# [ZJOI2017] 仙人掌

## 题目描述

如果一个**无自环无重边无向连通图**的任意一条边最多属于一个简单环，我们就称之为仙人掌。所谓简单环即不经过重复的结点的环。

 ![](https://cdn.luogu.com.cn/upload/pic/4742.png) 

现在九条可怜手上有一张**无自环无重边的无向连通图**，但是她觉得这张图中的边数太少了，所以她想要在图上连上一些新的边。同时为了方便的存储这张无向图，图中的边数又不能太多。经过权衡，她想要加边后得到的图为一棵仙人掌。

不难发现合法的加边方案有很多，可怜想要知道总共有多少不同的加边方案。

两个加边方案是不同的当且仅当一个方案中存在一条另一个方案中没有的边。


## 说明/提示

**样例说明**

对于第一组样例合法加边的方案有 {},{(2,3)}，共 2 种。

**时空限制**

时间限制1s，空间限制512M。

**数据范围**

![](https://cdn.luogu.com.cn/upload/pic/4743.png)


## 样例 #1

### 输入

```
2
3 2
1 2
1 3
5 4
1 2
2 3
2 4
1 5```

### 输出

```
2
8```

# 题解

## 作者：brealid (赞：52)

整个算法范围两部分：判断仙人掌与得出答案

## Part 1 判断仙人掌

对于一个**无自环无重边的无向连通图**，方案数非 $0$ 当且仅当这个图本身满足仙人掌的性质（即：任意一条边最多属于一个简单环）。

因此我们需要判断仙人掌。

注意这道题的特殊性，你会发现，一个简单环对答案是无贡献的（原因请看 Part 2）。

因此我们不需要存储每个环包括多少条边，以及包含的边是什么。**我们只需要对处于简单环中的边打上删除标记即可**。

因此，在仙人掌判断中，  
$\color{red}\texttt{你不需要 tarjan, 或者树上差分，你只需要暴力}$  
**解释** 在 dfs 中，当你发现这条边指向的节点不是父亲，但却已经被访问过，设这条边为 $u-v$，那么 $u-v-LCA(u,v)-u$ 构成一个环，你只需要用类似**暴力**求LCA的方法一层层往上爬，并对爬到的边打标记即可。不要忘了给 $u-v$ 打上删除标记。

**正确性** 一条边至多只可能被打一次的删除标记。如果被打第二次，那么可以判断这条边至少处于两个简单环中，因此立即返回并输出 $0$（无解）。

注意，  
$\color{red}\texttt{1. 你最好需要邻接表存图。}$  
**解释** 因为若你对一条边 u-v 打标记，你肯定也要对 v-u 打标记。使用编号从 $0$ 开始的邻接表时，如果要对编号为 $e$ 的边打标记，对 $\lfloor\frac{e}{2}\rfloor$ 打标记即可。使用 $vector$ 存图会麻烦很多。  
$\color{red}\texttt{2. 你最好需要存，从父亲节点到自己的边的编号。}$  
**解释** 因为在暴力对一个环上的边打标记时，存下这条“到父边”（姑且让我用这个名词吧）可以保证跳到父亲的复杂度为 $\Theta(1)$ 的。不存这条边，只能暴力搜索出边，均摊复杂度 $\Theta(\frac{m}{n})$。（当然，你要跟我说最好情况都是 $\Omega(1)$，我也没办法。但是出题人大概率不会这么良心。）  
$\color{red}\texttt{3. 一旦发现当前图不是仙人掌，立即返回。}$  
**解释** 如果等到搜索结束再返回，复杂度可以被卡到最坏 $O(n^2)$。

## Part 2 求解仙人掌
现在我们已经确定原图为仙人掌（非仙人掌右转 ``puts("0")``），并且对环上的边打上了删除标记。

$\color{blue}\texttt{Q:}$ 为什么“环上的边对答案无贡献”？  
$\color{blue}\texttt{A:}$ 显然，环上的边已经处于一个简单环之中。因此根据仙人掌的定义，我们不能把这些“环上的边”包含到其他简单环之中。因此这些边不可能对答案有贡献。

**引理** 考虑到原图已经被我们划分成了一些树，而且这些树之间是不会互相影响的。  
**证明** 注意到，如果你想对两棵树上的两个节点连边，由于原图是**无向连通图**，因此这两棵树原来肯定被一条**环上的链**所连接。因此，若要对这两棵树上的这两个节点连边，原来**环上的链**就会被覆盖 $2$ 次，不符合仙人掌定义。

因此，我们可以对每棵树单独求解，然后将答案利用**乘法原理**乘起来即可。

---

考虑现在我们达到了什么。  
我们成功将一道 **仙人掌** 上的问题转化成了 **树** 上的问题（部分分 #6~#7）

---

考虑设计 $DP$。  

先把辅助数组 $h$ 讲了。  
$h[i]$ 表示**有 $i$ 个点，它们之间匹配的方案数**  
简单来讲，现在有 $i$ 个点，都是某个节点 $u$ 的孩子，而且这 $i$ 个节点各自到 $u$ 的边都没有被简单环覆盖（易知：$i=\operatorname{size_{Children_u}}$）  
考虑到如果连一条边 $v-w$ 那么 $v-u$ 与 $w-u$ 这两条边都会被覆盖。  
故：一个点 $v$ 最多只能与它的兄弟连一条边。  

由于 $h$ 值与树的形态无关，可以预处理。  
假设已有 $i - 1$ 个点，现在加入 $1$ 个点。   
这个点可以不与任何兄弟连边，方案数为 $h[i - 1]$  
这个点可以选择与一个兄弟连边，有 $i - 1$ 种选择，每种选择带来 $h[i - 2]$ 的贡献，方案数 $(i - 1)·h[i - 2]$  

所以，  
$$h[i] = h[i - 1] + (i - 1)·h[i - 2]$$

$\color{red}\texttt{这时候你要想清楚这个状态为什么设计。}$

设计状态 $g[u]$ 表示**节点 $u$ 可向上拓展** 的方案数。

考虑 $g[u]$ 的转移。  
由 $g[u]$ 的意义，我们需要在 $u\cup\operatorname{Children_u}$ 中选出一个节点，作为**接口节点**，可以同父亲的其他直接孩子的子树节点连接。  
因为 $u-fa[u]$ 这条边最多只能属于一个简单环，所以保留一个**接口节点**即可。  

我们有 
$$g[u] = h[Deg + 1] · \prod_{v\in \operatorname{Children_u} }g[v]$$  

其中 $Deg$ 表示 $\operatorname{size_{Children_u}}$

注意到，此时我们将节点 $u$ 自身也作为 $\operatorname{Children_u}$ 的一个兄弟来计算。关于这点，理解方式有二：
1. $g[u] = h[Deg] · \prod_{v\in \operatorname{Children_u} }g[v] + Deg · h[Deg - 1] · \prod_{v\in \operatorname{Children_u} }g[v]=\texttt{原式}$  
   如果把 $u$ 自身作为**接口节点**，方案数为加号左边，不解释；  
   如果把 $u$ 的一个孩子作为**接口节点**，方案数为加号右边。  
   - 解释：选择一个孩子（$Deg$）剩下的任意匹配（$h[Deg - 1] $）再乘上孩子的 $g$ 值（$\prod_{v\in \operatorname{Children_u} }g[v]$）
2. 如果在 $h[Deg + 1]$ 种匹配中，
   - $u$ 被连边：假设 $u-v$ 被连，那么这条边的意义**不是连接**，而是选定 $v$ 作为**接口节点**
   - $u$ 未被连边：$u$ 即**接口节点**

然而，
$\color{red}\texttt{答案不是 g[root]}$

考虑到在 $g$ 的转移中，有可能 $u-v$ 被连 $(v\in \operatorname{Children_u})$。这时，按照我们的理解，$v$ 被选中作为接口节点。  
**但是 $root$ 节点不再向上延伸，$root$ 节点不需要接口节点，接口节点的存在只会导致答案重复统计**  
在 $g$ 的转移中，我们确实重复统计了一些边的贡献，**但是这“重复统计”的前提是“接口节点”**  
意即：$g[u]$ 被 $fa[u]$ 所统计，才是“重复统计”的正确性之源。

$\color{red}\texttt{对于一棵树，答案是 }h[Deg_{root}] · \prod_{v\in \operatorname{Children_{root}} }g[v]$

这样不会重复统计。  
这也就是其他很多题解中提到的 $f$ 数组。

## 代码

见 gitee 仓库 https://gitee.com/hkxa/mycode/blob/master/luogu/P3687.cpp

---

## 作者：Ubospica (赞：27)

安利博客>_< [luogu3687-[ZJOI2017] 仙人掌 - Ubospica - 博客园](https://www.cnblogs.com/ubospica/p/10551440.html)

我们先考虑只有一棵树如何处理.

仙人掌可以看做若干环的集合. 特别的, 对于一条没有环的边, 可以加上重边, 那么这个边和它的重边构成一个环.

对于树来说, 问题就可以转化为求加上若干条边, 使树上的每一条边在且仅在一个环内的方案数.

去掉加的边, 也就是说求用若干条边不相交的链将整个树覆盖的方案数.

考虑树形dp.

设 $f_i$ 表示考虑 $i$ 的子树与 $i$ 连向父亲的边, 用若干条边不相交的链覆盖的方案数;

$g_n$ 表示一个点连出 $n$ 条边, 用若干条边不相交的链覆盖的方案数, 也就是说, 将 $n$ 条边两两匹配或者单独留下的方案数.

考虑最后一条边是否匹配, 我们可以得出 $g_i$ 的通项:

$$g_i = g_{i-1} + g_{i-2} \cdot (i-1)$$


然后求 $f_i$: 

对于非根的点 $i$, 它连出了 $|child(i)| + 1$ 条边. 可以考虑将 $f_j$ 连向父亲的边两两匹配或者单独留下, 根据乘法原理, 有 

$$f_i = \prod_{j \in child(i)} f_j \cdot g_{|child(i)| + 1}$$

对于$i = rt$, 它没有连向父亲的边, 因此 

$$f_i = \prod_{j \in child(i)} f_j \cdot g_{|child(i)|}$$

答案即为 $f_{rt}$.

最后考虑其他的图怎么做: 

如果不是仙人掌, 答案为0;

如果图是仙人掌:  

对于仙人掌的一个环上的两点 $p$ 和 $q$, 显然不能再加边使它们在环外联通. 因此, 我们可以去掉所有的环, 对于剩下的每棵树分别求出答案, 对答案相乘即可.

## Code
```
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<set>
#include<map>
using namespace std;
#define rep(i,l,r) for(register int i=(l);i<=(r);++i)
#define repdo(i,l,r) for(register int i=(l);i>=(r);--i)
#define il inline
typedef double db;
typedef long long ll;

//---------------------------------------
const int nsz=5e5+50,msz=1e6+50;
const ll nmod=998244353;
int t,n,m;

struct te{int t,pr,del;}edge[msz*2];
int hd[nsz],pe=1;
#define forg(p,i,v) for(int i=hd[p],v=edge[i].t;i;i=edge[i].pr,v=edge[i].t)
void adde(int f,int t){edge[++pe]=(te){t,hd[f],0};hd[f]=pe;}
void adddb(int f,int t){adde(f,t);adde(t,f);}

ll g[nsz];
void init(int bnd){
	g[0]=1,g[1]=1;
	rep(i,2,bnd)g[i]=(g[i-1]+g[i-2]*(i-1))%nmod;
}


int vis[nsz],stkp[nsz],stk[nsz],top=0;
bool solcactus(int p,int e0){
	stk[++top]=e0^1,stkp[p]=top,vis[p]=1;
	forg(p,i,v){
		if(i==e0)continue;
		if(vis[v]){//cir
			if(stkp[v]>stkp[p])continue;
			edge[i].del=edge[i^1].del=1;
			rep(j,stkp[v]+1,stkp[p]){
				if(edge[stk[j]].del)return 0;
				edge[stk[j]].del=edge[stk[j]^1].del=1;
			}
			continue;
		}
		if(solcactus(v,i^1)==0)return 0;
	}
	--top;
	return 1;
}

ll dp[nsz];
void dfs(int p,int fa){
	dp[p]=1,vis[p]=1;
	int cnt=0;
	forg(p,i,v){
		if(v==fa||edge[i].del)continue;
		dfs(v,p);
		dp[p]=dp[p]*dp[v]%nmod;
		++cnt;
	}
	dp[p]=dp[p]*(fa==0?g[cnt]:g[cnt+1])%nmod;
}

ll sol(){
	memset(vis,0,(n+10)*sizeof(int));
	top=0;
	if(solcactus(1,0)==0)return 0;
	memset(vis,0,(n+10)*sizeof(int));
	ll res=1;
	rep(i,1,n){
		if(vis[i]==0)dfs(i,0),res=res*dp[i]%nmod;
	}
	return res;
}



void init1(int n){
	memset(hd,0,(n+10)*sizeof(int));
	pe=1;
}

int main(){
	ios::sync_with_stdio(0),cin.tie(0);
	init(5e5+50);
	cin>>t;
	rep(cs,1,t){
		cin>>n>>m;
		init1(n);
		int a,b;
		rep(i,1,m)cin>>a>>b,adddb(a,b);
		cout<<sol()<<'\n';
	}
	return 0;
}
```

---

## 作者：yjjr (赞：19)


# 题意

给定一个无向连通图，添加一些边，使其变为仙人掌

问方案数

# 分析

我大概。。。只会写10分暴力+20分特判吧

------

正解如下

首先特判这张图是否是仙人掌，如果是，那么输出0

显然环是对答案不产生贡献的，那么破环为链

这样原图转化成一棵树，部分分设置的用意如此

用h[i]表示有i个点，它们之间匹配的方案数

h[i]=h[i-1]+(i-1)*h[i-2]

- 如果i节点不与其他节点相连，那么方案就是h[i−1]
- 如果与其他节点连接，那么有(i−1)中选择方式，而当选择一个点以后，有两个点不能再连接，那么方案就是(i−1)∗h[i−2]

用f[i]表示子树i的方案数,g[i]表示可向上拓展的子树的方案数，num表示子树的节点个数（即大小）

$$f[i]=h[num]*\prod g[son](son\in Child(i))$$

每一个子节点都可以向上扩展并相对独立，然后一共有h[num]种儿子的匹配方案

$$g[i]=f[i]+h[num-1]*num*\prod g[son](son\in Child(i))$$

该节点可以自己想上扩展为f[i]，并且有num个子节点，每个子节点还可以选择一个儿子，并且一共有h[num-1]种匹配方案

# code
```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#define rep(i,a,b) for(register int i=a;i<=b;i++)
#define dep(i,a,b) for(register int i=a;i>=b;i--)
#define ll long long
#define mem(x,num) memset(x,num,sizeof x)
#define reg(x) for(int i=last[x];i;i=e[i].next)
using namespace std;
inline ll read()
{
	ll f=1,x=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int mod=998244353,maxn=5e5+6,maxm=1e6+6;
struct edge{int to,next,from;}e[maxm*2];
bool isca,vis[maxn],flag[maxm*2];ll f[maxn],g[maxn],h[maxn],ans;
int que[maxn],dfn[maxn],low[maxn],col[maxn],tim,top,T,n,m,cnt,last[maxn];
void insert(int u,int v){
	e[++cnt]=(edge){v,last[u],u};last[u]=cnt;flag[cnt]=1;
	e[++cnt]=(edge){u,last[v],v};last[v]=cnt;flag[cnt]=1;
}
void tarjan(int x,int fa){
	bool flag=0;
	dfn[x]=low[x]=++tim;que[++top]=x;
	reg(x){
		if(e[i].to==fa)continue;
		if(!dfn[e[i].to]){
			tarjan(e[i].to,x);
			low[x]=min(low[x],low[e[i].to]);
			if(low[e[i].to]<dfn[x]){
				if(flag){isca=0;return;}
				flag=1;
			}
		}else{
			low[x]=min(low[x],dfn[e[i].to]);
			if(dfn[e[i].to]<dfn[x]){
				if(flag){isca=0;return;}
				flag=1;
			}
		}
	}
	if(low[x]==dfn[x])
		while(true){
			col[que[top--]]=x;
			if(que[top+1]==x)break;
		}
}
void dfs(int x,int fa){
	vis[x]=1;f[x]=1,g[x]=0;
	int num=0;
	reg(x){
		if(!flag[i]||e[i].to==fa)continue;
		dfs(e[i].to,x);
		f[x]=f[x]*g[e[i].to]%mod;
		num++;
	}
	g[x]=(f[x]*h[num]%mod+f[x]*h[num-1]%mod*num%mod)%mod;
	f[x]=f[x]*h[num]%mod;
}
int main()
{
	h[0]=h[1]=1;
	rep(i,2,maxn-5)h[i]=(h[i-1]+(h[i-2]*(i-1)%mod))%mod;
	T=read();
	while(T--){
		isca=1,ans=1;cnt=tim=top=0;
		n=read(),m=read();
		rep(i,1,n){vis[i]=0;last[i]=col[i]=dfn[i]=low[i]=0;}
		rep(i,1,m){
			int u=read(),v=read();
			insert(u,v);
		}
		tarjan(1,0);
		if(!isca){printf("0\n");continue;}
		rep(i,1,cnt)if(col[e[i].from]==col[e[i].to])flag[i]=0;
		rep(i,1,n){
			if(vis[i])continue;
			dfs(i,0);
			ans=ans*f[i]%mod;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```






---

## 作者：LebronDurant (赞：16)

网上题解我看了很多，我感觉虽然说所有题解做法都是对的，但是好多人的理解却是完全不对的。有一种做法是$dp_{i}$表示$i$子树和上面一条边的方案数，然后$dp_i=h[du[i]]\prod\limits_{j\in{son[i]}}dp_j$。这个按照把每个儿子的答案乘起来然后乘$i$点相邻的边的方案来理解的话其实是完全不对的。因为如果一个儿子子树的方案覆盖了$j$往上的边，$i$相邻的方案数其实小于$h[du[i]$，但是为什么他对了呢？因为他有些情况少考虑了，就是跨越$(i,j)$的一个较长的边也是合法的。其实可以通过第二种树dp，也就是yjjr大佬的题解的做法，可以推导出以上的做法其实是对的。我通过看neither_nor的题解的启发，想出一种理解方法，如有不严谨请评论指出，谢谢大家。

还是$h[i]$表示$n+1$个点的菊花图的方案数，也就是只考虑一个点的所有出边两两配对或者单拎出来的方案书，递推式$h[i]=h[i-1]+h[i-2]\times(i-1)$，不解释了。

原图不是仙人掌输出0，去环，两个不同联通块不可以有边，否则不是仙人掌，变成树dp，把每个树的方案乘到一起就是最终答案。

考虑把所有合法方案的仙人掌的桥都加一条重边，那么这个问题就变成了用边不相交的链覆盖树上每一条边。那么考虑任意一种方案，相当于是对于每一个点我们把他的所有出边两两配对，或者单拎出来。每个点任意一种分配方式都能合成一个整棵树的合法方案。那么根据乘法原理，最终答案就是$\prod{h[du[i]]}$，文章最开始我认为的错误做法的式子和这个等价。
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
#include<vector>
using namespace std;
#define N 1000012
typedef long long ll;
const int p=998244353;
struct edge{int to,nxxt;}e[N<<1];
int T,n,m,head[N],cnt,h[N],du[N],fa[N][21],dep[N];
int a[N][2],tot,su[N],wh[N];
bool vis[N],ban[N<<1];
void dfs(int te)
{
	for(int i=head[te];i;i=e[i].nxxt)
	{
		int j=e[i].to;if(vis[j])
		{if(j!=fa[te][0]&&dep[j]<dep[te])a[++tot][0]=te,a[tot][1]=j,ban[i]=ban[i^1]=1;
			continue;
		}vis[j]=1;
		dep[j]=dep[te]+1;fa[j][0]=te;wh[j]=i;dfs(j);
	}
}
void clfs(int te)
{
	for(int i=head[te];i;i=e[i].nxxt)
	{
		int j=e[i].to;if(vis[j])continue;vis[j]=1;
		clfs(j);su[te]+=su[j];
	}
}
inline int lca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i=20;~i;i--)if(dep[fa[x][i]]>=dep[y])x=fa[x][i];
	if(x==y)return x;
	for(int i=20;~i;i--)if(fa[x][i]^fa[y][i])x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
inline void ins(int u,int v){e[cnt].to=v;e[cnt].nxxt=head[u];head[u]=cnt++;}
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++)head[i]=du[i]=vis[i]=su[i]=0;cnt=2;
		h[0]=h[1]=1;for(int i=2;i<=n;i++)h[i]=(h[i-1]+1ll*h[i-2]*(i-1)%p)%p;
		for(int i=1;i<=m;i++)
		{
			int x,y;scanf("%d%d",&x,&y);
			ins(x,y);ins(y,x);
		}for(int i=1;i<=cnt;i++)ban[i]=0;
		vis[1]=1;dep[1]=tot=0;fa[1][0]=1;dfs(1);
		for(int i=1;i<=20;i++)for(int j=1;j<=n;j++)fa[j][i]=fa[fa[j][i-1]][i-1];
		for(int i=1;i<=tot;i++)
		{
			int x=a[i][0],y=a[i][1],gf=lca(x,y);
			//printf("%d %d fk\n",x,y);
			su[x]++,su[y]++,su[gf]-=2;
		}for(int i=1;i<=n;i++)vis[i]=0;
		vis[1]=1;clfs(1);bool cc=true;
		for(int i=1;i<=n;i++)
		{
			if(su[i]>=2){cc=false;break;}
		}if(!cc){puts("0");continue;}
		for(int i=1;i<=n;i++)if(su[i])ban[wh[i]]=ban[wh[i]^1]=1;
		int ans=1;
		for(int i=1;i<=n;i++)
		{
			for(int j=head[i];j;j=e[j].nxxt)if(!ban[j])du[i]++;
			//printf("%d ",du[i]);
			ans=1ll*ans*h[du[i]]%p;
		}//puts("");
		printf("%d\n",ans);
	}
}
/*
1
3 3
1 2
1 3
2 3
*/
```


---

## 作者：nofind (赞：7)

## [题意](https://www.luogu.com.cn/problem/P3687)

本题解可以算作是yjjr题解的详细版。

先判断是否为仙人掌，如果不是输出$0$。

考虑一个仙人掌，显然环是没用的，我们将所有环边去掉，形成一个森林，对每个森林求解，最后乘到一起。

现在我们要求一颗树的答案：  
对于一个方案，如果有一条边没在任何一个环中，我们给它加一条重边，使得它与重边构成一个环。于是问题变为求用不相交的链覆盖整棵树的方案数。  

对于一颗子树，显然只会有一条链可以向上延伸，因为如果有两条链都向上延伸必定有一条边被覆盖了两次。因此我们这样设计状态：  
设$f_{x}$表示$x$的子树，没有链向上延伸的方案数，$g_{x}$表示有一条链向上延伸的方案数。

考虑转移：  
设$num$为$x$的儿子数。  
$1.f_x=h_{num}\prod\limits_{y\in son_x} g_y$（$h$的定义见下面）。  
解释一下：  
我们要让$x$的子树没有向上延伸的链，也就是说所有向上延伸的链都要在这里结束，而每条链有两种结束方式：连到$x$上或连到另一个儿子向上延伸的链的端点。   
如下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/y069rvep.png)
于是我们要求$h_{num}$表示$x$有$num$时的方案数。  
考虑这个问题实际就是每个儿子要么单独要么和别的链匹配，可以递推：  
$h_i=h_{i-1}+h_{i-2}*(i-1)$，即考虑$i$如何选择。

$2.g_{x}=f_x+\sum\limits_{y\in son_x}g_y\times h_{num-1}\prod\limits_{z\in son_x,z\not=y}g_z=num\times h_{num-1}\times\prod\limits_{y\in son_x}g_y$

首先$x$向上延伸的方案数为$f_x$。  
之后枚举继续延伸哪条链，设为儿子$y$的，那么其他的方案数为$h_{num-1}\prod\limits_{z\in son_x,z\not=y}g_z$，推一推式子就变成上面哪样了。

复杂度：$O(n)$。

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e5+10;
const int maxm=1e6+10;
const int mod=998244353;
int T,n,m,cnt_edge=1,tim,top,ans;
int head[maxn],dfn[maxn],low[maxn],sta[maxn],col[maxn],f[maxn],g[maxn],h[maxn];
bool flag;
bool vis[maxn],ban[maxm<<1];
struct edge{int to,nxt;}e[maxm<<1];
inline int read()
{
    char c=getchar();int res=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9')res=res*10+c-'0',c=getchar();
    return res*f;
}
inline void add_edge(int u,int v)
{
	e[++cnt_edge].nxt=head[u];
	head[u]=cnt_edge;
	e[cnt_edge].to=v;
	ban[cnt_edge]=0;
}
inline void init()
{
	for(int i=1;i<=n;i++)head[i]=dfn[i]=low[i]=col[i]=vis[i]=0;
	flag=1,ans=cnt_edge=1;top=tim=0;
}
void tarjan(int x,int fa)
{
	dfn[x]=low[x]=++tim;
	sta[++top]=x;
	bool flag1=0;
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(y==fa)continue;
		if(!dfn[y])tarjan(y,x),low[x]=min(low[x],low[y]);
		else low[x]=min(low[x],dfn[y]);
		if(low[y]<dfn[x])
		{
			if(flag1){flag=0;return;}
			flag1=1;
		}
	}
	if(!flag)return;
	if(dfn[x]==low[x])
		while(1)
		{
			col[sta[top--]]=x;
			if(sta[top+1]==x)break;
		}
}
void dfs(int x,int fa)
{
	vis[x]=1;
	f[x]=1,g[x]=0;
	int num=0;
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(ban[i]||y==fa)continue;
		dfs(y,x);
		f[x]=1ll*f[x]*g[y]%mod;
		num++;
	}
	g[x]=(1ll*f[x]*h[num]%mod+1ll*f[x]*h[num-1]%mod*num%mod)%mod;
	f[x]=1ll*f[x]*h[num]%mod;
}
inline void solve()
{
	n=read(),m=read();
	init();
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read();
		add_edge(u,v);add_edge(v,u);
	}
	tarjan(1,0);
	if(!flag){puts("0");return;}
	for(int i=2;i<=cnt_edge;i++)if(col[e[i].to]==col[e[i^1].to])ban[i]=1;
	for(int i=1;i<=n;i++)
	{
		if(vis[i])continue;
		dfs(i,0);
		ans=1ll*ans*f[i]%mod;
	}
	printf("%d\n",ans);
}
int main()
{
	h[0]=h[1]=1;
	for(int i=2;i<=maxn-10;i++)h[i]=(h[i-1]+1ll*(i-1)*h[i-2]%mod)%mod;
	T=read();
	while(T--)solve();
	return 0;
}
```


---

## 作者：lcjqwq (赞：4)

### Description 

给定一张 $n$ 个点 $m$ 条边的无向简单连通图，问有多少种加边方法使其是一颗仙人掌。

$n \leq 5\cdot 10^5, m \leq \min\{\frac{n\cdot(n+1)}{2}, 10^6\}$  

### Solution

若原图不是一颗仙人掌，直接输出 $0$ 即可。

若其是一颗仙人掌，其中的环对答案没有贡献（既不能在其中加边，也不能向外连边），可以直接把与这个环相关的边删掉。剩下的即是一颗森林。求出每棵树的方案数将其直接累乘即可。

如果图是树的情况下怎么做？发现如果在一颗树找出若干个不相交的链，每个链的首尾连一条边，那么这个图一定是仙人掌；反之，最后加完边的图，加上的每一条边都对应一条链，每一条边也只会属于至多一个环即至多属于一个树链加上加上的边。所以问题转化成在一棵树中找出若干不相交的链的方案数。 这样还是不是特别好做，如果我们把那些没有在任何一个环的树边看成在他与他自己的环里，那么问题就转化成了 **用若干条不相交的链覆盖整颗树的方案数** 。

考虑树形dp。令 $dp_u$ 为 $u$ 的子树中所有边加上他到父亲的一条边的方案数。令 $f_x$ 表示一个点的度数为 $x$，把所有与它相连的边用长度不超过 $2$ 的链全部覆盖的方案数，则 $dp_u = f_{deg_u}\Pi _vdp_{v}$ 。其中 $v$ 是 $u$ 的子节点，$deg_u$ 是 $u$ 的度数。

$f$ 考虑用递推求。每次新加入一条边，他可以自己是一条链，也可以与之前的一条匹配成一条链。易得 $f_n = f_{n-1}+(n-1)\cdot f_{n-2}$ 并且 $f_0 = f_1= 1$ 。

复杂度 $O(n+m)$ 

### Code

[看代码戳这里](https://acfunction.github.io/2019/06/21/BZOJ4784/#Code)

---

## 作者：5ab_juruo (赞：3)

给一种不同的 DP 推法。

首先考虑一棵树怎么做。给一条链加上一条边形成一个简单环，等价于把这条链上所有边删掉。所以，每一个构建仙人掌的方案等价于覆盖树上链边的方案，且由于不能加重边，每条链至少经过两条边。

令 $par_i$ 为 $i$ 的父亲，$(u,v)$ 为连接 $u$ 和 $v$ 两点的边。$S_i$ 为 $i$ 的孩子集合。

定义 $f_i$ 为不覆盖 $(par_i,i)$ 时，$i$ 子树内的方案数，$g_i$ 为覆盖 $(par_i,i)$，且保证链长至少为 $2$ 时，$i$ 子树内的方案数。如果要以 $i$ 为起点覆盖 $(par_i,i)$，则方案数显然等于 $f_i$。

当 $i$ 向 $par_i$ 转移时，每个子树有两种选择：

- 不拓展 $(par_i,i)$，可以是把父亲当成终点，也可以根本不覆盖 $(par_i,i)$，方案数是 $f_i+g_i$；
- 拓展 $(par_i,i)$，可以是从 $i$ 开始，或者伸长一条本来存在的边，方案数也是 $f_i+g_i$。

所以，对于 $x$ 节点，有 $j$ 个孩子拓展的方案数即为 $\displaystyle \binom{|S_x|}{j}\prod_{c\in S_x} (f_c+g_c)$。相对应的转移有两种（$!!$ 代表双阶乘）：

- $j$ 是偶数，则孩子两两配对有 $(j-1)!!$ 种方案，转移到 $f_x$。
- $j$ 是奇数，先钦定一个孩子继续向上拓展，剩下的两两配对，一共有 $j\times (j-2)!!=j!!$ 种方案，转移到 $g_x$。

即：

$$
\begin{aligned}
f_{x}&=\sum_{j\bmod{2}=0}^{|S_x|} \binom{|S_x|}{j} (j-1)!!\prod_{c\in S_x} (f_c+g_c)\\
g_{x}&=\sum_{j\bmod{2}=1}^{|S_x|} \binom{|S_x|}{j} j!!\prod_{c\in S_x} (f_c+g_c)
\end{aligned}
$$

最终的答案即为 $f_{root}$。

拓展到一般情况，当且仅当原图是仙人掌才可能有解，可以用树上差分平凡判断。删掉原图中所有原有的环后，每个连通块都是树，各自求解后求乘积即可。

```cpp
const int max_n = 500000, max_m = 1000000, mod = 998244353;

int hd[max_n], des[max_m * 2], nxt[max_m * 2], u[max_m], v[max_m], e_cnt = 0;
int df[max_n], par[max_n], ps[max_n], dep[max_n], ind = 0;
bool in[max_n], vis[max_n];
mint dp[max_n][2], fac[max_n + 1], ifac[max_n + 1];

void add(int s, int t)
{
	des[e_cnt] = t;
	nxt[e_cnt] = hd[s];
	hd[s] = e_cnt++;
}

void dfs1(int id, int fa)
{
	vis[id] = true;
	par[id] = fa;
	ps[ind++] = id;
	
	for (int p = hd[id], dst; p != -1; p = nxt[p])
	{
		dst = des[p];
		if (!vis[dst])
		{
			dep[dst] = dep[id] + 1;
			dfs1(dst, id);
		}
		else if (dst != fa)
		{
			if (dep[id] > dep[dst])
				df[dst]--, df[id]++;
		}
	}
}

void dfs2(int id, int fa)
{
	dp[id][0] = dp[id][1] = 0;
	
	mint prod = 1;
	int snc = 0;
	for (int p = hd[id], dst; p != -1; p = nxt[p])
	{
		dst = des[p];
		if (dst != fa)
		{
			dfs2(dst, id), snc++;
			prod *= dp[dst][0] + dp[dst][1];
		}
	}
	mint ef = 1;
	for (int i = 0; i <= snc; i++)
	{
		if (i & 1)
			ef *= i;
		dp[id][i & 1] += ef * prod * fac[snc] * ifac[i] * ifac[snc - i];
	}
}

void initfac(int _lim)
{
	fac[0] = 1;
	for (int i = 0; i < _lim; i++)
		fac[i + 1] = fac[i] * (i + 1);
	ifac[_lim] = fac[_lim].inv();
	for (int i = _lim; i > 0; i--)
		ifac[i - 1] = ifac[i] * i;
}

signed main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	
	int cas;
	initfac(max_n);
	
	cin >> cas;
	while (cas--)
	{
		e_cnt = ind = 0;
		
		int n, m;
		cin >> n >> m;
		
		fill(df, df + n, 0);
		fill(hd, hd + n, -1);
		fill(in, in + n, true);
		fill(vis, vis + n, false);
		
		for (int i = 0, x, y; i < m; i++)
		{
			cin >> x >> y; x--, y--;
			u[i] = x, v[i] = y;
			add(x, y), add(y, x);
		}
		dfs1(0, -1);
		
		bool hans = true;
		
		e_cnt = 0;
		fill(hd, hd + n, -1);
		for (int _i = n - 1, i; _i >= 0; _i--)
		{
			i = ps[_i];
			if (par[i] != -1)
				df[par[i]] += df[i];
			if (df[i] == 0 && par[i] != -1)
			{
				add(par[i], i);
				in[i] = false;
			}
			else if (df[i] > 1)
			{
				hans = false;
				break;
			}
		}
		if (!hans)
		{
			cout << "0\n";
			continue;
		}
		
		mint ans = 1;
		for (int i = 0; i < n; i++)
			if (in[i])
			{
				dfs2(i, -1);
				ans *= dp[i][0];
			}
		
		cout << ans << "\n";
	}
	
	return 0;
}
```

---

## 作者：juju527 (赞：3)

## $\texttt{Solution}$

考虑很有启发性的树的情况。

对于一颗树加边变成仙人掌，由于仙人掌上每条边至多属于一个环，考虑设计一个树形dp计算方案数。

> 考虑得到点 $x$ 的答案，$y$ 为 $x$ 的某个孩子，$x$ 有 $siz$ 个子树。

设 $dp_x$ 为 $x$ 树内添边得到仙人掌的总方案数

显然，由于仙人掌的性质，$x$ 的每个子树 $y$ 内**最多**一个点往子树 $y$ 外连边

**最多**这个条件并不方便我们处理，考虑将其转换成**恰好**

我们钦定若 $y$ 子树内无点往外连，将 $y$ 点往外连一条**重边**

对应到仙人掌上，不连该重边即可，同时，仙人掌上的子树内若无边向外连，在原树上连一条重边即能对应

至此，我们将性质转换成了：$x$ 的每个子树 $y$ 内**恰好**一个点往子树 $y$ 外连边。

> 记子树 $y$ 内往外连边点为 $z$

继续考虑状态转移方程，每个 $z$ 仅有两种选择，向 $x$ 连边或和其他 $z$ 点配对。

容易发现所有 $z$ 的配对方案只与 $siz$ 有关，记为$f(siz)$。

考虑最后一个 $z$ 点的选法可得：

$f(siz)=f(siz-1)+(siz-1)\times f(siz-2)$

每个子树间仙人掌方案独立，直接乘起来。

每个 $z$ 点匹配方案也有两种情况：所有 $z$ 在 $x$ 子树内匹配完或选一个 $z$ 往 $x$ 树外走（根节点没有情况二）。

$dp_x=(\prod dp_y)\times(f(siz)+siz\times f(siz-1))$

$dp_{root}=(\prod dp_y)\times f(siz)$

至此，树的情况我们可以在 $O(n)$ 内得到答案。

考虑无向图的情况。

显然我们需要先判断该图是否为一个仙人掌，若已经不满足仙人掌条件，输出0

考虑图与树不一样的部分：环

![](https://pic.downk.cc/item/5f5898b3160a154a67fb2723.png)

如上图，红边为环边，能发现，环上点所在的子树（黑圈）是不能两两连边的，这样的蓝边会与红色环冲突

那么每个黑圈就独立了，一一算出贡献最后乘起来即答案

具体实现考虑把所有环边ban掉，剩下一个**森林**，直接每棵树跑一遍 $O(n)$ 树形dp即可

代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=5e5+5,maxm=1e6+5,mod=998244353;
struct Edge{
	int to,nxt;
}e[2*maxm];
int cnt;
int head[maxn];
bool ban[2*maxm];
int num;
int b[maxn],p[maxn];
int dfsnum;
int dfn[maxn],low[maxn];
bool vis[maxn];
stack<int>st;
ll f[maxn];
ll dp[maxn];
int read(){
	int x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*y;
}
void add(int u,int v){
	e[cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt++;
	return ;
}
bool ck;
void tarjan(int x,int fa){
	dfn[x]=low[x]=++dfsnum;
	st.push(x);
	vis[x]=1;
	bool flag=0;
	for(int i=head[x];i!=-1;i=e[i].nxt){
		int tmp=e[i].to;
		if(tmp==fa)continue;
		if(!dfn[tmp]){
			tarjan(tmp,x);
			low[x]=min(low[x],low[tmp]);
			if(low[tmp]<dfn[x]){
				if(flag){ck=1;return ;}
				flag=1;
			}
		}
		else{
			low[x]=min(low[x],dfn[tmp]);
			if(dfn[tmp]<dfn[x]){
				if(flag){ck=1;return ;}
				flag=1;
			}
		}
	}
	if(dfn[x]==low[x]){
		num++;
		p[num]=0;
		while(st.size()&&st.top()!=x){
			int k=st.top();
			vis[k]=0;
			b[k]=num;
			p[num]++;
			st.pop();
		}
		if(st.size()){
			vis[x]=0;
			b[x]=num;
			p[num]++;
			st.pop();
		} 
	}
	return ;
}
void dfs(int x,int rt){
	ll pai=1;
	int son=0;
	vis[x]=1;
	for(int i=head[x];i!=-1;i=e[i].nxt){
		int tmp=e[i].to;
		if(ban[i]||vis[tmp])continue;
		dfs(tmp,rt);
		pai=pai*dp[tmp]%mod;
		son++;
	}
	if(x^rt)dp[x]=pai*f[son+1]%mod;
	else dp[x]=pai*f[son]%mod;
	return ;
}
int main(){
//	freopen("cactus.in","r",stdin);
	f[0]=f[1]=1;
	for(int i=2;i<=5e5+1;i++)f[i]=(f[i-1]+1ll*(i-1)*f[i-2]%mod)%mod;
	int T;
	T=read();
	while(T--){
		int n,m;
		n=read();m=read();
		cnt=0;
		for(int i=1;i<=n;i++)head[i]=-1;
		for(int i=1;i<=m;i++){
			int u,v;
			u=read();v=read();
			add(u,v);
			add(v,u);
		}
		for(int i=0;i<cnt;i++)ban[i]=0;
		dfsnum=num=0;ck=0;
		for(int i=1;i<=n;i++)dfn[i]=low[i]=vis[i]=0;
		while(!st.empty())st.pop();
		tarjan(1,0);
		for(int i=1;i<=n;i++)vis[i]=0;
		for(int i=1;i<=n;i++){
			for(int j=head[i];j!=-1;j=e[j].nxt){
				int tmp=e[j].to;
				if(b[i]^b[tmp])continue;
				ban[j]=1;
			}
		}
		if(ck){puts("0");continue;}
		ll ans=1;
		for(int i=1;i<=n;i++){
			if(vis[i])continue;
			dfs(i,i);
			ans=ans*dp[i]%mod;
		}
		printf("%lld\n",ans);
	}
	return 0;
}

```

---

## 作者：qczrz6v4nhp6u (赞：2)

### Solution

首先考虑在树上怎么做。

不难想到扫描每条非树边，覆盖两点间路径，则最终图是仙人掌等价于没有一条边被覆盖两次或以上。

于是原问题可以转化成该问题：选择若干条长度至少为 $2$ 的路径，使路径上的边覆盖次数加一，求最终每条边覆盖次数都是 $0$ 或 $1$ 的方案数。

【长度至少为 $2$】很烦人，我们考虑将最终没有被覆盖的边连上一条重边，这样就转化为了：选择若干条长度至少为 $1$ 的路径，使路径上的边覆盖次数加一，求最终每条边覆盖次数都是 $1$ 的方案数。

继续转化。我们考虑先将原树连满重边，每一次操作改为：选择两条有一个端点相同的路径，并将这两条路径合并。

发现此时一个节点的操作不会影响到另一个结点，于是我们把它弱化到节点上考虑，分别求出后再乘起来：选择若干组点对，满足点对中的点均与当前节点相邻，且任意一个节点至多在一个点对内出现的方案数。

这个问题仅与度数有关，已经足够弱了。我们考虑 DP：

设 $f_n$ 为结点度数为 $n$ 时，上述问题的答案。分两种情况考虑：

- 第 $n$ 个点不与任何点配对。  
方案数为 $f_{n-1}$。

- 第 $n$ 个点与其中一个点配对。  
在剩下 $n-1$ 个点中任选一个配对，其他的该怎么选怎么选，方案数为 $(n-1)f_{n-2}$。

于是转移方程即为 $f_{n}=f_{n-1}+(n-1)f_{n-2}$。初值是 $f_{0}=f_{1}=1$。

我们解决了树的情况，考虑拓展到仙人掌（我们已经判掉了不是仙人掌的情况）。

容易发现，在环上的所有边都是不可被覆盖的。于是我们将环删掉，剩下一个森林，则森林的每棵树都是互相独立的，可以按照上述方法求出，分别求出后乘起来即可。

时间 / 空间复杂度均为 $O(n+m)$。

代码并不难写，就不放了。

---

## 作者：lgswdn_SA (赞：2)

看上去有点长，只不过把这道题我看了题解后的思路过程写了一下罢了。

首先我们对图进行分类讨论。如果图不是仙人掌，那么直接输出 0 即可。如果图存在环，那么我们之后加的边肯定不会跨过这个环，所以我们把仙人掌拆分成无环的几个部分（把环给丢掉），形成了几棵独立的树。所以我们最终还是要在树上做。

然后我们考虑加边变成环其实等价于找到几条互相没有交集的路径，然后路径的端点连边，就能构成仙人掌。所以问题转化成了在树上有多少选择若干条互相没有交集的仙人掌的方案数。

我们可以考虑 DP。关于树上路径的覆盖选择问题可以这样设状态 $f_{u,0/1}$ 表示 $u$ 及其子树，是否会有一条从 $u$ 子树生长到祖先的路径。

下图中黑色边代表树上的边/路径，橙色边代表加的边。下图左边描述的就是 $f_{u,0}$ 所覆盖的情况，我们发现所有的子树中的点的路径 $(x,y)$ 和 $(z,u)$ 等都在子树内。而右图的 $(z,u)$ 就是一条准备伸展到祖先的路径，它最后和祖先（或者兄弟）$w$ 连边，这个 $w$ 在子树外。容易证明，不可能存在两条连接到外部的路径，因为这样 $(u,fa_u)$ 就会被重复覆盖到。

![image.png](https://i.loli.net/2021/05/08/wYCEaReyOWGAqUD.png)

所以接下来我们的转移其实比较容易。首先对于 $f_{u,0}$，我们的每一个儿子节点伸展出来的链都可以选择与其他儿子节点伸展出来的链所匹配。  
下图中， $x$ 子树伸展出来的路径为 $(x,a)$，$y$ 子树的为 $(y,b)$。  
![image.png](https://i.loli.net/2021/05/08/Psa9Aph1idEfHyw.png) 

我们需要一个辅助数组 $g_i$ 表示 $i$ 个儿子节点，每个儿子节点可以和别的未使用的儿子节点组成路径或者和根节点组成路径的方案数。我们有 $g_i=(i-1)g_{i-2}+g_{i-1}$，很好想明白是怎么回事儿。

所以 $f_{u,0}$ 的方案是（$cs_u$ 代表儿子数量）

$$
f_{u,0}=g_{cs_u}\prod_{v\in son_u} f_{v,1}
$$

然后考虑 $f_{u,1}$ 的转移。我们要选择出一个儿子节点，它的伸展出来的路径成为 $u$ 伸展出来的路径，或者我们也可以直接选取 $u$ 这个点作为伸展出去的路径的起始点。所以我们有

$$
\begin{aligned}
f_{u,1}&=f_{u,0}+\sum_{v\in son_u} f_{v,1} \times (g_{sc_u-1} \prod _{w\in son_u, w\neq v}f_{v,1})\\
&= f_{u,0}+sc_u\times g_{sc_u-1}\prod_{v\in son_u}f_{v,1}
\end{aligned}
$$

```cpp
#define int long long
#define rep(i,a,b) for(register int i=(a);i<=(b);i++)
#define per(i,a,b) for(register int i=(a);i>=(b);i--)
using namespace std;
const int N=1e6+9,mod=998244353;

inline long long read() {
    register long long x=0, f=1; register char c=getchar();
    while(c<'0'||c>'9') {if(c=='-') f=-1; c=getchar();}
    while(c>='0'&&c<='9') {x=(x<<3)+(x<<1)+c-48,c=getchar();}
    return x*f;
}

int T,n,m,tick,dfn[N],low[N],rt[N],f[N][2],g[N],ans=1;
bool cactus=1,vst[N];
vector<int>e[N],t[N];

stack<int>st;
void dfs1(int u,int fa) {
	dfn[u]=low[u]=++tick, st.push(u);
	int ccnt=0;
	for(auto v:e[u]) if(v!=fa) {
		if(!dfn[v]) dfs1(v,u), low[u]=min(low[u],low[v]);
		else low[u]=min(low[u],dfn[v]);
		if(low[v]<dfn[u]) if((++ccnt)==2) {cactus=0; return;}
		if(cactus==0) return;
	}
	if(dfn[u]==low[u]) while(1) {
		int v=st.top(); st.pop(); rt[v]=u;
		if(v==u) break;
	}
}

void dfs2(int u,int fa) {
	int sc=t[u].size()-(fa!=0);
	vst[u]=1, f[u][0]=g[sc], f[u][1]=(sc>0?g[sc-1]*sc%mod:0);
	for(auto v:t[u]) if(v!=fa) {
		dfs2(v,u);
		f[u][0]=f[u][0]*f[v][1]%mod;
		f[u][1]=f[u][1]*f[v][1]%mod;
	}
	f[u][1]=(f[u][1]+f[u][0])%mod;
}

signed main() {
	T=read();
	while(T--) {
		n=read(), m=read();
		tick=0, ans=cactus=1;
		rep(i,1,n) dfn[i]=low[i]=rt[i]=f[i][0]=f[i][1]=g[i]=vst[i]=0;
		rep(i,1,n) e[i].clear(), t[i].clear();
		rep(i,1,m) {
			int u=read(), v=read();
			e[u].push_back(v), e[v].push_back(u);
		}
		g[0]=g[1]=1;
		rep(i,2,n) g[i]=((i-1)*g[i-2]+g[i-1])%mod;
		dfs1(1,0);
		if(!cactus) {puts("0"); continue;}
		rep(u,1,n) for(auto v:e[u]) if(rt[u]!=rt[v]) t[u].push_back(v);
		rep(i,1,n) if(!vst[i]) dfs2(i,0), ans=ans*f[i][0]%mod;
		printf("%lld\n",ans);
	}
	return 0;
} 
```

---

## 作者：福州周圣力 (赞：0)

首先判断整张图是否是一棵仙人掌：对原图做 DFS（也可以理解为 Tarjan），如果发现了一条非树边（由于是无向图，所以这条边一定是返祖边），那么说明图上存在环。此时暴力将环上的边全部标记：

一种方法是用类似于 Tarjan 的方法遍历，不过发生弹栈的条件不是 `low == dfn` 而是出现了非树边。

对于这题，我们还可以充分利用返祖边的性质。设当前节点为 $u$，返祖边的另一端点为 $v$，那么 $v$ 为 $u$ 的祖先，于是只需要在遍历树边时记录下每个点通往父节点的边的编号，然后在标记环时从 $u$ 不断往上标记树边（及其反边）直到碰到点 $v$ 为止。在标记过程中，如果碰到已经被标记过的边，那么说明原图不是一棵仙人掌。最后，我们还需要将那条非树边（及其反边）也打上标记。

如果整张图不是一棵仙人掌，那么答案为 $0$。如果整张图是一棵仙人掌，那么所有已经存在的环上不能继续加边，所以可以将所有的环边断开，此时图上剩下的点和边会构成若干棵树。由乘法原理不难得出，此时整张图的方案数即为剩下的子图中所有树的方案数的乘积。

**于是问题转化为，对于一棵树，由多少种不同的加边方案使其变成一棵仙人掌。**

对于计数类的树上问题，可以考虑使用树形 DP 求解。记 $f_i$ 表示以 $i$ 为根的子树中的方案数，那么对于非根节点有：

$$
f_i=\left(\prod\limits_{j\in S_i}f_j\right)\times g\left(|S_i|+1\right)
$$

对于根节点有：

$$
f_i=\left(\prod\limits_{j\in S_i}f_j\right)\times g\left(|S_i|\right)
$$

其中 $S_i$ 为 $i$ 的子节点的集合，$g(x)$ 表示当一个点连接了 $x$ 条边时，这个点被环覆盖的方案数。

对于 $g$ 的计算，可以使用下面这个递推式：

$$
g_i=g_{i-1}+(i-1)g_{i-2}
$$

解释：第一个部分的 $g_{i-1}$ 对应了环不覆盖这条边的情况，此时覆盖 $i$ 条边的方案数和覆盖其它的 $i-1$ 条边的方案数是一样的。第二个部分的 $(i-1)g_{i-2}$ 则是对应了这条边被环覆盖的情况，此时这个环中的非树边的另一端点为其它的 $i-1$ 个节点中的一个（注意另一个端点不能为中心节点，否则只会构成重边而不会构成环），除了这两个点之外，其它的点仍然可以按照原来的方案进行覆盖，故有 $g_{i-2}$ 种方案，根据乘法原理，第二个部分的总方案数为 $(i-1)g_{i-2}$。

[含参考代码的完整版题解](https://www.luogu.com.cn/paste/fvhur967)

---

## 作者：pengyule (赞：0)

[洛谷图挂了，在这里获得更好的阅读体验](https://www.cnblogs.com/impyl/p/15702533.html)

[原题链接](https://uoj.ac/problem/290)

[AC记录](https://uoj.ac/submission/520928)

## Part 0 基本思路
1. 如果给出的图一开始就不是仙人掌，则输出 0，否则：
2. 如果一条边处在某个环中，则新加的边一定不会跨过它。
3. 题目转化为求：把树上的边划为若干条路径的方案数。其中“路径”指由若干连续的边构成的链。
4. 考虑树形 dp。

## Part 1 判定仙人掌
判定无向连通图是否是仙人掌可以采用 dfs+树上差分的办法。具体来说，对图进行 dfs，那么会形成一个 dfs 树，对于当前遍历到的点 $x$，如果存在一条“返祖边”$(x,y)$，则可以让 $x$ 的差分值 $+1$，$y$ 的差分值 $-1$，表示 $x$ 到 $y$ 的树上路径中的边被一个环包含；一个点的差分值表示连接它与它父节点的边被覆盖的差分次数。再进行一轮 dfs 计算树上前缀和。图是仙人掌等价于最后每个点的值均 $\le 1$。

## Part 2 求强联通分量
下面阐述为什么需要求强联通分量。

![](https://img2020.cnblogs.com/blog/2405862/202112/2405862-20211217144451973-216513477.png)

考虑上图。新加的边一定不会跨过包含两个及以上点的强联通分量的任一条边【\*】。而 $\{3,7,9,1,2,5\},\{10\},\{4\},\{6\},\{8\}$ 为本图中的强联通分量。【\*】该如何翻译成程序可以执行的语言，是我们应该思考的问题。

目前来看，这个问题尚不好解决，我们先看下面的思路。

## Part 3 树形 dp
让我们先来考虑最为理想的情况：题图为一棵树。

根据 Part 0.3 的说法，我们可以设 $f_{i}$ 表示 $i$ 的子树内部的划分方案数。$\prod_{j\in son(i)}f_j$ 是容易想到的。现在就需要把 $i$ 的儿子连起来，那么需要乘以 $h_{|son(i)|}$，$h_i$ 表示的是

![](https://img2020.cnblogs.com/blog/2405862/202112/2405862-20211217151119160-1799391919.png)

就比如说![](https://img2020.cnblogs.com/blog/2405862/202112/2405862-20211217151231497-1090502097.png)就有![](https://img2020.cnblogs.com/blog/2405862/202112/2405862-20211217151310450-1429090492.png)和![](https://img2020.cnblogs.com/blog/2405862/202112/2405862-20211217151339106-750084796.png)两种划分方式。容易得出递推式 $h_i=h_{i-1}+(i-1)\cdot h_{i-2}$。解释：现在又多了一个儿子，那么这个儿子可以不跨根或者跨根，不跨根就是 $h_{i-1}$，跨根就还剩独立的 $i-2$ 个儿子，就是 $h_{i-2}$，而它选择跟哪个儿子又有 $(i-1)$ 种方案，总的就是 $(i-1)\cdot h_{i-2}$。

那答案是不是就是 $\prod_{j\in son(i)}f_j\cdot h_{|son(i)|}$ 呢？不是，因为无法实现跨儿子的路径。这时候我们就需要更改 $f_i$ 的定义了。改成表示 $i$ 的子树中跨 $i$ 和不跨 $i$ 的方案数之和。也就是可以在 $i$ 这里断开也可以不断开，都考虑到了。转移方程也有变化，就是 $\prod_{j\in son(i)}f_j\cdot h_{|son(i)|+1}$。$+1$ 的原因是还需要考虑跟不跟父亲相连。另外整棵树的根 $1$ 号点是个例外，因为它没有父亲，所以它的转移就是不需要那个 $+1$。

补充：为什么能够转化为 Part 0.3的说法？你可以想象节点是钉子，我们所加的新边是橡皮筋，每加一条边就让橡皮筋去贴到它的端点间树上路径上所有钉子上绷着。那么相邻两点间不能有多段橡皮筋。而如果相邻两点间没有橡皮筋，你可以想象其实有一条橡皮筋连着它们。这样一棵树就可以被看成多条路径拼成的。

## 回到 Part 2
现在可能有一些思路了，那么【\*】怎么落实呢？我们发现如果 $i$ 和父节点属于同一强连通分量【\*'】，就不需要那个 $+1$。另外还会影响 $|son(i)|$，因为有一些儿子是无论如何也不会参与划分的。这样的儿子就是 【\*'】为假的节点。

那么回到上面的图，为什么 $6,8$、$4,8$ 能产生答案，其实回答很显然了，$f_6=f_8=1$，$f_4=2$，$f_2=f_3f_4f_5f_8h_{2+0}=4$，答案就是 $4$ 了。

## 附注
为了后人调试之方便，下贡献一组样例。

*sample.in:*
```
6
3 2
1 2
1 3

5 4
1 2
2 3
2 4
1 5

10 10
8 4
8 7
8 5
8 6
1 9
6 10
5 2
4 1
6 3
8 2

10 11
4 6
2 3
7 10
9 7
4 2
2 5
2 1
1 5
7 3
2 9
2 8

6 7
2 3
1 3
4 5
5 6
4 6
1 4
2 5

10 11
2 10
4 7
10 9
3 8
3 6
3 7
1 7
1 5
1 2
4 3
2 4
```
*sample.out*:
```
2
8
64
4
0
0
```

---


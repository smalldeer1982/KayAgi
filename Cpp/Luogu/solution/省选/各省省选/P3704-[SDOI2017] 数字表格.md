# [SDOI2017] 数字表格

## 题目背景

Doris 刚刚学习了 fibonacci 数列。用 $f_i$ 表示数列的第 $i$ 项，那么

$$f_0=0,f_1=1$$

$$f_n=f_{n-1}+f_{n-2},n\geq 2$$

## 题目描述

Doris 用老师的超级计算机生成了一个 $n\times m$ 的表格，

第 $i$ 行第 $j$ 列的格子中的数是 $f_{\gcd(i,j)}$，其中 $\gcd(i,j)$ 表示 $i,j$ 的最大公约数。


Doris 的表格中共有 $n\times m$ 个数，她想知道这些数的乘积是多少。

答案对 $10^9+7$ 取模。


## 说明/提示

#### 数据规模与约定

- 对于 $10\%$ 的数据，保证 $n,m\leq 10^2$。
- 对于 $30\%$ 的数据，保证 $n,m\leq 10^3$。
- 另有 $30\%$ 的数据，保证 $T\leq 3$。
- 对于 $100\%$ 的数据，保证 $1 \leq T\leq 10^3$，$1\leq n,m\leq 10^6$。


## 样例 #1

### 输入

```
3
2 3
4 5
6 7```

### 输出

```
1
6
960```

# 题解

## 作者：yybyyb (赞：73)

忽然不知道这个要怎么表示。。。

就写成这样吧。。

$$\prod_{d=1}^n\prod_{i=1}^n\prod_{j=1}^mif(gcd(i,j)==d)f[gcd(i,j)]$$

直接把$f[d]$提出来

$$\prod_{d=1}^{n}f[d]^{\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[gcd(i,j)==1]}$$

上面那个东西用莫比乌斯反演+数论分块可以$O(\sqrt n)$求

外面套的这一层也可以数论分块求

于是，我们就得到了一个$O(n)$的做法


但是显然还不够


把上面那坨东西拎出来看

$$\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[gcd(i,j)==1]$$

太熟悉了

$$\sum_{i=1}^{n/d}\mu(i)[\frac{n}{id}][\frac{m}{id}]$$

还是老套路，

令$T=id$

直接把$T$在整个式子里面提出来

$$\prod_{T=1}^{n}\prod_{d|T}f[d]^{[n/T][m/T]\mu(T/d)}$$

有一些一样的东西

$$\prod_{T=1}^{n}(\prod_{d|T}f[d]^{\mu(T/d)})^{[n/T][m/T]}$$


然后怎么办。。。。

很明显，已经可以对$[n/T][m/T]$分块了

那。。。里面的东西怎么办。。。

又不能线性筛。。。


喂喂。。。不能线性筛就暴力算呀

数据范围$10^6$

每个数暴力算到他的倍数里面去

也就是$\frac{n}{1}+\frac{n}{2}+.....\frac{n}{10^6}$

这个东西也就是$15n$的样子

所以直接暴力把那个东西的前缀给求出来

就可以做到$O(\sqrt n)$求解了

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define MOD 1000000007
#define MAX 1000000
inline int read()
{
    int x=0,t=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
int fpow(int a,int b)
{
    int s=1;
    while(b){if(b&1)s=1ll*a*s%MOD;a=1ll*a*a%MOD;b>>=1;}
    return s;
}
int f[MAX+10],pri[MAX],tot;
int g[MAX+10];
int inv[MAX+10];
int F[MAX+10];
int mu[MAX+10];
bool zs[MAX+10];
int n,m;
void pre()
{
    f[1]=g[1]=F[0]=F[1]=1;
    mu[1]=1;zs[1]=true;
    for(int i=2;i<=MAX;++i)
    {
        f[i]=(f[i-1]+f[i-2])%MOD;
        g[i]=fpow(f[i],MOD-2);F[i]=1;
        if(!zs[i])pri[++tot]=i,mu[i]=-1;
        for(int j=1;j<=tot&&i*pri[j]<=MAX;++j)
        {
            zs[i*pri[j]]=true;
            if(i%pri[j])mu[i*pri[j]]=-mu[i];
            else{break;}
        }
    }
    for(int i=1;i<=MAX;++i)
    {
        if(!mu[i])continue;
        for(int j=i;j<=MAX;j+=i)
            F[j]=1ll*F[j]*(mu[i]==1?f[j/i]:g[j/i])%MOD;
    }
    for(int i=2;i<=MAX;++i)F[i]=1ll*F[i]*F[i-1]%MOD;
}
int main()
{
    pre();
    int T=read();
    while(T--)
    {
        n=read(),m=read();
        if(n>m)swap(n,m);
        int i=1,j,inv,ans=1;
        while(i<=n)
        {
            j=min(n/(n/i),m/(m/i));
            inv=1ll*F[j]*fpow(F[i-1],MOD-2)%MOD;
            ans=1ll*ans*fpow(inv,1ll*(n/i)*(m/i)%(MOD-1))%MOD;
            i=j+1;
        }
        printf("%d\n",(ans+MOD)%MOD);
    }
    return 0;
}

```


---

## 作者：xgzc (赞：54)

这道题目还有一种比较有意思的解法。

定义一种运算$(\mathbf f\oplus\mathbf g)(x) = \prod\limits_{d\mid x}\mathbf f(d)^{\mathbf g(\frac xd)}$

研究一下这种运算的性质：

虽然这个运算没有交换律也没有结合律，但是它有一个比较奇特的性质：

设运算$*$是狄利克雷卷积，那么可以证明$(\mathbf f \oplus \mathbf g) \oplus \mathbf h = \mathbf f \oplus (\mathbf g * \mathbf h)$。

于是就有一种基于$\prod$的莫比乌斯反演：

$\mathbf f = \mathbf g \oplus \mathbf 1 \Rightarrow \mathbf g = \mathbf f \oplus \mu$

也就是$\mathbf f(x) = \prod_{d|x} \mathbf g(d) \Rightarrow \mathbf g(x) = \prod_{d|x} \mathbf f(d)^{\mu(\frac xd)}$

那么这道题目就很好推了。

$$\begin{aligned}&\prod_{i=1}^n\prod_{j=1}^m f[\gcd(i, j)] \\=&\prod_{i=1}^n\prod_{j=1}^m\prod_{d|i, d|j} \mathbf g(d) \quad (\mathbf g = \mathbf f \oplus \mu) \\=&\prod_{d=1}^n \mathbf g(d)^{\sum_{d|i}\sum_{d|j}1} \\=&\prod_{d=1}^n \mathbf g(d)^{\left\lfloor \frac nd\right\rfloor \left\lfloor \frac md\right\rfloor}\end{aligned}$$

我们发现$\mathbf g$可以$\mathrm{O}(n\log n)$算，于是就做完了。

代码见我的[$\texttt{blog}$](https://www.cnblogs.com/cj-xxz/p/10632172.html)

---

## 作者：小粉兔 (赞：40)

在博客园食用更佳：[https://www.cnblogs.com/PinkRabbit/p/10011541.html](https://www.cnblogs.com/PinkRabbit/p/10011541.html)。

### 题意简述：

求 $\prod_{i=1}^{N}\prod_{j=1}^{M}F_{\gcd(i,j)}\bmod mod$ ，其中 $F_{i}$ 是斐波那契数列的第 $i$ 项， $mod=10^9+7$ 。

共有 $T$ 组数据。

### 题解：

喜闻乐见的推式子时间。

不失一般性，假设 $N\le M$ 。

$$\begin{aligned}&=\prod_{i=1}^{N}\prod_{j=1}^{M}F_{\gcd(i,j)} \\ &=\prod_{k=1}^{N}{F_{k}}^{\left(\sum_{i=1}^{N}\;\sum_{j=1}^{M}\;\left[\gcd(i,j)=k\right]\right)}\end{aligned}$$

右上角的指数部分是老套路了。

$$\begin{aligned}&= \sum_{i=1}^{N}\sum_{j=1}^{M}\left[\gcd(i,j)=k\right]\\&= \sum_{i=1}^{\left\lfloor\frac{N}{k}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{M}{k}\right\rfloor}\left[\gcd(i,j)=1\right]\\&= \sum_{d=1}^{\left\lfloor\frac{N}{k}\right\rfloor}\mu(d)\left\lfloor\frac{N}{kd}\right\rfloor\left\lfloor\frac{M}{kd}\right\rfloor\end{aligned}$$

所以

$$\begin{aligned} &= \prod_{k=1}^{N}{F_{k}}^{\left(\sum_{d=1}^{\left\lfloor\frac{N}{k}\right\rfloor}\mu(d)\left\lfloor\frac{N}{kd}\right\rfloor\left\lfloor\frac{M}{kd}\right\rfloor\right)}\\ &= \prod_{T=1}^{N}\left(\prod_{k|T}{F_{k}}^{\mu(\frac{T}{k})}\right)^{\left\lfloor\frac{N}{T}\right\rfloor\left\lfloor\frac{M}{T}\right\rfloor} \end{aligned}$$

令 $f(n)=\prod_{d|n}{F_{d}}^{\mu(\frac{n}{d})}$ 。

则

$$=\prod_{T=1}^{N}{f(T)}^{\left\lfloor\frac{N}{T}\right\rfloor\left\lfloor\frac{M}{T}\right\rfloor}$$

外层数论分块求出。内层的 $f(T)$ 直接暴力预处理，每个数直接乘到它的倍数中，复杂度 $\Theta(n\log n)$ 。

**注意实现的时候的时间复杂度**，我因为实现多了快速幂的一个 $\log$ 被卡了。

**正确的时间复杂度应该是** $\Theta(N(\log N+\log mod)+T\sqrt{N}\log mod)$ 。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

#define mod 1000000007
#define LL long long

int Pow(int b, LL e) {
	if (e < 0) e += mod - 1;
	int a = 1;
	for (; e; b = (LL)b * b % mod, e >>= 1)
		if (e & 1) a = (LL)a * b % mod;
	return a;
}

bool ip[1000005];
int p[80005], pc;
int mu[1000005];
int f[1000005], fr[1000005];

void init() {
	
	ip[1] = 1;
	mu[1] = 1;
	
	for (int i = 2; i <= 1000000; ++i) {
		if (!ip[i]) {
			p[++pc] = i;
			mu[i] = -1;
		}
		for (int j = 1; j <= pc && (LL)p[j] * i <= 1000000; ++j) {
			register int k = p[j] * i;
			ip[k] = 1;
			if (i % p[j]) mu[k] = -mu[i];
			else break;
		}
	}
	
	for (int i = 1; i <= 1000000; ++i)
		f[i] = 1, fr[i] = 1;
	
	int A = 1, B = 0;
	for (int i = 1; i <= 1000000; ++i) {
		B = (A + B) % mod;
		A = (B - A + mod) % mod;
		int G[3] = {Pow(B, -1), 1, B};
		for (int j = i, k = 1; j <= 1000000; j += i, ++k) {
			f[j] = (LL)f[j] * G[mu[k] + 1] % mod,
			fr[j] = (LL)fr[j] * G[1 - mu[k]] % mod;
		}
	}
	
	f[0] = fr[0] = 1;
	for (int i = 1; i <= 1000000; ++i)
		f[i] = (LL)f[i - 1] * f[i] % mod,
		fr[i] = (LL)fr[i - 1] * fr[i] % mod;
}

int main() {
	init();
	int T;
	scanf("%d", &T);
	while (T--) {
		int N, M;
		scanf("%d%d", &N, &M);
		if (N > M) swap(N, M);
		int A = 1;
		for (int i = 1, j; i <= N; i = j + 1) {
			j = min(N / (N / i), M / (M / i));
			A = (LL)A * Pow((LL)f[j] * fr[i - 1] % mod, (LL)(N / i) * (M / i)) % mod;
		}
		printf("%d\n", A);
	}
	return 0;
}
```

---

## 作者：qwaszx (赞：16)

哭了，卡了两个小时常了，$Kelin$为什么这么nb啊明明我复杂度比他低还没他跑得快

---
现在我比他快了

---

首先化式子.设$n\leq m$，除法均为整除.

$\begin{array}{lcc}\prod\limits_{i=1}^n\prod\limits_{j=1}^mf[gcd(i,j)]=\prod\limits_{d=1}^n\prod\limits_{i=1}^n\prod\limits_{j=1}^m(f[d])^{[gcd(i,j)]}\\=\prod\limits_{d=1}^n(f[d])^{\sum\limits_{i=1}^n\sum\limits_{j=1}^m[gcd(i,j)=d]}\\=\prod\limits_{d=1}^n(f[d])^{\sum\limits_{k=1}^\frac{n}{d}\mu(k)\frac{n}{kd}\frac{m}{kd}}\\=\prod\limits_{T=1}^n\left(\prod\limits_{d|T}(f[d])^{\mu(\frac{T}{d})}\right)^{\frac{n}{T}\frac{m}{T}}\end{array}$

于是我们预处理$\prod\limits_{d|T}(f[d])^{\mu(\frac{T}{d})}$即可$O(\sqrt{n}\log n)$回答询问了

如何预处理呢?

绝大多数人都是枚举$d$，然后更新$T$

然而事实上我们有更好的做法.参考[$rqy$的blog](https://lx-2003.blog.luogu.org/mobius-inversion).

设$g_{i,n}=\prod\limits_{d|T,d\text{只含前i种质因子}}(f[\frac{T}{d}])^{\mu(d)}$

和$inv_{i,n}=\dfrac{1}{g_{i,n}}=\prod\limits_{d|T,d\text{只含前i种质因子}}(f[\frac{T}{d}])^{-\mu(d)}$

于是枚举$p_i$.

如果$p_i\not|n$，那么$g_{i,n}=g_{i-1,n},inv_{i,n}=inv_{i-1,n}$;

否则，$g_{i,n}=g_{i-1,n}\times\prod\limits_{dp_i|T}(f[\frac{\frac{T}{p_i}}{d}])^{\mu(dp_i)}=g_{i-1,n}\times\prod\limits_{dp_i|T}(f[\frac{\frac{T}{p_i}}{d}])^{-\mu(d)}=g_{i-1,n}\times inv_{i-1,\frac{n}{p_i}}$

同理有$inv_{i,n}=inv_{i-1,n}\times g_{i-1,\frac{n}{p_i}}$

于是我们就可以枚举素数来更新了.滚动数组消掉第一维即可.

于是我们把跑$g$和跑$inv$得时间从$n\log mod$降到了$n\log \log n$

可是还有一个问题!$g$和$inv$的初值分别是$f$和$inv(f)$.$inv(f)$如果硬算还有$n\log mod$的复杂度，这远远大于刚才的复杂度.

于是我~~观摩了Kelin的代码~~冥思苦想一番之后想起了一种神仙的做法.

我们来考虑$f$的前缀积$sf$，以及$invf$的前缀积$si$.

那么我们有$invf(n)=si(n)\times sf(n-1)$以及$si(n-1)=si(n)\times f(n)$

于是只要知道了$si(N)$我们就可以$O(n)$递推出所有$invf$，而$si(N)=sf(N)^{-1}$，跑一次逆元求出来即可.

这个技巧还有很多用处emm它可以线性求数论函数逆元.

于是预处理的复杂度只剩$n\log \log n$了~~我就不信哪个神仙能线筛~~

$O(n\log \log n+T\sqrt{n}\log n)$.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#define mod 1000000007
using namespace std;
const int N=1e6+5;
int s[N],invs[N];
int m,n,T,p[N],prime[100000],mu[N],cnt,nn[1005],mm[1005],sf[N];
inline int qpower(int a,int b)
{
	int ans=1;for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;return ans;
}
void make(int n)
{
	mu[1]=p[1]=invs[0]=s[1]=invs[1]=sf[1]=1;
	for(int i=2;i<=n;i++)
	{
		s[i]=(s[i-1]+s[i-2])%mod,sf[i]=1ll*sf[i-1]*s[i]%mod;if(!p[i])prime[++cnt]=i,mu[i]=-1;
		for(int j=1,x;j<=cnt&&(x=i*prime[j])<=n;j++)
		{
			p[x]=1;if(i%prime[j])mu[x]=-mu[i];
			else break;
		}
	}
	int sis=qpower(sf[n],mod-2);
	for(int i=n;i>=2;i--)invs[i]=1ll*sis*sf[i-1]%mod,sis=1ll*sis*s[i]%mod;
	for(int i=1;i<=cnt;i++)
	{
		for(int jj=n/prime[i],j=jj*prime[i];jj>=1;jj--,j=jj*prime[i])
		{
			s[j]=1LL*s[j]*invs[jj]%mod;
			invs[j]=1ll*invs[j]*s[jj]%mod;
		}
	}
	for(int i=2;i<=n;i++)s[i]=1ll*s[i]*s[i-1]%mod,invs[i]=1ll*invs[i]*invs[i-1]%mod;;
}
int main()
{
	scanf("%d",&T);int maxn=0;
	for(int i=1;i<=T;i++)scanf("%d%d",nn+i,mm+i),maxn=max(maxn,min(nn[i],mm[i]));
	make(maxn);
	for(int TTT=1;TTT<=T;TTT++)
	{
		int n=nn[TTT],m=mm[TTT];
		if(n>m)swap(n,m);int ans=1;
		int i=1,lt=sqrt(n);
		for(;i<=lt;i++)
		{
			ans=(1ll*ans*qpower(1ll*s[i]*invs[i-1]%mod,1ll*(n/i)*(m/i)%(mod-1)))%mod;
		}
		for(;i<=n;i=lt+1)
		{
			lt=min(n/(n/i),m/(m/i));
			ans=(1ll*ans*qpower(1ll*s[lt]*invs[i-1]%mod,(n/i)*(m/i)))%mod;
		}
		printf("%d\n",ans);
	}
}
```
~~卡常是无止境的~~
```

---

## 作者：shadowice1984 (赞：10)

套路满满的一道题……

卡常数卡的我欲仙欲死……(其实是我脑残了几次233)

额那么一看就是充满了莫比乌斯反演的恶意……

还是说两点，反演题最重要的是有信仰，要动起手来化简式子

关键时刻一定要有勇气继续把式子推出去，然后就是用各种奇技淫巧了……

其实反演题还是很套路的，毕竟代码好写。

## 开始愉快的推倒式子吧……

 _(以下推倒过程中我们均使用$(i,j)$表示$gcd(i,j)$)_ 
 
 反演题主要难理解的东西有两个，一个是交换Σ，另一个是偷换变量，如果理解了这个两个东西的话基本反演就学会了
 
 (这道题还多了一个骚操作叫交换Π)

题目让我们求的式子是(不妨设n<m)

## $\prod_{i=1}^{N}\prod_{j=1}^{M}f((i,j))$

然后这里有一个非常传统的操作叫枚举gcd，令**d=(i,j),i/=d,j/=d**得

## $\prod_{d=1}^{N}f(d)^{\sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}ε((i,j))}$

其中$ε$是元函数，当且仅当x=1,$ε(x)=1$否则$ε(x)=0$

根据莫比乌斯反演得四个主要推论(啊啊啊为什么luogu没有反演的板子……，不会反演结论的话随便找一个反演的题解去看好了，这里也会简单介绍下)

----------------
#### 下面是莫比乌斯反演的简单介绍，熟练的话可以跳过

如果记两个数论函数$f,g$的狄利克雷卷积为$(f×g)$那么我们定义狄利克雷卷积运算为下面这个式子

## $(f×g)(x)=\sum_{d|x}f(d)g(\frac{x}{d})$


然后莫比乌斯反演的4个常见结论是

### $φ=μ×id$

### $ε=μ×1$

### $id=φ×1$

### $1=1×ε$

其中id(x)=x,1(x)=1

_________________

由第三个推论可以把ε函数反演掉，可以得到

## $\prod_{d=1}^{N}f(d)^{\sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}\sum_{T|(i,j)}μ(T)1(\frac{(i,j)}{T})}$

然后我们发现1(x)=1所以1函数可以消掉，另外$T|(i,j)\leftrightarrow T|i\&T|j$所以我们可以把式子做一下小小的变换

## $\prod_{d=1}^{N}f(d)^{\sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}\sum_{T|i\&T|j)}μ(T)}$

此时我们需要蛇皮一下，采用一个被称为交换Σ的操作(十分古老但是依然很皮的操作)，我们变换变量的枚举顺序，**令i\=t,j\=t**，得：

## $\prod_{d=1}^{N}f(d)^{\sum_{T=1}^{N}μ(T)\sum_{i=1}^{\lfloor\frac{N}{dT}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{dT}\rfloor}1}$

显然我们会发现里边的两个Σ可以化成乘法，得到下面这个式子

## $\prod_{d=1}^{N}f(d)^{\sum_{T=1}^{N}μ(T)\lfloor\frac{N}{dT}\rfloor\lfloor\frac{M}{dT}\rfloor}$

我们的初中数学老师告诉我们，底数相同，指数相加等于幂次相乘，所以指数上的Σ可以变成底数上的Π，得到这个式子

## $\prod_{d=1}^{N}\prod_{T=1}^{\lfloor\frac{N}{d}\rfloor}f(d)^{μ(T)\lfloor\frac{N}{dT}\rfloor\lfloor\frac{M}{dT}\rfloor}$

现在的话我们直接计算的值是调和级数复杂度乘上一个快速幂复杂度

调和级数就是这样的一个东西

### $\sum_{i=1}^{N}\frac{N}{i}=O(nlogn)$

 _注意这里的等于是渐进等于，实际上当N=1e6的时候这个数是13970034小于$nlog_{2}n$_ 

所以我们的复杂度是$O(Tnlog^{2}n)$的，不可接受，我们需要继续优化下去

我们发现此时交换Π已经没用了，我们无论是枚举d还是枚举T最后的得到是同样的复杂度，既然我们枚举d没用，枚举t也没用，不如让我们看看求的式子里都有什么变量

## $f(d)^{μ(T)\lfloor\frac{N}{dT}\rfloor\lfloor\frac{M}{dT}\rfloor}$

枚举$d,t$都没用啊……

# 所以我们要枚举$dT$

这才是这道题真正蛇皮的地方，不仅交换了Π，而且创造了一个新的枚举变量！

这里令$K=dT$那么我们可以得到$d|K\&T|K$并且$d=\frac{K}{T}\&T=\frac{K}{d}$

所以我们的式子可以化成这样：

## $\prod_{K=1}^{N}\prod_{d|K}f(d)^{μ(\frac{K}{d})\lfloor\frac{N}{K}\rfloor\lfloor\frac{M}{K}\rfloor}$

根据指数上的乘法等于次方嵌套这一原则，我们可以这样做一个小变换

## $\prod_{K=1}^{N}\prod_{d|K}(f(d)^{μ(\frac{K}{d})})^{\lfloor\frac{N}{K}\rfloor\lfloor\frac{M}{K}\rfloor}$

发现$\lfloor\frac{N}{K}\rfloor\lfloor\frac{M}{K}\rfloor$和d根本没关系。

根据指数相同时，**幂次的积等于积的幂次**这个运算规则，我们可以这样做

## $\prod_{K=1}^{N}(\prod_{d|K}f(d)^{μ(\frac{K}{d})})^{\lfloor\frac{N}{K}\rfloor\lfloor\frac{M}{K}\rfloor}$

我们令

## $val(K)=\prod_{d|K}f(d)^{μ(\frac{K}{d})}$

发现$val(K)$可以$O(nlogn)$的暴力计算出来

此时我们的答案变成了

## $\prod_{K=1}^{N}val(K)^{\lfloor\frac{N}{K}\rfloor\lfloor\frac{M}{K}\rfloor}$

此时我们已经打好了$val(p)$的表，所以我们现在$O(\sqrt{n})$的枚举$\lfloor\frac{N}{K}\rfloor\lfloor\frac{M}{K}\rfloor$的值，每次查询$val$的区间积，这个东西我们可以用前缀积的方式来处理，两个前缀积一除就是区间积了

然后我们就可以愉快的写(卡)代(常)码(数)了~

总的算法复杂度$O(nlogn+T\sqrt{n})$依靠信(大)仰(时)的(限)话可以接受

其实代码炒鸡短~

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<ctime>
using namespace std;typedef unsigned long long ll;ll mod=1e9+7;const int N=1e6+10;
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=(a*a)%mod){if(p&1){r=(r*a)%mod;}}return r;}
int t;int miu[N];int zhi[N];bool book[N];int cnt;ll f[N];ll prp[N];int sn;int sm;int n=1e6;
int main()
{
	f[1]=1;f[2]=1;for(int i=3;i<=n;i++){f[i]=(f[i-1]+f[i-2])%mod;}miu[1]=1;//打表fibonacci数列 
	for(int i=2;i<=n;i++)//线性筛筛miu函数 
	{
		if(book[i]==false){miu[i]=-1,zhi[++cnt]=i;}
		for(int j=1;j<=cnt&&zhi[j]*i<=n;j++)
		{
			book[i*zhi[j]]=true;
			if(i%zhi[j]==0){miu[i*zhi[j]]=0;break;}
			else {miu[i*zhi[j]]=miu[i]*miu[zhi[j]];}
		}
	}for(int i=0;i<=n;i++){prp[i]=1;}//处理前缀积 
	for(int i=1;i<=n;i++)
	{
		ll inv=po(f[i],mod-2);//这里一定先把-1次幂处理出来，不然复杂度多个log 
		for(int j=i;j<=n;j+=i)//枚举约数太慢换成枚举倍数了，自己就是倍数的约数 
		{	
			if(miu[j/i]==-1){prp[j]*=inv;prp[j]%=mod;}//这样写似乎常数最小？ 
			else if(miu[j/i]==1){prp[j]*=f[i];prp[j]%=mod;} 
		}
	}for(int i=1;i<=n;i++){prp[i]*=prp[i-1];prp[i]%=mod;}//前缀积 
	scanf("%d",&t);
	for(int z=1;z<=t;z++)
	{
		scanf("%d%d",&sn,&sm);int p;ll res=1;
		for(int i=1;i<=min(sn,sm);i=p+1)//这里是数论分块的板子 
		{
			p=min(sn/(sn/i),sm/(sm/i));//像这样的话[i,p]内的值，(n/i)*(m/i)都是一样的 
			res=res*po(prp[p]*po(prp[i-1],mod-2)%mod,(ll)(sn/i)*(ll)(sm/i))%mod;
		}printf("%lld\n",res);
	}return 0;//拜拜程序~ 
}
```










---

## 作者：xyz32768 (赞：7)

容易看出，此题用**莫比乌斯反演**求解。

首先，要把$\prod_{i=1}^n\prod_{j=1}^mf[\gcd(i,j)]$换一个方向去思考，即不枚举$i,j$，而是枚举$d=\gcd(i,j)$。可以得到，在这个表格里，$f[d]$出现的次数就是$\sum_{i=1}^n\sum_{j=1}^m[\gcd(i,j)=d]$。

所以：

$Ans=\prod_df[d]^{\sum_{i=1}^n\sum_{j=1}^m[\gcd(i,j)=d]}$

$=\prod_df[d]^{\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[\gcd(i,j)=1]}$

而$\sum_{i=1}^x\sum_{j=1}^y[\gcd(i,j)=1]$是一个经典问题，它等于$\sum_d\lfloor\frac{x}{d}\rfloor\lfloor\frac{y}{d}\rfloor\mu(d)$。

即原式等于$\prod_df[d]^{\sum_k\lfloor\frac{n}{dk}\rfloor\lfloor\frac{m}{dk}\rfloor\mu(k)}$。

继续考虑。可以发现，$\lfloor\frac{n}{dk}\rfloor$和$\lfloor\frac{m}{dk}\rfloor$这两个式子不容易直接分块。所以这里令$u=dk$，原式化为：

$\prod_u\prod_{k|u}f[\frac{u}{k}]^{\mu(k)\lfloor\frac{n}{u}\rfloor\lfloor\frac{m}{u}\rfloor}$

$=\prod_u(\prod_{k|u}f[\frac{u}{k}]^{\mu(k)})^{\lfloor\frac{n}{u}\rfloor\lfloor\frac{m}{u}\rfloor}$。

这样就可以将$\lfloor\frac{n}{u}\rfloor$和$\lfloor\frac{m}{u}\rfloor$的值分块了。令$F[u]=\prod_{k|u}f[\frac{u}{k}]^{\mu(k)}$，那么就可以预处理$F$的前缀积，计算区间的积时使用逆元计算。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int MaxN = 1e6, PYZ = 1e9 + 7, N = MaxN + 5;
int tot, f[N], g[N], pri[N], miu[N], F[N], prod[N];
bool mark[N];
int qpow(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = 1ll * res * a % PYZ;
        a = 1ll * a * a % PYZ;
        b >>= 1;
    }
    return res;
}
void sieve() {
    int i, j; f[0] = 0; f[1] = miu[1] = g[1] = F[1] = prod[0] = 1;
    mark[0] = mark[1] = 1;
    for (i = 2; i <= MaxN; i++) {
        f[i] = (f[i - 1] + f[i - 2]) % PYZ;
        g[i] = qpow(f[i], PYZ - 2); F[i] = 1;
        if (!mark[i]) pri[++tot] = i, miu[i] = -1;
        for (j = 1; j <= tot; j++) {
            if (1ll * i * pri[j] > MaxN) break;
            mark[i * pri[j]] = 1;
            if (i % pri[j] == 0) break;
            else miu[i * pri[j]] = -miu[i];
        }
    }
    for (i = 1; i <= MaxN; i++) {
        if (miu[i] != 0) for (j = i; j <= MaxN; j += i)
            F[j] = 1ll * F[j] * (miu[i] == 1 ? f[j / i] : g[j / i]) % PYZ;
        prod[i] = 1ll * prod[i - 1] * F[i] % PYZ;
    }
}
int solve(int a, int b) {
    int i, n = min(a, b), ans = 1;
    for (i = 1; i <= n;) {
        int nxt = min(a / (a / i), b / (b / i)), pro;
        pro = 1ll * prod[nxt] * qpow(prod[i - 1], PYZ - 2) % PYZ;
        ans = 1ll * ans * qpow(pro, 1ll * (a / i) * (b / i) % (PYZ - 1)) % PYZ;
        i = nxt + 1;
    }
    return ans;
}
int main() {
    int a, b, T = read(); sieve();
    while (T--) a = read(), b = read(),
        printf("%d\n", solve(a, b));
    return 0;
}
```

---

## 作者：George1123 (赞：6)

# 题解-[SDOI2017]数字表格

**[博客中阅读](https://www.cnblogs.com/Wendigo/p/12489320.html)**

**前置知识：**

> 莫比乌斯反演[</>](https://www.cnblogs.com/Wendigo/p/12441788.html) 

---

> [\[SDOI2017\]数字表格](https://www.luogu.com.cn/problem/P3704)

> $T$ 组测试数据，$f_i$ 表示 $\texttt{Fibonacci}$ 数列第 $i$ 项（$f_0=0$，$f_1=1$，$f_i=f_{i-1}+f_{i-2}$），求
> $$\left(\prod\limits_{i=1}^n\prod\limits_{j=1}^mf_{\gcd(i,j)}\right)\bmod(10^9+7)$$

> 数据范围：$T\le 1000$，$1\le n,m\le 10^6$。

---

本来是水题，但是这个蒟蒻一下犯了好多常见毛病，所以来写篇题解。

1. 忘记用生成 $\mu$ 的线性筛函数了。

2. 忘记幂次取模要膜 $\varphi(mod)$ 了。

---

假设 $n\le m$：

![前314.png](https://i.loli.net/2020/03/14/rmdJR82iKXNAPZe.png)

然后现在直接分块套分块 $\Theta(N+Tn)$ 可以得到 $30$ 分。

---

为了 $\texttt{AC}$，只好拿 $T=dk$ 带入继续走：

![后314.png](https://i.loli.net/2020/03/14/HjcNw2F5xsOaBkh.png)

然后括号外面就 $\Theta(\sqrt n)$ 分块，里面就 $\Theta(N\log N)$ 预处理出来。

最后时间复杂度：$\Theta(N\log N+T\sqrt n)$。

---

**code**

```cpp
#include <bits/stdc++.h>
using namespace std;

//&Start
#define lng long long
#define lit long double
#define kk(i,n) " \n"[i==n]
const int inf=0x3f3f3f3f;
const lng Inf=0x3f3f3f3f3f3f3f3f;

//&Data
const int N=1e6,mod=1e9+7;
int t,n,m;

//&Pow
int Pow(int a,int x){
	int res=1;
	for(;x;a=1ll*a*a%mod,x>>=1)
		if(x&1) res=1ll*res*a%mod;
	return res;
}

//&Mobius&Fibonacci
bitset<N+10> np;
int p[N+10],cnt,mu[N+10],tp[N+10],f[N+10],g[N+10],h[N+10];
void Mobius(){
	np[1]=true;
	mu[1]=f[1]=g[1]=h[1]=1;
	for(int i=2;i<=N;i++){
		if(!np[i]) p[++cnt]=i,mu[i]=-1;
		f[i]=(f[i-1]+f[i-2])%mod;
		g[i]=Pow(f[i],mod-2);
		h[i]=1;
		for(int j=1;j<=cnt&&i*p[j]<=N;j++){
			np[i*p[j]]=1;
			if(i%p[j]==0){mu[i*p[j]]=0;break;}
			mu[i*p[j]]=-mu[i];
		}
	}
	for(int k=1;k<=N;k++){ //nlogn 的暴力筛
		if(mu[k]==0) continue;
		for(int T=k;T<=N;T+=k)
			h[T]=1ll*h[T]*(mu[k]==1?f[T/k]:g[T/k])%mod;
	}
	h[0]=1;
	for(int i=1;i<=N;i++) h[i]=1ll*h[i-1]*h[i]%mod;//前缀积
}

//&Main
int main(){
	Mobius();//这东西千万不能忘记打
	scanf("%d",&t);
	for(int ti=1;ti<=t;ti++){
		scanf("%d%d",&n,&m);
		if(n>m) n^=m^=n^=m;
		int res=1,a,x;
		for(int l=1,r;l<=n;l=r+1){
			r=min(n/(n/l),m/(m/l));
			a=1ll*h[r]*Pow(h[l-1],mod-2)%mod;
			x=1ll*(n/l)*(m/l)%(mod-1);//幂次一定一定一定要模(phi(mod))
			res=1ll*res*Pow(a,x)%mod;
		}
		printf("%d\n",res);
	}
	return 0;
}
```

---

**祝大家学习愉快！**


---

## 作者：Reywmp (赞：5)

# [Luogu P3704 [SDOI2017]数字表格](https://www.luogu.com.cn/problem/P3704)

-----------

同步更新在我的[莫比乌斯反演做题记录](https://www.luogu.com.cn/blog/Stormy-Rey/shuo-xue-2-mu-bi-wu-si-fan-yan-zuo-ti-ji-lu)，里面有一些莫反的套路题和基础前置芝士。

-----------

~~在机房复盘 SDOI 2017 的模拟赛第一次场 A 黑题写题解纪念一下。~~

这个题要你求：
$$
\prod_{i=1}^n\prod_{j=1}^m \mathrm{fib_{\gcd(i,j)}}
$$
其中 $\mathrm{fib_{i}}$ 表示斐波拉契数列第 $i$ 项。

$\prod$ 连乘运算做不了 $\sum$ 的一些卷积公式（尤其是 $\texttt{Dirichlet}$ 卷积）。我们考虑把这个式子换成可以用 $\sum$ 推的情况。

首先一般性地，我们保证 ${\color{red}{n\leq m}}$。

我们枚举 $\displaystyle\sum_i\sum_j f(i,j)$ 这一类式子的时候会习惯性地枚举一个 $k$ 让其满足和式内部的条件。

这题即使是 $\prod$ 也可以套路化地使用这个方法。

所以原式可以转换为
$$
\prod_{k=1}^n\prod_{i=1}^n\prod_{j=1}^m \mathrm{fib}_k\times[\gcd(i,j)=k]
$$
我们发现每个 $\mathrm{fib}_d$ 都会与自己相乘很多次，于是我们可以将每个 $d$ 的贡献考虑写成幂的形式。

显然每个 $\mathrm{fib}_d$ 的幂的指数就是其等于 $\gcd(i,j)$ 对应的数对 $(i,j)$ 的个数。 

现在我们有
$$
\prod_{k=1}^n\mathrm {fib}_k^{\displaystyle\bigg({\color{blue}{\sum_{i=1}^n\sum_{j=1}^m[\gcd(i,j)=k]}}\bigg)}
$$
我们把指数特地标记出来。因为我们发现他是一个老朋友。

我们在做形似 $\displaystyle\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)$ 的一类莫反题是会将式子转换成 $\displaystyle \sum_{k=1}^n\bigg(k{\color{blue}{\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=k]}}\bigg)$

我们考虑怎么将这个式子转化成可做的形式（以下皆是莫反题老套路，跟不上请先去做一些基础莫反题~~，不是幽灵乐团，别信 CYJian~~）。
$$
\begin{aligned}
{\color{blue}{\texttt{blue part}}}&=\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}[\gcd(i,j)=1]\\
&=\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}\epsilon(\gcd(i,j))\\
&=\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}\sum_{d|\gcd(i,j)}\mu(d)\\
&=\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}[ d|i]\sum_{j=1}^{\lfloor \frac{m}{k}\rfloor}[d|j]\\
&=\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)\lfloor\frac{n}{k\times d}\rfloor\lfloor\frac{m}{k\times  d}\rfloor
\end{aligned}
$$
这个东西已经可以 $\Theta(\sqrt n)$ 级别的数论分块做了，但是我们要把其代入原式继续看。

现在原式变成了：
$$
\prod_{k=1}^n\mathrm {fib}_k^{\bigg (\displaystyle\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)\lfloor\frac{n}{k\times d}\rfloor\lfloor\frac{m}{k\times  d}\rfloor\bigg)}
$$
我们设 $T=k\times d$。

我们发现这样方便让我们将 $\displaystyle\sum_{d=1}^{\lfloor \frac{n}{k}\rfloor}$  与 $\mathrm{fib}_k$ 以幂的形式结合。所有变量用 $T$ 表示出来后贡献到一个 $\prod$ 中。

写出来就是：
$$
\prod_{T=1}^n\bigg({\color{blue}{\prod_{k|T}\mathrm{fib}_k^{\mu(\frac{T}{k})}}}\bigg)^{\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor}
$$
蓝色部分我们可以通过类似筛法预处理的方法求出：

- 线筛 $\mu$ 函数。
- 对于每一个 $k$ 枚举其倍数 $T$ ，乘上这个 $\mathrm{fib}_k$ 算入这个 $T$ 的贡献。
- 因为 $\mu$ 只有三种取值，有影响的只有 $\{1,-1\}$ 两种。
- 所以问题就变成了乘上 $\mathrm {fib}_{k}$ 或除以 $\mathrm {fib}_k$。这里就变成 $\mathrm{inv  fib}$（逆元）和 $\mathrm{fib}$ 两种情况。

外层我们做数论分块的时候，每次求内部只需要一次 $\Theta (\log p)$（$p$ 是模数）和 $\Theta(\log(\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor))$的快速幂分别求逆元和与外层指数的幂。

预处理复杂度是 $\Theta(n\log n+n\log p)$，数论分块复杂度是 $\Theta(t\sqrt n (\log p+\log \lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor))$ 小写 $t$ 是数据组数。

实现看代码（考试时忘了写逆元卡了好久导致 T2 LCT 都没写完）：

```cpp
#include<bits/stdc++.h>

#define ll long long
#define ull unsigned long long
#define INL inline
#define Re register

//Tosaka Rin Suki~

INL int read()
{
	int x=0,w=1;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();if(ch=='-')w=-1,ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+ch-48,ch=getchar();return x*w;
}

const int N=1e6+5;
const ll MOD=1e9+7;

ll f[N],finv[N],prime[N],mu[N],cnt,prod[N];
bool vis[N];

INL ll fpow(ll x,ll p)
{
	ll res=1;
	while(p)
	{
		if(p&1)res=(1ll*res*x)%MOD;
		x=(1ll*x*x)%MOD;p>>=1;
	}
	return res;
}

INL void get_mu(ll n)
{
	f[0]=0,f[1]=1;
	for(int i=2;i<=n;i++)f[i]=(f[i-1]+f[i-2])%MOD;
	for(int i=0;i<=n;i++)finv[i]=fpow(f[i],MOD-2),prod[i]=1;
	//fib 和 invfib
	vis[1]=1,vis[0]=1,mu[1]=1;
	for(int i=2;i<=n;i++)
	{
		if(!vis[i])prime[++cnt]=i,mu[i]=-1;
		for(int j=1;j<=cnt&&prime[j]*i<=n;j++)
		{
			vis[prime[j]*i]=1;
			if(i%prime[j])mu[i*prime[j]]=-mu[i];
			else {mu[i*prime[j]]=0;break;}
		}
	}//筛出 mu 
	for(int i=1;i<=n;i++)
	{
		for(int j=i;j<=n;j+=i)
		{
			int now=j/i;
			if(mu[now]==-1)prod[j]=1ll*prod[j]*finv[i]%MOD;
			else if(mu[now]==1)prod[j]=1ll*prod[j]*f[i]%MOD;
		}
	}//每个 k 在其对应 \prod T 中的贡献 
	for(int i=1;i<=n;i++)prod[i]=1ll*prod[i-1]*prod[i]%MOD;
}

int main()
{
	//freopen("product.in","r",stdin);
	//freopen("product.out","w",stdout);
	int T=read();
	get_mu(1000000);
	while(T--)
	{
		ll n=read(),m=read();
		if(n<m)std::swap(n,m);
		ll l=1,r,ans=1;
		while(l<=m)
		{
			r=std::min(n/(n/l),m/(m/l));
			ans=1ll*ans*fpow(1ll*prod[r]*fpow(prod[l-1],MOD-2)%MOD,1ll*(n/l)*(m/l)%(MOD-1))%MOD;
			//数论分块，后面这个指数可以通过 mod MOD-1 减少量级 
			l=r+1;
		}
		printf("%lld\n",(ans%MOD+MOD)%MOD);
	}
	return 0;
}
```



---

## 作者：chihik (赞：3)


前置知识：莫比乌斯反演，数论分块

## 题意

$$\prod_{i=1}^n \prod_{j=1}^m f_{ gcd(i,j) }$$

其中$f$为斐波拉契数列

## Part 1.正常操作
$gcd$可以枚举,令$d=min(n,m)$，上式等价于

$$\prod_{k=1}^d\prod_{i=1}^n\prod_{j=1}^mf_k^{[ gcd(i,j)==k ]}$$

将重复的$f_k$计算到一起

$$\prod_{k=1}^df_k^{\sum_{i=1}^n\sum_{j=1}^m[ gcd(i,j)==k ]}$$

$$\prod_{k=1}^df_k^{\sum_{i=1}^{ \lfloor n / k \rfloor }\sum_{j=1}^{ \lfloor m / k \rfloor }[ gcd(i,j)==1 ]}$$

## Part2.毒瘤操作

将指数部分拿出来看：
$$\sum_{i=1}^{ \lfloor n / k \rfloor }\sum_{j=1}^{ \lfloor m / k \rfloor }[ gcd(i,j)==1 ]$$

有一个结论：
$$\sum_{i \mid n}\mu(i)=[n=1]$$

证明如下：

1.当$n=1$时显然

2.当$n!=1$时，由唯一分解定理得：$n=p_1^{w_1}p_2^{w_2}...p_k^{w_k}$
由莫比乌斯函数的性质，$\mu(k) \not= 0$当且仅当$k$无平方因子。(由多个质因子相乘)

有$i$个质因子的数有$C_k^i$种取值。

所以只需证
$$\sum_{i=0}^k(-1)^iC_k^i=0$$

很像二项式定理，将 $ x = 1 , y = -1 $ 代入即可得证。

代入上式
$$\sum_{i=1}^{ \lfloor n / k \rfloor }\sum_{j=1}^{ \lfloor m / k \rfloor }\sum_{s \mid gcd(i,j)}\mu(s)$$

改写一下：
$$\sum_{i=1}^{ \lfloor n / k \rfloor }\sum_{j=1}^{ \lfloor m / k \rfloor }\sum_{s=1}^{ \lfloor n/k \rfloor }\mu(s)* [s \mid gcd(i,j)] $$

将$\mu(s)$向前提：

$$\sum_{s=1}^{ \lfloor n/k \rfloor } \mu(s) \sum_{i=1}^{ \lfloor n / k \rfloor }\sum_{j=1}^{ \lfloor m / k \rfloor }[s \mid gcd(i,j)] $$

$$\sum_{s=1}^{ \lfloor n/k \rfloor } \mu(s)\lfloor \frac{n}{ks} \rfloor \lfloor \frac{m}{ks} \rfloor$$

然后，我们得到最终结果为：
$$\prod_{k=1}^df_k^{\sum_{s=1}^{ \lfloor n/k \rfloor } \mu(s)\lfloor \frac{n}{ks} \rfloor \lfloor \frac{m}{ks} \rfloor}$$

令$T=ks$，则原式等价于：

$$\prod_{T=1}^d\prod_{k \mid T }f_k^{\mu(\frac{T}{k})\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor}$$

$\lfloor \frac{n}{T} \rfloor , \lfloor \frac{m}{T} \rfloor$与枚举的$k$无关,可以加括号

$$\prod_{T=1}^d(\prod_{k \mid T }f_k^{\mu(\frac{T}{k})})^{\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor}$$

然后令$F(T)=\prod_{k \mid T }f_k^{\mu(\frac{T}{k})}$,原式化为

$$
\prod_{T=1}^dF(T)^{\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor}
$$

似乎就不能化简了

## Part3.求解

内部的$F(k)$可以用类似埃筛的思想解决，外部用数论分块，就可以$\Theta(\sqrt{n})$解决了


```cpp
#include <cstdio>
#include <iostream>
using namespace std;
#define Mod 1000000007

const int MAXN = 1000000;
int k , prime[ MAXN / 10 + 5 ] , mu[ MAXN + 5 ];
bool vis[ MAXN + 5 ];

void sieve( int x ) {
	mu[ 1 ] = 1;
	for( int i = 2 ; i <= x ; i ++ ) {
		if( !vis[ i ] ) {
			prime[ ++ k ] = i;
			mu[ i ] = -1;
		}
		for( int j = 1 ; j <= k && 1ll * i * prime[ j ] <= x ; j ++ ) {
			vis[ i * prime[ j ] ] = 1;
			if( i % prime[ j ] == 0 ) break;
			mu[ i * prime[ j ] ] = -mu[ i ];
		}
	}
}
int Quick_pow( int x , int po ) {
	int Ans = 1;
	while( po ) {
		if( po % 2 ) 
			Ans = 1ll * Ans * x % Mod;
		x = 1ll * x * x % Mod;
		po /= 2;
	}
	return Ans;
}
int Inv( int x ) {
	return Quick_pow( x , Mod - 2 );
} 

int t , n , m;
int f[ MAXN + 5 ] = { 0 , 1 , 1 } , finv[ MAXN + 5 ] = { 0 , 1 , 1 } , F[ MAXN + 5 ];
void Init( ) {
	sieve( MAXN );
	for( int i = 3 ; i <= MAXN ; i ++ ) {
		f[ i ] = ( f[ i - 1 ] + f[ i - 2 ] ) % Mod;
		finv[ i ] = Inv( f[ i ] ); 
	}
	for( int i = 0 ; i <= MAXN ; i ++ )
		F[ i ] = 1;
	for( int i = 1 ; i <= MAXN ; i ++ ) {
		if( !mu[ i ] ) continue;
		for( int j = i ; j <= MAXN ; j += i )
			F[ j ] = ( 1ll * F[ j ] * ( mu[ i ] == 1 ? f[ j / i ] : finv[ j / i ] ) ) % Mod;
	}
	for( int i = 2 ; i <= MAXN ; i ++ )
		F[ i ] = 1ll * F[ i - 1 ] * F[ i ] % Mod;
}

int solve( int n , int m ) {
	int d = n < m ? n : m , Ans = 1;
	for( int l = 1 , r ; l <= d ; l = r + 1 ) {
		r = min( n / ( n / l ) , m / ( m / l ) );
		Ans = 1ll * Ans * Quick_pow( 1ll * F[ r ] * Inv( F[ l - 1 ] ) % Mod , 1ll * ( n / l ) * ( m / l ) % ( Mod - 1 ) ) % Mod;
	}
	return ( Ans + Mod ) % Mod;
}

int main( ) {
	Init( );	
	scanf("%d",&t);
	while( t -- ) {
		scanf("%d %d",&n,&m);
		printf("%d\n",solve( n , m ));
	}
	return 0;
}
```

---

## 作者：nekko (赞：3)

假设 $n \le m$

$$ \begin{aligned} &\prod_{i=1}^{n}\prod_{j=1}^{m}f(\gcd(i,j)) \\ =&\prod_{d=1}^{n}f(d)^{\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j)=d]} \\ =&\prod_{d=1}^{n}f(d)^{\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}[\gcd(i,j)=1]} \\ =&\prod_{d=1}^{n}f(d)^{\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}\sum_{t \mid \gcd(i,j)}\mu(t)} \\ =&\prod_{d=1}^{n}f(d)^{\sum_{t = 1}^{\lfloor \frac{n}{d} \rfloor}\mu(t)\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}[t \mid \gcd(i,j)]} \\ =&\prod_{d=1}^{n}f(d)^{\sum_{t = 1}^{\lfloor \frac{n}{d} \rfloor}\mu(t)\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}[t \mid i][t \mid j]} \\ =&\prod_{d=1}^{n}f(d)^{\sum_{t = 1}^{\lfloor \frac{n}{d} \rfloor}\mu(t)\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}[t \mid i]\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}[t \mid j]} \\ =&\prod_{d=1}^{n}f(d)^{\sum_{t = 1}^{\lfloor \frac{n}{d} \rfloor}\mu(t)\lfloor \frac{n}{dt} \rfloor \lfloor \frac{m}{dt} \rfloor} \\ =&\prod_{T=1}^{n}\prod_{d \mid T}f(d)^{\mu(\frac{T}{d})\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor} \\ =&\prod_{T=1}^{n} \left( \prod_{d \mid T}f(d)^{\mu ( \frac{T}{d} ) } \right) ^ { \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor} \\ =&\prod_{T=1}^{n} g(T) ^ { \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor} \\ \end{aligned} $$

然后就可以对 $\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor$ 进行数论分块了，然后考虑如何求 $g(T)$

首先有：

$$ g(T)=\sum_{d \mid T} f(d)^{\mu(\frac{T}{d})} $$

显然 $f,\mu$ 都可以预处理出来，之后只需要枚举 $i$，再枚举 $j$，用 $f(i) ^ {\mu(j)}$ 累加到 $g(i \times j)$ 上就行了

---

## 作者：_Sein (赞：1)



$$\begin{aligned}ans&=\prod\limits_{i=1}^n\prod\limits_{j=1}^mFib[gcd(i,j)]\\&=\prod\limits_{d=1}^{\min(n,m)}\prod\limits_{i=1}^n\prod\limits_{j=1}^mFib[d]^{[gcd(i,j)=d]}\\&=\prod\limits_{d=1}^{\min(n,m)}Fib[d]^{\sum\limits_{i=1}^n\sum\limits_{j=1}^m[gcd(i,j)==d]}\end{aligned}$$

令$f(d)=\sum\limits_{i=1}^n\sum\limits_{j=1}^m[gcd(i,j)==d],g(d)=\sum\limits_{i=1}^n\sum\limits_{j=1}^m [d|gcd(i,j)]$，

易知$g(k)=\sum\limits_{k|d}f(d)=\lfloor\frac{n}{k}\rfloor \lfloor\frac{m}{k}\rfloor$，根据莫比乌斯反演公式有:$f(d)=\sum\limits_{d|k}g(k)*\mu(\frac{k}{d})=\sum\limits_{d|k}\lfloor\frac{n}{k}\rfloor \lfloor\frac{m}{k}\rfloor*\mu({\frac{k}{d}})$

$$\begin{aligned}ans&=\prod\limits_{d=1}^{\min(n,m)}\prod\limits_{d|k,k\le \min(n,m)}Fib[d]^{\lfloor\frac{n}{k}\rfloor \lfloor\frac{m}{k}\rfloor*\mu({\frac{k}{d}})}\\&=\prod\limits_{k=1}^{\min(n,m)}\prod\limits_{d|k}Fib[d]^{\lfloor\frac{n}{k}\rfloor \lfloor\frac{m}{k}\rfloor*\mu({\frac{k}{d}})}\end{aligned}$$

其中$\prod\limits_{d|k}Fib[d]^{\mu(\frac{k}{d})}$可预处理。
```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#define ll long long
#define gc getchar()
using namespace std;
const int N=1e6+5,M=1e5+5,mod=1e9+7;
template<class o>
inline void qr(o &x)
{
	x=0;char c=gc;int f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
template<class o>
void qw(o x)
{
	if(x<0)putchar('-'),x=-x;
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
int prime[M],len,mu[N];ll sum[N],f[N][2],inv[N];bool v[N];
inline ll pow_mod(ll a,ll b){ll ans=1;a%=mod;for(;b;b>>=1,a=a*a%mod)if(b&1)ans=(ans*a)%mod;return ans;}
void gp()
{
	mu[1]=1;
	for(int i=2;i<N;i++)
	{
		if(!v[i])prime[++len]=i,mu[i]=-1;
		for(int j=1;j<=len&&i*prime[j]<N;j++)
		{
			v[i*prime[j]]=1;
			if(i%prime[j]==0){mu[i*prime[j]]=0;break;}
			mu[i*prime[j]]=-mu[i];
		}
	}
	f[0][0]=f[0][1]=0;f[1][1]=f[1][0]=1;sum[1]=1;
	for(int i=2;i<N;i++)
		f[i][0]=(f[i-1][0]+f[i-2][0])%mod,sum[i]=1,
		f[i][1]=pow_mod(f[i][0],mod-2);
	for(int i=1;i<N;i++)
		for(int j=i;j<N;j+=i)
		{
			int t=j/i;
			if(mu[t]==-1)
				sum[j]=sum[j]*f[i][1]%mod;
			else if(mu[t]==1)
				sum[j]=sum[j]*f[i][0]%mod;
		}
	inv[0]=1;sum[0]=1;
	for(int i=1;i<N;i++)sum[i]=sum[i]*sum[i-1]%mod,inv[i]=pow_mod(sum[i],mod-2);
}
int main()
{
	gp();
	int T;qr(T);
	while(T--)
	{
		int n,m;qr(n),qr(m);
		int t=min(n,m);ll ans=1;
		for(int l=1,r;l<=t;l=r+1)
		{
			r=min(n/(n/l),m/(m/l));
			ans=((ans*pow_mod(sum[r]*inv[l-1],1ll*(n/r)*(m/r)))%mod);
		}
		qw(ans);puts("");
	}
	return 0;
}
```


---

## 作者：Sym_Je (赞：1)

## P3704 [SDOI2017]数字表格   

## $\frak{main~idea}$    

$$\prod_{i=1}^{n}\prod_{j=1}^{m}fib[gcd(i,j)]$$     

## $\frak{Solution}$   
又到了有趣(~~毒瘤~~) 的推柿子时间 。 
我们假设 $n<m$  
$$\prod_{i=1}^{n}\prod_{j=1}^{m}fib[gcd(i,j)]$$    
$$\to\prod_{d=1}^{n}\prod_{i=1}^{n}\prod_{j=1}^{m}[gcd(i,j)==d]\cdot fib[d]$$   
$$\to\prod_{d=1}^{n}\prod_{i=1}^{\lfloor \frac{n}{d}\rfloor}\prod_{j=1}^{\lfloor \frac{m}{d}\rfloor}[gcd(i,j)]\cdot fib[d]$$     
$$\to\prod_{d=1}^{n}\cdot fib[d] ^{\sum_{i=1}^{\lfloor \frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{d}\rfloor}[gcd(i,j)]}$$  

$$\to\prod_{d=1}^{n}\cdot fib[d] ^{\sum_{i=1}^{\lfloor \frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{d}\rfloor}\sum_{k|gcd(i,j)}\mu_k}$$

$$\to\prod_{d=1}^{n}\cdot fib[d] ^{\sum_{k=1}^{n}\sum_{i=1}^{\lfloor \frac{n}{dk}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{dk}\rfloor}\mu_k}$$    

$$\to\prod_{d=1}^{n}\cdot fib[d] ^{\sum_{k=1}^{n}{\lfloor \frac{n}{dk}\rfloor}{\lfloor \frac{m}{dk}\rfloor}\mu_k}$$        
按套路我们发现 $dk$这个显然要枚举两维所以我们设 $T=dk$ .
$$\prod_{T=1}^{n} \prod_{d|T}\cdot fib[d]^{\mu({\frac{T}{d}})\cdot\lfloor \frac{n}{T}\rfloor\cdot \lfloor \frac{m}{T} \rfloor}$$    

然后我们可以把它分为两份  

$$\prod_{T=1}^{n} (\prod_{d|T}\cdot fib[d]^{\mu({\frac{T}{d}})})^{\lfloor \frac{n}{T}\rfloor\cdot \lfloor \frac{m}{T} \rfloor}$$  

然后里层我们预处理出来就好了 。我们枚举每个数，然后枚举他的倍数，复杂度 $O(nlogn)$    

对于外层我们分块一下就好啦 。    

* $\frak{Code}$

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod=1e9+7;
const ll maxn=1e6+10;
ll mu[maxn],pr[maxn],np[maxn],num,n,m;
ll f[maxn],z[maxn],c[maxn];
ll t;
void init(ll n)
{
	mu[1]=1;
	for(ll i=2;i<=n;++i) {
		if(!np[i]) {
			pr[++num]=i;mu[i]=-1;
		}
		for(ll j=1;j<=num;++j) {
			if(1ll*pr[j]*i>n) break;
			np[i*pr[j]]=1;
			if(i%pr[j]==0) {
				mu[i*pr[j]]=0;
				break;
			}
			mu[i*pr[j]]=-mu[i];
		}
	}
	f[0]=0;f[1]=1;
	for(ll i=2;i<=n;++i) f[i]=(f[i-1]+f[i-2])%mod;	
}

ll poww(ll x,ll k) {
	ll ans=1;
	while(k) {
		if(k&1) ans=ans*x%mod;
		x=x*x%mod;
		k>>=1;
	}return ans;
}

void pre(ll n) {
	for(ll i=1;i<=n;++i) 
		for(ll j=1;j*i<=n;++j) {
			if(mu[j]==0) continue ;
			else if(mu[j]==1) z[i*j]=z[i*j]*f[i]%mod;
			else z[i*j]=z[i*j]*poww(f[i],mod-2)%mod;
		}
	c[0]=1;
	for(ll i=1;i<=n;++i) {
		c[i]=c[i-1]*z[i]%mod;
	}
//	for(ll i=1;i<=10;++i) cout<<c[i]<<" ";
}

ll wo(ll n,ll m) 
{
	ll MIN=min(n,m);
	ll ans=1;
	for(ll l=1,r;l<=MIN;l=r+1) {
		r=min(MIN,min(n/(n/l),m/(m/l)));
		ans=ans*poww((c[r]*poww(c[l-1],mod-2)%mod),(n/l)*(m/l))%mod;
	}
	return ans;
}

inline ll read() {
	ll data=0,f=1;
	char c=getchar();
	while('0'>c||c>'9') {
		if(c=='-') f=-1;
		c=getchar(); 
	}while('0'<=c&&c<='9') {
		data=data*10+c-'0';c=getchar();
	}return data*f;
}

int main() {
	for(ll i=0;i<=maxn-10;++i) z[i]=1;
	init(maxn-10); 
	pre(maxn-10);
	t=read();
	while(t--) {
		n=read(),m=read();
		cout<<wo(n,m)<<"\n"; 
	} 
	return 0;
}
```

---

## 作者：VenusM1nT (赞：1)

莫比乌斯反演。

（什么毒瘤题啊这是……）

本文同步发表于笔者的博客：[题解 P3704 [SDOI2017]数字表格](https://venusnero.github.io/2019/02/21/solution_p3704/)

要求：

$$\prod_{i=1}^{n}\prod_{j=1}^{n}f_{gcd(i,j)}$$

（其中 $f_i$ 为斐波那契数列的第 $i$ 项）

出现了 $gcd$，那么就用一个惯用技巧：枚举之，所以式子变成：

$$\prod_{d=1}^{n}\prod_{i=1}^{n}\prod_{j=1}^{m}f_d\times[gcd(i,j)=d]$$

因为有许多重复的 $f_d$ 被记录到答案里，我们不妨将它化成 $f_d^x$ 的形式，如下：

$$\prod_{d=1}^{n}f_d ^{\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=d]}$$

上面这坨好像有点眼熟？单独拎出来看看：

$$\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=d]$$

这也太熟悉了吧……化简之：

$$=\sum_{i=1}^{n\over d}\sum_{j=1}^{m\over d}[gcd(i,j)=1]$$

根据 $\mu$ 的性质：$\sum_{d|n}\mu(d)=[n=1]$，可以将它展开成：

$$=\sum_{i=1}^{n\over d}\sum_{j=1}^{m\over d}\sum_{k|gcd(i,j)}\mu(k)$$

$k|gcd(i,j)$ 看着很不爽，把它化成枚举的形式：

$$=\sum_{i=1}^{n\over d}\sum_{j=1}^{m\over d}\sum_{k=1}^{n\over d}\mu(k)\times [k|gcd(i,j)]$$

因为有许多重复的 $\mu(k)$ 被累加，所以我们可以将它提到前面去：

$$=\sum_{k=1}^{n\over d}\mu(k)\sum_{i=1}^{n\over d}\sum_{j=1}^{m\over d}[k|gcd(i,j)]$$

由于只有满足后面这个才会对答案产生贡献，所以我们可以发现，只有 $i,j$ 都是 $k$ 的倍数时能有贡献，因此可以化简出一个很经典的式子：

$$=\sum_{k=1}^{n\over d}\mu(k)\lfloor {n\over dk} \rfloor \lfloor {m\over dk} \rfloor$$

这个式子可以数论分块求，不赘述。

回到原式，将这个代入，可得：

$$\prod_{d=1}^{n}f_d ^{\sum_{i=1}^{n\over d}\mu(k)\lfloor {n\over id} \rfloor \lfloor {m\over id} \rfloor}$$

按照之前某道题的套路，我们可以枚举 $id=T$，对式子进行进一步化简：

$$\prod_{T=1}^{n}\prod_{d|T}f_T^{\mu({T\over d})\lfloor {n\over T} \rfloor \lfloor {m\over T} \rfloor}$$

为了方便求，加个括号：

$$\prod_{T=1}^{n}(\prod_{d|T}f_T^{\mu({T\over d})})^{\lfloor {n\over T} \rfloor \lfloor {m\over T} \rfloor}$$

令：

$$F(n)=\prod_{d|n}f_d^{\mu({n\over d})}$$

则原式最终等于

$$\prod_{T=1}^{n}F(T)^{\lfloor {n\over T} \rfloor \lfloor {m\over T} \rfloor}$$

内层的 $F(T)$ 可以暴力求，外层的 $\lfloor {n\over T} \rfloor \lfloor {m\over T} \rfloor$ 就是一个很明显的数论分块式了，直接上数论分块就行了。

```cpp
#include<bits/stdc++.h>
#define MAXN 1000000
using namespace std;
const int Mod=1e9+7;
int n,m,pri[MAXN+5],tot,f[MAXN+5],inv[MAXN+5],F[MAXN+5],mu[MAXN+5];
bool isp[MAXN+5];
int QuickPow(int x,int y)
{
	int res=1;
	while(y)
	{
		if(y&1) res=1ll*res*x%Mod;
		x=1ll*x*x%Mod;
		y>>=1;
	}
	return res;
}
void GetPrime()
{
	isp[1]=1;
	mu[1]=1;
	f[1]=1;
	inv[1]=1;
	for(int i=2;i<=MAXN;i++)
	{
		f[i]=(f[i-1]+f[i-2])%Mod;
		inv[i]=QuickPow(f[i],Mod-2);
		if(!isp[i])
		{
			pri[++tot]=i;
			mu[i]=-1;
		}
		for(int j=1;j<=tot && i*pri[j]<=MAXN;j++)
		{
			isp[i*pri[j]]=1;
			if(i%pri[j]) mu[i*pri[j]]=mu[i]*mu[pri[j]];
			else
			{
				mu[i*pri[j]]=0;
				break;
			}
		}
	}
	for(int i=0;i<=MAXN;i++) F[i]=1;
	for(int i=1;i<=MAXN;i++)
	{
		if(!mu[i]) continue;
		for(int j=i;j<=MAXN;j+=i) F[j]=1ll*F[j]*(mu[i]==1?f[j/i]:inv[j/i])%Mod;
	}
	for(int i=2;i<=MAXN;i++) F[i]=1ll*F[i]*F[i-1]%Mod;
}
int main()
{
	GetPrime();
	int Time;
	scanf("%d",&Time);
	while(Time--)
	{
		scanf("%d %d",&n,&m);
		if(n>m) swap(n,m);
		int ans=1,INV;
		int l=1,r;
		while(l<=n)
		{
			r=min(n/(n/l),m/(m/l));
			INV=1ll*F[r]*QuickPow(F[l-1],Mod-2)%Mod;
			ans=1ll*ans*QuickPow(INV,(1ll*(n/l)*(m/l))%(Mod-1))%Mod;
			l=r+1;
		}
		printf("%d\n",(ans+Mod)%Mod);
	}
	return 0;
}
```

---


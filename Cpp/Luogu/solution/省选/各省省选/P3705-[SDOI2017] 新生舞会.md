# [SDOI2017] 新生舞会

## 题目描述

学校组织了一次新生舞会，Cathy 作为经验丰富的老学姐，负责为同学们安排舞伴。


有 $n$ 个男生和 $n$ 个女生参加舞会，一个男生和一个女生一起跳舞，互为舞伴。


Cathy 收集了这些同学之间的关系，比如两个人之前认识没，计算得出 $a_{i,j}$。

Cathy 还需要考虑两个人一起跳舞是否方便，比如身高体重差别会不会太大，计算得出 $b_{i,j}$，表示第 $i$ 个男生和第 $j$ 个女生一起跳舞时的不协调程度。


当然，还需要考虑很多其他问题。


Cathy 想先用一个程序通过 $a_{i,j}$ 和 $b_{i,j}$ 求出一种方案，再手动对方案进行微调。

Cathy 找到你，希望你帮她写那个程序。


一个方案中有 $n$ 对舞伴，假设每对舞伴的喜悦程度分别是 $a'_1,a'_2,...,a'_n$，假设每对舞伴的不协调程度分别是 $b'_1,b'_2,...,b'_n$。令

$C=\frac {a'_1+a'_2+...+a'_n}{b'_1+b'_2+...+b'_n}$

Cathy 希望 $C$ 值最大。

## 说明/提示

对于 $10\%$ 的数据，$1 \le n \le 5$。

对于 $40\%$ 的数据，$1 \le n \le 18$。

另有 $20\%$ 的数据，$b_{i,j} = 1$。

对于 $100\%$ 的数据，$1 \le n \le 100,1 \le a_{i,j},b_{i,j} \le 10^4$。

## 样例 #1

### 输入

```
3
19 17 16
25 24 23
35 36 31
9 5 6
3 4 2
7 8 9```

### 输出

```
5.357143```

# 题解

## 作者：Soulist (赞：12)

然而类似方格取数问题套上一个分数规划。。。

题面意思大致是给一个 $n*n$ 的矩阵，每个元素有两个权值$(a,b)$

每行每列都只能选一个，最大化$\dfrac{\sum_{i=1}^na_i}{\sum_{i=1}^nb_i}$

设$C=\dfrac{\sum_{i=1}^na_i}{\sum_{i=1}^nb_i}$

稍做变形：$C*\sum_{i=1}^nb_i = \sum_{i=1}^n a_i$

即：

$$\sum_{i=1}^na_i - C*b_i=0$$

考虑二分$C$值，然后套上费用流求解即可。

建图比较简单，每行向源点连$1$，每列向汇点连$1$，费用均为 $0$ 

然后每行向每列连流量$1$ 费用 $a_{i,j}-C*b_{i,j}$

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
    char cc = getchar(); int cn = 0, flus = 1;
    while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
    while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
    return cn * flus;
}
const int M = 2e5 + 5 ; 
const int N = 200 + 5 ; 
#define inf 123456789
#define eps 1e-8
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
struct E {
    int to, next, w;
    double f ; 
} e[M * 2]; 
int head[N * 2], cur[N * 2], cnt, n, mark[N * 2], vis[N * 2], s, t ;
double dis[N * 2], Ans, a[N][N], b[N][N] ;
void add( int x, int y, int z, double f ) {
    e[++ cnt] = (E){ y, head[x], z, f }, head[x] = cnt ; 
    e[++ cnt] = (E){ x, head[y], 0, -f }, head[y] = cnt ; 
} 
queue< int > q; 
bool spfa() {
    rep( i, s, t ) dis[i] = - inf ; 
    memset( vis, 0, sizeof(vis) ) ;
    q.push(s) ; dis[s] = 0 ;
    while( !q.empty() ) {
        int u = q.front() ; q.pop() ; vis[u] = 0;
        Next( i, u ) {
            int v = e[i].to ; 
            if( dis[v] < dis[u] + e[i].f && e[i].w ) {
                dis[v] = dis[u] + e[i].f;
                if( !vis[v] ) q.push(v), vis[v] = 1; 
            }	
        }
    }
    return dis[t] != -inf ;
}
int dfs( int x, int dist ) {
    mark[x] = 1 ; 
    if( x == t ) return dist ; 
    int flow = 0 ; 
    for( register int &i = cur[x]; i; i = e[i].next ) {
        int v = e[i].to ; 
        if( !mark[v] && dis[v] == dis[x] + e[i].f && e[i].w ) {
            int di = dfs( v, min( dist, e[i].w ) ) ; 
            if( di > 0 ) {
                e[i].w -= di, e[i ^ 1].w += di;
                flow += di, dist -= di ; 
                Ans += di * e[i].f ; 
                if( dist == 0 ) return flow ; 
            }
        }
    }
    return flow ;
}
void zkwflow() {
    Ans = 0;
    while(spfa()) {
        memcpy( cur, head, sizeof(head) ) ;
        mark[t] = 1 ; 
        while( mark[t] ) {
            memset( mark, 0, sizeof(mark) ) ;
            dfs( s, inf ) ;
        }
    }
} 
bool check( double x ) {
    s = 0, t = 2 * n + 1 ; cnt = 1;
    memset( head, 0, sizeof(head) );
    rep( i, 1, n ) add( s, i, 1, 0 ), add( i + n, t, 1, 0 ) ;
    rep( i, 1, n ) rep( j, 1, n ) add( i, j + n, 1, a[i][j] - x * b[i][j] );
    zkwflow() ;
    return Ans >= 0 ;
}
void solve() {
    double l = 0, r = 10000 + 5, mid, ans = 0 ;
    while( r - l > eps ) {
        mid = ( l + r ) / 2.0 ; 
        if( check(mid) ) ans = mid, l = mid + eps ; 
        else r = mid - eps ;
    }
    printf("%.6lf\n", ans ) ;
}
signed main()
{
    n = read() ; 
    rep( i, 1, n ) rep( j, 1, n ) a[i][j] = read() ; 
    rep( i, 1, n ) rep( j, 1, n ) b[i][j] = read() ; 
    solve() ; 
    return 0;
}
```

---

## 作者：Log_x (赞：10)

**费用流+分数规划+二分答案**


首先我们可以想到二分答案C，但C的满足条件似乎并不好处理


但我们可以利用分数规划的思想将C进行转换



```cpp
C = (a1 + a2 + …… + an) / (b1 + b2 + …… + bn)
(b1 + b2 + …… + bn) * C = (a1 + a2 + …… + an)
(a1 + a2 + …… + an) - (b1 + b2 + …… + bn) * C = 0
(a1 - b1 * C) + (a2 - b2 * C) + …… + (an - bn * C) = 0
```
由此我们得出这道二分图的最小费用最大流：

1)将源点向每个男生连一条流量为1、费用为0的边


2)将每个女生向汇点连一条流量为1、费用为0的边


3)将每一对男女舞伴间连一条流量为1、费用为[a[i][j] - b[i][j] \* C]的边


然后每次判断最小费用是否小于（或大于）0来缩小边界，最后得到答案。


**代码如下：**


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const double Maxn = 1e9;
const int N = 205, M = 8e4 + 5;
const double eps = 1e-8;
int pre[N], nxt[M], to[M], lst[N], fr[M], flw[M], Q[M];
int n, s, t, T; bool vis[N];
double a[N][N], b[N][N], cst[M], Ans, dis[N]; 
template <class T> inline void CkMin(T &a, const T b) {if (a > b) a = b;}
inline void Add(const int x, const int y, const int z, const double g)
{
    nxt[++T] = lst[x]; lst[x] = T; to[T] = y; fr[T] = x; flw[T] = z; cst[T] = g;
    nxt[++T] = lst[y]; lst[y] = T; to[T] = x; fr[T] = y; flw[T] = 0; cst[T] = -g;
}
inline bool Bul()
{
    for (int i = s; i <= t; ++i) dis[i] = -Maxn;
    int te = 0, we = 1, x, y; 
    dis[Q[1] = s] = 0.0;
    while (te < we)
    {
        x = Q[++te]; vis[x] = false;
        for (int i = lst[x]; i; i = nxt[i])
        if (dis[y = to[i]] < dis[x] + cst[i] && flw[i])
        {
            dis[y] = dis[x] + cst[i]; pre[y] = i; 
            if (!vis[y]) vis[y] = true, Q[++we] = y;
        }
    }
    return dis[t] > -Maxn;
}
inline void Deal()
{
    int Mif = Maxn;
    for (int i = pre[t]; i; i = pre[fr[i]]) CkMin(Mif, flw[i]);
    for (int i = pre[t]; i; i = pre[fr[i]])
     flw[i] -= Mif, flw[i ^ 1] += Mif, Ans += (double)Mif * cst[i];
}
inline bool check(const double mi)
{
    T = 1; memset(lst, 0, sizeof(lst));
    for (int i = 1; i <= n; ++i) 
     Add(s, i, 1, 0), Add(i + n, t, 1, 0);
    for (int i = 1; i <= n; ++i)
     for (int j = 1; j <= n; ++j)
      Add(i, j + n, 1, a[i][j] - mi * b[i][j]);
    Ans = 0.0; while (Bul()) Deal();
    return (Ans <= 0); 
}
int main()
{
    scanf("%d", &n); s = 0; t = (n << 1) + 1;
    for (int i = 1; i <= n; ++i)
     for (int j = 1; j <= n; ++j) scanf("%lf", &a[i][j]);
    for (int i = 1; i <= n; ++i)
     for (int j = 1; j <= n; ++j) scanf("%lf", &b[i][j]);
    double l = 0, r = 1e4;
    while (r - l >= eps)
    {
        double mid = (l + r) / 2;
        (check(mid) ? r : l) = mid;
    } 
    return printf("%.6lf\n", l), 0;
}
```

---

## 作者：xyz32768 (赞：9)

由于题目求的是最优配对方案，所以很容易想到建一个二分图后用费用流求解，即建立源点和汇点，由源点向每个男生连一条容量为$1$的边，由每个女生向汇点连一条容量为$1$的边，再从任意一个男生向任意一个女生连一条容量为$1$的边。

再考虑费用分配。这时候主要的问题在于$C=\frac{\sum a}{\sum b}$这个式子中$\sum b$在分母位置，无法简单求和。因此可以利用分数规划的思想去掉分母。先二分答案$ans$。

接下来判断最优解$C$能否大于或等于$ans$。把式子$C=\frac{\sum a}{\sum b}$变形后为$\sum a-C\sum b=0$。这时候就可以推出如果$C\geq ans$，就一定存在一种$\sum a,\sum b$的合法分配方案，使得$\sum a-ans\sum b\geq 0$。此时就可以得出，源点连向男生，以及女生连向源点的边的费用都为$0$，第$i$个男生向第$j$个女生的边的费用为$a_{i,j}-ans*b_{i,j}$。建图完成后，如果**最大费用**最大流大于等于$0$，那么$C\geq ans$。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int L = 105, N = 5e5 + 5; const double eps = 1e-8;
int n, a[L][L], b[L][L], ecnt, nxt[N], adj[N], go[N], cap[N], len,
que[N], S, T; double cost[N], dis[N], ans;
bool vis[N], walk[N];
void add_edge(int u, int v, int w, double x) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;
    cap[ecnt] = w; cost[ecnt] = x;
    nxt[++ecnt] = adj[v]; adj[v] = ecnt; go[ecnt] = u;
    cap[ecnt] = 0; cost[ecnt] = -x;
}
bool spfa() {
    int i; for (i = S; i <= T; i++) dis[i] = -1e20, walk[i] = 0;
    dis[que[len = 1] = S] = 0;
    for (i = 1; i <= len; i++) {
        int u = que[i]; vis[u] = 0;
        for (int e = adj[u], v; e; e = nxt[e])
            if (cap[e] > 0 && dis[u] + cost[e] > dis[v = go[e]]) {
                dis[v] = dis[u] + cost[e];
                if (!vis[v]) vis[que[++len] = v] = 1;
            }
    }
    return dis[T] >= -1e19;
}
int dfs(int u, int flow) {
    if (u == T) return ans += dis[T] * flow, flow;
    int res = 0, delta; walk[u] = 1;
    for (int e = adj[u], v; e; e = nxt[e])
        if (!walk[v = go[e]] && cap[e] > 0 &&
        abs(dis[v] - dis[u] - cost[e]) <= eps) {
            delta = dfs(v, min(cap[e], flow - res));
            if (delta) {
                cap[e] -= delta; cap[e ^ 1] += delta;
                res += delta; if (res == flow) break;
            }
        }
    return res;
}
double mcmf() {
    ans = 0;
    while (spfa()) dfs(S, 0x3f3f3f3f);
    return ans;
}
bool check(double mid) {
    int i, j; ecnt = S = 1; T = (n << 1) + 2;
    for (i = S; i <= T; i++) adj[i] = 0;
    for (i = 1; i <= n; i++) add_edge(S, i + 1, 1, 0);
    for (i = n + 2; i < T; i++) add_edge(i, T, 1, 0);
    for (i = 1; i <= n; i++) for (j = 1; j <= n; j++)
        add_edge(i + 1, j + n + 1, 1, 1.0 * a[i][j] - 1.0 * b[i][j] * mid);
    double ap = mcmf(); return abs(ap) <= eps || ap > eps;
}
int main() {
    int i, j; n = read();
    for (i = 1; i <= n; i++) for (j = 1; j <= n; j++)
        a[i][j] = read();
    for (i = 1; i <= n; i++) for (j = 1; j <= n; j++)
        b[i][j] = read();
    double l = -1e7, r = 1e7;
    while (abs(r - l) > eps) {
        double mid = (l + r) / 2;
        if (check(mid)) l = mid;
        else r = mid;
    }
    printf("%.6lf\n", r);
    return 0;
}
```

---

## 作者：gyyyyx (赞：2)

好久没发题解了，估值掉了一堆o(╥﹏╥)o

观察到题目中要求 $\frac{\sum{a'}}{\sum{b'}}$ 的最大值，联想到 01 分数规划。

那么就可以使用二分答案。

推一下柿子（其实没啥好推的）：

显然，要使 $ans\geq mid$，$\frac{\sum{a'}}{\sum{b'}}\geq mid$ 是充分必要条件。

原式变形后得：$\sum{(a'-mid\cdot b')}\geq 0$。

因此我们只需要找到一种配方案使得 $\sum{(a'-mid\cdot b')}$ 最大，当最大值大于 $0$ 时说明 $ans\geq mid$。

那如何找到最大值呢？

当我们给每个男生和女生之间连边，就会得到一个二分图。

而第 $i$ 个男生和第 $j$ 个女生之间边的权值就是 $a_{i,j}-mid\cdot b_{i,j}$。

那我们观察到此二分图中一种匹配方案就对应着一种男女生配对方案。

所以最大值就是匹配中的最大权值和，可以用网络费用流孑孓。

不会网络流的童鞋可以看看我的这篇 [blog](https://www.luogu.com.cn/blog/s19418/wang-lao-liu-xue-xi-bi-ji)。

因此思路就搞定了，上代码：

```cpp
#include<bits/stdc++.h>
#define eps 0.00000001
#define INF 1000000000
#define M 80005
#define N 105
using namespace std;
int n,s,t,a[N][N],b[N][N];
struct Edge{
    int to,nxt,flw;double cst;
    Edge(int a=0,int b=0,int c=0,double d=0):to(a),nxt(b),flw(c),cst(d){}
};
struct Edge e[M];
int head[N<<1],cnt;
inline void Add(int u,int v,int w,double c){
    e[++cnt]=Edge(v,head[u],w,c);head[u]=cnt;
    e[++cnt]=Edge(u,head[v],0,-c);head[v]=cnt;
}
double dis[N<<1];
bool vis[N<<1];
queue <int> q;
inline bool SPFA(){
    for(int i(s);i<=t;++i) dis[i]=-INF,vis[i]=0;
    dis[s]=0;vis[s]=1;q.push(s);
    while(!q.empty()){
        int u(q.front());
        q.pop();vis[u]=0;
        for(int i(head[u]);~i;i=e[i].nxt){
            if(!e[i].flw) continue;
            int v(e[i].to);
            if(dis[u]+e[i].cst>dis[v]){
                dis[v]=dis[u]+e[i].cst;
                if(!vis[v]) q.push(v),vis[v]=1;
            }
        }
    }
    return dis[t]!=-INF;
}
int cur[N<<1];double ans;
int Dfs(int u,int limit){
    if(u==t||!limit) return limit;
    vis[u]=1;int f(0);
    for(int i(cur[u]);(~i)&&limit;i=e[i].nxt){
        cur[u]=i;int v(e[i].to);
        if(e[i].flw&&!vis[v]&&dis[v]==dis[u]+e[i].cst){
            int tmp(Dfs(v,min(limit,e[i].flw)));
            e[i].flw-=tmp;e[i^1].flw+=tmp;
            limit-=tmp;f+=tmp;
            ans+=e[i].cst*tmp;
        }
    }
    if(f) vis[u]=0;
    return f;
}
inline void Dinic(){
    while(SPFA()){
        for(int i(s);i<=t;++i) vis[i]=0;
        for(int i(s);i<=t;++i) cur[i]=head[i];
        while(Dfs(s,INF));
    }
}
inline bool Check(double x){
    for(int i(s);i<=t;++i) head[i]=-1;cnt=-1;
    for(int i(1);i<=n;++i){
        Add(s,i,1,0);
        Add(i+n,t,1,0);
    }
    for(int i(1);i<=n;++i)
        for(int j(1);j<=n;++j)
            Add(i,j+n,1,a[i][j]-x*b[i][j]);
    ans=0;Dinic();
    return ans>-eps;
}
int main(){
    scanf("%d",&n);
    for(int i(1);i<=n;++i)
        for(int j(1);j<=n;++j)
            scanf("%d",&a[i][j]);
    for(int i(1);i<=n;++i)
        for(int j(1);j<=n;++j)
            scanf("%d",&b[i][j]);
    s=0;t=(n<<1)+1;
    double l(0),r(10000),mid;
    while(r-l>eps){
        mid=(l+r)/2.0;
        if(Check(mid)) l=mid;
        else r=mid;
    }
    printf("%.6f\n",l);
    return 0;
}
```

当然实际码代码中还有很多细节要思考。

比如数组的大小，精度问题等等。

建议看完题解后自己码一遍。

然后……完结✿✿ヽ(°▽°)ノ✿

---

## 作者：漠寒 (赞：2)

## 分析

做了几道分数规划题，选一些来写题解。

首先观察答案形式，就是求最终 $(\dfrac{\sum a_i'}{\sum b_i'})\geqslant ans$ 最大的 $ans$，在转化一下形式，就是 $\sum a_i'-ans\times b_i'\geqslant 0$。

所以我们去二分答案（显然越小的答案最终越容易使上面式子满足），然后每一组对答案的贡献就能计算出，然后又要求每一个人都要找到各自舞伴，式子中的大于等于可以视为使左边的值最大，所以在 check 函数中我们男女生建点，每一组的贡献用作建边，男生向女生建边，流量为 $1$，费用 $a[i][j]-mid\times b[i][j]$，超级源点向男生，女生向超级汇点建流量 $1$，费用 $0$ 的边，验证最大费用是否大于等于 $0$ 即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
inline void read(int &res){
	res=0;
	int f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')res=(res<<1)+(res<<3)+c-48,c=getchar();
	res*=f;
}
int n,s,t;
int a[105][105];
int b[105][105];
int head[210],tot;
struct edge{
	int to,nex,w;
	double bq;
}e[100000];
inline void add(int qq,int mm,int w,double bq){
	e[++tot].to=mm;
	e[tot].nex=head[qq];
	e[tot].w=w;
	e[tot].bq=bq;
	head[qq]=tot;
}
double dis[210];
int pre[210],incf[210];
queue<int>q;
int vis[210];
bool spfa(){
	for(int i=1;i<=t;i++){
		dis[i]=-1e18;
		incf[i]=1e9;
	}
	q.push(s);
	while(q.size()){
		int x=q.front();q.pop();
		vis[x]=0;
		for(int i=head[x];i;i=e[i].nex){
			if(!e[i].w)continue;
			int v=e[i].to;
			if(dis[v]<dis[x]+e[i].bq){
				pre[v]=i;
				dis[v]=dis[x]+e[i].bq;
				incf[v]=min(incf[v],e[i].w);
				if(!vis[v])q.push(v);
				vis[v]=1;
			}
		}
	}
	return incf[t]<1e9;
}
bool check(double x){
	memset(head,0,sizeof(head));
	tot=1;
	for(int i=1;i<=n;i++){
		add(0,i,1,0);
		add(i,0,0,0);
		for(int j=1;j<=n;j++){
			double bq=-x*b[i][j]+a[i][j];
			add(i,j+n,1,bq);
			add(j+n,i,0,-bq);
		}
		add(i+n,t,1,0);
		add(t,i+n,0,0);
	}
	double sum=0;
	while(spfa()){
		sum+=incf[t]*dis[t];
		int x=t;
		while(x!=s){
			e[pre[x]].w--;
			e[pre[x]^1].w++;
			x=e[pre[x]^1].to;
		}
	}
	return sum>=0;
}
int main()
{
	read(n);
	s=0;t=2*n+1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)read(a[i][j]);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)read(b[i][j]);
	}
	double l=0,r=10000;
	while(r-l>=1e-7){
		double mid=(l+r)/2.0;
		if(check(mid))l=mid+1e-8;
		else r=mid-1e-8;
	}
	printf("%.6lf",l);
}

```


---

## 作者：nianheng (赞：2)

### 分数规划，最大费用最大流#

题意可以简化为给出一个矩阵，要求每行和每列必须且只能取一个格子，要求$sigma\ a_{i,j}/sigma\ b_{i,j}$ 最大

考虑分数规划，可以将式子转化：

$sigma\ a_{i,j}/sigma\ b_{i,j}=C$

$sigma\ a_{i,j}=sigma\ b_{i,j}*C$

$sigma\ a_{i,j}-sigma\ b_{i,j}*C=0$

$sigma(\ a_{i,j}-b_{i,j}*C)=0$

C就是我们要求的最大值，我们可以$mid$实数二分它，对于每一个$mid$，求出这种情况下$sigma(\ a_{i,j}-b_{i,j}*mid)=0$的最大值，如果最大值小于0，就说明$mid>C$，反之亦然。

至于怎么求最大值，可以将横坐标建一个点集，纵坐标建一个点集，对于每个矩阵上的点$a_{i,j}$建一条从i到j的弧，流量为1，费用为$a_{i,j}-sigma\ b_{i,j}*mid$，然后跑最大费用最大流就行了

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#include<map>
#define inf 0x7fffffff
using namespace std;
inline int read()
{
	int ans=0,fh=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			fh=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
		ans=(ans<<1)+(ans<<3)+ch-'0',ch=getchar();
	return ans*fh;
}
const int maxn=300;
const int maxm=10010;
const double eps=0.00000001;
int s,t,v[maxm*2],u[maxm*2],w[maxm*2],qq[maxn],ll[maxn],nex[maxm*2],head[maxn],num=1,n,a[110][110],b[110][110];
double f[maxm*2],bj[maxn],l,r,mid;
bool cz[maxn];
queue<int>q;
void add(int x,int y,double fee)
{
	u[++num]=x;
	v[num]=y;
	w[num]=1;
	f[num]=fee;
	nex[num]=head[x];
	head[x]=num;
	u[++num]=y;
	v[num]=x;
	w[num]=0;
	f[num]=-fee;
	nex[num]=head[y];
	head[y]=num;
}
bool spfa()
{
	memset(qq,0,sizeof(qq));
	for(int i=1;i<=n*2+2;i++)
		bj[i]=2100000000;
	memset(ll,0,sizeof(ll));
	q.push(s);
	bj[s]=0;
	ll[s]=inf;
	while(!q.empty())
	{
		int now=q.front();
		q.pop();
		cz[now]=0;
		for(int i=head[now];i;i=nex[i])
			if(w[i]&&bj[v[i]]>bj[now]+f[i])
			{
				bj[v[i]]=bj[now]+f[i];
				ll[v[i]]=min(w[i],ll[now]);
				qq[v[i]]=i;
				if(!cz[v[i]])
					q.push(v[i]),cz[v[i]]=1;
			}
	}
	return qq[t]>0;
}
double EK()
{
	double fee=0;
	while(spfa())
	{
		int liu=ll[t];
		for(int i=qq[t];i;i=qq[u[i]])
			w[i]-=liu,w[i^1]+=liu;
		fee+=liu*bj[t];
	}
	return fee*-1;
}//最大费用最大流
double work(double x)
{
	memset(head,0,sizeof(head));
	num=1;
	for(int i=1;i<=n;i++)
		add(s,i,0),add(i+n,t,0);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			add(i,j+n,(double)x*b[i][j]-a[i][j]);//建图
	return EK();
}
int main()
{
	n=read();
	s=n*2+1;t=s+1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			a[i][j]=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			b[i][j]=read();
	r=1000000;
	while(r-l>eps)
	{
		mid=(l+r)*0.5;
		double dd=work(mid);
		if(dd>=0)
			l=mid;
		else
			r=mid;
	}//实数二分
	printf("%.6lf",l);
	fclose(stdin);
	return 0;
}

```

---

## 作者：shadowice1984 (赞：2)

不知道为什么我一吸氧就开始疯狂炸……

(总之是在没有$O_{2}$的情况下疯狂卡常过了这道题)

## 01分数规划

看起来这道题似乎非常的不可做

但是熟练的OIER应该一眼就可以推出做法吧

首先我们发现题目中给出的式子是这样的

最大化

# $Mid=\frac{\sum a_{i,j}}{\sum b_{i,j}}$

那么我们可以认为这是一个网格图，每个格子上有一个物品，价值为$a_{i,j}$,代价为$b_{i,j}$现在要求你**每一行每一列取且仅能取一个**，求$Mid$最大值

如果你学习过一种叫01分数规划的东西的话，你会意识到，处理这类问题第一反应是二分答案，更准确的来讲，我们判断我们二分的答案mid是否比真实答案大，这样就可以求出这个函数的值了

让我们来试着变换下刚才的式子

# $\sum a_{i,j}-\sum Midb_{i,j}=0$

也就是说如果mid=c，那么这个式子最大值会等于0

如果mid>c这个式子最大值会小于0

如果mid<c这个式子最大值会大于0

然后我们就可以就此二分答案了

唯一要解决的问题是，在给定mid的前提下如何求出刚才那个式子的最大值

显然我们可以把一个格子的权值变成$a_{i,j}-Midb_{i,j}$现在唯一要考虑的问题就是如何满足**每一行每一列取且仅能取一个**的前提下做到最优

这里我们需要使用网络流描述一个互斥的关系，如果你足够熟练的话应该可以很快反应过来这是**行列拆点**

具体来讲我们把每一行和每一列看作点，每一个点看作行列间的一条边，那么我们如果从源点向所有行点连一条容量为1的边，所有列点向汇点连一条容量为1的边，那么我们会发现这样可以满足每个行列都只选一次的限制条件

剩下的事情就是把每个点作为一个容量为1的点连入，然后点权作为边权跑费用流就好了

(不就是二分图最大带权匹配吗……会的话不需要我多说吧)

## 卡常数

本题唯一的难点在于丧心病狂的$10^{-6}$精度要求，因此我们的二分次数将不可避免的多

具体来讲卡常数的办法就是去掉你程序里的全部结构题再手写一个队列，依靠信仰可以通过卡常来通过本题

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;const int N=110;typedef double db;db eps=1e-8;int n;
int v[4*N*N];int x[4*N*N];int c[4*N*N];db val[4*N*N];
int al[2*N];int ct=1;int rst[4*N*N];//去掉了所有的结构体，大家凑合着看吧 
inline void add(int p,int y)
{
    v[++ct]=y;x[ct]=al[p],c[ct]=1;al[p]=ct;rst[ct]=1;
    v[++ct]=p;x[ct]=al[y];c[ct]=0;al[y]=ct;rst[ct]=0;
}db cost;db d[2*N];int s;int t;int ctt;int q[4000010];int hd=1;int til;
int fr[2*N];int nu[2*N];bool book[2*N];
inline bool spfa()
{
    for(int i=1;i<=ctt;i++){d[i]=-0x3f3f3f3f;}d[s]=0;
    for(q[++til]=s;hd<=til;++hd)//这里手写了队列…… 
    {
        for(int w=q[hd],i=al[w];i;i=x[i])//spfa不说了 
        {
            if(d[v[i]]<d[w]+val[i]&&c[i]!=0)
            {
                fr[v[i]]=w;nu[v[i]]=i;d[v[i]]=d[w]+val[i];
                if(!book[v[i]]){q[++til]=v[i];book[v[i]]=true;}
            }
        }book[q[hd]]=false;
    }hd=1;til=0;//记得手动清空 
    if(d[t]==-0x3f3f3f3f){return false;}//这里为了省常数直接+1-1因为边权只有1和0 
    for(int p=t;p!=s;p=fr[p]){c[nu[p]]-=1;c[nu[p]^1]+=1;}
    cost+=d[t];return true;
}db a[N][N];db b[N][N];int tr[N][N];
inline void rebuild(db mid)//这里维护了一个点到边的映射 
{
    for(int i=1;i<=ct;i++){c[i]=rst[i];}
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)//重新设置下边权 
        {
        	val[tr[i][j]]=a[i][j]-b[i][j]*mid;
            val[tr[i][j]^1]=-val[tr[i][j]];
        }
    }cost=0;
}
int main()
{
    scanf("%d",&n);ctt=2*n;s=++ctt;t=++ctt;
    for(int i=1;i<=n;i++){for(int j=1;j<=n;j++){scanf("%lf",&a[i][j]);}}
    for(int i=1;i<=n;i++){for(int j=1;j<=n;j++){scanf("%lf",&b[i][j]);}}
    for(int i=1;i<=n;i++){add(s,i);add(n+i,t);}//加边 
    for(int i=1;i<=n;i++){for(int j=1;j<=n;j++){add(i,n+j);tr[i][j]=ct-1;}}
    db l=0;db r=1e4;
    while(r-l>eps)//二分答案 
    {
        db mid=(l+r)/2;rebuild(mid);
        while(spfa());if(cost<0){r=mid;}else {l=mid;}
    }printf("%.6lf",l);return 0;//拜拜程序~ 
}
```







---

## 作者：Victorique (赞：2)

做完这个题之后对这个题产生了深深地厌恶。。。

出题人出这个题还不SPJ估计就是为了恶心人的。

显然二分答案，然而由于精确到小数点后6位，导致我们必须把二分的级数增大10^6。

连边什么的楼下（可能马上就变成楼上了），几位都说的很明白了，就是把题目中的分式化成一个等式，判断最终结果是否小于0即可。

作为其他题解的一些补充，说一下防止T的一些方法：

①不要随便增大二分上界，算好了写

②最好还是把计算时的数据* 1e7，最后一块除掉，要不可能出现玄学导致死循环。。

③不要开大数组，memset会教你做人的。

④结构体尽量改成数组吧，貌似好像会快一些。

⑤请尽量使用较高级的算法搞这个题

⑥然而我们依然要保证一定的精度，第5个点，很容易你就出问题，然后还有一第9个点，数据不是最大的但是T的很厉害。

⑦记住memset数组还有num的重置。。。

# ⑧最重要的————>O2优化
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#define inf 1000000000000001ll
#define maxxx 500000001
#define re register
#define ll long long
#define min(a,b) a<b?a:b 
using namespace std;
const long double eps=0.00000007;
struct po{
	int to,nxt,w;
	ll dis;
};
po edge[800001];
int n,m,s,t,b[205],p;
int head[205],num=-1;
ll tot,dis[205],pa[501][501],pb[501][501];
inline int read()
{
    int x=0,c=1;
    char ch=' ';
    while((ch>'9'||ch<'0')&&ch!='-')ch=getchar();
    while(ch=='-')c*=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-'0',ch=getchar();
    return x*c;
}
inline void add_edge(int from,int to,int w,ll dis)
{
	edge[++num].nxt=head[from];
	edge[num].to=to;
	edge[num].w=w;
	edge[num].dis=dis;
	head[from]=num;
}
inline void add(int from,int to,int w,ll dis)
{
	add_edge(from,to,w,dis);
	add_edge(to,from,0,-dis);
}
inline bool spfa()
{
	for(re int i=s;i<=t;i++) dis[i]=inf+1;
	memset(b,0,sizeof(b));
	queue<int> q;
	q.push(t);
	dis[t]=0;
	b[t]=1;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		b[u]=0;
		for(re int i=head[u];i!=-1;i=edge[i].nxt){
			int v=edge[i].to;
			if(edge[i^1].w>0&&dis[v]>dis[u]-edge[i].dis){
				dis[v]=dis[u]-edge[i].dis;
				if(!b[v]){
					b[v]=1;
					q.push(v);
				}
			}
		}
	}
	return dis[s]<inf;
}
inline int dfs(int u,int low)
{
	b[u]=1;
	if(u==t) return low;
	int diss=0;
	for(re int i=head[u];i!=-1;i=edge[i].nxt){
		int v=edge[i].to;
		if(edge[i].w&&!b[v]&&dis[v]==dis[u]-edge[i].dis){
			int check=dfs(v,min(edge[i].w,low));
			if(check){
				tot+=check*edge[i].dis;
				low-=check;
				diss+=check;
				edge[i].w-=check;
				edge[i^1].w+=check;
				if(low==0) break;
			}
		}
	}
	return diss;
}
inline void max_flow()
{
	int ans=0;
	while(spfa()){
		b[t]=1;
		while(b[t]){
			memset(b,0,sizeof(b));
			ans+=dfs(s,maxxx);
			
		}
	}
	return;
}
inline void build(ll x)
{
	memset(head,-1,sizeof(head));
	num=-1;tot=0;
	for(re int i=1;i<=n;i++)
	add(s,i,1,0),add(n+i,t,1,0);
	for(re int i=1;i<=n;i++)
	 for(re int j=1;j<=n;j++)
	 add(i,j+n,1,-(pa[i][j]-pb[i][j]*x));
}
inline bool check(ll x)
{
	build(x);
	max_flow();
	if(-tot<=0) return 1;
	else return 0;
}
int main()
{
	n=read();
	for(re int i=1;i<=n;i++) 
	 for(re int j=1;j<=n;j++)
	 pa[i][j]=read(),pa[i][j]*=5000000;
	for(re int i=1;i<=n;i++)
	 for(re int j=1;j<=n;j++)
	 pb[i][j]=read();
	 s=0,t=n+n+1;
	ll l=1,r=50000000000ll;
	while(r>=l){
		ll mid=(l+r)/2;
		if(check(mid))
		r=mid-1; else
		l=mid+1;
	}
	printf("%.6lf",l*1.0/5000000);
}
```

---

## 作者：hegm (赞：1)

### [P3705 [SDOI2017]新生舞会](https://www.luogu.com.cn/problem/P3705)

考虑到求的是最大值，我们二分 $mid$。

$\dfrac{\sum a}{\sum b}<mid\to \sum a<\sum b\times mid\to\sum (a_i-mid\times b_i)<0$

问题转化，我们考虑这个式子的实际意义是对男生女生进行二分图匹配，匹配是有代价的，两个人匹配的代价为 $a_{i,j}-b_{i,j}\times mid$。

那么考虑二分的具体内容，我们只要证明当前的 $mid$ 存在 $\sum (a_i-mid\times b_i)>0$
 即可，如果存在 $r=mid$ 否则 $l=mid$。
 
 问题是如何证明/寻找最大的 $\sum (a_i-mid\times b_i)$，不难发现，它类似于费用流的形式，同时又因为网络流兼容二分图，所以我们可以通过找最小费用最大流来寻找最小值，既然是找最小值，我们就要把边权变为 $mid\times b_i-a_i$ 进行寻找。
 
具体的看下代码。

### CODE
```cpp
#include<bits/stdc++.h>
#define N 105
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const double eps=1e-7;
const int inf=10000000009;
int n,a[N][N],b[N][N],head[N],tot=1;
double co;
int s=0,t;
struct node
{
	int from,val,to,next,ini;
	double a,b,cost;
}k[N*N*N];
void add(int from,int to,int val,int a,int b)
{
	k[++tot].to=to;
	k[tot].from=from;
	k[tot].next=head[from];
	k[tot].ini=val;
	k[tot].a=a;
	k[tot].b=b;
	head[from]=tot;
}
bool vis[N*N];
double dis[N*N];
queue<int> q;
bool spfa()
{
	for(int i=s;i<=t;i++)dis[i]=inf;
	memset(vis,0,sizeof(vis));
	while(q.size())q.pop();
	q.push(0);
	vis[0]=1;
	dis[0]=0;
	while(q.size())
	{
		int now=q.front();
		q.pop();
		vis[now]=0;
		for(int i=head[now],to;i;i=k[i].next)
		{
			to=k[i].to;
			if(k[i].val&&dis[to]>dis[now]+k[i].cost)
			{
				dis[to]=dis[now]+k[i].cost;
				if(!vis[to])
				{
					q.push(to);
					vis[to]=1;
				}
			}
		}
	}
	return dis[t]<inf;
}
int dfs(int now,int can)
{
	if(now==t)return can;
	vis[now]=1;
	int out=0;
	for(int i=head[now],to;i;i=k[i].next)
	{
		to=k[i].to;
		if(dis[to]!=dis[now]+k[i].cost||vis[to]||!k[i].val)continue;
		int res=dfs(to,min(can,k[i].val));
		k[i].val-=res;
		k[i^1].val+=res;
		co+=k[i].cost*res;
		out+=res;
		can-=res;
	}
	vis[now]=0;
	if(out==0)dis[now]=0;
	return out;
}
bool check(double mid)
{
	for(int i=1;i<=tot;i++)
	k[i].cost=k[i].b*mid-k[i].a,k[i].val=k[i].ini;
	int ans=0;co=0;
	while(spfa())
	{
		memset(vis,0,sizeof(vis));
		ans+=dfs(0,inf);
	}
	return co>0;
}
int main()
{
	n=read();t=2*n+1; 
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)a[i][j]=read();
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)b[i][j]=read();
	for(int i=1;i<=n;i++)
	{
		add(0,i,1,0,0);
		add(i,0,0,0,0);
	}
	for(int i=1;i<=n;i++)
	{
		add(i+n,t,1,0,0);
		add(t,i+n,0,0,0);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			add(i,j+n,1,a[i][j],b[i][j]);
			add(j+n,i,0,-a[i][j],-b[i][j]);
		}
	}
	double l=0,r=1e6,mid;
	while(r-l>eps)
	{
		mid=(l+r)/2.0;
		if(check(mid))r=mid;
		else l=mid;
	}
	printf("%.6f",l);
	return 0;
}

```

---

## 作者：Foreverxxx (赞：1)

广告：[一名 Blink 的博客](https://foreverxxx.blog.luogu.org/)

### 前言

非常让人不解的一道题，没有 SPJ 导致我调了半天二分精度才过……

### 思路

首先明确这是一道分数规划的题。由于答案具有单调性，我们考虑将答案进行二分。

对于所求的答案 $C$，我们需要将
$\ C=\dfrac{\sum\limits_{i=1}^{n}a_i}{\sum\limits_{i=1}^{n}b_i}$ 
最大化。

对于分数规划的题，很明显我们可以将式子化简为 
$\ C \times \sum\limits_{i=1}^{n}b_i=\sum\limits_{i=1}^{n}a_i$，即得到  $\ \sum\limits_{i=1}^{n}a_i - C \times \sum\limits_{i=1}^{b}b_i = 0$。

于是我们考虑二分答案 $C$，将所有的边均赋值为 $a_{i,j}-C \times b_{i,j}$，然后跑一次二分图最大权完美匹配，如果 KM 算法得到的答案大于等于 $0$，则将二分下界扩大，否则将二分上界缩小。

顺便说一句，虽然这道题 KM 算法跑得比网络流快，不过还是可以构造出数据来将 KM 算法的效率搞成 $O(n^4)$，不过没有关系，既然不卡网络流，那 KM 算法更不可能被卡了（实在不行就上 BFS 版本的 KM 吧）。

Code

```cpp#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sss=0,www=1;
	char chh=getchar();
	while(chh<'0'||chh>'9'){
		if(chh=='-') www=-1;
		chh=getchar();
	}
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss*www;
}
int n;
double delta;
double lx[105],ly[105];
int matched[105];
bool visx[105],visy[105];
double a[105][105],b[105][105];
double edge[105][105];
double l=0,r=1e4,eps=1e-7;
void remake_gragh(double mid){//二分答案后进行边的重新赋值操作
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=n;j++)
			edge[i][j]=a[i][j]-b[i][j]*mid;
	}
}
bool find(int now){
	visx[now]=true;
	for(register int i=1;i<=n;i++){
		if(!visy[i]){
			if(lx[now]+ly[i]-edge[now][i]>=-eps&&lx[now]+ly[i]-edge[now][i]<=eps){
				visy[i]=true;
				if(!matched[i]||find(matched[i])){
					matched[i]=now;
					return true;
				}
			}
			else delta=min(delta,lx[now]+ly[i]-edge[now][i]);
		}
	}
	return false;
}
double KM(){//常规的DFS版本的KM算法
	memset(lx,0x3f,sizeof lx);
	memset(ly,0,sizeof ly);
	memset(matched,0,sizeof matched);
	for(register int i=1;i<=n;i++){
		while(true){
			memset(visx,false,sizeof visx);
			memset(visy,false,sizeof visy);
			delta=1e18;
			if(find(i)) break;
			for(register int j=1;j<=n;j++){
				if(visx[j]) lx[j]-=delta;
				if(visy[j]) ly[j]+=delta;
			}
		}
	}
	double ans=0;
	for(register int i=1;i<=n;i++)
		ans+=edge[matched[i]][i];
	return ans;
}
int main(){
	n=read();
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=n;j++){
			a[i][j]=(double)read();
		}
	}
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=n;j++){
			b[i][j]=(double)read();
		}
	}
	while(l+eps<r){
		double mid=(l+r)/2;
		remake_gragh(mid);
		if(KM()>=0) l=mid;
		else r=mid;
	}
	printf("%.6lf",l);
	return 0;
}
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sss=0,www=1;
	char chh=getchar();
	while(chh<'0'||chh>'9'){
		if(chh=='-') www=-1;
		chh=getchar();
	}
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss*www;
}
int n;
double delta;
double lx[105],ly[105];
int matched[105];
bool visx[105],visy[105];
double a[105][105],b[105][105];
double edge[105][105];
double l=0,r=1e4,eps=1e-7;
void remake_gragh(double mid){
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=n;j++)
			edge[i][j]=a[i][j]-b[i][j]*mid;
	}
}
bool find(int now){
	visx[now]=true;
	for(register int i=1;i<=n;i++){
		if(!visy[i]){
			if(lx[now]+ly[i]-edge[now][i]>=-eps&&lx[now]+ly[i]-edge[now][i]<=eps){
				visy[i]=true;
				if(!matched[i]||find(matched[i])){
					matched[i]=now;
					return true;
				}
			}
			else delta=min(delta,lx[now]+ly[i]-edge[now][i]);
		}
	}
	return false;
}
double KM(){
	memset(lx,0x3f,sizeof lx);
	memset(ly,0,sizeof ly);
	memset(matched,0,sizeof matched);
	for(register int i=1;i<=n;i++){
		while(true){
			memset(visx,false,sizeof visx);
			memset(visy,false,sizeof visy);
			delta=1e18;
			if(find(i)) break;
			for(register int j=1;j<=n;j++){
				if(visx[j]) lx[j]-=delta;
				if(visy[j]) ly[j]+=delta;
			}
		}
	}
	double ans=0;
	for(register int i=1;i<=n;i++)
		ans+=edge[matched[i]][i];
	return ans;
}
int main(){
	n=read();
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=n;j++){
			a[i][j]=(double)read();
		}
	}
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=n;j++){
			b[i][j]=(double)read();
		}
	}
	while(l+eps<r){
		double mid=(l+r)/2;
		remake_gragh(mid);
		if(KM()>=0) l=mid;
		else r=mid;
	}
	printf("%.6lf",l);
	return 0;
}
```

---

## 作者：撤云 (赞：1)

### $Describe$
> 有一场舞会,n个男生,n个女生,要组成n对舞伴,男生i和女生j组队的适合度是$a_{ij}$,
不适合度是$b_{ij}$,
 让你求$max(\sum($适合度$)/\sum($不适合度$))$

### $Solution$
这道题是$01$分数规划的好题目。我们首先拆分这个式子:
令$A_i$为舞伴的适合度,$B_i$为不适合度

$$C=\sum_{i=1}^{i<=n}a_i/\sum_{i=1}^{i<=n}b_i$$  
$$\sum_{i=1}^{i<=n}a_i=\sum_{i=1}^{i<=n}b_i*C$$  
$$\sum_{i=1}^{i<=n}a_i-\sum_{i=1}^{i<=n}b_i*C=0$$  

则我们可以对C二分一个数$mid$,令：
$$ans=max(\sum_{i=1}^{i<=n}a_i-\sum_{i=1}^{i<=n}b_i*mid)$$

如果$ans>0$则$ans$比$C$要小,反之比$C$大

那么这个$max(ans)怎么求呢？$
这个随便用个费用流搞一搞就好了;
- 把每个人拆成$x$和$x'$
- 将$S$和$x$相连，流量为1，费用为0
- 将$x'$和$T$相连，流量为1，费用为0
- 对于两个人$x,y$我们将$x$和$y'$相连，流量为1，费用为$a[x][y]-mid*b[x][y]$(因为我的spfa是跑的最短路，所以我写的是-a[x][y]+mid*b[x][y],最后跑出来的答案的绝对值就是最大费用最大流);
- 跑一遍最大费用最大流

### $Code$
网络流代码过长，移步到博客效果更佳
[戳这](https://www.cnblogs.com/hbxblog/p/10266038.html)

---

## 作者：creation_hy (赞：0)

二分答案 + 网络流。

题意有点像费用流，但是直接跑是不行的。

因为直接建图的话你需要知道每个点精确的费用，而

$\sum\dfrac{a_i}{b_i}\ne\dfrac{\sum a_i}{\sum b_i}$

~~我居然还傻乎乎的试了一下，这是可以说的吗~~

考虑二分答案。

稍微变形一下式子：

$\sum a_i-C\sum b_i=0$

$\sum a_i-K\sum b_i\ge0(K\le C)$

然后 `check` 函数不就写出来了吗。

按照 $a_i-mid\sum b_i$ 建费用，如果最大费用最大流大于等于 $0$，那么答案可以大于等于这个数字，$l=mid$，否则 $r=mid$。

注意 `check` 的时候清空变量。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 205;
const int M = 3e4 + 5;
const ll inf = 1e18;
const double eps = 1e-8;
int n, s, t, tot, head[N], to[M], nxt[M];
int a[105][105], b[105][105];
ll val[M], flw;
double c[M], d[N], cst;
bool vis[N];
inline void link(int u, int v, ll w, double cost)
{
    to[tot] = v;
    nxt[tot] = head[u];
    val[tot] = w;
    c[tot] = cost;
    head[u] = tot++;
}
inline void add(int u, int v, ll w, double cost)
{
    link(u, v, w, cost);
    link(v, u, 0, -cost);
}
queue<int> q;
inline bool spfa()
{
    for (int i = s; i <= t; i++)
        d[i] = 1e18;
    q.emplace(s);
    d[s] = 0;
    vis[s] = true;
    while (!q.empty())
    {
        int tmp = q.front();
        q.pop();
        vis[tmp] = false;
        for (int i = head[tmp]; ~i; i = nxt[i])
            if (val[i] && d[to[i]] > d[tmp] + c[i])
            {
                d[to[i]] = d[tmp] + c[i];
                if (!vis[to[i]])
                {
                    vis[to[i]] = true;
                    q.emplace(to[i]);
                }
            }
    }
    return d[t] != inf;
}
inline ll dfs(int x, ll flow)
{
    if (x == t)
        return flow;
    vis[x] = true;
    ll rest = flow;
    for (int i = head[x]; ~i && rest; i = nxt[i])
        if (!vis[to[i]] && val[i] && d[to[i]] == d[x] + c[i])
        {
            ll rs = dfs(to[i], min(rest, val[i]));
            if (!rs)
                d[to[i]] = inf;
            else
            {
                rest -= rs;
                val[i] -= rs;
                val[i ^ 1] += rs;
                cst += rs * c[i];
            }
        }
    vis[x] = false;
    return flow - rest;
}
inline double mcmf()
{
    while (spfa())
        flw += dfs(s, inf);
    return cst;
}
inline bool check(double x)
{
    memset(head, -1, sizeof(head));
    tot = flw = cst = 0;
    for (int i = 1; i <= n; i++)
        add(s, i, 1, 0), add(i + n, t, 1, 0);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            add(i, j + n, 1, -(a[i][j] - x * b[i][j]));
    return mcmf() < 0;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    double l = 0, r = 0;
    s = 0, t = n << 1 | 1;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            cin >> a[i][j], r += a[i][j];
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            cin >> b[i][j];
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid))
            l = mid;
        else
            r = mid;
    }
    cout << fixed << showpoint << setprecision(6) << l;
    return 0;
}
```

---

## 作者：541forever (赞：0)

首先肯定躲不掉一个二分一个
$C$，那么我们要考虑的便是如何判断答案是否合法。

考虑 $C$ 已知后，合法的充要条件为

$$
\begin{aligned}
&C \ge \frac{a_1' + a_2' + a_3' \ldots + a_n'}{b_1' + b_2' + b_3'+ \cdots + b_n'}\\
\Leftrightarrow &C \sum_{i = 1}^n b_i \geqslant \sum_{i = 1}^n a_i\\
\Leftrightarrow &\sum_{i = 1}^n {Cb}_i - a_i \geqslant 0
\end{aligned}
$$

因此我们只需将每个男生向女生连一条边权为 ${Cb}_i - a_i$ 的边，再求二分图最大权匹配判断二分的 $C$ 是否合法即可。跑最大费用最大流的点数为 $ O(n)$ 级别，边数为 $O(n^{2})$ 级别，最大流量为 $n$，因此总时间复杂度为 $O (n^3 \log\sum_{i=1}^n\sum_{j=1}^na_{i,j})$，足以通过本题。


---

## 作者：Violet___Evergarden (赞：0)

**分数规划套一个 KM 算法。**

将舞会的匹配看作一个二分图匹配。

我们要最大化 $ \frac{\sum_{i=1}^{n}{a_i^{'}}}{\sum_{i=1}^n{b_i^{'}}}$。

可以首先二分出一个答案 $mid$，将每两个人之间的权设为 $a_{i,j}-mid\times b_{i,j} $，套一个 KM 算法求此时二分图最大权完美匹配。

若这个值大于 $0$，那么答案还可以更大；若等于 $0$ 那么答案就是此时；若小于 $0$ 那么答案会更小。

```cpp
#include <iostream>
#include <cstring>
#include <queue>
#include <iomanip>
#define double long double
#define int long long
using namespace std;
const int kMaxN=201;
const double eps=1e-8;
int n,a[kMaxN][kMaxN],b[kMaxN][kMaxN];
double l,r=1e5,mid,ans;
double hopel[kMaxN],hoper[kMaxN],w[kMaxN][kMaxN],d[kMaxN];
int matchx[kMaxN],matchy[kMaxN],pre[kMaxN];
bool visl[kMaxN],visr[kMaxN];
void Match(int x)
{
  int lose;
  while(x)
  {
    lose=matchx[pre[x]];
    matchx[pre[x]]=x;
    matchy[x]=pre[x];
    x=lose;
  }
}
void Bfs(int x)
{
  memset(visl,0,sizeof(visl));
  memset(visr,0,sizeof(visr));
  memset(pre,0,sizeof(pre));
  for(int i=1;i<=n;i++)d[i]=1e15;
  queue<int>q;
  q.push(x);
  while(1)
  {
    while(!q.empty())
    {
      int now=q.front();
      q.pop();
      visl[now]=true;
      for(int i=1;i<=n;i++)
      {
        if(visr[i])continue;
        if(d[i]>hopel[now]+hoper[i]-w[now][i])
        {
          d[i]=hopel[now]+hoper[i]-w[now][i];
          pre[i]=now;
          if(!d[i])
          {
            visr[i]=true;
            if(!matchy[i])
            {
              Match(i);
              return;
            }
            else
            {
              q.push(matchy[i]);
            }
          }
        }
      }
    }
    double mind=1e15;
    for(int i=1;i<=n;i++)
    {
      if(!visr[i])mind=min(mind,d[i]);
    }
    for(int i=1;i<=n;i++)
    {
      if(visl[i])hopel[i]-=mind;
      if(visr[i])hoper[i]+=mind;
      else d[i]-=mind;
    }
    for(int i=1;i<=n;i++)
    {
      if(visr[i])continue;
      if(!d[i])
      {
        visr[i]=true;
        if(!matchy[i])
        {
          Match(i);
          return;
        }
        else
        {
          q.push(matchy[i]);
        }
      }
    }
  }
}
bool Check(double x)
{
  for(int i=1;i<=n;i++)
  {
    for(int j=1;j<=n;j++)
    {
      w[i][j]=a[i][j]-x*b[i][j];
    }
  }
  double sum=0;
  memset(matchx,0,sizeof(matchx));
  memset(matchy,0,sizeof(matchy));
  memset(pre,0,sizeof(pre));
  for(int i=1;i<=n;i++)
  {
    hopel[i]=-1e15;
    hoper[i]=0;
    for(int j=1;j<=n;j++)
    {
      hopel[i]=max(hopel[i],w[i][j]);
    }
  }
  for(int i=1;i<=n;i++)
  {
    Bfs(i);
  }
  for(int i=1;i<=n;i++)
  {
    sum+=w[matchy[i]][i];
  }
  return sum>=0;
}
signed main()
{
cin>>n;
for(int i=1;i<=n;i++)
{
  for(int j=1;j<=n;j++)cin>>a[i][j];
}
for(int i=1;i<=n;i++)
{
  for(int j=1;j<=n;j++)cin>>b[i][j];
}
while(r-l>eps)
{
  mid=(l+r)/2.0;
  //cout<<l<<" "<<r<<" "<<mid<<"\n";
  if(Check(mid))
  {
    ans=mid,l=mid;
  }
  else r=mid;
}
cout<<fixed<<setprecision(6)<<ans;
return 0;
}
```

---

## 作者：RemiliaScar1et (赞：0)

## P3705 [SDOI2017]新生舞会

读题，总结题意：

有两个点集合，不同点集之间的点可以两两互相配对，每一对配对 $(i,j)$ 会产生有两个权值 $a_{i,j},b_{i,j}$，求配对方案 $S$ 使得 $C=\frac{\sum_{(i,j)\in S} a_{i,j}}{\sum_{(i,j)\in S} b_{i,j}}$ 最大，且所有点都被配对。只需给出 $C$ 的最大值。

---

根据做题经验，这是一个分数规划问题，我们可以考虑 **二分一个值 $mid$ 使得 $C\ge mid$**。

然后套路地化一下式子：

$$\sum_{(i,j)\in S} a_{i,j}\ge mid \sum_{(i,j)\in S} b_{i,j}\\
\sum_{(i,j)\in S}(a_{i,j}-mid\cdot b_{i,j})\ge 0
$$

对于每一个 $mid$，我们需要验证存在一种情况上面的式子能够成立。问题集中于如何解决这个配对问题。

对于这类配对问题我们很容易想到网络流。

设题中的男生为左部点，女生为右部点，由于对于每一个左部点，都向所有的右部点连了边，且左右两部点的个数相同，所以一定存在一个完美匹配。

我们 **建立超级源汇点，超级源点向所有左部点连边，左部点向右部点连边，右部点向超级汇点连边，容量均为 $1$**。容易证图中任意一个最大流与一个合法方案一一对应。

然后我们要考虑如何体现权值的影响。

由于最大流已经被用来保证了合法方案，我们可以从费用下手。从上面的不等式可以看出，我们只需要验证不等式右边的最大值大于 $0$ 即可，发现求和的每一项都只与一对配对本身有关，而配对在上面的建图中被抽象成了边，**所以我们将边 $(i,j)$ 的费用设成 $a_{i,j}-mid\cdot b_{i,j}$，然后跑最大费用最大流，判定费用是否大于 $0$** 即可

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef double dd;

const int N=1010,M=1e5+10,INF=1e8;

int head[N],ver[M<<1],nxt[M<<1],cc[M<<1],tot=0;
dd ww[M<<1];
void add(int x,int y,int c,dd d)
{
	ver[tot]=y; cc[tot]=c; ww[tot]=d; nxt[tot]=head[x]; head[x]=tot++;
	ver[tot]=x; cc[tot]=0; ww[tot]=-d; nxt[tot]=head[y]; head[y]=tot++;
}
int n,S,T;
int a[N][N],b[N][N];

int q[M],incf[M],pre[M];
dd d[M];
bool vis[M];

bool spfa()
{
	int hh=0,tt=1;
	memset(d,0x42,sizeof d);
	memset(incf,0,sizeof incf);
	q[0]=S; d[S]=0.0; incf[S]=INF;
	while(hh!=tt)
	{
		int x=q[hh++];
		if(hh==M) hh=0;
		vis[x]=0;
		for(int i=head[x];~i;i=nxt[i])
		{
			int y=ver[i];
			if(cc[i] && d[y]>d[x]+ww[i])
			{
				d[y]=d[x]+ww[i];
				pre[y]=i;
				incf[y]=min(cc[i],incf[x]);
				if(!vis[y])
				{
					q[tt++]=y;
					if(tt==M) tt=0;
					vis[y]=1;
				}
			}
		}
	}
	return incf[T]>0;
}

dd EK()
{
	int flow=0;
	dd cost=0;
	while(spfa())
	{
		int tmp=incf[T];
		flow+=tmp; cost+=(dd)tmp*d[T];
		for(int i=T;i!=S;i=ver[pre[i]^1])
		{
			cc[pre[i]]-=tmp;
			cc[pre[i]^1]+=tmp;
		}
	}
	return cost;
}


bool check(dd mid)
{
	memset(head,-1,sizeof head);
	tot=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
			add(i,n+j,1,-((dd)a[i][j]-mid*(dd)b[i][j]));
	}
	for(int i=1;i<=n;i++)
		add(S,i,1,0),add(n+i,T,1,0);
	return -EK()>=0;
}

int read()
{
	int x=0;
	int w=1;
	char ch=getchar();
	while(ch>'9'||ch<'0') w*=(ch=='-'?-1:1),ch=getchar();
	while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return x*w;
}

int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) a[i][j]=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) b[i][j]=read();
	dd l=-1e5-10,r=1e5+10,mid;
	S=0,T=2*n+1;
	while(r-l>1e-7)
	{
		mid=(l+r)/2.0;
		if(check(mid)) l=mid;
		else r=mid;
	}
	printf("%.6lf",l);
	return 0;
}

```

---

## 作者：VenusM1nT (赞：0)

二分图最佳匹配 + 分数规划。读题，发现要求最优配对，很显然，这个图是一张二分图，那么最佳匹配我们可以用 $\text{KM}$ 或者 费用流 来求出，这里不赘述如何求出最佳匹配。我们来考虑怎么计算这个 $C=\frac{\sum_{i=1}^{k}a'[i]}{\sum_{i=1}^{k}b'[i]}$。显然，这里的 $\sum_{i=1}^{k}b'[i]$ 是非常不好处理的，所以我们要引入**分数规划**的思想，将这个式子转化成 $\sum_{}^{}a'-C\sum_{}^{}b'=0$，然后二分答案 $C$，每次 $\text{Check}$ 都跑一遍最佳匹配，边权就设成 $a[i][j]-mid\times b[i][j]$，然后跑最大权最佳匹配（也就是最大费用最大流），判断最后得到的权和是否为 $0$ 即可。

同步发表于笔者的博客：[题解 P3705 [SDOI2017]新生舞会](https://venusnero.github.io/2019/01/25/solution_p3705/)

代码选用 $\text{zkw}$ 费用流。

```cpp
#include<bits/stdc++.h>
#define MAXN 1005
#define inf 1010580540
#define eps 1e-8
using namespace std;
deque <int> q;
int cnt,fst[MAXN],nxt[MAXN<<5],to[MAXN<<5],w[MAXN<<5],cur[MAXN];
int n,m,S,T,maxflow;
double dis[MAXN],a[MAXN][MAXN],b[MAXN][MAXN],cot[MAXN<<5],mincost;
bool inq[MAXN],vis[MAXN];
void AddEdge(int u,int v,int c,double fl)
{
	to[++cnt]=v;
	nxt[cnt]=fst[u];
	fst[u]=cnt;
	w[cnt]=c;
	cot[cnt]=fl;
}
bool Spfa()
{
	for(int i=S;i<=T;i++) dis[i]=inf;
	memset(inq,0,sizeof(inq));
	q.push_front(T);
	dis[T]=0;
	inq[T]=1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop_front();
		inq[u]=0;
		for(int i=fst[u];i;i=nxt[i])
		{
			int v=to[i];
			if(dis[v]>dis[u]-cot[i] && w[i^1])
			{
				dis[v]=dis[u]-cot[i];
				if(!inq[v])
				{
					if(!q.empty() && dis[v]<dis[q.front()]) q.push_front(v);
					else q.push_back(v);
					inq[v]=1;
				}
			}
		}
	}
	return dis[S]!=inf;
}
int Dfs(int u,int flow)
{
	vis[u]=1;
	if(u==T || !flow) return flow;
	int used=0;
	for(int &i=cur[u];i;i=nxt[i])
	{
		int v=to[i];
		if(dis[v]==dis[u]-cot[i] && w[i] && !vis[v])
		{
			int fl=Dfs(v,min(flow,w[i]));
			if(fl)
			{
				used+=fl;
				flow-=fl;
				w[i]-=fl;
				w[i^1]+=fl;
				if(!flow) break;
			}
		}
	}
	return used;
}
void zkwMCMF()
{
	while(Spfa())
	{
		vis[T]=1;
		while(vis[T])
		{
			memset(vis,0,sizeof(vis));
			memcpy(cur,fst,sizeof(fst));
			int fl=Dfs(S,inf);
			maxflow+=fl;
			mincost+=dis[S]*fl;
		}
	}
	mincost=-mincost;
}
bool Check(double mid)
{
	maxflow=mincost=0;
	cnt=1;
	memset(fst,0,sizeof(fst));
	for(int i=1;i<=n;i++)
	{
		AddEdge(S,i,1,0);
		AddEdge(i,S,0,0);
	}
	for(int i=n+1;i<=n*2;i++)
	{
		AddEdge(i,T,1,0);
		AddEdge(T,i,0,0);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			AddEdge(i,j+n,1,-a[i][j]+b[i][j]*mid);
			AddEdge(j+n,i,0,a[i][j]-b[i][j]*mid);
		}
	}
	zkwMCMF();
	return fabs(mincost)<=eps || mincost>eps;
}
int main()
{
	scanf("%d",&n);
	S=0;
	T=n*2+1;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++) scanf("%lf",&a[i][j]);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++) scanf("%lf",&b[i][j]);
	}
	double l=0,r=1e4;
	while(r-l>eps)
	{
		double mid=(l+r)/2.0;
		if(Check(mid)) l=mid;
		else r=mid;
	}
	printf("%.6lf\n",r);
	return 0;
}
```

---

## 作者：Isonan (赞：0)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P3705)

我的01分数规划学习笔记[>Here<](https://www.luogu.org/blog/PopulusEuphratica/post-xue-xi-bi-ji-01-fen-shuo-gui-hua)

这道题是道比较有趣的01分数规划题，不仅需要01分数规划的思想，还要应用网络流求解，有一些复杂。

考虑对于二分出的每一个值，我们都可以网络流建图:

从源点向所有男生建边，流为1，费用为0；

从男生向女生建边，流为1，费用为$mid*b_{ij}-a_{ij}$;

从女生向汇点建边，流为1，费用为0。

接下来跑一遍最小费用最大流求出匹配的最小费用，判断是否是负数就可以了。

这题还需要卡一点常，也算是考验下应试技巧。

代码：

```cpp
#include <cstdio>
#include <cstring>
#define min(X,Y) ((X)<(Y)?(X):(Y))

int n,head[301],nxt[180001],b[180001],v[180001],k=1;
int vt[180001],flow[301],q[100001],h,t,S,T,pre[301];
double dis[301],ct[180001],bene[180001],cost[180001],a[101][101],bad[101][101],tem,l=0.0,r=100000000.0,mid;
bool inq[301];
void push(int s,int t,int val,double c){
	nxt[++k]=head[s];
	head[s]=k;
	b[k]=t;
	v[k]=val;
	cost[k]=c;
}
void link(int s,int t,int val,double c){
	push(s,t,val,c);
	push(t,s,0,-c);
}
bool spfa(){
	for(int i=S;i<=T;i++)dis[i]=1000000000.0;
	h=t=0;
	q[++t]=S;
	inq[S]=1;
	dis[S]=0.0;
	flow[S]=0x7f7f7f7f;
	while(h<t){
		++h;inq[q[h]]=0;
		for(register int i=head[q[h]];i;i=nxt[i])
			if(dis[b[i]]>dis[q[h]]+cost[i]&&v[i]){
				dis[b[i]]=dis[q[h]]+cost[i];
				flow[b[i]]=min(flow[q[h]],v[i]);
				pre[b[i]]=i;
				if(!inq[b[i]])inq[b[i]]=1,q[++t]=b[i];
			}
	}
	return dis[T]!=1000000000.0;
}
bool judge(double u){
	double ans=0.0;
	memset(head,0,sizeof head);
	k=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)
			link(i,j+n,1,u*bad[i][j]-a[i][j]);
		link(S,i,1,0.0);
		link(i+n,T,1,0.0);
	}
	while(spfa()){
		int tem=T;
		while(tem!=S){
			v[pre[tem]]-=flow[T];
			v[pre[tem]^1]+=flow[T];
			tem=b[pre[tem]^1];
		}
		ans+=(double)flow[T]*dis[T];
	}
	return ans<0.0;
}
int read(){
	int x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
	return x;
}
int main(){
	n=read();
	T=n+n+1; 
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=n;j++)
			a[i][j]=(double)read();
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=n;j++)
			bad[i][j]=(double)read();
	while(r-l>=0.000000001){
		mid=(l+r)/2;
		if(judge(mid))l=mid;
		else r=mid;
	}
	printf("%.6lf",l);
}
```

---


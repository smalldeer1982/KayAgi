# [SDOI2017] 相关分析

## 题目描述

Frank 对天文学非常感兴趣，他经常用望远镜看星星，同时记录下它们的信息，比如亮度、颜色等等，进而估算出星星的距离，半径等等。

Frank 不仅喜欢观测，还喜欢分析观测到的数据。他经常分析两个参数之间（比如亮度和半径）是否存在某种关系。

现在 Frank 要分析参数 $X$ 与 $Y$ 之间的关系。他有 $n$ 组观测数据，第 $i$ 组观测数据记录了 $x_i$ 和 $y_i$。他需要一下几种操作。

###  $\verb!1 L R!$

用直线拟合第 $L$ 组到第 $R$ 组观测数据。用 $\overline{x}$ 表示这些观测数据中 $x$ 的平均数，用 $\overline{y}$ 表示这些观测数据中 $y$ 的平均数，即
 
$$\begin{aligned}\overline{x}&={1 \over R-L+1} \sum _{i=L} ^R x_i \\\overline{y}&={1 \over R-L+1} \sum _{i=L} ^R y_i\end{aligned}$$

如果直线方程是 $y=ax+b$，那么 $a$ 应当这样计算：

$$a={\displaystyle\sum_{i=L} ^R (x_i-\overline{x})(y_i-\overline{y}) \over \displaystyle\sum _{i=L} ^R (x_i -\overline{x})^2}$$

 
你需要帮助 Frank 计算 $a$。

 
###  $\verb!2 L R S T!$

Frank 发现测量数据第 $L$ 组到第 $R$ 组数据有误差，对每个 $i$ 满足 $L \leq i \leq R$，$x_i$ 需要加上 $S$，$y_i$ 需要加上 $T$。
 
###  $\verb!3 L R S T!$

Frank 发现第 $L$ 组到第 $R$ 组数据需要修改，对于每个 $i$ 满足 $L \leq i \leq R$，$x_i$ 需要修改为 $(S+i)$，$y_i$ 需要修改为 $(T+i)$。


## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据 $1 \leq n,m \leq 1000$；
- 另有 $20\%$ 的数据，没有 $3$ 操作，且 $2$ 操作中 $S=0$；
- 另有 $30\%$ 的数据，没有 $3$ 操作。

对于 $100\%$ 的数据，$1 \leq n,m \leq 10^5$，$0 \leq |S|,|T| \leq 10^5$，$0 \leq |x_i|,|y_i| \leq 10^5$。

保证 $1$ 操作不会出现分母为 $0$ 的情况。


## 样例 #1

### 输入

```
3 5
1 2 3
1 2 3
1 1 3
2 2 3 -3 2
1 1 2
3 1 2 2 1
1 1 3
```

### 输出

```
1.0000000000
-1.5000000000
-0.6153846154
```

# 题解

## 作者：liangbowen (赞：26)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P3707)

[更好的阅读体验？](https://www.cnblogs.com/liangbowen/p/16773674.html)

思路和码量都有难度，思路难点是推式子，代码难度是线段树操作很奇怪，导致很难打。

## 思路

### 转化式子

首先将 $a$ 爆拆，目标就是把平均值搞掉。（有点恐怖，建议仔细看；看不懂没关系，记住最后化简的式子就行）

$\begin{aligned} a  & = \dfrac{\sum_{i = L}^R (x_i - \overline{x})\cdot(y_i - \overline{y})}{\sum_{i = L}^R (x_i - \overline{x})^2} \\ & = \dfrac{\sum_{i = L}^R (x_i\cdot y_i - x_i\cdot \overline{y} - y_i\cdot \overline{x} + \overline{x} \cdot \overline{y})}{\sum_{i = L}^R x_i^2 - 2x_i\overline{x} + \overline{x} ^ 2}\\ & = \dfrac{(\sum x_iy_i) - (\overline{y} \cdot \sum x_i) - (\overline{x} \cdot \sum y_i) + \Big((R - L + 1) \cdot \overline{x} \cdot \overline{y}\Big)}{(\sum x_i^2) - (2\overline{x}\sum x_i) + \Big((R - L + 1)\overline{x}^2\Big)} \\ & = \dfrac{\sum x_iy_i - \frac{\sum x_i \sum y_i}{R - L + 1} - \frac{\sum x_i \sum y_i}{R - L + 1} + \frac{\sum x_i \sum y_i}{R - L + 1}}{\sum x_i^2 - 2 \cdot \frac{(\sum x_i) ^ 2}{R - L + 1} + \frac{(\sum x_i) ^ 2}{R - L + 1}} \\ & = \dfrac{\sum x_iy_i - \frac{\sum x_i \sum y_i}{R - L + 1}}{\sum x_i^2 - \frac{(\sum x_i) ^ 2}{R - L + 1}}\end{aligned}$

至此，我们搞掉了平均数。观察最终式子，只需维护 $\sum x_i$、$\sum y_i$、$\sum x_iy_i$、$\sum x_i^2$ 的值。

容易发现题目是区间求、区间改。所以我们用线段树处理。

利用线段树知道这四个值后，直接代入式子，就能计算出答案了。

### 线段树实现

梳理一下更新操作：

1. 区间 $x_i$ 与 $y_i$ 加上一个数。
2. 区间修改 $x_i = y_i = i$，然后再来一次操作一。

为了方便，我们可以用一个结构体封装线段树的存储。

对于两个点合并，发现可以直接加起来。~~为了看起来更酷~~，我重载了一下加号。

```cpp
//db 是 double 的意思，为什么用 double 后面会解释
struct Node
{
	db x, y, xx, xy, s, t;
	bool cov;
    Node() {x = y = xx = xy = s = t = cov = 0;} //初始化很重要
} tr[N << 2];
Node operator +(Node a, Node b)
{
	Node ans;
	ans.x = a.x + b.x;
	ans.y = a.y + b.y;
	ans.xx = a.xx + b.xx;
	ans.xy = a.xy + b.xy;
	return ans;
}
```

那么 `pushup` 就很简单了。

```cpp
void pushup(int pos) {tr[pos] = tr[ls(pos)] + tr[rs(pos)];}
```

考虑线段树重要操作 `pushdown`：貌似难很多。推一推式子。

1. $\sum (x_i + s) = \sum x_i + s \cdot (R - L + 1)$

2. $\sum (y_i + t) = \sum y_i + t \cdot (R - L + 1)$

3. $\sum (x_i + s)(y_i + t) = \sum x_iy_i + s \sum y_i + t \sum x_i + s \cdot t \cdot (R - L + 1)$

4. $\sum (x_i + s)^2 = \sum (x_i^2 + 2 \cdot s \cdot x_i + s^2) = \sum x_i^2 + 2 \cdot s \cdot \sum x_i + s^2 \cdot (R - L + 1)$

综上，我们可以写出 `lazy` 函数。

```cpp
void lazy(int l, int r, int pos, db S, db T)
{
    tr[pos].s += S, tr[pos].t += T;
    tr[pos].xy += T * tr[pos].x + S * tr[pos].y + S * T * (r - l + 1); //对比原xy暴力展开即可 
    tr[pos].xx += 2 * S * tr[pos].x + S * S * (r - l + 1); //对比原xx暴力展开即可 
    tr[pos].x += S * (r - l + 1), tr[pos].y += T * (r - l + 1); 
}
```

不幸的是，我们还要再处理一个东西：区间覆盖 $x_i = y_i = i$。

也就是说，我们还需要一个操作：区间重建 $x_i = y_i = i$。

前置知识：$1^2 + 2^2 + 3^2 + \cdots + n^2 = \dfrac{n \cdot (n + 1) \cdot (2n + 1)}{6}$。不会可以去百度查。

```cpp
db sqsum(db x) {return x * (x + 1) * (2 * x + 1) / 6;} //1*1 + 2*2 + ... + x*x
db sqsum(int l, int r) {return sqsum(r) - sqsum(l - 1);} //l*l + ... + r*r
void rebuild(db l, db r, int pos) //重建 xi = yi = i
{
    tr[pos].s = tr[pos].t = 0, tr[pos].cov = true;
    tr[pos].x = tr[pos].y = (l + r) * (r - l + 1) / 2; //等差数列求和
    tr[pos].xx = tr[pos].xy = sqsum(l, r);
}
```

那么，我们终于可以写 `pushdown` 了。

```cpp
void pushdown(int l, int r, int pos)
{
    int mid = (l + r) >> 1;
    if (tr[pos].cov) //如果需要覆盖，那就下传覆盖
    {
        rebuild(l, mid, ls(pos));
        rebuild(mid + 1, r, rs(pos));
        tr[pos].cov = false;
    }
    lazy(l, mid, ls(pos), tr[pos].s, tr[pos].t);
    lazy(mid + 1, r, rs(pos), tr[pos].s, tr[pos].t);
    tr[pos].s = tr[pos].t = 0;
}
```

其实到这里就马上搞定了，把其他几个基本操作码掉就完事了。

## 完整代码

不幸的是，你会发现数据较大，`long long` 都有机会炸。

你可以直接使用 `double`。

代码个人认为挺好看的。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define space putchar(' ')
#define endl putchar('\n')
using namespace std;
typedef long long LL;
typedef unsigned long long ull;
typedef double db;
typedef long double LD;
namespace io { //fast read && write 可以直接不管
    bool FREAD = false; //do you need to use fread?
    void fastio()
    {
        ios::sync_with_stdio(false);
        cin.tie(0), cout.tie(0);
    }
    char buf[1 << 21], *p1 = buf, *p2 = buf;
    inline char getc()
    {
        if (!FREAD) return getchar();
        if (p1 == p2) p2 = buf + fread(buf, 1, 1 << 21, stdin), p1 = buf;
        return *(p1++);
    }
    inline int read()
    {
        char op = getc(); int x = 0, f = 1;
        while (op < 48 || op > 57) {if (op == '-') f = -1; op = getc();}
        while (48 <= op && op <= 57) x = (x << 1) + (x << 3) + (op ^ 0x30), op = getc();
        return x * f;
    }
    inline void write(int x)
    {
        if (x < 0) putchar('-'), x = -x;
        if (x > 9) write(x / 10);
        putchar(x % 10 + 0x30);
    }
} using namespace io;
const int N = 1e5 + 5;
db kx[N], ky[N];
struct Node
{
	db x, y, xx, xy, s, t;
	bool cov;
    Node() {x = y = xx = xy = s = t = cov = 0;}
} tr[N << 2];
Node operator +(Node a, Node b)
{
	Node ans;
	ans.x = a.x + b.x;
	ans.y = a.y + b.y;
	ans.xx = a.xx + b.xx;
	ans.xy = a.xy + b.xy;
	return ans;
}
struct SegmentTree
{
    int ls(int x) {return x << 1;}
    int rs(int x) {return x << 1 | 1;}
    void pushup(int pos) {tr[pos] = tr[ls(pos)] + tr[rs(pos)];}
    void build(int l, int r, int pos)
    {
        if (l == r)
        {
            tr[pos].x = kx[l], tr[pos].y = ky[l];
            tr[pos].xx = kx[l] * kx[l];
            tr[pos].xy = kx[l] * ky[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(l, mid, ls(pos));
        build(mid + 1, r, rs(pos));
        pushup(pos);
    }
    db sqsum(db x) {return x * (x + 1) * (2 * x + 1) / 6;} //1*1 + 2*2 + ... + x*x
    db sqsum(int l, int r) {return sqsum(r) - sqsum(l - 1);} //l*l + ... + r*r
    void rebuild(db l, db r, int pos) //重建 xi = yi = i
    {
        tr[pos].s = tr[pos].t = 0, tr[pos].cov = true;
        tr[pos].x = tr[pos].y = (l + r) * (r - l + 1) / 2; //等差数列求和
        tr[pos].xx = tr[pos].xy = sqsum(l, r);
    }
    void lazy(int l, int r, int pos, db S, db T)
    {
        tr[pos].s += S, tr[pos].t += T;
        tr[pos].xy += T * tr[pos].x + S * tr[pos].y + S * T * (r - l + 1); //对比原xy暴力展开即可 
        tr[pos].xx += 2 * S * tr[pos].x + S * S * (r - l + 1); //对比原xx暴力展开即可 
        tr[pos].x += S * (r - l + 1), tr[pos].y += T * (r - l + 1); 
    }
    void pushdown(int l, int r, int pos)
    {
        int mid = (l + r) >> 1;
        if (tr[pos].cov)
        {
            rebuild(l, mid, ls(pos));
            rebuild(mid + 1, r, rs(pos));
            tr[pos].cov = false;
        }
        lazy(l, mid, ls(pos), tr[pos].s, tr[pos].t);
        lazy(mid + 1, r, rs(pos), tr[pos].s, tr[pos].t);
        tr[pos].s = tr[pos].t = 0;
    }
    void update(int L, int R, int l, int r, int pos, db S, db T)
    {
        if (L <= l && r <= R) return lazy(l, r, pos, S, T);
        pushdown(l, r, pos);
        int mid = (l + r) >> 1;
        if (L <= mid) update(L, R, l, mid, ls(pos), S, T);
        if (mid < R) update(L, R, mid + 1, r, rs(pos), S, T);
        pushup(pos);
    }
    void modify(int L, int R, int l, int r, int pos, db S, db T)
    {
        if (L <= l && r <= R)
        {
            rebuild(l, r, pos), lazy(l, r, pos, S, T);
            return;
        }
        pushdown(l, r, pos);
        int mid = (l + r) >> 1;
        if (L <= mid) modify(L, R, l, mid, ls(pos), S, T);
        if (mid < R) modify(L, R, mid + 1, r, rs(pos), S, T);
        pushup(pos);
    }
    Node query(int L, int R, int l, int r, int pos)
    {
        if (L <= l && r <= R) return tr[pos];
        pushdown(l, r, pos);
        int mid = (l + r) >> 1;
		Node ans;
		if (L <= mid) ans = ans + query(L, R, l, mid, ls(pos));
        if (mid < R) ans = ans + query(L, R, mid + 1, r, rs(pos));
        return ans;
    }
} seg;
int main()
{
    //freopen("C:\\Users\\User\\Desktop\\对拍\\data.txt", "r", stdin);
    //freopen("C:\\Users\\User\\Desktop\\cuojie.txt", "w", stdout);
    int n = read(), T = read();
    for (int i = 1; i <= n; i++) kx[i] = read();
    for (int i = 1; i <= n; i++) ky[i] = read();
    seg.build(1, n, 1);
    while (T--)
    {
        int op = read(), l = read(), r = read(), s = (op == 1 ? -1 : read()), t = (op == 1 ? -1 : read()); //压行 
        if (op == 1)
        {
            Node ans = seg.query(l, r, 1, n, 1); //抄公式
            db x = ans.x, y = ans.y, xx = ans.xx, xy = ans.xy;
            db fenzi = xy - x * y / (r - l + 1), fenmu = xx - x * x / (r - l + 1);
            printf("%.10lf\n", fenzi / fenmu);
        }
        else if (op == 2) seg.update(l, r, 1, n, 1, s, t);
        else if (op == 3) seg.modify(l, r, 1, n, 1, s, t);
    }
    return 0;
}
```

码字不易（特别是开头的一长串 $\LaTeX$），希望能帮助到大家！

---

## 作者：Capella (赞：14)

[<悄悄为自己打一波广告qwq - 原文点这儿！>](http://www.cnblogs.com/Capella/p/8481720.html)

## 概述

这是一道区间操作的题目，解法有线段树与分块等。

Capella 选择线段树进行讲解qwq（因为没用分块写这题）。

## 准备与计算答案

首先要知道，线段树需要维护的数值有哪些。

先来看题目中所给的公式。

$\bar x = \frac 1 {r-l+1} \sum_{i=l}^r x_i$

$\bar y = \frac 1 {r-l+1} \sum_{i=l}^r y_i$

$\hat a = \frac{\sum_{i=l}^r (x_i - \bar x)(y_i - \bar y)}{\sum_{i=l}^r (x_i - \bar x)^2}$

将线性回归方程的公式展开得（$\sum_{i=l}^r$ 省略为 $\sum$）：

$\hat a = \frac{\sum (x_i y_i - \bar x y_i - \bar y x_i + \bar x \bar y)}{\sum (x_i^2 - 2\bar x x_i + \bar x^2)}$

$= \frac{\sum x_i y_i - \bar x \sum y_i - \bar y \sum x_i + (r-l+1) \bar x \bar y}{\sum x_i^2 - 2\bar x \sum x_i + (r-l+1) \bar x^2}$

将 $\bar x$、$\bar y$ 代入上式得：

$\hat a = \frac{\sum x_i y_i - \frac{\sum x_i \sum y_i}{r-l+1} - \frac{\sum x_i \sum y_i}{r-l+1} + (r-l+1) \frac{\sum x_i}{r-l+1} \cdot \frac{\sum y_i}{r-l+1}}{\sum x_i^2 - \frac{2(\sum x_i)^2}{r-l+1} + (r-l+1) (\frac{\sum x_i}{r-l+1})^2}$

$= \frac{\sum x_i y_i - \frac{\sum x_i \sum y_i}{r-l+1}}{\sum x_i^2 - \frac{(\sum x_i)^2}{r-l+1}}$

由此可见，线段树需要维护的数值有 $\sum x_i^2$、$\sum x_i y_i$、$\sum x_i$ 以及 $\sum y_i$。

设 $v_0 = \sum x_i^2, v_1 = \sum x_i y_i, v_2 = \sum x_i, v_3 = \sum y_i$，

则最终计算出的 $\hat a = \frac{v_1 - \frac{v_2 v_3}{r-l+1}}{v_0 - \frac{v_2^2}{r-l+1}}$。

## 区间加操作

进行区间加操作时，设 $x$ 的变化量为 $S$，$y$ 的变化量为 $T$，则各个标记的下传过程如下：

$\sum (x_i + S)^2 = \sum (x_i^2 + 2Sx_i + S^2)$  
$= \sum x_i^2 + 2S \sum x_i + (r-l+1)S^2$

$\sum (x_i+S)(y_i+T) = \sum (x_i y_i + Sy_i+Tx_i+ST)$  
$=\sum x_i y_i + S \sum y_i + T \sum x_i + (r-l+1)ST$

$\sum (x_i+S) = \sum x_i + (r-l+1)S$

$\sum (y_i+T) = \sum y_i +(r-l+1)T$

特别注意：由于更新 $\sum x_i^2 $ 与 $\sum x_i y_i$ 时，需要用到更新前的 $\sum x_i$ 与 $\sum y_i$ 的值，所以应**注意顺序**。

## 区间修改操作

### 前置技能

$1^2 + 2^2 + \dots + n^2 = \frac {n(n+1)(2n+1)} 6$

### 转化

试图将区间修改操作转化为区间加操作。

对于 $i \in [l,r]$，$x_i$ 改为 $S+i$，$y_i$ 改为 $T+i$，

相当于将 $i \in [l,r]$ 的每个 $x_i$ 与 $y_i$ 都改为 $i$ ，

$\sum x_i^2 = \sum y_i^2 = \sum i^2 = \frac {r(r+1)(2r+1)} 6 - \frac {l(l-1)(2l-1)} 6$（即 $\sum_{i=1}^r i^2 -\sum_{i=1}^{l-1} i^2$）

$\sum x_i = \sum y_i = \sum i = \frac {(r-l+1)(l+r)} 2$（$r-l+1$ 为区间元素个数，$\frac {l+r} 2$ 为区间平均值）

然后**清空`Lazy Tag`**（无论区间曾经加了多少都没有用，将被统一修改）。

### 维护操作

清空`Lazy Tag`后，对区间 $[l,r]$ 进行区间加操作，即：每个 $x_i$ 加上 $S$，每个 $y_i$ 加上 $T$。

更新过程与区间加操作完全相同。

最后还要打上标记`c`，表示此区间的子区间需要区间修改操作。

## 注意事项

- 一定记得下传`Lazy Tag`与`c`标记，我就是因为没传才调了一上午+一下午+半个晚上的。

- 本题下传标记部分较为复杂，请一定**注意顺序**。

## 结束语

这道题有点像《HAOI2012 高速公路》啊。

线段树这种东西，多推一推也就熟悉啦。

加油，各位队友；加油，自己。

```cpp
#include <cstdio>
#include <cstring>
const int MAXN=100010;
double x[MAXN],y[MAXN];
int n,m;
class SegmentTree
{
    public:
        void Build(int i,int l,int r)
        {
            s[i]=node(l,r);
            if(l==r)
            {
                s[i].v[0]=x[l]*x[l],s[i].v[1]=x[l]*y[r],s[i].v[2]=x[l],s[i].v[3]=y[r];
                return;
            }
            int j=i<<1,mid=l+r>>1;
            Build(j,l,mid),Build(j|1,mid+1,r),PushUp(i);
        }
        void Add(int i,int l,int r,double S,double T)
        {
            if(l==s[i].l && r==s[i].r)
            {
                AddModify(i,S,T);
                return;
            }
            if(s[i].l^s[i].r)
                PushDown(i);
            int j=i<<1,mid=s[i].l+s[i].r>>1;
            if(r<=mid)
                Add(j,l,r,S,T);
            else if(l>mid)
                Add(j|1,l,r,S,T);
            else
                Add(j,l,mid,S,T),Add(j|1,mid+1,r,S,T);
            PushUp(i);
        }
        void Change(int i,int l,int r,double S,double T)
        {
            if(l==s[i].l && r==s[i].r)
            {
                ChangeModify(i),AddModify(i,S,T);
                return;
            }
            if(s[i].l^s[i].r)
                PushDown(i);
            int j=i<<1,mid=s[i].l+s[i].r>>1;
            if(r<=mid)
                Change(j,l,r,S,T);
            else if(l>mid)
                Change(j|1,l,r,S,T);
            else
                Change(j,l,mid,S,T),Change(j|1,mid+1,r,S,T);
            PushUp(i);
        }
        double Ans(double l,double r)
        {
            double size=r-l+1;
            memset(ans,0,sizeof ans);
            Sum(1,l,r);
            return (ans[1]-ans[2]*ans[3]/size)/(ans[0]-ans[2]*ans[2]/size);
        }
    private:
        double ans[4];
        struct node
        {
            bool c;
            double S,T,v[4];
            int l,r;
            node(int _l=0,int _r=0)
            {
                l=_l,r=_r,c=S=T=0;
            }
        }s[MAXN<<2];
        double Calc(double i)
        {
            return i*(i+1)*(2*i+1)/6;
        }
        void AddModify(int i,double S,double T)
        {
            double size=double(s[i].r-s[i].l+1);
            s[i].v[0]+=S*S*size+2*S*s[i].v[2];
            s[i].v[1]+=S*T*size+S*s[i].v[3]+T*s[i].v[2];
            s[i].v[2]+=S*size;
            s[i].v[3]+=T*size;
            s[i].S+=S,s[i].T+=T;
        }
        void ChangeModify(int i)
        {
            double l=double(s[i].l),r=double(s[i].r);
            s[i].v[0]=s[i].v[1]=Calc(r)-Calc(l-1),s[i].v[2]=s[i].v[3]=(r-l+1)*(l+r)/2,s[i].c=1,s[i].S=s[i].T=0;
        }
        void PushUp(int i)
        {
            int l=i<<1,r=l|1;
            for(int k=0;k<4;++k)
                s[i].v[k]=s[l].v[k]+s[r].v[k];
        }
        void PushDown(int i)
        {
            int l=i<<1,r=l|1;
            if(s[i].c)
                ChangeModify(l),ChangeModify(r);
            AddModify(l,s[i].S,s[i].T),AddModify(r,s[i].S,s[i].T);
            s[i].c=s[i].S=s[i].T=0;
        }
        void Sum(int i,int l,int r)
        {
            if(l==s[i].l && r==s[i].r)
            {
                for(int k=0;k<4;++k)
                    ans[k]+=s[i].v[k];
                return;
            }
            if(s[i].l^s[i].r)
                PushDown(i);
            int j=i<<1,mid=s[i].l+s[i].r>>1;
            if(r<=mid)
                Sum(j,l,r);
            else if(l>mid)
                Sum(j|1,l,r);
            else
                Sum(j,l,mid),Sum(j|1,mid+1,r);
        }
}SgT;
int main(int argc,char *argv[])
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;++i)
        scanf("%lf",&x[i]);
    for(int i=1;i<=n;++i)
        scanf("%lf",&y[i]);
    SgT.Build(1,1,n);
    for(int i=1,opt,l,r;i<=m;++i)
    {
        double S,T;
        scanf("%d %d %d",&opt,&l,&r);
        switch(opt)
        {
            case 1:
                printf("%.10lf\n",SgT.Ans(l,r));
                break;
            case 2:
                scanf("%lf %lf",&S,&T);
                SgT.Add(1,l,r,S,T);
                break;
            case 3:
                scanf("%lf %lf",&S,&T);
                SgT.Change(1,l,r,S,T);
                break;
        }
    }
    return 0;
}
```

谢谢阅读。

---

## 作者：Rainybunny (赞：8)

看各位dalao的题解原来我也是正解呀，~~超开心~~。 


------------
## 问题转化

拿到题目的第一反应一定是**线段树**，不过a那堆奇奇怪怪的式子看似很难维护，那么，我们把原式的分子分母分别展开：    

Denominator(分母)=$\sum_{i=l}^r{(x_i-\overline{x})^2}$=$\sum_{i=1}^r{(x_i^2-2x_i+\overline{x}^2)}$  
$x_i$, $\overline{x}$都可以通过$x_i$的区间和维护出来，即需维护:
$\sum_{i=l}^r{x_i}$，令为SecSumX；  
$x^2$也能直接维护，即需维护：
$\sum_{i=l}^r{x^2}$，令为Xpower；

Numerator(分子)=$\sum_{i=l}^r{(x_i-\overline{x})(y_i-\overline{y})}$=$\sum_{i=l}^r{(x_iy_i-\overline{x}y_i-\overline{y}x_i+\overline{x}\overline{y})}$  
首先，$\sum_{i=l}^ry_i$肯定是要维护的，令为SecSumY;
此时把求和展开，则有：  
Numerator=$\sum_{i=l}^rx_iy_i-\overline{x}\sum_{i=l}^ry_i-\overline{y}\sum_{i=l}^rx_i+\sum_{i=l}^r\overline{x}\overline{y}$  
把已维护的值代入，则：  
Numerator=$\sum_{i=l}^rx_iy_i-SecSumY\overline{x}-SecSumX\overline{y}+\sum_{i=l}^r\overline{x}\overline{y}$  
再维护$\sum_{i=l}^rx_iy_i$(令为XYprod)就大功告成啦！  

于是，我们勇敢~~扯淡~~地把a展开后，得到了这个式子：  
$a=\frac{XYprod-SecSumX\overline{y}-SecSumY\overline{x}+(r-l+1)\overline{x}\overline{y}}{Xpower-2SecSumX+\overline{x}^2}$   
SecSumX，SecSumY，Xpower，XYprod都满足**可加性**，可以动手维护啦。  

## 懒标记  
两种修改，一定对应两个懒标记，定义两个pair: Lazy1,Lazy2，分别对应操作二和操作三。那么问题来了，两个Lazy的下传会不会因先后顺序而发生混乱呢？  
答案是否定的~~不然我不会做~~，因为操作三是简单粗暴的覆盖，而操作二是累加，也就是说当Lazy2来临时，Lazy1已经无用了。那么在下传时**分类讨论**： 

1.Lazy1，Lazy2，均为空，直接退出；  
    
2.Lazy1非空，Lazy2为空，执行区间修改并下传；  

3.Lazy1为空，Lazy2非空，执行区间覆盖并下传；  

4.Lazy1，Lazy2均非空，先覆盖，再修改，并下传；  

明白了吗，当Lazy1和Lazy2同时存在时，一定是覆盖在前，Lazy1才有意义。  
接下来又是~~漫长的~~计算时间：  
### 修改操作 
$NewSecSumX=\sum_{i=l}^r{(x_i+S)}=SecSumX+(r-l+1)S$  

$NewSecSumY=\sum_{i=l}^r{(y_i+T)}=SecSumY+(r-l+1)T$  

$NewXpower=\sum_{i=l}^r{(x_i+S)^2}=\sum_{i=l}^r(x_i^2+2x_iS+S^2)$  
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$=Xpower+2SecSumXS+(r-l+1)S$  

$NewXYprod=\sum_{i=l}^r(x_i+S)(y_i+T)=\sum_{i=l}^r(x_iy_i+x_iT+y_iS+ST)$  
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$=XYprod+SecSumXT+SecSumYS+(r-l+1)ST$  
注意修改时仍需要原值，不要直接赋值。  
### 覆盖操作   
恭喜获得技能《前缀平方和》：$\sum_{i=1}^ni^2=\frac{n(n+1)(2n+1)}{6}$，以PowerSum(n)使用。  
恭喜获得技能《等差数列求和》：$l+(l+1)+...+r=\frac{(l+r)(r-l+1)}{2}$。
  
$NewSecSumX=\sum_{i=l}^r{S+i}=(r-l+1)S+\frac{(l+r)(r-l+1)}{2}$  

$NewSecSumY=\sum_{i=l}^r{T+i}=(r-l+1)S+\frac{(l+r)(r-l+1)}{2}$  

$NewXpower=\sum_{i=l}^r{(S+i)^2}=\sum_{i=l}^r(S^2+2iS+i^2)$  
$=(r-l+1)S^2+(l+r)(r-l+1)S+PowerSum(r)-PowerSum(l-1)$  

$NewXYprod=\sum_{i=l}^r(S+i)(T+i)=\sum_{i=l}^r(ST+i(S+T)+i^2)$  
$=(r-l+1)ST+\frac{(l+r)(r-l+1)(S+T)}{2}+PowerSum(r)-PowerSum(l-1)$

做完这些简单的计算，用线段树维护即可，注意本题精度较高，longlong会在#6~10卡掉，全开double为敬。

The Code：
```cpp
// by.luogu P3707

#include <cstdio>
#include <iostream>

namespace Optimize { // 优化模板
	#define Eps 1e-8
	#define Inf 0x3f3f3f3f
	#define Int register int
	#define LL long long int
	#define Type template<typename _T>
	#define FileClose() fclose ( stdin ), fclose ( stdout )
	#define FileOpen( fname ) freopen ( fname".in", "r", stdin ), freopen ( fname".out", "w", stdout )
	Type inline _T Max ( const _T a, const _T b ) { return a > b ? a : b; }
	Type inline _T Min ( const _T a, const _T b ) { return a < b ? a : b; }
	Type inline _T Abs ( const _T x ) { return x < 0 ? -x : x; }
	Type inline _T rint () {
		_T x = 0; int f = 1; char s = getchar ();
		while ( s < '0' || '9' < s ) f = s == '-' ? -1 : 1, s = getchar ();
		while ( '0' <= s && s <= '9' ) x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar ();
		return x * f;
	}
	Type inline void wint ( _T x ) {
		if ( x < 0 ) putchar ( '-' ), x = ( ~ x ) + 1;
		if ( 9 < x ) wint ( x / 10 );
		putchar ( x % 10 + '0' );
	}
}

using namespace std;
using namespace Optimize;

const int MAXN = 100000;
int n, m;
double x[MAXN + 5] = {}, y[MAXN + 5] = {};

inline double PowerSum ( const double n ) { // 前缀平方和
	return 1.0 * n * ( n + 1 ) * ( 2 * n + 1 ) / 6;
}

struct Segment_Tree {
	struct Node { // 震惊，数据大到l，r都要开double才能卡过精度
		double l, r, Items; // Items项数 = r - l + 1，反复出现在计算，直接储存更方便
		double x, y, SecSumX, SecSumY, Xpower, XYprod; // 结点信息全开double
		pair<double, double> Lazy1, Lazy2; // Lazy1 -> cmd2, Lazy2 -> cmd3
	} *Tree;
	inline void Unleaf_update ( const int i ) { // 非叶结点更新，左右子结点对应元素之和
		Tree[i].SecSumX = Tree[i << 1].SecSumX + Tree[i << 1 | 1].SecSumX;
		Tree[i].SecSumY = Tree[i << 1].SecSumY + Tree[i << 1 | 1].SecSumY;
		Tree[i].Xpower = Tree[i << 1].Xpower + Tree[i << 1 | 1].Xpower;
		Tree[i].XYprod = Tree[i << 1].XYprod + Tree[i << 1 | 1].XYprod;
	}
	inline void Build ( const int i, const int l, const int r, const double* Leafx, const double* Leafy, const int SizeofTree = 0 ) { // 建树操作
		if ( i == 1 ) Tree = new Node[SizeofTree] ();
		Tree[i].l = l, Tree[i].r = r, Tree[i].Items = r - l + 1, Tree[i].Lazy1 = Tree[i].Lazy2 = make_pair ( 0LL, 0LL );
		if ( l == r ) { // 叶结点赋值
			Tree[i].SecSumX = Leafx[l];
			Tree[i].SecSumY = Leafy[l];
			Tree[i].Xpower = Leafx[l] * Leafx[l];
			Tree[i].XYprod = Leafx[l] * Leafy[l];
			return ;
		}
		int Mid = ( l + r ) >> 1;
		this -> Build ( i << 1, l, Mid, Leafx, Leafy );
		this -> Build ( i << 1 | 1, Mid + 1, r, Leafx, Leafy );
		this -> Unleaf_update ( i ); // 记得更新非叶结点
	}
	inline void Calcul_Cover ( const int i, const double S, const double T ) { // 覆盖操作的计算
		Tree[i].SecSumX = S * Tree[i].Items + Tree[i].Items * ( Tree[i].r + Tree[i].l ) / 2;
		Tree[i].SecSumY = T * Tree[i].Items + Tree[i].Items * ( Tree[i].r + Tree[i].l ) / 2;
		Tree[i].Xpower = Tree[i].Items * S * S
						+ ( Tree[i].r + Tree[i].l ) * Tree[i].Items * S
						+ PowerSum( Tree[i].r ) - PowerSum( Tree[i].l - 1 );
		Tree[i].XYprod = Tree[i].Items * S * T
						+ ( Tree[i].l + Tree[i].r ) * Tree[i].Items / 2 * ( S + T )
						+ PowerSum( Tree[i].r ) - PowerSum( Tree[i].l - 1 );
	}
	inline void Calcul_Update ( const int i, const double S, const double T ) { // 更新操作的计算
		double NewSecSumX, NewSecSumY, NewXpower, NewXYprod;
		NewSecSumX = Tree[i].SecSumX + Tree[i].Items * S;
		NewSecSumY = Tree[i].SecSumY + Tree[i].Items * T;
		NewXpower = Tree[i].Xpower
					+ 2 * Tree[i].SecSumX * S
					+ Tree[i].Items * S * S;
		NewXYprod = Tree[i].XYprod
					+ Tree[i].SecSumX * T
					+ Tree[i].SecSumY * S
					+ Tree[i].Items * S * T;
		Tree[i].SecSumX = NewSecSumX;
		Tree[i].SecSumY = NewSecSumY;
		Tree[i].Xpower = NewXpower;
		Tree[i].XYprod = NewXYprod;
	}
	inline void Spread ( const int i ) { // 懒标记下传
		if ( ! ( Tree[i].Lazy1.first || Tree[i].Lazy1.second || Tree[i].Lazy2.first || Tree[i].Lazy2.first ) ) return ; // 情形1，直接退出
		if ( Tree[i].Lazy2.first || Tree[i].Lazy2.second ) { // 先覆盖
			Tree[i << 1].Lazy1 = Tree[i << 1 | 1].Lazy1 = make_pair ( 0LL, 0LL ); // 子结点已被覆盖，Lazy1失效，清零
			Tree[i << 1].Lazy2 = Tree[i << 1 | 1].Lazy2 = Tree[i].Lazy2; // 同是覆盖，不累加，直接赋值
			this -> Calcul_Cover ( i << 1, Tree[i].Lazy2.first, Tree[i].Lazy2.second ); // 计算子结点信息
			this -> Calcul_Cover ( i << 1 | 1, Tree[i].Lazy2.first, Tree[i].Lazy2.second );
		}
		if ( Tree[i].Lazy1.first || Tree[i].Lazy1.second ) { // 再更新
			Tree[i << 1].Lazy1.first += Tree[i].Lazy1.first; // 更新操作，Lazy1累加
			Tree[i << 1].Lazy1.second += Tree[i].Lazy1.second;
			Tree[i << 1 | 1].Lazy1.first += Tree[i].Lazy1.first;
			Tree[i << 1 | 1].Lazy1.second += Tree[i].Lazy1.second;
			this -> Calcul_Update ( i << 1, Tree[i].Lazy1.first, Tree[i].Lazy1.second ); // 计算子结点信息
			this -> Calcul_Update ( i << 1 | 1, Tree[i].Lazy1.first, Tree[i].Lazy1.second );
		}
		Tree[i].Lazy1 = Tree[i].Lazy2 = make_pair ( 0, 0 ); // 清空当前节点标记
	}
	inline double Query ( const int i, const int l, const int r, const int RetType ) { // 查询操作，通过RetType查询四个信息
		if ( r < Tree[i].l || l > Tree[i].r ) return 0; // 不相关区间，退出
		if ( l <= Tree[i].l && Tree[i].r <= r ) { // 包含区间
			switch ( RetType ) { // 选择返回信息
				case 1: return Tree[i].SecSumX;
				case 2: return Tree[i].SecSumY;
				case 3: return Tree[i].Xpower;
				case 4: return Tree[i].XYprod;
			}
		}
		this -> Spread ( i ); // 记得下放懒标记
		double lchret = this -> Query ( i << 1, l, r, RetType );
		double rchret = this -> Query ( i << 1 | 1, l, r, RetType );
		return lchret + rchret; // 递归并返回左右子结点查询值之和
	}
	inline void Cover ( const int i, const int l, const int r, const double S, const double T ) { // Cmd3，覆盖
		if ( r < Tree[i].l || l > Tree[i].r ) return ;
		if ( l <= Tree[i].l && Tree[i].r <= r ) { // 完全覆盖
			Tree[i].Lazy1 = make_pair ( 0, 0 ); // Lazy1失效
			Tree[i].Lazy2 = make_pair ( S, T ); // Lazy直接赋值
			this -> Calcul_Cover ( i, S, T ); // 计算结点信息
			return ;
		}
		this -> Spread ( i ); // 下放标记
		this -> Cover ( i << 1, l, r, S, T );
		this -> Cover ( i << 1 | 1, l, r, S, T );
		this -> Unleaf_update ( i ); // 子结点已被修改，重新维护当前结点信息
	}
	inline void Update ( const int i, const int l, const int r, const double S, const double T ) { // Cmd 2
		if ( r < Tree[i].l || l > Tree[i].r ) return ;
		if ( l <= Tree[i].l && Tree[i].r <= r ) { // 完全修改
			Tree[i].Lazy1.first += S; // Lazy1累加
			Tree[i].Lazy1.second += T;
			this -> Calcul_Update ( i, S, T ); // 计算结点信息
			return ;
		}
		this -> Spread ( i ); // 下放标记
		this -> Update ( i << 1, l, r, S, T );
		this -> Update ( i << 1 | 1, l, r, S, T );
		this -> Unleaf_update ( i ); // 维护当前结点信息
	}
} SegTree;

inline double Calculation ( const int l, const int r ) { // 答案计算
	double Items = r - l + 1;
	double XYprod = SegTree.Query ( 1, l, r, 4 ); // 分别查询四个元素的值
	double SecSumX = SegTree.Query ( 1, l, r, 1 );
	double SecSumY = SegTree.Query ( 1, l, r, 2 );
	double Xpower = SegTree.Query ( 1, l, r, 3 );
	double AvrX = 1.0 * SecSumX / Items; // x的平均值
	double AvrY = 1.0 * SecSumY / Items; // y的平均值
	double Numerator = XYprod - SecSumX * AvrY - SecSumY * AvrX + Items * AvrX * AvrY; // 分子
	double Denominator = Xpower - 2 * SecSumX * AvrX + Items * AvrX * AvrX; // 分母
	return Numerator / Denominator;
}

inline void Work () {
	#define rint rint<int>() // 声明快读类型int
	n = rint, m = rint;
	for ( Int i = 1; i <= n; ++ i ) {
		scanf ( "%lf", &x[i] );
	}
	for ( Int i = 1; i <= n; ++ i ) {
		scanf ( "%lf", &y[i] );
	} // 读入基本信息
	SegTree.Build ( 1, 1, n, x, y, n << 2 ); // 建树
	while ( m -- ) {
		int Cmd = rint, l = rint, r = rint;
		double s, t;
		switch ( Cmd ) {
			case 1: { // 求a
				double Ans = Calculation ( l, r );
				printf ( "%lf\n", Ans );
				break;
			}
			case 2: { // 更新
				scanf ( "%lf %lf", &s, &t );
				SegTree.Update ( 1, l, r, s, t );
				break;
			}
			case 3: { // 覆盖
				scanf ( "%lf %lf", &s, &t );
				SegTree.Cover ( 1, l, r, s, t );
				break;
			}
		}
	}
}

int main () {
	Work ();
	return 0;
}
```



---

## 作者：Karry5307 (赞：5)

### 题意

给定两个长度为 $n$ 的序列 $x,y$，有 $m$ 次操作，每次操作形如以下三种：

- `1 l r`：求出 $(x_l,y_l),\cdots,(x_r,y_r)$ 的回归方程的斜率。

- `2 l r S T`：将满足 $l\leq i\leq r$ 的 $x_i$ 加上 $S$，$y_i$ 加上 $T$。

- `3 l r S T`：将满足 $l\leq i\leq r$ 的 $x_i$ 改为 $S+i$，$y_i$ 改为 $T+i$。

其中对于数据 $(x_1,y_1),\cdots (x_n,y_n)$ 的回归方程的斜率为

$$\hat{a}=\frac{\sum\limits_{i=1}^{n}(x_i-\overline{x})(y_i-\overline{y})}{\sum\limits_{i=1}^{n}(x_i-\overline{x})^2}$$

$\texttt{Data Range:}1\leq n,m\leq 10^5$。

### 题解

[不一定更好的阅读体验](https://www.cnblogs.com/Karry5307/p/13682106.html)

写了两个小时，线段树懒标记部分写错都不知道自己是怎么死的。

~~mmp 这题怎么这么难写~~

考虑先推一下式子，强行展开有

$$\hat{a}=\frac{\sum\limits_{i=1}^{n}x_iy_i-\overline{x}\sum\limits_{i=1}^{n}y_i-\overline{y}\sum\limits_{i=1}^{n}x_i+n\overline{x}\overline{y}}{\sum\limits_{i=1}^{n}x_i^2-2\overline{x}\sum\limits_{i=1}^{n}x_i+n\overline{x}^2}$$

考虑将 $\overline{x}$ 和 $\overline{y}$ 拆一下并且合并一下同类项得到

$$\hat{a}=\frac{\sum\limits_{i=1}^{n}x_iy_i-\frac{1}{n}\sum\limits_{i=1}^{n}x_i\sum\limits_{i=1}^{n}y_i}{\sum\limits_{i=1}^{n}x_i^2-\frac{1}{n}\sum\limits_{i=1}^{n}x_i}$$

到这里维护的东西就很清晰了，考虑怎么来维护。一次的东西很平凡，考虑二次的。

$$\sum\limits_{i=1}^{n}(x_i+S)(y_i+T)=\sum\limits_{i=1}^{n}x_iy_i+S\sum\limits_{i=1}^{n}y_i+T\sum\limits_{i=1}^{n}x_i+nST$$

然后就没了，同样的道理得到

$$\sum\limits_{i=1}^{n}(x_i+S)^2=\sum\limits_{i=1}^{n}x_i^2+2S\sum\limits_{i=1}^{n}x_i+nS^2$$

这样就可以直接做 $2$ 操作了。对于 $3$ 操作的话可以先考虑强行赋值然后再区间加，赋值这一部分就是基础的求和公式运用，然后就没了。

一个注意的点是区间赋值递归到某个区间时要把这个区间的加法懒标记清零（~~我这个 sb 就是因为这个调了 1h 的~~）

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
typedef long double db;
const ll MAXN=2e5+51;
struct SegmentTree{
	ll l,r,tag;
	db sxx,sxy,sx,sy,tagx,tagy;
};
SegmentTree tree[MAXN<<2];
ll n,qcnt,op,l,r,len;
SegmentTree p,g;
db s,t;
db x[MAXN],y[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline db sum2(ll x)
{
	return 1.0*x*(x+1)*(2*x+1)/6;
}
#define ls node<<1
#define rs (node<<1)|1
inline void update(ll node)
{
	tree[node].sxx=tree[ls].sxx+tree[rs].sxx;
	tree[node].sxy=tree[ls].sxy+tree[rs].sxy;
	tree[node].sx=tree[ls].sx+tree[rs].sx;
	tree[node].sy=tree[ls].sy+tree[rs].sy;
}
inline void create(ll l,ll r,ll node)
{
	tree[node]=(SegmentTree){l,r};
	if(l==r)
	{
		tree[node].sx=x[l],tree[node].sy=y[l];
		return (void)(tree[node].sxx=x[l]*x[l],tree[node].sxy=x[l]*y[l]);
	}
	ll mid=(tree[node].l+tree[node].r)>>1;
	create(l,mid,ls),create(mid+1,r,rs),update(node);
}
inline void spread(ll node)
{
	ll lenl=tree[ls].r-tree[ls].l+1,lenr=tree[rs].r-tree[rs].l+1;
	if(tree[node].tag)
	{
		tree[ls].sx=tree[ls].sy=lenl*tree[ls].l+lenl*(lenl-1)/2.0;
		tree[rs].sx=tree[rs].sy=lenr*tree[rs].l+lenr*(lenr-1)/2.0;
		tree[ls].sxx=tree[ls].sxy=sum2(tree[ls].r)-sum2(tree[ls].l-1);
		tree[rs].sxx=tree[rs].sxy=sum2(tree[rs].r)-sum2(tree[rs].l-1);
		tree[ls].tag=tree[rs].tag=1,tree[node].tag=0;
		tree[ls].tagx=tree[ls].tagy=tree[rs].tagx=tree[rs].tagy=0;
	}
	if(tree[node].tagx!=0||tree[node].tagy!=0)
	{
		db u=tree[node].tagx,v=tree[node].tagy;
		tree[ls].sxx+=2*u*tree[ls].sx+lenl*u*u;
		tree[rs].sxx+=2*u*tree[rs].sx+lenr*u*u;
		tree[ls].sxy+=u*tree[ls].sy+v*tree[ls].sx+lenl*u*v;
		tree[rs].sxy+=u*tree[rs].sy+v*tree[rs].sx+lenr*u*v;
		tree[ls].sx+=lenl*u,tree[ls].sy+=lenl*v;
		tree[rs].sx+=lenr*u,tree[rs].sy+=lenr*v;
		tree[ls].tagx+=u,tree[rs].tagx+=u,tree[node].tagx=0;
		tree[ls].tagy+=v,tree[rs].tagy+=v,tree[node].tagy=0;
	}
}
inline void add(ll l,ll r,db s,db t,ll node)
{
	if(l<=tree[node].l&&r>=tree[node].r)
	{
		ll len=tree[node].r-tree[node].l+1;
		tree[node].sxx+=2*s*tree[node].sx+len*s*s;
		tree[node].sxy+=s*tree[node].sy+t*tree[node].sx+len*s*t;
		tree[node].sx+=len*s,tree[node].sy+=len*t;
		return (void)(tree[node].tagx+=s,tree[node].tagy+=t);
	}
	ll mid=(tree[node].l+tree[node].r)>>1;
	spread(node),l<=mid?add(l,r,s,t,ls):(void)1,r>mid?add(l,r,s,t,rs):(void)1;
	update(node);
}
inline void cover(ll l,ll r,ll node)
{
	if(l<=tree[node].l&&r>=tree[node].r)
	{
		ll len=tree[node].r-tree[node].l+1;
		tree[node].sxx=tree[node].sxy=sum2(tree[node].r)-sum2(tree[node].l-1);
		tree[node].sx=tree[node].sy=tree[node].l*len+len*(len-1)/2.0;
		return (void)(tree[node].tag=1,tree[node].tagx=tree[node].tagy=0);
	}
	ll mid=(tree[node].l+tree[node].r)>>1;
	spread(node),l<=mid?cover(l,r,ls):(void)1,r>mid?cover(l,r,rs):(void)1;
	update(node);
}
inline SegmentTree query(ll l,ll r,ll node)
{
	SegmentTree u=g,v=g;
	if(l<=tree[node].l&&r>=tree[node].r)
	{
		return tree[node];	
	}	
	ll mid=(tree[node].l+tree[node].r)>>1;
	spread(node);
	l<=mid?(void)(u=query(l,r,ls)):(void)1;
	r>mid?(void)(v=query(l,r,rs)):(void)1;
	return (SegmentTree){0,0,0,u.sxx+v.sxx,u.sxy+v.sxy,u.sx+v.sx,u.sy+v.sy};
}
int main()
{
	n=read(),qcnt=read();
	for(register int i=1;i<=n;i++)
	{
		scanf("%Lf",&x[i]);
	}
	for(register int i=1;i<=n;i++)
	{
		scanf("%Lf",&y[i]);
	}
	create(1,n,1);
	for(register int i=1;i<=qcnt;i++)
	{
		op=read(),l=read(),r=read();
		if(op==1)
		{
			p=query(l,r,1),len=r-l+1;
			printf("%.10Lf\n",(p.sxy-p.sx*p.sy/len)/(p.sxx-p.sx*p.sx/len));
			continue;
		}
		scanf("%Lf%Lf",&s,&t),op==3?cover(l,r,1):(void)1,add(l,r,s,t,1);
	}
}
```

---

## 作者：N2MENT (赞：3)

**p3707** 

------------

这道题第一次写了一颗线段树，（ ~~只有样例过了~~ ） 始终没有调出来，于是写了一个分块。 

首先要化简本题的阴间式子 


$$a=\frac{\sum^R_{i=L}(x_i-\bar{x})(y_i-\bar{y})}{\sum^R_{i=L}(x_i-\bar{x})^2} $$


以下为分子： 

$$=\sum^R_{i=L} (x_iy_i-x_i\bar{y}-y_i\bar{x}+\bar{x}\bar{y})$$ 

$$=\sum^R_{i=L} x_iy_i-\bar{y}\sum^R_{i=L}x_i-\bar{x}\sum^R_{i=L}y_i+\sum^R_{i=L}\bar{x}\bar{y}$$ 

把 $\bar x$ 和 $\bar y$ 展开： 

$$=\sum^R_{i=L} x_iy_i-\frac{\sum^R_{i=L} x_i\sum^R_{i=L} y_i}{R-L+1}-\frac{\sum^R_{i=L} x_i\sum^R_{i=L} y_i}{R-L+1}+\frac{\sum^R_{i=L} x_i\sum^R_{i=L} y_i}{R-L+1}$$ 

$$=\sum^R_{i=L} x_iy_i-\frac{\sum^R_{i=L} x_i\sum^R_{i=L} y_i}{R-L+1}$$ 

分母同理： 

$$=\sum^R_{i=L} x_i^2-\frac{(\sum^R_{i=L} x_i)^2}{R-L+1}$$ 

于是，原来的式子就被化成了下面的形式： 

$$a=\frac{\sum^R_{i=L} x_iy_i-\frac{\sum^R_{i=L} x_i\sum^R_{i=L} y_i}{R-L+1}}{\sum^R_{i=L} x_i^2-\frac{(\sum^R_{i=L} x_i)^2}{R-L+1}}$$ 

所以我们只需要维护 $\sum x_i$ $\sum y_i$ $\sum x_iy_i$ $\sum x_i^2$ ，对于区间加和区间覆盖操作，我们可以维护标记 add 和 cover 。

**操作 2：** 

$\sum (x_i+s)(y_i+t)=\sum x_iy_i+s\sum y_i+t\sum x_i+st(R-L+1)$ 

$\sum (x_i+s)^2=\sum x_i^2+2s\sum x_i+s^2(R-L+1)$ 

之后再更新 $\sum x_i$ $\sum y_i$ 并记录 add 。 

**操作 3：** 

每个块直接清空 add 标记，并记录 cover ,然后直接用平方和公式 （ $\frac{n(n+1)(2n+1)}{6}$ ） 维护信息。 

对于碎块，直接暴力计算更改产生的贡献。 

**注意** 

存在覆盖标记的碎块在进行更改时可能产生混淆，所以可以直接 **清空整个块的所有标记** 再进行更改 （ 先覆盖再修改 ） 

可能可行的优化： 

1. 略微调低块的大小 

1. ~~O2yyds~~ 

[可能存在的更改](https://www.luogu.com.cn/paste/lwdkdp2m) 

code  

细节可以看代码 （ ~~码风自我感觉良好~~ ）  
```cpp
#include<bits/stdc++.h>
#define double long double
#define int long long
using namespace std;
const int maxn=100010;
double x[maxn],y[maxn];
int n,m,K;
struct block {
	int l,r;
	double x2,xy,x,y;
	double add[2];//区间加标记
	double cvr[2];//区间覆盖标记
	bool c;
} b[maxn];
int id[maxn];
void clear(int t) {//清空整个块
	if(b[t].c) {
		b[t].c=0;
		for(int i=b[t].l; i<=b[t].r; i++) {
			x[i]=b[t].cvr[0]+i;
			y[i]=b[t].cvr[1]+i;
		}
		b[t].cvr[0]=b[t].cvr[1]=0;
	}
	if(b[t].add[0]||b[t].add[1]) {
		int S=b[t].add[0];
		int T=b[t].add[1];
		for(int i=b[t].l; i<=b[t].r; i++) {
			x[i]+=S;
			y[i]+=T;
		}
		b[t].add[0]=b[t].add[1]=0;
	}
}
void add(int l,int r,double s,double t) {
	clear(id[l]);
	clear(id[r]);
	for(int i=l; i<=b[id[l]].r&&i<=r; i++) {
		b[id[l]].x2+=2*s*x[i]+s*s;
		b[id[l]].xy+=s*y[i]+t*x[i]+s*t;
		b[id[l]].x+=s;
		b[id[l]].y+=t;
		x[i]+=s;
		y[i]+=t;
	}
	if(id[l]!=id[r])
		for(int i=b[id[r]].l; i<=r; i++) {
			b[id[r]].x2+=2*s*x[i]+s*s;
			b[id[r]].xy+=s*y[i]+t*x[i]+s*t;
			b[id[r]].x+=s;
			b[id[r]].y+=t;
			x[i]+=s;
			y[i]+=t;
		}
	for(int i=id[l]+1; i<id[r]; i++) {
		b[i].x2+=2*b[i].x*s+s*s*(b[i].r-b[i].l+1);
		b[i].xy+=b[i].x*t+b[i].y*s+s*t*(b[i].r-b[i].l+1);
		b[i].x+=s*(b[i].r-b[i].l+1);
		b[i].y+=t*(b[i].r-b[i].l+1);
		b[i].add[0]+=s;
		b[i].add[1]+=t;
	}
	return;
}
void cover(int l,int r,double s,double t) {
	clear(id[l]);
	clear(id[r]);
	for(int i=l; i<=b[id[l]].r&&i<=r; i++) {
		b[id[l]].x2-=x[i]*x[i]-(s+i)*(s+i);
		b[id[l]].xy-=x[i]*y[i]-(s+i)*(t+i);
		b[id[l]].x-=x[i]-(s+i);
		b[id[l]].y-=y[i]-(t+i);
		x[i]=s+i;
		y[i]=t+i;
	}
	if(id[l]!=id[r])
		for(int i=b[id[r]].l; i<=r; i++) {
			b[id[r]].x2-=x[i]*x[i]-(s+i)*(s+i);
			b[id[r]].xy-=x[i]*y[i]-(s+i)*(t+i);
			b[id[r]].x-=x[i]-(s+i);
			b[id[r]].y-=y[i]-(t+i);
			x[i]=s+i;
			y[i]=t+i;//暴力计算贡献
		}
	for(int i=id[l]+1; i<id[r]; i++) {
		int l=b[i].l;
		int r=b[i].r;
        	//平方和公式维护信息
		b[i].x2=(r-l+1)*s*s+s*(l+r)*(r-l+1)+r*(r+1)*(2*r+1)/6-l*(l-1)*(2*l-1)/6;
		b[i].xy=(r-l+1)*s*t+(s+t)*(l+r)*(r-l+1)/2+r*(r+1)*(2*r+1)/6-l*(l-1)*(2*l-1)/6;
		b[i].x=(r-l+1)*s+(l+r)*(r-l+1)/2;
		b[i].y=(r-l+1)*t+(l+r)*(r-l+1)/2;
		b[i].cvr[0]=s;
		b[i].cvr[1]=t;
		b[i].add[0]=b[i].add[1]=0;
		b[i].c=1;
	}
	return;
}
struct Ans {
	double x,y,xy,x2;
} ans;
double query(int l,int r) {
	ans.x=ans.x2=ans.xy=ans.y=0;
	clear(id[l]);
	clear(id[r]);
	for(int i=l; i<=b[id[l]].r; i++) {
		ans.x+=x[i];
		ans.y+=y[i];
		ans.x2+=x[i]*x[i];
		ans.xy+=x[i]*y[i];
	}
	if(id[l]!=id[r])
		for(int i=b[id[r]].l; i<=r; i++) {
			ans.x+=x[i];
			ans.y+=y[i];
			ans.x2+=x[i]*x[i];
			ans.xy+=x[i]*y[i];
		}
	for(int i=id[l]+1; i<id[r]; i++) {
		ans.x+=b[i].x;
		ans.y+=b[i].y;
		ans.x2+=b[i].x2;
		ans.xy+=b[i].xy;
	}
	return (ans.xy-ans.x*ans.y/(r - l + 1))/(ans.x2-ans.x*ans.x/(r - l + 1));
}

signed main() {
	scanf("%lld%lld",&n,&m);
	for(int i=1; i<=n; i++) {
		scanf("%Lf",x+i);
	}
	for(int i=1; i<=n; i++) {
		scanf("%Lf",y+i);
	}
	K=sqrt(n);
	for(int i=1; i<=n; i++) {
		id[i]=(i-1)/K+1;
		b[id[i]].x+=x[i];
		b[id[i]].y+=y[i];
		b[id[i]].x2+=x[i]*x[i];
		b[id[i]].xy+=x[i]*y[i];
	}
	for(int i=1; i<=id[n]; i++) {
		b[i].l=(i-1)*K+1;
		b[i].r=i*K;
	}
	b[id[n]].r=n;
	for(int i=1; i<=m; i++) {
		int in,l,r;
		double s,t;
		scanf("%lld%lld%lld",&in,&l,&r);
		switch(in) {
			case 1:
				printf("%.10Lf\n",query(l,r));
				break;
			case 2:
				scanf("%Lf%Lf",&s,&t);
				add(l,r,s,t);
				break;
			case 3:
				scanf("%Lf%Lf",&s,&t);
				cover(l,r,s,t);
				break;
		}
	}
}
```


---

## 作者：离子键Ionic_Bond (赞：3)

## [SDOI2017] 相关分析 Solution
### 写题解挺累人的，各位看官给个赞吧~

**【思路比较大众化，主要是我觉得自己的代码比较易懂所以发了这篇题解。如果介意思路不够新颖，勿看，勿喷。】**

第一眼看到这个题，那个求线性回归方程一次项系数$\hat a$的式子让我以为这是什么毒瘤统计学题目；

~~(后来证明确实很毒瘤)。~~

再仔细看一眼，发现就是非常直接的区间修改和区间特殊运算结果查询；

仔细想想，你会发现线段树貌似没法直接且精确的维护这个回归方程的值，会有精度问题而且写起来会异常麻烦；

所以我们就需要把这个看起来十分奇妙的式子**拆一拆**，拆成**用线段树可以准确且容易维护的东西**；

其实吧，这个式子看着挺麻烦，其实很好化简，大概是这么个过程：

$$\hat a=\frac{\sum_{i=L}^{R}{(x_i-\bar{x})(y_i-\bar{y})}}{\sum_{i=L}^{R}{(x_i-\bar{x})}}$$

$$\Rightarrow \hat a=\frac{\sum(x_iy_i-\bar{x}y_i-\bar{y}x_i+\bar{x}\bar{y})}{\sum{(x_i^2-2x_i\bar{x}+\bar{x}^2)}}$$

$$\Rightarrow \hat a=\frac{\sum x_iy_i-\sum \bar{x}y_i-\sum \bar{y}x_i+\bar{x}\bar{y}\cdot(L-R+1)}{\sum{x_i^2-\sum 2x_i\bar{x}+\bar{x}^2\cdot (L-R+1)}}$$

$$\Rightarrow \hat a=\frac{\sum x_iy_i-\bar{x}\sum y_i-\bar{y}\sum x_i+\bar{x}\bar{y}\cdot(L-R+1)}{\sum{x_i^2-2\bar{x}\sum x_i +\bar{x}^2\cdot (L-R+1)}}$$
【注：上面的那个式子我们记为(1)】

然后，把$\ \bar x\ $和$\ \bar y\ $带入进去,你会发现式子变得**简单**了:


$$(1)\Rightarrow \hat a=\frac{\sum x_iy_i-\frac{\sum x_i\sum y_i}{R-L+1}-\frac{\sum y_i \sum x_i}{R-L+1}+\frac{\sum x_i \sum y_i}{(R-L+1)^2}\cdot(R-L+1)}{\sum x_i^2-2\cdot\frac{(\sum x_i)^2}{R-L+1}+\frac{(\sum x_i)^2}{(R-L+1)^2}\cdot(R-L+1)}$$

$$\Rightarrow \hat a=\frac{\sum x_iy_i-\frac{\sum x_iy_i}{R-L+1}}{\sum x_i^2-\frac{(\sum x_i)^2}{R-L+1}}$$

化简到这一步，我们就找到了可以**准确且较为容易维护**的四个值，即
$\sum x_i,\sum y_i,\sum x_iy_i,\sum x_i^2$

OK, fine. 如何进行**区间查询**我们已经解决了。

接下来的问题就是如何修改。

- **区间加法**

每次做区间加法，上面维护的四个值分别会这样变化：

$$\sum (x_i+S)=\sum x_i+S(R-L+1)$$

$$\sum (y_i+T)=\sum x_i+T(R-L+1)$$

$$\sum (x_i+S)(y_i+T)=\sum x_iy_i+S\sum y_i+T\sum x_i+ST(R-L+1)$$

每次修改只需要加上原先区间和的后面那一坨就可以了。

- **区间修改**

考虑先大力把 `x` 序列和 `y` 序列 的 `L~R` 区间里的每一个值修改成 `i`，

然后再对两个区间分别做加 `S` 和加 `T` 的区间加法。

那么问题来了：

我们怎么去修改这四个值呢？

$\mathbb Q:$ $\sum x_i$ 和$\sum y_i$ 的修改？

$\mathbb A:$
1. 前缀和维护 $\sum_{i=1}^{n}{i}$，然后将对应区间改为$pre_R-pre_{L-1}$.

2. 只需要将对应区间改为 `(R-L+1)*(R+L)/2` 即可。

---
$\mathbb Q:$ $\sum x_i^2$和$\sum x_iy_i$ 的修改？

$\mathbb A:$ 
1. 前缀和维护 $\sum_{i=1}^{n}{i^2}$，然后将对应区间改为$powpre_R-powpre_{L-1}$.

2. 利用公式 $\sum_{i=1}^{n}{i^2}=\frac{n(n+1)(2n+1)}{6}$ 维护,然后将对应区间改为$powpre_R-powpre_{L-1}$.

OK, fine.

至此，我们解决完了所有数学问题，解决完这些问题，实现起来其实就不难了。这里略微一讲。

这题的 `pushdown` 实现看起来很毒瘤，需要维护一大堆东西，其实写起来并不是很难，结合代码看看：

```cpp
void transtag(int p,int l,int r,double S,double T){//区间求和pushdown
	tgx[p]+=S;
	tgy[p]+=T;
	double lth=(double)r-(double)l+1.00;
	tr[p][3]+=T*tr[p][1]+S*tr[p][2]+S*T*lth;
	tr[p][4]+=2*S*tr[p][1]+S*S*lth; 
	tr[p][1]+=S*lth;
	tr[p][2]+=T*lth;//刚刚推得的四个式子
}
void mvtag(int p,int l,int r){//区间修改pushdown
	tr[p][1]=tr[p][2]=getsum((double)l,(double)r);
	//getsum:sigma(x[i])
	tr[p][3]=tr[p][4]=getpowsum((double)l,(double)r);
	//getpowsum:sigma(x[i]*x[i])
	tgx[p]=tgy[p]=0;//清零求和懒标记，因为这个区间已经全部被修改过了
	flag[p]=1;//该节点有区间修改操作，把它的 flag[] 改为 true
}
void pushdown(int p,int l,int r){
	int md=(l+r)>>1;
	if(flag[p])mvtag(ls(p),l,md),mvtag(rs(p),md+1,r);
	//flag[]:判断该区间是否存在区间修改操作的 lazy tag
	transtag(ls(p),l,md,tgx[p],tgy[p]);
	transtag(rs(p),md+1,r,tgx[p],tgy[p]);
	tgx[p]=tgy[p]=0;
	flag[p]=0;//将所有懒标记清零
}
```
OK, fine.

现在就可以去码其它部分啦！

其实这个题除了 `pushdown` 操作，没有任何难点。

就是正常的求和、区间维护。**思维难度不大但实现比较麻烦**，这里附上我自己的代码，仅供参考。

~~（鬼知道我因为把 `l` 写成  `1` 这种鬼畜错误调了一晚上这题后从机房走出来啥心情）~~

## Code :

```cpp
#include<bits/stdc++.h>
#define Te template
#define ll long long
#define elif else if

using namespace std;

Te <typename R> R read(R &x){
	x=0;
	char c=getchar();R f=1;
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
	return x=x*f;
}

Te <typename W> void write(W x){
	if(x<0)x=(~x)|1,putchar('-');
	if(x>9)write(x/10);
	putchar((x-(x/10)*10)+48);
}

/*Variables*/
const int N=1e5+7;
int n,m;
double tr[N<<2][5],tgx[N<<2],tgy[N<<2],x[N],y[N],pows[N],ans[5];
bool flag[N<<2];
/*Functions and Classification*/

class SegTr{
	private:
		int ls(int p){return p<<1;} 
		int rs(int p){return p<<1|1;}
		void pushup(int p){
			for(int i=1;i<=4;i++){
				tr[p][i]=tr[ls(p)][i]+tr[rs(p)][i];
			}
		}
		void transtag(int p,int l,int r,double S,double T){
			tgx[p]+=S;
			tgy[p]+=T;
			double lth=(double)r-(double)l+1.00;
			tr[p][3]+=T*tr[p][1]+S*tr[p][2]+S*T*lth;
			tr[p][4]+=2*S*tr[p][1]+S*S*lth; 
			tr[p][1]+=S*lth;
			tr[p][2]+=T*lth;
		}
		void mvtag(int p,int l,int r){
			tr[p][1]=tr[p][2]=this->getsum((double)l,(double)r);
			tr[p][3]=tr[p][4]=this->getpowsum((double)l,(double)r);
			tgx[p]=tgy[p]=0;
			flag[p]=1;
		}
		void pushdown(int p,int l,int r){
			int md=(l+r)>>1;
			if(flag[p])mvtag(ls(p),l,md),mvtag(rs(p),md+1,r);
			transtag(ls(p),l,md,tgx[p],tgy[p]);
			transtag(rs(p),md+1,r,tgx[p],tgy[p]);
			tgx[p]=tgy[p]=0;
			flag[p]=0;
		}
		double getsum(double l,double r){
			return (l+r)*(r-l+1)/2;
		}
		double getpowsum(int l,int r){		
			return pows[r]-pows[l-1];
		}
	public:
		void build(int p,int l,int r){
			if(l==r){
				tr[p][1]=x[l],
				tr[p][2]=y[l],
				tr[p][3]=x[l]*y[l],
				tr[p][4]=x[l]*x[l];
				return;
			}
			int md=(l+r)>>1;
			build(ls(p),l,md);
			build(rs(p),md+1,r);
			pushup(p);	
		}
		void block_add(int p,int l,int r,int gl,int gr,double S,double T){
			if(gl<=l&&gr>=r){
				transtag(p,l,r,S,T);
				return;
			}
			pushdown(p,l,r);
			int md=(l+r)>>1;
			if(gl<=md)this->block_add(ls(p),l,md,gl,gr,S,T);
			if(gr>md)this->block_add(rs(p),md+1,r,gl,gr,S,T);
			pushup(p);
		}
		void block_rev(int p,int l,int r,int gl,int gr,int S,int T){
			if(gl<=l&&gr>=r){
				mvtag(p,l,r);
				transtag(p,l,r,S,T);
				return;
			}
			pushdown(p,l,r);
			int md=(l+r)>>1;
			if(gl<=md)this->block_rev(ls(p),l,md,gl,gr,S,T);
			if(gr>md)this->block_rev(rs(p),md+1,r,gl,gr,S,T);
			pushup(p);
		}
		double block_sum(int p,int l,int r,int gl,int gr,int i){
			double res=0;
			if(gl<=l&&gr>=r){
				return tr[p][i]; 
			}
			pushdown(p,l,r);
			int md=(l+r)>>1;
			if(gl<=md)res+=this->block_sum(ls(p),l,md,gl,gr,i);
			if(gr>md)res+=this->block_sum(rs(p),md+1,r,gl,gr,i);
			return res;
			pushup(p);
		}
}SegmentTree;
/*---*/
int main(){
	read(n),read(m);
	for(int i=1;i<=n;i++)scanf("%lf",&x[i]),pows[i]=pows[i-1]+(double)i*(double)i;
	for(int j=1;j<=n;j++)scanf("%lf",&y[j]);
	SegmentTree.build(1,1,n);
	for(;m--;){
		int Q,L,R;
		double S,T;
		cin>>Q;
		scanf("%d%d",&L,&R);
		if(Q==1){			
			for(int i=1;i<=4;i++)ans[i]=SegmentTree.block_sum(1,1,n,L,R,i);
			double answer=(ans[3]-(ans[1]*ans[2])/(R-L+1))/(ans[4]-(ans[1]*ans[1])/(R-L+1));
			printf("%.10lf\n",answer);
		}
		if(Q==2){
			scanf("%lf%lf",&S,&T);
			SegmentTree.block_add(1,1,n,L,R,S,T);		
		}
		if(Q==3){
			scanf("%lf%lf",&S,&T);
			SegmentTree.block_rev(1,1,n,L,R,S,T);			
		}
	}
}
```

---

## 作者：xyz32768 (赞：3)

1、概述

====
一道比BZOJ1858还要恶心的线段树……

调了好几个小时……


2、维护内容

======
考虑拆开式子：

$\frac{\sum_{i=L}^R(x_i-\bar x)(y_i-\bar y)}{\sum_{i=L}^R(x_i-\bar x)^2}=\frac{\sum_{i=L}^Rx_iy_i-\frac{(\sum_{i=L}^Rx_i)*(\sum_{i=L}^Ry_i)}{R-L+1}}{\sum_{i=L}^Rx_i^2-\frac{(\sum_{i=L}^Rx_i)^2}{R-L+1}}$。

所以只要维护$\sum x,\sum y,\sum xy,\sum x^2$的值。

对于修改，维护$4$个标记：

$addX$：$x$区间加的标记。

$addY$：$y$区间加的标记。

$tagX$：$x$区间成段更新的标记，并且每一个$x$值加上$i$。

$tagY$：$y$区间成段更新的标记，并且每一个$y$值加上$i$。


3、标记更新

======
标记的更新一个比一个恶心……

以下$l$为左端点，$r$为右端点。

对于区间加操作，

$\sum xy+=T\sum x+S\sum y+(r-l+1)*S*T$

$\sum x^2+=2S\sum x+(r-l+1)*S^2$

$\sum x+=(r-l+1)*S$

$\sum y+=(r-l+1)*T$

对于区间更新操作，

$\sum x=(r-l+1)*S+\frac{(r-l+1)*(l+r)}{2}$

$\sum y=(r-l+1)*T+\frac{(r-l+1)*(l+r)}{2}$

$\sum x^2=(r-l+1)*S^2+S*(l+r)*(r-l+1)+\frac{r(r+1)(2r+1)}{6}-\frac{l(l-1)(2l-1)}{6}$

$\sum xy=(r-l+1)*S*T+\frac{(S+T)*(l+r)*(r-l+1)}{2}+\frac{r(r+1)(2r+1)}{6}-\frac{l(l-1)(2l-1)}{6}$


4、代码

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 1e5 + 5, M = 4e5 + 5;
int n, m, X[N], Y[N], QAQ = 1;
struct cyx {
    double sumX, sumY, sumXY, sumX2, addX, addY,
        firX, firY; bool cn;
    int l, r, lc, rc, inc;
} T[M];
struct pyz {
    double sumX, sumY, sumXY, sumX2;
    friend inline pyz operator + (pyz a, pyz b) {
        pyz res; res.sumX = a.sumX + b.sumX;
        res.sumY = a.sumY + b.sumY;
        res.sumX2 = a.sumX2 + b.sumX2;
        res.sumXY = a.sumXY + b.sumXY;
        return res;
    }
};
inline double sqr(const double x) {return x * x;}
inline double sumx2(const double l, const double r) {
    return 1.0 * r * (r + 1) * (2.0 * r + 1) / 6.0
        - 1.0 * l * (l - 1) * (2.0 * l - 1) / 6.0;
}
inline void downdate(const int x) {
    int lc = T[x].lc, rc = T[x].rc;
    if (T[x].cn) {
        T[lc].firX = T[x].firX;
        T[rc].firX = T[x].firX;
        T[lc].cn = T[rc].cn = 1; T[x].cn = 0;
        T[lc].addX = T[rc].addX = T[lc].inc = 0;
        T[lc].firY = T[x].firY;
        T[rc].firY = T[x].firY;
        T[lc].cn = T[rc].cn = 1; T[x].cn = 0;
        T[lc].addY = T[rc].addY = T[rc].inc = 0;
    }
    T[lc].addX += T[x].addX; T[rc].addX += T[x].addX; T[x].addX = 0;
    T[lc].addY += T[x].addY; T[rc].addY += T[x].addY; T[x].addY = 0;
    T[lc].inc += T[x].inc; T[rc].inc += T[x].inc; T[x].inc = 0;
}
inline void upt(const int x) {
    int lc = T[x].lc, rc = T[x].rc, l = T[x].l, r = T[x].r;
    double x1, y1, xy1, x21, x2, y2, xy2, x22; int mid = l + r >> 1;
    x1 = T[lc].sumX; x2 = T[rc].sumX;
    y1 = T[lc].sumY; y2 = T[rc].sumY;
    x21 = T[lc].sumX2; x22 = T[rc].sumX2;
    xy1 = T[lc].sumXY; xy2 = T[rc].sumXY;
    x21 += 2.0 * x1 * T[lc].addX + T[lc].addX * T[lc].addX * (mid - l + 1);
    x22 += 2.0 * x2 * T[rc].addX + T[rc].addX * T[rc].addX * (r - mid);
    xy1 += x1 * T[lc].addY + T[lc].addX * y1 +
        T[lc].addX * T[lc].addY * (mid - l + 1);
    xy2 += x2 * T[rc].addY + T[rc].addX * y2 +
        T[rc].addX * T[rc].addY * (r - mid);
    x1 += T[lc].addX * (mid - l + 1); x2 += T[rc].addX * (r - mid);
    y1 += T[lc].addY * (mid - l + 1); y2 += T[rc].addY * (r - mid);
    if (T[lc].inc) {
        double lx = T[lc].firX + T[lc].addX, ly = T[lc].firY + T[lc].addY;
        x21 = 1.0 * (mid - l + 1) * sqr(lx) + lx * (l + mid) *
            (mid - l + 1) + sumx2(l, mid);
        xy1 = 1.0 * lx * ly * (mid - l + 1) + (lx + ly) * (l + mid)
            * (mid - l + 1) / 2.0 + sumx2(l, mid);
        x1 = lx * (mid - l + 1) + 1.0 * (l + mid) * (mid - l + 1) / 2.0;
        y1 = ly * (mid - l + 1) + 1.0 * (l + mid) * (mid - l + 1) / 2.0;
    }
    if (T[rc].inc) {
        double rx = T[rc].firX + T[rc].addX, ry = T[rc].firY + T[rc].addY;
        x22 = 1.0 * (r - mid) * sqr(rx) + rx * (mid + 1 + r) *
            (r - mid) + sumx2(mid + 1, r);
        xy2 = 1.0 * rx * ry * (r - mid) + (rx + ry) * (mid + 1 + r)
            * (r - mid) / 2.0 + sumx2(mid + 1, r);
        x2 = rx * (r - mid) + 1.0 * (mid + 1 + r) * (r - mid) / 2.0;
        y2 = ry * (r - mid) + 1.0 * (mid + 1 + r) * (r - mid) / 2.0;
    }
    T[x].sumX = x1 + x2; T[x].sumY = y1 + y2;
    T[x].sumXY = xy1 + xy2; T[x].sumX2 = x21 + x22;
}
inline void build(const int l, const int r, const int p) {
    T[p].l = l; T[p].r = r;
    if (l == r) {
        T[p].sumX = X[l]; T[p].sumY = Y[l];
        T[p].sumXY = T[p].sumX * T[p].sumY;
        T[p].sumX2 = T[p].sumX * T[p].sumX;
        return;
    }
    int p2 = (T[p].lc = ++QAQ), p3 = (T[p].rc = ++QAQ);
    int mid = l + r >> 1; build(l, mid, p2); build(mid + 1, r, p3);
    T[p].sumX = T[p2].sumX + T[p3].sumX;
    T[p].sumY = T[p2].sumY + T[p3].sumY;
    T[p].sumXY = T[p2].sumXY + T[p3].sumXY;
    T[p].sumX2 = T[p2].sumX2 + T[p3].sumX2;
}
inline void change(const int s, const int e,
const int Si, const int Ti, const int p) {
    int l = T[p].l, r = T[p].r;
    if (l == s && r == e) {
        T[p].addX += 1.0 * Si; T[p].addY += 1.0 * Ti;
        return;
    }
    int mid = l + r >> 1, p2 = T[p].lc, p3 = T[p].rc; downdate(p);
    if (e <= mid) change(s, e, Si, Ti, p2);
    else if (s >= mid + 1) change(s, e, Si, Ti, p3);
    else change(s, mid, Si, Ti, p2), change(mid + 1, e, Si, Ti, p3);
    upt(p);
}
inline void modify(const int s, const int e, const int Si,
const int Ti, const int p) {
    int l = T[p].l, r = T[p].r;
    if (T[p].l == s && T[p].r == e) {
        T[p].cn = 1; T[p].firX = 1.0 * Si; T[p].firY = 1.0 * Ti; T[p].inc = 1;
        T[p].addX = T[p].addY = 0;
        return;
    }
    int mid = l + r >> 1, p2 = T[p].lc, p3 = T[p].rc; downdate(p);
    if (e <= mid) modify(s, e, Si, Ti, p2);
    else if (s >= mid + 1) modify(s, e, Si, Ti, p3);
    else modify(s, mid, Si, Ti, p2), modify(mid + 1, e, Si, Ti, p3);
    upt(p);
}
inline pyz ask(const int s, const int e, const int p) {
    pyz res; int l = T[p].l, r = T[p].r;
    if (l == s && r == e) {
        double x, y;
        if (T[p].cn) {
            x = T[p].firX + T[p].addX; y = T[p].firY + T[p].addY;
            res.sumX = x * (r - l + 1) +
                1.0 * (l + r) * (r - l + 1)
                / 2.0;
            res.sumY = y * (r - l + 1) +
                1.0 * (l + r) * (r - l + 1)
                / 2.0;
            res.sumXY = x * y * (r - l + 1) +
                1.0 * (x + y) * (l + r) * (r - l + 1)
                / 2.0 + sumx2(l, r);
            res.sumX2 = sqr(x) * (r - l + 1) +
                x * (l + r) * (r - l + 1) + sumx2(l, r);
            return res;
        }
        res.sumX = T[p].sumX + T[p].addX * (r - l + 1);
        res.sumY = T[p].sumY + T[p].addY * (r - l + 1);
        res.sumXY = T[p].sumXY + T[p].sumX * T[p].addY
            + T[p].sumY * T[p].addX + T[p].addX * T[p].addY * (r - l + 1);
        res.sumX2 = T[p].sumX2 + 2.0 * T[p].addX * T[p].sumX
            + sqr(T[p].addX) * (r - l + 1);
        return res;
    }
    int mid = l + r >> 1, p2 = T[p].lc, p3 = T[p].rc; downdate(p);
    if (e <= mid) res = ask(s, e, p2);
    else if (s >= mid + 1) res = ask(s, e, p3);
    else res = ask(s, mid, p2) + ask(mid + 1, e, p3);
    return upt(p), res;
}
inline double trans(const int l, const int r, const pyz res) {
    double x = res.sumX, y = res.sumY, x2 = res.sumX2, xy = res.sumXY;
    return (xy - x * y / (r - l + 1)) / (x2 - x * x / (r - l + 1));
}
int main() {
    int i, op, x, y, u, v; n = read(); m = read();
    for (i = 1; i <= n; i++) X[i] = read();
    for (i = 1; i <= n; i++) Y[i] = read();
    build(1, n, 1);
    while (m--) {
        op = read(); if (op == 2) {
            x = read(); y = read(); u = read(); v = read();
            change(x, y, u, v, 1);
        }
        else if (op == 3) {
            x = read(); y = read(); u = read(); v = read();
            modify(x, y, u, v, 1);
        }
        else {
            x = read(); y = read();
            printf("%.10lf\n", trans(x, y, ask(x, y, 1)));
        }
    }
    return 0;
}
====
```

---

## 作者：银河AI (赞：2)

### 解题思路

题解里怎么都是线段树的题解？

分块没有排面了（惨）。

要做出来这道题，有三个需要解决的点：

**1.要维护什么**

其实和线段树一样，分块也需要维护一些东西，那么需要维护什么呢？下面进行推导:

$\begin{aligned}
a &=\frac{\sum\limits^R_{i=L}(x_i-\bar x)(y_i-\bar y)}{\sum\limits^R_{i=L}(x_i-\bar x)^2}\\
     &=\frac{\sum\limits^R_{i=L}x_iy_i - \sum\limits^R_{i=L}x_i \bar y-\sum\limits^R_{i=L}y_i\bar x +\sum\limits^R_{i=L}\bar x\bar y}{\sum\limits^R_{i=L}x_i^2 -\sum\limits^R_{i=L}2x\bar x+\sum\limits^R_{i=L} \bar x^2}
\end{aligned}$

因为 $\bar y$ 和 $\bar x$ 是定值，我们设 $s=r-l+1$，用 $\sum$ 来表示 $\sum\limits^R_{i=L}$ 则有：

$\begin{aligned}
a &=\frac{\sum x_iy_i-\bar y\sum x_i-\bar x\sum y_i+s\bar x\bar y}{\sum x_i^2-2\bar x\sum x_i+s\bar x^2}\\
\because \bar x &= \frac{1}{s}\sum x_i\\
\bar y &=\frac{1}{s}\sum y_i\\
\end{aligned}$

将 $\bar x$ 和 $\bar y$ 代入 $a$，有：

$\begin{aligned}
  a &=\frac{\sum x_iy_i-\frac{2\sum x_i\sum y_i}{s}+\frac{s\sum x_i \sum y_i}{s}}{\sum x_i^2-\frac{2\sum x_i\sum x_i}{s}+\frac{\sum x_i\sum x_i}{s}}\\
  &=\frac{s\sum x_iy_i-\sum x_i\sum y_i}{s\sum x_i^2-\sum x_i\sum y_i}
\end{aligned}$

故知，我们只需要维护 $\sum x_i y_i$，$\sum x_i$，$\sum y_i$ 和 $\sum x_i^2$。

接下来我们就要解决区间增加的问题了。

**2.区间增加的注意事项**

其实跟普通的分块区间增加差不多。

但是这里要用到两个懒标记：

$lazyx$ 和 $lazyy$

分别代表 $x$ 的 $lazy$ 和 $y$ 的 $lazy$。

对于 $\sum x_i^2$ 和 $\sum x_iy_i$，为了减小常数，我们考虑 $O(1)$操作。

$\sum (x_i+s)(y_i+t)=\sum x_i y_i+sy_i+tx_i+(r-l+1)st$

$\sum (x_i+s)^2= \sum x_i^2+2s\sum x_i+(r-l+1)s^2$

然后再更新 $\sum x_i$ 和 $\sum y_i$

这里要注意维护的先后顺序。

**3.区间更新的注意事项**

跟上面一样

我们也需要用到两个懒标记

$layx$ 和 $layy$

分别代表 $x$ 和 $y$ 更新的懒标记，是需要覆盖的，而不是像 $lazyx$ 和 $lazyy$ 那样增加。

同样，我们也需要 $O(1)$ 的操作来减小常数。

这里给出维护顺序。

更新 $\sum x_iy_i$：

- $\sum (s+i)(t+i)=(r-l+1)st+(s+t)(l+r)(l+r-1)/2+r(r+1)(2r+1)/6-l(l-1)(2l-1)/6$

更新 $\sum x_i^2$:

- $\sum(s+i)^2=(r-l+1)s^2+s(l+r)(r-l+1)+r(r+1)(2r+1)/6-l(l-1)(2l-1)/6$

更新 $\sum x_i$:

- $\sum (s+i)=(r-l+1)s+(l+r)(r-l+1)/2$

更新 $\sum y_i$:

- $\sum (t+i)=(r-l+1)t+(l+r)(r-l+1)/2$

需要注意的是，如果整个块都更新了，那么这个块的 $lazyx$ 和 $lazyy$ 都要被清零。

思路已经讲的差不多了，其实说白了就是更新的地方麻烦，其他都是板子，代码就不放出来了，如果需要的话我再更新。

---

## 作者：Night_Aurora (赞：2)

我们先化简一下式子

 ![](https://cdn.luogu.com.cn/upload/pic/5759.png) 

化简为 ![](https://cdn.luogu.com.cn/upload/pic/5761.png)

其中XY=xi\*yi,L<=i<=R

XX=xi\*xi,L<=i<=R

以及两个头顶直线的分别是区间内x和y的平均数

那么我们就可以通过线段树维护这四个值

顺便维护一下x和y的和

对于仅有的两个区间修改，一个比一个难搞

假设看得人都会懒标记，那么我们的问题就是两个标记的相斥性和快速维护要维护的值

很明显2,3懒标记都在时先下置3再下置2

所以完整区间2操作时不用管3操作

完整区间3操作要清空2操作

还有维护区间的一些值

对于2操作，x，y的和以及平均数怎么维护就不唠叨了

 ![](https://cdn.luogu.com.cn/upload/pic/5762.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/5763.png) 

其中Xs和Ys分别是修改前区间的x和y和，式子里的XX和XY也是修改前的，l照样是区间长度

对于3操作就开始有难度了

 ![](https://cdn.luogu.com.cn/upload/pic/5764.png) 

Ys的维护也基本相同，平均数就不用说了

 ![](https://cdn.luogu.com.cn/upload/pic/5766.png) 

后面两个表示平方前缀和(1^2+2^2+3^2+....n^2)

最后最难的是XY的维护

 ![](https://cdn.luogu.com.cn/upload/pic/5767.png) 

其中以上式子里的变量都是修改前的

这样我们要死要死的正确维护出题人乱修改以后，就能基本准确的A掉每个测试点了












```cpp
#include <stdio.h>
#include <string.h>
typedef double FLT;
FLT Nx[110000],Ny[110000];
int N,M;
typedef struct LTRee
{
    FLT XY,XX;
    FLT Xs,Ys;
    FLT Xb,Yb;
    FLT Xp,Yp;
    FLT Xt,Yt;
    bool Sigp,Sigt;
    int F,T,M;
    LTRee*R,*L;
    void MakeTree(int Fr,int To);
    void Update();
    void Update2(FLT s,FLT t);
    void Update3(FLT s,FLT y);
    void Down2();
    void Down3();
    void Operator2(int,int,FLT,FLT);
    void Operator3(int,int,FLT,FLT);
    void Queries(int,int,FLT&,FLT&,FLT&,FLT&);
    FLT Query(int ,int);
}LTR,*LPLTR;
double GetA(FLT len,FLT xs,FLT ys,FLT xx,FLT xy)
{
    FLT fm,fz;
    fz=xy-xs*ys/len;
    fm=xx-xs*xs/len;
    return fz/fm;
}
void LTR::MakeTree(int Fr,int To)
{
    F=Fr,T=To;
    M=(F+T)>>1;
    Xp=Yp=Xt=Yt=Sigt=Sigp=0;
    if(F==T)
    {
        Xs=Xb=Nx[F];
        Ys=Yb=Ny[F];
        XY=Xs*Ys;
        XX=Xs*Xs;
        return;
    }
    L=new LTR;
    R=new LTR;
    L->MakeTree(Fr,M);
    R->MakeTree(M+1,To);
    Update();
}
void LTR::Update()
{
    Xs=L->Xs+R->Xs;
    Ys=L->Ys+R->Ys;
    Xb=Xs/(R-L+1);
    Yb=Ys/(R-L+1);
    XY=L->XY+R->XY;
    XX=L->XX+R->XX;
}
void LTR::Update2(FLT s,FLT t)
{
    XX=XX+2*s*Xs+s*s*(T-F+1);
    XY=XY+t*Xs+s*Ys+t*s*(T-F+1);
    Xs+=(T-F+1)*s;
    Ys+=(T-F+1)*t;
    Xb+=s;
    Yb+=t;
    Xp+=s;
    Yp+=t;
    Sigp=1;
}
void LTR::Update3(FLT s,FLT t)
{
    FLT bl=T-F+1;
    Xs=bl*(s+F-1)+(bl+1)*bl/2;
    Ys=bl*(t+F-1)+(bl+1)*bl/2;
    Xb=Xs/bl;
    Yb=Ys/bl;
    bl=s+T;
    XX=((2*bl+3)*bl+1)*bl;
    bl=s+F-1;
    XX-=((2*bl+3)*bl+1)*bl;
    XX/=6;
    bl=T-F+1;
    XY=bl*F*F+F*((s+t)*bl+bl*(bl-1));
    XY=XY+s*t*bl+(s+t)*(bl*(bl-1))/2+((2*bl+1)*(bl-1)+1)*(bl-1)/6;
    Xt=s;
    Yt=t;
    Sigt=1;
}
void LTR::Down2()
{
    L->Operator2(F,M,Xp,Yp);
    R->Operator2(M+1,T,Xp,Yp);
    Xp=Yp=0;
    Sigp=0;
}
void LTR::Down3()
{
    L->Operator3(F,M,Xt,Yt);
    R->Operator3(M+1,T,Xt,Yt);
    Xt=Yt=0;
    Sigt=0;
}
void LTR::Operator2(int Fr,int To,FLT s,FLT t)
{
    if(F==Fr&&T==To)
    {
        Update2(s,t);
        return;
    }
    if(Sigt)
        Down3();
    if(Sigp)
        Down2();
    if(To<=M)
        L->Operator2(Fr,To,s,t);
    else if(Fr>M)
        R->Operator2(Fr,To,s,t);
    else
    {
        L->Operator2(Fr,M,s,t);
        R->Operator2(M+1,To,s,t);
    }
    Update();
}
void LTR::Operator3(int Fr,int To,FLT s,FLT t)
{
    if(F==Fr&&T==To)
    {
        if(Sigp)
        {
            Sigp=0;
            Xp=Yp=0;
        }
        Update3(s,t);
        return;
    }
    if(Sigt)
        Down3();
    if(Sigp)
        Down2();
    if(To<=M)
        L->Operator3(Fr,To,s,t);
    else if(Fr>M)
        R->Operator3(Fr,To,s,t);
    else
    {
        L->Operator3(Fr,M,s,t);
        R->Operator3(M+1,To,s,t);
    }
    Update();
}
void LTR::Queries(int Fr,int To,FLT&xs,FLT&ys,FLT&xx,FLT&xy)
{
    if(F==Fr&&T==To)
    {
        xs=Xs;
        ys=Ys;
        xx=XX;
        xy=XY;
        return;
    }
    if(Sigt)
        Down3();
    if(Sigp)
        Down2();
    if(To<=M)
        L->Queries(Fr,To,xs,ys,xx,xy);
    else if(Fr>M)
        R->Queries(Fr,To,xs,ys,xx,xy);
    else
    {
        FLT a,b,c,d;
        L->Queries(Fr,M,xs,ys,xx,xy);
        R->Queries(M+1,To,a,b,c,d);
        xs+=a;
        ys+=b;
        xx+=c;
        xy+=d;
    }
}
FLT LTR::Query(int Fr,int To)
{
    double xs,ys,xx,xy;
    Queries(Fr,To,xs,ys,xx,xy);
    return GetA(To-Fr+1,xs,ys,xx,xy);
}
LPLTR Root;
void Input()
{
    scanf("%d %d",&N,&M);
    int wi;
    for(wi=1;wi<=N;++wi)
        scanf("%lf",Nx+wi);
    for(wi=1;wi<=N;++wi)
        scanf("%lf",Ny+wi);
    Root=new LTR;
    Root->MakeTree(1,N);
}
void AC()
{
    int wi,op,F,T;
    FLT s,t;
    for(wi=1;wi<=M;++wi)
    {
        scanf("%d %d %d",&op,&F,&T);
        if(op^1)
            scanf("%lf %lf",&s,&t);
        if(op==1)printf("%.9lf\n",Root->Query(F,T));
        if(op==2)Root->Operator2(F,T,s,t);
        if(op==3)Root->Operator3(F,T,s,t);
    }
}
int main()
{
    Input();
    AC();
    return 0;
}
```

---

## 作者：kbtyyds (赞：0)

# P3707 题解

- [题目链接](https://www.luogu.com.cn/problem/P3707)

- [更好的阅读体验](https://www.luogu.com.cn/blog/453059/solution-p3707)

2023/1/1 upd：才发现写错了题号，修改后于是再交一遍。

## 1. 分析

拿到这个题我们看到题目要支持区间修改及区间查询，考虑线段树。

## 2. 推式子

### 2.1 不带修改

先推一下答案式子（以下用 $\sum$ 代替 $\sum_{i=L}^R$，以 $n$ 代替 $(r-l+1)$）：

$$a=\frac{\sum (x_i-\overline x)(y_i-\overline y)}{\sum(x_i-\overline x)^2}$$

对分子和分母分别计算：

$$\begin{aligned}\text{分子}&=\sum(x_i-\overline x)(y_i-\overline y)\\&=\sum x_i y_i-\overline x\sum y_i-\overline y\sum x_i+n(\overline x\cdot\overline y)\\&=\sum x_i y_i-\frac 1 n\sum x_i\sum y_i-\frac 1 n\sum y_i\sum x_i+\frac n {n^2}\sum x_i\sum y_i\\&=\sum x_i y_i-\frac 1 n\sum x_i\sum y_i\end{aligned}$$

$$\begin{aligned}\text{分母}&=\sum(x_i-\overline x)^2\\&=\sum x_i^2-2\overline x\sum x_i+n\cdot(\overline x)^2\\&=\sum x_i^2-\frac 2 n(\sum x_i)^2+\frac n {n^2}(\sum x_i)^2\\&=\sum x_i^2-\frac 1 n(\sum x_i)^2\end{aligned}$$

综上所述，我们需要维护 $\sum x_i y_i,\sum x_i^2,\sum x_i,\sum y_i$ 的值。

### 2.2 带修改

#### 2.2.1 区间加

首先维护区间懒标记 `tagx` 和 `tagy`，分别表示 $x$ 和 $y$ 加的值。

简单推一下修改后的式子：

$$\begin{aligned}\sum(x_i+s)(y_i+t)&=\sum x_i y_i+s\sum y_i+t\sum x_i+nst\\\sum (x_i+s)^2&=\sum x_i^2+2s\sum x_i+ns^2\\\sum (x_i+s)&=\sum x_i+ns\\\sum (y_i+t)&=\sum y_i+nt\end{aligned}$$

懒标记自己加一下就好了。

上代码~
```cpp
inline void pushadd(int o,int l,int r,long double s,long double t)
{
    tagx[o]+=s,tagy[o]+=t;
    int len=r-l+1;
    xy[o]+=s*y[o]+t*x[o]+len*s*t;
    x2[o]+=2*s*x[o]+len*s*s;
    x[o]+=len*s;
    y[o]+=len*t;
}
```

#### 2.2.2 区间赋值

可以发现该操作可以分成两个操作：

1. $x_i\leftarrow i,y_i\leftarrow i$
1. $x_i\leftarrow x_i+s,y_i\leftarrow y_i+t$

第 2 部分就是 2.2.1 提到的区间加，现在只要处理第 1 部分。

也~~简单~~推一下式子：

$$\begin{aligned}\sum x_i y_i&=\sum x_i^2=\sum i^2=f(r)-f(l-1)\\\sum x_i&=\sum y_i=\frac {(l+r)(r-l+1)} 2\end{aligned}$$

其中 $f(x)=\sum\limits_{i=1}^x i^2=\dfrac {x(x+1)(2x+1)} 6$，读者自证不难。

还是放一个证明[链接](https://www.luogu.com.cn/paste/bzlo6mej)吧 QAQ

这部分的代码如下：

```cpp
inline int f(int x)
{
	return (x*(x+1)>>1)*(x<<1|1)/3;//迷之卡常
}
inline int get(int l,int r)
{
	return f(r)-f(l-1);
}
inline void pushcov(int o,int l,int r)
{
    cov[o]=1;
    tagx[o]=tagy[o]=0;
    xy[o]=x2[o]=get(l,r);
    x[o]=y[o]=((l+r)*(r-l+1))/2.0;
}
```

## 3. 细节

因为赋值就直接赋值，所以要把之前的加法懒标记全部清空。

同时，要先执行赋值，再执行区间加。

## 4. 代码

[云剪切板](https://www.luogu.com.cn/paste/9pqkqj2s)

---

## 作者：Erina (赞：0)

下面吐槽几句

被这道题搞的差点爆炸......拿了0分之后不知道怎么办,瞎搞了半天......之后发现必须要用double,之后改了一会double,然后一直过不去,之后听说能__int128水过......

进入正题.

首先,线段树是干什么的?

维护**具有区间可加性的序列问题的区间修改,区间查询**

然后看一看那个令人窒息的式子$\frac{\sum_{i=L}^{R}(x_i-\overline{x})(y_i-\overline{y})}{\sum_{i=L}^{R}(x_i-\overline{x})^2}$.

一眼就知道**不**满足区间可加性,于是就开始一波骚操作,把这个式子用**满足区间可加性的东西表达出来**

原式=$\frac{\sum_{i=L}^{R}(x_iy_i-\overline{x}y_i-\overline{y}x_i+\overline{x}\overline{y})}{\sum_{i=L}^{R}(x_i^2-2\overline{x}\sum_{i=L}^{R}x_i+\sum_{i=L}^{R}{\overline{x}^2})}$

其中$\overline{x},\overline{y}$都是~~炒鸡容易处理的~~常数,剩下的就有区间可加性了.

那么只需要维护$\sum_{i=L}^{R}x_i,\sum_{i=L}^{R}y_i,\sum_{i=L}^{R}x_iy_i,\sum_{i=L}^{R}x_i^2$就可以了

区间加方法不难,其他的题解也有提过,就不再赘述了......

主要是区间赋值操作.

首先是一个公式:$1^2+2^2+3^2......+n^2=\frac{n(n+1)(2n+1)}{6}$

证明如下:

首先, 当$n=1$时不难证明.

对于$∀n>1$$n(n+1)(2n+1)-(n-1)n(2n-1)=6n^2$

然后......就没有然后了......

先干掉tag.

之后把操作拆分成两个,一个是赋值为[l,r],另一个是(+s,+t),也就是第一个操作

这题下传标记其实没有想象中的那么难,一定要记住:线段树的值一定是正确的,打标时操作.

下面是~~简短的~~代码

```cpp
#include <iomanip>
#include <iostream>
#include <tuple>
#define mid ((l + r) >> 1)
using namespace std;
typedef tuple<__int128, __int128, __int128, __int128> dat; //x,y,xy,x^2
dat tree[400005];
__int128 atx[400005], aty[400005], upd[400005], aa[100005], ab[100005];
dat add(dat a, dat b) { return dat(get<0>(a) + get<0>(b), get<1>(a) + get<1>(b), get<2>(a) + get<2>(b), get<3>(a) + get<3>(b)); }
void w(__int128 x)
{
	if (x < 0)
		putchar('-'), x = -x;
	if (x >= 10)
		w(x / 10);
	putchar(x % 10 + 48);
}
inline char gc()
{
	static char bb[1000000], *s = bb, *t = bb;
	return s == t && (t = (s = bb) + fread(bb, 1, 1000000, stdin), s == t) ? EOF : *s++;
}
inline __int128 read()
{
	int x = 0, w = 1;
	char ch = gc();
	while (ch < 48)
		w = ((ch == '-') ? -1 : 1), ch = gc();
	while (ch >= 48)
		x = x * 10 + ch - 48, ch = gc();
	return x * w;
}
void push_up(__int128 x) { tree[x] = add(tree[x << 1], tree[x << 1 | 1]); }
void fxa(__int128 x, __int128 a, __int128 b, __int128 l, __int128 r)
{
	atx[x] += a, aty[x] += b;
	get<3>(tree[x]) += 2 * a * get<0>(tree[x]) + (r - l + 1) * a * a;
	get<2>(tree[x]) += a * get<1>(tree[x]) + b * get<0>(tree[x]) + a * b * (r - l + 1);
	get<1>(tree[x]) += (r - l + 1) * b, get<0>(tree[x]) += (r - l + 1) * a;
}
void fxb(__int128 x, __int128 l, __int128 r)
{
	upd[x] = 1, atx[x] = aty[x] = 0;
	get<0>(tree[x]) = get<1>(tree[x]) = ((l + r) * (r - l + 1)) >> 1, get<2>(tree[x]) = get<3>(tree[x]) = (r * (r + 1) * ((r << 1) + 1) - (l - 1) * l * ((l << 1) - 1)) / 6;
}
void build(__int128 id, __int128 l, __int128 r)
{
	if (l == r)
		tree[id] = dat(aa[l], ab[l], aa[l] * ab[l], aa[l] * aa[l]);
	else
		build(id << 1, l, mid), build(id << 1 | 1, mid + 1, r), push_up(id);
}
void push_down(__int128 id, __int128 l, __int128 r)
{
	if (upd[id])
		fxb(id << 1, l, mid), fxb(id << 1 | 1, mid + 1, r);
	fxa(id << 1, atx[id], aty[id], l, mid), fxa(id << 1 | 1, atx[id], aty[id], mid + 1, r), atx[id] = aty[id] = 0;
	upd[id] = atx[id] = aty[id] = 0;
}
void add(__int128 id, __int128 l, __int128 r, __int128 s, __int128 e, __int128 a, __int128 b)
{
	if (e < l || s > r)
		return;
	if (s <= l && r <= e)
		fxa(id, a, b, l, r);
	else
		push_down(id, l, r), add(id << 1, l, mid, s, e, a, b), add(id << 1 | 1, mid + 1, r, s, e, a, b), push_up(id);
}
void set(__int128 id, __int128 l, __int128 r, __int128 s, __int128 e, __int128 a, __int128 b)
{
	if (e < l || s > r)
		return;
	if (s <= l && r <= e)
		fxb(id, l, r), fxa(id, a, b, l, r);
	else
		push_down(id, l, r), set(id << 1, l, mid, s, e, a, b), set(id << 1 | 1, mid + 1, r, s, e, a, b), push_up(id);
}
dat query(__int128 id, __int128 l, __int128 r, __int128 s, __int128 e)
{
	if (e < l || s > r)
		return dat(0, 0, 0, 0);
	if (s <= l && r <= e)
		return tree[id];
	else
	{
		push_down(id, l, r);
		return add(query(id << 1, l, mid, s, e), query(id << 1 | 1, mid + 1, r, s, e));
	}
}
__int128 n, m;
int main()
{
	n = read(), m = read();
	for (__int128 i = 1; i <= n; i++)
		aa[i] = read();
	for (__int128 i = 1; i <= n; i++)
		ab[i] = read();
	build(1, 1, n);
	for (__int128 i = 1; i <= m; i++)
	{
		__int128 o, x, y, a, b;
		o = read();
		if (o == 1)
		{
			x = read(), y = read();
			dat ans = query(1, 1, n, x, y);
			cout << fixed << setprecision(15) << (get<2>(ans) - (long double)(get<0>(ans) * get<1>(ans)) / (y - x + 1)) / (long double)(get<3>(ans) - (long double)(get<0>(ans) * get<0>(ans)) / (y - x + 1)) << endl;
		}
		if (o == 2)
			x = read(), y = read(), a = read(), b = read(), add(1, 1, n, x, y, a, b);
		if (o == 3)
			x = read(), y = read(), a = read(), b = read(), set(1, 1, n, x, y, a, b);
	}
}
```



---

## 作者：Mario_sz (赞：0)

先化式子。


$$a=\frac {\sum \_{i=L} ^R (x\_i- \overline x)(y\_i- \overline y)} {\sum \_{i=L} ^R (x\_i-\overline x)^2} \\

=\frac {(R-L+1) \sum \_{i=L} ^{R} x\_i y\_i - \sum \_{i=L} ^{R} x\_i \sum \_{i=L} ^{R} y\_i } {(R-L+1) \sum \_{i=L} ^{R} x\_i^2 - (\sum \_{i=L} ^{R} x\_i)^2}$$

其实不用把$\overline x$和$\overline y$化出来就可以搞，但是比较麻烦，如果像上式一样吧$\overline x$和$\overline y$化成$x_i$和$y_i$更好维护。

这样只需要维护4个值：$\sum x_i$，$\sum y_i$，$\sum x_i^2$，$\sum x_i y_i$

以下式子中用$l$代表$R-L+1$

操作2：

①$\sum (x_i+S) (y_i+T)=\sum x_iy_i + S\sum y_i+T\sum x_i+lS$

②$\sum (x_i+S)^2=\sum x_i^2+2S\sum x_i+lS^2$

③$\sum (x_i+S)=\sum x_i+lS$

④$\sum (y_i+T)=\sum y_i+lT$

操作3：

⑤$\sum (S+i)(T+i) = lST +T\sum i+S\sum i+\sum i^2$

⑥$\sum (S+i)^2=lS^2 + 2S\sum i + \sum i^2$

⑦$\sum S+i=lS+\sum i$

⑧$\sum T+i=lT+\sum i$


$\sum i$和$\sum i^2$可以在建树的时候算出来，这样就写一棵有区间加和区间修改的线段树即可了。

注意操作2的顺序，因为①式和②式都要用到未被更新的$\sum x_i$和$\sum y_i$


---


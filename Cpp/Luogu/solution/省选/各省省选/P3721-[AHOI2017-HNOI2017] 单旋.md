# [AHOI2017/HNOI2017] 单旋

## 题目描述

H 国是一个热爱写代码的国家，那里的人们很小去学校学习写各种各样的数据结构。伸展树（splay）是一种数据结构，因为代码好写，功能多，效率高，掌握这种数据结构成为了 H 国的必修技能。有一天，邪恶的“卡”带着他的邪恶的“常数” 来企图毁灭 H 国。“卡” 给 H 国的人洗脑说，splay 如果写成单旋的，将会更快。“卡”称“单旋 splay”为“spaly”。虽说他说的很没道理，但还是有 H 国的人相信了，小 H 就是其中之一，spaly 马上成为他的信仰。而 H 国的国王，自然不允许这样的风气蔓延，国王构造了一组数据，数据由 $m$（不超过 $10^5$）个操作构成，他知道这样的数据肯定打垮 spaly，但是国王还有很多很多其他的事情要做，所以统计每个操作所需要的实际代价的任务就交给你啦。

数据中的操作分为 $5$ 种：

1. 插入操作：向当前非空 spaly 中插入一个关键码为 $key$ 的新孤立节点。插入方法为，先让 $key$ 和根比较，如果 $key$ 比根小，则往左子树走，否则往右子树走，如此反复，直到某个时刻，$key$ 比当前子树根 $x$ 小，而 $x$ 的左子树为空，那就让 $key$ 成为 $x$ 的左孩子；或者 $key$ 比当前子树根 $x$ 大，而 $x$ 的右子树为空，那就让 $key$ 成为 $x$ 的右孩子。该操作的代价为：插入后，$key$ 的深度。特别地，若树为空，则直接让新节点成为一个单个节点的树。（各节点关键码互不相等。对于“深度” 的解释见末尾对 spaly 的描述。）

2. 单旋最小值：将 spaly 中关键码最小的元素 $x \min$ 单旋到根。操作代价为：单旋前 $x \min$ 的深度。（对于单旋操作的解释见末尾对 spaly 的描述。）

3. 单旋最大值：将 spaly 中关键码最大的元素 $x \max$ 单旋到根。操作代价为：单旋前 $x \max$ 的深度。

4. 单旋删除最小值：先执行 $2$ 号操作，然后把根删除。由于 $2$ 号操作之后，根没有左子树，所以直接切断根和右子树的联系即可。（具体见样例解释）。操作代价同 $2$ 号操作。

5. 单旋删除最大值：先执行 $3$ 号操作，然后把根删除。操作代价同 $3$ 号操作。

![](https://cdn.luogu.com.cn/upload/pic/5106.png)

对于不是 H 国的人，你可能需要了解一些 spaly 的知识，才能完成国王的任务：

1. spaly 是一棵二叉树，满足对于任意一个节点 $x$，它如果有左孩子 $lx$，那么 $lx$ 的关键码小于 $x$ 的关键码。如果有右孩子 $rx$，那么 $rx$ 的关键码大于 $x$ 的关键码。

2. 一个节点在 spaly 的深度定义为：从根节点到该节点的路径上一共有多少个节点（包括自己）。

3. 单旋操作是对于一棵树上的节点 $x$ 来说的。一开始，设 $f$ 为 $x$ 在树上的父亲。如果 $x$ 为 $f$ 的左孩子，那么执行 $zig (x)$ 操作（如上图中，左边的树经过 $zig (x)$ 变为了右边的树）, 否则执行 $zag (x)$ 操作（在上图中，将右边的树经过 $zag (f)$ 就变成了左边的树）。每当执行一次 $zig (x)$ 或者 $zag (x)$,$x$ 的深度减小 $1$，如此反复，直到 $x$ 为根。总之，单旋 $x$ 就是通过反复执行 $zig$ 和 $zag$ 将 $x$ 变为根。

## 说明/提示

$20 \%$ 的数据满足： $1 \leq m \leq 1000$。

另外 $30\%$ 的数据满足：不存在 $4,5$ 操作。

$100\%$ 的数据满足：$1 \leq m \leq 10^5,1 \leq key \leq 10^9$。 所有出现的关键码互不相同。 任何一个非插入操作，一定保证树非空。 在未执行任何操作之前，树为空。

## 样例 #1

### 输入

```
5
1 2
1 1
1 3
4 
5```

### 输出

```
1 
2 
2
2 
2```

# 题解

## 作者：老K (赞：12)

[推广我的博客](https://cnyali-lk.com)

这题真是666.

用一个数据结构模拟另一个数据结构。

我们发现：

1. 插入的时候，首先找到它前驱和后继，在spaly中它们显然是连续的，一定有一个是另一个的祖先。那么我们就可以找到深的那个把新节点接在它下面。

2. 单旋最小最大值，就是把它的儿子直接接到父亲上，并且把它取出来，把原树挂在它下面，此时它的子树以外的节点的深度都+1了。

3. 删除最大最小值，就是把它的儿子直接接到父亲上，并把它扔掉，此时它子树中的节点的深度都-1了。

发现点权互不相同，那么我们就能用离散化权值线段树维护深度和计算前驱后继（就是维护关键码为key的节点的深度以及存不存在）

当然也得模拟出这棵树的结构，但是这并没有什么难度。
``` C++
/*
Author: CNYALI_LK
LANG: C++
PROG: 3721.cpp
Mail: cnyalilk@vip.qq.com
*/
#include<bits/stdc++.h>
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define DEBUG printf("Passing [%s] in LINE %d\n",__FUNCTION__,__LINE__)
#define Debug debug("Passing [%s] in LINE %d\n",__FUNCTION__,__LINE__)
#define all(x) x.begin(),x.end()
using namespace std;
const double eps=1e-8;
const double pi=acos(-1.0);
typedef long long ll;
typedef pair<int,int> pii;
template<class T>int chkmin(T &a,T b){return a>b?a=b,1:0;}
template<class T>int chkmax(T &a,T b){return a<b?a=b,1:0;}
template<class T>T sqr(T a){return a*a;}
template<class T>T mmin(T a,T b){return a<b?a:b;}
template<class T>T mmax(T a,T b){return a>b?a:b;}
template<class T>T aabs(T a){return a<0?-a:a;}
#define min mmin
#define max mmax
#define abs aabs
int read(){
	int s=0,base=1;
	char c;
	while(!isdigit(c=getchar()))if(c=='-')base=-base;
	while(isdigit(c)){s=s*10+(c^48);c=getchar();}
	return s*base;
}
char WriteIntBuffer[1024];
template<class T>void write(T a,char end){
	int cnt=0,fu=1;
	if(a<0){putchar('-');fu=-1;}
	do{WriteIntBuffer[++cnt]=fu*(a%10)+'0';a/=10;}while(a);
	while(cnt){putchar(WriteIntBuffer[cnt]);--cnt;}
	putchar(end);
}
int type[102424],lsh[102424],w[102424],t,ds;
struct smt{
	smt *l,*r;
	int cnt,add,_l,_r;
	smt(int l_,int r_){
		_l=l_;_r=r_;
		if(l_!=r_){
			int mid=(_l+_r)>>1;	
			l=new smt(l_,mid);
			r=new smt(mid+1,r_);
		}
		cnt=0;
	}
	void upd(int x,int s){
		cnt+=s;
		if(_l<_r)if(x<r->_l)l->upd(x,s);
		else r->upd(x,s);
	}
	void _add(int l_,int r_,int w){
		if(l_<=_l&&_r<=r_){
			add+=w;
			return;
		} if(l_<=l->_r)l->_add(l_,r_,w);
		if(r_>=r->_l)r->_add(l_,r_,w);
	}
	int prev(int x){
		if((!cnt)||x<_l)return 0;
		if(_l==_r)return _l;
		int s=r->prev(x);
		return s?s:l->prev(x);	
	}
	int next(int x){
		if((!cnt)||_r<x)return 0;
		if(_l==_r)return _l;
		int s=l->next(x);
		return s?s:r->next(x);
	}
	int height(int x){
		if(!x)return 0;
		if(_l==_r)return add;
		if(x<=l->_r)return add+l->height(x);
		else return add+r->height(x);
	}
};
smt *root;
int fa[102424],son[102424][2],ps,_root;
void insert(int x){
	fa[x]=son[x][0]=son[x][1]=0;
	if(!ps){
		root->_add(x,x,1-root->height(x));
		_root=x;
		++ps;
		write(1,'\n');
	}
	else{
		++ps;
		int sl=root->prev(x),sr=root->next(x);
		int hl=root->height(sl),hr=root->height(sr);
		if(hl<hr){
			fa[x]=sr;
			son[sr][0]=x;
			root->_add(x,x,hr+1-root->height(x));

			printf("%d\n",hr+1);
		}
		else{
			fa[x]=sl;
			son[sl][1]=x;
			root->_add(x,x,hl+1-root->height(x));
			printf("%d\n",hl+1);
		}
	}
	root->upd(x,1);
}
void splay_min(){
	int x=root->next(1);
	if(_root==x){printf("1\n");return;}
	else{
		int w;
		printf("%d\n",w=root->height(x));
		root->_add(x,x,1-w);
		son[fa[x]][0]=son[x][1];
		fa[son[x][1]]=fa[x];
		root->_add(fa[x],t,1);
		son[fa[_root]=x][1]=_root;
		_root=x;
	}
}
void splay_max(){
	int x=root->prev(t);
	if(_root==x)printf("1\n");
	else{
		int w=root->height(x);
		printf("%d\n",w);
		root->_add(x,x,1-w);
		son[fa[x]][1]=son[x][0];
		fa[son[x][0]]=fa[x];
		root->_add(1,fa[x],1);
		son[fa[_root]=x][0]=_root;
		_root=x;
	}
}
void remove_min(){
	int x=root->next(1);
	if(x==_root){
		fa[_root=son[x][1]]=0;
		root->_add(1,t,-1);
		printf("1\n");
	}
	else{
		printf("%d\n",root->height(x));
		root->_add(x+1,fa[x]-1,-1);	
		fa[son[x][1]]=fa[x];
		son[fa[x]][0]=son[x][1];
	}

	root->upd(x,-1);
}

void remove_max(){
	int x=root->prev(t);
	if(x==_root){
		fa[_root=son[x][0]]=0;
		root->_add(1,t,-1);
		printf("1\n");
	}
	else{
		printf("%d\n",root->height(x));
		root->_add(fa[x]+1,x-1,-1);	
		fa[son[x][0]]=fa[x];
		son[fa[x]][1]=son[x][0];
	}

	root->upd(x,-1);
}
int main(){
#ifdef cnyali_lk
	freopen("3721.in","r",stdin);
	freopen("3721.out","w",stdout);
#endif
	int n;
	n=read();
	for(int i=n;i;--i){
		type[i]=read();
		if(type[i]==1){
			lsh[++t]=w[i]=read();
		}
	}
	sort(lsh+1,lsh+t+1);
	for(int i=1;i<=n;++i){
		if(type[i]==1){w[i]=lower_bound(lsh+1,lsh+t+1,w[i])-lsh;}
	}
	root=new smt(1,t);

	while(n){
		if(type[n]==1){
			insert(w[n]);
		}
		else if(type[n]==2){
			splay_min();
		}
		else if(type[n]==3){
			splay_max();
		}
		else if(type[n]==4){
			remove_min();
		}
		else{
			remove_max();
		}
		--n;
	}
	return 0;
}


```


---

## 作者：DOTime (赞：11)

标签：线段树+set

题解：

此题的标题为splay，所以我们可以排除这道题的正解是splay的可能性。然后我们发现只有最值的单旋，而且，三点一线不需要先旋转父亲。通过手玩我们可以发现，就是把最值直接移到最顶端作为根节点，然后其他的点以及他们之间的父子关系全部都没有变化。于是就只要求深度了。

我们发现，最小值，他没有左子树，而右子树在单旋之后深度不变（-1+1），而其他的点深度全部+1。如果再删掉根节点，全部的点深度-1。于是就可以使用线段树，维护每一个点的深度。

首先输入所有的操作，对于全部的值进行离散化，然后线段树就是对应离散化之后的点的深度。

最小值x，他的右子树的范围为[x+1,fa]。于是我们对这段区间-1，对全部区间+1。然后将x深度修改为1。最大值类似。如果要删除，全部区间-1。这样就可以解决问题了。

但是我们发现不好插入，具体来说应该是对于x，他的fa不好找，那么我们就记下来。然后在插入的时候，同时插入到set中，利用set来找fa。如果插入的不是最小值，那么可能为右子树，我们就把it--，判断这个点是否有右儿子，如果没有，就找到父亲了。否则，再找（it++）++。这个就是他的父亲，然后标记好。

set的insert()返回一个pair类型，first代表指针，指向插入的位置，second是bool，代表是否已有此元素。

```cpp
<http://www.cnblogs.com/D-O-Time/p/7922491.html>
  1 #include<set>
  2 #include<cstdio>
  3 #include<iostream>
  4 #include<algorithm>
  5 #define ls k*2
  6 #define rs (k*2+1)
  7 using namespace std;
  8 const int MAXN=210000;
  9 int m,sz,root,tp;
 10 int v[MAXN],q[MAXN],op[MAXN];
 11 int dep[MAXN*4],fa[MAXN],ch[MAXN][2];
 12 set<int>st;
 13 inline int gi() { int res; scanf("%d",&res); return res; }
 14 void down(int k)
 15 {
 16   if(!dep[k])return ;
 17   dep[ls]+=dep[k];
 18   dep[rs]+=dep[k];
 19   dep[k]=0;
 20 }
 21 void add(int k,int ll,int rr,int L,int R,int Val)
 22 {
 23   if(ll==L && rr==R) { dep[k]+=Val; return; }
 24   down(k);
 25   int mid=(ll+rr)/2;
 26   if(R<=mid)
 27     add(ls,ll,mid,L,R,Val);
 28   else if(mid<L)
 29     add(rs,mid+1,rr,L,R,Val);
 30   else
 31     {
 32       add(ls,ll,mid,L,mid,Val);
 33       add(rs,mid+1,rr,mid+1,R,Val);
 34     }
 35 }
 36 void modify(int k,int ll,int rr,int p,int Val)
 37 {
 38   if(ll==rr) { dep[k]=Val; return;}
 39   down(k);
 40   int mid=(ll+rr)/2;
 41   if(p<=mid)
 42     return modify(ls,ll,mid,p,Val);
 43   else
 44     return modify(rs,mid+1,rr,p,Val);
 45 }
 46 int query(int k,int ll,int rr,int p)
 47 {
 48   if(ll==rr) return dep[k];
 49   down(k);
 50   int mid=(ll+rr)/2;
 51   if(p<=mid)
 52     return query(ls,ll,mid,p);
 53   else
 54     return query(rs,mid+1,rr,p);
 55 }
 56 int insert(int x)
 57 {
 58   set<int>::iterator it=st.insert(x).first;
 59   if(root==0) {root=x; modify(1,1,tp,x,1); return 1;}
 60   if(it!=st.begin())
 61     {
 62       if(!ch[*--it][1]) ch[fa[x]=*it][1]=x;
 63       it++;
 64     }
 65   if(!fa[x]) ch[fa[x]=*++it][0]=x;
 66   int deep=query(1,1,tp,fa[x])+1;
 67   modify(1,1,tp,x,deep);
 68   return deep;
 69 }
 70 int findmin()
 71 {
 72   int x=*st.begin(),res=query(1,1,tp,x);
 73   if(x==root)return 1;
 74   if(x+1<=fa[x]-1)
 75     add(1,1,tp,x+1,fa[x]-1,-1);
 76   add(1,1,tp,1,tp,1);
 77   ch[fa[x]][0]=ch[x][1];
 78   fa[ch[x][1]]=fa[x];
 79   ch[fa[root]=x][1]=root;
 80   root=x;
 81   modify(1,1,tp,x,1);
 82   return res;
 83 }
 84 void delmin()
 85 {
 86   printf("%d\n",findmin());
 87   add(1,1,tp,1,tp,-1);
 88   st.erase(root);
 89   root=ch[root][1];
 90   fa[root]=0;
 91 }
 92 int findmax()
 93 {
 94   int x=*st.rbegin(),res=query(1,1,tp,x);
 95   if(x==root)return 1;
 96   if(fa[x]+1<=x-1)
 97     add(1,1,tp,fa[x]+1,x-1,-1);
 98   add(1,1,tp,1,tp,1);
 99   ch[fa[x]][1]=ch[x][0];
100   fa[ch[x][0]]=fa[x];
101   ch[fa[root]=x][0]=root;
102   root=x;
103   modify(1,1,tp,x,1);
104   return res;
105 }
106 void delmax()
107 {
108   printf("%d\n",findmax());
109   add(1,1,tp,1,tp,-1);
110   st.erase(root);
111   root=ch[root][0];
112   fa[root]=0;
113 }
114 int main()
115 {
116   scanf("%d",&m);
117   for(int i=1;i<=m;i++)
118     {
119       scanf("%d",&op[i]);
120       if(op[i]==1) q[++tp]=v[i]=gi();
121     }
122   sort(q+1,q+1+tp);
123   for(int i=1;i<=m;i++)
124     if(op[i]==1)
125       v[i]=lower_bound(q+1,q+1+tp,v[i])-q;
126   for(int i=1;i<=m;i++)
127     {
128       if(op[i]==1) { printf("%d\n",insert(v[i])); }
129       else if(op[i]==2) printf("%d\n",findmin());
130       else if(op[i]==3) printf("%d\n",findmax());
131       else if(op[i]==4) delmin();
132       else if(op[i]==5) delmax();
133     }
134 }
```

---

## 作者：埃罗芒阿老师· (赞：6)


可以直接去我博客：<http://www.cnblogs.com/zzmmm/p/7273747.html>

思路{


每次单旋只会取$maxormin$,那么手玩发现,这样树的形态基本不变!


那么我们可以直接把x提上去,这是手动维护Spaly的形态,


我们想怎么统计答案呢?暴力跳显然是会T的,这里实质是查询点到根的距离,


可以考虑使用$LCT$维护,这样就直接查询点到根的路径长度就可以了.


(LCT维护的是无根树!所以每次查询都要把$Spaly$的根搞到$LCT$的总根)


然后直接按照Spaly的方法$Link,Cut$,删除操作同理辣。。。。


插入呢？？？？


由于一个点总是插在其前驱的右儿子或是后继的左儿子.


那么手玩发现,一定插在深度更深的节点中.好,那么先查询后判断,


对于前驱,后继,最小,最大操作,无脑set就行了。。。。。


```cpp
}
#include<bits/stdc++.h>
#define RG register
#define il inline
#define N 1100000
#define inf (1<<30)
using namespace std;
int ch[N][2],fa[N],st[N],sub[N],rt,cnt,c[N][2],f[N],sz[N];bool rev[N];
bool isroot(int x){return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;}
void up(int x){sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+1;return;}
void down(int x){if(rev[x])rev[x]^=1,rev[ch[x][0]]^=1,rev[ch[x][1]]^=1,swap(ch[x][1],ch[x][0]);}
void Rotate(int x){
  int y=fa[x],z=fa[y];
  int l=ch[y][1]==x,r=l^1;
  if(!isroot(y))ch[z][ch[z][1]==y]=x;
  fa[x]=z,fa[y]=x,fa[ch[x][r]]=y;ch[y][l]=ch[x][r];
  ch[x][r]=y;up(y),up(x);
}
void Splay(int x){int top(0),y=x;st[++top]=x;
  while(!isroot(y))st[++top]=fa[y],y=fa[y];
  for(int i=top;i;i--)down(st[i]);
  while(!isroot(x)){
    y=fa[x];int z=fa[y];
    if(!isroot(y)){
      if(ch[z][0]==y^ch[y][0]==x)Rotate(x);
      else Rotate(y);
    }Rotate(x);
  }
}
void access(int x){int t(0);while(x)Splay(x),ch[x][1]=t,t=x,up(x),x=fa[x];}
void makeroot(int x){access(x),Splay(x),rev[x]^=1;}
void link(int x,int y){
  if(!x||!y)return;
  makeroot(x);
  fa[x]=y;
}
void cut(int x,int y){
  if(!x||!y)return;
  makeroot(x),access(y),Splay(y);
  ch[y][0]=fa[x]=0,up(x),up(y);
}
int Query(int x){makeroot(rt),access(x),Splay(x);return sz[x];}
set<int>s;
set<int>::iterator it;
struct ask{int flag,kk;}a[N];
int main(){
  freopen("spaly.in","r",stdin);
  freopen("spaly.out","w",stdout);
  int T;scanf("%d",&T);
  s.insert(-inf),s.insert(inf);
  for(int i=1;i<=T;++i){
    scanf("%d",&a[i].flag);
    if(a[i].flag==1)scanf("%d",&a[i].kk),sub[++sub[0]]=a[i].kk;
  }
  sort(sub+1,sub+sub[0]+1);int szz=unique(sub+1,sub+sub[0]+1)-sub-1;
  for(int i=1;i<=T;++i){
    if(a[i].flag==1){
      a[i].kk=lower_bound(sub+1,sub+szz+1,a[i].kk)-sub;
      if(!cnt){cnt++,rt=a[i].kk,s.insert(rt),printf("1\n");continue;}
      else{
    it=s.upper_bound(a[i].kk);int nxt=*it,deep(0),x;--it;int pre=*it;
    if(pre!=-inf){int now=Query(pre);if(now>deep)deep=now,x=pre;}
    if(nxt!=inf){int now=Query(nxt);if(now>deep)deep=now,x=nxt;}
    printf("%d\n",deep+1);c[x][a[i].kk>x]=a[i].kk,f[a[i].kk]=x;cnt++;link(x,a[i].kk);
    s.insert(a[i].kk);
      }
    }
    if(a[i].flag==2){
      if(cnt==1){printf("1\n");continue;}
      it=s.begin(),++it;int x=*it,y=c[x][1],z=f[x],k=Query(x);
      if(rt!=x){
    cut(x,z),cut(x,y),link(x,rt),link(z,y);
    f[x]=0,c[x][1]=rt,f[rt]=x,rt=x,c[z][0]=y,f[y]=z;
      }
      printf("%d\n",k);
    }
    if(a[i].flag==3){
      if(cnt==1){printf("1\n");continue;}
      it=s.end(),--it,--it;int x=*it,y=c[x][0],z=f[x],k=Query(x);
      if(rt!=x){
    cut(x,z),cut(x,y),link(x,rt);link(z,y);
    f[x]=0,c[x][0]=rt,f[rt]=x,rt=x,c[z][1]=y;
    f[y]=z;
      }printf("%d\n",k);
    }
    if(a[i].flag==4){
      if(cnt==1){cnt--;printf("1\n"),s.erase(s.find(rt)),rt=0;continue;}
      it=s.begin(),++it;int x=*it,y=c[x][1],z=f[x],k=Query(x);
      cut(x,z),cut(x,y);
      link(y,z);
      cnt--;s.erase(s.find(x));
      if(x==rt)rt=y;
      c[x][0]=c[x][1]=f[x]=0,c[z][0]=y,f[y]=z;
      printf("%d\n",k);
    }
    if(a[i].flag==5){
      if(cnt==1){cnt--;printf("1\n"),s.erase(s.find(rt)),rt=0;continue;}
      it=s.end(),--it,--it;int x=*it,y=c[x][0],z=f[x],k=Query(x);
      cut(x,z),cut(x,y);link(y,z);cnt--;s.erase(s.find(x));
      printf("%d\n",k);if(x==rt)rt=y;
      c[x][0]=c[x][1]=f[x]=0,c[z][1]=y,f[y]=z;
    }
  }
  return 0;
}
```

---

## 作者：EnofTaiPeople (赞：5)

这是一道神题，需要我们手玩来发现性质。

发现单旋最小值的过程有一条长链不会改变，这就是 Spaly 的错误之处。事实上，这是一个断边连边的流程：
1. 将他的右儿子接到他的父亲；
2. 断掉自己的所有联系；
3. 将当前的树根作为自己的左儿子。

最大值同理，现在可以开始做题了。

先将所有询问读入，将数值离散化，维护一个 set 表示当前 Spaly 中的节点，插入时将其接到前驱后继深度更大的一个就可以了。
```cpp
for(x=1;x<=q;++x){
	read(qr[x][0]);
	if(qr[x][0]==1)read(qr[x][1]),mp[++mt]=qr[x][1];
	}sort(mp+1,mp+mt+1);
for(x=1;x<=q;++x)
	qr[x][1]=lower_bound(mp+1,mp+mt+1,qr[x][1])-mp;
```

至于父子关系和深度，只需要使用 Splay 维护实链并记录子树大小，当实链打通到根节点时，Splay 的大小就是深度。
```cpp
#define tp(x) (t[f[x]][1]==x)
#define in(x) (t[f[x]][0]==x||tp(x))
#define ls t[x][0]
#define rs t[x][1]
inline void pp(int x){
	sz[x]=sz[ls]+sz[rs]+1;
}
inline void rot(int x){
	int y=f[x],k=tp(x),w=t[x][!k];
	t[x][!k]=y,t[y][k]=w;
	if(in(y))t[f[y]][tp(y)]=x;
	f[x]=f[y],f[f[w]=y]=x,pp(y);
}
inline void splay(int x){
	for(int y=f[x];in(x);rot(x),y=f[x])
		if(in(y))rot(tp(x)^tp(y)?x:y);pp(x);
}
inline void access(int x){
	for(int y=0;x;x=f[y=x])
		splay(x),rs=y,pp(x);
}
inline int dep(int x){
	if(!x)return 0;
	access(x);
	splay(x);
	return sz[x];
}
```
[LOJ 的 AC记录](https://loj.ac/s/1534334)

---

## 作者：gorokokoro (赞：4)

其实……树状数组也是可以的。

插入实际上就是在前驱后继中选出深度较大的点将自己连在它下面。至于如何连接稍后描述。

其他题解都讲得很清楚了，单旋 $\min$ 或 $\max$ 到根实际上就是把最值放到根然后嫁接最值原来的儿子。

设需要单选的 $\min$ 值或者 $\max$ 值为 $x$ 。

考虑如何进行把嫁接，我们可以维护每个结点的两个儿子和父亲。

将 $x$ 放到根之后，除了 $x$ 原子树的点的深度都需要 $+1$ 。这个操作相当于区间 $+1$（$x$ 的子树代表着连续的区间），树状数组实现。

单旋并删除 / 插入是单点 $\mathrm{set}$ 操作，采用树状数组单点加的方法实现。

时间复杂度 $\mathrm O(M\log N)$ 。

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <vector>
#include <set>
#define N 100020
using namespace std;

int a[N], b[N];
vector<int> v;
set<int> f;
int g[N];
int s[N][2], p[N];

inline int Lowbit(int x)
{
    return x & -x;
}

void AddFenwick(int x, int v)
{
    for(; x <= (signed)::v.size(); x += Lowbit(x))
        g[x] += v;

    return;
}

int SumFenwick(int x)
{
    int o;

    for(o = 0; x; x -= Lowbit(x))
        o += g[x];

    return o;
}

void AddChunk(int l, int r, int v)
{
    AddFenwick(l    ,  v);
    AddFenwick(r + 1, -v);

    return;
}

int main(void)
{
    int m;
    int i, r, t, o;
    set<int>::iterator x, y;

    scanf("%d", &m);
    for(i = 1; i <= m; i ++)
    {
        scanf("%d", &a[i]);
        if(a[i] == 1)
        {
            scanf("%d", &b[i]);
            v.push_back(b[i]);
        }
    }
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());

    for(i = 1; i <= m; i ++)
        if(a[i] == 1)
        {
            b[i] = lower_bound(v.begin(), v.end(), b[i]) - v.begin() + 1;

            if(!f.empty())
            {
                y = f.upper_bound(b[i]);
                if(y == f.begin())
                {
                    o = SumFenwick(*y) + 1;
                    s[*y][0] = b[i];
                    p[b[i]] = *y;
                }
                else if(y == f.end())
                {
                    x = -- y;
                    o = SumFenwick(*x) + 1;
                    s[*x][1] = b[i];
                    p[b[i]] = *x;
                }
                else
                {
                    x = y;
                    x --;
                    if(SumFenwick(*y) > SumFenwick(*x))
                    {
                        o = SumFenwick(*y) + 1;
                        s[*y][0] = b[i];
                        p[b[i]] = *y;
                    }
                    else
                    {
                        o = SumFenwick(*x) + 1;
                        s[*x][1] = b[i];
                        p[b[i]] = *x;
                    }
                }
            }
            else
            {
                r = b[i];
                o = 1;
            }
            AddChunk(b[i], b[i], o - SumFenwick(b[i]));
            printf("%d\n", o);
            f.insert(b[i]);
        }
        else if(a[i] == 2)
        {
            t = *f.begin();
            printf("%d\n", SumFenwick(t));
            AddChunk(t, t, 1 - SumFenwick(t));
            if(p[t])
            {
                AddChunk(p[t], v.size(), 1);
                s[p[t]][0] = s[t][1];
                if(s[t][1])
                    p[s[t][1]] = p[t];
                p[t] = 0;
                s[t][1] = r;
                p[r] = t;
                r = t;
            }
        }
        else if(a[i] == 3)
        {
            t = *f.rbegin();
            printf("%d\n", SumFenwick(t));
            AddChunk(t, t, 1 - SumFenwick(t));
            if(p[t])
            {
                AddChunk(1, p[t], 1);
                s[p[t]][1] = s[t][0];
                if(s[t][0])
                    p[s[t][0]] = p[t];
                p[t] = 0;
                s[t][0] = r;
                p[r] = t;
                r = t;
            }
        }
        else if(a[i] == 4)
        {
            t = *f.begin();
            printf("%d\n", SumFenwick(t));
            AddChunk(t, t, 1 - SumFenwick(t));
            if(p[t])
            {
                AddChunk(p[t], v.size(), 1);
                s[p[t]][0] = s[t][1];
                if(s[t][1])
                    p[s[t][1]] = p[t];
                p[t] = 0;
                s[t][1] = r;
                p[r] = t;
                r = t;
            }

            r = s[t][1];
            p[r] = 0;
            AddChunk(1, v.size(), -1);
            f.erase(t);
        }
        else
        {
            t = *f.rbegin();
            printf("%d\n", SumFenwick(t));
            AddChunk(t, t, 1 - SumFenwick(t));
            if(p[t])
            {
                AddChunk(1, p[t], 1);
                s[p[t]][1] = s[t][0];
                if(s[t][0])
                    p[s[t][0]] = p[t];
                p[t] = 0;
                s[t][0] = r;
                p[r] = t;
                r = t;
            }

            r = s[t][0];
            p[r] = 0;
            AddChunk(1, v.size(), -1);
            f.erase(t);
        }

    return 0;
}

```

---

## 作者：cunzai_zsy0531 (赞：3)

[题目链接](https://www.luogu.com.cn/problem/P3721)

这是一道很有意思的题……用一个数据结构维护另一个数据结构……

先考虑这个题的答案，也就是深度如何维护？作为 `LCT` 练习题单中的一道题，很容易想到用 `LCT` 维护链上点数，这样每个点的深度就可以把这个点和根 `split`出来，直接返回这个点的 `siz` 就行了。

然后，考虑到需要找整棵树的最小点和最大点，所以使用 `set` 来维护整棵树中存在的点，找最小和最大就调用 `t.begin()` 和 `t.end()` 即可。（注意 `end()` 是开的，需要 `--it` 才能找到最大的元素）

考虑剩下四个操作树的形态会发生哪些变化：

2、3操作：把最小的或者最大的数移到根。以最小的为例：设这个点为 $x$，这个点一定没有左儿子，右儿子为 $u$，父亲为 $v$，根为 $rt$，那么需要做的操作是 `cut(x,u),cut(x,v),link(u,v),link(x,rt)`。这个大家画个图就理解了。那么有一个问题，如何找到这个 $u$ 和 $v$ 呢？需要用数组模拟一下原树的结构，在插入、旋转和删除的时候更新一下即可，具体细节看代码。

4、5操作：移到根之后要删除，所以最后那个 `link(x,rt)` 就不需要做了。

总体来说，这个方法码量较大，对码力要求较高且难调，如果有其他更好方法，不建议使用……但是如果真的想练习 `LCT`，本题不失为一道好题。

最后放上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<set>
#include<algorithm>
using namespace std;
inline void swap(int &x,int &y){x^=y^=x^=y;}
inline int max(const int &a,const int &b){return a>b?a:b;}
const int N=1e5+13;
struct Lct{
	struct Stack{
		int s[N],t;
		inline void clear(){t=0;}
		Stack(){clear();}
		inline void push(int x){s[++t]=x;}
		inline void pop(){--t;}
		inline int top(){return s[t];}
		inline bool empty(){return !t;}
	};
	int fa[N],siz[N],ch[N][2];bool tag[N];
	inline void refresh(int x){siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+1;}
	inline bool isroot(int x){return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;}
	inline bool chk(int x){return ch[fa[x]][1]==x;}
	inline void rotate(int x){
		int f=fa[x],gf=fa[f],k=chk(x),w=ch[x][k^1];
		fa[x]=gf;if(!isroot(f)) ch[gf][chk(f)]=x;
		if(w) fa[w]=f;ch[f][k]=w;
		fa[f]=x;ch[x][k^1]=f;
		refresh(f),refresh(x);
	}
	inline void pushdown(int x){
		if(!tag[x]) return;
		tag[ch[x][0]]^=1,tag[ch[x][1]]^=1,tag[x]=0;
		swap(ch[x][0],ch[x][1]);
	}
	inline void splay(int x){
		Stack st;int p=x;
		while(!isroot(p)) st.push(p),p=fa[p];
		st.push(p);
		while(!st.empty()) pushdown(st.top()),st.pop();
		while(!isroot(x)){
			int f=fa[x];
			if(!isroot(f)){
				if(chk(f)==chk(x)) rotate(f);
				else rotate(x);
			}
			rotate(x);
		}
	}
	inline void access(int x){
		for(int p=0;x;p=x,x=fa[x]) splay(x),ch[x][1]=p,refresh(x);
	}
	inline void makeroot(int x){access(x);splay(x);tag[x]^=1;}
	inline int findroot(int x){
		access(x);splay(x);
		while(ch[x][0]) x=ch[x][0];
		return x;
	}
	inline void split(int x,int y){makeroot(x);access(y);splay(y);}
	inline void link(int x,int y){
		if(!x||!y) return;
		makeroot(x);
		fa[x]=y;
	}
	inline void cut(int x,int y){
		if(!x||!y) return;
		split(x,y);
		ch[y][0]=fa[x]=0,refresh(x),refresh(y);
	}
	inline int finddep(int x,int y){//对每一个点找深度 
		split(x,y);
		return siz[y];
	}
}T;
int m,tot,rt,op[N],a[N],b[N],Cnt,f[N],c[N][2];
set<int> t;
set<int>::iterator it;
int main(){
//	freopen("splay1.in","r",stdin);
//	freopen("splay.out","w",stdout);
	scanf("%d",&m);
	for(int i=1;i<=m;++i) T.siz[i]=1;
	for(int i=1;i<=m;++i){
		scanf("%d",&op[i]);
		if(op[i]==1) scanf("%d",&a[i]),b[++tot]=a[i];
	}
	sort(b+1,b+tot+1);tot=unique(b+1,b+tot+1)-b-1;
	for(int i=1;i<=m;++i){
		switch(op[i]){
			case 1:{
				int x=lower_bound(b+1,b+tot+1,a[i])-b;
				int pre=0,suf=0;
				if(!Cnt){//注意特判，这个题因为涉及到边界的地方很多，所以需要很多特判 
					t.insert(x);rt=x;
					puts("1");++Cnt;
					continue;
				}
				t.insert(x);it=t.find(x);++Cnt;
				if(it!=t.begin()) pre=*(--it),++it;//找前驱和后继的set操作不太一样，要注意 
				++it;
				if(it!=t.end()) suf=*it;
				int r1=pre?T.finddep(rt,pre):0,r2=suf?T.finddep(rt,suf):0;
				if(r1<r2){
					printf("%d\n",r2+1);
					f[x]=suf,c[suf][0]=x,T.link(x,suf);
				}
				else{
					printf("%d\n",r1+1);
					f[x]=pre,c[pre][1]=x,T.link(x,pre);
				}
				break;
			}
			case 2:{
				it=t.begin();int x=*it;
				if(rt==x){puts("1");continue;}
				printf("%d\n",T.finddep(rt,x));
				int u=c[x][1],v=f[x];//开了两个数组来记录原树 
				T.cut(x,v),T.cut(x,u),T.link(x,rt),T.link(v,u);
				f[x]=0,c[x][1]=rt,f[rt]=x;rt=x;
				c[v][0]=u;f[u]=v;
				break;
			}
			case 3:{
				it=t.end();int x=*(--it);
				if(rt==x){puts("1");continue;}
				printf("%d\n",T.finddep(rt,x));
				int u=c[x][0],v=f[x];
				T.cut(x,v),T.cut(x,u),T.link(x,rt),T.link(v,u);
				f[x]=0,c[x][0]=rt,f[rt]=x;rt=x;
				c[v][1]=u;f[u]=v;
				break;
			}
			case 4:{
				it=t.begin();int x=*it;t.erase(x);
				printf("%d\n",T.finddep(rt,x));
				--Cnt;
				if(!Cnt) continue;
				int u=c[x][1],v=f[x];
				T.cut(x,v),T.cut(x,u);T.link(u,v);
				c[x][0]=c[x][1]=f[x]=0;if(rt==x) rt=u;//别忘了更新根节点 
				c[v][0]=u;f[u]=v;
				break;
			}
			case 5:{
				it=t.end();int x=*(--it);t.erase(x);
				printf("%d\n",T.finddep(rt,x));
				--Cnt;
				if(!Cnt) continue;
				int u=c[x][0],v=f[x];
				T.cut(x,v),T.cut(x,u);T.link(u,v);
				c[x][0]=c[x][1]=f[x]=0;if(rt==x) rt=u;
				c[v][1]=u;f[u]=v;
				break;
			}
		}
	}
	return 0;
}
```


---

## 作者：shadowice1984 (赞：3)

其实我splay也是可以做的……

~~等等，怎么又双叒叕死循了……滚回去写线段树！~~

那么首先这道题要求我们实现一个数据结构——spaly

滋磁插入，单旋最值，单旋并删除最值。

那么首先spaly肯定是会T的，但是我们可以考虑通过某些东西模拟这个数据结构，然后我们经过手玩发现，由于我们单旋的是最值，意味着我们一直在左旋，或者一直在右旋。

回忆下旋转的过程，其实只是转移了了一个子树的所有者，每次都是中间的那个子树被拿走，但是我们连续进行同一旋转的时候，上步旋转拿走的子树会在下一步被换回来，(如果还是了解不了的话自行手玩，同“树状数组”那道题的结论)

因此，我们发现，上一次旋转对树结构的破坏很快就会被修正，最后的结果是，将最值放在根上，再将它原来的左/右子树嫁接到它原来的父亲上
那么我们发现，除了他的原来子树和他自己之外，其他点的深度+1

如果删掉了根，那么所有点深度-1

然后我们就需要维护这个树的姿态，我们可以直接开一个spalytree
就像平时维护splaytree一样维护他的姿态，但是我们不能在这棵树上插入和查找，查前驱后继，所以我们需要set~

因此，我们可以这样维护这个spalytree，使用set维护它的平衡树部分，使用线段树维护它的深度部分，对于深度如何维护呢，还记得我们滋磁的操作们吗？我们现在来拆分操作，也就是说我们到底要维护那个数据结构。

(代码实现上，为了好写，我们把值读进来离散化之后，直接把值作为节点的编号，无论是在spalytree上还是线段树上)

##### 操作1：插入

1.查找前驱和后继(set操作)

2.寻找前驱和后继中有空闲儿子位置的点(spalytree操作)

3.查找父亲节点的深度并且+1孩子深度(线段树操作)

##### 操作2：单旋min

1.查找min(set操作)

2.嫁接它的子树并将其提至根的位置(spalytree操作)

3.比他的原父亲大的值，深度加1,**自己的深度设为1**，(线段树操作)

##### 操作3，单旋max

同上，流程完全相同

##### 操作4：单旋并删除min

1.进行操作2(复合操作)

2.将min的右儿子设为根(spalytree操作)

3.删除min(set操作)

4.所有点深度-1

##### 操作5：单旋并删除max

同上，只是让左儿子成为根

然后流程就很清楚啦(这里当然开的还是值域线段树)

上代码~
```c
#include<cstdio>
#include<algorithm>
#include<set>
#include<vector>
#include<stack>
using namespace std;
const int N=1e5+10;int m;
struct linetree//通用线段树板子
{
    int val[4*N];int add[4*N];
    inline void pushdown(int p,int l,int r)
    {
        if(r-l>1){add[2*p]+=add[p];add[2*p+1]+=add[p];}
        val[p]+=(r-l)*add[p];add[p]=0;return;
    }
    inline void setadd(int p,int l,int r,int dl,int dr,int plus)
    {
        if(dl==l&&dr==r){add[p]+=plus;pushdown(p,l,r);return;}
        if(add[p]!=0)pushdown(p,l,r);int mid=(l+r)/2;
        if(dl<mid){setadd(2*p,l,mid,dl,min(dr,mid),plus);}
        else pushdown(2*p,l,mid);
        if(mid<dr){setadd(2*p+1,mid,r,max(dl,mid),dr,plus);}
        else pushdown(2*p+1,mid,r);
        val[p]=val[2*p]+val[2*p+1];
    }
    inline int sum(int p,int l,int r,int dl,int dr)
    {
        if(add[p]!=0){pushdown(p,l,r);}
        if(dl==l&&dr==r){return val[p];}int mid=(l+r)/2;int res=0;
        if(dl<mid){res+=sum(2*p,l,mid,dl,min(dr,mid));}
        if(mid<dr){res+=sum(2*p+1,mid,r,max(dl,mid),dr);}
        return res;
    }
    inline void setval(int p,int v)
    {int nowv=sum(1,0,m,p-1,p);setadd(1,0,m,p-1,p,v-nowv);}
    inline int getval(int p){return sum(1,0,m,p-1,p);}
}lt;
set <int> se;//一个set
struct data
{
    int pos;int val;
    friend bool operator <(data a,data b){return a.val<b.val;}
}data[N];int cnt;//离散化的结构体
struct op{int tp;int val;}op[N];
struct spalytree//直接维护树的形态
{
    int s[2][N];int fa[N];int root;
    inline int ins(int v,int tp,int p)//辅助函数,插入一个值并返回深度
    {
        s[tp][p]=v;fa[v]=p;int dep=lt.getval(p)+1;
        lt.setval(v,dep);se.insert(v);return dep;
    }
    inline int insert(int v)
    {
        if(root==0){root=v;se.insert(v);lt.setval(v,1);return 1;}//空树
        set <int>::iterator it;
        it=se.begin();if(v<*it){return ins(v,0,*it);}//无前驱
        it=se.end();--it;if(v>*it){return ins(v,1,*it);}//无后继
        it=se.lower_bound(v);if(s[0][*it]==0){return ins(v,0,*it);}//查看前驱和后继
        --it;return ins(v,1,*it);
    }
    inline int spalymi()
    {
        set <int>:: iterator it;it=se.begin();int dep=lt.getval(*it);//查最小值
        if(*it==root){return 1;}//如果是根就不用操作
        lt.setadd(1,0,m,fa[*it]-1,m,1);lt.setval(*it,1);//添加深度
        s[0][fa[*it]]=s[1][*it];if(s[1][*it])fa[s[1][*it]]=fa[*it];
        s[1][*it]=root;fa[*it]=0;fa[root]=*it;root=*it;return dep;//变换树的姿态
    }
    inline int spalyma()//同上
    {
        set <int>:: iterator it;it=--se.end();int dep=lt.getval(*it);
        if(*it==root){return 1;}
        lt.setadd(1,0,m,0,fa[*it],1);lt.setval(*it,1);
        s[1][fa[*it]]=s[0][*it];if(s[0][*it])fa[s[0][*it]]=fa[*it];
        s[0][*it]=root;fa[*it]=0;fa[root]=*it;root=*it;return dep;
    }
    inline int erasemi()
    {
        int dep=spalymi();se.erase(root);//spaly后直接erase就好
        int tmp=root;root=s[1][root];s[1][tmp]=0;
        lt.setadd(1,0,m,0,m,-1);return dep;//全体深度-1
    }
    inline int erasema()//同上
    {
        int dep=spalyma();se.erase(root);
        int tmp=root;root=s[0][root];s[0][tmp]=0;
        lt.setadd(1,0,m,0,m,-1);return dep;
    }
}sly;
int main()
{
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&op[i].tp);
        if(op[i].tp==1)
        {
            scanf("%d",&op[i].val);
            data[++cnt].pos=i;data[cnt].val=op[i].val;
        }
    }
    sort(data+1,data+cnt+1);
    for(int i=1;i<=cnt;i++){op[data[i].pos].val=i;}//离散化
    for(int i=1;i<=m;i++)//然后就可以直接上了
    {
        switch(op[i].tp)
        {
            case 1:{printf("%d\n",sly.insert(op[i].val));break;}
            case 2:{printf("%d\n",sly.spalymi());break;}
            case 3:{printf("%d\n",sly.spalyma());break;}
            case 4:{printf("%d\n",sly.erasemi());break;}
            case 5:{printf("%d\n",sly.erasema());break;}
        }
    }return 0;//拜拜程序
}
```

---

## 作者：doctorZ_ (赞：2)

这是个奇怪的题目，要用数据结构维护另一个数据结构。
## $\text{Solution}$
- $1$.插入操作，新节点的父亲要么是它的前驱，要么是它的后继，将新节点插在较深那个点下面，新节点的深度为父亲的深度$+1$
- $2$.记最小的点为$X$,$X$的父亲为$Y$,当前的根为$rt$,由于是单旋，所以从$Y$到$rt$这段的父子关系都不变，我们只需把$X$接在$rt$上，将$X$的右儿子接在$Y$的左儿子上，$Y\sim rt$的点的深度都$+1$，$X$的右儿子深度不变，$X$的深度变为1
![移根前](https://cdn.luogu.com.cn/upload/image_hosting/p78ucl7j.png)
![移根后](https://cdn.luogu.com.cn/upload/image_hosting/d88x2jqj.png)
- $3$.与$2$类似
- $4$.先进行$2$操作，然后将$rt$与儿子的关系断掉，把除根以外的点的深度都$-1$
- $5$.与$4$类似         

前驱后继可以用$set$维护，深度可以用离散化后的线段树维护，总时间复杂度$O(n\log n)$
## $\text{Code}$
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<set>
#define N 110000 
using namespace std;
int read()
{
	int res=0,x=1; char ch=getchar();
	while(ch<'0'||ch>'9'){ if(ch=='-') x=-x; ch=getchar();}
	while('0'<=ch&&ch<='9')	res=(res<<1)+(res<<3)+(ch^'0'),ch=getchar();
	return res*x;
}
const int inf=2147483647;
int a[N+1],b[N+1];
int tag[N<<2|1];
int c[N+1],len;
void update(int p,int l,int r,int L,int R,int k)
{
//	if(L>R)
//		return;
	if(L<=l&&r<=R)
	{
		tag[p]+=k;
		return;
	}
	int mid=(l+r)>>1;
	if(L<=mid)
		update(p<<1,l,mid,L,R,k);
	if(R>mid)
		update(p<<1|1,mid+1,r,L,R,k);
}
int query(int p,int l,int r,int k)
{
	if(l==r)
		return tag[p];
	tag[p<<1]+=tag[p],tag[p<<1|1]+=tag[p];
	tag[p]=0;
	int mid=(l+r)>>1;
	if(k<=mid)
		return query(p<<1,l,mid,k);
	else
		return query(p<<1|1,mid+1,r,k);
}
set<int> t;
set<int>::iterator it;
int fa[N+1],ch[N+1][2],rt;
int insert(int key)
{
	it=t.upper_bound(key);
	int nxt=*it;
	it--;
	int pre=*it;
	int depp=-1,depn=-1;
	if(pre!=-inf)
		depp=query(1,0,len,pre);
	if(nxt!=inf)
		depn=query(1,0,len,nxt);
//	printf("%d %d\n",depp,depn);
	if(depp==-1&&depn==-1)
		fa[key]=0,update(1,0,len,key,key,1-query(1,0,len,key)),rt=key;
	else
		if(depp>depn)
			fa[key]=pre,ch[pre][1]=key,update(1,0,len,key,key,depp+1-query(1,0,len,key));
		else
			fa[key]=nxt,ch[nxt][0]=key,update(1,0,len,key,key,depn+1-query(1,0,len,key));
	t.insert(key);
	return query(1,0,len,key);
}
int rmin()
{
	it=t.begin(),it++;
	int minn=*it;
	if(rt==minn)
		return 1;
	int res=query(1,0,len,minn);
	int son=ch[minn][1];
	update(1,0,len,fa[minn],len,1),update(1,0,len,minn,minn,1-query(1,0,len,minn));
	fa[son]=fa[minn],ch[fa[minn]][0]=son;
	fa[minn]=0,ch[minn][1]=rt,fa[rt]=minn;
	rt=minn;
	return res;
}
int rmax()
{
	it=t.end(),it--,it--;
	int maxn=*it;
	if(rt==maxn)
		return 1;
	int res=query(1,0,len,maxn);
	int son=ch[maxn][0];
	update(1,0,len,0,fa[maxn],1),update(1,0,len,maxn,maxn,1-query(1,0,len,maxn));
	fa[son]=fa[maxn],ch[fa[maxn]][1]=son;
	fa[maxn]=0,ch[maxn][0]=rt,fa[rt]=maxn;
	rt=maxn;
	return res;
}
int delmin()
{
	int res=rmin();
	update(1,0,len,0,len,-1);
	int s=ch[rt][1];
	fa[ch[rt][1]]=0,ch[rt][0]=ch[rt][1]=0;
	t.erase(rt);
	rt=s;
	return res;
}
int delmax()
{
	int res=rmax();
	update(1,0,len,0,len,-1);
	int s=ch[rt][0];
	fa[ch[rt][0]]=0,ch[rt][0]=ch[rt][1]=0;
	t.erase(rt);
	rt=s;
	return res;
}
int main()
{
//	freopen("splay.in","r",stdin);
//	freopen("splay.out","w",stdout);
	int m=read();
	for(int i=1;i<=m;i++)
	{
		a[i]=read();
		if(a[i]==1)
			c[i]=b[i]=read();
	}
	sort(c+1,c+1+m);
	len=unique(c+1,c+1+m)-c-1;
	for(int i=1;i<=m;i++)
		b[i]=lower_bound(c+1,c+1+len,b[i])-c;
	t.insert(-inf),t.insert(inf);
	for(int i=1;i<=m;i++)
	{
		if(a[i]==1)
			printf("%d\n",insert(b[i]));
		if(a[i]==2)
			printf("%d\n",rmin());
		if(a[i]==3)
			printf("%d\n",rmax());
		if(a[i]==4)
			printf("%d\n",delmin());
		if(a[i]==5)
			printf("%d\n",delmax());
	}
	return 0;
}
```


---

## 作者：zhaoyifan (赞：2)

线段树处理的确很美妙，但是依旧需要维护原树父亲，

实际上我们可以多模拟一下，只用splay就可以解决本题

Splay+数组模拟

我们发现他只要求最小值和最大值的修改，那么手动找一下规律很容易发现
对于插入我们也手动找一下规律，对于树中的大小紧邻的点，他们在树形态中也是紧邻的，所以模拟一下就可以找到规律（即在不splay的前提树是很多链构成的）

然后开simer和simfa记录原树中的相对位置，因为修改不会大幅度修改原树，所以对于simer和simfa的修改也比较友好

希望在难题方面能有更多的人分享题解，互相帮助，还能提升自信，理清题目思路，多好的一件事情！
```c
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<stack>
using namespace std;
const int maxn=1e5+7;
stack<int>sta;
int n,m,cnt=1,simfa[maxn],dep[maxn],fa[maxn],son[maxn],
t[maxn][2],w[maxn],rt,simer[maxn][2],laz[maxn],ans,simrt,
rev;
void up(int x)
{
    son[x]=son[t[x][0]]+son[t[x][1]]+1;
}
void downit(int x)
{
    if(!laz[x]) return ;
    int l=t[x][0],r=t[x][1];
    if(l) {dep[l]+=laz[x];laz[l]+=laz[x];}
    if(r) {dep[r]+=laz[x];laz[r]+=laz[x];}
    laz[x]=0;
    
}
void Insert(int &x,int v)
{
    if(!x) 
    {
        x=++cnt;w[x]=v;son[x]=1;return ;
    }
    downit(x);
    if(v<w[x]) Insert(t[x][0],v);
    else Insert(t[x][1],v);
    up(x);fa[t[x][0]]=fa[t[x][1]]=x;
}
void rotate(int x,int &k)
{
    int y=fa[x],z=fa[y],d=t[y][1]==x;
    if(y==k) k=x;
    else t[z][t[z][1]==y]=x;
    fa[x]=z;fa[y]=x;fa[t[x][d^1]]=y;
    t[y][d]=t[x][d^1];t[x][d^1]=y;up(y);up(x);
}
void splay(int x,int &k)
{
    int xx=x;sta.push(xx);
    while(fa[xx]) {xx=fa[xx];sta.push(xx);}
    while(sta.size()) {downit(sta.top());sta.pop();}
    while(x!=k)
    {
        int y=fa[x],z=fa[y];
        if(y!=k)
        {
            if((t[y][0]==x)^(t[z][0]==y)) rotate(x,k);
            else rotate(y,k);
        }
        rotate(x,k);
    }
}
void solve2()
{
    int p1=rt,old=simrt;downit(p1);
    while(t[p1][0]) {p1=t[p1][0];downit(p1);}simrt=p1;
    splay(p1,rt);ans=dep[p1];int s=simer[p1][1];
    if(ans==1) return ;
    if(t[p1][1]) 
    {
        dep[t[p1][1]]++;laz[t[p1][1]]++;
        simfa[old]=p1;simer[p1][1]=old;
    }
    if(simfa[p1]) 
    {
        splay(simfa[p1],t[p1][1]);int p2=simfa[p1];
        if(t[p2][0]) {dep[t[p2][0]]--;laz[t[p2][0]]--;}
        simer[simfa[p1]][0]=s;
        if(s) simfa[s]=simfa[p1];
        simfa[p1]=0;dep[p1]=1;rev=p1;
    }
}
void solve3()
{
    int p1=rt;int old=simrt;downit(p1);
    while(t[p1][1]) {p1=t[p1][1];downit(p1);}simrt=p1;
    splay(p1,rt);ans=dep[p1];int s=simer[p1][0];
    if(ans==1) return ;
    if(t[p1][0]) 
    {
        dep[t[p1][0]]++;laz[t[p1][0]]++;
        simfa[old]=p1;simer[p1][0]=old;
    }
    if(simfa[p1])
    {
        splay(simfa[p1],t[p1][0]);int p2=simfa[p1];
        if(t[p2][1]) {laz[t[p2][1]]--;dep[t[p2][1]]--;}
        simer[simfa[p1]][1]=s;
        if(s) simfa[s]=simfa[p1];
        simfa[p1]=0;dep[p1]=1;rev=p1;
    }
}
int find_hea(int x,int v)
{
	if(!x) return -1e9;
	if(w[x]<v) return max(w[x],find_hea(t[x][1],v));
	else return find_hea(t[x][0],v);
}
int find_nxt(int x,int v)
{
	if(!x) return 1e9;
	if(w[x]>v) return min(w[x],find_nxt(t[x][0],v));
	else return find_nxt(t[x][1],v);
}
int find_na(int x,int v)
{
	if(w[x]==v) return x;
	if(w[x]<v) return find_na(t[x][1],v);
	else return find_na(t[x][0],v);
}
int main()
{
    scanf("%d",&m);n=m;
    for(int i=1;i<=m;++i)
    {
        int x,y;ans=0;scanf("%d",&x);
        if(x==1)
        {
            scanf("%d",&y);int de=0;
            int p1=find_hea(rt,y),p2=find_nxt(rt,y);
            if(p1!=-1e9)
            {
            	p1=find_na(rt,p1);splay(p1,rt);
            	if(!simer[p1][1])
            	{
            		simer[p1][1]=cnt+1;simfa[cnt+1]=p1;de=dep[p1];
            	}
            }
            if(p2!=1e9)
            {
            	p2=find_na(rt,p2);splay(p2,rt);
            	if(!simer[p2][0])
            	{
            		simer[p2][0]=cnt+1;simfa[cnt+1]=p2;de=dep[p2];
            	}
            }
            if(!de) simrt=cnt+1;ans=de+1;
            dep[cnt+1]=de+1;Insert(rt,y);splay(cnt,rt);
        }
        if(x==2) solve2();
        if(x==4)
        {
            solve2();
            int p1=rt;simfa[simer[p1][1]]=0;
            fa[t[rt][1]]=0;rt=t[rt][1];
            simrt=simer[p1][1];
            if(rt) {laz[rt]--;dep[rt]--;}
        }
        if(x==3) solve3();
        if(x==5)
        {
            solve3();
            int p1=rt;simfa[simer[p1][0]]=0;
            simrt=simer[p1][0];rt=t[p1][0];
            fa[rt]=0;t[p1][0]=0;
            if(rt) {laz[rt]--;dep[rt]--;}
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：ningago (赞：1)

我喜欢 Treap，所以我用 Treap 维护 Spaly。

$fa,ls,rs,dep,val$ 分别表示一个节点的父亲，左儿子，右儿子，深度，权值。

以 $2$ 操作为例，具体细节请自行模拟，这里只说结果。设最小值对应节点为 $x$，则 $2$ 操作的实质为：

- $fa(rs(x))\leftarrow fa(x)$，$ls(fa(x))\leftarrow rs(x)$；
- $rs(x)\leftarrow root$，$fa(root)\leftarrow x$；
- $fa(x)\leftarrow \varnothing$；
- 除去 $x$ 子树以外的所有 $dep$ 加一；
- $dep(x)\leftarrow 1$。

所以说 spaly 的形态可以 $O(1)$ 维护，需要一个区间加的数据结构维护 $dep$。

用一个按权值为 $val(x)$ 排序的 Treap 维护前序遍历序列的 $dep$。

用 $[l,r]$ 表示权值在此区间内的点，不难发现每个子树用这样的区间表示，记作 $l_i,r_i$。

以 $x$ 是 $fa(x)$ 的右儿子为例，容易求出 $l_i=val(fa(x))+1$。在 Treap 上记录每个节点对应（Treap 上）子树的 $dep$ 最小值，即可二分出 $r_i$。

对于插入 $val$ （节点编号 $x$）操作，在 Treap 上找到其的前驱后继 $p,q$。

若 $p$ 存在且 $rs(p)=\varnothing$，则要修改 $fa(x)\leftarrow p,rs(p)\leftarrow x$。

否则将一定有 $q$ 存在且 $ls(q)=\varnothing$，修改 $fa(x)\leftarrow q,ls(q)\leftarrow x$。

复杂度 $O(n\log^2n)$，二分应该可以规避掉（？）。

代码是答辩，`Findroot` 应该可以 $O(1)$ 的。

```cpp
#include <cstdio>
#include <cstring>
#include <ctype.h>
#include <algorithm>
#include <cmath>
#include <set>

char ST;
//#define int long long
#define ll long long
//#define inf 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f 
#define pii std::pair <int, int>
#define mkp std::make_pair
#define fi first
#define se second
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define gline debug("now is #%d\n", __LINE__)

int read()
{
	int x = 0, f = 1;
	char c = getchar();
	for(; !isdigit(c); c = getchar()) if(c == '-') f = -1;
	for(;  isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);
	return x * f; 
}

void ckmax(int &x, int y) { x = x > y ? x : y; }
void ckmin(int &x, int y) { x = x < y ? x : y; }
#define mod 998244353
//#define mod 1000000007
void plus_(int &x, int y) { x = x + y >= mod ? x + y - mod : x + y; }
void mul_(int &x, int y) { x = 1ll * x * y % mod; }
int ksm(int a, int b)
{
	int res = 1;
	for(; b; b >>= 1, mul_(a, a)) if(b & 1) mul_(res, a);
	return res;
}

unsigned int sd = 114514;
unsigned int rnd()
{
	sd ^= sd << 13;
	sd ^= sd >> 7;
	sd ^= sd << 11;
	return sd;
}

#define N 100010
int n, m;
int fa[N], ls[N], rs[N];
std::set <int> s;

struct Tree
{
	int dep, sz, val, ls, rs, mn;
	int lazy;
	unsigned int key;
	void push(int z) { mn += z, dep += z, lazy += z; }
}tr[N];

#define lson(k) tr[k].ls
#define rson(k) tr[k].rs

int root, idx;
int fid[N];

int newnode(int val, int dep)
{
	tr[++idx].sz = 1;
	tr[idx].val = val;
	fid[val] = idx;
	tr[idx].key = rnd();
	tr[idx].dep = tr[idx].mn = dep;
	return idx;
}

void pushup(int k) 
{ 
	tr[k].mn = std::min({tr[k].dep, tr[lson(k)].mn, tr[rson(k)].mn});
	tr[k].sz = tr[lson(k)].sz + tr[rson(k)].sz + 1; }

void pushdown(int k)
{
	if(tr[k].lazy)
	{
		tr[lson(k)].push(tr[k].lazy);
		tr[rson(k)].push(tr[k].lazy);
		tr[k].lazy = 0;
	}
}

void split(int k, int val, int &x, int &y)
{
	if(!k) { x = y = 0; return; }
	pushdown(k);
	if(tr[k].val <= val)
	{
		x = k;
		split(rson(x), val, rson(x), y);
	}
	else
	{
		y = k;
		split(lson(y), val, x, lson(y));
	}
	pushup(k);
}

int merge(int x, int y)
{
	if(!x || !y)
		return x | y;
	if(tr[x].key <= tr[y].key)
	{
		pushdown(x);
		rson(x) = merge(rson(x), y);
		pushup(x);
		return x;
	}
	else
	{
		pushdown(y);
		lson(y) = merge(x, lson(y));
		pushup(y);
		return y;
	}
}

int t1, t2, t3;

int get_pre(int x)
{
	split(root, x - 1, t1, t2);
	int p = t1;
	while(rson(p))
	{
		pushdown(p);
		p = rson(p);
	}
	root = merge(t1, t2);
	return p;
}

int get_suc(int x)
{
	split(root, x, t1, t2);
	int p = t2;
	while(lson(p))
	{
		pushdown(p);
		p = lson(p);
	}
	root = merge(t1, t2);
	return p;
}

void ins(int x, int t)
{
	split(root, x - 1, t1, t2);
	root = merge(merge(t1, t), t2);
}

int Ins(int val)
{
	s.insert(val);
	if(!root)
	{
		root = newnode(val, 1);
		return 1;
	}
	int p = get_pre(val), q = get_suc(val);
	if(p && !rs[p])
	{
		int x = newnode(val, tr[p].dep + 1);
		rs[p] = x;
		fa[x] = p;
		ins(val, x);
		return tr[x].dep;
	}
	else
	{
		int x = newnode(val, tr[q].dep + 1);
		ls[q] = x;
		fa[x] = q;
		ins(val, x);
		return tr[x].dep;
	}
}

int query(int l, int r)
{
	split(root, r, t1, t3);
	split(t1, l - 1, t1, t2);
	int res = tr[t2].mn;
	root = merge(merge(t1, t2), t3);
	return res;
}

void change(int l, int r, int z)
{
	if(l > r) return;
	split(root, r, t1, t3);
	split(t1, l - 1, t1, t2);
	tr[t2].push(z);
	root = merge(merge(t1, t2), t3);
}

int Findroot()
{
	int l = 1, r = m, res = 1;
	while(l <= r)
	{
		int mid = (l + r) >> 1;
		if(query(1, mid) == 1)
			res = mid, r = mid - 1;
		else
			l = mid + 1;
	}
	return fid[res];
}

int sta[N], top;

void Subchange(int x, int z)
{
	if(!x)
		return;
	if(z == 2)
	{
		tr[root].push(-1);
		return;
	}
	int deep = query(tr[x].val, tr[x].val);
	int L, R;
	if(x == rs[fa[x]])
	{
		int L = tr[fa[x]].val + 1;
		int l = L, r = n;
		R = n;
		while(l <= r)
		{
			int mid = (l + r) >> 1;
			if(query(L, mid) <= deep)
				R = mid, l = mid + 1;
			else
				r = mid - 1;
		}
		change(L, R, z);
	}
	else if(x == ls[fa[x]])
	{
		int R = tr[fa[x]].val - 1;
		int l = 1, r = R;
		L = 1;
		while(l <= r)
		{
			int mid = (l + r) >> 1;
			if(query(mid, R) <= deep)
				L = mid, r = mid - 1;
			else
				l = mid + 1;
		}
		change(L, R, z);
	}
}

int SpalyMin()
{
	int val = *s.begin();
	int x = fid[val];
	int res = query(val, val);
	int rt = Findroot();
	if(rt == x)
		return res;
	int rsx = rs[x];
	ls[fa[x]] = rs[x];
	fa[rs[x]] = fa[x];
	Subchange(rsx, -1);
	split(root, val, t1, t2);
	tr[t1].dep = tr[t1].mn = 1;
	root = merge(t1, t2);
	fa[rt] = x;
	rs[x] = rt;
	fa[x] = 0;
	Subchange(rt, 1);
	return res;
}

int SpalyMax()
{
	int val = *(--s.end());
	int x = fid[val];
	int res = query(val, val);
	int rt = Findroot();
	if(rt == x)
		return res;
	int lsx = ls[x];
	rs[fa[x]] = ls[x];
	fa[ls[x]] = fa[x];
	Subchange(lsx, -1);
	split(root, val - 1, t1, t2);
	tr[t2].dep = tr[t2].mn = 1;
	root = merge(t1, t2);
	fa[rt] = x;
	ls[x] = rt;
	fa[x] = 0;
	Subchange(rt, 1);
	return res;
}

int DelMin()
{
	int val = *s.begin();
	s.erase(val);
	int x = fid[val];
	int res = query(val, val);
	int rt = Findroot();
	int rsx = rs[x];
	if(fa[x])
		ls[fa[x]] = rs[x];
	fa[rs[x]] = fa[x];
	split(root, val, t1, t2);
	root = t2;
	if(x == rt)
		Subchange(rsx, 2); 
	else
		Subchange(rsx, -1);
	return res;
}

int DelMax()
{
	int val = *(--s.end());
	s.erase(val);
	int x = fid[val];
	int res = query(val, val);
	int rt = Findroot();
	int lsx = ls[x];
	if(fa[x])
		rs[fa[x]] = ls[x];
	fa[ls[x]] = fa[x];
	split(root, val - 1, t1, t2);
	root = t1;
	if(x == rt)
		Subchange(lsx, 2);
	else
		Subchange(lsx, -1);
	return res;
}

struct Lish
{
	int sta[N], top;
	void ins(int x) { sta[++top] = x; }
	void build()
	{
		std::sort(sta + 1, sta + 1 + top);
//		top = std::unique(sta + 1, sta + 1 + top) - sta - 1;
	}
	int query(int x) { return std::lower_bound(sta + 1, sta + 1 + top, x) - sta; }
}X;

int op_[N], x_[N];

char ED;
signed main()
{
	tr[0].mn = 0x3f3f3f3f;
	n = read();
	for(int i = 1; i <= n; i++)
	{
		op_[i] = read();
		if(op_[i] == 1)
			X.ins(x_[i] = read());
	}
	X.build();
	m = X.top; 
	for(int _ = 1, op, t = -114514; _ <= n; _++)
	{
		op = op_[_];
		if(op == 1)
			t = Ins(X.query(x_[_]));
		else if(op == 2)
			t = SpalyMin();
		else if(op == 3)
			t = SpalyMax();
		else if(op == 4)
			t = DelMin();
		else if(op == 5)
			t = DelMax();
		printf("%d\n", t);
	}
	return 0;
}
```

---

## 作者：Rainybunny (赞：0)

# 题目

&emsp;&emsp;[luogu](https://www.luogu.com.cn/problem/P3721).

# 题解

&emsp;&emsp;树状数组 + set。（总算不用神仙数据结构了qwq。  

&emsp;&emsp;~~由于作者很菜，~~ 可能会过于详细，请[大佬](https://www.luogu.com.cn/problem/P3724)们见谅呐~  

&emsp;&emsp;首先，关于 “spaly”，可以先画一画图找找规律。  

&emsp;&emsp;举个例子：

![graph _1_.png](https://i.loli.net/2020/06/02/OKhMmt4NeQ7Wn5v.png)

![graph _2_.png](https://i.loli.net/2020/06/02/l1ew7r8CE3LHmYk.png)

![graph _3_.png](https://i.loli.net/2020/06/02/2vUSbxHuQamAoyg.png)

![graph _4_.png](https://i.loli.net/2020/06/02/LgZBAdNiG6Yws7D.png)

&emsp;&emsp;如上四幅图体现了把权值最小的 $6$ 号结点“spaly”到根的过程。直接观察初始状态 P1 和最终状态 P4，发现除了关于 $6$ 号结点本身及其邻接点外，树形没有改变！  

&emsp;&emsp;这提示我们，可以把树形与深度信息**分开维护**。为了方便建立编号与键值的对应关系，**离线所有操作，并离散化键值。** 此后，令任意结点的编号 $u$ 等于其键值 $key_u$。一步步来：

## 维护树形

&emsp;&emsp;题目中的操作都与最小最大值有关，不难想到用 `std::set` 来动态维护当前“spaly”上存在的点权。  

&emsp;&emsp;对于每种操作：

### 操作 $1$

&emsp;&emsp;若树空，直接令“spaly”的根为该结点，退出。  

&emsp;&emsp;否则，利用 `set`，将当前的键值插入 `set`，并取得 `set` 中与其相邻的两个元素，令为 $u,v$。（`set.insert()` 会返回插入位置的迭代器）。可以证明，对于“spaly”上任意结点 $p<q$，若**不存在 $p<r<q$** （也即是 $key_p<key_r<key_q$），则 $p$ 与 $q$ 存在**父子关系**。简单地讨论一下当前结点挂在 $u$ 下还是 $v$ 下即可。不在赘述。

### 操作 $2$

&emsp;&emsp;利用 `set` 直接找到最小值结点编号，修改其父亲的信息，父亲的儿子信息，根的信息。

### 操作 $3$

&emsp;&emsp;同操作 $2$，不赘述。

### 操作 $4$

&emsp;&emsp;在操作 $2$ 的基础上，断绝根与其右儿子（最小值没有左儿子）的关系，修改相关信息。

### 操作 $5$

&emsp;&emsp;同操作 $4$，不赘述。

## 维护深度

&emsp;&emsp;有四种影响深度的形式：插入结点，某子树上移一位（旋转换父亲），某结点到根，去除根节点。

&emsp;&emsp;对于后两种，实质上就是所有结点的深度 $+1$ 或 $-1$，第一种则是单点查询（查询父亲）和单点修改（更新儿子）；第二种是亦是区间 $-1$。

&emsp;&emsp;所以，用一个经典的树状数组维护序列差分就可以支持所有操作了。  

&emsp;&emsp;最后细说一下第二种，设上旋的结点为 $u$，它是父亲 $fa_u$ 的左儿子。那么 $[u+1,fa_u-1]$ 里的结点都在 $fa_u$ 的右子树内，将其区间 $-1$，抵消掉整棵树的区间 $+1$，实质上就是该子树树深不变。$u$ 作为 $fa_u$ 的右儿子时同理。其余操作比较简单，在维护树形的步骤里加上对树状数组的维护即可。

## 代码

&emsp;&emsp;~~真的短w。~~

```cpp
#include <set>
#include <cstdio>
#include <algorithm>

inline int rint () {
	int x = 0; char s = getchar ();
	for ( ; s < '0' || '9' < s; s = getchar () );
	for ( ; '0' <= s && s <= '9'; s = getchar () ) x = x * 10 + ( s ^ '0' );
	return x;
}

inline void wint ( const int x ) {
	if ( 9 < x ) wint ( x / 10 );
	putchar ( x % 10 ^ '0' );
}

const int MAXN = 1e5;
int n, kcnt, ktmp[MAXN + 5];
int root, fa[MAXN + 5], ch[MAXN + 5][2]; // spaly tree.
std :: set<int> aprk; // appearing keys.
std :: set<int> :: iterator it;

struct Event { int opt, key; } evt[MAXN + 5];

class BinaryIndexTree {
private:
	int siz, val[MAXN + 5];
	inline int lowbit ( const int x ) const { return x & -x; }

public:
	inline void set ( const int s ) { siz = s; }
	inline void add ( const int x, const int v ) { for ( int i = x; i <= siz; i += lowbit ( i ) ) val[i] += v; }
	inline void addsec ( const int l, const int r, const int x ) { add ( l, x ), add ( r + 1, -x ); }
	inline int sum ( const int x ) { int ret = 0; for ( int i = x; i; i -= lowbit ( i ) ) ret += val[i]; return ret; }
	inline void assign ( const int x, const int v ) { addsec ( x, x, v - sum ( x ) ); }
} bit;

inline int insert ( const int k ) {
	it = aprk.insert ( k ).first;
	if ( ! root ) return bit.assign ( root = k, 1 ), 1;
	if ( it != aprk.begin () ) {
		if ( ! ch[*-- it][1] ) ch[*it][1] = k, fa[k] = *it;
		++ it;
	}
	if ( ! fa[k] ) ch[*++ it][0] = k, fa[k] = *it;
	int ret = bit.sum ( fa[k] ) + 1;
	return bit.assign ( k, ret ), ret;
}

inline int getMin () {
	int p = *aprk.begin (), ret = bit.sum ( p );
	if ( root == p ) return 1;
	if ( p + 1 != fa[p] ) bit.addsec ( p + 1, fa[p] - 1, -1 );
	bit.addsec ( 1, kcnt, 1 ), bit.assign ( p, 1 );
	if ( ch[p][1] ) fa[ch[p][1]] = fa[p];
	ch[fa[p]][0] = ch[p][1];
	fa[root] = p, fa[p] = 0, ch[p][1] = root, root = p;
	return ret;
}

inline int getMax () {
	int p = *-- ( it = aprk.end () ), ret = bit.sum ( p );
	if ( root == p ) return 1;
	if ( fa[p] + 1 != p ) bit.addsec ( fa[p] + 1, p - 1, -1 );
	bit.addsec ( 1, kcnt, 1 ), bit.assign ( p, 1 );
	if ( ch[p][0] ) fa[ch[p][0]] = fa[p];
	ch[fa[p]][1] = ch[p][0];
	fa[root] = p, fa[p] = 0, ch[p][0] = root, root = p;
	return ret;
}

inline int remMin () {
	int ret = getMin ();
	bit.addsec ( 1, kcnt, -1 );
	fa[root = ch[root][1]] = 0, aprk.erase ( *aprk.begin () );
	return ret;
}

inline int remMax () {
	int ret = getMax ();
	bit.addsec ( 1, kcnt, -1 );
	fa[root = ch[root][0]] = 0, aprk.erase ( -- ( it = aprk.end () ) );
	return ret;
}

int main () {
	n = rint ();
	for ( int i = 1; i <= n; ++ i ) {
		if ( ( evt[i].opt = rint () ) == 1 ) {
			evt[i].key = ktmp[++ kcnt] = rint ();
		}
	}
	std :: sort ( ktmp + 1, ktmp + kcnt + 1 );
	bit.set ( kcnt );
	for ( int i = 1, opt, ans; i <= n; ++ i ) {
		opt = evt[i].opt;
		if ( opt == 1 ) ans = insert ( std :: lower_bound ( ktmp + 1, ktmp + kcnt + 1, evt[i].key ) - ktmp );
		else if ( opt == 2 ) ans = getMin ();
		else if ( opt == 3 ) ans = getMax ();
		else if ( opt == 4 ) ans = remMin ();
		else ans = remMax ();
		wint ( ans ), putchar ( '\n' );
	}
	return 0;
}
```

---

## 作者：FZzzz (赞：0)

有点意思的 ds 题。

然而对于我这种只会暴力的选手来说就没有任何技巧可言了。

首先手玩一下可以发现，一次 spaly 就是把它的唯一的儿子接到它的父亲上面，然后把根接到它下面。

我们用 lct 去维护这个 spaly 的形态。问题是我们怎么找到这个唯一的儿子呢。

这里我们使用一个维护虚子树信息的 trick，用一个 `set` 去维护一个节点的所有（最多两个）虚儿子。怎么实现这个信息的维护不再赘述。

然后对于插入，我们可以发现它的父节点不是它的前驱就是它的后继。我们找到它的前驱和后继，易得这两个一个是另一个的祖先。所以我们找到比较深的那个节点，就是新节点的父亲。

然后有一些细节，代码不知道为什么就写了这么长……
```cpp
#include<set>
#include<map>
#include<cctype>
#include<cstdio>
using namespace std;
inline int readint(){
	int x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-'){
		f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxm=1e5+5;
int m;
int fa[maxm],ch[maxm][2],size[maxm],mn[maxm];
set<int> ich[maxm];
void pushup(int x){
	size[x]=1;
	if(ch[x][0]) size[x]+=size[ch[x][0]];
	if(ch[x][1]) size[x]+=size[ch[x][1]];
	if(ch[x][0]) mn[x]=mn[ch[x][0]];
	else mn[x]=x;
}
bool isroot(int x){
	return !fa[x]||(ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x);
}
void rotate(int x){
	int y=fa[x],z=fa[fa[x]];
	if(!isroot(y)) ch[z][ch[z][1]==y]=x;
	bool d=ch[y][1]==x;
	int k=ch[x][!d];
	ch[x][!d]=y;
	ch[y][d]=k;
	fa[x]=z;
	fa[y]=x;
	if(k) fa[k]=y;
	pushup(y);
	pushup(x);
}
void splay(int x){
	while(!isroot(x)){
		int y=fa[x],z=fa[fa[x]];
		if(!isroot(y)){
			if((ch[y][1]==x)^(ch[z][1]==y)) rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
}
void access(int x){
	int y=0;
	while(x){
		splay(x);
		if(ch[x][1]) ich[x].insert(mn[ch[x][1]]);
		if(y) ich[x].erase(y);
		ch[x][1]=y;
		pushup(x);
		y=x;
		x=fa[x];
	}
}
void link(int x,int y){
	fa[x]=y;
	ich[y].insert(x);
}
void cut(int x,int y){
	access(y);
	splay(x);
	fa[x]=0;
	ich[y].erase(x);
}
int findroot(int x){
	access(x);
	splay(x);
	while(ch[x][0]) x=ch[x][0];
	splay(x);
	return x;
}
int findfa(int x){
	access(x);
	splay(x);
	if(!ch[x][0]) return 0;
	x=ch[x][0];
	while(ch[x][1]) x=ch[x][1];
	splay(x);
	return x;
}
int get_dep(int x){
	access(x);
	splay(x);
	return ch[x][0]?size[ch[x][0]]+1:1;
}
set<int> s;
typedef set<int>::iterator iter;
void spaly(int u){
	int y=findfa(u);
	access(u);
	if(!ich[u].empty()){
		int z=*ich[u].begin();
		if(y){
			cut(z,u);
			link(z,y);
		}
	}
	if(y){
		cut(u,y);
		link(findroot(y),u);
	}
}
void del(int u){
	int y=findfa(u);
	access(u);
	if(!ich[u].empty()){
		int z=*ich[u].begin();
		cut(z,u);
		if(y) link(z,y);
	}
	if(y) cut(u,y);
}
int main(){
	#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
	#endif
	m=readint();
	for(int i=1;i<=m;i++) pushup(i);
	map<int,int> mp;
	while(m--){
		int c=readint();
		if(c==1){
			int key=readint();
			if(!mp.count(key)){
				int res=mp.size();
				mp[key]=res+1;
			}
			int u=mp[key];
			if(!s.empty()){
				iter it=s.lower_bound(key);
				if(it==s.begin()) link(u,mp[*it]);
				else if(it==s.end()) link(u,mp[*--it]);
				else{
					int pre,suc=mp[*it];
					pre=mp[*--it];
					if(get_dep(pre)<get_dep(suc)) link(u,suc);
					else link(u,pre);
				}
			}
			s.insert(key);
			printf("%d\n",get_dep(u));
		}
		else if(c==2){
			int u=mp[*s.begin()];
			printf("%d\n",get_dep(u));
			spaly(u);
		}
		else if(c==3){
			int u=mp[*--s.end()];
			printf("%d\n",get_dep(u));
			spaly(u);
		}
		else if(c==4){
			int u=mp[*s.begin()];
			printf("%d\n",get_dep(u));
			del(u);
			s.erase(s.begin());
		}
		else{
			int u=mp[*--s.end()];
			printf("%d\n",get_dep(u));
			del(u);
			s.erase(--s.end());
		}
	}
	return 0;
}
```

---

## 作者：crashed (赞：0)

# 题目
&emsp;&emsp;[点这里](https://www.luogu.com.cn/problem/P3722)看题目。  
# 分析
&emsp;&emsp;最妙的地方在于，这道题其实是**用一种数据结构模拟另一种数据结构**！  
&emsp;&emsp;我们需要维护深度和树的结构，以下对于每个操作进行分别讨论。  

### 插入一个新节点  
&emsp;&emsp;可以发现，这个新节点一定会**成为自己的前驱或者后继中深度较大者的儿子**。  
&emsp;&emsp;然后可以更新深度和树的结构。  
### 单旋最小值  
&emsp;&emsp;发现树会有如下的变化：  
&emsp;&emsp;&emsp;&emsp;如果自己有儿子，那么它只会是自己的右儿子；旋转后，**它会接到自己原先的父亲上**。  
&emsp;&emsp;&emsp;&emsp;**除了自己的儿子以外，其它的节点的深度都会 +1** 。  
&emsp;&emsp;&emsp;&emsp;**原先的根变成了最小值的儿子**，**根随后变成最小值**。  
&emsp;&emsp;单旋最大值同理分析。  
### 单旋最小值并删除  
&emsp;&emsp;先模拟好单旋的修改，然后考虑**旋转后**的变化：  
&emsp;&emsp;&emsp;&emsp;**所有节点深度 -1** 。  
&emsp;&emsp;&emsp;&emsp;**断开最小值和它的右儿子的边，根变为它的右儿子**。    
&emsp;&emsp;单旋最大值并删除同理分析。  

&emsp;&emsp;发现树的深度的修改实际上可以理解为**值域上一段区间的加减**，因此可以用权值线段树维护；前驱后继也可以顺便用它维护了。  
&emsp;&emsp;中途我们需要用 map 来维护树的形态，或者离散化之后直接存下来也可以。  
&emsp;&emsp;时间复杂度：$O(n\log_2|V|)$。  
# 代码
```cpp
#include <map>
#include <cstdio>
using namespace std;

const int up = 1e9/*4*/;
const int MAXN = 1e5 + 5, MAXLOG = 30, MAXS = MAXN * MAXLOG/*205*/;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

map<int, int> fa, ch[2];

int siz[MAXS], dep[MAXS], tag[MAXS], lch[MAXS], rch[MAXS];
int tot, rt, sgrt;

void upt( const int x ) { siz[x] = siz[lch[x]] + siz[rch[x]]; }
void add( const int x, const int v ) { dep[x] += siz[x] * v, tag[x] += v; }
void normalize( const int x ) { if( tag[x] ) add( lch[x], tag[x] ), add( rch[x], tag[x] ), tag[x] = 0; }

void setNode( int &u, const int l, const int r, const int pos, const int v )
{
	if( ! u ) u = ++ tot;
	if( l == r ) { siz[u] += v; return ; }
	int mid = l + r >> 1; normalize( u );
	if( pos <= mid ) setNode( lch[u], l, mid, pos, v );
	else setNode( rch[u], mid + 1, r, pos, v );
	upt( u );
}

void update( int &u, const int l, const int r, const int segL, const int segR, const int v )
{
	if( ! u ) u = ++ tot;
	if( segL <= l && r <= segR ) { add( u, v ); return ; }
	int mid = l + r >> 1; normalize( u );
	if( segL <= mid ) update( lch[u], l, mid, segL, segR, v );
	if( mid < segR ) update( rch[u], mid + 1, r, segL, segR, v );
	upt( u );
}

int query( const int u, const int l, const int r, const int segL, const int segR )
{
	if( ! u ) return 0;
	if( segL <= l && r <= segR ) return siz[u];
	int mid = l + r >> 1, ret = 0; normalize( u );
	if( segL <= mid ) ret += query( lch[u], l, mid, segL, segR );
	if( mid < segR ) ret += query( rch[u], mid + 1, r, segL, segR );
	return ret;
}

int Kth( const int u, const int l, const int r, const int rnk )
{
	if( l == r ) return l;
	int mid = l + r >> 1; normalize( u );
	if( rnk <= siz[lch[u]] ) return Kth( lch[u], l, mid, rnk );
	return Kth( rch[u], mid + 1, r, rnk - siz[lch[u]] );
}

int getDep( const int u, const int l, const int r, const int pos )
{
	if( l == r ) return dep[u];
	int mid = l + r >> 1; normalize( u );
	if( pos <= mid ) return getDep( lch[u], l, mid, pos );
	return getDep( rch[u], mid + 1, r, pos );
}

int Kth( const int rnk ) { if( rnk <= 0 ) return -1; if( rnk > siz[sgrt] ) return up + 1; return Kth( sgrt, 1, up, rnk ); }
int getDep( const int id ) { if( id < 0 || id > up ) return -0x3f3f3f3f; return getDep( sgrt, 1, up, id ); }

int getMx( const int u, const int l, const int r )
{
	if( l == r ) return l;
	int mid = l + r >> 1; normalize( u );
	if( siz[rch[u]] ) return getMx( rch[u], mid + 1, r );
	return getMx( lch[u], l, mid );
}

int getMn( const int u, const int l, const int r )
{
	if( l == r ) return l;
	int mid = l + r >> 1; normalize( u );
	if( siz[lch[u]] ) return getMn( lch[u], l, mid );
	return getMn( rch[u], mid + 1, r );
}

int rotMn()
{
	int id = getMn( sgrt, 1, up ), rig = ch[1][id], y = fa[id];
	if( rt == id ) return 1;
	if( rig ) fa[rig] = y; fa[rt] = id, fa[id] = 0;
	ch[1][id] = rt, ch[0][y] = rig, rt = id;
	int ret = getDep( id );
	update( sgrt, 1, up, y, up, 1 );
	update( sgrt, 1, up, id, id, -ret + 1 );
	return ret;
}

int rotMx()
{
	int id = getMx( sgrt, 1, up ), lef = ch[0][id], y = fa[id];
	if( rt == id ) return 1;
	if( lef ) fa[lef] = y; fa[rt] = id, fa[id] = 0;
	ch[0][id] = rt, ch[1][y] = lef, rt = id;
	int ret = getDep( id );
	update( sgrt, 1, up, 1, y, 1 );
	update( sgrt, 1, up, id, id, -ret + 1 );
	return ret;
}

int main()
{
	int op, k, N;
	read( N );
	while( N -- )
	{
		read( op );
		if( op == 1 )
		{
			read( k ), setNode( sgrt, 1, up, k, 1 );
			if( siz[1] == 1 ) 
			{ 
				fa[rt = k] = 0, update( sgrt, 1, up, k, k, 1 ); 
				puts( "1" );
				continue; 
			}
			int rnk = query( sgrt, 1, up, 1, k );
			int pre = Kth( rnk - 1 ), suf = Kth( rnk + 1 );
			int dpre = getDep( pre ), dsuf = getDep( suf );
			if( dpre > dsuf ) fa[k] = pre, ch[1][pre] = k, update( sgrt, 1, up, k, k, dpre + 1 );
			else fa[k] = suf, ch[0][suf] = k, update( sgrt, 1, up, k, k, dsuf + 1 );
			write( getDep( k ) ), putchar( '\n' );
		}
		if( op == 2 ) write( rotMn() ), putchar( '\n' );
		if( op == 3 ) write( rotMx() ), putchar( '\n' );
		if( op == 4 ) 
		{
			int ans = rotMn(), tmp = rt, y = ch[1][tmp];
			update( sgrt, 1, up, tmp + 1, up, -1 );
			update( sgrt, 1, up, tmp, tmp, - ans );
			if( y ) fa[y] = 0; ch[1][tmp] = 0, rt = y;
			setNode( sgrt, 1, up, tmp, -1 );
			write( ans ), putchar( '\n' );
		}
		if( op == 5 )
		{
			int ans = rotMx(), tmp = rt, y = ch[0][tmp];
			update( sgrt, 1, up, 1, tmp - 1, -1 );
			update( sgrt, 1, up, tmp, tmp, -ans );
			if( y ) fa[y] = 0; ch[0][tmp] = 0, rt = y;
			setNode( sgrt, 1, up, tmp, -1 );
			write( ans ), putchar( '\n' );
		}
	}
	return 0;
}
```

---


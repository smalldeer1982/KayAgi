# [AHOI2017/HNOI2017] 影魔

## 题目背景

影魔，奈文摩尔，据说有着一个诗人的灵魂。事实上，他吞噬的诗人灵魂早已成千上万。

千百年来，他收集了各式各样的灵魂，包括诗人、牧师、帝王、乞丐、奴隶、罪人，当然，还有英雄。

每一个灵魂，都有着自己的战斗力，而影魔，靠这些战斗力提升自己的攻击。

## 题目描述

奈文摩尔有 $n$ 个灵魂，他们在影魔宽广的体内可以排成一排，从左至右标号 $1$ 到 $n$。第 $i$ 个灵魂的战斗力为 $k_i$，灵魂们以点对的形式为影魔提供攻击力。对于灵魂对 $i, j\ (i<j)$ 来说，若不存在 $k_s\ (i<s<j)$ 大于 $k_i$ 或者 $k_j$，则会为影魔提供 $p_1$ 的攻击力。另一种情况，令 $c$ 为 $k_{i + 1}, k_{i + 2}, \cdots, k_{j -1}$ 的最大值，若 $c$ 满足：$k_i < c < k_j$，或者 $k_j < c < k_i$，则会为影魔提供 $p_2$ 的攻击力，当这样的 $c$ 不存在时，自然不会提供这 $p_2$ 的攻击力；其他情况的点对，均不会为影魔提供攻击力。

影魔的挚友噬魂鬼在一天造访影魔体内时被这些灵魂吸引住了，他想知道，对于任意一段区间 $[a, b]$，位于这些区间中的灵魂对会为影魔提供多少攻击力，即考虑所有满足 $a\le i<j\le b$ 的灵魂对 $i, j$ 提供的攻击力之和。

顺带一提，灵魂的战斗力组成一个 $1$ 到 $n$ 的排列：$k_1, k_1, \cdots, k_n$。

## 说明/提示

对于 $30\%$ 的数据，$1\le n, m\le 500$。

另有 $30\%$ 的数据，$p_1 = 2p_2$。

对于 $100\%$ 的数据，$1\le n,m\le 200000, 1\le p_1, p_2\le 1000$。

## 样例 #1

### 输入

```
10 5 2 3
7 9 5 1 3 10 6 8 2 4
1 7
1 9
1 3
5 9
1 5```

### 输出

```
30
39
4
13
16```

# 题解

## 作者：花样百出 (赞：86)

题解:


这个题可以采取离线处理的方式.先处理出每个点i左边第一个比它大的点L[i],和右边第一个比它大的点R[i].

那么对于区间L[i]到R[i]有p1的贡献.①

对于左端点在L[i]+1到i-1,右端点为R[i]的区间有p2的贡献.②

对于左端点为L[i],右端点为i+1到R[i]-1的区间也有p2的贡献.③

所以我们离线排序处理好.

对于①情况,我们在扫到R[i]时,更新点L[i]的贡献

对于②情况,我们在扫到R[i]时,更新区间L[i]+1到i-1的贡献

对于③情况,我们在扫到L[i]时,更新区间i+1到R[i]-1的贡献

我们对于每个询问[l,r],在扫到l-1时,我们记录此时区间l到r的每个点的贡献和为sum1,然后当我们扫到r的时候,再次记录此时的区间l到r的每个点的贡献和为sum2,显然答案就是sum2-sum1了.

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
#include<vector>
#include<set>
#define RG register
#define LL long long int
#define MAXN 500010
using namespace std;
const int INF=1e9;
struct node{
  int l,r,x,id,v;
  node(){}
  node(int l_,int r_,int x_,int id_,int v_):l(l_),r(r_),x(x_),id(id_),v(v_){}
  bool operator <(const node &tmp)const{
    return x<tmp.x;
  }
}s1[MAXN],s2[MAXN];
int n,m,p1,p2;
int k[MAXN],q[MAXN],top;
int L[MAXN],R[MAXN];
LL ans[MAXN],c1[MAXN],c2[MAXN];
int lowbit(int x)
{
  return x&(-x);
}
void add(int x,int y)//区间修改操作
{
  if(x) for(int i=x;i<=n;i+=lowbit(i)) c1[i]+=y,c2[i]+=(LL)x*y;
}
LL sum(int x)
{
  LL num=0;
  for(int i=x;i>0;i-=lowbit(i)) num+=(x+1)*c1[i]-c2[i];
  return num;
}
int main()
{
  freopen("1.in","r",stdin);
  scanf("%d%d%d%d",&n,&m,&p1,&p2);
  k[0]=k[n+1]=n+1;q[++top]=0;
  for(int i=1;i<=n;i++) scanf("%d",&k[i]);
  for(int i=1;i<=n+1;i++)
    {
      while(k[q[top]]<k[i]) R[q[top]]=i,top--;
      L[i]=q[top];q[++top]=i;
    }
  int x,y;
  for(int i=1;i<=m;i++)
    {
      scanf("%d%d",&x,&y);ans[i]+=(y-x)*p1;
      s1[i]=node(x,y,x-1,i,-1);s1[i+m]=node(x,y,y,i,1);
    }
  sort(s1+1,s1+2*m+1);int tot=0;
  for(int i=1;i<=n;i++)
    {
      if(1<=L[i]&&R[i]<=n) s2[++tot]=node(L[i],L[i],R[i],0,p1);
      if(1<=L[i]&&R[i]>i+1) s2[++tot]=node(i+1,R[i]-1,L[i],0,p2);
      if(L[i]+1<i&&R[i]<=n) s2[++tot]=node(L[i]+1,i-1,R[i],0,p2);
    }
  sort(s2+1,s2+tot+1);int n1=1,n2=1;
  while(!s1[n1].x) n1++;
  for(int i=1;n1<=m*2&&i<=n;i++)
    {
      while(n2<=tot&&s2[n2].x==i){
    add(s2[n2].r+1,-s2[n2].v);
    add(s2[n2].l,s2[n2].v);
    n2++;
      }
      while(n1<=m*2&&s1[n1].x==i){
    ans[s1[n1].id]+=s1[n1].v*(sum(s1[n1].r)-sum(s1[n1].l-1));
    n1++;
      } 
    }
  for(int i=1;i<=m;i++) printf("%lld\n",ans[i]);
  return 0;
}
```

---

## 作者：_ctz (赞：42)

感觉还是挺有思维难度的一道题。蒟蒻想了不短时间才从暴力$O(n^3)$优化到$O(nlogn)$

### 纯暴力

$O(n^3)$ 暴力枚举区间内的点对，暴力扫描区间最大值。

### 稍微好点的暴力

最大值可以用线段树维护，优化到 $O(n^2logn)$。

（其实$st$表能达到 $O(n^2)$ ，不过蒟蒻早忘了咋写了。。。总之最大值可以用数据结构优化)

### （重点！）高端的优化

似乎到上面就不是很好想了。瓶颈就在于枚举点对的 $n^2$。可不可以少枚举点东西？

一个点对 $(i,j)$ 的贡献与三个值有关：$a[i],a[j],max(a[k])(i<k<j)$

不枚举$i,j$，那就枚举中间的 $a[k]$。这里引入两个值：定义 $ll[i]$ 为**从点 $i$ 向左走，直到遇到第一个大于它的数的位置（没有则为0）**；同理，$rr[i]$就是向右走（没有则为n+1)。

也就是说，**点 $i$ 是区间$[ll[i]+1,rr[i]-1]$的最大值，且满足这个区间长度最小**。

这样，枚举这个点（记为 $i$ )的时候：（区间记为$[L,R]$）

- 如果 $ll[i]$ 与 $rr[i]$ 都在区间中，就会有一点对 $(ll[i],rr[i])$满足条件 $1$。
- 如果 $ll[i]$ 在区间中，那么每个点对 $(ll[i],k)(i<k<min(rr[i],R))$ 满足条件 $2$。（因为 $a[k]<a[i]$ ，$a[i]<a[ll[i]]$ ， $a[i]$ 为区间 $[ll[i]+1,k-1]$的最大值。注意不能走出去所以取min）
-  如果 $rr[i]$ 在区间中，那么每个点对 $(k,rr[i])(max(ll[i],L)<k<i)$ 满足条件 $2$。（原因同上）

这样就能得到 $O(n^2)$ 的做法。

### 顶级的优化

前面铺垫这么多，终于轮到正解出场了！

根据上面，我们需要一种方法，能快速得知：

- 每个 $ll[i]$ 在区间内的数的 $min(rr[i],R)-i$
- 每个 $rr[i]$ 在区间内的数的 $i-max(ll[i],L)$ 
- $ll[i]$，$rr[i]$都在区间内数的个数。

虽然有点麻烦，不过本题只有询问，是不是可以离线下来搞一搞呢？

先处理第一种。从右往左扫描数列，遇到某个数的 $ll[i]$ 再把这个数产生的贡献用某种数据结构维护起来，遇到某个询问的左端点就直接查询，这样保证了**只有 $ll[i]$ 在区间内的数才会产生贡献**。

具体来说：用线段树维护。遇到 $ll[i]$ 就把 $[i+1,rr[i]-1]$（注意不能取两端）加 $1$，遇到询问左端点就查询 $[L,R]$ 的和。仔细想想就会发现，这样也会在查询时相当于取了$min(rr[i],R)$。

第二种倒过来扫就好了。

第三种正着扫倒着扫皆可。以倒着扫为例：遇到 $ll[i]$ 把$[rr[i],n]$加 $1$（意为询问右端点落在$[rr[i],n]$都会覆盖到$rr[i]$，就有 1 贡献），这样查询时单点查 $R$ 即可。

时间复杂度：$O(nlogn)$（常数有点大最慢$1100ms+$。。。）

细节：1.关于预处理$ll$、$rr$：蒟蒻好像想复杂了，没有什么好方法，只能记录下位置，按权值排序后造棵平衡树倒着扫数列，插入每个点的位置，$ll$、$rr$分别查前驱后继。。。

2.统计的答案要开long long！

$update:$

3.有一点忘了说了：对于情况1，满足$i+1=j$同样会有贡献，而该方法统计不上，所以输出时直接加上就好。

上代码：
```cpp
#define Kafuu signed
#define Chino main

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>

#define maxn 200005
#define inf 0x3f3f3f

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
template<typename T>
inline T read(){
	T x=0;
	int y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}//快读
inline int ran(){
	static int seed=45562;
	return seed=seed*48271LL%2147483647;
}//一个优化常数的随机数函数
int a[maxn],pos[maxn],ll[maxn],rr[maxn],n;
vector<int>lq[maxn],rq[maxn],li[maxn],ri[maxn];
//分别用来存询问左端点、右端点和ll、rr的位置情况
//vector可以用链式前向星代替，常数小。不过我懒了。。。
struct Question{
	int l,r;
	long long ans;
}q[maxn];
struct Treap{
#define ls(x) ls[x]
#define rs(x) rs[x]
	int dat[maxn],ls[maxn],rs[maxn],ra[maxn],root,cnt;
	void right(int &node){
		int rec=ls(node);
		ls(node)=rs(rec);
		rs(rec)=node;
		node=rec;
	}
	void left(int &node){
		int rec=rs(node);
		rs(node)=ls(rec);
		ls(rec)=node;
		node=rec;
	}
	void insert(int &node,int d){
		if(！node){
			node=++cnt;
			dat[node]=d;
			ra[node]=ran();
			return;
		}
		if(dat[node]<d){
			insert(rs(node),d);
			if(ra[rs(node)]>ra[node])left(node);
		}
		else {
			insert(ls(node),d);
			if(ra[ls(node)]>ra[node])right(node);
		}
	}
	int getpre(int d){
		int ans=0,node=root;
		while(node){
			if(dat[node]<d)ans=max(ans,dat[node]),node=rs(node);
			else node=ls(node);
		}
		return ans;
	}
	int getnex(int d){
		int ans=n+1,node=root;
		while(node){
			if(dat[node]<d)node=rs(node);
			else ans=min(ans,dat[node]),node=ls(node);
		}
		return ans;
	}	
}tr;//平衡树
#undef ls
#undef rs
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
struct Segment_Tree{
	int dat[maxn<<2],tag[maxn<<2];
	inline void update(int node){
		dat[node]=dat[ls(node)]+dat[rs(node)];
	}
	inline void datadown(int l,int r,int node,int d){
		dat[node]+=(r-l+1)*d;
		tag[node]+=d;
	}
	inline void pushdown(int l,int r,int node){
		int mid=l+r>>1;
		datadown(l,mid,ls(node),tag[node]);
		datadown(mid+1,r,rs(node),tag[node]);
		tag[node]=0;
	}
	void add(int L,int R,int l,int r,int node){
		if(L<=l&&R>=r){
			dat[node]+=r-l+1;
			++tag[node];
			return;
		}
		if(tag[node])pushdown(l,r,node);
		int mid=l+r>>1;
		if(L<=mid)add(L,R,l,mid,ls(node));
		if(R>mid)add(L,R,mid+1,r,rs(node));
		update(node);
	}
	long long ask(int L,int R,int l,int r,int node){
		if(L<=l&&R>=r)return (long long)dat[node];
		if(tag[node])pushdown(l,r,node);
		int mid=l+r>>1;
		long long ans=0;
		if(L<=mid)ans=ask(L,R,l,mid,ls(node));
		if(R>mid)ans+=ask(L,R,mid+1,r,rs(node));
		return ans;
	}
}st1,st2,st3;//空间够大开三棵线段树QwQ
Kafuu Chino(){
	n=read();
	int m=read();
	long long p1=read<long long>(),p2=read<long long>();
	for(register int i=1;i<=n;++i){
		a[i]=read();
		pos[a[i]]=i;
	}
	sort(a+1,a+1+n);
	for(register int i=n;i;--i){
		int L=tr.getpre(pos[a[i]]),R=tr.getnex(pos[a[i]]);
		ll[pos[a[i]]]=L;
		rr[pos[a[i]]]=R;
		if(L!=-inf)li[L].push_back(pos[a[i]]);
		if(R!=inf)ri[R].push_back(pos[a[i]]);
		tr.insert(tr.root,pos[a[i]]);	
	}
	for(register int i=1;i<=m;++i)
		q[i].l=read(),q[i].r=read(),lq[q[i].l].push_back(i),rq[q[i].r].push_back(i);
	for(register int i=n;i;--i){
		for(register int j=0;j<li[i].size();++j){
			if(li[i][j]+1<rr[li[i][j]])st1.add(li[i][j]+1,rr[li[i][j]]-1,0,n+1,1);
			st3.add(rr[li[i][j]],n+1,0,n+1,1);
		}
		for(register int j=0;j<lq[i].size();++j)
			q[lq[i][j]].ans+=st1.ask(i,q[lq[i][j]].r,0,n+1,1)*p2+st3.ask(q[lq[i][j]].r,q[lq[i][j]].r,0,n+1,1)*p1;
	}
	for(register int i=1;i<=n;++i){
		for(register int j=0;j<ri[i].size();++j)
			if(ll[ri[i][j]]+1<ri[i][j])st2.add(ll[ri[i][j]]+1,ri[i][j]-1,0,n+1,1);
		for(register int j=0;j<rq[i].size();++j)
			q[rq[i][j]].ans+=st2.ask(q[rq[i][j]].l,i,0,n+1,1)*p2;
	}
	for(register int i=1;i<=m;++i)
		printf("%d\n",q[i].ans+(long long)(q[i].r-q[i].l)*p1);
}

```















---

## 作者：yybyyb (赞：21)

首先把两种贡献换成人话：

如果对于两个位置$l,r$

他们是区间$[l,r]$中的最大值和次大值，产生$p1$的贡献
如果恰好有一个是最大值，产生$p2$的贡献

那么，对于当前位置$i$，假设左/右第一个比他大的位置是$l,r$

那么，$(l,r)$产生$p1$的贡献

$(l+1..i-1,r),(l,i+1..r-1)$会产生$p2$的贡献


可以把他分解为二维平面内的矩阵求和问题，这个可以用扫描线来解决

当然，主要的问题是怎么转换为二维平面求矩阵和。。。

我们算的是当前加上了位置$i$以后产生的贡献

如果对于一个询问$L,R$，$i$在其范围内，当然就要考虑它产生的贡献


那么，$i$产生的贡献是什么？

将一个位置$i$拆分成$3$个贡献：

当加入完位置$R[i]$之后，要对于$L[i]$产生$p1$的贡献

当加入完位置$L[i]$之后，要对于$(i,R[i])$的每个位置产生$p2$的贡献



当加入完位置$R[i]$之后，要对于$(L[i],i)$的每个位置产生$p2$的贡献

那么，一个询问$L,R$，只要考虑它范围内的贡献

因此拆分成三部分

加入完$L-1$位置之后，要忽略掉前面所有$L,R$位置产生的贡献

加入完$R$位置之后，要考虑所有的$L,R$位置产生的贡献
额外考虑每一组范围内的，$(i,i+1)$产生的贡献$p1$

这样子，扫描线+区间加法+区间求和即可

可以用单调栈+树状数组实现。
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define ll long long
#define RG register
#define MAX 222222
inline int read()
{
    RG int x=0,t=1;RG char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
int L[MAX],R[MAX];
int a[MAX],n,m,p1,p2;
int S[MAX],top,cnt,tot;
struct Line{int x,l,r,v;}p[MAX<<2];
bool operator<(Line a,Line b){return a.x<b.x;}
struct query{int x,l,r,v,id;}q[MAX<<2];
bool operator<(query a,query b){return a.x<b.x;}
ll c1[MAX],c2[MAX],ans[MAX];
void Modify(int x,int w)
{
	for(int i=x;i<=n;i+=i&(-i))
		c1[i]+=w,c2[i]+=x*w;
}
ll Query(int x)
{
	ll ret=0;
	for(int i=x;i;i-=i&(-i))
		ret+=(x+1)*c1[i]-c2[i];
	return ret;
}
int main()
{
	n=read();m=read();p1=read();p2=read();
	for(int i=1;i<=n;++i)a[i]=read();
	S[top=0]=0;
	for(int i=1;i<=n;++i)
	{
		while(top&&a[S[top]]<a[i])--top;
		L[i]=S[top];S[++top]=i;
	}
	S[top=0]=n+1;
	for(int i=n;i>=1;--i)
	{
		while(top&&a[S[top]]<a[i])--top;
		R[i]=S[top];S[++top]=i;
	}
	for(int i=1;i<=m;++i)
	{
		int l=read(),r=read();ans[i]=(r-l)*p1;
		q[++cnt]=(query){r,l,r,1,i};
		q[++cnt]=(query){l-1,l,r,-1,i};
	}
	sort(&q[1],&q[cnt+1]);
	for(int i=1;i<=n;++i)
	{
		if(L[i]&&R[i]<n+1)p[++tot]=(Line){R[i],L[i],L[i],p1};
		if(L[i]&&R[i]>i+1)p[++tot]=(Line){L[i],i+1,R[i]-1,p2};
		if(L[i]+1<i&&R[i]<n+1)p[++tot]=(Line){R[i],L[i]+1,i-1,p2};
	}
	sort(&p[1],&p[tot+1]);
	for(int i=1,j=1;i<=cnt;++i)
	{
		while(j<=tot&&p[j].x<=q[i].x)
		{
			Modify(p[j].l,p[j].v);
			Modify(p[j].r+1,-p[j].v);
			++j;
		}
		ans[q[i].id]+=q[i].v*(Query(q[i].r)-Query(q[i].l-1));
	}
	for(int i=1;i<=m;++i)printf("%lld\n",ans[i]);
	return 0;
}

```



---

## 作者：楠枫 (赞：12)

本题可以采用主席树的在线做法，只不过常数会 $super$ 大。

和其他题解差不多，我们先要求出第 $i$ 个数的 $l_i$ 和 $r_i$ ，其中 $l_i$ 表示左边第一个比它大的点(若没有则为 $0$ )， $r_i$ 表示右边比它大的第一个点，若没有则为 $n+1$ 。

那么对于 $i$   
1. 点对 $(l_i,r_i)$ 可以有 $p_1$ 的贡献  

2. 点对 $([l_i+1,i-1],r_i),(l_i,[i+1,r_i-1])$ 可以有 $p_2$ 的贡献 $(l_i+1<i-1),(i+1<r_i-1)$  

3. $(i,i+1)$ 也可以有 $p_1$ 的贡献

有了这么几点，我们就可以拿主席树来维护，对于每个点对，我们以 $x$ 更新，若 $x$ 为区间，则以 $y$ 更新。

用一个单调栈预处理，链表（或 $vector$ 存储更新信息）。

$AC \kern 0.4emCODE$:
```cpp
#include<bits/stdc++.h>
#define ri register int
#define p(i) ++i
#define LL long long
using namespace std;
const int N=2e5+7;
inline int read() {
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
struct node{
	int l,r,w;
	node(){}
	node(int l,int r,int w):l(l),r(r),w(w){}
};
struct E{
	int first[N],t;
	void init() {t=1;}
	struct edge{
		int nxt;
		node v;
	}e[N<<2];
	inline void add(int u,node v) {
		e[t].v=v;
		e[t].nxt=first[u];
		first[u]=t++;
	} 
}E;
struct Seg{
	int root[N],tot;
	struct Segmenttree{
		int l,r;
		LL sum,tag;
	}T[N*32];
	inline void update(int &x,int l,int r,int lt,int rt,int w) {
		if (!x) x=p(tot);
		T[x].sum+=1ll*(min(r,rt)-max(l,lt)+1)*w;
		if (l<=lt&&rt<=r) {T[x].tag+=1ll*w;return;}
		int mid=(lt+rt)>>1;
		if (l<=mid) update(T[x].l,l,r,lt,mid,w);
		if (r>mid) update(T[x].r,l,r,mid+1,rt,w);
	}
	inline int merge(int x,int y) {
		if (!x||!y) return x+y;
		T[x].sum+=T[y].sum;T[x].tag+=T[y].tag;
		T[x].l=merge(T[x].l,T[y].l);
		T[x].r=merge(T[x].r,T[y].r);
		return x;
	}
	inline LL query(int x,int l,int r,int lt,int rt) {
		if (!x) return 0;
		if (l<=lt&&rt<=r) return T[x].sum;
		int mid=(lt+rt)>>1;LL res=0;
		if (l<=mid) res+=query(T[x].l,l,r,lt,mid);
		if (r>mid) res+=query(T[x].r,l,r,mid+1,rt);
		return res+1ll*(min(r,rt)-max(l,lt)+1)*T[x].tag;
	}
}T;
int n,st[N],p,pp,at[N],ll[N],rr[N],m;
int main() {
	n=read(),m=read(),p=read(),pp=read();
	const int p1=p,p2=pp;
	int tp=0;
	for (ri i(1);i<=n;p(i)) {
		at[i]=read();
		while(tp&&at[st[tp]]<at[i]) rr[st[tp--]]=i;
		ll[i]=st[tp];
		st[p(tp)]=i;
	}
	while(tp) rr[st[tp--]]=n+1;
	E.init();
	for (ri i(1);i<=n;p(i)) {
		if (i!=n) E.add(i,node(i+1,i+1,p1));
		if (ll[i]&&rr[i]<=n) E.add(ll[i],node(rr[i],rr[i],p1));
		if (ll[i]&&i+1<=rr[i]-1) E.add(ll[i],node(i+1,rr[i]-1,p2));
		if (rr[i]<=n&&ll[i]+1<=i-1) E.add(rr[i],node(ll[i]+1,i-1,p2));
	}
	for (ri i(1);i<=n;p(i)) {
		for (ri j(E.first[i]);j;j=E.e[j].nxt) {
			node v=E.e[j].v;
			int l=v.l,r=v.r,w=v.w;
			T.update(T.root[i],l,r,1,n,w);
		}
		T.root[i]=T.merge(T.root[i],T.root[i-1]);
	}
	for (ri i(1);i<=m;p(i)) {
		int l=read(),r=read();
		printf("%lld\n",T.query(T.root[r],l,r,1,n)-T.query(T.root[l-1],l,r,1,n));
	}
	return 0;
}
```

---

## 作者：御坂17379号 (赞：6)

这里给出一种线性做法。

考虑把点对分成第一个小和第二个小的情况，以下只考虑第一个小的情况，另一种情况是相似的。

考虑所有产生贡献的点对一定是某个点作为左端点与从他开始的前缀 max 点作为右端点，其中最近的一个贡献为 p1，其他为 p2。

因此可以使用单调栈求出以某个点为左端点的点对贡献和与以某个点作为右端点的点对贡献和，这样我们解决了全局的询问。

在区间询问中，我们考虑找到区间的最大值，这样区间中的所有点对一定不会跨过这个最大值。以最大值左侧的点作为左端点，其前缀 max 序列在区间中最后一个就是最大值，因此两者的全局贡献和相减即为它在区间中的贡献。若以最大值右侧的点作为右端点，直接考虑以它为右端点的所有点对即可。

综上，我们使用一个 $O(n)-O(1)$ RMQ 求出最大值后，将单调栈求出的两种贡献值作区间和即可

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,p1,p2,a[210000];
int lowbit[410000],lg[21000];
void init_binary(){
	lg[0]=-1;
	for(int i=1;i<=400000;i++)lowbit[i]=(i&1)?0:lowbit[i>>1]+1;
	for(int i=1;i<=20000;i++)lg[i]=lg[i>>1]+1;
}
#define _s_maxx(l,r) (l+lowbit[h[r]>>l-bl[block[l]]])
int get(int x,int y){return a[x]>a[y]?x:y;}
struct RMQ{
	int bsz,block[210000],bl[210000],h[210000],st[21000][21],sta[21],top;
	void init(int* a,int len){
		bsz=__lg(len)+1;
		for(int i=1;i<=len;i++){
			block[i]=(i-1)/bsz+1;
			if(block[i-1]!=block[i]){
				st[block[i]-1][0]=sta[1];
				bl[block[i]]=i,h[i]=1,sta[top=1]=i;
			}else{
				while(top&&a[i]>a[sta[top]])top--;
				h[i]=h[sta[top]]|(1<<i-bl[block[i]]);
				sta[++top]=i;
			}
		}
		st[block[len]][0]=sta[1];
		for(int j=1;j<=20;j++){
			for(int i=block[len]+1-(1<<j);i>=1;i--)
				st[i][j]=get(st[i][j-1],st[i+(1<<j-1)][j-1]);
		}
	}
	int maxx(int* a,int l,int r){
		int lb=block[l],rb=block[r];
		if(lb==rb)return _s_maxx(l,r);
		if(rb-lb==1)return get(_s_maxx(l,bl[lb+1]-1),_s_maxx(bl[rb],r));
		int k=lg[rb-lb-1];
		return get(get(_s_maxx(l,bl[lb+1]-1),_s_maxx(bl[rb],r)),get(st[lb+1][k],st[rb-(1<<k)][k]));
	}
}T;
int sta[210000],top;
int vals1[210000],valp1[210000],nums1[210000],nump1[210000];
int vals2[210000],valp2[210000],nums2[210000],nump2[210000];
signed main(){
	scanf("%lld%lld%lld%lld",&n,&m,&p1,&p2);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	init_binary();T.init(a,n);
	for(int i=n;i>=1;i--){
		while(top&&a[sta[top]]<a[i])nump2[i]+=nump2[sta[top]]+1,valp2[i]+=p1-p2,top--;
		sta[++top]=i,valp2[i]+=nump2[i]*p2;
		nums1[i]=top-1,vals1[i]=(top==1)?0:p1+(top-2)*p2;
	}
	top=0;
	for(int i=1;i<=n;i++){
		while(top&&a[sta[top]]<a[i])nump1[i]+=nump1[sta[top]]+1,valp1[i]+=p1-p2,top--;
		sta[++top]=i,valp1[i]+=nump1[i]*p2;
		nums2[i]=top-1,vals2[i]=(top==1)?0:p1+(top-2)*p2;
	}
	for(int i=1;i<=n;i++)valp1[i]+=valp1[i-1],valp2[i]+=valp2[i-1],vals2[i]+=vals2[i-1],vals1[i]+=vals1[i-1];
	for(int i=1,l,r;i<=m;i++){
		scanf("%lld%lld",&l,&r);int p=T.maxx(a,l,r);
		int ans=0;
		ans+=vals1[p-1]-vals1[l-1]-(p-l)*nums1[p]*p2+valp1[r]-valp1[p];
		ans+=vals2[r]-vals2[p]-(r-p)*nums2[p]*p2+valp2[p-1]-valp2[l-1];
		printf("%lld\n",ans);
	}
}
```

---

## 作者：ycyaw (赞：6)

首先整个序列是一个排列，这是一个很重要的性质

考虑$(i,j)$什么时候会产生贡献：

1. 当$k_i,k_j$为区间$(i,j)$的最大值和次大值，贡献为$p1$
2. 当$k_i,k_j$其中一个为区间最大值，另一个不是次大值，贡献为$p2$

维护出每个$i$位置左边右边第一个比它大的位置，记作$L_i,R_i$，这个可以用单调栈求。于是$(L_i,R_i)$，$(i,i+1)$的贡献为$p1$，$(L_i+1...i-1,R_i)$，$(L_i,i+1...R_i-1)$的贡献为$p2$

可以发现如果有$(p,q)$满足$p<L_i,q>R_i$，$(p,q)$如果有贡献，则会算在另一个$i$上，所以不会算重

对于$(i,i+1)$，直接根据询问区间长度算贡献

对于$(L_i,R_i)$，我们在枚举到$R_i$时在$L_i$上加上贡献

对于$(L_i+1...i-1,R_i)$，我们在枚举到$R_i$时在$L_i+1...i-1$这段区间加上贡献

对于$(L_i,i+1...R_i)$，同上一条

回答一个询问$[a,b]$时，如果在枚举到$b$时直接求$[a,b]$的区间和，会存在一些$(i,j)$满足$i<a,a<j<b$的不合法的贡献。所以我们需要减去枚举到$a-1$时$[a,b]$的区间和，这样有贡献的$(i,j)$就都在区间内

$Code\ Below:$
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define int long long
#define hh puts("")
#define pc putchar
#define ls(x) ((x)<<1)
#define rs(x) ((x)<<1|1)
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
//char buf[1<<21],*p1=buf,*p2=buf;
using namespace std;
const int N=200005;
int n,m,p1,p2,a[N],st[N],top,L[N],R[N],cnt,tot;
int tr[N<<2],tag[N<<2],ans[N];
struct que{
	int x,l,r,v,id;
	friend bool operator < (que A,que B){
		return A.x<B.x;
	}
}q[N<<1];
struct ope{
	int x,l,r,v;
	friend bool operator < (ope A,ope B){
		return A.x<B.x;
	}
}op[N<<2];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-1;ch=getchar();}
    while(isdigit(ch)){ret=ret*10+(ch^48);ch=getchar();}
    return ret*ff;
}
void write(int x){if(x<0){x=-x,pc('-');}if(x>9) write(x/10);pc(x%10+48);}
void writeln(int x){write(x),hh;}
void writesp(int x){write(x),pc(' ');}
void push_down(int l,int r,int k){
	int mid=(l+r)>>1;
	tag[ls(k)]+=tag[k];
	tag[rs(k)]+=tag[k];
	tr[ls(k)]+=tag[k]*(mid-l+1);
	tr[rs(k)]+=tag[k]*(r-mid);
	tag[k]=0;
}
void update(int l,int r,int x,int y,int v,int k){
	if(x<=l&&r<=y){
		tr[k]+=(r-l+1)*v;
		tag[k]+=v;
		return;
	}
	push_down(l,r,k);
	int mid=(l+r)>>1;
	if(x<=mid) update(l,mid,x,y,v,ls(k));
	if(mid+1<=y) update(mid+1,r,x,y,v,rs(k));
	tr[k]=tr[ls(k)]+tr[rs(k)];
}
int query(int l,int r,int x,int y,int k){
	if(x<=l&&r<=y) return tr[k];
	push_down(l,r,k);
	int mid=(l+r)>>1,res=0;
	if(x<=mid) res+=query(l,mid,x,y,ls(k));
	if(mid+1<=y) res+=query(mid+1,r,x,y,rs(k));
	return res;
}
signed main(){
	n=read(),m=read(),p1=read(),p2=read();
	for(int i=1;i<=n;i++) a[i]=read();
	st[top=0]=0;
	for(int i=1;i<=n;i++){
		while(top&&a[i]>a[st[top]]) top--;
		L[i]=st[top];st[++top]=i;
	}
	st[top=0]=n+1;
	for(int i=n;i>=1;i--){
		while(top&&a[i]>a[st[top]]) top--;
		R[i]=st[top];st[++top]=i;
	}
	for(int i=1;i<=m;i++){
		int l=read(),r=read();ans[i]=(r-l)*p1;//(i,i+1)的贡献 
		q[++cnt]=(que){l-1,l,r,-1,i};
		q[++cnt]=(que){r,l,r,1,i};
	}
	sort(q+1,q+cnt+1);
	for(int i=1;i<=n;i++){
		if(L[i]>=1&&R[i]<=n) op[++tot]=(ope){R[i],L[i],L[i],p1};
		if(L[i]>=1&&R[i]-1>=i+1) op[++tot]=(ope){L[i],i+1,R[i]-1,p2};
		if(L[i]+1<=i-1&&R[i]<=n) op[++tot]=(ope){R[i],L[i]+1,i-1,p2};
	}
	sort(op+1,op+tot+1);
	for(int i=1,j=1;i<=cnt;i++){
		while(j<=tot&&op[j].x<=q[i].x){
			update(1,n,op[j].l,op[j].r,op[j].v,1);
			j++;
		}
		ans[q[i].id]+=q[i].v*query(1,n,q[i].l,q[i].r,1);
	}
	for(int i=1;i<=m;i++) writeln(ans[i]);
    return 0;
}
```


---

## 作者：老K (赞：6)

推广一发[老K的博客](https://cnyali-lk.com)

我们先不考虑p1，考虑一个点对如果有任意一个点的权值大于之间的所有点权，那么就有p2的贡献。

那么p1会算为2个p2.


怎么枚举呢？

先考虑单侧，另一侧反过来即可。

用单调栈记录每个点x后面第一个比它大的z。

那么$x<y\le z$的所有y都满足(x,y)有p2的贡献（显然）

~~然后这样就完了~~你成功的获得了30分也就是p1=2p2的部分。

由于点权组成了排列，不存在有2个点点权相等。

那么对于p1的贡献，显然只可能一边是最大值一边是次大值。

那么我们在上面找到z的时候，显然$(x,z)$点对的贡献应该是p1，但是会被算为2p2，那么直接加上$p1-2p2$的贡献即可。

具体怎么算呢？

先把询问按照左端点排序。

枚举x从n到1，然后找到z，对于每个点对(x,y)的贡献，直接加在y上。然后对于所有左端点为x的询问，直接求l到r的贡献和即可。

```C++
/*
Author: CNYALI_LK
LANG: C++
PROG: 3722.cpp
Mail: cnyalilk@vip.qq.com
*/
#include<bits/stdc++.h>
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define DEBUG printf("Passing [%s] in LINE %lld\n",__FUNCTION__,__LINE__)
#define Debug debug("Passing [%s] in LINE %lld\n",__FUNCTION__,__LINE__)
#define all(x) x.begin(),x.end()
using namespace std;
const double eps=1e-8;
const double pi=acos(-1.0);
typedef long long ll;
typedef pair<ll,ll> pii;
template<class T>ll chkmin(T &a,T b){return a>b?a=b,1:0;}
template<class T>ll chkmax(T &a,T b){return a<b?a=b,1:0;}
template<class T>T sqr(T a){return a*a;}
template<class T>T mmin(T a,T b){return a<b?a:b;}
template<class T>T mmax(T a,T b){return a>b?a:b;}
template<class T>T aabs(T a){return a<0?-a:a;}
#define min mmin
#define max mmax
#define abs aabs
ll read(){
    ll s=0,base=1;
    char c;
    while(!isdigit(c=getchar()))if(c=='-')base=-base;
    while(isdigit(c)){s=s*10+(c^48);c=getchar();}
    return s*base;
}
char WritellBuffer[1024];
template<class T>void write(T a,char end){
    ll cnt=0,fu=1;
    if(a<0){putchar('-');fu=-1;}
    do{WritellBuffer[++cnt]=fu*(a%10)+'0';a/=10;}while(a);
    while(cnt){putchar(WritellBuffer[cnt]);--cnt;}
    putchar(end);
}
struct _ask{
    ll t,l,r;
    _ask(){}
    _ask(ll _t){
        t=_t;
        l=read();r=read();
    }
};
_ask ask[204847];

ll n,m,p1,p2;
ll a[204847];
struct smt{
    smt *l,*r;
    ll _l,_r,sum,add;
#define push_up sum=l->sum+r->sum
    smt(ll ls,ll rs){
        _l=ls;_r=rs;
        sum=add=0;
        if(ls!=rs){
            ll mid=(ls+rs)>>1;
            l=new smt(ls,mid);
            r=new smt(mid+1,rs);
        }
    }
    void put_tag(ll w){
        sum+=w*(_r-_l+1);
        add+=w;
    }
    void push_down(){
        l->put_tag(add);
        r->put_tag(add);
        add=0;
    }
    void change(ll ls,ll rs,ll w){
        if(ls<=_l&&_r<=rs)put_tag(w);
        else{
            push_down();
            if(ls<=l->_r)l->change(ls,rs,w);
            if(rs>=r->_l)r->change(ls,rs,w);
            push_up;
        }
    }
    ll query(ll ls,ll rs){
        if(ls<=_l&&_r<=rs)return sum;
        else{
            push_down();
            ll ans=0;
            if(ls<=l->_r)ans+=l->query(ls,rs);
            if(rs>=r->_l)ans+=r->query(ls,rs);
            return ans;
        }
    }
};
ll nx[204847],ans[204847];
void calc(){
    sort(ask+1,ask+m+1,[](_ask a,_ask b){return a.l<b.l;});
    stack<ll> stk;
    stk.push(n+1);
    smt *r=new smt(1,n+1);
    ll j=m;
    for(ll i=n;i;--i){
        while(a[stk.top()]<a[i])stk.pop();
        nx[i]=stk.top();
        stk.push(i);
        r->change(i+1,nx[i],p2);
        r->change(nx[i],nx[i],p1-2*p2);
        while(ask[j].l==i){
            ans[ask[j].t]+=r->query(ask[j].l,ask[j].r);
            --j;
        }
    }
}
int main(){
#ifdef cnyali_lk
    freopen("3722.in","r",stdin);
    freopen("3722.out","w",stdout);
#endif
    n=read();
    m=read();p1=read();p2=read();
    for(ll i=1;i<=n;++i)a[i]=read();
    a[n+1]=n+1;
    for(ll i=1;i<=m;++i){
         ask[i]=_ask(i);
    }
    calc();
    reverse(a+1,a+n+1);
    for(ll i=1;i<=m;++i){ask[i].l=n+1-ask[i].l;ask[i].r=n+1-ask[i].r;swap(ask[i].l,ask[i].r);}
    calc();
    for(ll i=1;i<=m;++i)write(ans[i],'\n');
    return 0;
}


```







---

## 作者：tzc_wk (赞：4)

安利个人 blog：https://www.cnblogs.com/ET2006/

[题面传送门](https://www.luogu.com.cn/problem/P3722)

首先我们把这两个贡献翻译成人话：

- 区间 $[l,r]$ 产生 $p_1$ 的贡献当且仅当 $a_l,a_r$ 分别为区间 $[l,r]$ 的最大值和次大值。
- 区间 $[l,r]$ 产生 $p_2$ 的贡献当且仅当 $a_l$ 为区间 $[l,r]$ 的最大值且 $a_r$ 不是区间 $[l,r]$ 的次大值，或者 $a_r$ 为区间 $[l,r]$ 的最大值且 $a_l$ 不是区间 $[l,r]$ 的次大值。

我们考虑转化贡献体，对于每个区间 $[l,r]$ 分两种情况：

- 若 $r-l=1$，那么显然所有这样的区间都会产生 $p_1$ 的贡献，这个我们特判一下即可。
- 若 $r-l\ge 2$，那么显然对于区间 $[l+1,r-1]$ 有一个唯一的最大值，设其位置为 $i$，于是我们改枚举 $i$，看看它会对哪些区间产生贡献。

我们设 $L_i$ 为在 $i$ 前面的最靠近 $i$ 的满足 $a_j>a_i$ 的 $j$，$R_i$ 为在 $i$ 后面的最靠近 $i$ 的满足 $a_j>a_i$ 的 $j$，这个显然可以一遍单调栈求出，然后分情况讨论：

- 若 $i$ 为区间 $[l+1,r-1]$ 的最大值，且区间 $[l,r]$ 产生 $p_1$ 的贡献，那显然只能是 $l=L_i,r=R_i$，因为如果左端点 $l>L_i$ 那 $a_l$ 就不是 $[l,r]$ 的较大值（或次大值）了（因为 $a_l<a_i$），如果左端点 $l<L_i$ 那 $a_i$ 就不是 $[l+1,r-1]$ 的最大值了（因为 $a_{L_i}>a_i$）；右端点同理。
- 若 $i$ 为区间 $[l+1,r-1]$ 的最大值，且区间 $[l,r]$ 产生 $p_2$ 的贡献，那我们分最大值在左端点处和最大值在右端点处两种情况。这里以最大值在左端点处为例，显然 $l=L_i$，而右端点理论上来说可以取遍 $(L_i,R_i)$ 中所有值，而我们强制 $i$ 为区间 $[l+1,r-1]$ 的最大值，故 $r\in(i,R_i)$。也就是说 $l=L_i,r\in(i,R_i)$，另一半同理可得 $r=R_i,l\in(L_i,i)$。

考虑借鉴 P5445 [APIO2019]路灯 的套路，建立二维平面直角坐标系，点 $(i,j)$ 表示以 $i,j$ 为端点的区间的贡献，那么显然对于每组询问我们只需求出以 $(l,l)$ 左下角，$(r,r)$ 为右下角的矩形中所有数的和。而显然上面的贡献都可转化为”纵坐标为 $y$，横坐标在区间 $[l,r]$ 中的点的贡献增加 $v$ 的形式“。那么显然我们可以把询问进行差分处理，并离线扫描线+线段树回答每个询问，复杂度线对。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define fz(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
#define ffe(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define fill0(a) memset(a,0,sizeof(a))
#define fill1(a) memset(a,-1,sizeof(a))
#define fillbig(a) memset(a,63,sizeof(a))
#define pb push_back
#define ppb pop_back
#define mp make_pair
template<typename T1,typename T2> void chkmin(T1 &x,T2 y){if(x>y) x=y;}
template<typename T1,typename T2> void chkmax(T1 &x,T2 y){if(x<y) x=y;}
typedef pair<int,int> pii;
typedef long long ll;
template<typename T> void read(T &x){
	x=0;char c=getchar();T neg=1;
	while(!isdigit(c)){if(c=='-') neg=-1;c=getchar();}
	while(isdigit(c)) x=x*10+c-'0',c=getchar();
	x*=neg;
}
const int MAXN=2e5;
int n,m,qu=0,p1,p2,a[MAXN+5],L[MAXN+5],R[MAXN+5];
struct node{int l,r;ll sum,lz;} s[MAXN*4+5];
void build(int k,int l,int r){
	s[k].l=l;s[k].r=r;if(l==r) return;
	int mid=(l+r)>>1;build(k<<1,l,mid);build(k<<1|1,mid+1,r);
}
void pushdown(int k){
	if(s[k].lz){
		s[k<<1].sum+=1ll*(s[k<<1].r-s[k<<1].l+1)*s[k].lz;s[k<<1].lz+=s[k].lz;
		s[k<<1|1].sum+=1ll*(s[k<<1|1].r-s[k<<1|1].l+1)*s[k].lz;s[k<<1|1].lz+=s[k].lz;
		s[k].lz=0;
	}
}
void modify(int k,int l,int r,int x){
	if(l<=s[k].l&&s[k].r<=r){
		s[k].sum+=1ll*x*(s[k].r-s[k].l+1);
		s[k].lz+=x;return;
	} pushdown(k);int mid=(s[k].l+s[k].r)>>1;
	if(r<=mid) modify(k<<1,l,r,x);
	else if(l>mid) modify(k<<1|1,l,r,x);
	else modify(k<<1,l,mid,x),modify(k<<1|1,mid+1,r,x);
	s[k].sum=s[k<<1].sum+s[k<<1|1].sum;
}
ll query(int k,int l,int r){
	if(l<=s[k].l&&s[k].r<=r) return s[k].sum;
	pushdown(k);int mid=(s[k].l+s[k].r)>>1;
	if(r<=mid) return query(k<<1,l,r);
	else if(l>mid) return query(k<<1|1,l,r);
	else return query(k<<1,l,mid)+query(k<<1|1,mid+1,r);
}
vector<pair<pii,int> > add[MAXN+5];
stack<pii> stk;ll ans[MAXN+5];
struct query{
	int x,l,r,p,t;
	bool operator <(const query &rhs){return x<rhs.x;}
} q[MAXN*2+5];
int main(){
	scanf("%d%d%d%d",&n,&m,&p1,&p2);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++){
		while(!stk.empty()&&stk.top().fi<a[i]) R[stk.top().se]=i,stk.pop();
		stk.push(mp(a[i],i));
	} while(!stk.empty()) R[stk.top().se]=n+1,stk.pop();
	for(int i=n;i;i--){
		while(!stk.empty()&&stk.top().fi<a[i]) L[stk.top().se]=i,stk.pop();
		stk.push(mp(a[i],i));
	} while(!stk.empty()) L[stk.top().se]=0,stk.pop();
	for(int i=1;i<=n;i++){
		if(L[i]&&R[i]!=n+1) add[L[i]].pb(mp(mp(R[i],R[i]),p1));
		if(L[i]&&R[i]!=i+1) add[L[i]].pb(mp(mp(i+1,R[i]-1),p2));
		if(R[i]!=n+1&&L[i]!=i-1) add[R[i]].pb(mp(mp(L[i]+1,i-1),p2));
	}
	for(int i=1;i<=m;i++){
		int l,r;scanf("%d%d",&l,&r);ans[i]+=1ll*(r-l)*p1;
		q[++qu]={r,l,r,i,1};q[++qu]={l-1,l,r,i,-1};
	} build(1,1,n);
	sort(q+1,q+qu+1);int cur=1;
	for(int i=1;i<=qu;i++){
		while(cur<=q[i].x){
			ffe(it,add[cur]) modify(1,it->fi.fi,it->fi.se,it->se);
			cur++;
		} ans[q[i].p]+=q[i].t*query(1,q[i].l,q[i].r);
	}
	for(int i=1;i<=m;i++) printf("%lld\n",ans[i]);
	return 0;
}
```



---

## 作者：xudaxia (赞：4)

设$l[i]$为i左边第一个比i大的数的下标。$r[i]$为i右边第一个比i大的数的下标。  
我们把$p1,p2$分开考虑。  
当产生贡献为$p1$时$i$和$j$一定满足，分别为$l[x],r[x]$枚举每一个值为$i$，$j$之间最大值可证。  
党产生贡献为$p2$时$i$和$j$满足分别为$l[x],[x+1,r[x]-1]$或$[l[x]+1,x-1],r[x]$，此时$a[x]$为$i$，$j$之间最大值，$i$，$j$一个比$a[x]$大，一个比$a[x]$小。  
然后就把问题转化为二维数点问题。产生贡献的点对对应坐标系中的一个点（为了避免重复计数如$(r[x],l[x])$和$(l[x],r[x])$，可以把小的作为横坐标，大的作为纵坐标）。然后我们每一次询问就是横坐标在$[l,r]$之间，纵坐标在$[l,r]$之间的权值和。  
然后就可以用主席树做了。
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<vector>
using namespace std;
#define int long long
const int N=201000; 
struct line{ int l,r,w; }; 
vector<line> vec[N]; 
int tot,root[N],lazy[N*70],ch[N*70][2],sum[N*70]; 
int n,m,p1,p2,a[N],stack[N],top,l[N],r[N]; 
void add(int l,int r,int L,int R,int w,int pre,int &now){ 
	now=++tot;
	ch[now][0]=ch[pre][0]; 
	ch[now][1]=ch[pre][1]; 
	lazy[now]=lazy[pre]; 
	sum[now]=sum[pre]+(R-L+1)*w; 
	if(l==L&&r==R){ 
		lazy[now]+=w; 
		return; 
	} 
	int mid=(l+r)>>1; 
	if(L>mid)add(mid+1,r,L,R,w,ch[pre][1],ch[now][1]); 
	else if(R<=mid)add(l,mid,L,R,w,ch[pre][0],ch[now][0]); 
	else{ 
		add(l,mid,L,mid,w,ch[pre][0],ch[now][0]); 
		add(mid+1,r,mid+1,R,w,ch[pre][1],ch[now][1]); 
	} 
} 
int check(int l,int r,int L,int R,int pre,int now){ 
	if(l==L&&r==R)return sum[now]-sum[pre]; 
	int mid=(l+r)>>1; 
	if(L>mid)return (lazy[now]-lazy[pre])*(R-L+1)+check(mid+1,r,L,R,ch[pre][1],ch[now][1]);
    else if(R<=mid)return (lazy[now]-lazy[pre])*(R-L+1)+check(l,mid,L,R,ch[pre][0],ch[now][0]); 
	else return (lazy[now]-lazy[pre])*(R-L+1) 
	+check(l,mid,L,mid,ch[pre][0],ch[now][0]) 
	+check(mid+1,r,mid+1,R,ch[pre][1],ch[now][1]);
} 
int read(){ 
	int sum=0,f=1;char ch=getchar(); 
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();} 
	while(ch>='0'&&ch<='9'){sum=sum*10+ch-'0';ch=getchar();} 
	return sum*f; 
} 
signed main(){ 
	n=read(),m=read(),p1=read(),p2=read(); 
	for(int i=1;i<=n;i++)a[i]=read(); 
	for(int i=1;i<=n;i++){ 
		while(a[i]>a[stack[top]]&&top)r[stack[top--]]=i; 
		stack[++top]=i; 
	} 
	while(top)r[stack[top--]]=n+1; 
	for(int i=n;i>=1;i--){ 
		while(a[i]>a[stack[top]]&&top)l[stack[top--]]=i; 
		stack[++top]=i; 
	} 
	while(top)l[stack[top--]]=0; 
	for(int i=1;i<=n;i++){
		line x; 
		if(i!=n&&i+1<=r[i]-1){ 
			x.l=i+1;x.r=r[i]-1;x.w=p2; 
			vec[l[i]].push_back(x); 
		} 
		if(l[i]+1<=i-1&&i!=1){ 
			x.l=l[i]+1;x.r=i-1;x.w=p2; 
			vec[r[i]].push_back(x); 
		} 
		x.l=i;x.r=i;x.w=p1; 
		vec[l[i]].push_back(x);
		vec[r[i]].push_back(x);
	} 
	for(int i=1;i<=n;i++){ 
		root[i]=root[i-1]; 
		for(int j=0;j<vec[i].size();j++)
			add(1,n,vec[i][j].l,vec[i][j].r,vec[i][j].w,root[i],root[i]);
	} 
	for(int i=1;i<=m;i++){ 
		int l=read(),r=read(); 
		printf("%lld\n",check(1,n,l,r,root[l-1],root[r])); 
	} 
	return 0; 
}
```

---

## 作者：zhengrunzhe (赞：3)

不久前刚做过[P3246 [HNOI2016]序列](https://www.luogu.com.cn/problem/P3246)

看到这题感觉做法有点熟悉 没想到这玩意就是HNOI2017
~~我抄我自己~~

可以想到维护一个$l_i$, $r_i$，表示$i$左边/右边第一个比它($k_i$)大的位置,数组是一个排列，所以不用考虑等于

这个玩意可以通过单调栈来实现$O(n)$(就是模板题)

然后性质就是$k_i$在$(l_i,r_i)$中是最大值，且$k_i<k_{l_i},k_i<k_{r_i}$

所以$\max_{j=l_i+1}^{r_i-1}\left \{k_j\right \}<\min(k_{l_i},k_{r_i})$

即$(l_i,r_i)$的最大值都比$k_{l_i},k_{r_i}$来的小，就产生了一个$p_1$的贡献

然后相邻的两个之间是没有东西的，也满足“不存在大于”的条件，也是$p_1$，所以一个询问$[l,r]$，它首先有一个$(r-l)*p_1$的基础答案

于是$p_1$的情况就讨论完了，看$p_2$的情况

任意一个$l_i<l<i,\ i<r<r_i$的区间$[l,r]$的最大值都是$k_i$，否则不是，我们取$k_{l_i}$作上界，则下界要$<k_i$，那我们可以取$(i,r_i)$中的任何一个数，所以$(i,r_i)$中的每个数都能产生$p_2$的贡献

我们考虑每个数字对所有询问的贡献，由于询问区间$[a_j,b_j]$与$[l_i,r_i]$的关系并不确定，进行一下分类讨论

$1.a_j\leq l_i,\ b_j \geq r_i$即$[l_i,r_i]$包含于$[a_i,b_i]$，则我们能同时取到$k_{l_i}$和$k_{r_i}$，所以会有一个$p_1$的贡献，我们能取到$k_{l_i}$以及$(i,r_i)$的所有数，所以会有$p_2(ri-i-1)$的贡献，同理还有$p_2(i-l_i-1)$的贡献，合起来就是$p_1+p_2(r_i-l_i-2)$

$2.a_j\leq l_i,\ i<b_j<r_i$ 即询问区间包含左半边而右半边只框到$b_j$这部分，那么只有$p_2(b_j-i)$

$2.a_j>l_i,\ b_j>r_i$ 即询问区间包含右半边而左半边只框到$a_j$这部分，那么只有$p_2(i-a_j)$

知道了每个位置对每个询问的贡献之后，怎么来维护呢

这是一个很显然的二维偏序，所以我一开始想了个kd-tree（[不会的来这里学](https://www.luogu.com.cn/blog/van/qian-tan-pian-xu-wen-ti-yu-k-d-tree)）

把所有询问当作点对$(a,b)$丢到kdtree里面，然后每个数字去树上矩形修改，由于我们需要加的数字与$b_j,a_j$这种与点自身相关的信息，所以我们可以考虑打三个加法标记，一个是无关的$tag_0$，一个是与$a$相关的$tag_1$，另一个是与$b$相关的$tag_2$，这样在最后遍历整棵树统计答案的时候就是$tag_0+tag_1*a+tag_2*b$

由于kdtree本身常数就很大了，再打标记就爆炸了，所以考虑标记永久化，标记不在修改过程中下传，最后一次遍历的时候才把到根路径上的所有标记累计起来看,$O(n\sqrt n)$

~~然而开了O2和指令集还是卡不过去~~

30分代码：

~~别走啊，我还有线段树满分做法~~
```cpp
#include<stack>
#include<cstdio>
#include<algorithm>
using std::stack;
using std::nth_element;
template<class type>inline const type min(const type &a,const type &b){return a<b?a:b;}
template<class type>inline const type max(const type &a,const type &b){return a>b?a:b;}
template<class type>inline const void read(type &in)
{
	in=0;char ch(getchar());bool f(0);
	while (ch<48||ch>57)f|=ch=='-',ch=getchar();
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
	if (f)in=-in;
}
typedef long long ll;
const int k(2),N(2e5+5);
int f;
ll ans[N];
struct point
{
	int d[k],id;
	inline point(){d[0]=d[1]=0;}
	inline point(const int &x,const int &y,const int id=0):id(id){d[0]=x;d[1]=y;}
	inline const bool operator<(const point &p)const
	{
		return d[f]<p.d[f];
	}
}b[N];
struct tree
{
	ll tag[3],val[3];
	point range,mn,mx;
	tree *son[2];
	static tree *null;
	void *operator new(size_t size);
	inline tree(){son[0]=son[1]=null;tag[0]=tag[1]=tag[2]=0;}
	inline tree(const point &p):range(p),mn(p),mx(p)
	{
		static bool init(0);
		if (!init)
		{
			init=1;
			null=new tree;
			null->son[0]=null->son[1]=null;
			for (int i(0);i<k;i++)null->mn.d[i]=N;
		}
		son[0]=son[1]=null;
		tag[0]=tag[1]=tag[2]=0;
	}
	inline const void pushup()
	{
		for (int i(0);i<k;i++)
			mn.d[i]=min(range.d[i],min(son[0]->mn.d[i],son[1]->mn.d[i])),
			mx.d[i]=max(range.d[i],max(son[0]->mx.d[i],son[1]->mx.d[i]));
	}
	inline const bool in(const point &x,const point &y)
	{
		for (int i(0);i<k;i++)
			if (!(mn.d[i]>=x.d[i]&&mx.d[i]<=y.d[i]))
				return 0;
		return 1;
	}
	inline const bool out(const point &x,const point &y)
	{
		for (int i(0);i<k;i++)
			if (mn.d[i]>y.d[i]||mx.d[i]<x.d[i])
				return 1;
		return 0;
	}
	inline const bool at(const point &x,const point &y)
	{
		for (int i(0);i<k;i++)
			if (!(range.d[i]>=x.d[i]&&range.d[i]<=y.d[i]))
				return 0;
		return 1;
	}
}*root,*tree::null;
#define null tree::null
char memory_pool[N*sizeof(tree)],*tail(memory_pool+sizeof(memory_pool));
inline void *tree::operator new(size_t size){return tail-=size;}
inline tree *build(const int &l,const int &r,const int &d)
{
	if (l>r)return null;
	const int mid(l+r>>1);f=d;
	nth_element(b+l,b+mid,b+r+1);
	tree *p(new tree(b[mid]));
	if (l==r)return p;
	p->son[0]=build(l,mid-1,(d+1)%k);
	p->son[1]=build(mid+1,r,(d+1)%k);
	p->pushup();
	return p;
}
template<const int f>inline const void add(tree *p,const point &x,const point &y,const ll &z)
{
	if (p==null)return;
	if (p->out(x,y))return;
	if (p->in(x,y))return p->tag[f]+=z,void();
	if (p->at(x,y))p->val[f]+=z,void();
	add<f>(p->son[0],x,y,z);add<f>(p->son[1],x,y,z);
}
inline const void check(tree *p,ll add0,ll add1,ll add2)
{
	if (p==null)return;
	ans[p->range.id]+=p->val[0]+(add0+=p->tag[0]);
	ans[p->range.id]+=p->range.d[0]*(p->val[1]+(add1+=p->tag[1]));
	ans[p->range.id]+=p->range.d[1]*(p->val[2]+(add2+=p->tag[2]));
	check(p->son[0],add0,add1,add2);check(p->son[1],add0,add1,add2);
}
int n,m,p1,p2,a[N],l[N],r[N];
stack<int>s;
int main()
{
	read(n);read(m);read(p1);read(p2);
	for (int i(1);i<=n;i++)read(a[i]);
	for (int i(1);i<=n;i++)
	{
		while (!s.empty()&&a[s.top()]<=a[i])s.pop();
		if (!s.empty())l[i]=s.top();
		s.push(i);
	}
	while (!s.empty())s.pop();
	for (int i(n);i;i--)
	{
		while (!s.empty()&&a[s.top()]<=a[i])s.pop();
		if (!s.empty())r[i]=s.top();else r[i]=n+1;
		s.push(i);
	}
	for (int i(1);i<=m;i++)
		read(b[i].d[0]),read(b[i].d[1]),
		ans[b[i].id=i]=1ll*p1*(b[i].d[1]-b[i].d[0]);
	root=build(1,m,0);
	for (int i(1);i<=n;i++)
		add<0>(root,point(1,r[i]),point(l[i],n),p1+(r[i]-l[i]-2ll)*p2),
		add<0>(root,point(1,i+1),point(l[i],r[i]-1),-1ll*i*p2),
		add<2>(root,point(1,i+1),point(l[i],r[i]-1),p2),
		add<0>(root,point(l[i]+1,r[i]),point(i-1,n),1ll*p2*i),
		add<1>(root,point(l[i]+1,r[i]),point(i-1,n),-p2);
	check(root,0,0,0);
	for (int i(1);i<=m;i++)printf("%lld\n",ans[i]);
	return 0;
}
```
现在来讲一下正常人的线段树做法

刚刚这道题的实质转化为了矩形加，单点查询

其实扫描线就完事了

$O(n \log n)$

100分AC代码：
```cpp
#include<stack>
#include<cstdio>
#include<algorithm>
using std::stack;
using std::sort;
template<class type>inline const void read(type &in)
{
	in=0;char ch(getchar());bool f(0);
	while (ch<48||ch>57)f|=ch=='-',ch=getchar();
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
	if (f)in=-in;
}
typedef long long ll;
const int N(2e5+5);
struct triple
{
	ll a,b,c;
	inline triple():a(0),b(0),c(0){}
	inline triple(const ll &a,const ll &b,const ll &c):a(a),b(b),c(c){}
	inline friend const triple operator+=(triple &a,const triple &b)
	{
		return a=triple(a.a+b.a,a.b+b.b,a.c+b.c);
	}
	inline const triple operator*(const int &x)
	{
		return triple(a*x,b*x,c*x);
	}
};
struct tree
{
	triple tag;
	tree *lson,*rson;
	void *operator new(size_t size);
	inline tree(){}
	inline const void update(const int &l,const int &r,const int &L,const int &R,const triple &v)
	{
		if (l>R||r<L)return;
		if (l>=L&&r<=R)return tag+=v,void();
		const int mid(l+r>>1);
		lson->update(l,mid,L,R,v);
		rson->update(mid+1,r,L,R,v);
	}
	inline const triple query(const int &l,const int &r,const int &k,triple add)
	{
		add+=tag;
		if (l==r)return add;
		const int mid(l+r>>1);
		if (k<=mid)return lson->query(l,mid,k,add);
		else return rson->query(mid+1,r,k,add);
	}
}*root;
char memory_pool[N*sizeof(tree)<<1],*tail(memory_pool+sizeof(memory_pool));
inline void *tree::operator new(size_t size){return tail-=size;}
inline const void build(tree *&p,const int &l,const int &r)
{
	p=new tree;
	if (l==r)return;
	const int mid(l+r>>1);
	build(p->lson,l,mid);
	build(p->rson,mid+1,r);
}
ll ans[N];
int n,m,p1,p2,a[N],l[N],r[N],cnt;
stack<int>s;
struct seg
{
	int type,x,y1,y2;triple v;
	inline seg(){}
	inline seg(const int &type,const int &x,const int &y,const int &id):type(type),x(x),y1(y),y2(id){}
	inline seg(const int &type,const int &x,const int &y1,const int &y2,const triple &v):type(type),x(x),y1(y1),y2(y2),v(v){}
	inline const bool operator<(const seg &s)const
	{
		if (x^s.x)return x<s.x;
		return type>s.type;
	}
}b[N*7];
int main()
{
	read(n);read(m);read(p1);read(p2);
	for (int i(1);i<=n;i++)read(a[i]);
	for (int i(1);i<=n;i++)
	{
		while (!s.empty()&&a[s.top()]<=a[i])s.pop();
		if (!s.empty())l[i]=s.top();
		s.push(i);
	}
	while (!s.empty())s.pop();
	for (int i(n);i;i--)
	{
		while (!s.empty()&&a[s.top()]<=a[i])s.pop();
		if (!s.empty())r[i]=s.top();else r[i]=n+1;
		s.push(i);
	}
	build(root,1,n);
	for (int i(1);i<=n;i++)
		b[++cnt]=seg(1,1,r[i],n,triple(p1+p2*(r[i]-l[i]-2ll),0,0)),
		b[++cnt]=seg(-1,l[i],r[i],n,triple(p1+p2*(r[i]-l[i]-2ll),0,0)),
		b[++cnt]=seg(1,1,i+1,r[i]-1,triple(-1ll*i*p2,0,p2)),
		b[++cnt]=seg(-1,l[i],i+1,r[i]-1,triple(-1ll*i*p2,0,p2)),
		b[++cnt]=seg(1,l[i]+1,r[i],n,triple(1ll*p2*i,-p2,0)),
		b[++cnt]=seg(-1,i-1,r[i],n,triple(1ll*p2*i,-p2,0));
	for (int l,r,i(1);i<=m;i++)
		read(l),read(r),
		ans[i]=1ll*p1*(r-l),
		b[++cnt]=seg(0,l,r,i);
	sort(b+1,b+cnt+1);
	for (int i(1);i<=cnt;i++)
		if (!b[i].type)
		{
			const triple t(root->query(1,n,b[i].y1,triple(0,0,0)));
			ans[b[i].y2]+=t.a+b[i].x*t.b+b[i].y1*t.c;
		}
		else
			root->update(1,n,b[i].y1,b[i].y2,b[i].v*b[i].type);
	for (int i(1);i<=m;i++)printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：DOTime (赞：3)

标签：线段树

题解：

http://www.cnblogs.com/D-O-Time/p/7922500.html

首先对于题目的条件进行分析，p1的条件是一个区间的两个端点必须是这一个区间的最大与次大值。p2的条件是一个区间的一个端点是最大值，而另一个端点不是次大值。显然，他们都需要两个条件（对于两个端点都有要求，这样的话不太好操作）。感受一下，p1的条件更为严苛，于是我们这样考虑：

一个区间的一个端点是最大值（两个条件的公共部分），另一个不管，此时加上p2的贡献。

我们可以通过线段树求解出这一个东西。对于i，找到右边大于他的第一个数，如果没有，自然是最后一个数，但是这样不好，于是我们加一个第n+1个数为+∞。然后设ri为右边大于他的第一个数，那么[i,i+1]、[i,i+2]、......[i,ri]都符合条件，于是在线段树中对于[i+1,ri]都+=p2。对于全部询问排序，给以i为左端点的区间加上贡献，查询[i+1,R]的和。反过来再搞一遍，注意询问区间也要反过来。

然后我们发现题目中的对另一个端点的限制是互补的，我们的区间[i,ri]满足p1，而[i,i+1~ri-1]满足p2。因为只有一个满足p1，而且一个i对应一个ri，于是我们在ri处+p1-p2-p2即可，完美解决这一个问题。

小结：此题关键在于两个条件有一半相同，而另一半互补，所以可以不管互补的那一半到时候再考虑。

```cpp
  1 #include<cstdio>
  2 #include<cstring>
  3 #include<iostream>
  4 #include<algorithm>
  5 #define ls k*2
  6 #define rs (k*2+1)
  7 #define LL long long
  8 using namespace std;
  9 const int MAXN=210000;
 10 int n,m,p1,p2,tp;
 11 int v[MAXN],aft[MAXN],st[MAXN];
 12 LL ans[MAXN],sum[MAXN*5],lz[MAXN*5];
 13 struct ed
 14 {
 15   int L,R,id;
 16 }ask[MAXN];
 17 #define down()\
 18 {\
 19   sum[ls]+=lz[k]*(mid-ll+1);\
 20   sum[rs]+=lz[k]*(rr-mid);\
 21   lz[ls]+=lz[k];\
 22   lz[rs]+=lz[k];\
 23   lz[k]=0;\
 24 }
 25 inline int gi() {int res; scanf("%d",&res); return res;}
 26 bool comp(ed x,ed y){return x.L<y.L;}
 27 int find(int x)
 28 {
 29   int L=1,R=m,mid;
 30   while(L<=R)
 31     {
 32       mid=(L+R)/2;
 33       if(ask[mid].L<x)
 34         L=mid+1;
 35       else
 36         R=mid-1;
 37     }
 38   return L;
 39 }
 40 void add(int k,int ll,int rr,int L,int R,LL Val)
 41 {
 42   if(ll==L && rr==R)
 43     {
 44       sum[k]+=Val*(rr-ll+1);
 45       lz[k]+=Val;
 46       return;
 47     }
 48   int mid=(ll+rr)/2;
 49   down();
 50   if(R<=mid)
 51     add(ls,ll,mid,L,R,Val);
 52   else if(mid<L)
 53     add(rs,mid+1,rr,L,R,Val);
 54   else
 55     {
 56       add(ls,ll,mid,L,mid,Val);
 57       add(rs,mid+1,rr,mid+1,R,Val);
 58     }
 59   sum[k]=sum[ls]+sum[rs];
 60 }
 61 LL query(int k,int ll,int rr,int L,int R)
 62 {
 63   if(ll==L && rr==R) return sum[k];
 64   int mid=(ll+rr)/2;
 65   down();
 66   if(R<=mid)
 67     return query(ls,ll,mid,L,R);
 68   else if(mid<L)
 69     return query(rs,mid+1,rr,L,R);
 70   else
 71     return query(ls,ll,mid,L,mid)+query(rs,mid+1,rr,mid+1,R);
 72 }
 73 void work()
 74 {
 75   tp=0; st[0]=n+1;
 76   for(int i=n;i>=1;i--)
 77     {
 78       while(tp && v[st[tp]]<v[i]) tp--;
 79       aft[i]=st[tp];
 80       st[++tp]=i;
 81     }
 82   memset(sum,0,sizeof sum);
 83   memset(lz,0,sizeof lz);
 84   for(int i=n;i>=1;i--)
 85     {
 86       if(aft[i]>i)
 87         {
 88           add(1,1,n+1,i+1,aft[i],p2);
 89           add(1,1,n+1,aft[i],aft[i],p1-2*p2);
 90         }
 91       int p=find(i);
 92       while(ask[p].L==i)
 93         {
 94           ans[ask[p].id]+=query(1,1,n+1,i+1,ask[p].R);
 95           p++;
 96         }
 97     }
 98 }
 99 int main()
100 {
101   n=gi();m=gi();p1=gi();p2=gi();
102   for(int i=1;i<=n;i++) v[i]=gi();
103   for(int i=1;i<=m;i++) ask[i].L=gi() , ask[i].R=gi() , ask[i].id=i;
104   sort(ask+1,ask+1+m,comp);
105   work();
106   reverse(v+1,v+1+n);
107   for(int i=1;i<=m;i++)
108     {
109       swap(ask[i].L,ask[i].R);
110       ask[i].L=n-ask[i].L+1;
111       ask[i].R=n-ask[i].R+1;
112     }
113   sort(ask+1,ask+1+m,comp);
114   work();
115   for(int i=1;i<=m;i++)
116     printf("%lld\n",ans[i]);
117   return 0;
118 }
```

---

## 作者：401rk8 (赞：2)

思路与其他题解相同，详细解释一下转化成矩阵求和的部分。

---

$k$ 是一个排列，因此互不相同。单调栈可以 $O(n)$ 求出对于每个 $i$，$k_i$ 为最大值的区间 $[l_i,r_i]$，每个 $i$ 的贡献可以分为 $3$ 种：

1. 对左端点 $l_i-1$，右端点 $r_i+1$ 贡献 $p_1$
2. 对左端点 $l_i-1$，右端点 $[i+1,r_i]$ 贡献 $p_2$
3. 对左端点 $[l_i,i-1]$，右端点 $r_i+1$ 贡献 $p_2$

将左端点看做横坐标，右端点看做纵坐标，画到坐标系上：

![](https://cdn.luogu.com.cn/upload/image_hosting/mw5vnq1h.png)

离线，按 $x$ 坐标排序后 BIT 维护纵轴可以轻易处理操作 $1,2$，但 $3$ 不好处理。

考虑不限制横轴、纵轴具体是哪个端点，并将 $3$ 和询问按 $y=x$ 对称，得到：

![](https://cdn.luogu.com.cn/upload/image_hosting/11z66kxe.png)

发现重合部分相同，因此可以将操作 $3$ 的右端点看做 $x$ 坐标，从而转化成操作 $2$。相应的，询问也变成正方形。

```cpp
const int N = 4e5+5;
int n,m,w1,w2,a[N];
struct Node { int x,l,r,val,id; } q[N];
bool operator < (const Node &x,const Node &y) { return x.x < y.x; }

int an,le[N],ri[N];
LL ans[N];
Node add[N];
int tp,stk[N];

struct BIT {
	LL t1[N],t2[N];
	void add(int i,int x) {
		for(int j = i; j <= n; j += j&-j)
			t1[j] += x, t2[j] += i*x;
	}
	LL sum(int i) {
		LL res = 0;
		for(int j = i; j; j -= j&-j) res += (i+1) * t1[j] - t2[j];
		return res;
	}
	void add(int l,int r,int x) { add(l,x), add(r+1,-x); }
	LL sum(int l,int r) { return sum(r) - sum(l-1); }
} bit;

signed main() {
	read(n,m,w1,w2);
	For(i,1,n) read(a[i]);
	a[0] = N, stk[++tp] = 0;
	For(i,1,n) {
		while( a[i] > a[stk[tp]] ) ri[stk[tp--]] = i-1;
		le[i] = stk[tp]+1;
		stk[++tp] = i;
	} while( tp ) ri[stk[tp--]] = n;
	For(i,1,n) {
		if( 1 < le[i] && ri[i] < n ) add[++an] = Node{le[i]-1,ri[i]+1,ri[i]+1,w1};
		if( 1 < le[i] && i < ri[i] ) add[++an] = Node{le[i]-1,i+1,ri[i],w2};
		if( le[i] < i && ri[i] < n ) add[++an] = Node{ri[i]+1,le[i],i-1,w2};
	} sort(add+1,add+an+1);
	For(i,1,m) {
		int l,r; read(l,r);
		ans[i] += (r-l) * w1;
		q[i] = Node{l-1,l,r,-1,i}, q[i+m] = Node{r,l,r,1,i};
	} sort(q+1,q+2*m+1);
	for(int i = 1, j = 1; i <= 2*m; ++i) {
		while( j <= an && add[j].x <= q[i].x )
			bit.add(add[j].l,add[j].r,add[j].val), ++j;
		ans[q[i].id] += q[i].val * bit.sum(q[i].l,q[i].r);
	}
	For(i,1,m) write(ans[i]);
	return iocl();
}
```

---

## 作者：teafrogsf (赞：2)

感觉这题还挺有意思的，不过估计是HNOI2017第二容易的题目。  
**UPD：原来的解释有点错误，修正一下。**  
发现两个限制条件很麻烦，不妨先不考虑右端点元素，找到当前元素$a[i]$的右方后继（可等于$a[i]$）$a[k]$。则从$[i,i+1]$到$[i,k)$这些区间都满足p2的贡献要求，而$[i,k]$则满足p1的贡献要求。而每次询问则要求当前区间所有子区间的答案，于是我们可以用线段树维护区间右端点的贡献，更新时将$(i,k)$加上p2,将$[k,k]$加上$p1$就可以了。查询是可以直接查询$(L+1,R)$的答案的。    
但是这样还有些问题，我们可能会算入L左边区间的贡献。所以只需要将询问区间按L从大到小排序就可以了。计算后继可以用单调栈来维护，当然你也可以浪费一点复杂度来$\rm lower\_bound$。  
至于左边的区间怎么办？将区间和询问反向就可以了。**注意反向后询问的变化。**  
**但我们注意到右端点的值可能对答案有影响：比如$[i,k]$这个区间在反向计算时是增加了p2的无意义贡献的。我们要在这里减掉。$**  
还有就是要开$\rm long\ long$。
```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#define neko 200010
#define chkmax(a,b) ((a)>(b)?(a):(b))
#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~i))
#define rf(i,a,b) for(register int i=(a);i>=(b);i=~(-i))
struct node
{
    int l,r,id;
}q[neko];
int n,m;
typedef long long ll;
ll p1,p2,a[neko],ans[neko],stk[neko],suc[neko],Sum[neko<<2],Add[neko<<2];
using namespace std;
namespace Seg
{
    #define ori tagl,tagr
    #define mid ((l+r)>>1)
    #define lson root<<1,l,mid
    #define rson root<<1|1,mid+1,r
    #define pushup(root) Sum[root]=Sum[root<<1]+Sum[root<<1|1]
    void pushdown(int root,int l,int r)
    {
        if(Add[root])
        {
            Sum[root<<1]+=1ll*(mid-l+1)*Add[root];
            Sum[root<<1|1]+=1ll*(r-mid)*Add[root];
            Add[root<<1]+=Add[root];
            Add[root<<1|1]+=Add[root];
            Add[root]=0;
        }
    }
    ll query(int root,int l,int r,int tagl,int tagr)
    {
        if(l>=tagl&&r<=tagr)return Sum[root];
        pushdown(root,l,r);
        ll tmp=0;
        if(tagl<=mid)tmp+=query(lson,ori);
        if(tagr>mid)tmp+=query(rson,ori);
        return tmp;
    }
    void update(int root,int l,int r,int tagl,int tagr,int x)
    {
        if(l>=tagl&&r<=tagr){Add[root]+=x,Sum[root]+=(r-l+1)*x;return;}
        pushdown(root,l,r);
        if(tagl<=mid)update(lson,ori,x);
        if(tagr>mid)update(rson,ori,x);
        pushup(root);
    }
    #undef ori
    #undef mid
    #undef lson
    #undef rson
}
namespace Cons
{
    using namespace Seg;
    bool cmp(node a,node b)
    {return a.l<b.l;}
    void init()
    {memset(Sum,0,sizeof(Sum)),memset(Add,0,sizeof(Add));}
    void calc()
    {
        int top=0,now=m;stk[0]=n+1;
        init();
        rf(i,n,1)
        {
            while(top&&a[stk[top]]<a[i])--top;
            suc[i]=stk[top];
            stk[++top]=i;
        }
        rf(i,n,1)
        {
            if(suc[i]>i)update(1,1,n+1,i+1,suc[i],p2),update(1,1,n+1,suc[i],suc[i],p1-2*p2);
            while(q[now].l==i)ans[q[now].id]+=query(1,1,n+1,i+1,q[now].r),--now;
        }
    }
}
using namespace Cons;
int main()
{
    scanf("%d%d%lld%lld",&n,&m,&p1,&p2);
    f(i,1,n)scanf("%lld",&a[i]);//a[n+1]=1e9;
    f(i,1,m)scanf("%d%d",&q[i].l,&q[i].r),q[i].id=i;
    sort(q+1,q+m+1,cmp),calc();
    reverse(a+1,a+n+1);
    f(i,1,m)swap(q[i].l,q[i].r),q[i].l=n-q[i].l+1,q[i].r=n-q[i].r+1;
    sort(q+1,q+m+1,cmp),calc();
    f(i,1,m)printf("%lld\n",ans[i]);return 0;
}
```

---

## 作者：lzk5627 (赞：1)

省选前的最后一篇题解 ~~希望不要是OI生涯中的最后一篇题解~~

最大值问题可以考虑**笛卡尔树**

考虑两种贡献的条件,假设 $i>j,k_i>k_j$

可以发现 $p1$ 的条件等价于 $j$ 是 $i$ 的左儿子的右链

$p2$ 的条件等价于 $j$ 是 $i$ 的左儿子的右链的左子树

然后离线区间,在每一个 $i$ 加入时计算 $i>j,k_i>k_j$ 的贡献,发现如果直接枚举左儿子的右链,复杂度是 $O(n)$ 的,因为每个节点只会在父亲和父亲的父亲被计算,于是就只要实现区间加和区间查询就好了

```cpp
#include<algorithm>
#include<iostream>
#include<vector>
#include<cstdio>
#include<cstring>
using namespace std;
#define ll long long
//{{{ read()
inline ll read(){
	register ll x=0,f=1;
	register char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')	f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')	x=x*10+(ch^48),ch=getchar();
	return x*f;
}
//}}}
const int N=2e5+5; 
struct pi{
	int l,r,id;
}q[N];
ll b[N<<2],la[N<<2],ans[N];
int n,m,p1,p2,a[N],lp[N],rp[N],ls[N],rs[N],lg[N],st[N][18];
void add(int rt,int l,int r,int z){
	b[rt]+=(r-l+1)*z,la[rt]+=z;
}
void push(int rt,int l,int r){
	if(!la[rt]) return ;
	int mid=(l+r)>>1;
	add(rt<<1,l,mid,la[rt]);
	add(rt<<1|1,++mid,r,la[rt]),la[rt]=0;
}
void add(int l,int r,int x,int y,int z,int rt){
	if(x<=l&&y>=r){
		add(rt,l,r,z);
		return ;
	}
	int mid=(l+r)>>1; push(rt,l,r);
	if(x<=mid)	 add(l,mid,x,y,z,rt<<1);
	if(y>mid)	add(++mid,r,x,y,z,rt<<1|1);
	b[rt]=b[rt<<1]+b[rt<<1|1];
}
ll query(int l,int r,int x,int y,int rt){
	if(x<=l&&y>=r) return b[rt];
	int mid=(l+r)>>1;
	ll ans=0; push(rt,l,r);
	if(x<=mid) ans=query(l,mid,x,y,rt<<1);
	if(y>mid)  ans+=query(++mid,r,x,y,rt<<1|1);
	return ans;
}
int min(int x,int y){
	if(a[x]<a[y]) return y;
	return x;
}
int get(int l,int r){
	int k=lg[r-l+1];
	return min(st[l][k],st[r-(1<<k)+1][k]);
}
int build(int l,int r){
	int x=get(l,r); lp[x]=l,rp[x]=r;
	if(l<x) ls[x]=build(l,x-1);
	if(r>x) rs[x]=build(x+1,r);
	return x;
}
bool com(pi x,pi y){
	return x.r<y.r;
}
bool cmp(pi x,pi y){
	return x.l>y.l;
}
int main(){
	freopen("1.in","r",stdin);
	//freopen(".out","w",stdout);
	n=read(),m=read(),p1=read(),p2=read();
	for(int i=2;i<=n;i++) lg[i]=lg[i>>1]+1;
	for(int i=1;i<=n;i++) a[i]=read(),st[i][0]=i;
	for(int j=1;j<=lg[n];j++)
		for(int i=1;i+(1<<j)<=n+1;i++)
			st[i][j]=min(st[i][j-1],st[i+(1<<(j-1))][j-1]);
	for(int i=1;i<=m;i++) q[i].l=read(),q[i].r=read(),q[i].id=i;
	build(1,n),sort(q+1,q+m+1,com);
	for(int i=1,j=1;i<=n&&j<=m;i++){
		int x=ls[i];
		while(x){
			if(ls[x]) add(1,n,lp[x],x-1,p2,1);
			add(1,n,x,x,p1,1),x=rs[x];
		}
		while(j<=m&&q[j].r==i) ans[q[j].id]=query(1,n,q[j].l,q[j].r,1),j++;
	}
	memset(la,0,sizeof(la));
	memset(b,0,sizeof(b));
	sort(q+1,q+m+1,cmp);
	for(int i=n,j=1;i&&j<=m;i--){
		int x=rs[i];
		while(x){
			if(rs[x]) add(1,n,x+1,rp[x],p2,1);
			add(1,n,x,x,p1,1),x=ls[x];
		}
		while(j<=m&&q[j].l==i) ans[q[j].id]+=query(1,n,q[j].l,q[j].r,1),j++;
	}
	for(int i=1;i<=m;i++)	printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：shadowice1984 (赞：1)

单调栈+线段树+离线处理

# 一定要开LONGLONG！！！

嗯~ o(\*￣▽￣\*)o我们发现要处理一堆区间

我们发现对于p1类型的区间【i，j】

如果j>i那么j一定是i右侧第一个比它大的点

（什么？j小于i？，反转区间可以化成情况一）

再考虑p2情况类型的区间【i，j】

如果i小于j则i一定是这样的点，它在区间（p，q）之间

//（p,q)是开区间！！！

其中【q，j】是一个p1类型的区间，p是q左侧第一个比

q大的点（同理i>j是可以反转区间转换为情况一）

通过反证法我们可以很容易的证明上面的说法可以不重不漏的

枚举出所有的p1，p2（假设有一个不符合条件的区间，发现很快就会出矛盾）

发现上述一套花里胡哨的定义只需要两个信息，

点 i 左侧第一个比他大的点是谁

点 i 右侧第一个比他大的点是谁

好像单调栈就可以处理欸

接下来是统计区间

发现在线处理会直接晕掉，考虑离线处理

把询问按右端点排序，之后每次拓展右端点

更新所有合法的左端点即可

发现p1是单点修改，p2是区间修改

//都开线段树好了，这里懒了

然后线段树sum一下就是结果了

另外，上述只处理了一半（即i小于j）

我们可以把区间和询问统统反转，处理下一半情况

//细节看注释吧，不看代码刚才讲的好多细节没有

上代码~

    
```cpp
    #include<cstdio>
    #include<algorithm>
    using namespace std;
    int n;int m;int p1;int p2;
    int a[200010];long long ans[200010];
    //开longlong
    struct data
    {
        int l;int r;int num;
        friend bool operator <(data a,data b){return a.r<b.r;}
    }q[200010];
    struct graph//这里用邻接表存右边第一个大的点间的关系
    {
        struct edge{int v;int nxt;}edge[400010];
        int cnt;int alist[200010];
        inline void add(int u,int v)
        {edge[++cnt].v=v;edge[cnt].nxt=alist[u];
        alist[u]=cnt;return;}
        inline void clear()
        {for(int i=0;i<=n;i++)alist[i]=0;
        for(int i=0;i<=cnt;i++)edge[i].v=0,edge[i].nxt=0;
        cnt=0;return;}
    }g;int left[200010];
    struct sta//手写的栈
    {
        int stk[200010];int nop;
        inline void push(int x){stk[++nop]=x;return;}
        inline void pop(){if(nop>0)nop--;return;}
        inline int top(){return stk[nop];}
        inline bool empty(){return nop>0;}
        inline void clear(){while(empty())pop();}
    }s;
    struct linetree//基本线段树
    {
        int val[800010];int lazy[800010];
        inline void pushdown(int p,int l,int r)
        {
            val[p]+=lazy[p]*(r-l);
            if(r-l>1)
            {lazy[2*p]+=lazy[p],lazy[2*p+1]+=lazy[p];}
            lazy[p]=0;return;
        }
        inline void setlazy(int p,int l,int r,int dl,int dr,int plus)
        {
            if(dl==dr)return;
            if(lazy[p]!=0)pushdown(p,l,r);
            if(dl==l&&dr==r)
            {lazy[p]+=plus;pushdown(p,l,r);return;}
            int mid=(l+r)/2;
            if(dl<mid)setlazy(2*p,l,mid,dl,min(mid,dr),plus);
            else pushdown(2*p,l,mid);
            if(mid<dr)setlazy(2*p+1,mid,r,max(dl,mid),dr,plus);
            else pushdown(2*p+1,mid,r);
            val[p]=val[2*p]+val[2*p+1];return;
        }
        inline int sum(int p,int l,int r,int dl,int dr)
        {
            if(lazy[p]!=0)pushdown(p,l,r);
            if(dl==l&&dr==r){return val[p];}
            int mid=(l+r)/2;int res=0;
            if(dl<mid)res+=sum(2*p,l,mid,dl,min(mid,dr));
            if(mid<dr)res+=sum(2*p+1,mid,r,max(dl,mid),dr);
            return res;
        }
        inline void clear()
        {for(int i=0;i<=4*n+1;i++){val[i]=0;lazy[i]=0;}return;}
    }lt1,lt2;//开两个，一个p1型左端点个数，另一个是p2型
    void reverse()//反转区间和询问
    {
        for(int i=1;i<=n/2;i++)swap(a[i],a[n-i+1]);
        for(int i=1;i<=m;i++)
        {swap(q[i].l,q[i].r);q[i].l=n-q[i].l+1,q[i].r=n-q[i].r+1;}
        return;
    }
    void work()
    {
        sort(q+1,q+m+1);//右端点排序
        for(int i=1;i<=n;i++)//右侧第一个大
        {
            while(s.empty()&&a[i]>a[s.top()])
            {g.add(i,s.top());
            //这里注意，一个点可能是好几个点的第一个大值
            //所以要用临接表存
            //printf("right[%d]=%d\n",a[s.top()],a[i]);
            s.pop();}s.push(i);
        }
        for(int i=n;i>=1;i--)//左侧第一个大
        {
            while(s.empty()&&a[i]>a[s.top()])
            {left[s.top()]=i;//可是一个点只有一个左侧第一大
            //printf("left[%d]=%d\n",a[s.top()],a[i]);
            s.pop();}s.push(i);
        }int cot=1;//枚举每个节点
        for(int i=1;i<=m;i++)
        {
            for(;cot<=q[i].r;cot++)
            {
                int nxt=g.alist[cot];//枚举这个点的所有左端点
                while(nxt)
                {
                    int v=g.edge[nxt].v;
                    lt1.setlazy(1,0,n,v-1,v,1);//更新p1型左端点
                    //printf("p1:%d,%d\n",a[cot],a[v]);
                    lt2.setlazy(1,0,n,left[v],v-1,1);//更新p2型右端点
                    //printf("p2:%d->%d~%d\n",a[cot],a[v],a[left[v]]);
                    nxt=g.edge[nxt].nxt;
                }
            }
            //务必是longlong
            ans[q[i].num]+=(long long)p1*(long long)lt1.sum(1,0,n,q[i].l-1,q[i].r);
            ans[q[i].num]+=(long long)p2*(long long)lt2.sum(1,0,n,q[i].l-1,q[i].r);
        }return;
    }
    int main()
    {
         //读入
        scanf("%d%d%d%d",&n,&m,&p1,&p2);
        for(int i=1;i<=n;i++){scanf("%d",&a[i]);}
        for(int i=1;i<=m;i++)
        {q[i].num=i;scanf("%d%d",&q[i].l,&q[i].r);}
        work();//干活
        s.clear();lt1.clear();lt2.clear();
        g.clear();for(int i=0;i<=n;i++)left[i]=0;
        reverse();//清理并反转
        work();//接着干活
        for(int i=1;i<=m;i++)
        {
            printf("%lld\n",ans[i]);
        }return 0;//拜拜程序~
}
```

---

## 作者：Unnamed114514 (赞：1)

考虑扫描线。

首先我们扫描线的时候应该想：我们 DS 上需要维护的是什么？

对于本题，有一个非常暴力的做法就是直接在 DS 上维护每个点 $p$ 在扫到 $r$ 的时候 $[p,p+1],[p,p+2],\cdots,[p,r]$ 的贡献的和。

从这个思路出发，我们就只用考虑每一个 $[l,r]$ 的情况了。

直接算贡献不好算，我们可以考虑给它转化成式子的形式。

贪心地，我们显然是要看区间里面又没有 $>k_i$ 和 $>k_j$ 的数，因此我们只需要找第一个位置即可。因此令 $L_i$ 表示 $i$ 左边第一个比它大的位置，$R_i$ 表示 $i$ 右边第一个比它大的位置。那么贡献为 $p_1$ 就等价于 $R_l\ge r,L_r\le l$ ，然后贡献为 $p_2$ 的时候，就只有其中一个成立。

显然 $R_l<r$ 和 $R_l\ge r$ 的式子并不一样，所以我们需要开两个 DS 来分别维护，然后在 $R_l=r$ 的时候，把它从第一个 DS 放到第二个 DS 里面。

最后再来考虑一下用什么 DS 来维护。

首先我们需要进行快速的插入和删除，然后我们需要对 $L_r\le l$ 和 $L_r>l$ 分开处理，并且只操作在这个 DS 里面的，而不是批量的区间操作。查询也只查询 $l\ge a_i$ 的部分并且要在这个 DS 里面，而不是区间查询。

容易发现，上述操作可以用 FHQ Treap 维护，时间复杂度 $O(n\log n)$。（是否可以用线段树维护未知）

---

## 作者：一Iris一 (赞：0)

刚做完 [P3246 [HNOI2016]序列](https://www.luogu.com.cn/problem/P3246) 就碰到这个题了。

（话说为什么 HN 两年出了一样的题……

根据题意可以发现，对于一个区间 $[l,r]$ 来说，无论是想要贡献 $p1$，还是想要贡献 $p2$，就都需要考虑 $[l,r]$ 中最大值和两端点的关系。

考虑暴力怎么做，枚举两个端点，然后求出区间 $RMQ$，之后比较两端点和 $RMQ$ 的关系。显然这样会 T。那我们不如反过来考虑，假设一个点作为 $RMQ$，然后考虑它参与进哪些区间的运算。

很自然地发现，对一个点来说只要知道它左右两边第一个大于它的数的位置，就能确定它作为 $RMQ$ 参与运算的区间范围，这个可以拿单调栈来做。

设左右两边第一个大于 $i$ 的数的位置为 $lef[i],right[i]$。如果我们将每个区间 $(i,j)$ 映射到
平面上，则一个点 i 所贡献的就是一个矩形 $[lef[i],i-1]-[i+1,right[i]]$。

题目已经告诉我们，对于任意一个区间它的贡献是 $0$、$p1$ 或者 $p2$。
对于$[lef[i],i-1]-[i+1,right[i]]$ 这个矩形，满足其内部任意一点贡献都为 $0$ 。正确性显然（因为你这个矩形是通过预处理 $lef$ 和 $right$ 求出来的，所以该点的左右端点都在 $lef$ 和 $right$ 范围内。

接下来考虑贡献为 $p1$ 的情况。可以发现对一个点 $i$ 来说，其 $lef$ 和 $right$ 分别向外扩大一位后的位置上的数大于 $k_i$，这显然不就构成 $p1$ 成立的条件了吗！必要性显然。

最后我们不考虑贡献 $p2$ 的情况，而是直接考虑查询操作。询问 $[l,r]$ 这个区间意味着在平面上询问 $(l,l)-(rr)$ 这个区域，该问题就被转化为了平面上矩形加、矩形查询的操作。实现的方式多种多样，什么二维树状数组、扫描线、四叉树、kdt……随便用就是了

最后说一下为什么不讨论贡献 $p2$ 的情况。可以直接将矩形默认值赋为 $p2$ ，做 $0$ 贡献相当于做 $-p2$ 贡献，做 $p1$ 贡献相当于做 $p1-p2$ 贡献，就能解决问题。

```cpp
#include<bits/stdc++.h>

using namespace std;

#define int long long
#define INF 1ll<<30
#define Int unsigned long long 

template<typename _T>
inline void read(_T &x)
{
	x=0;char s=getchar();int f=1;
	while(s<'0'||s>'9') {f=1;if(s=='-')f=-1;s=getchar();}
	while('0'<=s&&s<='9'){x=(x<<3)+(x<<1)+s-'0';s=getchar();}
	x*=f;
}

#define lowbit(x) (x&(-x))
#define gb(x) ((x-1)/T + 1)
#define gl(x) ((x-1)*T + 1)
#define pb push_back 
#define Re register
#define MOD(x) (x = (x + mod)%mod)

const int np =2e5 + 5;

int a[np] , sta[np] , top;
int lef[np],right_[np];
int ql[np],qr[np],ans[np];
int h[np];
int n,q,p1,p2;
vector<int> Add[np],jian[np],qry[np],Addp1[np];

struct node{
	int l,r;
	node *ls,*rs;
	int sum,tag;
	
	inline bool inrange(int L,int R){return L<=l&&r<=R;}
	inline bool outofrange(int L,int R){return r < L||R < l;}
	
	inline void pushup()
	{
		sum = ls->sum + rs->sum;
	}
	
	inline void maketag(int vl)
	{
		sum += (r - l + 1) * vl;
		tag += vl;
	}
	
	inline void pushdown()
	{
		if(tag)
		{
			ls->maketag(tag);
			rs->maketag(tag);
			tag = 0 ;
		}
		return ;
	}
	
	inline int query(int L,int R)
	{
		if(inrange(L,R))
		{
			return sum;
		}
		else
		{
			if(!outofrange(L,R))
			{
				pushdown();
				return ls->query(L,R) + rs->query(L,R);
			}
		}
	}
	
	inline void upd(int L,int R,int vl)
	{
		if(inrange(L,R))
		{
			maketag(vl);
			return;
		}
		else
		{
			if(!outofrange(L,R))
			{
				pushdown();
				ls->upd(L,R,vl);
				rs->upd(L,R,vl);
				pushup();
			}
		}
	}
}mem[np * 5],*pool = mem,*T1,*T2;
inline node *New(){return ++pool;}
inline node *build(int L,int R)
{
	node *u = New();
	u->l = L , u->r  = R;
	if(L == R)
	{
		u->ls = u->rs =NULL;
	}
	else
	{
		int mid = L + R>>1;
		u->ls = build(L,mid);
		u->rs = build(mid + 1,R);
		u->pushup();
	}
	return u;
}

signed main()
{
	read(n);
	read(q);
	read(p1);
	read(p2);
	
	for(int i=1;i<=n;i++) read(a[i]);
	
	for(int i=1;i<=n;i++)
	{
		while(a[sta[top]] < a[i] && top >= 1) top--;
		if(top) lef[i] = sta[top] + 1;
		else lef[i] = 1;
		sta[++top] = i;
	}
	
	top = 0;
	for(int i=n;i>=1;i--)
	{
		while(a[sta[top]] <= a[i] && top >= 1) top--;
		if(top) right_[i] = sta[top] - 1;
		else right_[i] = n;
		sta[++top] = i;		
	}
	// 0类贡献 [lef , i - 1] , [i + 1,right] 
	// p1类贡献 (lef,right) 
	// 剩下都是p2类贡献  
	for(int i=1;i<=n;i++)
	{
		if(i + 1 <= n) Addp1[i + 1].pb(i);
		if(1 <= lef[i] - 1 && right_[i] + 1 <= n) Addp1[right_[i] + 1].pb(lef[i] - 1);
		if(lef[i]>i-1 || i + 1 >right_[i]) continue;
		if(lef[i] == right_[i]) continue;
		Add[i + 1].pb(i);
		jian[right_[i]].pb(i);
	}
	
	T1 = build(1,n); // 维护已经落下的矩形 
	T2 = build(1,n); // 维护正在落下的矩形 
	for(int i=1;i<=q;i++)
	{
		read(ql[i]);read(qr[i]);
		qry[qr[i]].pb(i);
	}
	
	h[0] = 0;
	for(int i=1;i<=n;i++) h[i] = h[i-1] + 1;
	
	for(int i=1;i<=n;i++)
	{
		for(auto j:Addp1[i])
		{
			T1->upd(j,j,p1-p2);
		 } 
		
		for(auto j:Add[i])
		{
			T1->upd(lef[j],j-1,(i-1)*p2);
			T2->upd(lef[j],j-1,-p2);
		}
		
		for(auto j:jian[i])
		{
			T1->upd(lef[j],j-1,-i*p2);
			T2->upd(lef[j],j-1,p2);
		}
		
		for(auto j:qry[i])
		{
			int x = (qr[j] - ql[j] + 1) * i * p2;
			int y = -(h[ql[j]] + h[qr[j]]) * (qr[j] - ql[j] + 1)/2*p2;
			x+=y;
			ans[j] = x + i * T2->query(ql[j],qr[j]) + T1->query(ql[j],qr[j]);
		}
	}
	
	for(int i=1;i<=q;i++) printf("%lld\n",ans[i]);
	
	return 0;
 }

```

 

---

## 作者：JZYshuraK (赞：0)

# 影魔
题解：

我们先用单调栈求出一个数左边第一个比它大的，和右边第一个比它大的。$l_i$和$r_i$就表示这两个值。

然后我们发现，$(l_i,r_i)$就是一个合法的第一个条件的点对。

接下来我们考虑如何统计第二个条件的点对。

第二个条件的话如果还想用刚才的值表示的话，我们发现就是在平面上枚举一个线段，然后把这个线段染色。

每次统计一个矩形中多少个点是染色的。

而这个过程我们可以用主席树+标记永久化来实现的。

Code:
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define N 200010 
#define lson l,mid,ls[x],ls[y]
#define rson mid+1,r,rs[x],rs[y]
using namespace std; typedef long long ll;
char *p1,*p2,buf[100000];
#define nc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
int rd() {int x=0; char c=nc(); while(c<48) c=nc(); while(c>47) x=(((x<<2)+x)<<1)+(c^48),c=nc(); return x;}
struct Node
{
	int x,l,r; ll p;
	Node() {}
	Node(int x_,int l_,int r_,ll p_) {x=x_,l=l_,r=r_,p=p_;}
}v[N<<2];
int a[N],lp[N],rp[N],sta[N],top,cnt,root[N],ls[N<<6],rs[N<<6],tot;
ll sum[N<<6],add[N<<6];
inline bool cmp(const Node &a,const Node &b) {return a.x<b.x;}
inline void pushup(int x) {sum[x]=sum[ls[x]]+sum[rs[x]];}
void insert(int b,int e,ll a,int l,int r,int x,int &y)
{
	y=++tot,ls[y]=ls[x],rs[y]=rs[x],add[y]=add[x],sum[y]=sum[x]+a*(e-b+1);
	if(b==l&&r==e) {add[y]+=a; return;}
	int mid=(l+r)>>1;
	if(e<=mid) insert(b,e,a,lson);
	else if(b>mid) insert(b,e,a,rson);
	else insert(b,mid,a,lson),insert(mid+1,e,a,rson);
}
ll query(int b,int e,int l,int r,int x,int y)
{
	if(b<=l&&r<=e) return sum[y]-sum[x];
	int mid=(l+r)>>1; ll ans=(add[y]-add[x])*(e-b+1);
	if(e<=mid) return ans+query(b,e,lson);
	else if(b>mid) return ans+query(b,e,rson);
	else return ans+query(b,mid,lson)+query(mid+1,e,rson);
}
int main()
{
	int n,m,i,j,x,y;
	ll p1,p2;
	n=rd(),m=rd(); p1=rd(),p2=rd(); for(int i=1;i<=n;i++) a[i]=rd();
	a[0]=a[n+1]=1<<30,top=1;
	for(i=1;i<=n;i++)
	{
		while(a[sta[top]]<a[i]) top--;
		lp[i]=sta[top],sta[++top]=i;
	}
	top=1,sta[1]=n+1;
	for(i=n;i>=1;i--)
	{
		while(a[sta[top]]<a[i])top--;
		rp[i]=sta[top],sta[++top]=i;
	}
	for(i=1;i<=n;i++)
	{
		if(lp[i]!=0&&rp[i]!=n+1) v[++cnt]=Node(lp[i],rp[i],rp[i],p1);
		if(i<n) v[++cnt]=Node(i,i+1,i+1,p1);
		if(lp[i]!=0&&rp[i]-i>1) v[++cnt]=Node(lp[i],i+1,rp[i]-1,p2);
		if(rp[i]!=n+1&&i-lp[i]>1) v[++cnt]=Node(rp[i],lp[i]+1,i-1,p2);
	}
	sort(v+1,v+cnt+1,cmp);
	for(i=j=1;i<=n;i++)
	{
		root[i]=root[i-1];
		while(j<=cnt&&v[j].x==i)
			insert(v[j].l,v[j].r,v[j].p,1,n,root[i],root[i]),j++;
	}
	while(m--)
	{
		x=rd(),y=rd();
		printf("%lld\n",query(x,y,1,n,root[x-1],root[y]));
	}
	return 0;
}
```
推销个人blog [JZYshuraK](https://www.cnblogs.com/ShuraK/p/10238938.html)

---

## 作者：埃罗芒阿老师· (赞：0)

可以直接看我博客：http://www.cnblogs.com/zzmmm/p/7502127.html

思路{

和去年的序列有点像啊...

对于一个点,单独计算其作为区间最大值的贡献，这也是一般的序列问题的套路。

对于单点$ i $，他所能作为一段区间内的最大值所能做出的贡献是什么，

找出左边第一个大于$K_i$的位置$L_i$,

右边第一个大于$K_i$的位置$R_i$；

一段区间做出的贡献，又十分自然想到了扫描线.

由于设二维平面上的点$( x , y ) $  中$ y $值表示所代表的点.$x$值表示它所能够影响到的点。

$P_1$对应了点$ ( i , L_i ) $到$ ( i , R_i ) $的线段，

$P_2$对应了点$ ( L_i , i + 1 ) $到$ ( i , R_i - 1 ) $的线段，

$P_2$对应了点$ ( R_i , L_i + 1 ) $到$ ( R_i , i - 1 ) $的线段，

询问抽象成两条平行于 $ x $ 轴的线段,

每条线段左右端点即为所产生的贡献范围.那线段的左右端点和上下端点都是$L,R$了.

那么就是求询问所代表的区间内的权值和了!!

用扫描线+区间修改树状数组维护这个东西即可.

这么说来应该也可以用扫描线来解决去年的序列了.

```cpp
}
#define RG register
#define ll long long
#define db double
#define N 200010
#define lowbit (i&-i)
using namespace std;
int l[N],r[N],st[N],a[N],n,m,p1,p2;
ll Ans[N];
namespace BIT{
  ll t1[N],t2[N];
  void clear(){memset(t1,0,sizeof(t1));memset(t2,0,sizeof(t2));}
  void add(int x,int y){
    for(int i=x;i<=n;i+=lowbit)t1[i]+=y,t2[i]+=1ll*x*y;
  }
  void Insert(int l,int r,int num){
    add(l,num),add(r+1,-num);
  }
  ll Query(int pos){
    ll Sum(0);
    for(int i=pos;i;i-=lowbit)Sum+=(pos+1)*t1[i]-t2[i];
    return Sum;
  }
  ll sum(int l,int r){
    return Query(r)-Query(l-1);
  }
}
struct event{
  int l,r,h,bel,val;
  event() {}
  event(int a,int b,int c,int d,int e):l(a),r(b),h(c),bel(d),val(e) {}
}eve1[N*2],eve2[N*3];int tot1,tot2;
bool comp(const event & a,const event & b){return a.h<b.h;}
int main(){
  scanf("%d%d%d%d",&n,&m,&p1,&p2);
  for(int i=1;i<=n;++i)scanf("%d",&a[i]);
  for(int i=1;i<=n;++i){
    while(st[0]&&a[st[st[0]]]<a[i])r[st[st[0]--]]=i;
    st[++st[0]]=i;
  }
  while(st[0])r[st[st[0]--]]=n+1;
  for(int i=n;i;i--){
    while(st[0]&&a[st[st[0]]]<a[i])l[st[st[0]--]]=i;
    st[++st[0]]=i;
  }
  while(st[0])l[st[st[0]--]]=0;
  for(int i=1;i<=m;++i){int l,r;
    scanf("%d%d",&l,&r);Ans[i]+=1ll*(r-l)*p1;
    eve1[++tot1]=event(l,r,r,i,1);
    eve1[++tot1]=event(l,r,l-1,i,-1);
  }
  sort(eve1+1,eve1+tot1+1,comp);
  for(int i=1;i<=n;++i){
    if(l[i]&&r[i]!=n+1)eve2[++tot2]=event(l[i],l[i],r[i],0,p1);
    if(l[i]&&r[i]>i+1)eve2[++tot2]=event(i+1,r[i]-1,l[i],0,p2);
    if(r[i]!=n+1&&l[i]+1<i)eve2[++tot2]=event(l[i]+1,i-1,r[i],0,p2);
  }
  sort(eve2+1,eve2+tot2+1,comp);
  int h1(1),h2(1);
  while(!eve1[h1].h)h1++;
  for(int i=1;i<=n&&h1<=tot1;++i){
    while(h2<=tot2&&eve2[h2].h==i){
      BIT::Insert(eve2[h2].l,eve2[h2].r,eve2[h2].val);
      h2++;
    }
    while(h1<=tot1&&eve1[h1].h==i){
      Ans[eve1[h1].bel]+=eve1[h1].val*(BIT::sum(eve1[h1].l,eve1[h1].r));
      h1++; 
    }
  }
  for(int i=1;i<=m;++i)cout<<Ans[i]<<"\n";
  return 0;
}

```

---


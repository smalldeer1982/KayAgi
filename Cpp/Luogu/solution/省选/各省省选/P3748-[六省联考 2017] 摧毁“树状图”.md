# [六省联考 2017] 摧毁“树状图”

## 题目描述

自从上次神刀手帮助蚯蚓国增添了上千万人口（蚯口？），蚯蚓国发展得越来越繁荣了！最近，他们在地下发现了一些神奇的纸张，经过仔细研究，居然是 D 国 X 市的超级计算机设计图纸！

这台计算机叫做 “树状图”，由 $n$ 个计算节点与 $n - 1$ 条可以双向通信的网线连接而成，所有计算节点用不超过 $n$ 的正整数编号。顾名思义，这形成了一棵树的结构。

蚯蚓国王已在图纸上掌握了这棵树的完整信息，包括 $n$ 的值与 $n - 1$ 条网线的连接信息。于是蚯蚓国王决定，派出蚯蚓国最强大的两个黑客，小 P 和小 H，入侵 “树状图”，尽可能地摧毁它。

小 P 和小 H 精通世界上最好的编程语言，经过一番商量后，他们决定依次采取如 下的步骤：
* 小 P 选择某个计算节点，作为他入侵的起始点，并在该节点上添加一个 **P** 标记。
* 重复以下操作若干次（可以是 $0$ 次）：
    * 小 P 从他当前所在的计算节点出发，选择一条没有被标记过的网线，入侵到该网线的另一端的计算节点，并在路过的网线与目的计算节点上均添加一个 **P** 标记。
* 小 H 选择某个计算节点，作为她入侵的起始点，并在该节点上添加一个 **H** 标记。
* 重复以下操作若干次（可以是 $0$ 次）：
    * 小 H 从她当前所在的计算节点出发，选择一条没有被标记过的网线，入侵到该网线的另一端的计算节点，并在路过的网线与目的计算节点上均添加一个 **H** 标记。（注意，小 H 不能经过带有 **P** 标记的网线，但是可以经过带有 **P** 标记的计算节点）
* 删除所有被标记过的计算节点和网线。
* 对于剩下的每条网线，如果其一端或两端的计算节点在上一步被删除了，则也删除这条网线。

经过以上操作后，“树状图” 会被断开，剩下若干个（可能是 $0$ 个）连通块。为了达到摧毁的目的，蚯蚓国王希望，连通块的个数越多越好。于是他找到了你，希望你能帮他计算这个最多的个数。

小 P 和小 H 非常心急，在你计算方案之前，他们可能就已经算好了最优方案或最优方案的一部分。你能得到一个值 $x$：
* 若 $x = 0$，则说明小 P 和小 H 没有算好最优方案，你需要确定他们两个的入侵路线。
* 若 $x = 1$，则说明小 P 已经算好了某种两人合作的最优方案中，他的入侵路线。他将选择初始点 $p_0$，并沿着网线一路入侵到了目标点 $p_1$，并且他不会再沿着网线入侵；你只需要确定小 H 的入侵路线。
* 若 $x = 2$，则说明小 P 和小 H 算好了一种两人合作的最优方案，小 P 从点 $p_0$ 入侵到了 $p_1$ 并停下，小 H 从点 $h_0$ 入侵到了 $h_1$ 并停下。此时你不需要指挥他们入侵了，只需要计算最后两步删除计算节点与网线后，剩下的连通块个数即可。

## 说明/提示

* 若 $x = 0$，则该行只有一个整数 $n$。
* 若 $x = 1$，则该行依次有三个整数 $n, p_0, p_1$。
* 若 $x = 2$，则该行依次有五个整数 $n, p_0, p_1, h_0, h_1$。

保证 $p_0, p_1, h_0, h_1$ 均为不超过 $n$ 的正整数。

每个数据接下来有 $n - 1$ 行，每行有两个不超过 $n$ 的正整数，表示这两个编号的计算节点之间有一条网线将其相连。保证输入的是一棵树。

同一行相邻的整数之间用恰好一个空格隔开。

**数据文件可能较大，请避免使用过慢的输入输出方法。**

【样例 1 说明】

这个输入文件只有一个输入数据。一种最优的方案如下：

- 小 P 从节点 $2$ 开始入侵，节点 $2$ 被小 P 标记。

- 小 P 从节点 $2$ 入侵到节点 $4$，节点 $4$ 和经过的网线被小 P 标记。

- 小 P 从节点 $4$ 入侵到节点 $7$，节点 $7$ 和经过的网线被小 P 标记。

- 小 H 从节点 $10$ 开始入侵，节点 $10$ 被小 H 标记。

- 删除被标记的节点 $2,4,7,10$ 和被标记的网线 $(2,4)$ 和 $(4,7)$。

- 删除任意一端在上一步被删除的网线。

此时还剩下 $8$ 个连通块。其中节点 $1,3,5,6,8,9,11$ 各自形成一个连通块，节点$12,13$形成了一个连通块。


【样例 2 说明】

- 数据 1：只有 $1$ 个计算节点，唯一可行的方案是小 P 从节点 $1$ 开始入侵（并马上停止），小 H 也从节点 $1$ 入侵到节点 $1$。所有的节点都被删去，剩下 $0$ 个连通块。

- 数据 2：一种最优方案是，小 P 从节点 $1$ 入侵到节点 $1$，小 H 也从节点 $1$ 入侵到节点 $1$。在删除操作后，剩下 $1$ 个连通块（只有节点 $2$）。

- 数据 3：唯一的最优方案是，小 P 从节点 $2$ 入侵到节点 $2$，小 H 也从节点 $2$ 入侵到节点 $2$，剩下 $2$ 个连通块。

- 数据 4：一种最优方案是，小 P 从节点 $2$ 入侵到节点 $2$，小 H 也从节点 $2$ 入侵到节点 $2$，剩下 $2$ 个连通块。

- 数据 5：唯一的最优方案是，小 P 从节点 $5$ 入侵到节点 $5$，小 H 也从节点 $5$ 入侵到节点 $5$，剩下 $4$ 个连通块。



![](https://cdn.luogu.com.cn/upload/pic/38934.png)

![](https://cdn.luogu.com.cn/upload/pic/38935.png)

![](https://cdn.luogu.com.cn/upload/pic/38936.png)

对于整数 $k$，设$\sum n^k$ 为某个输入文件中，其$ T$ 个输入数据的 $n^k$ 之和。

对于所有数据，$T \leq 10^5, \sum n^1 <5 \times 10^5$

请注意初始化的时间复杂度，避免输入大量小数据时超时。

每个测试点的详细数据范围见下表。如果表中 “完全二叉” 为 Yes，则该输入文件的每个数据满足：网线信息的第 $j$ 行 $(1 \leq j < n)$ 输入的两个数依次是 $\left\lfloor \frac {j + 1} {2} \right\rfloor$ 和 $j + 1$。

![](https://cdn.luogu.com.cn/upload/pic/38937.png)

## 样例 #1

### 输入

```
1 0
13
1 2
2 3
2 4
4 5
4 6
4 7
7 8
7 9
9 10
10 11
10 12
12 13```

### 输出

```
8```

## 样例 #2

### 输入

```
8 0
1
2
1 2
3
1 2
2 3
4
1 3
2 3
2 4
5
1 5
2 5
3 5
4 5
16
1 2
1 3
1 4
1 5
5 6
5 7
5 8
5 9
9 10
9 11
9 12
9 13
13 14
13 15
13 16
17
1 2
1 3
1 4
1 5
5 6
5 7
5 8
5 17
17 9
9 10
9 11
9 12
9 13
13 14
13 15
13 16
17
8 6
2 6
11 6
4 6
14 2
10 2
5 4
1 4
9 8
17 11
12 5
3 6
13 6
16 8
7 11
15 16
```

### 输出

```
0
1
2
2
4
12
13
10
```

## 样例 #3

### 输入

```
8 1
1 1 1
2 1 1
1 2
3 2 2
1 2
2 3
4 2 2
1 3
2 3
2 4
5 5 5
1 5
2 5
3 5
4 5
16 1 5
1 2
1 3
1 4
1 5
5 6
5 7
5 8
5 9
9 10
9 11
9 12
9 13
13 14
13 15
13 16
17 1 5
1 2
1 3
1 4
1 5
5 6
5 7
5 8
5 17
17 9
9 10
9 11
9 12
9 13
13 14
13 15
13 16
17 2 4
8 6
2 6
11 6
4 6
14 2
10 2
5 4
1 4
9 8
17 11
12 5
3 6
13 6
16 8
7 11
15 16
```

### 输出

```
0
1
2
2
4
12
13
10
```

# 题解

## 作者：xiaolilsq (赞：36)

[题目链接](https://www.luogu.com.cn/problem/P3748)

这里提供一种**换根dp**的做法，可能比前面那些题解里面讲的做法容易实现且不难调试？（雾

> 题意：求树上两条不相交的路径（指的是没有边重合），使得删去路径上的边和点后剩下的联通块数量尽可能多。

不妨按树上两条路径的相对情况来分类讨论：

#### 情况一：两条路径存在点重合。

因为树上两个点之间只有一条路径，所以如果有点重合，那么**一定只会有一个点是公共点**，我们可以把这一个点单独拎出来作为根，不难发现所谓的两条路径可以视为 $1\sim 4$ 条链，其中链的一端就是根，只需要记录从根连出去的**前四大链**即可得到这种情况的答案。

#### 情况二：两条路径不存在点重合。

不难发现**必然存在一棵子树使得一条路径完全在这棵子树内而另外一条路径和这个子树没有交点**，考虑枚举每一棵子树，**规定这棵子树内的路径经过子树的根**，然后找到在这棵子树内的最优路径和子树外的最优路径。

不难发现，上面列出来所要求的都可以通过换根较容易地求出。

状态如下（以下所说的路径及链都可以退化为单点）：

设 $mx(u,k)$ 表示考虑在以 $u$ 为根的子树中，对于所有 $u$ 的儿子 $v$ 中 $dp(v)$ 第 $k+1$ 大的值。

设 $cnt(u)$ 表示 $u$ 的儿子数量。

设 $dp(u)$ 表示考虑在以 $u$ 为根的子树中，去掉以 $u$ 为一个端点的链后剩下的联通块数量的最大值。

设 $fp(u)$ 表示考虑在以 $u$ 为根的子树中，去掉经过 $u$ 点的某条路径后剩下的联通块数量的最大值。

设 $f(u)$ 表示考虑在以 $u$ 为根的子树中，去掉某条路径后剩下的联通块数量的最大值。

转移如下：

$$
dp(u)=\max(cnt(u),mx(u,0)+cnt(u)-1)
$$

$$
fp(u)=\max(dp(u),mx(u,0)+mx(u,1)+cnt(u)-2)
$$

发现 $f(u)$ 可能不太好转移，因为对于 $u$ 的儿子 $v$ 里面的一条路径，如果是经过 $v$ 点的话，只考虑以 $v$ 为根的子树是不会考虑到 $v$ 外面连着的 $u$ 所在的连通块造成的贡献，而如果不经过 $v$ 点的话， $u$ 所在的连通块是不会造成贡献的，所以考虑多记录点东西：

设 $f_0(u)$ 表示考虑在以 $u$ 为根的子树中，去掉某条路径后剩下的联通块数量的最大值；设 $f_1(u)$ 表示**认为删去 $u$ 点后 $u$ 外面还有一个连通块**，去掉某条路径后剩下的连通块数量的最大值。

然后我们再假设 $fmx(u)$ 表示对于所有 $u$ 的儿子 $v$ 中 $f_1(v)$ 的最大值。

转移就比较容易了：

$$
f_0(u)=\max(fmx(u),fp(u))
$$

$$
f_1(u)=\max(fmx(u),fp(u)+1)
$$

好的，看看我们转移用到了哪些东西： $fmx(u)$ 、 $mx(u,0)$ 以及 $mx(u,0)+mx(u,1)$ 。

显然，换根的时候只要记录： $fmx(u)$ 的最大次大， $mx(u,0)$ 的最大次大次次大。

不难发现，其实我们更新答案的时候要用到 $mx(u,0\sim 3)$ ，所以 $mx(u,0)$ 其实要记录前四大。

于是就可以愉快地写代码了：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define inf 500000000
using namespace std;
#define ch() getchar()
#define pc(x) putchar(x)
template<typename T>inline void read(T&x){
	int f;char c;
	for(f=1,c=ch();c<'0'||c>'9';c=ch())if(c=='-')f=-f;
	for(x=0;c<='9'&&c>='0';c=ch())x=x*10+(c&15);x*=f;
}
template<typename T>inline void write(T x){
	static char q[64];int cnt=0;
	if(!x)pc('0');if(x<0)pc('-'),x=-x;
	while(x)q[cnt++]=x%10+'0',x/=10;
	while(cnt--)pc(q[cnt]);
}
const int maxn=100005;
struct Edge{
	int v,nt;
	Edge(int v=0,int nt=0):
		v(v),nt(nt){}
}e[maxn*2];
int hd[maxn],num;
void qwq(int u,int v){
	e[++num]=Edge(v,hd[u]);hd[u]=num;
}
int mx[maxn][4],fmx[maxn][2];
void change(int x,int val){
	for(int i=0;i<4;++i)
		if(mx[x][i]<val)
			mx[x][i]^=val^=mx[x][i]^=val;
}
void fchange(int x,int val){
	for(int i=0;i<2;++i)
		if(fmx[x][i]<val)
			fmx[x][i]^=val^=fmx[x][i]^=val;
}
int dp[maxn],f[maxn][2],fp[maxn];
void dfs0(int u,int fa){
	int cnt=0;
	mx[u][0]=mx[u][1]=mx[u][2]=mx[u][3]=-inf;
	dp[u]=f[u][0]=f[u][1]=fmx[u][0]=fmx[u][1]=-inf;
	for(int i=hd[u];i;i=e[i].nt){
		int v=e[i].v;
		if(v==fa)continue;
		dfs0(v,u);++cnt;
		change(u,dp[v]);
		fchange(u,f[v][1]);
	}
	dp[u]=max(cnt,mx[u][0]+cnt-1);
	fp[u]=max(dp[u],mx[u][0]+mx[u][1]+cnt-2);
	f[u][0]=max(fmx[u][0],fp[u]);
	f[u][1]=max(fmx[u][0],fp[u]+1);
}
int ans,d[maxn];
void dfs1(int u,int fa){
	int sm=d[u];ans=max(ans,d[u]);
	for(int i=0;i<4;++i)
		ans=max(ans,sm+=mx[u][i]-1);
	int cnt=d[u]-1;
	for(int i=hd[u];i;i=e[i].nt){
		int v=e[i].v;
		if(v==fa)continue;
		int t=-1;
		for(int j=0;j<4;++j)
			if(mx[u][j]==dp[v])
				t=j;
		int mx0=mx[u][0],mx1=mx[u][0]+mx[u][1],mx2=fmx[u][0];
		if(t==0)mx0=mx[u][1],mx1=mx[u][1]+mx[u][2];
		else if(t==1)mx1=mx[u][0]+mx[u][2];
		if(fmx[u][0]==f[v][1])mx2=fmx[u][1];
		dp[u]=max(cnt,mx0+cnt-1);
		fp[u]=max(dp[u],mx1+cnt-2);
		f[u][0]=max(mx2,fp[u]);
		f[u][1]=max(mx2,fp[u]+1);
		ans=max(ans,f[u][0]+fp[v]);
		change(v,dp[u]);fchange(v,f[u][1]);
		dfs1(v,u);
	}
}
int main(){
	int T,x;
	read(T),read(x);
	while(T--){
		int n,tmp;
		read(n);
		for(int i=0;i<x;++i)
			read(tmp),read(tmp);
		num=0;
		for(int i=1;i<=n;++i)
			hd[i]=d[i]=0;
		for(int i=1;i<n;++i){
			int u,v;
			read(u),read(v);
			qwq(u,v);qwq(v,u);
			++d[u],++d[v];
		}
		ans=0;
		dfs0(1,0);dfs1(1,0);
		write(ans),pc('\n');
	}
	return 0;
}
```

~~成功降低了思维及讨论难度，为何不写换根呢？~~

---

## 作者：shadowice1984 (赞：27)

 _(精神污染警告：这道题带有极强的精神污染特质，请谨慎服用)_ 
 
  _(如果需要对拍支持直接看最下边，本题解赠送对拍器)_ 
# 树形DP

## 一句话题意

求树上两边不重合路径，使得删去路径上所有的点和边之后，剩下的森林联通块尽可能多，另外，如过我们可以解决x=0的情况，就可以AC本题，因为另外两个x都是其他情况(其实就是考试的时候方便劝退，直接告诉你AC本题性价比有多低)

### 1.路径的拆分

看起来要让我们dp路径，还记的一般的树形dp是怎么做的吗？，把待求的路径变成
一些我们可以处理的基本图形，通过dfs枚举lca的过程，枚举这些基本图形的合并，从而达到了枚举每个图形的目的

但问题是这道题是**两条互不相交的路径**，平常我们做的都是可爱的一条路径，只需dp一个一字形路径就好了，然后枚举lca的时候合并出所有的V字形路径。
对于这道题，我们采取类似的拆分手段，**枚举路径的所有可能情况，拆分处理**

#### 一些定义

在您阅读本题解的剩余部分时，不妨让我们来定义一些名词

**一字形路径**是指从u到v的一条路径，其中u是v的祖先或者v是u的祖先

**V字形路径是指**树上的**任意路径**，可以退化为一字型路径，V字形路径的顶点，是指u，v在树上的lca

**一个点**在本题中被视为**退化**的一种路径

##### 两条路径的所有可能情况

下面让我们来手动枚举路径的所有可能情况

 _(这才是这道题的精髓，充斥着各种退化与特例)_ 

###### Case 1:双V不交
也就是说这个树上有两条路径，并且，他们的V字形路径顶点之间不是祖先关系
我们发现这种情况十分的trival，可以拆分为两条V字形路径来做

###### Case2：双V嵌套

和Case1有些类似，也有两条树上的V型路径，但Case2要求树上的两条V型路径顶点必须为祖先关系，会发现我们并不能简单的拆分他，情况开始变得复杂

###### Case3：三叉/二叉

这时树上的两条路径点相交了，我们发现他们有一个重合的点，并且有一路形成了一个类似三叉戟的形状，当然，我们可能会发现其中的一种路径并没有出头，此时它退化为一个二叉的形状。此时情况开始变得辣手……

##### 将路径拆分为基本形状

我们发现似乎case1十分的可爱，他可以很轻易的被拆分为两条互不相干的V型路径，但是case2，3就有些辣手，此时我们该怎么办呢？

## 直接暴力的拆分即可

具体来讲，我们将路径的形状划分为5种type(如果真的看不懂定义的话可以看下面的图)

###### type1

tp1\[i]表示，在子树i中，删去一条过i的一字型路径，子树i分裂出的最大联通块数目。

###### type2

tp2\[i]表示，在子树i中删去一条过i的V字型路径，子树i分裂出最大联通块数目，**我们注意到type2可以被表示为两个type1拼起来**

###### type3

tp3\[i]表示，在子树i中删去一条**不经过i的路径**，子树i**增加**的最大联通块数目，(注意，尽管type3的定义十分的别扭，但是会给转移的**正确性**带来保障(并没说它会使转移简易)，事实上它长的太像type2了，但是我们必须严格区分这两个状态，否则转移将会乱七八糟)(这里要时刻记住，只有type3是增量定义的，这里指的是增加的量，比如删去了一个路径，产生两个联通块，此时type3=1，因为只增加了一个)

但是我们还是注意到**type3的形状和type2**一膜**一样**，只是位置不同

###### type4

tp4\[i]表示，在子树i中删去一条**经过i的一字型路径**，**可以**再删去一条不经过i的V字路径，此时子树i分裂出的最大联通块个数，
tp4的构成极其的复杂，但的确可以转移，待会再说

###### type5

tp5\[i]表示，在子树i中删去一条过i的三叉路径/二叉路径/一叉路径，i分裂出的最大联通块个数，tp5的构成相对简单(相对tp4而言，其实简单不到哪里去)

###### 图示

![](https://cdn.luogu.com.cn/upload/pic/15153.png)


##### 基本形状间的转移

下面记点i的孩子个数为s，孩子中type1的最大值为r1t1，以此类推。

###### tp1

我们发现tp1是非常可爱的，它的来源有两种

1.自己孩子中的tp1最大值，值为r1t1+s-1

2.删去自己这个点(退化情况)，值为s

###### tp2

我们发现tp2其实也不错，来源也是有两种

1.自己孩子的tp1最大值和次大值拼起来，值为r1t1+r2t1+s-2

2.自己的tp1(退化情况)，值为tp1

###### tp3

tp3的鬼畜定义决定了tp3的转移会非常简单,

如果最大的路径是孩子中的tp3,那么增量还是增量，如果最大的路径是tp2,那么由于tp2要求删根，所以tp2分裂的子树全部是增量，因此，tp3的转移方程为

max(r1t3,r1t2)

###### tp4

下面来看有趣的tp4，tp4的来源如下

1.选择孩子中的一个tp1和一个tp3，再删去自己，如果tp1的最大值和tp3的最大值不是一个，当然好说，否则，尝试用其中的一个次大值替换tp1或者tp3，两种tp各试一遍,转移的值为tp1+tp3+s-1因为tp3是增量定义，因此我们这里只用减去tp1需要减的1

2.选择孩子中的一个tp1和一个tp2，再删去自己，还是和tp3一样的转移逻辑，只是这里需要-2，因为tp2不是增量定义

3.删去自己，和孩子中的一个tp3(退化情况),此时因为tp3的增量定义，值r1t3+s

4.选择孩子中的一个tp4并删去自己，值为r1t4+s-1

###### tp5

tp5的转移相对简单，它的来源如下

1.孩子中的3条链，并删去自己，值为r1t1+r2t1+r3t1+s-3

2.孩子中的tp5,并删去自己，值为r1t5+s-1

3.自己的tp2(二叉退化情况),值为tp2\[i]

看起来好像转移不是很麻烦?

下面让我们来考虑更加有趣的合并情况

### 2.路径的合并

#### 合并路径的所有可能情况

##### 一般情况（没错还有各种有(e)趣（xin）的特例）

以下均假设我们dfs到了i，正在枚举i为lca的各种情况

###### case 1

~~我们发现(怎么老是发现？)~~我们观察得到，双V不交可以拆成tp3,tp3和,tp2,tp2,以及tp3,tp2

如果是纯粹的tp2或者tp3选取最大值和次大值就可以了

如果tp2,tp3混合选的话，考虑两种类型的最大值是不是一个，如果是一个的话，还是尝试用其中一种的次大值去替换tp2或者tp3，两种类型各自尝试一遍

如果孩子只有一个的话，我们在tp3和tp2中选一个

由于i无论如何都不会被删，最后要+1

###### case 2

我们观察得到，双V嵌套有着一堆辣手的特例，在此我们考虑一般情况，一般来讲，我们还是可以把一个双V嵌套拆成一个tp1，和一个tp4的

还是考虑孩子里两种类型的最大值是不是一个，如果不是一个的话再好不过，两个的最大值我都要，选择r1t1和r1t4,但是如果是一个的话尝试用次大值替换，还是两种类型都去试一遍

由于此时删掉了i因此我们要+上s-2，此时如果i不是根的话还要+1

当然我们也可以只应用tp4，就像样例中的方案，答案为r1t4+s-1+(fa\[i]!=0)

###### case 3

我们观察得到，三叉和二叉都是可以拆成一个tp1和一个tp5的

像case2一样考虑孩子里两种类型的最大值是否是同一个孩子，如果冲突依然尝试次大值替换法，两个类型都去试一遍

此时删去i，还是加上s-2,i不是根额外+1

同case2.可以只应用tp5.答案为r1t5+s-1+(fa\[i]!=0)

##### 友善的特例们

~~我们观察得到(怎么老是观察得到?)~~我们对拍发现，存在着一些十分优秀的特例可以卡掉我们的优(luo)美(so)的算法

难道我们要修改算法，使的它更加一般化？包含更多的情形？更加简洁，优美？

## 大力特判掉就好了

##### Special case 1 四叉

选取最大的4条链即可，答案为r1t1+r2t1+r3t1+r4t1+s-4

##### Special case 2 完美嵌套

注意到我们对case2的划分是无法处理完美嵌套的情况的，就是说两个V型路径的顶点连接起来的路径上，不包含其他的直线路径，更直白一点，删去最上边V型路径的顶点后，整个路径分裂为两个tp1和一个tp3/tp2我们发现此时根本没法分成一个tp1和一个tp4来做

而且，更加致命的是，我们此时要处理的是选择两个tp1,一个tp2/tp3，并且每个孩子只能选择一种属性，现在要求最大，此时我们就没办法使用刚才那种屡试不爽的次大值替代法了，因为考虑这样一种情况，尝试用第三大的tp1去替换，却发现和tp3冲突，当我们想要解决冲突的时候，尴尬的发现tp3的次大值和tp1的最大值重了……

难道我们的算法真的处理不了这种情况？不如我们换个算法？这样我们的算法会更加的优美，简洁，明了……

## 暴力枚举tp2/tp3选谁即可

如果发现当前枚举的孩子和r1t1/r2t1冲突，那么用r1t3替换，显然同一个东西不可能冲突两个值，答案就是当前枚举的值+r1t1/r2t2+r1t3+s-2+(fa\[i]!=0)

因为还是要删去根，tp2/tp3使用增量表示，所以只需减去t1的链就行了

### 复杂度

算法复杂度**O(N)**,但是我们要维护type1最大值，次大值，第三大值，type2最大值，次大值，type3最大值，次大值，type4最大值，次大值，type5最大值，次大值，以及各个type的最大值都是谁，对于type1额外维护一个次大值和第三大值都是谁，因此这里的复杂度O(N)指的是**耗时随着输入的增加而线性增长**，没有别的意思。

### 下面是对拍器

这道题直接使用人类的思维想的话，当然就是上面的**3个case5个type2个特例**+数不清的转移方式啦~

所以我们AC掉这道题的正确姿势当然是对拍+调试啦~

下面附赠对拍器一组~(用的时候新建一个root和seed文件，root存数据范围，seed存初始随机种子)

Checker

```c
#include<cstdlib>
#include<algorithm>
#include<cstdio>
using namespace std;
int ans1;int ans2;int t;
int main()
{
    printf("对拍中……\n");
    while(ans1==ans2)
    {
        t++;
        system("maker.exe");
        system("runner.exe");
        freopen("run.out","r",stdin);
        scanf("%d",&ans1);
        fclose(stdin);
        system("std.exe");
        freopen("std.out","r",stdin);
        scanf("%d",&ans2);
        fclose(stdin);
        printf("第 %d 组数据:",t);
        printf("run:%d std:%d\n",ans1,ans2);
    }
    printf("出现错误……\n");
    printf("请检查相应的文件\n");
    system("pause");
    return 0;
}
```
MAKER 注意这里并没有srand(time(0))1s内可拍多组数据(前提是你关360)

```c
#include<cstdio>
#include<algorithm>
#include<ctime>
#include<cstdlib>
using namespace std;
int tree[100010];int t;int x;int n;int sed;
int main()
{
    freopen("seed.sed","r",stdin);
    scanf("%d",&sed);srand(sed);
    fclose(stdin);
    freopen("seed.sed","w",stdout);
    printf("%d",rand()*time(0));
    fclose(stdout);
    freopen("root.rot","r",stdin);
    freopen("test.in","w",stdout);
    scanf("%d%d",&t,&x);
    scanf("%d",&n);
    printf("%d %d\n",t,x);
    printf("%d\n",n);
    for(int i=1;i<=n;i++){tree[i]=i;}
    random_shuffle(tree+1,tree+n+1);
    for(int i=2;i<=n;i++){printf("%d %d\n",tree[i],tree[rand()%(i-1)+1]);}
    fclose(stdin);fclose(stdout);
    return 0;
}
```

然后是runner和std要加的文件读入命令

runner

```C
freopen("test.in","r",stdin);
freopen("run.out","w",stdout);
//do sth
fclose(stdin);fclose(stdout);
```

std

```c
freopen("test.in","r",stdin);
freopen("std.out","w",stdout);
//do sth
fclose(stdin);fclose(stdout);
```
上代码~

```c
#include<cstdio>
#include<algorithm>
#include<cstdlib>
using namespace std;
int t;int x;const int N=1e5+10;
struct data{int v;int nxt;}edge[2*N];
int alist[N];int cnt;int emp1;int emp2;int emp3;int emp4;
inline void add(int u,int v)
{edge[++cnt].v=v;edge[cnt].nxt=alist[u];alist[u]=cnt;}
bool book[N];int tp1[N];int tp2[N];int tp3[N];int tp4[N];
int tp5[N];int res;int n;//各类tp的定义见题解 
void dfs(int x,int fa)
{
    book[x]=true;int nxt=alist[x];//对的，其实我们要维护这么多变量 
    int r1t1;int r2t1;int r3t1;int r1t2;int r2t2;int r1t3;int r2t3;
    int r1t4;int r2t4;int r1t5;int r2t5;int mt1;int ct1;int dt1;int mt2;
    int mt3;int mt4;int mt5;int s;s=mt1=ct1=dt1=mt2=mt3=mt4=mt5=0;
    r1t1=r2t1=r3t1=r1t2=r2t2=r1t3=r2t3=r1t4=r2t4=r1t5=r2t5=0;
    while(nxt)
    {
        int v=edge[nxt].v;
        if(!book[v])
        {
            dfs(v,x);s++;//维护最大值，次大值们，和最大值都是谁 
            if(tp1[v]>r1t1){dt1=ct1;ct1=mt1;mt1=v;r3t1=r2t1;r2t1=r1t1;r1t1=tp1[v];}
            else if(tp1[v]>r2t1){dt1=ct1;ct1=v;r3t1=r2t1;r2t1=tp1[v];}
            else if(tp1[v]>r3t1){dt1=v;r3t1=tp1[v];}
            if(tp2[v]>r1t2){mt2=v;r2t2=r1t2;r1t2=tp2[v];}
            else if(tp2[v]>r2t2){r2t2=tp2[v];}
            if(tp3[v]>r1t3){mt3=v;r2t3=r1t3;r1t3=tp3[v];}
            else if(tp3[v]>r2t3){r2t3=tp3[v];}
            if(tp4[v]>r1t4){mt4=v;r2t4=r1t4;r1t4=tp4[v];}
            else if(tp4[v]>r2t4){r2t4=tp4[v];}
            if(tp5[v]>r1t5){mt5=v;r2t5=r1t5;r1t5=tp5[v];}
            else if(tp5[v]>r2t5){r2t5=tp5[v];}
        }
        nxt=edge[nxt].nxt;
    }
    if(s==0)return;
    tp1[x]=max(r1t1+s-1,s);//更新tp1 ,tp2
    if(s>1){tp2[x]=max(r1t1+r2t1+s-2,tp1[x]);}else tp2[x]=tp1[x];
    tp3[x]=max(r1t3,r1t2);//更新tp3 
    if(s>1)//分情况讨论tp4 
    {
        if(mt1==mt3){tp4[x]=max(r1t1+r2t3+s-1,r2t1+r1t3+s-1);}else {tp4[x]=r1t1+r1t3+s-1;}
        if(mt1==mt2){tp4[x]=max(tp4[x],max(r1t1+r2t2+s-2,r2t1+r1t2+s-2));}else {tp4[x]=max(tp4[x],r1t1+r1t2+s-2);}
    }tp4[x]=max(tp4[x],r1t3+s);tp4[x]=max(tp4[x],r1t4+s-1);//更新tp5 
    if(s>2){tp5[x]=r1t1+r2t1+r3t1+s-3;}tp5[x]=max(tp5[x],tp2[x]);tp5[x]=max(tp5[x],r1t5+s-1);
    if(s>1)//合并case 1 
    {
        res=max(r1t3+r2t3+1,res);res=max(r1t2+r2t2+1,res);
        if(mt2==mt3){res=max(max(r1t2+r2t3+1,r2t2+r1t3+1),res);}
        else {res=max(r1t2+r1t3+1,res);}
    }else {res=max(max(r1t3,r1t2)+1,res);}
    if(s>1)//合并case 2 
    {
        if(mt1==mt4){res=max(max(r1t1+r2t4,r2t1+r1t4)+(fa!=0)+s-2,res);}
        else {res=max(r1t1+r1t4+s-2+(fa!=0),res);}
    }res=max(tp4[x]+(fa!=0),res);
    if(s>1)//合并case 3 
    {
        if(mt1==mt5){res=max(max(r1t1+r2t5,r2t1+r1t5)+(fa!=0)+s-2,res);}
        else {res=max(r1t1+r1t5+(fa!=0)+s-2,res);}
    }res=max(tp5[x]+(fa!=0),res);
    if(s>2)//大力的特判特例，这里并没有维护第四大值，而是一起取max取出来 
    {
        nxt=alist[x];int ma=0;
        while(nxt)
        {
            int v=edge[nxt].v;
            if(v!=fa)
            {
                int va=max(tp3[v],tp2[v]-1);
                if(v!=ct1&&v!=mt1)
                {res=max(va+r1t1+r2t1+(fa!=0)+s-2,res);if(s>3&&v!=dt1){ma=max(ma,tp1[v]);}}
                else if(v==ct1){res=max(va+r1t1+r3t1+(fa!=0)+s-2,res);}//处理冲突 
                else if(v==mt1){res=max(va+r2t1+r3t1+(fa!=0)+s-2,res);}
            }nxt=edge[nxt].nxt;
        }if(s>3){res=max(ma+r1t1+r2t1+r3t1+s-4+(fa!=0),res);}//处理四叉情况 
    }return;//结束dfs	
}
inline void clear()//清空函数 
{
    for(int i=1;i<=n;i++)//清邻接表只清alist就足够了 
    {alist[i]=0;tp1[i]=0;tp2[i]=0;tp3[i]=0;tp4[i]=0;tp5[i]=0;book[i]=false;}
    cnt=0;res=0;
}
int main()
{
    scanf("%d%d",&t,&x);
    for(int z=1;z<=t;z++)
    {
        scanf("%d",&n);switch(x)//无视题目的提示 
        {
            case 0:{break;}
            case 1:{scanf("%d%d",&emp1,&emp2);break;}
            case 2:{scanf("%d%d%d%d",&emp1,&emp2,&emp3,&emp4);break;}
        }
        for(int i=1;i<n;i++){int u;int v;scanf("%d%d",&u,&v);add(u,v);add(v,u);}
        dfs(1,0);printf("%d\n",res);clear();
    }return 0;//拜拜程序~ 
}
```
















---

## 作者：Krystallos (赞：23)

## UPD 2021/3/23: 代码贴错的问题终于有人指出来了
~~我个人非常不理解考场上为什么会出现这么\*\*的动规，真就推式子一小时写码十分钟呗~~  
### 24分，x=2
~~不会真的有人不会照着给出的方案模拟然后统计答案吧不会吧不会吧~~
### 另24分，x=1
~~关于这个部分分小编也没想出来怎么做，有知道的小伙伴可以在评论区留言哦~~
### 100分
~~我们非常的勇认为我们可以不需要靠给出的方案直接算正解（~~  
对于每个节点 $p$ 我们定义四个状态 $f_{p, 0 \sim 3}$，下面我们将对每个状态分别解释含义 **（只是演示切除链的形态，不代表这么切最优）**  
$f_{p, 0}$: 切除一条端点在 $p$ 且另一端点在子数内的链的答案，这条链就像这样：  
![](https://cdn.luogu.com.cn/upload/image_hosting/96jd3hwl.png)  
$f_{p, 1}$：切除一条两个端点在 $p$ 子树内且链不经过 $p$ 的链的答案：  
![](https://cdn.luogu.com.cn/upload/image_hosting/tchv6a1t.png)  
$f_{p, 2}$：切除一条两个端点在 $p$ 子树内且经过 $p$ 的链的答案：  
![](https://cdn.luogu.com.cn/upload/image_hosting/vmhucbhj.png)  
$f_{p, 3}$：切除一条端点在 $p$ 且另一端点在子数内的链与一条两个端点在 $p$ 子树内且经过 $p$ 的链的答案：  
![](https://cdn.luogu.com.cn/upload/image_hosting/tlsb1soe.png)  
~~以下内容可能引起不适请谨慎观看~~  
对于每个讨论到的节点 $p$ ，枚举其的儿子 $son$，假设已经将 $son$ 的状态讨论完毕，那么现在有一下六种情况可以更新答案：
* $f_{p, 3} + f_{son, 0} - (p == 1)$（因为如果 $p$ 是 $1$ 那么上方没有其他连通块要减掉 $1$，之后同理）：  ![](https://cdn.luogu.com.cn/upload/image_hosting/9up1p78c.png)  ~~画图逐渐抽象~~  
* $f_{p, 0} + f_{son, 3} - (p == 1)$：  ![](https://cdn.luogu.com.cn/upload/image_hosting/5jayqfbs.png)  
* $f_{p, 1} + f_{son, 2}$（因为无论 $p$ 上方有没有节点都不影响答案所以不需要判 $p$ 为 $1$）：  ![](https://cdn.luogu.com.cn/upload/image_hosting/p5205kil.png)  
* $f_{p, 1} + f_{son, 1} - 1$（上方没切到的地方连到一起了多算了一个要减一）：  ![](https://cdn.luogu.com.cn/upload/image_hosting/vgyjyza5.png)  
* $f_{p, 2} + f_{son, 1} - (p == 1)$：  ![](https://cdn.luogu.com.cn/upload/image_hosting/4nxj6ui2.png)  
* $f_{p, 2} + f_{son, 2} - (p == 1)$：  ![](https://cdn.luogu.com.cn/upload/image_hosting/xxmkaolt.png)  	
~~坐下，这才刚开始呢，继续往下看~~  
有一种方案可以推得 $f_{p, 0}$，即直接在 $f_{son, 0}$ 的基础上删掉节点 $p$，$f_{son, 0} + deg_p - 1$（其中 $deg_p$ 的意思是 $p$ 的儿子数）：  
![](https://cdn.luogu.com.cn/upload/image_hosting/844za5g7.png)  
有两种方案可以推得 $f_{p, 1}$：  
$f_{q, 1}$（直接继承)：  
![](https://cdn.luogu.com.cn/upload/image_hosting/na535r4w.png)  
$f_{q, 2} + 1$：  
![](https://cdn.luogu.com.cn/upload/image_hosting/f4fmrqah.png)  
有一种方案可以推得 $f_{p, 2}$，即$f_{p, 0} + f_{q, 0} - 1$：  
![](https://cdn.luogu.com.cn/upload/image_hosting/2t7jju0c.png)  
~~要来力（~~  
有五种方案可以推得 $f_{p, 3}$ ~~（惊不惊喜意不意外）~~：  
$f[p][0] + f[q][2] - 1$：  
![](https://cdn.luogu.com.cn/upload/image_hosting/v8vefygk.png)  
$f[p][0] + f[q][1] - 1$：  
![](https://cdn.luogu.com.cn/upload/image_hosting/dgxvfe1i.png)  
$f[p][2] + f[q][0] - 1$：  
![](https://cdn.luogu.com.cn/upload/image_hosting/v0u3dqdf.png)  
$f[q][3] + deg[p] - 1$：  
![](https://cdn.luogu.com.cn/upload/image_hosting/xb0sawkv.png)  
$f[q][0] + deg[p] + ret - 2$：  
（$ret$ 的意思是之前讨论的儿子 $q$ 中最大的 $f_{q, 1}$ 和 $f_{q, 2}$）
![](https://cdn.luogu.com.cn/upload/image_hosting/3bm7dc7g.png)  
初始化的问题：$f_{p, 0}$，$f_{p, 2}$，$f_{p, 3}$ 设为 $deg_p$，即只切掉节点 $p$；$f_{p, 1}$ 设为 $1$，即不切。  
~~好了完了（~~  
code:  
```cpp
#include <iostream>
#include <cstdio>
const int BUFFER_SIZE = 1 << 20;
char rb[BUFFER_SIZE], *rp = rb, *rt = rb;
inline char read_char() {
    return rp == rt ? (rt = rb + fread(rb, 1, BUFFER_SIZE, stdin), rp = rb, *rp++) : *rp++;
}
inline int read_int() {
    int x = 0;
    char ch = read_char(), flag = 0;
    while (ch != '-' && (ch < '0' || ch > '9')) {
        ch = read_char();
    }
    if (ch == '-') {
        flag = 1;
        ch = read_char();
    }
    for (x = 0; ch >= '0' && ch <= '9'; ch = read_char()) {
        x = x * 10 + (ch - '0');
    }
    return flag ? -x : x;
}
const int nn = 1e5 + 5;
int T, n, x, ans;
int cnt = 0, last[nn], prev[nn << 1], to[nn << 1];
inline void addedge(int p, int q) {
    ++cnt;
    prev[cnt] = last[p];
    last[p] = cnt;
    to[cnt] = q;
}
inline void change(int &a, const int b) { a = a > b ? a : b; }
int deg[nn], f[nn][4];
void dp(int p, int father) {
    f[p][0] = f[p][2] = f[p][3] = deg[p];
    f[p][1] = 1;
    int ret = 0;
    for (int i = last[p], q; i; i = prev[i]) {
        if ((q = to[i]) != father) {
            dp(q, p);
            change(ans, f[p][3] + f[q][0] - (p == 1));
            change(ans, f[p][0] + f[q][3] - (p == 1));
            change(ans, f[p][1] + f[q][2]);
            change(ans, f[p][1] + f[q][1] - 1);
            change(ans, f[p][2] + f[q][1] - (p == 1));
            change(ans, f[p][2] + f[q][2] - (p == 1));
            change(f[p][1], f[q][1]);
            change(f[p][1], f[q][2] + 1);
            change(f[p][3], f[p][0] + f[q][2] - 1);
            change(f[p][3], f[p][0] + f[q][1] - 1);
            change(f[p][3], f[p][2] + f[q][0] - 1);
            change(f[p][3], f[q][3] + deg[p] - 1);
            change(f[p][3], f[q][0] + deg[p] + ret - 2);
            change(f[p][2], f[p][0] + f[q][0] - 1);
            change(f[p][0], f[q][0] + deg[p] - 1);
            change(ret, f[q][1]);
            change(ret, f[q][2]);
        }
    }
}   
void solve() {
    n = read_int();
    for (int i = 1; i <= x; ++i) { read_int(); read_int(); }
    for (int i = 2, p, q; i <= n; ++i) {
        ++deg[p = read_int()];
        ++deg[q = read_int()];
        addedge(p, q);
        addedge(q, p);
        --deg[i];
    }
    dp(1, 0);
    printf("%d\n", ans);
    ans = cnt = 0;
    for (int i = 1; i <= n; ++i) last[i] = deg[i] = 0;
}
int main() {
    T = read_int(); x = read_int();
    while (T--) solve();
}
```

---

## 作者：行吟啸九州 (赞：8)

这个题在考场上，我觉得水平和我一样比较一般的选手，大都不会去思考这个正解，因为感觉这个正解太复杂了，而84分的纯暴力又太香，而我看题解区也没有什么部分分，所以就来说一下我能想到的暴力吧。

算法一：对于x = 2的点，我们模拟这个删除过程，把删除的边都打上标记。然后我们删掉所有的边，加回所有没有标记的边，过程中用并查集维护连通块即可，由于本人写并查集不按秩合并，所以有个```logn```，时间复杂度O（$\sum$
```nlogn```）。 

算法二：对于1 - 7个点，可以枚举四个端点，然后相当于x = 2的情况，调用算法一，时间复杂度O（$n ^5$```lognT```），不过还需要判定两条路径不能有交，这个可以通过跳LCA过程中打标记实现，所以最后的时间复杂度O($n ^6$```lognT```)，有很多复杂度更优的办法，不过这是暴力嘛，怎么方便怎么来。

算法三：对于x = 1的点，我们相当于在一个森林上找一条路径，使得删去这个路径得到的联通块最多。这个可以用树dp求，```f[i]```代表从i子树内一点开始，连到i的路径里删去一条最多能产生多少个联通块，```g[i]```代表i子树内的一条路径里删去一条最多能产生多少个联通块。我们可以利用类似于求树的直径的办法求出来f与g数组，各个联通块取最大即可，时间复杂度O($\sum$n)。

算法四：对于```x = 0, n <= 100```的点，我们可以枚举两个端点，用算法三的办法进行树dp，时间复杂度O($\sum$$n^3$)。

然后就获得了84分的好成绩。

---

## 作者：ViXbob (赞：8)

[滋磁去我博客看吖](http://www.vixbob-lwc.pw/2019/05/12/2017-six-provinces-joint-examination/)

一句话题意:选出两条没有边交的链, 使得删掉和选出的链上所有点相关的边后联通块个数最大.

经过计算我们发现联通块的个数等于选出的点的度数和$-$边数$\times 2-$链的个数+1, 边数又等于选出的点数$-$链的个数.所以答案为选出的点的度数和-点数$\times 2+$链的个数$+$1.(没有点交,并且没有两个点属于不同的链但是有直接边相连的这两种情况.特殊的这两种情况答案都要减一.)

考虑$\text{dp}$, 设$f[i][0/1/2][0/1/2/3]$表示$\text{dp}$完了$i$这个子树, 确定了$0/1/2$条链, $i$的度数为$0/1/2/3$(只考虑选出来的链对度数的影响)的最优答案.特别的一个点的链这个点的度数为$1$.

定义几个函数:

1. $\text{MxSum(S)}$表示$S$集合中最大元素和次大元素的和.
2. $\text{MaxF(x,d)}$表示$\max_{0 \le k\le 3}(f[x][d][k])$
3. $\text{EMaxF(x,d)}$表示$\max_{0 \le k \le 3}(f[x][d][k]-[k>0])$

转移有点毒瘤, 要分类讨论一下:

1. $f[i][1][0] \leftarrow f[v][1][k], v \in son_i, k\in [0,2]$.
2. $f[i][1][1] \leftarrow f[v][1][1], v\in son_i.$
3. $f[i][1][2] \leftarrow \text{MxSum}(\{f[v][1][1], v \in son_i\}).$
4. $f[i][2][0] \leftarrow \max(\max_{v\in son_i}(\text{MaxF(v,2)}),\text{MxSum}(\{\text{MaxF(v,1)}, v\in son_i\}))$.

上面这$4$种转移比较简单,剩下的四种较为复杂:

一.$f[i][2][1]$:

1. 这个点单独成一条链,然后儿子节点的子树当中再选一条链.$f[i][2][1]\leftarrow \max(f[v][1][0], f[v][1][1]-1), v\in son_i$.
2. 从某一个儿子的子树当中延伸出来一条链, **另外**的一个儿子的子树中选一条链.$f[i][2][1]\leftarrow f[u][1][1]+\max_{v\in son_i, v \ne u}(\text{EMaxF(v,1)}), u\in son_i$.

二.$f[i][2][2]$:

1. 从某一儿子的子树中延伸出来的一条链(这个子树确定了两条链),**另外**的一个儿子的子树中再选一条可以延伸的链(这个子树确定了一条链).$f[i][2][2] \leftarrow \max(f[u][2][3], f[u][2][1])+\max_{u \in son_i, u \ne v}(f[u][1][1]), v \in son_i$.
2. 从某一个儿子的子树中选择一条链, **另外**两个儿子的子树中都有一条可以延伸出来的链(这两个子树都只确定了一条链).$f[i][2][2]\leftarrow \text{EMaxF(u,1)}+\text{MxSum}(\{f[u][1][1], u \in son_i, u \ne v\}),v \in son_i$.

三.$f[i][2][3]$和$f[i][2][4]$:

都是直接选择儿子节点中$f[v][1][1]$中前$3/4$大的进行转移即可.因为这两种情况都是有点交的,所以答案减一.

PS:$f[i][2][4]$这个状态不用记下来,只用更新一下答案就好了.并且处理完每一个节点后将所有度数大于零的状态加上$deg[i]-2$.

代码:
```cpp
/*
 * 4871_new.cpp
 * This file is part of 4871
 *
 * Copyright (C) 2019 - ViXbob
 *
 * 4871 is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * 4871 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with 4871. If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * There is no end though there is a start in space. ---Infinity.
 * It has own power, it ruins, and it goes though there is a start also in the star. ---Finite.
 * Only the person who was wisdom can read the most foolish one from the history.
 * The fish that lives in the sea doesn't know the world in the land.
 * It also ruins and goes if they have wisdom.
 * It is funnier that man exceeds the speed of light than fish start living in the land.
 * It can be said that this is an final ultimatum from the god to the people who can fight.
 *
 * Steins;Gate
 */
#include <bits/stdc++.h>
#define rep(i, j, k) for(int i = j; i <= k; ++i)
#define dep(i, j, k) for(int i = j; i >= k; --i)
#define SIZE(x) ((int)x.size())
#define mp(x, y) make_pair(x, y)
#define pb(x) push_back(x)

typedef long long ll;
typedef unsigned long long ull;

template <typename T> bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }
template <typename T> bool chkmin(T &a, T b) { return a > b ? a = b, 1 : 0; }

using namespace std;

const int maxn = 1e5 + 15;
const int P = 998244353;
const int inf = 0x3f3f3f3f;

int f[maxn][3][4], T, x;

inline int read() {
	char ch = getchar(); int u = 0, f = 1;
	while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar(); }
	while(isdigit(ch))  { u = u * 10 + ch - 48; ch = getchar(); } return u * f;
}

inline int pls(int x, int y) { x += y; return x >= P ? x - P : x; }
inline int dec(int x, int y) { x -= y; return x < 0 ? x + P : x; }
inline int max(int a, int b, int c) { return max(a, max(b, c)); }
inline int max(int a, int b, int c, int d) { return max(a, max(b, c, d)); }

namespace ViXbob {
	int n, fa[maxn], z, deg[maxn], ans;
	vector<int> G[maxn];
	
	inline void init() {
		n = read(); ans = 0; z = x;
		rep(i, 1, n) G[i].clear();
		rep(i, 1, n) rep(j, 0, 2) rep(k, 0, 3) f[i][j][k] = -inf;
		memset(fa, 0, sizeof(int) * (n + 5));
		memset(deg, 0, sizeof(int) * (n + 5));
	}
	
	inline int calcout(int x) { return max(f[x][2][3], f[x][2][1], f[x][1][1]); }
	inline int calcall(int x, int d) { return max(f[x][d][0], f[x][d][1], f[x][d][2], f[x][d][3]); }
	inline int calcall0(int x) { return max(f[x][1][0], max(f[x][1][1], f[x][1][2], f[x][1][3]) - 1); }
	
	struct Node {
		int g0, g1;
		Node(int a = -inf, int b = -inf) { g1 = a; g0 = b; }
		Node operator & (const Node &t) const {
			Node rnt = *this;
			if(t.g0 >= g1) return t;
			else {
				if(t.g1 >= rnt.g1) rnt.g0 = rnt.g1, rnt.g1 = t.g1;
				else rnt.g0 = max(rnt.g0, t.g1); 
			} return rnt;
		}
		int sum() { return g0 + g1; }
	} ;
	
	inline void dfs(int x) {
		vector<int> Ans;
		f[x][1][1] = 0;
		for(auto v : G[x]) if(v != fa[x]) {
			fa[v] = x; dfs(v);
			Ans.pb(f[v][1][1]);
			chkmax(f[x][1][1], f[v][1][1]);
			chkmax(f[x][1][0], calcall(v, 1));
			chkmax(f[x][2][0], calcall(v, 2));
			chkmax(f[x][2][1], max(f[v][2][3], f[v][2][1], f[v][1][0], f[v][1][1] - 1));
		}
		if(Ans.size() >= 2) {
			vector<Node> pre, preout;
			pre.resize(G[x].size() + 1);
			preout.resize(G[x].size() + 1);
			Node suc, sucout, mx0;
			rep(i, 0, SIZE(G[x]) - 1) {
				int v = G[x][i];
				pre[i + 1] = pre[i]; preout[i + 1] = preout[i];
				if(v == fa[x]) continue;
				pre[i + 1] = pre[i + 1] & Node(calcall0(v));
				preout[i + 1] = preout[i + 1] & Node(f[v][1][1], -inf);
				mx0 = mx0 & Node(calcall(v, 1));
			}
			chkmax(f[x][2][0], mx0.sum());
			chkmax(f[x][1][2], preout.rbegin() -> sum());
			dep(i, SIZE(G[x]) - 1, 0) if(G[x][i] != fa[x]) {
				int v = G[x][i];
				chkmax(f[x][2][1], f[v][1][1] + (pre[i] & suc).g1);
				chkmax(f[x][2][2], max(f[v][2][3], f[v][2][1]) + (preout[i] & sucout).g1);
				if(SIZE(Ans) >= 3) chkmax(f[x][2][2], (preout[i] & sucout).sum() + calcall0(v));
				suc = suc & Node(calcall0(v), -inf);
				sucout = sucout & Node(f[v][1][1], -inf);
			}
		}
		if(Ans.size() >= 3) {
			sort(Ans.begin(), Ans.end(), greater<int>());
			int rnt = 0;
			rep(i, 0, 2) rnt += Ans[i];
			chkmax(f[x][2][3], rnt - 1);
			if(Ans.size() >= 4) chkmax(ans, rnt + Ans[3] + deg[x]);
		}
		rep(i, 1, 2) rep(j, 1, 3) f[x][i][j] += deg[x] - 2;
	}
	
	int main() {
		while(T--) {
			init();
			while(z--) read(), read();
			rep(i, 1, n - 1) {
				int x = read(), y = read();
				G[x].pb(y); G[y].pb(x);
				deg[x]++; deg[y]++;
			}
			if(n <= 2) { putchar(n - 1 + '0'); putchar('\n'); continue; }
			dfs(1);
			rep(i, 1, 2) rep(j, 0, 3) chkmax(ans, f[1][i][j] + i + 1);
			printf("%d\n", ans);
		} return 0;
	}
}

int main() {
//	freopen("1.in", "r", stdin);
//	freopen("my.out", "w", stdout);
	T = read(); x = read();
	ViXbob :: main();
	return 0;
}
/*
*/
```

---

## 作者：Imakf (赞：5)

### [六省联考2017]摧毁树状图

#### tag：树型dp

介绍一种从网上看来的做法，码量很小（迫真）。

首先给出一些定义：

把 $1$ 作根，$deg_i$ 表示 $i$ 号节点的儿子数量。

**路径**，表示选择树上两个点切除的一种方案，即与题目定义中一样。

**链**，表示端点为当前正在 $dp$ 的节点 $x$ 的特殊路径，__注意路径是可以退化为链的__。

所以路径可以看成是两条链拼凑而成的。

__下文会有一些图片，可能方便理解__，我们用$\color{red}\text{红色}$表示一条路径，$\color{#23f3a2}\text{绿色}$表示一条链，虚线表示两条链在本次转移中合成了一条路径。

- $dp_{x,0}$ 表示切除一条端点在 $x$ 上的链的最大答案；
- $dp_{x,1}$ 表示切除一条不经过 $x$ 的路径的最大答案（注意这个时候 $x$ 和它的祖先构成的联通块是会被算入答案的，所以转移的时候我们要对此进行修正）；
- $dp_{x,2}$ 表示切除一条经过 $x$ 的路径的最大答案；
- $dp_{x,3}$ 表示切除一条端点在 $x$ 上的链，和子树内一条路径（可以经过 $x$）的最大答案；

更新答案时考虑枚举一个儿子 $d$。

则 $Ans$ 可能被下列所有值取代：

1. $dp_{x,3}+dp_{d,0}-1+[x\not=1]$

2. $dp_{x,0}+dp_{d,3}-1+[x\not=1]$

此处 $-1$ 是因为链合并导致联通块数量减少，$+[x\not=1]$ 是因为如果不是根，那么 $x$ 的上方还有一个联通块

![](https://cdn.luogu.com.cn/upload/image_hosting/9ubvb06x.png)

3. $dp_{x,1}+dp_{d,2}$
4. $dp_{x,1}+dp_{d,1}-1$



![](https://cdn.luogu.com.cn/upload/image_hosting/28m6zw0z.png)

5. $dp_{x,2}+dp_{d,1}-1+[x\not=1]$
6. $dp_{x,2}+dp_{d,2}-1+[x\not=1]$

![](https://cdn.luogu.com.cn/upload/image_hosting/vpm3pikm.png)

于是可以完成答案的更新。

-------------

更新完答案之后还要更新 $dp$ 数组。

一开始令 $dp_{x,0}=dp_{x,2}=dp_{x,3}=deg_x,dp_{x,1}=1$，分别表示选 $x$ 节点本身和选子树中的一个叶子。如果本身是叶子那么根本不会进入循环更新答案，故没有问题。

枚举了一个儿子 $d$，就开始更新 $dp$ 值。

$dp_{x,1}=\max\{dp_{x,1},dp_{d,1},dp_{d,2}+1\}$

要么就是直接继承一条不经过 $d$ 的，要么继承一条经过 $d$ 的。由于经过 $d$ 的路径的答案没有算 $d$ 的祖先构成的联通块，于是 $+1$。

$dp_{x,3}$ 可以由下列 $5$ 种转移过来：

1. $dp_{x,0}+dp_{d,2}-1$，直接拼凑一条链和一条路径，由于 $d$ 为 $x$ 的儿子，所以算多了一个联通块，减掉即可；
2. $dp_{x,0}+dp_{d,1}-1$，与转移 1 同理；
3. $dp_{x,2}+dp_{d,0}-1$，把链的端点从 $d$ 延伸到 $x$，由于 $d$ 为 $x$ 的儿子，所以算多了一个联通块，减掉即可；
4. $dp_{d,3}+deg_x-1$，与转移 3 解释相同；
5. 令 $res$ 为 $\max\limits_{i\in\text{在} d \text{之前就考虑过的儿子}}\{dp_{i,1} ,dp_{i,2}\}$，则有 $dp_{d,0}+deg_x+res-2$，表示从当前儿子选一条链，然后再在其它儿子里选一条路径，选用了两个儿子，减掉即可。

$dp_{x,2}=\max\{dp_{x,2},dp_{x,0}+dp_{d,0}-1\}$ 

选用两条链拼起来。

$dp_{x,0}=\max\{dp_{x,0},dp_{d,0}+deg_x-1\}$

直接继承儿子的链。



由于路径可能退化为链，链可以退化成点，所以最后还要更新一遍：

$dp_{x,2}=\max\{dp_{x,2},dp_{x,0}\}$

$dp_{x,3}=\max\{dp_{x,3},dp_{x,2}\}$


以下是~~整齐的~~代码


```cpp
#include <cstdio>
#include <cstring>
#include <ctime>
#include <cstdlib>

const int MX = 1e5 + 233;

int read(){
	char k = getchar(); int x = 0;
	while(k < '0' || k > '9') k = getchar();
	while(k >= '0' && k <= '9')
		x = x * 10 + k - '0' ,k = getchar();
	return x;
}

int head[MX] ,tot ,type ,deg[MX] ,n ,Ans;
struct edge{
	int node ,next;
}h[MX << 1];
void addedge(int u ,int v ,int flg = 1){
	h[++tot] = (edge){v ,head[u]} ,head[u] = tot;
	if(flg) addedge(v ,u ,0);
}

void init(int upper){
	tot = 0 ,Ans = 0;
	for(int i = 0 ; i <= upper ; ++i) deg[i] = head[i] = 0;
}

int max(int a ,int b){return a > b ? a : b;}
void chkmax(int &a ,int b){a = max(a ,b);}
int dp[MX][4];

// dp[0] 表示一条经过 x 的链	
// dp[1] 表示一条不经过 x 的路径
// dp[2] 表示一条经过 x 的路径
// dp[3] 表示一条经过 x 的一条链和一条子树内（可以过x）的路径
// 因为是逐个儿子考虑的，所以只要不乱更新就不会算多

void dapai(int x ,int f){
	dp[x][0] = dp[x][2] = dp[x][3] = deg[x];
	dp[x][1] = 1;

	int res = 0;
	for(int i = head[x] ,d ; i ; i = h[i].next){
		if((d = h[i].node) == f) continue;
		dapai(d ,x);
		chkmax(Ans ,dp[x][3] + dp[d][0] - (x == 1));
		chkmax(Ans ,dp[x][0] + dp[d][3] - (x == 1));
		chkmax(Ans ,dp[x][1] + dp[d][2]);
		chkmax(Ans ,dp[x][1] + dp[d][1] - 1);
		chkmax(Ans ,dp[x][2] + dp[d][1] - (x == 1));
		chkmax(Ans ,dp[x][2] + dp[d][2] - (x == 1));

		chkmax(dp[x][1] ,dp[d][1]);
		chkmax(dp[x][1] ,dp[d][2] + 1);
		
		chkmax(dp[x][3] ,dp[x][0] + dp[d][2] - 1);
		chkmax(dp[x][3] ,dp[x][0] + dp[d][1] - 1);
		chkmax(dp[x][3] ,dp[x][2] + dp[d][0] - 1);
		chkmax(dp[x][3] ,dp[d][3] + deg[x] - 1); // 把路径留下，链传上来
		chkmax(dp[x][3] ,dp[d][0] + deg[x] + res - 2);
		

		chkmax(dp[x][2] ,dp[x][0] + dp[d][0] - 1);
		
		chkmax(dp[x][0] ,dp[d][0] + deg[x] - 1);

		chkmax(dp[x][2] ,dp[x][0]);
		chkmax(dp[x][3] ,dp[x][2]);

		chkmax(res ,dp[d][1]);
		chkmax(res ,dp[d][2]);
	}
}

void solve(){
	init(n = read());
	if(type >= 2) read() ,read();
	if(type >= 1) read() ,read();
	for(int i = 2 ,u ,v ; i <= n ; ++i){
		deg[u = read()]++;
		deg[v = read()]++;
		addedge(u ,v);
		--deg[i];
	}
	dapai(1 ,0);
	printf("%d\n" ,Ans);

}

int main(){
	int T = read();
	type = read();
	while(T--) solve();
	return 0;
}
```



---

## 作者：wind_whisper (赞：3)

## $\text{Foreword}$
《小清新》树形 dp。  
其实本题没有**那么**（重读）恶心，但我一开始写完 $x=0$ 后眼瞎没有看到 $x=1,2$ 时也必然是**最优方案**（这种东西不黑体吗...）可以直接无视，还在苦苦的写强制选链的特殊情况，被狠狠的恶心到了。  
这个故事告诉我们，要**仔细审题**！  

感觉自己的做法还是挺舒服的，虽然核心转移看的有些长（也只有 40 行左右），但没有太多的分类讨论，和有些代码枚举儿子然后直接取十几行 $\max$ 相比感觉更加阳间。
## $\text{Solution}$
题意算比较简洁清晰了，再具体一些大概就是选出两条可重点不可重边的链，将树分割成尽可能多的连通块。    

（一开始我受 [希望](https://www.luogu.com.cn/problem/P5291) 那个题的影响，尝试了好一会用度数和点数简洁的表示出连通块数目来简化 dp，其实是在玩泥巴，直接做就很方便。）  

### $\text{Definition}$
设置状态 $f_{x,i,d}$ 表示 $x$ 节点子树内选择了 $i$ 条**已经确定**的链，**子树内** 的联通块最大数目。  
$d$ 的定义有些复杂：  
在 $x$ 作为父亲的时候，$d\in [0,4]$ 表示的是 $x$ **被删除**，与 $x$ 相连的儿子的个数，$d=5$ 表示 $x$ **不被删除**。  
在 $x$ 作为儿子的时候，$d\in [0,1]$ 表示 $x$ **被删除**，且与父亲相连/不相连。$d=5$ 表示 $x$ **不被删除**。
### $\text{Transfer}$
#### Part 1
$d=5$，$x$ 不删时：$x$ 必然不会和儿子相连，儿子要么删了但不和父亲连（$d=0$），要么根本不删 ($d=5$)，不删的时候由于父子都不删，两个联通块合并成一个，所以答案要减一。
$$f_{x,i,5}+f_{son,j,5}-1\to f_{x,i+j,5}$$
$$f_{x,i,5}+f_{son,j,0}\to f_{x,i+j,5}$$
$d\in[0,4]$ 时：$x$ 可以和儿子相连也可以不连，不连的时候儿子是否删除都可以，对应转移分别就是：
$$f_{x,i,d}+f_{son,j,1}\to f_{x,i+j,d+1}$$
$$f_{x,i,d}+f_{son,j,0}\to f_{x,i+j,d}$$
$$f_{x,i,d}+f_{son,j,5}\to f_{x,i+j,d}$$
这样 $x$ 从所有儿子得到的转移就全完事了，接下来我们需要把 $f_{x,i,d}$ 的 $d$ 的定义从“父亲形态”转化成“儿子形态”，以使它可以继续向父亲转移。
#### Part 2
$d=5$ 时：$x$ 没选就是没选，没什么好说的。
$$f_{x,i,5}\to f_{x,i,5}$$
$d=0$ 时：注意我们之前是**强制让 $x$ 被删除**的，所以我们不能直接让它转移到 $f_{x,i,0}$。为了删除它，要么使其单独一个点成链，要么让它成为链尾和父亲相连，对应就是：
$$f_{x,i,0}\to f_{x,i+1,0}$$
$$f_{x,i,0}\to f_{x,i,1}$$

$d=2/4$ 时：向 $x$ 连接的偶数条边必然两两成链：
$$f_{x,i,d}\to f_{x,i+d/2,0}$$
$d=1/3$ 时：单出来的一条可以把 $x$ 当成链头停止，也可以继续向父亲延伸：
$$f_{x,i,d}\to f_{x,i+d/2+1,0}$$
$$f_{x,i,d}\to f_{x,i+d/2,1}$$
#### Part 3
这样看起来就做完了？  
但是你一测发现过不去样例！  
仔细一看，是被两个点一条边的情况 $hack$ 了。  
一般的，当一个图长成深度为 1 的菊花的时候，我们都会出问题。
我们缺少了在一个点连续摆烂的情况。  
这个东西有两种解决方案：  
第一种是**当 $x$ 被删除**的时候，可以原地多选几条链，即：
$$f_{x,i,0}\to f_{x,i+1,0}$$
$$f_{x,i,1}\to f_{x,i+1,1}$$
第二种是求出度数最大点的度数，让答案和这个度数取个 $\max$。  
第二种虽然看起来更加简单，跑起来也稍微快一点，但如果在考场上，本人还是建议第一种，毕竟多说多错，直接给一个合法转移，让 `std::max` 做决策而不是自己归纳贪心，肯定更加稳妥。  
如果是做练习当然就精益求精啦。
## $\text{Code}$
代码就简单了，把上面的转移敲出来即可。  
（滚动数组无脑好用，不会互相转移出 bug，强推）
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define ok debug("OK\n")
using namespace std;

const int N=1e5+100;
const int M=2e5+100;
const int inf=1e9;

inline ll read(){
    ll x(0),f(1);char c=getchar();
    while(!isdigit(c)) {if(c=='-')f=-1;c=getchar();}
    while(isdigit(c)) {x=(x<<1)+(x<<3)+c-'0';c=getchar();}
    return x*f;
}

int n;
int f[N][3][6];
int tmp[2][3][6],now,pre;
vector<int>v[N];
inline void Max(int &x,int y){
    y>x?x=y:0;return;
}
void dfs(int x,int fa){
    for(int to:v[x]){
        if(to==fa||vis[to]) continue;
        dfs(to,x);
    }
    now=1;pre=0;
    memset(tmp,-0x3f,sizeof(tmp));
    tmp[now][0][5]=1;tmp[now][0][0]=0;
    for(int s:v[x]){
        if(s==fa||vis[s]) continue;
        swap(now,pre);
        memset(tmp[now],-0x3f,sizeof(tmp[now]));
        for(int i=0;i<=2;i++){
            for(int j=0;i+j<=2;j++){
                Max(tmp[now][i+j][5],tmp[pre][i][5]+f[s][j][5]-1);
                Max(tmp[now][i+j][5],tmp[pre][i][5]+f[s][j][0]);
                for(int d=0;d<=4;d++){
                    Max(tmp[now][i+j][d],tmp[pre][i][d]+f[s][j][0]);
                    Max(tmp[now][i+j][d],tmp[pre][i][d]+f[s][j][5]);
                    if(d+1<=4)Max(tmp[now][i+j][d+1],tmp[pre][i][d]+f[s][j][1]);
                }
            }   
        }
    }
    memset(f[x],-0x3f,sizeof(f[x]));
    for(int i=0;i<=2;i++){
        Max(f[x][i][5],tmp[now][i][5]);
        if(i+1<=2) Max(f[x][i+1][0],tmp[now][i][0]);
        Max(f[x][i][1],tmp[now][i][0]);
        for(int j=1;j<=4;j++){
            if(j&1){
                if(i+j/2<=2) Max(f[x][i+j/2][1],tmp[now][i][j]);
                if(i+(j+1)/2<=2) Max(f[x][i+(j+1)/2][0],tmp[now][i][j]);
            }
            else if(i+j/2<=2) Max(f[x][i+j/2][0],tmp[now][i][j]);
        }
    }
    for(int i=1;i<=2;i++){
        Max(f[x][i][0],f[x][i-1][0]);
        Max(f[x][i][1],f[x][i-1][1]);
    }
    return;
}
void work0(){
    for(int i=1;i<n;i++){
        int x=read(),y=read();
        v[x].push_back(y);v[y].push_back(x);
    }
    dfs(1,0);
    printf("%d\n",max(f[1][2][0],f[1][2][5]));
    return;
}
signed main(){
#ifndef ONLINE_JUDGE
    freopen("a.in","r",stdin);
    freopen("a.out","w",stdout);
#endif
    int T=read(),op=read();
    while(T--){
        n=read();
        for(int i=1;i<=op;i++) read(),read();
        work0();
        for(int i=1;i<=n;i++) v[i].clear();
    }
    return 0;
}
/*
*/

```



---

## 作者：Nightingale_OI (赞：1)

## P3748 [六省联考 2017] 摧毁“树状图”

### 大意

认真读题发现钦定的路径一定是最优答案，所以不用对 $x=0/1/2$ 分类讨论。

给定一棵树，选出两条边不交的路径（每条路径至少包含一个点），将这两条路径包含的点都删掉之后剩下连通块最多是多少。

### 思路

记 $d_x$ 表示点 $x$ 的度数，$a_x=d_x-2$。

先看看对于一条路径经过的点集 $S$，分成的连通块数为：

$$\sum_{x\in S}d_x - 2(|S|-1)=\sum_{x\in S}a_x+2$$

---

若选出的两条路径有公共点，其形态一定是从某个点出发延伸出去的 $0\sim 4$ 条链，同样可以推出连通块数为 $\sum a_x+2$，换根求权值前 $4$ 大的链即可。

若选出的两条路径无公共点，一定存在一条边分开它们，枚举这条边 $(u,v)$。

如果 $u$ 和 $v$ 都在选择的路径中，则连通块数为 $\sum a_x+2$，否则为 $\sum a_x +3$。

按照上面的推导，应该是 $\sum a_x+4$，但是它们分出的连通块会通过 $(u,v)$ 这条边相连，是一个连通块，所以是 $\sum a_x + 3$，当 $u$ 和 $v$ 都被选时，多算了 $\{u\}$ 和 $\{v\}$ 两个连通块，但它们被删了，所以是 $\sum a_x + 2$。

记 $f_{u,v,0/1}$ 表示在断掉 $(u,v)$ 这条边后 $u$ 所在连通块选出一条路径的 $\sum a_x$ 最大值，$0/1$ 表示是否经过 $u$，同样换根求。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define f(i,j,k) for(int i=j;i<=k;++i)
#define g(i,j,k) for(int i=j;i>=k;--i)
int n,m,s,l;
const int N=101010,inf=1e9+7;
vector<int>q[N];
int a[N],f[N][3],g[N][4],h[N][4];
inline void ud(int*a,int w){
	f(i,0,3)if(w>a[i]){
		g(j,3,i+1)a[j]=a[j-1];
		a[i]=w;break;
	}
}
void dhs(int x,int fa){
	int v0,v1,w;v0=v1=-inf;
	f(t,0,3)h[x][t]=0;
	for(int y:q[x])if(y!=fa){
		dhs(y,x);
		ud(h[x],h[y][0]+a[y]);
		w=max(f[y][0],f[y][1]);
		if(w>v0)v1=v0,v0=w;
		else if(w>v1)v1=w;
	}
	f[x][0]=v0;
	f[x][1]=h[x][0]+h[x][1]+a[x];
	f[x][2]=v1;
}
void dfs(int x,int fa,int up,int u0,int u1){
	int *p=g[x],z,u[2],v,v0,v1,w;u[0]=u0;u[1]=u1;
	f(t,0,3)p[t]=h[x][t];ud(p,up);
	s=max(s,p[0]+p[1]+p[2]+p[3]+a[x]+2);
	f(p,0,1)f(q,0,1)s=max(s,u[p]+f[x][q]+3-(p&&q));
	for(int y:q[x])if(y!=fa){
		z=p[0]==(v=h[y][0]+a[y]);w=max(f[y][0],f[y][1]);
		v0=max({f[x][w==f[x][0]?2:0],u0,u1});
		v1=(v==p[0]?p[1]+p[2]:v==p[1]?p[0]+p[2]:p[0]+p[1])+a[x];
		dfs(y,x,p[z]+a[x],v0,v1);
	}
}
inline void doing(){
	scanf("%lld",&n);
	f(i,1,m*2)scanf("%lld",&s);
	f(i,1,n)q[i].clear();
	f(i,2,n){
		scanf("%lld %lld",&s,&l);
		q[s].push_back(l);
		q[l].push_back(s); 
	}
	f(i,1,n)a[i]=((int)q[i].size())-2;
	s=l=0;
	if(n<2)return printf("0\n"),void();
	dhs(1,0);dfs(1,0,0,-inf,-inf);
	printf("%lld\n",s);
}
signed main(){
	int t;
	cin>>t>>m;
	while(t--)doing();
	return 0; 
} 
```

---

## 作者：SegTree (赞：1)

给这题整了一个无脑但是多只 $\log$ 的做法，喜提最劣解。

前置题目：CF2050G。

首先观察一下两个人的路径是怎么选的。要么它们没有公共点，要么有公共点。

## Case 1 没有公共点
如果没有公共点，必然存在一条边把这两条路径分离开，不妨枚举这个边是什么。

注意到，如果两条路径距离为 $1$ 会出现算重的情况，所以我们这里先枚举两条路径距离 $>1$ 的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/825op0wg.png)

下面的直径定义为 $2+\sum_{x\in path(u,v)}deg_x$。

其中，红色边是我们枚举的边，那么可以贡献成为第一条路径的直径的分成了如图的四个红框区域，也就是父亲的除去它以外的每颗子树和父亲方向的子树；而第二条路径就比较显然，就是以 $8$ 为根的这颗子树。

当然，$=1$ 相当于没有限制，只需要算出子树外的直径就可以了。

求出直径在一颗子树内很好做到，但是抠掉一颗子树的直径需要维护的东西很多，比较麻烦。

有一个更为简单的做法，就是求 dfn 序下的前后缀直径。（因为两个点集的直径是可合并的，可以根据两个点集的直径算出合并形成的点集的直径。）

## Case2 有公共点

这种情况稍微简单一些，相当于求最长的 $4$ 条链，相当于每次换根维护每个点到 $rt$ 的路径权值，每次把根 $u$ 换成儿子 $x$ 相当于做子树以内 $-w_u$，子树以外 $+w_x$，可以用线段树维护区间加区间 $\max$。

做完了，复杂度 $O(n\log n)$。

---


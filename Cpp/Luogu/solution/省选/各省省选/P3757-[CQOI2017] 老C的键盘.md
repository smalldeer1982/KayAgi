# [CQOI2017] 老C的键盘

## 题目描述

老 C 是个程序员。

作为一个优秀的程序员，老 C 拥有一个别具一格的键盘，据说这样可以大幅提升写程序的速度，还能让写出来的程序在某种神奇力量的驱使之下跑得非常快。

小 Q 也是一个程序员。有一天他悄悄潜入了老 C 的家中，想要看看这个键盘究竟有何妙处。他发现，这个键盘共有 $n$ 个按键，这 $n$ 个按键虽然整齐的排成一列，但是每个键的高度却互不相同。聪明的小 Q 马上将每个键的高度用 $1 \sim n$ 的整数表示了出来，得到一个 $1 \sim n$ 的排列 $h_1,h_2, \cdots ,h_n$。

为了回去之后可以仿造一个新键盘（新键盘每个键的高度也是一个 $1 \sim n$ 的排列），又不要和老 C 的键盘完全一样，小 Q 决定记录下若干对按键的高度关系。作为一个程序员，小 Q 当然不会随便选几对就记下来，而是选了非常有规律的一些按键对：对于 $i=2,3, \cdots ,n$，小 Q 都记录下了一个字符 `<` 或者 `>`，表示 $h_{\frac i2}<h_i$ 或者$h_{\frac i2}>h_i$。于是，小 Q 得到了一个长度为 $n-1$ 的字符串，开开心心的回家了。

现在，小 Q 想知道满足他所记录的高度关系的键盘有多少个。虽然小 Q 不希望自己的键盘和老 C 的完全相同，但是完全相同也算一个满足要求的键盘。答案可能很大，你只需要告诉小 Q 答案 $\bmod ~ 1,000,000,007$ 之后的结果即可。


## 说明/提示



![](https://cdn.luogu.com.cn/upload/pic/5095.png)


## 样例 #1

### 输入

```
5 <>><```

### 输出

```
3```

## 样例 #2

### 输入

```
5 <<<<```

### 输出

```
8```

## 样例 #3

### 输入

```
5 <<>>```

### 输出

```
18```

# 题解

## 作者：shadowice1984 (赞：12)

哇塞！我可以说这是双倍经验吗？

和**P4099HEOI2014SAO**是重题，而且弱化了!!!

我也是不想说啥了……明明有O(n^2)的复杂度啊……

我可以贴一发我的题解链接嘛……

https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p4099

那么我们发现对比HEOI2014来讲，这道题唯一的问题是，没有树QAQ

但是如果你对二叉树的表示相当熟练的话，我们会发现，其实线段树什么的啊，二叉堆什么的啊，都是用2\*i，2\*i+1来表示父子关系的i/2就是i的父亲，所以树什么的是可以建出来的，还是一只完全二叉树，

如果我们把它的拓扑序排名作为全排列里的位置，那么一个拓扑序一一对应一个全排列

所以是给定二叉树型图，求所有合法拓扑序方案，还只要求O(N^3)算法！

还有就是这道题连小于大于号都给你了……，你甚至不必改HEOI那道题的代码

当然我就只写O(N^3)的代码咯~，毕竟前缀和啥的还得再维护，多麻烦，出题人不为难你就不写了啊，写O(N^2)的去交4099

但是还有一个至关重要的麻烦，转移方程里，要求4个1e9乘一起，显然爆longlong……
所以分开乘，膜3遍即可

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;
typedef unsigned long long ll;
ll mod=1e9+7;const int N=110;
ll dp[N][N];ll c[N][N];
ll siz[N];int n;ll res;
char mde[N];
inline void dfs(int x)
{
	for(int v=2*x;v<=min(n,2*x+1);v++)
	{
		dfs(v);
		if(mde[v]=='>')//O(N^3)因为我懒得打前缀和
		{
			for(int k=siz[x]+siz[v];k>=1;k--)//枚举排名
			{
				ll sum=0;
				for(int i=1;i<=min(siz[x],(ll)k);i++)//保证合法性的区间
				{
					for(int j=k-i+1;j<=siz[v];j++)//保证合法性
					{
						ll a=(dp[x][i]*dp[v][j])%mod;ll b=(c[i-1][k-1]*c[siz[x]-i][siz[x]+siz[v]-k])%mod;
						a=(a*b)%mod;sum=(sum+a)%mod;//两个序列的可能取值情况*x前序列组合*x后序列组合
					}
				}
				dp[x][k]=sum;
			}
		}
		else//同上,只是枚举区间变了,转移方程是一样的
		{
			for(int k=siz[x]+siz[v];k>=1;k--)
			{
				ll sum=0;
				for(int i=1;i<=min(siz[x],(ll)k);i++)
				{
					for(int j=1;j<=min((ll)k-i,siz[v]);j++)
					{
						ll a=(dp[x][i]*dp[v][j])%mod;ll b=(c[i-1][k-1]*c[siz[x]-i][siz[x]+siz[v]-k])%mod;
						a=(a*b)%mod;sum=(sum+a)%mod;
					}
				}
				dp[x][k]=sum;
			}
		}
		siz[x]+=siz[v];//别忘了siz
	}
}
int main()
{
	scanf("%d",&n);
	c[0][0]=1;//打表组合数备用
	for(int i=1;i<=n;i++)
	{
		c[0][i]=1;c[i][i]=1;
		for(int j=1;j<i;j++){c[j][i]=(c[j][i-1]+c[j-1][i-1])%mod;}
	}
	scanf("%s",mde+2);//注意从2开始
	for(int i=1;i<=n;i++){dp[i][1]=1;siz[i]=1;}//初始化
	dfs(1);
	for(int i=1;i<=n;i++){res=(res+dp[1][i])%mod;}
	printf("%lld",res);return 0;//拜拜程序~
}
```



---

## 作者：wrpwrp (赞：9)

发现题目给的很像一棵树。。。

就把这棵树建出来。

发现如果把大于小于号分别看成一条有向边， 发现这个题目就是求这个图有多少个拓扑序。对于每一个拓扑序， 直接$$12345$$这样标号就可以得到满足题目要求的序列。

考虑树$dp$, 设$f(i, j)$为$i$这个点在这个子树所形成的拓扑序列中在第$j$位的方案数。

转移的时候实际上就是合并两个序列。

用$x$表示当前点,$y$表示儿子。

+ 当$x > y$时，

  $f(x,k) = \sum C(k - 1, i - 1) \times C(sz[x]+sz[y] -k, sz[x] -i) * f(x, i) * f(y, j)$

  这里的$k$从$i + j$枚举到$i + sz[y]$。

  意思就是， 注意到我们定义的状态是只关心其他的点和当前点的相对大小的， 所以就可以这样算。

  相当于前$k - 1$个位置里面有$i - 1$个在$x$原本所属于的数列里面， 剩下的是$y$里面的。

  然后后$sz[x] + sz[y] - k$个位置里面有$sz[x] - i$个是原本属于$x$那个数列的， 剩下的是$y$里面的。

  由于我们只关心相对大小以及每个数是来自于哪一个数列， 所以这里只要乘上组合数就可以了。

+ 当$x < y$时

  转移一样的， $k$从$i$到$i + j - 1$。

```cpp
#include <cmath>
#include <cstdio>
#include <vector>
#include <cstring>
#include <algorithm>
#include <iostream>

using namespace std;

#define R register
const int N = 100 + 5;
const int P = 1e9 + 7;

inline int read() {
	int x = 0, f = 1; char a = getchar();
	for(; a >= '0' && a <= '9'; a = getchar()) x = x * 10 + a - '0';
	return x * f;
}

int C[N][N]	;
inline void init() {
	for(R int i = 0; i < N; i ++) {
		C[i][0] = 1;
		for(R int j = 1; j <= i; j ++) 
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P;
	}
}

int dp[N][N];
int g[N][N];

int n;
char s[N];
int sz[N];

inline void dfs(int x) {
	sz[x] = 1; dp[x][1] = 1;
	for(R int p = 0; p <= 1; p ++) {
		int y = x * 2 + p;
		if(y > n) break;
		dfs(y); 
		for(R int i = 1; i <= sz[x]; i ++) g[x][i] = dp[x][i]; 
		memset(dp[x], 0, sizeof(dp[x]));
		for(R int i = sz[x]; i >= 1; i --) 
			for(R int j = sz[y]; j >= 1; j --) {
				if(s[y] == '>') {
					for(R int k = i + sz[y]; k >= i + j; k --) 
						dp[x][k] = 
					(dp[x][k] + 1LL * C[k - 1][i - 1] * C[sz[x] + sz[y] - k][sz[x] - i] % P * g[x][i] % P * dp[y][j] % P) % P;
				}
				else {
					for(R int k = i + j - 1; k >= i; k --)
						dp[x][k] = 
					(dp[x][k] + 1LL * C[k - 1][i - 1] * C[sz[x] + sz[y] - k][sz[x] - i] % P * g[x][i] % P * dp[y][j] % P) % P;
				}
			}
		sz[x] += sz[y];
	}
}

int main() {
	#ifdef IN
	freopen("a.in", "r", stdin);
	//freopen(".out", "w", stdout);
	#endif
	init();
	n = read(); scanf("%s", s + 2);
	dfs(1);
	int ans = 0;
	for(R int i = 1; i <= n; i ++) ans = (ans + dp[1][i]) % P;
	printf("%d\n", ans);
	return 0;
}
```



---

## 作者：litble (赞：5)

用f[x][i]表示第x个节点在当前子树的排列里排在第i个 的解数。

那么从当前子树节点中弄k个出来放在根节点前面，其他子树中弄j-1个出来， 则根节点排在k+j个。

然后，如果不看此子树，则根节点排在第 j个，就是f[x][j]种。如果只看子树，子树根节点的排列是一个连续区间用前缀和做

合并的排列则是：对于根节点前面的，选出j-1个作为非此子树弄出来的

对于后面的，选出sum[x]-j个作为非此子树中弄出来的

它们的顺序是没有关系的，所以用组合数即可

```cpp
#include<iostream>
#include<cstdio>
#include<climits>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
#define ll long long
ll mod=1000000007;
int n,tot;
char ss[105];
ll f[105][105],g[105][105],tmp[105],c[105][105];
int h[105],to[105],ne[105],sum[105];
void add(int x,int y){tot++;to[tot]=y;ne[tot]=h[x];h[x]=tot;}
void dfs(int x){
    int l=x<<1,r=l|1;
    if(l<=n)add(x,l);
    if(r<=n)add(x,r);
    int i,j,k;
    g[x][1]=f[x][1]=sum[x]=1;
    for(i=h[x];i;i=ne[i]){
        dfs(to[i]);
        for(j=1;j<=sum[x]+sum[to[i]];j++)tmp[j]=0;//临时数组
        for(j=1;j<=sum[x];j++)
            for(k=0;k<=sum[to[i]];k++){
            if(ss[to[i]]=='>')
            tmp[j+k]+=f[x][j]*g[to[i]][k]%mod
            *c[j+k-1][j-1]%mod*c[sum[x]+sum[to[i]]-j-k][sum[x]-j]%mod;
            else tmp[j+k]+=f[x][j]*(g[to[i]][sum[to[i]]]-g[to[i]][k]+mod)%mod
            *c[j+k-1][j-1]%mod*c[sum[x]+sum[to[i]]-j-k][sum[x]-j]%mod;
        }
        sum[x]+=sum[to[i]];
        for(j=1;j<=sum[x];j++)//前缀和
        f[x][j]=tmp[j]%mod,g[x][j]=(g[x][j-1]+f[x][j])%mod;
    }
}
int main()
{
    int i,j,x=0,bj=2;
    scanf("%d%s",&n,ss+2);
    c[0][0]=1;
    for(i=1;i<=n;i++){//组合数
        c[i][0]=1;
        for(j=1;j<=i;j++)
            c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
    }
    dfs(1);printf("%lld",g[1][sum[1]]);
    return 0;
}
```

---

## 作者：FutureSnow (赞：3)

本题是[P4099](https://www.luogu.com.cn/problem/P4099)的加弱版（这题需要 $O(n^2)$，而本题 $O(n^3)$ 就能过，本题解会提到 $O(n^2)$ 做法，双倍经验请自行领取）。

按照题目给出的大于号和小于号连有向边，不难发现如果把有向边改成无向边，则建出的图是一棵树（本题是完全二叉树，参考线段树的建法），题目要求的就是这个树形结构上不同拓扑序的数量。

考虑 $\texttt{DP}$。设 $f_{a,k}$ 表示结点 $a$ 在其子树中的拓扑序排在第 $k$ 位的方案数。不难想到可以自叶子节点向上合并。考虑将子树 $y$ 并入子树 $x$ 的转移。由于 我们固定了 $x$ 这一个结点在拓扑序中的位置，所以我们可以计算 $x$ 之前和之后元素的组合数。枚举 $x$ 子树中有 $i$ 个结点在 $x$ 或 $x$ 之前（注意这里包含 $x$），$y$ 子树中有 $j$ 个在 $x$ 之前（注意这里不包含 $x$），则可以计算对 $f_{x, i + j}$ 的贡献：
$$\sum_k{\binom{i + j - 1}{j}\binom{s_x + s_y - i - j}{s_y - j}} f_{y,k} f_{x,i}$$
+ 如果是结点 $x$ 连向结点 $y$，则 $k$ 取值范围为 $1 \le k \le j$。
+ 如果是结点 $y$ 连向结点 $x$，则 $k$ 取值范围为 $j + 1 \le k \le s_y$。

其中 $s_a$ 表示子树 $a$ 的大小。这样计算的时间复杂度是 $O(n^3)$，可以通过本题。

观察到无论边的方向是什么，$k$ 的取值范围都是一段连续的区间，于是我们可以预先计算前缀和，减少一维时间复杂度，最终时间复杂度为 $O(n^2)$。

一些细节看代码注释。
```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;
const int mod = 1e9 + 7;
int n, ans, f[110][110], sz[110], c[110][110], g[110] /*g[]是临时存储贡献的数组，防止原状态被覆盖*/ , sum[110];
char ch[110];
struct edge{
	int next, to, w; // w 表示箭头方向，由于转移需要，不能只建单向边 
}e[210];
int ne, head[1010];

inline void AE(int from, int to, int w){
	e[++ne] = (edge){head[from], to, w};
	head[from] = ne;
}

void dfs(int x, int fa){
	f[x][1] = 1; sz[x] = 1;
	for(int p = head[x]; p; p = e[p].next){
		int y = e[p].to, w = e[p].w;
		if(y == fa) continue;
		dfs(y, x);
		int num = sz[x] + sz[y];
		for(int i = 1; i <= sz[y]; i++) sum[i] = (sum[i - 1] + f[y][i]) % mod; //这里计算前缀和 
		for(int i = 1; i <= num; i++) g[i] = 0;
		for(int i = 1; i <= sz[x]; i++){
			for(int j = 0; j <= sz[y]; j++){ //不同方向边的转移 
				if(!w) g[i + j] = (g[i + j] + c[i + j - 1][j] * c[num - i - j][sz[y] - j] % mod * sum[j] /*用前缀和代替原数组求和，下同*/ % mod * f[x][i] % mod) % mod;
				else g[i + j] = (g[i + j] + c[i + j - 1][j] * c[num - i - j][sz[y] - j] % mod * (sum[sz[y]] - sum[j]) % mod * f[x][i] % mod) % mod;
			}
		}
		for(int i = 1; i <= num; i++) f[x][i] = g[i];
		sz[x] += sz[y];
	}
}

inline void comb(){
	for(int i = 0; i <= 105; i++){
		c[i][0] = 1;
		for(int j = 1; j <= i; j++) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;
	}
}

signed main (){
	cin >> n >> ch + 2;
	for(int i = 2; i <= n; i++){
		int w = (ch[i] == '>' ? 0 : 1);
		AE(i / 2, i, w);
		AE(i, i / 2, w ^ 1);
	}
	comb();
	dfs(1, 0); 
	for(int i = 1; i <= n; i++) ans = (ans + f[1][i]) % mod;
	cout << (ans + mod) % mod << endl; //答案可能在模 mod 意义下是负数 
	return 0;
}
```


---

## 作者：Xy_top (赞：2)

题解区没有人讲清状态转移方程.jpg

题目中给的关系很像一棵树，考虑建出这个完全二叉树，看到数据范围于是考虑 ``DP``。

显然，设 $f_{u,k,0/1/2}$ 表示以 $u$ 为根的子树中，[没有考虑任何子树/考虑了左子树/都考虑了]，$u$ 排名为 $k$ 的方案数，显然有 $f_{u, 1, 0} = 1$。

接下来考虑如何转移左子树，设左子树为 $v$。

枚举一个 $i$ 表示 $u$ 在已计算答案部分的排名，枚举一个 $j$ 表示 $v$ 在其子树内的排名。对于 $h_u < h_v$ 的情况，则 $u$ 在 $v$ 子树中不可能排到第 $j$ 名以及第 $j$ 名后面（因为第 $j$ 名是 $v$，$h_u < h_v$）。

再枚举一个 $k$ 表示将 $v$ 计入答案后 $u$ 的排名。如果 $u$ 的值小于 $v$ 子树中所有节点的值，那么 $k=i$，另一个极端情况是：在 $v$ 子树中比 $v$ 小的 $j-1$ 个节点的权值全部比 $u$ 的权值小。此时 $k$ 的值为 $i+j-1$。

枚举完 $i,j,k$ 后，我们就知道 $u$ 子树内（不算 $v$）有 $i-1$ 个比 $u$ 小，$v$ 子树内有 $k - i$ 个，下面来讨论这些节点的方案数。我们发现，$u$ 中 $i-1$ 个节点各自的顺序和 $v$ 中 $k-i$ 个节点各自的顺序其实已经确定好了，就是它们之间的顺序没有确定好。如果我们从合并后前的 $k-1$ 空位中选 $i-1$ 个给 $u$ 子树中比 $u$ 小的那些，那么我们发现剩下 $k-i$ 个空位是留给 $v$ 子树中的，它们的顺序已经确定好了，直接按顺序填入即可，所以前 $k - 1$ 个安排的方案数就是 $C_{k-1}^{i-1}$。

那么在 $i$ 后面的那些节点安排的方案数也同理，方案数为 $C _ {sz_u + sz_v - k} ^ {sz_u - i}$，其中 $sz_u-i$ 是 $u$ 子树中（不算 $v$）比 $u$ 小的节点数量。

故转移方程为 $f_{u,k,1} +  C _ {k-1} ^ {i-1} \times C _ {sz_u + sz_v - k} ^ {sz_u-i} \times f_{u, i, 1}\times f_{v,j,2} \to f_{u,k,1}$。

$h_u>h_v$ 时同理，只不过 $k$ 的循环范围变为了 $[i+j,i+sz_v]$。

另一个子树也同理。

talk is cheap, show me the code:


```cpp
#include <bits/stdc++.h>
#define int long long
#define For(i, a, b) for (int i = (a); i <= (b); i ++)
#define foR(i, a, b) for (int i = (a); i >= (b); i --)
using namespace std;
int n;
int f[101][101][3];
int sz[101], fac[201], inv[201];
char s[101];
const int mod = 1000000007;
int q_pow (int x, int y) {
	if (y == 0) return 1;
	if (y & 1) return x * q_pow (x * x % mod, y >> 1) % mod;
	return q_pow (x * x % mod, y >> 1);
}
int C (int n, int m) {return fac[n] * inv[m] % mod * inv[n - m] % mod;}
void dfs (int u) {
	sz[u] = 1;
	f[u][1][0] = 1;
	if (2 * u > n) {
		f[u][1][2] = 1;
		return;
	}
	dfs (2 * u);
	if (s[2 * u] == '<') {
		int v = 2 * u;
		For (i, 1, sz[u]) For (j, 1, sz[2 * u]) For (k, i, i + j - 1)
			f[u][k][1] = (f[u][k][1] + C (k - 1, i - 1) * C (sz[u] + sz[v] - k, sz[u] - i) % mod * f[u][i][0] % mod * f[v][j][2] % mod) % mod;
	} else {
		int v = 2 * u;
		For (i, 1, sz[u]) For (j, 1, sz[2 * u]) For (k, i + j, i + sz[v])
			f[u][k][1] = (f[u][k][1] + C (k - 1, i - 1) * C (sz[u] + sz[v] - k, sz[u] - i) % mod * f[u][i][0] % mod * f[v][j][2] % mod) % mod;
	}
	sz[u] += sz[2 * u];
	if (2 * u + 1 > n) {
		For (i, 0, 100) f[u][i][2] = f[u][i][1];
		return;
	}
	dfs (2 * u + 1);
	if (s[2 * u + 1] == '<') {
		int v = 2 * u + 1;
		For (i, 1, sz[u]) For (j, 1, sz[v]) For (k, i, i + j - 1)
			f[u][k][2] = (f[u][k][2] + C (k - 1, i - 1) * C (sz[u] + sz[v] - k, sz[u] - i) % mod * f[u][i][1] % mod * f[v][j][2] % mod) % mod;
	} else {
		int v = 2 * u + 1;
		For (i, 1, sz[u]) For (j, 1, sz[v]) For (k, i + j, i + sz[v])
			f[u][k][2] = (f[u][k][2] + C (k - 1, i - 1) * C (sz[u] + sz[v] - k, sz[u] - i) % mod * f[u][i][1] % mod * f[v][j][2] % mod) % mod;
	}
	sz[u] += sz[2 * u + 1];
}
void init () {
	fac[0] = 1;
	For (i, 1, 200) fac[i] = fac[i - 1] * i % mod;
	inv[200] = q_pow (fac[200], mod - 2);
	foR (i, 199, 0) inv[i] = inv[i + 1] * (i + 1) % mod;
}
void solve () {
	init ();
	scanf ("%d%s", &n, s + 2);
	dfs (1);
	int ans = 0;
	For (i, 1, n) ans = (ans + f[1][i][2]) % mod;
	cout << ans;
}
signed main () {
	int _ = 1;
//	cin >> _;
	while (_ --) {
		solve ();
		cout << '\n';
	}
	return 0;
}

```

---

## 作者：liuchuliang666 (赞：0)

[P4099](https://www.luogu.com.cn/problem/P4099) 的弱化版，之前做过，特来复习一下。

注意到题目中的大小关系按照编号形成了一棵完全二叉树，不过其实是不是完全二叉的其实不重要，重要的是它是棵树。

那么显然这是个计数类树形 DP，我们可以很自然的设出状态 $f_{u, i}$ 表示当 $h_u = i$ 且 $\text{subtree}(u)$ 已确定答案时的方案数。

然后你就傻了，因为你需要整个子树的信息。

但是我们注意到有关 $h_u$ 的限制只是跟它两个儿子的大小关系，这就有一个重要的启发：我们并不关心当前的具体值，而是它和儿子的大小关系，更进一步的，我们真正关心的是**排名**！

因此我们可以设 $f_{u, i}$ 表示在 $\text{subtree}(u)$ 中，当 $h_u$ 的排名为 $i$ 时，合法序列的数量，那么初始在未合并子树时，应有 $f_{u, 1} = 1$，其余为 $0$。

记 $v \in \text{son}(u)$，考虑将 $v$ 的信息合并到 $u$ 中。我们枚举 $i$ 和 $j$ 分别为已合并（下同）的 $\text{subtree}(u)$ 和 $\text{subtree}(v)$ 中排名在 $u$ 前面（再加上 $u$ 自身）的个数。那么在前 $i + j - 1$ 个位置中，来自 $\text{subtree}(v)$ 的 $j$ 个数字可任选位置，有 $\binom{i + j - 1}{j}$ 种选法，后 $\text{size}(u) + \text{size}(v) - i - j$ 个位置中同理，为 $\binom{\text{size}(u) + \text{size}(v) - i - j}{\text{size}(v) -j}$，那么枚举 $k$ 为 $v$ 在 $\text{subtree}(v)$ 中的排名，那么对 $f_{u, i + j}$ 的贡献只需再乘上 $f_{u, i}$ 和 $f_{v, k}$ 即可。

这个时间复杂度是 $O(n ^ 3)$ 的，足以通过此题，不过注意到我们完全没有必要枚举 $k$，因为 $k$ 必定是一段连续区间，那么我们对 $f_v$ 求个前缀和就能轻松优化至 $O(n ^ 2)$ 了。

代码就不放了，其它题解写得都挺直白的。

---


# [FJOI2017] 矩阵填数

## 题目描述

给定一个 $h \times w$ 的矩阵，矩阵的行编号从上到下依次为 $1 \sim h$，列编号从左到右依次 $1 \sim w$。

在这个矩阵中你需要在每个格子中填入 $1 \sim m$ 中的某个数。

给这个矩阵填数的时候有一些限制，给定 $n$ 个该矩阵的子矩阵，以及该子矩阵的最大值 $v$，要求你所填的方案满足该子矩阵的最大值为 $v$。

现在，你的任务是求出有多少种填数的方案满足 $n$ 个限制。

两种方案是不一样的当且仅当两个方案至少存在一个格子上有不同的数。由于答案可能很大，你只需要输出答案对 $10 ^ 9 + 7$ 取模后的结果。

## 说明/提示

对于 $20\%$ 的数据，$n \le 2$。

另有 $20\%$ 的数据，$1 \le h, w \le 50$。

对于 $100\%$ 的数据，$T \le 5$，$1 \le h, w, m \le 10 ^ 4$，$1 \le n \le 10$，$1 \le v \le m$。

## 样例 #1

### 输入

```
2
3 3 2 2
1 1 2 2 2
2 2 3 3 1
4 4 4 4
1 1 2 3 3
2 3 4 4 2
2 1 4 3 2
1 2 3 4 4```

### 输出

```
28
76475```

# 题解

## 作者：shadowice1984 (赞：18)

表示正解为什么是$O(4^{n})$啊……

明明可以做到$O(3^n)$啊……

感觉那个dp做法十分奇怪……同时凭借$O(2^{n})$的空间复杂度拿了rk1？

# 容斥原理

看到计数想容斥……基本来讲这种玄学的计数题就是容斥定理没跑了……

首先我们发现矩阵中一个点肯定有一个取值范围

范围是$[1,min(min(v_{i}),m)]$其中i是覆盖了这个点的矩阵，因为呢，如果这个点的取值大过了v的最小值，对应子矩阵的限制就不满足了

然后值域相同的点会连成一些奇形怪状的图案(当然，不一定全部相连)

我们仔细观察这个图形，**发现值域不同的点之间的取值无关。**

这个是什么意思呢？

如果两个点a,b值域不同的话，a取到值域的max，所满足的子矩阵(们)，和b取到值域的max所满足的子矩阵(们)肯定不同，没有什么既然a取了max那么b就可以随便取了这个说法。

所以a取什么值和b取什么值根本没有任何关系~

那么既然是独立事件就可以使用乘法原理~

因此分别求出每个值域的方案数，最后乘起来就是答案了！

### 求某一个值域的方案数

(我知道胡乱设一堆变量十分难理解，但是的确不是很好说)

那么我们会发现呢，可能有多个矩阵的值域相同，那么设值域最大值为k的**点**构成一个集合$S_{k}$，里面的点可以满足的子矩阵暂且记为1，2，3……号矩阵

那么我们可以先让所有的点随便取，那么总方案数就是$k^{|S_{k}|}$

然后我们发现明显多算了

所以减去1号子矩阵取不到max的情况，记$S_{k}$中属于i号矩阵的点构成了集合$T_{k,i}$那么总方案数为$(k-1)^{|T_{k,1}|}k^{|S_{k}|-|T_{k,1}|}$，就是属于一号矩阵的点不可以取max，其他的点随便取

然后减去2号子矩阵取不到max的情况，3号子矩阵取不到max的情况，等等……

发现1，2号子矩阵同时取不到max的情况被多减了，所以减去1，2同时取不到max的情况，2，3同时取不到max的情况，1，3同时取不到max的情况……等等

发现此时1，2，3号子矩阵同时取不到max的情况被多加了，所以减去1，2，3同时取不到max的情况，……等等……

然后这样就可以大力容斥出每一个值域的方案数了

大概就是枚举v值相同的矩阵集合的子集，然后加加减减什么的

问题来了，上面要求我们要求出S集合和T集合的siz……

其实就是可以理解成v值相同子矩阵矩阵的并集∪所有值小于当前v的子矩阵并集-所有值小于v的矩阵的并集

T集合的话差不多，就是把上面的“所有”改成子集就可以了，然后就可以求出这个集合的siz了。

问题是如何求出所有并集的siz？

显然所有并集的siz是可以容斥原理暴力做的，直接枚举子集就好……然后$O(3^{n})$暴力的枚举子集大力容斥就可以了

所以当然非常快了……就酱

上代码~

```C

// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
using namespace std;const int N=15;const int M=1050;typedef long long ll;const ll mod=1e9+7;
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod){if(p&1){r=r*a%mod;}}return r;}
int n;int m;ll h;ll w;ll s[M];ll u[M];int up;int siz[M];ll res;int T;
struct retc//矩形类 
{
    ll x;ll y;ll x1;ll y1;int v;
    inline void rd(){scanf("%lld%lld%lld%lld%d",&x,&y,&x1,&y1,&v);}
    inline bool ck(){return (x>x1)||(y>y1);}//是否为空 
    inline ll calcs(){return (x1-x+1)*(y1-y+1);}//求面积 
    void operator &=(const retc& a)//交 
    {x=max(x,a.x);y=max(y,a.y);x1=min(x1,a.x1);y1=min(y1,a.y1);}
    friend bool operator <(retc a,retc b){return a.v<b.v;}
}r[N],tr;
inline void solve()
{
    scanf("%lld%lld%d%d",&h,&w,&m,&n);
    for(int i=0;i<n;i++){r[i].rd();}sort(r,r+n);up=(1<<n)-1;
    for(int i=1;i<=up;i++)//暴力求交集面积 
    {
        tr.x=1;tr.y=1;tr.x1=h;tr.y1=w;
        for(int p=i,j=0;p;p>>=1,j++){if(p&1){tr&=r[j];if(tr.ck()){s[i]=0;goto ed;}}}
        s[i]=tr.calcs();ed:;
    }
    for(int i=1;i<=up;i++)//暴力求并集面积 
    {
        for(int j=i;j;j=(j-1)&i)
        {if(siz[j]%2){u[i]+=s[j];}else {u[i]-=s[j];}}
    }
    int ns=0;int ls=0;res=1;
    for(int i=0;i<n;i++)//分值域统计方案数 
    {
        ns|=(1<<i);if(r[i].v==r[i+1].v){continue;}
        ll tot=u[ns|ls]-u[ls];ll st=tot;ll ret=po(r[i].v,tot);
        for(int k=ns;k;k=(k-1)&ns)
        {
            tot=u[k|ls]-u[ls];
            ll del=po(r[i].v-1,tot)*po(r[i].v,st-tot)%mod;
            if(siz[k]%2){ret=(ret+mod-del)%mod;}
            else {ret=(ret+del)%mod;}
        }res=res*ret%mod;ls|=ns;ns=0;//乘起来	
    }printf("%lld\n",res*po(m,h*w-u[up])%mod); 
}
inline void clear(){for(int i=0;i<=up;i++){u[i]=0;}}
int main()
{
    for(int i=1;i<=1023;i++){siz[i]=siz[i>>1]+(i&1);}scanf("%d",&T);
    for(int z=1;z<=T;z++){solve();clear();}return 0;//拜拜程序~ 
}

```








---

## 作者：Itst (赞：7)

**Update On 2020.3.6：修复了一些细节问题**

---

“子矩阵最大值等于 $v$ ”的方案数等于“子矩阵最大值小于等于$v$的方案数”减去“子矩阵最大值小于 $v$ 的方案数”，考虑容斥。$2^n$ 地枚举哪些子矩阵满足最大值小于 $v$，那么我们可以得到矩阵中每一个位置能够取到的最大值，设 $x_{i,j}$ 表示 $(i,j)$ 的最大取值，那么方案数就是 $\prod\limits_{i=1}^H \prod\limits_{j=1}^W x_{i,j}$。

复杂度 $O(2^nHW)$ 不能接受。发现矩形个数很少，所以有大量的位置取到的最大值相等。可以对横纵坐标离散化，处理出一些子矩形满足无论如何这个子矩形内部的最大值均相等。因为横纵坐标都只有 $O(n)$ 种，所以一共有 $O(n^2)$ 个这样的矩形，对于同一个矩形的贡献可以同时计算。再按照上面的方法做复杂度就是 $O(2^nn^3)$ 了，精细实现还可以做到 $O(n^3+2^nn^2)$。

```
#include<bits/stdc++.h>
//this code is written by Itst
using namespace std;

const int MOD = 1e9 + 7;
int arr[25][25] , X[25] , Y[25] , cntx , cnty , W , H , N , M , T , pos[11][5];

int poww(long long a , int b){
    int times = 1;
    while(b){
        if(b & 1) times = times * a % MOD;
        a = a * a % MOD; b >>= 1;
    }
    return times;
}

int main(){
#ifdef ONLINE_JUDGE
    freopen("in","r",stdin);
    freopen("out","w",stdout);
#endif
    ios::sync_with_stdio(0);
    for(cin >> T ; T ; --T){
        cin >> W >> H >> M >> N; cntx = cnty = 0;
        for(int i = 1 ; i <= N ; ++i){
            for(int j = 0 ; j < 5 ; ++j)
                cin >> pos[i][j];
            X[++cntx] = pos[i][0]; Y[++cnty] = pos[i][1];
            X[++cntx] = ++pos[i][2]; Y[++cnty] = ++pos[i][3];
        }
        X[++cntx] = 1; X[++cntx] = W + 1;
        Y[++cnty] = 1; Y[++cnty] = H + 1;
        sort(X + 1 , X + cntx + 1); cntx = unique(X + 1 , X + cntx + 1) - X - 1;
        sort(Y + 1 , Y + cnty + 1); cnty = unique(Y + 1 , Y + cnty + 1) - Y - 1;
        int ans = 0;
        for(int i = 0 ; i < 1 << N ; ++i){
            for(int j = 1 ; j < cntx ; ++j)
                for(int k = 1 ; k < cnty ; ++k)
                    arr[j][k] = M;
            for(int j = 1 ; j <= N ; ++j)
                for(int k = lower_bound(X + 1 , X + cntx + 1 , pos[j][0]) - X ; X[k] != pos[j][2] ; ++k)
                    for(int l = lower_bound(Y + 1 , Y + cnty + 1 , pos[j][1]) - Y ; Y[l] != pos[j][3] ; ++l)
                        arr[k][l] = min(arr[k][l] , pos[j][4] - (i >> (j - 1) & 1));
            int tmp = 1;
            for(int j = 1 ; j < cntx ; ++j)
                for(int k = 1 ; k < cnty ; ++k)
                    tmp = 1ll * tmp * poww(arr[j][k] , (X[j + 1] - X[j]) * (Y[k + 1] - Y[k])) % MOD;
            ans = (ans + MOD + (__builtin_popcount(i) & 1 ? -1ll : 1ll) * tmp) % MOD;
        }
        cout << ans << endl;
    }
    return 0;
}
```

---

## 作者：pantw (赞：5)

敲代码的时候懒得切输入法所以注释全是英文emmm

作为本蒻的一个心结，这道题的细节还是蛮多的。

做法就是 离散化坐标 + 状压DP。


下面这段内容摘录自FJWC2017课件。


> 题意：一个矩阵中可以任意填 m 个数。给你 N 个小矩阵并且告诉你此矩阵中的最大值 v，求有多少种大矩阵满足所给条件。

> 分析：考虑到 n 很小，因此我们可以通过离散化将所有不同的矩阵重叠的情况(最多 $2 ^ n$种)的最大值和块数先处理出来。其中第 i 种的最大值为 $v_i$，块数为 $c_i$。
然后对于每一种重叠情况，我们有两种选择，其一是不取最大值，则方案数为$(v_i - 1) ^{c_i}$。第二种是取最大值，则方案数为 $v_i ^ {c_i} - (v_i - 1) ^ {c_i}$。

则可以设 `dp[i][j]`为前 i 种重叠块其中有 j 这些状态的矩阵的最大值被满足了的方案数，则我们现在考虑第 i+1 块的取的情况。不妨设当第 i+1 块取最大值时能使得 `s[i + 1]`的矩阵被满足。

则当取最大值时，把对应方案数转移到 `dp[i + 1][j | s[i + 1]]`，否则转移到 `dp[i + 1][j]`。

故 `dp[(1 << n)][(1 << n) - 1]`为最终的方案。


具体实现细节请参考本蒻的代码。


```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define maxn 10010
#define maxm 30
#define mod 1000000007
#define Lovelive long long

// Records the matrices' information.
int x1[maxm], y1[maxm], x2[maxm], y2[maxm], v[maxm];

// Represents x-bounds && y-bounds.  
// e.g. xb[i] = 1 means that there is a gap between row 1 and row 2. 
int xb[maxm], yb[maxm], xbs, ybs;

// Record the information for each block.
int block[maxm * maxm], bs, blimit[maxm * maxm], fulfill[maxm * maxm];

// DP array.
Lovelive f[maxm * maxm][1100];

// Tell whether the grid (x,y) is in rectangle i.
inline int in(int x, int y, int i) {
    return x >= x1[i] && x <= x2[i] && y >= y1[i] && y <= y2[i];
}

// Returns the minimum value between x and y.
inline int min(int x, int y) {
    return x < y ? x : y;
}

// Calculate power of an integer in O(log p) time
Lovelive pow(Lovelive n, Lovelive p) {
    Lovelive ret = 1;
    for(; p; p >>= 1, n = n * n % mod) {
        if(p&1) ret = ret * n % mod;
    }
    return ret;
}

int main() {
    int T;
    scanf("%d", &T);
    while(T--) {
        //initialization 
        xbs = ybs = bs = 0;
        xb[xbs++] = 0;
        yb[ybs++] = 0;
        memset(f, 0, sizeof f);
        memset(fulfill, 0, sizeof fulfill);
        
        int h, w, m, n;
        scanf("%d%d%d%d", &h, &w, &m, &n);
        for(int i = 0; i < n; i++) {
            scanf("%d%d%d%d%d", x1 + i, y1 + i, x2 + i, y2 + i, v + i);
            xb[xbs++] = x1[i] - 1;
            yb[ybs++] = y1[i] - 1;
            xb[xbs++] = x2[i];
            yb[ybs++] = y2[i];
        }
        xb[xbs++] = h;
        yb[ybs++] = w;
        // Discretize indices.
        std::sort(xb, xb + xbs);
        std::sort(yb, yb + ybs);
        xbs = std::unique(xb, xb + xbs) - xb;
        ybs = std::unique(yb, yb + ybs) - yb;
        
        // Preprocess the information of each block.
        for(int i = 1; i < xbs; ++i) {
            for(int j = 1; j < ybs; ++j) {
                ++bs;
                block[bs] = (xb[i] - xb[i-1]) * (yb[j] - yb[j-1]);
                blimit[bs] = m;
                for(int k = 0; k < n; ++k)
                    if(in(xb[i], yb[j], k))
                        blimit[bs] = min(blimit[bs], v[k]);                
                for(int k = 0; k < n; ++k)
                    if(in(xb[i], yb[j], k) && blimit[bs] == v[k])
                        fulfill[bs] ^= 1 << k;
            }
        }
        
        int li = 1 << n;
        f[0][0] = 1;
        for(int i = 1; i <= bs; ++i) {
            int ful = fulfill[i];
            Lovelive fail = pow(blimit[i] - 1, block[i]);
            Lovelive success = pow(blimit[i], block[i]) - fail + mod;
            for(int j = 0; j - li; ++j) {
                f[i][j] = (f[i][j] + f[i-1][j] * fail) % mod;
                f[i][j|ful] = (f[i][j|ful] + f[i-1][j] * success) % mod;
            }
        }
        
        printf("%d\n", (int)f[bs][li-1]);
    }
}
```

---

## 作者：Dreamunk (赞：4)

[题目](https://www.luogu.org/problem/P3813)

给定一个 $h\times w$ 的矩阵，每个格子中将填入 $1$ 到 $m$ 中的某个整数。  
一个合法的填数方案须满足 $n$ 条限制，每条限制形如“以 $(x_1,y_1)$ 为左上角，$(x_2,y_2)$ 为右下角的子矩阵中，最大值必须为 $v$”。  
求填数方案数，对大质数取模。  

把这 $n$ 条限制按照 $v$ 从小到大排序。

这样，就可以对每个 $x$ 求出最小限制为 $x$ 的区域的答案，最后处理没被限制的区域（这显然是 $m^{S_R}$，$S_R$ 没被限制的区域的面积）。

答案就是把这些东西全部乘起来。

接下来考虑对于每个 $x$ 求出最小限制为 $x$ 的区域的答案。

设 $A$ 为所有 $v$ 值等于 $x$ 的限制构成的集合。我们要满足 $A$ 中所有限制，并不好算，考虑容斥。

改为对 $A$ 的每个子集 $B$，求强制让其不满足的方案数，大概是 $(x-1)^{S_B}x^{S_{A-B}}$ ，其中 $S_A$ 为集合 $A$ 中所有子矩阵的并的面积去掉其中有更小限制的面积。然后加加减减就行。

发现我们还要求区域面积，当然可以离散化坐标值然后随便搞，但那个细节巨多。考虑更好写的方法：继续容斥。

我们发现本题中所有的面积都可以转为矩形的交和并。

发现矩形交是好求的，而并的就等于其子集的交加加减减，然后就求完了。枚举子集的子集是 $O(3^n)$ 的。

每组数据的复杂度为 $O(3^n+2^n\log(hw))$，$\log$ 来自快速幂。（当然可以 FMT 把 $3^n$ 优化掉，优化到 $O(2^nn+2^n\log(hw))$，但没有必要）。

```cpp
#include<cstdio>
#include<algorithm>
typedef long long ll;
const int N=10,M=1e9+7;
inline int Pow(int a,int m){int s=1;for(;m;m>>=1)m&1?s=(ll)s*a%M:0,a=(ll)a*a%M;return s;}
int x[N],y[N],xx[N],yy[N],mx[N],t[N],n,m,h,w,cnt[1<<N],ans,tmp;ll cup[1<<N],cap[1<<N];
bool Cmp(const int&i,const int&j){return mx[i]<mx[j];}
int main(){
    int a,b,aa,bb,U;
	for(int I=0;I<(1<<N);I++)cnt[I]=cnt[I>>1]+(I&1);
	int T;scanf("%d",&T);for(;T--;){
	scanf("%d%d%d%d",&h,&w,&m,&n);
	for(int i=0;i<n;i++)scanf("%d%d%d%d%d",x+i,y+i,xx+i,yy+i,mx+i),t[i]=i;
	std::sort(t,t+n,Cmp);
	for(int I=0;I<(1<<n);I++){
	  a=b=0,aa=h,bb=w;
	  for(int i=0;i<n;i++)if(I&1<<i){
		a=std::max(a,x[i]);
		b=std::max(b,y[i]);
		aa=std::min(aa,xx[i]);
		bb=std::min(bb,yy[i]);
	  }
	  cap[I]=a>aa||b>bb?0:(ll)(aa-a+1)*(bb-b+1);
	}
	for(int I=0;I<(1<<n);I++){
	  cup[I]=0;
	  for(int J=I;J;J=I&J-1)
		cup[I]=(cup[I]+cap[J]*(cnt[J]&1?1:-1));
	}
	ans=Pow(m,h*w-cup[(1<<n)-1]);
	U=0;
	for(int l=0,r=0,I;r<n;r++)if(r+1==n||mx[t[r]]!=mx[t[r+1]]){
	  I=0;
	  for(int i=l;i<=r;i++)I|=1<<t[i];
	  tmp=Pow(mx[t[r]],cup[I|U]-cup[U]);
	  for(int J=I;J;J=I&J-1)
		tmp=(tmp+(ll)Pow(mx[t[r]]-1,cup[J|U]-cup[U])*Pow(mx[t[r]],cup[I|U]-cup[J|U])%M*(cnt[J]&1?-1:1)+M)%M;
	  ans=(ll)ans*tmp%M;
	  U|=I,l=r+1;
	}
	printf("%d\n",ans);
	}return 0;
}
```

---

## 作者：HomuraAkemi (赞：3)

$v$ 的值的个数只有 $1$ 怎么做？

如果只有一个大小为 $a$ 的矩形，那么矩形内部的值域为 $[1,v]$，而且必须至少有一个 $v$，那么就是 $v^{a}-(v-1)^a$。

如果有两个大小为 $a,b$ 的矩形，如果无交的话方案数显然为 $v^{a+b}-(v-1)^av^b-v^a(v-1)^b+(v-1)^{a+b}$；如果有交的话，方案数就是 $v^{a\cup b}-(v-1)^av^{a\cup b-a}-v^{a\cup b-b}(v-1)^b+(v-1)^{a\cup b}$，不难发现这也适用于无交的情况。这里，$a\cup b$ 指两个矩形并的面积。

所以更进一步地，我们得到，$v$ 的值的个数为 $1$ 时，答案为

$$ \sum_{T\subseteq S} (-1)^{|T|}v^{\operatorname{union}(S)-\operatorname{union}(T)}(v-1)^{\operatorname{union}(T)} $$

如果不同的 $v$ 的个数 $\gt 1$ 怎么办？先考虑值小的位置，因为值小的位置显然要先被考虑；然后在上式的 $\operatorname{union}$ 中扣除值已经确定的部分即可。

实现时，可以把有用的坐标转成左闭右开的形式之后离散化（只有 $\Theta(n)$ 个），查询时可以直接暴力查询。

时间复杂度 $\Theta(n^32^n)$。当然精细实现的话是可以更优的。

代码：

```cpp
// Homura Akemi a.k.a. Starrykiller (/user/235125)
// I love Madoka Kaname forever! 
#include <bits/stdc++.h>

using namespace std;

auto range(auto l, auto r) { return views::iota(l,r); }
auto rev=views::reverse;

namespace sk { // modint
};

using ll=sk::modint1000000007;

struct Q {
    int x1, y1, x2, y2;
};

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
int T; cin>>T;
// int T=1;
while (T--) []{
    int r, c, v, n;
    cin>>r>>c>>v>>n;
    vector<int> d={1,r+1,c+1};
    ll ans=1;
    map<int,vector<Q>> q;
    for (int v, x1, y1, x2, y2; auto _: range(0,n)) {
        cin>>x1>>y1>>x2>>y2>>v;
        q[v].emplace_back(x1,y1,x2+1,y2+1);
        d.insert(end(d),{x1,y1,x2+1,y2+1});
    }
    ranges::sort(d); d.erase(unique(begin(d),end(d)),end(d));
    auto get=[&](int x) {
        return ranges::lower_bound(d,x)-begin(d);
    };
    int m=size(d); vector vis(m,vector<int>(m));
    auto sum_union=[&](const vector<Q>& q) {
        vector tmp(m,vector<int>(m));
        for (const auto &[x1,y1,x2,y2]: q) {
            tmp[x1][y1]++;
            tmp[x2][y2]++;
            tmp[x2][y1]--;
            tmp[x1][y2]--;
        }
        for (auto i: range(0,m))
            for (auto j: range(0,m)) {
                if (i) tmp[i][j]+=tmp[i-1][j];
                if (j) tmp[i][j]+=tmp[i][j-1];
                if (i&&j) tmp[i][j]-=tmp[i-1][j-1];
            }
        int ans=0;
        for (auto i: range(0,m-1))
            for (auto j: range(0,m-1)) if (tmp[i][j] && !vis[i][j]) 
                ans+=(d[i+1]-d[i])*(d[j+1]-d[j]);
        return ans;
    };
    for (auto &[v,c]: q) {
        ll sum=0;
        for (auto &[x1,y1,x2,y2]: c) {
            x1=get(x1); y1=get(y1);
            x2=get(x2); y2=get(y2);
        }
        int all=sum_union(c);
        auto k=size(c);
        for (auto i: range(0u,1u<<k)) {
            vector<Q> q;
            for (auto j: range(0u,k)) if (i>>j&1) q.emplace_back(c[j]);
            int partial=sum_union(q);
            ll cur=ll(v-1).pow(partial)*ll(v).pow(all-partial);
            if (popcount(i)&1) sum-=cur;
            else sum+=cur;
        }
        for (auto &[x1,y1,x2,y2]: c)
            for (int i=x1; i<x2; ++i)
                for (int j=y1; j<y2; ++j) vis[i][j]++;
        ans*=sum;
    }
    ans*=ll(v).pow(sum_union({{get(1),get(1),get(r+1),get(c+1)}}));
    cout<<ans<<'\n';
}();
}
```

---

## 作者：Daidly (赞：3)

> 现在，你的任务是求出有多少种填数的方案满足 $n$ 个限制。

考虑容斥，第 $i$ 个矩形的条件为：矩形中的点权不超过 $v_i$ 且存在点权为 $v_i$ 的点。

> 将 $\max(a_1,a_2)=v$ 转换为 $\max(a_1,a_2)\leq v$ 和 $a_1=v$ 或 $a_2=v$。

需要求的是 $n$ 个集合的交集。

考虑没有限制存在点权，只有 $\leq v_i$ 的限制，相当于矩形取 $\min$，查值，离散化横纵坐标暴力再利用乘法原理即可得出。

> 为什么能用乘法原理？
>
> 考虑两个数的情况，即 $\max(a_1,a_2)\leq v$，转化为两个独立的式子：$a_1\leq v,a_2\leq v$，可以使用乘法原理。

由于可以快速求，所以我们将每个矩形 $\leq v_i$ 的交作为全集。

记 $S_i$ 表示在第 $i$ 矩形内存在点权为 $v_i$ 的点。

$$
\begin{aligned}

\Bigg|\bigcap_{i=1}^nS_i\Bigg|&=|U|-\Bigg|\bigcup_{i=1}^n\overline{S_i}\Bigg|\\

&=|U|-\sum_{T\in[n],T\ne\emptyset}(-1)^{|T|+1}\Bigg|\bigcap_{i\in T}\overline{S_i}\Bigg|\\

&=|U|+\sum_{T\in[n],T\ne\emptyset}(-1)^{|T|}\Bigg|\bigcap_{i\in T}\overline{S_i}\Bigg|\\

&=\sum_{T\in[n]}(-1)^{|T|}\Bigg|\bigcap_{i\in T}\overline{S_i}\Bigg|\\

\end{aligned}
$$

考虑 $\overline{S_i}$ 的意义：在第 $i$ 个矩形内不存在点权为 $v_i$ 的点，即第 $i$ 个矩形内点权 $\leq v_i-1$。又可以按求全集的方法做了。

注意点：整个 $h\times w$ 的矩形也有限制，我们可以在离散化和求全集时加上，但是容斥的时候不要带上，因为它的要求只是不超过 $m$。

[My Submission](https://www.luogu.com.cn/record/104286784)

---

## 作者：绝顶我为峰 (赞：3)

首先计算最小值恰好 $=v$ 的方案数有一个非常套路的转化是差分一下变成最小值 $\leq v$ 和最小值 $\leq v-1$ 的数量相减。

这里有多个限制，直接这样做就不行了，但注意到 $n\leq10$，显然可以枚举一个子集然后容斥，钦定不合法的子矩形限制最小值 $\leq v-1$，没有钦定的则不变。

现在我们要快速求出每个点的取值范围，显然下界永远是 $1$，只要求上界即可。

不难想到将所有限制按照权值从小到大排序依次加入，这样一旦一个位置被覆盖后上界就不会再改变了，于是问题转化成了维护一个 $01$ 矩阵，支持查询矩形和，矩形赋值成 $0$。

这个怎么做？树套树？分块？停停，别数据结构学傻了，一共只有十次操作，还可以离线，直接把矩形离散化一下然后每次暴力找就结束了。

时间复杂度 $O(2^nn^3)$。

```cpp
#include<iostream>
#include<cstdio>
#include<bitset>
#include<cstring>
#include<algorithm>
using namespace std;
const int block=100,mod=1e9+7;
int t,n,m,lim,p,ans,sum[31][31],node1[31],cnt1,node2[31],cnt2;
bool vis[31][31];
struct element
{
    int l1,l2,r1,r2,w;
    bool operator<(const element &other) const
    {
        return w<other.w;
    }
}a[10],b[10];
inline void init()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
}
inline int read()
{
    int x;
    cin>>x;
    return x;
}
inline int pw(int a,int b)
{
    int res=1;
    while(b)
    {
        if(b&1)
            res=1ll*res*a%mod;
        b>>=1;
        a=1ll*a*a%mod;
    }
    return res;
}
inline int Mod(int x)
{
    return x>=mod? x-mod:x;
}
inline int calc(int l1,int l2,int r1,int r2)
{
    int res=0;
    for(int i=l1;i<l2;++i)
        for(int j=r1;j<r2;++j)
            if(!vis[i][j])
            {
                vis[i][j]=1;
                res+=sum[i][j];
            }
    return res;
}
inline void clear()
{
    for(int i=1;i<cnt1;++i)
        for(int j=1;j<cnt2;++j)
            vis[i][j]=0;
}
int main()
{
    init();
    t=read();
    while(t--)
    {
        n=read(),m=read(),lim=read(),p=read();
        cnt1=cnt2=ans=0;
        node1[++cnt1]=1;
        node1[++cnt1]=n+1;
        node2[++cnt2]=1;
        node2[++cnt2]=m+1;
        memset(sum,0,sizeof sum);
        for(int i=0;i<p;++i)
            node1[++cnt1]=a[i].l1=read(),node2[++cnt2]=a[i].r1=read(),node1[++cnt1]=a[i].l2=read()+1,node2[++cnt2]=a[i].r2=read()+1,a[i].w=read();
        sort(node1+1,node1+cnt1+1);
        sort(node2+1,node2+cnt2+1);
        cnt1=unique(node1+1,node1+cnt1+1)-node1-1;
        cnt2=unique(node2+1,node2+cnt2+1)-node2-1;
        for(int i=0;i<p;++i)
        {
            a[i].l1=lower_bound(node1+1,node1+cnt1+1,a[i].l1)-node1;
            a[i].l2=lower_bound(node1+1,node1+cnt1+1,a[i].l2)-node1;
            a[i].r1=lower_bound(node2+1,node2+cnt2+1,a[i].r1)-node2;
            a[i].r2=lower_bound(node2+1,node2+cnt2+1,a[i].r2)-node2;
        }
        for(int i=1;i<cnt1;++i)
            for(int j=1;j<cnt2;++j)
                sum[i][j]=(node1[i+1]-node1[i])*(node2[j+1]-node2[j]);
        for(int s=0;s<1<<p;++s)
        {
            int res=1;
            for(int i=0;i<p;++i)
            {
                b[i]=a[i];
                if(s>>i&1)
                    --b[i].w;
            }
            clear();
            sort(b,b+p);
            for(int i=0;i<p;++i)
                res=1ll*res*pw(b[i].w,calc(b[i].l1,b[i].l2,b[i].r1,b[i].r2))%mod;
            for(int i=1;i<cnt1;++i)
                for(int j=1;j<cnt2;++j)
                    if(!vis[i][j])
                        res=1ll*res*pw(lim,sum[i][j])%mod;
            ans=Mod(ans+1ll*(__builtin_parity(s)? mod-1:1)*res%mod);
        }
        cout<<ans<<'\n';
    }
    cout.flush();
    return 0;
}
```

---

## 作者：littleKtian (赞：3)

这里是一个 $O(n2^n)$ 的做法（不过常数相对较大）。

------------

最大值为 $v$ 的限制不好处理，考虑将限制转成**矩阵内所有数的值不大于 $v$** 后用容斥求解（具体来讲，枚举其中每个限制是否被打破，那么对于所有被打破的限制将会变为**矩阵内所有数的值不大于 $v-1$**）。

我们可以将整个矩阵分成 $O(n^2)$ 块，每块都会有若干个最大值的限制（也可能没有限制）。显然这些限制中只有 $v$ 值最小的最大值限制能影响每块的取值范围（即便打破其他限制也无法对其产生影响），于是我们可以只保留这些性质。对于块 $i$，我们记 $S_i$ 表示能影响块 $i$ 取值范围的限制的集合，$w_i$ 表示这些限制的 $v$。

我们将所有 $v$ 值相同的最大值限制看做一组，记作集合 $U$，枚举其中哪些性质被打破，记这些被打破的性质的集合为 $T$。容易发现对于所有的块 $x(w_x=v)$，当且仅当 $T\bigcap S_x=\varnothing$ 时块 $x$ 的取值范围为 $\left[1,v\right]$，否则为 $\left[1,v-1\right]$。

将 $T$ 对 $U$ 取补集，有 $S_x\subset\complement_UT$，于是我们可以 $O(t2^t)$（$t$ 为集合 $U$ 的大小）对于所有的 $T$ 求出所有 $w_x=v$ 的块 $x$ 中取值范围为 $\left[1,v\right]$ 的块的总面积，从而求出该部分的答案。

各部分的答案的乘积再乘上所有没有被受限制的块的部分的答案就是最终结果。

套个光速幂就能做到 $O(n2^n)$ 了。

```cpp
#include<bits/stdc++.h>
#define p 1000000007
#define K 10000
using namespace std;
int T,h,w,m,n;
int x_1[15],y_1[15],x_2[15],y_2[15],v[15],xh[15],tk[15];
int fm[2][15][K+5],ffm[2][15][K+5];
bool cmp(const int &x,const int &y){return v[x]<v[y];}
int lx[25],ly[25],ls[25],tx,ty;
int fg[25][25][15],ff[(1<<10)+5],f[(1<<10)+5],fk,ans;
int dr()
{
    int xx=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')xx=xx*10+ch-'0',ch=getchar();
    return xx;
}
int P(int opt,int xh,int y){return opt?1ll*ffm[1][xh][y/K]*ffm[0][xh][y%K]%p:1ll*fm[1][xh][y/K]*fm[0][xh][y%K]%p;}
int fi(int opt,int x)
{
    int l=1,r=opt?ty:tx,mid;
    while(l<=r)
    {
        mid=(l+r)>>1;int mx=opt?ly[mid]:lx[mid];
        if(x==mx)return mid;
        if(x<mx)r=mid-1;else l=mid+1;
    }
    return -1;
}
int main()
{
    T=dr();
    while(T--)
    {
        tx=ty=0,fk=0,ans=0;
        memset(fg,0,sizeof(fg));
        memset(f,0,sizeof(f));
        memset(ff,0,sizeof(ff));
        memset(tk,0,sizeof(tk));
        h=dr(),w=dr(),m=dr(),n=dr();
        for(int i=1;i<=n;i++)lx[i]=x_1[i]=dr(),ly[i]=y_1[i]=dr(),lx[n+i]=(x_2[i]=dr())+1,ly[n+i]=(y_2[i]=dr())+1,v[i]=dr(),xh[i]=i;
        lx[2*n+1]=ly[2*n+1]=1,lx[2*n+2]=h+1,ly[2*n+2]=w+1;
        sort(lx+1,lx+2*n+3),sort(ly+1,ly+2*n+3),sort(xh+1,xh+n+1,cmp);
        for(int i=1;i<=2*n+2;i++)if(lx[i]!=lx[i-1])ls[++tx]=lx[i];
        for(int i=1;i<=tx;i++)lx[i]=ls[i];
        for(int i=1;i<=2*n+2;i++)if(ly[i]!=ly[i-1])ls[++ty]=ly[i];
        for(int i=1;i<=ty;i++)ly[i]=ls[i];
        for(int i=1;i<=n;i++)
        {
            fm[0][i][0]=fm[1][i][0]=ffm[0][i][0]=ffm[1][i][0]=1;
            for(int j=1;j<=K;j++)fm[0][i][j]=1ll*fm[0][i][j-1]*v[i]%p,ffm[0][i][j]=1ll*ffm[0][i][j-1]*(v[i]-1)%p;
            for(int j=1;j<=K;j++)fm[1][i][j]=1ll*fm[1][i][j-1]*fm[0][i][K]%p,ffm[1][i][j]=1ll*ffm[1][i][j-1]*ffm[0][i][K]%p;
        }
        fm[0][0][0]=fm[1][0][0]=1;
        for(int i=1;i<=K;i++)fm[0][0][i]=1ll*fm[0][0][i-1]*m%p;
        for(int i=1;i<=K;i++)fm[1][0][i]=1ll*fm[1][0][i-1]*fm[0][0][K]%p;
        for(int t=1;t<=n;t++)
        {
            int x=fi(0,x_1[t]),y=fi(1,y_1[t]),xx=fi(0,x_2[t]+1),yy=fi(1,y_2[t]+1);
            for(int i=x;i<xx;i++)for(int j=y;j<yy;j++)fg[i][j][t]=1;
        }
        for(int i=1;i<tx;i++)for(int j=1;j<ty;j++)
        {
            int kn=(lx[i+1]-lx[i])*(ly[j+1]-ly[j]),fv=0;
            for(int t=1;t<=n;t++)if(fg[i][j][xh[t]]){fv=v[xh[t]];break;}
            if(fv)
            {
                int zt=0;
                for(int t=1;t<=n;t++)
                if(v[xh[t]]==fv)
                {
                    tk[t]+=kn;
                    if(fg[i][j][xh[t]])zt^=1<<(t-1);
                }
                ff[zt]+=kn;
            }
            else fk+=kn;
        }
        ans=P(0,0,fk);
        for(int t=1;t<=n;t++)
        {
            int nt=t,l,tzt;
            while(nt<n&&v[xh[nt+1]]==v[xh[t]])++nt;
            l=nt-t+1,tzt=(1<<l)-1;
            for(int i=0;i<=tzt;i++)f[i]=ff[i<<(t-1)];
            for(int i=0;i<l;i++)for(int j=0;j<(1<<l);j++)if(!(j&(1<<i)))f[j^(1<<i)]+=f[j];
            int lan=0;
            for(int i=0;i<=tzt;i++)
            {
                int lans=1ll*P(0,xh[t],f[i])*P(1,xh[t],tk[t]-f[i])%p,ttt=i^tzt,op=0;
                for(int j=0;j<l;j++)if(ttt&(1<<j))op^=1;
                lan=(lan+(op?-1ll:1ll)*lans+p)%p;
            }
            for(int i=0;i<(1<<l);i++)f[i]=0;
            ans=1ll*ans*lan%p,t=nt;
        }
        printf("%d\n",ans);
    }
}
```

---

## 作者：MoyunAllgorithm (赞：2)

在模拟赛上切了该题，纪念，并给出一种状压解法。~~码字不易求通过qwq~~

### 题意

给 $H \times W$ 的矩阵，每个格子填写一个 $[1,M]$ 的值，需要满足 $N$ 条限制：

- 给出一个子矩形和 $v$。要求该子矩形内的最大值刚好是 $v$。

对于 $40 \%$ 的数据，$H,W \le 50$。

对于所有数据，$H,W \le 10000,N \le 10$。

### 分析

看到 $N \le 10$，能想到这可能是一个与 $2$ 的次幂有关的解法。相关的解法是**容斥**和**状压 dp**。个人对 dp 比较熟悉，因此也往这方面考虑。

从 $\textbf{40}$ **分部分分**入手。考虑 $dp(i,j,st)$ 表示我们考虑了方格 $(i,j)$ 及以前的填数情况，当前满足了二进制数 $st$ 中为 $\texttt 1$ 的位的限制，的填数方法个数。事实上你会发现前两维可以滚动数组优化。

除此以外，我们还需要定义 $\text{stat}(x,y)$ 表示有哪些子矩形包含 $(x,y)$，且**其对应的 $v$ 是所有包含 $(x,y)$ 的子矩形中最小的**。定义 $\text{mxv}(x,y)$ 表示所有包含 $(x,y)$ 的子矩形中最小的 $v$。那么 $(x,y)$ 中填写的数必须是 $[1,\text{mxv}(x,y)]$ 的范围。

你可能会对 $\text{stat}$ 感到疑惑。$\text{stat}$ 的意义在于，如果 $(x,y)$ 填了 $\text{mxv}(x,y)$，那所有 $\text{stat}(x,y)$ 状态代表的子矩形满足要求。需要注意的是，包含 $(x,y)$ 的其他子矩形可能不满足，因为这不是它规定的最大值。

考虑如何转移。如果我们枚举到了一组 $(i,j,st)$，那么：

 当 $st$ 所代表的 $\texttt{01}$ 串包含 $\text{stat}(i,j)$，即对于任意一个 $p \in [0,N)$，如果 $\text{stat}(i,j)$ 的第 $p$ 位若是 $\texttt 1$，则 $st$ 的第 $p$ 位也必须是 $\texttt 1$，那么说明：**所有包含 $(i,j)$ 的子矩形的限制已经满足**。这意味着 **我可以在 $\text{mxv} (i,j)$ 的范围内随意填写该值**。 $dp(1,st)=dp(1,st)+dp(0,st) \times \text{mxv}(i,j)$。（注：这里的 $dp$ 第一维是滚动数组）

 否则，**存在包含 $(i,j)$ 的子矩形没有被满足要求**。那我此时可以选择：

- 在这里填写 $[1,\text{mxv}(i,j))$ 的数。那不会满足任何其他要求，$st$ 不变。$dp(1,st)=dp(1,st)+dp(0,st) \times (\text{mxv}(i,j)-1)$。

- 在这里填写 $\text{mxv}(i,j)$。那么：**所有 $\text{stat}(i,j)$ 的矩形都会被满足。** 因此 $dp(1,st|\text{stat}(i,j))=dp(1,st|\text{stat}(i,j))+dp(0,st)$。这里就不需要乘 $\text{mxv}$ 了，因为只有一个值能填。

这样我们解决了该问题，但时间复杂度是 $O(HW2^N)$ 的，可以得到 $40$ 分。

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int MOD=1e9+7;
LL dp[2][1<<10];
int H,W,M,N;
bool in[55][55][15];
int stat[55][55];
int mxv[55][55];
int lim[15];
bool Cover(int x,int y)
{
	for(int i=1;i<=N;i++)
	{
		if((y&(1<<i-1))&&!(x&(1<<i-1))) return false;
	}
	return true;
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d %d %d %d",&H,&W,&M,&N);
		memset(dp,0,sizeof(dp));
		memset(in,0,sizeof(in));
		memset(stat,0,sizeof(stat));
		for(int i=1;i<=H;i++)
			for(int j=1;j<=W;j++)
				mxv[i][j]=M;
		for(int i=1;i<=N;i++)
		{
			int xa,ya,xb,yb,v;
			scanf("%d %d %d %d %d",&xa,&ya,&xb,&yb,&v);
			lim[i]=v;
			for(int j=xa;j<=xb;j++)
				for(int k=ya;k<=yb;k++)
					in[j][k][i]=1,mxv[j][k]=min(mxv[j][k],v);
		}
		for(int i=1;i<=H;i++)
		{
			for(int j=1;j<=W;j++)
			{
				for(int k=1;k<=N;k++)
				if(in[i][j][k]&&lim[k]==mxv[i][j]) stat[i][j]|=(1<<k-1);
				//printf("%d %d %d %d\n",i,j,stat[i][j],mxv[i][j]);
			}
		}
		dp[0][0]=1;
		for(int i=1;i<=H;i++)
		{
			for(int j=1;j<=W;j++)
			{
				for(int st=0;st<(1<<N);st++)
				{
					if(Cover(st,stat[i][j])) dp[1][st]=(dp[1][st]+dp[0][st]*mxv[i][j])%MOD;
					else
					{
						//printf("DP%d %d %d %d ",i,j,st,stat[i][j]);
						dp[1][st]=(dp[1][st]+dp[0][st]*(mxv[i][j]-1))%MOD;
						dp[1][st|stat[i][j]]=(dp[1][st|stat[i][j]]+dp[0][st]);
					}
				}
				for(int st=0;st<(1<<N);st++) dp[0][st]=dp[1][st],dp[1][st]=0;
			}
		}
		//for(int st=0;st<(1<<N);st++) printf("(%d %d)\n",st,dp[st]);
		printf("%lld\n",dp[0][(1<<N)-1]);
	}
	return 0;
} 

```

**如何优化？**

**我们发现：$\text{stat}$ 和 $\text{mxv}$ 相同的一些方格的贡献是完全相同的！** 那 $\text{stat}$ 和 $\text{mxv}$ 是由什么决定的？是和覆盖该点的子矩形有关。也就是说存在这个性质：

- 对于两个方格，如果它们被相同的一堆子矩形包含，那它们的 $\text{stat}$ 和 $\text{mxv}$ 相同。

这样我们把方格图分为了若干个区，每个区的点的贡献完全一致。那有多少个区呢？是少于 $2^N$ 个的。

如何快速求出区的大小？我们不可以枚举所有方格并看它是哪个区的，这是 $O(HWN)$ 的会超时。但是当我们把子矩形的坐标离散化，之后再离散化的坐标上枚举，那是 $O(N^3)$ 的。

$dp$ 时，我们不再关心方格 $(i,j)$，而是直接考虑区域 $z$：

 当 $st$ 包含 $\text{stat}(z)$ 时，所有包含该区域的子矩形满足要求。因此该区域每个方格都可以随便填。设 $|z|$ 是该区域的大小即方格个数，则 $dp(1,st)=dp(1,st)+dp(0,st) \times \text{mxv}(z)^{|z|}$。 

 否则我们看**该区域是否存在至少一个 $\text{mxv}(z)$。**

- 不存在，即里填写 $[1,\text{mxv}(i,j))$ 的数。$dp(1,st)=dp(1,st)+dp(0,st) \times (\text{mxv}(z)-1)^{|z|})$。

- 至少填写了一个 $\text{mxv}$。则所有包含该区域的限制被满足。有多少种方案？结合容斥思想：总方案数减去没填 $\text{mxv}$ 的方案数。 $dp(1,st|\text{stat}(z))=dp(1,st|\text{stat}(z))+dp(0,st) \times (\text{mxv}(z)^{|z|}-(\text{mxv}(z)-1)^{|z|})$。

这样我们解决了该题。时间复杂度是 $O(2^{2N} \log (HW))$，后者是快速幂的复杂度。可以通过本题。

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int MOD=1e9+7;
LL dp[1<<10][1<<10];//这里没有滚动数组
int H,W,M,N;
struct Limit
{
	int xa,xb,ya,yb;
	int v;
}l[15];
struct Zone
{
	int mxv;
	int num;
	int stat;
}z[1050];
int Z=0;
bool Cover(int x,int y)
{
	for(int i=1;i<=N;i++)
	{
		if((y&(1<<i-1))&&!(x&(1<<i-1))) return false;
	}
	return true;
}
int px[35],py[35],X,Y;
int in[35][35][35];
int S;
LL QPow(LL base,int po)
{
	LL res=1;
	while(po)
	{
		if(po&1) res=res*base%MOD;
		base=base*base%MOD;
		po>>=1; 
	}
	return res;
}
void dfs(int p,int status)
{
	if(p==N)
	{
		for(int i=1;i<X;i++)
		{
			for(int j=1;j<Y;j++)
			{
				bool flag=1;
				for(int k=1;k<=N;k++)
				{
					if(in[i][j][k]&&!(status&(1<<k-1))) flag=0;
					if(!in[i][j][k]&&(status&(1<<k-1))) flag=0;
				}
				if(flag) z[status].num+=(px[i+1]-px[i])*(py[j+1]-py[j]);
			}
		}
		z[status].mxv=M;
		z[status].stat=0;
		S-=z[status].num;
		for(int i=1;i<=N;i++)
		{
			if(status&(1<<i-1))
			{
				z[status].mxv=min(z[status].mxv,l[i].v);
			}
		}
		for(int i=1;i<=N;i++)
		{
			if(status&(1<<i-1))
			{
				if(l[i].v==z[status].mxv)  z[status].stat|=(1<<i-1);
			}
		}
		return;
	}
	dfs(p+1,status<<1);
	dfs(p+1,status<<1|1);
	return;
}
int main()
{
	freopen("num.in","r",stdin);
	freopen("num.out","w",stdout);
	int T;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d %d %d %d",&H,&W,&M,&N);
		memset(dp,0,sizeof(dp));
		memset(in,0,sizeof(in));
		Z=0;
		X=0,Y=0;
		for(int i=0;i<(1<<10);i++) z[i].num=0;
		px[++X]=1,px[++X]=H+1,py[++Y]=1;py[++Y]=W+1;
		for(int i=1;i<=N;i++)
		{
			int xa,ya,xb,yb,v;
			scanf("%d %d %d %d %d",&xa,&ya,&xb,&yb,&v);
			l[i]={xa,xb,ya,yb,v};
			px[++X]=xa;
			px[++X]=xb+1;
			py[++Y]=ya;
			py[++Y]=yb+1;
		}
		sort(px+1,px+X+1);
		sort(py+1,py+Y+1);
		X=unique(px+1,px+X+1)-px-1;
		Y=unique(py+1,py+Y+1)-py-1;
		for(int i=1;i<=N;i++)
		{
			int xa=l[i].xa,ya=l[i].ya,xb=l[i].xb,yb=l[i].yb;
			xa=lower_bound(px+1,px+X+1,xa)-px;
			xb=lower_bound(px+1,px+X+1,xb+1)-px;
			ya=lower_bound(py+1,py+Y+1,ya)-py;
			yb=lower_bound(py+1,py+Y+1,yb+1)-py;
			for(int j=xa;j<xb;j++)
				for(int k=ya;k<yb;k++)
					in[j][k][i]=1;
		}
		dfs(0,0);
		dp[0][0]=QPow(M,z[0].num);
		for(int i=1;i<(1<<N);i++)
		{
			for(int st=0;st<(1<<N);st++)
			{
				if(Cover(st,z[i].stat)) dp[i][st]=(dp[i][st]+dp[i-1][st]*QPow(z[i].mxv,z[i].num))%MOD;
				else
				{
					//printf("DP%d %d ",i,st);
					dp[i][st]=(dp[i][st]+dp[i-1][st]*QPow(z[i].mxv-1,z[i].num))%MOD;
					dp[i][st|z[i].stat]=(dp[i][st|z[i].stat]+dp[i-1][st]*((QPow(z[i].mxv,z[i].num)-QPow(z[i].mxv-1,z[i].num))%MOD+MOD)%MOD);
				}
			}
		}
		printf("%lld\n",dp[(1<<N)-1][(1<<N)-1]);
	}
	return 0;
} 
```



---

## 作者：SegTree (赞：2)

最大值恰好等于 $k$ 并不是好做的，但是最大值 $\le k$ 较为显然。

如果我们现在已经知道若干个条件形如一个矩阵的最大值 $\le k$，那么我们可以对于这些条件按照 $k$ 进行排序，显然没有矩阵中没有被考虑过的点可以在 $1$ 到 $k$ 中任取，有 $k^{cnt}$ 种方案，然后将这个矩阵没有被考虑过的点标记一下。实现上可以将坐标离散化然后暴力扫一遍。

如果我们只有 $1$ 个限制，我们可以把最大值 $\le k$ 的方案数减去最大值 $\le k-1$ 的方案数。

记 $k_i$ 表示第 $i$ 个限制中的 $k$ 的值。如果有 $2$ 个限制，可以求出

第一个条件的矩阵最大值 $\le k_1$ 且第二个条件的矩阵最大值 $\le k_2$，这里记为 $A$。

第一个条件的矩阵最大值 $\le k_1$ 且第二个条件的矩阵最大值 $\le k_2-1$，记为 $B$。

第一个条件的矩阵最大值 $\le k_1-1$ 且第二个条件的矩阵最大值 $\le k_2$，记为 $C$。

第一个条件的矩阵最大值 $\le k_1-1$ 且第二个条件的矩阵最大值 $\le k_2-1$，记为 $D$。

那么第一个条件的矩阵最大值 $=k_1$ 且 第二个条件的矩阵最大值 $=k_2$ 的方案数为 $A-B-C+D$。（如图所示：）

![](https://cdn.luogu.com.cn/upload/image_hosting/5m23bhcs.png)

$A=S_1+S_2+S_3+S_4$

$B=S_1+S_3$

$C=S_1+S_2$

$D=S_1$

$A-B-C+D=S_4$

同理，若有 $n$ 条限制，则答案为最大值 $\le k-1$ 的限制有偶数个的方案数减去最大值 $\le k-1$ 的限制有奇数个的方案数。

直接计算，时间复杂度 $\mathcal{O}(2^nn^3)$（$\mathcal{O}(n^3)$ 是第一维枚举限制、剩下两维要扫该限制对应的矩阵。）

代码仅供参考：

```cpp
int calc(){
    vector<int>vx,vy;
    up(i,1,q)tmp[i]=d[i];tmp[q+1]=(node){1,n,1,m,M};
    vx.p_b(-1),vy.p_b(-1);
    up(i,1,q+1){
        vx.p_b(tmp[i].xl-1),vx.p_b(tmp[i].xr+1),vy.p_b(tmp[i].yl-1),vy.p_b(tmp[i].yr+1);
        vx.p_b(tmp[i].xl),vx.p_b(tmp[i].xr),vy.p_b(tmp[i].yl),vy.p_b(tmp[i].yr);
    }sort(vx.begin(),vx.end()),sort(vy.begin(),vy.end());
    up(i,1,q+1){
        tmp[i].xl=lower_bound(vx.begin(),vx.end(),tmp[i].xl)-vx.begin(),tmp[i].xr=lower_bound(vx.begin(),vx.end(),tmp[i].xr)-vx.begin();
        tmp[i].yl=lower_bound(vy.begin(),vy.end(),tmp[i].yl)-vy.begin(),tmp[i].yr=lower_bound(vy.begin(),vy.end(),tmp[i].yr)-vy.begin();
    }sort(tmp+1,tmp+q+2);
    int ret=1;
    up(i,1,50)up(j,1,50)res[i][j]=0;
    up(i,1,q+1){
        up(j,tmp[i].xl,tmp[i].xr){
            up(k,tmp[i].yl,tmp[i].yr){
                if(!res[j][k]){
                    res[j][k]=1;
                    ret=ret*1ll*qpow(tmp[i].v,(vx[j]-vx[j-1])*(vy[k]-vy[k-1]))%mod;
                }
            }
        }
    }return ret;
}
void dfs(int x,int cnt){
    if(x>q){
        int res=calc();
        if(!(cnt&1))(ans+=res)%=mod;
        else ans=(ans-res+mod)%mod;
        return;
    }d[x]=Q[x];
    d[x].v=Q[x].v;
    dfs(x+1,cnt);
    d[x].v=Q[x].v-1;
    dfs(x+1,cnt+1);
    d[x]=Q[x];
}
void slv(){
    n=read(),m=read(),M=read(),q=read();
    up(i,1,q)Q[i].xl=read(),Q[i].yl=read(),Q[i].xr=read(),Q[i].yr=read(),Q[i].v=read();
    ans=0;
    dfs(1,0);
    printf("%d\n",ans);
}
```

---

## 作者：ax_by_c (赞：1)

我们知道最大值为 $x$ 相当于：

- 均不超过 $x$。

- 存在 $x$。

对每个格子求出 $lim_{i,j}$ 表示其能取的上界即可解决第一个限制，但是第二个限制不好解决。

考虑容斥，设 $S$ 集合内的第二个限制不满足的方案数为 $F(S)$，答案即为 $\sum_S(-1)^{\lvert S\rvert}F(S)$。

考虑如何计算 $F(S)$，将在 $S$ 中的限制上界减去一即可。

时间复杂度 $O(2^nhwn)$ 无法通过。考虑先离散化，时间复杂度 $O(2^nn^3)$，可以通过。

```cpp
#include<bits/stdc++.h>
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define per(i,r,l) for(int i=(r);i>=(l);i--)
#define repll(i,l,r) for(ll i=(l);i<=(r);i++)
#define perll(i,r,l) for(ll i=(r);i>=(l);i--)
#define pb push_back
#define ins insert
#define clr clear
using namespace std;
namespace ax_by_c{
typedef long long ll;
const ll mod=1e9+7;
const int N=30;
const int S=(1<<10)+5;
int n,m,h,k;
int xl[N],xr[N],yl[N],yr[N],xx[N];
int hx[N],cx,hy[N],cy;
int msk,pct[S];
int lim[N][N];
ll ksm(ll a,ll b,ll p){
	a=a%p;
	ll r=1;
	while(b){
		if(b&1)r=r*a%p;
		a=a*a%p;
		b>>=1;
	}
	return r%p;
}
ll F(int s){
	rep(i,1,cx)rep(j,1,cy)lim[i][j]=h;
	rep(i,1,k)
	if(s&(1<<(i-1))){
		rep(x,xl[i],xr[i])rep(y,yl[i],yr[i])lim[x][y]=min(lim[x][y],xx[i]-1);
	}
	else{
		rep(x,xl[i],xr[i])rep(y,yl[i],yr[i])lim[x][y]=min(lim[x][y],xx[i]);
	}
	ll ans=1;
	rep(i,1,cx-1)rep(j,1,cy-1)ans=ans*ksm(lim[i][j],(hx[i+1]-hx[i])*(hy[j+1]-hy[j]),mod)%mod;
	return ans;
}
void slv(){
	scanf("%d %d %d %d",&n,&m,&h,&k);
	rep(i,1,k)scanf("%d %d %d %d %d",&xl[i],&yl[i],&xr[i],&yr[i],&xx[i]);
	cx=0;
	hx[++cx]=1,hx[++cx]=n+1;
	rep(i,1,k)hx[++cx]=xl[i],hx[++cx]=xr[i]+1;
	sort(hx+1,hx+1+cx),cx=unique(hx+1,hx+1+cx)-hx-1;
	rep(i,1,k)xl[i]=lower_bound(hx+1,hx+1+cx,xl[i])-hx,xr[i]=lower_bound(hx+1,hx+1+cx,xr[i]+1)-hx-1;
	cy=0;
	hy[++cy]=1,hy[++cy]=m+1;
	rep(i,1,k)hy[++cy]=yl[i],hy[++cy]=yr[i]+1;
	sort(hy+1,hy+1+cy),cy=unique(hy+1,hy+1+cy)-hy-1;
	rep(i,1,k)yl[i]=lower_bound(hy+1,hy+1+cy,yl[i])-hy,yr[i]=lower_bound(hy+1,hy+1+cy,yr[i]+1)-hy-1;
	msk=(1<<k)-1;
	rep(i,0,msk)pct[i]=pct[i>>1]+(i&1);
	ll ans=0;
	rep(i,0,msk){
		if(pct[i]%2)ans=(ans-F(i)+mod)%mod;
		else ans=(ans+F(i))%mod;
	}
	printf("%lld\n",ans);
}
void main(){
	int T=1;
	scanf("%d",&T);
	while(T--)slv();
}
}
int main(){
	string __name="";
	if(__name!=""){
		freopen((__name+".in").c_str(),"r",stdin);
		freopen((__name+".out").c_str(),"w",stdout);
	}
	ax_by_c::main();
	return 0;
}
```

---

## 作者：船酱魔王 (赞：1)

# P3813 [FJOI2017] 矩阵填数 题解

## 题意回顾

$ h \times w $ 的矩阵，每个位置可以填数 $ [1,m] $，$ n $ 个限制条件形如一个子矩阵的最大值，求出在这些限制下矩阵的元素填写方案和。

$ 1 \le n \le 10 $，$ 1 \le h,w,m \le 10^4 $，$ 1 \le T \le 5 $。

## 分析

显然最大值不好搞，因为 $ n $ 很小，考虑和 $ n $ 相关的指数算法。

考虑容斥原理，钦定每个子矩阵上限（区分于最大值，可以所有值都取不到上限）是最大值还是最大值减去 $ 1 $，乘法原理即可。

此时我们需要将上限覆盖到每个子矩阵上，关于 $ h \times w $ 成线性以上的复杂度都过不去，发现 $ n $ 很小因此可以直接离散化，然后用快速幂即可在 $ O(n^3) $ 时间内处理完每一种上限情况。

故本题时间复杂度为 $ O(2^nn^3) $。

注意离散化时不能忽略掉边框未被任何子矩阵覆盖的部分，如果离散化写得比较不好的话需要特判一下边框大小。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <map>
using namespace std;
const int mod = 1e9 + 7;
const int N = 25;
int T;
int h, w, m, n;
int tx[N * 2];
int ty[N * 2];
int xa[N];
int ya[N];
int xb[N];
int yb[N];
int xxa[N];
int yya[N];
int xxb[N];
int yyb[N];
int v[N];
map<int, int> mpx, mpy;
int mat[N * 2][N * 2];
int val[N * 2][N * 2];
void modify(int xc, int yc, int xd, int yd, int vl, int bl) {
    for(int i = xc; i <= xd; i++) {
        for(int j = yc; j <= yd; j++) {
            mat[i][j] = (bl == 2) ? vl : min(mat[i][j], vl);
        }
    }
}
int ksm(int x, int y) {
    int ans = 1;
    int mul = x;
    while(y) {
        if(y & 1) ans = (long long)ans * mul % mod;
        mul = (long long)mul * mul % mod, y >>= 1;
    }
    return ans;
}
int main() {
    scanf("%d", &T);
    for(int ti = 1; ti <= T; ti++) {
        scanf("%d%d%d%d", &h, &w, &m, &n);
        mpx.clear(), mpy.clear();
        for(int i = 1; i <= n; i++) {
            scanf("%d%d%d%d%d", &xa[i], &ya[i], &xb[i], &yb[i], &v[i]);
            tx[2 * i - 1] = xa[i] - 1, tx[2 * i] = xb[i];
            ty[2 * i - 1] = ya[i] - 1, ty[2 * i] = yb[i];
        }
        //(a,b]
        sort(tx + 1, tx + 2 * n + 1);
        sort(ty + 1, ty + 2 * n + 1);
        for(int i = 1; i <= 2 * n; i++) mpx[tx[i]] = i, mpy[ty[i]] = i;
        for(int i = 2; i <= 2 * n; i++) {
            for(int j = 2; j <= 2 * n; j++) val[i][j] = (tx[i] - tx[i - 1]) * (ty[j] - ty[j - 1]);
        }
        int rp = (long long)(tx[2 * n] - tx[1]) * (ty[2 * n] - ty[1]);
        for(int qi = 1; qi <= n; qi++) {
            xxa[qi] = mpx[xa[qi] - 1] + 1;
            yya[qi] = mpy[ya[qi] - 1] + 1;
            xxb[qi] = mpx[xb[qi]];
            yyb[qi] = mpy[yb[qi]];
        }
        int ans = 0;
        for(int st = 0; st < (1 << n); st++) {
            modify(2, 2, 2 * n, 2 * n, m, 2);
            for(int i = 0; i < n; i++) {
                if((1 << i) & st) modify(xxa[i + 1], yya[i + 1], xxb[i + 1], yyb[i + 1], v[i + 1] - 1, 1);
                else modify(xxa[i + 1], yya[i + 1], xxb[i + 1], yyb[i + 1], v[i + 1], 1);
            }
            int now = 1;
            for(int i = 2; i <= 2 * n; i++) {
                for(int j = 2; j <= 2 * n; j++) {
                    now = (long long)now * ksm(mat[i][j], val[i][j]) % mod;
                }
            }
            int popcst = 0;
            int sst = st;
            while(sst) sst = (sst - 1) & sst, popcst++;
            if(popcst % 2 == 0) ans = (ans + now) % mod;
            else ans = (ans - now + mod) % mod;
        }
        printf("%lld\n", (long long)ans * ksm(m, h * w - rp) % mod);
    }
    return 0;
}
```

---

## 作者：Fzrcy (赞：1)

显然答案为所有子矩阵的最大值**小于等于** $v_i$ 的方案数减去**存在**一个子矩阵的最大值**小于** $v_i$ 的方案数。

存在一个子矩阵的最大值**小于** $v_i$ 的方案数显然要用容斥来计算，直接 $O(2^n)$ 枚举有哪些子矩阵的最大值**小于等于** $v_i$，否则子矩阵的最大值**小于** $v_i$，然后我们可以 $O(nHW)$ 统计方案数，然后对横纵坐标离散化一下，可以优化到 $O(n^3+n^2\log n)$ 的复杂度统计方案数（$\log$ 是快速幂的复杂度）。

总时间复杂度为 $O(2^n(n^3+n^2\log n))$。

```cpp
// qwq
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
constexpr ll mo=1e9+7;
ll ksm(ll x,ll y){
	ll cur=1;
	for(;y;y>>=1,x=x*x%mo)
		if(y&1)cur=cur*x%mo;
	return cur;
}
ll W,H,n,a[30][30],m,X[30],Y[30],cx,cy;
struct Add{ll x,y,l,r,v;}mat[30];
void solve(){
	cin>>H>>W>>m>>n;
	for(int i=1;i<=n;i++)
		cin>>mat[i].x>>mat[i].l>>
		mat[i].y>>mat[i].r>>mat[i].v;
	cx=cy=0;
	X[++cx]=1,Y[++cy]=1;
	X[++cx]=H+1,Y[++cy]=W+1;
	for(int i=1;i<=n;i++)
		X[++cx]=mat[i].x,X[++cx]=mat[i].y+1,
		Y[++cy]=mat[i].l,Y[++cy]=mat[i].r+1;
	sort(X+1,X+cx+1),sort(Y+1,Y+cy+1);
	cx=unique(X+1,X+cx+1)-X-1;
	cy=unique(Y+1,Y+cy+1)-Y-1;
	cx--,cy--;
	ll ans=0;
	for(int S=0;S<(1<<n);S++){
		for(int i=1;i<=cx;i++)
			for(int j=1;j<=cy;j++)
				a[i][j]=m;
		ll tmp=1,ci=0;
		for(int s=1;s<=n;s++){
			ll t=mat[s].v-((S>>(s-1))&1);ci+=((S>>(s-1))&1);
			int l=lower_bound(X+1,X+cx+1,mat[s].x)-X,r=lower_bound(X+1,X+cx+1,mat[s].y+1)-X-1;
			int x=lower_bound(Y+1,Y+cy+1,mat[s].l)-Y,y=lower_bound(Y+1,Y+cy+1,mat[s].r+1)-Y-1;
			for(int i=l;i<=r;i++)for(int j=x;j<=y;j++)a[i][j]=min(a[i][j],t);
		}
		for(int i=1;i<=cx;i++)for(int j=1;j<=cy;j++){
			ll l1=X[i+1]-X[i],l2=Y[j+1]-Y[j];
			tmp=(tmp*ksm(a[i][j],l1*l2))%mo;
		}
		ans=(ans+((ci&1)?mo-1ll:1ll)*tmp%mo)%mo;
		// cout<<tmp<<'\n';
	}
	cout<<ans<<'\n';
	return;
}
int main(){
	ll t; cin>>t;
	while(t--)solve();
	return 0;
}
```

---

## 作者：ダ月 (赞：1)

### 题意概要：

给定一个 $h\times w$ 的矩阵，每个点可以填 $[1,m]$ 间的一个正整数，并且要求满足 $n$ 个子矩阵内的最大值**分别**为 $w_i$。

### 题目分析：

这个最大值为 $w_i$ 的限制条件直接做不好做，我们可以考虑容斥，即我们统计这个子矩阵内 $\max\le w_i$ 的方案数 $x$，然后统计 $\max<w_i$ 的方案数 $y$，$x-y$ 就是这个子矩阵内 $\max=w_i$ 的方案数。

接下来考虑多个子矩阵，我们只需要将子矩阵按权值大小从小到大加入这个矩阵，然后统计答案就行，包括没有任何限制的部分。由于可能从在两个限制条件 $P_1$，$P_2$，满足他们限制的 $w_1,w_2$ 相同，在考虑 $w$ 减不减 $1$ 的时候，$P_1,P_2$ 的加入顺序会发生改变。所以我们要考虑容斥，$f(A)$ 为在满足 $A$ 条件下，矩阵的方案数。 即 $f(\max\le w_1 \cap\max\le w_2)-f(\max <w_1\cap \max\le w_2)-f(\max \le w_1\cap \max<w_2)+f(\max<w_1\cap\max<w_2)$。

扩展到多个限制条件同理。

具体操作就是将矩阵离散化，支持矩形的区间覆盖，区间查询。当然，由于 $n$ 非常小，我们只需要暴力即可。

时间复杂度：$O(n^22^{n})$。

### 代码如下：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pd push_back
#define all(x) x.begin(),x.end()
#define Clear(x,n) for(int i=0;i<=n;i++)x[i]=0;
#define LB lower_bound
//==============================================================================
ll QP(ll x,ll y,ll mod){ll ans=1;for(;y;y>>=1,x=x*x%mod)if(y&1)ans=ans*x%mod;return ans;}
//==============================================================================
namespace IO{
	int readInt(){
		int x=0,y=0;char c=0;
		while(!isdigit(c))y|=c=='-',c=getchar();
		while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
		return !y?x:-x;
	}
	void write(int x){if(!x)return;write(x/10);putchar(x%10+'0');}
	void Output(int x){if(x<0)putchar('-'),x=-x;if(!x)putchar('0');else write(x);}
	void WL(int x){Output(x);putchar('\n');}
	void WS(int x){Output(x);putchar(' ');}
}
namespace Debug{
	void DeVec(vector<int> c){for(auto y:c)printf("%d ",y);puts("");}
	void DeNum(int x){printf("%d\n",x);}
}
//==============================================================================
const int N=20+10;
ll T;
const int mod=1e9+7;
ll n,m,p,q;
ll s[N][N];
bool vis[N][N];
struct node{ll x1,y1,x2,y2,w;}a[20];
bool cmp(const node &x,const node &y){return x.w<y.w;}
int pop_count(int x){int ans=0;for(;x;x>>=1)ans+=x&1;return ans;}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
    cin.tie(nullptr);
	cin>>T;
	while(T--){
		cin>>n>>m>>p>>q;
		for(int i=1;i<=q;i++)cin>>a[i].x1>>a[i].y1>>a[i].x2>>a[i].y2>>a[i].w;
		for(int i=1;i<=q;i++)a[i].x2++,a[i].y2++;
		vector<ll> v1,v2;v1.pd(1);v1.pd(n+1);v2.pd(1);v2.pd(n+1);
		for(int i=1;i<=q;i++)v1.pd(a[i].x1),v2.pd(a[i].y1),v1.pd(a[i].x2),v2.pd(a[i].y2);
		sort(all(v1));sort(all(v2));v1.erase(unique(all(v1)),v1.end());v2.erase(unique(all(v2)),v2.end());
		for(int i=1;i<=q;i++)a[i].x1=LB(all(v1),a[i].x1)-v1.begin()+1,a[i].y1=LB(all(v2),a[i].y1)-v2.begin()+1,
							 a[i].x2=LB(all(v1),a[i].x2)-v1.begin()+1,a[i].y2=LB(all(v2),a[i].y2)-v2.begin()+1;
		for(int i=0;i<v1.size()-1;i++)
			for(int j=0;j<v2.size()-1;j++)
				s[i+1][j+1]=(v1[i+1]-v1[i])*(v2[j+1]-v2[j]);
		ll ans=0;
		for(int S=0;S<(1<<q);S++){
			vector<node> v;
			for(int i=1;i<=q;i++){
				v.pd(a[i]);
				if(S>>(i-1)&1)v[i-1].w--;
			}sort(v.begin(),v.end(),cmp);
			ll rs=1;
			for(int i=1;i<v1.size();i++)
				for(int j=1;j<v2.size();j++)
					vis[i][j]=false;
			for(auto k:v){
				ll t=0;
				for(int i=k.x1;i<k.x2;i++)
					for(int j=k.y1;j<k.y2;j++)
						if(!vis[i][j])
							vis[i][j]=true,
							t=(s[i][j]+t)%(mod-1);
				rs=rs*QP(k.w,t,mod)%mod;
			}for(int i=1;i<v1.size();i++)
				for(int j=1;j<v2.size();j++)
					if(!vis[i][j])
						rs=rs*QP(p,s[i][j],mod)%mod;
			ans=(ans+(pop_count(S)&1?(-1):(1))*rsod;
		}printf("%lld\n",(ans+mod)%mod);
	}
}


```


---

## 作者：翼德天尊 (赞：1)

> $h\times w$ 的矩阵，每个格子可以填 $1\sim m$ 中的一个数。$n$ 个限制，每条限制要求某个子矩阵的最大值为 $v$。求满足所有限制的填数方案数。
>
> $1\le h,w,m\le 10^4$，$1\le n\le 10$，$1\le v\le m$。 

考虑 $n$ 很小，所以其实矩阵中的关键点不多，离散化之后完全可以暴力扫描整个矩阵来做。

但发现问题在于，类似「某个子矩阵最大值必须为 $v$」这样的约束并不好做，因为约束最大值为 $v$ 就意味着该子矩阵中的所有值都 $\le v$，且至少有一个值为 $v$。

发现后者的限制是很不平凡的。

于是正难则反，考虑将这样的约束容斥做。 

具体地，不妨将所有值的上界作为全集，「至少有一个值为 $v$ 」这样的限制作为属性，将求解交集转化为求解补集的并集，则「至少有一个值为 $v$」这样的属性就被我们转化为了更好求解的 「所有值都小于 $v$」，于是套用容斥求并集的做法即可。

时间复杂度 $O(n^32^n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=105;
const int mod=1e9+7;
int t,h,w,m,n,lshx[N],ltotx,lshy[N],ltoty;
struct node{
    int ax,ay,bx,by,v;
}p[N];
int read(){
    int w=0,f=1;
    char ch=getchar();
    while (ch>'9'||ch<'0') {
        if (ch=='-') f=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9') {
        w=(w<<3)+(w<<1)+(ch^48);
        ch=getchar();
    }
    return w*f;
}
int coun(int x){
    int y=0;
    while (x){
        if (x&1) ++y;
        x>>=1;
    }
    return y;
}
ll ksm(ll x,ll y){
    ll ans=1;
    while (y){
        if (y&1) ans=ans*x%mod;
        x=x*x%mod;
        y>>=1;
    }
    return ans;
}
int main(){
#ifndef ONLINE_JUDGE
    freopen("in.in","r",stdin);
#endif
    t=read();
    while (t--){
        h=read(),w=read(),m=read(),n=read(),ltotx=ltoty=0;
        for (int i=1;i<=n;i++){
            lshx[++ltotx]=p[i].ax=read(),lshy[++ltoty]=p[i].ay=read(),lshx[++ltotx]=p[i].bx=read()+1,lshy[++ltoty]=p[i].by=read()+1,p[i].v=read();
        }
        lshx[++ltotx]=1,lshx[++ltotx]=h+1,lshy[++ltoty]=1,lshy[++ltoty]=w+1;
        sort(lshx+1,lshx+1+ltotx);
        ltotx=unique(lshx+1,lshx+1+ltotx)-lshx-1;
        sort(lshy+1,lshy+1+ltoty);
        ltoty=unique(lshy+1,lshy+1+ltoty)-lshy-1;
        for (int i=1;i<=n;i++)
            p[i].ax=lower_bound(lshx+1,lshx+1+ltotx,p[i].ax)-lshx,
            p[i].ay=lower_bound(lshy+1,lshy+1+ltoty,p[i].ay)-lshy,
            p[i].bx=lower_bound(lshx+1,lshx+1+ltotx,p[i].bx)-lshx,
            p[i].by=lower_bound(lshy+1,lshy+1+ltoty,p[i].by)-lshy;
        // for (int i=1;i<=ltotx;i++) cout<<lshx[i]<<"\n";
        // for (int i=1;i<=ltoty;i++) cout<<lshy[i]<<"\n";
        ll ans=0;
        for (int i=0;i<(1<<n);i++){
            int x=coun(i),f=(x&1)?-1:1;
            ll num=1;
            for (int b=1;b<=n;b++)
                if (i&(1<<b-1)) p[b].v--;
            for (int j=1;j<ltotx;j++){
                for (int k=1;k<ltoty;k++){
                    int g=(lshx[j+1]-lshx[j])*(lshy[k+1]-lshy[k]),maxn=m;
                    for (int s=1;s<=n;s++)
                        if (p[s].ax<=j&&j<p[s].bx&&p[s].ay<=k&&k<p[s].by) maxn=min(maxn,p[s].v);
                    num=num*ksm(maxn,g)%mod;
                    //cout<<num<<"\n";
                }
            }
            for (int b=1;b<=n;b++)
                if (i&(1<<b-1)) p[b].v++;
            ans=(ans+num*f)%mod;
        }
        cout<<(ans+mod)%mod<<"\n";
    }
    return 0;
}
```

---

## 作者：bigbigdoggy (赞：1)


## 看前请确保已经深思熟虑，然后食用


##### 解析
显然我们想到了状压DP，令 f[i][j] 表示做到了第i个块状态为j的方案，j表示哪些块满足限制。

注意，由于子矩阵限制可能会重叠，所以我们先预处理，将矩阵分为若干个小块，每个小块中仅有一个限制条件（显然就是所有覆盖条件中最小的一个）。

然后我们记 Val 表示这一块里面的限制值，Num 表示这一块的个数，然后我们再记个 op 表示覆盖哪些块的限制值为Val。

之后用状压DP，考虑第 i 块是否取限制值，取则方案数为 (Val - 1) ^ Num，不取则方案数为 Val ^ Num - (Val - 1) ^ Num。

当取限制值时，把对应方案数转移到 f[i + 1][j | op[i + 1]]，否则转移到 f[i + 1][j]。最后答案就是 f[cnt][all] 了

------------


```cpp
#include <bits/stdc++.h>//万能头QwQ
using namespace std;
typedef long long ll;
const int MOD=1e9+7;
int T;
int h,w,m,n,all;
int qx[1001],x,qy[1001],y;
int Num[1001],Val[1001],op[1001],cnt;
int f[1001][3001]= {0};
struct power
{
	int x1,y1;
	int x2,y2;
	int val;
} a[1001];
int get()
{
	int res=1,Q=1;
	char c;
	while((c=getchar())<48 || c>57 )//转化ing
	{
		if(c=='-')Q=-1;
	}
	res=c-48;
	while((c=getchar())>=48 && c<=57 )
	{
		res=res*10+c-48;
	}
	return res*Q;
}

ll Quick(ll a,int b)
{
	ll res=1;
	while(b)
	{
		if(b&1) res=res*a%MOD;
		a=(ll)a*a%MOD;
		b>>=1;
	}
	return res;
}

void Deal_first()
{
	sort(qx+1,qx+x+1);
	x=unique(qx+1,qx+x+1)-qx-1;
	sort(qy+1,qy+y+1);
	y=unique(qy+1,qy+y+1)-qy-1;
	cnt=0;
	for(int i=2; i<=x; i++)
		for(int j=2; j<=y; j++)
		{
			int lenx=qx[i]-qx[i-1];
			int leny=qy[j]-qy[j-1];
			Num[++cnt]=lenx*leny;
			Val[cnt]=m;
			op[cnt]=0;

			for(int l=1; l<=n; l++)
				if(a[l].x1<=qx[i-1] && qx[i]<=a[l].x2 && a[l].y1<=qy[j-1] && qy[j]<=a[l].y2)
					Val[cnt]=min(Val[cnt],a[l].val);

			for(int l=1; l<=n; l++)
				if(a[l].val==Val[cnt])
					if(a[l].x1<=qx[i-1] && qx[i]<=a[l].x2 && a[l].y1<=qy[j-1] && qy[j]<=a[l].y2)
						op[cnt]|=(1<<l-1);
		}
}

void Deal()
{
	memset(f,0,sizeof(f));
	f[0][0]=1;

	for(int i=0; i<=cnt-1; i++)
	{
		for(int opt=0; opt<=all; opt++)
		{
			if(f[i][opt])
			{
				f[i+1][opt|op[i+1]] = (f[i+1][opt|op[i+1]] + (ll)f[i][opt]*(ll)(Quick(Val[i+1],Num[i+1]
                                -Quick(Val[i+1]-1,Num[i+1]) + MOD) % MOD) % MOD;
				f[i+1][opt] = (f[i+1][opt] + (ll)f[i][opt]*Quick(Val[i+1]-1,Num[i+1]) % MOD) % MOD;

			}
		}
	}
}
int main()
{
	T=get();
	while(T--)
	{
		h=get();
		w=get();
		m=get();
		n=get();
		all=(1<<n)-1;
		x=y=0;
		for(int i=1; i<=n; i++)
		{
			a[i].x1=get();
			a[i].y1=get();
			a[i].x2=get();
			a[i].y2=get();
			a[i].x1--;
			a[i].y1--;
			a[i].val=get();
			qx[++x]=a[i].x1;
			qx[++x]=a[i].x2;
			qy[++y]=a[i].y1;
			qy[++y]=a[i].y2;
		}
		qx[++x]=0;
		qx[++x]=h;
		qy[++y]=0;
		qy[++y]=w;
		Deal_first();
		Deal();
		printf("%d\n",f[cnt][all]);
	}
    return 0；//完美收官
}
```


[原网址](https://www.cnblogs.com/BearChild/p/7530456.html)，已过，请放心食用

---

## 作者：C20203030 (赞：1)


### 一、题目

[点此看题](https://www.luogu.org/problem/P3813)

### 二、解法

观察数组范围，发现$h,w$特别大，而限制只有至多$10$条，我们考虑**离散化**。

怎么个离散化法呢？考虑将每一个限制的四个边延长，这样就将大矩形切割成了至多$20\times 20$个小矩形，且这些小矩形的性质是一样的（被哪些限制包含）。
具体的离散化操作我们把它当做切木棍，对于$[l,r]$，我们这样离散化：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191028125824268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0MyMDIwNDR6eHk=,size_16,color_FFFFFF,t_70)

也就是我们把$l，r$各切一刀，在$l$加上一个左括号，$l-1$加上一个右括号，$r$加上一个左括号，$r+1$加上一个右括号，离散化就变成了括号匹配问题，排序后匹配相邻的括号即可。

离散化后，我们发现每个限制中只要中只要有一个小矩形满足限制就可以了，由于限制数很小，考虑状态压缩，设$dp[i][s]$为前$i$个小矩形满足状压后为$s$的条件的方案数，我们先考虑每一个小矩形：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191027132133106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0MyMDIwNDR6eHk=,size_16,color_FFFFFF,t_70)

中间的那个小矩形被两个限制所包含，但是我们只能满足要求最大值为$3$的限制，所以我们记小矩形的状态为$10$（二进制），$dp$时拿原状态或上小矩形的状态就可以得到目标状态。我们再记$g[i]=(Min-1)^s$（$s$为小矩形的面积），即无法满足任何一个限制的情况，$f[i]=Min^{s}-g[i]$为能满足最大值最小的限制的情况（我们也只能满足这些限制），那样我们就能写出如下$dp$方程（记小矩形状态为$S$）：

$\begin{cases}
dp[i][j|S]=dp[i-1][j]\times f[i] \\
dp[i][j]=dp[i-1][j]\times g[i]
\end{cases}$

最后输出$dp[m][2^n-1]$即可（$m$是小矩形的个数），时间复杂度$O(4n^{2}\times 2^n)$。


```cpp
#include <cstdio>
#include <vector>
#include <cstring>
#include <algorithm>
using namespace std;
#define int long long
const int MOD = 1e9+7;

const int MAXN = 10005;
int read()
{
	int x=0,flag=1;char c;
	while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
	while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*flag;
}
int T,h,w,m,n,cnt,oth,dp[505][1<<10];
int x1[MAXN],y1[MAXN],x2[MAXN],y2[MAXN],v[MAXN];
bool vx[MAXN][2],vy[MAXN][2];
vector<pair<int,int> > x,y;
struct node
{
    int f,g,s;
}a[505];
void add(int z,bool d,bool type)
{
    if(!type) x.push_back(make_pair(z,d)),vx[z][d]=1;
    else y.push_back(make_pair(z,d)),vy[z][d]=1;
}
int qkpow(int a,int b)
{
    int res=1;
    while(b>0)
    {
        if(b&1) res=res*a%MOD;
        a=a*a%MOD;
        b>>=1;
    }
    return res;
}
signed main()
{
    T=read();
    while(T--)
    {
        h=read();w=read();m=read();n=read();
        cnt=oth=0;
        memset(vx,0,sizeof vx);
        memset(vy,0,sizeof vy);
        memset(dp,0,sizeof dp);
        x.clear();y.clear();
        add(1,0,0);add(h,1,0);
        add(1,0,1);add(w,1,1);
        for(int i=1;i<=n;i++)
        {
            x1[i]=read();y1[i]=read();x2[i]=read();y2[i]=read();v[i]=read();
            if(x1[i]>1 && !vx[x1[i]-1][1])
                add(x1[i]-1,1,0);
            if(!vx[x1[i]][0])
                add(x1[i],0,0);
            if(x2[i]<h && !vx[x2[i]+1][0])
                add(x2[i]+1,0,0);
            if(!vx[x2[i]][1])
                add(x2[i],1,0);
            if(y1[i]>1 && !vy[y1[i]-1][1])
                add(y1[i]-1,1,1);
            if(!vy[y1[i]][0])
                add(y1[i],0,1);
            if(y2[i]<w && !vy[y2[i]+1][0])
                add(y2[i]+1,0,1);
            if(!vy[y2[i]][1])
                add(y2[i],1,1);
        }
        sort(x.begin(),x.end());
        sort(y.begin(),y.end());
        for(int i=0;i<x.size();i+=2)
            for(int j=0;j<y.size();j+=2)
            {
                int a1=x[i].first,a2=x[i+1].first;
                int b1=y[j].first,b2=y[j+1].first;
                int siz=(a2-a1+1)*(b2-b1+1),s=0,Min=m;
                for(int k=1;k<=n;k++)
                {
                    if(a1>=x1[k] && a2<=x2[k] && b1>=y1[k] && b2<=y2[k])
                    {
                        if(Min>v[k])
                        {
                            Min=v[k];
                            s=0;
                        }
                        if(Min==v[k]) s|=(1<<k-1);
                    }
                }
                int g=qkpow(Min-1,siz),f=qkpow(Min,siz)-g;
                if(!s) oth+=siz;
                else  a[++cnt]=node{f,g,s};
            }
        dp[0][0]=1;
        for(int i=1;i<=cnt;i++)
        {
            for(int j=0;j<(1<<n);j++)
                dp[i][j|a[i].s]=(dp[i][j|a[i].s]+dp[i-1][j]*a[i].f)%MOD;
            for(int j=0;j<(1<<n);j++)
                dp[i][j]=(dp[i][j]+dp[i-1][j]*a[i].g)%MOD;
        }
        printf("%d\n",(dp[cnt][(1<<n)-1]*qkpow(m,oth)%MOD+MOD)%MOD);
    }
}

```


---

## 作者：zifanwang (赞：0)

考虑容斥，枚举哪些矩阵中的数 $<v$（个数为 $c$），哪些 $\le v$，则系数为 $(-1)^c$。

考虑将矩阵离散化为 $\mathcal O(n^2)$ 个块，对于每个子矩阵枚举覆盖的块，更新最大值，最后答案便是 $\sum_{T\sub S}(-1)^{|T|}\prod_{block}\max_{block}^{size_{block}}$。

参考代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define md 1000000007
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define rept(i,a,b) for(int i=(a);i<(b);++i)
#define drep(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
int T,h,w,m,n,t1,t2,d1[23],d2[23],f[23][23];
ll ans;
struct node{
	int x1,y1,x2,y2,c;
	inline void in(){
		scanf("%d%d%d%d%d",&x1,&y1,&x2,&y2,&c);
		d1[++t1]=x1,d1[++t1]=x2+1;
		d2[++t2]=y1,d2[++t2]=y2+1;
	}
}a[12];
ll power(ll x,int y){
	ll ans=1;
	for(;y;y>>=1){
		if(y&1)ans=ans*x%md;
		x=x*x%md;
	}
	return ans;
}
ll solve(int s){
	rept(i,1,t1)rept(j,1,t2)f[i][j]=m;
	rept(i,0,n){
		int c=((s>>i)&1)?a[i].c-1:a[i].c;
		int x1=lower_bound(d1+1,d1+t1+1,a[i].x1)-d1,x2=lower_bound(d1+1,d1+t1+1,a[i].x2+1)-d1;
		int y1=lower_bound(d2+1,d2+t2+1,a[i].y1)-d2,y2=lower_bound(d2+1,d2+t2+1,a[i].y2+1)-d2;
		rept(x,x1,x2)rept(y,y1,y2)f[x][y]=min(f[x][y],c);
	}
	ll ans=1;
	rept(i,1,t1)rept(j,1,t2){
		ans=ans*power(f[i][j],(d1[i+1]-d1[i])*(d2[j+1]-d2[j]))%md;
	}
	return ans;
}
signed main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d%d%d",&h,&w,&m,&n);
		t1=t2=2,d1[1]=d2[1]=1,d1[2]=h+1,d2[2]=w+1;
		rept(i,0,n)a[i].in();
		sort(d1+1,d1+t1+1);t1=unique(d1+1,d1+t1+1)-d1-1;
		sort(d2+1,d2+t2+1);t2=unique(d2+1,d2+t2+1)-d2-1;
		ans=0;
		rept(s,0,1<<n){
			if(__builtin_popcount(s)&1)ans=(ans-solve(s))%md;
			else ans=(ans+solve(s))%md;
		}
		cout<<(ans+md)%md<<'\n';
	}
	return 0;
}
```

---


# [TJOI2007] 足彩投注

## 题目背景

了解足球彩票的人可能知道，足球彩票中有一种游戏叫做“胜负彩”，意为猜比赛的胜负。下面是一些与胜负彩有关的术语：

注：**每一**组有效组合数据。

投注：彩民以现金购买足球彩票的行为。

单式投注：彩民对于所有球队的比赛成绩均只选择一种预测结果的投注方式。投注的数量（注数）为1。

复式投注：彩民对于某些场次的比赛成绩选择两种以上的预测结果的投注方式。投注的数量为复式投注的组合数。例如，某彩民对一场比赛预测了两个结果（例如胜平），另一场比赛预测了三个结果（胜负平），其他比赛都只预测了一种结果，那么注数就是 $2\times 3=6$。**这样的一个复式投注，可以看成一个包含六种单式投注的集合。**


胜负彩的玩法一般是这样的。彩票机构指定一轮比赛中的若干场，让彩民去猜每场比赛的结果（胜负平）。根据彩民猜中比赛的场次，来确定中奖的额度

## 题目描述

我们现在考虑一个简化的模型。对于一轮比赛，彩民需要竞猜其中 $n$ 场比赛的结果，每场比赛的胜负平都有一个概率 $p(i, r)$ 。其中，$i$ 表示第 $i$ 场比赛。$r\in \{0,1,2\}$，分别表示主队比赛结果的负、平、胜。$p(i, r)$ 则表示第i场比赛、结果为r的概率。此外，还有一个概率 $q(i, r)$，表示第 $i$ 场比赛，投注购买结果为 $r$ 的概率，**即总注数中购买该场次某一比赛结果的概率**。


例如，如果 $q(1,0) = 0.5$，我们可以知道第一场比赛有 $50\%$ 的投注会买主队输球。我们假设这 $n$ 场比赛互不相关，即 $p(i, r)$ 的结果不会受 $p(j, r’)$ 的影响，$q(i, r)$ 的结果也不会受 $q(j, r’)$ 的影响（$r \ne r’$）。


在这个模型里，我们规定，必须猜中全部 $n$ 场比赛的结果才能获奖。总奖金为 $M$，由所有获奖的投注平分。因此，对于一个单式投注 $R_i = \{r_{i1}, r_{i2}, \ldots ,r_{in}\}$，$r_{ij}$ 表示投注 $R_i$对第j场比赛的预测结果，它的中奖概率为：

$$
P(R_i)=\prod\limits_{j=1}^np(j,r_{ij})
$$
设投注总数为 $N$，那么中奖的投注总数为：

$$
N\cdot Q(R_i)=N\cdot\prod\limits_{j=1}^nq(j,r_{ij})
$$
于是，投注 $R_i$ 所能得到的奖金的期望（平均意义下能够获得的奖金数）就是：

$$
\dfrac{M}{N\cdot Q(R_i)} \cdot P(R_i)
$$
以上考虑的仅仅是单式投注的情况，即仅考虑单注 $R_i$ 的中奖情况。对于复式投注，情况要复杂一些。采用复式投注时，投注的是一个集合 $R = \{R1, R2, …, Rk\}$，其中k是投注的数量。例如，三场比赛，第一场猜“胜负”，第二场猜“平”，第三场猜“负平”，则 $k = 4$，$R$ 集合所包含的四个元素如下如下：

|       | $r_{i1}$ | $r_{i2}$ | $r_{i3}$ |
| ----- | -------- | -------- | -------- |
| $R_1$ | 0        | 1        | 0        |
| $R_2$ | 0        | 1        | 1        |
| $R_3$ | 2        | 1        | 0        |
| $R_4$ | 2        | 1        | 1        |

复式投注R中，只要有一个 $Ri$ 猜对所有比赛结果，即可中奖。因此，复式投注R所能获得的奖金的期望就是：

$$
\sum_{R_i\in R}\dfrac{M}{N\cdot Q(R_i)} \cdot P(R_i)
$$

我们的问题是，给定 $n$ 场比赛的信息（胜负平的概率和彩民购买三种结果的概率），以及复式投注中可以购买的最大注数 $U$，要求设计一种复式投注的方案，在不超过最大注数（复式投注的注数 $k \le U$）的前提下，使得获得奖金的期望最大。

## 样例 #1

### 输入

```
1 10 10 1
0.3 0.2 0.5 0.7 0.2 0.1```

### 输出

```
1.609```

# 题解

## 作者：Anita_Hailey (赞：3)

# 足彩投注

## 题目概述

**题目背景**

了解足球彩票的人可能知道，足球彩票中有一种游戏叫做“胜负彩”，意为猜比赛的胜负。下面是一些与胜负彩有关的术语

注      ：每一组有效组合数据。

投    注：彩民以现金购买足球彩票的行为。

单式投注：彩民对于所有球队的比赛成绩均只选择一种预测结果的投注方式。投注的数量（注数）为1。

复式投注：彩民对于某些场次的比赛成绩选择两种以上的预测结果的投注方式。投注的数量为复式投注的组合数。例如，某彩民对一场比赛预测了两个结果（例如，胜平），           另一场比赛预测了三个结果（胜负平），其他比赛都只预测了一种结果，那么注数就是2×3 = 6。这样的一个复式投注，可以看成一个包含六种单式投注的集合。

胜负彩的玩法一般是这样的。彩票机构指定一轮比赛中的若干场，让彩民去猜每场比赛的结果（胜、负、平）。根据彩民猜中比赛的场次，来确定中奖的额度。

**题目描述**

我们现在考虑一个简化的模型。对于一轮比赛，彩民需要竞猜其中$n$场比赛的结果，每场比赛的胜负平都有一个概率$p(i, r)$。其中，$i$表示第i场比赛,$r$ = 0, 1, 2，分别表示比赛结果的（主队）负、平、胜。$p(i, r)$则表示第$i$场比赛、结果为$r$的概率。此外，还有一个概率$q(i, r)$，表示第i场比赛，投注购买结果为$r$的概率。

例如，如果q(1,0)=0.5，我们可以知道第一场比赛有50%的投注会买主队输球。我们假设这n场比赛互不相关，即p(i, r)的结果不会受p(j, r’)的影响，q(i, r)的结果也不会受q(j, r’)的影响(r ≠ r’)。

在这个模型里，我们规定，必须猜中全部$n$场比赛的结果才能获奖。总奖金为$M$，由所有获奖的投注平分。因此，对于一个单式投注$Ri = \{r_{i1}, r_{i2}, …, r{in}\}$，rij表示投注Ri对第j场比赛的预测结果，它的中奖概率为
$$
P(R_i)=\prod_{i=1}^n\ p(j,r_{ij})
$$
设投注总数为N，那么中奖的投注总数为：
$$
N*Q(R_i)=N*\prod_{i=1}^n\ p(j,r_{ij})
$$
于是，投注Ri所能得到的奖金的期望（平均意义下能够获得的奖金数）就是：
$$
\frac {M} {N*Q(R_i)}*P(R_i)
$$
复式投注R中，只要有一个Ri猜对所有比赛结果，即可中奖。因此，复式投注R所能获得的奖金的期望就是：
$$
\sum_{R_i\in R}\frac {M} {N*Q(R_i)}*P(R_i)
$$
我们的问题是，给定n场比赛的信息（胜负平的概率和彩民购买三种结果的概率），以及复式投注中可以购买的最大注数U，要求设计一种复式投注的方案，在不超过最大注数（复式投注的注数k ≤ U）的前提下，使得获得奖金的期望最大。

**输入格式**

第一行四个整数$n, N, M, U（n, U ≤ 10^4, N, M ≤ 10^9）$。

以下n行，每行六个实数。第i + 1行的六个实数为$p(i, 0), p(i, 1), p(i, 2), q(i, 0), q(i, 1),q(i, 2)$，用来描述第i场比赛的相关信息。其中，$p(i, 0) + p(i, 1) + p(i, 2) = 1, q(i, 0) + q(i, 1) + q(i, 2) = 1, q(i, j) ≠ 0$。

**输出格式**

一个实数，表示最大的奖金期望的自然对数
$$
ln(Max_{|R|≤U}(\sum_{R_i\in R}\frac {M} {N*Q(R_i)}*P(R_i)))
$$
输出保留3位小数（四舍五入）。

**simple.in**

```c++
1 10 10 1
0.3 0.2 0.5 0.7 0.2 0.1
```

**simple.out**

```c++
1.609
```

## 问题分析

### 样例分析

说实话，刚看到题时，我蒙了，这怎么多数学公式怎么搞。所以推明白了样例，就大概明白了

拿出我的Casio，$e^{1.609}=4.9978$,那么没有求对数时就是5，在乘上N除以M就知道$\frac {P(R_i)} {Q(R_i)}$是5通过细致细致入微的关差，刚好0.5/0.1=5。

注意p是结果的概率，q是投注的概率

我们看到U=1,则最大注数是1,也就是说都是单注，那事实上在这个样例，我们就要求一个$Max_{0<=i<=2}\{\frac{p(1,i)}{q(1,i)} \}$,那么这个样例分析，$U=1$时看不出来什么有什么的，我们把$U=2$，再来看这个样例，我们可以把复式投注看成是两个单注，投注赢的奖金是0.3/0.7=0.428，而投注平的奖金为0.2/0.2=1，投注输的奖金为0.5/0.1=5（~~这怕不是国足~~）

这时我们的两个注要压平和输。

在$U=3$时我们三个注都压。那么对于，一场比赛我们的押注方式共有7种，可事实上，我们只用考虑其中的三种情况，因为由于贪心的思想在注数一定时，我们选择概率奖金数最大(即$\sum_{e=1}^k\frac{p(i,j)}{q(i,j)}$)的。

于是我们真的懂了这个又臭又长的答案式子，先不考虑ln
$$
ans=\prod_{i=1}^n(a(i,k_i))*\frac{M}{N}
$$
其中$a(i,k_i)$,表示我第i场比赛投$k_i$个注的期望的最大奖金概率就是好几个$\frac{p(i,j)}{q(i,j)}$

**引理**

ln(ab)=ln(a)+ln(b,证明吗，幂运算，送的。

**考虑到小数乘法的精度损失**——其实挺重要的

我们不妨对式子先取ln，成为加法，又快有准

于是式子两边同时取ln有
$$
ln(ans)=\sum_{i=1}^nln(a(i,k_i))+ln\frac{M}{N}
$$
我们就有了以下代码来生成a

```c++
for(int i=1;i<=n;i++){
		scanf("%lf%lf%lf%lf%lf%lf",&a,&b,&c,&d,&e,&f);
		tmp[0]=a/d;
		tmp[1]=b/e;
		tmp[2]=c/f;
		cha[i][1]=log(max(tmp[1],max(tmp[0],tmp[2])));
		cha[i][2]=log(max(tmp[1]+tmp[0],max(tmp[1]+tmp[2],tmp[0]+tmp[2])));
		cha[i][3]=log(tmp[1]+tmp[0]+tmp[2]);
	}
```

### 算法分析

题目是问我们一个最大的期望答案,又不输出方案，那我就是dp

考虑他的状态$f(i,j)$,，表示在已经押注了i场比赛，还剩j个注是期望奖金概率的最大值取ln，这里我们用了$log_e(i)$函数的单增性，这是一个不完全重复背包

我们的所求即为$f(n,U)$，再来考虑我们的转移方程
$$
f(i,j)=\begin{cases}0&i=0 \\Max_{1<=k<=3}\{ f(i-1,j/k)+a[i][k]\}&i≠0\end{cases}
$$
注意这里的j一定不能为0因为注数为零时后面投不下去了

我们要注意的是这个t题的数据有些大，如果开二维的话要10G左右$qwq$，在计算$f(i,j)$,是我们只用到了f(i-1，j/k)的数据那么我们可以加上一维数组优化，注意递推是要倒序求（完全的要顺序）。

```c++
for(int i=1;i<=n;i++)
		for(int j=U;j>=1;j--)
			for(int k=1;k<=3;k++)
				if(j/k>=1)
					data[j]=max(data[j],data[j/k]+cha[i][k]);
```

于是我就很愉快的卡过了这道题

接下来是完整代码

```c++
#include <bits/stdc++.h>
using namespace std;
const int Maxn=10001,MaxU=10001;
double a,b,c,d,e,f,data[MaxU],cha[Maxn][4],tmp[3];;
int n,M,N,U;
int main(){
	scanf("%d%d%d%d",&n,&N,&M,&U);
	for(int i=1;i<=n;i++){
		scanf("%lf%lf%lf%lf%lf%lf",&a,&b,&c,&d,&e,&f);
		tmp[0]=a/d;
		tmp[1]=b/e;
		tmp[2]=c/f;
		cha[i][1]=log(max(tmp[1],max(tmp[0],tmp[2])));
		cha[i][2]=log(max(tmp[1]+tmp[0],max(tmp[1]+tmp[2],tmp[0]+tmp[2])));
		cha[i][3]=log(tmp[1]+tmp[0]+tmp[2]);
	}
	for(int i=1;i<=n;i++)
		for(int j=U;j>=1;j--)
			for(int k=1;k<=3;k++)
				if(j/k>=1)
					data[j]=max(data[j],data[j/k]+cha[i][k]);
	printf("%.3lf",log(M)-log(N)+data[U]);
	return 0;
}
```

很短，只有24行，这又一次说明了推样例的重要性

## 回头望月

当我再看我的dp是有些伤感，我是怎么堆出dp转移方程的？每一场比赛，你必须投注，那么，在dp过程中万一一次dp的之不改变即cha<0，怎么办，我是错了吗。

事实上，在思考之后这个问题等价于$a+b+c=1,d+e+f=1$

问在$\frac{a}{d},\frac{b}{e},\frac{c}{f}$中有最大的一个，两个，三个求和，和是否大于1。

其实是显然的，考虑和谐的情况三个都是1，显然的吗，哈哈

---

## 作者：_louhc (赞：3)

## 思路
题目又臭又长,其实没有什么卵用....  
真正有用的只有那个式子.根据乘法原理,我们可以转换成这样:  
$$ans=\frac MN\max\{\prod_{i=1}^n(a_{i,0}\times \frac{p_{i,0}}{q_{i,0}}+a_{i,1}\times \frac{p_{i,1}}{q_{i,1}}+a_{i,2}\times \frac{p_{i,2}}{q_{i,2}})\},a\in\{0,1\},\prod_{i=1}^n(a_{i,0}+a_{i,1}+a_{i,2})\le U$$  
于是设计状态 $f[i][j][k]$ 表示当前进行到 $i$ 场,有 $j$ 场 $(a_{i,0}+a_{i,1}+a_{i,2})$ 为 $2$,有 $k$ 场 $(a_{i,0}+a_{i,1}+a_{i,2})$ 为 $3$.  
因为 $j,k$ 都是$\log$ 级别的,所以总复杂度为 $O(n\log^2 U)$.  
最终结果可能会很大,最好不要用 `double`,用 `long double`,或者利用 $\log(xy)=\log x + \log y$ 来求.  
因为最终结果也要求取 $\log$,于是用后一种就OK了.  
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define i64 long long
#define f80 long double
#define rgt register
#define fp( i, b, e ) for ( int i(b), I(e); i <= I; ++i )
#define fd( i, b, e ) for ( int i(b), I(e); i >= I; --i )
#define go( i, b ) for ( int i(b), v(to[i]); i; v = to[i = nxt[i]] )
template<typename T> inline bool cmax( T &x, T y ){ return x < y ? x = y, 1 : 0; }
template<typename T> inline bool cmin( T &x, T y ){ return y < x ? x = y, 1 : 0; }

const int _ = 10015;
int n, N, M, U;
double p[_][3], f[_][14][9];

signed main(){
	scanf( "%d%d%d%d", &n, &N, &M, &U );
	fp( i, 1, n ){
		double t1, t2, t3;
		scanf( "%lf%lf%lf%lf%lf%lf", p[i], p[i] + 1, p[i] + 2, &t1, &t2, &t3 );
		p[i][0] /= t1, p[i][1] /= t2, p[i][2] /= t3, sort(p[i], p[i] + 3),
		p[i][1] += p[i][2], p[i][0] += p[i][1]; //贪心选最大的几个加起来
		p[i][0] = log(p[i][0]), p[i][1] = log(p[i][1]), p[i][2] = log(p[i][2]);
	} double ans(0);
	fp( i, 1, n ){
		for ( int j(0), tj(1); tj <= U; ++j, tj *= 2 )
			for ( int k(0), tk(tj); tk <= U; ++k, tk *= 3 ){
				cmax( f[i][j][k], f[i - 1][j][k] + p[i][2] );
				if ( j ) cmax( f[i][j][k], f[i - 1][j - 1][k] + p[i][1] );
				if ( k ) cmax( f[i][j][k], f[i - 1][j][k - 1] + p[i][0] );
			}
	} fp( i, 0, 13 ) fp( j, 0, 8 ) cmax( ans, f[n][i][j] );
	printf( "%.3lf\n", ans + log(M) - log(N) );
	return 0;
}


```

---

## 作者：GNAQ (赞：1)

这个题被 JLOI2010 抄去了。

这玩意是概率 DP

就是你读完巨长的题面之后可以想一下

假如你全去投复式，并且每场都押三种结果，那么。。

你最多投 $10$ 场

两种？ $20$ 场满够。

然后我们就可以设计状态去描述决策过程。

$\mathrm{dp[i][j][k]}$ 表示目前投了 $i$ 场单注, $j$ 场双注, $k$ 场三注的最大概率

然后就转移就完事了.

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<iterator>
#include<cstdlib>
#include<map>
#include<vector>
#include<set>
#include<queue>
#define ll long long
using namespace std;
 
int n,N,M,U;
long double p[10010][5]={0},q[10010][5]={0},a[10010][5]={0};
long double dp[10010][20][20]={0};
 
inline void readx(int& x)
{
    x=0; int k=1; register char ch=0;
    while (ch<'0' || ch>'9') { ch=getchar(); if (ch=='-') k=-1; }
    while (ch>='0' && ch<='9') { x=x*10+ch-'0'; ch=getchar(); }
    x*=k;
}
 
inline bool cmp1(long double a,long double b) { return a>b; }
 
int main()
{
    readx(n); readx(N); readx(M); readx(U);
    for (int i=1;i<=n;i++)
    {
        for (int j=0;j<=2;j++) scanf("%Lf",&p[i][j]);
        for (int j=0;j<=2;j++) scanf("%Lf",&q[i][j]);
        for (int j=0;j<=2;j++) a[i][j]=p[i][j]/q[i][j];
        sort(a[i],a[i]+3,cmp1);
    }
     
    dp[0][0][0]=1.0;
    for (int i=1;i<=n;i++)
        for (int j=0;j<=19;j++)
            for (int k=0;k<=9;k++) if (pow(2,j)*pow(3,k)<=(long double)U+1e-6)
            {
                dp[i][j][k]=dp[i-1][j][k]*a[i][0];
                if (j) dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]*(a[i][0]+a[i][1]));
                if (k) dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]*(a[i][0]+a[i][1]+a[i][2]));
            }
    long double ans=0.0;
    for (int j=0;j<=19;j++)
        for (int k=0;k<=9;k++)
            ans=max(ans,dp[n][j][k]);
    printf("%.3Lf\n",log(ans/N*M));
    return 0;
}
```

---

## 作者：qwer6 (赞：0)

## Description

~~其实这道题的难点就在看懂题目。~~

总共有 $N$ 个人去买彩票，总奖金共 $M$ 元，对于一张彩票，需要确定 $n$ 个数字，每个数字有 $3$ 种可选的值，对于第 $i$ 个数字的第 $j$ 个可选值，将有 $q(i,j)N$ 的人选这个可选值，有 $q(i,j)$ 的概率正确，当且仅当一张彩票的所有数字正确的时候，这张彩票可以获得奖金，总奖金将由所有中奖的彩票平分。

特别的，对于一张彩票，一个数字可以选择多个可选值，记第 $i$ 个数字选择 $cnt_i$ 个可选值，那么称这张彩票的注数为 $\prod_{i=1}^n cnt_i$，问当所有人每个数字选择的可选值个数相等且彩票的注数不超过 $u$ 的时候，这 $N$ 个人一个人获得的奖金的最大期望是多少，输出最大期望的自然对数。

## Solution

我们来看一下题中所给出的四条公式：
$$
P(R_i)=\prod_{j=1}^n p(j,r_{i,j})\\
Q(R_i)=\prod_{j=1}^n q(j,r_{i,j})\\
E(R_i)=\frac{P(R_i)M}{Q(R_i)N}\\
E(R)=\sum_{R_i\in R}\frac{P(R_i)M}{Q(R_i)N}\\
$$
第一条公式描述了一个单式投注中奖的概率，第二条公式描述了一个人有多大的概率购买这个单式投注，第三条公式描述了一个单式投注每一个人获得奖金的期望值，第四条公式描述了一个复式投注每一个人获得奖金的期望值。

我们重点分析最后一条公式，显然，$\frac{M}{N}$ 是一个常数，可以提出，然后将 $P(R_i)$ 和 $Q(R_i)$ 的计算公式代入可以得到：
$$
E(R)=\frac{M}{N} \sum_{R_i\in R}\prod_{j=1}^n \frac{p(j,r_{i,j})}{q(j,r_{i,j})}
$$
我们设 $a_{i,j}=\frac{p(i,j)}{q(i,j)}$，那么有：
$$
E(R)=\frac{M}{N}\sum_{R_i\in R}\prod_{j=1}^n a_{j,r_{i,j}}
$$
然后我们需要对上面这个式子进行进一步化简，这里举一个例子可能会更好理解这一步变换：假设一共三场比赛，第一场下注胜负，第二场下注胜负，第三场下注胜，那么这种复式投注包含的所有单式投注有 $(2,2,2),(2,0,2),(0,2,2),(0,0,2)$ 四种，最后得到的式子就是 $a_{1,2}\times a_{2,2}\times a_{3,2}+a_{1,2}\times a_{2,0}\times a_{3,2}+a_{1,0}\times a_{2,2}\times a_{3,2}+a_{1,0}\times a_{2,0}\times a_{3,2}$，那么提取公因数之后，原式就等于 $(a_{1,2}+a_{1,0})\times (a_{2,2}+a_{2,0})\times a_{3,2}$，那么我们上面的式子应该也可以做类似的转换，可以得到：
$$
E(R)=\frac{M}{N}\prod_{i=1}^n\sum_{j=0}^2 a_{i,j}\times b_{i,j}
$$
其中 $b_{i,j}$ 表示第 $i$ 场的情况 $j$ 在复式投注 $R$ 中是否被下注了。

看起来这样子应该可以写了，但是我们仔细分析一下样例。

可以发现样例中显然只能进行单式投注，如果使用上面的式子，确定唯一一场比赛只能下注一种情况的话，然后直接按照期望进行计算的话，那么就有 $E(R)=\frac{10}{10}[p(1,0)\times a_{1,0}+p(1,1)\times a_{1,1}+p(1,2)\times a_{1,2}]$，最后得到的答案 $\ln(E(R))$ 为 $0$，但是样例输出是 $1.609$？观察一下所有 $a_{1,i}$ 的取值，分别为 $0.428571,1,5$，而 $e^{1.609}=4.9978109171778$，恰好和 $5$ 接近，所以这道题中要求的复式投注方案其实是需要确定每一场比赛投几种情况，投什么情况。

理解了这一点，问题就简单了，我们计算出 $a_{i,j}$，然后对于每一场比赛，将 $a$ 从大到小排序，然后下注一种情况就乘 $a_{1}$，下注两种情况就乘 $a_1+a_2$，下注三种情况就乘 $a_1+a_2+a_3$，然后直接进行 DP 即可。

唯一一点美中不足的问题在于，这样的状态可能需要记 $f_{i,j}$ 表示前 $i$ 场共投 $j$ 注的最大乘积，时空复杂度 $O(nm)$，虽然时限够了，但是空间显然不够。

优化也十分套路，可以选择滚动数组优化，也可以使用这种优化方式：显然 $j$ 只能表示成 $2^x3^y$ 这种形式，将 $j$ 这一维拆解成 $x$ 和 $y$ 两维即可。

写完一交，怎么只有 $50$ 分？看一看返回信息，好像是输出 $\inf$ 了，不过没关系，我们知道 $\ln(ab)=\ln(a)+\ln(b)$，给上面所有值套一个 $\ln$，然后把乘法改成加法即可通过。

## Code

```c++
/*by qwer6*/
/*略去缺省源和快读快写*/
const int N=1e4+5;
int n,nn,mm,u,mx2,mx3;
double p1,p2,p3,q1,q2,q3,ans;
int pw[20][10];
double f[N][20][10],val[N][5];
signed main(){
	read(n),read(nn),read(mm),read(u);
	for(int i=1;i<=n;i++){
		scanf("%lf%lf%lf",&p1,&p2,&p3);
		scanf("%lf%lf%lf",&q1,&q2,&q3);
		val[i][1]=p1/q1;
		val[i][2]=p2/q2;
		val[i][3]=p3/q3;
		sort(val[i]+1,val[i]+3+1,greater<double>());
		val[i][3]=log(val[i][1]+val[i][2]+val[i][3]);
		val[i][2]=log(val[i][1]+val[i][2]);
		val[i][1]=log(val[i][1]);		
	}
	pw[0][0]=1;
	for(int i=1;;i++){
		pw[i][0]=pw[i-1][0]<<1;
		if(pw[i][0]>u){
			mx2=i-1;
			break;
		}
	}
	for(int i=1;;i++){
		pw[0][i]=(pw[0][i-1]<<1)+pw[0][i-1];
		if(pw[0][i]>u){
			mx3=i-1;
			break;
		}
	}
	for(int i=0;i<=mx2;i++)
		for(int j=0;j<=mx3;j++)
			pw[i][j]=pw[i][0]*pw[0][j];
	for(int i=1;i<=n;i++){
		for(int j=0;j<=mx2;j++){
			for(int k=0;k<=mx3;k++){
				if(pw[j][k]>u)break;
				f[i][j][k]=f[i-1][j][k]+val[i][1];
				if(j)f[i][j][k]=max(f[i][j][k],f[i-1][j-1][k]+val[i][2]);
				if(k)f[i][j][k]=max(f[i][j][k],f[i-1][j][k-1]+val[i][3]);
			}
		}
	}
	for(int j=0;j<=mx2;j++){
		for(int k=0;k<=mx3;k++){
			if(pw[j][k]>u)break;
			ans=max(ans,f[n][j][k]);
		}
	}
	printf("%.3lf",ans+log(mm)-log(nn));
}
```

---


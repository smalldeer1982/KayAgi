# [TJOI2007] 书架

## 题目描述

Knuth 先生家里有个精致的书架，书架上有 $N$ 本书，如今他想学到更多的知识，于是又买来了 $M$ 本不同的新书。现在他要把新买的书依次插入到书架中，他已经把每本书要插入的位置标记好了，并且相应的将它们放好。由于 Knuth 年龄已大，过几天他已经记不清某些位置上放的到底是什么书了，请问你能帮助他吗？


## 说明/提示

原来有三本书 Math、Algorithm、Program，后来又买了两本书，分别插入到 $2$ 和 $1$ 的位置，每次插入时其他书都要向后挪一个位置，最后书架上书的序列为：

```plain
0  Math
1  System
2  Algorithm
3  Picture
4  Program
```
$Q$ 次询问依次为 $0$, $1$, $3$ 位置的书，所以答案为：Math、System、Picture


对于 $30\%$ 的数据，$1 \leqslant N \leqslant 100$, $1 \leqslant M \leqslant 10^3$, $1 \leqslant Q \leqslant 10^3$

对于 $100\%$ 的数据，$1 \leqslant N \leqslant 200$, $1 \leqslant M \leqslant 10^5$, $1 \leqslant Q \leqslant 10^4$

对于 $100\%$ 的数据都符合题目中所描述的限制关系，数据保证每次插入的位置均不超过当时书架上书的数量，而且保证 $Q$ 次查询中的每个位置上一定有书。

## 样例 #1

### 输入

```
3
Math
Algorithm
Program
2
Picture 2
System 1
3
0
1
3```

### 输出

```
Math
System
Picture```

# 题解

## 作者：critnos (赞：42)

这题感觉用啥方法都能水过去。

比如 vector，块链。

介绍一种神仙级别的 STL 数据结构：rope。

（表面上大概可以理解为进阶版的 vector）

这个丧心病狂的东西支持 $\log n$ 级别的大部分 vector 操作。

然后就很简单了，，，

您以为这是基于平衡树的？

no，是基于**可持久化**平衡树的，底层是红黑树。

所以支持 $O(1)$ 的 copy，，，

可以水大部分的可持久化题目。

```cpp
#include<bits/stdc++.h>
#include<ext/rope>
using namespace std;
using namespace __gnu_cxx;
rope<int> a; 
string t[200005];
int main()
{
	int n,x;
	string p;
	scanf("%d",&n);
	while(n--)
	{
		cin>>t[a.size()];
		a.push_back(a.size());
	}	
	scanf("%d",&n);
	while(n--)
	{
		cin>>t[a.size()];
		scanf("%d",&x);
		a.insert(x,a.size());
	}
	scanf("%d",&n);
	while(n--)
	{
		scanf("%d",&x);
		cout<<t[a[x]]<<endl;
	}	
}
```


---

## 作者：Sunlight9 (赞：40)

写在前面的话：

这篇题解的做法是$fhq-Treap$，其实楼上（应该是）已经有一篇$fhq-Treap$的题解了，但那位$DALAO$是用指针写的，为了让大家更快的看懂，于是就写了一篇用非指针变量的$fhq-Treap$，自我感觉~~通俗易懂，儒雅随和~~。

大家可以在我的[blog](https://dyrisingsunlight.github.io/2019/08/17/TJOI2007-%E4%B9%A6%E6%9E%B6/)中进行查看。

下面进入正文。

------------


## $Problem's$ $Website$
[TJOI2007 书架](https://www.luogu.org/problem/P3850)

## $Solution$
这是一道平衡树的好题，因为我暂时不会$Splay$，所以我就用$fhq-Treap$来写。

首先关于$fhq-Treap$的一些解释在我的另外一篇[blog](https://dyrisingsunlight.github.io/2019/08/10/%E6%B5%85%E8%B0%88fhq-Treap/)中已经详细说明了，不懂的童鞋可以先去学习一下。

这道题要用到**排名分裂**，同样用到这种方法的还有另外一道[同名题](https://www.luogu.org/problem/P2596)。

~~上面好像都是废话，下面是干货。~~

##### 下面详细地说一下操作。

> 1.处理书的名称:

>> 因为是字符串，所以我们用一个$string$类型的数组记录，用一个变量当做编号**映射**到每本书的名称。

>> 温馨提示：注意数据范围，否则将惨遭$RE$。。。（好像就我这个菜鸡$RE$了）

> 2.处理一开始就在书架上的书:

>> 我们所说的“**排名**”即**当前这本书的上面有几本书**，所以对于最开始的书籍，我们只要$insert(i - 1, cnt);$即可（cnt即为映射的变量）

> 3.处理后来放入的书籍:

>> 经过研究样例，我们发现：插入一个位置为$x$的书，原本的第$x$本到最后一本的位置都会$+1$，也就是![](https://cdn.luogu.com.cn/upload/pic/72965.png)，那么也就是说，插入后这本书的排名就为$x$，所以就$insert(x, cnt);$

> 4.处理询问

>> 要输出第$x$个位置书的名称，我们就相当于找到第$x$个位置书映射的编号。

>> 方法也很简单，我们首先以$x$为排名将树分裂成以$r1, r2$为根的两棵树，再对$r2$以$1$为排名分裂成以$r3, r4$为根的两棵树，这样$r3$就成了一个节点，也就是要求的答案。

>> 给个图让大家理解一下（对于$fhq-Treap$，不理解的时候画个图有事半功倍的效果）:![](https://cdn.luogu.com.cn/upload/pic/72966.png
)

>> 别忘了最后合并回去。

相信大家对$fhq-Treap$又加深了理解。

所以下面代码就不解释了 ~~(逃~~

## $Code$
```cpp
//Coded by dy.
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define gc getchar()
#define pc(x) putchar(x)
#define re register
const int Maxn = 1e5 + 200 + 10;
using std :: string;
using std :: cin;
using std :: cout;
using std :: endl;
inline int sc() {
    int xx = 0, ff = 1; char cch = gc;
    while(!isdigit(cch)) {
        if(cch == '-') ff = -1; cch = gc;
    }
    while(isdigit(cch)) {
        xx = (xx << 1) + (xx << 3) + (cch ^ '0'); cch = gc;
    }
    return xx * ff;
}
inline void out(int x) {
    if(x < 0)
		pc('-'), x = -x;
    if(x >= 10)
        out(x / 10);
    pc(x % 10 + '0');
}
struct fhq_Treap {
	int ch[2];
	int siz, val, dat;
}t[Maxn];
int n, m, cnt;
int rt, r1, r2, r3, r4, tot;
string s[Maxn];
inline void pushup(int id) {
	t[id].siz = t[t[id].ch[0]].siz + t[t[id].ch[1]].siz + 1;
}
inline int cre(int r) {
	t[++tot].siz = 1, t[tot].val = r, t[tot].dat = rand();
	return tot;
}
inline void split(int id, int r, int &x, int &y) {
	if(!id)
		x = y = 0;
	else {
		if(r <= t[t[id].ch[0]].siz) {
			y = id;
			split(t[id].ch[0], r, x, t[id].ch[0]);
		}
		else {
			x = id;
			split(t[id].ch[1], r - t[t[id].ch[0]].siz - 1, t[id].ch[1], y);
		}
		pushup(id);
	}
}
inline int merge(int x, int y) {
	if(!x || !y)
		return x + y;
	if(t[x].dat < t[y].dat) {
		t[x].ch[1] = merge(t[x].ch[1], y);
		pushup(x);
		return x;
	}
	t[y].ch[0] = merge(x, t[y].ch[0]);
	pushup(y);
	return y;
}
inline void insert(int r, int id) {
	split(rt, r, r1, r2);
	rt = merge(r1, merge(cre(id), r2));
}
inline void query(int r) {
	split(rt, r, r1, r2);
	split(r2, 1, r3, r4);
	cout << s[t[r3].val] << endl;
	rt = merge(r1, merge(r3, r4));
}
int main() {
	srand(20041029);
	n = sc();
	for(re int i = 1; i <= n; ++i) {
		cin >> s[++cnt];
		insert(i - 1, cnt);
	}
	m = sc();
	while(m--) {
		cin >> s[++cnt];
		int x = sc();
		insert(x, cnt);
	}
	m = sc();
	while(m--) {
		int x = sc();
		query(x);
	}
    return 0;
}
```
$rp++$

---

## 作者：PiCaHor (赞：11)

这题   暴力a了   然后是vector的性质 直接暴力  代码中用了map其实可以换成数组       然后接结束了


```c
#include <bits/stdc++.h>
using namespace std;

vector <int> self;
map <int,string> book;
int n,m,len,q,x;

int read()
{
  int x=0;
  char c=getchar();
  while(c<'0'||c>'9')  c=getchar();
  while(c>='0'&&c<='9')
  {
    x=(x<<3) + (x<<1) + c - '0' ;
    c=getchar();
  }
  return x;
}

int main()
{
  string str;
  n=read();
  for(int i=1; i<=n; i++)
  {
    cin>>str;
    book[++len]=str;
    self.push_back(len);
  }
  m=read();
  for(int i=1; i<=m; i++)
  {
    cin>>str>>x;
    book[++len]=str;
    self.insert(self.begin()+x,len);
  }
  q=read();
  while(q--)
  {
    x=read();
    cout<<book[self[x]]<<endl;
  }
  return 0;
}

```

---

## 作者：Eternal_Blue (赞：10)

# 这题是一道比较基础的平衡树问题  
因为我不会写treap  
所以我写了splay  

### ~~思路很简单~~  
### 思路：  
针对一开始的每一个已经排好的书，正常地建树，节点的权值可以设为该书的编号（其实在这道题里，节点的权值并没有什么意义）  
对于新插入的节点，假设该节点插入在k位置，那么先将平衡树的第k个节点伸展到树顶，然后再把平衡树的第k-1个节点伸展到根节点的左子树。此时，很显然第k-1个节点的右子树一定为空，这时候把新来的书插在这个位置。  
最后对于每一个询问，直接查第k个节点就行了。  
为了防止各种奇怪的问题，我在建树的时候还特意插入了最小节点和最大节点   
### 以下是代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 1000010
int ch[MAXN][2],val[MAXN],par[MAXN],cnt[MAXN],sizes[MAXN];
char names[MAXN][15];
int i,j,k,m,n,ncnt,root,q;
int chk(int x){
	return ch[par[x]][1]==x;
}
void pushup(int x){
	sizes[x]=sizes[ch[x][0]]+sizes[ch[x][1]]+cnt[x];
}
void rotate(int x){
	int y=par[x],z=par[y],k=chk(x),w=ch[x][!k];
	ch[y][k]=w,par[w]=y;
	ch[z][chk(y)]=x,par[x]=z;
	ch[x][!k]=y,par[y]=x;
	pushup(y),pushup(x);
}
void splay(int x,int goal=0){
	while(par[x]!=goal){
		int y=par[x],z=par[y];
		if(z!=goal){
			if(chk(x)==chk(y)) rotate(y);
			else rotate(x);
		}
		rotate(x);
	}
	if(!goal) root=x;
}
void find(int v){
	if(!root) return;
	int cur=root;
	while(val[ch[cur][v>val[cur]]]&&v!=val[cur]){
		cur=ch[cur][v>val[cur]];
	}
	splay(cur);
}
void insert(int v){
	int cur=root,p=0;
	while(cur&&val[cur]!=v){
		p=cur;
		cur=ch[cur][v>val[cur]];
	}
	if(cur){
		cnt[cur]++;
	}else{
		cur=++ncnt;
		if(p) ch[p][v>val[p]]=cur;
		ch[cur][0]=ch[cur][1]=0;
		val[cur]=v,par[cur]=p;
		cnt[cur]=sizes[cur]=1;
	}
	splay(cur);
}
int kth(int k){
	int cur=root;
	while(true){
		if(ch[cur][0]&&sizes[ch[cur][0]]>=k){
			cur=ch[cur][0];
		}else{
			if(sizes[ch[cur][0]]+cnt[cur]<k){
				k-=sizes[ch[cur][0]]+cnt[cur];
				cur=ch[cur][1];
			}else{
				return cur;
			}
		}
	}
}
int ranks(int v){
	find(v);
	return sizes[ch[root][0]]+1;
}
int pre(int v){
	find(v);
	if(val[root]<v) return root;
	int cur=ch[root][0];
	while(ch[cur][1]) cur=ch[cur][1];
	return cur;
}
int succ(int v){
	find(v);
	if(val[root]>v) return root;
	int cur=ch[root][1];
	while(ch[cur][0]) cur=ch[cur][0];
	return cur;
}
void remove(int v){
	int last=pre(v),Next=succ(v);
	splay(last),splay(Next,last);
	int del=ch[Next][0];
	if(cnt[del]>1){
		cnt[del]--;
		splay(del);
	}else{
		ch[Next][0]=0;
		splay(Next);
	}
}
int main(){
	ncnt=0; root=0;
	insert(-1),insert(1000000000);
	scanf("%d",&n);
	for(i=1;i<=n;i++) {
		scanf("%s",names[i]);
		insert(i);
	}
	scanf("%d",&m);
	for(i=1;i<=m;i++){
		scanf("%s%d",names[n+i],&k);
		k=k+2;
		int id=kth(k);
		splay(id);
		int sid=kth(k-1);
		splay(sid,id);
		ch[sid][1]=++ncnt;
		ch[ncnt][0]=ch[ncnt][1]=0;
		par[ncnt]=sid;
		val[ncnt]=k;
		cnt[ncnt]=sizes[ncnt]=1;
		pushup(sid),pushup(id);
	}
	scanf("%d",&q);
	for(i=1;i<=q;i++){
		scanf("%d",&k);
		int id=kth(k+2);
		printf("%s\n",names[id-2]);
	}
	return 0;
}
```

---

## 作者：Ireliaღ (赞：9)

2019.1.30更新：加入了$LateX$，简化了$Split$函数

## ~~这题我觉得就是个无旋Treap的板子，为什么没有无旋Treap的题解~~  
无旋$Treap$随便搞搞就过了这道题，我来发一个题解  

### 前置知识：无旋Treap

无旋$Treap$的详细介绍我[博客](https://www.cnblogs.com/Juruo1103/p/10281403.html)里面有，这里先简单介绍一下。无旋$Treap$的主要操作是分裂和合并，分裂时可以分裂出任意大小的子树，这样，它就成了除了$Splay$之外，支持区间指定位置插入的常用数据结构。
  
### 关于本题

这道题是让我们指定位置插入和单点查询，那么我们二叉搜索树的性质由原序列顺序保持，这样中序遍历就是原序列。

#### 操作（1）：插入

加入我们想把一个元素插入后，让它在序列的第$k$个位置，那么我们分裂出大小为$k-1$的子树，把它与新结点合并，再和剩余部分合并，就$OK$了，代码如下

```
void Insert(Node *x, int k) {
    Node *t1, *t2;
    Split(root, k - 1, t1, t2);//分出k - 1个元素存在t1中，剩余存在t2中
    root = Merge(t1, Merge(x, t2));//新结点插进去，原样拼回去
}

```

#### 操作（2）：单点查询

既然它按照原序列保持二叉搜索树性质，那么我们就可以把它当做查询第$k$小。先拆出大小为$k - 1$的子树，再在剩余部分拆出大小为$1$的子树，取这个结点的$val$，再原样拼回去，代码如下

```
string FindKth(int pos) {
    Node *lt, *tmp;
    Split(root, pos - 1, lt, tmp);//第一次拆
    Node *rt, *midt;
    Split(tmp, 1, midt, rt);//第二次拆
    string res = midt->name;//存答案
    root = Merge(lt, Merge(midt, rt));//拼回去
    return res;
}
```

 _完整代码_   
 ```
 // luogu-judger-enable-o2
#include <string>
#include <iostream>

const int MAXN = 205;
const int MAXM = 1e5 + 5;
const int MAXQ = 1e4 + 5;

using std::cin;
using std::cout;
using std::string;

int Rand() {
    static int seed = 39444;
    return seed = (((seed ^ 810872ll) + 1433223ll) * 19260817ll) % 2147483647;
}

struct Node{
    int key, siz;
    string name;
    Node *child[2];
    Node(string name):name(name), key(Rand()), siz(1) {
        child[0] = child[1] = NULL;
    }
    Node():key(Rand()), siz(1) {
        child[0] = child[1] = NULL;
    }
};

Node *root = NULL;

//Node book[MAXN];

int n, m, q;

void Update(Node *now) {
    now->siz = 1;
    now->siz += now->child[0] ? now->child[0]->siz : 0;
    now->siz += now->child[1] ? now->child[1]->siz : 0;
}

void Split(Node *now, int k, Node *&t1, Node *&t2) {
    if (!now) {
        t1 = t2 = NULL; return;
    } 
    if (!k) {
        t1 = NULL; t2 = now; return;
    }
    if (k >= now->size) {
        t1 = now; t2 = NULL; return;
    }
    int ls = now->child[0] ? now->child[0]->size : 0;
    if (ls >= k) {
        Node *temp;
        Split(now->child[0], k, t1, temp);
        t2 = now; t2->child[0] = temp; 
        t2->Update(); return;
    } else {
        Node *temp;
        Split(now->child[1], k - ls - 1, temp, t2);
        t1 = now; t1->child[1] = temp;
        t1->Update(); return;
    }
}

Node *Merge(Node *a, Node *b) {
    if (!a) return b;
    if (!b) return a;
    if (a->key < b->key) {
        a->child[1] = Merge(a->child[1], b);
        Update(a);
        return a;
    } else {
        b->child[0] = Merge(a, b->child[0]);
        Update(b);
        return b;
    }
}

void Insert(Node *x, int k) {
    Node *t1, *t2;
    Split(root, k - 1, t1, t2);
    root = Merge(t1, Merge(x, t2));
}

string FindKth(int pos) {
    Node *lt, *tmp;
    Split(root, pos - 1, lt, tmp);
    Node *rt, *midt;
    Split(tmp, 1, midt, rt);
    string res = midt->name;
    root = Merge(lt, Merge(midt, rt));
    return res;
}

int main() {
    cin >> n;
    string temp;
//	for (int i = 1; i <= n; i++) cin >> (book + i)->name;
//	for (int i = 1; i <= n; i++) Insert(book + i, i);
    for (int i = 1; i <= n; i++) {
        cin >> temp;
        Insert(new Node(temp), i);
    }
    cin >> m;
    int pos;
    for (int i = 1; i <= m; i++) {
        cin >> temp >> pos; pos++;
        Insert(new Node(temp), pos);
    }
    cin >> q;
    for (int i = 1; i <= q; i++) {
        cin >> pos; pos++;
        cout << FindKth(pos) << '\n';
    }
    return 0;
}
```

---

## 作者：liuqy (赞：8)

## 前置芝士：树状数组
蛤，你不知道？好吧，打个板子就知道了[传送门](https://www.luogu.org/problemnew/show/P3374)

------------


我们先观察观察数据,发现最下面的书插入的位置肯定是它的目标位置，那么它之前一本放置的位置呢，我们发现能影响它目标位置的只可能是之后书的目标位置在它之前的会使它往后挪，以此类推，发现其实就是在已经放完位置之后的空位找位置，所以用树状数组维护一下到这个点的空位数，插入的时候二分一下位置看是否能插入即可。

------------

上代码
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int N=110000;
int n,m,k,x,bin[N],ans[N];
struct node{
	int p,k;
}d[N];
struct node1{
	char s[20];
}a[N];
int lowbit(int x){
	return x&-x;
}
void add(int x,int y){
	while(x<=n+m){
		bin[x]+=y;
		x+=lowbit(x);
	}
}
int sum(int x){
	int cnt=0;
	while(x!=0){
		cnt+=bin[x];
		x-=lowbit(x);
	}
	return cnt;
}
int query(int x,int y,int k){
	int ans1;
	while(x<=y){
		int mid=(x+y)>>1;
		int t=sum(mid);
		if(t>k)y=mid-1;
		else if(t<k)x=mid+1;
		else{ans1=mid;y=mid-1;}
	}
	return ans1;
}
int main(){
	scanf("%d",&n);
	memset(bin,0,sizeof bin);
	for(int i=1;i<=n;i++){scanf("%s",a[i].s);d[i].k=i;d[i].p=i;}
	scanf("%d",&m);
	for(int i=1;i<=m;i++){scanf("%s%d",a[i+n].s,&k);d[i+n].p=i+n;d[i+n].k=k+1;}
	for(int i=1;i<=n+m;i++)add(i,1);
	for(int i=n+m;i>=1;i--){
		k=query(1,n+m,d[i].k);
		ans[k]=d[i].p;
		add(k,-1);
	}
	scanf("%d",&k);
	for(int i=1;i<=k;i++){
		scanf("%d",&x);
		int t=ans[x+1];
		for(int j=0;j<strlen(a[t].s);j++)printf("%c",a[t].s[j]);
		printf("\n");
	}
	return 0;
}
```


---

## 作者：良月澪二 (赞：3)

元旦放假的前几个小时做的

在洛谷搜平衡树的标签

只做$STL$可以水的<(￣ˇ￣)/

然后就碰到了这个题

这么好写！

然后就有了下面的代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <complex>
#include <algorithm>
#include <climits>
#include <queue>
#include <map>
#include <ctime>
#include <set>
#include <vector>
#include <iomanip>
#define A 1000010
#define B 2010

using namespace std;
typedef long long ll;
vector<string> v;
int n, m, x;
char opt[11];

int main(int argc, char *argv[]) {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%s", opt);
        v.push_back(opt);
    }
    scanf("%d", &m);
    while (m--) {
        scanf("%s %d", opt, &x);
        v.insert(v.begin() + x, opt);
    }
    scanf("%d", &m);
    while (m--) {
        scanf("%d", &x);
        string s = v[x];
        printf("%s\n", s.c_str());
    }
    return 0;
}
```
当然这是最后换了输入输出的

然后就$T$了七个

很懵逼

我这个复杂度至于？？？

$vector$套$string$有多慢？？？

懂的请告诉我(*-ω-)

遂去看题解（PiCaHor的）

也很妙啊

怕数组寻址慢开正好的数组（这里的正好是$n+m$）

又有了下面的代码，也就是他说的数组版

一定要熟悉$STL$中各种函数

通过迭代器指定位置插入和指定位置删除

$T$怕了，不敢$cin$ $cout$
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <complex>
#include <algorithm>
#include <climits>
#include <queue>
#include <map>
#include <ctime>
#include <set>
#include <vector>
#include <iomanip>
#define A 100010
#define B 2010

using namespace std;
typedef long long ll;
vector<int> v;
string tmp[A];
int n, m, x, cnt;
char opt[12];

int main(int argc, char *argv[]) {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%s", opt);
        tmp[++cnt] = opt;
        v.push_back(cnt);
    }
    scanf("%d", &m);
    while (m--) {
        scanf("%s %d", opt, &x);
        tmp[++cnt] = opt;
        v.insert(v.begin() + x, cnt);
    }
    scanf("%d", &m);
    while (m--) {
        scanf("%d", &x);
        string s = tmp[v[x]];
        printf("%s\n", s.c_str());
    }
    return 0;
}
```

---

## 作者：zhengrunzhe (赞：2)

提供指针Splay

题解原有的那份Splay代码初始建树是n log n插入，维护“权值的左小右大”

这份代码采用O(n)建树，平衡树维护序列，其实这样才是Splay实现这种题型的正统做法

若当前要在pos位置前插入，令A为pos位置的节点，B为pos位置前一个的节点

先把B splay到根，这样根的左子树便是区间[pos,end]

再将A splay到根的右儿子，这样A的右子树便是区间[pos+1,end]，A没有左子树，便可以把要插入的节点接在A的左儿子处
```cpp
#include<cstdio>
#include<string>
#include<iostream>
using std::cin;
using std::cout;
using std::endl;
using std::string;
template<class type>inline void read(type &in)
{
	in=0;char ch=getchar();short fh=1;
	while (ch<48||ch>57)fh=ch=='-'?-1:fh,ch=getchar();
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+ch-48,ch=getchar();
	in*=fh;
}
const int N=210,M=1e5+10;
int n,m,q;
string book[N];
class Splay
{
	private:
		struct tree
		{
			int size;
			string key;
			tree *fa,*son[2];
			inline void pushup()
			{
				size=son[0]->size+son[1]->size+1;
			}
			inline bool identity()
			{
				return fa->son[1]==this;
			}
		};
	public:
		tree *null,*root;
	protected:
		tree memory_pool[N+M],*tail;
		inline void init()
		{
			tail=memory_pool;null=tail++;
			null->size=0;null->key="";
			null->son[0]=null->fa=null->son[1]=null;
			root=null;
		}
		inline tree *newtree(string key)
		{
			tree *p=tail++;
			p->key=key;p->size=1;
			p->son[0]=p->fa=p->son[1]=null;
			return p;
		}
		inline void connect(tree *p,tree *fa,bool which)
		{
			if (p!=null)p->fa=fa;
			if (fa!=null)fa->son[which]=p,fa->pushup();
		}
		inline void rotate(tree *p)
		{
			tree *fa=p->fa;
			bool id=p->identity();
			connect(p,fa->fa,fa->identity());
			connect(p->son[id^1],fa,id);
			connect(fa,p,id^1);
		}
		inline void splay(tree *p,tree *goal)
		{
			for (tree *fa;(fa=p->fa)!=goal;rotate(p))
				if (fa->fa!=goal)
					rotate(p->identity()^fa->identity()?p:fa);
			if (goal==null)root=p;
		}
		inline tree *findrank(int ranking)
		{
			ranking++;tree *now=root;
			while (1)
				if (ranking<=now->son[0]->size)now=now->son[0];
				else
				{
					ranking-=now->son[0]->size+1;
					if (!ranking)return now;
					now=now->son[1];
				}
		}
		inline tree *split(int pos)  //将第pos个位置提取出来，左儿子空出
		{
			tree *pre=findrank(pos-1),*now=findrank(pos);
			splay(pre,null);splay(now,pre);
			return now;
		}
	public:
		inline Splay(){init();}
		inline tree *build(int l,int r,tree *fa) //递归建树
		{
			if (l>r)return null;
			int mid=l+r>>1;
			tree *p=newtree(book[mid]);p->fa=fa;
			if (l==r)return p;
			p->son[0]=build(l,mid-1,p);
			p->son[1]=build(mid+1,r,p);
			return p->pushup(),p;
		}
		inline void insert(int pos,string key)
		{
			tree *now=newtree(key);
			connect(now,split(pos),0); //把新建的节点接上原来的pos位置前
			splay(now,null);
		}
		inline string query(int pos)
		{
			return findrank(pos)->key;
		}
}S;
int main()
{
	read(n);
	for (int i=1;i<=n;i++)cin>>book[i];
	book[0]=book[n+1]="";
	S.root=S.build(0,n+1,S.null); //添加0和n+1哨兵节点
	read(m);
	string name;int pos;
	while (m--)cin>>name,read(pos),S.insert(pos+1,name); //为了方便，将题中位置从0开始编号转成1开始编号
	read(q);
	while (q--)read(pos),cout<<S.query(pos+1)<<endl;
	return 0;
}
```

---

## 作者：lzx1999 (赞：1)

这是一道fhq_Treap(fhq,不是fhp,手残党,感谢提醒)的题, 我发现题解里都不是按照lazy标记往下传的, 我下意识的写的是用lazy的标记去修改rank的值, 每次在x处放一本书,x到最后的书的rank的排名都会+1 所以我的查找完全可以按照值rnk来查找,每次插入一本书就修改lazy标记
```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

#define eps 1e-9
#define endl '\n'
#define gcd __gcd
#define ll long long
#define LL long long
#define IDX(x) x - 'A'
#define idx(x) x - 'a'
#define idz(x) x - '0'
#define ld long double
#define lowebit(x) x&(-x)
#define rint register int
#define Len(x) (int)(x).size()
#define all(s) (s).begin(), (s).end()
using namespace std;
struct node
{
    int l, r, lazy, rnd, sie, rnk;
    string val;
}tr[110000];
mt19937 rnd(116551);
int root, tot;
inline int newnode(string val, int rnk)
{
    int now = ++ tot;
    tr[now].val = val;
    tr[now].sie = 1;
    tr[now].rnd = rnd();
    tr[now].rnk = rnk;
    return now;
}
inline void update(int now)
{
    tr[now].sie = tr[tr[now].l].sie + tr[tr[now].r].sie + 1;
}
inline void updown(int now) // 下放lazy标记
{
    if(tr[now].lazy)
    {
        tr[tr[now].l].rnk += tr[now].lazy;
        tr[tr[now].r].rnk += tr[now].lazy;
        tr[tr[now].l].lazy += tr[now].lazy;
        tr[tr[now].r].lazy += tr[now].lazy;
        tr[now].lazy = 0;
    }
}
void split(int now, int val, int& x, int& y)
{
    if(!now) x = y = 0;
    else
    {
        updown(now); // 在执行分裂操作前一定要下放lazy,因为拆分会破会一棵树,所以必须题前将lazy标记下放,否则就会错
        if(tr[now].rnk < val)
        {
            x = now;
            split(tr[now].r, val, tr[now].r, y);
        }
        else
        {
            y = now;
            split(tr[now].l, val, x, tr[now].l);
        }
        update(now);
    }
}
int Merge(int x, int y)
{
    if(!x || !y) return x + y;
    if(tr[x].rnd < tr[y].rnd)
    {
        updown(x);// 同理在合并前也一定要下放lazy标记
        tr[x].r = Merge(tr[x].r, y);
        update(x);
        return x;
    }
    else
    {
        updown(y);
        tr[y].l = Merge(x, tr[y].l);
        update(y);
        return y;
    }
}
int32_t main()
{
	ios_base::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    clock_t c1ockck = clock();
    int n; cin >> n;
    string s;
    for(int i = 0 ; i < n ; i ++)
    {
        cin >> s;
        root = Merge( root ,newnode(s, i)); //初始值按照最初给的顺序插入, 排名为i
    }
    cin >> n;
    int rnk;
    int x, y, z;
    for(int i = 1 ; i <= n ; i ++)
    {
        cin >> s >> rnk;
        split(root, rnk, x, y);//将以root为根的一棵树按照rank分裂成x和y, 以y为根的树的排名都是>= rank的, 所以以y为根的树要rank都要+1
        tr[y].rnk += 1;
        tr[y].lazy += 1;//防止TLE
        x = Merge(x, newnode(s, rnk));//按照rank先和x合并,先和y合并也行
        root = Merge(x, y);
    }
    cin >> n;
    for(int i = 1 ; i <= n ; i ++)
    {
        cin >> rnk;
        split(root, rnk, x, y);
        split(y, rnk + 1, y, z);//拆分成三棵树, rank< rnk的x, rank==rnk的y和rank>rnk的z
        cout << tr[y].val << endl;//直接输出根y的值就好
        root = Merge(Merge(x, y), z);//不能忘记合并这些树
    }
    cerr << "Time:" << clock() - c1ockck << "ms" <<endl;//什么都没有用的东西
    /**srO**/return 0;/**Orz**/
}

```


---

## 作者：Ascnbeta (赞：0)

## P3850 [TJOI2007] 书架

平衡树模板题，其他平衡树的题解基本都依赖分裂子树操作，这里提供不需要分裂子树的 WBLT 平衡树做法，其他 Leafy tree 也可以使用这种办法。至于其他类型的平衡树，不一定可用。

顺带一提，WBLT 真的快，关了个同步流就直接进最优解第一页了，不过我不会卡常数。

## 思路分析

为什么我们不能直接插入呢？因为我们如果在每个结点上维护位置的话，做不到动态更新位置，所以我们只能分裂子树。

但是 WBLT 是一颗 Leafy tree，由于 WBLT 的信息都存在叶子节点上，所以每一次插入操作肯定会进行到每个叶子上，这时候我们直接把这个叶子拆成两个叶子，左叶子维护要插入的字符串，右叶子维护原字符串即可。这其实相当于把叶子结点的顺序用来进行了平衡树的排序，但是这一步与其他的平衡树不同的是复杂度常数明显降低，所以每一次插入操作就是 $\mathcal{O}(\log n)$，而且 WBLT 这个 $\log$ 常数也小。

插入操作代码如下，类似 `getval` 的操作，每次判断插入的位置和左子树叶子节点个数来判断向左还是向右插入：

```cpp
inline void insert(int p,string str,int pos) {
    if (siz[p] == 1) {
        if (pos != 1) {
            int x = create(str),y = create(nm[p]);
            ls[p] = y,rs[p] = x;
        }else{
            int x = create(str),y = create(nm[p]);
            ls[p] = x,rs[p] = y;
        }
        pushup(p);
        return;
    }
    if (pos <= siz[ls[p]]) insert(ls[p],str,pos);
    else insert(rs[p],str,pos-siz[ls[p]]);
    pushup(p);
    maintain(p);
}
```

其他就没什么好说的了，注意下标从 $0$ 开始！因此每一次的位置需要 $+2$（节点个数从 $1$ 开始，我们还有一个哨兵节点）。

## AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 203;
const int maxm = 1e5+30;
const double alpha = 0.29;
int n,m,q;
double val[(maxn+maxm)<<1];
string nm[(maxn+maxm)<<1];
int ls[(maxn+maxm)<<1],rs[(maxn+maxm)<<1],siz[(maxn+maxm)<<1],tot,rt,cnt;
inline int create(string str) {
    nm[++tot] = str;
    siz[tot] = 1;
    return tot;
}
inline void pushup(int p) {
    siz[p] = siz[ls[p]] + siz[rs[p]];
}
#define ch(x,d) ((d)?(rs[x]):(ls[x]))
inline void rotate(int p,int d) {
    swap(ls[p],rs[p]);
    swap(ls[ch(p,d^1)],rs[ch(p,d^1)]);
    swap(ch(ch(p,d^1),d^1),ch(p,d));
    pushup(ch(p,d^1));
    pushup(p);
}
inline void maintain(int p) {
    int d;
    if (siz[p] == 1) return;
    if (siz[ls[p]] < alpha*siz[p]) d = 1;
    else if (siz[rs[p]] < alpha*siz[p]) d = 0;
    else return;
    if (siz[ch(ch(p,d),d^1)] * (1 - alpha) >= siz[ch(p,d)] * (1 - 2 * alpha)) {
        rotate(ch(p,d),d^1);
    }
    rotate(p,d);
}
inline void insert(int p,string str,int pos) {
    if (siz[p] == 1) {
        if (pos != 1) {
            int x = create(str),y = create(nm[p]);
            ls[p] = y,rs[p] = x;
        }else{
            int x = create(str),y = create(nm[p]);
            ls[p] = x,rs[p] = y;
        }
        pushup(p);
        return;
    }
    if (pos <= siz[ls[p]]) insert(ls[p],str,pos);
    else insert(rs[p],str,pos-siz[ls[p]]);
    pushup(p);
    maintain(p);
}
inline string getname(int rnk) {
    int p = rt;
    while (1) {
        if (siz[p] == 1) {
            assert(rnk == 1);
            return nm[p];
        }
        if (siz[ls[p]] >= rnk) p = ls[p];
        else rnk -= siz[ls[p]],p = rs[p];
    }
}
signed main() {
#ifdef LOCAL
    freopen("D:/codes/exe/a.in","r",stdin);
    freopen("D:/codes/exe/a.out","w",stdout);
#endif
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    rt = create("QAQ");
    // cerr << rt << '\n';
    insert(rt,"awa",1);

    cin >> n;
    for (int i = 1; i <= n; i++) {
        string s;
        cin >> s;
        insert(rt,s,i+1);
        // for (int i = 1; i <= tot; i++) {
        //     cerr << i << ' ' << ls[i] << ' ' << rs[i] << ' ' << nm[i] << ' ' << siz[i] << '\n';
        // }
        ++cnt;
        // cerr << s << "\n";
    }
    cin >> m;
    while (m--) {
        string s;int opt;
        cin >> s >> opt;
        insert(rt,s,opt+2);
        // for (int i = 1; i <= tot; i++) {
        //     cerr << i << ' ' << ls[i] << ' ' << rs[i] << ' ' << nm[i] << ' ' << siz[i] << '\n';
        // }
        ++cnt;
        // cerr << s << opt+1 << "\n";
    }
    cin >> q;
    while (q--) {
        int opt;
        cin >> opt;
        // cerr << opt << "\n";
        cout << getname(opt+2) << '\n';
    }
    return 0;
}
```

---

## 作者：Edward_Elric (赞：0)

## 思路
首先这是一个平衡树裸题，很容易看出来。

但这个数据范围貌似$\to(n\sqrt{n})$和$\to(n\log{n})$都可以跑。

于是觉得写个平衡树太麻烦了，写了分块，思路并不难想

随机数据只需要$vector$乱搞一波,插入均摊依然是$O(\sqrt {n})$。

但如果数据不随机，那么一个块也许会大大超过$\sqrt {n}$。所以我们需要重建操作，每次重建$O(n)$，重建最多$\sqrt {n}$次

但是我WA了一万发。我很不开心，想了很久，做了大胆的猜测，7，8点有误，然后在查询插入中$min(x+1,id-1)$然后过了。也就是说，其实数据并未保证每次插入的位置均不超过当时书架上书的数量。

所以这个分块开$O2$居然跑了第一。这足以证明平衡树常数之大，为什么不写分块呢？~~喵喵喵~~
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+1000,md=400+10;
vector<int>v[md];
int a[maxn];
char b[maxn][10+5];
int n,m,q,nuit,tot,bl,id;
void pre(){
    scanf("%d",&n);
    int bl=sqrt(n);
    for(int i=1;i<=n;i++){
    	scanf("%s",b[++id]);
        v[(i-1)/bl+1].push_back(id);
    }
    nuit=(n-1)/bl+1;
}
void rebuild(){
    int cnt=0;
    for(int i=1;i<=nuit;i++){
        for(vector<int>::iterator j=v[i].begin();j!=v[i].end();j++)
        a[++cnt]=*j;
        v[i].clear();
    }
    int blo=sqrt(cnt);
    for(int i=1;i<=cnt;i++)
     v[(i-1)/blo+1].push_back(a[i]);
    nuit=(cnt-1)/blo+1;
}
pair<int,int> query(int rk){
    int x=1;
    while(rk>v[x].size())
	rk-=v[x].size(),x++;
    return make_pair(x,rk-1);
}
void insert(int s,int x){
    pair<int,int> t=query(x);
    v[t.first].insert(v[t.first].begin()+t.second,s);
    if(v[t.first].size()>bl*20)rebuild();
}
void work(){
    scanf("%d",&m);
    bl=max(bl,(int)sqrt(m));
    for(int i=1;i<=m;i++){
       scanf("%s",b[++id]);
       int x;
       scanf("%d",&x);
       insert(id,min(x+1,id-1));
    }
    scanf("%d",&q);
    for(int i=1;i<=q;i++){
        int x;
        scanf("%d",&x);
        pair<int,int> t=query(min(id,x+1));
        printf("%s\n",b[v[t.first][t.second]]);
    }
}
int main(){
    pre();
    work();
    return 0;
}
```


---


# [TJOI2007] 小朋友

## 题目背景

幼儿园里有N个小朋友，老师要从中选出来一部分做丢手绢的游戏，可是老师没有想到这么小的孩子里面有些人之间还有矛盾。老师想找出尽量多的小朋友去玩游戏，但是又很头疼，他不想看到找出来玩游戏的小朋友里面还有任何两个人之间存在着矛盾。如果告诉你小朋友之间存在的M对矛盾关系，你能否帮助幼儿园老师计算出他最多可以选出多少个小朋友来做这个丢手绢的游戏？


## 题目描述

关于矛盾限制的说明：

如果我们把存在着矛盾的两个小朋友看作是无向图中相连的两个点，那么题目中的数据保证M对矛盾所构成的图中不会有超过3个点的环。（图1符合要求，图2则不符合）

![](https://cdn.luogu.com.cn/upload/pic/6098.png)


## 说明/提示

幼儿园有6个小朋友，矛盾关系中1 - 2 - 3组成一个环，3 - 4 - 5组成一个环，因此只能在这两个环中分别选一个小朋友，并且不能选择3号小朋友。

    
对于20%的数据，1 ≤ N ≤ 20

对于40%的数据，1 ≤ N ≤ 50

对于100%的数据，1 ≤ N ≤ 200

对于100%的数据都符合题目中所描述的矛盾限制关系。


## 样例 #1

### 输入

```
5 6
1 2
3 2
1 3
3 5
3 4
4 5```

### 输出

```
2```

# 题解

## 作者：Shikita (赞：12)

# 弦图 完美消除序列

## 弦图的前置知识

诱导子图：子图中任意一条边的两个端点一定也都在这个子图中

最大团：团中任意两点之间一定都有边，而包含顶点最多的团就是最大团

最小团覆盖：用最少的团覆盖图中所有的点

最大独立集：独立集中任意两点之间一定都没有边，而包含顶点最多的独立集就是最大独立集

最小染色：用最少的颜色给图染色使得图中任意相邻的两点颜色不相同

弦图：无向图中任意长度大于3的环都至少有一个弦，所谓弦就是连接环中不相邻两点的边

一般来讲：

①最大团数<=最小染色数

②最大独立集<=最小团覆盖

对于弦图来讲：

①最大团数==最小染色数

②最大独立集==最小团覆盖

单纯点：如果与顶点V相邻的所有点能构成一个团，那么V就是个单纯点

③任何一个弦图都有至少一个单纯点，不是完全图的弦图至少有两个不相邻的单纯点

完美消除序列：一个点的序列（每个点刚好出现1次）$v_1, v_2,…,v_n$满足$v_i$在诱导子图{$v_i, v_{i+1},…,v_n$}中为一个单纯点

一个无向图是弦图的充要条件是存在完美消除序列

再看本题的题意，**题目中的数据保证M对矛盾所构成的图中不会有超过3个点的环**

显然符合弦图的定义嘛

而题目中要求的矛盾关系，就是不能选择相邻的两个点嘛

妥妥的弦图最大独立集

## 做法

对于这种题目，我们只需要求个完美消除序列就好了，然后在完美消除序列上从前往后贪心取点即可

对于完美消除序列的求取方法

从后往前确定序列的点，每取一个点都把还没加入序列的和它相连的点的标号+1，每次取点选择标号最大的点之一，这样我们便可以求出一个完美消除序列

复杂度 $O(m+n)$

接下去在完美消除序列上跑个贪心就好了

```
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int x=0;
    char c=getchar();
    bool flag=0;
    while(c<'0'||c>'9') {if(c=='-')flag=1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x+(x<<2)<<1)+ c-'0';c=getchar();}
    return flag?-x:x;
}
const int N=1e5+5;
int n,m,vis[N],seq[N],num[N],id=1,ans;
int to[N],nxt[N],head[N],cnt;
vector<int>cg[N];
void add(int u,int cg){to[++cnt]=cg;nxt[cnt]=head[u];head[u]=cnt;}
int main()
{
    n=read();m=read();
    for(int i=1;i<=m;++i)
    {
        int u=read(),v=read();
        add(u,v),add(v,u);
    }
    for(int i=1;i<=n;++i) cg[0].push_back(i);
    for(int i=1;i<=n;++i)
    {
        int fg=0,now;
        while(!fg)
        {
            for(int j=cg[id].size()-1;j>=0;--j)
            if (!vis[cg[id][j]]) {fg=1;now=cg[id][j];break;}
            else cg[id].pop_back();
            if(!fg) --id;
        }
        seq[i]=now;vis[now]=1;
        for (int e=head[now];e;e=nxt[e])
        if (!vis[to[e]])
        {
            cg[++num[to[e]]].push_back(to[e]);
            id=max(id,num[to[e]]);
        }
    }
    memset(vis,0,sizeof(vis));
    for(int i=n;i;--i) if(!vis[seq[i]])
    {
        ++ans;vis[seq[i]]=1;
        for(int e=head[seq[i]];e;e=nxt[e]) vis[to[e]]=1;
    }
    printf("%d\n",ans);
}
```


---

## 作者：Purslane (赞：2)

# Solution

这是一个弦图。

你用最大势算法求出完美消除序列之后贪心即可。

完美消除序列使用堆去实现复杂度 $O(n^2 \log n)$，可以接受。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=200+10;
vector<int> G[MAXN];
int n,m,deg[MAXN],leb[MAXN],rev[MAXN],vis[MAXN];
struct INFO {int deg,id;};
bool operator <(INFO A,INFO B) {return A.deg<B.deg;}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	ffor(i,1,m) {int u,v;cin>>u>>v,G[u].push_back(v),G[v].push_back(u);}
	priority_queue<INFO> q;
	ffor(i,1,n) q.push({0,i});
	ffor(tc,1,n) {
		while(leb[q.top().id]) q.pop();
		int u=q.top().id;
		leb[u]=tc,rev[tc]=u;
		for(auto v:G[u]) if(!leb[v]) deg[v]++,q.push({deg[v],v});
	}
	int sum=0;
	roff(i,n,1) {
		int flg=0,u=rev[i];
		for(auto v:G[u]) flg|=vis[v];
		if(!flg) sum++,vis[u]=1;
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：decoqwq (赞：2)

团的定义是无向图中的一个子图，并且为完全图

弦的定义为，连接环内两个不相邻点的边，弦图的定义是，任意大于三的环都至少有一条弦，那么弦图中所有的极小团的大小都是$3$

一些点诱导子图定义为不含其他边的子图

若与点$v$相邻的点集$S_v+v$的诱导子图为一个团，则$v$是一个单纯点

然后此题要判定一张图是不是弦图，就要引入完美消除序列的概念，即$n$个点的一种排列$v_1,v_2..v_n$满足，$v_i$在$v_{i+1}..v_n$的诱导子图中为单纯点

可以证明一张图是弦图的充要条件是其拥有完美消除序列

完美消除序列常用的求法为$MCS$最大势算法，按$n..1$的顺序给点标号，每次标号的点是当前与已标号点集$S_n$中相邻点最多的点，可以链表优化至线性，常用的还有堆优化的$O(nlogn)$求法

判断一个序列是否为完美消除序列，只需要对于任意一个点$v_i$，我们找到他之后的序列中的和他相邻的点，称作点集$S_v$，如果$S_v$中最小的元素与其他元素都相邻，则该序列为完美消除序列，否则不是

证明可以看$cdq$的$ppt$

本题已经说明给定的是弦图，让你求的是弦图的最大独立集，那么显然我们只需按照完美消除序列正向贪心，标记相邻点，即可

顺带一提，最小染色数就只需要找出$MCS$中已选点中相邻点最多的点在已选点中的相邻点个数加$1$即可

```cpp
/*  Never Island  */
/*deco loves Chino*/
#include <bits/stdc++.h>
using namespace std;
int lis[210],pos[210],n,m,vis[210];
int mmp[210][210],cnt,head[210],ans[210],t[210];
struct edge
{
	int next,to;	
}e[40010];
void add(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}
struct node
{
	int ind,id;
	node(int A,int B):ind(A),id(B){}
	bool operator<(const node&a)const
	{
		return ind<a.ind;
	}
};
priority_queue<node> q;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	for(int i=1;i<=n;i++)
	{
		q.push(node(0,i));
	}
	cnt=n;
	while(!q.empty())
	{
		node u=q.top();
		q.pop();
		if(!vis[u.id])
		{
			lis[cnt]=u.id;
			pos[u.id]=cnt--;
			vis[u.id]=1;
			for(int i=head[u.id];i;i=e[i].next)
			{
				int v=e[i].to;
				if(!vis[v])
				{
					ans[v]++;
					u.id=v,u.ind=ans[v];
					q.push(u);
				} 
			}
		}
	}
	int rans=0;
	memset(vis,0,sizeof(vis));
	for(int i=1;i<=n;i++)
	{
		int u=lis[i];
		cnt=0;
		if(!vis[u])
		{
			rans++;
			vis[u]=1;
		}
		else
		{
			continue;
		}
		for(int j=head[u];j;j=e[j].next)
		{
			int v=e[j].to;
			vis[v]=1;
		}
	}
	cout<<rans;
	return 0;
}
```

---

## 作者：opened (赞：1)

 _~~**蓝题+1**~~_ 

设有图G(V,E)

- 子图：G′(V′E′)是图G(V,E)的子图当且仅当
		V′∈V,E′∈E

- 诱导子图：G′(V′E′)是图G(V,E)的子图当且仅当

		 V′∈V,E′={∀u∈V′,v∈V′(u,v)∈E′}

- 团：G′(V′E′)是图G(V,E)的子图，且G′(V′E′)是关于V′的完全图

- 极大团：G′(V′E′)是团，且不是其他团的子集。

- 最大团：G′(V′E′)是极大团，且点数最多。

- 最大独立集：图G′是G的子集且G′中所有点不相邻，取最大点集大小的图G′为图G的最大独立集。

- 弦：连接环中不相邻的两个点的边。

- 弦图：一个无向图称为弦图当图中任意长度大于3的环都至少有一个弦

- 单纯点：设N(v)表示与点v相邻的点集。一个点称为单纯点当且仅当v+N(v)的诱导子图为一个团。

    	引理：任何一个弦图都至少有一个单纯点，不是完全图的弦图至少有两个不相邻的单纯点。

1. 完美消除序列：一个点的序列(每个点出现且恰好出现一次)v1,v2,…,vn满足vi在vi,vi+1,…,vn的诱导子图中为一个单纯点。

    	 定理：一个无向图是弦图当且仅当它有一个完美消除序列。

- 弦图的最大独立集：得到**完美消除序列**，对于一个点，由于前面的已经考虑，而后面的点与它不能同时被选择，而且后面的点还可能影响其它与之相邻的点，因此**从前往后贪心**即可。


Talk is cheap, show me the code.
------------

    #include<iostream>
    #include<cstdio>
    #include<vector>
    using namespace std;
    const int N=300;
    struct node{int v,next;}G[N*2];
    int n,m,cnt,b_size,head[N],vis1[N],vis2[N],V[N],num[N];
    vector<int>a[N];
    void addedge(int u,int v){
        G[++cnt].v=v;
        G[cnt].next=head[u];
        head[u]=cnt;
    }                                //链式前向星
    int main(){
        scanf("%d%d",&n,&m);
        for(int i=1;i<=m;i++){
            int u,v;
            scanf("%d%d",&u,&v);
            addedge(u,v);
            addedge(v,u);
        }
        for(int i=1;i<=n;i++) a[0].push_back(i);
        for(int k=1;k<=n;k++){        //从前往后
            int u,flag=0;
            while(!flag){
                int x=a[b_size].size();
                for(int i=x;i;i--)     //从后往前
                    if(vis1[a[b_size][i-1]]) a[b_size].pop_back();
                    else {
                        u=a[b_size][i-1];
                        flag=1;
                        break;
                    }
                if(!flag) b_size--;
            }
            V[k]=u;
            vis1[u]=1;
            for(int i=head[u];i;i=G[i].next){
                int v=G[i].v;
                if(!vis1[v]){
                    a[++num[v]].push_back(v);
                    b_size=max(b_size,num[v]);
                }
            }
        }
        int ans=0;
        for(int k=n;k;k--){           //从后往前！
            int u=V[k];
            if(!vis2[u]){
                ans++;
                vis2[u]=1;
                for(int i=head[u];i;i=G[i].next){
                    int v=G[i].v;
                    vis2[v]=1;
                }
            }
        }
        printf("%d\n",ans);
        return 0;
    }

---

## 作者：JiaY19 (赞：0)

弦图裸题。

### 思路

求一张图的最大独立集。

考虑题目给定的图是一张弦图。

那么就有一些十分优美的性质。

考虑它的完美消除序列。

我们从前往后染色。

染色的数量即图的最大独立集点的个数。

如何~~证明~~感性理解。

考虑对于一个团而言，必然只会有一个点在最大独立集中。

那么在完美消除序列上。

第一个点所连的边形成了一个团，我们贪心的把第一个点给选中，然后循环往复的操作，那么必然是最优的。

代码很简单，[code](https://www.luogu.com.cn/record/105825538)。

---


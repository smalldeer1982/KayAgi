# [TJOI2008] 公共子串

## 题目描述

一个字符串的子串是在这个串基础上去掉0个或者若干个字符所形成的，例如abc, aa和abbc都是字符串aabbcc的子串，而aba不是。 现给你三个字符串，请问他们三个共同含有多少种子串（不算空串）?

注意： 有些相同的公共子串尽管出现在不同的位置，但仍算1种，详见样例。


## 说明/提示

3个字符串共有的公共子串有： “a”, “p”, “ap”, “pa”, “aa”, “apa”。 其中子串 “a” 有多个，但由于统计的是公共子串种类，所以 “a” 只算1种子串。


100%的数据中，字符串的长度不超过100。字符串中只含有小写字母。




## 样例 #1

### 输入

```
apartment
apache
approach
```

### 输出

```
6```

# 题解

## 作者：NZSWW33OMF2GC (赞：57)

[公共子串 - 洛谷](https://www.luogu.com.cn/problem/P3856)

For better reading experience, click [here](https://www.luogu.com.cn/blog/x4Cx58x54/solution-p3856).

---

之前的几篇题解用到了‘重新统计’这样的步骤，思维量较大（萌新我现在也没太搞懂），于是我自己鼓捣了一下，提出一种比较简单的思路。这篇题解给出完整的论证过程和转移方程，给各位作为参考。

---

求三个字符串中互不相同的公共子串数目。

三个字符串分别记为 `a`、`b`、`c`，下标均起始于 1。对三个字符串中的每一个字符，计算它之前一次出现的位置，存入对应的 `last` 数组中（若该字符之前未出现过则存入 0）。

`f[i][j][k]` 代表 `a[1..i]`、`b[1..j]` 和 `c[1..k]` 上互不相同的公共子串数目（即子问题的解）。下面动态规划计算 `f`。

当 `a[i] == b[j] == c[k] == ch` 时，会产生新的公共子串。此时考虑将 `ch` 接到之前出现的所有公共子串之后，这样就产生了与之前数量相同的新公共子串，再加上 `ch` 本身也是新公共子串，故此时有

$$
f_{i,\,j,\,k} = 2\cdot f_{i-1,\,j-1,\,k-1} + 1.
$$

但是上面没有考虑重复的情况。哪一部分公共子串是重复的呢？为了方便，我们先将 `ch` 在三个字符串中上一次出现的位置 `lasta[a[i]]`、`lastb[b[j]]` 和 `lastc[c[k]]` 分别记为 `li`、`lj`、`lk`。那么在计算 `f[li][lj][lk]` 和 `f[i][j][k]` 时均会在 `f[li-1][lj-1][lk-1]` 所代表的公共子串末尾接上 `ch`，这部分就是重复的。还有 `ch` 本身亦重复，故当 `li`、`lj` 和 `lk` 均不为 0 时，需要考虑重复数。

$$
f_{i,\,j,\,k} = 2\cdot f_{i-1,\,j-1,\,k-1} - f_{li-1,\,lj-1,\,lk-1}.
$$

若 `a[i]`、`b[j]`、`c[k]` 不相等，那么没有新的公共子串产生，此时直接将之前的值继承过来即可。但问题在于，如何定义“之前”呢？直接复制 `f[i-1][j-1][k-1]` 显然是错的，因为未考虑在 `f[i-1][j][k]` 等处产生的新公共子串。很容易可以想到容斥原理：

$$
\begin{aligned}
f_{i,\,j,\,k} = &\phantom{+} f_{i-1,\,j,\,k} + f_{i,\,j-1,\,k} + f_{i,\,j,\,k-1}\\
&- f_{i-1,\,j-1,\,k} - f_{i,\,j-1,\,k-1} - f_{i-1,\,j,\,k-1}\\
&+ f_{i-1,\,j-1,\,k-1}.
\end{aligned}
$$

---

下面附上核心代码：

```cpp
for(int i = 1; i <= alen; ++i)
    for(int j = 1; j <= blen; ++j)
        for(int k = 1; k <= clen; ++k)
            if (a[i] == b[j] && b[j] == c[k])
            {
                f[i][j][k] = f[i-1][j-1][k-1]*2 + 1;
                if (lasta[i] && lastb[j] && lastc[k])
                    f[i][j][k] -= f[lasta[i]-1][lastb[j]-1][lastc[k]-1] + 1;
            }
            else
            {
                f[i][j][k] = f[i-1][j][k] + f[i][j-1][k] + f[i][j][k-1]
                           - f[i-1][j-1][k] - f[i][j-1][k-1] - f[i-1][j][k-1]
                           + f[i-1][j-1][k-1];
            }
```

---

我尽量在每一篇题解中做到语言通俗、思路清晰、逻辑严密。如果您从中得到了启发的话，一个小小的赞是对我最大的肯定！


---

## 作者：Ginger_he (赞：6)

# 题目描述
求 $3$ 个字符串有多少个不同的公共子序列，不包括空序列。
# 题解
序列自动机模板题。$dp_{i.c}=\min\left\{j\mid j>i,s_j=c\right\}$ 表示从第 $i$ 个位置开始字符 $c$ 在 $s$ 中下一次出现的位置。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,m,k,x[105][30],y[105][30],z[105][30];
ll f[105][105][105];
char a[105],b[105],c[105];
ll dfs(int u,int v,int w)
{
	ll res=1;
	if(f[u][v][w]!=-1)
		return f[u][v][w];
	for(int i=1;i<=26;i++)
	{
		if(x[u][i]&&y[v][i]&&z[w][i])
			res+=dfs(x[u][i],y[v][i],z[w][i]);
	}
	return f[u][v][w]=res;
}
void pre(int t,int p[105][30],char s[105])
{
	for(int i=t-1;i>=0;i--)
	{
		for(int j=1;j<=26;j++)
			p[i][j]=p[i+1][j];
		p[i][s[i+1]-96]=i+1;
	}
}
int main()
{
	memset(f,-1,sizeof(f));
	scanf("%s%s%s",a+1,b+1,c+1);
	pre(strlen(a+1),x,a);
	pre(strlen(b+1),y,b);
	pre(strlen(c+1),z,c);
	printf("%lld\n",dfs(0,0,0)-1);
	return 0;
}
```


---

## 作者：DarkClever (赞：4)

## 问题引入

> 如果我们需要一种算法，使其可以将一个字符串的所有子序列表示为一个 DAG（即有向无环图），我们该如何构建？

## 构建

钦定 $n$ 为字符串的长度，$\Sigma$ 为字符集，$S$ 为字符串，且 $S$ 只会包含小写字母。

我们定义 $nxt_{i,j} (i \leq n,j \in \Sigma)$ 为在 $i$ 位置之后第一个 $j$ 字符出现的位置。

那么我们很容易得出构建方法：

```cpp
struct SequentialAutomaton {
    int nxt[N][M];
    void init(string s){
        for(int i=s.length()-1;i>=0;i--){//从后往前遍历
            for(int j=1;j<=26;j++)nxt[i][j] = nxt[i+1][j];//将nxt数组从 i+1 转移至 i
            if(s[i] <= 'z' && 'a' <= s[i])nxt[i][s[i] - 'a' + 1] = i + 1;//并且更新状态，从下一个字符转移过来
            //我的nxt数组是从 1 开始的，所以从 s_i（对应了字符串第 i+1 个字符）转移
        }
    }
};
```


时间复杂度为 $O(n|\Sigma|)$，空间复杂度亦为 $O(n|\Sigma|)$。

显然，$nxt_i$ 只会指向 $j(j>i)$，所以这是一个 DAG。

构建完这个 DAG 后，它能做什么呢？

## 应用

### 寻找子序列/子序列匹配

这个十分简单，只需要在 DAG 上贪心的往后跳即可，因为如果 $i$ 无法跳到 $k$，那么 $j(j>i)$ 也一定无法跳到 $k$。

```cpp
vector<int> Find(string x){
    int pt = 0,i = 0;//pt为当前匹配到的子序列中的位置，i当前字符串s1中跳到的位置
    vector<int> xl;//储存答案的vector
    while(pt!=x.length()){
        if(s1.nxt[i][x[pt] - 'a' + 1])//如果能跳，就贪心的跳 
            i = s1.nxt[i][x[pt] - 'a' + 1],pt++,xl.push_back(i);
        else
            return vector<int>();//如果找不到返回一个空的vector
    }
    return xl;//返回答案
}
```


时间复杂度为 $O(l)$，其中 $l$ 为 $x$ 的长度。

### 寻找一个子序列的出现次数

很简单，只要我们除了向后跳之外，我们也可以向下一个相同的找，就可以遍历到他每一个出现的情况。

```cpp
int dfs(string x,int i = 0,int pt = 0){
    int anss = 0;
    //有两种可能
    //第1种，向后跳，此时将pt++
    if(pt != x.length() && s1.nxt[i][x[pt] - 'a' + 1]){
        anss += dfs(x,s1.nxt[i][x[pt] - 'a' + 1],pt+1);
    }
    //第2种，跳到下一个跟自己一样的
    if(pt>0 && s1.nxt[i][x[pt - 1] - 'a' + 1]){
        anss += dfs(x,s1.nxt[i][x[pt - 1] - 'a' + 1],pt);
    }
    if(pt == x.length()){
        //找完了
        return anss+1;
    }
    //此处注意到自己是由 pt-1 跳过来的
    return anss;
}
```


然后呢，我们发现时间复杂度是极高的，很容易**超出时间限制**，所以我们需要进行优化。

这个时候，我们就需要使用——记忆化搜索！

借助记忆化搜索，我们只用多开一个 $O(nl)$ 的数组，就可以将时间复杂度压缩到 $O(nl)$ 以下。

```cpp
int dfs(string x,int i = 0,int pt = 0){
    if(f[i][pt]){
        return f[i][pt];
    }
    int anss = 0;
    //有两种可能
    //第1种，向后跳，此时将pt++
    if(pt != x.length() && s1.nxt[i][x[pt] - 'a' + 1]){
        anss += dfs(x,s1.nxt[i][x[pt] - 'a' + 1],pt+1);
    }
    //第2种，跳到下一个跟自己一样的
    if(pt>0 && s1.nxt[i][x[pt - 1] - 'a' + 1]){
        anss += dfs(x,s1.nxt[i][x[pt - 1] - 'a' + 1],pt);
    }
    if(pt == x.length()){
        //找完了
        return anss+1;
    }
    //此处注意到自己是由 pt-1 跳过来的
    f[i][pt] = anss;//记忆答案
    return anss;
}
```


### 统计本质不同子序列数量

我们可以考虑直接深搜，统计所有可能的子序列，并且使用记忆化搜索即可。

```cpp
int f[N];
int dfs(int x){
    if(f[x])//还是记忆化搜索
        return f[x];
    for(int i=1;i<=26;i++)
        if(s1.nxt[x][i]) 
            f[x] += dfs(s1.nxt[x][i]);//进行转移即可
    if(x)//这里的判断是为了不统计空序列
        f[x]++;
    return f[x];
}
```


时间复杂度是 $O(n|\Sigma|)$，非常简单。

### 统计多个字符串之间公共子串数量

例题：P1819 和 P3856

终于进入正题了，这两道题除了取模和有一题要多输入一个长度之外没有区别，就一起讲了。

我们考虑直接对**统计本质不同子序列数量**进行改造，如果 $s1.nxt_{x,i} \land s2.nxt_{y,i} \land s3.nxt_{z,i}$，则将 $x,y,z$ 分别跳向 $s1.nxt_{x,i},s2.nxt_{y,i},s3.nxt_{z,i}$ 即可。

当然，我们仍然要使用记忆化搜索优化，空间复杂度为 $O(n^3)$，时间复杂度为 $O(n^3|\Sigma|)$。

```cpp
int f[N][N][N];
int dfs(int x,int y,int z){
    if(f[x][y][z])//记~忆~化~搜~索~
        return f[x][y][z];
    for(int i=1;i<=26;i++)
        if(s1.nxt[x][i] && s2.nxt[y][i] && s3.nxt[z][i]) 
            f[x][y][z] += dfs(s1.nxt[x][i] , s2.nxt[y][i] , s3.nxt[z][i]);
    if(x && y && z)//为了不统计空序列（当然你也可以在输出答案时减一）
        f[x][y][z]++;
    return f[x][y][z];
}
```


好了，序列自动机以及这道题目就讲到这里 byebye~

---

## 作者：yzysdTNT (赞：3)

像这种求公共什么玩意的好像基本都是 DP……
### 思路

如上，我们可以~~大胆猜测~~得出这题是 DP。
设 $f_{i,j,k}$ 表示第一个字符串前 $i$ 个、第二个字符串前 $j$ 个、第三个字符串前 $k$ 个字符中**不重复**的字串数量。  
可以得到一个特殊的转移：当 $a_i = b_j = c_k$ 时，当前的子串数量就是本来的所有公共子串加上在每一个后面再接一个当前字符，再加上这个字符本身，即 $f_{i,j,k} = f_{i-1,j-1,k-1} \times 2 + 1$。但此时如果这个字符在三个字符串中都出现过就会产生重复，因此我们预处理出**每个位置上**的字符在前面最后一次出现的位置，记为 $lsta_i$、$lstb$、$lstc$，则重复的内容就是 $f_{lsta_i-1,lstb_j-1,lstc_k-1} + 1$，因为这一部分字串后已经接过这个字符了，再加上它本身就是上式。  
其它情况下就是继承上一个状态，但是要用到容斥，贴一张韦恩图：
![](https://cdn.luogu.com.cn/upload/image_hosting/bibwr3hu.png)
所以可以得到一个很长的~~弑子~~式子，直接看代码吧。

---

## [CODE](https://www.luogu.com.cn/record/180612785)

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 105,M = 30;
int n,m,s,f[N][N][N],lsta[N],lstb[N],lstc[N];
char a[N],b[N],c[N];
signed main(){
	cin >> (a + 1) >> (b + 1) >> (c + 1);
	n = strlen(a + 1);
	m = strlen(b + 1);
	s = strlen(c + 1);
	for(int i = 1;i <= n;i++){
		for(int j = i - 1;j;j--){
			if(a[i] == a[j]){
				lsta[i] = j;
				break;
			}
		}
	}
	for(int i = 1;i <= m;i++){
		for(int j = i - 1;j;j--){
			if(b[i] == b[j]){
				lstb[i] = j;
				break;
			}
		}
	}
	for(int i = 1;i <= s;i++){
		for(int j = i - 1;j;j--){
			if(c[i] == c[j]){
				lstc[i] = j;
				break;
			}
		}
	}//如上是预处理lst
	for(int i = 1;i <= n;i++){
		for(int j = 1;j <= m;j++){
			for(int k = 1;k <= s;k++){
				if(a[i] == b[j] && b[j] == c[k]){
					f[i][j][k] = 2 * f[i - 1][j - 1][k - 1] + 1; //特殊转移
					if(lsta[i] && lstb[j] && lstc[k]){
						f[i][j][k] -= f[lsta[i] - 1][lstb[j] - 1][lstc[k] - 1] + 1; //去重
					} 
				}
				else{
					f[i][j][k] = f[i - 1][j][k] + f[i][j - 1][k] + f[i][j][k - 1]
					 - f[i - 1][j - 1][k] - f[i - 1][j][k - 1] - f[i][j - 1][k - 1]
					 + f[i - 1][j - 1][k - 1]; //继承
				}
			}
		}
	}
	cout << f[n][m][s];
	return 0;
} 
```

---

## 作者：elijahqi (赞：3)

方案数可能超int。这题坑了好久。f[i][j][k]表示s1前i个字母，s2前j个字母，s3前k个字母所包含的本质不同的公共子串的个数。为了避免重复，我们每次做i,j,k时都重新统计所有的本质不同的公共子串。怎么统计呢？枚举公共子串的结尾为a…z，假设当前枚举a，找到目前为止的每一个串的最后一个a的位置，为了避免重复，我们把所有满足以a结尾的公共子串的结尾都当做是这个a，则个数为f[ii-1][jj-1][kk-1]+1。每次都重新统计，最后答案就是f[n1][n2][n3]。

举个例子 ：要求f[i][j][k] 枚举b时 找到最后一次出现b的位置 f[i'][j'][k'] 那么 前面有的bb aa ab cd等串

都都会加上现在的b形成新的串 bbb也是一个新的子串  那么c d 等结尾的就是后面继续循环的时候可以找到

```cpp
#include<cstdio>
#include<cstring>
#define N 110
long long data[N][N][N];
char a[N],b[N],c[N];
int last1[N][30],last2[N][30],last3[N][30];
void f(int i,int j,int k){
   long long ans=0;
   //data[i][j][k]=0;
    for (int z=0;z<=25;++z){
        int x1=last1[i][z],x2=last2[j][z],x3=last3[k][z];
        if (x1==0||x2==0||x3==0) continue;
        if (data[x1-1][x2-1][x3-1]==-1) f(x1-1,x2-1,x3-1);
        ans+=data[x1-1][x2-1][x3-1]+1;    
    }
    data[i][j][k]=ans;
}
int main(){
   // freopen("3856.in","r",stdin);
    scanf("%s%s%s",a+1,b+1,c+1);
    int n=strlen(a+1),m=strlen(b+1),k=strlen(c+1);
    for (int i=1;i<=n;++i) 
        for (int j=0;j<26;++j) {last1[i][j]=last1[i-1][j];if(a[i]=='a'+j) last1[i][j]=i;}
    for (int i=1;i<=m;++i)
        for (int j=0;j<26;++j){ last2[i][j]=last2[i-1][j];if (b[i]=='a'+j) last2[i][j]=i;}
    for (int i=1;i<=k;++i)
        for (int j=0;j<26;++j){ last3[i][j]=last3[i-1][j];if (c[i]=='a'+j) last3[i][j]=i;}
    memset(data,0xff,sizeof(data));
    //data[0][0][0]=1;
    f(n,m,k);
    printf("%lld",data[n][m][k]);
    return 0;
}
···


http://www.elijahqi.win/2017/08/17/luogu3856-tjoi2008%e5%85%ac%e5%85%b1%e5%ad%90%e4%b8%b2/


---

## 作者：Jμdge (赞：2)

白痴了，只会做 SB 题了，这题居然没想出来...


# noteskey

考虑一下数据范围里说字符串长度只有 100 ，然后是三个字符串，那么三层的 dp 也就是 $n^3$


然后枚举字符转移套个常数 26 

很稳，代码也很短...

# code 
```
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define ll long long
using namespace std;
const int M=103;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline void reads(string& s){ char c=getchar();
	for(;!isalpha(c);c=getchar()); s=" ";
	for(;isalpha(c);c=getchar()) s+=c;
} int n1,n2,n3,las[4]['z'+1];
ll f[M][M][M]; string s1,s2,s3;
int main(){
	reads(s1),reads(s2),reads(s3); //毒瘤的字符串读优
	n1=s1.length()-1;
	n2=s2.length()-1;
	n3=s3.length()-1;
	fp(i,1,n1){ las[1][s1[i]]=i,memset(las[2],0,sizeof las[2]);
		fp(j,1,n2){ las[2][s2[j]]=j,memset(las[3],0,sizeof las[3]);
			fp(k,1,n3){ las[3][s3[k]]=k; 
				fp(x,'a','z'){ int ii=las[1][x],jj=las[2][x],kk=las[3][x];
					if(ii&&jj&&kk) f[i][j][k]+=f[ii-1][jj-1][kk-1]+1;
				}
			}
		}
	}
	return !printf("%lld\n",f[n1][n2][n3]);
}
```



---

## 作者：__liujy (赞：1)

## 零. 前言
- 前置知识：容斥原理，动态规划。
- 所用数组：$dp_{i,j,k}$ 表示第一个字符串前 $i$ 个，第二个字符串前 $j$ 个，第三个字符串前 $k$ 个所能组成的不重复的公共子序列数；$lsta_{i}$ 表示在第一个字符串中第 $i$ 个字符最后出现的位置，如果没有就为 $0$；$lstb_{i}$ 表示在第二个字符串中第 $i$ 个字符最后出现的位置，如果没有就为 $0$；$lstc_{i}$ 表示在第三个字符串中第 $i$ 个字符最后出现的位置，如果没有就为 $0$。
- 注意事项：下文中 $lsta_{i},lstb_{j},lstc_{k}$ 的值均不为 $0$；$a,b,c$ 分别为第一、二、三个字符串。
## 壹. 思路
考虑以下两种情况：

- $a_{i}=b_{j}=c_{k}$：有两种方式，第一种是在本来的字符串上都加上这一位，方案数为 $dp_{i-1,j-1,k-1} \times 2$；第二种就是直接另外开一个字符串，方案数为 $1$，综上所述 $dp_{i,j,k}=dp_{i-1,j-1,k-1} \times 2+1$。不过还有一种可能，就是有重复的，重复的部分就是和 $a_{i},b_{j},c_{k}$ 相同的部分，编号就是 $lsta_{i},lstb_{i},lstc_{i}$，就是要减去 $dp_{lsta_{i}-1,lstb_{i}-1,lstc_{i}-1}+1$，这个地方的推导与之前的类似。
- $a_{i},b_{j},c_{k}$ 这三个字符不完全相同：当前状态也就是需要继承上一个状态，因为有三个，因此会有重复的地方，需要用容斥计算，而上面的不用容斥是因为只有那一种，画不了。既然是继承上一个状态，那么所继承的状态就是 $dp_{i-1,j,k}+dp_{i,j-1,k}+dp_{i,j,k-1}$，但是这里面会有重复的，重复的和就是 $dp_{i-1,j-1,k}+dp_{i-1,j,k-1}+dp_{i,j-1,k-1}$，可是这个重复的里面又会有多减的，也就是 $dp_{i-1,j-1,k-1}$，综上所述 $dp_{i,j,k}=dp_{i-1,j,k}+dp_{i,j-1,k}+dp_{i,j,k-1}-(dp_{i-1,j-1,k}+dp_{i-1,j,k-1}+dp_{i,j-1,k-1})+dp_{i-1,j-1,k-1}$。
## 贰. 代码
```cpp
// P3856 [TJOI2008] 公共子串
#include<bits/stdc++.h>
const int MAXL=105;
typedef long long LL;
int lsta[MAXL],lstb[MAXL],lstc[MAXL];
char a[MAXL],b[MAXL],c[MAXL];
LL dp[MAXL][MAXL][MAXL];
int main()
{
    while(a[1]<'a'||a[1]>'z')
        scanf("%s",(a+1));
    while(b[1]<'a'||b[1]>'z')
        scanf("%s",(b+1));
    while(c[1]<'a'||c[1]>'z')
        scanf("%s",(c+1));
    int lena=strlen(a+1),
        lenb=strlen(b+1),
        lenc=strlen(c+1);
    for(int i=1;i<=lena;i++)
        for(int j=i-1;j>=1;j--)
            if(a[i]==a[j])
            { lsta[i]=j; break; }
    for(int i=1;i<=lenb;i++)
        for(int j=i-1;j>=1;j--)
            if(b[i]==b[j])
            { lstb[i]=j; break; }
    for(int i=1;i<=lenc;i++)
        for(int j=i-1;j>=1;j--)
            if(c[i]==c[j])
            { lstc[i]=j; break; }
    for(int i=1;i<=lena;i++)
        for(int j=1;j<=lenb;j++)
            for(int k=1;k<=lenc;k++)
                if((a[i]==b[j])&&(b[j]==c[k]))
                {
                    dp[i][j][k]=(dp[i-1][j-1][k-1]<<1LL)+1;
                    if((lsta[i]>0)&&(lstb[j]>0)&&(lstc[k]>0))
                        dp[i][j][k]-=dp[lsta[i]-1][lstb[j]-1][lstc[k]-1]+1;
                }
                else
                    dp[i][j][k]=dp[i-1][j][k]+dp[i][j-1][k]+dp[i][j][k-1]
                               -dp[i-1][j-1][k]-dp[i-1][j][k-1]-dp[i][j-1][k-1]
                               +dp[i-1][j-1][k-1];
    printf("%lld\n",dp[lena][lenb][lenc]);
    return 0;
}
```

---

## 作者：strcmp (赞：1)

题目大意：给定 $3$ 个只含有英文小写字母的字符串，求公共子序列数量。

------------

子序列考虑维护子序列自动机。

因为值域是 $[0,\,25]$ 的，所以我们不用像模板题那样开个 `vector` 或者主席树就能维护子序列自动机。

令 $f_{i,\,j,\,k}$ 为第 $k$ 个字符串第 $i$ 个位置之后第一个字符与第 $i$ 个位置的字符相同的位置。求解可以倒序枚举一遍，做到 $\Theta(n|\Sigma|)$ 的复杂度。

设 $dp_{i,\,j,\,k}$ 为以到第一个字符串的第 $i$ 个位置，第二个字符串的第 $j$ 个位置和第三个字符串的第 $k$ 个位置结尾的公共子序列数。

则枚举下一个相同的字符 $c$，令 $i' \leftarrow f_{i,\,c,\,0},\,j' \leftarrow f_{j,\,c,\,1},\,k \leftarrow f_{k,\,c,\,2}$。

则有转移：$dp_{i,\,j,\,k} \leftarrow dp_{i,\,j,\,k} + dp_{i',\,j',\,k'}$。满足条件 $i',\,j',\,k' \ne 0$。

最后令 $dp_{i,\,j,\,k}$ 加上 $[i \ne 0 \wedge j \ne 0 \wedge k \ne 0]$ 即可，答案为 $dp_{0,\,0,\,0}$。

时间复杂度 $\Theta(n^3)$，实现上使用记忆化搜索。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const int maxn = 1e4 + 10;
int n; char a[maxn], b[maxn], c[maxn];
int f[maxn][27][3]; ll dp[155][155][155];
inline ll dfs(int x, int y, int z) {
    ll& v = dp[x][y][z];
    if (v != -1) return v; v = 0;
    for (int i = 0; i <= 25; i++) {
        int tx = f[x][i][0], ty = f[y][i][1], tz = f[z][i][2];
        if (tx && ty && tz) v = v + dfs(tx, ty, tz);
    }
    return v += (x || y || z);
}
int main() {
    memset(dp, -1, sizeof(dp));
    scanf("%s%s%s", a + 1, b + 1, c + 1); n = max({ strlen(a + 1), strlen(b + 1), strlen(c + 1) }); 
    for (int i = n; i >= 1; i--) {
        for (int j = 25; j >= 0; j--) {
            for (int k = 0; k <= 2; k++) f[i - 1][j][k] = f[i][j][k];
        }
        if (a[i] != '\0') f[i - 1][a[i] - 'a'][0] = i;
        if (b[i] != '\0') f[i - 1][b[i] - 'a'][1] = i;
        if (c[i] != '\0') f[i - 1][c[i] - 'a'][2] = i;
    }
    printf("%lld\n", dfs(0, 0, 0));
    return 0;
}
```

---

## 作者：XiaoQuQu (赞：1)

一道萌萌题的双倍经验。

设 $f_{i,j,k}$ 表示从第一个字符串的 $i$ 位置开始，第二个字符串的 $j$ 位置开始，第三个字符串的 $k$ 位置开始，剩下的公共子序列的个数。

对于每个字符串，预处理 $nxt_{i,ch}$ 表示在 $i$ 之后，字符 $ch$ 第一次出现的位置，这个东西的预处理是简单的：

1. $s_{i+1}=ch$，有 $nxt_{i,ch}=i+1$；
2. $s_{i+1}\ne ch$，有 $nxt_{i,ch}=nxt_{i+1,ch}$。

如果当 $i$ 后无 $ch$ 字符，则认为 $nxt_{i,ch}=+\infty$。

这样，我们就可以很方便的转移，对于 $f_{i,j,k}$，枚举下一个相同的字符 $ch$，有 $f_{i,j,k}=\sum\limits_{ch}f_{nxt1_{i,ch},nxt2_{j,ch},nxt3_{k,ch}}$。

```cpp
const int MAXN = 155, inf = 1e18;
char s[4][MAXN];
int nxt[4][MAXN][26], dp[MAXN][MAXN][MAXN];

void mknxt(int x, int n) {
	for (int i = 0; i < 26; ++i) nxt[x][n][i] = inf;
	for (int i = n - 1; i >= 0; --i) {
		for (int j = 0; j < 26; ++j) nxt[x][i][j] = nxt[x][i + 1][j];
		nxt[x][i][s[x][i + 1] - 'a'] = i + 1;
	}
}

int dfs(int x, int y, int z) {
	if (dp[x][y][z]) return dp[x][y][z];
	int ret = 1;
	for (int i = 0; i < 26; ++i) {
		int p1 = nxt[1][x][i], p2 = nxt[2][y][i], p3 = nxt[3][z][i];
		if (p1 == inf || p2 == inf || p3 == inf) continue;
		ret = (ret + dfs(p1, p2, p3));
	}
	return dp[x][y][z] = ret;
}

void work() {
	for (int i = 1; i <= 3; ++i) cin >> (s[i] + 1);
	mknxt(1, strlen(s[1] + 1)); mknxt(2, strlen(s[2] + 1)); mknxt(3, strlen(s[3] + 1));
	cout << (dfs(0, 0, 0) - 1) << endl;
}
```


---

## 作者：sodalyghat (赞：0)

### 分析
子序列的题，先建出子序列自动机，然后考虑在自动机上 DP 方案。设 $f_{i,j,k}$ 代表分别在三个自动机上匹配到了哪里，然后枚举所有后继状态转移即可。不考虑空串，最后答案要减一。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace Luo_ty{
	const int MAXN = 155;
	char x[MAXN], y[MAXN], z[MAXN];
	int xam[MAXN][26], yam[MAXN][26], zam[MAXN][26];
	int t[26];
	long long f[MAXN][MAXN][MAXN];
	long long dfs(int i, int j, int k){
		if(f[i][j][k]) return f[i][j][k];
		f[i][j][k] = 1;
		for(int op = 0;op < 26;op++){
			if(xam[i][op] && yam[j][op] && zam[k][op]){
				f[i][j][k] += dfs(xam[i][op], yam[j][op], zam[k][op]);
			}
		}
		return f[i][j][k];
	}
	int main(){
		int n, m, l;
		scanf("%s%s%s", x + 1, y + 1, z + 1);
		n = strlen(x + 1);
		m = strlen(y + 1);
		l = strlen(z + 1);
		for(int i = n;~i;i--){
			for(int j = 0;j < 26;j++){
				xam[i][j] = t[j];
			}
			if(i) t[x[i] - 'a'] = i;
		}
		for(int i = 0;i < 26;i++) t[i] = 0;
		for(int i = m;~i;i--){
			for(int j = 0;j < 26;j++){
				yam[i][j] = t[j];
				
			}
			if(i) t[y[i] - 'a'] = i;
		}
		for(int i = 0;i < 26;i++) t[i] = 0;
		for(int i = l;~i;i--){
			for(int j = 0;j < 26;j++){
				zam[i][j] = t[j];
			}
			if(i) t[z[i] - 'a'] = i;
		}
		printf("%lld", dfs(0, 0, 0) - 1);
		return 0;
	}
}
int main(){
	return Luo_ty::main();
}//International Milan is the best team.
```

---

## 作者：OldDriverTree (赞：0)

# Solution

对三个串建出子序列自动机，考虑在子序列自动机上 $\text{DP}$，设 $f_{x,y,z}$ 表示子序列当前在三个子序列自动机上分别走到了 $x,y,z$ 这三个状态，继续走能形成多少种子序列。

转移就为 $f_{x,y,z}=1+\sum\limits_{c\in\Sigma} f_{nxt_{0,x,c},nxt_{1,y,c},nxt_{2,z,c}}$。

注意这个值是包含空子序列的，所以最后答案要减去 $1$。

时间复杂度为 $O(n^3\vert\Sigma\vert)$。
# Code
```c++
//when you use vector or deque,pay attention to the size of it.
//by OldDirverTree
#include<bits/stdc++.h>
//#include<atcoder/all>
#define P pair<int,int>
#define int long long
#define mid (l+r>>1)
using namespace std;
//using namespace atcoder;
const int N=101;
int nxt[3][N][26];
int n,f[N][N][N];
char s[3][N];

int read() {
	int x=0; bool f=true; char c=0;
	while (!isdigit(c) ) f&=(c!='-'),c=getchar();
	while (isdigit(c) ) x=(x<<3)+(x<<1)+(c&15),c=getchar();
	return f?x:-x;
}
int solve(int x,int y,int z) {
	if (f[x][y][z]) return f[x][y][z]; f[x][y][z]=1;
	for (int i=0;i<26;i++) if (nxt[0][x][i]&&nxt[1][y][i]&&nxt[2][z][i])
	f[x][y][z]+=solve(nxt[0][x][i],nxt[1][y][i],nxt[2][z][i]); return f[x][y][z];
}
main()
{
	for (int i=0;i<3;i++)
	{
		scanf("%s",s[i]+1),n=strlen(s[i]+1);
		for (int j=n;j;j--) {
			for (int k=0;k<26;k++)
			nxt[i][j-1][k]=nxt[i][j][k];
			nxt[i][j-1][s[i][j]-'a']=j;
		}
	}
	printf("%lld",solve(0,0,0)-1);
	return 0;
}
```

---

## 作者：cpu_gal (赞：0)

# P3856 题解

这其实是一道序列自动机的模板题。唯一不同的是，我们需要求多个不同串的公共子序列。

显然，我们可以对这三个串进行 DFS。为了提高效率，避免重复计算，我在此处选用了记忆化搜索进行优化。

我们不妨假设 dp 数组存储的是每一步的计算结果（记忆化数组）。其中，$dp _ {x,y,z}$ 代表我们的三个串分别从    $x,y,z$ 开始的相同子序列个数。对于每次递归，我们都可以去枚举字母表中的每个字母。如果三个字符串都含有当前字母，那么就代表当前的公共子序列长度又增加了，我们可以进行进一步的搜索。

最后，只要当前的 $x,y,z$ 不全等于 $0$
 ，我们就将 $dp _ {x,y,z}$ 加一。
 
## 参考代码

```c
#include <iostream>
#include <cstdio>
#include <string>
#include <memory.h>
using namespace std;
const int MOD = 1e8, N = 160, MAXM = 30, M = 26, NPOS = 0x3f;  // NPOS为数组默认值，查找子串时有用，M为字母表长度
const char ST = 'a';  // 字母表起始字符

class SequenceAM {  // 序列自动机 Sequence Auto Machine
    public:
        int nxt[160][30];  // 核心数组
        string s;  // 当前串

    void init() {  // 初始化序列自动机
        // for (int i = 0; i < 26; i++) this -> nxt[s.size()][i] = NPOS;  // 如果要查找子串，需要进行初始化
        for (int i = this -> s.size() - 1; i >= 0; i--) {  // 倒序初始化
            for (int j = 0; j < M; j++) this -> nxt[i][j] = this -> nxt[i + 1][j];  // 默认等于前一个的值
            this -> nxt[i][this -> s[i] - ST] = i + 1;  // 更新数组
        }
    }

    bool find(string t) {  // 查找函数，此程序中不会使用
        int p = -1, length = t.size();  // p 指针
        for (int i = 0; i < length; i++) {  // 循环每个字符
            p = this -> nxt[p + 1][t[i] - 'a'];  // 指针跳转
            if (p == NPOS) return 0;  // 如果当前值为空（或不存在），返回未找到
        }
        return 1;  // 子串t存在
    }
};
SequenceAM a, b, c;  // 三个串
long long dp[N][N][N];  // 记忆化数组
int n;  // 串长度

long long dfs(int x, int y, int z) {  // 本题核心：深搜
    if (dp[x][y][z]) return dp[x][y][z];  // 记忆化
    for (int i = 0; i < M; i++) {  // 枚举每个字符
        if (a.nxt[x][i] && b.nxt[y][i] && c.nxt[z][i]) {  // 如果同时存在于三个串中
            dp[x][y][z] = (dp[x][y][z] + dfs(a.nxt[x][i], b.nxt[y][i], c.nxt[z][i])) % MOD;  // 继续dfs，并加上它的返回值，记得取余
        }
    }
    if (x || y || z) dp[x][y][z]++;  // 不都为0则加一
    return dp[x][y][z] % MOD;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n;
    cin >> a.s >> b.s >> c.s;  // 输入串
    a.init(); b.init(); c.init();  // 初始化
    cout << dfs(0, 0, 0) << endl;  // 进行dfs
    return 0;
}

```

---

## 作者：xiezheyuan (赞：0)

## 简要题意

给出三个由小写英文字母组成的字符串 $A,B,C$。求这三个字符串的本质不同公共子序列个数。

$1 \leq |A|,|B|,|C| \leq 100$。

## 思路

对于子序列问题，我们先建出子序列自动机。这里简单介绍一下子序列自动机是什么：

对于一个字符串 $S$，令 $F(i,j)$ 为 $[i+1,|S|]$ 中最小的 $k$，使得 $S_k=j$。则 $F(i,j)$ 就是我们要求的子序列自动机。

$F(i,j)$ 有一个 $O(|S|W)$ 的做法（$W$ 为 $S$ 中字符集大小）。我们逆推，不难发现以下结论：

$$
F(i,j)=\begin{cases}
0&i=|S|\\
i+1&(j=S_{i+1})\\
F(i+1,j)&(j\neq S_{i+1})
\end{cases}
$$

注意 $i$ 可以为 $0$。此时指向的是最前的为 $j$ 的位置。可以在字符串开头字符不同时充当相同的开头。

然后就可以 $O(|S|W)$ 递推了。

然后我们回到本题。考虑 dp，令 $f(i,j,k)$ 表示考虑到 $A[i:|A|],B[j:|B|],C[k:|C|]$ 的公共子序列数。那么答案就是 $f(0,0,0)$。

考虑如何转移。如果 $i,j,k$ 后继都有一个相同的字符（至于如何判断相同的字符，可以构造 $A,B,C$ 的子序列自动机 $F,G,H$），那么就是一个公共子序列，可以转移。最后自己本身也是一个子序列（注意当 $i,j,k$ 为 $0$ 时这不是一个子序列）也就是：

$$
f_{i,j,k}=[ijk \neq 0]+\sum_{s=\texttt{a}}^{\texttt{z}}[F(i,s)G(i,s)K(i,s) \neq 0]f(F(i,s),G(i,s),K(i,s))
$$

然后这道题就做完了。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 105;
int ytxy,zyb,zbzQ;
string a,b,c;
int f[N][27],g[N][27],h[N][27],dp[N][N][N];

inline int M(const int &x){
	return x;
}

inline void build(){
	for(int i=ytxy;i;i--){
		for(int j=1;j<=26;j++){
			f[i-1][j]=f[i][j];
		}
		f[i-1][a[i]-'a'+1]=i;
	}
	for(int i=zyb;i;i--){
		for(int j=1;j<=26;j++){
			g[i-1][j]=g[i][j];
		}
		g[i-1][b[i]-'a'+1]=i;
	}
	for(int i=zbzQ;i;i--){
		for(int j=1;j<=26;j++){
			h[i-1][j]=h[i][j];
		}
		h[i-1][c[i]-'a'+1]=i;
	}
}

int F(int i,int j,int k){
	if(dp[i][j][k]) return dp[i][j][k];
	for(int s=1;s<=26;s++){
		if(f[i][s] && g[j][s] && h[k][s]) dp[i][j][k]=M(dp[i][j][k]+F(f[i][s],g[j][s],h[k][s]));
	}
	if(i || j || k) dp[i][j][k]++;
	return dp[i][j][k]=M(dp[i][j][k]);
}

signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>a>>b>>c;
	ytxy=a.size();zyb=b.size();zbzQ=c.size();
	a=" "+a;b=" "+b;c=" "+c;
	build();
	cout<<F(0,0,0)<<'\n';
	return 0;
}
```

---


# [TJOI2009] 战争游戏

## 题目背景

小R正在玩一个战争游戏。游戏地图是一个M行N列的矩阵，每个格子可能是障碍物，也可能是空地，在游戏开始时有若干支敌军分散在不同的空地格子中。每支敌军都可以从当前所在的格子移动到四个相邻的格子之一，但是不能移动到包含障碍物的格子。如果敌军移动出了地图的边界，那么战争就失败了。


## 题目描述

现在你的任务是，在敌军开始移动前，通过飞机轰炸使得某些原本是空地的格子变得不可通行，这样就有可能阻止敌军移出地图边界（出于某种特殊的考虑，你不能直接轰炸敌军所在的格子）。由于地形不同的原因，把每个空地格子轰炸成不可通行所需的炸药数目可能是不同的，你需要计算出要阻止敌军所需的最少的炸药数。


## 说明/提示

对50%的数据，1 ≤ M,N ≤ 10

对100%的数据，1 ≤ M,N ≤ 30

矩阵里的每个数不超过100


## 样例 #1

### 输入

```
4 3
1 2 1
1 10 1
1 0 -1
1 1 1```

### 输出

```
6```

# 题解

## 作者：LeavingZzz (赞：14)

# Solution For P3866  
$\large\mathcal{By\text{ }ShadderLeave}$  

感觉另外两篇题解只讲了实现方法QwQ  
~~那我来口胡一下思维历程~~  
Upd On 2020-5-4：题解界面改了代码缩进又鬼畜了

[$\mathsf{Link\text{ }To\text{ }Problem}$](https://www.luogu.com.cn/problem/P3866)  
[$\color{red}\mathsf{A\text{ }Better\text{ }Reading\text{ }Experience}$](https://www.luogu.com.cn/blog/ShadderLeave/solution-p3866)  

## 题目分析  
这道大意是让我们把敌军封在一个区域内不能逃到边界，实际上就是想让我们切断从敌军当前位置到边界的道路，在这个基础上使用最小的花费。  
画个图大概yy一下就是：  
![](https://cdn.luogu.com.cn/upload/image_hosting/hznsufll.png)  
中间可能较复杂的部分先不想，我们就是想把 $S$ 和 $T$ 之间使用最小的代价砍断使二者不可达（建立超级源点和超级汇点是因为**可能有多支敌军**，同时边界的点也不止一个）。  
这就很自然地想到了网络流的最小割。  

中间部分怎么办呢？  

中间的部分要表示原图的联通情况，同时要能够表现切断某些点的代价，如果直接用朴素的方法：假如两点 $u$、$v$ 相邻，就建立边 $(u,v)$ ,权值为点 $v$ 的点权的一条边，是会有bug的（比如一个点炸两次）。  

那么我们使用一个小技巧：拆点法。  

将一个点 $u$ 拆成一个入点 $u_1$ 以及一个出点 $u_2$,并且在 $u_1$、$u_2$ 之间连一条边，权值为点 $u$ 的点权，这样破坏掉点 $u$ 就相当于切断 $u_1$ 和 $u_2$ 之间连的一条边，切断后所有想通过 $u$ 点的路径会被阻断。  
![](https://cdn.luogu.com.cn/upload/image_hosting/i309dta4.png)  
所以这时候模型基本浮出水面：  
1. 建立超级源点并且和所有的敌军点的入点连接  
2. 将所有的边界点的出点连接到超级汇点  
3. 对于中间的点，每个点的出点连接到相邻点的入点  

接下来是边权的问题  

已经说过每个点的入点和出点之间的边的边权是该点的点权，假如该点是敌人 则不用连边（因为连边表示可以炸掉这一点，不合题意），假如该点已经是障碍，那么更不用连边，而且在相邻点连边的时候也要滤掉这个情况（本来就不是联通的多连边浪费时空）。  

对于相邻点间的边，是不可以断掉的，因为断掉这条边没有实际的意义，它只是用来表示连通性的，断掉就会破坏原图的信息，防止它被断掉就将其边权置为 $inf$。（最小割选中正无穷的边就不会是最小割了）  

对于超级源汇点和具体点之间的连边，同样不可以断掉，置为 $inf$。  

由最小割最大流定理，最小割在数值上等于最大流，直接跑最大流即可。

说完啦。要是还有问题就去代码里面找我吧qwq  

$\large\mathsf{Code}:$  
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
queue <int> q;
const int maxn=1807;//想想自己数组开没开小
const int maxm=40007;
const int inf=0x7f7f7f7f;
int N,M,S,T,all;
struct E{
    int u,v,cf;
}e[maxm];
int first[maxn],nt[maxm],ES=1;//边的编号初始化否则反边不可表示为 i^1
#define cf(i) e[i].cf
inline void addE(int u,int v,int cf)
{
    e[++ES]=(E){u,v,cf};
    nt[ES]=first[u];
    first[u]=ES;
    return ;
}
inline void add(int u,int v,int cf)//网络瘤专用加边
{
    addE(u,v,cf);addE(v,u,0);
    return ;
}
inline int R()
{
    char c;
    int re,f=1;
    while((c=getchar())>'9'||c<'0')
    if(c=='-') f=-1;
    re=c-48;
    while((c=getchar())>='0'&&c<='9')
    re=re*10+c-48;
    return re*f;
}
int cnt[maxn],cur[maxn];
inline bool BFS()//Dinic算法
{
    int u,v;
    memset(cnt,0,sizeof(cnt));
    cnt[S]=1;q.push(S);
    while(!q.empty())
    {
        u=q.front();q.pop();
        for(register int i=first[u];i;i=nt[i])
        {
            v=e[i].v;
            if(!cnt[v]&&cf(i)>0)
            {
                cnt[v]=cnt[u]+1;
                q.push(v);
            }
        }
    }
    return cnt[T]!=0;
}
inline int min_(const int &x,const int &y) {return x<y?x:y;} 
inline int dfs(int u,int f)//Dinic算法
{
    if(u==T) return f;
    int v,d,sum=0;
    for(register int &i=cur[u];i;i=nt[i])
    {
        v=e[i].v;
        if(cnt[v]==cnt[u]+1&&cf(i)>0)
        {
            d=dfs(v,min_(f,cf(i)));
            if(d>0)
            {
                sum+=d;f-=d;
                cf(i)-=d;cf(i^1)+=d;
                if(f<=0) return sum;
            }
        }
    }
    return sum;
}
int m[37][37];
inline int num(int i,int j)//由坐标换算成的点编号
{
    return (i-1)*M+j;//要减一，切记！！切记！！
}
int main()
{
	N=R();M=R();all=N*M;//总点数
	T=2*all+1;
    for(register int i=1;i<=N;i++)
        for(register int j=1;j<=M;j++)
            m[i][j]=R();
    for(register int i=1;i<=N;i++)
        for(register int j=1;j<=M;j++)
        {
			if(m[i][j]==-1) continue;//本来就是障碍啥也不用做
			else if(m[i][j]==0)//特判敌军
				add(num(i,j),num(i,j)+all,inf),add(S,num(i,j),inf);
			else add(num(i,j),num(i,j)+all,m[i][j]);
			//相邻点之间的连边
			if(i>1&&m[i-1][j]!=-1) add(num(i,j)+all,num(i-1,j),inf);
			if(j>1&&m[i][j-1]!=-1) add(num(i,j)+all,num(i,j-1),inf);
			if(i<N&&m[i+1][j]!=-1) add(num(i,j)+all,num(i+1,j),inf);
			if(j<M&&m[i][j+1]!=-1) add(num(i,j)+all,num(i,j+1),inf);
			//特判边界
			if(i==1||j==1||i==N||j==M) add(num(i,j)+all,T,inf);
        }
    int ans=0;
    while(BFS())//Dinic求 最大流/最小割
    {
        memcpy(cur,first,sizeof(first));//当前弧优化
        ans+=dfs(S,inf);
    }
    printf("%d",ans);
    return 0;
}
```
如果这篇题解对您有帮助，请点个赞QwQ  
如果还有问题可以评论或者直接私信窝。  
蟹蟹管理大大审核^_^   

$\LARGE\mathcal{The\text{ }End}$

---

## 作者：闲人 (赞：4)

又是一道网络流的建图题  
[题目传送门](https://www.luogu.com.cn/problem/P3866)  

## 题目分析  

- 有一群敌人“0”，想要走出地图。

- 有一些障碍“-1”，在地图上。

- 你可以通过用炸药把一些地变为障碍，不过每一块地变成障碍所需的炸药不同，具体是这块地的数字，如“2”。

- 你现在要知道阻止敌人走出地图所用的最少炸药是多少。

- 对100%的数据，$1 \le M,N \le 30$  

## 思路  

我们要割断敌人的路，断了的路不能走，又要使所用的炸药最少，想到了什么？  
对！ 最小割！  
又因为最大流=最小割。  
所以 建图+拆点+最大流 就是正解。  

## 亿点问题  

万恶的建图总是我们成功路上的绊脚石，所以我们应该如何建图呢？  
地图上唯一在在动的是敌人，而我们要阻止他到边界。每一个块地有一个值，代表我们那至少要用多少炸药把它变成障碍（要花费多少把流割断）。   
那么图的基本框架就出来了：  

1. 把所有的点拆成两个，中间连起来的流量为这个点的数值。

1. 构建一个超级源点，把所有的敌人的入点连起来。 

1. 把所有的点的出点连上旁边点的入点。

1. 建一个超级汇点，把所有的边界点的出点连起来。


PS.不过敌人和障碍都可以不连边，因为他们不能炸掉。

## 代码  
Code:   

~~~cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#define ll long long
using namespace std;

const int N = 100010, M = 2000010, INF = 1e8;

ll n, m, S, T;
ll head[N], ver[M], edge[M], next_[M], tot;
ll q[N], d[N], cur[N];
ll map[35][35];

ll min_(int x, int y) {
	if (x < y) return x;
	return y;
}

//网络流连边 
void add(int x, int y, int z) {
	ver[tot] = y, edge[tot] = z, next_[tot] = head[x], head[x] = tot ++;
	ver[tot] = x, edge[tot] = 0, next_[tot] = head[y], head[y] = tot ++;
}

//网络流Dinic
bool bfs() {												
	int hh = 0, tt = 0;
	memset(d, -1, sizeof d);
	q[0] = S, d[S] = 0, cur[S] = head[S];
	while (hh <= tt) {
		int t = q[hh++];
		for (int i = head[t]; ~i; i = next_[i]) {
			int ver_ = ver[i];
			if (d[ver_] == -1 && edge[i]) {
				d[ver_] = d[t] + 1;
				cur[ver_] = head[ver_];						
				if (ver_ == T) return true;
				q[++ tt] = ver_;
			}
		}
	}
	return false;   
}

int find(ll u, ll limit) {									
	if (u == T) return limit;
   	ll flow = 0;
	for (int i = cur[u]; ~i && flow < limit; i = next_[i]) {
		cur[u] = i;
		int ver_ = ver[i];
		if (d[ver_] == d[u] + 1 && edge[i]) {
			int t = find(ver_, min_(edge[i], limit - flow));
			if (!t) d[ver_] = -1;
			edge[i] -= t, edge[i ^ 1] += t, flow += t;
		}
	}
	return flow;
}

ll dinic() {												 
	long long r = 0, flow;
	while (bfs()) while (flow = find(S, INF)) r += flow;
	return r;
} 


int main() {
	cin >> n >> m;
	memset(head, -1, sizeof head);																							//初始化表头 
	for(int i = 1; i <= n; i ++){
		for(int j = 1; j <= m; j ++){
			cin >> map[i][j];
		}
	}
	for(int i = 1; i <= n; i ++){
		for(int j = 1; j <= m; j ++){
			if(map[i][j] == -1) continue;																					//障碍 
			else if(map[i][j] == 0) add((i - 1) * m + j ,(i - 1) * m + j + n * m, INF), add(0, (i - 1) * m + j, INF);		//敌人 
			else add((i - 1) * m + j, (i - 1) * m + n * m + j, map[i][j]);													//自己的入点连出点 
			if(i > 1 && map[i - 1][j] != -1) add((i - 1) * m + n * m + j, (i - 1 - 1) * m + j,INF);							//内部点连四周 
			if(j > 1 && map[i][j - 1] != -1) add((i - 1) * m + n * m + j, (i - 1) * m + j - 1,INF);
			if(i < n && map[i + 1][j] != -1) add((i - 1) * m + n * m + j, (i) * m + j,INF);
			if(j < m && map[i][j + 1] != -1) add((i - 1) * m + n * m + j, (i - 1) * m + j + 1,INF);
			if(i == 1 || j == 1 || i == n || j == m) add((i - 1) * m + n * m + j, 2 * n * m + 1, INF);						//边界 
		}
	}
	S = 0;
	T = 2 * n * m + 1;
	cout << dinic();
	return 0;
}
~~~

## 后记  

一些其他关于网络流的题：  
[狼和羊的故事](https://www.luogu.com.cn/problem/P2598)  
[方格取数问题](https://www.luogu.com.cn/problem/P2774)  
[家园 / 星际转移问题](https://www.luogu.com.cn/problem/P2754)


---

## 作者：ker_xyxyxyx_xxs (赞：2)

[P3866 [TJOI2009]战争游戏](https://www.luogu.com.cn/problem/P3866)

题意：不要让敌人逃出去。

标签：最小割。

知道是最小割，你就很快能反应过来，让地图和外界不连通，相当于将地图与外界的联系切断，外界就自然成为了汇点。上最小割。

讲一下连边。

1、如果这个点是障碍物，什么也不做。

2、考虑拆点。将每一个不是障碍的点拆为两个点，入点连向出点，如果这个点是敌人，边权为 $ \infty $。如果这个点是空地，边权为当前点点权。

3、所有点向周围的点连边。周围点是障碍就不连，是敌人和空地都要连。边权为 $ \infty $。注意是**起点的出点连向终点的入点**，也是个老套路了。

4、考虑源点汇点之间的连边。源点向所有敌军的入点连一条边权为 $ \infty $  的边。每个边界上的点向汇点连一条边权为 $ \infty $ 的边。

接着利用最小割最大刘定理求出最小割。

Code
```cpp
# include <iostream>
# include <queue>
# include <cstring>
# include <cstdio>
using namespace std;

const int N = 1e6 + 5;
const int M = 2e6 + 5;
const int inf = 1e9;

typedef struct {
	int x , y , z , next;
} Node;
Node edge[M];
int E = 1 , elast[N];
void add(int x , int y , int z) {
	E ++;
	edge[E].x = x;
	edge[E].y = y;
	edge[E].z = z;
	edge[E].next = elast[x];
	elast[x] = E;
}
int S , T;
int dis[N] , cnt[N];
void bfs(int start) {
	queue<int> q;
	q.push(start);
	dis[start] = 0;
	cnt[S] = 1;
	while (!q.empty()) {
		int cur = q.front();
		q.pop();
		for (int i = elast[cur] ; i ; i = edge[i].next) {
			int v = edge[i].y;
			if (dis[v] != -1) continue;
			dis[v] = dis[cur] + 1;
			q.push(v);
			cnt[dis[v]] ++;
		}
	}
}
int cur[N];
int dfs(int u , int flow) {
	if (u == T) return flow;
	int delta = 0;
	for (int i = cur[u] ; i ; i = edge[i].next) {
		cur[u] = i;
		int v = edge[i].y;
		if (edge[i].z > 0 && dis[u] == dis[v] + 1) {
			int temp = dfs(v , min(flow - delta , edge[i].z));
			edge[i].z -= temp;
			edge[i ^ 1].z += temp;
			delta += temp;
			if (delta == flow) return delta;
		}
	}
	if (dis[S] >= T + 1) return delta;
	cur[u] = elast[u];
	if (-- cnt[dis[u]] == 0) dis[S] = T + 1;
	cnt[++ dis[u]] ++;
	return delta;
}
int Isap() {
	int ans = 0;
	memset(cnt , 0 , sizeof cnt);
	memset(dis , -1 , sizeof dis);
	bfs(T);
	for (int i = 0 ; i <= T ; i ++) {
		cur[i] = elast[i];
	}
	while (dis[S] < T + 1) ans += dfs(S , inf);
	return ans;
}
int st[50][50];
int dx[4] = {1 , 0 , -1 , 0};
int dy[4] = {0 , 1 , 0 , -1};
int n , m;
int id(int x , int y) {
	return (x - 1) * n + y;
}
int main() {
	cin >> m >> n;
	S = 0 , T = (n * m) << 1 | 1;
	for (int i = 1 ; i <= m ; i ++) {
		for (int j = 1 ; j <= n ; j ++) cin >> st[i][j];
	}
	for (int i = 1 ; i <= m ; i ++) {
		for (int j = 1 ; j <= n ; j ++) {
			if (st[i][j] == -1) continue;
			if (st[i][j] == 0) add(S , id(i , j) , inf) , add(id(i , j) , S , 0) , add(id(i , j) , id(i , j) + n * m , inf) , add(id(i , j) + n * m , id(i , j) , 0);
			else add(id(i , j) , id(i , j) + n * m , st[i][j]) , add(id(i , j) + n * m , id(i , j) , 0);
			for (int k = 0 ; k < 4 ; k ++) {
				int tx = i + dx[k] , ty = j + dy[k];
				if (tx < 1 || ty < 1 || tx > m || ty > n) continue;
				else if (st[tx][ty] == -1) continue;
				else add(id(i , j) + n * m , id(tx , ty) , inf) , add(id(tx , ty) , id(i , j) + n * m , 0);
			}
			if (i == 1 || j == 1 || i == m || j == n) add(id(i , j) + n * m , T , inf) , add(T , id(i , j) + n * m , 0);
		}
	}
	printf("%d\n" , Isap());
	return 0;
}

```

---

## 作者：vegetabird (赞：2)

这一题是一个很裸的最小割。


把每一个点都拆成两个点，若该点不是路障，则中间连一条边，若该点点权为正，则流量等于点权，若点权为0，则流量等于INF。对于所有相邻的点对，建边，权值为INF（若两点中有一点是路障，则不建边）。


设一个源点source，一个汇点sink。在源点与所有敌军之间建权值为INF的边，在边界上所有点与汇点之间建权值为INF的边。


然后跑一遍最大流，根据最小割等于最大流，就可以求出最小割了。


Code:
```cpp
    #include<cstdio>
    #include<cctype>
    #include<cstring>
    #include<utility>
    #include<algorithm>
    #include<vector>
    #include<queue>
    #include<cmath>
    #include<set>
    int n,m;
    int source,sink;
    int mat[35][35];
    int to[200010],cap[200010],flow[200010],nxt[200010],fst[20010],cnt;
    int level[20010],q[20010],head,tail;
    const int INF=0x3fffffff;
    int trans1[35][35],trans2[35][35];
    inline int transform1(int x,int y){
        return m*(x-1)+y;
    }
    inline int transform2(int x,int y){
        return m*(x+n-1)+y;
    }
    inline void buildedge(int u,int v,int f){
        to[cnt]=v,cap[cnt]=f;
        nxt[cnt]=fst[u];
        fst[u]=cnt++;
        to[cnt]=u;
        nxt[cnt]=fst[v];
        fst[v]=cnt++;
    }
    inline int min(int a,int b){
        return a<b?a:b;
    }
    inline bool bfs(){
        int u,k;
        memset(level,0,sizeof(level));
        head=0,tail=1;
        q[head]=source;
        level[source]=1;
        while(head!=tail){
            u=q[head++];
            for(k=fst[u];k!=-1;k=nxt[k]){
                if(!level[to[k]]&&cap[k]>flow[k]){
                    level[to[k]]=level[u]+1;
                    q[tail++]=to[k];
                    if(to[k]==sink)return true;
                }
            }
        }
        return false;
    }
    int dfs(int u,int avaiflow){
        if(u==sink)return avaiflow;
        int k,r=avaiflow,p;
        for(k=fst[u];r&&k!=-1;k=nxt[k]){
            if(level[to[k]]==level[u]+1&&cap[k]>flow[k]){
                r-=(p=dfs(to[k],min(r,cap[k]-flow[k])));
                flow[k]+=p;
                cap[k^1]+=p;
            }
        }
        return avaiflow-r;
    }
    inline int dinic(){
        int maxflow=0,t;
        while(bfs()){
            while(t=dfs(source,INF)){
                maxflow+=t;
            }
        }
        return maxflow;
    }
    int main(){
        scanf("%d%d",&n,&m);
        source=0,sink=2*n*m+1;
        for(int i=source;i<=sink;i++){
            fst[i]=-1;
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                scanf("%d",&mat[i][j]);
                trans1[i][j]=transform1(i,j);
                trans2[i][j]=transform2(i,j);
                if(!mat[i][j]){
                    buildedge(source,trans1[i][j],INF);
                    buildedge(trans1[i][j],trans2[i][j],INF);
                }
                if(i==1||j==1||i==n||j==m){
                    buildedge(trans2[i][j],sink,INF);
                }
                if(mat[i][j]>0){
                    buildedge(trans1[i][j],trans2[i][j],mat[i][j]);
                }
                if(i>1&&mat[i][j]>=0&&mat[i-1][j]>=0){
                    buildedge(trans2[i][j],trans1[i-1][j],INF);
                    buildedge(trans2[i-1][j],trans1[i][j],INF);
                }
                if(j>1&&mat[i][j]>=0&&mat[i][j-1]>=0){
                    buildedge(trans2[i][j],trans1[i][j-1],INF);
                    buildedge(trans2[i][j-1],trans1[i][j],INF);
                }
            }
        }
        printf("%d\n",dinic());
    }
```


---

## 作者：Foreverxxx (赞：1)

一些教训：模板还是要练熟一些才好。

### 分析

整张地图中，一共有 $3$ 种格子，分别为障碍物、敌军以及空地，我们需要轰炸的是空地，保证敌军会被轰炸后的地方以及障碍物包围。

对于每一个格子，我们只需要考虑上下左右四个格子就可以了。

### 思路

首先分析样例。

![](https://cdn.luogu.com.cn/upload/image_hosting/i3qef5na.png)

红色的格子就是样例中被炸掉的区域。

乍一看，我们没有任何的思路，所以不妨考虑，我们是如何把敌军所在的位置给隔离出去的。

比如原来我们需要轰炸这些区域。

![](https://cdn.luogu.com.cn/upload/image_hosting/ogp7arpo.png)

但是我们发现，轰炸敌军所在位置上面一块是不划算的，所以我们又对这一块进行考虑。

不难发现，我们只需要轰炸代价为 $10$ 的区域的左、上、右三块区域，即这些区域**代替**了代价为 $10$ 的区域。换言之，我们现在需要考虑的东西变为了如何轰炸，使得此时军队的左、下、上三块区域被包围或者被轰炸。

根据代价为 $10$ 的方块的经验，我们尝试着建立了这样一张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/8jcs227c.png)

所以我们需要割掉这些边：

![](https://cdn.luogu.com.cn/upload/image_hosting/afvg6fs3.png)

所以思路已经出来了，**最小割**！

根据我们的经验，首先需要将每个点进行拆点操作，把每个点拆成两个点。

然后，我们按照如下方式进行连边：

1. 对于障碍物，我们选择忽略。
2. 源点与军队所在点连边，流量为 $\infty$。
3. 对于不是障碍物的点，从该点的出点向四周的入点连边，流量同样为 $\infty$。
4. 对于空地，我们从入点向出点连边，代价为轰炸的代价。对于敌军，我们从入点向出点连边，流量为 $\infty$。
5. 对于边界的点，我们从出点向汇点连边，流量为 $\infty$。

最后，根据最小割最大流定理跑最小割就行了。

### 一些细节

1. 最大流模板一定不要写错了！
2. 得在开头特判是否为障碍物，枚举四周连边时也要判断，同时注意越界问题。
3. 敌军所在地不能被轰炸！

Code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sss=0,www=1;
	char chh=getchar();
	while(chh<'0'||chh>'9'){
		if(chh=='-') www=-1;
		chh=getchar();
	}
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss*www;
}
const int dx[]={0,1,0,-1},dy[]={1,0,-1,0};
int n,m,s,t;
int maze[35][35];
int depth[1805];
int head[1805],to[1000005],val[1000005],nxt[1000005],tot=1;
void add(int u,int v,int w){
	to[++tot]=v;
	val[tot]=w;
	nxt[tot]=head[u];
	head[u]=tot;
}
void add_edge(int u,int v,int w){
	add(u,v,w); add(v,u,0);
}
bool in(int x,int y){
	return 1<=x&&x<=n&&1<=y&&y<=m;
}
int calc_in(int x,int y){
	return m*(x-1)+y;
}
int calc_out(int x,int y){
	return m*(x-1)+y+n*m;
}
bool bfs(){
	memset(depth,0,sizeof depth); depth[s]=1;
	queue<int> q; q.push(s);
	while(!q.empty()){
		int x=q.front(); q.pop();
		for(register int i=head[x];i;i=nxt[i]){
			int u=to[i];
			if(val[i]&&!depth[u]){
				depth[u]=depth[x]+1;
				q.push(u);
			}
		}
	}
	return depth[t];
}
int dfs(int now,int flow){
	if(now==t) return flow;
	int out_flow=0;
	for(register int i=head[now];i&&flow;i=nxt[i]){
		int u=to[i];
		if(val[i]&&depth[u]==depth[now]+1){
			int tmp=dfs(u,min(flow,val[i]));
			val[i]-=tmp,val[i^1]+=tmp;
			flow-=tmp,out_flow+=tmp;
		}
	}
	if(out_flow==0) depth[now]=0;
	return out_flow;
}
int Dinic(){
	int ans=0;
	while(bfs()) ans+=dfs(s,1e9);
	return ans;
}
int main(){
	memset(head,-1,sizeof head); 
	n=read(),m=read(); s=0,t=2*n*m+1;
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			maze[i][j]=read();
		}
	}
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			if(maze[i][j]==-1) continue;
			if(maze[i][j]==0){
				add_edge(s,calc_in(i,j),1e9);
				add_edge(calc_in(i,j),calc_out(i,j),1e9);
			}
			else add_edge(calc_in(i,j),calc_out(i,j),maze[i][j]);
			for(register int k=0;k<4;k++){
				int tx=i+dx[k],ty=j+dy[k];
				if(in(tx,ty)&&maze[tx][ty]!=-1) add_edge(calc_out(i,j),calc_in(tx,ty),1e9);
			}
			if(i==1||i==n||j==1||j==m) add_edge(calc_out(i,j),t,1e9);
		}
	}
	printf("%d",Dinic());
	return 0;
}
```

---

## 作者：Pwtking (赞：0)

[传送门](https://www.luogu.com.cn/problem/P3866)

分析题意，意思是不能让敌人通过格子之间的移动走出边界，而阻止敌军从一个格子到另一个子的途径是什么——花费敌军要到的格子所需的代价来建墙。

由此如果我们把每个格子之间都建一条边权为终点格子的建墙代价的边，再将源点连向每个敌人边权为无穷大，再把每个边界点向汇点连无穷大的边，最后求一下这张图的最小割不就是答案了吗？（以上建边均不包含起点或终点为障碍或终点为敌人的情况，原因显然。）

于是错误的解法诞生了。

这个看似很对的解法虽然很接近正解了，但为什么是错的呢？

这样建图的话，如果有多个敌人的话，向敌人周围的格子建边可能会产生重复，比如三个敌人坐标分别为 $(i,j),(i+1,j-1),(i+1,j+1)$，此时我们想要在  $(i+1,j)$ 建墙的话，因为三个敌人都向这个坐标连过边，这样不就产生重复了吗。

于是，我们使用**拆点**法。

将每个坐标（障碍格除外），拆分成两个点，分别作为入点和出点，边权为这个坐标修墙的代价，再将出点向其他他相邻的非障碍且非敌人格的入点连边权为无穷大的边，最后将边界点的出点向汇点连边权为无穷大的边，将源点向敌人格的入点连边权为无穷大的边。

这样就解决了边权重复计算的问题。

最终答案就是这张图的最小割。

#### Question：

1. 这样的建边每两个空格子之间会建两条边，不会导致边权计算重复吗？

- 首先，不这样建边的话显然是错误的，因为不能覆盖所有情况（比如我只能到一个格子而不能从一个格子出去）。其次这样建边只有每个格子拆出来的两个点之间才有非无限大的的连边（最小割一定只会割这些边），并且是单向边，起点和终点只会由起点的出点向终点的入点连的边，即为边权值会计算一次，不会产生重复。

2. 建无限大边权的边意义是什么？

- 因为我们要求最小割，就要保持图的联通，但是我们又不能因为这些为了保持图联通而不对答案产生贡献边影响答案，所以建无穷大的边，这样我们求最小割的时候才不会选上这些边。

---

## 作者：Fzrcy (赞：0)

$1\le n,m\le 30$，网络流无疑了。

考虑最小割模型。建立超级原点和超级汇点 $S$，$T$，将每个点 $(i,j)$ 拆成两个点 $(i,j)$ 和 $(i',j')$，对于**可炸毁**的点 $(i,j)$，连边 $(i,j)\xrightarrow{a_{i,j}} (i',j')$ 和 $S\xrightarrow{INF}(x,y)$，对于相邻的点 $(x,y)$ 连边：$(i',j')\xrightarrow{inf}(x,y)$。对于敌军的点 $(x,y)$ 连边：$(x,y)\xrightarrow{INF}T$，跑最大流即可求出最小割。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
struct Edge{
  int u, v, flow, cap;
  Edge(int A=0, int B=0, int C=0, int D=0){
    u=A, v=B, flow=C, cap=D;
  }
};
const int N=1e5+11, INF=1e9;
struct Dinic{
  vector<int> E[N]; vector<Edge> edge;
  int vis[N], dist[N], c[N], s, t, tt;

  void link(int u, int v, int cap){
    E[u].push_back(int(edge.size()));
    edge.push_back(Edge(u, v, 0, cap));
    E[v].push_back(int(edge.size()));
    edge.push_back(Edge(v, u, 0, 0));
  }

  bool BFS(){
    for(int i=1; i<=tt; i++)
      c[i]=vis[i]=0, dist[i]=INF;
    queue<int> q; q.push(s), dist[s]=0, vis[s]=1;
    while(!q.empty()){
      int u=q.front(); q.pop();
      for(int i:E[u]){
        Edge e=edge[i];
        if(e.cap>e.flow&&!vis[e.v])
          vis[e.v]=1, dist[e.v]=dist[e.u]+1, q.push(e.v);
      }
    }
    return vis[t];
  }

  int dfs(int u, int a){
    if(u==t||a==0) return a;
    int tot=0, f=0;
    for(int &i=c[u]; i<int(E[u].size()); i++){
      Edge e=edge[E[u][i]];
      if(dist[e.v]==dist[e.u]+1&&(f=dfs(e.v, min(e.cap-e.flow, a)))>0){
        tot+=f, a-=f, edge[E[u][i]].flow+=f, edge[E[u][i]^1].flow-=f;
        if(a==0)break;
      }
    }
    return tot;
  }

  int Max_Flow_Min_Cost(int u, int v, int total){
    int ans=0;
    s=u, t=v, tt=total;
    while(BFS())ans+=dfs(u, INF);
    return ans;
  }
}g;
int a[333][333];
int n, m;
int id(int i, int j){
  return (i-1)*m+j;
}
int main(){
  cin>>n>>m;
  int s=2*n*m+2, t=s-1, all=n*m;
  for(int i=1; i<=n; i++)
  for(int j=1; j<=m; j++)
    cin>>a[i][j];
  for(int i=1; i<=n; i++)
  for(int j=1; j<=m; j++){
    if(a[i][j]==-1)continue;
    if(a[i][j]==0)g.link(s, id(i, j), INF), g.link(id(i, j), id(i, j)+all, INF);
    else g.link(id(i, j), id(i, j)+all, a[i][j]);
    if(i>1&&a[i-1][j]!=-1)g.link(id(i, j)+all, id(i-1, j), INF);
    if(j>1&&a[i][j-1]!=-1)g.link(id(i, j)+all, id(i, j-1), INF);
    if(i<n&&a[i+1][j]!=-1)g.link(id(i, j)+all, id(i+1, j), INF);
    if(j<m&&a[i][j+1]!=-1)g.link(id(i, j)+all, id(i, j+1), INF);
    if(i==1||j==1||i==n||j==m)g.link(id(i, j)+all, t, INF);
  }
  cout<<g.Max_Flow_Min_Cost(s, t, t+11)<<'\n';
  return 0;
}
```



---

## 作者：strcmp (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P3866)

[更好的阅读体验](https://wqlblogger.oier.space/post/lg-477917-solution-p3866)

[最大流最小割证明（选择性观看）](https://wqlblogger.oier.space/post/wql)

**题目大意：** 给定一个 $\mathrm{M \times N}$ 的**带权**矩阵 $\mathrm A_{i,\,j}$，对于每个元素的权值 $\mathrm A_{i,\,j}$，分三种情况：

- $\mathrm A_{i,\,j} = -1$，表示无法通过 $(i,\,j)$ 这个元素。

- $\mathrm A_{i,\,j} = 0$，表示 $(i,\,j)$ 这个元素被标记为一个**起点。**

- $\mathrm A_{i,\,j} \in \mathbb{N^+}$，表示可以花费 $\mathrm A_{i,\,j}$ 的代价使得 $(i,\,j)$ 这个元素被标记为无法通过。

从每个元素 $(i,\,j)$ 可以通过与其相邻的**未标记不可通过**的元素。

设被标记的第 $i$ 个起点的坐标为 $(x_i,\,y_i)$，权值为 $w_i$。

用一定的代价将某些元素标记为不可通过，使得不存在任何一个路径，该路径满足其起点为 $(x_i,\,y_i)$，不经过任何被标记为不可通过的元素，且终点为任意一个在边界上的元素。求最优方案。

### Solution

根据题意，容易想到最小割，考虑建图，则题意转化为**求出将从起点到边界结点割断的最小代价**。

考虑每个结点 $u$，先考虑 $u$ 是起点的情况，则可以建立超级汇点 $s$，从 $s$ 到 $u$ 连容量为 $+\infty$ 的边。再考虑 $u$ 是边界结点的情况，建立超级汇点 $t$，从 $u$ 向 $t$ 连容量为 $+\infty$ 的边。

此时再考虑其它结点的连边，对于一个结点 $u$，如果我们将其标记，则将会导致所有通过结点 $u$ 的路径被切断。但传统的最小割只能模拟单个边被割断的情况，对于结点被割断的情况则难以实现，于是考虑特殊建图。

我们可以考虑将每个结点建立一个 **「入点」** 和 **「出点」**，相当于把每一个结点 $u$ “拆”成了 $u'$ 和 $u''$，先从 $u'$ 向 $u''$ 连容量为 $\mathrm A_{i,\,j}$ 的边。之后所有原本连向 $u$ 的边都连向 $u'$，所有从 $u$ 连出去的边都改为从 $u''$ 连出去。在这道题上，就是从相邻结点的出点向当前结点的入点连边，显然容量为 $+\infty$，然后分类讨论特殊情况即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/ux2cf5r7.png)

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define inf 1000000000000000
#define V 100010
#define E 5000010
typedef long long int ll;
struct edge {
	int to, next;
	ll capa;
};
int cnt = 0, head[V], n, m; edge node[E];
inline void add(int fir, int nxt, ll w) {
	node[cnt].to = nxt,
	node[cnt].capa = w,
	node[cnt].next = head[fir],
	head[fir] = cnt++;
}
int s, t, dep[V], gap[V], cur[V]; queue<int>que; ll sum = 0;
inline void initing() {
	memset(dep, -1, V * sizeof(int));
	memcpy(cur, head, (t + 1) * sizeof(int));
}
inline void bfs() {
	int fro, ito;
	que.push(t); dep[t] = 0; ++gap[dep[t]];
	while (!que.empty()) {
		fro = que.front(); que.pop();
		for (register int i = head[fro]; i != -1; i = node[i].next) {
			ito = node[i].to;
			if (dep[ito] == -1) {
				dep[ito] = dep[fro] + 1;
				que.push(ito);
				++gap[dep[ito]];
			}
		}
	}
}
ll dfs(int u, ll flow) {
	if (u == t || flow == 0)return flow; ll used = 0, wei = 0;
	for (register int i = cur[u]; i != -1; i = node[i].next) {
		cur[u] = i;
		if (dep[u] == dep[node[i].to] + 1 && node[i].capa) {
			wei = dfs(node[i].to, min(flow - used, node[i].capa));
			if (wei) {
				node[i].capa -= wei;
				node[i ^ 1].capa += wei;
				used += wei;
			}
		}
		if (used == flow)return used;
	}
	--gap[dep[u]];
	if (!gap[dep[u]])dep[s] = t + 1;
	++gap[++dep[u]];
	return used;
}
ll ISAP() {
	initing(); bfs();
	while (dep[s] < t) {
		sum += dfs(s, inf);
		memcpy(cur, head, (t + 1) * sizeof(int));
	}
	return sum;
}
inline int bh(int x, int y){
	return (x - 1) * m + y;
}
inline int hb(int x, int y){
	return bh(x,y)+n*m;
}
inline void addE(int u, int v, ll w){
	add(u, v, w);
	add(v, u, 0);
}
bool vis[205][205];
bool ok(int i, int j){
	return (i && i <= n && j && j <= m && !vis[i][j]);
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(); cout.tie();
	memset(head, -1, V * sizeof(int));
	cin >> n >> m; s = 2 * n * m + 1, t = 2 * n * m + 2;
	int f, l; ll w;
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			cin >> w;
			if(w == -1){
				vis[i][j] = true;
				continue;
			}
			if(w == 0)addE(s, bh(i,j), inf);
			if(w != 0)addE(bh(i,j), hb(i,j), w);
			else addE(bh(i,j), hb(i,j), inf);
			if(i == 1 || j == 1 || i == n || j == n)addE(hb(i,j), t, inf);
			if(ok(i-1,j))addE(hb(i,j), bh(i-1,j), inf);
			if(ok(i+1,j))addE(hb(i,j), bh(i+1,j), inf);
			if(ok(i,j-1))addE(hb(i,j), bh(i,j-1), inf);
			if(ok(i,j+1))addE(hb(i,j), bh(i,j+1), inf);
		}
	}
	cout << ISAP();
	return 0;
}
```



---

## 作者：pldzy (赞：0)

[传送门：P3866 [TJOI2009] 战争游戏](https://www.luogu.com.cn/problem/P3866)

## Solution

首先考虑如何建图。

先看建源点和汇点的原因：

- 建源点：有若干支不同的军队需要拦截，所以要将他们所在点都与源点连接，以跑网络流。
- 建汇点：有若干个通向图外的可行边界点，也要将它们都与汇点连在一起，以跑网络流。

这样一来，源点的汇点的建图方式就可以轻易得到了：

- 源点：自源点向所有军队的所在点相连，流量为 $inf$。
- 汇点：将所有可以通行的图内边界点与汇点相连，流量为 $inf$。

如此，解决此题的具体方式也就出来了：求最小割。

上文所述，将军队都与源点相连，可行边界点都与汇点相连，则要想阻止军队出图，**就是要割去一些带权值的边，既能使源点和汇点不连通，又要使割去边的权值之和最小**。

因为最大流等于最小割，所以这道题就转化为求最大流。那么上述的边权在下文就变成了流量。

再看如何建图的中间部分：

1. 很明显，要将所有的可行点（即该点没有障碍物）和它四周可以到达的点连边，流量为 $inf$。

2. 对于空地，发现它有一个轰炸值（即轰炸所费炸药数），特别地，对于军队所在点，轰炸值为 0。按上文所述，要想将一个点权转化为边权，也就是一条边的流量，那么方法呼之欲出：拆点。

1. 所以，我们将每一个可行点拆成两个点，入点和出点，并在它们之间连边。若点为空地，则边的流量即为空地的轰炸值，这样即可限制通过该空地点的流量；若点为军队所在点，则边的流量为 $inf$。

1. 最后再来说入点和出点的连边：对于所有可行点，使用出点向四周可行点的入点连边；对于军队所在点，则自源点与该点的入点连边。

建图就说完了，剩下的就只有最大流板子了。

特别：注意点的编号的处理。

## Code

更多详情见代码及注释。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
#include<vector>
using namespace std;

#define rep(i, a, b) for(int i = a; i <= b; ++i)
#define maxn 2005
#define maxm 40005
#define inf 2147483647
int n, m, d, nm;
int c[maxn][maxn], cntc, l[maxm], r[maxm], ans;
int s, t, p[maxn][maxn], tot;
int dep[maxm];
int hd[maxm], cur[maxm], cnt = 1;
int fx[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
struct node{
	int to, nxt, w;
}e[maxm << 1];

inline void add(int u, int v, int w)
{
	e[++cnt].to = v;
	e[cnt].nxt = hd[u], e[cnt].w = w;
	hd[u] = cnt;
	e[++cnt].to = u;
	e[cnt].nxt = hd[v], hd[v] = cnt;
}

inline int id(int x, int y)/*点的编号的处理*/
{
	return (x - 1) * m + y;
}

inline bool bfs()
{
	queue <int> q;
	memset(dep, 0, sizeof dep);
	dep[s] = 1, q.push(s);
	while(!q.empty())
	{
		int u = q.front();
		q.pop();
		for(int v, i = hd[u]; i; i = e[i].nxt)
		{
			if(!dep[v = e[i].to] and e[i].w)
			{
				dep[v] = dep[u] + 1;
				q.push(v);
			}                              
		}
	}
	return dep[t] ? true : false;
}

inline int dinic(int u, int in)
{
	if(u == t or !in) return in;
	int out = 0;
	for(int v, &i = cur[u]/*cur[u] 随着 i 的变化而变化*/; i and in/*注意判容量剩余*/; i = e[i].nxt)
	        /*当前弧优化*/ 
	{
		if(dep[v = e[i].to] == dep[u] + 1 and e[i].w)
		{
			int res = dinic(v, min(in, e[i].w));
			e[i].w -= res, e[i ^ 1].w += res;
			in -= res, out += res;
		}
	}
	if(!out) dep[u] = 0;
	return out;
}

int main()
{
	scanf("%d %d", &n, &m);
	nm = n * m, t = nm * 2 + 1;
	rep(i, 1, n) rep(j, 1, m) scanf("%d", &c[i][j]);
	rep(i, 1, n) rep(j, 1, m) if(c[i][j] != -1)
	{
		if(!c[i][j])//若该点为军队所在点 
			add(id(i, j), id(i, j) + nm, inf)/*拆点*/, add(s, id(i, j), inf)/*军队所在点和源点相连*/;
		else /*若该点为空地*/add(id(i, j), id(i, j) + nm, c[i][j])/*拆点*/;
		int nw = id(i, j) + nm;//当前入点相对应的出点 
		if(i == 1 or j == 1 or i == n or j == m) add(nw, t, inf);//边界点和汇点相连 
		rep(k, 0, 3)//向点的四周可行点连边 
		{
			int xx = i + fx[k][0], yy = j + fx[k][1];
			if(xx < 1 or yy < 1 or xx > n or yy > m or c[xx][yy] == -1) continue;
			add(nw/*当前点出点*/, id(xx, yy)/*四周可行点入点*/, inf);
		}
	}
	while(bfs())//Dinic板子 
	{
		rep(i, s, t) cur[i] = hd[i];//当前弧优化-数组初始化 
		ans += dinic(s, inf);
	}
	printf("%d\n", ans);
	return 0; 
}
```


------------
感谢阅读。

辛苦管理员审核，若有问题烦请指出。

---

## 作者：破忆 (赞：0)

## 【题意】

让一些格子不可行，使军队无法到达边界，求最小代价

## 【分析】

军队组成点集 $A$，边界上的点组成点集 $B$

求将 $A$ 和 $B$ 割开的最小代价

**最小割=最大流**

------------

考虑如何建图

将点拆成入点和出点

* 源点向军队的出点连流量 $\inf$ 的边

* 空地的入点向空地的出点连流量是此点代价的边

* 非障碍点的出点向周围点的入点连流浪 $\inf$ 的边

* 周围点的出点向汇点连流量 $\inf$ 的边

这样就保证了流会被需要轰炸的点卡住

并且最大流就是最小代价

## 算法

网络流

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=35,maxt=maxn*maxn*2,maxe=maxn*maxn*10,INF=1<<30,p[4][2]={{-1,0},{0,1},{1,0},{0,-1}};
int n,m;
int mp[maxn][maxn];
int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
struct Dinic{
    int S,T;
    struct edge{
        int to,nxt,f;
    }e[maxe];
    int tot,lnk[maxt];
    void add_e(int x,int y,int f){
        e[++tot]=(edge){y,lnk[x],f};
        lnk[x]=tot;
    }
    void ADD(int x,int y,int f){
        add_e(x,y,f),add_e(y,x,0);
    }
    int que[maxt],cur[maxt],dep[maxt];
    bool BFS(){
        int hed=0,til=1;
        for(int i=1;i<=T;i++) cur[i]=lnk[i],dep[i]=INF;
        que[1]=S,dep[S]=0;
        while(hed!=til){
            int x=que[++hed];
            for(int j=lnk[x];j;j=e[j].nxt){
                int y=e[j].to;
                if(dep[y]==INF&&e[j].f){
                    dep[y]=dep[x]+1;
                    que[++til]=y;
                }
            }
        }
        return dep[T]!=INF;
    }
    int DFS(int x,int limit){
        if(!limit||x==T) return limit;
        int flow=0,f;
        for(int j=cur[x];j;j=e[j].nxt){
            cur[x]=j;
            int y=e[j].to;
            if(dep[y]==dep[x]+1&&(f=DFS(y,min(limit,e[j].f)))){
                e[j].f-=f;
                e[j^1].f+=f;
                flow+=f;
                limit-=f;
            }
            if(!limit) return flow;
        }
        return flow;
    }
    int calc(){
        int ans=0;
        while(BFS()) ans+=DFS(S,INF);
        return ans;
    }
}D;
int getid(int x,int y){
	return (x-1)*m+y;
}
int main(){
 	freopen("P3866.in","r",stdin);
 	freopen("P3866.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++) mp[i][j]=read();
	D.S=n*m*2+1,D.T=D.S+1,D.tot=1;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++){
		if(mp[i][j]==0){
			D.ADD(D.S,getid(i,j)+n*m,INF);
			for(int w=0;w<4;w++){
				int x=i+p[w][0],y=j+p[w][1];
				if(x>n||x<1||y>m||y<1) continue;
				if(mp[x][y]==-1) continue;
				D.ADD(getid(i,j)+n*m,getid(x,y),INF);
			}
		}else
		if(mp[i][j]>0){
			D.ADD(getid(i,j),getid(i,j)+n*m,mp[i][j]);
			for(int w=0;w<4;w++){
				int x=i+p[w][0],y=j+p[w][1];
				if(x>n||x<1||y>m||y<1) continue;
				if(mp[x][y]==-1) continue;
				D.ADD(getid(i,j)+n*m,getid(x,y),INF);
			}
		}
	}
	for(int i=1;i<=n;i++)
		D.ADD(getid(i,1)+n*m,D.T,INF),D.ADD(getid(i,m)+n*m,D.T,INF);
	for(int j=2;j<m;j++)
		D.ADD(getid(1,j)+n*m,D.T,INF),D.ADD(getid(n,j)+n*m,D.T,INF);
	printf("%d\n",D.calc());
	return 0;
}
```


---

## 作者：hovny (赞：0)

## [题面](https://www.luogu.org/problemnew/show/P3866)

好难表述啊~

在n*m的矩阵上，有一些大兵（为0），一些空地（一个正整数），障碍物（-1），现在摧毁一些空地，使所有大兵不能走出矩阵去（代价为表示空地的整数），求最小代价

## 思路：

### 网络流最小割

~~“阻止”，“最小”，看到这样的字眼，肯定就要想到最小割啊~~

在互相能到达的点之间建边，容量为INF，因为——它不能炸……

然后把每个点拆成**入点**和**出点**，每个兵所在的出点和**源点S**直接相连，在最外面的点的出点和**汇点T**直接相连

最后套模板，OK了

最重要的还是建边，能够理解题目的意思，想出对应的策略

Code：

```cpp
#include<bits/stdc++.h>
#define INF 0x7f7f7f7f
#define M 5010
#define N 2010
#define Mn 31
using namespace std;
int Cx[4]={1,0,0,-1};//预处理移动的方向
int Cy[4]={0,1,-1,0};
struct node{
	int to,cap;
	int nxt;
	node(int a,int b):to(a),cap(b){	}
	node(){	}
}b[M<<1];
int head[N],deep[N],a[Mn][Mn];
int n,m,S,T,Maxflow,Max,t=1;
bool p[Mn][Mn];
int read()
{
	int s=0,p=1;
	char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-')
			p=-1;
		c=getchar();
	}
	while(isdigit(c))
	{
		s=(s<<1)+(s<<3)+c-'0';
		c=getchar();
	}
	return s*p;
}
int Cag(int x,int y)
{
	return (x-1)*m+y;
}
void add(int x,int y,int cap)
{
	b[++t]=node(y,cap);
	b[t].nxt=head[x];
	head[x]=t;
	b[++t]=node(x,0);
	b[t].nxt=head[y];
	head[y]=t;
	return;
}
void Add(int x,int y)
{
	int Tx,Ty;
	for(int i=0;i<4;i++)
	{
		Tx=x+Cx[i];Ty=y+Cy[i];
		if(p[Tx][Ty])//边框的用处
			add(Cag(x,y)+Max,T,INF);//在矩阵外就和汇点T相连
		else
			add(Cag(x,y)+Max,Cag(Tx,Ty),INF);//否则出点和入点相连
	}
	return;
}
bool BFS()
{
	int i,cur;
	int to,cap;
	queue<int>p;
	memset(deep,0,sizeof(deep));
	p.push(S);deep[S]=1;
	while(!p.empty())
	{
		cur=p.front();p.pop();
		for(i=head[cur];i;i=b[i].nxt)
		{
			to=b[i].to;cap=b[i].cap;
			if(cap&&!deep[to])
			{
				deep[to]=deep[cur]+1;
				p.push(to);
				if(to==T)
					return 1;
			}
		}
	}
	return 0;
}
int Dinic(int k,int flow)
{
	if(k==T)
		return flow;
	int i,to,cap,res,rest=flow;
	for(i=head[k];i&&rest;i=b[i].nxt)
	{
		to=b[i].to;cap=b[i].cap;
		if(cap&&deep[to]==deep[k]+1)
		{
			res=Dinic(to,min(rest,cap));
			if(!res)
				deep[to]=0;
			b[i].cap-=res;
			b[i^1].cap+=res;
			rest-=res;
		}
	}
	return flow-rest;
}
int main()
{
	int i,j,flow;
	n=read();m=read();
	Max=n*m;T=Max+Max+1;//汇点T
	for(i=1;i<=n;i++)//裱个框，方便判断
		p[i][0]=p[i][m+1]=1;
	for(i=1;i<=m;i++)
		p[0][i]=p[n+1][i]=1;
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
			a[i][j]=read();
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
		{
			if(a[i][j]==-1)//如果是障碍就不建边
				continue;
			if(a[i][j]==0)//如果是大兵就与源点建边，注意，是出点！否则都要为zero了……
				add(S,Cag(i,j)+Max,INF);
			else//如果是空地，那么在自己的入点和出点之间建边
				add(Cag(i,j),Cag(i,j)+Max,a[i][j]);//注意，这里的容量是a[i][j]，就是要炸多少次
			Add(i,j);//放个函数里看看能不能和四周相连
		}
	while(BFS())//Dinic模板
		while((flow=Dinic(S,INF)))
			Maxflow+=flow;
	printf("%d",Maxflow);
	return 0;
}
```

## 推荐题目

### [Luogu P2472 [SCOI2007]蜥蜴](https://www.luogu.org/problemnew/show/P2472)

有点类似，~~但很不相同！~~

---


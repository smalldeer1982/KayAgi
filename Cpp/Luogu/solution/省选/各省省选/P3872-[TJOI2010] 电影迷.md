# [TJOI2010] 电影迷

## 题目描述

小A是一个电影迷，他收集了上百部的电影，打算从中挑出若干部在假期看完。他根据自己的口味和网上的介绍，对每部电影 $X$ 都打了一个分数 $v_X$，表示自己喜欢的程度。这个分数的范围在 $-1000$ 至 $1000$ 之间，越大表示越喜欢。小A每看一部电影 $X$，他的体验值就会加上 $v_X$。

另外，因为某些电影是组成一个系列的，比如著名的《终结者》系列、《黑客帝国》系列等等，如果小A只看了前一部而没有看后一部的话，他就会觉得不是很爽。准确来讲，对于任意两部不同的电影 $X,Y$，他们可能存在一个依赖值 $d_{X,Y}$，表示如果小A看了 $X$ 但是没看 $Y$，他的体验值就会减少 $d_{X,Y}$。（注意与观看的顺序无关，只要两部都看过，就不会减少体验值）

现在他要选出若干电影来看，使得得到的总的体验值最大。如果他无法得到正的体验值，就输出 $0$。

## 说明/提示

如果小A只看电影 $1$，体验值为 $100-49=51$。如果只看电影2，体验值为 $-50-10=-60$。如果两部都看，体验值为 $100+(-50)=50$。所以应该只看电影 $1$。

### 数据规模与约定

对于 $20\%$ 的数据，$1\le N\le 15$。

对于 $100\%$ 的数据，$1\le N\le 100,-1000\le v_X \le 1000,0<d_{X,Y}\le 1000$

每个测试点时限1秒

## 样例 #1

### 输入

```
2 2
100 -50
1 2 49
2 1 10
```

### 输出

```
51```

# 题解

## 作者：YellowBean_Elsa (赞：8)

		S 向正权点建边，容量为点权；负权点向 T 建边，容量为点权绝对值，

		x->y 的限制就直接建 x->y。最后拿正权和-最小割就是答案。
    
    
这是神仙出题人的方法，我来给一个完整的正确性证明。

#### 证明

若一个限制条件连的 x, y 点权不同号，在取了其中正的那个后，要么放弃正的，要么取了负的，要么减少 dXY，与连边方式的最小割相同。

如果同号会怎样呢？

我们任意选两个同号点1, 2，连边2->1，选1的任意一条到T的路径1->3->T。（如果没有这条路径那么1，2常规都选（负点权则不选）答案不受影响）

![](https://cdn.luogu.com.cn/upload/image_hosting/39g9abdt.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

边a, x, y中至少有一条删掉。

##### 1. 删x或y：

1，2仍然都选，且不用割去其它边，答案不受影响。

##### 2. 删a：

1不选了，这时要么不选2（割b）要么损失d12（割c）。

如果割x或y了咋办？

怎么可能，那样转化为上一种情况，a就不用割了，不是最小割。

那这样答案也不受影响了。

##### 综上

同号的限制条件也解决了。

#### 证毕

最后还是贴一下代码吧。

```cpp
//coder: Feliks*GM-YB
#include<bits/stdc++.h>
#define fu(i,a,b) for(register int i = a, I = (b) + 1; i < I; ++i)
#define fd(i,a,b) for(register int i = a, I = (b) - 1; i > I; --i)
typedef long long ll;
using namespace std;
template <class T> inline void read(T &x) {
    x=0;T f=1;char ch=getchar();
    while(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();
    while(isdigit(ch))x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    x*=f;
}int n,m;
#define go(x) for(int i=first[x],y=v[i];i;i=nex[i],y=v[i])
const int N=1e3+5;
const int M=1e5+5;
int v[M],nex[M],w[M],first[N],tot=1;
inline void add(int x,int y,int z){
    v[++tot]=y;w[tot]=z;
    nex[tot]=first[x];
    first[x]=tot;
}namespace Dinic{
    const int s=0;
    const int t=N-4;
    const int inf=1e9+7;
    int d[N],flow,ans;
	queue<int> q;
    inline bool bfs(){
        while(!q.empty())q.pop();
        memset(d,0,sizeof(d));
        q.push(s);d[s]=1;
        while(!q.empty()){
            int x=q.front();q.pop();
            go(x){
                if(!w[i] || d[y])continue;
                q.push(y);
                d[y]=d[x]+1;
                if(y==t)return 1;
            }
        }return 0;
    }int dinic(int x,int f){
        if(x==t)return f;
        int res=f,k;
        for(int i=first[x],y=v[i];i && res;i=nex[i],y=v[i]){
            if(!w[i] || d[y]!=d[x]+1)continue;
            k=dinic(y,min(res,w[i]));
            if(!k)d[y]=0;
            w[i]-=k;w[i^1]+=k;
            res-=k;
        }return f-res;
    }inline void solve(int c){
    	while(bfs()){
			while(flow=dinic(s,inf))ans+=c*flow;
		}
	}
}using namespace Dinic;
int a[N],df;
int main(){
	read(n),read(m);
	fu(i,1,n){
		read(a[i]);
		if(a[i]>=0)add(s,i,a[i]),add(i,s,0),ans+=a[i];
		else add(i,t,-a[i]),add(t,i,0);
	}fu(i,1,m){
		int x,y;
		read(x),read(y);
		read(df);
		add(x,y,df),add(y,x,0);
	}solve(-1);
	printf("%d\n",ans);
    return 0;
}
```


---

## 作者：wgyhm (赞：5)

# [TJOI2010]电影迷

题目大意：

> 选择 $i$ 获得 $v_i$ 的价值，选择 $i$ 但是不选择 $j$ 失去 $d_{i,j}$ 的价值（不可逆）。求 $\max(\text{最大价值},0)$。

## 〇、前言

这里介绍两种方法。同时请确保你会最大流的基础算法和一定的最小割基础。

## 一、ex最大权闭合子图

### 建图

* $\begin{cases}(s,x,v_x)&v_x>0\\(x,t,-v_x)&v_x<0\end{cases}$

* $(x,y,d_{x,y})$、

答案 $=$ 正权点之和 $-$ 最小割

## 含义

因为建图类似于最大闭合权子图，所以含义也可以类比得出。

* 割掉 $s$ 与 $x$ 的边，表示**不选择**正权点 $x$；割掉 $x$ 与 $t$ 的边，表示**选择**负权点 $x$。

* 如果 $s$ 与 $i$ 有边，表示**选择**正权点 $x$；如果 $x$ 与 $t$ 有边，表示**不选择**负权点 $x$。

* 割掉 $(x,y)$，表示选择 $x$ 但是不选择 $y$，付出 $d_{x,y}$ 的代价。

图示

![](https://cdn.luogu.com.cn/upload/image_hosting/2zcronfr.png)

### 合法性

如果 $s$ 与 $t$ 连通，则存在正权点 $i$ 和负权点 $j$ 使得 $s$ 到 $i$ 有边，$i$ 到 $j$ 连通，$j$ 到 $t$ 有边，所以 $j$ 一定是 $i$ 的后继。根据含义，选择 $i$ ，不选择 $j$ 却不付出 $d_{i,j}$ 的代价，是不合法的。

图示：

![](https://cdn.luogu.com.cn/upload/image_hosting/gu8h6xsn.png)

如果 $s$ 与 $t$ 不连通。

1. 割断（选择）了负权点 $j$ 与 $t$ 的边 $(j,t)$，也就是选择了 $j$ 的前驱正权点 $i$ 和 $j$ 。根据最小割的定义，$j$ 的前驱 $i$ 不会被割，同时也不选择中间的边 $(i,j)$ 。
2. 割断了 $(i,j)$ ，也就是选择了正权点 $i$ ，不选择负权点 $j$ ，恰好减去了所谓的体验值。
3. 割断了 $(s,i)$，也就是选择了负权点 $j$ ，放弃了正权点 $i$，同时也没有减去体验值。

图示：

![](https://cdn.luogu.com.cn/upload/image_hosting/wmfrs0uz.png)

### 最优性

最小割 $=$ 不选择的正权点之和 $+$ 选择的负权点之和的绝对值 $+$ 减少的 $d$。

答案 $=$ 选择的正权点之和 $+$  选择的负权点之和 $-$ 减少的 $d$ 。

最小割保证了答案最大。

代码看别的博客吧。

## 二、集合划分模型

众所周知，最小割不可以跑负权边。

由于有负数，根据数据范围把所有的分数 $v_x$ 都加上一个大正整数 $base$ 使得所有 $v_x$ 都变为正数。 

设 $v'_x=v_x+base$

### 建图

* $(s,i,v'_i),(i,t,base)$

* $(i,j,d_{i,j})$

答案 $=$ $\sum\limits_{i=1}^n v_i+base\times n-最小割$

### 含义

* 割断 $(s,i)$ 表示 $i$ 不选择，割断 $(i，t)$ 表示选择 $i$。

### 正确性

原来没有加上 $base$ 的正权网络是正确的，加上以后为什么还是对的呢？

根据含义，总共会割 $n$ 条与 $s$ 或者 $t$ 相接的边。所以总共额外增加的 $base\times n$。而所有情况都有额外加上了 $base\times n$ ，相对的大小就不变了。

### Code：

```cpp
//Dinic...

const int eps=2e3;
signed main(){
    rg int i,x,y,z,sum=0;
    read(n);read(m);s=0;t=n+1;
    for (i=1;i<=n;i++) read(x),Dinic::ins(s,i,x+eps),Dinic::ins(i,t,eps),sum+=x;
    while (m--) read(x),read(y),read(z),Dinic::ins(x,y,z);
    sum=sum+eps*n-Dinic::Dinic();
    printf("%lld",sum);
    return 0;
}
```


---

## 作者：block_in_mc (赞：2)

## 题目大意

有 $n$ 部电影，观看其中的第 $i$ 部就能够获得 $v_i$ 的愉悦值（或失去 $-v_i$ 点愉悦值，若 $v_i<0$）；同时也有 $m$ 个限制 $(i,j,d_{i,j})$，代表若观看其中的第 $i$ 部但没有观看第 $j$ 部就会失去 $d_{i,j}$ 点愉悦值（不可逆）。求所能获得的愉悦值的最大值。

## 解题思路

使用类似于求解最大权闭合子图的建图方法，设起点为 $s$，终点为 $t$：

* 若 $v_i\ge0$，就在 $s$ 与 $i$ 之间建容量为 $v_i$ 的边；
* 若 $v_i<0$，就在 $i$ 与 $t$ 之间建容量为 $-v_i$ 的边；
* 对于限制 $(i,j,d_{i,j})$，在 $x$ 与 $y$ 之间建容量为 $\inf$ 的边。
  
设 $S=\sum\limits_{v_i\ge0}v_i$，图的最小割为 $e$，则答案为 $S-e$。

现在来证明这样做的正确性：

不妨考虑这样一个简单的图： $s\rightarrow x\rightarrow y\rightarrow t$。显然，最小割的值一定是三条边容量中的一个，否则不满足最小割的定义。

* 若割去的边为 $s\rightarrow x$，代表不看 $x$，放弃 $v_x$ 的愉悦值，但也不用承担 $d_{i,j}$ 和 $y$ 的负愉悦值；
* 若割去的边为 $x\rightarrow y$，代表看 $x$ 但不看 $y$，获得 $v_x$ 的愉悦值并承担 $d_{i,j}$ 的负愉悦值；
* 若割去的边为 $y\rightarrow t$，代表看 $x$ 和 $y$，获得 $v_x$ 的愉悦值并承担 $v_y$ 的负愉悦值。

更加复杂的图也有着类似的解释。这样枚举了 $x,y$ 的所有情况，能够正确求出答案。

AC 代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 10000, M = 100000;
struct edge { int st, ed, v; } e[M];
vector<int> g[N];
int n, m, s, t, u, v, x, mf, sum, ans, cnt = -1, pre[N], minf[N], vis[N];
void add(int st, int ed, int v) {
    e[++cnt] = {st, ed, v};
    g[st].push_back(cnt);
    e[++cnt] = {ed, st, 0};
    g[ed].push_back(cnt);
}
bool bfs() {
    memset(minf, 0, sizeof minf);
    queue<int> q; q.push(s);
    minf[s] = 0x3f3f3f3f;
    while (!q.empty()) {
        int p = q.front(); q.pop();
        for (int id : g[p]) {
            edge ed = e[id];
            if (minf[ed.ed] || ed.v == 0) continue;
            pre[ed.ed] = id;
            minf[ed.ed] = min(minf[ed.st], ed.v);
            q.push(ed.ed);
        }
        if (minf[t]) break;
    }
    return minf[t];
}
void EK() {
    while (bfs()) {
        for (int p = t; p != s; p = e[pre[p]].st) {
            e[pre[p]].v -= minf[t];
            e[pre[p] ^ 1].v += minf[t];
        }
        ans += minf[t];
    }
}
int main() {
    scanf("%d%d", &n, &m);
    s = 0, t = n + 1;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &x);
        if (x >= 0) add(s, i, x), sum += x;
        else add(i, t, -x);
    }
    for (int i = 1; i <= m; i++) {
        scanf("%d%d%d", &u, &v, &x);
        add(u, v, x);
    }
    EK();
    printf("%d", sum - ans);
    return 0;
}
```

---

## 作者：elijahqi (赞：2)

http://www.elijahqi.win/2018/01/02/luogu3872-tjoi2010%e7%94%b5%e5%bd%b1%e8%bf%b7/

题目描述

小A是一个电影迷，他收集了上百部的电影，打算从中挑出若干部在假期看完。他根据自己的口味和网上的介绍，对每部电影X都打了一个分数vX，表示自己喜欢的程度。这个分数的范围在-1000至1000之间，越大表示越喜欢。小A每看一部电影X，他的体验值就会加上vX。

另外，因为某些电影是组成一个系列的，比如著名的《终结者》系列、《黑客帝国》系列等等，如果小A只看了前一部而没有看后一部的话，他就会觉得不是很爽。准确来讲，对于任意两部不同的电影X,Y，他们可能存在一个依赖值dXY，表示如果小A看了X但是没看Y，他的体验值就会减少dXY。（注意与观看的顺序无关，只要两部都看过，就不会减少体验值）

现在他要选出若干电影来看，使得得到的总的体验值最大。如果他无法得到正的体验值，就输出0。

输入输出格式

输入格式：

输入的第一行是两个整数：电影总数N和依赖关系数目M。第二行包含用空格隔开的N个数，表示对每部电影的打分。接下来M行，每行包含三个整数X, Y, dXY，表示一个依赖关系。每个有序对(X,Y)最多出现一次。(1 ≤ X,Y ≤ N)

输出格式：

输出一个整数，表示小A能得到的最大体验值。

输入输出样例

输入样例#1： 复制

2 2
100 -50

1 2 49
2 1 10

输出样例#1： 复制

51
说明
如果小A只看电影1，体验值为100-49 = 51。如果只看电影2，体验值为-50-10 = -60。如果两部都看，体验值为100+(-50) = 50。所以应该只看电影1。

数据规模与约定

对于20%的数据，1 ≤ N ≤ 15

对于100%的数据，1 ≤ N ≤ 100, -1000 ≤ vX ≤ 1000, 0 < dXY ≤ 1000

每个测试点时限1秒

这题可以看作是最大权闭合子图的一个扩展问题 其实和那个bzoj ceoi2008 order挺像的 想了一天也没想到方法去膜了下题解 发现其实有一种情况我是可以不去考虑的 比如我这个电影的值是负数 如果选了他 没选别的 也会有一个代价 那其实这条边我是始终也不需要考虑的

我首先从源点向每个权值为正的电影连边 然后如果这个电影的权值为负数 那么我就从这个电影向汇点连边 然后如果每个电影之间存在关系 那么直接连边即可 这样的话就被转化成一个最小割问题 这个问题分为三个部分 首先是我不看这个电影带来的损失（注意如果存在关联 且没看是在现有的基础上倒扣 所以这个建图成立  其次如果存在关联 我不去看后面的电影也有可能带来损失  最后如果我必须得看这个电影 那么因为权值是负数 所以也会带来损失 跑一下最大流 用正权的总和-最大流即可

唉还是太菜啊 怎么办呢qwq

另外跪膜Icefox大佬 提供的另外一种做法 是什么呢 就是因为存在负的 所以我可以 用1000-一下每个权值 这样求出来的最小割 然后再用点数\*1000- 最小割就是我想要的最大的答案了 因为这题其实我读题的时候还是有误差 觉得自己太菜了 仍然 要努力啊  做法就是 我源向每个点连 1000的 边  然后每个点向 汇连 1000-权值的边 然后 如果有限制 那么就在两个点之间直接嗯连限制的那个权值的边 然后就像我刚刚说的 用点数\*1000- 最小割 为什么这么做 其实道理差不多 因为 相当于我这个点可以不选 那么我就没有收益了 这1000的边就被我割去了  如果互相之间有关联的话 如果那个权值我没有选的话 那么是不是我相当于是这1000就没了 那我还要限制一下如果选了那个点 没选这个点之间的边 要么割掉 要么不选那个点 一开始我认为这1000的权值太小了 如果我选了这个点 不选其他点的代价太大 那么会不够好 显然是不对的 因为如果我最终收益肯定<0那么我干脆哪个都不选为0即可

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define inf 0x3f3f3f3f
#define N 110
using namespace std;
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if(T==S) return EOF;}
    return *S++;
}
inline int read(){
    int x=0,f=1;char ch=gc();
    while(ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=gc();}
    while(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=gc();}
    return x*f;
}
struct node{
    int y,z,next;
}data[N*N*2];
int num=1,h[N],level[N],n,m,T;
inline void insert1(int x,int y,int z){
    data[++num].y=y;data[num].z=z;data[num].next=h[x];h[x]=num;
    data[++num].y=x;data[num].z=0;data[num].next=h[y];h[y]=num;
}
inline bool bfs(){
    queue<int> q;memset(level,0,sizeof(level));level[0]=1;q.push(0);
    while(!q.empty()){
        int x=q.front();q.pop();
        for (int i=h[x];i;i=data[i].next){
            int y=data[i].y,z=data[i].z;
            if (level[y]||!z) continue;level[y]=level[x]+1;q.push(y);if (y==T) return 1;
        }
    }return 0;
} 
inline int dfs(int x,int s){
    if (x==T) return s;int ss=s;
    for (int i=h[x];i;i=data[i].next){
        int y=data[i].y,z=data[i].z;
        if (level[x]+1==level[y]&&z){
            int xx=dfs(y,min(s,z));if (!xx) level[y]=0;
            s-=xx;data[i].z-=xx;data[i^1].z+=xx;if (!s) return ss;
        }
    }return ss-s;
}
int main(){
    freopen("3872.in","r",stdin);
    n=read();m=read();T=n+1;int sum=0;
    for (int i=1;i<=n;++i){
        int tmp=read();if (tmp>=0) insert1(0,i,tmp),sum+=tmp;else insert1(i,T,-tmp);
    }
    for (int i=1;i<=m;++i){
        int x=read(),y=read(),z=read();
                if (z<0)continue;
        insert1(x,y,z);
    }int ans=0;while(bfs()) ans+=dfs(0,inf);
    printf("%d",sum-ans);
    return 0;
}
```

---

## 作者：一E孤行 (赞：1)

~~看到题目首先懵逼~~

## 前置芝士：最大权闭合图的求解

### 题意

我们把每个电影看成一个点，点权有正有负，让你选一些点，是点权和最大，并且如果算出来的最大值为负数，可以一个不选使得答案成为 $0$

### ~~胡乱~~分析

点权有正有负、最大值、不能为负数，一下自己就能想到最大闭合权图。但这跟普通的最大权闭合图还不大一样。普通的模板是啥呢？选了一个点，他后面的点必须选，但在这个题中可以不选，但是要付出一定的代价（扣分呗）

我们在普通最大权闭合图中的处理方式是：在正权点和负权点之间连容量为 $inf$ 的边，这样可以保证最小割不会割断这些边，从而保证某个选了的点后面的点全部会被选上。

那么回到这道题，既然他规定可以不选其后置节点，那我们就把那些连接正权点和负权点的边的容量改为 $d$ ,（ $d$ 为选了前置节点但不选后置节点所要扣的分）。这样我们在求最小割的时候，就能保证最小割可以隔断这些边让其不选后置节点。最小割求出来了，剩下的就是常规的最大权闭合图的操作了， $ans=sum-Dinic() $  （ $ans$ 是答案， $sum$ 是所有正权点的和， $Dinic()$ 是根据最大流=最小割求出的最小割的大小。


上~~才艺~~代码
------------
```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<iostream>
#include<cstring>
#include<ctime>
using namespace std;
#define int long long 
const int inf=4e9;
#define maxn 300
struct aaaa{
    int to,next,c;
}a[maxn*20];
int head[maxn],d[maxn],tot,s,t,n,m,ans;
void add(int x,int y,int z)
{
    a[tot].to=y;
    a[tot].c=z;
    a[tot].next=head[x];
    head[x]=tot++;
}
bool bfs()
{
    memset(d,-1,sizeof(d));
    d[s]=0;
    queue<int> q;
    q.push(s);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=head[u];~i;i=a[i].next)
        {
            int v=a[i].to;
            if(a[i].c&&d[v]==-1)
            {
                d[v]=d[u]+1;
                q.push(v);
            }
        }
    }
    return d[t]!=-1;
}
int dfs(int u,int flow)
{
    if(u==t)
        return flow;
    int res=0;
    for(int i=head[u];~i;i=a[i].next)
    {
        int v=a[i].to;
        if(a[i].c&&d[v]==d[u]+1)
        {
            int tmp=dfs(v,min(flow,a[i].c));
            res+=tmp;
            flow-=tmp;
            a[i].c-=tmp;
            a[i^1].c+=tmp;
            if(!flow)
                break;
        }
    }
    if(res==0)
        d[u]=-1;
    return res;
}
int Dinic()
{
    int res=0;
    while(bfs())
        res+=dfs(s,inf);
    return res;
}


signed main()
{
    clock_t c1=clock();
#ifdef LOCAL
    freopen("in.in","r",stdin);
    freopen("out.out","w",stdout);
#endif
    //=========================================
     scanf("%lld%lld",&n,&m);
     memset(head,-1,sizeof(head));
     s=0,t=n+1;
     for(int i=1;i<=n;i++)
     {
         int x;
         scanf("%lld",&x);
         if(x>0)
            add(s,i,x),add(i,s,0),ans+=x;
        else
            add(i,t,-x),add(t,i,0);
     }
     for(int i=1;i<=m;i++)
     {
         int x,y,z;
         scanf("%lld%lld%lld",&x,&y,&z);
         add(x,y,z);
         add(y,x,0);
     }
     printf("%lld\n",ans-Dinic());
    //=========================================
end:
    cerr<<"Tmie Used:"<<clock()-c1<<"ms"<<endl;
    return 0;
}
```


---

## 作者：mqmhaaaa1 (赞：1)

# 水提
首先想到把每个电影看作点，再以之间的关系连边，然后就是跑最小割计算贡献（正难则反嘛

# 具体来说
答案必定是 $sum-maxflow$

## 先考虑 $sum$
首先~~不~~难想出只有观赏体验为正的电影才有正贡献，也就是说，在没有电影之间关系的时候，我们只需要选贡献为正的电影看必定能获得最大体验值，所以意思是**我们选择观影体验为正的电影时，会获得相应的贡献**

所以我们的 $sum$ 就是所有正观影体验值之和
## 再考虑建图
首先我们用源点 $s$ 当为选这个点，汇点 $t$ 作为不选

那么就像上面说的**我们选择观影体验为正的电影时，会获得相应的贡献**

所以 $s$ 向所有观影体验为正的电影连容量为对应体验的边

然后是负体验的电影，我们可以把他们想象成**我们不选这些电影时，会获得相应体验的绝对值**

因为我们的 $sum$ 里本来就没加这些体验值，而选了后反而会减少对应的体验值，所以这些体验值为负的电影向s连容量对应体验值绝对值的边

但还有一种就是电影之间存在系列关系的电影，这也是本体重点

因为本来我们就不会去看负观影体验的电影，而正观影体验的电影我们本来就会贪心的想看，因此我们只把**由正观影体验的电影向其他电影这样的关系看作有用**（注意，这是单向的）

然后我们考虑，我们需要比较是单看这部电影再减去 $dXY$ 的体验值大还是这两部电影一起看体验值大

不难想出我们可以按关系将连个点连边（单向的!!!），容量为 $dXY$

为啥对呢

首先我们想想，上面说的两个要比较的东西在图中不就是割掉另一部电影与t连边还是割掉两个电影之间连边哪个小嘛

如果割了两个电影之间的连边，就说明不看另一部，否则，就是两部都看

那么，当流量能到达汇点，就说明我们有了负贡献，也就是最大流增加，也就是统计答案了

附上丑陋的代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll int
inline void write(ll x) {static ll sta[35];ll top = 0;do {sta[top++] = x % 10, x /= 10;} while (x);while (top) putchar(sta[--top] + 48);}
inline ll read() {ll x = 0, w = 1;char ch = 0;while (ch < '0' || ch > '9') {  if (ch == '-') w = -1;ch = getchar();}while (ch >= '0' && ch <= '9') {x = x * 10 + (ch - '0'); ch = getchar(); }return x * w; }
const ll N=5e4+20,M=2e6+10,inf=0x3f3f3f3f;
ll to[M<<1],nxt[M<<1],bh[N],w[M<<1],tot=1;
ll head[N],st[N];
ll s,t;
bool vis[N];
inline void add(ll u,ll v,ll z){
	to[++tot]=v;
	nxt[tot]=bh[u];
	w[tot]=z;
	bh[u]=tot;
	
	to[++tot]=u;
	nxt[tot]=bh[v];
	w[tot]=0;
	bh[v]=tot;
}
inline bool bfs(){
	memset(st,0,sizeof st);
	memcpy(head,bh,sizeof bh);
	queue<ll>q;
	q.push(s);
	vis[s]=1;
	st[s]=0;
	while(q.size()){
		ll u=q.front();q.pop();
		vis[u]=0;
		for(ll i=bh[u];i;i=nxt[i]){
			ll v=to[i];
			if(w[i]&&!st[v]&&v^s){
				st[v]=st[u]+1;
				if(v==t)return 1;
				if(!vis[v])vis[v]=1,q.push(v);
			}
		}
	}
	return st[t];
}
ll mxf=0;
ll dinic(ll u,ll flow){
	vis[u]=1;
	if(u==t){
		mxf+=flow;return flow;
	}
	ll zy=0;
	for(ll i=head[u];i&&zy<=flow;i=nxt[i]){
		ll v=to[i];head[u]=i;
		if(w[i]&&st[v]==st[u]+1&&(!vis[v]||v==t)){
			ll jb=dinic(v,min(w[i],flow-zy));
			w[i]-=jb;w[i^1]+=jb;
			zy+=jb;
		}
	}
	vis[u]=0;
	return zy;
}
ll n,m;
ll num=0;
int main(){
	n=read();m=read();
	s=0;t=n+1;
	for(ll i=1;i<=n;++i){
		ll val=read();
		if(val>0)add(s,i,val),num+=val;//只有正贡献才加上 
		else add(i,t,-val);//记得是绝对值 
		//正贡献连s，负贡献连t 
	}
	for(ll i=1;i<=m;++i){
		ll u=read(),v=read(),val=read();
		add(u,v,val);//单向关系，所以是单向边 
	}
	while(bfs()){
		vis[t]=1;
		while(vis[t]){
			memset(vis,0,sizeof vis);
			dinic(s,inf);
		}
	}
	if(num-mxf<=0)putchar('0');//小于0就取0 
	else write(num-mxf);
	return 0;
}
```

写了一个静校的题解，用词不准请见谅

---

## 作者：creation_hy (赞：0)

这水题呀。提供一种更好想到的做法。

题意一眼最小割，然后约束看上去很像 P1361 是不是，唯一的区别就是加了负权，做了一个选择可能还有惩罚。那直接照搬就不行了，因为网络流不能带负权嘛，而且改成了一个选一个不选才有贡献。

处理方法很简单，反过来想，就相当于开局给了你个惩罚，但是你如果同时选了 $x,y$ 或者没选 $x$ 再给你个奖励。

然后对于本身权值就是负权的点同理，开局给惩罚，如果你不选他再给奖励。

选第一类的点视为选，第二类视为不选，然后跑个最小割就行了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e4 + 5;
const int M = 1e5 + 5;
const ll inf = 1e18;
int n, m, s, t, etot, head[N], to[M], nxt[M], stt[N], d[N], b[N];
ll val[M];
inline void link(int u, int v, ll w)
{
    to[etot] = v;
    nxt[etot] = head[u];
    val[etot] = w;
    head[u] = etot++;
}
inline void add(int u, int v, ll w)
{
    link(u, v, w);
    link(v, u, 0);
}
inline bool bfs()
{
    queue<int> q;
    memset(d, 0, sizeof(d));
    d[s] = 1;
    q.emplace(s);
    while (!q.empty())
    {
        int x = q.front();
        q.pop();
        for (int i = head[x]; ~i; i = nxt[i])
            if (!d[to[i]] && val[i])
            {
                d[to[i]] = d[x] + 1;
                q.emplace(to[i]);
                if (to[i] == t)
                    return true;
            }
    }
    return false;
}
inline ll dfs(int x, ll flow)
{
    if (x == t)
        return flow;
    ll res = 0;
    for (int &i = stt[x]; ~i && res < flow; i = nxt[i])
        if (d[to[i]] == d[x] + 1 && val[i])
        {
            ll tmp = dfs(to[i], min(flow - res, val[i]));
            if (tmp)
            {
                res += tmp;
                val[i] -= tmp;
                val[i ^ 1] += tmp;
            }
        }
    return res;
}
inline ll dinic()
{
    ll res = 0;
    while (bfs())
    {
        memcpy(stt, head, sizeof(head));
        res += dfs(s, inf);
    }
    return res;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    memset(head, -1, sizeof(head));
    cin >> n >> m, s = 0, t = n + m + 1;
    int sum = 0;
    for (int i = 1, x; i <= n; i++)
    {
        cin >> x;
        if (x > 0)
            add(s, i, x), sum += x;
        else
            add(i, t, -x);
    }
    for (int i = 1, x, y, w; i <= m; i++)
    {
        cin >> x >> y >> w, b[x] += w;
        add(s, i + n, w), add(i + n, x, w), add(i + n, y, w);
    }
    for (int i = 1; i <= n; i++)
        add(i, t, b[i]), sum += b[i];
    cout << sum - dinic() << '\n';
    return 0;
}
```

---

## 作者：mjsdnz (赞：0)

+ [原题链接](https://www.luogu.com.cn/problem/P3872)

## 题目大意

有 $n$ 个物品，选第 $i$ 个物品可以产生 $x_{i}$ 的贡献（可正可负）。其中有些物品有配对，如果 $a$ 物品和 $b$ 物品配对，若只选择了其中的一个，则会产生 $-d_{a,b}$ 的贡献，求最大的贡献值。

## 建模

很明显的最小割建模，在不考虑配对的情况下，从源点向贡献为正的物品连边，贡献为负的物品向汇点连边，流量为 $\left | x_{i} \right |$。

下面考虑配对的情况，我们可以直接在 $a$ 和 $b$ 之间连一条流量为 $d_{a,b}$ 的边，在跑最小割的时候，只有 $a$ 和 $b$ 不在同一边是该边才会产生贡献，符合我们的要求。

最后用所有物品的正贡献减去最小割即是答案。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4 + 10;
const int inf = 0x3f3f3f3f;
int cnt = 1;
int n,m,s,t;
int head[N];
struct edge {
	int u, v, c, val, nxt;
	edge(int u = 0, int v = 0, int c = 0, int val = 0, int nxt = 0): u(u), v(v), c(c), val(val), nxt(nxt) {}
}e[N*10];
void ADD(int u,int v,int c){
	cnt++;
	e[cnt]=edge(u,v,c,0,head[u]);
	head[u]=cnt;
}
void add_edge(int u,int v,int c){
	ADD(u,v,c);
	ADD(v,u,0);
}
int now[N],dep[N];
bool bfs(){
	memcpy(now,head,sizeof head);
	memset(dep,0,sizeof dep);
	queue<int>q;
	dep[s]=1;
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=e[i].nxt)
		{
			int v=e[i].v;
			int c=e[i].c;
			if(!c||dep[v]!=0) continue;
			dep[v]=dep[u]+1;
			q.push(v);
		}
	}
	return dep[t]!=0;
}
int dfs(int u,int t,int flow){
	if(u==t) return flow;
	int nowflow=0;
	for(int i=now[u];i&&flow>nowflow;i=e[i].nxt){
		now[u]=i;
		int v=e[i].v;
		int c=e[i].c;
		if(!c||dep[v]!=dep[u]+1) continue;
		int ff=dfs(v,t,min(c,flow-nowflow));
		if(ff) nowflow+=ff,e[i].c-=ff,e[i^1].c+=ff;
		else dep[v]=inf;
	}
	return nowflow;
}
int maxflow(){
	int ans=0;
	while(bfs()){
		int nowflow;
		while((nowflow=dfs(s,t,inf))) ans+=nowflow;
	}
	return ans;
}
int main() {
	cin>>n>>m;
	s=n+1,t=s+1;
	int sum=0;
	for(int i=1;i<=n;i++){
		int aa;
		cin>>aa;
		if(aa>0) add_edge(s,i,aa),sum+=aa;
		else add_edge(i,t,-aa);
	}
	for(int i=1;i<=m;i++){
		int aa,bb,val;
		cin>>aa>>bb>>val;
		add_edge(aa,bb,val);
	}
	cout<<sum-maxflow();
}
```

---

## 作者：pldzy (赞：0)


[传送门：P3872 [TJOI2010]电影迷](https://www.luogu.com.cn/problem/P3872)

**以最大权闭合子图为基础，再加上一点小拓展。**

本题解主要是想~~细~~讲一下最大权闭合子图。

## 最大权闭合子图

### 1. 概念

- 闭合子图：在原图 $G$ 的闭合子图中，每一个节点，它在 $G$ 中所能到达的所有节点都包含在这个子图中。

- 最大权闭合子图：即原图 $G$ 中点权之和最大的闭合子图。

### 2. 运用

目标：求一图的最大权闭合子图。

#### <1>

先建立一超级源点和超级汇点。

对于每个带权值的节点：

- 若节点为正，则与超级源点相连，流量为该点权值；
- 反之，则与超级汇点相连，流量为该点权值相反数。

很明显，在不考虑“每个点在 $G$ 中所能到达的所有节点都包含在这个子图中”这个限制条件时，最大权“闭合子图”肯定是所有正权值之和，也就是现在与源点相连的所有边流量之和。

此时，上述的建边方式的原因就清楚明了了：区分开来正负权值的点。

#### <2>

然后再加上限制，在点和点之间建边。

此时可以隐约发现：我们会使用最小割去求出最大权子图。

割去一些边，使源点与汇点不相连，最后源点所在的那个子图即为原图的最大权闭合子图。

回过头来：这些边的流量是什么？

这些边的流量为 $inf$。因为“每个点在 $G$ 中所能到达的所有节点都包含在这个子图中”，所以要保证这些边不会被割去。

#### <3> 

此时可以发现，被割去的边都是与源点或者汇点相连的边。

- 若一负权值节点与汇点相连的边被割去：

	说明此时它放在最大权闭合子图中是最优的状态，但最大权闭合子图的权值和要减去该点权值的绝对值。
    
- 若一正权值节点与汇点相连的边被割去：

	说明此时它不放在最大权闭合子图中是最优的状态，但最大权闭合子图的权值和要减去该点权值。
    
这样一来，最大权闭合子图的权值和就是：正权值之和 - 最小割。

然后最小割转化为最大流去求解即可。

## 回归本题

可以看到，最大权闭合子图模板中，原图中的边不能删去，但本题可以删去。

只是删去这条边也需要代价，那就将此边的流量设为代价而不是 $inf$ 即可。

剩下的就是最大权闭合子图的模板了。

### AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i <= b; ++i)
#define inf 10000000
#define maxn 700
#define maxm 1000005

int n, m;
int sa[maxn];
int cnt = 1, hd[maxn];
struct node{
	int to, nxt;
	int flw;
}e[maxm];
int in[maxn];
vector <int> out[maxn];
int dep[maxn], vis[maxn];
int sum, ans;
int s, t;

inline int id(int i, int j)
{
	return (i - 1) * m + j;
}

inline void add(int u, int v, int f)
{
	e[++cnt] = (node){v, hd[u], f};
	hd[u] = cnt;
	e[++cnt] = (node){u, hd[v], 0};
	hd[v] = cnt;
}

inline void topo()
{
	queue <int> q;
	rep(i, 1, n * m)
	{
		if(!in[i])
			vis[i] = 1, q.push(i);
	}
	while(!q.empty())
	{
		int u = q.front();
		q.pop();
		for(int i = 0; i < out[u].size(); ++i)
		{	
			int v = out[u][i];
			in[v] -= 1;
			if(!vis[v] and !in[v])
				vis[v] = 1, q.push(v);
		}
	}
}

inline bool bfs()
{
	queue <int> q;
	memset(dep, 0, sizeof dep);
	dep[s] = 1, q.push(s);
	while(!q.empty())
	{
		int u = q.front();
		q.pop();
		for(int i = hd[u], v; i; i = e[i].nxt)
		{
			if(!dep[v = e[i].to] and e[i].flw)
				dep[v] = dep[u] + 1, 
				q.push(v);
		}
	}
	return dep[t] ? 1 : 0;
}

inline int dfs(int u, int cm)
{
	if(u == t or !cm) return cm;
	int lv = 0;
	for(int i = hd[u], v; i and cm; i = e[i].nxt)
	{
		if(!e[i].flw) continue;
		if(dep[v = e[i].to] != dep[u] + 1) continue;
		int res = dfs(v, min(cm, e[i].flw));
		e[i].flw -= res; 
		e[i ^ 1].flw += res;
		cm -= res, lv += res;
	}
	if(!lv) dep[u] = 0;
	return lv;
}

inline int dinic()
{
	while(bfs())
		ans += dfs(s, inf);
	return ans;
}

signed main()
{
	scanf("%d%d", &n, &m);
	s = n + 1, t = s + 1;
	rep(i, 1, n) 
	{
		scanf("%d", &sa[i]);
		if(sa[i] < 0) add(i, t, -sa[i]);
		else add(s, i, sa[i]), sum += sa[i];
	}
	rep(i, 1, m)
	{
		int ut, vt, dt;
		scanf("%d%d%d", &ut, &vt, &dt);
		add(ut, vt, dt);
	}
	printf("%d\n", sum - dinic());
	return 0;
}
```


------------
感谢阅读。

辛苦管理员审核，若有问题烦请指出。

---

## 作者：向日葵小班 (赞：0)

### 题意：
给出一张 $n$ 个点的有向图，点有点权 $w$，有正有负，边有边权 $c$，均为正。

选出点集 $X$ 使得 $\sum_{u\in X} W_u-\sum_{u\in X,v\notin X} c[u\rightarrow v]$ 最大。（点权和减去伸出点集的边权和）

$n\le100$

### 做这题我们要先学会闭合子图

闭合子图：
对于一张有向图的导出子图 $W$，若 $W$ 没有指向 $W$ 外的出边，称为闭合子图。

最大权闭合子图：
点有点权（有正有负），选出点权和最大的闭合子图。

------------
这是扩展的最大权闭合子图问题：原先是要求一定闭合，现在可以花费某种代价删去一条有向边的约束。

仍然考虑类似的建图，正权点连源，负权点连汇，有向边的边权不再是正无穷而是删去（割去）的代价。

答案方案仍然是最小割 $V_S$ 中的点集。

---

## 作者：IceFox (赞：0)

欢迎访问蒟蒻的博客：[传送门](http://blog.csdn.net/Icefox_zhx/article/details/78949041 "传送门")

我是类似[这道题](http://blog.csdn.net/Icefox_zhx/article/details/78854953)想到的建图方法。因为有负权，所以我用delta都先减他们一下，都变成正权，使原点权和最大，就变成了使现点权和最小，就可以用最小割啦。S向所有点建边，容量为delta，唤作第一层，所有点向T建边，容量为delta-点权，唤作第二层。对于有限制的边，建边x->y,容量为val。对于每个点，第一二层必割一条，割第一层，就代表不选这个点，割第二层，就代表选这个点。如果x选了，y没选，x->y有边，则一定会把这条边割掉，符合题意。

Elijahqi提供了另一种建图方式：类似[order](http://blog.csdn.net/Icefox_zhx/article/details/78890586)这题。S向正权点建边，容量为点权，负权点向T建边，容量为点权绝对值，x->y的限制就直接建x->y。最后拿正权和-最小割就是答案。

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define N 110
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    return x*f;
}
int n,m,h[N],num=1,cur[N],T=101,lev[N],del=1000,ans=0;
struct edge{
    int to,next,val;
}data[20500];
inline void add(int x,int y,int val){
    data[++num].to=y;data[num].next=h[x];h[x]=num;data[num].val=val;
    data[++num].to=x;data[num].next=h[y];h[y]=num;data[num].val=0;
}
inline bool bfs(){
    queue<int>q;memset(lev,0,sizeof(lev));
    q.push(0);lev[0]=1;
    while(!q.empty()){
        int x=q.front();q.pop();
        for(int i=h[x];i;i=data[i].next){
            int y=data[i].to;if(lev[y]||!data[i].val) continue;
            lev[y]=lev[x]+1;if(y==T) return 1;q.push(y);
        }
    }return 0;
}
inline int dinic(int x,int low){
    if(x==T) return low;int tmp=low;
    for(int &i=cur[x];i;i=data[i].next){
        int y=data[i].to;if(lev[y]!=lev[x]+1||!data[i].val) continue;
        int res=dinic(y,min(tmp,data[i].val));
        if(!res) lev[y]=0;else tmp-=res,data[i].val-=res,data[i^1].val+=res;
        if(!tmp) return low;
    }return low-tmp;
}
int main(){
//    freopen("a.in","r",stdin);
    n=read();m=read();
    for(int i=1;i<=n;++i) add(0,i,del),add(i,T,del-read()),ans+=del;
    while(m--){
        int x=read(),y=read();add(x,y,read());
    }while(bfs()){memcpy(cur,h,sizeof(cur));ans-=dinic(0,inf);}
    printf("%d\n",ans);
    return 0;
}
```

---


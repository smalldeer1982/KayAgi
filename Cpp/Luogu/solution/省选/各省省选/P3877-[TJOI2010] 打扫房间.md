# [TJOI2010] 打扫房间

## 题目描述

学校新建了一批宿舍，值日生小A要把所有的空房间都打扫一遍。这些宿舍的布局很奇怪，整个建筑物里所有的房间组成一个N \* M的矩阵，每个房间的东南西北四面墙上都有一个门通向隔壁房间。另外有些房间是堆放杂物的，无需打扫。小A想设计若干条打扫路线，使得恰好进出每个需打扫的房间各一次，而且进出每个房间不能通过同一个门。要求每条路线都是一个闭合的环线，并且每条路线经过的房间数大于2。

如下面两图所示均为满足要求的打扫方案（灰色格子为放杂物的房间）：

 ![](https://cdn.luogu.com.cn/upload/pic/6841.png) 

小A发现对于某些房间布局是不存在这样的满足要求的方案的。他请你写一个程序计算一下，对于一种给定的房间布局，满足要求的方案是否存在。


## 说明/提示

对50%的数据，3 ≤ N,M ≤ 12

对100%的数据，3 ≤ N,M ≤ 30

每个测试点时限1秒


## 样例 #1

### 输入

```
4
3 4
##..
....
....
3 4
##..
....
#...
3 4
##..
#...
#...
3 4
####
#..#
####
```

### 输出

```
YES
NO
YES
NO
```

# 题解

## 作者：ShineEternal (赞：1)

# 写在前面：
如想获取更佳阅读效果，请点击[这里](https://blog.csdn.net/kkkksc03/article/details/89043231)，任何疑问欢迎私信作者！

# 分析：
首先整理一下条件：
1、恰好进出每个需打扫的房间各**一次**

2、进出每个房间不能通过同一个门

（其实前两个条件是一回事）

3、要求每条路线都是一个**闭合的环线**

4、每条路线经过的房间数大于**2**

让你在一个n*m的矩阵中，找出是否能按照约定方案打扫全部指定房间。

### 首先不难得出一个结论：有奇数个需要打扫的房间时一定无解。

#### 证明？
每一次打扫都要满足条件3和4，而闭合的环线为多边形，显然必须对称（即通过平移可得到矩形），不难看出：每一次都能且只能打扫**偶数**个房间。

然后稍作分析，发现每个格子的度为**2**（即进入此房再出去）。

#### 考虑建图。


一个房间上下左右有门，我们自然而然想到一个点向周围四个连边，就构成了黑白染色的模型。

一个矩阵中的房间最多用两条路线打扫即可。

每个点都要走到。
所以每个点都会向上下左右异色格点流出1，同时也会接受另一个点的流入。

我们这时将白点流向黑点的流反向，这样每个白点流入2，每个黑点流出2。

于是每个点有2的流量，来说明可以有两条边和它相连。

黑点都向S连边，白点都向T连边

然后图建好了，开始跑网络流，如果满流就证明所有的点都进，出过一次，打扫完毕，输出yes；否则no

### 建图总结：

 - 节点含义：房间
 - 边的含义：打扫路线
 - 边如何相连：四连通
 - 源点S：矩阵外一点
 - 汇点T：矩阵外一点

# 代码：

```cpp

#include<cstdio>
#include<vector> 
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
#define inf 0x7fffffff
int n,m,s,t,ans;
int gx[5]={0,0,-1,0,1};
int gy[5]={0,-1,0,1,0};
//int gy[5]={0,-1,1,0,0};
//int gx[5]={0,0,0,-1,1};
int d[1000],id[105][105];
char a[105][105];
struct edge
{
    int to,val,rev;
    edge(int _to,int _val,int _rev)
    {
        to=_to;
        val=_val;
        rev=_rev;
    }
};
vector<edge>e[1000];
void add(int x,int y,int w)
{
    e[x].push_back(edge(y,w,e[y].size()));
    e[y].push_back(edge(x,0,e[x].size()-1));
}
bool bfs()
{
   memset(d,-1,sizeof(d));
    
    queue<int>q;
   
    q.push(s);
    d[s]=0;
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for(int i=0;i<e[x].size();i++)
        {
            int y=e[x][i].to;
            if((d[y]==-1)&&e[x][i].val)
            {
            	q.push(y);
                d[y]=d[x]+1;
                
            }
        }
    }
    if(d[t]==-1)
    return 0;
    else
    return 1;
}
int dfs(int x,int low)
{
    if(x==t||low==0)return low;
    int totflow=0;
    for(int i=0;i<e[x].size();i++)
    {
        int y=e[x][i].to;
        int rev=e[x][i].rev;
        if((d[y]==(d[x]+1))&&e[x][i].val)
        {
            int a=dfs(y,min(low,e[x][i].val));
            e[x][i].val-=a;
            e[y][rev].val+=a;
            low-=a;
            totflow+=a;
            if(low==0)return totflow;
        }
    }
    if(low!=0)d[x]=-1;
    return totflow;
}
int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        for(int i=0;i<=1000;i++)
        e[i].clear();
        int cnt=0,tot=0,sum=0;
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=m;j++)
            {
                cin>>a[i][j];
                id[i][j]=++cnt;
                if(a[i][j]=='.')tot++;
            }
        }
        s=0;
        t=cnt+1;
        if(tot%2==1)
        {
            printf("NO\n");
            continue;
        }
        if((n==1)||(m==1))
        {
        	printf("NO\n");
            continue;
        }
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=m;j++)
            {
                    if(a[i][j]=='.')
                    {
                if(((i+j)%2)==1)
                {
                        add(s,id[i][j],2);
                        sum+=2;
                        for(int k=1;k<=4;k++)
                        {
                            int nx=i+gx[k];
                            int ny=j+gy[k];
                            if((nx>=1)&&(nx<=n)&&(ny>=1)&&(ny<=m)&&(a[nx][ny]!='#'))
                                add(id[i][j],id[nx][ny],1);
                        }
                }
                else
                {
                    add(id[i][j],t,2);
                }
                    }
            }
        }
        ans=0;
        while(bfs())
        {
     
        ans+=dfs(s,inf);
   		}
        if(ans==tot)
        {
            printf("YES\n");
        }
        else
        printf("NO\n");
    }
    return 0;
} 


```



---

## 作者：GNAQ (赞：1)

首先很显然的结论是奇数个点是 `NO` （证明考虑路径是闭的，长度有类似对称的性质）

然后我先想到的是插头 DP ，可惜过不去。然后认真想了一下这个范围估计就是网络流。

然后往网络流上靠。 首先考虑这题目的约束条件就是要所有格都走，并且回路。

所有格都走看起来抓不出什么性质，我们看回路。

既然是回路，~~如果有一些插头 DP 的基础的话，~~ 比起普通的行走路径，我们能想到一个唯一的、非常优秀的性质：每个格的度都是 $2$ 。这个性质本身足够优秀，一个局面只要满足了这个性质，再加上合理的格子-格子之间的连边，就能出解。

这样并没有解决什么问题。因为你建不出图。

朝着建图的方向考虑。我们尝试把格子和格子之间的边用网络流图上的边代替。考虑一个点只能向四连通的点连边，这样是一个黑白格的模型。所以我们很自然的想到黑白染色。

这大概就是我的整个思考过程。再来确认一下，黑白格正好构成二分图，这样白格向黑格走流量，每个边都设单位流量表示这个白格和这个黑格连接。 黑白分别连到 $S,T$ ，每个格给 $2$ 的流量表示能连出两条边，实现 $2$ 的度数。这样就行了

最后，如果满流显然是 `YES` ，如果非满流，那肯定有格子度数不到 $2$ ，是 `NO`

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<queue>
#include<vector>
#define ll long long
using namespace std;

struct ed
{
	int pre,to,cap;
}edge[1000010];
int at=1,ptr[100010];

int ss,tt,totflow;

int n,m,mapx[110][110],id[110][110],col[110][110];
int dx[4]={0,-1,0,1},dy[4]={-1,0,1,0};

template<typename int_t>
void readx(int_t& x)
{
	x=0; int_t k=1; char ch=0;
	while (ch<'0' || ch>'9') { ch=getchar(); if (ch=='-') k=-1; }
	while (ch>='0' && ch<='9') { x=x*10+ch-'0'; ch=getchar(); }
	x*=k;
}

void Is(int fx,int tx,int wx)
{
	at++;
	edge[at].pre=ptr[fx];
	edge[at].to=tx;
	edge[at].cap=wx;
	ptr[fx]=at;
	at++;
	edge[at].pre=ptr[tx];
	edge[at].to=fx;
	edge[at].cap=0;
	ptr[tx]=at;
}

// Dinic
int lvl[100010],cur[100010];
queue<int> que;
bool BFS()
{
	memset(lvl,0,sizeof lvl); lvl[ss]=1; que.push(ss); int cac;
	while (!que.empty())
	{
		cac=que.front(); que.pop();
		for (int v=ptr[cac];v;v=edge[v].pre)
			if ((!lvl[edge[v].to]) && edge[v].cap)
			{
				lvl[edge[v].to]=lvl[cac]+1;
				que.push(edge[v].to);
			}
	}
	if (!lvl[tt]) return 0;
	memcpy(cur,ptr,sizeof ptr);
	return 1;
}
int DFS(int now,int minf)
{
	if (!minf || now==tt) return minf;
	int sumf=0,needf=0;
	for (int v=cur[now];v;v=edge[v].pre) if (lvl[edge[v].to]==lvl[now]+1)
	{
		cur[now]=v;
		if ( (needf=DFS(edge[v].to,min(minf,edge[v].cap))) )
		{
			sumf+=needf; minf-=needf;
			edge[v].cap-=needf; edge[v^1].cap+=needf;
			if (!minf) break;
		}
	}
	return sumf;
}

void Solve()
{
	memset(ptr,0,sizeof ptr); at=1;
	memset(id,0,sizeof id); totflow=0;
	memset(mapx,0,sizeof mapx);
	
	char ch; int tmp=0,cnt=0,qwq=0;
	readx(n); readx(m); 
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
		{
			ch=0; while (ch!='#' && ch!='.') ch=getchar();
			if (ch=='.') { mapx[i][j]=1; qwq++; } 
			else mapx[i][j]=0;
			id[i][j]=++tmp;
		}
	if (qwq%2) { printf("NO\n"); return; }
	
	// Build Graph
	ss=0; tt=tmp+1;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++) 
		{
			if ( ((i+j)&1) && mapx[i][j]) // white points
			{
				Is(ss,id[i][j],2); cnt+=2;
				for (int w=0;w<4;w++) if (mapx[i+dx[w]][j+dy[w]])
					Is(id[i][j],id[i+dx[w]][j+dy[w]],1);
			}
			else if (!( (i+j)&1 )) // black points
				Is(id[i][j],tt,2); 
		}
		
	while (BFS()) totflow+=DFS(ss,2*1e9);
	if (totflow==cnt) printf("YES\n");
	else printf("NO\n");
}

int main()
{
	int T; readx(T); 
	while (T--) Solve();
}
```

---

## 作者：Victorique (赞：0)

## Solution

唔，乍看上去比较像是一个搜索题。。然后可以发现的是网络流黑白染色维护这个题并不是一件很困难的事。因为如果我们能从一个门出去，那么我们反过来走一定可以从同一个门进来。这样我们就可以这么实现，把每个黑格子与源点连流量为2的边，每个白格子与汇点连流量为2的边，黑格子和白格子之间用流量为1表示转移。这样就可以轻松实现这道题。

## Code

```cpp
#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#define re register
#define inf 400000000
#define MAXN 10001
#define MAXM 100001
using namespace std;
int n,s,q,dis[2000011],t,l,cur[200051],m,tot,sum;
struct po
{
    int nxt,to,w;
}edge[MAXM];
int head[MAXN],dep[MAXN],num=-1;
char a[101][101];
int id[101][101],nm;
int dx[5]={0,1,0,-1,0};
int dy[5]={0,0,1,0,-1};
inline int read()
{
    int x=0,c=1;
    char ch=' ';
    while((ch>'9'||ch<'0')&&ch!='-')ch=getchar();
    while(ch=='-')c*=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-'0',ch=getchar();
    return x*c;
}
inline void add_edge(int from,int to,int w)
{
    edge[++num].nxt=head[from];
    edge[num].to=to;
    edge[num].w=w;
    head[from]=num;
}
inline void add(int from,int to,int w)
{
    add_edge(from,to,w);
    add_edge(to,from,0);
}
inline bool bfs()
{
    memset(dep,0,sizeof(dep));
    queue<int> q;
    while(!q.empty())
    q.pop();
    q.push(s);
    dep[s]=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(re int i=head[u];i!=-1;i=edge[i].nxt)
        {
            int v=edge[i].to;
            if(dep[v]==0&&edge[i].w>0)
            {
                dep[v]=dep[u]+1;
                if(v==t)
                return 1;
                q.push(v);
            }
        }
    }
    return 0;
}
inline int dfs(int u,int dis)
{
    if(u==t)
    return dis;
    int diss=0;
    for(re int& i=cur[u];i!=-1;i=edge[i].nxt)
    {
        int v=edge[i].to;
        if(edge[i].w!=0&&dep[v]==dep[u]+1)
        {
            int check=dfs(v,min(dis,edge[i].w));
            if(check>0)
            {
                dis-=check;
                diss+=check;
                edge[i].w-=check;
                edge[i^1].w+=check;
                if(dis==0) break;
            }
        }
    }
    return diss;
}
inline int dinic()
{
    int ans=0;
    while(bfs())
    {
        for(re int i=0;i<=t;i++)
        cur[i]=head[i];
        while(int d=dfs(s,inf))
        ans+=d;
    }
    return ans;
}
inline void prepare()
{
	memset(head,-1,sizeof(head));
	num=-1;nm=0;
	sum=0;tot=0;
}
int main() 
{
    //freopen("date.in","r",stdin);
    int T=read();
    while(T--){
    	prepare();
    	n=read();m=read();
    	for(re int i=1;i<=n;i++)
    		for(re int j=1;j<=m;j++){
    			cin>>a[i][j];
    			id[i][j]=++nm;
    			if(a[i][j]!='#') tot++;
    		}
    	s=0;t=n*m+1;
    	if(tot%2==1){cout<<"NO"<<endl;continue;}
    	for(re int i=1;i<=n;i++)
    		for(re int j=1;j<=m;j++){
    			if(i+j&1==1){
    				if(a[i][j]!='#'){
    					add(s,id[i][j],2);sum+=2;
    					for(re int k=1;k<=4;k++){
    						int lx=i+dx[k],ly=j+dy[k];
    						if(lx>=1&&lx<=n&&ly>=1&&ly<=m&&a[lx][ly]!='#')
    							add(id[i][j],id[lx][ly],1);
    					}
    				} 
    			}else add(id[i][j],t,2);
    		}
    	int d=dinic();
    	if(d==sum) cout<<"YES"<<endl;
    	else cout<<"NO"<<endl;
    }
    return 0;
}

```

---


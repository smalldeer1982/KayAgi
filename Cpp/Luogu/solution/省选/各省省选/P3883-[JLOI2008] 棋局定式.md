# [JLOI2008] 棋局定式

## 题目描述

在“jloi-08”游戏中，还存有非常非常多的棋局定式，也就是常会用到的下棋的组合。有时在学习一个著名棋局时，电脑会考一考刘先生：在这局棋里面，有多少个定式啊？分别是什么啊？


对于30~40步的普通棋局，刘先生还能回答出来，可是有时候2个实力相当的大牛下的棋局，2000000步都有可能。如果电脑对这样的棋局提上面的问题时，刘先生就必须写一个程序来帮助自己了。可是，刘先生在这方面却…，怎么写也写不对。你能帮助刘先生吗？


棋局是由很多step组成的，而step是由一个字符串组成的，比如Kh2或者是Nxb7。

前者表示K(king)移动至h2格，后者表示N(knight)移动至b7格并吃掉原有的棋子。


第一个字符可能有6种：K Q B N R P，而后面可能是一个坐标或者是字符x后跟一个坐标。


坐标是由一个小写英文字母(a~h)和一个数字(1~8)组成的。


如果一个棋局中完整地并连续地包含一个定式中所有的step，那么这个棋局便包含这个定式。


## 说明/提示

不保证给出的棋局和定式符合国际象棋的规则。


## 样例 #1

### 输入

```
2 5
3
King's Knight Opening
Pe4
Pe5
Nf3
3
Nimzowitsch Variation
Pc4
Pe5
Nf3
Pe4
Pe5
Nf3
Nc6
Bb5
```

### 输出

```
King's Knight Opening```

# 题解

## 作者：SuperJvRuo (赞：7)

乍一看字符集是所有的走法，应该是$6*8*8*2$的大小，但其实字符集应该是可能出现的所有单个字符共$6+8+8+1$，这样就可以直接用AC自动机了，速度与后缀数组做法基本相当，但是空间占用要大一些
```
#include<iostream>
#include<queue>
#include<string>
using namespace std;

int trans[128];
int cnt=0;
void init()
{
	//建立字符到整数的映射
    int cnt=0;
    trans['K']=++cnt;
    trans['Q']=++cnt;
    trans['B']=++cnt;
    trans['N']=++cnt;
    trans['R']=++cnt;
    trans['P']=++cnt;
    trans['x']=++cnt;
    trans[0]=++cnt;
    for(char i='a';i<='h';++i)
    {
        trans[i]=++cnt;
    }
    for(char i='1';i<='8';++i)
    {
        trans[i]=++cnt;
    }
}

string name[2005];
//定式名
bool vis[2005];
//是否出现

struct Tree
{
    int fail;
    int vis[26];
    int num;
}AC[800005];
//Trie树

inline void Build(string s,int num)
{
	//建树
    int l=s.length();
    int now=0;
    for(int i=0;i<l;++i)
    {
        if(AC[now].vis[trans[s[i]]]==0)
        AC[now].vis[trans[s[i]]]=++cnt;
        now=AC[now].vis[trans[s[i]]];
    }
    AC[now].num=num;
}

void Get_fail()
{
	//BFS求fail
    queue<int> Q;
    for(int i=0;i<26;++i)
    {
        if(AC[0].vis[i]!=0)
        {
            AC[AC[0].vis[i]].fail=0;
            Q.push(AC[0].vis[i]);
        }
    }
    while(!Q.empty()) 
    {
        int u=Q.front();
        Q.pop();
        for(int i=0;i<26;++i)
        {
            if(AC[u].vis[i]!=0)
            {
                AC[AC[u].vis[i]].fail=AC[AC[u].fail].vis[i];
                Q.push(AC[u].vis[i]);
            }
            else
            AC[u].vis[i]=AC[AC[u].fail].vis[i];
        }
    }
}

void AC_Query(string s)
{
    int l=s.length();
    int now=0;
    for(int i=0;i<l;++i)
    {
        now=AC[now].vis[trans[s[i]]];
        for(int t=now;t;t=AC[t].fail)
        {
            vis[AC[t].num]=1;
        } 
    }
}

int main()
{
    init();
    ios::sync_with_stdio(false);
    int n,m,k;
    string s;
    cin>>n>>m;
    for(int i=1;i<=n;++i)
    {
        string now;
        cin>>k;
        //读入k以后还没有换行，此处需要getline一下
        getline(cin,name[i]);
        getline(cin,name[i]);
        for(int j=0;j<k;++j)
        {
            cin>>s;
            now+=s;
            //全都接起来
        }
        Build(now,i);
    }
    AC[0].fail=0;
    Get_fail();
    
    string now;
    for(int i=0;i<m;++i)
    {
        cin>>s;
        now+=s;
        //接起来
    }
    AC_Query(now);
    //匹配
    for(int i=1;i<=n;++i)
    {
        if(vis[i])
        cout<<name[i]<<'\n';
    }
    return 0;
}
```
![](https://cdn.luogu.com.cn/upload/pic/15339.png )

---

## 作者：Kris_hukr (赞：1)

### 分析

这题本质上还是个 AC 自动机的板子，只需要存下定式对应的名称然后输出就好了。不会 AC 自动机的可以去[学习一下](https://www.luogu.com.cn/problem/P3796)。

只是存在一个问题：如果直接建树字符集会过大，导致 MLE。

考虑到实际棋谱中会出现的字符其实很有限，可以对每一个字符建立唯一的映射。这样再建树就不会 MLE 了。

剩下的细节见代码。

### 代码

```cpp
#include <cstring>
#include <iostream>
#include <queue>

const int MAX_N = 700050;
const int MAX_M = 2050;
const int CHA_SIZE = 35;

int tree[MAX_N][CHA_SIZE], exi[MAX_N], nxt[MAX_N], ans[MAX_M];
int tot;
std::string s[MAX_M];

int tt[255];  // 字符映射

void init();

void build();

void insert(std::string s, int c);

void query(std::string s);

int main() {
    std::ios::sync_with_stdio(false);
    init();

    int n, m;
    std::cin >> n >> m;

    auto* nam = new std::string[n + 5];
    for (int i = 1; i <= n; i++) {
        int k;
        std::cin >> k;
        std::getline(std::cin, nam[i]);  // 还有换行符未被 cin 读入
        std::getline(std::cin, nam[i]);

        for (int j = 1; j <= k; j++) {
            std::string x;
            std::cin >> x;
            s[i] += x;  // 将每个定式当作一个字符串
        }
        insert(s[i], i);
    }
    build();

    std::string k;
    for (int i = 1; i <= m; i++) {
        std::string s;
        std::cin >> s;
        k += s;  // 同理
    }
    query(k);

    for (int i = 1; i <= n; i++) {
        if (ans[i]) {  // 出现过就输出
            std::cout << nam[i] << '\n';
        }
    }

    return 0;
}

void build() {
    std::queue<int> q;
    for (int i = 0; i < CHA_SIZE; i++) {
        if (tree[0][i]) {
            q.push(tree[0][i]);
        }
    }
    while (!q.empty()) {
        int x = q.front();
        q.pop();
        for (int i = 0; i < CHA_SIZE; i++) {
            if (!tree[x][i]) {
                tree[x][i] = tree[nxt[x]][i];
            } else {
                q.push(tree[x][i]);
                nxt[tree[x][i]] = tree[nxt[x]][i];
            }
        }
    }
}

void init() {
    int cnt = 0;
    for (int i = '1'; i <= '8'; ++i) {
        tt[i] = ++cnt;
    }
    tt['B'] = ++cnt;
    tt['K'] = ++cnt;
    tt['N'] = ++cnt;
    tt['P'] = ++cnt;
    tt['Q'] = ++cnt;
    tt['R'] = ++cnt;
    for (int i = 'a'; i <= 'h'; ++i) {
        tt[i] = ++cnt;
    }
    tt['x'] = ++cnt;
}

void insert(std::string s, int c) {
    int x = 0;
    for (int i = 0; s[i]; i++) {
        int ch = tt[s[i]];
        if (!tree[x][ch]) {
            tree[x][ch] = ++tot;
        }
        x = tree[x][ch];
    }
    exi[x] = c;
}

void query(std::string s) {
    int x = 0;
    for (int i = 0; s[i]; i++) {
        int ch = tt[s[i]];
        x = tree[x][ch];
        for (int j = x; j; j = nxt[j]) {
            ans[exi[j]]++;
        }
    }
}
```


---


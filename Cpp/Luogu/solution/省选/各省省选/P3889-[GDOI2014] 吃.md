# [GDOI2014] 吃

## 题目背景

感谢 @FFjet 提醒，第 8 个数据点损坏暂时删除。

## 题目描述

W师兄计划了很久，终于成功的在BG开了一家寿司店。

正当W师兄还在兴奋的时候，这时一个噩耗传来，吃货L师姐居然知道了这件事，而且正赶过来，W师兄瞬间心就冷了下去，但是机智的W师兄也瞬间想到了应付L师姐的策略.......

这时，L师姐到了寿司店，先四处望了望风景，发现现在只有L师姐一个顾客，下面是L师姐的选餐说明：

1.寿司店内的寿司被排在一行共N个盘子里，按从左到右编号为1~N。

2.每个位置上寿司的数量是确定的并且有玻璃窗保护。

3.每隔一段时间就会有一个选餐时间，L师姐可以在一个连续的区间[l, r]中选择其中一盘，然后在该区间之外选择另一盘（如果区间外有盘子）。

L师姐发现这家寿司店厨师的制作速度很快，总能在下一次选餐时间前将寿司数量恢复原样。

作为有尊严有追求的吃货，L师姐也有自己的规则，L师姐在选完两盘寿司后，会决定每口恰好吃D个寿司，且使得两盘寿司刚好可以分别吃完，不剩余任何寿司。比如两盘寿司数量为2和4,那么D=1或者D=2都可以恰好将两盘寿司分别吃干净，而两盘寿司数量为3和5时，那么只能D=1才行。

作为有特殊追求的L师姐才不在乎吃的数量，L师姐在乎的是一口吃多个寿司的感觉。于是，如果L师姐可以一口吃D个寿司，那么L师姐的愉悦值为D，但是L师姐没有选到两盘寿司，那么她的愉悦值为0。

现在L师姐知道每个盘子所放着的寿司数量，L师姐想知道每次选择时间过后她可以获得的最大愉悦值是多少？


## 说明/提示

###样例解释

样例1里的第一个选餐时间，可以选择2和4，这样L师姐就可以每次吃两个寿司，使得两个盘子都可以吃干净，第二个选餐时间，师姐不管选哪两个盘子，都只能每次吃一个。

样例2 里的第一个选餐时间，可以选择16和32,而第二个选餐时间，L师姐可以选择8和16或者8和32。

对于20%的数据，N <= 100, M <= 100, max(a1,a2,…,aN) <= 100。

对于50%的数据，N <= 10000, M <= 10000, max(a1,a2,…,aN) <= 10000。

对于100%的数据，N <= 100000, M <= 100000, max(a1,a2,…,aN) <= 100000。


## 样例 #1

### 输入

```
5
1 2 3 4 5
2
2 3
2 4```

### 输出

```
2
1```

## 样例 #2

### 输入

```
5
2 4 8 16 32
2
3 4
2 3```

### 输出

```
16
8
```

# 题解

## 作者：Demeanor_Roy (赞：2)

- [原题链接](https://www.luogu.com.cn/problem/P3889)

- 好久没写题解了。（指一周

------------

看到 $n,m,V$ 都是 $10^5$ 级别，应该马上反应过来：这个数据范围可以支持我们一些很暴力的操作。

考虑对 $x \in [1,V]$，预处理出 $S_x$ 表示 $x$ 的倍数在序列中出现位置的集合。令 $d$ 代表 $[1,V]$ 中所有数因子数的最大值，显然这部分预处理的时间复杂度与 $\sum_{x}{\vert S_x \vert}$ 都是 $O(nd)$ 级别的。

枚举 $x$，令 $S_x ={p_1,p_2,\dots,p_k}$，显然对于询问 $[l,r]$，答案可以取到 $x$ 当且仅当：

- $p_1 < l$ 或者 $p_k > r$。

- $\exists i \in [1,k]$，满足 $l \leq p_i \leq r$。

发现第一个条件特别烦，又因为限制条件之间是**或者**的关系，考虑直接把条件拆开。换句话说，对所有询问，求出满足第一个条件前半部分与第二个条件的最大的 $x$，同理求出满足第一个条件后半部分与第二个条件的最大的 $x$，二者的 $\max$ 就是该询问的答案。

显然拆出来的两部分对称，这里以满足第一个条件前半部分为例讲解。

不妨将上述条件转化为 $O(nd)$ 个三元组 $(x,y,z)$，其含义为：所有满足 $l < x,l \leq y \leq r$ 的询问的答案与 $z$ 取 $\max$。将询问按 $l$ 排序，三元组插入到 $x+1$ 的位置，双指针枚举询问与三元组，不难发现需要实现的是单点修改与区间 $\max$ 操作，用线段树可以实现。

于是问题得到解决，时间复杂度为 $O(nd \log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mp make_pair
#define mid ((tr[p].l+tr[p].r)>>1)
const int N=1e5+10;
int n,m,c,v[N],ans[N];
vector<int> d[N],pos[N];
vector<pair<int,int>> add[N];
struct Query
{
	int l,r,id;
}q[N];
struct node
{
	int l,r,mx;
}tr[N<<2];
inline void build(int p,int l,int r)
{
	tr[p].l=l;tr[p].r=r;tr[p].mx=0;
	if(l==r) return void();
	build(p<<1,l,mid);build(p<<1|1,mid+1,r);
}
inline void change(int p,int x,int w)
{
	if(tr[p].l==tr[p].r) return tr[p].mx=max(tr[p].mx,w),void();
	if(x<=mid) change(p<<1,x,w);else change(p<<1|1,x,w);
	tr[p].mx=max(tr[p<<1].mx,tr[p<<1|1].mx);
}
inline int query(int p,int l,int r)
{
	if(tr[p].l>=l&&tr[p].r<=r) return tr[p].mx;
	int res=0;
	if(l<=mid) res=max(res,query(p<<1,l,r));
	if(r>mid) res=max(res,query(p<<1|1,l,r));
	return res;
}
inline void solveL()
{
	for(int i=1;i<=n;i++) add[i].clear();
	for(int i=1;i<=m;i++) 
	{
		if(d[i].size()<2) continue;
		for(int j=1;j<(int)d[i].size();j++) add[d[i][0]+1].push_back(mp(d[i][j],i));
	}
	sort(q+1,q+c+1,[](Query A,Query B){return A.l<B.l;});
	build(1,1,n);
	for(int i=1,j=0;i<=c;i++)
	{
		while(j+1<=q[i].l)
		{
			++j;
			for(auto x:add[j]) change(1,x.first,x.second);
		}
		ans[q[i].id]=max(ans[q[i].id],query(1,q[i].l,q[i].r));
	}
}
inline void solveR()
{
	for(int i=1;i<=n;i++) add[i].clear();
	for(int i=1;i<=m;i++) 
	{
		if(d[i].size()<2) continue;
		reverse(d[i].begin(),d[i].end());
		for(int j=1;j<(int)d[i].size();j++) add[d[i][0]-1].push_back(mp(d[i][j],i));
	}
	sort(q+1,q+c+1,[](Query A,Query B){return A.r>B.r;});
	build(1,1,n);
	for(int i=1,j=n+1;i<=c;i++)
	{
		while(j-1>=q[i].r)
		{
			--j;
			for(auto x:add[j]) change(1,x.first,x.second);
		}
		ans[q[i].id]=max(ans[q[i].id],query(1,q[i].l,q[i].r));
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) 
	{
		scanf("%d",&v[i]);
		m=max(m,v[i]);pos[v[i]].push_back(i);
	}
	for(int i=1;i<=m;i++)
		for(int j=i;j<=m;j+=i)
			for(auto x:pos[j]) d[i].push_back(x);
	for(int i=1;i<=m;i++)
	{
		sort(d[i].begin(),d[i].end());
		d[i].erase(unique(d[i].begin(),d[i].end()),d[i].end());
	}
	scanf("%d",&c);
	for(int i=1;i<=c;i++) scanf("%d%d",&q[i].l,&q[i].r),q[i].id=i; 
	solveL();solveR();
	for(int i=1;i<=c;i++) printf("%d\n",ans[i]);
	return 0;
}
```




---

## 作者：Gmt丶FFF (赞：1)

神奇的题目。

可以用 oier 的直觉感受到这题需要用数据结构，那先想想乱搞的分块吧。

设 $K$ 为块长。

对于询问 $\left[l,r\right]$，我们将询问拆成两种，散块对区间外的贡献与整块对区间外的贡献。

对于散块，我们先将询问离线下来，然后从左往右扫描，对于一个数 $a_i$，枚举其所有因子，然后再枚举所有因子的倍数来更新答案，那么我们就可以 $O(1)$ 查询一个数对一个区间的贡献了，可以知道，一个数只用一次枚举倍数，所以总时间复杂度为调和级数，所以时间复杂度为 $O(nK+\frac{n^2}{K})$。注意还要从右到左扫描一次。

而对于整块，我们也将询问离线下来，先预处理出每一个块的因数，对于一个数 $a_i$，枚举其所有因数，然后枚举所有块，看这个块有没有这个因数，如果有，那就更新答案，因为每个因数更新了一次后就不用更新了，数字数量共有 $n$ 种，时间复杂度仍然为 $O(nK+\frac{n^2}{K})$。注意还要从右到左扫描一次。

总时间复杂度即为 $O(nK+\frac{n^2}{K})$，

~~前端时间做了很多 lxl 的分块题，这题不卡常都不习惯了。~~

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
int cnwr,wr[40];
inline int read()
{
	char ch=getchar();
	int sum=0;
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')sum=(sum<<1)+(sum<<3)+(ch^48),ch=getchar();
	return sum;
}
inline void write(int x)
{
	if(x==0)putchar('0');
	while(x)wr[++cnwr]=x%10,x/=10;
	while(cnwr)putchar(wr[cnwr--]^48);
}
const int N=1e5+5;
const int K=316;
const int M=K+5;
const int T=N/K+5;
int n,m,a[N],B[N],L[T],R[T],res[N];
vector<int>p1[N],p2[N],p3[N],p4[N];
struct node
{
	int l,r;
}q[N];
void init()
{
	n=read();
	for(int i=1;i<=n;i++)a[i]=read(),B[i]=i/K+1;
	for(int i=1;i<=B[n];i++)L[i]=max(1,(i-1)*K),R[i]=min(n,i*K-1);
	m=read();
}
namespace solve1
{
	int t[N],ans[N];
	bool vis[N];
	void update(int x)
	{
		if(vis[x])return;
		vis[x]=1;
		for(int i=x;i<=N-5;i+=x)ans[i]=max(ans[i],x);
	}
	void solve()
	{
		for(int i=1;i<=n;i++)
		{
			if(!vis[a[i]])
			{
				for(int j=1;j*j<=a[i];j++)
				{
					if(a[i]%j==0)
					{
						if(j*j!=a[i])update(a[i]/j);
						update(j);
					}
				}
			}
			int len=p1[i].size();
			for(int j=0;j<len;j++)
			{
				int x=p1[i][j];
				int l=q[x].l,r=min(q[x].r,R[B[l]]);
				for(int k=l;k<=r;k++)res[x]=max(res[x],ans[a[k]]);
				r=q[x].r,l=max(q[x].l,L[B[r]]);
				for(int k=l;k<=r;k++)res[x]=max(res[x],ans[a[k]]);
			}
		}
		for(int i=1;i<=N-5;i++)ans[i]=t[i]=vis[i]=0;
		for(int i=n;i>=1;i--)
		{
			if(!vis[a[i]])
			{
				for(int j=1;j*j<=a[i];j++)
				{
					if(a[i]%j==0)
					{
						if(j*j!=a[i])update(a[i]/j);
						update(j);
					}
				}
			}
			int len=p2[i].size();
			for(int j=0;j<len;j++)
			{
				int x=p2[i][j];
				int r=q[x].r,l=max(q[x].l,L[B[r]]);
//				cout<<x<<" "<<l<<" "<<r<<" "<<ans[7]<<endl;
				for(int k=l;k<=r;k++)res[x]=max(res[x],ans[a[k]]);
				l=q[x].l,r=min(q[x].r,R[B[l]]);
				for(int k=l;k<=r;k++)res[x]=max(res[x],ans[a[k]]);
			}
		}
	}
}
namespace solve2
{
	int ans[T];
	bool vis[N],pri[T][N];
	void update(int x,int y,bool flag)
	{
		if(vis[y])return;
		vis[y]=1; 
		if(!flag)for(int i=B[x]+1;i<=B[n];i++){if(pri[i][y]){ans[i]=max(ans[i],y);}}
		else for(int i=1;i<B[x];i++)if(pri[i][y])ans[i]=max(ans[i],y);
	}
	void solve()
	{
		for(int i=1;i<=B[n];i++)
		{
			for(int j=L[i];j<=R[i];j++)
			{
				for(int k=1;k*k<=a[j];k++)
				{
					if(a[j]%k==0)
					{
						pri[i][a[j]/k]=1;
						pri[i][k]=1;
					}
				}
			}
		}
		for(int i=1;i<=n;i++)
		{
			if(!vis[a[i]])
			{
				for(int j=1;j*j<=a[i];j++)
				{
					if(a[i]%j==0)
					{
						if(j*j!=a[i])update(i,a[i]/j,0);
						update(i,j,0);
					}
				}
			}
			int len=p1[i].size();
			for(int j=0;j<len;j++)
			{
				int x=p1[i][j];
				int l=B[q[x].l]+1,r=B[q[x].r]-1;
				for(int k=l;k<=r;k++)res[x]=max(res[x],ans[k]);
			}
		}
		for(int i=1;i<=N-5;i++)vis[i]=0;
		for(int i=1;i<=B[n];i++)ans[i]=0;
		for(int i=n;i>=1;i--)
		{
			if(!vis[a[i]])
			{
				for(int j=1;j*j<=a[i];j++)
				{
					if(a[i]%j==0)
					{
						if(j*j!=a[i])update(i,a[i]/j,1);
						update(i,j,1);
					}
				}
			}
			int len=p2[i].size();
			for(int j=0;j<len;j++)
			{
				int x=p2[i][j];
				int l=B[q[x].l]+1,r=B[q[x].r]-1;
				for(int k=l;k<=r;k++)res[x]=max(res[x],ans[k]);
			}
		}
	}
}
int main()
{
//	freopen("data.in","r",stdin);
//	freopen("data.out","w",stdout);
	init();
	for(int i=1;i<=m;i++)
	{
		res[i]=1;
		q[i].l=read(),q[i].r=read();
		p1[q[i].l-1].push_back(i);
		p2[q[i].r+1].push_back(i);
	}
	solve1::solve();
	solve2::solve();
	for(int i=1;i<=m;i++)write(res[i]),putchar('\n');
	return 0;
}
```


---

## 作者：Mobius127 (赞：1)

### upd: 代码中注释掉的是暴力分解的代码和计算 $d(n)$ 的部分。

[题传](https://www.luogu.com.cn/problem/P3889)

没有修改，果断离线。

每个询问珂以拆成两个部分，都相当于从边界开始拉出一段，随后以一个点为分界线，求两边选出的最大 $\gcd$。

考虑枚举这个 $\gcd$，设数列中含有这个数的集合为 $C_{\gcd}$，我们只需要考虑 $C_{\gcd}$ 中编号相邻的两个节点连成的区间是否与当前询问区间是否相交即可（虽然珂以有更长的区间，但是肯定能找到更短的区间去代替它，这是没有影响的）。

那么思路就出来了：排序使得右端点递增，当一个新的右端点加入时，我们枚举它的每一个质因子 $d$，同时维护数组 $pre_d$ 表示上一个含有因子 $d$ 的数在哪，那么现在就得到了一个价值为 $d$ 的区间 $[pre_d, r]$。我们要找的就是一个与 $[l, r]$ 相交且价值最大的区间。（另一部分同理）

显然要找的区间必然包含 $l$，对于每个新区间，直接在线段树上打个价值为 $d$ 的 tag 即可，注意边界问题，右端点应该 -1。

复杂度 $O(n \ln n+n d(n)\log n$（预处理） 或 $O(n \sqrt{n} \log n)$ （暴力分解），都需要 O2 才能卡过去。

### Code：

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <cmath>
#include <vector>
#include <cctype>
using namespace std;
typedef long long ll;
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
inline void write(int x){
    if(x<0) putchar('-'), x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int N=1e5+5;
const int INF=1e5;
int n, m, a[N], Mx[N*4], tag[N*4];
#define ls k<<1
#define rs k<<1|1
#define mid (l+r>>1)
void upd(int k, int v){
	Mx[k]=max(Mx[k], v);
	tag[k]=max(tag[k], v);
}
void pushdown(int k){
	if(!tag[k]) return ;
	upd(ls, tag[k]), upd(rs, tag[k]);
	tag[k]=0;
}
void change(int k, int l, int r, int x, int y, int val){
	if(x<=l&&r<=y) return upd(k, val);pushdown(k);
	if(x<=mid) change(ls, l, mid, x, y, val);
	if(mid<y) change(rs, mid+1, r, x, y, val);
	Mx[k]=max(Mx[ls], Mx[rs]);
}
int query(int k, int l, int r, int x){
	if(l==r) return Mx[k];pushdown(k);
	if(x<=mid) return query(ls, l, mid, x);
	else return query(rs, mid+1, r, x);
}
#undef ls
#undef rs
#undef mid
int ans[N], pre[N];
struct Box{int l, r, id;}Q[N];
bool crx(Box x, Box y){return x.r<y.r;}
bool cmb(Box x, Box y){return x.l>y.l;}
vector <int> G[N];
signed main(){
	for(int i=1; i<=INF; i++)
		for(int j=i; j<=INF; j+=i)
			G[j].push_back(i);
			
//	for(int i=1; i<=INF; i++)
//		ans[0]=max(ans[0], (int)(G[i].size()));
//	printf("--%d\n", ans[0]);
	n=read();
	for(int i=1; i<=n; i++)
		a[i]=read();
	m=read();
	for(int i=1; i<=m; i++)
		Q[i].l=read(), Q[i].r=read(), Q[i].id=i;
	sort(Q+1, Q+m+1, crx);
	for(int i=1, j=1; i<=n; i++){
//		for(int x=1; x*x<=a[i]; x++)
//			if(a[i]%x==0){
//				if(pre[x]) change(1, 1, INF, pre[x]+1, i, x);
//				pre[x]=i;
//				if(a[i]/x==x) continue;
//				if(pre[a[i]/x]) change(1, 1, INF, pre[a[i]/x]+1, i, a[i]/x);
//				pre[a[i]/x]=i;
//			}
		for(int x=0; x<G[a[i]].size(); x++){
			int v=G[a[i]][x];
			if(pre[v]) change(1, 1, INF, pre[v]+1, i, v);
			pre[v]=i;
		}
		while(j<=m&&Q[j].r==i){
			ans[Q[j].id]=max(ans[Q[j].id], query(1, 1, INF, Q[j].l));
			j++;
		}
	}
	memset(Mx, 0, sizeof(Mx));
	memset(pre, 0, sizeof(pre));
	memset(tag, 0, sizeof(tag));
	sort(Q+1, Q+m+1, cmb);
	for(int i=n, j=1; i>=1; i--){
//		for(int x=1; x*x<=a[i]; x++)
//			if(a[i]%x==0){
//				if(pre[x]) change(1, 1, INF, i, pre[x]-1, x);
//				pre[x]=i;
//				if(a[i]/x==x) continue;
//				if(pre[a[i]/x]) change(1, 1, INF, i, pre[a[i]/x]-1, a[i]/x);
//				pre[a[i]/x]=i;
//			}
		for(int x=0; x<G[a[i]].size(); x++){
			int v=G[a[i]][x];
			if(pre[v]) change(1, 1, INF, i, pre[v]-1, v);
			pre[v]=i;
		}
		while(j<=m&&Q[j].l==i){
			ans[Q[j].id]=max(ans[Q[j].id], query(1, 1, INF, Q[j].r));
			j++;
		}
	}
	for(int i=1; i<=m; i++)
		printf("%d\n", ans[i]);
	return 0;
}
```


---

## 作者：james1BadCreeper (赞：1)

可以将 $[1,l)\cup (r,n]$ 拆开，因此一次询问就变成了在 $[1,l),[l,r]$ 中各选一个数。

高效维护这个问题十分困难，发现值域很小，直接处理出所有数的因数再做考虑。离线，按照右端点升序排序。如果 $pre_{a_i}$ 存在，那么询问的 $l$ 在 $(pre_{a_i},i]$ 的范围内出现时是可以更新到 $a_i$ 的，一个区间修改单点查询的线段树就可以完成。时间复杂度为 $O(n\sqrt{n}\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5; 

int n, m; 
int a[100005], pre[100005], nxt[100005]; 
vector<int> b[100005]; 
struct Query {
    int l, r, id; 
} Q[100005]; 
int ans[100005]; 
int T[400005], tag[400005]; 
inline void maketag(int o, int k) { 
    T[o] = max(T[o], k); tag[o] = max(tag[o], k); 
}
inline void pushdown(int o) {
    if (!tag[o]) return; 
    maketag(o << 1, tag[o]); maketag(o << 1 | 1, tag[o]); 
    tag[o] = 0; 
}
void update(int o, int l, int r, int x, int y, int k) {
    if (x <= l && r <= y) return maketag(o, k); 
    pushdown(o); int mid = l + r >> 1; 
    if (x <= mid) update(o << 1, l, mid, x, y, k); 
    if (mid < y) update(o << 1 | 1, mid + 1, r, x, y, k); 
    T[o] = max(T[o << 1], T[o << 1 | 1]); 
}
int query(int o, int l, int r, int x) {
    if (l == r) return T[o]; 
    pushdown(o); int mid = l + r >> 1; 
    if (x <= mid) return query(o << 1, l, mid, x); 
    return query(o << 1 | 1, mid + 1, r, x); 
}

int main(void) {
    for (int i = 1; i <= N; ++i) for (int j = i; j <= N; j += i) b[j].emplace_back(i); 
    scanf("%d", &n); 
    for (int i = 1; i <= n; ++i) scanf("%d", a + i); 
    scanf("%d", &m); 
    for (int i = 1; i <= m; ++i) scanf("%d%d", &Q[i].l, &Q[i].r), Q[i].id = i; 

    sort(Q + 1, Q + m + 1, [&](auto a, auto b) { return a.r < b.r; }); 
    for (int i = 1, j = 1; i <= n; ++i) {
        for (int x : b[a[i]]) {
            if (pre[x]) update(1, 1, N, pre[x] + 1, i, x); // l 在这部分时可以有答案
            pre[x] = i; 
        }
        while (j <= m && Q[j].r == i) {
            ans[Q[j].id] = max(ans[Q[j].id], query(1, 1, N, Q[j].l)); 
            ++j; 
        }
    }

    memset(T, 0, sizeof T); memset(tag, 0, sizeof tag); 
    sort(Q + 1, Q + m + 1, [&](auto a, auto b) { return a.l > b.l; }); 
    for (int i = n, j = 1; i >= 1; --i) {
        for (int x : b[a[i]]) {
            if (nxt[x]) update(1, 1, N, i, nxt[x] - 1, x); 
            nxt[x] = i; 
        }
        while (j <= m && Q[j].l == i) {
            ans[Q[j].id] = max(ans[Q[j].id], query(1, 1, N, Q[j].r)); 
            ++j; 
        }
    }

    for (int i = 1; i <= m; ++i) printf("%d\n", ans[i]); 
    return 0;
}
```

---

## 作者：时律 (赞：1)

来写一下这道题的 $O(n\sqrt{n})$ 分块做法，感谢 @[chaotic](https://www.luogu.com.cn/user/218250) 的想法。由于 $n,m,a_i$ 同阶下面复杂度分析统称 $n$。

首先一次询问 $[l,r]$ 会把序列划分为三段： $[1,l-1],[l,r],[r+1,n]$。其中 $[r+1,n]$ 的做法与 $[1,l-1]$ 类似，重点关注 $[1,l-1]$。

![](https://z4请更换图床a.net/images/2023/03/09/9788cb34be721b2d783c9e3dcf39c2b1.png)

首先明确一次询问可以将序列划分为这种形状（某些部分可能不存在）。

由于是计算 $\gcd$ 最大值，考虑对各部分之间的贡献取 $\max$ 得到答案。

不过在此之前，还需要做一些准备工作，比如求出每个数的因数，这是 $O(n\sqrt{n})$ 的。

## 中散对左块

注意到散块的大小是 $O(\sqrt{n})$ 的，我们可以将这个拆成 $O(\sqrt{n})$ 个单点询问：对于一个前缀 $[1,x]$，有一个数 $y$ 与其取 $\gcd$ 得到的最大值。

我们把这个询问存在 $x$ 处，离线下来做，这样一共会产生 $O(n\sqrt{n})$ 个询问。

最后我们从小到大枚举 $x$，并且枚举 $a_x$ 的因数 $d$，这个枚举的总复杂度是 $O(n\sqrt{n})$ 的。在枚举 $d$ 后，我们就把 $d$ 的所有倍数存着的 $ans$ 与 $d$ 取 $\max$，表示这些倍数能有它这个 $\gcd$。不难发现我们只需要在每种 $d$ 第一次出现的时候干这回事，均摊下来是 $O(n\lg n)$ 的。

在枚举完 $d$ 后，对于在 $x$ 存着的询问直接查询即可。

## 中整对左块

首先预处理出每个块包含了哪些因数。这是 $O(n\sqrt{n})$ 的。并且，我们也把这个询问离线下来。

类似于上一个从小到大枚举 $x$，再枚举 $a_x$ 的因数 $d$。接着再枚举 $x$ 后面的所有块，如果这个块里有着这个因数 $d$ 就将这个块的 $ans$ 与 $d$ 取 $\max$，不难发现每个 $d$ 也是只有第一次做有用，所以一共做 $O(n)$ 次，总共是 $O(n\sqrt{n})$ 的。查询的时候就把它询问的整块的 $ans$ 的 $\max$ 当答案就行了。

## 实现细节

注意到离线存询问总是存一段连续的区间，所以实际上并没有单点拆开的必要。

预处理每个块包含的因数可以用 bitset 而不是用 bool 数组存，这样会快一点。但是这道题本来也不卡常。

```cpp
//Private Eye,dancing with the wind.
#include<bits/stdc++.h>
using namespace std;

#define MAXN 100005
const int block=317,maxn=100000;
int n,m,a[MAXN],b[MAXN],L[MAXN],R[MAXN];
vector<int> st[MAXN];
bitset<MAXN> ts[block+5];
inline void init()
{
	for(int i=1;i<=maxn;i++)
		for(int j=i;j<=maxn;j+=i)
			st[j].emplace_back(i);
	for(int i=1;i<=n;i++)
		for(int x:st[a[i]])
			ts[b[i]][x]=1;
}

struct query{
	int l,r,id;
	query(int l_,int r_,int id_):
		l(l_),r(r_),id(id_){}
};
vector<query> ql[MAXN],qL[MAXN],qr[MAXN],qR[MAXN];
int ans[MAXN],ans1[MAXN],ans2[MAXN];
bitset<MAXN> vis;
inline void solve()
{
	for(int i=1;i<=n;i++)
	{
		if(!vis[a[i]])
		{
			for(int x:st[a[i]])
				if(!vis[x])
				{
					vis[x]=1;
					for(int y=x;y<=maxn;y+=x)
						ans1[y]=max(ans1[y],x);
					for(int j=b[i]+1;j<=b[n];j++)
						if(ts[j][x]) ans2[j]=max(ans2[j],x);
				}
		}
		for(query x:ql[i])
			for(int j=x.l;j<=x.r;j++)
				ans[x.id]=max(ans[x.id],ans1[a[j]]);
		for(query x:qL[i])
			for(int j=x.l;j<=x.r;j++)
				ans[x.id]=max(ans[x.id],ans2[j]);
	}
	vis.reset();
	memset(ans1,0,sizeof(ans1));
	memset(ans2,0,sizeof(ans2));
	for(int i=n;i>=1;i--)
	{
		if(!vis[a[i]])
		{
			for(int x:st[a[i]])
				if(!vis[x])
				{
					vis[x]=1;
					for(int y=x;y<=maxn;y+=x)
						ans1[y]=max(ans1[y],x);
					for(int j=b[i]-1;j>=1;j--)
						if(ts[j][x]) ans2[j]=max(ans2[j],x);
				}
		}
		for(query x:qr[i])
			for(int j=x.l;j<=x.r;j++)
				ans[x.id]=max(ans[x.id],ans1[a[j]]);
		for(query x:qR[i])
			for(int j=x.l;j<=x.r;j++)
				ans[x.id]=max(ans[x.id],ans2[j]);
	}
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),b[i]=(i-1)/block+1;
	for(int i=1;i<=b[n];i++) L[i]=R[i-1]+1,R[i]=min(L[i]+block-1,n);
	init(),scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		int l,r;
		scanf("%d%d",&l,&r);
		if(b[l]==b[r])
		{
			ql[l-1].emplace_back(query(l,r,i));
			qr[r+1].emplace_back(query(l,r,i));	
		}
		else
		{
			ql[l-1].emplace_back(query(l,R[b[l]],i));
			ql[l-1].emplace_back(query(L[b[r]],r,i));
			if(b[l]+1!=b[r]) qL[l-1].emplace_back(query(b[l]+1,b[r]-1,i));
			qr[r+1].emplace_back(query(l,R[b[l]],i));
			qr[r+1].emplace_back(query(L[b[r]],r,i));
			if(b[l]+1!=b[r]) qR[r+1].emplace_back(query(b[l]+1,b[r]-1,i));
		}
	}
	solve();
	for(int i=1;i<=m;i++)
		printf("%d\n",ans[i]);
}
```

---

## 作者：stoorz (赞：1)

题目大意：给出一个长度为 $n$ 的序列 $a$，$m$ 个询问，每个询问给出 $l,r$，在 $[l,r]$ 与 $[1,l)∪(r,n]$ 中各选择一个数字，使得这两个数字的 $\gcd$ 最大。

重点讨论如何在 $[1,l)$ 与 $[l,r]$ 中选择两个数使得它们的 $\gcd$ 最大。因为 $[l,r]$ 与 $(r,n]$ 的 $\operatorname{maxgcd}$ 与之求法是一样的。

我们考虑枚举 $[1,l)$ 中每一个数的所有因子 $d$。然后找到 $[l,n]$ 中下一个拥有因子 $d$ 的位置 $p$。那么我们就用 $d$ 来更新 $p$ 与 $[1,l)$ 的 $\operatorname{maxgcd}$。将 $[1,l)$ 中每一个数的每一个因子全部找到对应的 $p$ 并且更新后，取 $[l,r]$ 的最大值即可。

那么就将每一个询问按 $l$ 升序排序，先预处理出每一个数的因子，以及下一个同样包含这个因子的数字的位置。那么对于连续的两组询问 $[l_i,r_i],[l_{i+1},r_{i+1}]$，我们将 $[l_i,l_{i+1})$ 中所有数每一个因子的贡献存到一棵线段树中。例如在这个区间内一个数有一个因子 $d$，然后通过预处理得到下一个包含因子 $d$ 的数字在位置 $pos$，那么就在线段树中将 $pos$ 的 $\operatorname{maxgcd}$ 与 $d$ 取最大值，然后维护即可。

为什么这样一定是正确的呢？因为我们对于每一个数的每一个因子维护的是距离它最近的下一个含有同样因子的数字 $p$，如果 $p\in [l_i,l_{i+1})$，那么当我们枚举到 $p$ 的时候又会往下一个含有该因子的位置更新；如果 $p\in(r_{i+1},n]$，那么现在 $[l_{i+1},r_{i+1}]$ 中不含有因子 $d$，所以不进行更新。

由于 $a[i]\leq 100000$，可以大力跑出每一个数的因子个数不超过 $d=128$。所以时间复杂度为 $O(n\sqrt{n}+md\log n)$。算是勉强能卡在线内。

---

## 作者：Noah2022 (赞：0)

### 方法1
* 对于每次询问暴力枚举所有可能性。
* 时间复杂度 $ O(M \times N \times N) $ ，期望得分 $ 20 $ 分。
### 方法2
* $ D=\operatorname{gcd}(X,Y) $ 最大，$ D $ 同时表示 $ X $ 和 $ Y $ 的最大的公因数。
* 于是对于每次询问，先枚举区间内的数，给其所有因数打上标记 $ 1 $，再枚举区间外的数，给其所有因数打上标记 $ 2 $。
* 此时同时具有标记 $ 1 $ 和标记 $ 2 $ 的最大数即为答案。
* 时间复杂度 $ O( M \times N \times \sqrt{D}) $。
* 期望得分 $ 20 \sim 30 $。
### 方法3
* 方法二的缺陷在于每次询问都会重新计算所有因数，显然可以通过尽量重用已经计算出来的结果来进行优化。
* 于是我们可以离线处理询问，将询问区间用分块思想排序，每次转移可以通过枚举因子和用堆维护来完成。
* 时间复杂度 $ O(N \times\sqrt{N} \times \sqrt{D} \times \operatorname{log}N) $。
* 期望得分：$ 50 \sim 80 $。
### 方法4
* 同样在方法二的基础上，可以通过重用已经枚举出来的因数来进行优化。
* 通过建立函数式值域线段树进行优化，结点每次询问区间 $ [  l , r ] $ 可以通过函数式线段树用类似搜索剪枝的方法得到。
* 在随机数据下该算法表现良好。
* 时间复杂度不好估计。
* 期望得分：$ 80 \sim 100 $。
### 方法5
* $ D=\operatorname{gcd}(X,Y) $ 最大，可以理解为区间内存在数 $ X $ 与区间外存在数 $ Y $，使得 $ D \mid X $ 且 $ D \mid Y $。
* 假定整数 $ X $，$ Y $ 所在下标为 $ px $，$ py $，则可以建立权值为 $ D $ 的线段 $ [px,py] $，此时若询问区间 $[l,r]$ 与 $ [px,py] $ 为相交关系（不包括包含），则询问 $ [l,r] $ 的答案至少为 $D$。
* 定义函数 $ V_{l,r}=\operatorname{gcd}(al, ar) $，则询问 $ Q_{l,r} $ 的答案为 $ \operatorname{max} $ $ (V_{l1,r1} (l1 < l \wedge r1 \ge l \wedge r1 \le r),V_{l2,r2}(l2 \ge l \wedge l2 \le r \wedge r2 > r)) $。
* 显然 $ V_{l,r} $ 的数量为 $ O(N^2) $，不可以先预处理，但是我们关心的是 $ V $ 的值，而对于给定的数 $ X $（下标为 $ pos $），$ V_{i,pos} $ 的所有不同取值个数为 $ X $ 的因数个数。
* 故我们可以通过读入所有询问，离线处理（左右分别循环一次），下面只讨论一个方向，另一个方向类似。
* $ pre_x $ 表示处理到当前位置 $ pos $ 的数 $ Y $ 时，上一个包含有因数 $ x $ 的数的位置。
* 此时枚举 $ Y $ 的因数 $ d $，则 $ V_{pre_d,pos}=d $。
* 可以通过线段树来快速进行插入和查询。
* 时间复杂度 $ O( N \times \sqrt{D} \times \operatorname{log}N) $。
* 期望得分：$ 100 $ 。

---


# [TJOI2015] 线性代数

## 题目描述

为了提高智商，ZJY 开始学习线性代数。

她的小伙伴菠萝给她出了这样一个问题：给定一个 $n \times n$ 的矩阵 $B$ 和一个 $1 \times n$ 的矩阵 $C$。求出一个 $1×n$ 的 01 矩阵 $A$，使得 $D=(A×B-C)×A^{\sf T}$ 最大，其中$A^{\sf T}$为$A$的转置，输出$D$。

## 说明/提示

- 对于 $30\%$ 的数据，$n \leq 15$；
- 对于 $100\%$ 的数据，$1 \leq n \leq 500$；
- 另外还有两组不计分的 hack 数据，放在 subtask 2 中，数据范围与上面一致。


## 样例 #1

### 输入

```
3
1 2 1
3 1 0
1 2 3
2 3 7```

### 输出

```
2```

# 题解

## 作者：revenger (赞：34)

看到这道题，我们先来画一下柿子。

$D=(A*B-C)*A^T$

$D=\sum_{i=1}^n(\sum_{j=1}^na_j*b_{j,i}-c_i)*a_i$ 

$D=\sum_{i=1}^n\sum_{j=1}^na_i*a_j*b_{i,j}-\sum_{i=1}^na_i*c_i$

柿子画到这里，我们可以看出，对于每个$a_i$，选0的时候没有贡献，选1的时候会带来$c_i$的损失，但是对于每一个同样选1的$a_j$,会带来$b_{j,i}+b_{i,j}$的贡献。

结合数据范围$n\leq500$,可以联想到最小割。

![](https://cdn.luogu.com.cn/upload/pic/18121.png)

这里我们假设S集是$a_i$选0，T集是$a_i$选1。一开始我们获得了所有$b$的收益，我们要让损失最小化。

列式子 

$(1)bx+by=c_x+c_y$ (都选1的时候只有$c$的损失)

$(2)ax+ay=b_{x,x}+b_{x,y}+b_{y,x}+b_{y,y}$ (都选0的时候损失为$b$数组)

$(3)ax+by+v=b_{x,x}+b_{x,y}+b_{y,x}+c_y$

$(4)ay+bx+v=b_{y,y}+b_{x,y}+b_{y,x}+c_x$ (一个选1一个选0时损失为$b$数组两数之间的收益和对应$c$数组收益)

可以解出对于每一组$(x,y)$

$ax=b_{x,x}+\frac{b_{x,y}+b_{y,x}}{2}$

$ay=b_{y,y}+\frac{b_{x,y}+b_{y,x}}{2}$

$bx=c_x$

$by=c_y$

$v=\frac{b_{x,y}+b_{y,x}}{2}$

对于每一组$(x,y)$,我们需要把割$ax$和$ay$的损失累加起来。

$ax=b_{x,x}+\frac{\sum_{i=1}^n(i!=x)b_{x,i}+b_{i,x}}{2}=\frac{\sum_{i=1}^nb_{x,i}+b_{i,x}}{2}$

这样建图就非常明显了，为了避免有小数的出现，我们将流量翻倍。

从源点$S$往每个点$i$连接流量为$b$数组第$i$行和第$i$列的权值总和的边。

每个点$i$往汇点$T$连接流量为$c_i*2$的边。

每一对点$(i,j)$之间连流量为$b_{i,j}+b_{j,i}$的双向边。

最后答案为$\sum_{i=1}^n\sum_{j=1}^nb_{i,j}-\frac{Maxflow(S,T)}{2}$

时间复杂度O($Maxflow(n,n^2)$)


---

## 作者：Soulist (赞：14)

做法$1:$先把$A$矩阵置为$1,$ 然后随机一个位置，把其取反，重复$1500$次，选一个好的种子，就能过了。代码如下：

```
#include<bits/stdc++.h>
using namespace std;
int read(){
    char cc = getchar(); int cn = 0, flus = 1;
    while(cc > '9' || cc < '0'){
        if(cc == '-') flus = -flus;
        cc = getchar();
    }
    while(cc >= '0' && cc <= '9') cn = cn * 10 + cc - '0', cc = getchar();
    return cn * flus;
}
const int N = 500 + 5;
const int M = 1e5 + 5;
const int inf = 99999999;
int n;
int a[N], b[N], c[N][N], d[N];
int p[N], q[N];
void input(){
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            c[i][j] = read();
        }
    }
    for(int i = 1; i <= n; i++) b[i] = read();
}
namespace Work3{
    int maxans = 0;
    int ans = 0;
    int check(){
        memset(d, 0, sizeof(d));
        int nowans = 0;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= n; j++){
                d[i] += a[j] * c[i][j];
            }
        }
        for(int i = 1; i <= n; i++){
            nowans += (d[i] - b[i]) * a[i];
        }
        maxans = max(maxans, nowans);
        return maxans;
    }
    void output3(){
        for(int i = 1; i <= n; i++)  a[i] = 1;
        check();
        int time = 1500;
        ans = maxans;
        int lastwh = 0;
        while(time){
            int wh = rand() % n + 1;
            a[wh] = a[wh] ^ 1;
            check();
            time--;
        }
        printf("%d\n", maxans);
        return ;
    }
}
int main(){
    srand(10007);
    n = read();
    input();
    Work3::output3();
    return 0;
}
```

当然，正确的写法还是写最小割建图......

可以发现，如果选了一个点为$1$，要花费$C_i$的代价。如果$i,j$两点同时选，会产生$B_{i,j}$的贡献。所以可以建立一个额外的点$(i,j)$表示这个贡献，然后分别向$i,j$连一条无穷大的边。。。然后跑最小割即可

代码如下：


```
#include<bits/stdc++.h>
using namespace std;
int read(){
    char cc = getchar(); int cn = 0, flus = 1;
    while(cc > '9' || cc < '0') {
        if(cc == '-') flus = -flus;
        cc = getchar();
    }
    while(cc >= '0' && cc <= '9') cn = cn * 10 + cc - '0', cc = getchar();
    return cn * flus;
}
const int M = 1e6 + 5;
const int N = 500 + 5;
const int inf = 99999999;
int n, m, s, t, head[M], cur[M];
int dep[M], cnt;
int c[N][N], b[N], ans;
struct E{
    int to, next, w;
}e[M * 2];
void ins(int x, int y, int z){
	e[++cnt].w = z; e[cnt].to = y;
    e[cnt].next = head[x]; head[x] = cnt;
}
void add(int x, int y, int z){
    ins(x, y, z); ins(y, x, 0);
}
bool bfs(int x){
    memset(dep, 0, sizeof(dep));
    queue<int> q;
    while(!q.empty()) q.pop();
    dep[x] = 1; q.push(x);
    while(!q.empty()){
        int u = q.front();
        q.pop();
        for(int i = head[u]; i; i = e[i].next){
            int v = e[i].to;
            if(e[i].w > 0 && dep[v] == 0){
                dep[v] = dep[u] + 1;
                q.push(v);
            }
        }
    }
    return dep[t] > 0;
}
int dfs(int x, int dist){
    if(x == t) return dist;
    for(int &i = cur[x]; i; i = e[i].next){
        int v = e[i].to;
        if((dep[v] == dep[x] + 1) && (e[i].w > 0)){
            int d = dfs(v, min(dist, e[i].w));
            if(d > 0){
                e[i].w -= d;
                e[i ^ 1].w += d;
                return d;
            }
        }
    }
    return 0;
}
int dinic(){
    int ans = 0;
    while(bfs(s)){
        int di;
        for(int i = s; i <= t; i++)	cur[i] = head[i];
        while(di = dfs(s, inf)){
		    ans += di;
        }
    }
    return ans;
}
void input(){
	n = read();
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            c[i][j] = read();
        }
    }
    for(int i = 1; i <= n; i++) b[i] = read();
}
void build(){
	s = 0, t = n * (n + 1) + 1;
	cnt = 1;
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= n; j++){
			add(s, i * n + j, c[i][j]);
			add(i * n + j, i, inf);
			add(i * n + j, j, inf);
			ans += c[i][j];
		}
	}
	for(int i = 1; i <= n; i++){
		add(i, t, b[i]);
	}
}
int main(){
    input();
    build();
    printf("%d\n", ans - dinic());//最小割
    return 0;
}

```

---

## 作者：YellowBean_Elsa (赞：10)

先根据矩阵乘法法则推一波柿子：

$$D = (A \times B -C)\times A^T $$
$$=\sum_{i=1}^n(\sum_{j=1}^n(a_j \times b_{i,j} - c_i) \times a_i)$$

为了能计算每个 $a$ 的贡献，我们把含 $a$ 的项分离出来

$$=\sum_{i=1}^n(\sum_{j=1}^n(a_i \times a_j \times b_{i,j})-c_i \times a_i)$$

于是我们可以发现

**对于每一个B矩阵中的元素 $b[i][j]$，**

**如果不要他（即 $a_i$ 和 $a_j$ 中有至少一个为0），就损失 $b[i][j]$ ,**

**否则就必须损失 $c[i]$ 和 $c[j]$（因为此时 $a_i$ 和 $a_j$ 皆为1）**

这促使我们想到了**最小割**。

### 建网络

- 每个 $b_{i,j}$ 和每个 $c_{i,j}$ 都对应一个节点

- 源点向每个 B 中节点连流量 $b_{i,j}$ 的边，每个 C 中节点向汇点连流量 $c_i$ 的边

- 每个 $b_{i,j}$ 向 $c_i$ 和 $c_j$ 连流量为inf的边

这时我们发现，对于每个 $b_{i,j}$，如果我们要切断从源点经过它到汇点的路，要么切断从源点到它的 $b_{i,j}$ 的边，要么切断从 $c_i$ 和 $c_j$ 到汇点的两条边，与前面所讲相同。

然后愉快地跑网络流，再用 $\sum b_{i,j}$ 减掉最小割即可切掉此题

```cpp
//coder: Feliks-GM-YB
#include<bits/stdc++.h>
#define ll long long
using namespace std;
//注意连边有约2e6条，小心数组开小见祖宗 
const int N=1e6+100;
const int M=502;
const int inf=(1<<30);
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)&&ch!='-')ch=getchar();
	if(ch=='-')f=-1,ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return x*f;
}int n;
int v[N<<1],nex[N<<1],first[N],w[N<<1],tot=1;
inline void add(int x,int y,int z){
	v[++tot]=y;w[tot]=z;
	nex[tot]=first[x];
	first[x]=tot;
}namespace Dinic{
	int s=0,t=1e6,maxf,flow;
	//s,t分别为源点和汇点
	int d[N];queue<int> q;
	inline bool bfs(){
		while(!q.empty())q.pop();
		memset(d,0,sizeof(d));
		q.push(s);d[s]=1;
		while(!q.empty()){
			int x=q.front();q.pop();
			for(int i=first[x];i;i=nex[i]){
				int y=v[i];
				if(!w[i] || d[y])continue;
				q.push(y);
				d[y]=d[x]+1;
				if(y==t)return 1;
			}
		}return 0;
	}int dinic(int x,int f){
		if(x==t)return f;
		int res=f,k;
		for(int i=first[x];i && res;i=nex[i]){
			int y=v[i];
			if(!w[i] || d[y]!=d[x]+1)continue;
			k=dinic(y,min(res,w[i]));
			if(!k)d[y]=0;
			w[i]-=k;w[i^1]+=k;
			res-=k;
		}return f-res;
	}
}using namespace Dinic;
int b[M][M],c[M],ans;
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			b[i][j]=read();
			ans+=b[i][j];//ans先赋为 B 矩阵元素之和 
			//b[i][j]对应节点 (i - 1) * n + j, 可代入数值理解
			add(s,(i-1)*n+j,b[i][j]);
			add((i-1)*n+j,s,0);
		}
	}for(int i=1;i<=n;i++){
		c[i]=read();
		add(n*n+i,t,c[i]);
		add(t,n*n+i,0);
	}for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			int x=(i-1)*n+j;
			add(x,n*n+i,inf);add(n*n+i,x,0);
			add(x,n*n+j,inf);add(n*n+j,x,0);
		}
	}//跑 Dinic 最大流求最小割 
	while(bfs())
		while(flow=dinic(s,inf))maxf+=flow;
	printf("%d\n",ans-maxf);
	return 0;
}
```






---

## 作者：AubRain (赞：3)

显然，只有 $a_i$ 和 $a_j$ 同时为1的时候，才对答案有 $b_{ij}$  的贡献。使 $a_i$ 为 $1$ 的代价为 $c_i$ 。于是这就是个最小割模型了。

首先左部有 $n^2$ 个点，S向每个点$(i,j)$连流量为 $b_{ij}$ 的边。如果这条边被割掉了，代表 $b_{ij}$对答案**没有贡献**。

右部有 $n$ 个点，每个向T连流量为 $c_i$ 的边，如果这条边被割掉了，代表 $a_i$ 为 $1$，花费了 $c_i$ 的代价。

每个点$(i,j)$向右部的 $i$ 和 $j$ 点连流量$INF$的边，代表只有右边 $i$ 和 $j$全都被割掉，$b_{ij}$ 才能有贡献。

然后答案就是 $\sum b_{ij}-$最小割

```cpp
#include<bits/stdc++.h>
#define N 3000005
#define INF 1<<29
#define num ((i-1)*n+j)
using namespace std;

inline void rd(int &X){
    X=0;int w=0;char ch=0;
    while(!isdigit(ch))w|=ch=='-',ch=getchar();
    while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    X=w?-X:X;
}

int n,s=N-5,t=N-4,ans,f,k;
int head[N],cnt=1,d[N];
struct nd{int nxt,to,v;}e[N<<1];
#define For(x) for(int y,i=head[x];(y=e[i].to);i=e[i].nxt)

void add(int x,int y,int w){
    e[++cnt]=(nd){head[x],y,w};head[x]=cnt;
    e[++cnt]=(nd){head[y],x,0};head[y]=cnt;
}
void build()
{
	rd(n);
	for(int x,i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			rd(x),ans+=x,add(s,num,x),add(num,i+n*n,INF),add(num,j+n*n,INF);
	for(int x,i=1;i<=n;i++)
		rd(x),add(i+n*n,t,x);
}

bool bfs()
{
    queue<int> q; q.push(s);
    memset(d,0,sizeof d); d[s]=1;
    while(!q.empty()){
        int x=q.front();q.pop();
        For(x) if(e[i].v&&!d[y]){
            q.push(y); d[y]=d[x]+1;
            if(y==t) return 1;
        }
    } return 0;
}

int dinic(int x,int flow)
{
    if(x==t) return flow; int re=flow;
    for(int y,i=head[x];(y=e[i].to)&&re;i=e[i].nxt)
        if(e[i].v&&d[y]==d[x]+1)
        {
            k=dinic(y,min(re,e[i].v));
            if(!k) d[y]=0;
            e[i].v-=k;e[i^1].v+=k;re-=k; 
        }
    return flow-re;
}

int main()
{
    build(); 
    while(bfs())
        while(f=dinic(s,INF))
            ans-=f;
    cout<<ans;
}
```

---

## 作者：lyreqwq (赞：2)

为什么没有最大密度子图做法啊 /fn /fn /fn

[更差的阅读体验](https://cx330-oier.top/2023/01/12/TJOI2015-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E9%A2%98%E8%A7%A3/)

> 给出一个 $N \times N$  的矩阵 $\mathbf{B}$ 和一个 $1 \times N$ 的矩阵 $\mathbf{C}$。求出一个 $1 \times N$ 的 $0 / 1$ 矩阵 $\mathbf{A}$，使得 $\mathbf{D} = (\mathbf{A} \times \mathbf{B} - \mathbf{C}) - \mathbf{A}^T$ 最大。其中 $\mathbf{A}^T$ 为 $\mathbf{A}$ 的转置。输出 $\mathbf{D}$。

首先推一波式子，发现题目要求最大化下式：
$$
\sum_{i = 1}^n \sum_{j = 1}^n A_i A_j B_{i, j} - \sum_{i = 1}^n C_i A_i
$$
这里为了方便，$\mathbf{A}, \mathbf{C}$ 我们都记为向量形式。

由于 $\forall i, A_i \in \{0, 1\}$，不难联想到最小割模型；而这个式子第一项存在 $i, j$，第二项只存在 $i$，如果分别当作边权 / 点权就能直接用类似最大密度子图的做法求。
$$
\mathrm{maximize} \sum_{i = 1}^n \sum_{j = 1}^n A_i A_j B_{i, j} - \sum_{i = 1}^n C_i A_i
$$
$$
\iff \mathrm{minimize} \sum_{i = 1}^n C_i A_i - \sum_{i = 1}^n \sum_{j = 1}^n A_i A_j B_{i, j}
$$
将原点集 $V$ 划分为两个集合 $V^{'}, \bar{V^{'}}$，其中 $V^{'} \cap \bar{V^{'}} = \emptyset, V^{'} \cup \bar{V^{'}} = V$；设 $A_i = 1$ 表示 $i \in V^{'}$ ，$A_i = 0$ 表示 $i \in \bar{V^{'}}$ ，有：
$$
\begin{aligned}
  &= \sum_{u \in V^{'}} C_u - \sum_{u \in V^{'}} \sum_{v \in V^{'}} B_{u, v} \\
  &= \sum_{u \in V^{'}} (C_u - B_{u, u}) - \sum_{u \in V^{'}} \sum_{v \in V^{'}} [u \neq v] B_{u, v} \\
  &= \sum_{u \in V^{'}} (C_u - B_{u, u}) - \sum\limits_{u \in V^{'}} \mathrm{Deg}(u) + \sum\limits_{u \in V^{'}} \sum\limits_{v \in \bar{V^{'}}} B_{u, v} \\
\end{aligned}
$$
其中 $\mathrm{Deg}(u) = \sum\limits_{v = 1}^{n} B_{u, v}$。于是这个式子就长成了最大密度子图的样子，不难发现点权 $w_u = C_u - B_{u, u}$，边权 $\mathrm{cost}(u, v) = B_{u, v}$，再次变形有：
$$
\sum_{u \in V^{'}} w_u - \sum\limits_{u \in V^{'}} \mathrm{Deg}(u) + \sum\limits_{u \in V^{'}} \sum\limits_{v \in \bar{V^{'}}} \mathrm{cost}(u, v)
$$
于是套板子，搞一个足够大的数 $U$，$S \to u$ 加边权为 $U$ 的边，$u \to T$ 加边权为 $w_u - \mathrm{Deg}(u) + U$ 的边，$\forall (u, v), u \neq v$ 之间加 $\mathrm{cost}(u, v)$ 的边。一遍 Dinic 即可。

**Code**

```cpp
# include <cstdio>
# include <cstring>
# include <algorithm>

constexpr int n_max(600), inf(0x3f3f3f3f);

int b[n_max][n_max], c[n_max], w[n_max];
int deg[n_max];
int n, base;

template <typename T, int v_max, int e_max>
class flow_network {
  struct edge { T c; int to, nxt; } e[e_max << 1];
  int head[v_max], idx = 1, cur[v_max], dis[v_max];
  inline bool search0() {
    static int q[v_max], *hh, *tt;
    memset(dis, 0x00, sizeof dis);
    hh = tt = q, *tt++ = s, dis[s] = 1, cur[s] = head[s];
    while (hh < tt) {
      const int u(*hh++);
      for (int i(head[u]); i; i = e[i].nxt) {
        const int v(e[i].to);
        if (!dis[v] && e[i].c)
        { dis[v] = dis[u] + 1, cur[v] = head[v], *tt++ = v; }
      }
    }
    return dis[t];
  }
  T search1(const int u, const T cap) {
    if (u == t) return cap;
    T flow(0);
    for (int i(cur[u]); i && flow < cap; i = e[i].nxt) {
      cur[u] = i; const int v(e[i].to);
      if (dis[v] == dis[u] + 1 && e[i].c) {
        T f(search1(v, std::min(cap - flow, e[i].c)));
        if (!f) { dis[v] = 0; }
        else { flow += f, e[i].c -= f, e[i ^ 1].c += f; }
      }
    }
    return flow;
  }
public:
  int s, t;
  inline void add(const int u, const int v, const T c) {
    e[++idx].to = v, e[idx].c = c, e[idx].nxt = head[u], head[u] = idx;
    e[++idx].to = u, e[idx].c = 0, e[idx].nxt = head[v], head[v] = idx;
  }
  inline T dinic() {
    T res(0), flow;
    while (search0()) { while ((flow = search1(s, inf))) { res += flow; } }
    return res;
  }
};
flow_network<int, n_max, n_max * n_max> net;

int main() {
  scanf("%d", &n), net.s = 0, net.t = n + 1;
  for (int i(1); i <= n; ++i) for (int j(1); j <= n; ++j) {
    scanf("%d", &b[i][j]);
    if (i != j) deg[i] += b[i][j];
  }
  for (int i(1); i <= n; ++i) {
    scanf("%d", &c[i]);
    w[i] = c[i] - b[i][i];
    base = std::max(base, deg[i] - w[i]);
  }
  for (int i(1); i <= n; ++i) {
    net.add(net.s, i, base);
    net.add(i, net.t, w[i] - deg[i] + base);
  }
  for (int i(1); i <= n; ++i) for (int j(1); j <= n; ++j)
  { net.add(i, j, b[i][j]); }
  printf("%d\n", n * base - net.dinic());
  return 0;
}
```

---

## 作者：撤云 (赞：2)

### 题目链接
[戳我](https://www.luogu.org/problemnew/show/P3973)

### $Solution$

首先来化简一下式子  

$$D=(A*B-C)*A^T$$  
$$=\sum_{i=1}^{n}(\sum_{j=1}^{n}A_j*B_{j,i}-C_i)*A_i$$   
$$=\sum_{i=1}^{n}\sum_{j=1}^{n}A_i*A_j*B_{i,j}-\sum_{i=1}^{n}C_i*A_i$$  


因为题目已经说明了$A$是一个$01$串,所以我们可以发现当$A_i$为$0$的时候对答案并没有任何贡献，不用计算。当$A_i$为$1$时，会有$C_i$的花费。但如果同时选$j$会有$B_{i,j}$的花费.所以这显然是一个最小割模型了。讲1看为选，0为不选

建图：
- 将每个$B_{ij}$看做一个点,总共有$n*n$个点。将这$S$和这$n*n$个点相连，流量为$B_{i,j}$
- 新建$n$个点。将这些点和$T$相连，流量为$C_i$
- 将$n*n$个点和新建节点中的$i,j$相连，流量为$inf$

答案就是$B$矩阵内的和-最小割

### $Code$

网络流代码过于长，代码见博客[这儿](https://www.cnblogs.com/hbxblog/p/10280551.html)

---

## 作者：zcxxnqwq (赞：1)

之前居然不知道矩阵的转置是什么/qd，百度一下发现这就是把矩阵的横竖颠倒一下。

然后进行一个柿子的推，发现 $D=\sum\limits_{i=1}^n a_i\ (\sum\limits_{j=1}^na_j\times b_{j,i}-c_i)$，由于 $c_i$ 这个东西的存在，且 $a$ 是 $01$ 矩阵，所以考虑最小割。

令 $a_i=1$ 的点 $i$ 属于集合 $S$，$a_i=0$ 的点 $i$ 属于集合 $T$，套路性地把每个点 $i$ 拆成横竖两个点 $x_i$ 和 $y_i$，根据式子建图：

- $a_i=0$ 损失的贡献为 $sum_i=\sum\limits_{j=1}^n b_{j,i}$，可以表示为连边 $(s,x_i,sum_i)$；
- $a_i=1$ 且 $a_j=0$ 损失的贡献为 $b_{j,i}$，表示为连边 $(x_i,y_j,b_{j,i})\ (j\ne i)$，$i=j$ 时不可能出现这种情况，即连边 $(x_i,y_i,+\infty)$；
- $a_i=1$ 要额外损失贡献 $c_i$，即连边 $(y_i,t,c_i)$，当 $i\in S$ 时强制切断这条边。

跑 Dinic 即可，答案即 $ans=\sum\limits_{i=1}^n\sum\limits_{j=1}^n b_{i,j}-$ 最小割。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define rep(i,s,e) for(int i=(s);i<=(e);++i)
#define Rep(i,s,e) for(int i=(e);i>=(s);--i)
using namespace std;
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    return x*f;
}
const int N=1010,M=1e6+5;
int n,s,t,b[N>>1][N>>1],c[N],sum[N];
int head[N],rad[N],cnt=1;
struct qwq{
    int v,w,nxt;
}e[M];
inline void add(int u,int v,int w){
    e[++cnt]={v,w,head[u]},head[u]=cnt;
    e[++cnt]={u,0,head[v]},head[v]=cnt;
}
int dep[N];
inline bool bfs(){
    queue<int> q;
    rep(i,1,t) dep[i]=0;
    dep[s]=1,q.push(s);
    while(!q.empty()){
        int x=q.front();q.pop();
        rad[x]=head[x];
        for(int i=head[x];i;i=e[i].nxt){
            int v=e[i].v,w=e[i].w;
            if(w&&!dep[v]) dep[v]=dep[x]+1,q.push(v);
        }
    }
    return dep[t]!=0;
}
int dfs(int x,int flow){
    if(x==t) return flow;
    int out=0;
    for(int &i=rad[x];i;i=e[i].nxt){
        int v=e[i].v,&w=e[i].w;
        if(w&&dep[v]==dep[x]+1){
            int res=dfs(v,min(flow,w));
            out+=res,flow-=res,w-=res,e[i^1].w+=res;
        }
        if(!flow) break;
    }
    if(flow) dep[x]=-1;
    return out;
}
signed main(){
    n=read(),s=n<<1|1,t=s+1;
    int ans=0,tmp;
    rep(i,1,n) rep(j,1,n) b[i][j]=read(),sum[j]+=b[i][j];
    rep(i,1,n) c[i]=read(),ans+=sum[i];
    rep(i,1,n){
        add(s,i,sum[i]),add(i+n,t,c[i]),add(i,i+n,1e9);
        rep(j,1,n) if(j!=i) add(i,j+n,b[j][i]);
    }
    while(bfs()) while(tmp=dfs(s,1e9)) ans-=tmp;
    // rep(i,1,t) cerr<<dep[i]<<' ';cerr<<endl;
    printf("%d\n",ans);
}
```


---

## 作者：nekko (赞：1)

首先不要读错题，注意 $A$ 是一个 $01$ 矩阵

化简一下式子，可以得到：

$$ans=\sum_{i=1}^{n}\sum_{j=1}^{n}a_ia_jb_{i,j}-\sum_{i=1}^{n}a_ic_i$$

意思就是有 $n$ 个物品，如果 $i,j$ 同时选择了，那么得到 $b_{i,j}$ 的收益；如果 $i$ 选择了，那么会花费 $c_i$

然后发现这就是个最大权闭合子图啊……

如果选择收益 $b_{i,j}$，那么会必须选择 $i,j$；如果选择 $i$，那么必须选择代价 $c_i$

然后 $S \to b_{i,j} \to i,j \to c_i,c_j \to T$

正权加起来后减去最大流即可

``` cpp
// luogu-judger-enable-o2
#include "bits/stdc++.h"
using namespace std;
typedef long long ll;

const int N = 5e6 + 10;

int b[510][510], c[510];

int head[N], rest[N], to[N], flow[N], tot = 1;

void ins(int u, int v, int w) {
    to[++ tot] = v, flow[tot] = w, rest[tot] = head[u], head[u] = tot;
}
void add(int u, int v, int w) {
    ins(u, v, w), ins(v, u, 0);
}

int dis[N], s, t, cnt;

int bfs() {
    for(int i = 1 ; i <= cnt ; ++ i) dis[i] = -1;
    dis[s] = 1; queue<int> q; q.push(s);
    while(q.size()) {
        int u = q.front(); q.pop();
        for(int i = head[u] ; i ; i = rest[i]) {
            int v = to[i];
            if(dis[v] == -1 && flow[i]) {
                dis[v] = dis[u] + 1;
                q.push(v);
            }
        }
    }
    return dis[t] != -1;
}

int dfs(int u, int f) {
    int use = 0;
    if(u == t || !f) return f;
    for(int i = head[u] ; i ; i = rest[i]) {
        int v = to[i];
        if(dis[v] == dis[u] + 1 && flow[i]) {
            int a = dfs(v, min(flow[i], f - use));
            flow[i] -= a, flow[i ^ 1] += a, use += a;
            if(use == f) break;
        }
    }
    if(!use) dis[u] = -1;
    return use;
}

const int inf = 0x3f3f3f3f;

int sol() {
    int res = 0;
    while(bfs()) {
        res += dfs(s, inf);
    }
    return res;
}
int n, idA[510], idB[510][510], idC[510];
int main() {
    scanf("%d", &n);
    for(int i = 1 ; i <= n ; ++ i)
        for(int j = 1 ; j <= n ; ++ j)
            scanf("%d", &b[i][j]);
    for(int i = 1 ; i <= n ; ++ i)
        scanf("%d", &c[i]);
    for(int i = 1 ; i <= n ; ++ i) idA[i] = ++ cnt;
    for(int i = 1 ; i <= n ; ++ i)
        for(int j = 1 ; j <= n ; ++ j)
            idB[i][j] = ++ cnt;
    for(int i = 1 ; i <= n ; ++ i) idC[i] = ++ cnt;
    s = ++ cnt, t = ++ cnt;
    int ans = 0;
    for(int i = 1 ; i <= n ; ++ i) {
        for(int j = 1 ; j <= n ; ++ j) {
            ans += b[i][j];
            add(s, idB[i][j], b[i][j]);
            add(idB[i][j], idA[i], inf);
            add(idB[i][j], idA[j], inf);
        }
    }
    for(int i = 1 ; i <= n ; ++ i) {
        add(idA[i], idC[i], inf);
        add(idC[i], t, c[i]);
    }

    printf("%d\n", ans - sol());
}
```

---

## 作者：Leap_Frog (赞：1)

### P.S.
前置知识：
1. 矩阵知识（保证能看懂题面  
2. 最大权闭合子图（网络流

### Description.
给定 $B_{[1...n][1...n]}$ 和 $C_{[1...n]}$  
构造 $A_{[1...n]}$ 为 01 矩阵  
使得 $(A\times B-C)\times A^T$ 最大
### Solution.
$$\sum_{i=1}^na_i\times\left(\left(\sum_{j=1}^na_j\times b_{j,i}\right)-c_i\right)$$  
$$\sum_{i=1}^na_i\times\left(\sum_{j=1}^na_j\times b_{j,i}\right)-\sum_{i=1}^na_ic_i$$  
$$\sum_{i=1}^n\sum_{j=1}^na_ia_jb_{j,i}-\sum_{i=1}^na_ic_i$$
由于 $\{a_i\}$ 是 01 数组（这个笔者刚开始没看到。  
然后我们就可以想象成有 $n$ 个点，$\{a_i\}$ 表示第 $i$ 个点是否选择。  
然后上面的式子就变成了选第 $i$ 个点会有 $c_i$ 的代价。  
而选 $i$ 和 $j$ 两个点有 $b_{i,j}$ 的收益。  
然后显然是一个最大全闭合子图的板子。  
直接上最小割就好了。  
### Coding.
```cpp
//愿你和你重要的人能够重逢！
#include<bits/stdc++.h>
using namespace std;typedef long long ll;
template<typename T>inline void read(T &x)
{
	x=0;char c=getchar(),f=0;
	for(;c<'0'||c>'9';c=getchar()) if(!(c^45)) f=1;
	for(;c>='0'&&c<='9';c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	f?x=-x,1:1;
}
const ll INF=1e9+5;struct edge{int to;ll w;int nxt;}e[7505005];
int n,s,t,et,head[250505],cur[250505],d[250505];
inline void ADDE(int x,int y,ll w) {e[++et]=(edge){y,w,head[x]},head[x]=et;}
inline void adde(int x,int y,ll w) {ADDE(x,y,w),ADDE(y,x,0);}
inline char bfs(int s,int t)
{
	queue<int>q;q.push(s),memset(d,0,sizeof(d)),d[s]=1;
	while(!q.empty())
	{
		int x=q.front();q.pop();
		for(int i=head[x];i;i=e[i].nxt) if(!d[e[i].to]&&e[i].w) q.push(e[i].to),d[e[i].to]=d[x]+1;
	}
	return !!d[t];
}
#define rev(x) ((((x)&1)?1:-1)+(x))
inline ll dfs(int x,int t,ll lim=INF)
{
	ll f=lim;if(x==t) return lim;
	for(int &i=cur[x];i;i=e[i].nxt) if(d[e[i].to]==d[x]+1&&e[i].w)
		{ll g=dfs(e[i].to,t,min(f,e[i].w));e[i].w-=g,e[rev(i)].w+=g,f-=g;if(!f) break;}
	return lim-f;
}
inline ll dinic(int s,int t) {ll r=0;while(bfs(s,t)) memcpy(cur,head,sizeof(cur)),r+=dfs(s,t);return r;}
int main()
{
	read(n),s=n*n+n+1,t=s+1;ll cnt=0;
	for(int i=1,id,x;i<=n;i++) for(int j=1;j<=n;j++) read(x),cnt+=x,adde(s,id=(i-1)*n+j,x),adde(id,n*n+i,INF),adde(id,n*n+j,INF);
	for(int i=1,x;i<=n;i++) read(x),adde(n*n+i,t,x);
	return printf("%lld\n",cnt-dinic(s,t)),0;
}
```

---

## 作者：deovc (赞：1)

# 意外发现
此题的正解如大佬们所说的那样，应该是用最小割。
  
但是本题有个特殊之处：假设A全为1，则B的每个元素都会派上用场。按题给样例，如果此时我们让A的第3个（随意选的）元素为0（A[3]=0），即A=[1 1 0]。我们再带入D公式计算一遍就能发现此时B的第3行和第3列元素失效（对于结果值没有贡献），而且C的第3列元素（第3个元素）也失效。直观点说，就是划去了这些行和列的元素。  
也就是说A的第i位是否为1，表示是否启用B的第i行和第i列，以及C的第i列。那么我们只需要判断，该位应该在何时启用即可。  
同样用A[3]为例，我们再次带入D的公式，可以发现，A[3]从1到0对最终结果值消除的增益为B[3][1] + B[3][2] + B[1][3] + B[2][3] + B[3][3] - C[3] = 1 + 2 + 1 + 0 + 3 - 7 = 0。依次分析A[1]、A[2]从1到0带来的增益消除，我们就可以发现，A[1]=0和A[2]=0带来的是正数增益消除，也就是说会让结果值变小，所以这种消除不可取，于是A[1]和A[2]保持为原来的1。而A[3]带来的增益消除效果为0，也就是说A[3]=0/1都可以。  
通过上述分析，我们只需要判断A中每一位从1到0产生的效果是否有益即可（即增益消除效果 < 0）。换句话说，只要验证一下，划去B的第i行和第i列，以及C的第i列是否会有正向增益即可。  
  
Talk is cheap. Show me the code.
```cpp
#pragma GCC optimize(2)
#include<cstdio>
#include<iostream>
#include<vector>

using namespace std;
const int maxn=505;
int num[maxn][maxn];
int n, res;
vector<int> a; //表示A的哪些位置为1

int main()
{
    //freopen("input.in", "r", stdin);
    ios::sync_with_stdio(0);
    cin>>n;
    for(int i=1; i<=n+1; ++i){ //C放在num中的n+1行了
        for(int j=1; j<=n; ++j){
            cin>>num[i][j];
        }
    }
    for(int i=1; i<=n; ++i){
        int row=0, col=0;
        for(int j=1; j<=n; ++j){
            row+=num[i][j];
            col+=num[j][i];
        }
        if(col+row-num[i][i]-num[n+1][i] > 0) a.push_back(i); //这里判断增益是否有效
    }
    //有了A后，只需要进行矩阵运算即可
    for(int i=0; i<a.size(); ++i){
        for(int j=1; j<=n; ++j){
            num[0][j]+=num[a[i]][j]; //留了num的第0行用作临时存储
        }
    }
    for(int i=0; i<a.size(); ++i){
        res+=num[0][a[i]]-num[n+1][a[i]];
    }
    printf("%d", res);
}

```
第一次写博客，感谢大家阅读！

---

## 作者：RockyYue (赞：0)

### 题意

给定一个 $n\times n$ 矩阵 $B$ 和一个 $1\times n$ 矩阵 $C$，求一个 $1\times n$ 矩阵 $A$，使得 $D=(A\times B-C)\times A^T$ 中元素之和最大，其中 $A^T$ 为 $A$ 的转置，输出 $T$。

其中 $n\le 500$，$B,C$ 均为 $[0,1000]$ 内整数。

### 解法

> Trick: 对于状态维数较高的情况（如本题 $n$ 维表示 $A$ 的每一位）但是每一维可以选择的情况又不多（如本题 $A_i\in \{0,1\}$ 时，往往直接随机化较退火是更优的。

$D$ 的形式有些抽象，先化简一下 $D$ 中所有元素之和。

设 $A\times B=P$，则 $P$ 是一个 $1\times n$ 的矩阵，$P_{1,i}=\sum_{j=1}^{n}{(A_{1,j}B_{j,i})}$，则若 $A\times B-C=Q$，$Q$ 亦为 $1\times n$，$Q_{1,i}=\sum_{j=1}^{n}{(A_{1,j}B_{j,i})-C_{1,i}}$。$1\times n$ 和 $n\times 1$ 矩阵相乘，按位对应乘即可。于是 $\sum D=\sum_{i=1}^{n}{Q_{1,i}A_{i,1}}$。

$A$ 每一位状态只有 $0$ 和 $1$，可以将 $A_{1,1\dots n}$ 看作 $n$ 个物品，取第 $i$ 个（即 $A_{1,i}=1$）会对 $\sum D$ 直接带来 $-C_{1,i}$ 的贡献，同时若同时取第 $i$ 个和第 $j$ 个（可以有 $i=j$）可以带来 $B_{i,j}+B_{j,i}$ 的贡献。

考虑随机化，每次随机选择一个 $A_i$，将其取反，计算取反这一位带来的贡献，这是 $O(n)$ 的（对于每个 $j$ 看在当前状态中是否同时取，这个较之前是否有改变），答案即为整个过程中贡献和的最大值。

这个随机改变一位的过程和 ```random_shuffle``` 的正确概率可以看做是一样的，随机的原因在于易于更新贡献。

分析一下概率，首先最优答案可能对应着多种 $A$ 的选择情况，设一次随机选择情况的正确概率为 $p$，总共执行 $k$ 次，则最终正确概率为 $1-(1-p)^k$，是可以相信的。

---

## 作者：SoyTony (赞：0)

前置知识：矩阵乘法定义，最大流最小割

先来转化一下题意，由于 $A$ 是 $01$ 的行向量，题目实际上是按照规则，选择一些数使得权值和最大。

不难发现的是 $AB-C$ 是指在矩形中每一列固定选几个位置上的数（$A$ 中为 $1$），加和减去 $C$ 中的数，从而得到一个新的行向量。

接下来再乘上 $A$ 的转置也就是在行向量中选择刚才选择位置上的数加和。

画图理解实际上是在方阵上划去行以及对应的列，没有被划去的数求和，同时没有划去的列要减去对应位置的 $C$ 值。

放在一起就是一个 $(n+1)\times n$ 的矩阵划去一些列以及对应的行，求和的最大值，其中除最后一行以外都是正贡献。

可以想到的一个网络流经典模型是让每个节点表示划去的一行（列），点与点之间的容量被权值限制，钦定与源点相连表示不划去，与汇点相连表示划去。

考虑 $(i,j)$，默认 $i,j$ 不同。

设容量 $c(s,i)=a,c(s,j)=b,c(i,t)=c,c(j,t)=d,c(i,j)=e,c(i,j)=f$，根据一些情况可以列出方程：

当 $i,j$ 都不被划去时，割去 $c,d$，代价 $0$，即：
$$c+d=0$$
当 $i,j$ 都被划去时，同理有：
$$a+b=B_{i,j}+B{j,i}$$
当 $i$ 被划去时：
$$a+c+e=B_{i,j}+B_{j,i}$$
当 $j$ 被划去时：
$$b+d+f=B_{i,j}+B_{j,i}$$

而 $i=j$ 时，要考虑 $C$ 的负贡献，也就是：
$$c(s,i)=B_{i,i}-C_i,c(i,t)=0$$

其实说到这里，不难看出解出容量跑最小割就可以了，但是容量可能为负数或零，这是我们不想看到的。

然而出现这种权值一定在与源点和汇点的边上，而每个点与源点汇点的边一定会割掉一条，也就是说我们可以给它增加一个附加权值而不影响答案，设附加权值为 $bs$，这样解上面的方程得到：
$$\begin{cases}
a=b=bs+\dfrac{B_{i,j}+B_{j,i}}{2}\\
c=d=bs\\
e=f=\dfrac{B_{i,j}+B_{j,i}}{2}
\end{cases}$$

于是答案就是：
$$\sum b-\sum c+bs\times n-\operatorname{maxf}()$$

其实最小割解决此类问题就是消去不需要的贡献。

```cpp
int n;
int b[505][505],c[505]; 
int S,T;
struct Graph{
    struct edge{
        int to,nxt,lim;
    }e[maxm<<1];
    int head[maxn],cnt=1;
    inline void add_edge(int u,int v,int w){
        e[++cnt].to=v,e[cnt].nxt=head[u],e[cnt].lim=w,head[u]=cnt;
        e[++cnt].to=u,e[cnt].nxt=head[v],e[cnt].lim=0,head[v]=cnt;
    }
    int cur[maxn],dis[maxn];
    ll dfs(int u,ll rest){
        if(u==T) return rest;
        ll flow=0;
        for(int i=cur[u];i&&rest;i=e[i].nxt){
            cur[u]=i;
            int v=e[i].to,C=min(rest,(ll)e[i].lim);
            if(dis[u]+1==dis[v]&&C){
                ll k=dfs(v,C);
                flow+=k,rest-=k;
                e[i].lim-=k,e[i^1].lim+=k;
            }
        }
        if(!flow) dis[u]=-1;
        return flow;
    }
    inline ll max_flow(){
        ll flow=0;
        while(1){
            queue<int> q;
            memcpy(cur,head,sizeof(head));
            memset(dis,-1,sizeof(dis));
            dis[S]=0;
            q.push(S);
            while(!q.empty()){
                int u=q.front();
                q.pop();
                for(int i=head[u];i;i=e[i].nxt){
                    int v=e[i].to;
                    if(dis[v]==-1&&e[i].lim){
                        dis[v]=dis[u]+1;
                        q.push(v);
                    }
                }
            }
            if(dis[T]==-1) return flow;
            flow+=dfs(S,1e18);
        }
    }
}G;
ll sum[505],ans;
int main(){
    // freopen("test.in","r",stdin);
    // freopen("test.out","w",stdout);
    n=read();
    for(int i=1;i<=n;++i){
        for(int j=1;j<=n;++j){
            b[i][j]=read();
            ans+=b[i][j];
        }
    }
    for(int i=1;i<=n;++i){
        c[i]=read();
        ans-=c[i];
    }
    ans+=bs*n;
    S=n+1,T=n+2;
    for(int i=1;i<=n;++i){
        sum[i]=bs+b[i][i]-c[i];
        G.add_edge(i,T,bs*2);
        sum[i]*=2;
        // printf("sum: %d %lld\n",i,sum[i]);
    }
    for(int i=1;i<=n;++i){
        for(int j=1;j<=n;++j){
            if(i==j) continue;
            G.add_edge(i,j,b[i][j]+b[j][i]);
            sum[i]+=b[i][j]+b[j][i];
        }
    }
    for(int i=1;i<=n;++i){
        G.add_edge(S,i,sum[i]);
    }
    printf("%lld\n",ans-G.max_flow()/2);
    return 0;
}
```

---

## 作者：juruo999 (赞：0)

# P3973 [TJOI2015]线性代数

蒟蒻一遍过，发题解祭之。

[传送门](https://www.luogu.com.cn/problem/P3973)
[更好体验](https://codewasp942.github.io/Kn-Blog/solution/P3973)

一道看起来不像费用流的费用流

## 分析

先展开柿子

$$
\begin{aligned}
D&=(A\times B-C)\times A^T\\
&=\sum_{i=1}^n{a_i\left(\sum_{j=1}^n{a_j\cdot b_{j,i}}-c_i\right)}\\
&=\sum_{i=1}^n\sum_{j=1}^n{a_ia_jb_{j,i}}-\sum_{i=1}^n{a_ic_i}\\
&=\sum_{i=1}^n\sum_{j=1}^n{a_ia_jb_{i,j}}-\sum_{i=1}^n{a_ic_i}
\end{aligned}
$$

$A$ 是 **01 矩阵**，所以 $a_i$ 和 $a_j$ 都为 $1$ 时，$a_i a_j$ 的取值才能是 $1$。

设展开式减号前的部分为 $X$，减号后的部分（含减号）为 $Y$，则 $D=X+Y$。

先考虑 $X$。假设所有 $a_i$ 全部是 $1$，这时，$X=\sum b_{i,j}$。对于每一对 $(i,j)$，如果 $a_i$ 和 $a_j$ 中有一个为 $0$，就会使减号前的部分减少 $b_{i,j}$，也就是产生 $b_{i,j}$ 的损失。

再考虑 $Y$。假设所有 $a_i$ 全部是 $0$，这时，$Y=0$。如果 $a_i$ 变为 $1$，则会使 $Y$ 增加 $-c_i$，也就是产生 $c_i$ 的损失。

如果我们不想产生 $b_{i,j}$ 的损失，那么 $a_i$ 和 $a_j$ 就一定都为 $1$。 

由于 $b_{i,j}$ 和 $c_i$ 都非负，这显然是非常经典的最小割模型。把图分成两部分，一部分表示取，一部分表示不取，两部分之间边表示关系。

**建图方法**：把每个 $b_{i,j}$ 看作点 $(i,j)$，源点向 $(i,j)$ 连边权为 $b_{i,j}$ 的边，割掉边表示 $a_i$ 与 $a_j$ 至少有一个是 $0$，把每个 $c_i$ 看作点 $i$，$(i,j)$ 向 $i$ 和 $j$ 连边权为 $\infty$ 的边，$i$ 向汇点连边权为 $c_i$ 的边，割掉边表示 $a_i=1$，跑**最小割**。

割掉源点到 $(i,j)$ 的边表示 $a_i$ 与 $a_j$ 至少有一个为 $0$，也就是割掉或者不割掉一条边都表示对 $a_i$ 的约束，那么这些约束会不会冲突呢？答案是不会的。大家可以自行验证。

## Code

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;

typedef long long ll;
const ll inf=1145141919810000;

namespace Flow{

	const int maxn=251005,maxm=750600;
	struct Edge { int v;ll w;int nxt; } E[maxm*2];
	int Fst[maxn],tp=1;
	void add(int u,int v,ll w){ E[++tp]=Edge{v,w,Fst[u]}; Fst[u]=tp; }
	void addEdge(int u,int v,ll w){ add(u,v,w);add(v,u,0); }

	int s,t,h[maxn],g[maxn];
	void bfs(){
		queue<int> Q; g[h[t]=1]++; Q.push(t);
		while(!Q.empty()){
			int u=Q.front(); Q.pop();
			for(int e=Fst[u];e;e=E[e].nxt){
				int v=E[e].v; if(h[v]) continue;
				g[h[v]=h[u]+1]++; Q.push(v);
			}
		}
	}
	ll aug(int u,ll F){
		if(u==t || F==0) return F;
		ll tot=0;
		for(int e=Fst[u];e;e=E[e].nxt){
			int v=E[e].v; if(E[e].w==0 || h[v]+1!=h[u]) continue;
			ll f=aug(v,min(F,E[e].w));
			F-=f;tot+=f;E[e].w-=f;E[e^1].w+=f;
			if(F==0){ return tot; }
		}
		if((--g[h[u]])==0) h[s]=maxn-1;
		g[++h[u]]++;
		return tot;
	}
	ll flow(){
		bfs(); ll ans=0;
		while(h[s]<maxn-1) ans+=aug(s,inf);
		return ans;
	}

}

int n;
ll b[505][505],c[505],su;

int main(){

	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);

	cin>>n;
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) cin>>b[i][j],su+=b[i][j];
	for(int i=1;i<=n;i++) cin>>c[i];

	Flow::s=1; Flow::t=2;
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) Flow::addEdge(1,n*(i-1)+j+2,b[i][j]);
	for(int i=1;i<=n;i++) Flow::addEdge(2+n*n+i,2,c[i]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			Flow::addEdge(n*(i-1)+j+2,2+n*n+i,inf);
			Flow::addEdge(n*(i-1)+j+2,2+n*n+j,inf);
		}

	cout<<su-Flow::flow()<<endl;

	return 0;
}
```

---

## 作者：ustze (赞：0)

题目所给的式子可以转化为
$$\sum_{i=1}^n\sum_{j=1}^nA_iA_jB_{ij}-\sum_{i=1}^nA_iC_i$$  
(顺便一提，矩阵$A$的转置$A^T$，即原$A_{ij}=A^T_{ji}$  
令A中1的位置集合为S 则
$$\sum_{i\in S}\sum_{j\in S}B_{ij}-\sum_{i\in S}C_i$$  
显然为最大权闭合子图模型，套路建图求最小割即可  
code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=1e6+6,inf=0x3f3f3f3f;

inline int read(){
	int s=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) s=s*10+ch-'0',ch=getchar();
	return s;
}
int n;
int b[505][505],c[505],id[505][505];
struct edge{
	int to,w,rev;
};
int d[M],cur[M];vector<edge> G[M];
int s,t,tot=0;
queue<int> q;
inline int bfs(){
	memset(d,-1,sizeof(d));
	d[s]=0,q.push(s);
	while(!q.empty()){
		int u=q.front();q.pop();
		for(edge e:G[u]){
			if(e.w>0&&d[e.to]<0){
				d[e.to]=d[u]+1;
				q.push(e.to);
			}
		}
	}
	return d[t]!=-1;
}
int dfs(int u,int f){
	if(u==t) return f;
	int w,tot=0;
	for(int &i=cur[u];i<G[u].size();i++){
		edge &e=G[u][i];
		if(e.w>0&&d[e.to]==d[u]+1&&(w=dfs(e.to,min(e.w,f)))){
			e.w-=w;G[e.to][e.rev].w+=w;
			f-=w,tot+=w;
			if(f<=0) break;
		} 
	}
	return tot;
}
inline void add_edge(int u,int v,int c){
	G[u].push_back({v,c,G[v].size()});
	G[v].push_back({u,0,G[u].size()-1});
}
inline int dinic(){
	int flow=0;
	while(bfs()){
		memset(cur,0,sizeof(cur));
		flow+=dfs(s,inf);
	}
	return flow;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++) 
		for(int j=1;j<=n;j++)
			b[i][j]=read(),id[i][j]=++tot;
	for(int i=1;i<=n;i++) c[i]=read();
	s=0,t=M-6;int ans=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			add_edge(s,id[i][j],b[i][j]);
			add_edge(id[i][j],tot+i,inf);
			ans+=b[i][j];
			if(i!=j) add_edge(id[i][j],tot+j,inf);
		}
	for(int i=1;i<=n;i++) add_edge(tot+i,t,c[i]);
	printf("%d",ans-dinic());
	return 0;
}

```

---

## 作者：破壁人 (赞：0)

分析：

由于A只有0和1,所以我们可以把0看作不取，1看作取。
那题目就变成了：

有n个点，取i要扣除ci的收益，但同时取i和j则可以获得b[i][j]+b[j][i]的收益。

这就是很经典的最小割建模，因为把一张网络分成两部分，

一部分表示取，另一部分表示不取，最小割就是这个方案的收益。

设源点S，汇点T。

用(i,j)表示同时选i和j，S向(i,j)连容量为b[i][j]+b[j][i]的边。

用i表示不选i，i向T连容量为c[i]的边。

为了保证(i,j)和i，j同时选择，(i,j)分别向i和j连容量为无限大的边。

这样，跑一遍最大流，B矩阵中所有数的和-最小割就是答案了。

代码：
```cpp

#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>

using namespace std;

const int inf=1e9;

int e1,to[1000001],w[1000001],next[1000001],first[1000001];
int e[1000001],f[1000001],d[1000001],b[501][501];
int cur[1000001],N,ans=0,sum=0,n1,S,T,x,n,mi=inf;

void insert(int o,int p,int q)
{
    to[e1]=p;w[e1]=q;next[e1]=first[o];first[o]=e1++;
    to[e1]=o;w[e1]=0;next[e1]=first[p];first[p]=e1++;
}

int main()
{
    memset(first,-1,sizeof(first));
    memset(cur,-1,sizeof(cur));
    memset(e,-1,sizeof(e));
    scanf("%d",&n);
    N=n*(n+1)/2;
    S=N+n+1;T=S+1;
    for(int i1=1;i1<=n;i1++)
        for(int j1=1;j1<=n;j1++) {scanf("%d",&b[i1][j1]);sum+=b[i1][j1];}
    for(int i=1;i<=n;i++)
        for(int j=i;j<=n;j++)
        {
            int x=(i==j)?b[i][j]:(b[i][j]+b[j][i]),yu=(i-1)*(2*n-i+2)/2+(j-i+1);
            insert(S,yu,x);
            insert(yu,N+i,inf);
            if(i!=j) insert(yu,N+j,inf);
        }
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&x);
        insert(N+i,T,x);
    }
    memset(f,0,sizeof(f));
    memset(d,0,sizeof(d));
    e[S]=S;f[0]=n1=N+n+2;
    int now=S;ans=0;
    for(int i=0;i<=n1;i++) cur[i]=first[i];
    while(d[S]<n1)
    {
        int bo=false;
        for(int i=cur[now];i!=-1;i=next[i])
            if((d[now]==(d[to[i]]+1))&&(w[i]>0))
            {      
                cur[now]=i;          
                mi=min(mi,w[i]);e[to[i]]=now;now=to[i];
                if(now==T)
                {
                    ans+=mi;
                    while(now!=S)
                    {	
                        w[cur[e[now]]]-=mi;
                        w[cur[e[now]]^1]+=mi;
                        now=e[now];   
                    }
                    mi=inf;
                }
                bo=true;break;
            }
        if(bo) continue;int mmi=n1;
        for(int i=first[now];i!=-1;i=next[i])
            if((w[i]>0)&&(mmi>d[to[i]])) {mmi=d[to[i]];cur[now]=i;}
        if(!(--f[d[now]])) break;
        f[(d[now]=(mmi+1))]++;now=e[now];
    }
    cout<<sum-ans<<endl;
    return 0;
}
```

---


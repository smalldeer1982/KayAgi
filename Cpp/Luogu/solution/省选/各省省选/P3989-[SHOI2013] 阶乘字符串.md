# [SHOI2013] 阶乘字符串

## 题目背景

shoi2013d1t2

（本题卡常数注意）


## 题目描述

给定一个由前 $n$ 个小写字母组成的串 $S$。串 $S$ 是阶乘字符串当且仅当前 $n$ 个小写字母的全排列（共 $n!$ 种）都作为的子序列（可以不连续）出现。

由这个定义出发，可以得到一个简单的枚举法去验证，但是它实在太慢了。所以现在请你设计一个算法，在 $1$ 秒内判断出给定的串是否是阶乘字符串。

## 说明/提示

第一组数据中，`ab` 这个串没有作为子序列出现。

![](https://cdn.luogu.com.cn/upload/image_hosting/9zs871wl.png)


## 样例 #1

### 输入

```
2
2
bbaa
2
aba```

### 输出

```
NO
YES```

# 题解

## 作者：Rusalka (赞：5)

## 题意简述

- 定义一个由前 $n$ 个字母组成的字符串为阶乘字符串，前 $n$ 个小写字母的全排列都作为它的子序列出现。

- 给定一个字符串 $S$，询问它是否是阶乘字符串。

- 多组数据，$1 \le T \le 5$, $1 \le n \le26$, $1 \le |S| \le 450$

## 分析与解答

#### 1. 关于 $n$ 的范围

- 考虑一个包含前 $n$ 种小写字母的字符串，长度至少要为多少才能满足其为阶乘字符串。换句话说，构造一个由前 $n$ 个字母组成的阶乘字符串，使得它的长度最小。

- 容易想到一种最 naive 的构造方式，将前 $n$ 个小写字母顺序排列再复制 $n$ 次，得到一个长度为 $n^2$ 的字符串。例如，当 $n=3$ 时，为 $\text{abcabcabc}$。容易证明该字符串一定为阶乘字符串。

- 在上面的构造方式中再改进一步，删去一些无用的字符，可以得到一种形如 $\text{abcdcbabcdcba}\ (n=4)$ 的构造方式（即以 $\text{abcd、dcba}$ 为基础串，将当前基础串接在前一个基础串的后面）（表述不太清楚，理解万岁，理解万岁），这种构造方式长度为 $n^2-n+1$

- **目前，我还没有找到更优秀的构造方式**。也就是说，现在可以假定，一个字符串的长度至少为 $n^2-n+1$，它才可能是前 $n$ 个字母的阶乘字符串。

- 注意到 $22^2-22+1 = 463 \gt 450, 21^2-21+1 = 421 \lt 450$，所以当 $n \ge 22$ 时一定无解。

- 通过上面的分析，我们将 $n$ 范围将至了 $1 \le n \le 21$，这就可以保证接下来的 dp 的时空复杂度了。

---

#### 2. 关于如何 dp

- 如果以考虑前第 $i$ 个字符为状态，每次转移时都需要枚举之前的所有子序列并一个一个 check，显然会超时。

- 注意到 $n \le 21$，我们不妨抛开上一个思想，考虑状压小写字母。令 $f_i$ 表示 $i$ 中的小写字母集合组成的所有全排列，是否都在 $S$ 的子序列中出现过。

- 于是转移又成了很大的问题。

- 这种时候，常见的想法是改变状态。令 $f_i$ 表示 $i$ 中的小写字母集合组成的所有全排列，在 $s$ 中全部出现过，所需要的下标**最小**是多少。此时，如果一个字母集合 $i$ 不能达成阶乘字符串的要求，则 $f_i = +\infty$。

- 构造 $S$ 的序列自动机，即 $nxt_{i,j}$ 表示第 $i$ 个位置后，字符 $j$ 第一次出现的位置，其中 $i \in [1,m],\ j \in [0,n)$。

- 这种状态下的转移不妨使用刷表法。只需要考虑在当前集合中加入一种小写字母，会发生什么变化。

- 发现如果加入一种字母 $j$，则在原来子序列的最后只要加入一个 $j$ 来满足有以 $j$ 结尾的排列；而包含 $j$ 的其他排列会在其它的转移中被考虑到。

- 所以转移就为 $f_{i|(1<<j)} = nxt_{f_i,j}$。因为要保证所有的排列都能够被满足，每个 $f_i$ 在向它转移的 $nxt$ 中取最大值。

- 最后判断 $f_{(1<<n)-1}$ 是否满足条件即可。

## Code

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int MAXM = 460;
const int MAXN = 23;
const int MAXS = (1<<21) + 10;
const int INF = 0x3f3f3f3f; 

int n, m, T;
char s[MAXN];
int f[MAXS], nxt[MAXM][MAXN];

inline bool work()
{
	scanf("%d%s",&n,s+1);
	int m = strlen(s+1);
	if(n > 21) return 0;
	for(int i=0;i<n;i++)
		nxt[m][i] = INF;
	for(int i=m;i>=1;i--) // 序列自动机 nxt
	{
		for(int j=0;j<n;j++)
			nxt[i-1][j] = nxt[i][j];
		nxt[i-1][s[i]-'a'] = i;
	}
	int maxs = 1<<n;
	for(int i=0;i<maxs;i++)
		f[i] = 0;
	for(int s=0;s<maxs;s++)
	{
		if(f[s] == INF) return 0; // 如果子集都无法满足，全部也一定不满足
		for(int i=0;i<n;i++)
		{
			if(((~s)>>i)&1)
			{
				if(f[s] == INF) f[s|(1<<i)] = INF;
				else f[s|(1<<i)] = max(f[s|(1<<i)], nxt[f[s]][i]);
			}
		}
	}
	return f[maxs-1] != INF; 
}

int main()
{
	scanf("%d",&T);
	while(T--) puts(work()?"YES":"NO");
	return 0;
}
```


---

## 作者：ZnPdCo (赞：4)

# 题目大意

给定一个字符串，看其是不是 $n$ 个小写字母全排列组成的子序列（**注意不是子串**）

# 更新记录

upd:2023-10-02 22:05:50 第一版，提出反例 `abcdabcadbac`

upd:2023-10-04 21:34:47 第二版，发现更优的构造方法（By [@Ac_forever](https://www.luogu.com.cn/user/768416)）

首先，我们可以~~很容易~~发现，$n>21$ 时完全构造不出合法的方案，所以答案一定为 `NO`。

证明：然鹅，网上说 $\dbinom{450}{21}<21!$ 是不正确的， 因为我自己算了一遍发现不对。

然后就是所谓的 $n^2-n+1$ 或 $n(n-1)+1$，是错误的、更优的构造方法为：


设 `'a'+n-1` 为 `x`，则重复 $n-3$ 遍从 `a` 到 `x`，然后再为 `a` 到 `x-1`，再为 `a` 和 `x`，再为 `a+1` 到 `x-1`，最后为 `a`。

举个例子可能会更好（$n=5$）：

$$
\underbrace{abcde\ abcde}_{n-3\text{遍}}\ \underbrace{abcd}_{\text{去尾}}\ \underbrace{a\ e}_{\text{头、尾}}\ \underbrace{bcd}_{\text{去头去尾}}\ \underbrace{a}_{\text{固定了}}
$$

~~但是我不会证明~~

但是又有~~前车之鉴~~，所以说，只能是最小字符串长度的**上限**是 $n^2-n$。

那么我们假定就是这个就是最小字符串的大致范围，那么发现当 $n=22$ 时 $n^2-n=462>450$，所以当 $n>21$ 时完全构造不出合法的方案。

---

发现可以状压。

用 $f_s$ 表示进行状态转移，$s$ 表示我们组成的前排列中字母的存在情况。例如 $s=(101)_2$ 表示有字母 `a` 和 `c`。

$f_s$ 表示满足条件的最小的字符串前缀长度，还是 $s=(101)_2$，若 $S=acaa$，容易发现 $f_s=3$，因为前 $3$ 的前缀为 `aca`，有 `ac` 与 `ca`，满足题意。

定义函数 $\text{nxt}(i,j)$ 表示第 $i$ 位后面的第一个字符 $j$ 的位置（不含自己）

然后枚举新加入的字符 `c`，易得：

$$
f_{s|c}=\max(f_{s|c},\text{nxt}(f_s,c))\qquad c\not\in s
$$

为什么是 $\max$？因为有两种情况：

1. $f_{s|c} > \text{nxt}(f_s,c)$，那么这时候 $f_{s|c}$ 是包含的 $c$ 的，满足条件
2. $f_{s|c} < \text{nxt}(f_s,c)$，那么这时候 $f_{s|c}$ 是不包含的 $c$ 的，要把 $c$ 包括进去

最后判断 $f_{(\underbrace{111\cdots111}_{\text{(n-1)个1}})_2}$，也就是 $f_{(1<<n)-1}$ 是不是合法的即可。

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ll long long
#define INF (ll)(1e17)
using namespace std;
ll t;
ll n;
char S[500];
ll nxt[500][26];
ll f[(1<<21)+10];
int main() {
	scanf("%lld", &t);
	while(t--) {
		scanf("%lld", &n);
		scanf("%s", S + 1);
		ll m = strlen(S + 1);
		
		
		if(n > 21) {
			printf("NO\n");
			continue;
		}
		
		
		
		for(ll c = 0; c < n; c++) nxt[m][c] = INF;
		for(ll s = 0; s < (1 << n); s++) {
			f[s] = 0;
		}
		
		
		
		for(ll i = m; i >= 1; i--) {
			for(ll c = 0; c < n; c++) {
				nxt[i - 1][c] = nxt[i][c];
			}
			nxt[i - 1][(ll)(S[i]) - 'a'] = i;
		}
		
		
		
		
		for(ll s = 0; s < (1 << n); s++) {
			for(ll c = 0; c < n; c++) {
				if((s | (1 << c)) != s) {
					if(f[s] == INF) f[s | (1 << c)] = INF;
					else f[s | (1 << c)] = max(f[s | (1 << c)], nxt[f[s]][c]);
				}
			}
		}
		
		
		if(f[(1 << n) - 1] == INF) printf("NO\n");
		else printf("YES\n");
	} // ( •̀ ω •́ )\
}
```

---

## 作者：Ac_forever (赞：3)

具体思路前面大佬都讲得很清楚了，我来具体讲讲此题的必要条件：
 $|s| \geq (n-1)\times n+1 $ 的证明。


定义字符串 $p$ 由前 $n$ 个字母组成，且没有重复字母。

易证： $n$ 个由 $p$ 组成的字符串一定满足要求。

考虑删除，当此字符串仅由 $n-1$ 个 $p$ 组成时，会出现如下情况，即第 $n!$ 个排列无法被算到，缺少最后一项。

那么仅需在末尾加上缺失项即可。

即 $|s|\geq (n-1)\times n+1$ 。

因为当此字符串仅由 $n-1$ 个 $p$ 组成时，第 $n!$ 个排列无法被算到，而此种构造方法为最优构造，所以结论成立。

## update:
### 10.4
感谢 @ZnPdCo 的提醒，发现一种构造：在 $n \ge 3$ 时， $p$ 重复 $n-3$ 次，后面加上 'a' 以及最后一个字母，加上 $2 \sim n-1$ 的所有字母，再加 'a' 。

本构造方法使得长度缩减至 $n \times (n-1)$ ，且通过测试。

---

## 作者：Alice_foo_foo (赞：3)

- 设f[S]表示当S中集合中的字母构成的排列均在原序列[1,f[S]]出现的最小值。

- 枚举排列的最后一个元素，则f[S]=max(next[f[S^(1<<i)]][i])，其中next[i][j]表示从i开始下一个j出现的位置。

- 然后我就不明白怎么舍解了，上网搜了一下发现n<=21但我并不知道为什么这样可以2333（如有能证明的神犇请私信）。


```cpp
#include<bits/stdc++.h>  
#define MAXN 505  
using namespace std;    int t,n,m;  
char s[MAXN];  
int f[MAXN][30];  
int g[1<<22];  
int main(){  
    scanf("%d",&t);  
    while(t--){  
        scanf("%d%s",&n,s+1);   m=strlen(s+1);  
        if(n>21){  
            puts("NO");  
            continue;  
        }  
        memset(f,-1,sizeof f);  
        for(int i=1;i<=m;++i){  
            for(int j=0;j<n;++j) f[i][j]=f[i-1][j];  
            f[i][s[i]-'a']=i;  
        }  
        for(int i=0;i<(1<<22);++i) g[i]=m;  
        for(int s=1;s<(1<<n);++s)  
            for(int i=0;i<n;++i){  
                if(g[s^(1<<i)]==-1){  
                    g[s]=-1;  
                    continue;  
                }  
                if(s&(1<<i))  g[s]=min(g[s],f[g[s^(1<<i)]][i]);  
            }  
//      printf("%d\n",g[(1<<n)-1]);  
        puts(g[(1<<n)-1]<0?"NO":"YES");  
    }  
    return 0;  
}  
```

---

## 作者：lx_zjk (赞：2)

这道题思维难度还是很大的 

先是看数据范围 $n<=26$不是特别可以状压 可能会$MLE$

$len <= 450$ 

$C(450, 21) < 21$

说明当$n > 21$ 时是无解的 因为无法凑出21个对

那么也就可以状态压缩了

$f[s] = next[f[s$^$(1 << j)]][j]$

$f[s]$表示当以s为子集判断其可行性

但是由于这样不好转移

由此$f[s]$就表示为当前子集$s$最右端的数

当$f[s] == m + 1$ 那么这个就是无解的

否则有解

如何传递呢 

预处理出来一个$g[i][j]$数组 表示第$i - 1$个位置后面$“a” + j - 1$的位置

那么$f[s] = max(f[s], g[f[s $^$ (1 << j)]][j])$

为什么取$max$ 是因为如果$f[s$^$(1 << j)] == m + 1$的话 那么这个数列就不是一个阶乘字符串

最后即判断$f[(1 << n) - 1] == m + 1$ 如果是那么序列就不是阶乘字符串

否则就是阶乘字符串

## code
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

inline ll read() {
    ll f = 1, x = 0;char ch;
    do {ch = getchar();if (ch == '-')f = -1;} while (ch > '9' || ch < '0');
    do {x = x * 10 + ch - '0';ch = getchar();} while (ch >= '0' && ch <= '9');
    return f * x;
}

const int MAX_N = 20 + 5;

const int MAX_S = (1 << 21) + 5;

const int MAX_L = 450 + 5;

int T, n, f[MAX_S], g[MAX_L][MAX_L];

char s[MAX_L];

int main() {
	T = read();
	while (T -- ) {
		n = read();
		scanf("%s", s + 1);
		if (n > 21) {
			puts("NO");
			continue;
		}
		memset(f, 0, sizeof(f));
		int m = strlen(s + 1);
		for (int i = 0; i < n; i ++ ) g[m][i] = g[m + 1][i] = m + 1;
		for (int i = m; i >= 1; i -- ) {
			for (int j = 0; j < n; j ++ ) g[i - 1][j] = g[i][j];//直接继承左边的
			g[i - 1][s[i] - 'a'] = i;//更新
		}
		for (int i = 0; i < (1 << n); i ++ ) {
			for (int j = 0; j < n; j ++ ) {
				if (i & (1 << j)) 
					f[i] = max(f[i], g[f[i ^ (1 << j)]][j]);
			}
		}
		if (f[(1 << n) - 1] != m + 1) puts("YES");
		else puts("NO");
	}
	return 0;
}

```

---

## 作者：LiuQJun_1119 (赞：1)

经过我自己手玩一下，发现字符串 $S$ 的长度至少要是 $n(n-1)+1$ 才有可能有解。可是数据范围告诉我们字符串 $S$ 的长度最多为 `450`，也就是说 $n>21$ 时一定无解。

那么这个数据范围就可以进行状压 DP 了。

## DP

设 $s$ 是个二进制数，它第 $i$ 位代表第 $i$ 个字母取不取

如：`101` 代表 `ac`，`111` 代表 `abc`。

这样，$s$ 就能表示一个字符串了。

设 $f_s$ 为满足 $s$ 表示的字符串的全排列都在字符串 $S$ 的前缀的子序列的最小长度。

$nxt_{i,j}$ 代表在字符串 $S$ 中第 $i$ 个位置后第一次出现字符 $j$ 的下标。

那么就很好转移了：$f_{s|2^i}=\max(f_{s|2^i},nxt_{f_s,i})$。

## Code
```cpp
#include<bits/stdc++.h>
#define max(a,b) (a>b)?a:b

const int N=450,INF=2147483647;

int n,T,len,nxt[N+5][26+5],f[(1<<21)+1];
char str[N+5];

bool check(){
	int m=strlen(str+1);
	for(int i=0;i<n;i++) nxt[m][i]=INF;
	for(int i=m;i;i--){
		for(int j=0;j<n;j++) nxt[i-1][j]=nxt[i][j];
		nxt[i-1][str[i]-'a']=i;
	}
	for(int i=0;i<(1<<n);i++) f[i]=0;
	bool flag=false;
	for(int s=0;s<(1<<n);s++){
		if(f[s]==INF) return false;
		for(int i=0;i<n;i++) if(!(s&(1<<i))) f[s|(1<<i)]=max(f[s|(1<<i)],nxt[f[s]][i]);
	}
	return f[(1<<n)]!=INF;
}

int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%s",&n,str+1);
		if(n>21){
			printf("NO\n");
			continue;
		}
		if(check()) printf("YES\n");
		else printf("NO\n");
	}
}
```

---

## 作者：Gmt丶FFF (赞：1)

由于一些不可抗拒的原因，$n\ge 22$ 无解。

那么只用考虑 $n\le21$ 的情况即可。

由于 $n$ 的范围缩小，导致状压又可以重新使用，所以考虑状压。

设 $f_i$ 为 $i$ 中所有的集合能被表示的最小下标。

那么对于任何一位 $j$ 如果在 $i$ 中，那么：

$f_i=\max(next(f_{i\oplus j},j))\hspace{0.2cm}\text{其中}\hspace{0.1cm}next(x,y)\hspace{0.1cm}\text{表示第一个在}\hspace{0.1cm}x\hspace{0.1cm}\text{后面出现的字符}\hspace{0.1cm} y\hspace{0.1cm}\text{的下标}$

因为本集合中的所有情况都得满足，所以下标得取最大值。

那么我们只需预处理出来 $next$ 即可。

从后往前枚举，本位的 $next$ 可以由上位继承，也要取上一位，设字符串中 $s_{i+1}$ 为 $c$ 那么：

$next_{i,j}=next_{i+1,j}$

$next_{i,c}=i+1$

预处理出来，然后状压 dp，dp 时对每个状态枚举 $1$ 的位置即可。

详细看代码。

希望有大佬可以指明下为何 $n\ge22$ 无解。

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
char s[505];
int n,vis[505][26],f[1<<21];
int main()
{
	freopen("factorial.in","r",stdin);
	freopen("factorial.out","w",stdout);
	int T;
	scanf("%d",&T);
	while(T--)
	{
		memset(vis,0,sizeof(vis));
		memset(f,0,sizeof(f));
		scanf("%d",&n);
		scanf("%s",s+1);
		if(n>21)
		{
			printf("NO\n");
			continue;
		}
		int len=strlen(s+1);
		for(int i=0;i<n;i++)vis[len][i]=vis[len+1][i]=len+1;
		for(int i=len-1;i>=0;i--)
		{
			for(int j=0;j<n;j++)vis[i][j]=vis[i+1][j];
			vis[i][s[i+1]-'a']=i+1;
		}
		for(int i=0;i<1<<n;i++)
		{
			for(int j=0;j<n;j++)
			{
				if(i&(1<<j))
				{
					f[i]=max(f[i],vis[f[i^(1<<j)]][j]);
				}
			}
		}
		if(f[(1<<n)-1]!=len+1)printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
```

---

## 作者：zhouzhuan (赞：1)

本题为状态压缩dp题：

f[S]表示当前的集合为S时满足阶乘字符串时的最后一个字母的位置。

g[i][j]表示以i+1开始的第一个j字母出现的位置。

然后枚举子集转移，最后判断一下是否满足f[(1<<n)−1]≤m 即可，本题解决。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[2500005],g[555][25],n,T,m,w;
char s[555];
int main()
{
    scanf("%d", &T);
    while(T--)
    {
        scanf("%d%s", &n, s+1);
        if(n > 21)
        {
            puts("NO");
            continue;
        }
        m = strlen(s + 1);
        w = 1<<n;
        for(int i = 1; i < w; i++) f[i]=0;
        for(int i = 0; i < n; i++) g[m][i] = g[m + 1][i] = m + 1;
        for(int i = m; i; i--)
        {
            for(int j = 0; j < n; j++)g[i - 1][j] = g[i][j];
            g[i - 1][s[i] - 'a'] = i;
        }
        for(int i = 1 ; i < w; i++)
            for(int j = 0 ; j < n; j++)
                if((1<<j) & i) f[i]=max(f[i],g[f[i^(1<<j)]][j]);
        if(f[w-1] != m+1) puts("YES");
        else puts("NO");
    }
    return 0;
}
```

---

## 作者：ZXZ_ (赞：0)



注意当 `n>21` 时无解（即输出 `NO`）

`f[S]` 表示当前的字母集合为 `S` 时满足阶乘字符串时的最后一个字母的位置。

`nxt[i][j]` 表示以 `i+1` 开始的第一个 `j` 字母出现的位置。

所以转移为 

```cpp
f[S+(1<<i)]=max(f[S+(1<<i)],nxt[f[S]][i])
```

最后判断 `f` 是否满足条件即可，代码如下：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int N=(1<<21)+1,INF=2147483647;
char s[460];
int T,n,f[N],nxt[460][27];
bool check(){
	scanf("%d%s",&n,s+1);
	if(n>21)return false;
	int len=strlen(s+1);
	for(int i=0;i<n;i++)
		nxt[len][i]=INF;
	for(int i=len;i>=1;i--){
		for(int j=0;j<n;j++)
			nxt[i-1][j]=nxt[i][j];
		nxt[i-1][s[i]-'a']=i;
	}
	for(int i=0;i<(1<<n);i++)
		f[i]=0;
	for(int S=0;S<(1<<n);S++){
		if(f[S]==INF)return 0;
		for(int i=0;i<n;i++)
			if(!(S&(1<<i)))
				f[S+(1<<i)]=max(f[S+(1<<i)],nxt[f[S]][i]);
	}
	return f[(1<<n)-1]!=INF;
}
int main(){
	scanf("%d",&T);
	while(T--){
		if(!check())printf("NO\n");
		else printf("YES\n");	
	}
}
```

---


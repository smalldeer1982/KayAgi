# [SHOI2008] 循环的债务

## 题目描述

Alice、Bob 和 Cynthia 总是为他们之间混乱的债务而烦恼，终于有一天，他们决定坐下来一起解决这个问题。不过，鉴别钞票的真伪是一件很麻烦的事情，于是他们决定要在清还债务的时候尽可能少的交换现金。

比如说，Alice 欠 Bob $10$ 元，而 Cynthia 和他俩互不相欠。现在假设 Alice 只有一张 $50$ 元，Bob 有 3 张 $10$ 元和 10 张 $1$ 元，Cynthia有 3 张 $20$ 元。一种比较直接的做法是：Alice 将 $50$ 元交给 Bob，而 Bob 将他身上的钱找给 Alice，这样一共就会有 14 张钞票被交换。但这不是最好的做法，最好的做法是：Alice 把 $50$ 块给 Cynthia，Cynthia 再把两张 $20$ 给 Alice，另一张 %|$20$ 给 Bob，而 Bob 把一张 $10$ 块给 Cynthia，此时只有 5 张钞票被交换过。

没过多久他们就发现这是一个很棘手的问题，于是他们找到了精通数学的你为他们解决这个难题。

## 说明/提示

对于 $30\%$ 的数据，$x_1, x_2, x_3 \le 50$。

对于 $100\%$ 的数据，$x_1, x_2, x_3 \le 1,000$。

## 样例 #1

### 输入

```
10 0 0
0 1 0 0 0 0
0 0 0 3 0 10
0 0 3 0 0 0```

### 输出

```
5```

## 样例 #2

### 输入

```
-10 -10 -10
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0```

### 输出

```
0```

# 题解

## 作者：D_14134 (赞：18)

### 恶心的dp

我们考虑这个问题其实就是一开始A,B,C分别有sa,sb,sc的钱，总共n元，经过一波py，目标状态的A,B,C分别有ea,eb,ec的钱。问最少需要交换几张钱。 

我们一种面额一种面额的考虑，显然不同面额之间互不影响.（而且你考虑的顺序其实可以是任意的，所以你可以按照张数从小到大来做。） 

我们考虑dp，f[k][i][j]，表示考虑前k种面额，A现在有i元，B现在有j元最少需要交换几张。

(显然此时C有n-i-j元，不用记录这一维状态)我们现在考虑第k+1种面额，枚举py之后A有a张，B有b张，c有tot-a-b张，能转移到的状态可以直接计算，交换张数也可以直接计算。

# code

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define maxn 1050
#define maxm 10
using namespace std;
int X1,X2,X3,tot,cnt[maxm],sum[maxn];
int num[maxm][maxm],val[maxm]={0,100,50,20,10,5,1};
int f[maxm][maxn][maxn],inf,ans;
int main(){
	scanf("%d%d%d",&X1,&X2,&X3);
	for(int i=1;i<=3;i++){
		for(int j=1;j<=6;j++){
			scanf("%d",&num[i][j]);
			sum[i]+=num[i][j]*val[j];
			tot+=num[i][j]*val[j];
			cnt[j]+=num[i][j];
		}
	}
	memset(f,127,sizeof(f));
	f[0][sum[1]][sum[2]]=0;inf=ans=f[1][1][1];
	for(int i=1;i<=6;i++) for(int j=0;j<=tot;j++) for(int k=0;k+j<=tot;k++)
		if(f[i-1][j][k]!=inf) {for(int x1=0;x1<=cnt[i];x1++)
			for(int x2=0;x1+x2<=cnt[i];x2++){
				int now1=j-(num[1][i]-x1)*val[i];
				int now2=k-(num[2][i]-x2)*val[i];
				int x3=cnt[i]-x1-x2;
				if(now1>=0&&now2>=0&&now1+now2<=tot){
					int w=abs(num[1][i]-x1)+abs(num[2][i]-x2)+abs(num[3][i]-x3);
					f[i][now1][now2]=min(f[i][now1][now2],f[i-1][j][k]+(w>>1));
				}
			}
		}
	int S1=sum[1]-X1+X3,S2=sum[2]-X2+X1,S3=sum[3]-X3+X2;
	for(int i=0;i<=6;i++)ans=min(ans,f[i][S1][S2]);
	if(S1<0||S2<0||S3<0||ans==inf)printf("impossible");
	else printf("%d",ans);
	return 0;
}
```

---

## 作者：William_Wang_ (赞：13)


### [CSDN link](https://blog.csdn.net/weixin_73113801/article/details/130792512)

[题目](https://www.luogu.com.cn/problem/P4026)

转换问题：所有人把钱放在桌上，每个人拿走自己所需的钱。

- 每个人并不需要重复的把相同钞票放在桌子上再拿回来，因此对于第 $i$ 种钞票，假设 Alice 初始有 $x$ 张，结束有 $x'$ 张，Alice 只需拿或者放 $|x'-x|$ 张。

- 对于第 $i$ 钞票，人与人之间的交换次数等于拿放次数和的一半，比如 Alice 放 $x$ 张，Bob 拿 $x$ 张，被视为交换 $x$ 张。

- 钱的总和不会变。

问题已经相当简单了，考虑搜索：前 $i$ 种钞票，三个人各拿了 $A,B,C$ 元：

 ```cpp
 int dfs(int i, int A, int B, int C)
{
	if(A > sa or B > sb or C > sc) return 1e9;
	// i = 6 时，A <= sa，B <= sb，C <= sc 而 A+B+C = sa+sb+sc 说明 A=sa，B=sb，C=sc，即最终状态
	if(i == 6) return 0;
	
	int res = 1e9;
	// 对于第 i 种钞票，A 拿走 j 张，B 拿走 k 张，C 拿走剩下的
	for(int j=0; j <= a[i]+b[i]+c[i]; j++)
		for(int k=0; j + k <= a[i]+b[i]+c[i]; k++)
		{
			res = min(res, dfs(i+1, A+j*w[i], B+k*w[i], C+(a[i]+b[i]+c[i]-j-k)*w[i]) + abs(j-a[i])+abs(k-b[i])+abs(a[i]+b[i]-j-k) );
		}
	return res;
}

int main()
{
	cin >> x1 >> x2 >> x3;
	
	for(int i=0; i<6; i++) cin >> a[i], sa += a[i] * w[i];
	for(int i=0; i<6; i++) cin >> b[i], sb += b[i] * w[i];
	for(int i=0; i<6; i++) cin >> c[i], sc += c[i] * w[i];
	
	sa = sa - x1 + x3, sb = sb - x2 + x1, sc = sc - x3 + x2;
	
	int ans = dfs(0, 0, 0, 0);
	
	if(ans < 1e9) cout << ans / 2;
	else cout << "impossible"; 
}
 ```

根据钱的总和不变，当 $A,B$ 固定时，$C$ 也是固定的，因此状态数至多为 $6 \times 1000 \times 1000$ ，考虑记忆化搜索。

### [code](https://www.luogu.com.cn/paste/47rpbnii)

---

## 作者：foreverlasting (赞：13)

难度标签是有毒吗

然后切入正题。

这题一看就是一道DP题（一般来说这种感觉应该非常明显了），然后开始考虑DP式。DP式~~随便就能想粗来~~超级难想。

常理，DP式应该是阶段+条件+结果，这题的结果显然是最少的方案转移次数，然后考虑阶段和条件。发现首先在每一次转移钱的时候，总钱的和是不变的。（好像没什么用）然后发现每一次转移钱的时候，大家自己手上的钱会变。如果阶段是钞票数量，显然不可能。所以阶段也只能转移钱的种类了，那么条件也很清楚地就出来了，显然就是当前状态下大家各自拥有的钱。因为拥有钱不超过1000，而1000的三次方好像爆空间，所以就想起了开始的总钱和不变这个事实。那么DP式就出来了：

dp[i][j][k]表示前i种钞票的价值（100~...），第一个人现在有j元，第二个人现在有k元的最小转移数目，而第三个人的钱就是总和减去j和k

那么状态转移方程也就轻而易举出来了（其实本质是背包问题），枚举当前第一个人和第二个人所拥有的钱，再枚举转移几张钞票，那就ok了。

code：
```
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
inline int read() {
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') {
        if(ch=='-')w=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return s*w;
}
inline void write(res x) {
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const int X=1e3+10,Mo[10]= {0,100,50,20,10,5,1};
int dp[10][X][X];//dp[i][j][k]表示前i种钞票的价值（100~...），第一个人现在有j元，第二个人现在有k元的最小转移数目
int x1,x2,x3,A[10][10],tot[10],cnt[10];
int main() {
    x1=read(),x2=read(),x3=read();
    for(res i=1; i<=3; i++)
        for(res j=1; j<=6; j++) {
            A[i][j]=read();
            tot[i]+=A[i][j]*Mo[j];
            cnt[j]+=A[i][j];
        }
    //for(res i=1;i<=3;i++)printf("%d ",tot[i]);
    tot[0]=tot[1]+tot[2]+tot[3];
    memset(dp,inf,sizeof(dp));
    dp[0][tot[1]][tot[2]]=0;
    for(res i=1; i<=6; i++)
        for(res j=0; j<=tot[0]; j++)
            for(res k=0; k+j<=tot[0]; k++)
                if(dp[i-1][j][k]!=inf) {
                    dp[i][j][k]=min(dp[i][j][k],dp[i-1][j][k]);
                    for(res pos1=0; pos1<=cnt[i]; pos1++)
                        for(res pos2=0; pos1+pos2<=cnt[i]; pos2++) {
                            res sum1=j+(pos1-A[1][i])*Mo[i],sum2=k+(pos2-A[2][i])*Mo[i];
                            if(sum1<0||sum2<0||sum1+sum2>tot[0])continue;
                            dp[i][sum1][sum2]=min(dp[i][sum1][sum2],dp[i-1][j][k]+(abs(pos1-A[1][i])+abs(pos2-A[2][i])+abs(cnt[i]-pos1-pos2-A[3][i]))/2);
                        }
                }
    res sum1=tot[1]+x3-x1,sum2=tot[2]+x1-x2,sum3=tot[3]+x2-x3;
    if(sum1<0||sum2<0||sum3<0||dp[6][sum1][sum2]==inf)puts("impossible");
    else write(dp[6][sum1][sum2]);
    return 0;
}
```

---

## 作者：Yansuan_HCl (赞：5)

提供一种 BFS 做法。

题目中的“欠债关系”比较难以理解，考虑转化。观察到所有人**最后拥有的金额**就是原来拥有的金额再**减去（还完）自己欠的钱、加上（收完）别人欠自己的钱**。

于是可以模拟钱的转移的操作进行 BFS.

直接搜过于暴力，需要剪枝。记录到达状态 *Bob 拥有 $x$ 元，Cynthia 拥有 $y$ 元* 时的最小交换次数（此时 Alice 的金额显然是 $tot-x-y$ 元）。这样，每种状态只会被搜到一次，时间复杂度为 $\mathcal{O}(N^2)$。

[代码](https://www.luogu.com.cn/paste/9pr34g5y)

---

## 作者：RedreamMer (赞：3)

萌新不会 DP 捏，只会暴力 DFS。

可能是数据水了，目前最优解第一 130ms，没有卡常。

## 思路

发现题目约束三人总面值之和不会超过 1000 元，并且对每人小于 10 元的货币个数进行了约束，所以毛咕咕 1 元的货币的个数比较多。

因为我们大力 DFS，枚举每个人最终最优情况中每种面值大于 1 元的货币的个数，最后判断可行性并用 1 元的货币调平。

对于每种货币之间的交换，因为互相独立，对于原来一种货币三人分别有 $a0,b0,c0$ 个，最终每人分别有 $a1,b1,c1$ 个，最优交换次数一定是 $\frac{|a0 - a1| + |b0 - b1| + |c0 - c1|} {2}$，贪心容易证明。

然后就做完了，记得 DFS 加点可行性和最优性剪枝。

## 代码

```cpp
int a, b, c, s[3], p[3][6], q[3][6], mx[6], t[3], o[6] = {100, 50, 20, 10, 5, 1}, ans = inf;

int calc() {
	int tmp = 0;
	rep(i, 0, 2) {
		t[i] = s[i];
		rep(j, 0, 4) t[i] += o[j] * (p[i][j] - q[i][j]);
		if(t[i] < 0 && abs(t[i]) > p[i][5]) return inf;
		tmp += abs(t[i]);
	}
	return tmp / 2;
}

int upd(int n) {
	return (abs(p[0][n] - q[0][n]) + abs(p[1][n] - q[1][n]) + abs(p[2][n] - q[2][n])) / 2;
}

void dfs(int n, int now) {
	if(now >= ans) return;
	if(n == 5) {
		ans = min(ans, now + calc());
		return;
	}
	rep(i, 0, mx[n]) rep(j, 0, mx[n] - i) {
		q[0][n] = i, q[1][n] = j, q[2][n] = mx[n] - i - j;
		dfs(n + 1, now + upd(n));
	}
}

signed main() {
	// freopen("in1.in", "r", stdin);
	a = read();
	b = read();
	c = read();
	s[0] = -a + c;
	s[1] = -b + a;
	s[2] = -c + b;
	rep(i, 0, 2) rep(j, 0, 5) p[i][j] = read(), mx[j] += p[i][j];
	dfs(0, 0);
	if(ans == inf) cout << "impossible";
	else cout << ans;
	return 0;
}
```

---

## 作者：saixingzhe (赞：2)

# 分析
首先我们可以进行题意转化，我们假设三个人先把自己所有的钱拿出来放在一张桌上，然后第一个人和第二个人在上面选钱，剩下的就是第三个人的。

很明显每人最后的钱数可以算出，所有我们设计 dp，$f_{i,j,k}$ 表示算到第 $i$ 种面值，第一个人有 $j$ 元钱，第二个人有 $k$ 元钱的最小交换数。

转移时枚举此种面值给第一个人的钱数和给第二个人的钱数，并可以计算出需要的交换数量，转移即可。

看起来复杂度很高，其实进行一些减枝去掉不存在的情况跑很飞快，足以通过。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[10][1005][1005],x1,x2,x3,s[7]={0,100,50,20,10,5,1},a[4][7],na,nb,nc;
int main(){
	memset(f,0x3f,sizeof(f));
	scanf("%d%d%d",&x1,&x2,&x3);
	for(int i=1;i<=3;i++)
		for(int j=1;j<=6;j++)	scanf("%d",&a[i][j]);
	for(int i=1;i<=6;i++)	na+=a[1][i]*s[i];
	for(int i=1;i<=6;i++)	nb+=a[2][i]*s[i];
	for(int i=1;i<=6;i++)	nc+=a[3][i]*s[i];
	na+=x3-x1;
	nb+=x1-x2;
	nc+=x2-x3;
	f[0][0][0]=0;
	for(int i=1;i<=6;i++)
	for(int j=0;j<=na;j++)
	for(int k=0;k<=nb;k++)
	for(int p=0;p<=a[1][i]+a[2][i]+a[3][i];p++)
	for(int q=0;q+p<=a[1][i]+a[2][i]+a[3][i];q++){
		if(j<p*s[i]||k<q*s[i])	continue;
		f[i][j][k]=min(f[i][j][k],f[i-1][j-p*s[i]][k-q*s[i]]+(abs(a[1][i]-p)+abs(a[2][i]-q)+abs(a[1][i]+a[2][i]-p-q))/2); 
	}
	if(f[6][na][nb]>1000000000)	printf("impossible"); 
	else	printf("%d",f[6][na][nb]);
    return 0;
}
```

---

## 作者：luobo215 (赞：2)

### 题目

[P4026](https://www.luogu.com.cn/problem/P4026)

读完这道题我人都被绕进去了，研究了好长时间才找到思路 qwq，研究懂了之后发现还可以。

### 思路

转化问题：与其让三个人还来还去，不如考虑把三个人所有的钱先放在一起，再让 A 拿走 A 应得的，B 拿走 B 应得的，剩下的的钱保证就是 C 应得的，此时交换次数变成了拿放次数和的一半。

> 例子：A 从桌子上放一张，B 拿起，相当于 A 交给 B。

再考虑 A 应得的由哪几部分组成：

记 $sum_a$ 为 A 所原有的钱数，$now_a$ 为 A 现有的钱数。A 现有的应该是原先的减去欠别人的加上别人欠他的。所以：

A:
$$
now_a = sum_a - x_1 + x_3
$$

B:

$$
now_b = sum_b - x_2 + x_1
$$

C:

$$
now_c = sum_c - x_3 + x_2
$$

现在问题就变成了：一共有一些钱，A 要 $now_a$，B 要 $now_b$，C 取走剩下的，求最少拿取次数。

这是不是就像背包了呢 qwq。

定义 $dp[i][x][y]$ 为前 $i$ 种货币，$a$ 取走 $x$，$b$ 取走 $y$ 的最小拿取次数。

转移方程就显然了：

$$
dp[i][x][y] =
\min(dp[i - 1][x - p \times v[i]][y - q \times v[i]]) + C
$$

其中，$C = |p - a_i| + |q - b_i| + |p + q - a_i - b_i|$。

边界条件：

$$
0 \leq p \leq s_i, 0 \leq q \leq s_i - p
$$

$s_i$ 表示第 $i$ 种钱总张数。

边界 $dp[0][0][0] = 0$。

结果 $dp[6][now_a][now_b]$（别忘除 2）。

实测吸氧能过（逃）。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;
using db = double;
using ldb = long double;
using pii = pair<int,int>;
#define CI const int
#define mp make_pair
CI maxn=1005;
CI inf=1e9;
int dp[7][maxn][maxn];
int v[10]={0,100,50,20,10,5,1};
int suma,sumb,sumc,ab,bc,ca;
int a[10],b[10],c[10],s[10];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>ab>>bc>>ca;
    for(int i=1;i<=6;i++)cin>>a[i],suma+=a[i]*v[i];
    for(int i=1;i<=6;i++)cin>>b[i],sumb+=b[i]*v[i];
    for(int i=1;i<=6;i++)cin>>c[i],sumc+=c[i]*v[i];
    for(int i=1;i<=6;i++)s[i]=a[i]+b[i]+c[i];
    suma+=ca-ab,sumb+=ab-bc,sumc+=bc-ca;
    memset(dp,0x3f,sizeof(dp));
    dp[0][0][0]=0;
    for(int i=1;i<=6;i++)
        for(int x=suma;x>=0;x--)
            for(int y=sumb;y>=0;y--)
            {
                for(int p=0;p<=s[i];p++)
                if(x-p*v[i]>=0)
                for(int q=0;q<=s[i]-p;q++)
                if(y-q*v[i]>=0)
                {
                    dp[i][x][y]=min(dp[i][x][y],dp[i-1][x-p*v[i]][y-q*v[i]]+abs(p-a[i])+abs(q-b[i])+abs(p+q-a[i]-b[i]));
                }
            }
    if(dp[6][suma][sumb]==0x3f3f3f3f)cout<<"impossible";
    else cout<<dp[6][suma][sumb]/2;
    return 0;
}

```

当然可以滚动数组。

但是有一篇题解的滚动数组是错误的[证明](https://www.luogu.com.cn/discuss/500103)，感谢 qwq。

滚动数组

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;
using db = double;
using ldb = long double;
using pii = pair<int, int>;
#define CI const int
#define mp make_pair
CI maxn=1005;
CI inf=1e9;
int dp[2][maxn][maxn];
int v[10]={0,100,50,20,10,5,1};
int suma,sumb,sumc,ab,bc,ca;
int a[10],b[10],c[10],s[10];
int pre=1,now=0;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>ab>>bc>>ca;
    for(int i=1;i<=6;i++)cin>>a[i],suma+=a[i]*v[i];
    for(int i=1;i<=6;i++)cin>>b[i],sumb+=b[i]*v[i];
    for(int i=1;i<=6;i++)cin>>c[i],sumc+=c[i]*v[i];
    for(int i=1;i<=6;i++)s[i]=a[i]+b[i]+c[i];
    suma+=ca-ab,sumb+=ab-bc,sumc+=bc-ca;
    memset(dp,0x3f,sizeof(dp));
    dp[0][0][0]=0;
    for(int i=1;i<=6;i++)
    {
        swap(now,pre);
        memset(dp[now],0x3f,sizeof(dp[now]));
        for(int x=suma;x>=0;x--)
            for(int y=sumb;y>=0;y--)
            {
                for(int p=0;p<=s[i];p++)
                if(x-p*v[i]>=0)
                for(int q=0;q<=s[i]-p;q++)
                if(y-q*v[i]>=0)
                {
                    dp[now][x][y]=min(dp[now][x][y],dp[pre][x-p*v[i]][y-q*v[i]]+abs(p-a[i])+abs(q-b[i])+abs(p+q-a[i]-b[i]));
                }
            }
    }
    if(dp[now][suma][sumb]==0x3f3f3f3f)cout<<"impossible";
    else cout<<dp[now][suma][sumb]/2;
    return 0;
}
```

第一篇题解（审核大大求过）。

> I'm so vegetable QAQ。

---

## 作者：Yang818 (赞：2)

## 题目
[传送门](https://www.luogu.com.cn/problem/P4026)

## 分析
~~一道极其诡异的题目~~

我们千万不要被题目所迷惑，去考虑要循环地还钱。要重新理解一下怎样还钱。

第一步：ABC 三人把所有的钱掏出来，放在桌子上

第二步：AB 拿走他们应该拿走的钱，剩下的就是 C 该拿走的钱

所谓的交换代价，就是指原本的钱减去拿走的钱的绝对值。怎么理解？

假设 A 原本有 $old_a$ 元钱，那么

$old_a = 100\times a_{100}+50\times a_{50}+20\times a_{20}+10\times a_{10}+5\times a_{5}+1 \times a_{1}$

其中 $a_n$ 表示面额为 $n$ 的纸币 A 有多少张。

设 A 应该拿走 $new_a$ 元钱，那么

$new_a=old_a-x_1+x_3$

同理：

$new_b=old_b-x_2+x_1$

$new_c=old_c-x_3+x_2$

问题就转化为了：求六种货币，能够取两个集合，$sum_1=new_a\ sum_2=new_b$ ($sum-sum_1-sum_2=new_c$)

好了，来玩背包吧

## 背包

设 $f_{i,x,y}$ 表示考虑前 $i$ 种货币，构造 $a$ 拿走 $x$ 元，$b$ 拿走 $y$ 元的最小交换次数

令 $table_i=a_i+b_i+c_i$  
  $v_{1...6}={100,50,20,10,5,1}$
  
$$f_{i,x,y}=\min_{0 \leq p \leq table_i\ 0 \leq q \leq table_i-p}{f_{(i-1)(x-p \times v_i)(y-q \times v_i)}}+|p-a_i|+|q-b_i|+|num_i-p-q-c_i|$$

最后答案就是 $f_{6,new_a,new_b}$

有人说这个会 $TLE$ ，其实是不会的，因为数组的第一维可以滚动数组滚掉。大小就是 $1\times 10^{6}$。就算不要滚动数组，吸个氧也过了。


## 代码
方程都列的这么详细了，代码还需要吗？
```cpp
#include<iostream>
#include<cstring>
#include<cmath>

using namespace std;
int f[1001][1001]; 
int main()
{
  int ab, bc, ca;
  cin >> ab >> bc >> ca;
  int a[7], b[7], c[7], num[7];
  int v[] = {0,100,50,20,10,5,1};
  int Ta = 0, Tb = 0, Tc = 0; 
  for (int i = 1; i <= 6; ++i) cin >> a[i], Ta += a[i]*v[i];
  for (int i = 1; i <= 6; ++i) cin >> b[i], Tb += b[i]*v[i];
  for (int i = 1; i <= 6; ++i) cin >> c[i], Tc += c[i]*v[i];
  for (int i = 1; i <= 6; ++i) num[i] = a[i] + b[i] + c[i];
  Ta += ca - ab;
  Tb += ab - bc;
  Tc += bc - ca;
  memset(f, 0x3f, sizeof (f));
  f[0][0]= 0;
  for (int i = 1; i <= 6; ++i) {
  	for (int x = Ta; x >= 0; x--)
	   for (int y = Tb; y >= 0; y--)
	     {
	       // to calc f[i,x,y];
	       for (int p = 0; p <= num[i]; ++p) if (x-p*v[i] >= 0){
		     for (int q = 0; p+q <= num[i]; ++q)  if (y-q*v[i]>=0){
		     	int tmp = f[x-p*v[i]][y-q*v[i]] 
				        + abs(p-a[i])+abs(q-b[i])+abs(p+q-a[i]-b[i]);
		     	if (f[x][y] > tmp)
		     	  f[x][y] = tmp;
			 }
			}
		 } 
  }
  if(f[Ta][Tb]<1000000000) 
  cout << f[Ta][Tb] / 2;	
  else
  cout << "impossible";	
} 
```

望通过，谢谢




---

## 作者：GreenDay (赞：1)

本蒟蒻的方法和众位巨佬的方法不太一样。

设$dp_{i,j}$表示A还剩多少钱，b还剩多少钱，需要转移多少次， $need_i$表示每个人需要（得/失）多少钱

对于每一种钞票，分6类讨论：

1. 在A手里：A->B , A->C
2. 在B手里：B->A , B->C
3. 在C手里：C->A , C->B

然后愉快的进行转移，~~只能得70分，WA了3个点~~

（请勿复制）

```cpp
#include <bits/stdc++.h> 
using namespace std;

const int N = 1010; 

int dp[N][N];
//表示A得失情况为i，B得失情况为j的情况 
const int w[6] = {100 , 50 , 20 , 10 , 5 , 1};

int sum[3] , tot;
int need[3];
int num[3][6];
int MaxOut[3] , MaxIn[3]; 

void No()
{
	puts("impossible");
	exit(0);
}

int main()
{
	cin >> sum[0] >> sum[1] >> sum[2];
	need[0] = sum[2] - sum[0];
	need[1] = sum[0] - sum[1];
	need[2] = sum[1] - sum[2];
	sum[0] = sum[1] = sum[2] = 0;
	for(int i = 0 ; i < 3 ; i ++)
	{
		for(int j = 0 ; j < 6 ; j ++)
		{
			cin >> num[i][j];
			sum[i] += num[i][j] * w[j];
		}
		tot += sum[i];
	}
	for(int i = 0 ; i < 3 ; i ++)
	{
		MaxOut[i] = sum[i];
		MaxIn[i] = tot - sum[i];
		if(need[i] < 0 && MaxOut[i] < -need[i])
			No();
		else if(need[i] > 0 && MaxIn[i] < need[i])
			No();
	}
	memset(dp , 63 , sizeof(dp));
	dp[MaxOut[0]][MaxOut[1]] = 0;

// 先转移A的钞票
	for(int i = 0 ; i < 6 ; i ++)
	{
		int val = w[i];
		while(num[0][i]--)
		{		
			//A->B
			//A丢钞票 第一维正序
			//B得钞票 第二维倒序 
			for(int a = 0 ; a <= tot - val ; a ++)
				for(int b = tot ; b >= val ; b --)
					dp[a][b] = min(dp[a][b] , dp[a + val][b - val] + 1);
			
			//A->C
			//A丢钞票 第一维正序
			for(int a = 0 ; a <= tot - val ; a ++)
				for(int b = 0 ; b <= tot ; b ++)
					dp[a][b] = min(dp[a][b] , dp[a + val][b] + 1);
		}
		while(num[1][i]--)
		{
			//B->A
			//A得到钞票，倒序
			//B失去钞票，正序
			for(int a = tot ; a >= val ; a --)
				for(int b = 0 ; b <= tot - val ; b ++)
					dp[a][b] = min(dp[a][b] , dp[a - val][b + val] + 1); 
			
			//B->C
			//B失去钞票，正序
			for(int a = 0 ; a <= tot ; a ++)
				for(int b = 0 ; b <= tot - val ; b ++)
					dp[a][b] = min(dp[a][b] , dp[a][b + val] + 1); 
		}
		while(num[2][i]--)
		{
			//C->A
			//A得钞票，倒序
			for(int a = tot ; a >= val ; a --)
				for(int b = 0 ; b <= tot ; b ++)
					dp[a][b] = min(dp[a][b] , dp[a - val][b] + 1);
			
			//C->B
			//B得到钞票，倒序
			for(int a = 0 ; a <= tot ; a ++)
				for(int b = tot ; b >= val ; b --) 
					dp[a][b] = min(dp[a][b] , dp[a][b - val] + 1);
		}
	}
	if(dp[MaxOut[0] + need[0]][MaxOut[1] + need[1]] > 10000)
		No();
	else
		cout << dp[MaxOut[0] + need[0]][MaxOut[1] + need[1]] << endl;
}
```

为什么WA了呢？

经@CTime_Pup_314 巨佬指点，这个dp存在的问题是：

### 一张钞票能被转移多次！

在原先的dp方程中，一个点可以转移2次。也就是一张钞票能用2次。~~我的钱能这样花也好啊~~，答案会比标准答案小。

所以新开一个辅助数组last[][]表示上一层状态。**每一张钞票**进行一次memcpy，然后从dp[][]从last[][]转移。这样避免了一张钞票用2次的情况，也同时避免了对转移顺序的讨论。虽然仍然转移2次，但一张钞票只会被用1次。

我的代码在BZOJ上会TLE，luogu能过。。常数比较大，见谅。

```cpp
#include <bits/stdc++.h> 
using namespace std;

const int N = 1010; 

int dp[N][N] , last[N][N];
//表示A得失情况为i，B得失情况为j的情况 
const int w[6] = {100 , 50 , 20 , 10 , 5 , 1};

int sum[3] , tot;
int need[3];
int num[3][6];
int MaxOut[3] , MaxIn[3]; 

void No()
{
	puts("impossible");
	exit(0);
}

int main()
{
	cin >> sum[0] >> sum[1] >> sum[2];
	need[0] = sum[2] - sum[0];
	need[1] = sum[0] - sum[1];
	need[2] = sum[1] - sum[2];
	sum[0] = sum[1] = sum[2] = 0;
	for(int i = 0 ; i < 3 ; i ++)
	{
		for(int j = 0 ; j < 6 ; j ++)
		{
			cin >> num[i][j];
			sum[i] += num[i][j] * w[j];
		}
		tot += sum[i];
	}
	for(int i = 0 ; i < 3 ; i ++)
	{
		MaxOut[i] = sum[i];
		MaxIn[i] = tot - sum[i];
		if(need[i] < 0 && MaxOut[i] < -need[i])
			No();
		else if(need[i] > 0 && MaxIn[i] < need[i])
			No();
	}
	memset(dp , 63 , sizeof(dp));
	dp[MaxOut[0]][MaxOut[1]] = 0;

// 先转移A的钞票
	for(int i = 0 ; i < 6 ; i ++)
	{
		int val = w[i];
		while(num[0][i]--)
		{		
			//A->B
			//A丢钞票 第一维正序
			//B得钞票 第二维倒序
			memcpy(last , dp , sizeof(dp));
			for(int a = 0 ; a <= tot - val ; a ++)
				for(int b = tot ; b >= val ; b --)
					dp[a][b] = min(dp[a][b] , last[a + val][b - val] + 1);
			
			//A->C
			//A丢钞票 第一维正序
			for(int a = 0 ; a <= tot - val ; a ++)
				for(int b = 0 ; b <= tot ; b ++)
					dp[a][b] = min(dp[a][b] , last[a + val][b] + 1);
		}
		while(num[1][i]--)
		{
			//B->A
			//A得到钞票，倒序
			//B失去钞票，正序
			memcpy(last , dp , sizeof(dp));
			for(int a = tot ; a >= val ; a --)
				for(int b = 0 ; b <= tot - val ; b ++)
					dp[a][b] = min(dp[a][b] , last[a - val][b + val] + 1); 
			
			//B->C
			//B失去钞票，正序
			for(int a = 0 ; a <= tot ; a ++)
				for(int b = 0 ; b <= tot - val ; b ++)
					dp[a][b] = min(dp[a][b] , last[a][b + val] + 1); 
		}
		while(num[2][i]--)
		{
			//C->A
			//A得钞票，倒序
			memcpy(last , dp , sizeof(dp));
			for(int a = tot ; a >= val ; a --)
				for(int b = 0 ; b <= tot ; b ++)
					dp[a][b] = min(dp[a][b] , last[a - val][b] + 1);
			
			//C->B
			//B得到钞票，倒序
			for(int a = 0 ; a <= tot ; a ++)
				for(int b = tot ; b >= val ; b --) 
					dp[a][b] = min(dp[a][b] , last[a][b - val] + 1);
		}
	}
	if(dp[MaxOut[0] + need[0]][MaxOut[1] + need[1]] > 10000)
		No();
	else
		cout << dp[MaxOut[0] + need[0]][MaxOut[1] + need[1]] << endl;
}
```

---

## 作者：kyel (赞：1)

# 标签：DP，递归，（真）暴力枚举

楼下各位的暴力标签是假的，这个是**真的暴力**。权当提供一种思路。

令dp[i][j][k]表示让第i个人**同时拿出两笔**大小分别为j和k的钱所需要的最少钞票数。显然这个可以dp出来。

然后可以证明：记A欠B与C总共pay[0],B、C同理有pay[1]、pay[2]，那么当所有3个人都满足**给出的钱减去从别人那里收到的的钱等于对应的pay[]值**时，三人债款算清了。这一结论使得我们可以不必关注中间的交换顺序，只需关心最终每个人分别给了别人多少钱。

这个结论是比较显然的。非形式化的说，当某一人的**净收入等于另两人欠自己总债**时，这个人**借出去的所有的钱就收回来了**——不关心具体从谁处收了多少，毕竟拿到自己的钱就是了——而当三个人借出去的钱都从别人那里收回来了，就各自拿回自己借出去的钱了。

于是我们揣着dp数组开始枚举：先枚举A给了B多少，再枚举B给了A、C多少，再**计算**C给了B多少（**使得B能够恰好收回自己的钱**）并枚举给了A多少，最后计算得A要给C多少。这本质上是一个**顺序结构的流程**，但是由于涉及到的中间变量有些**多而且含义重叠**，可以考虑**递归实现**。

由于这个真的暴力，在递归的时候还需要加上一些杂七杂八的可行性剪枝才能不开O2地AC。。

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <algorithm>

inline void getmin(int& a, int b) { if (b < a) a = b; }

const int val[6] = { 100, 50, 20, 10, 5, 1 }, maxm(1123), inf(112345);
int have[3][6], dp[3][maxm][maxm], tot[3], cnt[3];//tot[i]为i的总钞票额，cnt[i]为i的钞票总张数 
bool ok[3][maxm];
int ab, bc, ca, m;//m为三人的总钞票额 
int pay[3];
int ans(inf);
void dfs(int now, int pa, int pb, int pc, int used, int start) {
	if (used >= ans) return;
	if (now == 0) {
		if (pa > pay[0] || pc < pay[2]) return;
		if (pa + (pc - pay[2]) != pay[0]) return;
		if (dp[now][start][pc - pay[2]] <= cnt[now]) {
			getmin(ans, used + dp[now][start][pc - pay[2]]);
		}
	} else if (now == 1) {
		for (int j(std::max(0, pay[1] - pb)); j <= tot[now]; ++j) {
			if (!ok[now][j]) continue;
			for (int g1(0), g2(j); g1 <= j; ++g1, --g2) {
				if (dp[now][g1][g2] <= cnt[now]) {
					dfs(2, pa - g1, pb + j, pc - g2, used + dp[now][g1][g2], start);
				}
			}
		}
	} else {
		if (pb < pay[1]) return;
		//由于已经枚举过了B给A、C多少钱，所以B接下来只能收钱不能给出；pb<pay[1]意味着B还需要给出更多的钱，则不可能为合法解了
		//上、下文有一些类似的语句同理。（其实由于枚举B时的循环限制，这句话应该没有什么用） 
		int g2(pb - pay[1]);
		if (!ok[now][g2]) return;
		for (int g1(tot[now] - g2); g1 >= 0; --g1) {
			if (pc + g1 + g2 < pay[2]) return;
			if (dp[now][g1][g2] <= cnt[now]) {
				dfs(0, pa - g1, pb - g2, pc + g1 + g2, used + dp[now][g1][g2], start);
			}
		}
	}
}
int main() {
	scanf("%d%d%d", &ab, &bc, &ca);
	pay[0] = ab - ca, pay[1] = bc - ab, pay[2] = ca - bc;
	for (int i(0); i != 3; ++i) for (int j(0); j != 6; ++j) {
		scanf("%d", &have[i][j]);
		m += have[i][j] * val[j], tot[i] += have[i][j] * val[j], cnt[i] += have[i][j];
	}
	for (int i(0); i != 3; ++i) for (int j(0); j <= m; ++j) for (int k(0); k <= m; ++k) dp[i][j][k] = inf;
	for (int i(0); i != 3; ++i) {//ok[i][j]表示第i个人有拿出单笔钱数额为j的合法方案 
		ok[i][0] = true;
		for (int j(0); j != 6; ++j) {
			for (int k(tot[i]); k != 0; --k) {
				for (int use(1); use <= have[i][j] && use * val[j] <= k; ++use) {
					ok[i][k] |= ok[i][k - use * val[j]];
				}
			}
		}
	}
	for (int i(0); i != 3; ++i) {//dp[i][j][k]含义如开头所述 
		dp[i][0][0] = 0;
		for (int j(0); j != 6; ++j) {
			for (int x(tot[i]); x >= 0; --x) {
				for (int y(tot[i] - x); y >= 0; --y) {
					for (int use(1); use <= have[i][j] && use * val[j] <= x + y; ++use) {
						for (int ua(0), ub(use); ua <= use && ua * val[j] <= x; ++ua, --ub) {
							if (ub * val[j] <= y) getmin(dp[i][x][y], dp[i][x - ua * val[j]][y - ub * val[j]] + use);
						}
					}
				}
			}
		}
	}
	for (int i(0); i <= tot[0]; ++i) {//枚举A给了B多少 
		if (ok[0][i]) dfs(1, i, -i, 0, 0, i);
	}
	if (ans > cnt[0] + cnt[1] + cnt[2]) printf("impossible\n");
	else printf("%d\n", ans);
	return 0;
}

```

---

## 作者：_Kenma_ (赞：0)

## 前言

需要脑子题。

推销博客：[here.](https://www.cnblogs.com/kenma)

## 思路分析

首先受到样例二的启发，如果我们决策这个交换纸币的过程也太困难了。所以需要换一种刻画方式。

考虑把所有纸币都放在桌子上，三个人再分配。代价就是分配之前和分配之后，每种面值的纸币的差。

这样就好 DP 了。

设 $f_{i,a,b}$ 表示前 $i$ 中面值的纸币，第一个人有 $a$ 元，第二个人有 $b$ 元。第三个人有多少钱可以计算出来。

每次转移时，枚举第一个人拿几张，第二个人拿几张，第三个人拿几张，背包一下就行。

复杂度不高，不想精细计算了。

## 代码实现


```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=1e9;
int x1,x2,x3,a[7],b[4][7],f[7][1001][1001],tot[7],num[7],sum[7],ans;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>x1>>x2>>x3;
	a[1]=100,a[2]=50,a[3]=20,a[4]=10,a[5]=5,a[6]=1;
	for(int i=1;i<=3;i++){
		for(int j=1;j<=6;j++){
			cin>>b[i][j];
			sum[i]+=b[i][j]*a[j];
			tot[j]+=b[i][j]*a[j];
			num[j]+=b[i][j];
		}
	}
	for(int i=1;i<=6;i++){
		tot[i]+=tot[i-1];
	}
	sum[1]+=x3-x1;
	sum[2]+=x1-x2;
	sum[3]+=x2-x3;
	if(sum[1]<0 || sum[2]<0 || sum[3]<0){
		cout<<"impossible";
		return 0;
	}
	memset(f,0x3f,sizeof(f));
	f[0][0][0]=0;
	for(int i=1;i<=6;i++){
		for(int a1=0;a1<=sum[1] && a1<=tot[i];a1++){
			for(int a2=0;a2<=sum[2] && a2<=tot[i] && a1+a2<=tot[i];a2++){
				int a3=tot[i]-a1-a2;
				if(a3<0 || a3>sum[3]) continue;
				for(int l1=0;l1<=num[i] && l1*a[i]<=a1;l1++){
					for(int l2=0;l2<=num[i] && l1+l2<=num[i] && l2*a[i]<=a2;l2++){
						int l3=num[i]-l1-l2;
						if(l3<0 && a3<l3*a[i]) continue;
						f[i][a1][a2]=min(f[i][a1][a2],f[i-1][a1-l1*a[i]][a2-l2*a[i]]+(abs(l1-b[1][i])+abs(l2-b[2][i])+abs(l3-b[3][i]))/2);
					}
				}
			}
		}
	}
	ans=f[6][sum[1]][sum[2]];
	if(ans>inf) cout<<"impossible";
	else cout<<ans;
	return 0;
}
```

---

## 作者：Kelvin2009 (赞：0)

这是一道记忆化搜索的动态规划。

首先需要注意到：无论怎么交换，三个人的现金总数是不变的。对于各种面值的纸币，三个人该种纸币数量的总和也是不变的。

枚举交换的纸币复杂度很大，而且不好维护。可以考虑枚举每种面值每人有多少张，由于总和不变，只用枚举两个人就可得三个的情况。再根据此刻各人手中该面值的张数可以与原张数比较得出该纸币被使出和被得到的次数，并记录所有面值被使出和被得到相加的总次数。

输出为交换次数。有人使出就必定有人得到，因此纸币的总使出次数等于总得到次数，交换次数为记录的总次数的一半。

考虑边界：由三人的原始资产与欠条，可知三人最后的资产。所以交换过程可以被转换为三人各得到一定数量的各面额纸币，使最终三人各自的总和为其最终资产。三人得到纸币的过程中，各人的资产不得超过其最终资产。

直接每次深度搜索一遍三人接下来获取的面额复杂度显然过大，考虑记忆化搜索。记录枚举到此面额，两个人已有资产总数即可（现有的总和知道，除去这两个人外就是第三个人现有的资产总数）。

------------
代码：

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
const int range=6;
const int tem_ran=1005;
const int lim=0x3f3f3f3f;
const int val[range]={100,50,20,10,5,1};
int x1,x2,x3,asum,bsum,csum,lstans,a[range],b[range],c[range],rec[range][tem_ran][tem_ran];
int dfs(int term,int atem,int btem,int ctem)
{
	if(atem>asum || btem>bsum || ctem>csum) return lim;
	if(term==range) return 0;
	if(rec[term][atem][btem]<lim) return rec[term][atem][btem];
	int ans=lim;
	int all_term=a[term]+b[term]+c[term];
	for(int i=0;i<=all_term;i++)
	{
		for(int j=0;i+j<=all_term;j++)
		{
			int k=all_term-i-j;
			ans=min(ans,dfs(term+1,atem+i*val[term],btem+j*val[term],ctem+k*val[term])+abs(a[term]-i)+abs(b[term]-j)+abs(c[term]-k));
		}
	}
	return rec[term][atem][btem]=ans;
}
int main()
{
	scanf("%d%d%d",&x1,&x2,&x3);
	for(int i=0;i<range;i++) scanf("%d",&a[i]),asum+=a[i]*val[i];
	for(int i=0;i<range;i++) scanf("%d",&b[i]),bsum+=b[i]*val[i];
	for(int i=0;i<range;i++) scanf("%d",&c[i]),csum+=c[i]*val[i];
	asum+=x3-x1,bsum+=x1-x2,csum+=x2-x3;
	memset(rec,lim,sizeof(rec));
	lstans=dfs(0,0,0,0);
	if(lstans>=lim) printf("impossible");
	else printf("%d",lstans/2);
	return 0;
}
```

---

## 作者：dAniel_lele (赞：0)

设 $v_{i,j}$ 表示第 $i$ 人拥有的 $j$ 种钞票数量。 

考虑 $dp_{x,i,j}$ 表示目前考虑到的人/面值对应状态为 $x$，第一个和第二个人分别有 $i,j$ 元的情况下最少动用多少张钞票。这样，我们也可以推出第三个人的钞票数量。

考虑转移，枚举这个人给其他两个人的该种钞票数量 $l_1,l_2$，设目前钞票的面值为 $val$。以第一个人为例，$dp_{x,i,j}+l_1+l_2\to dp_{x+1,i-(l_1+l_2)\times val,j+l_1\times val}$。

总复杂度 $O(tot^2)$ 带一定的常数，其中 $tot$ 为面值总额。

```cpp
#include <bits/stdc++.h>
#define int long long
#define s(i,j) ((i-1)*m+j)
#define add(i,j) ((i+j>=mod)?i+j-mod:i+j)
using namespace std;
int x[4];
int v[4][105],tot[4];
int atot[4],mz[6]={100,50,20,10,5,1};
int dp[1005][1005];
signed main(){
	cin>>x[1]>>x[2]>>x[3];
	for(int i=1;i<=3;i++){
		for(int j=0;j<6;j++) cin>>v[i][j];
		for(int j=0;j<6;j++) tot[i]+=mz[j]*v[i][j];
	}
	atot[1]=tot[1]-x[1]+x[3];
	atot[2]=tot[2]-x[2]+x[1];
	atot[3]=tot[3]-x[3]+x[2];
	if(atot[1]<0||atot[2]<0||atot[3]<0){
		cout<<"impossible";
		return 0;
	}
	memset(dp,1,sizeof(dp));
	dp[tot[1]][tot[2]]=0;
	for(int t=0;t<6;t++){
		for(int i=0;i<=1000;i++){
			for(int j=0;i+j<=1000;j++){
				int k=tot[1]+tot[2]+tot[3]-i-j;
				for(int l1=0;l1<=v[1][t];l1++){
					for(int l2=0;l1+l2<=v[1][t];l2++){
						if((l1+l2)*mz[t]<=i){
							dp[i-(l1+l2)*mz[t]][j+l1*mz[t]]=min(dp[i-(l1+l2)*mz[t]][j+l1*mz[t]],dp[i][j]+l1+l2);
						}
					}
				}
			}
		}
	}
	for(int t=0;t<6;t++){
		for(int j=0;j<=1000;j++){
			for(int i=0;i+j<=1000;i++){
				int k=tot[1]+tot[2]+tot[3]-i-j;
				for(int l1=0;l1<=v[2][t];l1++){
					for(int l2=0;l1+l2<=v[2][t];l2++){
						if((l1+l2)*mz[t]<=j){
							dp[i+l1*mz[t]][j-(l1+l2)*mz[t]]=min(dp[i+l1*mz[t]][j-(l1+l2)*mz[t]],dp[i][j]+l1+l2);
						}
					}
				}
			}
		}
	}
	for(int t=0;t<6;t++){
		for(int j=1000;j>=0;j--){
			for(int i=1000-j;i>=0;i--){
				int k=tot[1]+tot[2]+tot[3]-i-j;
				for(int l1=0;l1<=v[3][t];l1++){
					for(int l2=0;l1+l2<=v[3][t];l2++){
						if((l1+l2)*mz[t]<=k){
							dp[i+l1*mz[t]][j+l2*mz[t]]=min(dp[i+l1*mz[t]][j+l2*mz[t]],dp[i][j]+l1+l2);
						}
					}
				}
			}
		}
	}
	if(dp[atot[1]][atot[2]]<=1e9) cout<<dp[atot[1]][atot[2]];
	else cout<<"impossible";
	return 0;
}
```

---

## 作者：Tang_poetry_syndrome (赞：0)

# [P4026] 循环的债务
一道很好的思维题，码量也不大。
## 思路
### Part1.化简题意
题目应该不难理解，但还钱时 $a\to b\to c\to a$ 的一个环看起来很难解决，于是我们来简化一下还钱流程，这里我们设 $a,b,c,x,y,z$ 分别为 a 原有的钱，b 原有的钱，c 原有的钱，a 欠 b 的钱，b 欠 c 的钱，c 欠 a 的钱:  
- 将所有的钱放在一张桌子上。
- 每个人少拿欠别人的钱，再多拿回别人欠自己的钱，如 a 最后的钱应为 $a-x+z$，以此类推。

再设 $A,B,C$ 为 a，b，c 最后的钱，那么题目就变成了将 $a,b,c$ 分别改为 $A,B,C$ 的过程。
### Part2.推关系式
从一堆东西里取出两个数，很明显是 DP 或 DFS，因为个人感觉 DFS 好理解，这里就讲 DFS。  
我们考虑设 $ans_{i,j,k,l}$ 为在分面值为 $val_i$ 面值的钱时，a，b，c 分别总共分到 $j,k,l$ 元的最小次数，$q_i,p_i(q_i+p_i\le \sum\limits_{t=1}^3num_{t,i})$ 为 a，b 分别拿了 $q_i,p_i$ 张价值为 $val_i$ 的钱，则 c 拿了 $\sum\limits_{t=1}^3num_{t,i}-q_i-p_i$ 张。  
根据这些前置条件，可以得出 $ans_{i,j,k,l}=\min\limits_{q_i=0}^{\sum\limits_{t=1}^3num_{t,i}}\min\limits_{p_i=0}^{\sum\limits_{t=1}^3num_{t,i}-q_i}ans_{i+1,j+q_i\times val_i,k+p_i \times val_i,l+(\sum\limits_{t=1}^3num_{t,i}-q_i-p_i)}+\left|num_{1,i}-q_i\right|+\left|num_{2,i}-p_i\right|+\left|q_i+p_i-num_{1,i}-num_{2,i}\right|$
### Part3.细节判断
推完深搜主体，我们再来考虑深搜出口与特殊判断。  
首先考虑深搜出口，基础的退出即在 $i>6(val_i<1)$，然后就是不合法情况的剪枝：当一个人拿的钱超过了他该拿的，该方案不合法，返回一个极大值以保证这个数无法被更新。  
接着是特殊判断，仔细思考，可以发现上面的式子中，一张钱从一个人转移到另一个人手中，在出发时计数一次，再收到时计数一次，可见一次转移计数两次，即得到答案是正确答案两倍，输出 $ans_{1,0,0,0}/2$ 即可，具体详见代码。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define f(i,j,k) for(register ll i=j;i<=k;++i)
#define g(i,j,k) for(register ll i=j;i>=k;--i)
#define pb(x) push_back(x)
#define mp(a,b) make_pair(a,b)
#define pii pair<int,int>
#define pll pair<ll,ll>
ll val[7]={0,100,50,20,10,5,1},x[4],a[4][7],mon[4],sum[7],s;
ll dp(int step,ll x,ll y,ll z)
{
	if(x>mon[1]||y>mon[2]||z>mon[3])return 1e9;
	if(step>6)return 0;
	ll minn=LONG_LONG_MAX;
	f(i,0,a[1][step]+a[2][step]+a[3][step])
		f(j,0,a[1][step]+a[2][step]+a[3][step]-i)
			minn=min(minn,dp(step+1,x+i*val[step],y+j*val[step],z+(a[1][step]+a[2][step]+a[3][step]-i-j)*val[step])+abs(a[1][step]-i)+abs(a[2][step]-j)+abs(i+j-a[1][step]-a[2][step]));
	return minn;
}
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	f(i,1,3)cin>>x[i];
	f(i,1,3)f(j,1,6)cin>>a[i][j],s+=a[i][j],mon[i]+=a[i][j]*val[j],sum[j]+=a[i][j];
	mon[1]+=x[3]-x[1],mon[2]+=x[1]-x[2],mon[3]+=x[2]-x[3];
	ll res=dp(1,0,0,0);
	if(res<1e9)cout<<res/2;
	else cout<<"impossible";
	return 0;
}
```

---

## 作者：Graygoo (赞：0)

思考量比较大，代码量很小的一道思维~~水~~好题。

解决这道题的核心在于将三人的交换 转换为大家 **把钱摊在桌子上，然后分别拿取自己应该获得的钱财。**

我们定义 $dp$ 状态 $ f(i,j,k) $ 为考虑前 $i$ 种货币， 第一个人还应该获得 $j$ 元 ， 第二个人还应该获得 $k$ 元的最小交换数。

不记录第三个人的信息，是因为可以通过前两个维度推出第三人的信息。

我们接下来考虑怎么转移。

$$\ F(i,j,k) = Max(F(i,j,k),
F(i-1,j-x \cdot v[i],k-y \cdot v[i]) 
+ abs(a[i]-x)+abs(b[i]-y) + abs(x+y-a[i]-b[i])) $$

**当然,要满足 $j>x \times v[i] ,k>y \times v[i] $ , 以及 $ x+y  < $ 货币 $i$ 的总数量。**

这玩意是什么意思呢？

我们前面说到，我们已经把所有货币放到了桌子上，那么转移方程就是在讨论如何分配这个桌子上的某一类型的货币。

$x$就是这种货币分配给第一个人的数量。
$y$就是给第二个人的数量。

这样子分配的代价是什么呢？有可能有人拿走了原本不属于自己的货币，有人少拿了原来自己的货币，那么对应到原来的交换模型就相当于是发生**一次交换**。当然，这一次交换会被重复计算两次。

对应到方程中，代价就是自己实际拿的与自己原本有的这种货币的绝对值。（不要忘记考虑第三个人！）

在输出答案时，因为每次原本的交换行为都被记录了两次，因此需要把答案除以$2$。
    


---


# [JSOI2008] 火星人

## 题目描述

火星人最近研究了一种操作：求一个字串两个后缀的公共前缀。

比方说，有这样一个字符串：madamimadam，我们将这个字符串的各个字符予以标号：
```
序号 1 2 3 4 5 6 7 8 9 10 11 
字符 m a d a m i m a d a m
```
现在，火星人定义了一个函数 $LCQ(x, y)$，表示：该字符串中第 $x$ 个字符开始的字串，与该字符串中第 $y$ 个字符开始的字串，两个字串的公共前缀的长度。比方说，$LCQ(1, 7) = 5, LCQ(2, 10) = 1, LCQ(4, 7) = 0$

在研究 $LCQ$ 函数的过程中，火星人发现了这样的一个关联：如果把该字符串的所有后缀排好序，就可以很快地求出 $LCQ$ 函数的值；同样，如果求出了 $LCQ$ 函数的值，也可以很快地将该字符串的后缀排好序。

尽管火星人聪明地找到了求取 $LCQ$ 函数的快速算法，但不甘心认输的地球人又给火星人出了个难题：在求取 $LCQ$ 函数的同时，还可以改变字符串本身。具体地说，可以更改字符串中某一个字符的值，也可以在字符串中的某一个位置插入一个字符。地球人想考验一下，在如此复杂的问题中，火星人是否还能够做到很快地求取 $LCQ$ 函数的值。

## 说明/提示

1. 所有字符串自始至终都只有小写字母构成。
2. $M\leq150,000$
3. 字符串长度L自始至终都满足$L\leq100,000$
4. 询问操作的个数不超过 $10,000$ 个。

对于第 $1$，$2$ 个数据，字符串长度自始至终都不超过 $1,000$
对于第 $3$，$4$，$5$ 个数据，没有插入操作。

## 样例 #1

### 输入

```
madamimadam
7
Q 1 7
Q 4 8
Q 10 11
R 3 a
Q 1 7
I 10 a
Q 2 11```

### 输出

```
5
1
0
2
1```

# 题解

## 作者：DengDuck (赞：46)

我校小朋友发现暴力能过。

注意要利用 STL 容器 `string`，这样插入的效率很快，但是比对那里 $\mathcal O(n)$ 咋过的就很玄学。

原因主要是因为 STL 容器在随机数据下跑得飞快的原因。

建议加强数据。

提供一种 Hack 方法，没有修改插入操作，全是查询，然后字符串所有字符都一样，然后每次查询的位置是 $1$ 和 $\dfrac 1 2 (n+1)$。

Upd：根据我的测试，我的方案并不能卡掉暴力，目测是查询次数在 $10^4$ 次以内，每次 $\mathcal O(n)$ 可以勉强撵过去。

而其他操作虽然是 $\mathcal O(n)$，但是 STL，懂得都懂，卡不了啊......
```cpp
#include <bits/stdc++.h>
#define fo(i, a, b) for (int i = a; i <= b; i++)
using namespace std;
string s;
int n, m;
int main() {
    cin >> s;
    n = s.size();
    cin >> m;
    fo(i, 1, m) {
        string o, c;
        int x, d;
        cin >> o >> x;
        if (o == "Q") {
            cin >> d;
            x--, d--;
            int lcq = 0;
            for (int i = x, j = d; i < n && j < n; i++, j++)
                if (s[i] == s[j])
                    lcq++;
                else
                    break;
            printf("%d\n", lcq);
        }
        if (o == "R") {
            cin >> c;
            s[x - 1] = c[0];
        }
        if (o == "I") {
            cin >> c;
            s.insert(x, c);
            n = s.size();
        }
    }
    return 0;
}
```

代码是我校一个小朋友的，不是我的。

---

## 作者：__Watcher (赞：27)

做法：平衡树（Splay）维护哈希值

---

这篇题解会具体讲讲 Splay 的过程，供新手参考。

---

观察插入操作，插入的实际上是一个下标，比如在下标 2 和 3 之间插入一个字母 a，相当于插入了一个位于 2.5 的 a （脑补即可）。对于此类问题，平衡树上的关键字设为下标，而它的值则为它表示的字母。对于一个节点，它的左子树上的节点都是在下标比它小的字符，右子树上的节点都是下标比它大的字符。

先说查询操作。  
二分求 Hash 值的做法比较明显，这里主要讲区间查询 Hash。当我们查询区间 $[l,r]$ 的 Hash 值，我们可以这样把它转换为树的 Hash 值：

![](https://cdn.luogu.com.cn/upload/image_hosting/cjq3c3ej.png)

那么，A 中所有元素都是下标大于 $l-1$ 且小于 $r+1$ 的数，实际就是区间 $[l,r]$。

维护 Hash ：`s[x].hs=s[s[x].son[0]].hs+(ull)s[x].val*p[s[s[x].son[0]].sz] + s[s[x].son[1]].hs*p[s[s[x].son[0]].sz+1];`

其中，$p(i)$ 表示进制的 $i$ 次方。

---

修改操作


这个比较简单，把待修改的节点旋转至根节点后直接修改即可。

---

插入操作

比如我们需要插入下标为 2.5 的字符，那么我们可以插在这里：

![](https://cdn.luogu.com.cn/upload/image_hosting/91yvoyct.png)

虽然不能真的插入 2.5 但我们只要把节点插在这个位置上无论如何旋转它都能维持下标为 2.5 的性质。

---

提供代码，仅供参考：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ull unsigned long long
int read() {
	int x=0, f=1; char ch=' ';
	while(!isdigit(ch)) {ch=getchar(); if(ch=='-') f=-1;}
	while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48), ch=getchar();
	return x*f;
}
int n, root, size;
ull p[1000005];
struct AB{
	int val, f, son[2], sz;
	ull hs;
}s[1000005];
int get_son(int x) {
	return x==s[s[x].f].son[1];
}
void update(int x) {
	if(!x) return;
	s[x].sz=1;
	if(s[x].son[0]) s[x].sz+=s[s[x].son[0]].sz;
	if(s[x].son[1]) s[x].sz+=s[s[x].son[1]].sz;
	s[x].hs=s[s[x].son[0]].hs+(ull)s[x].val*p[s[s[x].son[0]].sz] + s[s[x].son[1]].hs*p[s[s[x].son[0]].sz+1];
}
void build(int l, int r, int x) {
	if(l>r) return;
	int mid=(l+r)>>1;
	if (mid >= x) s[x].son[1] = mid;
	else s[x].son[0] = mid;
	s[mid].f = x, s[mid].sz = 1;
	if (l==r) return;
	build(l, mid-1, mid), build(mid+1, r, mid);
	update(mid);
	return ;
}
void rotate(int x) {
	int fa=s[x].f, ffa=s[fa].f, wson=get_son(x);
	s[fa].son[wson]=s[x].son[wson^1];
	s[s[fa].son[wson]].f=fa;
	s[x].son[wson^1]=fa;
	s[fa].f=x;
	s[x].f=ffa;
	if(ffa) s[ffa].son[s[ffa].son[1]==fa]=x;
	update(fa);
	update(x);
} 
void splay(int x, int goal) {
	for(int fa;(fa=s[x].f)!=goal;rotate(x)) {
		if(s[fa].f!=goal) {
			rotate((get_son(x)==get_son(fa))?fa:x);
		}
	}
	update(x);
	if(goal==0) root=x;
}
int find(int x) {
	int now=root;
	while(1) {
		if (s[s[now].son[0]].sz+1 == x) return now;
		if (s[s[now].son[0]].sz+1 < x) x -= (s[s[now].son[0]].sz+1), now = s[now].son[1];
		else now = s[now].son[0];
	}
}
int get_hash(int l, int r) {
	int x=find(l), y=find(r+2);
	splay(x, 0), splay(y, root);
	return s[s[s[root].son[1]].son[0]].hs;
}
char ch[1000005];
int t;
int main() {
	scanf("%s", ch+1);
	n=strlen(ch+1);
	p[0]=1;
	for(int i=1;i<=n*2;i++) p[i]=p[i-1]*27ull;
	for(int i=2;i<=n+1;i++) {
		s[i].val=s[i].hs=ch[i-1]-'a'+1;
	}
	build(1, n+2, root);
	root = (n+3) >> 1, size=n+2;
	cin>>t;
	while(t--) {
		char type[3], ch[3];
		scanf("%s", type);
		if(type[0]=='Q') {
			int x=read(), y=read();
			if(x>y) swap(x, y);
			int l=0, r=size-y-1, mid;
			while(l<r) {
				mid=(l+r+1)>>1;
				if(get_hash(x, x+mid-1)==get_hash(y, y+mid-1)) l=mid;
				else r=mid-1;
			}
			printf("%d\n", l);
		}
		if(type[0]=='R') {
			int x=read();
			scanf("%s", ch);
			splay(find(x+1), 0);
			s[root].val=ch[0]-'a'+1;
			update(root);
		}
		if(type[0]=='I') {
			int u=read();
			scanf("%s", ch);
			int x=find(u+1), y=find(u+2);
			splay(x, 0); splay(y, x);
			s[s[root].son[1]].son[0] = ++size;
			s[size].f = s[root].son[1];
			s[size].val = s[size].hs = ch[0]-'a'+1;
			splay(size, 0);
		}
	}
}
```




---

## 作者：Dispwnl (赞：18)

emmm。。。题意做法前面都说的很明白了

发现（也可能是我没找到）竟然没人用Fhq Treap做~~你们是不是看不起Treap~~

Fhq Treap支持单点插入，单点删除（修改时用），区间查询

还是很好写的~~我™还WA了这么多次~~

注意树上点要赋初值不然只有30分

用unsigned int似乎比int快了不止一点。。。似乎是处理负数费时间

代码：
```cpp
# include<iostream>
# include<cstring>
# include<cstdio>
# include<cstdlib>
# define LL unsigned int
using namespace std;
const int MAX=2e5+1;
int rt,tot,n,m;
string A;
LL ha[MAX];
struct Fhq_Treap{
    int pos[MAX],siz[MAX],Ch[MAX];
    LL w[MAX];
    int son[MAX][2];
    void pus(int x)
    {
        siz[x]=siz[son[x][1]]+siz[son[x][0]]+1;
        w[x]=w[son[x][0]]*ha[siz[son[x][1]]+1]+ha[siz[son[x][1]]]*Ch[x]+w[son[x][1]];
    }
    int merge(int x,int y)
    {
        if(!x||!y) return x+y;
        if(pos[x]<pos[y])
        {
            son[x][1]=merge(son[x][1],y);
            pus(x);
            return x;
        }
        else
        {
            son[y][0]=merge(x,son[y][0]);
            pus(y);
            return y;
        }
    }
    void split(int i,int k,int &a,int &b)
    {
        if(!i) a=b=0;
        else
        {
            if(k<=siz[son[i][0]])
            b=i,split(son[i][0],k,a,son[i][0]);
            else a=i,split(son[i][1],k-siz[son[i][0]]-1,son[i][1],b);
            pus(i);
        }
    }
    void ins(int x,char ch)
    {
        int a,b;
        split(rt,x,a,b);
        w[++tot]=Ch[tot]=ch-'a'+1,siz[tot]=1,pos[tot]=rand();
        rt=merge(merge(a,tot),b);
    }
    void cut(int x)
    {
        int a,b,c;
        split(rt,x,a,c);
        split(a,x-1,a,b);
        b=merge(son[b][0],son[b][1]);
        rt=merge(merge(a,b),c);
    }
    LL ask(int l,int r)
    {
        int L=r-l+1;
        int a,b,c,d;
        split(rt,l-1,a,b);
        split(b,L,c,d);
        LL ans=w[c];
        rt=merge(a,merge(c,d));
        return ans;
    }
    bool look(int x,int y,int mid)
    {
        LL ans1=ask(x,x+mid-1),ans2=ask(y,y+mid-1);
        return ans1==ans2;
    }
}Tree;
string Read()
{
    string a=" ";
    char ch=getchar();
    for(;ch>'z'||ch<'a';ch=getchar());
    for(;ch<='z'&&ch>='a';a+=ch,ch=getchar());
    return a;
}
char read_char()
{
    char ch=getchar();
    for(;ch>'z'||ch<'A';ch=getchar());
    return ch;
}
int read()
{
    int x=0;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar());
    for(;isdigit(ch);x=x*10+ch-48,ch=getchar());
    return x;
}
int main()
{
    A=Read(),n=A.length()-1,m=read();
    ha[0]=1;
    for(int i=1;i<MAX;++i)
      ha[i]=ha[i-1]*27;
    for(int i=1;i<=n;++i)
      Tree.ins(i,A[i]);
    for(int i=1;i<=m;++i)
      {
      	char op=read_char();
      	if(op=='Q')
      	{
      		int x=read(),y=read();
      		int l=1,r=min(n-x,n-y)+1,ans=0;
      		while(l<=r)
      		{
      			int mid=(l+r>>1);
      			if(Tree.look(x,y,mid)) l=mid+1,ans=mid;
      			else r=mid-1;
            }
            printf("%d\n",ans);
        }
        else if(op=='R')
        {
            int x=read();
            Tree.cut(x),Tree.ins(x-1,read_char());
        }
        else if(op=='I')
        {
            int x=read();
            ++n,Tree.ins(x,read_char());
        }
      }
    return 0;
}
```

---

## 作者：Ebola (赞：15)

#### 替罪羊树+哈希+倍增

2008年的题，现在想来，那时候的OI圈可真是美好，从不恶意卡某种算法。唉，时代变了

由于这题要搞这么个LCP，还要支持插入、修改操作，那后缀数组就没法搞了

于是我们可以用平衡树。每个节点维护整棵子树的哈希值，假设右子树大小为$R$，然后设$pw[x]$表示$base$的$x$次方，那么哈希值维护公式就是：$sum[x]=sum[rson[x]]+val[x]*pw[R]+sum[lson[x]]*pw[R+1]$

哈希模数要尽量大一些，虽然出题人善良，但模数小还是会WA，建议使用ULL自然溢出

那么求两串的lcp，我们可以用倍增的思想来搞。

首先需要写一个函数$find(l,r)$，它的功能是求得$l$到$r$这个子串的哈希值。那可以用类似线段树拆区间询问的方法，只不过平衡树的拆区间询问更难写，思路还是一样的，这个直接看代码就很直观了

然后就是倍增的思想，枚举$k=17\to 0$，如果子串$[x,x+2^k)$的哈希值与字串$[y,y+2^k)$的相等，那就$x,y$都向右移动$2^k$步，同时令答案加上$2^k$。当然你说二分那也可以，但我处理二分边界的能力实在太弱了，就不写二分了

至于用什么树，都行。我用的替罪羊，好写又跑得快，目前是Rank 1

```cpp
#include<bits/stdc++.h>
using namespace std;

namespace IO
{
    const int S=(1<<20)+5;
    char buf[S],*H,*T;
    inline char Get()
    {
        if(H==T) T=(H=buf)+fread(buf,1,S,stdin);
        if(H==T) return -1;return *H++;
    }
    inline int read()
    {
        int x=0;char c=Get();
        while(!isdigit(c)) c=Get();
        while(isdigit(c)) x=x*10+c-'0',c=Get();
        return x;
    }
    inline char readc()
    {
        char c=Get();
        while((c<'A'||c>'Z')&&(c<'a'||c>'z')) c=Get();
        return c;
    }
    char obuf[S],*oS=obuf,*oT=oS+S-1,c,qu[55];int qr;
    inline void flush(){fwrite(obuf,1,oS-obuf,stdout);oS=obuf;}
    inline void putc(char x){*oS++ =x;if(oS==oT) flush();}
    template <class I>inline void print(I x)
    {
        if(!x) putc('0');
        while(x) qu[++qr]=x%10+'0',x/=10;
        while(qr) putc(qu[qr--]);
        putc('\n');
    }
}

using namespace IO;
typedef unsigned long long ull;
const int N=150010;
const double alpha=0.75;
int lc[N],rc[N],sz[N],tot=0,rt=0;
ull val[N],sum[N],pw[N];
vector<int> A;

bool isbad(int o){return sz[lc[o]]>alpha*sz[o]+5||sz[rc[o]]>alpha*sz[o]+5;}
void maintain(int o)
{
    sum[o]=sum[rc[o]]+val[o]*pw[sz[rc[o]]]+sum[lc[o]]*pw[sz[rc[o]]+1];
    sz[o]=sz[lc[o]]+sz[rc[o]]+1;
}

void flatten(int o)
{
    if(!o) return;
    flatten(lc[o]);
    A.push_back(o);
    flatten(rc[o]);
}

void rebuild(int &o,int l,int r)
{
    int mid=(l+r)/2;
    o=A[mid-1];
    lc[o]=rc[o]=0;
    if(l<mid) rebuild(lc[o],l,mid-1);
    if(r>mid) rebuild(rc[o],mid+1,r);
    maintain(o);
}

void insert(int &o,int k,int x)
{
    if(!o)
    {
        o=++tot;
        lc[o]=rc[o]=0;
        val[o]=sum[o]=x;
        sz[o]=1;
        return;
    }
    if(isbad(o))
    {
        A.clear();flatten(o);
        rebuild(o,1,A.size());
    }
    int szl=sz[lc[o]];
    if(k<=szl) insert(lc[o],k,x);
    else insert(rc[o],k-szl-1,x);
    maintain(o);
}

void modify(int o,int k,int x)
{
    int szl=sz[lc[o]];
    if(k==szl+1) val[o]=x;
    else if(k<=szl) modify(lc[o],k,x);
    else modify(rc[o],k-szl-1,x);
    maintain(o);
}

ull find(int o,int l,int r,int nl,int nr)
{
    if(l==nl&&r==nr) return sum[o];
    int szl=sz[lc[o]];ull res=0;
    if(nr<l+szl) return find(lc[o],l,l+szl-1,nl,nr);
    if(nl>l+szl) return find(rc[o],l+szl+1,r,nl,nr);
    if(nl<l+szl) res=find(lc[o],l,l+szl-1,nl,l+szl-1);
    if(nl<=l+szl&&nr>=l+szl) res=res*pw[1]+val[o];
    if(nr>l+szl) res=res*pw[nr-l-szl]+find(rc[o],l+szl+1,r,l+szl+1,nr);
    return res;
}

int lcp(int x,int y)
{
    int res=0;
    for(int i=17;i>=0;i--)
    {
        if(x+(1<<i)-1>tot) continue;
        if(y+(1<<i)-1>tot) continue;
        ull s1=find(rt,1,tot,x,x+(1<<i)-1);
        ull s2=find(rt,1,tot,y,y+(1<<i)-1);
        if(s1!=s2) continue;
        res|=1<<i;x+=1<<i;y+=1<<i;
    }
    return res;
}

int main()
{
    pw[0]=1;
    for(int i=1;i<N;i++)
        pw[i]=pw[i-1]*131;
    static char ss[N];
    scanf("%s",ss+1);
    tot=strlen(ss+1);
    for(int i=1;i<=tot;i++)
        A.push_back(i),val[i]=ss[i]-'a'+1;
    rebuild(rt,1,tot);
    for(int m=read();m;m--)
    {
        char opt=readc();
        if(opt=='I')
        {
            int x=read();
            char d=readc();
            insert(rt,x,d-'a'+1);
        }
        if(opt=='R')
        {
            int x=read();
            char d=readc();
            modify(rt,x,d-'a'+1);
        }
        if(opt=='Q') print(lcp(read(),read()));
    }
    flush();
    return 0;
}
```

### 最后吐槽几句

写完后惊叹所有人都不约而同地写了Splay或非旋Treap，没见一个人用其它东西。其实按照我的方法，用什么平衡树都可以啊，普通Treap、SBT什么的都可以的啊。然后仔细想了想，发现用Splay根本不需要写那个恶心的拆区间询问，直接把左端点伸展到根，右端点伸展到根的右儿子，那右儿子的左儿子就直接是那一段的哈希值了……

不管了，虽然你们Splay好写，但你们常数大，你们跑不过我（Flag高高立起）

---

## 作者：devout (赞：8)

~~话说这题时限不是10秒吗怎么跑洛谷上就1s了~~

有插入问题，想到平衡树

考虑询问，我们发现单次查询$O(\log^2n )$可以接受，所以我们对于每次询问进行一下二分长度，那么怎么判断这两个字符串相等呢？我们想到了~~不靠谱~~的哈希

那么怎么用平衡树维护区间哈希值呢？根据哈希的定义，我们有

$$hash[x]=hash[lc]\times base^{siz[rc]+1}+val[x]\times^{siz[rc]}+hash[rc]$$

注意这里我们还是需要存每个节点代表的字符的，不能用$hash[x]$替换$val[x]$，~~我就在这里调了好久~~

对于我们每次查询，二分出一个区间之后，我们直接利用$fhq\  treap$把这一段区间拎出来，然后求出哈希值就可以了

对于哈希的问题，这里我用的是$unsigned\  int$自然溢出，~~因为这样跑的快点~~，如果取模的话就会变得超级超级慢

当然因为我自带大常数最后还是被迫吸氧了

据说这题$splay$跑的更快？

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=1e5+5;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

typedef unsigned int ull;
const int base=29;

int n,m;
char s[N];
int son[N][2],siz[N],val[N],treap[N];
ull haxi[N],poww[N];
int rt,tot;

int newnode(int value){
    int u=++tot;
    siz[u]=1,treap[u]=rand();
    haxi[u]=val[u]=value;
    return u;
}

void update(int x){
    siz[x]=siz[son[x][0]]+siz[son[x][1]]+1;
    haxi[x]=haxi[son[x][0]]*poww[siz[son[x][1]]+1]+val[x]*poww[siz[son[x][1]]]+haxi[son[x][1]];
}

int merge(int u,int v){
    if(!u||!v)return u|v;
    int rt;
    if(treap[u]<treap[v])son[rt=u][1]=merge(son[u][1],v);
    else son[rt=v][0]=merge(u,son[v][0]);
    return update(rt),rt;
}

void split(int o,int &u,int &v,int k){
    if(!o){u=v=0;return;}
    int rank=siz[son[o][0]]+1;
    if(rank<=k)split(son[u=o][1],son[o][1],v,k-rank);
    else split(son[v=o][0],u,son[o][0],k);
    update(o);
}

ull gethash(int l,int r){
    int x,y,z;
    split(rt,x,z,r);
    split(x,x,y,l-1);
    ull res=haxi[y];
    rt=merge(merge(x,y),z);
    return res;
}

int main()
{
    srand(19260817);
    poww[0]=1;
    Rep(i,1,1e5)poww[i]=poww[i-1]*base;
    scanf("%s",s+1);
    n=strlen(s+1);
    Rep(i,1,n)rt=merge(rt,newnode(s[i]-'a'));
    read(m);
    Rep(i,1,m){
        char opt[10];
        scanf("%s",opt);
        if(opt[0]=='Q'){
            int x,y;
            read(x),read(y);
            if(x>y)swap(x,y);
            int l=1,r=siz[rt]-y+1,res=0;
            while(l<=r){
                int mid=l+r>>1;
                if(gethash(x,x+mid-1)==gethash(y,y+mid-1))res=mid,l=mid+1;
                else r=mid-1;
            }
            printf("%d\n",res);
        } 
        if(opt[0]=='R'){
            int x,y,z;read(x);
            char ch;cin>>ch;
            int pos=x,value=ch-'a';
            split(rt,x,z,pos);
            split(x,x,y,pos-1);
            haxi[y]=val[y]=value;
            rt=merge(merge(x,y),z);
        }
        if(opt[0]=='I'){
            int x,y;read(x);
            char ch;cin>>ch;
            int k=x,val=ch-'a';
            split(rt,x,y,k);
            rt=merge(merge(x,newnode(val)),y);
        }
    }
    return 0;
}
```


---

## 作者：Inui_Sana (赞：7)

大家好，我不会平衡树，所以我用线段树过了这一题。

其实就是一个 trick：SGT 不能维护插入操作，于是离线处理：先求出序列最后长度，再**倒着**做所有插入操作（可以将一开始的序列也视作若干次插入）。

先将序列上每个位置标为 $1$，于是插入到第 $x$ 个数后面就变成了线段树上二分，找到第一个前缀和为 $x+1$ 的位置，于是在最终序列中，这个数就是在这个位置，并将这个位置标记为 $0$。

当然如果优美一点你会发现上述操作可以用 BIT 替代。

知道最后每个数在哪里，就可以直接维护所有的操作了。SGT 维护哈希值和平衡树类似，就是维护当前哈希值 $h$ 和序列长度 $len$，此处不再赘述。一开始还没插入的位置长度 $len$ 要设为 $0$，插入时再改为 $1$，哈希值正常维护即可。

需要注意的是，在处理询问的时候会发现我们似乎还要动态维护当前序列每个位置对应最终序列哪个位置。不过这个东西其实也是一个 BIT 上二分就能解决，不会影响复杂度。

因为只用了简单 SGT+BIT 所以跑得飞快，在没有刻意卡常的情况下进了最优解第一页。

code：

```cpp
const ull base=20247161607;
int n,m,cur,b[N],rk[N],id[N];
ull c[107],pw[N];
mt19937 rnd(time(0));
char s[N];
struct node{
	int op,x,y;
}d[N];
struct Tnode{
	int len;ull h;
	Tnode(int _len=0,ull _h=0):len(_len),h(_h){}
	Tnode operator+(const Tnode &rhs)const{
		return Tnode(len+rhs.len,h*pw[rhs.len]+rhs.h);
	}
};
struct SGT{
	Tnode tr[N<<2];
	il void pushup(int o){
		tr[o]=tr[o<<1]+tr[o<<1|1];
	}
	void update(int l,int r,int o,int x,int y){
		if(l==r){
			tr[o]=Tnode(1,c[y]);
			return;
		}
		int mid=(l+r)>>1;
		if(x<=mid){
			update(l,mid,o<<1,x,y);
		}else{
			update(mid+1,r,o<<1|1,x,y);
		}
		pushup(o);
	}
	Tnode query(int l,int r,int o,int x,int y){
		if(r<x||l>y||x>y){
			return Tnode();
		}
		if(l>=x&&r<=y){
			return tr[o];
		}
		int mid=(l+r)>>1;
		return query(l,mid,o<<1,x,y)+query(mid+1,r,o<<1|1,x,y);
	}
}T;
struct BIT{
	int tr[N];
	#define lb(x) ((x)&(-(x)))
	il void upd(int x,int y){
		while(x<=cur){
			tr[x]+=y;
			x+=lb(x);
		}
	}
	il int find(int x){
		int p=0,s=0;
		drep(i,18,0){
			if(p+(1<<i)<=cur&&s+tr[p+(1<<i)]<=x){
				p+=1<<i;
				s+=tr[p];
			}
		}
		return p+1;
	}
}R;
void Yorushika(){
	scanf("%s",s+1),n=strlen(s+1);
	rep(i,0,25){
		c[i]=1ull*rnd()*rnd()*rnd()*rnd();
	}
	rep(i,1,n){
		rk[i]=i-1;
	}
	read(m),cur=n;
	rep(i,1,m){
		char op[7];int x,y;
		scanf("%s",op),read(x);
		if(op[0]=='Q'){
			read(y);
			d[i]={0,x,y};
		}else if(op[0]=='R'){
			scanf("%s",op);
			d[i]={1,x,op[0]-'a'};
		}else{
			scanf("%s",op);
			d[i]={2,x,op[0]-'a'};
			rk[id[i]=++cur]=x;
		}
	}
	pw[0]=1;
	rep(i,1,cur){
		R.upd(i,1);
		pw[i]=pw[i-1]*base;
	}
	drep(i,cur,1){
		b[i]=R.find(rk[i]);
		R.upd(b[i],-1);
	}
	rep(i,1,n){
		T.update(1,cur,1,b[i],s[i]-'a');
		R.upd(b[i],1);
	}
	int len=n;
	rep(i,1,m){
		if(d[i].op==0){
			int x=R.find(d[i].x-1),y=R.find(d[i].y-1);
			int l=1,r=min(len-d[i].x+1,len-d[i].y+1),ans=0;
			while(l<=r){
				int mid=(l+r)>>1;
				int X=R.find(d[i].x+mid-2),Y=R.find(d[i].y+mid-2);
				if(T.query(1,cur,1,x,X).h==T.query(1,cur,1,y,Y).h){
					ans=mid;
					l=mid+1;
				}else{
					r=mid-1;
				}
			}
			printf("%d\n",ans);
		}else if(d[i].op==1){
			int x=R.find(d[i].x-1);
			T.update(1,cur,1,x,d[i].y);
		}else{
			T.update(1,cur,1,b[id[i]],d[i].y);
			R.upd(b[id[i]],1);
			len++;
		}
	}
}
signed main(){
	int t=1;
	//read(t);
	while(t--){
		Yorushika();
	}
}
```

---

## 作者：AC_love (赞：5)

大家好，我很喜欢暴力数据结构，于是我打算用分块来做这道题。

此题有插入操作，因此普通的静态分块无法解决问题，考虑块状链表。

首先众所周知，块状链表可以轻而易举做到此题其他题解中平衡树做的事情：维护一个区间 $[l, r]$ 的哈希值。但这个操作用块状链表来做复杂度为 $O(\sqrt n)$，对比 $O(\log n)$ 的平衡树并不占优势。

同时我们知道，分块和二分是天生八字不合的算法，此题中如果对分块算法使用二分，单次询问复杂度将会达到 $O(\sqrt n \log n)$。由于本题询问操作很少，所以貌似可以通过（连 $O(n)$ 的暴力都能通过，这个没理由过不去），但看起来真的很劣。

所以对于块状链表做法，我们不考虑使用二分回答询问，而是直接暴力跳块。

详细点说，做法如下：

预处理：对于每个块，维护每个前缀的 hash 值。

修改：修改一个字符，然后修改所有包括这个字符的前缀的 hash 值。

插入：插入一个字符，把它后面的字符整体往后挪一位，然后再修改所有包括这个插入字符的前缀的 hash 值。

询问：从两个点开始，每次一步跳 $\sqrt n$ 格，如果跳完之后还相等，那么继续跳。如果跳完之后不相等，直接暴力跳 $\sqrt n$ 步找到第一个不相等的位置即可。

考虑一下复杂度。

当块的长度和每个块内元素都为 $\sqrt n$ 级别时，修改和插入操作最多改一整个块，复杂度 $O(\sqrt n)$；询问操作中，暴力跳块最多只会跳过 $\sqrt n$ 个块，复杂度 $O(\sqrt n)$。当发现不同之处，开始暴力跳时，最多跳 $\sqrt{n}$ 个字符就能找到差异，复杂度还是 $O(\sqrt n)$。

每个操作都是 $O(\sqrt n)$ 的复杂度，而预处理复杂度为 $O(n \sqrt n)$。故总复杂度为 $O((n + m) \sqrt n)$。

本题中 $n, m$ 近乎同阶，复杂度可视为 $O(n \sqrt n)$，相比 $O(n \log^2 n)$ 的平衡树未必不占优势（KH：支持正义根号！）。

[评测记录](https://www.luogu.com.cn/record/160426827)

本人代码总用时 1.70s，比大部分平衡树跑的都快，起码如果让我自己写一个平衡树的话肯定没有我的块状链表跑得快。

~~我踩过的坑点~~ 一些需要注意的点：

1. 本题中插入操作是“在第 $x$ 个字符后面插入”，而一些写法的插入操作是“在第 $x$ 个字符前面插入”。如果你采用了这样的写法，记得读入插入操作后将 $x$ 增加 $1$。
2. 在询问跳块时，可能会发生跳到字符串外面的情况，导致溢出。特判很麻烦，我的解决办法是在读入的字符串后面加入足够多的特殊字符。
3. 需要注意，如果你也加入了特殊字符，请务必特判 `Q x x` 这种情况，否则这两个东西会一直跳下去，直到跳到字符串外面。

同时众所周知的，块状链表题目不给代码约等于耍流氓（AClove：口嗨谁不会啊），因此我们在下面对于每种操作的代码进行详解：

一个块内应该维护的信息：

```cpp
struct block
{
    char c[S * 5 + 100];
    // 记录块内的所有字符
    int pre[S * 5 + 100];
    // pre 数组维护每个前缀 hash
    int sz;
    // sz 维护这个块的大小
    int lef, rig;
    // lef, rig 记录当前块的左块和右块编号
    int head;
    // head 记录这个块前面有多少个字符
    int hash(int l, int r) { return ((pre[r] - pre[l - 1] * p[r - l + 1] % mod) + mod) % mod; }
    // 快速求一个区间的 hash 值
    void push_back(char val) { c[++ sz] = val; pre[sz] = (pre[sz - 1] * base + val - 'a' + 1) % mod; }
    // 插入一个新字符
};
block c[S * 2 + 10];
```

修改一个位置的字符：

```cpp
void change(int pos, char val)
{
    int ps = bl[pos], w = pos - c[ps].head;
    // ps 是 val 处于哪个块，w 是 val 在块中的位置
    c[ps].c[w] = val;
    // 修改这个位置的字符
    for(int i = w; i <= c[ps].sz; i = i + 1)
        c[ps].pre[i] = (c[ps].pre[i - 1] * base + c[ps].c[i] - 'a' + 1) % mod;
        // 修改所有包含这个位置的前缀哈希
}
```

向一个位置插入元素：

需要注意的是，只有当每个块的大小都接近 $\sqrt n$ 时块状链表的复杂度才能保证。如果你一直往一个块里插入元素，会导致这个块变得很大，复杂度可能退化成 $O(n^2)$。因此要在块比较大的时候把块拆开。

```cpp
void split(int id)
// 把 id 这个块拆了
{
    c[++ blocks].lef = id;
    c[blocks].rig = c[id].rig;
    c[c[id].rig].lef = blocks;
    c[id].rig = blocks;
    // 开一个新块

    for(int i = S + 1; i <= c[id].sz; i = i + 1)
    {
        c[blocks].push_back(c[id].c[i]);
        // 把插入新字符
        c[id].c[i] = c[id].pre[i] = 0;
        // 清除旧块中的信息
    }
    c[id].sz = S;
    // 重置旧块的大小
    c[blocks].head = c[id].head + S;
    // 计算新块前面有多少个字符
    for(int i = c[blocks].head + 1; i <= c[blocks].head + c[blocks].sz; i = i + 1)
        bl[i] = blocks;
        // 更新 bl 数组
}

void insert(int pos, char val)
{
    int ps = bl[pos], w = pos - c[ps].head;
    // ps 是 val 处于哪个块，w 是 val 在块中的位置
    for(int i = c[ps].sz + 1; i >= w + 1; i = i - 1)
        c[ps].c[i] = c[ps].c[i - 1];
        // 把 w 后面的字符整体右移一位
    c[ps].c[w] = val;
    // 修改这个位置的字符
    c[ps].sz ++;
    // 更新块长
    for(int i = w; i <= c[ps].sz; i = i + 1)
        c[ps].pre[i] = (c[ps].pre[i - 1] * base + c[ps].c[i] - 'a' + 1) % mod;
        // 修改所有包含这个位置的前缀哈希
    for(int i = ps; i; i = c[i].rig)
    {
        if(i != ps)
            c[i].head ++;
        // 把后面的所有块的前面的字符数 +1
        bl[c[i].head + 1] = i;
        bl[c[i].head + c[i].sz] = i;
        // 更新 bl 数组
    }
    if(c[ps].sz >= S * 2)
        split(ps);
        // 如果当前块长度太长，就把它拆了
}
```

询问：

```cpp
int jump(int pos, int k)
// 计算 pos 跳 k 步后的哈希值
{
    int ps = bl[pos], w = pos - c[ps].head;
    // ps 是 val 处于哪个块，w 是 val 在块中的位置
    int suf = c[ps].sz - w + 1;
    // 计算 w 后面有几个字符
    if(suf >= k)
        return c[ps].hash(w, w + k - 1);
        // 如果还在块内，那么直接快速计算
    return (c[ps].hash(w, w + suf - 1) * p[k - suf] % mod + jump(pos + suf, k - suf)) % mod;
    // 否则先把当前块跳完，然后去跳下一个块
}

bool cmp(int l1, int l2)
// 比较两个位置的字符是否相等
{
    int ps1 = bl[l1], w1 = l1 - c[ps1].head;
    int ps2 = bl[l2], w2 = l2 - c[ps2].head;
    return c[ps1].c[w1] == c[ps2].c[w2];
}

int query(int l1, int l2)
{
    int res = 0;
    while(jump(l1, S) == jump(l2, S))
    {
        res += S;
        l1 += S;
        l2 += S;
    }
    while(cmp(l1, l2))
    {
        l1 ++;
        l2 ++;
        res ++;
    }
    return res;
}
```

初始化：

```cpp
void build()
{
    for(int i = 1; i <= len; i = i + 1)
    {
        bl[i] = (i - 1) / S + 1;
        c[bl[i]].push_back(s[i]);
        // 向块内插入一个字符
        blocks = bl[i];
        // 更新块数
    }
    for(int i = 1; i <= blocks; i = i + 1)
        c[i].lef = i - 1,
        c[i].rig = i + 1,
        c[i].head = (i - 1) * S;
        // 维护每个块的左右块
    c[blocks].rig = 0;
    // 最右边的块右边没有块
}
```

以上就是本题的所有核心操作，代码的其他部分没啥意义，就不放了。

---

## 作者：JZYshuraK (赞：5)

# 火星人
题解：
第一眼就是后缀数组，但是发现有单点插入操作果断$pass$。

一个序列支持单点插入肯定最少是个平衡树。

又发现$log^2n$好像能过，我们就对序列建立非旋转$Treap$然后维护子树$hash$值。

每一次查询的时候二分。

二分地找出从当前位的答案。

然后撕出区间暴力验证即可。

时间复杂度$O(mlog^2n)$。

Code：
```cpp
#include <bits/stdc++.h>
#define N 100010 
using namespace std;
typedef unsigned int ull;
const ull base = 97 ;
int root,cnt; char s[N];
ull B[1000010];
#define nc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
char buf[100000],*p1,*p2;
inline int rd()
{
	register int x=0;register char c=nc();
	while(c<'0'||c>'9')c=nc();
	while(c>='0'&&c<='9')x=((x+(x<<2))<<1)+(c^48),c=nc();
	return x;
}
struct Node
{
	int ls,rs,size,key;
	ull sum,val;
}a[N<<1];
struct par {int x,y;};
inline void pushup(int x)
{
	int ls=a[x].ls,rs=a[x].rs;
	a[x].sum=a[x].val; a[x].size=1;
	if(ls) a[x].sum-=a[x].val,a[x].sum+=a[ls].sum+a[x].val*B[a[ls].size],a[x].size+=a[ls].size;
	if(rs) a[x].sum+=a[rs].sum*B[a[ls].size+1],a[x].size+=a[rs].size;
}
int merge(int x,int y)
{
	if(!x||!y) return x|y;
	if(a[x].key>a[y].key)
	{
		a[x].rs=merge(a[x].rs,y); pushup(x);
		return x;
	}
	else
	{
		a[y].ls=merge(x,a[y].ls); pushup(y);
		return y;
	}
}
par split(int x,int k)
{
	if(!k) return (par){0,x};
	int ls=a[x].ls,rs=a[x].rs;
	if(k==a[ls].size)
	{
		a[x].ls=0; pushup(x);
		return (par){ls,x};
	}
	else if(k==a[ls].size+1)
	{
		a[x].rs=0; pushup(x);
		return (par){x,rs};
	}
	else if(k<a[ls].size)
	{
		par t=split(ls,k);
		a[x].ls=t.y; pushup(x);
		return (par){t.x,x};
	}
	else
	{
		par t=split(rs,k-a[ls].size-1);
		a[x].rs=t.x; pushup(x);
		return (par){x,t.y};
	}
}
inline int newnode(ull val)
{
	int x=++cnt;
	a[x].ls=a[x].rs=0; a[x].size=1;
	a[x].sum=a[x].val=val; a[x].key=rand()*rand();
	return x;
}
void insert(int x,ull val)
{
	par t=split(root,x);
	root=merge(t.x,merge(newnode(val),t.y));
}
ull query(int x,int k)
{
	par t1=split(root,x-1),t2=split(t1.y,k);
	ull re=a[t2.x].sum;
	root=merge(t1.x,merge(t2.x,t2.y));
	return re;
}
void update(int x,ull y)
{
	par t1=split(root,x-1),t2=split(t1.y,1);
	root=merge(t1.x,merge(newnode(y),t2.y));
}
void output(int x)
{
	int ls=a[x].ls,rs=a[x].rs;
	if(ls) output(ls);
	printf("%lld ",a[x].val);
	if(rs) output(rs);
}
int build(int l,int r)
{
	if(l==r) return newnode(s[l]-'a'+1);
	int mid=(l+r)>>1;
	return merge(build(l,mid),build(mid+1,r));
}
int main()
{
	srand(20021214);
	B[0]=1;
	for(int i=1;i<=1000000;i++) B[i]=B[i-1]*base;
	scanf("%s",s+1); int n=strlen(s+1);
	root=build(1,n);
	int m=rd(); while(m--)
	{
		char opt=nc(); while(opt!='Q'&&opt!='R'&&opt!='I')opt=nc(); int x=rd();
		if(opt=='Q')
		{
			int y=rd();
			int r=min(n-x+1,n-y+1)+1,l=0;
			// printf("%d %d\n",x,y);
			while(l<r)
			{
				int mid=(l+r)>>1;
				// printf("%d %lld %lld\n",mid,query(x,mid),query(y,mid));
				if(query(x,mid)==query(y,mid)) l=mid+1;
				else r=mid;
			}
			printf("%d\n",l-1);
			// printf("djhdjhfjhfgjuhdfgiodfg=%d\n",query(x,5)==query(y,5));
			// r--;
			// int d,p=0;
			// for(d=1;d<=r&&query(x,d)==query(y,d);d<<=1) ;
			// for(d>>=1;d;d>>=1) if(p+d<=r&&query(x,p+d)==query(y,p+d)) p+=d;
			// // printf("djhdjhfjhfgjuhdfgiodfg=%d\n",query(x,5)==query(y,5));
			// printf("%d\n",p);
		}
		else if(opt=='R')
		{
			char d=nc();while(d<'a'&&d>'z')d=nc(); ull val=d-'a'+1;
			update(x,val);
		}
		else
		{
			n++;
			char d=nc();while(d<'a'&&d>'z')d=nc(); ull val=d-'a'+1;
			insert(x,val);
		}
	}
	return 0;
}
```
推销个人blog [JZYshuraK](https://www.cnblogs.com/ShuraK/p/10132440.html)

---

## 作者：FutaRimeWoawaSete (赞：4)

# 前言~~一些闲扯~~
这道题考场上的毒瘤题目，刚开始打了一个分块然后发现自己根本不会维护插入操作，观察到询问个数比较少，觉得拿50pts还不如去赌数据于是敲了个vector + 二分，果不其然省选题目数据送我自闭……  
# 正文  
这道题我们看到插入操作，又发现要维护一个~~假LCP~~，于是我们考虑使用平衡树，在这里我打了个Splay。  
首先考虑建树，由于我们要维护一个~~假LCP~~，看到字符串要判相等果断写hash，于是我们的Splay就维护一下当前的字符是什么以及当前子树的hash值即可，部分代码如下：

定义：

```cpp
struct node
{
	int ch[2],size,ff;//左右儿子，子树大小，父亲节点 
	int c;//当前字符是什么(当然也可以记录字符最后计算hash时用c - '0'就行了，这里直接记录-'0'的值方便一些) 
	unsigned long long hash;//当前子树的hash值 
}t[Len];
```  

update()

update函数我们维护一下子树大小以及hash值，子树大小就是套路了，而hash值这里就需要用到hash的定义。  
记rsize为右子树的大小，```b[i]```为K的i次方，当前为u子树。  
由于我们现在这个子树还是符合以编号排序的，所以子树hash值就为左子树的hash值乘上```b[rsize + 1]```(在序列上就相当于乘上```b[r - l + 1]```)加上```t[u].c``` * ```b[rsize]``` (中间一个字符的hash)加上右子树的hash值。转成数学公式，即：
```
hash[u] = hash[ls(u)] * b[rsize + 1] + c[u] * b[rsize] + hash[rs(u)];
```
附部分代码：  
```cpp
void update(int x)
{
	t[x].size = t[t[x].ch[0]].size + t[t[x].ch[1]].size + 1;
	int rsize = t[t[x].ch[1]].size;
	t[x].hash = t[t[x].ch[1]].hash + (unsigned long long)t[x].c * b[rsize] + t[t[x].ch[0]].hash * b[rsize + 1];
}
```

build()

build就比较套路了，具体可以参考[P3391文艺平衡树](https://www.luogu.com.cn/problem/P3391)的建树过程，就相当于是根据id建树嘛，在这里不做过多讲解。  
附部分代码：  
```cpp
void build(int l,int r,int x)
{
	if(l > r) return;
	int mid = (l + r) >> 1;
	if(mid >= x) t[x].ch[1] = mid;
	else t[x].ch[0] = mid;
	t[mid].ff = x,t[mid].size = 1;
	if(l == r) return;
	build(l , mid - 1, mid) , build(mid + 1 , r , mid);
	update(mid);
}
int main()
{

	for(int i = 2 ; i <= n + 1; i ++) t[i].c = t[i].hash = s[i - 1] - '0';
	build(1 , n + 2 , root);
	root = (n + 3) >> 1,tot = n + 2;
}
```

rotate(),Splay()

rotate(),Splay()函数~~都是套路~~，Splay的模板往上套就完了。注意在Spaly转完后要更新一下root。  

Find()

Find(x)即寻找第x - 1个数在哪里。为什么是第x - 1个数呢？你之前插入的时候的1和n + 2是INF，所以才是第x - 1个数对吧。  
这里由于之和我们的插入顺序有关，所以不能像传统方式一样直接找，这里相当于查找排名为x的数，于是根据子树大小来写就OK了(还不理解的人就把他当getnum(rank)吧……)  
附部分代码：
```cpp
int Find(int x)
{
	int u = root;
	while(u)
	{
		int lsize = t[t[u].ch[0]].size;
		if(lsize + 1 == x) return u;
		else if(lsize + 1 < x) x -= lsize + 1,u = t[u].ch[1];
		else u = t[u].ch[0];
	}
}
```

insert()

insert()函数也有点不一样。这里你又不能直接去通过val值（实际也没有）来insert，我们就~~稍微恶毒一点~~。  
设插入的数位置为idx  
首先一波操作找到idx和idx + 1，然后把idx旋转到root，idx + 旋转到root的右儿子，然后我们就可以把现在的这个字符插入root的右儿子的左儿子了对吧。  
然后呢？  
插入呗……  
```cpp
void insert(int x,int w)
{
	int pre = Find(x + 1) , nex = Find(x + 2);
	Splay(pre , 0);
	Splay(nex , pre);
	t[nex].ch[0] = ++ tot;
	int Fx = tot;
	t[Fx].ff = nex;
	t[Fx].hash = t[Fx].c = w;
	Splay(Fx , 0);
}
```

Hash()

求一段区间的Hash值还是和文艺平衡树一样的套路，把pre翻到root然后把nex翻到pre的右儿子然后nex的左二子就是l ~ r区间对吧，这时候我们直接查询这颗子树的Hash大小即可。
```cpp
unsigned long long Hash(int l,int r)
{
	int pre = Find(l), nex = Find(r + 2);
	Splay(pre , 0);
	Splay(nex , pre);
	int Fx = t[nex].ch[0];
	return t[Fx].hash; 
}
```
# PS
注意一些细节：  
1.~~老生常谈~~Splay别写错了……  
2.注意一下什么时候update，不放心的~~多update几次也不会死人对吧~~；  
3.还是注意一下插入的边界值1和n + 2，然后每次查询修改插入的x一定要+1哦~  
差不多了  
放代码：  
这里借鉴了一下[@邓本永](https://www.luogu.com.cn/user/93041)的代码，毕竟我自己写的……貌似有点丑诶！  
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int Len = 4e5 + 5, K = 1e9 + 7;
int n,m,opt,x,y,root,tot;
unsigned long long b[Len];
struct node
{
	int ch[2],size,ff;//左右儿子，子树大小，父亲节点 
	int c;//当前字符是什么(当然也可以记录字符最后计算hash时用c - '0'就行了，这里直接记录-'0'的值方便一些) 
	unsigned long long hash;//当前子树的hash值 
}t[Len];
char s[Len],ss[2],sss[2];
void update(int x)
{
	t[x].size = t[t[x].ch[0]].size + t[t[x].ch[1]].size + 1;
	int rsize = t[t[x].ch[1]].size;
	t[x].hash = t[t[x].ch[1]].hash + (unsigned long long)t[x].c * b[rsize] + t[t[x].ch[0]].hash * b[rsize + 1];
}
void build(int l,int r,int x)
{
	if(l > r) return;
	int mid = (l + r) >> 1;
	if(mid >= x) t[x].ch[1] = mid;
	else t[x].ch[0] = mid;
	t[mid].ff = x,t[mid].size = 1;
	if(l == r) return;
	build(l , mid - 1, mid) , build(mid + 1 , r , mid);
	update(mid);
}
void rotate(int x)
{
	int y = t[x].ff,z = t[y].ff,k = t[y].ch[1] == x;
	t[z].ch[t[z].ch[1] == y] = x;
	t[x].ff = z;
	//
	t[y].ch[k] = t[x].ch[k ^ 1];
	t[t[x].ch[k ^ 1]].ff = y;
	//
	t[x].ch[k ^ 1] = y;
	t[y].ff = x;
	update(y),update(x); 
}
void Splay(int x,int goal)
{
	while(t[x].ff != goal)
	{
		int y = t[x].ff,z = t[y].ff;
		if(z != goal) (t[y].ch[1] == x) ^ (t[z].ch[1] == y) ? rotate(x) : rotate(y);
		rotate(x);
	}
	update(x);
	if(goal == 0) root = x;
}
int Find(int x)
{
	int u = root;
	while(u)
	{
		int lsize = t[t[u].ch[0]].size;
		if(lsize + 1 == x) return u;
		else if(lsize + 1 < x) x -= lsize + 1,u = t[u].ch[1];
		else u = t[u].ch[0];
	}
}
void insert(int x,int w)
{
	int pre = Find(x + 1) , nex = Find(x + 2);
	Splay(pre , 0);
	Splay(nex , pre);
	t[nex].ch[0] = ++ tot;
	int Fx = tot;
	t[Fx].ff = nex;
	t[Fx].hash = t[Fx].c = w;
	Splay(Fx , 0);
}

unsigned long long Hash(int l,int r)
{
	int pre = Find(l), nex = Find(r + 2);
	Splay(pre , 0);
	Splay(nex , pre);
	int Fx = t[nex].ch[0];
	return t[Fx].hash; 
}
int main()
{
	scanf("%s",s + 1);
	n = strlen(s + 1);
	b[0] = 1;
	for(int i = 1 ; i <= 250000 ; i ++) b[i] = b[i - 1] * K;
	for(int i = 2 ; i <= n + 1; i ++) t[i].c = t[i].hash = s[i - 1] - '0';
	build(1 , n + 2 , root);
	root = (n + 3) >> 1,tot = n + 2;
	scanf("%d",&m);
	while(m --)
	{
		scanf("%s",ss);
		if(ss[0] == 'Q')
		{
			scanf("%d %d",&x,&y);
			if(x > y) swap(x , y);
			int l = 0,r = tot - y - 1;
			while(l < r)
			{
				int mid = (l + r + 1) >> 1;
				if(Hash(x , x + mid - 1) == Hash(y , y + mid - 1)) l = mid;
				else r = mid - 1;
			}
			printf("%d\n",l);
		}
		else if(ss[0] == 'R')
		{
			scanf("%d",&x);
			scanf("%s",sss);
			char chan = sss[0];
			Splay(Find(x + 1) , 0);
			t[root].c = chan - '0';
			update(root);
		}
		else if(ss[0] == 'I')
		{
			scanf("%d",&x);
			scanf("%s",sss);
			char chan = sss[0];
			insert(x , chan - '0');
		}
	}
	return 0;
}
```
# 完结撒花！


---

## 作者：Jμdge (赞：4)

给同学看了看自己随机跳到的这道题，然后他给我秒指原题（就是这道）...果然刷题多就是不一样。。。于是做了这道题又滚去那道多组数据的了

# noteskey


我们考虑一眼看去没有修改的话果断整个串倒过来建个 SAM 倍增跑 LCP

但是有修改啊！

## Query

于是我们考虑二分 + HASH 在 log （~~用了平衡树要带平方的吧？~~） 时间内处理询问

## Replace

我们考虑在平衡树上直接删除 + 插入

## Insert

我们在平衡树上插入即可

## pushup

有点关键的其实是平衡树中的 $pushup$ ，那么我们考虑之前询问里说的 $HASH$ 做法，令每个节点的权值为用预处理的 pw 长度 $HASH$ 数组 维护的左儿子 + 当前点 + 右儿子的 $HASH$ 值， 而长度就是子节点的 $size$


## Build

我们考虑直接 $Insert$ 的话可能有点慢，于是我们笛卡尔树 $O(n)$ 构造，


>FAQ ：woc卡常？这玩意儿有什么好卡的

>没办法我常数大我也很绝望啊，上次我打标算退化成暴力分呢！


## 平衡树


然后平衡树首推 FHQ Treap 

你问我为什么？真爱党不解释



# care

然后注意这里有多组数据...别忘了清

还有 newnode 里把 son 信息归零


# code

~~又压行，又压行！~~

```
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#define fp(i,a,b) for(int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(int i=(a),I=(b)-1;i>I;--i)
#define go(G,u) for(int i=G.head[u],v=G.e[i].to;i;v=G.e[i=G.e[i].nxt].to)
#define ll unsigned int
using namespace std;
const int M=2e5+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} inline char cread(){ char c=getchar();
	for(;!isalpha(c);c=getchar()); return c;
} inline void reads(string& s){ char c=getchar();
	for(;!isalpha(c);c=getchar()); s=" ";
	for(;isalpha(c);c=getchar()) s+=c;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(int x,char chr='\n'){
    if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
} int n,m; string s; ll ha[M]={1};
namespace FHQTreap{ int root,tot,top,stk[M],son[M][2]; ll w[M]; arr siz,pos,ch;
	inline int Rand(){static int seed=131; return seed=int(seed*48271ll%(~0ull>>1));}
	inline int newnode(int x){int a=++tot; son[a][0]=son[a][1]=0;
		return siz[a]=1,w[a]=ch[a]=x,pos[a]=Rand(),a;
	}
	inline void pushup(int x){ siz[x]=siz[son[x][0]]+siz[son[x][1]]+1;
		w[x]=w[son[x][0]]*ha[siz[son[x][1]]+1]+ch[x]*ha[siz[son[x][1]]]+w[son[x][1]];
	}
	inline void build(string& s,int n){
		int a,b,c; b=stk[top=1]=newnode(s[1]-'a'+1);
		fp(i,2,n){ c=newnode(s[i]-'a'+1),a=0;
			for(;top&&pos[stk[top]]>pos[c];a=stk[top--],pushup(a));
			if(top) son[stk[top]][1]=c; son[c][0]=a;
			stk[++top]=c; if(top==1) b=c;
		} for(;top;--top) pushup(stk[top]); root=b;
	}
	int merge(int x,int y){ if(!x||!y) return x|y;
		if(pos[x]<pos[y]) return son[x][1]=merge(son[x][1],y),pushup(x),x;
		else return son[y][0]=merge(x,son[y][0]),pushup(y),y;
	}
	void split(int u,int k,int& x,int& y){ if(!u) return x=y=0,void();
		if(siz[son[u][0]]>=k) return split(son[y=u][0],k,x,son[u][0]),pushup(u),void();
		else return split(son[x=u][1],k-siz[son[u][0]]-1,son[u][1],y),pushup(u),void();
	}
	inline void Insert(int x,int ch){ int a,b=newnode(ch),c;
		split(root,x,a,c),root=merge(a,merge(b,c));
	}
	inline void Delete(int x){ int a,b,c;
		split(root,x-1,a,b),split(b,1,b,c),root=merge(a,c);
	}
	inline ll ask(int l,int r){ int a,b,c;
		split(root,r,a,c),split(a,l-1,a,b); ll ans=w[b];
		return root=merge(a,merge(b,c)),ans;
	}
	inline bool query(int x,int y,int len){
		return ask(x,x+len-1)==ask(y,y+len-1);
	}
} using namespace FHQTreap;
inline int Min(int a,int b){return a<b?a:b;}
int main(){ int op,x,y,l,r,mid;
	reads(s),n=s.length()-1,m=read();
	fp(i,1,2e5) ha[i]=ha[i-1]*131; build(s,n);
	fp(kkk,1,m){ op=cread();
		if(op=='Q'){ x=read(),y=read();
			for(l=1,r=Min(n-x,n-y)+1;l<=r;) mid=(l+r)>>1,
				query(x,y,mid)?l=mid+1:r=mid-1; print(r);
		} else if(op=='I') x=read(),++n,y=cread()-'a'+1,Insert(x,y);
		else if(op=='R') x=read(),y=cread()-'a'+1,Delete(x),Insert(x-1,y);
	} return Ot(),0;
}
```


# more

双倍经验（多组数据！）：  [STRLCP - Longest Common Prefix](https://www.luogu.org/problemnew/show/SP3109)




---

## 作者：λᴉʍ (赞：4)

[来水一篇题解](http://www.cnblogs.com/xzz_233/p/7489297.html)

后缀数组显然不行

LCP是可以二分+哈希算出来的

因为有插入操作所以平衡树维护

然后每次二分一下，把哈希值抠出来比较就行了


$hash[i]=hash[ls]+ch \times base^{size[rs]}+hash[rs]\times base^{size[ls]+1}$


（据说bzoj卡双哈希？？？


```cpp
// luogu-judger-disable-o2
// It is made by XZZ
#include<cstdio>
#include<algorithm>
#include<cstring>
#define Fname "bzoj_1014"
using namespace std;
#define rep(a,b,c) for(rg int a=b;a<=c;a++)
#define drep(a,b,c) for(rg int a=b;a>=c;a--)
#define erep(a,b) for(rg int a=fir[b];a;a=nxt[a])
#define il inline
#define rg register
#define vd void
#define fir first
#define sec second
#define pr pair<point,point>
#define mp make_pair
typedef unsigned int ll;
il int gi(){
    rg int x=0;rg char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x;
}
typedef struct node* point;
point null;
int seed=2333;
il int Rand(){return seed=seed*19260817ll%2147483647;}
const int maxn=1e5+2;
ll base[maxn],Base[maxn];
struct node{
    int size,rand,ch;
    ll h,H;
    point ls,rs;
    node(char _ch){
    ch=_ch-'`',rand=Rand(),size=1,ls=rs=null;
    h=H=ch;
    }
    il vd reset(){
    size=ls->size+rs->size+1;
    h=ls->h+base[ls->size]*ch+base[ls->size+1]*rs->h;
    H=ls->H+Base[ls->size]*ch+Base[ls->size+1]*rs->H;
    }
};
point root;
il point build(){
    char str[100010];
    scanf("%s",str+1);
    int n=strlen(str+1);
    point now,stk[n+2],lst;int top=0;
    rep(i,1,n){
    now=new node(str[i]),lst=null;
    while(top&&stk[top]->rand>now->rand)lst=stk[top],stk[top--]->reset();
    if(top)stk[top]->rs=now;
    now->ls=lst,stk[++top]=now;
    }
    while(top)stk[top--]->reset();
    return stk[1];
}
il point merge(point a,point b){
    if(a==null){b->reset();return b;}
    if(b==null){a->reset();return a;}
    if(a->rand<b->rand){a->rs=merge(a->rs,b);a->reset();return a;}
    else{b->ls=merge(a,b->ls);b->reset();return b;}
}
il pr split(point now,int num){
    if(now==null)return mp(null,null);
    point ls=now->ls,rs=now->rs;
    if(num==now->ls->size){now->ls=null,now->reset();return mp(ls,now);}
    if(num==now->ls->size+1){now->rs=null,now->reset();return mp(now,rs);}
    if(now->ls->size>num){
    pr T=split(now->ls,num);
    now->ls=T.sec,now->reset();
    return mp(T.fir,now);
    }else{
    pr T=split(now->rs,num-now->ls->size-1);
    now->rs=T.fir,now->reset();
    return mp(now,T.sec);
    }
}
il vd Get(char&ch){do ch=getchar();while(ch<'a'||ch>'z');}
il vd change(){
    int k=gi();char ch;Get(ch);
    pr T=split(root,k-1),TT=split(T.sec,1);
    TT.fir->ch=TT.fir->h=TT.fir->H=ch-'`';
    root=merge(T.fir,merge(TT.fir,TT.sec));
}
il vd ins(){
    int k=gi();char ch;Get(ch);
    pr T=split(root,k);
    root=merge(T.fir,merge(new node(ch),T.sec));
}
il pair<ll,ll>GetHash(int l,int r){
    pair<ll,ll>ret;
    pr T=split(root,l-1),TT=split(T.sec,r-l+1);
    ret=mp(TT.fir->h,TT.fir->H);
    root=merge(T.fir,merge(TT.fir,TT.sec));
    return ret;
}
il bool check(int&x,int&y,int mid){
    pair<ll,ll>a=GetHash(x,x+mid-1),b=GetHash(y,y+mid-1);
    return a.fir==b.fir&&a.sec==b.sec;
}
il vd solve(){
    int x=gi(),y=gi();
    int mid,l=0,r=min(root->size-x+1,root->size-y+1);
    while(l<r){
    mid=(l+r)>>1;
    if(check(x,y,mid+1))l=mid+1;
    else r=mid;
    }printf("%d\n",l);
}
int main(){
    null=new node('`');
    null->size=0;
    null->ls=null->rs=null;
    base[0]=1;
    rep(i,1,1e5)base[i]=base[i-1]*29;
    Base[0]=1;
    rep(i,1,1e5)Base[i]=Base[i-1]*23333;
    root=build();
    int m=gi();char opt;
    while(m--){
    do opt=getchar();while(opt<'A'||opt>'Z');
    if(opt=='Q')solve();
    else if(opt=='R')change();
    else ins();
    }
    return 0;
}
```

---

## 作者：大奕哥 (赞：4)

我们可以使用二分答案来计算。

至于添加和修改操作我们可以使用Splay来维护复杂度O(mlogn)当然Splay常数很大。

·#include<bits/stdc++.h>

```cpp
using namespace std;
const int N=150005,mod=9875321;
typedef long long ll;
int size[N],fa[N],c[N][2],v[N],h[N],p[N],n,m,cnt,rt;
char ch[N];
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void update(int x)
{
    size[x]=size[c[x][0]]+size[c[x][1]]+1;
    h[x]=(h[c[x][0]]+1ll*v[x]*p[size[c[x][0]]]%mod+1ll*h[c[x][1]]*p[size[c[x][0]]+1]%mod)%mod;
}
void rotate(int x,int &k)
{
    int y=fa[x],z=fa[y],l,r;
    l=(c[y][1]==x);r=l^1;
    if(k==y)k=x;else c[z][c[z][1]==y]=x;
    fa[y]=x;fa[x]=z;fa[c[x][r]]=y;
    c[y][l]=c[x][r];c[x][r]=y;
    update(y);update(x);
}
void splay(int x,int &k)
{
    while(x!=k)
    {
        int y=fa[x],z=fa[y];
        if(y!=k)
        {
            if(c[y][0]==x^c[z][0]==y)rotate(x,k);
            else rotate(y,k);
        }
        rotate(x,k);
    }
}
int find(int x,int k)
{
    if(size[c[x][0]]+1==k)return x;
    else if(size[c[x][0]]>=k)return find(c[x][0],k);
    else return find(c[x][1],k-size[c[x][0]]-1);
}
void insert(int k,int w)
{
    int x=find(rt,k),y=find(rt,k+1);
    splay(x,rt);splay(y,c[x][1]);
    int z=++cnt;c[y][0]=z;fa[z]=y;v[z]=w;
    update(z);update(y);update(x);
}
int query(int k,int w)
{
    int x=find(rt,k);int y=find(rt,k+w+1);
    splay(x,rt);splay(y,c[x][1]);
    int z=c[y][0];
    return h[z];
}
int solve(int x,int y)
{
    int l=1,r=min(cnt-x,cnt-y)-1,ans=0;
    while(l<=r)
    {
        int mid=l+r>>1;
        if(query(x,mid)==query(y,mid))l=mid+1,ans=mid;
        else r=mid-1;
    }
    return ans;
}
void build(int l,int r,int f)
{
    if(l>r)return;
    int mid=l+r>>1;
    fa[mid]=f;c[f][mid>=f]=mid;v[mid]=ch[mid]-'a'+1;
    if(l==r){
        size[mid]=1;h[mid]=v[mid];return;
    }
    build(l,mid-1,mid);build(mid+1,r,mid);
    update(mid);
}
int main()
{
    scanf("%s",ch+2);
    n=strlen(ch+2);int x,y;
    p[0]=1;for(int i=1;i<=150004;++i)p[i]=p[i-1]*27%mod;cnt=n+2;
    build(1,n+2,0);rt=(n+3)>>1;
    m=read();char s[5],d[5];
    for(int i=1;i<=m;++i)
    {
        scanf("%s",s);
        if(s[0]=='Q'){
            x=read();y=read();printf("%d\n",solve(x,y));
        }
        else if(s[0]=='R'){
            x=read();scanf("%s",d+1);x=find(rt,x+1);splay(x,rt);
            v[rt]=d[1]-'a'+1;update(rt);
        }
        else{
            x=read();scanf("%s",d+1);insert(x+1,d[1]-'a'+1);
        }
    }
    return 0;
}
```

---

## 作者：elijahqi (赞：3)

 
 http://www.elijahqi.win/2018/01/23/bzoj1014/

 http://blog.csdn.net/elijahqi/article/details/79139088

Description



火星人最近研究了一种操作：求一个字串两个后缀的公共前缀。比方说，有这样一个字符串：madamimadam，

我们将这个字符串的各个字符予以标号：序号： 1 2 3 4 5 6 7 8 9 10 11 字符 m a d a m i m a d a m 现在，

火星人定义了一个函数LCQ(x, y)，表示：该字符串中第x个字符开始的字串，与该字符串中第y个字符开始的字串

，两个字串的公共前缀的长度。比方说，LCQ(1, 7) = 5, LCQ(2, 10) = 1, LCQ(4, 7) = 0 在研究LCQ函数的过程

中，火星人发现了这样的一个关联：如果把该字符串的所有后缀排好序，就可以很快地求出LCQ函数的值；同样，

如果求出了LCQ函数的值，也可以很快地将该字符串的后缀排好序。 尽管火星人聪明地找到了求取LCQ函数的快速

算法，但不甘心认输的地球人又给火星人出了个难题：在求取LCQ函数的同时，还可以改变字符串本身。具体地说

，可以更改字符串中某一个字符的值，也可以在字符串中的某一个位置插入一个字符。地球人想考验一下，在如此

复杂的问题中，火星人是否还能够做到很快地求取LCQ函数的值。

Input

第一行给出初始的字符串。第二行是一个非负整数M，表示操作的个数。接下来的M行，每行描述一个操作。操

作有3种，如下所示

1、询问。语法：Qxy，x,y均为正整数。功能：计算LCQ(x,y)限制：1<=x,y<=当前字符串长度。

2、修改。语法：Rxd，x是正整数，d是字符。功能：将字符串中第x个数修改为字符d。限制：x不超过当前字

符串长度。

3、插入：语法：Ixd，x是非负整数，d是字符。功能：在字符串第x个字符之后插入字符d，如果x=0，则在字

符串开头插入。限制：x不超过当前字符串长度

Output

对于输入文件中每一个询问操作，你都应该输出对应的答案。一个答案一行。

Sample Input

madamimadam

7
Q 1 7
Q 4 8
Q 10 11

R 3 a
Q 1 7
I 10 a
Q 2 11
Sample Output

5
1
0
2
1
HINT

1、所有字符串自始至终都只有小写字母构成。


2、M<=150,000


3、字符串长度L自始至终都满足L<=100,000


4、询问操作的个数不超过10,000个。


对于第1，2个数据，字符串长度自始至终都不超过1,000


对于第3，4，5个数据，没有插入操作。


之前听闻过 说这是个平衡树的题？今天想了想嗯？？这怎么做 哦 对对哦这个可以那splay维护下hash值的  怎么搞 我首先建一棵平衡树出来 然后同时更新的时候计算hash值 怎么算 就hash[l]\*(size[r]+1)+hash[x]\*size[r]+hash[r]  然后怎么算答案 就是我们针对每个询问我去二分一下长度 然后每次都把这个长度的取出来比较下hash值即可 其他操作都同splay的基本操作

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 110000
using namespace std;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}
    while(ch<='9'&&ch>='0') x=x*10+ch-'0',ch=getchar();
    return x*f;
}
int n,c[N][2],fa[N],size[N],root,cnt,m;
char s[N],v[N],op[10];
unsigned int hs[N],p[N];
inline void update(int x){
    int l=c[x][0],r=c[x][1];
    size[x]=size[l]+size[r]+1;
    hs[x]=hs[l]*(p[size[r]+1])+p[size[r]]*(v[x]-'a'+1)+hs[r];
}
inline void build(int f,int l,int r){
    if (l>r) return;int mid=l+r>>1;
    c[f][mid>f]=mid;fa[mid]=f;v[mid]=s[mid];hs[mid]=s[mid]-'a'+1;
    if (l==r) {size[l]=1;return;}
    build(mid,l,mid-1);build(mid,mid+1,r);update(mid);
} 
inline void rotate(int x,int &tar){
    int y=fa[x],z=fa[y];
    if (y==tar) tar=x;else c[z][c[z][1]==y]=x;
    int l=c[y][1]==x,r=l^1;
    fa[c[x][r]]=y;fa[y]=x;fa[x]=z;
    c[y][l]=c[x][r];c[x][r]=y;update(y);update(x);
}
inline void splay(int x,int &tar){
    while(x!=tar){
        int y=fa[x],z=fa[y];
        if (y!=tar){
            if (c[y][0]==x^c[z][0]==y) rotate(x,tar);else rotate(y,tar);
        }rotate(x,tar);
    }
}
inline int find(int x,int sz){
    int l=c[x][0],r=c[x][1];
    if (size[l]+1==sz) return x;
    if (sz<=size[l]) return find(l,sz);else return find(r,sz-size[l]-1);
}
inline int split(int x,int y){
    int xx=find(root,x),yy=find(root,y);
    splay(yy,root);splay(xx,c[root][0]);return c[xx][1];
}
inline bool check(int x,int y,int mid){
    int xx=split(x,x+mid+1),tmp=hs[xx];
    int yy=split(y,y+mid+1),tmp1=hs[yy];
    return tmp==tmp1;
}
inline void print(int x){
    if (c[x][0]) print(c[x][0]);
    printf("%c %u\n",v[x],hs[x]);
    if (c[x][1]) print(c[x][1]);
}
int main(){
    freopen("bzoj1014.in","r",stdin);
    scanf("%s",s+2);n=strlen(s+2);root=n+3>>1;p[0]=1;m=read();cnt=n+2;
    for (int i=1;i<=100100;++i) p[i]=p[i-1]*27;build(0,1,n+2);
//    print(root);puts("");
    for (int i=1;i<=m;++i){
        scanf("%s",op);
        if (op[0]=='Q'){
            int x=read(),y=read();int l=1,r=min(cnt-x-1,cnt-y-1);
            while(l<=r){
                int mid=l+r>>1;
                if (check(x,y,mid)) l=mid+1;else r=mid-1;
            } printf("%d\n",r);
        }
        if (op[0]=='R'){
            int x=read();char cc[2];scanf("%s",cc);
            int tmp=split(x,x+2);v[tmp]=cc[0];hs[tmp]=cc[0]-'a'+1;
            update(fa[tmp]);update(root);
        }
        if (op[0]=='I'){
            int x=read()+1;char cc[2];scanf("%s",cc);
            int xx=find(root,x),yy=find(root,x+1);splay(yy,root);splay(xx,c[root][0]);
            v[++cnt]=cc[0];hs[cnt]=cc[0]-'a'+1;size[cnt]=1;fa[cnt]=xx;c[xx][1]=cnt;
            update(xx);update(root);
        } 
    }
    return 0;
}


```

---


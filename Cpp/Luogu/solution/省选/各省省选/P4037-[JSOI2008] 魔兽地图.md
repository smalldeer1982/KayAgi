# [JSOI2008] 魔兽地图

## 题目背景

本题疑似错题，不保证存在算法能通过该数据范围下的所有数据。目前所有题解的复杂度都是错误的，且绝大部分能被 https://www.luogu.com.cn/discuss/1112812 中的 Hack 卡掉。

## 题目描述

DotR (Defense of the Robots) Allstars 是一个风靡全球的魔兽地图，他的规则简单与同样流行的地图 DotA (Defense of the Ancients) Allstars。

DotR 里面的英雄只有一个属性——力量。他们需要购买装备来提升自己的力量值，每件装备都可以使佩戴它的英雄的力量值提高固定的点数，所以英雄的力量值等于它购买的所有装备的力量值之和。装备分为基本装备和高级装备两种。基本装备可以直接从商店里面用金币购买，而高级装备需要用基本装备或者较低级的高级装备来合成，合成不需要附加的金币。装备的合成路线可以用一棵树来表示。

比如，Sange and Yasha 的合成需要 Sange，Yasha 和 Sange and Yasha Recipe Scroll 三样物品。其中 Sange 又要用 Ogre Axe，Belt of Giant Strength 和 Sange Recipe Scroll 合成。每件基本装备都有数量限制，这限制了你不能无限制地合成某些性价比很高的装备。

现在，英雄 Spectre 有 $M$ 个金币，他想用这些钱购买装备使自己的力量值尽量高。你能帮帮他吗？他会教你魔法 Haunt（幽灵附体）作为回报的。

## 样例 #1

### 输入

```
10 59
5 A 3 6 1 9 2 10 1
1 B 5 3
1 B 4 3
1 B 2 3
8 A 3 2 1 3 1 7 1
1 B 5 3
5 B 3 3
15 A 3 1 1 5 1 4 1
1 B 3 5
1 B 4 3```

### 输出

```
33```

# 题解

## 作者：大奕哥 (赞：17)

一道背包的神题，用到了树上dp和背包dp，这个题的特殊性在于儿子对于父亲节点是有影响的，所以用f[i][j][k]表示第i号装备，其中用j个来合成上层装备，花费k元所能获得最大的力量值。

然后对于每一个节点枚举我选择合成几个，遍历每一个儿子节点，背包dp一下花费k元的最大力量值。注意这里的背包是一个分组背包，即对于每一个节点，我需要选择它的每一个叶子节点，这里每一个叶子都是一组物品（因为我需要枚举给每个叶子的花费），我需要选择每一组里的一个物品，所以是一个分组背包，最后用算出背包的g数组去更新f数组，同样是枚举话多少钱，把几个物品用于上层合成，然后转移状态。

安利blog

```cpp
http://www.cnblogs.com/nbwzyzngyl/p/8287860.html
#include<bits/stdc++.h>
using namespace std;
const int N=55;
int n,m,cnt,vv[N],head[N],v[N],f[N][105][2005],ans[2005],g[2005],L[N],p[N],M[N];
struct node{
    int to,nex,w;
}e[20005];
void add(int x,int y,int w)
{
    e[++cnt].to=y;e[cnt].nex=head[x];head[x]=cnt;e[cnt].w=w;vv[y]++;
}
void dp(int x)
{
    if(v[x])return;v[x]=1;
    if(!head[x]){
        L[x]=min(L[x],m/M[x]);
        for(int i=L[x];i>=0;--i)
        for(int j=i;j<=L[x];++j)
        f[x][i][j*M[x]]=p[x]*(j-i);
        return;
    }
    L[x]=1e9;
    for(int i=head[x];i;i=e[i].nex)
    {
        int y=e[i].to;dp(y);
        L[x]=min(L[x],L[y]/e[i].w);
        M[x]+=e[i].w*M[y];
    }
    L[x]=min(L[x],m/M[x]);
    for(int i=L[x];i>=0;--i)
    {
        memset(g,-0x3f,sizeof(g));g[0]=0;
        for(int j=head[x];j;j=e[j].nex)
        {
            int y=e[j].to;
            for(int a=m;a>=0;--a)
            {
                int t=-1e9;
                for(int b=0;b<=a;++b)
                t=max(t,g[a-b]+f[y][i*e[j].w][b]);
                g[a]=t;
            }
        }
        for(int j=0;j<=i;++j)
            for(int k=0;k<=m;++k)
            f[x][j][k]=max(f[x][j][k],g[k]+p[x]*(i-j));
    }
}
int main()
{
    memset(f,-0x3f,sizeof(f));
    scanf("%d%d",&n,&m);
    int k,x,y;
    for(int i=1;i<=n;++i)
    {
        scanf("%d",&p[i]);
        char s[3];scanf("%s",s);
        if(s[0]=='A'){
            scanf("%d",&k);
            for(int j=1;j<=k;++j)
            {
                scanf("%d%d",&x,&y);add(i,x,y);
            }
        }
        else{
            scanf("%d%d",&M[i],&L[i]);
        }
    }
    for(int i=1;i<=n;++i)
    if(!vv[i])
    {
        dp(i);
        for(int j=m;j>=0;--j)
        for(int k=0;k<=j;++k)
        ans[j]=max(ans[j],ans[j-k]+f[i][0][k]);
    }
    printf("%d\n",ans[m]);
    return 0;
}
```

---

## 作者：wzj423 (赞：11)

```cpp
#include <bits/stdc++.h>
typedef long long ll;
typedef double db;
#define Set0(x) memset(x,0,sizeof (x))
#define SetMax(x) memset(x,0x3f,sizeof (x))
#define SetMin(x) memset(x,0xc0,sizeof (x))
using namespace std;
int rd() {
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
/*
    对于每一个子树x,我们有
    f[x][i][k] 表示当前子树为x,有i个物品上交上一层合成(从而不计贡献但是计入成本),子树内一共投入了k元的最大收益
    一个子树的贡献有以下几个方面:
    1.其余儿子节点内部的贡献
    2.儿子节点上交的物品合成一部分当前节点物品,这一部分又有一部分被截留在当前节点,产生了贡献
    那么影响一个节点决策的因素有以下几个方面:
    1.投入
    2.合成几个
    3.上交几个
    其中1和3
    会影响父节点的决策,而2仅仅会影响子节点的决策,所以先枚举2,再讨论在多种情况2之下哪种1和3的组合最优
    当情况2确定的时候,相当于在做多重背包,而背包的条件因为2改变而改变,因而我们需要用g数组来暂存答案,用以更新f
    最后再用h数组对于f数组做一个多重背包,因为可能是一个森林.
*/
//defs=============================================
int N,K;
int L[55],M[55],P[55];//M单价,L上限
char ch[20];
//edge============================================
struct edge {
    int ed,nxt,vv;
}E[2000];
int head[55],Ecnt,deg[55];//入度
void addEdge(int st,int ed,int vv) {
    E[++Ecnt].ed=ed,E[Ecnt].nxt=head[st],head[st]=Ecnt;
    E[Ecnt].vv=vv;++deg[ed];
}
//dp==============================================
int f[55][105][2005];
int g[55][55][2005];
int h[55][2005];
void dp(int x) {
    //printf("dp in %d\n",x);
    if(head[x]==0) {//叶子节点
        L[x]=min(L[x],K/M[x]);//钱数限制
        for(int i=0;i<=L[x];++i) //上交几个
            for(int j=i;j<=L[x];++j) //制作几个
                f[x][i][j*M[x]]=(j-i)*P[x];
        return;
    }
    L[x]=0x3f3f3f3f;
    for(int i=head[x];i;i=E[i].nxt) {
        int ed=E[i].ed,vv=E[i].vv;
        dp(ed);
        L[x]=min(L[x],L[ed]/vv);
        M[x]+=M[ed]*vv;
    }
    L[x]=min(L[x],K/M[x]);//钱限制
//开始dp
    g[x][0][0]=0;//初始状态
    for(int l=L[x];l>=0;--l) {//倒序可以保证每一轮所选取的g[x][tot-1][j-k]中所包含的决策至少选取了l*vv个物品用于合成
        int tot=0;
        for(int i=head[x];i;i=E[i].nxt) {
            int ed=E[i].ed,vv=E[i].vv;
            ++tot;
            for(int j=0;j<=K;++j) {
                for(int k=0;k<=j;++k) {
                    g[x][tot][j]=max(g[x][tot][j],g[x][tot-1][j-k]+f[ed][l*vv][k]);
                }
            }
        }
        for(int i=0;i<=l;++i) {
            for(int j=0;j<=K;++j) {
                f[x][i][j]=max(f[x][i][j],g[x][tot][j]+P[x]*(l-i));
            }
        }
    }
}
//main============================================
int main() {
    SetMin(f),SetMin(g);
    N=rd(),K=rd();
    for(int i=1;i<=N;++i) {
        P[i]=rd();
        scanf("%s",ch);
        if(ch[0]=='B') {
            M[i]=rd(),L[i]=rd();
        } else {
            int up=rd();
            while(up--) {
                int v=rd(),num=rd();
                addEdge(i,v,num);
            }
        }
    }
    int tot=0;
    for(int x=1;x<=N;++x) {
        if(!deg[x]) {
            dp(x);++tot;
            for(int i=0;i<=K;++i) {//投入多少
                for(int j=0;j<=i;++j) {//之前投入多少
                    for(int k=0;k<=L[x];++k) {//上交几个物品
                        h[tot][i]=max(h[tot][i],h[tot-1][j]+f[x][k][i-j]);
                    }
                }
            }
        }
    }
    //puts("End");
    int ans=0;
    for(int i=1;i<=K;++i) {
        ans=max(ans,h[tot][i]);
    }
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：FutaRimeWoawaSete (赞：7)

这道题其实很有难度，是我目前遇到最难的一道树上背包了。    
首先认真审题(从这里就开始犯低级错误)，发现题目已经告诉我们低级合成高级的路径是一条树。    
树上，并且是个背包，这不就是[选课](https://www.luogu.com.cn/problem/P2014)这一类树上背包这种题吗？   
我们直接把每种合成路径建成一棵树，再把没有合成路径的基本装备当成一棵树，最后都把它们往 $0$ 节点上面连跑树$DP$。(这都是套路)     
也就是说我们可以用选课这道题的思路来解决这一道题，只不过操作起来确实麻烦很多。    
首先是预处理，比较简单。你现在看自己的儿子最多能选几个，那么你需要几个该儿子就直接把它最多能选几个除以当前你需要的个数然后所有值取$min$就好了。   
还可以维护当前这个装备需要的花费，放一下代码：   
```cpp
void dfs(int x)
{
	if(!head[x])
	{
		temp[x] = min(temp[x] , m / cost[x]);//temp就是当前装备最多能选几个
		return;
	}
	temp[x] = Inf;
	for(int e = head[x] ; e ; e = edge[e].next)
	{
		int to = edge[e].to;
		dfs(to);
		temp[x] = min(temp[x] , temp[to] / edge[e].num);
		cost[x] += edge[e].num * cost[to];//cost就是当前装备的花费
	}
	temp[x] = min(temp[x] , m / cost[x]);
}
```
到这里我就开始犯错了，这里首先讲一下我的错误想法：
```
dp[i][j]表示选到第i个用品此时背包空间大小为j
```
然后就直接树上$DP$。    
~~然后我就爆了。~~    
很明显我们这么进行状态定义是完全不对的，我们的基本装备是个数量有限的背包啊，那么我们怎么知道我们当前每种一共选了多少个基本装备呢？我们怎么知道当前的转移合不合法？    
思来想去完全搞不出来，最后给自己的计时超时了就~~瞟了瞟题解~~才知道了正确的$DP$状态：   
```
dp[i][j][k]表示第i个装备，其中用j个来合成父亲的装备，背包容量为k时所能获得最大收益。
```
于是这样我们就可以计算了，首先需要分情况讨论当前的点是不是叶子节点，如果是的话我们只能先用一个背包初始化才行：   
```cpp
if(!head[x])
	{
		for(int i = temp[x] ; i >= 0 ; i --)
			for(int j = i ; j <= temp[x] ; j ++)
				dp[x][i][j * cost[x]] = w[x] * (j - i);//有数量限制的dp的模板，在这里不做过多解释
		return;
	}
```
接着我们就可以跑$DP$了，第一层我们需要枚举我们选的当前装备个数，第二层就枚举儿子节点，第三四层正常背包就好了。   
最后拿出来再处理一遍前面的背包就好了。    
讲到这里也就差不多了，如果你还是写挂了可能需要注意一下你的$dp$数组是否先置为 $-Inf$ ，再其次就是你的$DP$是否在中间打挂了，不得不说这道题还是有点考细节。     
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector> 
using namespace std;
const int Len = 105,Inf = 0x3f;
bool flag[Len],flaw[Len];
long long n,m,w[Len],cost[Len],temp[Len],dp[55][105][2005],f[2005];
int head[Len],cnt,fa[Len],root[Len],len;
struct node
{
	int next,to,num;
}edge[Len << 1];
char s[2];
void add(int from,int to,int num)
{
	edge[++ cnt].to = to;
	edge[cnt].next = head[from];
	edge[cnt].num = num;
	head[from] = cnt;
}
void dfs(int x)
{
	if(!head[x])
	{
		temp[x] = min(temp[x] , m / cost[x]);
		return;
	}
	temp[x] = Inf;
	for(int e = head[x] ; e ; e = edge[e].next)
	{
		int to = edge[e].to;
		dfs(to);
		temp[x] = min(temp[x] , temp[to] / edge[e].num);
		cost[x] += edge[e].num * cost[to];
	}
	temp[x] = min(temp[x] , m / cost[x]);
}
void DP(int x)
{
	if(!x)
	{
		for(int e = head[x] ; e ; e = edge[e].next) 
		{
			DP(edge[e].to);
			for(int i = m ; i >= 0 ; i --)
				for(int j = 0 ; j <= i ; j ++)	
					dp[0][0][i] = max(dp[0][0][i] , dp[0][0][i - j] + dp[edge[e].to][0][j]);
		}
		return;
	}
	if(!head[x])
	{
		for(int i = temp[x] ; i >= 0 ; i --)
			for(int j = i ; j <= temp[x] ; j ++)
				dp[x][i][j * cost[x]] = w[x] * (j - i);
		return;
	}
	for(int e = head[x] ; e ; e = edge[e].next) DP(edge[e].to);
	for(int i = temp[x] ; i >= 0 ; i --)
	{
		memset(f , -Inf , sizeof f);
		f[0] = 0;
		for(int e = head[x] ; e ; e = edge[e].next)
		{
			int to = edge[e].to;
			for(int k = m ; k >= 0 ; k --)
			{
				long long t = -1e9;
				for(int p = 0 ; p <= k ; p ++)
					t = max(t , f[k - p] + dp[to][i * edge[e].num][p]);
				f[k] = t;
			}
		}
		for(int j = 0 ; j <= i ; j ++)
			for(int k = 0 ; k <= m ; k ++) 
				dp[x][j][k] = max(dp[x][j][k] , f[k] + w[x] * (i - j));
	}
}
int main()
{
	memset(dp , -Inf , sizeof dp);
	scanf("%lld %lld",&n,&m);
	for(int i = 0 ; i <= m ; i ++) dp[0][0][i] = 0;
	for(int i = 1 ; i <= n ; i ++)
	{
		scanf("%lld",&w[i]);
		scanf("%s",s);
		if(s[0] == 'A') 
		{
			int N;
			scanf("%d",&N);
			while(N --)
			{
				int x,y;scanf("%d %d",&x,&y);
				add(i , x , y);
				fa[x] = i;
			}
		}
		else if(s[0] == 'B') scanf("%lld %lld",&cost[i],&temp[i]);
	}
	for(int i = 1 ; i <= n ; i ++) if(!fa[i]) add(0 , i , 1);
	dfs(0);
	DP(0);
	printf("%lld\n",dp[0][0][m]);
	return 0;
}
```

---

## 作者：ISYRHH (赞：5)


## [JSOI2008]魔兽地图

------------

&emsp;[某机房dp巨佬](https://www.luogu.com.cn/user/207701)（%%%%%%%钛强了）给了我这道题，想了一节物理课出了点思路（~~物理课总是灵感的源泉~~）,被dalao不是很看好。坚持写出来后复杂度没错但是常数巨大，被卡到了60分……

&emsp;优化一年后终于过了这道题，发现和题解思路不大一样（明示我思路清奇？），于是写了这篇题解记录一下。

&emsp;（本题解和其他题解思路有些差异，因此导致卡常比较严重，可供学习参考，也是提供另一种思路）

------------


## 题意分析

&emsp;题目说明了合成过程是一棵树。所以一看就觉得是一道树上背包，仔细一看会发现有一些限制，而代价是在叶子节点上的。

&emsp;处理的话稍加思考就能想到要从底层往上合成，再将合成完本层剩下的钱最优化分到下层，这就是大体上的思想了。

------------


## 解法

&emsp;首先考虑将下一层的装备合成父亲不一定是最优的（显而易见），但是合成父亲的父亲可能是血赚的。

&emsp;而如果为了本层最优不合成本层的装备，不一定能满足合成上层装备的要求，即本成合成的装备数是会对上层产生影响的。

&emsp;对于这种问题，我们充分运用朴素（~~暴力~~）的思想，把本层合成的装备数也压成一维dp就好了……

&emsp;所以我们定义 $dp_{i,j,k}$ 为对于第x种装备，分到了j的钱，造了i个x以后剩下的钱分到子树中能产生的最大价值

&emsp;（这里是不算x的价值的，因为有的x可能是中间产物，被造成了更高级的装备，它本身的价值是不需要被计算的）

&emsp;然后考虑转移的过程，本层和下层钱数确定后，本层要造i个装备，所以下面几层至少要造 $i \cdot num$ 个(num为造一个x需要的下层y的个数），我们遍历一遍用来更新dp数组就可以了。

&emsp;这样我们就得到了一个 $O(nm^2v^2)$（数量限制为v）的算法，虽然说跑不满，但是毫无疑问，会被卡掉……

&emsp;再考虑一下当本层和下层钱数确定后，如果下层个数是递减遍历的，那么对于一个能满足较大本层个数i的下层个数j，它一定还能满足下一个较小的i。

&emsp;所以只需要记录一个变量now为能满足当前本层个数i的最优的下层贡献即可。

&emsp;实际处理过程中即为从大到小遍历一遍下层个数，一遍遍历一遍更新now，然后用now去更新dp就可以了。

&emsp;这样我们缩掉了一个v，实际的复杂度是 $O(nm^2v)$ 的。这也是一个&ensp;复&ensp;杂&ensp;度&ensp;正确的算法。

&emsp;实现一下就得到代码：

```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<cstdlib>
using namespace std;
#define INF 1145141919
struct edge
{
    int to,wei;
    edge(){}
    edge(int to,int wei):to(to),wei(wei){}
};
int n,m,dp[52][101][2001],w[52],c,in1,in2,lim[52],ans,mig[52];
vector<edge>ed[52];
char in;
bool vis[52],yd[52];
int minn(int x,int y)
{
    return x<=y?x:y;
}
int maxx(int x,int y)
{
    return x>=y?x:y;
}
void dfs(int x)
{
    vis[x]=true;
    if(yd[x])
    {
        for(int i=0;i<=m;i++)
        {
            for(int j=0;j<=lim[x];j++)
            {
                if(w[x]*j<=i)dp[x][j][i]=0;
            }
        }
        return;
    }
    lim[x]=100;
    for(vector<edge>::iterator ite=ed[x].begin();ite!=ed[x].end();ite++)
    {
        if(!vis[ite->to])dfs(ite->to);
        lim[x]=minn(lim[x],lim[ite->to]/ite->wei);
        w[x]+=w[ite->to]*ite->wei;
    }
    for(int i=0;i<=lim[x];i++)
    {
        for(int j=0;j<=m;j++)
        {
            dp[x][i][j]=0;
        }
    }
    for(vector<edge>::iterator ite=ed[x].begin();ite!=ed[x].end();ite++)
    {
        for(int i=m;i>0;i--)
        {
            for(int j=i;j>0;j--)
            {
                int now=-INF;
                for(int k=lim[ite->to];k>=0;k--)
                {
                    if(dp[ite->to][k][j]<0)continue;
                    if(j>=w[ite->to]*k)now=maxx(now+mig[ite->to],dp[ite->to][k][j]);
                    int hh=k/ite->wei;
                    if(hh<=lim[x]&&i>=hh*w[x]&&i-j>=hh*w[x]-w[ite->to]*k)dp[x][hh][i]=maxx(dp[x][hh][i],dp[x][hh][i-j]+now);
                }
            }
        }
    }
    for(int i=0;i<=lim[x];i++)
    {
        ans=maxx(ans,dp[x][i][m]+mig[x]*i);
    }
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&mig[i]);
        in=getchar();
        while(in!='A'&&in!='B')
        {
            in=getchar();
        }
        if(in=='A')
        {
            scanf("%d",&c);
            for(int j=1;j<=c;j++)
            {
                scanf("%d%d",&in1,&in2);
                ed[i].push_back(edge(in1,in2));
            }
        }
        else
        {
            yd[i]=true;
            scanf("%d%d",&w[i],&lim[i]);
        }
    }
    for(int i=1;i<=n;i++)
    {
        if(!vis[i])dfs(i);
    }
    printf("%d",ans);
    return 0;
}
```


&emsp;自信交上去……

![](https://z3.ax1x.com/2021/05/13/gByYqI.png)

&emsp;以正解16倍的大常数被卡掉了……

&emsp;是我们的优化就开始了……

&emsp;主要可以优化的部分是i,j,k的三重for循环，我们可以通过判断去掉一部分无用的状态，缩小常数。

&emsp;无用的状态有三种：

&emsp;&emsp;1.当要造儿子y的个数k与儿子y的花费之积超过了分给儿子y的钱数j时，很明显它是没有意义的，不需要更新now，不需要更新dp。

&emsp;&emsp;2.当要造x的个数与x的花费之积超过了x分到的钱数i时，这时的的状态也是没有意义的，不需要更新dp。

&emsp;&emsp;3.当要造k个x，分到其他儿子的钱数i-j，小于其他儿子至少要分到的钱时，这个j本身可能是有意义的，需要更新now，但对i是没有意义的，不能更新dp。

&emsp;考虑i,j的状态数是远大于k的状态数的，如果保持先i后j再k的循环顺序，剪枝的效率是很低的，因此我们要把k提到循环的前面。

&emsp;先将k提到j之前，对于j不同的情况，now是不能共用的，因为分到不同钱数，造k个儿子j的dp值是不同的。

&emsp;所以我们将now扩展一维，分别记录不同j下的now，由此将k提到j外面。

&emsp;另外考虑状态，将j分为两种情况，对于满足上述情况3的j，只用来更新now，满足情况1的j直接剪掉。

&emsp;于是我们又得到了一份代码：

```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<cstdlib>
using namespace std;
#define INF 1145141919
struct edge
{
    int to,wei;
    edge(){}
    edge(int to,int wei):to(to),wei(wei){}
};
int n,m,dp[52][101][2001],w[52],c,in1,in2,lim[52],ans,mig[52],ccn,now[2001];
vector<edge>ed[52];
char in;
bool vis[52],yd[52];
int minn(int x,int y)
{
    return x<=y?x:y;
}
int maxx(int x,int y)
{
    return x>=y?x:y;
}
void dfs(int x)
{
    vis[x]=true;
    if(yd[x])
    {
        return;
    }
    lim[x]=100;
    for(vector<edge>::iterator ite=ed[x].begin();ite!=ed[x].end();ite++)
    {
        if(!vis[ite->to])dfs(ite->to);
        lim[x]=minn(lim[x],lim[ite->to]/ite->wei);
        w[x]+=w[ite->to]*ite->wei;
    }
    for(vector<edge>::iterator ite=ed[x].begin();ite!=ed[x].end();ite++)
    {
        for(int i=m;i>0;i--)
        {
            memset(now,0xcf,sizeof(now));
            for(int k=lim[ite->to];k>=0;k--)
            {
                int xxx=w[ite->to]*k,hh=k/ite->wei,yyy=i-hh*w[x]+w[ite->to]*k;
                for(int j=i;j>yyy&&j>=xxx;j--)
                {
                    now[j]=maxx(now[j]+mig[ite->to],dp[ite->to][k][j]);
                }
                for(int j=minn(yyy,i);j>=xxx;j--)
                {
                    now[j]=maxx(now[j]+mig[ite->to],dp[ite->to][k][j]);
                    dp[x][hh][i]=maxx(dp[x][hh][i],dp[x][hh][i-j]+now[j]);
                }
            }
        }
    }
    for(int i=0;i<=lim[x];i++)
    {
        ans=maxx(ans,dp[x][i][m]+mig[x]*i);
    }
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&mig[i]);
        in=getchar();
        while(in!='A'&&in!='B')
        {
            in=getchar();
        }
        if(in=='A')
        {
            scanf("%d",&c);
            for(int j=1;j<=c;j++)
            {
                scanf("%d%d",&in1,&in2);
                ed[i].push_back(edge(in1,in2));
            }
        }
        else
        {
            yd[i]=true;
            scanf("%d%d",&w[i],&lim[i]);
        }
    }
    for(int i=1;i<=n;i++)
    {
        if(!vis[i])dfs(i);
    }
    printf("%d",ans);
    return 0;
}
```
&emsp;不自信地交上去，果然，又T了……

![](https://z3.ax1x.com/2021/05/13/gBbY9J.png)

&emsp;好歹又过了一个点，有点进步（自我安慰）。

&emsp;然后考虑怎么将k提到i之前……

&emsp;根据最开始的定义，我们可以发现，now只与j和k有关，它记录的是下一层的东西，实际上是和i没有关系的

&emsp;所以我们可以直接将now提到三重for循环外单独处理，将now再扩展一维，记录同样j,k下最优的now

&emsp;（这时的now已经可以认为是单独一个dp的内容了，它记录的是下层的儿子y分到j的钱数，先造k个y，再将剩下的钱自由分配，可以分配给子树，也可以再造几个y，不算最开始造的k个y能创造的最大价值）

&emsp;这时的i,j,k已经是无所谓顺序的了（只需要保证i递减（背包），状态有意义），我们可以肆意地将k提到最外层，然后将满足前面情况1,2,3的状态全部剪掉。

&emsp;另外此时的 $now_{k,j}$ 在j相同时，对于k递减一定是单调递增的。所以对于满足 $i\cdot num \leq k < (i+1)\cdot num$ 的所有k中，$k=i\cdot num$ 是最优的。

&emsp;因此只需要不需要遍历所有k，只需要遍历一遍i用最优的k更新答案就可以了。

&emsp;由此我们得到了最终代码：

------------

## 代码

```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<cstdlib>
using namespace std;
#define INF 1145141919
struct edge
{
    int to,wei;
    edge(){}
    edge(int to,int wei):to(to),wei(wei){}
};
int n,m,dp[52][101][2001],w[52],c,in1,in2,lim[52],ans,mig[52],ccn,now[102][2001];
vector<edge>ed[52];
char in;
bool vis[52],yd[52];
int minn(int x,int y)
{
    return x<=y?x:y;
}
int maxx(int x,int y)
{
    return x>=y?x:y;
}
void dfs(int x)
{
    vis[x]=true;
    if(yd[x])
    {
        return;
    }
    lim[x]=100;
    for(vector<edge>::iterator ite=ed[x].begin();ite!=ed[x].end();ite++)
    {
        if(!vis[ite->to])dfs(ite->to);
        lim[x]=minn(lim[x],lim[ite->to]/ite->wei);
        w[x]+=w[ite->to]*ite->wei;
    }
    //预处理本装备一件的造价和数量的上限。
    for(vector<edge>::iterator ite=ed[x].begin();ite!=ed[x].end();ite++)
    {
        memset(now,0xcf,sizeof(now));
        for(int k=lim[ite->to];k>=0;k--)
        {
            int yyy=k*w[ite->to];
            for(int i=m;i>=yyy;i--)
            {
                now[k][i]=maxx(now[k+1][i]+mig[ite->to],dp[ite->to][k][i]);
            }
        }
        //对每个儿子先处理出now。
        for(int k=0;k<=lim[x];k++)
        {
            int xxx=w[ite->to]*k*ite->wei,zzz=w[x]*k;
            for(int i=m;i>=zzz;i--)
            {
                int yyy=i-k*w[x]+w[ite->to]*k*ite->wei;
                for(int j=minn(i,yyy);j>=xxx;j--)
                {
                    dp[x][k][i]=maxx(dp[x][k][i],dp[x][k][i-j]+now[k*ite->wei][j]);
                }
            }
        }
        //对可行的状态更新dp。
    }
    for(int i=0;i<=lim[x];i++)
    {
        ans=maxx(ans,dp[x][i][m]+mig[x]*i);
    }
    //因为懒得找根就直接对节点更新答案了。
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&mig[i]);
        in=getchar();
        while(in!='A'&&in!='B')
        {
            in=getchar();
        }
        if(in=='A')
        {
            scanf("%d",&c);
            for(int j=1;j<=c;j++)
            {
                scanf("%d%d",&in1,&in2);
                ed[i].push_back(edge(in1,in2));
            }
        }
        else
        {
            yd[i]=true;
            scanf("%d%d",&w[i],&lim[i]);
        }
    }
    //分情况输入装备的情况。
    for(int i=1;i<=n;i++)
    {
        if(!vis[i])dfs(i);
    }
    //因为懒得找根就直接dfs了。
    printf("%d",ans);
    //输出。
    return 0;
}
```
&emsp;于是终于AC了……
![](https://z3.ax1x.com/2021/05/13/gBbt39.png)
## **end**

---

## 作者：木xx木大 (赞：4)

[P4037 [JSOI2008]魔兽地图](https://www.luogu.com.cn/problem/P4037)

设$P_x,L_x,M_x$。表示物品 $x$ 的能量，购买上限与价格。$L_x=min（L_x，\frac {m}{M_x}）$。从高级装备向合成它所需要的的低级装备连边，边权 $w$ 为需要这种低级物品的数量。高级装备的 $M$ 和 $L$ 可以由低级装备推出。 

设 $f_{i,j,k}$表示第 $i$ 个物品，有 $j$ 件用于上层的合成，花费金钱是 $k$ 所能获得的最大力量。用 $g_{i,j}$表示 $x$ 的前 $i$ 个儿子的子树，花费 $j$ 的钱，所能获得的最大力量。对于以 $x$ 为根的子树，倒序枚举合成 $l$ 个 $x$ 物品（以保证每一轮所选取的 $g_{tot-1,j-k}$中所包含的决策至少选取了 $l\times  w$ 个物品用于合成），再用其余的钱买一些 $x$ 子树内的装备不用于合成。$g_{tot,j}=max \{ g_{tot-1,j-k}+f_{v,l\times w,k } \}$。即从 $j$ 中拿出 $k$ 的钱在 $v$ 的子树内购买。

最后再枚举合成的 $l$ 个 $x$ 物品中有 $j$ 个是直接用于增加力量，剩余用于合成的$f_{x,j,k}=max\{ g_{tot,k}+P_x\times (l-j)\}$

代码和别的题解差不多。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct edg{
	int to,nxt,w;
}e[20005]; 
int cnt,head[55],f[55][105][2005],g[55][105][2005],L[55],M[55],P[55],n,m;
int ru[55],h[55][2005];
void add(int u,int v,int w)
{
	cnt++;
	e[cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
	e[cnt].w=w;
	ru[v]++;
}
void dp(int u)
{
	if(!head[u])
	{//f[i][j][k]表示第i个物品，有j个用于合成上层，花费为k的最小代价 
		L[u]=min(L[u],m/M[u]);
		for(int i=0;i<=L[u];i++)//枚举上交i个 
			for(int j=i;j<=L[u];j++)//购买j个 
				f[u][i][j*M[u]]= (j-i)*P[u]; 
		return;
	}
	L[u]=0x3f3f3f3f;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		dp(v);
		L[u]=min(L[u],L[v]/e[i].w);
		M[u]+=e[i].w*M[v];
	}
	L[u]=min(L[u],m/M[u]);
	g[u][0][0]=0;
	for(int l=L[u];l>=0;l--)
	{
		int tot=0;
		for(int i=head[u];i;i=e[i].nxt)
		{
			tot++;
			int v=e[i].to;
			for(int j=0;j<=m;j++)//前tot个子树花了j块金币	
				for(int k=0;k<=j;k++)
					g[u][tot][j]=max(g[u][tot][j],g[u][tot-1][j-k]+f[v][l*e[i].w][k]);
		}
		for(int j=0;j<=l;j++)
			for(int k=0;k<=m;k++)
				f[u][j][k]=max(f[u][j][k],g[u][tot][k]+(l-j)*P[u]);
	}
 } 
int main()
{
	scanf("%d%d",&n,&m);
	memset(f,-0x3f,sizeof(f));
	memset(g,-0x3f,sizeof(g));
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&P[i]);
		char ch=getchar();
		while(ch!='A'&&ch!='B')ch=getchar();
		if(ch=='A')
		{
			int c;
			scanf("%d",&c);
			while(c--)
			{
				int v,w;
				scanf("%d%d",&v,&w);
				add(i,v,w);
			}
		}
		else scanf("%d%d",&M[i],&L[i]);
	}
	int tot=0,ans=0;
	for(int x=1;x<=n;x++)
	{
		if(!ru[x])
		{
			dp(x);
			tot++;
			for(int i=0;i<=m;i++)//前tot个子树花了i块金币	
				for(int j=0;j<=i;j++)
					for(int k=0;k<=L[x];k++)
						h[tot][i]=max(h[tot][i],h[tot-1][j]+f[x][k][i-j]);
		}
	}
	for(int i=0;i<=m;i++)
		ans=max(ans,h[tot][i]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：q779 (赞：3)


题目链接：[P4037 [JSOI2008]魔兽地图](https://www.luogu.com.cn/problem/P4037)

容易发现这是一个十分有(dú)趣(liú)的树上背包问题

高级装备和基本装备显然有树形的依赖关系

按照高级->高级->基本的方式进行建图，$(u,v)$ 的边权就是合成 $u$ 需要的 $v$ 个数

于是可以由此建出一个**森林**，因此最后dp的时候要加个虚拟结点啥的

设 $P[x],L[x],M[x]$ 分别表示物品 $x$ 的价值、购买上限和花费

对于基本装备（叶子结点），显然要进行```L[x]=min(L[x],m/M[x])```的操作

设 $f[u][j][k]$ 表示 $u$ 装备所在子树，上传 $j$ 个 $u$ 装备用于给上层合成（也就是不计算这 $j$ 个的贡献），且所在子树花费的总金额为 $k$ 是能获得的最大价值

对于一个 $u$ ，它对父亲的贡献分为两方面

* 它所在的子树的贡献（价值），包括儿子的以及自己没上传的
*  $u$ 上传的 $u$ 装备的个数，以用于父亲的合成

则我们首先要知道对于每个结点究竟合成几个

考虑枚举 $l$ ，表示 $u$ 要合成 $l$ 个（上传+自己私藏的）

然后我们就可以枚举上传几个以及花费多少了

如何知道对 $u$ 所在子树花费 $k$ 能获得的最大价值是多少呢

这个需要我们再单独做一个临时的dp

设 $g[i][j]$ 表示对于 $u$ 所在子树，只考虑 $u$ 的前 $i$ 个儿子所在子树，花费为 $j$ 时能获得的最大价值（这里不用记录 $u$ ，因为只是临时的dp）

则有
$$
g[i][j+k]=\max(g[i][j+k],g[i-1][j]+f[v][l\times w(u,v)][k])
$$

* 这里为什么是 $l\times w(u,v)$ ？因为已经枚举了当前要合成 $l$ 个

* 这里为什么max的第一个不是 $g[i-1][j+k]$ ？因为我们每个子树都要拿材料啊

  所以这里只是代码这么写而已，

  相当于 $g[i][j+k]=\max\{g[i-1][j]+f[v][l\times w(u,v)][k]\}$

* ~~这里为什么是 $j+k$ ？因为我喜欢刷表法，当然可以填表法~~

然后就可以愉快地推出 $f$ 的转移方程了
$$
f[u][j][k]=\max(f[u][j][k],g[k]+(l-j) \times P[u])
$$
细节巨多，详见代码（~~这次有注释了qwq~~）

时间复杂度的宽松上界为 $O(100\times nm^2)$

实际剪枝+时限3.00s，可以```444ms```跑过所有点（~~嘿嘿所以我是目前最优解~~

代码：

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <iomanip>
using namespace std;
#define int long long
#define INF 0x3f3f3f3f3f3f3f3f
#define N (int)(55)
#define SZ (int)(2e3+15)

int n,m;
int P[N],M[N],L[N],tmp[SZ],h[SZ],f[N][105][SZ],g[SZ];
struct Edge
{
    int u,v,w,next;
}e[N*N];
int pos=1,head[N],in[N];
void addEdge(int u,int v,int w)
{
    e[++pos]={u,v,w,head[u]};
    head[u]=pos;++in[v];
}
void DP(int u)
{
    if(!head[u])
    {
        L[u]=min(L[u],m/M[u]);
        for(int i=0; i<=L[u]; i++)
            for(int j=i; j<=L[u]; j++)
                f[u][i][j*M[u]]=(j-i)*P[u]; // j-i的会被私藏起来 qwq
        return;
    }
    L[u]=INF;
    for(int i=head[u]; i; i=e[i].next)
    {
        int v=e[i].v; DP(v);
        L[u]=min(L[u],L[v]/e[i].w); // 木桶能装多少水，和最短的那块板有关
        M[u]+=e[i].w*M[v];
    }
    L[u]=min(L[u],m/M[u]); // 当然了，钱不够“木板”长也是没用的
    for(int l=0; l<=L[u]; l++)
	// 题解区都说是倒序枚举，表示不明白，正着枚举也可以过
	// 他们的解释是，倒序枚举可以保证每一轮选的g[j]中所包含的决策至少选取了l*w个物品用于合成
	// 可是如果没法选取l*w个物品的话，每一轮的g[j]（也就是tmp[j]）肯定是-INF了，应该不会影响答案的正确性
	// 不太懂他们什么意思，如果我错了欢迎hack awa
    {
        memset(g,0xc0,sizeof(g));
        g[0]=0; // 滚动数组优化
        for(int i=head[u]; i; i=e[i].next)
        {
            int v=e[i].v,w=e[i].w;
            for(int j=0; j<=m; j++)
                tmp[j]=g[j],g[j]=-INF; // 注意转移方程不是从g[i-1][j+k]转移的
            for(int j=0; j<=m; j++)
                for(int k=0; tmp[j]>=0&&j+k<=m; k++) // 重要剪枝
                    g[j+k]=max(g[j+k],tmp[j]+f[v][l*w][k]);
        }
        for(int j=0; j<=l; j++)
            for(int k=0; k<=m; k++)
                f[u][j][k]=max(f[u][j][k],g[k]+(l-j)*P[u]);
    }
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    // freopen("check.in","r",stdin);
    // freopen("check.out","w",stdout);
    cin >> n >> m;
    memset(f,0xc0,sizeof(f));
    for(int i=1,l; i<=n; i++)
    {
        char ch;
        cin >> P[i] >> ch;
        if(ch=='A')
        {
            cin >> l;
            for(int j=1,v,w; j<=l; j++)
                cin >> v >> w,addEdge(i,v,w);
        }
        else cin >> M[i] >> L[i];
    }
    for(int u=1; u<=n; u++)
    {
        if(!in[u]) // 森林
        {
            DP(u);
            for(int i=0; i<=m; i++)
                tmp[i]=h[i],h[i]=0;
            for(int i=0; i<=m; i++)
                for(int j=0; i+j<=m; j++)
                    h[i+j]=max(h[i+j],tmp[i]+f[u][0][j]); 
				// 虚拟结点不用也无法合成物品，显然子结点上传只会浪费
        }
    }
    int res=-INF;
    for(int i=0; i<=m; i++)
        res=max(res,h[i]);
    cout << res << '\n';
    return 0;
}
```

参考了很多的题解，就不一一列出来了 qwq

**转载请说明出处**

---

## 作者：ckain (赞：3)

### 提供一种新思路
现有的大部分题解记 $f[u][i][j]$ 为 $u$ 装备保留 $i$ 个给父亲，子树总花费为 $j$ 的最大力气值。

我的状态记 $f[u][i][j]$ 为u装备至少生产 $i$ 个，子树总花费为 $j$ 的最大力气值。

在操作上会复杂一些，但是感觉上可能更加直观。

先处理出 $F[u][i][j]$ 为u装备刚好生产 $i$ 个，子树总花费为 $j$ 的最大力气值。

易得 $\displaystyle f[u][i][j]=\max_{i\le k}F[u][k][j]$，做一个关于第二维的后缀最小值顺序递推即可。

同时可以注意到，给出的图可能是森林，那么要为再为散开的树设计一个背包综合答案。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
inline void rd(int &x){
	int s=0,f=1; char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=0; c=getchar();}
	while(c>='0'&&c<='9'){s=s*10+c-48; c=getchar();}
	x=f? s:-s;
}
const int N=55,M=2e3+5,inf=1e9;
struct edge{int to,w,nt;} e[M]; int hd[N],ect;
void ade(int u,int v,int w){e[++ect]={v,w,hd[u]}; hd[u]=ect;}

int n,m,in[N],val[N],Lim[N],Cost[N];
int f[N][105][M],g[M];
//f[u][i][j] u装备生产至少 i个，总花费为 j，最大力量值 
//g[]为树上背包时的辅助转移的临时数组 
void cklp(int F[][M],int u){
	for(int i=Lim[u]-1; ~i; i--){
		for(int j=0; j<=m; j++){
			F[i][j]=max(F[i][j], F[i+1][j]);
		}
	}
}

void dfs(int u){
	memset(f[u],~63,sizeof(f[u]));
	if(!hd[u]){
		Lim[u]=min(Lim[u],m/Cost[u]);
		for(int i=0; i<=Lim[u]; i++)
			f[u][i][i*Cost[u]]=i*val[u];
		cklp(f[u], u);
		return;
	}
	Lim[u]=inf;
	for(int i=hd[u]; i; i=e[i].nt){
		int v=e[i].to, w=e[i].w;
		dfs(v);
		Lim[u]=min(Lim[u], Lim[v]/w);
		Cost[u]+=Cost[v]*w;
	}
	Lim[u]=min(Lim[u],m/Cost[u]);
	
	for(int i=0; i<=Lim[u]; i++){
		memset(g,~63,sizeof(g)); g[0]=0;
		for(int Ei=hd[u]; Ei; Ei=e[Ei].nt){
			int v=e[Ei].to, w=e[Ei].w;
			for(int j=m; ~j; j--){
				int t=-inf;
				for(int k=0; k<=j; k++)
					t=max(t, f[v][i*w][k]+g[j-k]-i*w*val[v]);
				g[j]=t;
			}
		}
		for(int j=0; j<=m; j++) f[u][i][j]=g[j]+i*val[u];
	}
	cklp(f[u], u);
}

int dp[M];

signed main(){
	rd(n); rd(m);
	for(int i=1; i<=n; i++){
		rd(val[i]);
		char opt; cin>>opt;
		if(opt=='A'){
			int c; cin>>c;
			for(int j=1,v,w; j<=c; j++){
				rd(v); rd(w); ade(i,v,w);
				in[v]++;
			}
		}
		else{
			rd(Cost[i]); rd(Lim[i]);
		}
	}
	memset(dp,~63,sizeof(dp)); dp[0]=0;
	for(int i=1; i<=n; i++){
		if(in[i]) continue;
		dfs(i);
		for(int j=m; ~j; j--){
			for(int k=0; k<=j; k++){
				dp[j]=max(dp[j], dp[j-k]+f[i][0][k]);
			}
		}
	}
	int ans=0;
	for(int i=0; i<=m; i++) ans=max(ans, dp[i]);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Code_星云 (赞：2)

非常好的一道树上背包。

先分析题目。我们发现对于一种装备，它要么不升级，用自己来贡献答案；要么升级，获取高阶装备的贡献。因此普通树上背包的状态不够转移，考虑多添加一位。因此我们用 $dp_{u,i,j}$ v表示在 $u$ 的子树中，$u$ 会向他的父节点提供 $i$ 个自己，同时 $u$ 子树内的花费为 $j$ 时的最大力量值。

首先考虑叶子节点的初始化。对于每个叶子节点的装备，我们枚举其选了多少个（用 $i$ 表示），然后枚举它向父亲贡献的个数（$j$）。此时它的贡献即为 $p_{leaf} \times (i - j)$。

然后考虑转移。最外层枚举合成了多少个该物品（$i$），然后每次统计在 $i$ 的情况下对于每个花费的值。对于一个花费 $j$，$g_j = g_{j - k} + dp_{son,i \times w,k}$，其中 $k$ 表示当前子树的枚举花费值。由于要选 $i$ 个此物品，那么它的每个子节点都必须向它提供合成材料，即 $i \times w$，其中 $w$ 表示兑换比值。然后把 $g$ 里临时存放的转移的值并到 $dp$ 上。

需要注意，此题可能是个森林，因此在外面还要做一次背包。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 52;
const int M = 2005;
const int inf = 1e9;
struct edges{
	int to, next, w;
};
edges edge[N << 1];
int n, m, cnt = 0;
int p[N], cost[N], lim[N], in[N], head[N], g[M], dp[N][2 * N][M], ans[M];

void add_edge(int u, int v, int w){
	edge[++ cnt].to = v;
	edge[cnt].next = head[u];
	edge[cnt].w = w;
	head[u] = cnt;
}
void dfs(int u){
	if(! head[u]){
		lim[u] = min(lim[u], m / cost[u]);
		for(int i = 0; i <= lim[u]; i ++)
		  for(int j = 0; j <= i; j ++)
			dp[u][j][i * cost[u]] = p[u] * (i - j);
		return;
	}
	lim[u] = inf; cost[u] = 0;
	for(int i = head[u]; i; i = edge[i].next){
		int v = edge[i].to, w = edge[i].w;
		dfs(v);
		cost[u] += cost[v] * w;
		lim[u] = min(lim[u], lim[v] / w);
	}
	lim[u] = min(lim[u], m / cost[u]);
	for(int i = lim[u]; i >= 0; i --){
		memset(g, -0x3f, sizeof g); g[0] = 0;
    	for(int ii = head[u]; ii; ii = edge[ii].next){
		  int v = edge[ii].to, w = edge[ii].w;
		    for(int j = m; j >= 0; j --){
		      int tmp = -inf;
			  for(int k = 0; k <= j; k ++)
			    tmp = max(tmp, g[j - k] + dp[v][i * w][k]);
			  g[j] = tmp;
			}
		}
	    for(int j = 0; j <= i; j ++)
	      for(int k = 0; k <= m; k ++)
	        dp[u][j][k] = max(dp[u][j][k], g[k] + (i - j) * p[u]);
	}
}
int main(){
	memset(dp, -0x3f, sizeof dp);
	scanf("%d %d", &n, &m);
	for(int i = 1; i <= n; i ++){
		scanf("%d", &p[i]);
		char c; cin >> c;
		if(c == 'A'){
			int cs; scanf("%d", &cs);
			for(int j = 1; j <= cs; j ++){
				int v, w; scanf("%d %d", &v, &w);
				add_edge(i, v, w);
				in[v] ++;
			}
		}else scanf("%d %d", &cost[i], &lim[i]);
	}
	for(int i = 1; i <= n; i ++){
		if(in[i]) continue;
		dfs(i);
		for(int j = m; j >= 0; j --)
		  for(int k = 0; k <= j; k ++) ans[j] = max(ans[j], ans[j - k] + dp[i][0][k]);
	}
	printf("%d\n", ans[m]);
	return 0;
}
```


---

## 作者：hnczy (赞：1)

一道非常综合的背包题。

我们发现每一个点的选择对它的父亲的合成有影响。

这样的话我们可以尝试把这个因素记下来。

$f_{rt,i,j}$ 来表示 $rt$ 及它的子树中选择 $i$ 个作为合成的材料的话，花费 $j$ 的最大战斗力。

这样的话我们就可以直接用多重背包来写了。

先枚举 $rt$ 的合成数量，在对每一个子树枚举，多重背包更新即可。

这里最好在转移的时候再加一个 $g$ 数组，来记一下在此合成数量的花费为 $i$ 时的最大收益。

每次清空一下即可。

可能有森林的情况，所以要把每一个点都枚举过来。

代码还是比较短的，重要在多重背包的写法，可以借鉴一下。

```c++
#include<bits/stdc++.h>
#define pii pair<int,int>
using namespace std;
const int N=55,inf =1e9;
int n,m,a[N],b[N],cnt[N],d[N],fa[N],f[55][105][2005],g[2005],ans;
//表示f[u][i][j] u这个子树 i的花费,j用于合成的最大贡献
char c;
void tomax(int &x,int y){if(x<y)x=y;}
vector<pii>e[N];
void dfs(int rt) {
	for(auto p:e[rt]) {
		int u=p.first,c=p.second;
		dfs(u);
		cnt[rt]=min(cnt[rt],cnt[u]/c);
		b[rt]+=b[u]*c;
	}
	cnt[rt]=min(cnt[rt],m/b[rt]);
	for(int i=0; i<=cnt[rt]; i++){//至多能拥有多少 
		int now=i*b[rt];
		memset(g,0,sizeof g);
		for(auto tmp:e[rt]) {
			int u=tmp.first,c=i*tmp.second;//需要的数量 
			for(int k=m; k>=0; k--) 
				for(int o=0; o<=k; o++) 
					tomax(g[k],g[k-o]+f[u][c][o]);
		}
		for(int j=0; j<=i; j++) 
			for(int k=m; k>=now; k--) 
				tomax(f[rt][j][k-j*b[rt]],g[k-now]+(i-j)*a[rt]),tomax(ans,f[rt][j][k]);
	}
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++) {
		cin>>a[i]>>c;
		if(c=='A') {
			scanf("%d",&d[i]);
			cnt[i]=inf;
			for(int j=1,num,id; j<=d[i]; j++) {
				scanf("%d%d",&id,&num);
				e[i].push_back({id,num});
				fa[id]=i;
			}
		} else scanf("%d%d",&b[i],&cnt[i]);
	}
	for(int i=1;i<=n;i++)if(!fa[i])dfs(i);
	cout<<ans;
	return 0;
}

```

常数可能有点大，需要加快读才能过。

---

## 作者：Acoipp (赞：1)

## 题目简述
给定一个森林，共有 $n$ 个节点，每个节点的装备具有“力量值”，如果一个节点有子节点，那么它必须通过子节点的装备的合并获得；否则，这个节点的装备可以直接购买，但有购买限制，最多不超过 $100$ 个。

问：你有 $m$ 个金币，最多能够通过购买和合成获得多少“力量值”。

数据范围：$1 \le n \le 51,0 \le m \le 2 \times 10^3$。

## 思路
题目中特别说明是一棵树，转移是从儿子节点向祖先节点转移，那么肯定是一个树形 DP；再加上，题目有金币限制，即背包体积，每个物品有权值（“力量值”），所以这道题是一个树上背包。

那么又因为每个节点有三个属性：节点编号，多少个合成上层装备，以及当前子树中花费了多少金币，我们就设三维的 DP 数组 $dp_{i,j,k}$，三者的上界分别是 $n,100,m$。

## 推导

我们按照树形 DP 的顺序来。

第一步，先处理没有子节点的情况。

根据题意，这种节点的装备是可以直接购买的，但是有购买限制，所以设购买限制为 $num_x$，枚举一共购买的个数，和合成上层设备的个数，就可以进行 DP 转移了。

```cpp
//mon数组为当前设备购买一个消耗的金币数量。
num[x] = min(num[x],m/mon[x]);
for(ll i=num[x];i>=0;i--){           //枚举多少个合成上层设备
	for(ll j=i;j<=num[x];j++){   //枚举一共购买个数
		dp[x][i][j*mon[x]] = a[x]*(j-i);
	}
}
```
第二步，有子节点的情况。

这种节点必须通过另外的装备合成获得，我们首先计算最多能够合成多少个。

```cpp
//各数组含义同上
num[x] = LLONG_MAX;                  //初始化
for(ll i=0;i<op[x].size();i++){
	dfs(op[x][i].first);         //递归
   	//子节点最多合成数量除以合成祖先节点的花费（向下取整）
	num[x] = min(num[x],num[op[x][i].first]/op[x][i].second);
	//同时记录合成一个该装备的价值
	mon[x] += mon[op[x][i].first]*op[x][i].second;
}
//最后看钱够不够
num[x] = min(num[x],m/mon[x]);
```

然后，进行 DP。
```cpp
for(ll i=num[x];i>=0;i--){      //枚举一共购买多少个当前装备
	//temp[x]表示花费x个金币最多获得多少力量值
	memset(temp,-0x3f,sizeof(temp));
	temp[0] = 0;
	for(ll j=0;j<op[x].size();j++){
		for(ll k=m;k>=0;k--){
			ll ttt = -3e9;
			for(ll l=0;l<=k;l++) ttt=max(ttt,temp[k-l]+dp[op[x][j].first][i*op[x][j].second][l]);
			temp[k] = ttt;
		}
	}
	for(ll j=0;j<=i;j++){   //枚举用多少个当前装备合成上层装备
		for(ll k=0;k<=m;k++){  //枚举花费的金额
			dp[x][j][k] = max(dp[x][j][k],temp[k]+a[x]*(i-j));
		}
	}
}
```

第三步，合并答案。

对于所有树的根节点，我们从上往下进行树形 DP，最后新建一个 $ans$ 数组，对于这些根节点进行分组背包，这样，这道题就完成了。
```cpp
for(i=1;i<=n;i++){
	if(root[i]){
		dfs(i);
		for(j=m;j>=0;j--) for(k=0;k<=j;k++) ans[j]=max(ans[j],ans[j-k]+dp[i][0][k]);    //对于dp[i][0][k]进行分组背包
	}
}
```
最终的答案即为 $ans_m$。

提示：$dp,ans$ 数组需要初始化，$ans_0=0$，其余均为**较大值**。

---

## 作者：fanypcd (赞：1)

有一定难度的思维题。


输入中的装备从高级向合成它需要的低级装备连边，最后会是一个森林。

对于每个高级装备，它能购买的次数和他的儿子的购买次数有关，所以我们需要在动态规划的维度中加入购买次数。

考虑设 $f_{u,i,j}$ 表示以 $u$ 为根的子树，**至少**合成 $i$ 件 $u$ 装备，总共在子树中花费 $j$ 金币能得到的最大能力值（如果不合法，即金币不够，$f_{u,i,j}=-\inf$）。

- 最开始 $u$ 为根的子树只有 $u$ 一个点，初始化所有的 $f_{u,i,j}$：（$lim[u]$ 表示 $u$ 装备最多买进的次数，$c[u]$ 表示一次买进的代价，$s[u]$ 表示 $u$ 装备增加的能力值）

```cpp
for(int i = 0; i <= lim[u]; i++)
{
	for(int j = 0; j <= m; j++)
	{
		f[u][i][j] = ((j < i * c[u]) || (i > lim[u]) ? -inf : i * s[u]);
	}
}
```

- 然后考虑 $u$ 节点每新加入一个子树 $v$（设合成一个 $u$ 装备需要 $w$ 个 $v$ 装备）。则所有的 $f_{u,i,j}$ 需要加上 $i \times w$ 个 $v$ 的代价才能合成，用背包的思路去合并答案：

```cpp
f[u][i][j] = max(-inf, f[u][i][j] + f[v][i * w][0] - i * w * s[v]);
for(int k = 1; k <= j; k++)
{
	f[u][i][j] = max(f[u][i][j], f[u][i][j - k] + f[v][i * w][k] - i * w * s[v]);
}
```

- 注意 $f_{u,i,j}$ 的定义是至少买 $i$ 件 $u$ 装备能得到的最大能力值（可能买得更多能力值更大），而先前背包合并的答案是正好买 $i$ 件的最大能力值，所以需要对 $f_{u,i,j}$ 求一个后缀最大值（注意是第二维的后缀最大）。

```cpp
for(int j = 0; j <= m; j++)
{
	f[u][lim[u] + 1][j] = -inf;
	for(int i = lim[u]; i >= 0; i--)
	{
		f[u][i][j] = max(f[u][i + 1][j], f[u][i][j]);
	}
}
```

- 最后建一个虚拟源点，向所有树根连边，一次 dfs 即可求得答案（虚拟源点处我写了特殊的合并）。

---

理论复杂度：$O(n\times \lim \times m^2)$，计算器敲一下发现好像极限数据是 $2.04e10$，luogu 交一发 T 到只有40pts，需要优化。

主要是对 dp 转移范围的优化：

朴素的写法是两层循环老实地从 $0-m$，但是考虑前一层枚举的 $i$ 的意义：$u$ 点买 $i$ 件，那么代价至少是 $i \times cost[u]$ ，同理 $v$ 点买 $i \times w$ 件，代价至少是 $i \times w \times cost[v]$。

然后时间复杂度：$O(\texttt{玄学})$。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define maxrd 100005
inline char GET_CHAR()
{
    static char buf[maxrd], *p1 = buf, *p2 = buf;
    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, maxrd, stdin), p1 == p2) ? EOF : *p1++;
}
template <class T> inline void read(T &x)
{
	x = 0;
	int f = 0;
	char ch = GET_CHAR();
	while(ch < '0' || ch > '9')
	{
		f |= ch == '-';
		ch = GET_CHAR();
	}
	while(ch >= '0' && ch <= '9')
	{
		x = x * 10 + (ch - 48);
		ch = GET_CHAR();
	}
	x = f ? -x : x;
	return;
}
inline void readch(char &x)
{
	x = GET_CHAR();
	while(x < 'A' && x > 'Z')
	{
		x = GET_CHAR();
	}
	return;
}
#define min(x, y) ((x) < (y) ? x : y)
#define max(x, y) ((x) > (y) ? x : y)
#define inf 0x3f3f3f3f
#define N 55
#define SIZE 100
#define M 2005
int first[N], Next[N], to[N], w[N], tot;
inline void add(int x, int y, int z)
{
	Next[++tot] = first[x];
	first[x] = tot;
	to[tot] = y;
	w[tot] = z;
	return;
}
int n, m;
int s[N], c[N], lim[N], cost[N];
int f[N][SIZE + 5][M], tmp[SIZE + 5][M];
void update(int u, int v, int w)
{
	if(u == n + 1)
	{
		for(int i = m; i >= 0; i--)
		{
			for(int j = 0; j <= i; j++)
			{
				f[u][0][i] = max(f[u][0][i], f[u][0][i - j] + f[v][0][j]);
			}
		}
		return;
	}
	memset(tmp, -0x3f, sizeof(tmp));
	for(int i = 0; i <= lim[u]; i++)
	{
		for(int j = m; j >= cost[u] * i; j--)
		{
			tmp[i][j] = max(tmp[i][j], f[u][i][j] + f[v][i * w][0] - i * w * s[v]);
			for(int k = cost[v] * i * w; k <= j; k++)
			{
				tmp[i][j] = max(tmp[i][j], f[u][i][j - k] + f[v][i * w][k] - i * w * s[v]);
			}
		}
	}
	memcpy(f[u], tmp, sizeof(f[u]));
	return;
}
void dfs(int u)
{
	for(int i = 0; i <= lim[u]; i++)
	{
		for(int j = 0; j <= m; j++)
		{
			f[u][i][j] = ((j < i * c[u]) || (i > lim[u]) ? -inf : i * s[u]);
		}
	}
	for(int i = first[u]; i; i = Next[i])
	{
		int v = to[i];
		dfs(v);
		lim[u] = min(lim[u], lim[v] / w[i]);
		cost[u] += w[i] * cost[v];
		update(u, v, w[i]);
	}
	for(int j = 0; j <= m; j++)
	{
		f[u][lim[u] + 1][j] = -inf;
		for(int i = lim[u]; i >= 0; i--)
		{
			f[u][i][j] = max(f[u][i + 1][j], f[u][i][j]);
		}
	}
	return;
}
int rd[N], root;
signed main()
{
	read(n), read(m);
	char opt;
	int cnt, ch, len;
	for(int i = 1; i <= n; i++)
	{
		read(s[i]), readch(opt);
		if(opt == 'A')
		{
			lim[i] = SIZE;
			read(cnt);
			while(cnt--)
			{
				read(ch), read(len);
				add(i, ch, len);
				rd[ch]++;
			}
		}
		else
		{
			read(c[i]), read(lim[i]);
			cost[i] = c[i];
		}
	}
	for(int i = 1; i <= n; i++)
	{
		if(!c[i] && !rd[i])
		{
			add(n + 1, i, 1);
		}
	}
	dfs(n + 1);
	printf("%d", f[n + 1][0][m]);
	return 0;
}
```

---

## 作者：w9095 (赞：1)

[P4037 [JSOI2008] 魔兽地图](https://www.luogu.com.cn/problem/P4037)

比较难的树上背包题目。

题目中装备有购买限制，所以二维树上背包状态肯定无法表示。又由于每件装备的合成只与其子节点的合成数量有关，所以需要一维表示这一个装备合成多少个，这样刚好可以进行父子之间的转移。

设状态 $f[x][y][z]$ 表示第 $x$ 件装备合成 $z$ 个，使用 $y$ 个金币可以达到的最大价值。

初始时，$f[x][y][z]$ 为负无穷。对于叶子节点，直接枚举购买数量，计算需要的金币，记录状态。

我们枚举 $z$，经过手推发现直接转移是不行的，所以考虑记录辅助转移数组 $g[i][j]$ 表示第 $x$ 件装备合成 $z$ 个时，考虑到第 $i$ 棵子树，使用了 $j$ 个金币。

我们发现，每一棵子树都必须达到可以合成 $z$ 个第 $x$ 件装备的数量。也就是说，第 $i$ 棵子树的装备至少合成 $w_{x,i}\times z$ 个，且不能不选，其中 $w_{x,i}$ 为合成 $x$ 需要的 $i$ 的数量。由于不能不选，所以 $g[i][j]$ 的初值为负无穷，$g[0][0]=0$。

接下来，我们使用类似分组背包的转移方式。对于第 $i$ 棵子树，在合成数量大于 $w_{x,i}\times z$ 的情况下任意选择，也就是枚举这个子树使用的金币 $k$，合成的数量 $l$。易得如下转移方程：($s_{x,i}$ 为第 $i$ 棵子树对应到的编号)

$$g[i][j]=\max(g[i-1][j],g[i][j-k]+f[s_{x,i}][j][l])(0\le k\le j,w_{x,i}\times z\le l \le 100)$$

上述过程可以使用滚动数组优化空间。转移结束后，令 $f[x][y][z]=g[c_x][y]$，其中 $c_x$ 为 $x$ 的子树数量，并计算合成的贡献。

这样做复杂度较高，为 $O(100^2nm^2)$。我们注意到如果倒序枚举 $z$，那么对于确定的 $i,j$，$f[s_{x,i}][j][l]$ 组成的集合元素数量是单增不降的。我们可以使用一个变量来维护，就不需要枚举 $l$ 了，时间复杂度为 $O(100nm^2)$。

这样还是会超时。我们发现其实对于一些高级装备，它们最多被合成的数量其实不大。我们可以把这个数量预处理出来，记为 $y_x$，$z$ 就只需要从 $y_x$ 枚举到 $0$ 即可。

经过上述优化，代码成功通过此题。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,c,x,ind[60],a[60],b[60],t[60],y[60],s[60][60],w[60][60],f[60][2001][101],g[2][2001],mx[60][2001],ans=-1e9;
char op;
void prework(int x)
{
	if(t[x]==0)return;
	y[x]=1e9;
	for(int i=1;i<=t[x];i++)
	    {
	    prework(s[x][i]);
	    y[x]=min(y[x],y[s[x][i]]/w[x][i]);
	    }
}

void dfs(int x)
{
	int now=0;
	if(t[x]==0)return;
	for(int i=1;i<=t[x];i++)dfs(s[x][i]);
	for(int i=1;i<=t[x];i++)
		for(int j=0;j<=m;j++)
		    mx[s[x][i]][j]=-1e9;
	for(int i=1;i<=t[x];i++)
		for(int j=0;j<=m;j++)
		    for(int p=(y[x]+1)*w[x][i];p<=100;p++)
		        mx[s[x][i]][j]=max(mx[s[x][i]][j],f[s[x][i]][j][p]);
	for(int k=y[x];k>=0;k--)
		{
		for(int i=1;i<=t[x];i++)
		    for(int j=0;j<=m;j++)
		        if(k*w[x][i]<=100)
		           for(int p=k*w[x][i];p<=min((k+1)*w[x][i],100);p++)
		               mx[s[x][i]][j]=max(mx[s[x][i]][j],f[s[x][i]][j][p]);
		for(int j=0;j<=m;j++)g[now][j]=g[now^1][j]=-1e9;
		g[now][0]=0;
		for(int i=1;i<=t[x];i++)
		    {
		    for(int j=0;j<=m;j++)g[now^1][j]=-1e9;
		    for(int j=0;j<=m;j++)
		        for(int p=0;p<=j;p++)
		            g[now^1][j]=max(g[now^1][j],g[now][j-p]+mx[s[x][i]][p]);
		    now^=1;
		    }
		for(int i=0;i<=m;i++)
		    if(g[now][i]!=-1e9)f[x][i][k]=g[now][i]+b[x]*k;
	    }
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	    for(int j=0;j<=m;j++)
	        for(int k=0;k<=100;k++)
	            f[i][j][k]=-1e9;
	for(int i=1;i<=n;i++)
	    {
	    	cin>>a[i]>>op;
	    	if(op=='A')
	    	    {
	    	    	b[i]=a[i];
	    	    	cin>>t[i];
	    	    	for(int j=1;j<=t[i];j++)cin>>s[i][j],cin>>w[i][j],ind[s[i][j]]++;
				}
			else if(op=='B')
			    {
			    	cin>>c>>x;
			    	y[i]=x;
			    	for(int j=0;j<=x;j++)
					    if(c*j<=m)f[i][c*j][j]=a[i]*j;
				}
		}
    for(int i=1;i<=n;i++)
        if(t[i])
           for(int j=1;j<=t[i];j++)b[i]-=a[s[i][j]]*w[i][j];
    for(int i=1;i<=n;i++)
	    if(ind[i]==0)prework(i);
	for(int i=1;i<=n;i++)
	    if(ind[i]==0)dfs(i);
	for(int i=1;i<=n;i++)
	    if(ind[i]==0)
	       {
	       	for(int j=0;j<=m;j++)
	       	    for(int k=0;k<=100;k++)
	       	        ans=max(ans,f[i][j][k]);
	       	cout<<ans;
		   }
	return 0;
}
```

---

## 作者：坑队友的小白 (赞：1)

**[$\Longrightarrow$题面](https://www.luogu.com.cn/problem/P4037)**

# 题解

其实刚看着道题的时候是一脸懵逼的（雾）。

然后想到使用dp，但是依然一脸懵。

但是看到这个极其小的$N$和装备数量限制让我明白加维是不可避免的。

首先可以发现，子树中的节点信息可以对子树的根节点产生影响，这一点和NOI2020D1T2有点像（但是那题我不会做，因为不太懂线段树合并），而本题的信息就是这个节点所代表的装备有多少是留下来作为价值贡献的，有多少是上交作为更高级武器的材料的，但是我们显然只需要记住其中一个，因为我们还需要记住这个子树中总共使用的金币数。

那么，设$f(u,x,y)$表示子树$T(u)$中，使用$y$个金币，这颗子树中锻造出装备$u$共$y$件上交，剩余的所有装备全部作为价值贡献。同时，我们弄一些辅助变量来减少常数：$lim(u)$表示装备$u$最多可以锻造多少个，$cst(u)$表示要锻造一个装备$u$需要花掉多少金币。

显然，对于叶子节点，也就是低级装备，我们只需要枚举制造了多少个，其中上交了多少个即可。

而对于非叶子节点$u$，首先，枚举总共锻造了多少个装备$u$，设为$num$，那么对于每一个儿子装备的需求量就确认了。接着对锻造了$num$个装备的情况，做一次背包，接着更新上交$i(0\leq i\leq num)$个的所有状态的dp值。

接着，对于所有没有父亲装备的节点，我们用背包对其进行合并，使用的值都是形如$f(i,j,0)$的。（也就是锻造装备$i$及其子树中的装备使用了$j$个金币，全部作为价值贡献）

```cpp
#include <bits/stdc++.h>
#define LL long long

using namespace std;

const int maxn = 56, maxk = 105, maxm = 2e3 + 5, INF = 1e9 + 7;
char read_ch() {
    char ch = getchar();
    while (ch != 'A' && ch != 'B') ch = getchar();
    return ch;
}
struct Edge {
    int v, nex; LL w;
    Edge(int v = 0, LL w = 0, int nex = 0) : v(v), w(w), nex(nex) {}
} E[maxn << 1];
int hd[maxn], tote;

void addedge(int u, int v, LL w) {
    E[++tote] = Edge(v, w, hd[u]), hd[u] = tote;
}

int N, M, hsf[maxn];
LL cst[maxn], lim[maxn], v[maxn], f[maxn][maxk][maxm], g[maxm], ans;

void dfs(int u) {
    if (!u) { //总的背包
        for (int i = hd[u]; i; i = E[i].nex) {
            dfs(E[i].v);
            for (int j = M; j >= 0; j--)
                for (int k = 0; k <= j; k++)
                    f[u][0][j] = max(f[u][0][j], f[u][0][j - k] + f[E[i].v][0][k]);
        }
        return ;
    } 
    if (!hd[u]) { //叶子节点
        lim[u] = min(lim[u], M / cst[u]);
        for (int i = lim[u]; i >= 0; i--)
            for (int j = i; j <= lim[u]; j++)
                f[u][i][j * cst[u]] = (j - i) * v[u];
        return ;
    }
    lim[u] = INF;
    for (int i = hd[u]; i; i = E[i].nex) {
        int v = E[i].v;
        dfs(v);
        lim[u] = min(lim[u], lim[v] / E[i].w), cst[u] += cst[v] * E[i].w;
    }
    lim[u] = min(lim[u], M / cst[u]);
    for (int j = 0; j <= lim[u]; j++) {
        for (int i = 0; i <= M; i++) g[i] = -INF;
        g[0] = 0;
        for (int i = hd[u]; i; i = E[i].nex) {
            int v = E[i].v;
            for (int x = M; x >= 0; x--) {
                LL newgx = -INF;
                for (int y = 0; y <= x; y++)
                    newgx = max(newgx, g[x - y] + f[v][j * E[i].w][y]);
                g[x] = newgx;
            }
        }
        for (int i = 0; i <= j; i++)
            for (int k = 0; k <= M; k++)
                f[u][i][k] = max(f[u][i][k], g[k] + (j - i) * v[u]);
    }
}

int main() {
    scanf("%d%d", &N, &M);
    for (int i = 1; i <= N; i++) for (int j = 0; j <= 100; j++) for (int k = 0; k <= M; k++)
                f[i][j][k] = -INF;
    for (int i = 1; i <= N; i++) {
        scanf("%lld", &v[i]); char t = read_ch();
        if (t == 'A') {
            int C; scanf("%d", &C);
            while (C--) {
                int v; LL w;
                scanf("%d%lld", &v, &w);
                addedge(i, v, w), hsf[v] = 1;
            }
        } else scanf("%lld%lld", &cst[i], &lim[i]);
    }
    for (int i = 1; i <= N; i++) if (!hsf[i]) addedge(0, i, 0);
    dfs(0);
    for (int i = 1; i <= M; i++) ans = max(ans, f[0][0][i]);
    printf("%lld\n", ans);
    return 0;
}
```





---

## 作者：Planetary_system (赞：0)

## 题面解释：
一颗装备合成树（题目说是树，事实上 `DAG` 应该都一样），有购买数量限制，求出一定金额的最大力量。
## 思路分析：
看到题目和数据范围想到 `dp`。设计 $ans_i$ 表示花费 $i$ 元的最大力量值。但是合成关系构成树结构，为了方便维护，我们先使用树上背包预处理。设计 $dp_{i,j,k}$ 为合成到第 $i$ 件装备，其中 $j$ 件继续用于合成，已经花了 $k$ 元的最大力量。

对于叶子节点，直接购买，是经典的背包问题。对于非叶子节点，我们将他被合成 $1$ 个的最小代价抽象成购买他的代价，然后处理出其购买上限。然后根据合成途径进行转移，转移部分在代码注释中很详细了。

由于设计状态时为一共获得的总力量，我们只需要在遍历后对根节点进行背包，根节点一定不用于合成，所以直接以 $dp_{rt,0,k}(k\in[0,m])$ 进行转移。

时间复杂度似乎不对，但应该没有更优做法了，是完全跑不满的，可以轻松通过。
## AC Code:
并非自己独立完成，借鉴过其他题解，思路一样。但是调试与理解后，详细进行注释，帮助后人更好地理解 `dp` 过程。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=60,M=2e3+10;
bool vis[N];struct node{int to,val;};vector<node>g[N];
int n,m,dp[N][N*2][M],p[M],a[N],c[N],z[N],in[N],ans[M];
void dfs(int u){
  	if(vis[u])return;vis[u]=1;
  	if(g[u].empty()){
	  	//直接购买 
  		z[u]=min(z[u],m/c[u]);
  		for(int i=z[u];i>=0;i--)//多少用来合成 
  	  		for(int j=i;j<=z[u];j++)//总共买多少 
  	    		dp[u][i][j*c[u]]=a[u]*(j-i);
		return;
  	}
  	//合成 
  	for(auto v:g[u]){
  		dfs(v.to);
  		z[u]=min(z[u],z[v.to]/v.val);
  		c[u]+=v.val*c[v.to];
 	}
  	z[u]=min(z[u],m/c[u]);
  	//处理消耗与数量限制 
  	for(int i=z[u];i>=0;i--){//合成i个u 
    	memset(p,0xcf,sizeof(p));p[0]=0;
    	//p[i]表示合成i个u花了k元子孙节点可以提供多少防御 
  		for(auto v:g[u]){
	  		for(int j=m;j>=0;j--){//到当前节点一共花费 
	  			int res=dp[0][0][0];
	    		for(int k=0;k<=j;k++)//当前节点花费 
	      			res=max(res,p[j-k]+dp[v.to][i*v.val][k]);	 
				p[j]=res;
	  		}
		}
		for(int j=0;j<=i;j++)//多少个装备用来合成更高级的 
	  		for(int k=0;k<=m;k++)//花了多少钱 
	    		dp[u][j][k]=max(dp[u][j][k],p[k]+a[u]*(i-j));
  	}
} 
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	memset(z,0x3f,sizeof(z));
	for(int i=1,t,v,w;i<=n;i++){
		char ch;cin>>a[i]>>ch;
		if(ch=='A'){
			cin>>t;while(t--)
			cin>>v>>w,in[v]++,
			g[i].push_back({v,w});
		}else cin>>c[i]>>z[i];
	}
	//dp[i][j][k]表示i装备j个用来合成花费了k元的最大力量 
	//ans[i]表示花费i元可以获得最大力量 
	memset(dp,0xcf,sizeof(dp));
	for(int i=1;i<=n;i++)if(!in[i]){
		dfs(i);
		for(int j=m;j>=0;j--)//总共花了多少钱 
        	for(int k=0;k<=j;k++)//此树花多少钱 
         		ans[j]=max(ans[j],ans[j-k]+dp[i][0][k]);//根节点不上传 
	}
	cout<<ans[m];
	return 0;
}
```

---

## 作者：huhangqi (赞：0)

由题目可知整个合成路径可以看作一个森林。

对于答案的统计，我们在处理完每棵树的消耗费用对应的最大力量以后，使用一个背包即可。

这样我们就可以统计出答案了。

现在问题在于如何处理出每一棵树的消耗费用对应的最大力量。

很明显这还是一个背包问题，但是这里需要合成，也就是说有一些物品买过来不能直接计算收益，再加上物品数量有限制，导致这个问题非常复杂。

那么我们可以考虑给背包多开一维状态，这边直接记录下有多少个此物品被用来合成，以此方便转移。

我们设置 $dp_{i,j,k}$ 表示选择到第 $i$ 件物品，选择 $j$ 个此物品用来合成，总共消耗 $k$ 个金币。

对于基本装备，我们已经知道了可以购买的数量，以及单价，可以直接多重背包。

但是由于我们多记了一维，我们在使用多重背包时还需要枚举合成数量，并且不计入这些用来合成的贡献。

对于高级装备的处理更加复杂，高级装备只能通过合成得到，那么我们就可以通过用来合成的物品数量以及价格推出高级装备的最多选择数量。

易得这个数量一定小于等于用来合成的物品数量。

之后我们枚举合成出来的数量，此时我们不需要考虑这些哪些用来继续合成，因此我们再设置一个 $dp_i$ 表示在合成出目前枚举的量的情况下的金币消耗。

由于我们需要保证合成出来，所以我们要将背包内的值进行强制更新，也就是说每次枚举一个新的物品，要给背包内所有值都更新一次答案，这样才能保证有值加入，可以合成出来。

处理完成之后就可以直接更新三维状态的背包了。

这样就可以成功处理出每棵树的消耗费用对应的最大力量了。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,dp[55][105][2005],v[55],c[55],w[55],ans[2005],dp2[2005];
vector<pair<int,int>> e[55];
bool vis[55];
char op;
void dfs(int p){
	if(e[p].size()==0){//基本装备 
		w[p]=min(w[p],m/c[p]);
		for(int i=0;i<=w[p];i++){
			for(int j=0;j<=i;j++)dp[p][j][i*c[p]]=(i-j)*v[p];
		}
		return;
	}
	w[p]=1e18,c[p]=0;//高级装备 
	for(auto tmp:e[p]){
		int i=tmp.first,x=tmp.second;
		dfs(i);
		w[p]=min(w[p],w[i]/x);
		c[p]+=c[i]*x;
	}
	w[p]=min(w[p],m/c[p]);
	for(int i=0;i<=w[p];i++){
		memset(dp2,-0x3f,sizeof(dp2));
		dp2[0]=0;
		for(auto tmp:e[p]){
			int u=tmp.first,x=tmp.second;
			for(int j=m;j>=0;j--){
				int tmp=-1e18;
				for(int k=0;k<=j;k++)tmp=max(tmp,dp2[j-k]+dp[u][i*x][k]);
				dp2[j]=tmp;//强制更新 
			}
		}
		for(int j=0;j<=i;j++){
			for(int k=0;k<=m;k++)dp[p][j][k]=max(dp[p][j][k],dp2[k]+(i-j)*v[p]);
		}
	}
}
signed main(){
	memset(dp,-0x3f,sizeof(dp));
	cin>>n>>m;
	for(int i=1,k;i<=n;i++){
		cin>>v[i]>>op;
		if(op=='A'){
			cin>>k;
			for(int j=1,v,w;j<=k;j++){
				cin>>v>>w;
				e[i].push_back({v,w});
				vis[v]=1;
			}
		}
		else cin>>c[i]>>w[i];
	}
	for(int i=1;i<=n;i++){
		if(vis[i])continue;
		dfs(i);
		for(int j=m;j>=0;j--){//背包处理答案 
			for(int k=0;k<=j;k++){
				ans[j]=max(ans[j],ans[j-k]+dp[i][0][k]);
			}
		}
	}
	cout<<ans[m];
	return 0;
}
``````

---

## 作者：__ycx2010__ (赞：0)

### 思路

设 $f_{i, j, k}$ 表示在 i 号点的子树中，用 k 枚金币，使得 i 号装备多出 j 个的最大力量值之和。

容易得出一个 $O(\lim ^2nm^2)$ 的 dag 上 dp，lim 为每件装备制成的数量的限制。

这时我们需要一个临时数组 $g_{i,j}$ 表示当前点上，用 j 枚金币，造出 i 个当前装备的最大力量值之和，它与 f 的区别在于不用管当前点所表示装备的力量值，转移式如下。

```
for (int i = lim[u]; i >= 0; i -- )
	for (int j = h[u]; ~j; j = ne[j]) {
		int ver = e[j];
		for (int xx = m; xx >= 0; xx -- ) {
			int tmp = -INF;
			for (int yy = 0; yy <= xx; yy ++ )
				chkmax(tmp, g[i][xx - yy] + f[ver][i * w[j]][yy]);
			g[i][xx] = tmp;
		}
	}
```

这样就可以省掉一个 $O(\lim)$，接下来就可以用 g 推出 f。

```
for (int i = lim[u]; i >= 0; i -- )
	for (int j = 0; j <= i; j ++ )
		for (int k = 0; k <= m; k ++ )
			chkmax(f[u][j][k], g[i][k] + (i - j) * value[u]);
```

总时间复杂度 $O(\lim n m^2)$。

### 代码

```
#include <bits/stdc++.h>
#define ll long long
#define fi first
#define se second
#define pb push_back
#define lb lower_bound
#define re register
#define sz(x) (int(x.size()))
#define all(x) x.begin(), x.end()

using namespace std;

const int N = 110, M = 2010, INF = 0x3f3f3f3f;
int n, m;
int d[N], lim[N], price[N], g[N][M], value[N];
int h[N], e[N * N], w[N * N], ne[N * N], idx;
int f[N][N][M], ans[M];
bool vis[N];

int rd() {
	int w = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {if (ch == '-') f = -1; ch = getchar();}
	while (ch >= '0' && ch <= '9') {w = (w << 3) + (w << 1) + ch - 48; ch = getchar();}
	return f * w;
}

void chkmax(int &x, int y) {x = max(x, y);}

void add_edge(int a, int b, int c) {
	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
	d[b] ++ ;
}

void dfs(int u) {
	if(vis[u]) return;
	vis[u] = true;
	if (h[u] == -1) {
		lim[u] = min(lim[u], m / price[u]);
		for (int i = lim[u]; i >= 0; i -- )
			for (int j = i; j <= lim[u]; j ++ )
				f[u][i][j * price[u]] = value[u] * (j - i);
		return;
	}
	lim[u] = 1e9;
	for (int i = h[u]; ~i; i = ne[i]) {
		int ver = e[i];
		dfs(ver);
		lim[u] = min(lim[u], lim[ver] / w[i]);
		price[u] += price[ver] * w[i];
	}
	lim[u] = min(lim[u], m / price[u]);
	memset(g, -0x3f, sizeof(g));
	for (int i = 0; i <= lim[u]; i ++ ) g[i][0] = 0;
	for (int i = lim[u]; i >= 0; i -- )
		for (int j = h[u]; ~j; j = ne[j]) {
			int ver = e[j];
			for (int xx = m; xx >= 0; xx -- ) {
				int tmp = -INF;
				for (int yy = 0; yy <= xx; yy ++ )
					chkmax(tmp, g[i][xx - yy] + f[ver][i * w[j]][yy]);
				g[i][xx] = tmp;
			}
		}
	for (int i = lim[u]; i >= 0; i -- )
		for (int j = 0; j <= i; j ++ )
			for (int k = 0; k <= m; k ++ )
				chkmax(f[u][j][k], g[i][k] + (i - j) * value[u]);
}

int main() {
	memset(f, -0x3f, sizeof(f));
	memset(h, -1, sizeof(h));
	n = rd(), m = rd();
	for (int i = 1; i <= n; i ++ ) {
		value[i] = rd();
		char c;
		cin >> c;
		if (c == 'A') {
			int tm = rd(), x, y;
			while (tm -- ) x = rd(), y = rd(), add_edge(i, x, y);
		} else price[i] = rd(), lim[i] = rd();
	}
	for (int i = 1; i <= n; i ++ )
		if(!d[i]) {
			dfs(i);
			for (int j = m; j >= 0; j -- )
				for (int k = 0; k <= j; k ++ )
					chkmax(ans[j], ans[j - k] + f[i][0][k]);
		}
	printf("%d\n", ans[m]);
	return 0;
}
```

---

## 作者：wind_seeker (赞：0)

~~难得手切紫题，虽然时间复杂度倒数还是来写篇题解。~~

先不考虑优化这个逆天的 $O(nm^2V)$，$V$ 为数量限制，我们设计状态：

$f_{i,j,k}$ 表示在编号为 $i$ 的整颗子树内，花了 $j$ 块钱，高级装备 $i$ 合成了 $k$ 个。由于只有 $i$ 会对上面造成影响，所以我们只需要记录 $i$ 的个数。

考虑如何作背包，由于我们要统计最后合成了几个 $i$，所以我们要对每一个 $i$ 的个数单独处理，保证所有儿子加入的时候都是满足大于等于合成要求的。

于是开始转移：

对于 $f_{cur_u,u,i,j}$，枚举 $p\in[0,m]$，$q\in[j\times sum_v,num_v]$，其中 $sum_v$ 为合成一个 $u$ 所需要的 $v$ 的个数，$num_v$ 为最多可拥有的 $v$ 的个数。

则有：

$$f_{cur_u,u,i,j}=\max f_{pre_u,u,i-p,j}+f_{cur_v,v,p,q}$$

注意合成 $u$ 需要减去 $v$ 的力量值，所以一开始把拿去合成的 $v$ 都减去，最后在把所有合成的 $u$ 的力量值加回来。

```cpp
for(int i=0;i<=m;i++) for(int j=0;j<=num[u];j++) f[cur[u]][u][i][j]=-inf;
for(int i=0;i<=num[u];i++) f[cur[u]][u][0][i]=0;
void add(int v,int u){
	swap(pre[u],cur[u]);
	for(int i=0;i<=m;i++) for(int j=0;j<=num[u];j++) f[cur[u]][u][i][j]=-inf;
	for(int j=0;j<=num[u];j++){
		for(int i=0;i<=m;i++){
			int V=i,W=-inf;
			for(int k=j*sum[v];k<=num[v];k++) W=max(W,f[cur[v]][v][i][k]-(j*sum[v])*val[v]);
			for(int k=m;k>=V;k--) f[cur[u]][u][k][j]=max(f[cur[u]][u][k][j],f[pre[u]][u][k-V][j]+W);	
		}
	}
}
for(int j=0;j<=num[u];j++) for(int i=j*cost[u];i<=m;i++) f[cur[u]][u][i][j]+=val[u]*j;
```

这样只能拿下惨淡的 $60$ 分。接下来只需要把枚举 $p$ 的下界变为 $j\times sum_v\times cost_v$ 即可卡过去。

### code
```cpp
#include<bits/stdc++.h>
#define pb push_back
using namespace std;
const int N=2010,inf=1e9;

int n,m,in[N],f[2][60][N][110];
int val[N],cost[N],num[N],sum[N],pre[N],cur[N];
vector<int> e[N];

void add(int v,int u){
	swap(pre[u],cur[u]);
	for(int i=0;i<=m;i++) for(int j=0;j<=num[u];j++) f[cur[u]][u][i][j]=-inf;
	for(int j=0;j<=num[u];j++){
		for(int i=j*sum[v]*cost[v];i<=m;i++){
			int V=i,W=-inf;
			for(int k=j*sum[v];k<=num[v];k++) W=max(W,f[cur[v]][v][i][k]-(j*sum[v])*val[v]);
			for(int k=m;k>=V;k--) f[cur[u]][u][k][j]=max(f[cur[u]][u][k][j],f[pre[u]][u][k-V][j]+W);	
		}
	}
}
void dfs(int u){
	pre[u]=1,cur[u]=0;
	for(int i=0;i<=m;i++) for(int j=0;j<=num[u];j++) f[cur[u]][u][i][j]=-inf;
	if(!e[u].size()) {for(int i=0;i<=m&&i/cost[u]<=num[u];i++) f[cur[u]][u][i][i/cost[u]]=i/cost[u]*val[u];return;}
	for(auto v:e[u]){
		dfs(v);
		if(u==0) continue;
		num[u]=max(num[u],num[v]/sum[v]),cost[u]+=sum[v]*cost[v];
	}
	for(int i=0;i<=num[u];i++) f[cur[u]][u][0][i]=0;
	for(auto v:e[u]) add(v,u);
	for(int j=0;j<=num[u];j++) for(int i=j*cost[u];i<=m;i++) f[cur[u]][u][i][j]+=val[u]*j;
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,x;i<=n;i++){
		char op;
		scanf("%d %c",&val[i],&op);
		if(op=='B')
			scanf("%d%d",&cost[i],&num[i]);
		else{
			scanf("%d",&x);
			for(int j=1,v,y;j<=x;j++) scanf("%d%d",&v,&y),sum[v]=y,e[i].pb(v),in[v]++;
		}
	}
	for(int i=1;i<=n;i++) if(!in[i]) e[0].pb(i);
	dfs(0);int answer=-1;
	for(int i=0;i<=m;i++) answer=max(answer,f[cur[0]][0][i][0]);
	printf("%d\n",answer);
	return 0;
}
/*
3 5
1 B 1 5
1 B 1 5
8 A 2 1 2 2 2
*/
```

---


# [AHOI2014/JSOI2014] 宅男计划

## 题目背景

自从迷上了拼图，JYY 就变成了个彻底的宅男。为了解决温饱问题，JYY 不得不依靠叫外卖来维持生计。


## 题目描述

外卖店一共有 $n$ 种食物，分别从 $1$ 到 $n$ 编号。第 $i$ 种食物有固定的价钱 $p_i$ 和保质期 $s_i$。第 $i$ 种食物会在 $s_i$ 天后过期。JYY 是不会吃过期食物的。

比如 JYY 如果今天点了一份保质期为 $1$ 天的食物，那么 JYY 必须在今天或者明天把这个食物吃掉，否则这个食物就再也不能吃了。保质期可以为 $0$ 天，这样这份食物就必须在购买当天吃掉。

JYY 现在有 $m$ 块钱，每一次叫外卖需要额外付给送外卖小哥外送费 $f$ 元。

送外卖的小哥身强力壮，可以瞬间给 JYY 带来任意多份食物。JYY 想知道，在满足每天都能吃到至少一顿没过期的外卖的情况下，他可以最多宅多少天呢？


## 说明/提示

#### 样例输入输出 1 解释
JYY的最佳策略是：
- 第一天买一份食物 $1$ 和一份食物 $2$ 并且吃一份食物 $1$；
- 第二天吃一份食物 $2$；
- 第三天买一份食物 $1$ 并且吃掉。

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 200$，$0 \leq s_i \leq 10^{18}$，$1 \leq f, p_i, m \leq10^{18}$。

## 样例 #1

### 输入

```
32 5 2
5 0
10 2```

### 输出

```
3```

# 题解

## 作者：zhaotiensn (赞：24)

（作为一道省选题，这题还是比较简单的，连我这种大蒟蒻都能水过去，不过竟然没有人来发题解，那么我就来写一份题解好了）

三分这题主要是运用**三分**和**贪心**的思想来做（反正我是这样做的，不过网上还有别的dalao用的是**模拟退火**，有志向的同学可以去看一看，反正我没有看懂）。

这题的关键是看出**购买外卖的次数**与**能够宅的天数**的关系是一个近似于**单峰**的函数，既然是单峰的函数，那么找出最大值就自然会使用**三分购买外卖的次数**了。（看出单峰函数的方法我也不知道，主要是一个一个去试，然后就能发现是单峰的了）

**三分模板（类型为double）：**

```cpp
    while(r-l<eps){
        double block=(r-l)/3;
        midl=l+block;midr=r-block;
        if(f(midl)>f(midr)){
            l=midl
        }else{
            r=midr;
        }
    }
```
然后就是对于每种次数求出最大能够达到的天数，因为数据大小有10^18，所以**放弃**使用**背包**，运用**贪心**的思想求解。具体的贪心是将所有的钱减去送外卖的总费用后平均分成多份，然后对每一份钱进行贪心，最后把剩下的所有钱进行贪心，前面的天数乘以份数再加上后面的天数就是当前次数的最大存活天数。
**AC代码：**

    
    
    
    
```cpp
    #include<iostream>
    #include<cstdio>
    #include<algorithm>
    using namespace std;
    long long m,f,n,l,r,midr,midl,maxn;
    struct food {
        long long p,s;
    } a[205];
    bool cmp(food a,food b) {//定义快排
        if(a.p!=b.p) return a.p<b.p;
        else return a.s>b.s;
    }
    long long get(long long t) {//贪心
        long long v,ans,now,w,k,p,j;
        v=m-t*f;//减去叫买卖所花费的钱
        w=v/t;//用w存每一份的钱
        k=v-w*t;//用k存一开始剩下来的钱
        ans=0;now=0;//初始化
        if(v<0)return 0;//当一开始就把钱花完了，自然就要退出
        for(long long i=1; i<=n; i++) {//贪心主体
            if((a[i].s>=now)&&(w-a[i].p>=0)) {//最便宜的能吃几天就吃几天，吃不了了再去找下一个能吃的吃
                p=min(a[i].s+1-now,w/a[i].p);
                now+=p;
                w-=p*a[i].p;
            }
            j=i;//用j储存选择的食品数量
            if(w-a[i].p<0)break;//因为按价格排序，当前的买不起了，剩下的都买不起了
        }
        k+=w*t;//将剩下的钱全存到k里
        for(long long i=j; i<=n; i++) {//对k进行贪心，从j开始，能吃的就买
            if((a[i].s>=now)&&(k-a[i].p>=0)) {
                p=min(k/a[i].p,t);
                ans+=p;
                k-=p*a[i].p;
            }
            if(ans>0)break;//因为剩下的钱不可能做到每次外卖都多买一天的量
        }
        //所以一旦ans有值，说明已经用过了，所以剩下的一定买不了了
        return t*now+ans;
    }
    int main() {
        cin>>m>>f>>n;
        for(int i=1; i<=n; i++) {
            cin>>a[i].p>>a[i].s;
        }
        sort(a+1,a+n+1,cmp);//优先吃便宜的，所以对食品价格进行排序，价格相同时保质期长的在前
        l=1;
        if(f!=0) {//特判f为0的情况
            r=(m/f)+1;//次数最大为总钱数除以每次送外卖的次数
        } else r=m+1;
        while(l<r) {//三分
            midl=l+(r-l)/3;
            midr=r-(r-l)/3;
            if(get(midl)>=get(midr)) {
                r=midr-1;//因为是整形，所以赋值时要-1，下面l也要+1
            } else {
                l=midl+1;
            }
    //        cout<<l<<" "<<r<<" "<<get(midl)<<" "<<get(midr)<<endl;
        }
        cout<<get(l);//好像输出l或r都可以
        return 0;
}
```

---

## 作者：xtx1092515503 (赞：13)

应该是你谷首篇有证明的题解吧。这题虽然很容易 **猜** 到做法，但是认真证明的话还是挺难的，紫题当之无愧。

证明后的复杂度可以做到优于现行全体题解。

另外，部分题解其实是有误的，应该可以卡掉，但是我太懒不想卡。本文中给出了其错误方式，如果有读完本文且有兴趣去卡的读者可以试一试。

------

首先第一个观察是我们不会点了单然后不吃。这意味着每次点单都必然对应了某一天。

第二个观察是前一次点单的食物不会拖到后一次点单后再去吃（这样把它调整到后一次点单再来点必然合法）。进而一次点单，必然解决且仅解决点单时刻直到下一次点单前的生理需求。

于是我们考虑用一个函数 $f_1(x)$ 表示仅以一次点单，解决 $x$ 天内的生理需求，所需要的最少代价。

如何求出 $f_1(x)$ 呢？其实只要贪心。假如有一种食物，它保质期短还贵，我们显然不如选那些又长又便宜的食物。于是我们可以按照保质期排序后关于代价跑一个单调栈，就能求出最好的食物的备选集合，其中所有食物的价值随着保质期延长而单调增。

设这些食物分别为 $(a_1,b_1),(a_2,b_2),\dots,(a_k,b_k)$，其中 $a_i$ 表示第 $i$ 种食物的保质期加一（实际意义是该食物能满足前 $a_i$ 天的食物需求），$b_i$ 表示其价值，且按照 $a$ 严格递增排序（按照我们上述结论，此时 $b$ 亦为严格递增）。我们认为 $a_0=0$。

那么，我们显然会在 $(a_{0},a_1]$ 间用第一种食物满足，$(a_1,a_2]$ 用第二种，……，$(a_{k-1},a_k]$ 用第 $k$ 种。

翻译成数学语言，就是对于 $x\in(a_{i-1},a_i],f_1(x)=f_1(x-1)+b_i$。我们认为 $f_1(0)=F$，其中 $F$ 为题目中给出的每次点单的外卖费。 同时，对于 $x>a_k$，我们认为 $f_1(x)=+\infty$。

因为 $b_i$ 单调增，所以整个 $f_1$ 在平面直角坐标系中，应该是一个下凸壳。

这个凸壳上只有整点，不太优雅。我们认为，非整数处的 $f_1(x)$ 也是有意义的：其函数图像为前后两个整点间连线。显然，这样扩张定义域后，其仍然是凸的。

现在考虑点单 $p$ 次的结果 $f_p(x)$。这其实就是 $k$ 个 $f_1$ 凸壳作闵可夫斯基和的结果。因为 $f_1(x)$ 均是凸的，所以由凸包闵可夫斯基和相关性质，我们可以发现 $f_p(x)$ 的函数图像即为 $f_1(x)$ 上所有点的横纵坐标各自扩大 $p$ 倍的结果。

我们考虑点单 $p$ 次，使用 $m$ 的预算，所能达到的最大 $x$。其实就是 $f_p(x)$ 的函数图像与直线 $y=m$ 的交点的横坐标，记作 $g(p)$。

该横坐标可能非整数；但是我们认为其是 **有效** 的，最终求出的答案也可能是非整数，此时下取整即得真实答案。

显然，我们要求的，就是对于 $p$ 为一切正整数，求出 $g(p)$ 的最大值。

我们考虑将 $p$ 的定义域扩张为一切正实数。此时 $f_p$ 的定义仍是 $f_1$ 上所有点的横纵坐标各自扩大 $p$ 倍的结果，且其仍然是合理的定义。

这样之后，我们考虑 $g(p)$：发现，其实际上可以被写作 $f_1(x)$ 与直线 $y=\dfrac mp$ 的交点的横坐标，乘以 $p$ 倍的结果。

对于 $f_1(x)$ 上任一一点 $(x,y)$（除 $(0,F)$ 以外），我们都可以找到其对应的直线 $y=\dfrac mp$（此时 $p=\dfrac my$）。于是有 $(x,y)$ 对应了 $g(\dfrac my)=m\times\dfrac xy$。

我们发现，$\dfrac xy$ 即为点 $(x,y)$ 与原点连线的斜率的倒数。而本题中一个第一象限中的下凸壳 $f_1(x)$，其上点与原点连线的斜率，在原点到该凸壳的切点处取得最小值，自切点向左向右 **严格** 递增。取倒数后，我们发现这意味着 $g(p)$ 其实亦是一个 **严格** 的单峰函数。当然也有可能存在的不是一个切点，而是一条切线段，此时切线段中所有 $g(p)$ 均相同，两端的 $g(p)$ 亦是严格递减。但不管是哪种，都是可以三分的。（但是，这里的三分必须是在 **实数域** 上三分，整数域上的三分还是会出现两个三分点处的 $g$ 值相等进而无法判定最值到底在哪侧；因此，部分题解中的整数三分写法其实是 **有误** 的。）

当然我们亦可以不三分，直接找切点。这亦是简单的：切点其实必为 $f_1(x)$ 上的那些斜率改变的“拐点”，其实就是 $a_1,a_2,\dots,a_k$。直接去找这些拐点然后求最小斜率即可找到切点。

切点对应的 $\dfrac my$ 不一定是整数值，此时要找到向下向上取整后的 $g$ 值的较大者。

复杂度可以做到除排序严格线性。

代码中理论会乘出 $10^{54}$ 级别的东西进而爆 `__int128`，但是实际因为数据水所以过去了。好孩子不要学。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef __int128 ii;
int n,tp;
ll ex,m;
ii res;
pair<ll,ll>p[210];
ii f[210];
ii g(ll x){
	if(m<=f[0]*x||!x)return 0;
	for(int i=1;i<=tp;i++)
		if(f[i-1]*x<=m&&m<=f[i]*x)
			return p[i-1].first*x+(m-f[i-1]*x)/p[i].second;
	return p[tp].first*x;
}
int main(){
	scanf("%lld%lld%d",&m,&ex,&n);
	for(int i=1;i<=n;i++)scanf("%lld%lld",&p[i].second,&p[i].first),p[i].first++;
	sort(p+1,p+n+1);
	for(int i=1;i<=n;i++){
		while(tp&&p[tp].second>=p[i].second)tp--;
		p[++tp]=p[i];
	}
	f[0]=ex;for(int i=1;i<=tp;i++)f[i]=(ii)(p[i].first-p[i-1].first)*p[i].second+f[i-1];
	int cp=1;
	for(int i=2;i<=tp;i++)if(f[i]*p[cp].first<f[cp]*p[i].first)cp=i;
	printf("%lld\n",(ll)max(g(m/f[cp]),g(m/f[cp]+1)));
	return 0;
}
```



---

## 作者：灯芯糕 (赞：13)

## $solution:$

看到这一题题面，莫名想到了（蔬菜），于是莫名开始恐慌。考场上只知道有个贪心计算快递小哥来一次，我要买能活n天的最小花费，却没想到还有一个三分法来枚举快递小哥来的次数！

首先我们可以脑补一下，快递小哥来的次数，和宅男活的总天数是成一个二次函数关系的。就像快递小哥来的次数少，那宅男多数的钱只能分到这么少的购买次数中，因为便宜的保质期短，每次必然会买一些保质期长价格贵的食物；当快递小哥来的次数多了，那我的钱可以分配到很多次购买机会中，是可以每次买些便宜的，可是你就会发现钱不多了（都给快递小哥付运费了！）所以我们三分找到中间的那一个平衡点(合理的购买次数能（钱尽其用）活得更久！！)

这是三分，那本题贪心贪在哪儿呢？我们读题发现，他给你的食品中肯定有一些垃圾食品（价格贵，保质期又短），我们可以进行筛选：单调队列，先将食品按保质期从大到小排序，然后放入以价格单调增的队列中去（因为后面放进取得食品保质期一定更长（排了序的），一但价格还比前一个低，就可以取代前一个食品）

然后还有一个贪心，就是在$check()$函数中，计算能活的最长天数时，只要在保质期内，我一定买最便宜的。就像我现在经筛选后有两个食品，一个保质期为5，价格为4，另一个保质期为8，价格为7，那我$[1,6]$天一定买第一个，$[7,9]$天一定买第二个！因为我们单调栈中时间从小到大，所以每次算活得最长天数时复杂度$O(n)
$再加上三分的复杂度，本题刚好够用！

然后对代吗做个解释：因为根据题意，保质期为1天的食品，可以留两天！！！（被这个坑惨了）所以我们在读入时干脆就给保质期加一，这样方便运算！然后解释一下我的$check（）$函数：

1. 我的$check()$买东西时，是同步的，如果买一个食品，那快递小哥来的$x$次都买这个食品（那个$if$除外）
2. $left:$我还剩下的钱的数量，（因为特性1，所以每一次都要减去我买的食品的价格乘以它的数量再乘以$x$天）
3. $now：$我同步买东西能同步维持的天数目前是多少
4. $day:$我有几天需要买这一种食品（如果没有足够的钱贪心的买，就会转到$if$中去）
5. $tot:$我总共能维持多少天
6. $if(now<b[i].t):$我没足够的钱来$x$天同步买一个东西，那我能买几天买几天，然后$return $

接下来一切以代码为准：

## $code:$

```cpp
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<ctime>
#include<cmath>
#include<vector>
#include<queue>
#include<map>
#include<set>

#define ll long long
#define db double
#define inf 0x7fffffff
#define rg register int

using namespace std;

struct su{
	ll v,t;
}a[215],b[215];

ll n,top;
ll ans,m,f;//如题

inline ll qr(){//快读，可以忽略
	char ch;
	while((ch=getchar())<'0'||ch>'9');
	ll res=ch^48;
	while((ch=getchar())>='0'&&ch<='9')
		res=res*10+(ch^48);
	return res;
}

inline bool cmp(su x,su y){return x.t<y.t;}

inline ll check(ll x){
	ll left=m-x*f,now=0,day,tot=0;//剩余的钱，每一次买的食物能维持几天，我还有几天需要买这个食物，总共能维持多少天
	if(left<0)return 0;
	for(rg i=1;i<=top;++i){//快递小哥来的x次都买这种食物
		day=min(b[i].t-now,left/(b[i].v*x));//每一次都买几个
		now+=day; tot+=day*x; left-=b[i].v*day*x;//进行统计转移
		if(now<b[i].t){tot+=left/b[i].v;break;}//剩余的钱不能支持每一次都买了，就能卖几次买几次，然后return
	}return tot;
}

int main(){
	//freopen("food.in","r",stdin);
	//freopen("food.out","w",stdout);
	m=qr();f=qr();n=qr();
	for(rg i=1;i<=n;++i)
		a[i]=su{qr(),qr()+1};
	sort(a+1,a+n+1,cmp); //按时间排序！！！（非价值）
	for(rg i=1;i<=n;b[++top]=a[i],++i)
		while(top&&a[i].v<=b[top].v)--top;//用单调栈进行食品筛选（加速）
	ll l=1,r=m/(f+b[1].v),mid1,mid2,tot,s1,s2;//r的值可以算出来
	while(l<=r){ //三分法求峰值
		tot=r-l+1,mid1=l+tot/3,mid2=l+tot*2/3;
		s1=check(mid1);s2=check(mid2);
		ans=max(ans,(s1<s2?l=mid1+1,s2:r=mid2-1,s1));//究极的三目运算压行
	}printf("%lld\n",ans);
	return 0;
}

```
updata：删了一些无用的图片与链接


---

## 作者：yzx72424 (赞：9)

其实这一题二分套三分也是是可以证明单峰的，不一定非得三分套二分。我们发现这样会爆long long,**但是**我们的C++11有__int128呀。~~完结撒花~~

---

## 作者：zhangzhaoke (赞：8)

啊哈，没有人写模拟退火吗

我来写一发模拟退火的题解

# 为什么用模拟退火？

1.因为这个题可以使用模拟的方法来重复寻找最优解

2.近似单峰函数，模拟退火可以确保稳定性

细节挺多的，我因为不小心用了两个m作为变量调了一个多小时

注释全在代码里

# 模拟退火是什么？

模拟退火的出处什么的就不管了，也不是重点。可能你也看过很多模拟退火 （简称  sa ） 的题解，但是完全看不懂。那么你可以先看看我的题解，做几道简单的题后再去看别的题解，你就会豁然开朗，很多人写的比我好很多。

大概算法的意思是，我设定一个值 （一般为 3000 左右） ，每次略微减少一点点 （一般是 0.99 左右） ，然后到达一个我设定的最小值 （一般为 1e-10 到 1e-14 ） 时停止。这个设定是根据需要来定，如果太少就会 wa，太多会 tle。然后每一次判断是否更优，更优就替换最优答案，不是更优就要按照一个概率接受（也就是代码中的 exp）。在循环很多次后，大概率找到最优解，但是那种 50 多个峰的函数就不好解决。

exp 那句是 sa 中最精髓的一句，因为越优接受概率越大，温度越低 （也就是设定的那个3000 ） 振动幅度越小，最后在温度越来越低的时候，肯定会落到最优解周围，温度降低到接近 0 了就到了最优解**

OI 赛制中不建议使用，因为只有一次提交机会，但是骗分用还是不错的！

# 本题代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int INF = 2147483647;

int n;
long long A,now,ans;
long long m,f;

struct power{
    long long cost;
    long long days;
}a[201];//每个食物的价格和保质天数

bool cmp(power a,power b){//排序函数，意思是优先价格小，相等按天数长
    if(a.cost == b.cost) return a.days > b.days;
    else return a.cost < b.cost;
}
long long check(long long times){//检验函数
    if(times<=0) return 0;//购买次数小于等于0直接退出
    long long money = m - times * f;//钱数=初始-购买次数*快递费
    long long res = 0, num, day = 0; 
    for(int i=1;i<=n;i++){
        num = min(money / a[i].cost / times, a[i].days - day + 1);
		//判断最小值，去价钱/价格/购买次数和目前天数的最小值（也就是最多活几天）
		//原因是要不然就没钱买了，要不然就没保质期吃不了了，所以取最小
        money -= num * a[i].cost * times;//钱花出去了
        day += num;//然后就活了这么多天
		res += times * num;//答案增加
        if(day <= a[i].days){//活的天数小于食物保质期
            num = money / a[i].cost;//现在的钱-花费的钱
            res += num;//最多的天数增加
            ans = max(ans, res);//更新最优解
            return res;//返回目前这个函数的值来对比
        }
    }
    ans = max(ans, res);
    return res;
}
void sa(double T){
    now = 1;
    while(T >= 1){
        A = now + (long long)(T * ((rand()/(double)RAND_MAX)*2-1));
        if(A<=0) A = T*(rand()/(double)RAND_MAX);
        if(check(A) > check(now))now = A;//更优则换
        T *= 0.93;//降温量
    }
}
int main(){
    scanf("%lld%lld%d",&m,&f,&n);
    for(int i=1;i<=n;i++)scanf("%lld %lld",&a[i].cost,&a[i].days);
    sort(a+1,a+n+1,cmp);//排好序了
	long long d = -1;//赋一个最小值，-1就够
    int ccf = n;
    n = 0;
    for(int i=1;i<=ccf;i++){
		if(a[i].days > d){
			a[++n]=a[i];//直接压缩一下，因为那些又贵又短的食物不用买
			d=a[i].days;//日期加到现在的最大值
			//也就是说，如果有一个食物比现在最好的食物好（两方面，一方面是价格，但是因为排完序了，所以只需要对比保质期就行）
		}
	}
    ans = 0;
    for(int sw = 0; sw < 100; sw++)sa(m/f+1);//跑100遍，最稳
	//m/f+1是代码的点睛之笔：一开始的温度不是一个定值，而是一个随着可以叫快递员次数增多而增多的一个值，如果改成3000或者30000这种都过不了最后几个点
    printf("%lld\n",ans);
    return 0;
}
```

# 总结

模拟退火是一个非常好用的算法，适合暴力推算，适合骗分。

这个温度和降温量真的很神奇，自己多做多调才能感受到，看别人的题解感受不了

这个题可能是我交的最多的一个题了（交了45遍啊！！！




---

## 作者：shadowice1984 (赞：6)

来一发三分套二分的题解
首先，我们发现这道题是个应用题，数据范围极大，省选难度
所以是考你三分法了，然后我们对于这道题，需要找几个贪心的结论

1.对于某些保质期短又贵的垃圾食品，我们坚决不要，所以可以他们删掉，所以食品的价格随保质期单增

2.如果当前买的轮次c固定，那么当前最优解仅有买M和M+1两种天数，也就是说，天数接近的时候最优，证明如果有一个方案天数是不接近的，那么把大的往小的上补，因为保质期随价格单增，肯定会变优

那么我们发现一件事，如果给定钱数，那么我们能存活到第几天是可以二分的，又因为刚才的结论2，我们可以把钱均分为c份，二分出一个存活时间k，我们发现，剩下的钱一定不能所有的天都买k+1天的量但是有几天可以所以，我们列出了总存活天数T与买的轮次C的函数

T=(M-cost(k)\*c-c\*f)/(cost(k+1)-cost(k))+k\*c ,k=D((M-C\*f)/C)

打表找规律发现这个函数单峰，可以三分求最值（不会证明，ε=ε=ε=┏(゜ロ゜;)┛逃）

 _（其实有一个二分套三分是可以证明单峰的，然而我们发现会爆long long）_
 
 上代码~
 
 

```C
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
int n;int cnt;ll m;ll f;
struct food
{
	ll cst;ll kep;
	friend bool operator <(food a,food b){return a.kep<b.kep;}
}tp[210],fo[210];
inline ll cost(ll t)//计算存活到t的花费 
{
	ll res=0;
	for(int i=1;i<=cnt;i++)
	{
		if(res<0){return -1;}
		if(t>fo[i].kep){res+=fo[i].cst*fo[i].kep;t-=fo[i].kep;}
		else {res+=fo[i].cst*t;return res;}
	}return -1;//这里是避免爆INF 
}
inline ll calcd(ll pm)//计算花多少钱可以存活多少天 
{
	ll l=0;ll r=pm;
	while(l<r)//单调可以二分 
	{
		ll mid=(l+r+1)/2;ll y=cost(mid);
		if(y==-1||y>pm){r=mid-1;}else {l=mid;}
	}
	return r;
}
inline ll calct(ll r)//计算T 
{
	ll rest=m-r*f;if(rest<0||rest>m){return 0;}//还是避免爆longlong 
	ll pm=rest/r;ll k=calcd(pm);if(k==0){return 0;} 
	ll c2=cost(k+1);ll c1=cost(k);if(c2==-1){return r*k;}
	else {rest-=c1*r;return rest/(c2-c1)+r*k;}
}
int main()
{
	scanf("%lld%lld%d",&m,&f,&n);
	for(int i=1;i<=n;i++){scanf("%lld%lld",&tp[i].cst,&tp[i].kep);}
	sort(tp+1,tp+n+1);tp[0].kep=-1;fo[0].kep=-1;
	for(int i=1;i<=n;i++)//单调栈去掉无用的东西 
	{while(cnt!=0&&tp[i].cst<fo[cnt].cst){cnt--;}fo[++cnt]=tp[i];}
	for(int i=cnt;i>=1;i--){fo[i].kep-=fo[i-1].kep;}//后向差分方便计算 
	ll l=1;ll r=m/f+1;//三分法求函数最值 
	while(r-l>5)//缩小区间 
	{
		ll x1=l+(r-l)/3;ll x2=l+((r-l)*2)/3;
		ll y1=calct(x1);ll y2=calct(x2);
		if(y1<y2){l=x1;}else {r=x2;}
	}
	ll res=calct(l);//然后暴力枚举最大值 
	for(ll i=l+1;i<=r;i++){res=max(res,calct(i));}
	printf("%lld",res);return 0;//拜拜程序~ 
}
```


---

## 作者：hhhh531889330 (赞：2)

看到这道题没有直接贪心的做法，我来补一发题解。

首先，读完体面我们容易发现一个性质，那就是对于所有的点 $i$ 满足存在一个点 $j$ 使得 $p_i>p_j$ 且 $s_i<s_j$ 那么 $i$ 点一定没有用处，我们可以直接不考虑。

排除掉这一部分点之后，容易发现剩下的点随 $s$ 值的变大，其 $p$ 值单调递增，那么我们不难发现，对于每一种外卖，它能被选择的区间只有 $s_i-s_{i-1}$ 其中 $s$ 按从大到小排序。我们可以发现，每加入一种新的外卖，就会改变之前所有已选择外卖的单价（包含了外卖费），显然，若选择一种外卖会降低单价，那么多选几份只会让单价更低。因此，一种外卖要么全选，要么全不选。

然后我们猜测，最后的答案是由若干个相同的外卖订单所组成的。由于 $p_i$ 单调递增，我们可以贪心的确定最优的外卖订单，然后贪心的解决问题。

值得注意的是，对于剩余资金的处理有两种方案。第一种是将其均匀分配到之前的外卖订单后，也就是再选一部分之前我们舍弃的外卖种类，第二种是直接再开一个新的订单，因为当前的剩余资金严格小于我们之前求出来的更优订单，这两种做法并不冲突。只需要在两种中选出答案更大的那一种便可通过此题。

时间复杂度 $O(n \log n)$，其中的 $\log$ 来自于排序，若将排序换成基数排序，则可做到 $O(n)$。

以下为满分代码

```
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define I1 __int128
LL s,c;
int i,j,n,m,k,l,o,p;
struct node
{
	LL s,p;
}item[205];
inline LL read()
{
	LL f(1),x(0); char ch(getchar());
	while (!isdigit(ch)) { if (ch=='-') f*=-1; ch=getchar(); }
	while (isdigit(ch)) x=(x<<1)+(x<<3)+ch-48,ch=getchar();
	return f*x;
}
inline int cmp(node x,node y)
{
	return x.s<y.s||(x.s==y.s&&x.p<y.p);
}
int main()
{
	s=read(),c=read(),n=read();
	for (i=1;i<=n;i++) item[i].p=read(),item[i].s=read(); LL mn(1e18);
	sort(item+1,item+n+1,cmp);
	for (i=n;i>=1;i--) 
	{
		mn=min(mn,item[i].p);
		if (mn<item[i].p) for (j=i,--n;j<=n;j++) item[j]=item[j+1];
	}
	I1 sum(c+item[1].p*(item[1].s+1)),num(item[1].s+1);
	for (i=2;i<=n;i++) 
	{
		if (item[i].p*num>sum) break;
		sum+=(item[i].s-item[i-1].s)*item[i].p,num=item[i].s+1;
	}
	LL ans(s/sum*num),cs(s/sum);
	s%=sum;
	item[0].s=-1;
	LL ag=s,ans1(0),ans2(0);
	for (j=i;j<=n;j++) 
	{
		LL x=min((item[j].s-item[j-1].s)*cs,ag/item[j].p);
		ag-=x*item[j].p,ans2+=x;
	}
	if (s>=c) 
	{
		s-=c;
		for (i=1;i<=n;i++)
		{
			LL x=min(item[i].s-item[i-1].s,s/item[i].p);
			s-=x*item[i].p,ans1+=x;
		}
	}
	printf("%lld",ans+max(ans1,ans2));
}
```

---

## 作者：Aisaka_Taiga (赞：2)

首先声明一点，这篇题解只是我看了别人的题解后自己的一些见解，还有为什么用   scanf 会 wa 一个点我改了好久qwq

看到题面，自己写几个数一次一次试就可以发现，购买外卖的次数和能在家的天数是两头低，中间高的一个图像（题解里说是什么单峰的函数，但小学数学水平的我不懂），这时候二分的话很显然会出错，因为二分适用于类似于单调函数的情况，那么这时候就需要三分来解决这个问题，因为求的是能宅的天数，那我们就来三分购买外卖的次数，计算每一种购买外卖次数的最优解，然后不断三分范围求出解就好了。

要想计算每一种购买外卖次数的最优解就要用到贪心了（不看标签我我就爆搜了）我们需要先按价格排序，价格相同比保质期（毕竟咱不是多有钱），从价钱最低的外卖开始买就好了，一直买到没钱或者说一份也买不起就退出循环，还要把每次购买剩下的钱加起来再去循环，然后看看哪一种能在家颓废的天数最多，返回相应的天数就好了，根据返回的天数来判断应该往哪里缩小范围，三分继续求解，直到不能再分为止。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long//用这个下面int main要改成signed main 
using namespace std;
struct sss{
	int p,s;//p是价钱，s是保质期 
}e[10010];
int m,f,n,l,r,midl,midr,ans1;//l是左边界，r是右边界，mindl是三分后的左边界，midr是三分后的右边界 
bool cmp(sss a,sss b)//结构体比较函数 
{
	if(a.p!=b.p)return a.p<b.p;//金钱至上，先买便宜的 
	return a.s>b.s;//一样贵就买保质期长的 
}
int mai(int x)//买x次 
{
	int v,ans,now,w,k,p,j;
	v=m-x*f;//先减去邮费 
	w=v/x;//计算每一次可以花多少钱 
	k=v-w*x;//计算有没有剩下的，就是上面那步余下的 
	ans=0;now=0;//初始化 
	if(v<0)return 0;//单单是邮费就付不起，没钱点外卖 
	for(int i=1;i<=n;i++)//n种食物依次枚举 
	{
		if(e[i].s>=now&&w-e[i].p>=0)//如果当前食物过不了保质期并且钱够买至少一份 
		{
			p=min(e[i].s+1-now,w/e[i].p);//p存放最多可以买的第i种外卖，因为一次买的不能超过保质期，不然就坏了，所以取保质期和能买的较小值 
			now+=p;//接下来p天宅在家吃第i种外卖 
			w-=p*e[i].p;//减去花费的钱 
		}
		j=i;//记录当前已经买了多少种外卖 
		if(w-e[i].p<0)break;//买不起了就退出循环 
	}
	k+=x*w;//加上每天买外卖剩下的钱 
	for(int i=j;i<=n;i++)//从之前买不起的外卖接着买 
	{
		if(e[i].s>=now&&k-e[i].p>=0)//同样的，不过保质期，至少能买一种 
		{
			p=k/e[i].p;//计算能买几件外卖，k/e[i].p是当前钱能买的数量 
			ans+=p;//加上能买的数量 
			k-=p*e[i].p;//减去买外卖花的钱 
		}
		if(ans)break;//只要ans有值余额肯定不够买下一种的了，直接退出 
	}
	return x*now+ans;//返回k撑的天数和买第一次选择的外卖撑的天数 
}
signed main()
{
	cin>>m>>f>>n; 
	for(int i=1;i<=n;i++)
	  cin>>e[i].p>>e[i].s;///输入每一件外卖的价钱，保质期 
	sort(e+1,e+n+1,cmp);//排序 
	l=1;//左边界，最少买一次 
	if(f!=0) r=m/f+1;//计算最多可以买多少次的外卖 
	else r=m+1;//当包邮的时候特判一下，最多可以买m+1次（没准有1块的外卖
	while(l<r)
	{
		midl=l+(r-l)/3;//三分找到新的左边界 
		midr=r-(r-l)/3;//找右边界 
		if(mai(midl)>=mai(midr))//如果midl左边界撑的天数不小于midr右边界撑的天数 
		r=midr-1;//证明右边界取大了，右边界左移 
		else l=midl+1;//反之就是左边界取小了，左边界右移 
	}
	cout<<max(mai(l),mai(r))<<endl;//输出l和r中次数可以颓的久的天数（其实l==r了 
	return 0;//好习惯 
}
```


---

## 作者：Dovish (赞：0)

非常好贪心题！

尝试从更加靠谱的角度入手，而不是乱搞乱猜。

## 分析
首先，如果数据范围很小，会不会做？

我们将每次点外卖这个事件视作一个物品，天数就是其价值，花费就是其占用空间。然后对所有物品做完全背包即可得到答案。

考虑求出一次购买外卖时一个对应天数的最小花费。

显然，可以观察到，如果一个两种外卖之间，存在一个外卖即贵保质期又短，那么显然没有必要选择这个。所以可以认为价格随着保质期单增。

那么，我们的策略就是先买最便宜的，买到堆满保质期了就再买第二便宜的，以此类推。可以发现由于单价是递增的，所以总花费关于天数是一个凸函数。（但是考虑一次外卖有固定的 $f$ 的成本，所以实际上凸包在求出来之后向上平移之后还需要考虑加入 $(0,0)$ 点然后重新更新凸包，新凸包上第一个节点就是对应性价比最大的物品）我们下文称一个凸包上的点对应的外卖指的是该物品对应的外卖中保质期最长的那一个。

凸函数的背包是可以贪心的，我们可以尽可能选择第一个凸包上的第一个物品。

考虑到天数是连续的而价值是不一定连续的，考虑二分答案。

只需要考虑尽可能地选择性价比最高的物品，这样选择和 check 的答案之间还有一定距离，这部分考虑选择下一个物品对应的外卖，亦或者再点一次外卖，从前往后选。

那么复杂度是 $O(n\log n+\log V)$，瓶颈在于排序去掉被完全偏序的外卖。

代码似乎写假了就不放了，不过也是能过的。

[LOJ的提交记录。](https://loj.ac/s/2372187)

---

## 作者：M78cong (赞：0)

此题的思路从其他大佬的题解可以很清晰的看出来，能宅的天数与点外卖的次数成
单峰函数，所以我们**以点外卖的次数**为变量进行三分。

我一开始的代码如下

```cpp
	while(r-l>1){  //以外卖次数进行三分 
		mid = l+(r-l)/2;
		midl = mid-1;
		midr = mid+1;
		if(get_ans(midl)>get_ans(midr)) r = mid;
		else l = mid;
	}
	cout<<max(get_ans(l),get_ans(r));
```
然而这份代码只得了 90 分，样例七没有通过.

原因在于三分是无法判断数值相同的情况，如果在**峰值的左侧（或者右侧）出现了两个相等的值**，此时，我们将没有办法判断我们的 $l$ 与 $r$ 究竟该偏向哪边

我们可以通过递归来避免这样的问题

```cpp
//get_ans(x)是算出点x次外卖能宅几天
ll three_find(ll l,ll r){  //三分查找 
	ll midl,midr,save1,save2;
	bool q=false;  //表示是否出现了值相等无法判断的情况 
	while(r-l>1){  //以外卖次数进行三分
		midl = (l+r)/2-1;
		midr = (l+r)/2+1;
		save1 = get_ans(midl);
		save2 = get_ans(midr);
		if(save1 > save2) r = (l+r)/2;
		else if(save1 == save2){ //当出现相同值时，退出循环
			q = true;
			break;
		}
		else l = (l+r)/2;
	}
	ll ans = 0;
	if(q) {
		ll ans1 = get_ans(midl+1);
		if(ans1 != save1){ 
			ans = ans1; //如果两数之间的中间值不同，那么峰值一定在中间
		}
		else{  //峰值在哪边，哪边的最大值将!=get_ans(midl)
			ll ans2 = three_find(l,midl);
			if(ans2 != save1) ans = ans2;
			else{
				ll ans3 = three_find(midr,r);
				ans = ans>ans3 ? ans:ans3;
			}
		}
	}
	else ans = max(get_ans(l),get_ans(r));
	return ans;
}
```
由于是单峰函数，所以峰值只会出现在左侧、右侧 或者 中间，我们**只需求出其中一侧的最大值不等于原来的 $get\_ans(midl)$ 的值**，这样就不用再去求其它侧了

完整代码如下：
```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#define ll uint64_t
using namespace std;
ll m,f;
int n;
vector< pair<ll,ll> > v;
bool cmp(pair<ll,ll>& s1,pair<ll,ll>& s2){
	if(s1.first==s2.first) return s1.second>s2.second;
	return s1<s2;
}
void input(){  //读入数据
	cin>>m>>f;
	cin>>n;
	for(int i=0;i<n;i++) {
		pair<ll,ll> tem;
		cin>>tem.first>>tem.second;
		v.push_back(tem);
	}
}
void sort_v(){  //将食物按价格排序，删去价格高但保质期低的食物，修改 n=v.size() 
	sort(v.begin(),v.end(),cmp);
	auto pre = v.begin();
	for(auto it = v.begin()+1;it!=v.end();it++){
		if((*it).second<=(*pre).second) {
			v.erase(it);
			it = pre;
		}
		pre = it;
	}
	n = v.size();
}

ll get_ans(ll x){  //表示买x次外卖能活几天 
	if(x==0) return 0;
	ll w = m-x*f;
	ll ans = 0;
	for(int i=0;i<n;i++){ //表示买到了第几种食物 
		ll num = w/v[i].first; //这种食物最多能买多少个 
		if(num==0) break;  //一个都买不了，不买了 
		ll max_num = 0;  //表示这种食物最多能买几个不过期的 
		if(i==0){
			if(v[i].second+1>num/x) {  //为了防止数据超过long long 
				max_num = num+1;
			}
			else max_num = (v[i].second+1)*x;
		}
		else{
			if(v[i].second-v[i-1].second>num/x) {
				max_num = num+1;
			}
			else max_num = (v[i].second-v[i-1].second)*x;
		}
		if(num>max_num) num = max_num;//如果买的食物超过了保质期,就只买保质期内的食物 
		ans += num;
		w -= num*v[i].first;
	}
	return ans;
}

ll three_find(ll l,ll r){  //三分查找 
	ll midl,midr,save1,save2;
	bool q=false;  //表示是否出现了值相等无法判断的情况 
	while(r-l>1){  //以外卖次数进行三分
		midl = (l+r)/2-1;
		midr = (l+r)/2+1;
		save1 = get_ans(midl);
		save2 = get_ans(midr);
		if(save1 > save2) r = (l+r)/2;
		else if(save1 == save2){
			q = true;
			break;
		}
		else l = (l+r)/2;
	}
	ll ans = 0;
	if(q) {
		ll ans1 = get_ans(midl+1);
		if(ans1 != save1) ans = ans1;
		else{
			ll ans2 = three_find(l,midl);
			if(ans2 != save1) ans = ans2;
			else{
				ll ans3 = three_find(midr,r);
				ans = ans>ans3 ? ans:ans3;
			}
		}
	}
	else ans = max(get_ans(l),get_ans(r));
	return ans;
}

int main(){
	input();
	sort_v();
	//此题是单峰函数，使用三分来求解最大值
	cout<<three_find(0,m/(f+v[0].first));
	return 0;
}
```


---

## 作者：zhouhuanyi (赞：0)

链接:https://www.luogu.com.cn/problem/P4040

题目描述：有$n$个食物，每个食物有一个价格$p_{i}$和一个保质期$s_{i}$,$JYY$每天都要吃一个食物，它可以通过向外买小哥点外卖来获取食物，每叫一次外卖就要付$f$元。问若$JYY$有$M$元，他最多能吃多少天的外卖。

题解：我们可以三分外卖小哥来的次数。现在就只用考虑外卖小哥来$k$次所能吃的最大天数了。

考虑对于一个价格为$p_{i}$，保质期为$s_{i}$的食物与一个价格为$p_{j}$，保质期为$s_{j}$的食物，若$p_{i}<=p_{j}$且$s_{i}>=s_{j}$，那么选$j$就不如选$i$，所以我们可以排除掉这样的食物，可以按$s$排序后用单调栈维护。

现在$p$与$s$都可以满足单调递增了，由于我们选择肯定是先吃是先吃$s$尽量小的，先买也是先买$p$尽量小的，所以我们可以从左到右依次买，买到买不了这一个时再买下一个，依次加入$k$个外卖小哥的贡献中。

但这样可能出现这这$k$个外卖小哥的贡献各不相同，但我们仔细想可以发现，加入$k$个外卖小哥的贡献各不相同，那么这一个食物一定是你最后买的，因为你没法买满这个食物，就更没法买满下一个价格比它更大的食物了。

复杂度$O(nlogn)$

```
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
struct node
{
	long long p,s;
	bool operator < (const node &a)const
	{
		return s<a.s;
	}
};
node point[600001];
long long n,f,m,deque[600001];
long long F(__int128 x)
{
	__int128 maxn,lst=0,cnt=0,M;
	M=m-f*x;
	if (M<0)
		return -1;
	int top=0;
	for (int i=1;i<=n;++i)
	{
		while (point[deque[top]].p>=point[i].p)
			top--;
		deque[++top]=i;
	}
	for (int i=1;i<=top;++i)
	{
		maxn=min(M/point[deque[i]].p,(point[deque[i]].s-lst+1)*x);
		if (maxn<=0)
			break;
		M-=maxn*point[deque[i]].p;
		lst+=maxn/x;
		cnt+=maxn; 
	}
	return cnt;
}
signed main()
{
	long long ans=0;
	__int128 first,last,mid,mid2; 
	cin>>m>>f>>n;
	first=1;
	last=m/f;
	for (int i=1;i<=n;++i)
		cin>>point[i].p>>point[i].s;
	sort(point+1,point+n+1);
	while (first<=last)
	{
		mid=first+(last-first)/3;
		mid2=last-(last-first)/3;
		if (F(mid)<F(mid2))
		{
			first=mid+1;
			ans=max(ans,F(mid));
		}
		else
		{
			last=mid2-1;
			ans=max(ans,F(mid2));
		}
	}
	cout<<ans<<endl;
	return 0;
}

---


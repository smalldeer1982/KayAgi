# [AHOI2014/JSOI2014] 奇怪的计算器

## 题目背景

JYY 有个奇怪的计算器，有一天这个计算器坏了，JYY 希望你能帮助他写一个程序来模拟这个计算器的运算。

## 题目描述

JYY 的计算器可以执行 $N$ 条预设好的指令。每次 JYY 向计算器输入一个正整数 $X$，计算器就会以 $X$ 作为初始值，接着依次执行预设的 $N$ 条指令，最后把最终得出的结果返回给 JYY。

每一条指令可以是以下四种指令之一：（这里 $a$ 表示一个正整数。）

1. $+a$：表示将当前的结果加上 $a$；
2. $-a$：表示将当前的结果减去 $a$；
3. $\times a$：表示将当前的结果乘以 $a$；
4. $@a$：表示将当前的结果加上 $a\times X$（$X$ 是一开始 JYY 输入的数）。

计算器用于记录运算结果的变量的存储范围是有限的，所以每次运算结束之后会有计算结果溢出的问题。

JYY 的计算器中，存储每计算结果的变量只能存储 $L$ 到 $R$ 之间的正整数，如果一次指令执行过后，计算结果超过了 $R$，那么计算器就会自动把结果变成 $R$，然后再以 $R$ 作为当前结果继续进行之后的计算。同理，如果运算结果小于 $L$，计算器也会把结果变成 $L$，再接着计算。

比如，假设计算器可以存储 $1$ 到 $6$ 之间的值，如果当前的计算结果是 $2$，那么在执行 $+5$ 操作之后，存储结果的变量中的值将会是 $6$。虽然 $2+5$ 的实际结果是 $7$，但是由于 $7$ 超过了存储范围的上界，所以结果就被自动更正成了上界的大小，也就是 $6$。

JYY 一共想在计算器上输入 $Q$ 个值，他想知道这 $Q$ 个值输入计算器之后，分别会得到什么结果呢？

## 说明/提示

### 样例解释

当 JYY 输入 $2$ 时，计算器会进行 $5$ 次运算，每一次运算之后得到的结果分别是 $6$（实际计算结果为 $7$ 但是超过了上界），$3,6,1$（实际结果为 $-1$ 但是低于了下界）和 $5$（由于一开始输入的是 $2$，所以这一次计算为 $1+2 \times 2$）。

### 数据范围及约定

对于所有测试数据，$1\le N$，$Q\le 10^5$，$1\le L\le X_k\le R\le 10^9$，$1\le a\le 10^9$。

## 样例 #1

### 输入

```
5 1 6
+ 5
- 3
* 2
- 7
@ 2
3
2
1
5```

### 输出

```
5
3
6```

# 题解

## 作者：ldxcaicai (赞：23)

[传送门](https://www.lydsy.com/JudgeOnline/problem.php?id=3878)
线段树综合。
让我想起一道叫做[$siano$](https://blog.csdn.net/dreaming__ldx/article/details/81170850)的题，这题就是那题的强化版本。
说说做法吧：
跟$saino$一样，当我们把$a[i]$排成有序的之后，就会保证在若干次操作后整个数列仍然是单调的。
首先加减可以看成一个操作，$L,R$的限制也只相当于一个操作，因此这道题要我们维护这几个操作：
1.区间加
2.区间乘
3.区间加变形（加上原数$a[i]$的$k$倍）
4.区间覆盖
维护：区间最大最小，单点值。
因此我们可以设计一个神奇的更新函数$f(p,k_1,k_2,k_3)$，表示整个区间的值的变化方式：
$c[i]=c[i]*k_1+k_2*a[i]+k_3$，然后我们又可以惊奇的发现这个函数可以用于所有的区间修改函数。
1.区间加：$f(p,1,0,add)$。
2.区间乘：$f(p,mul,0,0)$。
3.区间加变形：$f(p,1,addx,0)$。
4.区间覆盖：$f(p,0,0,set)$。
这样的话，我们连前三个操作的单独的修改函数都不用写，简洁自然。
代码如下：

```
#include<bits/stdc++.h>
#define ll long long
#define N 100005
#define lc (p<<1)
#define rc (p<<1|1)
#define p1 T[p].lz1
#define p2 T[p].lz2
#define p3 T[p].lz3
#define mid (T[p].l+T[p].r>>1)
using namespace std;
struct Node{int l,r;ll mn,mx,lz1,lz2,lz3;}T[N<<2];
struct Query{int op;ll v;}q[N];
struct Ans{int id;ll v;}a[N];
int n,m;
ll ans[N],L,R;
inline ll max(ll a,ll b){return a>b?a:b;}
inline ll min(ll a,ll b){return a<b?a:b;}
inline void pushup(int p){T[p].mx=T[rc].mx,T[p].mn=T[lc].mn;}
inline void pushnow(int p,ll k1,ll k2,ll k3){
	p1*=k1,p2=p2*k1+k2,p3=p3*k1+k3;
	T[p].mx=T[p].mx*k1+k2*a[T[p].r].v+k3;
	T[p].mn=T[p].mn*k1+k2*a[T[p].l].v+k3;
}
inline void pushdown(int p){pushnow(lc,p1,p2,p3),pushnow(rc,p1,p2,p3),p1=1,p2=0,p3=0;}
inline void build(int p,int l,int r){
	T[p].l=l,T[p].r=r,p1=1,p2=p3=0,T[p].mx=a[r].v,T[p].mn=a[l].v;
	if(l==r)return;
	build(lc,l,mid),build(rc,mid+1,r);
}
inline void modify1(int p){
	if(T[p].l==T[p].r)return pushnow(p,0,0,L);
	pushdown(p);
	if(T[rc].mn<L)pushnow(lc,0,0,L),modify1(rc);
	else modify1(lc);
	pushup(p);
}
inline void modify2(int p){
	if(T[p].l==T[p].r)return pushnow(p,0,0,R);
	pushdown(p);
	if(T[lc].mx>R)pushnow(rc,0,0,R),modify2(lc);
	else modify2(rc);
	pushup(p);
}
inline bool cmp(Ans a,Ans b){return a.v<b.v;}
inline void query(int p){
	if(T[p].l==T[p].r){ans[a[T[p].l].id]=T[p].mn;return;}
	pushdown(p),query(lc),query(rc);
}
int main(){
	scanf("%d%lld%lld",&m,&L,&R);
	for(int i=1;i<=m;++i){
		char s[2];
		scanf("%s%lld",s,&q[i].v);
		switch(s[0]){
			case '+':{q[i].op=1;break;}
			case '-':{q[i].op=2;break;}
			case '*':{q[i].op=3;break;}
			default:{q[i].op=4;break;}
		}
	}
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%lld",&a[i].v),a[i].id=i;
	sort(a+1,a+n+1,cmp),build(1,1,n);
	for(int i=1;i<=m;++i){
		switch(q[i].op){
			case 1:{pushnow(1,1,0,q[i].v);break;}
			case 2:{pushnow(1,1,0,-q[i].v);break;}
			case 3:{pushnow(1,q[i].v,0,0);break;}
			default:{pushnow(1,1,q[i].v,0);break;}
		}
		if(T[1].mn<L)modify1(1);
		if(T[1].mx>R)modify2(1);
	}
	query(1);
	for(int i=1;i<=n;++i)cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：tytyty (赞：6)

## 题意
给出 $N$ 次操作，存储范围 $L$ 和 $R$，以及一个长度为 $Q$ 的序列。

有 4 种操作：
1. $+a$：表示将当前的结果加上 $a$。

1. $-a$：表示将当前的结果减去 $a$。

1. $*a$：表示将当前的结果乘以 $a$。

1. $@a$：表示将当前的结果加上 $a*X$（$X$ 是一开始输入的数）。

当执行完一次操作，大于 $R$ 的数把它变为 $R$，小于 $L$ 的数把它变为 $L$。

输出经过若干次操作后的序列。
## 思路

注意到每次操作对全局去最小值和最大值，我们可以考虑维护区间最小值和区间最大值，如果区间最大值大于 $R$ 则将大于 $R$ 的部分赋值为 $R$，区间最小值小于 $L$ 同理。


------------

前三种操作就是区间加（减），区间乘。第四种操作比较奇怪先不管它，找一个标记记录一下。


------------

观察到每次都对于整个序列进行操作，所以不改变各个数之间的大小关系，可以将序列排序之后再做。那么大于 $R$ 的数肯定在右边连续一段，小于 $L$ 的数同理。


------------
再来看第四种操作。虽然它很奇怪，但我们只需要维护区间最大值和最小值。而因为我们将序列排过序，所以最大值和最小值只受端点值的影响。更新时只需这样就好啦。
```cpp
void pushad(int rt, int l, int r, ll x) 
{
    minn[rt] += num[l].val * x;
    maxx[rt] += num[r].val * x;
    tad[rt]+=x; 
}
```


------------
## Code
（会有亿点点长，因为我木有将三种标记合起来写，感觉分开会容易理解一点吧，~~其实主要原因是我也不会~~）。
```
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 100005;
const int T = 4 * N + 5;
int n, mn, mx, q;
ll minn[T], maxx[T], tadd[T], tmul[T], tad[T], tset[T];
struct node1 {
    char s;
    ll a;
} op[N];
struct node2 
{
    ll id, val, ans;
} num[N];
bool cmp1(node2 a, node2 b) //按值排序
{
    return a.val < b.val;
}
bool cmp2(node2 a, node2 b) //按编号排序（输出时）
{
    return a.id < b.id;
}
void build(int rt, int l, int r) 
{
    if (l == r) 
	{
        minn[rt] = num[l].val;
        maxx[rt] = num[l].val;
        return ;
    }
    tmul[rt] = 1;
    int mid = l + r >> 1;
    build(rt << 1, l, mid);
    build(rt << 1 | 1, mid + 1, r);
    minn[rt] = min(minn[rt << 1], minn[rt << 1 | 1]);
    maxx[rt] = max(maxx[rt << 1], maxx[rt << 1 | 1]);
}
void pushadd(int rt, int l, int r, ll x)
{
    minn[rt] += x;
    maxx[rt] += x;
    tadd[rt] += x;
}
void pushmul(int rt, int l, int r, ll x)
{
    minn[rt] *= x;
    maxx[rt] *= x;
    tmul[rt] *= x;
    tadd[rt] *= x;
    tad[rt] *= x;
}
void pushad(int rt, int l, int r, ll x) //奇怪的操作4
{
    minn[rt] += num[l].val * x;
    maxx[rt] += num[r].val * x;
    tad[rt]+=x; 
}
void pushset(int rt, int l, int r, ll x)
{
    minn[rt] = maxx[rt] = x;
    tset[rt] = x;
    tadd[rt] = 0;
    tmul[rt] = 1;
    tad[rt] = 0;
}
void pushdown(int rt, int l, int r)
{
    int mid = l + r >> 1;
    if (tset[rt] != 0) 
	{
        pushset(rt << 1, l, mid, tset[rt]);
        pushset(rt << 1 | 1, mid + 1, r, tset[rt]);
        tset[rt] = 0;
    }
    if (tmul[rt] != 1) 
	{
        pushmul(rt << 1, l, mid, tmul[rt]);
        pushmul(rt << 1 | 1, mid + 1, r, tmul[rt]);
        tmul[rt] = 1;
    }
    if (tadd[rt] != 0) 
	{
        pushadd(rt << 1, l, mid, tadd[rt]);
        pushadd(rt << 1 | 1, mid + 1, r, tadd[rt]);
        tadd[rt] = 0;
    }
    if (tad[rt] != 0) 
	{
        pushad(rt << 1, l, mid, tad[rt]);
        pushad(rt << 1 | 1, mid + 1, r, tad[rt]);
        tad[rt] = 0;
    }
}
void setmin(int rt, int l, int r) 
{
    if (maxx[rt] < mn) //如果区间最大值都小于L
	{
        pushset(rt, l, r, mn);//全部赋为L
        return ;
    }
    if (l == r)//找不到小于L的数了
        return ;
    pushdown(rt, l, r);
    int mid = l + r >> 1;
    setmin(rt << 1, l, mid);//在左区间一定有小于L的数
    if (minn[rt << 1 | 1] < mn)//如果右区间也有小于L的数
        setmin(rt << 1 | 1, mid + 1, r);
    minn[rt] = min(minn[rt << 1], minn[rt << 1 | 1]);
    maxx[rt] = max(maxx[rt << 1], maxx[rt << 1 | 1]);
}
void setmax(int rt, int l, int r) //参考setmin
{
    if (minn[rt] > mx) 
	{
        pushset(rt, l, r, mx);
        return ;
    }
    if (l == r)
        return ;
    pushdown(rt, l, r);
    int mid = l + r >> 1;
    setmax(rt << 1 | 1, mid + 1, r);
    if (maxx[rt << 1] > mx)
        setmax(rt << 1, l, mid);
    minn[rt] = min(minn[rt << 1], minn[rt << 1 | 1]);
    maxx[rt] = max(maxx[rt << 1], maxx[rt << 1 | 1]);
}
void sett(int rt, int l, int r) //找答案
{
    if (l == r) {
        num[l].ans = minn[rt];
        return ;
    }
    pushdown(rt, l, r);
    int mid = l + r >> 1;
    sett(rt << 1, l, mid);
    sett(rt << 1 | 1, mid + 1, r);
}
int main() 
{
    scanf("%d%d%d", &n, &mn, &mx);
    for (int i = 1; i <= n; i++) 
        scanf("%s%lld", &op[i].s, &op[i].a);
    scanf("%d", &q);
    for (int i = 1; i <= q; i++) 
    {
        scanf("%lld", &num[i].val);
        num[i].id = i;
    }
    sort(num + 1, num + q + 1, cmp1);
    build(1, 1, q);
    for (int i = 1; i <= n; i++) 
    {//因为题目每次都对于整个序列进行操作，所以可以直接打标记，这样可以少些一点
        if (op[i].s == '+') 
            pushadd(1, 1, q, op[i].a);
        else if (op[i].s == '-')
            pushadd(1, 1, q, -op[i].a);
        else if (op[i].s == '*')
            pushmul(1, 1, q, op[i].a);
        else if (op[i].s == '@')
            pushad(1, 1, q, op[i].a);
        setmin(1, 1, q);
        setmax(1, 1, q);
    }
    sett(1, 1, q);
    sort(num + 1, num + q + 1, cmp2);
    for (int i = 1; i <= q; i++)
        cout << num[i].ans << endl;
    return 0;
}
```


---

## 作者：wangyibo201026 (赞：3)

## 事前规定

我们把 $L$ 写成 $l$，$R$ 写成 $r$。

## 问答环节

Q：为什么看了看别人的题解，都是用的线段树呀？

A：因为操作既要区间修改，也要对 $l$ 和 $r$ 取 $\max$ 和 $\min$，普通的模拟无法满足我们的需求，所以我们需要用线段树。

Q：那用线段树来维护什么呢？

A：用线段树来维护最后给出的 $q$ 个值

Q：为什么本题的线段树需要维护 $\min$ 和 $\max$ 呢？

A：因为在最后我们需要对小于 $l$ 的数赋值为 $l$，大于 $r$ 的数赋值为 $r$，又因为我们的线段树不能一边维护这个东西，所以只能在最后根据 $\min$ 值 与 $\max$ 值来~~暴力~~赋值。

Q：为什么别的题解需要写关于赋值的 $tag$，不是直接赋值就可以了吗？

A：想啥呢？我们的赋值需要按照线段树区间修改的方式来修改，否则会超时的！

## 思路

以上几点，都是萌新喜欢问的一些问题，现在来讲一下思路：

我们发现，针对于每一次操作，都是对于整个区间进行的，所以我们可以直接加上 $tag$，不用再写一大堆的 update 函数了。

然后对于每一次操作，我们就看一下有没有小于 $l$ 的数或是大于 $r$ 的数，有的话就直接赋值。

接下来分几个层次来讲：

1. addtag1：打加/减法标记。

2. addtag2：打乘法标记。

3. addtag3：打操作 $4$ 的标记。

4. addtag4：打区间赋值的标记。

### addtag1

我们可以普通的打标记，由于加/减法是最低级的运算，所以不用考虑任何，直接加上加法标记即可。

Code:

```cpp
void addtag1(int node, int val){
  maxi[node] += val;    // maxi 和 mini 数组同样也得加上 val
  mini[node] += val;
  tag1[node] += val;
}
```

### addtag2

我们根据运算知道：第一次如果乘了 $3$，第二次乘了 $5$，那么最后就乘了 $3 \times 5 = 15$，所以乘法标记是乘起来的关系。我们根据运算又知道：第一次如果加了 $3$，第二次乘了 $5$，那么最后就不经让**原数**乘了 $5$ 而且还加了 $3 \times 5 = 15$，所以加法标记也是乘的关系。由于操作 $4$ 的标记也是加法运算，所以跟上面同理。

Code:

```cpp
void addtag2(int node, int val){
  maxi[node] *= val;   //这里仍要乘上
  mini[node] *= val;
  tag2[node] *= val;
  tag1[node] *= val;
  tag3[node] *= val;
}
```

### addtag3

由于这个操作有点怪，所以我们需巧妙的解决它：

我们首先按照 $a$ 的值排个序，由于操作时全局修改，所以不论怎么修改，最小的仍然还是最小的，最大的仍然还是最大的，所以我们在加的时候就不需要考虑变动的数了。

Code:

```cpp
void addtag3(int node, int lt, int rt, int val){
  mini[node] += a[lt].x * val;   //直接加上最小的乘上 val的可以了，最大值同理
  maxi[node] += a[rt].x * val;
  tag3[node] += val;   //这里是加法运算，所以需要加起来
}
```

### addtag4

简单的赋值，只需要把所有标记还原为初始状态就行了。

Code:

```cpp
void addtag4(int node, int val){
  maxi[node] = mini[node] = val;
  tag4[node] = val;
  tag1[node] = 0;
  tag2[node] = 1;
  tag3[node] = 0;
}
```

四个标记全部讲完了，然后 pushdown 就直接按照运算优先级去打标记就可以了。

pushdown：

```cpp
void pushdown(int node, int lt, int rt){   //一定按照优先级去下传标记
  if(tag4[node] != 0){
    addtag4(node << 1, tag4[node]);
    addtag4(node << 1 | 1, tag4[node]);
    tag4[node] = 0;
  }
  if(tag2[node] != 1){
    addtag2(node << 1, tag2[node]);
    addtag2(node << 1 | 1, tag2[node]);
    tag2[node] = 1;
  }
  if(tag1[node] != 0){
    addtag1(node << 1, tag1[node]);
    addtag1(node << 1 | 1, tag1[node]);
    tag1[node] = 0;
  }
  if(tag3[node] != 0){
    int mid = lt + rt >> 1;
    addtag3(node << 1, lt, mid, tag3[node]);
    addtag3(node << 1 | 1, mid + 1, rt, tag3[node]);
    tag3[node] = 0;
  }
}
```

最后简简单单的赋值操作一下就可以了。

赋值操作：

```cpp
void Update_Max(int node, int lt, int rt){
  if(mini[node] > R){
    addtag4(node, R);   //直接打标记
    return ;
  }
  if(maxi[node] <= R){   //如果小于就不需要继续递归了
    return ;
  }
  if(lt == rt){
    return ;
  }
  pushdown(node, lt, rt);
  int mid = lt + rt >> 1;
  Update_Max(node << 1, lt, mid);
  Update_Max(node << 1 | 1, mid + 1, rt);
  pushup(node);
}

void Update_Min(int node, int lt, int rt){   //同理
  if(maxi[node] < L){
    addtag4(node, L);
    return ;
  }
  if(mini[node] >= L){
    return ;
  }
  if(lt == rt){
    return ;
  }
  pushdown(node, lt, rt);
  int mid = lt + rt >> 1;
  Update_Min(node << 1, lt, mid);
  Update_Min(node << 1 | 1, mid + 1, rt);
  pushup(node);
}
```

最后取个答案就可以了：

```cpp
void Have_ans(int node, int lt, int rt){
  if(lt == rt){
    a[lt].ans = mini[node];
    return ;
  }
  pushdown(node, lt, rt);
  int mid = lt + rt >> 1;
  Have_ans(node << 1, lt, mid);
  Have_ans(node << 1 | 1, mid + 1, rt);
  pushup(node);
}
```

最后的代码，就不给了。

---

## 作者：Betrayer_of_love (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P4041)

### 题解：

---

将所有的要进行操作的数从小到大排序，建一颗线段树，对它们进行统一修改。

用线段树维护区间最大值和最小值，且支持区间加减、区间乘、区间加原数的 $x$ 倍和区间覆盖。

一开始我用了 $4$ 个标记维护，然后自闭了，发现题解构建了一个函数，大大节省了代码运行时的复杂度。

对线段树的一个元素 $x$，设计这样一个更新函数 $f(k1,k2,k3)=x \times k1+y \times k2+k3$，其中 $y$ 是最初输入进来的数。

然后区间加：$f(1,0,odd)$，区间乘：$f(mul,0,0)$，区间加原数：$f(1,oddx,0)$，区间覆盖：$f(0,0,x)$。

这样就是本题的具体思路啦！

### CODE:

---


```cpp
#include <bits/stdc++.h>
#define LL long long
#define mid ((l + r) >> 1)
#define ls p << 1
#define rs p << 1 | 1
using namespace std;
LL read(){
    LL k = 0, f = 1; char c = getchar();
    while(c < '0' || c > '9') {
        if(c == '-') f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9')
        k = k * 10 + c - 48, c = getchar();
    return k * f;
}
struct zzz{
    char flag; LL x;
}opt[100010];
struct hhh {
    int l, r; LL max, min, k1, k2, k3;
}tree[100010 << 2];
struct jjj {
    int pos; LL x;
}a[100010];
void up(int p) {
    tree[p].max = tree[rs].max;
    tree[p].min = tree[ls].min;
}
void build(int l, int r, int p) {
    tree[p].l = l, tree[p].r = r, tree[p].k1 = 1;
    if(l == r) {
        tree[p].max = tree[p].min = a[l].x; return ;
    }
    build(l, mid, ls); build(mid+1, r, rs);
    up(p);
}
void pushnow(int p, LL k1, LL k2, LL k3) {
	tree[p].k1 *= k1, tree[p].k2 = tree[p].k2 * k1 + k2, tree[p].k3 = tree[p].k3 * k1 + k3;
	tree[p].max = tree[p].max * k1 + a[tree[p].r].x * k2 + k3;
	tree[p].min = tree[p].min * k1 + a[tree[p].l].x * k2 + k3;
}
void down(int p) {
	hhh &x = tree[p];
	pushnow(ls, x.k1, x.k2, x.k3),
	pushnow(rs, x.k1, x.k2, x.k3);
	x.k1 = 1, x.k2 = x.k3 = 0;
}
void update_low(int p, int k) {
	if(tree[p].l == tree[p].r) {
		pushnow(p, 0, 0, k); return ;
	}
	down(p);
	if(tree[ls].max > k) pushnow(rs, 0, 0, k), update_low(ls, k);
	else update_low(rs, k);
	up(p);
}
void update_up(int p, int k) {
	if(tree[p].l == tree[p].r) {
		pushnow(p, 0, 0, k); return ;
	}
	down(p);
	if(tree[rs].min < k) pushnow(ls, 0, 0, k), update_up(rs, k);
	else update_up(ls, k);
	up(p);
}
LL ans[100010];
void query(int p){
    if(tree[p].l == tree[p].r){
		ans[a[tree[p].l].pos] = tree[p].min;
		return ;
	}
    down(p);
    query(ls), query(rs);
}
bool cmp(jjj x, jjj y) {
    return x.x < y.x;
}
int main() {
    int m = read(), l = read(), r = read();
    for(int i = 1; i <= m; ++i) {
        char c = getchar();
        while(c != '+' && c != '-' && c != '*' && c != '@') c = getchar();
        opt[i].flag = c, opt[i].x = read();
    }
    int n = read();
    for(int i = 1; i <= n; ++i) a[i].pos = i, a[i].x = read();
    sort(a+1, a+n+1, cmp);
    build(1, n, 1);
    for(int i = 1; i <= m; ++i) {
        if(opt[i].flag == '+')
            pushnow(1, 1, 0, opt[i].x);
        else if(opt[i].flag == '-')
            pushnow(1, 1, 0, -opt[i].x);
        else if(opt[i].flag == '*')
            pushnow(1, opt[i].x, 0, 0);
        else if(opt[i].flag == '@')
            pushnow(1, 1, opt[i].x, 0);
        if(tree[1].max > r) update_low(1, r);
        if(tree[1].min < l) update_up(1, l);
    }
    query(1);
    for(int i = 1; i <= n; ++i) cout << ans[i] << endl;
    return 0;
}
```


**完结撒花，谢谢！！！**

---

## 作者：free_fall (赞：1)

一共有 $n$ 次操作，要求输出 $q$ 个数经过这些操作后的值分别是多少。

容易想到将这 $q$ 个数作为叶子结点建立一颗线段树，这样这些操作就变成了全局区间修改的操作。

如果对于这四种操作以及区间取最大最小值都记录标记的话太繁琐容易出错，所以我们利用三种标记维护这 6 种操作：mul，tag，add，其中 tag 记录的是操作 4 的标记，用函数 push_tag 来下传这三种标记，那么前四种操作就变成了：

1. ```push_tag(1,1,1,a[i])```。

2. ```push_tag(1,1,1,-a[i])```。

3. ```push_tag(1,a[i],0,0)```。

4. ```push_tag(1,1,a[i],0)```。

对于区间取最大最小值的操作也可以利用这个函数下传标记来进行修改，首先我们对这 $q$ 个数进行排序，容易发现不管怎样操作，这些数之间的大小关系是不会变化的（准确地说一个数如果本来比另一个数要小的话，不管怎样操作都不会变得比它大）。

那么求区间最大值的操作就变成了在树上二分查找从左到右最后一个小于它的数，将这个数和它左边所有的数都修改为 $ll$，标记这样下传：```push_tag(p,0,0,ll)```。

区间取最小同理。

代码如下，时间复杂度为 $O(n \log^2 n)$：
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5,inf=0x3f3f3f3f3f3f3f3f;
int n,ll,rr,q,a[N],op[N],ans[N];
struct kk{
	int val,id;
	bool operator<(const kk &x)const{
		return val<x.val;
	}
}b[N];
struct seg_tree{
	#define ls p<<1
	#define rs p<<1|1
	int t[N<<2],mul[N<<2],tag[N<<2],add[N<<2];
	void push_tag(int p,int a,int b,int c){
		mul[p]*=a;
		tag[p]=tag[p]*a+b;
		add[p]=add[p]*a+c;
		return;
	}
	void push_down(int p){
		push_tag(ls,mul[p],tag[p],add[p]);
		push_tag(rs,mul[p],tag[p],add[p]);
		tag[p]=add[p]=0;
		mul[p]=1;
		return;
	}
	void build(int p,int l,int r){
		add[p]=tag[p]=0;
		mul[p]=1;
		if(l==r){
			t[p]=b[l].val;
			return;
		}
		int mid=l+r>>1;
		build(ls,l,mid);
		build(rs,mid+1,r);
		return;
	}
	int query(int p,int l,int r,int x){
		if(l==r)return t[p]*mul[p]+tag[p]*t[p]+add[p];
		push_down(p);
		int mid=l+r>>1;
		if(x<=mid)return query(ls,l,mid,x);
		return query(rs,mid+1,r,x);
	}
	void change_max(int p,int l,int r){
		if(l==r){
			if(query(1,1,q,l)<ll)push_tag(p,0,0,ll);
			return;
		}
		push_down(p);
		int mid=l+r>>1,tmp=query(1,1,q,mid);
		if(tmp>=ll){
			change_max(ls,l,mid);
			return;
		}
		push_tag(ls,0,0,ll);
		change_max(rs,mid+1,r);
		return;
	}
	void change_min(int p,int l,int r){
		if(l==r){
			if(query(1,1,q,l)>rr)push_tag(p,0,0,rr);
			return;
		}
		push_down(p);
		int mid=l+r>>1,tmp=query(1,1,q,mid);
		if(tmp<=rr){
			change_min(rs,mid+1,r);
			return;
		}
		push_tag(rs,0,0,rr);
		change_min(ls,l,mid);
		return;
	}
	#undef ls
	#undef rs
}seg;
signed main(){
	scanf("%lld%lld%lld",&n,&ll,&rr);
	for(int i=1;i<=n;i++){
		char s[3];
		scanf("%s%lld",s,&a[i]);
		if(s[0]=='+')op[i]=1;
		if(s[0]=='-')op[i]=2;
		if(s[0]=='*')op[i]=3;
		if(s[0]=='@')op[i]=4;
	}
	scanf("%lld",&q);
	for(int i=1;i<=q;i++){
		scanf("%lld",&b[i].val);
		b[i].id=i;
	}
	sort(b+1,b+q+1);
	seg.build(1,1,q);
	for(int i=1;i<=n;i++){
		if(op[i]==1)seg.push_tag(1,1,0,a[i]);
		if(op[i]==2)seg.push_tag(1,1,0,-a[i]);
		if(op[i]==3)seg.push_tag(1,a[i],0,0);
		if(op[i]==4)seg.push_tag(1,1,a[i],0);
		seg.change_max(1,1,q);
		seg.change_min(1,1,q);
	}
	for(int i=1;i<=q;i++){
		ans[b[i].id]=seg.query(1,1,q,i);
	}
	for(int i=1;i<=q;i++){
		printf("%lld\n",ans[i]);
	}
	return 0;
}
```

---

## 作者：鱼跃于渊 (赞：0)

## 做法：    
前 $3$ 个操作很基础，不做讲解，不过注意优先级。  
考虑存储范围怎么搞，其实可以维护区间最小最大值，然后再做区间赋值就行了。  
至于操作 $4$，它与下标相关，看起来不太好搞。但可以注意到对于一个有序序列来说，这些操作都不会改变其有序性，所以直接把原数列排序之后搞。  
怎么搞呢，设 $a$ 为排序后的数列，$x$ 为要乘的数，$mn$ 为区间最小值，$mx$ 为区间最大值，则对于一个区间 $[l,r]$ 来说，由于其有有序性，故 $mn=mn+a_l \times x$，$mx=mx+a_r \times x$。  
**tips**：[警示后人](https://www.luogu.com.cn/discuss/698319)。
## 代码：  
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define ls(x) ((x)<<1)
#define rs(x) ((x)<<1|1)
const int N=1e5+5;
struct todo{
	char op;int x;
}td[N];
struct node{
	int x,i,ans;
}a[N];
bool cmp1(const node &x,const node &y){
	return x.x<y.x;
}
bool cmp2(const node &x,const node &y){
	return x.i<y.i;
}
int q,n,L,R;
struct tree{
	int mn,mx,atag,mtag,btag,ftag;
}t[N*4];
void push_up(int i){
	t[i].mn=min(t[ls(i)].mn,t[rs(i)].mn);
	t[i].mx=max(t[ls(i)].mx,t[rs(i)].mx);
}
void amodify(int i,int k){
	t[i].mn+=k;
	t[i].mx+=k;
	t[i].atag+=k;
}
void mmodify(int i,int k){
	t[i].mn*=k;
	t[i].mx*=k;
	t[i].atag*=k;
	t[i].mtag*=k;
}
void fmodify(int i,int k){
	t[i].mn=t[i].mx=k;
	t[i].ftag=k;
	t[i].atag=t[i].btag=0;t[i].mtag=1;
}
void bmodify(int i,int l,int r,int k){
	t[i].mn+=a[l].x*k;
	t[i].mx+=a[r].x*k;
	t[i].btag+=k;
}
void push_down(int i,int l,int r){
	int mid=(l+r)>>1;
	if(t[i].ftag){
		fmodify(ls(i),t[i].ftag);
		fmodify(rs(i),t[i].ftag);
		t[i].ftag=0;
	}
	if(t[i].mtag!=1){
		mmodify(ls(i),t[i].mtag);
		mmodify(rs(i),t[i].mtag);
		t[i].mtag=1;
	}
	if(t[i].atag){
		amodify(ls(i),t[i].atag);
		amodify(rs(i),t[i].atag);
		t[i].atag=0;
	}
	if(t[i].btag){
		bmodify(ls(i),l,mid,t[i].btag);
		bmodify(rs(i),mid+1,r,t[i].btag);
		t[i].btag=0;
	}
}
void build(int i,int l,int r){
	if(l==r){
		t[i]={a[l].x,a[l].x,0,1,0,0};
		return;
	}
	int mid=(l+r)>>1;
	build(ls(i),l,mid);
	build(rs(i),mid+1,r);
	push_up(i);
	t[i].atag=t[i].ftag=t[i].btag=0;
	t[i].mtag=1;
}
void lupdate(int l,int r,int i){
	if(t[i].mx<L){
		fmodify(i,L);
		return;
	}
	push_down(i,l,r);
	int mid=(l+r)>>1;
	if(t[ls(i)].mn<L) lupdate(l,mid,ls(i));
	if(t[rs(i)].mn<L) lupdate(mid+1,r,rs(i));
	push_up(i);
}
void rupdate(int l,int r,int i){
	if(t[i].mn>R){
		fmodify(i,R);
		return;
	}
	push_down(i,l,r);
	int mid=(l+r)>>1;
	if(t[ls(i)].mx>R) rupdate(l,mid,ls(i));
	if(t[rs(i)].mx>R) rupdate(mid+1,r,rs(i));
	push_up(i);
}
int query(int nx,int l,int r,int i){
	if(l==r) return t[i].mn;
	push_down(i,l,r);
	int mid=(l+r)>>1;
	if(nx<=mid) return query(nx,l,mid,ls(i));
	else return query(nx,mid+1,r,rs(i));
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>q>>L>>R;
	for(int i=1;i<=q;i++)
		cin>>td[i].op>>td[i].x;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].x;a[i].i=i;
	}
	sort(a+1,a+n+1,cmp1);
	build(1,1,n);
	for(int i=1,x;i<=q;i++){
		x=td[i].x;
		switch(td[i].op){
			case '+':amodify(1,x);
				break;
			case '-':amodify(1,-x);
				break;
			case '*':mmodify(1,x);
				break;
			case '@':bmodify(1,1,1,x);
				break;
		}
		lupdate(1,n,1);
		rupdate(1,n,1);
	}
	for(int i=1;i<=n;i++)
		a[i].ans=query(i,1,n,1);
	sort(a+1,a+n+1,cmp2);
	for(int i=1;i<=n;i++)
		cout<<a[i].ans<<'\n';
	return 0;
}
```

---

## 作者：djh0314 (赞：0)

[**洛谷**](https://www.luogu.com.cn/problem/P4041)。

## 题意

有 $Q$ 个询问，$n$ 个操作，一共有 4 种：
1. $+a$：结果加上 $a$；
2. $-a$：结果减去 $a$；
3. $\times a$；结果乘上 $a$；
4. $@a$：结果加上 $a\times X$（$X$ 是一开始输入的数）。
将每个询问放在 $n$ 个操作中过一遍，同时每次处理完后，倘若小于 $L$，赋值为 $L$；倘若大于 $R$，赋值为 $R$。


### 暴力
按照题意模拟即可。

## 分析
我们可以发现，我们所有数的经历的过程是一样的，我们可以用线段树来维护我们的 6 中操作：
1. 区间加；
2. 区间减（同 1）；
3. 区间乘；
4. 区间加的变种；
5. 区间取至最大值；
6. 区间取至最小值。

这么算来，我们似乎是要维护 5 种 tag，10 种值。      
想想都让人头皮发麻，怎么都应该是黑题才对。

但是实际上，我们的其中操作其实并不会改变期间相邻数的大小关系，因此，我们的 5、6 操作就变成了区间覆盖与一个二分（找到最后一个小于 $L$ 或 第一个大于 $R$）啦。           

总结一下，我们需要维护区间乘、区间加、区间加变形、区间覆盖、单点查询。         

看起来还是非常复杂，但是我们用 $c_p\times tag1_p+tag2_p$ 的形式，就可以将区间乘，区间加，区间覆盖融为一体。            
最后的区间加变种，地位与区间加等同，与区间加的维护大致相同。

~~~cpp
struct SEG {
#define ls p<<1
#define rs p<<1|1
	int c[N<<2],tag[N<<2],tag2[N<<2],tag3[N<<2];

	inline void cl(int p,int x,int y,int L,int R) {
		tag3[p]*=x;
		tag2[p]=tag2[p]*x+y;
		tag[p]=tag[p]*x;
	}

	inline void cl(int p,int x) {
		tag3[p]+=x;
	}

	inline void pushdown(int p,int L,int R) {
		int mid=L+R>>1;
		cl(ls,tag[p],tag2[p],L,mid),cl(rs,tag[p],tag2[p],mid+1,R);
		cl(ls,tag3[p]),cl(rs,tag3[p]);
		tag[p]=1,tag2[p]=tag3[p]=0;
	}

	inline void build(int p,int L,int R) {
		tag[p]=1,tag2[p]=tag3[p]=0;
		if(L==R) {
			c[p]=qu[L].x;
			return ;
		}
		int mid=L+R>>1;
		build(ls,L,mid),build(rs,mid+1,R);
	}

	inline void change(int p,int L,int R,int l,int r,int x,int y) {
		if(l>r) return ;
		if(l<=L&&R<=r) {
			cl(p,x,y,L,R);
			return ;
		}
		int mid=L+R>>1;
		pushdown(p,L,R);
		if(l<=mid) change(ls,L,mid,l,r,x,y);
		if(mid<r)  change(rs,mid+1,R,l,r,x,y);
	}

	inline void change(int p,int L,int R,int l,int r,int x) {
		if(l>r) return ;
		if(l<=L&&R<=r) {
			cl(p,x);
			return ;
		}
		int mid=L+R>>1;
		pushdown(p,L,R);
		if(l<=mid) change(ls,L,mid,l,r,x);
		if(mid<r)  change(rs,mid+1,R,l,r,x);
	}

	inline int query(int p,int L,int R,int x) {
		if(L==R) return c[p]*tag[p]+tag2[p]+tag3[p]*c[p];
		pushdown(p,L,R);
		int mid=L+R>>1;
		if(x<=mid) return query(ls,L,mid,x);
		if(mid<x)  return query(rs,mid+1,R,x);
	}

#undef ls
#undef rs
} tree;

inline void solvel() {
	int l=1,r=m,res=0;
	while(l<=r) {
		int mid=l+r>>1;
		int x=tree.query(1,1,m,mid);
		if(x<L) {
			res=mid;
			l=mid+1;
		} else r=mid-1;
	}
	tree.change(1,1,m,1,res,0,L);
}

inline void solver() {
	int l=1,r=m,res=m+1;
	while(l<=r) {
		int mid=l+r>>1;
		int x=tree.query(1,1,m,mid);
		if(x>R) {
			res=mid;
			r=mid-1;
		} else l=mid+1;
	}
	tree.change(1,1,m,res,m,0,R);
}
~~~

### 总结一下，这题其实利用了线段树的区间修改的时间复杂度，操作的不改变相对关系。

---


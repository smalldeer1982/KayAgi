# [AHOI2014/JSOI2014] 支线剧情

## 题目背景

宅男 JYY 非常喜欢玩 RPG 游戏，比如仙剑，轩辕剑等等。不过 JYY 喜欢的并不是战斗场景，而是类似电视剧一般的充满恩怨情仇的剧情。这些游戏往往都有很多的支线剧情，现在 JYY 想花费最少的时间看完所有的支线剧情。

## 题目描述

JYY 现在所玩的 RPG 游戏中，一共有 $N$ 个剧情点，由 $1$ 到 $N$ 编号，第 $i$ 个剧情点可以根据 JYY 的不同的选择，而经过不同的支线剧情，前往 $K_i$ 种不同的新的剧情点。当然如果为 $0$，则说明 $i$ 号剧情点是游戏的一个结局了。

JYY 观看一个支线剧情需要一定的时间。JYY 一开始处在 $1$ 号剧情点，也就是游戏的开始。显然任何一个剧情点都是从 $1$ 号剧情点可达的。此外，随着游戏的进行，剧情是不可逆的。所以游戏保证从任意剧情点出发，都不能再回到这个剧情点。由于 JYY 过度使用修改器，导致游戏的“存档”和“读档”功能损坏了，

所以 JYY 要想回到之前的剧情点，唯一的方法就是退出当前游戏，并开始新的游戏，也就是回到 $1$ 号剧情点。JYY 可以在任何时刻退出游戏并重新开始。不断开始新的游戏重复观看已经看过的剧情是很痛苦，JYY 希望花费最少的时间，看完所有不同的支线剧情。

## 说明/提示

### 样例解释

JYY 需要重新开始 $3$ 次游戏，加上一开始的一次游戏，$4$ 次游戏的进程是：

- $1 \to 2 \to 4$；
- $1 \to 2 \to 5$；
- $1 \to 3 \to 5$；
- $1 \to 3 \to 6$。

对于 $100\%$ 的数据满足 $N \le 300$，$0 \le K_i \le 50$，$1 \le T_{i,j} \le 300$，$\sum K_i \le 5000$。

## 样例 #1

### 输入

```
6
2 2 1 3 2
2 4 3 5 4
2 5 5 6 6
0
0
0```

### 输出

```
24```

# 题解

## 作者：Orion545 (赞：24)

# 广告

[蒟蒻的blog](http://www.cnblogs.com/dedicatus545/p/8729360.html)

# 正文

转化模型：给一张有向无环图，每次你可以选择一条路径走，花费的时间为路径上边权的总和，问要使所有边都被走至少一遍（可以重复），至少需要花费多久

走至少一遍，等价于覆盖这条边

也就是说，我们要找这个图的一个可重复的路径覆盖

路径覆盖让我们想到什么算法了呢？

网络流啊！

我们考虑建立网络流图模型。

这道题里面有个关键：走过一条边，走几次就要花几次的费用，这想到什么？

费用流嘛！

我们定义走一次路径会给这条路径上的所有边增加1的流量，再给所有边赋一个费用等于边权

这样，我们只要设每条边的流量有一个1的下限，上限为无限大，就能做了

还要把所有的剧情结束点（没有出边的）连到一个超级汇点，源点就是1号点

跑一个最小费用可行流即可

这里附上最小费用可行流的教程

# 最小费用可行流

考虑一张网络流图，每条边定义为(u,v,w,l,r)，代表从u到v的一条有向边，费用为w，容量为\[l,r\]闭区间，源点s汇点t已知，且保证源点没有入边、汇点没有出边

同时定义常规费用流图的边为(u,v,w,cap)

现在我们需要求这张图的最小费用可行流（就是满足所有边的流量上下限制，同时费用最小）

按照如下方式建立附加边和附加点：

1.建立附加源点SS，和附加汇点TT

2.对于原图中每一个点（包括源汇）u,令d\[u\]代表u点的所有入边的流量下界减去出边的流量下界

2.1.如果d\[u\]是负数，那么从u连一条边(u,TT,0,-d\[u\])到TT

2.2.如果d\[u\]是正数，那么从SS连一条边(SS,u,0,d\[u\])到u

3.对于原图中每一条边(u,v,w,l,r)，连边(u,v,w,r-l)

4.连边(t,s,0,inf)（注意这里是原图的源汇点！不是附加的源汇点！！）

这样以后，从SS到TT跑新图的最小费用最大流，再加上原图中每条边的下界流量乘以费用（必须跑的部分），就是最小费用可行流的费用了

# 为什么？

我们考虑一个点，流入边流量下界比流出边流量下界大1，即d\[u\]==1

此时，我们要有一个“补流”的思想

此时出小于入，那么出边的流量下界就会比入边的小1

因为下界一定是要满的，而我们如果希望消除下界影响，新图中的旧图的边，流量上届一定是(r-l)

那我们势必要找一个方法，令这个比较小的流量流出下界，能与比较大的流量流入下界“平起平坐”

这个时候，假如我们从超级源补1的流量过来，那是不是相当于“帮了”输出边一把，平衡了一下“实力强大”的输入边呢？

这样我们就完成了补流过程

### 上面那段是感性理解，如果想看证明的话，可以看看神犇的博客

[神犇的博客](https://blog.csdn.net/clove_unique/article/details/54884437)

# Code:
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
int inf=1e9+7;
using namespace std;
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
int n,ans,first[510],cnt=-1;
int dis[510],vis[510],q[20010],head,tail;
struct edge{
    int to,next,w,cap;
}a[100010];
inline void add(int u,int v,int w,int cap){
    a[++cnt]=(edge){v,first[u],w,cap};first[u]=cnt;
    a[++cnt]=(edge){u,first[v],-w,0};first[v]=cnt;
}
bool spfa(int s,int t){
    int i,u,v,w;head=0,tail=1;
    memset(dis,-1,sizeof(dis));memset(vis,0,sizeof(vis));
    q[0]=t;dis[t]=0;vis[t]=1;
    while(head<tail){
        u=q[head++];vis[u]=0;
        for(i=first[u];~i;i=a[i].next){
            if(!a[i^1].cap) continue;
            v=a[i].to;w=a[i].w;
            if(dis[v]==-1||dis[v]>dis[u]-w){
                dis[v]=dis[u]-w;
                if(!vis[v]){
                    vis[v]=1,q[tail++]=v;
                }
            }
        }
    }
    return ~dis[s];
}
int dfs(int u,int t,int limit){
    if(u==t){vis[t]=1;return limit;}
    int i,v,f,flow=0;vis[u]=1;
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;
        if((dis[v]==dis[u]-a[i].w)&&(a[i].cap)&&(!vis[v])){
            f=dfs(v,t,min(limit,a[i].cap));
            if(f){
                flow+=f;limit-=f;
                ans+=f*a[i].w;
                a[i].cap-=f;a[i^1].cap+=f;
                if(!limit) return flow;
            }
        }
    }
    return flow;
}
int costflow(int s,int t){//我写的是从某博客上学的改进版zkw费用流
    int re=0;
    while(spfa(s,t)){
        vis[t]=1;
        while(vis[t]){
            memset(vis,0,sizeof(vis));
            re+=dfs(s,t,inf);
        }
    }
    return re;
}
int d[510];
int main(){
    memset(first,-1,sizeof(first));
    n=read();int i,t1,t2,t3,j;
    for(i=1;i<=n;i++){
        t1=read();
        for(j=1;j<=t1;j++){
            t2=read();t3=read();
            d[i]--;d[t2]++;ans+=t3;//流量下界其实都是一
            add(i,t2,t3,inf);
        }
    }
    for(i=2;i<=n;i++){
        add(i,n+1,0,inf);
    }
    for(i=1;i<=n;i++){//补流过程
        if(d[i]>0) add(0,i,0,d[i]);
        if(d[i]<0) add(i,n+2,0,-d[i]);
    }
    add(n+1,1,0,inf);
    costflow(0,n+2);
    cout<<ans<<endl;
}
```

---

## 作者：Boxxxxxx (赞：13)

[博客链接](https://blog.csdn.net/qq_43804974/article/details/107554692)

这题的建图方式可以类比[洛谷P1251](https://www.luogu.com.cn/problem/P1251)

我是由那个题才想到这么建的，由于每条边至少经过一次，我们又不清楚需要跑多少次，把边看成点，点与汇点相连，可是我们又不知道最大流应该是多少，直接这么连会发生错误。利用那道题的思想，每条边最少需要一次，那么就每条边看做两个点，点1和点2，点1有1的流量流向汇点，点2接受源点的1的流量，这是一个补流的过程。利用补流的过程和把边拆成两个点，我们就可以跑出来最大流是边数的最小费用。
![](https://cdn.luogu.com.cn/upload/image_hosting/dise99ji.png)
这么做吧，比其他的做法跑的慢很多，但是还可以ac的，只是最慢一个点还需要832ms(不开O2)

```cpp

int head[max_], xiann = 2;
struct kk {
	int to, next, flow, val;
	kk() {}
	kk(int to, int next, int flow, int val) :to(to), next(next), flow(flow), val(val) {}
}xian[max_ << 1];
il void add(int a, int b, int c, int d) {
	/*if (c) {
		cout << a << " " << b << " " << c << endl;
	}*/
	xian[xiann] = kk(b, head[a], c, d);
	head[a] = xiann;
	xiann++;
}
int cur[max_], dis[max_], N = 0, que[max_], L, R;
int S, T;
bool vis[max_];
bool spfa() {
	re int i, now, to;
	for (i = 0; i <= N; i++) {
		cur[i] = head[i]; dis[i] = inf; vis[i] = 0;
	}
	L = 1, R = 0;
	que[++R] = S; vis[S] = 1; dis[S] = 0;
	while (L <= R) {
		now = que[L]; L++; vis[now] = 0;
		for (i = head[now]; i; i = xian[i].next) {
			to = xian[i].to;
			if (xian[i].flow  && dis[to] > dis[now] + xian[i].val) {
				dis[to] = dis[now] + xian[i].val;
				if (!vis[to]) {
					vis[to] = 1;
					que[++R] = to;
				}
			}
		}
	}
	return dis[T] != inf;
}
int mincost, maxflow;
int dfs(int now, int flow) {
	if (!flow || now == T)return flow;
	re int  to, tot = 0, f;
	vis[now] = 1;
	for (int &i = cur[now]; i; i = xian[i].next) {
		to = xian[i].to;
		if (!vis[to] && xian[i].flow && dis[to] == dis[now] + xian[i].val && (f = dfs(to, min(flow - tot, xian[i].flow)))) {
			tot += f;
			xian[i].flow -= f; xian[i ^ 1].flow += f;
			mincost += f * xian[i].val;
			if (tot == flow)break;
		}
	}
	vis[now] = 0;
	return tot;
}
void dinic() {
	while (spfa()) {
		maxflow += dfs(S, inf);
	}
}
il void addEdge(int a, int b, int c, int d) {
	//cout << a << " "  << b <<" "<< c << endl;
	add(a, b, c, d);
	add(b, a, 0, -d);
}
vector<pair<int, int> > ask[700];
map<int, pair<int, int> >mp;
il void ini() {
	re int n = read(),i,j,num,cost,to,idn,xianid = 0,nowxianid = 0,a,b;
	pair<int, int> temp;
	idn = n;
	for(i = 1;i <= n;i++){
		num = read();
		for (j = 1; j <= num; j++) {
			to = read(); cost = read();
			ask[i].push_back(make_pair(to, cost));
			++xianid;
			a = ++idn; b = ++idn;
			mp[xianid] = make_pair(a, b);
		}
	}
	S = 0; N = T = ++idn;
	addEdge(S, 1, inf, 0);
	for (i = 1; i <= n; i++) {
		for (auto pa : ask[i]) {
			nowxianid++; 
			temp = mp[nowxianid];
			addEdge(temp.first, temp.second, inf, 0);
			addEdge(temp.first, T, 1, 0);
			addEdge(S,temp.second, 1, 0);
			addEdge(temp.second, pa.first, inf, 0);
			addEdge(i, temp.first, inf, pa.second);
		}
	}
	dinic();
	cout << mincost;
}
signed main() {
	ini();
	return 0;
}
```


---

## 作者：GoPoux4 (赞：9)

一道最小费用可行流。

---

#### 建模

观看一个支线剧情花费一定时间，并且每个支线剧情至少观看一次，将这个条件抽象成网络上的一条边，容量上界为 $\infty$，下界为 $1$，费用为 $t_i$ 。

由于在每个点都可以退出游戏，于是将每个点向一个虚拟的汇点 $t$ 连边，容量上界为 $\infty$，下界为 $0$，费用为 $0$。

求解这个源点为 $s=1$，汇点为 $t$ 的网络的最小费用可行流即可。

#### 最小费用可行流

先了解无源无汇上下界可行流：

> 给定无源汇流量网络 $G$。询问是否存在一种标定每条边流量的方式，使得每条边流量满足上下界同时每一个点流量平衡。

由于这是一个有源有汇网络，其中源点 $s$ 与汇点 $t$ 不满足流量守恒性质，所以连边 $t \to s$ 将其转化为无源无汇网络。

先让每一条边都满足它的容量下界，可以发现此时有些点并不满足流量守恒性质，于是我们需要补流。

对于每一个点 $u$，记录它流入流量与流出流量的差：

$$
d_u=\sum_{v \in V}f(v,u)-\sum_{v \in V}f(u,v)
$$

建立超级源点 $S$，与超级汇点 $T$ 用于补流。然后对于 $d_u$ 分类讨论：

+ $d_u=0$，不需要补流。

+ $d_u>0$，流入流量多了，连边 $u \to T$，容量为 $d_u$，将多余流量送入超级汇点 $T$。

+ $d_u<0$，流入流量不够，连边 $S \to u$，容量为 $|d_u|$，让超级源点 $S$ 对其补流。

在新建的网络上跑最小费用最大流即可。

由于最开始强制给了每条边 $1$ 的流量，最小费用还要加上这个操作的费用才是答案。

---

$\text{Code}:$

类 $\text{Dinic}$ 算法求最小费用最大流，也叫 $\text{zkw}$ ~~重口味~~。

```cpp
#pragma GCC target("avx")
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <queue>
#define maxn 3005
#define maxm 300005
#define R register
#define INF 1000000007
using namespace std;
typedef long long lxl;

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

struct edge
{
	int v,cp,w,next;
}e[maxm<<1];

int head[maxn],k;

inline void add(int u,int v,int cp,int w)
{
	e[k]=(edge){v,cp,w,head[u]};
	head[u]=k++;
	e[k]=(edge){u,0,-w,head[v]};
	head[v]=k++;
}

int n,mincost,maxflow;
int dis[maxn],nxt[maxn];
bool vis[maxn];

inline bool SPFA(int s,int t)
{
	queue<int> q;
	for(int i=1;i<=n+3;++i) dis[i]=-1,vis[i]=false;
	dis[s]=0;
	vis[s]=true;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		vis[u]=false;
		nxt[u]=head[u];
		for(int i=head[u];~i;i=e[i].next)
		{
			int v=e[i].v;
			if(!e[i].cp) continue;
			if(!~dis[v]||dis[v]>dis[u]+e[i].w)
			{
				dis[v]=dis[u]+e[i].w;
				if(!vis[v]) q.push(v),vis[v]=true;
			}
		}
	}
	return ~dis[t];
}

inline int Dinic(int u,int t,int flow)
{
	if(u==t||!flow) return flow;
	vis[u]=true;
	int rest=flow,i;
	for(i=nxt[u];~i;i=e[i].next)
	{
		int v=e[i].v;
		if(!e[i].cp||dis[v]!=dis[u]+e[i].w||vis[v]) continue;
		int k=Dinic(v,t,min(rest,e[i].cp));
		if(!k) continue;
		mincost+=k*e[i].w;
		e[i].cp-=k;
		e[i^1].cp+=k;
		rest-=k;
		if(!rest) continue;
	}
	vis[u]=false;
	nxt[u]=i;
	return flow-rest;
}

int d[maxn];

int main()
{
	// freopen("P4043.in","r",stdin);
	n=read();
	memset(head,-1,sizeof(head));
	int s=1,t=n+1,S=n+2,T=n+3;
	for(int i=1;i<=n;++i)
	{
		int ki=read();
		for(int j=1;j<=ki;++j)
		{
			int v=read(),w=read();
			++d[v];--d[i];
			mincost+=w;
			add(i,v,INF,w);
		}
	}
	for(int i=2;i<=n;++i)
		add(i,t,INF,0);
	add(t,s,INF,0);
	for(int i=1;i<=n+1;++i)
	{
		if(d[i]>0) add(S,i,d[i],0);
		if(d[i]<0) add(i,T,-d[i],0);
	}
	// for(int i=0;i<k;i+=2)
	// 	printf("%d %d %d\n",e[i^1].v,e[i].v,e[i].cp);
	while(SPFA(S,T))
		maxflow+=Dinic(S,T,1<<30);
	printf("%d\n",mincost);
	return 0;
}

```


---

## 作者：FutaRimeWoawaSete (赞：7)

有源汇最小可行费用流。              

~~样例很强谢谢~~          

我们考虑每条边至少被走过一次，那么是不是直接钦定每条边的流量上下界为 $[1,Inf]$ 然后跑无源汇最小费用流就好了啊？当你开开心心码完就会发现基本的小样例都过不了。               

需要注意点 $1$ 的流量不限，所以我们考虑再建个虚点 $t$ 让除 $1$ 以外的所有点的流量都流过去，这样跑一个有源汇最小费用流就好了。         

注意一些细节：              

1. 数组开到 $32$ 倍左右，不然会玄学 RE，不过我个人算出来也就 $8$ 倍左右，不知道哪里算漏了还是咋的；            

2. 记得在跑残余网络时清空最后约束 $s,t$ 流量的边。             

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 1e3 + 5 , M = 1.5e4 + 5;
const long long Inf = 1e12;
int n,m,head[Len],cnt = 1,flag[Len],pre[Len],s,t,S,T;
long long val[Len],maxflow,mincost,dis[Len],aug[Len],sum,SUM;
struct node
{
	int next,to;long long w,ww,www;
	inline void clear(){next = to = w = ww = www = 0;}
}edge[Len << 5];
void add(int from,int to,long long w,long long www)
{
	edge[++ cnt].to = to;
	edge[cnt].next = head[from];
	edge[cnt].w = w;
	edge[cnt].www = www;
	head[from] = cnt;
}
bool SPFA()
{
	queue<int> q;
	for(int i = 1 ; i <= n + 3 ; i ++) dis[i] = Inf , flag[i] = pre[i] = aug[i] = 0;
	aug[S] = Inf , dis[S] = 0 , flag[S] |= 1 , q.push(S);
	while(!q.empty())
	{
		int p = q.front();q.pop();
		flag[p] = 0;
		for(int e = head[p] ; e ; e = edge[e].next)
		{
			int to = edge[e].to;
			if(dis[to] > dis[p] + edge[e].www && edge[e].w)
			{
				dis[to] = dis[p] + edge[e].www;
				aug[to] = min(aug[p] , edge[e].w);
				pre[to] = e;
				if(!flag[to]) flag[to] |= 1 , q.push(to);
			}
		}
	}
	if(dis[T] == Inf) return 0;
	return 1;
}
void E_K()
{
	while(SPFA())
	{
		int x = T , E;
		maxflow += aug[T];
		mincost += aug[T] * dis[T];
		while(x != S)
		{
			E = pre[x];
			edge[E].w -= aug[T] , edge[E ^ 1].w += aug[T];
			x = edge[E ^ 1].to;
		}
	}
}
int BB,TT;
int main()
{
	scanf("%d",&n);
	s = 1 , t = n + 1 , S = t + 1 , T = S + 1;
	for(int i = 1 ; i <= n ; i ++)
	{
		int k;scanf("%d",&k);
		while(k --)
		{
			scanf("%d %d",&BB,&TT);
			//i -> BB [1 , Inf] TT
			edge[cnt + 1].ww = 1;
			val[BB] += 1 , val[i] -= 1 , SUM += TT;
			add(i , BB , Inf - 1 , TT) , add(BB , i , 0 , -TT);
		}
	}
	for(int i = 2 ; i <= n ; i ++) add(i , t , Inf , 0) , add(t , i , 0 , 0);
	for(int i = 1 ; i <= n ; i ++)
	{
		if(val[i] > 0) add(S , i , val[i] , 0) , add(i , S , 0 , 0) , sum += val[i];
		if(val[i] < 0) add(i , T , -val[i] , 0) , add(T , i , 0 , 0);
	}
	add(t , s , Inf , 0) , add(s , t , 0 , 0);
	E_K();
	edge[cnt ^ 1].clear() , edge[cnt].clear();
	S = s , T = t;
	E_K();
	printf("%lld\n",mincost + SUM); 
	return 0;
}
```

---

## 作者：251Sec (赞：4)

简单题。题面写啥你就干啥。

看到题面想到什么？网络流。要求原图中每条边至少经过一次？那么每条边的流量上下界为 $[1,+\infty)$。经过每一次需要花费 $t$ 的时间？那么边的费用就是 $t$。每个点可以回到点 $1$？那么每个点向点 $1$ 连一条费用为 $0$，上下界为 $[0, +\infty)$ 的边。

于是求无源汇有上下界最小费用可行流即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define S (n + 1)
#define T (n + 2)
const ll inf = 0x3f3f3f3f3f3f3f3f;
int n;
struct Edge {
	int to, next;
	ll w, c;
} e[500005];
int head[505], len;
void Insert(int u, int v, ll w, ll c) {
	e[++len].to = v;
	e[len].next = head[u];
	e[len].w = w;
	e[len].c = c;
	head[u] = len;
}
void InsertF(int u, int v, ll w, ll c) {
	if (!len) len = 1;
	Insert(u, v, w, c);
	Insert(v, u, 0, -c);
}
ll maxf, minc;
ll dis[505], fl[505];
int pat[505];
bool vis[505];
bool SPFA() {
	memset(vis, 0, sizeof(vis));
	memset(dis, 0x3f, sizeof(dis));
	memset(fl, 0x3f, sizeof(fl));
	queue<int> q;
	q.push(S);
	vis[S] = true;
	dis[S] = 0;
	while (!q.empty()) {
		int u = q.front(); q.pop(); vis[u] = false;
		for (int i = head[u]; i; i = e[i].next) {
			if (!e[i].w) continue;
			int v = e[i].to;
			if (dis[v] > dis[u] + e[i].c) {
				dis[v] = dis[u] + e[i].c;
				fl[v] = min(fl[u], e[i].w);
				pat[v] = i;
				if (!vis[v]) {
					vis[v] = true;
					q.push(v);
				}
			}
		}
	}
	return dis[T] < 0x3f3f3f3f3f3f3f3f;
}
void EK() {
	while (SPFA()) {
		maxf += fl[T];
		minc += fl[T] * dis[T];
		for (int i = T; i != S; i = e[pat[i] ^ 1].to) {
			e[pat[i]].w -= fl[T];
			e[pat[i] ^ 1].w += fl[T];
		}
	}
}
int inl[505];
int main() {
	scanf("%d", &n);
	for (int i = 2; i <= n; i++) {
		InsertF(i, 1, inf, 0);
	}
	for (int i = 1; i <= n; i++) {
		int k;
		scanf("%d", &k);
		while (k--) {
			int v; ll c;
			scanf("%d%lld", &v, &c);
			minc += c;
			InsertF(i, v, inf, c);
			inl[v]++; inl[i]--;
		}
	}
	for (int i = 1; i <= n; i++) {
		if (inl[i] > 0) {
			InsertF(S, i, inl[i], 0);
		}
		else if (inl[i] < 0) {
			InsertF(i, T, -inl[i], 0);
		}
	}
	EK();
	printf("%lld\n", minc);
	return 0;
}
```

---

## 作者：Echoternity (赞：3)

费用流居然没有人写 $\operatorname{SSP-Dinic}$ 。翻遍全网都是 $\operatorname{SSP-EK}$ 或者 $\operatorname{MCMF}$ 的写法。

名正言顺的 $\operatorname{SSP-Dinic}$ 的上下界费用流写法。（甚至以 $\text{86ms}$ 冲进了最优解）其实与上下界网络流无异，就是将 `Bfs()` 换成 `Spfa()` 即可，难点依然在建图：

1. 对于剧情 $i$ 能够到达 $u$，链接 $(i,u)$，容量为 $[1,inf]$，费用为 $v$。
2. 因为除了 $1$ 号剧情，其它所有剧情都应该能够直接结束，所以链接 $(i,T)$，这里的 $T$ 是真实汇点，容量为 $[0,inf]$，费用为 $0$；
3. 对于流量不守恒的点，根据 $A[i]$ 的正负，链接虚拟源点或者虚拟汇点，容量为 $\mid A[i]\mid$，费用为 $0$。
4. 链接 $(T,S)$，真实源汇点。容量为 $[0,inf]$，费用为 $0$。

对建图进行一定的解释：

* 第一条下界为 $1$ 是因为题目要求所有剧情都必须要过一遍，但过多少遍是无所谓的；
* 第三条和第四条都是上下界网络流的常规操作，就不必要多解释了。

因为这里只是求取可行流，所以跑一遍即可。也不需要跑第二次求残流网络的浮动流量，也不需要去删边。

[网络流一小时速通](https://violeteternal.github.io/Eternity/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/OI/network-flow/)

``` c++
const int MAXN=1e3+10;
const int MAXM=1e6+10;
const int INF=0x3f3f3f3f;
int N,M,S,T,ret;
struct Net
{
    int next,to,val,cost;
}Edge[MAXM<<1];
//结构体内存的是：下一条边的编号，边的指向，边的容量，边的费用
int Head[MAXN],Cur[MAXN],Total=1;
//网络流特性：Total开始必须为偶数
//Cur是Dinic的当前弧优化
inline void addEdge(int u,int v,int w,int c)
{
    Edge[++Total]=(Net){Head[u],v,w,c};Head[u]=Total;
    Edge[++Total]=(Net){Head[v],u,0,-c};Head[v]=Total;
}
//链式前向星建边操作
int Dist[MAXN],A[MAXN];
bool Vis[MAXN];
//A的含义：点容量差，即进入的容量减去流出的容量
inline bool Spfa()
{
    std::queue<int>Q;
    memset(Dist,0x3f,sizeof(Dist));
    memset(Vis,0,sizeof(Vis));
    Q.push(S);
    Dist[S]=0;
    while(!Q.empty())
    {
        int u=Q.front();Q.pop();
        Vis[u]=0;
        for(int e=Head[u];e;e=Edge[e].next)
        {
            int v=Edge[e].to;
            if(Dist[v]>Dist[u]+Edge[e].cost&&Edge[e].val)
            {
                Dist[v]=Dist[u]+Edge[e].cost;
                if(!Vis[v]) Vis[v]=1,Q.push(v);
            }
        }
    }
    return Dist[T]!=INF;
}
//费用流的增广（也可以用其它的最短路算法）
int Dfs(int x,int inf)
{
    if(x==T) return inf;
    int flow=0;Vis[x]=1;
    for(int e=Cur[x],v;e&&flow<inf;e=Edge[e].next)
    {
        v=Edge[e].to,Cur[x]=e;
        if(!Vis[v]&&Edge[e].val&&Dist[v]==Dist[x]+Edge[e].cost)
        {
            int k=Dfs(v,std::min(Edge[e].val,inf-flow));
            if(k)
            {
                ret+=k*Edge[e].cost;
                Edge[e].val-=k,Edge[e^1].val+=k,flow+=k;
            }
        }
    }
    Vis[x]=0;
    //这是个疑点，我没加这句的时候也A了
    //加了之后直接跑进最优解
    return flow;
}
//Dinic的推流操作
inline int Dinic()
{
    int r=0,flow;
    while(Spfa())
    {
        memcpy(Cur,Head,sizeof(Head));
        while(flow=Dfs(S,INF)) r+=flow;
    }
    return r;
}
//Dinic全局增广
int main()
{
    // freopen("netflow.in","r",stdin);
    // freopen("netflow.out","w",stdout);
    read(N);
    int rS=1,rT=N+1,vS=N+2,vT=N+3;
    //真实源汇点(Reality)和虚拟源汇点(virtual)
    for(int i=1,k;i<=N;++i)
    {
        read(k);
        for(int j=1,u,v;j<=k;++j)
        {
            read(u,v);
            ++A[u],--A[i];
            ret+=v;addEdge(i,u,INF-1,v);
        }
    }
    for(int i=2;i<=N;++i) addEdge(i,rT,INF,0);
    for(int i=1;i<=N;++i)
    {
        if(A[i]>0) addEdge(vS,i,A[i],0);
        else if(A[i]<0) addEdge(i,vT,-A[i],0);
    }
    addEdge(rT,rS,INF,0);
    S=vS,T=vT;
    Dinic();
    write(ret);
    return 0;
}
/*
6
2 2 1 3 2
2 4 3 5 4
2 5 5 6 6
0
0
0
*/
```

---

## 作者：mzgwty (赞：3)

这题显然可以利用单纯形法解决（主要是因为我太懒不想写费用流）

我们对加入的每一条边标号。对于每一个点，我们只需要保证流向它的边的流量大于等于它流出的流量，然后每一条给出的边的下界为 $1$ ，除此之外，我们需要添加一些从 $1$ 以外的节点连向 $1$ 的边，它们的流量下界为 $0$ 。

考虑将所有流量至少为 $1$ 的边的流量设为 $x_i+1 $，其余为 $x_i$ ，那么对于每一条边，如果它存在于图上，那么就将它的来源对应的常数项加上 $1$ ，它的终点的常数项减去 $1$ ；否则不修改常数项。

然后利用对偶原理将求最小值转化成求最大值跑一遍线性规划，最后加上图中边的边权之和就行了。

```cpp
#include<stdio.h>
#include<string.h>
#include<math.h>
#include<algorithm>
#include<iostream>
#include<queue>
using namespace std;

const int N=5305,M=305;
const double eps=1e-8,INF=1e18;

int n,m,k,b,c;

double a[N][M];

inline void pivot(int l,int e) {
	double t=a[l][e];a[l][e]=1;
	for(int i=0 ; i<=m ; ++i) a[l][i]/=t;
	for(int i=0 ; i<=n ; ++i)
		if(i!=l&&fabs(a[i][e])>eps) {
			t=a[i][e],a[i][e]=0;
			for(int j=0 ; j<=m ; ++j) a[i][j]-=t*a[l][j];
		}
}

inline double simplex() {
	int l,e;
	double t,p;
	while(1) {
		e=m+1;
		for(int i=1 ; i<=m ; ++i) if(a[0][i]>eps) {e=i;break ;}
		if(e==m+1) break ;
		t=INF;
		for(int i=1 ; i<=n ; ++i)
			if(a[i][e]>eps&&t>(p=a[i][0]/a[i][e]))
				t=p,l=i;
		if(t==INF) return INF;
		pivot(l,e);
	}
	return a[0][0];
}

int sum;

int main() {
	scanf("%d",&n);
	for(int i=1 ; i<=n ; ++i) {
		scanf("%d",&k);
		for(int j=1 ; j<=k ; ++j)
			scanf("%d%d",&b,&c),sum+=c,a[++m][i]=-1,++a[0][i],a[m][b]=1,--a[0][b],a[m][0]=c;//这里需要注意一下
		if(i!=1) a[++m][i]=-1,a[m][1]=1;
	}
	swap(n,m);
	printf("%.0lf",-simplex()+sum);
	return 0;
}
```

---

## 作者：AubRain (赞：2)

## 有源汇点上下界最小费用可行流

按照题意，在 DAG 上，每条边的下界为 $1$ ，上界是 $INF$ ,费用为时间。按照输入建边即可。

按照题意，源点为 $1$ 节点，每个点向汇点连流量 $INF$ 的边。

然后源汇点的流量可以不守恒，于是要从汇点向源点连流量 $INF$ 的边。此时就可以转化成 **无源汇点上下界费用流**。

$ss$ ，$tt$ 是题意所要求的源汇点，$s$ ，$t$ 是超级源汇点。

```cpp
#include <bits/stdc++.h>
#define N 1005
#define M 1000005
#define INF 1e9
using namespace std;

inline void rd(int &X){
    X=0;int w=0;char ch=0;
    while(!isdigit(ch))w|=ch=='-',ch=getchar();
    while( isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    X=w?-X:X;
}

int n,m,ans,s=N-2,t=s+1,ss,tt;
int head[N],cnt=1,T[N];
int d[N],mn[N],v[N],pre[N];
struct nd{int nxt,to,v,c,l,r,pd;}e[M];
#define For(x) for(int y,i=head[x];(y=e[i].to);i=e[i].nxt)

inline void add(int x,int y,int v,int c=0,int l=0,int r=0){
	if(!v) v=r-l;
	e[++cnt]=(nd){head[x],y,v, c,l,r,-1};head[x]=cnt;
	e[++cnt]=(nd){head[y],x,0,-c,l,r, 1};head[y]=cnt;
}
bool SPFA()
{
    memset(d,0x3f,sizeof d);d[s]=0;
    queue<int> q;q.push(s);mn[s]=1<<29;
    while(!q.empty()){
        int x=q.front();q.pop();v[x]=0;
        For(x) if(e[i].v&&d[y]>d[x]+e[i].c)
        {
            pre[y]=i; d[y]=d[x]+e[i].c;
            mn[y]=min(mn[x],e[i].v);
            if(!v[y]) v[y]=1,q.push(y);
        }
    }
    return d[t]!=0x3f3f3f3f;
}
void up()
{
    ans+=d[t]*mn[t];
    for(int i,x=t;x!=s;x=e[i^1].to)
        i=pre[x],e[i].v-=mn[t],e[i^1].v+=mn[t];
}
void solve()
{
	for(int x=1;x<=n+1;x++)
		For(x) T[x]+=e[i].pd*e[i].l,ans+=e[i].l*e[i].c*(e[i].pd<0);
	for(int i=1;i<=n+1;i++)
		if(T[i]>0) add(s,i,T[i],0);
		else if(T[i]<0) add(i,t,-T[i],0);
	while(SPFA()) up();
}
signed main(){
	rd(n);ss=1;tt=n+1;
	add(tt,ss,INF);
	for(int x,v,i=1;i<=n;i++){
		rd(m);
		while(m--) rd(x),rd(v),add(i,x,0,v,1,INF);
	}
	for(int i=2;i<=n;i++)
		add(i,tt,INF);
	solve();cout<<ans;
}

```

---

## 作者：Mark_4396 (赞：1)

有源汇有容量下界最小费用流

每个支线剧情节点，也就是终结节点，连一条INF的边到起始点1，费用为0，这样就构成了无源汇有容量下界费用流问题。先对弧进行改造，容量减去下界，然后对点进行改造，统计每个点减少的出度和入度，缺出度的，点连权值为出度的边到汇点；缺入度的，源点连权值为入度的边到点，附加边的费用为0，然后跑费用流，费用+附加边的费用为最小费用```
```
#include <bits/stdc++.h>
using namespace std;

const int INF = 0x3f3f3f3f;
const int maxn = 310;
const int maxm = 40000;
int n, k, b, t;
int tot;
int d[maxm];

struct Edge
{
    int to, next, cap, flow, cost;
}edge[maxm];
int head[maxn], tol;
int pre[maxn], dis[maxn];
bool vis[maxn];
int N ;//节点总个数，节点编号从0~N-1
void init(int n)
{
    N = n;
    tol = 0;
    memset(head, -1, sizeof(head));
}
void addedge(int u, int v, int cap, int cost)
{
    edge[tol].to = v;
    edge[tol].cap = cap;
    edge[tol].cost = cost;
    edge[tol].flow = 0;
    edge[tol].next = head[u];
    head[u] = tol++;
    edge[tol].to = u;
    edge[tol].cap = 0;
    edge[tol].cost = -cost;
    edge[tol].flow = 0;
    edge[tol].next = head[v];
    head[v] = tol++;
}

bool spfa(int s, int t)
{
    queue<int>q;
    for(int i = 0; i < N; i++)
    {
        dis[i] = INF;
        vis[i] = false;
        pre[i] = -1;
    }
    dis[s] = 0;
    vis[s] = true;
    q.push(s);
    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            int v = edge[i].to;
            if(edge[i].cap > edge[i].flow && dis[v] > dis[u] + edge[i].cost)
            {
                dis[v] = dis[u] + edge[i].cost;
                    pre[v] = i;
                if(!vis[v])
                {
                    vis[v] = true;
                    q.push(v);
                }
            }
        }
    }
    if(pre[t] == -1) return false;
    else return true;
}

int minCostMaxflow(int s, int t, int &cost)
{
    int flow = 0;
    cost = 0;
    while(spfa(s,t))
    {
        int Min = INF;
        for(int i = pre[t]; i != -1; i = pre[edge[i^1].to])
        {
            if(Min > edge[i].cap - edge[i].flow)
                Min = edge[i].cap - edge[i].flow;
        }
        for(int i = pre[t]; i != -1; i = pre[edge[i^1].to])
        {
            edge[i].flow += Min;
            edge[i^1].flow -= Min;
            cost +=  edge[i].cost*Min;
        }
        flow += Min;
    }
    return flow;
}

int main()
{
    cin >> n;
    tot = 0;
    memset(d, 0, sizeof(d));
    int st = 0, ed = n+1;
    init(n+2);
    addedge(ed, st, INF, 0);
    for(int i = 1; i <= n; i++)
    {
        scanf("%d", &k);
        for(int j = 1; j <= k; j++)
        {
            scanf("%d%d", &b, &t);
            tot+=t;
            addedge(i, b, INF, t);
            d[i]--, d[b]++;
        }
    }
    for(int i = 2; i <= n; i++)
        addedge(i, 1, INF, 0);
    for(int i = 1; i <= n; i++)
    {
        if(d[i]>0)
            addedge(st, i, d[i], 0);
        else if(d[i] < 0)
            addedge(i, ed, -d[i], 0);
    }
    int c;
    minCostMaxflow(st, ed, c);
    cout << tot+c;
    return 0;
}
```



---

## 作者：elijahqi (赞：1)

(http://www.elijahqi.win/2017/12/22/bzoj3876-ahoi2014jsoi2014%E6%94%AF%E7%BA%BF%E5%89%A7%E6%83%85/)

Description

http://blog.csdn.net/elijahqi/article/details/78873474

【故事背景】

宅男JYY非常喜欢玩RPG游戏，比如仙剑，轩辕剑等等。不过JYY喜欢的并不是战斗场景，而是类似电视剧一般的充满恩怨情仇的剧情。这些游戏往往

都有很多的支线剧情，现在JYY想花费最少的时间看完所有的支线剧情。

【问题描述】

JYY现在所玩的RPG游戏中，一共有N个剧情点，由1到N编号，第i个剧情点可以根据JYY的不同的选择，而经过不同的支线剧情，前往Ki种不同的新的剧情点。当然如果为0，则说明i号剧情点是游戏的一个结局了。

JYY观看一个支线剧情需要一定的时间。JYY一开始处在1号剧情点，也就是游戏的开始。显然任何一个剧情点都是从1号剧情点可达的。此外，随着游戏的进行，剧情是不可逆的。所以游戏保证从任意剧情点出发，都不能再回到这个剧情点。由于JYY过度使用修改器，导致游戏的“存档”和“读档”功能损坏了，

所以JYY要想回到之前的剧情点，唯一的方法就是退出当前游戏，并开始新的游戏，也就是回到1号剧情点。JYY可以在任何时刻退出游戏并重新开始。不断开始新的游戏重复观看已经看过的剧情是很痛苦，JYY希望花费最少的时间，看完所有不同的支线剧情。

Input
输入一行包含一个正整数N。

接下来N行，第i行为i号剧情点的信息；

第一个整数为，接下来个整数对，Bij和Tij，表示从剧情点i可以前往剧

情点，并且观看这段支线剧情需要花费的时间。


Output

输出一行包含一个整数，表示JYY看完所有支线剧情所需要的最少时间。




Sample Input

6
2 2 1 3 2

2 4 3 5 4

2 5 5 6 6

0
0
0
Sample Output

24
HINT

JYY需要重新开始3次游戏，加上一开始的一次游戏，4次游戏的进程是


1->2->4，1->2->5，1->3->5和1->3->6。




对于100%的数据满足N<=300,0<=Ki<=50,1<=Tij<=300,Sigma(Ki)<=5000

这题其实可以有别的方法 但是为了练习下板子 还是写了上下界的最小费用流

做法大概就是首先我先把所有流量的下界都流上 然后同时 这些答案肯定都是有了的  而且我因为这个图是所有下界都是1的可行流 那么一定存在 所以我建一个无源无汇的图 然后只要这个新图跑满流 就代表我原图流量平衡了 那么我只需要在满足下界的情况下使得流量平衡 再跑一下最小费用最大流即可

```cpp

#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define inf 0x3f3f3f3f
#define N 330
using namespace std;
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
inline int read(){
    int x=0;char ch=gc();
    while(ch<'0'||ch>'9') ch=gc();
    while(ch<='9'&&ch>='0') x=x*10+ch-'0',ch=gc();
    return x;
}
int num=1,h[N],d[N],T,pre[N],path[N],n,flag[N],f[N];
struct node{
    int y,z,next,c;
}data[N*N*2];
inline void insert1(int x,int y,int z,int c){
    data[++num].y=y;data[num].z=z;data[num].next=h[x];h[x]=num;data[num].c=c;
    data[++num].y=x;data[num].z=0;data[num].next=h[y];h[y]=num;data[num].c=-c;
}
inline bool spfa(){
    queue<int> q;memset(flag,0,sizeof(flag));memset(f,0x3f,sizeof(f));memset(pre,-1,sizeof(pre));q.push(0);flag[0]=1;f[0]=0;
    while(!q.empty()){
        int x=q.front();q.pop();flag[x]=0;
        for (int i=h[x];i;i=data[i].next){
            int y=data[i].y,z=data[i].z,c=data[i].c;
            if (f[x]+c<f[y]&&z){
                f[y]=f[x]+c;pre[y]=x;path[y]=i;
                if(!flag[y]) q.push(y),flag[y]=1;
            }
        }
    }if (pre[T]==-1) return 0;else return 1;
}
int main(){
    freopen("bzoj3876.in","r",stdin);
    n=read();int ans=0,t=n+1;T=n+2;
    for (int i=1;i<=n;++i){
        int nm=read();d[i]-=nm;insert1(i,t,inf,0);
        for (int j=1;j<=nm;++j){int y=read(),z=read();++d[y];insert1(i,y,inf,z);ans+=z;}
    }
    for (int i=1;i<=n;++i){if (d[i]<0) insert1(i,T,-d[i],0);if (d[i]>0) insert1(0,i,d[i],0);}insert1(t,1,inf,0);
    while(spfa()){
        int minn=inf,now=T;
        while(now) minn=min(minn,data[path[now]].z),now=pre[now];now=T;
        while(now){ans+=data[path[now]].c*minn;data[path[now]].z-=minn;data[path[now]^1].z+=minn;now=pre[now];}
    }printf("%d",ans);
    return 0;
}


```

---


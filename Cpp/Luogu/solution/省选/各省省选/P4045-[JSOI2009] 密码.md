# [JSOI2009] 密码

## 题目描述

众所周知，密码在信息领域起到了不可估量的作用。对于普通的登陆口令以，唯一的破解方法就是暴力破解——逐个尝试所有可能的字母组合，但这是一项很耗时又容易被发现的工作。所以，为了获取对方的登陆口令，在暴力破解密码之前，必须先做大量的准备工作。经过情报的搜集，现在得到了若干有用信息，形如：

> ​     “我观察到，密码中含有字符串*。”

例如，对于一个 $10$ 位的密码以及观察到的字符串 `hello` 与 `world`，可能的密码组合为 `helloworld`与 `worldhello`；而对于 $6$ 位的密码以及到的字符串 `good` 与 `day`,可能的密码组合为 `gooday`。

有了这些信息，就能够大大地减少尝试的次数了。请编一个程序，计算所有密码组合的可能。密码中仅可能包含 `a-z` 之间的小写字母。

## 说明/提示

对于 $100\%$ 的数据，$1\leq L\leq 25,1\leq N\leq 10$，每个观察到的字符串长不超过 $10$，并且保证输出结果小于 $2^{63}$。


## 样例 #1

### 输入

```
10 2
hello
world```

### 输出

```
2
helloworld
worldhello```

# 题解

## 作者：皎月半洒花 (赞：20)

这里说一种跟另外两篇题解不一样的剪枝。

同时……这题大概也就是蓝~紫左右，这个黑实在太虚了。

观察题意，由 `good+day=gooday` 可知应该放在 $\rm AC$ 自动机上做，观察范围可知是状压。记 $f_{i,j,s}$ 表示匹配到串的第 $i$ 位，走到了自动机上的第 $j$ 个节点，当前已经拼完了集合 $s$ 中的模式串的方案数。那么转移自然很简单。值得提一句的的是，由于本身 $\rm AC$ 自动机存在路径压缩，所以是 `认子不认父` 的结构，只能刷表。

之后考虑输出方案。考虑一种无脑的输出方式。由于很容易 $dfs$ 出每个状态 $(i,j,k)$ 是否可以转移到终点，所以不需要考虑 $42$ 的限制，剪完枝直接输出即可。

同时，只要在 $\rm AC$ 自动机上保证每次走最小的字母，就一定是字典序最优的方案。

```cpp
int o ;
LL ans ;
int n, m ;
int t[N] ;
char s[N] ;
LL f[N][W][Z] ;
bool g[N][W][Z] ;
bool v[N][W][Z] ;

struct ACAM{
    int size ;
    int _ed[W] ;
    int fail[W] ;
    queue <int> q ;
    int trans[W][26] ;
    void Ins(char *t, int num){
        int rt = 0, len ;
        len = strlen(t + 1) ;
        for (int x, i = 1 ; i <= len ; ++ i){
            x = t[i] - 'a' ;
            if (!trans[rt][x])
                trans[rt][x] = ++ size ;
            rt = trans[rt][x] ;
        }
        _ed[rt] |= (1 << num) ;
    }
    void build(){
        for (int i = 0 ; i < 26 ; ++ i)
            if (trans[0][i]) q.push(trans[0][i]) ;
        while (!q.empty()){
            int x = q.front() ;
            q.pop() ; _ed[x] |= _ed[fail[x]] ;
            for (int i = 0 ; i < 26 ; ++ i){
                if (!trans[x][i]) trans[x][i] = trans[fail[x]][i] ;
                else fail[trans[x][i]] = trans[fail[x]][i], q.push(trans[x][i]) ;
            }
        }
    }
}S ;
bool search(int x, int y, int z){
    if (x == n){
        v[x][y][z] = 1 ;
        return g[x][y][z] = (bool)(z == o) ;
    }
    bool p = 0 ;
    if (v[x][y][z])
        return g[x][y][z] ;
    else v[x][y][z] = 1 ;
    for (int i = 0 ; i < 26 ; ++ i)
        p |= search(x + 1, S.trans[y][i], z | S._ed[S.trans[y][i]]) ;
    return g[x][y][z] = p ;
}
void output(int x, int y, int z){
    if (!g[x][y][z]) return ;
    if (x == n){
        for (int i = 1 ; i <= n ; ++ i)
            printf("%c", t[i] + 'a') ;
        return puts(""), void() ;
    }
    for (int i = 0 ; i < 26 ; ++ i)
        t[x + 1] = i, output(x + 1, S.trans[y][i], z | S._ed[S.trans[y][i]]) ;
}
int main(){
    cin >> n >> m ; S.size = 0 ;
    for (int i = 1 ; i <= m ; ++ i)
        scanf("%s", s + 1), S.Ins(s, i - 1) ;
    S.build() ; f[0][0][0] = 1 ; o = (1 << m) - 1 ;
    for (int i = 0 ; i < n ; ++ i)
        for (int j = 0 ; j <= S.size ; ++ j)
            for (int k = 0 ; k <= o ; ++ k)
                if (f[i][j][k])
                    for (int l = 0 ; l < 26 ; ++ l)
                        f[i + 1][S.trans[j][l]][k | S._ed[S.trans[j][l]]] += f[i][j][k] ;
    for (int i = 0 ; i <= S.size ; ++ i) ans += f[n][i][o] ;
    if (ans > 42) return printf("%lld\n", ans), 0 ;
    else return cout << ans << '\n', search(0, 0, 0), output(0, 0, 0), 0 ;
}

```

---

## 作者：longgod (赞：8)


说实在的，讲真，思路并不是很难

但是由于自己脑抽了，

所以几乎怼了一上午

重要的事情说三遍，

不要直接给字符串排序 

不要直接给字符串排序

真的不要直接给字符串排序

不然很容易翻车的…… 

废话不多说，题解：

 
一串密码，必须包含以下所有的单词

很显然，trie上面跑AC自动机构建fail指针

然后dp

几乎已经成为AC自动机的一个套路了…… 

其实在我们没看数据范围之前我们就可以大胆猜测

既然是包含所有单词的问题，没准是状压dp呢？

一看数据范围 

n<=10

很好，状压不解释

dp[i][j][S]

长度为i，并且当前状态在trie树上第j个节点，单词使用为S的方案数

在我们构建trie树的时候，对于有单词的节点，我们就设置一个from，标记它来自第几个单词

这样，在dp转移的时候，我们就可以把他和S取或，将这个单词存进S里面向下转移

那么转移的方程就可以非常轻易的推出了，

首先，我们枚举接下来可能去到的单词(a-z)

然后从当前的j往下走一层

同时长度i+1

如果这个节点恰好是个单词节点，不管三七二十一，加入到S里面去（并没有规定不可以重复使用）

最后统计dp[Len][trie树所有节点][S总]即可，

很好，如果你真的这么干的话，

你只有40分

为什么？

如果单词是 ca和a

当我们取ca之后

实际上我们已经取了a，也就是所有单词都已经出现了。

但是，我们的上述算法并不能对此作出反应，他会认为，'a'，没有出现过。

怎么办？

去掉重复单词，去除被包含单词，

只要是被其他单词所包含的单词 删掉！

重复的单词，删掉！

这么刚？

就是这么刚！

然后dp就行了

当然，最后统计答案的时候

S总的实际意义指的是没有被删除的单词的集合

等等……

还有输出方案呢!

暴搜！

当答案小于等于42时

实际上是不会存在单个字符的

严格的说，就是答案小于等于42时

必然是所有单词（去重后）以某种顺序相连所组成的

直接暴搜就好了

注意处理一下单词间的重复前后缀

我这里用了一种很暴力的方法

网上有更好的 

~~但我觉得我的更好理解~~

感觉自己代码巨丑无比
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
ll dp[35][105][2105];
struct ha
{
    int next[26];
    int fail;
    int from;
    ha()
    {
        memset(next,0,sizeof next);
        fail=from=0;
    }
}trie[205];
int Len,n,cnt;
char tmp[25][25];
int q[2550];
char save[205];
bool book[205];
char answer[55][205];
int ranky[55];
int co;
int del[105];
int all;
inline void insert(char *s,int from)
{
    register int i,j,now=0,len=strlen(s);
    all+=len;
    for(i=0;i<len;i++)
    {
        j=s[i]-'a';
        if(!trie[now].next[j])
        trie[now].next[j]=++cnt;
        now=trie[now].next[j];
    }
    trie[now].from=from;
}
inline void getfail()
{
    register int i,j,u,fail,head=1,tail=1;
    for(i=0;i<26;i++)
    if(trie[0].next[i])
    q[tail++]=trie[0].next[i];
    while(head<tail)
    {
        u=q[head++];
        for(i=0;i<26;i++)
        {
            if(!trie[u].next[i])
            {
                trie[u].next[i]=trie[trie[u].fail].next[i];
                continue;
            }
            q[tail++]=trie[u].next[i];
            fail=trie[u].fail;
            fail=trie[fail].next[i];
            trie[trie[u].next[i]].fail=fail;
        }
    }
}
inline bool getin(int k,int l,int r)
{
    register int i,j=0;
    for(i=l;i<=r;i++)
    {
        if(tmp[k][j]!=save[i]) return false;
        j++;
    }
    return true;
}
inline int in(int k,int loc,int len)//loc 要插的位置，即末尾减一 
{
    register int i,j;
    int reme=loc;
    for(i=loc-1;i>=0;i--)
    if(getin(k,i,loc-1))
    reme=i;
    i=reme;
    for(j=0;j<len;j++)
    save[i]=tmp[k][j],i++;
    if(i<loc) i=loc;
    return i;
}
inline void out(int now)
{
    for(register int i=0;i<now;i++)
    putchar(save[i]);
    putchar('\n');
}
inline void dfs(int now,int rest)
{
    register int i,j,k;
    //out(now);
    if(now>Len) return;
    if(now==Len&&rest==0)
    {
        co++;
        for(i=0;i<Len;i++)
        answer[co][i]=save[i];
        return;
    }
    else
    if(now==Len||rest==0) return;
    for(i=1;i<=n;i++)
    {
        if(del[i]||book[i]) continue;
        int len=strlen(tmp[i]);
        j=in(i,now,len);
        book[i]=true;
        dfs(j,rest-1);
        book[i]=false;
    }
}
inline bool check(char *T,char *s)
{
    register int i,j,k,l1=strlen(T),l2=strlen(s);
    if(l1<l2) return false;
    for(i=0;i<l1;i++)
    {
        if(l1-i<l2) return false;
        for(k=i,j=0;j<l2;j++)
        {
            if(T[k]!=s[j]) 
            break;
            k++; 
        }
        if(j==l2)
        return true;
    }
    return false;
}
inline bool cmp(int x,int y)
{
     for(int i=0;i<Len;i++)
     if(answer[x][i]!=answer[y][i])return answer[x][i]<answer[y][i];
     return 0;
}
inline void _swap(char *a,char *b)
{
	 register int i;
     for(i=0;i<Len;i++)
     {
     	swap(a[i],b[i]);
     }
}
int main()
{
    scanf("%d%d",&Len,&n);
    register int a,b,c,i,j,k;
    int S=1<<n;
    for(i=1;i<=n;i++)
    scanf("%s",tmp[i]);
    for(a=1;a<=n;a++)
    {
    	for(b=1;b<n;b++)
    	{
    		if(strcmp(tmp[b],tmp[b+1])==1)
    		swap(tmp[b],tmp[b+1]);
    	}
    }
    for(a=1;a<=n;a++)
    {
    	if(del[a]) continue;
        for(b=1;b<=n;b++)
    	if(b!=a&&!del[b])
    	if(check(tmp[a],tmp[b]))
    	del[b]=1;
    }
    for(i=1;i<=n;i++)
    if(!del[i])
    insert(tmp[i],i);
    getfail();
    dp[0][0][0]=1;
    for(a=0;a<Len;a++)
    {
        for(b=0;b<=cnt;b++)
        {
            for(c=0;c<S;c++)
            {
                for(k=0;k<26;k++)
                {
                    int Next=trie[b].next[k];
                    int tmpc=c;
                    if(trie[Next].from)
                    {
                        j=trie[Next].from;
                        j=(1<<(j-1));
                        tmpc|=j;
                    }
                    dp[a+1][Next][tmpc]+=dp[a][b][c];
                }
            }
        }
    }
    ll ans=0;
    int right=0;
    for(a=1;a<=n;a++)
    if(!del[a])
    right+=(1<<(a-1));
    for(a=0;a<=cnt;a++)
    ans+=dp[Len][a][right];
    cout<<ans<<endl;
    if(ans<=42)
    {
    	int tot=n;
        for(a=1;a<=n;a++)
        if(del[a])
        tot--;
     	dfs(0,tot);
        for(a=1;a<=co;a++)
        ranky[a]=a;
        sort(ranky+1,ranky+1+co,cmp);
        for(a=1;a<=co;a++)
        puts(answer[ranky[a]]);
    }
    return 0;
}
```
哦，对了，学弟的博客，推荐一下 [http://www.cnblogs.com/dedicatus545/]

---

## 作者：CMY2013 (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P4045)

看到题目要求求出方案数，所以要么用 dp 要么用组合数学，这里本蒟蒻用的是 dp 求解。

首先我们来考虑这道题的算法。结合字符串和题目要求，我们发现这道题跟 AC 自动机有关~~我才不会告诉你我是从标签里看到的~~。 

其次来推导 dp 方程。观察数据范围得出，这道题可以使用状压来解决，那么这道题的方程就显而易见了。用 $ dp_{i,j,k} $ 来表示构造出 $i$ 位后，当前在 AC 自动机的第 $j$ 个节点，子串集为 $k$ 的方案数，则转移方程为 $ dp_{i,j,k}→dp_{i+1,tr_{j,l},k|state_{tr_{j,l}}} $ 。那么最终答案为 $ \sum\limits_{i=0}^{temp} dp_{len,i,2^n-1} $ 。 

最后来考虑怎样输出答案。我们可以用一个 bool 数组 $ f_{i,j,k} $ 来表示构造出 $i$ 位后，当前在 AC 自动机的第 $j$ 个节点，子串集为 $k$ 时是否可以继续构造下去使得最终可以构造出一个满足题目条件的字符串。而这个 bool 数组可以用 dfs 来解决。最终我们在结合着 $f$ 数组输出就可以了。

#### 提醒

1. 一定要开 long long 。 

2. dfs 时一定要加记忆化。


### CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,tr[110][30],cnt[110],fail[110],tot=0;
long long dp[30][110][(1<<10)];
bool f[30][110][(1<<10)],vis[30][110][(1<<10)];
void addtrie(string s,int x) //创建trie树
{
	int rt=0;
	for(int i=0;i<s.size();i++)
	{
		if(!tr[rt][s[i]-'a']) tr[rt][s[i]-'a']=++tot;
		rt=tr[rt][s[i]-'a'];
	}
	cnt[rt]|=(1<<(x-1));
}

void qfail() //通过BFS算出失配指针
{
	queue<int> q;
	for(int i=0;i<26;i++) 
	{
		if(tr[0][i])
		{
			fail[tr[0][i]]=0;
			q.push(tr[0][i]);
		}
	 } 
	while(!q.empty())
	{
		int nw=q.front();
		q.pop();
		for(int i=0;i<26;i++)
		{
			if(tr[nw][i])
			{
				fail[tr[nw][i]]=tr[fail[nw]][i];
				cnt[tr[nw][i]]|=cnt[tr[fail[nw]][i]];
				q.push(tr[nw][i]);
			}
			else tr[nw][i]=tr[fail[nw]][i];
		}
	}
}

bool dfs1(int x,int y,int z) //求取f数组
{
	if(vis[x][y][z]) return f[x][y][z];
	vis[x][y][z]=true;
	if(x==l)
	{
		if(z==(1<<n)-1) f[x][y][z]=true;
		return f[x][y][z];
	}
	for(int i=0;i<26;i++)
	{
		f[x][y][z]|=dfs1(x+1,tr[y][i],z|cnt[tr[y][i]]);
	}
	return f[x][y][z];
}

char c[30];

void dfs2(int x,int y,int z) //输出最终答案
{
	if(x==l)
	{
		for(int i=1;i<=l;i++) cout<<(char)(c[i]+'a');
		cout<<endl;
		return;
	}
	for(int i=0;i<26;i++)
	{
		if(f[x+1][tr[y][i]][z|cnt[tr[y][i]]])
		{
			c[x+1]=i;
			dfs2(x+1,tr[y][i],z|cnt[tr[y][i]]);
		}
	}
}

int main()
{
	string s;
	cin>>l>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		addtrie(s,i);
	}
	qfail(); //构建AC自动机
	dp[0][0][0]=1;
	for(int i=0;i<l;i++)
	{
		for(int j=0;j<=tot;j++)
		{
			for(int k=0;k<(1<<n);k++)
			{
				for(int o=0;o<26;o++)
				{
					dp[i+1][tr[j][o]][k|(cnt[tr[j][o]])]+=dp[i][j][k];  //dp求解每种状态能以多少种方案完成
				}
			}
		}
	}
	long long ans=0;
	for(int i=0;i<=tot;i++) ans+=dp[l][i][(1<<n)-1]; //统计方案数
	cout<<ans<<endl;
	if(ans<=42)
	{
		dfs1(0,0,0);
		dfs2(0,0,0);
	}
	return 0;
}
```

---

## 作者：jijidawang (赞：5)

显然 AC 自动机，吧

和 [文本生成器](https://www.luogu.com.cn/problem/P4052) 那题类似，考虑状压 DP，令 $dp_{i,j,k}$ 表示到第 $i$ 位，自动机上是 $j$，包含集合 $k$ 的模式串个数 .

于是转移就在 AC 自动机上走一步即可（刷表）.

然后这个输出方案就很恶心，注意到如果输出方案则答案不超过 $42$，于是暴搜即可 .

DP 转移咋写的暴搜就咋写，本质是相同的 .

**数组别开小 数组别开小 数组别开小 数组别开小 数组别开小**


代码：
```cpp
using namespace std;
typedef long long ll;
const int L = 27, N = 111, T = 1<<11, alphabet = 26;
inline int trans(const char c){return c - 'a';}
int n, m;
ll dp[L][N][T];
struct AC
{
	int tr[N][alphabet], mark[N], fail[N], root, cc;
	inline void insert(int id, string s)
	{
		int u = root, l = s.length();
		for (int i=0; i<l; i++)
		{
			int _ = trans(s[i]);
			if (!tr[u][_]) tr[u][_] = ++cc;
			u = tr[u][_];
		} mark[u] |= (1 << id);
	}
	inline void build()
	{
		queue<int> q; fail[root] = root;
		for (int i=0; i<alphabet; i++)
		{
			if (tr[root][i]){q.push(tr[root][i]); fail[tr[root][i]] = root;}
			else tr[root][i] = root;
		}
		while (!q.empty())
		{
			int u = q.front(); q.pop(); mark[u] |= mark[fail[u]];
			for (int i=0; i<alphabet; i++)
			{
				if (tr[u][i]){fail[tr[u][i]] = tr[fail[u]][i]; q.push(tr[u][i]); mark[tr[u][i]] |= mark[fail[tr[u][i]]];}
				else tr[u][i] = tr[fail[u]][i];
			}
		}
	}
	inline ll DP()
	{
		dp[0][0][0] = 1;
		for (int i=0; i<n; i++)
			for (int j=0; j<=cc; j++)
				for (int s=0; s<(1<<m); s++)
				{
					if (!dp[i][j][s]) continue;
					for (int k=0; k<alphabet; k++) // trans
					{
						int v = tr[j][k];
						dp[i+1][v][s | mark[v]] += dp[i][j][s];
					}
				}
	    ll ans = 0;
	    for (int i=0; i<=cc; i++) ans += dp[n][i][(1<<m)-1];
	    return ans;
	}
	AC(){root = cc = 0;}
}ac;
bool vis[L][N][T], chk[L][N][T];
int mov[L];
bool dfs(int i, int j, int s)
{
	if (i == n)
	{
		vis[i][j][s] = true;
		return chk[i][j][s] = (s == (1<<m)-1);
	}
	if (vis[i][j][s]) return chk[i][j][s];
	vis[i][j][s] = true;
	bool ans = false;
	for (int k=0; k<alphabet; k++)
		ans |= dfs(i+1, ac.tr[j][k], s | ac.mark[ac.tr[j][k]]);
	return chk[i][j][s] = ans;
}
void output(int i, int j, int s)
{
	if (!chk[i][j][s]) return ;
	if (i == n)
	{
		for (int p=1; p<=n; p++) putchar(mov[p] + 'a');
		puts(""); return ;
	}
	for (int k=0; k<alphabet; k++)
	{
		mov[i+1] = k;
		output(i+1, ac.tr[j][k], s | ac.mark[ac.tr[j][k]]);
	}
}
int main()
{
	string tmp; scanf("%d%d", &n, &m);
	for (int i=1; i<=m; i++){cin >> tmp; ac.insert(i-1, tmp);}
	ac.build();
	ll ans = ac.DP();
	printf("%lld\n", ans);
	if (ans > 42) return 0;
	dfs(0, 0, 0); output(0, 0, 0);
	return 0;
}
```

---

## 作者：Nights_watcher (赞：2)

先进行动态规划。考虑 $dp_{i,j,k}$ 表示密码长度为 $i$ 出现过密码的状态为 $j$ 在自动机上节点为 $k$ 的情况密码的个数。转移就非常简单，从 $dp_{i-1,j,k}$ 转移到 $dp_{i,j|state_{nxt_{k,l}},nxt_{k,l}}$。记自动机上有 $tot$ 个节点，最终答案即为 $\sum_{i=0}^{tot}dp_{L,2^n-1,i}$。此时，我们可以得到一半的分数。

如果答案小于等于四十二，则需要进行方案输出。

先进行记忆化搜索，搜索出来每一个状态是否可以到达，用一个数组记录下来。

接下来再进行普通搜索，搜出所有方案即可。

代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 10007;
int n , m;
char c[30];
struct point
{
	int nxt[26] = {} , sp = 0 , state = 0;
}a;
vector <point> tr;
vector <long long> dp[30][1 << 10];
bool f[30][110][1 << 10] , vis[30][110][1 << 10];
string s[15];
void add (int i , const string & s)
{
	int now = 0;
	for (int i = 0;i < s.size ();i ++)
	{
		int x = s[i] - 'a';
		if (! tr[now].nxt[x])
		{
			tr.push_back (a);
			tr[now].nxt[x] = tr.size () - 1;
		}
		now = tr[now].nxt[x];
	}
	tr[now].state |= (1 << (i - 1));
}
queue <int> que;
void fail ()
{
	for (int i = 0;i < 26;i ++)
		if (tr[0].nxt[i]) que.push (tr[0].nxt[i]);
	while (! que.empty ())
	{
		int x = que.front ();
		que.pop ();
		for (int i = 0;i < 26;i ++)
			if (tr[x].nxt[i])
			{
				tr[tr[x].nxt[i]].sp = tr[tr[x].sp].nxt[i];
				tr[tr[x].nxt[i]].state |= tr[tr[tr[x].nxt[i]].sp].state;
				que.push (tr[x].nxt[i]);
			}
			else tr[x].nxt[i] = tr[tr[x].sp].nxt[i];
	}
}
void D ()
{
	dp[0][0][0] = 1;
	for (int i = 1;i <= m;i ++)
	{
		for (int j = 0;j < (1 << n);j ++)
			for (int k = 0;k < tr.size ();k ++) dp[i][j][k] = 0;
		for (int k = 0;k < tr.size ();k ++)
			for (int j = 0;j < (1 << n);j ++)
				for (int l = 0;l < 26;l ++)
					dp[i][j | tr[tr[k].nxt[l]].state][tr[k].nxt[l]] += dp[i - 1][j][k];
	}
}
bool sfd (int i , int j , int k)
{
	if (vis[i][j][k]) return f[i][j][k];
	vis[i][j][k] = 1;
	if (i == m)
	{
		if (k == (1 << n) - 1) f[i][j][k] = 1;
		return f[i][j][k];
	}
	for (int l = 0;l < 26;l ++) f[i][j][k] |= sfd (i + 1 , tr[j].nxt[l] , k | tr[tr[j].nxt[l]].state);
	return f[i][j][k];
}
void dfs (int i , int j , int k)
{
	if (i == m)
	{
		for (int l = 1;l <= i;l ++) cout << c[l];
		cout << "\n";
		return ;
	}
	for (int l = 0;l < 26;l ++)
		if (f[i + 1][tr[j].nxt[l]][(k | tr[tr[j].nxt[l]].state)])
		{
			c[i + 1] = l + 'a';
			dfs (i + 1 , tr[j].nxt[l] , (k | tr[tr[j].nxt[l]].state));
		}
}
signed main ()
{
	tr.push_back (a);
	cin >> m >> n;
	for (int i = 1;i <= n;i ++)
	{
		cin >> s[i];
		add (i , s[i]);
	}
	fail ();
	for (int j = 0;j <= m;j ++)
	for (int i = 0;i < (1 << n);i ++) dp[j][i].resize (tr.size ()) , dp[j][i].resize (tr.size ());
	D ();
	long long he = 0;
	for (int i = 0;i < tr.size ();i ++) he += dp[m][(1 << n) - 1][i];
	cout << he << "\n";
	if (he <= 42)
	{
		sfd (0 , 0 , 0);
		dfs (0 , 0 , 0);
	}
	return 0;
}
```

---

## 作者：Hoks (赞：2)

## 前言
这题还算比较简单的 ACAM+dp 吧，只是输出方案有点折磨了。

广告：[串串博客](https://www.luogu.com.cn/article/dv6dig1o)。
## 思路分析
首先因为是多模匹配，考虑先建出 ACAM，求出 fail 指针。

接着考虑如何处理题目中的计数问题，考虑 dp。

貌似 dp 的空间会炸飞？

发现 $n\le10$，考虑状压。

设计 $dp_{i,j,k}$ 表示已经填了 $i$ 位，ACAM 上跑到了状态 $j$，已用字符串状态为 $k$ 的方案数。

其中 $k$ 的值域即为 $[0,2^n-1]$。

那么再完善下 ACAM 部分，插入一个字符串后在他的结尾打标记表示这个状态包含这个编号的字符串。

那么在求 fail 指针的时候传下 fail 的标记和当前节点的标记或下就行了。

接着考虑下这个 dp 怎么转移，假设枚举到的字符为 $c$，或上当前状态标记后状态为 $k'$。
$$dp_{i,\delta(j,c),k'}=dp_{i,j,k}$$
实际转移的时候累加一下就行了。

因为最后可能停在任何一个位置上，所以要遍历一遍 ACAM 的所有状态累加下答案。

这块都还非常简单，可以先去码一下，交的话是能有 $50$ 分。

接着考虑如何输出方案，考虑 dfs。

在 dfs 是用类似前面 dp 转移时的状态进行跑，并给每个这样的状态打标记代表是否访问与是否可行。

最后再跑一遍输出答案即可。

空间如果不是很紧的话建议多开点防止炸光。
## 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=110,INF=0x3f3f3f3f3f3f3f3f,mod=998244353;
int l,n,m,mx,ans,f[N][N][1024],a[N];char s[N];
bool mp[N][N][1024],ff[N][N][1024];
struct ACAM
{
	struct node{int nxt,ed,mp[26];}t[N*N];int tot=0;
	inline void insert(char s[],int n,int id)
	{
		int u=0;
		for(int i=1;i<=n;i++){if(!t[u].mp[s[i]-'a']) t[u].mp[s[i]-'a']=++tot;u=t[u].mp[s[i]-'a'];}
		t[u].ed|=(1<<id);
	}
	inline void build()
	{
		queue<int>q;
		for(int i=0;i<26;i++) if(t[0].mp[i]) t[t[0].mp[i]].nxt=0,q.push(t[0].mp[i]);
		while(!q.empty())
		{
			int u=q.front();q.pop();t[u].ed|=t[t[u].nxt].ed;
			for(int i=0;i<26;i++)
				if(t[u].mp[i]) t[t[u].mp[i]].nxt=t[t[u].nxt].mp[i],q.push(t[u].mp[i]);
				else t[u].mp[i]=t[t[u].nxt].mp[i];
		}
	}
}ac;
namespace Fast_IO
{
    static char buf[1000000],*paa=buf,*pd=buf;
    #define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
    inline int read()
    {
        int x(0),t(1);char fc(getchar());
        while(!isdigit(fc)&&fc!=-1){if(fc=='-') t=-1;fc=getchar();}
        while(isdigit(fc)&&fc!=-1) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
        if(fc==-1) exit(0);return x*t;
    }
    inline void print(int x)
    {
        if(x<0) putchar('-'),x=-x;
        if(x>9) print(x/10);
        putchar(x%10+'0');
    }
    inline bool chk(char c) { return !(c>='a'&&c<='z'); }
    inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1; }
    inline void rd(char s[],int&n)
    {
        s[++n]=getchar();
        while(chk(s[n])) s[n]=getchar();
        while(ck(s[n])) s[++n]=getchar();
        n--;
    }
}
using namespace Fast_IO;
bool dfs(int x,int y,int z)
{
	if(x==l) return mp[x][y][z]=1,ff[x][y][z]=z==mx;
	bool p=0;if(mp[x][y][z]) return ff[x][y][z];mp[x][y][z]=1;
	for(int i=0;i<26;i++) p|=dfs(x+1,ac.t[y].mp[i],z|ac.t[ac.t[y].mp[i]].ed);
	return ff[x][y][z]=p;
}
void make(int x,int y,int z)
{
	if(!ff[x][y][z]) return ;
	if(x==l)
	{
		for(int i=1;i<=l;i++) putchar(a[i]+'a') ;
		return puts(""),void();
	}
	for(int i=0;i<26;i++) a[x+1]=i,make(x+1,ac.t[y].mp[i],z|ac.t[ac.t[y].mp[i]].ed) ;
}
signed main()
{
	l=read(),n=read();f[0][0][0]=1;mx=(1<<n)-1;
	for(int i=1;i<=n;i++) m=0,rd(s,m),ac.insert(s,m,i-1);ac.build();
	for(int i=0;i<l;i++)
		for(int j=0;j<=ac.tot;j++)
			for(int k=0;k<=mx;k++)
				if(f[i][j][k])
					for(int c=0;c<26;c++)
						f[i+1][ac.t[j].mp[c]][k|ac.t[ac.t[j].mp[c]].ed]+=f[i][j][k];
	for(int i=0;i<=ac.tot;i++) ans+=f[l][i][mx];
	if(ans>42) print(ans);
	else print(ans),puts(""),dfs(0,0,0),make(0,0,0);
	return 0;
}
```

---

## 作者：zhangxy__hp (赞：1)

设 $dp_{i,j,S}$ 表示填了 $i$ 位，在 AC 自动机上的 $j$ 号节点，当前覆盖的字符串集位 $S$ 的方案数。于是有转移：

$$
\large{dp_{i,j,S}\to dp_{i+1,tr_{j,k},S\operatorname{or}sta_{tr_{j,k}}}}
$$

其中 $tr_{j,k}$ 表示 AC 自动机上 $j$ 点加上字符 $k$ 的节点，$sta_j$ 表示以 $j$ 点为结尾的字符串构成的集合，$\operatorname{or}$ 表示按位或。

输出方案，先记忆化搜索确定每个状态 $(i,j,S)$ 能否转移到合法状态，再一遍 dfs 输出即可。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define il inline

using namespace std;
namespace asbt{
namespace cplx{bool begin;}
const int maxn=(1<<10)+5;
int n,m,tr[105][30],tot;
int fail[105],sta[105];
ll dp[30][105][maxn];
bool vis[30][105][maxn];
bool f[30][105][maxn];
char ans[maxn];
string s;
queue<int> q;
il bool dfs1(int i,int j,int S){
	if(vis[i][j][S]){
		return f[i][j][S];
	}
	vis[i][j][S]=1;
	if(i==m){
		return f[i][j][S]=S==(1<<n)-1;
	}
	bool &res=f[i][j][S];
	for(int k=0;k<=25;k++){
		res|=dfs1(i+1,tr[j][k],S|sta[tr[j][k]]);
	}
	return res;
}
il void dfs2(int i,int j,int S){
	if(i==m){
		for(int k=1;k<=m;k++){
			cout<<ans[k];
		}
		cout<<"\n";
		return ;
	}
	for(int k=0;k<=25;k++){
		if(f[i+1][tr[j][k]][S|sta[tr[j][k]]]){
			ans[i+1]=k+'a';
			dfs2(i+1,tr[j][k],S|sta[tr[j][k]]);
		}
	}
}
namespace cplx{
	bool end;
	il double usdmem(){return (&begin-&end)/1048576.0;}
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>m>>n;
	for(int i=1,p;i<=n;i++){
		cin>>s;
		p=0;
		for(int j=0,d;j<s.size();j++){
			d=s[j]-'a';
			if(!tr[p][d]){
				tr[p][d]=++tot;
			}
			p=tr[p][d];
		}
		sta[p]|=1<<(i-1);
	}
	for(int i=0;i<=25;i++){
		if(tr[0][i]){
			q.push(tr[0][i]);
		}
	}
	while(q.size()){
		int u=q.front();
		q.pop();
		for(int i=0;i<=25;i++){
			if(tr[u][i]){
				fail[tr[u][i]]=tr[fail[u]][i];
				sta[tr[u][i]]|=sta[fail[tr[u][i]]];
				q.push(tr[u][i]);
			}
			else{
				tr[u][i]=tr[fail[u]][i];
			}
		}
	}
	dp[0][0][0]=1;
	for(int i=0;i<=m;i++){
		for(int j=0;j<=tot;j++){
			for(int S=0;S<1<<n;S++){
				if(!dp[i][j][S]){
					continue;
				}
				for(int k=0;k<=25;k++){
					dp[i+1][tr[j][k]][S|sta[tr[j][k]]]+=dp[i][j][S];
				}
			}
		}
	}
	ll ans=0;
	for(int i=0;i<=tot;i++){
		ans+=dp[m][i][(1<<n)-1];
	}
	cout<<ans<<"\n";
	if(ans>42){
		return 0;
	}
	dfs1(0,0,0);
	dfs2(0,0,0);
	return 0;
}
}
int main(){return asbt::main();}
```

---

## 作者：Imerance1018 (赞：0)

## Description
[传送门](https://www.luogu.com.cn/problem/P4045)

## Solution

看到多个字符串，先把 AC 自动机建出来。发现 $n$ 很小，考虑对 $n$ 进行状压，标准的 AC 自动机上 DP。

套路地定义 $f_{i,j,S}$ 表示走到 AC 自动机上节点 $i$，已填字符串长度为 $j$，表示包含字符串集合的二进制数为 $S$ 的方案数。使用刷表法，枚举下一步填哪个字母进行转移。

需要在 AC 自动机上处理出走到第 $i$ 个节点时新包含了哪些字符串，显然为 fail 树上该节点所有祖先节点的状态按位或的结果，对 fail 树进行一遍 dfs 即可。

由于答案还要输出方案，可以先 dfs 处理出所有最后对答案有贡献（即能直接或间接转移到满足 $j=L$ 且 $S=2^n-1$ 的状态）的状态，然后递归输出答案。将字母从小到大选择即可解决字典序的问题。

时空复杂度 $O(L\sum \left| s_i \right|2^n)$。

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=110;


namespace ACAM
{
    struct node
    {
        int son[26],fail,cnt;
        node(){memset(son,0,sizeof(son));fail=cnt=0;}
    }t[N];
    int tot,idx;
    int q[N],head,tail;
    vector<int>G[N];

    void init(){tot=0;head=1,tail=0;}
    void insert(string x,int idx)
    {
        int u=0;
        for(int i=0;i<(int)x.size();i++)
        {
            int &v=t[u].son[x[i]-'a'];
            if(!v)v=++tot;
            u=v;
        }
        t[u].cnt|=(1<<(idx-1));
    }
    void build()
    {
        for(int i=0;i<26;i++)
        {
            int v=t[0].son[i];
            if(!v)continue;
            q[++tail]=v;
            G[0].emplace_back(v);
        }
        while(head<=tail)
        {
            int u=q[head++];
            for(int i=0;i<26;i++)
            {
                int &v=t[u].son[i],f=t[t[u].fail].son[i];
                if(v)
                {
                    t[v].fail=f;
                    G[f].emplace_back(v);
                    q[++tail]=v;
                }
                else v=f;
            }
        }
    }
    void dfs(int x)
    {
        for(auto y:G[x])
        {
            t[y].cnt|=t[x].cnt;
            dfs(y);
        }
    }
};
using namespace ACAM;

int n,L;
int f[110][26][1<<10];
bool vis[110][26][1<<10],pd[110][26][1<<10];
void make_tag(int x,int y,int z)
{
    if(!f[x][y][z]||pd[x][y][z]==1)return;
    pd[x][y][z]=1;
    if(y==L)
    {
        vis[x][y][z]=(z==(1<<n)-1);
        return;
    }
    for(int l=0;l<26;l++)
    {
        int nxt=t[x].son[l];
        make_tag(nxt,y+1,z|t[nxt].cnt);
        vis[x][y][z]|=vis[nxt][y+1][z|t[nxt].cnt];
    }
}
void solve(int x,int y,int z,string res)
{
    if(!vis[x][y][z])return;
    if(y==L)
    {
        cout<<res<<"\n";
        return;
    }
    for(int l=0;l<26;l++)
    {
        int nxt=t[x].son[l];
        solve(nxt,y+1,z|t[nxt].cnt,res+(char)(l+'a'));
    }
}
signed main()
{
    init();
    cin>>L>>n;
    for(int i=1;i<=n;i++)
    {
        string x;
        cin>>x;
        insert(x,i);
    }
    build();
    dfs(0);
    f[0][0][0]=1;
    for(int j=0;j<L;j++)
        for(int i=0;i<(1<<n);i++)
            for(int k=0;k<=tot;k++)
            {
                if(!f[k][j][i])continue;
                for(int l=0;l<26;l++)
                {
                    int nxt=t[k].son[l];
                    f[nxt][j+1][i|t[nxt].cnt]+=f[k][j][i];
                }
            }
    int sum=0;
    for(int i=0;i<=tot;i++)sum+=f[i][L][(1<<n)-1];
    cout<<sum<<"\n";
    if(sum>42)return 0;
    make_tag(0,0,0);
    solve(0,0,0,"");
    return 0;
}
······
``````

---

## 作者：xuanfeng101 (赞：0)

## 题解
首先，看到题目数据范围很小，不难想到**状态压缩**。有一个朴素的想法就是设 $f_{i, j, s}$ 表示当前进行到第 $i$ 个数，前十个字母状态为 $j$，已经匹配的子串集合为 $s$。这个时候转移是顺理成章的，但是状态 $j$ 的**时空复杂度**都很高，导致三维状态时空复杂度很高。所以，这个时候我们要想着将 $j$ 降维，那么对于字符串的题无非就那几种方法，这里我们可以用 **AC** **自动机**这个利器，它常常很方便用于这种**需要出现关键词**的状态转移，那么此时我们就设 $j$ 表示在自动机上的位置，然后有转移：
$$
  f_{i, tr_{j, k}, s | st_{tr_{j, k}}} = f_{i, tr_{j, k}, s | st_{tr_{j, k}}} + f_{i, j, k}
$$
其中 $tr_{j, k}$ 数组表示的是 $\operatorname{trie}$ 图上的边，$st_{i}$ 表示的是节点 $i$ 的可以满足的点集合。



所以说我们只要建立出自动机，然后枚举状态刷表即可。但是本题很毒瘤的是它还要输出状态，所以说我们还要先进行**记忆化搜索**，找出所有**合法状态**，然后再暴搜一遍，根据合法状态转移输出方案。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 30;
int n, m;
int tr[N * 15][26], ne[N * 15], idx;
int q[N * 15];
int st[N * 15];
bool vis[N][N * 15][1 << 10];
int f[N][N * 15][1 << 10], g[N][N * 15][1 << 10];
char s[N], ans[45];


void insert(int pos, char s[])
{
    int p = 0;
    for (int i = 1; s[i]; i ++ )
    {
        int& t = tr[p][s[i] - 'a'];
        if (!t) t = ++ idx;
        p = t;
    }
    st[p] |= 1 << pos;
}

void build()
{
    int tt = -1, hh = 0;
    for (int i = 0; i < 26; i ++ ) if (tr[0][i]) q[ ++ tt] = tr[0][i];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = 0; i < 26; i ++ )
        {
            int& p = tr[t][i];
            if (!p) p = tr[ne[t]][i];
            else 
            {
                ne[p] = tr[ne[t]][i];
                st[p] |= st[ne[p]];
                q[ ++ tt] = p;
            }
        }
    }
}

bool dfs(int i, int j, int state) 
{
    if (vis[i][j][state]) return g[i][j][state];
    vis[i][j][state] = true;
    if (i == n) return g[i][j][state] = (state == (1 << m) - 1);
    for (int k = 0; k < 26; k++) 
    {
        int nj = tr[j][k];
        int ns = state | st[nj];
        g[i][j][state] |= dfs(i + 1, nj, ns);
    }
    return g[i][j][state];
}

void dfs2(int i, int j, int state) 
{
    if (i == n) 
    {
        for (int i = 1; i <= n; i ++ ) cout << ans[i];
        cout << endl;
        return;
    }
    for (int k = 0; k < 26; k ++ ) 
    {
        int nj = tr[j][k];
        int ns = state | st[nj];
        if (g[i + 1][nj][ns]) 
        {
            ans[i + 1] = k + 'a';
            dfs2(i + 1, nj, ns);
        }
    }
}

signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n >> m;
    for (int i = 0; i < m; i ++ )
    {
        cin >> s + 1;
        insert(i, s);
    }

    build();

    f[0][0][0] = 1;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j <= idx; j ++ )
            for (int s = 0; s < (1 << m); s ++ )
                if (f[i][j][s])
                    for (int k = 0; k < 26; k ++ )
                        f[i + 1][tr[j][k]][s | st[tr[j][k]]] += f[i][j][s];
    int res = 0;
    for (int i = 0; i <= idx; i ++ ) res += f[n][i][(1 << m) - 1];
    cout << res << endl;
    if (res <= 42) dfs(0, 0, 0), dfs2(0, 0, 0);
    return 0;
}
```

---


# [JSOI2007] 文本生成器

## 题目描述

JSOI 交给队员 ZYX 一个任务，编制一个称之为“文本生成器”的电脑软件：该软件的使用者是一些低幼人群，他们现在使用的是 GW 文本生成器 v6 版。

该软件可以随机生成一些文章——总是生成一篇长度固定且完全随机的文章。 也就是说，生成的文章中每个字符都是完全随机的。如果一篇文章中至少包含使用者们了解的一个单词，那么我们说这篇文章是可读的（我们称文章 $s$ 包含单词 $t$，当且仅当单词 $t$ 是文章 $s$ 的子串）。但是，即使按照这样的标准，使用者现在使用的 GW 文本生成器 v6 版所生成的文章也是几乎完全不可读的。ZYX 需要指出 GW 文本生成器 v6 生成的所有文本中，可读文本的数量，以便能够成功获得 v7 更新版。你能帮助他吗？

答案对 $10^4 + 7$ 取模。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq n \leq 60$，$1 \leq m \leq 100$。
- $1 \leq |s_i| \leq 100$，其中 $|s_i|$ 表示字符串 $s_i$ 的长度。
- $s_i$ 中只含大写英文字母。

## 样例 #1

### 输入

```
2 2
A
B
```

### 输出

```
100```

# 题解

## 作者：Refun (赞：42)

第一次做在AC自动机上跑DP的题……

之前做的好像都是乱搞

学长说AC自动机的DP都非常套路

大部分f[i][j]表示当前在节点j,且串长为i时的情况，

有时再加一维表示这个状态里面包含了哪些东西

而且AC自动机的DP会经常让你用矩阵乘法优化

 
那么对于这个题，我们可以先将AC自动机建立出来，然后搞一个简单的容斥

用所有的情况减去不可读的情况。

那么那些是不可读的情况呢？当然就是跑不到单词结尾节点的情况喽……

定义f[i][j]表示当前在j点且串长为i时不经过单词结尾的路径条数

然后从父亲往儿子转移即可

注意如果一个单词的后缀是一个可读单词(即fail指针指向可读单词的结尾节点)

那么这个单词一定也是可读的，我们就不能往这个单词走了

话说之前我好像做过类似的不过没有吸取教训QvQ活该WA好久

[代码](http://www.cnblogs.com/refun/p/8706911.html)

---

## 作者：AThousandSuns (赞：34)

在我的博客上看效果更佳：[点这里](https://www.cnblogs.com/1000Suns/p/10351847.html)

---
第一道在AC自动机上DP的题，纪念纪念。

首先可以发现答案就是所有串的个数减去不包含可读串的串的个数。

前半部分是 $26^m$。后半部分使用DP求解。

首先建出可读串的AC自动机。

令 $dp[i][j]$ 表示串长为 $i$，在AC自动机上走到编号为 $j$ 的节点的合法串个数。

如果走到 $j$ 的儿子 $k$ 这个节点的串合法，那么就可以从 $(i,j)$ 转移到 $(i+1,ch[j][k])$。

$dp[i+1][ch[j][k]]+=dp[i][j](0\le k<26)$

初始状态 $dp[0][0]=1$。答案为所有 $dp[m][i]$ 的最大值。

可能看到这里，你最大的疑问就是：如何判断走到点 $j$ 的串是否合法？真的可行吗？

想一想在AC自动机的fail的性质。我们就可以发现：如果从点 $j$ 不停沿fail往上跳，经过的所有点（包括 $j$）没有串尾的节点，那么 $j$ 合法，否则不合法。

这个合法性可以在BFS求fail时顺带求出。

（仔细想一想在AC自动机上跑匹配的本质就明白了）

时间复杂度 $O(m\sum|S|)$，空间复杂度 $O(\sum|S|)$，全都带一个 $26$ 的常数。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=10007;
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define ROF(i,a,b) for(int i=(a);i>=(b);i--)
#define MEM(x,v) memset(x,v,sizeof(x))
inline int read(){
    char ch=getchar();int x=0,f=0;
    while(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();
    while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    return f?-x:x;
}
int n,m,cnt,q[6666],h,r,ch[6666][26],dp[111][6666],fail[6666];
bool war[6666];    //war表示节点是否不合法（不合法！不合法！）
char str[111];
void insert(char str[],int len){
    int now=0;
    FOR(i,1,len){
        int p=str[i]-'A';
        if(!ch[now][p]) ch[now][p]=++cnt;
        now=ch[now][p];
    }
    war[now]=true;    //串尾不合法
}
void build(){
    h=1;r=0;
    FOR(i,0,25) if(ch[0][i]) q[++r]=ch[0][i];
    while(h<=r){
        int u=q[h++];
        FOR(i,0,25) if(ch[u][i]){
            fail[ch[u][i]]=ch[fail[u]][i];
            war[ch[u][i]]|=war[fail[ch[u][i]]];
            //如果fail不合法，自己也不合法
            q[++r]=ch[u][i];
        }
        else ch[u][i]=ch[fail[u]][i];
    }
}
int qpow(int a,int b){
    int ans=1;
    for(;b;b>>=1,a=a*a%mod) if(b&1) ans=ans*a%mod;
    return ans;
}
int main(){
    n=read();m=read();
    FOR(i,1,n) scanf("%s",str+1),insert(str,strlen(str+1));
    build();
    dp[0][0]=1;
    FOR(i,0,m-1) FOR(j,0,cnt) FOR(k,0,25)
        if(!war[ch[j][k]]) dp[i+1][ch[j][k]]=(dp[i+1][ch[j][k]]+dp[i][j])%mod;
        //ch[j][k]合法，可以转移
    int ans=qpow(26,m);
    FOR(i,0,cnt) ans=(ans-dp[m][i]+mod)%mod;    //容斥一下
    printf("%d\n",ans);    //答案
}
```

---

## 作者：George1123 (赞：27)

**博客中文章：[题解-\[JSOI2007\]文本生成器](https://blog.csdn.net/KonnyWen/article/details/104238511)**

### [\[JSOI2007\]文本生成器](https://www.luogu.com.cn/problem/P4052)
**这题就是那种著名的AC自动机+dp题，算法唯一，如果你不会AC自动机，出门左转[\[传送门\]](https://blog.csdn.net/KonnyWen/article/details/104226807)。**

这题当中的那些单词就相当于AC自动机模板中的模式串，只不过这题当中是要求满足“包含至少一个模式串的”文本串而已。

所以先把模式串放到 $\texttt{trie}$ 树上，然后用AC自动机的 $\texttt{build()}$ 函数把 $fail$ 指针构造出来，并把 $ch[][]$ 数组进化为一条永通路，以便避免文本串匹配时一个模式串到结尾了没有地方可走的尴尬。

**以上都是对模板的解说。** 对于这题，我们发现“包含至少一个”这样的约束条件，就想到 **答案$=$整体$-$剩余**，先求出一个模式串都不包含的文本串数，然后求出没有约束条件下文本串有 $26^m$ 种，就可以得出答案。

因为要求一个模式串都不包含的文本串数，所以 $\texttt{insert(s)}$ 的时候在有字符串结尾的节点 $x$ 上注 $mk[x]=1$，如下：

```cpp
void insert(char*s){
	int n=strlen(s+1),p=1;
	for(int i=1;i<=n;i++){
		int c=s[i]-'A'+1;
		if(!ch[p][c]) ch[p][c]=++cnt;
		p=ch[p][c];
	}
	mk[p]=1;
}
```
又因为如果一个字符串的后缀是模式串，那么它也不能出现在文本串中，所以在构造AC自动机 $fail$ 指针的时候要令 $mk[x]|=mk[fail[x]]$，如下：

```cpp
void build(){
	for(int i=1;i<=26;i++) ch[0][i]=1;
	queue<int> q;while(q.size()) q.pop();q.push(1);
	while(q.size()){
		int x=q.front();q.pop();
		for(int c=1;c<=26;c++)
			if(ch[x][c]) fa[ch[x][c]]=ch[fa[x]][c],mk[ch[x][c]]
				|=mk[fa[ch[x][c]]],q.push(ch[x][c]);
			else ch[x][c]=ch[fa[x]][c];
	}
}
```

因为这题的文本串没有实体，不能通过AC自动机上 $fail$ 指针一跳完事，所以根据AC自动机dp。**设 $dp[i][j]$ 表示长度为 $i$ 且后缀字符为AC自动机上节点 $j$ 的文本串数量**，又文本串中不能出现模式串，所以有转移方程：

```cpp
for(int i=1;i<=m;i++)
	for(int j=1;j<=t.cnt;j++)//全点参与
		for(int c=1;c<=26;c++) //沿着子节点生成文本串下一个字母
			if(!t.mk[t.ch[j][c]])  //避开模式串
				dp[i][t.ch[j][c]]=(dp[i][t.ch[j][c]]+dp[i-1][j])%mod;
```
如果AC自动机节点数为 $cnt$，那么一个模式串都不包含的文本串数就为 $\sum\limits_{i=1}^{cnt}dp[m][i]$，所以答案就是：

$$(26^m-\sum\limits_{i=1}^{cnt}dp[m][i])\mod 10007$$

因为模数小，只有 $10007$，所以不必开 $\texttt{long long}$，但如果你忘记取模了，$\texttt{long long}$ 也救不了你。如果你懂了，那么蒟蒻就放代码了：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=70;
const int M=110;
const int mod=1e4+7;
class Trie{
public:
	int ch[N*M][30],cnt;
	bool mk[N*M];
	Trie(){cnt=1;}
	void insert(char*s){
		int n=strlen(s+1),p=1;
		for(int i=1;i<=n;i++){
			int c=s[i]-'A'+1;
			if(!ch[p][c]) ch[p][c]=++cnt;
			p=ch[p][c];
		}
		mk[p]=1;
	}
};
class Acam:public Trie{
public:
	int fa[N*M];
	void build(){
		for(int i=1;i<=26;i++) ch[0][i]=1;
		queue<int> q;while(q.size()) q.pop();q.push(1);
		while(q.size()){
			int x=q.front();q.pop();
			for(int c=1;c<=26;c++)
				if(ch[x][c]) fa[ch[x][c]]=ch[fa[x]][c],mk[ch[x][c]]
					|=mk[fa[ch[x][c]]],q.push(ch[x][c]);
				else ch[x][c]=ch[fa[x]][c];
		}
	}
}t;
int n,m,dp[M][N*M],ans=1;
char s[M];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%s",s+1),t.insert(s);
	t.build();
	dp[0][1]=1;
	for(int i=1;i<=m;i++) for(int j=1;j<=t.cnt;j++)
		for(int c=1;c<=26;c++) if(!t.mk[t.ch[j][c]]) 
			dp[i][t.ch[j][c]]=(dp[i][t.ch[j][c]]+dp[i-1][j])%mod;
	for(int i=m,j=26;i;j=(j*j)%mod,i>>=1)
		if(i&1) ans=(ans*j)%mod;
	for(int i=1;i<=t.cnt;i++) ans=(ans-dp[m][i]+mod)%mod;
	printf("%d\n",ans);
	return 0;
}
```
后续学习推荐题目：

[\[NOI2011\]阿狸的打字机](https://www.luogu.com.cn/problem/P2414)

[\[SDOI2014\]数数](https://www.luogu.com.cn/problem/P3311)

[\[JSOI2009\]密码](https://www.luogu.com.cn/problem/P4045)

**祝大家学习愉快！**



---

## 作者：kkksx (赞：15)

## 题意

给定一些模式串，求长度为m的所有文本串的个数，且该文本串至少包括一个模式串，答案对10007取模

## 思路

//没有调用get_fail()调了一个小时我怕不是神仙....

看到一堆字符串的匹配问题，首先就可以考虑自动机全家桶了......~~很容易~~发现用AC自动机看起来可做

对所有串建AC自动机，然后变成trie图，一个文本串只要包括了一个end标记就说明包括至少一个串。在图上这样的统计问题，容易想到是dp

于是大多数题解到这里就运用了一个经典的四字成语

## 正难则反

~~才怪~~

虽然正难则反（所有串-不包含任一个的串）可做，但是按照正常的思路来说，则反首先要正难，然而它并不难......对于我这个蒟蒻来说很难就此想到反推（个人认为否定正着做会误导萌新比如本人）

用f[ i ][ j ][0 / 1]表示到了i号点，当前字符串长度为j，是否经过过有标记的点，这样的总方案数，那么最终的答案就为sigma( f[ 0 ~ ndsum ][ m ][ 1 ] )。

这样递推也是相当简单的，为了保证前一位先被求出来，所以外层循环先枚举字符串长度j

```cpp
if(is_end[now])//是终点就没有0状态 
{
	f[now][i][1]=(f[now][i][1]+f[j][i-1][0]+f[j][i-1][1])%mod;
}
else//不是终点 
{
	f[now][i][0]=(f[now][i][0]+f[j][i-1][0])%mod;
	f[now][i][1]=(f[now][i][1]+f[j][i-1][1])%mod;
	//f[now][i][1]不从f[j][i-1][0]转化过来qwq 
}
```

再加入AC自动机模板即可轻松切掉（）

Code：

```cpp
#include<bits/stdc++.h>
#define N 6100
using namespace std;
const int mod = 10007;
int n,m;
int nxt[N][26],fail[N],is_end[N],ndsum;
int f[N][105][2];//走了j步走到了i点,是否有经过单词 
char s[N];
void ad(char c[])
{
	int now=0,len=strlen(c);
	for(int i=0;i<len;++i)
	{
		int p=c[i]-'A';
		if(!nxt[now][p]) nxt[now][p]=++ndsum;
		now=nxt[now][p];
	}
	is_end[now]=1;
}
void get_fail()
{
	queue<int> q;
	for(int i=0;i<26;++i) if(nxt[0][i]) q.push(nxt[0][i]);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int j=0;j<26;++j)
		{
			if(nxt[u][j])
			{
				q.push(nxt[u][j]);
				fail[nxt[u][j]]=nxt[fail[u]][j];
				is_end[nxt[u][j]]|=is_end[nxt[fail[u]][j]];
			}
			else nxt[u][j]=nxt[fail[u]][j];
		}
	}
}
void dp()
{
	f[0][0][0]=1;
	for(int i=1;i<=m;++i)//step
	{
		for(int j=0;j<=ndsum;++j)//node
		{
			for(int k=0;k<26;++k)//next
			{
				int now=nxt[j][k];
				if(is_end[now])//是终点就没有0状态 
				{
					f[now][i][1]=(f[now][i][1]+f[j][i-1][0]+f[j][i-1][1])%mod;
				}
				else//不是终点 
				{
					f[now][i][0]=(f[now][i][0]+f[j][i-1][0])%mod;
					f[now][i][1]=(f[now][i][1]+f[j][i-1][1])%mod;
					//f[now][i][1]不从f[j][i-1][0]转化过来qwq 
				}
			}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		scanf("%s",s);
		ad(s);
	}
	get_fail();
	dp();
	int ans=0;
	for(int i=0;i<=ndsum;++i) ans=(ans+f[i][m][1])%mod;
	printf("%d\n",ans);
	return 0;
}
```

（当然这道题f的第二维显然是可以滚掉的2333）

---

## 作者：Qura (赞：15)


**问题一** 假设只有一个单词，怎么做？

对单词左个KMP, 设$F[i,j]$为已构成长度为$i$,单词匹配到位置$j$的,且没有一次匹配完全的方案数.显然,转移方程是:

$F[i,j] \rightarrow F[i+1,j\text{或者其FAIL链的某个位置}+1]$


最终答案为$26^m-F[m,*]$.(很显然的补集转化)

**问题二** 现在有很多个单词, 怎么做?

多个单词的做法, 把单词们做成Trie图, 方程也就变成:

$F[i,j] \rightarrow F[i+1,Trie[j].ch[c]]$

(j此时代表 Trie图 上的一个节点, 匹配完全指的就是经过带有end标记的节点.)
	
~~诶,不跳FAIL链啦?~~ 笨,**Tire图**已经把这个过程优化掉了了.在标准的ACAM里,如果当前节点存在儿子c,直接转移过去; 不然,就得条FAIL链.**但是**,咱不是有这样一句话吗?
	
```cpp
at void build():
	if(!Trie[x].ch[i]) Trie[x].ch[i]=Tire[Trie[x].fail].ch[i];
```
	
巧妙吧?

**注意** 若一个点的 FAIL链 里存在某个单词的 end标记 ,显然这个点是GG的.
 (这个点代表一个字串, FAIL链 上的点代表的字串这个字串的后缀) 这个性质太有用了.

代码补贴了.



---

## 作者：StudyingFather (赞：12)

合法的情况总数并不好求，考虑求出不合法的情况（即不存在一个子串等于模式串），最后用总数减去即可。

因为是多模式串匹配问题，考虑在 AC 自动机上求解。

设 $f(i,j)$ 表示当前准备匹配第 $i$ 个字符，且当前在 AC 自动机上的 $j$ 节点时，不合法的方案总数。

怎么转移？不能经过哪些节点？

显然终止节点是不能经过的。除此之外呢？注意到我们的匹配过程会不停地跳 fail 指针，因此如果一个节点能通过跳若干次 fail 指针到达一个终止节点，则该点也是不能经过的。

求所有不能经过节点的工作，可以在求 fail 指针的时候顺便完成。

```cpp
// Problem : P4052 [JSOI2007]文本生成器
// Contest : Luogu
// URL : https://www.luogu.com.cn/problem/P4052
// Memory Limit : 125 MB
// Time Limit : 1000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <iostream>
#include <string>
#include <queue>
#define MOD 10007
using namespace std;
const int sigma=26;
int tr[6005][sigma],fail[6005],cnt;
int vis[6005];
int f[105][6005];
int fpow(int x,int y)
{
 int ans=1;
 while(y--)
  ans=ans*x%MOD;
 return ans;
}
void insert(string s)
{
 int u=0;
 for(auto c:s)
 {
  if(!tr[u][c-'A'])
   tr[u][c-'A']=++cnt;
  u=tr[u][c-'A'];
 }
 vis[u]=1;
}
void build()
{
 queue<int> q;
 for(int i=0;i<sigma;i++)
  if(tr[0][i])q.push(tr[0][i]);
 while(!q.empty())
 {
  int u=q.front();
  q.pop();
  for(int i=0;i<sigma;i++)
  {
   if(tr[u][i])
   {
    fail[tr[u][i]]=tr[fail[u]][i];
    vis[tr[u][i]]|=vis[fail[tr[u][i]]];
    q.push(tr[u][i]);
   }
   else
    tr[u][i]=tr[fail[u]][i];
  }
 }
}
int main()
{
 int n,m;
 cin>>n>>m;
 int ans=fpow(26,m);
 for(int i=1;i<=n;i++)
 {
  string s;
  cin>>s;
  insert(s);
 }
 build();
 f[0][0]=1;
 for(int i=0;i<m;i++)
  for(int j=0;j<=cnt;j++)
   for(int k=0;k<sigma;k++)
    if(!vis[tr[j][k]])
     f[i+1][tr[j][k]]=(f[i+1][tr[j][k]]+f[i][j])%MOD;
 for(int i=0;i<=cnt;i++)
  ans=(ans-f[m][i]+MOD)%MOD;
 cout<<ans<<endl;
 return 0;
}
```

---

## 作者：MuYC (赞：10)

这道题，人人都说是AC自动机上dp的套路板子，但是他们给的分析蒟蒻死活也听不明白(可能是初学的缘故.......)

好久终于搞懂了，写了这篇题解想造福跟我一样的同胞(~~应该只有我一个人这么菜......~~)

#### 题意简化　：
给你$n$个模式串，你需要生成一个长度为$m$的字符串使得至少一个模式串可以匹配成功，问可行的生成方案总数对10007取模。

多串匹配，计数，是dp + AC自动机.....(这里还是蛮显然的)

但是怎么做?

#### 思路
什么样的字符串使得至少一个模式串可以匹配？这个东西太难处理了。

正难则反 --------- OI中的著名四字成语

不妨转化为求没有一个模式串可以匹配成功的方案数为$sum$。(补集转换)

然后不含一个模式串的字符串的方案就是$26^m - sum$

首先用$n$个模式串模式串建立一个AC自动机

##### 思考什么时候会有一个文本串使得没有一个模式串可以匹配成功？

```cpp
//这是AC自动机进行匹配的代码。
//这段函数将会输出有多少个模式串与文本串匹配成功
void GetAns()
{
	int len = strlen(a),now = 0 , ans = 0;
	for(int i = 0 ; i < len  ; i ++)
	{
		int num = a[i] - 'a';
		now = AC[now].son[num];
		for(int u = now ; AC[u].end != -1 && u ; u = AC[u].Fail)
		{
			ans += AC[u].end;
			AC[u].end = -1;
		}
	}
	cout << ans << endl;
	return ;
}
```
观察ＡＣ自动机获取答案的过程，我们发现:

访问到一个文本串里面的节点，我们就会不停的跳这个点的$Fail$，这个点的$Fail$的$Fail$ .......(这个就被称为$Fail$链)，直到跳到根或者是答案已经被计算过的点(已经被跳过了，再往下跳就重复了)。

然后答案累加上以跳到的点为结尾的模式串的个数。

假设$i$的$Fail$指针指向点$j$，根据$Fail$指针的定义就为：Ｔｒｉｅ上根节点到$j$的路径形成的字符串是Ｔｒｉｅ上根节点到$i$的路径形成的字符串的后缀

那么这样子答案是显然可行的.

那么我们要让答案为0，怎么办?

那就是当前点以及跳到的点上，没有任何一个模式串以它们为结尾，我们要选的点是这些，至于其他的点，我们则要"避开"。

#### 考虑如何DP

根据套路(没办法，套路还是得知道一下的)，ＡＣ自动机上的ＤＰ一般状态的设置是这样子的: $DP[i][j]$ <-----　表示AC自动机上走$i$步且最后走的一个是$j$的答案

根据上面的分析$DP[i][k] $就要累加上 $DP[i - 1][j]$ ($k$是$j$的儿子，同时满足$j$没有一个模式串以其$Fail$链上的点(包括$j$)为结尾)

最后，统计出来所有的答案$\sum_{i = 0}^{i = cnt} {DP[m][i]}也就是以ＡＣ自动机上任意一个节点为"j"的答案，同时文本要求长度为m$

答案就是$(26^m - sum)$   $mod$   $10007$

至此结束.

注意一下模意义下减法要加上$Mod$防止变成负数,详见代码。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,cnt = 0;
const int MAXN = 6005,MAXM = 105,Mod = 10007;//常量赋值
char s[1005];//给定的模式串用这个存
struct node{
	int end,Fail;
	int son[26];
}AC[MAXN];//AC自动机
int vis[MAXN];//建立Fail指针的时候要用的东西
int f[MAXM][MAXN];//DP数组
void build()
{
	int len = strlen(s),now = 0;
	for(int i = 0 ; i < len ; i ++)
	{
		int num = s[i] - 'A';
		if(AC[now].son[num] == 0)
			AC[now].son[num] = ++cnt;
		now = AC[now].son[num];
	}
	AC[now].end = 1;
}//建立AC自动机

void GetFail()
{
	int now = 0 , head = 0 , tail = 0;
	for(int i = 0 ; i < 26 ; i ++)
		if(AC[0].son[i])
			tail ++ , vis[tail] = AC[0].son[i];
	while(head < tail)
	{
		head ++;
		int v = vis[head];
		for(int i = 0 ; i < 26 ; i ++)
		{
			if(AC[v].son[i])
			{
				AC[AC[v].son[i]].Fail = AC[AC[v].Fail].son[i];
				tail ++;
				vis[tail] = AC[v].son[i];//普通的建立AC自动机即可
				AC[AC[v].son[i]].end |= AC[AC[AC[v].son[i]].Fail].end;//这里运用了或运算来求出Fail链上是否有一个点为模式串的结尾
			}
			else AC[v].son[i] = AC[AC[v].Fail].son[i];
		}
	}
	return ;
}

int quick_power(int x,int y){
	int ans = 1 , op = x;
	if(y == 2)return x*x;
	if(x == 0)return 0;
	while(y){
		if(y % 2 == 1)ans *= op , ans %= Mod;
		op *= op , op %= Mod;
		y = y >> 1;
	}
	return ans % Mod;
}

void DP()
{
	f[0][0] = 1;
	for(int i = 1 ; i <= m ; i ++)
		for(int j = 0 ; j <= cnt ; j ++)
			if(!AC[j].end)//我们显然不能对不合法的点进行动态规划
			{
				for(int k = 0 ; k < 26 ; k ++)
				f[i][AC[j].son[k]] =( f[i][AC[j].son[k]] + f[i - 1][j] )% Mod;
			}
	int ans = 0;
	for(int j = 0 ; j <= cnt ; j ++)
		if(!AC[j].end)ans += f[m][j],ans %= Mod;
	cout <<(quick_power(26,m) - ans + Mod )% Mod;//这里要加上Mod，不然会死
}

int main()
{
	cin >> n >> m;
	for(int i = 1 ; i <= n ; i ++)
	{
		cin >> s;
		build();
	}
	GetFail();//这里是进行建Fail的
	DP();//这里是进行DP的
	return 0;
}
```

---

## 作者：jacktang (赞：9)

以下是吐槽，可以跳过。
---
刚开始看题的时候，嗯。。这不和[HNOI2008]GT考试一模一样吗，就是把kmp换成了ac自动机，（反正ac自动机就是放大版的kmp嘛）。
然后信心百倍的开始敲代码，自信的运行程序，咦，怎么连样例都过不了，然后发现不对啊，如果只考虑dp转移的最后状态，那中间的合格的字符串怎么统计呢。。
嗯，经过一些思考，哦，我们可以在最后考虑不合格的嘛，转移中间遇到合格的跳过不转移就好了。。嗯，感觉很正确。。
然后在自信一波操作，咦，怎么还是过不了样例啊。。
哦，循环队列忘了清空。。
咦，我好像过了样例，嗯，自信交一交。
啊，怎么只有三十分啊。。
嗯，下不了数据。。找一个标程拍一拍。。
嗯，这个标程怎么不太对啊，纳尼，这标程怎么过不了样例啊。
再见。
然后再找了一份标程经过各种对拍终于还是拍出来了啊。。。
我天真的以为当前节点是单词结尾跳过就好了，结果对拍着才发现：咦，这个节点以上的万一有合格的单词怎么办呢。。嗯，可以像AC自动机模板（具体见[LuoguP3838](https://www.luogu.org/problemnew/show/P3808)）那样一直跳fail嘛，然后统计cnt，如果cnt>0的话不就说明上面有吗，嗯，我真聪明。
最后终于A了，蒟蒻还是很激动的。。。
结果一看题解，原来AC自动机上DP是有套路的啊。。。一口老血差点喷出来。

![image](http://img.itlun.cn/uploads/allimg/160617/1-16061G42141.jpg)

不过我的做法和他们不太一样（毕竟我要慢一些啊！！），我就寻思写篇题解吧，不然对不起自己做了这么久。。。

---

所以对于我的做法，主要有三点。

## 1.初始化辅助数组 g[j][k]。

所以类似于kmp上的dp,（或者有点类似dp套dp）

我们可以用一个转移数组g[j][k]表示
**编号为j的节点的下一个字母填k会转移到的最长字符串的结尾的点的编号**   。

嗯，我知道你们肯定不知所云，其实就是沿着fail指针往上跳的第一个匹配到的点。。

转移数组的构造很简单，具体看代码。
```cpp
inline void init(int now){
	if(get(now)) vis[now]=true;//关于合格的字符串的限制，第二点要讲。
	for(int i=0;i<26;++i){
		int u=now;
		while(!tree[u].ch[i] && u) u=tree[u].fail;
		g[now][i]=tree[u].ch[i];
	}
	for(int i=0;i<26;++i){
		int v=tree[now].ch[i];
		if(!v) continue;
		init(v);
	}
}
```

## 2.限制。（vis[i]）

因为直接统计合格的个数不好统计，我们就反向考虑，用总方案数 pow(26,m)减去不合格的方案数就好了。

不合格的方案数可以在转移过程中判断，如果有限制就不转移，所以就很好统计。

至于一个点是否有限制，想一想AC自动机求出现过的串的个数的方法，就是一个get()函数嘛。。然后我就原封不动的搬了过来。（逃。

如果求出来的个数大于0就说明匹配到当前节点时已经有单词出现过了，就把这个节点的vis赋值为true。表示有限制，状态转移时就不转移。

```cpp
inline int get(int now){
	int res=0;
	for(int i=now;i;i=tree[i].fail){
		if(tree[i].cnt) res+=tree[i].cnt;
	}
	return res;
}
```


## 3.状态转移。f[cur][j]

因为文本的每一位在A-Z中随便选，没有限制，所以可以把构造这个文本看做状态的转移，每次的转移都是一样的，所以一个转移数组能够代表每次转移的情况。然后转移m次就好了。（往往有题把n出小一点，然后m非常大，就可以套一个矩阵快速幂）。

f[cur][j]表示**转移到第cur步（滚动数组优化）以j结尾的不合格的方案数**。

我觉得这么一说就很裸了。。dp转移的常规套路,毕竟转移数组都求出来了。

```cpp
int cur=1;
f[cur][0]=1;
for(int i=1;i<=m;++i){
	cur^=1;	
	memset(f[cur],0,sizeof f[cur]);	
	for(int j=0;j<=idx;++j){
		if(vis[j]) continue;
		for(int k=0;k<26;++k){
			if(vis[g[j][k]]) continue;
			f[cur][g[j][k]]+=f[cur^1][j];
			f[cur][g[j][k]]%=MO;
		}
	}
}
```
---
最后附上完整代码和数据生成器。

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
const int MAXN=10000+5;
const int MO=10007;
struct Trie{
	int ch[30],cnt,fail;
}tree[MAXN];
char S[MAXN];
int idx,f[2][MAXN],g[MAXN][26];
bool vis[MAXN];
inline void insert(){
	int len=strlen(S+1);
	int now=0;
	for(int i=1;i<=len;++i){
		int c=S[i]-'A';
		if(!tree[now].ch[c]){
			tree[now].ch[c]=++idx;
		}
		now=tree[now].ch[c];
	}
	tree[now].cnt++;
}

queue <int> q;

inline void get_fail(){
	while(!q.empty()) q.pop();
	int now=0;tree[now].fail=0;
	for(int i=0;i<26;++i){
		if(!tree[now].ch[i]) continue;
		int v=tree[now].ch[i];
		tree[v].fail=0;
		q.push(v);
	}
	while(!q.empty()){
		now=q.front();q.pop();
		for(int i=0;i<26;++i){
			int u=tree[now].ch[i];
			if(!u) continue;
			q.push(u);int v=tree[now].fail;
			while(v && !tree[v].ch[i]) v=tree[v].fail;
			tree[u].fail=tree[v].ch[i];
		}
	}
}

inline int get(int now){
	int res=0;
	for(int i=now;i;i=tree[i].fail){
		if(tree[i].cnt) res+=tree[i].cnt;
	}
	return res;
}

inline void init(int now){
	if(get(now)) vis[now]=true;
	for(int i=0;i<26;++i){
		int u=now;
		while(!tree[u].ch[i] && u) u=tree[u].fail;
		g[now][i]=tree[u].ch[i];
	}
	for(int i=0;i<26;++i){
		int v=tree[now].ch[i];
		if(!v) continue;
		init(v);
	}
}

inline int Pow(int k){
	int ans=1,tmp=26;
	while(k){
		if(k&1) ans=(ans*tmp)%MO;
		tmp=(tmp*tmp)%MO;
		k>>=1;
	}
	return ans;
}

int main(){
	int n,m;scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		scanf("%s",S+1);
		insert();
	}
	get_fail();
	init(0);
	int cur=1;
	f[cur][0]=1;
	for(int i=1;i<=m;++i){
		cur^=1;	
		memset(f[cur],0,sizeof f[cur]);	
		for(int j=0;j<=idx;++j){
			if(vis[j]) continue;
			for(int k=0;k<26;++k){
				if(vis[g[j][k]]) continue;
				f[cur][g[j][k]]+=f[cur^1][j];
				f[cur][g[j][k]]%=MO;
			}
		}
	}
	int res=Pow(m),ans=0;
	for(int i=0;i<=idx;++i){
		if(vis[i]) continue;
		ans=(ans+f[cur][i])%MO;
	}
	printf("%d",(res-ans+MO)%MO);
	return 0;
}

```
---
```cpp
#include<stdlib.h>
#include<string.h>
#include<time.h>
#include<stdio.h>
int main(){
	srand(time(0));
	int n=60,m=100;
	printf("%d %d\n",n,m);
	for(int i=1;i<=n;++i){
		int len=rand()%100+1;
		for(int j=1;j<=len;++j){
			putchar(rand()%26+'A');
		}
		putchar('\n');
	}
	return 0;
}
```



---

## 作者：noble_ (赞：4)


## [更好的阅读体验](http://www.cnblogs.com/noblex/p/8424762.html)## 

我一开始也不会做这题的，后来看了很多网上的题解，终于AC了。（我好菜啊）


------------


主要参考：[传送门QWQ](http://blog.csdn.net/thchuan2001/article/details/57463291)

直接搞非常麻烦，反正我是不会做。于是考虑求反，即求有多少不包含任何单词的数量。最后再用$ {26}^m $减去就ok了。

接下来就是统计。

于是在$ AC $自动机上搞$ dp $。

用 $ dp[i][j] $表示前$ i $个字符在$ AC $自动机上位置为$ j $的方案数。

那么可以得出$ dp[i+1][k]=dp[i+1][k]+dp[i][j] $如果k是合法的儿子。

所以还要判断一下合法性（合法性 即：不是任何一个单词的end）

 
 
 

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=6010, MOD=10007;

int son[N][26], fail[N], end[N], newp, rt, q[N];
int dp[1200][6010], n, m;
char s[N];

int find(int cur,int i)
{
	if(!cur) return rt;
	if(son[cur][i]) return son[cur][i];
	return fail[son[cur][i]]=find(fail[cur],i);
}

int main()
{
	for (int i=0;i<26;i++) son[0][i]=1;
	newp=rt=1;
	scanf("%d%d",&n,&m);
	
	//Trie
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s+1);
		int cur=rt, l=strlen(s+1);
		for(int j=1;j<=l;j++)
		{
			if(!son[cur][s[j]-'A']) son[cur][s[j]-'A']=++newp;
			cur=son[cur][s[j]-'A'];
		}
		end[cur]=1;
	}
	
	//fail
	int l=1,r=1;q[1]=1;
	for(;l<=r;l++)
	{
		for(int i=0;i<26;i++)
		if(son[q[l]][i])
		{
			fail[son[q[l]][i]]=find(fail[q[l]],i);
			q[++r]=son[q[l]][i];
		}
	}
	
	//dp
	dp[1][1]=1; 
	for(int i=1;i<=m;i++)
	for(int j=1;j<=newp;j++)
	{
		for(int k=0;k<26;k++)
		{
			int cur=j, f=0;
			while(cur)
			{
				if(end[son[cur][k]]) { f=1; break; }
				cur=fail[cur];
			}
			if(f) continue;	//不能放 
			cur=j;
			while(!son[cur][k])
			{
				cur=fail[cur];  //从j向fail[j]跳直到有k儿子
			}
            cur=son[cur][k];
			dp[i+1][cur]=(dp[i+1][cur]+dp[i][j])%MOD;
		}
	}
	
	int anss=1, ans=0;
	for (int i=1;i<=m;i++) anss=(anss*26)%MOD;    //转换
    for (int i=1;i<=newp;i++)
    {
        ans=(ans+dp[m+1][i])%MOD;    //最终答案是所有dp[m+1][x]的和
    }
	
	printf("%d\n",(anss-ans+MOD)%MOD); 
	return 0;
}
```

 

---

## 作者：When (赞：3)

### 算法
AC自动机上的套路DP

### 思路
正面处理困难，于是考虑容斥，求不合法的方案数。考虑使用AC自动机，则原问题转化为：求使这$m$个字符串都匹配不上的字符串的个数。所以，匹配过程中经过的点，其$fail$链上的节点（包括本身）都不能有结束节点。

设$dp(i,j)$表示从根节点开始走$i$步到$j$号节点的方案数，状态转移方程为：

$dp(i, j) = \sum_{!t[k].num}dp(i - 1, k)$ （t[k].num表示k号节点的fail链上是否有结束节点）

### 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 5e4 + 10,mode = 1e4 + 7;
int n,f[6010][6010],m,ans;
string a;

struct AC{
	int cnt;
	struct Tree{
		int num,fail;
		int ch[30];
	}t[maxn];
	AC(){cnt = 0;}

	void build(string s){
		int len = s.size(); int now = 0;
		for(int i = 0; i < len; ++ i){
			int c = s[i] - 'A';
			if(!t[now].ch[c]) t[now].ch[c] = ++cnt;
			now = t[now].ch[c];
		}
		t[now].num = 1;
	}

	void get_fail(){
		queue<int> q;
		for(int i = 0; i < 26; ++ i)
			if(t[0].ch[i]){
				t[t[0].ch[i]].fail = 0;
				q.push(t[0].ch[i]);
			}
		while(!q.empty()){
			int u = q.front(); q.pop();
			for(int i = 0; i < 26; ++ i){
				int v = t[u].ch[i];
				if(v){
					t[v].fail = t[t[u].fail].ch[i];
					q.push(v);
					t[v].num |= t[t[v].fail].num;
				}
				else t[u].ch[i] = t[t[u].fail].ch[i];
			}
		}
	}

	void DP(){
		f[0][0] = 1;
		for(int i = 1; i <= m; ++ i)
			for(int j = 0; j <= cnt; ++ j)
				if(!t[j].num){
					for(int k = 0; k < 26; ++ k)
						f[i][t[j].ch[k]] = (f[i][t[j].ch[k]] + f[i - 1][j]) % mode;
				}
		for(int i = 0; i <= cnt; ++ i)
			if(!t[i].num) ans += f[m][i], ans %= mode;
	}
}ac;

int ksm(int a, int b){  //递归版本快速幂
	if(b == 1) return a;
	if(b == 0) return 1;
	if(b & 1) return ((a * ksm(a, b / 2)) % mode * ksm(a, b / 2)) % mode;
	else return (ksm(a, b / 2) * ksm(a, b / 2)) % mode;
}

int main(){
	ios::sync_with_stdio(false);
	cin >> n >> m;
	for(int i = 1; i <= n; ++ i){
		cin >> a;
		ac.build(a);
	}
	ac.get_fail(); ac.DP();
	cout << (ksm(26, m) - ans + mode) % mode << endl;
	return 0;
}
```
### 安利
[这篇博客对AC自动机上的DP进行了较为全面的总结](https://blog.csdn.net/dyx404514/article/details/13776025)


---

## 作者：KokiNiwa (赞：3)

这是一道简单的$AC$自动机上的$DP$问题。适合入门

[文本生成器](https://www.luogu.org/problem/P4052)

乍一看，这是和字符串、计数有关的题。于是容易联想到$AC$自动机和$DP$。但是具体如何做呢？看到这句话“如果一篇文章中至少包含使用者们了解的一个单词”，容易联想到正难则反。只要求出有多少个一个认识的单词都没有的文章数即可。更具体的，首先建立$AC$自动机，然后设$f[i][j]$表示匹配到自动机上第$i$个结点，长度为$j$的字符串有多少个。初始状态，$f[root][0]=0$。每一次转移，可以从$f[i][j]->f[son[i][k]][j+1]$，即为每次走到一个儿子上。一个结点可以走，当且仅当这个节点的$fail$指针，以及$fail$指针的$fail$指针$ \cdots\cdots $都不能是一个认识的单词的结尾。

于是这道题就结束了

```cpp
#include <cstdio>
#include <queue>
#include <cstring>

using namespace std;

//1.常量设计
const int maxWord = 70, maxLen = 110, maxNode = 70 * 110, mod = 10007;
//2.变量的定义（变量类型）
int wordN = 0, totNode = 0;
queue<int> que;
//3.数组的定义
//4.数组的空间分配
int ch[maxNode][26] = {};
int fail[maxNode] = {}, dp[maxNode][maxLen] = {};
int createLen = 0;
bool can[maxNode] = {};
char input[maxLen] = {};
//5.变量的初始化
//6.函数的定义
void insert() {
	int now = 0, len = strlen(input + 1);
	for (int fuI = 1; fuI <= len; ++fuI) {
		int erZi = input[fuI] - 'A';
		if (!ch[now][erZi]) ch[now][erZi] = ++totNode;
		now = ch[now][erZi];
	}
	can[now] = 0;
}
void buildFail() {
	while (!que.empty()) que.pop();
	for (int erZi = 0; erZi < 26; ++erZi) if (ch[0][erZi]) que.push(ch[0][erZi]);
	while (!que.empty()) {
		int now = que.front();
		que.pop();
		for (int id = 0; id < 26; ++id) {
			if (ch[now][id]) {
				fail[ch[now][id]] = ch[fail[now]][id];
				if (!can[fail[ch[now][id]]]) can[ch[now][id]] = 0;
				que.push(ch[now][id]);
			} else {
				ch[now][id] = ch[fail[now]][id];
			}
		}
	}
}
void add(int &fir, int sec) {
	fir = (fir + sec) % mod;
}
void Minus(int &fir, int sec) {
	fir = ((fir - sec) % mod + mod) % mod;
}

int main()
{
	freopen("create.in", "r", stdin);
	freopen("create.out", "w", stdout);
	scanf("%d%d", &wordN, &createLen);
	for (int node = 0; node <= 60 * 100; ++node) can[node] = 1;
	for (int renShi = 1; renShi <= wordN; ++renShi) {
		scanf("%s", input + 1);
		insert();
	}
	buildFail();
	dp[0][0] = 1;
	for (int nowLen = 0; nowLen < createLen; ++nowLen) {
		for (int node = 0; node <= totNode; ++node) {
			if (!(dp[node][nowLen] && can[node])) continue;
			for (int sonId = 0; sonId < 26; ++sonId) {
				if (!can[ch[node][sonId]]) continue;	//注意这里转移到的点也要合法，不只是更新别人的点要合法
				add(dp[ch[node][sonId]][nowLen + 1], dp[node][nowLen]);
			}
		}
	}
	int ans = 1;
	for (int weiI = 1; weiI <= createLen; ++weiI) ans = (ans * 26) % mod;
	for (int endNode = 0; endNode <= totNode; ++endNode) {
		Minus(ans, dp[endNode][createLen]);
	}
	printf("%d\n", ans);
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

---

## 作者：BzhH (赞：2)

首先看到这到题，很容易想到AC自动机，但这个题它求的是方案，并且没有告诉我们母串，所以这个时候我就们可以尝试用搜索枚举每一种方案

部分代码
```cpp
void dfs(int now, int j, bool flag)//now代表枚举了的文章长度，j代表AC自动机的下标，flag代表当前的文章是否合法
{
    if (now == m)
    {
        ans = (ans + flag) % MOD;
        return;
    }
    for (int i = 0; i < 26; i++)
    {
        int t = tr[j][i];
        bool is = true;
        while (t)
        {
            if (cnt[t])
            {
                dfs(now + 1, tr[j][i], true);
                is = false;
                break;
            }
            t = net[t];
        }
        if (is)
            dfs(now + 1, tr[j][i], flag);
    }
}
```
这个暴搜只能的20分，于是尝试优化，改成了记忆化搜索，用一个数组将之前搜过的状态存起来
```cpp
int dfs(int now, int j, bool flag)
{
    if (rec[now][j][flag])
        return rec[now][j][flag];
    if (now == m)
        return flag;
    int res = 0;
    for (int i = 0; i < 26; i++)
    {
        int t = tr[j][i];
        bool is = true;
        while (t)
        {
            if (cnt[t])
            {
                res = (res + dfs(now + 1, tr[j][i], true)) % MOD;
                is = false;
                break;
            }
            t = net[t];
        }
        if (is)
            res = (res + dfs(now + 1, tr[j][i], flag)) % MOD;
    }
    rec [now][j][flag] = res;
    return res;
}
```
但了记忆化之后任然只能得70分，由于我tcl，已经找不出其他地方优化了，所以就只能考虑DP了，有了记忆化搜索的经验，那么DP就相对好想了，定于一个三维数组$f_{i,j,k}$,含义同上面的搜索,i表示当前的文章长度,j表示AC自动机的位置,k表示文章是否合法,具体的转移方程放在代码里解释

完整代码
```
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
const int N = 1e5 + 5, MOD = 1e4 + 7;

char str[N];
int tr[N][26], net[N], cnt[N], idx, ans, n, m;
int f[105][N][2];
queue<int> q;

void insert()
{
    int p = 0;
    for (int i = 0; str[i]; i++)
    {
        int t = str[i] - 'A';
        if (!tr[p][t])
            tr[p][t] = ++idx;
        p = tr[p][t];
    }
    cnt[p]++;
}

void build()
{
    for (int i = 0; i < 26; i++)
        if (tr[0][i])
            q.push(tr[0][i]);
    while (!q.empty())
    {
        int t = q.front();
        q.pop();
        for (int i = 0; i < 26; i++)
        {
            int p = tr[t][i];
            if (!p)
                tr[t][i] = tr[net[t]][i];
            else 
            {
                net[p] = tr[net[t]][i];
                q.push(p);
            }
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
    {
        scanf("%s", &str);
        insert();
    }
    build();//AC自动机板子,就不解释了
    f[0][0][0] = 1;//初始状态
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j <= idx; j++)
        {
            for (int k = 0; k < 26; k++)
            {
                bool flag = false;
                int p = tr[j][k];
                while (p)
                {
                    if (cnt[p])
                    {
                        flag = true;
                        break;
                    }
                    p = net[p];
                }//判断下一个位置是否存在一个字典中的单词
                if (flag)
                    f[i + 1][tr[j][k]][1] = (f[i + 1][tr[j][k]][1] + f[i][j][0] + f[i][j][1]) % MOD;//如果存在,就把当前位置的所有方案加上
                else //不存在
                {
                    f[i + 1][tr[j][k]][0] = (f[i + 1][tr[j][k]][0] + f[i][j][0]) % MOD;//加上不合法的方案
                    f[i + 1][tr[j][k]][1] = (f[i + 1][tr[j][k]][1] + f[i][j][1]) % MOD;//加上合法的方案              
                }
            }
        }
    }
    int ans = 0;
    for (int i = 0; i <= idx; i++)
        ans = (ans + f[m][i][1]) % MOD;//将所有方案加起来        
    printf("%d", ans);
    return 0;
}
```




---

## 作者：fpjo (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P4052)

这是一道十分经典的AC自动机+dp的题目

## 大意

求长度为m、字符集为大写字母、包含至少一个模式串的所有字符串的数目，对$1e4+7$取模

## 思路

看到这种匹配类的东西可以考虑AC自动机。但直接求出答案比较复杂，我们考虑转换为其补集即*不包含任何任何一个模式串的字符串数目*.

对模式串建立AC自动机,当节点为 ***危险节点*** ,即**结束节点**或者**其祖先为结束节点**(因为一个单词的后缀是一个可读单词时,这个单词一定可读的)都不可以,所以对于后一种有以下代码

```cpp
ed[trie[x][i]]|=ed[fail[trie[x][i]]];
```



假设 $f_{i,j}$ 表示已经匹配到$trie$图上的节点$i$,长度为 $j$ 的不合法字符串个数,我们枚举接下来的字符,即可实现转移,有以下dp方程式

$$f_{trie_{i,k},j}(trie_{i,k}\notin ed)=\sum_{i\notin ed} f_{trie_{i},j-1}$$

意思就是说将这个非危险节点的答案转移到它的非危险的儿子上去.

## 注意(我掉的坑)

1. $Trie$的大小为字符串总大小×字符集大小

    ~~这除了我还会掉吗~~

2. 根节点在AC自动机中有它特有的含义,仔细思考

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int const MOD=1e4+7;
int n,m,sum;
int f[6001][1010];
char s[2000];
struct AC_Automaton{
	int trie[10010][30],fail[60010],ed[60010];
	int tot;
	queue<int>q;
	void insert(){
		int len=strlen(s+1);int now=0;
		for(int i=1;i<=len;i++){
			int x=s[i]-'A';
			if(!trie[now][x]){trie[now][x]=++tot;}
			now=trie[now][x];
		}
		ed[now]=1;
	}
	void getfail(){
		for(int i=0;i<26;i++){
			if(trie[0][i]){
				fail[trie[0][i]]=0;
				q.push(trie[0][i]);
			}
		}
		while(!q.empty()){
			int x=q.front();q.pop();
			for(int i=0;i<26;i++){
				if(trie[x][i]){
					fail[trie[x][i]]=trie[fail[x]][i];
					q.push(trie[x][i]);
					ed[trie[x][i]]|=ed[fail[trie[x][i]]];
				}else{
					trie[x][i]=trie[fail[x]][i];
				}
			}
		}
	}
}ACA;
int qpow(int x,int k){
	int ans=1;
	while(k){
		if(k&1)ans=(ans*x)%MOD;
		k>>=1;
		x=x*x%MOD;
	}
	return ans;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%s",s+1);
		ACA.insert();
	}
	ACA.getfail();
	for(int i=0;i<26;i++){
		if(!ACA.ed[ACA.trie[0][i]])f[ACA.trie[0][i]][1]+=1;
	}
	for(int i=2;i<=m;i++){
		for(int j=0;j<=ACA.tot;j++){
			if(!ACA.ed[j]){
				for(int k=0;k<26;k++){
					if(!ACA.ed[ACA.trie[j][k]])f[ACA.trie[j][k]][i]=(f[ACA.trie[j][k]][i]+f[j][i-1])%MOD;
				}
			}
		}
	}
	for(int j=0;j<=ACA.tot;j++)if(!ACA.ed[j])sum=(sum+f[j][m])%MOD;
	printf("%d\n",(qpow(26,m)-sum+MOD)%MOD);
	return 0;
}
```


---

## 作者：wzy2021 (赞：1)

我们来看一下这道题：

首先建出 $trie$ 树，再建出 **AC自动机**。

考虑容斥，即总数 - 不可读的个数。

总数 = $26 ^ m$，可用快速幂求解。

问题变成 不可读的方案 有多少个？

显然，如果一个点 $u$，$fail[u]$ 是危险节点，则 $u$ 也是危险节点。


那么用一个 $flag[u]$ 表示 $u$ 是否是危险节点，$flag[u]$ 可在求 $fail$ 时转移。


考虑 **动态规划**，记 $dp[i][j]$ 表示在AC自动机上结尾为节点 $j$，长度为 $i$ 的方案数，转移方程为: 

$$dp[i][trie[j][k]] = dp[i][trie[j][k]] + dp[i - 1][j],flag[trie[j][k]] \neq 0$$ 

最后方案就是：$\sum\limits_{i = 1}^{cnt} dp[m][i]$ 

注意：要取摸，且处理取摸后再减为负数的情况

具体实现，可看代码。

```cpp
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;

const int maxn = 6e4 + 10, mod = 1e4 + 7;
int n, m, cnt = 1, trie[maxn][26], fail[maxn], dp[110][maxn];
char c[maxn][110];
bool flag[maxn];
queue <int> q;

void insert (int p) { // 建立 trie 树
    int now = 1, len = strlen (c[p] + 1);
    for (int i = 1; i <= len; ++i) {
        int x = c[p][i] - 'A';
        if (!trie[now][x]) trie[now][x] = ++ cnt;
        now = trie[now][x];
    }
    flag[now] = 1;
}

void calc () { // 求出 fail 与 flag 数组，便建出 AC 自动机
    for (int i = 0; i < 26; ++i) trie[0][i] = 1;
    q.push (1); fail[1] = 0;
    while (!q.empty()) {
        int now = q.front(); q.pop();
        for (int i = 0; i < 26; ++i) {
            if (trie[now][i]) {
                fail[trie[now][i]] = trie[fail[now]][i]; flag[trie[now][i]] |= flag[fail[trie[now][i]]];
                q.push (trie[now][i]);
            } else {
                trie[now][i] = trie[fail[now]][i];
            }
        }
    }
}

int query () { // 求不可行方案
    dp[0][1] = 1;
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= cnt; ++j) {
            for (int k = 0; k < 26; ++k) {
                if (!flag[trie[j][k]]) dp[i][trie[j][k]] = (dp[i][trie[j][k]] + dp[i - 1][j]) % mod;
            }
        }
    }
    int ans = 0;
    for (int i = 1; i <= cnt; ++i) {ans = (ans + dp[m][i]) % mod; cout << ans << endl;}
    return ans;
}

int pow (int x, int y) { // 快速幂
    int res = 1;
    while (y) {
        if (y & 1) res = res * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return res;
}

int main() {
    scanf ("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) {
        scanf ("%s", c[i] + 1); insert (i); // 插入
    }
    calc ();
    printf ("%d", (pow (26, m) - query() + mod) % mod); // 容斥
    return 0;
}
```

---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P4052)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一次遇到自动机上面跑$DP$的题。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原题目看起来不好做，但是有“至少一个”这个条件，我们就可以想到容斥一波，用总方案减去不合法方案。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总方案很好计算，为$26^m$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑计算不合法方案，也就是里面不包含任何一个已知单词。换句话说，没有一个单词能**匹配**得上它。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到这个词你应该就懂了，这道题实际上跟字符串匹配有关系。由于这道题有多个模式串，所以我们先建好$AC$自动机。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后考虑$DP$计算不合法方案：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$f(i,j)$：长度为$i$、在自动机上会到达状态$j$的不合法字符串的总数。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$nxt(i,j)$为从状态$i$，走过$j$之后到达的状态。这个可以预处理。转移有：  
$$\forall k\in['A','Z'],f(i+1,nxt(j,k))+=f(i,j)$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（按照从前一个状态往后转移的方法来理解这个方程）  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$L=\sum_{i=1}^nlen(s_i)$，时间复杂度为$O(26L^2+26mL)$（前一个为预处理$nxt$的时间，这是我猜的，因为根据平时自动机的实际运行情况时间应该比这个小得多；后一个为$DP$的时间）。  
# 代码
```cpp
#include <queue>
#include <cstdio>
#include <cstring>

const int mod = 10007;
const int MAXN = 65, MAXM = 105, MAXSIZ = MAXN * MAXM, MAXC = 26;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

std :: queue<int> q;

int f[MAXM][MAXSIZ];
int ch[MAXSIZ][MAXC], nxt[MAXSIZ][MAXC], fail[MAXSIZ];
char S[MAXM];
int N, M, siz, rt = 1;
bool ed[MAXSIZ];

void init() { siz = 1; for( int i = 0 ; i < 26 ; i ++ ) ch[0][i] = 1; }
int id( const char c ) { return c - 'A'; }

int qkpow( int base, int indx )
{
	int ret = 1;
	while( indx )
	{
		if( indx & 1 ) ( ret *= base ) %= mod;
		( base *= base ) %= mod, indx >>= 1;
	}
	return ret;
}

void insert( const char *s )
{
	int len = strlen( s + 1 ), p = rt, indx;
	for( int i = 1 ; i <= len ; i ++ )
	{
		indx = id( s[i] );
		if( ! ch[p][indx] ) ch[p][indx] = ++ siz;
		p = ch[p][indx];
	}
	ed[p] = true;
}

void failBuild()
{
	while( ! q.empty() ) q.pop();
	q.push( rt );
	int u, v, p;
	while( ! q.empty() )
	{
		u = q.front(), q.pop();
		for( int i = 0 ; i < 26 ; i ++ )
		{
			v = ch[u][i], p = fail[u];
			if( ! v ) { ch[u][i] = ch[fail[u]][i]; continue; }
			while( p && ! ch[p][i] ) p = fail[p];
			if( ch[p][i] ) fail[v] = ch[p][i];
			q.push( v ), ed[v] |= ed[fail[v]];
		}
	}
}

int desti( int cur, const char way )
{
	int indx = id( way );
	while( cur && ! ch[cur][indx] ) cur = fail[cur];
	return ch[cur][indx];
}

int main()
{
	init();
	read( N ), read( M );
	for( int i = 1 ; i <= N ; i ++ )
	{ 
		scanf( "%s", S + 1 );
		insert( S );
	};
	failBuild();
	for( int i = 0 ; i <= siz ; i ++ )
		for( int j = 0 ; j < 26 ; j ++ )
			nxt[i][j] = desti( i, j + 'A' );
	f[0][rt] = 1;
	for( int i = 0 ; i < M ; i ++ )
		for( int j = 1 ; j <= siz ; j ++ )
			for( int k = 0 ; k < 26 ; k ++ )
				if( ! ed[nxt[j][k]] )
					( f[i + 1][nxt[j][k]] += f[i][j] ) %= mod;
	int tmp = 0;
	for( int i = 1 ; i <= siz ; i ++ ) ( tmp += f[M][i] ) %= mod;
	write( ( qkpow( 26, M ) - tmp + mod ) % mod ), putchar( '\n' );
	return 0;
}
```

---

## 作者：i207M (赞：0)

## 题意

求出长度为M的任意大写字符串中，包含至少一个模式串的数量

## 方法

## 求XXX包含至少一个YYY的种类=XXX的种类-不含任何YYY的种类

求出长度为M的任意大写字符串中，不包含任何模式串的数量；

AC自动机上DP；

**套路：$f[i][j]$表示串的长度为i，当前在j节点的数量；**

转移？枚举j的下一位填什么，转移到对应的节点；

## 注意

结尾标记要下传，也就是当一个点的前缀是一个单词的结尾时，也不能选，所以要$val[v] |= val[fail[v]]$；

不要像我一样用什么奇怪的下传，v的前缀就是fail[v]；

## 代码

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<queue>
#include<stack>
#include<bitset>
#include<deque>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define mem0(x) memset((x),0,sizeof (x))
#define mem1(x) memset((x),0x3f,sizeof (x))
#define pb push_back
#define gc getchar
template<class T>void in(T &x)
{
	x = 0; bool f = 0; char c = gc();
	while (c < '0' || c > '9') {if (c == '-') f = 1; c = gc();}
	while ('0' <= c && c <= '9') {x = (x << 3) + (x << 1) + (c ^ 48); c = gc();}
	if (f) x = -x;
}
#undef gc
#define N 10005
int trie[N][26], cnt, fail[N];
int val[N];
int n;
void insert(char *c) {
	ri l = strlen(c), x = 0;
	for (ri i = 0, t; i < l; i++) {
		t = c[i] - 'A';
		if (!trie[x][t]) trie[x][t] = ++cnt;
		x = trie[x][t];
	}
	val[x]++;
}
void getfail() {
	queue<int>q;
	q.push(0);
	ri x;
	while (!q.empty()) {
		x = q.front();
		q.pop();
		for (ri i = 0, v; i < 26; ++i)
			if ((v = trie[x][i])) {
				fail[v] = x ? trie[fail[x]][i] : 0;
				q.push(v);
				val[v] |= val[fail[v]];
			}
			else trie[x][i] = trie[fail[x]][i];
	}
}
#define md 10007
int m;
char tc[N];
int f[105][N];  // added is i,node is j
signed main() {
	in(n), in(m);
	for (ri i = 1; i <= n; ++i) {
		scanf("%s", tc);
		insert(tc);
	}
	getfail();
	f[0][0] = 1;
	for (ri i = 1; i <= m; ++i) {
		for (ri j = 0; j <= cnt; ++j) {
			if (!f[i - 1][j]) continue;
			for (ri k = 0; k < 26; ++k) {
				if (val[trie[j][k]] == 0) {
					(f[i][trie[j][k]] += f[i - 1][j]) %= md;
				}
			}
		}
	}
	/*for (ri i = 0; i <= m; ++i) {
		for (ri j = 0; j <= cnt; ++j) {
			printf("%d ", f[i][j]);
		}
		puts("");
	}*/
	int sum = 0;
	for (ri i = 0; i <= cnt; ++i) (sum += f[m][i]) %= md;
	int ans = 1;
	for (ri i = 1; i <= m; ++i) (ans *= 26) %= md;
	printf("%d", (ans - sum + md) % md);
	return 0;
}

```

---


# [SDOI2016] 储能表

## 题目描述

有一个 $n$ 行 $m$ 列的表格，**行从 $0$ 到 $n-1$ 编号，列从 $0$ 到 $m-1$ 编号**。每个格子都储存着能量。最初，第 $i$ 行第 $j$ 列的格子储存着 $(i \oplus j)$ 点能量（$\oplus$ 表示**按位异或**）。所以，整个表格储存的总能量是

$$\sum_{i=0}^{n-1} \sum_{j=0}^{m-1} i \oplus j$$

随着时间的推移，格子中的能量会渐渐减少。每经过一个时间单位，每个格子中的能量都会减少 $1$。显然，**一个格子的能量减少到 $0$ 之后就不会再减少了。**

也就是说，$k$ 个时间单位后，整个表格储存的总能量是

$$\sum_{i=0}^{n-1} \sum_{j=0}^{m-1} \max((i \oplus j)-k,0)$$

给出一个表格，求 $k$ 个时间单位后它储存的总能量。

由于总能量可能较大，输出时对 $p$ 取模。

## 说明/提示

对于 $100\%$ 的数据，保证 $1\le T\le 5000$，$1\le p\le 10^9$，$1\le n,m\le 10^{18}，0\le k\le 10^{18}$。

| 测试点编号 | $T=$ | $n\le$ | $m\le$ | $k\le$ | $p\le$ |
| :--: | :--: | :--: | :--: | :--: | :--: |
| $1,2$ | $5000$ | $100$ | $100$ | $100$ | $10^9$ |
| $3$ | $5000$ | $10^{18}$ | $10^{18}$ | $0$ | $10^9$ |
| $4$ | $5000$ | $10^{18}$ | $10^{18}$ | $1$ | $10^9$ |
| $5$ | $5000$ | $10$ | $10^{18}$ | $10$ | $10^9$ |
| $6$ | $1$ | $10^5$ | $10^{18}$ | $10^5$ | $10^9$ |
| $7$ | $1$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |
| $8$ | $100$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |
| $9,10$ | $5000$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |

$\texttt{Statement fixed by Starrykiller.}$

## 样例 #1

### 输入

```
3
2 2 0 100
3 3 0 100
3 3 1 100```

### 输出

```
2
12
6```

# 题解

## 作者：lytqwq (赞：35)

这题对初学数位DP的我很不友好

洛谷上的第一个题解没写明白状态。百度到的其他的题解也大多是 “直接DP就好了” “只写了状态” “看我代码” ，或者没说该怎么样数位DP

~~在翻了12页百度后，~~ 有了这篇题解...

题目要我们求这个东西：

$$\sum_{i=0}^{n-1} \sum_{j=0}^{m-1} \mathrm{max} ((i \mathrm{xor} j)-k,0)$$

我们可以把问题分成 求异或值大于$k$的对数 $S1$ ，异或值大于$k$的异或和 $S2$

答案就变为了 $S2-S1\times k$

至于怎么求，数位DP

定义

$ f_{i,a,b,c} $ $i$ ：考虑到第 $i$ 位， $a,b,c$ 为 $1$ 时表示 前面到第 $i$ 位分别和 $n,m,k$ 的前面到第 $i$ 位相等时的异或和 为 $0$ 时表示 $i$ 位分别比 $n,m$ 的前面到第 $i$ 位小和比 $k$ 的前面到第 $i$ 位大时的异或和 

$f$ 的异或和要去掉 前面到第 $i$ 位的 $k$ 

$g_{i,a,b,c}$ 同上，但是表示是对数

转移在注释上

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long int N=70;
long long int f[N][2][2][2],g[N][2][2][2];
// f_{i,a,b,c} i：考虑到第i位， a,b,c 为1时表示 前面到第i位分别和n,m,k的前面到第i位相等时的异或和 为0时表示i位分别比n,m的前面到第i位小和比k的前面到第i位大时的异或和 
//f已经去掉 前面到第i位的k 
//g_{i,a,b,c} 同上，但是表示对数 
long long int n,m,k,T,p;
int main(){
	scanf("%lld",&T);
	while(T--){
		memset(f,0,sizeof(f));
		memset(g,0,sizeof(g));
		scanf("%lld%lld%lld%lld",&n,&m,&k,&p);
		g[62][1][1][1]=1;
		for(int i=61;i>=1;i--){//从高位往低位推 
			long long int x=(n>>(i-1))&1,y=(m>>(i-1))&1,z=(k>>(i-1))&1;// x: n在第i位的数； y:m在第i位的数；z：k在第i位的数 
			for(long long int a=0;a<2;a++){ //是不是前面到第i位和n的相等
				for(long long int b=0;b<2;b++){//是不是前面到第i位和m的相等
					for(long long int c=0;c<2;c++){//是不是前面到第i位和k的相等
						if(f[i+1][a][b][c] || g[i+1][a][b][c]){//此处是刷表法，从i,a,b,c转移出去 
							for(long long int xx=0;xx<2;xx++){//转移到第i位的数 是 
								for(long long int yy=0;yy<2;yy++){//转移到第i位的数 是 
									long long int zz=xx^yy;// 已知了这一位的数，这一位的异或就知道了 
									if((a && x<xx)||(b && y<yy)||(c && z>zz)){ 
										continue;
										//1.不能让 前面到第i位相等，现在还这一位比n的这一位大
										//2.不能让 前面到第i位相等，现在还这一位比m的这一位大
										//3.不能让 前面到第i位相等，现在还这一位比k的这一位小 
									}
									long long int aa=(a && x==xx),bb=(b && y==yy),cc=(c && z==zz);
									//如果前面到第i位都相等，现在这一位也相等，就是1，需要再看后面的数才能判断大小 
									//不然就为0，意为在必定在限制之内 
									//可以发现不会从0转移到1，只会从1转移到0 
									g[i][aa][bb][cc]+=g[i+1][a][b][c];
									//转移 g
									g[i][aa][bb][cc]%=p;
									f[i][aa][bb][cc]+=f[i+1][a][b][c]+(zz-z+p)%p*((1ll<<(i-1))%p)%p*g[i+1][a][b][c]%p;
									//转移 f，后一项中的(zz-z+p)%p*((1ll<<(i-1))%p)%p就是转移的数的每一位都去掉k的那一位后这一位的贡献， g[i+1][a][b][c]为转移的数量 
									f[i][aa][bb][cc]%=p;
								}
							}
						}
					}
				}
			}
		}
		printf("%lld\n",f[1][0][0][0]);
		//考虑完最后一位,注意到是0~(n-1)和0~(m-1)，所以直接用表示小于n,m的0，当 两个数异或为k的时候，都减了k，就没必要算了，直接算让异或值大于k 
	}
}
```











---

## 作者：优秀的渣渣禹 (赞：33)

修改了一下，update了一种新做法
#### 来我们接触到这篇题目，我们仔细考虑一下是数位dp。

### 可以发现可以一位一位的处理，每一位可以从前一位推出，所以可以考虑数位dp。


		我们把要统计的数变为二进制表示，先考虑n位二进制的数，再考虑n-1位的数。f[i][1/0][1/0][1/0]为已经考虑到了第i位，第i位是否比n（第i位）小，第i位是否比m小， 是否比k小的总共分数。
	
    	g[i][1/0][1/0][1/0]为已经考虑到了第i位，第i位是否比n（第i位）小，第i位是否比m小，是否比k小的所有情况总数。

		我们从大到小考虑每一位，我们就可以推出一个式子g[i][aa][bb][cc] += g[i+1][a][b][c];
    
		如果从状态(i,a,b,c)可以转移到状态(i-1, aa, bb, cc);
####   f[i][aa][bb][cc] += f[i+1][a][b][c] + (zz-z)*(1<<i)*g[i+1][a][b][c];
		前一项不必多说，后一项就是对于每一种可能都可以在前面加上1/0。
		最然数据范围是10 18，但是log2(10^18) = 60。所以我们循环60次即可。
### 代码如下

	#include<cstdio>
	#include<cmath>
	#include<algorithm>
	#include<iostream>
	#include<cstring>
	#include<vector>
	#define ll long long
	using namespace std;
	ll f[62][2][2][2], g[62][2][2][2];
	ll n, m, k, T, p;
	int main()
	{
		scanf("%lld", &T);
		while (T--) {
		memset(f, 0, sizeof(f));
		memset(g, 0, sizeof(g));
		scanf("%lld %lld %lld %lld", &n, &m, &k, &p);
		g[61][1][1][1] = 1;
		for (int i = 60; i >= 0; i--) {
		int x = (n >> i) & 1, y = (m >> i) & 1, z = (k >> i) & 1;
			for (int a = 0; a < 2; a++) {
				for (int b = 0; b < 2; b++) {
					for (int c = 0; c < 2; c++){
						if (f[i + 1][a][b][c] || g[i + 1][a][b]	[c]) {
							for (int xx = 0; xx < 2; xx++) {
								for (int yy = 0; yy < 2; yy++) {
									int zz = xx ^ yy;
									if ((a && x < xx) || (b && y < yy) || (c && z > zz))
										continue;
									int aa = (a && x == xx), bb = (b & y == yy),cc = (c && z == zz);
									g[i][aa][bb][cc] = (g[i][aa][bb][cc] + g[i + 1][a][b][c]) % p;
									f[i][aa][bb][cc] = (f[i][aa][bb][cc] + f[i + 1][a][b][c] + ((zz - z) + p) % p * ((1ll << i) % p) % p * g[i + 1][a][b][c] % p) % p;
									}
								}
							}	 
						}
					}
				}
			}
			printf("%lld\n", f[0][0][0][0]);
		}
	}
   
 分割线---------------------------------------------------------------
 
这个题可以暴力打表。

初拿此题还是一年前，当时写的数位dp，现在看来可以打表玩。

我们看一下要求的式子：
$$
\sum_{i=0}^{n-1}\sum_{j=0}^{m-1}\max((i xor j)-k,0)
$$

然后我们定义一个$sum$函数，该函数如下：

$sum(x,y):$求$\sum_{now=x}^ynow$

其实就是想拆个西格玛下来。。。。算是化简吧。。。。。

然后我们在定义一个calc函数。。。美其名曰求题目及若干子问题（好吧我承认就是递归求解）
$$
calc(n,m,k)
$$
那么问题来了，这两个函数是怎么来的？

首先我们需要打个表！！！！！

![](https://cdn.luogu.com.cn/upload/image_hosting/wrc592fk.png)

然后我们发现这个表好像是对称的！！！！

这个叫啥对称？？对角对称？？中心对称再拧回来？？？总之是对称的就是了。

然后对于$\forall p=2^i$，$p*p$的左上角的是$(0,0)$的正方形，它的每一行，每一列的和是固定的。且它下面的和右面的同等大小的正方形恰好是在它的基础上加一个$2^i$，它的右下角的正方形是与它完全一样的。

Like this：

![](https://cdn.luogu.com.cn/upload/image_hosting/g56pr2ll.png)

然后就可以递归求解了

这里说一下calc的写法。

我们先求出比$n,m$中较大的数小的最大的2的次幂然后减一，这个次幂设为$t$的话（下面假设$n$大一点），那么我们得到了一个$t*t$的正方形。

如果这个正方形在$n*m$的矩形里面，那我们就可以递归它的下面一部分，右边一部分，和右下角一部分。

如果这个矩形已经超过了$n,m$的矩形的范围，我们可以直接计算出$t,m$这个矩形的数值（$t$行—列的和是固定的，因为$t$是2的次幂），接着再递归求解$(n-i)*m$这个矩形内的数值。

然后我们就可以写个大模拟。。。。。。

然后就可了。

事实证明，什么dp都是浮云，打表暴力才是王道！！！（划死

上代码


```cpp
#define B cout << "BreakPoint" << endl;
#define O(x) cout << #x << " " << x << endl;
#define O_(x) cout << #x << " " << x << " ";
#define Msz(x) cout << "Sizeof " << #x << " " << sizeof(x)/1024/1024 << " MB" << endl;
#include<cstdio>
#include<cmath>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#define LL long long
#define inf 1000000009
using namespace std;
inline LL read() {
	LL s = 0,w = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') {
		if(ch == '-')
			w = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9') {
		s = s * 10 + ch - '0';
		ch = getchar();
	}
	return s * w;
}
LL T,N,M,K,p,tmp;
LL sum(LL x,LL y) {
	if(x < 0) {
		x = 0;
	}
	if(y < 0) {
		y = 0;
	}
	LL res = y - x + 1;
	if(res & 1) {
		return (res % p) * ((x + y >> 1) % p) % p;
	} else {
		return ((res + 1 >> 1) % p) * ((x + y) % p) % p;
	}
}
LL calc(LL n,LL m,LL k) {
	if(n < 0||m < 0) {
		return 0;
	}
	if(n == 0 && m == 0) {
		return max(((N - 1) ^ (M - 1)) - K,tmp) % p;
	}
	if(n < m) {
		swap(n,m);
	}
	LL l = 0,t;
	while((1LL << l) <= n + 1) l++;
	l--;
	t = (1LL << l) - 1;
	if(t <= m) {
		return ((t + 1) % p * sum(-k,t - k) % p + (n - t + m - t) % p * sum(t + 1 - k,t + t + 1 - k) % p + calc(n - t - 1,m - t - 1,k)) % p;
	} else {
		return ((m + 1) % p * sum(max(-k,tmp),max(tmp,t - k)) % p + calc(n - t - 1,m,k - t - 1)) % p;
	}
}
void init() {
	N = read(),M = read(),K = read(),p = read();
	LL now = calc(N - 1,M - 1,K);
	printf("%lld\n",now);
	return ;
}
void solve() {
	T = read();
	while(T--){
		init();
	}
	return ;
}
int main(){
	solve();
	return 0;
}
```



---

## 作者：Fizzmy (赞：19)

## Solution：

看到两个求和符号下意识想到莫反...

等等 为什么莫反会有异或操作？？？

...

最终发现是一道二进制下的数位dp：

$f[i][0/1][0/1][0/1]$表示从高到低第i位，是否到n的上界，是否到m的上界，当前异或结果是否到k的下界

对于每个状态记录合法方案数和所有合法i,j的异或和，最后把k的那些减去即可

代码依旧套路，记忆化搜索即可

代码：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring> 
#define pii pair<int,int> 
using namespace std;
long long n,m,nn,mm,k,kk;
int T,mod,maxlen;
pii f[70][2][2][2];
bool vis[70][2][2][2];
void add(int &x,int y)
{
	x+=y;
	if (x>=mod) x-=mod;
}
pii dp(int len,bool n1,bool m1,bool k1)
{
	if (len>maxlen) return make_pair(1,0);
	if (vis[len][n1][m1][k1]) return f[len][n1][m1][k1];
	vis[len][n1][m1][k1]=1;
	int np=(n>>maxlen-len)&1,mp=(m>>maxlen-len)&1,kp=(k>>maxlen-len)&1;
	for (int i=0;i<=(n1?np:1);i++)
		for (int j=0;j<=(m1?mp:1);j++)
		{

			if (k1&&(i^j)<kp) continue;
			pii nw=dp(len+1,n1&&(i==np),m1&&(j==mp),k1&&((i^j)==kp));
			add(f[len][n1][m1][k1].first,nw.first);
			add(f[len][n1][m1][k1].second,((1ll<<maxlen-len)*(i^j)%mod*nw.first+nw.second)%mod);
		}
	return f[len][n1][m1][k1];
}
int main()
{
	scanf("%d",&T);
	while (T--)
	{
		memset(vis,0,sizeof(vis));memset(f,0,sizeof(f));
		scanf("%lld%lld%lld%d",&n,&m,&k,&mod);
		n--,m--;
		int nw=0;
		nn=n,mm=m,kk=k;
		while (nn) nw++,nn/=2;maxlen=max(nw,maxlen);nw=0;
		while (mm) nw++,mm/=2;maxlen=max(nw,maxlen);nw=0;
		while (kk) nw++,kk/=2;maxlen=max(nw,maxlen);
		pii ans=dp(1,1,1,1);
		printf("%d\n",(1ll*ans.second-1ll*k%mod*ans.first%mod+mod)%mod);
	}
	
}
```



---

## 作者：MyukiyoMekya (赞：8)

提供一种小清新做法。

考虑 $i\in [0,2^u),j\in [0,2^v)$ ，假设 $u\le v$ ，那么所有 $i \operatorname{xor} j$ 的结果覆盖区间刚好是 $[0,2^v)$ 且每个数恰好被覆盖到 $2^u$ 次。

那就把 $\log^2$ 个矩形全部提取出来算一遍就好了，时间复杂度 $\mathcal O(T\log n\log m)$。

```cpp
// This code wrote by chtholly_micromaker(Myukiyomekya)
#include <bits/stdc++.h>
#define int long long
int n,m,K,p;
inline int S(int l,int r)
{return ((l+r)&1)?(r-l+1)/2%p*((l+r)%p)%p:(l+r)/2%p*((r-l+1)%p)%p;}
inline int calc(int l,int r,int x)
{return l<=x&&x<=r?S(0,r-x):r<x?0:S(l-x,r-x);}
signed main(void)
{
	int t;std::cin>>t;
	while(t--)
	{
		std::cin>>n>>m>>K>>p;
		int ans=0,u,v,x;
		for(int i=0;i<60;++i)for(int j=0;j<60;++j)if((n>>i&1)&&(m>>j&1))
			u=std::min(i,j),v=i^j^u,x=(n&-(1LL<<-~i))^(m&-(1LL<<-~j)),
			x&=-(1LL<<v),(ans+=(1LL<<u)%p*calc(x,x|~-(1LL<<v),K))%=p;
		std::cout<<ans<<"\n";
	}
	return 0;
}
```



---

## 作者：Pekac (赞：6)

[P4067](https://www.luogu.com.cn/problem/P4067)

因为不能直接减去 $nmk$，先把题目中的式子转化为求 $i\oplus j \ge k$ 的数的个数与和。

这样就可以进行数位 dp 了。令 $f_{bt,un,um,lk}$ 表示当前考虑到第 $bit$ 位，$n$ 有没有达到上界，$m$ 有没有达到上界，$k$ 有没有达到下界的个数，$g$ 表示的是这些数的总和。然后因为考虑的是有没有到达上/下界，从高向低位进行记搜更简单。

转移是简单的，即 $f_{bit,un,um,lk}=\sum f_{bit-1,un',um',lk'}$，$g_{bit,un,um,lk}=\sum g_{bit-1,un',um'lk'}+(i\oplus j)\times 2^{bit}\times f_{bit-1,un',um',lk'}$。其中 $i,j$ 表示行、列的当前枚举的位的值。

为了实现方便，可以只用一次记搜，返回值是一个 pair 即可 。

代码：
```cpp
typedef long long ll;
typedef pair<int,int> pii;
ll n,m,k;int p;
ll pw[65];
pii f[64][2][2][2];int vis[64][2][2][2];
pii dfs(int bit,int un,int um,int lk){
	if(bit==-1)return pii(1,0);
	if(vis[bit][un][um][lk])return f[bit][un][um][lk];
	vis[bit][un][um][lk]=1;
	pii &now=f[bit][un][um][lk];
	now=pii(0,0);
	int bn=n>>bit&1,bm=m>>bit&1,bk=k>>bit&1;
	for(int i=0;i<=(un?bn:1);i++)for(int j=0;j<=(um?bm:1);j++){
		if(lk&&(i^j)<bk)continue;
		pii res=dfs(bit-1,un&(i==bn),um&(j==bm),lk&((i^j)==bk));
		now.first=(now.first+res.first)%p,now.second=(now.second+res.first*(i^j)*1ll*pw[bit]+res.second)%p;
	}
	return now;
}
void solve(){memset(vis,0,sizeof(vis));
	scanf("%lld%lld%lld%d",&n,&m,&k,&p);n--,m--;
	pw[0]=1;for(int i=1;i<=60;i++)pw[i]=pw[i-1]*2%p;
	pii res=dfs(60,1,1,1);
	cout<<(res.second-res.first*1ll*(k%p)%p+p)%p<<"\n";
}
int main(){
	int T;cin>>T;
	while(T--)solve();
    return 0;
}
```

---

## 作者：封禁用户 (赞：6)

# 题目
[传送门 to luogu](https://www.luogu.com.cn/problem/P4067)

# 思路
看了看大多数题解，似乎都是神仙的数位 $dp$ ？

本蒟蒻实在是没办法往那个方面想，所以给出了一种更加 ~~令人迷惑~~ 美好的做法。

> 声明：下文中的区间都只涉及整数。例如，$[a,b]$ 实际指 $[a,b]\cup\Bbb{Z}$ 。

#### 简单的小情况
如果 $n=2^k$ ，是否有非常舒服的做法呢？

给出这样一个定理：

$$\forall x\in[0,2^k),\{x\oplus r|r\in[0,2^k)\}=[0,2^k)$$

用大白话来说，一个小于 $2^k$ 的数，异或上 $2^k-1$ 以内的所有数，仍然得到这些数。

证明是极其简易的：异或的结果小于 $2^k$ ，且互不相同，只好是遍布 $[0,2^k)$ 。

所以，如果 $n=2^k$ ，可以直接发现，表中的所有值就是（ $a\times b$ 表示出现了 $a$ 次 $b$ ）：

$$m\times 0+m\times 1+m\times 2+\cdots+m\times (2^k-1)$$

#### 复杂的小局面
如果 $n\ne 2^k$ ，这能够难倒一直受虐、死者之心的小蒟蒻吗？

可以考虑将 $n$ 拆分一下，按照最高位分一个类。或者说，把这 $n$ 个数字，像在 $0/1\;Trie$ 树上一样，放在左右子树中。

$m$ 当然也可以这么做。然后绝招来了：__两两匹配，四个递归__！（~~还挺押韵的~~）

显然，两两匹配之后，结果是正确的。也就是说，将 $[0,n)$ 分成了 $A,B$ ，$m$ 则是 $C,D$ ，那么最后的答案，可以转化为 $\langle A,C\rangle,\langle A,D\rangle,\langle B,C\rangle,\langle B,D\rangle$ 四个相似的问题。

那么，我们选择最大的 $k$ ，满足 $2^k<n$ ，然后切开！

于是，__最高位的异或值就不归它管了__。这种在 $0/1\;Trie$ 树上的行走，当然是有这样性质的。

直接把高位已经得到的异或值丢进递归里面就可以了。

#### 综合的中和
我们已经有了思路，用 $f(x,n,m)$ 表示，已经得到的异或值是 $x$ ，$[0,n)\oplus[0,m)$ 作出的贡献（ $k$ 是需要被考虑的，作为全局变量）。

不妨设 $n\ge m$ 。如果 $n=2^k$ ，那么可以直接计算出答案：因为得到的结果一定是 

$$m\times(0+x),m\times (1+x),m\times(2+x),\cdots,m\times(n-1+x)$$

如果 $2^k<n<2^{k+1}$ ，那么将 $[0,n)$ 分解为 $[0,2^k),[2^k,n)$ ，再令 $r=\min(2^k,m)$ ，将 $[0,m)$ 分解为 $[0,r),[r,m)$ ，两两组合。在组合的时候，注意要给 $x$ 加上一个 $2^k$ ，并且将 $[2^k,n)$ 这种超过了 $2^k$ 的区间减掉一个 $2^k$ ——毕竟这个异或值已经累加到 $x$ 里了。

可是复杂度呢？这不是一个 $\mathcal T(n)=4\mathcal T(\frac{n}{2})+\mathcal O(1)$ 吗？

不是这样的。拆解一次，会拆出来 $2^k$ ，就变成 $\mathcal O(1)$ 的了。

所以，我们每次只会实际递归一次，复杂度仍然是 $\mathcal O(\log n)$ 的。

# 代码
- 计算等差数列要除以二，所以只能取模 $2P$ 。
- $m=0$ 只会是因为递归之前，$n\le r\vee m\le r$，没有实际意义，~~只能使代码变短~~。
- $i$ 相当于 $2^k$ 中的 $k$ ，亦可以理解为 $0/1\;Trie$ 上面的行走。

```cpp
#include <cstdio>
#include <iostream>
#include <vector>
using namespace std;
inline long long readint(){
	long long a = 0; char c = getchar(), f = 1;
	for(; c<'0'||c>'9'; c=getchar())
		if(c == '-') f = -f;
	for(; '0'<=c&&c<='9'; c=getchar())
		a = (a<<3)+(a<<1)+(c^48);
	return a*f;
}
inline void writeint(long long x){
	if(x < 0) putchar('-'), x = -x;
	if(x > 9) writeint(x/10);
	putchar((x%10)^48);
}

# define MB template < typename T >
MB void getMax(T &a,const T &b){ if(a < b) a = b; }
MB void getMin(T &a,const T &b){ if(b < a) a = b; }

const int LogN = 60;
typedef long long int_;
int P; int_ k;

int_ ans; // 答案
void solve(int_ now,int_ n,int_ m,int i=LogN){
	const int_ r = 1ll<<i>>1, all = (1ll<<i)-1;
	if(now+all <= k) return ; // 一定小于k
	if(n < m) swap(n,m); // 保持 n 大 m 小
	if(m <= 0) return ; // 不可能的情况！
	if(n == all+1){ // 简单的小情况
		if(now < k) // 有一些是不能用的
			n -= k-now, now = k;
		m %= P, n %= P<<1;
		ans = ((n*(n-1)>>1)%P*m+ans)%P;
		ans = ((now-k)%P*m%P*n+ans)%P;
		return ;
	}
	solve(now,n-r,m-r,i-1);
	solve(now^r,n-r,min(m,r),i-1);
	solve(now^r,min(n,r),m-r,i-1);
	solve(now,min(n,r),min(m,r),i-1);
}

int main(){
	int_ n, m;
	for(int T=readint(); T; --T){
		n = readint(), m = readint();
		k = readint(), P = readint();
		ans = 0, solve(0,n,m);
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：胡尔克HULK (赞：3)

先写个小程序模拟一下
```cpp
int main()
{
	int n,m;
	cin>>n>>m;
	for (int i=0;i<n;i++)
	{
		for (int ii=0;ii<m;ii++)
			cout<<setw(4)<<(i^ii);
		cout<<endl;
	}
}
```
然后可以得出类似这样的结果

   0   1   2   3   4   5   6   7
   
   1   0   3   2   5   4   7   6
   
   2   3   0   1   6   7   4   5
   
   3   2   1   0   7   6   5   4
   
   4   5   6   7   0   1   2   3
   
   5   4   7   6   1   0   3   2
   
   6   7   4   5   2   3   0   1
   
   7   6   5   4   3   2   1   0
   
发现规律：对于边长为2^n的正方形，每一行0~2^n-1各出现一次

而且，可以将这个正方形划分成四个边长为2^(n-1)的正方形，左上角和右下角的正方形完全相同，左下和右上的正方形完全相同，且左下和右上的正方形每个对应位置的数比左上和右下的正方形大2^(n-1)

有了这个规律，我们就可以从最开始的一个0推出整个图了，然后用递推的方式求解，每一步取能取到的最大边长为2^n的图（直接计算），把多余的边角加上（直接计算）然后把剩余部分（0为左上角的）推到左上角继续计算（递推）

code

```cpp
#include <iostream>
#include <iomanip>
using namespace std;
typedef long long ll;
ll s[80]={1},k,MOD=998244353,MXP;
ll nx2(ll c)
{
	ll i;
	for (i=0;s[i]!=0;i++)
		if (s[i]>c) return i-1;
	return MXP;
}
ll q(ll s,ll n)
{
	if (n>=s-1) return 0;
	if (n<=0)
		if (s%2==0)
			 return ((-n)%MOD*(s%MOD)%MOD+(s/2)%MOD*((s-1)%MOD))%MOD;
		else 
			return ((-n)%MOD*(s%MOD)%MOD+((s-1)/2)%MOD*(s%MOD))%MOD;
	if ((s-n)%2==0)
		 return ((s-n)/2)%MOD*((s-n-1)%MOD)%MOD;
	else return ((s-n-1)/2)%MOD*((s-n)%MOD)%MOD;
}
ll cc(ll n,ll m,ll k)
{
	ll ans;
//	cout<<n<<' '<<m<<' '<<k<<' ';
	if (n==0||m==0) return 0;
	if (n>m)
	{
		ll p=n;
		n=m;
		m=p;
	}
	ll nx=nx2(m);
//	cout<<s[nx];
	if (s[nx]>n){
		ans=q(s[nx],k)*(n%MOD)%MOD;
		ans+=cc(n,m-s[nx],k-s[nx]);
	}
	else
	{
		ans=((q(s[nx+1],k)-q(s[nx],k)+MOD)%MOD)*((n-s[nx]+m-s[nx])%MOD)%MOD;
		ans+=(q(s[nx],k)%MOD)*(s[nx]%MOD)%MOD;
		ans%=MOD;
		ans+=cc(m-s[nx],n-s[nx],k);
	}
	return ans%MOD;
}
int main()
{
	ll x,y;
	ll n,m,T;
	cin>>T;
	for (ll i=1;s[i-1]*2<=2e18;i++){
		s[i]=s[i-1]*2;
		MXP++;
	}
	while (T--){
	cin>>n>>m>>k>>MOD;
	cout<<cc(n,m,k)<<endl;
	}
}
```


---

## 作者：xujindong_ (赞：2)

存在简单的 1log 做法。

假设只有一个求和，对于 $i\in[0,n)$，我们可以把 $i\operatorname{xor}x$ 分为 $\operatorname{popcount(i)}$ 个区间：枚举 $i,x$ 的 LCP，在 $x$ 的某个为 $1$ 的位上钦定 $i$ 为 $0$，更低的位自由。则异或 $x$ 后更低的位仍然自由选，这一位及以上固定。区间和容易 $O(1)$ 算。

类似地，钦定 $i$ 的第 $a$ 位和 $j$ 的第 $b$ 位，不妨设 $a\geq b$，则 $a$ 位及以上固定，$a-1\sim b$ 位 $i$ 可以自由选，$b$ 位以下 $i,j$ 都自由选。异或 $x$ 后，$a+1$ 位以下都自由选，每个数会被算 $2^b$ 次。注意到这个区间只和 $\max(a,b)$ 和 $[a\ne b]$ 有关，因此最后只有 $O(\log n)$ 次区间求和。枚举 $\max(a,b)$，假设 $a>b$，则每个 $b$ 产生 $2^b$ 次，这个区间被算的次数就是 $m$ 低于 $a$ 位的部分，$a<b$ 同理，$a=b$ 单独算。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,mod,ans;
long long n,m,k;
int f(long long l,long long r){
  return r=max(r-k,0ll),l=max(l-k,0ll),((__int128)(l+r)*(r-l+1)/2)%mod;
}
int main(){
  cin>>t;
  while(t--){
    cin>>n>>m>>k>>mod;
    for(int i=max(__lg(n),__lg(m));i>=0;i--){
      if(n>>i&1||m>>i&1)ans=(ans+((n>>i&1)*(m&((1ll<<i)-1))+(m>>i&1)*(n&((1ll<<i)-1)))%mod*(f((n^m^1ll<<i)&~((1ll<<i)-1),(n^m^1ll<<i)|((1ll<<i)-1))))%mod;
      if(n>>i&1&&m>>i&1)ans=(ans+(1ll<<i)%mod*(f((n^m)&~((1ll<<i)-1),(n^m)|((1ll<<i)-1)))+mod)%mod;
    }
    cout<<ans<<'\n',ans=0;
  }
  return 0;
}
```

---

## 作者：mystic_qwq (赞：2)

给定 $n,m,k,p$。求 $\sum\limits_{i=1}^{n-1}\sum\limits_{j=1}^{m-1}(\max\{i\oplus j,k\}-k)$。

问题转化为求出 $(i,j)$ 使得 $i\oplus j>k$ 的数量 $S_1$ 和总和 $S_2$。则答案为 $S_2-k\cdot S_1$。

考虑用数位 DP。设 $f_{pos,N,M,kk}$ 表示考虑 $pos$ 及以下的位，$i$ 有没有选满，$j$ 有没有选满，$k$ 是否没有被当前选择的 $i\oplus j$ 超越（由于从高到低，若已经被超了则之后永远被超）。这样状态下，满足条件的数量以及总和。

思考数位低的会给高的带来怎样的贡献。首先，数量直接汇聚到高的里面，总和加上低位的和，之后若当前位存在 $[i\oplus j=1]$，则统计 低位的和$\times 2^{当前数位}$ 即可。于是我们定义一个 $\texttt{pair}$ 作为状态记录。分别为有多少对数满足 $(i\oplus j)>k$，以及 ta 的和。则贡献按照上述统计即可。在加和的时候考虑当前数位是否为 $1$，以及当前是第几位，就可以在结构体里包装贡献的过程。

令 $a,b,c$ 分别表示 $n,m,k$ 的当前位，则存在转移
$$f_{pos,N,M,kk}=\sum\limits_{i=0}^{N?a:1}\sum\limits_{j=0}^{M?b:1}[!kk\vee(i\oplus j)\ge c]\{f_{pos-1,N\wedge[i=a],M\wedge[j=b],kk\wedge[(i\oplus j)=c]},i\oplus j,pos\}$$

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
#define fi first
#define se second

ll n,m,k,p;

struct pii{
  int x,y;
  inline void operator+=(const tuple<pii,bool,int>&A){
    auto&[a,b,c]=A;
    (x+=a.x)%=p,(y+=a.y)%=p;
    if(b) (y+=(1ll<<c)%p*a.x%p)%=p;
  }
  explicit operator int() const{
    return (y-x*(k%p)%p+p)%p;
  }
};

pii f[64][2][2][2];
bool vis[64][2][2][2];
#define CO [pos][N][M][kk]
#define For(i,a,b) for(char i=a;i<=(b);++i)

inline pii dfs(int pos,bool N,bool M,bool kk){
  if(pos==-1) return {1,0};
  if(vis CO) return f CO; vis CO=1;
  f CO={0,0};
  bool a=n>>pos&1,b=m>>pos&1,c=k>>pos&1;
  For(i,0,N?a:1) For(j,0,M?b:1) if(!kk||(i^j)>=c)
    f CO+={dfs(pos-1,N&&i==a,M&&j==b,kk&&(i^j)==c),i^j,pos};
  return f CO;
}

void solve(){
  memset(vis,0,sizeof vis);
  cin>>n>>m>>k>>p,--n,--m;
  cout<<int(dfs(60,1,1,1))<<'\n';
}

main(){
  cin.tie(0)->sync_with_stdio(0);
  int T; cin>>T;
  while(T--) solve();
}
```

---

## 作者：an_ancient_ghoul (赞：1)

# [SDOI2016] 储能表题解

万机之神护佑我等！

## 题目描述

有一个 $n$ 行 $m$ 列的表格，行从 $0$ 到 $n-1$ 编号，列从 $0$ 到 $m-1$  编号。每个格子都储存着能量。最初，第 $i$ 行第 $j$ 列的格子储存着 $(i \oplus j)$ 点能量。所以，$k$ 个时间单位后，整个表格储存的总能量是

$$\sum_{i=0}^{n-1} \sum_{j=0}^{m-1} \max ((i  \oplus j)-k,0) \bmod{p} $$

计算这个值。

## Analysis

考虑 $ T = 5000 $，$ n \leq 10 ^ {18}  $，$ m \leq 10 ^ {18}  $，$ k \leq 10 ^ {18}  $，$ p \leq 10 ^ 9 $ 直接暴力 $\Theta(n)$  或者 $\Theta(\sqrt{n})$ 或者 $\Theta(\sqrt[3]{n})$ 是绝对不行的。

如此之大的数据，当然是要 $\Theta(\log_2{n})$ 啦！  
数位 dp：考虑对于每一位 $u$ 都有以 $f[u][higher\_n][higher\_m][lower\_k]$ 为是否卡住 $n$ 和 $m$ 的上界，贴着 $k$ 的下界的方案数。  
以 $b[u][higher\_n][higher\_m][lower\_k]$ 为对应的结果之和，从高到低递，从低到高归，最后统计最高位的结果。  
提前预处理出各位存好，dp 时直接枚举。  
答案即是 $f[1][1][1][1]-b[1][1][1][1]\bmod k$。

## Code
```cpp

#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<math.h>
#include<iostream>
#include<stack>
#include<map>
#include<list>
#include<unordered_map>
#include<vector>
#include<queue>
#include<deque>
#include <cstring>
#include <algorithm>
#include<set>
#include <cstdio>

//#include<bits/stdc++.h>
#define int long long
#define reg regisetr
#define maxn 75
using namespace std;
int t, n, m, k, p, hoschet;
//b为是否卡上界的异或和，f为方案数 
//[位数][卡n的上界][卡m的上界][卡k的下界] 
int b[maxn][2][2][2], f[maxn][2][2][2];
bool wm[maxn], wn[maxn], wk[maxn];
void dp(reg int u, reg bool higher_n, reg bool higher_m, reg bool lower_k)
{
	// 当前位数,是否卡n的上界,是否卡m的上界,是否卡k的下界
	//卡上界：指最大的n/m前u位和当前状态一样
	if (f[u][higher_n][higher_m][lower_k]) return;//减脂
	if (u > hoschet)
	{
		b[u][higher_n][higher_m][lower_k] = 0;
		f[u][higher_n][higher_m][lower_k] = 1;
		return;
	}
	reg int vb, vf, rn = (higher_n ? wn[u] : 1ll), rm = (higher_m ? wm[u] : 1ll), kw = wk[u];
	//卡到上界，就按照计算的上界取，没卡到就随意0/1
	for (reg int i = 0; i <= rn; i++)for (reg int j = 0; j <= rm; j++)
	{
		if (lower_k && ((i ^ j) < kw))continue;
		dp(u + 1, higher_n && (i == rn), higher_m && (j == rm), lower_k && ((i ^ j) == kw));
		vf = f[u + 1][higher_n && (i == rn)][higher_m && (j == rm)][lower_k && ((i ^ j) == kw)] % p;
		vb = b[u + 1][higher_n && (i == rn)][higher_m && (j == rm)][lower_k && ((i ^ j) == kw)] % p;
		f[u][higher_n][higher_m][lower_k] = (f[u][higher_n][higher_m][lower_k] + vf) % p;
		b[u][higher_n][higher_m][lower_k] = (b[u][higher_n][higher_m][lower_k] + ((i ^ j) << (hoschet - u)) % p * vf % p + vb) % p;
	}
}
signed main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> t;
	while (t--)
	{
		cin >> n >> m >> k >> p;
		n--, m--;
		memset(wn, 0, sizeof wn);
		memset(wm, 0, sizeof wm);
		memset(wk, 0, sizeof wk);
		memset(f, 0, sizeof f);
		memset(b, 0, sizeof b);
		hoschet = max((int)log2(n), max((int)log2(m), (int)log2(k))) + 1;
		for (reg int i = 1; i <= hoschet; i++) //从高到低倒着来
		{//
			wn[i] = (n & (1ll << (hoschet - i)));
			wm[i] = (m & (1ll << (hoschet - i)));
			wk[i] = (k & (1ll << (hoschet - i)));
		}
		//cout << "hoschet: " << hoschet << endl;
		dp(1, 1, 1, 1);
		cout << ((b[1][1][1][1] % p - k % p * f[1][1][1][1] % p) % p + p) % p << endl;
	}
	return 0;
}
//*/
```


---

## 作者：hgzxwzf (赞：1)

## [P4067](https://www.luogu.com.cn/problem/P4067)

### 解题思路：

问题可以转化为求 $\sum_{i=0}^{n-1}\sum_{j=0}^{m-1}[i\oplus j\ge k](i\oplus j-k)$。

按照数位 dp 的套路，开三维记录 $i$ 是否顶着 $n-1$ 取，$j$ 是否顶着 $m-1$ 取，$i\oplus j$ 是否压着 $k$ 取。

$f_{p,f1,f2,f3}$ 记录方案数，$g_{p,f1,f2,f3}$ 记录所以方案的贡献之和。

通过 $f_1,f_2,f_3$ 约束 $i,j$ 第 $p$ 位的取值，并通过 $i,j$ 第 $p$ 位的取值得到 $f_1',f_2',f_3'$，数位 dp 的套路，具体看代码。

设 $i_p,j_p$ 分别表示 $i,j$ 第 $p$ 位的取值。

$g_{p,f_1,f_2,f_3}\leftarrow g_{p,f_1,f_2,f_3}+g_{p,f_1',f_2',f_3'}+(i_p\oplus j_p)f_{p,f_1',f_2',f_3'}\times 2^p$；

$f_{p,f_1,f_2,f_3}\leftarrow f_{p,f_1,f_2,f_3}+f_{p+1,f_1',f_2',f_3'}$。

### Code：
```cpp
const int N=65;

#define pii pair<mint,mint>

pii dp[N][2][2][2];
bool vis[N][2][2][2];
mint mi[N];
LL n,m,k;

pii work(int p,int fn,int fm,int fk)
{
	if(p==-1) return mk(1,0);
	if(vis[p][fn][fm][fk]) return dp[p][fn][fm][fk];
	vis[p][fn][fm][fk]=1;
	int ln=fn?(n>>p&1):1,lm=fm?(m>>p&1):1,lk=(k>>p&1)&&fk;
	mint r1=0,r2=0;
	rep(i,0,ln)
		rep(j,0,lm)
		{
			if((i^j)<lk) continue;
			pii res=work(p-1,fn&&i==ln,fm&&j==lm,fk&&(i^j)==lk);
			r1+=res.fi,r2+=res.fi*(i^j)*mi[p]+res.se;
		}
	return dp[p][fn][fm][fk]=mk(r1,r2);
}

int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		memset(vis,0,sizeof(vis));
		scanf("%lld%lld%lld%d",&n,&m,&k,&mod);
		n--,m--;
		mi[0]=1;
		rep(i,1,N-1) mi[i]=mi[i-1]*2;
		pii res=work(60,1,1,1);
		printf("%d\n",res.se-res.fi*(k%mod));
	}
	return 0;
}

```


---

## 作者：Fzrcy (赞：0)

> 题意简述：求 $\sum_{i=0}^{n-1} \sum_{j=0}^{m-1} \operatorname{max} ((i \operatorname{xor} j)-k,0)$。

显然只有 $i \operatorname{xor} j \ge k$ 时对答案有贡献，因此答案可以改为：

$$(\sum_{i=0}^{n-1}\sum_{j=0}^{m-1}i \operatorname{xor} j [i \operatorname{xor} j\ge k])-(\sum_{i=0}^{n-1}\sum_{j=0}^{m-1}[i \operatorname{xor} j\ge k])$$

因此我们只需统计满足 $i \operatorname{xor} j\ge k$ 的点对异或值以及个数即可。

考虑数位 dp，设 $f_{i,j,k,l}$ 表示当前考虑到第 $i$ 位，已经填过的数 $x$ 是否紧贴 $n-1$，已经填过的数 $y$ 是否紧贴 $m-1$，当前异或值是否紧贴 $k$，将剩下未填的数填完的满足限制的方案数，$g_{i,j,k,l}$ 与 $f_{i,j,k,l}$ 类似，只不过存储的前 $i$ 位的异或和。

然后枚举 $x$、$y$ 填哪些数转移即可，具体可以看代码，这里不再阐述。

```cpp
// qwq
#include <bits/stdc++.h>
#define RG register
#define R RG int
#define inl inline
using ll=long long;
using namespace std;
struct info{ll num,sum;};
constexpr int N=70;
ll mo,dn[N],dm[N],dk[N];
info f[N][2][2][2];
bool ban[N][2][2][2];
info dfs(R now,bool onN,bool onM,bool nb){
    if(now==0)return {1,0};
    info& ret=f[now][onN][onM][nb];
    if(ban[now][onN][onM][nb])return ret;
    R xn=0,yn=(onN?dn[now]:1);
    R xm=0,ym=(onM?dm[now]:1);
    for(R x=xn;x<=yn;x++){
        for(R y=xm;y<=ym;y++){
            R d=x^y;if(nb&&d<dk[now])continue;
            info v=dfs(now-1,onN&&x==dn[now],onM&&y==dm[now],nb&&d==dk[now]);
            v.sum+=(1ll<<now-1)%mo*d%mo*v.num;
            (ret.num+=v.num)%=mo,(ret.sum+=v.sum)%=mo;
        }
    }
    return ban[now][onN][onM][nb]=1,ret;
}
void sol(){
    memset(ban,0,sizeof ban);
    memset(f,0,sizeof f);ll n,m,k;
    scanf("%lld%lld%lld%lld",&n,&m,&k,&mo);n--,m--;
    for(R i=0;i<60;i++)dn[i+1]=n>>i&1,dm[i+1]=m>>i&1,dk[i+1]=k>>i&1;
    info ans=dfs(60,1,1,1);
    printf("%lld\n",(ans.sum%mo-k%mo*ans.num%mo+mo)%mo);
}
int main(){
    int T;scanf("%d",&T);
    while(T--)sol();
    return 0;
}
```



---


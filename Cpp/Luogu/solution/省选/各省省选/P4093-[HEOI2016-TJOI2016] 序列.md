# [HEOI2016/TJOI2016] 序列

## 题目描述

佳媛姐姐过生日的时候，她的小伙伴从某宝上买了一个有趣的玩具送给他。

玩具上有一个数列，数列中某些项的值可能会变化，但同一个时刻最多只有一个值发生变化。现在佳媛姐姐已经研究出了所有变化的可能性，她想请教你，能否选出一个子序列，使得在**任意一种变化和原序列**中，这个子序列都是不降的？请你告诉她这个子序列的最长长度即可。

## 说明/提示

注意：每种变化最多只有一个值发生变化。

在样例输入中，所有的变化是：
```plain
1 2 3
2 2 3
1 3 3
1 1 3
1 2 4
```
选择子序列为原序列，即在任意一种变化中均为不降子序列。

对于 $20\%$ 数据，所有数均为正整数，且小于等于 $300$。

对于 $50\%$ 数据，所有数字均为正整数，且小于等于 $3000$。

对于 $100\%$ 数据，所有数字均为正整数，且小于等于 $10^5$。$1\le x\le n$。


## 样例 #1

### 输入

```
3 4 
1 2 3 
1 2 
2 3 
2 1 
3 4```

### 输出

```
3
```

# 题解

## 作者：小粉兔 (赞：59)

### 题意简述：

给定一个长度为 $n$ 的序列 $a$。

同时这个序列还可能发生变化，每一种变化 $(x_i,y_i)$ 对应着 $a_{x_i}$ 可能变成 $y_i$。

不会同时发生两种变化。

需要找出一个最长的子序列，使得这个子序列在任意一种变化下都是不降的。

只需要求出这个子序列的长度即可。

**注意：可以不发生任何变化。**

### 题解：

记 $f[i]$ 为以第 $i$ 项结尾的子序列最长长度。

则有转移：$f[i]=\max_{j<i}(f[j])+1$，同时还要满足 $maxval_j\le a_i$ 和 $a_j\le minval_i$。  
其中 $maxval_i$ 表示第 $i$ 项最大能变成的值，$minval_i$ 表示第 $i$ 项最小能变成的值。

按照项从小到大转移，形成了**天然的时间顺序**，同时还要满足两个偏序限制。

算上时间顺序，这是一个三维偏序问题，用 CDQ 分治 + 数据结构（我用了树状数组）就能解决。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

const int MN = 100005;
const int MC = 100000;

int N, M;
int A[MN], Mx[MN], Mn[MN];
int f[MN], Ans;
int p[MN];
inline bool cmp1(int i, int j) { return Mx[i] < Mx[j]; }
inline bool cmp2(int i, int j) { return A[i] < A[j]; }

int B[MN];
inline void Ins(int i, int x) { for (; i <= MC; i += i & -i) B[i] = max(B[i], x); }
inline void Clr(int i) { for (; i <= MC; i += i & -i) B[i] = 0; }
inline int Qur(int i) { int A = 0; for (; i; i -= i & -i) A = max(A, B[i]); return A;}

void CDQ(int lb, int rb) {
	if (lb == rb) {
		f[lb] = max(f[lb], 1);
		return;
	}
	int mid = lb + rb >> 1;
	CDQ(lb, mid);
	for (int i = lb; i <= rb; ++i)
		p[i] = i;
	sort(p + lb, p + mid + 1, cmp1);
	sort(p + mid + 1, p + rb + 1, cmp2);
	int j = lb;
	for (int i = mid + 1; i <= rb; ++i) {
		while (j <= mid && Mx[p[j]] <= A[p[i]]) {
			Ins(A[p[j]], f[p[j]]);
			++j;
		}
		f[p[i]] = max(f[p[i]], Qur(Mn[p[i]]) + 1);
	}
	for (int i = lb; i <= mid; ++i)
		Clr(A[i]);
	CDQ(mid + 1, rb);
}

int main() {
	int x, y;
	scanf("%d%d", &N, &M);
	for (int i = 1; i <= N; ++i)
		scanf("%d", &A[i]),
		Mx[i] = Mn[i] = A[i];
	for (int i = 1; i <= M; ++i)
		scanf("%d%d", &x, &y),
		Mx[x] = max(Mx[x], y),
		Mn[x] = min(Mn[x], y);
	CDQ(1, N);
	for (int i = 1; i <= N; ++i)
		Ans = max(Ans, f[i]);
	printf("%d\n", Ans);
	return 0;
}
```

---

## 作者：shadowice1984 (赞：43)

非常传统的一道cdq套dp的题目

如果熟练掌握cdq的话应该可以很快的敲出来？

## CDQ分治优化dp

先说什么是CDQ

其实cdq就是滚动式的树套树

还记得dp里有一个东西叫滚动数组优化吗？

滚动数组仅仅优化了空间却没有优化时间复杂度

cdq分治也是如此，相较于树套树，cdq分治并不会节约时间复杂度

相反，cdq分治的特点是省空间，从头到尾只有一个低维数据结构和被分治数组的空间开销，(以及一点系统栈的内存？)，以及比树套树少的常数和代码量

为什么cdq可以部分的替代树套树呢？

**因为cdq分治那个solve函数的本质是树套树外层树的中序遍历函数**

换句话来讲，如果我们只是需要树套树外层树的中序遍历函数的话，我们就可以使用cdq分治，在时间维度而不是在空间维度上生成这个树套树的外层部分，从而隐性的使用了一个树套树

那么下面我们以这个题为例讲解下CDQ分治的正确姿势吧(其实也不一定正确)

首先由于这道题本质上还是一个dp所以请先让我们推一发转移方程

令$Dp_{i}$以i为结尾的最长上升子序列长度(允许其中一个元素任意变换)

那么为了求$Dp_{i}$我们枚举上一个点是谁

所以大概长这样？

## $Dp_{i}=max(Dp_{j})+1$

中j同时满足下面3个限制

1.$j<=i$

2.$val_{j}<=min_{i}$

3.$max_{j}<=val_{i}$

后两个限制条件是我们枚举i和j那个变化之后产生的结果

(max和min表示的是一个元素可以变化的最大值和最小值)

那么我们发现max运算是允许乱序的

也就是说，只要你为每一个i求出了一个所有合法的j集合，就可以转移

至于求这个集合的过程，是随便的，你想怎么求就怎么求

那么我们现在只是处理l，r这一段区间的转移关系，假设我们使用了一些奥妙重重的手法使得l以前的dp值全部被求出并且也向l，r区间的点进行了转移

**我们希望望这个solve函数结束时，l,r内的dp值全部被求出**

 _(显然在只有一个点的时候这个点的dp值已经被求出可以直接return)_ 

所以我们现在只需要**考虑l，r之间点的转移关系**就行了

此时我们人为的将这个区间分为两半，同时我们递归的调用这个函数solve(l,mid)

这样因为我们调用了一次solve函数，所以l,mid之间的点已经被求出了

此时我们只考虑l,mid对mid，r之间的转移关系

发现**l，mid的下标全部小于mid，r之间的下标**，所以这一维的限制不存在了

所以我们把l，mid按val值排序，把mid，r按min值排序

此时我们枚举我们要要用l，mid中的点转移mid，r中的某一个点i

现在要使用一些奇技淫巧来消掉剩下的两位限制了

发现l,mid中可以转移到i的点，在按val排序之后是一个连续前缀，假设这是以j为结尾的前缀

此时我们发现j之前的点的val值全部小于等于i的min，所以第二维限制也不存在了

下面我们考虑第三维限制，发现是$max_{j}<=val_{i}$因此我们可以将j之前的所有点p都将各自的dp值插入到树状数组的$max_{p}$位置上，此时我们只需要查一发前缀最大值和i当前的dp值取个max就可以完成在l,mid范围内的转移了

由于我们发现i是按$min_{i}$排序的，所以我们可以保证j指针不会后退，树状数组里也不会删除点，因此我们的总复杂度是$O(LenlogLen)$的

但是我们并不可以就此返回，因为此时l，r内的dp值并没求完，但是l，mid内的值已经求好了，而且也向mid，r完成了转移，所以满足我们使用solve(mid，r)的条件了，此时我们可以使用一次solve(mid，r)来讲mid到r范围内的dp值求出

此时我们已经求出了l，r内的全部dp值，所以我们可以return了

如果你足够熟练的话很容易的就可以看出上述算法实际上就是对着dp值建了一棵线段树然后跑了一遍线段树的中序遍历然后动态的保存了下每个区间的dp值结果

我们solve函数其实就是考虑了线段树上3个节点的关系(l,r)(l,mid)(r,mid)

同时在每个solve函数结束的时刻，这个dp数组实际上存储了线段树这个节点的全部信息

所以我们最后要做的事就是调用一次solve(0,n)函数，求出最大的dp值而已

~~(废了那么多话其实代码只有50行)~~

上代码~

```
#include<cstdio>
#include<algorithm>
using namespace std;const int N=1e5+10;
struct nod{int val;int mi;int ma;int pos;int dp;}a[N];int n;int m;int res=1;
inline bool cmp1(const nod& a,const nod& b){return a.val<b.val;}//3个比较函数
inline bool cmp2(const nod& a,const nod& b){return a.mi<b.mi;}
inline bool cmp3(const nod& a,const nod& b){return a.pos<b.pos;}
struct data//离散化
{
    int v;int fr;int tp;
    friend bool operator <(data a,data b){return a.v<b.v;}
    friend bool operator ==(data a,data b){return a.v==b.v;}
}l[3*N];int rk[3*N];int ct;
struct trearray//树状数组
{
    int ta[3*N];
    inline void c(int x,int c){for(;x<=3*n;x+=x&(-x)){ta[x]=max(ta[x],c);}}
    inline void d(int x){for(;x<=3*n;x+=x&(-x)){ta[x]=0;}}
    inline int  q(int x){int r=0;for(;x>0;x-=x&(-x)){r=max(r,ta[x]);}return r;}
}ta;
void solve(int l,int r)//solve函数
{
    if(r-l==1){return;}int mid=(l+r)/2;
    solve(l,mid);sort(a+l+1,a+mid+1,cmp1);sort(a+mid+1,a+r+1,cmp2);
    for(int i=mid+1,j=l+1;i<=r;i++)//双指针+树状数组转移
    {for(;a[j].val<=a[i].mi&&j<=mid;j++){ta.c(a[j].ma,a[j].dp);}a[i].dp=max(a[i].dp,ta.q(a[i].val)+1);}
    for(int i=l+1;i<=mid;i++){ta.d(a[i].ma);}sort(a+mid+1,a+r+1,cmp3);solve(mid,r);//最后别忘了把mid到r恢复下
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){int t;scanf("%d",&t);a[i]=(nod){t,t,t,i,0};}
    for(int i=1;i<=m;i++)
    {int x;int t;scanf("%d%d",&x,&t);a[x].mi=min(a[x].mi,t);a[x].ma=max(a[x].ma,t);}
    for(int i=1;i<=n;i++)//离散化
    {l[++ct]=(data){a[i].val,i,0};l[++ct]=(data){a[i].mi,i,1};l[++ct]=(data){a[i].ma,i,2};}
    sort(l+1,l+3*n+1);rk[1]=1;
    for(int i=2;i<=3*n;i++){rk[i]=(l[i]==l[i-1])?rk[i-1]:i;}
    for(int i=1;i<=3*n;i++)
    {
        switch(l[i].tp)
        {
            case 0:{a[l[i].fr].val=rk[i];break;}
            case 1:{a[l[i].fr].mi=rk[i];break;}
            case 2:{a[l[i].fr].ma=rk[i];break;}
        }
    }a[1].dp=1;solve(0,n);//然后solve(0,n)就好了
    for(int i=1;i<=n;i++){res=max(res,a[i].dp);}
    printf("%d",res);return 0;//拜拜程序~
}
```

---

## 作者：ADay (赞：17)

[更好的阅读体验](https://www.cnblogs.com/aday526/p/solution-p4093.html)  

## Solution
这显然是求 $\mathsf{LIS}$ 的模板多了两维限制，转移方程为 $f_i=\max\limits_{j<i,a_i\ge mx_j,mn_i\ge a_j}f_j+1$，其中 $f_i$ 表示以 $i$ 结尾的最长子序列，$mx_i,mn_i$ 表示 $a_i$ 能变化到的最大值和最小值，因为介于 $mx_i$ 和 $mn_i$ 之间的数都没有用。  

对于方程的这三个限制，可以当三维偏序来做，每次用 $f_i$ 更新 $(a_i,mx_i)$ 矩形内的最大值，查询时查 $(mn_i,a_i)$ 内的最大值即可。  

实现的话，可以用 $\mathsf{CDQ}$ 分治或树套树，这里我用了二维树状数组，用 `pb_ds` 的哈希表 `gp_hash_table` 来实现类似的动态开点。
## Code
```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
const int N=1e5+5;
int n,m,mv,ans,a[N],mn[N],mx[N];
gp_hash_table<int,int>c[N];
inline void add(int x,int y,int v){
	for(int i=x;i<=mv;i+=i&-i)
		for(int j=y;j<=mv;j+=j&-j)
			c[i][j]=max(c[i][j],v);
}
inline int ask(int x,int y){
	int res=0;
	for(int i=x;i;i-=i&-i)
		for(int j=y;j;j-=j&-j)
			res=max(res,c[i][j]);
	return res;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",a+i),mv=max(mv,mx[i]=mn[i]=a[i]);
	for(int i=1,x,y;i<=m;i++){
		scanf("%d%d",&x,&y);
		mx[x]=max(mx[x],y);
		mn[x]=min(mn[x],y);
		mv=max(mv,mx[x]);
	}
	for(int i=1;i<=n;i++){
		int res=ask(mn[i],a[i])+1;
		add(a[i],mx[i],res);
		ans=max(ans,res);
	}printf("%d\n",ans);
	return 0;
}
```

---

## 作者：消失的海岸线 (赞：9)

丢个[博客](https://www.zgz233.xyz/2018/01/24/bzoj-4553-tjoi2016heoi2016%E5%BA%8F%E5%88%97/)链接。



记 $l_i$ 为 $i$ 能到的最小状态，$r_i$ 为最大。


变形的 $LIS$ ，考虑一个两个相邻的状态 $i$ 和 $j$ ， 什么情况 $j$ 能更新 $i$，即：


$j<i$

$a_j<a_i$


$a_j<l_i$


$r_j<a_i$


实际上发现第二条包含于三四条了。


那么三维偏序问题，写了个 CDQ 练手。由于时间限制比较松所以二维线段树和 2DT 也能过...


```cpp
#include <cmath>
#include <queue>
#include <cstdio>
#include <iomanip>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 100010
#define ll long long
using namespace std;
char xB[1<<15],*xS=xB,*xT=xB;
#define getchar() (xS==xT&&(xT=(xS=xB)+fread(xB,1,1<<15,stdin),xS==xT)?0:*xS++)
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
inline int Mn(int a,int b)
{return a<b?a:b;}
inline int Mx(int a,int b)
{return a>b?a:b;}
int n,m,p;
struct zgz
{
    int v,l,r,id;
    void read_in(int x)
    {v=l=r=read();id=x,p=Mx(p,v);}
}b[N],d[N];
inline bool cmpv(const zgz &a,const zgz &b)
{return a.v<b.v;}
inline bool cmpl(const zgz &a,const zgz &b)
{return a.l<b.l;}
inline bool cmpid(const zgz &a,const zgz &b)
{return a.id<b.id;}
int c[N];
void modify(int x,int v)
{
    for(;x<=p;x+=x&(-x))
    c[x]=Mx(c[x],v);
}
int ask(int x)
{
    int ret=0;
    for(;x;x-=x&(-x))
    ret=Mx(c[x],ret);
    return ret;
}
void clear(int x)
{
    for(;x<=p;x+=x&(-x))
    c[x]=0;
}
int f[N];
void CDQ(int l,int r)
{
    if(l==r)return ;
    int mid=(l+r)>>1;
    CDQ(l,mid);
    sort(b+l,b+mid+1,cmpv),sort(b+mid+1,b+r+1,cmpl);
    int i=l,j=mid+1;
    for(;j<=r;j++)
    {
        while(i<=mid&&b[i].v<=b[j].l)modify(b[i].r,f[b[i].id]),i++;
        f[b[j].id]=Mx(f[b[j].id],ask(b[j].v)+1);
    }
    while(i>l)i--,clear(b[i].r);
    sort(b+l,b+r+1,cmpid);
    CDQ(mid+1,r);
}
int ans;
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;i++)b[i].read_in(i);
    for(int i=1;i<=m;i++)
    {
        int x=read(),y=read();
        b[x].l=Mn(b[x].l,y),b[x].r=Mx(b[x].r,y);
    }
    for(int i=1;i<=n;i++)f[i]=1;
    CDQ(1,n);
    for(int i=1;i<=n;i++)ans=Mx(ans,f[i]);
    printf("%d\n",ans);
}
```

---

## 作者：lao_wang (赞：7)

## 修改

1. 偏序条件错误（9.4）。
2. 优化原代码空间，但思路一致。

## 题目大意

寻找一个子序列，使得该序列在**任何一个数字的一次修改或不修改**后为单调不降的最大长度。

## 正文

显然我们可以将其看作一个带三维偏序条件的求最长不降子序列的 dp，偏序条件为：

1. $max _i \leq a_j$。
2. $a_i \leq min_j$。
3. $i \leq j$。

其中 $a_i$ 为原序列元素，$max _i$ 为修改第 $i$ 项时的最大值（初始化为 $a_i$），$min _i$ 为修改第 $i$ 项时的最小值（初始化为 $a_i$）。

（但是本题解的重点不在此所以就不过多做解释。）

这里我使用的方法是一个神奇的写法，该写法近似于线段树套线段树但查询区间第 $k$ 大时复杂度为 $O(n \log^2 n)$，空间复杂度为 $O(n \log^2 n)$。

~~该算法应该是离线算法但是被我用可持久化数组记录状态所以在线了。~~

不在线前代码就为[三维偏序板子](https://www.luogu.com.cn/article/6xhv7leg)，只是将计数的树状数组改为求最大值的线段树。

但显然如果直接跑是会 WA 的。

我们会发现每个答案（除排序后的第一个）的求解对上几个满足该偏序条件的 dp 有依赖（也就是，如果要求 $dp_i$ 必须先求出排序后的 $1\sim i-1$ 的 dp 值）。

为什么会对后面的 dp 值会产生依赖？

显然使用 cdq 完成这道题的过程为：

1. $solve(l,mid)$。
2. 左区间对右区间的贡献。
3. $solve(mid+1,r)$

而使用整体二分完成这道题的过程因为：

1. 求 $mid$ 并划分区间。
2. 左区间对右区间的贡献。（区间划分依据是值域，且答案不会修改在操作数组上）
3. $solve(l,mid)$，$solve(mid+1,r)$。

也就是一个是自下而上的分治。

一个是自上而下的分治。

所以我们需要在线处理。

我们可以将其理解为 $N$ 次询问，每次询问第 $i$ 个的 dp 值且强制在线。

如果真的执行 $N$ 次整体二分，会发现有许多的区间分化、最大值是重复的，我们就可以尝试将其记录下来。

然后我们会发现，可以建 $\log n$ 个可持久化线段树，每层的 $mid$ 都先连向空树，之后每个关于 $mid$ 分出的区间对根节点为 $root_{mid}$ 修改，$root_{mid}$ 修改为现在的根节点（详见代码）。

查询就依据原三维偏序的题解写就好了。

~~有什么问题可以私信我，语文太辣鸡啦。~~

## 代码 1

```cpp
#include<bits/stdc++.h>
#define N 212345
#define re register
#define inf 2147483647
using namespace std ;
int n , tr_tot[20] , root_tot[20] , q=0 , cnt=0 , maxn[N] , minn[N] , ans=1 , a[N] ;
struct tree{
	int maxn , ls , rs ;
}tr[19][200005+100000*19];
unordered_map<int,int> all_mid[20] ;
inline int made(int num,int l,int r,int floor){
	if(l==r) return num ;
	re int mid=(l+r)>>1 ;
	tr[floor][num].ls = made(++tr_tot[floor],l,mid,floor) ;
	tr[floor][num].rs = made(++tr_tot[floor],mid+1,r,floor) ;
	return num ;
}
inline int change(int last,int now,int l,int r,int floor,int k,int x){
	if(l==r){
		tr[floor][now].maxn = x ;
		return now ;
	}
	re int mid=(l+r)>>1 ;
	if(mid>=k) tr[floor][now].ls = change(tr[floor][last].ls,++tr_tot[floor],l,mid,floor,k,x) , tr[floor][now].rs = tr[floor][last].rs ;
	else tr[floor][now].rs = change(tr[floor][last].rs,++tr_tot[floor],mid+1,r,floor,k,x) , tr[floor][now].ls = tr[floor][last].ls ;
	tr[floor][now].maxn = max(tr[floor][tr[floor][now].ls].maxn,tr[floor][tr[floor][now].rs].maxn) ;
	return now ;
}
inline int find_max(int num,int l,int r,int L,int R,int floor){
	if(L>=l&&R<=r) return tr[floor][num].maxn ;
	re int mid=(L+R)>>1 , ans=0 ;
	if(mid>=l) ans = max(ans,find_max(tr[floor][num].ls,l,r,L,mid,floor)) ;
	if(mid<r) ans = max(ans,find_max(tr[floor][num].rs,l,r,mid+1,R,floor)) ;
	return ans ;
}
inline int ask(int l,int r,int x,int y,int floor,int ans){
	if(l>r) return ans ;
	re int mid=(l+r)>>1 ;
	if(l==r) return max(ans,all_mid[floor].count(mid)?find_max(all_mid[floor][mid],1,y,1,100000,floor):0);
	if(mid>=x) return ask(l,mid,x,y,floor+1,ans) ;
	else return ask(mid+1,r,x,y,floor+1,max(ans,all_mid[floor].count(mid)?find_max(all_mid[floor][mid],1,y,1,100000,floor):0)) ;
}
inline void insert(int l,int r,int x,int y,int dp,int floor){
	if(l>r) return ;
	re int mid=(l+r)>>1 ;
	if(!all_mid[floor][mid]) all_mid[floor][mid] = 1 ;
	if(mid>=x){
		re int temp=all_mid[floor][mid] ;
		re int next=all_mid[floor][mid] = ++tr_tot[floor] ;
		change(temp,next,1,100000,floor,y,dp) , (l!=r?insert(l,mid,x,y,dp,floor+1):(void)0) ;
	}else insert(mid+1,r,x,y,dp,floor+1) ;
}
inline int read(){
    int x=0 , f=1 ;
    char a=getchar() ;
    while(!(a>='0'&&a<='9')){
        if(a=='-') f = -f ;
        a = getchar() ;
    }
    while(a>='0'&&a<='9'){
        x *= 10 ;
        x += a-'0' ;
        a = getchar() ;
    }
    return x*f ;
}
signed main(){
    n = read() , q = read() ;
	for(re int i=1;i<=18;i++){
		tr_tot[i] = 1 ;
		made(1,1,100000,i) ;
	}
	for(re int i=1;i<=n;i++) a[i] = minn[i] = maxn[i] = read() ;
	for(re int i=1;i<=q;i++){
		re int x=read() , w=read() ;
		maxn[x] = max(w,maxn[x]) ;
		minn[x] = min(w,minn[x]) ;
	}
	insert(1,100000,maxn[1],a[1],1,1) ;
	for(re int i=2;i<=n;i++){
		re int temp=ask(1,100000,a[i],minn[i],1,0)+1 ;
		insert(1,100000,maxn[i],a[i],temp,1) ;
		ans = max(ans,temp) ;
	}
	cout << ans ;
	return 0 ;
}
```

思路一致，只是使用了平衡树节省空间。

如果需要修改原节点的贡献（也就是遇到待修的情况），只需要将原节点移到另一个平衡树上。

## 代码 2

```cpp
#include<bits/stdc++.h>
#define N 112345
#define re register
using namespace std ;
int n , q , maxn[N] , minn[N] , cnt=0 , a[N] , ans=0 ;
unordered_map<int,int> all_mid[19] ;
struct node{
	int num , dp , down ;
	int pri ;
	int l , r ;
}t[N*19];
inline void update(int u){
	t[u].down = max(t[t[u].l].down,max(t[t[u].r].down,t[u].dp)) ;
}
inline void split(int u,int x,int &l,int &r){
	if(!u){
		l = r = 0 ;
		return ;
	}
	if(t[u].num<=x){
		l = u ;
		split(t[u].r,x,t[u].r,r) ;
	}else{
		r = u ;
		split(t[u].l,x,l,t[u].l) ;
	}
	update(u) ;
}
inline int merge(int l,int r){
	if(!l||!r) return l+r ;
	if(t[l].pri<t[r].pri){
		t[l].r = merge(t[l].r,r) ;
		update(l) ;
		return l ;
	}else{
		t[r].l = merge(l,t[r].l) ;
		update(r) ;
		return r ;
	}
}
inline int read(){
    re int x=0 ;
	re char a=getchar() ;
    while(!(a>='0'&&a<='9')){
        a = getchar() ;
    }
    while(a>='0'&&a<='9'){
        x *= 10 ;
        x += a-'0' ;
        a = getchar() ;
    }
    return x ;
}
inline int newnode(int root,int x,int dp){
	re int l , r ;
	split(root,x,l,r) ;
	++cnt ;
	t[cnt].l = t[cnt].r = 0 ;
	t[cnt].num = x ;
	t[cnt].down = t[cnt].dp = dp ;
	t[cnt].pri = rand() ;
	re int temp=merge(l,cnt) ;
	root = merge(temp,r) ;
	return root ;
}
inline void insert(int l,int r,int floor,int x,int y,int dp){
	if(l>r) return ;
	re int mid=(l+r)>>1 ;
	if(mid>=x){
		re int temp=all_mid[floor][mid] ;
		if(!temp){
			cnt++ ;
			t[cnt].l = t[cnt].r = 0 ;
			t[cnt].down = t[cnt].dp = dp ;
			t[cnt].num = y ;
			all_mid[floor][mid] = cnt ;
		}else all_mid[floor][mid] = newnode(temp,y,dp) ;
		if(l!=r) insert(l,mid,floor+1,x,y,dp) ;
	}else insert(mid+1,r,floor+1,x,y,dp) ;
}
inline int find_max(int root,int x){
	re int l , r , ans=0 ;
	split(root,x,l,r) ;
	ans = t[l].down ;
	root = merge(l,r) ;
	return ans ;
}
inline int ask(int l,int r,int floor,int x,int y,int ans){
	if(l>=r) return ans ;
	re int mid=(l+r)>>1 ;
	if(mid>=x) return ask(l,mid,floor+1,x,y,ans) ;
	else return ask(mid+1,r,floor+1,x,y,max(ans,all_mid[floor].count(mid)?find_max(all_mid[floor][mid],y):0)) ;
}
signed main(){
	srand(time(NULL)) ;
	n = read() , q = read() ;
	for(re int i=1;i<=n;i++) a[i] = minn[i] = maxn[i] = read() ;
	for(re int i=1;i<=q;i++){	
		re int x=read() , w=read() ;
		maxn[x] = w>maxn[x]?w:maxn[x] ;
		minn[x] = w<minn[x]?w:minn[x] ;
	}
	insert(1,100001,1,maxn[1],a[1],1) ;
	for(re int i=2;i<=n;i++){
		int temp=ask(1,100001,1,a[i]+1,minn[i],0)+1 ;
		insert(1,100001,1,maxn[i],a[i],temp) ;
		ans = max(ans,temp) ;
	}
	cout << ans ;
	return 0 ;
}
```

---

## 作者：attack (赞：7)

这道题是DP应该不难看出来。

$dp[i]$表示选择$i$以后所能形成的满足条件的子序列的最大值

转移的时候枚举前面的点$(j)$。

设$MX[i]$表示$i$号位置能变成的最大值，$MI[i]$表示$i$号位置能变成的最小值，$a$为原序列

这样转移的时候会有两个限制条件

$a[i]>=MX[j]$ && $MI[i]>=a[j]$

这很明显是个二维偏序问题嘛，用CDQ树套树什么的都可以搞。

树套树的话，将$a$抽象为$x$轴，将$MX$抽象为$y$轴

转移的时候我们实际是在左下角为$(0,0)$，右上角为$MI[i],a[i]$的矩阵中查最大值

每次转移对答案的贡献的话实际上只是改变了$a[i],mx[i]$的值

然后就能很自然的想到树套树了，线段树套线段树或者树状数组套线段树都可以搞

 

后者常数小一些

线段树的数组一定要开的足够大！！！！


```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int MAXN=6*1e6+10;
const int MAXNN=1e5+10;
const int INF=1e8+10;
inline int read()
{
    char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
int root[MAXN],N,M,MX[MAXNN],MI[MAXNN],a[MAXNN];
struct S
{
	struct node
	{
		int ls,rs,mx;
	}T[MAXN];
	int tot;
	int query(int now,int ll,int rr,int pos)
	{
		if(ll==rr) 
			return T[now].mx;
		int mid=ll+rr>>1;
		if(pos<=mid) 
			return query(T[now].ls,ll,mid,pos);
		else 
			return max( T[T[now].ls].mx , query(T[now].rs,mid+1,rr,pos));	
	}
	void change(int &now,int ll,int rr,int pos,int val)
	{
		if(!now) now=++tot;
		T[now].mx=max(T[now].mx,val);
		if(ll==rr) return ;
		int mid=ll+rr>>1;
		if(pos<=mid) change(T[now].ls,ll,mid,pos,val);
		else 		 change(T[now].rs,mid+1,rr,pos,val);
	}
}tree;
struct B
{ 
	int N;
	int Tree[MAXNN];
	int lowbit(int p) {return p&(-p);}
	int Query(int k,int val)
	{
		int ans=0;
		while(k) 
		{
			ans=max(ans,tree.query(root[k],1,N,val));
			k-=lowbit(k);
		}
		return ans;
	}
	void Change(int k,int pos,int val)
	{
		while(k<=N)
		{
			tree.change(root[k],1,N,pos,val);
			k+=lowbit(k);
		}
	}
}BIT;
int main()
{
	//freopen("heoi2016_seq.in","r",stdin);
	//freopen("heoi2016_seq.out","w",stdout);
	N=read();M=read();
	for(int i=1;i<=N;i++) MX[i]=MI[i]=a[i]=read();
	for(int i=1;i<=M;i++)
	{
		int x=read(),y=read();
		MX[x]=max(MX[x],y);BIT.N=max(BIT.N,MX[x]);
		MI[x]=min(MI[x],y);
	}
	int ans=0;
	for(int i=1;i<=N;i++)
	{
		int now=BIT.Query(MI[i],a[i])+1;
		BIT.Change(a[i],MX[i],now);
		ans=max(ans,now);
	}
	printf("%d",ans);
	return 0;
}
```

 

---

## 作者：撤云 (赞：6)

### [$$blog$$](https://www.cnblogs.com/hbxblog/p/10253236.html)
---
### 题目链接
[戳这](https://www.luogu.org/problemnew/show/P4093)

### Solution 

首先考虑最暴力的dp
我们设:
$f[i]$表示选择$i$以后所能形成的满足条件的子序列的最大值
$minx[i]$表示$i$能转换为的最小值
$maxx[i]$表示$i$能转换为的最大值

于是转移的条件显然了:
1. $i>j$
2. $minx[i]>=a[j]$
3. $a[i]>=maxx[i]$

对于暴力直接枚举j转移就好了,但却只有50分,想想正解。
条件很明显是三维偏序问题啊。我们可以随便用一些数据结构：
如: cdq分治,树套树什么的。这里就不详细介绍了

### code
线段树+树状数组
``` cpp
#include<bits/stdc++.h>
#define rg register
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
int read() {
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
	while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
	return f*x;
}
struct node {
	int l,r,v;
} a[100001*100];
int tot,root[100010];
void update(int &k,int l,int r,int pos,int v) {
	if(k==0)
		k=++tot;
	a[k].v=max(a[k].v,v);
	if(l==r)
		return ;
	int mid=(l+r)>>1;
	if(pos<=mid) update(a[k].l,l,mid,pos,v);
	else update(a[k].r,mid+1,r,pos,v);
}
int find(int k,int l,int r,int begin,int end) {
	if(k==0)
		return 0;
	if(l==begin&&r==end)
		return a[k].v;
	int mid=(l+r)>>1;
	if(end<=mid)
		return find(a[k].l,l,mid,begin,end);
	else if(begin>mid)
		return find(a[k].r,mid+1,r,begin,end);
	else return max(find(a[k].l,l,mid,begin,mid),find(a[k].r,mid+1,r,mid+1,end));
}
#define lowbit(x) (x&(-x))
void add(int x,int y,int v) {
	while(x<=100005)
		update(root[x],1,100005,y,v),x+=lowbit(x);
}
int sum(int x,int y) {
	int js=0;
	while(x)
		js=max(find(root[x],1,100005,1,y),js),x-=lowbit(x);
	return js;
}
int b[100010],minx[100010],maxx[100010];
int main() {
	int n=read(),m=read(),x,y,ans=0;
	for(int i=1; i<=n; i++)
		b[i]=minx[i]=maxx[i]=read();
	for(int i=1; i<=m; i++)
		x=read(),y=read(),maxx[x]=max(maxx[x],y),minx[x]=min(minx[x],y);
	for(int i=1; i<=n; i++) {
		int js=sum(minx[i],b[i])+1;
		ans=max(ans,js);
		add(b[i],maxx[i],js);
	}
	cout<<ans;
}
```



---

## 作者：夏色祭 (赞：5)

看上去就是可以dp的样子。

设$dp_{i}$为以i结尾的最长不下降序列。

易得:$dp_{i}$ = $max(dp_{j})+1$ $(j<=i$&&$Max_{j}<=a_{i}$&&$a_{j}<=Min_{i})$

$Max_{i}$和$Min_{i}$表示第i个点所有变化中的最大值和最小值。

我们考虑用一个什么东西来维护这个dp。

我的第一反应是树状数组套动态开点线段树，而且写那玩意应该也不会太长。

突然想到最近学了CDQ。

于是讲下CDQ怎么搞。

因为有两个两边不是同一个数组的条件，所以我们在solve的时候，要对$[l,mid]$和$[mid+1,r]$的根据不同的两个数组sort下，然后用个树状数组维护前缀max，算下左边对右边的贡献。

然后因为是dp，所以我们不能直接分治$[l,mid]$和$[mid+1,r]$然后合并，我们应该先分治$[l,mid]$然后算好$[l,mid]$对$[mid+1,r]$的贡献，然后再去分治$[mid+1,r]$ （记得去做$[mid+1,r]$前先把数组$[mid+1,r]$恢复）

具体代码可以见我[博客](http://www.cnblogs.com/zykykyk/p/9073893.html)

---

## 作者：s_a_b_e_r (赞：4)

我们设$maxv_i$为第$i$个数变化的最大值;$minv_i$为第$i$个数变化的最小值,$a_i$位原来的数值

则题目要求转化为,求一个最长的序列,使一下条件满足
- $j<i$
- $max(a_j,maxv_j) \le a_i$
- $a_j\le min(a_i,minv_i)$

那这种不等式问题就能转化为二维数点问题

对于每一个j,我们每一次就可以在平面内加一个坐标为$(maxv_j,a_j)$的权值为$dp_j$点,对于每一次转移,可以从$(0,0)$到$(a_i,minv_i)$中找到一个点权最大的点,当前点答案就是找到点的权值+1。

找点就能用很多数据结构维护,cdq分制树套树,k-d tree都可以,这里我用了**树状数组套treap**,相比于套动态开点线段树,平衡树比线段树空间更小,空间复杂度$O(nlogn)$

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<stack>
#include<vector>
#include<cstring>
#include<queue>
#include<bitset>
using namespace std;
const int maxn=150000+23333;
typedef long long ll;
inline int read(){
    int an=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch<='9'&&ch>='0'){an=an*10+(ch^48);ch=getchar();}
    return an*f;
}
/*
j<i
a_j<a_i
a_j<min_{a_i}
max_{a_j}<a_i
f_i=max(f_i,f_j+1)
*/
int n,m;
int a[maxn],b[maxn],c[maxn],maxv;
int dp[maxn];
struct Treap{
    int ran[maxn<<3],l[maxn<<3],r[maxn<<3],v[maxn<<3],w[maxn<<3],cnt,ma[maxn<<3];
    inline void update(int k){ma[k]=max(ma[r[k]],max(w[k],ma[l[k]]));}
    inline void l_change(int &k){int t=r[k];r[k]=l[t];l[t]=k;update(k);update(t);k=t;}
    inline void r_change(int &k){int t=l[k];l[k]=r[t];r[t]=k;update(k);update(t);k=t;}
    inline void insert(int &k,int x,int val){
        if(!k){cnt++;k=cnt;ran[k]=rand();ma[k]=w[k]=val;v[k]=x;return;}
        else if(v[k]==x)w[k]=max(w[k],val);
        else if(x<v[k]){insert(l[k],x,val);if(ran[l[k]]<ran[k])r_change(k);}
        else {insert(r[k],x,val);if(ran[r[k]]<ran[k])l_change(k);}
        update(k);
    }
    inline int query(int k,int x){
        int re=0;
        for(;k;){
            if(v[k]>x)k=l[k];
            else re=max(re,max(ma[l[k]],w[k])),k=r[k];
        }
        return re;
    }\\前驱最大
}t;
struct BIT{
    int root[maxn];
    inline int query(int k,int x){
        int re=0;
        for(;k;k-=k&-k)
        re=max(re,t.query(root[k],x));
        return re;
    }
    inline void add(int k,int x,int val){
        for(;k<=maxv;k+=k&-k)t.insert(root[k],x,val);
    }
}T;
int ans;
int main(){
    srand(233333);
    n=read();m=read();
    for(int i=1;i<=n;i++)b[i]=c[i]=a[i]=read();
    for(int i=1;i<=m;i++){
        int x=read(),y=read();
        b[x]=min(b[x],y);c[x]=max(c[x],y);
    }
    for(int i=1;i<=n;i++)maxv=max(maxv,c[i]);
    for(int i=1;i<=n;i++){
        int x=T.query(b[i],a[i]);
        dp[i]=x+1;
        T.add(a[i],c[i],dp[i]);
        ans=max(ans,dp[i]);
    }
    cout<<ans;
    return 0;
}
```
~~树套树就是一中思想,具体实现要靠自己领悟~~

---

## 作者：Rorschachindark (赞：3)

# 序列
[题目传送门](https://www.luogu.com.cn/problem/P4093)
## 思路
我们可以设$l_i,r_i,v_i$分别表示每个点可以取的最小值，最大值，原值。

由于每个序列只能改一个点，所以我们可以列出$dp$方程:

$$dp[i]=\max\{dp[j]\}+1,i>j\bigvee l_i\geq v_j\bigvee v_i \geq r_j$$

然后我们发现时间这一维度是一个天然的维度，我们不用管它，然后可以直接用$\text {cdq}$分治优化这个$\text {dp}$了，具体见代码。

话说这是我接触的第一道$\text {cdq}$分治优化$\text {dp}$。。。果然还是我菜了。
## $\text {Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define MAXN 100005

int n,m;

class Bit_tree
{
	private:
		int bit[MAXN];
		int lowbit (int &x){return x & (-x);}
	public:
		void clearback (int pos){for (Int i = pos;i <= n;i += lowbit (i)) bit[i] = 0;}
		void update (int pos,int x){for (Int i = pos;i <= n;i += lowbit (i)) bit[i] = max (bit[i],x);}
		int query (int pos){int ans = 0;for (Int i = pos;i;i -= lowbit (i)) ans = max (ans,bit[i]);return ans;}
}Tree;

struct node
{
	int v,l,r,Index;//分别每个点的原权值，最大权值，最小权值，编号 
}a[MAXN];

int dp[MAXN];

bool cmpv (node A,node V){return A.v < V.v;}
bool cmpl (node A,node V){return A.l < V.l;}
bool cmpid (node A,node V){return A.Index < V.Index;}

void cdq (int l,int r)
{
	if (l == r) return ;
	int mid = (l + r) >> 1;
	cdq (l,mid);
	sort (a + l,a + mid + 1,cmpv),sort (a + mid + 1,a + r + 1,cmpl);
	int i = l,j = mid + 1;
	for (;j <= r;++ j)
	{
		while (i <= mid && a[i].v <= a[j].l) Tree.update (a[i].r,dp[a[i].Index]),i ++;
		dp[a[j].Index] = max (dp[a[j].Index],Tree.query (a[j].v) + 1);
	} 
	while (i > l) Tree.clearback (a[-- i].r);
	sort (a + mid + 1,a + r + 1,cmpid);
	cdq (mid + 1,r);
}

int read ()
{
	int x = 0;char c = getchar();int f = 1;
	while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}
	while (c >= '0' && c <= '9'){x = (x << 3) + (x << 1) + c - '0';c = getchar();}
	return x * f;
}

void write (int x)
{
	if (x < 0){x = -x;putchar ('-');}
	if (x > 9) write (x / 10);
	putchar (x % 10 + '0');
}

signed main()
{
	n = read (),m = read ();
	for (Int i = 1;i <= n;++ i) a[i].v = a[i].l = a[i].r = read (),a[i].Index = i;
	for (Int i = 1;i <= m;++ i)
	{
		int x = read (),y = read ();
		a[x].l = min (a[x].l,y),a[x].r = max (a[x].r,y);
	}
	for (Int i = 1;i <= n;++ i) dp[i] = 1;
	cdq (1,n);
	int maxn = 0;
	for (Int i = 1;i <= n;++ i) maxn = max (maxn,dp[i]);
	write (maxn),putchar ('\n');
	return 0;
}
```

---

## 作者：Jμdge (赞：3)

这道题原来很水的？

# noteskey

一开始以为是顺序的 m 个修改，然后选出一段最长子序列使得每次修改后都满足不降

这 TM 根本不可做啊！ 于是就去看题解了，然后看到转移要满足的条件的我发出了黑人问号...

然后才发现原来是求的子序列是满足任意一次修改后不降...

于是列出两（san）个条件式子，就可以 CDQ 切掉了 QWQ

> $j<i$

> $a_j<min_i$

> $max_j<a_i$

这里的 max 和 min 就是某个位置上出现过的最 大/小 值



# watch out

需要注意的就是 CDQ 先处理左半部分再处理当前部分再处理右半部分，否则左半部分对右半部分的贡献就会出锅


还有就是看清楚题目，别交错题，我就是那个交错题 RE 了十几次的...


# code

可能某个合并还有优化的空间？【雾

```cpp
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define ll long long
using namespace std;
const int M=1e5+3;
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline bool cmax(int& a,int b){return a<b?a=b,1:0;}
inline bool cmin(int& a,int b){return a>b?a=b,1:0;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,m,p,ans,f[M],c[M];
struct node{ int x,l,r,id;
	inline void init(int iid){
		x=l=r=read(),id=iid,cmax(p,x);
	}
}a[M];
inline bool cmpx(node& a,node& b){return a.x<b.x;}
inline bool cmpl(node& a,node& b){return a.l<b.l;}
inline bool cmpid(node& a,node& b){return a.id<b.id;}
inline void clear(int x){for(;x<=p;x+=x&-x) c[x]=0;}
inline void update(int x,int d){for(;x<=p;x+=x&-x) cmax(c[x],d);}
inline int query(int x,int s=0){for(;x;x^=x&-x) cmax(s,c[x]);return s;}
void CDQ(int l,int r){ if(l==r) return ; int mid=(l+r)>>1;
	CDQ(l,mid),sort(a+l,a+1+mid,cmpx),sort(a+1+mid,a+1+r,cmpl);
	Rg int i=l,j=mid+1;
	for(;j<=r;++j){
		while(i<=mid&&a[i].x<=a[j].l)
			update(a[i].r,f[a[i].id]),++i;
		cmax(f[a[j].id],query(a[j].x)+1);
	}
	while(i>l) --i,clear(a[i].r); j=r,i=l;
	sort(a+l,a+1+r,cmpid);
	CDQ(mid+1,r);
}
int main(){ n=read(),m=read(); Rg int x,y;
	fp(i,1,n) a[i].init(i),f[i]=1;
	fp(i,1,m) x=read(),y=read(),
		cmin(a[x].l,y),cmax(a[x].r,y);
	CDQ(1,n); fp(i,1,n) cmax(ans,f[i]);
	return !printf("%d\n",ans);
}
```


---

## 作者：SamariumPhosphide (赞：2)

首先，序列中每个位置都有一个变化后的最大值以及一个变化后的最小值。设第 $i$ 位的值的最大值位 $max_i$， 最小值为 $min_i$，原本的值为 $o_i$。那么为了保证第 $i$ 个数无论怎样变化都小于第 $j$ 个数，那么需要保证：

+ $o_i<min_j$
+ $max_i<o_j$

于是我们愉快的发现这就是求三维偏序求 LIS。于是直接套用 cdq 分治。在计算左部对右部贡献的时候，直接更新右边的 dp 数组即可。

**细节：注意要先算左边，然后更新右边，最后再递归右边。**

原因很简单，在递归右面的时候，使用了右面的部分数据来更新右面的另一半数据。而尚未计算左边对右边贡献时，右边的 dp 数组尚未更新，不能用来计算其它的数据。

[Code Here](https://www.luogu.com.cn/paste/k65l6i5j)

---

## 作者：hzoi_zxb (赞：2)

## 题意：

最长上升子序列，不过是永久最长上升子序列而且每次变化只能改一个值，也就是说对于 i 和 j，i 处所有值都要小于等于 j 处，j 处所有值都要大于等于 i 处才可以。
## 50pts 做法
根据题意，我们易得基础 DP：

$$f_i=\max(f_i,f_j+1)$$

条件：

1. $maxx_j \leq a_i$
2. $minn_i \leq a_j$
3. $1 \leq j < i$

这里 f 表示以 i 为结尾最大的序列长度， a 表示该位置初始值，maxn 和 minn 分别表示该位置可以出现的最大值和最小值。

如果您推不出这一点，建议先学线性 DP 。。。

$\mathcal O(n^2)$ 的基础 DP 可以拿到 50pts。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100010],maxx[100001],minn[100001],tot[100001],ans;
namespace AYX
{	inline short main()
	{	scanf("%d%d",&n,&m);
		for(int i=1;i<=n;++i)scanf("%d",&a[i]),maxx[i]=minn[i]=a[i];
		for(int i=1;i<=m;++i)
		{	int pos,x;
			scanf("%d%d",&pos,&x);
			maxx[pos]=max(maxx[pos],x);
			minn[pos]=min(minn[pos],x);
		}
		for(int i=1;i<=n;++i)
		{	tot[i]=1;
			for(int j=1;j<i;++j)
			if(a[j]<=minn[i] and maxx[j]<=a[i])tot[i]=max(tot[i],tot[j]+1);
			ans=max(ans,tot[i]);
		}
		printf("%d\n",ans);
		return 0;
	}
}
signed main()
{return AYX::main();
}
```
## 下面是 100pts 做法。

我们发现，对于 dp 转移的条件：

1. $maxn_i\le a_i$
2. $a_j \le minn_i$
3. $j<i$

这实际上构成了三维偏序，这样我们就可以通过 CDQ 分治来优化 DP 的转移。具体实现就是模板用树状数组维护 max 值。

值得注意的一点是 $j<i$ 这个条件，在 sort 过程中，id 的位置会被打乱，这样可能导致后面向前面转移，会  WA 。那么我们怎么办呢？ CDQ  时打乱了顺序，我们只需要在本次 CDQ 过程后下一个 CDQ 前把位置变回来即可。

具体实现：　`sort(p+mid+1,p+r+1,cmp3);` 

cmp3 ：　`return i.id<j.id;`

这样这道题就完美解决了。

### code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,f[1000001],ans,c[1000001],nn;
struct LCIS
{int a,maxn,minn,id;}p[1000001];
namespace AYX
{	inline bool cmp1(LCIS i,LCIS j)
	{return i.maxn<j.maxn;}
	inline bool cmp2(LCIS i,LCIS j)
	{return i.a<j.a;}
	inline bool cmp3(LCIS i,LCIS j)
	{return i.id<j.id;}
	inline void add(int x,int val)
	{for(int i=x;i<=n;i+=i&-i)c[i]=max(c[i],val);}
	inline int query(int x)
	{int res=0;for(int i=x;i;i-=i&-i)res=max(res,c[i]);return res;}
	inline void clear(int x)
	{for(int i=x;i<=n;i+=i&-i)c[i]=0;}
	inline void CDQ(int l,int r)
	{	if(l==r){f[p[l].id]=max(f[p[l].id],1);return ;}
		int mid=(l+r)>>1;
		CDQ(l,mid);
		sort(p+l,p+mid+1,cmp1);
		sort(p+mid+1,p+r+1,cmp2);
		int j=l;
		for(int i=mid+1;i<=r;++i)
		{	while(j<=mid and p[j].maxn<=p[i].a)add(p[j].a,f[p[j].id]),++j;
			f[p[i].id]=max(f[p[i].id],query(p[i].minn)+1);
		}
		for(int i=l;i<j;++i)clear(p[i].a);
		sort(p+mid+1,p+r+1,cmp3);
		CDQ(mid+1,r);
	}
	inline short main()
	{	scanf("%d%d",&n,&m);
		for(int i=1;i<=n;++i)scanf("%d",&p[i].a),p[i].maxn=p[i].minn=p[i].a,p[i].id=i;
		for(int i=1;i<=m;++i)
		{	int pos,x;
			scanf("%d%d",&pos,&x);
			p[pos].maxn=max(p[pos].maxn,x);
			p[pos].minn=min(p[pos].minn,x);
		}
		CDQ(1,n);
		for(int i=1;i<=n;++i)ans=max(ans,f[i]);
		printf("%d\n",ans);
		return 0;
	}
}
signed main()
{return AYX::main();
}

```

修改了 $\LaTeX$ ，望通过，谢谢。。

---

## 作者：SovietPower✨ (赞：2)

$O(n^2)$DP很好写，对于当前的i从之前满足条件的j中选一个最大值,$dp[i]=d[j]+1$
```cpp
 for(int j=1; j<i; ++j)
	if(a[j]<=minv[i]&&maxv[j]<=a[i])//序列只会变换一次 
		dp[i]=max{dp[j]+1};
```
转移要满足两个条件：$a[j]<=minv[i]\ \&\&\ maxv[j]<=a[i]$

这是一个二维偏序问题，CDQ、树套树都可以。

拿$minv[x]$和$a[y]$作为两个坐标轴，$dp[j]$表示其上一点$(A[j],maxv[j])$.

这样就成了一个二维平面，可以向其中插入一些点dp[i]，询问一个矩形区域(也是一段前缀)中某点最大值 

线段树套线段树 树状数组套线段树都可做 复杂度$O(nlog^2n)$

前者常数太大，空间消耗大；后者优许多
```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
#define gc() getchar()
#define now node[rt]
#define lson l,m,node[rt].ls
#define rson m+1,r,node[rt].rs
#define lb(x) ((x)&-(x))
const int N=1e5+5;

int n,m,A[N],minv[N],maxv[N],MaxV,MaxA;
namespace Tree_2D
{
	struct Seg_Tree
	{
		struct Node
		{
			int maxv,ls,rs;
		}node[N<<6];//还要再小点。。不然BZOJ上依旧MLE 
		inline int new_Node()
		{
			static int cnt=0;
			return ++cnt;
		}
		void Insert(int l,int r,int &rt,int p,int v)
		{
			if(!rt) rt = new_Node();
			now.maxv = std::max(now.maxv, v);
			if(l<r)
			{
				int m=l+r>>1;
				if(p<=m) Insert(lson,p,v);
				else Insert(rson,p,v);
			}
		}
		int Query(int l,int r,int rt,int L,int R)
		{
			if(!rt) return 0;
			if(L<=l && r<=R) return now.maxv;
			int m=l+r>>1;
			if(L<=m)
				if(m<R) return std::max(Query(lson,L,R),Query(rson,L,R));
				else return Query(lson,L,R);
			return Query(rson,L,R);
		}
	}t;
	struct Bit
	{
		int root[N];
		void Insert(int p,int y,int v)
		{
			while(p<=MaxV)
				t.Insert(1,MaxA,root[p],y,v), p+=lb(p);
		}
		int Query(int p,int y)
		{
			int res=0;
			while(p)
				res=std::max(res,t.Query(1,MaxA,root[p],1,y)), p-=lb(p);
			return res;
		}
	}t2D;
}
#undef now
inline int read()
{
	int now=0;register char c=gc();
	for(;!isdigit(c);c=gc());
	for(;isdigit(c);now=now*10+c-'0',c=gc());
	return now;
}

int main()
{
	n=read(),m=read();
	for(int i=1; i<=n; ++i)
		maxv[i]=minv[i]=A[i]=read(), MaxA=std::max(MaxA,A[i]);
	for(int x,y,i=1; i<=m; ++i)
		x=read(), y=read(), maxv[x]=std::max(maxv[x],y), minv[x]=std::min(minv[x],y);
	for(int i=1; i<=n; ++i) MaxV=std::max(MaxV,maxv[i]);
	int ans=0;
	for(int v,i=1; i<=n; ++i)
	{
		v = Tree_2D::t2D.Query(minv[i], A[i]) + 1;
		Tree_2D::t2D.Insert(A[i], maxv[i], v);
		ans = std::max(ans, v);
	}
	printf("%d",ans);

	return 0;
}
```

---

## 作者：xgzc (赞：1)

### 题解

很像最长不下降子序列对吧~~（废话）~~

设$up[i]$和$down[i]$分别表示$i$最大最小能取多少

注意到：

$$f[i] = max_j\left\{f[j]\right\} + 1$$

$$a[j] \leq down[i],\; up[j] \leq a[i],\; j \leq i$$

三维偏序！！！

$CDQ$分治走起

### 代码

```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#define RG register

inline int read()
{
	int data = 0, w = 1; char ch = getchar();
	while(ch != '-' && (!isdigit(ch))) ch = getchar();
	if(ch == '-') w = -1, ch = getchar();
	while(isdigit(ch)) data = data * 10 + (ch ^ 48), ch = getchar();
	return data * w;
}

using std::max;
const int maxn(100010);
int n, m, a[maxn], up[maxn], down[maxn], c[maxn], f[maxn], Max;
inline bool cmp_1(int x, int y) { return a[x] < a[y]; }
inline bool cmp_2(int x, int y) { return down[x] < down[y]; }
void clean(int x) { while(x <= Max) c[x] = 0, x += x & -x; }
void add(int x, int v) { while(x <= Max) c[x] = max(c[x], v), x += x & -x; }
int query(int x)
{
	int ans = 0;
	while(x) ans = max(ans, c[x]), x -= x & -x;
	return ans;
}

void Div(int l, int r)
{
	static int id[maxn];
	if(l == r) return (void)(f[l] = max(f[l], 1));
	int mid = (l + r) >> 1; Div(l, mid);
	for(RG int i = l; i <= r; i++) id[i] = i;
	std::sort(id + l, id + mid + 1, cmp_1);
	std::sort(id + mid + 1, id + r + 1, cmp_2);
	int j = l;
	for(RG int i = mid + 1; i <= r; i++)
	{
		while(j <= mid && a[id[j]] <= down[id[i]]) add(up[id[j]], f[id[j]]), j++;
		f[id[i]] = max(f[id[i]], query(a[id[i]]) + 1);
	}
	for(RG int i = l; i < j; i++) clean(up[id[i]]);
	Div(mid + 1, r);
}

int main()
{
	n = read(), m = read();
	for(RG int i = 1; i <= n; i++) up[i] = down[i] = a[i] = read();
	for(RG int i = 1, x, y; i <= m; i++)
		x = read(), y = read(),
		  up[x] = max(up[x], y),
		  down[x] = std::min(down[x], y);
	Max = *std::max_element(up + 1, up + n + 1);
	Div(1, n); printf("%d\n", *std::max_element(f + 1, f + n + 1));
	return 0;
}
```



---

## 作者：kouylan (赞：0)

把每一个位置的值放到结构体中，$a_i$ 表示原值，$b_i$ 表示能取到的最小值，$c_i$ 表示能取到的最大值。考虑什么样的两个位置 $i,j$ 可以在答案的序列中相邻，显然要满足

1. $c_j\leq a_i$

2. $a_j\leq b_i$

3. $j<i$

所以这是一个三维偏序问题，采用 cdq 分治解决。

cdq 可以直接解决条件 $3$，在计算 [ $l,mid$ ] 对 [ $mid+1,r$ ] 的贡献时，我们可以让 [ $l,mid$ ] 按 $a$ 排序，让 [ $mid+1,r$ ] 按 $b$ 排序，采取双针的方法，就可以解决条件 $2$，最后，用树状数组存 $c$ 位置的 dp 最大值，解决了条件 $1$。

下面是 AC 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define lowbit(i) (i&-i)

int n,m,mx,f[100005],ans,t[100005];
struct node{
	int a,b,c,u;
}q[100005],q0[100005];

bool cmpa(node x,node y)
{
	return x.a<y.a;
}

bool cmpb(node x,node y)
{
	return x.b<y.b;
}

void fix(int x,int v)
{
	for(int i=x;i<=mx;i+=lowbit(i))
		if(v==-1)
			t[i] = 0;
		else
			t[i] = max(t[i],v);
}

int ask(int x)
{
	int s=0;
	for(int i=x;i>=1;i-=lowbit(i))
		s = max(s,t[i]);
	return s;
}

void cdq_(int l,int r)
{
	if(l==r)
		return;
	int mid=l+r>>1;
	cdq_(l,mid);
	sort(q+l,q+1+mid,cmpa), sort(q+1+mid,q+1+r,cmpb);
	for(int i=mid+1,j=l;i<=r;i++)
	{
		while(j<=mid && q[j].a<=q[i].b)
			fix(q[j].c,f[q[j].u]), j++;
		f[q[i].u] = max(f[q[i].u],ask(q[i].a)+1);
	}
	for(int i=l;i<=mid;i++)
		fix(q[i].c,-1);
	for(int i=l;i<=r;i++)
		q[i] = q0[i];
	cdq_(mid+1,r);
}

signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n&&cin>>q[i].a;i++)
		q[i].b = q[i].c = q[i].a, q[i].u = i, mx = max(mx,q[i].a);
	for(int i=1,x,y;i<=m&&cin>>x>>y;i++)
		q[x].b = min(q[x].b,y), q[x].c = max(q[x].c,y), mx = max(mx,y);
	for(int i=1;i<=n;i++)
		f[i] = 1, q0[i] = q[i];
	cdq_(1,n);
	for(int i=1;i<=n;i++)
		ans = max(ans,f[i]);
	cout<<ans<<endl;
	
	return 0;
}
```

祝大家 AC 愉快！

---


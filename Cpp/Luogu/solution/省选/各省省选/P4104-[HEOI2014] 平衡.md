# [HEOI2014] 平衡

## 题目描述

下课了，露露、花花和萱萱在课桌上用正三棱柱教具和尺子摆起了一个“跷跷板”。

这个“跷跷板”的结构是这样的：底部是一个侧面平行于地平面的正三棱柱教具，上面 摆着一个尺子，尺子上摆着若干个相同的橡皮。尺子有 2n + 1 条等距的刻度线，第 n + 1 条 刻度线恰好在尺子的中心，且与正三棱柱的不在课桌上的棱完全重合。

露露发现这个“跷跷板”是不平衡的（尺子不平行于地平面）。于是，她又在尺子上放 了几个橡皮，并移动了一些橡皮的位置，使得尺子的 2n + 1 条刻度线上都恰有一块相同质 量的橡皮。“跷跷板”平衡了，露露感到很高兴。

花花觉得这样太没有意思，于是从尺子上随意拿走了 k 个橡皮。令她惊讶的事情发生了： 尺子依然保持着平衡！     萱萱是一个善于思考的孩子，她当然不对尺子依然保持平衡感到吃惊，因为这只是一个 偶然的事件罢了。令她感兴趣的是，花花有多少种拿走 k 个橡皮的方法，使得尺子依然保 持平衡？当然，为了简化问题，她不得不做一些牺牲——假设所有橡皮都是拥有相同质量的 质点。但即使是这样，她也没能计算出这个数目。放学后，她把这个问题交给了她的哥哥/ 姐姐——Hibarigasaki 学园学生会会长，也就是你。当然，由于这个问题的答案也许会过于 庞大，你只需要告诉她答案 mod p 的值。


## 说明/提示

10%的数据满足：n <= 10。

30%的数据满足：n <= 50。

50%的数据满足：n <= 1000。

另有 10%的数据满足：k = 3。

在此基础上，另有 10%的数据满足：p = 2。

100%的数据满足：T <= 20，1 <= n <= 10000，1 <= k <= 10，2 <= p <= 10000，且 k <= 2n+1。


## 样例 #1

### 输入

```
10
6 5 10000  
4 1 10000 
9 6 10000 
4 6 10000 
5 1 10000 
8318 10 9973 
9862 9 9973 
8234 9 9973 
9424 9 9973 
9324 9 9973```

### 输出

```
73
1
920
8
1
4421
2565
0
446
2549```

# 题解

## 作者：CG__HeavenHealer (赞：7)

# 【题解】 P4104 [HEOI2014]平衡

### 题意：

有 $ 1 $ 到 $ 2n+1 $ 的一个杠杆，支点在 $n +1$ 处，起初每个刻度上都有一个质量相同的钩码，问拿走 $k$ 个钩码使杠杆仍保持平衡的方案数。

---

### 解法：

前置知识：

1. 杠杆的平衡条件： $F_1l_1 = F_2l_2 $ ， 左边的重心到支点的距离等于右边中心到支点的距离
2. **整数划分**

---

#### 另：关于整数划分（会的请自行跳过）

整数划分是求解一类诸如用 $k$ 个整数的和表示一个数 $n$ 的方案的问题，解法是DP。

对于每一个数的拆分方式，我们可以分为两种：

1. 表示这个数的几个数中，最小值为 $1$ 。
2. 表示这个数的几个数中，最小值不为 $1$ 。

设 $f[i][j]$ 为：用 $j$ 个数拆分 $i$ 这个数的方案数（这 $j$ 个数之间可以重复），那么对于以上两种情况，怎么实现转移呢？

对于1，它可以由 $f[i][j]$ 表示出  $f[i + 1][j + 1]$ 的状态，理由就是对每个 $i$ 的方案，我们都可以加一个 $1$ 使其成为 $i+1$ 的一种方案；

而对于2，它可以由 $f[i][j]$ 表示出  $f[i + j][j]$ 的状态，理由就是对每个 $i$ 的方案，我们可以在每一个数上加一个 $1$ 使其成为 $i+j$ 的一种方案；

下面附上两种情况的解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/lgbtm2ry.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/xzb58m29.png)

那么，转移方程就是： **$f[i][j]=f[i-1][j-1]+f[i-j][j] $**。

（可以左转切掉 [这里](https://www.luogu.com.cn/problem/P1025) 的例题 ）

---

言归正传，回到这道题：

对于1，因为钩码的质量都相等，所以对于每一侧，其重心都是成一个对称的效果。

而2又用在哪里呢？

我们设取出的数字之和为 $x$ ，那么解答等价于求出 $x = (n+1) \times k$ 的方案数。

![](https://cdn.luogu.com.cn/upload/image_hosting/rzdcsoy3.png)

如图，类似于这样的杠杆都是平衡的。

类似于整数划分，我们可以设 $f[i][j] $ 为用 $j$ 个数拆分 $i$ 这个数的方案数（这 $j$ 个数之间不能重复），同样的，对于每一个数的拆分方式，我们可以分为最小值为 $1$ 和不为 $1$ 的两种，转移分别是：

1. 最小值为 $1$ ：$f[i][j]$ 可以从 $f[i-j][j-1]$ 转移过来（因为已知这几个数之间不能重复，那么最小值为1，这几个数中就肯定只有一个1，我们可以给每个数都减掉一个1，剩下的是 $j-1$ 个数，这样就可以从 $f[i-j][j-1]$ 这个状态转移到 $f[i][j]$ 了。)
2. 最小值不为 $1$ ：$f[i][j]$ 可以从 $f[i-j][j]$ 转移过来，理由和有重复的划分相同。

则转移方程为： $f[i][j]=f[i-j][j-1]+f[i-j][j]$ ，最后答案为 $f[(n+1) \times k][k]$ 。

剩下要注意的事情就是要注意处理边界，因为我们要处理出 $k$ 个数的和为 $(n+1)\times k$ 的方案数，而杠杆长度只有 $2\times n +1$ ，所以有些方案是不合法的，需要减掉。

---

### Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define ri register int
const int N = 1e4 + 5, K = 15;
int n, k, p, f[N * K * 2][K]; // f[i][j]表示用j个数表示i的方案数
inline int read() {
    ri x = 0, f = 1;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-') f = -1;
    for (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
    return f * x;
}
signed main() {
    for (ri T = read(); T--; memset(f, 0, sizeof(f))) {
        n = read(), k = read(), p = read();
        f[0][0] = 1;
        for (ri i = 1; i <= (n + 1) * k; i++)
            for (ri j = 1; j <= k; j++) {
                if (i < j) continue;
                f[i][j] = (f[i - j][j] + f[i - j][j - 1]) % p; // 整数划分
                if (i >= (n + 1) * 2) // 注意处理超出杠杆的部分，要减去i-(n+1)*2的方案数
                    ((f[i][j] -= f[i - (n + 1) * 2][j - 1]) += p) %= p;
            }
        printf("%lld\n", (f[(n + 1) * k][k] + p) % p);
    }
    return 0;
}
```

---

## 作者：foreverlasting (赞：6)

[题面](https://www.luogu.org/problemnew/show/P4104)

动态规划。

好像和题解思路有点不一样哎。

首先肯定是转换题目，转换成从$[1,2*n+1]$中取出$k$个数使和为$(n+1)*k$。然后考虑一个DP。

$dp[i][j]$表示取了$i$个数，取出来的数之和为$j$。

考虑转移方程。

如果我们把所有方案写出来，每个方案分别排序后，发现是一条最小值至少为$0$，最大值至多为$2*n$的序列。如何去得到这样一个序列。我们有两种方式。第一种，整个序列加上$1$。第二种，在序列的开头增加一个初始值。那么转移方程就出来了：

$dp[i][j]=dp[i][j-i]+dp[i-1][j-i]$。

而事实上我们这样超出$[1,2*n+1]$的范围，所以我们要减去$dp[i-1][j-(n+1)*2]$去限制，所以就好了。

~~之所以要发题解，是因为我的代码好像没有循环去统计答案。~~

code:
```
//2018.9.20 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
inline int read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void _swap(res &x,res &y){
    x^=y^=x^=y;
}
inline int _abs(const res &x){
    return x>0?x:-x;
}
inline int _max(const res &x,const res &y){
    return x>y?x:y;
}
inline int _min(const res &x,const res &y){
    return x<y?x:y;
}
const int N=1e4+10,K=10+10;
namespace MAIN{
    int T,n,k,kcz;
    int dp[K][N*K*2];
    inline void MAIN(){
        T=read();
        while(T--){
            n=read(),k=read(),kcz=read();
            memset(dp,0,sizeof(dp));
            dp[0][0]=1;
            for(res j=1;j<=(n+1)*k;j++)
                for(res i=1;i<=_min(j,k);i++)
                    dp[i][j]=(dp[i][j-i]+dp[i-1][j-i]-(j>=(n+1)*2?dp[i-1][j-(n+1)*2]:0))%kcz;
            printf("%d\n",(dp[k][(n+1)*k]%kcz+kcz)%kcz);
        }
    }
}
int main(){
    MAIN::MAIN();
    return 0;
}
```

---

## 作者：Richard_Whr (赞：4)

整数划分是一大类问题，且有通性通法，值得总结。

会的可以直接跳过

借此题机会总结一下整数划分问题：（约定顺序不影响）

- ###  1.1.将 $m$ 划分为 $n$ 个数，可以重复，有多少种方案

- ### 1.2.将 $m$ 划分为 $n$ 个数，不能重复，有多少种方案

- ### 2.1.将 $m$ 划分为 $n$ 个数，可以重复，每个数都要求是奇数，有多少种方案

- ### 2.2.将 $m$ 划分为 $n$ 个数，不能重复，每个数都要求是奇数，有多少种方案

- ### 3.1.将 $m$ 划分为 $n$ 个数，可以重复，要求每个数均 $<x$，有多少种方案

- ### 3.2 将 $m$ 划分为 $n$ 个数，不能重复，要求每个数均 $<x$，有多少种方案

别急，我们逐个击破

由于划分没有顺序，因此我们可以理解为，我们划分出的必须是有序序列。

### 1.1.解法

设 $f_{i,j}$ 表示已经分了 $i$ 个数，和为 $j$ 的方案数量

为了保证有序，我们每次都有两种选择：

- 第一个数前面 $+1$
	
    $f_{i,j}+=f_{i-1,j-1}$

- 给所有数 $+1$
	
    $f_{i,j}+=f_{i,j-i}$
    
第二维顺序循环即可。

### 1.2.解法

延续上一个的状态设计，思考什么时候会出现重复。

当且仅当我们在序列前 $+1$ 且之前有 $1$ 的时候，会出现问题。

因此我们先给所有数 $+1$，然后再在序列前面 $+1$，即可

转移方程有：

- 给所有数 $+1$

	$f_{i,j}+=f_{i,j-i}$
    
- 先给所有数 $+1$，再添加一个 $1$

	$f_{i,j}+=f_{i-1,j-i}$
    
### 2.1.解法

依然延续，考虑使得构造的序列只出现偶数该咋办呢？

可以发现，整体 $+2$ 就行了

- 给所有数 $+2$

	$f_{i,j}+=f_{i,j-2\times i}$
    
- 在序列前 $+1$

	$f_{i,j}+=f_{i-1,j-1}$
    
### 2.2. 解法

不再赘述，直接上套路

$f_{i,j}=f_{i-1,j-i}+f_{i,j-2\times i}$

### 3.1. 解法

这次改成容斥，考虑问题一定出在所有数 $+1$ 上，这样会使得最大数可能超量。

我们将这个超量的减去即可，考虑不合法状态至少存在一个 $x$，那么现在的总和为 $j$，他之前的和就是一定是 $j-x$

$f_{i,j}=f_{i-1,j-1}+f_{i,j-i}-f_{i-1,j-x}$


### 3.2 解法

不再赘述，直接上套路

$f_{i,j}=f_{i-1,j-i}+f_{i,j-i}-f_{i-1,j-x}$



------------


## 本题题解

那么对于这道题来说，相当于我们将这 $2 \times n$ 个数标号 $1$ ~ $2 \times n+1$

可以发现，如果左右两侧平衡，那么他们的平均数一定是 $n+1$，因此总和就是 $k \times (n+1)$。

总结一下限制：

- 总和为 $k \times (n+1)$

- 个数为 $k$

- 互不相同

- （隐藏条件） 每个数都 $ < (n+1) \times 2$

直接调用整数划分 3.2，即可搞定此题

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=11,M=1e5+10;
int f[N][M];
int n,k,m,mod;

int main()
{
    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
    int T;
    cin>>T;
    while(T--)
    {
        cin>>n>>k>>mod;
        m=k*(n+1);
        
        memset(f,0,sizeof f);
        f[0][0]=1;
        for(int i=1;i<=k;i++)
        {
            for(int j=i;j<=m;j++)
            {
                if(j>=2*n) f[i][j]=(f[i-1][j-i]+f[i][j-i]-f[i-1][j-2*(n+1)]+mod)%mod;
                else f[i][j]=(f[i-1][j-i]+f[i][j-i])%mod;
            }
        }
        
        
        cout<<f[k][m]<<"\n";
    }
    
    return 0;
}

```

如果你想更进一步，优化空间，也许可以用滚动数组。




---

## 作者：tymzzh_01 (赞：4)

本蒟蒻的第一篇题解。

很明显，这题是动态规划。

类似于整数划分，我们可以设
$dp[i][j]$ 为用
$j$ 个数拆分
$i$ 这个数的方案数。
对于每一个数的拆分方式，我们可以分为最小值为
$1$ 和不为
$1$ 的两种。

最小值为
$1$：
$dp[i][j]$ 可以从
$dp[i−j][j−1]$ 变过来。（因为最小值为 $1$，且每个数肯定不重复，所以这几个数中就肯定只有一个 $1$，我们可以给每个数都减掉一个 $1$，剩下的就是
$j−1$ 个数，这样就可以从
$dp[i−j][j−1]$ 这个状态转移到
$dp[i][j]$ 了。）

最小值不为
$1$：
$dp[i][j]$ 可以从
$dp[i−j][j]$ 转移过来，理由和有重复的划分相同。
则转移方程为：
$dp[i][j]=dp[i−j][j−1]+dp[i−j][j]$，最后答案为
$dp[(n+1)×k][k]$。

剩下要注意的事情就是要注意处理边界，因为我们要处理出
$k$ 个数的和为
$(n+1)×k$ 的方案数，而杠杆长度只有
$2×n+1$，所以有些方案是需要减掉的。
上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int t,n,k,x,dp[15][100005];
int main()
{
	cin >> t;
	while (t--)
	{
		cin >> n >> k >> x;
		memset(dp,0,sizeof(dp));
		dp[0][0] = 1;
		for (int i = 1;i <= k;i++)
		{
			for (int j = i;j <= (n + 1) * k;j++)
			{
				int d = dp[i][j - i] + dp[i - 1][j - i];
				if (j >= 2 * n) dp[i][j] = (d - dp[i - 1][j - 2 * (n + 1)] + x) % x;
				else dp[i][j] = d % x;
			}
		}
		cout << dp[k][(n + 1) * k] << "\n";
	}
	return 0;
}
```

---

## 作者：Plus_Ultra (赞：3)

一. 前言：

这题是学完 **_整数划分模型_** 以后老师给的一道例题，学会了以后发篇题解,加深记忆，同时希望能帮到和我一样的萌新	QwQ.

二. 解法：

1. 问题转换：

- 我们首先要了解一点点物理知识：左半轴选的橡皮到重心的距离和 = 右半轴选的橡皮到重心的距离和.

- 所以就是在左边选 i 个点，,再在右边选（k-i） 个点，使其到中心（中点）的距离和为一个不固定的值 X 的方案数.

- 就等同于把 X 划分成 i 个数的方案数 * 把 X 划分成 （k-i) 个数的方案数.

2. 过程：

- 于是，我们可以枚举距离和 X，再枚举左边选的点的个数 i ，转移即可.

- 转移方程： dp[x,y]=dp[x-y,y]+dp[x-y,y-1]. 

- 最后根据乘法原理累加答案即可.

- 具体不懂整数划分模型可以在网上学习一下，这里不再赘叙.

- 代码确实是照着二楼大佬写的，感谢.

3. 注意细节：

- 如果枚举的距离和 X > n，那么dp[X][j]-dp[X-n-1][j-1](划分成j个数)，意思是减去将 X-n-1 划分成 j-1 个数，第 j 个数为 n+1 的方案数（这样方案不合法，超出n）.

- 累加方案数时，分为两种情况：选重心点和不选重心点，方案数都要累加上.

- 取模速度较慢，要写读优，取模时尽量分开操作.

下面上代码（我知道各位大佬也不需要代码）：

```
#include<iostream>
#include<cstdio>

#define LL long long
#define N 100005
#define M 11

using namespace std;

LL ans,T,dp[N][M],k,p,n;

LL read()
{
	LL v=0,f=1;char c='_';
	while(c<'0'||c>'9')
	{
		if(c=='-')  f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	v=v*10+c-'0',c=getchar();
	return v*f;
}

int main()
{
	T=read();
	
	while(T--)
	{
		n=read(),k=read(),p=read();
		
		ans=0;dp[0][0]=1;//初始化 
		for(int i=1;i<=n*k;i++)		
			for(int j=1;j<=k&&j<=i;j++)//两个都要小于 
			{
				dp[i][j]=(dp[i-j][j]+dp[i-j][j-1])%p;//整数划分模型 
				if(i>n)  dp[i][j]=(dp[i][j]-dp[i-n-1][j-1]+p)%p;//防溢出 
				//去掉不合法方案 
			}
			
		for(int i=0;i<=k;i++)//记得从0开始枚举 
			for(int j=0;j<=n*k;j++)
			{
				ans=(ans+dp[j][i]*dp[j][k-i]%p)%p;//累加方案 
				if(i<k)  ans+=dp[j][i]*dp[j][k-i-1]%p,ans%p;//合并为一句会T。。。
				//我们可以选重心 
			}
			
		cout<<ans<<endl;
	}
	
	return 0;
}
```
以后准备写一篇整数划分模型文章（很可能会咕）.

### _[Plus Ultra!](https://www.luogu.org/blog/OnePunchManGO/)_

---

## 作者：MloVtry (赞：3)

简单来说就是选择k个∈[-n,n]的数使其和为0。

设f[j][i]表示取i个正整数，其和为j的方案数。

转移有两种:

一种是当前的每个元素都+1，所以f[j][i]<-f[j-i][i]

另一种是当前每个元素+1，在放进来一个1，f[j][i]<-f[j-i][i-1]。

所以f[i][j]=f[i-j][j-1]+f[i-j][j].

但是每个元素要在[-n,n]范围内，所以
f[i][j]-=f[i-n-1][j-1]，减去有1个n+1的方案数。

这样问题就解决了，注意的是中间的橡皮也可以拿。

代码
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define N 100005
#define M 15
using namespace std;
int f[N][M],T,n,k,p,ans;

int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d%d",&n,&k,&p);
		ans=0;f[0][0]=1;
		for(int i=1;i<=n*k;++i)
		for(int j=1;j<=i&&j<=k;++j)
		{
			f[i][j]=(f[i-j][j-1]+f[i-j][j])%p;
			if(i>=n+1) f[i][j]=((f[i][j]-f[i-n-1][j-1])%p+p)%p;
		}
		for(int i=0;i<=k;++i)
		{
			for(int j=0;j<=n*k;++j)
			{
				ans=(ans+1ll*f[j][i]*f[j][k-i]%p)%p;
				if(i<k) ans+=(f[j][i]*f[j][k-i-1]),ans%=p;
			}
		}
		printf("%d\n",ans);
		
		
	}
	return 0;
}
```

---

## 作者：Tmbcan (赞：2)

## [P4104 [HEOI2014] 平衡](https://www.luogu.com.cn/problem/P4104)
### 题面
题目描述：  
一个杠杆上的左右两侧各有 $n$ 块质量相等的橡皮（杠杆最中间也有一块），随机从中拿走 $k$ 块橡皮，可使杠杆依然平衡。求共有多少种拿走橡皮的方案数，答案对 $p$ 取模。

题目简译：  
从 $-n\sim n$ 中共选出 $k$ 个互不相同的数，求使得正数与负数的和为零的方案数。
### 思路
**前置知识：**[整数划分](https://baike.baidu.com/item/%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86)。

只考虑在杠杆的右侧选出 $x\in [1,k]$ 个数，题目就变成了经典的整数划分模型：  
将 $N\in [0,n\times k]$ 划分为 $k$ 个互不相同且不大于 $n$ 的正整数的方案数。  
显然统计答案时，右侧选出 $x$ 个数，那么左侧就选出 $k-x$ 个数，乘法原理计算得到总方案数。  


---


对于数字有大小限制的整数划分，不过多赘述：  
> 令 $dp_{i,j}$ 表示把 $i$ 划分为 $j$ 个数的方案：  
> 则有 $dp_{i,j} = dp_{i-j,j}+dp_{i-j,j-1}$。  
> 当 $i>n$ 时，出现的不合法方案需要减掉：  
> 此时 $dp_{i,j} = dp_{i-j,j}+dp_{i-j,j-1}-dp_{i-n-1,j-1}$。

对于统计答案：  
> 如上：枚举杠杆一侧选出 $x$ 个数，另一侧就选出 $k-x$ 个数，乘法原理计算。  
> 特别注意：杠杆最中间也有一块橡皮，需要考虑是否将其拿走。
### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<climits>
#include<cstdlib>
#include<vector>
using namespace std;
typedef long long ll;
template <typename T>
inline void read(T&x){//快读
	int w=0;x=0;
	char ch = getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') w=1;
		ch = getchar();
	}
	while(ch>='0'&&ch<='9'){
		x = (x<<1)+(x<<3)+(ch^48);
		ch = getchar();
	}
	if(w) x=-x;
}
template <typename T,typename...Args>
inline void read(T&t,Args&...args){
	read(t);read(args...);
}
const int N = 1e4+10,K = 15;
int n,k,p;
ll dp[N*K][K];
int main(){
	int T;read(T);
	while(T--){
		read(n,k,p);
		memset(dp,0,sizeof(dp));
		dp[0][0] = 1;//初始状态
		for(int i=0;i<=k*n;++i){//整数划分
			for(int j=1;j<=min(i,k);++j){
				dp[i][j] = (dp[i][j]+dp[i-j][j]+dp[i-j][j-1])%p;
				if(i>n) dp[i][j] = (dp[i][j]-dp[i-n-1][j-1]+p)%p;
			}
		}
		ll ans = 0;
		for(int j=0;j<=k;++j){
			for(int i=0;i<=n*k;++i){
				ans = (ans+dp[i][j]*dp[i][k-j])%p;
				if(j<k) ans = (ans+dp[i][j]*dp[i][k-j-1])%p;//最中间的橡皮要看是否选
			}
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：vеctorwyx (赞：2)

前置物理知识（杠杆平衡条件）：

$$\large F_1l_1=F_2l_2$$

又因为每个橡皮的质量相同，于是我们只需要保证左边所有取走的橡皮到支点的距离和等于右边所有取走的橡皮到支点的距离相等即可。

先想最朴素的 dp 方法：

设 $dp_{i,j}$ 表示取走 $i$ 个橡皮，这些橡皮到支点的距离和为 $j$。

有转移方程（设当前拿走到支点距离为 $k$ 的橡皮）

$$\large dp_{i,j} =dp_{i,j} + dp_{i-1,j-k}$$

最后再特殊处理一下放在支点上的橡皮，答案即为

$$\sum_{i=1}^{k-1}\sum_{j=1}^{n \times k} dp_{i,j}\times dp_{k-i,j}+dp_{i,j}\times dp_{k-i-1,j}$$

但是时间复杂度是 $O(n^2k)$的，超时了……

~~如果你想这么卡过去我也不会拦着你~~

------

这时候就要引出[这道题](https://www.luogu.com.cn/problem/P1025)了。

借鉴这里整数划分的思想，状态不变，则转移方程变为

$$\large dp_{i,j} = dp_{i - 1, j - i} + dp_{i,j - i}$$

这时候会出现选了比 $n$ 大的位置的橡皮的情况，需要删掉，具体做法分两种：

1. 直接将 $dp_{1,j}(j>n) $ 的部分设为0；

2. 当 $j>n+1$时，由转移方程得，每次转移的每个因子只会加一，则第一次出现的非法位置一定是 $j = n + 1$ 的情况，此时剩余的 $i-1$ 块橡皮的距离和为 $j - (n + 1)$ ，即多算了 $dp_{i-1,j - (n + 1)}$ 种情况，减去即可。

此时的复杂度降到了 $O(nk^2)$，就可过了。

除此之外， 要特判一下 $k = 1$ 的情况。

code：

```
#include<bits/stdc++.h>
using namespace std;
int t, n, m, p;
int dp[15][100010];
int ans = 0;
signed main(){
	scanf("%d", &t);
	while(t--){
		ans = 0;
		scanf("%d%d%d", &n, &m, &p);
		if(m == 1){
			puts("1");
			continue;
		}
		dp[0][0] = 1;
		dp[1][1] = 1;
		for(int j = 1; j <= n * m; j++)
			for(int i = 1; i <= min(j, m); i++){
				if(j > i)
					dp[i][j] = (dp[i - 1][j - i] + dp[i][j - i]) % p;
				else
					continue;
				if(j > n + 1)
					(((dp[i][j] -= dp[i - 1][j - (n + 1)]) %= p) += p) %= p;
				if(j > n && i == 1)
					dp[i][j] = 0;}
		for(int i = 1; i < m; i++)
			for(int j = 1; j <= n * m ;j++)
				(ans += dp[i][j] * dp[m - i][j] % p + dp[i][j] * dp[m - i - 1][j] % p) %= p;
		printf("%d\n", ans);
	}
}
```

---

## 作者：123hh2 (赞：2)

--->[传送门](https://www.luogu.com.cn/problem/P4104)

---

### 前言

update:2021.6.29 修改了一些小问题

在 CG__HeavenHealer 的推荐下做了这道题，感觉这道题挺不错的，建议在完成这道题之前，看看这道题---> [数的划分](https://www.luogu.com.cn/problem/P1025)

---

### 题目大意

给出 $t(t \le 20)$ 组询问，对于每个询问，给了你一个长度为 $2n+1(1 \le n \le 10^4)$ 跷跷板，其支点在 $n+1$处 ，并且在每个单位长度上都有一块相等质量的橡皮。让我们求出在拿走 $k(1 \le k \le 10)$ 块橡皮的方案数对 $p(2 \le p \le 10^4)$ 进行取模的结果 

数据保证 $k \le 2n+1$

---

### 思路

首先能想到的是打一个爆搜 + 剪枝，依次枚举所有可能的方案并适当剪枝，但看到数据范围就打消了这个念头，于是我们得换一个思路

由于刚刚做了数的划分这道题,并且 CG__HeavenHealer 告诉我这道题要用 DP 做，所以我们就往 DP 方向想

结合数的划分里的状态，我们可以设 $dp[i][j]$ 表示对数 $i$ 划分成 $j$ 个 **不重复** 的大于等于 $1$ 的数的方案数。对于这道题来说，设我们取出的 $k$ 个数之和为 $sum$，我们要保证取出的这些数能够使这个跷跷板保持平衡，所以我们要保证 $sum= k \times (n+1)$，也就是每个橡皮离中心的距离之和除以 $k$ 在这个跷跷板的中点上

考虑对 $sum$ 进行整数划分，易得

$dp[i][j]=dp[i-j][j] + dp[i-j][j-1]$

对于这道题而言，我们要划分的数 $sum$ 可能会超出杠杆的长度，我们需要减去超出部分的方案数，因为杠杆上没有这个数的坐标，也就是

$dp[i][j]=dp[i][j]-dp[i-2*(n+1)][j-1]$

所以最终的方案数就是 $dp[k \times (n+1)][k]$

---

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define in inline
#define ri register
#define _123hh2 0
using namespace std;
in int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0') {if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
in void write(int x)
{
    if(x<0) {x=-x;putchar('-');}
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int maxn=1e4+1;
int dp[maxn*20][11];
//开大 20 倍的原因：
//首先先开大两倍,因为杠杆长度是 2n+1 
//其次是，我们要划分的数 sum(第一维)是 k*(n+1)，所以数组还要多开 k 倍
//题目给的 k 是比 10 小的，所以综上考虑，开20倍就好了 
inline void init()
{
	for(ri int i=1;i<maxn*20;i++) for(ri int j=1;j<=10;j++) dp[i][j]=0;dp[0][0]=1;
}
signed main()
{
	int t=read();
	while(t--)
	{
		int n=read(),k=read(),p=read();
		init();//初始化
		for(ri int i=1;i<=k*(n+1);i++)//枚举每一个 sum 之前的数 
		{
			for(ri int j=1;j<=k;j++)
			{
				//i<j不能划分qwq！ 
				if(i>=j) dp[i][j]=dp[i-j][j]+dp[i-j][j-1],dp[i][j]+=p,dp[i][j]%=p; 
				//你的数太大啦，剪掉这一部分超过杠杆长度的方案数 
				if(i>=2*(n+1)&&i>=j) dp[i][j]-=dp[i-2*(n+1)][j-1],dp[i][j]+=p,dp[i][j]%=p;
			}
		}
		write(dp[k*(n+1)][k]%p),puts("");//输出将 sum 划分成 k 份时的方案数 
	}
	return _123hh2;
}
```


---

## 作者：程门立雪 (赞：1)

# P4104 [HEOI2014]平衡

**题意转换:**

杠杆的平衡条件为 $F1 \times L1 = F2 \times L2$, 因为橡皮的质量相等，所以平衡的条件为：左边橡皮到重心的距离和等于右边橡皮到重心的距离和，

题目也就转化为，在重心左边选$i$个数，再在右边选$（k-i）$个点，到重心的距离和为$x$的方案数，也就是整数划分。

$f[x][i]$表示选$i$个数，使和为$x$的方案数（也就是将$x$划分为$i$个不同数的方案数）。
可以看做有$i$个盒子，考虑盒子里有1和无1的情况 。

有1:$f[i-j][j-1]$    无1：$f[i-j][j]$ 

$f[i][j] = f[i-j][j-1] + f[i-j][j]$

```c
#include <cstdio>
#include <iostream>
#define orz cout << "AK IOI" <<"\n"

using namespace std;
const int maxk = 15;
const int maxn = 100010;

inline int read()
{
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
	while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0';ch = getchar();}
	return x * f;
}
int T, n, k, p, f[maxn][maxk]; 
int main()
{
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    T = read();
    while(T--)
    {
    	n = read(), k = read(), p = read();
    	int ans = 0;
    	f[0][0] = 1;
    	for(int i = 1; i <= n * k; i++)
		    for(int j = 1; j <= i && j <= k; j++)
		    {
		   	  f[i][j] = (f[i - j][j - 1] + f[i - j][j]) % p;
		   	  if(i >= n + 1) f[i][j] = (f[i][j] - f[i - n - 1][j - 1] + p) % p;
		    } 
		for(int i = 0; i <= k; i++)
		    for(int j = 0; j <= n * k; j++)
		    {
		   	  ans = (ans + f[j][i] * f[j][k - i] % p) % p;
		   	  if(i < k) ans = (ans + (f[j][i] * f[j][k - i - 1]) % p) % p; 
		    }
		printf("%d\n", ans);
	}
	return 0;
}

```


---

## 作者：yizhiming (赞：0)

本题解主要是解释把这道题当作整数划分的依据，可能是我太蒟了，其他题解都只提了一嘴，而没说为什么。

## 题目大意

给定长度为 $2\times n+1$ 的杠杆，杠杆除 $n+1$ 位置以外的每一个位置都有质量相等的砝码，问取走 $k$ 个砝码使得杠杆仍旧平衡的方案数，对读入的 $p$ 取模。

$1\leq n\leq 10^5,1\leq k\leq 10,1\leq p\leq 10^5$

## 解题思路

我们将题面转换一下，因为质量相等，所以我们设砝码所在的刻度为其权值，根据杠杆平衡原理可知，左边去掉的砝码到 $n+1$ 的距离之和等于右边去掉的砝码到 $n+1$ 的距离之和，我们设左边共选了 $x$ 个砝码，设为数组 $a$，右边设为数组 $b$，则有：

$\sum\limits_{i=1}^{x}(n+1-a_i) = \sum\limits_{j=1}^{k-x}(b_j-n-1)$

将 $n+1$ 提出来可得：

$x\times(n+1)-\sum\limits_{i=1}^{x}a_i = -(k-x)(n+1)+\sum\limits_{j=1}^{k-x}b_j$

移项可得：

$(x+k-x)\times(n+1) = \sum\limits_{i=1}^{x}a_i+\sum\limits_{j=1}^{k-x}b_j$

我们会发现左边即为 $k\times (n+1)$，右边为选出来数之和，即可得：

$sum = (n+1)\times k$

但是这时候就有人要问了，如果全选了左边或者右边也有满足这种情况的怎么办呢？

我们发现 $sum$ 是 $k$ 个数的和，而这些数中左边的数都 $<n+1$，右边的数都 $>n+1$。如果不左右都选，一定不满足条件。

所以就可以转换题意直接做整数划分。

## Code

注意一下超过边界的要减掉就好，这部分代码其它题解都有解释，我就不多说了。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
#include <cmath>
using namespace std;
int read(){
	int x=0,f=1;char ch = getchar();
	while(ch<'0'||ch>'9'){if(ch=='-'){f=-1;}ch = getchar();}
	while(ch>='0'&&ch<='9'){x = x*10+ch-'0';ch = getchar();}
	return x*f;
}
int n,k,p;
const int N = 1e4+5;
int f[N*20][20];
void init(){
	n = read();k = read();p = read();
	memset(f,0,sizeof(f));
	f[0][0] = 1;
	for(int i=1;i<=k*(n+1);i++){
		for(int j=1;j<=min(i,k);j++){
			f[i][j] = (f[i-j][j-1]+f[i-j][j])%p;
			if(i>=2*(n+1)){
				f[i][j] = (f[i][j]-f[i-2*(n+1)][j-1]+p)%p;
			} 
		}
	}
	cout<<f[k*(n+1)][k]<<"\n";
}
int main(){
	int t = read();
	while(t--){
		init();
	} 

	return 0;
}

```

完结撒花

---


# [HEOI2015] 兔子与樱花

## 题目描述

很久很久之前，森林里住着一群兔子。有一天，兔子们突然决定要去看樱花。

兔子们所在森林里的樱花树很特殊。樱花树由 $n$ 个树枝分叉点组成，编号从 $0$ 到 $n-1$，这 $n$ 个分叉点由 $n-1$ 个树枝连接，我们可以把它看成一个有根树结构，其中 $0$ 号节点是根节点。

这个树的每个节点上都会有一些樱花，其中第 $i$ 个节点有 $c_i$ 朵樱花。樱花树的每一个节点都有最大的载重 $m$，对于每一个节点 $i$，它的儿子节点的个数和 $i$ 节点上樱花个数之和不能超过 $m$，即 $son(i) + c_i \leq m$，其中 $son(i)$ 表示 $i$ 的儿子的个数，如果 $i$ 为叶子节点，则 $son(i) = 0$。

现在兔子们觉得樱花树上节点太多，希望去掉一些节点。当一个节点被去掉之后，这个节点上的樱花和它的儿子节点都被连到删掉节点的父节点上。如果父节点也被删除，那么就会继续向上连接，直到第一个没有被删除的节点为止。

现在兔子们希望计算在不违背最大载重的情况下，最多能删除多少节点。

注意根节点不能被删除，被删除的节点不被计入载重。

## 说明/提示

- 对于 $30\%$ 的数据，$n \leq 5 \times 10^3$，$m \leq 100$，$c_i \leq 100$；
- 对于 $70\%$ 的数据，$n \leq 2 \times 10^5$，$m \leq 2 \times 10^3$，$c_i \leq 10^3$；
- 对于 $100\%$ 的数据，$1 \leq n \leq 2 \times 10^6$，$1 \leq m \leq 10^5$，$0 \leq c_i \leq 10^3$，保证初始时，每个节点樱花数与儿子节点个数之和大于 $0$ 且不超过 $m$。


## 样例 #1

### 输入

```
10 4
0 2 2 2 4 1 0 4 1 1
3 6 2 3
1 9
1 8
1 1
0
0
2 7 4
0
1 5
0```

### 输出

```
4```

# 题解

## 作者：YoungNeal (赞：19)

题解在博客[食用](https://www.cnblogs.com/YoungNeal/p/9084704.html)效果更佳哦~

## Solution

做法：自底向上，贪心的优先删除每个点的儿子中代价最小的一个。

贪心：以 $sons[i]+c[i]$ 为 $i$ 点的代价，每个点我们选取代价最小的删除，结果一定不会变差。

>  证明：对于 $i$ 点和  $i$ 的两个儿子 $j,p$，假设 $c[j]+sons[j]<c[p]+sons[p]$，由决策包容性，选 $j$ 优先删除一定比选 $p$ 优先删除更优。

自底向上：从根节点 $dfs$ ，从叶子结点向上回溯。路上如果遇到能删除的点就删，不必考虑其祖先。

> 证明：设点  $i$ 的儿子是 $j$ ，$j$ 的兄弟是 $p$ ，$j$ 还有一个儿子是 $q$。
>
> $dfs$ 的过程中，如果在回溯到  $j$ 的时候发现可以删除 $q$，那么就删除 $q$，并更新 $j$ 本身的代价，这样可能会导致无法再回溯到 $i$ 点的时候删除 $p$。
>
> 粗略想一下这不是有后效性嘛，但是因为贪心删了儿子而导致这个点不能再删，那么我们只会损失一个点，就是该点，而删除儿子至少会删除一个，所以不会亏。。
>
> 综上，自底向上的删除无后效性，满足贪心性质。

## Code

```cpp
#include<map>
#include<cstdio>
#include<cctype>
#include<algorithm>
#define N 2000005

int n,m;
int ans;
int c[N];
int sons[N],cnt;
int tot[N],l[N],r[N];

inline char nc(){
    static const int BS=1<<22;
    static unsigned char buf[BS],*st,*ed;
    if(st==ed) ed=buf+fread(st=buf,1,BS,stdin);
    return st==ed?EOF:*st++;
}
//#define nc getchar
inline int getint(){
    char ch;
    int res=0;
    while(!isdigit(ch=nc()));
    while(isdigit(ch)){
        res=(res<<1)+(res<<3)+(ch^48);
        ch=nc();
    }
    return res;
}

bool cmp(int a,int b){
    return sons[a]+c[a]<sons[b]+c[b];
}

void dfs(int now){
    if(!sons[now]) return;
    for(int i=l[now];i<=r[now];i++)
        dfs(tot[i]);
    std::sort(tot+l[now],tot+r[now]+1,cmp);
    for(int i=l[now];i<=r[now];i++){
        if(c[tot[i]]+sons[tot[i]]+c[now]+sons[now]-1<=m){
            ans++;
            c[now]+=c[tot[i]];
            sons[now]+=sons[tot[i]]-1;
        }
        else break;
    }
}

signed main(){
    n=getint(),m=getint();
    for(int i=1;i<=n;i++)
        c[i]=getint();
    for(int i=1;i<=n;i++){
        sons[i]=getint();
        l[i]=cnt+1;
        r[i]=cnt+sons[i];
        for(int j=1;j<=sons[i];j++){
            int a=getint()+1;
            tot[++cnt]=a;
        }
    }
    dfs(1);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：阔睡王子 (赞：8)

## 一道看起来很唬人的贪心题
说是紫题，实际上就是一道普通的提高组的题。

题意：
- 给定一个大小为 $n$ 的点权树，编号为 $0$ 到 $n-1$ 。
- 支持一种删除操作：删除某个点，它的所有儿子节点连接到它的父亲节点，它的点权加到父亲节点上。
- 给定一个限制：任何一个点任何时刻它的点权加上它的儿子节点个数不得超过一个给定的数。
- 求最大删除点数。

先自己推了一下样例，不难发现删除 $9，5，8，6$ 合理。

![](https://cdn.luogu.com.cn/upload/image_hosting/hb5lcodk.png)

感觉好像可以用 DP 做，自己又去推导了一下 DP 方程，在推导过程中发现删除某个点暂时只会影响到它的父亲节点，而父亲节点发生变化后再删除又只暂时影响父亲节点的父亲节点，不删除则不再影响任何祖先节点。

得出第一个结论：最好贪心地自下而上的删点。

我再看一看题意：

- 支持一种删除操作：删除某个点，它的所有儿子节点连接到它的父亲节点，它的点权加到父亲节点上。

得出第二个结论：儿子节点数量和点权是共同转移的，可以放在一起计算。

不难看出这个题求的是最大删除个数，不考虑后续影响，删一个点对答案的贡献跟它的点权或者子节点数量没有半毛钱关系，不管你是什么样的点答案都只会加一。

得出第三个结论：在所有可删的点中，删一个子节点数量或者点权都比较小的点比较优。

把三个结论结合在一起，就有了一个贪心的思路：

我们自下而上的计算答案，对于一个点，优先删除它子节点数量加点权比较小的数，
删到不能删为止，每删一次答案就加一，并且修改它的信息。

而寻找点权和子节点数量较小的点可以通过快排实现。

思路完毕之后就是考虑代码实现了！

```
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
const int maxn=2000010;
int n,m;
int a[maxn],key[maxn],id[maxn],temp[maxn],ans,cnt,head[maxn];
struct node
{
	int to,next;
}e[maxn];
void build(int x,int y)
{
	e[++cnt].to=y;
	e[cnt].next=head[x];
	head[x]=cnt;
}
bool cmp(int a,int b)
{
	return a<b;
}
void dfs(int u)
{
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		dfs(v);
	}
	int top=0;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		temp[++top]=key[v];//temp排序数组，key是点权加子节点个数和，看做关键字，所以叫key 
		id[top]=v;
	}
	sort(temp+1,temp+top+1,cmp);
	for(int i=1;i<=top;i++)
	{
		if(key[u]+temp[i]-1<=m)
		{
			key[u]+=temp[i]-1;//更新key 
			ans++;
		}
		else break; 
	}
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=0;i<=n-1;i++)
	{
		scanf("%lld",&a[i]);
	}
	for(int i=0;i<=n-1;i++)
	{
		int x;
		scanf("%lld",&x);
		key[i]=a[i]+x;//初始化key 
		for(int j=1;j<=x;j++)
		{
			int y;
			scanf("%lld",&y);
			build(i,y);
		}
	}
	dfs(0);
	printf("%lld",ans);
}
```


---

## 作者：hzoi_liuchang (赞：3)

## 分析
一道贪心题

首先我们可以证明最优的贡献一定是从下依次合并到上的

不会出现一个节点不能合并到父亲节点，却能合并到父亲节点的祖先节点的情况

我们设当前的节点为 $u$,$u$ 的父亲节点为 $v$，$v$ 的父亲节点是 $fa$

如果 $u$ 不能合并到 $v$ 上，那么必定有

 $c[u]+son[u]-1+c[v] +son[v]>m$

如果我们把 $v$ 合并到 $fa$ 上再把 $u$ 合并到 $fa$ 上

那么 $fa$ 此时的值为 

$c[fa]+son[fa]-1+c[u]+son[u] -1+c[v]+son[v]$

我们发现右半部分一定是大于 $m$ 的

因此此时 $fa$ 的值一定大于 $m$

所以合并的过程一定是从下到上依次进行的

不会出现将某个节点合并到父亲节点后又将该节点的儿子节点合并到其父亲节点上

所以我们可以一遍 $dfs$ 求出答案

对于每一个节点将其所有儿子节点对它的贡献从小到大排序，依次合并，直到不能合并为止

某个节点 $u$ 对其父亲节点 $fa$ 的贡献为 $son[u]+c[u]-1$
## 代码
``` cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#define rg register
const int maxn=2e6+5;
inline int read(){
	rg int x=0,fh=1;
	rg char ch=getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*fh;
}
int h[maxn],tot=1;
struct asd{
	int to,nxt;
}b[maxn<<1];
void ad(int aa,int bb){
	b[tot].to=bb;
	b[tot].nxt=h[aa];
	h[aa]=tot++;
}
int son[maxn],c[maxn],n,m,ans,js[maxn];
void dfs(int now,int fa){
	std::vector<int> g;
	for(rg int i=h[now];i!=-1;i=b[i].nxt){
		rg int u=b[i].to;
		if(u==fa) continue;
		dfs(u,now);
		g.push_back(js[u]-1);
	}
	std::sort(g.begin(),g.end());
	rg int haha=g.size()-1;
	for(rg int i=0;i<=haha;i++){
		if(js[now]+g[i]<=m){
			js[now]+=g[i];
			ans++;
		}
	}
	g.clear();
}
int main(){
	memset(h,-1,sizeof(h));
	n=read(),m=read();
	rg int aa;
	for(rg int i=1;i<=n;i++){
		c[i]=read();
	}
	for(rg int i=1;i<=n;i++){
		son[i]=read();
		for(rg int j=1;j<=son[i];j++){
			aa=read();
			aa++;
			ad(aa,i),ad(i,aa);
		}
		js[i]=son[i]+c[i];
	}
	dfs(1,0);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：HH_Halo (赞：2)

~~考完试才发现这竟然是道紫题，感觉评高了~~

## 思路分析
* 首先明确题意，题目中的删除，本质上是每个节点负重的转移，而每个节点的负重即为儿子个数再加上本身的樱花数，也就是点权
* 考虑如何删除，依据题意，即使一个点被删除了，其负重也不会凭空消失，而是从下往上一直累加。 据此，我们需要从下往上逐个删除
* 另外的问题就是，一个点可能会有多个子节点，在转移过程中，依据贪心思想，我们需要将子节点的负重排序，因为按dfs序直接转移很可能会出现负重过大的节点导致其他负重较小的点无法转移
* 这里贪心成立的条件就是上面所提到的，一个节点的负重不会消失，所以遇到能删的情况就直接删就好了

*代码很简单，是目前的最优解*
## $\textcolor{green}{Code}$
```c++
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define R register
#define N 2000010
using namespace std;
inline int read(){
	int x = 0,f = 1;
	char ch = getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
int n,m,c[N],siz[N],weight[N],b[N],top,ans,head[N];
struct edge{
	int to,next;
}e[N];
int len;
void addedge(int u,int v){
	e[++len].to = v;
	e[len].next = head[u];
	head[u] = len;
}
void dfs(int u){
	for(R int i = head[u];i;i = e[i].next){
		int v = e[i].to;
		dfs(v);
	}
	top = 0;
	for(R int i = head[u];i;i = e[i].next){
		int v = e[i].to;
		b[++top] = weight[v];
	}
	sort(b+1,b+1+top);
	for(R int i = 1;i <= top;i++){
		if(weight[u]+b[i]-1<=m){
			ans++,weight[u] = weight[u]+b[i]-1;
			//printf("%d->weight[%d]=%d\n",b[i],u,weight[u]);
		}
		else break;
	}
}
int main(){
	n = read(),m = read();
	for(R int i = 1;i <= n;i++)c[i] = read();
	for(R int i = 1;i <= n;i++){
		int k = read();
		siz[i] = k;
		weight[i] = siz[i]+c[i];
		for(R int j = 1;j <= k;j++){
			int x = read()+1;
			addedge(i,x);
		}
	}
	dfs(1);
	printf("%d\n",ans);
	return 0;
}

```

---

## 作者：ez_lcw (赞：2)

首先想一下题目中的操作如何转化：

> 当一个节点被去掉之后，这个节点上的樱花和它的儿子节点都被连到删掉节点的父节点上。

设当前节点为 $u$，$u$ 的父节点为 $fa$，儿子个数为 $son_u$。那么当我们把节点 $u$ 删去时，$fa$ 的樱花数会加上 $c_u$，儿子个数会加上 $son-1$（减 $1$ 是因为 $u$ 本来是 $fa$ 的儿子但被删去了）。

那么删去一个节点对其父亲的负载增加值就被我们算出来了，设为 $val_i=c_u+son_u-1$。

想了想 dp 做法没能想出来，于是想了一下贪心。

考虑从下往上贪心，设当前节点为 $u$，先递归处理删除 $u$ 的子树内除了 $u$ 和 $u$ 的儿子的节点（不妨把这些节点称为孙子节点，~~尽管它们可能是 u 的孙子、曾孙子、曾曾孙子~~）的最大贡献，再考虑删除 $u$ 的儿子的最大贡献，然后回溯。

如何处理删除 $u$ 的儿子对 $u$ 的贡献？我们可以把 $u$ 的儿子按它们的负载（孙子节点被删完后的负载），然后从小往大地删除，直到不能删为止（$u$ 的负载要大于 $m$ 时）。这样就能保证在有限的负载增加值中删去最多的节点。

为什么从下往上贪心是对的？

我们先画个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/vfdmpucb.png)

结合上面这个图，认为贪心不正确的人就会说：有没有可能我在 $u=2$ 的时候删去了 $3$ 号节点，增加了 $2$ 节点的负载。导致在 $u=1$ 的时候 $2$ 节点因为负载过大而不能被删去。想一想，发现要删除 $2$ 节点可能要取消删除 $2$ 子树内的很多个节点，才能删除 $2$ 节点，这样会使删除的节点数减少或不变，所以不如直接从下往上贪心。

代码如下：

```cpp
#include<bits/stdc++.h>

#define N 2000010

using namespace std;

int n,m,ans,val[N],a[N];
int cnt,head[N],nxt[N],to[N];

void adde(int u,int v)
{
	to[++cnt]=v;
	nxt[cnt]=head[u];
	head[u]=cnt;
}

void dfs(int u)
{
	for(int i=head[u];i;i=nxt[i]) dfs(to[i]);//先递归
	int tot=0;
	for(int i=head[u];i;i=nxt[i]) a[++tot]=val[to[i]];//把每个子节点的负载值加入排序数组
	sort(a+1,a+tot+1);//排序
	for(int i=1;i<=tot;i++)
	{
		if(val[u]+a[i]-1<=m)//贪心取
		{
			val[u]+=a[i]-1;
			ans++;
		}
		else break;
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&val[i]);
	for(int i=1;i<=n;i++)
	{
		int k;
		scanf("%d",&k);
		val[i]=val[i]+k;//重新设置val
		for(int j=1;j<=k;j++)
		{
			int v;
			scanf("%d",&v);
			v++;//注意！
			adde(i,v);
		}
	}
	dfs(1);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：潜翎 (赞：2)

这其实是一道蛮水的紫题。

我的思路不同于已有题解的思路，代码实际运行效率要更慢，要吸点氧才能通过~~qwq~~，但是胜在好想与好理解。~~反正省选评测都要吸氧嘛我这个吸氧跑的还挺快的332ms呢~~

回到正题。

我们只需要贪心的，自下而上的删除点就可以了。可以贪心的原因** YoungNeal **大佬说的非常清楚明白。

我的思路是：用优先队列维护可以选择删除的儿子。~~确实很容易想到对不对~~

这道题有两个坑点。一是点的编号从0开始，二是对于已删除的点，根本不需要把儿子和它父亲的边重新连，直接把它的权值标为-1表示已删除，把它的儿子加入它的父亲的优先队列，再扫到这个点特判就完事了。因为每个点只会被删除一次，所以这样搞是正确的。

还有，这题建单向边就可以了，建双向边会在你删了几个点之后出现奇奇怪怪的bug。~~[惨痛教训](https://www.luogu.org/recordnew/lists?uid=101526&pid=P4107&status=&sort=0)~~

好啦，更多的就看代码吧。

如果帮助到你，记得点赞哦。

```cpp
#include <queue>
#include <stdio.h>
#include <algorithm>
#define N 2000010
#define P pair<int,int>
using namespace std;
int n,m,tot,ans;
int val[N],vec[N],next[N],head[N],son[N];
int read()
{
    int x=0,w=1;
    char ch; ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x*w;
}//这只是个最普通的快读板子qwq 
void add(int x,int y)
{
    vec[++tot]=y;
    next[tot]=head[x];
    head[x]=tot;
}
void dfs(int u)
{
    priority_queue<P>q;
    for(int i=head[u];i;i=next[i])
    {
        int v=vec[i];
        dfs(v);
        q.push(P(-val[v]-son[v],v));//这是一个大根堆，取负能让它完成小根堆的操作qwq 
    }
    while(!q.empty())//有儿子可删 
    {
        int v=q.top().second;//反正我们也只用节点编号嘛qwq 
        q.pop();
        if(val[u]+val[v]+son[u]+son[v]-1<=m)
        {
            val[u]+=val[v];val[v]=-1;//标记删除，一定要标记哦 
            son[u]+=son[v]-1;
            ans++;
            for(int i=head[v];i;i=next[i])
            {
                int z=vec[i];
                if(val[z]==-1) continue;
                q.push(P(-val[z]-son[z],z));//把没删的z儿子插到u上 
            }
        }
        else return;
    }
}
int main()
{
    int x;
    n=read();m=read();
    for(int i=0;i<n;i++) val[i]=read();
    for(int i=0;i<n;i++)//一定记住点的编号从0开始qwq 
    {
        son[i]=read();
        for(int j=1;j<=son[i];j++) x=read(),add(i,x);
    }
    dfs(0);
    printf("%d",ans);
    return 0;
}
```


------------
后记：

第一次不看题解切~~水的一批的~~紫题，成就感max

---

## 作者：Digital_Sunrise (赞：1)

### P4107题解
### 题目大意:

```
1、这是一个有根树。
2、对于每一个节点，它的子节点数量和自身权值和不能超过
指定的m。
3、删除一个节点就是将其子节点连到其父节点上，点权利也
加到父节点上。
4、要使得删除次数最多

```
~~莫名想起消消乐~~

### 解题思路

首先，一眼望过去，不是 $\text{dp}$ 就是贪心

很明显，子问题都没有独立性，所以直接排除 $\text{dp}$

所以，一定是贪心。

使用数组 weight 来表示某一个节点的重量($weight[i] = son(i) + c[i]$)

对于每一个节点，将它所有的子节点的 weight 依次存储于数组 a 中

然后把 $a~\text{sort}$ 一遍

(这时候$a$的作用就很明了了，为了使原本的weight不变)

从小到大排序后，从第一个开始依次遍历

只要使得 $weight[u] + a[v] - 1 <= m$ 就把他删掉(u是当前节点，

v是它的子节点)

那么就删除节点v

而对于每一个节点，要将其子节点的 weight 值全都处理完毕才能

处理此节点

所以我们要使用 $\text{dfs}$ 来实现

### 核心代码

这里提供两个版本

1、 $\text{vector}$ 版本

```cpp
void dfs(int u)
{
	for(int i = 0;i < G[u].size();i++) dfs(G[u][i]);
	int tot = 0;
	for(int i = 0;i < G[u].size();i++) a[++tot] = weight[G[u][i]];
	sort(a + 1,a + tot +1);
	for(int i = 1;i <= tot;i++)
	{
		if(weight[u] + a[i] - 1 <= m)
		{
			weight[u] += a[i] - 1;
			ans++;
		}
		else break;
	}
}
```

2、邻接表版本
```cpp
void dfs(int u)
{
	for(int i = head[u];i;i = e[i].next) dfs(e[i].to);
	int tot = 0;
	for(int i = head[u];i;i = e[i].next) a[++tot] = weight[e[i].to];
	sort(a + 1,a + tot +1);
	for(int i = 1;i <= tot;i++)
	{
		if(weight[u] + a[i] - 1 <= m)
		{
			weight[u] += a[i] - 1;
			ans++;
		}
		else break;
	}
}
```
**代码**

注意一下，这道题不能使用 $\text{cin}$ 和 $\text{cout}$ ，会超时
```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m,ans;
int val[2000010],a[2000010];
int weight[2000010];
vector <int> G[2000010];

void dfs(int u)
{
	for(int i = 0;i < G[u].size();i++) dfs(G[u][i]);
	int tot = 0;
	for(int i = 0;i < G[u].size();i++) a[++tot] = weight[G[u][i]];
	sort(a + 1,a + tot +1);
	for(int i = 1;i <= tot;i++)
	{
		if(weight[u] + a[i] - 1 <= m)
		{
			weight[u] += a[i] - 1;
			ans++;
		}
		else break;
	}
}

int main()
{
	cin >> n >> m;
	for(int i = 1;i <= n;i++) scanf("%d",&val[i]);
	for(int i = 1;i <= n;i++)
	{
		int x,y;
		scanf("%d",&x);
		weight[i] = x + val[i];
		for(int j = 1;j <= x;j++)
		{
			scanf("%d",&y);
			G[i].push_back(y + 1);
		}
	}
	dfs(1);
	printf("%d",ans); 
    return 0;
}
```


---

## 作者：Phykyer (赞：1)

冲着树形 $dp$ 来做的这道题，写了一发普通的树形 $dp$ 交上去挂了之后，才意识到这道题并没有那么简单，需要用到贪心的思想来解题。  

首先，我们可以用可以定义一个数组 $ctt[x]$ （$contribution$）代表当前节点 $x$ 如果被删除会使其父亲增重多少 , 那么显然有 $ctt[x] = ctt[x] = son[x] + w[x]$ ($son[x]$ 代表 $x$ 的儿子数， $w[x]$ 代表 $x$ 上的樱花个数)。  

接下来我们考虑删除节点，对于一个节点其可删除的必要条件即是：  
$w[x] + ctt[y] + son[x] - 1 <= m$   
这里就要用到贪心的策略，即优先考虑删除 $ctt$ 值最小的儿子，再考虑删除其他的儿子。这样贪心的正确性是显然的。  

那么这道题就解决了，但是这道题会卡常，用 $set$ 存会 $mle$ （~~大概是我写的太丑了~~），用 $vector$ 存会 $tle$ ，开 $O2$ 可过，但是作为一道省选题可以放心吸氧，所以用 $vector$ 即可。  

以下是代码部分：  

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

const int N = 2000010;

int n, m;
int head[N], ver[N], Next[N], cnt;
int w[N], son[N], ctt[N], ans[N];
// ans为以x为根的子树内能删的最大个数
// 其它数组存储内容如上文所述 
vector < pair < int, int > > f[N];

inline void add(int x, int y) {
	ver[++cnt] = y; Next[cnt] = head[x]; head[x] = cnt;
}

inline void dp(int x) {
	for (int i = head[x]; i; i = Next[i]) {
		int y = ver[i];
		dp(y);
		ans[x] += ans[y];
		son[x]++;
		f[x].push_back(make_pair(ctt[y], y));
	}
	ctt[x] = son[x] + w[x];
	sort(f[x].begin(), f[x].end());
	// 从小到大排序贪心
	for (int i = 0; i < f[x].size(); i++) {
		int y = f[x][i].second;
		if (w[x] + ctt[y] + son[x] - 1 <= m) {
			ans[x] += 1;
			w[x] += w[y];
			son[x] += son[y] - 1;
			ctt[x] = son[x] + w[x];
			// 删除一个节点时更新它父亲的信息
		}
	}
}

inline int read() {
	register int x = 0; char ch = getchar();
	while (ch < '0' || ch > '9') ch = getchar();
	while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
	return x;
}

int main() {
	n = read(); m = read();
	register int i, j;
	for (i = 1; i <= n; i++) w[i] = read();
	int x, y;
	for (i = 1; i <= n; i++) {
		x = read();
		for (j = 1; j <= x; j++) {
			y = read() + 1;
			add(i, y);
		}
	}
	dp(1);
	cout << ans[1] << endl;
	return 0;
}
```


---

## 作者：寒鸽儿 (赞：1)

简单的dfs + 贪心罢  
选取的策略是每次选择代价最小的孩子割掉,直到不能再割为止  
割掉一个孩子$i$,会造成父亲承载代价增加$c_i + deg_i$,$deg_i$为结点的当前度数  
记得每次割完之后更新当前结点的信息($c_i$和$deg_i$)  
代码吸氧可过(考题的编译选项貌似也有O2)  
```cpp
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#define itra vector<int>::iterator

using namespace std;

const int N = 2345678, M = 123456;

int head[N], ver[N], nex[N], m, tot;
inline void addedge(int u, int v) {
	ver[tot] = v; nex[tot] = head[u]; head[u] = tot++;
}

int c[N], deg[N], res = 0;
bool cmp(int x, int y) {
	return c[x] + deg[x] < c[y] + deg[y];
}
void dfs(int cur) {
	vector<int> v;
	for(int i = head[cur]; ~i; i = nex[i]) {
		dfs(ver[i]);
		v.push_back(ver[i]);
	}
	sort(v.begin(), v.end(), cmp);
	int tt = c[cur] + deg[cur], delc = 0, deldeg = 0;
	for(itra it = v.begin(); it != v.end(); ++it) {
		if(tt + c[*it] + deg[*it] - 1 <= m) {
			tt += c[*it] + deg[*it] - 1;
			delc += c[*it]; deldeg += deg[*it] - 1;
			++res;
		}
	}
	c[cur] += delc; deg[cur] += deldeg;
}

int main() {
	memset(head, -1, sizeof(head));
	int n, tmp;
	scanf("%d %d", &n, &m);
	for(int i = 1; i <= n; ++i) scanf("%d", c + i);
	for(int i = 1; i <= n; ++i) {
		scanf("%d", deg + i);
		for(int j = 1; j <= deg[i]; ++j) {
			scanf("%d", &tmp);
			addedge(i, tmp + 1);
		}
	}
	dfs(1);
	printf("%d\n", res); 
	return 0;
}
```

---

## 作者：C20203030 (赞：0)


## 一、题目

[点此看题](https://www.luogu.org/problem/P4107)

## 二、解法

我们发现删去一个点就会给它的父节点造成$son[v]+c[v]-1$的负担。

我们遍历整棵树，贪心地看，我们选择删去的子节点的负担越小就越优，于是我们从小到大地删除子节点。

但是增加了当前点的负担也给当前点的父亲的操作造成影响，那我们的贪心是错误的吗？其实更新当前点的更新对答案的贡献至少为1，而对于父节点的操作贡献影响至多为1，所以我们贪心出来的操作一定是最优的，这里的讨论可以类比[2018年提高组D1T3](https://blog.csdn.net/C202044zxy/article/details/100800491)。


```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
const int MAXN = 2000005;
int read()
{
	int x=0,flag=1;char c;
	while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
	while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*flag;
}
int n,m,tot,ans,f[MAXN],son[MAXN],c[MAXN];
struct edge
{
    int v,next;
}e[2*MAXN];
struct node
{
    int u,c;
    bool operator < (const node &B) const {
        return c<B.c;
    }
};
void dfs(int u,int fa)
{
    vector<node> ve;
    for(int i=f[u];i;i=e[i].next)
    {
        int v=e[i].v;
        if(v==fa) continue;
        dfs(v,u);
        son[u]++;
        ve.push_back(node{v,son[v]+c[v]});
    }
    sort(ve.begin(),ve.end());
    for(int i=0;i<ve.size();i++)
    {
        int v=ve[i].u;
        if(c[u]+son[u]+ve[i].c-1<=m)
        {
            c[u]+=c[v];
            son[u]+=son[v]-1;
            ans++;
        }
        else break;
    }
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=n;i++)
        c[i]=read();
    for(int i=1;i<=n;i++)
    {
        int k=read();
        for(int j=1;j<=k;j++)
        {
            int v=read()+1;
            e[++tot]=edge{v,f[i]},f[i]=tot;
            e[++tot]=edge{i,f[v]},f[v]=tot;
        }
    }
    dfs(1,0);
    printf("%d\n",ans);
}
```

---

## 作者：MloVtry (赞：0)

贪心。

因为每个点删除之后儿子和樱花都会加到父亲上，所以令c[i]+sons[i]为删除i号节点的代价。

每个节点都删掉自己孩子中代价最小的那个，然后把自己的代价更新一下。

代码
```cpp
#include<algorithm>
#include<iostream>
#define N 2000005
#include<cstdio>
#define M N
using namespace std;
int a[N],c[N],n,m,l[N],r[N],knt,ans;
int read()  //读入优化
{
    int out=0,flag=1;
    char c=getchar();
    while(c<48||c>57) {if(c=='-') flag=-1;c=getchar();}
    while(c>=48&&c<=57)
    {
        out=out*10+c-48;
        c=getchar();
    }
    return out*flag;
}
bool comp(int aa,int bb)
{
	return c[aa]<c[bb];
}
void dfs(int now)
{
	for(int i=l[now];i<=r[now];++i) dfs(a[i]),c[now]++;
	
	sort(a+l[now],a+r[now]+1,comp);
	
	for(int i=l[now];i<=r[now];++i)
	{
		if(c[now]+c[a[i]]-1<=m) c[now]+=c[a[i]]-1,ans++;
		else break;
	}
	
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;++i) c[i]=read();
	for(int i=1;i<=n;++i)
	{
		int it=read();
		l[i]=knt+1;
		while(it--) a[++knt]=read()+1;
		r[i]=knt;
	}
	dfs(1);
	printf("%d\n",ans);
	return 0;
}
```

---


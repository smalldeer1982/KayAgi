# [HEOI2015] 最短不公共子串

## 题目描述

在虐各种最长公共子串、子序列的题虐的不耐烦了之后，你决定反其道而行之。

下面给出一些定义：

- 一个串的“子串”指的是它的连续的一段，例如 `bcd` 是 `abcdef` 的子串，但 `bde` 不是。
- 一个串的“子序列”指的是它的可以不连续的一段，例如 `bde` 是 `abcdef` 的子序列，但 `bdd` 不是。

下面，给两个小写字母串 $a, b$，请你计算：

1. $a$ 的一个最短的子串，它不是 $b$ 的子串。
2. $a$ 的一个最短的子串，它不是 $b$ 的子序列。
3. $a$ 的一个最短的子序列，它不是 $b$ 的子串。
4. $a$ 的一个最短的子序列，它不是 $b$ 的子序列。

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $20$。
- 对于 $50\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $500$。
- 对于 $100\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $2000$。

## 样例 #1

### 输入

```
aabbcc
abcabc```

### 输出

```
2
4
2
4```

## 样例 #2

### 输入

```
aabbcc
aabbcc```

### 输出

```
-1
-1
2
-1```

# 题解

## 作者：UniverseofHK (赞：12)

## 楼上巨佬的思路都很清晰！但代码略显冗长

**题意**：

问最短的满足：是A的子串（子序列），且不是B的子串（子序列，子序列（子串））。（共四个问题）

**思路**：

1. 子串问题，考虑后缀自动机；子序列问题，考虑序列自动机；
2. 然后本题要求属于前者，而不属于后者的子结构，可以考虑暴力的在两种DAG上同时跑；若前者可以跑，后者却不能跑，说明此子结构仅属于前者，好像问题就解决了？
3. 但仔细一想，长度为$2000$的串子序列似乎太多了，好像不能跑完？这里我们考虑$bfs$，记录哪些状态（二维）已经遍历；对于已经遍历过的状态，虽然此前在遍历时当前状态所代表的子结构可能不一样（比如序列自动机通过不同的路径到达某个节点），但此后节点的可到达性却只与当前节点是否可到达有关，而与怎样到达的无关，故后续节点是否可到达在之前的$bfs$中已经处理好了；因此可以像普通的$bfs$一样，遍历过的状态可接忽略掉！（使用$n×n$的$vis$记录）
4. 复杂度：后缀自动机为$O(n*∑)$；序列自动机为$O(n*∑)$；每个后缀自动机节点数为$2*n$，每个序列自动机节点数为$n$，$bfs$遍历时每个点遍历边数为$∑$，因此$bfs$复杂度为$O(n*∑)$;
5. **总复杂度为$O(n*∑)$**。（$∑$为字符集大小）

**压行思路**：由于后缀自动机与序列自动机都可以看做DAG，而在$bfs$的时候也只需要用到边，因此在忽略这两种自动机的其他结构后，就变得一样啦！四个$bfs$完全可以写在一起。

### 代码

```cpp
#include "bits/stdc++.h"
using namespace std;

const int maxn = 4e3+10;

struct P{ int a, b, c; };
int ch[2][2][maxn][26], fa[2][maxn], len[2][maxn];
bool vis[maxn][maxn];
int tot[2]={1,1}, last[2]={1,1};
char s[maxn];

void add(int c, int f) {
    int p=last[f], np=last[f]=++tot[f];
    len[f][np]=len[f][p]+1;
    for(; p&&!ch[f][1][p][c]; p=fa[f][p]) ch[f][1][p][c]=np;
    if(!p) fa[f][np]=1;
    else {
        int q=ch[f][1][p][c];
        if(len[f][q]==len[f][p]+1) fa[f][np]=q;
        else {
            int nq=++tot[f]; len[f][nq]=len[f][p]+1;
            fa[f][nq]=fa[f][q]; fa[f][q]=fa[f][np]=nq;
            memcpy(ch[f][1][nq],ch[f][1][q],104);
            for(; p&&ch[f][1][p][c]==q; p=fa[f][p]) ch[f][1][p][c]=nq;
        }
    }
}

void pre(int f) {
    for(int i=strlen(s+1); i; --i) {
        memcpy(ch[f][0][i-1],ch[f][0][i],104);
        ch[f][0][i-1][s[i]-'a']=i;
    }
}

void bfs(int f1, int f2) {
    memset(vis,0,sizeof(vis));
    queue<P> q;
    q.push((P){f1,f2,0}); vis[f1][f2]=1;
    while(!q.empty()) {
        P now=q.front(); q.pop();
        for(int i=0; i<26; ++i) if(ch[0][f1][now.a][i]) {
            if(ch[1][f2][now.b][i]) {
                int a=ch[0][f1][now.a][i], b=ch[1][f2][now.b][i];
                if(!vis[a][b]) vis[a][b]=1, q.push((P){a,b,now.c+1});
            }
            else return (void)printf("%d\n", now.c+1);
        }
    }
    printf("-1\n");
}

int main() {
    scanf("%s", s+1);
    pre(0); for(int i=1; s[i]; ++i) add(s[i]-'a',0);
    scanf("%s", s+1);
    pre(1); for(int i=1; s[i]; ++i) add(s[i]-'a',1);
    bfs(1,1); bfs(1,0); bfs(0,1); bfs(0,0);
}
```

### [更棒的观赏体验！](https://blog.csdn.net/weixin_43823767/article/details/102689565)

---

## 作者：Ebola (赞：10)

网上有说用DP的，但那样就相当于做了4道题，我追求效率，肯定不会这么干

其实可以每个串建一个后缀自动机，以及一个序列自动机，分别用于识别子串和子序列

序列自动机是一个相当不优秀的自动机，其构造复杂度理论是O(n^2)的，因为每新增一个字符，序列自动机上有很多结点都能继续接受这个字符，所以都要连边过去

每一问就相当于在A、B串相应的自动机上跑广搜，遇到第一个A串匹配、B串失配的字符就输出当前深度

这样我们就可以写一个广搜，然后复制3遍，改几个字母就可以了哈哈哈哈

```cpp
#include<bits/stdc++.h>
using namespace std;

struct SAM
{
    int ch[4010][26],prt[4010];
    int len[4010];
    int lst,tot;
    SAM(){lst=tot=1;}
    
    void insert(int c)
    {
        int p=lst,np=++tot;len[np]=len[p]+1;
        while(p&&!ch[p][c]) ch[p][c]=np,p=prt[p];
        if(!p) prt[np]=1;
        else
        {
            int q=ch[p][c];
            if(len[q]==len[p]+1) prt[np]=q;
            else
            {
                int nq=++tot;len[nq]=len[p]+1;
                memcpy(ch[nq],ch[q],sizeof(ch[nq]));
                prt[nq]=prt[q];prt[q]=prt[np]=nq;
                while(ch[p][c]==q) ch[p][c]=nq,p=prt[p];
            }
        }
        lst=np;
    }
} SA,SB;

struct SqAM
{
    int ch[4010][26],lst[26],pre[4010];
    int root,tot;
    SqAM(){root=tot=1;for(int i=0;i<26;i++)lst[i]=1;}
    
    void insert(int c)
    {
        int p=lst[c],np=++tot;
        pre[np]=p;
        for(int i=0;i<26;i++)
            for(int j=lst[i];j&&!ch[j][c];j=pre[j])
                ch[j][c]=np;
        lst[c]=np;
    }
} SQA,SQB;

char A[2010],B[2010];
int la,lb;
struct THIRD
{
    int a,b,step;
    THIRD(int x=0,int y=0,int z=0):a(x),b(y),step(z){}
};
int vis[4010][4010];

int BFS1()
{
    queue<THIRD> q;
    q.push(THIRD(1,1,0));
    vis[1][1]=1;
    while(!q.empty())
    {
        int ra=q.front().a,rb=q.front().b,st=q.front().step;
        for(int i=0;i<26;i++)
        {
            int va=SA.ch[ra][i],vb=SB.ch[rb][i];
            if(va&&vb)
            {
                if(vis[va][vb]==1) continue;
                q.push(THIRD(va,vb,st+1));
                vis[va][vb]=1;
            }
            if(va&&!vb) return st+1;
        }
        q.pop();
    }
    return -1;
}

int BFS2()
{
    queue<THIRD> q;
    q.push(THIRD(1,1,0));
    vis[1][1]=2;
    while(!q.empty())
    {
        int ra=q.front().a,rb=q.front().b,st=q.front().step;
        for(int i=0;i<26;i++)
        {
            int va=SA.ch[ra][i],vb=SQB.ch[rb][i];
            if(va&&vb)
            {
                if(vis[va][vb]==2) continue;
                q.push(THIRD(va,vb,st+1));
                vis[va][vb]=2;
            }
            if(va&&!vb) return st+1;
        }
        q.pop();
    }
    return -1;
}

int BFS3()
{
    queue<THIRD> q;
    q.push(THIRD(1,1,0));
    vis[1][1]=3;
    while(!q.empty())
    {
        int ra=q.front().a,rb=q.front().b,st=q.front().step;
        for(int i=0;i<26;i++)
        {
            int va=SQA.ch[ra][i],vb=SB.ch[rb][i];
            if(va&&vb)
            {
                if(vis[va][vb]==3) continue;
                q.push(THIRD(va,vb,st+1));
                vis[va][vb]=3;
            }
            if(va&&!vb) return st+1;
        }
        q.pop();
    }
    return -1;
}

int BFS4()
{
    queue<THIRD> q;
    q.push(THIRD(1,1,0));
    vis[1][1]=4;
    while(!q.empty())
    {
        int ra=q.front().a,rb=q.front().b,st=q.front().step;
        for(int i=0;i<26;i++)
        {
            int va=SQA.ch[ra][i],vb=SQB.ch[rb][i];
            if(va&&vb)
            {
                if(vis[va][vb]==4) continue;
                q.push(THIRD(va,vb,st+1));
                vis[va][vb]=4;
            }
            if(va&&!vb) return st+1;
        }
        q.pop();
    }
    return -1;
}

int main()
{
    scanf("%s%s",A,B);
    la=strlen(A),lb=strlen(B);
    for(int i=0;i<la;i++) SA.insert(A[i]-'a'),SQA.insert(A[i]-'a');
    for(int i=0;i<lb;i++) SB.insert(B[i]-'a'),SQB.insert(B[i]-'a');
    printf("%d\n%d\n%d\n%d\n",BFS1(),BFS2(),BFS3(),BFS4());
    return 0;
}
```

---

## 作者：Flandre_495 (赞：4)

### 不会sam还想切题的小伙伴们集合了。

一道四合一题，如果分开做前两个好说，后两个得有点操作 ，不过由于我太菜做不得。

那我们把这四个看成一类问题。

考虑自动机：一个节点表示一个状态，每条边表示状态的转移。由于子串和子序列都能建出自动机来，那么我们只需要对两个自动机进行相同的转移，则 $A$ 中有而 $B$ 中没有的状态就是我们要找的答案。

子序列建成自动机这个应该都会，由于希望最长的匹配，肯定相同的字符越靠前越好。每个位置是一个点，向后每个字符往离它最近的点连边，时间复杂度与空间复杂度均为 $O(n*$ 字符集大小$)$ 。

子串建成自动机可以选择前缀自动机也可选择后缀自动机，而这题数据范围是 $2000$，因为复杂度瓶颈并不在这里，当然如果不想考虑空间的话可以写 $sam$。我们这里只需要用 $trie$ 当自动机就可以了，把每个子串取出来建立一个 $trie$，字符总长度 $O(n^2)$，时间复杂度与空间复杂度均为 $O(n^2*字符集大小)$。看着大算算其实可过。

那么自动机就建好了，每次询问是什么，就把两个字符串建成相应的自动机就好了。那么现在考虑如何找答案。

因为一条边相当于加进去一个字符，我们进行 $BFS$，遇到第一个 $A$ 中存在而 $B$ 中不存在的状态就把长度 $+1$ 输出出来。如果遍历 $A$ 的完整个自动机（自动机肯定不会有环的），还没有找到一个 $B$ 中没有的状态，那 $A$ 就太逊了，输出 $-1$。

考虑 $BFS$ 复杂度：$trie$ 进行 $BFS$ 时，由于 $trie$ 是像树一样的结构，每个点只会被遍历一次，复杂度不会超过 $O(n^2)$ 。而当两个序列自动机进行遍历的时候，由于到达一个点可以通过不同的路径，如果无脑加点会被卡成指数级。我们需要用 $vis$ 数组记录一下哪些状态到达过，由于序列自动机节点有 $n$ 个，这样时间复杂度与空间复杂度也都是 $O(n^2)$ 的，而且这个复杂度瓶颈不可避，前面自然也就不需要那么优了。

不过要注意只有两个自动机同时为序列自动机的时候才用 $vis$，否则 $trie$ 那么多点也开不下是吧~

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=101010;
const int qwq=2000100;
const int inf=0x3f3f3f3f;

struct T {

	char s[N];
	int n;
	int ch[qwq][26],cnt,now,rt;

	void trie() {
		memset(ch,0,sizeof(ch));
		rt = now = cnt = 1;
		for(int i=1;i<=n;i++) {
			now = rt;
			for(int j=i;j<=n;j++) {
				int c = s[j] - 'a';
				if(!ch[now][c]) ch[now][c] = ++cnt;
				now = ch[now][c];
			}
		}
	}

	void lie() {
		memset(ch,0,sizeof(ch));
		cnt = n; rt = 0;
		for(int i=1;i<=n;i++) {
			for(int j=i-1;j>=0;j--) {
				ch[j][ s[i]-'a' ] = i;
				if(s[j]==s[i]) break;
			}
		}
	}

} A,B;

struct E{ int x,y,le; };
queue <E> q;
bool vis[2333][2333];

int query() {
	bool flag = 0;
	if(A.rt==0 && B.rt==0) flag = 1;
	q.push( (E){A.rt,B.rt,0} );
	vis[A.rt][B.rt] = 1;
	while(!q.empty()) {
		E now = q.front(); q.pop();
		for(int i=0;i<25;i++) {
			int u = A.ch[now.x][i], v = B.ch[now.y][i];
			if(flag) { if(vis[u][v]) continue; }
			if(!u) continue;
			if(u && !v) { while(!q.empty()) q.pop(); return now.le+1; }
			q.push( (E){u,v,now.le+1} );
			if(flag) vis[u][v] = 1;
		}
	}
	return -1;
}

int main() {
	int ans4;
	scanf("%s%s",A.s+1,B.s+1);
	A.n = strlen(A.s+1); B.n = strlen(B.s+1);
	A.trie(); B.trie(); cout<<query()<<"\n";
	B.lie();            cout<<query()<<"\n";
	A.lie();            ans4 = query();
	B.trie();           cout<<query()<<"\n"<<ans4;
	return 0;
}
```

如果有不太严谨或者复杂度错误的地方希望各位大佬指正，谢谢 orz。

---

## 作者：lhm_ (赞：4)

给定两个字符串$A$和$B$，我们需要找出一个串，其在$A$中出现且不在$B$中出现，这个串为子串或者子序列，求在每种情况下，该串的最短长度。

考虑到后缀自动机可以识别一个字符串的所有子串，序列自动机可以识别一个字符串的所有子序列。

那么我们直接对$A$和$B$两个字符串建出相应的自动机，在两个自动机上同时进行$bfs$，当发现存在一个串在$A$上可识别，在$B$上无法识别，那么就找到了答案，若$bfs$整个过程结束了，说明没有符合要求的答案，直接返回$-1$。

具体实现细节看代码吧。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 4010
using namespace std;
char s1[maxn],s2[maxn];
struct Automata
{
    int root,tot,las;
    int len[maxn],ch[maxn][30],fa[maxn],last[30];
    void clear_sam()
    {
        tot=las=root=1;
        memset(fa,0,sizeof(fa));
        memset(ch,0,sizeof(ch));
        memset(len,0,sizeof(len));
    }
    void clear_seq()
    {
        root=2010;
        memset(ch,0,sizeof(ch));
        memset(last,0,sizeof(last));
    }
    void insert(int c)
    {
        int p=las,np=las=++tot;
        len[np]=len[p]+1;
        while(p&&!ch[p][c]) ch[p][c]=np,p=fa[p];
        if(!p) fa[np]=root;
        else
        {
            int q=ch[p][c];
            if(len[q]==len[p]+1) fa[np]=q;
            else
            {
                int nq=++tot;
                memcpy(ch[nq],ch[q],sizeof(ch[q]));
                len[nq]=len[p]+1,fa[nq]=fa[q],fa[np]=fa[q]=nq;
                while(ch[p][c]==q) ch[p][c]=nq,p=fa[p];
            }
        }
    }
    void sam(char *s)
    {
        clear_sam();
        int lenth=strlen(s+1);
        for(int i=1;i<=lenth;++i) insert(s[i]-'a'+1);
    }
    void seq(char *s)
    {
        clear_seq();
        int lenth=strlen(s+1);
        for(int i=lenth;i;--i)
        {
            for(int j=1;j<=26;++j) ch[i][j]=last[j];
            last[s[i]-'a'+1]=i;
        }
        for(int i=1;i<=26;++i) ch[root][i]=last[i];
    }
}A,B;
struct node
{
    int a,b,len;
};
bool vis[maxn][maxn];
int query()
{
    memset(vis,0,sizeof(vis));    
    queue<node> q;
    q.push((node){A.root,B.root,0});
    vis[A.root][B.root]=true;
    while(!q.empty())
    {
        node now=q.front();
        q.pop();
        for(int i=1;i<=26;++i)
        {
            int a=A.ch[now.a][i],b=B.ch[now.b][i];
            if(vis[a][b]) continue;
            if(a&&!b) return now.len+1;
            vis[a][b]=true;
            q.push((node){a,b,now.len+1});
        }
    }
    return -1;
}
int main()
{
	scanf("%s%s",s1+1,s2+1);
    A.sam(s1),B.sam(s2),printf("%d\n",query());
    A.sam(s1),B.seq(s2),printf("%d\n",query());
    A.seq(s1),B.sam(s2),printf("%d\n",query());
    A.seq(s1),B.seq(s2),printf("%d\n",query());
	return 0;
}
```


---

## 作者：密期望 (赞：2)

一看题面4合1，想偷懒的我就不想写了。于是我就在想，我可不可以只写一个函数然后调用4遍A掉这道题，然后我发现是可行的。

首先分析题目，我们可以很快明白，我们需要构建后缀自动机和序列自动机。很巧合的是，这俩货都是一个有向无环图，所以我们可以强行抽象题目，得到以下这个新题目：

给出两个都只有一个源点的有向无环图，同时从源点出发，只能同时经过边权（转移字符）相同的边。要求找到最短的一条路径，使得第一个图中走到的点有一条边是第二个图中的点没有的（第一个图中的点还能继续转移，而第二个图中的点无路可走）。如果第一个图中的任意一条路径在第二个途中都存在对应的一条路径，那么输出-1。

这下我们就把4个问题化为同一个问题了。那么这么进行代码设计才可以让一个函数既能接受后缀自动机，又能接受序列自动机呢？

常用的有两个办法，一个是使用template关键字，让函数本身变为一个不确定参数的东西（就是让std::sort可以为所欲为的那个）。而另一种办法则是使用OOP的特性：继承。

我们知道后缀自动机和序列自动机都是有向无环图（或者说“自动机”）。所以我们可以定义一个有向无环图（自动机）类。

```
class auto_mata{
    public:
        const int V;
        vector<int>tr[N];
        int node_count;
        auto_mata(int V_):V(V_){
            node_count=0;
        }
        virtual int new_node(){
            tr[node_count]=vector<int>(V,0);
            return node_count++;
        }
};
```
它拥有有向无环图（自动机）的共性：

V：字符集大小

tr：转移边

auto_mata(int)：生成指定字符集大小的一个有向无环图（自动机）

new_node：新建一个节点（这个不重要，可以再后面单独写）

我们的后缀自动机和序列自动机自然可以选择继承有向无环图（自动机）类，并在此基础上增添自己独有的代码

```
class suffix_auto_mata:public auto_mata{
    public:
        int last;
        int f[N];
        int len[N];
        suffix_auto_mata(int V_):auto_mata(V_){
            ...
        }
        ...
};
class subsequence_auto_mata:public auto_mata{
    public:
        subsequence_auto_mata(int V_):auto_mata(V_){
            ...
        }
        ...
};
```
这样我们就可以写一个函数
```
int bfs(const auto_mata &a,const auto_mata &b);
```
来接受任何两个有向无环图（自动机）（你甚至可以传入一个继承了auto_mata的trie，对应问题就有会出现变化。可以出8和1了），然后计算出我们抽象后的问题的答案。

以下为完整代码

```
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
#include<set>
#include<queue>
using std::queue;
using std::set;
using std::min;
using std::vector;
typedef long long ll;
typedef long double ld;
const int N=1e5;
const int INF=0x3f3f3f3f;
void file(const char *str){
    char in[100],out[100];
    sprintf(in,"%s.in",str),sprintf(out,"%s.out",str);
    freopen(in,"r",stdin),freopen(out,"w",stdout);
}
ll read(){
    ll a=0;int op=1;char ch=getchar();
    while(ch<'0'||'9'<ch){if(ch=='-')op=-1;ch=getchar();}
    while('0'<=ch&&ch<='9'){a=(a<<3)+(a<<1)+(48^ch);ch=getchar();}
    return a*op;
}
class auto_mata{
    public:
        const int V;
        vector<int>tr[N];
        int node_count;
        auto_mata(int V_):V(V_){
            node_count=0;
        }
        virtual int new_node(){
            tr[node_count]=vector<int>(V,0);
            return node_count++;
        }
};
class suffix_auto_mata:public auto_mata{
    public:
        int last;
        int f[N];
        int len[N];
        suffix_auto_mata(int V_):auto_mata(V_){
            new_node();
            new_node();
            last=1;
        }
        virtual int new_node(){
            int t=auto_mata::new_node();
            f[t]=0;
            len[t]=0;
            return t;
        }
        int split(int c,int p){
            int q=tr[p][c],nq=new_node();
            f[nq]=f[q];
            f[q]=nq;
            len[nq]=len[p]+1;
            for(int i=0;i<V;i++)tr[nq][i]=tr[q][i];
            while(p&&tr[p][c]==q){
                tr[p][c]=nq;
                p=f[p];
            }
            return nq;
        }
        int add(int c){
            return last=add(c,last);
        }
        int add(int c,int p){
            if(tr[p][c]){
                if(len[tr[p][c]]==len[p]+1)return tr[p][c];
                return split(c,p);
            }
            int np=new_node();
            len[np]=len[p]+1;
            while(p&&!tr[p][c]){
                tr[p][c]=np;
                p=f[p];
            }
            if(!p){
                f[np]=1;
            }else{
                if(len[tr[p][c]]==len[p]+1){
                    f[np]=tr[p][c];
                }else{
                    f[np]=split(c,p);
                }
            }
            return np;
        }
};
class subsequence_auto_mata:public auto_mata{
    public:
        subsequence_auto_mata(int V_):auto_mata(V_){
            new_node();
            new_node();
        }
        void add(int c){
            int t=new_node();
            for(int i=t-1;i&&!tr[i][c];i--)tr[i][c]=t;
        }
};
set<int>s[N];
int bfs(const auto_mata &a,const auto_mata &b){
    int x,y,d;
    queue<int>qx,qy,qd;
    for(int i=1;i<(int)a.node_count;i++)s[i].clear();
    s[1].insert(1);
    qx.push(1);
    qy.push(1);
    qd.push(0);
    while(!qx.empty()){
        x=qx.front();
        y=qy.front();
        d=qd.front();
        if(!y)return d;
        qx.pop();
        qy.pop();
        qd.pop();
        for(int i=0;i<a.V;i++)if(a.tr[x][i]){
            if(s[a.tr[x][i]].find(b.tr[y][i])==s[a.tr[x][i]].end()){
                s[a.tr[x][i]].insert(b.tr[y][i]);
                qx.push(a.tr[x][i]);
                qy.push(b.tr[y][i]);
                qd.push(d+1);
            }
        }
    }
    return -1;
}
suffix_auto_mata sufa(26),sufb(26);
subsequence_auto_mata seqa(26),seqb(26);
char str[N];
void input(){
    scanf(" %s",str);
    for(int i=0;str[i];i++){
        sufa.add(str[i]-'a');
        seqa.add(str[i]-'a');
    }
    scanf(" %s",str);
    for(int i=0;str[i];i++){
        sufb.add(str[i]-'a');
        seqb.add(str[i]-'a');
    }
}
void ini(){
}
void solve(){
    printf("%d\n",bfs(sufa,sufb));
    printf("%d\n",bfs(sufa,seqb));
    printf("%d\n",bfs(seqa,sufb));
    printf("%d\n",bfs(seqa,seqb));
}
void output(){
}
void test(){
    input();
    ini();
    solve();
    output();
}
void all(){
    file("4112");
    test();
}
int main(){
    all();
    return 0;
}
```

由于OOP和STL喜闻乐见的常数，再加上写法各种暴力，不扣细节，所以要开O2才能过。但事实上不像我这么写得丑应该是不会比普通做法慢多少的。

---

## 作者：sh7adow_ (赞：2)

### Waring

在阅读本文之前，你需要学会 [OI-Wiki 自动机](https://oi-wiki.org/string/automaton/) 。

经过作者尝试，你需要开`O2优化`，否则只会拿到 $70$ 分的好成绩。

### 要点
- 序列自动机

### 定义

序列自动机是接受且仅接受一个字符串的子序列的自动机。

本文中用 $s$ 代指这个字符串。

### 状态
若 $s$ 包含  $n$ 个字符，那么序列自动机包含 $n+1$  个状态。

令 $t$  是 $s$  的一个子序列，那么 $\delta(start,t)$ 是  在 $s$ 中第一次出现时末端的位置。

也就是说，一个状态 $i$ 表示前缀 $s[1..i]$ 的子序列与前缀 $s[1..i-1]$  的子序列的差集。

序列自动机上的所有状态都是接受状态。

### 转移

由状态定义可以得到， $\delta(u,c)=\min\{i|i>u,s[i]=c\}$ ，也就是字符 $c$ 下一次出现的位置。

为什么是“下一次”出现的位置呢？因为若 $i>j$ ，后缀 $s[i..|s|]$ 的子序列是后缀 $s[j..|s|]$ 的子序列的子集，一定是选尽量靠前的最优。

### 构建

从后向前扫描，过程中维护每个字符最前的出现位置：

![](https://cdn.luogu.com.cn/upload/image_hosting/he68x1rz.png)

这样构建的复杂度是 $O(n|\sum|)$ 。

### Solution
这题的 (1) 和 (3) 两问需要`后缀自动机`，而且做法类似，在这里只讲解 (2) 和 (4) 两问。

(2) 比较简单，枚举 $A$ 的子串输入进 $B$ 的序列自动机，若不接受则计入答案。

(4) 需要 `DP`。令 $f(i,j)$ 表示在 $A$ 的序列自动机中处于状态 $i$ ，在 $B$ 的序列自动机中处于状态 $j$ ，需要再添加多少个字符能够不是公共子序列。

$f(i,null)=0$ ， $f(i,j)=\min\limits_{\delta_A(i,c) \ne null}f(\delta_A(i,c),\delta_B(j,c))+1$ 。

### Code
```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 2005;

char s[N], t[N];
int na[N][26], nb[N][26], nxt[26];
int n, m, a[N], b[N], tot = 1, p = 1, f[N][N << 1];

struct SAM {
  int par, ch[26], len;
} sam[N << 1];

void insert(int x) {
  int np = ++tot;
  sam[np].len = sam[p].len + 1;
  while (p && !sam[p].ch[x]) {
    sam[p].ch[x] = np;
    p = sam[p].par;
  }
  if (p == 0)
    sam[np].par = 1;
  else {
    int q = sam[p].ch[x];
    if (sam[q].len == sam[p].len + 1)
      sam[np].par = q;
    else {
      int nq = ++tot;
      sam[nq].len = sam[p].len + 1;
      memcpy(sam[nq].ch, sam[q].ch, sizeof(sam[q].ch));
      sam[nq].par = sam[q].par;
      sam[q].par = sam[np].par = nq;
      while (p && sam[p].ch[x] == q) {
        sam[p].ch[x] = nq;
        p = sam[p].par;
      }
    }
  }
  p = np;
}

int main() {
  scanf("%s%s", s + 1, t + 1);

  n = strlen(s + 1);
  m = strlen(t + 1);

  for (int i = 1; i <= n; ++i) a[i] = s[i] - 'a';
  for (int i = 1; i <= m; ++i) b[i] = t[i] - 'a';

  for (int i = 1; i <= m; ++i) insert(b[i]);

  for (int i = 0; i < 26; ++i) nxt[i] = n + 1;
  for (int i = n; i >= 0; --i) {
    memcpy(na[i], nxt, sizeof(nxt));
    nxt[a[i]] = i;
  }

  for (int i = 0; i < 26; ++i) nxt[i] = m + 1;
  for (int i = m; i >= 0; --i) {
    memcpy(nb[i], nxt, sizeof(nxt));
    nxt[b[i]] = i;
  }

  int ans = N;

  for (int l = 1; l <= n; ++l) {
    for (int r = l, u = 1; r <= n; ++r) {
      u = sam[u].ch[a[r]];
      if (!u) {
        ans = min(ans, r - l + 1);
        break;
      }
    }
  }

  printf("%d\n", ans == N ? -1 : ans);

  ans = N;

  for (int l = 1; l <= n; ++l) {
    for (int r = l, u = 0; r <= n; ++r) {
      u = nb[u][a[r]];
      if (u == m + 1) {
        ans = min(ans, r - l + 1);
        break;
      }
    }
  }

  printf("%d\n", ans == N ? -1 : ans);

  for (int i = n; i >= 0; --i) {
    for (int j = 1; j <= tot; ++j) {
      f[i][j] = N;
      for (int c = 0; c < 26; ++c) {
        int u = na[i][c];
        int v = sam[j].ch[c];
        if (u <= n) f[i][j] = min(f[i][j], f[u][v] + 1);
      }
    }
  }

  printf("%d\n", f[0][1] == N ? -1 : f[0][1]);

  memset(f, 0, sizeof(f));

  for (int i = n; i >= 0; --i) {
    for (int j = 0; j <= m; ++j) {
      f[i][j] = N;
      for (int c = 0; c < 26; ++c) {
        int u = na[i][c];
        int v = nb[j][c];
        if (u <= n) f[i][j] = min(f[i][j], f[u][v] + 1);
      }
    }
  }

  printf("%d\n", f[0][0] == N ? -1 : f[0][0]);

  return 0;
}
```


------------
以上内容转自[OI-Wiki](https://oi-wiki.org/string/seq-automaton/#_5)。



---

## 作者：WhiteEurya (赞：2)

给定两个长度分别为 $n,m$ 的串 $A,B$，求：

(1) $A$ 的一个最短子串，它不是 $B$ 的子串

(2) $A$ 的一个最短子串，它不是 $B$ 的子序列

(3) $A$ 的一个最短子序列，它不是 $B$ 的子串

(4) $A$ 的一个最短子序列，它不是 $B$ 的子序列

输出四个答案的长度。$n, m \leq 2 \times 10^3$

-------------

是不是最近 $\texttt{steam}$ 正在打包所以我也做了这么一个打包题...

四个问题是四种解法，也就是典型的 $\text{4 in 1}$

接下来来分析这四种情况怎么处理。

前置技能： **后缀自动机**、**序列自动机**

--------------------------

### 情况(1)

相当于求 $A, B$ 串后缀的 $\text{lcp}$ 长度 $+1$。也可以看做是两个前缀的最长公共后缀。因为后缀的前缀是子串嘛。

这有很多解法，这里就直接用DP做。

记 $f(i,j)$ 表示 匹配到 $A$ 串的第 $i$ 个，$B$ 串的第 $j$ 个（都从后往前数）的最长公共后缀

逆序枚举 $a_i, b_j$，如果 $a_i = b_j$，表示两个串的最长公共后缀可以再同时往前往前扩展 $1$ 位，即
$$f(i,j)=f(i+1,j+1)+1$$
接下来枚举每一个前缀 $a_i,b_j$，然后求出两个前缀的最长公共后缀，即：
$$mx=\max(mx,f(i,j))$$
如果匹配上了($mx \neq n-i+1$)，那么就用 $mx$ 更新答案。
$$ans=\min(mx,ans)$$
复杂度 $O(nm)$

```c++
void Subtask() { 
    static int F[MaxN][MaxN];
    for(int i = N; i > 0; i--) 	
        for(int j = M; j > 0; j--) 
            if(S[i] == _S[j]) F[i][j] = F[i + 1][j + 1] + 1; 
    int Ans = Inf;
    for(int i = 1; i <= N; i++) {
        int _Ans = 0;
        #define Max(A, B) std::max(A, B)
        #define Min(A, B) std::min(A, B) 
        for(int j = 1; j <= M; j++) _Ans = Max(_Ans, F[i][j]);
        if(_Ans ^ (N - i + 1)) Ans = Min(Ans, _Ans + 1);
    }
    if(Ans == Inf) Ans = -1;
    printf("%d\n", Ans);
}
```



---------------

### 情况(2)

对 $B$ 串建立 **序列自动机**，在序列自动机上贪心。

建立序列自动机：

```c++
void Init() {
    int A[MaxN];
    for(int i = 0; i < 26; i++) A[i] = N + 1;
    for(int i = M; i >= 0; i--) {
        int Ch = _S[i] - 'a';
        for(int j = 0; j < 26; j++) Next[j][i] = A[j];
        A[Ch] = i;
    } 
}
```



怎么贪心呢？首先 $O(n)$ 地枚举 $A$ 的所有前缀，然后枚举这些前缀的所有后缀。

枚举前缀的后缀时，将这些值放到序列自动机上跑 。

记录一个值 $now$，当枚举到 $a_j$ 时，转移 $now=next(a_j,now)$

一旦出现失配（$now > n$），就可以用子串的长度来更新答案了。即：
$$ans=\min(ans,j-i+1)$$
复杂度 $O(n^2)$

```c++
void _Subtask() {
        Init();
        int Ans = Inf;
        for(int i = 1; i <= N; i++) {
            int Now = 0;
            for(int j = i; j <= N; j++) {
                int Ch = S[j] - 'a';
                Now = Next[Ch][Now];
                if(Now > N) {
                    Ans = Min(Ans, j - i + 1);
                    break;
                }
            }
        }
        if(Ans == Inf) Ans = -1; 
        printf("%d\n", Ans);
    }
```

----------------

### 情况(3)

对 $B$ 串建立 **后缀自动机**，然后在后缀自动机上DP。

原理和 $(1)$ 一样，找出最长的可匹配部分并使它尽量短，那么答案为长度 $+1$

后缀自动机：

```c++
void Insert(char C) {
    int Ch = C - 'a';
    int Np = ++Tot, P = Lst; Lst = Np;
    Len[Np] = Len[P] + 1;
    while(P && !Tr[Ch][P]) Tr[Ch][P] = Np, P = Fa[P];
    if(!P) Fa[Np] = 1;
    else {
        int Q = Tr[Ch][P];
        if(Len[Q] == Len[P] + 1) Fa[Np] = Q;
        else {
            int Nq = ++Tot; Fa[Nq] = Fa[Q]; Len[Nq] = Len[P] + 1;
            for(int i = 0; i < 26; i++) Tr[i][Nq] = Tr[i][Q];
            Fa[Q] = Fa[Np] = Nq;
            while(P && Tr[Ch][P] == Q) Tr[Ch][P] = Nq, P = Fa[P];
        } 
    }
}
```

记 $f(i)$ 表示在自动机上跑到位置 $i$ 的最短长度是多少。

那么每次枚举 $A$ 的每一个字符，并且遍历整个后缀自动机去跳。

假设 $i$ 枚举 $A$ 串，$j$ 枚举后缀自动机，记录 $now=tr(j,a_i)$

如果 $now \neq 0$，表示可以继续往下匹配，更新 $f$：
$$f(now)=\min(f(now),f(j) + 1)$$
否则，表示失配了，更新答案：
$$ans=\min(ans,f(j)+1)$$
复杂度 $O(n \times tot)$，其中 $tot$ 是后缀自动机的节点数。

```c++
void __Subtask() {
    static int F[MaxN]; memset(F, 0x3f, sizeof(F)); F[1] = 0;
    int Ans = Inf;
    for(int i = 1; i <= N; i++) {
        for(int j = 1; j <= Tot; j++) {
            int Ch = S[i] - 'a';
            int Now = Tr[Ch][j];
            if(!Now) Ans = Min(Ans, F[j] + 1);
            else F[Now] = Min(F[Now], F[j] + 1);
        }
    }
    if(Ans == Inf) Ans = -1;
    printf("%d\n", Ans);
}
```

----------------------

### 情况(4)

对 $B$ 串建立 **序列自动机**，然后在序列自动机上DP。

原理和 $(1)$，$(3)$ 一样，做法和 $(3)$ 几乎一模一样，除了把后缀自动机改成序列自动机以外。

不再赘述。

```c++
void ___Subtask() {
    static int F[MaxN]; memset(F, 0x3f, sizeof(F)); F[0] = 0;
    int Inf = F[1];
    int Ans = Inf;
    for(int i = 1; i <= N; i++) {
        for(int j = 0; j <= M; j++) {
            int Ch = S[i] - 'a';
            int Now = Next[Ch][j];
            if(Now > N) Ans = Min(Ans, F[j] + 1);
            else F[Now] = Min(F[Now], F[j] + 1);
        }
    }
    if(Ans == Inf) Ans = -1;
    printf("%d\n", Ans);
}
```

---------------

### 附录：

[洛谷 P 4112 最短不公共子串](https://www.luogu.org/problemnew/show/P4112)

[My blog](http://xiaoyao24256.com/index.php/archives/301/)

---

## 作者：_171829 (赞：0)

本题题意给你两个由小写英文字母组成的串 $A$  和 $B$，求：

1. $A$ 的一个最短的子串，它不是 $B$ 的子串；

2. $A$ 的一个最短的子串，它不是 $B$ 的子序列；

3. $A$ 的一个最短的子序列，它不是 $B$ 的子串；

4. $A$ 的一个最短的子序列，它不是 $B$ 的子序列。

$1\le\left\vert A \right\vert,\left\vert B \right\vert\le2000$


这题的 $(1)$ 和 $(3)$ 两问需要后缀自动机，而且做法类似，在这里只讲解 $(2)$ 和 $(4)$ 两问。

$(2)$ 比较简单，枚举 $A$ 的子串输入进 $B$ 的序列自动机，若不接受则计入答案。

(4) 需要 $DP$。令 $f(i,j)$ 表示在 $A$ 的序列自动机中处于状态,在 $B$ 的序列自动机中处于状态 $i$，需要再添加多少个字符能够不是公共子序列。

$f(i,null) = 0$

$f(i,j) = \frac{min}{\vartheta(i,c)\ne null} f(\vartheta_A(i,c),\vartheta_B(j,c))+1$

ac代码：
```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 2005;

char s[N], t[N];
int na[N][26], nb[N][26], nxt[26];
int n, m, a[N], b[N], tot = 1, p = 1, f[N][N << 1];

struct SAM {
  int par, ch[26], len;
} sam[N << 1];

void insert(int x) {
  int np = ++tot;  //新节点
  sam[np].len = sam[p].len + 1;
  while (p && !sam[p].ch[x]) {
    sam[p].ch[x] = np;
    p = sam[p].par;
  }
  if (p == 0)
    sam[np].par = 1;
  else {
    int q = sam[p].ch[x];
    if (sam[q].len == sam[p].len + 1)
      sam[np].par = q;
    else {
      int nq = ++tot;
      sam[nq].len = sam[p].len + 1;
      memcpy(sam[nq].ch, sam[q].ch, sizeof(sam[q].ch));
      sam[nq].par = sam[q].par;
      sam[q].par = sam[np].par = nq;
      while (p && sam[p].ch[x] == q) {
        sam[p].ch[x] = nq;
        p = sam[p].par;
      }
    }
  }
  p = np;
}

int main() {
  scanf("%s%s", s + 1, t + 1);

  n = strlen(s + 1);
  m = strlen(t + 1);

  for (int i = 1; i <= n; ++i) a[i] = s[i] - 'a';
  for (int i = 1; i <= m; ++i) b[i] = t[i] - 'a';

  for (int i = 1; i <= m; ++i) insert(b[i]);

  // nxt[S[i]]<-i
  for (int i = 0; i < 26; ++i) nxt[i] = n + 1;
  for (int i = n; i >= 0; --i) {
    memcpy(na[i], nxt, sizeof(nxt));
    nxt[a[i]] = i;
  }

  for (int i = 0; i < 26; ++i) nxt[i] = m + 1;
  for (int i = m; i >= 0; --i) {
    memcpy(nb[i], nxt, sizeof(nxt));
    nxt[b[i]] = i;
  }

  //四种情况计算答案
  // 1
  int ans = N;
  for (int l = 1; l <= n; ++l) {
    for (int r = l, u = 1; r <= n; ++r) {
      u = sam[u].ch[a[r]];
      if (!u) {
        ans = min(ans, r - l + 1);
        break;
      }
    }
  }

  printf("%d\n", ans == N ? -1 : ans);

  // 2
  ans = N;

  for (int l = 1; l <= n; ++l) {
    for (int r = l, u = 0; r <= n; ++r) {
      u = nb[u][a[r]];
      if (u == m + 1) {
        ans = min(ans, r - l + 1);
        break;
      }
    }
  }

  printf("%d\n", ans == N ? -1 : ans);

  // 3
  for (int i = n; i >= 0; --i) {
    for (int j = 1; j <= tot; ++j) {
      f[i][j] = N;
      for (int c = 0; c < 26; ++c) {
        int u = na[i][c];
        int v = sam[j].ch[c];
        if (u <= n) f[i][j] = min(f[i][j], f[u][v] + 1);
      }
    }
  }

  printf("%d\n", f[0][1] == N ? -1 : f[0][1]);

  // 4
  memset(f, 0, sizeof(f));

  for (int i = n; i >= 0; --i) {
    for (int j = 0; j <= m; ++j) {
      f[i][j] = N;
      for (int c = 0; c < 26; ++c) {
        int u = na[i][c];
        int v = nb[j][c];
        if (u <= n) f[i][j] = min(f[i][j], f[u][v] + 1);
      }
    }
  }

  printf("%d\n", f[0][0] == N ? -1 : f[0][0]);

  return 0;
}
```




---

## 作者：一扶苏一 (赞：0)

## 【SAM & 子序列自动机】【P4112】 [HEOI2015]最短不公共子串

### Analysis

一道非常无聊的四合一题。

前置知识是 SAM 和 [子序列自动机](https://www.luogu.com.cn/problem/P5826)。

以下约定 $a$，$b$ 串长均为 $n$，字符集大小为 $t$。

#### 问题 1

首先对 $b$ 建出 SAM，对于一个字符串 $s$，如果把它放在这个 SAM 上跑，没有跑到无法转移的位置，则 $s$ 是 $b$ 的子串，否则不是。

注意到串长非常小，因此我们可以枚举 $a$ 的子串的起始位置，然后逐个加入字符并在 SAM 上进行转移，如果加入一个字符时无法转移，那么显然当前子串就是一个符合要求的子串。最后对所有的起始位置的情况的答案取 min 即可。时间复杂度 $O(n^2)$。

#### 问题 2

对 $b$ 建出子序列自动机，用与问题 1 相同的做法枚举 $a$ 的子串的起始位置并计算答案即可。只不过这次时放在子序列自动机上跑。

这里的字符集很小，可以直接暴力构造子序列自动机而无需使用模板题的可持久化线段树。

构造自动机的复杂度为 $O(nt)$，匹配复杂度为 $O(n^2)$，总时间复杂度 $O(nt + n^2)$。

#### 问题 3

对 $a$ 建出子序列自动机。在这个自动机上遍历所有的路径即可遍历 $a$ 的所有子序列。

然后可以遍历 $a$ 的所有状态，同时维护当前状态在 $b$ 的 SAM 上的对应状态。显然某次转移如果转移出了自动机，那么 $a$ 的当前状态就是一个满足要求的子序列。考虑对于 $a$ 的子序列自动机的一个状态 $u$ 和 $b$ 的 SAM 的一个状态 $v$，如果匹配到了 $(u, v)$ 状态，那么该状态继续转移能增加的字符串长度是确定的，也就是说，对于每一个 $(u, v)$，我们只需要知道匹配到 $(u, v)$ 的最短字符串长度是多少。这个问题可以 BFS 解决，每次取队首，并尝试转移所有的字符，如果转移后的状态还没有入队，则压入队列并更新长度。如果某个转移在 $a$ 上存在但在 $b$ 上不存在，则直接更新答案即可。

考虑时间复杂度：SAM 个子序列自动机的节点数均为 $O(n)$，因此一共有 $O(n^2)$ 个状态。每次转移需要 $O(t)$ 枚举新加的字符，因此总复杂度 $O(n^2 t)$。

#### 问题 4

对 $b$ 也建出子序列自动机，然后用同样的方式进行 bfs 即可。时间复杂度 $O(n^2 t)$。

如果交上去代码 TLE/MLE 了很多点，有可能是因为在 bfs 的时候没有记录那些状态已经经过了而造成了 $O(n^4)$ 的时空复杂度。

### Code

```cpp
namespace Fusu {

const int maxt = 26;
const int maxn = 8005;

void Init();
void Ca1c();
void Ca2c();
void Ca3c();
void Ca4c();

void Main() {
  Init();
  Ca1c();
  Ca2c();
  Ca3c();
  Ca4c();
}

namespace SAM {

struct Node {
  Node *fail;
  int len;
  std::map<char, Node*> trans;
  bool vis[2005];
};
Node Mem[maxn], *pool = Mem;
inline Node *New(const int x) {
  auto u = pool++;
  u->len = x;
  return u;
};

void build(char *s, const int n, Node *&rt) {
  auto lst = rt = New(0);
  for (int i = 1, x = s[i] - 'a'; i <= n; x = s[++i] - 'a') {
    auto p = lst, np = New(i);
    lst = np;
    while (p && (p->trans.count(x) == false)) {
      p->trans[x] = np;
      p = p->fail;
    }
    if (p == nullptr) {
      np->fail = rt;
    } else {
      auto q = p->trans[x];
      if (q->len == (p->len + 1)) {
        np->fail = q;
      } else {
        auto nq = New(p->len + 1);
        nq->trans = q->trans;
        nq->fail = q->fail;
        q->fail = np->fail = nq;
        while (p && (p->trans[x] == q)) {
          p->trans[x] = nq;
          p = p->fail;
        }
      }
    }
  }
}

} // namespace SAM
SAM::Node *ra, *rb;

namespace SQAM {

void Build(int trans[][maxt], const char *const s, const int n) {
  for (int i = n, x = s[i] - 'a', di = i - 1; i; x = s[i = di--] - 'a') {
    for (int j = 0; j < maxt; ++j) {
      trans[di][j] = trans[i][j];
    }
    trans[di][x] = i;
  }
}

} // namespace SQAM
int ta[maxn][maxt], tb[maxn][maxt];

int n, m;
char s[maxn], t[maxn];

void Init() {
  n = qrs(s + 1);
  m = qrs(t + 1);
  SAM::build(t, m, rb);
  SQAM::Build(ta, s, n);
  SQAM::Build(tb, t, m);
}

void Ca1c() {
  int ans = n + 1;
  for (int i = 1; i <= n; ++i) {
    auto u = rb;
    for (int j = i, x = s[i] - 'a', len = 0; j <= n; x = s[++j] - 'a') if (++len < ans) {
      if (u->trans.count(x) == false) {
        ans = len;
      } else {
        u = u->trans[x];
      }
    } else {
      break;
    }
  }
  qw((ans == n + 1) ? -1 : ans, '\n');
}

void Ca2c() {
  int ans = n + 1;
  for (int i = 1; i <= n; ++i) {
    int u = 0;
    for (int j = i, x = s[j] - 'a', len = 0; j <= n; x = s[++j] - 'a') if (++len < ans) {
      if (tb[u][x] == 0) {
        ans = len;
      } else {
        u = tb[u][x];
      }
    } else {
      break;
    }
  }
  qw((ans == n + 1) ? -1 : ans, '\n');
}

std::queue<std::pair<int, std::pair<int, SAM::Node*> > > Q;
void Ca3c() {
  int ans = -1;
  Q.push({0, {0, rb}});
  rb->vis[0] = true;
  while (!Q.empty()) {
    auto u = Q.front(); Q.pop();
    int len = u.first + 1, sq = u.second.first;
    auto ss = u.second.second;
    bool flag = false;
    for (int j = 0; j < maxt; ++j) if (ta[sq][j] != 0) {
      if (ss->trans.count(j) == false) {
        ans = len;
        flag = true;
        break;
      } else if (ss->trans[j]->vis[ta[sq][j]] == false) {
        ss->trans[j]->vis[ta[sq][j]] = true;
        Q.push({len, {ta[sq][j], ss->trans[j]}});
      }
    }
    if (flag) break;
  }
  qw(ans, '\n');
}

std::queue<std::pair<int, std::pair<int, int> > > QQ;
bool vis[2005][2005];
void Ca4c() {
  int ans = -1;
  QQ.push({0, {0, 0}});
  vis[0][0] = true;
  while (!QQ.empty()) {
    auto x = QQ.front(); QQ.pop();
    int len = x.first + 1, u = x.second.first, v = x.second.second;
    bool flag = false;
    for (int j = 0; j < maxt; ++j) if (ta[u][j]) {
      if (tb[v][j]) {
        bool &vv = vis[ta[u][j]][tb[v][j]];
        if (vv == false) {
          QQ.push({len, {ta[u][j], tb[v][j]}});
          vv = true;
        }
      } else {
        ans = len;
        flag = true;
        break;
      }
    }
    if (flag) break;
  }
  qw(ans, '\n');
}

} // namespace Fusu

```





---


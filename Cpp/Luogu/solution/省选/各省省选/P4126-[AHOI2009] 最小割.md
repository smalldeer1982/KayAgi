# [AHOI2009] 最小割

## 题目描述

$A,B$ 两个国家正在交战，其中 $A$ 国的物资运输网中有 $N$ 个中转站，$M$ 条单向道路。设其中第 $i(1\le i\le M)$ 条道路连接了 $v_i,u_i$ 两个中转站，那么中转站 $v_i$ 可以通过该道路到达 $u_i$ 中转站，如果切断这条道路，需要代价 $c_i$。

现在 $B$ 国想找出一个路径切断方案，使中转站 $s$ 不能到达中转站 $t$，并且切断路径的代价之和最小。

小可可一眼就看出，这是一个求最小割的问题。但爱思考的小可可并不局限于此。现在他对每条单向道路提出两个问题：

- 问题一：是否存在一个最小代价路径切断方案，其中该道路被切断？
- 问题二：是否对任何一个最小代价路径切断方案，都有该道路被切断？

现在请你回答这两个问题。

## 说明/提示

设第 $(i+1)$ 行输入的边为 $i$ 号边，那么 $\{1,2\},\{6,7\},\{2,4,6\}$ 是仅有的三个最小代价切割方案。它们的并是 $\{1,2,4,6,7\}$，交是 $\{\varnothing \}$。

测试数据规模如下表所示

数据编号|N|M|数据编号|N|M
-|-|-|-|-|-
1|10|50|6|1000|20000
2|20|200|7|1000|40000
3|200|2000|8|2000|50000
4|200|2000|9|3000|60000
5|1000|20000|10|4000|60000

## 样例 #1

### 输入

```
6 7 1 6
1 2 3
1 3 2
2 4 4
2 5 1
3 5 5
4 6 2
5 6 3```

### 输出

```
1 0
1 0
0 0
1 0
0 0
1 0
1 0```

# 题解

## 作者：command_block (赞：33)

**最小割的可行边和必须边**(所有割集的交集和并集)

注意必须边$\subseteq$可行边.

显然,在**某种**最大流方案中,最小割$\Rightarrow$满流。

考虑现有的满流边 $u,v$ 如何被替代,不难想到 : **残量网络**中有包含 $u,v$ 的环(另一条路,注意还包括反向边)。

让流沿着环流动一圈,最大流不变,但是满流被破坏。

由此引出 : 两个端点在同一**强连通分量**内的边必然总不是最小割。

将当前残量网络缩点成`DAG`,上面的边才有可能成为最小割。

在这些边里面,直接将$S,T$相连的我们必须要割,这些边就是必须边。

对于其他边都能分别够构造割与不割的方案,它们是可行边。

在这个`DAG`上,每一种紧的割(不考虑权值)都是最小割。

左端点 : 靠近$S$的一端, 右端点 : 靠近$T$的一端。

割的构造 : 把这条边左端点到 $S$ 的路径钦定为 $S$ 集合,其余为 $T$ 集合,然后把所有 $S,T$ 之间的边割断,这是紧的,而且该边是最小割的一部分。

不割的构造 : 如果右端点不是 $T$ ,把这条边右端点到 $S$ 的路径钦定为 $S$ 集合。否则左端点必然不是 $S$ ,把这条边左端点到 $T$ 的路径钦定为 $T$ 集合即可。这样整条边总是被完整地包含在 $S$ 或 $T$ 集中。

在这个`DAG`上搞搞说不定还有什么新科技……

具体实现,需要先跑最大流,然后`Tarjan`缩强连通分量,条件是:

- 可行边 : 两端不在一个强连通分量内。

- 必须边 : 一端在$S$的分量内,另一端在$T$的分量内。

```cpp
#include<cstdio>
#include<vector>
#include<queue>
#define INF 1000000000 
#define MaxN 4050
#define MaxM 120500
using namespace std;
struct Line
{int to,nxt,cap;}l[MaxM];
int tl=1,fir[MaxN];
void add(int f,int t,int cap){
  l[++tl]=(Line){t,fir[f],cap};fir[f]=tl;
  l[++tl]=(Line){f,fir[t],0  };fir[t]=tl;
}
int S,T,n,dis[MaxN],cur[MaxN];
queue<int> q;
bool bfs()
{
  for (int i=1;i<=n;i++)
    {cur[i]=fir[i];dis[i]=0;}
  q.push(S);dis[S]=1;
  while(!q.empty()){
  	int u=q.front();
  	q.pop();
  	for (int i=fir[u],v;i;i=l[i].nxt)
  	  if (l[i].cap&&!dis[v=l[i].to]){
  	  	dis[v]=dis[u]+1;
  	  	q.push(v);
      }
  }return dis[T];
}
int dfs(int u,int flow)
{
  if (u==T)return flow;
  int sum=0,sav,v;
  for (int &i=cur[u];i;i=l[i].nxt){
  	if (dis[v=l[i].to]==dis[u]+1&&l[i].cap){
  	  sav=dfs(v,min(flow,l[i].cap));
  	  if (sav){
  	  	l[i].cap-=sav;
  	  	l[i^1].cap+=sav;
  	  	sum+=sav;
  	  	if (!(flow-=sav))return sum;
      }else dis[v]=-1;
    }
  }return sum;
}
int dfn[MaxN],low[MaxN],tim,
    stk[MaxN],top,col[MaxN],Bcnt;
bool in[MaxN];
void dfs2(int u)
{
  low[u]=dfn[u]=++tim;
  in[stk[++top]=u]=1;
  for (int i=fir[u],v;i;i=l[i].nxt)
    if (l[i].cap){
      if (!dfn[v=l[i].to])
        {dfs2(v);low[u]=min(low[u],low[v]);}
      else if (in[v])low[u]=min(low[u],dfn[v]);
    }
  if (low[u]==dfn[u]){
    Bcnt++;
    while(stk[top+1]!=u){
      in[stk[top]]=0;
      col[stk[top--]]=Bcnt;
    }
  }
}
int m,fr[MaxM],to[MaxM];
int main()
{
  scanf("%d%d%d%d",&n,&m,&S,&T);
  for (int i=1,cap;i<=m;i++){
    scanf("%d%d%d",&fr[i],&to[i],&cap);
    add(fr[i],to[i],cap);
  }while(bfs())dfs(S,INF);
  for (int i=1;i<=n;i++)
    if (!dfn[i])dfs2(i);
  for (int i=1;i<=m;i++)
    if (!l[i<<1].cap){
      printf("%d %d\n",
        col[fr[i]]!=col[to[i]],
        col[fr[i]]==col[S]&&col[to[i]]==col[T]
      );
    }else puts("0 0");
  return 0;
}
```

---

## 作者：斗神·君莫笑 (赞：26)

//蒟蒻sxz的第一篇题解

//和大佬们还有很大差距

//膜拜楼下守望大神



我似乎也有几个定理要证明：

#### 1.判定边xy是否可能在最小割中 （最小割可行边）

  充要条件：
  
　　1.满流。
  
　　2.在残余网络中找不到x到y的路径。（**正向弧都不行！**）
 
  也就是楼下大神的2
  
  很好理解，如果还能找到，那么砍了它也没什么用
  
  如果正向弧没流满，那么肯定不是最小割（可以找到另一条更好限制流量的边）
  
  只有满流才能让正向弧等于0，才有不能找到的条件
  
  因此，**在算法体现中，他们两个必定只能不属于一个SCC才能在最小割中**
  
------------

#### 2.判定边xy是否必然在最小割中
  （最小割必须边）
    
  充要条件：
   
　　1.满流。
  
　　2.残余网络中源点能到入点，出点能到汇点。
  
  若满流但在残余网络中源点不能到入点或出点不能到汇点，
  
  那么在每条单独路径上一定都存在一条满足最小割可行边的边
  
  （一条容量为0的正向弧阻断路径且没有其他路径），
  
  割掉这条可行边是可以起到同样的阻断效果同时代价更优的。

  因此，**在算法实现中，只有源点和x属于一个SCC，汇点和y属于一个SCC，才能达到割掉它属于最优解**
  
定理证明完了，接下来上代码

#### 就是用dinic跑完最大流以后tarjan求SCC，按照我推导的公式求解

附：本人对tarjan的理解不是特别深，再加上tarjan几乎就是模板，所以对SCC不明白的请参见模板P1726
 
 

------------

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){//读优 
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';ch=getchar();
	}
	return x;
}
int n,m,s,t;
struct Edge{
	int u,v,w,nxt;
}e[120010];
int head[4010],cnt=1;//注意：cnt必须从1开始，因为加边是n和n+1，偶数和偶数+1可以通过异或转化，具体请自行推导 
inline void add(int u,int v,int w){//前向星加边 
	e[++cnt].u=u;
	e[cnt].v=v;
	e[cnt].w=w;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
int dis[4010];
int bfs(){
	queue<int>q;//广搜队列 
	q.push(s);
	memset(dis,-1,sizeof(dis));//所有编号赋初值 
	dis[s]=0;//初始原点编号，让其可以朝下分层 
	while(!q.empty()){
		int u=q.front();q.pop();//取出队首 
		for(int i=head[u];i;i=e[i].nxt){
			if(e[i].w>0&&dis[e[i].v]==-1){//如果此点可以流并且它没有被编号过 
				dis[e[i].v]=dis[u]+1;//分层编号
				q.push(e[i].v);//入队 
				if(e[i].v==t)return 1;//如果将汇点编完号，返回，示意dinic继续找增广 
			}
		}
	}
	return 0;//找不到一条可行流，示意dinic返回 
}
int dfs(int x,int f){
	if(x==t||f==0)return f;//如果搜到了增广路或者没有流量走不下去 
	int used=0;//定义已经流出的流量 
	for(int i=head[x];i;i=e[i].nxt){
		if(e[i].w>0&&dis[e[i].v]==dis[x]+1){//如果此边能走通并且编号正确（根据dinic，只有是下一编号才能走通） 
			int k=dfs(e[i].v,min(e[i].w,f));//向下流，注意处理流量!!!一定要二者最小的！ 
			if(k==0)continue;//无法流通，继续处理下一条边 
			used+=k;f-=k;//减少剩余流量，增加流出流量 
			e[i].w-=k;e[i^1].w+=k;//对正向弧和反向弧做流量处理
			if(f==0)break;//剩余流量为0，结束 
		}
	}
	if(used==0)dis[x]=-1;//无法下流，使其退出分层，下次不用再走，否则浪费效率 
	return used;//返回可行流的最大流量 
}
int dinic(){
	int flow=0;//最大流 
	while(bfs())
		flow+=dfs(s,0x7fffffff);//加上每次增广可继续下流的流量 
	return flow;
}
int dfn[4010],low[4010],vis[4010],scc[4010],num,cntt;
stack<int>st;
void tarjan(int u){//tarjan模板，判scc分量，见模板题，不做详细解释 
	st.push(u);vis[u]=1;
	dfn[u]=low[u]=++cntt;
	for(int i=head[u];i;i=e[i].nxt){
		if(e[i].w==0)continue;//注意,满流时无法继续，是本题的关键点 
		if(dfn[e[i].v]==0){
			tarjan(e[i].v);
			low[u]=min(low[u],low[e[i].v]);
		}
		else if(vis[e[i].v]==1)
			low[u]=min(dfn[e[i].v],low[u]);
	}
	if(dfn[u]==low[u]){
		++num;
		while(1){
			int top=st.top();st.pop();
			vis[top]=0;scc[top]=num;
			if(top==u)break;
		}
	}
}
int main(){
	n=read();m=read();s=read();t=read();
	for(int i=1;i<=m;++i){
		int u,v,w;
		u=read();v=read();w=read();
		add(u,v,w);add(v,u,0);//加边，正向弧和反向弧 
	}
	int flow=dinic();//尽管flow并没有用，但调试较为方便 
	for(int i=1;i<=n;++i)
		if(scc[i]==0)
			tarjan(i);//如果没有判过scc，跑一遍，求出它属于的联通块
	//判断方法和公式见前面 
	for(int i=2;i<cnt;i+=2){//这样才能跳到每一条正向边 
		int u=e[i].u,v=e[i].v;
		if(e[i].w==0&&scc[u]!=scc[v]){//记得判断满流
			printf("1 ");
			if(scc[u]==scc[s]&&scc[v]==scc[t])printf("1");
			else printf("0");
		}
		else printf("0 0");
		printf("\n");
	}
	return 0;
} 
```


------------


最后，附加两个关于最小割的知识点：

1.常用描述

	表述一：删去若干条边使得源点到汇点不连通，
    
    求删边的权值和的最小可能值。
    
表述二：将点集分为(S,T)，

记所有从S中出发到T中的边的权值和为c(S,T)，

求c(S,T)的最小值。

2.求最小割

a. 以权值为容量，该网络最大流的值即为最小割的值

b. 在残量网络中，从源点出发进行一次增广BFS，

即得到一个分割。该分割是一个最小割


---

## 作者：ckain (赞：11)

#### 注：感谢 command_block 题解和万能的 uoj 群友．

可行边指存在于至少一个最小割集中的边．  
必须边指包含于任意最小割集中的边．  
发现题目的两问分别为判断可行边和判断必须边．  
我们现在考虑判断方法．

设最大流得到的某一个（任意一个）残量网络为 $G$．

#### $part\;1$ 可行边．  
对于一条边 $e$，如果它在 $G$ 上不是满流（满流指最大流后边权减为 $0$, 即被流满了），则将 $e$ 的边权 $-eps$（即减少一个微小值）之后，最大流的大小没有变化；而如果其满流，这样操作最大流肯定会变小．若 $e$ 不满流，则假设 $e$ 存在于一种最小割集中，将 $e$ 的边权 $-eps$，最小割集的大小会发生变化，而根据最大流等于最小割，最大流也因发生变化，而这于上文的结论不符．这就证明了，存在一种最大流后的残量网络使得 $e$ 不满流等价于（当且仅当）$e$ 不被包含在任意一个最小割集中．  
对于一条边  $e=(u \rightarrow v, w)$ 在进行最大流后若被流满，则有可能为可行边，需要进一步确定判断．我们考虑若存在一种最大流后的残量网络使得 $e$ 流不满，则应该满足可以找到 $u \rightarrow v$ 的另一条增广路径使得 $v$ 交还给 $u$ 一些流量（流经 $e$ 的）后，$u$ 可以不通过 $e$ 将其送到 $v$．对应在当前的残量网络上，我们只需要判断 $u$ 和 $v$ 是否在同一个强联通分量里即可（请注意，这里的强联通分量指的是由残量网络上不走边权为 $0$ 的边后求得的强联通分量）．

#### $part\;2$ 必须边．  
必须边集包含于可行边集．我们沿用 $part\;1$ 中的思路，求出残量网络上不走 0 边后的缩点图 $G^{'}$（$G^{'}$ 的边集是原图中满流，并且在缩点后不成自环的边，即使用有残余流量边缩点得到的新图再用满流边连接）．可以发现，$G^{'}$ 上的边就是可行边集．任意一种最小割，应都是若干个 $G^{'}$ 中的边组成的，并且 $G^{'}$ 中任意一种紧的割都是最小割．  
这里先提供一种构造最小割集的方法．将 $G^{'}$ 上的点划分成两个联通块，一部分和 $s$ 相连，记作 $S$ 集，另一部分和 $t$ 相连，记作 $T$ 集，将 $S$ 集和 $T$ 集间的边割掉，即构造出了一种最小割．  
我们对于 $e=(u \rightarrow v)$，若 $v$ 所在的强联通分量与 $t$ 所在的强联通分量不同，我们构造  $S=\left\{ x|x \in path_{s \rightarrow v} \right\}$，若 $u$ 所在的强联通分量和 $s$ 所在的强联通分量不同，我们构造 $T=\left\{ x|x \in path_{u \rightarrow t} \right\}$．这两中情况都可以构造出 $e$ 不割的一种最小割集出来，易知 $e$ 不是必须边；而剩下的情况，即 $s$ 与 $u$ 在同一强联通分量并且 $v$ 与 $t$ 在同一强联通分量，可得知 $e$ 一定为必须边．故也可以这样判断必须边：沿着残量网络中的非 $0$ 边，$s$ 可做到达 $u$，$v$可以到达 $t$．

#### code：
```cpp
#include<bits/stdc++.h>
#define pii pair<int, int>
#define fr first
#define sc second
using namespace std;
inline int rd(void){
	int s=0, f=1; char c=getchar();
	while(c<'0' || c>'9') {if(c=='-') f=0; c=getchar();}
	while(c>='0' && c<='9') {s=s*10+c-'0'; c=getchar();}
	return f? s:-s;
}
const int N=4005, M=60005, inf=2e9;

struct edge{int to, w, nt;} e[M<<1]; int hd[N], ect=1;
void _ade(int u, int v, int w){e[++ect]={v, w, hd[u]}; hd[u]=ect;}
void ade(int u, int v, int w){_ade(u, v, w); _ade(v, u, 0);}

struct node{int u, v, id;} g[M];

int dep[N];
bool bfs(int S, int T){
	memset(dep, -1, sizeof(dep));
	dep[S]=0;
	queue<int> q;
	q.push(S);
	while(!q.empty()){
		int u=q.front(); q.pop();
		for(int i=hd[u]; i; i=e[i].nt){
			int v=e[i].to;
			if(e[i].w && dep[v]==-1){
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}
	return ~dep[T];
}

int cur[N];
int dfs(int u, int flow, int T){
	if(u==T) return flow;
	for(int i=cur[u]; i; i=e[i].nt){
		int v=e[i].to;
		cur[u]=i;
		if(e[i].w && dep[v]==dep[u]+1){
			int nflow=dfs(v, min(flow, e[i].w), T);
			if(nflow){
				e[i].w-=nflow;
				e[i^1].w+=nflow;
				return nflow;
			}
			else dep[v]=-1;
		}
	}
	return 0;
}

int dinic(int S, int T){
	int totflow=0, nflow=0;
	while(bfs(S, T)){
		memcpy(cur, hd, sizeof(hd));
		while(nflow=dfs(S, inf, T)) totflow+=nflow;
	}
	return totflow;
}

int n, m, s, t;

int id, bid, dfn[N], low[N], bel[N], fstk[N];
stack<int> stk;
void tarjan(int u){
	dfn[u]=low[u]=++id;
	stk.push(u);
	fstk[u]=1;
	for(int i=hd[u]; i; i=e[i].nt){
		int v=e[i].to;
		if(!e[i].w) continue;
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u], low[v]);
		}
		else if(fstk[v]) low[u]=min(low[u], dfn[v]);
	}
	if(dfn[u]==low[u]){
		bid++;
		while(1){
			int x=stk.top(); stk.pop();
			bel[x]=bid;
			fstk[x]=0;
			if(x==u) break;
		}
	}
}

signed main(){
	n=rd(), m=rd(), s=rd(), t=rd();
	for(int i=1, u, v, w; i<=m; i++){
		u=rd(), v=rd(), w=rd();
		g[i]={u, v, ect+1};
		ade(u, v, w);
	}
	dinic(s, t);
	for(int i=1; i<=n; i++) if(!dfn[i]) tarjan(i);
	
	for(int i=1, u, v; i<=m; i++){
		u=g[i].u, v=g[i].v;
		if(e[g[i].id].w==0&& bel[u]!=bel[v]){
			printf("1 ");
			if(bel[u]==bel[s] && bel[v]==bel[t]) printf("1");
			else printf("0");
		}
		else printf("0 0");
		puts("");
	}
	return 0;
}
```

---

## 作者：asuldb (赞：11)

[题目](https://www.luogu.org/problemnew/show/P4126)

最小割的可行边和必须边

可行边$(u,v)$需要满足以下两个条件

1. 满流

1. 残量网络中不存在$u$到$v$的路径

这个挺好理解的呀，如果存在还存在路径的话那么这条边就不会是瓶颈了

必须边$(u,v)$需要满足的条件

1. 满流

1. 残量网络中$S$能到达$u$，$v$能到达$T$

这样的话$(u,v)$就成为了唯一的瓶颈了

我们可以直接在残量网络上跑$tarjan$，只跑没满流的边

如果发现$u$和$v$不在同一强联通分量里，就说明这是一条可行边

因为$(u,v)$满流，$(v,u)$必然存在，在同一连通分量里就说明可以从$u$走到$v$形成一个环，也就存在$u$到$v$的路径

如果$u$和$S$在同一个强联通分量里，$v$和$T$在同一个强连通分量里，那么说明这是一条必须边，和上面类似

代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#define re register
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
const int maxn=4e3+5;
const int inf=1e9;
inline int read() {
	char c=getchar();int x=0;while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
std::queue<int> q;
struct E{int v,nxt,f;}e[150000];
int n,m,S,T,cnt,top,p,mid,num=1;
int dfn[maxn],low[maxn],st[maxn],f[maxn];
int head[maxn],d[maxn],cur[maxn],col[maxn];
inline void C(int x,int y,int f) {
	e[++num].v=y;e[num].nxt=head[x];
	head[x]=num;e[num].f=f;
}
int X[60005],Y[60005],id[60005];
inline void add(int x,int y,int f) {C(x,y,f),C(y,x,0);}
inline int BFS() {
	for(re int i=1;i<=n;i++) d[i]=0,cur[i]=head[i];
	d[S]=1,q.push(S);
	while(!q.empty()) {
		int k=q.front();q.pop();
		for(re int i=head[k];i;i=e[i].nxt)
		if(!d[e[i].v]&&e[i].f) d[e[i].v]=d[k]+1,q.push(e[i].v);
	}
	return d[T];
}
int dfs(int x,int now) {
	if(x==T||!now) return now;
	int flow=0,ff;
	for(re int& i=cur[x];i;i=e[i].nxt)
	if(d[e[i].v]==d[x]+1) {
		ff=dfs(e[i].v,min(e[i].f,now));
		if(now<=0) continue;
		now-=ff,flow+=ff,e[i].f-=ff,e[i^1].f+=ff;
		if(!now) break;
	}
	return flow;
}
void tarjan(int x) {
	dfn[x]=low[x]=++cnt;
	st[++top]=x;f[x]=1;
	for(re int i=head[x];i;i=e[i].nxt) {
		if(!e[i].f) continue;
		if(!dfn[e[i].v]) tarjan(e[i].v),low[x]=min(low[x],low[e[i].v]);
		else if(f[e[i].v]) low[x]=min(low[x],dfn[e[i].v]);
	}
	if(dfn[x]==low[x]) {
		++p;
		do {
			mid=st[top--];
			f[mid]=0;
			col[mid]=p;
		}while(x!=mid);
	}
}
int main() {
	n=read(),m=read();S=read(),T=read();
	for(re int z,i=1;i<=m;i++) {
		X[i]=read(),Y[i]=read();
		z=read();id[i]=num+1;add(X[i],Y[i],z);
	}
	while(BFS()) dfs(S,inf);
	for(re int i=1;i<=n;i++) if(!dfn[i]) tarjan(i);
	for(re int i=1;i<=m;i++) {
		if(col[X[i]]!=col[Y[i]]&&!e[id[i]].f) putchar('1');
			else putchar('0');
		putchar(' ');
		if(!e[id[i]].f&&col[X[i]]==col[S]&&col[Y[i]]==col[T]) putchar('1');
			else putchar('0');
		putchar(10);
	}
	return 0;
}
```


---

## 作者：WeLikeStudying (赞：7)

- [类题](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/post-tu-lun-edges-in-mst)。

**题意**
- [链接](https://www.luogu.com.cn/problem/P4126)。
- 给定一个有向图连通图，源点和汇点，判断它的每条边属于这三种情况的哪一种：在所有最小割上，在部分最小割上，不在任何最小割上。
- 点数不大于 $4000$，边数不大于 $60000$。

**分析**
- 首先，根据我们对流和割的理解（[参见](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/wang-lao-liu)流模型章节），我们可以构造一种一般化的最小割方案，构造 $S,T$ 为两个分别包含源点和汇点的点集，使得从 $S$ 到 $T$ 所有的边都是满流的，那么这个边集一定是最小割，而且所有这样的边集组成最小割的所有可能方案。
- 基于最大流和最小割完全相等，我们容易证明这个事实，个人认为理解了这一点，后面的就很容易推导。
- 我们容易得到：如果一条边未满流，那么它不在任何最小割上。
- 那么如果一条边满流了，它是否总在某个最小割上呢？下面是一个反例。
![](https://cdn.luogu.com.cn/upload/image_hosting/rpir7iep.png)
- 没错，如果我们某条边满流，但是我们知道：这只不过是个巧合，证据就是存在另一条路径，它也可以流这一条，然后让这条不流，所以割这条边是没用的（反之，割这条边可以让某两个点不连通，根据上面的推论，它可以出现在割的方案内）。
- 考虑反向边此时显然有流，我们可以得出判定：两个端点不在同一个强连通分量内的满流边一定在某个最小割方案内。
- 接下来进行缩点，图即变成了有向无环图，根据上面的推论：如果一条边始终在最小割上，那么显然要求若不割这条边，$S$ 与 $T$ 始终连通。
- 所以我们就得到了第二个判定，如果在残量网络上加上这条边，$S$ 将与 $T$ 连通，考虑到反向边的因素，缩点后这条边可以看作是从 $S$ 流向 $T$，[代码实现](https://www.luogu.com.cn/paste/0w4dfpzy)。
- 说句实话，在残量网络上 $\text{Tarjan}$ 缩点然后建出一个 $\text{DAG}$（实际上，是从 $T$ 到 $S$ 的 $\text{DAG}$），上面任意（严格定义）的 $S,T$ 割都是最小割，然后直接从 $S$ 指向到 $T$ 的边一定在任意的最小割上，这个性质实在太优美了。
- 从实用性的角度，它已经可以解决如下问题，指定 $k$ 条边，询问它们是否能够同时在某个最小割上，除去网络流的复杂度，我们显然可以在线性时间内解决它。

---

## 作者：xht (赞：6)

题目地址：[P4126 [AHOI2009]最小割](https://www.luogu.org/problemnew/show/P4126)

#### 最小割的可行边与必须边

首先求最大流，那么最小割的可行边与必须边都必须是**满流**。

* 可行边：在残量网络中不存在 $x$ 到 $y$ 的路径（强连通分量）；

* 必须边：在残量网络中 $S$ 能到 $x$ && $y$ 能到 $T$ 。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 4e3 + 6, M = 6e4 + 6, inf = 1e9;
int n, m, s, t, d[N], f[N];
int Head[N], Edge[M<<1], Leng[M<<1], Next[M<<1], tot = 1;
struct E {
    int x, y, z;
} e[M<<1];
int dfn[N], low[N], num, st[N], top, ins[N], c[N], cnt;

inline void add(int x, int y, int z) {
    Edge[++tot] = y;
    Leng[tot] = z;
    Next[tot] = Head[x];
    Head[x] = tot;
}

inline bool bfs() {
    memset(d, 0, sizeof(d));
    queue<int> q;
    d[s] = 1;
    q.push(s);
    while (q.size()) {
        int x = q.front();
        q.pop();
        for (int i = Head[x]; i; i = Next[i]) {
            int y = Edge[i], z = Leng[i];
            if (d[y] || !z) continue;
            d[y] = d[x] + 1;
            q.push(y);
            if (y == t) return 1;
        }
    }
    return 0;
}

int dinic(int x, int flow) {
    if (x == t) return flow;
    int rest = flow;
    for (int i = Head[x]; i && rest; i = Next[i]) {
        int y = Edge[i], z = Leng[i];
        if (d[y] != d[x] + 1 || !z) continue;
        int k = dinic(y, min(z, rest));
        if (!k) d[y] = 0;
        else {
            Leng[i] -= k;
            Leng[i^1] += k;
            rest -= k;
        }
    }
    return flow - rest;
}

void dfs(int x, int k) {
    f[x] = k;
    for (int i = Head[x]; i; i = Next[i]) {
        int y = Edge[i], z = Leng[i^(k-1)];
        if (f[y] || !z) continue;
        dfs(y, k);
    }
}

void tarjan(int x) {
    dfn[x] = low[x] = ++num;
    st[++top] = x;
    ins[x] = 1;
    for (int i = Head[x]; i; i = Next[i]) {
        int y = Edge[i], z = Leng[i];
        if (!z) continue;
        if (!dfn[y]) {
            tarjan(y);
            low[x] = min(low[x], low[y]);
        } else if (ins[y])
            low[x] = min(low[x], dfn[y]);
    }
    if (dfn[x] == low[x]) {
        ++cnt;
        int y;
        do {
            y = st[top--];
            ins[y] = 0;
            c[y] = cnt;
        } while (x != y);
    }
}

int main() {
    cin >> n >> m >> s >> t;
    for (int i = 1; i <= m; i++) {
        scanf("%d %d %d", &e[i].x, &e[i].y, &e[i].z);
        add(e[i].x, e[i].y, e[i].z);
        add(e[i].y, e[i].x, 0);
    }
    while (bfs())
        while (dinic(s, inf));
    dfs(s, 1);
    dfs(t, 2);
    for (int i = 1; i <= n; i++)
        if (!dfn[i]) tarjan(i);
    for (int i = 1; i <= m; i++) {
        int k = i << 1;
        if (Leng[k]) puts("0 0");
        else printf("%d %d\n", c[e[i].x] != c[e[i].y], f[e[i].x] == 1 && f[e[i].y] == 2);
    }
    return 0;
}
```

---

## 作者：cirnovsky (赞：4)

[link。](https://www.luogu.com.cn/problem/P4126)

也许题不错，反正有点降智…

先给结论，在

$$
V_N=V \\
E_N=E \\
c(x,y)=w(x,y)
$$

的流网络中：

- 可行边：在增广完的 induced subgraph 中，不存在 $u$ 到 $v$ 的**路径**；
- 必要边：在增广完的 induced subgraph 中，可以从 $S$ 到 $u$ 且可以从 $v$ 到 $T$。

先看可行边。不存在 $(u,v)$ 有两个条件，一个是 $c_f(u,v)=0$，另一个是与之并联（特指以 $u$ 为起点，$v$ 为终点的）的线路中存在 $c_f(u',v')=0$。第一个的理解是，如果它没满流，则与之串联的 arcs 中存在比它的容量更小的边，根据最小割串联割最小的原则成立；第二个就是，如果你不把并联的砍了，你的划分压根不合法，何谈可行与否。

那么关于可行边的判断，把图缩点即可。

再看必要边。这个类比可行边即可，不赘述。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,S,T,co[4100],dfsnt,colnt,inst[4100],sta[4100],top,dfn[4100],low[4100],vi[4100],rec[60100];
vector<pair<int,int>> arc;
template<typename T> struct network {
	const int n;
	struct edge {
		int to,r; T w;
//		friend bool operator<(const edge& one,const edge& ano) { return one.to<ano.to || (one.to==ano.to && one.r<ano.r); }
	};
	vector<vector<edge>> e;
	vector<int> lev,iter;
	network(int n):n(n),e(n+1),lev(n+1),iter(n+1) {}
	void link(const int x,const int y,T w,int ID) {
		assert(1<=x && x<=n && 1<=y && y<=n);
		rec[ID]=int(e[x].size());
		e[x].push_back((edge){y,int(e[y].size())+(x==y),w});
		e[y].push_back((edge){x,int(e[x].size())-1,0});
	}
	bool BFS(const int s,const int t) {
		queue<int> q; lev.assign(n+1,0);
		for(q.push(s),lev[s]=1; q.size(); q.pop()) {
			for(int now=q.front(),i=iter[now]=0,y; i<int(e[now].size()); ++i) {
				if(now==t)	return 1;
				if(!lev[y=e[now][i].to] && e[now][i].w)	lev[y]=lev[now]+1,q.push(y);
			}
		}
		return lev[t];
	}
	T DFS(const int now,T f,const int t) {
		if(now==t)	return f;
		T res=0,tt;
		for(int& i=iter[now],y; i<int(e[now].size()); ++i) {
			if(lev[y=e[now][i].to]==lev[now]+1 && e[now][i].w && (tt=DFS(y,min(f,e[now][i].w),t))) {
				e[now][i].w-=tt; e[y][e[now][i].r].w+=tt; res+=tt; f-=tt;
				if(!f)	break;
			}
		}
		if(!res)	lev[now]=0;
		return res;
	}
	T get(const int s,const int t) {
		T res=0;
		while(BFS(s,t))	res+=DFS(s,numeric_limits<T>::max(),t);
		return res;
	}
};
template<typename T=int> T rd() {
	T x=0; char IO=getchar(); bool f=0;
	while(IO<'0' || IO>'9')	f|=IO=='-',IO=getchar();
	while(IO>='0' && IO<='9')	x=x*10+(IO&15),IO=getchar();
	return f?-x:x;
}
void DFS(const int now,const network<int>& G) {
	dfn[now]=low[now]=++dfsnt;
	inst[sta[++top]=now]=1;
	for(int i=0,y; i<int(G.e[now].size()); ++i) {
		if(!G.e[now][i].w)	continue;
		if(!dfn[y=G.e[now][i].to])	DFS(y,G),low[now]=min(low[now],low[y]);
		else if(inst[y])	low[now]=min(low[now],dfn[y]);
	}
	if(dfn[now]==low[now]) {
		++colnt;
		while(sta[top]!=now)	co[sta[top]]=colnt,inst[sta[top]]=0,top--;
		top--; co[now]=colnt; inst[now]=0;
	}
}
void DFS_network(const int now,const network<int>& G,const int c) {
	vi[now]=c;
	for(int i=0,y; i<int(G.e[now].size()); ++i) {
		if(!vi[y=G.e[now][i].to] && (c-1?G.e[y][G.e[now][i].r].w:G.e[now][i].w))	DFS_network(y,G,c);
	}
}
signed main() {
	freopen("mincut.in","r",stdin);
	freopen("mincut.out","w",stdout);
	n=rd(); m=rd(); S=rd(); T=rd();
	network<int> G(n);
	for(int i=0,x,y; i<m; ++i)	x=rd(),y=rd(),G.link(x,y,rd(),i),arc.emplace_back(x,y);
	for(int i=(G.get(S,T),1); i<=n; ++i)	if(!dfn[i])	DFS(i,G);
	DFS_network(S,G,1); DFS_network(T,G,2);
//	for(int i=1; i<=n; ++i)	printf(" --- %d ",vi[i]); puts("\n");
//	for(int i=1; i<=n; ++i)	printf(" --- %d ",co[i]); puts("");
//	for(int i=1; i<=n; ++i)	sort(G.e[i].begin(),G.e[i].end());
//	for(int now=1; now<=n; ++now) {
//		printf(" --- current node = %d:",now);
//		for(int i=0; i<int(G.e[now].size()); ++i)	printf(" %d",G.e[now][i].to);
//		puts("");
//	}
	for(int i=0; i<m; ++i) {
//		printf(" (%d %d)\n",arc[i].first,lower_bound(G.e[arc[i].first].begin(),G.e[arc[i].first].end(),(network<int>::edge){arc[i].second,0,0})->to);
//		if(lower_bound(G.e[arc[i].first].begin(),G.e[arc[i].first].end(),(network<int>::edge){arc[i].second,0,0})->w)	puts("0 0");
//		printf(" (%d %d)[%d %d]\n",arc[i].first,G.e[arc[i].first][rec[i]].to,co[arc[i].first],co[G.e[arc[i].first][rec[i]].to]);
		if(G.e[arc[i].first][rec[i]].w)	puts("0 0");
		else	printf("%d %d\n",co[arc[i].first]!=co[arc[i].second],vi[arc[i].first]==1 && vi[arc[i].second]==2);
	}
	return 0;
}
```

---

## 作者：7KByte (赞：2)

网络流经典题型。

最小割必经边/可行边 。

显然可行边包含必经边。

可行边满足的第一个条件：在最大流中满流。

没有满流，说明有一条更小的边流满了，显然割掉这更小的边会使得答案更优。

可行边满足的第二个条件：在剩余网络中没有$u\to v$的路径。

如果存在路径。则$u\to v$可以退流，这样就不满足第一个条件了。

可行边必须满足这两个条件。

必经边满足的第三个条件：在剩余网络中存在$S\to u$，$v\to T$的路径。

感性理解一下。既然源点，回点可以到这条边两端，那么瓶颈一定在当前边。

所以当前边的容量改变，一定会使得最大流改变，从而使最小割改变。

所以当前边为必经边。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 20005
using namespace std;
int h[N],tot=1,mat[N<<2];
struct edge{
	int to,nxt,cap;
}e[N<<3];
void add(int x,int y,int z){
	e[++tot].nxt=h[x];h[x]=tot;e[tot].to=y;e[tot].cap=z;
	e[++tot].nxt=h[y];h[y]=tot;e[tot].to=x;e[tot].cap=0;
}
int d[N],s,t;queue<int>q;
bool bfs(){
	memset(d,0,sizeof(d));
	d[s]=1;q.push(s);
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i=h[x];i;i=e[i].nxt)if(!d[e[i].to]&&e[i].cap)
			d[e[i].to]=d[x]+1,q.push(e[i].to);
	}
	return d[t]?1:0;
}
int dfs(int x,int flow){
	if(x==t)return flow;
	int res=flow;
	for(int i=h[x];i;i=e[i].nxt){
		int y=e[i].to;
		if(!e[i].cap||d[y]!=d[x]+1)continue;
		int now=dfs(y,min(e[i].cap,res));
		if(!now)d[y]=0;
		e[i].cap-=now;e[i^1].cap+=now;res-=now;
		if(!res)return flow;
	}
	return flow-res;
}
int n,m;
struct node{
	int x,y,z;
}a[N<<3];
int dfn[N],low[N],idx,sta[N],top,v[N],cnt,pos[N];
void dfs(int x){
	dfn[x]=low[x]=++idx;sta[++top]=x;v[x]=1;
	for(int i=h[x];i;i=e[i].nxt)if(e[i].cap){
		if(!dfn[e[i].to])dfs(e[i].to),low[x]=min(low[x],low[e[i].to]);
		else if(v[e[i].to])low[x]=min(low[x],dfn[e[i].to]);
	}
	if(low[x]==dfn[x]){
		++cnt;
		while(true){
			int y=sta[top--];
			v[y]=0;pos[y]=cnt;
			if(x==y)return ;
		}
	}
}
int hav[N][2];
void calc(){
	q.push(s);hav[s][0]=1;
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i=h[x];i;i=e[i].nxt)if(e[i].cap&&!hav[e[i].to][0])
			hav[e[i].to][0]=1,q.push(e[i].to);
	}
	q.push(t);hav[t][1]=1;
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i=h[x];i;i=e[i].nxt)if(e[i^1].cap&&!hav[e[i].to][1])
			hav[e[i].to][1]=1,q.push(e[i].to);
	}
}
int main(){
	scanf("%d%d%d%d",&n,&m,&s,&t);
	rep(i,1,m){
		scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].z);
		add(a[i].x,a[i].y,a[i].z);mat[i]=tot^1;
	}
	while(bfs())dfs(s,0x7fffffff);
	rep(i,1,n)if(!dfn[i])dfs(i);
	calc();
	rep(i,1,m){
		if(!e[mat[i]].cap){
			if(pos[a[i].x]!=pos[a[i].y])printf("1 ");
			else {printf("0 0\n");continue;}
			if(hav[a[i].x][0]&&hav[a[i].y][1])puts("1");
			else puts("0");
		}
		else puts("0 0");
	}
	return 0;
}
```

---

## 作者：Dispwnl (赞：2)

似乎有几个性质：
- **1.残余网络中有剩余流量的边一定不在最小割中**

如果有剩余流量的话肯定还有更优解

如图：
![](/img/study/zuixiaoge.png)

最小割为$4$，容量为$5$的边有剩余流量，它不在最小割里

- **2.残余网络中一条边（满足性质$1$）的首尾还能相互到达，那么这条边不满足条件$1$**

我个人理解是一边的两点还能相互到达，说明它们在割后的同一点集合中

连接它们的边就肯定不是最小割方案，反之连接它们的边就肯定在某个最小割方案中

- **3.在残余网络中一边（满足性质$1$）的首尾分别与$S$和$T$在一个强连通分量中，那么这条边满足条件$2$**

很好证明吧……

你如果不割这条边，最大流（即最小割）肯定得改变

性质$2,3$都是在性质$1$的基础上进行的，性质$2$不满足性质$3$肯定也不满足

至于是否联通，用$Tarjan$判断就行了~~我想用并查集失败了~~

### 代码
```
# include<iostream>
# include<cstdio>
# include<cstring>
# include<queue>
# include<stack>
# define ini inline int
# define inv inline void
# define inb inline bool
using namespace std;
const int MAX=4e3+1,inf=1e8;
struct p{
    int fr,x,y,dis;
}c[MAX<<5];
int n,m,s,t,num,TOT,ans,cnt;
int h[MAX],d[MAX],col[MAX],dfn[MAX],low[MAX];
bool use[MAX];
stack<int> st;
ini read()
{
    int x=0;
    char ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    while(isdigit(ch))
    {
        x=x*10+ch-48;
        ch=getchar(); 
    }
    return x;
}
inv add(int x,int y,int dis)
{
    c[num].fr=y,c[num].x=h[y],c[num].y=x,c[num].dis=0,h[y]=num++;
    c[num].fr=x,c[num].x=h[x],c[num].y=y,c[num].dis=dis,h[x]=num++;
}
inb bfs()
{
    queue<int> qu;
    memset(d,0,sizeof(d));
    d[s]=1;
    qu.push(s);
    while(!qu.empty())
    {
        int tt=qu.front();
        qu.pop();
        for(int i=h[tt];i;i=c[i].x)
          if(!d[c[i].y]&&c[i].dis)
          {
          	d[c[i].y]=d[tt]+1;
          	qu.push(c[i].y);
          }
    }
    return d[t];
}
int dfs(int x,int dix)
{
    if(x==t||!dix) return dix;
    int sum=0;
    for(int i=h[x];i;i=c[i].x)
      if(d[c[i].y]==d[x]+1&&c[i].dis)
      {
      	int dis=dfs(c[i].y,min(dix,c[i].dis));
      	if(dis)
      	{
      		sum+=dis;
      		dix-=dis;
      		c[i].dis-=dis;
      		c[i^1].dis+=dis;
      		if(!dix) break;
        }
      }
    if(!sum) d[x]=-1;
    return sum;
}
inv dinic()
{
    while(bfs()) dfs(s,inf);
}
void tarjan(int x)
{
    dfn[x]=low[x]=++cnt;
    use[x]=1;
    st.push(x);
    for(int i=h[x];i;i=c[i].x)
      if(c[i].dis)
      if(!dfn[c[i].y])
      tarjan(c[i].y),low[x]=min(low[x],low[c[i].y]);
      else if(use[c[i].y])
      low[x]=min(low[x],dfn[c[i].y]);
    if(low[x]==dfn[x])
    {
        ans++;
        int tt=-1;
        while(tt!=x)
        {
            tt=st.top();
            st.pop();
            col[tt]=ans;
            use[tt]=0;
        }
    }
}
int main()
{
    n=read(),m=read(),s=read(),t=read();
    for(int i=1;i<=m;i++)
      {
      	int x=read(),y=read(),dis=read();
      	add(x,y,dis);
      }
    dinic();
    for(int i=1;i<=n;i++)
      if(!dfn[i]) tarjan(i);
    for(int i=1;i<num;i+=2)
      {
        if(c[i].dis)
      	{
      		printf("0 0\n");
      		continue;
        }
      	if(col[c[i].fr]==col[c[i].y])
      	printf("0 ");
      	else printf("1 ");
      	if(col[c[i].fr]==col[s]&&col[c[i].y]==col[t])
      	printf("1\n");
      	else printf("0\n");
      }
    return 0;
}
```
### [博客](https://a-failure.github.io/2018/04/03/AHOI2009-%E6%9C%80%E5%B0%8F%E5%89%B2/)

---

## 作者：Foreverxxx (赞：1)

首先把原图建出来后利用最小割最大流定理跑一边最小割，这是比较明显的。

那么现在再来考虑这两个问题，先解决第一个，是否存在一条最小割的方案使得这条道路被切断？

通过手模以及思想实验后，我们可以知道，在残量网络中，这条边的流量必须为 $0$（不然这条边割了也没用，会有其它更好的边替代它，它不可能存在于最小割中），这是显而易见的，由此可以推出，这两个点也不能通过其它流量非 $0$ 的路径到达，否则这条边割了也没用。

对于这种情况，显然需要用到 ``Tarjan`` 算法，将原图变成一个 ``DAG``，保证 $scc_u$ 不等于 $scc_v$。

然后来研究第二个问题。

思路就比较明显了，我们必须保证 $scc_s=scc_u$，并且 $scc_v=scc_t$，当然这是在这条边流量为 $0$ 时才能考虑。

比较容易证明，如果此时 $u$ 与源点不连通，或者 $v$ 与汇点不连通，那么说明可以找到更好的边替代这条边，那么这条边就没有意义了。

总结一下：

对于第一个问题：

1. 残量网络中，这条边流量为 $0$。

2. 在参量网络缩成的 ``Tarjan`` 中，$scc_u$ 不等于 $scc_v$。

对于第二个问题：

1. 残量网络中，这条边流量为 $0$。

2. 在参量网络缩成的 ``Tarjan`` 中，$scc_s=scc_u$ 且 $scc_v=scc_t$。

Code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sss=0;
	char chh=getchar();
	while(chh<'0'||chh>'9') chh=getchar();
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss;
}
int n,m,S,T;
int head[4005],to[1000005],val[1000005],nxt[1000005],tot=1;
int depth[4005];
int dfn[4005],low[4005],cnt=0;
int scc[4005],scc_num=0;
stack<int> s;
bool insta[4005];
struct Gragh{
	int u,v;
}gragh[200005];
bool bfs(){
	memset(depth,0,sizeof depth); depth[S]=1;
	queue<int> q; q.push(S);
	while(!q.empty()){
		int x=q.front(); q.pop();
		for(register int i=head[x];i;i=nxt[i]){
			if(!val[i]) continue;
			int u=to[i];
			if(!depth[u]){
				depth[u]=depth[x]+1;
				q.push(u);
			}
		}
	}
	return depth[T];
}
int dfs(int now,int flow){
	if(now==T) return flow;
	int out_flow=0;
	for(register int i=head[now];i&&flow;i=nxt[i]){
		int u=to[i];
		if(val[i]&&depth[u]==depth[now]+1){
			int tmp=dfs(u,min(flow,val[i]));
			flow-=tmp,out_flow+=tmp;
			val[i]-=tmp,val[i^1]+=tmp;
		}
	}
	if(out_flow==0) depth[now]=0;
	return out_flow;
}
int Dinic(){
	int ans=0;
	while(bfs()) ans+=dfs(S,1e9);
	return ans;
}
void add(int u,int v,int w){
	to[++tot]=v;
	val[tot]=w;
	nxt[tot]=head[u];
	head[u]=tot;
	gragh[tot].u=u;
	gragh[tot].v=v;
}
void add_edge(int u,int v,int w){
	add(u,v,w),add(v,u,0);
}
void Tarjan(int now){
	dfn[now]=low[now]=++cnt;
	insta[now]=true; s.push(now);
	for(register int i=head[now];i;i=nxt[i]){
		if(!val[i]) continue;
		int u=to[i];
		if(!dfn[u]){
			Tarjan(u);
			low[now]=min(low[now],low[u]);
		}
		else if(insta[u]) low[now]=min(low[now],dfn[u]);
	}
	if(low[now]==dfn[now]){
		int tmp; scc_num++;
		while(s.top()!=now){
			tmp=s.top(); s.pop();
			scc[tmp]=scc_num;
			insta[tmp]=false;
		}
		s.pop();
		scc[now]=scc_num;
		insta[now]=false;
	}
}
int main(){
	n=read(),m=read(),S=read(),T=read();
	int u,v,w;
	for(register int i=1;i<=m;i++){
		u=read(),v=read(),w=read();
		add_edge(u,v,w);
	}
	int now_flow=Dinic();
	for(register int i=1;i<=n;i++){
		if(!dfn[i]) Tarjan(i);
	}
	for(register int i=2;i<=tot;i+=2){
		//还不能乱存边，注意这样枚举每条边 
		int u=gragh[i].u,v=gragh[i].v,w=val[i];
		if(!w&&scc[u]!=scc[v]){
			cout<<"1 ";
			if(scc[u]==scc[S]&&scc[v]==scc[T]){
				cout<<"1\n";
			}
			else cout<<"0\n";
		}
		else cout<<"0 0\n";
	}
	return 0;
}
```

---

## 作者：MiRaciss (赞：1)

## 前言
看到大家都是用链式前向星写的题解，作为洛谷最劣解，一定要发一篇 vector 的题解丫~~毕竟 vector 是信仰~~

## 题解

我们先考虑一个无法再增广的残留网络中有什么性质

因为残留网络是由正向边和其对应的反向边组成的，那么对于 $x,y$ 之间的某条边满流后，其对应的反向边一定有流量。

这时，如果 $x,y$ 间另有一条非满流边，则 $x,y$ 间构成一个强连通块。

然后我们考虑如果在一种方案中的一条边**非满流**，而这条边在其它方案中**满流**了，那么必会导致原方案中的某一条边由**满流**变为由**非满流**(如果它还是满流那么最大流就应该变大了)。

那么这两条边有什么性质呢？如果我们沿着增广路，可以发现这两条边应该在同一个强连通中

所以这道题我们就做完了：

首先我们需要判断它是不是满流，然后分类讨论：

对于存在于某种最小割方案中的边，我们只需要判断这条边的两端是否在同一个强连通里。

对于存在于任何最小割方案中的边，它的两端一定是一端和源点联通，一端和汇点联通的。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int INF=0x3f3f3f3f;

struct zz{
	int u,w,id,idid;
};
vector<zz> v[1000005];
map<int,bool> mp[60006];

struct Dinic{
	int dist[1000005],be[1000005];
	int s,t;
	void Add(int x,int y,int z,int id){
		int idx=v[x].size(),idy=v[y].size();
		v[x].push_back((zz){y,z,idy,id});
		v[y].push_back((zz){x,0,idx,id});
		mp[y][id]=1;
	}
	bool BFS(){
		bool f=0;memset(dist,-1,sizeof dist);
		queue<int> q;q.push(s);
		dist[s]=be[s]=0;
		while(!q.empty()){
			int x=q.front();q.pop();
			int siz=v[x].size();
			for(int i=0;i<siz;i++){
				int y=v[x][i].u,w=v[x][i].w;
				if(!w||dist[y]!=-1) continue;
				q.push(y),be[y]=0,dist[y]=dist[x]+1;
				if(y==t) f=1;
			}
		}
		return f;
	}
	int DFS(int x,int sum){
		if(x==t||!sum) return sum;
		int siz=v[x].size(),ans=0;
		for(int i=be[x];i<siz&&sum!=ans;i++){
			int y=v[x][i].u,w=v[x][i].w,id=v[x][i].id;be[x]=i;
			if(!w||dist[x]!=dist[y]-1) continue;
			int now=DFS(y,min(sum-ans,w));
			if(!now) dist[y]=0;
			v[x][i].w-=now,v[y][id].w+=now,ans+=now;
		}
		return ans;
	}
	int dinic(){
		int ans=0,now=0;
		while(BFS()) while(now=DFS(s,INF)) ans+=now;
		return ans;
	}
}T;

int n,m;
bool f[600005];
bool FLAG[600006];
bool vis[600006];                      
struct ss{
	int x,y;
}a[100000];

int col[100005];
int DFSN[100005],Low[100005];

struct TarJan{
	bool qwq[100005];
	int tot=0,qwqtot=0;
	stack<int> st;
	void Tarjan(int x){
		DFSN[x]=Low[x]=++tot;
		st.push(x);qwq[x]=1;
		for(int i=0;i<v[x].size();i++){
			int y=v[x][i].u;
			if(!v[x][i].w) continue;
			if(!DFSN[y]) Tarjan(y),Low[x]=min(Low[x],Low[y]);
			else if(qwq[y]) Low[x]=min(Low[x],DFSN[y]);
		}
		if(DFSN[x]==Low[x]){
			int now;++qwqtot;
			do{
				now=st.top();st.pop();
				qwq[now]=0,col[now]=qwqtot;
			}while(x!=now);
		}
	}
}xf;

int main(){
	cin>>n>>m>>T.s>>T.t;
	for(int i=1,x,y,z;i<=m;i++){
		scanf("%d%d%d",&x,&y,&z);
		T.Add(x,y,z,i);
	}
	int ans=T.dinic();
	for(int i=1;i<=n;i++) if(!DFSN[i]) xf.Tarjan(i);
	for(int x=1;x<=n;x++){
		for(int i=0;i<v[x].size();i++){
			int y=v[x][i].u,id=v[x][i].idid;
			if(v[x][i].w) continue;
			if(mp[x][id]) continue;
			if(col[x]!=col[y]) f[id]=1;
			if(col[x]==col[T.s]&&col[y]==col[T.t]) FLAG[id]=1;
		}
	} 
	for(int i=1;i<=m;i++) printf("%d %d\n",f[i],FLAG[i]);
	return 0;
}
```



---

## 作者：forest114514 (赞：0)

前言：这是一道很好的图论相关的结论板子题。

 [题目传送门](https://www.luogu.com.cn/problem/P4126)
# 1. 前置芝士：最小割的必须边与可行边
想必大家都已经知道二分图最大匹配的必须边与可行边的求法了吧：

- `必须边`：$u \to v$ 流量为 $1$，并且 $u$，$v$ 两点在残量网络中不属于一个强连通分量；

- `可行边`：$u \to v$ 流量为 $1$，或者 $u$，$v$ 两点在残量网络中属于一个强连通分量。

类似的，我们可以知道如何求最小割的必须边与可行边：

- `必须边`：$u \to v$ 满流且 $u$，$v$ 在残量网络中不属于一个强联通分量；

- `可行边`：$u \to v$ 满流且 $u$ 与 $S$，$v$ 与 $T$ 在残量网络中属于一个强连通分量。
    


至于如何证明，请各位 dalao 问度娘（~~我有一个很巧妙的证明，只是这里写不下）~~……

# 2.CODE
代码有一点细节：

1. tarjan 求强联通分量是要加 `if(!val[i]) continue;` 这句话，跳过满流的边
2. dinic 要写对当前弧优化（~~这应该不用说了吧）~~

**代码**：

```cpp
//蒟蒻一枚
#include<bits/stdc++.h>
#define re register
#define il inline
#define gc() getchar()
#define rep(i,a,b) for(re int i=a;i<=b;i++)
#define per(i,a,b) for(re int i=a;i>=b;i--)
#define tep(i,x) for(re int i=head[x];~i;i=ne[i])
#define inf 0x3f3f3f3f
using namespace std;
template<typename T> inline void read(T &x){
	T f=1;x=0;char ch=gc();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch&15),ch=gc();
	x*=f;
}
template<typename T> inline void write(T x){
	if(x<0) putchar('-'),x=-x;
   	if(x>9) write(x/10);
   	putchar(('0'+x%10));
}
template <typename T,typename ...Args> inline
void read(T &x,Args &...args){read(x);read(args...);}
template<typename T> inline void write(T x,char c){write(x),putchar(c);}
const int N=10005,M=4e5+10;
int n,m,S,T,head[N],idx=1,to[M],ne[M],val[M];
int cur[N],dep[N];
int Ti,dfn[N],low[N],ins[N],st[N<<1],top,col[N],cnt_scc;
int pos[M],ans1[M],ans2[M];
il void _add(int u,int v,int w){
	to[++idx]=v,ne[idx]=head[u],head[u]=idx,val[idx]=w;
	to[++idx]=u,ne[idx]=head[v],head[v]=idx,val[idx]=0;
}
il bool bfs(){
	memset(dep,-1,sizeof dep);
	queue<int> q;
	q.push(S);dep[S]=0,cur[S]=head[S];
	while(!q.empty()){
		int x=q.front();q.pop();
		tep(i,x){
			int y=to[i];
			if(val[i]&&dep[y]==-1){
				dep[y]=dep[x]+1;
				cur[y]=head[y];
				if(y==T) return 1;
				q.push(y);
			}
		}
	}
	return 0;
}
il int dfs(int x=S,int lim=inf){
	if(x==T) return lim;
	int res=lim;
	for(int i=cur[x];~i&&res;i=ne[i]){
		int y=to[i];
		cur[x]=i;
		if(val[i]&&dep[y]==dep[x]+1){
			int ad=dfs(y,min(val[i],res));
			if(!ad) dep[y]=-1;
			val[i]-=ad,val[i^1]+=ad,res-=ad;
		}
	}
	return lim-res;
}
il void dinic(){
	int res=0,ad;
	while(bfs()) while(ad=dfs()) res+=ad;
	return ;
}
il void tarjan(int x){
	dfn[x]=low[x]=++Ti;
	st[++top]=x,ins[x]=1;
	for(int i=head[x];~i;i=ne[i]){
		int y=to[i];
		if(!val[i]) continue;
		if(!dfn[y]){
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(ins[y]) low[x]=min(low[x],dfn[y]);
	}
	if(dfn[x]==low[x]){
		cnt_scc++;
		int u;
		do{
			u=st[top--];
			ins[u]=0;
			col[u]=cnt_scc;
		}while(u!=x);
	}
}
signed main(){
	//ios::sync_with_stdio(false);
	//cin.tie(0);cout.tie(0);
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	memset(head,-1,sizeof head);
	read(n,m,S,T);
	int u,v,w;
	rep(i,1,m){
		read(u,v,w);
		_add(u,v,w);
		pos[i]=idx-1;
	}
	dinic();
	rep(i,1,n) if(!dfn[i]) tarjan(i);
	rep(i,1,m){
		int u=to[pos[i]^1],v=to[pos[i]];
		if(!val[pos[i]]){
			write(col[u]!=col[v]?1:0);putchar(' ');
			write(((col[u]==col[S])&&(col[v]==col[T]))?1:0); putchar('\n');
		}
		else putchar('0'),putchar(' '),putchar('0'),putchar('\n');
	}
	return 0;
}

```
    

---

## 作者：Z1qqurat (赞：0)

无论是最小割的可行边还是必需边，我现在瞎跑一遍最大流，那它首先都得是满流边。

明确一点，**最小割中的边都必须是满流边。**

* 最小割的可行边：如果在残量网络中，$(u, v)$ 边剩余容量为 $0$ 且 $u$ 和 $v$ 不在同一个强连通分量中，$(u, v)$ 为最小割的可行边。

  证明：采用反证法，如果残量网络中， $u$ 和 $v$ 在同一个强连通分量中，则 $u$ 到 $v$ 仍有路径。然而 $(u, v)$ 是一条满流边，所以 $(v, u)$ 肯定存在于残量网络中。大概是这样一个图：

![](https://pic.imgdb.cn/item/64a2c58b1ddac507cc448fc6.png)

  现在存在 $u$ 到 $v$ 的路径，和 $(v, u)$ 构成了一个环。那么如果我们想要 $(u, v)$ 为一条最小割边，那么 $(u, v)$ 必和环上其他的一条边一起组成，但是这些环上的边都不是**满流边**，说明一定可以找到一组只有满流边的割使边权和更小，则 $(u, v)$ 无法在最小割上，得证。

* 最小割的必需边：也就是说，如果将边 $(u, v)$ 的容量增大，最小割也会增大。所以 $(u, v)$ 为满流边，且残量网络上 $s$ 和 $u$，$v$ 和 $t$ 一定连通。

  证明：如果残量网络上 $s$ 和 $u$，$v$ 和 $t$ 连通，则我们将 $c(u, v)$ 增大，一定能在残量网络上新找到一条从 $s$ 到 $t$ 的增广路，使得最大流增大，最小割随之增大；反之则无法找到新的增广路，最小割不会增大。得证。

所以说，我们只需要跑一遍最大流，然后在残量网络上做 $\mathrm{tarjan}$ 缩点，求出每个点所在的强连通分量。在边 $(u, v)$ 满流的前提下，如果 $scc_u \ne scc_v$，则边 $(u, v)$ 为最小割可行边；如果 $scc_s = scc_u, scc_v = scc_t$，那么边 $(u, v)$ 为最小割必需边。

给出纯野生无公害绿色环保代码，请放心食用。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <queue>
#include <stack>
#define ll long long
using namespace std;
const int N = 4005, M = 1.3e5;
int n, m, s, t, cnt = 1, to[M], nxt[M], head[N], cur[N], dis[N];
bool ins[N];
ll limit[M];
int tot, dfn[N], low[N], scc[N], num;
queue <int> q;
stack <int> stk;
struct Edge{
    int u, v, id;
}e[M];

void AddEdge(int u, int v, ll w) {
    to[++cnt] = v, limit[cnt] = w, nxt[cnt] = head[u], head[u] = cnt;
    to[++cnt] = u, limit[cnt] = 0, nxt[cnt] = head[v], head[v] = cnt;
    return ;
}

ll Augmenting(int u, ll rest) {
    if(u == t) return rest;
    ll ret = 0;
    for (int i = cur[u]; i && rest; i = nxt[i]) {
        cur[u] = i;
        int v = to[i]; ll c = min(limit[i], rest);
        if(dis[v] == dis[u] + 1 && c) {
            int f = Augmenting(v, c);
            rest -= f, ret += f;
            limit[i] -= f, limit[i ^ 1] += f;
        }
    }
    if(!ret) dis[u] = -1;
    return ret;
}

ll MaxFlow(int s, int t) {
    ll maxflow = 0;
    while(1) {
        bool bl = 0;
        memset(dis, -1, sizeof(dis));
        memcpy(cur, head, sizeof(head));
        while(!q.empty()) q.pop();
        q.push(s), dis[s] = 0;
        while(!q.empty()) {
            int u = q.front(); q.pop();
            if(bl) break;
            for (int i = head[u]; i; i = nxt[i]) {
                int v = to[i];
                if(limit[i] && dis[v] == -1) {
                    dis[v] = dis[u] + 1;
                    if(v == t) {
                        bl = 1; break;
                    }
                    q.push(v);
                }
            }
        }
        if(dis[t] == -1) return maxflow;
        maxflow += Augmenting(s, 1e18);
    }
}

void tarjan(int u) {
    dfn[u] = low[u] = ++tot;
    stk.push(u), ins[u] = 1;
    for (int i = head[u]; i; i = nxt[i]) {
        if(!limit[i]) continue;
        int v = to[i];
        if(!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if(ins[v]) low[u] = min(low[u], dfn[v]);
    }
    if(dfn[u] == low[u]) {
        num++;
        while(!stk.empty()) {
            int cur = stk.top(); stk.pop();
            ins[cur] = 0;
            scc[cur] = num;
            if(cur == u) break;
        }
    }
    return ;
}

int main() {
    scanf("%d %d %d %d", &n, &m, &s, &t);
    for (int i = 1; i <= m; ++i) {
        int u, v, w; scanf("%d %d %d", &u, &v, &w);
        AddEdge(u, v, w);
        e[i].u = u, e[i].v = v, e[i].id = cnt - 1;
    }
    MaxFlow(s, t);
    for (int i = 1; i <= n; ++i) {
        if(!dfn[i]) tarjan(i);
    }
    for (int i = 1; i <= m; ++i) {
        int u = e[i].u, v = e[i].v, id = e[i].id;
        if(!limit[id] && scc[u] != scc[v]) cout << "1 ";
        else cout << "0 ";
        if(!limit[id] && scc[u] == scc[s] && scc[v] == scc[t]) puts("1");
        else puts("0");
    }
    return 0;
}
```



---


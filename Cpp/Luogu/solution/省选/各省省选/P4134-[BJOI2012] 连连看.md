# [BJOI2012] 连连看

## 题目描述

凡是考智商的题里面总会有这么一种消除游戏。不过现在面对的这关连连看可不是 QQ 游戏里那种考眼力的游戏。我们的规则是，给出一个闭区间 $[a,b]$ 中的全部整数，如果其中某两个数 $x$，$y$（$x>y$）的平方差 $x^2-y^2$ 是一个完全平方数 $z^2$，并且 $y$ 与 $z$ 互质，那么就可以将 $x$ 和 $y$ 连起来并且将它们一起消除，同时得到 $x+y$ 点分数。那么过关的要求就是，消除的数对尽可能多的前提下，得到足够的分数。快动手动笔算一算吧。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $1\le a,b\le100$。
- 对于 $100\%$ 的数据，保证 $1\le a,b\le1000$。

## 样例 #1

### 输入

```
1 15```

### 输出

```
2 34```

# 题解

## 作者：Stinger (赞：7)

提供一个兼具跑得慢和码量大两大~~优点~~的神笔做法/kk

很容易想到这样一个费用流建图：若一对 $(x,y)$ 是合法的，则源点向 $x$ 以及 $y$ 向汇点都连容量为 $1$ 费用为 $0$ 的边，$x$ 向 $y$ 连容量 $1$ 费用 $x+y$ 的边，答案即为最大费用最大流。

问题是我们怎么知道哪些点向源点连哪些向汇点连？（这里其它题解直接拆点解决了，不需要搞清楚哪些连源点哪些连汇点）。

以本人的数学水平无法找出一个简单的规律进行染色。但我们染色的本质，是将所有点划分为两个不交集合 $S,T$，使得所有满足 $x\in S,y\in S,x\ne y$ 的 $(x,y)$ 都不合法。同样，满足 $x\in T,y\in T,x\ne y$ 的 $(x,y)$ 也不合法。假设 $S$ 为黑色， $T$ 为白色，这样就避免了同色点之间的连边。

那么，如果一对 $(x,y)$ 合法，意味着 $x,y$ 不能划分到相同的集合里面去。可以用 2-SAT 找出一种可行方案。找到了合法的集合划分方案（染色方案）后，按照之前说的费用流建图就可以了。

2-SAT 会不会无解？这个菜鸡无法严格证明，但凭直觉满足条件的 $(x,y)$ 应该是很少的，2-SAT 的边也就很少，即 2-SAT 有解的概率很大。并且写完程序跑一遍极限数据发现 2-SAT 有解，所以这不是乱搞，是理论上没法证明但实际上无法 hack 掉的奇怪做法（

```cpp
#include <cstdio>
#include <queue>
#include <cstring>
#include <cmath>

int n;
struct TwoSAT {
	struct Edge {
		int to, nxt;
	} e[4000005];
	int head[2000005], s[2000005], tot, top;
	bool mark[2000005];
	void clear() {
		memset(head, 0, sizeof head);
		memset(mark, 0, sizeof mark);
		tot = 0;
	}
	inline void AddEdge(const int u, const int v) {
		e[++ tot].to = v, e[tot].nxt = head[u], head[u] = tot;
	}
	inline void addclause(int x, int valx, int y, int valy) {
		x = (x - 1) * 2 + valx;
		y = (y - 1) * 2 + valy;
		AddEdge(x ^ 1, y);
		AddEdge(y ^ 1, x);
	}
	bool dfs(const int u) {
		if (mark[u ^ 1]) return false;
		if (mark[u]) return true;
		mark[u] = true;
		s[top ++] = u;
		for (int i = head[u]; i; i = e[i].nxt)
			if (!dfs(e[i].to)) return false;
		return true;
	}
	bool solve() {
		for (int i = 0; i < n << 1; i += 2)
			if (!mark[i] && !mark[i ^ 1]) {
				top = 0;
				if (!dfs(i)) {
					while (top > 0) mark[s[-- top]] = false;
					if (!dfs(i ^ 1)) return false;
				}
			}
		return true;
	}
} solver;

const int INF = 1e9;
int gcd(int n, int m) {return m ? gcd(m, n % m) : n;}
inline int min(const int x, const int y) {return x < y ? x : y;}
struct Edge {
	int to, cap, cost, nxt;
} e[200005];
int head[1005], cur[1005], dis[1005], Maxflow, Maxcost;
bool mp[1005][1005];
int tot = 1, s, t;
bool vis[1005], mark[1005];
std::queue<int> Q;
inline void AddEdge(int u, int v, int cap, int cost) {
	e[++ tot].to = v, e[tot].nxt = head[u], head[u] = tot;
	e[tot].cap = cap, e[tot].cost = cost;
	e[++ tot].to = u, e[tot].nxt = head[v], head[v] = tot;
	e[tot].cap = 0, e[tot].cost = -cost;
}
bool SPFA() {
	memcpy(cur, head, sizeof cur);
	memset(vis, 0, sizeof vis);
	memset(dis, ~0x3f, sizeof dis);
	memset(mark, 0, sizeof mark);
	Q.push(s);
	dis[s] = 0;
	while (Q.size()) {
		int u(Q.front());
		Q.pop();
		mark[u] = false;
		for (int i = head[u]; i; i = e[i].nxt) {
			int v = e[i].to;
			if (e[i].cap && dis[u] + e[i].cost > dis[v]) {
				dis[v] = dis[u] + e[i].cost;
				if (!mark[v]) Q.push(v), mark[v] = true;
			}
		}
	}
	return dis[t] > -INF;
}

int dfs(int u, int flow) {
	if (u == t) return flow;
	vis[u] = true;
	int used = 0, tmp;
	for (int i = cur[u]; i && used <= flow; i = e[i].nxt) {
		cur[u] = i;
		if (e[i].cap && dis[u] + e[i].cost == dis[e[i].to]) {
			int v = e[i].to;
			if (!vis[v] && (tmp = dfs(v, min(flow - used, e[i].cap))))
				used += tmp, e[i].cap -= tmp, e[i ^ 1].cap += tmp;
		}
	}
	return used;
}

void Dinic() {
	int flow;
	while (SPFA()) Maxflow += (flow = dfs(s, INF)), Maxcost += flow * dis[t];
}

bool check(int x, int y) {
	int z = sqrt(x * x - y * y);
	return z * z == x * x - y * y && gcd(y, z) == 1;
}

int main() {
	int l, r;
	scanf("%d%d", &l, &r);
	n = r;
	s = 0, t = r + 1;
	for (int i = l; i <= r; ++ i) if (i & 1)
		for (int j = l; j < i; ++ j)
			if (check(i, j)) {
				mp[i][j] = mp[j][i] = true;
				solver.addclause(i, 1, j, 1);
				solver.addclause(i, 0, j, 0);
			}
	if (!solver.solve()) return 114514;
	for (int i = l; i <= r; ++ i)
		if (solver.mark[i * 2 - 1]) AddEdge(s, i, 1, 0);
		else AddEdge(i, t, 1, 0);
	for (int i = l; i <= r; ++ i) if (solver.mark[i * 2 - 1])
		for (int j = l; j <= r; ++ j)
			if (!solver.mark[j * 2 - 1] && mp[i][j]) AddEdge(i, j, 1, i + j);
	Dinic();
	printf("%d %d", Maxflow, Maxcost);
}
```

---

## 作者：interestingLSY (赞：3)

emmmmm.......这数据范围.....应该是**费用流**

~~然而楼下dalao所说的二分图我不会证啊qwq~~

没办法,只能硬想了.

### 咳咳,言归正传

# 算法
这题的特点有两个:

- 每个数最多被消一次..........(记为条件1)

- 要消就是一对点一起消..........(记为条件2)

所以,不难建出图:

- 把一个数拆成两个点,分别记为$In_x$和$Out_x$,表示"输入"和"输出".

- 从$S$向每个数的输出端($Out_x$)连一条(1,0)的边$\qquad\color{blue}{\text{注:(1,0)代表流量为1,单位流量费用为0}}$

- 从每个数的输入端($In_x$)向$T$连一条(1,0)的边

- 对于符合条件的两个数$x,y$,从$Out_x$向$In_y$连$(1,x+y)$,从$Out_y$向$In_x$连$(1,x+y)$
前三条好理解,最后一条是在干啥?

道理很简单:为了保证"条件2".(自己想想如果只连了$In_x$和$Out_y$会怎样).输出答案时,直接将费用与流量分别除以2即可

# 一个要注意的地方 & 关键点

有人说自己求最大费用最大流$WA$了(只得30分)

这是为什么呢?

答案就是你们初始化时把$Dis$全设为$-1$而不是$-\inf$

不要忘了反向弧的费用为负

这样就会导致某些点到$S$的距离小于你设的初始权值

# 代码(只有建图部分~~我相信你们都有模板~~)

```cpp
bool Ok( int x , int y ){
	if( x < y ) swap(x,y);
	int z = x*x - y*y;
	int d = sqrt(z);
	if( d*d != z ) return 0;
	if( __gcd(d,y) != 1 ) return 0;
	return 1;
}

void Build(){
	Forx(i,a,b)
		Forx(j,i+1,b)
			if(Ok(i,j)){
				int point = i+j;
				Link(i,j+MAXN,1,point);
				Link(j,i+MAXN,1,point);
			}
	Forx(i,a,b){
		Link(S,i,1,0);
		Link(i+MAXN,T,1,0);
	}
}
```

---

## 作者：奇米 (赞：3)

## 题解- P4134 连连看

* **题目大意**

就是在$[a,b]$区间中找出尽量多的数对$(x,y)$,若两种情况下数对数相同使得若干对数对和尽量大。

* $Sol$

这道题目难点在于如何转换到熟悉的模型——**最小费用最大流**。但是题目要我们求数对和尽量大，所以我们只要把边权取反**相当于求最小费用**，最后答案再去一遍反即可。因为这样我们就可以用简单的方法来解决这道题目了。

于是就很简单：

 对于一个成立的数对$(x,y)$从$x$到$y+b$连一条费用为$-x-y$的边流量为$1$的边即可。

从超级源点向$[a,b]$连边权为$0$流量为$1$的边，从$[a,b]$连边权为$0$流量为$1$的边向超级汇点。

* $Code$

```cpp

#include <bits/stdc++.h>
using namespace std;

const int N=2005;
const int M=2e5+5;

int n,m,cnt=1,ans1,ans2,s,t;
int head[N],lb[M],ld[N];
int dis[N],vis[N],fl[M];
struct nood {
	int fr,nex,to,w,fl;
};
nood e[M<<2];

inline void jia(int u,int v,int w,int fl) {
	e[++cnt].nex=head[u];
	e[cnt].fr=u; 
	head[u]=cnt;
	e[cnt].to=v;
	e[cnt].w=w;
	e[cnt].fl=fl;
}

inline int gcd(int a,int b) {
	if(!b) return a;
	return gcd(b,a%b);
}

inline bool spfa() {
	queue<int> q;
	memset(dis,63,sizeof(dis));
	memset(vis,0,sizeof(vis));
	memset(fl,63,sizeof(fl));
	q.push(s),dis[s]=0,vis[s]=1,ld[t]=-1;
	while(!q.empty()) {
		int u=q.front();
		q.pop();
		vis[u]=0;
		for ( int i=head[u];i;i=e[i].nex ) {
			int v=e[i].to;
			if(e[i].fl&&dis[v]>dis[u]+e[i].w) {
				dis[v]=dis[u]+e[i].w;
				fl[v]=min(fl[u],e[i].fl);
				ld[v]=u;
				lb[v]=i;
				if(!vis[v]) {
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	return (ld[t]!=-1);
}

inline void dinic() {
	while(spfa()) {
		int u=t;
		ans1+=fl[t];
		ans2+=fl[t]*dis[t];
		while(s!=u) {
			e[lb[u]].fl-=fl[t];
			e[lb[u]^1].fl+=fl[t];
			u=ld[u];
		}
	}
	ans1/=2;
	printf("%d %d\n",ans1,-1*ans2/2);
	exit(0);
}

int main() {
	scanf("%d%d",&n,&m);
	s=n-1,t=n+m+1;
	for ( int i=n;i<=m;i++ ) {
		jia(s,i,0,1),jia(i,s,0,0);
		jia(i+m,t,0,1),jia(t,i+m,0,0);
	}
	for ( int i=n;i<=m;i++ ) 
		for ( int j=n;j<i;j++ ) {
			int o=i*i-j*j;
			if((int)sqrt(o)*(int)sqrt(o)==o) {
				int rua=sqrt(o);
				if(gcd(rua,j)==1) { 
					jia(i,j+m,-i-j,1),jia(j+m,i,i+j,0);
					jia(j,i+m,-i-j,1),jia(i+m,j,i+j,0);
				}
			}
		}
	dinic();
	return 0;
}
	

```



---

## 作者：听取MLE声一片 (赞：2)

写这篇题解的缘由：tg模拟赛竟然出了网络流题，当时看出来是费用流但是建图建出来一个环， $100\rightarrow10$。

先看这数据范围，是 `1000` 以内，然后跑一遍一共有多少组合法的，发现只有不到 `400` 组，费用流是没有任何问题的。

然后是怎么样想到是费用流的。题面中说，每个数只能用一次，自然想到了流量上限为 `1` ,然后再加上最大分数，这道题应该是一道类似**二分图最大权完美匹配**，数据范围挺小的，直接上一个最大费用最大流就可以（边权存负就行）。

但是，问题就来了，建图的时候会出现一些比较尴尬的情况，比如这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/a0zoei9x.png)

这就用了一个**拆点**的技巧，把每个点拆成两个点。

为了省去判断~~还有懒~~，我找到一个做法，就是把所有能找到的边都连一下，就相当于把每两个点都**连了两遍**，然后再把它们分别与超级源点和超级汇点相连（注意一定要拆完点！）。

最后，因为我们相当于把每条边每个点都遍历了正好两遍，所以我们只需要把答案除以 `2` 即可，就省去了判断！

下面是核心代码（剩下的自己套板子）

```
int gcd(int x,int y){
	if(y==0)
		return x;
	return gcd(y,x%y);
}
bool check(int x,int y){
	if(x<y)
		swap(x,y);
	int z=sqrt(x*x-y*y);
	return z*z==x*x-y*y&&gcd(y,z)==1;
}
signed main()
{
	n=read(),m=read();
	s=0,t=m+1;
	for(int i=n;i<=m;i++)
		for(int j=i+1;j<=m;j++)
			if(check(i,j)){
				int w=-i-j;
				add(i,j+t,1,w);
				add(j,i+t,1,w);
			}
	for(int i=n;i<=m;i++){
		add(s,i,1,0);
		add(i+t,t,1,0);
	}
    EK();
    printf("%lld %lld",maxn/2,-cost/2);
	return 0;
}
```

这里用的 `EK` ，因为这里不卡时间。

---

## 作者：Khassar (赞：2)

这个题其实是一个费用流~~水题~~，水不水呢主要要看你能不能发现它其实是一个二分图。它为什么是一个二分图呢，因为它不是二分图我不会做，额，这好像不是理由，你可以手玩一下，发现它是一个二分图（主要还是因为不是二分图没法做），既然它是一个二分图了，那这个问题就很简单了。

我们暴力枚举$x,y$暴力判断符不符合能够相消的关系，二分图染个色，分成左右两部，就正常建图（源点到左部，流量$1$，费用$0$，右部到汇点，流量$1$，费用$0$，$x->y$，费用$x+y$,流量$1$，$x$∈左部，$y$∈右部），跑一遍最大费用最大流就可以了，最大流就是第一问，最大费用就是第二问。（我太懒，用的是费用取反再跑最小费用最大流）

本来我这样就可以开开心心地$A$掉这题然后去做别的题，但是我脑子一抽想起了另一个解决二分图带权匹配的问题（因为这实际上是一个二分图带权匹配的模型嘛）— $KM$算法。然后我就去码$KM$去了，然后就一直$30$分，希望有$dalao$能告诉我我的$KM$哪错了,谢谢。

下面的代码$KM$和费用流都有，$work$函数就是费用流，$KM$函数是$KM$

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<vector>
#include<ctime>

#define ll long long
#define R register
#define IL inline
#define Rf(a,b,c) for(R int (a)=(b);(a)<=(c);++(a))
#define Tf(a,b,c) for(R int (a)=(b);(a)>=(c);--(a))
#define MP make_pair
#define PA pair<int,int>
#define MES(a,b) memset((a),(b),sizeof((a)))
#define MEC(a,b) memcpy((a),(b),sizeof((b)))

using namespace std;

const int N=300005,M=1005,inf=(1<<30);

struct node{
	int next,to,cup,len,from;
}e[N*4];

int ansflow,anscost;
int vis[N],dis[N],pre[N],head[N],a,b,w[M][M],n,m,s,t,tot=1,ans,g[M][M],id[M],lx[M],ly[M],link[M],sl[M],sum,flag;
bool S[M],T[M];

queue <int> q;

IL int read(){
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x*=10;x+=(ch-'0');ch=getchar();}
	return x*f;
}
IL void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

IL bool pd(int x,int y) {
	R int z=x*x-y*y,d=sqrt(z);
	if(d*d==z&&__gcd(y,z)==1) return true;
	return false; 
}

IL void add(int u,int v,int c,int l){
	e[++tot].next=head[u];e[tot].from=u;
	head[u]=tot; e[tot].to=v;
	e[tot].cup=c; e[tot].len=l;
}
IL void ins(int u,int v,int c,int l) {add(u,v,c,l);add(v,u,0,-l);}

IL bool bfs(){
	memset(vis,0,sizeof(vis));
	Rf(i,s,t) dis[i]=inf;
	memset(pre,-1,sizeof(pre));
	q.push(s);vis[s]=1;dis[s]=0;
    while(!q.empty()){
        R int now=q.front();q.pop();vis[now]=0;
        for(int i=head[now];i;i=e[i].next){
            int p=e[i].to;
            if(e[i].cup&&dis[p]>dis[now]+e[i].len){
                dis[p]=dis[now]+e[i].len;pre[p]=i;
                if(!vis[p]) {
                    vis[p]=1;q.push(p);
                }
            }
        }
    }
    return dis[t]!=inf;
}
IL void find(){
	R int now=t,down=inf;
	while(now!=s) {
		down=min(down,e[pre[now]].cup);
		now=e[pre[now]].from;
	}
	now=t;
	while(now!=s){
		e[pre[now]].cup-=down;
		e[pre[now]^1].cup+=down;
		now=e[pre[now]].from;
	}
	ansflow+=down;anscost+=dis[t]*down;
}

IL void work() {
	Rf(i,a,b) {
		if(vis[i]==1) {
			ins(s,i,1,0);
			Rf(j,a,b) if(w[i][j]) ins(i,j,1,-i-j);
		}
		else ins(i,t,1,0);
	} 
	anscost=ansflow=0;
	while(bfs()) {
		find();ans++;
	}
	write(ans);putchar(' ');
	write(-anscost);putchar('\n');
}

void dfs1(int x) {
	Rf(i,a,b) if(!vis[i]&&g[x][i]) {
		if(vis[x]==1) vis[i]=2;
		else vis[i]=1;
		dfs1(i);
	}
}

bool dfs(int x) {
	S[x]=true;
	Rf(i,1,m) 
		if(lx[x]+ly[i]==w[x][i]) {
			if(!T[i]) {
				T[i]=true;
				if(!link[i]||dfs(link[i])) {
					link[i]=x;
					return true;
				}
			}
		}
		else sl[i]=min(sl[i],lx[x]+ly[i]-w[x][i]);
	return false;
}

IL void update() {
	R int a=1e9;
	Rf(j,1,m) if(!T[j]) 
		a=min(a,sl[j]); 
	Rf(i,1,n) if(S[i]) lx[i]-=a;
	Rf(i,1,m) {
		if(T[i]) ly[i]+=a;
		sl[i]-=a;
	}
}

IL void KM() {
	Rf(i,a,b) 
		if(vis[i]==1) id[i]=++n;
		else id[i]=++m;
	if(n>m) swap(n,m),flag=1;
	Rf(i,a,b) {
		Rf(j,a,b) if(g[i][j]) {
			if(!flag) w[id[i]][id[j]]=i+j;
			else w[id[j]][id[i]]=i+j;
		}
	}
	Rf(i,1,m) link[i]=lx[i]=ly[i]=0; 	
	Rf(i,1,n) Rf(j,1,m) lx[i]=max(lx[i],w[i][j]);
	Rf(i,1,n) while(true) {
		Rf(j,1,m) {
			S[j]=T[j]=false;sl[j]=1e9;
		}
		if(dfs(i)) break;
		else update();
	}
	Rf(i,1,m) if(link[i]&&w[link[i]][i]) {
		ans++;sum+=w[link[i]][i];
	}
	write(ans);putchar(' ');write(sum);
}	 


signed main()
{
	a=read();b=read();t=b+1;
	Rf(i,a,b) Rf(j,a,i-1) if(pd(i,j)) g[i][j]=g[j][i]=1;
	Rf(i,a,b) if(!vis[i]) {
		vis[i]=1;
		dfs1(i);
	}
//	work();
	KM();
	
	return 0;
}
```

---

## 作者：撤云 (赞：2)

### [$$blog$$](https://www.cnblogs.com/hbxblog/p/10255112.html)
---
### 题目链接
[戳我](https://www.luogu.org/problemnew/show/P4134)
### $Solution$

我们首先进行拆点操作，将每个点都拆成$x$和$y$，将满足条件的两个点连起来就好了(记得要将$x$连$y'$的同时要将$y$联向$x'$)

### code 
``` cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9')
        f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9')
        x=x*10+c-'0',c=getchar();
    return x*f;
}
struct node{
    int to,next,v,w;
}a[1000001];
int dis[10001],f[10001],pre[10001],fa[10001],s,t,n,head[10001],cnt,x,y,z,c;
void add(int x,int y,int c,int v){
    a[++cnt].to=y;
    a[cnt].next=head[x];
    a[cnt].v=c;
    a[cnt].w=v;
    head[x]=cnt;
}
queue < int > q;
int spfa(){
    q.push(s);
    memset(dis,127,sizeof(dis));
    memset(f,0,sizeof(f));
    f[s]=1,dis[s]=0;
    int inf=dis[s+1];
    while(!q.empty()){
        int now=q.front();
        q.pop();
        f[now]=0;
        for(int i=head[now];i;i=a[i].next){
            int v=a[i].to;
            if(dis[v]>dis[now]+a[i].w&&a[i].v){
                dis[v]=dis[now]+a[i].w,pre[v]=i,fa[v]=now;
                if(!f[v])
                    f[v]=1,q.push(v);
            }
        }
    }
    if(dis[t]!=inf)
        return 1;
    return 0;
}
int ans1,ans;
void anser(){
    while(spfa()){
        int minx=2147483647;
        for(int i=t;i!=s;i=fa[i])
            minx=min(minx,a[pre[i]].v);
        ans+=minx,ans1+=dis[t]*minx;
        for(int i=t;i!=s;i=fa[i])
            a[pre[i]].v-=minx,(pre[i]%2)?a[pre[i]+1].v+=minx:a[pre[i]-1].v+=minx;
    }
}
int main(){
    int A=read(),B=read();
    n=B,s=0,t=B+1;
    for(int i=A;i<=B;i++)
        add(s,i,1,0),add(i,s,0,0);
    for(int i=A+B;i<=B+B;i++)
        add(i,t,1,0),add(t,i,0,0);
    for(int i=A;i<=B;i++)
        for(int j=A;j<i;j++){
            int l=i*i-j*j,p=sqrt(l);
            if(p*p==l&&__gcd(j,p)==1){
                add(i,j+B,1,-i-j),add(j+B,i,0,i+j);
				add(j,i+B,1,-i-j),add(i+B,j,0,i+j);
			}
        }
    anser();
    printf("%d %d",ans/2,-1*ans1/2);
}
```

---

## 作者：BMTXLRC (赞：1)

注 $1$：此题的模型并不为二分图，然而数据保证了他是二分图（

注 $2$：贪心正确性估计有误，最大匹配其实应该是过不去的（

### 分析：

我们先假设他是二分图好了，匹配涉及到权值最大，故我们考虑最大权匹配。

保险起见，建议大家跑 $\texttt{bfs KM}$。

### 你需要准备的前置知识：

1. $\texttt{GCD}$

很显然了，公约数为 $1$ 是连上边的条件之一。

用 `__gcd` 怕 $\texttt{TLE}$，自己打吧。

```cpp
int gcd(int x,int y){
    if(y==0) return x;
    else return gcd(y,x%y);
}
```

2. 二分图染色

染色的时候注意一定染有边的点，没边的不要去染他了。

```cpp
void color(int x,int k){
    col[x]=k;
    for(register int i=l;i<=r;i++){
        if(a[x][i]!=0&&col[i]==0) color(i,-k);
    }
}
```

### $\texttt{Q\&A}$：

（我个人有疑惑的地方，已经被大佬们解决了）

1. 二分图不一定具有完美匹配啊，为什么 $\texttt{KM}$ 可以通过？

用邻接矩阵的话，相当于有很多边权为 $0$ 的边，这样是肯定有完美匹配的。

然而用邻接表的话，估计会死循环，不过没关系，建虚点应该行（没试过）。

2. $O(n^3)$ 的 $\texttt{bfs KM}$ 为什么能过？

我们遍历的时候，其实把没有边的点都忽略了，相当于是只遍历了有边的点，这样实际点数 $n$ 是远远达不到 $10^3$ 的。

### 总代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e3+5;
const int inf=1e9;
int ans=0,slack[N],p[N],f[N],lx[N],ly[N],dfn[N],id=1,head[N],l,r,cnt,a[N][N],col[N];
bool vis[N];
void bfs(int k){
	int x=0,delta=0,s=0,y=l-1;
	memset(slack,0x3f,sizeof(slack));
	slack[l-1]=0;
	memset(p,0,sizeof(p));
	f[y]=k;
	while(1){
		x=f[y],delta=inf,dfn[y]=id;
		for(register int i=l;i<=r;i++){
			if(dfn[i]==id) continue;
			if(slack[i]>lx[x]+ly[i]-a[x][i]){
				slack[i]=lx[x]+ly[i]-a[x][i];
				p[i]=y;
			}
			if(slack[i]<delta) delta=slack[i],s=i;
		}
		for(register int i=l-1;i<=r;i++){
			if(dfn[i]==id) lx[f[i]]-=delta,ly[i]+=delta;
			else slack[i]-=delta;
		}
		y=s;
		if(f[y]==-1) break;
	}
	while(y) f[y]=f[p[y]],y=p[y];
}
int KM(){
	memset(f,-1,sizeof(f));
	for(register int i=l;i<=r;i++,id++) if(col[i]==1) bfs(i);
	for(register int i=l;i<=r;i++) if(f[i]!=-1&&a[f[i]][i]!=0) ans+=a[f[i]][i],cnt++;
	return ans;
}
int gcd(int x,int y){
    if(y==0) return x;
    else return gcd(y,x%y);
}
void color(int x,int k){
    col[x]=k;
    for(register int i=l;i<=r;i++){
        if(a[x][i]!=0&&col[i]==0) color(i,-k);
    }
}
int main(){
	scanf("%d %d",&l,&r);
	for(register int i=l;i<=r;i++){
        for(register int j=i+1;j<=r;j++){
            double k=sqrt(j*j-i*i);
            if((int)k!=k) continue;
            if(gcd(i,(int)k)==1) a[j][i]=i+j,a[i][j]=i+j,vis[i]=true,vis[j]=true;
        }
    }
    for(register int i=l;i<=r;i++){
        if(vis[i]==true){
            if(col[i]==0) color(i,1);
        }
    }
	printf("%d %d",cnt,KM());
}
```


---

## 作者：SaltedShark (赞：1)

提供一种非费用流的奇怪方法，对拍推荐找下面的费用流。

我刚学了二分图匹配，从二分图标签里找到的这个题，于是想当然地往二分图上套。发现一个数只能被消一次，并且要和另一个数一起消，符合匹配问题的性质。所以可以把数看成点，用数值给这个点编号，把符合条件的点连边，如果形成二分图就能跑匹配了。但是它究竟是不是二分图呢？我不会证，于是写了个暴力跑了一下没跑出来奇环。

还有一个问题是每条边有一个边权，是选这条边得到的收益。如果用KM算法，我又不会两边的点数量不相同的KM。但是发现这个边权不是任意的，是边两边的点的编号的和。于是想当然地有贪心，就是从左边最大的点开始从大向小匹配，每次找增广路的时候，找到所有增广路，然后走那条终点编号最大的。设点数为n，复杂度大概是n*n吧。找N次增广路，每次最坏遍历所有的点。点数大概五百，所以能过。

但是发现贪心正确性有点问题，有时候掉进局部最优出不来了。自然就想到随机化，于是跑n次上面的贪心算法，每次选定一个点不去，正确性挺玄学的，因为这个图是数学方法生成的，没法手造，而且比较稀疏，所以能水过去吧。总复杂度好像n^3，跑出来差不多八十毫秒。
```cpp
#include<ctime>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
int pf[1001000],nx[1000],hd[1010],t[1000],ys[1010],zb[1010],dm[1010],sl=0,zg[1010],yb[1010],sl2=0;
int gcd(int x,int y)
{
    if(y==0)return x;
    return gcd(y,x%y);
}
void ss(int x,int sc)
{
    ys[x]=sc;
    for(int i=hd[x];i!=0;i=nx[i])
        if(ys[t[i]]==0)ss(t[i],3-sc);
}
int zzd_sj(int x,int z)
{
    int mxx=-1;
    for(int i=hd[x];i!=0;i=nx[i])
        if(zg[t[i]]==0)
        {
            zg[t[i]]=1;
            if(dm[t[i]]==0&&t[i]!=z)return t[i];//找到最大的增广路终点
            mxx=max(mxx,zzd_sj(dm[t[i]],z));
        }
    return mxx;
}
int zzg(int x,int z)
{
    for(int i=hd[x];i!=0;i=nx[i])
        if(zg[t[i]]==0)
        {
            zg[t[i]]=1;
            if(dm[t[i]]==0&&t[i]==z)//匈牙利，但是只走确定的增广路
            {
                dm[t[i]]=x;
                return 1;
            }
            if(dm[t[i]]!=0&&zzg(dm[t[i]],z))
            {
                dm[t[i]]=x;
                return 1;
            }
        }
    return 0;
}
int main()
{
    srand(int(time(0)));
    for(int i=1;i<=1000;i++)pf[i*i]=i;
    int aa,bb,u=0;
    scanf("%d%d",&aa,&bb);
    for(int i=aa+1;i<=bb;i++)
        for(int j=aa;j<i;j++)
        {
            int z=pf[i*i-j*j];
            if(z!=0&&gcd(j,z)==1)
            {
                nx[++u]=hd[i];
                hd[i]=u;
                t[u]=j;
                nx[++u]=hd[j];
                hd[j]=u;
                t[u]=i;
            }
        }//暴力找符合条件的点建图
    for(int i=bb;i>=aa;i--)if(ys[i]==0&&hd[i]!=0)ss(i,1);
    for(int i=bb;i>=aa;i--)
		if(ys[i]==1)zb[++sl]=i;
		else yb[++sl2]=i;//把点黑白染色分成两部分
    int da=0,zh=0;
	for(int i=0;i<=sl2;i++)//0的时候无限制，其他时候都是yb[i]不去
	{
		int zh2=0,da2=0;
		memset(dm,0,sizeof(dm));
		for(int j=1;j<=sl;j++)
		{
        	memset(zg,0,sizeof(zg));
        	int mx=zzd_sj(zb[j],yb[i]);
        	if(mx==-1)continue;
        	++da2;
        	memset(zg,0,sizeof(zg));
        	zzg(zb[j],mx);//找到最大的路然后走过去
		}
		for(int j=aa;j<=bb;j++)if(ys[j]==2&&dm[j]!=0)
		{
			zh2+=j+dm[j];
		}
		zh=max(zh,zh2);
		da=max(da,da2);
	}
    printf("%d %d",da,zh);
    return 0;
}
```

---

## 作者：Chenyichen0420 (赞：0)

## 思路分析

一个好玩的事实是在极限数据下会有多达 $316$ 组不同的 $(x,y)$，非常巨大，使用费用流无法困难的通过。

唯一的问题是怎么样保证一个数不会被统计多次。

这时候我们想到一个办法：拆点。我们将一个点拆成入点和出点，每组贡献双向的从入点连到出点。然后再从源汇分别给到出入点 $1$ 单位流量。

问题来了：你怎么保证不会出现 $A_{in}\to B_{out},B_{in}\to C_{out}$ 的情况出现呢？

事实上我们容易观察到在最大费用流中，每一个点都会更倾向于向最大贡献者连边。

换句话说，如果从入点出发得到的匹配和从出点出发得到的匹配不一样，那我们通过将其中更小的那一个镜像为更大的那一个一定更优。

因此这样跑完之后我们得到的恰好是两个问题的答案的两倍，除掉就完了。代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
//#define common_match
#ifdef _MSC_VER
#define __gcd _Gcd
#endif
int n, m, k, s, t, ans, mxf;
#ifdef common_match
struct dinic {
	struct edge { int p, v; }tmp;
	vector<edge>e; vector<int>h[505];
	inline void ins(int l, int r, int v) {
		h[l].push_back(e.size());
		tmp.p = r; tmp.v = v;
		e.push_back(tmp);
		h[r].push_back(e.size());
		tmp.p = l; tmp.v = 0;
		e.push_back(tmp);
	}
	int d[505]; bool vis[505];
	inline bool bfs() {
		memset(vis, 0, sizeof vis);
		vis[s] = d[s] = 1;
		queue<int>q; q.push(s);
		while (q.size()) {
			int tp = q.front(); q.pop();
			for (int i = 0; i != h[tp].size(); ++i) {
				edge& sp = e[h[tp][i]];
				if (!vis[sp.p] && sp.v)
					d[sp.p] = d[tp] + 1,
					vis[sp.p] = 1, q.push(sp.p);
			}
		}
		return vis[t];
	}
	int cur[505];
	inline int dfs(int p, int a) {
		if (p == t || a == 0)  return a; int ret = 0, f;
		for (int& i = cur[p]; i != h[p].size(); ++i) {
			edge& sp = e[h[p][i]];
			if (d[sp.p] == d[p] + 1 && (f = dfs(sp.p, min(a, sp.v))) > 0) {
				sp.v -= f; e[h[p][i] ^ 1].v += f;
				ret += f; if ((a -= f) == 0) break;
			}
		}
		return ret;
	}
	inline int maxflow() {
		int ret = 0;
		while (bfs())
			memset(cur, 0, sizeof cur),
			ret += dfs(s, 0x3f3f3f3f);
		return ret;
	}
	inline void reset() {
		e.clear(); for (int i = 0; i <= t; ++i) h[i].clear();
	}
}din;
#else
struct SSP {
	struct node { int p, f, v; }tmp;
	vector<node>e; vector<int>h[5005];
	inline void ins(int l, int r, int f, int v) {
		tmp.p = r; tmp.f = f; tmp.v = v;
		h[l].emplace_back(e.size());
		e.emplace_back(tmp);
		tmp.p = l; tmp.f = 0; tmp.v = -v;
		h[r].emplace_back(e.size());
		e.emplace_back(tmp);
	}
	int d[5005]; bitset<5005>vis;
	inline bool spfa() {
		vis.reset(); fill(d + 1, d + t + 1, 0x3f3f3f3f3f3f3f3f);
		queue<int>q; q.emplace(s); d[s] = 0;
		while (q.size()) {
			int tp = q.front(); q.pop(); vis[tp] = 0;
			for (int i : h[tp])
				if (e[i].f && d[e[i].p] > d[tp] + e[i].v)
					if (d[e[i].p] = d[tp] + e[i].v, !vis[e[i].p])
						q.emplace(e[i].p), vis[e[i].p] = 1;
		}
		return d[t] != 0x3f3f3f3f3f3f3f3f;
	}
	int pr[5005];
	inline int dfs(int p, int f) {
		if (p == t || !f) return f;
		int ret = 0, v; vis[p] = 1;
		for (int& i = pr[p]; i != h[p].size(); ++i) {
			node& sp = e[h[p][i]];
			if (!vis[sp.p] && sp.f && d[sp.p] == d[p] + sp.v) {
				v = dfs(sp.p, min(f, sp.f));
				if (!v) d[sp.p] = 0x3f3f3f3f3f3f3f3f;
				sp.f -= v; e[h[p][i] ^ 1].f += v;
				ret += v; f -= v; ans += v * sp.v;
				if (!f) return ret;
			}
		}
		vis[p] = 0; return ret;
	}
	inline int que() {
		while (spfa()) {
			fill(pr + 1, pr + t + 1, 0);
			for (int v; v = dfs(s, 0x3f3f3f3f3f3f3f3f);) mxf += v;
		}
		return mxf;
	}
	inline void clear() {
		e.clear();
		for (int i = 1; i <= t; ++i) h[i].clear();
	}
}ssp;
#endif
inline bool issqr(int v, int i) {
	int t = sqrt(v);
	if (t * t != v) return 0;
	return __gcd(v, i) == 1;
}
signed main() {
	ios::sync_with_stdio(0);
	cin >> n >> m; s = m << 1 | 1; t = s + 1;
	for (int i = n; i <= m; ++i)
		for (int j = i + 1; j <= m; ++j)
			if (issqr(j * j - i * i, i))
				ssp.ins(i, j + m, 1, -i - j),
				ssp.ins(j, i + m, 1, -i - j);
	for (int i = n; i <= m; ++i) ssp.ins(s, i, 1, 0);
	for (int i = n; i <= m; ++i)
		ssp.ins(i + m, t, 1, 0);
	cout << ssp.que() / 2 << " "; cout << ((-ans) / 2) << endl;
}
```

---


# [CQOI2010] 鼹鼠

## 题目描述

Hilbert鼹鼠住在Hilbert地洞里——地洞的边界是一条$n$阶Hilbert曲线${H_n}$。Hilbert曲线的定义如下：${H_1}$是一个上端缺口的单位正方形；$H_n$由四份${H_n}-1$组成，其中左下和右下两份没有任何变化，而左上的那一份逆时针旋转了90度，而右上的那一份顺时针旋转了90度。这四份$H_n-1$用三条单位长度的线段连接起来构成了$H_n$。$H_1$~$H_4$如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/0vif0fh6.png)

你想捉一只Hilbert鼹鼠来玩，所以往地洞里使劲倒水想把它们赶出来。不过，由于地洞里有空气，无论你怎么倒水，有些地方总是淹不到的（假设水和空气都不可压缩）。输入Hilbert曲线

![](https://cdn.luogu.com.cn/upload/image_hosting/aaj85oki.png)

的阶数 $n$ 和地面的倾斜角 $α$ ，你的任务是计算能淹没到的面积。

注意，只有当水位严格高于一个障碍物时，水才能越过它往下流。更多细节可以参考下面的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/bbvmrpvd.png)


## 说明/提示

$rt,n<=12,0<=alpha<=90$

## 样例 #1

### 输入

```
5 30```

### 输出

```
190.803848```

## 样例 #2

### 输入

```
3 45```

### 输出

```
15.500000```

## 样例 #3

### 输入

```
4 10```

### 输出

```
91.573592
```

## 样例 #4

### 输入

```
3 0```

### 输出

```
26.000000

```

# 题解

## 作者：sounds_666 (赞：13)

#### [题目传送门](https://www.luogu.org/problem/P4179)
emm...当我看到这个题的时候，第一反应就是打表，于是就开始了漫长的推算之旅。。。

第一步数格子的个数，数了很久推出一个式子：$4* a[i-1]+2* (i-1)$

可是数完之后发现这样没用啊，还不一定是对的，于是打标思路愉快地GG。（~~也许可以只是我没推出来~~）

于是我就发现数量上行不通，从形状上总可以吧。于是推着推着就发现乱七八糟的图形是可以转化成为一个中学数学题。

那么规律是什么呢？举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/5jj9hob0.png?x-oss-process=image/resize,m_lfit,h_170,w_225)![](https://cdn.luogu.com.cn/upload/image_hosting/c0ujbvxq.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

你还没有发现规律吗？那就再来一组：

![](https://cdn.luogu.com.cn/upload/image_hosting/uv7cjqp9.png?x-oss-process=image/resize,m_lfit,h_170,w_225)![](https://cdn.luogu.com.cn/upload/image_hosting/2e344d3p.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

此时，不难发现规律，地图的左上角以及右上角的空，以及左下和右下的地洞是上一个的图形。这样分形就愉快的完成了。

此时突然发现，没有数据范围，好吧,我默默的打开了bzoj1817,发现了数据范围（$n≤12,0≤α<90$）（还无耻的请管理员加一下数据范围）那么有了数据范围就可以算出最大边长，及$2^{12}-1=4095$，所以就可以轻松的用一个二维数组存下来。

接下来应该就是考虑水在方格中的位置了。

![](https://cdn.luogu.com.cn/upload/image_hosting/6bzrtkmi.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

仔细观察，我们不难发现顶部的一个格子的水在格子中大概是这样的，再根据题意可看出，可以推出为基准高度为cosα（~~这是三角函数，不要问我为什么~~），但是中间的怎么办呢？其实也就是从周围四个格子相互连通中推导而来,想到周围的四个格子就想到了搜索（建议用dfs，感觉bfs会爆空间，毕竟$n≤12$）,那么只需从四个方向（左上，右上，左下，右下）推出即可。

举个例子（~~又要看图~~）：

![](https://cdn.luogu.com.cn/upload/image_hosting/ar18kg8x.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

就不难看出准高为h+sinα（左下），至于剩下的三个方向就不画图了，
直接告诉大家准高吧，分别是：$h+cosα$（右下），$h-sinα$（左上），$h-cosα$（右上），
其实大家学过三角函数的都知道吧，而且都应该能自己推出来（不会推的也不要慌，毕竟我也推了好久）

知道准高以后，就可以面积就可以进行分类讨论（与$cosα,sinα$）

分三段后求解，然后这个题就应该可以通过搜索做出来了

温馨提示：为了保证精度，最后在进行除法运算，小数点后取六位哦~~

最后就是你们想要的AC代码了：
```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
using namespace std;
int n,jd,len=1;
double sinn,coss,sum,ans;
const double p=4.0*atan(1.0);
bool vis[4100][4100],mapp[4100][4100],hole[4100][4100];
double min(double i,double j){return i<j?i:j;}
bool rule(int x,int y){
	if(x>=1&&y>=1&&x<=len&&y<=len&&!vis[x][y]&&mapp[x][y])return 0;
	return 1;
}
void dfs(int x,int y,double h){
	if(h<1e-10||rule(x,y))return;
	vis[x][y]=1;
	h=min(sum,h);
	if(jd==0)ans++;
	else{
		double s=sinn,c=coss;
		if(jd>45)swap(s,c);
		if(h<=s)ans+=h*h;
		else if(h<=c)ans+=(2.0*h-s)*s;
		else ans+=2.0*s*c-(s+c-h)*(s+c-h); 
	}
	dfs(x+1,y,h+coss),dfs(x,y+1,h+sinn);
	dfs(x-1,y,h-coss),dfs(x,y-1,h-sinn);
	return;
}
int main(){
	scanf("%d%d",&n,&jd);
	mapp[1][1]=1;
	for(int k=1;k<n;k++){
		for(int i=1;i<=len;i++){
			for(int j=1;j<=len;j++){
				hole[len-j+1][i]=hole[j][len+1+len-i+1]=!mapp[i][j];
				hole[len+1+i][j]=hole[len+1+i][len+j+1]=mapp[i][j];
			}
		}
		for(int i=1;i<=2*len+1;i++)hole[len+1][i]=1;
		for(int i=1;i<=len;i++)hole[i][len+1]=1;
		len*=2,len++;
		for(int i=1;i<=len;i++){
			for(int j=1;j<=len;j++)mapp[i][j]=hole[i][j];
		}	
	}
	double angle=(1.0*jd*p/180);
	sinn=sin(angle);
	coss=cos(angle);
	sum=coss+sinn;
	for(int i=1;i<=len;i++)dfs(1,i,coss);
	if(jd>0)ans/=(2.0*sinn*coss);
	printf("%0.6lf",ans);
	return 0;
}
```


---

## 作者：hunction (赞：3)

大体思路：Hilbert 曲线非常难以理解，于是想到把整个地洞划分为方格图，然后计算每个空心格子中被水淹没的面积。

设 $n$ 阶 Hilbert 曲线的边长为 $l_n$，则 $l_n = l_{n - 1} + 1$。所以 $n$ 阶 Hilbert 曲线的边长为 $2^n - 1$，可以轻松地用数组存储整张图。

#### Step1 求出空心格子

现在已知 $1$ 阶 Hilbert 曲线中的空心格位置（只有一个格子且为空心）

对于 $n \ge 2$，要从 $n - 1$ 阶 Hilbert 曲线推出 $n$ 阶 Hilbert 曲线。根据题面中 Hilbert 曲线的递归定义，直接把 $n-1$ 阶图像平移即可得到下面两个 $n -1$ 阶图像。然后左上角和右上角的图像可以通过旋转 + 平移生成。注意左上角和右上角的图像里，空心和实心的状态是相反的。还要把第 $l_{n - 1} + 1$ 行和第 $l_{n - 1} + 1$ 列的前 $l_{n - 1}$ 个设为空心的。

#### Step2 求出每格被水淹没的高度

设 $h_{x, y}$ 表示格 $(x, y)$ 中最低点到水位线的距离，则 $h_{x - 1, y} = h - \cos \alpha, h_{x + 1, y} = h + \cos \alpha, h_{x, y - 1} = h + \sin \alpha, h_{x, y + 1} = h - \sin \alpha$（推导过程不赘述，因为不难）。从第一行的所有格子都开始搜一遍（$h_{起始格} = \cos \alpha$），可以推出所有其他格子的 $h$。

值得注意的一点是，如果 $h > \sin \alpha + \cos \alpha$，就和 $\sin \alpha + \cos \alpha$ 取 $\min$；而只要 $h \le 0$ 了，后面都应该不算了，不然就会导致刚好卡在一个障碍物的角上又流不下去的情况会被算成流下去。

#### Step3 求出每个被水淹没的面积

设 $x = \min(\sin \alpha, \cos \alpha), y = \max(\sin \alpha, \cos \alpha)$，分三种情况讨论：

1. $h \le x$：面积为 $h ^ 2 \over 2 x y$。
2. $h > x \wedge h \le y$：面积为 $\frac{h ^ 2}{2 x y} - (\frac{h}{2xy} - 1)\frac{h - x}{2y}$。
3. $h > y$：面积为 $\frac{h ^ 2}{2 x y} - (\frac{h}{2xy} - 1)\frac{h - x}{2y}- (\frac{h}{2xy} - 1)\frac{h - y}{2x}$。

然后就做完了。但是除法应该放到最后做，不然会 WA 一个点。

代码：
```cpp
#include <bits/stdc++.h>
using lf = double;
const lf eps = 1e-7;
const int N = 15, L = (1 << 12) + 5;
int n, l = 1; lf alpha, ans, sn, cs;
bool emp[L][L], tmp[L][L], vis[L][L];
lf Calc(lf h) {
	lf x = std::min(sn, cs), y = std::max(sn, cs);
	if (alpha < eps) return 1;
	lf s0 = h * h / 2 / x / y, s1 = (h / x - 1) * (h - x) / y / 2, s2 = (h / y - 1) * (h - y) / x / 2;
	if (h < x + eps) return s0;
	if (h < y + eps) return s0 - s1;
	return s0 - s1 - s2;
}
void Dfs(int x, int y, lf h) {
	if (h < eps || x < 1 || x > l || y < 1 || y > l || !emp[x][y] || vis[x][y]) return;
	vis[x][y] = true, ans += Calc(h = std::max(std::min(h, sn + cs), 0.0));
	Dfs(x, y - 1, h + sn), Dfs(x, y + 1, h - sn), Dfs(x - 1, y, h - cs), Dfs(x + 1, y, h + cs);
}
int main() {
	scanf("%d%lf", &n, &alpha), emp[1][1] = 1, alpha = alpha / 180 * acos(-1), sn = sin(alpha), cs = cos(alpha);
	for (int k = 2; k <= n; k++, l = l * 2 + 1) {
		for (int i = 1; i <= l; i++) for (int j = 1; j <= l; j++) {
			tmp[l + 1 - j][i] = tmp[j][2 * l + 2 - i] = !emp[i][j];
			tmp[i + l + 1][j] = tmp[i + l + 1][j + l + 1] = emp[i][j];
		}
		for (int i = 1; i <= l * 2 + 1; i++) tmp[l + 1][i] = 1;
		for (int i = 1; i <= l + 1; i++) tmp[i][l + 1] = 1;
		memcpy(emp, tmp, sizeof emp);
	}
	for (int i = 1; i <= l; i++) Dfs(1, i, cs);
	printf("%lf\n", ans);
	return 0;
}

---

## 作者：GIFBMP (赞：3)

对于一个 $n$ 阶曲线，其边长是 $O(2^n)$ 级别的，直接暴力预处理即可。

对于 $\alpha=0$ 的情况，直接特判。接下来就是重点了，我们设一个方格中水面到其底部的顶点的距离为 $h$，那么对于左下角的方格，这个距离就会变为 $h+\sin\alpha$。

![](https://cdn.luogu.com.cn/upload/image_hosting/xlek6cjb.png)

同理可以推得，右下角的距离变为 $h+\cos\alpha$，左上角距离为 $h-\cos\alpha$，右上角距离为 $h-\sin\alpha$。

接下来我们只要根据 $h$ 计算这个方块内被覆盖的面积就可以了。当 $\alpha>45\degree$ 时，把图形轴对称一下就好了，我们只要考虑 $\alpha\le 45\degree$ 的情况。

当 $h\le \sin\alpha$ 时，显然有 $S=\dfrac{h^2}{2\sin\alpha\cos\alpha}$；

![](https://cdn.luogu.com.cn/upload/image_hosting/fn4ojphy.png)

当 $\sin\alpha<h\le\cos\alpha$ 时，$S=\dfrac{\sin\alpha}{2\cos\alpha}+\dfrac{h-\sin\alpha}{\cos\alpha}$；

![](https://cdn.luogu.com.cn/upload/image_hosting/51rh4x2j.png)

当 $h>\cos\alpha$ 时，和第一种情况一样，$S=1-\dfrac{(\sin\alpha+\cos\alpha-h)^2}{2\sin\alpha\cos\alpha}$。

于是就做完了。

要注意精度问题，把 $2\sin\alpha\cos\alpha$ 提到最外面除，不然会 WA 一个点。

总结：遇到这类看上去很难的题的时候要冷静分析，题目往往比看上去要简单很多。

Code:

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std ;
const double pi = acos (-1.0) ;
const int MAXN = 5e3 + 10 ;
int n , len , P ;
bool vis[MAXN][MAXN] , a[MAXN][MAXN] , b[MAXN][MAXN] ;
double A , sn , cs , ans ;
void dfs (int x , int y , double h) {
	if (h <= 0 || x < 1 || y < 1 || x > len || y > len || vis[x][y] || !a[x][y]) return ;
	h = min (h , sn + cs) ; vis[x][y] = 1 ;
	if (!P) ans++ ;
	else {
		double s = sn , c = cs ;
		if (P > 45) swap (s , c) ;
		if (h <= s) ans += h * h ;
		else if (h <= c) ans += (2 * h - s) * s ;
		else ans += (2.0 * s * c) - (s + c - h) * (s + c - h) ;
	} 
	dfs (x + 1 , y , h + cs) , dfs (x - 1 , y , h - cs) ;
	dfs (x , y + 1 , h - sn) , dfs (x , y - 1 , h + sn) ;
}
int main () {
	scanf ("%d%d" , &n , &P) , A = P * pi / 180.0 ;
	sn = sin (A) , cs = cos (A) ; len = a[1][1] = 1 ;
	for (int i = 1 ; i < n ; i++) {
		for (int j = 1 ; j <= len ; j++)
			for (int k = 1 ; k <= len ; k++) {
				b[j][k] = !a[k][j] ;
				b[j + len + 1][k] = a[j][k];
				b[j][k + len + 1] = !a[len - k + 1][j] ;
				b[j + len + 1][k + len + 1] = a[j][k];
			}
		for (int j = 1 ; j <= 2 * len + 1 ; j++) b[len + 1][j] = 1 ;
		for (int j = 1 ; j <= len + 1 ; j++) b[j][len + 1] = 1 ;
		len = 2 * len + 1 ;
		for (int j = 1 ; j <= len ; j++)
			for (int k = 1 ; k <= len ; k++)
				a[j][k] = b[j][k] ;
	}
	for (int i = 1 ; i <= len ; i++) dfs (1 , i , cs) ;
	if (P) ans /= (2.0 * sn * cs) ;
	printf ("%.6lf\n" , ans) ;
	return 0 ;
}
```

---

## 作者：PrincessQi (赞：0)

先考虑 $a=0$ 怎么做。

观察题目，发现 $H_n$ 由两个正着的 $H_{n-1}$，一个朝左的反 $H_{n-1}$（洞变成土地，土地变成洞），一个朝右的反 $H_{n-1}$ 构成，且二维数组能存下 $H_{12}$。

于是递归构造即可。

然后从第一行每一个洞开始搜索，记录所有能达到的地方即可。注意水不能往上流（由于地洞的另一头并不裸露，所以这不是连通器）。

然后考虑一般情况。

注意到可以记录当前水的深度。假设当前深度是 $h$，转移的话就从 $h$ 转移到 $h\pm \sin a$、$h\pm \cos a$ 即可。统计答案的话考虑可以用 $h$ 加上简单初中三角函数知识求出每个能走的格子的水的面积。

个人觉得做这种题绝对不能被花里胡哨的题面吓到，这题实际难度其实是远低于看起来的难度的。

---


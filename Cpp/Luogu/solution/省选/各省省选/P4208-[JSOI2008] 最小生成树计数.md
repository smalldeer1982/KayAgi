# [JSOI2008] 最小生成树计数

## 题目描述

现在给出了一个简单无向加权图。你不满足于求出这个图的最小生成树，而希望知道这个图中有多少个不同的最小生成树。（如果两棵最小生成树中至少有一条边不同，则这两个最小生成树就是不同的）。由于不同的最小生成树可能很多，所以你只需要输出方案数对 $31011$ 的模就可以了。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le n \le 100$，$1 \le m \le 1000$，$1\leq c_i\leq 10^9$。

## 样例 #1

### 输入

```
4 6
1 2 1
1 3 1
1 4 1
2 3 2
2 4 1
3 4 1```

### 输出

```
8
```

# 题解

## 作者：smarthehe (赞：101)

UPD in 2020/12/26：更换了图床。

UPD in 2020/8/12：修改排版与一些语言。原来的真是太丑了。

题目要求求出最小生成树的个数。

看起来无从下手，连暴力也想不出来。

所以我们需要一个最小生成树的性质。

**定理：** 同一个图的每个最小生成树中，边权相等的边数量相等。

**证明：**（不严谨）

考虑kruskal算法的过程，先排序，后枚举所有边。

对于同一边权的边，如果两端点不属于同一个联通块，总会在最小生成树中加入该边。

操作等价于：加入所有同一边权的边，后消除其中所有的简单环。

发现消环操作不影响对于顶点的连通性，且消除一个简单环等价于删掉环中一条边。

所以，无论如何消环，最终剩余总边数一定。其他边权以此类推。
___

### 算法1.枚举

题目中限制条件：相等边权的边数不超过 10。

考虑先求最小生成树，然后对于最小生成树中出现的每种边权，用暴力枚举的方式统计在同一边权的边中选取哪几条也可保证最小生成树连通性。

举例说明：

这是一个图。

![](https://cdn.luogu.com.cn/upload/image_hosting/clvsiofe.png)

这是原图的某一个最小生成树。

![](https://cdn.luogu.com.cn/upload/image_hosting/mrrt6xj0.png)

加上原图上的所有边权为3的边，新图长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/kzojqvdl.png)

于是你可以枚举任意不成环的三边，他们都可以形成一种最小生成树，例如以下两种：

![](https://cdn.luogu.com.cn/upload/image_hosting/hgncvv12.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/tekbr8o0.png)

对于任意一个边权均是如此，例如边权为 4：

![](https://cdn.luogu.com.cn/upload/image_hosting/xcoi4bfu.png)

枚举类似边权为 3 的情况，此处不再列举。

对于同一边权，极限 $2^{10}$ 枚举，统计当前边权答案后 $O(m)$ 枚举其他边权，乘法原理统计答案。

极限时间复杂度 $O(2^{10}m)$（不好表示就直接把枚举复杂度算进去了），且实际复杂度不可能达到此值，可以通过。
___

### 算法2.生成树计数

由定理以及枚举做法的启发，我们可以每次指定最小生成树中的一种边权。

不过，相较于枚举并判环，我们有更好的方法保证最小生成树的连通性。

将最小生成树上非该边权的边都加在一个新图上，利用并查集缩点。

之后将原图中边权为选定值的边都加在新图上，注意缩点后边的处理。

还用以前的例子说明：

![](https://cdn.luogu.com.cn/upload/image_hosting/z8bcluyp.png)

对黑点以及黑边缩点：

![](https://cdn.luogu.com.cn/upload/image_hosting/mfmlixs6.png)

直接对该新图求生成树个数，即可统计答案并保证连通性。

这样就可以统计出取同一权值边的方案个数。枚举每种边权利用乘法原理统计答案即可。

但是，由于生成树计数是 $O(n^3)$ 的算法，乍眼一看复杂度逼近 $O(m n^3)$，是不可行的。

以下严谨证明复杂度为 $O(n^3)$。

首先容易发现，在一棵树上，每删除一条边会使连通块个数 +1。
 
设最小生成树上有 $k$ 种边权，每种边权边数为 $c_1$ 到 $c_k$。

对于第 $i$ 种边权，每次删掉 $c_i$ 条边，形成 $c_i+1$ 个连通块，对新图求生成树个数时间为 $O(c_i^3)$。总时间 $O(\sum\limits_{i=1}^k c_i^3)$。

有不等式：

$$
\sum_{i=1}^{k} c_i^3 \leq \left(\sum_{i=1}^k c_i\right)^3
$$

证明可以直接把右边拆开，除了左边那些三次项还有一堆非负项。

注意到 $\sum\limits_{i=1}^k c_i = n-1$，于是复杂度 $O(n^3)$。

以下是算法 2 的代码。算法 1 的代码请参看其他题解。

另，由于本人使用的是最裸的辗转相除法行列式求值，所以复杂度是 $O(n^3\log n)$。使用一些其他技巧就能达到 $O(n^3)$ 的效率，详情请查看其他行列式求值相关博客。

___

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

const int N=101,M=1001,MOD=31011;

//原图，边权离散化并按相等边权存储 
struct e
{
    int x,y,v;
} tp[M],mst[M];
vector<e> edge[M]; 
int cmp(e a,e b)
{
    return a.v<b.v;
}

bool is[M];

//并查集 
int bcj[N],bel[N];
void init(int a)
{
	for(int i=1;i<=a;i++) bcj[i]=i;
}
int rt(int a)
{
    if(bcj[a]==a) return a;
    return bcj[a]=rt(bcj[a]);
}
bool uni(int a,int b)
{
    int p=rt(a),q=rt(b);
    if(p==q) return true;
    bcj[p]=q;
    return false;
}

//三个矩阵 度数、邻接、基尔霍夫 
int n,deg[N][N],g[N][N],mat[N][N];

int treecnt()//生成树计数，辗转相除高斯消元 
{
    int i,j,k,ans=1;
    for(i=1;i<n;i++)
    {
        for(j=i+1;j<n;j++)
        {
            while(mat[j][i])
            {
                int div=mat[i][i]/mat[j][i];
                for(k=i;k<n;k++) mat[i][k]=(mat[i][k]-1ll*mat[j][k]*div%MOD+MOD)%MOD;
                swap(mat[i],mat[j]);
                ans*=-1;
            }
            if(mat[i][i]==0) return 0;
        }
        ans=1ll*ans*mat[i][i]%MOD;
    }
    return (ans+MOD)%MOD;
}

int main()
{
    int a,b,i,j,k,tl=0,tmp=0,cnt=0;
    scanf("%d%d",&a,&b);
    init(a);
    for(i=0;i<b;i++) scanf("%d%d%d",&tp[i].x,&tp[i].y,&tp[i].v);
    sort(tp,tp+b,cmp);

    //kruskal 
    for(i=0;i<b;i++)
    {
        if(tp[i].v!=tmp) tl++,tmp=tp[i].v;
        edge[tl].push_back(tp[i]);
        if(uni(tp[i].x,tp[i].y)) continue;
        is[tl]=1,mst[cnt]=tp[i],mst[cnt++].v=tl;
    }
    if(cnt!=a-1)
    {
        printf("0");
        return 0;
    }

    //统计答案 
    int ans=1;
    for(i=1;i<=tl;i++)
    {
        //如果最小生成树中没有用到此边权 
        if(!is[i]) continue;

		init(a);
        int siz=edge[i].size();
		n=0;
		
		//将生成树上的边全部连上并缩点
		for(j=0;j<cnt;j++)
		{
			if(mst[j].v==i) continue;
			uni(mst[j].x,mst[j].y);
		}
		for(j=1;j<=a;j++)
		{
			if(bcj[j]==j) bel[j]=++n;
		}
		for(j=1;j<=a;j++) bel[j]=bel[rt(j)];
		
        //将原图中此边权的边全部连上 
        for(j=0;j<siz;j++)
        {
            int bx=bel[edge[i][j].x],by=bel[edge[i][j].y];
            deg[bx][bx]++,deg[by][by]++;
            g[bx][by]++,g[by][bx]++;
        }

        for(j=1;j<=n;j++)
            for(k=1;k<=n;k++)
                mat[j][k]=deg[j][k]-g[j][k];
        ans=ans*treecnt()%MOD;

        //删除连上的边 
        for(j=0;j<siz;j++)
        {
            int bx=bel[edge[i][j].x],by=bel[edge[i][j].y];
            deg[bx][bx]--,deg[by][by]--;
            g[bx][by]--,g[by][bx]--;
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：老K (赞：62)

大概的思路：

我们发现对于所有最小生成树，每种边权的边数是一样的。

那就可以首先找到最小生成树，然后枚举每种边权w，把其它边权，在生成树里的边加上，然后求有几种方案选出边权为w的边，把他们加上，使得得到了一棵树。

然后乘起来。

那么这个方案数就可以用Matrix-Tree定理计算。

矩阵求行列式，基本方法就是高斯消元。


--- 
以下是之前的做法，正解在下面

由于我太菜了，不会模数不为质数时的高斯消元，所以我是直接浮点数强算行列式然后转int乘起来的。

这个为什么能对呢？

因为同样权值的边数不超过10，再怎么方案数都没有1024，不会出现太大的情况。

//另：对于这个限制，使得暴力计算而不用Matrix-Tree复杂度正确甚至可能还跑得快些我无话可说，反正我没跑过暴力

```C++
/*
Author: CNYALI_LK
LANG: C++
PROG: 4208.cpp
Mail: cnyalilk@vip.qq.com
*/
#include<bits/stdc++.h>
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define DEBUG printf("Passing [%s] in LINE %lld\n",__FUNCTION__,__LINE__)
#define Debug debug("Passing [%s] in LINE %lld\n",__FUNCTION__,__LINE__)
#define all(x) x.begin(),x.end()
using namespace std;
const double eps=1e-8;
const double pi=acos(-1.0);
typedef long long ll;
typedef pair<ll,ll> pii;
template<class T>ll chkmin(T &a,T b){return a>b?a=b,1:0;}
template<class T>ll chkmax(T &a,T b){return a<b?a=b,1:0;}
template<class T>T sqr(T a){return a*a;}
template<class T>T mmin(T a,T b){return a<b?a:b;}
template<class T>T mmax(T a,T b){return a>b?a:b;}
template<class T>T aabs(T a){return a<0?-a:a;}
#define min mmin
#define max mmax
#define abs aabs
ll read(){
	ll s=0,base=1;
	char c;
	while(!isdigit(c=getchar()))if(c=='-')base=-base;
	while(isdigit(c)){s=s*10+(c^48);c=getchar();}
	return s*base;
}
struct edge{
	ll u,v,w;
};
edge e[102424];
ll fa[102424],use[102424];
ll is[102424];
ll find(ll x){return x==fa[x]?x:fa[x]=find(fa[x]);}
ll e_cmp(edge a,edge b){return a.w<b.w;}
const ll p=31011;
double a[128][128];
ll inv[31015];
ll det(ll n){
	double k,s=1;
	for(ll i=1;i<=n;++i){
		if(fabs(a[i][i])<eps){
			ll hv=0;
			for(ll j=i+1;j<=n;++j)if(fabs(a[j][i])>=eps){
				hv=1;
				s=-s;
				for(ll l=1;l<=n;++l)swap(a[i][l],a[j][l]);
				break;
			}
			if(!hv)return 0;
		}
		k=1/a[i][i];
		s=s*a[i][i];
		for(ll j=i;j<=n;++j)a[i][j]=a[i][j]*k;
		for(ll j=i+1;j<=n;++j){
			k=a[j][i];
			for(ll l=1;l<=n;++l){
				a[j][l]-=a[i][l]*k;
			}
		}
	}
	ll ans=(ll)(s+eps+eps);
	return ans;
}
int main(){
#ifdef cnyali_lk
	freopen("4208.in","r",stdin);
	freopen("4208.out","w",stdout);
#endif
	ll n,m;
	inv[1]=1;
	for(ll i=2;i<p;++i)inv[i]=(p-p/i)*inv[p%i]%p;
	n=read();m=read();
	for(ll i=1;i<=m;++i){
		e[i].u=read();
		e[i].v=read();
		e[i].w=read();
	}
	sort(e+1,e+m+1,e_cmp);
	for(ll i=1;i<=n;++i)fa[i]=i;
	ll g=n;
	for(ll i=1;i<=m&&g>1;++i)if(find(e[i].u)!=find(e[i].v)){
		use[i]=1;	
		fa[find(e[i].u)]=find(e[i].v);
		--g;
	}
	if(g>1){printf("0\n");return 0;}
	ll u=1,v=1;
	ll ans=1;
	while(v<=m){
		for(ll i=1;i<=n;++i){
			fa[i]=i;
			is[i]=0;
		}
		for(ll i=1;i<=m;++i)if(use[i]&&e[i].w!=e[u].w){
			fa[find(e[i].u)]=find(e[i].v);	
		}	
		g=0;
		for(ll i=1;i<=n;++i){
			if(!is[find(i)]){
				is[find(i)]=++g;
			}
			is[i]=is[find(i)];
		}
		for(ll i=1;i<=g;++i)for(ll j=1;j<=g;++j)a[i][j]=0;
		while(e[u].w==e[v].w){
			a[is[e[v].u]][is[e[v].v]]-=1;
			a[is[e[v].v]][is[e[v].u]]-=1;
			a[is[e[v].u]][is[e[v].u]]+=1;
			a[is[e[v].v]][is[e[v].v]]+=1;
			++v;
		}

		--g;
		ans=ans*det(g)%p;
		u=v;
	}
	printf("%lld\n",ans);
	return 0;
}


```
---
upd：正解：

我们现在要用$a_{i,i}$把$a_{j,i}$在模意义下消为0，当模数为质数的时候，可以用逆元，但是非质数的时候怎么办呢？

考虑求$\gcd(a,b)$的过程：

```C++
int gcd(int a,int b){
	while(b){
		a-=(a/b)*b;//a%=b;
	    swap(a,b);
	}
	return a;
}
```

然后a就是gcd了，b就被消没了。

那么就可以类似的对整行进行相减，交换直到要消的元素消掉为止，显然$a_{i,i},a_{j,i}$消掉都没事，只要消掉的元素那行交换到第j行就行。

注意任何一次交换都会使行列式值取反。

这样就是$O(n^3 \log n)$的了（减次数是$O(\log n)$，单次$O(n)$

怎么把log消掉呢？

就直接单独对这两个元素相消（当然也要对行列式，然后记录a,b,c,d，设原来两个元素是u,v，之后分别变成了$au+bv,cu+dv$，之后对于每一列对应的元素u,v，直接更新就可以了。

时间复杂度$O(n^3)$

```C++
/*
Author: CNYALI_LK
LANG: C++
PROG: 4208.cpp
Mail: cnyalilk@vip.qq.com
*/
#include<bits/stdc++.h>
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define DEBUG printf("Passing [%s] in LINE %lld\n",__FUNCTION__,__LINE__)
#define Debug debug("Passing [%s] in LINE %lld\n",__FUNCTION__,__LINE__)
#define all(x) x.begin(),x.end()
using namespace std;
const double eps=1e-8;
const double pi=acos(-1.0);
typedef long long ll;
typedef pair<ll,ll> pii;
template<class T>ll chkmin(T &a,T b){return a>b?a=b,1:0;}
template<class T>ll chkmax(T &a,T b){return a<b?a=b,1:0;}
template<class T>T sqr(T a){return a*a;}
template<class T>T mmin(T a,T b){return a<b?a:b;}
template<class T>T mmax(T a,T b){return a>b?a:b;}
template<class T>T aabs(T a){return a<0?-a:a;}
#define min mmin
#define max mmax
#define abs aabs
ll read(){
    ll s=0,base=1;
    char c;
    while(!isdigit(c=getchar()))if(c=='-')base=-base;
    while(isdigit(c)){s=s*10+(c^48);c=getchar();}
    return s*base;
}
struct edge{
    ll u,v,w;
};
edge e[102424];
ll fa[102424],use[102424];
ll is[102424];
ll find(ll x){return x==fa[x]?x:fa[x]=find(fa[x]);}
ll e_cmp(edge a,edge b){return a.w<b.w;}
const ll p=31011;
ll a[128][128];
ll inv[31015];
void kill(ll a,ll b,ll &aii,ll &aij,ll &aji,ll &ajj,ll &sign){
	sign=1;
	aii=ajj=1;
	aij=aji=0;
	while(b){
		aii-=a/b*aji;
		aij-=a/b*ajj;
		aij=(aij%p+p)%p;
		aii=(aii%p+p)%p;
		a%=b;
		swap(a,b);
		swap(aii,aji);
		swap(aij,ajj);
		sign=-sign;
	}
}
ll det(ll n){
    ll k,s=1,_a,b,c,d,pa,ans=1,nxa,nxb;
	for(ll i=1;i<=n;++i)for(ll j=1;j<=n;++j)if(a[i][j]<0)a[i][j]+=p;
    for(ll i=1;i<=n;++i){
        for(ll j=i+1;j<=n;++j){
			kill(a[i][i],a[j][i],_a,b,c,d,pa);
			s*=pa;
			for(ll k=1;k<=n;++k){
				nxa=(a[i][k]*_a+a[j][k]*b)%p;	
				nxb=(a[i][k]*c+a[j][k]*d)%p;	
				a[i][k]=nxa;
				a[j][k]=nxb;
			}
        }
		ans=ans*a[i][i]%p;
    }

    return ans*(s+p)%p;
}
int main(){
#ifdef cnyali_lk
    freopen("4208.in","r",stdin);
    freopen("4208.out","w",stdout);
#endif
    ll n,m;
    inv[1]=1;
    for(ll i=2;i<p;++i)inv[i]=(p-p/i)*inv[p%i]%p;
    n=read();m=read();
    for(ll i=1;i<=m;++i){
        e[i].u=read();
        e[i].v=read();
        e[i].w=read();
    }
    sort(e+1,e+m+1,e_cmp);
    for(ll i=1;i<=n;++i)fa[i]=i;
    ll g=n;
    for(ll i=1;i<=m&&g>1;++i)if(find(e[i].u)!=find(e[i].v)){
        use[i]=1;	
        fa[find(e[i].u)]=find(e[i].v);
        --g;
    }
    if(g>1){printf("0\n");return 0;}
    ll u=1,v=1;
    ll ans=1;
    while(v<=m){
        for(ll i=1;i<=n;++i){
            fa[i]=i;
            is[i]=0;
        }
        for(ll i=1;i<=m;++i)if(use[i]&&e[i].w!=e[u].w){
            fa[find(e[i].u)]=find(e[i].v);	
        }	
        g=0;
        for(ll i=1;i<=n;++i){
            if(!is[find(i)]){
                is[find(i)]=++g;
            }
            is[i]=is[find(i)];
        }
        for(ll i=1;i<=g;++i)for(ll j=1;j<=g;++j)a[i][j]=0;
        while(e[u].w==e[v].w){
            a[is[e[v].u]][is[e[v].v]]-=1;
            a[is[e[v].v]][is[e[v].u]]-=1;
            a[is[e[v].u]][is[e[v].u]]+=1;
            a[is[e[v].v]][is[e[v].v]]+=1;
            ++v;
        }

        --g;
        ans=ans*det(g)%p;
        u=v;
    }
    printf("%lld\n",ans);
    return 0;
}


```


---

## 作者：Siyuan (赞：53)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/articles/problem-JSOI-2008-MST-Count/)

---

## Description

> 题目链接：[Luogu 4208](https://www.luogu.org/problemnew/show/P4208)

给出一个由 $n$ 个点和 $m$ 条边构成的简单无向加权图。你不满足于求出这个图的最小生成树，而希望知道这个图中有多少个不同的最小生成树。（两棵最小生成树是不同的当且仅当它们有至少有一条边不同）。方案数对 $31011$ 取模。

数据范围：$1\le n\le 100$，$1\le m\le 1000$

------

## Solution

### 简化版

由于在 $\text{MST}$ 中，**每种权值的边的数量是固定的**，那么我们先统计出每种权值需要多少条边，记为 $c_i$。

我们发现具有相同权值的边的数量不超过 $10$ 条，那么我们暴力枚举第 $i$ 种权值的边选择哪 $c_i$ 条，然后根据乘法原理来统计答案。（这个算法已经可以通过本题）

**注意**：我们为了能够快速分开连通块，并查集中**不能使用路径压缩**！

**时间复杂度**：$O(2^{10}m)$

### 加强版

我们考虑**加强版**：每种权值的边不超过 $100$ 条。我们就需要**矩阵树定理**了。

注意到 $\text{MST}$ 有如下性质：

1. 每种权值的边的数量是固定的。
2. 不同的生成树中，某一种权值的边任意加入需要的数量后，**形成的联通块状态是一样的**。

这样一来，我们可以枚举树边的权值 $i$，把**权值不是 $i$ 的树边**都加入图中后进行缩点；对于**权值为 $i$ 的原图中的边**，在缩点后的图中构造**基尔霍夫矩阵**，用矩阵树定理求出方案数。

最终的答案也是根据乘法原理计算。

**时间复杂度**：$O(n^3\log n)$（大概是这样吧，这个算法我不怎么会算呀 QAQ）

------

## Code

### 简化版

```cpp
#include <cstdio>
#include <algorithm>

const int N=105,M=1e3+5;
const int mod=31011;
int n,m,cnt,sum,l[M],r[M],c[M],fa[N];
struct Edge {
	int u,v,w;
	bool operator < (const Edge &b) const {
		return w<b.w;
	}
}e[M];

int find(int x) {
	return fa[x]==x?x:find(fa[x]);
}
void dfs(int now,int x,int num) {
	if(now>r[x]) {
		sum+=(num==c[x]);
		return;
	}
	int fu=find(e[now].u),fv=find(e[now].v);
	if(fu!=fv) {
		fa[fu]=fv;
		dfs(now+1,x,num+1);
		fa[fu]=fu,fa[fv]=fv;
	}
	dfs(now+1,x,num);
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i) scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
	std::sort(e+1,e+m+1);
	for(int i=1;i<=n;++i) fa[i]=i;
	int tot=0;
	for(int i=1;i<=m;++i) {
		if(e[i].w!=e[i-1].w) r[cnt]=i-1,l[++cnt]=i;
		int fu=find(e[i].u),fv=find(e[i].v);
		if(fu!=fv) ++c[cnt],fa[fu]=fv,++tot;
	}
	r[cnt]=m;
	if(tot!=n-1) return puts("0"),0;
	for(int i=1;i<=n;++i) fa[i]=i;
	int ans=1;
	for(int i=1;i<=cnt;++i) {
		sum=0,dfs(l[i],i,0),ans=ans*sum%mod;
		for(int j=l[i];j<=r[i];++j) fa[find(e[j].u)]=find(e[j].v);
	}
	printf("%d\n",ans);
	return 0;
}
```

### 加强版

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

const int N=105,M=1e3+5;
const int mod=31011;
int n,m,tot,fa[N],a[N][N],bel[N],val[N];
struct Edge {
	int u,v,w;
	bool operator < (const Edge &b) const {
		return w<b.w;
	}
}e[M],tr[N];

int find(int x) {
	return fa[x]==x?x:fa[x]=find(fa[x]);
}
void init() {
	for(int i=1;i<=n;++i) fa[i]=i;
}
void add(int u,int v) {
	--a[u][v],--a[v][u],++a[u][u],++a[v][v];
}
void merge(int x,int y) {
	fa[find(x)]=find(y);
}
int Gauss(int n) {
	int ans=1;
	for(int i=1;i<=n;++i) {
		for(int k=i+1;k<=n;++k) {
			while(a[k][i]) {
				int d=a[i][i]/a[k][i];
				for(int j=i;j<=n;++j) a[i][j]=(a[i][j]-1LL*d*a[k][j]%mod+mod)%mod;
				std::swap(a[i],a[k]),ans=-ans;
			}
		}
		ans=1LL*ans*a[i][i]%mod,ans=(ans+mod)%mod;
	}
	return ans;
}
bool kruskal() {
	std::sort(e+1,e+m+1);
	init();
	int cnt=0;
	for(int i=1;i<=m;++i) {
		int fu=find(e[i].u),fv=find(e[i].v);
		if(fu==fv) continue;
		fa[fu]=fv,tr[++cnt]=e[i];
		if(e[i].w!=val[tot]) val[++tot]=e[i].w;
	}
	return cnt==n-1;
}
void addTreeEdge(int v) {
	for(int i=1;i<n&&tr[i].w!=v;++i) merge(tr[i].u,tr[i].v);
	for(int i=n-1;i&&tr[i].w!=v;--i) merge(tr[i].u,tr[i].v);
}
int getblock() {
	int blo=0;
	for(int i=1;i<=n;++i) if(find(i)==i) bel[i]=++blo;
	for(int i=1;i<=n;++i) bel[i]=bel[find(i)];
	return blo;
}
void rebuild(int v) {
	memset(a,0,sizeof(a));
	for(int i=1;i<=m;++i) if(e[i].w==v) add(bel[e[i].u],bel[e[i].v]);
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i) scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
	if(!kruskal()) return puts("0"),0;
	int ans=1;
	for(int i=1;i<=tot;++i) {
		init();
		addTreeEdge(val[i]);
		int blo=getblock();
		rebuild(val[i]);
		ans=1LL*ans*Gauss(blo-1)%mod;
	}
	printf("%d\n",ans);
	return 0;
}
```



---

## 作者：Kevin_Wa (赞：28)

此题刚看到（$n \leq100$），首先想到的是暴力搜索，将所有的情况都搜出来，再找到最小的几个数，取模。

在看到取模时就可意识到爆搜恐怕$TLE$满满的，所以再根据数据来判断，应该搜索是过的了的，不需要高级算法。

考虑一点：如果搜索时发现该生成树已经大于了最小生成树，就可以返回了。时间复杂度可以再降$n$

但是（$n \leq100$）的范围还是勉强，所以我们可以由上发现一个规律：

在所有最小生成树中，同一权值边的个数是不变的。

几乎所有的题解直接忽略了证明，包括楼顶的那个，所以我来简单证一下。

首先明白最小生成树的做法，用k的话，是从小到大选的，每一步都是最优的，然而再选一种方案，由于生成树的边必然是$n-1$，所以要想仍最优，当前这一步的权值必然是小于等于我们先前找的最小生成树的该步权值，但是通过倒证，如果出现小于的情况，必然会出现更优的生成树，但是显然不会存在，所以在所有最小生成树中，同一权值边的个数是不变的。

于是乎我们可以爆搜了。

通过优化，我们可以记录搜索每一种权值的搜索方案，再运用乘法原理相乘，取模再得到最优解。

因为模数小且权值$\leq 10^9$所以可以不开$long long$

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node {
	int x,y,z;
}a[1001],b[1001];
int n,m,i,t,f[1001],d[1001],c[1001],cnt,ans,xx,yy;
int find(int x)//k算法
{
	if (f[x]==x) return x;
	f[x]=find(f[x]);
	return f[x];
}
void dfs(int now,int k,int x)//now表当前位置，k表示加入边数，x表权值种类在d数组中位置
{ 
	if (now>b[x].y)//如果搜过右端点
	  {
	  	if (k==d[x]) cnt++;//符合情况则+1
	  	return;
	  }
	int p[101];
	for (int i=1;i<=n;i++) p[i]=f[i];//存储
	xx=find(a[now].x);yy=find(a[now].y);
	if (xx!=yy)//如果可以加入最小生成树
	    {
	  	f[xx]=yy;
	  	dfs(now+1,k+1,x);
		}
	for (int i=1;i<=n;i++) f[i]=p[i];//还原
	dfs(now+1,k,x);
	
}
int cmp(node a,node b){return a.z<b.z;}
int main()
{
	scanf("%d %d",&n,&m);
	for (int i=1;i<=m;i++)//输入
	  scanf("%d %d %d",&a[i].x,&a[i].y,&a[i].z);
	sort(a+1,a+1+m,cmp);//快排用于k算法及搜索同一权值
	for (int i=1;i<=n;i++)//k算法初始化
	  f[i]=i;
	a[0].z=-INT_MAX;t=0;
	for (int i=1;i<=m;i++)
	  if (a[i].z==a[i-1].z)//搜索同一权值的左右位置，方便搜索
	    {
	    	b[t].y++;c[i]=t;//y表是右端点
		}
	else {
		t++;b[t].x=i;b[t].y=i;c[i]=t;//x表示左端点，t表示权值种数
	    }
	cnt=0;
	for (int i=1;i<=m;i++)
	  {
	  	xx=find(a[i].x);yy=find(a[i].y);//寻找最小生成树
	  	if (xx!=yy) 
	  	  {
	  	  	f[xx]=yy;
	  	  	d[c[i]]++; //d存储该权值需要的边数
			cnt++;
			}
		if (cnt==n-1) break;//最小生成树找到
	  }
	if (cnt!=n-1) {printf("0");exit(0);}//没找到
  for (int i=1;i<=n;i++) f[i]=i;//初始
  ans=1;
  for (int i=1;i<=t;i++)
    if (d[i]>0)
    {
    	cnt=0;
    	dfs(b[i].x,0,i);//搜索
    	ans=(ans*cnt)%31011;//乘法原理
    	for (int j=b[i].x;j<=b[i].y;j++)/更新
    	  {
    	  	xx=find(a[j].x);yy=find(a[j].y);
    	  	if (xx!=yy)
    	  	  {
    	  	  	f[xx]=yy;
				}
		  } 
	
    }
printf("%d\n",ans);
 } 
```

---

## 作者：YHASDY (赞：9)

更好的阅读体验，在洛谷博客和[博客园](https://www.cnblogs.com/InductiveSorting-QYF/p/11742332.html)

前置知识：对于同一个图的所有最小生成树，权值相等的边的数量相同。

　　可以简单证明一下：

｜　　我们可以从kruskal的过程考虑。这个算法把所有边按权值大小从小到大排序，然后按顺序看每条边，只要加上这条边后不会形成连通块，就加上。

｜　　以上过程其实等价于先将所有权值等于第一条边的边都加进图中，然后一个个删边，使图中无环。设权值等于第一条边的边数为i，下次再将所有权值等于第i+1条边的边都加进图中。。。直至算过最后一条边，或图中刚好剩下了n-1条边（n为图的点的个数）。

｜　　发现加完一批边后要删的边的个数等于形成的“最小环”的个数（这里最小环是指：对于一个最小环，不存在一组边使得通过这组边把环“从中间切开”后，被切开的环的两部分可与这组边形成两个新环（即不是依照国际标准的定义，而是为了方便在本文现定义的）；同时最小环边数不一定小）。

｜　　　　为什么呢？从一个最小环开始考虑：

｜　　　　　　若不存在其他的某个最小环v与这个环u有公共边，那么只要任意删一条边就能减少一个最小环。

｜　　　　　　若存在，这时删边就有两种情况：

｜　　　　　　　　删公共边：首先u和v原来的最小环形态都会被破坏，最小环数目-2。然后，发现u和v剩下的部分又可以组成一个新的最小环，所以最小环的数目又+1。所以最小环数目-1；

｜　　　　　　　　不删公共边：u的最小环形态被破坏，且不会生成新的最小环，所以最小环数目-1。

｜　　　　　　综上，可知要删的边的数目==最小环的数目，且要删的边可是最小环上的任意边。

｜　　　　由于加完一批边后，最小环的数目确定，所以删的边的数目也确定。故图生成的所有最小生成树边权相等的边数目也相等。所以我们可以先跑一次最小生成树，记录下每种边权在最小生成树中的出现次数

｜　　同时我们还发现，当处理完一批权值等于x的边后，这个图的连通性（即都有哪些点连通）是唯一的。即使不用kruskal做最小生成树，设用了算法A做最小生成树，如果只保留权值等于x的边，那么保留的图的连通性与用kruskal做到处理完权值等于x的边时是一样的。否则，只可能连通的点数小于用kruskal做到时的连通的点数（因为kruskal全部地考虑过了权值等于x的边，其他算法不可能比全部还多吧）。但这是不成立的，因为若成立，就说明用kruskal做的最小生成树X中权值等于x的边比A算法得到的最小生成树Y中权值等于x的边的边数多一。由于kruskal是从小边开始贪心考虑所有边的，那么X的权值和一定小于Y，与Y是最小生成树矛盾；并且这也与上文的定理矛盾。

｜　　设最小生成树边的权值从小到大分别为x1,x2,...,xk，那么构造一个最小生成树只需要分k步，每步都是在前面步骤都做了的基础上，选择一个对所有权值等于x的边的保留方案。由于每步造成的对连通性的影响都是一样的，即每步的结果都是一样的，所以可以用乘法原理，将每步的保留方案数乘起来再去模就是答案了。

｜　　怎么求每步的保留方案数呢？由于题目限制权值相等的边不超过10条，所以用dfs枚举就是了，同时可用并查集验证可行性。注意：如果dfs要回溯到之前状态，那么并查集不能路径压缩，否则并查集的状态难以回溯到之前的状态。
  
｜ 时间复杂度:O(2^n　*m）
  
 满分代码：
 ```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>

using namespace std;

const int N=105,M=1005,mod=31011;

struct Edge{
    int from,to,len;
}e[M];

int n,m,f[N],l[M],r[M],cnt,tot,ecnt[M];
int x;

char ch;

inline int read()
{
    x=0;
    ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
    return x;
}

inline bool cmp(const Edge &a,const Edge &b)
{
    return a.len<b.len;
}

int yfa(int u)
{
    if(u==f[u]) 
        return u;
    else 
        return f[u]=yfa(f[u]);
}    

int fa(int u)
{
    if(u==f[u])
        return u;
    else
        return fa(f[u]);
}
//能/不能路径压缩的并查集查找 
void dfs(int wei,int kin,int had)//当前看的边数组的位置，当前看的边的种类，当前已经取的边的数目 
{
    int b1,b2;
    b1=fa(e[wei].from);//dfs要回溯状态，所以dfs里并查集查找操作不能路径压缩 
    b2=fa(e[wei].to);
    if(r[kin]-wei+1+had==ecnt[kin])//如果已经取的边的数目+还能取的数目=要取的边的数目，就只能取了 
    {
        if(b1==b2) return;
        if(had==ecnt[kin]-1) 
        {
            cnt++;
            return;
        }
        f[b1]=b2;
        dfs(wei+1,kin,had+1);
        f[b1]=b1;
        return;
    }
    if(b1!=b2)
    {
        if(had+1==ecnt[kin])
            cnt++;
        else
        {
            f[b1]=b2;
            dfs(wei+1,kin,had+1);
            f[b1]=b1;
        }
    }
        dfs(wei+1,kin,had);
}

int main()
{
    n=read(),m=read();
    for(int i=1;i<=m;++i)
        e[i].from=read(),e[i].to=read(),e[i].len=read();
    sort(e+1,e+m+1,cmp);
    for(int i=1;i<=n;++i)
        f[i]=i;
    int u,v;
    for(int i=1;i<=m;++i)
    {
        if(e[i].len==e[i-1].len)
        {
            r[tot]++;
        }
        else
        {
            ++tot;
            l[tot]=r[tot]=i;
        }
        if(cnt<n-1)
        {
            u=yfa(e[i].from),v=yfa(e[i].to);
            if(u!=v)
            {
                ecnt[tot]++;
                f[u]=v;
                cnt++;
            }
        }
    }
    if(cnt<n-1)//注意无解时的判断 
    {
        printf("0");
        return 0;
    }
    long long ans=1;
    for(int i=1;i<=n;++i) f[i]=i;
    for(int i=1;i<=tot;++i) 
        if(ecnt[i])
        {
            cnt=0;
            dfs(l[i],i,0);
            ans=(ans*cnt)%mod;
            for(int j=l[i];j<=r[i];++j)//更新当前步骤做完时图的连通性 
            {
                u=yfa(e[j].from);
                v=yfa(e[j].to);
                if(u!=v) 
                    f[u]=v;
            }
        }
    printf("%lld",ans);
    return 0;
}
```
欢迎提问。

（写的有点多，应该能懂吧）

（懂了的话不妨点个赞，让更多的人看到）
（没有懂的话，不用吝啬评论功能的使用，作者会积极答疑）

---

## 作者：taoran (赞：9)

#### 前置技能:
#### 定理：一张图的所有最小生成树中权值相等的边的个数一定相同
#### 证明：一开始集合中为空，然后向集合中加边，先加最小的边，无论怎样都会加到不能再加，就相当于把边都加入后把环删除，此时凡是能用这种边连通的点都联通了，之后把相连通的点缩为一个点考虑，第二次同理加当前最小的边（整体第二小的边）......然后感性理解一下呗qwq
之后发现本题思路：

先要求出最小生成树，统计每一种权值的边的个数ha2[i]，然后枚举每一种权值的边，只要在所有该权值的边中找出有多少种ha2[i]条边的组合能生成最小生成树。
由于本题 
##### “注意：具有相同权值的边不会超过10条。”
所以可以暴力枚举是哪ha2[i]条边，将其加入，用并查集维护，当发现某边两顶点已在同一并查集中，则有环，不合法，将其删去。最后乘法原理统计一下答案即可。

##### 代码如下，可能不大好看 ~~非常丑陋,它可真长~~  qwq：

```
#include<bits/stdc++.h>
#define F(x,y,z) for (int x=y;x<=z;++x)
#define LL long long
#define ct continue
#define pb 31011
using namespace std;
LL cnt,n,m,f[105],ans=1,yd[1005],vv[105],s[1005],k,wx[1005],f2[105];
map<int,int>ha2;
map<int,int>vis;
struct edg
{
	int u,v,w;
}e[1005];
bool cmp(const edg &aa,const edg &bb)
{
	return aa.w<bb.w;
}
int ask(int x)
{
	if (x==f[x])
		return x;
	f[x]=ask(f[x]);
	return f[x];
}
void mer(int x,int y)
{
	f[ask(x)]=ask(y);
} 
int ask2(int x)
{
	if (x==f2[x])
		return x;
	f2[x]=ask2(f2[x]);
	return f2[x];
}
void mer2(int x,int y)
{
	f2[ask2(x)]=ask2(y);
} 
void dfs(int de,int fi)
{
	if (de==fi+1)
		{
			F(i,1,n)
				f2[i]=f[i];
			F(j,1,de-1)
				{
					int i=vv[j];
					if (ask2(e[wx[i]].u)==ask2(e[wx[i]].v))
						return;
					else mer2(e[wx[i]].u,e[wx[i]].v);
				}
			s[e[wx[1]].w]++; 
			s[e[wx[1]].w]%=pb;
			return;
		}
	for (int i=vv[de-1]+1;i<=k;++i)
		vv[de]=i,dfs(de+1,fi);
}
void work(int x)
{
	F(i,1,n)
		f[i]=i;
	F(i,1,m)
		if (e[i].w!=x)
			if (yd[i])
				mer(e[i].v,e[i].u);
	k=0;
	F(i,1,m)
		if (e[i].w==x)
			wx[++k]=i;
	s[x]=0;
	dfs(1,ha2[x]);
	ans*=s[x];
	ans%=pb;
}
int main()
{
	scanf("%d%d",&n,&m);
	F(i,1,m)
		{
			scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
		} 
	sort(e+1,e+m+1,cmp);
	int i=1;
	F(i,1,n)
		f[i]=i;
	while (i<=m)
		{
			if (cnt==n-1)
				break; 
			if (ask(e[i].u)!=ask(e[i].v))
				{
					mer(e[i].u,e[i].v);
					cnt++;
					ha2[e[i].w]++;
					yd[i]=1;
				}
			i++;
		}
	if (cnt!=n-1)
		{
			printf("0\n");
			return 0;
		}
	F(i,1,m)
		{
			if (!vis[e[i].w])
				{
					vis[e[i].w]=1;
					work(e[i].w);
				}	
		} 
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Space_Gold_Trash (赞：9)

这道题就是要求你求出最小生成树的个数

但是如何才能求出个数呢?

我们首先明确一个定理

对于所有的最小生成树,它们的权值相同的边的个数是一样的

我们如何证明这个定理呢?

我们首先求出一个最小生成树

我们随便加一条边

我们就必须在这个环上删去一条边

但是如果我们删去的边比加入的边小

岂不是就不是最小生成树了?

但是如果相反,那么最开始的最小生成树不就不是最小生成树了?

那么我们就可以确定,我们删去一条边,再加上一条边

这两个边一定是相等的

那么很显然,最小生成树中,权值不相同的边是不会互相干扰的

那么我们就可以求出每个权值相同的边有多少个不成环的组合方式

然后乘法原理搞一下,不就行了吗?

但是有一些小细节

比如不能路径压缩,因为压缩了岂不是就不能回溯了?

因为回溯我们用的是将点的父亲节点设为自己

```
#include<bits/stdc++.h>
#define MOD 31011
#define M 1011
#define N 111
using namespace std;
struct Edge{
	int x,y,z;
	inline bool operator<(const Edge &p)const{
		return z<p.z;
	}
}ed[M];
struct remember{
	int st,ed,ci;
}re[M];
int cnt;
int fa[N];
inline int find(int k){
	return k==fa[k]?k:find(fa[k]);
}
inline void un(int x,int y){
	x=find(x);y=find(y);
	fa[x]=y;
}
int sum;
inline void dfs(int k,int now,int s){
	if(now==re[k].ed+1){
		if(s==re[k].ci)++sum;
		return;
	}
	int x=find(ed[now].x),y=find(ed[now].y);
	if(x!=y){
		fa[x]=y;
		dfs(k,now+1,s+1);
		fa[x]=x;fa[y]=y;
	}
	dfs(k,now+1,s);
}
int main( ){
	int n,m;
	scanf("%d%d",&n,&m);
	int i,j,x,y,z;
	for(i=1;i<=m;++i){
		scanf("%d%d%d",&x,&y,&z);
		ed[i]=Edge{x,y,z};
	}
	for(i=1;i<=n;++i)fa[i]=i;
	sort(ed+1,ed+m+1);
	int tot(0);
	for(i=1;i<=m;i++)re[i].ci=0;
	for(i=1;i<=m;++i){
		if(ed[i].z!=ed[i-1].z){re[cnt].ed=i-1;re[++cnt].st=i;}
		x=ed[i].x;y=ed[i].y;
		if(find(x)!=find(y)){++re[cnt].ci;un(x,y);++tot;}
	}
	re[cnt].ed=m;
	if(tot!=n-1){puts("0");return 0;}
	int ans(1);
	for(i=1;i<=n;++i)fa[i]=i;
	for(i=1;i<=cnt;++i){
		sum=0;
		dfs(i,re[i].st,0);
		ans=ans*sum%MOD;
		for(j=re[i].st;j<=re[i].ed;++j)
		if(find(ed[j].x)!=find(ed[j].y))un(ed[j].x,ed[j].y);
	}
	printf("%d",ans);
}
```

---

## 作者：Kelin (赞：8)

### [题意](https://blog.csdn.net/BeNoble_/article/details/79745850)

最小生成树计数

---

### 题解

考虑最小生成树的两个性质： 

>$1.$不同的最小生成树中,每种权值的边出现的个数是确定的 
>$2.$不同的生成树中,某一种权值的边连接完成后,形成的联通块状态是一样的 

所以我们可以把边权相同的边放在一起处理

举个例子~~(图片是网上下的)~~

![这里写图片描述](https://img-blog.csdn.net/20180329153140581?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JlTm9ibGVf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

其中虚线边表示边权相同的边

假设其中每个联通块内的答案已经算完了,考虑缩点

![这里写图片描述](https://img-blog.csdn.net/20180329153324470?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JlTm9ibGVf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

那么我们用矩阵树定理可以算出上图的生成树的个数

所以我们只要在$Kruskal$中处理完一种边权的边后做一遍当前这些联通块的生成树计数就好了

然后根据乘法原理把每一种边权的答案乘就好了

具体怎么处理联通块

我们用$belong$表示合并之前的这个点所属的联通块(即$s_1,s_2,s_3$),$fa$表示连了当前这种长的边后这个点所属的联通块(整个一坨)

对于一个整的联通块$fa$,我们记录其中当前所有长度的边$(u,v)$

缩点之后就是$(belong_u,belong_v)$,也就是只要求当前的$belong$形成的基尔霍夫矩阵的值就好了

因为这题的模数不是质数所以要用到辗转相除来解行列式
```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
const int N=105,M=1005,P=31011;
typedef int arr[N];
struct eg{int u,v,w;}e[M];
int n,m,ans=1;arr fa,bl,vis,g[N],G[N];vector<int>s[N];
int gf(int u,int*fa){return fa[u]==u?u:fa[u]=gf(fa[u],fa);}
inline int pls(int a,int b){return a+=b,a>=P?a-P:a;}
inline int sub(int a,int b){return a-=b,a<0?a+P:a;}
inline int det(int n){
    int a,b,t,f=1,tp=1;
    fp(i,1,n)fp(j,1,n)G[i][j]=pls(P,G[i][j]);
    fp(i,1,n){
        fp(j,i+1,n){
            a=G[i][i],b=G[j][i];
            while(b){
                t=a/b;a%=b;swap(a,b);
                fp(k,i,n)G[i][k]=sub(G[i][k],t*G[j][k]%P);
                fp(k,i,n)swap(G[i][k],G[j][k]);f=-f;
            }
        }
        if(!G[i][i])return 0;
        tp=tp*G[i][i]%P;
    }
    return pls(P,f*tp);
}
inline void calc(){
    fp(i,1,n)if(vis[i]){s[gf(i,fa)].push_back(i);vis[i]=0;}
    fp(i,1,n)if(s[i].size()>1){
        int t=s[i].size(),*a=s[i].data();
        memset(G,0,sizeof G);
        fp(j,1,t)fp(k,j+1,t){
            int u=a[j-1],v=a[k-1];
            if(g[u][v]){
                G[j][k]=G[k][j]=-g[u][v];
                G[j][j]+=g[u][v],G[k][k]+=g[u][v];
            }
        }
        ans=ans*det(t-1)%P;
        fp(j,1,t)bl[a[j-1]]=i;
    }
    fp(i,1,n)s[i].clear(),fa[i]=bl[i]=gf(i,bl);
}
inline bool cmp(const eg&a,const eg&b){return a.w<b.w;}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    scanf("%d%d",&n,&m);
    fp(i,1,n)fa[i]=bl[i]=i;
    fp(i,1,m)scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
    sort(e+1,e+m+1,cmp);e[0]=e[1];
    fp(i,1,m){
        if(e[i].w^e[i-1].w)calc();
        int u=gf(e[i].u,bl),v=gf(e[i].v,bl);
        if(u^v){
            vis[u]=vis[v]=1;
            ++g[u][v],++g[v][u];
            fa[gf(u,fa)]=gf(v,fa);
        }
    }calc();
    fp(i,2,n)if(bl[i]^bl[i-1])return puts("0"),0;
    printf("%d",ans);
return 0;
}
```

---

## 作者：ShuYuMo (赞：7)

### P4208 [JSOI2008]最小生成树计数


#### 应该了解到的：
 - 对于一张没有相同边权的图 $G$ 来说，他的最小生成树是唯一的。换句话说，导致图 $G$ 的最小生成树 $T$ 不唯一的因素是边权重复的边。对应 `kruskal` 的运行过程来说，就是在边排序的过程中，相同权值的边内部的处理顺序。
 - 尽管相同权值的边处理顺序不同，但是不管按什么顺序处理这些边，最终处理完这种权值的边后，图的联通关系是相同的。
 - 因为对于边权相同的边处理顺序并不影响后面比这些边大的边的决策情况。所以 每一组权值相同的边对答案的贡献是独立的。可以分别考虑每一组权值相同的边 对答案的贡献，最终乘法原理统计即可。


#### 两种解法：
 - 对于每一组权值相同的边，考虑其贡献的方法
 - 暴力枚举每一组边
 - 关于其他题解的另一种方法是：
    - 例如 当前计算贡献的一组具有相同边权的边，先将与其权值**不同**的边加入图中，形成一堆连通块，每一个连通块缩成一个点，再加入这组边，对形成的图做生成树计数，然后这张图的生成树个数就是这组边对答案的贡献。
 - 而我想到的是：
    - 如果考虑 `kruskal` 的运行过程，对于一组具有相同权值的边，其贡献的计算方法应该是加入比这组边的边权**小**的所有边，形成连通块 缩点，再加入这组边，对形成的图 通过矩阵树定理 求生成树计数。


#### 两种解法的异同
  - 必须是加入除了选定的那一组以外**全部**的边之后，对每个联通块缩点，再加入选定的那一组边权相同的边，统计生成树计数，即这组点的贡献。
  - 因为如果只加入比这组边的边权小的边，可能这张图并不联通，也就是说，如果用矩阵树定理求其生成树的数量，答案将会是 $0$。
  - 暴力算法可以求出只加入比这组边的边权小的边后，按照不同顺序加入当前这组边后形成的森林数量，而矩阵树定理只能求出生成树数量。
  - 所以如果使用矩阵树定理求每组边贡献，必须加入这组之外的全部边后才能计数。
  - 可以证明，加入部分边，求下一组边按不同顺序加入求其森林数  和  加入除这组边以外的所有边后求联通生成树数 这两种方法是等价的。只不过求森林数没有什么多项式解法，不能像求生成树数量那样用矩阵树定理优化复杂度。

#### 具体实现方法
可以考虑先建出一棵最小生成树，然后考虑某组权值为 $w$ 的边时，`dfs` 求出删去这条边后 所有连通块，对所有连通块缩点，然后用 `Matrix-tree` 求出这一组边加入后的图形成的生成树数量。

#### 代码
```cpp
#include <climits>
#include <cstring>
#include <cstdio>
#include <iostream>
#include <algorithm>
int read() { int x; scanf("%d", &x); return x; }
using namespace std;
const int _N = 2e2 + 10;
const int _M = 2e3 + 10;
const int MOD = 31011;
int n, m;
struct edges{
    int u, v, w;
}edge[_M];
bool CMP(const edges & A, const edges & B) { return A.w < B.w; }
namespace Tree{
    int head[_N];
    struct edges{
        int node;
        int w;
        int nxt;
    }edge[_M];
    int tot = 0;
    void add(int u, int v, int w) {
        tot++;
        edge[tot].node = v;
        edge[tot].nxt  = head[u];
        edge[tot].w    = w;
        head[u]        = tot;
    }
    int nodetot = 0;
    int SCC[_N]; // 这里的SCC命名并不严谨，这里的SCC只是指缩点后，某个原图点所在的缩点编号。如 SCC[i] 表示原图中的点 i 缩入的点。
    void dfs(int now, int W){
        SCC[now] = nodetot;
        for(int i = head[now]; i ;i = edge[i].nxt) {
            int ex = edge[i].node;
            if(SCC[ex]) continue; if(edge[i].w == W) continue;
            dfs(ex, W);
        }
    }
    void initDfs(int x) {
        nodetot = 0;
        fill(SCC + 1, SCC + 1 + n, 0);
        for(int i = 1; i <= n; i++){
            if(!SCC[i]) ++nodetot, dfs(i, x);
        }
    }
} using Tree::add; using Tree::nodetot; using Tree::SCC; using Tree::initDfs;

int fa[_N];
void init(int n) { for(int i = 1; i <= n; i++) fa[i] = i; }
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
void merge(int x, int y) { x = find(x); y = find(y); fa[x] = y; }
bool ask(int x, int y)  { return find(x) == find(y); }

int matrix[_N][_N];
int det(int n){
    int ans = 1;
    for(int i = 1; i <= n; i++) {
        for(int j = i + 1; j <= n; j++) {
            while(matrix[j][i]) {
                int x = matrix[i][i] / matrix[j][i];
                for(int k = i; k <= n; k++){
                    matrix[i][k] = (matrix[i][k] -0ll- (matrix[j][k] *1ll* x % MOD) + MOD) % MOD;
                    swap(matrix[i][k], matrix[j][k]);
                } ans *= -1;
            }
        }
    }
    for(int i = 1; i <= n; i++) ans = (ans *1ll* matrix[i][i]) % MOD;
    return ( ans % MOD + MOD ) % MOD;
}
int main(){
    n = read(), m = read();
    for(int i = 1; i <= m; i++) {
        edge[i].u = read();
        edge[i].v = read();
        edge[i].w = read();
    }
    init(n);
    sort(edge + 1, edge + 1 + m, CMP);
    for(int i = 1; i <= m; i++) {
        edges &now = edge[i];
        if(ask(now.u, now.v)) continue;
        add(now.u, now.v, now.w); add(now.v, now.u, now.w);
        merge(now.u, now.v);
    }
    int ans = 1; edge[m + 1].w = INT_MAX;
    for(int i = 1; i <= m; i++) {
        int L = i, R;
        for(R = i; edge[R + 1].w == edge[L].w; R++);
        cerr << L << " " << R << " " << edge[L].w << endl;
        initDfs(edge[L].w);
        for(int j = L; j <= R; j++) {
            edges &now = edge[j];
            matrix[ SCC[now.u] ][ SCC[now.u] ] ++;
            matrix[ SCC[now.v] ][ SCC[now.v] ] ++;
            matrix[ SCC[now.u] ][ SCC[now.v] ] --;
            matrix[ SCC[now.v] ][ SCC[now.u] ] --;
        }
        ans = (ans *1ll* det(nodetot - 1)) % MOD;
        for(int k = 1; k <= nodetot; k++) for(int j = 1; j <= nodetot; j++) matrix[k][j] = 0;        
        i = R;
    }
    printf("%d\n", ans);
    return 0;
}
```
  

---

## 作者：fighter (赞：4)

# 题解 P4208 【[JSOI2008]最小生成树计数】

​	先说明一下，我是看了 foreverlastnig大神的题解后才写的这道题，所以代码比较相似。这里也仅仅是对各位大佬的题解的一些小小的补充。

​	关于具体的思路和定理的证明，很多大佬都完整的讲解过了，我针对我自己在思考这道题时的一些疑惑做一些补充。

1. 为什么按照各种权值固定的次数选取一定能成为最小生成树？很多人证明了所有最小生成树中相同权值的边出现的次数一定是相等的。但反过来在选取了这些边之后为什么会形成完整的树呢？其实这是一个很弱智的问题，但却让我想了半天~~（还是太弱了）~~。实际上选取了这些边之后，边数一定达到了n-1条，而我们在选取的时候就已经通过判断使得这些边不可能构成环，那不就刚好构成一棵树吗？

2. 为什么不能对dfs中使用的并查集进行路径压缩？我认为是因为在dfs过程中搜索完后需要还原，以保证搜索的正确性，而这种还原要保证并查集的结构完整地被还原，如果进行路径压缩，那么当前的根节点，在dfs后可能已经不是根节点，原先他的子节点经过路径压缩后，都指向了当前“级别”更高的根节点，这时候如果要还原并查集的结构就会十分困难。

## 代码

```cpp
#include <bits/stdc++.h>
#define MAXN 105
#define MAXM 1005
#define P 31011
#define ll long long
using namespace std;

struct Edge{
    int v1,v2, w;
    Edge(){
        v1 = v2 = w = 0;
    }
}g[MAXM];
bool cmp(Edge e1, Edge e2){
    return e1.w < e2.w;
}
struct node{
    int l, r, v;    //起点,终点,最小生成树中所包含的数量
}a[MAXM];

int n, m, cnt, sum;
int par[MAXN];

int find(int x){
    if(par[x] == x){
        return x;
    }
    return find(par[x]);       //为了不破坏并查集结构,不进行路径压缩
}

void init(){
    for (int i = 1; i <= n; ++i) {
        par[i] = i;
    }
}

bool kruskal(){     //其实kruskal中的并查集可以路径压缩
    int tot = 0;
    sort(g+1, g+m+1, cmp);
    for (int i = 1; i <= m; ++i) {
        if(g[i].w != g[i-1].w){
            cnt++;
            a[cnt].l = i;
            a[cnt-1].r = i-1;
        }
        int x = find(g[i].v1), y = find(g[i].v2);
        if(x == y){
            continue;
        }
        tot++;
        a[cnt].v++;
        par[x] = y;
    }
    a[cnt].r = m;
    return (tot == n-1);
}

void dfs(int x, int now, int tot){ //在第几层(按权值分层),边集中的位置,当前层已选择的数量
    if(now > a[x].r){
        if(tot == a[x].v){
            sum++;
        }
        return;
    }
    int a = find(g[now].v1), b = find(g[now].v2);
    if(a != b){
        par[a] = b;
        dfs(x, now+1, tot+1);
        par[a] = a, par[b] = b;
    }
    dfs(x, now+1, tot);
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; ++i) {
        scanf("%d%d%d", &g[i].v1, &g[i].v2, &g[i].w);
    }
    init();
    if(!kruskal()){
        cout << 0 << endl;
        return 0;
    }
    init();
    ll ans = 1;
    for (int i = 1; i <= cnt; ++i) {
        sum = 0;
        dfs(i, a[i].l, 0);
        ans = ans*sum % P;
        for (int j = a[i].l; j <= a[i].r; ++j) {
            int x = find(g[j].v1), y = find(g[j].v2);
            if(x != y){
                par[x] = y;
            }
        }
    }
    cout << ans << endl;

    return 0;
}
```



---

## 作者：小塘空明 (赞：3)

在同一个图中的最小生成树中，相同权值的边的边数是相同的。

证明：每个相同权值的边构成图上的一些联通块，我们先把每个边权值组成的联通块内部去掉环，每个连通块之间相互连接。如果要从一个联通块内部连一条环到别的联通块，肯定不如权值更小的联通块内部连接更优。

所以相当于每一个相同权值的边的联通块内求构成生成图的方案数。

因为每个方案相对独立，对结果进行相乘。

因为同一权值的边不会超过十条，容易证明当每个权值边数都为10时复杂度最大，此时复杂度为36000000左右，可以通过本题~~如果加强版的话各位还是好好学矩阵树吧~~

注意并查集并不能路径合并，否则会失去路径上的一些信息。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;
typedef long long ll;
const ll size=1e3+10;
const ll mod=31011;
struct node{ll x,y,z;}a[size];
struct sege{ll l,r,cnt;}b[size];
ll n,m,q,ans,res,fa[size];
inline bool operator<(const node&x,const node&y){
	return x.z<y.z;
}
inline ll get(ll x){
	if(x==fa[x]) return x;return get(fa[x]);
}
inline ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}
inline void dfs(ll x,ll i,ll sum){
	if(i==b[x].r+1){
		if(sum==b[x].cnt) res++;return;
	}
	ll fx=get(a[i].x),fy=get(a[i].y);
	if(fx!=fy){
		fa[fx]=fy;dfs(x,i+1,sum+1);fa[fx]=fx;fa[fy]=fy;
	}
	dfs(x,i+1,sum);
}
int main(){
	n=read();m=read();
	for(ll i=1;i<=m;i++){a[i].x=read();a[i].y=read();a[i].z=read();}
	sort(a+1,a+1+m);
	for(ll i=1;i<=n;i++) fa[i]=i;
	for(ll i=1;i<=m;i++){
		if(a[i].z!=a[i-1].z) b[++q].l=i,b[q-1].r=i-1,b[q].cnt=0;
		ll x=get(a[i].x),y=get(a[i].y);
		if(x==y) continue;
		fa[x]=y;ans++;b[q].cnt++;
	}
	b[q].r=m;
	if(ans!=n-1){printf("0\n");return 0;}
	else{
		ans=1;
		for(ll i=1;i<=n;i++) fa[i]=i;
		for(ll i=1;i<=q;i++){
			res=0;dfs(i,b[i].l,0);ans=ans*res%mod;
			for(ll j=b[i].l;j<=b[i].r;j++){
				ll x=get(a[j].x),y=get(a[j].y);
				if(x==y) continue;fa[x]=y;
			}
		}
		printf("%lld\n",ans);
	}
	return 0;
} 
```


---

## 作者：brealid (赞：2)

考虑性质【具有相同权值的边不会超过 $10$ 条】

从一般套路来看，$10$ 可能涉及指数级算法。

|$n^n≈$|$n!≈$|$2^n≈$|
|:-:|:-:|:-:|
|$1\times10^{10}$|$3.63\times10^6$|$1.02\times 10^3$|

~~所以我们用猜复杂度的方法知道了实际复杂度与 $O(2^n)$ 有关~~

考虑 $O(2^n)$ 一般的做法：按位枚举。

于是就可以口胡出一种做法，**证明在后**

> 做法：  
> 「一」对于 **``mst`` 上有的边** 的权值（设权值为 $k$，且这样的边在 **原图** 上有 $c$ 条），先连接 **``mst``** 上 **权值非 $k$** 的边（尤指**并查集合并**操作）  
> 「二」对于剩下的 **原图上的权值为 $k$** 的边，**枚举子集**（即：二进制从 $0$ 到 $2^c$ 枚举）  
> 「三」对于枚举得到的一种子集，**首先要保证**若这些子集中的边全部加入，得到的图的边数为 $n-1$。  
>> 形式化的说，我们要保证 **``mst`` 上权值非 $k$ 的边的条数 + $sizeof\{subset\}(subset \subset E_{edge.val==k}) = n-1$**   

> 「四」接下来我们要保证若这些子集中的边全部加入，得到的是一棵**树**（而不是非连通图）。这是，我们可以通过类似 ``kruskal`` 的方式利用**并查集**维护点联通关系。只要有任意一条边在连接时导致了环的形成（即：这条边的两个端点早已联通）则这种子集不构成对答案的贡献  
>> 注意，由于并查集的**断边**操作十分困难，而且若实现将只能**按秩合并**而不能**路径压缩**，所以我们在枚举子集之前**对 ``fa`` 数组进行备份**，这样可以快速地将 ``fa`` 数组还原到**对这种子集检验之前的情况**

证明：关键点在于证明“在所有最小生成树中，权值相等的边出现的次数相等”

现在我们考虑一颗 ``mst`` 中的两条边 $e_1,e_2$。$e_1$ 连接 $u_1,v_1$，权值为 $w_1$；$e_2$ 连接 $u_2,v_2$，权值为 $w_2$。根据 ``mst`` 性质易知 $u_1,v_1,u_2,v_2$ 中必定有两点可以不经过 $e_1,e_2$ 到达，不妨设为 $v_1,u_2$

![P4208-sol.PNG](https://i.loli.net/2020/06/08/PpM1yHOqJE8Ieub.png)

**前提** $e_1,e_2$ 与图上**三个蓝框代表的点集合**构成一颗 ``mst``  
**假设 1** 有两条不属于 ``mst`` 的边 $e_3,e_4$ 满足其权值均不等于 $e_1,e_2$ 的权值  
**假设 2** $e_3,e_4$ 与图上**三个蓝框代表的点集合**能构成一颗 ``mst``  

不妨设 $val_{e_1}<val_{e_2}$ 和 $val_{e_3}<val_{e_4}$。
1. 如果有 $val_{e_3}<val_{e_1}$ ，可知在 ``kruskal`` 中 $e_3$ 先于 $e_1$ 访问。而 $e_3$ 既然能满足**假设 2**，则 $e_3$ 一定会被加入到 ``mst`` 中，与**假设 1**矛盾
2. 如果有 $val_{e_1}<val_{e_3}$，由 **前提** 与 **假设 2** 可知 $val_{e_1}+val_{e_2}=val_{e_3}+val_{e_4}$，所以易得 $val_{e_1}<val_{e_3}<val_{e_4}<val_{e_2}$。此时在 ``kruskal`` 中 $e_3,e_4$ 先于 $e_2$ 访问。而 $e_3,e_4$ 既然能满足**假设 2**，则 $e_3$ 或 $e_4$ 一定会被加入到 ``mst`` 中（且 $e_2$ 将不会被加入到 ``mst`` 中），则可以得出一颗 ``mst`` ，其权值小于原 ``mst``，矛盾。

现在已经可以得出这题的全部解法。  

时间复杂度（$D$ 为“具有相同权值的边”的最多个数）：  
- 枚举所有 **``mst`` 上有的边** 的权值： $\Theta(n)$
- 对于 **原图上的权值为 $k$** 的边 **枚举子集** ：$\Theta(2^{D})$  
- 检验方案正确性 ：$\Theta(D)$  

总时间复杂度：$\Theta(nD2^D)$

代码：[见我的 gitee 仓库](https://gitee.com/hkxa/mycode/blob/master/luogu/P4208.cpp)

---

## 作者：_WA自动机 (赞：2)

更好的阅读体验点[这里](https://wa-automaton.github.io/2019/03/08/BZOJ1016/)~
# 大意：
给你一个联通无向图，求其最小生成树的个数。答案对31011取模。（鬼知道为啥是这个数）
# 分析：
这道题有个很有趣也很奇妙的结论...
> 对于一个无向连通图来说，它的所有最小生成树中，相等边权的边的数量都是相等的，且在去掉这些相等边权的边之后，图的连通性也是相同的。

这个结论怎么证明呢？~~大胆猜想，无需证明~~
> 这里给出一个简单证明~~感性理解~~：考虑kruskal的过程,不妨把加入相同权值的边看做一个“阶段”。每次加边都是加到加入图中会形成环为止。然后进入下一个阶段。那么，把前面已经被更小权值的边联通的联通块看做一些点，则我们就是在这些点之间随便连边。如果形成环，我们选择不加入这条边还是从环上删除一条边并加入这条边，对连通性和生成树中该种边权边的条数显然都没有影响。所以，上述结论成立。

有了这个结论，我们重新来审视这道题。我们要求最小生成树的个数。不妨仍然把相同权值的边看成阶段。根据乘法原理，我们要求的答案就是每个阶段连边的方案数之积。那么，我们先求一遍最小生成树。并得到一种方案。然后再次跑一遍kruskal，在每个阶段，将原先最小生成树中除了该阶段的边的其他边连进这张图，然后将图进行缩点（这个可以用并查集实现）然后在缩点后的新图上，加入这个阶段的所有边。此时求新图的生成树方案数，每一种方案都对应着原图中这个阶段的一种加边方案。采用矩阵树定理求生成树就可以了。
# 代码
```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>

using std::sort;
using std::swap;
using std::fabs;

const int P=31011;
const int maxn=(1e3+100)*2;
const double eps=1e-6;

bool used[maxn];

namespace MST
{
    int fa[maxn];
    int u[maxn],v[maxn],w[maxn],r[maxn],tot;
    long double K[maxn][maxn];
    inline int find(int u){return u==fa[u]?u:fa[u]=find(fa[u]);}
    inline void add(int _u,int _v,int _w){u[++tot]=_u,v[tot]=_v,w[tot]=_w;}
    struct cmp{bool operator() (const int a,const int b){return w[a]<w[b];}};
    inline long double determinant(long double (*A)[maxn],int n)
    {
        for (int i=1,c=1,j;i<=n;++i)
        {
            for (j=c;j<=n && fabs(A[j][i])<eps;++j);
            if (j==n+1) continue;
            for (int k=1;k<=n;++k) swap(A[c][k],A[j][k]);
            for (int j=c+1;j<=n;++j)
                if (fabs(A[j][i])>eps)
                {
                    long double t=A[j][i]/A[c][i];
                    for (int k=i;k<=n;++k)
                        A[j][k]-=A[c][k]*t;
                }
            ++c;
        }
        long double ans=1;
        for (int i=1;i<=n;++i) ans*=A[i][i];
        return fabs(ans);//这里要取绝对值
    }
    inline void Kruskal(int n,int m)
    {
        for (int i=1;i<=n;++i) fa[i]=i;
        for (int i=1;i<=m;++i) r[i]=i;
        sort(r+1,r+m+1,cmp());
        for (int i=1;i<=m;++i)
        {
            int x=r[i];
            if (find(u[x])!=find(v[x]))
            {
                fa[find(u[x])]=find(v[x]);
                used[x]=true;
            }
        }
    }
    int index[maxn];
    inline void Add_edge(int idx)
    {
        int x=index[find(u[idx])],y=index[find(v[idx])];
        ++K[x][x];++K[y][y];
        --K[x][y];--K[y][x];
    }
    inline void merge(int idx)
    {
        if (find(u[idx])!=find(v[idx]))
            fa[find(u[idx])]=find(v[idx]);
    }
    inline int Build_Graph(int n,int m,int L,int R)
    {
        int tot=0;
        for (int i=1;i<=n;++i)
            for (int j=1;j<=n;++j)
                K[i][j]=0;
        for (int i=1;i<=n;++i) fa[i]=i;
        for (int i=1;i<=m;++i)
            if (used[r[i]] && (i<L || i>R)) merge(r[i]);
        memset(index,0,sizeof(index));
        for (int i=1;i<=n;++i) if (!index[find(i)]) index[find(i)]=++tot;
        for (int i=L;i<=R;++i) Add_edge(r[i]);
        return tot;
    }
    inline int Kruskal_cal(int n,int m)
    {
        int ans=1;
        for (int L=1,R=1;R<=m;L=R)
        {
            bool ok=false;
            while (w[r[L]]==w[r[R]] && R<=m)
                if (used[r[R++]]) ok=true;
            if (!ok) continue;
            int tot=Build_Graph(n,m,L,R-1);
            ans=((long long)ans*(int)std::round(determinant(K,tot-1)))%P;
        }
        return ans;
    }
} // Kruskal

int main()
{
    // freopen("1016/1.in","r",stdin);
    int n,m;
    scanf("%d%d",&n,&m);
    for (int i=1,u,v,w;i<=m;++i)
        scanf("%d%d%d",&u,&v,&w),MST::add(u,v,w);
    MST::Kruskal(n,m);
    printf("%d",MST::Kruskal_cal(n,m));
}
```

---

## 作者：PPXppx (赞：2)

### 一张图的所有最小生成树权值相等的边的个数一定相同

---
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,cnt,tot,sum,ans;
int father[1010];
const int mod=31011;  

struct Edge{
    int from,to,dis;
}edge[1010];    //结构体：from,to是边的两端点，dis权值

struct E{
    int left,right,choose;
}bian[1010];    //left,right权值相等的边的左右编号，
//choose在最小生成树中的个数

bool cmp(Edge a,Edge b){
    return a.dis<b.dis;
}    

int find(int x){
    return x==father[x]?x:find(father[x]);
}     //并查集
     //很奇怪不能路径压缩优化，
    //哪位大佬讲一下为什么！！！

void dfs(int x,int now,int k)//核心
{
     if(now==bian[x].right+1){
         if(k==bian[x].choose) sum++;
         return;
     }
     int xx=find(edge[now].from);
     int yy=find(edge[now].to);
     if(xx!=yy){
         father[xx]=yy;
         dfs(x,now+1,k+1);
         father[xx]=xx;
         father[yy]=yy;
     }
     dfs(x,now+1,k);
}    

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
      father[i]=i;
    for(int i=1;i<=m;i++)
  scanf("%d%d%d",&edge[i].from,&edge[i].to,&edge[i].dis);
    sort(edge+1,edge+1+m,cmp);  //按边的权值排序
    tot=0;
    for(int i=1;i<=m;i++){
      if(edge[i].dis!=edge[i-1].dis){ //边的权值不相等 
            cnt++;   //边的权值一共有cnt种
            bian[cnt].left=i;
            bian[cnt-1].right=i-1;
      }	
        int xx=find(edge[i].from);
        int yy=find(edge[i].to);
        if(xx!=yy){
            father[xx]=yy;
            bian[cnt].choose++;
            tot++;
        }
    }
    if(tot!=n-1){
        printf("0");
        return 0;
    } //特判无法构成最小生成树
    bian[cnt].right=m;
    ans=1;
    for(int i=1;i<=n;i++)
      father[i]=i;
    for(int i=1;i<=cnt;i++)
    {
        sum=0;
        dfs(i,bian[i].left,0);
        ans=(ans*sum)%mod;
        for(int j=bian[i].left;j<=bian[i].right;j++)
        {
            int xx=find(edge[j].from);
            int yy=find(edge[j].to);
            if(xx!=yy) father[xx]=yy;
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：crashed (赞：1)

# 方法
最小生成树上有一个重要的性质：   
$$
\begin{aligned}
&w_e: e\text{的权}\\
&\text{Tree}(G): G\text{的生成树集合}\\
&f(T,w)\triangleq \sum_{e\in T}[w_e=w]\\
\Rightarrow& \forall T_1,T_2\in \text{Tree}(G),\forall w, f(T_1,w)=f(T_2,w)
\end{aligned}
$$   
   
~~翻译成人话~~就是，同一个图上任意两棵最小生成树，指定任意权值，**两棵树上边权等于这个权值的边的数量都是相等的**。  
   
道理非常简单。对于一条非树边，它一定对应了树上的一条链，**这条链上最大边权一定小于等于这条边的权**。如果相等，我们可以替换，得到一棵新的最小生成树。     
   
然后我们就只需要考虑相同权值的边的情况，最终答案就是所有权值的方案数的积。   
    
按照权值从小到大。取出当前权值的所有边，得到边集$E'$。假如我们将连通块缩成点，得到新点集$V'$。定义新图$G'=(V',E')$，那么我们**能且仅能在保证不连成环的情况下取尽可能多的边**。可以保证这样取出来一定会得到一棵最小生成树（因为这就是 Kruskal 的过程）。计算这样取的方案数我们就得到了当前阶段的方案数。   
   
然后我们加入$E'$中的所有边并缩点，进入下一阶段计算。   
   
当相同权值的边的数量较小时，我们可以直接枚举计算（比如），否则需要用 Matrix-Tree 计算。   
# 例题
[[JSOI2008]最小生成树计数](https://www.luogu.com.cn/problem/P4208)，相同权值的边比较少，所以直接枚举计算每个阶段的贡献。   
  
代码见下：   
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

const int mod = 31011;
const int MAXN = 105, MAXE = 1005;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

struct edge
{
	int u, v, w;
	edge() { u = v = w = 0; }
	edge( const int U, const int V, const int W ) { u = U, v = V, w = W; }
	bool operator < ( const edge & b ) const { return w < b.w; }
}E[MAXE];

struct dsu
{
	int fa[MAXN] = {}, s;
	dsu() { s = 0, memset( fa, 0, sizeof fa ); }
	dsu( const int n ) { s = n; for( int i = 1 ; i <= s ; i ++ ) fa[i] = i; }
	dsu( const dsu &t ) { s = t.s; for( int i = 1 ; i <= s ; i ++ ) fa[i] = t.fa[i]; }
	int findSet( const int u ) { return fa[u] = ( fa[u] == u ? u : findSet( fa[u] ) ); }
	bool unionSet( int u, int v ) { u = findSet( u ), v = findSet( v ); fa[u] = v; return u ^ v; }
}cur;

int N, M;

int main()
{
	read( N ), read( M );
	for( int i = 1 ; i <= M ; i ++ )
		read( E[i].u ), read( E[i].v ), read( E[i].w );
	std :: sort( E + 1, E + 1 + M );
	cur = dsu( N ); int ans = 1;
	for( int l = 1, r ; l <= M ; )
	{
		for( r = l ; r <= M && E[r].w == E[l].w ; r ++ );
		int siz = r - l, cnt = 0, tot, mx = 0;
		for( int S = 0 ; S < 1 << siz ; S ++ )
		{
			dsu tmp( cur ); tot = 0;
			for( int i = 0 ; i < siz ; i ++ )
				if( S & ( 1 << i ) )
				{
					if( ! tmp.unionSet( E[i + l].u, E[i + l].v ) ) { tot = -1; break; }
					tot ++;
				}
			if( tot > mx ) mx = tot, cnt = 1;
			else if( tot == mx ) cnt ++;
		}
		ans = 1ll * ans * cnt % mod;
		for( ; l < r ; l ++ ) cur.unionSet( E[l].u, E[l].v );
	}
	int cnt = 0;
	for( int i = 1 ; i <= N ; i ++ ) cnt += cur.fa[i] == i;
	if( cnt > 1 ) puts( "0" );
	else write( ans ), putchar( '\n' );
	return 0;
}
```

---

## 作者：水库中的水库 (赞：0)

## 定理

首先引入几个定理

- 对于两个不同的最小生成树$A,B$(这里的不同指严格意义下的边不同)，当且仅当对于长度为$w$的边，$A,B$所拥有的个数相等
- 只连接长度$\leq w$的边，$A,B$连通性相同

证明略

## 思路

根据这几个定理，可以得到一个简单的思路

- 将边长$w_i$离散化，因为对于最小生成树来说只需考虑大小关系

- 求出最小生成树$A$，记录长度$w_i$的边使用的次数$cnt[w_i]$
- 考虑Kruscal算法的过程，我们每次加边来联通两个联通块，所以假设当前考虑到长度为$w$的边，我们直接用暴搜考虑加边的方案数
- 乘法原理计数

```cpp
/***************************************************************
    File name: I.cpp
    Author: ljfcnyali
    Create time: 2019年05月24日 星期五 08时38分49秒
***************************************************************/
#include<bits/stdc++.h>

using namespace std;

#define REP(i, a, b) for ( int i = (a), _end_ = (b); i <= _end_; ++ i ) 
#define mem(a) memset ( (a), 0, sizeof ( a ) ) 
#define str(a) strlen ( a ) 

const int maxn = 2010;
const int INF = 0x3f3f3f3f;
const int Mod = 31011;

struct node
{
    int u, v, w;
} a[maxn];

int n, m, f[maxn], cnt[maxn], sum, ans, W;

inline int cha(int x)
{
    return f[x] == x ? x : cha(f[x]);
}

inline int cmp(node x, node y)
{
    return x.w < y.w;
}

inline void Kruscal()
{
    ans = sum = 0;
    REP(i, 1, m)
    {
        int fx = cha(a[i].u), fy = cha(a[i].v);
        if ( fx != fy ) 
        {
            f[fx] = fy; cnt[a[i].w] ++; ++ sum;
//			printf("%d %d %d\n", a[i].u, a[i].v, a[i].w);
        }
        if ( sum == n - 1 ) { ans = 1; return ; }
    }
}

inline int dfs(int x, int w, int s)
{
    if ( s == cnt[w] ) return 1;	
    if ( a[x].w != w ) return 0;
    int fx = cha(a[x].u), fy = cha(a[x].v), sum = 0;
    if ( fx != fy ) { f[fx] = fy; sum = dfs(x + 1, w, s + 1); f[fx] = fx; }
    return sum + dfs(x + 1, w, s);
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif
    while ( ~scanf("%d%d", &n, &m) )
    {
        mem(a); mem(cnt); W = 1; REP(i, 1, n) f[i] = i;
        REP(i, 1, m) scanf("%d%d%d", &a[i].u, &a[i].v, &a[i].w);
        sort ( a + 1, a + m + 1, cmp ); a[m + 1].w = INF;
        REP(i, 1, m)
        {
            if ( a[i].w != a[i + 1].w ) a[i].w = W ++;
            else a[i].w = W;
        }
        Kruscal();
        if ( ans == 0 ) { printf("0\n"); continue ; }
        REP(i, 1, n) f[i] = i;
        REP(i, 1, m)
        {
            if ( !cnt[a[i].w] || a[i - 1].w == a[i].w ) continue ;
            sum = dfs(i, a[i].w, 0);
            ans = (ans * sum) % Mod;
            for ( int j = i; j; ++ j )
            {
                if ( a[j].w != a[i].w ) break ;
                int fx = cha(a[j].u), fy = cha(a[j].v);
                if ( fx != fy ) f[fx] = fy;
            }
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

---


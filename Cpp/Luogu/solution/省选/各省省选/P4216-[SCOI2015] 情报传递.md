# [SCOI2015] 情报传递

## 题目描述

奈特公司是一个巨大的情报公司，它有着庞大的情报网络。情报网络中共有 $n$ 名情报员。每名情报员可能有若干名 (可能没有) 下线，除 $1$ 名大头目外其余 $n-1$ 名情报员有且仅有 $1$ 名上线。奈特公司纪律森严，每名情报员只能与自己的上、下线联系，同时，情报网络中任意两名情报员一定能够通过情报网络传递情报。

奈特公司每天会派发以下两种任务中的一个任务：

1. 搜集情报：指派 $T$ 号情报员搜集情报；
2. 传递情报：将一条情报从 $X$ 号情报员传递给 $Y$ 号情报员。

情报员最初处于潜伏阶段，他们是相对安全的，我们认为此时所有情报员的危险值为 $0$；一旦某个情报员开始搜集情报，他的危险值就会持续增加，每天增加 $1$ 点危险值 (开始搜集情报的当天危险值仍为 $0$，第 $2$ 天危险值为 $1$，第 $3$ 天危险值为 $2$，以此类推)。传递情报并不会使情报员的危险值增加。

为了保证传递情报的过程相对安全，每条情报都有一个风险控制值 $C$。奈特公司认为，参与传递这条情报的所有情报员中，危险值大于 $C$ 的情报员将对该条情报构成威胁。现在，奈特公司希望知道，对于每个传递情报任务，参与传递的情报员有多少个，其中对该条情报构成威胁的情报员有多少个。

## 说明/提示

样例解释：

对于 $3$ 个传递情报任务，都是经过 $5$ 名情报员，分别是 $4$ 号、$2$ 号、$1$ 号、$3$ 号和 $7$ 号。

- 第 $1$ 个任务，所有情报员 (危险值为 $0$) 都不对情报构成威胁；
- 第 $2$ 个任务，有 $2$ 名情报员对情报构成威胁，分别是 $1$ 号情报员 (危险值为 $3$) 和 $4$ 号情报员 (危险值为 $2$)，$7$ 号情报员 (危险值为 $1$) 并不构成威胁；
- 第 $3$ 个任务，只有 $1$ 名情报员对情报构成威胁。

数据范围：

$n\leqslant 2\times 10^5,Q\leqslant 2\times 10^5,0<P_i,C_i\leqslant N,1\leqslant T_i,X_i,Y_i\leqslant n$。

## 样例 #1

### 输入

```
7
0 1 1 2 2 3 3 
6
1 4 7 0
2 1
2 4
2 7
1 4 7 1
1 4 7 3```

### 输出

```
5 0
5 2
5 1```

# 题解

## 作者：Prean (赞：57)

这是一种题解没有的 $ O(m\log n) $ 做法。

首先第一步转化。设这是第 $ x $ 个任务，若 $ opt $ 为 $ 1 $，危险值大于 $ c $ 的只有可能在第 $ x-c-1 $ 个任务以前出现。

于是题目就变成了在某一时刻单点加和在某一时刻链上查询，离线即可去掉“某一时刻”。

单点加和链上查询，大家用的应该都是树剖，复杂度是 $ O(\log^2n) $ 的。然而使用 DFS 序和差分，将单点加转化为子树加，将链上查询转化为单点查询。

具体来说就是设一个 $ s[u] $ 表示节点 $ u $ 到根节点有多少个节点是危险的，那么单点加就可以变成子树加，在 DFS 序上就是区间加。

链上查询只需要查询 $ u,v,LCA(u,v),f[LCA(u,v)] $，也就是单点查。

区间加单点查，树状数组上！

极短的代码：
```cpp
#include<cstdio>
#include<vector>
const int M=2e5+5;
int n,m,dfc,d[M],f[M],dfn[M],siz[M],son[M],top[M];
int BIT[M];int opt[M],x[M],y[M],ans[M];
std::vector<int>G[M],id[M];
void DFS1(int u){
	dfn[u]=++dfc;d[u]=d[f[u]]+1;siz[u]=1;
	for(int&v:G[u]){
		DFS1(v);siz[u]+=siz[v];
		if(siz[v]>siz[son[u]])son[u]=v;
	}
}
void DFS2(int u,int tp){
	top[u]=tp;if(!son[u])return;DFS2(son[u],tp);
	for(int&v:G[u])if(v!=son[u])DFS2(v,v);
}
inline int LCA(int u,int v){
	while(top[u]^top[v]){
		if(d[top[u]]>d[top[v]])u=f[top[u]];
		else v=f[top[v]];
	}
	return d[u]>d[v]?v:u;
}
inline int dis(const int&u,const int&v){
	return d[u]+d[v]-(d[LCA(u,v)]<<1)+1;
}
inline void Add(int x,const int&val){
	for(;x<=n;x+=1<<__builtin_ctz(x))BIT[x]+=val;
}
inline int Query(int x){
	int ans=0;
	for(;x>=1;x-=1<<__builtin_ctz(x))ans+=BIT[x];
	return ans;
}
inline int Q(const int&x,const int&y){
	int lca=LCA(x,y);
	return Query(dfn[x])+Query(dfn[y])-Query(dfn[lca])-Query(dfn[f[lca]]);
}
signed main(){
	register int i,k;
	scanf("%d",&n);
	for(i=1;i<=n;++i)scanf("%d",f+i),G[f[i]].push_back(i);
	for(i=1;f[i];i=f[i]);
	DFS1(i);DFS2(i,i);
	scanf("%d",&m);
	for(i=1;i<=m;++i){
		scanf("%d",opt+i);
		if(opt[i]==1){
			scanf("%d%d%d",x+i,y+i,&k);
			if(k<i)id[i-k-1].push_back(i);
		}
		if(opt[i]==2){
			scanf("%d",x+i);
		}
	}
	for(i=1;i<=m;++i){
		if(opt[i]==2){
			Add(dfn[x[i]],1);Add(dfn[x[i]]+siz[x[i]],-1);
		}
		for(int&v:id[i])ans[v]=Q(x[v],y[v]);
		if(opt[i]==1){
			printf("%d %d\n",dis(x[i],y[i]),ans[i]);
		}
	}
}
```

---

## 作者：Ebola (赞：38)

一道送分题，作为数据结构爱好者，必须是一眼秒掉此题

将一个情报员开始搜集情报的时刻设为它的权值，对于一个始终没有搜集情报的人，权值设为Q

对于t时刻的询问，显然就是询问路径上比t-c小的值有多少个

询问区间中小于某个数的元素有多少个，显然就是主席树。因为是在树上的，所以我们直接建树上主席树，也就是每个节点继承父节点的信息，然后每次询问找出lca，做两遍询问，再特判一下lca即可

主席树修改要多带一个log，因此先将所有询问读取，得到所有点权，然后直接建树就行了

楼下那位是建的序列主席树，然后用树剖套主席树做的，我比他少一个log

```cpp
#include<bits/stdc++.h>
using namespace std;

namespace IO
{
    const int S=(1<<20)+5;
    char buf[S],*H,*T;
    inline char Get()
    {
        if(H==T) T=(H=buf)+fread(buf,1,S,stdin);
        if(H==T) return -1;return *H++;
    }
    inline int read()
    {
        int x=0;char c=Get();
        while(!isdigit(c)) c=Get();
        while(isdigit(c)) x=x*10+c-'0',c=Get();
        return x;
    }
    char obuf[S],*oS=obuf,*oT=oS+S-1,c,qu[55];int qr;
    inline void flush(){fwrite(obuf,1,oS-obuf,stdout);oS=obuf;}
    inline void putc(char x){*oS++ =x;if(oS==oT) flush();}
    template <class I>inline void print(I x)
    {
        if(!x) putc('0');
        while(x) qu[++qr]=x%10+'0',x/=10;
        while(qr) putc(qu[qr--]);
    }
}

using namespace IO;
const int N=200010;
struct Edge{int to,next;} e[N];
struct Query{int op,x,y,c;} q[N];
int h[N],esum=0,n,val[N],root,Q;
int fa[N],hson[N];
int top[N],sz[N],dep[N];
int rt[N],sum[N*20],tot=0;
int lc[N*20],rc[N*20];

void add_edge(int u,int v)
{
    e[++esum].to=v;
    e[esum].next=h[u];
    h[u]=esum;
}

void dfs1(int u)
{
    sz[u]=1;
    for(int t=h[u];t;t=e[t].next)
    {
        int v=e[t].to;
        dep[v]=dep[u]+1;
        dfs1(v);sz[u]+=sz[v];
        if(sz[v]>sz[hson[u]]) hson[u]=v;
    }
}

void dfs2(int u,int tp)
{
    top[u]=tp;
    if(hson[u]) dfs2(hson[u],tp);
    for(int t=h[u];t;t=e[t].next)
        if(e[t].to!=fa[u]&&e[t].to!=hson[u])
            dfs2(e[t].to,e[t].to);
}

int getlca(int x,int y)
{
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        x=fa[top[x]];
    }
    return dep[x]<dep[y]?x:y;
}

void insert(int &o,int p,int l,int r,int x)
{
    sum[o=++tot]=sum[p]+1;
    lc[o]=lc[p];rc[o]=rc[p];
    if(l==r) return;
    int mid=(l+r)/2;
    if(x<=mid) insert(lc[o],lc[p],l,mid,x);
    else insert(rc[o],rc[p],mid+1,r,x);
}

int query(int L,int R,int l,int r,int x)
{
    if(l==r) return sum[R]-sum[L];
    int mid=(l+r)/2;
    if(x<=mid) return query(lc[L],lc[R],l,mid,x);
    return sum[lc[R]]-sum[lc[L]]+query(rc[L],rc[R],mid+1,r,x);
}

void build(int u)
{
    insert(rt[u],rt[fa[u]],1,Q,val[u]);
    for(int t=h[u];t;t=e[t].next) build(e[t].to);
}

int main()
{
    n=read();
    for(int i=1;i<=n;i++)
    {
        fa[i]=read();
        if(!fa[i]) root=i;
        else add_edge(fa[i],i);
    }
    Q=read();
    for(int i=1;i<=n;i++) val[i]=Q;
    for(int i=1;i<=Q;i++)
    {
        q[i].op=read();q[i].x=read();
        if(q[i].op==2) val[q[i].x]=i;
        else q[i].y=read(),q[i].c=read();
    }
    dep[root]=1;dfs1(root);
    dfs2(root,root);
    build(root);
    for(int i=1;i<=Q;i++)
    {
        if(q[i].op==2) continue;
        int x=q[i].x,y=q[i].y,c=q[i].c,lca=getlca(x,y);
        print(dep[x]+dep[y]-2*dep[lca]+1);putc(' ');
        if(i-c-1<=0){putc('0');putc('\n');continue;}
        int ans=query(rt[lca],rt[x],1,Q,i-c-1);
        ans+=query(rt[lca],rt[y],1,Q,i-c-1);
        ans+=(val[lca]<i-c);
        print(ans);putc('\n');
    }
    flush();
    return 0;
}
```



---

## 作者：StudyingFather (赞：13)

首先让我们转换一下题意：

- 插入操作：给指定的点 $u$ 打上一个时间戳 $t_u$。
- 查询操作：给定当前时间 $t$，查询 $u$ 到 $v$ 的路径上有多少个有时间戳的点满足 $t-t_u \gt c$（或者说 $t-c \gt t_u$）。

这个东西当然能重链剖分后用主席树来做，然而复杂度 $O(n \log^3 n)$，虽然能做，但复杂度确实有点高了。

本题不要求强制在线，因此我们可以将所有查询操作按 $t-c$ 升序排序。

每次处理一个询问操作时，只需将所有满足 $t-c \gt t_u$ 的点 $u$ 打上标记即可。

最后要求的两个答案就是 $u$ 到 $v$ 路径上经过的点数和 $u$ 到 $v$ 路径上打标记的点数。

当然可以用线段树，但是在这种单点修改，求区间和的场合，用树状数组代码更简洁，常数也比线段树小。

~~然而我的代码好像也没比线段树的实现快，代码也没短多少~~

时间复杂度 $O(n \log^2 n)$。

```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;
typedef pair<int,int> pii;
vector<int> e[200005];
int dfn[200005],top[200005],dep[200005],son[200005],fa[200005],siz[200005];
int cnt,ans1[200005],ans2[200005];
struct BIT
{
 int tr[200005],n;
 void init(int N)
 {
  n=N;
 }
 int lowbit(int x)
 {
  return x&(-x);
 }
 void add(int x,int y)
 {
  while(x<=n)
  {
   tr[x]+=y;
   x+=lowbit(x);
  }
 }
 int query(int x)
 {
  int ans=0;
  while(x)
  {
   ans+=tr[x];
   x-=lowbit(x);
  }
  return ans;
 }
 int query_sum(int x,int y)
 {
  return query(y)-query(x-1);
 }
}tr1,tr2;
struct node
{
 int id,u,v,x;
 bool operator<(const node&a)const
 {
  return x<a.x;
 }
};
queue<pii> q;
vector<node> vec;
void dfs1(int u,int f)
{
 fa[u]=f;
 dep[u]=dep[f]+1;
 siz[u]=1;
 for(auto v:e[u])
 {
  dfs1(v,u);
  if(siz[v]>siz[son[u]])
   son[u]=v;
 }
}
void dfs2(int u,int t)
{
 dfn[u]=++cnt;
 top[u]=t;
 if(!son[u])return;
 dfs2(son[u],t);
 for(auto v:e[u])
  if(v!=son[u])dfs2(v,v);
}
void query_chain(int x,int y,int id)
{
 while(top[x]!=top[y])
 {
  if(dep[top[x]]>dep[top[y]])swap(x,y);
  ans1[id]+=tr1.query_sum(dfn[top[y]],dfn[y]);
  ans2[id]+=tr2.query_sum(dfn[top[y]],dfn[y]);
  y=fa[top[y]];
 }
 if(dep[x]>dep[y])swap(x,y);
 ans1[id]+=tr1.query_sum(dfn[x],dfn[y]);
 ans2[id]+=tr2.query_sum(dfn[x],dfn[y]);
}
int main()
{
 ios::sync_with_stdio(false);
 int n,root,Q;
 cin>>n;
 tr1.init(n),tr2.init(n);
 for(int i=1;i<=n;i++)
 {
  int pa;
  cin>>pa;
  if(pa)e[pa].push_back(i);
  else root=i;
  tr1.add(i,1);
 }
 dfs1(root,0);
 dfs2(root,root);
 cin>>Q;
 for(int i=1;i<=Q;i++)
 {
  int k;
  cin>>k;
  if(k==1)
  {
   int u,v,c;
   cin>>u>>v>>c;
   vec.push_back({i,u,v,i-c});
  }
  else
  {
   int x;
   cin>>x;
   q.push(make_pair(i,x));
  }
 }
 sort(vec.begin(),vec.end());
 for(auto p:vec)
 {
  int u=p.u,v=p.v,x=p.x,id=p.id;
  while(!q.empty())
  {
   int y=q.front().first,z=q.front().second;
   if(y<x)
   {
    q.pop();
    tr2.add(dfn[z],1);
   }
   else break;
  }
  query_chain(u,v,id);
 }
 for(int i=1;i<=Q;i++)
  if(ans1[i])cout<<ans1[i]<<' '<<ans2[i]<<endl;
 return 0;
}
```


---

## 作者：ix35 (赞：12)

## P4216 [SCOI2005]情报传递

看到题解区有很多写树剖套主席树的，代码难写也就算了，时间复杂度还是$O(n\log^3n)$的。

实际上这道题是一个普通树剖+线段树就能搞定的事情。

考虑以下询问$(x,y,c)$，实际上对于当前时刻$i$来说，危险值已经达到$c$的所有修改操作的完成时间$t$应该满足$t+c<i$（表示到$i$时危险值已经超过了$c$），所以对于这个查询来说需要考虑的修改操作只有那些时间不超过$i-c-1$的修改。

于是我们知道了影响每个询问操作的修改操作的范围。看到这个范围比较简单，而且题目可以离线，所以可以对这个范围排序。

也就是我们对所有询问按照如下规则排序：设询问的时间为$i$，危险参数为$c$，那么按照$i-c-1$从小到大排序。

接下去就很容易了，用一个指针扫描修改操作，若当前修改操作的时间$t$满足$t+c<i$（这里的$i,c$指当前询问中的参数），那么直接将这个修改做掉（树上对应位置点权增加1）。

接下来所有危险的修改已经做完了，就可以处理询问。这个没有任何难度，修改过的点权都已经增加，直接树剖查询$x,y$两点间路径上的点权和即可，这是树剖模板。

这里主要是利用了可以离线做的性质，一次修改不需要变成动态的，而是可以通过对询问的合理排序使得修改变成一次性的操作，从而省去了主席树查询等麻烦的处理手段，直接使用简单的树链剖分+线段树即可。

算法时间复杂度为$O(n\log^2 n)$。

P.S.代码看上去长只是个人码风问题

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=200010;
struct Mod {
	int p,t;
}md[MAXN];
struct Qu {
	int l,r,c,id;
}q[MAXN];
int n,m,rt,seg[MAXN],rev[MAXN],dep[MAXN],wsn[MAXN],siz[MAXN],top[MAXN],f[MAXN];
int eg,cnt,tot1,tot2,hd[MAXN],ver[2*MAXN],nx[2*MAXN],ans[2][MAXN],vis[MAXN];
int op,x,y,c,sum[MAXN*4];
bool cmp (Qu a,Qu b) {
	return a.c<b.c;
}
void add_edge (int x,int y) {
	ver[++eg]=y;
	nx[eg]=hd[x];
	hd[x]=eg;
	return;
}
void dfs1 (int x,int fa) {
	dep[x]=dep[fa]+1,siz[x]=1;
	for (int i=hd[x];i;i=nx[i]) {
		if (ver[i]!=fa) {
			dfs1(ver[i],x);
			siz[x]+=siz[ver[i]];
			if (siz[ver[i]]>siz[wsn[x]]) {
				wsn[x]=ver[i];
			}
		}
	}
	return;
}
void dfs2 (int x,int fa) {
	if (wsn[x]) {
		top[wsn[x]]=top[x];
		seg[wsn[x]]=++cnt;
		rev[cnt]=wsn[x];
		dfs2(wsn[x],x);
	}
	for (int i=hd[x];i;i=nx[i]) {
		if (ver[i]!=fa&&ver[i]!=wsn[x]) {
			top[ver[i]]=ver[i];
			seg[ver[i]]=++cnt;
			rev[cnt]=ver[i];
			dfs2(ver[i],x);
		}
	}
}
void push_up (int p) {
	sum[p]=sum[p*2]+sum[p*2+1];
	return;
}
void modifyt (int p,int l,int r,int x) {
	if (l==r) {sum[p]++;return;}
	int mid=(l+r)>>1;
	if (x<=mid) {modifyt(p*2,l,mid,x);}
	else {modifyt(p*2+1,mid+1,r,x);}
	push_up(p);
	return;
}
int sumt (int p,int l,int r,int xl,int xr) {
	if (xr<l||r<xl) {return 0;}
	if (xl<=l&&r<=xr) {return sum[p];}
	int mid=(l+r)>>1;
	return sumt(p*2,l,mid,xl,xr)+sumt(p*2+1,mid+1,r,xl,xr);
}
void modify (int pos) {
	if (!vis[pos]) {
		vis[pos]++;
		modifyt(1,1,n,seg[pos]);
	}
	return;
}
void query (int x,int y,int &u,int &v) {
	u=v=0;
	int fx=top[x],fy=top[y];
	while (fx!=fy) {
		if (dep[fx]<dep[fy]) {swap(fx,fy),swap(x,y);}
		v+=sumt(1,1,n,seg[fx],seg[x]);
		u+=dep[x]-dep[fx]+1;
		x=f[fx];
		fx=top[x];
	}
	if (dep[x]<dep[y]) {swap(x,y);}
	v+=sumt(1,1,n,seg[y],seg[x]);
	u+=dep[x]-dep[y]+1;
	return;
}
int main () {
	scanf("%d",&n);
	for (int i=1;i<=n;i++) {
		scanf("%d",&f[i]);
		if (f[i]) {add_edge(i,f[i]),add_edge(f[i],i);}
		else {rt=i;}
	}
	dfs1(rt,0);
	top[rt]=rt,seg[rt]=1,rev[1]=rt,cnt=1;
	dfs2(rt,0);
	scanf("%d",&m);
	for (int i=1;i<=m;i++) {
		scanf("%d",&op);
		if (op==1) {
			scanf("%d%d%d",&x,&y,&c);
			q[++tot1].l=x;
			q[tot1].r=y,q[tot1].c=i-c-1,q[tot1].id=tot1;
		} else {
			scanf("%d",&x);
			md[++tot2].p=x;
			md[tot2].t=i;
		}
	}
	sort(q+1,q+tot1+1,cmp);
	int cur=1;
	for (int i=1;i<=tot1;i++) {
		while (cur<=tot2&&md[cur].t<=q[i].c) {modify(md[cur].p);cur++;}
		int u,v;
		query(q[i].l,q[i].r,u,v);
		ans[0][q[i].id]=u,ans[1][q[i].id]=v;
	}
	for (int i=1;i<=tot1;i++) {
		printf("%d %d\n",ans[0][i],ans[1][i]);
	}
	return 0;
}
```


---

## 作者：asd_a (赞：7)

树剖加主席树即可，与楼下不一样，楼下直接线上处理有点难懂，我就讲一讲离线处理的吧。
分析题意：当前时间为$t0$,情报员$i$调查开始时间为$t_i$,风险控制值为$c$,则就是要求所有路径上满足$t0-t_i>c$的个数，$t_i$是在主席树里面的，$t0$与$c$可直接得知，可得=>$t0-c>t_i$=>$t0-c-1≥t_i$, 路径上就交给树剖；然后就转化成了区间求$t_i≤t0-c-1$即可。  
然而主席树不擅长修改，就只能离线建树，又有一个问题：在查询之后开始的怎么办？我们想一想，在查询之后开始的必有：$t_i≥t0$,$c≥0$ $∴t_i>t0-c-1$,所以不用担心。  
接下来的事情就是跑模板了  
献上代码，若有不足的地方望dalao评论区讨论：
```
#include<bits/stdc++.h>
#define N 200005
#define TR N<<5
using namespace std;
int n,m,G,KK[N],XX[N],YY[N],ZZ[N];
int fi[N],ne[N<<1],to[N<<1],seg[N],dad[N],son[N],top[N],rev[N],siz[N],dep[N],tot;
int a[N],root[N],t_cnt;
/*
邻接表存边，son为重儿子，top为重链顶，dep为深度，
siz为子树大小，seg为线段树中编号，rev[seg[x]]=x
*/
struct P_tree{
    int sum,ls,rs;
}t[TR];
inline void add(int x,int y){ne[++tot]=fi[x];to[tot]=y;fi[x]=tot;}
inline void ad(int x,int y){add(x,y);add(y,x);}
inline void dfs1(int x,int fa)
{
    dep[x]=dep[fa]+1;
    siz[x]=1;
    dad[x]=fa;
    for(int i=fi[x];i;i=ne[i])
    {
        int y=to[i];
        if(y!=fa)
        {
            dfs1(y,x);
            siz[x]+=siz[y];
            if(siz[y]>siz[son[x]])son[x]=y;
        }
    }
}
inline void dfs2(int x,int fa)
{
    if(son[x])
    {
        seg[son[x]]=++seg[0];
        top[son[x]]=top[x];
        rev[seg[0]]=son[x];
        dfs2(son[x],x);
    }
    for(int i=fi[x];i;i=ne[i])
    {
        int y=to[i];
        if(y!=fa && y!=son[x])
        {
            seg[y]=++seg[0];
            rev[seg[0]]=y;
            top[y]=y;
            dfs2(y,x);
        }
    }
}//树剖预处理
inline void build(int now1,int now2,int l,int r,int x)
{
    t[now2]=t[now1];
    t[now2].sum++;
    if(l==r) return ;
    int mid=(l+r)>>1;
    if(x<=mid)
    {
        t[now2].ls=++t_cnt;
        build(t[now1].ls,t[now2].ls,l,mid,x);
    }
    else
    {
        t[now2].rs=++t_cnt;
        build(t[now1].rs,t[now2].rs,mid+1,r,x);
    }
}//建树
inline int query(int now1,int now2,int l,int r,int x)
{
    if(x<=0) return 0;
    if(l==r) return t[now2].sum-t[now1].sum;
    int mid=(l+r)>>1,ls1=t[now1].ls,ls2=t[now2].ls;
    if(x<=mid) return query(ls1,ls2,l,mid,x);
    else return query(t[now1].rs,t[now2].rs,mid+1,r,x)+t[ls2].sum-t[ls1].sum;
}//查询
inline pair<int,int> askline(int x,int y,int c,int k)
{
    int fx=top[x],fy=top[y],anss=0,numm=0;
    while(fx!=fy)
    {
        if(dep[fx]<dep[fy]) swap(x,y),swap(fx,fy);
        anss+=query(root[seg[fx]-1],root[seg[x]],1,m,k-c-1);
        numm+=abs(dep[x]-dep[fx])+1;
        x=dad[fx],fx=top[x];
    }
    if(dep[x]>dep[y]) swap(x,y);
    anss+=query(root[seg[x]-1],root[seg[y]],1,m,k-c-1);
    numm+=abs(dep[y]-dep[x])+1;
    return make_pair(anss,numm);
}
int main()
{
    cin>>n;
    int x,y,z;
    for(int i=1;i<=n;i++)
    {
    	cin>>x;
    	if(x) ad(x,i);
    	else G=i;
    }
    dfs1(G,0);
    seg[0]=seg[G]=1;
    top[G]=rev[1]=G;
    dfs2(G,-1);
    cin>>m;
    for(int i=1;i<=m;i++)
    {
    	cin>>KK[i]>>XX[i];
    	if(KK[i]==1) cin>>YY[i]>>ZZ[i];
    	else a[XX[i]]=i;
    }//离线
    for(int i=1;i<=n;i++)
    {
    	root[i]=++t_cnt;
    	if(a[rev[i]]>0)
    		build(root[i-1],root[i],1,m,a[rev[i]]);
    	else
    		t[root[i]]=t[root[i-1]];//不搜集
    }
    pair<int,int> ansnum;
    for(int i=1;i<=m;i++)
    {
    	if(KK[i]==1)
    	{
    		ansnum=askline(XX[i],YY[i],ZZ[i],i);
    		cout<<ansnum.second<<" "<<ansnum.first<<endl;
    	}
    }
    return 0;
}
```

---

## 作者：ACalgorithm (赞：6)

		如何实现，各位dalao都讲解的十分好了，我就先着重讲一下怎么联想
    到这种解法的吧

------------

    	首先，我用的是树剖求lca加上树上主席树（相信做这道题的dalao们
    应该都会主席树吧）

------------
	
    	好，下面我们进入正题：
    首先，这道题要求我们求一下一条路径上，权值大于某个限制的点的个数，
    而且点的权值在某一个时刻后，将会不断增加，直接考虑怎么维护应该不是
    那么好做吧，那么换个思路：我们肯定是想要将权值固定对吧，不让他增加
    很好，我们试试。（参考系都学过吧，不要说你是XX小学的dalao...)，我
    们之前都假定了询问时的时间线为0，对吧，这时我们需要的是找出>=limit
    的数的个数，而且数还会增加，那么，我们假定，一个点的权值从开始起就
    不再增加，且就为其开始的时间，
    
  **那么，询问的时间线就会变成time-limit，**
    
    这个应该很容易理解，所以，我们的询问也就变成了，求权值<time-limit
    的数的个数了。至此，这个题就很简单了吧。
    	我们离线将所以人开始搜集情报的时间赋成他的权值，然后建立主席
    树，对于每一个询问，记下询问的时间点，就可以先赋完值，再处理询问
    了。

------------

	还是贴下代码吧，只是写的有点丑（应该也没什么需要注释的吧）。

------------

    #include<cstdio>
    #include<algorithm>
    #include<cstring>
    #define inf 0x3f3f3f3f
    using namespace std;
    int n,m,tot,head[200010],k,root[200010],val[200010],tim,cnt;
    struct node{
        int l,r,sum;
    } t[200010*40];
    struct qt{
        int s,t,lim,ti;
    } q[200010];
    struct hhd{
        int to,nt;
    } edge[400010];
    void add(int u,int v){
        edge[++k].nt=head[u];head[u]=k;edge[k].to=v;
    }
    int siz[200010],son[200010],f[200010],top[200010],d[200010];
    void insert(int id,int l,int r,int v){
        t[id].sum++;if(l==r) return ;
        int mid=(l+r)>>1;
        if(v>mid){//在右边 
            t[++tot]=t[t[id].r];t[id].r=tot;
            insert(tot,mid+1,r,v);
        } else {
            t[++tot]=t[t[id].l];t[id].l=tot;
            insert(tot,l,mid,v);
        }
    }
    void dfs_1(int u,int fa){
        siz[u]=1;d[u]=d[fa]+1;
        root[u]=++tot;t[tot]=t[root[fa]];
        insert(root[u],1,m,val[u]);
        for(int i=head[u];i;i=edge[i].nt){
            int v=edge[i].to;
            if(v==fa) continue;
            dfs_1(v,u);siz[u]+=siz[v];
            if(siz[v]>siz[son[u]]||!son[u]) son[u]=v;
        }
    }
    void dfs_2(int u,int tp){
        top[u]=tp;
        if(!son[u]) return ;
        dfs_2(son[u],tp);
        for(int i=head[u];i;i=edge[i].nt){
            int v=edge[i].to;
            if(v==f[u]||v==son[u]) continue;
            dfs_2(v,v);
        }
    }
    int _lca(int x,int y){
        while(top[x]!=top[y]){
            if(d[top[x]]<d[top[y]]) swap(x,y);
            x=f[top[x]];
        }
        return d[x]<d[y]?x:y;
    }
    int query(int id,int l,int r,int st,int to){
        if(!id) return 0;
        if(l>to||r<st) return 0;
        if(l>=st&&r<=to) return t[id].sum;
        int mid=(l+r)>>1;
        return query(t[id].l,l,mid,st,to)+query(t[id].r,mid+1,r,st,to);
    }
    int main(){
        scanf("%d",&n);memset(val,inf,sizeof(val));int fa;
        for(int i=1;i<=n;i++) scanf("%d",&fa),add(fa,i),f[i]=fa;
        scanf("%d",&m);
        int kind,a,b,c;
        for(int i=1;i<=m;i++){
            scanf("%d",&kind);
            if(kind==1){
                scanf("%d%d%d",&a,&b,&c);q[++cnt].s=a;q[cnt].t=b;q[cnt].lim=c;q[cnt].ti=i;
            } else {
                scanf("%d",&a);val[a]=min(val[a],i);
            }
        }
        dfs_1(1,0);dfs_2(1,1);
        for(int i=1;i<=cnt;i++){
            tim=q[i].ti-q[i].lim-1;
            int lca=_lca(q[i].s,q[i].t);
            int ans=query(root[q[i].s],1,m,1,tim)+query(root[q[i].t],1,m,1,tim)-query(root[lca],1,m,1,tim)-query(root[f[lca]],1,m,1,tim);
            printf("%d %d\n",d[q[i].s]+d[q[i].t]-d[lca]-d[f[lca]],ans);
        }
        return 0;
    } 

------------

    有什么不懂的可以问我

---

## 作者：_Diu_ (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P4216)

这一题已经有很多方法了，树剖等等更是数不胜数。

在此本蒟蒻提供一种别的题解暂时没有的方法：

## lca +主席树

时间复杂度大概是 $O(m\log m+n\log n)$，常数稍大。

~~提供给不喜欢树剖的同学们使用~~。

### 离线

先考虑题目的问题。

对于一个询问（假设在 $T$ 的时间提出），那么实质上是要统计 $\sum_{u\in line}[T-1-t_u\ge c]$。

其中 $t_u$ 表示节点 $u$ 开始收集情报的时间。

那么，移一下项就是 $t_u\le T-1-c$。

我们只需要查询链上满足条件的节点数即可。

### 建树

比较容易想到值域主席树。

第 $x$ 个节点所代表的主席树表示从根节点到该节点的 $t$ 组成的值域线段树。

每次正常查询值域以内的符合条件的个数即可。

值域 $t_u \in [1,q]$，`lca` 预处理是 $O(n\log n)$，每次跑主席树是 $O(\log q)$，总时间复杂度是 $O(n\log n+q\log q)$。

注意有可能有 $T-1-c\le 0$ 的情况，这样的话所有人都要算上，可能会爆值域。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10,M=1e7+10;
int n,q,a[N],t[N],rt[N],fa[N][20],dep[N],lg[N],boss,tot;
int op[N],x[N],y[N],c[N];
struct tree{
	int ls,rs,cnt;
}tr[M];
vector<int> g[N];
void build(int &o,int l,int r){
	o=++tot;
	if(l==r)return;
	int mid=l+r>>1;
	build(tr[o].ls,l,mid),build(tr[o].rs,mid+1,r);
}
void update(int &p,int o,int l,int r,int v){
	tr[p=++tot]=tr[o],tr[p].cnt++;
	if(l==r)return;
	int mid=l+r>>1;
	if(v<=mid)update(tr[p].ls,tr[o].ls,l,mid,v);
	else update(tr[p].rs,tr[o].rs,mid+1,r,v);
}
int query(int p,int o,int l,int r,int c){
//	printf("%lld %lld %lld %lld %lld\n",p,o,l,r,c);
	if(r<=c)return tr[p].cnt-tr[o].cnt;
	if(tr[p].cnt-tr[o].cnt==0)return 0;
	int mid=l+r>>1;
	if(c<=mid)return query(tr[p].ls,tr[o].ls,l,mid,c);
	return tr[tr[p].ls].cnt-tr[tr[o].ls].cnt+query(tr[p].rs,tr[o].rs,mid+1,r,c);
}
void dfs(int u){
	update(rt[u],rt[fa[u][0]],0,q,t[u]);
	for(int i=1;i<20;i++){
		fa[u][i]=fa[fa[u][i-1]][i-1];
		if(!fa[u][i])break;
	}
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i];
		if(v==fa[u][0])continue;
		dep[v]=dep[u]+1;
		dfs(v);
	}
}
void up(int &u,int d){
	for(int i=0;i<=lg[d];i++)if(d>>i&1)u=fa[u][i];
}
int lca(int u,int v){
	if(dep[u]<dep[v])swap(u,v);
	up(u,dep[u]-dep[v]);
	if(u==v)return u;
	for(int i=19;i>=0;i--){
		if(fa[u][i]^fa[v][i])u=fa[u][i],v=fa[v][i];
	}
	return fa[u][0];
}
signed main(){
	for(int i=2;i<N;i++)lg[i]=lg[i>>1]+1;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&fa[i][0]);
		if(!fa[i][0])boss=i;
		else g[fa[i][0]].push_back(i);
	}
	scanf("%d",&q);
	for(int i=1;i<=n;i++)t[i]=q;
	for(int i=1;i<=q;i++){
		scanf("%d",&op[i]);
		if(op[i]^2)scanf("%d%d%d",&x[i],&y[i],&c[i]);
		else scanf("%d",&x[i]),t[x[i]]=i;
	}
	build(rt[0],0,q);
	dfs(boss);
	for(int i=1;i<=q;i++){
		if(op[i]^1)continue;
		int w=lca(x[i],y[i]);
		printf("%lld ",dep[x[i]]+dep[y[i]]-2*dep[w]+1);
		if(i-c[i]<1)puts("0");
		else printf("%lld\n",query(rt[x[i]],rt[w],0,q,i-c[i]-1)+query(rt[y[i]],rt[fa[w][0]],0,q,i-c[i]-1));
	}
}
```

---

## 作者：YoungNeal (赞：5)

题解在博客[食用](https://www.cnblogs.com/YoungNeal/p/9169259.html)效果更佳哦~


## Solution

将收集情报看作染色操作，那么对于编号为 $idx$ 的询问，显然要求的是在 $idx-c-1$ 或更早这一条链上有多少点被染过色。

容易想到离线处理，按照 $idx-c-1$ 从小到大排序，并实时树上染色。

对于求两点距离，显然可以用两点深度之和再减去 $lca$ 的深度的二倍，求 $lca$ 可以在做第二问时顺便求出，所以我们返回一个 $pair$ 类型即可。

## Code

```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
#define N 200005
#define blank putchar(' ')
#define nxtline putchar('\n')
#define max(A,B) ((A)>(B)?(A):(B))
#define min(A,B) ((A)<(B)?(A):(B))
#define swap(A,B) ((A)^=(B)^=(A)^=(B))

int ques[N][5],q;
int n,m,cnt,pos,tot;
int sze[N],son[N],fa[N];
int sum[N<<2],ans[N],d[N];
int head[N],dfn[N],top[N];

struct Node{
    int x,y,z;
    int idx,ans1,ans2;
}node[N];

struct Edge{
    int to,nxt;
}edge[N];

void add(int x,int y){
    edge[++cnt].to=y;
    edge[cnt].nxt=head[x];
    head[x]=cnt;
}

bool cmp1(Node a,Node b){
    return a.idx-a.z<b.idx-b.z;
}

bool cmp2(Node a,Node b){
    return a.idx<b.idx;
}

int getint(){
    int x=0;char ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x;
}

void write(int x){
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

void first_dfs(int now){
    sze[now]=1;
    for(int i=head[now];i;i=edge[i].nxt){
        int to=edge[i].to;
        d[to]=d[now]+1;
        fa[to]=now;
        first_dfs(to);
        sze[now]+=sze[to];
        if(sze[to]>sze[son[now]])
            son[now]=to;
    }
}

void second_dfs(int now,int low){
    top[now]=low;
    dfn[now]=++tot;
    if(son[now])
        second_dfs(son[now],low);
    for(int i=head[now];i;i=edge[i].nxt){
        int to=edge[i].to;
        if(to==son[now])
            continue;
        second_dfs(to,to);
    }
}

void pushup(int cur){
    sum[cur]=sum[cur<<1]+sum[cur<<1|1];
}

void modify(int cur,int l,int r,int ql,int qr){
    if(l==r){
        sum[cur]=1;
        return;
    }
    int mid=l+r>>1;
    if(ql<=mid)
        modify(cur<<1,l,mid,ql,qr);
    else
        modify(cur<<1|1,mid+1,r,ql,qr);
    pushup(cur);
}

int query(int cur,int l,int r,int ql,int qr){
    if(ql<=l and r<=qr)
        return sum[cur];
    int mid=l+r>>1,ans=0;
    if(ql<=mid)
        ans+=query(cur<<1,l,mid,ql,qr);
    if(mid<qr)
        ans+=query(cur<<1|1,mid+1,r,ql,qr);
    return ans;
}

std::pair<int,int> ask(int x,int y){
    int ans=0;
    while(top[x]!=top[y]){
        if(d[top[x]]<d[top[y]])
            swap(x,y);
        ans+=query(1,1,n,dfn[top[x]],dfn[x]);
        x=fa[top[x]];
    }
    if(d[x]<d[y])
        swap(x,y);
    ans+=query(1,1,n,dfn[y],dfn[x]);
    return std::make_pair(y,ans);
}

signed main(){
    n=getint();int root;
    for(int i=1;i<=n;i++){
        int p=0;
        if((p=getint())==0)
            root=i;
        else
            add(p,i);
    }
    first_dfs(root);second_dfs(root,root);
    m=getint();
    for(int i=1;i<=m;i++){
        if(getint()==1){
            node[++pos].x=getint();
            node[pos].y=getint();
            node[pos].z=getint();
            node[pos].idx=i;
        } else{
            ques[++q][1]=getint();
            ques[q][2]=i;
        }
    }
    std::sort(node+1,node+1+pos,cmp1);
    int now=0;
    for(int i=1;i<=pos;i++){
        while(now<q and node[i].idx-node[i].z>ques[now+1][2]){
            now++;
            modify(1,1,n,dfn[ques[now][1]],dfn[ques[now][1]]);
        }
        std::pair<int,int> p=ask(node[i].x,node[i].y);
        node[i].ans1=d[node[i].x]+d[node[i].y]+1-2*d[p.first];
        node[i].ans2=p.second;
    }
    std::sort(node+1,node+1+pos,cmp2);
    for(int i=1;i<=pos;i++){
        write(node[i].ans1);blank;
        write(node[i].ans2);nxtline;
    }
    return 0;
}
```



---

## 作者：Owen_codeisking (赞：4)

怎么没人发 $O(n\log^3 n)$ 的暴力做法。。。

树剖 + 线段树 + $vector$ 上二分！

而且是在线做法，虽然没啥用。。。

因为插入已经保证升序，所以修改是 $\log$ 的。$SC$ 的数据水是出名的。。。常数根本跑不满，所以可以通过此题。。。

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
#define lson (rt<<1)
#define rson (rt<<1|1)
using namespace std;
const int maxn=200000+10;
int n,m,rt,head[maxn],to[maxn<<1],nxt[maxn<<1],tot;
int top[maxn],dep[maxn],son[maxn],fa[maxn],siz[maxn],id[maxn],mp[maxn],tim;
vector<int> v[maxn<<2];

inline int read(){
	register int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return (f==1)?x:-x;
}

void update(int x,int C,int l,int r,int rt){
	v[rt].push_back(C);
	if(l == r) return ;
	int mid=(l+r)>>1;
	if(x <= mid) update(x,C,l,mid,lson);
	else update(x,C,mid+1,r,rson);
}

int query(int L,int R,int C,int l,int r,int rt){
	if(L <= l && r <= R){
		vector<int>::iterator it=upper_bound(v[rt].begin(),v[rt].end(),C);
		return it-v[rt].begin();
	}
	int mid=(l+r)>>1,ans=0;
	if(L <= mid) ans+=query(L,R,C,l,mid,lson);
	if(R > mid) ans+=query(L,R,C,mid+1,r,rson);
	return ans;
}

inline void addedge(int x,int y){
	to[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}

void dfs1(int x,int f){
	siz[x]=1;fa[x]=f;dep[x]=dep[f]+1;
	int maxson=-1;
	for(int i=head[x],y;i;i=nxt[i]){
		y=to[i];
		if(y==f) continue;
		dfs1(y,x);siz[x]+=siz[y];
		if(siz[y]>maxson) maxson=siz[y],son[x]=y;
	}
}

void dfs2(int x,int topf){
	id[x]=++tim;mp[tim]=x;top[x]=topf;
	if(son[x]) dfs2(son[x],topf);
	for(int i=head[x],y;i;i=nxt[i]){
		y=to[i];
		if(y==fa[x]||y==son[x]) continue;
		dfs2(y,y);
	}
}

inline void ask(int x,int y,int z){
	int ans1=0,ans2=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		ans1+=id[x]-id[top[x]]+1;
		ans2+=query(id[top[x]],id[x],z,1,n,1);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	ans1+=id[y]-id[x]+1;
	ans2+=query(id[x],id[y],z,1,n,1);
	printf("%d %d\n",ans1,ans2);
}

int main()
{
	n=read();
	int op,x,y,z;
	for(int i=1;i<=n;i++){
		x=read();
		if(!x) rt=i;
		else addedge(x,i);
	}
	dfs1(rt,0);dfs2(rt,rt);
	m=read();
	for(int i=1;i<=m;i++){
		op=read(),x=read();
		if(op==1) y=read(),z=read(),ask(x,y,i-z-1);
		else update(id[x],i,1,n,1);
	}
	return 0;
}
```

---

## 作者：_Sein (赞：3)

不难发现，对于一个传递$i$，只有$i-C_i-1$之前的搜集才会对答案产生贡献。

根据这个条件，可以衍生两种算法。

较简单但复杂度较高的离线算法($O(n~log^2n)$):

对于传递$i$，以$i-C_i-1$进行排序，就可以线性推了，对于询问可用树链剖分进行处理。

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#define ll long long
#define gc getchar()
#define eps 1e-8
using namespace std;
const int N=2e5+5,mod=20170408;
template<class o>
inline void qr(o &x)
{
	x=0;char c=gc;int f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
template<class o>
void qw(o x)
{
	if(x<0)putchar('-'),x=-x;
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
struct Query
{
	int x,y,c,id;
	Query(int x=0,int y=0,int c=0,int id=0):x(x),y(y),c(c),id(id){}
	bool operator <(const Query a)const{return c<a.c;} 
}Q[N];
struct node
{
	int x,t;
	node(int x=0,int t=0):x(x),t(t){}
	bool operator <(const node a)const{return t<a.t;}
}P[N];
int fa[N],siz[N],son[N],dep[N],yss[N],top[N],cnt,dfn[N],c[N],n,ans[N],s[N];
inline void add(int x){for(;x<=n;x+=x&-x)++c[x];}
inline int ask(int x){int ans=0;for(;x;x-=x&-x)ans+=c[x];return ans;}
struct edge{int y,next;}a[N<<1];int len,last[N];
void ins(int x,int y){a[++len]=(edge){y,last[x]};last[x]=len;}
void dfs1(int x)
{
	siz[x]=1;son[x]=0;
	for(int k=last[x],y;k;k=a[k].next)
	{
		if((y=a[k].y)==fa[x])continue;
		fa[y]=x;dep[y]=dep[x]+1;
		dfs1(y);
		siz[x]+=siz[y];if(siz[son[x]]<siz[y])son[x]=y;
	}
}
void dfs2(int x,int tp)
{
	dfn[x]=++cnt;yss[cnt]=x;top[x]=tp;
	if(son[x])dfs2(son[x],tp);
	for(int k=last[x],y;k;k=a[k].next)
		if((y=a[k].y)!=fa[x]&&y!=son[x])dfs2(y,y);
}
void solve(int x,int y,int id)
{
	int tx=top[x],ty=top[y];ans[id]=0,s[id]=0;
	while(tx!=ty)
	{
		if(dep[tx]>dep[ty])
			s[id]+=dep[x]-dep[tx]+1,ans[id]+=ask(dfn[x])-ask(dfn[tx]-1),x=fa[tx],tx=top[x];
		else 
			s[id]+=dep[y]-dep[ty]+1,ans[id]+=ask(dfn[y])-ask(dfn[ty]-1),y=fa[ty],ty=top[y];
	}
	if(dep[x]<dep[y])swap(x,y);
	s[id]+=dep[x]-dep[y]+1,ans[id]+=ask(dfn[x])-ask(dfn[y]-1);
}
int main()
{
	qr(n);int rt=0;
	for(int i=1,x;i<=n;i++)
	{
		qr(x);
		if(!x)rt=i;
		else ins(x,i),ins(i,x); 
	}
	dfs1(rt);
	dfs2(rt,rt);
	int m;qr(m);
	int l1=0,l2=0;
	for(int i=1;i<=m;i++)
	{
		int op,x,y,w;qr(op),qr(x);
		if(op==1)qr(y),qr(w),++l1,Q[l1]=Query(x,y,i-w-1,l1);
		else P[++l2]=node(x,i);
	}
	sort(Q+1,Q+l1+1);sort(P+1,P+l2+1);
	for(int i=1,j=0;i<=l1;i++)
	{
		while(j+1<=l2&&P[j+1].t<=Q[i].c)++j,add(dfn[P[j].x]);
		solve(Q[i].x,Q[i].y,Q[i].id);
	}
	for(int i=1;i<=l1;i++)
		qw(s[i]),putchar(' '),qw(ans[i]),puts("");
	return 0;
}
```



较复杂但复杂度较低的在线算法($O(n~log~n)$):

利用类似树上差分，可以把询问拆成$s_x+s_y-s_{lca(x,y)}-s_{fa_{lca(x,y)}}$，其中$s_i$表示$i$点到根节点有多少个可以产生贡献的情报员。

根据$i-C_i-1$这个条件，不难联想到$s_{i}$可以存版本，就可以利用可持久化数组进行查询历史版本操作。

修改操作要修改一个区间，也就是以$i$为根的子树，对于可持久化数组，并不用多一个$log$，可以使用标记永久化。

另外有一个坑点，如果一个情报员执行多次收集任务，以第一次收集的时间为准，因此需要判断。

悄悄bb一句，树剖居然跑得更快($n,q\le 2e5$)。

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#define ll long long
#define gc getchar()
#define eps 1e-8
using namespace std;
const int N=2e5+5,mod=20170408;
template<class o>
inline void qr(o &x)
{
	x=0;char c=gc;int f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
template<class o>
void qw(o x)
{
	if(x<0)putchar('-'),x=-x;
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
int fa[N],siz[N],son[N],dep[N],yss[N],top[N],cnt,dfn[N],c[N],n;
struct edge{int y,next;}a[N<<1];int len,last[N];
void ins(int x,int y){a[++len]=(edge){y,last[x]};last[x]=len;}
void dfs1(int x)
{
	siz[x]=1;son[x]=0;
	for(int k=last[x],y;k;k=a[k].next)
	{
		if((y=a[k].y)==fa[x])continue;
		fa[y]=x;dep[y]=dep[x]+1;
		dfs1(y);
		siz[x]+=siz[y];if(siz[son[x]]<siz[y])son[x]=y;
	}
}
void dfs2(int x,int tp)
{
	dfn[x]=++cnt;yss[cnt]=x;top[x]=tp;
	if(son[x])dfs2(son[x],tp);
	for(int k=last[x],y;k;k=a[k].next)
		if((y=a[k].y)!=fa[x]&&y!=son[x])dfs2(y,y);
}
int lca(int x,int y)
{
	int tx=top[x],ty=top[y];
	while(tx!=ty)
	{
		if(dep[tx]>dep[ty])x=fa[tx],tx=top[x];
		else y=fa[ty],ty=top[y];
	}
	if(dep[x]<dep[y])swap(x,y);
	return y;
}
struct HGT{int l,r,s;}t[N<<5];int root[N],tmp,id[N];//标记永久化可持久化线段树 
bool vis[N];
void update(int l,int r,int &x,int y,int L,int R)
{
	t[x=++tmp]=t[y];
	if(L<=l&&R>=r){t[x].s++;return ;}
	int mid=l+r>>1;
	if(L<=mid)update(l,mid,t[x].l,t[y].l,L,R);
	if(R>mid)update(mid+1,r,t[x].r,t[y].r,L,R);
}
int query(int l,int r,int x,int pos)
{
	if(l==r)return t[x].s;
	int mid=l+r>>1,val=0;
	if(pos<=mid)val+=query(l,mid,t[x].l,pos);
	else val+=query(mid+1,r,t[x].r,pos);
	return val+t[x].s;
}
int calc(int t,int x)
{
	if(!id[t]||!dfn[x])return 0;
	return query(1,n,root[id[t]],dfn[x]);
}
int main()
{
	qr(n);int rt=0;
	for(int i=1,x;i<=n;i++)
	{
		qr(x);
		if(!x)rt=i;
		else ins(x,i),ins(i,x); 
	}
	dep[1]=1;dfs1(rt);
	dfs2(rt,rt);
	int m;qr(m);
	for(int i=1;i<=m;i++)
	{
		int op,x,y,c;qr(op);
		if(op==1)
		{
			qr(x),qr(y),qr(c);
			id[i]=id[i-1];int t=max(i-c-1,0);
			int f=lca(x,y),ans=calc(t,x)+calc(t,y)-calc(t,f)-calc(t,fa[f]);
			qw(dep[x]+dep[y]-dep[f]-dep[fa[f]]);putchar(' ');qw(ans);puts("");
		}
		else
		{
			qr(x);
			if(vis[x])continue;vis[x]=1;//只有第一次才算。 
			id[i]=id[i-1]+1;
			update(1,n,root[id[i]],root[id[i-1]],dfn[x],dfn[x]+siz[x]-1);
		}
	}
	return 0;
}
```



---

## 作者：Unnamed114514 (赞：3)

在线并且 $O(n\sqrt{n}\log n)$ 的若智做法，序列分块套值域分块。

问题的转化：对于一个人，若在 $a$ 时刻开始搜集，那么他在 $b$ 时刻的风险就是 $b-a$，令一个节点 $x$ 被叫去搜集资料的时间是 $t_x$，对于第 $i$ 次询问，问题就转化成了求 $(u,v)$ 链上 $i-t_m>C$ 的数量，移项得 $i-C-1\ge t_m$。

我们令 $\Delta=i-C-1$，对于树上的路径问题，考虑用树剖进行处理，那么接下来就是查询一个区间内 $t_m\le\Delta$ 的数量。

我们显然不可能对于每个区间，直接建出一个维护值域的数据结构，这样的空间复杂度是 $O(n^2)$ 的。

于是就想到**序列分块**，对于每个块，我们维护 $t_m\le\Delta$ 的数量，散块可以直接 $O(\sqrt{n})$ 的暴力。

根据树剖性质，一共有 $n\log n$ 个询问，每次询问都会查询 $O(\sqrt{n})$ 个区间，所以应该会有 $n\sqrt{n}\log n$ 个查询。但是每个人只会搜集一次，所以只有 $n$ 个插入。在这种查询和插入差距比较大的时候，就容易想到**值域分块**。

对于每个块，我们维护两个东西，一个是块的全局前缀和，一个是块内前缀和。

那么我们就可以做到 $O(\sqrt{n})$ 插入，$O(1)$ 查询了。

整体来看，时间复杂度是 $O(n\sqrt{n}\log n)$，空间复杂度是 $O(n\sqrt{n})$，因为比较卡空间，所以需要调整块长，代码中序列分块块长是 $800$，值域分块块长是 $400$。

[这就是代码](https://www.luogu.com.cn/record/122412038)

关于效率：拿题解区唯一一篇[在线的题解](https://www.luogu.com.cn/record/122403568)测了一下，打不过。

关于离线：好像把所有 $n\log n$ 个询问离线下来可以用主席树 $O(n\log^2n)$ 搞定？

关于时间：本地测了一下，在极限数据下（应该就是条链的时候），跑了不到 0.7s。

---

## 作者：Great_Influence (赞：3)

首先，可以知道，如果设当前时间为t，题目要求的是路径长度和$t-c-1$版本的树上权值之和。前者直接树链剖分，后者可以选择套用可持久化线段树维护历史版本。时间复杂度$O(q\log_2n)$，空间复杂度$q\log_2n$。

代码：

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
using namespace std;
template<typename T>inline void read(T &x)
{
	T s=0,f=1;char k=getchar();
	while(!isdigit(k)&&(k^'-'))k=getchar();
	if(!isdigit(k)){f=-1;k=getchar();}
	while(isdigit(k)){s=s*10+(k^48);k=getchar();}
	x=s*f;
}
void file()
{
	#ifndef ONLINE_JUDGE
		freopen("test.in","r",stdin);
		freopen("test.out","w",stdout);
	#endif
}
#define Chkmax(a,b) a=a>(b)?a:(b)
#define Chkmin(a,b) a=a<(b)?a:(b)
const int MAXN=2e5+7;
static struct edge
{
	int v,nxt;
}p[MAXN];
static int n,m,e,head[MAXN],dep[MAXN];
static int fa[MAXN],sz[MAXN],son[MAXN];
inline void add(int u,int v)
{p[++e].v=v;p[e].nxt=head[u];head[u]=e;}
void dfs(int u)
{
	sz[u]=1;dep[u]=dep[fa[u]]+1;
	for(register int v=head[u];v;v=p[v].nxt)
	{
		dfs(p[v].v);sz[u]+=sz[p[v].v];
		if(!son[u]||sz[p[v].v]>sz[son[u]])
			son[u]=p[v].v;
	}
}
static int top[MAXN],dfn[MAXN],ri[MAXN];
void dfs(int u,int tp)
{
	ri[dfn[u]=++e]=u;top[u]=tp;
	if(son[u])dfs(son[u],tp);
	else return;
	for(register int v=head[u];v;v=p[v].nxt)
		if(p[v].v^son[u])dfs(p[v].v,p[v].v);
}
static int root;
inline void init()
{
	read(n);
	Rep(i,1,n)
	{
		read(fa[i]);
		if(!fa[i])root=i;
		else add(fa[i],i);
	}
	dfs(root);e=0;dfs(root,root);
}
static int roots[MAXN];
static struct HJT
{
	int sz,l,r;
}s[MAXN*80];
void insert(int las,int &now,int l,int r,int pos)
{
	s[now=++e]=s[las];++s[now].sz;
	if(l==r)return;
	static int mid;mid=(l+r)>>1;
	if(pos<=mid)insert(s[las].l,s[now].l,l,mid,pos);
	else insert(s[las].r,s[now].r,mid+1,r,pos);
}
int query(int h,int l,int r,int x,int y)
{
	if(!s[h].sz||l>=x&&r<=y)return s[h].sz;
	int mid=(l+r)>>1,ans=0;
	if(x<=mid)ans=query(s[h].l,l,mid,x,y);
	if(y>mid)ans+=query(s[h].r,mid+1,r,x,y);
	return ans;
}
static int peo;
inline int quer(int rot,int u,int v)
{
	static int ans;peo=0;ans=0;
	while(top[u]^top[v])
	{
		if(dfn[top[u]]<dfn[top[v]])swap(u,v);
		ans+=query(rot,1,n,dfn[top[u]],dfn[u]);
		peo+=dfn[u]-dfn[top[u]]+1;
		u=fa[top[u]];
	}
	if(dfn[u]>dfn[v])swap(u,v);
	peo+=dfn[v]-dfn[u]+1;
	ans+=query(rot,1,n,dfn[u],dfn[v]);
	return ans;
}
inline void solve()
{
	read(m);e=0;
	static int opt,x,y,c,ans;
	Rep(i,1,m)
	{
		read(opt);read(x);
		if(opt==1)
		{
			read(y);read(c);roots[i]=roots[i-1];
			c=max(0,i-c-1);
			ans=quer(roots[c],x,y);
			printf("%d %d\n",peo,ans);
		}
		else insert(roots[i-1],roots[i],1,n,dfn[x]);
	}
}
int main()
{
	file();
	init();
	solve();
	return 0;
}

```

---

## 作者：一叶知秋。 (赞：2)

首先，简化题面：

对于每一天有两种操作：

1.（这里说的是第二问，第一位过于简单，不提做法）询问当前从 $X_i$ 到 $Y_i$ 的路径上有多少个点的值 $val$ 使得 $0 < val \le i-C_i-1$

2.让编号为 $T_i$ 的点的值 $val=i$

emmm，一开始看完题觉得是个树剖套主席树，然而不会写主席树，突然发现这道题可以离线，然后对于每个询问按照 $i-C_i-1$ 从小到大排序，每次询问完以后，将两次询问中间的加上，最后下一次询问时就直接算从 $X$ 到 $Y$ 有多少个点的值大于 $0$ 即可。

代码如下：

```cpp
#include<cstdio>
#include<algorithm>

using namespace std;

#define maxn 222222
#define lowbit(k) (k&(-k))

inline int read(){
	int r=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')r=(r<<1)+(r<<3)+(c^48),c=getchar();
	return r*f;
}

inline int max(int a,int b){
	return a>b?a:b;
}

inline void swap(int &a,int &b){
	int c=a;
	a=b;
	b=c;
}

struct E{
	int v,nxt;
	E() {}
	E(int v,int nxt):v(v),nxt(nxt) {}
}e[maxn];

struct Q{
	int u,v,c,num;
	bool operator <(const Q &q) const{
		return c<q.c;
	}
}q[maxn];

int n,qu,s_e,s_q,head[maxn],x[maxn],rev[maxn],c[maxn],t[maxn],s[maxn],ans[maxn];

inline void a_e(int u,int v){
	e[++s_e]=E(v,head[u]);
	head[u]=s_e;
}

inline void add(int k,int x){
	while(k<=n){
		c[k]+=x;
		k+=lowbit(k);
	}
}

inline int sum(int k){
	int Sum=0;
	while(k>0){
		Sum+=c[k];
		k-=lowbit(k);
	}
	return Sum;
}

struct Tree_Chain{//日常树剖，2个dfs一样

	int s_tr,fa[maxn],dep[maxn],son[maxn],seg[maxn],top[maxn],size[maxn];

	inline void scan(){
		read();//前面有一个0，先读掉
		for(int i=2;i<=n;i++){
			int u=read();
			a_e(u,i);
		}
	}

	void dfs_1(int u){
		size[u]=1;
		dep[u]=dep[fa[u]]+1;
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].v;
			if(v==fa[u])continue;
			fa[v]=u;
			dfs_1(v);
			if(size[v]>size[son[u]])son[u]=v;
			size[u]+=size[v];
		}
	}

	void dfs_2(int u,int t){
		top[u]=t;
		seg[u]=++s_tr;
		rev[s_tr]=u;
		if(son[u])dfs_2(son[u],t);
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].v;
			if(top[v])continue;
			dfs_2(v,v);
		}
	}

	inline void init(){
		scan();
		dfs_1(1);
		dfs_2(1,1);
	}

	inline void update(int u){//简单的update
		if(!u)return;
		add(seg[u],1);
	}

	inline void ask(int u,int v,int num){
		int fu=top[u],fv=top[v];
		while(fu!=fv){
			if(dep[fu]<dep[fv])swap(u,v),swap(fu,fv);
			s[num]+=seg[u]-seg[fu]+1;//s记录有多少个点
			ans[num]+=sum(seg[u])-sum(seg[fu]-1);//ans记录有多少个点的值大于0
			u=fa[fu],fu=top[u];
		}
		if(dep[u]>dep[v])swap(u,v);
		s[num]+=seg[v]-seg[u]+1;
		ans[num]+=sum(seg[v])-sum(seg[u]-1);
	}

}t_c;

int main(){
	n=read();
	t_c.init();
	qu=read();
	for(int i=1;i<=qu;i++){
	   	int opt=read();
	   	if(opt&1){
	   		s_q++;
	   		q[s_q].u=read(),q[s_q].v=read();
	   		q[s_q].c=i-read()-1;
	   		q[s_q].num=s_q;
	   	}
	   	else t[i]=read();
	}
	sort(q+1,q+1+s_q);
	for(int i=0;i<s_q;i++){//从0开始，正好加上最小的询问前的
		t_c.ask(q[i].u,q[i].v,q[i].num);
		int j=q[i].c+1;
		while(j<=q[i+1].c)
			t_c.update(t[j++]);
	}
	t_c.ask(q[s_q].u,q[s_q].v,q[s_q].num);//最大的询问后面的没必要加
	for(int i=1;i<=s_q;i++)
		printf("%d %d\n",s[i],ans[i]);
	return 0;
}
```

---

## 作者：huangwenlong (赞：2)

~~[首先宣传下自己的blog](http://ssttkkl.top/posts/ShengXuan/2018/03/%E3%80%90SCOI2015%E3%80%91%E6%83%85%E6%8A%A5%E4%BC%A0%E9%80%92/)~~

-----

树上的路径查询问题，显然要用到树剖。

我们可以把每个人开始去搜集情报的时间记录下来，第$i$个人记为$S_i$。那么当前时间为$T$时，第$i$个人的风险值就是$T-S_i$。于是查询时只需要查路径上有多少个开始时间严格小于$T-C$的节点。可以用树剖+树状数组套平衡树，或者树剖+线段树套平衡树实现。

总的时间复杂度为$O(n\log^3 n)$，怎么看都应该过不了$2 \times 10^5$级别的数据的。但是人要有希望，怎么也要提交一发。然后就过了……没吸氧懒得写快读，最慢的点也才1404ms，这数据也太水了。

```cpp
#include <iostream>
#define maxn 200005
using namespace std;

// 下面是Treap
struct node *nil;
struct node
{
    node *ch[2];
    int val, cnt, siz, prio;
    node(int v) : val(v), cnt(1), siz(1), prio(rand()) { ch[0] = ch[1] = nil; }
    void pullup() { siz = cnt + ch[0]->siz + ch[1]->siz; }
    int cmp(int k) { return k < val ? 0 : 1; }
};
void init()
{
    nil = new node(0);
    nil->ch[0] = nil->ch[1] = nil;
    nil->cnt = nil->siz = 0;
    nil->prio = 0x7fffffff;
}
void rotate(node *&t, int d)
{
    node *k = t->ch[d ^ 1];
    t->ch[d ^ 1] = k->ch[d];
    k->ch[d] = t;
    t->pullup(), k->pullup();
    t = k;
}
void insert(int v, node *&t)
{
    if (t == nil)
        t = new node(v);
    else if (t->val == v)
        t->cnt++;
    else
    {
        int d = t->cmp(v);
        insert(v, t->ch[d]);
        if (t->prio > t->ch[d]->prio)
            rotate(t, d ^ 1);
    }
    t->pullup();
}
int cntless(int v, node *&t)
{
    if (t == nil)
        return 0;
    else if (v == t->val)
        return t->ch[0]->siz;
    else if (v < t->val)
        return cntless(v, t->ch[0]);
    else
        return cntless(v, t->ch[1]) + t->ch[0]->siz + t->cnt;
}

// 下面是树剖
struct edge
{
    int next, to;
} edges[maxn * 2];
int head[maxn], ecnt;
void addedge(int u, int v)
{
    ecnt++;
    edges[ecnt].to = v;
    edges[ecnt].next = head[u];
    head[u] = ecnt;
}
int n, q;
int fa[maxn], siz[maxn], dep[maxn], hvy[maxn];
void dfs1(int v, int f, int d)
{
    fa[v] = f, dep[v] = d, siz[v] = 1, hvy[v] = -1;
    for (int i = head[v]; i; i = edges[i].next)
    {
        int w = edges[i].to;
        if (w != f)
        {
            dfs1(w, v, d + 1);
            siz[v] += siz[w];
            if (hvy[v] == -1 || siz[hvy[v]] < siz[w])
                hvy[v] = w;
        }
    }
}
int dfn[maxn], top[maxn], timer;
void dfs2(int v, int tp)
{
    dfn[v] = ++timer, top[v] = tp;
    if (hvy[v] != -1)
    {
        dfs2(hvy[v], tp);
        for (int i = head[v]; i; i = edges[i].next)
        {
            int w = edges[i].to;
            if (w != fa[v] && w != hvy[v])
                dfs2(w, w);
        }
    }
}

// 下面是树状数组
node *c1[maxn];
int sum(int x, int c)
{
    int ans = 0;
    for (int i = x; i >= 1; i -= (i & -i))
        ans += cntless(c, c1[i]);
    return ans;
}
void inc(int x, int c)
{
    for (int i = x; i <= n + 1; i += (i & -i))
        insert(c, c1[i]);
}

void query(int v, int w, int c)
{
    int siz = 0, ans = 0;
    while (top[v] != top[w])
    {
        if (dep[top[v]] > dep[top[w]])
            swap(v, w);
        ans += sum(dfn[w], c) - sum(dfn[top[w]] - 1, c);
        siz += dfn[w] - dfn[top[w]] + 1;
        w = fa[top[w]];
    }
    if (dep[v] > dep[w])
        swap(v, w);
    ans += sum(dfn[w], c) - sum(dfn[v] - 1, c);
    siz += dfn[w] - dfn[v] + 1;
    cout << siz << ' ' << ans << endl;
}

int main()
{
    ios::sync_with_stdio(false);
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        int j;
        cin >> j;
        addedge(i, j);
        addedge(j, i);
    }

    dfs1(0, -1, 1);
    dfs2(0, 0);
    init();
    for (int i = 0; i < maxn; i++)
        c1[i] = nil;

    cin >> q;
    for (int t = 1; t <= q; t++)
    {
        int opt, x, y, c;
        cin >> opt;
        if (opt == 1)
        {
            cin >> x >> y >> c;
            query(x, y, t - c);
        }
        else
        {
            cin >> c;
            inc(dfn[c], t);
        }
    }
    return 0;
}

```



---

## 作者：rainygame (赞：1)

发现题解区没有在线做法，这里给出一种简单的在线做法。

令当前在 $t$ 时刻，限制为 $c$，第 $i$ 个人的危险值为 $s_i$。

则需要满足：

$$
\begin{aligned}
t-s_i>c\\
-s_i>c-t\\
s_i<t-c\\
\end{aligned}
$$

然后就是树链剖分，然后维护链信息即可。

需要支持维护单点修改，区间查小于某值的的数个数。这个可以用分块搞。当然可以块内排序，但是也可以用树状数组维护。

对于每个块，维护一个权值树状数组，然后对于整块直接查询，零散块暴力即可。

注意空间，块长为 $1000$ 较为合适。

修改复杂度 $O(\log n)$，查询复杂度 $O(\sqrt n\log^2 n)$，但是数据比较水，就可以过去。

总复杂度 $O(n\sqrt n \log^2 n)$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 200001
#define MAXM 210

int n, q, opt, u, v, c, cnt, now;
int id[MAXN];
int dep[MAXN], top[MAXN], son[MAXN], fa[MAXN], siz[MAXN];
vector<int> e[MAXN];

void dfs1(int x){
    siz[x] = 1;
    dep[x] = dep[fa[x]] + 1;
    for (auto i: e[x]){
        if (i ^ fa[x]){
            dfs1(i);
            siz[x] += siz[i];
            if (siz[son[x]] < siz[i]) son[x] = i;
        }
    }
}

void dfs2(int x, int tp){
    top[x] = tp;
    id[x] = ++cnt;
    if (son[x]) dfs2(son[x], tp);
    for (auto i: e[x]){
        if (i != fa[x] && i != son[x]) dfs2(i, i);
    }
}

struct BIT{
#define lowbit(x) (x & -x)
    int c[MAXN];
    void add(int x){
        while (x <= q){
            ++c[x];
            x += lowbit(x);
        }
    }

    int query(int x){
        int res(0);
        while (x){
            res += c[x];
            x -= lowbit(x);
        }
        return res;
    }
};

struct Block{
    int len;
    int a[MAXN], bl[MAXN];
    int L[MAXM], R[MAXM];
    BIT tr[MAXM];
    void init(){
        len = 1000;
        int tot((n-1)/len+1);
        for (int i(1); i<=tot; ++i){
            L[i] = R[i-1] + 1;
            R[i] = i * len;
        }
        R[tot] = n;
        for (int i(1); i<=n; ++i) a[i] = INT_MAX;
        for (int i(1); i<=tot; ++i){
            for (int j(L[i]); j<=R[i]; ++j) bl[j] = i;
        }
    }

    void modify(int x, int k){
        tr[bl[x]].add(k);
        a[x] = k;
    }

    int query(int l, int r, int k){
        if (k <= 0) return 0;
        int p(bl[l]), q(bl[r]), ans(0);
        if (p == q){
            for (int i(l); i<=r; ++i) ans += a[i] < k;
            return ans;
        }

        for (int i(l); i<=R[p]; ++i) ans += a[i] < k;
        for (int i(p+1); i<q; ++i) ans += tr[i].query(k-1);
        for (int i(L[q]); i<=r; ++i) ans += a[i] < k;
        return ans;
    }
}fk;

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n;
    for (int i(1); i<=n; ++i){
        cin >> fa[i];
        if (fa[i]) e[fa[i]].push_back(i);
    }
    dfs1(1);
    dfs2(1, 1);
    fk.init();

	cin >> q;
    for (int i(1); i<=q; ++i){
        cin >> opt;
        if (opt == 1){
            cin >> u >> v >> c;
            c = i-c;
            int res(0), res2(0);
            while (top[u] ^ top[v]){
                if (dep[top[u]] < dep[top[v]]) swap(u, v);
                res += fk.query(id[top[u]], id[u], c);
                res2 += id[u]-id[top[u]]+1;
                u = fa[top[u]];
            }
            if (dep[u] > dep[v]) swap(u, v);
            cout << res2 + (id[v]-id[u]+1) << ' ' << res + fk.query(id[u], id[v], c) << '\n';
        }else{
            cin >> u;
            fk.modify(id[u], i);
        }
    }

    return 0;
}

```


---


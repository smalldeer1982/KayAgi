# [SHOI2008] 仙人掌图 II

## 题目背景

题目这个II是和[SHOI2006的仙人掌图](https://www.luogu.org/problemnew/show/P4129)区分的，bzoj没有。
**但是实际上还是和bzoj1023是一个题目的**。

## 题目描述

如果某个无向连通图的任意一条边至多只出现在一条简单回路（simple cycle）里，我们就称这张图为仙人掌图（cactus）。所谓简单回路就是指在图上不重复经过任何一个顶点的回路。

![](https://cdn.luogu.com.cn/upload/pic/13241.png)

举例来说，上面的第一个例子是一张仙人图，而第二个不是——注意到它有三条简单回路：（4，3，2，1，6，5，4）、（7，8，9，10，2，3，7）以及（4，3，7，8，9，10，2，1，6，5，4），而（2，3）同时出现在前两个的简单回路里。另外，第三张图也不是仙人图，因为它并不是连通图。显然，仙人图上的每条边，或者是这张仙人图的桥（bridge），或者在且仅在一个简单回路里，两者必居其一。定义在图上两点之间的距离为这两点之间最短路径的距离。定义一个图的直径为这张图相距最远的两个点的距离。**现在我们假定仙人图的每条边的权值都是1，你的任务是求出给定的仙人图的直径**。

## 说明/提示


对第一个样例的说明：6号点和12号点的最短路径长度为8，所以这张图的直径为8。

【注意】使用Pascal语言的选手请注意：你的程序在处理大数据的时候可能会出现栈溢出。
如果需要调整栈空间的大小，可以在程序的开头填加一句：{\$M 5000000}，其中5000000即指代栈空间的大小，请根据自己的程序选择适当的数值。

## 样例 #1

### 输入

```
15 3
9 1 2 3 4 5 6 7 8 3
7 2 9 10 11 12 13 10
5 2 14 9 15 10```

### 输出

```
8```

## 样例 #2

### 输入

```
10 1
10 1 2 3 4 5 6 7 8 9 10```

### 输出

```
9```

# 题解

## 作者：LawrenceSivan (赞：20)

# P4244 [SHOI2008]仙人掌图 II

## 前言

这是仙人掌的入门题目了。

这道题也让我学到了很多东西，所以来写一篇题解。

希望也能帮到大家qwq

## 题意

给定一个仙人掌，求出它的直径。

## 思路

看到求直径，首先可以联想到求树的直径。

对于树的直径，我们主要有两种方式：两次 DFS 或者 BFS，和树形 DP。

~~然后这个题直接使用 BFS 求解可以获得 70 分~~

具体做法是：

对于两次 BFS 或者 DFS ，首先任意地选择一个点，开始对树进行遍历，寻找最远的一个点，之后再从这个点开始，再次进行一次遍历，再次找到距离这个点最远的点。于是就求出了直径。关于证明可以从网上搜一搜，这里就不提了，今天的重点不是它

对于 DP ，可以得到以下过程：

```cpp
void DP(int u){
	vis[u]=1;
	for(re int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(vis[v])continue;
		DP(v);
		ans=max(ans,f[u]+f[v]+val[i]);
		f[u]=max(f[u],f[v]+val[i]);
	}
}
```

但是对于仙人掌上的环，我们就不能这么去操作了。

考虑如何把仙人掌上的环消去。

需要使用圆方树。

[如果你还不会圆方树](https://www.cnblogs.com/cjyyb/p/9098400.html)

关于圆方树的概念及构造方法就不再多说了，这里主要是想说一说这道题的细节。

由于在构建圆方树的过程中，会把环变成一个菊花图，二这些针对的都是圆方树上方圆边或者圆方边。

对于树上的圆圆边是不会有影响的，因为环肯定不会出在圆圆边上。

所以对于圆方树的圆圆边，其实就是普通的树边，所以我们可以直接使用树形 DP 来进行转移。

如何判断到底是不是圆圆边呢？

根据定义，发现圆圆边不在环上，所以我们只需要判断两个点是不是满足不在环上就可以了。

回忆建树的 `tarjan` 过程，我们根据 dfs 序的大小以及 追溯值 `low` 来判断访问节点顺序的先后以及他们的位置关系。

当 `low[v]>dfn[u]` 时，说明 `v` 这个节点只能回到比 `u` 更靠下的位置上，所以他们不会组成一个环。

于是找出了圆圆边。

直接转移即可。

```cpp
if(low[v]>dfn[u]){//不在环上，大力树形DP
            ans=max(ans,f[u]+f[v]+1);
            f[u]=max(f[u],f[v]+1);
        }
```

对于在环上的点，我们需要单独处理。

于是我们直接把这一条链都取出来单独来看。

问题在于我们如何找到一条链，就算找到了如何把它提取出来呢？

回忆 `tarjan` 的过程，也就是 dfs 的过程，每次都会沿着树边向前走，且每个点只会经过一次。

对于一个环，必定会有一条边经过不到。

如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/uq94rzos.png)

从 $u$ 出发，走到 $v$， 红色的边没有经过。

可以发现判断条件是 $v$ 在 $u$ 之后访问，并且 $v$ 在搜索树上的父亲不是 $u$ 。

于是一旦满足了这个条件，意味着我们当前找到的节点 $u$ 是一个环的起始，$v$ 是结束。

有了两头的节点，我们就可以顺势找出一整个环将它提取出来。

具体做法是从环的结束开始，每次跳他在搜索树中的父亲，直到调到环的起始为止。

可以用一个数组存储这个环。

有了环之后，我们需要计算环上的 dp 值了。

对于环上的两个点，如果想要计算 dp 数组的值，就需要知道两个节点在环上的距离。

注意在环上距离指的是两点较小的那个环上距离。

首先对于一个环，他的起始于结束部位相连的地方是不好处理的。

可以考虑环问题的套路处理方式：断环为链，复制一倍。

这样我们每次只计算不超过半个环长的部分，这样就可以找出较短的那一个了。

```cpp
tot=0;
for(re int i=x;i!=fa[y];i=fa[i])g[++tot]=f[i];
for(re int i=1;i<=tot;i++)g[i+tot]=g[i];
```

转移方程是 

`ans=max(ans,f[i]+f[j]+(i-j))` 

其中，$i,j$ 分别是两个点，$f[i],f[j]$ 分别是对应点的 dp 值。

具体含义就是两个点的 dp 值之和加上两点在环上的距离。

发现这个式子只有一次项，是可以使用单调队列的。

发现这个式子其实就是求 $\max(f[i]+f[j]+(i-j))$ 。

循环的时候 $i$ 是定值，也就是要求 $\max(f[j]-j)$

所以得到维护队列单调性的条件：

`g[q[tail]]-q[tail]<g[i]-i`

上面的 $g[]$ 是 是为了方便转移的临时变量。

最后不要忘记更新环的起始位置的 dp 值。

## 细节相关

1. 对于每次提取链。

由于我们是沿着环按照 dfs 序递增的顺序访问的。

所以如果我们直接跳回环的起始位置，相当于我们的环是倒着存储的。

需不需要正过来呢？

不需要。

因为这个环本身就是任意的，你也不知道你会从哪里进来。

直接在环上 dp 就行了。

但是有一点需要注意。

如果你真的非要把他正过来，有一些细节需要注意。

观察这个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/w4dfz7pz.png)

如果你直接跳回来，那么存环的序列就是：

$v\rightarrow 5\rightarrow 4 \rightarrow 3 \rightarrow 2 \rightarrow 1 \rightarrow u$

一号下标是 $v$。

而如果你反过来：

$u\rightarrow 1\rightarrow 2\rightarrow 3 \rightarrow4 \rightarrow 5 \rightarrow v$

一号下标是 $u$。

虽然 $u$ 也是环上的点，但是这个点一定是连接着一个圆圆边，而我们需要处理的第一个环上的边应该是 $u\rightarrow 1$ 这条边。

所以正过来的话需要从 $2$ 开始 dp，并且开始的决策集合需要补充上一个 $1$ 号点的决策点，才能保障正确进行。

关于最后根节点的 dp值更新：

同样的也要分开看，反着的直接更新：

`for(re int i=1;i<=tot;i++)f[x]=max(f[x],g[i]+min(i,tot-i));`

正着的需要注意， $1$ 号节点是不能更新的，需要从二号节点开始。

`for(re int i=2;i<=tot;i++)f[x]=max(f[x],g[i]+min(i-1,tot-i+1));`

同时给出正向和反向的代码：

正向：

```cpp
//#define LawrenceSivan

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
#define INF 0x3f3f3f3f
#define re register
const int maxn=1e5+5;

int n,m,ans;

int hd[maxn],to[maxn<<1],nxt[maxn<<1],cnt;

inline void add(int u,int v){
    nxt[++cnt]=hd[u];
    to[cnt]=v;
    hd[u]=cnt;
}

int f[maxn],q[maxn],head,tail,g[maxn],tot;

//ans=max(ans,f[i]+f[j]+dis(i,j))
//dis(i,j)为他们在环上的较短距离
//为了保证是较短距离，断环为链，加倍处理，当长度超过半环就队头出队

int dfn[maxn],low[maxn],fa[maxn],num;

void solve(int x,int y){
    tot=0;
    for(re int i=y;i!=fa[x];i=fa[i])g[++tot]=f[i];
    for(re int i=1;i<=tot;i++)g[i+tot]=g[i];
    reverse(g+1,g+1+tot*2);
    head=1,tail=0;q[++tail]=1;
    for(re int i=2;i<=(tot<<1);i++){
        while(head<=tail&&i-q[head]>(tot>>1))head++;
        ans=max(ans,g[i]+g[q[head]]+(i-q[head]));
        while(head<=tail&&g[q[tail]]-q[tail]<g[i]-i)tail--;
        q[++tail]=i;
    }
    for(re int i=2;i<=tot;i++)f[x]=max(f[x],g[i]+min(i-1,tot-i+1));
}

void tarjan(int u){
    dfn[u]=low[u]=++num;
    for(re int i=hd[u];i;i=nxt[i]){
        int v=to[i];
        if(v==fa[u])continue;
        if(!dfn[v]){
            fa[v]=u;
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else low[u]=min(low[u],dfn[v]);
        if(low[v]>dfn[u]){//不在一个环上，大力树形DP
            ans=max(ans,f[u]+f[v]+1);
            f[u]=max(f[u],f[v]+1);
        }
    }
    for(re int i=hd[u];i;i=nxt[i]){
        int v=to[i];
        if(fa[v]==u)continue;//要找的是非树边，树边不要
        if(dfn[v]>dfn[u])solve(u,v);//找到环的两个端点，把环拎出来单独算
    }
}

template<typename T>
inline void read(T &x){
    x=0;T f=1;char ch=getchar();
    while (!isdigit(ch)) {if(ch=='-')f=-1;ch=getchar();}
    while (isdigit(ch)){x=x*10+(ch^48);ch=getchar();}
    x*=f;
}

signed main() {
#ifdef LawrenceSivan
    freopen("aa.in", "r", stdin);
    freopen("aa.out", "w", stdout);
#endif
    read(n),read(m);
    for(re int i=1,x,u,v;i<=m;i++){
        read(x);read(u);x--;
        while(x--){
            read(v);add(u,v);add(v,u);u=v;
        }
    }

    tarjan(1);

    printf("%d\n",ans);


    return 0;
}

```

反向

```cpp
//#define LawrenceSivan

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
#define INF 0x3f3f3f3f
#define re register
const int maxn=1e5+5;

int n,m,ans;

int hd[maxn],to[maxn<<1],nxt[maxn<<1],cnt;

inline void add(int u,int v){
    nxt[++cnt]=hd[u];
    to[cnt]=v;
    hd[u]=cnt;
}

int f[maxn],q[maxn],head,tail,g[maxn],tot;

//ans=max(ans,f[i]+f[j]+dis(i,j))
//dis(i,j)为他们在环上的较短距离
//为了保证是较短距离，断环为链，加倍处理，当长度超过半环就队头出队

int dfn[maxn],low[maxn],fa[maxn],num;

void solve(int x,int y){
    tot=0;
    for(re int i=y;i!=fa[x];i=fa[i])g[++tot]=f[i];
    for(re int i=1;i<=tot;i++)g[i+tot]=g[i];
    head=1,tail=0;q[++tail]=0;
    for(re int i=1;i<=(tot<<1);i++){
        while(head<tail&&i-q[head]>(tot>>1))head++;
        ans=max(ans,g[i]+g[q[head]]+(i-q[head]));
        while(head<tail&&g[q[tail]]-q[tail]<g[i]-i)tail--;
        q[++tail]=i;
    }
    for(re int i=1;i<=tot;i++)f[x]=max(f[x],g[i]+min(i,tot-i));
}

void tarjan(int u){
    dfn[u]=low[u]=++num;
    for(re int i=hd[u];i;i=nxt[i]){
        int v=to[i];
        if(v==fa[u])continue;
        if(!dfn[v]){
            fa[v]=u;
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else low[u]=min(low[u],dfn[v]);
        if(low[v]>dfn[u]){//不在一个环上，大力树形DP
            ans=max(ans,f[u]+f[v]+1);
            f[u]=max(f[u],f[v]+1);
        }
    }
    for(re int i=hd[u];i;i=nxt[i]){
        int v=to[i];
        if(fa[v]==u)continue;//要找的是非树边，树边不要
        if(dfn[v]>dfn[u])solve(u,v);//找到环的两个端点，把环拎出来单独算
    }
}

template<typename T>
inline void read(T &x){
    x=0;T f=1;char ch=getchar();
    while (!isdigit(ch)) {if(ch=='-')f=-1;ch=getchar();}
    while (isdigit(ch)){x=x*10+(ch^48);ch=getchar();}
    x*=f;
}

signed main() {
#ifdef LawrenceSivan
    freopen("aa.in", "r", stdin);
    freopen("aa.out", "w", stdout);
#endif
    read(n),read(m);
    for(re int i=1,x,u,v;i<=m;i++){
        read(x);read(u);x--;
        while(x--){
            read(v);add(u,v);add(v,u);u=v;
        }
    }

    tarjan(1);

    printf("%d\n",ans);


    return 0;
}
```

---

## 作者：稚名真白 (赞：13)


“圆方树——处理仙人掌的利器”

先推荐一篇写的很好的文章
[immortalCO](http://immortalco.blog.uoj.ac/blog/1955)

下文有很大的一部分都是参考了该文后写出来或者借鉴~~（照搬）~~过来的

简要的解释一下  学识不精 望大佬们斧正

首先是定义 圆方树 顾名思义 就是~~有圆有方~~的树 

圆是指**圆点** 就是仙人掌原有的点  

方是指**方点** 是我们新加进去的点 （至于为什么添加后面再说）

其作用是把仙人掌缩成一颗树 “从而将树的算法**修改后**用于仙人掌上”  

“它能轻松的将仙人掌转化为树，并能资磁仙人掌上点分治、虚仙人掌、仙人掌剖分等经典的树上问题”

着重讲一下它的构造（第一时间没看懂）

首先是在无向图中找一个环 将环内所有的边都删掉  然后新建一个方点P 将环内所有的点与P相连 任选一个环内的点作为树根




![](https://cdn.luogu.com.cn/upload/pic/47125.png)

左图黑色的边围城一个环 我们新建一个节点P 就是右图的红点

删去全部黑边 环上每个点都连上P点 也就是红边 任选环上一个点作为树根   这里为了方便（打代码也方便） 我们把绿色边连的那个店作为根节点  那么这把一个环变成了一棵树  （某佬成为~~菊花图~~）

如此下去  就可以把仙人掌变成一颗圆方树 

那么边权值呢？   

圆点->方点的权值为0  

方点->圆点的权值为环中次圆点到根节点的最短路

圆点->圆点就是原仙人掌的权值  

不存在方点->方点。（圆方树特性）

之后就可以DP求直径了

对于圆点 和普通的树一样 为最深+次深+1

对于方点  由于儿子们成环 不能简单的用最深+次深+1  咱们可以固定i ，求对于每一个i的max (F[j]+dist(i,j))，
		dist(i,j)等于 min(j-i,n-i+j)，
		为了丢掉这个min好使用单调队列，咱们将环复制一遍，
		然后每一次只考虑半个环长度的DP，这显然是正确的，
		每一个状态都可以在 i 或者 j 的时候被计算到。
		那么方程可以继续改写为 max（F[i]+F[j]+j-i)，
		固定i之后就是求 max(F[j]+j)(j∈[i+1,i+n/2]）
		之后就是单调队列的事情了        
        
        
口胡。。。 这里讲解可能不太清楚。大家看代码吧 

```cpp
#include<cstdio> 
#include<cstring>
#define max(a,b) ((a>b)?(a):(b))
#define min(a,b) ((a>b)?(b):(a))
using namespace std;
const int N=100050;
struct pp {int v,nxt;} e[N<<1]; 
int n,nn,m,tot=1,kok,head[N];
int low[N],dfn[N],fa[N],f[N];
int ans,a[N],q[N],dep[N];
void Add(int u,int v)
{
	e[++tot].nxt=head[u];head[u]=tot;e[tot].v=v;
	e[++tot].nxt=head[v];head[v]=tot;e[tot].v=u;
}
void Init()
{
	scanf("%d%d",&n,&m);nn=n;
	for(int i=1;i<=m;i++)
	{
		int num,u=0;scanf("%d",&num);
		for(int j=1,v;j<=num;j++)
		{
			scanf("%d",&v); if(u!=0) Add(u,v); u=v;
		}
	}
}
void Work(int u,int v)
{
	int all=dep[v]-dep[u]+1,j=all;
	for(int i=v;i!=u;i=fa[i]) a[j--]=f[i]; a[j]=f[u];
	
	for(int i=1;i<=all;i++) a[i+all]=a[i]; // 复制一遍 为了计算到到所有情况 
	int l=0,r=0; q[0]=1;
	for(int i=2;i<=all*2;i++)
	{
		while(l<=r&&i-q[l]>all/2) l++;
		ans=max(ans,a[i]+i+a[q[l]]-q[l]);
		while(l<=r&&a[q[r]]-q[r]<a[i]-i) r--;
		q[++r]=i;
	}
	for(int i=2;i<=all;i++)
		f[u]=max(f[u],a[i]+min(i-1,all-i+1)); // 更新 f 
}
void Tarjan(int u,int last)
// Tarjan的时候顺便把答案也算出来吧 难的第二次Dfs 
{
	dfn[u]=low[u]=++kok;
	for(int j=head[u];j;j=e[j].nxt) if(j!=last)
	{
		int v=e[j].v;
		if(!dfn[v])
		{
			fa[v]=u; dep[v]=dep[u]+1; Tarjan(v,j^1);
			low[u]=min(low[u],low[v]);
		}
		else low[u]=min(low[u],dfn[v]);
		if(low[v]>dfn[u]) // 确保u的最深 不走v这边 
		{
			ans=max(ans,f[u]+f[v]+1);
			f[u]=max(f[u],f[v]+1);
		}
	}
	for(int j=head[u];j;j=e[j].nxt)
	{
		int v=e[j].v;
		if(fa[v]!=u&&dfn[u]<dfn[v]) Work(u,v);
	}
}
void Solve()
{
	Tarjan(1,0); printf("%d\n",ans);
}
int main()
{
	Init();
	Solve();
	return 0;
}
```


太菜了 只能说这么多  关于圆方树的性质和应用大家还是去看那篇文章吧   



---

## 作者：foreverlasting (赞：9)

这题不算太难吧，居然没有题解，太震惊了。

首先发现题面里有这样一个信息：**显然，仙人图上的每条边，或者是这张仙人图的桥（bridge），或者在且仅在一个简单回路里，两者必居其一。**所以发现每条边只有两种情况这个重要事实，那就好办了。

像这种类型的DP应该还是挺多的了，每个环内的DP是一种情况，环外的DP是另一种情况，然后把两种整合在一起就行了（像ZJOI2008的骑士）。于是对图进行DFS，求出DFS树，然后环内处理一下（因为是环，所以可以将原本的环拆掉，复制成两倍的链），DP式应该是好推的，非常普通的区间DP了。然后环外就更简单了。设dp[i]为在以i为根的子树中以i为起点的最长链长度，那么最后目标就是max{dp[i]+dis(i,j)}。于是就ok了。

code：
```
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define res register int 
#define inf 0x3f3f3f3f
#define eps 1e-15
inline int read(){
    res s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return s*w;
}
inline void write(res x) {
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const int N=1e5+10,M=1e7+10;
int low[N],dfn[N],fa[N],deep[N];
int num,ans;
int head[N],cnt;
int dp[N],a[N],moq[N];
struct E{int next,to;}edge[M];
inline void addedge(res u,res v){edge[++cnt]=(E){head[u],v},head[u]=cnt;}
inline void DP(res f,res x){
	res tot=deep[x]-deep[f]+1,j=0;
	for(res i=x;i!=f;i=fa[i],j++)a[tot-j]=dp[i];
	a[tot-j]=dp[f];
	for(res i=1;i<=tot;i++)a[tot+i]=a[i];
	memset(moq,0,sizeof(moq));
	res head=1,tail=1;
	moq[1]=1;
	for(res i=2;i<=(tot<<1);i++){
		while(head<=tail&&i-moq[head]>tot/2)head++;
		ans=max(ans,a[i]+i+a[moq[head]]-moq[head]);
		while(head<=tail&&a[moq[tail]]-moq[tail]<=a[i]-i)tail--;
		moq[++tail]=i;
	}
	for(res i=2;i<=tot;i++)dp[f]=max(dp[f],a[i]+min(i-1,tot-i+1));
}
inline void tarjan(res x){
	low[x]=dfn[x]=++num;
	for(res i=head[x];i;i=edge[i].next){
		res tox=edge[i].to;
		if(tox==fa[x])continue;
		if(!dfn[tox])fa[tox]=x,deep[tox]=deep[x]+1,tarjan(tox),low[x]=min(low[x],low[tox]);
		else low[x]=min(low[x],dfn[tox]);
		if(dfn[x]<low[tox])ans=max(ans,dp[x]+dp[tox]+1),dp[x]=max(dp[x],dp[tox]+1);
	}
	for(res i=head[x];i;i=edge[i].next)
		if(fa[edge[i].to]!=x&&dfn[x]<dfn[edge[i].to])DP(x,edge[i].to);
}
int n,m;
int main(){
	n=read(),m=read();
	while(m--){
		res k=read(),x=read();
		for(res i=2;i<=k;i++){
			res y=read();
			addedge(x,y),addedge(y,x);
			x=y;
		}
	}
	tarjan(1);
	write(ans);
	return 0;
}
```

---

## 作者：BlankAo (赞：6)

$\Large\natural$ **P4244 [SHOI2008]仙人掌图 \ [原题链接](https://www.luogu.com.cn/problem/P4244) \ [更好阅读体验](https://www.cnblogs.com/BlankAo/p/14244657.html)**

##  解法

一开始看见仙人掌，按套路要建出圆方树，但后来发现其实是不用建的。

回想一下求普通树的直径时候的 $\text{dp}$ 方法，可爱而无害。

设 $o$ 为当前 $\text{dfs}$ 到的点， $v$ 为它的一个儿子结点，$f_x$ 为点 $x$ 到叶子结点的最长距离（这个定义全文适用），则有：

$$f_o=max(f_o,f_v+1)$$

$$ans=max(ans,f_o+f_v+1)$$

现在尝试把它扩展至毒瘤的仙人掌来。

我们发现，如果 $o$ 与儿子 $v$  不共存与一个环，那么它们还是可以用上面的 $\text{dp}$ 方式的。但是如果共存于一个环，那还是要特殊处理。

在 $\text{tarjan}$ 的时候，如果 $low_v>dfn_o$ 那么就表示 $v$ 与 $o$ 不在一个环上，就大胆放心地用上面的 $\text{dp}$ 方式。

如果在一个环中，那么我们就要把这个环抽出来：记录一下每个点是从哪个点搜过来的，记为 $fa$ 。$\text{tarjan}$ 的末尾再遍历边一遍，如果找到一个点 $x$，$fa_x\ne o$ 且 $dfn_v>dfn_o$ 那就说明我们找到了一个环的两个点。然后不断让 $x$ 往上跳，即不断令 $x=fa_x$ 就可以找到整个环。

其原理是：从 $o$ 开始 $\text{tarjan}$ ，如果有环，会沿着环走，最后到达 $o$ 的儿子。而且每次 $x=fa_x$ 就相当于沿着搜索轨迹倒退，最后终能复原整个环。

然后找到了这个环怎么办呢？画画仙人掌，发现底下的东西都已不再重要，只有 $f_o$ 值得更新了。所以现在的任务是：在这个环中更新 $ans$ 。并更新 $f_o$。

更新 $ans$，首先按照环形套路，断环为链，将环复制一倍。找到两个距离不超过半环的点。（如果超过半环了就会反着来，比如环 1-2-3-4 首尾相接，断环成链 1-2-3-4-1-2-3-4 ，1-4 不会统计，因为它路径长度为3，而 4-1会统计）这样处理，我们就可以有一个显然的更新。

设原来环的长度为 $len$ ，存环的数组为 $a$ ，现在枚举到了下标 $i$ 和 $j$ ，使得 $i>j$ 且 $i-j<\frac{len}2$ ，则两个点是$a_i,a_j$。

$$ans=max(ans,i-j+f_{ai}+f_{aj})$$

这个可以用单调队列优化，设队尾的点是 $x$ ，在环中下标为 $y$ ，如果 $f_x-y<f_{ai}-i$ 就队尾左移。

更新 $f_o$ 简单。设 $x$ 为环上一个点（不为 $o$），$l$为 $x$ 到 $o$ 的距离。则

$$f_o=max(f_o,f_x+l)$$

注意更新的顺序。

然后就做完啦~

## 代码

开了 O2 后，居然是目前的最优解诶

码风毒瘤见谅

```c++
#include<bits/stdc++.h>
#define rep(i,x,y) for(int i=x;i<=y;++i)
#define mar(o) for(int E=fst[o];E;E=e[E].nxt)
#define v e[E].to
using namespace std;
const int n7=50123,l7=100123,m7=500123;
struct dino{int to,nxt;}e[m7];
int n,m,ecnt,t,fst[n7],f[n7],ans;
int dfn[n7],low[n7],fa[n7],lin[l7];

struct MoquE{
	int head,tail,que[l7];
	void clear(){head=1,tail=0;que[1]=0;}
	void updat(int id,int cnt){
		while(head<=tail && id-que[head]>cnt/2)head++;
		ans=max(ans,f[ lin[id] ]+f[ lin[ que[head] ] ]+id-que[head]);
		while(head<=tail && f[ lin[ que[tail] ] ]-que[tail]<f[ lin[id] ]-id)tail--;
		tail++,que[tail]=id;
	}
}qued;

int rd(){
	int shu=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))shu=(shu<<1)+(shu<<3)+(ch^48),ch=getchar();
	return shu;
}

void edge(int sta,int edn){
	ecnt++;
	e[ecnt]=(dino){edn,fst[sta]};
	fst[sta]=ecnt;
}

void calc(int o1,int o2){
	int cnt=0;
	for(int o=o2;o!=o1;o=fa[o]){
		cnt++,lin[cnt]=o;
	}
	cnt++,lin[cnt]=o1;
	rep(i,1,cnt)lin[i+cnt]=lin[i];
	qued.clear();
	rep(i,1,cnt*2)qued.updat(i,cnt);
	rep(i,1,cnt-1)f[o1]=max(f[o1],f[ lin[i] ]+min(i,cnt-i));
} 

void tarjan(int o){ 
	t++,dfn[o]=low[o]=t;
	mar(o){
		if(v==fa[o])continue;
		if(!dfn[v]){
			fa[v]=o,tarjan(v);
			low[o]=min(low[o],low[v]);
		}
		low[o]=min(low[o],dfn[v]);
		if(low[v]>dfn[o]){
			ans=max(ans,f[o]+f[v]+1);
			f[o]=max(f[o],f[v]+1);
		}
	}
	mar(o){
		if(fa[v]!=o&&dfn[v]>dfn[o])calc(o,v);
	}
}

int main(){
	n=rd(),m=rd();
	rep(i,1,m){
		int num=rd()-1,o1,o2=rd();
		while(num--)o1=rd(),edge(o1,o2),edge(o2,o1),o2=o1;
	}
	tarjan(1);
	printf("%d",ans);
	return 0;
}
```





---

## 作者：day_dream (赞：4)

~~这是仙人掌的入门题吧。~~

首先，如果这不是一个仙人掌，而是一棵树的话就很好办了。我们只要对树进行一遍树形DP就行啦。f[u]表示u点向下延伸的最大深度

>ans=max{f[u]+f[son[u]]+1}；

>f[u]=max{f[son[u]+1};

每个节点更新答案时，我们在用它其中一个儿子v更新f[u]前我们先用它来更新答案。因为我们在遍历到它之前，它与我们处理到的东西没有关联，所以我们可以将v与u接起来更新直径。

回到这题。我们要求一个仙人掌的直径。那么对于不是环的边可以像处理树那样处理。然后对于每个环单独处理。(~~图画得有点丑，大家凑合着看吧。~~)

![](https://sz.btfs.mail.ftn.qq.com/ftn_handler/3d07404399f8c796cc5a9a63c40e0122de6334ebedb5689bd911de34c02ba595c0816ab50bfa75284554828549a8bc07795172ff641cd9d00cbea74bcd398a32?compressed=0&dtype=1&fname=RW%241B%6065%5D%40%407%7BCFPT6K_O%5DU.png)

对于一个环，我们可以将图看成一个基环外向树，我们已经处理完了环上每个节点子树，现在要对环上的点进行DP。两个环上的点中距离最远的点对的距离为f[u]+f[v]+u-v(u-v代表两个的在环上较短的距离)。我们发现这个式子可以用单调队列优化于是就做完了。不过为了保证u-v是环上较短的距离，我们可以把这个环复制一遍，再进行DP，在队首与当前位置超过环长一半时将队首弹出。

```cpp
#include<algorithm>
#include<cstdio>
#define mxn 100010
using namespace std;
int n,m,l,r,sl,fh,ans,f[mxn],a[mxn],q[mxn];
int tim,fa[mxn],dfn[mxn],low[mxn];
int t,h[mxn];
struct edge
{
    int to,nxt;
}e[mxn<<2];
int rd()
{
    sl=0;fh=1;
    char ch=getchar();
    while(ch<'0'||'9'<ch) {if(ch=='-') fh=-1; ch=getchar();}
    while('0'<=ch&&ch<='9') sl=sl*10+ch-'0',ch=getchar();
    return sl*fh;
}
void add(int u,int v)
{
    e[++t]=(edge){v,h[u]};h[u]=t;
    e[++t]=(edge){u,h[v]};h[v]=t;
}
void solve(int rt,int u)
{
    int lim,tot=0;
    for(int i=u;i!=fa[rt];i=fa[i]) a[++tot]=f[i];
    lim=tot>>1;q[l=r=1]=tot<<1;
    for(int i=1;i<=tot;++i) a[i+tot]=a[i];
    for(int i=tot*2-1;i;--i)
    {
        while(l<=r&&q[l]-i>lim) ++l;
        ans=max(ans,a[i]+q[l]+a[q[l]]-i);
        while(l<=r&&a[q[r]]+q[r]<=a[i]+i) --r;
        q[++r]=i;
    }
    for(int i=1;i<tot;++i) f[rt]=max(f[rt],a[i]+min(i,tot-i));
}
void dfs(int u)
{
    dfn[u]=low[u]=++tim;int v;
    for(int i=h[u];i;i=e[i].nxt)
    {
        if((v=e[i].to)==fa[u]) continue;
        if(!dfn[v]) fa[v]=u,dfs(v),low[u]=min(low[u],low[v]);
        else low[u]=min(low[u],dfn[v]);
        if(low[v]>dfn[u])
        {
            ans=max(ans,f[u]+f[v]+1);
            f[u]=max(f[u],f[v]+1);
        }
    }
    for(int i=h[u];i;i=e[i].nxt)
        if(fa[v=e[i].to]!=u&&dfn[v]>dfn[u])
            solve(u,v);
}
int main()
{
    n=rd();m=rd();
    for(int k,x,y,i=1;i<=m;++i)
    {
        k=rd();x=rd();
        for(int j=2;j<=k;++j) y=rd(),add(x,y),x=y;
    }
    dfs(1);printf("%d\n",ans);
    return 0;
}
```

---

## 作者：_tobi_ (赞：4)

[题目 Link](https://www.luogu.com.cn/problem/P4244)  
参考了《算法竞赛进阶指南》作者李煜东的做法

1. 如果给的图是一棵普通的树，那么答案就是树的直径
2. 如果图中存在一个环，那么整个图就是一棵基环树，答案就是基环树的直径   
3. 考虑更复杂的情况，如下图：   
![](https://cdn.luogu.com.cn/upload/image_hosting/dcwvljn2.png) 

对整个图按照 Tarjan 求割边的方法遍历，考虑从结点 $1$ 出发遍历整个图，给遍历到的每一个结点赋值一个时间戳 $dfn$，并记录进入每个结点的边 $from$，每次访问 $dfn = 0$ 的子节点。  

我们把基环树中，环上第一个被遍历到的点称为**顶点**，如图中的 $1$ 和 $7$。
以顶点为分界，整个仙人掌图将被分成几棵“基环树”。具体来说，$7, 8, 9, 10$ 和子树 $8$，子树 $9$，子树 $10$ 是一棵，其他的点是另一棵。  
除上述两种情况外，我们还需考虑答案中同时存在多棵基环树上的边的情况。容易发现顶点的遍历顺序构成一个 DAG。   
我们把 DAG 中的边反过来，再按拓扑序完成整个图的求解。  
  
具体来说，对于遍历到的每一个点 $i$，如果 $i$ 连接着桥边或 $i$ 是某个基环树的顶点，我们就维护一个 $d_i$ 表示从 $i$ 出发能够遍历的最远距离。   
设 $i$ 的子结点为 $j$，对于桥边 $(i, j)$，$d_i = max(d_j + 1)$，**考虑到情况 $1$**, 我们在更新 $d_i$ 前应该先用 $(d_i + d_j + 1)$ 来更新答案。   
对于非桥边 $(i, j)$, $i, j$ 一定在同一个基环树的环中。若 $i$ 是顶点，**考虑到情况 $2$**, 从 $i$ 出发，先求出该基环树的直径并更新答案。**再考虑到情况 $3$**, 求出从顶点 $i$ 出发，在基环树中能够到达的最远的距离作为 $d_i$（按照题中对于“距离”的定义，在环上的部分应走较短的一边）。 

更具体地，为了判断 $i$ 是否为一个基环树的顶点，我们在遍历完结点 $i$ 后准备回溯时，再扫一遍 $i$ 的出边。如果发现存在边 $(i, j)$，满足 $dfn_j > dfn_i$， 且 $from_j \not= (i, j)$，说明 $i$ 的子节点可以到 $j$，$i$ 也可以到 $j$，构成了一个环，我们从 $j$ 出发沿着 $from_j$ 的反边回到 $i$，并记录所有经过的结点，就得到了以 $i$ 为顶点的基环树的环。   
设环上结点分别为 $1, 2, 3, 4 \dots p$, 那么这棵基环树的直径就是 $max(d_i + d_j + min(i - j, p - i + j))$，其中 $i, j \in [1, p]$ 且 $i > j$。  
我们把环复制一倍再拼接起来（复制后 $d$ 值对应相等），每次维护一个指针 $i \in [1, 2p]$ 和一个单调队列，单调队列中元素 $j \in [i - p / 2, i - 1]$ 来保证 $i, j$ 间距离不超过半个环（至于为什么 $i - p / 2$ 可以取等，读者可以画环计算一下）  
对于每个 $i$ 和 $j$，用 $(d[i] + d[j] + i - j)$ 来更新答案，而对于同一个 $i$，答案只与 $d[j] - j$ 有关，根据这个值的大小维护单调队列即可。

具体实现可以看下面的代码。


```cpp
#include<bits/stdc++.h>
using namespace std;
istream &in = cin; ostream &out = cout;

const int N = 5e4 + 5, M = 2e7 + 5; //总边数为 2*K*M
int head[N], nxt[M], val[M], to[M], tot;
void add(int x, int y, int z) { to[++tot] = y, val[tot] = z, nxt[tot] = head[x], head[x] = tot; }

int n, m;
int dfn[N], low[N], dcnt, from[N], d[N], ans;

int s[2 * N], scnt;
deque<int> dq;
void solveOnCircle(int y, int x) {
    scnt = 0; dq.clear(); //注意清空
    while (y != x) {
        s[++scnt] = y;
        y = to[from[y] ^ 1];
    }
    s[++scnt] = x; //记录环上点
    for (int i = 1; i <= scnt; i++) s[i + scnt] = s[i]; //复制一倍
    for (int i = 1; i <= 2 * scnt; i++) {
        while (dq.size() && dq.front() < i - scnt / 2) dq.pop_front();
        if (dq.size()) ans = max(ans, d[s[i]] + d[s[dq.front()]] + i - dq.front());
        while (dq.size() && d[s[dq.back()]] - dq.back() <= d[s[i]] - i) dq.pop_back();
        dq.push_back(i);
    }
    //单调队列维护基环树直径，同时更新答案
    for (int i = 1; i <= scnt; i++) {
        d[x] = max(d[x], d[s[i]] + min(scnt - i, i));
    }
    //更新顶点的 d 值
}

void Tarjan(int x) {
    dfn[x] = low[x] = ++dcnt;
    for (int e = head[x]; e; e = nxt[e]) {
        int y = to[e];
        if (!dfn[y]) {
            from[y] = e;
            Tarjan(y);
            low[x] = min(low[x], low[y]);
            if (low[y] > dfn[x]) {
                ans = max(ans, d[x] + d[y] + val[e]);
                d[x] = max(d[x], d[y] + val[e]);
            }
            //是桥边，更新答案和 d 值
        }
        else if (from[x] != (e ^ 1)) {
            low[x] = min(low[x], dfn[y]);
        }
    }
    for (int e = head[x]; e; e = nxt[e]) {
        int y = to[e];
        if (dfn[y] > dfn[x] && from[y] != e) { //找到环
            solveOnCircle(y, x);
        }
    }
}


int main() {
    ios::sync_with_stdio(false), in.tie(nullptr), out.tie(nullptr);
    tot = 1; // 注意成对变换 tot 初值
    in >> n >> m;
    for (int i = 1, k, x, y; i <= m; i++) {
        in >> k >> x;
        for (int j = 2; j <= k; j++) {
            in >> y;
            add(x, y, 1), add(y, x, 1);
            x = y;
        }
    }
    Tarjan(1);
    out << ans << '\n';
    return 0;
}
```

---

## 作者：Z1qqurat (赞：4)

求仙人掌直径，考虑类比树形 dp 求树上直径的做法。**有一个很好的性质就是仙人掌可以恰好分为若干条桥和一些简单环**。维护 $f_u$ 表示对于一个圆点 $u$，以它为链顶的最长链长度。假如现在我们按照 tarjan 的 dfs 顺序遍历到了一个圆点，且 $u$ 不在任何一个环上，也就是说 $u$ 的所有儿子 $v\in son(u)$ 都是圆点，那么可以直接通过树形 dp 的求最大次大值更新直径：

![](https://pic.imgdb.cn/item/65bafde6871b83018a1aa513.jpg)

1. 假如现在我们按照 tarjan 求割边的 dfs 顺序遍历到了一个圆点 $u$，且 $u$ 不在任何一个环上，也就是说 $u$ 的所有儿子 $v\in son(u)$ 都是圆点，那么可以直接通过树形 dp 的求最大次大值更新直径，也就是说 $d\gets\max(d,f_u+f_v+1),f_u\gets\max(f_u,f_v+1)$。此时 $u\to v$ 必然是一条割边，所以判定条件就是 $dfn_u<low_v$（$v$ 无法通过一条返祖边走到 $u$ 之上，说明这没有形成一个环）。
2. $u,v$ 构成了一条 $v\to u$ 的返祖边，那么 $v\to u$ 的链上组成一个环，也就是说 $u$ 是这个环的“根节点”。取出这个环并将 $u$ 作为第一个节点，断环为链复制一遍，相当于我们要选出两点 $i,j\in[1,2len],0<j-i\le \left\lfloor\frac{len}{2}\right\rfloor$，使得 $j-i+f_j+f_i$ 最大。固定 $j$，相当于求一个最大的 $i$ 满足 $i\ge j+\left\lfloor\frac{len}{2}\right\rfloor$，使得 $f_i-i$ 最大。这是一个滑动窗口状物，直接用优先队列维护就行了。最后记得用环上非根点的 $f$ 来更新 $f_u$。

总体来说虽然没有建出圆方树，但是借鉴了圆方树的思路（感觉仙人掌问题本质上就是分开处理圆点方点 $\to$ 割边与简单环的情况，和基环树有点像的）。往往就是在圆方树转化下把仙人掌问题用树上问题的思路解决。

```cpp
#include <bits/stdc++.h>
#define ALL(v) begin(v), end(v)
#define All(v, l, r) &v[l], &v[(r) + 1]
using i64 = int64_t;
using db = double;
using std::cin;
using std::cout;
constexpr int N = 5e4 + 5;

int n, m, tot, diam;
std::array<std::vector<int>, N> G;
std::array<int, N> f, fa, dfn, low;
std::array<int, N << 1> w, q;

auto dp_circle(int u, int v) {
   auto len = 1; w[1] = f[u];
   for (auto i = v; i != u; i = fa[i]) w[++len] = f[i];
   for (auto i = 1; i <= len; ++i) w[i + len] = w[i];

   auto head = 0, tail = 0; q[0] = 1;
   for (auto i = 2; i <= (len << 1); ++i) {
      while (head <= tail && i - q[head] > (len >> 1)) head++;
      diam = std::max(diam, w[i] + i + w[q[head]] - q[head]);
      while (head <= tail && w[q[tail]] - q[tail] < w[i] - i) tail--;
      q[++tail] = i;
   }

   for (auto i = 2; i <= len; ++i)
      f[u] = std::max(f[u], w[i] + std::min(i - 1, len - i + 1));
   return ;
}

auto tarjan(int u, int ff) -> void {
   dfn[u] = low[u] = ++tot;
   for (auto v : G[u]) {
   	if (v == ff) continue;
      if (!dfn[v])
         fa[v] = u, tarjan(v, u), low[u] = std::min(low[u], low[v]);
      else low[u] = std::min(low[u], dfn[v]);
      if (low[v] > dfn[u]) {
         diam = std::max(diam, f[u] + f[v] + 1);
         f[u] = std::max(f[u], f[v] + 1);
      }
   }
   for (auto v : G[u])
      if (v != ff && dfn[v] > dfn[u] && fa[v] != u) dp_circle(u, v);
   return ;
}

auto main() -> int {
   std::ios::sync_with_stdio(false);
   cin.tie(nullptr), cout.tie(nullptr);

   cin >> n >> m;
   for (auto i = 1, k = 0, u = 0, v = 0; i <= m; ++i) {
      cin >> k >> u;
      for (auto j = 2; j <= k; ++j)
         cin >> v, G[u].emplace_back(v), G[v].emplace_back(u), u = v;
   }
   tarjan(1, 0);
   cout << diam << "\n";
   return 0;
}

---

## 作者：feecle6418 (赞：4)

自己 yy 出了一种 dp 方法……

先提供一组 hack 数据：

```
8 3
5 1 2 3 4 5
3 1 3 5
5 6 3 7 8 6
output:3
```

以下是解法。

首先套路地建出圆方树。

对于圆点很好处理，直接按照求树的最长链的方法树形 dp 即可，求出最大值和次大值；主要是方点不好处理。

由于方点不存在 dp 值，先考虑如何更新答案。设答案为 $ans$，破环为链并复制一次，那么 $ans\leftarrow \max(ans,\max\{d_i+d_j+pos_i-pos_j\})$，这里 $i$ 和 $j$ 是环上的点，且 $i>j$。这里显然可以用单调队列维护递减的 $d_i-pos_i$。但是如何上传最长链的 $dp$ 值呢？

我最开始的想法是枚举每一个环内的点 $x$，用 $\text{x 到环的根的距离}+d_x$ 来更新环根的最长链长度和次长链长度。虽然能够过样例，但是只有 $50$ 分。

问题在哪呢？上面的那组数据就说明了原因：这样有可能使得根的最长链和次长链来自同一个环，从而最长链与次长链的和就**横跨了半环**，不符合**最短路**的条件！

如何修改？方法很简单，对于每个环**只用最大值**更新根，就能避免这个问题。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<vector>
using namespace std;
struct Edge {
	int from,to,next;
} e[200005],e2[200005];
int dfn[100005],low[100005],st[100005],top,sign,n,m;
int h[100005],h2[100005],cnt=1,cnt2,l,r,q[100005],ans;
int pos[100005],tot,d1[100005],d2[100005],f[100005];
vector<int> loop[100005];
void Add_Edge(int x,int y,int h[],int &cnt,Edge e[]) {
	e[++cnt]= {x,y,h[x]};
	h[x]=cnt;
//	cout<<x<<' '<<y<<endl;
}
void Tarjan(int x,int prt) {
	dfn[x]=low[x]=++sign;
	for(int i=h[x]; i; i=e[i].next) {
		if(i==(prt^1))continue;
		int y=e[i].to;
		if(!dfn[y]) {
			st[++top]=i;
			Tarjan(y,i);
			low[x]=min(low[x],low[y]);
			if(low[y]>dfn[x]) {
				top--,Add_Edge(x,y,h2,cnt2,e2),Add_Edge(y,x,h2,cnt2,e2);
			} else if(low[y]==dfn[x]) {
				int s=0;
				++tot;
				while(top) {
					int now=st[top--];
					loop[tot].push_back(e[now].from),s++;
					if(e[now].from==x&&e[now].to==y)break;
				}
				for(int j=0; j<s; j++) {
					Add_Edge(tot,loop[tot][j],h2,cnt2,e2);
					Add_Edge(loop[tot][j],tot,h2,cnt2,e2);
				}
			}
		} else if(dfn[y]<dfn[x]) {
			st[++top]=i,low[x]=min(low[x],dfn[y]);
		}
	}
}
int tmp[100005];
void Calcloop(int x) {
	int s=loop[x].size(),root=loop[x][s-1];
	l=r=1,q[1]=0;
	for(int i=1; i<=s; i++)tmp[i]=tmp[i+s]=loop[x][i-1];
	for(int i=1; i<=s*2; i++) {
		while(l<r&&q[l]<i-s/2)l++;
		ans=max(ans,d1[tmp[q[l]]]+d1[tmp[i]]+i-q[l]);
		while(l<=r&&d1[tmp[i]]-i>=d1[tmp[q[r]]]-q[r])r--;
		q[++r]=i;
	}
	int maxx=0;
	for(int i=1; i<s; i++){
		int dis=min(i,s-i);
		maxx=max(maxx,dis+d1[tmp[i]]);
	}
	if(maxx>d1[root])d2[root]=d1[root],d1[root]=maxx;
	else if(maxx>d2[root])d2[root]=maxx;
}
void DFS(int x,int fa) {
	for(int i=h2[x]; i; i=e2[i].next) {
		int y=e2[i].to;
		if(y==fa)continue;
		DFS(y,x);
		if(x>n||y>n)continue;
		if(d1[x]<d1[y]+1)d2[x]=d1[x],d1[x]=d1[y]+1;
		else if(d2[x]<d1[y]+1)d2[x]=d1[y]+1;
	}
	if(x<=n)ans=max(ans,d1[x]+d2[x]);
	else Calcloop(x);
	//cout<<"D:"<<x<<' '<<d1[x]<<' '<<d2[x]<<endl;
}
int main() {
	scanf("%d%d",&n,&m),tot=n;
	for(int i=1,x,S,pre; i<=m; i++) {
		scanf("%d",&S);
		for(int j=1;j<=S;j++){
			scanf("%d",&x);
			if(j>1)Add_Edge(x,pre,h,cnt,e),Add_Edge(pre,x,h,cnt,e);
			pre=x;
		}
	}
//	cout<<"PP"<<endl;
	Tarjan(1,0);
	DFS(1,0);
	printf("%d\n",ans);
}
/*
8 3
5 1 2 3 4 5
3 1 3 5
5 6 3 7 8 6
*/
```

---

## 作者：Chenyichen0420 (赞：2)

## 思路分析

思考方式可以参见我的[这篇题解](https://www.luogu.com.cn/article/oa1qjayn)。这里主要讲一下这道题特定的对环处理方式。

我们注意到，对于一个环，我们需要快速的求出 $md_i+md_j+dis_{i,j}$，其中 $md_p$ 表示以 $p$ 为根的子树中与 $p$ 距离最远的点的距离，$dis_{i,j}$ 表示 $i,j$ 在环上的最小距离。

我们先假定环上的点的编号依次为 $1,2,\dots,n,i<j$，那么 $md_i+md_j+dis_{i,j}=md_i+md_j-\min(j-i,n-(j-i))$。

如果我们还能保证 $\min(j-i,n-(j-i))$，也就是 $j-i\le\frac{n}{2}$，那么上式可以简化为 $(md_j+j)+(md_i-i)$。

如果我们枚举 $j$，那么 $md_j+j$ 是相对固定的，因此我们要求出在合法范围内的 $j$ 的 $\min md_j-j$。显然这个可以单调队列。

对于一个环，可以暴力合并到根节点上，对于非环点，我们先统计过这个点的最大值，再进行合并。

思路口胡完毕，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node {
	int p, id;
	node(int pi = 0, int vi = 0) :p(pi), id(vi) {};
};
int n, m, cnt, dfn[50005], low[50005]; vector<node>son[50005];
int f[50005], md[50005], fe[50005], d[100005], cn, ans;
inline void tmin(int& l, int r) { (l > r) && (l = r); }
inline void tmax(int& l, int r) { (l < r) && (l = r); }
inline void mkmd(int fp, int p) {
	cn = 0; deque<int>dq;
	for (int i = p;i != f[fp];i = f[i]) d[++cn] = md[i];
	for (int i = 1;i <= cn;++i) d[i + cn] = d[i];
	for (int i = 1;i <= cn << 1;++i) {
		if (dq.size() && i - dq.front() > cn >> 1) dq.pop_front();
		if (dq.size()) tmax(ans, d[i] + d[dq.front()] + i - dq.front());
		while (dq.size() && d[i] - i >= d[dq.back()] - dq.back()) dq.pop_back();
		dq.emplace_back(i);
	}
	for (int i = 1;i <= cn;++i)
		tmax(md[fp], d[i] + min(i, cn - i));
}
inline void tarjan(int p, int id) {
	dfn[p] = low[p] = ++cnt;
	for (const node& sp : son[p])
		if (!dfn[sp.p]) {
			f[sp.p] = p; fe[sp.p] = sp.id;
			tarjan(sp.p, sp.id), tmin(low[p], low[sp.p]);
			if (low[sp.p] > dfn[p])
				tmax(ans, md[p] + md[sp.p] + 1),
				tmax(md[p], md[sp.p] + 1);
		}
		else if (id != sp.id) tmin(low[p], dfn[sp.p]);
	for (const node& sp : son[p])
		if (dfn[p] < dfn[sp.p] && fe[sp.p] != sp.id)
			mkmd(p, sp.p);
}
signed main() {
	ios::sync_with_stdio(0);
	cin >> n >> m; int ecc = 0;
	for (int i = 1, a, b, c;i <= m;++i)
		for (cin >> a >> b;--a;)
			cin >> c, swap(b, c), ++ecc,
			son[b].emplace_back(c, ecc),
			son[c].emplace_back(b, ecc);
	tarjan(1, 0); cout << ans << endl;
}
```

---

## 作者：cysxc11111 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P4244)

------------
#### 题目大意

无向图仙人掌求直径，即这张图相距最远的两个点的距离，距离为两个点之间的最短路长度。

#### 做题思路

如果是一棵树，那么直接用 $d(x)$ 来表示点 $x$ 往下的儿子到 $x$ 的最长距离，每次用最长和次长距离更新答案即可。

但是仙人掌图是存在环的，所以需要把环上的情况全部存在第一次发现环的这个根节点上。如何存呢，大概的意思就是先将环上的点一次保存，用尺取的方法不断地去用**环上最远的两个点之间的距离**（加上这些点向外延伸的距离）去更新答案。最后再把通过这个环可以到达的最远距离更新在根节点上，这个根节点可以再去更新其他值。

#### 完整代码

如果以上仍然不懂可以结合代码帮助理解。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i = (int)a;i<=(int)b;i++)
#define rep_e(i,u,v) for(int i=head[u],v=to[i];~i;i=nex[i],v=to[i])
using namespace std;
typedef long long ll;
const int maxn=50005;
const int maxm=2000005;
int n,m,low[maxn],dfn[maxn],d[maxn];
int head[maxn],to[maxm],nex[maxm],cnt,ans;
int a[maxn*2],st[maxn*2],ct,dep[maxn],fa[maxn];
void add(int u,int v){
	to[cnt]=v;nex[cnt]=head[u];
	head[u]=cnt++;
}
void deal(int rt,int x){
	int tot=dep[x]-dep[rt]+1,tmp=tot;
	for(int i=x;i!=rt;i=fa[i]){
		a[tmp--]=d[i];
	}
	a[tmp]=d[rt];
	rep(i,1,tot) a[tot+i]=a[i];
	st[1]=1;
	int l=1,r=1;
	rep(i,2,2*tot){
		while(l<=r&&i-st[l]>tot/2) l++;
		ans=max(ans,a[i]+i+a[st[l]]-st[l]);
		while(l<=r&&a[st[r]]-st[r]<=a[i]-i) r--;
		st[++r]=i;
	}
	rep(i,2,tot) d[rt]=max(d[rt],a[i]+min(i-1,tot-(i-1)));
}
void dfs(int u,int f){
	low[u]=dfn[u]=++ct;
	rep_e(i,u,v){
		if(v==f) continue;
		if(!dfn[v]){
			fa[v]=u; dep[v]=dep[u]+1;
			dfs(v,u); low[u]=min(low[v],low[u]);
		}
		else low[u]=min(low[u],dfn[v]);
		if(dfn[u]<low[v]){             
			ans=max(ans,d[u]+d[v]+1);
			d[u]=max(d[u],d[v]+1);
		}
	}
	rep_e(i,u,v)
	if(fa[v]!=u&&dfn[u]<dfn[v])
		deal(u,v);
	
}
int main(){
	memset(head,-1,sizeof(head));
	scanf("%d%d",&n,&m);
	rep(o,1,m){
		int k,x,y; scanf("%d",&k);
		scanf("%d",&x);
		rep(i,2,k){
			scanf("%d",&y);
			add(x,y); add(y,x); x=y;
		}
	}
	dep[1]=1;
	dfs(1,-1);
	printf("%d\n",ans);
	return 0;
}
```

这道紫题其实还算是比较水的，~~求管理员通过~~。

---

## 作者：sqrtqwq (赞：0)

我们考虑使用类似于求树的直径的方法来求仙人掌的直径。

我们定义 $dp_u$ 为以 $u$ 为链的顶点的最长链的长度。那么分为以下两类情况：

- $u$ 不在任意一个环上。

那么此时我们直接使用正常的树形 dp 来解决即可。那么就有 $ans = \max(ans,dp_u + dp_v + 1),dp_u = \max(dp_u,dp_v + 1)$。此时的 $u \to v$ 必定是一条割边。

判定方法就是 $v$ 不能通过返祖边走到 $u$ 的上面，即为 $dfn_u < low_v$。

- $u$ 在环之上。

面对带有环的问题，先考虑破环为链。那么我们先把这个环拎出来后把他复制以一边。

那么我们现在的任务就是求出两个点 $i,j$ 满足 $1 \le i,j \le 2 \times len,0 < j - i \le \lfloor \dfrac{j - i}{2} \rfloor$ 使得 $dp_j + dp_i + j - i$ 最大。此时考虑我们固定 $j$，然后求出最大并且满足一以上条件的 $dp_i - i$。此时我们可以使用单调队列来维护。

---


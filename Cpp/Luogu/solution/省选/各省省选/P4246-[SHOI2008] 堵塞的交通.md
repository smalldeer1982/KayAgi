# [SHOI2008] 堵塞的交通

## 题目描述

有一天，由于某种穿越现象作用，你来到了传说中的小人国。小人国的布局非常奇特，整个国家的交通系统可以被看成是一个 $2$ 行 $C$ 列的矩形网格，网格上的每个点代表一个城市，相邻的城市之间有一条道路，所以总共有 $2C$ 个城市和 $3C-2 $条道路。 

小人国的交通状况非常槽糕。有的时候由于交通堵塞，两座城市之间的道路会变得不连通，直到拥堵解决，道路才会恢复畅通。初来咋到的你决心毛遂自荐到交通部某份差事，部长听说你来自一个科技高度发达的世界，喜出望外地要求你编写一个查询应答系统，以挽救已经病入膏肓的小人国交通系统。 小人国的交通部将提供一些交通信息给你，你的任务是根据当前的交通情况回答查询的问题。交通信息可以分为以下几种格式：

- `Close r1 c1 r2 c2`：相邻的两座城市 $(r_1, c_1)$ 和 $(r_2, c_2)$ 之间的道路被堵塞了；
- `Open r1 c1 r2 c2`：相邻的两座城市 $(r_1, c_1)$ 和 $(r_2, c_2)$ 之间的道路被疏通了；
- `Ask r1 c1 r2 c2`：询问城市 $(r_1, c_1)$ 和 $(r_2, c_2)$ 是否连通。如果存在一条路径使得这两条城市连通，则返回 `Y`，否则返回 `N`。

*注：$r_i$ 表示行数，$c_i$ 表示列数，$1 \leq r_i \leq 2, 1 \leq c_i \leq C$。*

## 说明/提示

**数据范围：**

对于 $100\%$ 的数据，$1 \leq C \leq 100000$，$1 \leq$ 信息条数 $\leq 100000$。

## 样例 #1

### 输入

```
2
Open 1 1 1 2
Open 1 2 2 2
Ask 1 1 2 2
Ask 2 1 2 2
Exit```

### 输出

```
Y
N```

# 题解

## 作者：AThousandSuns (赞：106)

线段树神题……没想到线段树还有这种玩法……

打出这道题对线段树的理解和运用一定有巨大帮助。

---
这题一看像是LCT的样子，然而LCT还得支持各种奇怪的东西，还有巨大常数……一不小心就会挂。

考虑线段树。~~咋啥都能考虑~~

一个节点维护 $[l,r]$ 区间的联通情况。（不考虑 $[l,r]$ 外的道路，不然会写死人）

（u,d,l,r,p,q都是bool。下图中有个错别字，懒得改了）

![](https://cdn.luogu.com.cn/upload/pic/48693.png)

对于叶子节点，很明显：

![](https://cdn.luogu.com.cn/upload/pic/48696.png)

---

本题最恶心也是最厉害的地方来了：pushup。

先看看l。

![](https://cdn.luogu.com.cn/upload/pic/48695.png )

r同理。这一部分这样写：

```cpp
//conn[x][0]表示(1,x)和(1,x+1)是否联通
//conn[x][1]表示(2,x)和(2,x+1)是否联通
x.l=l.l|(l.u&conn[l.rig][0]&r.l&conn[l.rig][1]&l.d);
//左边能直接走下去
//左边能走上面，中上联通，再通过右边走到下面，中下联通，再通过左边走下面绕回来
x.r=r.r|(r.u&conn[l.rig][0]&l.r&conn[l.rig][1]&r.d);
//同理
```

再看看u。

![](https://cdn.luogu.com.cn/upload/pic/48694.png)

d同理。这一部分这样写：

```cpp
x.u=(l.u&conn[l.rig][0]&r.u)|(l.p&conn[l.rig][1]&r.q);
//左边能走上面，中上联通，右边能走上面
//左边能走主对角线，中下联通，右边能走副对角线
x.d=(l.d&conn[l.rig][1]&r.d)|(l.q&conn[l.rig][0]&r.p);
//同理
```

最后还有p：

![](https://cdn.luogu.com.cn/upload/pic/48697.png)

q同理。最后放出整个pushup代码：

```cpp
//pushup这样传参的原因待会会说
void pushup(node &x,node l,node r){
	x.lft=l.lft;	//x的左边界，因为conn要用到所以也要pushup
	x.rig=r.rig;	//x的右边界
	x.l=l.l|(l.u&conn[l.rig][0]&r.l&conn[l.rig][1]&l.d);
	x.r=r.r|(r.u&conn[l.rig][0]&l.r&conn[l.rig][1]&r.d);
	x.u=(l.u&conn[l.rig][0]&r.u)|(l.p&conn[l.rig][1]&r.q);
	x.d=(l.d&conn[l.rig][1]&r.d)|(l.q&conn[l.rig][0]&r.p);
	x.p=(l.u&conn[l.rig][0]&r.p)|(l.p&conn[l.rig][1]&r.d);
	x.q=(l.d&conn[l.rig][1]&r.q)|(l.q&conn[l.rig][0]&r.u);
}
```
---
现在来写修改操作。

我们发现在同一行和不在同一行有很多区别（要改的东西不一样），那就分开讨论。

先看不在同一行：（即同一列）

对于这一列代表的叶子节点，实际上就是上面和下面的连通性发生了变化。

![](https://cdn.luogu.com.cn/upload/pic/48700.png)

然后沿途pushup就行了。

在同一行的会比较难懂。我也是看了别的题解才明白……

发现对于 $[x,x+1]$ 这两个点所在的列，直接找到 $x$ 对应的线段树叶子不太好修改。怎么弄呢？

我们发现，修改 $[x,x+1]$ 这两列，会影响到的最小线段树节点是 $[l,r]$，其中 $x=(l+r)/2=mid$。即 $x$ 作为线段树节点中点的节点。

会怎么影响呢？其实就是conn会变，然后就会影响整个节点的联通性。

![](https://cdn.luogu.com.cn/upload/pic/48702.png)

那么修改完conn之后，对这个节点重新pushup一遍就好了。

这里贴个代码：

```cpp
//o：节点编号，l：左端点，r：右端点
//p,row：表示修改(row+1,p)和(row+1,p+1)，因为第一行在conn是0，第二行是1
//val：开还是关
void modify1(int o,int l,int r,int p,int row,bool val){
	int mid=(l+r)>>1;
	if(mid==p){	//中点就是p
		conn[mid][row]=val;	//修改conn
		pushup(seg[o],seg[o<<1],seg[o<<1|1]);	//重新pushup
		return;
	}
	if(mid>=p) modify1(lson,p,row,val);	//递归修改
	else modify1(rson,p,row,val);
	pushup(seg[o],seg[o<<1],seg[o<<1|1]);	//更新
}
```
---
最后还有询问。询问相信大家都会写。
```cpp
//返回node方便在递归路上合并各个节点的信息
node query(int o,int l,int r,int ql,int qr){
	if(l>=ql && r<=qr) return seg[o];	//直接返回
	int mid=(l+r)>>1;
	if(mid<ql) return query(rson,ql,qr);	//不需要左儿子
	if(mid>=qr) return query(lson,ql,qr);	//不需要有儿子
	node ans;
	pushup(ans,query(lson,ql,qr),query(rson,ql,qr));	//左右儿子合起来
	return ans;
} 
```
然后main里面大力讨论一下是考虑答案u,d,l,r,p还是q。交上去……

WA？？？？？？！！！！！！

哦对了，我们来测组数据吧：
```plain
4
OPEN 1 1 1 2
OPEN 1 3 1 4
OPEN 1 1 2 1
OPEN 2 1 2 2
OPEN 2 2 2 3
OPEN 2 3 2 4
OPEN 1 4 2 4
ASK 1 2 1 3 
EXIT
```
答案明显是Y。但是我们输出了N？为什么？

我们把这个图画出来：

![](https://cdn.luogu.com.cn/upload/pic/48703.png)

原来如此。那么求出三个区间大力讨论一下。写法跟pushup差不多，如果理解了pushup那么这一块也应该不难理解。

直接放代码吧：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=444444;
#define lson o<<1,l,mid
#define rson o<<1|1,mid+1,r
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define ROF(i,a,b) for(int i=(a);i>=(b);i--)
#define MEM(x,v) memset(x,v,sizeof(x))
inline int read(){
	char ch=getchar();int x=0,f=0;
	while(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return f?-x:x;
}
struct node{
	int lft,rig;
	bool l,r,u,d,p,q;
}seg[maxn];	//节点
int n;
bool conn[maxn][2];
void pushup(node &x,node l,node r){
	x.lft=l.lft;
	x.rig=r.rig;
	x.l=l.l|(l.u&conn[l.rig][0]&r.l&conn[l.rig][1]&l.d);
	x.r=r.r|(r.u&conn[l.rig][0]&l.r&conn[l.rig][1]&r.d);
	x.u=(l.u&conn[l.rig][0]&r.u)|(l.p&conn[l.rig][1]&r.q);
	x.d=(l.d&conn[l.rig][1]&r.d)|(l.q&conn[l.rig][0]&r.p);
	x.p=(l.u&conn[l.rig][0]&r.p)|(l.p&conn[l.rig][1]&r.d);
	x.q=(l.d&conn[l.rig][1]&r.q)|(l.q&conn[l.rig][0]&r.u);
}
void build(int o,int l,int r){	//建树
	if(l==r){
		seg[o].lft=seg[o].rig=l;	//叶子节点左右边界
		seg[o].u=seg[o].d=1;	//左右联通
		return;
	}
	int mid=(l+r)>>1;
	build(lson);build(rson);
	pushup(seg[o],seg[o<<1],seg[o<<1|1]);
}
void modify1(int o,int l,int r,int p,int row,bool val){	//同行修改
	int mid=(l+r)>>1;
	if(mid==p){
		conn[mid][row]=val;
		pushup(seg[o],seg[o<<1],seg[o<<1|1]);
		return;
	}
	if(mid>=p) modify1(lson,p,row,val);
	else modify1(rson,p,row,val);
	pushup(seg[o],seg[o<<1],seg[o<<1|1]);
}
void modify2(int o,int l,int r,int p,bool val){	//不同行修改，第p列
	if(l==r){
		seg[o].l=seg[o].r=seg[o].p=seg[o].q=val;
		return;
	}
	int mid=(l+r)>>1;
	if(mid>=p) modify2(lson,p,val);
	else modify2(rson,p,val);
	pushup(seg[o],seg[o<<1],seg[o<<1|1]);
}
node query(int o,int l,int r,int ql,int qr){	//查询区间[ql,qr]的节点
	if(l>=ql && r<=qr) return seg[o];
	int mid=(l+r)>>1;
	if(mid<ql) return query(rson,ql,qr);
	if(mid>=qr) return query(lson,ql,qr);
	node ans;
	pushup(ans,query(lson,ql,qr),query(rson,ql,qr));
	return ans;
} 
int main(){
	n=read();char op[10];
	build(1,1,n);
	while(~scanf("%s",op) && op[0]!='E'){
		int a=read(),b=read(),c=read(),d=read();
		switch(op[0]){
			case 'C':	//关路
				if(a==c) modify1(1,1,n,min(b,d),a-1,0);	//同一行
				else modify2(1,1,n,b,0);	//不同行
				break;
			case 'O':	//开路
				if(a==c) modify1(1,1,n,min(b,d),a-1,1);
				else modify2(1,1,n,b,1);
				break;
			case 'A':	//询问
				if(b>d) swap(a,c),swap(b,d);	//列编号小的放前面
				node ans1=query(1,1,n,b,d),ans2=query(1,1,n,1,b),ans3=query(1,1,n,d,n);	//三段
				bool flag=false;
				if(a==1){
					if(c==1){	//左上，右上
						if(ans1.u) flag=true;	//直接走上面
						if(ans2.r&ans1.d&ans3.l) flag=true;	//绕路走
					}
					else{	//左上，右下
						if(ans1.p) flag=true;	//直接走
						if(ans2.r&ans1.d) flag=true;	//从左边绕
						if(ans3.l&ans1.u) flag=true;	//从右边绕
					}
				}
				else{
					if(c==1){	//左下，右上
						if(ans1.q) flag=true;	//直接走
						if(ans2.r&ans1.u) flag=true;	//从左边绕
						if(ans3.l&ans1.d) flag=true;	//从右边绕
					}
					else{	//左下，右下
						if(ans1.d) flag=true;	//直接走
						if(ans2.r&ans1.u&ans3.l) flag=true;	//绕路走
					}
				}
				puts(flag?"Y":"N");
		}
	}
}
```
---
这可能是我写过最认真的一篇题解了。

主要还是因为这题太有意义了，而且洛谷上题解没几个图，有点难懂……

希望能帮到大家。~~两开花，谢谢支持。~~

---

## 作者：daniel14311531 (赞：11)

在校网上做题时发现原题QwQ……  

题解：  

这很明显是求动态图的连通性啊，果断线段树分治。  

线段树分治就是按时间进行分治，利用按秩合并的并查集合并/分离操作维护连通性，LOJ似乎有一道非常好的模板题：[「离线可过」动态图连通性](https://loj.ac/problem/121)。  

剩下的就是粘板子了，存储边时用map维护即可。  

时间复杂度 $O(m log m)$(m为操作数)。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m=0;
struct T { int l,r;vector <int> id; };T t[400010];
struct P { int opt,x,y; };P q[100010];
struct S { int x,dep; };S sta[400010];
map <int,int> ma[200010];
char s[10];
int fa[200010],dep[200010],top=0;

inline int Max(int x,int y) { return x>y?	x:y; }
void build(int u,int l,int r) {
	t[u].l=l,t[u].r=r; if(l>=r)	return ;
	int mid=(l+r)>>1; build(u*2,l,mid),build(u*2+1,mid+1,r);
}
void ins(int u,int l,int r,int w) {
	if(l==t[u].l&&r==t[u].r) { t[u].id.push_back(w);return ; }
	int mid=(t[u].l+t[u].r)>>1;
	if(r<=mid)	ins(u*2,l,r,w); else if(l>mid)	ins(u*2+1,l,r,w);
	else	ins(u*2,l,mid,w),ins(u*2+1,mid+1,r,w);
}
inline int find(int x) { return x==fa[x]?	x:find(fa[x]); }
void Union(int x,int y) {
	x=find(x),y=find(y); if(x==y)	return ;
	if(dep[x]<dep[y])	x^=y,y^=x,x^=y;
	fa[y]=x;sta[++top]=(S){y,dep[y]},sta[++top]=(S){x,dep[x]};
	dep[x]=Max(dep[x],dep[y]+1);
}
void dfs(int u) {
	int Now=top;
	for(int i=0;i<t[u].id.size();i++)	Union(q[t[u].id[i]].x,q[t[u].id[i]].y);
	if(t[u].l>=t[u].r) {
		if(q[t[u].l].opt==3)
			find(q[t[u].l].x)==find(q[t[u].l].y)?	puts("Y"):puts("N");
		return ;
	}
	dfs(u*2),dfs(u*2+1);
	while(top>Now)	fa[sta[top].x]=sta[top].x,dep[sta[top].x]=sta[top].dep,--top;
}
int main() {
	scanf("%d",&n),build(1,1,100000);
	for(int i=1;i<=n+n;i++)	fa[i]=i,dep[i]=1;
	for(int i=1;;++i) {
		scanf("%s",s); if(s[0]=='E')	break;
		int a,b,c,d,x,y; ++m;
		scanf("%d%d%d%d",&a,&b,&c,&d),x=(a-1)*n+b,y=(c-1)*n+d;
		if(x>y)	x^=y,y^=x,x^=y;
		q[m].x=x,q[m].y=y;
		if(s[0]=='O')	q[m].opt=1,ma[x][y]=i;
		else if(s[0]=='C')
			ins(1,ma[x][y],i-1,i),ma[x].erase(ma[x].find(y)),q[m].opt=2;
		else	q[m].opt=3;
	}
	for(int i=1;i<=n+n;i++)
		for(map<int,int>::iterator it=ma[i].begin();it!=ma[i].end();++it)
			ins(1,it->second,m,it->second);
	dfs(1);
	return 0;
}
```


---

## 作者：takanashi_mifuru (赞：7)

### sol1

很厉害的题。

首先第一步是想到用线段树。

然后我们来考虑维护区间的什么信息。

因为我们要求的是可达性所以我们维护可达性，维护哪几个点呢？

是角落的四个点，非常明显，因为角落的四个点可以到达别的区间去。

这样的话区间也可以合并，然后我们询问问的时候要怎么做呢？

然后你说，诶这还不简单，我直接合并区间，然后对于一个区间问他们两个是否可达就可以了！

实际上他假掉了。

![](https://pic.imgdb.cn/item/64ddd238661c6c8e5456a594.jpg)

如上图，从第 $1$ 行第 $2$ 列走到第 $2$ 行第 $4$ 列，如果你只合并区间 $[2,4]$ 的话，结果就是走不过去。

怎么解决呢？

对于每次询问，把区间的起点往前的前缀和终点往后的后缀信息处理出来，然后处理出相邻点的可达性，然后就简单了，我们把三段的可达性拼起来就知道我们能不能直接走过去了！

非常聪明的解法！

代码：

```cpp
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
bool tag[100005][2];
class SegTree{
	public:
	struct node{
		int lt,rt;
		bool Tag[4][4];
	}Tree[100005<<2];
	int rnk[100005];
	node merge(node a,node b){
		node tmp;
		for(int i=0;i<4;i++){
			for(int j=0;j<4;j++){
				tmp.Tag[i][j]=false;
			}
		}
		tmp.lt=a.lt;
		tmp.rt=b.rt;
		tmp.Tag[0][1]=a.Tag[0][1];
		tmp.Tag[1][0]=a.Tag[1][0];
		tmp.Tag[2][3]=b.Tag[2][3];
		tmp.Tag[3][2]=b.Tag[3][2];
		for(int i=0;i<2;i++){
			for(int j=2;j<4;j++){
				for(int k=0;k<2;k++){
					if(a.Tag[i][k|2]&&b.Tag[j][k]&&tag[a.rt][k]){
						tmp.Tag[i][j]=true;
						tmp.Tag[j][i]=true;
					}
				}
			}
		}
		for(int k=2;k<4;k++){
			if(a.Tag[0][k]&&a.Tag[1][(k)^1]&&tag[a.rt][0]&&tag[a.rt][1]){
				if(b.Tag[0][1]){
					tmp.Tag[0][1]=tmp.Tag[1][0]=true;
				}
			}
		}
		for(int k=0;k<2;k++){
			if(b.Tag[2][k]&&b.Tag[3][(k)^1]&&tag[a.rt][0]&&tag[a.rt][1]){
				if(a.Tag[2][3]){
					tmp.Tag[2][3]=tmp.Tag[3][2]=true;
				}
			}
		}
		return tmp;
	}
	void pushup(int cur){
		Tree[cur]=merge(Tree[cur<<1],Tree[cur<<1|1]);
		return;
	}
	void build(int cur,int lt,int rt){
		if(lt==rt){
			Tree[cur].Tag[0][2]=Tree[cur].Tag[2][0]=true;
			Tree[cur].Tag[1][3]=Tree[cur].Tag[3][1]=true;
			Tree[cur].lt=lt;
			Tree[cur].rt=rt;
			return;
		}
		int mid=lt+rt>>1;
		build(cur<<1,lt,mid);
		build(cur<<1|1,mid+1,rt);
		rnk[mid]=cur;
		pushup(cur);
		return;
	}
	void updateH(int cur,int lt,int rt,int Q,int k){
		if(lt>Tree[Q].rt||rt<Tree[Q].lt){
			return;
		}
		if(cur==Q){
			pushup(cur);
			return;
		}
		int mid=lt+rt>>1;
		updateH(cur<<1,lt,mid,Q,k);
		updateH(cur<<1|1,mid+1,rt,Q,k);
		pushup(cur);
		return;
	}
	void updateS(int cur,int lt,int rt,int Q,bool val){
		if(lt>Q||rt<Q){
			return;
		}
		if(lt==rt&&lt==Q){
			for(int i=0;i<4;i++){
				for(int j=0;j<4;j++){
					if(i==j)continue;
					Tree[cur].Tag[i][j]=val; 
				}
			}
			Tree[cur].Tag[0][2]=Tree[cur].Tag[2][0]=true;
			Tree[cur].Tag[1][3]=Tree[cur].Tag[3][1]=true;
			return;
		}
		int mid=lt+rt>>1;
		updateS(cur<<1,lt,mid,Q,val);
		updateS(cur<<1|1,mid+1,rt,Q,val);
		pushup(cur);
		return;
	}
	node query(int cur,int lt,int rt,int qx,int qy){
		if(lt>=qx&&rt<=qy){
			return Tree[cur];
		}
		int mid=lt+rt>>1;
		if(mid<qx){
			return query(cur<<1|1,mid+1,rt,qx,qy);
		}
		if(mid+1>qy){
			return query(cur<<1,lt,mid,qx,qy);
		}
		return merge(query(cur<<1,lt,mid,qx,qy),query(cur<<1|1,mid+1,rt,qx,qy));
	}
	void solve(){
		int stx,sty,edx,edy;
		scanf("%lld%lld%lld%lld",&stx,&sty,&edx,&edy);//
		stx--,edx--;
		if(sty>edy){
			swap(stx,edx);
			swap(sty,edy);
		}
		node Pre=query(1,1,n,1,sty);
		node Mid=query(1,1,n,sty,edy);
		node Suf=query(1,1,n,edy,n);
		bool tag1=Pre.Tag[2][3];
		bool tag2=Suf.Tag[0][1];
		bool ans=false;
		for(int i=0;i<2;i++){
			for(int j=2;j<4;j++){
				if(Mid.Tag[i][j]){
					if((tag1||stx==i)&&(tag2||edx+2==j)){
						ans=true;
					}
				}
			}
		}
		if(ans){
			puts("Y");
		}
		else{
			puts("N");
		}
	}
}P;
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<n;i++){
		tag[i][0]=tag[i][1]=false;
	}
	P.build(1,1,n);
	string S;
	while(cin>>S){
		if(S=="Exit"){
			break;
		}
		if(S=="Open"){
			int stx,sty,edx,edy;
			scanf("%lld%lld%lld%lld",&stx,&sty,&edx,&edy);
			if(sty>edy){
				swap(stx,edx);
				swap(sty,edy);
			}
			if(stx^edx){
				P.updateS(1,1,n,sty,true);
			}
			else{
				tag[sty][stx-1]=true;
				P.updateH(1,1,n,P.rnk[sty],stx-1);
			}
		}
		else{
			if(S=="Close"){
				int stx,sty,edx,edy;
				scanf("%lld%lld%lld%lld",&stx,&sty,&edx,&edy);
				if(sty>edy){
					swap(stx,edx);
					swap(sty,edy);
				}
				if(stx^edx){
					P.updateS(1,1,n,sty,false);
				}
				else{
					tag[sty][stx-1]=false;
					P.updateH(1,1,n,P.rnk[sty],stx-1);
				}
			}
			else{
				P.solve();
			}
		}
	}
	return 0;
}
```


### sol2

实际上加边删边判连通性的问题你可以对于每条边把他存在与否丢到时间轴上，然后线段树分治套可撤销并查集判连通性可以直接过。

---

## 作者：myee (赞：7)

### 前言

可能大多数人看到这题就一眼动态图连通性秒了。

但是我发现自己不会敲动态图连通性……

于是，提供一种离线做法。

什么，LCT？

LCT 多难打，放一个**更加暴力而简约**的离线做法。

---
### 思路

线段树分治。

考虑到每条道路都有一个**寿命**，即从某时刻到某时刻里存在，我们具备了线段树分治的一个先决条件。**特别的，如果最后都没有死，我们最后杀掉它。**

我们维护一个**时光序列**，即某时刻中有的道路，那么对每条道路，我们**在时光序列的某段中同时插入**，最后对时光序列每个询问点进行查询即可，使用并查集复杂度是 $O(nm\alpha(n))$ 的。

~~这不就暴力吗。~~

考虑到时光序列可以形如一颗 Leafy Tree（把实际信息存在叶子节点的树）的，我们用线段树维护它，插入边时就是在线段树上区间插入，查询时 dfs 一遍线段树即可。

什么，你问我 dfs 时怎么统计贡献？

使用带撤销并查集即可。

什么，你不会带撤销并查集？

其实就是不用路径压缩而用其它优化（如按秩合并）的并查集，开栈记录下 `merge` 过程，撤销操作就取栈顶回退即可。

复杂度 $O(n+m\log m\log n)$。

---
### Code

带撤销并查集使用按秩合并没有精神，以下代码利用 Treap 的思想，封装了一个 `Heap_DSU`。

```cpp
#include <algorithm>
#include <map>
#include <stdio.h>
#include <vector>
typedef long long llt;
typedef unsigned uint;typedef unsigned long long ullt;
typedef bool bol;typedef char chr;typedef void voi;
typedef double dbl;
template<typename T>bol _max(T&a,T b){return(a<b)?a=b,true:false;}
template<typename T>bol _min(T&a,T b){return(b<a)?a=b,true:false;}
template<typename T>T power(T base,T index,T mod){return((index<=1)?(index?base:1):(power(base*base%mod,index>>1,mod)*power(base,index&1,mod)))%mod;}
template<typename T>T lowbit(T n){return n&-n;}
template<typename T>T gcd(T a,T b){return b?gcd(b,a%b):a;}
template<typename T>T lcm(T a,T b){return(a!=0||b!=0)?a/gcd(a,b)*b:(T)0;}
template<typename T>T exgcd(T a,T b,T&x,T&y){if(!b)return y=0,x=1,a;T ans=exgcd(b,a%b,y,x);y-=a/b*x;return ans;}
template<typename T,typename Rand>
class Heap_DSU
{
    private:
        std::vector<T>Fath,Prior,Hty;
        T root(T p){return(p==Fath[p])?p:root(Fath[p]);}
    public:
        voi build(T n,Rand rng=Rand())
        {
            Fath.resize(n),Prior.resize(n),Hty.clear();
            for(T i=0;i<n;i++)Fath[i]=i,Prior[i]=rng();
        }
        bol connected(uint u,uint v){return root(u)==root(v);}
        bol merge(T u,T v)
        {
            if((u=root(u))==(v=root(v)))return Hty.push_back(u),false;
            if(Prior[u]<Prior[v])std::swap(u,v);
            return Fath[u]=v,Hty.push_back(u),true;
        }
        bol revoke()
        {
            if(Hty.empty())return false;
            T p=Hty.back();Hty.pop_back();
            if(Fath[p]==p)return false;
            return Fath[p]=p,true;
        }
};
typedef std::pair<uint,uint>Pair;
struct Seg
{
    std::vector<Pair>Way;uint len;Seg*L,*R;
    voi build(uint n){if((len=n)>1)L=new Seg,R=new Seg,L->build(len>>1),R->build(len-(len>>1));}
    voi insert(uint l,uint r,Pair p)
    {
        if(!l&&r==len){Way.push_back(p);return;}
        if(l<(len>>1))
            if(r<=(len>>1))L->insert(l,r,p);
            else L->insert(l,len>>1,p),R->insert(0,r-(len>>1),p);
        else R->insert(l-(len>>1),r-(len>>1),p);
    }
};
ullt Ra=1;const ullt Rb=10007,Rc=114513;struct rng{uint operator()(){return Ra=Ra*Rb+Rc;}};
Heap_DSU<uint,rng>U;
chr C[10];Pair P[114514];uint Op[114514];
bol Ans[114514];uint t=0;
uint hash(uint a,bol b){return a<<1|b;}
std::map<Pair,uint>M;Seg S;
voi dfs(Seg*S,uint cnt)
{
    uint k=0;for(auto w:S->Way)U.merge(w.first,w.second),k++;
    if(S->len==1)
    {
        if(!Op[cnt])Ans[t++]=U.connected(P[cnt].first,P[cnt].second);
    }
    else dfs(S->L,cnt),dfs(S->R,cnt+S->L->len);
    while(k--)U.revoke();
}
int main()
{
    uint n,m=0,r,c;scanf("%u%u",&n),U.build(n<<1);
    while(scanf("%s",C)==1&&*C!='E')
    {
        Op[m]=*C=='A'?0:(*C=='O'?1:2);
        scanf("%u%u",&r,&c),P[m].first=hash(c-1,r-1);
        scanf("%u%u",&r,&c),P[m].second=hash(c-1,r-1);
        if(P[m].first>P[m].second)std::swap(P[m].first,P[m].second);
        m++;
    }
    S.build(m);
    for(uint i=0;i<m;i++)if(Op[i]==1)M[P[i]]=i;else if(Op[i]==2)S.insert(M[P[i]],i,P[i]),M.erase(P[i]);
    for(auto w:M)S.insert(w.second,m,w.first);
    dfs(&S,0);
    for(uint i=0;i<t;i++)puts(Ans[i]?"Y":"N");
    return 0;
}
```

---
### 一些经验 / 非经验

可以离线（经验）：
* [SP9576](https://www.luogu.com.cn/problem/SP9576)
* [SP9577](https://www.luogu.com.cn/problem/SP9577)
* [loj121](https://loj.ac/p/121)
* [P2147](https://www.luogu.com.cn/problem/P2147)
* [P3767](https://www.luogu.com.cn/problem/P3767)

强制在线（非经验）：
* [loj122](https://loj.ac/p/122)
* [P5247](https://www.luogu.com.cn/problem/P5247)


---

## 作者：yqbylty (赞：7)

首先这题我们的重点就是如何判断两点是否能互相到达。

对于下图，我们来讨论一下怎样才能使点对之间联通。

![](https://luvwgyx.com/wp-content/uploads/2018/12/堵塞的交通1.png)

我们举个例子：若要使$S_1$和$S_4$能互相到达，中间的$mid-mid+1$先不管它，那么我们是不是只需要满足$S_1->S_3$和$S_3->S_4$能通或者$S_1->S_2$和$S_2->S_4$之间能通那么$S_1$和$S_4$就是能互相到达的。那么同理，我们也就可以处理出其它六个点对之间的联通关系。

于是我们就可以考虑一下合并的处理。

![](https://luvwgyx.com/wp-content/uploads/2018/12/堵塞的交通3.png)

对于上图，我们要合并$S_1 - S_4$和$S_1{other} - S_4{other}$这两个矩阵，那么我们就要更新这个大的矩阵的信息了。

同样举个例子：若要更新$S_1$和$S_4{other}$这两个点的联通关系，那么同样我有很多走法，但是不管怎样我都是要经过$S_2->S_1{other}$和$S_4->S_3{other}$这两条边中的一条的，而这些走法中涉及的其它的边，在我们合并前的两个小矩形我们是统计过的，所以我们只需要知道$S_2->S_1{other}$和$S_4->S_3{other}$这两条边是不是疏通的就好了。

其实从上面的分析来看，我们可以采用线段树来解决这道题。

那么我们只需要记录八个参数就可以了：

- $U$：第一行$S_2->S_1{othe r}$是否联通
- $D$：第二行$S_4->S_3{other }$是否联通
- $l$：$S _1$,$S_3$是否联通
- $r$：$S_2$,$S_4$是否联通
- $u$：$S_1$,$S_2$是否联通
- $d$：$S_3$,$S_4$是否联通
- $q$：$S_1$,$S_4$是否联通
- $p$：$S_3$,$S_2$是否联通

然后合并就好了，具体的看代码吧。

**Code:**

```cpp
/*Program from Luvwgyx*/
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=1e5+10;
int c,r1,r2,c1,c2;char s[10];
struct node{bool U,D,l,r,u,d,p,q;}w[maxn<<2];
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void print(int x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)print(x/10);
    putchar(x%10+'0');
}
void write(int x){print(x);puts("");}
struct Segment_Tree{
    struct tree{int l,r;}tree[maxn<<2];
    void merge(node &k,node l,node r){
        k.l=l.l|(l.u&k.U&r.l&k.D&l.d);
        k.r=r.r|(r.u&k.U&l.r&k.D&r.d);
        k.u=(l.u&k.U&r.u)|(l.q&k.D&r.p);
        k.d=(l.d&k.D&r.d)|(l.p&k.U&r.q);
        k.q=(l.q&k.D&r.d)|(l.u&k.U&r.q);
        k.p=(l.p&k.U&r.u)|(l.d&k.D&r.p);
    }
    void build(int k,int l,int r){
        tree[k].l=l;tree[k].r=r;
        if(l==r){w[k].u=w[k].d=w[k].U=w[k].D=1;return ;}
        int mid=(l+r)>>1;
        build(k<<1,l,mid);
        build(k<<1|1,mid+1,r);
    }
    void updater(int k,int x,int t,int val){
        int l=tree[k].l,r=tree[k].r,mid=(l+r)>>1;
        if(x==mid){
            t==1?w[k].U=val:w[k].D=val;
            merge(w[k],w[k<<1],w[k<<1|1]);
            return ;
        }
        if(x<=mid)updater(k<<1,x,t,val);
        else updater(k<<1|1,x,t,val);
        merge(w[k],w[k<<1],w[k<<1|1]);
    }
    void updatec(int k,int x,int val){
        int l=tree[k].l,r=tree[k].r;
        if(l==r){w[k].l=w[k].r=w[k].p=w[k].q=val;return ;}
        int mid=(l+r)>>1;
        if(x<=mid)updatec(k<<1,x,val);
        else updatec(k<<1|1,x,val);
        merge(w[k],w[k<<1],w[k<<1|1]);
    }
    node find(int k,int s,int t){
        int l=tree[k].l,r=tree[k].r,mid=(l+r)>>1;
        if(s<=l&&r<=t)return w[k];
        if(t<=mid)return find(k<<1,s,t);
        else if(s>mid)return find(k<<1|1,s,t);
        else {
            node ret=w[k];
            merge(ret,find(k<<1,s,t),find(k<<1|1,s,t));
            return ret;
        }
    }
}T;
int main(){
    c=read();T.build(1,1,c);
    while(scanf("%s",s)!=EOF){
        if(s[0]=='E')break;int ans=0;
        r1=read();c1=read();r2=read();c2=read();
        if(c1>c2)swap(c1,c2),swap(r1,r2);
        if(s[0]=='O'){r1==r2?T.updater(1,c1,r1,1):T.updatec(1,c1,1);}
        if(s[0]=='C'){r1==r2?T.updater(1,c1,r1,0):T.updatec(1,c1,0);}
        if(s[0]=='A'){
            node l=T.find(1,1,c1),x=T.find(1,c1,c2),r=T.find(1,c2,c);
            if (r1==1&&r2==1)ans=x.u|(l.r&x.p)|(x.q&r.l)|(l.r&x.d&r.l);
            if (r1==1&&r2==2)ans=x.q|(l.r&x.d)|(x.u&r.l)|(l.r&x.p&r.l);
            if (r1==2&&r2==1)ans=x.p|(l.r&x.u)|(x.d&r.l)|(l.r&x.q&r.l);
            if (r1==2&&r2==2)ans=x.d|(l.r&x.q)|(x.p&r.l)|(l.r&x.u&r.l);
            puts(ans?"Y":"N");
        }
    }
    return 0;
}
```

---

## 作者：zhlzt (赞：6)

上午 yyz 讲课，这是一道例题，看着貌似很可做的样子就开写了。然后因为两个 joker 错误调了很久。/ll

注意到我们所选的路径不需要多次经过相同的城市，否则可以等效成前者。

以下 $n$ 为题面中的 $C$，$m$ 为信息条数。

令 $(i,j)$ 表示第 $i$ 列第 $j+1$ 行的点（$1\le i\le n$，$0\le j\le 1$）。设询问 $(x_u,y_u)$ 和 $(x_v,y_v)$ 是否连通，不妨设 $x_u\le x_v$。则我们只需考虑以下四种路径：

1. 自 $(x_u,y_u)$ 向右走蛇形路径至 $(x_v,y_v)$，经过的点满足列数单调不减。
2. 自 $(x_u,y_u)$ 向右走形如 1 的蛇形路径至 $(x_v,1-y_v)$，再向右并掉头向左行至 $(x_v,y_v)$。
3. 自 $(x_u,y_u)$ 向左并掉头向右行至 $(x_u,1-y_u)$，再走形如 1 的蛇形路径至 $(x_v,y_v)$。
4. 自 $(x_u,y_u)$ 向左并掉头向右行至 $(x_u,1-y_u)$，再向右走形如 1 的蛇形路径至 $(x_v,1-y_v)$，最后向右并掉头向左行至 $(x_v,y_v)$。

我们考虑分别维护蛇形路径和掉头。使用线段树较为容易。

对于蛇形路径，我们维护区间左端的两个点和区间右端的两个点（共 $4$ 个点对）的连通关系（仅通过该区间内的边）。显然在仅通过该区间内的边的限制条件下，他们之间的路径一定是蛇形路径。

对于掉头，我们维护区间左端的两个点的连通关系，和区间右端的两个点的连通关系（仅通过该区间内的边）。显然在仅通过该区间内的边的限制条件下，他们之间的路径一定是“向左并掉头向右”或“向右并掉头向左”。

时间复杂度 $\mathcal{O}(n+m\log n)$，空间复杂度 $\mathcal{O}(n)$。

:::info[pushup()]{open}
```cpp
inline node pushup(node u,node v){
	node res;
	res.l=u.l,res.r=v.r;
	res.dp[0]=(u.dp[0]|(valr[v.l][0] & valr[v.l][1] & v.dp[0] & u.val[0][0] & u.val[1][1]));
	res.dp[1]=(v.dp[1]|(valr[v.l][0] & valr[v.l][1] & u.dp[1] & v.val[0][0] & v.val[1][1]));
	res.val[0][0]=((u.val[0][0] & v.val[0][0] & valr[v.l][0])|(u.val[0][1] & v.val[1][0] & valr[v.l][1]));
	res.val[0][1]=((u.val[0][0] & v.val[0][1] & valr[v.l][0])|(u.val[0][1] & v.val[1][1] & valr[v.l][1]));
	res.val[1][0]=((u.val[1][0] & v.val[0][0] & valr[v.l][0])|(u.val[1][1] & v.val[1][0] & valr[v.l][1]));
	res.val[1][1]=((u.val[1][0] & v.val[0][1] & valr[v.l][0])|(u.val[1][1] & v.val[1][1] & valr[v.l][1]));
	return res;
}
```
:::

:::info[路径存在性判断]{open}
```cpp
cin>>uy>>ux>>vy>>vx;
--uy,--vy;
if(ux>vx) swap(ux,vx),swap(uy,vy);
node tmpl=query(1,ux,1),tmp=query(ux,vx,1),tmpr=query(vx,n,1);
if(tmp.val[uy][vy]) cout<<"Y\n";
else if(tmp.val[uy][vy^1] and tmpr.dp[0]) cout<<"Y\n";
else if(tmp.val[uy^1][vy] and tmpl.dp[1]) cout<<"Y\n";
else if(tmp.val[uy^1][vy^1] and tmpl.dp[1] and tmpr.dp[0]) cout<<"Y\n";
else cout<<"N\n";
```
:::

:::success[[SHOI2008] 堵塞的交通 - P4246.cpp]
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
int n,valc[maxn],valr[maxn][2];
struct node{
	int l,r,val[2][2],dp[2];
}tree[maxn<<2];
inline node pushup(node u,node v){
	node res;
	res.l=u.l,res.r=v.r;
	res.dp[0]=(u.dp[0]|(valr[v.l][0] & valr[v.l][1] & v.dp[0] & u.val[0][0] & u.val[1][1]));
	res.dp[1]=(v.dp[1]|(valr[v.l][0] & valr[v.l][1] & u.dp[1] & v.val[0][0] & v.val[1][1]));
	res.val[0][0]=((u.val[0][0] & v.val[0][0] & valr[v.l][0])|(u.val[0][1] & v.val[1][0] & valr[v.l][1]));
	res.val[0][1]=((u.val[0][0] & v.val[0][1] & valr[v.l][0])|(u.val[0][1] & v.val[1][1] & valr[v.l][1]));
	res.val[1][0]=((u.val[1][0] & v.val[0][0] & valr[v.l][0])|(u.val[1][1] & v.val[1][0] & valr[v.l][1]));
	res.val[1][1]=((u.val[1][0] & v.val[0][1] & valr[v.l][0])|(u.val[1][1] & v.val[1][1] & valr[v.l][1]));
	return res;
}
void build(int p,int pl,int pr){
	tree[p].l=pl,tree[p].r=pr;
	if(pl==pr){
		tree[p].val[0][0]=tree[p].val[1][1]=1;
		return;
	}
	int mid=(pl+pr)>>1;
	build(p<<1,pl,mid); build(p<<1|1,mid+1,pr);
	tree[p]=pushup(tree[p<<1],tree[p<<1|1]);
}
void update(int pos,int p){
	if(tree[p].l==tree[p].r){
		tree[p].dp[0]=tree[p].dp[1]=tree[p].val[0][1]=tree[p].val[1][0]=valc[tree[p].l];
		return;
	}
	int mid=(tree[p].l+tree[p].r)>>1;
	if(pos<=mid) update(pos,p<<1);
	else update(pos,p<<1|1);
	tree[p]=pushup(tree[p<<1],tree[p<<1|1]);
}
node query(int l,int r,int p){
	if(l<=tree[p].l and tree[p].r<=r) return tree[p];
	int mid=(tree[p].l+tree[p].r)>>1;
	if(r<=mid) return query(l,r,p<<1);
	if(l>mid) return query(l,r,p<<1|1);
	return pushup(query(l,r,p<<1),query(l,r,p<<1|1));
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n;
	char str[10];
	int ux,uy,vx,vy;
	build(1,1,n);
	while(cin>>str){
		if(str[0]=='E') break;
		cin>>uy>>ux>>vy>>vx;
		--uy,--vy;
		if(str[0]=='O'){
			if(ux==vx) valc[ux]=1,update(ux,1);
			else if(ux<vx) valr[vx][vy]=1,update(vx,1);
			else valr[ux][uy]=1,update(ux,1);
		}
		else if(str[0]=='C'){
			if(ux==vx) valc[ux]=0,update(ux,1);
			else if(ux<vx) valr[vx][vy]=0,update(vx,1);
			else valr[ux][uy]=0,update(ux,1);
		}
		else{
			if(ux>vx) swap(ux,vx),swap(uy,vy);
			node tmpl=query(1,ux,1),tmp=query(ux,vx,1),tmpr=query(vx,n,1);
			if(tmp.val[uy][vy]) cout<<"Y\n";
			else if(tmp.val[uy][vy^1] and tmpr.dp[0]) cout<<"Y\n";
			else if(tmp.val[uy^1][vy] and tmpl.dp[1]) cout<<"Y\n";
			else if(tmp.val[uy^1][vy^1] and tmpl.dp[1] and tmpr.dp[0]) cout<<"Y\n";
			else cout<<"N\n";
		}
	}
	return 0;
}
```
:::

---

## 作者：GNAQ (赞：6)

看到题解里线段树合并结点的做法都是

## 大力讨论联通情况

我就很不爽。。为什么不上 $\color{red}\text{并查集}$ 呢？

我们在树上每个节点开并查集维护连通性，代替那一堆数组和变量什么的。

并查集做法的优点在于

1. 你能无脑合并，因为不需要考虑 $\color{red}\text{连通性和先后顺序之间的一堆影响}$ ，所以调试的时候根本不用操心**最麻烦的**节点合并部分

2. 最后查答案也是无脑合并然后 `Find()` 一下就好了

3. 要维护的变量很少。~~合并代码也相对简洁~~ ←情况其实非常多

不过一句题外话，我写的还是挺长的，也许是我变量名太长的缘故？或者并查集这种写法要讨论的情况本身就比开一堆变量那个要多??

-----

### 制表符万岁！

我是按照横向道路建的树，维护的区间长度是 $n-1$ 。

```plain
┌─┬─┬─┬─┬─┐
│1│2│3│4│5│          n=6
└─┴─┴─┴─┴─┘
```


对于一个`格子`，编号如下:

```plain
1─2
│ │
3─4
```


更新的时候，如果是横向更新，那需要更新对应的一个叶子。如果竖向的那需要更新夹起它的左右两个叶子。

```plain
竖向更新要照顾 L R 两个叶子。
┌─┬─┐
│L│R│
└─┴─┘
```

然后询问的时候要先看在偏左的询问点能不能通过`向左走`的方式更新`纵向`上的连通性，然后偏右的询问点也同理，类似于这图：


```plain
r1=1 c1=3
r2=2 c2=5

 ┌─────┐
 │     |
 │ ┌─┬─○─┬─┬─┐
 │ │1│2│3│4│5│
 │ └─┴─┴─┴─○─┘
 │     ↑
 └─────┘

```


还有就是合并的时候要把左右两块合到一起，这个时候在中间要枚举好几种走法，然后就没啥可讲的了。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#define ll long long
using namespace std;

int n,m,conn[100010][4];

template<typename int_t>
void readx(int_t& x)
{
	x=0; int_t k=1; char ch=0;
	while (ch<'0' || ch>'9') { ch=getchar(); if (ch=='-') k=-1; }
	while (ch>='0' && ch<='9') { x=x*10+ch-'0'; ch=getchar(); }
	x*=k;
}

int Find(int e,int ds[])
{
	if (e!=ds[e]) ds[e]=Find(ds[e],ds);
	return ds[e];
}

void Merge(int a,int b,int ds[])
{
	ds[Find(b,ds)]=Find(a,ds);
}

namespace SGT
{
	#define LCH (inx<<1)
	#define RCH (inx<<1|1)
	
	struct Seg_Tree
	{
		int l,r,mid;
		int ds[6];
	}tree[400010];
	int lx,rx;
	
	Seg_Tree Update(Seg_Tree A,Seg_Tree B)
	{
		Seg_Tree C;
		C.l=A.l; C.r=B.r; C.mid=(A.l+B.r)>>1;
		for (int i=1;i<=4;i++) C.ds[i]=i;
		
		if (Find(1,A.ds)==Find(2,A.ds)) C.ds[2]=1;
		if (Find(3,B.ds)==Find(4,B.ds)) C.ds[4]=3;
		
		for (int i=1;i<=2;i++)
			for (int j=3;j<=4;j++) if (Find(i,A.ds)==Find(j,A.ds))
				for (int k=3;k<=4;k++) if (Find(j-2,B.ds)==Find(k,B.ds))
					Merge(i,k,C.ds);
		
		return C;
	}
	
	void BuildTree(int inx,int lxx,int rxx)
	{
		tree[inx].l=lxx; tree[inx].r=rxx;
		tree[inx].mid=(lxx+rxx)>>1;
		for (int i=1;i<=4;i++) tree[inx].ds[i]=i;
		if (lxx==rxx) return;
		BuildTree(LCH,lxx,tree[inx].mid);
		BuildTree(RCH,tree[inx].mid+1,rxx);
	}
	
	void Upd(int inx)
	{
		if (tree[inx].l==lx && tree[inx].r==lx)
		{
			memset(tree[inx].ds,0,sizeof(tree[inx].ds));
			for (int i=1;i<=4;i++) tree[inx].ds[i]=i;
			
			if (conn[lx][1]) Merge(1,3,tree[inx].ds);
			if (conn[lx][2]) Merge(2,4,tree[inx].ds);
			if (conn[lx][3]) Merge(1,2,tree[inx].ds);
			if (conn[lx+1][3]) Merge(3,4,tree[inx].ds);
			return;
		}
		if (lx<=tree[inx].mid) Upd(LCH);
		else Upd(RCH);
		tree[inx]=Update(tree[LCH],tree[RCH]);
	}
	
	Seg_Tree Qry(int inx)
	{
		if (tree[inx].l>=lx && tree[inx].r<=rx) return tree[inx];
		if (lx>tree[inx].mid) return Qry(RCH);
		else if (rx<=tree[inx].mid) return Qry(LCH);
		else return Update(Qry(LCH),Qry(RCH));
	}
	
	#undef LCH
	#undef RCH
};

char cmd[110];
int main()
{
	readx(n); SGT::BuildTree(1,1,n-1);
	
	int c1,r1,c2,r2;
	while (1)
	{
		scanf("%s",cmd+1);
		if (cmd[1]=='E') return 0;
		readx(r1); readx(c1); readx(r2); readx(c2);
		
		if (cmd[1]=='A')
		{
			SGT::Seg_Tree tmp,tmp2;
			if (c1==c2) 
			{
				if (conn[c1][3]) { printf("Y\n"); continue; }
				if (c1>1) 
				{
					SGT::lx=1; SGT::rx=c1-1; tmp=SGT::Qry(1);
					if (Find(3,tmp.ds)==Find(4,tmp.ds)) { printf("Y\n"); continue; }
				}
				if (c1<n)
				{
					SGT::lx=c1; SGT::rx=n-1; tmp=SGT::Qry(1);
					if (Find(1,tmp.ds)==Find(2,tmp.ds)) { printf("Y\n"); continue; }
				}
				printf("N\n");
			}
			else 
			{
				SGT::lx=min(c1,c2); SGT::rx=max(c1,c2)-1; tmp=SGT::Qry(1);
				if (min(c1,c2)>1)
				{
					SGT::lx=1; SGT::rx=min(c1,c2)-1; tmp2=SGT::Qry(1);
					if (Find(3,tmp2.ds)==Find(4,tmp2.ds)) Merge(1,2,tmp.ds);
				}
				if (max(c1,c2)<n)
				{
					SGT::lx=max(c1,c2); SGT::rx=n-1; tmp2=SGT::Qry(1);
					if (Find(1,tmp2.ds)==Find(2,tmp2.ds)) Merge(3,4,tmp.ds);
				}
				if (c1<c2) r2+=2;
				else r1+=2;
				printf("%c\n",(Find(r1,tmp.ds)==Find(r2,tmp.ds))?'Y':'N');
			}
		}
		else
		{
			if (c1==c2) 
			{
				conn[c1][3]=(cmd[1]=='O');
				if (c1>1) { SGT::lx=c1-1; SGT::Upd(1); }
				if (c1<n) { SGT::lx=c1; SGT::Upd(1); }
			}
			else 
			{
				conn[min(c1,c2)][r1]=(cmd[1]=='O');
				SGT::lx=min(c1,c2); SGT::Upd(1);
			}
		}
	}
}
```

---

## 作者：tjtdrxxz (赞：6)

先简单说下线段树分治。

字面意思，就是按照每次操作的时间进行分治（对于可撤销的）。

很明显，对于图的连通性并查集秒了。对于删边操作，就用可撤销并查集维护就好了。那怎么样在一段区间上加边删边呢？很简单，类似于懒标记，要加的边先放在节点上，最后遍历的时候，直接下传就好了。

需要注意的是，因为每次是一段区间，所以最后要清空此时的操作。

对于这道题，用 ` map ` 维护每条边第一次加入时的时间（后面用 $ a $ 指代），如果要删除这条边，记删除这条边时的时间为 $ b $，就相当于是把 $ a \to b - 1 $ 的时间段给加上一条边。

最后记住把没加进去的边（直到最后都没被删）加进线段树就好了。

时间复杂度 $ O (n \log ^ 2 {n}) $，~~包能过得~~。

code：
```cpp
# include <bits/stdc++.h>
# define endl '\n'
using namespace std;
using size_s = unsigned int;
const int N = 1000000 + 11;
vector <int> q;
int fa[N], siz[N];
int qx[N], qy[N];
int n, m;
int find (int x)
{
	return x == fa[x] ? x : find (fa[x]);
}
bool merge (int x, int y)
{
	x = find (x), y = find (y);
	if (x == y) return 0;
	if (siz[x] < siz[y])
	{
		swap (x, y);
	}
	fa[y] = x;
	siz[x] += siz[y];
	q.push_back (y);
	return 1;
}
void cut ()
{
	int x = q.back ();
	q.pop_back ();
	int y = fa[x];
	fa[x] = x;
	siz[y] -= siz[x];
}
string op[N];
struct SegTree
{
	size_s l, r, mid;
	SegTree *ls, *rs;
	vector <int> stk;
	SegTree (size_s s, size_s t) :
	l {s}, r {t}, mid { (l + r) >> 1 },
	ls {nullptr}, rs {nullptr}
	{
		if (l == r)
		{
			return;
		}
		ls = new SegTree (l, mid + 0);
		rs = new SegTree (mid + 1, r);
	}
	void modify (size_s s, size_s t, int x)
	{
		if (l >= s and r <= t)
		{
			stk.push_back (x);
			return;
		}
		if (mid >= s) ls -> modify (s, t, x);
		if (mid <  t) rs -> modify (s, t, x);
	}
	void solve ()
	{
		int cnt = 0;
		for (auto it : stk)
		{
			int u = qx[it], v = qy[it];
			cnt += merge (u, v);
		}
		if (l == r)
		{
			if (op[l] == "Ask")
			{
				int x = qx[l], y = qy[l];
				if (find (x) == find (y))
				{
					cout << "Y" << endl;
				}
				else
				{
					cout << "N" << endl;
				}
			}
		}
		else
		{
			ls -> solve ();
			rs -> solve ();
		}
		while (cnt --)
		{
			cut ();
		}
	}
};
//# define first fi
//# define second se
map <int, map <int, int> > mp;
int main ()
{
	ios :: sync_with_stdio (0);
	cin.tie (0), cout.tie (0);
	cin >> n;
	for (int i = 1; i <= n * 2; i ++)
	{
		fa[i] = i, siz[i] = 1;
	}
	SegTree tr (1, 1e5 + 5);
	while (cin >> op[++ m])
	{
		if (op[m] == "Exit") break;
		int r1, c1, r2 = 0, c2 = 0;
		int x = 0, y = 0;
		cin >> r1 >> c1 >> r2 >> c2;
		x = (r1 - 1) * n + c1;
		y = (r2 - 1) * n + c2;
		if (x > y) swap (x, y);
		qx[m] = x, qy[m] = y;
		if (op[m] == "Open")
		{
			mp[x][y] = m;
		}
		else if (op[m] == "Close")
		{
			tr.modify (mp[x][y], m - 1, m);
			mp[x].erase (mp[x].find (y));
		}
	}
	for (int u = 1; u <= n * 2; u ++)
	{
		for (auto v : mp[u])
		{
			tr.modify (v.second, m, v.second);
		}
	}
	tr.solve ();
}
```

---

## 作者：pldzy (赞：5)

来顺一下思路？

本篇题解的定位和目的是尽笔者所能帮助大家搞清楚题解区“考虑线段树”这句话背后的逻辑和原因。

换句话说，本题解重点在于理清思路线的来历和去向，而不在于解释线段树 `pushup()` 该怎么维护。

个人建议先去阅读其他题解，在“明白如何做但不知道为什么这么做”的时候阅读本篇题解。

## Solution

### Part 1

首先，抛开这个线段树的 tag，题目询问连通性，点边量级相同，考虑线段树分治套上可撤销并查集做离线的动态图连通性即可。优点是直接无脑套模板就好。

考虑不用动态图连通性，从这个图的特点出发的做法。最终联通的路径一定是一个蛇形，特殊情况是在首尾两端路径形态可能不同。发现单行的话很好做，但是双行的话最终答案路径的形态可能非常复杂，指会在两行之间交替出现，非常不好维护。

### Part 2

考虑这种在类似序列形态的图上“走”的常见套路。通常在一类问题中，我们会考虑用倍增来模拟或者加速我们模拟路径行走的过程。形象地，我们会把可能的行走的路径拆分成若干段，一段一段地跳。即**忽略过程，只记录结果，分段解决子问题**。

回归到这道题，题目询问的是连通性。维护连通性，除了并查集直接维护之外，我们可以考虑从它的传递性入手。同时，发现题目每一次询问的都是在列数上的一个区间，既然是询问区间，我们可以尝试延用上面倍增的思路。

本质上是把原问题拆分成子问题，回答询问时合并拆分出来的、已经预处理过结果的子问题。优点是可以很好地平衡我们修改和查询的复杂度，前提是答案具有可拆段合并性。这种思想其实很常见，比如分块、树剖优化 dp、倍增等等，还有就是本题的线段树优化。表面上的区别是 长度相同分段、不基于序列形态的分段、以及多种长度的分段。

而这道题也能用这种思维，一是根据连通性的传递性，我们的答案具有可拆分、可合并的特性，二是询问可视为基于序列形态上的，这给我们提供了充分划分子问题解决的条件。

### Part 3

言归正传。考虑我们把最后联通 $(r1,c1)$ 和 $(r2,c2)$ 的路径拆成一段一段，那么每一段我们关心的只是它的起点和终点以及它们俩的连通性。同时，根据这一段路径起点终点的列数，我们 似乎 可以把这段路径放入一段列数区间考虑。具体地，对于列数区间 $[l,r]$，我们只维护它的 左上角、左下角、右上角、右下角 相互之间的连通性。

但这样还是不够。因为我们可能会有从列 $l$ 出发，走到列 $k$，然后回到列 $r$，但是 $l<r<k$ 的情况。也即是说，此时我们的路径可能绕到区间 $[l,r]$ 外面，“间接地”把它的两个端点联通起来了。这种情况如何维护？解决方法就是不维护。重新修改定义：对于区间 $[l,r]$，考虑维护 **只走它内部的边** 的前提下，它四个角两两之间的连通性。

这样一来，对于上述的特殊情况，我们有两种解决方式：

- 若 $[l,r]$ 的某个端点不是必须要考虑的点（即它不是询问给出的端点），即我们完全不需要关心 这个点 和 其他点（指区间 $[l,r]$ 的四个角）的连通性。那么上述“走到区间之外”的路径就可以用一个更大的区间 $[l,k]$ 来描述。
- 若 $[l,r]$ 的某个端点是必须要考虑的点（即它是询问给出的端点），即 它 和 其他点（指区间 $[l,r]$ 的四个角）的连通性我们必须要关心（此时两个询问点一个列数是 $l$，一个列数是 $r$，否则可以用第一条进一步归约到此条件）。那么此时我们不仅要考虑上述维护的$[l,r]$ 四个角的连通性，还要考虑它们通过区间之外的边联通起来的情况。这种情况我们就需要把 $[1,l]$ 和 $[r,n]$ 的维护情况一起考虑进来并分类讨论了。但是这种情况只会出现一次（即回答询问的时候），所以我们的复杂度可以保证。

### Part 4

然后考虑怎么维护上面定义的 $[l,r]$ 四个角两两之间的连通性。因为连通性具有传递性，所以这个问题显然可以再一步递归到子问题 $[l,mid]$ 和 $[mid+1,r]$，显然可以通过它们两各自的答案以及 连接这两段区间的边 的存在性（即是否“疏通”或“拥堵”）合并得到。通过不断这样二分递归到子问题，且合并答案的复杂度是 $O(1)$ 的，我们就可以 $O(\log n)$ 得到一个区间的答案了。同理，修改也是 $O(\log n)$ 的，因为被“波及”到的区间同理也只有 $O(\log n)$ 个。

很显然，这个结构就是线段树的结构。而这个最终的解法也是我们非常熟悉的，用线段树维护、合并带修改的信息。这样，我们就得到了 $O(m\log n)$ 的做法。

Bonus：同理，这道题也能用分块维护。

希望经过上述两千字的分析（如果你看明白我在胡什么？），你不会再对题解区“考虑线段树”感到莫名其妙和没有头绪了。

## Code

~~被误导了调了好久……~~

其实没有什么可说的，合并的地方自己画画图搞清楚细节就可以了，回答查询的时候分类讨论一下即可。

注释就不加了，用 $0$ 表示区间左上角，$1$ 表示区间左下角，$2$ 表示区间右上角，$3$ 表示区间右下角。有需要的可以参考一下代码。

$3 \text{KB}$ 左右，海星。

````cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i <= b; ++i)
#define per(i, a, b) for(int i = a; i >= b; --i)

const int maxn = 1e5 + 5;

int n;

#define ls (x << 1)
#define rs (x << 1 | 1)

struct tree{
	bool g[4][4], f[2];
	tree(){ memset(g, 0, sizeof g); memset(f, 0, sizeof f);}
}t[maxn << 2];

inline tree Merge(tree x, tree y){
	tree z;
	z.f[0] = y.f[0], z.f[1] = y.f[1];
	
	rep(i, 0, 3) z.g[i][i] = 1; 
	
	bool Ov = x.f[0] & x.f[1];
	z.g[0][1] = x.g[0][1] | (x.g[0][2] & Ov & y.g[0][1] & x.g[1][3]);
	z.g[0][2] = (x.g[0][2] & x.f[0] & y.g[0][2]) | (x.g[0][3] & x.f[1] & y.g[1][2]);
	z.g[0][3] = (x.g[0][2] & x.f[0] & y.g[0][3]) | (x.g[0][3] & x.f[1] & y.g[1][3]);
	z.g[1][2] = (x.g[1][2] & x.f[0] & y.g[0][2]) | (x.g[1][3] & x.f[1] & y.g[1][2]);
	z.g[1][3] = (x.g[1][2] & x.f[0] & y.g[0][3]) | (x.g[1][3] & x.f[1] & y.g[1][3]);
	z.g[2][3] = y.g[2][3] | (y.g[0][2] & Ov & x.g[2][3] & y.g[1][3]);
	
	return z;
}

inline void up(int x){
	t[x] = Merge(t[ls], t[rs]);
}

inline void build(int x, int l, int r){
	if(l == r){
		rep(i, 0, 3) t[x].g[i][i] = 1;
		t[x].g[0][2] = t[x].g[1][3] = 1;
		return;
	}
	int mid = l + r >> 1;
	build(ls, l, mid), build(rs, mid + 1, r);
	up(x);
}

inline tree qryr(int x, int l, int r, int L, int R){
	if(l >= L and r <= R) return t[x];
	int mid = l + r >> 1;
	if(R <= mid) return qryr(ls, l, mid, L, R);
	if(L > mid) return qryr(rs, mid + 1, r, L, R);
	return Merge(qryr(ls, l, mid, L, R), qryr(rs, mid + 1, r, L, R));
}

inline void updtp1(int x, int l, int r, int p, int o, bool v){
	if(r == p){
		t[x].f[o] = v;
		int mid = l + r >> 1;
		if(l != r){
			updtp1(rs, mid + 1, r, p, o, v);
			up(x);
		}
		return;
	}
	
	int mid = l + r >> 1;
	if(mid == p){
		t[ls].f[o] = v;
		updtp1(ls, l, mid, p, o, v);
		up(x); 
		return;
	}
	if(p < mid) updtp1(ls, l, mid, p, o, v); 
	else updtp1(rs, mid + 1, r, p, o, v);
	up(x);
}

inline void updtp2(int x, int l, int r, int p, bool v){
	if(l == r){
		t[x].g[0][1] = t[x].g[2][3] = t[x].g[0][3] = t[x].g[1][2] = v;
		return;
	}
	int mid = l + r >> 1;
	if(p <= mid) updtp2(ls, l, mid, p, v); 
	else updtp2(rs, mid + 1, r, p, v);
	up(x);
}

int main(){
	scanf("%d", &n);
	build(1, 1, n);
	
	while(true){
		char str[15]; scanf("%s", str);
		if(str[0] == 'E') return 0;
		int r1, c1, r2, c2;
		scanf("%d%d%d%d", &r1, &c1, &r2, &c2);
		
		if(str[0] == 'A'){
			if(c1 > c2) swap(r1, r2), swap(c1, c2);
			tree nw = qryr(1, 1, n, c1, c2);
			tree lft = qryr(1, 1, n, 1, c1);
			tree rgh = qryr(1, 1, n, c2, n);
			
			if(r1 == r2 and c1 == c2){ printf("Y\n"); continue;}
			
			if(c1 == c2){
				if(nw.g[0][1] or lft.g[2][3] or rgh.g[0][1]) printf("Y\n");
				else printf("N\n");
				continue;
			} 
			
			bool u = r1 - 1, v = r2 - 1;
			if(nw.g[u][2 + v]){ printf("Y\n"); continue;}
			
			bool cl = lft.g[2 + min(u, !u)][2 + max(u, !u)],
				cr = rgh.g[min(v, !v)][max(v, !v)];
			if((cl and nw.g[!u][2 + v]) or (cr and nw.g[u][2 + (!v)]) or (cl and cr and nw.g[!u][2 + (!v)]))
				printf("Y\n");
			else printf("N\n");
		} else{
			if(r1 == r2) updtp1(1, 1, n, c1, r1 - 1, str[0] == 'O' ? 1 : 0);
			else updtp2(1, 1, n, c1, str[0] == 'O' ? 1 : 0); 
		}
	}
	return 0;
}
````

---

## 作者：GoldenPotato137 (赞：5)

[戳我获得更好的阅读体验qwq](https://www.goldenpotato.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/luogu-p4246-shoi2008%E5%A0%B5%E5%A1%9E%E7%9A%84%E4%BA%A4%E9%80%9A/)

---
# Solution
~~这题的确是有线段树上大分类讨论的在线做法~~，但是本菜鸡还是想主要讲一下离线暴力做法。

.

这题我们考虑离线下来搞。离线之后，我们会发现，**某条边会在某些询问区间中出现。**

考虑**以询问的编号为下标建线段树，我们把每一条边出现的时间段全部加到线段树里面去。**

接下来，直接**在线段树上跑dfs**,每到一个区间，就把这个区间里面存的边通通在并查集中连上；每完成一个区间，就把这个区间连上的边通通取消（类似于回溯）。

这样搞，我们每次到一个叶子节点的时候，这个叶子节点代表的询问上所要连的边一定已经全部连上了，直接在并查集中查询任意节点的父亲的$size$是否为$n$即可。

因为我们这里有撤销（回溯）操作，因此必需使用**按秩合并**的并查集。我们只需要开一个栈，把每次修改的fa的节点记录下来即可完成撤销的操作。

对于边和点，我们大力编号一下即可qwq。

.

时间复杂度$O(nlog^2n)$ 吗？

问题是这玩意能过啊.....
~~因此，我们的时间复杂度是$O($能过$)$~~

就酱，我们又切掉一道题啦。(ﾉﾟ∀ﾟ)ﾉ 

---
# Code
**数据生成器**

[在这里qwq](https://www.goldenpotato.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/luogu-p4246-shoi2008%E5%A0%B5%E5%A1%9E%E7%9A%84%E4%BA%A4%E9%80%9A/)

**正解**
```cpp
//Luogu P4246 [SHOI2008]堵塞的交通
//Mar,22ed,2019
//线段树分治离线维护动态图连通性
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=100000+100;
const int M=N*4;
int ans[N];
struct UnF
{	
	int size[N],fa[N],mstack[M],top;
	void Init(int n)
	{
		for(int i=1;i<=n;i++)
			size[i]=1;
	}
	int FindFather(int x)
	{
		if(fa[x]==0) return x;
		return FindFather(fa[x]);
	}
	void Link(int x,int y)
	{
		mstack[++top]=0;
		int fa_x=FindFather(x),fa_y=FindFather(y);
		if(size[fa_x]>size[fa_y]) 
			swap(x,y),swap(fa_x,fa_y);
		if(fa_x==fa_y) return;
		mstack[top]=fa_x;	
		fa[fa_x]=fa_y,size[fa_y]+=size[fa_x];
	}
	int Query(int x,int y)
	{
		if(FindFather(x)==FindFather(y))
			return true; 
		return false;
	}
	void Undo()
	{
		if(mstack[top]==0)
		{
			top--;
			return;
		}
		size[fa[mstack[top]]]-=size[mstack[top]];
		fa[mstack[top]]=0;
		top--;
	}
}unf;
struct OP
{
	int s,t,id;
}op[N],op2[M*20],e[M];
struct SegmentTree
{
	#define mid ((now_l+now_r)>>1)
	#define lson (now<<1)
	#define rson (now<<1|1)
	vector <int> w[N<<2];
	void Insert(int l,int r,int x,int now,int now_l,int now_r)
	{
		if(now_l>=l and now_r<=r)
		{
			w[now].push_back(x);
			return;
		}
		if(l<=mid) Insert(l,r,x,lson,now_l,mid);
		if(r>mid) Insert(l,r,x,rson,mid+1,now_r);
	}
	void dfs(int now,int now_l,int now_r)
	{
		if(now_l>now_r) return;
		for(int i=0;i<int(w[now].size());i++)
			unf.Link(e[w[now][i]].s,e[w[now][i]].t);
		if(now_l==now_r)
			ans[now_l]=unf.Query(op[now_l].s,op[now_l].t);
		else
		{
			dfs(lson,now_l,mid);
			dfs(rson,mid+1,now_r);
		}
		for(int i=0;i<int(w[now].size());i++)
			unf.Undo();
	}
	#undef mid
	#undef lson
	#undef rson
}sgt;
int last[M],n,q,p;//q次询问,p个区间
bool w[3][N][3];
inline int GetID(int x,int y,int type)
{
	return ((y-1)*n+x-1)*3+type;
}
inline int GetID2(int x,int y)
{
	return (y-1)*n+x;
}
int main()
{
	freopen("4246.in","r",stdin);
	freopen("4246.out","w",stdout);
	
	n=read();
	char OP[10];
	while(1)
	{
		scanf("%s",OP+1);
		if(OP[1]=='E') break;
		else if(OP[1]=='O' or OP[1]=='C')
		{
			int y1=read(),x1=read(),y2=read(),x2=read(),type=1;
			if(OP[1]=='C') type=0;
			if(x1>x2) swap(x1,x2),swap(y1,y2);
			if(y1>y2) swap(x1,x2),swap(y1,y2);
			if(x2==x1+1)
			{
				if(w[y1][x1][0]==type) continue;
				w[y1][x1][0]=type;
				type=0;
			}
			else
			{
				if(w[y1][x1][2]==type) continue;
				w[y1][x1][2]=w[y2][x2][1]=type;
				type=2;
			}
			
			if(OP[1]=='O')
				last[GetID(x1,y1,type)]=q+1;
			else
			{
				op2[++p].s=last[GetID(x1,y1,type)],op2[p].t=q,op2[p].id=GetID(x1,y1,type);
				last[GetID(x1,y1,type)]=0;
			}
		}
		else
		{
			int y1=read(),x1=read(),y2=read(),x2=read();
			op[++q].s=GetID2(x1,y1),op[q].t=GetID2(x2,y2);
		}
	}
	for(int i=0;i<=6*n+100;i++)
		if(last[i]!=0)
			op2[++p].s=last[i],op2[p].t=q,op2[p].id=i;
			
	for(int i=1;i<=2;i++)
		for(int j=1;j<=n;j++)
			for(int k=0;k<=2;k++)
			{
				e[GetID(j,i,k)].s=GetID2(j,i);
				if(k==0) e[GetID(j,i,k)].t=GetID2(j+1,i);
				if(k==2) e[GetID(j,i,k)].t=GetID2(j,i+1);
			}
	unf.Init(n*2+1);
	for(int i=1;i<=p;i++)
		if(op2[i].s<=op2[i].t)
		{
			sgt.Insert(op2[i].s,op2[i].t,op2[i].id,1,1,q);
			cerr<<op2[i].s<<" "<<op2[i].t<<" "<<op2[i].id<<endl;
		}
		
	sgt.dfs(1,1,q);
			
	for(int i=1;i<=q;i++)
		if(ans[i]==0)
			printf("N\n");
		else
			printf("Y\n");
	return 0;
}

```







---

## 作者：scallop (赞：5)

这道题真是一道非常**好**的的题目。

我们考虑使用线段树维护连通性。分别维护一个区间中

$$[l_1,r_1],[l_1,l_2],[l_1,r_2],[l_2,r_1],[l_2,r_2],[r_1,r_2]$$

这些点的连通性。
我们可以通过一定的讨论来得到 $O(1)$ 的方法通过子树更新信息（有些复杂，见代码）

然后我们可以完成单点修改了。

考虑询问操作。我们发现从点 $x_c$ 走到 $y_c$ 可能有四种情况：

$$1:x_c\to y_c$$
$$2:x_c\to x_{!c}\to y_c$$
$$3:x_c\to y_{!c}\to y_c$$
$$4:x_c\to x_{!c}\to y_{!c}\to y_c$$

其中我们令 $!c$ 表示同一列的另一行。那么我们只需要分情况判断是否可以到达就行了。

```cpp
#include <algorithm>
#include <iostream>
#include <fstream>
#include <cstring>
#include <cstdlib>
#include <complex>
#include <string>
#include <cstdio>
#include <vector>
#include <bitset>
#include <cmath>
#include <ctime>
#include <queue>
#include <stack>
#include <map>
#include <set>
using namespace std;

struct segment
{
	int l;
	int r;
	int sum[2];
	bool e[3][2];
};

struct return_val
{
	bool e[3][2];
	bool operator = (const return_val &x)
	{
		for (int i = 0; i < 3; ++i)
		{
			for (int j = 0; j < 2; ++j)
				e[i][j] = x.e[i][j];
		}
	}
};

const int MAXN = 2e5 + 100;
int n, cnt;
bool a[MAXN][2];
segment tree[MAXN];

void pushup(int p)
{
	if (tree[p].l == tree[p].r)
		return;
	int l = p * 2, r = p * 2 + 1, mid = (tree[p].l + tree[p].r) / 2;
	memset(tree[p].e, 0, sizeof tree[p].e);
	tree[p].e[0][0] = (tree[l].e[0][0] && tree[r].e[0][0] && a[mid][0]) || (tree[l].e[0][1] && tree[r].e[1][0] && a[mid][1]);
	tree[p].e[0][1] = (tree[l].e[0][0] && tree[r].e[0][1] && a[mid][0]) || (tree[l].e[0][1] && tree[r].e[1][1] && a[mid][1]);
	tree[p].e[1][0] = (tree[l].e[1][0] && tree[r].e[0][0] && a[mid][0]) || (tree[l].e[1][1] && tree[r].e[1][0] && a[mid][1]);
	tree[p].e[1][1] = (tree[l].e[1][0] && tree[r].e[0][1] && a[mid][0]) || (tree[l].e[1][1] && tree[r].e[1][1] && a[mid][1]);
	tree[p].e[2][0] = tree[l].e[2][0] || (tree[p].e[0][1] && tree[p].e[1][1]) || (tree[p].e[0][0] && tree[p].e[1][0]) || (tree[p].e[0][0] && tree[p].e[1][1] && tree[r].e[2][1]) || (tree[l].e[0][0] && tree[l].e[1][1] && tree[r].e[2][0] && a[mid][0] && a[mid][1]);
	tree[p].e[2][1] = tree[r].e[2][1] || (tree[p].e[0][0] && tree[p].e[0][1]) || (tree[p].e[1][0] && tree[p].e[1][1]) || (tree[p].e[0][0] && tree[p].e[1][1] && tree[l].e[2][0]) || (tree[r].e[0][0] && tree[r].e[1][1] && tree[l].e[2][1] && a[mid][0] && a[mid][1]);
}

void add_row(int p, int x)
{
	if (tree[p].l == tree[p].r && tree[p].l == x)
		tree[p].e[0][0] = tree[p].e[0][1] = tree[p].e[1][0] = tree[p].e[1][1] = tree[p].e[2][0] = tree[p].e[2][1] = true;
	else if (tree[p].l <= x && tree[p].r >= x)
	{
		int mid = (tree[p].l + tree[p].r) / 2;
		if (x > mid)
			add_row(p * 2 + 1, x);
		else
			add_row(p * 2, x);
		pushup(p);
	}
}

void sub_row(int p, int x)
{
	if (tree[p].l == tree[p].r && tree[p].l == x)
	{
		tree[p].e[0][0] = tree[p].e[1][1] = true;
		tree[p].e[1][0] = tree[p].e[0][1] = false;
		tree[p].e[2][0] = tree[p].e[2][1] = false;
	}
	else if (tree[p].l <= x && tree[p].r >= x)
	{
		int mid = (tree[p].l + tree[p].r) / 2;
		if (x > mid)
			sub_row(p * 2 + 1, x);
		else
			sub_row(p * 2, x);
		pushup(p);
	}
}

void add_column(int p, int x, int c)
{
	if (tree[p].l == tree[p].r && tree[p].l == x)
		a[x][c] = true, tree[p].sum[c] = 1;
	else if (tree[p].l <= x && tree[p].r >= x)
	{
		int mid = (tree[p].l + tree[p].r) / 2;
		if (x > mid)
			add_column(p * 2 + 1, x, c);
		else
			add_column(p * 2, x, c);
		pushup(p);
	}
}

void sub_column(int p, int x, int c)
{
	if (tree[p].l == tree[p].r && tree[p].l == x)
		a[x][c] = false, tree[p].sum[c] = 0;
	else if (tree[p].l <= x && tree[p].r >= x)
	{
		int mid = (tree[p].l + tree[p].r) / 2;
		if (x > mid)
			sub_column(p * 2 + 1, x, c);
		else
			sub_column(p * 2, x, c);
		pushup(p);
	}
}

void open(int l1, int r1, int l2, int r2)
{
	if (l1 == l2)
		add_row(1, l1);
	else
	{
		if (l1 > l2)
			swap(l1, l2);
		if (!a[l1][r1])
		{
			add_column(1, l1, r1);
		}
	}
}

void close(int l1, int r1, int l2, int r2)
{
	if (l1 == l2)
		sub_row(1, l1);
	else
	{
		if (l1 > l2)
			swap(l1, l2);
		if (a[l1][r1])
			sub_column(1, l1, r1);
	}
		
}

return_val query_direct(int p, int l, int r)
{
	if (tree[p].l == l && tree[p].r == r)
		return (return_val){{tree[p].e[0][0], tree[p].e[0][1], tree[p].e[1][0], tree[p].e[1][1], tree[p].e[2][0], tree[p].e[2][1]}};
	else
	{
		return_val t1, t2;
		int mid = (tree[p].l + tree[p].r) / 2;
		if (r > mid)
			t2 = query_direct(p * 2 + 1, max(mid + 1, l), r);
		if (l <= mid)
			t1 = query_direct(p * 2, l, min(mid, r));
		if (l > mid)
			return t2;
		else if (r <= mid)
			return t1;
		else
		{
			return_val ret;
			ret.e[0][0] = (t1.e[0][0] && t2.e[0][0] && a[mid][0]) || (t1.e[0][1] && t2.e[1][0] && a[mid][1]);
			ret.e[0][1] = (t1.e[0][0] && t2.e[0][1] && a[mid][0]) || (t1.e[0][1] && t2.e[1][1] && a[mid][1]);
			ret.e[1][0] = (t1.e[1][0] && t2.e[0][0] && a[mid][0]) || (t1.e[1][1] && t2.e[1][0] && a[mid][1]);
			ret.e[1][1] = (t1.e[1][0] && t2.e[0][1] && a[mid][0]) || (t1.e[1][1] && t2.e[1][1] && a[mid][1]);
			ret.e[2][0] = t1.e[2][0] || (ret.e[0][1] && ret.e[1][1]) || (ret.e[0][0] && ret.e[1][0]) || (ret.e[0][0] && ret.e[1][1] && t2.e[2][1]) || (t1.e[0][0] && t1.e[1][1] && t2.e[2][0] && a[mid][0] && a[mid][1]);
			ret.e[2][1] = t2.e[2][1] || (ret.e[0][0] && ret.e[0][1]) || (ret.e[1][0] && ret.e[1][1]) || (ret.e[0][0] && ret.e[1][1] && t1.e[2][0]) || (t2.e[0][0] && t2.e[1][1] && t1.e[2][1] && a[mid][0] && a[mid][1]);
			return ret;
		}
				
	}
}

int query_left(int l, int r, int c)
{
	while (l < r)
	{
		int mid = (l + r) / 2;
		return_val j = query_direct(1, mid, r);
		if (j.e[c][c])
			r = mid;
		else
			l = mid + 1;
	}
	return r;
}

int query_right(int l, int r, int c)
{
	while (l < r)
	{
		int mid = (l + r + 1) / 2;
		return_val j = query_direct(1, l, mid);
		if (j.e[c][c])
			l = mid;
		else
			r = mid - 1;
	}
	return l;
}

bool query(int l1, int r1, int l2, int r2)
{
	if (l1 > l2)
	{
		swap(l1, l2);
		swap(r1, r2);
	}
	return_val t = query_direct(1, l1, l2);
	if (t.e[r1][r2])
		return true;
	return_val t1 = query_direct(1, 1, l1), t2 = query_direct(1, l2, n);
	bool ld = t1.e[2][1], rd = t2.e[2][0];
	if (ld && t.e[r1 ^ 1][r2])
		return true;
	if (rd && t.e[r1][r2 ^ 1])
		return true;
	if (ld && rd && t.e[r1 ^ 1][r2 ^ 1])
		return true;
	return false;
}

void build(int p, int l, int r)
{
	tree[p].l = l;
	tree[p].r = r;
	if (tree[p].l != tree[p].r)
	{
		int mid = (l + r) / 2;
		build(p * 2, l, mid);
		build(p * 2 + 1, mid + 1, r);
	}
	else
		tree[p].e[0][0] = tree[p].e[1][1] = true;
}

int main()
{
	ios::sync_with_stdio(false);
	cin >> n;
	build(1, 1, n);
	while (true)
	{
		string s;
		cin >> s;
		if (s[0] == 'E')
			break;
		int l1, c1, l2, c2;
		cin >> c1 >> l1 >> c2 >> l2;
		--c1;
		--c2;
		if (s[0] == 'O')
			open(l1, c1, l2, c2);
		if (s[0] == 'C')
			close(l1, c1, l2, c2);
		if (s[0] == 'A')
		{
			if (query(l1, c1, l2, c2))
				printf("Y\n");
			else
				printf("N\n");
		}
	}
	return 0;
}
```

---

## 作者：KSkun (赞：5)

# 题解
本题题解同步发布于我的博客[[SHOI2008]堵塞的交通 题解 | KSkun's Blog](https://ksmeow.moe/traffic_shoi08_sol/)，欢迎来逛~
## 设计可合并的状态
本题是一个线段树维护连通性的题目，那么必然要设计区间信息的合并，设计一个可合并的状态很有必要。这里我的设计是对于区间[l, r]存储(1, l)、(2, l)、(1, r)、(2, r)四个点两两间的连通性，总共有6种（即左上左下右上右下）。另外把横向道路放在线段树外面管理。

合并的时候，我们分情况讨论。例如需要维护左上右下这一情况，可以走的路线一共两种，如下图。
![pic1](https://cdn.luogu.com.cn/upload/pic/14769.png)
将六种情况都处理完毕合并就完成了。

## 修改
**竖向道路：**找到包含这条道路的长度为1的区间（即[x, x]），修改该区间内四种状态（左上右上、左下右下永远连通）即可。

**横向道路：**线段树递归的时候，发现有一个区间的mid和mid+1恰好是横向道路两端的c坐标时，在外部维护的横向道路修改后更新这个区间的信息，因为横向道路的影响是从这个区间开始产生的。

## 查询
直接查[c1, c2]？显然不行，因为有下面这种情况：
![pic2](https://cdn.luogu.com.cn/upload/pic/14770.png)
不一定直接能到，也许要往左往右绕，所以我们还得考虑绕的情况。除了[c1, c2]以外，还要把[1, c1]、[c2, C]两个区间的信息拿到，查c1上下两点，c2上下两点，再查这4个点之间的连通情况。

## 总结
线段树维护连通性，很新奇的用法。这道题的思维难度并不大，但是实现难度不小。主要细节集中于合并区间信息与查询答案的时候。写这个题的时候，用别人题解里的程序拍了好久才改出来。总之是很烦人的就对了。

# 代码
见博客吧…太长了贴出来占版面。

---

## 作者：b6e0_ (赞：4)

### 提供一个在线的不用线段树的 `set` 做法。

我并没有把这题看作序列问题，而一直在图论方面思考这题。

为什么这题**只有横边和竖边**，而不是一般的图呢？肯定是横边和竖边有性质。于是我在挖性质。

横边很好处理，难搞的在竖边。为什么**竖边都是竖直的**，而没有斜着的呢？很特殊，记下来，后面有用。

考虑图中连通的两个点，它们之间的路径有几种情况。

- 它们在同一行内，直接从这一行走过去；
- 在它们之间，经过一些竖边，上上下下地走过去，如图（$1\rightarrow 10$）：

![](https://s2.loli.net/2022/07/30/yDPvRHgCxqXYoJt.png)

- 其中一个或两个点，先回头走一些，经过一条竖边，再往前走，如图（$3\rightarrow 8$）：

![](https://s2.loli.net/2022/07/30/WLVefPlAMZpxqjK.png)

对于第一种情况，将同一行内的一个个连通块看作一条条线段，用两个 `set`（代码中叫 `seg[2]`）分别维护第一行和第二行里每个线段的起点，通过 `lower_bound` 和 `upper_bound` 判断同一行内的两点是否在一条线段中。

对于第三种情况，有一个性质：若从起点往回走，那么**一定会在经过第一条竖边（的某个端点）时沿着竖边走下去/走上去**。因为如果走到了更远的一条竖边，那么在回来时，一定会经过更近的那条竖边的另一个端点，没必要。如图（$5\rightarrow 10$）：

![](https://s2.loli.net/2022/07/30/6lNZi8pGThgPdKB.png)

显然没必要走红路径绕一大圈，走蓝路径就够了。

此时竖边一定竖直的作用就凸显出来了。可以用另一个 `set`（代码中叫 `key`）存哪些位置上有竖边，用 `lower_bound` 和 `upper_bound` 找到离起点和终点最近的一条竖边。另外，可以把竖边所在位置的上下两个点看作同一个点（称作竖点），这样一条上上下下的路径就被拆分了很直的三部分：起点到左边或右边最近的竖点；这个竖点经过一些竖点，到另一个竖点（也必须是终点左边或右边最近的竖点）；另一个竖点到终点。

第一部分和第三部分的路径都在同一行内，可以用上面说的 `seg` 数组判断；对于第二部分，它只跟竖点有关，于是可以再开一个 `set`（代码中叫 `cant`）表示有哪些竖点与**下一个竖点，也就是它在 `key` 中的后继**不连通。查询时用 `lower_bound` 和 `upper_bound` 看 `cant` 内有没有在 起点的竖点 与 终点的竖点 之间的点即可。

对于加边和删边，不难发现每次操作只会对一个竖点产生影响，于是直接维护这四个 `set` 即可。

在线，时间复杂度 $\mathcal O(n\log n)$。

[代码](/paste/3229zo8h)又臭又长，全是分讨和 `set` 的操作，看不懂的估计加了注释也没啥用，就不加了。

---

## 作者：xgzc (赞：4)

### 题解

这里提供几种不用脑子的算法~~（当然是离线的）~~：

#### $\text{LCT}$

记下每条边的删除时间，用$\text{LCT}$维护最大生成树，每次加进一条边时，跟原来那条链上的做比较，删除那条删除时间最短的边即可。

#### 线段树分治

这个算法将每条边的加入和删除时间加入到线段树中，所以在遍历到叶子节点时，那个时刻存在的边都已经在并查集上了，于是直接判断即可。

并查集用按秩合并就可以了，撤销时记得按栈序撤销。

### 代码

这里贴线段树分治的代码

```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#include<vector>
#include<map>
#define RG register
#define clear(x, y) memset(x, y, sizeof(x))

inline int read()
{
	int data = 0, w = 1; char ch = getchar();
	while(ch != '-' && (!isdigit(ch))) ch = getchar();
	if(ch == '-') w = -1, ch = getchar();
	while(isdigit(ch)) data = data * 10 + (ch ^ 48), ch = getchar();
	return data * w;
}

const int maxn(200010);
struct edge { int from, to, beg, end; };
std::pair<int, int> q[maxn], stk[maxn << 2];
std::vector<edge> e;
std::map<int, int> G[maxn];
int fa[maxn], top, q_num, n, id[2][maxn], cnt, size[maxn];
char s[10];

inline int find(int x) { while(x ^ fa[x]) x = fa[x]; return x; }
inline void merge(int x, int y)
{
	int fx = find(x), fy = find(y);
	if(fx == fy) return;
	if(size[fx] > size[fy]) std::swap(fx, fy);
	fa[fx] = fy; size[fy] += size[fx]; stk[++top] = std::make_pair(fx, fy);
}

inline void undo()
{
	int x = stk[top].first, y = stk[top--].second;
	fa[x] = x; size[y] -= size[x];
}

inline void Div(int l, int r, std::vector<edge> E)
{
	std::vector<edge> L, R;
	std::vector<edge>::iterator it;
	int mid = (l + r) >> 1, tmp = top;
	for(it = E.begin(); it != E.end(); ++it)
		if(it -> beg <= l && r <= it -> end) merge(it -> from, it -> to);
		else
		{
			if(it -> beg <= mid) L.push_back(*it);
			if(it -> end > mid)  R.push_back(*it);
		}
	if(l == r) printf("%c\n", find(q[l].first) == find(q[l].second) ? 'Y' : 'N');
	else Div(l, mid, L), Div(mid + 1, r, R);
	while(top > tmp) undo();
}

int main()
{
	n = read();
	for(RG int i = 1; i <= n; i++)
		id[0][i] = ++cnt, id[1][i] = ++cnt;
	for(RG int r1, c1, r2, c2;;)
	{
		scanf("%s", s);
		if(s[0] == 'E') break;
		r1 = read() - 1, c1 = read(), r2 = read() - 1, c2 = read();
		if(s[0] == 'O')
		{
			e.push_back((edge){id[r1][c1], id[r2][c2], q_num + 1, -1});
			G[id[r1][c1]][id[r2][c2]] = G[id[r2][c2]][id[r1][c1]] = e.size() - 1;
		}
		else if(s[0] == 'C') e[G[id[r1][c1]][id[r2][c2]]].end = q_num;
		else if(s[0] == 'A') q[++q_num] = std::make_pair(id[r1][c1], id[r2][c2]);
	}
	for(std::vector<edge>::iterator it = e.begin(); it != e.end(); ++it)
		if(it -> end == -1) it -> end = q_num;
	for(RG int i = 1; i <= n + n; i++) fa[i] = i, size[i] = 1;
	Div(1, q_num, e);
	return 0;
}
```



---

## 作者：DaiRuiChen007 (赞：3)

# 洛谷 P4246 题解



[$\text{Link}$](https://www.luogu.com.cn/problem/P4246)



## 思路分析 



### I. 状态设计

大力讨论连通性，对于每个区间的四个端点（左上、左下、右上、右下）维护两两之间是否联通

具体状态设计如下：

[![vkWf3Q.png](https://s1.ax1x.com/2022/08/01/vkWf3Q.png)](https://imgtu.com/i/vkWf3Q)

我们用 $col_{r,c}$ 维护 $(r,c),(r,c+1)$ 之间的连通性，$row_c$ 维护 $(1,c),(2,c)$ 之间的连通性 



---



### II. 区间合并细节处理



#### 1. 区间合并更新 $l,r$

更新 $l$ 有两种方式：左区间直接更新或者绕道右区间更新，如图所示：

[![vkW9fg.png](https://s1.ax1x.com/2022/08/01/vkW9fg.png)](https://imgtu.com/i/vkW9fg)

更新 $r$ 类似，右区间更新或者绕道左区间更新，如图所示：

[![vkWPpQ.png](https://s1.ax1x.com/2022/08/01/vkWPpQ.png)](https://imgtu.com/i/vkWPpQ)

所以我们可以写出 $l,r$ 的合并代码

```cpp
res.l=(x.l)||(x.u&&col[1][k]&&y.l&&col[2][k]&&x.d);
res.r=(y.r)||(y.u&&col[1][k]&&x.r&&col[2][k]&&y.d);
```



#### 2. 区间合并更新 $u,d$

更新 $u$ 有两种方式：从上方直接走或者绕道下方走，如图所示：

[![vkWilj.png](https://s1.ax1x.com/2022/08/01/vkWilj.png)](https://imgtu.com/i/vkWilj)

更新 $d$ 类似，下面直接走或者绕道上方走，如图所示：

[![vkRjmt.png](https://s1.ax1x.com/2022/08/01/vkRjmt.png)](https://imgtu.com/i/vkRjmt)

所以我们可以写出 $u,d$ 的合并代码

```cpp
res.u=(x.u&&col[1][k]&&y.u)||(x.x&&col[2][k]&&y.y);
res.d=(x.d&&col[2][k]&&y.d)||(x.y&&col[1][k]&&y.x);
```



#### 3. 区间合并更新 $x,y$

更新 $x$ 有两种方法，从上方到右区间或从下方到右区间，如图所示：

[![vkWF6s.png](https://s1.ax1x.com/2022/08/01/vkWF6s.png)](https://imgtu.com/i/vkWF6s)

更新 $y$ 类似，从上方过或从下方过

[![vkWkXn.png](https://s1.ax1x.com/2022/08/01/vkWkXn.png)](https://imgtu.com/i/vkWkXn)

所以我们可以写出 $x,y$ 的合并代码

```cpp
res.x=(x.u&&col[1][k]&&y.x)||(x.x&&col[2][k]&&y.d);
res.y=(x.d&&col[2][k]&&y.y)||(x.y&&col[1][k]&&y.u);
```



### II. 修改操作

如果修改的是某两个纵向相邻的点 $(r,c),(r+1,c)$ 的连通性，我们只需要找到叶子节点 $c$ 然后修改即可

如果修改的是某两个横向相邻的点 $(r,c),(r,c+1)$ 的连通性，我们可以找到第一个满足 $mid=c$ 的区间，然后对这个区间重新 pushup 一遍即可，由于线段树上的每个非叶子结点的 $mid$ 各不相同，且不存在某个非叶子节点的 $mid=n$，所以可以放心更新

当然也可以将包含 $c,c+1$ 的区间全部更新一遍，但是常数略大，不过对复杂度没有影响



### III. 查询操作

本题最大坑点就在于这里的查询操作，注意从 $(r1,c1)$ 到 $(r2,c2)$ 不一定只经过区间 $[c1,c2]$，可能从两侧的区间转移，所以我们要对 $r1,r2$ 的情况分类讨论，对于每种情况计算出绕路的方案

以下均假设 $L=\min(c1,c2),R=\max(c1,c2)$，$ok$ 表示答案

#### 1. 左上到右上

可以不绕路，从左边绕路，从右边绕路，从两边绕路，如图所示（虚线表示从两侧区间绕路）：

[![vkRxTf.png](https://s1.ax1x.com/2022/08/01/vkRxTf.png)](https://imgtu.com/i/vkRxTf)

查询代码如下：

```cpp
ok|=tm.u;
ok|=tl.r&&tm.y;
ok|=tm.x&&tr.l;
ok|=tl.r&&tm.d&&tr.l;
```



#### 2. 左下到右下

同上，四种方法，如图所示：

[![vkRv0P.png](https://s1.ax1x.com/2022/08/01/vkRv0P.png)](https://imgtu.com/i/vkRv0P)

查询码如下：

```
ok|=tm.d;
ok|=tl.r&&tm.x;
ok|=tm.y&&tr.l;
ok|=tl.r&&tm.u&&tr.l;
```



#### 3. 左上到右下

同上，四种方法，如图所示：

[![vkWSk8.png](https://s1.ax1x.com/2022/08/01/vkWSk8.png)](https://imgtu.com/i/vkWSk8)



查询代码如下：

```cpp
ok|=tm.x;
ok|=tl.r&&tm.d;
ok|=tm.u&&tr.l;
ok|=tl.r&&tm.y&&tr.l;
```



#### 4. 左下到右上

同上，四种方法，四种方法：

[![vkWptS.png](https://s1.ax1x.com/2022/08/01/vkWptS.png)](https://imgtu.com/i/vkWptS)

查询代码如下：

```cpp
ok|=tm.y;
ok|=tl.r&&tm.u;
ok|=tm.d&&tr.l;
ok|=tl.r&&tm.x&tr.l;
```



### IV. 总结

设 $Q$ 为操作总数，时间复杂度 $\Theta((Q+C)\log C)$，空间复杂度 $\Theta(C)$

> 总结：
>
> 这道题好像想到线段树就迎刃而解了（查询的时候绕道除外）
>
> 线段树解决区间问题是相当方便的，注意分类讨论的时候一定要完整详细
>
> 本题更新两个相邻节点之间信息的 trick 值得学习

## 代码呈现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e5+1;
int n;
bool row[MAXN],col[3][MAXN];
struct node {
	bool l,r,u,d,x,y;
	node() { l=r=u=d=x=y=false; }
};
class SegmentTree {
	private:
		node tree[MAXN<<2];
		inline node merge(node x,node y,int k) {
			node res;
			res.l=(x.l)||(x.u&&col[1][k]&&y.l&&col[2][k]&&x.d);
			res.r=(y.r)||(y.u&&col[1][k]&&x.r&&col[2][k]&&y.d);
			res.u=(x.u&&col[1][k]&&y.u)||(x.x&&col[2][k]&&y.y);
			res.d=(x.d&&col[2][k]&&y.d)||(x.y&&col[1][k]&&y.x);
			res.x=(x.u&&col[1][k]&&y.x)||(x.x&&col[2][k]&&y.d);
			res.y=(x.d&&col[2][k]&&y.y)||(x.y&&col[1][k]&&y.u);
			return res;
		}
		inline int left(int x) {
			return x<<1;
		}
		inline int right(int x) {
			return x<<1|1;
		}
		inline void pushup(int pos,int mid) {
			tree[pos]=merge(tree[left(pos)],tree[right(pos)],mid);
		}
	public:
		inline void Build(int l=1,int r=n,int pos=1) {
			if(l==r) {
				tree[pos].u=tree[pos].d=true;
				tree[pos].l=tree[pos].r=false;
				tree[pos].x=tree[pos].y=false;
				return ;
			}
			int mid=(l+r)>>1;
			Build(l,mid,left(pos));
			Build(mid+1,r,right(pos));
			pushup(pos,mid);
		}
		inline void ModifyRow(int u,int l=1,int r=n,int pos=1) {
			if(l==r) {
				tree[pos].u=tree[pos].d=true;
				tree[pos].l=tree[pos].r=row[u];
				tree[pos].x=tree[pos].y=row[u];
				return ;
			}
			int mid=(l+r)>>1;
			if(u<=mid) ModifyRow(u,l,mid,left(pos));
			else ModifyRow(u,mid+1,r,right(pos));
			pushup(pos,mid);
		}
		inline void ModifyCol(int u,int l=1,int r=n,int pos=1) {
			int mid=(l+r)>>1;
			if(u==mid) {
				if(l!=r) pushup(pos,mid);
				return ;
			} 
			if(u<mid) ModifyCol(u,l,mid,left(pos));
			else ModifyCol(u,mid+1,r,right(pos));
			pushup(pos,mid);
		}
		inline node Query(int ql,int qr,int l=1,int r=n,int pos=1) {
			if(ql<=l&&r<=qr) return tree[pos];
			int mid=(l+r)>>1;
			if(qr<=mid) return Query(ql,qr,l,mid,left(pos));
			if(mid<ql) return Query(ql,qr,mid+1,r,right(pos));
			return merge(Query(ql,qr,l,mid,left(pos)),Query(ql,qr,mid+1,r,right(pos)),mid);
		}
}	S;
signed main() {
	cin>>n;
	S.Build();
	while(true) {
		string opt;
		cin>>opt;
		if(opt=="Exit") break;
		int r1,c1,r2,c2;
		cin>>r1>>c1>>r2>>c2;
		if(opt=="Ask") {
			if(c1>c2) swap(c1,c2),swap(r1,r2);
			auto tl=S.Query(1,c1),tm=S.Query(c1,c2),tr=S.Query(c2,n);
			bool ok=false;
			if(r1==1&&r2==1) {
				ok|=tm.u;
				ok|=tl.r&&tm.y;
				ok|=tm.x&&tr.l;
				ok|=tl.r&&tm.d&&tr.l;
			}
			if(r1==2&&r2==2) {
				ok|=tm.d;
				ok|=tl.r&&tm.x;
				ok|=tm.y&&tr.l;
				ok|=tl.r&&tm.u&&tr.l;
			}
			if(r1==1&&r2==2) {
				ok|=tm.x;
				ok|=tl.r&&tm.d;
				ok|=tm.u&&tr.l;
				ok|=tl.r&&tm.y&&tr.l;
			}
			if(r1==2&&r2==1) {
				ok|=tm.y;
				ok|=tl.r&&tm.u;
				ok|=tm.d&&tr.l;
				ok|=tl.r&&tm.x&tr.l;
			}
			if(ok) puts("Y");
			else puts("N");
		} else {
			bool f;
			if(opt=="Close") f=false;
			if(opt=="Open") f=true;
			int c=min(c1,c2);
			if(c1==c2) {
				row[c]=f;
				S.ModifyRow(c);
			} else {
				col[r1][c]=f;
				S.ModifyCol(c);
			}
		}
	}
	return 0;
}
```

---

## 作者：_anll_ (赞：2)

好多大力讨论和动态图连通性的题解，但为什么不无脑离线用可撤销并查集维护呢？~~才不是我不会前面的做法呢...~~

## 思路
前置知识：[P5787 二分图 /【模板】线段树分治](https://www.luogu.com.cn/problem/P5787) 切掉了这道题回来看这道差不多就是套板子的程度了。

考虑将操作离线下来后根据时间轴进行维护。具体地，你发现每条连线都会有时效性，我们随便离散化一下存储当前连线在哪段时间生效即可。特别地，样例也说明了会有一些连线直到询问结束依旧生效，我们需要额外进行一次遍历处理这些连线。

我们按时间轴建立线段树，将每条连线挂在它对应的区间上，类似地将询问挂在对应的点上。处理好后按照惯例遍历一次线段树即可。在进入当前区间时将连线并在一起，走到叶子结点就判断两点是否在一个并查集里，离开区间的时候再撤销即可。

可撤销并查集和线段树的时间复杂度均为 $O(\log n)$，故总时间复杂度为 $O(\log^2 n)$，可以通过本题。

## 代码
离线那段写的有点丑，将就看吧唉。
```cpp
#include<map>
#include<vector>
#include<iostream>
#include<unordered_map>
#define lc p<<1
#define rc p<<1|1
#define C 8281027
#define endl '\n'
#define fir first
#define sec second
#define mid (l+r)/2
using namespace std;
const int N=1e5+5;
struct H{
	int x,y,z;
}stk[N];
int n,m,tot,qlen,top,fas[N],siz[N];
unordered_map<int,int> id;
map<pair<int,int>,int> mo;
vector<pair<int,pair<int,int> > > as;
vector<int> num[N<<2],ask[N<<2];
pair<pair<int,int>,pair<int,int> > q[N];
void upd_road(int L,int R,int l,int r,int p,int k){
	if(L<=l&&r<=R) return void(num[p].push_back(k));
	if(L<=mid) upd_road(L,R,l,mid,lc,k);
	if(mid<R) upd_road(L,R,mid+1,r,rc,k);
}
void upd_ask(int a,int l,int r,int p,int k){
	if(l==r) return void(ask[p].push_back(k));
	if(a<=mid) upd_ask(a,l,mid,lc,k);
	else upd_ask(a,mid+1,r,rc,k);
}
int Findfa(int x){
	return (x==fas[x]?x:Findfa(fas[x]));
}
void HB(int x,int y){
	int fx=Findfa(x),fy=Findfa(y);
	if(fx==fy) return;
	if(fx>fy) swap(fx,fy);
	if(siz[fx]<siz[fy]) swap(fx,fy);
	fas[fy]=fx,siz[fx]+=siz[fy];
	stk[++top]={fx,fy,siz[fy]};
}
void work(int l,int r,int p,int now=top){
	for(auto a:num[p])
		HB(q[a].fir.fir,q[a].fir.sec);
	if(l==r){
		for(auto a:ask[p]){
			int x=as[a].sec.fir,y=as[a].sec.sec;
			int fx=Findfa(x),fy=Findfa(y);
			cout<<(fx==fy?"Y\n":"N\n");
		}
	}
	else work(l,mid,lc),work(mid+1,r,rc);
	while(now<top){
		H a=stk[top--];
		fas[a.y]=a.y,siz[a.x]-=a.z;
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;string s;int a1,b1,a2,b2;
	for(int i=1;i<=2*n;i++) fas[i]=i,siz[i]=1;
	while(1){
		cin>>s;
		if(s[0]=='E') break;
		m++;cin>>a1>>b1>>a2>>b2;
		int x=a1*C+b1,y=a2*C+b2;
		if(!id[x]) id[x]=++tot;
		if(!id[y]) id[y]=++tot;
		x=id[x],y=id[y];
		if(s[0]=='O') if(!mo[{x,y}]) mo[{x,y}]=m;
		if(s[0]=='C') if(mo[{x,y}]) q[++qlen]={{x,y},{mo[{x,y}],m-1}},mo[{x,y}]=0;
		if(s[0]=='A') as.push_back({m,{x,y}});
	}
	for(auto x:mo){
		int a=x.second;if(!a) continue;
		q[++qlen]={x.first,{a,m}};
	}
	for(int i=1;i<=qlen;i++)
		upd_road(q[i].sec.fir,q[i].sec.sec,1,m,1,i);
	for(int i=0;i<as.size();i++)
		upd_ask(as[i].fir,1,m,1,i);
	work(1,m,1);
	return 0;
}
```

---

## 作者：thh_loser (赞：2)

# P4246 [SHOI2008] 堵塞的交通 题解

[题目链接](https://www.luogu.com.cn/problem/P4246)

## 思路

首先暴力的思路是很显然的，疏通时用并查集维护，堵塞时直接全部重构即可。但是很明显时间是不够的，于是我们需要优化暴力。~~（因为太蒻了根本不会动态树所以只能使用暴力了）~~

我们发现时间复杂度瓶颈出现在重构并查集上，所以我们考虑用分块进行优化，对块内用并查集进行维护，且由于每次疏通都是相邻两点，我们可以考虑只将两个块的分界单独用数组记录连通性。每次重构时，块内我们只用将长度为 $\sqrt{n}$ 的区间进行重构，这样时间复杂度是可以接受的。

总而言之，对于一条路的疏通与堵塞操作，如果在块内则用并查集更新或重构，块间则用一个数组维护分界点连通性。

对于询问，我们考虑搜索，从一端出发，每次先判断是否与另一点连通，再分别搜向前一块最后一列的两个点和下一块的第一列两个点，每一块最多四个顶点，单次复杂度也是 $ O\left(\sqrt{n} \right) $。

## code
```c++14
#include<bits/stdc++.h>
using namespace std;
int c,len,sum;
int cl[350],tot;
int fa[200010];
bool edg[3][100010];
int vis[3][100010];
stack<pair<int,int> >sta[350];
void build(){//预处理分块 
	int cd=0;
	while(cd<=c){
		tot++;
		cd+=len;
		cl[tot]=cd;
		if(c<=len+cd){
			cl[++tot]=c;
			return;
		}
	}
}
int gc(int x){return lower_bound(cl+1,cl+tot+1,x)-cl;}//找到在哪一块中 
int gf(int x){return (fa[x]==x?x:fa[x]=gf(fa[x]));}//并查集 
void rebuild(int clas,int id1,int id2){//对于块内的重构 
	if(id1>id2)swap(id1,id2);
	for(int i=cl[clas-1]+1;i<=cl[clas];i++)fa[i]=i;
	for(int i=cl[clas-1]+1;i<=cl[clas];i++)fa[i+c]=i+c;
	stack<pair<int,int> >rec;//储存边 
	while(!sta[clas].empty()){
		if(sta[clas].top().first==id1&&sta[clas].top().second==id2){//要删掉的边 
			sta[clas].pop();
		}
		else{
			rec.push(sta[clas].top());
			int fu=gf(sta[clas].top().first),fv=gf(sta[clas].top().second);
			sta[clas].pop();
			if(fu!=fv)fa[fu]=fv;
		}
	}
	sta[clas]=rec;
}
bool asdfghjkl(int do1,int c1,int do2){//深搜判断连通性 
	if(gf(do1)==gf(do2))return 1;
	int k=do1/c;
	vis[k+1][do1-k*c]=sum;
	bool ans=0;
	if(gf(cl[c1-1]+1)==gf(do1)&&edg[1][cl[c1-1]]&&c1!=1&&vis[1][cl[c1-1]]!=sum)ans|=asdfghjkl(cl[c1-1],c1-1,do2);
	if(ans)return 1;
	if(gf(cl[c1-1]+1+c)==gf(do1)&&edg[2][cl[c1-1]]&&c1!=1&&vis[2][cl[c1-1]]!=sum)ans|=asdfghjkl(cl[c1-1]+c,c1-1,do2);
	if(ans)return 1;
	if(gf(cl[c1])==gf(do1)&&edg[1][cl[c1]]&&c1!=tot&&vis[1][cl[c1]+1]!=sum)ans|=asdfghjkl(cl[c1]+1,c1+1,do2);
	if(ans)return 1;
	if(gf(cl[c1]+c)==gf(do1)&&edg[2][cl[c1]]&&c1!=tot&&vis[2][cl[c1]+1]!=sum)ans|=asdfghjkl(cl[c1]+1+c,c1+1,do2);
	return ans;
	//搜索四个顶点 
}
int main(){
//	freopen("trac.in","r",stdin);
//	freopen("trac.out","w",stdout);
	scanf("%d",&c);
	for(int i=1;i<=c;i++)fa[i]=i; 
	for(int i=1;i<=c;i++)fa[i+c]=i+c;
	len=sqrt(c);
	build();
	while(1){
		string s;
		int ri,ci,rri,cci;
		cin>>s;
		if(s[0]=='E')break;
		scanf("%d%d%d%d",&ri,&ci,&rri,&cci);
		if(ci>cci){
			swap(ri,rri);
			swap(ci,cci);
		}
		int dot1=ci+(ri-1)*c,dot2=cci+(rri-1)*c;
		int clas1=gc(ci),clas2=gc(cci);
		if(s[0]=='O'){
			if(clas1!=clas2)edg[ri][ci]=1;
			else{
				int fu=gf(dot1),fv=gf(dot2);
				if(fu!=fv)fa[fu]=fv;
				sta[clas1].push(make_pair(dot1,dot2));
			}
		}
		else if(s[0]=='C'){
			if(clas1!=clas2){
				edg[ri][ci]=0;//edg表示块间分界处的连通性 
			}
			else{
				rebuild(clas1,dot1,dot2);//块内则重构 
			}
		}
		else{
			sum++;
			cout<<(asdfghjkl(dot1,clas1,dot2)?("Y\n"):("N\n"));
		}
	}
	return 0;
}
```

---

## 作者：JMercury (赞：1)

这题是某天的一个考试题。然后下来看题解，感觉思路大概明白以后开始写，结果还是写了很长时间。。。我觉得评成**黑题**应该问题不大

---

### 线段树每个节点保存的信息

$l,r$:左、右端点$l$

$luld$:从左上角$(l,1)$是否能达到左下角$(l,2)$

$rurd$:从右上角$(r,1)$是否能达到右下角$(r,2)$

其他几个类似就不解释了。注意，这里的连通性，是考虑的**在$[l,r]$内行走是否连通**

### 节点信息更新的问题

这里拿一个举例子，$luld$。其他的方法大同小异。如果实在想不明白可以看看代码

从左上角走到左下角有两种方法。

1.直接在左半部分走下去。故$luld(p<<1)=true$可推出以$luld(p)=true$

2.绕到右半部分，然后走到下面去以后走回来。这种情况很麻烦，它要求这些路是连通的

（1）左半部分可以从左上角走到右上角，即$luru(p<<1)=true$

（2）从上面可以从左半部分走到右半部分。由于这只涉及到一条路，所以这个拿一个数组在外面维护就可以了

（3）右半部分可以从左上角走到右下角，即$luld(p<<1|1)=true$

（4）从下面可以从右半部分走到左半部分，同（2）

（5）左半部分可以从上面从左走到右，即$luru(p<<1)=true$

然后就这么更新就可以了。

### 询问时的操作

还是有很多情况。比如我们询问从$(1,y_1)$是否能走到$(1,y_2)$。

（1）在$[y_1,y_2]$内就可以直接走过去

（2）要先通过$[1,y_1]$这个部分走到$(2,y_1)$，然后再在$[y_1,y_2]$内走过去

（3）要先通过$[y_2,n]$这个部分走到$(2,y_2)$，然后再在$[y_1,y_2]$内走过去

（4）要先通过$[1,y_1]$这个部分走到$(2,y_1)$，然后再在$[y_1,y_2]$内走到$(2,y_2)$，最后通过$[y_2,n]$这个部分走到$(1,y_2)$

所以有4个方法判。而关于在某个区域内是否能从一个角走到另一个角，这个可以合并线段树解决了。

### 总结

总的来说，这个题算法首先就很难想到，即使想到是线段树也比较难想到维护6个变量，最后判断连通性很容易掉情况；码量很大，然后还极容易犯错（坑点很多，详见代码）。（为什么这不是黑题……）

### AC代码

```cpp
#include<bits/stdc++.h>
const int maxn=100010;
using namespace std;

int n;
bool U[maxn],D[maxn];
struct SegmentTree
{
    int l,r;
    bool luld,luru,lurd,ldru,ldrd,rurd;
    #define l(a) tree[a].l
    #define r(a) tree[a].r
    #define m(a) ((l(a)+r(a))>>1)
    #define luld(a) tree[a].luld
    #define luru(a) tree[a].luru
    #define lurd(a) tree[a].lurd
    #define ldru(a) tree[a].ldru
    #define ldrd(a) tree[a].ldrd
    #define rurd(a) tree[a].rurd
}tree[maxn<<2];

void Update(int p) ///更新节点信息
{
    luld(p)=(luld(p<<1) || (luru(p<<1) && ldrd(p<<1) && luld(p<<1|1) && U[m(p)] && D[m(p)]));
    rurd(p)=(rurd(p<<1|1) || (luru(p<<1|1) && ldrd(p<<1|1) && rurd(p<<1) && U[m(p)] && D[m(p)]));
    lurd(p)=((luru(p<<1) && U[m(p)] && lurd(p<<1|1)) || ((lurd(p<<1) && D[m(p)] && ldrd(p<<1|1))));
    ldru(p)=((ldru(p<<1) && U[m(p)] && luru(p<<1|1)) || ((ldrd(p<<1) && D[m(p)] && ldru(p<<1|1))));
    luru(p)=((luru(p<<1) && U[m(p)] && luru(p<<1|1)) || ((lurd(p<<1) && D[m(p)] && ldru(p<<1|1))));
    ldrd(p)=((ldru(p<<1) && U[m(p)] && lurd(p<<1|1)) || ((ldrd(p<<1) && D[m(p)] && ldrd(p<<1|1))));
}

void BuildTree(int p,int l,int r)
{
    l(p)=l,r(p)=r;
    if(l==r)
    {
        luru(p)=ldrd(p)=true; ///这是一个小坑
        return;
    }
    BuildTree(p<<1,l,m(p));
    BuildTree(p<<1|1,m(p)+1,r);
}

void Change1(int p,int goal,bool ud,bool oc) ///修改横向边的信息
{
    if(m(p)==goal)
    {
        if(ud) U[goal]=oc;
        else D[goal]=oc;
        Update(p); ///注意和下面的Change2对比一下，为什么下面一个不用Update？
        return;
    }
    Change1((p<<1)+(goal>m(p)),goal,ud,oc);
    Update(p);
}

void Change2(int p,int goal,bool oc)
{
    if(l(p)==r(p))
    {
        luld(p)=rurd(p)=lurd(p)=ldru(p)=oc;
        return;
    }
    Change2((p<<1)+(goal>m(p)),goal,oc);
    Update(p);
}

SegmentTree Ask(int p,int l,int r) ///合并线段树
{
    if(l<=l(p) && r>=r(p)) return tree[p];
    if(r<=m(p)) return Ask(p<<1,l,r);
    else if(l>m(p)) return Ask(p<<1|1,l,r);
    else
    {
        SegmentTree TMP,x=Ask(p<<1,l,r),y=Ask(p<<1|1,l,r);
        TMP.luld=(x.luld || (x.luru && x.ldrd && y.luld && U[m(p)] && D[m(p)]));
        TMP.rurd=(y.rurd || (y.luru && y.ldrd && x.rurd && U[m(p)] && D[m(p)]));
        TMP.lurd=((x.luru && U[m(p)] && y.lurd) || ((x.lurd && D[m(p)] && y.ldrd)));
        TMP.ldru=((x.ldru && U[m(p)] && y.luru) || ((x.ldrd && D[m(p)] && y.ldru)));
        TMP.luru=((x.luru && U[m(p)] && y.luru) || ((x.lurd && D[m(p)] && y.ldru)));
        TMP.ldrd=((x.ldru && U[m(p)] && y.lurd) || ((x.ldrd && D[m(p)] && y.ldrd)));
        return TMP;
    }
}

int main()
{
    scanf("%d",&n);
    BuildTree(1,1,n);
    while(1)
    {
        string ss;cin>>ss;
        if(ss=="Exit") break;
        int ux,uy,vx,vy;
        scanf("%d%d%d%d",&ux,&uy,&vx,&vy);
        if(uy>vy) swap(ux,vx),swap(uy,vy);
        if(ss!="Ask")
        {
            if(ux==vx) Change1(1,uy,ux==1,ss[0]=='O');
            else Change2(1,uy,ss[0]=='O');
        }
        else
        {
            bool b=false;
            SegmentTree l=Ask(1,1,uy),m=Ask(1,uy,vy),r=Ask(1,vy,n);
            if(ux==1 && vx==1)
            {
                if(m.luru || (l.rurd && m.ldru) || (r.luld && m.lurd) || (l.rurd && m.ldrd && r.luld)) b=true;
            }
            else if(ux==1 && vx==2)
            {
                if(m.lurd || (l.rurd && m.ldrd) || (r.luld && m.luru) || (l.rurd && m.ldru && r.luld)) b=true;
            }
            else if(ux==2 && vx==1)
            {
                if(m.ldru || (l.rurd && m.luru) || (r.luld && m.ldrd) || (l.rurd && m.lurd && r.luld)) b=true;
            }
            else if(ux==2 && vx==2)
            {
                if(m.ldrd || (l.rurd && m.lurd) || (r.luld && m.ldru) || (l.rurd && m.luru && r.luld)) b=true;
            }
            printf(b? "Y\n":"N\n");
        }
    }
    return 0;
}
```

---

## 作者：qwer6 (赞：0)

这道题有两种写法，一种可以使用线段树分治离线解决，另一种可以直接使用线段树在线解决。  
使用线段树分治的写法十分简单，基本上就是板子，直接按照时间分治，然后使用可撤销的并查集维护联通性即可。  
但是我们发现这种写法并没有利用只有两行的特性。  
那么直接使用线段树呢？  
我们考虑对于一个区间，维护 $6$ 个值，表示左上，左下，右上，右下四个端点之间的连通性。  
那么合并呢？  
我们这里把合并分为两类，一种是不同列之间从左到右的联通性，另外一种是同一列中从上到下的连通性。  
这里假设合并的两个区间为 $[L_1,R_1]$ 和 $[L_2,R_2]$，并且用 $0$ 和 $1$ 表示第一行和第二行，那么 $(0,L_1)$ 就表示第一个区间的左上位置，其他位置以此类推。  
我们考虑第一种，以 $(0,L_1)$ 到 $(1,R_2)$ 为例。  
有这样两条路线：从 $(0,L_1)$ 到 $(0,R_1)$ 再到 $(0,L_2)$ 最后到 $(1,R_2)$，或者从 $(0,L_1)$ 到 $(1,R_1)$ 再到 $(1,L_2)$ 最后到 $(1,R_2)$。  
不理解可以画图理解一下。  
对于第一条路线，我们发现 $(0,L_1)$ 和 $(0,R_1)$，$(0,L_2)$ 和 $(1,R_2)$ 的连通性我们是直接知道的，缺失的只是 $(0,R_1)$ 和 $(0,L_2)$ 之间的连通性，但是其实 $(0,R_1)$ 和 $(0,L_2)$ 之间只有一条边可以到达，我们直接在线段树外开一个数组记录同一行相邻的两个点是否联通，然后在合并的时候判断一下。  
可能有人觉得，我们可以先从 $(0,R_1)$ 到 $(1,R_1)$ 然后到 $(1,L_2)$ 最后到 $(0,L_2)$，但是，这样要求 $(1,R_1)$ 和 $(1,L_2)$ 联通，假设这是一条可行的路线，那么我们在第二条路线中会考虑到这条路线的。  
现在我们来考虑第二种，以 $(0,L_1)$ 到 $(1,L_1)$ 为例。  
首先，如果这两个点原来就是联通的，那么合并后显然还是联通的。  
如果这两个点不联通呢？  
我们想想怎么可以从 $(0,L_1)$ 通过右边到达 $(1,L_1)$，显然要求 $(0,L_1)$ 和 $(0,R_1)$，$(0,R_1)$ 和 $(0,L_2)$，$(0,L_2)$ 和 $(1,L_2)$，$(1,L_2)$ 和 $(1,R_1)$，$(1,R_1)$ 和 $(1,L_1)$ 互相联通。  
为什么我们不通过右边其他可能上下联通的列来走呢？  
和上面第一种合并的理由类似，如果存在其他合法的路线，等同于 $(0,L_2)$ 和 $(1,L_2)$ 联通。  
那么合并就完成了，我们考虑修改。  
修改同一列上下十分简单，我们直接修改即可。  
问题就在于修改两列之间。  
我们发现修改两列之间其实就是通过修改一条边的存在与否来影响区间的联通与否的，而对于 $x$ 到 $x+1$ 两列之间的边，它影响的最小区间为 $[l,r]$，且满足区间中点为 $x$。  
那么这道题就结束了，吗？  
我们发现，对于 $l,r$ 两列的连通性，不只需要考虑 $[l,r]$ 之间的路径，而需要考虑经过 $[1,C]$ 的所有路径。  
那难道线段树是错的吗？  
显然不是，我们发现 $[1,l]$，$[r,C]$ 之间的路径的贡献就是让这一列原来不联通的上下两个点变得联通了。  
原来如此！  
那我们分别求出三段区间 $[1,l],[l,r],[r,C]$，然后使用高超的条件判断技术讨论一下就可以了。  

```c++
/*by qwer6*/
#include<bits/stdc++.h>
#define Nxt puts("")
#define Spa putchar(32)
#define Pline puts("------------------------------")
namespace FastIO{
	inline int read(int &a){
		char c=getchar();
		int f=1;
		a=0;
		while(!isdigit(c)){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(isdigit(c)){
			a=(a<<1)+(a<<3)+(c^48);
			c=getchar();
		}
		return a=a*f;
	}
	inline int read(){
		char c=getchar();
		int f=1,a=0;
		while(!isdigit(c)){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(isdigit(c)){
			a=(a<<1)+(a<<3)+(c^48);
			c=getchar();
		}
		return a*f;
	}
	inline void write(int x){
		if(x<0)putchar('-'),x=-x;
		std::stack<int>st;
		do{
		   st.push(x%10);
		   x/=10;
		}while(x);
		while(!st.empty())putchar(st.top()+'0'),st.pop();
		return ;
	}
	inline void tomax(int &a,int b){
		if(a<b)a=b;
		return ;
	}
	inline void tomin(int &a,int b){
		if(a>b)a=b;
		return ;
	}
}
using namespace FastIO;
using namespace std;
const int N=1e5+5,inf=0x3f3f3f3f;
int C,r1,r2,c1,c2;
char opt[15];
bool Road[2][N];
//Road[0/1][i] 表示 (0/1,i) 和 (0/1 i+1) 是否联通 
struct Node{
	int L,R;
	bool l,r;
	//l 表示左上 <-> 左下是否联通  
	//r 表示右上 <-> 右下是否联通 
	bool flag[2][2];
	Node(int _L=0,int _R=0){
		L=_L,R=_R;
		flag[0][0]=flag[1][0]=flag[0][1]=flag[1][1]=l=r=0;
	}
	Node friend operator +(Node a,Node b){
		Node res=Node(a.L,b.R);
		res.flag[0][0]=(a.flag[0][0]&b.flag[0][0]&Road[0][a.R])|(a.flag[0][1]&b.flag[1][0]&Road[1][a.R]);
		res.flag[0][1]=(a.flag[0][0]&b.flag[0][1]&Road[0][a.R])|(a.flag[0][1]&b.flag[1][1]&Road[1][a.R]);
		res.flag[1][0]=(a.flag[1][0]&b.flag[0][0]&Road[0][a.R])|(a.flag[1][1]&b.flag[1][0]&Road[1][a.R]);
		res.flag[1][1]=(a.flag[1][0]&b.flag[0][1]&Road[0][a.R])|(a.flag[1][1]&b.flag[1][1]&Road[1][a.R]);
		res.l=a.l|(a.flag[0][0]&a.flag[1][1]&b.l&Road[0][a.R]&Road[1][a.R]);
		res.r=b.r|(b.flag[0][0]&b.flag[1][1]&a.r&Road[0][a.R]&Road[1][a.R]);
		return res;
	}
};
struct Segment_tree{
	Node c[N<<2];
	#define ls p<<1
	#define rs p<<1|1
	#define mid (l+r>>1)
	void pushup(int p){c[p]=c[ls]+c[rs];}
	void build(int p,int l,int r){
		if(l==r){
			c[p]=Node(l,r);
			c[p].flag[0][0]=c[p].flag[1][1]=1;
			return ;
		}
		build(ls,l,mid),build(rs,mid+1,r);
		pushup(p);
	}
	void change_Line(int p,int l,int r,int x,bool val){//改变一列上下的连通性 
		if(l==r){
			c[p].l=c[p].r=c[p].flag[1][0]=c[p].flag[0][1]=val;
			return ;
		}
		if(mid>=x)change_Line(ls,l,mid,x,val);
		else change_Line(rs,mid+1,r,x,val);
		pushup(p);
	} 
	void change_Row(int p,int l,int r,int x,int id,int val){//改变两列之间的道路状态 
		if(mid==x){
			Road[id][x]=val;
			return pushup(p);
		}
		if(mid>=x)change_Row(ls,l,mid,x,id,val);
		else change_Row(rs,mid+1,r,x,id,val);
		pushup(p);
	}
	Node query(int p,int l,int r,int L,int R){
		if(L<=l&&r<=R)return c[p];
		if(mid>=L&&mid<R)return query(ls,l,mid,L,R)+query(rs,mid+1,r,L,R);
		if(mid>=L)return query(ls,l,mid,L,R);
		return query(rs,mid+1,r,L,R);
	}
}Set;
signed main(){
	read(C);
	Set.build(1,1,C);
	while(1){
		scanf("%s",opt+1);
		if(opt[1]=='E')break;
		read(r1),read(c1),read(r2),read(c2);
		r1--,r2--;
		if(opt[1]=='A'){
			if(c1>c2)swap(c1,c2),swap(r1,r2);
			Node L=Set.query(1,1,C,1,c1),R=Set.query(1,1,C,c2,C),tmp=Set.query(1,1,C,c1,c2);
			bool ans,l=L.r|tmp.l,r=R.l|tmp.r;
			if(c1==c2)ans=l|r;
			else if(l&&r)ans=tmp.flag[0][0]|tmp.flag[0][1]|tmp.flag[1][0]|tmp.flag[1][1];
			else if(l)ans=tmp.flag[0][r2]|tmp.flag[1][r2];
			else if(r)ans=tmp.flag[r1][0]|tmp.flag[r1][1];
			else ans=tmp.flag[r1][r2];
			puts(ans?"Y":"N");
		}else{
			if(c1==c2)Set.change_Line(1,1,C,c1,opt[1]=='O');
			else Set.change_Row(1,1,C,min(c1,c2),r1,opt[1]=='O');
		}
	}
}
```

---

## 作者：Hurraciny (赞：0)

# 背景

第一次写的时候用的线段树常规做法，由于过于复杂写挂了……
第二次写用了线段树分治求图的连通性，写对了。

# 前置芝士🧀

- [线段树分治](https://www.cnblogs.com/Golb/articles/18142070)
- 可撤销并查集

# 分析

题目中给出一个图，要求可以增边、删边并求两个点的连通性。
这不就是动态图求连通性吗，可以想到的一个算法就是线段树分治。

# 具体做法

题目给了我们坐标，~~可是我们不需要坐标啊~~，于是可以给每一个坐标分配一个编号，方便线段树分治操作。

将所有的操作都离线下来，对时间建立线段树，将每一条边的加入时间和删除时间加入线段树中。

对线段树进行 dfs ，用可撤销并查集维护连通性，在此过程中离线记录答案，可因为我们搜索时本来就是按时间顺序搜的，因此早出现的询问必定早计算，这是算完直接输出就不用记录啦～

# 代码
```cpp
#include <iostream>
#include <cstring>
#include <stack>
#include <unordered_map>
#include <vector>
#include <algorithm>

using namespace std;

const int N = 2e5+2;
const int M = 3e5+1;
int ID[3][N];	//给坐标分配的编号
class DSU{	//可撤销并查集：其实就是把操作塞到栈里
private:
	int fa[N];
	int dep[N];
	stack<pair<int, int> >sta;
public:
	inline int size(){
		return sta.size();
	}
	inline void init(int n){
		for(int i = 1; i <= n; i++)
			fa[i] = i, dep[i] = 0;
		while(!sta.empty())
			sta.pop();
	}
	inline int find(int x){
		if(fa[x] == x)
			return x;
		return find(fa[x]);
	}
	inline bool check(int x, int y){
		return find(x) == find(y);
	}
	inline void join(int x, int y){
		x = find(x);
		y = find(y);
		if(x == y)
			return;	
		if(dep[x] > dep[y])
			swap(x, y);
		if(dep[x] == dep[y])
			dep[y]++;
		fa[x] = y;
		sta.push(make_pair(x, y));
	}
	inline void undo(int x){	//撤销到x个节点
		while(sta.size() > x){
			int x = sta.top().first;
			int y = sta.top().second;
			sta.pop();
			if(dep[y] == dep[x]+1)
				dep[y]--;
			fa[x] = x;
		}
	}
};
DSU UN;
typedef struct{
	int tp;
	int x, y;
	inline bool get(){	//操作的输入
		string s;
		cin >> s;
		if(s[0] == 'E')
			return false;
		if(s[0] == 'C')
			tp = 0;
		if(s[0] == 'O')
			tp = 1;
		if(s[0] == 'A')
			tp = 2;
		int r, c;
		scanf("%d%d", &r, &c);
		x = ID[r][c];
		scanf("%d%d", &r, &c);
		y = ID[r][c];
		return true;
	}
}OPT;
OPT a[N];
bool ans[N];
vector<OPT>tree[N<<2];	//线段树
inline int lchild(int x){return x<<1;}
inline int rchild(int x){return x<<1|1;}
inline void modify(int p, int pl, int pr, int l, int r, int x){
	if(pl >= l && pr <= r){
		tree[p].push_back(a[x]);
		return;
	}
	int mid = (pl+pr) >> 1;
	if(mid >= l)
		modify(lchild(p), pl, mid, l, r, x);
	if(mid < r)
		modify(rchild(p), mid+1, pr, l, r, x);
	return;
}
inline void dfs(int p, int pl, int pr){
	int tmp = UN.size();
	for(auto i : tree[p])
		UN.join(i.x, i.y);	//连边
	if(pl == pr){
		if(a[pl].tp == 2)
			puts(UN.check(a[pl].x, a[pl].y) ? "Y" : "N");
		UN.undo(tmp); 
		return;
	}
	int mid = (pl+pr) >> 1;
	dfs(lchild(p), pl, mid);
	dfs(rchild(p), mid+1, pr);
	UN.undo(tmp);
	return;
}
unordered_map<int, int>st[N];	//建边时间
unordered_map<int, int>lst[N];	//删边时间
int main(){
	int n;
	scanf("%d", &n);
	UN.init(2*n);
	int cnt = 0;
	for(int i = 1; i <= 2; i++)
		for(int j = 1; j <= n; j++)
			ID[i][j] = ++cnt;
	cnt = 0;
	while(a[++cnt].get());	//输入
	cnt--;
	for(int i = 1; i <= cnt; i++){
		if(a[i].tp == 0 && st[a[i].x][a[i].y]){
			modify(1, 1, cnt, st[a[i].x][a[i].y], i-1, i);
			st[a[i].x][a[i].y] = st[a[i].y][a[i].x] = 0;
		}
		if(a[i].tp == 1 && !st[a[i].x][a[i].y]){
			st[a[i].x][a[i].y] = st[a[i].y][a[i].x] = i;
			lst[a[i].x][a[i].y] = lst[a[i].x][a[i].y] = i;
		}
	}
	//把没有被删除的边也塞进线段树
	for(int i = 1; i <= cnt; i++)
		if(st[a[i].x][a[i].y] && a[i].tp == 1){
			st[a[i].x][a[i].y] = st[a[i].y][a[i].x] = 0;
			modify(1, 1, cnt, lst[a[i].x][a[i].y], cnt, i);
		}
	//遍历线段树
	dfs(1, 1, cnt);
	return 0;
}
```

---

## 作者：Nuyoah_awa (赞：0)

### 题目大意

一个 $2\times n$ 的棋盘，起初都不连通，然后连通一些边再堵塞一些边后问两点间是否连通。

### 题目分析

先想如果没有堵塞边的情况，那就是裸并查集了，但是考虑到并查集查询合并速度和可撤销性不可兼得，所以很明显并查集做不了。

再看题目里面很有意思的是只有两排，所以感觉可以分类讨论维护区间合并，而且询问也很像区间是否连通（但不完全是，后面再说）。所以可以考虑用线段树维护。

观察一个区间，若区间之间可合并可拆分，最后询问都可以转化为一段区间内四个端点之间是否可以相互连通，假设四个端点为 $a,b,c,d$，我们非常~~草率且~~直接地将我们想知道的连通性命名为 $ab,ac,ad,bc,bd,cd$。

![P4246-1](https://s21.ax1x.com/2024/06/06/pkYT9Bj.png)

然后从线段树最基本的区间合并开始入手。观察下图，以 $ad$ 讨论，不难发现根据已知信息，这个状态可以连通仅有两种可能（图中绿色和橙色方案），然后拓展到所有状态，发现合并时只用枚举连接点走上面还是走下面，能否连通都可根据已知状态得出。分类讨论即可（见下代码）。

![P4246-2](https://s21.ax1x.com/2024/06/06/pkYTpuQ.png)

由于所有改变都可以视为线段树上点修改，区间查询，所以都没有标记，也不用 `push_down`。正常线段树 `push_up` 中分讨即可。

但是在计算答案的时候，可不只是两点作为左右界的区间端点是否连通那么简单，因为有可能他们在这个区间内并不连通，而是从左边或右边绕行连通。但是这样也好判断，就是判断左边的点是否能通过他左边绕行到这一列另一个点，右边同理，再判断绕行后是否能连通，这就是单纯的区间查询端点是否连通了，各种情况同理（依旧是分类讨论，详见代码在此不做过多赘述）。

ps：记得注意一些边界问题：对于初始值，单点的 $ab,cd$ 是连通的；对于单点上下修改，由于单点为边界，不会执行自己对自己的 `push_up`，所以记得修改时除了要改 $ac,bd$，边 $ad,cb$ 也是需要手动改的（亲测会挂，开始交好几发都因为这个问题 $50pts$）。

再说一些看似没有用的小技巧，由于 `push_up` 中和查询操作中都可能会出现区间合并的操作，虽然它们可能格式或者区间可能范围都不相同，但本质都是合并，所以可以略作修改封装到一个函数里，看上去可能没什么用，但是却可以有效避免写错，而且方便调试和找错。

### code
```cpp
#include <iostream>
#include <cstdio>
#define mid ((t[p].l+t[p].r)>>1)
#define ls (p<<1)
#define rs (ls^1)

using namespace std;

const int N = 1e5 + 5;
int n, x1, x2, y1, y2, s[5][N];
string opt;
struct fhq{
	int l, r, ac, bd, ab, cd, ad, bc;
}t[N<<2];

void push_up(fhq &p, fhq lp, fhq rp, int md)
{
	p.ac = lp.ac | (lp.ab & s[1][md] & rp.ac & s[2][md] & lp.cd);
	p.bd = rp.bd | (rp.ab & s[1][md] & lp.bd & s[2][md] & rp.cd);
	p.ab = (lp.ab & s[1][md] & rp.ab) | (lp.ad & s[2][md] & rp.bc);
	p.cd = (lp.cd & s[2][md] & rp.cd) | (lp.bc & s[1][md] & rp.ad);
	p.ad = (lp.ad & s[2][md] & rp.cd) | (lp.ab & s[1][md] & rp.ad);
	p.bc = (lp.bc & s[1][md] & rp.ab) | (lp.cd & s[2][md] & rp.bc);
}

void update1(int p, int x, int val)
{
	if(t[p].l == t[p].r)
	{
		t[p].ac = t[p].bd = t[p].ad = t[p].bc = val;
		return ;
	}
	if(x <= mid)	update1(ls, x, val);
	if(x > mid)		update1(rs, x, val);
	push_up(t[p], t[ls], t[rs], mid);
}

void update2(int p, int ll, int rr)
{
	if(t[p].l == t[p].r)	return ;
	if(ll <= mid)	update2(ls, ll, rr);
	if(rr > mid)	update2(rs, ll, rr);
	push_up(t[p], t[ls], t[rs], mid);
}

fhq query(int p, int ll, int rr)
{
	if(ll <= t[p].l && t[p].r <= rr)
		return t[p];
	fhq res;
	if(ll <= mid && mid < rr)
		push_up(res, query(ls, ll, rr), query(rs, ll, rr), mid);
	else if(ll <= mid)
		res = query(ls, ll, rr);
	else
		res = query(rs, ll, rr);
	return res;
}

void build(int p, int l, int r)
{
	t[p].l = l, t[p].r = r;
	if(l == r)
	{
		t[p].ab = t[p].cd = 1;
		return ;
	}
	build(ls, l, mid), build(rs, mid + 1, r);
}

signed main()
{
    scanf("%d", &n);
    build(1, 1, n);
    while(1)
    {
    	cin >> opt;
    	if(opt == "Exit")	return 0;
    	if(opt == "Close")
    	{
    		scanf("%d %d %d %d", &x1, &y1, &x2, &y2);
			if(y1 > y2)	swap(x1, x2), swap(y1, y2);
    		if(x1 != x2)	update1(1, y1, 0);
    		else
			{
				s[x1][y1] = 0;
				update2(1, y1, y2);
			}
		}
		else if(opt == "Open")
		{
    		scanf("%d %d %d %d", &x1, &y1, &x2, &y2);
			if(y1 > y2)	swap(x1, x2), swap(y1, y2);
    		if(x1 != x2)	update1(1, y1, 1);
    		else
			{
    			s[x1][y1] = 1;
				update2(1, y1, y2);
			}
		}
		else
		{
    		scanf("%d %d %d %d", &x1, &y1, &x2, &y2);
			if(y1 > y2)	swap(x1, x2), swap(y1, y2);
			fhq ans = query(1, y1, y2), ansl = query(1, 1, y1), ansr = query(1, y2, n);
			if(x1 == 1)
			{
				if(x2 == 1)
				{
					if(ans.ab)	puts("Y");
					else if(ans.ad & ansr.ac)	puts("Y");
					else if(ans.bc & ansl.bd)	puts("Y");
					else if(ansl.bd & ans.cd & ansr.ac)	puts("Y");
					else	puts("N");
				}
				else
				{
					if(ans.ad)	puts("Y");
					else if(ansl.bd & ans.cd)	puts("Y");
					else if(ansr.ac & ans.ab)	puts("Y");
					else if(ansl.bd & ans.bc & ansr.ac)	puts("Y");
					else	puts("N");
				}
			}
			else
			{
				if(x2 == 1)
				{
					if(ans.bc)	puts("Y");
					else if(ansl.bd & ans.ab)	puts("Y");
					else if(ansr.ac & ans.cd)	puts("Y");
					else if(ansl.bd & ans.ad & ansr.ac)	puts("Y");
					else	puts("N");
				}
				else
				{
					if(ans.cd)	puts("Y");
					else if(ansl.bd & ans.ad)	puts("Y");
					else if(ansr.ac & ans.bc)	puts("Y");
					else if(ansl.bd & ans.ab & ansr.ac)	puts("Y");
					else	puts("N");
				}
			}
		}
	}
	return 0;
}
```

---

## 作者：船酱魔王 (赞：0)

# P4246 [SHOI2008] 堵塞的交通 题解

## 题意回顾

$ 2 \times n $ 网格，$ 3n-2 $ 条网格边，请你模拟两种操作：

* 将一条网格边改变可用状态。

* 询问两个格点是否可达。

注意初始时所有边不可用。

$ 1 \le n \le 10^5 $，操作次数不超过 $ 10^5 $。

## 分析

动态图连通性问题不好做，考虑观察图的性质是一个比较细长的结构，考虑使用维护序列的数据结构。

线段树维护一个区间所有格子的部分点可达状态，不难想到维护四个角之间是否相互可达，因为单点修改所以只需要快速合并相邻区间即可。

因为如果由一个区间到达另一个区间必然经过两个区间交点，而区间内部可达性已经维护，所以可以对两个小区间涉及到的 $ 6 $ 个点（有 $ 2 $ 个是区间交点）用并查集跑出大区间的可达性。

注意修改时如果是竖线需要修改相邻两个格子，横线只需要修改一个格子。

对于合并时的初值，应该设置为左上右上连通，左下右下连通。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1e5 + 5;
int n;
struct node {
	int f[4][4];
	void out() {
		for(int i = 0; i < 4; i++) {
			for(int j = i + 1; j < 4; j++) {
				if(f[i][j] == 0) continue;
				cout << (char)('A' + i) << (char)('A' + j) << " ";
			}
		}
		cout << endl;
	}
} d[N * 4], zero, col;
int fa[18];
/*
0 2
1 3
*/
int gf(int x) {
	if(fa[x] == x) return x;
	return fa[x] = gf(fa[x]);
}
inline void merge(int x, int y) {
	x = gf(x), y = gf(y);
	if(x != y) fa[x] = y;
}
int id[N];
void colt(int s, int t, int p) {
	if(s == t) {
		id[s] = p;
		return;
	}
	int mid = (s + t) >> 1;
	colt(s, mid, p * 2);
	colt(mid + 1, t, p * 2 + 1);
}
node operator+(node p1, node p2) {
	int tmp[4] = {0, 1, 4, 5};
	for(int i = 0; i < 6; i++) fa[i] = i;
	for(int i = 0; i < 4; i++) {
		for(int j = i + 1; j < 4; j++) {
			if(p1.f[i][j] == 0) continue;
			merge(i, j);
		}
	}
	for(int i = 0; i < 4; i++) {
		for(int j = i + 1; j < 4; j++) {
			if(p2.f[i][j] == 0) continue;
			merge(i + 2, j + 2);
		}
	}
	for(int i = 0; i < 4; i++) {
		for(int j = 0; j < 4; j++) {
			if(gf(tmp[i]) != gf(tmp[j])) p1.f[i][j] = 0;
			else p1.f[i][j] = 1;
		}
	}
	return p1;
}
void update(int x, int s, int t, int p) {
	if(x == 0) return;
	if(s == t) {
		return;
	}
	int mid = (s + t) >> 1;
	if(x <= mid) update(x, s, mid, p * 2);
	else update(x, mid + 1, t, p * 2 + 1);
	d[p] = d[p * 2] + d[p * 2 + 1];
}
node query(int l, int r, int s, int t, int p) {
	if(l > r) return col;
	if(l <= s && t <= r) return d[p];
	int mid = (s + t) >> 1;
	node ans = col;
	if(l <= mid) ans = ans + query(l, r, s, mid, p * 2);
	if(mid < r) ans = ans + query(l, r, mid + 1, t, p * 2 + 1);
	d[p] = d[p * 2] + d[p * 2 + 1];
	return ans;
}
int main() {
	col.f[0][2] = col.f[1][3] = 1;
	scanf("%d", &n);
	string op;
	int x2, y2, x3, y3;
	colt(1, n, 1);
	int ix = 0;
	while(true) {
		cin >> op;
		if(op == "Exit") break;
		scanf("%d%d%d%d", &x2, &y2, &x3, &y3);
		if(op == "Close" || op == "Open") {
			int tp = (op == "Close") ? 0 : 1;
			if(y2 == y3) {
				d[id[y2 - 1]].f[2][3] = tp;
				d[id[y2]].f[0][1] = tp;
				update(y2, 1, n, 1);
				update(y2 - 1, 1, n, 1);
			} else if(x2 == x3) {
				int ii = min(y2, y3);
				if(x2 == 1) d[id[ii]].f[0][2] = tp;
				else d[id[ii]].f[1][3] = tp;
				update(ii, 1, n, 1);
			}
		} else if(op == "Ask") {
			if(y2 > y3) swap(x2, x3), swap(y2, y3);
			node t1 = query(1, y2 - 1, 1, n, 1);
			node t2 = query(y2, y3 - 1, 1, n, 1);
			node t3 = query(y3, n, 1, n, 1);
			for(int i = 0; i < 8; i++) fa[i] = i;
			for(int i = 0; i < 4; i++) {
				for(int j = 0; j < 4; j++) {
					if(t1.f[i][j]) merge(i, j);
					if(t2.f[i][j]) merge(i + 2, j + 2);
					if(t3.f[i][j]) merge(i + 4, j + 4);
				}
			}
			int p1 = (x2 == 1) ? 2 : 3;
			int p2 = (x3 == 1) ? 4 : 5;
			if(gf(p1) == gf(p2)) printf("Y\n");
			else printf("N\n");
		} else {
			printf("dthkxy AK IOI\n");
		}
	}
	return 0;
}

```

---

## 作者：littleKtian (赞：0)

upd on 2020.8.30：重构了整篇题解的排版

------------

此做法并不是最优的，但也是一种思路。

------------

因为整个图只有两行，而且要动态维护点之间的连通性，于是很容易想到用线段树维护区间内 左上/左下 到 右上/右下 是否连通，查询的时候只需要在这个区间内查询连通性就行了。

但这样显然会漏掉一种情况：可能这两个点通过区间外的边连通了，也就是绕了一段。

考虑先把要绕的那段走完，也就是把原来要查询的两个点尽量向两边拓展，走到尽头位置（可以只在某一行走，也可以换行一直走到某个点换不了为止），查询新的两个点的区间内是否连通。容易证明这样得到的答案也是正确的。

走的过程可以直接在线段树上不断去跳。

复杂度 $O(n\log^2 n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct qj{
	int l,r;
	bool lt[2][2];//lt[i][j]表示第i+1行第l座城市是否与第j+1行第r座城市连通
};
qj tree[400005];
bool ro_h[2][100005],ro_l[100005];
char s[10];
int c,r_1,c_1,r_2,c_2;
void csh(int xh,int ll,int rr)
{
	tree[xh].l=ll;tree[xh].r=rr;
	if(ll==rr){tree[xh].lt[0][0]=tree[xh].lt[1][1]=true;return;}
	int mid=(ll+rr)>>1;
	csh(xh*2,ll,mid);csh(xh*2+1,mid+1,rr);
}
void xg_h(int xh,int w)
{
	int mid=(tree[xh].l+tree[xh].r)>>1;
	if(w<mid)xg_h(xh*2,w);
	if(w>mid)xg_h(xh*2+1,w);
	for(int i=0;i<2;i++)
	  for(int j=0;j<2;j++)
	    tree[xh].lt[i][j]=(tree[xh*2].lt[i][0]&&tree[xh*2+1].lt[0][j]&&ro_h[0][mid])||(tree[xh*2].lt[i][1]&&tree[xh*2+1].lt[1][j]&&ro_h[1][mid]);
}
void xg_l(int xh,int w)
{
	if(tree[xh].l==tree[xh].r)
	{
		tree[xh].lt[0][1]=tree[xh].lt[1][0]=ro_l[w];
		return;
	}
	int mid=(tree[xh].l+tree[xh].r)>>1;
	if(w<=mid)xg_l(xh*2,w);
	if(w>mid)xg_l(xh*2+1,w);
	for(int i=0;i<2;i++)
	  for(int j=0;j<2;j++)
	    tree[xh].lt[i][j]=(tree[xh*2].lt[i][0]&&tree[xh*2+1].lt[0][j]&&ro_h[0][mid])||(tree[xh*2].lt[i][1]&&tree[xh*2+1].lt[1][j]&&ro_h[1][mid]);
}
qj ask(int xh,int ll,int rr)
{
	if(ll<=tree[xh].l&&tree[xh].r<=rr)return tree[xh];
	int mid=(tree[xh].l+tree[xh].r)>>1;
	if(ll<=mid&&rr<=mid)return ask(xh*2,ll,rr);
	if(ll>mid&&rr>mid)return ask(xh*2+1,ll,rr);
	qj ans,le=ask(xh*2,ll,rr),ri=ask(xh*2+1,ll,rr);
	ans.l=le.l;ans.r=ri.r;
	for(int i=0;i<2;i++)
	  for(int j=0;j<2;j++)
	    ans.lt[i][j]=(le.lt[i][0]&&ri.lt[0][j]&&ro_h[0][mid])||(le.lt[i][1]&&ri.lt[1][j]&&ro_h[1][mid]);
	return ans;
}
int zy(int xh,int h,int w)
{
	if(w==tree[xh].r)
	{
		if(tree[xh].lt[h][h])
		{
			if(ro_h[h][tree[xh].l-1])return zy(1,h,tree[xh].l-1);//此时城市可以被移到第h+1行第tree[xh].l-1座，因为可能还可以左移，所以进行递归
			else return tree[xh].l;//此时城市只能被移到tree[xh].l，无法继续左移
		}
		else return zy(xh*2+1,h,w);//无法左移，递归右儿子
	}
	else
	{
		int mid=(tree[xh].l+tree[xh].r)>>1;
		if(w<=mid)return zy(xh*2,h,w);
		else return zy(xh*2+1,h,w);
	}
}
int yy(int xh,int h,int w)//和左移同理
{
	if(w==tree[xh].l)
	{
		if(tree[xh].lt[h][h])
		{
			if(ro_h[h][tree[xh].r])return yy(1,h,tree[xh].r+1);
			else return tree[xh].r;
		}
		else return yy(xh*2,h,w);
	}
	else
	{
		int mid=(tree[xh].l+tree[xh].r)>>1;
		if(w<=mid)return yy(xh*2,h,w);
		else return yy(xh*2+1,h,w);
	}
}
int main()
{
	scanf("%d",&c);
	csh(1,1,c);
	scanf("%s",s);
	while(s[0]!='E')
	{
		scanf("%d%d%d%d",&r_1,&c_1,&r_2,&c_2);
		--r_1;--r_2;
		if(c_1>c_2)swap(r_1,r_2),swap(c_1,c_2);
		if(s[0]=='C')
		{
			if(r_1==r_2&&c_1+1==c_2)
			{
				ro_h[r_1][c_1]=false;
				xg_h(1,c_1);
			}
			if(r_1!=r_2&&c_1==c_2)
			{
				ro_l[c_1]=false;
				xg_l(1,c_1);
			}
		}
		if(s[0]=='O')
		{
			if(r_1==r_2&&c_1+1==c_2)
			{
				ro_h[r_1][c_1]=true;
				xg_h(1,c_1);
			}
			if(r_1!=r_2&&c_1==c_2)
			{
				ro_l[c_1]=true;
				xg_l(1,c_1);
			}
		}
		if(s[0]=='A')
		{
			c_1=zy(1,r_1,c_1);c_2=yy(1,r_2,c_2);
			qj x=ask(1,c_1,c_2);
			if(x.lt[r_1][r_2])printf("Y\n");
			else printf("N\n");
		}
		scanf("%s",s);
	}
}
```


---


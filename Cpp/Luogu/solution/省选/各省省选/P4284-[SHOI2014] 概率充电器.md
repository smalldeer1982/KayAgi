# [SHOI2014] 概率充电器

## 题目描述

著名的电子产品品牌 SHOI 刚刚发布了引领世界潮流的下一代电子产品——概率充电器：

“采用全新纳米级加工技术，实现元件与导线能否通电完全由真随机数决定！SHOI 概率充电器，您生活不可或缺的必需品！能充上电吗？现在就试试看吧！”

SHOI 概率充电器由 $n-1$ 条导线连通了 $n$ 个充电元件。进行充电时，每条导线是否可以导电以概率决定，每一个充电元件自身是否直接进行充电也由概率决定。随后电能可以从直接充电的元件经过通电的导线使得其他充电元件进行间接充电。

作为 SHOI 公司的忠实客户，你无法抑制自己购买 SHOI 产品的冲动。在排了一个星期的长队之后终于入手了最新型号的 SHOI 概率充电器。你迫不及待地将 SHOI 概率充电器插入电源——这时你突然想知道，进入充电状态的元件个数的期望是多少呢？

## 说明/提示

对于 $30\%$ 的数据，$n \leq 5 \times 10^3$。

对于 $100\%$ 的数据，$n \leq 5 \times 10^5$，$0 \leq p,q_i \leq 100$。

## 样例 #1

### 输入

```
3
1 2 50
1 3 50
50 0 0```

### 输出

```
1.000000```

## 样例 #2

### 输入

```
5
1 2 90
1 3 80
1 4 70
1 5 60
100 10 20 30 40```

### 输出

```
4.300000```

# 题解

## 作者：asuldb (赞：80)

这是一道概率+树形$dp$

首先我们看到这里每一个的贡献都是1，所以我们要求的**期望就是概率**

求得其实就是这个

$$\sum_{i=1}^nP_i$$

$P_i$为节点$i$通电的概率

显然节点$i$通电有三种可能

1. 它自己来电了

1. 它的子树里有一个点来电了传了过来

1. 它的子树外面有一个点来电了传了过来

第一种情况最好考虑了，至于第二种和第三种我们好像很难解决的样子

但是这显然也告诉了我们这是一个套路题，第二种和第三种正好就是树规里的$up$ $and$ $down$思想

于是我们设$h[i]$表示第$i$个节点通电的概率，之后我们利用$up$ $and$ $down$思想，在第一遍dfs的过程中，$h[i]$表示$i$通电的概率，且电一定来自它自己或者它的子树里（对应第一第二种情况），在第二遍dfs的时候被更新成为电来自于任何地方的概率（对应所有情况）

最开始初始化，$h[i]=a[i]*0.01$电只能来自自己

之后第一遍dfs，树形dp里的$up$，我们要将子树的信息合并给根，由于根通电还是有两种可能

1. 根自己来电了

1. 儿子来电，儿子通向根的边导电

显然这两种情况只需要满足一种就够了

但是合并之后的概率是多少呢，直接加起来显然是不对的~~而我还真加了起来~~

我们考虑有两个事件$A,B$，发生的概率分别是$P(A),P(B)$，那么至少发生一件的概率应该是

$$P(A)+P(B)-P(A)*P(B)$$

这个怎么推出来的，很简单，至少发生一件，那么就有三种可能

1. $A$发生$B$不发生，那么则为$P(A)*(1-P(B))$

1. $B$发生$A$不发生，那么则为$P(B)*(1-P(A))$

1. $A,B$一起发生，那么则为$P(A)*P(B)$

三项合起来最后一化就是$P(A)+P(B)-P(A)*P(B)$

所以我们合并根和子树的信息的时候，$P(A)=h[i],P(B)=h[j]*p(i,j)$，$i$是子树的根，$j$是$i$的儿子,$p(i,j)$是这条边导电的概率

所以$h[i]=P(A)+P(B)-P(A)*P(B)$

之后我们就要考虑$down$了，一个节点有点也有可能来自它的父亲，于是我们采用$down$的思想用父亲更新儿子

显然我们更新一位父亲的某个儿子，显然我们只能用其他点来电传到父亲的概率来更新这个儿子

于是我们设$P(B)=h[j]*p(i,j)$，而且有

$$P(A)+P(B)-P(A)*P(B)=h[i]$$

我们要求的是$P(A)$即除了$j$这棵子树其他点来电使得$i$有电的概率

于是解一下这个方程

$$P(A)-P(A)*P(B)=h[i]-P(B)$$

$$P(A)*(1-P(B))=h[i]-P(B)$$

$$P(A)=\frac{h[i]-P(B)}{1-P(B)}$$

而之后我们去更新儿子的话还有一边是否导电需要考虑，于是

$$h[j]=h[j]+(P(A)*p(i,j))-h[j]*P(A)*p(i,j)$$

之后就没有啦，同时还有一个非常坑的地方就是如果$P(B)=h[j]*p(i,j)=1$

那么除以$1-P(B)$肯定会出错，由于$h[j]$都已经是1了，显然没有什么必要去更新它了，于是可以直接跳过这一层接着往下更新就好了
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define re register
#define maxn 500005
#define eps 1e-7
struct node
{
    int v,nxt,w;
}e[maxn<<1];
int num,n,m;
int a[maxn],head[maxn],deep[maxn];
double h[maxn];
double ans;
inline int read()
{
    char c=getchar();
    int x=0;
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9')
      x=(x<<3)+(x<<1)+c-48,c=getchar();
    return x;
}
inline void add_edge(int x,int y,int z)
{
    e[++num].v=y;
    e[num].nxt=head[x];
    e[num].w=z;
    head[x]=num;
}
void dfs(int x)//up
{
    for(re int i=head[x];i;i=e[i].nxt)
    if(!deep[e[i].v])
    {
        deep[e[i].v]=deep[x]+1;
        dfs(e[i].v);
        double k=h[e[i].v]*double(e[i].w)/100;
        h[x]=h[x]+k-h[x]*k;
    }
}
inline int check(double aa,double bb)
{
    if(aa+eps>bb&&aa-eps<bb) return 1;
    return 0;
}
void redfs(int x)//down
{
    ans+=h[x];
    for(re int i=head[x];i;i=e[i].nxt)
    if(deep[e[i].v]>deep[x])
    {
        if(check(h[e[i].v]*double(e[i].w)/100,1)) 
        {
            redfs(e[i].v);
            continue;
        }
        double k=(h[x]-h[e[i].v]*double(e[i].w)/100)/(1-h[e[i].v]*double(e[i].w)/100);
        k*=double(e[i].w)/100;
        h[e[i].v]=h[e[i].v]+k-k*h[e[i].v];
        redfs(e[i].v);
    }
}
int main()
{
    n=read();
    int x,y,z;
    for(re int i=1;i<n;i++)
    {
        x=read();
        y=read();
        z=read();
        add_edge(x,y,z),add_edge(y,x,z);
    }
    for(re int i=1;i<=n;i++)
        a[i]=read(),h[i]=a[i]*0.01;
    deep[1]=1;
    dfs(1);
    redfs(1);
    printf("%.6lf",ans);
    return 0;
} 

```

---

## 作者：partychicken (赞：40)

## 概率+树型dp

### Part I

拿到这道题的一瞬间，反应了一下——**这不是道假期望题吗？**

为什么？我们考虑这道题的答案

$$\sum p_i*w_i$$

而，$w_i$全TMD是$1$ ！！！所以，就对$p_i$**求个和**就行了。

**所以这题是概率dp**

___

### Part II

考虑这个dp怎么写,一片乌鸦飞过，这TM怎么写啊！！！

聪明的同学不难发现，我们任意选取一个点作为根，然后考虑每个节点，不仅它的子节点可以对它亮的概率产生贡献，它的**父节点同样可以产生贡献**。

这咋dp啊？这dp个p啊？

诶？好像有个做法：我们枚举每个儿子为根，然后对每种情况进行处理，每次根节点的答案是正确的，因为它没有父亲~~（没爹的孩子果然简单易懂呢）~~。复杂度$O(n^2)$,看一眼数据范围，50w，emmm，~~松松松n方过百万~~显然过不去

考虑优化，发现每次换根的贡献只有一部分点，我们把这些点维护一下，复杂度。。。等等，这咋写啊？然后，我的思路就离正解越来越远。。。~~思路逐渐变态~~

___

### Part III

上回书说到，每个点的概率来源有三

- 它的子节点对它的贡献（即整棵子树中有节点进入充电状态，且通过边传递给它的概率）

- 它自己的贡献（即它最初为充电状态的概率）

- 它的父节点对它的贡献（即除子树外的部分有节点进入充电状态，且通过边传递给它的概率）

如果只考虑前两个，貌似dp方程比较显然

$$dp[now]+=(1-dp[now])\times dp[v]\times e[i].val$$

其中，$dp[x]$指点$x$的概率，$v$是$now$的子节点，$e[i].val$是连接$now$,$v$的边连通的概率

然后，考虑父节点的贡献。我们用上面dp转移出的概率从根节点向下转移，这样**每个节点向下转移的时候已经是被充分计算过的**，没有后效性。

感觉哪里不对。。。

以一对儿父子关系为例，$a$是$b$的父节点。第一遍dp的时候，**$b$对$a$产生了贡献**，第二遍dp时**这个贡献又作为$a$的一部分贡献给了$b$**。

发现统计重复了，我们需要的是**$b$对$a$作贡献前$a$的dp值**，换言之，即**把$b$对$a$做的贡献排除出去**。

考虑第一遍的dp方程

$$dp[a]_{now}=dp[a]_{last}+(1-dp[a]_{last})\times dp[b]\times e[i].val$$

每个变量的意义上同，特殊地，我们区分了$dp[a]_{now}$与$dp[a]_{last}$，分别指**转移后的dp[a] (即现在已知的dp[a])** 与 **转移前的dp[a] (即所求的,对dp[b] 在第二次dp中产生贡献的部分）**

化简可得

$$dp[a]_{last}=\dfrac{dp[a]_{now}-dp[b]\times e[i].val}{1-dp[b]\times e[i].val}$$

求得$dp_{last}$后，沿用第一次的转移

$$dp[b]+=(1-dp[b])\times dp[a]_{last}\times e[i].val$$

进行第二次dp，所得的结果就是最终答案。此题完结。

另外还有一些细节见代码（当然，看完上面的那些要是自己能打出来就不要看代码了）

___

### Part IV

又到了喜闻乐见的放代码环节

```
#include<bits/stdc++.h>

using namespace std;

const double eps=1e-7;

struct Edge
{
    int to,nxt;
    double val;
    Edge(){}
    Edge(int to,int nxt,double val):to(to),nxt(nxt),val(val){}
}e[1000010];
int head[500010],cnt;

void addedge(int u,int v,double val)
{
    e[++cnt]=Edge(v,head[u],val);
    head[u]=cnt;
}

int n;
double dp[500010];

void dfs1(int now,int fa)//第一遍dp
{
    for(int i=head[now];i;i=e[i].nxt)
    {
        int vs=e[i].to;
        if(fa==vs) continue;
        dfs1(vs,now);
        dp[now]+=dp[vs]*(1-dp[now])*e[i].val;
    }
}

void dfs2(int now,int fa)//第二遍dp
{
    for(int i=head[now];i;i=e[i].nxt)
    {
        int vs=e[i].to;
        if(fa==vs) continue;
        if(fabs(1-dp[vs]*e[i].val)<=eps) 
        //坑：如果分母为0直接跳过。
        //原因：分母为0说明dp[vs]为1，不需要贡献
        {
            dfs2(vs,now);
            continue;
        }
        dp[vs]+=(1-dp[vs])*(dp[now]-dp[vs]*e[i].val)/(1-dp[vs]*e[i].val)*e[i].val;
        dfs2(vs,now);
    }
}

int main()
{
    cin>>n; 
    for(int i=1;i<n;i++)
    {
        int u,v;
        double val;
        cin>>u>>v>>val;
        addedge(u,v,val/100);
        addedge(v,u,val/100);
    }
    for(int i=1;i<=n;i++)
    {
        cin>>dp[i];//自己的贡献一开始就算进去
        dp[i]/=100;
    }
    dfs1(1,0);
    dfs2(1,0);
    double ans=0;
    for(int i=1;i<=n;i++)
    {
        ans+=dp[i];
    }
    cout<<fixed<<setprecision(6);//保留6位小数
    cout<<ans<<endl;
}
```

___

### Part V

回过头来看这道题，发现我一开始的思路并没有问题，只是没想清楚。

我们统计父节点贡献的时候，**本质上就是换根,**把原来的父节点变成子节点，那么**原来对父节点的贡献要还原，而父节点要对子节点进行贡献**。而第二遍dp的本质是对重复信息的利用，以达到换根效率的最优效果——$O(1)$换根。

题目不错，值得一做。

---

## 作者：fanypcd (赞：16)

[P4284 [SHOI2014]概率充电器](https://www.luogu.com.cn/problem/P4284)

换根 dp。

考虑算出每个点的概率 $P_i$，利用期望的线性性，$\sum P_i$ 就是答案。

考虑先求出每个点通过自己或是子树的点通电的概率，设为 $f_i$。

考虑加上一个子树时，概率怎么转移，设 $w$ 为根 $u$ 从子节点 $v$ 及其子树通电的概率，即 $w = f_v * p_{u,v}$，这里 $p_{u,v}$ 表示连接 $u,v$ 的导线的通电概率。
那么 $f_u = f_u +w - f_u \times w$。

这里利用了一个小的容斥，即 $P(A \cup B) = P(A) + P(B) − P(A \cap B) = P(A) + P(B) − P(A) \times P(B)$。

然后考虑点 $u$ 如何从父亲 $fa$ 处转移，此时要算出 $fa$ 不从 $u$ 走时通电的概率，设为 $P_a$。

仿照开始求 $f$ 的过程，令 $w = f_u \times p_{u,fa}$，则有 $f_{fa} = P_a + w - P_a \times w$。

所以 $P_a = \frac{f_{fa} - w}{1 - w}$。（当 $w = 1$ 时该式无意义，强行计算会导致 RE）。

所以 $fa$ 的子节点 $u$ 真正通电的概率 $P(u) = f_u + (P_a \times p_{u,fa}) - f_u \times (P_a \times p_{u,fa})$。

复杂度  $O(n)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
inline void read(int &x)
{
	x = 0;
	int f = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9')
	{
		f |= ch == '-';
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9')
	{
		x = x * 10 + ch - 48;
		ch = getchar();
	}
	x = f ? -x : x;
	return;
}
#define N 500005
int first[N], Next[N << 1], to[N << 1], tot;
double w[N << 1];
inline void add(int &x, int &y, double &z)
{
	Next[++tot] = first[x];
	first[x] = tot;
	to[tot] = y;
	w[tot] = z;
	return;
}
double f[N];
void dfs1(int u, int pre)
{
	for(int i = first[u]; i; i = Next[i])
	{
		int v = to[i];
		if(v == pre)
		{
			continue;
		}
		dfs1(v, u);
		f[u] = f[u] + w[i] * f[v] - f[u] * w[i] * f[v];
	}
	return;
}
void dfs2(int u, int pre)
{
	for(int i = first[u]; i; i = Next[i])
	{
		int v = to[i];
		if(v == pre)
		{
			continue;
		}
		if(f[v] * w[i] != 1)
		{
			double Pa = w[i] * (f[u] - f[v] * w[i]) / (1 - f[v] * w[i]);
			f[v] = f[v] + Pa - f[v] * Pa;
		}
		dfs2(v, u);
	}
	return;
}
int n;
signed main()
{
	int x, y;
	double z;
	read(n);
	for(int i = 1; i < n; i++)
	{
		read(x), read(y);
		scanf("%lf", &z);
		z /= 100.0;
		add(x, y, z);
		add(y, x, z);
	}
	for(int i = 1; i <= n; i++)
	{
		scanf("%lf", &f[i]);
		f[i] /= 100.0;
	}
	dfs1(1, 0);
	dfs2(1, 0);
	double ans = 0.0;
	for(int i = 1; i <= n; i++)
	{
		ans += f[i];
	}
	printf("%0.6lf", ans);
	return 0;
}
```

---

## 作者：xryjr233 (赞：10)

显然这是一棵树。

设节点$i$和$j$之间的边为$(i,j)$,边$(i,j)$导电的概率为$q_{i,j}$,第$i$个点自身有电的概率为$p_i$

考虑树形dp。

显然答案等于所有节点有电的概率之和。

考虑一个节点什么时候会被充电:

1.它自己有电;

2.它的孩子里有节点有电,并且这个孩子和这个节点之间的导线是导电的;

3.它的父亲有电,并且这个节点和父亲之间的导线导电。

本着树形dp的思路,先不考虑父亲对儿子的影响,即先不考虑3。

我们设$dp_i$表示第$i$个节点在考虑自身及其子树以后,有电的概率。

然后我们发现这样一来很难得知某一个儿子对父亲的概率贡献。

于是我们记$dp_i$表示第$i$个节点在考虑自身及其子树以后,**没有**电的概率。

我们设$i$的孩子为$s_1,s_2,s_3,...,s_m$。

则有$dp_i=(1-p_i)\Pi_{j=1}^m(dp_{s_j}+(1-dp_{s_j})\times (1-q_{i,s_j})$

解释:

我们知道一些时间同时发生的概率为这些时间独立概率的乘积。

要让$i$没电,就要求它自己没电,它的儿子也全部没电,或者有电的孩子和$i$之间的导线不导电。

$i$本身没电的概率是$(1-p_i)$;

孩子$s_j$没电的概率是$dp_{s_j}$,孩子$s_j$有电,且$(i,s_j)$不导电的概率是$(1-dp_{s_j})\times(1-q_{i,s_j})$,那么孩子$s_j$到$i$这一段没电的概率就是两者的和,即$dp_{s_j}+(1-dp_{s_j})\times(1-q_{i,s_j})$。

所以上面的式子就是把这些东西乘起来了。

发现每个孩子对于答案的贡献是独立的(这就是设$dp_i$的意义的理由)。

于是点$i$去除孩子$s_j$以后,剩下部分没电的概率就是$\frac{dp_i}{dp_{s_j}+(1-dp_{s_j})\times(1-q_{i,s_j})}$。

有什么用?

一会儿就知道了。

之后我们来考虑点$i$的父亲$f_i$对$i$的影响。

我们记$DP_i$为点$i$的父亲**没有**电传到$i$的概率。

我们记

$T=DP_{f_i}\times \frac{dp_{f_i}}{dp_i+(1-dp_i)\times q_{f_i,i}}$

也就是$f_i$不算$i$这棵子树,剩下的部分使得$f_i$没电的概率。

那么有

$DP_i=T+(1-T)\times(1-q_{f_i,i})$

解释:

前一个部分意义上面已经提过;

$(1-T)$即$f_i$不算$i$这棵子树,剩下的部分使得$f_i$有电的概率,$(1-q_{f_i,i})$即边$(f_i,i)$不导电的概率,那么整个就是$f_i$有电而$(f_i,i)$没电的概率。

两个部分都算完了。

于是看看答案等于什么。

点$i$没电的总概率就是$dp_i\times DP_i$;

那么点$i$有电的概率就是$1-dp_i\times DP_i$;

答案就是$\sum_{i=1}^n(1-dp_i\times DP_i)$。

code:

```cpp
#include<bits/stdc++.h>
#define Merge(x,y,val) (dps[x]*=(g[y]=dps[y]+(1-dps[y])*(1-val)))
using namespace std;
struct edge{
    int t,nxt;
    double v;
}e[1000010];
int n,u,v,w,cnt,be[500010],vis[500010],f[500010];
double p[500010],g[500010],fv[500010],dps[500010],dpf[500010],ans;
void add(int x,int y,int val){
    e[++cnt].t=y,e[cnt].v=val*0.01,e[cnt].nxt=be[x],be[x]=cnt;
}
void dfs1(int x){
    vis[x]=1,dps[x]=1-p[x];
    for(int i=be[x];i;i=e[i].nxt)!vis[e[i].t]?dfs1(e[i].t),Merge(x,e[i].t,e[i].v),0:(f[x]=e[i].t,fv[x]=e[i].v);
}
void dfs2(int x){
    dpf[x]=f[x]?(g[x]?dpf[f[x]]*dps[f[x]]/g[x]+(1-dpf[f[x]]*dps[f[x]]/g[x])*(1-fv[x]):0):1;
    ans+=1-dps[x]*dpf[x];
    for(int i=be[x];i;i=e[i].nxt)e[i].t!=f[x]?dfs2(e[i].t),0:0;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<n;++i)scanf("%d%d%d",&u,&v,&w),add(u,v,w),add(v,u,w);
    for(int i=1;i<=n;++i)scanf("%lf",&p[i]),p[i]*=0.01;
    dfs1(1),dfs2(1);
    printf("%.6lf",ans);
    return 0;
}
```

---

## 作者：jijidawang (赞：9)

由期望的线性性，答案就是每个点通电的概率 .

发现这个的并不太好做，我们求一下每个点不通电的概率 .

分析一下每个点受到哪些贡献：
1. 自己通电
2. 子树内通电
3. 子树外通电

令 $f(u)$ 为自己通电和子树内通电的概率，则
$$f(u)=(1-p_i)\prod_{v\in\mathrm{son}(u)}(f(v)+(1-f(v)(1-w))$$
为啥？因为贡献可以拆成：
- 子树没电
- 子树有电，但是不通电

令 $g(u)$ 表示子树外通电概率，我们可以考虑 $u$ 的子树外到底是什么：
- $u$ 的父亲的子树外
- $u$ 的父亲的子树除了 $u$ 的子树的部分

第一个贡献显然 .

关于第二个，因为我们是连乘积形式，所以直接除掉儿子的贡献就完了 .

于是就有 $u$ 的子树外有电的概率：
$$P=g(fa(u))\cdot\dfrac{f(fa(u))}{f(u)+(1-f(u))(1-w)}$$

然后类似的拆贡献：
- 子树没电
- 子树有电，但是不通电

于是就有
$$g(u)=P+(1-P)(1-w)$$

这个从父亲到儿子的 dp 可以自顶向下做 dfs .

注意特判分母为 $0$ 的情况

Code:
```cpp
using namespace std;
typedef long long ll;
typedef double db;
const int N = 514114;
vector<pair<int, db> > g[N];
inline void addedge(int u, int v, db w){g[u].emplace_back(make_pair(v, w));}
inline void ade(int u, int v, db w){addedge(u, v, w); addedge(v, u, w);}
int n;
db p[N], dp1[N], dp2[N];
void dfs1(int u, int fa)
{
	dp1[u] = 1 - p[u];
	for (auto e : g[u])
	{
		int v = e.first; db w = e.second;
		if (v == fa) continue;
		dfs1(v, u);
		dp1[u] *= dp1[v] + (1-dp1[v]) * (1-w);
		//        不通电 ; 通电，但是不连边 
	}
}
void dfs2(int u, int fa)
{
	for (auto e : g[u])
	{
		int v = e.first; db w = e.second;
		if (v == fa) continue;
		if (dp1[v] + (1 - dp1[v]) * (1-w) == 0) continue;
		db P = dp2[u] * dp1[u] / (dp1[v] + (1 - dp1[v]) * (1-w));
		dp2[v] = P + (1-P) * (1-w);
		dfs2(v, u);
	}
}
int main()
{
	scanf("%d", &n); db w;
	for (int i=1, u, v; i<n; i++) scanf("%d%d%lf", &u, &v, &w), ade(u, v, w/100);
	for (int i=1; i<=n; i++) scanf("%lf", p+i), p[i] /= 100;
	dp2[1] = 1;
	dfs1(1, 0); dfs2(1, 0);
	db ans = 0;
	for (int i=1; i<=n; i++) ans += 1 - dp1[i] * dp2[i];
	printf("%.6f\n", ans);
	return 0;
}
```

---

## 作者：大朋友 (赞：7)

# P4284 [SHOI2014]概率充电器题解
###  update : 2021/10/13-3 英文,数字之间增加空格，并优化公式,变量的  latex
---
### 概率+树形 DP
### [题目传送门](https://www.luogu.com.cn/problem/P4284)
---
## 简化题目
给出一颗无根树，树上每一个点有概率 $p$，对于边 $e_i=(u,v)$ 存在 $p_i$ 概率联通 $u\,v$，求 $\sum_{i=1}^np_i$
## 分析
不难想到，本题需要使用 DP ,怎么使用关键在于要知道 DP 转移的相关变量，我们先确定可能参加 DP 的变量，在一步一步缩圈，最后**根据变量确定方程**。


|变量名| 解释 |
|--|--|
|  $ p_i $  |  $i$ 点的初始概率  |
|  $ P1_i $  |  $i$ 点的son上传的概率  |
|  $ P2_i $  |  $i$ 点的集成概率  |
|  $ siz_i $  |  $i$ 点的子树大小  |
|  $ v_i $  |  $i$ 点的连边对应点  |
|  $ w_i $  |  $i$ 点的连边联通概率  |



我们一个一个变量分析

-  $ p_i $ 可能会参加方程，但是考虑到 DP 的状态集成思想， $P1,P2$  更有可能参加方程。

- 对于这道题子树的大小以及类似(  $ dep,fa $  )等点特征变量很难关系到**树形DP**,所以暂时不考虑，如果题目需要特征会在后期突出，暂时不考虑。

-  $v,w$ 明显会是转移对象
所以我们先初步确定一个范式:
$$
P2_i=ans(P1_v,w_{i->v},P2_v,P2_i,P1_i)
$$

## 思考情况
1.自己来电 $p_i$。

2.子树上传 $P2_i$。

3.与父亲的关系 $ g(P2_fa_i,P1_i) $ (g 表示存在函数关系)。

(3):来自父节点所以概率-父节点从 i 得来的概率。
## 概率合并
$$
\operatorname{P}(a)\cup\operatorname{P}(b)
  =  1-  (  \neg\operatorname{P}(a)\cap\neg\operatorname{P}(b))=  \operatorname{P}(a)+\operatorname{P}(b)-\operatorname{P}(a)\cap\operatorname{P}(b)
$$
(update: 格式化公式 )

于是可以愉快的转移了。

对于第3种转移情况有一个方程可以手解，建议自己解一解，代码里也有。
## 完整代码
```c++
#include<bits/stdc++.h>
#define ll long long
#define db double
#define fd(i, a, b) for (ll i = a; i >= b; i--)
#define r(i, a) for (ll i = fir[a]; i; i = e[i].nex)
#define file(a) freopen(#a ".in", "r", stdin);
#define il inline
#define gc getchar()
#define f(i,a,b) for(ll i=a;i<=b;i++)
using namespace std;
const ll maxn=5e5+10,INF=1e16;
il ll read(){
    ll x=0,f=1;char ch=gc;
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc;}
    while(ch>='0'&&ch<='9') x=(x*10)+(ch^48),ch=gc;
    return x*f;}
ll n,fir[maxn],cnt;
db p[maxn];
struct edge{ll to,nex;db w;}e[maxn<<2];
il void add(ll a,ll b,db P){
	e[++cnt].to=b,e[cnt].nex=fir[a],e[cnt].w=P;
	fir[a]=cnt;
}
il void dfs1(ll x,ll f){
	r(i,x){
		ll v=e[i].to;
		if(v==f) continue;
		dfs1(v,x);
		db s=e[i].w;
		s*=p[v];
		p[x]=p[x]+s-p[x]*s;
	}
}
il void dfs2(ll x,ll f){
	r(i,x){
		ll v=e[i].to;
		if(v==f) continue;
		db s=e[i].w;
		if(1-s*p[v]) s=(p[x]-s*p[v])/(1-s*p[v]);
		else s=1;
		s*=e[i].w;
		p[v]=p[v]+s-p[v]*s;
		dfs2(v,x);
	}
}
int main()
{
// 	file(a);
	n=read();
	f(i,1,n-1){
		ll a=read(),b=read();
		db P=read()*0.01;
		add(a,b,P),add(b,a,P);
	}
	f(i,1,n) p[i]=read()*0.01;
	dfs1(1,0);
	dfs2(1,0);
	db ans=0;
	f(i,1,n) ans+=p[i];
	printf("%.6lf\n", ans);
}
```

---

## 作者：Prean (赞：4)

~~这个题，题面是【】，出题人也是个【】~~

真就只放前向星过，把 vector 和离线建图都卡了。。。

题意：

一棵树，一条边有 $ p_i $ 的概率连接两个节点，一个点有 $ P_i $ 的概率亮着，问所有节点亮着的期望。

首先根据期望的线性性，所有节点亮着的期望明显可以拆成每个节点亮着的期望之和。然后仔细想想，$ E(X)=1 * p +0 * (1-p)=p $，所以只需要求亮着的概率即可。

怎么算呢？

考虑 dp，设 $ dp_1[u] $ 为 $ u $ 为根的子树中，$ u $ 亮着的概率。

直接算很困难，考虑算 $ u $ 不亮着的概率，不难发现是 $ (1-P_u)\prod_{\texttt {v is u son}}(1-dp1[v] \times p_{(u,v)}) $，用 $ 1 $ 减去即可得到 $ dp_1[u] $。

接下来考虑换根。要求的东西还是一样的，只是需要维护父节点的 $ dp $ 值。

设 $ dp_2[u] $ 为考虑整棵树时 $ u $ 亮着的概率，此处为了方便设 $ f[u] $ 为去掉 $ u $ 为根的子树时，其父亲节点亮着的概率。

对于 $ u $ 的一个儿子 $ v $，我们很容易能够发现有 $ f[v]=(1-p_{(u,f[v])}\prod_{\texttt {x is u son }\And x \ne v } 1-dp1[x] \times e_{(u,x)}) $。

大多数同学都是直接用 $ dp2[u] $ 和 $ dp1[v] $ 直接进行转移，来得到其值，但其实可以对儿子维护一个前缀积和后缀积，这样就不会出现除法的问题了。
```cpp
#include<cstdio>
#include<vector>
#include<cctype>
typedef double db;
const int M=5e5+5;
int n,m,cnt,h[M],f[M];db ans,p[M],dp1[M],dp2[M];
db v[M],lp[M],rp[M];
struct Edge{
	int v,nx;db p;
}e[M<<1];
inline void Add(const int&u,const int&v,const db&p){
	e[++cnt]=(Edge){v,h[u],p};h[u]=cnt;
	e[++cnt]=(Edge){u,h[v],p};h[v]=cnt;
}
inline int read(){
	int n(0);char s;
	while(!isdigit(s=getchar()));
	while(n=n*10+(s&15),isdigit(s=getchar()));
	return n;
}
void DFS1(int u){
	dp1[u]=1-p[u];
	for(int E=h[u];E;E=e[E].nx)if(e[E].v^f[u])f[e[E].v]=u,DFS1(e[E].v),dp1[u]*=(1-dp1[e[E].v]*e[E].p);dp1[u]=1-dp1[u];
}
void DFS2(int u){
	int e,i,len(0);db p=(dp2[u]*=1-::p[u]);
	for(e=h[u];e;e=::e[e].nx)if(::e[e].v^f[u])v[++len]=1-dp1[::e[e].v]*::e[e].p;
	for(i=1;i<=len;++i)lp[i]=(i==1?1:lp[i-1])*v[i];
	for(i=len;i>=1;--i)rp[i]=(i==len?1:rp[i+1])*v[i];
	for(e=h[u],i=1;e;e=::e[e].nx){
		if(::e[e].v==f[u])continue;Edge&E=::e[e];dp2[E.v]*=p;dp2[u]*=1-dp1[E.v]*E.p;
		if(i^1)dp2[E.v]*=lp[i-1];if(i^len)dp2[E.v]*=rp[i+1];
		dp2[E.v]=1-(1-dp2[E.v])*E.p;++i;
	}
	for(e=h[u];e;e=::e[e].nx)if(::e[e].v^f[u])DFS2(::e[e].v);dp2[u]=1-dp2[u];
}
signed main(){
	int i,u,v,p;n=read();
	for(i=1;i<n;++i)u=read(),v=read(),p=read(),Add(u,v,.01*p);
	for(i=1;i<=n;++i)::p[i]=.01*read(),dp2[i]=1;DFS1(1);DFS2(1);
	for(i=1;i<=n;++i)ans+=dp2[i];printf("%.6f",ans);
}
```

---

## 作者：Vocalise (赞：2)

## 题意解释

一棵 $n$ 个点的树，每个点 $i$ 有 $q_i$ 概率为有电状态，$1-q_i$ 概率为无电状态，一条树边 $e $ 有 $p_e$ 概率可以通电，$1-p_e$ 概率不能通电。一个由可以通电的边连成的连通块中如果至少有一个点有电，那么整个连通块的点都会有电。

问期望下有多少个点会最终有电。

## 题解

先考虑朴素的树形 DP。一个点需要考虑它子树中与它连通的点有多少个，并且这个连通块还没有电。会得到一个 $f_{v,s}$ ，表示 $v$ 子树中有 $s$ 个点与根连通还没有电，期望下已经有电的点数。

转移考虑它的某条儿子边是否可以通电（$2^n$ 级别的状态数），并且如果该点亮起就将 $s$ 置 $0$。

时空复杂度太高。发现我们考虑了一个点在其它点处造成的贡献。实际上，根据期望的线性性，可以直接计算树上每个点有电的概率。数值上也等于期望。

最后将所有点的期望相加就是答案。

于是一个换根 DP 就呼之欲出。

令 $f_v$ 表示 $v$ 子树内使 $v$ 有电的概率。有两种情况：

1. 该点自己亮起。
2. 至少一个儿子亮起，且该儿子的父亲边可以通电。

令两种情况的反面相叠加，再取反，可得：（以下边集默认为单向边）
$$
f_v = 1 - (1-q_v)\prod\limits_{(v,u)\in E}(1-p_{(v,u)}f_u)
$$
考虑换根。

要计算某个点 $v$ 的父亲 $u$ 这棵反向子树（点补集）的 $f$ 值，考虑再记 $g_u$​ 为这个值。

注意到 $g_u$ 是根据儿子 $v$ 变化的。

设我们考虑到 $v$ 这个点的 $g_v$ 值 ，它的父亲为 $u$，$v$ 需要向下走（递归进入）的儿子是 $k$，则
$$
g_v=1-(1-q_v)(1-p_{(u,v)}g_u)\prod\limits_{(v,s)\in E,s\not=k}(1-p_{(v,s)}f_s)
$$
比较好理解。如果算出所有儿子的乘积再除去 $k$，我们不太容易处理为 $0$ 的情况（且有精度问题），所以较理想的做法是将儿子有序化，计算乘积的前缀后缀。

还有就是，在使用这个做法的时候可能需要在邻接表中手动将父亲删去，以免干扰求前后缀积。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <vector>

const int N = 500001;

char buf[1 << 25] ,*p1 = buf ,*p2 = buf;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf ,1 ,1 << 21 ,stdin) ,p1 == p2) ? EOF : *p1++)
inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();
    return x * f;
}

int n; double p[N];
std::vector <std::pair <int,double> > V[N];
typedef std::vector <std::pair <int,double> >::iterator it;

double f[N];

void Dfs(int v,int fa) {
    f[v] = 1;
    for(int i = 0;i < (int)V[v].size();i++) {
        int u = V[v][i].first; if(u == fa) continue;
        Dfs(u,v), f[v] *= 1 - V[v][i].second * f[u];
    }
    f[v] = p[v] + (1 - p[v]) * (1 - f[v]);
    return;
}

double g[N],Ans;
std::vector <double> P[N],Q[N];

void Dfs1(int v,int fa) {
    double tmp = 1 - g[fa], ans = tmp;
    
    it j;
    for(it i = V[v].begin();i != V[v].end();i++) {
        int u = i -> first;
        if(u == fa) j = i;
        else ans *= 1 - i -> second * f[u];
    }
    if(v > 1) V[v].erase(j);

    ans = 1 - (1 - p[v]) * ans;
    //std::printf("%d %lf\n",v,ans);
    Ans += ans;

    for(int i = 0;i < (int)V[v].size();i++) {
        int u = V[v][i].first; if(u == fa) continue;
        P[v].push_back(1 - V[v][i].second * f[u]);
        Q[v].push_back(1 - V[v][i].second * f[u]);
    }
    for(int i = 1;i < (int)P[v].size();i++) P[v][i] *= P[v][i - 1];
    for(int i = (int)Q[v].size() - 2;i >= 0;i--) Q[v][i] *= Q[v][i + 1];
    for(int i = 0;i < (int)V[v].size();i++) {
        int u = V[v][i].first; if(u == fa) continue;
        g[v] = tmp * (!i ? 1 : P[v][i - 1]) * (i == (int)Q[v].size() - 1 ? 1 : Q[v][i + 1]);
        g[v] = V[v][i].second * (1 - (1 - p[v]) * g[v]);
        Dfs1(u,v);
    }
    return;
}

int main() {
    n = read();
    for(int i = 1;i < n;i++) {
        int v = read(), u = read();
        double p = read() / 100.0;
        V[v].push_back(std::make_pair(u,p));
        V[u].push_back(std::make_pair(v,p));
    }
    for(int i = 1;i <= n;i++) p[i] = read() / 100.0;
    Dfs(1,0), Dfs1(1,0);
    //for(int i = 1;i <= n;i++) std::printf("%lf ",f[i]);
    //std::puts("");
    std::printf("%.6lf\n",Ans);
    return 0;
}


```





---

## 作者：crashed (赞：2)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P4284)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~看到概率和期望我就不会了。~~  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设充电器$i$的充电概率为$P(i)$，则可以得到答案为：  
$$\sum_i (P(i)\times 1) =\sum_i P(i)$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以我们只需要求出每个充电器成功充电的概率就可以啦！  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是如果暴力化式子的话，会发现有很多$1-P$的项，转移就会非常头疼。于是我们反其道而行之，~~放弃这道题~~求充电器充电失败的概率，设为$p$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移：  
$$p(u)=(1-q_u)\sum_{(u,v)\in E}(1-p(u,v)(1-p(v)))$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中$p(u,v)$表示边$(u,v)$可以通电的概率。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看起来不是很好呀......似乎有环......怎么办？  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~目测可以高斯消元~~  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过这道题的背景是树，直觉告诉我们应该是两次$DFS$解决的问题。首先考虑子树内的情况：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$f(u)$：在$u$的子树内，$u$不被点亮的概率。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$son(u)$表示$u$的儿子集合，转移就是：  
$$f(u)=(1-q_u)\sum_{v\in son(u)}(1-p(u,v)(1-f(v)))$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后考虑第二遍$DFS$该怎么做。通过第一次$DFS$，我们已经得到了子树内的情况，所以第二遍$DFS$我们只需要将子树外的信息合并上去就可以了。子树外的信息可以通过父亲的真实答案（合并后的答案）推出来。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是这道题就被解决啦，时间$O(n)$。  
# 代码
```cpp
#include <cstdio>

const double eps = 1e-11;
const int MAXN = 5e5 + 5;

template<typename _T>
void read( _T &x )
{
    x = 0;char s = getchar();int f = 1;
    while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
    while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
    x *= f;
}

template<typename _T>
void write( _T x )
{
    if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
    if( 9 < x ){ write( x / 10 ); }
    putchar( x % 10 + '0' );
}

template<typename _T>
_T ABS( const _T a ) { return a < 0 ? -a : a; }

struct edge
{
	int to, nxt; double w;
}Graph[MAXN << 1];

double f[MAXN], q[MAXN], g[MAXN];
int head[MAXN];
int N, cnt;

double equal( const double x, const double y = 0 ) { return ABS( x - y ) < eps; }
double fix( const double a ) { if( equal( a ) ) return a + eps; if( equal( a, 1 ) ) return a - eps; return a; }

void addEdge( const int from, const int to, const double w )
{
	cnt ++;
	Graph[cnt].w = fix( w ), Graph[cnt].to = to, Graph[cnt].nxt = head[from];
	head[from] = cnt;
}
void addE( const int from, const int to, const double w ) { addEdge( from, to, w ), addEdge( to, from, w ); }

void DFS1( const int u, const int fa )
{
	f[u] = 1 - q[u];
	for( int i = head[u], v ; i ; i = Graph[i].nxt )
		if( ( v = Graph[i].to ) ^ fa )
		{
			DFS1( v, u );
			f[u] *= ( 1 - Graph[i].w * ( 1 - f[v] ) );
		}
}

void DFS2( const int u, const int fa )
{
	double w;
	for( int i = head[u], v ; i ; i = Graph[i].nxt )
		if( ( v = Graph[i].to ) ^ fa )
		{
			w = Graph[i].w;
			g[v] = f[v] * ( 1 - w * ( 1 - g[u] / ( 1 - w * ( 1 - f[v] ) ) ) );
			DFS2( v, u );
		}
}

int main()
{
	read( N );
	for( int i = 1, u, v, w ; i < N ; i ++ ) read( u ), read( v ), read( w ), addE( u, v, w * 0.01 );
	for( int i = 1 ; i <= N ; i ++ ) scanf( "%lf", &q[i] ), q[i] /= 100;
	DFS1( 1, 0 );
	g[1] = f[1], DFS2( 1, 0 );
	double res = 0;
	for( int i = 1 ; i <= N ; i ++ ) res += 1 - g[i];
	printf( "%.6f\n", res );
	return 0;
}
```

---

## 作者：WNico (赞：2)

> [传送](https://www.luogu.org/problem/P4284)
>
> 考场切了来写题解

# 题意

已知每个点通电的概率，每条边导电的概率，求树上每个点有电的概率之和（期望

# 思路

本题作为树形DP来说并不难，主要在于概率的转移

首先要搞清楚 

$P(A+B) = 1-(1-P(A))(1-P(B)) \dots\dots1$

$\therefore P(A)=(1-P(A+B))(1-P(B))\dots\dots2$

从下往上转移可以用 1 做到

算出根节点有电的概率

考虑将根节点转移到子节点

由 2 式求出，父节点不经过一个子节点供电而有电的概率 $P'$

将 $P'$ 向该子节点转移，求出子节点有电的概率

---

另外，记得特判子节点的概率$\times$边概率为 1 的情况

这种情况下不需要去掉子节点对父节点的影响

（因为 ~~会 nan~~ 此时子节点必然为 1

源程序
---

```cpp
#include<bits/stdc++.h>
#define db double
using namespace std;

inline void io(){
	freopen("ProbabilityCharger.in","r",stdin);
	freopen("ProbabilityCharger.ans","w",stdout);
}

inline int read(){
	int s=0,w=1;char ch;
	while(!isdigit(ch=getchar())) if(ch=='-') w=-1;
	while(isdigit(ch)) s=s*10+ch-'0',ch=getchar();
	return s*w;
}

const int N = (int)5e5+9;
int n;
int head[N],nxt[N*2],v[N*2],tl;
db e[N*2],val[N],final_ans=0.0;
db dp[N];

inline void adde(int x,int y,int z){
	v[++tl]=y;e[tl]=(db)z/100.0;nxt[tl]=head[x];head[x]=tl; 
}

inline db spl(db a,db b){
	// 消去影响
	return 1-(1-a)/(1-b);
} 
inline db mer(db a,db b){
	// 求P(A+B)
	return 1-(1-a)*(1-b);
}

inline void dfs1(int x,int fr){
	// 初始化为该节点直接通电的概率
	dp[x]=val[x];
	for(int i=head[x];i;i=nxt[i]){
		if(v[i]!=fr){
			dfs1(v[i],x);
            // 统计该节点在子树供电下有电的概率
			dp[x] = mer(dp[x],dp[v[i]]*e[i]);
		}
	}
}

inline void dfs2(int x,int fr){
	// 统计答案
	final_ans += dp[x];
	for(int i=head[x];i;i=nxt[i]){
		if(v[i]!=fr){
        	// 特判子节点概率为 1 的情况
			if(dp[v[i]]*e[i]!=1) dp[v[i]] = mer(dp[v[i]],spl(dp[x],dp[v[i]]*e[i])*e[i]);
			dfs2(v[i],x);
		}
	}
}

int main(){
	//freopen("2.in","r",stdin);
	io();
	n=read();
	for(int i=1,x,y,z;i<n;++i){
		x=read(),y=read(),z=read();
		adde(x,y,z);adde(y,x,z);
	}
	for(int i=1;i<=n;++i) val[i]=(db)read()/100.0;
	dfs1(1,0);
	dfs2(1,0);
	printf("%.6lf",final_ans);
	
	return 0;
}
```

附数据生成器
---
```python
from cyaron import *
from random import *
from  time  import *

seed(time())
io = IO(input_file="23.in")
n = 500000
io.input_writeln(n)
g = Graph.tree(n,weight_limit=(0,100))
io.input_writeln(g)
for i in range(0,n):
    io.input_write(randint(0,100))

```

--- 

$$Fin$$

[$My~Blog$](https://a-wnico-blog.blog.luogu.org/)





---

## 作者：localhost (赞：2)

树形dp中的$\text{up and down}$

还有一点期望

设每个点能够通电的概率为$P_i$

那么$ans = \sum_{i=1}^n P_i$

**我们先考虑$up$(只考虑子树))**

分成两种情况：

1. 直接通电 : $q_i$
   
2. 被子节点通电 : 
   
   $(1-q_i) \times P_{to}(\text{子节点}) \times e_i.w(\text{连接的边导电的概率})$
   
**我们再考虑$down$(考虑子树外))**

我们可以通过父节点的答案来更新子节点

父节点的答案是包括当前子节点的

可以把这部分除去然后按照$up$的方法更新

$P_x= P_x' (1-P_x')*(P_{to}*e_i.w)$($P_x'$指根节点除去当前子节点的贡献的答案)

整理得：
$$P_x'=\frac{P_x-(P_{to} \times e_i.w)}{1-(P_{to} \times e_i.w)}$$

(这里有个坑点:当$1-(P_{to} \times e_i.w) = 0$时这个式子就没有意义了)

$\therefore P_{to} = P_{to} + (1-P_{to}) \times P_x' \times e_i.w$

所以在下推的时候要特判一下

上代码：
```cpp
#include<bits/stdc++.h>
namespace ZDY{
    #pragma GCC optimize(3)
    #define il __inline__ __attribute__ ((always_inline))
    #define rg register
    #define ll long long
    #define ull unsigned long long
    #define db double
    #define sht short
    #define MB template <class T>il
    #define Fur(i,x,y) for(int i=x;i<=y;++i)
    #define Fdr(i,x,y) for(int i=x;i>=y;--i)
    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)
    #define clr(x,y) memset(x,y,sizeof(x))
    #define cpy(x,y) memcpy(x,y,sizeof(x))
    #define fin(s) freopen(s".in","r",stdin)
    #define fout(s) freopen(s".out","w",stdout)
    #define fcin ios::sync_with_stdio(false)
    #define l2(n) ((int)(log2(n)))
    #define inf 0x3f3f3f3f
    MB T ABS(T x){return x>0?x:-x;}
    MB T MAX(T x,T y){return x>y?x:y;}
    MB T MIN(T x,T y){return x<y?x:y;}
    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}
    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}
}using namespace ZDY;using namespace std;
namespace IO{const char* ln="\n";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){clr(ch,0);if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;
#define N 500011
int n,cnt=0,head[N],d[N];
struct edge{
    int to,nxt;
    db w;
}e[N*2];
il void add(int x,int y,db w){
    e[++cnt].to=y;e[cnt].w=w;e[cnt].nxt=head[x];head[x]=cnt;
}
db s[N],ans=0;
void up(int x){
    fl(i,x)if(!d[to]){
        d[to]=d[x]+1;
        up(to);
        db t=s[to]*e[i].w;
        s[x]+=(1-s[x])*t;
    }
}
#define eps 1e-7
il bool chk(db x){return x+eps>1.0&&x-eps<1.0;}
void down(int x){
    ans+=s[x];
    fl(i,x)if(d[to]>d[x]){
        if(!chk(s[to]*e[i].w)){
            db t=(s[x]-s[to]*e[i].w)/(1.0-s[to]*e[i].w)*e[i].w;
            s[to]+=(1-s[to])*t;
        }
        down(to);
    }
}
int main(){
    in>>n;
    int x,y,w;
    Fur(i,1,n-1)in>>x>>y>>w,add(x,y,(db)w*0.01),add(y,x,(db)w*0.01);
    Fur(i,1,n)in>>x,s[i]=(db)x*0.01;
    d[1]=1;
    up(1);
    down(1);
    printf("%.6f\n",ans);
}
```


---

## 作者：Aw顿顿 (赞：1)

每个充电器充上电的概率设为 $f_i$ 的话，显然我们要求的结果是 $f_1+f_2+\cdots f_n$，因此这道题实际上是概率树形 DP。

接下来考虑贡献关系。

- 该节点自行充上电：概率为 $q_i$，由于输入的是百分数，要转化为实数进行计算。
- 该节点由儿子节点来电。
- 该节点由父亲节点来电。

设一个节点有电的概率为 $f_i$ 嘛，那不考虑父亲方向的来电，就可以写出来转移方程：

$$f_i=f_i+(1-f_i)\cdot f_j\cdotp(i,j)$$

其中 $j$ 是 $i$ 的孩子，而 $p$ 表示两点连边通电的概率。解释一下这个式子，即要么该节点本身来电，要么来自它的孩子，**两者至少发生一个即可**。那么接下来考虑第三种来源，就可以进行自上而下的操作了。

然而我们会发现出现了重复操作。

假设存在一对父子 $(x,y)$，向上更新时我们对于 $x\to y$ 进行了一次更新，而这次更新产生的贡献不应该再被贡献回来，我们要用 $x$ 最初的值进行计算。让我们用 $f_{i1}$ 表示原值，$f_{i2}$ 表示新值，写出来也就是：

$$f_{i2}=f_{i1}+(1-f_{i1})\cdot f_j\cdot p(i,j)$$

让我们进行一些简单的代数变形吧：

$$f_{i2}=f_j\cdot p(i,j)+f_{i1}(1-f_j\cdot p(i,j))$$

$$f_{i2}-f_j\cdot p(i,j)=f_{i1}(1-f_j\cdot p(i,j))$$

$$f_{i1}=\dfrac{f_{i2}-f_j\cdot p(i,j)}{1-f_j\cdot p(i,j)}$$

一旦出现除法尤为值得注意的是分母不可为零，排除该情况后进行二次 DP 即可解出这一题。

```cpp
#include<bits/stdc++.h>
#define eps (1e-7)
#define N 500005
using namespace std;
struct edge{int v,nxt;double w;}e[N<<1];
int h[N],cnt,n;double res;
void add(int u,int v,double w){
	e[++cnt].v=v;e[cnt].w=w;
	e[cnt].nxt=h[u];h[u]=cnt;
}double f[N];
void dfs1(int u,int fa){
	for(int i=h[u];i;i=e[i].nxt){
		if(fa==e[i].v)continue;
		dfs1(e[i].v,u);
		f[u]=f[u]+f[e[i].v]*(1-f[u])*e[i].w;
	}
}void dfs2(int u,int fa){
	for(int i=h[u];i;i=e[i].nxt){
		int v=e[i].v;
		if(fa==v)continue;
		if(fabs(1.0-f[v]*e[i].w)<=eps){
			dfs2(v,u);
			continue;
		}
		f[v]+=(1-f[v])*(f[u]-f[v]*e[i].w)/
			  (1-f[v]*e[i].w)*e[i].w;
		dfs2(v,u);
	}
}int main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int u,v;double w;
		scanf("%d%d%lf",&u,&v,&w);
		add(u,v,w/100);add(v,u,w/100);
	}for(int i=1;i<=n;i++){
		double x;scanf("%lf",&x);
		f[i]=x/100.0;
    }dfs1(1,-1);dfs2(1,-1);
    for(int i=1;i<=n;i++)res+=f[i];
    printf("%.6lf\n",res);
	return 0;
}
```



---

## 作者：KokiNiwa (赞：1)

这是一道二次换根题（第一次写二次换根）。

[概率充电器](https://www.luogu.org/problem/P4284)

首先答案是每个元器件有电的概率的总和。于是需要求出，每个点有电的概率。设$p_i$表示第$i$个点有电的概率，那么$p_i$可以通过与$i$相连的点计算出来，或者说可以列出一个方程，在这里大概口胡一下，就是$i$有电有两种情况：
+ 本身就有电
+ 本身没电，但是和它相连的点有电，并且那条边联通

于是我们就可以列出线性方程组，利用高斯消元解决问题。但是这时间复杂度$O(n^3)$肯定炸了啊。

考虑换方法，假如现在我们需要求出第$i$个结点有电的概率。发现不好求，怎么办呢？可以通过反过来解决问题，即求出第 $i$ 个点没电并且与其相连的点要么边不连通，要么点没电的概率。那么就要求出与其相连的点没电的概率（因为其他的都是已知的），现在就可以开始 $dp$ 啦（因为与其相连的点是不不能通过当前点传导电的）。但复杂度$O(n^2)$，不可接受。

考虑二次换根，所谓二次换根就是首先计算出$1$点的概率，然后在计算与$1$相连通的$2$结点为根时的概率的时候可以利用$1$点计算的部分结果，计算$2$为根的时候的概率。这道题中，可以结合上面暴力 $dp$ 想出换根的具体操作，这里就不再多说啦。

代码：
```cpp
#include <cstdio>

using namespace std;

const int maxNode = 5e5 + 10;
int dianN, totBian;
int head[maxNode], fa[maxNode];
double dp[maxNode], youDian[maxNode], termi[maxNode];
struct bian {
	int to, next;
	double lian;
} edge[maxNode << 1];

void addedge(int nodU, int nodV, double lian) {
	edge[++totBian].to = nodV;
	edge[totBian].next = head[nodU];
	edge[totBian].lian = lian;
	head[nodU] = totBian;
}

void gengXin(int now) {
	double meiDian = 1.0 - youDian[now];
	for (int pt = head[now]; pt; pt = edge[pt].next) {
		int to = edge[pt].to;
		if (to != fa[now]) {
			meiDian *= (1.0 - dp[to] * edge[pt].lian);
		}
	}
	dp[now] = 1.0 - meiDian;
}

void dfs1(int now, int from) {
	fa[now] = from;
	for (int pt = head[now]; pt; pt = edge[pt].next) {
		int to = edge[pt].to;
		if (to != from) {
			dfs1(to, now);
		}
	}
	gengXin(now);
}

void dfs2(int now, int from) {
	for (int pt = head[now]; pt; pt = edge[pt].next) {
		int to = edge[pt].to;
		if (to != from) {
			fa[now] = to;
			fa[to] = 0;
			
			double yuanBenNow = dp[now], yuanBenTo = dp[to];
			
//			gengXin(now);
//			gengXin(to);
			fa[now] = to;
			fa[to] = 0;
			
			dp[now] = 1.0 - dp[now];
			if (1.0 - dp[to] * edge[pt].lian < 1e-9)
				gengXin(now);
			else dp[now] /= 1.0 - dp[to] * edge[pt].lian;
			dp[now] = 1.0 - dp[now];
			dp[to] = 1.0 - dp[to];
			dp[to] *= 1.0 - dp[now] * edge[pt].lian;
			dp[to] = 1.0 - dp[to];
			
			termi[to] = dp[to];
			dfs2(to, now);
			
			fa[to] = now;
			fa[now] = 0;
			
			dp[now] = yuanBenNow;
			dp[to] = yuanBenTo;
		}
	}
}

int main() {
	scanf("%d", &dianN);
	for (int bianI = 1; bianI < dianN; ++bianI) {
		int nodU, nodV, persent;
		scanf("%d%d%d", &nodU, &nodV, &persent);
		addedge(nodU, nodV, 1.0 * persent / 100.0);
		addedge(nodV, nodU, 1.0 * persent / 100.0);
	}
	for (int dianI = 1; dianI <= dianN; ++dianI) {
		int persent;
		scanf("%d", &persent);
		youDian[dianI] = 1.0 * persent / 100.0;
	}
	dfs1(1, 0);
	termi[1] = dp[1];
	dfs2(1, 0);
	double ans = 0;
	for (int dianI = 1; dianI <= dianN; ++dianI) {
		ans += termi[dianI];
	}
	printf("%lf\n", ans);
	return 0;
}
```

---


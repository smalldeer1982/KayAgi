# [SHOI2008] 安全的航线

## 题目描述

在设计航线的时候，安全是一个很重要的问题。首先，最重要的是应采取一切措施确保飞行不会发生任何事故，但同时也需要做好最坏的打算，一旦事故发生，就要确保乘客有尽量高的生还几率。

当飞机迫降到海上的时候，最近的陆地就是一个关键的因素。航线中最危险的地方就是距离最近的陆地最远的地方，我们称这种点为这条航线“孤地点”。孤地点到最近陆地的距离被称为“孤地距离”。作为航空公司的高级顾问，你接受的第一个任务就是尽量找出一条航线的孤地点，并计算这条航线的孤地距离。

为了简化问题，我们认为地图是一个二维平面，陆地可以用多边形近似，飞行线路为一条折线。航线的起点和终点都在陆地上，但中间的转折点是可能在海上（如下图所示，方格标示出了孤地点）。

![](https://cdn.luogu.com.cn/upload/pic/15457.png)

## 说明/提示

对于50%的数据，1≤C≤2，2≤N≤5;

对于100%的数据，1≤C≤20，2≤N≤20。

## 样例 #1

### 输入

```
1 2
-9 -6
5 1
3
0 16
-16 -12
17 -6```

### 输出

```
0.00```

## 样例 #2

### 输入

```
2 3
12 4
16 17
3 9
4
1 0
4 19
19 14
6 12
3
10 10
5 3
18 2```

### 输出

```
2.94```

# 题解

## 作者：totorato (赞：6)

# Flight Safety (BZOJ1020)

(当然先推荐一下博客[点这里](http://mina.moe/archives/5323))

### 题意

世界上有很多岛屿，可以看成是C个边形($C\leq20$，每个点数M不超过30，可以非凸)。一架飞机沿一条N点折线飞行($N\leq20$)，求航线上一个点，最大化其到最近岛屿的距离。给出的所有点都是$[-1000,10000]$内的整数坐标。要求最终答案精度在$10^{-2}$以下(在UVA提交精度$10^{-3}$)。

![fig.1](http://mina.moe/wp-content/uploads/2018/04/1.jpg")

### 分析

首先我想，既然航线被划分成了“在岛上”-“在海上”-“在岛上”-...的交替模式，那么我们对每个在海上的段求最远距离不是很容易吗？取个中点不就行了。

反例(中点显然不是最优的)：

![fig.1](http://mina.moe/wp-content/uploads/2018/04/2.jpg")

那么求截得这段海上航线的两条线段的角平分线与航线的交点不就是最远点吗？

反例：

![fig.1](http://mina.moe/wp-content/uploads/2018/04/3.jpg")

额。。。这个里面的花，我们或许只能用更奇怪的方法解决这道题了。

### 爬山(90pts)

爬山算法是求解怪异函数的最优化问题的常用方法。

如果将航线上每个点到最近岛屿的距离看成有关飞行距离的函数，那么我们会看到一个非常可爱的函数图像。这个图像有如下性质：斜率的绝对值不超过1。原因是：从任意一处出发，向任意方向飞行，你与最近岛屿的距离变化速度不可能超过你飞行的速度。

因此，我们证明了这个函数是不会突变的。这就意味着我们可以让很多个小人从不同位置爬这个图像，他们不会因为函数突变而摔死或者爬不动(即若函数不连续则爬山算法不可解极值)。这样，最终爬地最高的小人就代表着函数的极值。

这种算法的基本步骤是：

- 1.按一定间隔放置小人
- 2.每个小人有一个特定的步长s
- 3.小人向着函数增长的方向爬s的长度
- 4.s变小

最终每个小人都会稳定在一座山峰处。

但是我们在准备实现这个算法之前需要注意如下几个问题：

- 要多少个小人可以保证几乎每个峰都被找到，或没找到的不会影响精度
- 小人的初始步长s
- 小人步长的减少率v
- 小人要爬多少步
- 以上的算法如果可以100%找到最优解，时间复杂度是否允许。

首先，我们可以证明，两个小人间距小于$10^{-2}$才一定可以找到最优解，而这和暴力找点没有任何区别，时间复杂度都不足以通过此题。因此我们可以冒险将间距调大，爬山步数调小，减少率设为2/3，并且面向数据编程，就可以在洛谷获得90分的好成绩(我提交了50多次)。

### 二分(100pts)

我并没有亲身尝试这个恐怖的算法，但是这是复杂度严格$O(NMClogA)$的(A为答案大小)。这是一个非常优秀的复杂度，谁看了都想打，但是不巧，看看它是怎么做的你就不想打了。

- 二分距离x
- 将每个多边形的边向外平移x，形成多个由圆弧和线段组成的形状
- 求航线与这些形状的交点，并对交点离散化后逆差分，求出每一段被形状覆盖的次数
- 如果存在一段没有被覆盖，则x扩大，反之减小。

看到了那个“由圆弧和线段组成的形状”了没？这东西原本就及其的恐怖，还需要求和线段的交点，实在是太难打。

### 迭代(100pts)

于是我们继续利用爬山的那种偷懒的思想。

分析爬山不可行的原因，是有很多没用的人在爬。国家供养不起那么多废物，于是就TLE了。所以我们要想办法清理掉更多的废物，保留最有可能爬上最高峰的人。

于是迭代算法就应运而生了。

对于一条线段，它到最近岛屿的距离一定是在$[D-\frac{L}{2},D+\frac{L}{2}]$的区间内的(D为其中点到最近岛屿的距离，L为其长度)。如果这个区间和$[X,+\infty]$(X为已知的最远距离)没有交集，或者L已经非常短，可以认为这条线段就是个废物，否则，我们可以将其拆成前半段和后半段递归处理。

因此我们可以用一个队列(甚至有限队列)维护当前所有有用的线段，每次生成两个线段，将有用的保留。这样，我们只会用有用的线段进行类似爬山的操作，这样就可以很快获得答案。

# 代码

#### 爬山

```cpp
#pragma GCC optimize(3)
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#define eps 1e-8
#define oo 1e5
#define MX 102

using namespace std;

struct vec
{
	double x,y;
	void input(){scanf("%lf%lf",&x,&y);}
	void output(){printf("%.3lf %.3lf\n",x,y);}
	vec (){}
	vec (const double& a,const double& b){x=a,y=b;}
	vec operator + (const vec& t)const{return vec(x+t.x,y+t.y);}
	vec operator - (const vec& t)const{return vec(x-t.x,y-t.y);}
	vec operator * (const double& t)const{return vec(x*t,y*t);}
	vec operator / (const double& t)const{return vec(x/t,y/t);}
	double len(){return sqrt(x*x+y*y);}
	vec normal(){return *this/(len()+eps);}
};
double dot(const vec& a,const vec& b){return a.x*b.x+a.y*b.y;}
double crs(const vec& a,const vec& b){return a.x*b.y-a.y*b.x;}
bool seg_seg_int(const vec& ap,const vec& aq,const vec& bp,const vec& bq)
{
	if(	min(ap.x,aq.x)>max(bp.x,bq.x)||
		min(bp.x,bq.x)>max(ap.x,aq.x)||
		min(ap.y,aq.y)>max(bp.y,bq.y)||
		min(bp.y,bq.y)>max(ap.y,aq.y))return 0;
	if(	crs(bq-aq,ap-aq)*crs(bp-aq,ap-aq)>0||
		crs(ap-bq,bp-bq)*crs(aq-bq,bp-bq)>0)return 0;
	return 1;
}
double p_to_seg(const vec& a,const vec& p,const vec& q)
{
	vec v=q-p;
	double t=dot(a-p,v)/dot(v,v);
	if(t<0||t>1)return min((a-p).len(),(a-q).len());
	vec b=p+(v*t);
	return (a-b).len();
}
bool p_in_poly(const vec& a,const vec* p,int n)
{
	int cnt=0;
	vec far=a+vec(1,+oo);
	for(int i=1;i<=n;i++)cnt+=seg_seg_int(a,far,p[i],p[i%n+1]);
	return (cnt&1);
}
int C,N,M[MX];
vec line[MX];
vec poly[MX][MX];

double mindis(const vec& a)
{
	double ans=+oo;
	for(int i=1;i<=N;i++)
	{
		if(M[i]>=3&&p_in_poly(a,poly[i],M[i]))return 0;
		if(M[i]>=2)for(int j=1;j<=M[i];j++)ans=min(ans,p_to_seg(a,poly[i][j],poly[i][j%M[i]+1]));
		else ans=min(ans,(poly[i][1]-a).len());
	}
	return ans;
}

void input()
{
	scanf("%d%d",&N,&C);
	for(int i=1;i<=C;i++)line[i].input();
	for(int i=1;i<=N;i++)
	{
		scanf("%d",&M[i]);
		for(int j=1;j<=M[i];j++)poly[i][j].input();
	}
}

double cal_max(const vec& p,const vec& q)
{
	vec v=q-p;
	double len=v.len(),ret=0,di=max(1e-2/len,2e-3);
	for(double i=0;i<=1;i+=di)
	{
		double now=i,stp=di/2,lf=mindis(p+v*now);
		for(int j=1;j<=21;j++)
		{
			double tr=min(1.0,now+stp);
			double nowf=lf,nxtf=mindis(p+v*tr);
			if(nxtf>nowf)now=tr,lf=nxtf;
			else now=max(0.0,now-stp),lf=mindis(p+v*now);
			if(nowf+stp*1.857142857<=ret)break;
			stp*=0.65;
		}
		ret=max(ret,mindis(p+v*now));
	}
	return ret;
}

void work()
{
	double ans=0;
	for(int i=1;i<C;i++)ans=max(ans,cal_max(line[i],line[i+1]));
	printf("%.2lf\n",ans);
}

int main()
{
    input();
    work();
	return 0;
}
```

#### 迭代

```cpp
#pragma GCC optimize(3)
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#define eps 1e-8
#define oo 1e5
#define MX 102

using namespace std;

struct vec
{
	double x,y;
	void input(){scanf("%lf%lf",&x,&y);}
	void output(){printf("%.3lf %.3lf\n",x,y);}
	vec (){}
	vec (const double& a,const double& b){x=a,y=b;}
	vec operator + (const vec& t)const{return vec(x+t.x,y+t.y);}
	vec operator - (const vec& t)const{return vec(x-t.x,y-t.y);}
	vec operator * (const double& t)const{return vec(x*t,y*t);}
	vec operator / (const double& t)const{return vec(x/t,y/t);}
	double len(){return sqrt(x*x+y*y);}
	vec normal(){return *this/(len()+eps);}
};
struct itv
{
	vec l,r;
	itv (){}
	itv (const vec& a,const vec& b){l=a,r=b;}
	vec mid(){return (l+r)/2.0;}
	double len(){return (r-l).len();}
};
double dot(const vec& a,const vec& b){return a.x*b.x+a.y*b.y;}
double crs(const vec& a,const vec& b){return a.x*b.y-a.y*b.x;}
bool seg_seg_int(const vec& ap,const vec& aq,const vec& bp,const vec& bq)
{
	if(	min(ap.x,aq.x)>max(bp.x,bq.x)||
		min(bp.x,bq.x)>max(ap.x,aq.x)||
		min(ap.y,aq.y)>max(bp.y,bq.y)||
		min(bp.y,bq.y)>max(ap.y,aq.y))return 0;
	if(	crs(bq-aq,ap-aq)*crs(bp-aq,ap-aq)>0||
		crs(ap-bq,bp-bq)*crs(aq-bq,bp-bq)>0)return 0;
	return 1;
}
double p_to_seg(const vec& a,const vec& p,const vec& q)
{
	vec v=q-p;
	double t=dot(a-p,v)/dot(v,v);
	if(t<0||t>1)return min((a-p).len(),(a-q).len());
	vec b=p+(v*t);
	return (a-b).len();
}
bool p_in_poly(const vec& a,const vec* p,int n)
{
	int cnt=0;
	vec far=a+vec(1,+oo);
	for(int i=1;i<=n;i++)cnt+=seg_seg_int(a,far,p[i],p[i%n+1]);
	return (cnt&1);
}
int C,N,M[MX];
vec line[MX];
vec poly[MX][MX];

double mindis(const vec& a)
{
	double ans=+oo;
	for(int i=1;i<=N;i++)
	{
		if(M[i]>=3&&p_in_poly(a,poly[i],M[i]))return 0;
		if(M[i]>=2)for(int j=1;j<=M[i];j++)ans=min(ans,p_to_seg(a,poly[i][j],poly[i][j%M[i]+1]));
		else ans=min(ans,(poly[i][1]-a).len());
	}
	return ans;
}

void input()
{
	scanf("%d%d",&N,&C);
	for(int i=1;i<=C;i++)line[i].input();
	for(int i=1;i<=N;i++)
	{
		scanf("%d",&M[i]);
		for(int j=1;j<=M[i];j++)poly[i][j].input();
	}
}

itv use[1000001];
void work()
{
	double best=0;
	int h=0,t=1;
	for(int i=1;i<C;i++)use[++h]=itv(line[i],line[i+1]);
	for(int i=1;i<=300000&&h>=t;i++)
	{
		itv now=use[t++],nxt1,nxt2;
		best=max(best,mindis(now.mid()));
		nxt1=itv(now.l,now.mid());
		nxt2=itv(now.mid(),now.r);
		if(nxt1.len()>=1e-4&&mindis(nxt1.mid())+nxt1.len()/2.0>best)use[++h]=nxt1;
		if(nxt2.len()>=1e-4&&mindis(nxt2.mid())+nxt2.len()/2.0>best)use[++h]=nxt2;
	}
	printf("%.6lf\n",best);
}

int main()
{
	int t;
	scanf("%d",&t);
	for(int i=1;i<=t;i++)
	{
		input();
		work();
	}
	return 0;
}
```



---

## 作者：acniu (赞：2)

> 既然楼下用爬山骗分，那我为何不用模拟退火？



线段$AB$上任意一点都可以表示成$Ak+B(1-k)$的形式，其中$k\in[0,1]$。考虑以$k$为变量，退火求每根线段上的孤地距离。

那么只要计算给定点到每个多边形的距离，再取最小值。可以先判断点是否在多边形中，若在则答案为$0$，否则答案为点到多边形各边的最小距离。

判断点在多边形中可以从点向外引一条射线，求射线与多边形各边的交点个数，为奇则在里边，为偶则在外面。

求点到线段的最小距离可以运用点积和叉积。想象从点到线段所在直线作垂线，若垂足在线段上则直接向量叉积，否则为点到端点的距离。判断垂足是否在线段上可以比较线段与"点到端点的直线"间的夹角与$90\degree$的大小，可以通过点积的正负号判断。

代码：
```cpp
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <iostream>
using namespace std;

struct vec { // 向量
	double x, y;
	vec() { x = y = 0.0; }
	vec(double a, double b) { x = a, y = b; }
	double length() { return sqrt(x * x + y * y); }
	vec operator+(const vec &v) const { return vec(x + v.x, y + v.y); }
	vec operator-(const vec &v) const { return vec(x - v.x, y - v.y); }
	double operator*(const vec &v) const { return x * v.x + y * v.y; }
	vec operator*(double k) const { return vec(x * k, y * k); }
	double operator&(const vec &v) const { return x * v.y - y * v.x; } // 叉乘
};

struct Poly {
	int m;
	int x[40], y[40];
	void read()
	{
		scanf("%d", &m);
		for (int i = 1; i <= m; i++)
			scanf("%d %d", x + i, y + i);
	}
	int inside(double xx, double yy) // 判断点在多边形里，我选的射线是竖直向上的
	{
		int flag = 0;
		for (int i = 1; i <= m; i++) {
			double a = x[i], c = x[i % m + 1];
			double b = y[i], d = y[i % m + 1];
			if (a == c) // 平行/重合均视作不相交
				continue;
			if (a > c) {
				swap(a, c);
				swap(b, d);
			}
			if (xx < a || xx > c)
				continue; // 这样二者不可能相交
			double k = (double)(d - b) / (c - a);
			if (k * (xx - a) + b > yy) // y = k(x - a) + b是直线的解析式
				flag ^= 1;
		}
		return flag;
	}
	double dist(double xx, double yy)
	{ // 求点到多边形的距离
		if (inside(xx, yy))
			return 0.0;
		double ans = 1e100;
		for (int i = 1; i <= m; i++) {
			vec p1(x[i % m + 1], y[i % m + 1]), p2(x[i], y[i]), p(xx, yy);
			vec u = p1 - p, v = p2 - p, w = p2 - p1;
			if (u * w > 0)
				ans = min(ans, u.length());
			else if (v * w < 0)
				ans = min(ans, v.length());
			else // 上面两种情况是垂足在线段外的情况
				ans = min(ans, abs(u & v) / w.length());
		}
		return ans;
	}
} poly[30];
int n, m;
vec p[30];

double calc(const vec &p1, const vec &p2, double k)
{
	vec p = p2 * k + p1 * (1 - k);
	double dist = 1e100;
	for (int i = 1; i <= n; i++)
		dist = min(dist, poly[i].dist(p.x, p.y));
	return dist;
}

double rando()
{
	return (double)rand() / RAND_MAX;
}

double calc(vec p1, vec p2) // 模拟退火
{
	double T = 1, k = rando(), ans = calc(p1, p2, k);
	while (T >= 1e-7) {
		double k2 = k + (rando() * 2 - 1) * T;
		k2 = max(0., min(k2, 1.));
		double tmp = calc(p1, p2, k2);
		if (tmp > ans || rando() < exp((tmp - ans) / T)) {
			ans = tmp;
			k = k2;
		}
		T *= .98;
	}
	return ans;
}

int main()
{
	srand(time(0));
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= m; i++)
		scanf("%lf %lf", &p[i].x, &p[i].y);
	for (int i = 1; i <= n; i++)
		poly[i].read();
	double ans = 0;
	for (int i = 1; i < m; i++)
		ans = max(ans, calc(p[i], p[i + 1]));
	printf("%.2f\n", ans);
}
```

---

## 作者：Nasaepa (赞：1)

一开题想了想三分，最后因为实现太难放弃了。

---

本题目考虑 `dfs`。

大致思路如下：

考虑在一条线段上寻找答案，取其中点记为 $mid$，算终点离最近的陆地有多远，记录为 $d$，如果 $mid$ 点在陆地内部则 $d = 0$。计这条线段的长度记为 $L$，当前已经得到的答案为 $ans$。

在这条线段上的点到最近陆地的距离一定在 $[d-\frac{L}{2},d+\frac{L}{2}]$ 范围内，画图证明显然。如果 $d+\frac{L}{2} \le ans$ 则这条线段没用，直接 `return`。如果 $L$ 的值过低则无法对答案产生实质影响，也要 `return`。

如果没有 `return` 则将 $ans$ 更新为 $\max(ans,d)$，并将线段从中点分成两段递归下去。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define N 30
#define INF 0x3f3f3f3f
#define lowbit(x) (x&-x)
#define pii pair<point,point>
#define cpx complex<double>
#define poly vector<ll>
#define eps 1e-8
namespace Point{// 定义点和向量运算 
	struct point{double x,y;point(const double &x_ = 0,const double &y_ = 0){x = x_,y = y_;}};
	inline point operator+(const point &n1,const point &n2){return point(n1.x+n2.x,n1.y+n2.y);}
	inline point operator-(const point &n1,const point &n2){return point(n1.x-n2.x,n1.y-n2.y);}
    struct segment{point a,b;segment(point a_ = point(0,0),point b_ = point(0,0)){a = a_,b = b_;}};// 线段类
	inline double len(const point &n1){return sqrt(n1.x*n1.x+n1.y*n1.y);}
	inline double operator*(const point &n1,const point &n2){return n1.x*n2.x+n1.y*n2.y;}
    inline point mid_point(point a,point b){return point((a.x+b.x)/2,(a.y+b.y)/2);}
	inline double dst(point p,point a,point b){// 点 p 到线段 ab 的距离
		point ap = p-a,ab = b-a,bp = p-b;
		double t = ap*ab/(ab.x*ab.x+ab.y*ab.y);
		if(t < -eps)return len(ap);
		if(t - 1 > eps)return len(bp);
		point q = a + point(ab.x*t,ab.y*t);
		return len(p-q);
	}
}using namespace Point;
inline bool equal(const double &n1,const double &n2){return fabs(n1-n2)<=eps;}
double ans;
vector<point> a;// 路线
vector<segment> all;// 所有多边形的线段
int c,n,x,y,ln[N];
inline bool check(const point &p){// 判断 p 是否再陆地上
    int cnt = 0;
    double x1,y1,x2,y2,k,b;
    for(const segment sg:all){
        x1 = sg.a.x,x2 = sg.b.x,y1 = sg.a.y,y2 = sg.b.y;
        if(equal(x1,x2)){if(equal(x1,p.x))return 1;continue;}
        if(p.x - min(x1,x2) > eps && max(x2,x1)-p.x > eps){
            k = (y1 - y2)/(x1 - x2);b = y1 - k * x1;
            if(p.x*k+b - p.y > eps)++cnt;
        }
    }
    return cnt&1;
}
void dfs(point a,point b){
    double d,l = len(b-a);
    // if(l < 0.8 && check(a) && check(b))return ;
    point mid = mid_point(a,b);
    if(check(mid))d = 0;
    else{
        d = INF;
        for(const segment sg:all)d = min(d,dst(mid,sg.a,sg.b));
    }
    // printf("a = [%.2lf,%.2lf] b = [%.2lf,%.2lf] d = %.2lf l = %.2lf\n",a.x,a.y,b.x,b.y,d,l);
    if(ans - d - l/2 > eps || l < 1e-3)return ;
    ans = max(ans,d);dfs(a,mid),dfs(b,mid);
}

// 主函数
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin >> c >> n;a.reserve(n);
    for(int i = 1;i <= n;++i)cin >> x >> y,a.emplace_back(point(x,y));
    for(int i = 1;i <= c;++i){
        cin >> ln[i];cin >> x >> y;point a(x,y),b = a;
        for(int j = 2;j <= ln[i];++j){cin >> x >> y;
            all.emplace_back(segment(point(x,y),b)),b = point(x,y);
        }
        all.emplace_back(segment(a,b));
    }
    for(int i = 1;i < n;++i)dfs(a[i-1],a[i]);
    cout << fixed << setprecision(2) << ans;
    return 0;
}
```

---


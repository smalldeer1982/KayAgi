# [SHOI2014] 信号增幅仪

## 题目描述

无线网络基站在理想状况下有效信号覆盖范围是个圆形。而无线基站的功
耗与圆的半径的平方成正比。现给出平面上若干网络用户的位置，请你选择一
个合适的位置建设无线基站 ……

就在你拿起键盘准备开始敲代码的时候，你的好朋友发明家SHTSC 突然出
现了。SHTSC 刚刚完成了他的新发明——无线信号增幅仪。增幅仪能够在不增
加无线基站功耗的前提下，使得有效信号的覆盖范围在某一特定方向上伸长若
干倍。即：使用了增幅仪的无线基站覆盖范围是个椭圆，其功耗正比于半短轴
长的平方。

现给出平面上若干网络用户的位置，请你选择一个合适的位置建设无线基
站，并在增幅仪的帮助下使所有的用户都能接收到信号，且无线基站的功耗最
小。

注意：由于SHTSC 增幅仪的工作原理依赖地磁场，增幅的方向是恒定的。

## 说明/提示

- 对于10%的数据，保证最优方案的中心在原点。
- 对于20%的数据，保证点是随机生成的。
- 对于30%的数据，n≤100。
- 对于50%的数据，n≤5000。
- 对于100%的数据，n≤50000，0≤a<180，1≤p≤100，|x|,|y|≤$2×10^8$。

## 样例 #1

### 输入

```
2
1 0
-1 0
0
2```

### 输出

```
0.500```

## 样例 #2

### 输入

```
3
1 1
-1 -1
0 0
45
7```

### 输出

```
0.202```

# 题解

## 作者：bztMinamoto (赞：7)

## 题面

[传送门](https://www.luogu.org/problemnew/show/P4288)

## 题解

我连椭圆是个啥都不知道导致这么简单一道题我一点思路都没有……

我们把坐标系旋转一下，让半长轴成为新的$x$轴，也就是说所有点都绕原点逆时针旋转$360-a$度，然后再把所有点的$x$坐标变为原来的${1\over p}$，跑一个最小圆覆盖就行了

```cpp
//minamoto
#include<bits/stdc++.h>
#define R register
#define inline __inline__ __attribute__((always_inline))
#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)
#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
inline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
int read(){
    R int res,f=1;R char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');
    return res*f;
}
double readdb()
{
    R double x=0,y=0.1,f=1;R char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(x=ch-'0';(ch=getc())>='0'&&ch<='9';x=x*10+ch-'0');
    for(ch=='.'&&(ch=getc());ch>='0'&&ch<='9';x+=(ch-'0')*y,y*=0.1,ch=getc());
    return x*f;
}
const int N=1e5+5;const double eps=1e-6,Pi=acos(-1.0);
inline double reps(){return (1.0*rand()/RAND_MAX-0.5)*eps;}
inline int sgn(R double x){return x<-eps?-1:x>eps;}
struct node{
    double x,y;
    inline node(){}
    inline node(R double xx,R double yy):x(xx),y(yy){}
    inline node operator +(const node &b)const{return node(x+b.x,y+b.y);}
    inline node operator -(const node &b)const{return node(x-b.x,y-b.y);}
    inline double operator *(const node &b)const{return x*b.y-y*b.x;}
    inline node operator *(const double &b)const{return node(x*b,y*b);}
    inline double operator ^(const node &b)const{return x*b.x+y*b.y;}
    inline double len2(){return x*x+y*y;}
    inline node rot(R double s,R double c){return node(x*c-y*s,x*s+y*c);}
    inline node rot90(){return node(-y,x);}
    inline void shake(){x+=reps(),y+=reps();}
}p[N],o;
struct Line{
    node p,v;
    inline Line(){}
    inline Line(R node pp,R node vv):p(pp),v(vv){}
    friend node cross(const Line &a,const Line &b){return a.p+a.v*(b.v*(b.p-a.p)/(b.v*a.v));}
};
node circle(const node &a,const node &b,const node &c){
    return cross(Line((a+b)*0.5,(b-a).rot90()),Line((a+c)*0.5,(c-a).rot90()));
}
int n;double s,c,a,b;
double calc(){
	double r=0;o=node(0,0);
	random_shuffle(p+1,p+1+n);
    fp(i,1,n)if(sgn((p[i]-o).len2()-r)>0){
        o=p[i],r=0;
        fp(j,1,i-1)if(sgn((p[j]-o).len2()-r)>0){
            o=(p[i]+p[j])*0.5,r=(p[j]-o).len2();
            fp(k,1,j-1)if(sgn((p[k]-o).len2()-r)>0)
                o=circle(p[i],p[j],p[k]),r=(p[k]-o).len2();
        }
    }
    return sqrt(r);
}
int main(){
    srand(20030719);
//	freopen("testdata.in","r",stdin);
    n=read();
    fp(i,1,n)p[i].x=readdb(),p[i].y=readdb(),p[i].shake();
    b=read(),a=read(),b=(360-b)/180.0*Pi,s=sin(b),c=cos(b),a=1.0/a;
    fp(i,1,n)p[i]=p[i].rot(s,c);
    fp(i,1,n)p[i].x=p[i].x*a;
    printf("%.3lf\n",calc());
    return 0;
}
```

---

## 作者：JustinRochester (赞：3)

[传送门](https://www.luogu.com.cn/problem/P4288)

---

**【分析】**
---

对于一个固定的，半径为 $r$ 的圆 $C$

我们采用新型号增幅仪，等价于将圆 $C$ 沿着 $\theta=a$ 的直线，往两端拉长 $p$ 倍

故我们考虑相对的效应：

等价于对所有点沿着 $\theta=a\cdot {\pi\over 180}$ 的直线，往两端收缩为 ${1\over p}$ ，然后求最小圆覆盖

但由于沿着 $\theta=a\cdot {\pi\over 180}$ 的直线收缩实在是有点迷惑，考虑到求的是圆覆盖，所以我们把平面中所有点旋转一个角度，答案不会发生变化

因此，我们先把所有点绕原点旋转 $-a$ 的角度，再沿 $x$ 轴收缩为原来的 ${1\over p}$

最后跑一个最小圆覆盖即可

---

**【代码】**
---

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef double db;
typedef pair<db, db> pdd;
#define fi first
#define se second
inline istream& operator >> (istream& in, pdd &p) { return in>>p.fi>>p.se; }
inline pdd operator + (const pdd &a, const pdd &b) { return pdd(a.fi+b.fi, a.se+b.se); }
inline pdd operator - (const pdd &a, const pdd &b) { return pdd(a.fi-b.fi, a.se-b.se); }
inline db operator * (const pdd &a, const pdd &b) { return a.fi*b.fi+a.se*b.se; }
inline db operator / (const pdd &a, const pdd &b) { return a.fi*b.se-a.se*b.fi; }
//*代表点积，/代表叉积
inline pdd operator * (const pdd &p, db a) { return pdd(p.fi*a, p.se*a); }
inline pdd operator ^ (const pdd &p, db a) { return pdd(p.fi*cos(a)-p.se*sin(a), p.fi*sin(a)+p.se*cos(a)); }
//^代表向量按弧度制旋转
inline pdd T(const pdd &p) { return pdd(p.se, -p.fi); }
//垂直的向量
inline db len(const pdd &p) { return sqrt(p*p); }
const db eps=1e-6;
inline int sgn(db val) { return fabs(val)<=eps?0:(val>0?1:-1); }

const int MAXN=1e5+10;
int n;
pdd p[MAXN];
inline void calc(pdd &o, db &r, const pdd &a, const pdd &b, const pdd &c) {
    //求外接圆
    pdd bc=b-c, ba=T(b-a), ca=T(c-a);
    db lambda=(bc/ba)/(ca/ba)*0.5;
    o=(c+a)*0.5+ca*lambda;
    r=len(o-a);
}
inline db minCirc(){
    random_shuffle(p+1, p+1+n);
    pdd o=pdd(0, 0);
    db r=0;
    for(int i=1;i<=n;++i){
        if( sgn( len(p[i]-o)-r )<=0 )
            continue;
        o=p[i];
        r=0;
        for(int j=1;j<i;++j) if( sgn( len(p[j]-o)-r )>0 ){
            o=(p[i]+p[j])*0.5;
            r=len(p[j]-p[i])*0.5;
            for(int k=1;k<j;++k) if( sgn( len(p[k]-o)-r )>0 )
                calc(o, r, p[i], p[j], p[k]);
        }
    }
    return r;
}
inline void init(){
    int a, pp;
    cin>>n;
    for(int i=1;i<=n;++i) cin>>p[i];
    cin>>a>>pp;
    db angle=-a*acos(-1)/180;
    for(int i=1;i<=n;++i) p[i]=p[i]^angle, p[i].fi/=pp;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    srand(time(0)^clock());
    cout<<fixed<<setprecision(3);
    init();
    cout<<minCirc();
    cout.flush();
    return 0;
}
```

---

## 作者：11400F (赞：1)

这道题表面上是让我们求最小椭圆覆盖，但是实际上我们可以把他转移成最小圆覆盖。

首先我们有一堆点和一个即将要求的最小椭圆覆盖：

![](https://s21.ax1x.com/2024/12/12/pAbNIYD.png)

为了方便计算，我们将其顺时针旋转 $a°$ 使这个椭圆的长轴与 $x$ 轴平行：

![](https://s21.ax1x.com/2024/12/12/pAbNofe.png)

最后因为它这个椭圆是本来的圆向 $x$ 轴的范围向外延伸到原来的 $p$ 倍，于是我们把所有点的 $x$ 坐标全部除以 $p$（请忽略下图中坐标轴上的数字）：

![](https://s21.ax1x.com/2024/12/12/pAbN7SH.png)

于是就变化为了最小圆覆盖问题了！然后直接套用模板即可求出圆的半径，即最小椭圆的半短轴长。

为了方便，我们把顺时针旋转 $a°$ 转化为逆时针旋转 $(360-a)°$，然后再把它转化为弧度。

那么如何求出某个点 $(x,y)$ 逆时针绕原点旋转 $\alpha$ 所得的坐标 $(x^{\prime}, y^{\prime})$ 呢？

![](https://s21.ax1x.com/2024/12/12/pAbUP6s.md.png)

假设 $AB = AC = r$，则：
$$
\left\{
\begin{aligned}
&x = r \cdot \cos \theta_1 \\
&y = r \cdot \sin \theta_1
\end{aligned}
\right.
$$

于是可以求出：

$$
\left\{
\begin{aligned}
x^{\prime} &= r\cdot\cos\theta_2 = r\cos(\alpha+\theta_1) = r(\cos \alpha \cos \theta_1 - \sin\alpha\sin\theta_1) \\
 &= r\cos\theta_1\cdot\cos\alpha - r\sin\theta_1\cdot\sin\alpha = x\cos\alpha-y\sin\alpha\\
y^{\prime} &= r\cdot\sin\theta_2 = r\sin(\alpha+\theta_1) = r(\sin \alpha \cos \theta_1 + \cos\alpha\sin\theta_1) \\
 &= r\cos\theta_1\cdot\sin\alpha + r\sin\theta_1\cdot\cos\alpha = x\sin\alpha+y\cos\alpha
\end{aligned}
\right.
$$

于是这道题就被完美地解决了！

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 5e4+4;
const double eps = 1e-9;
const double Pi = 3.1415926535897932384626433832795;
int comp(double x){
    if(fabs(x) < eps) return 0;
    if(x < 0) return -1;
    return 1;
}
struct Point{
    double x, y;
    Point operator + (const Point &b){
        return {x+b.x, y+b.y};
    }
    Point operator - (const Point &b){
        return {x-b.x, y-b.y};
    }
    Point operator / (const double &b){
        return {x/b, y/b};
    }
}p[N];

Point O;
double r;

double Dist(Point u, Point v){
    return sqrt((u.x-v.x)*(u.x-v.x)+(u.y-v.y)*(u.y-v.y));
}

bool incircle(Point x){
    return comp(Dist(x, O) - r) <= 0;
}

Point getO(Point u, Point v, Point w){
    double a = 2*(u.x-v.x), b = 2*(u.y-v.y), c = (u.x*u.x+u.y*u.y-v.x*v.x-v.y*v.y);
    double d = 2*(v.x-w.x), e = 2*(v.y-w.y), f = (v.x*v.x+v.y*v.y-w.x*w.x-w.y*w.y);
    double fm = a*e-b*d;
    double x = (c*e-b*f)/fm, y = (a*f-c*d)/fm;
    return {x,y};
}

Point Rotate(Point u, double ang){
    double newx = u.x*cos(ang)-u.y*sin(ang);
    double newy = u.x*sin(ang)+u.y*cos(ang);
    return {newx, newy};
}

int n;
void solve(){
    O = p[1], r = 0;
    for(int i=1;i<=n;i++){
        if(incircle(p[i])) continue;
        O = p[i];
        for(int j=1;j<i;j++){
            if(incircle(p[j])) continue;
            O = (p[i]+p[j])/2;
            r = Dist(O,p[i]);
            for(int k=1;k<j;k++){
                if(incircle(p[k])) continue;
                O = getO(p[i], p[j], p[k]);
                r = Dist(O, p[i]);
            }
        }
    }
}


int main(){
    scanf("%d", &n);
    for(int i=1;i<=n;i++){
        scanf("%lf%lf", &p[i].x, &p[i].y);
    }
    double ang, times;
    scanf("%lf%lf", &ang, &times);
    ang = double(360-ang)/180.0*Pi;
    for(int i=1;i<=n;i++){
        p[i] = Rotate(p[i], ang);
        p[i].x /= times;
    }
    random_shuffle(p+1, p+1+n);
    solve();
    printf("%.3lf", r);
    return 0;
}
```

~~选自[根神基础之最小圆覆盖](https://www.luogu.com.cn/article/w8kcegmm)~~

---

## 作者：NightTide (赞：1)

很好一题目，使我的最小圆覆盖旋转。

先假设 $p = 1$。这是最简单的情况。这个时候我们就得到了一个裸的最小圆覆盖。

当 $p \not= 1$，但是 $a = 0$ 的时候。圆就变成了对称轴与坐标轴平行的椭圆，运用高中知识仿射一下，又回到了最小圆覆盖。

在一般的情况下，我们先通过坐标的旋转回到第二种情况，再进行仿射，又是最小圆覆盖。

目前为止实际上这个题目已经做完了。如果你还不会做，那么你一定遇到了下面这个问题：

#### 什么是最小圆覆盖

[模板题传送门](https://www.luogu.com.cn/problem/P1742)

最小圆覆盖问题是指：在二维平面上有一堆点，求一个最小半径的圆，能够将所有点全部都包住。

为解决这个问题，我们首先引入三个性质：

> 性质 1：最小覆盖圆是唯一的

证明：假设存在两个圆，它们的都是符合要求的最小圆。设它们的半径为 $r$。那么所有的点就必定落在下图中的蓝色区域：

![](https://cdn.luogu.com.cn/upload/image_hosting/n27ek9jd.png)

而我们以两圆的两个交点为直径再做一个圆（如下图中紫色圆），显然它包含了该区域中的任意点，并且其直径为原本的两圆的一条弦，必然小于原本的两圆的直径：

![](https://cdn.luogu.com.cn/upload/image_hosting/h397df6j.png)

那么，蓝色圆不为最小圆，与假设冲突。

> 性质 2：对于一个点集，其最小覆盖圆只为两种情况之一：1. 圆由该点集内三个或者三个以上的点共同确定；2. 该点集内的两个点确定圆的直径

证明：记满足该两种情况为命题 $p$，是某个点集的最小覆盖圆为命题 $q$。

假如点集内没有点落在圆上，那么显然圆保持圆心不变，一直收缩。必然能够到某一状态，使得至少一个点落在圆上。

假如点集内只有一个点落在圆上，保持该点始终在圆上收缩半径，也必定在某一状态，使得另一点落在圆上。

假如点集内有两点落在圆上，但两点不构成直径。让圆心在两点确定的线段的中垂线上移动，必然存在某一状态，使得除了这两点以外的某一点也落在圆上

综上，$\neg p\Rightarrow \neg q$，即 $p \Rightarrow q$。

对于一个只有两个点的点集，显然条件二为最小覆盖圆。

对于一个等边三角形的三个顶点构成的点集，显然条件一为最小覆盖圆。

综上，$\exists$ 圆 $O$ 满足 $p$，使得 $q$ 成立。

> 性质 3：对于一个已知点集 $S$，已知其最小覆盖圆为圆 $O_1$。向点集内新增一点 $P$，若 $P$ 在圆外，则新点集的最小覆盖圆过点 $P$。

证明：对于一个新圆 $O_2$，其包含了点集 $S$ 中的所有点和 $P$，且 $P$ 在圆 $O_2$ 内。

若 $O_2$ 上只有两个点。 $S$ 中任意两点间的距离必然小于圆 $O_1$ 的直径，那么这两点不可能构成 $O_2$ 的直径，与性质 2 冲突。

若 $O_2$ 上有三个或三个以上的点，如图（深蓝色为 $O_1$，天青色为 $O_2$），$S$ 中的点必然被包含在浅蓝色区域内：

![img](https://cdn.luogu.com.cn/upload/image_hosting/2i0msskd.png)

类似于性质 1 的证明，圆 $O_1$ 不为点集 $S$ 的最小覆盖圆，与题设冲突。

于是得证。

引入这三个性质之后，我们就可以得到一个玄而又玄的算法：随机增量算法。

首先将所有的点随机化（随机化的作用在之后），记该点集为 $S$，$S_i$ 代表点集中的第 $i$ 个点。

接着初始化一个半径为 $0$，圆心为 $S_1$ 的圆。

接着遍历所有点，将当前枚举到的点丢入已知点集中，并维护一个新的最小覆盖圆，以此类推。

问题在于，当我们已知前 $i- 1$ 个点的最小覆盖圆时，如何确定加入第 $i$ 个点后的最小覆盖圆。

若 $S_i$ 在圆内，那么直接继续循环。

若 $S_i$ 在圆外，由性质 3，新的最小覆盖圆过点 $S_i$。此时我们已知圆上一点，不足以确定一个圆。

于是我们又初始化一个半径为 $0$，圆心为 $S_i$ 的圆。从 $i - 1$ 开始向前枚举 $j$，此时性质 3 依然适用。

若 $S_j$ 在圆内，那么直接继续循环。

若 $S_j$ 在圆外，由性质 3，新的最小覆盖圆过点 $S_j$。此时我们已知圆上两点，依旧不够。

于是我们又初始化一个以 $S_i$ 和 $S_j$ 为直径的圆，从 $1 \sim j - 1$ 枚举 $k$，依旧利用性质 $3$。

若 $S_k$ 在圆内，那么直接继续循环。

若 $S_k$ 在圆外，由性质 3，新的最小覆盖圆过点 $S_k$。此时三点确定一个圆。

当 $k$ 循环结束时，我们就得到了加入第 $i$ 个点后的最小覆盖圆。

核心代码如下：

```cpp
random_shuffle(p + 1, p + n + 1);// 随机化数组
// 结构体 (coor){x 坐标，y 坐标}，数组 p 是该类型
// 结构体 (circle){圆心，半径}
c = (circle){p[1], 0};
for(int i = 2; i <= n; i++){
    // double_cmp(double a, double b)：比较两个浮点数 a 和 b 的大小
    if(double_cmp(c.r, get_dis(c.o, p[i])) == -1){
        c = (circle){p[i], 0};
        for(int j = 1; j < i; j++){
            if(double_cmp(c.r, get_dis(c.o, p[j])) == -1){
                // get_dis(coor a, coor b)：两点之间距离
                c = (circle){(p[i] + p[j]) / 2, get_dis(p[i], p[j]) / 2};
                for(int k = 1; k < j; k++){
                    // get_circle(coor a, coor b, coor c)：三点确定圆
                    if(double_cmp(c.r, get_dis(c.o, p[k])) == -1) c = get_circle(p[i], p[j], p[k]);
                }
            }
        }
    }
}
```

好现在有人问，这玩意儿不是 $O(n^3)$ 的吗？

这只是理论最坏时间复杂度。然而实际上，每次在进入下一层循环时，都会判定一次当前点是否在当前圆外。可以证明，当数据随机时，我们只有 $\frac{3}{n}$ 的概率遇到一个在圆外的点。这也是随机化处理的原因。在随机化处理后，时间复杂度就变为了 $O(n\times\frac{3}{n}\times n\times\frac{3}{n}\times n)$，即 $O(n)$。

#### 完整代码如下

```cpp
#include<bits/stdc++.h>
#define MAXN 100010
#define eps 1e-9
#define pi acos(-1)
using namespace std;
struct coor{ double x, y; };
struct circle{ coor o; double r; };
coor operator + (coor a, coor b){ return (coor){a.x + b.x, a.y + b.y}; }
coor operator - (coor a, coor b){ return (coor){a.x - b.x, a.y - b.y}; }
coor operator * (coor a, double b){ return (coor){a.x * b, a.y * b}; }
coor operator / (coor a, double b){ return (coor){a.x / b, a.y / b}; }
double operator * (coor a, coor b){ return a.x * b.y - a.y * b.x; }
int double_cmp(double a, double b){
    if(fabs(a - b) < eps) return 0;
    if(a < b) return -1;
    return 1;
}
// 向量旋转 b，单位为弧度
coor rotate(coor a, double b){ return (coor){a.x * cos(b) + a.y * sin(b), -a.x * sin(b) + a.y * cos(b)}; }
// 两点间距离
double get_dis(coor a, coor b){
    double dx = a.x - b.x;
    double dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
}
// 两直线交点，p 和 v，q 和 w 分别确定两条直线
coor inter_section(coor p, coor v, coor q, coor w){
    coor u = p - q;
    double t = (w * u) / (v * w);
    return p + v * t;
}
// 求中垂线，用两点表示一条直线
pair<coor, coor> bisector(coor a, coor b){
    coor p = (a + b) / 2;
    coor q = rotate(b - a, pi/2);
    return make_pair(p, q);
}
// 三点定圆
circle get_circle(coor a, coor b, coor c){
    pair<coor, coor> x = bisector(a, b), y = bisector(a, c);
    coor o = inter_section(x.first, x.second, y.first, y.second);
    double r = get_dis(o, a);
    return (circle){o, r};
}
int n;
circle c;
coor p[MAXN];
int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) scanf("%lf%lf",&p[i].x,&p[i].y);
    random_shuffle(p + 1, p + n + 1);
    c = (circle){p[1], 0};
    for(int i = 2; i <= n; i++){
        if(double_cmp(c.r, get_dis(c.o, p[i])) == -1){
            c = (circle){p[i], 0};
            for(int j = 1; j < i; j++){
                if(double_cmp(c.r, get_dis(c.o, p[j])) == -1){
                    c = (circle){(p[i] + p[j]) / 2, get_dis(p[i], p[j]) / 2};
                    for(int k = 1; k < j; k++){
                        if(double_cmp(c.r, get_dis(c.o, p[k])) == -1) c = get_circle(p[i], p[j], p[k]);
                    }
                }
            }
        }
    }
    printf("%.10lf\n",c.r);
    printf("%.10f %.10f\n",c.o.x, c.o.y);
}
```

#### 回到本题

好的以上是最小圆覆盖，根据一开始的思路，我们很容易就能够将上面那份板子改为本题的答案。

```cpp
#include<bits/stdc++.h>
#define MAXN 100010
#define eps 1e-9
#define pi acos(-1)
using namespace std;
struct coor{ double x, y; };
struct circle{ coor o; double r; };
coor operator + (coor a, coor b){ return (coor){a.x + b.x, a.y + b.y}; }
coor operator - (coor a, coor b){ return (coor){a.x - b.x, a.y - b.y}; }
coor operator * (coor a, double b){ return (coor){a.x * b, a.y * b}; }
coor operator / (coor a, double b){ return (coor){a.x / b, a.y / b}; }
double operator * (coor a, coor b){ return a.x * b.y - a.y * b.x; }
int double_cmp(double a, double b){
    if(fabs(a - b) < eps) return 0;
    if(a < b) return -1;
    return 1;
}
coor rotate(coor a, double b){ return (coor){a.x * cos(b) + a.y * sin(b), -a.x * sin(b) + a.y * cos(b)}; }
double get_dis(coor a, coor b){
    double dx = a.x - b.x;
    double dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
}
coor inter_section(coor p, coor v, coor q, coor w){
    coor u = p - q;
    double t = (w * u) / (v * w);
    return p + v * t;
}
pair<coor, coor> bisector(coor a, coor b){
    coor p = (a + b) / 2;
    coor q = rotate(b - a, pi/2);
    return make_pair(p, q);
}
circle get_circle(coor a, coor b, coor c){
    pair<coor, coor> x = bisector(a, b), y = bisector(a, c);
    coor o = inter_section(x.first, x.second, y.first, y.second);
    double r = get_dis(o, a);
    return (circle){o, r};
}
int n, a, t;
double b;
circle c;
coor p[MAXN];
int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) scanf("%lf%lf",&p[i].x,&p[i].y);
    scanf("%d%d",&a,&t);
    
    b = a / 180.0 * pi;
    // 旋转
    for(int i = 1; i <= n; i++) p[i] = rotate(p[i], b);
    // 仿射
    for(int i = 1; i <= n; i++) p[i].x /= (double)t;
    
    random_shuffle(p + 1, p + n + 1);
    c = (circle){p[1], 0};
    for(int i = 2; i <= n; i++){
        if(double_cmp(c.r, get_dis(c.o, p[i])) == -1){
            c = (circle){p[i], 0};
            for(int j = 1; j < i; j++){
                if(double_cmp(c.r, get_dis(c.o, p[j])) == -1){
                    c = (circle){(p[i] + p[j]) / 2, get_dis(p[i], p[j]) / 2};
                    for(int k = 1; k < j; k++){
                        if(double_cmp(c.r, get_dis(c.o, p[k])) == -1) c = get_circle(p[i], p[j], p[k]);
                    }
                }
            }
        }
    }
    c.r *= 1000;
    c.r = round(c.r);
    c.r /= 1000;
    printf("%.3lf\n",c.r);
}
```

---

## 作者：DreamLand_zcb (赞：1)

## 简要题意

给定坐标系上 $N$ 个点，求将一个圆沿 $x$ 轴正方向逆时针转 $\alpha$ 度的方向拉长 $p$ 倍后能覆盖所有点的最小椭圆短半轴长度。

## 思路

斜着的椭圆不好处理怎么办，那就先把坐标系上 $N$ 个点顺时针转 $\alpha$ 度，把斜着的椭圆转过来变成长轴平行于坐标轴的椭圆。

椭圆不好处理怎么办，所有点横坐标缩小 $p$ 倍，这样椭圆的长半轴也缩小了 $p$ 倍，变成了圆，接下来直接跑一遍[最小覆盖圆](https://www.luogu.com.cn/blog/fantastic-minecraft/p2533-ahoi2012-xin-hao-ta-ti-xie)就好了。

最重要的一个问题就是如何把点顺时针旋转 $\alpha$ 度。

[![pCV4F8f.png](https://s1.ax1x.com/2023/06/11/pCV4F8f.png)](https://imgse.com/i/pCV4F8f)

如图，把点 $B$ 转到 $A$ 处时（$r$ 为半径）：

$$
\begin{cases}
  x_1 = r \cos(\alpha + \beta) = r \cos(\alpha)\cos(\beta) - r \sin(\alpha)\sin(\beta) \\

  y_1 = r \sin(\alpha + \beta) = r \sin(\alpha)\cos(\beta) + r \cos(\alpha)\sin(\beta)
\end{cases}
$$

因为：

$$ 
\begin{cases}
  x_0 = r \cos(\beta) \\
  y_0 = r \sin(\beta)
\end{cases}
$$

所以：

$$
\begin{cases}
  x_1 = x_0 \cos(\alpha) - y_0 \sin(\alpha) \\
  y_1 = x_0 \sin(\alpha) + y_0 \cos(\alpha)
\end{cases}
$$

因为这是逆时针旋转 $\alpha$ 度，而我们需要的是顺时针旋转 $\alpha$ 度，只需要把 $-\alpha$ 带入 $\alpha$ 就好了。

**注意 $\alpha$ 是角度制，因为 c++ 里的 `sin` 和 `cos` 都是弧度制的，我们要先把 $\alpha$ 变成 $\dfrac{\alpha \times \pi}{180}$ 再进行计算！！！！**

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define setp setprecision
#define mem(a, m) memset(a, m, sizeof(a))
#define double long double
#define Pi 3.14159265358979323846
using namespace std;

const double eps = 1e-12;
int n; 
double A, P;
struct node {
	double x, y;
	void turn()
	{
		double s = sin(-A), c = cos(-A);
		double xx = x, yy = y;
		x = xx * c - yy * s;
		y = xx * s + yy * c;
	}
}t[100005];
double r;//半径答案 
node p;//坐标答案 

double dist(node a, node b)
{
	double u = (a.x - b.x), v = (a.y - b.y);
	return sqrtl(u * u + v * v);
}
void work(node u, node v, node w)
{
	double a = 2 * (u.x - v.x);
	double b = 2 * (u.y - v.y);	
	double c = u.x * u.x + u.y * u.y - v.x * v.x - v.y * v.y;
	double d = 2 * (v.x - w.x);
	double e = 2 * (v.y - w.y);
	double f = v.x * v.x + v.y * v.y - w.x * w.x - w.y * w.y;
	double g = a * e - b * d;
	double px = (c * e - f * b) / g;
	double py = (a * f - d * c) / g;
	p = (node){px, py};
	r = dist(p, u);
}
int main()
{
	ios::sync_with_stdio(false);
	cin >> n;
	for(int i=1;i<=n;i++)	cin >> t[i].x >> t[i].y;
	cin >> A >> P;
	A = A * Pi / 180;
	random_shuffle(t+1, t+n+1);
	for(int i=1;i<=n;i++)	t[i].turn(), t[i].x /= P;
	for(int i=1;i<=n;i++)
	{
		if(dist(p, t[i]) <= r - eps)	continue;
		p = t[i], r = 0;
		for(int j=1;j<i;j++)
		{
			if(dist(p, t[j]) <= r - eps)	continue;
			p.x = (t[i].x + t[j].x) / 2;
			p.y = (t[i].y + t[j].y) / 2;
			r = dist(t[i], t[j]) / 2;
			for(int k=1;k<j;k++)
			{
				if(dist(p, t[k]) <= r - eps)	continue;
				work(t[i], t[j], t[k]);
			}
		}
	}
	cout << fixed << setp(3) << r << endl;
	return 0;
}
```


---

## 作者：__ycx2010__ (赞：1)

## 前言

[题目传送门](https://www.luogu.com.cn/problem/P4288)

## 分析

将原图中所有点 $(x, y)$ 映射到新图中 $(\frac{x}{p}, y)$ 的位置上。

新图中椭圆变成了圆，且与原图中的方案一一对应。

只要在新图中求一个最小圆覆盖即可。

## 实现

```
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>

#define x first
#define y second

using namespace std;

typedef pair<double, double> PDD;
const int N = 50010;
const double eps = 1e-12;
const double PI = acos(-1);

int n;
PDD q[N];
struct Circle
{
    PDD p;
    double r;
};

int sign(double x)
{
    if (fabs(x) < eps) return 0;
    if (x < 0) return -1;
    return 1;
}

int dcmp(double x, double y)
{
    if (fabs(x - y) < eps) return 0;
    if (x < y) return -1;
    return 1;
}

PDD operator+ (PDD a, PDD b)
{
    return {a.x + b.x, a.y + b.y};
}

PDD operator- (PDD a, PDD b)
{
    return {a.x - b.x, a.y - b.y};
}

PDD operator* (PDD a, double t)
{
    return {a.x * t, a.y * t};
}

PDD operator/ (PDD a, double t)
{
    return {a.x / t, a.y / t};
}

double operator* (PDD a, PDD b)
{
    return a.x * b.y - a.y * b.x;
}

PDD rotate(PDD a, double b)
{
    return {a.x * cos(b) + a.y * sin(b), -a.x * sin(b) + a.y * cos(b)};
}

double get_dist(PDD a, PDD b)
{
    double dx = a.x - b.x;
    double dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
}

PDD get_line_intersection(PDD p, PDD v, PDD q, PDD w)
{
    auto u = p - q;
    double t = w * u / (v * w);
    return p + v * t;
}

pair<PDD, PDD> get_line(PDD a, PDD b)
{
    return {(a + b) / 2, rotate(b - a, PI / 2)};
}

Circle get_circle(PDD a, PDD b, PDD c)
{
    auto u = get_line(a, b), v = get_line(a, c);
    auto p = get_line_intersection(u.x, u.y, v.x, v.y);
    return {p, get_dist(p, a)};
}

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%lf%lf", &q[i].x, &q[i].y);
    double a, p;
    scanf("%lf%lf", &a, &p);
    for (int i = 0; i < n; i ++ )
    {
        q[i] = rotate(q[i], a / 180 * PI);
        q[i].x /= p;
    }

    random_shuffle(q, q + n);
    Circle c({q[0], 0});
    for (int i = 1; i < n; i ++ )
        if (dcmp(c.r, get_dist(c.p, q[i])) < 0)
        {
            c = {q[i], 0};
            for (int j = 0; j < i; j ++ )
                if (dcmp(c.r, get_dist(c.p, q[j])) < 0)
                {
                    c = {(q[i] + q[j]) / 2, get_dist(q[i], q[j]) / 2};
                    for (int k = 0; k < j; k ++ )
                        if (dcmp(c.r, get_dist(c.p, q[k])) < 0)
                            c = get_circle(q[i], q[j], q[k]);
                }
        }

    printf("%.3lf", c.r);
    return 0;
}
```


---

## 作者：ztytql (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P4288)
## Description
给定一个正整数 $n$ 和 $n$ 个点的坐标，以及整数 $a$ 和 $p,$ 求满足覆盖所有点的，以 $a$ 度为正方向的最小椭圆的半短轴长度。
## Solution
乍一看这道题好像没有什么头绪，但感觉跟最小覆盖圆差不多，于是我们可以试着把这道题转化成最小覆盖圆。

首先要将椭圆转化为圆。因为我们发现答案要求半短轴长，所以我们可以将每个点乘 $\dfrac{1}{p},$ 即将 $x$ 轴收缩，就直接转化成了圆。

其次，题目中所要求的增幅方向是第二大难点。最小覆盖圆需要以椭圆的长轴为水平轴，可是移动坐标系比较麻烦，但是题目要求的是半短轴长，跟坐标没有直接关联，所以考虑直接旋转每一个点 $a$ 度，将椭圆转到水平轴在进行计算。

关于最小圆覆盖的解法，详见[此题](https://www.luogu.com.cn/problem/P1742)，这里不再过多赘述。

难点主要在于思路，其实代码思维难度并不高，都是板子。
## Code
```cpp
#include <bits/stdc++.h>
#define int long long

#define x first
#define y second

using namespace std;

typedef pair<double, double> PDD;
const int N = 50010;
const double eps = 1e-12;
const double PI = acos(-1);

int n;
PDD q[N];

struct circle
{
    PDD p;
    double r;
};

int sign(double x) // 判断正负
{
    if (fabs(x) < eps)
        return 0;
    if (x < 0)
        return -1;
    return -1;
}

int dcmp(double x, double y) // 判断大小关系
{
    if (fabs(x - y) < eps)
        return 0;
    if (x < y)
        return -1;
    return 1;
}

// 重载四则运算
PDD operator+ (PDD a, PDD b)
{
    return {a.x + b.x, a.y + b.y};
}

PDD operator- (PDD a, PDD b)
{
    return {a.x - b.x, a.y - b.y};
}

PDD operator* (PDD a, double t)
{
    return {a.x * t, a.y * t};
}

PDD operator/ (PDD a, double t)
{
    return {a.x / t, a.y / t};
}

double operator* (PDD a, PDD b) // 叉积
{
    return a.x * b.y - a.y * b.x;
}

PDD rotate(PDD a, double b) // 将 a 旋转 b 个角度
{
    return {a.x * cos(b) + a.y * sin(b), -a.x * sin(b) + a.y * cos(b)};
}

double get_dist(PDD a, PDD b) // 求距离
{
    double dx = a.x - b.x, dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
}

PDD get_point(PDD p, PDD v, PDD q, PDD w) // 求交点
{
    auto u = p - q;
    double t = w * u / (v * w);
    return p + v * t;
}

pair<PDD, PDD> get_line(PDD a, PDD b) // 求中垂线
{
    return {(a + b) / 2, rotate(b - a, PI / 2)};
}

circle get_circle(PDD a, PDD b, PDD c) // 根据三点求圆
{
    auto u = get_line(a, b), v = get_line(a, c);
    auto p = get_point(u.x, u.y, v.x, v.y);
    return {p, get_dist(p, a)};
}

signed main()
{
    cin >> n;
    for (int i = 0 ; i < n ; i ++)
        cin >> q[i].x >> q[i].y;
    double a, p; // p 是长轴与短轴的比，即放大倍数
    cin >> a >> p;
    for (int i = 0 ; i < n ; i ++)
    {
        q[i] = rotate(q[i], a / 180 * PI); // 将角度转化为弧度
        q[i].x /= p;
    }
    
    random_shuffle(q, q + n); // 随机化，防止被卡
    circle c({q[0], 0});
    // 求最小覆盖圆
    for (int i = 1 ; i < n ; i ++)
        if (dcmp(c.r, get_dist(c.p, q[i])) < 0)
        {
            c = {q[i], 0};
            for (int j = 0 ; j < i ; j ++)
                if (dcmp(c.r, get_dist(c.p, q[j])) < 0)
                {
                    c = {(q[i] + q[j]) / 2, get_dist(q[i], q[j]) / 2};
                    for (int k = 0 ; k < j ; k ++)
                        if (dcmp(c.r, get_dist(c.p, q[k])) < 0)
                            c = get_circle(q[i], q[j], q[k]);
                }
        }
    cout << fixed << setprecision(3) << c.r << endl;
    return 0;
}
```

最后还要注意一下：因为题目给的 $a$ 是角度，不是弧度，所以我们需要把角度乘以 $\dfrac{180}{\pi}$ 转化为弧度。

---

## 作者：cyn2006 (赞：1)

介于本题在这里介绍一些数学知识。

### $Part\ 1$

增幅仪的功耗正比于短半轴的长等价于一个直角坐标系中的椭圆：

![UkegRH.png](https://s1.ax1x.com/2020/07/07/UkegRH.png)

其中 $|\overrightarrow{AC}|$ 为短半轴，$|\overrightarrow{DB}|$ 为长半轴，即 $\frac{x^2}{a^2}+\frac{y^2}{b^2}=r^2$（椭圆方程）

原题中椭圆绕原点 $O$ 逆时针旋转 $\alpha^\circ\Longleftrightarrow$ 坐标系绕原点 $O$ 旋转 $(360-\alpha)^\circ$

由题意可知，令旋转后的椭圆点集为 $E=\{(x,y)\}$（长半轴在 $x$ 轴上，短半轴在 $y$ 轴上），可表达为 $\frac{x^2}{p^2}+y^2=0$，那么将 $x$ 轴上的实数都除以 $p$，该椭圆 $E$ 可转化为 $\{(x_0,y_0)|x_0=p^2x,y_0=y,(x,y)\in E\}=\{(x_0,y_0)|x_0^2+y_0^2=r^2\}$，即将椭圆转化成了圆。

- 关于点的旋转：

  ```cpp
  inline point mul(point a,point b){
      return point(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
  }
  inline point Angle(db a){
      return point(cos(a),sin(a));
  }
  inline point rotate(point a,db b){
      return mul(a,Angle(b));
  }
  //rotate(a,b) 表示将点 a 顺时针旋转 b 度（b 为弧度制）
  ```

  

### $Part\ 2$

原问题转化为：已知 $n$ 个点的坐标，求其最小圆覆盖。

[最小圆覆盖及其求解](https://www.luogu.com.cn/problem/solution/P1742)

主要是随机增量的渐进思想。



至此，本题得到解决。

---

## 作者：Genius_Star (赞：0)

### 思路：

考虑伸缩变换旋转，首先将坐标轴逆时针旋转 $\theta$ 度，即相当于将每个点绕原点逆时针 $\theta$ 度。

同时椭圆的长轴系数为 $b$，那么将每个点 $(x, y) \to (\frac{x}{b}, y)$，容易发现此时椭圆上的点在新的坐标系下为一个圆，且这个圆的半径为短轴长。

于是跑一次随机增量的最小圆覆盖即可，平均时间复杂度为 $O(N)$。

### 完整代码：

```cpp
 #include<bits/stdc++.h>
#define lowbit(x) x & (-x)
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define add(x, y) ((x + y >= mod) ? (x + y - mod) : (x + y))
#define dec(x, y) ((x - y < 0) ? (x - y + mod) : (x - y))
#define ctz(x) __builtin_ctz(x)
#define popcnt(x) __builtin_popcount(x)
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 5e4 + 10;
const db eps = 1e-9, pi = acos(-1);
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
int n;
db a, b;
class Point{
public:
	db x, y;
	inline Point(db _x = 0, db _y = 0){
		x = _x;
		y = _y;
	}
	inline bool operator<(const Point&rhs)const{
		if(x == rhs.x)
		  return y < rhs.y;
		return x < rhs.x;
	}
	inline void Read(){
		scanf("%lf%lf", &x, &y);
	}
	inline bool operator==(const Point &rhs)const{
		return (x == rhs.x) && (y == rhs.y);
	}
	inline Point operator-(const Point &rhs)const{
		return {x - rhs.x, y - rhs.y};
	}
	inline Point operator+(const Point &rhs)const{
		return {x + rhs.x, y + rhs.y};
	}
	inline Point operator*(const db &k)const{
		return {x * k, y * k};
	}
	inline Point operator/(const db &k)const{
		return {x / k, y / k};
	}
	inline friend Point rev(Point a){
		return {-a.y, a.x};
	}
	inline friend Point rotate(Point a, db theta){
		db coss = cos(theta), sinn = sin(theta);
//		cerr << coss << ' ' << sinn << ' ' << theta << ' ' << a.x * sinn + a.y * coss << '\n';
		return {a.x * coss - a.y * sinn, a.x * sinn + a.y * coss};
	}
	inline friend db dis(Point a, Point b){
		return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
	}
	inline friend db dot(Point a, Point b){
		return a.x * b.x + a.y * b.y;
	}	
	inline friend db cross(Point a, Point b){
		return a.x * b.y - a.y * b.x;
	}	
	inline friend db cross(Point a, Point b, Point c){
		return cross(b - a, c - a);
	}
	inline db operator*(const Point &rhs)const{
		return cross(*this, rhs);
	}
	inline friend Point getPoint(Point a, Point u, Point b, Point v){
		db t = ((a - b) * v) / (v * u);
		return a + (u * t);
	}
	inline friend pair<Point, Point> midLine(Point a, Point b){
		return {(a + b) / 2, rev(b - a)};
	}
}p[N];
class Circle{
public:
	Point u;
	db r;
	inline Circle(Point _u = 0, db _r = 0){
		u = _u;
		r = _r;
	}
};	
inline Circle cover(Point a, Point b){
	return {(a + b) / 2, dis(a, b) / 2};
}
inline Circle cover(Point a, Point b, Point c){
	auto u = midLine(a, b), v = midLine(a, c);
	auto t = getPoint(u.fi, u.se, v.fi, v.se);
	return {t, dis(a, t)};
}
inline Circle Smallest_circle(Point a[], int n){
	Circle ans = {a[1], 0};
	for(int i = 2; i <= n; ++i){
		if(ans.r < dis(a[i], ans.u)){
			ans = {a[i], 0};
			for(int j = 1; j < i; ++j){
				if(ans.r < dis(a[j], ans.u)){
					ans = cover(a[i], a[j]);
					for(int k = 1; k < j; ++k)
					  if(ans.r < dis(a[k], ans.u))
					    ans = cover(a[i], a[j], a[k]);
				}
			}
		}
	}
	return ans;
}
mt19937 R(time(0));
bool End;
signed main(){
//	freopen("1.in", "r", stdin);
	n = read();
	for(int i = 1; i <= n; ++i)
	  p[i].Read();
	a = read(), b = read();
	for(int i = 1; i <= n; ++i){
		p[i] = rotate(p[i], -a / 180 * pi);
		p[i].x /= b;
	}
	shuffle(p + 1, p + n + 1, R);
//	cerr << midLine(p[1], p[2]).fi.x << ' ' << midLine(p[1], p[2]).fi.y << ' ' << midLine(p[1], p[2]).se.x << ' ' << midLine(p[1], p[2]).se.y << '\n';
	auto ans = Smallest_circle(p, n);
	printf("%.3lf", ans.r);
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：1234567890sjx (赞：0)

前置知识：最小圆覆盖。

题目中给的是一个椭圆，性质十分的不优美！考虑把椭圆上的每一个点 $(x,y)$ 一一映射到一个新的圆上的一个点 $(x_0,y_0)$。然后就可以开心的跑最小圆覆盖啦！

问题在于如何快乐的映射。考虑首先旋转坐标系，让这个增加长度的方向旋转到和 $x$ 轴重合，然后把 $x$ 轴的每一个单位长度都变成原来的 $\frac{1}{p}$。这样一来就将原问题转化为了一个圆上最小覆盖的问题，且满足椭圆上的点和新的圆上的点一一对应。

然后这个题目就快乐的做完啦。因为几乎就是板子，所以不放代码啦。

---

## 作者：bloodstalk (赞：0)

感谢审核人
## Description
给定 $n$ 个点，椭圆长轴的方向 $a$ 和放大倍数 $p$，求覆盖全部点的最小椭圆的半短轴长度。

## Solution
让我们求最小覆盖椭圆，但是椭圆不具有什么好的性质，我们可以把椭圆转化成圆来做，这样，题目就转化成了最小覆盖圆，这个用随机增量法来做就可以了。

接下来我们考虑如何转化成圆。

首先从长轴方向 $a$ 入手，因为斜着求椭圆显然很麻烦，我们可以把它旋转到 $x$ 轴的方向，将 $x$ 轴逆时针旋转 $a$ 度与长轴重合显然也很麻烦，我们考虑等价操作：逆时针旋转坐标轴 $a$ 度，就等于顺时针旋转每个点 $a$ 度，因为本题只考虑半短轴的长度，所以坐标位置不用考虑，因此这两个操作等价。

接下来考虑怎么把椭圆转换成圆，这个相对来说好想一点，因为题目中扩大了 $x$ 坐标 $p$ 倍，所以说我们只需要把每个点的横坐标变成原来的 $\frac{1}{p}$ 即可，这样我们就把一个椭圆转化成圆了。

最后套一个随机增量法求最小圆覆盖即可。不会的可以看看[这一道题](https://www.luogu.com.cn/problem/P1742)。

## Code
```cpp
#include<bits/stdc++.h>
//#define int long long
#define ll long long
#define next nxt
#define re register
#define il inline
const int N = 5e4 + 5;
const double eps = 1e-6;
const double Pi = acos(-1.0);
using namespace std;

struct Point{
	double x,y;
}p[N];
struct Circle{
	Point p; double r;
}C;
struct Line{
	Point s,t;
}u,v;
int n; double a,b;

il int read()
{
	int f=0,s=0;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) f |= (ch=='-');
	for(; isdigit(ch);ch=getchar()) s = (s<<1) + (s<<3) + (ch^48);
	return f ? -s : s;
}

Point operator +(Point a,Point b) { return Point{a.x+b.x,a.y+b.y}; }//加

Point operator -(Point a,Point b) { return Point{a.x-b.x,a.y-b.y}; }//减

Point operator *(Point a,double t) { return Point{t * a.x,t * a.y}; }//数乘

Point operator /(Point a,double t) { return Point{a.x / t,a.y / t}; }//数除

il double operator *(Point a,Point b) { return a.x*b.y - a.y*b.x; }//叉积

il double operator &(Point a,Point b) { return a.x*b.x + a.y*b.y; }//点积

il double dis(Point a,Point b) { return sqrt((b-a)&(b-a)); }

Point GetNode(Point a,Point u,Point b,Point v)//求交点
{
	double t = (a-b)*v / (v*u);
	return a + u*t;
}

Point rotate(Point a,double b) { return Point{a.x*cos(b)-a.y*sin(b),a.y*cos(b)+a.x*sin(b)}; }

Line Midperp(Point a,Point b) { return Line{(a+b)/2,rotate(b-a,Pi/2)}; }//找中垂线

Circle cover(Point a,Point b) { return Circle{(a+b)/2,dis(a,b)/2}; }//覆盖两个点的最小圆就在他俩中点上

Circle cover(Point a,Point b,Point c)//三个点的圆，找中垂线的交点，即为答案
{
	u = Midperp(a,b) , v = Midperp(a,c);
	Point p = GetNode(u.s,u.t,v.s,v.t);
	return Circle{p,dis(p,a)};
}

il void Random_Increment()
{
	C = {p[1] , 0};
	for(re int i=2;i<=n;i++)
	{
		if(C.r < dis(C.p,p[i]))
		{
			C = {p[i] , 0};//一点圆
			for(re int j=1;j<i;j++)
			{
				if(C.r < dis(C.p,p[j]))//两点圆
				{
					C = cover(p[i],p[j]);
					for(re int k=1;k<j;k++)
					{
						if(C.r < dis(C.p,p[k]))//三点确定一个圆，可以证明这个复杂度是均摊O(n)的
							C = cover(p[i],p[j],p[k]);
					}
				}
			}
		}
	}
}

signed main()
{
	n = read();
	for(re int i=1;i<=n;i++) scanf("%lf%lf",&p[i].x,&p[i].y);
	scanf("%lf%lf",&a,&b);
	for(re int i=1;i<=n;i++)
	{
		p[i] = rotate(p[i],-a/180*Pi);
		p[i].x /= b;
	}
	random_shuffle(p+1,p+n+1);//随机打乱，保证复杂度
	Random_Increment();
	printf("%.3lf",C.r);
	return 0;
}
```

复杂度 $O(n)$，可以通过本题。

---


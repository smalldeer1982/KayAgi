# [HAOI2008] 排名系统

## 题目描述

排名系统通常要应付三种请求：上传一条新的得分记录、查询某个玩家的当前排名以及返回某个区段内的排名记录。当某个玩家上传自己最新的得分记录时，他原有的得分记录会被删除。为了减轻服务器负担，在返回某个区段内的排名记录时，最多返回 $10$ 条记录。

## 说明/提示

- 对于 $20\%$ 的数据，$N\le100$；
- 对于 $100\%$ 的数据，$N\le2.5\times10^5$。

## 样例 #1

### 输入

```
20
+ADAM 1000000
+BOB 1000000
+TOM 2000000
+CATHY 10000000
?TOM
?1
+DAM 100000
+BOB 1200000
+ADAM 900000
+FRANK 12340000
+LEO 9000000
+KAINE 9000000
+GRACE 8000000
+WALT 9000000
+SANDY 8000000
+MICK 9000000
+JACK 7320000
?2
?5
?KAINE```

### 输出

```
2
CATHY TOM ADAM BOB
CATHY LEO KAINE WALT MICK GRACE SANDY JACK TOM BOB
WALT MICK GRACE SANDY JACK TOM BOB ADAM DAM
4```

# 题解

## 作者：浅色调 (赞：12)

### Solution：
$\quad\;\;$(既然没有题解，那我pbds来水发题解咯！)

　　本题纯模拟~~平衡树+hash~~。

　　这种动态加点、改值、查询排名和k大值的问题，直接想到平衡树。

　　题目中需要用到的信息有：字符串、得分、时刻，其中时刻就是该字符串得到当前分数是第几次操作，维护时刻是因为对于得分相同的字符串，时刻小的要排在前面。

　　我们用~~一棵Splay来维护~~pbds中的rb_tree来维护。

　　对于每个字符串，把其和插入的时刻进行map映射，然后每个节点以分数为第一关键字、时刻为第二关键字，构建平衡树。对于每种操作：1、插入节点，直接可以insert ; 2、改变节点分数和时刻，我们直接改为删除这个节点，并加入新的值的节点 ; 3、查询排名，我们有order_of_key ; 4、查询第k大值，我们有find_by_order。

　　只需要模拟就好了，减少了很多冗余的码农操作（pbds大法好！）

$\quad\;\;$欢迎来踩博客：[five20](http://www.cnblogs.com/five20/p/9690055.html)（蒟蒻写题解不易，转载请注明出处，万分感谢！～）
### 代码：
```
    /*Code by 520 -- 9.21*/
    #include<bits/stdc++.h>
    #include<ext/pb_ds/assoc_container.hpp>
    #include<ext/pb_ds/tree_policy.hpp>
    #define il inline
    #define ll long long
    #define RE register
    #define For(i,a,b) for(RE int (i)=(a);(i)<=(b);(i)++)
    #define Bor(i,a,b) for(RE int (i)=(b);(i)>=(a);(i)--)
    using namespace std;
    using namespace __gnu_pbds;
    const int N=500005;
    int n,val[N],cnt,tot;
    map<string,int> mp;
    string ss[N];
    struct node{
        int v,id;
        bool operator < (const node &x) const {return v==x.v?id<x.id:v>x.v;}
    };
    tree<node,null_type,less<node>,rb_tree_tag,tree_order_statistics_node_update> T;
    il bool isdig(char x){return x>='0'&&x<='9';}
    int main(){
        ios::sync_with_stdio(0);
        cin>>n;char c;string s;int x,tp;
        while(n--){
            cin>>c>>s;
            if(c=='+') {
                if(mp[s]) {
                    tp=mp[s],T.erase(node{val[tp],tp});tot--;
                }
                mp[s]=++cnt,cin>>val[cnt],T.insert(node{val[cnt],cnt});tot++;
                ss[cnt]=s;
            }
            else if(c=='?'&&!isdig(s[0])) {
                x=mp[s];cout<<T.order_of_key(node{val[x],x})+1<<endl;
            }
            else {
                x=0;
                For(i,0,s.size()-1) x=(x<<3)+(x<<1)+(s[i]^48);
                tp=min(tot,x+9);
                For(i,x-1,tp-1) cout<<ss[T.find_by_order(i)->id]<<' ';cout<<endl;
            }
        }
        return 0;
    }    
```

---

## 作者：_luanyi_ (赞：7)

平衡树好题，本人使用 fhq。  
观察本题，发现本题与一般的 fhq 题目有些许不同：
 - 需要支持按排名分裂或者按权值分裂，分别实现即可；
 - 分数相同按时间排序，可以双关键字排序，但笔者使用了按照（分数 $\times260000+$ 时间（时间为倒序））作为节点的权值，排序起来更方便~~其实本质还是双关键字排序~~。

接下来分析题目所给的操作。

## 上传分数

我们给每个人编号，如果这个名字以前没有被编过号，就编一个号，并把权值扔进 fhq 中；如果这个名字已经编过号了，就把旧的权值删除，更新权值（外部数组记录），并将新权值扔进 fhq 中。

## 查询排名

对于输入给定的名字，先查阅其编号，再用外部数组查他的权值，将 fhq 按权值分裂，得到他的排名。

## 查询名字

首先按排名分裂，由于笔者的 fhq 权值从小到大排，故需要先将排名取个反。  
之后就变成了在一棵子树中查询排名为 $1\sim\min(10,size)$ 的节点的编号，其中 $size$ 为子树大小。  
由于笔者不是很聪明，采用了 `for` 循环加暴力分裂合并的方法，常数巨大~~差点过不去~~。  
具体地，若查询排名为 $i$ 的节点的权值，则将 $i$ 作为关键字按排名分裂，再在左子树中将 $i-1$ 作为关键字按排名分裂，注意如果查询到为空就及时退出，防止 RE。  

## code

trick：字符串处理推荐用 string，用起来很方便，但它只能 cin 和 cout，此时可以关闭同步流**和将 endl 改为 \`\n\`**。（实测能快亿倍，学校 OJ 过不去就是这样卡过去的）  
关闭同步流的方法：

```cpp
ios::sync_with_stdio (0); cin.tie (0); cout.tie (0);
```

但需注意之后只能 cin 和 cout，否则可能会出一些神奇的问题。

```cpp
#include <bits/stdc++.h>
#define fq(i,a,b) for (int i = (a); i <= (b); i++)
#define fnq(i,a,b) for (int i = (a); i < (b); i++)
#define nfq(i,a,b) for (int i = (a); i >= (b); i--)
#define nfnq(i,a,b) for (int i = (a); i > (b); i--)
#define fqs(i,a,b,c) for (int i = (a); i <= (b); i += (c))
#define fnqs(i,a,b,c) for (int i = (a); i < (b); i += (c))
#define nfqs(i,a,b,c) for (int i = (a); i >= (b); i -= (c))
#define nfnqs(i,a,b,c) for (int i = (a); i > (b); i -= (c))
#define elif else if
using namespace std;

#define int long long

//#define GRAPH
//const int EDGES = -1;
//const int VERTEXES = -1;
////# define EDGE_W
////typedef int W_TYPE;

//#define COMPLEX

inline int rd () {
	int f = 1;
	char ch = getchar ();
	while (!isdigit (ch)) (ch == '-' ? (f = -1) : 0), ch = getchar ();
	int num = 0;
	while (isdigit (ch)) num = num * 10 + ch - '0', ch = getchar ();
	return num * f;
}
#define d rd ()

inline int rd (const int modp) {
	int f = 1;
	char ch = getchar ();
	while (!isdigit (ch)) (ch == '-' ? (f = -1) : 0), ch = getchar ();
	int num = 0;
	while (isdigit (ch)) num = (num * 10 + ch - '0') % modp, ch = getchar ();
	return (num * f % modp + modp) % modp;
}

#ifdef GRAPH
struct Edge {
	int v, nxt;
# ifdef EDGE_W
	W_TYPE w;
# endif
	Edge () {}
# ifdef EDGE_W
	Edge (int _v, W_TYPE _w, int _nxt) {v = _v, w = _w, nxt = _nxt;}
# else
	Edge (int _v, int _nxt) {v = _v, nxt = _nxt;}
# endif
} edge[EDGES];
int head[VERTEXES], ecnt;
# ifdef EDGE_W
void addedge (int u, int v, W_TYPE w) {edge[++ecnt] = Edge (v, w, head[u]); head[u] = ecnt;}
#  define fe(u) for (int i = head[u], v, w; v = edge[i].v, w = edge[i].w, i; i = edge[i].nxt)
# else
void addedge (int u, int v) {edge[++ecnt] = Edge (v, head[u]); head[u] = ecnt;}
#  define fe(u) for (int i = head[u], v; v = edge[i].v, i; i = edge[i].nxt)
# endif
void init () {memset (head, 0, sizeof head); ecnt = 0;}
#endif

#ifdef COMPLEX
struct cpx {
	double a, b;
	cpx () {a = 0, b = 0;}
	cpx (double _a) {a = _a, b = 0;}
	cpx (double _a, double _b) {a = _a, b = _b;}
	friend cpx operator + (cpx a, cpx b) {return cpx (a.a + b.a, a.b + b.b);}
	friend cpx operator - (cpx a, cpx b) {return cpx (a.a - b.a, a.b - b.b);}
	friend cpx operator * (cpx a, cpx b) {return cpx (a.a * b.a - a.b * b.b, a.b * b.a + a.a * b.b);}
	friend cpx operator / (cpx a, cpx b) {return cpx ((a.a * b.a + a.b * b.b) / (b.b * b.b + b.a * b.a), (a.b * b.a - a.a * b.b) / (b.b * b.b + b.a * b.a));}
	friend cpx operator += (cpx &a, cpx b) {return a = a + b;}
	friend cpx operator -= (cpx &a, cpx b) {return a = a - b;}
	friend cpx operator *= (cpx &a, cpx b) {return a = a * b;}
	friend cpx operator /= (cpx &a, cpx b) {return a = a / b;}
};
#endif
// 以上均为码头，以下为主要程序 
const int maxn = 300300;
struct node {
	int l, r, pri, sz, key, id;
	node () {}
	node (int k, int i) {l = r = 0; sz = 1; key = k; id = i; pri = rand ();}
} tree[maxn]; int cnt;
#define sz(p) tree[p].sz
#define l(p) tree[p].l
#define r(p) tree[p].r
#define pri(p) tree[p].pri
#define key(p) tree[p].key
//开头5个宏，代码短一倍 
void push_up (int p) {sz (p) = sz (l (p)) + sz (r (p)) + 1;}
pair <int, int> split (int p, int k) {//按权值分裂，<k放左子树，>=k放右子树 
	if (!p) return make_pair (0, 0);
	if (k <= key (p)) {
		pair <int, int> q = split (l (p), k);
		l (p) = q.second;
		push_up (p);
		return make_pair (q.first, p);
	} else {
		pair <int, int> q = split (r (p), k);
		r (p) = q.first;
		push_up (p);
		return make_pair (p, q.second);
	}
}
pair <int, int> splitt (int p, int k) {//按排名分裂，<=k放左子树，>k放右子树 
	if (!k) return make_pair (0, p);
	if (!p) make_pair (0, 0);
	if (k <= sz (l (p))) {
		pair <int, int> q = splitt (l (p), k);
		l (p) = q.second; push_up (p);
		return make_pair (q.first, p);
	} elif (k == sz (l (p)) + 1) {
		int rr = r (p);
		r (p) = 0; push_up (p);
		return make_pair (p, rr);
	} else {
		pair <int, int> q = splitt (r (p), k - sz (l (p)) - 1);
		r (p) = q.first; push_up (p);
		return make_pair (p, q.second);
	}
}
int merge (int x, int y) {//合并 
	if (!x || !y) return x | y;
	if (pri (x) > pri (y)) {
		r (x) = merge (r (x), y);
		push_up (x);
		return x;
	} else {
		l (y) = merge (x, l (y));
		push_up (y);
		return y;
	}
}
int addnode (int id, int k) {tree[++cnt] = node (id, k); return cnt;}
int root;
void insert (int score, int id) {//插入 
	pair <int, int> q = split (root, score);
	root = merge (q.first, merge (addnode (score, id), q.second));
}
void erase (int score) {//删除 
	pair <int, int> q = split (root, score);
	pair <int, int> r = split (q.second, score + 1);
	root = merge (q.first, r.second);
}
map <string, int> mp; string mmp[maxn]; int ccnt; int sc[maxn];
const int shift = 260000;//乘以一个很大的数 
string s;
signed main () {
	ios::sync_with_stdio (0); cin.tie (0); cout.tie (0);//关闭同步流 
	int m; cin >> m; while (m--) {
		cin >> s;
		if (s[0] == '+') { int x; cin >> x;
			s = s.substr (1);
			if (!mp[s]) {//这个名字没有被编过号 
				mp[s] = ++ccnt;
				mmp[ccnt] = s;
				sc[ccnt] = x * shift + m;
				insert (x * shift + m, ccnt);
			} else {//这个名字编过号 
				erase (sc[mp[s]]);
				sc[mp[s]] = x * shift + m;
				insert (x * shift + m, mp[s]);
			}
		} else {
			s = s.substr (1);
			if (isdigit (s[0])) {//给排名查询名字 
				int num = 0;
				for (auto c : s) num = num * 10 + c - '0';
				pair <int, int> q = splitt (root, sz (root) - num + 1);
				fq (i, 1, 10) {//暴力查询 
					if (sz (q.first) - i < 0) break;//及时退出
					pair <int, int> r = splitt (q.first, sz (q.first) - i);
					pair <int, int> t = splitt (r.second, 1);
					if (!t.first) {
						q.first = merge (r.first, merge (t.first, t.second));
						break;//及时退出之前不要忘记merge回来
					}
					cout << mmp[tree[t.first].id] << ' ';
					q.first = merge (r.first, merge (t.first, t.second));
				} cout << '\n'; root = merge (q.first, q.second);
			} else {//给名字查询排名 
				int score = sc[mp[s]];
				pair <int, int> q = split (root, score);
				cout << sz (q.second) << '\n';
				root = merge (q.first, q.second);
			}
		}
	}
	return 0;
}

/*
20
+A 1
+B 1
+C 2
+D 3
?1
*/

```

可以从代码看出，fhq 的优点还是代码短，好写，好处理，**易 debug**。

---

## 作者：yybyyb (赞：7)

感觉好久没有发过题解了额，忽然想到顺手发发。

为啥泥萌都这么喜欢看我写$Splay$(雾

那就再来一道$Splay$模板题吧。然而这题数据很鬼，每次只跟着操作$Splay$是可以卡的，也很容易解决，每做个几百次操作就随机旋转一下就好了。
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<map>
using namespace std;
#define ll long long
#define ull unsigned long long
#define MAX 250500
#define ls (t[x].ch[0])
#define rs (t[x].ch[1])
#define inf 2000000000
const int base=233;
inline int read()
{
    int x=0;bool t=false;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=true,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return t?-x:x;
}
map<ull,int> M;
char name[MAX][20],ch[20];
int len[MAX];
struct Node
{
    int ch[2],ff;
    int v,size;
}t[MAX];
int rt,n,tot;
void pushup(int x){t[x].size=t[ls].size+t[rs].size+1;}
void rotate(int x)
{
    int y=t[x].ff,z=t[y].ff;
    int k=t[y].ch[1]==x;
    if(z)t[z].ch[t[z].ch[1]==y]=x;t[x].ff=z;
    t[y].ch[k]=t[x].ch[k^1];t[t[x].ch[k^1]].ff=y;
    t[x].ch[k^1]=y;t[y].ff=x;
    pushup(y);pushup(x);
}
void Splay(int x,int goal)
{
    while(t[x].ff!=goal)
    {
        int y=t[x].ff,z=t[y].ff;
        if(z!=goal)
            (t[y].ch[0]==x)^(t[z].ch[0]==y)?rotate(x):rotate(y);
        rotate(x);
    }
    if(!goal)rt=x;
}
void insert(int u,int id)
{
    int x=rt;
    while(233)
    {
        if(!t[x].ch[u>t[x].v])
        {
            t[id].ff=x;t[id].v=u;t[id].size=1;
            t[x].ch[u>t[x].v]=id;
            Splay(id,0);
            break;
        }
        else x=t[x].ch[u>t[x].v];
    }
}
int Kth(int K)
{
    int x=rt;
    while(233)
    {
        if(t[ls].size+1==K)return x;
        else if(t[ls].size>=K)x=ls;
        else K-=t[ls].size+1,x=rs;
    }
}
void Del(int x)
{
    Splay(x,0);int rk=t[ls].size;
    int l=Kth(rk),r=Kth(rk+2);
    Splay(l,0);Splay(r,l);t[r].ch[0]=0;
    pushup(r);pushup(l);
    t[x].ff=t[x].size=t[x].v=0;
}
int getnum(char *s)
{
    int l=strlen(s+1),ret=0;
    for(int i=1;i<=l;++i)ret=ret*10+s[i]-48;
    return ret;
}
ull gethash(char *s)
{
    int l=strlen(s+1);ull h=0;
    for(int i=1;i<=l;++i)h=h*base+s[i];
    return h;
}
void Output(int x,int &sum)
{
    if(sum>=10)return;
    if(rs)Output(rs,sum);
    if(sum>=10)return;
    if(x>2)
    {
        ++sum;
        for(int i=1;i<len[x];++i)
            putchar(name[x][i]);
        putchar(' ');
    }
    if(ls)Output(ls,sum);
}
int main()
{
    n=read();
    insert(-inf,++tot);insert(inf,++tot);
    while(n--)
    {
        scanf("%s",ch);
        if(ch[0]=='+')
        {
            ull h=gethash(ch);int sco=read(),id;
            if(M[h])id=M[h],Del(id),insert(sco,id);
            else
            {
                insert(sco,M[h]=id=++tot);
                for(int i=1,l=strlen(ch);i<l;++i)name[tot][i]=ch[i];
                len[tot]=strlen(ch);
            }
        }
        else if(ch[1]>='0'&&ch[1]<='9')
        {
            int rk=getnum(ch);
            int l=Kth(tot-rk+1);
            Splay(l,0);int sum=0;
            Output(t[l].ch[0],sum);puts("");
        }
        else
        {
            ull h=gethash(ch);
            int x=M[h];Splay(x,0);
            printf("%d\n",t[rs].size);
        }
        if(n%200==0)Splay(rand()%tot+1,0);
    }
    return 0;
}
```

---

## 作者：Huah (赞：5)

大家好，这题一看就是平衡树的裸题，但是我喜欢写线段树，所以我就用线段树过了此题

将所有查询按分数和插入的时间点进行离散化，每一个离散化的值分配一个单独的叶子结点，然后按操作顺序进行插入删除和查询操作即可，查询方式类似于可持久化线段树一样的查询方式，插入和删除就是普通的插入和删除操作。
```
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5;
map<string,int>mp;
struct node
{
    char c;
    string s;
    int x,id,p,hs,hsname;
    bool operator<(const node&o)const
    {
        if(x==o.x) return id<o.id;
        return x>o.x;
    }
}opt[N];
int n,m,f[N],p[N],t[N<<2];
void fix(int l,int r,int k,int x,int v)
{
    if(l==r)
    {t[k]=v;return;}
    int m=l+r>>1;
    if(x<=m) fix(l,m,k<<1,x,v);
    else fix(m+1,r,k<<1|1,x,v);
    t[k]=t[k<<1]+t[k<<1|1];
}
int query(int l,int r,int k,int x)
{
    if(l==r) return l;
    int m=l+r>>1;
    if(x<=t[k<<1]) return query(l,m,k<<1,x);
    return query(m+1,r,k<<1|1,x-t[k<<1]);
}
int query(int l,int r,int k,int x,int val)
{
    if(l==r) return val+1;
    int m=l+r>>1;
    if(x>m) return query(m+1,r,k<<1|1,x,val+t[k<<1]);
    return query(l,m,k<<1,x,val);
}
int main()
{
    cin.tie(0);
    cout.tie(0);
    cin>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>opt[i].c>>opt[i].s;
        if(opt[i].c!='+') opt[i].x=-1;
        else cin>>opt[i].x;
        opt[i].id=i;
    }
    sort(opt+1,opt+1+m);
    for(int i=1;i<=m;i++)
    {
        if(opt[i].s[0]>'9')
        {
            int k=mp[opt[i].s];
            if(k) opt[i].hsname=k;
            else mp[opt[i].s]=opt[i].hsname=i;
        }
        opt[i].hs=i;if(opt[i].x!=-1) n=i;
        p[opt[i].id]=i;
    }
    for(int j=1;j<=m;j++)
    {
        int i=p[j];
        if(opt[i].c=='+')
        {
            if(f[opt[i].hsname])
                fix(1,n,1,f[opt[i].hsname],0);
            f[opt[i].hsname]=opt[i].hs;
            fix(1,n,1,opt[i].hs,1);
        }
        else if(opt[i].s[0]>='0'&&opt[i].s[0]<='9')
        {
            int x=0;
            for(int k=0;k<opt[i].s.size();k++)
                x=(x<<1)+(x<<3)+opt[i].s[k]-'0';
            for(int i=1;i<=10&&x<=t[1];i++,x++)
                cout<<opt[query(1,n,1,x)].s<<' ';
            cout<<endl;
        }
        else  printf("%d\n",query(1,n,1,f[opt[i].hsname],0));
    }
}
```


---

## 作者：jia_shengyuan (赞：3)

可以说是一道很水的紫题。数据量很小，fhqtreap+cin 都能随便~~水~~过。

同时，本题解的代码应该是目前最简洁的。


------------

大体做法就是开个 `map` 存每个名字对应的分数、时间，然后用一个 `fhqtreap` 存储即可。因为排名由大到小，我们让左子树 $>$ 根 $>$ 右子树。

添加新分数就是把原有的删了新弄一个，同时更新 `map`；查排名和名字是平衡树基操，不过多解释。

值得一提的是，在读取数据的时候，我们大可不必手写一个从字符串里提取整数的东西，而是可以直接用 `sscanf` 函数。具体用法是第一个参数传字符串，后面的参数和 `scanf` 完全相同。

很方便的是，`std::string` 有 `const char*` 的构造函数。同时，我们可以利用指针的 `+1` 直接略过第一位。具体做法可以看代码。

不吸氧最慢的点 632ms。

```cpp
#include <iostream>
#include <cstdio>
#include <random>
#include <map>

const int MAXN = 2.5e5+9;
using namespace std;

struct Score {
    int score, dfn;
    inline bool operator > (const Score& other) const {
        if(score==other.score) return dfn<other.dfn;
        return score>other.score;
    }
};
struct node {
    int ls, rs, mark, size;
    Score score;
    string name;
}fhq[MAXN];
#define lson(i) fhq[fhq[i].ls]
#define rson(i) fhq[fhq[i].rs]

map<string, Score> nameToScore;
mt19937 rnd(114514);
int root, tot, N;

inline int newnode(string name, int val){
    fhq[++tot].mark=rnd();
    fhq[tot].name = name;
    fhq[tot].score = {val,tot};
    fhq[tot].size=1;
    return tot;
}
inline void pushup(int now){
    fhq[now].size=lson(now).size+rson(now).size+1;
}
// 按值分裂
void split_val(int now, Score key, int &a, int &b){
    if(!now){
        a=b=0;
        return;
    }
    if(fhq[now].score > key){
        a=now;
        split_val(fhq[now].rs, key, fhq[now].rs, b);
    } else {
        b=now;
        split_val(fhq[now].ls, key, a, fhq[now].ls);
    }
    pushup(now);
}
// 按大小分裂
void split_size(int now, int size, int &a, int &b){
    if(!now){
        a=b=0;
        return;
    }
    if(lson(now).size < size){
        a=now;
        split_size(fhq[now].rs, size-lson(now).size-1, fhq[now].rs, b);
    } else {
        b=now;
        split_size(fhq[now].ls, size, a, fhq[now].ls);
    }
    pushup(now);
}
// 合并
int merge(int a, int b){
    if(!a||!b) return a+b;
    if(fhq[a].mark >= fhq[b].mark){
        fhq[a].rs = merge(fhq[a].rs, b);
        pushup(a);
        return a;
    }
    fhq[b].ls = merge(a, fhq[b].ls);
    pushup(b);
    return b;
}

int a,b,c;
inline void insert(string name, int score){ // 添加新分数
    auto it = nameToScore.find(name);
    if(it != nameToScore.end()){ // 如果以前有，就要先删掉
        split_val(root, it->second, a, b);
        split_size(b,1,b,c);
        root = merge(a,c);
    }
    nameToScore[name] = {score, tot+1}; // 更新map
    split_val(root, {score, tot+1}, a, b);
    root = merge(merge(a, newnode(name, score)), b);
}
inline void query_rank(string name){ // 查询排名
    split_val(root, nameToScore[name], a, b);
    cout << fhq[a].size+1 << endl;
    root = merge(a,b);
}
void display(int now){ // 中序遍历输出名字
    if(!now) return;
    display(fhq[now].ls);
    cout << fhq[now].name << ' ';
    display(fhq[now].rs);
}
inline void query_sub(int begin){ // 查询排名记录
    split_size(root, begin-1, a, b); 
    split_size(b,10,b,c); // 如果b中元素不够十个，实际上什么都不会发生
    display(b);
    cout << endl;
    root=merge(a,merge(b,c));
}

int main(){
    ios::sync_with_stdio(false); cin.tie();
    int t, val; char cmd[32];
    cin >> t;
    while(t--){
        cin >> cmd;
        if(cmd[0] == '+'){
            cin >> val;
            insert(cmd+1, val); // cmd+1即略过了第零位的部分
        } else if(cmd[1] > '9'){
            query_rank(cmd+1);
        } else {
            sscanf(cmd+1,"%d",&val); // 从字符串中读取整数
            query_sub(val);
        }
    }
    return 0;
}
```


---

## 作者：MC_Launcher (赞：1)

### 题意：

建立一种数据结构，支持插入（分数对应的人，人对应的分数），删除（更新分数相当于删除再插入），查询三种操作，可以说是一道平衡树的模板题

这里就给大家介绍一下平衡树

如果你还没有学过二叉搜索树，请移步至 [[P5076]普通平衡树(弱化版)](https://www.luogu.com.cn/problem/P5076)

当然，如果不想花费太多时间，这里可以简要介绍一下。

二叉搜索树是以一棵二叉树为基础，对于每个节点，左子树中的所有节点都比它小，右子树中的所有节点都比它大。假设树上有 $n$个节点, 数据如果完全随机，这棵二叉树应该近似于完全二叉树，因此树的高度应该是 $\log n$ 左右，对于每次查询数对应的排名，只需要从根节点开始，判断比当前节点大或者小从而决定向左子树或者右子树走，因此预期平均复杂度为 $\log n$ ，同样，在查询排名所对应的数，只需要每次比较排名与左子树大小（即小于该节点的数的个数），因此复杂度也为 $\log n$ ，插入与查询类似，只是需要修改叶子节点的子节点。

但是如果经过精心构造的数据，比如说 $1,2,3,4,5$ 那么在插入的时候会把 $2$ 插入到 $1$ 右边,$3$ 插入到 $2$ 右边... 以此类推,最终会变成一条链，这样深度就变成了 $n$ ，查询时间也变成了 $O(n)$ ，所以我们需要想办法解决。

这里给大家介绍的是有旋 Treap ， Treap = Tree + Heap ，即树+堆，这里是要符合堆的性质，我们需要用一个随机权值来确定堆，比如说要让父节点的一个随机权值大于子节点的随机权值，这个随机权值自然是随机赋予的，所以可以保证数据随机性，就能不断修改符合堆的性质，也就保证了树的随机性。那么如何根据随机权值来修改呢，我们可以通过树的旋转得到

先给大家看一下旋转的代码

```cpp
int turn_l(int Old_Father)//左旋
{
    int RightSon=T[Old_Father].rs;
    int Old_LeftSon=T[RightSon].ls;
    T[RightSon].ls=Old_Father;
    T[Old_Father].rs=Old_LeftSon;
    pushup(Old_Father);
    pushup(RightSon);
    return RightSon;
}

int turn_r(int Old_Father)//右旋
{
    int LeftSon=T[Old_Father].ls;
    int Old_RightSon=T[LeftSon].rs;
    T[LeftSon].rs=Old_Father;
    T[Old_Father].ls=Old_RightSon;
    pushup(Old_Father);
    pushup(LeftSon);
    return LeftSon;
}
```

可能很多人并没有看懂，那么我在这里详细地解释一下，以左旋为例

 $T$ 数组是用来存这棵树的， $Old Father$ 是之前的父节点，  $RightSon$ 是它的右儿子，那么我们想要令右儿子变为父节点，显然父节点不可能变成右子节点，否则我们就会破坏这棵树，因此父节点会旋转成右子节点的左子节点，那么问题来了，右子节点现在有了 3 个子节点，显然已经不是二叉树了，而原来的父节点少了右子节点，那么我们将右子节点的左子树转交给父节点的右子树即可，显然，这些节点都比原来的父节点要大，所以没有破坏二叉搜索树，旋转后也仍然是原右子节点的左子树中的一部分。

图示如下

![](https://cdn.luogu.com.cn/upload/image_hosting/9kwrwdg6.png)

一开始以 $2$ 为根，要将它左旋

![](https://cdn.luogu.com.cn/upload/image_hosting/a4eozlto.png)

旋转后，可以看到 $1$ 有 $3$ 个子节点， $2$ 只有一个，于是我们需要把 $1$ 原来的左子节点 $4$ 变成 $2$ 的右子节点

![](https://cdn.luogu.com.cn/upload/image_hosting/redrceiu.png)

旋转完成，可以看到这两棵树的中序遍历都是 $3,2,4,1,5$ ，并没有破坏原有的二叉搜索树结构

那么为什么要 `return RightSon;` 呢？

我们在插入的时候会进行旋转，毫无疑问，插入后第一次旋转的只是它和它的父节点，于是我们就需要更新这个点的父节点所对应的子节点，这样会更方便；此外，旋转后可能仍然不满足父节点随机权值大于子节点，要继续旋转

插入的同时，我们还需要记得更新子树大小便于查询

插入代码如下

```cpp
int insert(long long New,int now,string name)//插入玩家数据
{
    if(now==0)
    {
        Playernum++;
        cnt++;
        T[cnt].Name=name;
        T[cnt].rk=rand()%1000000;
        T[cnt].val=New;
        T[cnt].size=1;
        return cnt;
    }
    if(New>T[now].val)//向右插入
    {
        T[now].rs=insert(New,T[now].rs,name);
        if(T[T[now].rs].rk>T[now].rk)
        {
            now=turn_l(now);//如果随机值比父节点大就左旋，同时更新根节点
        }
    }
    if(New<T[now].val)//向左插入
    {
        T[now].ls=insert(New,T[now].ls,name);
        if(T[T[now].ls].rk>T[now].rk)
        {
            now=turn_r(now);//如果随机值比父节点大就右旋，同时更新根节点
        }
    }
    pushup(now);
    return now;
}
```

这里的 `pushup(now);` 是用来更新子树大小的，代码如下

```cpp
void pushup(int i)//更新子树大小
{
    T[i].size=T[T[i].ls].size+T[T[i].rs].size+1;
}
```

根据插入操作是递归的，所以旋转某个根节点必定后于它的子节点，也就是说在它子树旋转完它才会旋转，不会破坏原有结构，所以说我们仍然可以更新它的大小为子树大小之和加上它本身

查询数所对应的排名只需要二分判断权值大小，权值大于当前值就在右子树中查找，反之在左子树中查找，代码如下，这里查找的是第 $K$ 小的（如果找到叶子节点还没找到说明这个数不存在）

```cpp
int FindK(long long Target,int now)//查询权值对应的数的排名
{
    if(now==0)//已经为叶子节点的子节点了
    {
        return 0;
    }
    if(T[now].val==Target)
    {
        return T[T[now].ls].size+1;
    }
    else if(Target>T[now].val)//在目前的右子树
    {
        return T[T[now].ls].size+1+FindK(Target,T[now].rs);//比它小的有左子树、根节点和右子树中的一部分
    }
    else//在目前的左子树
    {
        return FindK(Target,T[now].ls);
    }
}
```

删除数据也与之类似，但是我们在删除的时候不好处理子节点，而我们的旋转又是现成的了，直接将删除的节点转到叶子节点再进行删除即可，有右子节点就以它为根左旋，有左子节点就以它为根右旋即可。

```cpp
int delete_(long long Target,int now)//删除目标数据，返回删除后的根节点
{
    if(Target==T[now].val)
    {
        if(T[now].ls==0&&T[now].rs==0)//如果已经是叶子节点就直接删除
        {
            Playernum--;//玩家总数量
            return 0;
        }
        if(T[now].ls!=0)//还有左儿子
        {
            now=turn_r(now);
            T[now].rs=delete_(Target,T[now].rs);//旋转后继续查找
        }
        else if(T[now].rs!=0)//还有右儿子
        {
            now=turn_l(now);
            T[now].ls=delete_(Target,T[now].ls);//旋转后继续查找
        }
    }
    else if(Target>T[now].val)//在目标节点的右子树
    {
        T[now].rs=delete_(Target,T[now].rs);
    }
    else
    {
        T[now].ls=delete_(Target,T[now].ls);
    }
    pushup(now);
    return now;
}
```

查询排名所对应的数，在查询过程中不断判断左子树大小与其排名的关系即可，如果左子树大小超过了这个排名，那么说明它在左子树中；但是如果在右子树，需要把排名减去左子树大小与根节点，因为你存的是子树大小而非总体排名，代码如下

```cpp
string FindRank(long long Target,int now)//查询排名所对应的名字
{
    if(T[T[now].ls].size>=Target)//目标排名在目前的左子树中
    {
        return FindRank(Target,T[now].ls);
    }
    else if(T[T[now].ls].size+1==Target)//已经找到目标排名
    {
        return T[now].Name;
    }
    else//在右子树中
    {
        return FindRank(Target-T[T[now].ls].size-1,T[now].rs);
    }
}
```

事实上，我们只需要 `FindK` 和 `FindRank` 两个函数就能处理模板平衡二叉树中的查找前驱和后继，通过查询一个数的排名，再反过来用排名 $+ 1$ 和排名 $- 1$ 查询数即可

还有一个小问题，分数可能相同，按照时间排序，我们肯定是不希望每个节点上出现一条链的，那么我们可以类似于hash表的映射，将一个数扩大很多倍，减去它目前的时间戳（插入越晚时间戳越大，那么先插入的值一定大于后插入的），这个倍数的话我设定的是 `1e7` ，所以需要开个 `long long` 处理。

全部代码如下

```cpp
/*
写一棵平衡树，点权设置为score × 1e7 - 时间戳 支持插入，删除，查询
*/
#include<bits/stdc++.h>
using namespace std;
#define maxn 2000010
struct NodeSpot
{
    long long val;//点权
    int ls;//左儿子
    int rs;//右儿子
    string Name;//玩家名字
    int rk;//随机数
    int size;//以该节点为根的子树大小
}T[maxn];

int cnt;//目前到第几个节点了，这个与玩家数量要分开记

map<string,long long>Player;

long long Playernum;

void pushup(int i)//更新子树大小
{
    T[i].size=T[T[i].ls].size+T[T[i].rs].size+1;
}

int turn_l(int Old_Father)//左旋
{
    int RightSon=T[Old_Father].rs;
    int Old_LeftSon=T[RightSon].ls;
    T[RightSon].ls=Old_Father;
    T[Old_Father].rs=Old_LeftSon;
    pushup(Old_Father);
    pushup(RightSon);
    return RightSon;
}

int turn_r(int Old_Father)//右旋
{
    int LeftSon=T[Old_Father].ls;
    int Old_RightSon=T[LeftSon].rs;
    T[LeftSon].rs=Old_Father;
    T[Old_Father].ls=Old_RightSon;
    pushup(Old_Father);
    pushup(LeftSon);
    return LeftSon;
}

int insert(long long New,int now,string name)//插入玩家数据
{
    if(now==0)
    {
        Playernum++;//记录玩家数量
        cnt++;
        T[cnt].Name=name;//建点
        T[cnt].rk=rand()%1000000;//赋随机权值
        T[cnt].val=New;
        T[cnt].size=1;
        return cnt;
    }
    if(New>T[now].val)//向右插入
    {
        T[now].rs=insert(New,T[now].rs,name);
        if(T[T[now].rs].rk>T[now].rk)
        {
            now=turn_l(now);//如果随机值比父节点大就左旋，同时更新根节点
        }
    }
    if(New<T[now].val)//向左插入
    {
        T[now].ls=insert(New,T[now].ls,name);
        if(T[T[now].ls].rk>T[now].rk)
        {
            now=turn_r(now);//如果随机值比父节点大就右旋，同时更新根节点
        }
    }
    pushup(now);
    return now;
}

int delete_(long long Target,int now)//删除目标数据，返回删除后的根节点
{
    if(Target==T[now].val)
    {
        if(T[now].ls==0&&T[now].rs==0)//如果已经是叶子节点就直接删除
        {
            Playernum--;
            return 0;
        }
        if(T[now].ls!=0)//还有左儿子
        {
            now=turn_r(now);
            T[now].rs=delete_(Target,T[now].rs);//旋转后继续查找
        }
        else if(T[now].rs!=0)//还有右儿子
        {
            now=turn_l(now);
            T[now].ls=delete_(Target,T[now].ls);//旋转后继续查找
        }
    }
    else if(Target>T[now].val)//在目标节点的右子树
    {
        T[now].rs=delete_(Target,T[now].rs);
    }
    else
    {
        T[now].ls=delete_(Target,T[now].ls);
    }
    pushup(now);
    return now;
}

int FindK(long long Target,int now)//查询权值对应的数的排名
{
    if(now==0)
    {
        return 0;
    }
    if(T[now].val==Target)
    {
        return T[T[now].ls].size+1;
    }
    else if(Target>T[now].val)//在目前的右子树
    {
        return T[T[now].ls].size+1+FindK(Target,T[now].rs);
    }
    else//在目前的左子树
    {
        return FindK(Target,T[now].ls);
    }
}

string FindRank(long long Target,int now)//查询排名所对应的名字
{
    if(T[T[now].ls].size>=Target)//目标排名在目前的左子树中
    {
        return FindRank(Target,T[now].ls);
    }
    else if(T[T[now].ls].size+1==Target)//已经找到目标排名
    {
        return T[now].Name;
    }
    else//在右子树中
    {
        return FindRank(Target-T[T[now].ls].size-1,T[now].rs);
    }
}

int n;//总询问数

int main()
{
    scanf("%d",&n);
    int root=0;
    for(int i=1;i<=n;i++)
    {
       char type;
       string sc_or_na;
       cin>>type;
       cin>>sc_or_na;
        if(type=='+')//添加玩家分数
        {
            long long add;
            scanf("%lld",&add);
            add*=10000000;//赋予新权值
            add-=i;
            if(Player[sc_or_na]!=0)//判断这个玩家是否出现过
            {
                root=delete_(Player[sc_or_na],root);//删除原有数据，更新根节点
            }
            Player[sc_or_na]=add;//储存新数据
            root=insert(add,root,sc_or_na);
        }
        else
        {
            long long add=0;
            if(sc_or_na[0]>='0'&&sc_or_na[0]<='9')
            {
                for(int i=0;i<sc_or_na.size();i++)
                {
                    add*=10;
                    add+=(sc_or_na[i]-'0');//查询排名，排名从大到小，要减去
                }
                for(int i=add;i<=min(Playernum,add+9);i++)
                {
                    cout<<FindRank(Playernum-i+1,root)<<" ";
                }
                cout<<endl;
            }
            else//查询玩家排名，排名是从大到小的，所以要减去
            {
                cout<<Playernum-FindK(Player[sc_or_na],root)+1<<endl;
            }
        }
    }
}
```

写在最后：其实平衡树并不算很难，刚开始学的时候觉得是神仙东西，实现起来很麻烦，但是只要知道了其中的原理的话，大致构架可以写出来慢慢调试，个人较为反对STL的封装的(去搜索pbds)，毕竟这玩意学了是自己的，祝各位OIer都能努力拼搏，实现理想

---

## 作者：GoPoux4 (赞：1)

~~平衡树裸题，fhq水过。~~

---

这道题一看到“排名”，就想到平衡树。

然而这道题需要在平衡树上加入第二键值，这里介绍一种方法处理这种问题：

 _一般来说，如果有两个需要优化的量 $v_1,v_2$，要求首先满足 $v_1$ 最小，在 $v_1$ 相同的情况下 $v_2$ 最小，则可以把二者合并成一个量 $Mv_1+v_2$ ，其中 $M$ 是一个比“$v_2$的最大理论值和 $v_1$ 的最小理论值之差”还要大的数。_ 

_——刘汝佳 《算法竞赛入门经典--训练指南》_

回到这道题，我们需要让排在前面的人首先满足 $score$ 最大，在 $score$ 相同的情况下 $time$ 最小，即 $-time$ 最大，即可把二者合并为一个数 $val=M * score-time$，这里 $M$ 取 $maxn=250000$ 即可。

用平衡树维护 $val$ 即可。

---

代码：因为有 $map$ 和字符串操作，轻微卡常。

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <map>
#include <string>
#define maxn 250005
#define lxl long long
using namespace std;

int n,x,y,z;
int root,tot,ch[maxn][2],size[maxn],rnd[maxn];
lxl val[maxn];
string str[maxn];
std::map<string,int> Name;

inline void update(int p)
{
	size[p]=size[ch[p][0]]+size[ch[p][1]]+1;
}

inline void split_val(int p,lxl k,int &x,int &y)
{
	if(!p) {x=y=0;return;}
	if(k>=val[p])
	{
		x=p;
		split_val(ch[p][1],k,ch[p][1],y);
	}
	else
	{
		y=p;
		split_val(ch[p][0],k,x,ch[p][0]);
	}
	update(p);
}

inline void split_rank(int p,int k,int &x,int &y)
{
	if(!p) {x=y=0;return;}
	if(k>=size[ch[p][0]]+1)
	{
		x=p;
		split_rank(ch[p][1],k-size[ch[p][0]]-1,ch[p][1],y);
	}
	else
	{
		y=p;
		split_rank(ch[p][0],k,x,ch[p][0]);
	}
	update(p);
}

inline int merge(int a,int b)
{
	if(!a||!b) return a|b;
	if(rnd[a]<rnd[b])
	{
		ch[a][1]=merge(ch[a][1],b);
		update(a);
		return a;
	}
	else
	{
		ch[b][0]=merge(a,ch[b][0]);
		update(b);
		return b;
	}
}

inline void erase(lxl k)
{
	split_val(root,k,x,z);
	split_val(x,k-1,x,y);
	root=merge(x,z);
}

inline int new_node(string s,int score,int time)
{
	size[++tot]=1;
	str[tot]=s;
	val[tot]=(lxl)score*maxn-time;//计算合并后的值
	rnd[tot]=rand();
	return tot;
}

inline void insert(string s,int score,int time)
{
	if(Name[s]) erase(val[Name[s]]);
	Name[s]=new_node(s,score,time);
	split_val(root,val[tot],x,y);
	root=merge(merge(x,tot),y);
}

inline void print(int p)
{
	if(!p) return;
	print(ch[p][1]);
	cout<<str[p]<<' ';
	print(ch[p][0]);
}

inline void index(int k)
{
	int nowtot=size[root];
	split_rank(root,nowtot-k+1,x,z);
	split_rank(x,max(nowtot-k-9,0),x,y);
	print(y);cout<<"\n";//用\n更快
	root=merge(merge(x,y),z);
}

inline void rnk(string s)
{
	int p=Name[s];
	split_val(root,val[p],x,y);
	int ans=size[y]+1;
	root=merge(x,y);
	cout<<ans<<"\n";//用\n更快
}

inline int readstr(string s)
{
	int len=s.size(),x=0;
	for(int i=0;i<len;i++)
		x=(x<<1)+(x<<3)+s[i]-'0';
	return x;
}

int main()
{
	//freopen("P4291.in","r",stdin);
	ios::sync_with_stdio(false); //关闭同步加速，所以不能用getchar快读
	cin>>n;
	char opt;
	string s;
	int score;
	for(int i=1;i<=n;i++)
	{
		cin>>opt;
		if(opt=='+')
		{
			cin>>s>>score;
			insert(s,score,i);
		}
		else if(opt=='?')
		{
			cin>>s;
			if(s[0]>='0'&&s[0]<='9') index(readstr(s));
			else rnk(s);
		}
	}
	return 0;
}

```


---

## 作者：吾王美如画 (赞：1)

# 唔姆
看没有treap的题解就来一篇吧

(常数有点大，大佬追求速度还是算了

------------
- 首先不考虑上传时间这个因素，那就是一个标准的名次树，想必大家都会了。
- 而加了时间这个因素，我们就有两个关键字了，所以以分数为第一关键字，上传时间为第二关键字维护一个名次树（其实也就是在大小相同的时候加个特判），就莫得问题了。
- 然鹅我们发现，treap好像很难连续访问多个节点，因为不能像splay那样旋转（jiojio，我发现treap是有极限的！），所以我们直接暴力进行十次查询（这就是常数巨大的原因QAQ，不过亲测稳过）

辣么上代码
```cpp
#include<bits/stdc++.h>
#define MAXN 1000100
#define INF 2147483647
using namespace std;
int sum=0,R=0;
int n;
struct qwq{
    int key;
    int t;
};
struct node{
       int son[2];
       int num;
       int size;
       int key;
       int rd;
       int time;
       string s; 
}tree[MAXN];
void up(int now){
     tree[now].size=tree[tree[now].son[0]].size+tree[tree[now].son[1]].size+tree[now].num;
}
void rotate(int &now,int d){
     int to=tree[now].son[!d];
     tree[now].son[!d]=tree[to].son[d];
     tree[to].son[d]=now;
     up(now);
     up(to);
     now=to;
}
void change(int &now,int x,int y,string s){
     if (!now){now=++sum;tree[now].size=tree[now].num=1;tree[now].key=x;tree[now].rd=rand();tree[now].time=y;tree[now].s=s;return;} 
     int tmp=(x>tree[now].key);
     change(tree[now].son[tmp],x,y,s);
     if (tree[now].rd>tree[tree[now].son[tmp]].rd)rotate(now,!tmp);
     up(now);
}
void del(int &now,int x,int y){
     if(!now)return;
     if (x==tree[now].key&&y==tree[now].time){
                       if(!tree[now].son[0]&&!tree[now].son[1]){
                                                      tree[now].num--;tree[now].size--;
                                                      if(!tree[now].num)now=0;
                       }
                       else if(tree[now].son[0]&&!tree[now].son[1]){
                                                          rotate(now,1);
                                                          del(tree[now].son[1],x,y);
                       }
                       else if(!tree[now].son[0]&&tree[now].son[1]){
                                                          rotate(now,0);
                                                          del(tree[now].son[0],x,y);
                       }
                       else {int tmp=(tree[tree[now].son[0]].rd>tree[tree[now].son[1]].rd);
                            rotate(now,tmp);
                            del(tree[now].son[tmp],x,y);
                       }
     }
     else{
          int tmp;
          if (x>tree[now].key||(x==tree[now].key&&y<tree[now].time))tmp=1;
          else tmp=0;
          del(tree[now].son[tmp],x,y);
     }
     up(now);
}
int rank(int now,int x,int y){
    if (!now)return 0;
    if (tree[now].key==x&&tree[now].time==y)return tree[tree[now].son[1]].size+1;
    else if (tree[now].key<x||(tree[now].key==x&&tree[now].time>y)) return rank(tree[now].son[1],x,y);
    else return tree[tree[now].son[1]].size+tree[now].num+rank(tree[now].son[0],x,y);
}
int find(int now,int x){
    if (!now)return 0;
    if (tree[tree[now].son[1]].size>=x)return find(tree[now].son[1],x);
    else if (tree[tree[now].son[1]].size+tree[now].num>=x)return now;
    else return find(tree[now].son[0],x-tree[tree[now].son[1]].size-tree[now].num);
}
int main(){
    map<string,qwq> imp;
    cin>>n;
    for(int i=1;i<=n;i++){
        string s;
        cin>>s;
        if (s[0]=='+'){
            int a;
            s=s.substr(1);
            scanf("%d",&a);
            if (imp.count(s))del(R,imp[s].key,imp[s].t);
            imp[s].key=a;
            imp[s].t=i;
            change(R,a,i,s);
        }
        else {
            if (s[1]<='9'&&s[1]>='0'){
                int a=0;
                for(int i=1;i<=s.length()-1;i++)
                    a=a*10+s[i]-'0';
                for(int i=a;i<=a+9;i++){
                    int b=find(R,i);
                    if (!b)break;
                    else cout<<tree[b].s<<" ";
                }
                printf("\n");
            } 
            else {
                qwq a;
                s=s.substr(1);
                a=imp[s];
                printf("%d\n",rank(R,a.key,a.t)); 
            }
        }
    }
    return 0;
}

```


---

## 作者：happybob (赞：0)

自定义结构体维护平衡树即可，并不需要哈希。

我们对于每个结构体维护名字、分数和插入时的编号。先按分数，后按插入编号重载运算符即可。

根据题意，我们要支持插入，求排名，按照排名求值以及删除操作。因为如果一个人的分数被更新，我们要在平衡树中修改它，即先删除后插入。

由于需要删除操作，所以需要写前驱操作，不过也是平衡树基础操作。

删除操作具体是，把要删除的点转到根，如果这个点的 $cnt > 1$，那么就 $cnt \leftarrow cnt - 1$，否则合并两个子树。合并时把左子树的最大值转到根，然后将右子树接上根的右儿子即可。

写的 Splay，常数非常大，不开 O2 会超时 $2$ 个点。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <set>
#include <climits>
#include <map>
using namespace std;

const int N = 3e5 + 5;

int n;

struct User
{
	string name;
	long long score;
	int id;
	User(){}
	User(string _n, long long _s, int _i): name(_n), score(_s), id(_i){}
	bool operator==(const User& g) const
	{
		return name == g.name && score == g.score && id == g.id;
	}
	bool operator<(const User& g) const
	{
		if (score ^ g.score) return score > g.score;
		return id < g.id;
	}
	bool operator>(const User& g) const
	{
		if (score ^ g.score) return score < g.score;
		return id > g.id;
	}
};

class Splay
{
public:
	int idx, rt;
	struct Node
	{
		int fa, son[2], sz, cnt;
		User val;
	}tr[N];
	int get(int x)
	{
		return x == tr[tr[x].fa].son[1];
	}
	void pushup(int u)
	{
		tr[u].sz = tr[tr[u].son[0]].sz + tr[tr[u].son[1]].sz + tr[u].cnt;
	}
	void rotate(int x)
	{
		int y = tr[x].fa, z = tr[y].fa;
		int chkx = get(x), chky = get(y);
		tr[y].son[chkx] = tr[x].son[chkx ^ 1];
		if (tr[x].son[chkx ^ 1]) tr[tr[x].son[chkx ^ 1]].fa = y;
		tr[x].son[chkx ^ 1] = y;
		tr[y].fa = x;
		tr[x].fa = z;
		if (z) tr[z].son[chky] = x;
		pushup(y);
		pushup(x);
	}
	void splay(int u)
	{
		for (int f = tr[u].fa; f = tr[u].fa, f; rotate(u))
		{
			if (tr[f].fa) rotate(get(f) == get(u) ? f : u);
		}
		rt = u;
	}
	void ins(User g)
	{
		if (!rt)
		{
			rt = ++idx;
			tr[rt].val = g;
			tr[rt].cnt = 1;
			pushup(rt);
			return;
		}
		int u = rt, f, last;
		while (true)
		{
			if (tr[u].val == g)
			{
				tr[u].cnt++;
				pushup(u);
				pushup(f);
				splay(u);
				return;
			}
			if (!u)
			{
				u = ++idx;
				tr[u].cnt = 1;
				tr[u].val = g;
				tr[u].fa = f;
				tr[f].son[last] = u;
				pushup(u);
				pushup(f);
				splay(u);
				return;
			}
			f = u;
			last = g > tr[u].val;
			u = tr[u].son[last];
		}
	}
	int rank(User x)
	{
		int res = 0, u = rt;
		while (true)
		{
			if (tr[u].val == x)
			{
				res += tr[tr[u].son[0]].sz;
				splay(u);
				return res + 1;
			}
			if (tr[u].val > x)
			{
				u = tr[u].son[0];
			}
			else
			{
				res += tr[tr[u].son[0]].sz + tr[u].cnt;
				u = tr[u].son[1];
			}
		}
	}
	User kth(int k)
	{
		int u = rt;
		while (true)
		{
			if (tr[tr[u].son[0]].sz >= k)
			{
				u = tr[u].son[0];
			}
			else if (tr[tr[u].son[0]].sz + 1 == k)
			{
				splay(u);
				return tr[u].val;
			}
			else
			{
				k -= tr[tr[u].son[0]].sz + tr[u].cnt;
				u = tr[u].son[1];
			}
		}
	}
	void CLEAR(int u)
	{
		tr[u].cnt = tr[u].fa = tr[u].son[0] = tr[u].son[1] = tr[u].sz = 0;
		tr[u].val.id = tr[u].val.score = 0;
		tr[u].val.name = "";
	}
	User pre()
	{
		int u = tr[rt].son[0];
		if (!u) return User("", 0LL, 0);
		while (tr[u].son[1]) u = tr[u].son[1];
		splay(u);
		return tr[u].val;
	}
	void del(User p)
	{
		rank(p);
		int u = rt;
		if (tr[u].cnt > 1)
		{
			tr[u].cnt--;
			pushup(u);
			return;
		}
		if (!tr[u].son[0])
		{
			rt = tr[u].son[1];
			tr[rt].fa = 0;
			CLEAR(u);
			return;
		}
		if (!tr[u].son[1])
		{
			rt = tr[u].son[0];
			tr[rt].fa = 0;
			CLEAR(u);
			return;
		}
		pre();
		tr[rt].son[1] = tr[u].son[1];
		tr[tr[u].son[1]].fa = rt;
		pushup(rt);
		CLEAR(u);
	}
}tr;

map<string, User> st;

int main()
{
	cin >> n;
	tr.ins(User("PPPPP", INT_MIN, INT_MIN));
	tr.ins(User("PPPPP", INT_MAX, INT_MAX));
	for (int i = 1; i <= n; i++)
	{
		char c;
		cin >> c;
		if (c == '+')
		{
			string name;
			long long score;
			cin >> name >> score;
			if (st.count(name))
			{
				tr.del(st[name]);
			}
			st[name] = User(name, score, i);
			tr.ins(st[name]);
		}
		else if (c == '?')
		{
			string s;
			cin >> s;
			bool flag = 1;
			for (auto i : s)
			{
				if (!(i >= '0' && i <= '9'))
				{
					flag = 0;
					break;
				}
			}
			if (flag)
			{
				int x = stoi(s);
				for (int i = 1; i <= 10; i++)
				{
					User g = tr.kth(x + i);
					if (g.name == "PPPPP")
					{
						break;
					}
					cout << g.name << " ";
				}
				cout << "\n";
			}
			else
			{
				cout << tr.rank(st[s]) - 1 << "\n";
			}
		}
	}
	return 0;
}
```


---

## 作者：_Vix_ (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P4291)

## 题意
维护一种数据结构，支持以下操作：

1. 插入元素
2. 查询元素排名
3. 查询区间元素

范围：$10 \le n \le 250000$。

## 分析

看到排名，很容易想到平衡树。谁能拒绝 fhq 呢，主要是好写。但是既要有排名，又要有区间，那么 $\texttt{split}$ 函数必须支持可以按照 $\texttt{val}$ 分，也可以按照 $\texttt{siz}$ 分。而这道题里，排名按照 $\texttt{val}$ 划分，所以 $\texttt{val}$ 与 $\texttt{siz}$ 不相冲突，直接写两个 $\texttt{split}$ 函数即可。其他的操作都是模板啦。

## 细节

1. 同一个人的排名可以被更新，用 map 记录一下。如果 map 里有这个元素，先删除旧的，再插入新的。
2. 因为有时间的先后，所以平衡树里要按照双关键字排序。
3. 本题输入比较烦人，这里用 string 很方便。

（笔者这里是把 fhq 封装起来了，看起来比较简洁）

## Code
```cpp
#include <bits/stdc++.h>
#define gc getchar
#define PII pair<int, int>
using namespace std;

inline int read() {
	int x = 0; bool flag = 0; char ch = gc();
	for (;!isdigit(ch); ch = gc()) flag |= ch == '-';
	for (; isdigit(ch); ch = gc()) x = (x << 1) + (x << 3) + (ch ^ 48);
	return flag ? ~(x - 1) : x;
}

const int N = 5e5 + 10;
int n, v;
string str;

struct fhq {
	int rt, idx, x, y, z;
	int son[N][2], siz[N], val[N], tim[N], rnd[N];
	string name[N];
	map<string, PII> mp;
	int New(int v, int t, string s) {
		int u = ++idx;
		val[u] = v, tim[u] = t, name[u] = s;
		rnd[u] = rand(), siz[u] = 1;
		return u;
	}
	void update(int u) {
		siz[u] = siz[son[u][0]] + siz[son[u][1]] + 1;
	}
	void split_val(int u, int v, int t, int &x, int &y) {
		if (!u) x = y = 0;
		else {
			if (val[u] > v || (val[u] == v && tim[u] < t)) x = u, split_val(son[x][1], v, t, son[x][1], y);
			else y = u, split_val(son[u][0], v, t, x, son[u][0]);
			update(u);
		}
	}
	void split_siz(int u, int k, int &x, int &y) {
		if (!u) x = y = 0;
		else {
			if (siz[son[u][0]] < k) x = u, split_siz(son[u][1], k - siz[son[u][0]] - 1, son[u][1], y);
			else y = u, split_siz(son[u][0], k, x, son[u][0]);
			update(u);
		}
	}//两个 split
	int merge(int x, int y) {
		if (!x || !y) return x + y;
		if (rnd[x] < rnd[y]) {
			son[x][1] = merge(son[x][1], y);
			update(x);
			return x;
		} else {
			son[y][0] = merge(x, son[y][0]);
			update(y);
			return y;
		}
	}
	void add(int v, int t, string s) {
		if (mp.find(s) != mp.end()) {
			split_val(rt, mp[s].first, mp[s].second, x, y);
			split_siz(y, 1, y, z);
			rt = merge(x, z);
		}
		mp[s] = {v, t};
		split_val(rt, v, t, x, y);
		rt = merge(merge(x, New(v, t, s)), y);
	}
	int rank(string s) {
		split_val(rt, mp[s].first, mp[s].second, x, y);
		int res = siz[x] + 1;
		rt = merge(x, y);
		return res;
	}
	void print(int u) {
		if (!u) return;
		print(son[u][0]);
		cout << name[u] << " ";
		print(son[u][1]);
	}//直接中序遍历输出就是答案
	void index(int k) {
		split_siz(rt, k - 1, x, y);
		split_siz(y, min(10, siz[y]), y, z);
		print(y); puts("");
		rt = merge(merge(x, y), z);
	}
} tr;

int main() {
	n = read();
	for (int t = 1; t <= n; t++) {
		cin >> str;
		if (str[0] == '+') v = read(), tr.add(v, t, str.substr(1));//这里要去掉开头的操作符
		else if (str[0] == '?' && !isdigit(str[1])) printf("%d\n", tr.rank(str.substr(1)));
		else {
			int k = 0;
			for (int i = 1; i < str.size(); i++)//是从 1 开始哦
				k = k * 10 + str[i] - '0';
			tr.index(k);
		}
	}
	return 0;
}
```


---

## 作者：封禁用户 (赞：0)

这是一道平衡树题，我就习惯写 fhq 了。

另外这题是有多关键字的，可以把一个人的权值乘以一个极大值（不要爆了）加上他的加入的时间。同时权值分裂和排名分裂都要用。

在平衡树上维护 $val$ 数组（也就是权值）。

这题有三个操作：

1. 插入：先用 map 看看有没有插入过此人，如果有就先删除原有记录，然后新建一个节点，按权值分裂。

1. 查询（Name）：用map找出他的加入时间，按权值分裂，找出他的排名。

1. 查询（Index）：按排名分裂出要求的前几个，输出即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 114514
#define M 3000001
#define ll long long
#define re register
#define in inline
#define ls c[now][0]
#define rs c[now][1]
ll n;
ll val[M],size[M],rd[M],c[M][2],bh[M];
string ren[M];
ll root,tot,ans,total;
ll x,y,z;
char ch;
string name;
map <string,ll> id;
//以下都为板子
in void update(ll now){
	size[now]=size[ls]+size[rs]+1;
}
in void split_val(ll now,ll k,ll &x,ll &y){
	if(!now){
		x=y=0;
		return;
	} 
	else if(val[now]<=k){
		x=now;
		split_val(rs,k,rs,y);
	}
	else{
		y=now;
		split_val(ls,k,x,ls);
	}
	update(now);
}
in void split_pm(ll now,ll k,ll &x,ll &y){
	if(!now){
		x=y=0;
		return;
	} 
	else{
		if(k<=size[ls]){
			y=now;
			split_pm(ls,k,x,ls);
		}
		else{
			x=now;
			split_pm(rs,k-size[ls]-1,rs,y);
		}
		update(now);
	}
}
in ll merge(ll x,ll y){
	if(!x||!y) return x+y;
	if(rd[x]<rd[y]){
		c[x][1]=merge(c[x][1],y);
		update(x);
		return x;
	}
	else{
		c[y][0]=merge(x,c[y][0]);
		update(y);
		return y;
	}
}
in void deleted(ll v){
	split_val(root,v,x,z);
	split_val(x,v-1,x,y);
	y=merge(c[y][0],c[y][1]);
	root=merge(merge(x,y),z);
}
in ll build(string s,ll v,ll t){
	size[++tot]=1;
	rd[tot]=rand();
	val[tot]=M*v-t; //多关键字，满足val，再满足t，维护val值。
	ren[tot]=s;
	return tot;
}
in void insert(string s,ll v,ll t){
	if(id[s]) deleted(val[id[s]]);
	id[s]=build(s,v,t);
	split_val(root,val[tot],x,y);
	root=merge(merge(x,tot),y);
}
in ll query_rank(ll k){
	split_val(root,val[k],x,y);
	ans=size[y]+1;
	root=merge(x,y);
	cout<<ans<<'\n';
}
in void print_(ll now){
	if(!now) return;
	print_(rs);
	//cout<<"QWQWQ"<<endl;
	cout<<ren[now]<<" ";
	print_(ls);
}
in ll index(ll k){
	ll now=size[root];
	split_pm(root,now-k+1,x,z);
	split_pm(x,max(now-k-9,0ll),x,y); //用long long 要加0ll
	print_(y);
	cout<<'\n';
	root=merge(merge(x,y),z);
}
int main(){
	ll k;
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>ch>>name;
		if(ch=='+'){
			cin>>k;
			insert(name,k,i);
		}
		else{
			if(name[0]>'9') query_rank(id[name]);
			else index(atoi(name.c_str()));
			//这里用了一个atoi，功能是将字符串转成整型
		}
	}
	return 0;
}
```

然而这份代码却有一个问题，就是两个查询的函数没有返回值，我却用的 ll 类型，不过这题也就神奇的过了。但去做[双倍经验](https://www.luogu.com.cn/problem/P2584)的时候就因为这个问题把我整得快心肌梗塞了。整整交了三页多，三回啊三回！

---

## 作者：BFSDFS123 (赞：0)

这道是一道[双倍经验](https://www.luogu.com.cn/problem/P2584)

-----

本题是一道平衡树的模板题，对于想练习平衡树基本知识的同学们很有帮助。

~~但是我就是用 pb_ds 水了过去。~~

-----

我们对于每个名字，使用 map 存储名字的编号，并对每个编号，用一个数组存储这个编号的值。

对于每次更新，直接把这个位置的值删掉，再加入这个节点。（注意更新个平衡树数）

对于每次询问，利用 ``find_by_order(x)`` 和 ``T.order_of_key(x)`` 来处理问题。

就这样，一道平衡树的紫题就被我们在80行之内给水掉了！

-----

代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp> 
using namespace std;
int cnt=0;
map<string,int> mp;
int val[250010];
struct Node{
	int v,id;
	bool operator<(const Node &rhs) const{
		if(v!=rhs.v)
		{
			return v>rhs.v;
		}
		return id<rhs.id;
	}
};
__gnu_pbds::tree<Node,__gnu_pbds::null_type,less<Node>,
				  __gnu_pbds::rb_tree_tag,
				  __gnu_pbds::tree_order_statistics_node_update>
T;
string Name[250010]; 
int main()
{
	int Case;
	scanf("%d",&Case);
	int tot=0;
	while(Case--)
	{
		char opt;
		string nm;
		cin>>opt>>nm;
		if(opt=='+')
		{
			if(mp[nm])
			{
				int pos=mp[nm];
				Node tmp;
				T.erase((Node){val[pos],pos});
				tot--;
			}
			mp[nm]=++cnt;
			scanf("%d",&val[cnt]);
			Node tmp;
			tmp.v=val[cnt];
			tmp.id=cnt;
			T.insert(tmp);
			Name[cnt]=nm;
			tot++;
		}else{
			if(isdigit(nm[0]))
			{
				int x=0;
				for(int i=0;i<nm.size();i++)
				{
					x=x*10+nm[i]-'0';
				}
				int N=min(tot,x+9);
				for(int i=x-1;i<=N-1;i++)
				{
					printf("%s ",Name[T.find_by_order(i)->id].c_str());
				}
				putchar('\n');
			}else{
				int id=mp[nm];
				printf("%d\n",T.order_of_key((Node){val[id],id})+1);
			}
		}
	}
	return 0;
}
```

因为 pb_ds 常数巨大，所以不开 O2 只有 90 分，最后一个点 TLE1.07 秒。

当然，你加上快读和快输也是可以的——只是我懒得改

----

另附：根据 CCF 的最新规则，pb_ds 已经能在正规比赛中使用啦！好时代，来临力！！！

[pb_ds 简介](https://oi-wiki.org/lang/pb-ds/)

---

## 作者：Stream月 (赞：0)

### [P4291 [HAOI2008]排名系统](https://www.luogu.com.cn/problem/P4291)



到目前，题解区还没有 fhq-Treap 的题解 qwq，那我发一篇 fhq -Treap 的题解供 fhq-Treap 玩家 debug 使用。

#### 题意简述：

维护一个数据结构，支持插入删除元素，查询元素排名，查询一个区段内的元素。（元素数值相等时，按时间戳排序）

#### Solution：

如果将括号内的话去掉的话，那这就是最裸的平衡树模板题了。那么如何维护时间时间戳呢？考虑将成绩与时间戳封装成一个结构体 rec，将 rec 作为权值用平衡树维护。

维护结构体与维护数值的不同点是，在 split 操作时要涉及对权值的比较，所以需要重载关系比较运算符，其余操作不变。

还有一点差异，在删除操作时稍有不同。

```cpp
void del(rec v) {	// 维护结构体
	pair<int, int> p = split(root, v);
	rec v2(v.sco, v.id - 1);	// 确保 只分离出 权值为 v 的一个节点  
	pair<int, int> p2 = split(p.first, v2);
	p2.second = merge(z[p2.second].l, z[p2.second].r);
	root = merge(merge(p2.first, p2.second), p.second);
}
```

上面 $v2$ 就相当于下面的 $v - 1$，确保只分离出记录为 v.sco 时间戳为 v.id 这一个节点 。

```cpp
void del(int v) {	// 维护数值
	pair<int, int> p = split(root, v); 
	pair<int, int> p2 = split(p.first, v - 1);
	p2.second = merge(z[p2.second].l, z[p2.second].r);
	root = merge(merge(p2.first, p2.second), p.second);
}
```



不开 O2 $\texttt{2.41s}$，吸氧之后 $\texttt{995ms}$。主要是因为我 split 习惯使用 pair，然后还有 map 维护字符串的映射，所以不吸氧有点慢。

#### Code:

```cpp
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <map>
#include <string>
using namespace std;
typedef long long ll;
inline ll read() {
	ll ans = 0;
	char last = ' ', ch = getchar();
	while (ch < '0' || ch > '9') last = ch, ch = getchar();
	while (ch >= '0' && ch <= '9') ans = ans * 10 + ch -'0', ch = getchar();
	if (last == '-') return -ans;
	return ans;
}

int read(char *s) {		// 字符串转数字
	int ans = 0;
	while (*s != '\0') {
		ans = ans * 10 + (*s) - '0';
 		s++;
	}
	return ans;
}

const int INF = 0x3f3f3f3f;
const int N = 2.5e5 + 5;


int root,  n;
map<string, int> m;
int tot, cnt, times;
struct rec {	// 平衡树中维护的权值 v
	int sco, id, ind;	//sco 成绩 id 时间戳 ind 在数组 a 中的下标
	rec() {}
	rec(int sco, int id): sco(sco), id(id){} 
};

struct node {
	int l, r, size, key;
	rec v;
} z[N];

struct entity {
	rec v;
	char name[15];
}a[N];

/*
	重载运算符
	以 成绩 为第一关键字 降序， 时间戳 为第二关键字 升序
*/
bool operator<(const rec &a, const rec &b) {
	return (a.sco > b.sco) || (a.sco == b.sco && a.id < b.id);
}
bool operator==(const rec &a, const rec &b) {
	return a.sco == b.sco && a.id == b.id;
}
bool operator<=(const rec &a, const rec &b) {
	return a < b || a == b;
}
void update(int x) {
	z[x].size = z[z[x].l].size + z[z[x].r].size + 1;
}

int merge(int x, int y) {
	if (!x || !y) return x | y;
	if (z[x].key > z[y].key) {
		z[x].r = merge(z[x].r, y);
		update(x);
		return x;
	} else {
		z[y].l = merge(x, z[y].l);
		update(y);
		return y;
	}
}

pair<int, int> split(int x, rec v) {
	if (x == 0) return make_pair(0, 0);
	if (z[x].v <= v) {
		pair<int, int> p = split(z[x].r, v);
		z[x].r = p.first;
		update(x);
		return make_pair(x, p.second);
	} else {
		pair<int, int> p = split(z[x].l, v);
		z[x].l = p.second;
		update(x);
		return make_pair(p.first, x);
	}
}

int newnode(rec v) {
	z[++cnt].key = rand();
	z[cnt].l = z[cnt].r = 0;
	z[cnt].size = 1;
	z[cnt].v = v;
	return cnt;
}

void insert(rec v) {
	pair<int, int> p = split(root, v);
	root = merge(merge(p.first, newnode(v)), p.second);
}

void del(rec v) {
	pair<int, int> p = split(root, v);
	rec v2(v.sco, v.id - 1);	// 确保 只分离出 权值为 v 的一个节点  
	pair<int, int> p2 = split(p.first, v2);
	p2.second = merge(z[p2.second].l, z[p2.second].r);
	root = merge(merge(p2.first, p2.second), p.second);
}

rec kth(int x, int k) {
	if (z[z[x].l].size >= k) {
		return kth(z[x].l, k);
	} else if (z[z[x].l].size + 1 == k) return z[x].v;
	else return kth(z[x].r, k - z[z[x].l].size - 1);
}

int rnk(rec v) {
	v.id--;
	pair<int, int> p = split(root, v);
	int ans = z[p.first].size + 1;
	root = merge(p.first, p.second);
	return ans;
}

void print(int x) {	// 中序遍历输出
	if (z[x].l) print(z[x].l);
	printf("%s ", a[z[x].v.ind].name);
	if (z[x].r) print(z[x].r);
}
void getRank(int x) {	// 分离出 排名在 [x, x + 9] 的 子树
	rec l = kth(root, x), r = kth(root, min(x + 9, tot));
	l.id--;
	pair<int, int> p = split(root, l);
	pair<int, int> p2 = split(p.second, r);
	print(p2.first);
	printf("\n");
	root = merge(p.first, merge(p2.first, p2.second));
}

char op[105];
string str;
int ind, x, tree;
int main() {
	//freopen(".in", "r", stdin);
	//freopen(".out", "w", stdout);
	n = read();
	for (int i = 1; i <= n; ++i) {
		scanf("%s", op);
		if (op[0] == '+') {
			x = read();
			++times;	// 更新时间戳
			str = op + 1;
			ind = m[str];
			if (ind) {
				del(a[ind].v);	// 删掉原有记录
			} else {
				m[str] = ++tot;	// 该用户第一次上传记录时 将其放入数组a中
				ind = tot;	
				for (int i = 0; i < (int)str.length(); ++i) {
					a[ind].name[i] = str[i];
				}
				a[ind].v.ind = ind;
			}
			a[ind].v.sco = x;
			a[ind].v.id = times;
			insert(a[ind].v);	// 插入记录
		} else {
			if (op[1] >='0' && op[1] <= '9') {	// 对应询问 ?Index
				x = read(op + 1);
				getRank(x);
			} else {	//询问 ?Name
				str = op + 1;
				ind = m[str];
				printf("%d\n", rnk(a[ind].v));
			}
		}
	}
	return 0;
}
```





---

## 作者：Huami360 (赞：0)

一眼看去平衡树裸题，我用$Splay$实现的。

本题的难点在于如何维护名字和编号的映射关系，现有的题解都是用$map+$字符串哈希的方法来维护的。

但还有更快的方法：$Trie$

码量真的不大，跑的飞快（总共479ms，未吸氧）

另外本题还有个坑，debug了好久，就是会出现分数非常大的童鞋，达到了十位数，如果你的虚点的值不够大的话就会像我一样TLE，所以INF还是都设为2147483647吧

一些细节看代码吧。

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <map>
using namespace std;
const int MAXN = 250010;
inline int read(){
    int s = 0;
    char ch = getchar();
    while(ch < '0' || ch > '9')ch = getchar(); 
    while(ch >= '0' && ch <= '9'){ s = s * 10 + ch - '0'; ch = getchar(); }
    return s;
}
struct info{
    int val, id;
    int operator > (const info A) const{
        return val == A.val ? id < A.id : val > A.val;
    }
};
struct splay{
    info val;
    int size, ch[2], fa;
}t[MAXN];
int root, num, T;
struct Trie{    //字典树维护名字和编号映射关系
	int val;    //编号
	Trie *ch[26];
	Trie(){ for(int i = 0; i < 26; ++i) ch[i] = NULL; val = 0; }
}rt;
int Insert(char *s, int pos){ //字典树插入，成功返回0，如果已经存在了就返回已有的编号
	int len = strlen(s);
	Trie *u = &rt;
	for(int i = 0; i < len; ++i){
	   if(u->ch[s[i] - 'A'] == NULL) u->ch[s[i] - 'A'] = new Trie();
	   u = u->ch[s[i] - 'A'];
	}
	if(u->val) return u->val;
	u->val = pos;
	return 0;
}
inline void pushup(int x){
    t[x].size = t[t[x].ch[0]].size + t[t[x].ch[1]].size + 1;
}
inline void rotate(int x){
    int y = t[x].fa, z = t[y].fa, k = t[y].ch[1] == x;
    t[y].ch[k] = t[x].ch[k ^ 1]; t[t[x].ch[k ^ 1]].fa = y;
    t[y].fa = x; t[x].ch[k ^ 1] = y;
    t[x].fa = z; t[z].ch[t[z].ch[1] == y] = x;
    pushup(y); pushup(x);
}
inline void Splay(int x, int goal){
    int y, z;
    while(t[x].fa != goal){
        y = t[x].fa; z = t[y].fa;
        if(z != goal) rotate((t[y].ch[1] == x) ^ (t[z].ch[1] == y) ? x : y);
        rotate(x);
    }
    if(!goal) root = x;
}
inline int insert(info x, int num){  //Splay插入
    if(!root){ root = num; t[root].val = x; t[root].size = 1; return root; }
    int u = root, fa = 0;
    while(u){ fa = u; u = t[u].ch[x > t[u].val]; }
    int id = num; t[id].val = x; t[id].size = 1; t[id].fa = fa; if(fa) t[fa].ch[x > t[fa].val] = id;
    Splay(id, 0);
    return id;
}
int limit, tmp, Time;
void find(int x){
    int u = root;
    while(233){
        if(t[t[u].ch[0]].size == x - 1) break;
        if(t[t[u].ch[0]].size >= x) u = t[u].ch[0];
        else x -= t[t[u].ch[0]].size + 1, u = t[u].ch[1];
    }
    Splay(u, 0);
}
char ch, name[MAXN][12];
int len[MAXN];
void dfs(int x){
    if(!limit) return;   //题中的排名是从大到小的，所以先遍历右儿子
    if(t[x].ch[1]) dfs(t[x].ch[1]);
    if(!limit) return;
    for(int i = 0; i < len[x]; ++i)
       putchar(name[x][i]);
    putchar(' ');
    --limit;
    if(t[x].ch[0]) dfs(t[x].ch[0]);
}
int next(int x, int mode){
    Splay(x, 0);
    int u = t[root].ch[mode]; 
    while(t[u].ch[!mode]) u = t[u].ch[!mode];
    return u;
}
char s[12];
int pq;
int main(){
	//freopen("1.txt","r",stdin);
	//freopen("2.txt","w",stdout);
    T = read(); insert((info){ -2147483646, 9999999 }, ++num); insert((info){ 2147483646, -1 }, ++num);
    while(T--){
        ch = getchar();
        while(ch != '+' && ch != '?') ch = getchar();
        if(ch == '+'){ 
          scanf("%s", s);
          if(pq = Insert(s, num + 1)){ //已经存在了
          	int l = next(pq, 0), r = next(pq, 1);  //删了再插进去
            Splay(l, 0);
            Splay(r, l);
            t[t[root].ch[1]].ch[0] = 0;
            Splay(t[root].ch[1], 0);
            insert((info){ read(), ++Time }, pq);
          }
          else{
            insert((info){read(), ++Time}, ++num); 
            memcpy(name[num], s, sizeof s);
            len[num] = strlen(name[num]);
          }
        }
        if(ch == '?'){
            ch = getchar();
            if(ch >= '0' && ch <= '9'){
                tmp = 0;
                while(ch >= '0' && ch <= '9'){ tmp = tmp * 10 + ch - '0'; ch = getchar(); }
                find(num - tmp);  //因为题中的排名是从大到小的，而平衡树排名是从小到大的，所以要反过来
				for(int i = 0; i < len[root]; ++i)
       			   putchar(name[root][i]);
    			putchar(' '); limit = 9;
                if(t[root].ch[0]) dfs(t[root].ch[0]);
                printf("\n");
            }
            else{
                int p = 0;
                while(ch >= 'A' && ch <= 'Z'){ s[p++] = ch; ch = getchar(); }
                for(int i = p; i < 12; ++i) s[i] = 0;
                Splay(Insert(s, 233), 0);
                printf("%d\n", t[t[root].ch[1]].size);
            }
        }
        if(T % 200 == 0) Splay(rand() % num + 1, 0);  //保持Splay随机性
    }
    return 0;
}
```

---


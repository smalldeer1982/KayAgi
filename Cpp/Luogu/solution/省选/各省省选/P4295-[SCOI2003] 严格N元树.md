# [SCOI2003] 严格N元树

## 题目描述

如果一棵树的所有非叶节点都恰好有 $n$ 个儿子，那么我们称它为严格 $n$ 元树。如果该树中最底层的节点深度为 $d$（根的深度为 $0$），那么我们称它为一棵深度为 $d$ 的严格 $n$ 元树。例如，深度为２的严格２元树有三个，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/um9mtoxb.png)
 
给出 $n,d$，编程数出深度为 $d$ 的 $n$ 元树数目。

## 样例 #1

### 输入

```
2 2```

### 输出

```
3```

## 样例 #2

### 输入

```
2 3```

### 输出

```
21```

## 样例 #3

### 输入

```
3 5```

### 输出

```
58871587162270592645034001
```

# 题解

## 作者：GhostCai (赞：6)

f[i]表示深度不超过i的严格n元树的个数。  
转移时考虑加一个根，由于是n元树，根下需要n个子树  
f[i]=(f[i-1]^n)+1 
答案即为对f[d]-f[d-1] 正体现了差分与前缀和的神奇作用


边界f[0]=1，且当d=0时特判答案为1



需要高精度

```cpp
#include <iostream>
#include <string>
#include <cstring>
#include <cstdio>
using namespace std;

const int maxn = 10000;

struct bign{
    int d[maxn], len;

	void clean() { while(len > 1 && !d[len-1]) len--; }

    bign() 			{ memset(d, 0, sizeof(d)); len = 1; }
    bign(int num) 	{ *this = num; } 
	bign(char* num) { *this = num; }
    bign operator = (const char* num){
        memset(d, 0, sizeof(d)); len = strlen(num);
        for(int i = 0; i < len; i++) d[i] = num[len-1-i] - '0';
        clean();
		return *this;
    }
    bign operator = (int num){
        char s[2000]; sprintf(s, "%d", num);
        *this = s;
		return *this;
    }

    bign operator + (const bign& b){
        bign c = *this; int i;
        for (i = 0; i < b.len; i++){
        	c.d[i] += b.d[i];
        	if (c.d[i] > 9) c.d[i]%=10, c.d[i+1]++;
		}
		while (c.d[i] > 9) c.d[i++]%=10, c.d[i]++;
		c.len = max(len, b.len);
		if (c.d[i] && c.len <= i) c.len = i+1;
        return c;
    }
    bign operator - (const bign& b){
        bign c = *this; int i;
        for (i = 0; i < b.len; i++){
        	c.d[i] -= b.d[i];
        	if (c.d[i] < 0) c.d[i]+=10, c.d[i+1]--;
		}
		while (c.d[i] < 0) c.d[i++]+=10, c.d[i]--;
		c.clean();
		return c;
    }
    bign operator * (const bign& b)const{
        int i, j; bign c; c.len = len + b.len; 
        for(j = 0; j < b.len; j++) for(i = 0; i < len; i++) 
			c.d[i+j] += d[i] * b.d[j];
        for(i = 0; i < c.len-1; i++)
            c.d[i+1] += c.d[i]/10, c.d[i] %= 10;
        c.clean();
		return c;
    }
    bign operator / (const bign& b){
    	int i, j;
		bign c = *this, a = 0;
    	for (i = len - 1; i >= 0; i--)
    	{
    		a = a*10 + d[i];
    		for (j = 0; j < 10; j++) if (a < b*(j+1)) break;
    		c.d[i] = j;
    		a = a - b*j;
    	}
    	c.clean();
    	return c;
    }
    bign operator % (const bign& b){
    	int i, j;
		bign a = 0;
    	for (i = len - 1; i >= 0; i--)
    	{
    		a = a*10 + d[i];
    		for (j = 0; j < 10; j++) if (a < b*(j+1)) break;
    		a = a - b*j;
    	}
    	return a;
    }
	bign operator += (const bign& b){
        *this = *this + b;
        return *this;
    }

    bool operator <(const bign& b) const{
        if(len != b.len) return len < b.len;
        for(int i = len-1; i >= 0; i--)
            if(d[i] != b.d[i]) return d[i] < b.d[i];
        return false;
    }
    bool operator >(const bign& b) const{return b < *this;}
    bool operator<=(const bign& b) const{return !(b < *this);}
    bool operator>=(const bign& b) const{return !(*this < b);}
    bool operator!=(const bign& b) const{return b < *this || *this < b;}
    bool operator==(const bign& b) const{return !(b < *this) && !(b > *this);}

    string str() const{
        char s[maxn]={};
        for(int i = 0; i < len; i++) s[len-1-i] = d[i]+'0';
        return s;
    }
};

istream& operator >> (istream& in, bign& x)
{
    string s;
    in >> s;
    x = s.c_str();
    return in;
}

ostream& operator << (ostream& out, const bign& x)
{
    out << x.str();
    return out;
}


bign f[17];
int n,d;

int main(){
    cin>>n>>d;
    if(n==1&&d==1) return cout<<0,0;
    if(d==0) return cout<<1,0;
    f[1]=1;
    for(int i=1;i<=d;i++) {
    	bign tmp=1;
    	for(int j=1;j<=n;j++) tmp=tmp*f[i-1];
    	f[i]=f[i]+tmp+1;
    }
    bign ans=f[d]-f[d-1];
    cout<<ans;
}
```

---

## 作者：wangyizhi (赞：5)

**[题目传送门](https://www.luogu.com.cn/problem/P4295)**

## 题目分析

设深度恰好为 $k$ 的严格 $n$ 元树的种类数为 $f_k$。
记 $s_k=\sum_{i=1}^{k}f_i$。

考虑这个问题：现在有一个节点，如何通过在下面接深度为 $k$ 的严格 $n$ 元树使它成为深度为 $k+1$ 的严格 $n$ 元树呢？

不考虑深度是否符合要求，则它的每个子树都有 $s_k$ 种接法。因为总共有 $n$ 棵子树，故总的方案数为 $s_k^n$。

在把深度考虑进去。我们要求深度恰好为 $k$ 的，那么就是深度小于等于 $k$ 的减去深度小于 $k$ 的。深度小于 $k$ 的方案数同上可以得出为 $s_{k-1}^n$。那么我们就可以得出状态转移方程了：

$\large{f_i=s_{k-1}^n-s_{k-2}^n}$

同时统计前缀和：$s_i=s_{i-1}+f_i$。

别忘了初始值：$f_0=1$,$f_1=1$。

然后就做完啦！！！！！！！！！！！！！！！！！！！！

但是！！

>答案保证不超过 
$200$ 
位十进制数。

所以还要手写高精！！！

## AC Code

```cpp
#include<iostream>
#include<vector>

namespace wyzlll // 手写高精 支持赋值加减乘快速幂输出
{
	
class lll
{
private:
	std::vector<int> a;
	void init(long long x=0)
	{
		a.clear();
		while(x)
			a.push_back(x%10),x/=10;
	}
public:
	lll(long long x=0)
	{init(x);}
	lll operator=(long long x)
	{
		init(x);
		return *this;
	}
	inline int len(){return a.size();}
	void del0()
	{
		while(a.size()&&a.back()==0)
			a.pop_back();
	}
	friend lll operator+(lll,lll);
	friend lll operator-(lll,lll);
	friend lll operator*(lll,lll);
	friend std::ostream& operator<<(std::ostream&,lll);
};
lll operator+(lll a,lll b)
{
	lll res;
	int la=a.len(),lb=b.len();
	if(la>lb) std::swap(a,b),std::swap(la,lb);
	res.a.push_back(0);
	for(int i=0;i<la;i++)
	{
		res.a[i]+=a.a[i]+b.a[i];
		res.a.push_back(res.a[i]/10);
		res.a[i]%=10;
	}
	for(int i=la;i<lb;i++)
	{
		res.a[i]+=b.a[i];
		res.a.push_back(0);
	}
	res.del0();
	return res;
}
lll operator-(lll a,lll b)
{
	lll res;
	int la=a.len(),lb=b.len();
	for(int i=0;i<lb;i++)
	{
		if(a.a[i]<b.a[i]) a.a[i]+=10,a.a[i+1]--;
		res.a.push_back(a.a[i]-b.a[i]);
	}
	for(int i=lb;i<la;i++)
		res.a.push_back(a.a[i]);
	res.del0();
	return res;
}
lll operator*(lll a,lll b)
{
	lll res;
	int la=a.a.size(),lb=b.a.size();
	for(int i=0;i<la+lb;i++) res.a.push_back(0);
	for(int i=0;i<la;i++)
		for(int j=0;j<lb;j++)
		{
			res.a[i+j]+=a.a[i]*b.a[j];
			res.a[i+j+1]+=res.a[i+j]/10;
			res.a[i+j]%=10;
		}
	res.del0();
	return res;
}
lll qpow(lll a,int b)
{
	if(!b) return 1;
	if(b==1) return a;
	lll res=qpow(a,b>>1);
	if(b&1) return res*res*a;
	return res*res;
}
std::ostream& operator<<(std::ostream &os,lll x)
{
	if(!x.len()) os<<0;
	while(x.a.size()) os<<x.a.back(),x.a.pop_back();
	return os;
}
	
}// namespace wyzlll

/*------正片开始------*/

using namespace std;
using namespace wyzlll;

lll dp[101],s[101];
void test();
int main()
{
	int n,d;
	cin>>n>>d;
	dp[0]=1,s[0]=1;
	dp[1]=1,s[1]=2;
	for(int i=2;i<=d;i++)
	{
		dp[i]=qpow(s[i-1],n)-qpow(s[i-2],n);
		s[i]=s[i-1]+dp[i];
	}
	cout<<dp[d]<<endl;
	return 0;
}
```

**The end~**

---

## 作者：封禁用户 (赞：5)

~~其实这题主要就是高精了……因为高精写挂了WA了满满一页……写高精的时候千万别忘了重新设置长度！！！！！！！~~

首先显而易见的状态就是$dp[i]$表示深度为i的n元树有多少个，可以想到需要在这n个孩子中随便钦定一个让他伸到最底部（深度为i-1），别的孩子深度只要不超过i就行了。那么就得设$g[i]$为深度不超过i的n元树个数。那么转移方程就是：

$dp[i]=(dp[i-1]*g[i-2]^{n-1})^n$

$g[i]=\sum_{j=0}^{i}dp[j]$

然后我就发现了一个问题，这么dp会有重复的方案，比如我现在钦定了儿子$k$为深度为$i-1$的，那么儿子$k-1$按照我们的转移方程就是深度不超过$i-1$就行了，那么也就是说$k-1$的深度可以为$i-1$，于是当你钦定$k-1$的深度必须是$i-1$的时候，肯定就会有重复的方案被计数进去了。

那么该怎么办呢？

重新明确一下我们现在的问题是什么，就是dp的时候一些儿子可能同时深度到达$i-1$，每次钦定**一个**儿子的深度的时候就会导致方案重复。既然钦定一个不行，那么我们不妨就直接枚举有多少个儿子的深度已经到达了$i-1$，再让其他的儿子的深度不超过$i-2$，这样直接上组合数就不会重复了。那么转移方程就是：

$dp[i]=\sum_{j=1}^nC_n^j*dp[i-1]^j*g[i-2]^{n-j}$

上代码（那些大量的调试语句都是高精闹得……）：

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<cstring>
#define int long long
using namespace std;
typedef struct _int{int len;
    _int(){
        len=1;
    }
    int data[1000];//9位一个 
    void init(){
        len=1;
        for(register int i=0;i<1000;i++)data[i]=0;
    }
    void print(){
        //printf("%lld",data[len-1]);
        for(register int i=len-1;i>=0;i--){
            printf("%.1lld",data[i]);
        }
    }
}INT;
void add(_int &a,_int &b,_int &c){
        //c.init();
        unsigned long long cf=0;
        int newl=max(a.len,b.len)+50;
        //a.print();printf("+");b.print();printf("=");
        for(register int i=0;i<newl;i++){
            unsigned long long res=a.data[i]+b.data[i]+cf;
            c.data[i]=res%10;cf=res/10;
        }
        while(newl>1&&c.data[newl-1]==0)newl--;c.len=newl;
        //c.print();cout<<endl;
}
void mul(_int &a,_int &b,_int &c){
	int newl=a.len+b.len+10;
    for(register int i=1;i<=a.len+10;i++){
        unsigned long long cf=0;
        unsigned long long tmp=a.data[i-1];
        for(register int j=1;j<=b.len+10;j++){
            unsigned long long res=(tmp*b.data[j-1])+cf+c.data[i+j-2];
            c.data[i+j-2]=res%10;
            cf=res/10;
        }
    }
    while(newl>1&&c.data[newl-1]==0)newl--;
    c.len=newl;
}
INT C[33][33];
INT dp[17];
INT mi[17][33];
INT g[17];
INT gmi[17][33];
signed main(){
    int n,d;cin>>n>>d;
    C[0][0].data[0]=1;
    for(register int i=1;i<=n;i++){
        C[i][0].data[0]=1;
        for(register int j=1;j<=i;j++){
            //printf("add(C[%d][%d],c[%d],[%d])--",i-1,j,i-1,j-1);C[i-1][j].print();printf("+");C[i-1][j-1].print();
            //cout<<endl;
            add(C[i-1][j],C[i-1][j-1],C[i][j]);
        }
    }
    dp[0].data[0]=1;
    g[0].data[0]=1;
    dp[1].data[0]=1;
    g[1].data[0]=2;
    gmi[1][0].data[0]=1;
    for(register int i=0;i<=n;i++){
        mi[0][i].data[0]=gmi[0][i].data[0]=mi[1][i].data[0]=1;
        if(i>0)mul(gmi[1][i-1],g[1],gmi[1][i]);
    }
    for(register int i=2;i<=d;i++){
        INT tmp;tmp.init();
        for(register int j=1;j<=n;j++){
            INT cjr=C[n][j];
            INT ywy;ywy.init();mul(cjr,mi[i-1][j],ywy);
            cjr.init();mul(ywy,gmi[i-2][n-j],cjr);
            ywy=tmp;tmp.init();add(cjr,ywy,tmp);
        }
        dp[i]=tmp;
        add(g[i-1],dp[i],g[i]);
        gmi[i][0].data[0]=1;
        mi[i][0].data[0]=1;
        for(register int j=1;j<=n;j++){
            mul(gmi[i][j-1],g[i],gmi[i][j]);
            mul(mi[i][j-1],dp[i],mi[i][j]);
        }
    }
    dp[d].print();
    return(0);
} 
```

---

## 作者：mrclr (赞：4)

这题自己搞了个dp，然后卡空间一上午终于过了……

令$dp[i][j]$表示深度为$i$，这一层有$n * j$个节点的$n$元树的个数。然后我们枚举上一层的节点个数进行转移：$dp[i][j] = \sum _ {k = 1} ^ {n ^ {i - 2}}dp[i - 1][k] * C_{nk} ^ {j}$。

然后因为~~出题人要恶心人~~没有取模，所以要写高精。

写完后自信满满一交MLE了，发现只有128MB……于是开始卡空间……

首先把dp变成滚动数组，但还是超时。这时候想到了压位高精，于是把每8位压成1位，然后高精数组长度改成$\frac{200}{8} + 1 = 26$，这样就过了……多开一点就会MLE。

（好像大佬们的做法都是容斥啥的）
```c++
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<vector>
#include<stack>
#include<queue>
#include<assert.h>
using namespace std;
#define enter puts("") 
#define space putchar(' ')
#define Mem(a, x) memset(a, x, sizeof(a))
#define In inline
typedef long long ll;
typedef double db;
const int INF = 0x3f3f3f3f;
const db eps = 1e-8;
const int maxn = 35;
const int N = 1024;
In ll read()
{
  ll ans = 0;
  char ch = getchar(), last = ' ';
  while(!isdigit(ch)) last = ch, ch = getchar();
  while(isdigit(ch)) ans = (ans << 1) + (ans << 3) + ch - '0', ch = getchar();
  if(last == '-') ans = -ans;
  return ans;
}
In void write(ll x)
{
  if(x < 0) x = -x, putchar('-');
  if(x >= 10) write(x / 10);
  putchar(x % 10 + '0');
}
In void MYFILE()
{
#ifndef mrclr
  freopen("ha.in", "r", stdin);
  freopen("ha.out", "w", stdout);
#endif
}

int n, d;
const int maxN = 26;
const int M = 100000000;
const int P = 8;
struct Big
{
  int a[maxN], len;
  In void N() {a[0] = len = 1;}
  friend In Big operator + (const Big& A, const Big& B)
  {
    Big ret; 
    int Len = min(maxN - 1, max(A.len, B.len));
    if(Len == maxN - 1) {ret.a[0] = 0, ret.len = 1; return ret;}
    Mem(ret.a, 0);
    for(int i = 0; i < Len; ++i)
      {
	ret.a[i] += A.a[i] + B.a[i];
	ret.a[i + 1] = ret.a[i] / M, ret.a[i] %= M;
      }
    if(Len < maxN - 1 && ret.a[Len]) ++Len;
    while(Len > 1 && !ret.a[Len - 1]) --Len;
    ret.len = Len;
    return ret;
  }
  friend In Big operator * (const Big& A, const Big& B)
  {
    Big ret;
    ret.len = min(maxN - 1, A.len + B.len - 1);
    if(ret.len == maxN - 1) {ret.a[0] = 0, ret.len = 1; return ret;}
    Mem(ret.a, 0);
    for(int i = 0; i < A.len; ++i)
      for(int j = 0; j < B.len; ++j)
	{
	  ll tp = 1LL * A.a[i] * B.a[j];
	  if(i + j < maxN) ret.a[i + j] += tp % M;
	  if(i + j + 1 < maxN) ret.a[i + j + 1] += tp / M;
	}
    if(ret.len < maxN - 1 && ret.a[ret.len]) ++ret.len;
    while(ret.len > 1 && !ret.a[ret.len - 1]) --ret.len;
    return ret;
  }
  In void out()
  {
    write(a[len - 1]);
    for(int i = len - 2; i >= 0; --i) printf("%0*d", P, a[i]);
  }
}C[N + 2][N + 2], dp[2][N + 2];

ll Pow[N + 2];
In void init()
{
  for(int i = 0; i <= N; ++i)
    for(int j = 0; j <= N; ++j) C[i][j].a[0] = 0, C[i][j].len = 1;
  C[0][0].N();
  for(int i = 1; i <= N; ++i)
    {
      C[i][0].N();
      for(int j = 1; j <= i; ++j) C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
    }
  Pow[0] = 1;
  for(int i = 1; i <= N; ++i) Pow[i] = Pow[i - 1] * n;
}

int main()
{
  MYFILE();
  n = read(), d = read();
  if(!d) {puts("1"); return 0;}
  init();
  dp[0][1].N(), dp[1][1].N();
  int o = 0;
  for(int i = 2; i <= d; ++i, o ^= 1)
    {
      for(int j = 1; j <= Pow[i - 1]; ++j)
	{
	  Mem(dp[o][j].a, 0); dp[o][j].len = 1;
	  for(int k = 1; k <= Pow[i - 2]; ++k)
	    dp[o][j] = dp[o][j] + (dp[o ^ 1][k] * C[n * k][j]);
	}
    }
  Big ans; Mem(ans.a, 0), ans.len = 1;
  for(int i = 1; i <= Pow[d - 1]; ++i) ans = ans + dp[o ^ 1][i];
  ans.out(), enter;
  return 0;
}
```

---

## 作者：bradfordzhang (赞：2)

# c++高精度+普通解法
这里推荐一下[我的博客](/blog/144417/solution-p4295) ~~在博客里观看更佳哦~~
> 这题其实考的是大整数（高精度）
> 高精度解决后就好办了

> 运用一些位运算就能避免超时

> 最后倒序输出就好了

> 下面是代码

```cpp
  #include<iostream>
  #include<cstdio>
  #include<cstring>
  using namespace std;
  const int maxn = 210;
  int n, d;
  //大整数结构体和加减乘
  struct bigint { int l, a[210]; } a[35], b, c, p, t;
  bigint sum(bigint a, bigint b) {
      memset(c.a, 0, sizeof(c.a)), c.l = max(a.l, b.l);
      for (int i = 1; i <= c.l; i++) {
          c.a[i] += a.a[i] + b.a[i];
          c.a[i + 1] += c.a[i] / 10000, c.a[i] %= 10000;
      }
      while (c.l && !c.a[c.l]) c.l--; return c;
  }
  bigint sub(bigint a, bigint b) {
      memset(c.a, 0, sizeof(c.a)), c.l = a.l;
      for (int i = 1; i <= a.l; i++) {
          c.a[i] = a.a[i] - b.a[i];
          if (c.a[i] < 0) c.a[i] += 10000, a.a[i + 1]--;
      }
      while (c.l && !c.a[c.l]) c.l--; return c;
  }
  bigint mul(bigint a, bigint b) {
      memset(c.a, 0, sizeof(c.a)), c.l = a.l + b.l;
      for (int i = 1; i <= a.l; i++) {
          for (int j = 1; j <= b.l; j++) {
              c.a[i + j - 1] += a.a[i] * b.a[j];
              c.a[i + j] += c.a[i + j - 1] / 10000, c.a[i + j - 1] %= 10000;
          }
      }
      while (c.l && !c.a[c.l]) c.l--; return c;
  }
  int main() {
      scanf("%d %d", &n, &d);
      a[0].a[1] = a[0].l = t.a[1] = t.l = 1;
      //接下来就和普通的求解一样了，只不过是用到了大整数
      for (int i = 1, k; i <= d; a[i++] = sum(b, t)) {
          memset(b.a, 0, sizeof(b.a)), p = a[i - 1], b.a[1] = b.l = 1;
          for (k = n; k; k >>= 1, p = mul(p, p)) if (k & 1) b = mul(b, p);
      }
      a[d] = sub(a[d], a[d - 1]), printf("%d", a[d].a[a[d].l]);
      for (int i = a[d].l - 1; i; i--) printf("%04d", a[d].a[i]);//输出时注意%04d
      return 0;
  }
```

---

## 作者：him的自我修养 (赞：1)

~~给小学生在赛场上做紫题不要命啦！~~

## solution

直接求 $n$ 元 $d$ 层树不太好求，所以考虑把 $dp_i$ 表示为不超过深度不超过 $i$ 的 $n$ 元 $d$ 层树。

转移方程就是 $dp_i=(dp_{i-1})^n+1$。

至于为什么，因为加一层就相当于新建一个根节点，这个根节点可以是叶子结点，情况 $+1$，否则就有 $n$ 个孩子节点，每个节点有 $dp_{i-1}$ 种选择，根据乘法原理，就有 $(dp_{i-1})^n$ 种选择，加起来就是上面的转移方程。

答案就是 $dp_d-dp_{d-1}$。

## code
```
#include <bits/stdc++.h>
using namespace std;
int n,d;
struct node{
	int len,a[1000];
}dp[40],b,c,p,val;
node sum(node a,node b){
	memset(c.a,0,sizeof(c.a));
	c.len=max(a.len,b.len)+1;
	for(int i=1;i<=c.len;i++){
		c.a[i]+=a.a[i]+b.a[i];
		c.a[i+1]+=c.a[i]/10000;
		c.a[i]%=10000;
	}
	while(c.len && !c.a[c.len]) c.len--;
	return c;
}
node sub(node a,node b){
	memset(c.a,0,sizeof(c.a));
	c.len=max(a.len,b.len);
	for(int i=1;i<=a.len;i++){
		c.a[i]=a.a[i]-b.a[i];
		if(c.a[i]<0) c.a[i]+=10000,a.a[i+1]--;
	}
	while(c.len && !c.a[c.len]) c.len--;
	return c;
}
node mul(node a,node b){
	memset(c.a,0,sizeof(c.a));
	c.len=(a.len+b.len)*2;
	for(int i=1;i<=a.len;i++){
		for(int j=1;j<=b.len;j++){
			c.a[i+j-1]+=a.a[i]*b.a[j];
			c.a[i+j]+=c.a[i+j-1]/10000,c.a[i+j-1]%=10000;
		}
	}	
	while(c.len && !c.a[c.len]) c.len--;
	return c;
}
int main(){
	cin >>n>>d;
	dp[0].a[1]=dp[0].len=val.a[1]=val.len=1;
	for(int i=1;i<=d;dp[i++]=sum(b,val)){
		memset(b.a,0,sizeof(b.a));
		p=dp[i-1];
		b.a[1]=b.len=1;
		int k=n;
		while(k){
			if(k&1) b=mul(b,p);
			p=mul(p,p);
			k>>=1;
		}
	}
	dp[d]=sub(dp[d],dp[d-1]);
	printf("%d",dp[d].a[dp[d].len]);
	for(int i=dp[d].len-1;i;i--){
		printf("%04d",dp[d].a[i]);
	}
	return ovo;
}
```

---

## 作者：山田リョウ (赞：1)

容易发现，直接求高度为 $d$ 的严格 $n$ 元树数量不是很容易，所以我们考虑求高度不超过 $d$ 的严格 $n$ 元树的个数，再减去高度不超过 $d-1$ 的严格 $n$ 元树的个数，就是答案。

$f_d$ 表示高度不超过 $d$ 的严格 $n$ 元树的个数，可以推出转移方程：
$$f_d=1+f_{d-1}^n$$

因为是严格 $n$ 元树，要么根节点是叶子节点，要么根节点有 $n$ 个儿子。

根节点是叶子结点的高度不超过 $d$ 的严格 $n$ 元树显而易见只有 $1$ 个。

根节点有 $n$ 个儿子的高度不超过 $d$ 的严格 $n$ 元树的每个儿子对应的子树的高度显而易见不能超过 $d-1$，根据乘法原理，有 $f_{d-1}^n$ 个这样的严格 $n$ 元树。

但是这题要高精度，所以我用的 python，代码：
```python
s=input()
n=int(s.split(' ')[0])
d=int(s.split(' ')[1])
x=1
for i in range(d-1):
    x=x**n+1
print(x**n+1-x)
```

---

## 作者：Huah (赞：1)

假设f[i]为深度小于等于i的严格n元树的个数，那么将它转移成f[i+1]

相当于给新建一个根结点，每个根结点的儿子有f[i]种选择，就是f[i]^n

再包括新加一个深度为1的根结点的情况，所以递推式就是f[i+1]=f[i]^n+1
```
import java.math.BigInteger;
import java.util.Scanner;


public class Main {
	public static BigInteger qpow(BigInteger a,int n)
	{
		BigInteger ans=new BigInteger("1");
		while(n!=0)
		{
			if((n&1)==1) ans=ans.multiply(a);
			a=a.multiply(a);
			n>>=1;
		}
		return ans;
	}
	public static void main(String []args)
	{
		BigInteger []f=new BigInteger[105];
		f[0]=new BigInteger("1");
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt(),d=sc.nextInt();
		for(int i=1;i<=d;i++)
			f[i]=qpow(f[i-1],n).add(new BigInteger("1"));
		if(d!=0)
			System.out.println(f[d].subtract(f[d-1]));
		else System.out.println(f[d]);
	}
}

```


---


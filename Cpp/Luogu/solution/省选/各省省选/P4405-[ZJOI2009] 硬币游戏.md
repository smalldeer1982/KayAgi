# [ZJOI2009] 硬币游戏

## 题目描述

Orez很喜欢玩游戏，他最近发明了一款硬币游戏。他在桌子的边缘上划分出2*n个位置并按顺时针把它们标号为1，2，……，2n，然后把n个硬币放在标号为奇数的位置上。

接下来每次按如下操作：在任意两个硬币之间放上一个硬币，然后将原来的硬币拿走；所放硬币的正反面由它两边的两个硬币决定，若两个硬币均为正面朝上或反面朝上，则所放硬币为正面朝上，否则为反面朝上。 那么操作T次之后桌子边缘上硬币的情况会是怎样的呢？

## 说明/提示

30%的数据 n≤1000 T≤1000

100%的数据 n≤100000 T≤2^60

样例解释
```
20202010101010101020
01010201010101010201
10102020101010102020
01020102010101020102
20202020201010202020
01010101020102010101
```

## 样例 #1

### 输入

```
10 5
2 2 2 1 1 1 1 1 1 2```

### 输出

```
0 1 0 1 0 1 0 1 0 2 0 1 0 2 0 1 0 1 0 1```

# 题解

## 作者：unknowncloud (赞：10)

把正面当作0，反面当作1

注意到每一次变换之后所得到的结果取决于变换之前该位置左右两个硬币的异或值

下面让我们找一下规律，设第2i-1个位置刚输入时候时的状态是Ai，空位置就用0代替
有一点点省略，相信大家还是看得懂的


![](https://cdn.luogu.com.cn/upload/pic/17648.png)

这样下来，我们大概能够发现，经过2^k次变换之后，A[i]会变成A[i+2^(k-1)]^[i-2^(k-1)]【暂时不考虑k=1的情况】


于是对T按位处理，如果T从小到大第k位为1，那么就把原数组的每一个A[i]进行一次替换

最后如果T为奇数，就再进行一次变换

代码如下，注意记得要提前处理出每一个2^k
还有就是为了取模时候方便，我的数组是从0开始使用的
```
#include <stdio.h>
#include <algorithm>
using namespace std;
typedef long long llw;
int c[4][200010];
llw n2[66];
llw T;
int n;

int main()
{
	int k=0;
	n2[0]=1;
	for(int i=1;i<=60;i++) n2[i]=n2[i-1]<<1;//预处理2^i
	scanf("%d %lld",&n,&T);
	for(int i=0;i<n;i++)
	{
		scanf("%d",&c[0][i<<1]);
		c[0][i<<1]--;//注意原来输入时候输入的是1和2，而不是用于异或运算的0和1
	}
	for(llw i=1;n2[i]<=T;i++)
	{
		if(n2[i]&T)//判断第i位是否为1
		{
			k^=1;
			for(int j=0;j<n;j++)
			{
				c[k][j<<1]=c[k^1][(((j-n2[i-1])%n+n)%n)<<1]^c[k^1][((j+n2[i-1])%n)<<1];//注意要*2
			}
		}
	}
	if(T&1)//判断是否为奇数
	{
		k^=1;
		for(int i=0;i<n;i++) c[k][(i<<1)+1]=c[k^1][i<<1]^c[k^1][((i<<1)+2)%(n<<1)];
		for(int i=1;i<(n<<1);i+=2) printf("0 %d ",c[k][i]+1);
	}
	else
	{
		for(int i=0;i<(n<<1);i+=2) printf("%d 0 ",c[k][i]+1);
	}
	return 0;
}
```

---

## 作者：Point_LUO (赞：3)

### 写在前面的话

我找到的规律和前面的几位大佬不太一样，如果你也觉得特判 $2^{0}$ 的方法有点奇怪，公式推导过于高深，或者觉得或者不想用滚动数组和两倍大小数组，可以来看看这篇题解。

### 题意简述

有 $2n$ 个位置，然后把 $n$ 个硬币放在标号为奇数的位置上。

每次按如下操作：在任意两个硬币之间放上一个硬币，然后将原来的硬币拿走；所放硬币的正反面由它两边的两个硬币决定，若两个硬币均为正面朝上或反面朝上，则所放硬币为正面朝上，否则为反面朝上。

求 $T$ 次操作后桌子上硬币情况。

### 思路分析

先分析这 $n$ 个硬币操作后所在位置：最初硬币放在奇数位上，奇数次操作后会放在偶数位上，偶数次操作后会放在奇数位上。（整个思路中唯一和奇偶有关系的就是输出时候放的位置）

在知道了位置之后，题目就可以简化成：给定长度为 $n$ 的 01 序列 $a$（将 12 序列换成 01 序列，0 表示正面朝上，1 表示反面朝上），每次操作新的 $a[i]$ 等于之前的 $a[i]$ 异或 $a[i+1]$（序列应为一个环所以具体实现可以标号从 0 开始，然后取模），最后再按操作次数奇偶选择输出顺序。

然后你看了一眼数据范围：$T\le2^{60}$，~~又是一道不可做题~~ 复杂度大概率和 $\log T$ 相关。

那么接下来我们开始推式子。（此处以 $n=10$ 和 $T=8$ 为例）

下面的这个表格记录的是每次操作时每个位置对应的最初 $T=0$ 时的来源。

||0|1|2|3|4|5|6|7|8|9|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|T=1|0 1|1 2|2 3|3 4|4 5|5 6|6 7|7 8|8 9|9 0|
|T=2|9 1|0 2|1 3|2 4|3 5|4 6|5 7|6 8|7 9|8 0|
|T=3|9 0 1 2|0 1 2 3|1 2 3 4|2 3 4 5|3 4 5 6|4 5 6 7|5 6 7 8|6 7 8 9|7 8 9 0|8 9 0 1|
|T=4|8 2|9 3|0 4|1 5|2 6|3 7|4 8|5 9|6 0|7 1|
|T=5|8 9 2 3|9 0 3 4|0 1 4 5|1 2 5 6|2 3 6 7|3 4 7 8|4 5 8 9|5 6 9 0|6 7 0 1|7 8 1 2|
|T=6|7 9 1 3|8 0 2 4|9 1 3 5|0 2 4 6|1 3 5 7|2 4 6 8|3 5 7 9|4 6 8 0|5 7 9 1|6 8 0 2|
|T=7|7 8 9 0 1 2 3 4|8 9 0 1 2 3 4 5|9 0 1 2 3 4 5 6|0 1 2 3 4 5 6 7|1 2 3 4 5 6 7 8|2 3 4 5 6 7 8 9|3 4 5 6 7 8 9 0|4 5 6 7 8 9 0 1|5 6 7 8 9 0 1 2|6 7 8 9 0 1 2 3|
|T=8|6 4|7 5|8 6|9 7|0 8|1 9|2 0|3 1|4 2|5 3|

整张表看起来还是一副不可做的样子……

但是再次观察表格，发现 $T=2^{k}$ 时来源都只有两个。

那么我们把表格只留下 $T=2^{k}$ 时的数据。

||0|1|2|3|4|5|6|7|8|9|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|T=1|0 1|1 2|2 3|3 4|4 5|5 6|6 7|7 8|8 9|9 0|
|T=2|9 1|0 2|1 3|2 4|3 5|4 6|5 7|6 8|7 9|8 0|
|T=4|8 2|9 3|0 4|1 5|2 6|3 7|4 8|5 9|6 0|7 1|
|T=8|6 4|7 5|8 6|9 7|0 8|1 9|2 0|3 1|4 2|5 3|

再次观察，发现在同一次操作中，每个值的两个来源之差 $p$ 是固定的，而且相邻的两个位置的来源之差为 1。我们把它记录下来。

||0|1|2|3|4|5|6|7|8|9|p|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|T=1|0 1|1 2|2 3|3 4|4 5|5 6|6 7|7 8|8 9|9 0|1|
|T=2|9 1|0 2|1 3|2 4|3 5|4 6|5 7|6 8|7 9|8 0|2|
|T=4|8 2|9 3|0 4|1 5|2 6|3 7|4 8|5 9|6 0|7 1|4|
|T=8|6 4|7 5|8 6|9 7|0 8|1 9|2 0|3 1|4 2|5 3|8|

那么这样我们就可以知道 $p=T$，接下来我们还需要知道每一次操作时的枚举起点 $s$。

||0|1|2|3|4|5|6|7|8|9|s|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|T=1|0 1|1 2|2 3|3 4|4 5|5 6|6 7|7 8|8 9|9 0|0|
|T=2|9 1|0 2|1 3|2 4|3 5|4 6|5 7|6 8|7 9|8 0|9|
|T=4|8 2|9 3|0 4|1 5|2 6|3 7|4 8|5 9|6 0|7 1|8|
|T=8|6 4|7 5|8 6|9 7|0 8|1 9|2 0|3 1|4 2|5 3|6|

如果还是觉得看起来没什么规律那么我们改换一下 $s$ 的表示方式。

||0|1|2|3|4|5|6|7|8|9|s|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|T=1|0 1|1 2|2 3|3 4|4 5|5 6|6 7|7 8|8 9|9 0|0|
|T=2|9 1|0 2|1 3|2 4|3 5|4 6|5 7|6 8|7 9|8 0|-1|
|T=4|8 2|9 3|0 4|1 5|2 6|3 7|4 8|5 9|6 0|7 1|-2|
|T=8|6 4|7 5|8 6|9 7|0 8|1 9|2 0|3 1|4 2|5 3|-4|

这样就清晰很多了，我们可以发现 $s=-T\div2$ 这一规律。

我们知道了起点 $s$ 和距离 $p$，就可以得到 $T=2^{k}$ 时所有的值了。

最后只需要解决如何将一个 $T$ 拆分为我们已知的 $T=2^{k}$ 的问题。

因为题意中的 $T$ 次变换可以等价于多次总变换数等于 $T$ 的变换，并且我们可以将 $T$ 转化为形如 $2^{k_{1}}+2^{k_{2}}+2^{k_{3}}+\dots$ 的形式，所以我们将 01 序列 $a$ 用位运算拆分后进行 $T_1=2^{k_{1}}$，$T_2=2^{k_{2}}$，$T_3=2^{k_{3}}$ 这样的变换就可以得到 $T$ 次变换后的结果。

最后和一开始所说的方法一样，按操作次数奇偶选择输出顺序就 OK 了。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100000;
int n;
bool a[N];
bool b[N];
long long T,tmp,p=1,s=0;
int main()
{
	cin>>n>>T;
	tmp=T;
	for(int i=0;i<n;i++)
	{
		int u;
		scanf("%d",&u);
		a[i]=u-1;
	}
	while(tmp)
	{
		if(tmp&1)
		{
			for(int i=0;i<n;i++) b[i]=a[((i-s)%n+n)%n]^a[((i+p-s+n)%n+n)%n];
			for(int i=0;i<n;i++) a[i]=b[i];
		}
		tmp>>=1;
		s=p;
		p<<=1;
	}
	if(T%2) for(int i=0;i<n;i++) printf("0 %d ",a[i]+1);
	else for(int i=0;i<n;i++) printf("%d 0 ",a[i]+1);
	return 0;
}
```

---

## 作者：Siyunshan (赞：3)

第一眼看过去：$DP$可解（别问我怎么看出来的…我也不知道当时什么脑子）,

于是列出方程

$A_[i]$->A[$i$+$2^{(k-1)}$]^[$i$-$2^{k-1}$]

然后就爆零了…发现惟一一篇题解和我的方程一样，于是就咕咕咕了…
再来看这道题时，盯着样例看，五分钟啥都没看出来，于是祭出小学四年级学的

### 瞪（数）眼（学）大（归）法（纳）

发现进行$2^k$次变换之后，第$i$个位置的硬币情况只与它左（右）的第$k+1$个硬币有关。

如果$k=0$,那么第$3$个硬币情况只与第$2$个和第$4$个硬币有关。因为$t$可以拆成若干个$2^k$的和，于是对每个$2^k$进行$O(n)$的变换，总复杂度$O(nlogt)$。~~然鹅方程并没有变~~

下面附代码
```c
#include <bits/stdc++.h>
#define in  freopen("coin.in","r",stdin);
#define out freopen("coin.out","w",stdout);
typedef long long ll;
using namespace std;
inline ll read()
{
    ll x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
const int N=200020;//这个可以调，但是不要开太小
ll n,t,a[N],b[N];
ll f(ll b,ll k)
{
    ll x=b-k;
    ll y=b+k;
    x=(x%(n<<1)+(n<<1)-1)%(n<<1)+1;
    y=(y-1)%(n<<1)+1;
    if(k==0)
        return a[x];
    if(a[x]==0)
        return 0;
    if(a[x]==a[y])
        return 1;
    else return 2;
}
void work(ll k,ll q)
{
    if(k==0)
        return;
    work(k>>1,q<<1);
    if(k%2==1)
    {
        memset(b,false,sizeof(b));
        for(ll j=1;j<=(n<<1);j++)
            b[j]=f(j,q);
        swap(a,b);
    }
}
int main()
{
    n=read();
    t=read();
    for(ll i=1;i<=n;i++)
        a[(i<<1)-1]=read();
    work(t,1);
    for(ll i=1;i<(n<<1);i++)
        cout<<a[i]<<" ";
    cout<<a[n<<1]<<endl;
    return 0;
}
```

---

## 作者：Mortidesperatslav (赞：2)

本题解仅仅是补充其余两篇题解缺少的思路。不附代码。

其他两篇题解我一点也看不懂，还是讲个清晰点的思路吧。

本文尽量保证刚学完 C++ 基本语法的萌新能看懂。

### 前置知识 1 异或（会的请跳过）

异或，就是**不进位加法**，在二进制下满足一个性质：若两个数的第 $k$ 位相同，则异或的第 $k$ 位为 $0$，否则为 $1$。根据这个性质，我们可以再推出几个重要的性质：

1. $x \oplus x = 0$（$\oplus$ 代表异或）。

2. $x \oplus 0 = x$。

3. 若 $a \oplus b = c$，则 $a \oplus c = b$。

4. $a \oplus b = b \oplus a $。

5. $a \oplus b \oplus c = a \oplus (b \oplus c)$。

### 前置知识 2 倍增（会的请跳过）

[可以看一下 OI-wiki 的介绍和例子](https://oi-wiki.org/basic/binary-lifting/)

放到这道题上，就是说 $T$ 太大了，我们不能一步一步操作，所以我们可以跳 $2$ 步、$4$ 步，一直到 $2^k$ 步，解决这个问题。

### 正文：解题过程

我们上面讲到要跳 $2$ 步、$4$ 步……但是我们怎么做到一次跳这么多步呢？

我们会发现 $1$ 和 $2$ 不好做，所以变成 $0$ 和 $1$，然后可以发现所有 $0$ 在下一轮会变成左右两边的异或，$1$ 和 $2$ 变为 $0$。

为了省事，我们先假设不是在一个环上做，而是在一条无限长的链上做。

假设我们现在有一个 $a_x$（以下 $a_i$ 表示第 $i$ 个位置未经过操作时的状态，$f_{k,i}$ 表示第 $i$ 个位置操作 $k$ 次之后的状态）。

那么 $f_{2,x}=f_{1,x-1}\oplus f_{1,x+1}=a_x \oplus a_{x+2} \oplus a_x \oplus a_{x-2}=a_x \oplus a_x \oplus a_{x+2} \oplus a_{x-2}=a_{x+2} \oplus a_{x-2}$。

$f_{4,x}=f_{3,x-1} \oplus f_{3,x+1}=  f_{2,x} \oplus f_{2,x-2} \oplus f_{2,x} \oplus f_{2,x+2}= a_{x-4} \oplus a_x \oplus a_{x+4} \oplus a_x=a_{x-4}\oplus a_{x+4}$。

以此类推，$f_{2^n,x}=a_{x-2^n} \oplus a_{x+2^n}$。

这就有规律了。

所以我们用倍增，每次推 $2^n$，这里的 $n \ge 1$。

最后考虑奇数和偶数，因为最多只剩下一次操作，暴力模拟就行。

因为这题空间比较小，建议采用滚动数组。滚动数组听起来高级，实际上非常好理解。

举个例子，假设 $T=14=2+4+8$。

你跳了 $2$ 步之后，因为还要跳 $4$ 步，所以要保存状态，但是你又跳完 $4$ 步后，之前你只跳了 $2$ 步的状态再也不会用到，所以可以覆盖掉。这样就大大节省了空间。

代码千篇一律，可以看看[这篇题解](https://www.luogu.com.cn/article/4oj0bepg)的，和我写的差不多（因为思路似乎也差不多）。

---

## 作者：linjunye (赞：0)

首先，我们把正面当作 $0$，把反面当作 $1$。

那么，注意到每次变换就相当于左右的异或和了（$0\oplus0=0$，$1\oplus1=0$，$0\oplus1=1$，$1\oplus0=1$）。

那么，我们做出下表（`#` 表示空位）。

|操作|$A_1$|$A_2$|$A_3$|$A_4$|$A_5$|$A_6$|……|$A_{2n-1}$|$A_{2n}$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$T=0$|$a_1$|`#`|$a_2$|`#`|$a_3$|`#`|……|$a_n$|`#`|
|$T=1$|`#`|$a_1\oplus a_2$|`#`|$a_2\oplus a_3$|`#`|$a_3\oplus a_4$|……|`#`|$a_n\oplus a_1$|
|$T=2$|$a_n\oplus a_2$|`#`|$a_1\oplus a_3$|`#`|$a_2\oplus a_4$|`#`|……|$a_{n-1}\oplus a_1$|`#`|
|$T=3$|`#`|$a_n\oplus a_1\oplus a_2\oplus a_3$|`#`|$a_1\oplus a_2\oplus a_3\oplus a_4$|`#`|$a_2\oplus a_3\oplus a_4\oplus a_5$|……|`#`|$a_{n-1}\oplus a_n\oplus a_1\oplus a_2$|
|$T=4$|$a_{n-1}\oplus a_3$|`#`|$a_n\oplus a_4$|`#`|$a_1\oplus a_5$|`#`|……|$a_{n-2}\oplus a_2$|`#`|
|$T=5$|`#`|$a_{n-1}\oplus a_n\oplus a_3\oplus a_4$|`#`|$a_n\oplus a_1\oplus a_4\oplus a_5$|`#`|$a_1\oplus a_2\oplus a_5\oplus a_6$|……|`#`|$a_{n-2}\oplus a_n\oplus a_1\oplus a_2$|
|$T=6$|$a_{n-2}\oplus a_n\oplus a_2\oplus a_4$|`#`|$a_{n-1}\oplus a_1\oplus a_3\oplus a_5$|`#`|$a_n\oplus a_2\oplus a_4\oplus a_6$|`#`|……|$a_{n-3}\oplus a_{n-1}\oplus a_1\oplus a_3$|`#`|
|$T=7$|`#`|$a_{n-2}\oplus a_{n-1}\oplus a_n\oplus a_1\oplus a_2\oplus a_3\oplus a_4\oplus a_5$|`#`|$a_{n-1}\oplus a_n\oplus a_1\oplus a_2\oplus a_3\oplus a_4\oplus a_5\oplus a_6$|`#`|$a_n\oplus a_1\oplus a_2\oplus a_3\oplus a_4\oplus a_5\oplus a_6\oplus a_7$|……|`#`|$a_{n-3}\oplus a_{n-2}\oplus a_{n-1}\oplus a_n\oplus a_1\oplus a_2\oplus a_3\oplus a_4$|
|$T=8$|$a_{n-3}\oplus a_5$|`#`|$a_{n-2}\oplus a_6$|`#`|$a_n\oplus a_7$|`#`|……|$a_{n-4}\oplus a_4$|`#`|

我们可以发现，当 $T=2^k$ 且 $k>0$ 时，$a_i=a_{i-2^{k-1}}\oplus a_{i+2^{k-1}}$。

注意这里的加法与减法后的结果要对 $n$ 取模（公式为了简洁就没有写）。

我们再想一想，假设我们现在有 $x$ 次操作后的数列，他是不是就相当于 $x_1$ 次操作后的数列再操作 $x_2$ 次后的数列呢（$x_1+x_2=x$）？

答案是显然的：是的 ~~（废话）~~。

仔细想想，我们是不是可以对每个 $T$ 进行二进制拆分？

比如 $T=6$ 时，是不是可以拆分成 $2^1+2^2$，然后用上述式子解。

当然，当 $T$ 为奇数时，多出了一个 $2^0$，但可以特别求解。

总体复杂度：$\Theta(n\log T)$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,T;
int a[200010],b[200010];//注意到更新时a数组会互相影响，所以开一个副本
int sub(int a,int b){//a-b
	int w=((a-b)%n+n)%n;
	if(w==0)return n;
	return w;
}
int add(int a,int b){//a+b
	int w=(a+b)%n;
	if(w==0)return n;
	return w;
}
signed main(){
	scanf("%lld%lld",&n,&T);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		a[i]--;//输入时不是01序列，所以减1 
	}
	for(int i=1;i<=n;i++)b[i]=a[i];//b是a的副本
	for(int i=1;i<=60;i++){
		if(T&(1ll<<i)){
			for(int j=1;j<=n;j++)a[j]=b[sub(j,1ll<<i-1)]^b[add(j,1ll<<i-1)];
			for(int j=1;j<=n;j++)b[j]=a[j];
		}
	}
	//由于我们前面减1，所以最后再加1 
	if(T&1){//2^0
		for(int i=1;i<=n;i++)printf("0 %d ",(a[i]^a[add(i,1)])+1);//参考表格中T=1时 
		return 0;
	}
	for(int i=1;i<=n;i++)printf("%d 0 ",a[i]+1);//参考表格中T=0时 
	return 0;
}

```

---


# [CQOI2005] 三角形面积并

## 题目描述

给出 $n$ 个三角形，求它们并的面积。

## 样例 #1

### 输入

```
2
0.0 0.0 2.0 0.0 1.0 1.0
1.0 0.0 3.0 0.0 2.0 1.0```

### 输出

```
1.75```

# 题解

## 作者：a2956331800 (赞：8)

这个题很显然的扫描线

先枚举每条边把每个交点求出来，然后按交点的x坐标当扫描线，排序，答案即为相邻两条扫描线各种与三角形相交长度和*扫描线之间的距离/2（扫描线之间的三角形部分都是梯形）

每条扫描线求出它经过了多少面积，求的时候依次枚举每个三角形，求和三边是否有交，如果交点超过一个（可以不判是不是同一个点，因为如果是扫描线和三角形的一个点相交，计入答案的长度是0），就把两个交点之间的线段存成pair（y小的当first），然后把所有的相交线段排序，扫描总面积

扫描的时候记录一个当前区间，初始化为[-inf,-inf]，每次加入一个新线段时，如果新线段和当前区间无交，就把当前区间计入答案（由于按起点从小到大排序，之后不会再有区间和当前区间有交了），然后把记录的区间更新为新的区间，否则更新右端点（取max）

统计答案的核心代码：
```cpp
double l=seg[1].x,r=seg[1].y,sum=0.0;
    for (int i=2;i<=cnt;++i)
    {
        if (seg[i].x-r>eps) sum+=r-l,l=seg[i].x,r=seg[i].y;
        else r=max(r,seg[i].y);
    }
    sum+=r-l;
    return sum;
```
然后如果按上面的思路做会WA第二个点以及第九个点可能出现各种错误
问题在于有一条边和y轴平行的边
比如这样的：
![](https://cdn.luogu.com.cn/upload/pic/29030.png)

在扫描到它左边的时候会记录左边那个边的距离，但这条扫描线和前一条扫描线统计答案时这个边并不产生贡献，所以要特判这个，就是每条扫描线作为左边和右边的那条扫描线统计答案时要分别计算相交面积，如果发现这种三角形就特判一下是不是在当前统计答案的区域以外。

下面的代码里Minus是当左边的扫描线时统计答案的函数，Plus是当右边的扫描线时统计答案的函数，两个函数的差别在第四行的判断条件（输入时把三角形的三个点按x从小到大排序了），自己想象一下就知道差别在哪了

（我自己的代码有精度问题（应该是没有判eps的原因），开long double又会T一个，O2都救不了，就先放一个指导我写出代码的代码）

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
#define N 105

const double eps=1e-12;
const double inf=1e9;
int dcmp(double x)
{
    if (x<=eps&&x>=-eps) return 0;
    return (x>0)?1:-1;
}
struct Vector
{
    double x,y;
    Vector(double X=0,double Y=0)
    {
        x=X,y=Y;
    }
    bool operator < (const Vector &a) const
    {
        return x<a.x||(x==a.x&&y<a.y);
    }
    void read(){scanf("%lf%lf",&x,&y);}
};
typedef Vector Point;
struct Line
{
    Point p,q;
    Line(Point P=Point(0,0),Point Q=Point(0,0))
    {
        p=P,q=Q;
    }
};
Vector operator + (Vector a,Vector b) {return Vector(a.x+b.x,a.y+b.y);}
Vector operator - (Vector a,Vector b) {return Vector(a.x-b.x,a.y-b.y);}
Vector operator * (Vector a,double b) {return Vector(a.x*b,a.y*b);}

int n,LSH;
double ans;
double lsh[N*N*10];
Point seg[N];
Line line[N][3];

double Cross(Vector a,Vector b)
{
    return a.x*b.y-a.y*b.x;
}
bool ins(Point A,Point B,Point C,Point D)
{
    Vector v,w,u;
    v=A-C,w=C-D,u=B-D;
    if (dcmp(Cross(v,w))==dcmp(Cross(u,w))) return 0;
    v=C-A,w=B-A,u=D-A;
    if (dcmp(Cross(v,w))==dcmp(Cross(u,w))) return 0;
    return 1;
}
Point GLI(Point P,Vector v,Point Q,Vector w)
{
    Vector u=P-Q;
    double t=Cross(w,u)/Cross(v,w);
    return P+v*t;
}
double Plus(double x)
{
    int cnt=0;
    for (int i=1;i<=n;++i)
    {
        if (dcmp(line[i][1].p.x-line[i][1].q.x)==0&&dcmp(x==line[i][1].p.x))
            continue;
        double Min=inf,Max=-inf;
        for (int j=1;j<=3;++j)
        {
            if (x<line[i][j].p.x||x>line[i][j].q.x) continue;
            if (dcmp(line[i][j].p.x-line[i][j].q.x)==0) continue;
            Point P=GLI(line[i][j].p,line[i][j].q-line[i][j].p,Point(x,-inf),Vector(0,inf));
            Min=min(Min,P.y),Max=max(Max,P.y);
        }
        if (Max-Min>eps) seg[++cnt]=Point(Min,Max);
    }
    sort(seg+1,seg+cnt+1);
    if (!cnt) return 0.0;
    double l=seg[1].x,r=seg[1].y,sum=0.0;
    for (int i=2;i<=cnt;++i)
    {
        if (seg[i].x-r>eps) sum+=r-l,l=seg[i].x,r=seg[i].y;
        else r=max(r,seg[i].y);
    }
    sum+=r-l;
    return sum;
}
double Minus(double x)
{
    int cnt=0;
    for (int i=1;i<=n;++i)
    {
        if (dcmp(line[i][2].p.x-line[i][2].q.x)==0&&dcmp(x==line[i][2].p.x))
            continue;
        double Min=inf,Max=-inf;
        for (int j=1;j<=3;++j)
        {
            if (x<line[i][j].p.x||x>line[i][j].q.x) continue;
            if (dcmp(line[i][j].p.x-line[i][j].q.x)==0) continue;
            Point P=GLI(line[i][j].p,line[i][j].q-line[i][j].p,Point(x,-inf),Vector(0,inf));
            Min=min(Min,P.y),Max=max(Max,P.y);
        }
        if (Max-Min>eps) seg[++cnt]=Point(Min,Max);
    }
    sort(seg+1,seg+cnt+1);
    if (!cnt) return 0.0;
    double l=seg[1].x,r=seg[1].y,sum=0.0;
    for (int i=2;i<=cnt;++i)
    {
        if (seg[i].x-r>eps) sum+=r-l,l=seg[i].x,r=seg[i].y;
        else r=max(r,seg[i].y);
    }
    sum+=r-l;
    return sum;
}
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;++i)
    {
        Point A,B,C;A.read(),B.read(),C.read();
        if (A.x>B.x) swap(A.x,B.x),swap(A.y,B.y);
        if (B.x>C.x) swap(B.x,C.x),swap(B.y,C.y);
        if (A.x>B.x) swap(A.x,B.x),swap(A.y,B.y);
        lsh[++LSH]=A.x,lsh[++LSH]=B.x,lsh[++LSH]=C.x;
        line[i][1]=Line(A,B),line[i][2]=Line(B,C);line[i][3]=Line(A,C);
    }
    for (int i=1;i<=n;++i)
        for (int j=1;j<=3;++j)
            for (int k=i+1;k<=n;++k)
                for (int l=1;l<=3;++l)
                {
                    Point A=line[i][j].p,B=line[i][j].q,C=line[k][l].p,D=line[k][l].q;
                    if (ins(A,B,C,D))
                    {
                        Point q=GLI(A,B-A,C,D-C);
                        lsh[++LSH]=q.x;
                    }
                }
    sort(lsh+1,lsh+LSH+1);LSH=unique(lsh+1,lsh+LSH+1)-lsh-1;
    double last=0.0,now;
    for (int i=1;i<=LSH;++i)
    {
        now=Plus(lsh[i]);
        if (i>1) ans+=(now+last)*(lsh[i]-lsh[i-1])/2.0;
        last=Minus(lsh[i]);
    }
    printf("%.2lf\n",ans-eps);
}
```

代码来源[传送门](https://blog.csdn.net/Clove_unique/article/details/70327717)

---

## 作者：Calculatelove (赞：6)

# Description

给出 $n$ 个三角形，求这 $n$ 个三角形并的面积。

数据范围：$1 \leq n \leq 100$，$-10^6 \leq x, y \leq 10^6$。  
时空限制：$1000 \ \mathrm{ms} / 128 \ \mathrm{MiB}$。

# Solution

扫描线的做法大家都会，这篇题解的做法是自适应辛普森积分。

记 $f(t)$ 表示：给出的 $n$ 个三角形与直线 $x = t$ 的交集长度。

那么答案即为：
$$
\int_a^b f(x) \ \text{dx}
$$
其中 $a, b$ 分别表示输入的 $x$ 中的最小值和最大值。

那么可以使用自适应辛普森积分做。现在的关键是要如何求出任意一个 $f(t)$。  
对于每一个三角形，考虑求出这个三角形与直线 $x = t$ 的相交部分是哪一段区间，把这些区间提出来，区间合并即可求出函数值。计算一个函数值的时间复杂度是 $\mathcal{O}(n \log n)$ 的，可以接受。

然后需要提高精度：

- 可以在递归过程中设置一个强制执行的最少迭代层数。
- 可以将每个三角形的最小 $x$ 值和最大 $x$ 值提出来后排序，对所有相邻点构成的区间求积分，将这些积分相加，就可以得到最后大区间 $[a, b]$ 的积分。

# Code

```c++
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>

using namespace std;

const double eps = 1e-9;
const double INF = 1e6;

int sgn(double n) {
	if (fabs(n) < eps) return 0;
	return n > 0 ? 1 : -1; 
}

int dcmp(double x, double y) {
	return sgn(x - y);
}

struct point {
	double x, y;

	point() { x = y = 0; }
	point(double A, double B) : x(A), y(B) {}
};

typedef point vec;

vec operator + (vec a, vec b) { return vec(a.x + b.x, a.y + b.y); }
vec operator - (vec a, vec b) { return vec(a.x - b.x, a.y - b.y); }
vec operator * (vec a, double b) { return vec(a.x * b, a.y * b); }
vec operator / (vec a, double b) { return vec(a.x / b, a.y / b); }

bool operator < (point a, point b) {
	if (dcmp(a.x, b.x)) return a.x < b.x;
	return a.y < b.y;
}

double cross(vec a, vec b) {
	return a.x * b.y - a.y * b.x;
}

point line_intersection(point A, point B, point C, point D) {
	point p = A, q = C;
	vec x = B - A, y = D - C;

	vec u = q - p;
	double t = cross(u, y) / cross(x, y);
	return p + x * t;
}

const int N = 110;

int n;
vector<point> a[N];

int t;
double pos[N * 2];

int m;
struct range {
	double l, r;

	range() {}
	range(double A, double B) : l(A), r(B) {}
} b[N];

bool ruler(range a, range b) {
	if (dcmp(a.l, b.l)) return a.l < b.l;
	return a.r < b.r;
}

double f(double x) {
	point Ga = point(x, 0), Gb = point(x, 1);

	m = 0;
	for (int i = 1; i <= n; i ++) {
		vector<point> u = a[i];

		if (dcmp(x, u[0].x) < 0) continue;
		if (dcmp(x, u[2].x) > 0) continue;

		if (!dcmp(u[0].x, u[1].x) && !dcmp(u[0].x, x)) {
			b[++ m] = range(u[0].y, u[1].y);
		} else if (!dcmp(u[1].x, u[2].x) && !dcmp(u[1].x, x)) {
			b[++ m] = range(u[1].y, u[2].y);
		} else {
			vector<double> seq;
			seq.clear();

			for (int j = 0; j < 3; j ++) {
				point A = u[j], B = u[(j + 1) % 3];
				if (B < A) swap(A, B);

				if (dcmp(x, A.x) < 0) continue;
				if (dcmp(x, B.x) > 0) continue;

				seq.push_back(line_intersection(A, B, Ga, Gb).y);
			}

			sort(seq.begin(), seq.end());
			b[++ m] = range(seq[0], seq[seq.size() - 1]);
		}
	}

	if (!m) return 0;

	sort(b + 1, b + 1 + m, ruler);

	double ans = 0;
	double st = b[1].l, ed = b[1].r;

	for (int i = 2; i <= m; i ++) {
		if (dcmp(b[i].l, ed) > 0)
			ans += ed - st,
			st = b[i].l, ed = b[i].r;
		else
			ed = max(ed, b[i].r);
	}

	ans += ed - st;

	return ans;
}

double simpson(double Lv, double Mv, double Rv, double len) {
	return (Lv + Rv + 4 * Mv) * len / 6; 
}

double asr(double l, double r, double Lv, double Mv, double Rv, int dep) {
	double mid = (l + r) / 2;
	double A = f((l + mid) / 2), B = f((mid + r) / 2);

	double s = simpson(Lv, Mv, Rv, r - l);
	double Ls = simpson(Lv, A, Mv, mid - l);
	double Rs = simpson(Mv, B, Rv, r - mid);

	if (!dcmp(s, Ls + Rs) && dep <= 0) return Ls + Rs;
	return asr(l, mid, Lv, A, Mv, dep - 1) + asr(mid, r, Mv, B, Rv, dep - 1);
}

int main() {
	scanf("%d", &n);

	for (int i = 1; i <= n; i ++) {
		for (int j = 0; j < 3; j ++) {
			double x, y;
			scanf("%lf%lf", &x, &y);

			a[i].push_back(point(x, y));
		}

		sort(a[i].begin(), a[i].end());

		pos[++ t] = a[i][0].x;
		pos[++ t] = a[i][2].x;
	}

	sort(pos + 1, pos + 1 + t);

	double ans = 0;

	for (int i = 2; i <= t; i ++) {
		if (!dcmp(pos[i - 1], pos[i])) continue;

		double l = pos[i - 1], r = pos[i];
		ans += asr(l, r, f(l), f((l + r) / 2), f(r), 5);
	}

	printf("%.2lf\n", ans);

	return 0;
}
```

---

## 作者：LJ07 (赞：1)

这边提供一个比较好写的做法，虽然还是扫描线。

不考虑特殊情况，扫描线做法是容易的：求出平面中所有线段的交点，然后纵坐标扫一遍扫描线。

每次求出直线 $y=y_{now}$ 与所有三角形的并的交集长度 $L$，这个直接模拟是 $O(n\log n)$。

则对于相邻两个扫描线 $y=y_{pre}$ 和 $y=y_{now}$，对答案的贡献就是 $\frac{(L_{now}+L_{pre})|y_{now}-y_{pre}|}{2}$。

但是有特殊情况，也就是当存在有一个三角形的一条边与 $y$ 轴平行时会多统计一块不在答案内的部分。

特判？不存在的。~~考虑人类智慧~~，将所有三角形绕原点旋转一定的角度，那就~~基本~~不存在这种情况了。

复杂度应该是 $O(n^3\log n)$。

[写丑了的 code](https://www.luogu.com.cn/paste/pfh556lv)

---

## 作者：lzh123bc (赞：1)

前置芝士：[辛普森积分](https://oi-wiki.org/math/numerical/integral/)

不难发现，此题可以用自适应辛普森积分。

那么怎么求 $f(a)$？

发现 $n\leq100$，每一次暴力得到直线 $x=a$ 与每个三角形相交线段，合并后线段长度就是 $f(a)$ 的值。

# 一些注意事项

- 要设置一个最小递归次数，防止精度过低

- 可以将要求的区间分段，提高精度

- 此题真的很卡精度，~~做好心理准备~~

[code](https://www.luogu.com.cn/paste/6s3mnzqu)

---

## 作者：lupengheyyds (赞：0)

## 题意

给 $n(1\le n\le 100)$ 个三角形，求其面积并。

## 解法一：自适应辛普森法

因为是求面积，很容易与积分建立关系，于是我们可以转换为积分问题解决。

令 $f(a)$ 表示直线 $x=a$ 与这些圆的交的长度，如图:

![pkuLQyt.png](https://s21.ax1x.com/2024/05/19/pkuLQyt.png)

则答案变为 $\int_{-\infin}^\infin f(x)dx$，因为三角形坐标范围在 $[-10^6,10^6]$，所以只需要计算 $\int_{-10^6}^{10^6} f(x)dx$。

用自适应辛普森法计算，当然如果直接计算容易被卡，比如你一开始选的五个点刚好是什么三角形都没有的，导致答案为 $0$，而其他位置却有很多三角形，这很明显是不对的。

具体地，我们可以记录下每个三角形的横坐标并将其排序，在相邻的横坐标之间做一次辛普森法，最后再加起来就好了。

当然这样还是会被卡，需要三个操作：

1. 对坐标进行随机扰动。

2. 强制辛普森法递归次数，一般为 $5$ 次。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NN=1e3+5;
const double eps=1e-8;
int n;
typedef pair<double,double> pa;
struct V{
    double x,y;
    void read(){cin>>x>>y;x+=(rand()&1?1:-1)*eps,y+=(rand()&1?1:-1)*eps;}
    V operator+(V b){return {x+b.x,y+b.y};}
    V operator-(V b){return {x-b.x,y-b.y};}
    double operator*(V b){return x*b.x+y*b.y;}
    double operator^(V b){return x*b.y-y*b.x;}
    V operator*(double c){return {x*c,y*c};}
};
struct Line{
    V p,v;
    Line(){return;}
    Line(V a,V b){p=a,v=b-a;}
};
double na=numeric_limits<double>::signaling_NaN();//以nan标记不合法 
V Sect(Line l1,Line l2){//l1为直线,l2为线段 
    V tmp=l1.v*(((l2.p-l1.p)^(l2.v))/(l1.v^l2.v))+l1.p;
    if((tmp-l2.p)*(tmp-(l2.p+l2.v))<=0)return tmp;
    else return {na,na};
}
struct Triangle{
    V p[3];
    void read(){p[0].read(),p[1].read(),p[2].read();}
}tri[NN];
vector<pa> q;
pa Solve(Triangle x,double y){
    int cnt=0;double tt[2]={na,na};
    for(int i=0;i<3;i++){
        V tmp=Sect(Line({y,0},{y,1}),Line(x.p[i],x.p[(i+1)%3]));
        if(isnan(tmp.y))continue;
        tt[cnt++]=tmp.y;
    }
    return {tt[0],tt[1]};
}
double f(double x){
    q.clear();
    for(int i=1;i<=n;i++){
        pa tmp=Solve(tri[i],x);
        if(isnan(tmp.first)||isnan(tmp.second))continue;
        q.push_back({min(tmp.first,tmp.second),max(tmp.first,tmp.second)});
    }
    sort(q.begin(),q.end());
    double st=-1e6,ed=-1e6,ans=0;
    for(pa mb:q){
        if(mb.first<=ed)ed=max(ed,mb.second);
        else ans+=ed-st,st=mb.first,ed=mb.second;
    }
    return ans+ed-st;
}
double simpson(double l,double r){
    double mid=(l+r)/2;
    return (r-l)*(f(r)+4*f(mid)+f(l))/6;
}
double Asr(double l,double r,double s,int step){
    double mid=(l+r)/2;
    double L=simpson(l,mid),R=simpson(mid,r);
    if(step<=0&&fabs(s-L-R)<eps)return s;
    return Asr(l,mid,L,step-1)+Asr(mid,r,R,step-1);
}
double pos[NN];
int tot;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        tri[i].read();
        for(int j=0;j<3;j++)pos[++tot]=tri[i].p[j].x;
    }
    double ans=0;
    sort(pos+1,pos+1+tot);
    tot=unique(pos+1,pos+1+tot)-pos-1;
    for(int i=2;i<=tot;i++){
        ans+=Asr(pos[i-1],pos[i],simpson(pos[i-1],pos[i]),4);
    }
    printf("%.2f",round(ans*1000)/1000);
    return 0;
}
```

## 解法二：扫描线

扫描线也是求面积并的基本手段，本质是将不规则图形转化为规则图形。

具体地，我们对三角形的每个顶点与交点画一条竖线，如图：

![pkuO2E8.png](https://s21.ax1x.com/2024/05/19/pkuO2E8.png)

我们发现两个相邻的竖线之间都是由一个或多个梯形组成的，于是我们可以对每两个相邻的竖线之间用梯形面积公示求解，求上下底的方式同上一种解法。

但这样还有些问题，当有三角形的边与 y 轴平行的时候，如图：

![pkuOzvR.png](https://s21.ax1x.com/2024/05/19/pkuOzvR.png)

对于其中一块，本应是这样的：

![pkuX9Dx.png](https://s21.ax1x.com/2024/05/19/pkuX9Dx.png)

现在变成了这样：

![pkuXk5D.png](https://s21.ax1x.com/2024/05/19/pkuXk5D.png)

这显然是错误的，解决方法就是将图形随机旋转一个角度。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NN=1e3+5;
const double eps=1e-8;
int n;
typedef pair<double,double> pa;
struct V{
    double x,y;
    void read(){cin>>x>>y;x+=(rand()&1?1:-1)*eps,y+=(rand()&1?1:-1)*eps;}
    V operator+(V b){return {x+b.x,y+b.y};}
    V operator-(V b){return {x-b.x,y-b.y};}
    double operator*(V b){return x*b.x+y*b.y;}
    double operator^(V b){return x*b.y-y*b.x;}
    V operator*(double c){return {x*c,y*c};}
};
struct Line{
    V p,v;
    Line(){return;}
    Line(V a,V b){p=a,v=b-a;}
};
double na=numeric_limits<double>::signaling_NaN();//以nan标记不合法 
V Sect(Line l1,Line l2){//l1为直线,l2为线段 
    V tmp=l1.v*(((l2.p-l1.p)^(l2.v))/(l1.v^l2.v))+l1.p;
    if((tmp-l2.p)*(tmp-(l2.p+l2.v))<=0)return tmp;
    else return {na,na};
}
struct Triangle{
    V p[3];
    void read(){p[0].read(),p[1].read(),p[2].read();}
}tri[NN];
vector<pa> q;
pa Solve(Triangle x,double y){
    int cnt=0;double tt[2]={na,na};
    for(int i=0;i<3;i++){
        V tmp=Sect(Line({y,0},{y,1}),Line(x.p[i],x.p[(i+1)%3]));
        if(isnan(tmp.y))continue;
        tt[cnt++]=tmp.y;
    }
    return {tt[0],tt[1]};
}
double f(double x){
    q.clear();
    for(int i=1;i<=n;i++){
        pa tmp=Solve(tri[i],x);
        if(isnan(tmp.first)||isnan(tmp.second))continue;
        q.push_back({min(tmp.first,tmp.second),max(tmp.first,tmp.second)});
    }
    sort(q.begin(),q.end());
    double st=-1e6,ed=-1e6,ans=0;
    for(pa mb:q){
        if(mb.first<=ed)ed=max(ed,mb.second);
        else ans+=ed-st,st=mb.first,ed=mb.second;
    }
    return ans+ed-st;
}
double simpson(double l,double r){
    double mid=(l+r)/2;
    return (r-l)*(f(r)+4*f(mid)+f(l))/6;
}
double Asr(double l,double r,double s,int step){
    double mid=(l+r)/2;
    double L=simpson(l,mid),R=simpson(mid,r);
    if(step<=0&&fabs(s-L-R)<eps)return s;
    return Asr(l,mid,L,step-1)+Asr(mid,r,R,step-1);
}
double pos[NN];
int tot;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        tri[i].read();
        for(int j=0;j<3;j++)pos[++tot]=tri[i].p[j].x;
    }
    double ans=0;
    sort(pos+1,pos+1+tot);
    tot=unique(pos+1,pos+1+tot)-pos-1;
    for(int i=2;i<=tot;i++){
        ans+=Asr(pos[i-1],pos[i],simpson(pos[i-1],pos[i]),4);
    }
    printf("%.2f",round(ans*1000)/1000);
    return 0;
}
```

## 关于输出

可以看到，我使用了 `printf("%.2f",round(ans*1000)/1000)` 这样的输出方式，从而一定程度上避免精度问题。

比如样例：

```
2
0.0 0.0 20.0 28.0 10.0 35.0
-50.0 0.0 -70.8 -33.5 -30.5 -10.5
```

此数据理论计算值为 $645.825$ ，保留 $2$ 位小数应为 $645.83$，但是由于 `double` 的精度问题，计算机中实际存储的值可能为 $645.824999999999999$，到这四舍五入时变为 $645.82$。

然而使用这种输出方式可以将其先变为精确的 $645.825$，从而正确的四舍五入。

---

## 作者：Eltaos_xingyu (赞：0)

### 题目描述

给出 $n$ 个三角形，求它们并的面积。

### 算法

这是一篇用自适应 Simpson 写的题解，主要是因为这个蒟蒻作者只会用扫描线写矩形面积并......

那么，自适应 Simpson 是什么？

**前置芝士**：Simpson 公式

![](https://cdn.luogu.com.cn/upload/image_hosting/j6x9k3qs.png)

（图片来源于[P4525](https://www.luogu.com.cn/problem/P4525)的第二篇题解）

不难发现这个公式的误差巨大：

![](https://cdn.luogu.com.cn/upload/image_hosting/o8sk17ek.png)

（图片来源于百度百科）

蓝色部分是公式求的，黄线是原函数......这误差的确肉眼可见的大。

于是自适应 Simpson 就出现了！！！

**自适应 Simpson** 是什么？

简单讲，就是二分区间，用 Simpson 公式计算二分的区间，如果左右区间结果的和加起来与原来的区间的结果在精度控制范围内，那就行，直接返回答案即可，如果超出了精度控制范围，那就继续二分直到结果在精度范围内。

```cpp
ld simpson(ld l,ld r){
	ld mid=(l+r)/2.0;
	return (4*f(mid)+f(r)+f(l))*(r-l)/6.0;
}

ld ASR(ld l,ld r,ld EPS,ld ans,int dep=4){
	ld mid=(l+r)/2.0;
	ld l_=simpson(l,mid),r_=simpson(mid,r);
	if(fabs(l_+r_-ans)<=EPS&&dep<=0)return ans;
	return ASR(l,mid,EPS,l_,dep-1)+ASR(mid,r,EPS,r_,dep-1);
}
```

也就差不多这样......

注意一点，`ASR` 函数中的 `dep` 参数是强制限定了最少递归次数，以防精度爆炸。

相信大家也关注到了代码中的 `f` 函数，那怎么写 `f` 函数呢？

类似于扫描线，我们固定一个平行于 x/y 轴的线，枚举各个三角形覆盖这条线的区间，最后区间并就行了。

那么这道题就做完了（上代码）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const double Pi=acos(-1);
int n;

struct po{
	double x,y;
}; 
struct vec{
	double A,B,C;//Ax+By+C=0;
};
vector<po> a[1001];
double y[1001];
vec get_vec_from_po(po p,po q){
	vec v;
	v.A=p.y-q.y;
	v.B=q.x-p.x;
	v.C=p.x*q.y-q.x*p.y;
	return v;
}
po get_po_from_vec(vec c,vec d){
	po pp;
	pp.x=((-d.B*c.C+c.B*d.C)/(-c.B*d.A+c.A*d.B));
	pp.y=((-d.A*c.C+c.A*d.C)/(c.B*d.A-c.A*d.B));
	return pp;
}
struct cmp_x{
	bool operator()(const po &c ,const po &d)const{
		return (c.x==d.x)? c.y<d.y:c.x<d.x;
	}
};
#define ld double
struct cmp_x_pair{
	bool operator()(const pair<ld,ld> &e ,const pair<ld,ld> &g)const{
		return e.first<g.first;
	}
};
struct cmp_y{
	bool operator()(const po &e ,const po &f)const{
		return (e.y==f.y)? e.x<f.x:e.y<f.y;
	}
};

const ld eps=1e-4;

vector<pair<ld,ld> > ss;
vector<po> temp;
ld f(ld yy){
	ss.clear();
	vec buff;
	buff.A=0;
	buff.B=1;
	buff.C=-yy;
	for(int k=1;k<=n;k++){
		temp.clear();
		temp=a[k];
		if(yy>temp[2].y||yy<temp[0].y)continue;
		vec b1=get_vec_from_po(temp[0],temp[2]);
		vec b2=get_vec_from_po(temp[1],temp[2]);
		vec b3=get_vec_from_po(temp[0],temp[1]);
		if(temp[1].y==temp[2].y&&temp[2].y==yy){
			po test1=temp[1];
			po test2=temp[2];
			ss.push_back(make_pair((test1.x>test2.x)?test2.x:test1.x,(test1.x<test2.x)?test2.x:test1.x));
		}
		else if(temp[0].y==temp[1].y&&temp[1].y==yy){
			po test1=temp[0];
			po test2=temp[1];
			ss.push_back(make_pair((test1.x>test2.x)?test2.x:test1.x,(test1.x<test2.x)?test2.x:test1.x));
		}
		else if(yy>=temp[1].y){
			po test1=get_po_from_vec(b1,buff);
			po test2=get_po_from_vec(b2,buff);
			ss.push_back(make_pair((test1.x>test2.x)?test2.x:test1.x,(test1.x<test2.x)?test2.x:test1.x));
		}
		else{
			po test1=get_po_from_vec(b1,buff);
			po test2=get_po_from_vec(b3,buff);
			ss.push_back(make_pair((test1.x>test2.x)?test2.x:test1.x,(test1.x<test2.x)?test2.x:test1.x));
		}
	}
	if(ss.empty())return 0;
	sort(ss.begin(),ss.end(),cmp_x_pair());
	double last=ss.begin()->first,an=0;
	for(vector<pair<ld,ld> >::iterator itt=ss.begin();itt!=ss.end();itt++){
		if(last<=itt->second){
			an+=itt->second-max(itt->first,last);
			last=itt->second;
		}
	}
	return an;
}

ld simpson(ld l,ld r){
	ld mid=(l+r)/2.0;
	return (4*f(mid)+f(r)+f(l))*(r-l)/6.0;
}

ld ASR(ld l,ld r,ld EPS,ld ans,int dep=4){
	ld mid=(l+r)/2.0;
	ld l_=simpson(l,mid),r_=simpson(mid,r);
	if(fabs(l_+r_-ans)<=EPS&&dep<=0)return ans;
	return ASR(l,mid,EPS,l_,dep-1)+ASR(mid,r,EPS,r_,dep-1);
}
int d;
int main(){
	d=0;
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	int cnt=0;
	for(int i=1;i<=n;i++){
		po buf;
		cin>>buf.y>>buf.x;
		a[i].push_back(buf);
		cin>>buf.y>>buf.x;
		a[i].push_back(buf);
		cin>>buf.y>>buf.x;
		a[i].push_back(buf);
		stable_sort(a[i].begin(),a[i].end(),cmp_y());
		y[++cnt]=a[i][0].y;
		y[++cnt]=a[i][2].y;
	}
	sort(y+1,y+cnt+1);
	ld anss=0;
	for(int i=1;i<cnt;i++){
		if(fabs(y[i]-y[i+1])<=eps)continue;
		anss+=ASR(y[i],y[i+1],eps,simpson(y[i],y[i+1]));
	}
	cout<<fixed<<setprecision(2)<<anss;
	return 0;
}
/*
3
1 1 1 5 5 1
2 0 4 0 2 2
3 2 5 2 3 4
*/
```

但，你以为这真就完了？

### 一些注意事项/优化

上面那份代码吸氧最多跑 90ms，想抢最优解怎么办？

- 判断一个三角形是否完全包含于另一个三角形（这个蒟蒻作者还没写出来）

- 尽量卡精度

- 一些玄学优化，比如 `inline` 和 `register`，要选合适的编译语言等

于是...最优解就诞生了！

![](https://cdn.luogu.com.cn/upload/image_hosting/abp29ewf.png)

（注：rk2 是我的同学，原来我就是 rk1，但是被他无情的刷了下去......）

代码就不贴了。qwq

### 后记

写这篇题解，还专门去抢了最优解，但是还没写完就被原 rk2 发现了，于是......就发生了抢最优解大战：

具体看[这里](https://www.luogu.com.cn/paste/lle4ti2z)

---


# [HNOI2009] 无归岛

## 题目描述

Neverland 是个神奇的地方，它由一些岛屿环形排列组成，每个岛上都生活着之中与众不同的物种。

但是这些物种都有一个共同的生活习性：对于同一个岛上的任意两个生物，他们有且仅有一个公共朋友，即对同一岛上的任意两个生物 a 和 b 有且仅有一个生物 c 既是 a 的朋友也是 b 的朋友，当然某些岛上也可能会只有一个生物孤单地生活着。

这一习性有一个明显的好处，当两个生物发生矛盾的时候，他们可以请那个唯一的公共朋友来裁决谁对谁错。 另外，岛与岛之间也有交流，具体来说，每个岛都会挑选出一个最聪明的生物做代表，然后这个生物与他相邻的两个岛的代表成为朋友。 

不幸运的是，A 世界准备入侵 Neverland，作为 Neverland 的守护者，Lostmonkey 想知道在一种比较坏的情况下 Neverland 的战斗力。因为和朋友并肩作战，能力会得到提升，所以 Lostmonkey 想知道在不选出一对朋友的情况下Neverland的最大战斗力。即选出一些生物，且没有一对生物是朋友，并且要求它们的战斗力之和最大。

## 说明/提示

**【样例说明】**

有四个岛，生物 $1$ 在 $1$ 号岛，生物 $2$ 在 $2$ 号岛，生物 $3$、$5$、$6$ 在 $3$ 号岛，生物 $4$ 在 $4$ 号岛。

输入数据保证 $4≤n≤100000$，$1 \le a,b \le n$，$1 \le m \le 200000$，$-1000 \le A_i \le 1000$。

## 样例 #1

### 输入

```
6 7
1 2
2 3
3 4
4 1
3 6
3 5
5 6
20 10 30 15 20 10```

### 输出

```
50```

# 题解

## 作者：lupengheyyds (赞：8)

## 思路
根据题意，最后将建成由一个大环连上多个三角环组成的图，像这样：
![](https://s11.ax1x.com/2024/01/07/pFSCdDe.png)

于是我们可以将大环与三角环分开处理。
#### 对于三角环
建立园方树。

对于原点，$dp[x][1/0]$ 表示选/不选 $x$ 的最大权值和。

对于方点，$dp[x][1/0]$ 表示选一个/不选 $x$ 的子节点时的最大权值和。

则对于圆点：

$dp[x][0]=\sum_{y\in son(x)}dp[y][1]$

$dp[x][1]=a[x]+\sum_{y\in son(x)}dp[y][0]$ 

对于方点：

$dp[x][0]=\sum_{y\in son(x)}dp[y][0]$

$dp[x][1]=\max_{y\in son(x)}\{dp[x][0]-dp[y][0]+dp[y][1]\}$ 

#### 对于大环
一个简单的环形 DP，每次规定第一个点选/不选，转化为线性 DP 就行了（具体看代码）。
## 实现
```
#include<bits/stdc++.h>
using namespace std;
const int szl=1e5+5,inf=0x3f3f3f3f;
int n,m;
vector<int> ed[szl],rbt[szl<<1];
int dfn[szl],low[szl],num,a[szl],f[szl][2];
int fa[szl],ext,dp[szl<<1][2];
void Solve(int u,int v){
	++ext;
	for(int i=v;i!=fa[u];i=fa[i]){
		rbt[ext].push_back(i);
		rbt[i].push_back(ext);
	}
	return;
}
void Tarjan(int x){
	dfn[x]=low[x]=++num;
	for(int y:ed[x]){
		if(y==fa[x])continue;
		if(!dfn[y]){
			fa[y]=x;
			Tarjan(y);
			low[x]=min(low[x],low[y]);
		}else low[x]=min(low[x],dfn[y]);
		if(low[y]<=dfn[x])continue;
		rbt[x].push_back(y);
		rbt[y].push_back(x);
	}
	for(int y:ed[x])if(fa[y]!=x&&dfn[y]>dfn[x])Solve(x,y);
}
//树形DP
void DP(int x,int f){
	if(x<=n){
		for(int y:rbt[x]){
			if(y==f)continue;
			DP(y,x);
			dp[x][0]+=max(dp[y][0],dp[y][1]);
			dp[x][1]+=dp[y][0];
		}
		dp[x][1]+=a[x];
	}else{
		for(int y:rbt[x]){
			if(y==f)continue;
			DP(y,x);
			dp[x][0]+=dp[y][0];	
		}
		for(int y:rbt[x]){
			if(y==f)continue;
			dp[x][1]=max(dp[x][1],dp[x][0]-dp[y][0]+dp[y][1]);
		}
	}
	return;
}
//环形DP
inline int Must(int x){
	f[0][0]=-inf,f[0][1]=dp[rbt[x][0]][1];
	for(int j=1;j<rbt[x].size();j++){
		f[j][0]=max(f[j-1][1],f[j-1][0])+dp[rbt[x][j]][0],
		f[j][1]=f[j-1][0]+dp[rbt[x][j]][1];
	}
	return f[rbt[x].size()-1][0];
}
inline int Mustnt(int x){
	memset(f,0,sizeof f);
	f[0][0]=dp[rbt[x][0]][0],f[0][1]=-inf;
	for(int j=1;j<rbt[x].size();j++){
		f[j][0]=max(f[j-1][1],f[j-1][0])+dp[rbt[x][j]][0],
		f[j][1]=f[j-1][0]+dp[rbt[x][j]][1];
	}
	return max(f[rbt[x].size()-1][0],f[rbt[x].size()-1][1]);
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	ext=n;
	for(int i=1;i<=m;i++){
		int u,v;cin>>u>>v;
		ed[u].push_back(v);
		ed[v].push_back(u);
	}
	for(int i=1;i<=n;i++)cin>>a[i];
	Tarjan(1);
	for(int i=n+1;i<=ext;i++){
		if(rbt[i].size()>3){
			for(int y:rbt[i])DP(y,i);
			cout<<max(Must(i),Mustnt(i));
			return 0;
		}
	}
	//没有特别的大环，可以直接树形DP
	DP(1,0);
	cout<<max(dp[1][0],dp[1][1]);		
	return 0;
} 
```

---

## 作者：haozexu (赞：4)

题意就是特殊的仙人掌（注：大环中每个点（岛）都是单点或若干三元环的组合）上最大独立集。

我们就不提拆成三元环和大环处理的方法了（您可以看 lupengheyyds 的题解），直接考虑普通仙人掌上最大权独立集问题。

考虑暴力计算最大权独立集的过程：

- 暴力考虑某点是否选择

- 判断解的合法性

- 更新答案

那么我们需要的关键信息，用于刻画问题的就是：

- 一个点是否被选择

- 相邻点的选择情况

考虑一个简化的问题，如果在树上求解呢？那么这两条信息就是：

- 一个点是否选择

- 子节点的选择情况（or 父节点的选择情况）

这就是 [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352) 

考虑仙人掌上的问题，发现第二条信息不好处理，因为节点间的关系复杂了

但是我们发现仙人掌拥有如下的性质：

- 它有环，但是没有一个边同时在 $2$ 个环里，如果从树的角度来看，仙人掌就是树加上边，最后满足同一个点 **至多** 有 $1$ 条返祖/后向边

也就是说仙人掌虽然连边复杂了，但是对于每一个点来说，它可能同时连接在很多链/很多简单环中，但是一个环中能影响它的选择情况的，只有 $2$ 个点，而一条链中能影响它的选择情况的，只有 $1$ 个点。

所以，非常暴力的思想就是用 DFS 树来确定更新顺序，令 $f_{x,0/1,0/1}$ 表示当前 $x$ 这个点选/不选，且这个点所在的环（**这个点不为环顶的环**）的**环底**选/不选时的最值（环顶/底：一个环中 DFS 序最小的叫环顶，最大的叫环底）

转移方程会比较长，请看代码注释：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5,M=2*N;
int n,m,val[N],f[N][2][2];
//          当前节点/是否选择当前节点/是否选择环底 
int tim,dfn[N];
vector<int> mp[N];
int dp(int x,int fa){
	dfn[x]=++tim;
	f[x][1][0]=f[x][1][1]=val[x];
	int rt=0;
	for(int v:mp[x]){
		if(fa==v) continue;
		if(!dfn[v]){
			int root=dp(v,x);
			//当自己不是环顶时的返回值是自己所在的大环的环顶 
			if(root!=dfn[x])rt=root;
			//如果当前节点的dfn等于返回值，则当前正在遍历一个环的第一条边 
			f[x][1][0]+=f[v][0][0];
			//不论当前是否为环顶，都应该这样更新 
			f[x][1][1]+=f[v][0][(root==dfn[x])?0:1];
			//如果是环顶， 那就必须不选环底，否则照常更新 
			if(root==dfn[x]){
				//只要不选环顶，就对子节点的状态没有任何限制 
				f[x][0][0]+=max(max(f[v][0][1],f[v][0][0]),max(f[v][1][0],f[v][1][1]));
				f[x][0][1]+=max(max(f[v][0][1],f[v][0][0]),max(f[v][1][0],f[v][1][1]));
			}
			else{
				//不是环顶，照常更新 
				f[x][0][0]+=max(f[v][0][0],f[v][1][0]);
				f[x][0][1]+=max(f[v][0][1],f[v][1][1]);
			}
		}else if(dfn[x]>dfn[v]){
			rt=dfn[v];//如果找到返祖边 
			//那么这个点就是环底，依照定义，以下情况不合法 
			f[x][1][0]=-0x3f3f3f3f; 
			f[x][0][1]=-0x3f3f3f3f;
		}
	}
	return rt;//小技巧：递归地返回所在的的环顶
}
int main(){
    ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v;cin>>u>>v;
		mp[u].push_back(v),mp[v].push_back(u);
	}
	for(int i=1;i<=n;i++) cin>>val[i];
	dp(1,0);
	cout<<max(max(f[1][0][1],f[1][0][0]),max(f[1][1][1],f[1][1][0]));
	return 0;
}
```

关于使用圆方树解决的题解([点击查看原题解](https://www.luogu.com.cn/blog/chen196422803/sol-p4410))，在此我想对那篇题解做一个注解，解释一下方点的转移方法：

那篇题解是这样处理方点的：

```cpp
int f0=0, f1=-1.4e8, g0=-1.4e8, g1=0;
//f是代表父节点(即环顶)不选的情况，g是代表要选的情况 
for(int i=hh[u]; i; i=nt[i]){
    int v=to[i]; if(v==fa)continue;
    dp(v, u);
    int o0=f0, o1=f1;
    f0=max(o0, o1)+f[v][0], f1=o0+f[v][1];
	//不选的时候，由于圆方树加边的特性，上一个扫描的儿子和当前扫描的儿子
	//在原图上面是相邻的，于是可以更新 
    o0=g0, o1=g1;
    g0=max(o0, o1)+f[v][0], g1=o0+f[v][1];
    //要选环顶的时候，由于 g0 初值是inf，所以第一条直接与环顶接壤的边不会被更新到 
}
f[u][0]=max(f0, f1), f[u][1]=g0;
//这里没有用 g1 更新，因为最后一个遍历的儿子必然是环底，这样做保证了不选环底 
```

~~（我才不会告诉你我看了 2days 还不懂问了机房大佬 way 才懂的）~~

对于更扩展的问题，无向图上的最大独立集问题，很遗憾，这是一个 NP-Complete 问题，可以从 3-SAT 归约而来。

这就做完了。


---

## 作者：Fzrcy (赞：2)

先建立原图的广义圆方树 $G$，设方点为 $n+1$ 至 $Node$（$Node$ 为 $G$ 的节点数）。

定义状态数组 $f_{u,0/1}$，对于圆点，它的含义是在以 $i$ 为根的子树中选择/不选择节点 $i$ 的最大权值，对于方点，它的含义是在以 $i$ 为根的子树中，选择/不选择父亲节点 $fa$ 的最大权值（$f_{i,1}$ 不包括节点 $fa$ 的权值）。

对于圆点 $u$ 有状态转移方程：$f_{u,0}=\sum_{u\to v}f_{v,0}$，$f_{u,1}=val_{u}+\sum_{u\to v}f_{v,1}$。

对于方点 $u$ 设 $f_0=0$，$f_1=-inf$，$g_0=-inf$，$g_1=0$，然后枚举儿子节点 $v$，有 $o_0=f_0$，$o_1=f_1$，$f_0=\max(o_0,o_1)+f_{v,0}$，$f_1=o_0+f_{v,1}$，$o_0=g_0$，$o_1=g_1$，$g_0=\max(o_0,o_1)+g_{v,0}$，$g_1=o_0+g_{v,1}$（依次按顺序执行），计算完所有儿子节点后，有 $f_{u,0}=\max(f_0,f_1)$，$f_{u,1}=g_0$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+1;
int h[N], nt[N<<1], to[N<<1], cnt, hh[N];
int dfn[N], low[N], Stack[N], Top, Node;
int f[N][2], val[N], n, m, dfnt;
void link(int u, int v){
    nt[++cnt]=h[u], h[u]=cnt, to[cnt]=v;
}
void llink(int u, int v){
    nt[++cnt]=hh[u], hh[u]=cnt, to[cnt]=v;
}
void Tarjan(int u){
    Stack[++Top]=u, dfn[u]=low[u]=++dfnt;
    for(int i=h[u]; i; i=nt[i]){
        int v=to[i];
        if(!dfn[v]){
            Tarjan(v), low[u]=min(low[u], low[v]);
            if(low[v]>=dfn[u]){
                Node++;
                for(int x=0; x!=v; Top--)
                    x=Stack[Top], llink(Node, x), llink(x, Node);
                llink(Node, u), llink(u, Node);
            }
        }
        else low[u]=min(low[u], dfn[v]);
    }
}
void dp(int u, int fa){
//    printf("%d  %d\n", fa, u);
    if(u<=n){
        for(int i=hh[u]; i; i=nt[i]) if(to[i]!=fa)
            dp(to[i], u), f[u][0]+=f[to[i]][0], f[u][1]+=f[to[i]][1];
        f[u][1]+=val[u];
        return;
    }
    else{
        int f0=0, f1=-1.4e8, g0=-1.4e8, g1=0;
        for(int i=hh[u]; i; i=nt[i]){
            int v=to[i]; if(v==fa)continue;
            dp(v, u);
            int o0=f0, o1=f1;
            f0=max(o0, o1)+f[v][0], f1=o0+f[v][1];
                o0=g0, o1=g1;
            g0=max(o0, o1)+f[v][0], g1=o0+f[v][1];
        }
        f[u][0]=max(f0, f1), f[u][1]=g0;
    }
}
int main(){
#ifdef LOCAL
    freopen("text.in","r",stdin);
    freopen("text.out","w",stdout);
#endif // LOCAL
    scanf("%d %d", &n, &m);
    for(int i=1, x, y; i<=m; i++)
        scanf("%d %d", &x, &y), link(x, y), link(y, x);
    for(int i=1; i<=n; i++)
        scanf("%d", &val[i]);
    Node=n, Tarjan(1), Top=0;
    dp(1, -1);
    printf("%d\n", max(f[1][0], f[1][1]));
    return 0;
}
```



---

## 作者：Cry_For_theMoon (赞：0)

学习了 WC2017 的仙人掌课件后发现了这个题。

其实处理仙人掌肯定强于处理树，所以我们会去想树上的问题怎么做，然后推广到仙人掌上。

树上的话，只要设 $f(u,0/1)$ 表示 $u$ 子树内，且 $u$ 本身是否选择，构成的最大独立集大小即可。

推广到仙人掌上，常用的方法有两个：

1. 圆方树

2. dfs 树。

这两个方法都应该是可以求最大权独立集的。这里给出一个 dfs 树上的解法。

首先 dfs 树并不完全是纯正的一颗树，因为 dfs 树之外还有返祖边的存在。仙人掌的特性使得一条边最多被一个返祖边覆盖（注意我们通常讨论边仙人掌，因为点仙人掌是边仙人掌的子集）。

由于仙人掌上一条边只会被一个返祖边覆盖，容易想到设 $f(u,0/1,0/1)$，新增的一个 $0/1$ 表示点 $u$ 所在的环顶是否选择。

但是这样会存在问题：我们把样例的图画出来，就会发现，点 $3$ 其实存在于两个环当中：$1\rightarrow 2\rightarrow 3\rightarrow 5\rightarrow 1$ 以及 $3\rightarrow 6\rightarrow 5\rightarrow 3$。那么我们到底记录的是哪个环。

事实上我们不难发现：如果 $u$ 在 $k(\gt 1)$ 个环中，必定有至少 $k-1$ 个环，它是作为环顶出现的。而此时你记录的两个 $0/1$ 都代表 $u$ 本身是否选择，这是无意义的。

换言之，我们新增的 $0/1$ 应该代表：$u$ 的一个所在环，且 $u$ 不是这个环的环顶，这个环的环顶是否被选择。

如果对于一个 $u$ 不存在这样的环顶，我们钦定第二维必须为 $0$。

这样就可以实现转移了。

复杂度 $O(n)$ （仙人掌上应该是 $n,m$ 同阶罢）。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define op(x) ((x&1)?x+1:x-1)
#define odd(x) (x&1)
#define even(x) (!odd(x))
#define lc(x) (x<<1)
#define rc(x) (lc(x)|1)
#define lowbit(x) (x&-x)
#define mp(x,y) make_pair(x,y)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
using namespace std;
const int MAXN=1e5+10,MAXM=2e5+10,INF=1e9;
int n,m,w[MAXN],u[MAXM],v[MAXM];
int istop[MAXN],isbottom[MAXN],top[MAXN],depth[MAXN],tag[MAXM],fa[MAXN],vis[MAXN];
int tmp[2][2];
vector<array<int,2> >e[MAXN];
vector<int>g[MAXN];
void dfs1(int u){
    depth[u]=depth[fa[u]]+1;vis[u]=1;
    for(auto p:e[u]){
        int v=p[0],idx=p[1];
        if(vis[v])continue;
        fa[v]=u;tag[idx]=1;
        dfs1(v);
    }
}
void tomax(int& x,int y){x=max(x,y);}
int dp[MAXN][2][2],ans=-INF;
void dfs2(int u){
    rep(i,0,1)rep(j,0,1)dp[u][i][j]=-INF;
    dp[u][0][0]=0;dp[u][1][0]=w[u];
    if(top[u]){
        if(isbottom[u])dp[u][0][1]=0;
        else dp[u][0][1]=0,dp[u][1][1]=w[u];
    }
    for(auto v:g[u]){
        if(v!=fa[u]){
            dfs2(v);
            rep(a,0,1)rep(b,0,1)tmp[a][b]=dp[u][a][b];
            if(u==top[v]){
                rep(a,0,1)rep(b,0,1)rep(c,0,1)rep(d,0,1){
                    if(a!=d)continue;
                    if(a && c)continue;
                    tomax(tmp[a][b],dp[u][a][b]+dp[v][c][d]);
                }
            }else{
                rep(a,0,1)rep(b,0,1)rep(c,0,1)rep(d,0,1){
                    if(a && c)continue;
                    if(b!=d)continue;
                    tomax(tmp[a][b],dp[u][a][b]+dp[v][c][d]);
                }
            }
            rep(a,0,1)rep(b,0,1)dp[u][a][b]=tmp[a][b];
        }
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    rep(i,1,m){
        cin>>u[i]>>v[i];
        e[u[i]].push_back({v[i],i});
        e[v[i]].push_back({u[i],i});
    }
    dfs1(1);
    rep(i,1,m)if(!tag[i]){
        if(depth[u[i]]<depth[v[i]])swap(u[i],v[i]);
        istop[v[i]]=1;
        isbottom[u[i]]=1;
        while(u[i]!=v[i])top[u[i]]=v[i],u[i]=fa[u[i]];
    }else g[u[i]].push_back(v[i]),g[v[i]].push_back(u[i]);
    rep(i,1,n)cin>>w[i];
    dfs2(1);
    rep(i,0,1)rep(j,0,1)tomax(ans,dp[1][i][j]);
    cout<<ans;

    return 0;
}
```

---


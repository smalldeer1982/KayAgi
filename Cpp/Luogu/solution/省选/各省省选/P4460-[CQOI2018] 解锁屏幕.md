# [CQOI2018] 解锁屏幕

## 题目背景

使用过 Android 手机的同学一定对手势解锁屏幕不陌生。 Android 的解锁屏幕由 $3 \times 3$ 个点组成，手指在屏幕上画一条线，将其中一些点连接起来，即可构成一个解锁图案。如下面三个例子所示：

![](https://cdn.luogu.com.cn/upload/pic/17556.png)
![](https://cdn.luogu.com.cn/upload/pic/17557.png)
![](https://cdn.luogu.com.cn/upload/pic/17558.png)

## 题目描述

画线时还需要遵循一些规则：
1. 连接的点数不能少于 $4$ 个。也就是说只连接两个点或者三个点会提示错误。
2. 两个点之间的联线不能弯曲。
3. 每个点只能“使用”一次，不可重复。这里的“使用”是指手指划过一个点，该点变绿。
4. 两个点之间的连线不能“跨过”另一个点，除非那个点之前已经被“使用”过。

对于最后一条规则，参见下图的解释。左边两幅图违反了该规则；而右边两幅图（分别为 $ 2 \rightarrow 4 \rightarrow 1 \rightarrow 3 \rightarrow 6$ 和 $ 6 \rightarrow 5 \rightarrow 4 \rightarrow 1 \rightarrow 9 \rightarrow 2$ ）则没有违反规则，因为在“跨过”点时，点已经被使用过了。

![](https://cdn.luogu.com.cn/upload/pic/17566.png)

现在工程师希望改进解锁屏幕，增减点的数目，并移动点的位置，不再是一个九宫格形状，但保持上述画线规则不变。

请计算新的解锁屏幕上，一共有多少满足规则的画线方案。

## 说明/提示

#### 样例解释 1

设 $4$ 个点编号为 $1$ 到 $4$ ，方案有 $1 \rightarrow 2 \rightarrow 3 \rightarrow 4$ ， $2 \rightarrow 1 \rightarrow 3 \rightarrow 4$ ，  $3 \rightarrow 2 \rightarrow 1 \rightarrow 4$ ，  $2 \rightarrow 3 \rightarrow 1 \rightarrow 4$ 以及它们的镜像。

### 数据范围

- 对于 $30\%$ 的数据，$1 \le n \le 10$。
- 对于 $100\%$ 的数据，$-1000 \le x_i ,y_i \le 1000$，$ 1 \le n < 20$。各点坐标不相同。

## 样例 #1

### 输入

```
4
0 0
1 1
2 2
3 3```

### 输出

```
8```

## 样例 #2

### 输入

```
4
0 0
0 1
0 2
1 0```

### 输出

```
18```

# 题解

## 作者：孙子隆 (赞：18)


本应该10.1前停课的我，选择提早来腾飞。

首先看到这个题，题面就很有意思。

## n<20!
显然首先应该想到就是状压了吧

设置dp[i]表示到达i状态得所有情况和

然后接着去想怎么转移和判断是否能够表示这些状态。

然后我发现我失败了，开一维的话没法转移，
因为时间复杂度会妥妥的T飞。

然后想一下（1<<20）并不大，可以考虑开两维。

设置dp[i][j]表示到达i状态后最后一个点是j的所有情况。

然后枚举每一个现阶段的点i和要转移的点k，然后枚举每一个状态。这样时间复杂度是
O(2^n*n^2）

最大的情况是约是4*1e8，

这样按照ccf的老爷机要跑4s。

这样我只能是吸氧过

转移方程也不难写
dp[i|(1<<(k-1)][k]+=dp[i][j];
这个题在判断添加上很像P2831

其余优化小细节都在代码里
（本代码借鉴第一页大佬的代码）

然后我写到一半省队爷突然回来，然后我问他是否吸了o2，然后我得知他通过二进制成功AC不开氧气

下面我贴一下他代码吧原理是一样的

二进制卡常还是nb啊！！！！
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#define Mod 100000007
using namespace std;
int nd[21][21];
int dp[1<<20][20];
int f[1<<20];
int n;
struct Point{
	int x,y;
}p[21];
bool is(Point a,Point b,Point c)//b是否在a和c连线上
{
	return (a.x-b.x)*(b.y-c.y)==(b.x-c.x)*(a.y-b.y);
}
int main()
{
//	freopen("android.in","r",stdin);
//	freopen("android.out","w",stdout);
	scanf("%d",&n);
	for(int i=0;i<n;i++)
		scanf("%d %d",&p[i].x,&p[i].y);
	for(int i=1;i<(1<<n);i++)
		f[i]=f[i>>1]+(i&1);
	int ans=0;
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
		{
			if(i==j)continue;
			for(int k=0;k<n;k++)
			{
				if(k==i||k==j)continue;
				if(((p[k].x-p[i].x)*(p[k].x-p[j].x)<0||(p[k].y-p[i].y)*(p[k].y-p[j].y)<0)&&is(p[i],p[k],p[j]))
					nd[i][j]|=(1<<k);
			}
		}
	for(int i=0;i<n;i++)
		dp[1<<i][i]=1;
	for(int i=1;i<(1<<n);i++)
	{
		for(int j=0;j<n;j++)
			if(dp[i][j]&&((1<<j)&i))
			{
				if(f[i]>=4)ans=(ans+dp[i][j])%Mod;
				for(int k=0;k<n;k++)
					if(!((1<<k)&i)&&(nd[j][k]&i)==nd[j][k])
					{
						dp[i|(1<<k)][k]=(dp[i|(1<<k)][k]+dp[i][j])%Mod;
					}
			}
	}
	printf("%d\n",ans);
//	fclose(stdin);fclose(stdout);
	return 0;
}
```


一定要事先预处理会省很多时间！！！


---

## 作者：StudyingFather (赞：15)

因为 $n \leq 20$，考虑状压。

先预处理从 $i$ 号点到 $j$ 号点一定经过的点，压到一个集合 $S_{i,j}$ 中。

设 $f_{i,j}$ 表示图案经过的点集为 $i$，且最后一个点是 $j$ 的方案数。

每次枚举下一个要经过的点，当且仅当这个点之前没被经过，且当前点合下一个点之间的所有点都被经过时才能转移。

最后统计所有经过至少四个点的状态即可。

时间复杂度 $O(n^2 2^n)$，当然实际合法的状态转移不会达到这个上限。

```cpp
// Problem : P4460 [CQOI2018]解锁屏幕
// Contest : Luogu Online Judge
// URL : https://www.luogu.com.cn/problem/P4460
// Author : StudyingFather
// Site : https://studyingfather.com
// Memory Limit : 500 MB
// Time Limit : 1000 ms
// Powered by CP Editor (https://github.com/cpeditor/cp-editor)

#include <iostream>
#include <algorithm>
#define MOD 100000007
#define INF 1e9
#define eqs 1e-7
using namespace std;
struct point
{
 int x,y;
}p[25];
int f[2500005][25],ans;
int g[25][25];
bool cmp(const point&a,const point&b)
{
 return a.x<b.x||(a.x==b.x&&a.y<b.y);
}
double slope(int x1,int y1,int x2,int y2)
{
 if(x1==x2)return INF;
 return 1.0*(y1-y2)/(x1-x2);
}
int popcount(int x)
{
 int ans=0;
 while(x)
 {
  ans++;
  x&=(x-1);
 }
 return ans;
}
int main()
{
 int n;
 cin>>n;
 for(int i=1;i<=n;i++)
  cin>>p[i].x>>p[i].y;
 sort(p+1,p+n+1,cmp);
 for(int i=1;i<=n;i++)
  for(int j=i+1;j<=n;j++)
   for(int k=i+1;k<=j-1;k++)
    if(abs(slope(p[i].x,p[i].y,p[k].x,p[k].y)-slope(p[k].x,p[k].y,p[j].x,p[j].y))<=eqs)
     g[i][j]|=(1<<k),g[j][i]|=(1<<k);
 for(int i=1;i<=n;i++)
  f[1<<i][i]=1;
 for(int i=0;i<(1<<(n+1));i++)
  for(int j=1;j<=n;j++)
   if(i&(1<<j))
    for(int k=1;k<=n;k++)
     if((i&(1<<k))==0&&k!=j&&(i&g[j][k])==g[j][k])
      f[i|(1<<k)][k]=(f[i|(1<<k)][k]+f[i][j])%MOD;
 for(int i=0;i<(1<<(n+1));i++)
  if(popcount(i)>=4)
   for(int j=1;j<=n;j++)
    if(i&(1<<j))ans=(ans+f[i][j])%MOD;
 cout<<ans<<endl;
 return 0;
}
```

---

## 作者：littleseven (赞：11)

# BZOJ 5299 [Cqoi2018]解锁屏幕

**题目链接：**[BZOJ 5299 [Cqoi2018]解锁屏幕]( https://lydsy.com/JudgeOnline/problem.php?id=5299 )		[洛谷 P4460 [CQOI2018]解锁屏幕]( https://www.luogu.org/problem/P4460 )

**算法标签:**  `状压DP`、`思维`

## 题目描述：

见题面。

## 题解：

**状压DP**

我们考虑一下限定条件：

- 点数 $\ge 4$ 这个限定条件其实可以在最后统计时候进行判断。
- 不能弯曲，这个其实不用特殊处理，理解路径就行。
- 每个点只能使用一次，因为我们直接使用状态压缩，我们直接判一下当前点在当前状态中是否出现过即可。
- 连线不能跨过一个没走过的点。对于这个特殊的限定条件，我们需要在进行DP之前处理出对于 $i$，$j$ 两个点的连线上有那些点。这样可以选择用相似三角形判断共线或者使用斜率判断（较麻烦）。

​	之后考虑状态。首先我们既然选择把这 $n$ 个点压成一维，我们就一定要从这里边的点向外边连线，而且我们又发现对于同一个状态，先走某个点和后走某个点并不算做同一种情况。这时我们发现，无论如何我们的状态中都要有<u>当前状态</u>和<u>从状态中的哪个点向外引边</u>。所以不妨就设状态为 $f[s][i]$ 为当前所有点的 $0/1$ 状态为 $s$，最后一个点选择 $i$ 的画线方案数。

​	转移则是每次枚举当前状态的一个点，向其他没有在当前状态的点引边，如果这条边合法则可以转移，不合法则跳过。

​	统计答案的时候特殊判一下当前这个答案是不是最少连接了 $4$ 个点即可。



想要学习更多状压DP，见博客[链接]( http://littleseven.top/archives/506#comment-52 )

## AC代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int mod = 1e8 + 7;

const int N = 21;

int n, Log[1 << N];

// Log[]便于直接取出当前这个元素在第几个位置（状态中的这个1代表的是第几个点）

int line[N][N];

// line[i][j] 存从i到j连线上的点，同样这里也将状态压缩成一个数

ll f[1 << N][N], ans;

struct Node {
	int x, y;
} node[N];

void init() {
	Log[1] = 0;
	for (int i = 2; i <= (1 << n) - 1; i ++ ) {
		Log[i] = Log[i >> 1] + 1;
	}
	// 预处理Log[]
}

bool check(Node xx, Node a, Node b) {
	// 检验点xx是否在a->b的线段上
	if (xx.x < min(a.x, b.x) || xx.x > max(a.x, b.x)) {
		// 可能在直线上但是一定不在线段上
		return 0;
	}
	if (xx.y < min(a.y, b.y) || xx.y > max(a.y, b.y)) {
		// 可能在直线上但是一定不在线段上
		return 0;
	}
	return ((a.x - xx.x) * (xx.y - b.y) == (xx.x - b.x) * (a.y - xx.y));
	// 在线段上
}

int lowbit(int x) {
	// lowbit函数（同树状数组中的lowbit），用来取出x在二进制下最右边一个1
	return x & (-x);
}

int main() {
	scanf("%d", &n);
	init();
	for (int i = 0; i < n; i ++ ) {
		scanf("%d%d", &node[i].x, &node[i].y);
	}
	for (int i = 0; i < n; i ++ ) {
		f[1 << i][i] = 1ll;
		// 初值
	}
	for (int i = 0; i < n; i ++ ) {
		for (int j = 0; j < n; j ++ ) {
			for (int k = 0; k < n; k ++ ) {
				if (k != i && k != j) {
					if (check(node[k], node[i], node[j])) {
						// 处理出对于每一条边经过了哪些点
						line[i][j] |= (1 << k);
					}
				}
			}
		}
	}
	for (int s = 0; s <= (1 << n) - 1; s ++ ) {
		for (int k = 0; k < n; k ++ ) {
			int now = s;
			while (now) {
				int ss = lowbit(now);
				int pos = Log[ss];
				// 这里通过lowbit来实现枚举，比一位一位判断要更省时间
				if ((! (s & (1 << k))) && ((line[pos][k] & s) == line[pos][k])) {
					// 更新状态，判断是否出现过以及是否在当前这两个点的连线上有其他的点
					f[s | (1 << k)][k] = (f[s | (1 << k)][k] + f[s][pos]) % mod;
				}
				now -= lowbit(now);
			}
		}
	}
	for (int s = 0; s <= (1 << n) - 1; s ++ ) {
		int cnt = 0;
		ll tmp = 0ll;
		for (int i = 0; i < n; i ++ ) {
			if (s & (1 << i)) {
				// 记录点个数和答案
				cnt ++ ;
				tmp = (tmp + f[s][i]) % mod;
			}
		}
		if (cnt >= 4) {
			// 当个数>=4个的时候就更新答案
			ans = (ans + tmp) % mod;
		}
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：Bruteforces (赞：4)

## 题意
给出N个点的坐标，用直线连接至少四个点组成一条折线，并且一条直线不能跨过尚未被选中的点。求出不同折线的数量。
## 题解
简单状压DP~~+毒瘤卡常~~

我们很容易发现，一个状态只跟**已选中的点集**与**折线的终点**有关。因此我们就可以状压DP啦~

具体实现见代码和注释
```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define mp make_pair
using namespace std;

const int N=20,mod=100000007;
int n,X[N],Y[N],a[N][N],f[N][1<<N],ans=0;
bool vis[N][1<<N];
queue<pii> Q;

inline bool isright(int x){   //判断折线是否经过至少四个点
	int cnt=0;
	for(;x;x-=(x&(-x)))cnt++;
	return cnt>=4;
}
inline bool onit(int x,int s,int t){   //判断x是否在s到t的连线上
	if(X[x]<min(X[s],X[t]) || X[x]>max(X[s],X[t]) || Y[x]<min(Y[s],Y[t]) || Y[x]>max(Y[s],Y[t]))return 0;
	return ((X[x]-X[s])*(Y[t]-Y[x])-(X[t]-X[x])*(Y[x]-Y[s])==0);
}
inline bool check(int x,int s,int t){   //判断连线上所有点是否都已被选中
	return ((a[s][t]&x)==a[s][t]);
}
inline void Add(int &x,int y){
	x+=y;if(x>=mod)x-=mod;
}

int main(){
	scanf("%d",&n);
	for(register int i=0;i<n;i++)scanf("%d%d",&X[i],&Y[i]);
	for(register int i=0;i<n;i++){   //预处理出连接两个点之前必须先连接的点
		for(register int j=0;j<n;j++)if(i!=j){
			for(register int k=0;k<n;k++)if(k!=i && k!=j && onit(k,i,j))
				a[i][j]+=(1<<k);
		}
	}
	for(register int i=0;i<n;i++)vis[i][1<<i]=1,f[i][1<<i]=1,Q.push(mp(i,1<<i));   //辣鸡的BFS实现状压DP
	while(!Q.empty()){
		int x=Q.front().first,y=Q.front().second;Q.pop();
		if(isright(y))Add(ans,f[x][y]);
		for(register int i=0,j=1;i<n;i++,j<<=1)if(!(j&y)){
			if(!check(y,x,i))continue;
			if(!vis[i][j|y])vis[i][j|y]=1,Q.push(mp(i,j|y));
			Add(f[i][j|y],f[x][y]);
		}
	}
	printf("%d\n",ans);
	return 0;
}
```
时间复杂度O(2^n*n^2)，卡卡常数，开个O2就能过啦~

---

## 作者：PhantasmDragon (赞：2)

安利本人博客:http://phantasmdragon.leanote.com/post/%5B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%5D%5BCQOI2018%5D%E8%A7%A3%E9%94%81%E5%B1%8F%E5%B9%95


------------

状态压缩形的递推.

我们用f[i][j]表示所有点的使用情况为i,最后碰到的一个点是j的总方案数.

比如 $f[10110][3]$ 表示5,3,2号点被连接,且现在落在3号点的总方案数.

这道题可以采用从前面向后面推的方法,比如 $f[10110][3]$ ,它可以推导到的状态有 $f[11110][4]$ 和 $f[10111][1]$ .以 $f[11110][4]$ 为例,我们从 $f[10110][3]$ 转移的条件就是在4号点和3号点连线上的点都被使用过了,否则就会违背题目的4号规则.

那对于每个状态 $f[s][j]$ ,我们就可以枚举它下一次连接的点 $k$ ,只要 $j$ 和 $k$ 连线上的所有点都已经在 $s$ 这个状态中被使用了,那么 ```f[s|(1<<(k-1))][k]+=f[s][j]``` 即可.

对于点与点之间相互的"跨越"关系,在开始时预处理一下即可.

最后统计答案的时候别忘了排除连接的点小于4个的所有状态.

----------
贴上代码:
```
#include<cstdio>
#include<cstdlib>
#include<vector>
#include<cmath>
#include<algorithm>
#define maxn 22
#define eps 1e-5
#define p 100000007
using namespace std;
struct point{int x,y;}a[maxn];
int f[1<<20][maxn],n,F;
vector<int> cr[maxn][maxn];
int judge(int l,int r,int m)
{
    if((a[m].x==a[l].x||a[m].x==a[r].x)&&a[l].x==a[r].x) return 1;
    else if(a[m].x==a[l].x||a[m].x==a[r].x) return 0;
    double k1=1.0*(a[m].y-a[l].y)/(a[m].x-a[l].x);
    double k2=1.0*(a[r].y-a[m].y)/(a[r].x-a[m].x);
    return fabs(k1-k2)<=eps;
}
int cmp(point a,point b){return a.x==b.x?a.y<b.y:a.x<b.x;}
int main()
{
    scanf("%d",&n);
    F=(1<<n)-1;
    for(int i=1;i<=n;i++) scanf("%d%d",&a[i].x,&a[i].y);
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++)
    {
        for(int j=i+1;j<=n;j++)
        {
            for(int k=i+1;k<=j-1;k++)
            {
                if(judge(i,j,k)) cr[i][j].push_back(k);
            }
        }
    }
    for(int i=1;i<=n;i++) f[(1<<(i-1))][i]=1;
    for(int i=1;i<=F;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if((i>>(j-1))&1) continue;
            int s=(i|(1<<(j-1)));
            for(int k=1;k<=n;k++)
            {
                if(k==j) continue;
                int x=min(j,k),y=max(j,k),flag=0;
                for(int t=0;t<cr[x][y].size();t++)
                    if(!((i>>(cr[x][y][t]-1))&1)) {flag=1;break;}
                if(flag) continue;
                f[s][j]=(f[s][j]+f[i][k])%p;
            }
        }
    }
    int ans=0;
    for(int i=1;i<=F;i++)
    {
        if(__builtin_popcount(i)<4) continue;
        for(int j=1;j<=n;j++)ans=(ans+f[i][j])%p;
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：傅思维666 (赞：1)


## 题解：

[博客食用口味更佳](https://www.cnblogs.com/fusiwei/p/11813111.html)

七哥@littleseven 推荐的题。~~必须要做~~

看到方案数想到递推，然后$1\le N\le 20$。所以想到状态压缩。然后七哥让我推状态。我一想，如果开多维的话可能空间会爆，所以考虑只开一维，压成一个$1<<n$的状态，表示每个点是否被连接。

后来发现没法转移。所以考虑再开一维，于是到处搜索...拿什么做第二维能保证既能转移又不会挂空间呢？

一看数据范围，只有点数的二十还符合第二点要求，所以就选择这个做状态。苦思冥想~~看完题解~~之后，觉得把状态设置成这样最合适：

$dp[i][j]$表示点的选择状况为$i$、选择的点集中终点为$j$时的方案数。

那么，针对于一个已定的状态$i$，它能转移的对象是这个状态中不为1的点。

举例：

$dp[10010][2]$可以转移到$dp[11010][4],dp[10011][1]$等状态。我们在转移的时候判一下这个点可不可以转移即可。（条件是转移前的$j$和转移后的$j$连上的直线上所有的点全部已经被到达过）

这样的话，我们可以先把两点间的点开$vector$存下，然后进行递推。

发现只连一个点的方案数是1.这个当初值。

我们转移的时候记录把当前状态用$st$记录下来，然后再用$k$枚举上一层状态，如果符合条件（即上面的点都被经过了，用$flag$标记判断进行转移就好）

转移方程是：
$$
dp[st][j]=(dp[st][j]+dp[i][k])\quad(mod\,\,\,p)
$$
完整代码就是：

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
const int mod=1e8+7;
int n;
bool flag;
int dp[1<<20][21];
struct node
{
    int x,y;
}a[21];
bool cmp(node a,node b)
{
    if(a.x==b.x)
        return a.y<b.y;
    return a.x<b.x;
}
vector<int> vec[21][21];
bool check(node a,node b,node c)
{
    return (a.x-b.x)*(b.y-c.y)==(b.x-c.x)*(a.y-b.y)?1:0;
}
int lowbit(int x)
{
    int ret=0;
    while(x)
    {
        x-=(x&(-x));
        ret++;
    }
    return ret;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&a[i].x,&a[i].y);
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n;j++)
            for(int k=i+1;k<j;k++)
                if(check(a[i],a[k],a[j]))
                    vec[i][j].push_back(k);
    for(int i=1;i<=n;i++)
        dp[1<<(i-1)][i]=1;
    for(int i=0;i<(1<<n);i++)
        for(int j=1;j<=n;j++)
        {
            if((i>>(j-1))&1)
                continue;
            int st=(i|(1<<(j-1)));
            for(int k=1;k<=n;k++)
            {
                if(k==j)
                    continue;
                int xx=min(j,k);
                int yy=max(j,k);
                flag=0;
                for(int t=0;t<vec[xx][yy].size();t++)
                    if(!((i>>(vec[xx][yy][t]-1))&1))
                    {
                        flag=1;
                        break;
                    }
                if(flag)
                    continue;
                dp[st][j]=(dp[st][j]+dp[i][k])%mod;
            }
        }
    int ans=0;
    for(int i=0;i<(1<<n);i++)
    {
        if(lowbit(i)<4)
            continue;
        for(int j=1;j<=n;j++)
            ans=(ans+dp[i][j])%mod;
    }
    printf("%d",ans);
    return 0;
}
```



---

## 作者：Tgotp (赞：1)

令f[i][j]表示状态为i，最后到达点为j的方案数，

那么考虑下一个点，

能到达的情况就是最后一个点和现在这个点中间没有点或者所有点都在i状态内

这东西用叉积判判可以预处理出来，然后跑状压dp就可以了，i大于4个1的时候加进答案就可以了

复杂度$O(2^nn^2)$然而跑不满所以复杂度就是O(能过)

c++代码如下：
```
#include<bits/stdc++.h>
#define rep(i,x,y) for(register int i = x;i <= y; ++ i)
#define repd(i,x,y) for(register int i = x;i >= y; -- i)
using namespace std;
typedef long long ll;
template<typename T>inline void read(T&x)
{
	char c;int sign = 1;x = 0;
	do { c = getchar(); if(c == '-') sign = -1; }while(!isdigit(c));
	do { x = x * 10 + c - '0'; c = getchar(); }while(isdigit(c));
	x *= sign;
}

const int N = 20,mod = 1e8 + 7;
int x[N],y[N],in[N][N];
int n;

inline int cross(int ax,int ay,int bx,int by) { return ax * by - ay * bx; }

inline bool check(int a,int b,int c)
{
	if(x[a] > x[b]) swap(a,b);
	if(x[a] == x[b])
	{
		if(x[c] != x[a]) return 0;
		return y[c] <= max(y[a],y[b]) && y[c] >= min(y[a],y[b]);
	}
	if(x[c] > x[b] || x[c] < x[a]) return 0;
	return cross(x[c]-x[a],y[c]-y[a],x[b]-x[a],y[b]-y[a]) == 0;
}

int f[1 << N][N],id[N],ans;

int main()
{
	read(n);
	rep(i,1,n) { read(x[i]); read(y[i]); }
	rep(i,1,n) id[i] = 1 << i - 1;
	rep(i,1,n) rep(j,i+1,n) if(i != j) rep(k,1,n)
		if(k != i && k != j && check(i,j,k))
			in[i][j] |= id[k],
			in[j][i] |= id[k];

	rep(j,1,n) f[id[j]][j] = 1;
	int s = (1 << n) - 1;
	rep(i,0,s) rep(j,1,n)
	{
		if(!f[i][j]) continue;
		rep(k,1,n)
		{
			if(i&id[k]) continue;
			if((in[j][k]&i)!=in[j][k]) continue;
			f[i|id[k]][k] = (f[i][j] + f[i|id[k]][k]) % mod;
		}
		if(__builtin_popcount(i) >= 4) ans = (ans + f[i][j]) % mod;
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：闲鱼 (赞：0)

先看数据范围

#### n<20

~~不是爆搜就是状压~~

考虑到把当前连接的点设为一个二进制状态i，每次不断去找未连接的点转移状态

因为数据范围不大，可以多设一维表示当前状态的最后一个连接的点是j，方便状态转移。

~~每个状态存的就是满足选中的状态集合为i，最后一个连接的点是j的方案数（废话）~~

同时为了保证合法，需要预处理两点连线上有哪些其他点。

G[i][j]存储一个二进制状态k，表示i和j的连线上的点

预处理判断一下是否在同一直线上以及是否在i点和j点之间即可

```cpp
#include <stdio.h>
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 25;
const int M = (1 << 20);
const int mod = 1e8 + 7;

struct Node{
    int x, y;
}node[N];
int G[N][N], sum[M], dp[M][N];

inline int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-') f = -1; ch = getchar();}
    while('0' <= ch && ch <= '9'){x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
    return x * f;
}

inline bool check1(Node a, Node b, Node c){
    return (b.x - a.x) * (a.y - c.y) == (a.x - c.x) * (b.y - a.y);
}

inline bool check2(Node a, Node b, Node c){
    return (a.x - b.x) * (a.x - c.x) < 0 || (a.y - b.y) * (a.y - c.y) < 0;
}

int main()
{
    int n = read(), ans = 0;
    for(register int i = 0;i < n;i++)
    {
        node[i].x = read(), node[i].y = read();
    }
    
    for(register int i = 1;i < (1 << n);i++) sum[i] = sum[i >> 1] + (i & 1);
    for(register int i = 0;i < n;i++) dp[1 << i][i] = 1; 
    
    for(register int i = 0;i < n;i++)
    {
        for(register int j = 0;j < n;j++)
        {
            if(i == j) continue;
            for(register int k = 0;k < n;k++)
            {
                if(k == i || k == j) continue;
                if(check1(node[k], node[i], node[j]) && check2(node[k], node[i], node[j]))
                {
                    G[i][j] = G[i][j] | (1 << k);
                }
            }
        }
    }
    
    for(register int i = 1;i < (1 << n);i++)
    {
        for(register int j = 0;j < n;j++)
        {
            if((1 << j) & i)
            {
                if(sum[i] >= 4) ans = (ans + dp[i][j]) % mod;
                for(register int k = 0;k < n;k++)
                {
                    if((1 << k) & i) continue;
                    if((G[j][k] & i) != G[j][k]) continue;
                    dp[i | (1 << k)][k] = (dp[i | (1 << k)][k] + dp[i][j]) % mod;
                }
            }
        }
    }
    printf("%d\n", ans % mod);
    return 0;
}
```


---

## 作者：feecle6418 (赞：0)

这道题是毒瘤卡常的简单状压DP。我们重点讲解如何优化。

很容易列出DP方程：设 $f[S][j]$ 表示目前已经经过的所有点的状态为 $S$，现在在 $j$ 这个点，则：
$$f[S][j]=\sum f[S-2^{j-1}][k]$$

其中 $k$ 为 $S-2^{j-1}$ 中包含的一个点，且满足 $j,k$ 连线上所有的点都包含在 $S$ 内。

但是这样会产生一个问题：每一次判断的时间复杂度是 $O(n)$ 的，整个算法时间复杂度为 $O(n^32^n)$，不能通过本题。还需要优化。

最简单的判断方法是枚举每个点，依次判断它是否已经包含于 $S$ 和是否满足不再连线上。这样复杂度是跑满的。我们首先尝试改变判断时枚举的东西来优化判断的过程（为什么？因为**最主要的时间都耗费在 $\mathrm{check}$ 上面了，优化一点点 $\mathrm{check}$ 的复杂度就会使得时间极大下降**），在DP前先把所有点对连线经过的点存下来，然后判断这些点是否被 $S$ 包含即可。

具体如何实现？有两种实现方法。一种是用  $\mathrm{vector}$ 存下这些被连线经过的点，然后遍历 $\mathrm{vector}$ 检查是否全部被 $S$ 包含；另一中，也是更快的一种，是把这些点**压入一个状态** $P$，然后直接检查整个状态 $P$ 是否被 $S$ 包含（**可通过 $P\ \mathrm{and}\ S=P$ 简单判断**）。两种方式都可通过本题。

下面给出两种实现方式的代码。

$\mathrm{vector}$（$O(n^32^n)$，完全跑不满）：

```cpp
// luogu-judger-enable-o2
#pragma GCC optimize(3)
#pragma GCC optimize("-O3")
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<vector>
#define mod 100000007
#define minn(x,y) ((x)<(y)?(x):(y))
#define maxx(x,y) ((x)>(y)?(x):(y))
using namespace std;
struct Point {
	int x,y;
} p[25];
int n,f[1100000][22],ans=0;
vector<int> notok[22][22];
inline double Slope(register int i,register int j) {
	if(p[i].x==p[j].x)return 1e8;
	return 1.0*(p[i].y-p[j].y)/(p[i].x-p[j].x);
}
inline char Check(register int stat,register int las,register int num) {
	for(register int j=0;j<notok[las][num].size();j++){
		if(!((stat>>(notok[las][num][j]-1))&1))return 0;
	}
	return 1;
}
inline int GetSiz(register int stat) {
	register int ret=0;
	while(stat) {
		ret+=(stat&1);
		stat>>=1;
	}
	return ret;
}
inline void Try() {
	for(register int i=1; i<=n; i++) {
		for(register int j=1; j<=n; j++) {
			if(j==i)continue;
			for(register int k=1; k<=n; k++) {
				if(k==i||k==j)continue;
				if(minn(p[i].x,p[j].x)<=p[k].x&&p[k].x<=maxx(p[i].x,p[j].x)) {
					if(minn(p[i].y,p[j].y)<=p[k].y&&p[k].y<=maxx(p[i].y,p[j].y)) {
						if(fabs(Slope(i,k)-Slope(k,j))<1e-7)notok[i][j].push_back(k);
					}
				}
			}
		}
	}
}
signed main() {
	//freopen("unlock.in","r",stdin);
	//freopen("unlock.out","w",stdout);
	scanf("%d",&n);
	for(register int i=1; i<=n; i++)scanf("%d%d",&p[i].x,&p[i].y);
	Try();
	for(register int i=1; i<(1<<n); i++) {
		register int siz=GetSiz(i);
		for(register int j=1; j<=n; j++) {
			if(!((i>>(j-1))&1))continue;
			if(!(i>>(j-1)))break;
			if(siz==1) {
				f[i][j]=1;
				break;
			}
			for(register int k=1; k<=n; k++) {
				if((!((i>>(k-1))&1))||k==j)continue;
				if(Check(i,k,j))f[i][j]+=f[i-(1<<(j-1))][k];
				if(f[i][j]>mod)f[i][j]-=mod;
			}
			if(siz>=4)ans+=f[i][j];
			if(ans>mod)ans-=mod;
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

压入状态：（此处只提供 $\mathrm{Check}$ 和 $\mathrm{Try}$ 函数的代码，其他完全相同，$O(n^22^n)$）

```cpp
inline char Check(register int stat,register int las,register int num) {
	if((notok[las][num]&stat)==notok[las][num])return 1;
	return 0;
}
inline void Try() {
	for(register int i=1; i<=n; i++) {
		for(register int j=1; j<=n; j++) {
			if(j==i)continue;
			for(register int k=1; k<=n; k++) {
				if(k==i||k==j)continue;
				if(minn(p[i].x,p[j].x)<=p[k].x&&p[k].x<=maxx(p[i].x,p[j].x)) {
					if(minn(p[i].y,p[j].y)<=p[k].y&&p[k].y<=maxx(p[i].y,p[j].y)) {
						if(fabs(Slope(i,k)-Slope(k,j))<1e-7)notok[i][j]+=(1<<(k-1));
					}
				}
			}
		}
	}
}
```

---

## 作者：FlyInTheSky (赞：0)

可以用连接个数来划分阶段。

那么我们设$dp(S,i)$为已经连过的点的集合，最后一次连在$i$点的方案数。

然后转移即可。复杂度$O(2^n n^2)$，复杂度跑不满可以过

然后我们还要满足两个点之间的连线不能「跨过」另一个点，那么我们预处理出来两个点之间点的集合，转移时判断即可。

这个集合可以$O(n^3)$来做，就是枚举两个点$i,j$求他们的之间点集合$S_{i,j}$
那么我们再枚举一个$k$点，判下**斜率相等**即可确定

还可以$O(nx)$做。先求出$\Delta x = b_x - a_x, \Delta y = b_y - a_y$，我们发现整点数只会在$(a_x + \frac{\Delta x}{\gcd (\Delta x, \Delta y)}, a_y + \frac{\Delta y}{\gcd (\Delta x, \Delta y)})$
，直接找坐标是否存在给定点即可，这里用了map，其实可以用桶。可以发现这个步数不超过$\max(x,y)$

最后统计答案统计$S$二进制下$1$个数大于等于$4$的

```c++
#include<cstdio> 
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<map>
#include<queue>
#include<set>
#define ms(i, j) memset(i, j, sizeof i)
#define LL long long
#define db double
#define fir first
#define sec second
#define mp make_pair
using namespace std;

namespace flyinthesky {

	const int MO = 100000007, MAXN = 20 + 1;
	
	int gcd(int a, int b) {return b != 0 ? gcd(b, a % b) : a;}
	
	int n, dp[(1 << 20) + 2][MAXN], s[MAXN][MAXN];
	struct pos {
		int x, y;
		bool operator < (const pos &rhs) const {
			return x == rhs.x ? y < rhs.y : x < rhs.x;
		}
	} p[MAXN];
	map<pos, int > ma;

    void clean() {
    	ms(dp, 0), ms(s, 0);
    }
    int solve() {
    	
    	clean();
    	cin >> n;
    	for (int i = 1; i <= n; ++i) scanf("%d%d", &p[i].x, &p[i].y), ma[p[i]] = i;
    	for (int u = 1; u <= n; ++u) {
    		for (int v = 1; v <= n; ++v) if (u != v) {
    			int dx = p[v].x - p[u].x;
    			int dy = p[v].y - p[u].y;
    			int g = gcd(dx, dy); g = (g < 0 ? -g : g);
    			if (g != 0) dx /= g, dy /= g;
    			int nowx = p[u].x, nowy = p[u].y;
    			while (!(nowx == p[v].x && nowy == p[v].y)) {
    				if (ma[(pos){nowx, nowy}]) s[u][v] |= (1 << (ma[(pos){nowx, nowy}] - 1));
    				nowx += dx, nowy += dy;
				}
				s[u][v] |= (1 << (u - 1));
				s[u][v] |= (1 << (v - 1));
			}
		}
		
		for (int i = 1; i <= n; ++i) dp[(1 << (i - 1))][i] = 1;
		
		for (int S = 0; S < (1 << n); ++S) {
			for (int i = 1; i <= n; ++i) if (S & (1 << (i - 1))) {
				for (int v = 1; v <= n; ++v) if (i != v && (S & (1 << (v - 1)))) {
					if ((S & s[i][v]) == s[i][v])
						dp[S][i] = (dp[S ^ (1 << (i - 1))][v] + dp[S][i]) % MO;
				}
			}
		}
		
		int ans = 0;
		
		for (int S = 0; S < (1 << n); ++S) {
			int tmp = S, cnt = 0;
			do {++cnt, tmp &= (tmp - 1);} while (tmp);
			if (cnt < 4) continue ;
			for (int i = 1; i <= n; ++i) ans = (ans + dp[S][i]) % MO;
		}
		
		cout << ans;

        return 0;
    } 
}
int main() {
    flyinthesky::solve();
    return 0;
}
```

---

## 作者：xfydemx (赞：0)

之前写挂了，过了两个月再翻出来做 A掉了  qwq

一眼状压 我们2^n的记下已经走过的点，然后check一下剩下的点是否可以选取 

因为第四条限制 不能跨过没走过的点

不妨通过预处理筛出哪些点在选取时不可以被跨过

复杂度O(2^n*n^3) 

虽然这题毒瘤卡常  但是复杂度对的话加个O2都能过的  
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<ctime>
#include<queue>
#include<cmath>
#include<stack>
#define ll long long
#define INF 0x3f3f3f3f
#define M 100000007
using namespace std;
ll m,n,ans,d[23][23],f[1<<20][21],k[21][21][21];
struct N{
    int x,y;
	friend bool operator < (N a,N b){
		if(a.x!=b.x) return a.x<b.x;
		return a.y<b.y;
	}
}a[22];
inline int read(){
	int s=1,w=0; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') s=-1;
	for(;isdigit(c);c=getchar()) w=10*w+c-'0';
	return s*w;
}
inline int get_sum(int x){
    int cnt=0;
    for(int i=1;i<=21;i++){
        if(x&(1<<(i-1))) cnt++;
    }
    return cnt;
}
inline bool check(int s,int x,int y){
    for(int i=1;i<=d[x][y];i++){
		if(!(s&(1<<(k[x][y][i]-1)))) 	return 0;
    }
    return 1;
}
int main(){
    n=read();
    for(int i=1;i<=n;i++){
        a[i].x=read(); a[i].y=read();
    }
    sort(a+1,a+n+1);
    ll full=1<<n;
    for(int i=1;i<=n;i++){
    	f[1<<(i-1)][i]=1;
        for(int j=i+1;j<=n;j++){
            for(int r=j+1;r<=n;r++){
                if(double((a[r].y-a[i].y)/double((a[r].x-a[i].x)))!=double((a[r].y-a[j].y)/double((a[r].x-a[j].x)))) continue;
                else {
                	k[i][r][++d[i][r]]=j;//因为已经排过序，j一定在i,r,中间
                	k[r][i][++d[r][i]]=j;//这里指想要从r到i必须经过j
				}
            }
        }
    }
    for(int s=1;s<full;s++){
        for(int i=1;i<=n;i++){
            if((!(s&(1<<i-1)))) continue;
            for(int j=1;j<=n;j++){
                if(s&(1<<(j-1))) continue;
                if(check(s,i,j)==0) continue;
                f[s|(1<<(j-1))][j]=(f[s|(1<<(j-1))][j]+f[s][i])%M;
            }
        }
    }
    unsigned ll ans=0;
    for(int i=1;i<full;i++){
        if(get_sum(i)<4) continue;
   		for(int j=1;j<=n;j++){
   			if(f[i][j]!=INF) {
   				ans=(ans+f[i][j])%M;
            }
        }
    }
    cout<<ans%M<<endl;
    return 0;
}

```

---


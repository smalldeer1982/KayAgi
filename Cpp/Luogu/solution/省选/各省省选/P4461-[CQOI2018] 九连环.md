# [CQOI2018] 九连环

## 题目背景

九连环是一种源于中国的传统智力游戏。如图所示，九个的圆环套在一把“剑”上，并且互相牵连。游戏的目标是把九个圆环全部从“剑”上卸下。

![](https://cdn.luogu.com.cn/upload/pic/17568.png)

## 题目描述

圆环的装卸需要遵守两个规则:

1. 第一个(最右边) 环任何时候都可以任意装上或卸下

2. 如果第k 个环没有被卸下，且第k 个环右边的所有环都被卸下，则第k+1个环(第k 个环左边相邻的环) 可以任意装上或卸下

与魔方的千变万化不同，解九连环的最优策略是唯一的。为简单起见，我们以“四连环”为例，演示这一过程。这里用1表示环在“剑”上，0 表示环已经卸下。

初始状态为1111,每步的操作如下:

1. 1101 (根据规则2,卸下第2 个环)

2. 1100 (根据规则1,卸下第1 个环)

3. 0100 (根据规则2,卸下第4 个环)

4. 0101 (根据规则1,装上第1 个环)

5. 0111 (根据规则2,装上第2 个环)

6. 0110 (根据规则1,卸下第1 个环)

7. 0010 (根据规则2,卸下第3 个环)

8. 0011 (根据规则1,装上第1 个环)

9. 0001 (根据规则2,卸下第2 个环)

10. 0000 (根据规则1,卸下第1 个环)

由此可见，卸下“四连环”至少需要10 步。随着环数增加，需要的步数也会随之增多。例如卸下九连环，就至少需要341步。

请你计算，有n 个环的情况下，按照规则，  全部卸下至少需要多少步。

## 说明/提示

对于10%的数据，$1≤n≤10$

对于30%的数据，$1≤n≤30$

对于100%的数据，$1≤n≤10^5,1≤m≤10$

## 样例 #1

### 输入

```
3
3
5
9```

### 输出

```
5
21
341```

# 题解

## 作者：WinXP (赞：39)

#啊

~~我一定要写这篇题解祭奠我逝去的一下午~~


拿到这题，乍一看是一个 $dp$ 题。也的确是一个 $dp$，而且非常水。

根据题中关于 $4$ 连环的解释，你可以发现 $4$ 连环的拆卸就是这样的一个规律：

$1$ : 拆 $2$ 连坏使其变为 $1100$ ；

$2$ : 拿掉最左面的 $1$ ;

$3$ : 加 $2$ 连环使其变为 $0111$ ；

$4$ : 拆 $3$ 连环。

仔细观察，两条规则中都是"任意装上或卸下。"那么可想而知装 $x$ 连环与卸 $x$ 连环都是同样的步数。

所以设 $dp(x)$ 表示 $x$ 连环拆卸的次数，~~这题已经结束了。~~（才怪)

$$dp(4)=dp(2) + 1 + dp(2) + dp(3)$$

$dp(n)=dp(n-2)$ (拆 $(n-2)$ 连环变成 $110000...$ ）$+$ $1$  ( $010000...$ )
$+$ $dp(n-2)$ (装 $(n-2)$ 连环变成 $011111...$ ) $+$ $dp(n-1)$ (拆 $(n-1)$ 连环)。

$$dp(n)=2dp(n-2)+dp(n-1)+1$$

于是我兴致冲冲地打了一发递推交上去30分。

然后我发现了一个问题：没有取膜？

没有取膜。我说怎么那么水。

于是我陷入了沉思。

。

沉思之中顺手打了个表：

$1$ $2$ $5$ $10$ $21$ $42$ $85$ $170...$

发现一个问题。每一项约等于前一项的 $2$ 倍。仔细分析，发现

$$dp(n)=2dp(n-1)+ (n\&1)?1:0$$

既然是 $2$ 倍，为什么不打一下 $2$ 进制表示呢？

$1$ $10$ $101$ $1010$ $10101$ $101010$ $1010101......$

有点意思。

其实也很容易能从 $dp$ 中发现这个规律，每当 $n$ 为奇数时$++$，就会使每隔 $1$ 位 $+1$ 。

这也不太好办。$n=1e5$ 时，这个 $2$ 进制数就有 $1e5$ 位。$10$ 进制的高精位数只知道比 $1e5$ 小却没有办法确定。隔一位一个 $1$ 也不方便化成 $10$ 进制啊。不过好像没有什么好办法能直接从 $2$ 进制的高精转化为 $10$ 进制的高精。(仅为思考过程)

能不能直接从 $10$ 进制的高精推过来呢？

如果是二进制表示是 $1000000....$ ，它就可以轻松地表示为 $2^n$ 然后用快速幂做了。

那么现在考虑对这个 $2$ 进制数 $×3$ 。哦不对，是 $11$ 。我们来看变成了什么。。

$11$ $110$ $1111$ $11110$ $111111$ $1111110 ......$

这就可以说是非常显然了吧。( $+1$ 或 $+2$ 变成 $10000...$ )

写出来也就是其他题解中大佬们的公式。只不过我用了这种另类思路得到。

可是有一个问题。 多项式乘法是 $n^2$ 的。即便有快速幂，它的复杂度也是 $n^2logn$ 的。

那么就写一个 $FFT$ 加速一下多项式乘法就行啦！

然后你要感谢你看到了这篇题解。如果你是那种对复杂度要求严格，认为复杂度决定一切和是否$AC$的选手，你可以少写一个$FFT$。

$n^2logn$ 中 $n^2$ 的 $n$ 是什么？是数据位数。

首先当 $n$ 为 $1e5$ 时你的 $2$ 进制数是 $1e5$ 位的。如果它变成 $10$ 进制，可以变成 $Xe4$ 级别。如果再对它压一下位直接 $1e8$ 进制，它可以变成 $Xe3$ 级别。复杂度瞬间变成$O($可过$)$。

实际上当 $n=1e5$ 时最后的答案压位后只有 $3762$ 位。

而且另外一点，普通的相乘常数可是比 $FFT$ 小了不止几倍。也就是说如果你用了 $FFT$ 去"优化"它，你反而会更慢。

$FFT$ + 小数相乘时暴力的优化 $=$ $132ms$

压位爆乘 + 输出优化 + 开小内存　$=$ $8ms$

伤感的故事。

```
#include <bits/stdc++.h>
#define rap(i,s,n) for(int i=s;i<=n;i++)
#define drap(i,n,s) for(int i=n;i>=s;i--)
#define N 5111
#define Q 100000000
#define ll long long
#define m(s,k) memset(s,k,sizeof s)
char xA[1<<16],xZ[20]; int xC=-1,xzz=0;
inline void wt_z(){fwrite(xA,1,xC+1,stdout),xC=-1;}
template<class T>inline void wt(T x,int t){
    if(xC>(1<<15)) wt_z();
    while(xZ[++xzz]=(char)(x%10+'0'),(x/=10)||(t>0)) --t;
    while(xA[++xC]=xZ[xzz],--xzz);
}
//得益于luogu的代码公开计划我可以愉快地抄大佬的快输板子了（不算抄袭吧QAQ）
using namespace std;
ll res[N],a[N],d[N];
int sz1,sz2;
int cheng(ll *a,int n,ll *b,int m){
    m(d,0); rap(i,0,n) rap(j,0,m) d[i+j]+=a[i]*b[j];
    rap(i,0,n+m) d[i+1]+=d[i]/Q,d[i]%=Q;
    int t=n+m+1; while(d[t]) d[t+1]+=d[t]/Q,d[t]%=Q,t++; t--;
    rap(i,0,t) a[i]=d[i]; return t;
}
//非常暴力又写的不是一般难看的乘
int main(){
    int n,m; scanf("%d",&m); rap(i,1,m){
        scanf("%d",&n); int t=n+1;
        m(res,0); res[0]=1; m(a,0); a[0]=2; sz1=sz2=0;
        while(t){
            if(t&1) sz1=cheng(res,sz1,a,sz2); t>>=1;
            if(t) sz2=cheng(a,sz2,a,sz2);
        }
        if(n&1) res[0]++; res[0]-=2; if(res[0]<0) res[0]+=Q,res[1]--;
        ll k=0; drap(i,sz1,0){k=k*Q+res[i]; res[i]=k/3; k%=3;}
        while(res[sz1]==0) sz1--;
        wt(res[sz1],0); drap(i,sz1-1,0) wt(res[i],7); xA[++xC]='\n'; wt_z();
    }
    return 0;
}
```
~~当我知道暴力可以过，而且快的飞起的时候，我就好像看到了岩浆里燃烧的钻石，就好像看到了3滴血跑路的盖伦,就好像看到了我被一个就是破不了防的血条里只剩下真空的妖梦反杀。~~

~~别和我提python.~~

---

## 作者：yhgalaxy (赞：14)

递推式的推导别的题解已经给出了，有一种通过简单的代数方法求解本题递推式的通项公式。

$f[0]=0, \ f[1]=1, \ f[i] = 2f[i-2]+f[i-1]+1 $

设$\ g[i] = f[i]+f[i-1], \ g[1] = 1 $

有$\ f[i] = 2g[i-1]-f[i-1]+1=1 $
$g[i] = f[i]+f[i-1]=2g[i-1]+1=2^i-1 $
$f[i] = 2^i-f[i-1]-1=f[i-2]+2^{i-1} $
$f[0] = 0,\ f[2i]=f[2i-2]+2^{2i-1}=\frac{2^{2i+1}-2}{3} $
$f[1] = 1,\ f[2i+1]=f[2i-1]+2^{2i}=\frac{2^{2i+2}-1}{3}$ 
综上$\ f[i] = \big\lfloor \frac{2^{i+1}}{3} \big\rfloor $

然后用压位高精度做快速幂即可。

---

## 作者：Marser (赞：8)

NOIP炸了之后的第一篇题解。谨以此纪念被我丢掉的省一。

观察题目，我们可以得到一个比较显然的递推式。设$F_x$表示$x$连环被拆下所需的步数，则有$$F_x = F_{x-1} + 2F_{x-2} + 1$$

~~伪~~证明如下：

显然拆$x$连环与装$x$连环互为逆操作，所需的步数相同；  
考虑拆$x$连环的过程，由规则二可以知道，最左边的环只有在只剩下它以及它右边的第一个环时可以拆下。而为了拆下这个环，必须先拆掉右边的$x-2$连环。  
拆下之后，考虑如何拆掉剩下的一个环。同样的，为了能拆下它，必须把它右边的第二个环装上，即装$x-2$连环。接下来，就可以直接拆$x-1$连环了。

推出这个式子之后其实已经可以使用压位高精计算了。但是为了减小常数，防止被卡掉，我们还要进行一些优化。  
注意到这是一个线性的三项递推式，考虑配凑求出通项。（必修五常见题型）

$F_x = F_{x-1} + 2F_{x-2} + 1$  
$F_x + F_{x-1} = 2F_{x-1} + 2F_{x-2} + 1$  
$F_x + F_{x-1} + 1 = 2F_{x-1} + 2F_{x-2} + 2$  
$F_x + F_{x-1} + 1 = 2(F_{x-1} + F_{x-2} + 1)$  
设$G_x = F_x + F_{x-1} + 1$，上面的式子就可以化为等比数列形递推式：
$$G_x = 2 \times G_{x-1} ~,x \ge 2 $$
$$G_x = 2 ~,x = 1$$

显然可以推出$G_x = 2^i$，接下来开始反解$F_x$。

由$F_x = F_{x-1} + 2F_{x-2} + 1$可得出  
$F_x = F_{x-2} + G_{x-1}$  
$F_x = F_{x-2} + 2^{x-1}$

先考虑$x$是偶数的情况：  
$F_{2x} = F_{2x-2} + 2^{2x-1}$  
$F_{2x} = 2^{2x-1} + 2^{2x-3} + \cdots + 2^1$  
运用等比数列求和公式可以得出：  
$F_{2x} = \frac{2^{2i-1} \times 4 - 2}{3} = \frac{2^{2i+1} - 2}{3}$

接下来考虑$x$是奇数的情况：  
$G_{2x+1} = F_{2x+1} + F_{2x} + 1$  
$F_{2x+1} = G_{2x+1} - F_{2x} - 1 = \frac{2^{2i+1} \times 3 + 2 - 2^{2i+1} - 3}{3}$  
$F_{2x+1} = \frac{2^{2i+2}-1}{3}$  

使用矩阵快速幂加速计算即可通过此题。

码风奇特，敬请谅解。
```cpp
#include<bits/stdc++.h>
#define reg register
typedef long long ll;
using namespace std;
const int MN=10005;
int n;
struct BigInt{
    static const int BASE=10000;
    int d[MN],len;
    inline void clear(int x=0){
        memset(d,len=0,sizeof(d));if(!x)len=1;while(x)d[len++]=x%BASE,x/=BASE;len--;
    }
    inline BigInt operator*(BigInt x){
        reg BigInt res;res.clear();
        for(reg int i=0;i<=len;i++)
            for(reg int j=0;j<=x.len;j++){
                res.d[i+j]+=d[i]*x.d[j];
                res.d[i+j+1]+=res.d[i+j]/BASE,res.d[i+j]%=BASE;
            }
        res.len=len+x.len+1;
        while(~res.len&&!res.d[res.len])res.len--;
        return res;
    }
}Ans,A;
namespace Out{
    const int _outlim=1<<20;
    char outbuf[_outlim+5];
    int cnt;
    inline void pc(char ch){
        outbuf[cnt++]=ch;
        if(cnt==_outlim)fwrite(outbuf,1,cnt,stdout),cnt=0;
    }
    inline void write(BigInt x){
    	reg bool f=0;
        if(x.d[x.len]>999)pc(x.d[x.len]/1000+'0'),f=1;x.d[x.len]%=1000;
        if(x.d[x.len]>99||f)pc(x.d[x.len]/100+'0'),f=1;x.d[x.len]%=100;
        if(x.d[x.len]>9||f)pc(x.d[x.len]/10+'0'),f=1;x.d[x.len]%=10;
        pc(x.d[x.len]+'0');
        for(reg int i=x.len-1;~i;i--){
            pc(x.d[i]/1000+'0');x.d[i]%=1000;
            pc(x.d[i]/100+'0');x.d[i]%=100;
            pc(x.d[i]/10+'0');x.d[i]%=10;
            pc(x.d[i]+'0');
        }
        pc('\n');
    }
    inline void end(){
        if(cnt)fwrite(outbuf,1,cnt,stdout),cnt=0;fclose(stdin);fclose(stdout);
    }
}
int main(){
    reg int T;scanf("%d",&T);
    while(T--){
        scanf("%d",&n);Ans.clear(1);A.clear(2);reg int b=n+1;
        while(b){if(b&1)Ans=Ans*A;A=A*A;b>>=1;}Ans.d[0]+=(n&1)-2;reg int q=0;
        for(reg int i=Ans.len;~i;i--)q=q*Ans.BASE+Ans.d[i],Ans.d[i]=q/3,q%=3;
        while(~Ans.len&&!Ans.d[Ans.len])Ans.len--;
        Out::write(Ans);
    }
    Out::end();
    return 0;
}
```

---

## 作者：da32s1da (赞：8)


如果您要copy，而且不怕变棕，请直接复制走人。
```
for i in range(int(input())):
    print(pow(2,int(input())+1)//3)
```
```
以下是da32s1da的想法。
WA!这题怎么做啊？？？
不知道。。。。
先看看样例吧，试着骗点分。
嗯。。。。
f[3]=5
f[5]=21
f[9]=341
似乎，没有什么规律。。。吗？
f[3]*3=5*3=15
f[5]*3=21*3=63
f[9]*3=341*3=1023
嗯，还是找不出规律。。。才怪
所以da32s1da很快的打出了一个ksm
```
```
#include<cstdio>
long long n,m,p,q;
int main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++){
    	scanf("%lld",&m);p=1;q=2;m++;
    	while(m){
    		if(m&1) p=(p*q);
    		q=(q*q);m>>=1;
        }
        printf("%lld\n",p/3);
    }
} 
```
然而只能得**30**分。
```
蒟蒻da32s1da：完蛋了，高精度不会。
10分钟后……
```

```
//黑科技~~~~
#include<sstream>
#include<cstdio>
#include<cmath>
using namespace std;
int n,m,v,c;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
    	scanf("%d",&m);
    	stringstream s;
        s.precision(0);
        s<<fixed<<pow(2.0L,m+1);
        string ss=s.str();
        v=ss.length();
        if(ss[0]>='3') printf("%d",(ss[0]-48)/3);
        c=(ss[0]-48)%3;
        for(int i=1;i<v;i++){
        	c=c*10+ss[i]-48;
        	printf("%d",c/3);c%=3;
        }puts("");
    }
    return 0;
}
```
这样能得**50**分！
```
这时da32s1da突然想起了高精！！！
#include<cstdio>
#include<cmath>
#include<cstring>
#define N 30200  //2^100000次方大概30100位左右
#define M 33554432  //2^25次方
using namespace std;
int n,m,t,num;
int s[N+1];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
    	scanf("%d",&m);m++;
    	memset(s,0,sizeof(s));
    	int p=m/25,j;s[N]=1;num=N;
    	//这里简化一下，一次乘2^25次方
    	while(p--){
        	for(j=num;j<=N;j++) s[j]*=M;
        	for(j=N;j>=num;j--)
        	s[j-1]+=s[j]/10,s[j]%=10;num--;
        	while(s[num]) s[num-1]=s[num]/10,s[num]%=10,num--;
        	num++; //计算位数
        }
        
    	p=1<<(m%25);  //乘上剩余
    	for(j=num;j<=N;j++) s[j]*=p;
        for(j=N;j>=num;j--)
        s[j-1]+=s[j]/10,s[j]%=10;num--;
        while(s[num]) s[num-1]=s[num]/10,s[num]%=10,num--;
        num++; //计算位数
        
        if(s[num]>=3) printf("%d",s[num]/3);
        int c=s[num]%3;
        for(j=num+1;j<=N;j++){
        	c=c*10+s[j];
        	printf("%d",c/3);c%=3;
        }puts(""); //输出
    }
    return 0;
}
```
这样就能达到**100**分啦！而且内存**1.8MB**左右！

希望以上能帮助到大家，最后…………

# 拒绝抄袭!

---

## 作者：RabbitHu (赞：6)

本题解同步发布于[胡小兔的博客](http://www.cnblogs.com/RabbitHu/p/BZOJ5300.html)，欢迎来踩。

## 题面

求n连环的最少步数，n <= 1e5。

## 题解

首先……我不会玩九连环……

通过找规律~~（其实是百度搜索）~~可知，$n$连环的最少步数是$\lfloor\frac{2^{n + 1}}{3}\rfloor$。

（实际上，九连环的步骤恰好是一个叫【格雷码】的编码方式中的$1$一直到$2^{n+1}-1$！）

然后我们要输出这个$\lfloor\frac{2^{n + 1}}{3}\rfloor$就好了。

然后我们发现——毒瘤出题人让我们写高精度。

……那就只能写咯……

用FFT做高精度乘法，封装起来，然后正常进行快速幂即可。

> ### P.S.
> 看了各位的做法，难道只有我一个人真的写的是FFT高精度嘛？！算了就当练习FFT板子了TAT

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#define enter putchar('\n')
#define space putchar(' ')
using namespace std;
typedef long long ll;
template <class T>
void read(T &x){
    char c;
    bool op = 0;
    while(c = getchar(), c < '0' || c > '9')
    if(c == '-') op = 1;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
    x = x * 10 + c - '0';
    if(op == 1) x = -x;
}
template <class T>
void write(T x){
    if(x < 0) putchar('-'), x = -x;
    if(x >= 10) write(x / 10);
    putchar('0' + x % 10);
}

const int N = 150000;
const double PI = acos(-1);
int T, x;

struct cp {
    double a, b;
    cp(){}
    cp(double x, double y): a(x), b(y){}
    cp operator + (const cp &obj) const {
	return cp(a + obj.a, b + obj.b);
    }
    cp operator - (const cp &obj) const {
	return cp(a - obj.a, b - obj.b);
    }
    cp operator * (const cp &obj) const {
	return cp(a * obj.a - b * obj.b, a * obj.b + b * obj.a);
    }
} inv[N], omg[N];

void init(int n){
    for(int i = 0; i < n; i++){
	omg[i] = cp(cos(2 * PI / n * i), sin(2 * PI / n * i));
	inv[i] = cp(omg[i].a, -omg[i].b);
    }
}
void fft(cp *a, int n, cp *omg){
    int lim = 0;
    while((1 << lim) < n) lim++;
    for(int i = 0; i < n; i++){
	int t = 0;
	for(int j = 0; j < lim; j++)
	    if(i >> j & 1) t |= 1 << (lim - j - 1);
	if(i < t) swap(a[i], a[t]);
    }
    for(int l = 2; l <= n; l <<= 1){
	int m = l / 2;
	for(cp *p = a; p != a + n; p += l)
	    for(int i = 0; i < m; i++){
		cp t = omg[n / l * i] * p[i + m];
		p[i + m] = p[i] - t;
		p[i] = p[i] + t;
	    }
    }
}

struct big {
    int g[N], len;
    big(){
	memset(g, 0, sizeof(g));
	len = 1;
    }
    big(int x){
	memset(g, 0, sizeof(g));
	len = 0;
	if(!x){
	    len = 1;
	    return;
	}
	while(x) g[len++] = x % 10, x /= 10;
    }
    void out(){
	for(int i = len - 1; i >= 0; i--)
	    printf("%d", g[i]);
	enter;
    }
    void operator /= (int x){
	int sum = 0, newlen = 0;
	for(int i = len - 1; i >= 0; i--){
	    sum = sum * 10 + g[i];
	    if(sum < x) g[i] = 0;
	    else{
		if(!newlen) newlen = i + 1;
		g[i] = sum / x;
		sum %= x;
	    }
	}
	len = max(newlen, 1);
    }
    void operator *= (const big &b){
	static cp A[N], B[N];
	int newlen = len + b.len - 1, n = 1;
	while(n < newlen) n <<= 1;
	for(int i = 0; i < n; i++){
	    A[i] = cp(i < len ? g[i] : 0, 0);
	    B[i] = cp(i < b.len ? b.g[i] : 0, 0);
	}
	init(n);
	fft(A, n, omg);
	fft(B, n, omg);
	for(int i = 0; i < n; i++)
	    A[i] = A[i] * B[i];
	fft(A, n, inv);
	for(int i = 0; i < newlen; i++)
	    g[i] = (int)floor(A[i].a / n + 0.5);
	g[len = newlen] = 0;
	for(int i = 0; i < len; i++)
	    g[i + 1] += g[i] / 10, g[i] %= 10;
	if(g[len]) len++; 
    }
} ret, a;

int main(){

    read(T);
    while(T--){
	read(x), x++;
	ret = big(1), a = big(2);
	while(x){
	    if(x & 1) ret *= a;
	    a *= a;
	    x >>= 1;
	}
	ret /= 3;
	ret.out();
    }

    return 0;
}
```

---

## 作者：y2823774827y (赞：3)

打表或仔细研究样例$\frac{2^{i+1}}{3}$

有数组$dp[i]$表拆下$i$连环的步数

四连环$(4,3,2,1)$与三连环$(3,2,1)$的区别在于最左边新加入了一个，则拆下四连环的步数=拆下两连环$(4,3,0,0)$+拆下最左边的一个$(0,3,0,0)$，此时虽然仅剩一个，但根据九连环规则，要拆下这一环：$(0,3,0,1)->(0,3,2,1)->(0,3,2,0)->(0,0,2,0)$
中间得把三连环重新装上再拆下来

我们得出：$dp[4]=dp[2]+1+dp[2]+dp[3]$

扩展到其他也是同
一做法：$dp[n]=2*dp[n-2]+1+dp[n-3]$

$1,2,5,10,21,42,85......$

$1,10,101,1010,10101,101010,1010101$

$1$和$0$是不相邻的，想到二进制乘法，让中间的$0$变成$1$
$\begin{aligned} 1010101\\×11\\1010101\\1010101~~\\11111111\\(2^{7+1}-1)/3\end{aligned}$$

$\begin{aligned} 101010\\×11\\101010\\101010~~\\1111110\\(2^{6+1}-2)/3\end{aligned}$$

扩展一下，得出答案：$$\frac{2^{i+1}}{3}$$

$n<=10^5$显然要高精，直接暴力肯定会超时，这里用$FFT$优化一下

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
typedef long long LL;
const int maxn=70000;
const double PI=acos(-1.0);
struct complex{
    double x,y;
    complex(double xx=0,double yy=0){
        x=xx,y=yy;
    }
}a[maxn],b[maxn];
complex operator + (complex x,complex y){
    return complex(x.x + y.x, x.y + y.y);
}
complex operator - (complex x,complex y){
    return complex(x.x - y.x, x.y - y.y);
}
complex operator * (complex x,complex y){
    return complex(x.x * y.x - x.y * y.y , x.y * y.x + x.x * y.y);
}
inline void FFT(complex *A,int *r,int limit,int type){
    for(int i=0;i<limit;++i)
        if(i<r[i])
            swap(A[i],A[r[i]]);
    for(int mid=1;mid<limit;mid<<=1){
        complex WN( cos(PI/mid) , type*sin(PI/mid) );
        for(int R=mid<<1,j=0;j<limit;j+=R){
            complex w(1,0);
            for(int k=0;k<mid;++k,w=w*WN){
                complex x=A[j+k],y=w*A[j+mid+k];
                A[j+k]=x+y,
                A[j+mid+k]=x-y;
            }
        }
    }
}
struct big{
    int g[maxn],len;
    big(){
        memset(g,0,sizeof(g)),
        len=1;
    }
    big(int x){
        memset(g,0,sizeof(g)),
        len=0;
        if(!x){
            len=1;
            return;
        }
        while(x){
            g[len++]=x%10,
            x/=10;
        }
    }
    void operator *=(const big &b){
        static complex A[maxn],B[maxn];
        int newlen=len+b.len,limit=1,L=0;
        while(limit<newlen)
            limit<<=1,
            ++L;
        for(int i=0;i<limit;++i)
            A[i]=complex(i<len?g[i]:0,0),
            B[i]=complex(i<b.len?b.g[i]:0,0);
        int r[20];r[0]=0;
        for(int i=0;i<limit;++i)
            r[i]=(r[i>>1]>>1)|((i&1)<<(L-1));
        FFT(A,r,limit,1),
        FFT(B,r,limit,1);
        
        for(int i=0;i<limit;++i)
            A[i]=A[i]*B[i];
            
        FFT(A,r,limit,-1);
        int ans[maxn];
        for(int i=0;i<limit;++i)
            ans[i]=(int)(A[i].x/limit+0.5);
        
        for(int i=0;i<limit;++i)
            if(ans[i]>9)
                ans[i+1]+=ans[i]/10,
                ans[i]%=10;
        
        --limit;
        while(limit>0&&ans[limit]==0)
            --limit;
        len=++limit;
        for(int i=0;i<limit;++i)
            g[i]=ans[i];
    }
    void operator /= (int x){
        int sum=0,newlen=0;
        for(int i=len-1;i>= 0;--i){
            sum=sum*10+g[i];
            if(sum<x) 
                g[i]=0;
            else{
                if(!newlen) 
                    newlen=i+1;
                g[i]=sum/x,
                sum%=x;
            }
        }
        len=max(newlen,1);
    }
    void Out(){
        for(int i=len-1;i>=0;--i)
            printf("%d",g[i]);
        printf("\n");
    }
}ret,base;
int main(){
    int T;
    scanf("%d",&T);
    while(T--){
        int n;
        scanf("%d",&n);
        ++n,
        ret=big(1),base=big(2);
        while(n){
            if(n&1)
                ret*=base;
            base*=base,
            n>>=1;
        }
        ret/=3,
        ret.Out();
    }
    return 0;
}/*
*/ 
```

---

## 作者：jklover (赞：3)

另外两篇题解中都给出了此题的通项公式,但对公式的分析过程稍略.这里我就简要说一下其中的思路与过程.(毕竟我只是个初三蒟蒻啊)


首先我们是可以通过分析题面中解四连环的思路来得到启示的.




------------

 _初始状态为1111,每步的操作如下:_ 


   _1.1101 (根据规则2,卸下第2 个环)_ 

   _2.1100 (根据规则1,卸下第1 个环)_ 

   _3.0100 (根据规则2,卸下第4 个环)_ 

   _4.0101 (根据规则1,装上第1 个环)_ 

   _5.0111 (根据规则2,装上第2 个环)_ 

   _6.0110 (根据规则1,卸下第1 个环)_ 

   _7.0010 (根据规则2,卸下第3 个环)_ 

   _8.0011 (根据规则1,装上第1 个环)_ 

   _9.0001 (根据规则2,卸下第2 个环)_ 

   _10.0000 (根据规则1,卸下第1 个环)_ 



------------
这里我们可以看到,**从第1步到第5步,实际上最终效果就变成了去解3连环.**因为将最后一个环卸下后,前面的环卸下/装上都只取决于在它前面环的状态,与最后一个环无关.所以我们就可以不管最后一个环了,问题从解4连环转化成了解3连环.


------------
至此,我们已容易想到,将解N连环的问题转化为解N-1连环,递归处理得出答案.可是,**从N连环到N-1连环,需要多少步呢?**我们只要解决了这个问题,整个问题也就解决了.


------------
#### 接下来我们解决从N环到N-1连环需要的步数.
此时,我们再去看题面中四连环的解决过程,仍看第一步至第五步.由规则2易知,为了取下第n个环,我们需要在保持第n-1个环不变的情况下(因为你动它对前面n-2个环没有影响),**将前面的n-2个环全部取下.**,即题面中第2步后的效果.
###  等等!
什么叫做将前面的n-2个环全部取下?**这不就是解n-2连环吗?**
我们再来看解掉前面n-2连环之后应该如何操作.此时已经符合了规则2的要求,我们用1步卸下第n个环,至此状态变成仅有第n-1个环在剑上,即题面中第3步后的效果.我们再看题面,可以得知接下来应该将后面的n-2连环全部装上去,就达到了卸下了第n个环,转移到n-1连环的目的.
### 此时整个过程已经明晰,即要解n连环,先解n-2连环,再下第n个环,再上n-2连环,再解n-1连环,是一个递归的过程.


------------

#### 那么我们只剩下最后一个问题,如何装上n-2连环?
**要装上n-2连环,就先将第n-3个环装上,即装上n-3连环后,装上第n-2个环,又卸下n-4连环,再上n-3连环.**
等等,这过程是不是有些眼熟?我们前面卸环的操作**"要解n连环,先解n-2连环,再下第n个环,再上n-2连环,再解n-1连环"** 跟这个上环的操作一一对应,且恰好相反!又因为上1连环和解1连环是互逆的,都只需一步,所以我们得到了一个十分关键的性质:**上n-2连环的过程与解n-2连环的过程是互逆的!**
 

------------

至此,整个问题已经解决.前面说的"再上n-2连环"的步数就等于解n-2连环的步数.再回到
#### "要解n连环,先解n-2连环,再下第n个环,再上n-2连环,再解n-1连环".的思路.
我们用f(n)来表示解n连环所需的步数,初始易得有f(1)=1,f(2)=2,递推式有**f(n)**=f(n-2)+1+f(n-2)+f(n-1)=**2f(n-2)+f(n-1)+1**.学过线代的同学在这里适加操作就可以得到f(n)的通项公式,而如果不知道通项公式的求法,自己打表找一下规律(或许)就可以得出.

f(n)=1/6 (-3 + (-1)^(1 + n) + 2^(2 + n)).


简要写出来就是**floor(2^(n+1)/3)**,接下来是高精度的实现这里就不再展开说明了.

_(PS:因为要用高精度,没有试过直接基于递推公式来做的方法,可能要炸空间,况且为了卡进时间还要用到矩阵加速,组合起来代码十分复杂)_ 


---------
Conclusion:此题来源于我国古代的一个益智游戏,不仅是最后的答案是递归的方式,解题过程中的分析也是通过递归思想,逐步解决问题(古人的智慧).


------------
PS:python大法好


import sys 

f=[0 for x in range(100010)]

if True :

    f[1]=1
    f[2]=2
    for i in range(3,100010):
        f[i]=2*f[i-2]+f[i-1]+1
    for i in range(int(input())):
        print(f[input()])
        

------------

---

## 作者：JustinRochester (赞：1)

[传送门](https://www.luogu.com.cn/problem/P4461)

---

**【分析】**
---

设 $f_n$ 表示将前 $n$ 个环时，拿下来的最少步数

不难想到，将该过程倒过来，就是放置前 $n$ 个环的最少步数

利用类似汉诺塔的思想，不难想到：

第一步是取下前 $(n-2)$ 个，然后取下第 $n$ 个，再将前 $(n-2)$ 个放回去，再将剩下的 $(n-1)$ 个取走

因此有 $f_n=f_{n-2}+1+f_{n-2}+f_{n-1}=f_{n-1}+2f_{n-2}+1$

递推边界是 $f_1=1,f_2=2$

解递推方程不难得到：$\displaystyle f_n={1\over 6}[2^{n+2}+(-1)^{n+1}-3]=\begin{cases}
{1\over 3}(2^{n+1}-1),n\&1
\\
{1\over 3}(2^{n+1}-2),n+1\&1
\end{cases}$

然后 ACM 是允许 Java 的（嘿嘿嘿）

---

**【代码】**
---

```java
import java.util.*;
import java.math.BigInteger;
public class Main{
    public static BigInteger one=BigInteger.valueOf(1), two=BigInteger.valueOf(2), three=BigInteger.valueOf(3);
    public static BigInteger pow2(int x){
        BigInteger ans=one,a=two;
        for(;x!=0;x>>=1,a=a.multiply(a))
            if((x&1)==1) ans=ans.multiply(a);
        return ans;
    }
    public static void main(String args[]){
        Scanner cin=new Scanner(System.in);
        int m=cin.nextInt(),n;
        for(int i=1;i<=m;++i){
            n=cin.nextInt();
            if((n&1)==1) System.out.println( pow2(n+1).subtract(one).divide(three) );
            else System.out.println( pow2(n+1).subtract(two).divide(three) );
        }
        cin.close();
    }
}
```

---

## 作者：Vocalise (赞：1)

一个无脑的 GF 做法。

设 $n$ 的答案为 $f_n$。

显然我们每次要先取下最后一个环才能进行后面的操作。

而且取下前 $n$ 个环的答案和加上 $n$ 个环的答案相同。

于是我们每次先取下 $n-2$ 个环，再取最后一个，再装上 $n-2$ 个环，转化为 $f_{n-1}$ 的情况。

$$ f_n = f_{n - 1} + 2f_{n - 2} + 1,n\ge 2 $$

$f_1 = 1, f_0 = 0$。

显然没有这么简单，因为 $n\le 10^5$，要写高精。

列举前若干项后发现似乎有 $f_n = 2f_{n-1} + [2\not|n]$

考虑证明。 $f_1 = 2f_0 + 1$，当 $n>1$ 时，

$2|n$，$f_n = f_{n-1} + 2f_{n-2}+1 = f_{n-1}+(f_{n-1}-1)+1$

$2\not|n$，$f_n = f_{n-1} + 2f_{n-2}+1 = f_{n-1}+f_{n-1}+1$

于是可以估算位数，汉诺塔 $h_n = 2h_{n-1}+1\ge f_n$，且 $h_n = 2^n-1$，

则位数约为 $B = \lg(2^{10^5})\approx 3\times 10^4$。

朴素递推高精 $\mathcal O(mnB)$，时间无法承受。

所以我们尝试求通项。

$$ \begin{aligned}
F(x) &= f_0x^0 + f_1x^1 + f_2x^2\cdots \\
2xF(x) &= 2f_0x^1 + 2f_1x^2 + 2f_2x^3\cdots \\
(1-2x)F(x) &= x^1 + x^3 + x^5\cdots \\
x^2(1-2x)F(x) &= x^3 + x^5 + x^7\cdots \\
(1-x^2)(1-2x)F(x) &= x \\
\end{aligned} $$

$$ F(x) = \dfrac{x}{(1-x)(1+x)(1-2x)}$$

猜测其为 $\dfrac{a}{1-x}$，$\dfrac{b}{1+x}$ 和 $\dfrac{c}{1-2x}$ 的和，$a,b,c$ 是常数。

于是可以解得 $a = -\dfrac{1}{2},b = -\dfrac{1}{6}, c = \dfrac{2}{3}$。

$$ \begin{aligned}
F(x) &= \dfrac{a}{1-x} + \dfrac{b}{1+x} + \dfrac{c}{1-2x} \\
&= \sum_{n\ge 0}-\dfrac{1}{2}x^n - \dfrac{1}{6}(-1)^nx^n + \dfrac{2}{3}2^nx^n
\end{aligned} $$

$$ f_n = \dfrac{-3-(-1)^n+2^{n+2}}{6} $$

现在要算 $2^{n+2}$。可以直接用 NTT 倍增算。

时间 $\mathcal{O}(mB\log B\log n)$。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>

const int N = 200001;
const int p = 998244353;

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
	do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
	return x * f;
}

inline int fastpow(int a,int b) {
	int res = 1;
	while(b) {
		if(b & 1) res = 1ll * res * a % p;
		a = 1ll * a * a % p;
		b >>= 1;
	}
	return res;
}

int r[N];

void NTT(int *a,int N) {
	for(int i = 0;i < N;i++) if(r[i] > i) std::swap(a[i],a[r[i]]);
	for(int n = 2, m = 1;n <= N;m = n, n <<= 1) {
		int g1 = fastpow(3,(p - 1) / n);
		for(int l = 0;l < N;l += n) {
			int g = 1;
			for(int i = l;i < l + m;i++) {
				int t1 = a[i], t2 = 1ll * a[i + m] * g % p;
				a[i] = (t1 + t2) % p;
				a[i + m] = (t1 - t2 + p) % p;
				g = 1ll * g * g1 % p;
			}
		}
	}
	return;
}

void INTT(int *a,int N) {
	NTT(a,N), std::reverse(a + 1,a + N);
	int iN = fastpow(N,p - 2);
	for(int i = 0;i < N;i++) a[i] = 1ll * a[i] * iN % p;
	return;
}

int a[N],b[N];

void Mul(int *x,int *y,int &n,int m) {
	int N = 1, l = -1; while(N <= n + m) N <<= 1, l++;
	for(int i = 0;i < N;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);
	for(int i = 0;i < n;i++) a[i] = x[i];
	for(int i = 0;i < m;i++) b[i] = y[i];
	for(int i = n;i < N;i++) a[i] = 0;
	for(int i = m;i < N;i++) b[i] = 0;
	NTT(a,N), NTT(b,N);
	for(int i = 0;i < N;i++) a[i] = 1ll * a[i] * b[i] % p;
	INTT(a,N); int v = 0; n = n + m;
	for(int i = 0;i < n;i++) {
		v += a[i];
		x[i] = v % 10, v /= 10;
		if(v && i == n - 1) n++;
	}
	while(n > 1 && !x[n - 1]) n--;
	return;
}

void Add(int *a,int n,int d) {
	int x = 0; a[0] += d;
	for(int i = 0;i < n;i++) {
		a[i] += x;
		if(a[i] < 0) a[i] += 10, x--;
		else if(a[i] > 9) a[i] -= 10, x++;
	}
}

void Div(int *a,int n,int d) {
	int x = 0;
	for(int i = n - 1;i >= 0;i--) {
		x = x * 10 + a[i];
		a[i] = x / d, x %= d;
	}
}

void print(int *a,int l) {
	while(l && !a[l]) l--;
	for(int i = l;i >= 0;i--) std::putchar(a[i] + 48);
	return;
}

int f[N],l,t[N],tl;

void Solve() {
	int n = read();
	for(int i = 1;i < N;i++) f[i] = t[i] = 0;
	f[0] = 1, t[0] = 2, l = tl = 1;
	int m = n + 2;
	while(m) {
		if(m & 1) Mul(f,t,l,tl);
		Mul(t,t,tl,tl);
		m >>= 1;
	}
	Add(f,l,-3 + ((n & 1) ? 1 : -1));
	Div(f,l,6);
	print(f,l), std::putchar('\n');
	return;
}

int main() {
	int m = read();
	while(m--) Solve();
	return 0;
}

```

---

## 作者：Ich_liebe_dich (赞：1)

## ~~这题建议自己手打压位高精度~~

### **提醒一下，这题的标签错得离谱，这题考的只是高精度。**

这一题背景用到了九连环~~我平时无聊就玩这个~~，只要是玩过九连环的人都知道怎么推公式，具体如下：

## 要上第n个环，必须要上第1~n-1个环，然后再卸下第1~n-2个环，再上第n个环，最后再上第1~n-1个环。

用人话来说，就是a[n]=a[n-1]+a[n-2]*2+1

然后这题就可以，动态规划？

```
#!/usr/bin/perl
use bigint;
<>;
$a{1}=1,$a{2}=2;
for(3..100000){
  $a{$_}=2*$a{$_-2}+2*$a{$_-1}+1;
}
print $a{$_} for <>;
```

全部TLE ~~QAQ~~，显然不现实。

仔细一看，这题的查询数据很水，m<=10

貌似直接暴力上公式都可以过了。

~~然后我就央求我旁边的数学大神帮我推公式我太难了~~

然后众所周知推出来两个公式，奇数偶数各一个，以下给出偶数公式：

```
(2**(n+1)-1)/3
```

再稍微整合一下就变成了众所周知的题解公式。

### 这题我为了节省时间直接用了Perl自带的高效率高精度乘方，建议手打一遍C++压位高精度再熟悉一下

毕竟这题难点就是高精度乘方

```
#!/usr/bin/perl
use bigint;
<>;
print 2**($_+1)/3,"\n" for <>;
```

## ~~用Python的什么鬼，Perl才是强无敌！~~

---

## 作者：Daidly (赞：1)

- 我们不妨设$K(n)$为解下$n$个圆环所需要的最少移动次数。显然，解下第一个圆环所需要的次数为$K(1)=1$（次）。当$n=2$时，必须先解下第二个圆环，再解下第一个圆环，所以，解下第二个圆环所需要的次数为$K(2)=2$（次）。

- 若要解下n个圆环，就必须要解下第$(n-2)$个圆环，需要$K(n-2)$次，然后再移动1次即可将第$n$个圆环解下，则只剩下第$(n-1)$个圆环。

- 若我们再用$k(n)$来表示前$(n-1)$个圆环都已经解下后，再解第n个圆环所需要的次数，则可以得出下面这个式子：$K(n)=K(n-2)+1+k(n-1)$。

- 接着，我们求$k(n)$的表达式。由前面显然可知，若要将第$n$个圆环解下，就必须先将第$(n-1)$个圆环套回去，需要$k(n-1)$次，再移一次，就可以将第$n$个圆环解下，再移$k(n-1)$次，就可以将第$(n-1)$个圆环解下，则得：
- $k(1)=1$且$k(n)=2k(n-1)+1$

- 由此可得：

$k(n)$=$2^2 k(n-2)+2+1$

=$2^3 k(n-3)+2^2+2+1$
    
=$...$
    
=$2^n -1$

- 所以$K(n)$=$K(n-2)+2^{n-1}$

- 因为有$K(1)$=$1$,$K(2)$=$2$所以要分类讨论。

$(1)$当n为偶数时：$K(n)$=$(2^{n+1}-2)/3$

$(2)$当n为奇数时：$K(n)$=$(2^{n+1}-1)/3$

- 然后就很简单了。

---

## 作者：ThinkofBlank (赞：0)

### 				题解 P4461 【[CQOI2018]九连环】

​	由于各位大佬已经用各种方法,将公式推得我这里便不再过多阐述,我们来谈谈本题的实现~

​	首先,我们先来看公式:$\lfloor\frac{2^{n+1}}{3}\rfloor$

​	我们知道,因为n<=1e5，所以$|2^{n+1}|$很小,而且询问也只有10,所以我们**如果能较快求出$2^{n+1}$我们再跑个高精除低精便可以通过此题了...**

​	于是现在问题转化到如何快速求$2^{n+1}$,于是,某大佬站出来刷刷刷...快速幂+FFT 对此我只能orzzzzz

​	由于我太弱,所以懒得打FFT了,但是打高精明显GG啊...这可怎么办呢？

​	其实,我们只需要稍加优化即可:**我们可以使用低精乘法来代替部分的高精乘法**,从而使得代码加速最后原地起飞！

​	不会低精优化高精的可以去[这里](https://www.luogu.org/blog/KingofNight/kuai-su-ji-suan-gao-jing-sheng-di-jing-di-jing-you-hua-gao-jing)学习~~看故事~~

​	下面给出代码:

```cpp
//#pragma GCC optimize(3,"Ofast","inline")//手动O3优化
//#pragma GCC target("sse","sse2","sse3","sse4","avx","avx2","popcnt")
#include<bits/stdc++.h>
using namespace std;
const unsigned long long T=5e17;
inline string operator*(string x,unsigned long long y){//高精乘低精 
	int len=x.size();
	unsigned long long a[100000];
	for(int i=0;i<len;++i){
		a[i]=x[len-i-1]-'0';
		a[i]*=y;
	}
	for(int i=0;i<len;++i){
		if(a[i]>9){
			if(i==len-1){
				a[len++]=0;
			}
			a[i+1]+=a[i]/10;
			a[i]%=10;
		}
	}
	while(len&&!a[len-1]){
		len--;
	}
	string ans="";
	for(int i=len-1;~i;--i){
		ans+=a[i]+'0';
	}
	return ans;
}
inline string operator/(string x,int y){//高精除低精 
	int len=x.size(),yu=0;
	bool flag=0;
	string res="";
	for(int i=0;i<len;++i){
		yu=yu*10+x[i]-'0';
		if(flag){
			res+=yu/3+'0';
			yu%=3;
			continue;
		}
		if(yu>=3){
			flag=1;
			res+=yu/3+'0';
			yu%=3;
		}
	}
	return res;
}
inline string fksc(int x,int y){//低精乘法优化高精乘法 
	unsigned long long ji=1;
	string res="1";
	while(y--){
		ji*=x;
		if(ji<=T){
			continue; 
		}
		res=res*ji;
		ji=1;
	}
	res=res*ji;
	return res;
}
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		int n;
		scanf("%d",&n);
		string res=fksc(2,n+1);
		cout<<res/3<<endl;
	}
	return 0;
}


```
O(1)<<代码的复杂度=O(可过)<<O(nm|s|)

当然,为了追求较快速度,可以先输入询问,然后进行一次低精优化高精处理完所有情况,然后再回答~


---


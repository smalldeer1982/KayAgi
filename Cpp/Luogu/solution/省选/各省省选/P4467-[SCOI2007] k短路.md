# [SCOI2007] k短路

## 题目描述

有 $n$ 个城市和 $m$ 条单向道路，城市编号为 $1$ 到 $n$。每条道路连接两个不同的城市，且任意两条道路要么起点不同要么终点不同，因此 $n$ 和 $m$ 满足$m \le n(n-1)$。

给定两个城市 $a$ 和 $b$，可以给 $a$ 到 $b$ 的所有简单路（所有城市最多经过一次，包括起点和终点）排序：先按长度从小到大排序，长度相同时按照字典序从小到大排序。你的任务是求出 $a$ 到 $b$ 的第 $k$ 短路。


## 说明/提示

第一个例子有 $5$ 个城市，所有可能出现的道路均存在。从城市 $1$ 到城市 $5$ 一共有 $5$ 条简单路，排序如下：

![](https://cdn.luogu.com.cn/upload/pic/17706.png)

- $20\%$ 的数据满足：$n\leq 5$；
- $40\%$ 的数据满足：$n\leq 30$；
- $100\%$ 的数据满足：$2\leq n\leq 50$，$1\leq k\leq 200$，$1\le l\le 10^4$。

## 样例 #1

### 输入

```
5 20 10 1 5
1 2 1
1 3 2
1 4 1
1 5 3
2 1 1
2 3 1
2 4 2
2 5 2
3 1 1
3 2 2
3 4 1
3 5 1
4 1 1
4 2 1
4 3 1
4 5 2
5 1 1
5 2 1
5 3 1
5 4 1```

### 输出

```
1-2-4-3-5```

## 样例 #2

### 输入

```
4 6 1 1 4
2 4 2
1 3 2
1 2 1
1 4 3
2 3 1
3 4 1```

### 输出

```
1-2-3-4```

## 样例 #3

### 输入

```
3 3 5 1 3
1 2 1
2 3 1
1 3 1```

### 输出

```
No```

# 题解

## 作者：约瑟夫用脑玩 (赞：68)

请求撤下所有“A Star”的题解，因为都不是正解而是乱搞，对思考没有任何意义，而且会误导其他人认为“A Star”可做或是直接觉得这就是正解。

讽刺的是现有题解都是“A Star”。

对以上叙述进行补充：“A Star”的复杂度是错的，而且一定是可以被卡掉的，如果是打表的不必说，如果是剪枝跑过的是数据水了。

这道题的正解也颇为简单，不要把07年的题想太复杂，做法就是真·k短路。

最短路大家都会吧，我们先考虑如何求出次短路。

经典的做法是把最短路上的每一条边都尝试删掉后跑最短路，再取其中的最小，原因显然，因为考虑了所有除了最短路的路径。

事实上这样并不利于我们进行扩展，因为每次考虑的路径中是有重复的。

考虑稍加限制但仍是正确的次短路做法：

- 我们钦定已经走了当前最短路的一个前缀。

- 限制下一条边不能走最短路走的那条边。

- 然后求出从这个前缀的最后一个点到终点的最短路。

- 同样的取其中的最小。

这个做法的正确性事实上是基于我们钦定除去最短路，然后求出来的最短路就是次短路了。

但我们还有一个重要的事实需要说明，就是我们只取了一部分最短路来取其中的最小，而其他路径都没有直接进行比较。

原因是这些路径一定可以通过截取某个前缀说明不可能是当前最短路的，请读者多作思考，后面扩展有用到这一点，故后文不会再做重复。

这个做法有一个最重要的好处是这些路径并不重复，更重要的，我们直接将这个方法扩展到k短路这道题就做完了，具体做法如下。

- 初始求出最短路。

  以下的思路是：每次去除当前的最短路，快速找到下一个最短路，直到求出k短路。

- 我们维护可能的下一个最短路的集合，删掉当前最短路后会新增一些路径可能成为下一个最短路。

  这些路径就是上述所说的方法求得，即钦定前缀，限制一条边，求最短路。
  
- 为了不和已有的可能的下一个最短路集合中的路径重复，当前钦定的前缀应不少于之前已有钦定的前缀。

正确性前面大概都说了，如果还有不清楚的，~~可能是我觉得不好说就略过了~~，还请读者多培养自行思考的能力，或是直接来找我问也行。

给一份复杂度正确且能通过这道题的[代码](https://www.luogu.com.cn/paste/f4l59juj)。（长得不好看可以自行调整）

补充复杂度及细节：

- 时间复杂度 $O(nk\times n^2)$，前面的 $nk$ 是总共涉及到的路径条数，$n^2$ 是最短路时间。

- 空间复杂度是 $O(nk\times (n/k/n^2))$，前面的还是涉及到的路径条数，后面根据是否精细实现来看，我比较懒所以实现的是 $O(k)$ 的，而且实际常数应该不大。

- 细节的话首先要注意字典序。

- 然后还要注意限制边可能限制多条。

- 最后建议用 $O(n^2)$ 的最短路，因为 $O(m\log m=n^2\log)$ 又难写又慢。

- 哦还有堆的 `<` 是反的大家应该都知道吧。

- 最后吐槽一下其实可以把k条最短路都输出出来的。。。

---

## 作者：5ab_juruo (赞：21)

首先二分答案 $mid$，即最终路径的长度。考虑如何判断长度 $\le lim$ 的路径数和 $k$ 的大小关系。

枚举一个路径的前缀 $p_1,p_2,\cdots,p_k$。并从小到大枚举 $p_{k+1}$ 可能的值。对于一种情况，如果 ban 掉 $p_1,p_2,\cdots,p_k$ 以后，已有的路径长度加上 $p_{k+1}$ 到 $t$ 的最短路 $\le lim$，这个 $p_{k+1}$ 就是合法的。一直枚举直到 $p_x=t$ 为止，计入答案。

二分出最终路径的长度后，再跑一次搜索即可得出答案。

### 复杂度分析

假设当前站在 $p_k$，从 $t$ 开始在反图上跑最短路，如果存在方案，则存在至少一个 $x$ 满足存在边 $(p_k,x)$ 且 $dis(x,t)+dis(p_k,x)\le lim$。在每一次最短路都能找到一个合法方案的前提下，一条路径最多需要 $n$ 次最短路。

每一次要搜 $k$ 条路径，使用 $\mathcal{O}(n^2)$ 的 dijkstra，一次二分的复杂度是 $\mathcal{O}(n^3k)$。所以整体复杂度是 $\mathcal{O}(n^3k\log l)$，上限非常宽松，可以通过。

要注意在搜索的时候剪枝，即搜出来的合法路径不能超过 $k$ 条，否则复杂度就没有保证。

### Code

```cpp
#include <cstdio>
#include <vector>
#include <cstring>
using namespace std;

typedef long long ll;
const int max_n = 50, max_m = (max_n - 1) * max_n, max_k = 500, max_w = 10000, INF = 0x3f3f3f3f;

int g[max_n][max_n], rg[max_n][max_n], dis[max_n], fans[max_n], fl, scnt, gcnt, n, k, t;
bool chs[max_n], vis[max_n];

void dij(int st)
{
	memcpy(vis, chs, sizeof vis);
	memset(dis, 0x3f, sizeof dis);
	dis[st] = 0;
	
	for (int i = 0, mn, mnp; i < n; i++)
	{
		mn = INF, mnp = -1;
		for (int j = 0; j < n; j++)
			if (!vis[j] && mn > dis[j])
				mn = dis[j], mnp = j;
		if (mnp == -1)
			break;
		
		vis[mnp] = true;
		for (int j = 0; j < n; j++)
			if (dis[j] > dis[mnp] + rg[mnp][j])
				dis[j] = dis[mnp] + rg[mnp][j];
	}
}

bool solve_nrc(int nxt, int lim)
{
	if (nxt == t)
		return ++scnt >= k;
	
	dij(t);
	vector<int> res(dis, dis + n);
	
	chs[nxt] = true;
	
	for (int i = 0; i < n; i++)
		if (!chs[i] && lim >= g[nxt][i] + res[i])
			if (solve_nrc(i, lim - g[nxt][i]))
				return true;
	
	return chs[nxt] = false;
}

bool solve(int id, int nxt, int lim)
{
	if (nxt == t)
	{
		fans[id++] = nxt;
		if (!lim)
		{
			fl = id;
			gcnt--;
		}
		return !gcnt;
	}
	
	dij(t);
	vector<int> res(dis, dis + n);
	
	fans[id++] = nxt;
	chs[nxt] = true;
	
	for (int i = 0; i < n; i++)
		if (!chs[i] && lim >= g[nxt][i] + res[i])
			if (solve(id, i, lim - g[nxt][i]))
				return true;
	
	return chs[nxt] = false;
}

signed main()
{
	memset(g, 0x3f, sizeof g);
	memset(rg, 0x3f, sizeof rg);
	
	int m, s;
	
	scanf("%d%d%d%d%d", &n, &m, &k, &s, &t);
	for (int i = 0, x, y; i < m; i++)
	{
		scanf("%d%d", &x, &y);
		x--, y--;
		scanf("%d", &g[x][y]);
		rg[y][x] = g[x][y];
	}
	s--, t--;
	
	int l = 0, r = 1e9, mid, ans = -1;
	while (l < r)
	{
		mid = (l + r) >> 1;
		scnt = 0;
		memset(chs, false, sizeof chs);
		
		if (solve_nrc(s, mid))
			r = mid;
		else
			ans = mid, l = mid + 1, gcnt = k - scnt;
	}
	
	memset(chs, false, sizeof chs);
	solve(0, s, ans + 1);
	if (gcnt)
	{
		puts("No");
		return 0;
	}
	
	for (int i = 0; i < fl; i++)
		printf("%d%c", fans[i] + 1, "-\n"[i == fl - 1]);
	
	return 0;
}
```

---

## 作者：STDLRZ (赞：15)

### 前言

Astar 又回来（活过来）啦！

先别急着说，Astar 肯定会被卡掉的啊，不可能过的。

来，先读完你再说。

估计有 **99.9%** 的可能不会被卡掉，如果被卡掉的话请在评论区留言或私信。

本文有一些~~非常巧妙~~的变换可以转成普通模型的时间复杂度。

注意：本题的证明会涉及到 dijkstra 的**算法本质**，所以若还没有了解（只会打模板的），请先去了解。

### 普通的 Astar 做法

很多人就是没认真看题，然后随便看了看，发现：这不就是 $K$ 短路吗？

不不不。这道题还多了一个限制：**每一个点只能走一次，且输出路径要按照字典序输出**。

于是有一些人便在这个代码上面改了改，就提交了上去。

学过 A* 算法的你肯定知道 A* 的估价函数是 $f(i)=g(i)+h(i)$，其中 $g(i)$ 是从起点 $s$ 到 $i$ 的路径长度，而 $h(i)$ 是从点 $i$ 到终点 $t$ 的**预估路径长度**。

也就是说，A* 算法的时间复杂度优劣就看**预估函数的质量和消耗的时间了**。

在没有前面的每一个点只能走一次这个条件的情况下，A* 的时间复杂度最坏为 $\mathcal O(kn \log n)$。

可是，如果加上这个条件，然后再套用以前的 A* 算法，你会发现，你的预估函数 $h(i)$ 和真实的最短路径函数 $true(i)$ 差了非常多。

这样的话，可以构造一组数据使得你的程序出现各种奇怪的错误。

先放这个方法的代码：[错误方法的代码。](https://www.luogu.com.cn/paste/6frmfsr9)

我们来看到提交记录：

![](https://cdn.luogu.com.cn/upload/image_hosting/vfty12hv.png)

发现存在一组数据能够将我们 Hack 掉。

考虑其他方法：我们可不可以用预处理出从 $t \to i$ 的最短路，使得这条路径上没有任何一个点是重复的吗？

显然，Hack 方法与上面一致，让你尽可能的经过环或者是尽可能经过重复的边即可。

那我们该怎么办呢？设计不出来一个好的预估算法，我们就做不出来这道题了。

这个时候，我们就需要跳出平常的思维了。

### 不寻常的思维

发现如果时间复杂度是 $\mathcal O(kn \log n)$，运算量大概只有 $3000000$（乘上字符串比较的常数），有点太少了。

考虑能否可以**不进行预处理**，直接需要什么就**计算什么**即可。

这样子的话，我们就可以设计出一个函数，求出从终点开始，**不经过哪些点**且不重复经过点的最短路。

时间复杂度就是平常的，$\mathcal O(n \log n)$，当然还会更短（因为有很多点无法经过）。

然后，我们可以对于每一个点在扩展的时候都做一次这个函数求出我们需要的信息，时间复杂度为 $\mathcal O(kn^2 \log n^2)$，化简之后就是 $\mathcal O(pkn^2 \log n)$，$p$ 是字符串比较的常数。

能通过吗？大概计算一下计算量最坏为 $1.5 \times 10^8$，且**还跑不满**，可以通过此题。

我们来试图证明一下这个算法的正确性（当然，我并不会严谨的证明）。

首先，我们求一般模型的 $k$ 短路的最坏时间复杂度为 $\mathcal O(kn \log n)$。

发掘一下一般模型（普通 $K$ 短路）用 A* 求解有哪一些性质：

- 首先，预处理出的从终点 $t$ 到某一个点 $i$ 的最短路是**实际可行的**。
- 预处理的最短路是最短的，貌似是一句废话。
- 所有结点的子结点的搜索代价值 $V>0$。

首先，显然的，第 $3$ 条肯定满足。

我们是在**实际需求**的情况下去求解最短路的，也就是说求出来的最短路肯定是可以和当前的路径接上去的（根据前面的定义得出）。

所以第 $1$ 条满足，当然第 $2$ 条是满足的（不是预处理的，是实时计算的）。

所以该算法的时间复杂度为 $\mathcal O(kn^2 \log n)$。

本题就做完了，我会在结尾放上代码。

### 证明部分

#### Part 1

首先，考虑一个点 $z$ 的最短路如何更新。

假设有一条当前到 $x$ 的最短路径 $A$ 和一条到 $x$ 的次短路径 $B$（不严格的）。

然后，假设 $A$ 路径经过了的点与 $B$ 路径经过的点不一样（一样的话就不用证明了）。

假设 $x \ne z$。

显然，分讨几种情况：

1. 点 $z$ 不在 $A,B$ 任何一条路径当中。
2. 点 $z$ 在 $A$ 路径中，不在 $B$ 路径中。
3. 点 $z$ 不在 $A$ 路径中，但在 $B$ 路径中。
4. 点 $z$ 在 $A,B$ 两条路径当中。

显然，对于第一种情况，显然成立。

第二种情况，显然，$B$ 路径已经比 $A$ 长了，肯定也成立。

第三种情况，根据 dijkstra 的算法流程，若存在一条更短的路径从 $A$ 路径的终点 $x$ 继续延伸到 $z$ 的话，那么就不会先更新 $z$ 这个点。

但是，因为 $z$ 在 $B$ 路径中且**不是终点**，而且延伸出了 $B$ 路径的后半部分，所以可以判断出 $z$ 的最短路**已经确定**，所以无法用 $A$ 路径更新 $z$，但是 $B$ 路径已经更新了 $z$。

我们在设计这个算法的时候，只是说点 $x$ 只管最短路径是什么，不管其他的次短路。没有说在遍历 $z$ 点的时候，$B$ 路径不能到 $z$ 点去更新啊！再说，$z$ 点确定的时候都还没有 $A$ 路径呢！

所以，也成立。

第四种情况，直接用 $A$ 或 $B$ 路径从起点 $s$ 到 $z$ 的最短路去更新即可。显然也成立。

所以，证毕，只需保留最短路径即可。

### 常数优化

上面的常数确实是有一点不堪了，我们来尝试优化一下常数。

但是，我们就需要多证一个东西。

### 证明：最短路不会走环路

题目已经说了，是**正权图，不可能存在负环**。

所以，你只要走了一遍环，那么你走的路程就会更长。

若我们从 $x$ 走到了 $x$（绕了一个环），再从 $x$ 走到了终点 $t$，不如直接 $x \to t$，这个地方的证明比较简单，若还无法理解，建议先学习最短路的算法核心部分。

但是注意：$K$ 短路是**有可能走环**的。

他有可能会在先前路径上多走几个环，来使得该长度不等于最短路径长度但是又只多一点的这种效果。

这就是说为什么 $K$ 短路需要判断是否走了重复的点的原因。

代码如下：[正解代码。](https://www.luogu.com.cn/paste/zyiwf58q)

---

## 作者：DAMDAM (赞：10)

事实上这道题 A Star 标签具有很大的误导性，因为此题要求了必须走简单路径。剪枝后 A Star 在考场上确实有其用处，但不利于完成这道题目完整的练习。

重新思考：通常情况下完成简单路径非严格次短路的问题，需要使用这样的算法，即：每次删除掉一条在最短路上的边，之后再跑最短路。

这样的做法可以保证简单路径（似乎指的不是同种简单路径），也可以算出非严格次短路，但我们发现这样的话不方便算出非严格 $k$ 短路（似乎无法保证其正确性），时间复杂度也偏大。

（下文中约定 $k$ 短路直接代指非严格 $k$ 短路。）

对此，我们更换其次短路实现方式，即：

1. 假定已经走完原本的一个最短路 $\xi$ 前缀 $\epsilon$ 到达点 $u$，原本最短路的下一条边为 $e \gets(u,v)$。

2. 标记不能走边 $e$ 后，计算从 $u$ 开始到 $t$ 的最短路 $\xi'_i$（无法到达终点 $t$ 则直接到步骤 3），并记录其路径。

3. 按照原先最短路走到点 $v$，重复上述扩展，直到我们已经将前缀 $\epsilon$ 扩展到终点 $t$。

4. 扩展完毕后，其中最短的 $\xi'_i$ 就是我们的次短路。

这样做是因为在正权图 $G$ 上，删去最短路的那条边就会得到非严格次短路。

事实上因为我们已走前缀 $\epsilon$，保证了我们不会走不可能是当前最短路的路，更不会走重复路径。

这个算法可以直接被扩展到 $k$ 短路，方法如下。

1. 首先算出初始最短路 $\Xi$ 及其路径。

2. 不妨使用优先队列 $q$ 保存最短路 $\Xi$。

3. 取出 $q$ 中最小值 $\xi$，$\xi$ 出队后对其执行刚才我们的扩展的 1-3 步。

4. 完成扩展后将刚才算出的所有 $\xi'$ 全部放入优先队列 $q$ 中排序处理。

5. 重复 $3\sim 4$ 步，直到 $q$ 已经为空或者已经重复了 $k-1$ 次。此时若 $q$ 为空，则并不存在 $k$ 短路，否则输出 $k$ 短路（即 $q$ 中保存的最小值）。

注意到

- 这样做的时间复杂度是 $O(n^{3}k)$ 的，因为计算了 $O(nk)$ 的路径数，并算了 $O(n^2)$ 的最短路。

- 在题目已经明显暗示 $O(m)$ 趋近于 $O(n^2)$ 的情况下，应使用 $O(n^2)$ 的最短路算法。

- 到算法的后面，可以发现我们标记不能走的边 $e_i$ 有多条。

- 之所以要记录路径，是因为要保证按照字典序进行路径的排序。

附上一份代码，因为只看算法流程很可能无法理解算法的实现。

```cpp
#include<cstdio>
#include<vector>
#include<ext/pb_ds/priority_queue.hpp>
#include<bitset>
#include<stack>
#include<cstring>
namespace Use {
	using std::vector;
	using std::min;
	using std::max;
	using __gnu_pbds ::priority_queue;
	using std::bitset;
	using std::stack;
	bool operator <(const vector<int>&a, const vector<int>&b) {
		unsigned sx = a.size(), sy = b.size(), siz = min(sx, sy);
		for (unsigned i = 0; i < siz; ++i) 
			if (a[i] > b[i]) return 0;
			else if (a[i] < b[i]) return 1;
		return sx < sy;
	}
	bool operator >(const vector<int>&a, const vector<int>&b) {
		unsigned sx = a.size(), sy = b.size(), siz = min(sx, sy);
		for (unsigned i = 0; i < siz; ++i) 
			if (a[i] > b[i]) return 1;
			else if (a[i] < b[i]) return 0;
		return sx > sy;
	}//保证字典序的途径
}
using namespace Use;
typedef long long ll;
const int maxn = 55, maxm = 2505, inf = 0x3f3f3f3f;
struct Edge {
	int to, dis, next;
} edge[maxm];

int head[maxn], len;
inline void insert(const int &u, const int &v, const int &w) {
	edge[++len] = {v, w, head[u]}, head[u] = len;
}

int n, dis[maxn], to;
bitset<maxn>onTheSP;//onTheSP[u] = 1 表示点 u 在最短路上
bitset<maxn>vis;//vis[u] = 1 表示在求最短路时 u 在 close 表上
bitset<maxm>isErased;//isErased[i] = 1 表示有向边 i 被删除了
stack<int>s;// 算出最短路时经过的点的栈，满足 LIFO，辅助求最短路路径
struct Path {
	int start;//路径的起始点
    int len;//当前将算出的最短路长度
    int lastplace;//已经走过的属于前缀的点个数
    int lastlen;//已经走过的前缀的长
	vector<int>path;//当前将算出的最短路路径
    vector<int>erasedEdges;//已经被删去的边
	Path (const int &_s = 0) : start(_s), len(0), lastplace(0), lastlen(0) {
		path.clear(), erasedEdges.clear();
	}
	void Init(const int &_s)  {
		start = _s, len = lastplace = lastlen = 0, path.clear(), erasedEdges.clear();
	}
	bool operator <(const Path &b) const & {
		return len == b.len ? path > b.path : len > b.len;
	}//堆使得 < 反向
	bool Dijkstra() {
		for (int i = 1; i <= n; ++i) dis[i] = inf;//路径初始
		isErased.reset();
		onTheSP.reset();
		vis.reset();
		dis[start] = 0;
		for (int i = 0, k = lastplace = path.size(); i < k; ++i) vis[path[i]] = 1;
		for (int i : erasedEdges) isErased[i] = 1;
		for (; !s.empty(); s.pop());
		for (int __ = 1, u, w; __ <= n; ++__) {//跑 Dijkstra
			u = 0;
			w = inf;
			for (int i = 1; i <= n; ++i) if (!vis[i] && w > dis[i]) w = dis[i], u = i;
			if (!u || w == inf) break;
			vis[u] = 1;
			s.push(u);
			for (int i = head[u], v, d; i; i = edge[i].next)
				if (!isErased[i] && dis[v = edge[i].to] > (d = w + edge[i].dis))
					dis[v] = d;
		}
		if (!vis[to] || dis[to] == inf) return 0;// 判断从点 start 开始能不能到达终点 to
		for (onTheSP[to] = 1; !s.empty(); s.pop()) //找到全部的在当前最短路上的点
			for (int u = s.top(), i = head[u], w = dis[u], v, d; i; i = edge[i].next)
				if (!isErased[i] && onTheSP[v = edge[i].to] && dis[v] == (d = w + edge[i].dis)) {
					onTheSP[u] = 1;//通过判断能否松弛下一条边判断是否在最短路 
					break;
				}
		for (int u = start, w; u != to; ) {
			path.emplace_back(u), w = dis[u];
			for (int i = head[u], v = (u = n + 1, 0); i; i = edge[i].next)
				if (!isErased[i] && onTheSP[v = edge[i].to] && dis[v] == w + edge[i].dis)
					u = min(u, v);//保证字典序 
		}
		path.emplace_back(to);
        len = lastlen + dis[to];//合并之前的路径前缀
		return 1;
	}
	void Write() {
		for (int u : path) printf("%d%c", u, u == to ? 10 : '-');
	}
} U, V;

int k, start;
priority_queue<Path>h;
void kthShortestPath() {
	if ((U = {start}).Dijkstra()) h.push(U);
	for (int siz, u, v, w, e; !h.empty() && --k; ) {
		U = h.top();
        h.pop();
        siz = U.path.size() - 1;//减掉 1 保证不走到终点 to
        w = U.lastlen;//直接从上一次走到的前缀的最后点开始走
		for (int p = U.lastplace/*同理*/; p < siz; ++p) {
			u = U.path[p];
			v = U.path[p + 1];
			for (e = head[u]; e; e = edge[e].next) if (edge[e].to == v) break;//取出边 e
			V.Init(u);//使路径以点 u 为起点
			V.erasedEdges = U.erasedEdges;//加入已经不能走的边 
			V.erasedEdges.emplace_back(e);//去除边 e
			V.lastlen = w;//记录已走路径前缀
			w += edge[e].dis;//之后路径前缀长增加了 edge[e].dis
			for (int i = 0; i < p; ++i) V.path.emplace_back(U.path[i]);//加入已走的点
			if (V.Dijkstra()) h.push(V);//在这些条件下，试图扩展路径并入队
		}
	}
	if (h.empty()) printf("No");
	else U = h.top(), U.Write();
}

int main() {
	int m;
	scanf("%d%d%d%d%d", &n, &m, &k, &start, &to);
	for (int u, v, w; m; --m) scanf("%d%d%d", &u, &v, &w), insert(u, v, w);
	kthShortestPath();
	return 0;
}
```

---


# [HAOI2018] 反色游戏

## 题目描述

小 C 和小 G 经常在一起研究搏弈论问题，有一天他们想到了这样一个游戏——

有一张 $n$ 个点 $m$ 条边的无向图，初始时每个节点有一个颜色，要么是黑色，要么是白色。

现在他们对于每条边做出一次抉择：要么将这条边连接的两个节点都反色（黑变白，白变黑），要么不作处理。

他们想把所有节点都变为白色，于是他们想知道在所有 $2^m$ 种可能的决策中，有多少种方案能达成这个目标。

然而，小 G 认为这个问题太水了，于是他还想知道，对于第 $i$ 个点，在删去这个点及与它相连的边后，新的答案是多少。

由于答案可能很大，你只需要输出答案对 $10^9+7$ 取模后的结果。

## 说明/提示

对于所有数据，有 $1\le T\le l0^5,1\le n,m\le10^5,1\le u,v\le n$，且给定的无向图没有重边和自环。

![](https://cdn.luogu.com.cn/upload/pic/18145.png)

*[Source: HAOI2018 Day 1 T2]*

## 样例 #1

### 输入

```
2
5 5
1 2
2 3
3 4
2 4
3 5
00000
5 4
1 2
2 3
2 4
2 5
11111```

### 输出

```
2 2 1 1 1 2
0 1 0 1 1 1```

# 题解

## 作者：dsidsi (赞：6)

这题的部分分可以用高斯消元解异或方程组解决。即

$$\oplus_{e\in edge_u}x_e=col_u$$

$edge_u$表示与$u$相邻的边。

很容易想到，答案就是$2^{自由元的数量}$，也就是要求矩阵的秩($=$m-自由元数)。对于每一个联通块，我们能选出的线性极大无关组为$n-1$(因为确定了$n-1$个点时，剩下的那个点一定确定)。所以矩阵的秩为$n-p$，自由元的数量为$m-n+p$。答案为$2^{m-n+p}$。对于每一个点的答案则写个$tarjan$求连通性即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1000005, mod = 1e9 + 7;

int pow2[maxn];
int n, m;

struct edge
{
	int to, next;
} e[maxn];
int h[maxn], tot;

char S[maxn];
int dfn[maxn], low[maxn], sz[maxn], bel[maxn], flag[maxn], sub[maxn], cut[maxn], deg[maxn], now, Time;

inline int gi()
{
	char c = getchar();
	while (c < '0' || c > '9') c = getchar();
	int sum = 0;
	while ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();
	return sum;
}

inline void add(int u, int v)
{
	e[++tot] = (edge) {v, h[u]}; h[u] = tot; ++deg[u];
	e[++tot] = (edge) {u, h[v]}; h[v] = tot; ++deg[v];
}

void tarjan(int u, int fa = 0)
{
	low[u] = dfn[u] = ++Time;
	flag[u] = 1; sz[u] = S[u] == '1';
	bel[u] = now;
	for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
		if (!dfn[v]) {
			tarjan(v, u);
			sz[u] += sz[v];
			if (low[v] >= dfn[u]) {
				++cut[u]; flag[u] &= (sz[v] & 1) == 0;
				sub[u] += sz[v];
			} else low[u] = min(low[u], low[v]);
		} else if (v != fa) low[u] = min(low[u], dfn[v]);
	if (!fa) --cut[u];
}

int main()
{
	pow2[0] = 1;
	for (int i = 1; i <= 100000; ++i) pow2[i] = pow2[i - 1] * 2 % mod;

	int T = gi();
	while (T--) {
		n = gi(); m = gi();
		memset(sz + 1, 0, sizeof(int) * n);
		memset(deg + 1, 0, sizeof(int) * n);
		memset(sub + 1, 0, sizeof(int) * n);
		memset(cut + 1, 0, sizeof(int) * n);
		memset(h + 1, 0, sizeof(int) * n); tot = 0;
		memset(dfn + 1, 0, sizeof(int) * n); Time = 0;
		for (int i = 1; i <= m; ++i) add(gi(), gi());
		scanf("%s", S + 1);

		int cnt = 0, cnt_odd = 0;
		for (int i = 1; i <= n; ++i)
			if (!dfn[i]) {
				now = i;
				tarjan(i); ++cnt;
				cnt_odd += sz[i] & 1;
			}

		int ans = m - n + cnt;
		printf("%d", cnt_odd ? 0 : pow2[ans]);
		for (int i = 1; i <= n; ++i) {
			if (!deg[i]) printf(" %d", cnt_odd - sz[i] == 0 ? pow2[ans] : 0);
			else {
				if (flag[i] && (((sz[bel[i]] - (S[i] == '1') - sub[i]) & 1) == 0) && cnt_odd - (sz[bel[i]] & 1) == 0)
					printf(" %d", pow2[ans - deg[i] + 1 + cut[i]]);
				else printf(" 0");
			}
		}
		puts("");
	}
	
	return 0;
}
```

---

## 作者：Soulist (赞：5)


先考虑一个经典题，给定一棵树，有的点要求度数为奇数，有的为偶数，求一个合法方案。

我们发现每个叶子节点都会有一个父亲来调整其度数，所以对于每个叶子节点判断其到其父亲的边能否保留即可。

换而言之只要不存在奇数个度数要求为奇数的点那么总能构成出来一个合法解，且这个合法解固定。

考虑本题做法，我们随便搞出一棵生成树，那么只要不存在两个点度数要求为奇数，那么外部的边无论怎么选都可以视为上述子问题，所以总能够存在一个合法解。

所以此时的答案为 $2^{m+1-n}$ 

现在考虑删点之后怎么做。

容易发现删点之后可能会破坏连通性。对于可能的多个联通块，我们需要对于每个联通块计算答案。

对原图建立广义圆方树，那么删除一个点之后会有其连接的方点的边都会被破坏（因为此点是两者之间的割点）设点 $i$ 的度数为 $x$，那么删除之后剩余的边数为 $m-x$，此时答案为 $2^{(m-x)+cnt-(n-1)}$，其中 $cnt$ 为联通块数量，即其在圆方树上的出度。

那么只需要判断每个联通块内需要度数为奇数的点时候为奇数即可，这个可以直接在广义圆方树上统计，复杂度 $\mathcal O(n+m)$

---

## 作者：AzusaCat (赞：4)

给你一张 $n$ 个点 $m$ 条边的无向图，每个点有黑白两种颜色的一种，对于每条边，你可以选择同时反转与其相连的两个点的颜色或者不操作。问原图和对于删掉任何一个点和与其相邻的边后形成的图，有多少种选择边的方案使得最后所有点的颜色都是白色。$n,m\leqslant 10^5$，$T\leqslant 5$。

多测是坏文明！铃太坏了！（恼

先不考虑删除点的情况。我们对每个连通块分别考虑。注意到每次操作不会更改黑点个数的奇偶性，所以对于某个连通块，如果其中有奇数个黑点，那么答案就是 $0$。否则我们考虑随便找出一棵生成树，我们发现无论非树边怎么选择，总有唯一的一种选择树边的方案使得最后都是白色，那么这个连通块的贡献就是 $2$ 的非树边个数次方。所以假设原图有 $k$ 个连通块，不难得到若合法，方案数为 $2^{m-n+k}$。

现在我们考虑删点。考虑删掉某个点后对答案的影响：如果新形成了含奇数个黑点的连通块，答案为 $0$，否则还有可能会增加连通块的个数。

我们考虑对原图建立圆方树，我们发现有很好的性质：删掉某个点后会形成新的连通块的数量恰好是这个点在圆方树中的度数（不难证明）。所以我们只需要对原图建立圆方树，然后判 $0$ 只需要在圆方树上 dfs 一遍，但是注意原图可能有多个连通块都有奇数个黑点，这时建议特判。复杂度 $O(n+m)$。

代码（还是有一些细节的，多测是真的难受呀！）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int const p=1e9+7;
int st2[200005],d[200005],d2[200005],n,cnt,target[200005],pre[200005],last[200005],tot,pw[200005],tim,dfn[200005],low[200005],st[200005],sum,siz[200005];
bool vis[200005],tag[200005],tag2[200005];
char s[200005];
vector<int>to[200005];
void add(int x,int y)
{
    target[++tot]=y;
    pre[tot]=last[x];
    last[x]=tot;
}
void dfs(int x)
{
    dfn[x]=low[x]=++tim;
    if(s[x]=='1')sum++;
    st[++st[0]]=x;st2[++st2[0]]=x;
    for(int i=last[x];i;i=pre[i])
    {
        int tar=target[i];
        if(!dfn[tar])
        {
            dfs(tar),low[x]=min(low[x],low[tar]);
            if(low[tar]==dfn[x])
            {
                cnt++;
                while(1)
                {
                    d2[st[st[0]]]++;
                    to[cnt].push_back(st[st[0]]);
                    to[st[st[0]]].push_back(cnt);
                    st[0]--;
                    if(st[st[0]+1]==tar)break;
                }
                to[cnt].push_back(x);
                to[x].push_back(cnt);
                d2[x]++;
            }
        }
        else low[x]=min(low[x],dfn[tar]);
    }
}
void dfs2(int x)
{
    st[++st[0]]=x;
    vis[x]=1;siz[x]=(x<=n&&s[x]=='1');
    for(auto tar:to[x])
    {
        if(vis[tar])continue;
        dfs2(tar);
        siz[x]+=siz[tar];
        if(x<=n&&(siz[tar]&1))tag[x]=1;
    }
}
int main()
{
    pw[0]=1;
    for(int i=1;i<=100000;i++)pw[i]=pw[i-1]*2%p;
    int _;
    scanf("%d",&_);
    while(_--)
    {
        int m,x,y,num=0,num2=0;
        scanf("%d%d",&n,&m);
        memset(d,0,sizeof(d));
        memset(d2,0,sizeof(d2));
        memset(last,0,sizeof(last));
        memset(tag2,0,sizeof(tag2));
        tot=0;
        for(int i=1;i<=m;i++)scanf("%d%d",&x,&y),add(x,y),add(y,x),d[x]++,d[y]++;
        scanf("%s",s+1);
        memset(dfn,0,sizeof(dfn));tim=0;cnt=n;
        for(int i=1;i<=n*2;i++)to[i].clear();
        bool flag=0;
        for(int i=1;i<=n;i++)
            if(!dfn[i])
            {
                sum=0;num++;st[0]=st2[0]=0;
                dfs(i);
                if(sum&1)
                {
                    num2++;
                    flag=1;
                    for(int j=1;j<=st2[0];j++)tag2[st2[j]]=1;
                }
            }
        if(flag)printf("0 ");
        else printf("%d ",pw[m-n+num]);
        if(num2>1)
        {
            for(int i=1;i<=n;i++)printf("0 ");
            puts("");
            continue;
        }
        memset(vis,0,sizeof(vis));
        memset(tag,0,sizeof(tag));
        for(int i=1;i<=n;i++)
            if(!vis[i])
            {
                st[0]=0;
                dfs2(i);
                for(int j=1;j<=st[0];j++)
                    if(st[j]<=n&&((siz[i]-siz[st[j]])&1))tag[st[j]]=1;
            }
        for(int i=1;i<=n;i++)
        {
            if(tag[i]||(flag&&(!tag2[i])))printf("0 ");
            else printf("%d ",pw[(m-d[i])-(n-1)+(num+d2[i]-1)]);
        }
        puts("");
    }
    return 0;
}
```



---

## 作者：Piwry (赞：4)

看没人分析代码细节我就来讲讲把...

# 分析

多个连通图可以分开计算

考虑单个连通图，黑点奇偶性一定不变，可以由此判断单张图是否有解。

如果有解，可以在图中随便划出一棵树（包含图所有节点）。从叶节点向根调节，总可以得到一个且仅一个方案。而非树边只要随便选就可以了。这样对于一张图答案是 $2^{m-n+1}$；对于多张图发现每多一张图就少一个树边，于是答案为 $2^{m-n+\text{图数}}$。

现在考虑删点。有三种情况：

1. 删去点后该图消失（即独立点）。这时判断除去这张图是否再没有无解的图。

2. 删去点后图数不变。这时判断这张图是否无解：如果是，判断是否删去了一个黑点（**使图有解**）且该图是否是**唯一的一张无解图**；如果否，判断是否**令这张图无解**且原来**没有其它图无解**。另外这时还要处理因删点**失去的边**。

3. 删去点后图数增加（割点）。这时我们要分别知道产生的每一张图是否无解且同时确认原来有没有其它无解图。同样还需处理失去的边。（这种情况最麻烦）

---

这里着重讲下第三种情况的实现：

判断需要知道分裂出的每张图的信息，我们可以直接在 tarjan 求割点时记录。

直接考虑从某个割点开始 dfs 的情况：如果发现dfs树中有儿子会被它所“割”，我们此时应该已经访问了这张分裂出来的图的**所有节点**，于是就可能记录下分裂图的黑点数；对于每张分裂出的图（除了**父亲处**），我们都会**访问一次**，这样我们就可以记录总共产生了几张图。

对于父亲处分裂出的图，我们可以记录原来每张连通图的黑点数，然后**减去分裂出的图的黑点数**（容斥）。因此我们还需另在 dfs 时求出每个节点属于哪张图。

这里还因注意**不是所有dfs树儿子都被该割点所“割”**，具体来说应当只统计 “`low[to] >= dfn[u]`” 的黑点数。

还有各种细节看代码可能会比较清晰。

# Code

为了方便理解直接对三种情况暴力分类，总共不多不少刚好 99 行）

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using std::min;

const int MAXN =2e5+50, M =1000000007;

int n, m, CNT, CNTmap;
int first[MAXN>>1], dfn[MAXN>>1], low[MAXN>>1];
int cut[MAXN>>1]/*删点多产生图数*/, cntB[MAXN>>1]/*黑点数*/,
    cntBcut[MAXN>>1]/*删点新产生图的总黑点数 +自己是否黑点*/, edg[MAXN>>1]/*连接边数*/;
int group[MAXN>>1], cntBmap[MAXN>>1];
bool col[MAXN>>1], unsol[MAXN>>1]/*对于每个割点是否产生无解图*/, isunsol[MAXN>>1]/*对于每个连通图是否无解*/;
struct edge{
	int net, to;
}e[MAXN];

void tarjan(int u, int fa){
	group[u] =CNTmap;
	cntBcut[u] =(col[u] == 1);
	dfn[u] =low[u] =++CNT;
	cntB[u] =(col[u] == 1);
	edge E;
	for(int l =first[u]; l != -1; l =E.net){
		E =e[l];
		if(!dfn[E.to]){
			tarjan(E.to, u), low[u] =min(low[u], low[E.to]);
			cntB[u] +=cntB[E.to];
			if(low[E.to] >= dfn[u]){
				cntBcut[u] +=cntB[E.to];/*割点不一定使所有儿子（联通图）双双断开*/
				++cut[u];
				unsol[u] =(unsol[u] || (cntB[E.to]%2 != 0));
			}
		}
		else if(E.to != fa) low[u] =min(low[u], dfn[E.to]);
	}
	if(!fa) --cut[u];/*特判*/
}

inline void addedge(int u, int v, int i){
	++edg[u], ++edg[v];
	edge &E =e[i], &E2 =e[i+m];
	E.net =first[u], first[u] =i;
	E.to =v;
	E2.net =first[v], first[v] =m+i;
	E2.to =u;
}

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

int pow2[MAXN>>1];
char s[MAXN>>1];

int main(){
	pow2[0] =1;
	for(int i =1; i < (MAXN)>>1; ++i) pow2[i] =(pow2[i-1]<<1)%M;
	for(int k =0, T =read(); k < T; ++k){
		n =read(), m =read(); CNT =0, CNTmap =0;
		memset(first, -1, sizeof(first));
		memset(dfn, 0, sizeof(dfn));
		memset(cut, 0, sizeof(cut));
		memset(edg, 0, sizeof(edg));
		memset(unsol, 0, sizeof(unsol));
		for(int i =0; i < m; ++i) addedge(read(), read(), i);
		scanf("%s", s);
		for(int i =1; i <= n; ++i) col[i] =s[i-1]-'0';
		int cntunsol =0;
		for(int i =1; i <= n; ++i)
			if(dfn[i] == 0){
				++CNTmap, tarjan(i, 0), cntunsol +=(cntB[i]&1);
				cntBmap[CNTmap] =cntB[i];
				isunsol[CNTmap] =(cntBmap[CNTmap]&1);
			}
		int ans =m-n+CNTmap;
		printf("%d ", (!cntunsol) ? pow2[ans] : 0);
		for(int i =1; i <= n; ++i){/*分类特判*/
			if(!edg[i]/*单独点*/) printf("%d ", (cntunsol-cntB[i] == 0) ? pow2[ans] : 0);
			else if(cut[i] == 0/*非割点*/){
				if(isunsol[group[i]] && cntunsol-col[i] == 0)/*对于该连通图无解*/
					printf("%d ", pow2[ans-edg[i]+1/*少一个点（树边）*/+cut[i]]);
				else if(!isunsol[group[i]] && !cntunsol && col[i] != 1)/*对于该连通图有解*/
					printf("%d ", pow2[ans-edg[i]+1+cut[i]]);
				else printf("0 ");
			}
			else{
				bool Nunsol/*是否产生无解*/ =(!unsol[i] && (cntBmap[group[i]]-cntBcut[i])%2 == 0 /*dfs难以计算父亲信息*/);
				if(Nunsol && cntunsol-isunsol[group[i]]/*可能减少一个无解图*/ == 0)
					printf("%d ", pow2[ans-edg[i]+1+cut[i]]);
				else printf("0 ");
			}
		}
		putchar('\n');
	}
}
```


---

## 作者：Star_Cried (赞：1)

## P4494 [HAOI2018]反色游戏

### 题意

给你一个无向图，图上每个点是黑色或者白色。你可以将一条边的两个端点颜色取反。问你有多少种方法每个边至多取反一次使得图上全变成白色的点。

### 思路

若任意一个连通块黑色点的个数为奇数那么无解。

先考虑树的情况。发现如果是树，并且黑点个数为偶数，有且仅有一种方式达到目标。然后发现，对于一个无向图，它的任意一个生成树若有解，那么其他非树边无论是否取反都有且仅有一种情况达到目标，并且充分。所以答案就是 $2^{m-n+1}$。

考虑不联通的情况，每多一个连通块相当于少了一条非树边，所以答案就是 $2^{m-n+cnt( 连通块个数 )}$。

然后考虑对于删除每个点的情况，分为以下几种：

1. 独立点，不与任何其他点联通，判断删去后是否有解；
2. 非割点，判断删去后是否有解。具体来讲，该点为黑点时，当且仅当全局只有一个连通块且正是所属连通块无解时删除后有解。白点时类似。
3. 是割点，判断删去该点后出现的所有连通块是否有解，并且也要判断是否仅有一个连通块无解且正是该点导致无解时删掉后有解。

对于每种情况，按照上面的方式计算一下有解时的新图的答案即可。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cstring>
#include<cmath>
using namespace std;
inline int read(){
	int w=0,x=0;char c=getchar();
	while(!isdigit(c))w|=c=='-',c=getchar();
	while(isdigit(c))x=x*10+(c^48),c=getchar();
	return w?-x:x;
}
namespace star
{
	const int maxn=1e5+10,mod=1e9+7;
	int n,m,pow[maxn],in[maxn];
	int ecnt,head[maxn],to[maxn<<1],nxt[maxn<<1];
	inline void addedge(int a,int b){
		to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt,in[a]++	;
		to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt,in[b]++;
	}
	int bel[maxn],dfn[maxn],low[maxn],cut[maxn],cnt[maxn],cntbel[maxn],cutcnt[maxn];
	bool col[maxn],unsol[maxn],unsolbel[maxn];
	void tarjan(int x,int fa){
		bel[x]=bel[0],cutcnt[x]=cnt[x]=col[x];
		dfn[x]=low[x]=++dfn[0];
		for(int u,i=head[x];i;i=nxt[i]) if((u=to[i])!=fa)
			if(!dfn[u]) {
				tarjan(u,x),low[x]=min(low[x],low[u]);
				cnt[x]+=cnt[u];
				if(dfn[x]<=low[u]) cutcnt[x]+=cnt[u],++cut[x],unsol[x]|=cnt[u]&1;
			}else low[x]=min(low[x],dfn[u]);
		cut[x]-=!fa;
	}
	inline void work(){
		memset(head,0,sizeof head),ecnt=bel[0]=0;memset(dfn,0,sizeof dfn),memset(cut,0,sizeof cut),memset(in,0,sizeof in),memset(unsol,0,sizeof unsol);
		n=read(),m=read();
		for(int i=1;i<=m;i++) addedge(read(),read());
		for(int c,i=1;i<=n;i++) scanf("%1d",&c),col[i]=c;
		int cntunsol=0;
		for(int i=1;i<=n;i++) if(!dfn[i]) 
			bel[0]++,tarjan(i,0),cntunsol+=cnt[i]&1,cntbel[bel[0]]=cnt[i],unsolbel[bel[0]]=cntbel[bel[0]]&1;
		int ans=m-n+bel[0]; 
		printf("%d ",cntunsol?0:pow[ans]);
		for(int i=1;i<=n;i++) {
			if(!in[i]) printf("%d ",cntunsol^cnt[i]?0:pow[ans]);
			else if(!cut[i]){
				if((unsolbel[bel[i]] and !(cntunsol^col[i])) or (!unsolbel[bel[i]] and !cntunsol and !col[i]))
					printf("%d ",pow[ans-in[i]+1+cut[i]]);
				else printf("0 ");
			}else if(!unsol[i] and !((cntbel[bel[i]]-cutcnt[i])&1) and !(cntunsol-unsolbel[bel[i]])) 
			printf("%d ",pow[ans-in[i]+1+cut[i]]);
			else printf("0 ");
		}
		puts("");
	}
}
signed main(){
	star::pow[0]=1;
	for(int i=1;i<=100000;i++) star::pow[i]=(star::pow[i-1]<<1)%star::mod;
	int T=read();
	while(T--)star::work();
	return 0;
}
```



---

## 作者：League丶翎 (赞：1)

安利博客 [秋葉 - 树叶的一生，只是为了归根么](https://chlience.com/solution/357.html)

## Problem

给定一张 $n$ 个点 $m$ 条边的无向图，每个点可以是黑色或者白色
可以选择一个边集，使得其相连的两端节点反色，显然，一共有 $2^m$ 种方案

问有多少种方案可以使得所有节点变白？

如果删掉节点 $i$ 有多少种方案使所有节点变白？

## Thought

显然有一个 $n*2^m$ 的做法，可以通过 $10pt$ 的数据

显然有一个 $m*2^n$ 的做法，可以通过 $30pt$ 的数据

如果单个联通图上黑点数为奇数，无解
否则必然有解

考虑先建出任意一个生成树，然后搞出任意一个合法解
那么只需要考虑每条非树边组成的环选还是不选

一共有 $2^{m-n+1}$ 种方案

可以通过 $70pt$ 的数据

考虑删掉一个点对答案的影响：

假设删掉这个点后图仍然联通，那么可以按照 $70pt$ 的方法 $O(1)$ 的进行计算答案
假设删掉这个点后图不再联通，那么考虑对每个联通块进行判断，是否有解

考虑建出圆方树，在圆方树上进行 $DP$
如果当前点不是割点，参照情况 $1$
如果当前点是割点，考虑 $DP$ 时算出各子树的黑点数，然后 $O(1)$ 计算答案

可以通过 $100pt$ 的数据

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int read() {
	int ans = 0, flag = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') {if(ch == '-') flag = - flag; ch = getchar();}
	while(ch >= '0' && ch <= '9') {ans = ans * 10 + ch - '0'; ch = getchar();}
	return ans * flag;
}
const int N = 100010;
const int mod = 1000000007;
struct Graph {
	int deg[N << 1];
	int f[N << 2], t[N << 2], n[N << 2], head[N << 1], tot;
	void addedge(int u, int v) {
		++ tot; ++ deg[u]; ++ deg[v];
		f[tot] = u;
		t[tot] = v;
		n[tot] = head[u];
		head[u] = tot;
	}
}G, H;
int low[N], dfn[N], DFN;
int sta[N << 2], top;
int bel[N], cnt;
int n, m;

int col[N];
char s[N];
int beg[N], bcnt;//the beg's top Node and the num of beg

int ansBeg[N];//the ans of the beg if not del ant Node
int belBeg[N];//which beg is the Node belong to;
int nodBeg[N];//howmany Node in the beg
int edgBeg[N];//howmany Edge in the beg
int colBeg[N];//how many black Node in the beg

int Ans[N];
int colSum[N << 1];
int bin[N];
void clear() {
	memset(&G, 0, sizeof(G));
	memset(&H, 0, sizeof(H));
	memset(low, 0, sizeof(low));
	memset(dfn, 0, sizeof(dfn));
	memset(sta, 0, sizeof(sta));
	memset(bel, 0, sizeof(bel));
	DFN = top = cnt = 0;

	memset(col, 0, sizeof(col));
	memset(belBeg, 0, sizeof(belBeg));
	while(bcnt) {
		beg[bcnt] = 
		ansBeg[bcnt] = 
		nodBeg[bcnt] = 
		edgBeg[bcnt] =
		colBeg[bcnt] = 0;
		-- bcnt;
	}
	memset(Ans, 0, sizeof(Ans));
	memset(colSum, 0, sizeof(colSum));
}
void dfs1(int x, int bcnt) {
	belBeg[x] = bcnt;
	nodBeg[bcnt] += 1;
	edgBeg[bcnt] += G.deg[x];
	colBeg[bcnt] += col[x];

	low[x] = dfn[x] = ++ DFN;
	for(int i = G.head[x]; i; i = G.n[i]) {
		int t = G.t[i];
		if(!dfn[t]) {
			sta[++ top] = i;
			dfs1(t, bcnt);
			low[x] = min(low[x], low[t]);
			if(low[t] == dfn[x]) {
				++ cnt;
				H.addedge(x, n + cnt);
				H.addedge(n + cnt, x);
				bel[x] = cnt;
				H.addedge(t, n + cnt);
				H.addedge(n + cnt, t);
				bel[t] = cnt;
				for(; sta[top] != i; sta[top --] = 0) {
					int fr = G.f[sta[top]];
					int to = G.t[sta[top]];
					if(bel[fr] != cnt) {
						H.addedge(fr, n + cnt);
						H.addedge(n + cnt, fr);
						bel[fr] = cnt;
					}
					if(bel[to] != cnt) {
						H.addedge(to, n + cnt); 
						H.addedge(n + cnt, to);
						bel[to] = cnt;
					}
				}
				sta[top --] = 0;
			}
		}
		else if(dfn[t] < dfn[x]) {
			sta[++ top] = i;
			low[x] = min(low[x], dfn[t]);
		}
	}
}
void dfs2(int x, int f, int bcnt) {
	if(x <= n) colSum[x] = col[x];
	for(int i = H.head[x]; i; i = H.n[i]) {
		int t = H.t[i];
		if(t == f) continue;
		dfs2(t, x, bcnt);
		colSum[x] += colSum[t];
	}
	if(x > n) return;
	Ans[x] = 1;
	for(int i = H.head[x]; i; i = H.n[i]) {
		int t = H.t[i];
		if(t == f) {
			if((colBeg[bcnt] - colSum[x]) % 2)
				Ans[x] = 0;
		}
		else
			if(colSum[t] % 2)
				Ans[x] = 0;
	}
	Ans[x] = Ans[x] * bin[(edgBeg[bcnt] - G.deg[x]) - max(0, nodBeg[bcnt] - 1 - H.deg[x])];
}
void work() {
	clear();
	n = read(); m = read();
	for(int i = 1; i <= m; ++ i) {
		int u = read(), v = read();
		G.addedge(u, v);
		G.addedge(v, u);
	}
	for(int i = 1; i <= n; ++ i)
		G.deg[i] /= 2;
	scanf("%s", s);
	for(int i = 0; i < n; ++ i)
		col[i + 1] = (s[i] == '1');
	for(int i = 1; i <= n; ++ i)
		if(!dfn[i]) {
			belBeg[i] = ++ bcnt;
			beg[bcnt] = i;
			dfs1(i, bcnt);
		}
	for(int i = 1; i <= n + cnt; ++ i)
		H.deg[i] /= 2;
	for(int i = 1; i <= bcnt; ++ i)
		edgBeg[i] /= 2;
	int ans = 1, Boom = 0;
	for(int i = 1; i <= bcnt; ++ i) {
		if(colBeg[i] % 2) ansBeg[i] = 1;
		else ansBeg[i] = 0;
		Boom += ansBeg[i];
	}
	if(Boom) printf("0 ");
	else printf("%d ", bin[m - n + bcnt]);
	for(int i = 1; i <= bcnt; ++ i)
		dfs2(beg[i], 0, i);
	for(int i = 1; i <= n; ++ i) {
		if(Boom - ansBeg[belBeg[i]]) printf("0 ");
		else printf("%d ", 1ll * Ans[i] * bin[(m - edgBeg[belBeg[i]]) - (n - nodBeg[belBeg[i]]) + (bcnt - 1)] % mod);
	}
	puts("");
}
int main() {
	bin[0] = 1;
	for(int i = 1; i < N; ++ i)
		bin[i] = 1ll * bin[i - 1] * 2 % mod;
	int t = read();
	while(t --)
		work();
	return 0;
}
```



---

## 作者：Supor__Shoep (赞：0)

### 结论 1（easy）

对于这种黑白点问题，我们不难发现其中的规律：**不管对哪些边进行操作，黑点和白点的奇偶性是不会变的**。对于一条边 $(x,y)$：

- 若 $x,y$ 同色，则其对应颜色的节点数减少 $2$，相反的颜色则增加 $2$，奇偶不变。

- 若 $x,y$ 异色，则一次操作就相当于两者的颜色互换，黑点和白点数量都不变。

因此对于一张连通图 $G=(V,E)$，如果 $G$ 中黑点的个数为奇数，则无论怎么操作，其数量一定会是奇数，不可能变成 $0$。相反，则可以对照上述两种情况，控制黑点数量，最终减少至 $0$，是**一定可以实现的**。

怎么证明？可以先考虑**一次次地选边**进行操作：

- 先保证 $G$ 中一定有白点（若初始时没有白点，则可以对一条连接两个黑点的边进行操作），那么此时一定存在一条边连接一黑一白。

- 根据上面的操作规律，对异色边的操作就等价于**交换颜色**。有了白点作为媒介，我们可以将黑点堆积到一块，并操作连接两个黑点的边。有了黑点是偶数的前提，我们完全可以保证解法可行！

但是题目是选完边之后直接操作，和上面思路不符？不存在，我们可以考虑 $G$ 中每条边在上述过程中被操作的次数的奇偶性，因为偶数次操作等价于不操作，奇数次操作等价于一次操作。这样就可以进行转换了。

### 结论 2（easy）

对于一张**连通图** $G=(V,E)$，若其中黑点个数为偶数，且 $G$ 是一棵树，则操作方案数为 $1$。

证明比较简单，有了结论 1 的铺垫，我们保证了合法方案的存在性。那么我们可以先从叶子节点出发，一步步往根节点进行操作就行了。

### 结论 3（moderate）

对于一张**连通图** $G=(V,E)$，若其中黑点个数为偶数，则操作方案数为 $2^{|E|-|V|+1}$。

证明：

- 先选择 $G$ 的一颗生成树，则其边数为 $|V|-1$。

- 对于剩余的 $|E|-|V|+1$ 条边，我们任意进行操作，即有 $2^{|E|-|V|+1}$ 种可能。

- 根据结论 1 可知，即使前面已经操作了某些非树边，生成树中的黑点数量仍然是偶数。由结论 2 可知生成树内的方案数为 $1$。

- 总的方案数就是 $2^{|E|-|V|+1}\times 1=2^{|E|-|V|+1}$。

看似简短，实际上还真的挺难想到的。。。难点所在了属于是。

### 总论

对于一张无向图 $G=(V,E)$，不保证连通。设其包含 $cnt$ 个连通块 $G_i=(V_i,E_i)$。

- 若 $\exists i\in[1,cnt]$，$G_i$ 中的黑点个数为奇数，则合法方案数为 $0$。

- 否则，将 $cnt$ 个连通块的答案乘起来，有：

$$\large{res=\prod_{i=1}^{cnt}2^{|E_i|-|V_i|+1}=2^{\sum_{i=1}^{cnt}(|E_i|-|V_i|+1)}}=2^{|E|-|V|+cnt}$$

### 实现

由总论可知，答案只和当前图中的边数，点数，连通块数目有关。因此对于每一个点 $x$，求出其度数 $d_x$，然后我们轻松求出删掉 $x$ 后的边数为 $m-d_x$，点数为 $n-1$。而对于连通块数目，可以考虑建立**圆方树**，$x$ 在圆方树上的度数即为删掉他之后，**其所在连通块变成的连通块数目**（不是变化量！）。当然，我们还需要注意删点之后，是否生成了黑点数为奇数的连通块，DP 判一下就行了。然后就很好求了，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e5+5;
const int MOD=1e9+7;
void read(int &x)
{
	x=0;
	short flag=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')	flag=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	x*=flag;
}
int qpow(int x,int y)
{
	int res=1;
	while(y)
	{
		if(y&1)	res=1ll*res*x%MOD;
		x=1ll*x*x%MOD;
		y>>=1;
	}
	return res;
}
int n,m,du[MAXN],d2[MAXN];
int head[MAXN],nxt[MAXN<<1],to[MAXN<<1],tot;
void add(int x,int y)
{
	if(x<y)	d2[x]++,d2[y]++;
	to[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}
vector<int> vec[MAXN];
int dfn[MAXN],low[MAXN],vis[MAXN];
int stk[MAXN],cnt,sumdfs;
int rt[MAXN],siz,bel[MAXN];
char s[MAXN];
void tarjan(int x)
{
	dfn[x]=low[x]=++sumdfs,stk[++cnt]=x,vis[x]=1,bel[x]=rt[siz];
	int len=vec[x].size();
	for(int i=0;i<len;i++)
	{
		int v=vec[x][i];
		if(!dfn[v])
		{
			tarjan(v);
			low[x]=min(low[x],low[v]);
			if(low[v]==dfn[x])
			{
				m++,add(x,m),add(m,x);
				while(stk[cnt]!=v)	add(stk[cnt],m),add(m,stk[cnt]),cnt--;
				cnt--,add(v,m),add(m,v);
			}
		}
		else	low[x]=min(low[x],dfn[v]);
	}
}
int dp[MAXN],F[MAXN];
void dfs(int x,int fa)
{
	F[x]=fa;
	if(x<=n)	dp[x]=s[x]-'0';
	for(int i=head[x];i;i=nxt[i])
	{
		if(to[i]==fa)	continue;
		dfs(to[i],x);
		dp[x]+=dp[to[i]];
	}
}
int main()
{
	int T;
	read(T);
	while(T--)
	{
		cnt=sumdfs=tot=siz=0;
		read(n),read(m);
		int pt=m;
		for(int i=1;i<=n;i++)	vec[i].clear();
		for(int i=1;i<=n*2;i++)	du[i]=dp[i]=head[i]=low[i]=dfn[i]=rt[i]=bel[i]=d2[i]=vis[i]=0;
		while(m--)
		{
			int x,y;
			read(x),read(y);
			vec[x].push_back(y),vec[y].push_back(x);
			du[x]++,du[y]++;
		}
		for(int i=1;i<=n;i++)	cin>>s[i];
		m=n;
		int flag=0;
		for(int i=1;i<=n;i++)
		{
			if(!vis[i])	rt[++siz]=i,tarjan(i),dfs(i,0),flag+=(dp[i]&1);
		}
		m=pt;
		if(!flag)	cout<<qpow(2,m-n+siz)<<" ";
		else	cout<<"0 ";
		for(int i=1;i<=n;i++)
		{
			if(s[i]=='1'&&flag==1&&(dp[bel[i]]&1)||s[i]=='0')
			{
				int t=0;
				for(int j=head[i];j;j=nxt[j])
				{
					if(to[j]==F[i])	continue;
					t|=(dp[to[j]]&1);
				}
				t|=((dp[bel[i]]-dp[i])&1);
				if(!t&&(s[i]=='1'||!flag))	cout<<qpow(2,(m-du[i])-(n-1)+(siz+d2[i]-1))<<" ";
				else	cout<<"0 ";
			}
			else	cout<<"0 ";
		}
		puts("");
	}
    return 0;
}
/*
1
15 10
6 11
8 15
9 11
6 14
2 14
7 15
2 11
3 15
10 12
2 6
001000010000010

3 8 14 
*/ 
```

---


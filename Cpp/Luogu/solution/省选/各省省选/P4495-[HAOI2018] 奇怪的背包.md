# [HAOI2018] 奇怪的背包

## 题目描述

小 C 非常擅长背包问题，他有一个奇怪的背包，这个背包有一个参数 $P$ ，当他向这个背包内放入若干个物品后，背包的重量是物品总体积对 $P$ 取模后的结果。

现在小 C 有 $n$ 种体积不同的物品，第 $i$ 种占用体积为 $V_i$ ，每种物品都有无限个。他会进行 $q$ 次询问，每次询问给出重量 $w_i$ ，你需要回答有多少种放入物品的方案，能将一个初始为空的背包的重量变为 $w_i$。注意，两种方案被认为是不同的，当且仅当放入物品的种类不同，而与每种物品放入的个数无关．不难发现总的方案数为 $2^n$。

由于答案可能很大，你只需要输出答案对 $10^9 + 7$ 取模的结果。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/18144.png)
HAOI2018 round1 T1

## 样例 #1

### 输入

```
3 3 6
1 3 4
5 2 3```

### 输出

```
5
6
6```

# 题解

## 作者：Bruteforces (赞：20)

### 题解
我们首先考虑 $n=1$ 的情况，~~通过打表~~可以发现，对于体积为 $v$ 的物品，在可以取无限次的条件下，能够取到的体积对 $P$ 取膜的值可以为

$gcd(v,P),2*gcd(v,P),3*gcd(v,P)...$

所以我们可以把这个物品的体积看做 $gcd(v,P)$，这对答案不会有任何影响。

由此我们得到启发，$O(\sqrt{P})$ 预处理出 $P$ 的每个约数，存储每个约数出现的次数。由于同一个约数多次选取对答案没有任何影响，容易得出，如果 $P$ 的一个约数出现次数为 $x$，则有 $2^x-1$ 种方案选取这个约数。

~~继续打表~~我们又可以发现，如果选取了 $P$ 的两个约数 $a_{1},a_{2}$，能够取到的值膜 $P$ 的值可以为

$gcd(a_{1},a_{2}),2*gcd(a_{1},a_{2}),3*gcd(a_{1},a_{2})...$

我们可以~~口胡~~证明，当选取约数个数大于 2 时，上式依然成立。

由此我们可以写出DP方程，设 $F[i][j]$ 表示选到 $P$ 的第 $i$ 个约数，选出的数的 gcd 值为 $P$ 的第 $j$ 个约数的方案数，则转移方程为：

$F[i][j]=F[i-1][j]+(1+\sum{_{gcd(a[k],a[i])==a[j]}F[i-1][k]})*(2^{s[i]}-1)$

其中 $a[i]$ 表示 $P$ 的第 $i$ 个约数，$s[i]$ 表示第 $i$ 个约数的出现次数。

该部分时间复杂度为 $O(M^2logM)$，空间复杂度为 $O(M^2)$ 或 $O(2M)$ （滚动数组），其中 $M$ 为 $P$ 的约数个数。

这个时候，对于每一个询问 $w_{i}$，我们容易得出答案就是

$\sum{_{a[i]|w_{i}}F[n][i]}$

但是询问数量可以达到 $10^6$ ，$M$ 最大可以达到 $10^3$ 以上，$O(qM)$ 的暴力统计依然会TLE。

事实上我们可以发现，如果一个数既是 $P$ 的约数，又是 $w_{i}$ 的约数，那么它一定是 $gcd(P,w_{i})$ 的约数，因此我们只需要统计

$\sum{_{a[i]|gcd(P,w_{i})}F[n][i]}$

而这可以在DP之后就预处理出来：

$G[i]=\sum{_{a[j]|a[i]}F[n][j]}$

因此我们可以 $O(1)$ 回答询问，这样总复杂度就是 $O(\sqrt{P}+M^2logM+q)$，这道题就可以AC啦

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1000010,M=10050,mod=1000000007;
int n,q,P,v[N],num[M],tot[M],cnt=0,f[2][M],g[M],now=0,sum[N];

inline void init(){
    sum[1]=2;
    for(register int i=2;i<=n;i++)sum[i]=sum[i-1]*2%mod;
    for(register int i=1;i<=n;i++)sum[i]=(sum[i]+mod-1)%mod;
    
    for(register int i=1;i<=sqrt(P);i++)if(P%i==0)num[++cnt]=i;
    for(register int i=cnt;i>1;i--)if(P/num[i]!=num[i])num[++cnt]=P/num[i];
    for(register int i=1;i<=n;i++){
        int pos=lower_bound(num+1,num+cnt+1,v[i])-num;
        tot[pos]++;
    }
    
    for(register int i=1;i<=cnt;i++)if(tot[i]){
        now^=1;
        for(register int j=1;j<=cnt;j++)f[now][j]=f[now^1][j];
        for(register int j=1;j<=cnt;j++)if(f[now^1][j]){
            int nxt=__gcd(num[j],num[i]);
            int pos=lower_bound(num+1,num+cnt+1,nxt)-num;
            (f[now][pos]+=1LL*f[now^1][j]*sum[tot[i]]%mod)%=mod;
        }
        (f[now][i]+=sum[tot[i]])%=mod;
    }
    for(register int i=1;i<=cnt;i++){
    	for(register int j=1;j<=i;j++)if(num[i]%num[j]==0){
            (g[i]+=f[now][j])%=mod;
        }
    }
}

int main(){
    scanf("%d%d%d",&n,&q,&P);
    for(register int i=1;i<=n;i++)scanf("%d",&v[i]),v[i]=__gcd(v[i],P);
    init();
    for(register int i=1;i<=q;i++){
        int x,ans=0;scanf("%d",&x);x=__gcd(x,P);
        int pos=lower_bound(num+1,num+cnt+1,x)-num;
        printf("%d\n",g[pos]);
    }
    return 0;
}
```

---

## 作者：dsidsi (赞：6)

设当前选取的物品序列为$v_{a_1},v_{a_2},...,v_{a_k}$

则可以凑出$w$的条件是$gcd(P, v_{a_1},v_{a_2},...,v_{a_k})|w$

这样就可以$DP$了。

设$f_{i,j}$表示考虑了前$i$个物品，当前选取的物品与$P$的$gcd$为$j$的方案数。每次转移只需要考虑选还是不选，时间复杂度$O(d(p)n)$，$d(p)$是$P$的因子个数，约为$P^{\frac{1}{3}}$。

优化方法是把与$gcd(v_i,P)$的$v_i$压在一起，这样复杂度就为$O(d(p)^2log)$。

```
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1000005, maxw = 1505, mod = 1e9 + 7;

typedef long long lint;
int n, m, q, P, tot, v[maxn], cnt[maxw], d[maxw], f[maxw][maxw], ans[maxw], pow2[maxn];
map<int, int> g;

inline int gi()
{
    char c = getchar();
    while (c < '0' || c > '9') c = getchar();
    int sum = 0;
    while ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

inline int gcd(int a, int b)
{
    if (b == 0) return a;
    return gcd(b, a % b);
}

inline void inc(int &a, int b) {a += b; if (a >= mod) a -= mod;}

int main()
{
    n = gi(); q = gi(); P = gi();
    for (int i = 1; i <= n; ++i) v[i] = gcd(P, gi());
    sort(v + 1, v + n + 1);

    for (int i = 1; i <= n; ++i)
        if (v[i] != v[i - 1]) ++tot, v[tot] = v[i], cnt[tot] = 1;
        else ++cnt[tot];
    n = tot;
    
    for (int i = 1; i * i <= P; ++i) {
        if (P % i == 0) {
            d[++m] = i;
            if (i * i != P) d[++m] = P / i;
        }
    }
    sort(d + 1, d + m + 1);
    for (int i = 1; i <= m; ++i) g[d[i]] = i;

    pow2[0] = 1;
    for (int i = 1; i <= 100000; ++i) pow2[i] = pow2[i - 1] * 2 % mod;
    f[0][m] = 1;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j) {
            int k = g[gcd(v[i], d[j])];
            inc(f[i][j], f[i - 1][j]);
            inc(f[i][k], (lint)f[i - 1][j] * (pow2[cnt[i]] - 1) % mod);
        }

    for (int i = 1; i <= m; ++i)
        for (int j = 1; j <= i; ++j)
            if (d[i] % d[j] == 0) inc(ans[i], f[n][j]);

    for (int i = 1; i <= q; ++i) printf("%d\n", ans[g[gcd(gi(), P)]]);
    
    return 0;
}
```

---

## 作者：xuantianhao (赞：4)

## [[HAOI2018] 奇怪的背包](https://www.luogu.com.cn/problem/P4495)

神题。

对于某个大小为 $v$ 的物品，它所能表示出的位置的集合等于 $\gcd(v,P)$ 所能表示的集合。

对于某些大小为 $v_1,\dots,v_k$ 的物品，位置集合为 $\gcd\{v_1,\dots,v_k,P\}$。

因此考虑 DP。

我们找出所有 $P$ 的约数，存入 ```vector```。这个个数的级别设为 $L$，则 $L$ 最大只到 768。设 $P$ 的第 $i$ 个约数为 $p_i$ 。

则对于所有的 $v_i$，我们找出 $\gcd(P,v_i)$。设新的 $v_i = \gcd(P,v_i)$。

对于每个 $p_i$，统计它在 $v_1,\dots,v_n$ 中出现了多少次，设为 $s_i$。

我们设 $f[i][j]$ 表示：在 $P$ 前 $i$ 个约数中，选择一些数，使得他们的 $\gcd$ 等于 $P$ 的第 $j$ 个约数的方案数。

则有

$f[i][j] = f[i-1][j]+\Bigg(\small{\begin{cases}1(i=j)\\0(i\neq j)\end{cases}}+\sum\limits_{\gcd(p_k,p_i)=p_j}f[i-1][k]\Bigg)*(2^{s_i}-1)$
 
释义：

首先，答案是可以从前一位继承来的。

然后，因为对于每个 $i$，选任何数量的 $v_k = p_i$ 的 $k$ 都是等价的，因此共有 $2^{s_i}-1$ 中选法；

当 $i = j$ 时，可以之前一个数也不选，就选 $i$ 一个数，因此要加上 1。

然后，因为 $\gcd$ 具有结合律和交换律，所有 $\gcd(p_k,p_i) = p_j$ 的状态也是可继承的。

则 $f[n][j]$ 的状态是最终状态。

对于每个 $w_i$，答案为 $\sum\limits_{v_j \mid w_i}f[n][j]$。这个可以通过一个 $L^2$ 的预处理求出 $g[i]=\sum\limits_{v_j \mid v_i}f[n][j]$ 算出。

复杂度 $O(\sqrt{P}+L^2\log L+q)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,m,p,s[1001000],f[2][1001000],g[1001000],two[1001000];
vector<int>v; 
int main(){
    scanf("%d%d%d",&n,&m,&p);
    two[0]=1;
    for(int i=1;i<=n;i++)two[i]=(two[i-1]<<1)%mod;
    for(int i=0;i<=n;i++)two[i]=(two[i]-1+mod)%mod;
//  for(int i=0;i<=n;i++)printf("%d ",two[i]);puts("");
    for(int i=1;i*i<=p;i++){
        if(p%i)continue;
        v.push_back(i);
        if(i*i!=p)v.push_back(p/i);
    }
    sort(v.begin(),v.end());
//  for(auto i:v)printf("%d ",i);puts("");
    for(int i=1,x;i<=n;i++)scanf("%d",&x),x=__gcd(x,p),s[lower_bound(v.begin(),v.end(),x)-v.begin()]++;
//  for(int i=0;i<v.size();i++)printf("%d ",s[i]);puts("");puts("");
    for(int i=0;i<v.size();i++){
        for(int j=0;j<=i;j++)f[i&1][j]=0;
        f[i&1][i]=1;
        for(int j=0;j<i;j++){
            int gcd=__gcd(v[i],v[j]);
            gcd=lower_bound(v.begin(),v.end(),gcd)-v.begin();
            (f[i&1][gcd]+=f[!(i&1)][j])%=mod;
        }
        for(int j=0;j<=i;j++)f[i&1][j]=(1ll*f[i&1][j]*two[s[i]]+f[!(i&1)][j])%mod;
//      for(int j=0;j<=i;j++)printf("%d ",f[i&1][j]);puts("");
    }
    for(int i=0;i<v.size();i++)for(int j=0;j<=i;j++)if(!(v[i]%v[j]))(g[i]+=f[n&1][j])%=mod;
    for(int i=1,w;i<=m;i++)scanf("%d",&w),w=__gcd(w,p),printf("%d\n",g[lower_bound(v.begin(),v.end(),w)-v.begin()]);
    return 0;
} 

```


---

## 作者：asuldb (赞：4)

[题目](https://www.luogu.org/problemnew/show/P4495)

暴力$dp$好有道理啊

于是我们来个反演吧

考虑一个体积序列$\{v_1,v_2,...v_n\}$能凑成$w$的条件

显然是

$$v_1x_1+v_2x_2+...+v_nx_n\equiv w(mod\ P)$$

根据贝祖定理，我们知道上面的同余方程有解的条件是

$$gcd(v_1,v_2...v_n,P)|w$$

现在题目转化成了求有多少个子集满足$gcd(v_1,v_2..v_n,P)|w$了

显然一个暴力$dp$记录一下当前$gcd$转移就好了，由于$gcd$必然是$P$的约数，$P$的约数是$\sqrt{P}$级别，我们我们只存这些有用的状态，之后每次暴力转移就好了，复杂度$O(n\sqrt{P})$就没了

但是我们来反演一波吧

设$F(n)$表示有多少个子集的$gcd$是$n$的倍数，$f(n)$表示有多少个子集的$gcd$是$n$

非常显然存在

$$F(n)=\sum_{n|d}f(d)$$

反演可得

$$f(n)=\sum_{n|d}F(d)\mu(\frac{d}{n})$$

$F(n)$我们随便搞一搞就好了，若有$s$个数都有$n$这个约数，那么$F(n)=2^s-1$

之后反演得到$f$，这里直接枚举$P$的约数，复杂度是$O(\sigma^2(P))$，但是我们还需要求一个$\mu$，配合线筛预处理还是挺快的

最后我们的答案是

$$Ans(n)=\sum_{d|n}f(d)$$

我们累加一遍就好了

复杂度很玄学，毕竟有一个$\mu$需要求，可能是$O(\sigma^2(P)\sqrt{P})$

代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#define re register
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
const int maxn=1e6+5;
const int mod=1e9+7;
const int M=2e5+5;
inline int read() {
    char c=getchar();int x=0;while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
int d[M],F[M],ans[M],f[M],g[M];
int pw[maxn],a[maxn];
int n,m,P,Sqr,tot;
int is[M],p[M>>1],mu[M],id2[M],id1[M];
inline int find(int x) {return (x<=Sqr)?id1[x]:id2[P/x];}
inline int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
inline void Init() {
    is[1]=1;mu[1]=1;
    for(re int i=2;i<=Sqr;i++) {
        if(!is[i]) p[++p[0]]=i,mu[i]=-1;
        for(re int j=1;j<=p[0]&&p[j]*i<=Sqr;j++) {
            is[p[j]*i]=1;
            if(i%p[j]==0) break;
            mu[p[j]*i]=-1*mu[i];
        }
    }
    for(re int i=1;i<=tot;i++) 
    if(d[i]<=Sqr) id1[d[i]]=i;
        else id2[P/d[i]]=i;
}
inline int getMu(int x) {
    if(x<=Sqr) return mu[x];
    int now=1,t=x;
    for(re int i=1;p[i]*p[i]<=t&&i<=p[0];i++)
    if(x%p[i]==0) {
        x/=p[i];
        if(x%p[i]==0) return 0;
        now=-1*now;
        if(x==1) break;
    }
    if(x!=1) now=-1*now;
    return now;
}
int main() {
    n=read(),m=read(),P=read();
    for(re int i=1;i*i<=P;i++)
    if(P%i==0) {
        d[++tot]=i;
        if(i!=P/i) d[++tot]=P/i;
    }
    pw[0]=1;
    for(re int i=1;i<=n;i++) pw[i]=(pw[i-1]+pw[i-1])%mod;
    for(re int i=1;i<=n;i++) a[i]=read();
    std::sort(d+1,d+tot+1);
    Sqr=std::sqrt(P);Init();
    for(re int i=1;i<=n;i++) {
        int k=gcd(a[i],P);
        g[find(k)]++;
    }
    for(re int i=1;i<=tot;i++)
        for(re int j=i;j<=tot;j++) {
            if(d[j]%d[i]) continue;
            F[i]+=g[j];
        }
    for(re int i=1;i<=tot;i++) F[i]=pw[F[i]]-1;
    for(re int i=1;i<=tot;i++)
        for(re int j=i;j<=tot;j++) {
            if(d[j]%d[i]) continue;
            f[i]+=F[j]*getMu(d[j]/d[i]);
            f[i]%=mod;
            f[i]=(f[i]+mod)%mod;
        }
    for(re int i=1;i<=tot;i++)
        for(re int j=i;j<=tot;j++) {
            if(d[j]%d[i]) continue;
            ans[j]=(ans[j]+f[i])%mod;
        }
    for(re int i=1;i<=m;i++) {
        int x=read();
        int k=gcd(x,P);
        printf("%d\n",ans[find(k)]);
    }
    return 0;
}
```


---

## 作者：Durancer (赞：4)


### HAOI 2018 奇怪的背包

#### 前言

特别鸣谢 $\text{Dxy}$ 大佬的帮助。

#### 一个YY的证明

首先给出一个定理。 

> 对于一个集合中的数 $\{ v_1,v_2,v_3…v_n|v_i\in\mathbb{N}^+\}$。

> 如果 $\gcd(v_1,v_2…v_n)|w$，那么下面这个式子一定成立。

> $$k_1v_1+k_2v_2+…+k_nv_n=w$$

设 $\gcd(v_1,v_2…v_n)=m$，$l_i=\dfrac{v_i}{m}$,则可以得到的是：

$$k_1v_1+k_2v_2+…+k_nv_n=\left( k_1l_1+k_2l_2+…+k_nl_n\right)m$$

$$\text{因为}\gcd(v_1,v_2…v_n)|w$$

$$\therefore w\  \text{为} \gcd(v_1,,v_2…v_n) \text{的倍数}$$

$$\therefore w=(k_1l_1+k_2l_2+…+k_nl_n)m$$

$$\therefore k_1v_1+k_2v_2+…+k_nv_n=w$$

#### 思路

首先肯定是要求 $$k_1V_1+k_2V_2+…+k_nV_n=w \ \ \ (\bmod\ \ P)$$

的方案数。

根据上面的证明可以得到，最终问题可以转化为：求有多少个集合满足 $\gcd(V_i,P)|w$ 。

发现问题其实还可以化简，因为左边的式子一定是 $P$ 的一个因子，而且这个因子一定会出现在 $w$ 中才有可能被整除。所以也就是求：

有多少种集合满足 $\gcd(V_i,P)|\gcd(w,P)$

这个时候你可能要问了，为什么是整除 $w$ 的最大公因数，别的 $P,w$ 的公共因子为什么不行？~~(来自写题解时的神奇疑惑)~~

这里来一个小小的证明：

根据算数基本定理可得：

$$ w=w_1^{c_1}·w_2^{c_2}·w_3^{c_3}·…·w_n^{c_3},(w_i\in \ \text{prime})$$

$$P=p_1^{k_1}·p_2^{k_2}·p_3^{k_3}·…·p_n^{k_n},(p_i\in\ \text{prime})$$

那么来看 $\gcd(w,P)$：

$$\gcd(w,P)=a_1^{b_1}·a_2^{b_2}·a_3^{b_3}·…·a_n^{b_n},(a_i \in \text{}prime)$$

也就是 $w,P$ 的全部公共部分，至于其他的更小的因子，一定包含在 $\gcd(w,P)$ 中，也就一定能整除 $\gcd(w,P)$。

**Tip1** 

因为是与最大公约数和因子有关，所以直接考虑把所有的 $V_i$ 都转化成 $\gcd(V_i,P)$ , 把 $w$ 转化为 $\gcd(w,P)$。

**Tip2**

那么现在就可以设方程了，首先**题目的询问与种类**有关，那么有一维可以是表示种类的，其次，通过转化的题目可以得到，与**集合中的所有 $V_i$ 与 $P$ 的最大公约数**有关，所以这也可以作为一维。

所以就可以设 $f_{i,j}$ 表示在前 $i$ 个物品中选取若干个，与 $P$ 的最大公约数为 $j$ 的方案数。

**Tip3**

观察 $P$，由于上面记录的都是与 $P$ 的因子有关，与 $P$ 本身的关系不大，所以就考虑把 $P$ 的因子记录下来，方便使用。

但是看到 $P\leq 10^9$ 并且 $P=998244353$ 的时候因子是 $998244353$ 巨大，要是把因子当做下标肯定是存不下的，此处离散化即可，从小到大排序，然后离散为排名即可。

看 $V_i$，为了减少枚举的数量，可以考虑把 $\gcd(V_i,P)$ 相同的物品合并，设数组记录每一个相同的量即可。

**注：** 以下的 $V_i$ 全部表示 $\gcd(V_i,P)$。

**Tip4**

根据提示，可以发现，每一种可以有选和不选两种状态，通过 **Tip3** 中的预处理，可以考虑预处理 $2^k$，因为将相同 $\gcd(V_i,P)$ 合并以后可能会有很多种，预处理可以减少多余的枚举求知。

**Tip5**

思考如何转移。

根据设的状态很显然是两层循环，外层枚举合并后的 $\gcd(V_i,P)$ 内层枚举离散化后的 $P$ 因子数组。

回观我们的状态 $f_{i,j}$ 是表示前 $i$ 个中选择若干个，然而并没有限制全部选择，所以在顺序枚举外层的时候，记得要递推合并上一步的式子，也就是：

$$f_{i-1,j}\to f_{i,j} $$

再考虑另外的转移：

设 $k=\gcd(V_i，p_i)$ 其中 $p_i$ 是 $P$ 的一个因子。

可以得到状态转移方程：

$$f_{i-1,j}·\left( 2^{cnt_i}-1\right)\to f_{i,j}$$

至于为什么要减一，因为这是选择若干 $V_i$ 的转移，所以，不可能会出现全部不选这种情况，因此要减一。

**Tip6**

最后一步合并答案。

$\text{ans}$ 数组的下标一定是 $\gcd(w,P)$ 无疑了，那么就枚举 $P$ 的因子，看一看那些可以整除 $\gcd(w,P)$ 合并上去即可。

#### 代码实现

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<map>
using namespace std;
const int N=1e6+9;
const int K=1e5+9;
const int M=2e3+9; 
const int mod=1e9+7;
int n,v[N],q,P;
int poi[M];//这是P的因子(:
int kar;//poi的计数器 
int cnt[M];//减少不必要的枚举，记录相同的v的_gcd 
int top;//有多少个不同的gcd 
map<int,int> pi;//记录P的质因子有哪些
int pow2[K];
int f[M][M];//在前i个v中选择了若干个,v的gcd是j的方案数。 
int ans[M];
int read()
{
	int f=1,x=0;
	char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();	} 
	while(s>='0'&&s<='9'){x=(x<<1)+(x<<3)+(s^'0');s=getchar();}
	return f*x;
} 
int gcd(int a,int b)
{
	if(!b) return a;
	else return gcd(b,a%b); 
}
void Madev()
{
	sort(v+1,v+1+n);//先排序
	for(int i=1;i<=n;i++)
	{
		if(v[i]!=v[i-1])//出现新的gcd
		{
			v[++top]=v[i];//重新记录/qq 
			cnt[top]++;
		}
		else cnt[top]++;
	}
} 
void MadeP()//处理P的因子 
{
	//用莫反的方法，将处理因子化为 sqrt(P) 的时间复杂度 
	for(int i=1;i*i<=P;i++)//1也是一个因子,用sqrt(P)浪费时间
	{
		if(P%i==0)
		{
			poi[++kar]=i;
			if(i*i!=P)
				poi[++kar]=P/i;
			//可以同时找到两个因子，复杂度-- 
		}
	}
	sort(poi+1,poi+1+kar);
	//因为考虑到gcd可能会很大，为了减少开内存的时间和空间开销，离散化，
	//用unodered_map更快 ，大不了自己手写=_=;
	for(int i=1;i<=kar;i++)
		pi[poi[i]]=i;//离散化。 
}
void Madetwo()
{
	pow2[0]=1;
	for(int i=1;i<=100000;i++)//乱猜因子个数，P^{1/3}左右
		pow2[i]=pow2[i-1]*2%mod;//Wrong:天才*i 
} 
void prepare()
{
	for(int i=1;i<=n;i++)
		v[i]=gcd(read(),P);//直接预处理成最大公因数
	Madev();//对v进行去重，本题时间复杂度不允许过多冗杂状态
	MadeP();
	Madetwo(); 
	//因为选择肯定是 2^n的选择，预处理pow2； 
}
//-----------------------预处理部分--------------------------- 
void DP()
{
	f[0][kar]=1;//唯一能想到的预处理/kk
	//别写成f[0][P]? 998244353撑不下 
	for(int i=1;i<=top;i++)//枚举 v
	 	for(int j=1;j<=kar;j++)//枚举 poi,P的因子
		{
			int k=pi[gcd(v[i],poi[j])];
			f[i][j]+=f[i-1][j];//刷表递推
			if(f[i][j]>=mod)
				f[i][j]%=mod;
			f[i][k]=f[i][k]+(1ll*f[i-1][j]*(pow2[cnt[i]]-1)%mod);//根据方案数合并
			//注意不能啥也不选，所以要-1这个方案数 
			if(f[i][k]>=mod)
				f[i][k]%=mod; 
		}
	for(int i=1;i<=kar;i++)
		for(int j=1;j<=i;j++)
			if(poi[i]%poi[j]==0)
			{
				ans[i]=ans[i]+f[top][j];//Wrong 想当然写成 n 应该是 top
				if(ans[i]>=mod)
					ans[i]%=mod;	
			} 
			
	return;
}
int main()
{
	n=read();
	q=read();//询问 
	P=read();//模数 
	prepare();
	DP();
	while(q--)
	{
		int opt=read();
		printf("%d\n",ans[pi[gcd(opt,P)]]);
	}
	return 0;
}
```


---

## 作者：Soulist (赞：3)

考虑方程 $ax+by=\gcd(x,y)$，裴蜀定理告诉我们它总是有解的

同时，不难发现查询的 $w_i$ 以及可以使用的 $v_i$ 均可以视为 $\gcd(x,P)$，这对于答案是没有影响的。原因是裴蜀定理。不妨设 $a_i=\gcd(v_i,P)$

假设使用了若干个数，仍然由于裴蜀定理，我们发现使用若干个数等价于使用若干个 $\gcd(a_{i_1},a_{i_2}...a_{i_m})$，于是查询等价于给定 $x$ 求有多少种方式选出若干个数使得 $\gcd(a,b,c...)|x$

对 P 分解质因数，~~为了锻炼代码能力我选择 PR~~，枚举每个约数，则只需要统计有多少种方案选出若干个数使得 $\gcd(a,b,c..)=d$

考虑莫比乌斯反演，设 $F(x)$ 为 $\gcd$ 至少为 $x$ 的方案数，则有 $F(x)=2^{cnt_x}$，且 $f(x)=\sum_{x|d}F(d)\mu(\frac{d}{x})$

容易发现合法的 $d$ 以及 $\frac{d}{x}$ 都是 $P$ 的约数且不含 $P$ 本身，我们注意到 $\sigma(P)$ 在 $10^9$ 范围内最大为 $1344$，所以直接 $\mathcal O(\sigma(P)^2)$ 暴力即可，复杂度为 $\mathcal O(\sigma(P)^2+(n+m)\log P)$

不过由于莫比乌斯函数本质上就是容斥系数，所以可以直接容斥。

不过由于要访问非连续的下标...我直接用了一个 $\rm map$

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )
#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )
#define re register
#define int long long
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int N = 2000 + 5 ; 
const int M = 1e6 + 5 ; 
const int mod = 1e9 + 7 ; 
int n, q, P, st[N], c[N], D[N], f[N], F[N], num, top, cnt ; 
int w[M] ; 
map<int, int> o, id ;
int fpow( int x, int k, int p ) {
	int ans = 1, base = x ; 
	while( k ) {
		if( k & 1 ) ans = 1ll * ans * base % p ;
		base = 1ll * base * base % p, k >>= 1 ; 
	} return ans ; 
}
int SD( int x ) {
	return 1ll * ( ( 1ll * rand() << 15ll ) | rand() ) % x ; 
}
bool M_R( int p ) {
	if( p == 2 || p == 3 ) return 1 ;
	if( p == 1 || ( p % 2 ) == 0 ) return 0 ; 
	int d = p - 1, s = 0 ; 
	while( !(d & 1) ) ++ s, d >>= 1 ; 
	rep( i, 0, 7 ) {
		re int a = SD( p - 3 ) + 2, x = fpow( a, d, p ), y = 0 ;
		for( re int j = 0; j < s; ++ j ) {
			y = 1ll * x * x % p ; if( ( y == 1 ) && ( x != 1 ) && ( x != p - 1 ) ) return 0 ;
			x = y ; 
		} if( y != 1 ) return 0 ; 
	} return 1 ; 
}
int gcd( int x, int y ) {
	return ( x == 0 ) ? y : gcd( y % x, x ) ;
} 
int work( int p ) {
	int k = 2, x = SD( p - 1 ) + 1, y = x, d = 1, c = SD(p - 1) + 1 ;
	for( re int i = 1; d == 1; ++ i ) {
		x = ( 1ll * x * x + c ) % p, d = gcd( (x > y) ? x - y : y - x, p ) ;
		if( i == k ) y = x, k <<= 1 ; 
	} return d ; 
}
void Pollard_Rho( int p ) {
	if( p == 1 ) return ; 
	if( M_R(p) ) { st[++ top] = p ; return ; }
	int x = p ; while( x == p ) x = work(p) ;
	Pollard_Rho(p / x), Pollard_Rho(x) ;
}
void dfs( int x, int d ) {
	if( x == num + 1 ) { D[++ cnt] = d ; return ; }
	int t = 1 ; 
	rep( k, 0, c[x] ) dfs( x + 1, d * t ), t = t * w[x] ;
}
signed main()
{
	n = gi(), q = gi(), P = gi() ; 
	Pollard_Rho(P) ; 
	sort( st + 1, st + top + 1 ) ;
	rep( i, 1, top ) ( st[i] == st[i - 1] ) ? ++ c[num] : c[++ num] = 1, w[num] = st[i] ;
	dfs( 1, 1 ), sort( D + 1, D + cnt + 1 ), -- cnt ;
	w[0] = 1 ; int x ; 
	rep( i, 1, n ) x = gi(), ++ o[gcd( x, P )], w[i] = w[i - 1] * 2 % mod ; 
	rep( i, 1, cnt ) {
		rep( j, i, cnt ) if( D[j] % D[i] == 0 ) F[i] += o[D[j]] ;
		F[i] = w[F[i]] - 1, id[D[i]] = i ; 
	}
	drep( i, 1, cnt ) {
		f[i] = F[i] ; 
		rep( j, i + 1, cnt ) if( D[j] % D[i] == 0 ) f[i] = ( f[i] - f[j] + mod ) % mod ; 
	}
	drep( i, 1, cnt ) rep( j, i + 1, cnt ) if( D[j] % D[i] == 0 ) f[j] = ( f[j] + f[i] ) % mod ; 
	rep( i, 1, q ) x = gi(), printf("%lld\n", f[id[gcd( x, P )]] ) ;
	return 0 ;
}
```

---

## 作者：Prean (赞：2)

先想一件事情：我们需要什么？

如果有一个物品的体积为 $w$，那么令一个数不断地加上 $w$，最后一定会回到 $0$。

而对于一堆物品，一定存在一个 $w$ 和这一堆物品等价。

容易发现，如果我取 $(P-1)$ 个 $w$ 相当于取了一个 $-w$。运用裴蜀定理可以知道这个 $w$ 为这一堆物品的 $\gcd$。

然后询问一个 $p$ 关心的是有多少种方案凑成的 $w$ 是 $p$ 的因数。

所以我们相当于要拿一堆数做一个 $\gcd$ 背包。

容易发现另一件事，物品 $w$ 和物品 $\gcd(P,w)$ 等价。所以我们相当于是拿若干个数（不超过 $1344$ 个）来做 $\gcd$ 背包。于是把数填进桶之后莫反一下即可。

询问 $p$ 时相当于询问 $\gcd(P,p)$，只需要一遍 $\gcd$ 即可。

莫反的过程有点儿像卷上一个 $\mu$，所以大概是可以做到 $O(\sigma(P)\omega(P)+q\log P)$，大不了 $O(\sigma(P)^2+q\log P)$ 也是稳过的。
```cpp
#include<algorithm>
#include<cstdio>
#include<cctype>
typedef unsigned ui;
const ui M=1350,mod=1e9+7;
ui n,q,P,m,p[35],k[35],K[35],f[M],id[M],val[M],vis[M];double inv[M];
inline ui pow(ui a,ui b=mod-2){
	ui ans(1);for(;b;b>>=1,a=1ull*a*a%mod)if(b&1)ans=1ull*ans*a%mod;return ans;
}
inline void Divide(ui n){
	for(ui i=2;i*i<=n;++i)if(!(n%i)){
		p[++m]=i;inv[m]=1./i+1e-15;while(!(n%i))++k[m],n/=i;
	}
	if(n^1)p[++m]=n,inv[m]=1./n+1e-15,k[m]=1;K[m+1]=1;for(ui i=m;i>=1;--i)K[i]=K[i+1]*(k[i]+1);
}
inline ui Getid(ui V){
	ui id(0);for(ui i=1;i<=m;++i)for(ui j(1);j<=k[i]&&V==ui(V*inv[i])*p[i];++j)id+=K[i+1],V*=inv[i];return id;
}
inline void DFS(const ui&n,ui V,const ui&tag,const ui&id){
	if(id==m+1)return vis[n]=tag,val[n]=V,void();
	for(ui i=0;i<=k[id];++i)DFS(n+i*K[id+1],V,tag|((i==k[id])<<id),id+1),V*=p[id];
}
inline ui read(){
	ui n(0);char s;while(!isdigit(s=getchar()));while(n=n*10+(s&15),isdigit(s=getchar()));return n;
}
inline void write(ui n){
	static char s[10];ui top(0);while(s[++top]=n%10^48,n/=10);while(putchar(s[top]),--top);putchar(10);
}
signed main(){
	n=read();q=read();P=read();Divide(P);
	while(n--)++f[Getid(read())];DFS(0,1,0,1);for(ui i=0;i<K[1];++i)id[i]=i;
	std::sort(id,id+K[1],[&](const ui&x,const ui&y){return val[x]<val[y];});
	for(ui i=1;i<=m;++i)for(ui x,j=K[1]-1;~j;--j)if(!(vis[x=id[j]]>>i&1))f[x]=(f[x]+f[x+K[i+1]])%mod;
	for(ui i=0;i<K[1];++i)f[i]=(pow(2,f[i])-1);
	for(ui i=1;i<=m;++i)for(ui x,j=0;j<K[1];++j)if(!(vis[x=id[j]]>>i&1))f[x]=(f[x]+mod-f[x+K[i+1]])%mod;
	for(ui i=1;i<=m;++i)for(ui x,j=0;j<K[1];++j)if(!(vis[x=id[j]]>>i&1))f[x+K[i+1]]=(f[x+K[i+1]]+f[x])%mod;
	while(q--)write(f[Getid(read())]);
}
```

---

## 作者：myee (赞：2)

### 前言

老师给的**夯基训练**题，感觉已有题解做法复杂度稍高，为此优化之。

### 一些记号

* $\tau(P)$ 表示 $P$ 的因子个数（即 $\operatorname{d}(P)$）。
* $\omega(P)$ 表示 $P$ 的本质不同质因子个数。

### 思路

把每个数 $v$ 变为 $\gcd\{v,P\}$，显然不影响答案。

此时数的种类只有 $O(\tau(P))$ 种。

则显然此时一种选法合法当且仅当 $\gcd\{v|v\in\mathcal B\}|w$，其中 $\mathcal B$ 代表选择的数的集合（背包）。

我们进行质因数分解，则每个数可被唯一分解。

$$P=\prod p_k^{a_k},v=\prod p_k^{b_k}(b_k\le a_k)$$

因此在此意义下有良好的偏序关系。

定义每个数 $v$ 的选法的 GF 为 $z^P+z^v$。

不妨考虑对每个数的 GF 在每个质数的幂次上同时做 $\min$ 卷积，即所谓 $\gcd$ 卷积。显然此时再做一次 zeta 变换（也即 Dirichlet 前缀和）即得答案系数。

$\gcd$ 卷积就和我们的交 / 并卷积类似了。

于是考虑调用 CF449D 的套路。

$$\prod z^P+z^v$$

其中乘法指 $\gcd$ 卷积。

我们把每个 GF 用 FMT 在数论上做一遍，逐项分别乘起来，IFMT 回去，就是 $\gcd$ 卷积，但这样复杂度不够优（为 $O(\min\{n,\tau(P)\}\tau(P)\omega(P))$ 的，也即**此题大多数题解的复杂度**）。

由于无论哪个位置，$z^P$ 在 FMT 后都会对之施以贡献，所以每个 $z^v$ 在其所能影响的范围的**加上 $1$** 相当于把 $1$ 变成 $2$，也即**乘以 $2$**。

于是不妨令所有 $v$ 对 $v$ 位置直接施以 $+1$ 的贡献，再做一次 FMT，然后在把每个位置的值 $a$ 变为 $2^a$，最后再 IFMT 回来。

### 复杂度分析

至此，复杂度为 $O(n\log P+q\log P+\tau(P)\omega(P))$，可近似认为是 $O(n\log P+q\log P+P^{\frac13}\log\log P)$，其中 $\log P$ 因子来源于 $\gcd$ 预处理（当然，是对着 $P$ 的分解式搞）。

对 $P$ 的质因数分解可用 Pollad-Rho 做到 $O(P^{\frac14+\epsilon})$，此处不计。

事实上，通过更精细的方法，对 $n,q$ 旁的 $\log P$ 因子可以作出进一步优化。


---

## 作者：yybyyb (赞：2)

~~似乎我的做法和别人都不一样？？？~~

一个重量为$V_i$的物品，可以放出所有$gcd(V_i,P)$的重量，而多个物品也只要$gcd$就好了。  
现在的问题转变成了有多少个集合$S$，满足$S+\{P\}$中所有数的$gcd$是$w$的因数。那么实际上就是直接令$a[i]'=gcd(a[i],P)$，然后选出一个集合使得它是$gcd(P,w)$的因数。  
考虑对于$P$的每个因数预处理答案，不记得在哪里看到的，当$P$较大的时候，其约数个数是$P^{\frac{1}{3}}$级别，那么在这里就可以暴力把所有因数算出来之后$O(\sigma^2)$计算，即先统计有多少个$a[i]'$是当前$d$的倍数，那么贡献是$2^{s}-1$，然后容斥减去所有$d$的倍数的答案就是$gcd$为$d$的答案。然后再$O(\sigma^2)$的计算约数和就好了。  
这样子复杂度大概是$O((n+Q)logP+\sigma(P)^2)$，前面那个$log$来自于$gcd$的复杂度。
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define MOD 1000000007
#define MAX 1000100
inline int read()
{
	int x=0;bool t=false;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')t=true,ch=getchar();
	while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
	return t?-x:x;
}
int n,Q,P,a[MAX],bin[MAX];
const int blk=50000;
int w[blk],tot,id1[blk],id2[blk],f[blk],s[blk];
int ID(int x){return x<blk?id1[x]:id2[P/x];}
int S[blk],top;
int main()
{
	n=read();Q=read();P=read();
	for(int i=1;i<=n;++i)a[i]=__gcd(read(),P);
	bin[0]=1;for(int i=1;i<=n;++i)bin[i]=(bin[i-1]<<1)%MOD;
	for(int i=1;i*i<=P;++i)
		if(P%i==0)
		{
			w[++tot]=i;
			if(P/i!=i)w[++tot]=P/i;
		}
	sort(&w[1],&w[tot+1]);
	for(int i=1;i<=tot;++i)
		if(w[i]<blk)id1[w[i]]=i;
		else id2[P/w[i]]=i;
	for(int i=1;i<=n;++i)s[ID(a[i])]+=1;
	for(int i=tot;i;--i)
	{
		int cnt=0;top=0;
		for(int j=i;j<=tot;++j)
			if(w[j]%w[i]==0)S[++top]=j,cnt+=s[j];
		f[i]=bin[cnt]-1;
		for(int j=2;j<=top;++j)f[i]=(f[i]+MOD-f[S[j]])%MOD;
	}
	for(int i=tot;i;--i)
		for(int j=1;j<i;++j)
			if(w[i]%w[j]==0)f[i]=(f[i]+f[j])%MOD;
	while(Q--)
	{
		int d=__gcd(read(),P);
		printf("%d\n",f[ID(d)]);
	}
	return 0;
}
```


---

## 作者：Fzrcy (赞：1)

首先根据裴蜀定理，在已知 $a,b$ 且 $x,y$ 任意的情况下， $ax+by$ 的最小正整数值为 $\gcd(a,b)$。所以在模 $P$ 意义下，$kx$ 的值为 $\gcd(x,P)$ 的倍数（$x$ 为定值，$k\ge 0$）。

首先将 $V_i$ 改为 $\gcd(V_i,P)$，即可以表示的最小整数，我们发现 $V_i$ 不同的情况最多只有 $\sqrt{P}$ 个（在该数据范围下最多只有 1344 个而已）。

设 $f_{i,j}$ 表示考虑了前 $i$ 个因数，当前可以表示的最小整数为 $V_j$ 的方案数，根据裴蜀定理转移即可。dp 的时间复杂度为 $O(d(P)^2\log P)$。

统计答案时，仍然将 $q$ 改为 $\gcd(q,P)$，则答案为 $\sum_{V_j|q} f_{d(P),j}$，这个可以预处理，$O(\log P)$ 查询（$\gcd$ 的时间复杂度）。

```cpp
// qwq
#include <bits/stdc++.h>
#define RG register
#define R RG int
#define inl inline
using namespace std;
using ll=long long;
constexpr int N=1e6+1;
constexpr ll mo=1e9+7;
int gcd(R x,R y){return !y?x:gcd(y,x%y);}
unordered_map<int,int>Map;
ll f[3000][3000];
int n,q,P,a[N],c[N],m;
ll ksm(ll x,ll y){
    ll cur=1;
    for(;y;y>>=1,x=x*x%mo)
        if(y&1)cur=cur*x%mo;
    return cur;
}
int main(){
    cin>>n>>q>>P;
    for(R i=1;i*i<=P;i++)if(P%i==0)
        c[++m]=i,(i*i!=P)&&(c[++m]=P/i);
    sort(c+1,c+m+1);m=unique(c+1,c+m+1)-c-1;
    for(R i=1;i<=m;i++)Map[c[i]]=i;
    for(R i=1,x;i<=n;i++)cin>>x,a[Map[gcd(x,P)]]++;
    f[0][Map[P]]=1;
    for(R i=1;i<=m;i++){
        memcpy(f[i],f[i-1],sizeof f[i-1]);
        if(a[i])for(R j=1;j<=m;j++){
            int nx=Map[gcd(c[j],c[i])];
            (f[i][nx]+=f[i-1][j]*(ksm(2,a[i])-1))%=mo;
            f[i][nx]=(f[i][nx]%mo+mo)%mo;
        }
    }
    for(R i=m;i;i--)
        for(R j=i+1;j<=m;j++)
            if(c[j]%c[i]==0)
                (f[m][j]+=f[m][i])%=mo;
    while(q--){
        R x;cin>>x;
        cout<<f[m][Map[gcd(x,P)]]<<'\n';
    }
    return 0;
}
```



---

## 作者：Jμdge (赞：1)

数论题（第一次没看题解耶）...

我们发现一个物品可以放无限多次，也就是说我们可以江 a[i] 视作 与 a[i] 与 p 的 $gcd$, 只要是这个 $gcd$ 的倍数的数, a[i] 都能表示（数论基础）

也就是说，我们读入 a[i] 的时候，直接江其处理为 $gcd(a[i],p)$ 即可

这点相信大家都能够推导到，接下来的推导也并不困难

1. 接下来我们考虑到 a[i] 的取值，我们发现 a[i] 只可能是 p 的约数（貌似很显然），而 p 的约数在 1e9 范围内不到 2000 个（据某大佬统计貌似连1400都不到）

2. 我们再考虑两个数 a[i], a[j] 能表示哪些数，其实 a[i], a[j] 可以表示的数仍然是 p 的约数，并且能被 $gcd(a[i],[j])$ 整除

上面两点启示我们可以写个 n^2 暴力（当然用到下面的map还要加个 log ）

那么我们考虑江 p 的所有约数筛出来，并且存进 s 数组，同时用 map 记录 p 的约数 i 在 s 中的位置 mp[i] 

然后剩下的就是动规转移了，我们令 f[i][j] 表示从前 i 个约数中取出任意数使它们的 $gcd=s[j]$ 的方案数，那么转移是这样的


$$f[i][x]=\sum f[i-1][a]\times f[i-1][b]\times [gcd(s[a],s[b])=s[x] ]$$

通俗讲就是 $gcd$ 为 x 的两个数的 **构成方案数** 的乘积累加进 f[i][x]

代码里用了滚动数组但其实并不需要，然后要说优化空间的话其实 map 可以换 HASH ，作者太懒太菜就不改了...（如要抢最优解 top 的同学可以考虑一下）

```
//by Judge
#include<map>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
const int mod=1e9+7;
const int M=1e6+3;
typedef int arr[M];
int gcd(int a,int b){return b?gcd(b,a%b):a;}
inline void ADD(int& a,int b){a+=a+b>=mod?b-mod:b;}
inline int qpow(int x,int p){ ll s=1;
	for(;p;p>>=1,x=1ll*x*x%mod)
		if(p&1) s=1ll*s*x%mod; return s;
}
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(int x,char chr='\n'){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=chr;
} int n,p,q,ans,a[M],s[M],num[M],f[2][M]; map<int,int> mp;

inline void prep(int n){
	for(int i=1;i*i<=n;++i) if(!(n%i)){
		s[++s[0]]=i; if(i*i<n) s[++s[0]]=n/i;
	} sort(s+1,s+1+s[0]);
	for(int i=1;i<=s[0];++i) mp[s[i]]=i;
}
int main(){
	n=read(),q=read(),p=read(),prep(p);
	for(int i=1;i<=n;++i) a[i]=read(),a[i]=gcd(a[i],p);
	for(int i=1;i<=n;++i) a[i]=lower_bound(s+1,s+1+s[0],a[i])-s,++num[a[i]];
	for(int i=1;i<=s[0];++i) if(num[i]) f[0][i]=qpow(2,num[i]),ADD(f[0][i],mod-1);
	for(int i=1;i<=s[0];++i){ memcpy(f[i&1],f[i&1^1],s[0]+1<<4);
		for(int j=1;j<i;++j) ADD(f[i&1][mp[gcd(s[i],s[j])]],1ll*f[i&1^1][i]*f[i&1^1][j]%mod);
	}
	memcpy(f[s[0]&1],f[s[0]&1^1],s[0]+1<<2);
	for(int i=s[0];i;--i) for(int j=1;j<i;++j)
		if(!(s[i]%s[j])) ADD(f[1][i],f[1][j]);
	for(int x;q;--q,print(f[1][mp[x]]))
		x=read(),x=gcd(p,x); return Ot(),0;
}
```





---

## 作者：SuperCowHorse (赞：0)

假设选出的方案序列为 $b$，长度为 $m$。很容易观察到一个性质：当且仅当 $\gcd\{\gcd\limits_{i=1}^m\{b_i\},p\}\mid w$ 时，序列 $b$ 是符合条件的。

那么，我们就把问题转换为了：求 $a$ 的子序列 $b$ 的个数，其中 $\gcd\{\gcd\limits_{i=1}^m\{b_i\},p\}\mid w$。

注意到 $\gcd\{\gcd\limits_{i=1}^m\{b_i\},p\}=\gcd\{\gcd\limits_{i=1}^m\{b_i,p\}\}$，那么问题又转化为了：求 $a$ 的子序列 $b$ 的个数，其中 $\gcd\{\gcd\{\gcd\limits_{i=1}^m\{b_i,p\}\}\mid w$。

又注意到 $\gcd\{\gcd\limits_{i=1}^m\{b_i,p\}\}$ 一定是 $p$ 的因子，那么 $\gcd\{\gcd\{\gcd\limits_{i=1}^m\{b_i,p\}\}\mid w$ 又可以等价于 $\gcd\{\gcd\{\gcd\limits_{i=1}^m\{b_i,p\}\}\mid \gcd\{w,p\}$。

所以最终问题就是：那么，我们就把问题转换为了：求 $a$ 的子序列 $b$ 的个数，其中 $\gcd\{\gcd\{\gcd\limits_{i=1}^m\{b_i,p\}\}\mid \gcd\{w,p\}$。

我们先把 $a$ 预处理成 $\gcd\{a_i,p\}$，然后剩下的就是一个背包了。设 $p$ 的因子个数为 $k$，则复杂度为 $O(nk)$。

但显然，$n\le10^6$，肯定会炸。

考虑优化。我们发现 $a$ 中**至多**有 $k$ 个不同的元素，我们对每一种不同的元素赋一个权值 $c_i$，然后去重。在背包转移时只需要乘上 $c_i$ 就行。

$c_i$ 又是多少呢？设 $i$ 在原数组的个数为 $k$，那么不难发现，转移的时候至少要取一个 $i$，总的方案数就是 $2^k-1$。

对了，由于 $p\le10^9$，因数比较大，所以需要离散化。这里我直接用了 `map`。

最终复杂度：$O(m^2\log m)$。($\log$ 是因为 `map`)

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e6+5;
const ll mod=1e9+7;
int n,Q;ll a[maxn],p;
map<ll,int>mp;int m;
ll f[maxn],g[maxn],o[maxn];
inline void init(){//先预处理 p 的所有因数，然后离散化
	for(ll i=1;i*i<=p;++i){
		if(p%i==0){
			o[++m]=i;
			if(i*i!=p) o[++m]=p/i;
		}
	}
	sort(o+1,o+1+m);
	for(int i=1;i<=m;++i){
		mp[o[i]]=i;
	}
}
ll c[maxn],pow2[maxn];
signed main(){
	scanf("%d%d%lld",&n,&Q,&p);
	pow2[0]=1;
	for(int i=1;i<=n;++i){
		pow2[i]=pow2[i-1]*2%mod;//预处理 2 的 k 次方
	}
	for(int i=1;i<=n;++i){
		scanf("%lld",&a[i]);
		a[i]=__gcd(a[i],p);
	}
	init();
	sort(a+1,a+1+n);
	for(int i=1;i<=n;++i){
		++c[mp[a[i]]];//计算 c
	}
	int Nahida=unique(a+1,a+1+n)-a-1;//去重
	n=Nahida;
	f[m]=1;
	for(int i=1;i<=n;++i){//背包，f[i] 表示 gcd 为 o[i] 时的方案数（这里因为更新时会影响到一些数组的值，所以开了两个数组进行滚动赋值）
		for(int j=1;j<=m;++j){
			g[j]=f[j];
		}
		for(int j=1;j<=m;++j){
			int u=__gcd(o[j],a[i]);//更新
			g[mp[u]]=((g[mp[u]]+f[j]*(pow2[c[mp[a[i]]]]-1))%mod)%mod;
		}
		for(int j=1;j<=m;++j){
			f[j]=g[j];
		}
	}
	memset(f,0,sizeof(f));
	for(int i=1;i<=m;++i){//计算最终的 f（比如说问 6 的方案数，其中 1,2,3,6 都是 6 的因子，所以这里要加上这些因子）
		for(int j=1;j<=i;++j){
			if(o[i]%o[j]==0){
				f[i]=(f[i]+g[j])%mod;
			}
		}
	}
	for(ll x;Q;--Q){//直接输出
		scanf("%lld",&x);
		printf("%lld\n",f[mp[__gcd(x,p)]]);
	}
	return 0;
}
```

---
考前写题解，祝所有人 CSP-S2024 rp++。

---


# [JSOI2018] 潜入行动

## 题目描述

外星人又双叒叕要攻打地球了，外星母舰已经向地球航行！这一次，``JYY`` 已经联系好了黄金舰队，打算联合所有 ``JSOIer`` 抵御外星人的进攻。

在黄金舰队就位之前，``JYY`` 打算事先了解外星人的进攻计划。现在，携带了监听设备的特工已经秘密潜入了外星人的母舰，准备对外星人的通信实施监听。

外星人的母舰可以看成是一棵 $n$ 个节点、 $n-1$ 条边的**无向树**，树上的节点用 $1,2,\cdots,n$ 编号。``JYY`` 的特工已经装备了隐形模块，可以在外星人母舰中不受限制地活动，可以神不知鬼不觉地在节点上安装监听设备。

如果在节点 $u$ 上安装监听设备，则 ``JYY`` 能够监听与 $u$ **直接相邻**所有的节点的通信。换言之，如果在节点 $u$ 安装监听设备，则对于树中每一条边 $(u,v)$ ，节点 $v$ 都会被监听。特别注意**放置在节点 $u$ 的监听设备并不监听 $u$ 本身的通信**，这是 ``JYY`` 特别为了防止外星人察觉部署的战术。

``JYY`` 的特工一共携带了 $k$ 个监听设备，现在 ``JYY`` 想知道，有多少种不同的放置监听设备的方法，能够使得母舰上**所有节点**的通信都被监听？为了避免浪费，**每个节点至多只能安装一个监听设备，且监听设备必须被用完**。


## 说明/提示

**样例 1 解释**

样例数据是一条链 $1-2-3-4-5$ 。首先，节点 $2$ 和 $4$ 必须放置监听设备，否则 $1,5$ 将无法被监听（放置的监听设备无法监听它所在的节点）。剩下一个设备必须放置在 $3$ 号节点以同时监听 $2,4$ 。因此在 $2,3,4$ 节点放置监听设备是唯一合法的方案。

**数据范围**

存在 $10\%$ 的数据，$1 \le n \le 20$ ；

存在另外 $10\%$ 的数据，$1 \le n \le 100$ ；

存在另外 $10\%$ 的数据，$1 \le k \le 10$ ；

存在另外 $10\%$ 的数据，输入的树保证是一条链；

对于所有数据，$1\le n\le 10^5$​ ，$1\le k\le \min\{n,100\}$ 。

## 样例 #1

### 输入

```
5 3
1 2
2 3
3 4
4 5```

### 输出

```
1```

# 题解

## 作者：GKxx (赞：97)

一道树上背包简单题

状态很好推。设$dp[x][i][0/1][0/1]$表示以$x$为根的子树中共放了$i$个监听装置，其中$x$点放没放装置，$x$点有没有被监听到的方案数（在以$x$为根的子树中除$x$外的其它结点都被监听到了）

不难看出这是一个树上背包，树上背包的转移套路是

$dp[x][i+j]=combine(dp[x][i],dp[v][j])$，其中$v$是$x$的子节点

所以本题的转移也就这样来考虑。把树画成这样，分为$x$侧和$v$侧
![xysILoveYou](https://cdn.luogu.com.cn/upload/pic/41854.png)

如果您有能力请自行推出方程，跳过这一段

 - 如果$x$没被监听，那么$v$一定不能放装置，因此
$dp[x][i+j][0][0]=\sum dp[x][i][0][0]*dp[v][j][0][1]$

 - 如果$x$没被监听但是放了装置，$x$侧的状态一定是$dp[x][i][1][0]$，$v$是否被监听无所谓但是一定不能放装置，因此
$dp[x][i+j][1][0]=\sum dp[x][i][1][0]*(dp[v][j][0][0]+dp[v][j][0][1])$

 - 如果$x$没放装置但是被监听了，这时候要分情况：

	$x$侧的状态是$dp[x][i][0][1]$，这时候反正$x$已经被监听了，$v$放不放装置都无所谓，但是必须保证$v$是被监听的，所以贡献是$dp[x][i][0][1]*(dp[v][j][0][1]+dp[v][j][1][1])$
    
    $x$侧的状态是$dp[x][i][0][0]$，这时候监听$x$的重任就要交给$v$了，同时$v$自己必须是被监听的，所以贡献是$dp[x][i][0][0]*dp[v][j][1][1]$

	因此$dp[x][i+j][0][1]=\sum (dp[x][i][0][1]*(dp[v][j][0][1]+dp[v][j][1][1])+dp[x][i][0][0]*dp[v][j][1][1])$

- 如果$x$既放了装置又被监听，同样要分两种情况：

	$x$侧的状态是$dp[x][i][1][0]$，需要让$v$来监听$x$，但是$v$是否被监听无所谓，因为$x$上放了装置可以保证$v$被监听，所以贡献是$dp[x][i][1][0]*(dp[v][j][1][0]+dp[v][j][1][1])$

	$x$侧的状态是$dp[x][i][1][1]$，这时候$x$的所有要求都满足了，$v$怎么样都行，贡献是$dp[x][i][1][1]*(dp[v][j][0][0]+dp[v][j][0][1]+dp[v][j][1][0]+dp[v][j][1][1])$

	因此$dp[x][i+j][1][1]=\sum (dp[x][i][1][0]*(dp[v][j][1][0]+dp[v][j][1][1])+dp[x][i][1][1]*(dp[v][j][0][0]+dp[v][j][0][1]+dp[v][j][1][0]+dp[v][j][1][1]))$

整理一下：

$dp[x][i+j][0][0]=\sum dp[x][i][0][0]*dp[v][j][0][1]$

$dp[x][i+j][1][0]=\sum dp[x][i][1][0]*(dp[v][j][0][0]+dp[v][j][0][1])$

$dp[x][i+j][0][1]=\sum (dp[x][i][0][1]*(dp[v][j][0][1]+dp[v][j][1][1])+dp[x][i][0][0]*dp[v][j][1][1])$

$dp[x][i+j][1][1]=\sum (dp[x][i][1][0]*(dp[v][j][1][0]+dp[v][j][1][1])+dp[x][i][1][1]*(dp[v][j][0][0]+dp[v][j][0][1]+dp[v][j][1][0]+dp[v][j][1][1]))$

~~不是很长对吧~~

小心：这题dp数组开long long是会MLE的，要中间运算过程中转long long然后再转回int

就差不多了

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>
#include <vector>

template <typename T> inline void read(T& t) {
    int f = 0, c = getchar(); t = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
    if (f) t = -t;
}
template <typename T> inline bool chkMin(T& x, const T& y) { return y < x ? (x = y, true) : false; }
template <typename T> inline bool chkMax(T& x, const T& y) { return x < y ? (x = y, true) : false; }
#ifdef WIN32
#define LLIO "%I64d"
#else
#define LLIO "%lld"
#endif	// WIN32 long long
#define rep(I, A, B) for (int I = (A); I <= (B); ++I)
#define dwn(I, A, B) for (int I = (A); I >= (B); --I)
#define erp(I, X) for (int I = head[X]; I; I = next[I])

const int maxn = 1e5 + 7;
const long long mod = 1e9 + 7;
std::vector<int> G[maxn];
int dp[maxn][107][2][2], tmp[107][2][2];
int size[maxn];
int n, K;

inline int add(int x, long long y) {
    if (y >= mod) y %= mod;
    for (x += y; x >= mod; x -= mod);
    return x;
}
inline void ae(int x, int y) {
    G[x].push_back(y);
    G[y].push_back(x);
}
void dfs(int x, int fa) {
    size[x] = dp[x][0][0][0] = dp[x][1][1][0] = 1;
    for (unsigned e = 0; e < G[x].size(); ++e) {
        int v = G[x][e];
        if (v != fa) {
            dfs(v, x);
            rep(i, 0, std::min(size[x], K)) {
                tmp[i][0][0] = dp[x][i][0][0]; dp[x][i][0][0] = 0;
                tmp[i][0][1] = dp[x][i][0][1]; dp[x][i][0][1] = 0;
                tmp[i][1][0] = dp[x][i][1][0]; dp[x][i][1][0] = 0;
                tmp[i][1][1] = dp[x][i][1][1]; dp[x][i][1][1] = 0;
            }
            rep(i, 0, std::min(size[x], K))
                rep(j, 0, std::min(size[v], K - i)) {
                    dp[x][i + j][0][0] = add(dp[x][i + j][0][0], 1ll * tmp[i][0][0] * dp[v][j][0][1]);

                    dp[x][i + j][0][1] = add(dp[x][i + j][0][1], 1ll * tmp[i][0][1] * (dp[v][j][0][1] + dp[v][j][1][1]));
                    dp[x][i + j][0][1] = add(dp[x][i + j][0][1], 1ll * tmp[i][0][0] * dp[v][j][1][1]);

                    dp[x][i + j][1][0] = add(dp[x][i + j][1][0], 1ll * tmp[i][1][0] * (dp[v][j][0][0] + dp[v][j][0][1]));

                    dp[x][i + j][1][1] = add(dp[x][i + j][1][1], 1ll * tmp[i][1][0] * (dp[v][j][1][0] + dp[v][j][1][1]));
                    dp[x][i + j][1][1] = add(dp[x][i + j][1][1], 1ll * tmp[i][1][1] * (1ll * dp[v][j][0][0] + dp[v][j][0][1] + 1ll * dp[v][j][1][0] + dp[v][j][1][1]));
                }
                size[x] += size[v];
        }
    }
}

int main() {
    read(n); read(K);
    rep(i, 1, n - 1) {
        int x, y;
        read(x); read(y); ae(x, y);
    }
    dfs(1, 0);
    printf("%d\n", (int)((dp[1][K][0][1] + dp[1][K][1][1]) % mod));
    return 0;
}
```

---

## 作者：yybyyb (赞：61)

不难想到一个沙雕$dp$，设$f[i][j][0/1][0/1]$表示当前点$i$，子树中一共放了$j$个，这个点是否放了，这个是否被覆盖了。  
看起来直接合并是$O(nk^2)$的QwQ。。。。。  
然后我以为是$O(nk^2)$的就不会做了嘤嘤嘤。  
实际上是$O(nk)$的。。。  
证明大概是这样的（为啥泥萌都不证明一下复杂度的啊）：  
考虑什么时候会产生$O(k^2)$的贡献，即一个点有两棵子树的大小大于$k$，而这样子合并次数不会超过$O(\frac{n}{k})$，所以这部分的复杂度是$O(nk)$的。  
另外一种情况是一个子树小于$k$，经过合并之后变成大于$k$的子树了，显然对于一个点，如果它的子树小于$k$，在某次合并之后它的子树就会大于$k$，并且对于每个点而言，只会在他的某个祖先的地方经历一次这样子的合并，所以这样子均摊每个点会产生$O(k)$的贡献。  
第三种情况是两个点的子树大小都小于$k$，合并完之后两者还是小于$k$。这个操作理解为每个两个集合中的点一一对应的产生一次贡献，那么盯着某一个特定点考虑，它每次产生的贡献是合并进来的子树大小的，因为在这一部分的过程中子树大小总是小于$k$，因此每个点产生的贡献也最多是$O(k)$的。  
综上，在三种合并情况中，每种情况产生的贡献都最多是$O(nk)$的，所以全局的复杂度就是$O(nk)$。  

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define MAX 100100
#define MOD 1000000007
void add(int &x,int y){x+=y;if(x>=MOD)x-=MOD;}
inline int read()
{
	int x=0;bool t=false;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')t=true,ch=getchar();
	while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
	return t?-x:x;
}
struct Line{int v,next;}e[MAX<<1];
int h[MAX],cnt=1;
inline void Add(int u,int v){e[cnt]=(Line){v,h[u]};h[u]=cnt++;}
int n,K,f[MAX][101][2][2],size[MAX];
int tmp[101][2][2];
void dfs(int u,int ff)
{
	size[u]=1;f[u][0][0][0]=1;f[u][1][1][0]=1;
	for(int i=h[u];i;i=e[i].next)
	{
		int v=e[i].v;if(v==ff)continue;dfs(v,u);
		for(int j=0;j<=size[u]&&j<=K;++j)
			for(int k=0;k<=size[v]&&j+k<=K;++k)
			{
				if(f[u][j][0][0])
				{
					add(tmp[j+k][0][0],1ll*f[u][j][0][0]*f[v][k][0][1]%MOD);
					add(tmp[j+k][0][1],1ll*f[u][j][0][0]*f[v][k][1][1]%MOD);
				}
				if(f[u][j][0][1])
				{
					add(tmp[j+k][0][1],1ll*f[u][j][0][1]*(f[v][k][0][1]+f[v][k][1][1])%MOD);
				}
				if(f[u][j][1][0])
				{
					add(tmp[j+k][1][0],1ll*f[u][j][1][0]*(f[v][k][0][0]+f[v][k][0][1])%MOD);
					add(tmp[j+k][1][1],1ll*f[u][j][1][0]*(f[v][k][1][0]+f[v][k][1][1])%MOD);
				}
				if(f[u][j][1][1])
				{
					int s=0;
					add(s,f[v][k][0][0]);add(s,f[v][k][0][1]);
					add(s,f[v][k][1][0]);add(s,f[v][k][1][1]);
					add(tmp[j+k][1][1],1ll*f[u][j][1][1]*s%MOD);
				}
			}
		size[u]+=size[v];
		for(int j=0;j<=size[u]&&j<=K;++j)
		{
			f[u][j][0][0]=tmp[j][0][0];tmp[j][0][0]=0;
			f[u][j][0][1]=tmp[j][0][1];tmp[j][0][1]=0;
			f[u][j][1][0]=tmp[j][1][0];tmp[j][1][0]=0;
			f[u][j][1][1]=tmp[j][1][1];tmp[j][1][1]=0;
		}
	}
}
int main()
{
	n=read();K=read();
	for(int i=1,u,v;i<n;++i)u=read(),v=read(),Add(u,v),Add(v,u);
	dfs(1,0);
	int ans=(f[1][K][0][1]+f[1][K][1][1])%MOD;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Kewth (赞：47)

大家都是四维 DP $f[u][k][0/1][0/1]$ ，这题难就难在上下界优化的复杂度分析和转移。 
上下界优化的复杂度分析就不细讲了，关键点在于进行 $O(k^2)$ 的背包转移的次数的是 $O(\frac{n}{k})$ 的。

而转移我想说这么多 `01` 写起来不累嘛。。。

事实上对于这个 `01` 可以用变量表示，假设当前合并两个背包 $f[u][a][p1][q1]$ 和 $f[v][b][p2][q2]$ ，  
其中 $v$ 是 $u$ 的儿子。

考虑合并后的 $f[u][a+b][p3][q3]$ ，$p3$ 和 $q3$ 分别会是什么，以及这个合并什么时候合法。

$p3$ 是合并后点 $u$ 是否安装监听器，这显然不受 $v$ 影响，也就是说 $p3=p1$ 。

$q3$ 是合并后点 $u$ 是否被监听，有两种情况：$u$ 之前已经被监听，$u$ 现在被 $v$ 监听。即：$q3=q1|p2$ 。

但是不是所有状态都能合并的，可以合并当且仅当 $v$ 被监听，  
$v$ 被监听同样有两种情况：$v$ 之前被监听，$v$ 现在被 $u$ 监听。  
也就是说当且仅当 $q2|p1=1$ 时这两个状态可以合并。

于是得到一个清爽的 4 个 for 转移：

```cpp
for(int p1 = 0; p1 < 2; p1 ++)
	for(int q1 = 0; q1 < 2; q1 ++)
		for(int p2 = 0; p2 < 2; p2 ++)
			for(int q2 = 0; q2 < 2; q2 ++)
				if(q2 | p1)
					(newf_u[a + b][p1][q1 | p2] +=
							f[u][a][p1][q1] * f[v][b][p2][q2]) %= mod;
```

这样不容易写错，如果全写 `01` 手动枚举所有情况，很容易漏算或者写错一个 `01` 之类的，  
而且很难调试。

完整实现：
```cpp
#include <cstdio>
#include <vector>

typedef long long ll;

const int maxn = 100005, maxk = 104, mod = 1000000007;
int f[maxn][maxk][2][2];
int g[maxk][2][2];
int lim[maxn];
std::vector<int> G[maxn];

inline void __a(int &x) { if(x >= mod) x -= mod; }

int N, K;
void dp(int u, int fa) {
	f[u][0][0][0] = 1;
	f[u][1][1][0] = 1;
	lim[u] = 1;

	for(int v : G[u])
		if(v != fa) {
			dp(v, u);

			int nlim = std::min(lim[u] + lim[v], K);
			for(int a = 0; a <= lim[u]; a ++)
				for(int b = 0; b <= lim[v] and a + b <= nlim; b ++) {
					for(int p1 = 0; p1 < 2; p1 ++)
						for(int q1 = 0; q1 < 2; q1 ++)
							for(int p2 = 0; p2 < 2; p2 ++)
								for(int q2 = 0; q2 < 2; q2 ++)
									if(q2 | p1)
										__a(g[a + b][p1][q1 | p2] +=
										 1ll * f[u][a][p1][q1] * f[v][b][p2][q2] % mod);
				}

			for(int k = 0; k <= nlim; k ++)
				for(int p = 0; p < 2; p ++)
					for(int q = 0; q < 2; q ++)
						f[u][k][p][q] = g[k][p][q];
			for(int k = 0; k <= nlim; k ++)
				g[k][0][0] = g[k][0][1] = g[k][1][0] = g[k][1][1] = 0;
			lim[u] = nlim;
		}
}

int main() {
	scanf("%d %d", &N, &K);
	for(int i = 1; i < N; i ++) {
		int u, v;
		scanf("%d %d", &u, &v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dp(1, 0);
	printf("%d\n", (f[1][K][0][1] + f[1][K][1][1]) % mod);
}
```


---

## 作者：tth37 (赞：22)

这是一个并不简单的背包类树形dp……

~~很自然地~~想到状态定义：$f[u][k][0/1][0/1]$表示以$u$为根的子树中，总共选择$k$个结点，其中除了$u$以外的所有结点均被监听到，$u$结点选或不选，$u$结点是否被覆盖的情况下，一共有多少种方案。

状态转移看似十分麻烦。每个结点$u$都有许多子结点，很难统计出每个子结点的所有情况（似乎在组合数学的范畴）。但是我们可以用十分巧妙的树形背包来进行状态转移。树上背包的转移套路是：

$$
f[u][i+j]=combine(f[u][i],f[v][j])
$$

相当于每递归访问完一个子结点，就把子节点上的状态与当前已经处理的状态一一配对，保证不重不漏且兼顾效率。具体的转移方程为：

$$
f[u][i+j][0][0]=\sum f[u][i][0][0]*f[v][j][0][1]
$$

$$
f[u][i+j][1][0]=\sum f[u][i][1][0]*(f[v][j][0][0]+f[v][j][0][1])
$$

$$
f[u][i+j][0][1]=\sum (f[u][i][0][1]\*(f[v][j][0][1]+f[v][j][1][1])+f[u][i][0][0]\*f[v][j][1][1]
$$

$$
f[u][i+j][1][1]=\sum (f[u][i][1][0]\*(f[v][j][1][0]+f[v][j][1][1])+f[u][i][1][1]\*(f[v][j][0][0]+f[v][j][0][1]+f[v][j][1][0]+f[v][j][1][1]))
$$

具体实现时还应注意：因为阶段（即扫描子结点个数）的划分，在每次转移前都要先记录原始的$u$结点上的数据，否则会导致混乱。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int MAXN=100005;
const int mod=1000000007;

int N,K;
int f[MAXN][105][2][2];
int g[105][2][2];
int size[MAXN];

vector<int> G[MAXN];

inline int Mod(ll x,ll y){
    x%=mod,y%=mod;
    return (int)(x+y)%mod;
}

void dp(int u,int fa){
    size[u]=1;
    f[u][0][0][0]=f[u][1][1][0]=1;
    for(vector<int>::iterator it=G[u].begin();it!=G[u].end();it++){
        int v=*it;
        if(v==fa) continue;
        dp(v,u);
        for(register int i=0;i<=min(size[u],K);++i){
            g[i][0][0]=f[u][i][0][0],f[u][i][0][0]=0;
            g[i][0][1]=f[u][i][0][1],f[u][i][0][1]=0;
            g[i][1][0]=f[u][i][1][0],f[u][i][1][0]=0;
            g[i][1][1]=f[u][i][1][1],f[u][i][1][1]=0;
        }
        for(register int i=0;i<=min(size[u],K);++i){
            for(register int j=0;j<=min(size[v],K-i);++j){
                f[u][i+j][0][0]=Mod((ll)f[u][i+j][0][0],(ll)g[i][0][0]*(ll)f[v][j][0][1]);
                f[u][i+j][0][1]=Mod((ll)f[u][i+j][0][1],(ll)g[i][0][0]*(ll)f[v][j][1][1]+(ll)g[i][0][1]*((ll)f[v][j][1][1]+(ll)f[v][j][0][1]));
                f[u][i+j][1][0]=Mod((ll)f[u][i+j][1][0],(ll)g[i][1][0]*((ll)f[v][j][0][0]+(ll)f[v][j][0][1]));
                f[u][i+j][1][1]=Mod((ll)f[u][i+j][1][1],(ll)g[i][1][0]*((ll)f[v][j][1][0]+(ll)f[v][j][1][1])+(ll)g[i][1][1]*((ll)f[v][j][0][0]+(ll)f[v][j][0][1]+(ll)f[v][j][1][0]+(ll)f[v][j][1][1]));
            }
        }
        size[u]+=size[v];
    }
}

int main(){
    scanf("%d%d",&N,&K);
    for(register int i=1;i<N;++i){
        int u,v;
        scanf("%d%d",&u,&v);
        G[u].push_back(v);
        G[v].push_back(u);
    }
    dp(1,0);
    printf("%d",(int)(f[1][K][0][1]+f[1][K][1][1])%mod);
    return 0;
}
```

---

## 作者：yangwenbin (赞：17)

[P4516 [JSOI2018]潜入行动](https://www.luogu.com.cn/problem/P4516)

这是一道树上背包的题目，很离谱（昨天人让一个大佬教我，才勉强看懂）

首先定义一个数组

$ dp [u] [i] [0/1] [0/1] \implies $ 以 $u$ 为根节点的子树，在放了 $i$ 个监视器,保证全部的子树上点都被监视到的情况下，带点 $u$ 上放与不放监视器，且是否被监视到。

在看出背包后，我们去寻找转移方程，

现在假设，我们已将查询到了以 $u$ 为根节点的树 $k$ ，此时发现了这个树的下方还有一个还有以 $v$ 为根节点的子树 $f$，于是把这个子树就并列过来。如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/4y91ygow.png)


------------

$$
\forall dp[u][i][0][0]
$$

$u$点没有被放置，且没有被监视到

所以 $v$ 点处必然不能放监视器，但不影响 $v$ 点被监听

$$
\therefore dp[u][i+j][0][0] = \sum dp[u][i][0][0] \times dp[v][j][0][1]
$$

------------

$$
\forall dp[u][i][0][1]
$$

这种情况要分类讨论：

- $u$ 一侧子树的状态为 $dp[u][i][0][1]$

这时候 $u$ 已经被监视了，所以在不在 $v$ 处放监视器，已经无伤大雅了，但是要保证每个点都被监视到所以 $v$ 点必须被监视


- $u$ 一侧子树的状态为 $dp[u][i][0][0]$

这时候 $u$ 还没被监视，所以一定要在 $v$ 处放监视器，同时要保证每个点都被监视到所以 $v$ 点也必须被监视

$$
\therefore dp[u][i+j][0][1] = \sum (dp[u][i][0][1] \times (dp[v][j][0][1] + dp[v][j][1][1]) + dp[u][i][0][0] \times dp[v][j][1][1])
$$

------------

$$
\forall dp[u][i][1][0]
$$

 $u$ 没被监视但是放了监视器，所以 $u$ 一侧子树的状态一定是 $dp[u][i][1][0]$， $v$ 是否被监视无所谓，但是一定不能放装置

$$
\therefore dp[u][i+j][1][0] = \sum dp[u][i][1][0] \times (dp[v][j][0][0] + dp[v][j][0][1])
$$

------------

$$
\forall dp[u][i][1][1]
$$

这种情况也要分类讨论：


- $u$ 一侧子树的状态为 $dp[u][i][1][0]$

所以要让 $v$ 点上放监视器来监视 $u$ 但是 $v$ 点没有必要被监听

- $u$ 一侧子树的状态为 $dp[u][i][1][1]$

$u$ 已经被 $k$ 侧子树满足了，所以对于 $v$ 来说可以随便选

$$
\therefore dp[u][i+j][1][1] = \sum (dp[u][i][1][0] \times (dp[v][j][1][0] + dp[v][j][1][1]) + dp[u][i][1][1] * (dp[v][j][0][0] + dp[v][j][0][1] + dp[v][j][1][0] + dp[v][j][1][1]))
$$

------------

综上所述

$dp[u][i+j][0][0] = \sum dp[u][i][0][0] \times dp[v][j][0][1]$

$dp[u][i+j][0][1] = \sum (dp[u][i][0][1] \times (dp[v][j][0][1] + dp[v][j][1][1]) + dp[u][i][0][0] \times dp[v][j][1][1])$

$dp[u][i+j][1][0] = \sum dp[u][i][1][0] \times (dp[v][j][0][0] + dp[v][j][0][1])$

$dp[u][i+j][1][1] = \sum (dp[u][i][1][0] \times (dp[v][j][1][0] + dp[v][j][1][1]) + dp[u][i][1][1] * (dp[v][j][0][0] + dp[v][j][0][1] + dp[v][j][1][0] + dp[v][j][1][1]))$


------------

# code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int SIZE = 1e5 + 7;
const int NUM = 107;
const int mod = 1e9 + 7;

inline int read()
{
	int x = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9')
		ch = getchar();
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x;
}

int n,k,num_edge;
int head[SIZE],siz[SIZE];
int dp[SIZE][NUM][2][2],tmp[NUM][2][2];
struct node
{
	int to,nxt;
};
node edge[SIZE << 1];

inline void add(int u,int v)
{
	edge[++num_edge].to = v;
	edge[num_edge].nxt = head[u];
	head[u] = num_edge;
}

inline int solve(int u,long long v)
{
	if (v >= mod) v = v % mod;
	for (u += v; u >= mod; u -= mod);
	return u;
}

void dfs(int u,int fa)
{
	siz[u] = dp[u][0][0][0] = dp[u][1][1][0] = 1;
	for (int t = head[u]; t ; t = edge[t].nxt)
	{
		int v = edge[t].to;
		if (v == fa) continue;
		dfs(v,u);
		int side = min(siz[u],k);
		for (int i = 0; i <= side; ++i)
		{
			tmp[i][0][0] = dp[u][i][0][0];
			dp[u][i][0][0] = 0;
			tmp[i][0][1] = dp[u][i][0][1];
			dp[u][i][0][1] = 0;
			tmp[i][1][0] = dp[u][i][1][0];
			dp[u][i][1][0] = 0;
			tmp[i][1][1] = dp[u][i][1][1];
			dp[u][i][1][1] = 0;
		}
		for (int i = 0; i <= side; ++i)
		{
			int limit = min(siz[v],k-i);
			for (int j = 0; j <= limit; ++j)
			{
				dp[u][i+j][0][0] = solve(dp[u][i+j][0][0],1ll * tmp[i][0][0] * dp[v][j][0][1]);
				dp[u][i+j][0][1] = solve(dp[u][i+j][0][1],1ll * tmp[i][0][1] * (dp[v][j][0][1] + dp[v][j][1][1]));
				dp[u][i+j][0][1] = solve(dp[u][i+j][0][1],1ll * tmp[i][0][0] * dp[v][j][1][1]);
				dp[u][i+j][1][0] = solve(dp[u][i+j][1][0],1ll * tmp[i][1][0] * (dp[v][j][0][0] + dp[v][j][0][1]));
				dp[u][i+j][1][1] = solve(dp[u][i+j][1][1],1ll * tmp[i][1][0] * (dp[v][j][1][0] + dp[v][j][1][1]));
				dp[u][i+j][1][1] = solve(dp[u][i+j][1][1],1ll * tmp[i][1][1] * (1ll * dp[v][j][0][0] + 1ll * dp[v][j][0][1] + 1ll * dp[v][j][1][0] + 1ll * dp[v][j][1][1]));
			}
		}
		siz[u] += siz[v];
	}
}
int main()
{
	n = read();k = read();
	for (int i = 1; i < n; ++i)
	{
		int u = read(),v = read();
		add(u,v);
		add(v,u);
	}
	dfs(1,0);
	printf("%d\n",(dp[1][k][0][1] + dp[1][k][1][1]) % mod);
	return 0;
}
```

注意这道题卡空间,运算时先转成 $long $ $long$ 之后再转回来。

---

## 作者：Piwry (赞：13)

这里着重分析下没什么人讲的复杂度（也是本题的重点）

## 解析

状态设计和背包部分已经很多人讲了，并且都很平凡

这里就着重分析下程序的复杂度

首先背包部分代码差不多这样：

```cpp
void dfs(int u, int fa){
	siz[u] =1;
	dp[u][0][0][0] =1;
	if(k > 0)
		dp[u][1][1][0] =1;
	for(int l =first[u]; l; l =e[l].net)
		if(e[l].to != fa){
			dfs(e[l].to, u);
			for(int i =0; i <= min(siz[u], k); ++i){/*保存上一次 dp 值*/
				/*...*/
			}
			for(int i =0; i <= min(siz[u], k); ++i)
				for(int j =0; j <= min(siz[e[l].to], k) && i+j <= k; ++j){
					/*...*/
				}
			siz[u] +=siz[e[l].to];
		}
}
```

我们先做出树的 dfs 序

考虑合并两段序列 $A,B$（$A$ 在左，$B$ 在后），其复杂度为 $O(\min(|A|,k)\cdot \min(|B|,k))$；可以理解为从序列 $A$ 选出后（至多） $k$ 个，从 $B $ 选出前 $k$ 个，然后它们两两配对起来的方案数

考虑一个点的贡献，显然它只会和 dfs 序相邻的左右 $2k$ 个（共 $4k$）个点匹配

接着我们考虑一对点会不会被多次匹配。当一对点被匹配时，它们在序列中差不多是这样的：

![mark](https://cdn.luogu.com.cn/upload/image_hosting/ckz0kktk.png)

如果这对点被多次匹配，就相当于左右移动调整序列的方框（及断点），并使这两个点仍旧在中间 $2k$ 方框内

我们可能产生的方框与配对点在图中的表现总是这三种之一：

![inmap](https://cdn.luogu.com.cn/upload/image_hosting/1yq9j4an.png)

而无论方框如何调整，显然都不可能满足上面的三种情况

非形式化的讲，首先由于 dfs 序，我们在 dfs 中子树的合并顺序是唯一的，因此情况三左侧的 “子树集合” 的状态也是唯一的；同时这也确定了子树的先后顺序

对于情况二、三只有两个配对点的 lca 作为蓝色结点才能满足要求；对于情况一也同理

由此可得一对点不会被重复统计贡献

总的复杂度就是 $O(nk)$

&nbsp;

_[参考](https://www.luogu.com.cn/blog/i207M/shu-xing-bei-bao-di-fu-za-du-cf1097g-vladislav-and-a-great-legend-xi)_ ，这貌似还是个挺实用的 trick，需要满足背包容量受子树大小限制（例如一些染色选取放置问题等）

## CODE

注意用 vector 可以大大加快程序在本题的速度

大致原因：

> “然后观察数据，$n$ 远大于 $k$，如果树太深答案一定是 $0$，出题人可能不想让输出 $0$ 的人拿高分，那么这颗树节点的度数大概率非常大，近似一个菊花图。
这时再写链表显然是不明智的做法，利用 vector 内存连续的特性，一般情况下比链表要快了。就不会出现提交记录里面的一片 $80$ 分，开 O2 后 $100$ 分的尴尬情况。”

[详见](https://www.luogu.com.cn/blog/user37070/solution-p4516)

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#pragma GCC optimize("O3")
#pragma GCC optimize("Ofast","-funroll-loops","-fdelete-null-pointer-checks")
#pragma GCC target("ssse3","sse3","sse2","sse","avx2","avx")
/*用 vector 就不需要优化了*/
using std::min;

const int MAXN =1e5+50;
const int M =1e9+7;

/*------------------------------Map------------------------------*/

int first[MAXN], tote;
struct edge{
	int net, to;
}e[MAXN<<1];

inline void addedge(int u, int v){
	++tote;
	e[tote].to =v, e[tote].net =first[u];
	first[u] =tote;
	++tote;
	e[tote].to =u, e[tote].net =first[v];
	first[v] =tote;
}

/*------------------------------Dfs------------------------------*/

int n, k;
int dp[MAXN][110][2][2]/*已经放几个，该点放了没，该点是否被监测*/, dppre[110][2][2];
int siz[MAXN];

inline int plus(int a, int b){ return (a+b >= M) ? a-M+b : a+b; }

void dfs(int u, int fa){
	siz[u] =1;
	dp[u][0][0][0] =1;
	if(k > 0)
		dp[u][1][1][0] =1;
	for(int l =first[u]; l; l =e[l].net)
		if(e[l].to != fa){
			dfs(e[l].to, u);
			for(int i =0; i <= min(siz[u], k); ++i){
				dppre[i][0][0] =dp[u][i][0][0], dp[u][i][0][0] =0;
				dppre[i][0][1] =dp[u][i][0][1], dp[u][i][0][1] =0;
				dppre[i][1][0] =dp[u][i][1][0], dp[u][i][1][0] =0;
				dppre[i][1][1] =dp[u][i][1][1], dp[u][i][1][1] =0;
			}
			for(int i =0; i <= min(siz[u], k); ++i)
				for(int j =0; j <= min(siz[e[l].to], k) && i+j <= k; ++j){
					dp[u][i+j][0][0] =plus(dp[u][i+j][0][0], 1ll*dppre[i][0][0]*dp[e[l].to][j][0][1]%M);
					dp[u][i+j][0][1] =plus(dp[u][i+j][0][1], 1ll*dppre[i][0][0]*dp[e[l].to][j][1][1]%M);
					dp[u][i+j][0][1] =plus(dp[u][i+j][0][1], 1ll*dppre[i][0][1]*dp[e[l].to][j][0][1]%M);
					dp[u][i+j][0][1] =plus(dp[u][i+j][0][1], 1ll*dppre[i][0][1]*dp[e[l].to][j][1][1]%M);
					dp[u][i+j][1][0] =plus(dp[u][i+j][1][0], 1ll*dppre[i][1][0]*dp[e[l].to][j][0][0]%M);
					dp[u][i+j][1][0] =plus(dp[u][i+j][1][0], 1ll*dppre[i][1][0]*dp[e[l].to][j][0][1]%M);
					dp[u][i+j][1][1] =plus(dp[u][i+j][1][1], 1ll*dppre[i][1][0]*dp[e[l].to][j][1][0]%M);
					dp[u][i+j][1][1] =plus(dp[u][i+j][1][1], 1ll*dppre[i][1][0]*dp[e[l].to][j][1][1]%M);
					dp[u][i+j][1][1] =plus(dp[u][i+j][1][1], 1ll*dppre[i][1][1]*dp[e[l].to][j][0][0]%M);
					dp[u][i+j][1][1] =plus(dp[u][i+j][1][1], 1ll*dppre[i][1][1]*dp[e[l].to][j][0][1]%M);
					dp[u][i+j][1][1] =plus(dp[u][i+j][1][1], 1ll*dppre[i][1][1]*dp[e[l].to][j][1][0]%M);
					dp[u][i+j][1][1] =plus(dp[u][i+j][1][1], 1ll*dppre[i][1][1]*dp[e[l].to][j][1][1]%M);
				}
			siz[u] +=siz[e[l].to];/*注意这行代码 ( 在本程序中 ) 必须放在转移后面，不然复杂度就错了*/
		}
}

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

int main(){
	n =read(), k =read();
	for(int i =0; i < n-1; ++i){
		int u =read(), v =read();
		addedge(u, v);
	}
	dfs(1, 0);
	printf("%d", plus(dp[1][k][0][1], dp[1][k][1][1]));
}
```

---

## 作者：Equfix (赞：8)

~~树形DP~~

~~树上背包~~

首先，确定一下状态：$dp[i][k][0/1][0/1]$ 代表是以第 $i$ 个节点为树根，其中放了 $k$ 个特工，该节点被父亲 / 儿子观察，该节点放 / 不放特工。\
其中，为确保状态不重，状态 $(i,k,0,0/1)$ 的所有儿子均不可放特工。\
确定状态之后，我们来看转移。


------------

## 【转移】
#### 先说 $dp[i][k][0][0]$。
对于儿子 $v$,应该有前面放 $k-j$ 个成立的方案数 $\times $ $v$ 节点放 $j$ 个、被儿子看、自身不放的方案数，即 $dp[i][k][0][0]=\sum dp[i][k-j][0][0]\ \times \ dp[v][j][1][0]$。

#### 二说 $dp[i][k][0][1]$。
对于儿子 $v$,应该有前面放 $k-j$ 个成立的方案数 $\times $ $v$ 节点放 $j$ 个、被父亲 / 儿子看、自身不放的方案数，即 $dp[i][k][0][1]=\sum dp[i][k-j][0][1] \times (dp[v][j][1][0]+dp[v][j][0][0])$。

#### 三说 $dp[i][k][1][0]$。
对于儿子 $v$,应该有：\
1.前面放 $k-j$ 个成立的方案数 $\times $ $v$ 节点放 $j$ 个、被儿子看、自身放 / 不放的方案数；\
2.前面放 $k-j$ 个，但 $i$ 号节点仍未被观察的方案数 $* $ $v$ 节点放 $j$ 个、被儿子看、自身放的方案数；\
即：$dp[i][k][1][0]=\sum (dp[i][k-j][1][0] \times (dp[v][j][1][0]+dp[v][j][1][1]) + dp[i][k-j][0][0] \times dp[v][j][1][1])$

#### 最后说 $dp[i][k][1][1]$。
对于儿子 $v$,应该有：\
1.前面放 $k-j$ 个成立的方案数 $\times $ $v$ 节点放 $j$ 个、被父亲 / 儿子看、自身放 / 不放的方案数；\
2.前面放 $k-j$ 个，但 $i$ 号节点仍未被观察的方案数 $* $ $v$ 节点放 $j$ 个、被父亲 / 儿子看、自身放的方案数；\
即：$dp[i][k][1][1]=\sum (dp[i][k-j][1][1] \times (dp[v][j][1][0]+dp[v][j][1][1]+dp[v][j][0][0]+dp[v][j][0][1]) + dp[i][k-j][0][1]* (dp[v][j][1][1]+dp[v][j][0][1])$

最最后，注意 $k$ 倒着枚举,$j$ 从 $0$ 开始枚举，答案是 $dp[root][k][1][0]+dp[root][k][1][1]$ （ $root$ 为将无根树转成有根树时的树根），就可以了。


------------


贴出代码：（因常数过大导致TLE，O2过了）


```cpp
#include <bits/stdc++.h>
using namespace std;
int w;//题目中的k
const int mod = 1e9 + 7;
vector<int>e[100001];//建树
int size[100001];//子树大小
unsigned int dp[100001][101][2][2];//long long 会MLE

void dfs1(int i, int fa) {
	size[i] = 1;
	for (int j = 0; j < e[i].size(); j++)
		if (e[i][j] != fa) {
			dfs1(e[i][j], i);
			size[i] += size[e[i][j]];
		}
}

void dfs2(int i, int fa) {
	for (int j = 0; j < e[i].size(); j++)
		if (e[i][j] != fa)
			dfs2(e[i][j], i);
	dp[i][0][0][0] = dp[i][1][0][1] = 1;
	int qwq = 1;
	for (int j = 1; j <= e[i].size(); j++)//转移
		if (e[i][j - 1] != fa) {
			qwq += size[e[i][j - 1]];
			for (int k = min(w, qwq); k >= 0; k--) {
				unsigned long long int ans1 = 0, ans2 = 0, ans3 = 0, ans4 = 0;
				for (int x = 0; x <= min(k, size[e[i][j - 1]]); x++) {
					int v = e[i][j - 1];
					if (k - x > qwq - size[v])
						continue;
					(ans1 += ((unsigned long long )dp[i][k - x][0][0] *
					          (dp[v][x][1][0]))) %= mod;

					(ans2 += ((unsigned long long )dp[i][k - x][0][1] *
					          (dp[v][x][1][0]
					           + dp[v][x][0][0]))) %= mod;

					(ans3 += ((unsigned long long )dp[i][k - x][1][0] * (dp[v][x][1][0] + dp[v][x][1][1])
					          + (unsigned long long )dp[i][k - x][0][0] * dp[v][x][1][1])) %= mod;

					(ans4 += ((unsigned long long )dp[i][k - x][1][1] * (dp[v][x][1][0] + dp[v][x][0][0]
					                                + dp[v][x][1][1] + dp[v][x][0][1])
					          + (unsigned long long )dp[i][k - x][0][1] * (dp[v][x][1][1] + dp[v][x][0][1]))) %= mod;
				}
				dp[i][k][0][0] = ans1;
				dp[i][k][0][1] = ans2;
				dp[i][k][1][0] = ans3;
				dp[i][k][1][1] = ans4;
			}

		}
}

int main() {
	int n;
	cin >> n >> w;
	for (int i = 1; i < n; i++) {
		int a, b;
		scanf("%d%d", &a, &b);
		e[a].push_back(b);
		e[b].push_back(a);
	}
	dfs1(1, 0);
	dfs2(1, 0);
	cout << (dp[1][w][1][0] + dp[1][w][1][1]) % mod;
	return 0;
}
```


---

## 作者：Ameyax (赞：7)

简单的树形dp。

设$f[i][j][0/1][0/1]$表示$i$的子树中已安装$j$个装置，$i$是/否安装，是/否被控制的方案数，dp方程随便推推注意下细节就行。

复杂度$O(nk)$

然后观察数据，$n$远大于$k$，如果树太深答案一定是$0$，出题人可能不想让输出$0$的人拿高分，那么这颗树节点的度数大概率非常大，近似一个菊花图。

这时再写链表显然是不明智的做法，利用vector内存连续的特性，一般情况下比链表要快了。就不会出现提交记录里面的一片$80$分，开O2后$100$分的尴尬情况。

现在各大比赛纷纷支持C++11，还开O2，以后存图是不是都不用写链表了（雾

[虽然这里面没有这篇题解但我还是要放出来！](http://blog-wayne.com/)

```cpp
void dfs(int u, int fa) {
    siz[u] = 1;
    f[u][0][0][0] = f[u][1][1][0] = 1;
    for (auto v : E[u])
        if (v != fa) {
            dfs(v, u);
            for (int i = 0, lim = min(siz[u], k); i <= lim; i++) {
                g[i][0][0] = f[u][i][0][0], f[u][i][0][0] = 0;
                g[i][0][1] = f[u][i][0][1], f[u][i][0][1] = 0;
                g[i][1][0] = f[u][i][1][0], f[u][i][1][0] = 0;
                g[i][1][1] = f[u][i][1][1], f[u][i][1][1] = 0;
            }
            //这样大概，可能，也许比两个循环要快那么一点点吧。
            for (int i = 0, lim = min(siz[u], k); i <= lim; i++)
                for (int j = 0, lim2 = min(siz[v], k); j <= lim2 && i + j <= k; j++) {
                    add(f[u][i + j][0][0], g[i][0][0] * f[v][j][0][1]);
                    add(f[u][i + j][0][1], g[i][0][1] * (f[v][j][0][1] + f[v][j][1][1]) + g[i][0][0] * f[v][j][1][1]);
                    add(f[u][i + j][1][0], g[i][1][0] * (f[v][j][0][0] + f[v][j][0][1]));
                    add(f[u][i + j][1][1], g[i][1][0] * (f[v][j][1][0] + f[v][j][1][1]) + g[i][1][1] * ((ll)f[v][j][0][0] + f[v][j][0][1] + f[v][j][1][0] + f[v][j][1][1]));
                }
            siz[u] += siz[v];
        }
}
```

---

## 作者：陈学威 (赞：6)

我看见有帅哥说这道题是简单的树形dp
。。。有点沉默

设 $f[i][j][0/1][0/1] $表示i的子树中已安装j个装置， i是/否安装，是/否被控制的方案数，
方程过长懒得解释，这道题难就难在要打的东西太多很容易出错

然后要注意，很容易爆空间和时间，数组开int，虽然dp过程中会爆int，但是数组要开int不然会爆，然后在dp的时候强制转long long。
这个地方我调试了好久

```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
typedef long long ll;
const int mod=1e9+7;
int N,K,f[100010][105][2][2],size[100010],front[100010];long long g[105][2][2];
struct tEdge{
    int v,next;
    tEdge(int v=0,int next=0) : v(v) , next(next) {}
}e[200020];
void add(int u,int v)
{
    static int tcnt=0;
    e[++tcnt]=tEdge(v,front[u]);front[u]=tcnt;
}
int mo(int &a,ll b){
    return (a+((int)(b%mod)))%mod;
}
void dfs(int u,int fa){
    size[u]=1;
    f[u][0][0][0]=f[u][1][1][0]=1;
    for(int i=front[u];i;i=e[i].next){
        int v=e[i].v;
        if(v==fa)continue;
        dfs(v,u);
        for(int i=0;i<=min(size[u],K);++i){
          g[i][0][0]=f[u][i][0][0],f[u][i][0][0]=0;
          g[i][0][1]=f[u][i][0][1],f[u][i][0][1]=0;
          g[i][1][0]=f[u][i][1][0],f[u][i][1][0]=0;
          g[i][1][1]=f[u][i][1][1],f[u][i][1][1]=0;
        }
        for(int i=0;i<=min(size[u],K);++i)
            for(int j=0;j<=min(size[v],K-i);++j){
                f[u][i+j][0][0]=mo(f[u][i+j][0][0],(ll)g[i][0][0]*(ll)f[v][j][0][1]);
                f[u][i+j][1][0]=mo(f[u][i+j][1][0],(ll)g[i][1][0]*(ll)(f[v][j][0][0]+f[v][j][0][1]));
                f[u][i+j][0][1]=mo(f[u][i+j][0][1],(ll)g[i][0][0]*(ll)f[v][j][1][1]+(ll)g[i][0][1]*(ll)(f[v][j][0][1]+f[v][j][1][1]));
                f[u][i+j][1][1]=mo(f[u][i+j][1][1],(ll)g[i][1][0]*(ll)(f[v][j][1][1]+f[v][j][1][0])+(ll)g[i][1][1]*(ll)((ll)(f[v][j][0][0]+f[v][j][0][1])+(ll)(f[v][j][1][1]+f[v][j][1][0])));

            }
        size[u]+=size[v];
    }
}
main(){
    scanf("%d%d",&N,&K);
    for(int i=1;i<N;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        add(u,v);add(v,u);
    }
    dfs(1,0);
    printf("%d\n",(f[1][K][1][1]+f[1][K][0][1])%mod);
    return 0;
}
```

---

## 作者：KaisuoShutong (赞：5)

## 题意

略。

## 题解

我们套路地设 $f_{i,j,0/1,0/1}$ 表示 $i$ 的子树中放置了 $j$ 个装置，其中 $i$ 有无放置，$i$ 有无被覆盖 的方案数，做树上背包。

那么，令 $y$ 为当前点，$s$ 为其儿子，$h$ 为转移出的点，我们列出 $16$ 种转移方程（暂且忽略 $j$）：

```txt
y,0,0 + s,0,0 -> x
y,0,0 + s,0,1 -> h,0,0
y,0,0 + s,1,0 -> x
y,0,0 + s,1,1 -> h,0,1

y,0,1 + s,0,0 -> x
y,0,1 + s,0,1 -> h,0,1
y,0,1 + s,1,0 -> x
y,0,1 + s,1,1 -> h,0,1

y,1,0 + s,0,0 -> h,1,0
y,1,0 + s,0,1 -> h,1,0
y,1,0 + s,1,0 -> h,1,1
y,1,0 + s,1,1 -> h,1,1

y,1,1 + s,0,0 -> h,1,1
y,1,1 + s,0,1 -> h,1,1
y,1,1 + s,1,0 -> h,1,1
y,1,1 + s,1,1 -> h,1,1
```

略加思考，我们总结出这些转移式的规律：

$y,a,b ~+~ s,c,d \rightarrow h,a,b~or~c$，要求 $a ~or~ d=1$。

那么做背包即可。注意这样写常数拉满，要开一下 $O2$。

点个赞吧。

参考代码：

```cpp
//伟大的导师，伟大的领袖，伟大的统帅，伟大的舵手
#include<bits/stdc++.h>
using namespace std;
int read() {
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
const int maxn = 1e5+10, mod = 1e9+7;
int f[maxn][110][2][2],t[110][2][2],sz[maxn],n,K;vector<int>G[maxn];
void Add(int&x,int y) {(x+=y)>=mod?x-=mod:x;}
void dfs(int x,int pa) {
	sz[x]=1;f[x][0][0][0]=f[x][1][1][0]=1;
	for(auto y:G[x]) if(y^pa) {
		dfs(y,x);
		for(int i=0;i<=min(K,sz[x]);i++)
			for(int j=0;j<=min(K-i,sz[y]);j++)
				for(int a=0;a<2;a++)
					for(int b=0;b<2;b++)
						for(int c=0;c<2;c++)
							for(int d=0;d<2;d++) if((a|d)==1) Add(t[i+j][a][b|c],1ll*f[x][i][a][b]*f[y][j][c][d]%mod);
		for(int i=0;i<=min(K,sz[x]+sz[y]);i++)
			for(int a=0;a<2;a++)
				for(int b=0;b<2;b++) f[x][i][a][b]=t[i][a][b],t[i][a][b]=0;
		sz[x]+=sz[y];
	}
}
void add(int x,int y) {G[x].push_back(y),G[y].push_back(x);}
signed main() {
	n=read(),K=read();
	for(int i=1;i<n;i++) add(read(),read());
	dfs(1,0),cout<<(f[1][K][0][1]+f[1][K][1][1])%mod;
	return 0;
}
```

---

## 作者：alvis (赞：3)

## $\texttt{Content}$

给一棵 $n$ 个点的树，试选取 $k$ 个点，使得树中的每一个点都至少与该 $k$ 个点中的一个点直接相连。( $k$ 个点中的点不与自身相连 ）

$n \le 10^5,k\le 100$

## $\texttt{Solution}$

可以发现这是一个树形 dp。

**设计状态**：

我一开始想的是设 $f_{0/1,u,i}$ 表示以 $u$ 为根的子树中有 $i$ 个被选取的点，$0/1$ 表示 $u$ 是否选取。

但是后来发现这样设计是不对的。因为这样在转移的过程中会出现后效性。

即我在以 $u$ 为根的子树中选取的点会对我接下来的递推产生影响。

所以说考虑进一步设计状态。一般来说，对于有后效性的一些 dp，我们可以通过增加状态的方式来把后效性干掉。

于是考虑增设一维 $0/1$ 表示点 $u$ 是否被覆盖到。

于是状态 $f_{0/1,0/1,u,i}$ 表示以 $u$ 为根的子树中有 $i$ 个被选取的点，第一个$0/1$ 表示 $u$ 是否选取，第二个 $0/1$ 表示 $u$ 是否被覆盖。

**状态转移**：

在设计出状态以后，转移方程就很好推了。

只需分类讨论即可。

- 当 $u$ 没有被选取，且没有被覆盖。

则

$f_{0,0,u,i+j} =  \sum \limits_{i=0}^k(f_{0,0,u,i} \times f_{0,1,v,j})$

- 当 $u$ 没有被选取，但被覆盖了。

则

$f_{0,1,u,i+j} = \sum \limits_{i=0}^k(f_{0,1,u,i } \times(f_{1,1,v,j} + f_{0,1,v,j}) + f_{0,0,u,i} \times f_{1,1,v,j}) $

- 当 $u$ 被选取，但没有被覆盖。

则

$f_{1,0,u,i+j} = \sum\limits_{i=0}^k(f_{1,0,u,i} \times (f_{0,1,v,j} + f_{0,0,v,j}))$

- 当 $u$ 被选取，且被覆盖。

则

$f_{1,1,u,i+j} =  \sum\limits_{i=0}^k(f_{1,1,u,i} \times (f_{1,1,v,j} + f_{0,1,v,j} + f_{1,0,v,j} + f_{0,0,v,j}) + f_{1,0,u,i}\times (f_{1,1,v,j} + f_{1,0,v,j}))$

## $\texttt{Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5+5, P = 1e9+7;
int n, k;
vector<int> g[N];
int f[2][2][N][101], siz[N], cmp[101][2][2];

//作树上 dp
void dfs(int u, int fa) {
	siz[u] = f[0][0][u][0] = f[1][0][u][1] = 1;
	for(int i = 0;i < g[u].size();i ++) {
		int j = g[u][i];
		if(j == fa) continue;
		dfs(j, u);
		for(int k1 = 0;k1 <= min(k, siz[u]);k1 ++) {
        		//防止在更新过程中多次更新(01背包)
			cmp[k1][0][0] = f[0][0][u][k1];
			f[0][0][u][k1] = 0;
           		cmp[k1][0][1] = f[0][1][u][k1]; 
			f[0][1][u][k1] = 0;
            		cmp[k1][1][0] = f[1][0][u][k1]; 
			f[1][0][u][k1] = 0;
            		cmp[k1][1][1] = f[1][1][u][k1]; 
			f[1][1][u][k1] = 0;
		}
        	//dp过程
		for(int k1 = 0;k1 <= k && k1 <= siz[u];k1 ++) {
			for(int k2 = 0;k2 + k1 <= k && k2 <= siz[j];k2 ++) {
				f[0][0][u][k1+k2] = (1ll * f[0][0][u][k1+k2] + 1ll * cmp[k1][0][0] * f[0][1][j][k2]) % P;
				f[1][0][u][k1+k2] = ((1ll * f[0][1][j][k2] + 1ll * f[0][0][j][k2]) % P * 1ll * cmp[k1][1][0] % P + 1ll * f[1][0][u][k1+k2]) % P;
				f[0][1][u][k1+k2] = (((1ll * f[1][1][j][k2] + f[0][1][j][k2]) % P * 1ll * cmp[k1][0][1]) % P  + 1ll * f[0][1][u][k1+k2] + 1ll * cmp[k1][0][0] * f[1][1][j][k2] % P) % P;
				f[1][1][u][k1+k2] = (1ll * f[1][1][u][k1+k2] + (1ll * f[1][1][j][k2] + f[0][1][j][k2] + f[1][0][j][k2] + f[0][0][j][k2]) % P * 1ll * cmp[k1][1][1] % P + cmp[k1][1][0] * (1ll * f[1][1][j][k2] + f[1][0][j][k2]) % P) % P;
			}
		}
		siz[u] += siz[j];
	}
}

int main() {
	cin >> n >> k;
	for(int i = 1, a, b;i < n;i ++) {
		cin >> a >> b;
		g[a].push_back(b), g[b].push_back(a);
	}
	dfs(1, 0);
	//输出时,有两种可能的方案
	cout << (1ll * f[1][1][1][k] + f[0][1][1][k]) % P;
	return 0;
} 
```


---

## 作者：LJ07 (赞：2)

## 题目描述

[题目传送门](https://www.luogu.com.cn/problem/P4516)
## 思路简述

~~题解区感觉好像没有我这么复杂而垃圾的做法。~~

显然是树形 dp。

不妨设 $f[i][j][z][0-3]$ 分别表示结点 $i$ 访问到第 $j$ 个孩子，放置了 $z$ 个监听设备，状态为 $0$ 到 $3$ 的方案数。

这里我们规定：
+ $0$ 表示没被上面的点监视且不放置监听设备。
+ $1$ 表示没被上面的点监视且放置监听设备。
+ $2$ 表示被上面的点监视且不放置监听设备。
+ $3$ 表示被上面的点监视且放置监听设备。
+ 当然可以简单理解为**当前状态可以使用 $2\times [\texttt{上面的点是否放了监听设备}]+[\texttt{当前点是否放了监听设备}]$ 表示。**（这里可能文字表述更为清楚）

### 情况1

如果一个点没被上面的点监视，且当前这个点没有/有放置监听设备

那么可以这么思考，一个点可以放置或不放置监听设备，但他一定得有一个儿子放置监听设备。

对于它的一个孩子 $v$ ， 就有 $2$ 种可能：

1. 之前的所有孩子都没有放置监视点，那么它可以选择放置监听设备。
1. 之前的孩子中有放置监视点，那么它放置或不放置监听设备都可。

容易想到还需要维护一个 $g[i][0-1][j]$ 表示访问到第 $i$ 个孩子，此时父结点不放置/放置监听设备，且一共放置了 $j$ 个监听设备，同时孩子都没有放置监听设备的方案数。

### 情况2

如果一个点被上面的点监视，且当前这个点没有/有放置监听设备。

直接更新即可。

---

综上，状态转移方程易得：
+ $t \in [0,1]$，$v$ 表示 $i$ 的第 $j$ 个孩子
+ $sz[i][j]$ 表示节点 $i$ 遍历到第 $j$ 个儿子所统计的子树大小。
+ $cnt[i]$ 表示节点 $i$ 的儿子个数。
+ 钦定当前子树根节点是 $u$。
+ $f[u][j][z][t]=\sum_{l=\max(0,z-sz[u][j]+sz[v][cnt[v]])}^{\min(z-t,sz[v][cnt[v]])} f[u][j-1][z-l][t+2]
\times (f[v][cnt[v]][j][1|(t\times 2)]
+f[v][cnt[v]][l][t\times 2]) $ 。
+ $f[u][j][z][t]=\sum_{l=\min(i-t,sz[v][cnt[v])}^{\max(0,i-sz[u][j]+sz[v][cnt[v]])}
f[u][j-1][z-l][t]
\times (f[v][cnt[v]][l][1+t\times 2]+f[v][cnt[v]][l][t\times 2])+g[t][i-j] \times f[v][cnt[v]][j][1+t\times 2]$。
+ $g[i][t][j]=\sum_{l=\min(i-t,sz[v][cnt[v]])}^{\max(0,j-sz[u][i]+sz[v][cnt[v]])}g[i-1][t][j-l]\times f[v][cnt[v]][l][t\times 2]$。

初始化：

$f[u][0][1][3]=f[u][0][0][2]=1$，$g[0][1][1]=g[0][1][1]=1$，其余皆为 $0$ 。

想必上面的状态转移方程有点恶心，然而枚举是第几个儿子的这一维是可以用滚动数组优化掉的。

## 丑陋の代码
[click here](https://www.luogu.com.cn/paste/n0iu2bqe)

---

## 作者：derta (赞：2)

状态转移方程其它题解已经写得很明白了，这里写一些杂七杂八的东西

## 时间复杂度的证明
令 $T_i$ 为对 $\text{subtree}(i)$ 进行动态规划的时间复杂度，$t_i$ 为将 $\text{son}(i)$ 的状态转移至 $i$ 的时间复杂度，则
$$
\begin{aligned}
t_i&=\sum_{j\in \text{son}(i)}\sum_{l=1}^{\min(k,\text{size}(i))}(\min(l,\text{size}(j))-\max(1,l+\text{size}(j)-\text{size}(i))) \\
&\geq \sum_{j\in \text{son}(i)}\sum_{l=1}^{k}\text{size}(j) \\
&=O(k\cdot \text{size}(i))
\end{aligned}
$$
对 $T_i$ 采用数学归纳法
- 若 $i \in \text{leaf}$，$T_i=1$
- 反之，假设对于任意 $s \in \text{son}(i)$，均有 $T_s=O(k\cdot \text{size}(s))$，则
$$
\begin{aligned}
T_i &= t_i+\sum_{j \in \text{son}(i)}T_j \\
&=O(k\cdot\text{size}(i))+\sum_{j \in \text{son}(i)}O(k \cdot \text{size}(j)) \\
&= O(k \cdot \text{size}(i))
\end{aligned}
$$
故时间复杂度上界为 $O(nk)$

## 滚动数组优化
许多人都是用 $a,b$ 转移到 $a+b$，但这样需要一个额外的数组，然而如果我们用 $t-l,l$ 转移到 $t$，倒序枚举 $t$，就不用额外开数组了

## $l$ 的范围
$\max(1,t+\text{size}(i)-\text{size}(s))\leq l \leq \min(t,\text{size}(s))$，其中 $s$ 表示当前枚举的孩子

## 代码
```cpp
#include <cstdio>
#include <vector>
const int MAXN = 100005, MAXK = 105, MOD = 1000000007;
std::vector<int> G[MAXN];
int f[MAXN][MAXK][2][2], size[MAXN];
// 第三维表示i是否装监听器，第四维表示i是否被监听
int n, k, a, b;

void dp(int i, int father) {
	f[i][0][0][0] = 1;
	f[i][1][1][0] = 1;
	size[i] = 1;
	for(int j = 0; j < G[i].size(); ++j) {
		int s = G[i][j];
		if(s != father) {
			dp(s, i);
			size[i] += size[s];
			for(int t = std::min(k, size[i]); t > 0; --t) {
				int lim = std::min(t, size[s]);
				f[i][t][0][1] = 0;
				f[i][t][0][0] = 0;
				f[i][t][1][1] = f[i][t][1][1]*f[s][0][0][0];
				f[i][t][1][0] = f[i][t][1][0]*f[s][0][0][0];
				for(int l = std::max(1, t + size[s] - size[i]); l <= lim; ++l) {
					f[i][t][0][0] = (1ULL*f[i][t - l][0][0]*f[s][l][0][1] + f[i][t][0][0])%MOD;
					f[i][t][0][1] = (1ULL*f[i][t - l][0][1]*(f[s][l][0][1] + f[s][l][1][1]) + 1ULL*f[i][t - l][0][0]*f[s][l][1][1] + f[i][t][0][1])%MOD;			
					f[i][t][1][0] = (1ULL*f[i][t - l][1][0]*(f[s][l][0][0] + f[s][l][0][1]) + f[i][t][1][0])%MOD;
					f[i][t][1][1] = (1ULL*f[i][t - l][1][1]*(1ULL*f[s][l][0][0] + f[s][l][0][1] + f[s][l][1][0] + f[s][l][1][1]) + 1ULL*f[i][t - l][1][0]*(f[s][l][1][0] + f[s][l][1][1]) + f[i][t][1][1])%MOD;
//					printf("f[%d][%d][0][0]:%d, f[%d][%d][0][1]:%d, f[%d][%d][1][0]:%d, f[%d][%d][1][1]:%d\n", i, t, f[i][t][0][0], i, t, f[i][t][0][1], i, t, f[i][t][1][0], i, t, f[i][t][1][1]);
				}
			}
			f[i][0][0][0] = 0;
		}
	}
}

int main() {
	scanf("%d%d", &n, &k);
	for(int i = 1; i < n; ++i) {
		scanf("%d%d", &a, &b);
		G[a].push_back(b), G[b].push_back(a);
	}
	dp(1, -1);
	int ans = (f[1][k][0][1] + f[1][k][1][1])%MOD;
	printf("%d", ans);
	return 0;
}
```

---

## 作者：nomonick (赞：2)

# 题解 P4516 【[JSOI2018]潜入行动】

[P4516 [JSOI2018]潜入行动](https://www.luogu.com.cn/problem/P4516)


这是一道树上背包的题目，确实很难想到思路

首先定义一个数组，用来存储状态

即：$dp[u][i][0/1][0/1] \implies $ 表示以 $u$ 为根节点的子树，在放了 $i$ 个监视器,保证全部的子树上点都被监视到的情况下，带点 $u$ 上放与不放监视器，且是否被监视到。

在看出背包后，我们去寻找转移方程（这就是重难点），

现在假设，我们已将查询到了以 $u$ 为根节点的树 $k_1$ ，此时发现了这个树的下方还有一个还有以 $v$ 为根节点的子树 $k_2$，于是把这个子树就并在一起形成一个大的图以满足要求：

------

$$
\forall dp[u][i][0][0]
$$

$u$ 点没有被放置，且没有被监视到

所以 $v$ 点处不能放监视器，这是肯定的，但是这并不影响 $v$ 点被监视到

$$
\therefore dp[u][i+j][0][0] = \sum dp[u][i][0][0] \times dp[v][j][0][1] 
$$

------

$$
\forall dp[u][i][0][1]
$$

这种情况要分类讨论：

- $u$ 一侧子树的状态为 $dp[u][i][0][1]$

这时候 $u$ 已经被监视了，所以在不在 $v$ 处放监视器，对于当前的结果没有任何影响，但是要保证每个点都被监视到，所以 $v$ 点被监视到

－　$u$ 一侧子树的状态为 $dp[u][i][0][0]$

这时候 $u$ 还没被监视，所以在 $v$ 处放监视器是不争的事实，同时要保证每个点都被监视到所以 $v$ 点也必须被监视

$$
\therefore dp[u][i+j][0][1] = \sum (dp[u][i][0][1] \times (dp[v][j][0][1] + dp[v][j][1][1]) + dp[u][i][0][0] \times dp[v][j][1][1])
$$

------

$$
\forall dp[u][i][1][0]
$$

$u$ 没被监视但是放了监视器，所以 $u$ 一侧子树的状态一定是 $dp[u][i][1][0]$，$v$ 是否被监视无所谓，但是一定不能放装置

$$
\therefore dp[u][i+j][1][0] = \sum dp[u][i][1][0] \times (dp[v][j][0][0] + dp[v][j][0][1])
$$

------

$$
\forall dp[u][i][1][1]
$$

这种情况也要分类讨论(直接　$wuhu$　起飞)：

- $u$ 一侧子树的状态为 $dp[u][i][1][0]$

所以我们需要 $v$ 点上放监视器来监视 $u$ ，同时 $v$ 点没有必要被监视

- $u$ 一侧子树的状态为 $dp[u][i][1][１]$

$u$ 已经被 $k_1$ 侧子树满足了，所以 $v$ 来说可以随便的安排（$Everything is OK.$）

$$
\therefore dp[u][i+j][1][1] = \sum (dp[u][i][1][0] \times (dp[v][j][1][0] + dp[v][j][1][1]) + dp[u][i][1][1] * (dp[v][j][0][0] + dp[v][j][0][1] + dp[v][j][1][0] + dp[v][j][1][1]))
$$

------

综上所述:

$$
dp[u][i+j][0][0] = \sum dp[u][i][0][0] \times dp[v][j][0][1]
$$

$$
dp[u][i+j][0][1] = \sum (dp[u][i][0][1] \times (dp[v][j][0][1] + dp[v][j][1][1]) + dp[u][i][0][0] \times dp[v][j][1][1])
$$

$$
dp[u][i+j][1][0] = \sum dp[u][i][1][0] \times (dp[v][j][0][0] + dp[v][j][0][1])
$$

$$
dp[u][i+j][1][1] = \sum (dp[u][i][1][0] \times (dp[v][j][1][0] + dp[v][j][1][1]) + dp[u][i][1][1] * (dp[v][j][0][0] + dp[v][j][0][1] + dp[v][j][1][0] + dp[v][j][1][1]))
$$

# code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int SIZE = 1e5 + 50;
const int NUM = 110;
const int mod = 1e9 + 7;

inline int read()
{
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9')
	{
		f = (ch == '-' ? -1 : 1);
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f * x;
}


int n,k,num_edge;
int head[SIZE],siz[SIZE];
int dp[SIZE][NUM][2][2],tmp[NUM][2][2];
struct node
{
	int to,nxt;
};
node edge[SIZE << 1];

inline void add(int u,int v)
{
	edge[++num_edge].to = v;
	edge[num_edge].nxt = head[u];
	head[u] = num_edge;
}

inline int solve(int u,long long v)
{
	if (v >= mod) v = v % mod;
	for (u += v; u >= mod; u -= mod);
	return u;
}

void dfs(int u,int fa)
{
	siz[u] = dp[u][0][0][0] = dp[u][1][1][0] = 1;
	for (register int t = head[u]; t; t = edge[t].nxt)
	{
		register int v = edge[t].to;
		if (v == fa) continue;
		dfs(v,u);
		register int side = min(siz[u],k);
		for (register int i = 0; i <= side; ++i)
		{
			tmp[i][0][0] = dp[u][i][0][0];
			dp[u][i][0][0] = 0;
			tmp[i][0][1] = dp[u][i][0][1];
			dp[u][i][0][1] = 0;
			tmp[i][1][0] = dp[u][i][1][0];
			dp[u][i][1][0] = 0;
			tmp[i][1][1] = dp[u][i][1][1];
			dp[u][i][1][1] = 0;
		}
		for (register int i = 0; i <= side; ++i)
		{
			register int limit = min(siz[v],k-i);
			for (register int j = 0; j <= limit; ++j)
			{
				dp[u][i+j][0][0] = solve(dp[u][i+j][0][0],1ll * tmp[i][0][0] * dp[v][j][0][1]);
				dp[u][i+j][0][1] = solve(dp[u][i+j][0][1],1ll * tmp[i][0][1] * (dp[v][j][0][1] + dp[v][j][1][1]));
				dp[u][i+j][0][1] = solve(dp[u][i+j][0][1],1ll * tmp[i][0][0] * dp[v][j][1][1]);
				dp[u][i+j][1][0] = solve(dp[u][i+j][1][0],1ll * tmp[i][1][0] * (dp[v][j][0][0] + dp[v][j][0][1]));
				dp[u][i+j][1][1] = solve(dp[u][i+j][1][1],1ll * tmp[i][1][0] * (dp[v][j][1][0] + dp[v][j][1][1]));
				dp[u][i+j][1][1] = solve(dp[u][i+j][1][1],1ll * tmp[i][1][1] * (1ll * dp[v][j][0][0] + 1ll * dp[v][j][0][1] + 1ll * dp[v][j][1][0] + 1ll * dp[v][j][1][1]));
			}
		}
		siz[u] += siz[v];
	}
}
int main()
{
	n = read();k = read();
	for (register int i = 1; i < n; ++i)
	{
		register int u = read(),v = read();
		add(u,v);
		add(v,u);
	}
	dfs(1,0);
	printf("%d\n",(dp[1][k][0][1] + dp[1][k][1][1]) % mod);
	return 0;
}

```

---

## 作者：VulcanStig (赞：2)

~~Orz居然是紫题~~

首先状态定义是显然的：

$ dp(u,i,0/1,0/1)$ 表示 $u$ 的子树除自己都已经保证被监听，用了 $i$ 个监听器，当前节点是否安装监听器，是否被监听

~~很显然~~的有这么几个状态转移

$dp(u,i,0,0)=\sum dp(v,j,0,1) \times dp(u,i-j,0,0)$

$dp(u,i,0,1)=\sum (dp(v,j,1,1)+dp(v,j,0,1)) \times (dp(u,i-j,0,1)+dp(u,i-j,0,0))-dp(u,i,0,0)$

$dp(u,i,1,0)=\sum (dp(v,j,0,0)+dp(v,j,0,1)) \times dp(u,i-j,1,0)$

$dp(u,i,1,1)=\sum (dp(v,j,1,1)+dp(v,j,1,0)+dp(v,j,0,0)+dp(v,j,0,1)) \times (dp(u,i-j,1,0)+dp(u,i-j,1,1))-dp(u,i,1,0)$

但是更新的顺序有点小烦

首先，因为是树形计数问题，所以DP的时候前面的状态不能保留，要开一个临时数组g更新（当然可以不用，特判一下 $j=0$ 的情况优先更新，再倒序更新即可）

其次，我们需要考虑每次转移时的枚举边界，否则复杂度会假：(下文 $siz[u]$ 均为只算入当前子树和之前已更新子树的值，详见代码)

$i$ 肯定不能超过其子树大小

$0\le i\le \min (siz[u],k)$

$j$ 要满足 $i-j\le siz[u]-siz[v]$ 且不超过 $v$ 的子树大小：

$\max(0,siz[v]-siz[u]+i)\le j\le \min(i,siz[v])$

此外，DP时那个减法操作最后再做，以免减出负数，也方便维护转移的正确性

这样就能保证正确性了

至于复杂度……

由于我们的更新是正确的且没有冗余的（也许），所以转移复杂度能够达到 $O(K^2)$ 的点最多 $n/k$ 个，所以复杂度为 $O(nk)$

**代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define re register
#define ll long long
inline int rd(){
	int re data=0;static char ch=0;ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))data=(data<<3)+(data<<1)+(ch^48),ch=getchar();
	return data;
}
const int N=1e5+5,K=105,mod=1e9+7;
int n,k,first[N],siz[N],cnt,dp[N][K][2][2],g[K][2][2];
struct edges{int v,nxt;}e[N<<1];
inline void add(int u,int v){e[++cnt]=(edges){v,first[u]},first[u]=cnt;}
inline void dfs(int u,int fa){
	siz[u]=1,dp[u][0][0][0]=dp[u][1][1][0]=1;
	for(int re v,i=first[u];i;i=e[i].nxt){
		v=e[i].v;if(v==fa)continue;
		dfs(v,u),siz[u]+=siz[v],memcpy(g,dp[u],sizeof g);
		for(int re i=min(k,siz[u]);~i;--i)dp[u][i][0][0]=dp[u][i][0][1]=dp[u][i][1][0]=dp[u][i][1][1]=0;
		for(int re i=min(k,siz[u]);~i;--i){
			int re maxl=min(i,siz[v]);
			for(int re j=max(0,i+siz[v]-siz[u]);j<=maxl;++j){
				(dp[u][i][0][0]+=(ll)dp[v][j][0][1]*g[i-j][0][0]%mod)%=mod,
				(dp[u][i][0][1]+=((ll)dp[v][j][1][1]+dp[v][j][0][1])%mod*(g[i-j][0][1]+g[i-j][0][0])%mod)%=mod,
				(dp[u][i][1][0]+=((ll)dp[v][j][0][0]+dp[v][j][0][1])%mod*g[i-j][1][0]%mod)%=mod,
				(dp[u][i][1][1]+=((ll)dp[v][j][1][1]+dp[v][j][1][0]+dp[v][j][0][0]+dp[v][j][0][1])%mod*(g[i-j][1][0]+g[i-j][1][1])%mod)%=mod;				
			}((dp[u][i][0][1]-=dp[u][i][0][0])+=mod)%=mod,((dp[u][i][1][1]-=dp[u][i][1][0])+=mod)%=mod;
		}		
	}
}
signed main(){
	n=rd(),k=rd();
	for(int re u,v,i=1;i^n;++i)u=rd(),v=rd(),add(u,v),add(v,u);
	dfs(1,0),cout<<(dp[1][k][0][1]+dp[1][k][1][1])%mod,exit(0);
}
```

---

## 作者：Sunflower_ac (赞：1)

# 【题解】P4516 [JSOI2018] 潜入行动

[博客园食用效果更佳](https://www.cnblogs.com/xrkforces/p/luogu-P4516.html)

比较常规但是有点思维含量的一道树形 DP。

---

## 题目链接

[P4516 [JSOI2018] 潜入行动](https://www.luogu.com.cn/problem/P4516)

## 题意概述

给定一棵有 $n$ 个点的树，现在要在一些点上安装最多 $k$ 个监听设备，每个监听设备可以监听到与这个点直接连边的所有点，**但不可以监听到它本身**，现在要求每个点都被监听到，且每个点最多只能有一个监听设备，求有多少种合法的方案，答案对 $1e9+7$ 取模。

## 题目分析

首先比较显然的是个树上背包。

那么按照树上背包的套路，我们定义 $dp_{x,i}$ 表示的是以 $x$ 为根的子树，安装了 $i$ 个监听设备有多少种合法的方案。

但是发现直接这样定义并不好转移，必须要考虑 $x$ 本身是否放了监听设备以及有没有被监听。

所以我们更改一下 $dp$ 状态：定义 $dp_{x,i,0/1,0/1}$ 表示的是以 $x$ 为根的子树，安装了 $i$ 个监听设备，$x$ 是否安装了监听设备，$x$ 是否被监听的方案数。

那么最后的答案就是 $dp_{1,k,0,1}+dp_{1,k,1,1}$。

树上背包的转移套路是考虑合并子树，即考虑 $dp_{x,i+j}$ 怎么样由 $dp_{x,i}$ 和 $dp_{y,j}$ 转移而来，其中 $y$ 是 $x$ 的儿子。

对于这样比较复杂的状态，我们分别考虑以 $x$ 为根的每个状态应该怎么转移。

- 对于 $dp_{x,i+j,0,0}$：

	$x$ 没有被监听，说明 $y$ 一定没有安装监听设备；$x$ 没有安装设备，说明 $y$ 一定需要被除 $x$ 之外的其它点监听。

	转移方程：
	$$
	 dp_{x,i+j,0,0}=\sum dp_{x,i,0,0}\times dp_{y,j,0,1}
	$$

- 对于 $dp_{x,i+j,0,1}$：

	$x$ 没有安装设备，说明 $y$ 一定被其它点监听；$x$ 被监听了，有两种情况：

	1. $x$ 在考虑 $y$ 之前就已经被其它儿子监听，此时 $y$ 之前安装不安装设备无所谓；
	2. $x$ 在考虑 $y$ 之前还未被其它儿子监听，所以它只能被 $y$ 监听，即 $y$ 必须安装设备。

	转移方程：
	$$
	 dp_{x,i+j,0,1}=\sum dp_{x,i,0,1} \times (dp_{y,i,0,1}+dp_{y,j,1,1})+dp_{x,i,0,0}\times dp_{y,j,1,1}
	$$

- 对于 $dp_{x,i+j,1,0}$：

	$x$ 安装设备了，那么 $y$ 之前是否被监听无所谓，因为反正它至少会被 $x$ 监听；$x$ 没有被监听，那么 $y$ 一定不能安装设备。

	转移方程：
	$$
	 dp_{x,i+j,1,0}=\sum dp_{x,i,1,0} \times (dp_{y,j,0,1}+dp_{y,j,0,0})
	$$

- 对于 $dp_{x,i+j,1,1}$：

	$x$ 安装设备了，那么 $y$ 之前是否被监听无所谓，因为反正它至少会被 $x$ 监听；$x$ 被监听了，有两种情况：

	1. $x$ 在考虑 $y$ 之前就已经被其它儿子监听，此时 $y$ 之前安装不安装设备无所谓；
	2. $x$ 在考虑 $y$ 之前还未被其它儿子监听，所以她只能被 $y$ 监听，即 $y$ 必须安装设备。

	考虑 $x$ 在 $y$ 之前是否被监听时，同时考虑 $y$ 之前是否被监听，总转移方程如下：
	$$
	 dp_{x,i+j,1,1}=\sum dp_{x,i,1,1}\times (dp_{y,i,1,1}+dp_{y,i,1,0}+dp_{y,i,0,1}+dp_{y,i,1,1}) 
   +dp_{x,i,1,0}\times(dp_{y,i,1,1}+dp_{y,i,1,0})
	$$

这就是全部的转移。

## 易错点

- 开 long long 会 MLE，请使用 unsigned int；
- 该取模的地方要取模；
- 树上背包每次转移前，先将 $dp_{x,i,0/1,0/1}$ 下的每一个状态都存一个临时数组下面只用临时数组转移，并将所有原 $dp_{x,i,0/1,0/1} $ 归零，防止之后的转移出现错乱。

## 代码实现

```cpp
//luoguP4516
#include<iostream>
#include<cstdio>
#include<cstring>
#define int unsigned int
using namespace std;
const int maxn=1e5+10;
const int maxk=105;
const int mod=1e9+7;
int dp[maxn][maxk][2][2],tp[maxk][2][2];
int sz[maxn];
int n,k;

basic_string<int>edge[maxn];

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

void dfs(int x,int fa)
{
	sz[x]=dp[x][0][0][0]=dp[x][1][1][0]=1;
	for(int y:edge[x])
	{
		if(y==fa)continue;
		dfs(y,x);
		for(int i=0;i<=min(sz[x],k);i++)
		{
			tp[i][0][0]=dp[x][i][0][0];
			tp[i][0][1]=dp[x][i][0][1];
			tp[i][1][0]=dp[x][i][1][0];
			tp[i][1][1]=dp[x][i][1][1];
			dp[x][i][0][0]=0;
			dp[x][i][0][1]=0;
			dp[x][i][1][0]=0;
			dp[x][i][1][1]=0;
		}
		for(int i=0;i<=min(sz[x],k);i++)
		{
			for(int j=0;j<=min(sz[y],k-i);j++)
			{
				(dp[x][i+j][0][0]+=1ll*tp[i][0][0]*dp[y][j][0][1]%mod)%=mod;
				(dp[x][i+j][0][1]+=1ll*tp[i][0][0]*dp[y][j][1][1]%mod+1ll*tp[i][0][1]*(dp[y][j][0][1]+dp[y][j][1][1])%mod)%=mod;
				(dp[x][i+j][1][0]+=1ll*tp[i][1][0]*(dp[y][j][0][0]+dp[y][j][0][1])%mod)%=mod;
				(dp[x][i+j][1][1]+=1ll*tp[i][1][0]*(dp[y][j][1][0]+dp[y][j][1][1])%mod+1ll*tp[i][1][1]*(dp[y][j][0][0]+dp[y][j][0][1]+dp[y][j][1][0]+dp[y][j][1][1])%mod)%=mod;
			}
		}
		sz[x]+=sz[y];
	}
}

signed main()
{
	n=read();k=read();
	for(int i=1;i<n;i++)
	{
		int u,v;
		u=read();v=read();
		edge[u]+=v;
		edge[v]+=u;
	}
	dfs(1,0);
	cout<<1ll*(dp[1][k][0][1]+dp[1][k][1][1])%mod<<"\n";
	return 0;
}
```



---

## 作者：UperFicial (赞：1)

[同步发表于我的 $\text{cnblogs}$](https://www.cnblogs.com/UperFicial/p/16657044.html)。

[传送门](https://www.luogu.com.cn/problem/P4516)。

考虑这个树形 DP 状态的设计，题目涉及的所有量都放进状态中。

设 $f_{i,j,0/1,0/1}$ 表示，以 $i$ 为根的子树中，除 $i$ 节点都被监听了，一共放置了 $j$ 个监听设备，$i$ 点是否放置了监听设备，$i$ 是否被监听（`0` 表示没有，`1` 表示有）的方案数。

考虑转移，设 $v$ 的父节点为 $u$：

- $f_{u,i+j,0,0}$ 的转移：
- 
  - $u$ 没有被监听，说明 $u$ 的儿子都没有放置监听设备。
   
  - 用树形背包来转移，即每访问完一个节点，就用当前状态与当前子树一一配对。
   
  - 枚举 $v$ 用的监听器数量 $j$，则 $f_{i,i+j,0,0}\leftarrow f_{u,i+j,0,0}+f_{u,i,0,0}\times f_{v,j,0,1}$。
   
  - 注意，这里的 $f_{u,i,0,0}$ 表示的是，$v$ 子树之前的那些子树对 $u$ 造成的贡献，实际操作中，我们可以另用一个数组表示。
   
- $f_{u,i+j,0,1}$ 的转移：
 
  - $u$ 没放置设备，但是被监听了。我们不知道它被父亲监听，还是被孩子监听，所以分两种情况讨论。
  
    - 如果 $u$ 被除 $v$ 以外的节点监听，$v$ 放不放置监听器就不重要了。所以我们得到 $f_{u,i+j,0,1}\leftarrow f_{u,i+j,0,1}+f_{u,i,0,1}\times \left(f_{v,j,0,1}+f_{v,j,1,1}\right)$。
     
    - 如果 $u$ 只被 $v$ 监听，那么 $v$ 只能放置监听器，$f_{u,i+j,0,1}\leftarrow f_{u,i+j,0,1}+f_{u,i,0,0}\times f_{v,j,1,1}$。注意，是从 $f_{u,i,0,0}$ 转移而来，因为我们刚刚提到过，$u$ 单独被 $v$ 监听，若还有其余的，会与第一种情况算重。
     
- $f_{u,i+j,1,0}$ 的转移：
 
    - $u$ 放置了监听器，但是没有被监听。这个条件也是十分好做的；
     
    - $u$ 没有被监听，说明 $v$ 没有放置监听设备。

    - $u$ 放置了监听器，说明在 $v$ 这个子树中，$v$ 是否被监听到是无所谓的，因为总会有 $u$ 监听 $v$。
     
    - 转移很明了：$f_{u,i+j,1,0}\leftarrow f_{u,i+j,1,0}+f_{u,i,1,0}\times \left(f_{v,j,0,0}+f_{v,j,0,1}\right)$。

- $f_{u,i+j,1,1}$ 的转移：

    - $u$ 被监听，根第二种情况一样，我们分两种情况讨论，是被儿子监听，还是被父亲监听。

      - 如果 $u$ 是被 $v$ 监听，$v$ 是否被监听是无所谓的，因为 $u$ 点放置了监听器，同时 $v$ 必须放置监听器。$f_{u,i+j,1,1}\leftarrow f_{u,i+j,1,1}+f_{u,i,1,0}\times \left(f_{v,j,1,0}+f_{v,j,1,1}\right)$。
      
      - 如果 $u$ 是被父亲监听，那么 $v$ 是否被监听是无所谓的，是否放置监听器也是无所谓的，开摆即可。$f_{u,i+j,1,1}\leftarrow f_{u,i+j,1,1}+f_{u,i,1,1}\times f_{v,j,0/1,0/1}$。

细节主要就是用一个数组保存除了 $v$ 子树的前面的子树的 DP 值。

考虑它的复杂度，性感证明即为考虑 $\text{siz}>k$ 的点不会超过 $\dfrac{n}{k}$ 个，总复杂度约为 $\Theta(nk)$。

[代码](https://www.luogu.com.cn/paste/r2du3bte)。

---

## 作者：Stinger (赞：1)

UPD：十分抱歉刚过审就让管理重新审核，只是修了个笔误，这下再有错我头插地里（

大概是树形背包的板题，但是这题的式子推起来非常长……

[传送门](https://www.luogu.com.cn/problem/P4516)

# $\texttt{Description}$

> 给你一颗 $n$ 个节点的树，$k$ 个监听设备。监听设备可以监听与它相邻的任何节点，**但不能监听它所在的节点**，每个节点只允许放置一个监听设备，求出将 $k$ 个设备用完且每个节点都被监听到的方案数。
>
> $\texttt{Data Range:} 1\le n\le 10^5,1\le k\le min(100,n)$

# $\texttt{Solution}$

这题面和数据规模大家也能猜到，是 $O(nk)$ 的树形 dp。

定义状态：$dp_{u,k,p}$ 表示在以 $u$ 为根节点的子树中，放置 $k$ 个监听设备，$u$ 自身是否被 $u$ 的子节点监听（$p$ 为 $0$ 表示没有，否则表示有）。

但是，这样定义状态会导致无法转移。因为我们不知道 $u$ 是否放置了监听设备，转移时也就不知道 $u$ 是否被子节点监听。~~其实是个人都知道一来就四维状态吧，就我不会~~所以定义 $dp_{u,k,p,q}$ 表示在以 $u$ 为根节点的子树中，放置 $k$ 个监听设备，$q$ 表示 $u$ 自身是否被 $u$ 的子节点监听，$p$ 表示 $u$ 节点是否放置了节点。

以下是恶心的树形 dp 转移方程（约定 $v$ 表示 $u$ 的子节点）：

$$dp_{u,i+j,0,0}=dp_{u,i,0,0}\times dp_{v,j,0,1}$$
$$dp_{u,i+j,0,1}=dp_{u,i,0,0}\times dp_{v,j,1,1}+dp_{u,i,0,1}\times(dp_{v,j,0,1}+dp_{v,j,1,1})$$
$$dp_{u,i+j,1,0}=dp_{u,i,1,0}\times (dp_{v,j,0,0}+dp_{v,j,0,1})$$
$$dp_{u,i+j,1,1}=dp_{u,i,1,0}\times (dp_{v,j,1,0}+dp_{v,j,1,1})+dp_{u,i,1,1}\times (dp_{v,j,0,0}+dp_{v,j,0,1}+dp_{v,j,1,0}+dp_{v,j,1,1})$$

~~你谷博客feature巨多，不能换行必须打多个公式，这 $\LaTeX$ 真的把我打疯了~~

~~我们无论遇到多长的方程，也不要怕，微笑着写下它，消除方程的最好方式就是A了这道题，祝你们成功（滑稽~~

~~草我怎么把两个梗合在了一起~~

解释一下方程：

第一个方程不必多说，$u$ 本身没有放，它的儿子没有收到父亲监听，所以儿子必须被它的这个儿子的儿子监听到（大家好我语文没救。

第二个方程，首先考虑 $dp_{u,i+j,0,1}=dp_{u,i,0,0}\times dp_{v,j,1,1}$ 这一部分。由于刚才 $u$ 还没有被儿子监听，但现在被儿子监听了，也就是说必须被 $v$ 儿子监听。$dp_{u,i,0,1}\times(dp_{v,j,0,1}+dp_{v,j,1,1})$ 表示反正 $u$ 已经被监听了，$v$ 放不放监听装置都行。

第三个方程，$u$ 放了监听装置，所以 $v$ 被没被儿子监听都可以。

第四个方程~~最长的~~，$dp_{u,i,1,0}\times (dp_{v,j,1,0}+dp_{v,j,1,1})$  和第二个方程同理，$u$ 必须被 $v$ 监听，而 $u$ 放了装置，$v$ 放不放都无所谓。后面那一坨则是 $u$ 已经被监听了，而 $u$ 又放了装置，所以它的儿子怎么搞都行。

复杂度证明我不会（滑稽

反正是 $O(nk)$ 的。会用就行，复杂度这种玄学不必去深究，又不会给你考场上加分（

# $\texttt{Code}$

代码实现细节：

dp 数组不能开`long long`。会被卡空间，必须中途计算时转为`long long`再转回`int`。

内含注释。

```cpp
#include <cstdio>

const int MOD = 1e9 + 7;
inline int min(const int x, const int y) {return x < y ? x : y;}
struct Edge {
	int to, nxt;
} e[200005];
int head[100005], cnt[100005], dp[100005][105][2][2], tmp[105][2][2], tot, n, k;
inline void AddEdge(const int u, const int v) {
	e[++ tot].to = v, e[tot].nxt = head[u], head[u] = tot;
}
void dfs(const int u, const int fa) {
	dp[u][0][0][0] = dp[u][1][1][0] = cnt[u] = 1LL;//初始化
	int lim(1);
	for (int I(head[u]); I; I = e[I].nxt) if (e[I].to != fa) {
		const int v(e[I].to);
		dfs(v, u);
		for (int i(0); i <= k; ++ i)
			tmp[i][0][0] = tmp[i][0][1] = tmp[i][1][0] = tmp[i][1][1] = 0LL;//tmp数组记录当前阶段的dp数组，方便转移。直接在原来的dp数组上转移不行
		for (int i(0); i <= cnt[u] && i <= k; ++ i)//套一下背包板子，cnt[u]为u的节点个数
		for (int j(0); j <= cnt[v] && j <= k - i; ++ j) {
			if (i + j > lim) lim = i + j;///算过的最大的tmp数组下标，因为算完了要把tmp赋值给dp数组。
			tmp[i + j][0][0] = (1LL * tmp[i + j][0][0] + 1LL * dp[u][i][0][0] * dp[v][j][0][1] % MOD) % MOD;
			tmp[i + j][0][1] = (1LL * tmp[i + j][0][1] + 1LL * dp[u][i][0][0] * dp[v][j][1][1] % MOD + 1LL * dp[u][i][0][1] * (dp[v][j][0][1] + dp[v][j][1][1]) % MOD) % MOD;
			tmp[i + j][1][0] = (1LL * tmp[i + j][1][0] + 1LL * dp[u][i][1][0] * (dp[v][j][0][0] + dp[v][j][0][1]) % MOD) % MOD;
			tmp[i + j][1][1] = (1LL * tmp[i + j][1][1] + 1LL * dp[u][i][1][0] * (dp[v][j][1][0] + dp[v][j][1][1]) % MOD + 1LL * dp[u][i][1][1] * (1LL * dp[v][j][0][0] + dp[v][j][0][1] + 1LL * dp[v][j][1][0] + dp[v][j][1][1]) % MOD) % MOD;
		}
		for (int i(0); i <= lim; ++ i)
			dp[u][i][0][0] = tmp[i][0][0], dp[u][i][0][1] = tmp[i][0][1], dp[u][i][1][0] = tmp[i][1][0], dp[u][i][1][1] = tmp[i][1][1];//算完了记得把tmp赋值给dp数组
		cnt[u] += cnt[v];
	}
}
signed main() {
	scanf("%d%d", &n, &k);
	for (int i(1); i < n; ++ i) {
		int u, v;
		scanf("%d%d", &u, &v);
		AddEdge(u, v), AddEdge(v, u);
	}
	dfs(1, -1);
	printf("%d\n", (dp[1][k][0][1] + dp[1][k][1][1]) % MOD);
	return 0;
}
```

---

## 作者：nofind (赞：1)

题意:https://www.luogu.org/problem/P4516

一道挺麻烦的树形背包

显然有两维是$f[x][i]$表示x的子树选了i个完全覆盖的方案数

之后为了转移需要再加几维

由于根节点放了并不覆盖根节点本身,需要添加两维:

$f[x][i][0/1][0/1]$表示x的子树,选了i个,x是否选了,x是否被覆盖,子树内(除了x)全都被覆盖的方案数

答案:$f[1][m][1][1]+f[1][m][0][1]$

转移:

枚举x之前的子树用了多少为i,当前子树y用多少为j

$f[x][i+j][0][0]+=f[x][i][0][0]*f[y][j][0][1]$

由于x没有放,因此y必须被覆盖,又因为x没有被覆盖,y是不能放的

$f[x][i+j][0][1]+=f[x][i][0][1]*f[y][j][1/0][1]+f[x][i][0][0]*f[y][j][1][1]$

由于x不放,所以y必须被覆盖,接下来分两种情况讨论:

1.x之前被覆盖了:y放不放都行

2.x之前没有被覆盖:y必须放上

$f[x][i+j][1][0]+=f[x][i][1][0]*f[y][j][0][0/1]$

由于x已经放上了,y之前是否被覆盖无所谓,但y是不能放的,因为x未被覆盖

$f[x][i+j][1][1]+=f[x][i][1][1]*f[y][j][0/1][0/1]+f[i][1][0]*f[y][j][1][0/1]$

由于x已经放上了,y是否被覆盖无所谓,接下来分两种情况讨论

1.x之前被覆盖了:y什么状态都无所谓,全加起来就行了

2.x之前未被覆盖:y必须放上

这题f数组不能开long long,转移时乘$1ll$即可

code:
```
#include<bits/stdc++.h>
using namespace std;
#define re register
const int maxn=1e5+10;
const int maxk=110;
const int mod=1000000007;
int n,m,cnt;
int head[maxn],size[maxn];
int g[maxk][2][2];
int f[maxn][maxk][2][2];
struct edge
{
	int to,nxt;
}e[maxn<<1];
inline void add(int u,int v)
{
	e[++cnt].nxt=head[u];
	head[u]=cnt;
	e[cnt].to=v;
}
void dfs(int x,int fa)
{
	size[x]=1;
	f[x][0][0][0]=f[x][1][1][0]=1;
	for(re int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(y==fa)continue;
		dfs(y,x);
		for(re int j=0;j<=min(size[x],m);j++)
		{
			g[j][0][0]=f[x][j][0][0],f[x][j][0][0]=0;
			g[j][1][0]=f[x][j][1][0],f[x][j][1][0]=0;
			g[j][0][1]=f[x][j][0][1],f[x][j][0][1]=0;
			g[j][1][1]=f[x][j][1][1],f[x][j][1][1]=0;
		}
		for(re int j=0;j<=min(size[x],m);j++)
			for(re int k=0;k<=min(size[y],m-j);k++)
			{
				f[x][j+k][0][0]=(f[x][j+k][0][0]+1ll*g[j][0][0]*f[y][k][0][1])%mod;
				f[x][j+k][0][1]=(f[x][j+k][0][1]+1ll*g[j][0][1]*(f[y][k][0][1]+f[y][k][1][1])%mod)%mod;	
				f[x][j+k][0][1]=(f[x][j+k][0][1]+1ll*g[j][0][0]*f[y][k][1][1]%mod)%mod;
				f[x][j+k][1][0]=(f[x][j+k][1][0]+1ll*g[j][1][0]*(f[y][k][0][0]+f[y][k][0][1])%mod)%mod;
				f[x][j+k][1][1]=(f[x][j+k][1][1]+1ll*g[j][1][0]*(f[y][k][1][0]+f[y][k][1][1])%mod)%mod;
				f[x][j+k][1][1]=(f[x][j+k][1][1]+1ll*g[j][1][1]*(f[y][k][0][0]+f[y][k][0][1])%mod)%mod;
				f[x][j+k][1][1]=(f[x][j+k][1][1]+1ll*g[j][1][1]*(f[y][k][1][0]+f[y][k][1][1])%mod)%mod;
			}
		size[x]+=size[y];	
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(re int i=1;i<n;i++)
	{
		int u,v;scanf("%d%d",&u,&v);
		add(u,v);add(v,u);
	}
	dfs(1,0);
	printf("%d",(f[1][m][0][1]+f[1][m][1][1])%mod);
	return 0;
}
```


---

## 作者：Jμdge (赞：1)

讲真，暴力的做法想也想到了，就是没敢打...（因为我看到了标签是黑色的啊！）


复杂度 $n·k^2$ ？ 然后玄学 AC ？ 我是有点懵的（其实状态也设计好了就是没有想转移）

然鹅本来我是要打链表的，貌似也是时间不如 vector 过不了...总之就是没 A 


-----

这道（假）题其实就是个树形dp ，转移比较麻烦，状态也不难设计（就是开数组的时候小心点，容易爆...）


状态的话就是用 f[i][j][0/1][0/1] 表示 i 号点的子树内，用了 j 个装置， i 号点本身是否安装 0/1 ，与它直接相连的孩子有没有安装 0/1（也就是有没有被窃听）


然后思考一堆转移就好了（转移还是看代码吧，也不难懂，打着太累...）

然后据楼上所言不要开 long long 中间过程转一下就好了，不然会炸（或者用龟速乘 ？）


```
//by Judge
#include<vector>
#include<cstdio>
#include<iostream>
using namespace std;
const int mod=1e9+7;
const int M=1e5+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int Min(int a,int b){return a<b?a:b;}
inline int Mul(int x,int y){return 1ll*x*y%mod;}
inline void ADD(int& a,int b){a+=a+b>=mod?b-mod:b;}
inline int Inc(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,K; vector<int> G[M];
int siz[M],f[M][101][2][2],g[101][2][2]; // 选 / , 覆盖/ 
inline void add(int x,int y){G[x].push_back(y),G[y].push_back(x);}
#define v G[u][i]
void dfs(int u,int fa){ siz[u]=f[u][0][0][0]=f[u][1][1][0]=1;
	for(int i=G[u].size()-1;i>=0;--i){
		if(v==fa) continue; dfs(v,u);
		for(int j=0,jj=Min(siz[u],K);j<=jj;++j)
			g[j][0][0]=f[u][j][0][0],f[u][j][0][0]=0,
			g[j][0][1]=f[u][j][0][1],f[u][j][0][1]=0,
			g[j][1][0]=f[u][j][1][0],f[u][j][1][0]=0,
			g[j][1][1]=f[u][j][1][1],f[u][j][1][1]=0;
		for(int j=0,jj=Min(siz[u],K);j<=jj;++j)
			for(int k=0,kk=Min(siz[v],K-j);k<=kk;++k)
				ADD(f[u][j+k][0][0],Mul(g[j][0][0],f[v][k][0][1])),
				
				ADD(f[u][j+k][0][1],Mul(g[j][0][0],f[v][k][1][1])),
				ADD(f[u][j+k][0][1],Mul(g[j][0][1],Inc(f[v][k][0][1],f[v][k][1][1]))),
				
				ADD(f[u][j+k][1][0],Mul(g[j][1][0],Inc(f[v][k][0][0],f[v][k][0][1]))),
				
				ADD(f[u][j+k][1][1],Mul(g[j][1][0],Inc(f[v][k][1][0],f[v][k][1][1]))),
				ADD(f[u][j+k][1][1],Mul(g[j][1][1],Inc(f[v][k][0][0],Inc(f[v][k][0][1],Inc(f[v][k][1][0],f[v][k][1][1])))));
		siz[u]+=siz[v];
	}
}

int main(){ n=read(),K=read(); for(int i=1,x,y;i<n;++i) x=read(),y=read(),add(x,y);
	return dfs(1,0),!printf("%d\n",Inc(f[1][K][0][1],f[1][K][1][1]));
}
```






---

## 作者：creation_hy (赞：0)

一道不错的树形 dp 题。

很容易想到 dp 状态，$f[i][j][0/1][0/1]$ 表示 $i$ 的子树放了 $j$ 个监听器，并且 $i$ 有/没有 放监听器，$i$ 有/没有 被覆盖到。

接下来是转移方程（$x \to t$）：

如果 $x$ 没有放监听器，也没有被覆盖到，那么 $t$ 显然不能放监听器（放了就覆盖到 $i$ 了）。

又因为现在 $x$ 不放，而且除了 $i$ 以外所有连接 $t$ 的节点都已经遍历过了，所以如果 $t$ 还没被监听，就没有机会再被监听了，所以 $t$ 必须被监听过。

即 $f[x][i+j][0][0]=f[x][i][0][0]\times f[t][j][0][1]$。

如果 $x$ 没有放监听器，被覆盖到了（即 $f[x][i+j][0][1]$），那么要不是 $x$ 的子树覆盖的，要不是 $t$ 覆盖的。

如果是 $x$ 的子树覆盖的，那么 $t$ 放不放都无所谓，但是 $t$ 必须被监听过（道理同上）。

如果是 $t$ 覆盖的，那么 $t$ 必须放，并且必须被监听过（同上）。

即 $f[x][i+j][0][1]=f[x][i][0][1]\times(f[t][j][0][1]+f[t][j][1][1])+f[x][i][0][0]\times f[t][j][1][1]$。

如果 $x$ 放了监听器，没有被覆盖到（即 $f[x][i+j][1][0]$），那么 $t$ 和 $x$ 的子树肯定都不能覆盖到 $x$，且 $t$ 有没有被覆盖到无所谓（因为接下来 $x$ 一定能覆盖 $t$）。即 $f[x][i+j][1][0]=f[x][i][1][0]\times(f[t][j][0][0]+f[t][j][0][1])$。

如果 $x$ 放了监听器，也被覆盖到了，那么还是两种可能，要不是 $x$ 的子树覆盖的，要不是 $t$ 覆盖的。

如果是 $x$ 的子树覆盖的，那么 $t$ 放不放都无所谓。并且此时 $x$ 一定能监听 $t$，所以 $t$ 是否被监听也无所谓。

如果 $x$ 的子树没有覆盖到，那么 $t$ 一定要覆盖到 $x$。是否被监听依旧无所谓（同上）。

即 $f[x][i+j][1][1]=f[x][i][1][1]\times(f[t][j][0][0]+f[t][j][0][1]+f[t][j][1][0]+f[t][j][1][1])+f[x][i][1][0]\times(f[t][j][1][0]+f[t][j][1][1])$。

注意几点：

1. 不用滚动数组，用一个 $tmp$ 数组存储之前的状态即可。
2. 开 long long 会爆两个点……所以需要用 int 存储，中途转 long long。
3. 取模后，任何乘法都会爆 int，且连加三次及以上也会爆 int。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 5;
const int mod = 1e9 + 7;
int n, m, head[N], to[N << 1], nxt[N << 1], etot;
int f[N][105][2][2], tmp[105][2][2];
int sz[N];
inline void link(int u, int v)
{
    to[etot] = v;
    nxt[etot] = head[u];
    head[u] = etot++;
}
inline void dfs(int x, int fa)
{
    f[x][0][0][0] = f[x][1][1][0] = 1;
    sz[x] = 1;
    for (int i = head[x]; ~i; i = nxt[i])
        if (to[i] != fa)
        {
            dfs(to[i], x);
            memcpy(tmp, f[x], sizeof(f[x]));
            memset(f[x], 0, sizeof(f[x]));
            for (int j = 0; j <= min(m, sz[x]); j++)
                for (int k = 0; k <= min(m - j, sz[to[i]]); k++)
                {
                    (f[x][j + k][0][0] += 1ll * tmp[j][0][0] * f[to[i]][k][0][1] % mod) %= mod;
                    (f[x][j + k][0][1] += (tmp[j][0][1] * (1ll * f[to[i]][k][1][1] + f[to[i]][k][0][1]) % mod +
                                           1ll * tmp[j][0][0] * f[to[i]][k][1][1] % mod) %
                                          mod) %= mod;
                    (f[x][j + k][1][0] += tmp[j][1][0] * (1ll * f[to[i]][k][0][0] + f[to[i]][k][0][1]) % mod) %= mod;
                    (f[x][j + k][1][1] += (tmp[j][1][0] * (1ll * f[to[i]][k][1][0] + f[to[i]][k][1][1]) % mod +
                                           tmp[j][1][1] * (1ll * f[to[i]][k][0][0] + f[to[i]][k][0][1] + f[to[i]][k][1][0] + f[to[i]][k][1][1]) % mod) %
                                          mod) %= mod;
                }
            sz[x] += sz[to[i]];
        }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    memset(head, -1, sizeof(head));
    cin >> n >> m;
    for (int i = 1, u, v; i < n; i++)
    {
        cin >> u >> v;
        link(u, v);
        link(v, u);
    }
    dfs(1, 0);
    cout << (f[1][m][0][1] + f[1][m][1][1]) % mod;
    return 0;
}
```

---

## 作者：Coros_Trusds (赞：0)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/16138220.html)

毒瘤树形 $dp$ 啊。。

# 题目大意

给定一棵树，如果在一个节点 $u$ 放一个监听设备，那么与 $u$ 相邻的节点 $v$ 都能被监听，但是 $u$ 不会被监听。现在有 $m$ 个监听设备，问能够监听整棵树且恰好使用了 $m$ 个监听设备的方案数。

一个节点至多放一个监听设备。

# 题目分析

借用大佬 @GKxx 的图：

![](https://cdn.luogu.com.cn/upload/pic/41854.png)

$$\tiny{\texttt{图 1,上图 x 即 i}}$$

令 $dp[i,j,0/1,0/1]$ 表示以 $i$ 为根的子树中一共放了 $j$ 装置，$i$ 点是否放了装置，$i$ 点有没有被覆盖到的方案数。

来推一推状态转移方程：

+ 当 $i$ 没被监听且没放监听装置时，$v(v\in son\{i\})$ 一定没有装监听设备，有 $dp[i,j+k,0,0]=\sum (dp[i,j,0,0]\times dp[v,k,0,1])$。

+ 当 $i$ 没被监听但放了监听装置时，$v$（$v$ 的定义如上）是否被监听不重要但是一定没有放装置，否则这里就可以被监听了，有 $dp[i,j+k,1,0]=\sum(dp[i,j,1,0]\times(dp[v,k,0,0]+dp[v,k,0,1]))$。

+ 当 $i$ 没放装置但被监听了时，分两种情况：

$i$ 侧的状态为 $dp[i,j,0,1]$：$dp[i,j+k,0,1]=\sum(dp[i,j,0,1]\times(dp[v,k,0,1]+dp[v,k,1,1]))$。

$i$ 侧的状态为 $dp[i,j,0,0]$：$dp[i,j+k,0,1]=\sum(dp[i,j,0,0]\times dp[v,k,1,1])$。注意这里没有 $dp[v,k,1,0]$，因为一定要让 $v$ 被覆盖，但是 $i$ 没放装置。

+ 当 $i$ 没放放了装置也被窃听了时：

$i$ 侧是状态 $dp[i,j,1,0]$：$dp[i,j+k,1,1]=\sum(dp[i,j,1,0]\times(dp[v,k,1,0]+dp[v,k,1,1]))$。

$i$ 侧是状态 $dp[i,j,1,1]$：$dp[i,j+k,1,1]=\sum(dp[i,j,1,1]\times(dp[v,k,0,0]+dp[v,k,0,1]+dp[v,k,1,0]+dp[v,k,1,1]))$。

# 代码

代码太难调了，调代码时间比思考时间还长。。

来张图了解下：

![屏幕截图 2022-04-12 231645.png](https://s2.loli.net/2022/04/12/sZyDM9kmXc3eHF2.png)

**上面这张图的写法太难调了，所以换了一种写法过了。**

注意全开 `long long` 会 $\verb!MLE!$，只能在过程中用 `long long`。

洛谷的蠢关键字制度使得代码传不上来，请到顶上链接内查看~

---

## 作者：Plozia (赞：0)

宣传博客->[link](https://blog.csdn.net/BWzhuzehao/article/details/114187950)

**特别提醒：本题卡空间。如果您的代码 `MLE` 了而且思路没有问题，请直接前往『关于卡空间』这一部分。**

P.S. `WA+MLE` 不计入上述范围内。

说句闲话：为什么 csdn 下渲染正常的 Latex 公式到你古就出问题了呀……

# 思路讲解：

本题是一道树上统计类 DP。

前置知识：树形 DP。

对于这道题，首先设下两维状态 $f[u][i]$，$u$ 为节点编号，$i$ 表示用了几个监听设备。

但是状态不够啊，我们不知道是否被监听，儿子节点是否被监听等等。

于是，我们新增两维 $0/1$ 状态来表示。

那么这道题的状态如下：

设 $f[u][i][0/1][0/1]$ 表示当前节点为 $u$ ，**子树中已经遍历的所有节点** 上放置 $i$ 个监听装备的方案数，**而且所有儿子节点均被监听**，其中第三维状态表示 $u$ 节点是否放下监听设备，第四维状态表示 $u$ 节点是否被 **儿子节点** 监听。

分情况讨论。以下均设 1 号节点为根节点， $now$ 为当前节点，$u$ 为儿子节点，$i$ 是 $now$ 子树中已经遍历的所有节点上放置的监听装备数，$j$ 是 $u$ 子树上放置的监听装备数，$V$ 为所有 $u$ 构成的集合。这里采用刷表法转移，目标为 $f[now][i+j][0/1][0/1]$。

1. $f[now][i+j][0][0]$

这个时候需要保证 $u$ 被监听，但是 $u$ 上面不能放监听装备，有转移方程：

$$f[now][i+j][0][0]=f[now][i][0][0] \times \sum_{u \in V}f[u][j][0][1]$$

2. $f[now][i+j][0][1]$

此时 $now$ 被监听了，但是需要考虑是谁监听的：

2. 1. 可以是 $u$ 来监听，此时 $now$ 之前不能被监听，然而 $u$ 要被监听，于是这一部分贡献：

$$f[now][i][0][0] \times \sum_{u \in V}f[u][j][1][1]$$

---

2. 2. 可以是别的节点来监听，此时 $u$ 放不放无所谓，然而 $u$ 要被监听，于是这一部分贡献：

$$f[now][i][0][1] \times \sum_{u \in V}(f[u][j][0][1]+f[u][j][1][1])$$

综上，有转移方程：

$$f[now][i+j][0][1] = f[now][i][0][0] \times \sum_{u \in V}f[u][j][1][1] + f[now][i][0][1] \times \sum_{u \in V}(f[u][j][0][1]+f[u][j][1][1])$$

3. $f[now][i+j][1][0]$

此时 $u$ 是否被监听无所谓，但是不能放装置，有转移方程：

$$f[now][i+j][1][0]=f[now][i][1][0] \times \sum_{u \in V}(f[u][j][0][0] + f[u][j][0][1])$$

4. $f[now][i+j][1][1]$

此时仍然要根据 $now$ 是否被监听来分类讨论：

4. 1. 由 $u$  来监听，但是因为 $now$ 放了装置，所以 $u$ 是否被监听无所谓，这一部分贡献为：

$$f[now][i][1][0] \times \sum_{u \in V}(f[u][j][1][0] + f[u][j][1][1])$$

---

4. 2. 不由 $u$ 来监听，此时 $u$ 放不放无所谓，是否被监听也无所谓，这一部分贡献为：

$$f[now][i][1][1] \times \sum_{u \in V}(f[u][j][0][0] + f[u][j][0][1] + f[u][j][1][0] + f[u][j][1][1])$$

综上，有转移方程：

$$f[now][i+j][1][1]=f[now][i][1][0] \times \sum_{u \in V}(f[u][j][1][0] + f[u][j][1][1])+f[now][i][1][1] \times \sum_{u \in V}(f[u][j][0][0] + f[u][j][0][1] + f[u][j][1][0] + f[u][j][1][1])$$

~~式子不是很长（确信~~

那么综合一下上面的四个方程：

$$f[now][i+j][0][0]=f[now][i][0][0] \times \sum_{u \in V}f[u][j][0][1]$$

$$f[now][i+j][0][1] = f[now][i][0][0] \times \sum_{u \in V}f[u][j][1][1] + f[now][i][0][1] \times \sum_{u \in V}(f[u][j][0][1]+f[u][j][1][1])$$

$$f[now][i+j][1][0]=f[now][i][1][0] \times \sum_{u \in V}(f[u][j][0][0] + f[u][j][0][1])$$

$$f[now][i+j][1][1]=f[now][i][1][0] \times \sum_{u \in V}(f[u][j][1][0] + f[u][j][1][1])+f[now][i][1][1] \times \sum_{u \in V}(f[u][j][0][0] + f[u][j][0][1] + f[u][j][1][0] + f[u][j][1][1])$$

初始状态为对于任意点 $now$，$f[now][0][0][0]=f[now][1][1][0]$。

最后答案是 $f[1][k][0][1]+f[1][k][1][1]$。

所有过程注意随时取模。

# 一些注意点：

1. 随时取模。
2. 转移的时候需要注意对于当前节点 $now$，我们需要临时数组 $tmp[i][0/1][0/1]$ 来存下当前节点的状态，防止因为修改而导致的 `WA`。具体可以参考我的代码。
3. 记得记录子树的大小，因为可能存在 $size_{now}<k$ 的情况，此时我们至多只能放 $size_{now}$ 个。

# 关于卡空间

这道题很毒瘤，我一开始开 `long long` 被卡空间了，最后看的题解才知道为什么会 `MLE`。

这道题需要注意：

1. 所有变量全部开 `int` 类型，尤其是 `f` 和 `tmp` 数组。
2. 运算的时候需要强制转换类型，同时取模。

代码：

```cpp
#include <bits/stdc++.h>
#define Min(a, b) ((a < b) ? a : b)
using namespace std;

typedef long long LL;
const int MAXN = 1e5 + 10, P = 1e9 + 7, MAXK = 100 + 10;
int n, k, f[MAXN][MAXK][2][2], tmp[MAXK][2][2], size[MAXN];
vector <int> Next[MAXN];

int read()
{
	int sum = 0, fh = 1; char ch = getchar();
	for (; ch < '0' || ch > '9'; ch = getchar()) fh -= (ch == '-') << 1;
	for (; ch >= '0' && ch <= '9'; ch = getchar()) sum = (sum << 3) + (sum << 1) + (ch ^ 48);
	return (fh == 1) ? sum : -sum;
}

void dfs(int now, int fa)
{
	size[now] = f[now][0][0][0] = f[now][1][1][0] = 1;
	for (int v = 0; v < Next[now].size(); ++v)
	{
		int u = Next[now][v];
		if (u == fa) continue;
		dfs(u, now);
		for (int i = 0; i <= k; ++i)
		{
			tmp[i][0][0] = f[now][i][0][0]; f[now][i][0][0] = 0;
			tmp[i][0][1] = f[now][i][0][1]; f[now][i][0][1] = 0;
			tmp[i][1][0] = f[now][i][1][0]; f[now][i][1][0] = 0;
			tmp[i][1][1] = f[now][i][1][1]; f[now][i][1][1] = 0;
		}
		for (int i = 0; i <= Min(size[now], k); ++i)
			for (int j = 0; j <= Min(size[u], k - i); ++j)
			{
				f[now][i + j][0][0] = ((LL)f[now][i + j][0][0] + (LL)tmp[i][0][0] * f[u][j][0][1]) % P;
				f[now][i + j][0][1] = ((LL)f[now][i + j][0][1] + (LL)tmp[i][0][0] * f[u][j][1][1] % P + (LL)tmp[i][0][1] * ((LL)f[u][j][0][1] + f[u][j][1][1]) % P) % P;
				f[now][i + j][1][0] = ((LL)f[now][i + j][1][0] + (LL)tmp[i][1][0] * ((LL)f[u][j][0][1] + f[u][j][0][0]) % P) % P;
				f[now][i + j][1][1] = ((LL)f[now][i + j][1][1] + (LL)tmp[i][1][0] * ((LL)f[u][j][1][0] + f[u][j][1][1]) % P + (LL)tmp[i][1][1] * ((LL)f[u][j][0][0] + f[u][j][0][1] + f[u][j][1][0] + f[u][j][1][1]) % P) % P;
			}
		size[now] += size[u];
	}
}

int main()
{
	n = read(), k = read();
	for (int i = 1; i < n; ++i)
	{
		int x = read(), y = read();
		Next[x].push_back(y); Next[y].push_back(x);
	}
	dfs(1, 1);
	printf("%d\n", ((LL)f[1][k][0][1] + f[1][k][1][1]) % P);
	return 0;
}
```

---

## 作者：RyexAwl (赞：0)

## 分析
设$f[u][j][0/1][0/1]$为在以$u$为根的子树放置恰好$j$个监听器，且除了点$u$其他点均被覆盖，点$u$是否被覆盖，点$u$是否放监听器的方案数。

首先考虑点$u$未被覆盖

如果点$u$未被覆盖，那么其子节点上一定是不能放监听器的。

接下来按点$u$是否放监听器做分类讨论：

如果节点$u$不放监听器，那么子节点在以其为根的子树内是一定被覆盖的。

那么有转移方程：
$$
f[u][j][0][0]=\sum_{P,\forall P_i,\sum_{P_{i,k}}=j}\ \prod_{p\in son(u),a_k=P_{i,k}}f[p][a_k][1][0]
$$

如果点$u$放监听器，那么子节点在以其为根点子树内既可以被覆盖，也可以未被覆盖。

那么有转移方程：
$$
f[u][j][0][1]=\sum_{P,\forall P_i,\sum_{P_{i,k}}=j-1}\ \prod_{p\in son(u),a_k=P_{i,k}}f[p][a_k][1][0]+f[p][a_k][0][0]
$$

如果点$u$被覆盖的话，那么对于$u$的子节点而言则需要至少有一个子节点放置监听器。

如果点$u$不放置监听器，那么子节点在以其为根的子树内一定被覆盖过。

对于每个子节点而言，都有放监听器与不放监听器两种决策，在统计完之后减掉所有子节点不放监听器的方案即我们要统计的方案。


那么有转移方程：
$$
\begin{aligned}
f[u][j][1][0]&=\sum_{P,\forall P_i,\sum_{P_{i,k}}=j}\ \prod_{p\in son(u),a_k=P_{i,k}}f[p][a_k][1][0]+f[p][a_k][1][1]-\sum_{P,\forall P_i,\sum_{P_{i,k}}=j}\ \prod_{p\in son(u),a_k=P_{i,k}}f[p][a_k][1][0]\\
&
\end{aligned}
$$
即
$$
f[u][j][1][0]=\sum_{P,\forall P_i,\sum_{P_{i,k}}=j}\ \prod_{p\in son(u),a_k=P_{i,k}}(f[p][a_k][1][0]+f[p][a_k][1][1])-f[u][j][0][0]
$$
接下来考虑点$u$放监听器的情况，我们发现其子节点的任一一种状态都可以满足与我们的需求，同理在最后减去所有子节点不放监听器点状态即可。

那么有转移方程：

$$
f[u][j][1][1]=\sum_{P,\forall P_i,\sum_{P_{i,k}}=j-1}\ \prod_{p\in son(u),a_k=P_{i,k}}(f[p][a_k][1][0]+f[p][a_k][1][1]+f[p][a_k][0][0]+f[p][a_k][0][1])-f[u][j][0][1]
$$
整理得：
$$
\begin{aligned}
&f[u][j][0][0]=\sum_{P,\forall P_i,\sum_{P_{i,k}}=j}\ \prod_{p\in son(u),a_k=P_{i,k}}f[p][a_k][1][0]\\
&f[u][j][0][1]=\sum_{P,\forall P_i,\sum_{P_{i,k}}=j-1}\ \prod_{p\in son(u),a_k=P_{i,k}}f[p][a_k][1][0]+f[p][a_k][0][0]\\
&f[u][j][1][0]=\sum_{P,\forall P_i,\sum_{P_{i,k}}=j}\ \prod_{p\in son(u),a_k=P_{i,k}}(f[p][a_k][1][0]+f[p][a_k][1][1])-f[u][j][0][0]\\
&f[u][j][1][1]=\sum_{P,\forall P_i,\sum_{P_{i,k}}=j-1}\ \prod_{p\in son(u),a_k=P_{i,k}}(f[p][a_k][1][0]+f[p][a_k][1][1]+f[p][a_k][0][0]+f[p][a_k][0][1])-f[u][j][0][1]
\end{aligned}
$$
## 代码实现
但是有了上面四个转移方程，我们目前并不能在程序中实现，考虑对上述转移方程做一些变型。

我们考虑一个更一般性的式子
$$
f[t]=\sum_{\sum c_i=t}\{\prod_{p\in S}w[p,c_i]\}
$$
其唯一的约束为$\sum c_i = t$

类似于分组背包，每次只考虑前$i$组：
$$
f[i][j]=\sum_k f[i-1][j-k]\times w[i][k]
$$




那么这样做的复杂度是多少呢？

显然，其复杂度是$O(nm^2)$的，这样是不足以过掉此题的。

而对于树上背包问题，我们可以通过优化上下限排除无用状态的方式优化到$O(nm)$。([具体证明](https://www.cnblogs.com/ouuan/p/BackpackOnTree.html))

令$cntsize$为当遍历到的子树大小的和（不包括子树$v$），$size[v]$为子树$v$的大小，$size[u]$为子树$u$的大小。

那么$j$的取值范围显然为$0\le j\le \min(cntsize+size[v])$

$k$的取值范围为$\max(j-cntsize,0)\le k\le \min(j,size[v])$

优化后的代码实现（全）：
```cpp
#include <iostream>

namespace wxy{
    typedef long long ll;
    const int N = 1e5 + 5,mod = 1e9 + 7;
    int head[N],fail[N << 1],edge[N << 1],tot;
    unsigned int f[N][105][2][2];
    bool vis[N];
    int n,m,size[N];
    inline void add(int x,int y){
        edge[++tot] = y;
        fail[tot] = head[x];
        head[x] = tot;
    }
    void dfs(int x){
        vis[x] = true;
        size[x] = 1;
        f[x][0][0][0] = f[x][0][0][1] = f[x][0][1][0] = f[x][0][1][1] = 1;
        for (int i = head[x];i;i = fail[i]){
            int v = edge[i];
            if (vis[v]) continue;
            dfs(v);
            int presize = size[x];
            size[x] += size[v];
            for (int j = std::min(size[x],m); j >= 0; j--){
                int p = std::max(0,j - presize - 1);
                if (p == 0){
                    f[x][j][0][0] = (1ll * f[x][j][0][0] * f[v][0][1][0]) % mod;
                    f[x][j][0][1] = (1ll * f[x][j][0][1] * (f[v][0][0][0] + f[v][0][1][0]) % mod) % mod;
                    f[x][j][1][0] = (1ll * f[x][j][1][0] * (f[v][0][1][0] + f[v][0][1][1]) % mod) % mod;
                    f[x][j][1][1] = (1ll * f[x][j][1][1] * (f[v][0][0][0] + f[v][0][0][1] + f[v][0][1][0] + f[v][0][1][1]) % mod) % mod;
                    p++;
                }else{
                    f[x][j][0][0] = f[x][j][0][1] = f[x][j][1][0] = f[x][j][1][1] = 0;
                }
                for (int k = p; k <= std::min(size[v],j); k++){
                    f[x][j][0][0] = (f[x][j][0][0] + (1ll * f[x][j - k][0][0] * (f[v][k][1][0])) % mod) % mod;
                    f[x][j][0][1] = (f[x][j][0][1] + (1ll * f[x][j - k][0][1] * (f[v][k][0][0] + f[v][k][1][0]) % mod) % mod) % mod;
                    f[x][j][1][0] = (f[x][j][1][0] + (1ll * f[x][j - k][1][0] * (f[v][k][1][0] + f[v][k][1][1]) % mod) % mod) % mod;
                    f[x][j][1][1] = (f[x][j][1][1] + (1ll * f[x][j - k][1][1] * (f[v][k][0][0] + f[v][k][0][1] + f[v][k][1][0] + f[v][k][1][1]) % mod) % mod) % mod;
                }
            }
        }
        for (int t = std::min(size[x],m); t > 0; t--){
            f[x][t][0][1] = f[x][t - 1][0][1];
            f[x][t][1][1] = f[x][t - 1][1][1];
        }
        f[x][0][0][1] = f[x][0][1][1] = 0;
        for (int t = 0; t <= std::min(size[x],m); t++){
            f[x][t][1][0] = (f[x][t][1][0] - f[x][t][0][0] + mod) % mod;
            f[x][t][1][1] = (f[x][t][1][1] - f[x][t][0][1] + mod) % mod;
        }
    }
    void main(){
        tot = 0;
        std::cin >> n >> m;
        for (int i = 1; i < n; i++){
            int a,b;
            std::cin >> a >> b;
            add(a,b);
            add(b,a);
        }
        dfs(1);
        std::cout << (f[1][m][1][0] + f[1][m][1][1]) % mod;
    }
}signed main(){wxy::main();return 0;}
```






---

## 作者：lgswdn_SA (赞：0)

## 部分分：

$\texttt{Subtask1 10pts  }n\le 20$

枚举每个点装不装监听器，然后判断是否可行

$\texttt{Subtask2 10pts  }k\le 10$

$k$ 很小，在随机情况下（也同样是数据）无法覆盖整个树，直接输出 $0$。

$\texttt{Subtask3 10pts  }$ 整个树是链

如果 $k$ 小于 $n-2$，那么无法覆盖住这个树，输出 $0$

所以如果我在考场上可以拿 $30$ 分……

---

## 正解：

显然这是个树形背包，我们可以用树形背包的常见套路做。$f(u,x,0/1,0/1)$ 代表第 $u$ 个节点子树用 $x$ 个监听器，$u$ 装/不装监听器，$u$有/没有被覆盖。

（以下 $v$ 代表 $u$ 的儿子）

---

对于 $f(u,x,0,0)$，由于自己不能被覆盖，所以 $v$ 就不能安装。由于自己不能安装，所以 $v$ 一定需要安装（否则就没有其他人去覆盖这个节点了）。

由于这个是乘法原理算种类数，所以应该是乘起来。

$$
f(u,i+j,0,0)=f(u,i,0,0)\times f(v,j,0,1)
$$

对于 $f(u,x,0,1)$，由于自己被覆盖，所以 $v$ 中至少有一个必须安装。

那么可以转移到这个状态的 $f(u)$ 应该有 $f(u,x,0,0)$ 和 $f(u,x,0,1)$，可以显然推得：  

$$
f(u,i+j,0,1)=f(u,i,0,0)\times f(v,j,1,1)+f(u,i,0,1)\times f(v,j,0/1,1)
$$

对于 $f(u,x,1,0)$，由于自己没有被覆盖，所以 $v$ 就不能安装。由于自己安装了，所以 $v$ 可以覆盖或者不覆盖。

$$
f(u,i+j,1,0)=f(u,i,1,0)\times f(v,j,0,0/1)
$$

对于 $f(u,x,1,1)$，由于自己被覆盖了，所以 $v$ 中至少有一个安装。可以转移到这个状态的 $f(u)$ 有 $f(u,x,1,0)$ 和 $f(u,x,1,1)$。

由于自己安装了，所 $v$ 可以覆盖或者不覆盖。

$$
f(u,i+j,1,1)=f(u,i,1,0)\times f(v,j,1,0/1)+f(u,i,1,1)\times f(v,j,0/1,0/1)
$$

初始化： $f(u,0,0,0)=f(u,1,1,0)=1$

---

## 代码&细节

推完式子就可以写代码了（转移方程长得有点难受）。

然后这题强制用 int 然后操作转 longlong 很杀人。

我对出题人卡空间的行为感到**非常不满**（

```foin(x,y)``` 函数代表两数相加并取模（在 int 转 longlong 操作中很实用）。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+3; const ll mod=1000000007;
struct edge{int to,nxt;}e[N*2]; int hd[N],tot;
void add(int u,int v){e[++tot]=(edge){v,hd[u]},hd[u]=tot;}
int n,k;
int foin(ll q,ll p){return (q+p)>mod?1ll*q+p-mod:q+p;}

int sz[N],f[N][103][2][2],t[103][2][2]; //树形背包常用的3个数组
void dfs(int u,int fa){
	f[u][0][0][0]=f[u][1][1][0]=sz[u]=1;
	for(register int p=hd[u],v;p;p=e[p].nxt)
		if((v=e[p].to)!=fa){
			dfs(v,u);
			for(register int i=0;i<=min(sz[u],k);i++)
				for(register int j=0;j<2;j++)
					for(register int k=0;k<2;k++)
						t[i][j][k]=f[u][i][j][k], f[u][i][j][k]=0;
			for(register int i=0;i<=min(sz[u],k);i++){
				for(register int j=0;j<=min(sz[v],k-i);j++){
					f[u][i+j][0][0]=foin(f[u][i+j][0][0],1ll*t[i][0][0]*f[v][j][0][1]%mod);
					f[u][i+j][0][1]=foin(f[u][i+j][0][1],(1ll*t[i][0][0]*f[v][j][1][1]+1ll*t[i][0][1]*(1ll*f[v][j][0][1]+f[v][j][1][1]))%mod);
					f[u][i+j][1][0]=foin(f[u][i+j][1][0],1ll*t[i][1][0]*(1ll*f[v][j][0][0]+f[v][j][0][1])%mod);
					f[u][i+j][1][1]=foin(f[u][i+j][1][1],foin((1ll*t[i][1][0]*(1ll*f[v][j][1][0]+f[v][j][1][1])%mod)
						,1ll*t[i][1][1]*(1ll*f[v][j][0][0]+f[v][j][0][1]+f[v][j][1][0]+f[v][j][1][1])%mod));
				}
			}
			sz[u]+=sz[v];
		}
}

int main(){
	scanf("%d%d",&n,&k);
	for(int i=1,u,v;i<n;i++)
		scanf("%d%d",&u,&v),add(u,v),add(v,u);
	dfs(1,0);
	printf("%lld",1ll*(f[1][k][0][1]+f[1][k][1][1])%mod);
	return 0;
}
```

---

## 作者：FjswYuzu (赞：0)

$\ \ \ \ \ \ \ $[luogu](https://www.luogu.com.cn/problem/P4516)

$\ \ \ \ \ \ \ $初看题面：哦，这难道不是一道水题么？直接切嘛。

$\ \ \ \ \ \ \ $类似于分类讨论被自控，被爸爸控制，被儿子控制嘛。

$\ \ \ \ \ \ \ $再看题面，发现：如果在自己这里放上监控，是无法被控制的。于是我们的树形 dp 就宣告爆炸。

$\ \ \ \ \ \ \ $因为~~根据讨论~~理性分析之后，我们发现，其实被控制是根本一样的。只有自己放或者不放的区别。

$\ \ \ \ \ \ \ $考虑以上影响因素以及我们的经验，定义 $dp_{i,j,0\ or\ 1,0\ or\ 1}$ 表示以 $i$ 为根的子树用 $j$ 个监控器，（根可以不被监听，但是其它节点必须被监听）当前节点放不放监控器，根是否被监听，可以得到一个很长的 dp 方程，太长懒得打，就放在代码里面吧。

$\ \ \ \ \ \ \ $但是这样就完了吗？这道题的难点就在于，我们这样的时间复杂度是 $O(nk^2)$ 的！！那么放上朴素代码。

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
//1
#define MOD 1000000007ll
using namespace std;
typedef long long LL;
/*
dp[i][j][0/1][0/1]:
以i为根，放j个监听器，根放了没有，被监听没有。
*/
vector<int> G[100005];
long long read()
{
	long long x=0,f=1;
	char c=getchar();
	while(c<'0' || c>'9')
	{
		if(c=='-')	f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x*f;
}//2
int dp[100005][105][2][2],tmpdp[105][2][2],sizen[100005],n,k;
void DP(long long now,long long pre)
{
	dp[now][0][0][0]=dp[now][1][1][0]=sizen[now]=1;
	for(unsigned int i=0;i<G[now].size();++i)
	{
		int to=G[now][i];
		if(to==pre)	continue;
		DP(to,now);
		memset(tmpdp,0,sizeof tmpdp);
		for(int j=0;j<=k;++j)
		{
			for(int l=0;l<=k-j;++l)//3
			{
				tmpdp[j+l][0][0]+=(
				(LL)dp[now][j][0][0]*dp[to][l][0][1])%MOD,
				tmpdp[j+l][0][0]%=MOD;
				tmpdp[j+l][0][1]+=(((
				(LL)dp[now][j][0][1]*dp[to][l][0][1])%MOD+
				(LL)dp[now][j][0][1]*dp[to][l][1][1])+
				(LL)dp[now][j][0][0]*dp[to][l][1][1])%MOD,
				tmpdp[j+l][0][1]%=MOD;
				tmpdp[j+l][1][0]+=((
				(LL)dp[now][j][1][0]*dp[to][l][0][1])+
				(LL)dp[now][j][1][0]*dp[to][l][0][0])%MOD,
				tmpdp[j+l][1][0]%=MOD;
				tmpdp[j+l][1][1]+=((((((
				(LL)dp[now][j][1][1]*dp[to][l][0][0])%MOD+
				(LL)dp[now][j][1][1]*dp[to][l][0][1])+
				(LL)dp[now][j][1][1]*dp[to][l][1][0])%MOD+
				(LL)dp[now][j][1][1]*dp[to][l][1][1])+
				(LL)dp[now][j][1][0]*dp[to][l][1][0])+
				(LL)dp[now][j][1][0]*dp[to][l][1][1])%MOD,
				tmpdp[j+l][1][1]%=MOD;//dp方程
			}
		}
		sizen[now]+=sizen[to];
		memcpy(dp[now],tmpdp,sizeof tmpdp);
	}
}
int main(){
// 	freopen("sneak.in","r",stdin);
// 	freopen("sneak.out","w",stdout);
	n=read(),k=read();
	for(int i=1;i<n;++i)
	{
		int u=read(),v=read();
		G[u].push_back(v);
		G[v].push_back(u);
	}
	DP(1,0);
	printf("%lld",(dp[1][k][0][1]+dp[1][k][1][1])%MOD);
	while(1)	return 0;
}
```

$\ \ \ \ \ \ \ $于是我们只能考虑优化。首先来试一下优化常数吧。

$\ \ \ \ \ \ \ $优化 1（对应注释1）：你的八聚氧。

$\ \ \ \ \ \ \ $优化 2（对应注释2）：你的 `fread()`。

$\ \ \ \ \ \ \ $优化 3（对应注释3）：放不了这么多放什么放，把 `j<=k` 改成 `min(k,sizen[now])`，`l<=k-j` 改成 `min(k-j,sizen[to])`。

$\ \ \ \ \ \ \ $交一发，为什么 A 了？？

$\ \ \ \ \ \ \ $删去优化 1 和 2，发现其实 1 和 2 并没有起很大作用，删掉 3 就只有 30 分了。这是为什么呢？

$\ \ \ \ \ \ \ $首先分析一下复杂度，这个优化看似是一个常数优化，但是实际上起到了至关重要的作用。

$\ \ \ \ \ \ \ $考虑证明，思来想去也不过三种情况：

1. 一个节点有两个儿子形成的子树大小大于 $k$：实际上合并次数就不会超过 $O(\frac{n}{k})$ 了。这样之后就会变成 $O(k)$。实际上这应该是最快的一种情况。

2. 一个节点有一个儿子形成的子树大小小于 $k$，合并了就成了大于 $k$ 了：因为子树的所有节点都经过一次背包合并，实际上均摊之后也只有 $O(k)$ 了。

3. otherwise：显然这个东西是不足 $O(k)$ 的。每次加入一个点，不足 $k$ 个节点，那么对于某一个特定的点，它的贡献实际上是每次加入的子树大小，还没有 $O(k)$ 了。

$\ \ \ \ \ \ \ $综上所述：我们的时间复杂度为 $O(nk)$。

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
#define MOD 1000000007ll
using namespace std;
typedef long long LL;
/*
dp[i][j][0/1][0/1]:
以i为根，放j个监听器，根放了没有，被监听没有。
*/
vector<int> G[100005];
long long read()
{
	long long x=0,f=1;
	char c=getchar();
	while(c<'0' || c>'9')
	{
		if(c=='-')	f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x*f;
}
int dp[100005][105][2][2],tmpdp[105][2][2],sizen[100005],n,k;
void DP(long long now,long long pre)
{
	dp[now][0][0][0]=dp[now][1][1][0]=sizen[now]=1;
	for(unsigned int i=0;i<G[now].size();++i)
	{
		int to=G[now][i];
		if(to==pre)	continue;
		DP(to,now);
		memset(tmpdp,0,sizeof tmpdp);
		for(int j=0;j<=min(k,sizen[now]);++j)
		{
			for(int l=0;l<=min(k-j,sizen[to]);++l)
			{
				tmpdp[j+l][0][0]+=(
				(LL)dp[now][j][0][0]*dp[to][l][0][1])%MOD,
				tmpdp[j+l][0][0]%=MOD;
				tmpdp[j+l][0][1]+=(((
				(LL)dp[now][j][0][1]*dp[to][l][0][1])%MOD+
				(LL)dp[now][j][0][1]*dp[to][l][1][1])+
				(LL)dp[now][j][0][0]*dp[to][l][1][1])%MOD,
				tmpdp[j+l][0][1]%=MOD;
				tmpdp[j+l][1][0]+=((
				(LL)dp[now][j][1][0]*dp[to][l][0][1])+
				(LL)dp[now][j][1][0]*dp[to][l][0][0])%MOD,
				tmpdp[j+l][1][0]%=MOD;
				tmpdp[j+l][1][1]+=((((((
				(LL)dp[now][j][1][1]*dp[to][l][0][0])%MOD+
				(LL)dp[now][j][1][1]*dp[to][l][0][1])+
				(LL)dp[now][j][1][1]*dp[to][l][1][0])%MOD+
				(LL)dp[now][j][1][1]*dp[to][l][1][1])+
				(LL)dp[now][j][1][0]*dp[to][l][1][0])+
				(LL)dp[now][j][1][0]*dp[to][l][1][1])%MOD,
				tmpdp[j+l][1][1]%=MOD;
			}
		}
		sizen[now]+=sizen[to];
		memcpy(dp[now],tmpdp,sizeof tmpdp);
	}
}
int main(){
// 	freopen("sneak.in","r",stdin);
// 	freopen("sneak.out","w",stdout);
	n=read(),k=read();
	for(int i=1;i<n;++i)
	{
		int u=read(),v=read();
		G[u].push_back(v);
		G[v].push_back(u);
	}
	DP(1,0);
	printf("%lld",(dp[1][k][0][1]+dp[1][k][1][1])%MOD);
	while(1)	return 0;
}
```

---

## 作者：asuldb (赞：0)

[题目](https://www.luogu.org/problemnew/show/P4516)

我好菜啊，嘤嘤嘤

原来本地访问数组负下标不会报$RE$或者$WA$，甚至能跑出正解啊

这道题还是非常呆的

我们发现$k$很小，于是断定这是一个树上背包

发现在一个点上安装控制器并不能控制这个点，可能需要到父亲那边才能控制这个点，于是我们设$dp[i][j][0/1][0/1]$表示在以$i$为根的子树里放置了$j$个监视器，控制了除了点$i$以外的点，在$i$点装没装控制器，$i$点有没有被控制

大力分类套论几个转移

$dp[i][j][0][0]$因为没有放监视器，必须要求其儿子们在他们的子树内部就被监视了，同时因为$i$还没有被监视，于是儿子不能放监视器，于是从$[0][1]$转移

$dp[i][j][1][0]$因为放了监视器，能监视儿子，于是儿子们有没有被监视都可以，但是都不能放监视器，于是从$[0][1]$和$[0][0]$转移

$dp[i][j][0][1]$因为没有放监视器，儿子们必须全部被监视到从$[0][1]$转移，因为$i$被监视，所以至少得有一个儿子放监视器，所以至少一个从$[1][1]$转移

$dp[i][j][1][1]$放了监视器，而要求被监视，从四种状态都能转移，但是要求至少有一个转移是$[1][0]$或$[1][1]$（放了监视器）

直接树形背包转移，之后大力容斥掉没有选择那个至少要选择的情况就好了

发现$dp[i][j][0][1]$要减掉的正好是$dp[i][j][0][0]$，$dp[i][j][1][1]$要减掉的正好是$dp[i][j][1][0]$

代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#define re register
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
const int maxn=1e5+5;
const int mod=1e9+7;
inline int read() {
	char c=getchar();int x=0;while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
struct E{int v,nxt;}e[maxn<<1];
int head[maxn],sum[maxn];
int dp[maxn][105][2][2];
int f[105][2][2];
int n,m,num;
inline void add(int x,int y) {e[++num].v=y;e[num].nxt=head[x];head[x]=num;}
inline int qm(int a) {return a>mod?a-mod:a;}
void dfs(int x,int fa) {
	int cur=0;
	sum[x]=1;
	for(re int i=head[x];i;i=e[i].nxt) {
		if(e[i].v==fa) continue;
		int v=e[i].v;
		dfs(v,x);cur++;
		sum[x]+=sum[v];
		int U=min(sum[x],m);
		if(cur==1) {
			for(re int k=0;k<=min(sum[v],m);k++) {
				dp[x][k][0][0]=dp[v][k][0][1];
				dp[x][k+1][1][0]=qm(dp[v][k][0][1]+dp[v][k][0][0]);
				dp[x][k+1][1][1]=(dp[v][k][1][1]+dp[v][k][1][0])%mod+(dp[v][k][0][0]+dp[v][k][0][1])%mod;
				dp[x][k+1][1][1]%=mod;
				dp[x][k][0][1]=qm(dp[v][k][1][1]+dp[v][k][0][1]);
			}
			continue;
		}
		for(re int j=U;j>=0;--j) {
			f[j][0][0]=dp[x][j][0][0],dp[x][j][0][0]=0;
			f[j][0][1]=dp[x][j][0][1],dp[x][j][0][1]=0;
			f[j][1][0]=dp[x][j][1][0],dp[x][j][1][0]=0;
			f[j][1][1]=dp[x][j][1][1],dp[x][j][1][1]=0;
		}
		for(re int j=U;j>=0;--j) 	
			for(re int k=0;k<=min(sum[v],m);k++) {
				int t=j-k;
				if(t<0) continue;
				dp[x][j][0][0]=(dp[x][j][0][0]+1ll*f[t][0][0]*dp[v][k][0][1]%mod)%mod;
				dp[x][j][1][0]=(dp[x][j][1][0]+1ll*f[t][1][0]*qm(dp[v][k][0][1]+dp[v][k][0][0])%mod)%mod;
				dp[x][j][0][1]=(dp[x][j][0][1]+1ll*f[t][0][1]*qm(dp[v][k][1][1]+dp[v][k][0][1])%mod)%mod;
				dp[x][j][1][1]=(dp[x][j][1][1]+1ll*f[t][1][1]*qm(qm(dp[v][k][1][1]+dp[v][k][1][0])+qm(dp[v][k][0][0]+dp[v][k][0][1]))%mod)%mod;
			}
	}
	if(!cur) {dp[x][0][0][0]=dp[x][1][1][0]=1;return;}
	for(re int j=0;j<=min(sum[x],m);j++)
		dp[x][j][0][1]=(dp[x][j][0][1]-dp[x][j][0][0]+mod)%mod,
		dp[x][j][1][1]=(dp[x][j][1][1]-dp[x][j][1][0]+mod)%mod;
}
int main() {
	n=read();m=read();
	for(re int x,y,i=1;i<n;i++)
		x=read(),y=read(),add(x,y),add(y,x);
	dfs(1,0);
	printf("%d\n",(dp[1][m][0][1]+dp[1][m][1][1])%mod);
	return 0;
}
```


---

## 作者：Honor誉 (赞：0)

[我的博客](https://blog.csdn.net/qq_35019468/article/details/102864520)

## 显然是树形DP

#### 但是推状态转移方程很想死啊！

$首先说一下DP[i][j][0/1][0/1]表示在树上的i点，一共放了j个监听设备，点i是否被覆盖，点i上是否有监听设备时，监听覆盖完点i的子树（不包括i）有多少种方案$。

$显然我们在dfs中更新时，是从儿子更新父亲，所以上面指的覆盖是指儿子对父亲的覆盖。还有我们需要设另一个数组来DP，设那个数组为dp1$

接下来就是恶心的四种情况讨论了。

## 首先，如果这个点更新后是DP[u][j][0][0]。

因为u没有被覆盖，所以son上一定没有监听设备，又因为需要完全覆盖，u不可能对son进行覆盖，所以son一定要被覆盖。

```cpp
dp[u][i+j][0][0]=(dp[u][i+j][0][0]+(dp1[i][0][0]*1ll*dp[v][j][1][0])%mod)%mod;
```

## 如果是DP[u][j][0][1]。
 
因为u没有被覆盖，所以son上一定没有监听设备，又因为u上有监听设备，所以son有没有被覆盖都行。

```cpp
dp[u][i+j][0][1]=(dp[u][i+j][0][1]+(dp1[i][0][1]*1ll*(dp[v][j][1][0]+dp[v][j][0][0])%mod)%mod)%mod;
```

## 如果是DP[u][j][1][0]。

因为u被覆盖了，所以u的更新之前的状态有可能没有被覆盖，或者被覆盖了，所以dp可以由两种更新前的状态（0,0）或（1,0）更新。

1.由（0,0）更新过来

这样的话，因为最终状态要求被覆盖，所以son上必须要有监听设备，又因为u不能对son进行覆盖，所以son一定要被覆盖。

2.由（1,0）更新过来

同理，因为u之前已经被覆盖了，所以son上有没有监听设备都可以，又因为u不能对son进行覆盖，所以son一定要被覆盖。

```cpp
dp[u][i+j][1][0]=(dp[u][i+j][1][0]+((dp1[i][0][0]*1ll*dp[v][j][1][1])%mod+0ll+(dp1[i][1][0]*1ll*(dp[v][j][1][0]+dp[v][j][1][1])%mod)%mod)%mod)%mod;
```

## 如果是DP[u][j][1][1]。

像上种情况一样，这种的dp也可以又两种更新前的状态（0,1）或（1,1）

1.由（0,1）更新过来

因为u上有监听设备，所以son上有没有被覆盖都可以，又因为u没有被覆盖（状态上要求被覆盖），所以son上有监听设备。

2.由（1,1）更新过来

同理，不过这次u已经被覆盖了，所以son上有没有监听设备都可以。

```cpp
dp[u][i+j][1][1]=(dp[u][i+j][1][1]+(dp1[i][0][1]*1ll*(dp[v][j][1][1]+dp[v][j][0][1])%mod)%mod+0ll+(dp1[i][1][1]*1ll*((((dp[v][j][1][0]+dp[v][j][1][1])%mod+dp[v][j][0][0])%mod+dp[v][j][0][1])%mod)%mod)%mod)%mod;
```

综上，四种情况的分类讨论已经完毕，程序主体也写出来了。

两个初始化：

```cpp
dp[u][0][0][0]=dp[u][1][0][1]=1;
```

```cpp
#include<bits/stdc++.h>
#define mod 1000000007
#define N 100010
#define M 110
using namespace std;
int n,m,to[N<<1],nxt[N<<1],head[N],cnt,size[N],x,y,dp[N][M][2][2],dp1[M][2][2];//哪一个点，子树放了几个，u是否覆盖，u是否放
void adde(int x,int y)
{
	to[++cnt]=y;
	nxt[cnt]=head[x];
	head[x]=cnt;
}
void dfs(int u,int fa)
{
	size[u]=1;
	dp[u][0][0][0]=dp[u][1][0][1]=1;
	for(int k=head[u];k;k=nxt[k])
	{
		int v=to[k];
		if(v!=fa)
		{
			dfs(v,u);
			for(int i=0;i<=m;i++)
			{
				dp1[i][0][0]=dp[u][i][0][0];
				dp[u][i][0][0]=0;
				dp1[i][1][0]=dp[u][i][1][0];
				dp[u][i][1][0]=0;
				dp1[i][0][1]=dp[u][i][0][1];
				dp[u][i][0][1]=0;
				dp1[i][1][1]=dp[u][i][1][1];
				dp[u][i][1][1]=0;
			}
			for(int i=0;i<=min(size[u],m);i++)
			{
				for(int j=0;j<=min(size[v],m-i);j++)
				{
					dp[u][i+j][0][0]=(dp[u][i+j][0][0]+(dp1[i][0][0]*1ll*dp[v][j][1][0])%mod)%mod;
					dp[u][i+j][0][1]=(dp[u][i+j][0][1]+(dp1[i][0][1]*1ll*(dp[v][j][1][0]+dp[v][j][0][0])%mod)%mod)%mod;
					dp[u][i+j][1][0]=(dp[u][i+j][1][0]+((dp1[i][0][0]*1ll*dp[v][j][1][1])%mod+0ll+(dp1[i][1][0]*1ll*(dp[v][j][1][0]+dp[v][j][1][1])%mod)%mod)%mod)%mod;
					dp[u][i+j][1][1]=(dp[u][i+j][1][1]+(dp1[i][0][1]*1ll*(dp[v][j][1][1]+dp[v][j][0][1])%mod)%mod+0ll+(dp1[i][1][1]*1ll*((((dp[v][j][1][0]+dp[v][j][1][1])%mod+dp[v][j][0][0])%mod+dp[v][j][0][1])%mod)%mod)%mod)%mod;
				}
			}
			size[u]+=size[v];
		}
	}
}
int main()
{
//	freopen("1.txt","r",stdin);
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		adde(x,y);
		adde(y,x);
	}
	dfs(1,-1);
	printf("%d\n",(dp[1][m][1][0]+dp[1][m][1][1])%mod);
	return 0;
}
```

## 附：好像DP开long long就会爆空间，所以好好写mod吧！！！

---


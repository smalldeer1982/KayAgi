# [SCOI2003] 切割多边形

## 题目描述

我们希望通过切割得到一个凸 $p$ 边形，$p\le 8$。

一开始的时候，你有一个 $n\times m$ 的矩形，即它的四角的坐标分别为 $(0,0), (0,m), (n,0), (n,m)$。每次，你可以选择一条直线把当前图形切割成两部分，保留其中一个部分（另一部分扔掉），切割线的长度为此直线在多边形内部的部分的长度。

求出最短的切割线总长度。

下面是一个例子，我们需要得到中间的多边形。

![](https://cdn.luogu.com.cn/upload/pic/18468.png)

分别沿着直线 $1,2,3,4$ 进行切割即可，得到中间的四边形。

## 说明/提示

样例对应于图中给出的例子。

## 样例 #1

### 输入

```
100 100
4
80 80
70 30
20 20
20 80```

### 输出

```
312.575```

# 题解

## 作者：离散小波变换° (赞：5)

## 题意简述

在一张$n\times m$的纸中，需要裁剪出其中的一个凸$k$边图案。每次裁剪会将一张纸剪成两张，并扔去其中一张。现在询问最短的裁剪线之和。

## 题解

感觉这题有一点恶评了，难度应该在绿~蓝以内。

为了方便书写，我们使用直线的一般形式表示，即$l:Ax+By+C=0$。

这边先普及一下解析几何中关于直线方程的相关知识。如果你已经学过，我觉得你不需要看这篇题解也能切这道题……

### 直线的交点

考虑两条直线：

$$\begin{cases}Ax+By+C&=0\cr A'x+B'y+C'&=0 \end{cases}$$

我们将$1$式乘上$A'$,$2$式乘上$A$，那么可以得到：

$$\begin{cases}AA'x+A'By+A'C&=0\cr AA'x+AB'y+AC'&=0 \end{cases}$$

上下两个式子相减，可以得到：

$$(A'B-AB')y=A'C-AC'$$

同理，我们也可以得到：

$$(A'B-AB')x=B'C-BC'$$

于是，我们就能够得到它们的交点为$\left(\dfrac{BC'-B'C}{AB'-A'B},\dfrac{AC'-A'C}{AB'-A'B}\right)$。

当然，还有一种特殊情况，就是两条直线平行。由于本题的特殊情况，不存在两条直线重合。因此，当出现两条直线平行（即$AB'=A'B$），特判即可。

特别值得注意的是，上述式子$A,A',B,B'$中存在$0$并不会影响结果的正确性。

### 两点确定直线

本题按照顺时针顺序输入各点坐标，我们需要根据每两个相邻的点求出过他们的直线。

考虑两个点$(a,b),(c,d)$，我们现在需要求出**一个**直线$l:Ax+By+C=0$。为什么要说是**一个**呢？因为$Akx+Bky+Ck=0$其实与上式等价。

分两种情况讨论：

- $C=0$。 这种情况非常简单。因为$aA+Bb=0$，所以可以直接得到$A=b,B=-a$时满足条件。

- $C\ne 0$。这种情况比较复杂。让我们讨论讨论。

由$Ax+By+C\Leftrightarrow Akx+Bky+Ck=0 \quad(k\ne 0)$，我们可以令$C=1$。可以联立方程组：

$$\begin{cases}Aa+Bb+1&=0 \cr Ac+Bd+1&=0 \end{cases}$$

考虑按照上面的方法，让一式乘以$c$，二式乘以$a$，得到：

$$\begin{cases}Aac+Bbc+c&=0 \cr Aac+Bad+a&=0 \end{cases}$$

同样的，让一式减去二式，得到$(bc-ad)B=a-c$

同理可以推出$(ad-bc)A=b-d$

那么这种情况下，可以得到一个$l:\dfrac{b-d}{ad-bc}x+\dfrac{a-c}{bc-ad}y+1=0$。

### 交点的位置

这里应该是最后一个要考虑的问题了。

我们在一张纸的**内部**，按照一条多边形的边做直线，我们需要知道它究竟会与哪两条直线产生交点。为了方便起见，我们求出这条边的中点$M\left(\dfrac{x_1+x_2}{2},\dfrac{y_1+y_1}{2}\right)$。

显然，只需要暴力枚举之前的每条直线，与当前直线求出交点，然后判断其中的哪两个点**刚好**包围了$M$。

$$\begin{gathered}\stackrel{\normalsize P_1}{\bullet}\kern{20pt}\stackrel{\normalsize P_2}{\bullet}\kern{20pt}\stackrel{\normalsize M}{\bullet}\kern{30pt}\stackrel{\normalsize P_3}{\bullet}\kern{10pt}\stackrel{\normalsize P_4}{\bullet}\kern{60pt}\stackrel{\normalsize P_5}{\bullet}\\[-19pt]\underline{\kern{250pt}}\end{gathered}$$

在这张图中，$P_2,P_3$即为我们的所求点。

（由于作者太菜了，只能画水平的直线。实际情况这条线可能是斜的，甚至有可能是垂直于$x$轴的。）

那么我们可以用两个点$L,R$表示当前**最接近**$M$的左右两个点的坐标。

同样的，有两种情况要考虑：

- 斜率不存在，即目前的交点$P$满足$P_x=M_x$。这种情况我们比较$P_y,M_y$，决定$P$在$M$的哪一侧即可。

- 斜率存在。直接判断$P_x,M_x$，判定$P$在$M$的哪一侧即可。

那么，这条剪切线的长度就是$|LR|=\sqrt{(L_x-R_x)^2+(L_y-R_y)^2}$。

### 暴力枚举

由于本题$k$的范围极小，所以可以直接$\mathcal O(k\times k!)$暴力搜索。

初始时，向当前的选边集合加入四条直线$x=0,y=0,x=n,y=m$即可。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;
typedef double LF;
const int MAXN =8+3;
struct Node{
    LF a,b,c; Node(LF _a=0,LF _b=0,LF _c=0):a(_a),b(_b),c(_c){}
}R[MAXN+3],L[MAXN+3];
LF X[MAXN],Y[MAXN],n,m; int k;
void get(Node l1,Node l2,LF &x,LF &y){
    if(fabs(l1.a*l2.b-l1.b*l2.a)<1e-9) {x=y=-1;return;}
    x=(l1.b*l2.c-l1.c*l2.b)/(l1.a*l2.b-l1.b*l2.a);
    y=(l1.c*l2.a-l1.a*l2.c)/(l1.a*l2.b-l1.b*l2.a);
}
double ans=INFINITY; bool vis[MAXN];
int _;
void dfs(int stp,double sum){
    if(stp==k+1){ans=min(ans,sum); return;}
    up(1,k,i){
        if(vis[i]) continue; vis[i]=true;
        LF mx=(X[i]+X[i+1])/2.0,my=(Y[i]+Y[i+1])/2.0;
        LF nsum=sum,px,py,qx,qy,dp=INFINITY,dq=INFINITY;
        up(1,stp+3,j){
            LF nx,ny; get(L[i],R[j],nx,ny); if(fabs(nx+1)<1e-9) continue;
            LF dis=sqrt((nx-mx)*(nx-mx)+(ny-my)*(ny-my));
            if(fabs(mx-nx)<1e-9){
                if(ny>my){if(dp>dis) dp=dis,px=nx,py=ny;}
                else {if(dq>dis) dq=dis,qx=nx,qy=ny;}
            } else{
                if(nx>mx){if(dp>dis) dp=dis,px=nx,py=ny;}
                else {if(dq>dis) dq=dis,qx=nx,qy=ny;}
            }
        }
        nsum+=sqrt((px-qx)*(px-qx)+(py-qy)*(py-qy));
        R[stp+4]=L[i]; dfs(stp+1,nsum); vis[i]=false;
    }
}
int main(){
    scanf("%lf%lf%d",&n,&m,&k);
    R[1].a=0,R[1].b=1,R[1].c=0;
    R[2].a=0,R[2].b=1,R[2].c=-m;
    R[3].a=1,R[3].b=0,R[3].c=0;
    R[4].a=1,R[4].b=0,R[4].c=-n;
    up(1,k,i) scanf("%lf%lf",&X[i],&Y[i]);
    X[k+1]=X[1],Y[k+1]=Y[1]; up(1,k,i){
        LF a=X[i],b=Y[i],c=X[i+1],d=Y[i+1];
        if(fabs(a*d-b*c)<1e-9) L[i].a=b,L[i].b=-a,L[i].c=0;
        else{
            L[i].a=(b-d)/(a*d-b*c);
            L[i].b=(a-c)/(b*c-a*d);
            L[i].c=1.0;
        }
    }
    dfs(1,0); printf("%.3lf\n",ans);
    return 0;
}
```

---

## 作者：One_JuRuo (赞：4)

感觉这道题难点全在计算几何的细节，调了几天qwq。

# 思路

观察到 $p$ 最大也只有 $8$，作为蒟蒻的我第一时间就想到了暴力搜索，每次选一条没算过的边计算加进去的切割线长度。

有了核心思想，我们就要处理细节了，搜索很好写，重点是如何求出切割线。

在这里介绍两种方法：

第一种，我们暴力找到这条边与所有目前存在的边的交点，然后求出题目中给到的两个点 $s,t$ 的中点 $mid$（其实只要是在线段 $s,t$ 上的点都可以，这里是为了方便直接取得中点），因为题目保证要切割出来的多边形是凸多边形，所以所有线的交点必然在 $s,t$ 的外面，而我们把找切割线的过程看做原有的线切新加的边，那么切割线应该是最里面的一段，所以我只需要找到能包含中点 $mid$ 且离中点 $mid$ 最近的两个点，再求距离即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/lt6d4h0c.png)

如上图，切割线就是红色的线段。

那么，怎么求那两个点呢，我们可以对所有交点进行排序（排序可以对 $x$ 或者 $y$ 进行排序，只不过当线水平时不能以 $y$ 排序，先竖直的时候不能以 $x$ 排序），然后小于中点 $mid$ 的所有点中最大的，和大于中点 $mid$ 的所有点中最小的就是要求的那两个点。

第二种，假设这条边的两个点分别为 $s,t$，那么我们只用求得射线 $s,t$ 与所有存在的线的交点中离 $t$ 最近的点和射线 $t,s$ 与所有存在的线的交点中离 $s$ 最近的点，再求两点距离即可。

# AC代码

找切割线的方法用的第一种。

(注：代码包含了大部分计算几何的基础内容，所以有很多函数这道题没用，大佬看的时候可以自动忽略，好像只有主函数、搜索函数和求交点的函数用到了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-8,pi=acos(-1.0);
const int N=100005;
/*这何尝不是一种火车头呢？*/
inline int dcmp(double x){return (x<-eps)?-1:(x>eps)?1:0;}//判断正负
inline double dabs(double x){return x*dcmp(x);}//绝对值 
/*向量（点）*/
struct vec{double x,y;vec(double _x=0,double _y=0){x=_x;y=_y;}};
inline bool cmp_vec(vec a,vec b){return (a.x!=b.x)?a.x<b.x:a.y<b.y;}
inline double len(vec a){return sqrt(a.x*a.x+a.y*a.y);}//模长 
inline double ang(vec a){return atan2(a.y,a.x);}//角度 
inline vec operator +(const vec &a,const vec &b){return vec(a.x+b.x,a.y+b.y);}
inline vec operator -(const vec &a,const vec &b){return vec(a.x-b.x,a.y-b.y);}
inline vec operator *(const vec &a,const double &b){return vec(a.x*b,a.y*b);}
inline vec operator /(const vec &a,const double &b){return vec(a.x/b,a.y/b);}
inline double operator *(const vec &a,const vec &b){return a.x*b.x+a.y*b.y;}//点积 
inline double operator ^(const vec &a,const vec &b){return a.x*b.y-a.y*b.x;}//叉积
inline vec rot(vec a,double the){return vec(a.x*cos(the)-a.y*sin(the),a.x*sin(the)+a.y*cos(the));}//旋转 
inline vec rot90(vec a){return vec(a.y,-a.x);}//特殊角旋转
inline vec rotpt(vec a,vec b,double the){return b+rot(a-b,the);}//a绕b旋转
/*线*/ 
struct line{vec s,t;line(vec _s=vec(0,0),vec _t=vec(0,0)){s=_s;t=_t;}};//线 
inline double maxx(line l){return max(l.s.x,l.t.x);}//大x
inline double maxy(line l){return max(l.s.y,l.t.y);}//大y 
inline double minx(line l){return min(l.s.x,l.t.x);}//小x
inline double miny(line l){return min(l.s.y,l.t.y);}//小y
inline double ang(line l){return ang(l.t-l.s);}//角度 
inline bool operator <(line &a,line &b){double a1=ang(a.t-a.s),a2=ang(b.t-b.s);return (dcmp(a2-a1))?a2>a1:dcmp((a.t-a.s)^(b.t-b.s))<0;} 
inline bool operator ==(vec &a,vec &b){return (!dcmp(a.x-b.x)&&!dcmp(a.y-b.y));}//点是否相等 
inline double dis(vec a,vec b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}//点距离
inline bool pd_pl(vec a,line b){return !dcmp((a-b.s)^(b.t-b.s));}//点是否在直线上
inline bool pd_px(vec a,line b){return pd_pl(a,b)&&(dcmp((a-b.s)*(a-b.t))<=0);}//点是否在线段上
inline vec footpt(vec a,line b){vec x=a-b.s,y=a-b.t,z=b.t-b.s;double s1=x*z,s2=-1.0*(y*z);return b.s+z*(s1/(s1+s2));}//求垂足（分别求as，at关于st的投影）
inline vec mirror(vec a,line b){return a+(footpt(a,b)-a)*2.0;}//a关于b的对称点
inline double dis_pl(vec a,line b){return dabs((a-b.s)^(a-b.t))/len(b.t-b.s);}//求a到直线b的距离（面积除以底边长）
inline double dis_px(vec a,line b){return (dcmp((a-b.s)*(b.t-b.s))<0)?len(a-b.s):(dcmp((a-b.t)*(b.t-b.s))>0)?len(a-b.t):dis_pl(a,b);}//求a到线段b的距离
inline vec pt_px(vec a,line b){return (dcmp((a-b.s)*(b.t-b.s))<0)?b.s:(dcmp((a-b.t)*(b.t-b.s))>0)?b.t:footpt(a,b);}//在线段b上与a最近的点
inline vec cross(line a,line b){vec x=a.t-a.s,y=b.t-b.s,z=a.s-b.s;return a.s+x*((y^z)/(x^y));}//求a与b的交点
inline bool pd_cross_lx(line a,line b){return (!dcmp((a.t-a.s)^(b.t-b.s)))?0:pd_px(cross(a,b),a);}//线段a与直线b是否相交
inline bool pd_cross_xx(line a,line b){return pd_cross_lx(a,b)&&pd_cross_lx(b,a);}//判断线段a是否与线段b相交
inline bool pd_cross_xx_(line a,line b)//判断两线段是否相交 （另一种方法，是否跨立） 
{
	if(maxx(a)<minx(b)||maxy(a)<miny(b)) return false;
	if(maxx(b)<minx(a)||maxy(b)<miny(a)) return false;
	double s1=(a.t-a.s)^(b.s-a.s),s2=(a.t-a.s)^(b.t-a.s);
	double s3=(b.t-b.s)^(a.s-b.s),s4=(b.t-b.s)^(a.t-b.s);
	return dcmp(s1)*dcmp(s2)<=0&&dcmp(s3)*dcmp(s4)<=0;//a的端点在b的两侧且b的端点在a的两侧 
}
inline double s_t(vec a,vec b,vec c){return dabs((b-a)*(c-a))/2;}//已知三点求三角形面积 
/*多边形*/
struct pol
{
	vector<vec> pt;
	inline vec& operator [](int x){return pt[x];}
	inline int ne(int x){return (x<pt.size()-1)?x+1:0;}
	inline void insert(vec p){pt.push_back(p);}
	inline void clear(){pt.clear();}
	inline int include(vec p)//点在多边形外:0,在多边形内:1,在多边形边上:2 
	{
		int cnt=0;
		for(int i=0;i<pt.size();i++)//射线法判断，射线方向为x轴正方向 
		{
			vec s=pt[i],t=pt[ne(i)];line l=line(s,t);
			if(pd_px(p,l)) return 2;
			if(dcmp(p.y-miny(l))>=0&&dcmp(maxy(l)-p.y)>0)
			if(dcmp(s.x+((p.y-s.y)/(t.y-s.y)*(t.x-s.x))-p.x)>0) cnt++;
		}
		return cnt&1;//偶数个交点则在多边形外，奇数个交点则在多边形内 
	}
	inline double s_p()//多边形面积 
	{
		double ans=0;
		for(int i=1;i<pt.size()-1;i++) ans+=(pt[i]-pt[0])^(pt[ne(i)]-pt[0]);
		return dabs(ans)/2;
	}
	inline double c_p()//多边形周长 
	{
		double ans=0;
		for(int i=0;i<pt.size();i++) ans+=dis(pt[i],pt[ne(i)]);
		return ans;
	}
	inline bool pd_l(vec x,vec l,vec r){return dcmp((l-x)^(r-x))<=0;}//xl是否在xr的左侧
	inline int include_(vec p)//二分法判断点是否在多边形内
	{
		int n=pt.size();
		if(!pd_l(pt[0],p,pt[1])) return 0;
		if(!pd_l(pt[0],pt[n-1],p)) return 0; 
		if(pd_px(p,line(pt[0],pt[1]))) return 2;
		if(pd_px(p,line(pt[0],pt[n-1]))) return 2;
		int l=1,r=n-2,ans=1,mid;
		while(l<=r)//二分找到最接近线(pt[0],p)的(pt[0],pt[ans]) 
		{
			mid=l+r>>1;
			if(!pd_l(pt[0],pt[mid],p)) l=mid+1,ans=mid;
			else r=mid-1;
		}
		if(!pd_l(pt[ans],p,pt[ne(ans)])) return 0;
		if(pd_px(p,line(pt[ans],pt[ne(ans)]))) return 2;
		return 1;
	} 
};
/*凸包*/
inline void andrew(pol &p)
{
	vector<vec>q(p.pt.size()<<1);int top=0,n=p.pt.size();
	sort(p.pt.begin(),p.pt.end(),cmp_vec),q[top]=p[0];
	for(int i=1;i<n;i++)
	{
		while(top&&dcmp((q[top-1]-q[top])^(q[top-1]-p[i]))<=0) top--;
		q[++top]=p[i];
	}
	int tot=top;
	for(int i=n-2;i>=0;i--)
	{
		while(top>tot&&dcmp((q[top-1]-q[top])^(q[top-1]-p[i]))<=0) top--;
		q[++top]=p[i];
	}
	if(n>1) top--;
	p.clear();
	for(int i=0;i<=top;i++) p.insert(q[i]);
}
/*旋转卡壳*/
inline double diam(pol p)
{
	int n=p.pt.size();double ans=0;
	for(int i=0,j=1;i<n;i++)
	{
		for(;;j=p.ne(j)) if(dcmp(s_t(p[j],p[i],p[p.ne(i)])-s_t(p[p.ne(j)],p[i],p[p.ne(i)]))>=0) break;
		ans=max(ans,max(dis(p[j],p[i]),dis(p[j],p[p.ne(i)])));
	}
	return ans;
}
/*main*/
int n,m,k;
double minn=100000;
vec a[15];
line l[10],bj[4];
bool st[10];
inline bool cmp_x(vec a,vec b){return a.x<b.x;}
inline bool cmp_y(vec a,vec b){return a.y<b.y;}
void dfs(int u,double ans)
{
	if(u==k){minn=min(minn,ans);return;}//更新答案
	for(int i=0;i<k;i++)//暴力找每条边
	{
		if(!st[i])
		{
			int cnt=0;
			vec p[20],mid=(l[i].s+l[i].t)/2.0,a,b;
			for(int j=0;j<4;j++) p[++cnt]=cross(l[i],bj[j]); 
			for(int j=0;j<k;j++) if(st[j]) p[++cnt]=cross(l[i],l[j]);//暴力求的当前边与所有存在的边的交点
			if(dcmp(p[1].x-p[cnt].x)==0)//如果是竖直的就以y排序（记得double的精度问题）
			{
				sort(p+1,p+cnt+1,cmp_y);//排序
				for(int i=1;i<=cnt;i++)
				{
					if(dcmp(p[i].y-mid.y)<0) a=p[i];//越靠后面的点y值更大，那么一直赋值直到出现y大于中点的情况，就可以找到第一个点
					else {b=p[i];break;}//第一个y大于中点的点就是我们要找的点
				}
			}
			else//以x排序的情况，与上面一种基本一样
			{
				sort(p+1,p+cnt+1,cmp_x);
				for(int i=1;i<=cnt;i++)
				{
					if(dcmp(p[i].x-mid.x)<0) a=p[i];
					else {b=p[i];break;}
				}
			}
			st[i]=1,dfs(u+1,ans+dis(a,b)),st[i]=0;//普普通通的dfs
		}
	}
}
int main()
{
	int a,b;pol p;
	scanf("%d%d%d",&n,&m,&k);
    bj[0]=line(vec(0,0),vec(0,m)),
    bj[1]=line(vec(n,0),vec(n,m)),
    bj[2]=line(vec(0,0),vec(n,0)),
    bj[3]=line(vec(0,m),vec(n,m));//要记得加入最开始的四条边
	for(int i=0;i<k;i++) scanf("%d%d",&a,&b),p.insert(vec(a,b));
	for(int i=0;i<k;i++) l[i]=line(p[i],p[p.ne(i)]);
	dfs(0,0);
	printf("%.3lf",minn);
}
```

---

## 作者：Flan (赞：3)

首先此题有一个显而易见的策略：每次切割都沿多边形的边缘。  
那么就可以状压 dp 求解最小切割线，具体怎么转移也不必啰嗦了。  
唯一的难点在于求解单次切割的长度。  
不难发现，切 $FG$ 的切割线正好是 $FG$ 所在直线与已有的切割线集合 $\{KJ, IL, AB, BC, CD, AD\}$ 的两个交点 $M, N$ 之间的线段 $MN$。可以枚举所有已有切割线，求出 $M, N$。  
![](https://cdn.luogu.com.cn/upload/image_hosting/z3q2voft.png)
为了表达没有斜率的直线，我使用一般式方程。解方程的时候一定要特判除 $0$、平行等毒瘤情况。
```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>

inline double min(const double& a, const double& b){
	return a < b ? a : b;
}

const int MAXQ = 8 + 1;

double dp[1 << 8];

int n, m, q;

struct Point{
	double x, y;
	Point(){}
	Point(double a, double b){
		x = a, y = b;
	}
	bool operator<(const Point& b)const{
		return std::fabs(x - b.x) < 1e-12 ? y < b.y : x < b.x;
	}
	bool operator>(const Point& b)const{
		return std::fabs(x - b.x) < 1e-12 ? y > b.y : x > b.x;
	}
}p[MAXQ];

struct Line{
	double a, b, c;//一般式
	Line(){}
	Line(double __a, double __b, double __c){//参数构造直线
		a = __a, b = __b, c = __c;
	}
	Line(Point __a, Point __b){//两点构造直线
		if(std::fabs(__a.x - __b.x) < 1e-12)
			a = 1, b = 0, c = -__a.x;
		else
			a = -__a.y + __b.y, b = __a.x - __b.x, c = -a * __a.x - b * __a.y;
	}
	Point operator^(const Line& __b)const{//重载 ^ 运算符求解两直线交点
		if(std::fabs(b) < 1e-12 || std::fabs(__b.b) < 1e-12){
			if(std::fabs(b) < 1e-12 && std::fabs(__b.b) < 1e-12)
				return Point(1e18, 1e18);
			else if(std::fabs(b) < 1e-12){
				double x = -c / a, y = -(__b.a * x + __b.c) / __b.b;
				return Point(x, y);
			}
			else{
				double x = -__b.c / __b.a, y = -(a * x + c) / b;
				return Point(x, y);
			}
		}
		else if(std::fabs(a / b - __b.a / __b.b) < 1e-12)
			return Point(1e18, 1e18);
		else{
			double x = -(c * __b.b - __b.c * b) / (a * __b.b - __b.a * b),
				y = -(a * x + c) / b;
			return Point(x, y);
		}
	}
}line[MAXQ];

inline double dist(Point a, Point b){
	double x = a.x - b.x, y = a.y - b.y;
	x *= x, y *= y;
	return std::sqrt(x + y);
}

double value(int status, int node){
	Point tmp, l = p[node], r = p[node % q + 1], re_l, re_r,
		mid = Point((l.x + r.x) / 2, (l.y + r.y) / 2);
//re_l, re_r 是切割线与已有切痕的两个交点
	if(std::fabs(line[node].a) < 1e-12)
		re_l = line[node] ^ Line(1, 0, 0),
		re_r = line[node] ^ Line(1, 0, -n);
	else if(std::fabs(line[node].b) < 1e-12)
		re_l = line[node] ^ Line(0, 1, 0),
		re_r = line[node] ^ Line(0, 1, -m);
	else if(line[node].a / line[node].b > 0)
		re_l = std::max(line[node] ^ Line(0, 1, -m), line[node] ^ Line(1, 0, 0)),
		re_r = std::min(line[node] ^ Line(0, 1, 0), line[node] ^ Line(1, 0, -n));
	else if(line[node].a / line[node].b < 0)
		re_l = std::max(line[node] ^ Line(0, 1, 0), line[node] ^ Line(1, 0, 0)),
		re_r = std::min(line[node] ^ Line(0, 1, -m), line[node] ^ Line(1, 0, -n));
	for(int i = 1; i <= q; ++i)
		if(status & (1 << i - 1)){
			tmp = line[node] ^ line[i];
			if(tmp < mid)
				re_l = std::max(re_l, tmp);
			else if(tmp > mid)
				re_r = std::min(re_r, tmp);
		}
	return dist(re_l, re_r);
}

int main(){
	std::scanf("%d%d%d", &n, &m, &q);
	for(int i = 1; i <= q; ++i)
		std::scanf("%lf%lf", &p[i].x, &p[i].y);
	for(int i = 1; i <= q; ++i)
		line[i] = Line(p[i], p[i % q + 1]);
	for(int i = 1; i < (1 << q); ++i){
		dp[i] = 1e18;
		for(int j = 1; j <= q; ++j)
			if(i & (1 << j - 1))
				dp[i] = min(dp[i], dp[i ^ (1 << j - 1)] + value(i ^ (1 << j - 1), j));//朴素状压
	}
	std::printf("%lf\n", dp[(1 << q) - 1]);
	return 0;
}
```
时间复杂度大概是 $O(2 ^ n)$？

---

## 作者：辰星凌 (赞：2)

# **【题解】切割多边形 [SCOI2003] [P4529] [Bzoj1091]**

[$\mathcal{My}\ \mathcal{Blog}$](https://www.cnblogs.com/Xing-Ling/p/12116733.html)

传送门：[切割多边形 $\text{[SCOI2003] [P4529]}$](https://www.luogu.com.cn/problem/P4529) [$\text{[Bzoj1091]}$](https://www.lydsy.com/JudgeOnline/problem.php?id=1091)

## **【题目描述】**

给出一个 $Mx*My$ $(0 < Mx,My < 500)$ 的矩形，现要用 $n$ $(3 \leqslant n \leqslant 8)$ 条直线依次对其进行切割，将它变成凸 $n$ 边形，每次切割的长度为该直线在剩下的矩形内部的部分的长度，求最短的切割线总长度。

## **【分析】**

一道计算几何膜您题。

由于 $n$ 比较小，可以 $O(n!)$ 枚举切割线的顺序，最后计算总长度取最小值就行了。

但有个非常麻烦的问题：如何求每次加入直线的切割线长度？

考虑用一个栈储存当前已经加入的直线（上下左右四个边界会在最初时加入），如果现在要加入直线 $p_1-p_2$（这里为方便描述，设 $p_1$ 在左边，$p_2$ 在右边），先求出它与栈中所有直线的交点，然后在这些交点中分别找到：$p_1$ 左边距离 $p_1$ 最近的点 $ans_1$ 和 $p_2$ 右边距离 $p_2$ 最近的点$ans_2$，易知 $len(ans_1,ans_2)$ 即为当次切割线长度。

图就不画了，自己领会吧。。。

## **【Code】**

```cpp
#include<algorithm>
#include<cstdio>
#include<cmath>
#define LD double
#define LL long long
#define Re register int
#define Vector Point
using namespace std;
const int N=20;
const LD eps=1e-9,inf=1e9;
inline int dcmp(LD a){return a<-eps?-1:(a>eps?1:0);}//处理精度
inline LD Abs(LD a){return a*dcmp(a);}//取绝对值
struct Point{
    LD x,y;Point(LD X=0,LD Y=0){x=X,y=Y;}
    inline void in(){scanf("%lf%lf",&x,&y);}
    inline void out(){printf("%.2lf %.2lf\n",x,y);}
}p1,p2,p3,p4,P[N];
struct Line{
    Point a,b;int id;LD k;Line(Point X=Point(0,0),Point Y=Point(0,0),int ID=0,LD K=0){a=X,b=Y,id=ID,k=K;}
    inline void sakura(){k=(!dcmp(a.x-b.x))?0.0:(a.y-b.y)/(a.x-b.x);}
    inline bool operator<(Line O)const{return k<O.k;}
}L[N],Q[N];
inline LD Dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}//点积
inline LD Cro(Vector a,Vector b){return a.x*b.y-a.y*b.x;}//叉积
inline LD Len(Vector a){return sqrt(Dot(a,a));}//模长
inline Point operator+(Point a,Vector b){return Vector(a.x+b.x,a.y+b.y);}
inline Vector operator-(Point a,Point b){return Vector(a.x-b.x,a.y-b.y);}
inline Vector operator*(Vector a,LD b){return Vector(a.x*b,a.y*b);}
inline Point cross_LL(Point a,Point b,Point c,Point d){//两直线AB,CD的交点
    Vector x=b-a,y=d-c,z=a-c;
    return a+x*(Cro(y,z)/Cro(x,y));//点A加上向量AF
}
int n,t,a[N],vis[N];LD Mx,My,Ans=inf;
inline void dfs(Re g,LD ans){
    if(g>n){Ans=min(Ans,ans);return;}
    for(Re i=1;i<=n;++i)
        if(!vis[i]){
            Point p1=L[i].a,p2=L[i].b,ans1=Point(inf,inf),ans2=Point(inf,inf);
            //ans1:在p2-p1延长线上距离p1最近的点
            //ans2:在p1-p2延长线上距离p2最近的点
            for(Re j=1;j<=t;++j){
                Point b=cross_LL(p1,p2,Q[j].a,Q[j].b);//获取直线L[i]与Q[i]的交点b
                if(dcmp(Len(p1-b)-Len(p2-b))<0&&dcmp(Len(p1-ans1)-Len(p1-b))>0)ans1=b;//如果 len(b,p1)<len(b,p2) 且 len(p1,b)<len(p1,ans1)
                if(dcmp(Len(p2-b)-Len(p1-b))<0&&dcmp(Len(p2-ans2)-Len(p2-b))>0)ans2=b;//如果 len(b,p2)<len(b,p1) 且 len(p2,b)<len(p2,ans2)
            }
            vis[i]=1,Q[++t]=L[i];
            dfs(g+1,ans+Len(ans1-ans2));//加上len(ans1,ans2)
            vis[i]=0,--t;
        }
}
int main(){
//  freopen("123.txt","r",stdin);
    scanf("%lf%lf%d",&Mx,&My,&n);
    for(Re i=1;i<=n;++i)P[i].in();
    for(Re i=1;i<=n;++i)L[i]=Line(P[i],P[i<n?i+1:1],i);//获取n条直线
    p1=Point(0,0),p2=Point(0,My),p3=Point(Mx,My),p4=Point(Mx,0);//四个顶点
    Q[++t]=Line(p1,p2),Q[++t]=Line(p2,p3),Q[++t]=Line(p3,p4),Q[++t]=Line(p4,p1);//先将四个边界入队
    dfs(1,0.0);
    printf("%.3lf\n",Ans);
}
```


---


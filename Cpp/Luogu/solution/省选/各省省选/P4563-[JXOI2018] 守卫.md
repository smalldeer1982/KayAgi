# [JXOI2018] 守卫

## 题目背景

九条可怜是一个热爱运动的女孩子。

## 题目描述

这一天她去爬山，她的父亲为了她的安全，雇了一些保镖，让他们固定地呆在在山的某些位置，来实时监视九条可怜，从而保护她。

具体来说，一座山可以描述为一条折线，折线的下方是岩石。这条折线有 $n$ 个折点，每个折点上有一个亭子，第 $i$ 个折点的坐标是 $(i,h_i)$ 。九条可怜只可能会在亭子处玩耍，那些保镖也只会在亭子处监视可怜。

由于技术方面的原因，一个保镖只能监视所有他能看得到的，横坐标不超过他所在位置的亭子。我们称一个保镖能看到一个亭子 $p$ ，当且仅当他所在的亭子 $q$ 和 $p$ 的连线不经过任何一块岩石。特别地，如果这条连线恰好经过了除了 $p,q$ 以外的亭子，那么我们认为保镖看不到可怜。

雇佣保镖是一件很费钱的事情，可怜的父亲希望保镖越少越好。

可怜的父亲还希望得到详尽的雇佣保镖的方案，他知道有些亭子可能正在维修，他想对所有的 $1\leq l\leq r\leq n$ 计算：如果事先已知了只有区间 $[l,r]$ 的亭子可以用来玩耍（和监视），那么最少需要多少个保镖，才能让 $[l,r]$ 中的每一个亭子都被监视到。

可怜的父亲已经得到了一个结果，他希望和你核实他的结果是否正确。

## 说明/提示

### 样例解释

如果 $r-l+1\leq 2$，那么答案显然是 $1$。

如果 $l=1$，$r=n$，那么答案是 $2$，需要安排两个保镖在 $(2,3),(3,1)$ 两个位置监视可怜。

### 数据范围与提示

对于 $30\%$ 的数据，$n\leq 20$。  
对于 $70\%$ 的数据，$n\leq 500$。  
对于 $100\%$ 的数据，$n\leq 5000$，$1\leq h_i\leq 10^9$。

## 样例 #1

### 输入

```
3
2 3 1```

### 输出

```
3
```

# 题解

## 作者：Ebola (赞：41)

本题的误导性极强，看到题大部分人都会去想凸包、单调栈一类的东西

显然的有这么一个事实：若游戏的区间是$[l, r]$，那么$r$号亭子必然需要放一个保镖

于是我们确定右端点，然后可以从右往左扫，记$p$表示$r$号亭子能看到的最左边的亭子。然后扫的过程中，用一个sum记录p及其右边部分的答案。因为r最左端能看到的点是$p$，所以$p-1$的纵坐标必然低于$p$，所以对于$[l, p-1]$这一段，我们必然要在$p$或$p-1$中选一个放置保镖，故有：

$f_{l,r}=sum+\min(f_{l,p-1},f_{l,p})$

在扫的过程中，$p$和$sum$也是需要更新的，若当前点是$r$号亭子可见的，那么必然要在之前的$p$和$p-1$中选一个放置保镖，所以$sum$要加上$\min(f_{l+1,p-1},f_{l+1,p})$，然后将$p$更新至当前的$l$

考虑可见性判定，显然只要$l$与$r$的连线，比$p$与$r$的连线斜率更大，$l$就是可见的

就这样，做完了……如果想的方向对了真的非常简单

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=5010;
int f[N][N],h[N],n;

double slope(int l,int r){return (double)(h[r]-h[l])/(r-l);}
bool cansee(int l,int x,int r){return slope(x,r)>slope(l,r);}

int main()
{
    int ans=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",h+i);
    for(int r=1;r<=n;r++)
    {
        ans^=(f[r][r]=1);
        int sum=1,p=0;
        for(int l=r-1;l>=1;l--)
        {
            if(!p||cansee(l,p,r)) sum+=min(f[l+1][p-1],f[l+1][p]),p=l;
            ans^=(f[l][r]=sum+min(f[l][p-1],f[l][p]));
        }
    }
    cout<<ans<<endl;
    return 0;
}
```



---

## 作者：duyi (赞：23)

[更好的阅读体验](https://www.cnblogs.com/dysyn1314/p/14479644.html)

# LOJ2545 「JXOI2018」守卫

## 题目大意

有 $n$ 座山，第 $i$ 座山是从 $(i, 0)$ 到 $(i, h_i)$ 的线段。称从第 $i$ 座山能看到第 $j$ 座山，当且仅当 $i\geq j$ 且不存在 $i < k < j$ 使得 $(j, h_j)$ 到 $(i, h_i)$ 的连线经过了第 $k$ 座山（恰好交于一点也算经过）。

对一段区间 $[l, r]$ ($1\leq l\leq r\leq n$)，你希望在其中选出最少数量的山，使得 $[l, r]$ 中每座山都能被至少一座选出的山看到。最少需要选出的山的数量，即为这段区间的花费。

求所有区间的花费的异或和。

数据范围：$1\leq n\leq 5000$，$1\leq h_i\leq 10^9$。

## 本题题解

记区间 $[l, r]$ 的花费为 $f(l, r)$。

枚举右端点 $r$。

首先，位置 $r$ 必须被选出来，否则没有其它位置能看到它。

选出 $r$ 后，考虑哪些位置能被 $r$ 看见。对 $1\leq i < r$，设 $s_i$ 表示点 $(i, h_i)$ 到 $(r,h_r)$ 的斜率，即 $s_i = \frac{h_r - h_i}{r - i}$。则位置 $i$ 能被 $r$ 看见，当且仅当 $\forall i < j < r: s_i < s_j$。这是因为如果存在 $s_j\leq s_i$，意味着 $i$ 会被第 $j$ 座山挡住。

于是，我们从 $r$ 到 $1$ 依次枚举 $l$，可以顺便推出 $[l, r]$ 里所有能被 $r$ 看见的位置，设它们为 $p_1, p_2, \dots, p_k$ ($l\leq p_1 < p_2 < \dots < p_k = r$)，另外不妨设 $p_0 = l - 1$。那么每一段非空的 $[p_i + 1, p_{i + 1} - 1]$ ($0\leq i < k$)，是 $r$ 看不见的。更准确地说，$p_{i + 1}$ 后面的位置都看不见它们。所以它们只能靠自己被看见（在内部解决）。因此，$p_{i + 1} - 1$ 和 $p_{i + 1}$ 这两个位置必有一个被选，因此解决 $[p_i + 1, p_{i + 1} - 1]$ 这段的花费就是：$\min\{f(p_{i} + 1, p_{i + 1} - 1), f(p_{i} + 1, p_{i + 1})\}$。

于是我们得到：
$$
f(l, r) = \sum_{i = 0}^{k - 1}\min\{f(p_{i} + 1, p_{i + 1} - 1), f(p_{i} + 1, p_{i + 1})\}
$$
这样朴素转移是 $\mathcal{O}(n^3)$ 的。

它很容易优化。发现除了第一段（$[l, p_1 - 1]$）的长度在变化，其它每段从产生起就是固定的。所以可以用一个变量记录后面每段的花费之和。另外，不难发现这个变量就等于 $f(p_1 + 1, r)$，所以甚至不需要记录，直接这样转移即可：
$$
f(l, r) = \min\{f(l, p_1 - 1), f(l, p_1)\} + f(p_1 + 1, r)
$$
时间复杂度 $\mathcal{O}(n^2)$。

## 总结

本题如果往凸包、单调栈等复杂的方向想，就被误导了。

在一开始，要注意分析题目本身的性质。比如我们抓住了关键的一条：**位置 $r$ 必被选出**。顺着这个思路，看哪些点是能被 $r$ 看见的。进一步发现大区间可以直接从小区间转移过来。于是自然而然就得到了上述的 DP 做法。

## 参考代码

```cpp
// problem: LOJ2545
#include <bits/stdc++.h>
using namespace std;

#define mk make_pair
#define fi first
#define se second
#define SZ(x) ((int)(x).size())

typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;

template<typename T> inline void ckmax(T& x, T y) { x = (y > x ? y : x); }
template<typename T> inline void ckmin(T& x, T y) { x = (y < x ? y : x); }

const int MAXN = 5000;
int n, h[MAXN + 5];
int dp[MAXN + 5][MAXN + 5];

int main() {
	cin >> n;
	for (int i = 1; i <= n; ++i)
		cin >> h[i];
	int ans = 0;
	for (int r = 1; r <= n; ++r) {
		ans ^= (dp[r][r] = 1);
		int p = 0;
		for (int l = r - 1; l >= 1; --l) {
			if (!p || (ll)(h[r] - h[l]) * (r - p) < (ll)(h[r] - h[p]) * (r - l)) {
				p = l;
			}
			dp[l][r] = min(dp[l][p], dp[l][p - 1]) + dp[p + 1][r];
			ans ^= dp[l][r];
		}
	}
	cout << ans << endl;
	return 0;
}
```







---

## 作者：chlchl (赞：5)

复出之后做的第一道区间 DP。

~~话说控制欲这么强的嘛。~~

## Solution
区间问题，考虑区间 DP。设 $f_{l,r}$ 表示区间 $[l,r]$ 至少放多少个守卫才能全部看守。

首先可以发现，对于一段区间 $[l,r]$，$r$ 是必须要放看守的，不然没有地方可以看到 $r$。

然后画个图，你可以发现，若亭子 $k$ 能被 $r$ 看到，则 $(k,h_k)$ 和 $(i,h_i)$ 的连线斜率，一定随着 $k$ 的增大单调递增。

![](https://cdn.luogu.com.cn/upload/image_hosting/ygtxxq0i.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

可以发现上图的红色实线的连到的亭子全都可以被看到，而虚线的亭子 $s$ 和能被看见的亭子 $t$ 会满足 $s<t,k_s\ge k_t$，这时是看不见的。

设 $p_i$ 为 $r$ 亭子能看到的从左到右第 $i$ 个亭子的编号，那么 $[p_i+1,p_{i+1}-1]$ 这个区间是没办法被 $r$ 观测到的。

那么必须放守卫来看守这一段了。假设我们在一个 $p_{i+1}$ 后面的位置 $x$ 放上守卫，可以使得他观测到这个区间至少一个亭子，那么我们必须要保证 $h_x>h_{p_{i+1}}$。

这时就出问题了，你会发现 $r$ 到 $x$ 的连线斜率 $k_x=\dfrac{h_r-h_x}{r-x}<k_{p_r}=\dfrac{h_r-h_{p_{i+1}}}{r-p_{i+1}}$，而 $p_{i+1}<x$，因此 $r$ 是看不到 $p_{i+1}$ 的，矛盾了。

所以我们得出一个结论：放置守卫的位置不能超过 $p_{i+1}$ 。所以 $p_{i+1}$ 和 $p_{i+1}-1$ 必须选其中一个，不然 $p_{i+1}-1$ 观测不到。

那么转移就很显然了，处理出所有 $p_i$（假设有 $t$ 个，且设 $p_0=l-1$），$f_{l,r}=\sum\limits_{i=0}^{t}\min\{f_{p_i,p_{i+1}},f_{p_{i},p_{i+1}-1}\}$。

于是 $O(n^3)$ DP 即可获得 70 分的好成绩。

考虑优化这个区间 DP。考虑固定右端点 $r$，倒序枚举左端点 $l$。因为 $r$ 是固定的，所以之前能够看见的亭子是完全一样的。

所以设 $p$ 为到目前为止 $[l,r]$ 内能被 $r$ 看到的最左的亭子，那么因为我们是倒着扫的，所以我们已经有了 $[p+1,r]$ 的答案，那么：

$$f_{l,r}\leftarrow\min\{f_{l,p-1},f_{l,p}\}+f_{p+1,r}$$

所以 DP 就被优化成了 $O(n^2)$ 的。扫的时候同步更新 $p$ 就行。

可以说这题让刚复出的我对最优子结构的理解大大提升，对最优子结构的利用可谓是淋漓尽致。


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 5000 + 10;
int n;
ll ans, h[N], f[N][N];

bool can_be_see(int x, int now, int r){//x的斜率比now的斜率小，就可以被看到 
	return (h[r] - h[x]) * 1ll * (r - now) < (h[r] - h[now]) * 1ll * (r - x);
}//斜率公式：(x1 - x2) / (y1 - y2)，不过除法改乘法了而已 

int main(){
	scanf("%d", &n);
	for(int i=1;i<=n;i++)
		scanf("%d", &h[i]);
	for(int r=1;r<=n;r++){
		int p = 0;
		ans ^= (f[r][r] = 1);//这个显然嘛 
		for(int l=r-1;l>=1;l--){
			if(!p || can_be_see(l, p, r))
				p = l;
			f[l][r] = min(f[l][p - 1], f[l][p]) + f[p + 1][r];
			ans ^= f[l][r];
		}
	}
	printf("%lld\n", ans);
	return 0; 
} 
```

---

## 作者：donghanwen1225 (赞：5)

这题实际上非常巧妙。

首先我们要注意到一个重要的性质：**一个保镖只能监视所有他能看得到的，横坐标不超过他所在位置的亭子。**

这说明，对任意一个区间 $[l,r]$，其最右端（也就是 $r$ 号亭子）必须要有保镖。

接下来，我们先固定右端点 $r$，并将 $l$ 从 $r-1$ 开始逐渐移动到 $1$；处理出对当前的 $l$，$r$ 向左能看到的最远的亭子，假设为 $p$。在扫的过程中，要存下来 $[p,r]$ 部分的答案 $\text{sum}$。

那么，我们必然要在 $p$ 或者 $p-1$ 两个位置中选一个添加一名保镖，也就是

$$f_{l,r}=\text{sum}+\min(f_{l,p-1},f_{l,p})$$

注意：在 $l$ 向左移动的时候，要对 $p$ 和 $\text{sum}$ 进行更新。具体的，如果当前的 $l$ 是 $r$ 点可见的，那么就要将 $\text{sum}$ 加上 $[l+1,p]$ 的贡献，即 $\min(f_{l+1,p-1},f_{l+1,p})$；并将 $p$ 修改为 $l$。

这样就基本已经解决了这道题，那么如何判断当前的 $l$ 是 $r$ 点可见的呢？

只需要比较当前的 $p,r$ 的连线的斜率与 $l,r$ 连线的斜率即可。显然，若 $\text{slope(p,r)>slope(l,r)}$，则需要更新 $p$ 的值。而斜率的计算方式也就是

$$\text{slope(l,r)}=\dfrac{h_r-h_l}{r-l}$$

代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,ans=0,h[5001],f[5001][5001];
double getk(int x,int y){return (h[y]-h[x])*1.0/(y-x);}
bool pd(int l,int x,int r){return getk(x,r)>getk(l,r);}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&h[i]);
	for(int i=1;i<=n;i++)
	{
		f[i][i]=1;ans^=1;
		int sum=1,p=0;
		for(int j=i-1;j>=1;j--)
		{
			if(!p||pd(j,p,i)) sum+=min(f[j+1][p-1],f[j+1][p]),p=j;
			f[j][i]=sum+min(f[j][p-1],f[j][p]);ans^=f[j][i];
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：CQWDX (赞：4)

[题目传送门 [JXOI2018] 守卫](https://www.luogu.com.cn/problem/P4563)

## 思路

区间dp。

设状态 $f_{l,r}$ 为在区间 $[l,r]$ 内要放的最少保镖数量。

看到题面第一眼的感觉是不会判两点能否连接。

第二眼发现可以用斜率判。

令 $k_{l,r}$ 为横坐标为 $l,r$ 的两点连线斜率。

有 $k_{l,r}=\frac{h_r-h_l}{r-l}$。

手搓几组样例，得 $\forall x\in[l,r)$，有 $k_{l,r}<k_{x,r}$ 。**即对于 $x\in[l,r)$，$(x,r)$ 的连线斜率最小。**

且若 $a$ 对于 $b$ 可见，并满足 $h_c>h_b$ 与 $c>a$，则 $a$ 对于 $c$ 可见。

令 $p=\{p_1,p_2\cdots p_m\}$ 为 $r$ 点当前能够覆盖的点集。**注：下文中 $p$ 按照从右至左斜率单调递减的顺序排序。**

> 注：能被覆盖的点可能**不连续**。但能被覆盖的点的斜率可以保证从**右至左单调递减。**
>
> 若想为点集连续，可能会导致 “$p$ 为 $r$ 点当前能够覆盖的最远点” 的错误贪心思路。~~喜提20pt。~~

如图，$r=G$ 时，$p=\{E,D,B\}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/8gel9ked.png)

接下来是这题个人认为比较难处理的地方。

> 由于 $p$ 不一定连续，故 $[p_{i+1}+1,p_i-1]$ 对于 $r$ 不可见。
>
> 由上述性质得，**对于 $j\in[p_i,r)$，$j=p_i$ 是唯一可以覆盖 $[p_{i+1}+1,p_i-1]$ 中至少一个点的点。** 即在区间 $(p_{i+1},p_i)$ 右侧唯一能够覆盖到此区间的点为 $p_i$。（有点绕，建议自己手玩一下。）
>
> ![](https://cdn.luogu.com.cn/upload/image_hosting/ddg41q3y.png)
>
> 如图，以 $A$ 为右端点，$[D,A]$ 中能覆盖 $[G,E]$ 的唯一点为 $D$。
>
>
> 当然，**也可以选择在 $p_i-1$ 处放置保镖，从内部将点覆盖。**
>
> 如在点 $E$ 放置保镖。
>
> 故 $p_i,p_i-1$ 至少有一处要放置保镖。
>
> 这样就成功的将区间 $[p_{i+1}+1,p_i]$ 或 $[p_{i+1}+1,p_i-1]$ 转换为了一个子问题。
>
> 区间 $[p_{k+1}+1,p_k-1]$ 的代价即为

$$f_{p_{i+1}+1,p_i-1}=\min\{f_{p_{i+1}+1,p_i-1},f_{p_{i+1}+1,p_i}\}$$

此时有转移方程：

$$f_{l,r}=\sum\limits_{i=1}^m\min\{f_{p_{i+1}+1,p_i-1},f_{p_{i+1}+1,p_i}\}$$

时间复杂度 $O(n^3)$，能拿 $70$ pts。

考虑优化。

- 因为 $p_i$ 是在 $[p_i,r)$ 中与 $r$ 点连线斜率最小的，所以**对于 $x\in[l,p_i)$，若存在 $f_{x,r}<f_{p_i,r}$，则 $p_{i+1}=x$。** 可以考虑将 $p_i$ 在循环里滚动处理。

- 可以注意到根据上述转移，当处理至 $p$ 点时，区间 $[p,r]$ 可以保证被完全覆盖。有转移方程 
$$f_{l,r}=\min\{f_{l,p-1,f_{l,p}}\}+f_{p+1,r}$$

干掉一个线性时间复杂度。时间复杂度 $O(n^2)$。

具体实现上有问题的话可以看代码。

```cpp
#pragma GCC optimize(2)
#include <bits/stdc++.h>
#define eps 1.0000
typedef long long ll;
const int maxn = 5020;
const ll inf = 1e18;
int n;
int h[maxn];
ll f[maxn][maxn], res;
bool check(int a, int b, int p){
	double ka = (h[p] - h[a]) * eps / (p - a);
	double kb = (h[p] - h[b]) * eps / (p - b);
	return ka < kb;
}
int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) scanf("%d", &h[i]), f[i][i] = 1;
	for(int r = 1; r <= n; r++){
		int pos = -1;
		for(int l = r - 1; l >= 1; l--){
			if(pos == -1 || check(l, pos, r)) pos = l;
			f[l][r] = std::min(f[l][pos - 1], f[l][pos]) + f[pos + 1][r];
		}
	}
	for(int i = 1; i <= n; i++)
		for(int j = i; j <= n; j++)
			res ^= f[i][j];
	printf("%lld", res);
	return 0;
}
```

初二婴儿，轻喷 qwq

~~我觉得这篇题解应该是题解区比较详细的？~~

---

## 作者：god8888 (赞：4)

本题简单来说从题目上分析，可画图如下：
![九条可怜的爬山路径](https://cdn.luogu.com.cn/upload/image_hosting/dr9uf5c3.png)
这个图给的就是九条可怜的爬山路径。我们可以看到，从一些坐标点　这幅图给的是九条爬山的路径，我们可以看到，从一些坐标可以看到，有的点可以看到他坐标以前以下的点，但有的点不能，这是本题的一个创新之处，但是大部分人可以想到做法，只是不敢相信这就是正解！没错，就是判斜率，用最简单的数学方法判断一个点能不能挡住另一个点的视线！

　　这样这道题其实就完成一半了，剩下的我们可以做一个区间dp，这个区间dp不像之前我们见过的，枚举区间长度一 一进行转移；而是采用线性dp的方法枚举左右端点即可，但是左端点要从右端点往前枚举；（其实枚举区间长度应该也没问题，各位大神可以试一下）；

　　所以我们定 f[l][r]代表l到r间的最优解，我们可以找到所有能被上面监视的点然后枚举是否安插一个保镖，以此进行转移！?
  
至于区间DP~~（觉得自己没有CSDN的大佬讲的好）~~，就发一个链接吧：[区间DP](https://blog.csdn.net/G20202502/article/details/82225732)。。
也好像解释完了，就上代码吧！！！！！！
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
#define mx 5005
int a[mx],dp[mx][mx];
int n,ans=0;
int check(int l,int mid,int r){//比较斜率 
	return (a[r]-a[mid])/(r-mid)>(a[r]-a[l])/(r-l);
} 
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++){
		dp[i][i]=1;//对于任何L-r的区间 r肯定要放一个 
		int sum=1;//表示当前 l-r 需要的保镖的最小数量 
		int l=i; //当前最远点 
		ans=ans^dp[i][i];//计算 
		for(int j=i-1;j>=1;j--){
			if(l==i||check(j,l,i)){//如果是第一个点 或者是 挡不住  
				sum=sum+min(dp[j+1][l-1],dp[j+1][l]);//考虑不放或者放 取一个最小值 
				l=j;//不断更新分割区间的那个点 
			}//对于j--i的区间得考虑j端点 
			dp[j][i]=sum + min(dp[j][l-1],dp[j][l]);//如果借助看不到当前点就考虑那个点到l之间的最优解 因为l之后已经是最优的解 
			ans=ans^dp[j][i];//对于每个区间都进行^运算 
		}
	}
	printf("%d\n",ans);
	return 0;
}
```
本蒟蒻的第三篇题解OK~\(≧▽≦)/~啦啦啦

---

## 作者：Memory_of_winter (赞：2)

[我的博客](https://www.cnblogs.com/Memory-of-winter/p/10349166.html)

**题目大意：**有一段$n(n\leqslant5\times10^3)$个点的折线，特殊点可以覆盖它以及它左边的它可以“看见”的点（“看见”指连线没有其他东西阻挡）。定义$f_{l,r}$为区间$[l,r]$最少需要的特殊点个数，求：$\sum\limits_{l=1}^n\sum\limits_{r=l}^nf_{l,r}$

**题解：**可以用斜率来判断是否可以看见。发现$r$一定要设一个关键点，而若一个极大区间$[l',r']$在$r$处看不见，那么一定要在$r'$或$r'+1$处设一个关键点，所以$f_{l,r}=1+\sum\limits_{l',r'}\min\{f_{l',r'},f_{l',r'+1}\}$（$l',r'$即为上文说的极大看不见的区间）

但这样复杂度是$O(n^3)$，不能承受，发现固定了$r$后（固定$l$也行），那些看不见的区间是重复的，可以后缀处理（固定$l$就是前缀）。

**卡点：**开始$naive$的以为贪心就行了（原以为直接贪心选择$r'+1$即可，然后发现一个斜率降低的折线就挂了）



**C++ Code：**

```cpp
#include <algorithm>
#include <cstdio>
#define maxn 5010
const double inf = 1e9;

int n, ans;
int h[maxn], f[maxn][maxn];
inline double slope(int l, int r) {
	if (l == r) return inf;
	return (h[r] - h[l]) / static_cast<double> (r - l);
}
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) scanf("%d", h + i);
	for (int r = 1, sum, now; r <= n; ++r) {
		ans ^= (sum = f[r][r] = 1);
		now = r;
		for (int l = r - 1; l; --l) {
			if (slope(l, r) < slope(now, r)) {
				sum += std::min(f[l + 1][now - 1], f[l + 1][now]);
				now = l;
			}
			ans ^= (f[l][r] = sum + std::min(f[l][now - 1], f[l][now]));
		}
	}
	printf("%d\n", ans);
	return 0;
}

```



---

## 作者：封禁用户 (赞：1)

## 思路

解法：区间 DP。

本题虽标上紫题，但黄队说了：“不要被颜色所吓倒。”

![](https://cdn.luogu.com.cn/upload/image_hosting/xdvdeul1.png)

易得，区间 $[l,r]$ 中最右端的亭子 $r$ 一定会有保镖。

先说一下可见性判断吧，只要 $l,r$ 的连线的斜率大于 $p,r$ 连成的线的斜率大，$l$ 即是可见的。

如图，红线是 $r$ 无法看到的，而蓝线是 $r$ 可以看到的，我们可以从 $r$ 向 $l$ 扫描，设 $p$ 是 $r$ 可以看到的最左端点，因次 $p-1$ 必然低于 $p$。

则对于 $l$ 到 $p-1$ 一段，在 $p$ 或 $p-1$ 必有一个保镖。

易得 $f_{l,r}=sum+\min(f_{l,p-1},f{l,p})$。

若当前点 $r$ 可见，则 $p$ 和 $p-1$ 中有一个保镖，则 $sum$ 要加 $\min(f_{l+1,p-1},f_{l+1,p}$，将 $p$ 更新成 $l$。

## AC code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 5010;
int f[N][N], h[N], n, ans = 0;
bool abledlook(int l, int x, int r) {
	return 1.0 * (h[x] - h[r]) / (x - r) > 1.0 * (h[r] - h[l]) / (r - l);//计算斜率
}
//判断是否可见

signed main() {
	cin >> n;

	for (int i = 1; i <= n; i++)cin >> h[i];
	for (int r = 1; r <= n; r++) {
		ans ^= (f[r][r] = 1);
		int sum = 1, p = 0;
		for (int l = r - 1; l >= 1; l--) {
			if (!p || abledlook(l, p, r))sum += min(f[l + 1][p - 1], f[l + 1][p]), p = l;//更新 p,sum

			ans ^= (f[l][r] = sum + min(f[l][p - 1], f[l][p]));
		}
	}

	cout << ans << "\n";
	return 0;
}
```

---

## 作者：LG_ljc2022 (赞：1)

## 题目大意

有一条 $\tt{n}$ 个点的折线段，每在一个右边的点上设置守卫可以向左边比它低的点进行监视，求监视所有区间 $[l, r]$ 所需的最小守卫数量的异或和。

关键点：**只能监视所有他能看得到的横坐标不超过他所在位置的亭子。** 

## 解题思路

~~题目废话真多~~

首先第一步读懂题目，本人理解能力很菜，直到 MikeZ 把图画出来才搞懂

画出九条可怜的登山图，很容易发现从右向左枚举更容易计算，因为所有的保镖都只能往左边看。很显然最右边的 $\tt{r}$ 号点必须放置一个，因为最右边的点没有更右边的进行监视。

这样一来，思路就打开了。把这个监视站能监视的所有点在手画的图上标记出来，很容易发现原本未监视的点被分成了几段区间。并且**区间之间互不干扰**

$\tt{Q}$：为什么分出来的区间一定互不干扰，即右边的区间不可能监视左边的区间？

$\tt{A}$：不难发现分隔两段区间的都是比两段区间内所有的点更高的点，即两段区间位于“山谷”当中。设分隔区间中最高的山峰为 $mount1$，左边区间最高峰为 $mount2$，若可以监视，则 $h[mount1] < h[mount2]$，那么监视到 $mount1$ 的监视站必然会监视到 $mount2$，此亭必定会被标记不位于剩下的区间中，因此矛盾，区间之间不会干扰。

一眼区间 $\tt{DP}$。设 $dp[l, r]$ 表示区间 $l, r$ 雇佣人数的最小值。初始化 $dp[i][i] = 1$，从右向左枚举节点，每一次判断最远能监视到的亭子。判断时比较斜率即可。斜率公式：

$$k = \frac{h[a] - h[c]}{a - c}$$

设最远为 $\tt{point}$，那么该点右边可能位于“山谷”中，所以转移时加上 $dp[point + 1][j]$，左侧必定位于“山谷”中，则应决策在该山上设置监视站或是在左边设置监视站，取其中代价小的即可。

转移方程：$dp[i][j] = dp[point + 1][j] + min(dp[i][point - 1], dp[i][point])$

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, mount[50005], dp[5005][5005], ans, point;
bool check_func_k(int a, int b, int c)
{
	double tx = (mount[a] - mount[c]) * 1.0 / (a - c), ty = (mount[b] - mount[c]) * 1.0 / (b - c);
	return tx < ty ? true : false;
}
int main()
{
	
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &mount[i]);
	for (int j = 1; j <= n; j++)
	{
		dp[j][j] = 1;
		ans ^= dp[j][j];
		point = -1e8;
		for (int i = j - 1; i >= 1; i--) //从右向左枚举	
		{
			if (point == -1e8) point = i;
			if (check_func_k(i, point, j) == true) point = i; //更新更远的点
			dp[i][j] = dp[point + 1][j] + min(dp[i][point - 1], dp[i][point]);
			ans ^= dp[i][j];
		}
	}
	printf("%d", ans);
	
	return 0;
}
``````

---

## 作者：FreeTimeLove (赞：1)

好的区间 DP 练习题。

考虑对于区间 $[l,r]$，$r$ 一定要选，因为每个点只能向左覆盖。设在 $(l,r]$ 中 $r$ 能向左看到的**下标最小**的点为 $p$，$f(l,r)$ 为 $[l,r]$ 中的点覆盖 $[l,r]$ 所需最小花费。

若 $r$ 看不到 $l$，则 $f(l,r)=\min(f(l,p),f(l,p-1))+f(p,r)$，因为此时只有 $[l,p]$ 中的点才能覆盖 $[l,p)$ 中的点；

否则 $f(l,r)=\min(f(l+1,p),f(l+1,p-1))+f(p,r)$，因为此时 $l$ 已经被覆盖，只需再覆盖 $[l+1,p)$ 即可。

$r$ 能看到 $l$ 的充要条件为 $\dfrac{h_r-h_l}{r-l}>\dfrac{h_r-h_p}{r-p}$。

时间复杂度 $O(n^2)$。

### code

```cpp
//written_by_FTL
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<bitset>
#include<vector>
#include<queue>
#include<unordered_map>
#define ll long long
#define LD long double
#define i7 __int128
#define re return
#define con continue
using namespace std;
inline void ckmin(auto &a,auto b){if(b<a)a=b;}
inline void ckmax(auto &a,auto b){if(a<b)a=b;}
const int N=5e3+5;
inline int rd(){
	int ans=0,f=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')f^=(ch=='-'),ch=getchar();
	while(ch>='0'&&ch<='9')ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();
	re f?-ans:ans;
}
int n,f[N][N],a[N],ans;
int main(){
	n=rd();
	for(int i=1;i<=n;i++)a[i]=rd();
	for(int r=1;r<=n;r++){
		f[r][r]=f[r-1][r]=1;
		int p=r-1;
		for(int l=r-2;l>0;l--){
			if((ll)(r-l)*(a[r]-a[p])>(ll)(r-p)*(a[r]-a[l]))
				f[l][r]=min(f[l+1][p],f[l+1][p-1])+f[p][r],p=l;
			else f[l][r]=min(f[l][p],f[l][p-1])+f[p][r];
			ans^=f[l][r];
		}
	}
	printf("%d\n",ans^1);
	re 0;
}
/*
5
7 6 1 1 4

*/
```

---

## 作者：GY程袁浩 (赞：0)

# 思路

首先观察到一个很重要的性质。

在题目中由于每个保镖只能看到自己的左边，所以对于区间 $[l,r]$，在 $r$ 号亭子必然有一个保镖（不然最右边的保镖右边的亭子谁来看着）。

我们画出图分析，发现在 $r$ 左边最后一个能被看到的亭子（以下记 $p$ 为这个亭子的位置）的左边就已经成为了一个与其他子区间完全独立的区间，所以考虑动态规划。

状态表示：$f_{l,r}$ 表示在区间 $[l,r]$ 之间，最少需要放多少个保镖。

首先我们知道，当 $l=r$ 的时候，$f_{l,r}=1$。然后我们发现，在得到状态 $f_{l,r}$ 时，我们不仅需要考虑 $[l,p-1]$ 这个区间，还需要考虑 $[p+1,r]$ 这个区间，于是我们考虑维护 $sum$ 来求出当前 $[p+1,r]$ 这个区间的保镖数，我们的 $l$ 需要从大往小枚举。

枚举 $l$ 的顺序是从大到小的，也就是从右到左，那么 $p$ 就会被更新。$p$ 会被更新当且仅当连 $l$ 与 $r$ 点的斜率小于连 $p$ 到 $r$ 的斜率（这里读者可以画图来理解）。

首先考虑 $sum$ 的计算，当 $p$ 被更改时，$sum \gets sum+\min(f_{l+1,p-1},f_{l+1,p})$，其他情况不变。特别的，当区间大小为一时，$sum$ 为 $1$。

接下来，因为我们需要知道 $f_{l,r}$ 的子区间 $f_{l,p}$ 与 $f_{l,p-1}$ 的值，而 $p$ 与 $p-1$ 是小于 $r$ 的，所以我们要把 $r$ 从小到大枚举，这样我们就可以愉快地转移状态了。

状态计算/转移：$f_{l,r}=\min(f_{l,p-1},f_{l,p})+sum$。

# Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 5e3 + 10;
int f[N][N], h[N], n, ans;
inline double line(int x, int y) { return (double)(h[x] - h[y]) / (x - y); }
inline bool stop(int x, int y, int z) { return line(z, x) > line(z, y); }
signed main() {
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> h[i];
	for (int r = 1; r <= n; r++) {
		ans ^= (f[r][r] = 1);
		int sum = f[r][r], p = 0;
		for (int l = r - 1; l >= 1; l--) {
			if (!p || !stop(l, p, r)) {//sum只维护了之前的[p+1,r]，此时p的位置改变，于是需要更新 sum，即加上 [l+1,p] 或 [l+1,p-1]。
				if(p) sum += min(f[l + 1][p], f[l + 1][p - 1]);// ！ 注意当 p 为 0 时，也会进入上个分支，此时 f[l+1][p-1] 会出现访问 f[l+1][-1] 的情况，需要特判掉。
				p = l;
			}
			ans ^= (f[l][r] = min(f[l][p - 1], f[l][p]) + sum);
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：__ycx2010__ (赞：0)

### 思路

设 $f_{l,r}$ 表示区间 $[l,r]$ 的答案。

首先有结论 $r$ 必须有保镖。

若 $l$ 可以被 $r$ 看见，则 $f_{l,r} = f_{l+1,r}$。

否则设 $p$ 为 $r$ 可以看见的最左端的点。

可以发现 $p$ 右边对 $p$ 左边一定没有贡献。

若在 $p$ 上设置保镖，则 $f_{l,r} = f_{l,p}+f_{p,r}$，否则，$f_{l,r}=f_{l,p - 1} + f_{p,r}$。

$f_{l,r}\left\{\begin{matrix}
  & f_{l+1,r} & r 可以看见 l\\
  & \min\{f_{l,p-1},f_{l,p}\} + f_{p,r} & Other.
\end{matrix}\right.$

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 5010;
int h[N], f[N][N];

bool chk(int x, int y, int z) {
	if (y == z) return true;
	if (1ll * (h[y] - h[x]) * (y - z) < 1ll * (h[y] - h[z]) * (y - x)) return true;
	return false;
}

int main() {
	int n, ans = 0;
	scanf("%d", &n);
	for (int i = 1; i <= n; i ++ ) scanf("%d", &h[i]);
	for (int i = 1; i <= n; i ++ ) {
		f[i][i] = 1;
		ans ^= 1;
		int p = i;
		for (int j = i - 1; j >= 1; j -- ) {
			if (chk(j, i, p)) p = j, f[j][i] = f[j + 1][i];
			else f[j][i] = min(f[j][p - 1], f[j][p]) + f[p][i];
			ans ^= f[j][i];
		}
	}
	printf("%d\n", ans);
    return 0;
}
```

---

## 作者：WrongAnswer_90 (赞：0)

[P4563 [JXOI2018] 守卫](https://www.luogu.com.cn/problem/P4563)

[更好的阅读体验](https://www.cnblogs.com/WrongAnswer90-home/p/18036917)

这道题让我充分认识了我一点不会 dp。

首先可以预处理一个点能看到的左边的所有点。注意到一个区间一定会选择右端点，设右端点不能看到的所有极长区间为 $[l_1,r_1],[l_2,r_2]\dots[l_k,r_k]$，区间 $[L,R]$ 的答案即为 $1+\sum f_{l_i,r_i}\dots$吗。

上述思路是错的，因为看不到的所有小区间不一定要强制选择右端点，还可能会选择右端点右侧的点，并且一定会选择右端点右侧的第一个点。

因为一定是右侧的第一个点遮盖住了该区间所有的点，否则假设 $k$ 遮盖住了区间 $[l_i,r_i]$ 且 $r_i+1$ 不能遮盖该区间。右端点也一定会被 $k$ 遮盖。

这样就得到了 $\mathcal O(n^3)$ 的 dp，固定右端点，左端点从右向左扫，随便优化成 $\mathcal O(n^2)$。

第一眼很容易想麻烦，想到凸包，单调栈之类的玩意，但是还是要先观察特殊性质啊。

```cpp
	int n,ans,f[5010][5010],a[5010];
	bool v[5010][5010];
	inline void mian()
	{
		read(n),ans=n&1;
		for(int i=1;i<=n+5;++i)for(int j=i+1;j<=n+5;++j)f[i][j]=INF;
		for(int i=1;i<=n;++i)
		{
			read(a[i]),f[i][i]=1;
			db minn=INF;int last=i,val=0;
			for(int j=i-1;j>=1;--j)
			{
				if(1.0*(a[i]-a[j])/(i-j)<minn)
				{
					minn=1.0*(a[i]-a[j])/(i-j);
					val+=min(f[j+1][last],f[j+1][last+1]);
					last=j-1;
				}
				ans^=(f[j][i]=val+min(f[j][last],f[j][last+1]));
			}
		}
		write(ans);
	}
```

---

## 作者：WOL_GO (赞：0)

这题题面很抽象，$l,r(l<r)$ 之间能看到的定义是：中间没有一个点 $p$，满足 $slope(l,r)<slope(p,r)$ 其中，$slope$ 求的是两点的斜率。因为题目要求任意区间的答案，然后异或起来。我们可以枚举当前区间 $[l,r]$ 考虑如何求答案。
对于当前区间 $[l,r]$，右端点 $r$ 肯定是要放将军的，不然没人能看到第 $r$ 个点。

我们可以从右往左枚举区间右端点, 再枚举左端点。我们维护当前右端点 $r$ 最远能看到的左端点的编号 $p$。定义 $dp[l,r]$ 表示区间 $[l,r]$ 的答案。

那么就有：$dp[l][r]=\min{(dp[l][p],dp[l][p-1])+dp[p+1][r]}$；也就是一定要在 $p$ 点和 $p-1$ 点再放一个将军因为 $p$ 号点看不到的话，肯定是被 $p+1$ 号点挡住了，那么可以考虑在这两个点放一个，看哪个更优因为不一定放在 $p$ 号点能看到更多，可以自己画图感受一下。

## CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
void read(int &xx){
    register char ch=getchar();
    register int ans=0;
    char t=0;
    while(!isdigit(ch))t|=ch=='-',ch=getchar/*_unlocked*/();
    while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar/*_unlocked*/();
    xx=t?-ans:ans;
    return ;
}
void write(int x){
    if(x<0){
        putchar('-');
        x*=-1;
    }
    char wr[18];
    register int cnt=1;
    if(x==0){
        putchar('0');
        putchar('\n');
        return ;
    }
    while(x){
        wr[cnt++]=x%10+'0';
        x/=10;
    }
    for(cnt--;cnt;cnt--){
        putchar(wr[cnt]);
    }
    putchar('\n');
    return;
}
const int maxn=5005;
int dp[maxn][maxn],a[maxn],n;
long double slope(int l,int r){return (long double)(a[r]-a[l])/(r-l);}
int main(){
    int ans=0;
    read(n);
    for(int i=1;i<=n;i++)read(a[i]);
    for(int i=1;i<=n;i++){
        dp[i][i]=1;
        ans^=1;
        int sum=1,p=0;
        for(int j=i-1;j>=1;j--){
            if(!p||slope(p,i)>slope(j,i))sum+=min(dp[j+1][p-1],dp[j+1][p]),p=j;
            ans^=(dp[j][i]=sum+min(dp[j][p-1],dp[j][p]));
        }
    }
    write(ans);
    return 0;
}
```



---

## 作者：rq_kyz (赞：0)

# 【题解】P4563 [JXOI2018] 守卫

### 传送门

[P4563 [JXOI2018] 守卫](https://www.luogu.com.cn/problem/P4563)

---

### 题意

现有一座山，可以被描述为一条折线。$h_i$ 表示横坐标为 $i$ 的地方的纵坐标。现在我们需要在上边放一些保镖，使得保镖可以看到任意一个地方。保镖只能看到横坐标不比他大且连线不被挡住（正好经过也算挡）的地方。对于任意一段区间，请问安排的最小人数为多少，输出所有结果异或起来的值。

---

### 分析

本题很容易想到凸包上去，其实只需要使用区间 DP。对于一段区间 $l$ 到 $r$，因为每个保镖只能看到他左边的位置，所以 $r$ 这个地方肯定是要放一个保镖的。既然 $r$ 都放了，那么我们需要找到 $r$ 这个位置可以看到的最靠左的位置。假设这个位置为 $i$，那么状态转移方程为：$dp_{l,r}=\min(dp_{l,i-1},dp_{l,i})+dp_{i+1,r}$。

所以我们现在的问题只是找出 $i$。我们可以记录一下已经求出的其它区间对应的 $i$。设 $f_{l,r}$ 表示 $l$ 到 $r$ 这段区间以内 $r$ 可以看到的最靠前的位置，那么 $f_{l,r}$ 应该怎么转移呢（怎么感觉有点像个 DP）？很容易想到，我们可以分为两种情况：第一种，$f_{l,r}=l$；第二种，$f_{l,r}=f_{l+1,r}$。所以我们只需要判断 $r$ 可不可以看到 $l$，便完成转移。

---

### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll a[5001];
ll dp[5001][5001];
ll f[5001][5001];//用于记录每一段区间的右端点可以看到的最靠前的位置（不小于左端点）
int main(){
	ll n;
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	ll ans=0;//记录答案
	for(ll l=1;l<=n;l++){//初始化
		dp[l][l]=1;
		ans^=1;
		f[l][l]=l;
	}
	for(ll l=1;l<n;l++){
		dp[l][l+1]=1;
		ans^=1;
		f[l][l+1]=l;
	}
	for(ll len=3;len<=n;len++)
		for(ll l=1,r=len;r<=n;l++,r++){
			//判断r可不可以看到l时，不需要循环中间节点，只需要判断f[l+1][r]有没有挡住l和r之间的连线
			if((a[r]-a[l])/(r-l)>(a[f[l+1][r]]-a[l])/(f[l+1][r]-l))
				f[l][r]=l;
			else
				f[l][r]=f[l+1][r];
			dp[l][r]=min(dp[l][f[l][r]-1],dp[l][f[l][r]])+dp[f[l][r]+1][r];
			ans^=dp[l][r];//别忘了更新
		}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：jr_zch (赞：0)

# [P4563 [JXOI2018] 守卫](https://www.luogu.com.cn/problem/P4563)
## by jr_zch

## 思路 & 解法

当你看见数据范围中有 $1$ 档比较重要的分数：

$$n \leq 500$$

这不就是为区间 dp 量身定制的吗？所以可以先从区间 dp 的方面入手，然后从某个角度去优化成 $O(n^2)$。

设状态 $f_{i,j}$ 表示区间 $i \sim j$ 所有点都被覆盖的最小价值，其实并不是很好转移，所以说可以自己造组数据手玩一下。比如下面这个：

![](https://cdn.luogu.com.cn/upload/image_hosting/gdecyp0x.png)

* 定理 $1$：在一个区间内，**最右边的点一定会被选中**。
> 因为所有点都是往左边延伸的，所以最右边的点一定会被选中。

那么可以思考最右边的点可以覆盖到哪些点：

![](https://cdn.luogu.com.cn/upload/image_hosting/l0u8lr7y.png)

那么除开这些已经被覆盖掉的点，剩下的点似乎可以分段处理，毕竟我们现在是在考虑 $O(n^3)$ 的算法。考虑每一段的未盖点由哪些点去覆盖。设区间 $l \sim r$ 这段区间未被覆盖，那么显然可以选择其区间内的点，或者是 $r$ 右边的点，但经过模拟，对于区间右边，似乎只有 $r + 1$ 可以产生贡献（是产生贡献，并不一定可以完全覆盖）。即要么从 $f_{l,r}$ 转移过来，要么从 $f_{l,r+1}$ 转移过来。

![](https://cdn.luogu.com.cn/upload/image_hosting/1tz96exe.png)

绿色边是 $j$ 能看见的，红色边是 $j$ 看不见的，即 $l$，$r$，浅蓝边是 $r+1$ 能看见的。

* 定理 $2$：每段 $j$ 看不见的区间 $l \sim r$，要么选择 $r+1$，要么选择其区间内的点。
> 需要证明 $r+2 \sim j$ 这段区间中所有 $j$ 可见的点都看不见 $l \sim r$ 中的任何一个点。
> 
> 考虑反证法，假设有这样的一个点能看见 $r$，设它是 $k$，那么因为 $j$ 能看见 $r+1$，所以 $slope(j,r+1)>slope(k,r+1)$。又因为 $k$ 能够看见 $r$，那么 $slope(k,r+1)>slope(r,r+1)$，所以 $slope(j,r+1)>slope(r+1,r)$，即 $j$ 可以看见 $r$，与定义相矛盾，得证。
>
> ![](https://cdn.luogu.com.cn/upload/image_hosting/wj2wozxc.png)
>
> 可能会有人疑惑，$j$ 和 $r$ 只是不经过 $r+1$ 这个点，如果经过了其他点呢？后文会提到关于该问题的细节以及证明。

如果有 $m$ 段 $j$ 看不见的点，那么现在的方程就是 $f_{i,j}=\sum_{k=1}^{m} \min(f_{l_k,r_k},f_{l_k,r_k+1})+1$。即每段代价和加上选择了右端点。

### 优化

前面已经说过了，每个区间的右端点是一个很重要的点，稍加分析后可知，在右端点固定的情况下，看不见的区间也是固定的，但是却进行了重复计算。从这方面入手，可以固定右端点往左边扫描，来去除重复计算。

```cpp
if(now==-1||k(j,now)>k(now,i)) f[i][j]=f[i+1][j],now=i;
else f[i][j]=min(f[i][now],f[i][now-1])+f[now+1][j];
```

如果 $i$ 可见，那么 $f_{i,j}=f_{i+1,j}$，如果 $i$ 不可见，将最左边一段不可见的算作一个整体进行更新：$f_{i,j}=f_{now,j}+\min(f_{i,now},f_{i,now-1})$。其中 $now$ 是当前 $j$ 能看见得最远左端点的位置。

注意到判断是否可见时，我使用的是和上文证明过程中类似的方法，都是只看两点连线会不会被最左边的点挡住。要解释这个问题，首先得弄清楚：从一个点出发，与左边点的连线的斜率是递减的。

结合判断两点是否可见的方法，我们要判断 $p_1$，$p_3$ 是否可见，需要满足对于中间的任意一点 $p_2$，满足 $slope(p_1,p_2) > slope(p_1,p_3) > slope(p_2,p_3)$ 三条不等关系中的任意一条即可，在这道题的代码实现过程中，$slope(p_1,p_3)$ 相当于是定值，那它只需要小于最小的 $slope(p_1,p_2)$，这个 $p_2$ 就是最左边的那一个 $p_1$ 可见的点。所以在判断右端点是否可见一个点时，只需经过当前可见的最远点即可。

那么这道题就做完了。

## Code：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn=5e3+7,inf=0x3f3f3f3f;
int n,now,ans=0;
int h[maxn],f[maxn][maxn];
vector<int> e[maxn];

double k(int x,int y){
	return double(h[x]-h[y])/double(x-y);	
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&h[i]);
	for(int j=1;j<=n;j++){
		f[j][j]=1,now=-1;
		for(int i=j-1;i;i--){
			if(now==-1||k(j,now)>k(now,i)) f[i][j]=f[i+1][j],now=i;
			else f[i][j]=min(f[i][now],f[i][now-1])+f[now+1][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++) ans^=f[i][j];
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：OIer_ACMer (赞：0)

~~这保镖干脆不雇得了。~~

------------
注：本题思路较为简单（真的！！！），所以笔者不会过多赘述证明以及原理，望周知！

------------
## 大致思路：
看到题目，首先想到可以用贪心做，将每个保镖对应一个亭子，但很显然，贪心只能过样例，因此，我们得想一想这道题 DP 怎么做。

我们首先先设计状态，我们设 $dp_{l,r}$ 表示区间 $l$ 到 $r$ 的答案，接着，我们定义一个数组 $ggg$，表示在每个位置安排保镖，那个保镖能看到的亭子有哪些。

数组安排好了，我们就来想一想 DP 策略是什么。根据我们不断枚举的结果，**显然 $r$ 位置一定有一个保镖**。同时不难观察到一个性质：拿区间 $[1,n]$ 来说，设其观察不到的某个区间为 $[ll,rr]$，那么 $rr$ 与 $rr$ 加 $1$ 一定有一个保镖，而且每段区间的贡献都是独立的。这一段的数据就可以先预处理出来，同时将结果储存到 $ggg$ 数组里面，还要设置一个中转量 $poss$，表示目前遍历到了那个亭子。然后直接枚举 $r$，不断把 $l$ 往左移动更新答案，这样可以保证更新的时候中间的区间都计算过，可以直接前缀和优化。

之后，就是用 DP 的转移方程将每个亭子安排保镖或者不安排保镖的情况计算代价，这段笔者就不细讲，具体看代码。

不要忘记个事：数组能开多大开多大！！！不要吝惜！！！

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
const int N = 5001;
int n, dp[N][N];
double a[N];
bool ggg[N][N];
signed main()
{
    // Fin(a);
    n = read();
    for (int i = 1; i <= n; i++)
    {
        a[i] = read();
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = i - 1, poss = -1; j; j--)
        {
            if ((poss == -1) || (1ll * (a[i] - a[poss]) * (i - j) > 1ll * (a[i] - a[j]) * (i - poss)))
            {
                ggg[i][j] = ggg[j][i] = 1, poss = j;
            }
        }
    }
    int ans = 0;
    for (int i = 1; i <= n; i++)
    {
        int s = 1, pos = 0;
        for (int j = i; j; j--)
        {
            if (ggg[j][i])
            {
                if (!ggg[j + 1][i])
                {
                    s += min(dp[j + 1][pos], dp[j + 1][pos + 1]);
                }
                dp[j][i] = s;
            }
            else
            {
                if (ggg[j + 1][i])
                {
                    pos = j;
                }
                dp[j][i] = s + min(dp[j][pos], dp[j][pos + 1]);
            }
            ans ^= dp[j][i];
        }
    }
    cout << ans;
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/122971860)

---

## 作者：Lyccrius (赞：0)

要求所有 $[l, r]$ 的答案异或和，考虑区间 DP。

由于 $n \le 5000$，时间复杂度应为 $\mathcal O(n^2)$。

一个保镖只能监视横坐标不超过他的亭子，也就是只能向左看，那么对于一个区间 $[l, r]$，$r$ 是必须放置保镖的。

考虑固定右端点，左端点不断左移，同时维护 $[l, r]$ 内 $r$ 能看到的最远（左）点 $p$。

由于山峰是参差不齐的，以至于 $r$ 能看到的点不一定连续。

$p$ 是 $r$ 能看到的最远点，但是 $p + 1$ 不一定能被 $r$ 看到，因此我们将 $f_{p + 1, r}$ 贡献到 $f_{l, r}$ 中。

对于 $p$ 左侧的部分 $[l, p)$ 是 $r$ 看不到的，于是 $p - 1, p$ 必然有一个位置要放置保镖，将 $\min (f_{l, p - 1}, f_{l, p})$ 贡献倒 $f_{l, r}$ 中。

综上，

$$f_{l, r} = \min (f_{l, p - 1}, f_{l, p}) + f_{p + 1, r}$$

---

## 作者：Unnamed114514 (赞：0)

考虑到要求出所有区间，容易想到区间 dp。状态很好定义：令 $dp_{l,r}$ 表示区间 $[l,r]$ 的答案，那么我们就需要 $O(1)$ 求出 $dp_{l,r}$。我们可以先确定一个变量，假设我们确定 $r$。

容易想到一个事情：因为保镖只能看他右侧的点，那么 $r$ 这个点是一定有保镖的。

首先来想一个事情：按照区间 dp 的思路，我们应该如何分割区间？显然，对于 $k\in[l,r]$，必须保证 $r$ 能看见 $k$ 的时候才能转移。我们来考虑一下这些区间：

![](https://cdn.luogu.com.cn/upload/image_hosting/sypggbo9.png)

如图，在 $r$ 确定的情况下，对于所有 $k_1,k_2,\cdots$，容易发现它们分割的长度是定值，所以我们可以用后缀和维护这些分割区间的和。

现在，假设我们枚举到 $[l,r]$，$r$ 在 $[l+1,r]$ 中可以看见的最左边的点为 $p$，如何确定 $l$ 是否可行呢？观察上面的图，我们可以得到：$k_{k_1r}>k_{k_2,r}$，那么应该可以推出：$k_{k_1,r}>k_{k_2,r}>\cdots$。由于 $p$ 在 $[l+1,r]$ 中是最左边的，所以此时 $k_{pr}$ 应该是最小的，那么，如果 $l$ 可以被看见，那么就必须要保证 $k_{lr}<k_{pr}$。

现在，我们已经完整地剖析了 $[p,r]$，现在轮到了剖析 $[l,p-1]$ 了。如果 $l$ 和 $p$ 重合，显然为 $0$，所以我们假设 $l\ne p$。当然，此时 $[l,p-1]$ 的内部情况已经剖析清楚了，我们来考虑外部的点的贡献。首先，因为 $p$ 是可以看见的最左边的点，那么有 $h_p-h_{p-1}>k_{rp}>0$，也就是说我们可以得到 $h_p>h_{p-1}$。所以说 $p$ 是可以看见 $p-1$ 的，并且由下图可知，在 $[p+1,r]$ 中，是没有点能看见 $p$ 的：

![](https://cdn.luogu.com.cn/upload/image_hosting/vleaqzvy.png)

那么此时就说明在 $[l,p-1]$ 之外的只有 $p$ 能作出贡献，那么 $[l,p-1]$ 的贡献就是 $\min\{dp_{l,p-1},dp_{l,p}\}$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,ans,h[5005],dp[5005][5005];
inline double clac(int i,int j){
	return (h[j]-h[i])*1.0/(j-i);
}
inline bool check(int l,int p,int r){
	return clac(l,r)<=clac(r,p);
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;++i)
		scanf("%lld",&h[i]);
	for(int r=1;r<=n;++r){
		ans^=(dp[r][r]=1);
		int s=1,p=0;
		for(int l=r-1;l;--l){
			if(!p||check(l,p,r))
				s+=min(dp[l+1][p],dp[l+1][p-1]),p=l;
			ans^=(dp[l][r]=s+min(dp[l][p-1],dp[l][p]));
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---


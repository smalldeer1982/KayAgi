# [JSOI2013] 哈利波特与死亡圣器

## 题目描述

伏地魔的黑暗势力控制了魔法部与霍格沃茨魔法学校之后，哈利与罗恩、赫敏不得不逃亡在外，隐形遁迹。为了完成校长邓布利多的遗命，一直在暗中寻机销毁伏地魔魂器的哈利，意外地获悉如果他们能够拥有传说中的三件死亡圣器，伏地魔将必死无疑。

在凤凰社成员的帮助下，哈利一行人重新掌控了霍格沃茨。然而此举激怒了伏地魔，他很快率领大批食死徒和黑暗生物向霍格沃茨进军。麦格教授紧急疏散了霍格沃茨的学生，并开始了守卫霍格沃茨的战斗。

霍格沃茨魔法学校的主要建筑共有 $n$ 处，我们编号为 $1$ 到 $n$，这些建筑间由魔法道路连接，整体呈树状分布，即任意两个建筑间有且仅有一条路径相连（路径可以是一条或多条道路组成）。霍格沃茨历经多年风雨，每个建筑自身有许多保护魔法，比如“石墩触动咒”、“降敌陷阱咒”、“统统加护咒”等，只需有人前往施用咒语即能保卫建筑。

现在，伏地魔大军已经到达 $1$ 号建筑——学校大门，凤凰社成员也已经在大门迎战，并且已经启用了大门的保护魔法。然而伏地魔大军势力壮大，保护魔法只能延缓大军的进攻锋芒，他们仍能用一个小时攻克一个建筑，随后整个大军便随机前往与之相邻的另一个建筑（兵贵神速，大军移动过程不需要时间；兵法无常，他们有可能前往已经攻克的建筑）。

目前除了 $1$ 号建筑，其他建筑的保护魔法都尚未被启用，凤凰社决定派出一些成员去其他建筑施用咒语来启动保护魔法。每个凤凰社成员可以瞬间达到任意一个建筑，并用一个小时完成对该建筑保护魔法的启用，之后可以再前往其他的建筑。他们的任务是，保证不论伏地魔大军如何行动，大军所到建筑的保护魔法都已经启用。为了集中更多力量直接打击伏地魔大军，凤凰社希望派出施用咒语的成员数尽可能少。

请你计算，至少需要派出多少位成员。

注：

- 伏地魔大军到达 $1$ 号建筑开始攻击的同时，凤凰社派出成员去其他建筑施咒。

- 当大军攻克某个建筑后，凤凰社成员可以在知道大军下一个小时去哪个建筑的情况下，再决定他们去哪些建筑施咒。这个过程也不需要时间。

- 已经启用过保护魔法的建筑无需再施咒，即便大军攻克该建筑以后某个时候又回到这个建筑，大军也会在这个建筑持续攻击一个小时后再离开。

## 说明/提示

### 数据范围

对于 $100\%$ 的数据，$1\leq n\leq 3\times 10^5$。

## 样例 #1

### 输入

```
7
1 2
1 3
2 5
2 6
7 2
4 1```

### 输出

```
3```

# 题解

## 作者：liangbowen (赞：10)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P4572)

[更好的阅读体验？](https://www.cnblogs.com/liangbowen/p/16755279.html)

双倍经验：P3554（数据坑一点）。简要题意可以看 P3554。

思路：二分答案 + 树形 DP。

## 思路

答案显然具有单调性，所以考虑二分答案。

$\operatorname{chk(k)}$ 判定这个 $k$ 是否能使 A 获胜。

容易想到贪心，但实际上并不可行。这是同机房巨佬的 [hack](https://www.luogu.com.cn/discuss/503923)。于是考虑 DP。

---

首先两人都很聪明，所以 B 会一直从根往下走；A 会一直在 B 下面的层染色。

最麻烦的是，在对一个子树染色时，可能会出现染不够的情况。但这并不意味着 $k$ 不成立，因为 $i$ 的祖先可能会有剩余的没有染色。

听起来非常难懂，举个例子，$k = 3$。

![](https://cdn.luogu.com.cn/upload/image_hosting/xfuz1xiz.png)

如果只看以 $2$ 为根的子树，显然无法染完。

但是如果看以 $1$ 为根的整棵树，发现：染完 $2,3$ 号点后还能再染一次，这样可以帮 $2$ 为根的子树染一下。于是 $k = 3$ 就成立了。

我们就可以用这个性质实现 DP。

---

设 $dp_i$ 表示以 $i$ 为根的子树，需要 $dp_i$ 次祖先的帮助。

那么就有转移方程（为了美观，分了两行）：

$$\texttt{sum} = \sum\limits_{\text{v : son of u}} dp_v + 1$$

$$dp_u = \max\{0, \texttt{sum} - k\}$$

$\texttt{sum}$ 即为子树需要的帮助次数。每次加 $(dp_v + 1)$，是因为还要染 $v$，所以加了一。

那么 $k$ 能成立，当且仅当 $dp_1 = 0$。

这题就愉快地做完啦！

## 完整代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int N = 3e5 + 5;
struct Edge {int now, nxt;} e[N << 1];
int head[N], cur;
void add(int u, int v)
{
	e[++cur].now = v;
	e[cur].nxt = head[u];
	head[u] = cur;
}
int k, dp[N];
void dfs(int u, int fa) //按照转移方程来就好了
{
	int sum = 0;
	for (int i = head[u]; i; i = e[i].nxt)
	{
		int v = e[i].now;
		if (v != fa) dfs(v, u), sum += dp[v] + 1; 
	}
	dp[u] = max(0, sum - k);
}
bool chk(int x)
{
	k = x, dfs(1, -114514);
	return !dp[1]; //等同于 return dp[1] == 0
}
int FIND(int l, int r) //二分答案
{
	while (l < r)
	{
		int mid = (l + r) >> 1;
		if (chk(mid)) r = mid;
		else l = mid + 1;
	}
	return r;
}
int main()
{
    ios::sync_with_stdio(false);
	int n;
	cin >> n;
	for (int i = 1; i < n; i++)
	{
		int u, v;
		cin >> u >> v;
		add(u, v), add(v, u);
	}
	cout << FIND(0, n); //注意 l=0，否则 n=1 会叉掉
    return 0;
}
```

希望能帮助到大家！

---

## 作者：littleKtian (赞：6)

直接计算感觉不好处理，因此考虑二分答案，假设我们现在需要检验的答案为 $k$。

因为大军一定不会往回走（这样会浪费时间），所以我们考虑将整个进攻过程倒过来处理。

设 $f_i$ 表示大军进攻到点 $i$ 时，需要在这之前给 $i$ 的子树中施加魔法的节点个数（不包括 $i$ 本身）。

有递推式 $f_i=\max\{0,\sum(f_j+1)-k\}$，其中 $j$ 是 $i$ 的子节点。

显然如果最后 $f_1=0$，那么这个答案就是可行的，否则就是不可行的。

总复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int lw[300005],bi[600005][2],bs;
int n;
int dr()
{
	int xx=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')xx=(xx<<1)+(xx<<3)+ch-'0',ch=getchar();
	return xx;
}
void tj(int u,int v){++bs,bi[bs][0]=lw[u],bi[bs][1]=v,lw[u]=bs;}
int dfs(int w,int fa,int k)
{
	int x=0;
	for(int o_o=lw[w];o_o;o_o=bi[o_o][0])
	{
		int v=bi[o_o][1];
		if(v!=fa)x+=dfs(v,w,k)+1;
	}
	return max(x-k,0);
}
int main()
{
	n=dr();
	for(int i=1;i<n;i++)
	{
		int u=dr(),v=dr();
		tj(u,v),tj(v,u);
	}
	int l=0,r=n-1,mid;
	while(l+1<r)
	{
		mid=(l+r)>>1;
		if(dfs(1,0,mid)==0)r=mid;
		else l=mid;
	}
	printf("%d",r);
}
```


---

## 作者：abc1856896 (赞：2)

# Solution

第一眼看上去答案应该是所有同一深度节点个数的最大值。但这样是错的。因为同一层的点不一定要一次染完，可以借助上一层多出来的去染颜色。

例如：![](https://cdn.luogu.com.cn/upload/image_hosting/qoip1g65.png)

此时答案应该是 $2$，第一次染 $2$ 和 $3$，第二次染 $4$ 和 $5$，最后一次染 $6$ 和 $7$。因为前几个节点同一深度只有一个节点，所以可以把下面的也染了。

此时我们注意到这种做法的问题在于不单单看同一深度的情况，**也可以借助祖先**。不妨定义 $dp_u$ 表示 $u$ 节点要祖先帮他染多少次，则 $dp_u= \max(\sum _ {u \sub \operatorname {son}_u} (dp_{v}+1)-m,0)$，含义为子儿子需求量之和，$m$ 表示一次染的节点个数。如果该情况合法，即不用找 $1$ 的祖先帮忙，则 $dp_1$ 为 $0$。

此时问题转化为最小的 $m$ 使得 $dp_1$ 为 $0$，注意到答案有单调性，二分即可。

# Code


```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 1000000007
#define debug(x) cout<<x<<" "
#define debug2(x) cout<<x<<endl
#define mem(a,x) memset(a,x,sizeof(a))
#define endl '\n'
#define ll long long
#define Min(a,b) a=a<b?a:b
#define Max(a,b) a=a>b?a:b
#define Add(a,b) a=(a+b)%mod
#define Minus(a,b) a=((a-b)%mod+mod)%mod
#define Mul(a,b) a=a*b%mod
#define gcd(a,b) __gcd(a,b)
#define lcm(a,b) (a)/gcd(a,b)*(b)
#define vi vector<int>
#define pi pair<int,int>
#define pb push_back
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
using namespace std;
int head[600005],Gcnt;
struct data{
	int to;
	int next;
};
data edge[600005];
void add_edge(int from,int to){
	Gcnt++;
	edge[Gcnt].to=to;
	edge[Gcnt].next=head[from];
	head[from]=Gcnt;
}
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
int dp[300005];
void dfs(int u,int fa,int k) {
	int sum=0;
	for(int i=head[u];i;i=edge[i].next) {
		int v=edge[i].to;
		if(v==fa) continue;
		dfs(v,u,k);
		sum+=dp[v]+1;
	}
	dp[u]=max((long long)(0),sum-k);
}
bool check(int mid) {
	memset(dp,0,sizeof(dp));
	dfs(1,0,mid);
	return !dp[1];
}
void solve() {
	int n=read();
	for(int i=1;i<n;i++) {
		int u=read(),v=read();
		add_edge(u,v),add_edge(v,u);
	}	
    if(!n || n==1) {
        cout<<0;
        return;
    }
	int l=0,r=n+1;
	while(l+1<r) {
		int mid=l+r>>1;
		if(check(mid)) r=mid;
		else l=mid;
	}
	cout<<r;
}
signed main(){
	int T=1;
	//cin>>T;
	while(T--) solve(); 
	return 0;
}
```

---

## 作者：sqzyz (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P4572)

[双倍经验](https://www.luogu.com.cn/problem/P3554)

## 题意

给一颗 $n$ 个节点的树，初始时 $1$ 号节点被防御，其余未被防御。一开始伏地魔在 $1$ 号节点。每一轮凤凰社选择 $k$ 个点防御，然后伏地魔走到一个相邻节点。求确保伏地魔不会走到未经防御的点的情况下，$k$ 的最小值

## 思路

由于答案具有单调性，考虑二分答案

再来考虑 check 怎么写

首先，伏地魔一定不会回到已经攻克的点，因为在采取最优策略的情况下，此举是无意义的，只会浪费时间

因此，凤凰社必须将下一步伏地魔可能前往的点全部防御，但是一次防御可能无法覆盖伏地魔下一步可能前往的所有点，此时需要上一步中剩余的凤凰社成员来支援

记 $f_u$ 表示以节点 $u$ 为根的子树所需要的支援数，得到转移方程 $ f_u=size_u-k+\sum\ max(f_v , 0)$ , 其中 $v$ 表示 $u$ 的子节点，$k$ 表示当前二分的值，$size_u$ 表示 $u$ 的子节点个数

如此，若 $f_1\le0$ ,当前二分到的 $k$ 合法，反之则不合法

## 代码

```
#include<bits/stdc++.h>
using namespace std;
int n;
vector<int>e[300005];
int siz[300005],f[300005];
void init(int u,int pa){
	for(int i=0;i<e[u].size();i++){
		int v=e[u][i];
		if(v==pa)continue;
		siz[u]++;
		init(v,u);
	}
}

void dfs(int u,int pa,int p){
	f[u]=siz[u]-p;
	for(int i=0;i<e[u].size();i++){
		int v=e[u][i];
		if(v==pa)continue;
		dfs(v,u,p);
		f[u]+=max(f[v],0);
	}
	return;
}
bool check(int p){
	memset(f,0,sizeof(f));
	f[1]=siz[1];
	dfs(1,0,p);
	if(f[1]<=0)return 1;
	return 0;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	init(1,0);
	int l=siz[1],r=0;
	for(int i=1;i<=n;i++)r=max(r,siz[i]);
	while(l<r){
		int mid=(l+r)>>1;
		if(check(mid))r=mid;
		else l=mid+1;
	}
	printf("%d",l);
	return 0;
}
```

---

## 作者：AbsMatt (赞：2)

## [题目传送器](https://www.luogu.com.cn/problem/P4572)
### 注意：如果你不好好看着一条，你就会损失一道[紫题 $AC$ ](https://www.luogu.com.cn/problem/P3554)

# 分析
### 题目意思
其实这道题的意思就和[这题意思一模一样(~~双倍经验~~)](https://www.luogu.com.cn/problem/P3554)

给一颗有 $n$ 个节点的多叉树，初始 $1$ 号点为黑色，其余都是白色的。开始时 B 在 $1$ 号节点，每轮 $A$ 选择 $k$ 个点进行染色，然后 B 走到相邻的一个点上， A 点先走，问保证 B 每一步都走不到白色点的 $k$ 的最小值。

### 思路
这题就是一道比较典型的二分答案题目，只需用 $O(\log_{2}{n})$ 二分答案 $k$ 的值，再用 $O(n)$ 的时间 check 下就行了。

本题还需要用到树形 DP 来记录每个节点第 $i$ 个节点的子树中（不包括 $i$）还需要染色的次数。

转移方程也就是

$dp[u]=\max({0,\sum_{son}^{dp_{son}}+1-k})$

### 注：本题用 vector 不会被卡常！！！

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MAX = 3e5+10;
int dp[MAX],n,l,r,ans;
vector <int> son[MAX];
void check(int x, int u, int fa) {
	int sum = 0;
	for(int i=0;i<son[u].size();i++) { // 树形DP
		int v=son[u][i];
		if(v == fa)	continue;
		check(x, v, u);
		sum +=(dp[v] + 1);
	}
	dp[u]=max(
    (long long)0,sum-x);
}

signed main() {
	cin>>n;
	for(int i = 1; i < n; i++) {
		int u,v;
		scanf("%lld%lld,&u,&v");
		son[u].push_back(v);
		son[v].push_back(u);
	}
	l = 0, r = n-1;
	ans = 0;
	while(l <= r) { // 二分答案
		int mid = (l+r)>>1;
		check(mid, 1, 0);
		if(dp[1] == 0) {
			r = mid-1;
			ans = mid;
		} else l = mid + 1;
	}
	cout<<ans;
   return 0; // 再见
}
```


---

## 作者：KukCair (赞：1)

#### 二分

我们发现答案具有单调性。

考虑二分的 check 怎么写。

#### check

首先大军肯定会往下走，往回走是不划算的，纯浪费时间；

而凤凰社会启用大军正在攻克节点的子节点。

设派出 $x$ 人。

我们设 $dp_i$ 为以 $i$ 为根的子树需要从其他地方调来的人，则有

$$dp_i\gets\max\{(\sum_{v=i \text{的子节点}} (dp_v+1)) - x, 0\}$$

- 为什么要和 $0$ 取 $\max$？

  这个时候若 $dp_i<0$，按照我们的定义是指调走人帮助兄弟节点，但由于我们并不知道应帮助谁，所以只能取 $0$。

- 为什么要 $dp_v+1$？

  需要开启 $v$ 本身。

#### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, dp[300005];
vector<int> vc[300005];
void dfs(int x, int fa, int k){
	for(int i = 0; i < vc[x].size(); i++){
		int v = vc[x][i];
		if(v != fa){
			dfs(v, x, k);
			dp[x] += dp[v] + 1;
		}
	}
	dp[x] = max(0, dp[x] - k);
}
bool check(int x){
	memset(dp, 0, sizeof(dp));
	dfs(1, 0, x);
	if(dp[1] > 0) return 0;
	return 1;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n;
	for(int i = 1; i <= n - 1; i++){
		int u, v;
		cin >> u >> v;
		vc[u].push_back(v);
		vc[v].push_back(u);
	}
	int l = 0, r = n - 1;
	while(l < r){
		int mid = (l + r) / 2;
		if(check(mid)) r = mid;
		else l = mid + 1;
	}
	cout << l;
	return 0;
}
```

---

## 作者：__Deng_Rui_Song__ (赞：1)

# problem

[题目传送门](/problem/P4572)

两个人 A 和 B 进行一个游戏：有根为 $1$ 的一棵树，放置一个棋子在点 $1$，一开始点 $1$ 已经被激活，其他点没有被激活，B 需要选择一个参数 $K$，游戏流程如下：

1. B 选择 $K$ 个未激活的点激活。

2. A 将一个棋子走一步。

3. 重复以上流程。

如果棋子走到了未激活的点，A 胜利，反之，B 胜利。确定 $K$ 的最小值。

# solution

容易发现棋子不会往上走，答案具有单调性，可以二分。

那怎么 check 呢？可以发现当棋子走到 $x$ 号结点时，只需要激活 $x$ 子树内的结点，所以没有后效性，考虑 dp。

设 $dp_i$ 表示到达 $i$ 号结点需要额外激活多少个结点。

你：check 答案就是 $dp_1$ 是否为 $0$。

没错，状态转移方程不太好想，首先，额外激活的数量为 $\sum_{i\to u}dp_u$（$\to$ 指有连边），其次，新增了 $\sum_{i\to u}$ 个结点，最后，可以激活 $K$ 个结点，所以状态转移方程为：$dp_i=(\sum_{i\to u}(dp_u+1))-k$。

你：诶，不对，如果有负数怎么办？

就相当于多出一些激活机会。

你：哦，它可以用来帮助兄弟结点，答案为 $dp_1$ 是否小于等于 $0$。

错了！如果 A 发现 B 在激活兄弟结点，根据最优策略，A 肯定不会走被 B 激活的兄弟结点，会算错！

你：那咋整？

跟 $0$ 取 max！！！

# code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,dp[300005];
vector<int> g[300005];
void dfs(int x,int fa,int val){
	dp[x] = (int)(g[x].size()) - (x != 1) - val;
	for (int i = 0; i < g[x].size(); i++){
		int nxt = g[x][i];
		if (nxt == fa) continue;
		dfs(nxt,x,val);
		dp[x] += dp[nxt];
	}
	dp[x] = max(dp[x],0ll);// 注意注意再注意！
}
bool check(int x){
	dfs(1,0,x);
	return !dp[1];
}
signed main(){
	cin >> n;
	for (int i = 1,x,y; i < n; i++){
		cin >> x >> y;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	int l = -1,r = n + 1;
	while (l + 1 < r){
		int mid = (l + r) / 2;
		if (check(mid)) r = mid;
		else l = mid;
	}
	cout << r;
	return 0;
}
```

---

## 作者：Jadonyzx (赞：1)

# 题意

去[双倍经验](https://www.luogu.com.cn/problem/P3554)自己看，非常简约的题面版本。

~~江苏 OI 特有的强悍找原题能力~~

## 单调性

对于人数 $ccf$ 和人数 $ioi$，如果 $ccf>ioi$ 且对于人数 $ioi$ 一定能防住伏地魔，则易证 $ccf$ 也一定有解。**也就是说 ~~CCF 一定能 AKIOI~~ 一定可以二分答案**。

## 考虑贪心

我太菜了想不到，直接跳过。

## 考虑动态规划

首先从对面的角度考虑问题，如果要使我方用的人数最多，一定是一口气走到最下面，这很显然对吧？

我们不妨设 $ccf_i$ 表示 $i$ 号子树需要上面多少人马的支援，$ioi$ 表示当前二分值，因为有时人数溢出，可以先防守后面的位置，因此在往上跳的过程中允许存在暂时不行的情况，有转移方程 $ccf_i=\max(0,ioi-\sum {(ccf_j+1)})$，和零取 $max$ 是缺的人数不可能为负，加一是因为该子节点也需被防御，最后判一下根节点是否需要来自虚空的支援就好了。

**~~加上一句 I love CCF 更容易通过哦~~**

> **Talk is cheap,show me the code.**


```cpp
#include<bits/stdc++.h>
#define maxn 300010
using namespace std;
int IOI,ccf[maxn],APIO;
vector<int>AK[maxn];
void CCF(int zjoi,int noi,int ioi){
	int rp=0;
	for(auto noip : AK[zjoi]){
		if(noip==noi)continue;
		CCF(noip,zjoi,ioi);
		rp+=ccf[noip]+1;
	}
	ccf[zjoi]=max(0,rp-ioi);
	return;
}
bool NOI(int ioi){
	memset(ccf,0,sizeof ccf);
	CCF(1,0,ioi);
	if(ccf[1]==0)return 1;
	return 0;
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>IOI;
	for(int ioi=1;ioi<IOI;++ioi){
		int RP,rp;cin>>RP>>rp;
		AK[RP].push_back(rp);
		AK[rp].push_back(RP);
	}
	int Codeforces=0,Luogu=IOI-1,ZJOI;
	while(Codeforces<=Luogu){
		ZJOI=(Codeforces+Luogu)/2;
		if(NOI(ZJOI))APIO=ZJOI,Luogu=ZJOI-1;
		else Codeforces=ZJOI+1;
	}
	cout<<APIO;
	return 0;
}
//I love CCF!
```

---

## 作者：AlicX (赞：1)

### 题意
给你一个有 $n$ 个点的树，对于每一次操作，伏地魔大军会前往与他们所在点相邻的点，而如果这个点是未被施过魔法，
保卫就失败了，求最小需要多少人才能保证在不输的情况下将所有的建筑施保护魔法。

## 思路
1. 首先我们可以发现答案具有单调性，假如 $k$ 个人可以做到，那么大于 $k$ 的人数就一定可以做到，所以我们考虑二分答案。

2. 那么怎么判断当前人数是否可行呢？因为每次伏地魔大军都是向当前节点的子节点走的，不会走回头路。因为假如他走回头路，说明现在走的路不是最优的，但是他们一定会走最优路线，所以矛盾了。知道了他们一定向子节点走，所以我们考虑树形动态规划。

3. 状态定义：因为一个点的子节点有可能不会被当前人数一次性全保护完，而他的祖先节点又有可能不会用完当前人数，所以当这种情况出现时，节点的剩余人数会提前为现在的节点施魔法，为了表示这种状态，我们定义 $f_i$ 表示节点 $i$ 所需的来自祖先节点的支援数量。

4. 状态转移：假定当前人数为 $k$，用 $son_i$ 表示节点 $i$ 的子节点数量，那么节点 $i$ 所需的志愿数量就是它本身所需的支援数量加上它所有的子节点所需的支援数量。所以退出状态转移方程：$f_i=son_i+ans-k$，其中 $ans$ 为所有子节点所需的支援数量。

5. 注意：当 $n$ 为 $1$ 时，输出 $0$。

## AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define x first
#define y second
using namespace std;
typedef pair<int,int> pii;
const int N=3e5+10;
int n;
int f[N];
int son[N];
int h[N],idx=0;
struct Node{
	int to,ne;
}tr[N<<1];
void add(int u,int v){
	tr[idx].to=v,tr[idx].ne=h[u],h[u]=idx++;
}
void dfs(int u,int fa){
	for(int i=h[u];i!=-1;i=tr[i].ne){
		int to=tr[i].to;
		if(to==fa) continue;
		son[u]++,dfs(to,u);
	}
}
void dp(int u,int fa,int k){
	int ans=0;
	for(int i=h[u];i!=-1;i=tr[i].ne){
		int to=tr[i].to;
		if(to==fa) continue;
		dp(to,u,k),ans+=f[to];
	}
	f[u]=max(son[u]+ans-k,1ll-1);
}
bool check(int mid){
	memset(f,0,sizeof f);
	dp(1,0,mid);
	if(!f[1]) return true;
	return false;
}
signed main(){
	memset(h,-1,sizeof h);
	cin>>n;
	if(n==1){
		cout<<0<<endl;
		return 0;
	}
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		add(u,v),add(v,u);
	}
	dfs(1,0);
	int l=1,r=n-1;
	while(l<r){
		int mid=l+r>>1;
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	cout<<r<<endl;
	return 0;
}/*
f[i]表示i节点所需要的最小支援数量 
*/
```

---

## 作者：CYZZ (赞：1)

# [P4572 哈利波特与死亡圣器](https://www.luogu.com.cn/problem/P4572)
~~我绝对不会告诉你这是道~~[~~双倍经验~~](https://www.luogu.com.cn/problem/P3554)。
# 题意简明
有一颗 $n$ 个节点的树，初始时 $1$ 号节点是黑的，其余是白的，两个人轮流进行操作。$A$ 一开始在 $1$ 号节点，每一轮，$B$ 选择 $k$ 个点染黑，然后 $A$ 走到原来点的其中一个子节点上，如果 $A$ 当前位于白点则 $A$ 胜，重复该过程。当 $B$ 将所有点染成黑色时则 $B$ 胜。求能让 $B$ 获胜的**最小**的 $k$。

# 思路分析
正常人第一眼一般会想到**贪心**，就是一层一层地染色，求树上同一层节点数的最大值，可当你看到这张图时......

![](https://cdn.luogu.com.cn/upload/image_hosting/fn4g6lyz.png)

我们来分析一下：按照贪心的思路，对于这棵树，$k$ 为 $4$。事实上答案为 $3$。第一轮，我们染 $2,3,4$ 号点。第二轮，无论 $A$ 跑到 $2$ 还是 $3$，我们把 $5,6,7$ 号点染黑，$A$ 就无路可走了。

模拟后我们不难发现：在染到第 $i$ 层前，第 $i$ 层的点是有可能已经被染了色的。换句话说，如果在染祖先的时候，有多出来的兵力，可以先帮它的子孙染一下。

显然，答案满足单调性。扫了一眼数据范围 $n\le 3 \times 10^5$，果断采用**二分答案**。

既然采用了二分答案，那 ckeck 函数怎么写呢？这时候，我们亮出正解：**树形 dp**！！！

设 $dp_i$ 表示染色到 $i$ 之前，以 $i$ 为根的子树中已经有 $dp_i$ 个节点被染了色，设 $i$ 的儿子为 $j$，然后我们就愉快地得出了状态转移方程：

$$ dp_i = \max(0,\sum\limits_{j}^{}{(dp_j+1)}-k) $$

加 $1$ 是因为 $j$ 本身也需要染，减 $k$ 是因为 $i$ 自己有 $k$ 个兵力。因为帮助数总不能为负数，所以要和 $0$ 做比较。然后我们要做的就只剩用 dfs 遍历每一个子树了。

# 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,tot,mid,head[300005],dp[300005];
struct node
{
	int next,to;
}e[600005];
void add_edge(int u,int v)
{
	e[++tot].next=head[u];
	e[tot].to=v;
	head[u]=tot;
}
void dfs(int u,int fa)//树形dp 
{
	int sum=0;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v!=fa)
		{
			dfs(v,u);
			sum+=dp[v]+1;//记得加1 
		}
	}
	dp[u]=max(0,sum-mid);
}
bool check()
{
	dfs(1,0);
	return !dp[1];
}
int binary_search()
{
	int l=0,r=n;
	/*如果整棵树只有一个节点呢？所以l从0开始*/ 
	while(l<r)
	{
		mid=(l+r)/2;
		if(check())
			r=mid;
		else
			l=mid+1;
	}
	return r;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add_edge(x,y);
		add_edge(y,x);
	}
	printf("%d",binary_search());
	return 0;
}
```
本蒟蒻的第二篇题解，希望能帮到大家！！！

---

## 作者：NTT__int128 (赞：0)

首先，发现答案具有单调性，考虑二分。

~~然后发现不会 check……~~

用树形 DP 写 check。

假设现在的 $k\gets mid$。

定义 $dp_x$ 表示如果伏地魔大军到达建筑 $x$ 时 $x$ 的子树内至少要提前给多少建筑施咒。

则 $dp_x\gets\sum\limits_{y是x的儿子}(dp_y+1)-k$。

然后，$dp_x\gets\max(dp_x,0)$。

你可能会问：为什么要对 $0$ 取 $\max$？$dp_x<0$ 不是代表可以匀出人给别的建筑物施咒吗？

~~自行思考~~

我们发现，我们是不知道伏地魔大军下一步要去哪里的。有可能我们给一个建筑施了咒，而伏地魔大军不走那里，我们就白修了。

最后，如果 $dp_1=0$，则可以，否则不行。（因为伏地魔大军到达建筑 $1$ 时凤凰社不能提前施咒）

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5;
int n,x,y,dp[N];
vector<int>v[N];
void dfs(int x,int f,int k){
	dp[x]=0;
	for(int y:v[x])
		if(y!=f){
			dfs(y,x,k);
			dp[x]+=dp[y]+1;
		}
	dp[x]=max(dp[x]-k,0);
}
bool check(int k){
	dfs(1,0,k);
	return dp[1]==0;
}
namespace IO
{
	int len=0;
	char ibuf[(1<<20)+1],*iS,*iT,out[(1<<26)+1];
	#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
	#define reg register
	inline int read()
	{
		reg char ch=gh();
		reg int x=0;
		reg char t=0;
		while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();
		while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
		return t?-x:x;
	}
	inline void putc(char ch)
	{
		out[len++]=ch;
	}
	template<class T>
	inline void write(T x)
	{
		if(x<0)putc('-'),x=-x;
		if(x>9)write(x/10);
		out[len++]=x%10+48;
	}
	inline void flush()
	{
		fwrite(out,1,len,stdout);
		len=0;
	}
}
using IO::read;
using IO::write;
using IO::flush;
using IO::putc;
int main(){
	n=read();
	for(int i=1;i<n;i++)x=read(),y=read(),v[x].push_back(y),v[y].push_back(x);
	int l=0,r=n;
	while(l<r){
		int d=(l+r)>>1;
		if(check(d))r=d;
		else l=d+1;
	}
	write(l);
	flush();
	return 0;
}
```

---

## 作者：_Cheems (赞：0)

具有单调性，二分答案 $k$，考虑判定。

可以发现，伏地魔是不会走回头路的。设当前点 $u$ 的父亲是 $fa$，则当伏地魔先前在 $fa$ 处时肯定是不存在一个未被保护的相邻节点，不然走过去就赢了。那从 $u\to fa$ 再走到另一个节点肯定不如在 $fa$ 时直接向那个点走去，因为被保护的点肯定更多了。同时，假如伏地魔走到了 $u$，那么接下来我们只会对 $u$ 子树内的点进行保护。

无后效性可以树形 dp。考虑 $f_u$ 表示伏地魔在 $u$ 点出发向子树内走去，若要成功防御则至少还需要提前保护多少个点。转移是容易的，$f_u\gets \max(0,(\sum\limits_{v\in son} 1+f_v)-k)$，因为我们在伏地魔行动前操作，而无法得知他具体往哪走，所以必须让每个儿子子树都合法。

复杂度 $O(n\log n)$。

闲话：是因为题目名字有趣所以开的这道题，感觉比较水，顶多评个蓝吧。
#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 3e5 + 5;
int n, u, v, k, f[N];
vector<int> to[N];

inline void dfs(int u, int fa){
	f[u] = 0;
	for(auto v : to[u])
		if(v ^ fa) dfs(v, u), f[u] += 1 + f[v];
	f[u] = max(0, f[u] - k); 
}
signed main(){
	cin >> n;
	for(int i = 1; i < n; ++i) scanf("%d%d", &u, &v), to[u].push_back(v), to[v].push_back(u);
	int L = -1, R = n, mid;
	while(L + 1 < R){
		mid = (L + R) >> 1;
		k = mid, dfs(1, 0);
		if(!f[1]) R = mid;
		else L = mid;
	}
	cout << R;
	return 0;
}
```

---


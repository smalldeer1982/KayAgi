# [FJOI2018] 领导集团问题

## 题目描述

一个公司的组织领导架构可以用一棵领导树来表示。公司的每个成员对应于树中一个结点 $v_i$，且每个成员都有响应的级别 $w_i$。越高层的领导，其级别值 $w_i$ 越小。树中任何两个结点之间有边相连，则表示与结点相应的两个成员属于同一部门。领导集团问题就是根据公司的领导树确定公司的最大部门。换句话说，也就是在领导树中寻找最大的部门结点子集，使得的结点 $v_i$ 和 $v_j$，如果 $v_i$ 是 $v_j$ 的子孙结点，则 $w_i \ge w_j$。

编程任务：对于任意对于给定的领导树，计算出领导树中最大的部门结点子集。


## 说明/提示

对于 $10\%$ 的数据，$n\le 20$；

对于 $40\%$ 的数据，$n\le 2000$；

对于 $100\%$ 的数据，$1\le n\le 2\times 10 ^ 5$，$0 < w_i \le 10 ^ 9$。

## 样例 #1

### 输入

```
6
2 5 1 3 5 4
1
1
2
2
4```

### 输出

```
4```

# 题解

## 作者：dodo (赞：57)

楼上两篇题解写的有一点点复杂，有map还写了离散化……

差分固然是一种理解方式，但其实有一种更好的理解方法和更简洁的代码。

那么现在我就来讲一讲

### 题意简述

文字语言：求树上最大权值随祖孙关系不降的点集大小

数学语言：求 $|S_{max}|$ 使得 $\forall{i,j(ancestor\ of \ i)\in S}, w_i\leq w_j$

为了方便描述，我们定义这种集合为“树上LIS”。

### 题解

考虑采用数学归纳法

类似处理序列LIS问题，对于每一个点 $u$ 使用multiset维护一个集合 $f_u$ 满足以下性质

- $f_{u,i}$ 表示在 $u$ 的子树中选择 $i$ 个点组成的所有树上LIS中，级别值 $w$ 最小值最大的那一个。

- 以 $u$ 为根节点的 $ans_u=|f_u|$（$|f_u|$表示集合 $f_u$ 的大小）（该性质可由上述性质发现）

对于任意一个叶子节点 $u$, $f_u$显然只含有 $w_u$，满足树上LIS性质。

再考虑不是叶子节点的 $u$

假设点 $u$ 的所有孩子 $v$ 的 $f_v$ 已经满足求出并满足上述性质，我们应该如何求出 $u$ 的 $f_u$ 呢？

首先，显然 $u$ 的所有孩子不会相互影响，要从以 $u$ 为根节点的子树（除 $u$ ）中选出大小为 $i$ 的树上LIS，可以直接贪心地选所有孩子集合中最大的 $i$ 个，于是只需将全部 $f_v$ 取并集并排序即可，于是可以直接将孩子们的 $f_v$ 集合全部启发式合并丢入 $f_u$ 的multiset ，记 $S=\bigcup_{v\in u.son}f_v$ 

现在我们考虑将 $u$ 加入 $S$ 集合并使集合满足性质

我们直接在multiset上二分出第一个 $i$ 满足 $f_{u,i}\geq w_u$ 那么我们将 $u$ 接在 $i$ 前显然是最优方案，此时 $f_{u,i-1}$ 就可以被 $w_u$ 替换，那么现在的集合就是我们要求的 $f_u$，并且满足树上LIS性质。

按照这样的方式在树上dfs即可求出 $f_1$，此时答案即为 $|f_1|$。

### 复杂度证明

该算法的复杂度为 $O(nlog^2n)$

考虑同样采用数学归纳法

记 $T_u$ 表示处理出 $f_u$ 的时间复杂度，$S_u$表示 $u$ 的子树大小

我们需要证明 $T_u=S_ulog^2S_u$

对于任意一个叶子节点 $u$，$S_u=1$，此时只需在multiset中插入 $w_u$ 复杂度为 $O(1)$，满足$T_i=S_ulog^2S_u$

再考虑不是叶子节点的 $u$

假设点 $u$ 的所有孩子 $v$ 的 $T_v=S_vlog^2S_v$ 

那么 $T_i=\sum_{v\in u.son}T_v+T_{merge}$

因为子孙们包含的节点个数$\sum_{v\in u.son}S_v+1=S_u$

所以$\sum_{v\in u.son}T_v\leq S_ulog^2S_u$

启发式合并的复杂度为 $S_ulogS_u$，使用multiset维护加一个log，$T_{merge}=S_ulog^2S_u$

所以$T_u$与 $S_ulog^2S_u$ 同阶

证毕。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
multiset<int> f[N];
multiset<int>::iterator it;
int n, w[N], ans;
int h[N], to[N], nxt[N], t;
bool comp(int x, int y) { return w[x] < w[y]; }
void add(int u, int v) { to[++t] = v, nxt[t] = h[u], h[u] = t; }
void merge(int u, int v) {
    if(f[u].size() < f[v].size()) swap(f[u], f[v]);
    for(it = f[v].begin(); it != f[v].end(); ++it) f[u].insert(*it);
}
void dfs(int u) {
    for(int i = h[u]; i; i = nxt[i]) dfs(to[i]), merge(u, to[i]);
    f[u].insert(w[u]);
    it = f[u].lower_bound(w[u]);
    if(it != f[u].begin()) f[u].erase(--it);
}
int main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; ++i) scanf("%d", &w[i]);
    for(int i = 2; i <= n; ++i) {
        int f;
        scanf("%d", &f);
        add(f, i);
    }
    dfs(1);
    printf("%d", f[1].size());
}
```


---

## 作者：Mr_Wu (赞：17)

设 $f_{u,i}$ 表示 $u$ 的子树中的方案最大值，保证这个方案中点权最小值为 $i$，当不选 $u$ 时，依如下递推式单次将 $u$ 的集合（指之前扫过的儿子和自己构成的集合）与 $v$ 的子树的 dp 信息合并（不存在方案设为 $-\infty$）

$$
f_{\text{new}}(u,i)=\max\{f(u,i)+\max_{j\ge i} f(v,j), f(v,i)+\max_{j\ge i} f(u,j) \}
$$

当选 $u$ 时，依递推式

$$
f(u,a_u)\leftarrow_{\max} 1+\sum_v \max_{j\ge a_u} f(v,j)
$$

现在直接收手，上线段树合并，我们将不存在方案的 dp 在实现是设为 0 （也就是这里没有节点），选 $u$ 时是单点改比较正常，在线段树合并（将 $o'$ 合并到 $o$ 上）时需要维护后缀 max，如果 $o=\text{null}$ 时，需要一个区间加操作，且一开始为 0 的位置不能被加。所以要存储一个节点的 dp 最大值和有 dp 值的位置个数。时间复杂度 $O(n\log n)$。

但常数极大，跑不过双 log：

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAXN = 200005, INF = 100000000;

int N, a[MAXN], id[MAXN], rk[MAXN];
bool cmp(int x, int y) { return a[x] < a[y]; }

struct node { int v, next; } E[MAXN << 1]; int head[MAXN], Elen;
void add(int u, int v) { ++Elen, E[Elen].v = v, E[Elen].next = head[u], head[u] = Elen; }

int rt[MAXN];
struct segmentTree {
	int ls[MAXN * 30], rs[MAXN * 30], mx[MAXN * 30], tag[MAXN * 30], cnt[MAXN * 30], Tlen;
	#define mid ((l + r) >> 1)
	void pushUp(int o) { mx[o] = max(mx[ls[o]], mx[rs[o]]), cnt[o] = cnt[ls[o]] + cnt[rs[o]]; }
	void plus(int o, int k) { if (mx[o]) mx[o] += k, tag[o] += k; }
	void pushDown(int o) { if (tag[o]) plus(ls[o], tag[o]), plus(rs[o], tag[o]), tag[o] = 0; }
	int query(int& o, int l, int r, int L, int R) {
		if (!o) return 0;
		if (l == L && r == R) return mx[o];
		else {
			pushDown(o);
			if (R <= mid) return query(ls[o], l, mid, L, R);
			else if (L > mid) return query(rs[o], mid + 1, r, L, R);
			else return max(query(ls[o], l, mid, L, mid), query(rs[o], mid + 1, r, mid + 1, R));
		}
	}
	void insert(int& o, int l, int r, int pos, int k) {
		if (!o) o = ++Tlen;
		if (l == r) {
			if (!mx[o]) cnt[o] = 1;
			mx[o] = max(mx[o], k);
		}
		else {
			pushDown(o);
			if (pos <= mid) insert(ls[o], l, mid, pos, k);
			else insert(rs[o], mid + 1, r, pos, k);
			pushUp(o);
		}
	}
	void modify(int& o, int l, int r, int L, int R, int K) {
		if (!o) o = ++Tlen;
		if (l == L && r == R) plus(o, K);
		else {
			pushDown(o);
			if (R <= mid) modify(ls[o], l, mid, L, R, K);
			else if (L > mid) modify(rs[o], mid + 1, r, L, R, K);
			else modify(ls[o], l, mid, L, mid, K), modify(rs[o], mid + 1, r, mid + 1, R, K);
			pushUp(o);
		}
	}
	void merge(int& o, int l, int r, int old, int mx1, int mx2) {
		if (!o) o = old, plus(o, mx1);
		else if (!old) plus(o, mx2);
		else if (l == r) {
			int val = max(mx[o] + mx[old], max (mx[o] + mx2, mx[old] + mx1));
			if (val && !mx[o]) cnt[o] = 1;
			mx[o] = val;
		}
		else {
			pushDown(o), pushDown(old);
			merge(ls[o], l, mid, ls[old], max(mx1, mx[rs[o]]), max(mx2, mx[rs[old]]));
			merge(rs[o], mid + 1, r, rs[old], mx1, mx2);
			pushUp(o);
		}
	}
} sgt;

void dfs(int u, int ff) {
	int qaq = 1;
	for (int i = head[u]; i; i = E[i].next) if (E[i].v != ff) dfs(E[i].v, u), qaq += sgt.query(rt[E[i].v], 1, N, rk[u], N);
	bool flag = 1;
	for (int i = head[u]; i; i = E[i].next) if (E[i].v != ff) {
		if (flag) rt[u] = rt[E[i].v], flag = 0;
		else sgt.merge(rt[u], 1, N, rt[E[i].v], 0, 0);
	}
	sgt.insert(rt[u], 1, N, rk[u], qaq);
}

int ans;
int main() {
	scanf("%d", &N);
	for (int i = 1; i <= N; ++i) scanf("%d", &a[i]), id[i] = i;
	sort(id + 1, id + N + 1, cmp);
	for (int i = 1; i <= N; ++i) rk[id[i]] = rk[id[i - 1]] + (a[id[i - 1]] != a[id[i]]);
	for (int i = 2, x; i <= N; ++i) scanf("%d", &x), add(x, i);
	dfs(1, 0);
	printf("%d\n", sgt.query(rt[1], 1, N, 1, N));
	return 0;
}
```

---

## 作者：George1123 (赞：17)


更棒棒的体验 $\Longrightarrow$ [$\it George1123$](https://www.cnblogs.com/George1123/p/13634442.html)

---
## 题面

> [FJOI2018 领导集团问题](https://www.luogu.com.cn/problem/P4577)

> 给一棵树 $T(|T|=n)$，每个点有个权值 $w_i$，从中选出一个子点集 $P=\{x\in {\rm node}|x\in T\}$，使得 $\forall u,v\in P,v\in{u{\rm 's\ subtree}}$ 满足 $w_v\ge w_u$，求 $|P|_{\max}$。

> 数据范围：$1\le n\le 2\cdot 10^5$，$0<w_i\le 10^9$。

---
## 蒟蒻解

这里是线段树合并维护 $\rm dp$ 的做法，$\Theta(n\log n)$ 但是跑得最慢，觉得这个做法屑的可以在评论区里怒斥 $\rm George1123$ 逊然后点踩走人，这个低佬一等的蒟蒻需要您的打击。

先对 $w_i$ 离散化，然后想 $n^2$ 的 $\rm dp$：考虑到每个节点要选，它的子树中就只能选 $\ge$ 它权值的。所以令 $f(u,x)$ 表示在 $u$ 的子树中，选的节点权重都 $\ge x$ 的最大满足题目要求子集大小。

对于一个节点 $u$，考虑它选不选，可以如下转移 $dp$：

$$x\in [1,n],f(u,x)\max=\sum_{v\in{u{\rm 's\ subtree}}}f(v,x)$$

$$x\in [1,w_u],f(u,x)\max=\sum_{v\in{u{\rm 's\ subtree}}}f(v,w_u)$$

考虑到要区间转移，可以线段树维护；考虑到要子树合并转移，可以线段树合并。

写线段树合并的时候要维护三个操作：权值求和 $\rm merge$、区间与 $x$ 取 $\max$、单点求值。

然后就可以做了，但是因为线段树合并上区间修改很困难，所以您旁边的巨佬 zhoukangyang 会怒斥着告诉您一个更好的做法：差分。

很明显 $\forall x\in[1,n-1],u\in T,f(u,x)\ge f(u,x+1)$，所以令 $g(u,x)=f(u,x)-f(u,x+1)$，然后维护。

三个操作对应的新做法为：继续权值求和 $\rm merge$、线段树上二分找分界点然后差分单点修改、区间求和。

然后就很好写了，线段树上二分找分界点是 $\Theta(\log n)$ 的，具体看代码。

---
## 代码

从 $0$ 开始的下标证明蒟蒻是个 $\rm crab$。

```cpp
#include <bits/stdc++.h>
using namespace std;

//Start
typedef long long ll;
typedef double db;
#define mp(a,b) make_pair((a),(b))
#define x first
#define y second
#define be(a) (a).begin()
#define en(a) (a).end()
#define sz(a) int((a).size())
#define pb(a) push_back(a)
#define R(i,a,b) for(int i=(a),I=(b);i<I;i++)
#define L(i,a,b) for(int i=(b)-1,I=(a)-1;i>I;i--)
const int iinf=0x3f3f3f3f;
const ll linf=0x3f3f3f3f3f3f3f3f;

//Data
const int N=2e5;
int n,m,a[N],d[N];
vector<int> e[N];
void adde(int u,int v){e[u].pb(v),e[v].pb(u);}

//SegmentTree
const int T=2e7;
#define mid ((l+r)>>1)
int tn,ls[T],rs[T],mx[T];
int newn(){ls[tn]=rs[tn]=-1;return tn++;}
void pushup(int k){
    // mx[k]=mx[ls[k]]+mx[rs[k]]; 这里要考虑到空节点
    mx[k]=0;
    if(~ls[k]) mx[k]+=mx[ls[k]];
    if(~rs[k]) mx[k]+=mx[rs[k]];
}
void add(int&k,int x,int v,int l=0,int r=m){
    if(r<=x||x+1<=l) return; if(!~k) k=newn();
    if(r-l==1) return mx[k]+=v,void();
    add(ls[k],x,v,l,mid),add(rs[k],x,v,mid,r),pushup(k);
}
int find(int k,int v,int l=0,int r=m){
    if(!~k) return -1; if(v>mx[k]) return -1; if(r-l==1) return l;
    int t; if(~(t=find(rs[k],v,mid,r))) return t;
    else return find(ls[k],v-(~rs[k]?mx[rs[k]]:0),l,mid); //这里虽然递归了两条路径，但可以证明至少有一条是 O(1) 的
}
int sum(int k,int x,int l=0,int r=m){
    if(r<=x) return 0; if(!~k) return 0; if(x<=l) return mx[k];
    return sum(ls[k],x,l,mid)+sum(rs[k],x,mid,r);
}
int merge(int k,int p,int l=0,int r=m){
    if(!~k||!~p) return ~k?k:p; if(r-l==1) return mx[k]+=mx[p],k;
    ls[k]=merge(ls[k],ls[p],l,mid),rs[k]=merge(rs[k],rs[p],mid,r);
    return pushup(k),k;
}

//Tree
int rt[N];
void dfs(int u=0,int fa=-1){
    for(int v:e[u])if(v!=fa)
        dfs(v,u),rt[u]=merge(rt[u],rt[v]);
    int t=sum(rt[u],a[u]),p=find(rt[u],t+1);  //批量转移 dp
    add(rt[u],a[u],1),add(rt[u],p,-1);
}

//Main
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n;
    R(i,0,n) cin>>a[i],d[i]=--a[i];
    sort(d,d+n),m=unique(d,d+n)-d;
    R(i,0,n) a[i]=lower_bound(d,d+m,a[i])-d; // 是 d+m 不是 d+n，lower_bound 玄学函数要写准
    R(i,1,n){
        int fa; cin>>fa,--fa;
        adde(fa,i);
    }
    fill(rt,rt+n,-1),dfs();
    cout<<sum(rt[0],0)<<'\n';
    return 0;
}
```
---
**祝大家学习愉快！**

---

## 作者：Jμdge (赞：14)

遗憾地告诉大家，由于数据太随（shui）机这道题可以用一个 $n^2$ 的算法水掉（所以写启发式合并的有点凉）

而且这个 n^2 算法跑得贼快...（你看我记录就知道了=-=）

然鹅手造一组数据卡到 $ 80 S~^+$

~~第一次体验到了暴力碾标算的赶脚？~~

写题解就是想让管理加一下链的数据点（虽说可能性不大，因为这是省选原题...），然后顺便介绍一下这个复杂度为假的算法

~~emmm？ 这个算法的复杂度不是 $O(\text{能过})$ 么？~~


首先我们考虑将所有的点按权值从大到小（权值相同就按深度从大到小）加入树中，然后每个点暴力向上跑父节点，并且不断给该节点的 f 数组++，如果跑到某个节点发现之前访问过了就退出，并将该节点标记为未访问

那么这么做为什么是对的？

首先讲讲简单的情况：


$$2$$
$$/$$
$$5$$
$$/\text{}~~~~|$$
$$3 ~~~~~~~3$$


假设是这样一个树（LaTeX模拟棵树好累...）

然后我们考虑权值 5 的点会让权值 2 的点++（即 f[1] ++），然后权值 3 的点上去后发现权值 5 的点访问过了，那么取消它的访问，然后另一个权值 3 的点去访问的时候又让 f[1]++ 了，最后权值 2 的点让自身 ++ 

这时 f[1]=3   而答案确实也是 3

但这时候我们发现权值 5 的点的 f 值是假的，本来应该是 1 但现在是 2

其实这里利用到的想法就是 3 将 5 给取代掉了（类似一个启发式合并题解中的修改权值，并且被修改的点没有算贡献）

然后最后的答案必然是 f[1]

（有点蒙，写得自己都蒙了）

其实还是非常像启发式合并的...

少了个 log 多了个 n 嘛...

毕竟这个算法最优情况下是 $O(n)$ 的


```
//by Judge
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int M=2e5+3;
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline void cmax(int& a,int b){if(a<b)a=b;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,pat,ans,a[M],fa[M],d[M],head[M],f[M],v[M],dep[M];
struct Edge{ int to,nxt; }e[M<<1];
inline void add(int u,int v){
	e[++pat]=(Edge){v,head[u]},head[u]=pat;
}
inline bool cmp(int x,int y){
	return a[x]^a[y]?a[x]>a[y]:dep[x]>dep[y];
}
void dfs(int u){ dep[u]=dep[fa[u]]+1;
	for(int i=head[u];i;i=e[i].nxt) dfs(e[i].to);
}
void insert(int u){ ++f[u],v[u]=v[0]=1;
	for(u=fa[u];!v[u];u=fa[u]) ++f[u]; v[u]=0;
}
int main(){
	freopen("1.in","r",stdin);
	n=read();
	for(int i=1;i<=n;++i)
		a[i]=read(),d[i]=i;
	for(int i=2,x;i<=n;++i)
		fa[i]=read(),add(fa[i],i);
	dfs(1),sort(d+1,d+1+n,cmp);
	for(int i=1;i<=n;++i) insert(d[i]);
	return !printf("%d\n",f[1]);
}
```


不看代码是搞不懂哒 【雾


但其实这道题是道好题，不能就这么水过去了（还是要练练启发式合并）


## 复述一下题意：

给定一棵树，求树上最长不降子序列的元素个数（可以有枝条，即满足任意节点权值不小于其祖先节点权值）


首先我们考虑将题目中的问题转化

题意让我们求的是最长不降，那么我们考虑到在树上取点是不连续的，这就难搞了

但是我们可以给某个节点赋一个假权值，然后这个点不计贡献

## FAQ：这样做有什么用么？

当然有，这样的话我们就可以树形 dp 了啊！

那么考虑转移方程：

令 $f[i][j]$ 表示 i 号点权值为 j 时其子树的最大贡献（包括自身）
，则有

$$f[u][j]=[j=w[u]]\sum_{v∈u.son}Max(f[v][k],k>=j)$$

前面那个 j=w[u] 就是说 j 为 u 号点的初始权值

不难发现转移复杂度为 $n^3$， 按楼上大佬所说，我们可以计算后缀 Max 将复杂度优化为 $n^2$ ,虽然并没有什么软用，仅仅是将转移变成了这样：

$$f[u][j]=[j=w[u]] + \sum_{v∈u.son}Max[v][j] $$

$$Max[i][j] = Max(v[i][k],k>=j)$$


#### 然后我们发现：对于 j>w[u] ，Max[u][j] 所有的 Max[v][j] 之和

#### 且对于 j=w[u] ，Max[u][j] 为上面那玩意儿 +1

但是对于 j<w[u] 就需要 $O(n)$ 维护了，所以有什么优化的办法？


我们发现后缀 Max 数组可以差分，并且整个数组非负，且也满足可加性，这样我们记录下 u 号节点所有子节点的 Max 数组之和，其差分数组等于所有子节点 max 数组的差分数组之和

说的可能很绕，令 F 为差分数组的话，其实就是：

$$F[Max[v_1]+Max[v_2]+...+Max[v_n]]=F[Max[v_1]]+F[Max[v_2]]+...+F[Max[v_n]]$$

这样我们将差分数组维护起来的话其实就是将 Max 数组维护起来了

## FAQ: 这样做有什么好处？之前的问题有解决么？

当然有的，我们发现如果 F[i][j] 加上 1 对于整个差分数组的影响不过是 F[i][j-1] 需要 -1 罢了，并且如果 F[i][j-1] 等于 0 就不用减了，因为差分数组维护的是后缀 Max 信息，不会存在负数

这样我们就可以将 [ j=w[u] ] 对整个数组的影响降为 $O(1)$

但是还是有问题啊，这个 F 数组的合并是 $O~ n$ 的啊，复杂度还是假的！

那么我们考虑怎么把这个合并的复杂度降下来... 

之前不是说了启发式合并了嘛...并且由于这个 F 数组大部分的数为 0 ，我们可以考虑用 map 来记录 F 数组，为 0 的就不维护了，省时间省空间


然后我们最后输出答案的时候直接遍历一下 F 数组就好了

```
//by Judge
#include<map>
#include<cstdio>
#include<iostream>
#include<algorithm>
#define IT map<int,int>::iterator
using namespace std;
const int M=2e5+3;
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline void cmax(int& a,int b){if(a<b)a=b;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,pat,res,w[M],d[M],rk[M],head[M]; map<int,int> dp[M];
struct Edge{ int to,nxt; }e[M<<1];
inline void add(int u,int v){
	e[++pat]=(Edge){v,head[u]},head[u]=pat;
}
inline bool cmp(int x,int y){return w[x]<w[y];}
inline void merge(int p1,int p2){
	if(dp[p1].size()<dp[p2].size()) swap(dp[p1],dp[p2]);
	for(IT it=dp[p2].begin();it!=dp[p2].end();++it)
		dp[p1][it->first]+=it->second;
}
#define v e[i].to 
inline void dfs(int u){
	for(int i=head[u];i;i=e[i].nxt) dfs(v),merge(u,v);
	int fk=rk[u]-1; if(dp[u].begin()->first>fk) return ;
	IT it=dp[u].upper_bound(fk); --it;
	if(it->second==1) dp[u].erase(it); else --it->second;
}
int main(){ n=read();
	for(int i=1;i<=n;++i) w[i]=read(),d[i]=i;
	for(int i=2,f;i<=n;++i) f=read(),add(f,i);
	sort(d+1,d+1+n,cmp),rk[d[1]]=1;
	for(int i=2;i<=n;++i) rk[d[i]]=(w[d[i]]==w[d[i-1]]?rk[d[i-1]]:i);
	for(int i=1;i<=n;++i) ++dp[i][rk[i]]; dfs(1);
	for(IT it=dp[1].begin();it!=dp[1].end();++it)
		res+=it->second; return !printf("%d\n",res);
}
```




话说标算和暴力都好短...


---

## 作者：lndjy (赞：9)

给一个不用差分的线段树合并做法。

线段树合并优化 dp。

朴素 dp：设 $f[i][j]$ 表示 $i$ 子树，最大值为 $\ge j$ 的答案的最大值。

转移：$f[i][j]=\max(\sum f[v][j],\sum f[v][w[i]]+1)$，$v$ 为 $i$ 子树，$w[i]$ 为 $i$ 权值。

转移拆两步：

1.$f[i][j]=\sum f[v][j]$

2.$f[i][k](k\in[1,w[i]])=\max(f[i][k],\sum f[v][w[i]]+1)$

每个点用一个线段树维护第二维，第一步就是线段树合并，第二步就是线段树区间与 $x$ 取 $\max$，查询就只有单点查询。

然后我写了一发，TLE/MLE 40 pts。

然后我问了可爱的@王学逸 ，她告诉我合并时 pushdown 不能同时 pushdown 两个结点，存在一个节点没儿子的时候你就不能 pushdown。

如果一个结点没有儿子，它对应区间中所有位置上的数都相同。所以合并本质是区间加操作。维护区间加和区间推平这两个标记即可。具体细节可以见代码。

因为 wxy 帮我改了一下，所以代码内码风可能有不同。写了垃圾回收是因为一开始调的时候以为被卡空间了。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
const int N=2e5+5;
struct tree
{
	int lson,rson,sum,assign,add;
}t[N*20*5];
int tot,root[N];
int trash[N*22],top;
int getnode()
{
	if(!top) return ++tot;
	int x=trash[top--];
	t[x].lson=t[x].rson=t[x].sum=0;
	t[x].add=0;t[x].assign=-1;
	return x;
}
void pushdown(int k)
{
	if(!t[k].lson) t[k].lson=getnode();
	if(!t[k].rson) t[k].rson=getnode();
	if (t[k].add)
	{
	    t[t[k].lson].sum+=t[k].add;
	    t[t[k].rson].sum+=t[k].add;
	    t[t[k].lson].add+=t[k].add;
	    t[t[k].rson].add+=t[k].add;
	    t[t[k].lson].assign+=t[k].add;
	    t[t[k].rson].assign+=t[k].add;
	    t[k].add=0;
	} 
	if (t[k].assign != -1)
	{
	    t[t[k].lson].sum=max(t[k].assign,t[t[k].lson].sum);
	    t[t[k].rson].sum=max(t[k].assign,t[t[k].rson].sum);
	    t[t[k].lson].assign=max(t[k].assign,t[t[k].lson].assign);
	    t[t[k].rson].assign=max(t[k].assign,t[t[k].rson].assign);
	    t[k].assign=-1;
	}
	
}
void seg_add(int x,int v)
{
    t[x].sum+=v;
    if(t[x].assign!=-1) t[x].assign+=v;
    t[x].add+=v;
}
void assign(int x,int v)
{
   t[x].sum=max(t[x].sum,v);
   t[x].assign=max(v,t[x].assign);
}
int merge(int x,int y,int l,int r)
{
//	cout<<"merge";
	if(!x||!y) return x+y;
	if (!t[y].rson && !t[y].lson) swap(x,y);
    if (!t[x].lson && !t[x].rson)
	{
        seg_add(y,t[x].sum);
		return y;
    }
	if(l==r)
	{
		t[x].sum+=t[y].sum;
		t[y].sum=t[y].lson=t[y].rson=0;
		trash[++top]=y;
		return x;
	}
	int mid=l+r>>1;
	pushdown(x);pushdown(y);
	t[x].lson=merge(t[x].lson,t[y].lson,l,mid);
	t[x].rson=merge(t[x].rson,t[y].rson,mid+1,r);
	t[y].sum=t[y].lson=t[y].rson=0;
	trash[++top]=y;
	return x;
}
int change(int k,int l,int r,int L,int R,int x)
{
	if(!k) k=getnode();
	if(L<=l&&r<=R)
	{
		//t[k].sum=max(t[k].sum,x);
		assign(k,x);
		return k;
	}
	pushdown(k);
	int mid=l+r>>1;
	if(L<=mid) t[k].lson=change(t[k].lson,l,mid,L,R,x);
	if(mid<R) t[k].rson=change(t[k].rson,mid+1,r,L,R,x);
	return k;
}
int ask(int k,int l,int r,int x)
{
//	cout<<"ask"; 
	if(l==r) return t[k].sum;
	int ans=0;
	int mid=l+r>>1;
	pushdown(k);
	if(x<=mid) ans=max(ans,ask(t[k].lson,l,mid,x));
	else ans=max(ans,ask(t[k].rson,mid+1,r,x)); 
	return ans;
}
struct edge
{
	int to,nxt;
}e[N*2];
int head[N],n,cnt,w[N],X[N];
void add(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
void dfs(int now)
{
	int sum=0;
	for(int i=head[now];i;i=e[i].nxt)
dfs(e[i].to),sum+=ask(root[e[i].to],1,n,w[now]),root[now]=merge(root[now],root[e[i].to],1,n);
	root[now]=change(root[now],1,n,1,w[now],sum+1);
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>w[i];
		X[i]=w[i];
	}
	sort(X+1,X+n+1);
	int num=unique(X+1,X+n+1)-X-1;
	for(int i=1;i<=n;i++)
	w[i]=lower_bound(X+1,X+num+1,w[i])-X;
	for(int i=2;i<=n;i++)
	{
		int x;
		cin>>x;
		add(x,i);
	}
	dfs(1);
	cout<<ask(root[1],1,n,1); 
	return 0;       
}
```


---

## 作者：K8He (赞：8)

# 题解 P4577 [FJOI2018]领导集团问题

题解区好像没有线段树上又套了二分的做法，于是就有了这片题解。

[题目传送门](https://www.luogu.com.cn/problem/P4577)

[更好的阅读体验](https://www.cnblogs.com/Keven-He/p/solution-p4577.html)

~~怀着必 WA 的决心交了两发，一不小心就过了。~~

## 题意

求一个树上最长不下降子序列。

## 思路

首先考虑裸的 dp：设 $f_{u,j}$ 表示以 $u$ 为根的子树里选的数的最大值不小于 $j$ 能选多少个。

$$
f_{u,j}=
\begin{cases}
\sum_{v\ is\ u's\ son}f_{v,j} &j>w_u\\
\max\{\sum_{v\ is\ u's\ son}f_{v,j},\sum_{v\ is\ u's\ son}f_{v,j+1}+1\} &j\le w_u
\end{cases}
$$

接下来是如何优化：

在 DFS 每个节点的过程中，用权值线段树维护 $f_{u,j}$。

首先把所有儿子的权值线段树和起来。

然后考虑**在什么区间选上这个节点更优**。

右端点肯定是 $w_i$ ，那么我们二分求左端点，即**二分一个最小的选了比不选更优的点**。

单点查询用权值线段树，合并儿子们的树用线段树合并，区间修改用标记可持久化。

时间复杂度是 $O(nlog^2n)$。

~~虽然慢到起飞但是能过。~~

## 代码

```cpp
#include<bits/stdc++.h>
#define _for(i,a,b) for(int i=a;i<=b;++i)
#define for_(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
#define bdmd int mid=(l+r)>>1
using namespace std;
const int N=2e5+10,inf=0x3f3f3f3f;
int n,cnt,w[N];
vector<int>son[N];
inline int rnt(){
	int x=0,w=1;char c=getchar();
	while(!isdigit(c)){if(c=='-')w=-1;c=getchar();}
	while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*w;
}
namespace LISAN{
	int ls[N];
	void LiSan(){
		_for(i,1,n){
			ls[i]=w[i];
		}
		sort(ls+1,ls+n+1);
		cnt=unique(ls+1,ls+n+1)-ls-1;
		_for(i,1,n)
			w[i]=lower_bound(ls+1,ls+cnt+1,w[i])-ls;
		return;
	}
}
class ValSegmentTree{
 public:
	int root[N],tot,uucnt,un_use[N*40];
	class TREE{
	 public:
		int left_son,right_son;
		int val=0;
	}tree[N*40];
	const TREE NONE=(TREE){0,0,0};
	#define ls(p) tree[p].left_son
	#define rs(p) tree[p].right_son
	#define l_s(p) tree[p].left_son,l,mid
	#define r_s(p) tree[p].right_son,mid+1,r
	#define va(p) tree[p].val
	#define bdmd int mid=(l+r)>>1
	inline int NewP(){
		if(uucnt)
			return un_use[uucnt--];
		return ++tot;
	}
	inline void DeleteP(int p){
		tree[p]=NONE;
		un_use[++uucnt]=p;
		return;
	}
	void UpdateQJ(int &p,int l,int r,int le,int ri,int val){
		if(!p)p=NewP();
		if(ri<l||r<le)return;
		if(le<=l&&r<=ri)
			va(p)+=val;
		else{
			bdmd;
			UpdateQJ(l_s(p),le,ri,val);
			UpdateQJ(r_s(p),le,ri,val);
		}
	}
	int QueryP(int p,int l,int r,int x){
		if(!p)return 0;
		if(l==r)return va(p);
		else{
			bdmd;
			if(x<=mid)
				return va(p)+QueryP(l_s(p),x);
			else
				return va(p)+QueryP(r_s(p),x);
		}
	}
	void Merge(int &p1,int p2){
		if(!p1){p1=p2;return;}
		if(!p2){return;}
		va(p1)+=va(p2);
		Merge(ls(p1),ls(p2));
		Merge(rs(p1),rs(p2));
		DeleteP(p2);
		return;
	}
	#undef ls
	#undef rs
	#undef l_s
	#undef r_s
	#undef va
}tr;
void Dfs(int u,int father){
	int sz=son[u].size();
	_for(i,0,sz-1){
		int v=son[u][i];
		if(v==father)continue;
		Dfs(v,u);
		tr.Merge(tr.root[u],tr.root[v]);
	}
	int xuan=tr.QueryP(tr.root[u],1,cnt,w[u]+1)+1;
	int l=1,r=w[u];
	while(l<=r){
		bdmd;
		if(tr.QueryP(tr.root[u],1,cnt,mid)>=xuan)
			l=mid+1;
		else
			r=mid-1;
	}
	tr.UpdateQJ(tr.root[u],1,cnt,l,w[u],1);
	return;
}
int main(){
	n=rnt();
	_for(i,1,n)w[i]=rnt();
	LISAN::LiSan();
	_for(i,2,n){
		int x=rnt();
		son[i].push_back(x);
		son[x].push_back(i);
	}
	Dfs(1,0);
	printf("%d\n",tr.QueryP(tr.root[1],1,n,1));
	return 0;
}
```

---

## 作者：Calculatelove (赞：6)

[Luogu P4577](https://www.luogu.com.cn/problem/P4577)。

## Description

给出一棵大小为 $n$ 的树，第 $i$ 个节点的权值为 $w_i$。

你需要选出一个最大的节点集合，使得对于节点集合中不同的两个点 $i, j$，若 $i$ 为 $j$ 的祖先节点，必须满足 $w_i \leq w_j$。

数据范围：$1 \leq  n \leq 2 \times 10^5$，$1 \leq w_i \leq 10^9$。  
时空限制：$1000 \ \mathrm{ms}/ 250 \ \mathrm{MiB}$。

## Solution

提供一种类似 [[NOI2020] 命运](https://www.luogu.com.cn/problem/P6773) 的整体 dp 做法。

考虑 dp。记 $f(u, i)$ 表示：在子树 $u$ 中选出的节点集合的 $w$ 最小值为 $i$ 的情况下，最大的节点集合的大小。有两种转移：

- 节点集合不包括 $u$（要保证 $f(u, i)$ 至少有一个 $f(v, i)$ 的转移）。

$$
f(u, i) \gets \sum\limits_{v \in \mathrm{son}(u)} \max\{f(v, \geq i)\}
$$

- 节点集合包括 $u$。

$$
f(u, w_u) \gets 1 + \sum\limits_{v \in \mathrm{son}(u)} \max\{f(v, \geq w_u)\}
$$

考虑线段树合并优化，在一棵维护子树 $u$ 的线段树中，代表区间 $[l, r]$ 的节点需要维护在子树 $u$ 中选出的节点集合的 $w$ 最小值在区间 $[l, r]$ 中的情况下，最大的节点集合的大小，即 $\max\limits_{l \leq i \leq r} f(u, i)$。

转移 1 即为整体 dp 的重点，在线段树合并的过程中计算。具体地，在合并线段树 `p, q` 的过程中，设当前合并到了代表区间 `[l, r]` 的节点，在递归的过程中记录 $\max\limits_{i > r} \{f(u, i)\}$ 与 $\max\limits_{i > r} \{f(v, i)\}$ 并分别记作 `maxp, maxq`。将情况分成以下五类讨论：

- 当 $p = 0, q = 0$ 时：返回空节点 $0$ 即可。
- 当 $p \neq 0, q = 0$ 时：此时相当于对 $p$ 内做一次区间加 `maxq`，打上懒标记后返回 $p$ 即可。
- 当 $p = 0, q \neq 0$ 时：此时相当于对 $q$ 内做一次区间加 `maxp`，打上懒标记后返回 $q$ 即可。
- 当 $l = r$ 时：此时递归到了一个叶子节点，有 $f'(u, l) = \max(\mathtt{maxp}, f(u, l)) + \max(\mathtt{maxq}, f(v, l))$。
- 当 $p \neq 0, q \neq 0$ 时：此时需要先合并 $p, q$ 的左右儿子，再以通过左右儿子上传信息。

> 特别要注意的是，区间加不用也不能对空节点打标记，因为空节点不能保证 $f(u, i)$ 至少有一个 $f(v, i)$ 的转移。

转移 2 即为平凡的区间查询最大值，单点修改。

时间复杂度 $\mathcal{O}(n \log w)$，空间复杂度 $\mathcal{O}(n \log w)$。

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>

template <class T>
inline void read(T &x) {
	static char s;
	while (s = getchar(), s < '0' || s > '9');
	x = s - '0';
	while (s = getchar(), s >= '0' && s <= '9') x = x * 10 + s - '0';
}

const int N = 200100;
const int sup = 1e9;

int n;
int a[N]; 

int tot, head[N], ver[N], Next[N];
void add_edge(int u, int v) {
	ver[++ tot] = v;    Next[tot] = head[u];    head[u] = tot;
}

namespace SGT {
	const int pond = 10001000;

	int nClock, root[N];
	struct node {
		int lc, rc;
		int max;
		int add;

		void mk_add(int x) {
			max += x;
			add += x;
		}
	} t[pond];

	void spread(int p) {
		if (t[p].add) {
			if (t[p].lc) t[t[p].lc].mk_add(t[p].add);
			if (t[p].rc) t[t[p].rc].mk_add(t[p].add);
			t[p].add = 0;
		}
	}

	void insert(int &p, int l, int r, int x, int val) {
		if (!p) p = ++ nClock;
		t[p].max = std::max(t[p].max, val);
		if (l == r) return;

		spread(p);
		int mid = (l + r) >> 1;

		if (x <= mid)
			insert(t[p].lc, l, mid, x, val);
		else
			insert(t[p].rc, mid + 1, r, x, val);
	}

	int ask(int p, int l, int r, int s, int e) {
		if (s <= l && r <= e) return t[p].max;

		spread(p);
		int mid = (l + r) >> 1;
		int cur = 0;

		if (s <= mid)
			cur = std::max(cur, ask(t[p].lc, l, mid, s, e));
		if (mid < e)
			cur = std::max(cur, ask(t[p].rc, mid + 1, r, s, e));

		return cur;
	}

	int merge(int p, int q, int l, int r, int maxp, int maxq) {
		if (!p && !q) return 0;
		if (p && !q) return t[p].mk_add(maxq), p;
		if (!p && q) return t[q].mk_add(maxp), q;
		if (l == r)
			return t[p].max = std::max(t[p].max, maxp) + std::max(t[q].max, maxq), p;

		spread(p), spread(q);
		int mid = (l + r) >> 1;

		t[p].lc = merge(t[p].lc, t[q].lc, l, mid,
			std::max(t[t[p].rc].max, maxp), std::max(t[t[q].rc].max, maxq));
		t[p].rc = merge(t[p].rc, t[q].rc, mid + 1, r, maxp, maxq);
		t[p].max = std::max(t[t[p].lc].max, t[t[p].rc].max);

		return p;
	}
}

void dp(int u) {
	int val = 1;
	for (int i = head[u]; i; i = Next[i]) {
		int v = ver[i];
		dp(v);

		val += SGT::ask(SGT::root[v], 1, sup, a[u], sup);
		SGT::root[u] = SGT::merge(SGT::root[u], SGT::root[v], 1, sup, 0, 0);
	}

	SGT::insert(SGT::root[u], 1, sup, a[u], val);
}

int main() {
	read(n);

	for (int i = 1; i <= n; i ++) read(a[i]);

	for (int i = 2, fa; i <= n; i ++) {
		read(fa);
		add_edge(fa, i);
	}

	dp(1);

	printf("%d\n", SGT::t[SGT::root[1]].max);

	return 0;
}
```

---

## 作者：shadowice1984 (赞：6)

怎么各位julao都写的线段树合并啊……

然而启发式合并跑的飞起，$O(nlog^2n)$甚至跑的比一些常数大的$O(nlogn)$的线段树合并还快……
__________________

## 本题题解

首先翻译一下并不是很好理解的题意

给你一棵有根树，让你从这棵树当中选取一个点集，使得对于在这个点集中的每一个点，它的点权都大于它的每一个被选中的祖先。

为了方便起见我们将点权离散化……

然后我们发现这个问题有点像树上的最长上升子序列问题……，但是我们并不会做子序列的问题，因为在我们点集中的点在树上不一定相邻，但是我们的树形dp是要求一定是孩子和父亲进行转移才可以进行列dp定义和推dp方程的，所以我们考虑转化一下这个问题，使得它变成一个可爱的树上的联通块问题……

假设我们选取了树上的一个点集，那么我们可以通过适当的向点集中添加一些额外的点来将这个点集变成一个联通块，那么问题来了，这个被我们强行构造出的联通块可能不符合任意一个点集中的点都大于它的每一个被选中的祖先这个条件……

但是显然原来就在点集中的点是符合的这个条件的，我们破坏了这个约束是因为我们新加入的点破坏了原来的点权关系，因此我们就将这些点的点权强行赋成一个合适的值，使得重新赋值之后这个联通块满足点权的约束关系(可以证明这样的转化方式一定存在)

现在就是我们坠喜欢的联通块问题了！

因此我们可以列出这样的一个dp式子$dp_{i,j}$表示联通块中最高点为i，且i取为j的点权时，联通块中未被篡改点权点数的最大值

那么根据树形dp的一般套路我们考虑孩子和父亲之间的转移问题，考虑我们现在决策到了第v棵子树，现在要把这颗子树加到它的父亲u的联通块中的情况

那么我们发现$(u,j)$和$(v,k)$这两个点之间能放在同一个联通块当中当且仅当$j<=k$

那么我们可以推出这样的状态转移方程

## $Dp_{u,j}+=Max_{k=j}^{n}Dp_{v,k}$

意义是我们枚举所有合法的连边情况在所有的连边方案当中取max

初始条件每个点的$Dp_{i,w_{i}}=1$其他dp项全部为0

直接暴力转移复杂度是$O(n^3)$通过预处理这个数组的后缀max数组的方式我们可以将复杂度降到$O(n^2)$但是问题来了我们的数据范围是$10^5$因此这点优化完全没用

发现复杂度在转移上，所以我们考虑一下如何优化这个东西

我们发现转移一整个数组的过程相当于于把每个u孩子v的dp数组的后缀max数组按位相加之后最后把u的原始dp数组和这个数组按位相加。

如果你足够熟练的话数组按位相加这个操作应该难不住你，但是你会面临一个十分辣手的操作——求后缀max数组

假如你是一名即将ak的julao，闲来无事打印出了这个dp数组的差分数组

那么我们考虑把这个数组进行后向差分，那么原数组按位相加相当于差分数组按位相加

下面我们考虑求后缀max数组的操作，发现一个有趣的性质，对于一个后向差分全部非负的数组，它的后缀max数组和原数组一样……，而且后缀max数组一定是差分全正的……

因此我们得出这样一个结论，【各个孩子的】【后缀max数组的】和数组【的差分】一定也是全正的

那么我们发现一件很有意思的事情，只有加入了u的数组之后这个数组才有可能出现负差分的现象，此时我们求后缀max数组才有意义，如果同时出现了多个负点我们将会非常难受，但是问题来了，这个差分数组最多有几个负点呢？

显然负点只能来自和u的数组按位相加这个操作

但是注意到我们变换了转移顺序，先加完了所有儿子，最后考虑u，因此我们的u数组还是边界条件状态……

也就是说一堆0里有一个1

换句话说它的差分数组就是一个1紧贴着一个-1

所以u数组做完按位相加之后这个东西里面最多有一个负点

考虑插入这个-1的时候会发生什么

如果加到了一个正的差分上加完之后差分数组非负所以不用管

很不幸的加到了0点上我们可能需要考虑一下如何处理这个-1差分

显然会让插入之后的数组"下沉"一个单位，此时我们取后缀max导致了这个下沉的部分会有一部分被这个-1前面的位置“填平”

那么由于下沉的高度只有1，因此被填平的区间就是这个-1的位置到这个-1前面的第一个非零差分的位置，然后由于这个位置被填平了1，因此这个前驱需要-1，然后剩余的差分并不改变

如果前驱不存在的话那么所有点都将被填平，所以这个-1白插了

那么我们看一看现在我们需要兹瓷什么操作……

数组按位相加，找数组里某一个位置之前第一个非0位置

找前驱map即可

什么？你说按位相加？暴力启发式合并，把小的map中的元素一个一个加入到大的map当中复杂度$O(nlog^2n)$

所以我们就用一个map愉快的做完了这道题

(其实找前驱和按位相加可以使用权值线段树合并做到更优秀的复杂度，但是我懒得写了QAQ)

代码很好写~

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<map>
using namespace std;const int N=2*1e5+10;int n;int tot;
map <int,int> dp[N];int res;
int v[N];int x[N];int al[N];int ct;int w[N];int lsh[N];int rk[N];
inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}
inline bool cmp(int a,int b){return w[a]<w[b];}
inline void merge(int p1,int p2)//暴力启发式合并 
{	
	if(dp[p1].size()<dp[p2].size())swap(dp[p1],dp[p2]);
	map <int,int>::iterator it;
	for(it=dp[p2].begin();it!=dp[p2].end();++it){dp[p1][it->first]+=it->second;}
}
inline void dfs(int u) 
{
	for(int i=al[u];i;i=x[i]){dfs(v[i]);merge(u,v[i]);}//加一下所有孩子 
	int fk=rk[u]-1;if(dp[u].begin()->first>fk)return;//找前驱 ,lower_bound之后--迭代器即可 
	map <int,int>::iterator it=dp[u].lower_bound(fk);if(it->first!=fk)--it;
	if(it->second==1){dp[u].erase(it);}else it->second--;//记得判一下如果是1的话减法改成erase 
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&w[i]);
	for(int i=2,f;i<=n;i++){scanf("%d",&f);add(f,i);}
	for(int i=1;i<=n;i++)lsh[i]=i;sort(lsh+1,lsh+n+1,cmp);//离散化 
	rk[lsh[1]]=1;for(int i=2;i<=n;i++)rk[lsh[i]]=(w[lsh[i]]==w[lsh[i-1]])?rk[lsh[i-1]]:i;
	for(int i=1;i<=n;i++)dp[i][rk[i]]++;dfs(1);map <int,int>::iterator it;
	for(it=dp[1].begin();it!=dp[1].end();++it){res+=it->second;}//加上所有的差分就可以还原原数组的最大值 
	printf("%d",res);return 0;//拜拜程序~ 
}
```

---

## 作者：i207M (赞：4)

为啥dalao们写的都是$O(n\log ^2n)$的dp什么的...明明排序后贪心是对的啊...还是先讲一边DP

## DP

很容易写出$O(n^2)$的转移方程，设$dp[x][i]$表示x子树，选择的最小权值$\ge v$的最优解。

然后发现形如：把子树的dp值对应加起来，然后取一个前缀max来修改。

~~这不是整体DP（线段树合并）的板子吗~~

但是我们要写的爽！

发现这是一个取前缀max的dp，我们可以维护它的后向差分数组。那么对于一个点，相当于在w[x]处差分数组+1，在差分数组中w[x]的前驱处-1，这可以很方便的用map实现。

代码极其好写。

```cpp
void dfs(int x)
{
	for(solid v:sn[x])
	{
		dfs(v);
		if(Size(dp[v])>Size(dp[x])) dp[x].swap(dp[v]);
		for(solid it:dp[v])
			if(!(dp[x][it.fi]+=it.se)) dp[x].erase(it.fi);
	}
	++dp[x][w[x]];
	auto it=dp[x].lower_bound(w[x]);
	if(it!=dp[x].begin())
		if(!--(--it)->se) dp[x].erase(it->fi);
}
```

## 贪心

（讲道理如果你为了追求复杂度，是需要写一个数据结构来进行下面说的查找的，但事实上直接暴力跳fa就非常快，甚至排进rk前3（不是我写的，别人写的）

我们直接维护选择的点的集合。我们把点按w从大到小排序，相同的按照深度从大到小考虑。

对于每一个点，我们找到它最深的被选择的祖先，如果没有，那么就选它，答案+1；否则，不选择它的祖先，选择它。

这是因为后面的点w都更小。我们选择的点集自然越深越好。

你可能会发现一个小锅：假如点x有两个祖先y和z$(dep[y]>dep[z])$都被选择，那么理论上是不能不选y，选x的。但是我们这样考虑：如果最终答案不包含z，比方说p顶替了z，那么这时候就不会冲突了；如果答案包含z，说明z的子树里没有新点了，那么这次“错误的”选择不会影响答案的值（无论选y还是选x，答案都不变）

---

## 作者：Coros_Trusds (赞：3)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/16071315.html)

# 题目大意

求树上最长不上升子序列的长度。

# 题目分析

不妨先想想序列上的解决方法，再将序列上的方法移植到树上来。

序列上的最长不上升子序列问题：

我们有 $\mathcal{O(n^2)}$ 的无脑动态规划做法，可以优化到 $\mathcal{O(n\log n)}$。每一次尽量选与答案序列的上一个数相近的数。比如说 `5 4 1`，如果又有一个 $3$ 在后面，那么可以拿 $3$ 替换 $1$：`5 4 3`，这样如果后面再出现一个 $2$ 也可以加入答案序列中。

扩展到树上：

维护 $f_i$，表示以点 $i$ 为根节点的子树内的最长不上升子序列，注意 $f_i$ 是一个序列。因为子树相互独立，所以可以进行合并。

实现时，我们把每一个数的**相对大小**取反，然后插入一个数时找到大于等于这个数的数 $x$，将 $x$ 删掉，插入当前数即可。最后答案即为 $f_1$ 的长度。

# 代码

```cpp
//2022/3/29
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#include <set>
#define enter putchar(10)
#define debug(c,que) cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) cout << arr[i] << w;
#define speed_up() cin.tie(0),cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define Abs(x) ((x) > 0 ? (x) : -(x))
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;
using namespace std;

const int N = 2e5 + 5;
struct Gragh {
	int v,nxt;
} gra[N << 1];
int a[N],head[N];	
multiset<int>st[N];
int n,idx;
inline void add(int u,int v) {
	gra[++ idx].v = v,gra[idx].nxt = head[u],head[u] = idx;
}
inline void merge(int x,int y) {
	if (st[x].size() < st[y].size()) swap(st[x],st[y]);
	for (multiset<int>::iterator it = st[y].begin();it != st[y].end(); ++ it) {
		st[x].insert(*it);
	}
}
inline void dfs(int now,int fath) {
	for (register int i = head[now];i;i = gra[i].nxt) {
		int v = gra[i].v;
		if (v != fath) {
			dfs(v,now);
			merge(now,v);
		}
	}
	multiset<int>::iterator it = st[now].lower_bound(a[now]);
	if (it != st[now].end()) st[now].erase(it);
	st[now].insert(a[now]);
}
int main(void) {
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	n = read();
	for (register int i = 1;i <= n; ++ i) a[i] = 1e9 - read();
	for (register int i = 2;i <= n; ++ i) {
		int x = read();
		add(i,x),add(x,i);
	}
	dfs(1,0);
	printf("%d\n",st[1].size());
	
	return 0;
}
```

---

## 作者：SoloRejudger (赞：3)

本人表示并不知道树上LIS问题。。。

我也只能连猜带蒙地口胡，讲出一个仿佛是正解的东西，正确性未知

题目叫我们在一棵树中选出尽可能多个点，使得每一个点的点权小于其祖先的点权

想到离散化，考试时在想，我们能不能将它转化成一个联通块，通过树dp解决呢？

对于40分的做法：设k为i的一个子节点

因为对于每个点i，k仅有一个权值，对于i来说，k可选可不选

于是我们想到修改权值，强行把k的权值进行修改，

使得满足每一个点的点权小于其祖先的点权（这一步需要点灵感）

设dpi,j为在以i为子树的点集里，当i的权值（离散化后）被修改成j时，

选出最多子集的点数（也就等同于没有被修改过的点的数量）

初始化条件为dpi,wi=1

依次地合并子树，因为dpi,j能与dpk,l合并时仅当j<=l，于是树dp方程为：

dpi,j+=Maxnl=jdpk,l​，想到后缀最大值数组，优化到O(n2)

于是考试时就卡这了

对于100分的做法：

其实，我们把我们所做的几件事列一列：

1.初始化dpi,wi=1

2.依次对每个子节点累加最大值

3.计算后缀最大值数组

void dfs(R int u) {
        f[u][w[u]] = 1;//1
        for(R Edge *i = la[u]; i; i = i->ne) {
            R int to = i->v; dfs(to);
            for(R int j = 1; j <= P; ++j) f[u][j] += g[to][j];//2
        }
        for(R int i = P; i >= 1; --i) g[u][i] = Max(g[u][i + 1], f[u][i]);//3
 }

考虑一直迭代搜索到叶节点，观察修改dp数组的只有1操作

一开始数组是这样的：

0 0 0 ..... 0 0 0

经过1操作:0 0 0 0.....1 0 0 ..... 0 0 0

经过3操作:0 0 0 0.....1 1 1 ..... 1 1 1 //忽略了2

在逐渐取最大值是，发现g一定是递增的（并不严格）

于是想到差分数组，就等同于在w[i]这个位置插入一个1，其他仍是0

由于差分数组的性质，答案就等同于全部位置之和相加

再模拟取最大值的过程，原来的g数组是0 0 0 .... 0 1 1 1 1

再插入一个变成0 0 0 ... 1 1 1... 1 1 1 ，

实际上这个操作的本质的问题，就是把i到i前的数直接的0变成1

在差分数组上的操作就是++t[i];--t[pre[i]];

但如果i之前没有数的话，就不用--t[pre[i]]了

于是我们考虑用一个multiset维护序列，每次插入值，

合并的过程中运用启发式，取最大值时找到他的前驱把它删掉，

最后答案即为还留在multiset中剩余的数的数量

完了

---

## 作者：Sakura_梦瑶 (赞：1)

刚学oi 刚接触线树合并,不会算空间.单看一条链是很裸的最长非升子序列问题,但是树上问题需要维护信息.我们考虑nlog做法情况下的链做法,我们需要维护一个数组供我们操作.而树上问题往往需要往合并方向想,或者换根维护,这是最基本的思路.这道题根已经确定,不需要换根,子树之间不产生互相约束,所以合并是合法的,而合并手法则使用线段树合并.
而答案就是最终以根为辅助数组的size.讲真线段树合并空间好难控制.
代码如下
```
#include<bits/stdc++.h>
#define N 4001000
#define left l,mid,ls[pos]
#define righ mid+1,r,rs[pos]
using namespace std;bool flag;
int las[N],to[N],nxt[N],a[N],num[N*2],ls[N*2],rs[N*2],rt[N],n,cnt,d;
void de(int x){if(!x)return;num[x]--;if(num[rs[x]])de(rs[x]);else de(ls[x]);}
void sak_tr(int l,int r,int &pos){
	if(!pos)pos=++cnt;num[pos]++;if(l==r)return;int mid=l+r>>1;
	if(mid<d){sak_tr(righ);if(!flag&&num[ls[pos]])de(ls[pos]),flag=1;}
	else sak_tr(left);if(flag)num[pos]--;
}
void sak_me(int &pos,int &p){
	if(!p||!pos){pos+=p;return;}num[pos]+=num[p];
	sak_me(ls[pos],ls[p]),sak_me(rs[pos],rs[p]);
}
void sak_dfs(int x,int fa){
	for(int i=las[x];i;i=nxt[i])if(to[i]!=fa)
	 sak_dfs(to[i],x),sak_me(rt[x],rt[to[i]]);
	flag=0,d=a[x],sak_tr(0,1e9,rt[x]);
}
main(){
	cin>>n;for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1,j=2,c=n*2-2;i<=c;i+=2,j++)scanf("%d",&to[i]),to[i+1]=j,
	 nxt[i]=las[j],las[j]=i,nxt[i+1]=las[to[i]],las[to[i]]=i+1;
	sak_dfs(1,1),cout<<num[rt[1]];
}
```


---

## 作者：zzw4257 (赞：0)

> 给定一棵有根树，求一个最大的子集(不一定联通)，使得子集满足性质,$\forall(x,y),x$是$y$的子孙都有$v_x\geqslant v_y$

#### $40~pts'$

我们只用知道子树内的最小元素就可以看$x$这个点取不取了

因此设$f_{x,K}$表示以$x$为根(但$x$可不取)，子树内最小权值权值$\geqslant K$的最大子集

对最值设至少不设刚好的原因是你发现权值是离散的，一个值选了会影响一个范围的选取，我们只用最值范围可以方便转移中的缩放

然后可以快速转移如下
$$
f_{x,K}=[a_x\leqslant K]+\sum_{y}f_{y,K}
$$
注意到存在至少这个关键字眼需要求前缀$\max$,无法直接数据结构优化

```cpp
inline void dfs(int x){
	int i;
	for(int y:g[x]){
		dfs(y);
		for(i=1;i<=len;++i)f[x][i]+=f[y][i];
	}++f[x][a[x]];for(i=len-1;i;--i)f[x][i]=max(f[x][i],f[x][i+1]);
}
```



#### $100~pts'$

你发现上面的式子$\mathcal O(n^2)$的瓶颈和$LIS$是一样的，我们需要去枚举这样大小关系再去转移吗

两种解决方案

- 把大小关系变成值域划分后区域求最值$\Rightarrow $树状数组优化$LIS$,现在要求前缀$\max$,在树上我们直接线段树合并即可(想一想差分)
- 考虑一种贪心方案，我们让子树内最小点权尽量大，为新来的点留位置$\Rightarrow$二分优化$LIS$,现在我们依然二分，然后因为多线程合并采用启发式合并套一个有序的结构$multiset$即可

实现上$F_x$表示$x$为根子树内点值最小值最大的集合

```cpp
inline void dfs(int x){
	int i;
	for(int y:g[x])dfs(y),Merge(f[x],f[y]);
	auto it=(f[x].insert(a[x]),f[x].lower_bound(a[x]));if(it!=f[x].begin())f[x].erase(--it);
}
```

---


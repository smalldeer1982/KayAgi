# [FJOI2015] 世界树

## 题目描述

奥丁杀死巨人伊米尔后，从伊米尔的尸体上生长出来一株巨大的梣树，它是整个宇宙的核心，被称为世界之树，这个巨木的枝干构成了整个世界，它被神秘的奥术力量所守护。

奥丁发现，世界树的每个节点至多有两棵子树，其蕴含的奥术力量是子树奥术力量的最大值 $+1$，如果一个节点没有子树，其奥术力量为 $1$，这些节点被称为“源”。

世界树在悠长的岁月里形成了奇妙的魔法平衡，具体来说，它的左子树与右子树的奥术力量的差的绝对值不会超过 $1$。若一个节点只有一棵子树（不妨设为左子树），则右子树的奥术力量视为 $0$。

现在奥丁想知道，在 $n$ 个节点的世界树中，最高和最低的两个“源”（即叶子节点）的深度差最大是多少？

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 10^{10000}$，$T\leq 50$。

## 样例 #1

### 输入

```
2
5
12345```

### 输出

```
1
9```

# 题解

## 作者：shadowice1984 (赞：12)

一句话题意:求节点数为n的avl树叶子深度之差的最大值是多少

为了方便起见我们深度为这个点到树根路径上点的个数而不是边的个数

如果你仔细看过算法导论的话你会发现习题上有一个题是让你证明为什么深度为$i$的avl至少有$\sum_{p=1}^{i}fib(p)$个节点

其实没什么稀奇的，就是普通的$dp$,$dp(i)$深度为i的avl树的最少节点数目，我们至少会得出这样一个结论就是这个数组是单调的，那么有了这个性质我们就可以列一个dp出来，$dp(i)=dp(i-1)+dp(i-2)+1$接下来运用van能的数学归纳法♂我们就可以证明这个数组就是fibonacci数组的前缀和数组了

接下来我们会发现这样构造出来的树同样是叶子深度差最大的树，为了证明这点我们只需要证明这样构造出来的树最小深度同样最小就行了，你同样可以使用van能的数学归纳法♂来证明这个命题，你还可以列一个dp式子$mindep(i)=min(mindep(i-1)+mindep(i-2))+1$来解决这个问题

然后我们大力猜想一波对于一个有n个节点的avl树来讲如果$dp(i) \leq n \le dp(i+1)-1$，那么n的答案应该和有$dp(i)$个节点的树是一样的

那这么说来我们只需要将询问读进来排个序,写个暴力压位高精吧每个dp的值刷出来就行啦？

然后你高兴的写了这个程序交上去发现wa的连姥姥都不认……

为什么呢？

试试6？显然答案是0因为此时唯一合法的avl树是一个完全二叉树,不过你的程序会输出1

情况开始变得辣手……

于是你把6特判了之后交了上去发现ac了本题……

为什么呢？

因为6是唯一的反例

证明的话你考虑如果不动最浅的叶子的话我们最多可以向这棵avl树中插入几个节点，通过打表发现只有6的时候我们必须在最浅的叶子中插入节点，其他的时候我们总是有多余的空隙插入多余的节点

所以这题就是写个压位高精就没了……

下面的代码有锅，会在数字后18位为000000000000000006的且这个数字不是6的时候wa掉，想改也很简单，不过这里懒得改了

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
using namespace std;const int S=560;const int N=1e4+10;typedef unsigned long long ull;
const ull mod=1e18;const int biot=18;
struct bigi//压位高精
{
    ull s[S+5];
    inline ull& operator [](const int& x){return s[x];}
    friend bigi operator +(bigi a,bigi b)
    {
        bigi c;ull sum=0;
        for(int i=1;i<=S;i++)sum+=a[i]+b[i],c[i]=sum%mod,sum/=mod;return c;
    }
    friend bool operator <(bigi a,bigi b)
        {for(int i=S;i>=1;i--)if(a[i]!=b[i])return a[i]<b[i];return false;}
    friend bool operator <=(bigi a,bigi b)
        {for(int i=S;i>=1;i--)if(a[i]!=b[i])return a[i]<b[i];return true;}
    inline void inc(){for(int i=1;i<=S;i++){s[i]++;if(s[i]!=mod)break;else s[i]=0;}}
}ret[3],qr[55];int T;char mde[N];int mdp[3];int ans[55];
int main()
{
    scanf("%d",&T);
    for(int i=1;i<=1e4;i++)mde[i]='0';//排序
    for(int i=1;i<=T;i++)//压位
    {
        scanf("%s",mde+1);int len=1;for(;mde[len+1]!='\0';len++);
        reverse(mde+1,mde+len+1);mde[len+1]='0';
        for(int s=1,t=1;s<=len;s+=biot,t++)
        {
            ull ret=0;
            for(int j=s+biot-1;j>=s;j--)
                ret*=10,ret+=mde[j]-'0';qr[i][t]=ret;
        }
        for(int j=1;j<=len;j++)mde[j]='0';qr[i][S+1]=i;
    }sort(qr+1,qr+T+1);//排序
    int tp=1;ret[1][1]=1;mdp[0]=mdp[1]=1;
    for(int i=1;i<=T;i++)
    {
        while(ret[tp%3]<=qr[i])
        {
            tp++;ret[tp%3]=ret[(tp-1)%3]+ret[(tp-2)%3];ret[tp%3].inc();
            mdp[tp%3]=min(mdp[(tp-1)%3],mdp[(tp-2)%3])+1;
        }ans[qr[i][S+1]]=(tp-1)-mdp[(tp-1)%3];
        if(qr[i][1]==6)ans[qr[i][S+1]]=0;
    }for(int i=1;i<=T;i++)printf("%d\n",ans[i]);return 0;//拜拜程序~
}
```















---

## 作者：Supor__Shoep (赞：1)

~~咱们看到了数据范围之后，不要畏惧，因为这说明正解是一个结论，推出结论再套一个高精咱们就胜利啦！！！~~

首先可以判断需要贪心，就是说我们要尽可能保证多的点，满足其左右子树的最大深度相差 $1$。

从大局观入手，我们现在得到树根 $r$，其左右儿子分别为 $l,r$，令 $l$ 子树中的最大深度 $\leq$ $r$ 子树中的最大深度，且此时的树是一个最优解。不难想到这是一个分而治之的过程：即满足了 $|dis_l-dis_r|\leq 1$ 的条件过后，再在左右子树进行分治，重复以上过程。

由此就可以想到，设 $dp_i$ 表示深度为 $i$ 时满足题目条件的树的最小点数。考虑转移，首先要满足深度为 $i$ 那么必定有一个子树为 $dp_{i-1}$，而还要保证点数最小且 $|dis_l-dis_r|\leq1$，那么另外一个子树就是 $dp_{i-2}$，再加上根节点，转移就是：

$$dp_i=dp_{i-1}+dp_{i-2}+1$$

初始化：$dp_1=1,dp_2=2$。

那么我们就可以得到 $n=dp_i$ 时的答案了，就是 $\lfloor \dfrac{i+1}{2}\rfloor-1$。

接着我们就可以尝试拓展到其它 $n$ 的答案。对于 $n\in [dp_i,dp_{i+1})$，我们肯定是考虑保持 $\lfloor \dfrac{i+1}{2}\rfloor-1$ 这个答案，即先构造出 $n=dp_i$ 的最优的树，然后在上面添加 $n-dp_i$ 个节点，尽可能不改变叶子节点的高度极差。不难发现仅有 $n=6$ 的时候无法保持 $n=dp_3=4$ 时候的答案，而其余的都满足最终答案为 $n=dp_i$ 时的答案。

因此我们求出 $dp_i$ 数组，然后找到 $i$ 满足 $n\in[dp_i,dp_{i+1})$，如果 $n≠6$，则输出 $\lfloor \dfrac{i+1}{2}\rfloor-1$，否则特判答案为 $0$。

由于 $n$ 太大力，因此我们需要一个高精度的数组。通过打表找到最大的 $i$ 接近于 $5\times 10^4$，然后预处理 $dp_i$。然而按照上述写法你会发现 MLE 啦。。

「？？？？」

我们发现这样做，预处理需要的空间太大了，然而最终查询用到的只有 $50$ 个位置，因此考虑优化一下，将所有询问离线下来排序，然后使用滚动数组，一边递推一边统计答案就行了。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=55;
namespace BigInterger{//找同学要的压位高精度板子 
	struct Int{
		int sign;
		std::vector<int>v;
		inline Int():sign(1){}
		inline Int(const std::string&s){*this=s;}
		inline Int(const int&v){
			char buf[21];
			sprintf(buf,"%d",v);
			*this=buf;
		}
		inline void zip(const int&unzip){
			if(!unzip)
				for(int i=0;i<v.size();++i)
					v[i]=get_pos(i<<2)+ get_pos(i<<2|1)*10+get_pos(i<<2|2)*100+get_pos(i<<2|3)*1000;
			else
				for(int i=(v.resize(v.size()<<2),v.size()-1),a;~i;--i)
					a=((i&3)>=2)?v[i>>2]/100:v[i>>2]%100,v[i]=(i&1)?a/10:a%10;
			setsign(1,1);
		}
		inline int get_pos(const int&pos)const{return pos>=v.size()?0:v[pos];}
		inline Int&setsign(const int&newsign,const int&rev){
			while(v.size()>1&&!v.back())v.pop_back();
			sign=(v.empty()||(v.size()==1&&!v[0]))?1:(rev?newsign*sign:newsign);
			return *this;
		}
		inline std::string to_str()const{
			Int b=*this;
			std::string s;
			for(int i=(b.zip(1),0);i<b.v.size();++i)
				s+=(char)(*(b.v.rbegin()+i)^48);
			return (sign<0?"-":"")+(s.empty()?"0":s);
		}
		inline bool absless(const Int&b)const{
			if(v.size()!=b.v.size())return v.size()<b.v.size();
			for(int i=v.size()-1;~i;--i)
				if(v[i]!=b.v[i])return v[i]<b.v[i];
			return false;
		}
		inline Int operator-()const{
			Int c=*this;
			c.sign=(v.size()>1||v[0])?-c.sign:1;
			return c;
		}
		inline Int&operator=(const std::string&s){
			if(s[0]=='-')
				*this=s.substr(1);
			else{
				for(int i=(v.clear(),0);i<s.size();++i)
					v.push_back(*(s.rbegin()+i)^48);
				zip(0);
			}
			return setsign(s[0]=='-'?-1:1,sign=1);
		}
		inline bool operator<(const Int&b)const{
			return sign!=b.sign?sign<b.sign:(sign==1?absless(b):b.absless(*this));
		}
		inline bool operator==(const Int&b)const{return v==b.v&&sign==b.sign;}
		inline Int&operator+=(const Int&b){
			if(sign!=b.sign)return *this=(*this)-(-b);
			v.resize(std::max(v.size(),b.v.size())+1);
			for(int i=0,carry=0;i<b.v.size()||carry;++i){
				carry+=v[i]+b.get_pos(i);
				v[i]=carry%10000,carry/=10000;
			}
			return setsign(sign,0);
		}
		inline Int operator+(const Int&b)const{
			Int c=*this;
			return c+=b;
		}
		inline Int operator++(){return *this+=1;}
		inline Int operator-(const Int&b)const{
			if(b.v.empty()||b.v.size()==1&&!b.v[0])return *this;
			if(sign!=b.sign)return (*this)+(-b);
			if(absless(b))return -(b-*this);
			Int c;
			for(int i=0,borrow=0;i<v.size();++i){
				borrow+=v[i]-b.get_pos(i);
				c.v.push_back(borrow);
				c.v.back()-=10000*(borrow>>=31);
			}
			return c.setsign(sign,0);
		}
		inline Int operator-=(const Int&b){return *this=*this-b;}
		inline Int operator--(){return *this-=1;}
		inline void add_mul(const Int&b,int mul){
			v.resize(std::max(v.size(),b.v.size())+2);
			for(int i=0,carry=0;i<b.v.size()||carry;++i){
				carry+=v[i]+b.get_pos(i)*mul;
				v[i]=carry%10000,carry/=10000;
			}
		}
		inline Int operator*(const Int&b)const{
			if(b<*this)return b*(*this);
			Int c,d=b;
			for(int i=0;i<v.size();++i,d.v.insert(d.v.begin(),0))
				c.add_mul(d,v[i]);
			return c.setsign(sign*b.sign,0);
		}
		inline Int operator*=(const Int&b){return *this=*this*b;}
		inline Int operator/(const Int&b)const{
			if(b.v.size()==1&&!b.v[0]){
				std::cout<<"Divisor is 0.\nCheck your code now.\n";
				exit(0);
				return 0x7fffffff;
			}
			Int c,d;
			d.v.resize(v.size());
			double db=1.0/(b.v.back()+(b.get_pos((unsigned)b.v.size()-2)/1e4)+(b.get_pos((unsigned)b.v.size()-3)+1)/1e8);
			for(int i=v.size()-1;~i;--i){
				c.v.insert(c.v.begin(),v[i]);
				int m=(c.get_pos(b.v.size())*10000+c.get_pos((int)b.v.size()-1))*db;
				c-=b*m,c.setsign(c.sign,0),d.v[i]+=m;
				while(c>=b)c-=b,++d.v[i];
			}
			return d.setsign(sign*b.sign,0);
		}
		inline Int operator/=(const Int&b){return *this=*this/b;}
		inline Int operator%(const Int&b)const{return *this-*this/b*b;}
		inline Int operator%=(const Int&b){return *this=*this%b;}
		inline bool operator>(const Int&b)const{return b<*this;}
		inline bool operator<=(const Int&b)const{return !(b<*this);}
		inline bool operator>=(const Int&b)const{return !(*this<b);}
		inline bool operator!=(const Int&b)const{return !(*this==b);}
	};
	inline std::istream& operator>>(std::istream& stream,Int&x){
		std::string str;
		stream>>str;
		x=str;
		return stream;
	}
	inline std::ostream& operator<<(std::ostream& stream,const Int&x){
		stream<<x.to_str();
		return stream;
	}
}using BigInterger::Int;
struct node
{
	Int x;
	int id;
	bool operator<(const node &f)const{ return x<f.x; }
}q[MAXN];
int res[MAXN];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int T;
	cin>>T;
	for(int i=1;i<=T;i++)	cin>>q[i].x,q[i].id=i;
	sort(q+1,q+T+1);//大力离线 
	Int A=1,B=2,C;//滚动需要的变量 
	int j=1;
	for(int i=1;i<=T;i++)
	{ 
		while(B<=q[i].x)	C=A,A=B,B=C+B+1,j++;
		if(q[i].x<=2||q[i].x==6)	continue;//特判 
		res[q[i].id]=ceil(j/2.0)-1;//统计 
	}
	for(int i=1;i<=T;i++)	cout<<res[i]<<'\n';
	return 0;
}
```

---


# [FJOI2016] 神秘数

## 题目描述

一个可重复数字集合 $S$ 的神秘数定义为最小的不能被 $S$ 的子集的和表示的正整数。例如 $S=\{1,1,1,4,13\}$，有：$1 = 1$，$2 = 1+1$，$3 = 1+1+1$，$4 = 4$，$5 = 4+1$，$6 = 4+1+1$，$7 = 4+1+1+1$。

$8$ 无法表示为集合 $S$ 的子集的和，故集合 $S$ 的神秘数为 $8$。

现给定长度为 $n$ 的**正整数**序列 $a$，$m$ 次询问，每次询问包含两个参数 $l,r$，你需要求出由 $a_l,a_{l+1},\cdots,a_r$ 所组成的可重集合的神秘数。

## 说明/提示

对于 $100\%$ 的数据点，$1\le n,m\le {10}^5$，$\sum a\le {10}^9$。

## 样例 #1

### 输入

```
5
1 2 4 9 10
5
1 1
1 2
1 3
1 4
1 5```

### 输出

```
2
4
8
8
8```

# 题解

## 作者：何俞均 (赞：54)

广告：食用[$blog$](https://www.cnblogs.com/heyujun/p/10279103.html)体验更佳

首先我们想一想暴力怎么做

对于一段区间$[l,r]$

我们先将它之间的数升序排序

从左往右扫，

设当前我们可以表示出的数为$[1,x]$,待插入的数为$a_i$

会有下面两种情况：

1.$a_i> x+1$时，$x+1$肯定表示不出来$ans=x+1$

2.$a_i\leq x+1$时，值域变为$[1,x+a_i]$，继续扫

那么我们暴力的复杂度为$O(nmlogn)$

考虑怎么优化这个过程

还是用刚才的思路

设当前值域$[1,x]$

则$ans=x+1$

若小于等于$ans$的数的和$res\geq ans$，则一定有未选的且小于等于$ans$的数，

令$ans=res+1$即可。

反之说明答案就是$ans$，直接$break$

因为有$\sum a_i\leq 10^9$,用主席树维护

所以复杂度$O(m(logn)(log\sum a_i))$

代码
```cpp
#include <iostream> 
#include <cstdio> 
#include <cstdlib> 
#include <cstring> 
#include <cmath> 
#include <algorithm> 
using namespace std; 
inline int gi() { 
    register int data = 0, w = 1; 
    register char ch = 0; 
    while (!isdigit(ch) && ch != '-') ch = getchar(); 
    if (ch == '-') w = -1, ch = getchar(); 
    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); 
    return w * data; 
}
const int MAX_N = 1e5 + 5; 
const int INF = 1e9; 
struct Node { int ls, rs, v; } t[MAX_N << 5]; 
int rt[MAX_N], tot = 0; 
void insert(int &o, int p, int l, int r, int pos, int v) { 
    o = ++tot, t[o] = t[p], t[o].v += v; 
    if (l == r) return ; 
    int mid = (l + r) >> 1; 
    if (pos <= mid) insert(t[o].ls, t[p].ls, l, mid, pos, v); 
    else insert(t[o].rs, t[p].rs, mid + 1, r, pos, v); 
} 
int query(int v, int u, int l, int r, int ql, int qr) { 
    if (ql <= l && r <= qr) return t[u].v - t[v].v; 
    int mid = (l + r) >> 1, res = 0; 
    if (ql <= mid) res += query(t[v].ls, t[u].ls, l, mid, ql, qr); 
    if (qr > mid) res += query(t[v].rs, t[u].rs, mid + 1, r, ql, qr); 
    return res; 
} 
int N, a[MAX_N]; 
int main () { 
    N = gi(); for (int i = 1; i <= N; i++) a[i] = gi(); 
    for (int i = 1; i <= N; i++) insert(rt[i], rt[i - 1], 1, INF, a[i], a[i]); 
    int M = gi();
    while (M--) { 
        int l = gi(), r = gi(), ans = 1; 
        for (;;) { 
            int res = query(rt[l - 1], rt[r], 1, INF, 1, ans); 
            if (res >= ans) ans = res + 1; 
            else break; 
        } 
        printf("%d\n", ans); 
    } 
    return 0; 
} 
```

---

## 作者：George1123 (赞：46)

[${\color{#00ccee}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.com.cn/blog/Wendigo/)

[P4587 【\[FJOI2016\]神秘数】](https://www.luogu.com.cn/problem/P4587)

### 此题算法:主席树+小$dp$

比此题更模板的主席树:

[P3834 【【模板】可持久化线段树 1(主席树)】](https://www.luogu.com.cn/problem/P3834)

**主席树=一堆公用一部分节点的线段树**

又名可持久化线段树。

每棵线段树往往是**值域线段树(下标为数的大小的线段树)**

第$i$棵树表示**桶中加入了前$i$个数后的区间和**。

建树时会存下根，新树依赖于老树。

查询时会不停比较两棵树的**相同区间**得出答案。

常见作用:静态求区间第$k$小数。


```cpp
struct hjtree{
	struct node{
		int ls,rs,v; //左子树，右子树，值(下标这么大的数有几个)
	}c[N*20];
	void build(int pl,int pr,int l,int r,int x){
		c[pr].v=c[pl].v+1;
		c[pr].ls=c[pl].ls;
		c[pr].rs=c[pl].rs;
		if(l==r) return;
		int mid=l+r>>1;
		if(x<=mid) build(c[pl].ls,c[pr].ls=++tot,l,mid,x);
		else build(c[pl].rs,c[pr].rs=++tot,mid+1,r,x);
	}
	int kth(int pl,int pr,int l,int r,int k){
		if(l==r) return l;
		int mid=l+r>>1;
		if(c[c[pr].ls].v-c[c[pl].ls].v>=k) //二分查询
			return kth(c[pl].ls,c[pr].ls,l,mid,k);
		else return kth(c[pl].rs,c[pr].rs,mid+1,r,
			k-(c[c[pr].ls].v-c[c[pl].ls].v));
	}
}hx;
```

**此题暴力思路:**

对区间的数从小到大排序。

设单前覆盖区间为$[1,x]$,下一个数为$y$:

```cpp
if(y<=x+1) //区间变成[1,x+y]
else  //区间不变
```

而由于后一种情况啥都不用做，所以可以用**主席树**优化。

**因为只有$[y_{last},x+1]$的数才是有用的**。


## 以下是代码+注释

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
const int A=1e9; //数组最大值
int n,m,tot,rt[N],ans;
struct hjtree{
	int ls[N<<5],rs[N<<5],v[N<<5]; //小一点就RE
	void cp(int x,int y){
		ls[x]=ls[y],rs[x]=rs[y],v[x]=v[y]; //节点复制
	}
	void fix(int pl,int pr,int l,int r,int x){
		cp(pr,pl),v[pr]+=x; //按照pl新建一个节点pr(两棵树可以共享节点)
		if(l==r) return;
		int mid=l+r>>1;
		if(mid>=x) fix(ls[pl],ls[pr]=++tot,l,mid,x);
		else fix(rs[pl],rs[pr]=++tot,mid+1,r,x);
	}
	int fsum(int pl,int pr,int l,int r,int x,int y){//得出pr和pl之间的大于x小于y的数的和
		if(v[pr]-v[pl]==0) return 0;
		if(l>=x&&r<=y) return v[pr]-v[pl];
		int ret=0,mid=l+r>>1;
		if(mid>=x) ret+=fsum(ls[pl],ls[pr],l,mid,x,y);
		if(mid<y) ret+=fsum(rs[pl],rs[pr],mid+1,r,x,y);
		return ret;
	}
}hx;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		int x; scanf("%d",&x);
		hx.fix(rt[i-1],rt[i]=++tot,1,A,x);
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		int L,R,tmp,lst=0,now=0;
		scanf("%d%d",&L,&R);
		while(1+1==2){ //重要歪理:1+1=2
			tmp=hx.fsum(rt[L-1],rt[R],1,A,lst+1,now+1);  //算法精华
			if(tmp){lst=now+1; now+=tmp; }
			else break;
		}
		printf("%d\n",now+1);
	}
	return 0;
}
```
就是这样，一个由大树维护的奇怪小$dp$写好了。

喜欢就点个赞吧，不喜欢也点个赞吧。

谢谢大家! !





---

## 作者：Suzt_ilymtics (赞：25)


[题目传送](https://www.luogu.com.cn/problem/P4587)

[更好的阅读体验？](https://www.cnblogs.com/Silymtics/p/solution-P4587.html)

思路挺仙的一题，不过有了思路就是个主席树的板子了

### 前置芝士

- 主席树

### Description

> 一个可重复数字集合 $S$ 的神秘数定义为最小的不能被 $S$ 的子集的和表示的正整数。
> 现在给你一个长度为 $n$ 的序列 $a$ ，每次询问一个 $[l,r]$，问 $[l,r]$ 区间的数组成的集合的神秘数。
> $n,m \le 10^5, \sum a_i \le 10^9$。

### Solution

考虑没有区间查询时怎么做。

首先肯定要考虑有没有 $1$ ，没有直接输出 $1$。
先对 $a$ 序列进行排序。
设当前我们已经表示出了 $[1,x]$，下一个添加进去的数为 $a_i$。

- 如果 $a_i \le x+1$，填加后能表示出来的区间为 $[1,x] \cup [1 + a_i, x + a_i] = [1, x + a_i]$。
- 如果 $a_i > x + 1$，那么 $x+1$ 就表示不出来，所以答案为 $x+1$。

这样一次询问的复杂度是 $O(n)$ 的。

考虑优化这个添加过程。

假设用值域在 $[1,lst]$ 区间内的数可以表示出来的区间为 $[1,now]$。
那么我们再把值域在 $[1,now+1]$ 区间内的任何数放进去都是合法的。
因为我们已经把值域在 $[1,lst]$ 内的所有数放进去了，那么我们设 $sum = \sum a_i [lst + 1 \le a_i \le now + 1]$，即对值域在 $[lst+1, now+1]$ 内的数求和，把他们一起放进去。
那么我们已经用过的数的区间为 $[1,now + 1]$，可以表示出来的数的区间为 $[1,now+sum]$。
注：上面这块的区间均指值域区间而不是下标区间，注意区分。

上面这个值域的扩展过程类似于斐波那契数列，所以说复杂度是 $\log (\sum a_i)$ 的。

查询一段区间内一个值域区间的和就是主席树板子做的事了。单次求和为 $\log $ 复杂度。

所以总复杂度为 $O(n \log n \log (\sum a_i))$。

### Code

```cpp
/*
Work by: Suzt_ilymics
Knowledge: ??
Time: O(??)
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#include<string>
#define int long long
#define orz cout<<"lkp AK IOI!"<<endl

using namespace std;
const int MAXN = 1e5+5;
const int INF = 1e9+7;
const int mod = 1e9+7;
const int Max = 1e9;

int n, m;
int root[MAXN];

int read(){
	int s = 0, f = 0;
	char ch = getchar();
	while(!isdigit(ch))  f |= (ch == '-'), ch = getchar();
	while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0' , ch = getchar();
	return f ? -s : s;
}

namespace Hjt {
    #define ls lson[now_]
    #define rs rson[now_]
    int lson[MAXN << 5], rson[MAXN << 5], val[MAXN << 5], node_num = 0;
    void Insert(int &now_, int pre_, int l, int r, int pos, int val_) {
        now_ = ++ node_num;
        val[now_] = val[pre_] + val_; 
        ls = lson[pre_], rs = rson[pre_];
        if(l == r) return ;
        int mid = (l + r) >> 1;
        if(pos <= mid) Insert(ls, lson[pre_], l, mid, pos, val_);
        else Insert(rs, rson[pre_], mid + 1, r, pos, val_);
    }
    int Query(int now_, int pre_, int l, int r, int L, int R) {
        if(!(val[now_] - val[pre_])) return 0;
        if(L <= l && r <= R) return val[now_] - val[pre_];
        int mid = (l + r) >> 1, res = 0;
        if(mid >= L) res += Query(ls, lson[pre_], l, mid, L, R);
        if(mid < R) res += Query(rs, rson[pre_], mid + 1, r, L, R);
        return res;
    }
}

signed main()
{
    n = read();
    for(int i = 1, x; i <= n; ++i) {
        x = read();
        Hjt::Insert(root[i], root[i - 1], 1, Max, x, x);
    }
    m = read();
    for(int i = 1, l, r; i <= m; ++i) {
       l = read(), r = read();
       int lst = 0, now = 0;
       while(1 + 2 == 3) {
           int tmp = Hjt::Query(root[r], root[l - 1], 1, Max, lst + 1, now + 1);
//           cout<<"tmp: "<<tmp<<"\n";
           if(tmp) lst = now + 1, now += tmp;
           else break;
       }
       printf("%lld\n", now + 1);
    }
	return 0;
}
```

---

## 作者：Fading (赞：21)

讲一个好理解的方法。

### 约定变量：

$\text{pos}$为当前集合可以表示的值域为$[1,\text{pos}]$。

我们来挖掘这题的性质。

## $1:\ $对于一个新加入的数$x$

### 若$x\leq \text{pos}+1,$那么$\text{pos}$可以扩大成$\text{pos}+x$

证明：非常简单，对于每一个$y\in[1,\text{pos}]$，有两个选择：

$y+=x:\ $值域变为$[1+x,\text{pos}+x]$

不变$\ :\ $值域依然为$[1,\text{pos}]$

$x$单独为一个数$\ :\ $值域为$[x,x]$

三者的并集为$[1,\text{pos}+x]$。

### 若$x>\text{pos}+1,$那么无法扩大

比较显然，因为多了一个$x$依旧拼不出$\text{pos}+1(x>\text{pos}+1)$

这个性质有什么用呢？

## $2:\ $对于区间$[l,r]$

我们把区间里的数从小到大拿出来。排序，设为$a_1,a_2,...$

### 必有$a_1=1$

显然。。。

我们一个一个数从小到大加入$($先加入所有的$1,$随后是$2...)$。

我们设$\text{mx}$为**已经在这个集合内数的上界**。

我们要新加入的数一定$\in [\text{mx}+1,\text{pos}+1]$

因为之前$[1,\text{mx}]$里的所有数都加入过了，继续加入就重复了！

而且根据刚才讲的，加入$[\text{pos}+2,+\infty]$对答案无贡献。

我们可以把这个值域内所有的数全部加入，设这个值域$[\text{mx}+1,\text{pos}+1]$的所有数和为$\text{Sum},$整个区间就可以扩大。

此时$\text{mx}$变为$\text{pos}+1,$而原来的$\text{pos}$则要加上$\text{Sum}($就是刚才讲的性质$)$

如果$\text{Sum}=0$答案就是$\text{pos}+1$

求值域和可以用权值线段树。然而这个是区间查询，所以我们使用主席树。

### 时间复杂度分析

发现$\text{pos}$的变换幅度很大，每一次加上$\text{pos}'+1($上一次的$\text{pos})$

这是一个倍增的复杂度。所以复杂度为$O(mlog_{2}^2A)$

其中$A$是$a$数组的最大值。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
int cnt,root[1000001],n,m;
const int inf=1e9;
struct node{
	int l,r,sum;
}seg[5000001];
#define mid ((lb+rb)>>1)
void update(int &rt,int lb,int rb,int x){
	seg[++cnt]=seg[rt];rt=cnt;seg[rt].sum+=x;
	if (lb==rb) return;
	(mid>=x?update(seg[rt].l,lb,mid,x):update(seg[rt].r,mid+1,rb,x));
}
int query(int i,int j,int lb,int rb,int l,int r){
	if (!(seg[j].sum-seg[i].sum)||r<lb|rb<l) return 0;
	if (lb>=l&&rb<=r) return (seg[j].sum-seg[i].sum);
	return query(seg[i].l,seg[j].l,lb,mid,l,r)+query(seg[i].r,seg[j].r,mid+1,rb,l,r);
}
int main(){
	n=read();
	for (int i=1;i<=n;i++){
		root[i]=root[i-1];
		update(root[i],1,inf,read());
	}
	m=read();
	while (m--){
		int l=read(),r=read();
		int mx=0,pos=0;
		for (int Sum;;){
			Sum=query(root[l-1],root[r],1,inf,mx+1,pos+1);
			if (!Sum) break;
			mx=pos+1;pos+=Sum;
		}
		printf("%d\n",pos+1);
	}
	return 0;
} 
```

---

## 作者：Utilokasteinn (赞：16)

## [Link](https://www.luogu.com.cn/problem/P4587)

一道挺有意思的题。

先讲一下该题的两个性质。

假设已经放进了一些数，可以组成 $[1,pos]$ 中任何一个数。

要新加入一个数 $x$。

**若 $x\le pos+1$，就把 $x$ 加入，那就可以组成 $[1,pos+x]$ 中任何一个数。**

不难发现，若 $x\le pos$，在 $x$ 加入之前可以组成 $[pos-x,pos]$，那在 $x$ 加入之后，这些数就可以和 $x$ 组成 $[pos,pos+x]$。若 $x=pos+1$，$x$ 可以直接组成 $pos+1$ 。

**若 $x>pos+1$，把 $x$ 加入，也无法组成 $pos+1$，故不将 $x$ 加入。**

------------

题解：

我们先将区间 $[l,r]$ 的数排序，从小到大。（实际上并不需要）

最开始可以组成的区间为 $[0,0]$。

设 $maxn$ 为加入集合的上界（不一定有这个数，但是集合内的数都小于等于它），初始为 $0$。设 $pos$ 为当前可以表示 $[1,pos]$。

最开始，肯定要放入数字 $1$。若没有数字 $1$，那肯定组不成 $1$，就可以直接输出。

假设数字 $1$ 的个数为 $cnt$，那组成的范围就成了 $[1,cnt]$。此时 $maxn=1,pos=cnt$。

按照之前发现的一些性质，继续查找数。

首先，新加入数肯定要在 $[1,pos+1]$ 内，又因为小于等于 $maxn$ 的数已经被加入，所以新加入的数范围在 $[maxn+1,pos+1]$。

查询区间 $[l,r]$ 中范围在 $[maxn+1,pos+1]$ 内的数的和 $res$。

将这些数全部加入，可组成的范围变为 $[1,pos+res]$，$maxn$ 变为 $pos+1$。

这样操作，直到加入不了数。答案就是 $pos+1$。

原本说要先排序，实际是不需要的，只需返回区间 $[l,r]$ 范围在 $[maxn+1,pos+1]$ 数的和，这就可以用主席数来维护。

不会分析时间复杂度，口胡一个 $O(m\log n \log A)$。$A$ 为 $a_i$ 中的最大数。可以通过此题。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int s=0;char c=getchar();
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())
		s=s*10+c-'0';
	return s;
}
int n,m,a[100005],cnt,root[100005],maxn;
struct node{
	int ls,rs,sum;
}s[3000000];
int update(int l,int r,int pre,int pos)
{
	int p=++cnt;
	s[p]=s[pre];
	s[p].sum+=pos;
	if(l<r)
	{
		int mid=(l+r)/2;
		if(pos<=mid)s[p].ls=update(l,mid,s[pre].ls,pos);
		else s[p].rs=update(mid+1,r,s[pre].rs,pos);
	}
	return p;
}
int query(int l,int r,int ql,int qr,int p1,int p2)
{
	if(qr<l|r<ql||s[p1].sum==s[p2].sum)
		return 0;
	if(ql<=l&&r<=qr)
		return s[p2].sum-s[p1].sum;
	int mid=(l+r)/2;
	return query(l,mid,ql,qr,s[p1].ls,s[p2].ls)+query(mid+1,r,ql,qr,s[p1].rs,s[p2].rs);
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read(),maxn=max(maxn,a[i]);
	for(int i=1;i<=n;i++)
		root[i]=update(1,maxn,root[i-1],a[i]);
	m=read();
	while(m--)
	{
		int l=read(),r=read();
		int mx=0,pos=0;
		while(1)
		{
			int res=query(1,maxn,mx+1,pos+1,root[l-1],root[r]);
			if(!res)break;
			mx=pos+1;
			pos+=res;
		}
		printf("%d\n",pos+1);
	}
	return 0;
} 
```
谢谢观赏。

---

## 作者：楠枫 (赞：10)

这可以说是主席树的一个板子题，主要维护不同区间的不同值域的区间和。

我们设当前已经求出的区间为 $[1,x]$，那么对于能扩充这个区间的数一定符合 $k\in[1,x+1]$，因为若 $k>x+1$ 则 $x+1$ 没有数来合成，所以答案即为 $x+1$。

不过严谨得来说，设 $lst$ 为上次合成的最右边界，$k \ge lst+1$，否则一个数可能会重复用多次。

所以可以有两种写法
```cpp
int lst=0,now=0;
while(1) {
	int tmp=T.query(T.root[r],T.root[l-1],lst+1,now+1,1,sum);
	if (tmp) lst=now+1,now+=tmp;
	else break;
}
```
或者是
```cpp
int now=0;
while(1) {
	int tmp=T.query(T.root[r],T.root[l-1],1,now+1,1,sum);
	if (tmp>now) now=tmp;
	else break;
}
```
两种写法时间复杂度没有什么区别，都是 $O(nlog_2(\sum_{i=1}^{n}a_i)+m(\text{区间和右界右移})log_2(\sum_{i=1}^{n}a_i))$。

但第二种常数会小很多，因为线段树区间求和，所求区间范围越大，分割的区间越少，所以常数会更小。实测真的会快不少。

$AC \kern 0.4emCODE:$ 
```cpp
#include<bits/stdc++.h>
#define p(i) ++i
#define ri register int
using namespace std;
const int N=1e5+7;
inline int read() {
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;	
}
int n,num[N];
struct Seg{
	int root[N],tot;
	struct Segmenttree{
		int l,r;
		int sum;
	}T[N<<5];
	inline void up(int x) {T[x].sum=T[T[x].l].sum+T[T[x].r].sum;}
	inline int New(int pre) {T[p(tot)]=T[pre];return tot;} 
	inline void insert(int &x,int pre,int l,int r,int p) {
		x=New(pre);
		if (l==r) {T[x].sum+=p;return;}
		int mid=(l+r)>>1;
		if (p<=mid) insert(T[x].l,T[pre].l,l,mid,p);
		else insert(T[x].r,T[pre].r,mid+1,r,p);
		up(x);
	}
	inline int query(int x,int y,int l,int r,int lt,int rt) {
		if (T[x].sum==T[y].sum) return 0;
		if (l<=lt&&rt<=r) return T[x].sum-T[y].sum;
		int mid=(lt+rt)>>1,res=0;
		if (l<=mid) res+=query(T[x].l,T[y].l,l,r,lt,mid);
		if (r>mid) res+=query(T[x].r,T[y].r,l,r,mid+1,rt);
		return res;
	}
}T;
int main() {
	int sum=0;
	n=read();
	for (ri i(1);i<=n;p(i)) sum+=(num[i]=read());
	for (ri i(1);i<=n;p(i)) T.insert(T.root[i],T.root[i-1],1,sum,num[i]);
	int q=read();
	for (ri i(1);i<=q;p(i)) {
		int l=read(),r=read();
		int now=0;
		while(1) {
			int tmp=T.query(T.root[r],T.root[l-1],1,now+1,1,sum);
			if (tmp>now) now=tmp;
			else break;
		}
		printf("%d\n",now+1);
	}
	return 0;
}
```

---

## 作者：clamee (赞：7)

[更好的阅读体验](https://clamee.github.io/2020/10/17/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-FJOI2016-%E7%A5%9E%E7%A7%98%E6%95%B0/)

> 题目大意：一个可重复数字集合S的神秘数定义为最小的不能被S的子集的和表示的正整数。
>
> 给定一个序列 $a$，每次询问一个区间的神秘数。

很久之前还讲过这个题，当时还要求带修。

考虑加入当前的神秘数为 $x$。当加入一个数 $y$ 且 $y\le x$ 时神秘数会变为 $x+y$。当 $y>x$ 时对答案不造成贡献。

可以考虑值域倍增，对 $[1,1],[2,3],[4,7],\cdots,[2^k,2^k-1],\cdots$ 之间的元素分别维护前缀和和 rmq。

每次查询的时候依次查区间最小值是否小于当前神秘数即可。如果小于的话直接加上区间和去下一个区间，不然直接返回答案。

如果 $O(n)-O(1)$ 求 rmq 的话复杂度可以做到 $O(n\log\max(a[i]))$。

我的代码就直接用 st 表了。

```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define rg register
#define ll long long
il int read()
{
	int re=0,k=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')k=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){re=re*10+ch-48;ch=getchar();}
	return re*k;
}
il void write(int x)
{
	if(x<0)return putchar('-'),write(-x),void();
	if(x<=9)return putchar(x+48),void();
	return write(x/10),write(x%10),void();
}
int LOG[100005],a[100005],n,m;
struct st{
	int st[100005][17];ll sum[100005];
	void init(int liml,int limr)
	{
		sum[0]=0;
		for(rg int i=1;i<=n;i++)
			if(a[i]>=liml&&a[i]<=limr)st[i][0]=a[i],sum[i]=sum[i-1]+a[i];
			else st[i][0]=0x3f3f3f3f,sum[i]=sum[i-1];
		for(rg int j=1;(1<<j)<=n;j++)
			for(rg int i=1;i+(1<<j)<=n+1;i++)
				st[i][j]=min(st[i][j-1],st[i+(1<<(j-1))][j-1]);
	}
	ll query(int l,int r)
	{
		int d=LOG[r-l];
		return min(st[l][d],st[r-(1<<d)+1][d]);
	}
	ll Sum(int l,int r)
	{
		return sum[r]-sum[l-1];
	}
}b[30];
signed main()
{
	n=read();
	for(rg int i=1;i<=n;i++)
		a[i]=read();
	m=read();
	for(rg int i=2;i<=n;i++)
		LOG[i]=LOG[i>>1]+1;
	b[0].init(1,1);
	for(rg int i=1,t=2;i<=29;i++,t<<=1ll)
		b[i].init(t,t+t-1);
	for(rg int i=1,l,r;i<=m;i++)
	{
		l=read();r=read();
		ll ans=0;int t=0;
		while(t<=29)
		{
			if(ans+1ll<min(b[t].query(l,r),(1ll<<(t+1))-1))
				break;
			ans+=b[t].Sum(l,r);
			t++;
		}
		write(ans+1ll);puts("");
	}
}
```



---

## 作者：Gmt丶FFF (赞：4)

首先对于数 $a_i$ 和一个 $sum$ 内被全部覆盖的区间，若 $a_i\le sum$，那么可以将区间覆盖到 $a_i+sum$，经典背包，不证明。

那么通过这个可以推出来一种暴力做法，每一次找到一个在 $l$ 到 $r$ 小于等于 $sum$ 的数，将 $sum$ 加上它，然后再找，初始 $sum=1$。

但是这样复杂度明显会非常高，考虑优化这个过程。

利用树状数组维护 $l$ 到 $r$ 的所有数，每次查询 $sum$ 以内的所有数，进行累加，如果 $sum$ 值发生了改变，再重复这个过程，直到不变为止。

可以很好的发现，每进行一次这个过程，$sum$ 的值近似 $\times2$，所以总共最多进行 $\log(\max(a_i))$ 次就可以更新完毕，我们称这种过程叫做迭代，迭代是因为处理顺序的原因导致一次答不出来最优解，就进行多次枚举得出答案的过程。

但是复杂度仍然不乐观，复杂度的根源在于每次建树状数组需要花费大量时间，所以考虑能否可持久化，那就可以打可持久化线段树，但是这里选择更简单的方法。

考虑对询问进行前缀和处理，每次需要查询的是 $1$ 到 $r$ 小于等于 $sum$ 的数与 $1$ 到 $l-1$ 小于等于 $sum$ 的数。

那么有很多区间的询问是重合的，就可以离线处理了。

先每次标记询问的位置，然后从前往后遍历整个序列，维护树状数组，每次再更新询问所得到的值，结束遍历后用前缀和处理每次的答案，与之前答案作对比，如果被更新了，那么继续迭代，直到无数值更新后，答案就统计出来了。

时间复杂度：$O(n\times\log(n)\times\log(\max(a_i)))$。

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstring>
#define int long long
using namespace std;
const int N=1e5+5;
int n,m,cnt,f[N],t[N],ans[N],sum[N],bef[N];
struct node
{
	int name,data;
}a[N];
int cmp(node fi,node se)
{
	return fi.data<se.data;
}
int cmp2(node fi,node se)
{
	return fi.name<se.name;
}
struct node2
{
	int name,l,r,sum;
}p[N];
int cmp3(node2 fi,node2 se)
{
	return fi.r<se.r;
}
int lowbit(int x)
{
	return x&(-x);
}
void update(int x,int k)
{
	while(x<=cnt)
	{
		f[x]+=k;
		x+=lowbit(x);
	}
}
int search(int x)
{
	int sum=0;
	while(x)
	{
		sum+=f[x];
		x-=lowbit(x);
	}
	return sum;
}
vector<int>lc[N],rc[N];
void diedai()
{
	memset(f,0,sizeof(f));
	for(int i=1;i<=m;i++)sum[i]=1;
	bool flag=0;
	for(int i=1;i<=n;i++)lc[i].clear(),rc[i].clear();
	for(int i=1;i<=m;i++)lc[p[i].l-1].push_back(p[i].name);
	for(int i=1;i<=m;i++)rc[p[i].r].push_back(p[i].name);
	for(int i=1;i<=n;i++)
	{
		update(a[i].data,t[a[i].data]);
		int len=lc[i].size();
		for(int j=0;j<len;j++)
		{
			int l=1,r=cnt;
			while(l<r)
			{
				int mid=(l+r+1)>>1;
				if(t[mid]<=p[lc[i][j]].sum)l=mid;
				else r=mid-1;
			}
			sum[lc[i][j]]-=search(l);
		}
		len=rc[i].size();
		for(int j=0;j<len;j++)
		{
			int l=1,r=cnt;
			while(l<r)
			{
				int mid=(l+r+1)>>1;
				if(t[mid]<=p[rc[i][j]].sum)l=mid;
				else r=mid-1;
			}
			sum[rc[i][j]]+=search(l);
		}
	}
	for(int i=1;i<=m;i++)
	{
		bef[i]=p[i].sum;
		if(sum[i]!=p[i].sum)flag=1;
		p[i].sum=sum[i];
	}
	if(flag)diedai();
}
signed main()
{
	freopen("niuniunum.in","r",stdin);
	freopen("niuniunum.out","w",stdout);
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i].data),a[i].name=i;
	sort(a+1,a+1+n,cmp);
	int bef=-1;
	for(int i=1;i<=n;i++)
	{
		if(a[i].data!=bef)cnt++,t[cnt]=a[i].data;
		bef=a[i].data;
		a[i].data=cnt;
	}
	sort(a+1,a+1+n,cmp2);
	for(int i=1;i<=n;i++)update(a[i].data,a[i].data);
	scanf("%lld",&m);
	for(int i=1;i<=m;i++)
	{
		p[i].name=i;
		scanf("%lld%lld",&p[i].l,&p[i].r);
		p[i].sum=1;
	}
	diedai();
	for(int i=1;i<=m;i++)printf("%lld\n",p[i].sum);
	return 0;
}
/*
8 6
1 2 3 4 5 17 1 99
1 5
2 5
1 6
1 7
1 8
3 8
*/
```

---

## 作者：rfsfreffr (赞：4)

挺奇妙的一道题，由于又和值域和区间查询有关，很自然的想到主席树。

先来考虑一个很简单例子：

假设集合 $S$ 已经可以组成 $[1,x]$ 的数。

如果我再加入一个  $p\le x+1$ 。

则新的集合 $S$ 就可维护出 $[1,x+p]$ 这个值域的数。

但若我加入的 $p>x+1$ ,将会对 $S$ 能维护的值域区间没有影响。

顺着以上这个想法：

假设我们已经维护出了 $[l,r]$ 内的值域情况。$S$ 集合为空。

我们首先肯定要找 $1$ 的个数啊！，没 $1$ 你连 $1$ 都维护不出来，算个屁！

假设我们找到了 $p$ 个 $1$ , 加入到 $S$ 集合中，现在 $S$ 能维护的区间就是 $[1,p]$。

那么现在，对于 $[2,p+1]$ 里的这些数，如果能将他们加入到 $S$ 中，就一定可以让，$S$ 能维护的区间增大！我们现在相当于需要求出在下标范围为 $[l,r]$ 区间内值域大小在 $[2,p+1]$ 范围的数的和。

那么，时间复杂度应该如何保证呢？

设 $a$ 为值域大小, 一次在主席树上的查询操作就是 $O(\log a)$ 的。

考虑最坏的查询情况，即 $p$ 增长最少的一种情况：

在区间 $[1,1]$ 进行查询，只找到一个 $1$, $S=[1,1]$。

在区间 $[2,2]$ 进行查询，只找到一个 $2$, $S=[1,3]$。

在区间 $[3,4]$ 进行查询，只找到一个 $3$, $S=[1,6]$。

在区间 $[5,7]$ 进行查询，只找到一个 $5$, $S=[1,11]$。

在区间 $[8,12]$ 进行查询，只找到一个 $8$, $S=[1,19]$。

我们通过找规律发现 ，设在经过 $k$ 次查找后， $S$ 的值域范围为 $[1,S_k]$。

再可以有 $S_k>\sum F_i$。

然后是一个很不严谨的估计：

$F_i =O(1.618^i)$, 则 $\sum F_i =O(2.618^i)$

即，我们每次查询，最多最多只会查 $O(\log a)$ 次。

故时间复杂度大概是 $O(n\log a+q\log^2a)$。

实际上很难跑满，常数应该相对较小，可以通过本题：

## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=2e5;

int n;
int root[N];
int m,l,r;
int a[N];
int sum[N*33];
int ls[N*33];
int rs[N*33];
int kk;

void read() {
	cin>>n;
	for(int i=1; i<=n; i++) scanf("%d",&a[i]);
}

void push_up(int p) {
	sum[p]=sum[ls[p]]+sum[rs[p]];
}

void insert(int p1,int &p2,int l,int r,int x) {
	if(p2==0) p2=++kk;
	if(l==r) {
		sum[p2]=sum[p1]+x;
		return ;
	}
	
	int mid=(l+r)>>1;
	if(x<=mid) rs[p2]=rs[p1],insert(ls[p1],ls[p2],l,mid,x);
	if(x>mid)  ls[p2]=ls[p1],insert(rs[p1],rs[p2],mid+1,r,x);
	push_up(p2);
}

int query (int pl,int pr,int l,int r,int L,int R) {
	if(L<=l&&r<=R) return sum[pr]-sum[pl];

	int mid=(l+r)>>1,res=0;
	if(L<=mid) res+=query(ls[pl],ls[pr],l,mid,L,R);
	if(R>mid) res+=query(rs[pl],rs[pr],mid+1,r,L,R);
	return res;
}

void build() {
	for(int i=1; i<=n; i++)
		insert(root[i-1],root[i],1,1e9,a[i]);
}

void print() {
	cin>>m;
	for(int i=1; i<=m; i++) {
		scanf("%d%d",&l,&r);
		int L=0,R=0,tmp=0;
		int ans=0;
		while(1) {
			int t=query(root[l-1],root[r],1,1e9,tmp+1,R+1);
			if(t==0) break;
			tmp=R+1;
			R=R+t;
		}
		printf("%d\n",R+1);
	}
}

int main() {
	read();
	build();
	print();
    return 0;
}
```

注意！！数组一定要开大！！不要以为你不是 RE 就不是数组开小了的问题了！



---

## 作者：渡墨残殇 (赞：3)

# 友好的主席树

## 前言自述
这是一道刚学主席树的练习题，就很适合我这样的人写。不过对于我而言，刚开始没有太理解主席树的本质，就想得有点累。

比如说我们刚学主席树时是求区间第 $k$ 小，然后就会把有关的数往求第 $k$ 小的方面考虑。但是主席树的本质是就是**多个线段树的维护**，由于新建线段树会和原来的有很多相同的结点，所以我们每开一个新线段树只需要开一个新的**根**结点和修改一条链即可。

对于本道题而言，我们维护的就是区间内某个数出现的次数不是区间第 $k$ 小了。我们先开一个线段树，由于每次添加一个数都要修改树的结点，所以还是要用主席树。

## 分析
给定一个集合数列，求给定的区间集合内内最小不能被表示的数。
这个题有相似思路的题：[P5020 货币系统](https://www.luogu.com.cn/problem/P5020) 。


这个题会想到集合的思想，给定一个当前集合中最小不能被表示的数为 $ans$，在此集合中，若对于一个数 $x$ 可以被该集合中其它的数表示出来，且在小于 $x$ 的数中在该集合中也均可以被表示出来或者本来就有，那么可以将 $x$ 填入集合，这样表示出来的范围就由 $ans-1$ 扩展到了 $ans+x-1$ 。

那么我们下一次加入的数就是在 $[x,ans+x-1]$ 之间的数，如果该区间中的集合中没有别的数，那么此时答案就是 $ans+x$ ，如果可以填就一直扩大范围。

### 查询

```cpp
int query(int use,int now,int l,int r,int lin,int rax)
{
	int ksum=0;
	if(lin<=l&&r<=rax)return t[now].sum-t[use].sum;
	int mid=(l+r)>>1;
	if(lin<=mid)ksum+=query(t[use].l,t[now].l,l,mid,lin,rax);
	if(mid<rax)  ksum+=query(t[use].r,t[now].r,mid+1,r,lin,rax);
	return ksum; 
}
```


对于维护添数有两种思路。

- 查询所有小于 $ans$ 的区间

通过主席树求和来查询从 $[1,ans-1]$ 的区间如果求和小于等于原来的 $ans$ 就可以结束循环了，否则就一直查询，直到 $Sum==ans$ 为止。
```cpp
int Sum=query(rt[l-1],rt[r],1,inf,1,ans);
		if(Sum<ans)break;
		else ans=Sum+1;
```
- 在填入的数 $x$ 后，查询区间 $[x+1,ans]$

在查询的区间中如果有数那么 $ans+=Sum$ 否则退出循环 。

```cpp
int Sum=query(rt[l-1],rt[r],1,inf,last+1,ans);
		last=ans;
		if(!Sum)break;
		else ans+=Sum;
```

### 维护

```cpp
void modify(int &xi,int x,int l,int r,int inst)
{
	xi=++nodee;
	t[xi]=t[x];t[xi].sum+=inst;
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(inst<=mid) modify(t[xi].l,t[x].l,l,mid,inst);
	else  modify(t[xi].r,t[x].r,mid+1,r,inst);
	return ; 
} 
```

注意不用像刚学主席树一样先建树，直接动态开点即可。

## 代码
```cpp
#include<bits/stdc++.h> 
#define mm 2000009
#define w qwrite
#define gc getchar()	
using namespace std;
struct nihao {
	int fre,l,r,sum,nl,nr;
}t[mm<<2];
int rt[mm<<2];
int a[mm];
int nodee;
int n,m,k=1e9; 
int anss,ans,last;
const int inf=1e9;
int read() { 
    int data = 0, w = 1; 
    char ch = 0; 
    while (!isdigit(ch) && ch != '-') ch = getchar(); 
    if (ch == '-') w = -1, ch = getchar(); 
    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); 
    return w * data; 
}
void modify(int &xi,int x,int l,int r,int inst)
{
	xi=++nodee;
	t[xi]=t[x];t[xi].sum+=inst;t[xi].nl=l,t[xi].nr=r;
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(inst<=mid) modify(t[xi].l,t[x].l,l,mid,inst);
	else  modify(t[xi].r,t[x].r,mid+1,r,inst);
	return ; 
} 

int query(int use,int now,int l,int r,int lin,int rax)
{
	int ksum=0;
	if(lin<=l&&r<=rax)return t[now].sum-t[use].sum;
	int mid=(l+r)>>1;
	if(lin<=mid)ksum+=query(t[use].l,t[now].l,l,mid,lin,rax);
	if(mid<rax)  ksum+=query(t[use].r,t[now].r,mid+1,r,lin,rax);
	return ksum; 
}
signed /*int*/ main ()
{
    int l,r;
    n=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
		modify(rt[i],rt[i-1],1,inf,a[i]);} 
	m=read();
	while(m--)
	{
		l=read(),r=read();ans=1,last=0;
	    for(int i=1;i+1-1<=1;i)
	    {
	    int Sum=query(rt[l-1],rt[r],1,inf,last+1,ans);
		last=ans;
		if(!Sum)break;
		else ans+=Sum;
		/*
		int Sum=query(rt[l-1],rt[r],1,inf,1,ans);
		if(Sum<ans)break;
		else ans=Sum+1;*/
		}
		printf("%d\n",ans);
	} 
    return 0;
}
```





---

## 作者：Godのfather (赞：3)

## （〇）前言&题目

感觉这道题有点意思，并且顺便学习了动态开点。

题意简述：

给出一个可重数集$S$，对于一个非负整数$x$，如果存在$S'\subseteq S$使得$\sum\limits_{a_i\in S'}ai=x$，那么就称$S$可以表示$x$。

假设$S=\{a_1,a_2,a_3,...,a_n\}$，给出$m$组询问，每次询问区间$[l,r]$上的元素组成的集合（即$\{a_l,a_{l+1},...,a_{r-1},a_r\}$）的**最小不能表示的数**是多少。

显然，对于任意的可重集都可以表示$0$，因为$\varnothing $可以表示$0$。

数据范围：

$|S|,m\leq10^5,a_i\in[1,10^9]$

## （一）思路

### Problem1：如何求出一个集合最小不能表示的数

>性质1：对于一个集合，较小的元素有可能可以表示较大的元素，而较大的元素一定不能表示较小的元素。

利用这个性质，我们可以先将这个集合排序，使得$a_l\leq a_{l+1}\leq \cdots\leq a_{r-1} \leq a_r$。

假设前$i$个元素能够表示的数集为$[0,k]$。对于$a_{i-1}$，分类讨论：

1. 若$a_{i+1}\in [0,k+1]$，则前$i+1$个元素能够表示的数集为$[0,k+a_{i+1}]$

1. 若$a_{i+1}>k+1$，则该集合最小不能表示的数为$k+1$

>性质2：对于一个集合（已从小到大排序），最小不能表示的数$x = 1+\sum\limits_{i=1}^{n}a_i(a_{n+1}>1+\sum\limits_{i=1}^{n}a_i)$

由此，我们得到了一个算法。

### Algorithm1：快速排序

对于每一个询问区间，可以将区间内的元素排序，然后再根据性质2求解。

快速排序时间复杂度$\Theta(n\log n)$，总时间复杂度$\Theta(mn\log n)$。

总时间复杂度主要在排序算法上。

### Problem2：如何降低复杂度上限

如果依靠性质2，无论怎样优化排序算法，时间复杂度上限都不低于$\Theta(nm)$。因此，需要换一种方法，推出更多的性质。

### Algorithm2：迭代法

如果我们不排序，对于一个集合$S$，假设$S$最小不能表示的数为$k+1$，那么，$S$必然存在一个子集$S'$，使得$S'$能够表示的数集恰好为$[0,k]$。

考虑如何求出这个子集$S'$。可以使用迭代法。

首先选定一个集合$S'$，它能表示的数为$[0,k']$，显然，$k'=\sum\limits_{x\in S'}x$。

那么我们只需要将$S$中满足$x\leq k'+1$且$x\in S$且$x\notin S'$的$x$放入集合$S'$中。

以此类推，当不存在$x\in S$且$x\notin S'$时，$S'$能够表示的数集最大，此时$k=\sum\limits_{x\in S'}x$。

在最差情况下，每次能够加入集合$S'$的元素呈指数级增长。因此，迭代进行的次数为$\Theta(\log n)$级别。

若每次迭代都将集合$S$遍历一遍，总时间复杂度将达到$\Theta(mn\log n)$，看上去与排序并无太大的区别。

### DataStructure1：主席树（可持久化线段树）

考虑使用一个数据结构来维护一个区间$[l,r]$内，数值范围在$[x,y]$内的元素之和。很容易想到建立一个主席树。然而题目中的值域是$[1,10^9]$，所以需要离散化。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int  maxn = 1e5 + 5;
const long long INF = 1e18 + 7;
inline long long read(){
	long long w = 0, f = 1; char ch = getchar();
	while(ch < '0' or ch > '9') {if(ch == '-') f = -f; ch = getchar();}
	while(ch >= '0' and ch <= '9') w = w*10ll + ch - '0', ch = getchar();
	return w*f;
}
struct SegmentTree{
	int ls, rs; long long sum;
}t[maxn*20];
int  N, M, root[maxn], cnt, tot, rak[maxn]; long long a[maxn], uni[maxn];
inline int  getRak(long long  x){
	return upper_bound(uni, uni+cnt+1+1, x) - uni - 1;
}
inline int  build(int l, int  r){
	int  p = ++tot;
	if(l == r){
		t[p].sum = 0ll;
		return p;
	}
	int  mid = (l+r)>>1;
	t[p].ls = build(l, mid);
	t[p].rs = build(mid+1, r);
	t[p].sum = t[t[p].ls].sum + t[t[p].rs].sum;
	return p;
}
inline int insert(int now, int  l, int  r, int  x, long long val){
	int p = ++tot;
	t[p] = t[now];
	if(l == r){
		t[p].sum += (long long)val;
		return p;
	}
	int mid = (l+r)>>1;
	if(x <= mid) t[p].ls = insert(t[now].ls, l, mid, x, val);
	else t[p].rs = insert(t[now].rs, mid+1, r, x, val);
	t[p].sum = t[t[p].ls].sum + t[t[p].rs].sum;
	return p;
}
inline long long ask(int p, int l, int r, int ql, int qr){
	if(l >= ql and r <= qr) return t[p].sum;
	int mid = (l+r)>>1; long long val = 0ll;
	if(ql <= mid) val += ask(t[p].ls, l, mid, ql, qr);
	if(qr > mid) val += ask(t[p].rs, mid+1, r, ql, qr);
	return val;
}
int main(){
	N = read(), M = read();
	for(int i=1; i<=N; i++) a[i] = read(), uni[i] = a[i];
	sort(uni+1, uni+N+1);
	cnt = unique(uni+1, uni+N+1) - uni;
	uni[cnt+1] = INF;
	for(int i=1; i<=N; i++) rak[i] = getRak(a[i]);
	root[0] = build(1, cnt);
	for(int i=1; i<=N; i++)
		root[i] = insert(root[i-1], 1, cnt, rak[i], a[i]);
	while(M--){
		int l = read(), r = read();
		long long sum1 = 0ll, last = -1ll, delta = 0ll;
		do{
			delta = ask(root[r], 1, cnt, getRak(last + 1) + 1, getRak(sum1 + 1)) - ask(root[l-1], 1, cnt, getRak(last+1) + 1, getRak(sum1+1));
			last = sum1, sum1 = sum1 + delta;
		}while(delta != 0ll);
		printf("%lld\n", sum1 + 1ll);
	}
	return 0;
}
```

#### 一个小优化：动态开点

据说离散化主席树已经过时了。动态开点主席树也很简单，唯一需要注意的是如何继承先前的节点。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
const int INF = 1e9 + 7;
inline int read(){
	int w = 0, f = 1; char ch = getchar();
	while(ch < '0' or ch > '9') {if(ch == '-') f = -f; ch = getchar();}
	while(ch >= '0' and ch <= '9') w = w*10ll + ch - '0', ch = getchar();
	return w*f;
}
struct SegmentTree{
	int ls, rs; long long sum;
}t[maxn*32];
int  N, M, root[maxn], tot; long long a[maxn];
inline int insert(int now, int l, int r, long long x){
	int p;
	if(!now) p = ++tot;
	else p = ++tot, t[p] = t[now];
	if(l == r){
		t[p].sum += (long long)x;
		return p;
	}
	int mid = (l + r)>>1;
	if(x <= mid) t[p].ls = insert(t[now].ls, l, mid, x);
	else t[p].rs = insert(t[now].rs, mid+1, r, x);
	t[p].sum = t[t[p].ls].sum + t[t[p].rs].sum;
	return p;
}
inline long long ask(int p, int l, int r, long long ql, long long qr){
	if(!p) return 0ll;
	if(l >= ql and r <= qr) return t[p].sum;
	int mid = (l+r)>>1; long long val = 0ll;
	if(ql <= mid) val += ask(t[p].ls, l, mid, ql, qr);
	if(qr > mid) val += ask(t[p].rs, mid+1, r, ql, qr);
	return val;
}
int main(){
	N = read(), M = read();
	for(int i=1; i<=N; i++) a[i] = read();
	root[0] = ++tot;
	for(int i=1; i<=N; i++) root[i] = insert(root[i-1], 1, INF, a[i]);
	while(M--){
		int l = read(), r = read();
		long long sum1 = 0ll, last = -1ll, delta = 0ll;
		do{
			delta = ask(root[r], 1, INF, last+2ll, sum1+1ll) - ask(root[l-1], 1, INF, last+2ll, sum1+1ll);
			last = sum1, sum1 = sum1 + delta;
		}while(delta != 0ll);
		printf("%lld\n", sum1 + 1ll);
	}
	return 0;
}
```

## （二）小结

这道题还是挺有趣的。学到了一个新的思想：迭代。

---

## 作者：KKarshilov (赞：3)

这道题为什么没有人写题解呢？

宣传一波个人博客~~

https://blog.csdn.net/qq_37666409/article/details/79055810

这道题的关键在于两个显而易见的结论：

1.如果我有k个1，那么1~k我是一定可以表达出来的

2.在1的条件下，如果新加入的一个数大于k+1，那么k+1就是答案，因为无论如何k+1你是凑不出来的(当前)

然后就可以这么做：

先看看l~r有多少的1，假设有k个，然后看看有多少个k+1，如果没有，输出k+1，否则答案更新为n*(k + 1) + k，n为k+1的个数，重复该过程即可

统计的过程明显可用主席树

寻找答案时至少会扩大两倍，log

O(nlogn*logn)

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN = 300100;
const int MAXE = 6000100;
const int INF = 0x3f3f3f3f;
int n, m, a[MAXN];
template<class T>void read(T &g)
{
    g = 0;int f = 0;int ch = getchar();
    while(ch < '0' || ch > '9')  {f |= (ch == '-'); ch = getchar();}
    while(ch >=  '0'&&ch <= '9'){g = g * 10+(ch^48); ch = getchar();}
    g = f ? - g : g;
    return;
}
int rt[MAXE];
ll val[MAXE];
int ls[MAXE], rs[MAXE], Clock_t;
void insert(int x, int pre, int l, int r, int pos) {
    int cur = rt[pre]; rt[x] = ++Clock_t; x = rt[x];
ab:
    int mid = (l + r) >> 1;
    ls[x] = ls[cur], rs[x] = rs[cur], val[x] = val[cur] + pos;
    if(l == r) return ;
    if(pos <= mid) {
        ls[x] = ++Clock_t; x = ls[x]; cur = ls[cur]; r = mid;
        goto ab;
    }
    else {
        rs[x] = ++Clock_t; x = rs[x]; cur = rs[cur]; l = mid + 1;
        goto ab;
    }
} 
ll query(int x, int y, int l, int r, int pos) {
    ll ret = 0;
AB:
    if(l == r) return (ret + (val[y] - val[x]));
    int mid = (l + r) >> 1;
    if(pos <= mid) {
        x = ls[x]; y = ls[y]; r = mid;
        goto AB;
    }
    else {
        ret += (val[ls[y]] - val[ls[x]]); x = rs[x]; y = rs[y]; l = mid + 1; 
        goto AB;
    }
}
signed main() {
    read(n);
    for(int i = 1; i <= n; i++) read(a[i]);
    for(int i = 1; i <= n; i++) insert(i, i - 1, 1, INF, a[i]);
    read(m);
    int x, y;
    ll Max;ll ans;
    while(m--) {
        Max = 1ll; read(x), read(y);
        ans = query(rt[x - 1], rt[y], 1, INF, 1);
        //cout << "ans = " << ans << endl;
        while(ans >= Max && Max != INF){
            Max = min( (ll) INF, ans + 1);
            ans = query(rt[x - 1], rt[y], 1, INF, (int) Max);
            //cout << "MAX = " << Max << "  " << "ans + 1 = " << ans + 1 << endl;
        }
        printf("%lld\n", ans + 1);
    } 
    return 0;
}
```

---

## 作者：JiaY19 (赞：2)

[**更好的阅读体验**](https://www.cnblogs.com/mfeitveer/p/16657316.html)


### 思路

用到了一个比较神奇的方法，迭代法。

首先考虑对于暴力怎么做。

可以有一个非常显而易见的结论。

如果一个数比此时可以表示的最大的数加一要小。

那么就一定能表示这个数并且可以表示的最大的数变成此时最大的数加上这个数。

稍微想一想就可以发现这个结论是比较好像的。

由此，我们可以利用迭代的思路来优化这个算法。

迭代指的是多次运行算法，来不断逼近正确答案，常用于随机算法当中。

对于每一次迭代，我们直接从左到右扫。

考虑到此题累积答案的特性，可以发现，我们每统计一次答案，此时的答案对于上一次的答案必然会翻倍。

所以我们迭代的次数就为 $O(\log n)$ 级别的。

考虑将询问全部离线。

每一扫过去的时候，若某个询问的前一次答案为 $\text{lastans}$，此时答案为 $\text{ans}$。

那么若 $\text{lastans}$ 等于 $\text{ans}$，那么代表我们就不需要继续统计这一个询问的答案了，就将他给删掉。

至于每一次统计答案，就是左端点前面比 $\text{lastans}$ 小的和右端点前面比 $\text{lastans}$ 小的和之差。

具体实现可以考虑使用树状数组和链表来实现。

### Code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 100010;

int n , m , a[N] , b[N] , del[N * 2] , vis[N] , head[N];
int top , t[N] , ans[N] , pre[N] , stk[N * 2] , ton[N][2];

struct List
{
    int pre , nxt;
}l[N * 2];

inline int read()
{
    int asd = 0 , qwe = 1; char zxc;
    while(!isdigit(zxc = getchar())) if(zxc == '-') qwe = -1;
    while(isdigit(zxc)) asd = asd * 10 + zxc - '0' , zxc = getchar();
    return asd * qwe;
}

inline void add(int x , int y)
{
    l[x].pre = head[y];
    l[head[y]].nxt = x;
    head[y] = x;
}

inline void delet(int x , int y)
{
    if(x == head[y]) head[y] = l[x].pre;
    l[l[x].pre].nxt = l[x].nxt;
    l[l[x].nxt].pre = l[x].pre;
}

inline int lowbit(int x)
{
    return x & (-x);
}

inline void update(int x)
{
    int sum = b[x];
    while(x <= n)
        t[x] += sum , x += lowbit(x);
}

inline int ask(int x)
{
    int res = 0;
    while(x) res += t[x] , x -= lowbit(x);
    return res;
}

signed main()
{
    n = read();
    for(int i = 1;i <= n;i++)
        a[i] = b[i] = read();
    m = read();
    sort(b + 1 , b + n + 1);
    int q = unique(b + 1 , b + n + 1) - b - 1;
    for(int i = 1;i <= n;i++)
        a[i] = lower_bound(b + 1 , b + q + 1 , a[i]) - b;
    for(int i = 1;i <= m;i++)
    {
        int l = read() , r = read();
        if(l > r) swap(l , r);
        add(i , l) , add(i + m , r);
        del[i] = l , del[i + m] = r;
        vis[i] = 1 , pre[i] = -1;
    }
    while(1)
    {
        bool flag = 0; top = 0;
        for(int i = 1;i <= n;i++)
            t[i] = 0;
        for(int i = 1;i <= n;i++)
        {
            for(int j = head[i];j;j = l[j].pre)
            {
                int kj = (j > m ? j - m : j);
                int x = ans[kj] + 1;
                int y = upper_bound(b + 1 , b + q + 1 , x) - b - 1;
                vis[kj] ^= 1;
                ton[kj][vis[kj]] = ask(y);
                if(vis[kj] == 1)
                {
                    if(a[i] <= y) ton[kj][1] += b[a[i]];
                    ans[kj] = ton[kj][1] - ton[kj][0];
                    if(ans[kj] != pre[kj]) pre[kj] = ans[kj] , flag = 1;
                    else  stk[++top] = kj + m , stk[++top] = kj;
                }
            }
            update(a[i]);
        }
        for(int i = 1;i <= top;i++)
            delet(stk[i] , del[stk[i]]);
        if(!flag) break;
    }
    for(int i = 1;i <= m;i++) cout << ans[i] + 1 << endl;
    return 0;
}

```

---

## 作者：pldzy (赞：2)

[传送门：P4587 [FJOI2016]神秘数](https://www.luogu.com.cn/problem/P4587)

**主席树**

## Solution

思路其实就是一楼大佬的思路，只不过大佬写的有些内容我太弱看不懂，所以来补充一下。

### 1

对于区间 $[l,r]$，将它升序排序后从左往右扫，设当前可以表示出的数为$[1,x]$，$ans$ 为 $(x + 1)$。

显然，对于当前扫到的数 $a_i$，当且仅当它小于等于 $ans$ 时，才对 $ans$ 有用。

用处即将值域扩大到 $[1,x+a_i]$。

因为在原先 $[1,x]$ 的基础上我们可以依次得到 $(1+a_i),(2+a_i),(3+a_i)+\cdots +(x+a_i)$。

所以只用考虑每次在区间 $[l,r]$ 中小于等于 $ans$ 的数。

### 2

按照 1 中的思路，若小于等于 $ans$ 的数的和 $res\geq ans$，则一定有未选的且小于等于 $ans$ 的数，令 $ans=res+1$ 即可。（大佬原话，不难理解。）

反之则说明了答案就是 $ans$。

这样可以使得我们不断去更新 $ans$，直到得出最大的 $ans$。

### 3

按照 2 中的思路，对于每一个查询，我们都要不断去询问区间 $[l,r]$ 中值小于等于 $ans$ 的数，直到找到答案。

所以，要用主席树来维护。**此题的主席树是对值域的划分。**

对于 $root_i$，它的子树维护的是 $a_1$ 到 $a_i$ 中每一个数在值域里的状态。

正因如此，我们才可以查询某一区间内小于等于某数的所有数之和。

具体地，可以看主席树模板：[P3834 【模板】可持久化线段树 2](https://www.luogu.com.cn/problem/P3834)，它也是类似的对值域的划分。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i <= b; ++i)
const int maxn = 1e5 + 5;
const int inf = 1e9;
int n;
int a[maxn];
struct node{
	int l, r;
	int sum;
}t[maxn << 5];
int m;
int lt, rtm;
int tot;
int rt[maxn];

inline int addt(int lst, int l, int r, int k, int d)
{
	int nw = ++tot;
	t[nw] = t[lst], t[nw].sum += d;
	if(l == r) return nw;
	int mid = (l + r) >> 1;
	if(k <= mid) t[nw].l = addt(t[lst].l, l, mid, k, d);
	else t[nw].r = addt(t[lst].r, mid + 1, r, k, d);
	return nw;
}

inline int query(int pl, int pr, /*在 a[pl] 到 a[pr] 这一区间中*/int l, int r,/*当前询问范围*/ int ql, int qr/*权值的合法范围*/)
{
	if(ql <= l and qr >= r) return t[pr].sum - t[pl].sum;
	int mid = (l + r) >> 1, res = 0;
	if(ql <= mid) res += query(t[pl].l, t[pr].l, l, mid, ql, qr);
	if(qr > mid) res += query(t[pl].r, t[pr].r, mid + 1, r, ql, qr);
	return res;
}

int main()
{
	scanf("%d", &n);
	rep(i, 1, n) scanf("%d", &a[i]);
	rep(i, 1, n) rt[i] = addt(rt[i - 1], 1, inf, a[i], a[i]);
	scanf("%d", &m);
	rep(i, 1, m)
	{
		scanf("%d%d", &lt, &rtm);
		int ans = 1;
		while(531)
		{
			int tmp = query(rt[lt - 1], rt[rtm], 1, inf, 1, ans);
			if(tmp >= ans) ans = tmp + 1;
			else break;
		}
		printf("%d\n", ans);
	}
	return 0;
}
```


------------
感谢阅读。

辛苦管理员审核，如有问题烦请指出。

---

## 作者：Prean (赞：2)

遇到一道题，我们该做什么？

打暴力。

此题的暴力是什么？从小到大枚举答案。但这太慢了，需要一个结论来加速一下：

> 若 $ [1,x] $ 都能够被表示出来，新加入一个数 $ y $，若 $ y > x+1 $，那么新的答案仍然是 $ [1,x] $；若 $ y<=x+1 $，则新的答案为 $ [1,x+y] $。

~~不是很严谨，感性理解一下~~

有了这个结论，能够加速枚举答案。

对于一个可行的 $ ans $，我们统计区间中不大于 $ ans $ 的数之和 $ sum $。若 $ sum=ans $，答案就是 $ ans $，否则将 $ ans $ 替换为 $ sum $ 继续枚举。

至于统计数的个数可以使用主席树。

这复杂度咋一看是 $ (\sum a)\log (\sum a) $ 的，其实不然。

假设上一次枚举的数为 $ lst $，这一次枚举的数为 $ ans $，很容易发现这一次的 $ sum $ 包含了大于 $ lst $ 且不大于 $ ans $ 的数  ~~废话~~。但第二部分的和一定大于 $ lst $，也就是说 $ sum > 2lst $，只需要 $ \log (\sum a) $ 次枚举即可。

复杂度就是 $ m\log n\log (\sum a) $ 的啦

~~喜闻乐见的~~ 代码：
```cpp
#include<cstdio>
const int M=1e5+5,N=1e9;
int n,m,tot,root[M];
struct Node{
	int L,R,sum;
}t[M*35];
int Modify(int u,int x,int L=1,int R=N){
	int id=++tot;
	t[id]=t[u];t[id].sum+=x;
	if(L<R){
		int mid=L+R>>1;
		if(x<=mid)t[id].L=Modify(t[u].L,x,L,mid);
		else t[id].R=Modify(t[u].R,x,mid+1,R);
	}
	return id;
}
int Query(int q,int p,int x,int L=1,int R=N){
	if(L==R)return t[p].sum-t[q].sum;
	int mid=L+R>>1;
	if(x<=mid)return Query(t[q].L,t[p].L,x,L,mid);
	else return t[t[p].L].sum-t[t[q].L].sum+Query(t[q].R,t[p].R,x,mid+1,R);
}
signed main(){
	register int i,L,R,x,ans;
	scanf("%d",&n);
	for(i=1;i<=n;++i)scanf("%d",&ans),root[i]=Modify(root[i-1],ans);
	scanf("%d",&m);
	for(i=1;i<=m;++i){
		scanf("%d%d",&L,&R);ans=1;
		while((x=Query(root[L-1],root[R],ans))>=ans)ans=x+1;
		printf("%d\n",ans);
	}
}
```

---

## 作者：chlchl (赞：1)

$28$ 篇题解的题居然没有关闭入口，~~我来水一下省选的题解。~~

## 题意简述
给定 $n$ 个数和 $m$ 个询问，对于每个询问 $l,r$，你需要输出最小的不能被集合 $\{a_l,a_{l+1},\cdots,a_r\}$ 及其子集的和表示出来的数。

## 做法
主席树的简单应用 + 一点点思维。

不会主席树的可以看看 [这里](https://www.luogu.com.cn/blog/hugocaicai/ke-chi-jiu-hua-xian-duan-shu-xue-xi-bi-ji)。

大部分人拿到题目，会先考虑暴力。对于区间 $\lbrack l,r\rbrack$，先排序，然后计算前缀和。若在某个位置 $i$，$sum_i<a_{i+1}$，即从 $l$ 开始前 $i$ 个数的和比第 $i+1$ 个数要小，那么 $sum_i+1\sim a_{i+1}$ 之间的数就都不能被表示出来。

这是个非常显然的结论，你甚至可以从题目的两个例子推出来（~~大雾~~）。

但这么做的时间复杂度是 $O(mn\log n)$ 的，会超时。我们需要优化这个过程。

排序非常浪费时间，所以我们考虑先把排序去掉。这里给出一种更好懂的理解。

我们考虑排好序后的数组：如果没有 $1$，那答案必然是 $2$。这个无论什么方法都很容易判断。所以，如果 $1,2$ 能被表示出来，那么数列中必有 $1$。

接着，排序的意义是什么？就是为了从小到大统计前缀和，找到最小的那个不能被表示出来的数。

前缀和又是什么？$sum_i$ 表示的是前 $i$ 小的数之和。

也就是说，我们可以开一棵值域主席树，存下 $1\sim k$ 的位置中不同值域的数的和，这样就可以基本复刻排序的过程。

然后，刚刚我们判断的依据是前缀和是否小于下一个数。同理，我们可以设当前最多能表示的数是 $ans$。

考虑 $ans+1$ 是否能被表示出来。如果所有小于等于 $ans+1$ 的数加起来，大于等于 $ans$，说明表示出 $ans$ 还没有用完所有数，可以继续表示更大的数。

那我们就令 $ans=$ 求出来的和 $+1$，继续检验能不能被表示出来。

显然，如果不能被表示出来，$ans$ 必然是最小的不能被表示出来的数，直接输出就好。

这样，$ans$ 每次至少翻一倍，加上主席树查询的时间是 $O(\log n)$，最坏时间复杂度是 $O(m\log ^2 n)$，可以通过本题。

记得开 $32$ 倍空间。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 1e5 + 10;
const int M = N * 32;
const ll MAXN = 1e9;
int n, m, len;
ll a[N], vec[N];
ll sz, rt[N], ls[M], rs[M], val[M];

int update(int u, int l, int r, int p, ll v){
	int o = ++sz;
	val[o] = val[u], ls[o] = ls[u], rs[o] = rs[u]; 
	val[o] += v;
	if(l == r)
		return o;
	int mid = (l + r) >> 1;
	if(p <= mid)	ls[o] = update(ls[o], l, mid, p, v);
	else	rs[o] = update(rs[o], mid + 1, r, p, v);
	return o;
}

ll query(int v, int u, int l, int r, int s, int t){ 
    if(l >= s && r <= t)
		return val[v] - val[u];
    int mid = (l + r) >> 1;
	ll res = 0; 
    if(s <= mid)
		res += query(ls[v], ls[u], l, mid, s, t); 
    if(t > mid)
		res += query(rs[v], rs[u], mid + 1, r, s, t); 
    return res; 
} 

int main(){
	scanf("%d", &n);
	for(int i=1;i<=n;i++)
		scanf("%lld", &a[i]);
	for(int i=1;i<=n;i++)
		rt[i] = update(rt[i - 1], 1, MAXN, a[i], a[i]);
	scanf("%d", &m);
	while(m--){
		int l, r;
		ll ans = 1;
		scanf("%d%d", &l, &r);
		while(114514){
			ll now = query(rt[r], rt[l - 1], 1, MAXN, 1, ans);
//			cout << now << endl;
			if(now >= ans)
				ans = now + 1;
			else
				break;
		}
		printf("%lld\n", ans);
	}
	return 0;
} 
```



---

## 作者：DiruiXiao (赞：1)

## [P4587 [FJOI2016]神秘数](https://www.luogu.com.cn/problem/P4587)

**【题意简述】**

给第一个可重复的数字序列 $S$，询问将 $[L,R]$ 区间作为集合，从中选取出所有可能的子集（包括空集），现询问该区间中最小的不能被表示的树。

**【解题思路】**

首先因为有空集，所以答案肯定不是 $0$。

然后做一个证明，假设对于前  $k$  个数能够覆盖 $[1,sum]$，并且该区间内的数呈递增态。

则假如下一个数为 $a_i$， 则可以得到新的区间 $[1,sum]\cup[1+a_i,sum+a_i]$，则显然可以发现，对于 $a_i\le sum+1$ 则都可以更新答案至 $[1,sum+a_i]$，而且对于所有 $a_i$ 小于 $sum$ 都可以作为一个整体加入。而对于当 $a_i>sum$ 时，则答案不变，并且如果当前的 $a_i$ 不成立，则之后的 $a$ 也不会成立。

因此诞生了一个暴力做法，对于每个区间 `sort` 后，设 $lim$ 为 $sum+1$，即 $lim$ 为答案。每次取出小于等于 $lim$ 的值求和，并且更新 $lim$ 值，直到取出的部分的值为 $0$（即无法更新）。边界条件为 $lim$ 初始为 $1$。

考虑维护 $n$ 个值域线段树，第 $i$ 棵树维护前 $i$ 个点在区间 $[L,R]$ 的前缀和，则显然可以用主席树维护这个操作。则每次对区间 $[L,R]$ 中 $1$ 到 $lim$ 的元素求和，如果得到的前缀和大于等于 $lim$ 则意味着可以更新答案至前缀和加 $1$。

则最终计算的时间复杂度为 $O(n\log n+m\log n\log 10^9)$。

**【AC代码】**

```cpp
#include<bits/stdc++.h>
#define MAXN 100005
#define LIM (int)(1e9)
using namespace std;
struct Node{
	int lc, rc, dat;
} tree[MAXN << 5];
int tot, root[MAXN], n, m;

inline int insert(int o, int L, int R, int pos, int val) {
	int p = ++tot; tree[p] = tree[o];
	if (L == R) {
		tree[p].dat += val;
		return p;
	}
	int mid = (L + R) / 2;
	if (pos <= mid) tree[p].lc = insert(tree[o].lc, L, mid, pos, val);
	else tree[p].rc = insert(tree[o].rc, mid + 1, R, pos, val);
	tree[p].dat = tree[tree[p].lc].dat + tree[tree[p].rc].dat;
	return p;
}

inline int query(int u, int L, int R, int l, int r) {
	if (l <= L && R <= r) return tree[u].dat;
	int mid = (L + R) / 2, sum = 0;
	if (l <= mid) sum += query(tree[u].lc, L, mid, l, r);
	if (r > mid) sum += query(tree[u].rc, mid + 1, R, l, r);
	return sum;
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) {
		int val; scanf("%d", &val);
		root[i] = insert(root[i - 1], 1, LIM, val, val);
	}
	scanf("%d", &m);
	while (m--) {
		int L, R, sum = 1; scanf("%d %d", &L, &R);
		while (1) {
			int det = query(root[R], 1, LIM, 1, sum) - query(root[L - 1], 1, LIM, 1, sum);
			if (det >= sum) sum = det + 1;
			else break;			
		}
		printf("%d\n", sum);
	}
	return 0;
}
```



---

## 作者：maruize (赞：1)

#  [FJOI2016]神秘数

考虑 $O(nq\log)$。

对于每个询问，(排序后)从小到大插入，设当前值 $val$，能表示的最大的数 $nw$，那么如果 $val \le nw+1$，那么 $nw+1 \sim nw+val$ 的点都能表示，那么$nw$ 更新为 $nw+val$。

---

**以下做法全是拿各种地方的题解拼凑的**

法一：在线，可以带修，常数大，空间大。

值域倍增分块，**每个块**内维护 $a_1\sim a_n$ 在**该值域**中的数的信息，其余用 null 填充。

- 什么信息呢？为什么是倍增呢？

现在考虑对每个询问动态处理。

我们按照倍增的块从小到大把在 $[l..r]$ 的值加入。

肯定不能一个个加，来看看按倍增分的块有什么性质。

当我们处理到一个块，如果能加入这个块的任何一个节点，一定要 $nw\ge $ 块下界。

现在只考虑这个块中 $[l..r]$ 之间的最小节点的权值，如果不能加则整个询问终止。

那么如果能加呢？

首先 $nw \ge $ 块下界，然后当前块 $val_{\min} \ge $ 下界。

更新后 $nw \ge 2\cdot \text{块下界} = \text{块上界}$。

**所以除了 min 值，整个块的节点都不用考虑，直接加入**

所以维护的信息就是区间 min，区间和，st 表 + 前缀和即可。

换掉 st 可以带修。

时间 $O(n\log n\log \max \{a_i\}+q\log \max \{a_i\})$。

注意**当一个块是空的时候如何处理**。

空间等于时间但空间限制 256Mb 所以**有点卡空间**。

可以用 $O(n)\sim O(1)$ rmq 做到 $O((n+q)\log \max \{a_i\})$。但不是特别必要。

```cpp
int a[N],st[31][N][18],sum[31][N];
#define in(i,k) (i>=(1<<(k-1))&&i<(1<<k))
query(k,l,r):查询第k个块st表l..r的rmq
//build
for(int k=1;k<=30;k++){
    for(int i=1;i<=n;i++)
        if(in(a[i],k))st[k][i][0]=a[i],sum[k][i]=sum[k][i-1]+a[i];
    else st[k][i][0]=1.1e9,sum[k][i]=sum[k][i-1];
    for(int b=1;b<18;b++)
        for(int i=1;i+(1<<(b-1))<=n;i++)//st表经典操作
            st[k][i][b]=min(st[k][i][b-1],st[k][i+(1<<(b-1))][b-1]);
}
//ask
for(int i=1;i<=q;i++){
    int l,r,nw=0;
    scanf("%d%d",&l,&r);//小心空块-------vvvvvvv
    for(int k=0;k<18&&min(query(k,l,r),(1<<k)-1)<=nw+1;k++)
        nw+=sum[k][r]-sum[k][l-1];
    printf("%d\n",nw+1);
}
```



---

法二：离线，不易带修，常数小，空间小，跑得飞快。

考虑离线**将 $a_i$ 从小到大加入**

对于每一个询问，维护当前的$nw$，并以其为排序关键字插入**堆**。
从小到大扫 $a_i$。

对于当前 $a_i$ (作为上文的 $val$ ) (因为有堆)我们知道那些询问区间的 $nw$ 有可能扩展。

那我们暴力取出他们来，利用当前区间和更新再塞回堆去，(动态区间和需要树状数组)。

但是这样时间会爆炸。

考虑对每个询问延迟更新 $nw$，在 $val \le nw+1(past,\text{未及时更新})$ 时该节点一定会被更新，那么就先不更新，让祂待在堆里。

当  $val > nw+1(past,\text{未及时更新})$ 时由于 $nw$ 没有更新所以不知道合不合法，那就更新 $nw$。

- 如果不合法那么更大的 $a_i$ 也无法加入，更新最终答案并从堆中删除。
- 如果 $val \le nw+1(\text{已更新})$ 在把更新后的点重新加入堆。

当一个询问从堆中取出时祂的 $nw$ 会翻倍，

所以时间 $O(n\log q\log \max\{a_i\})$。

注意因为是 lazy 更新，所以**最后要加入一个 $=\infty$ 的val (即令$a_{n+1}=\infty$)**来更新所有撑到最后的询问。

注意扫到一个 $a_i$ 应先检查询问，再将 $a_i$ 插入树状数组。

```cpp
pii a[N];
struct ask{int l,r,id,nw;};
bool operator<(const ask&a,const ask&b){return a.nw>b.nw;}//小根堆
int tree[N],n,m,ans[N];
scanf("%d",&n);
for(int i=1;i<=n;i++)scanf("%d",&a[i].fs),a[i].sc=i;
sort(a+1,a+n+1),a[n+1]=pii(1.1e9,n+1),n++;
scanf("%d",&m);
priority_queue<ask>q;
for(int i=1,l,r;i<=m;i++)
    scanf("%d%d",&l,&r),q.push({l,r,i,0});
for(int i=1;i<=n;i++){
    while(!q.empty()&&q.top().nw+1<a[i].fs){
        ask t=q.top();q.pop();
        t.nw=sum(t.r)-sum(t.l-1);//树状数组
        if(t.nw+1>=a[i].fs)/*t.nw+=a[i].fs,*/q.push(t);
        else ans[t.id]=t.nw;
    }
    add(a[i].sc,a[i].fs);//树状数组
}
for(int i=1;i<=m;i++)printf("%d\n",ans[i]+1);
```



---

法三：主席树，没想，不会。



---

## 作者：FutaRimeWoawaSete (赞：1)

应该被一次牛客的 TG 模拟撞重了，那时候做这道题推了快一大半性质结果没学过主席树报废了……     

其实按理来说，莫队套个权值线段树也能跑一跑，至于时间复杂度的话就玄学吧。   

我们想一下我们的暴力做法。首先先排个序，然后一个个枚举，得到当前可以拼出 $1 \sim res$，如果当前这个数 $Ins$ 小于等于了 $res + 1$，那么我们肯定就可以吧答案扩到 $1 \sim res + Ins$，就相当于当前这个数不属于原来我们拼 $1 \sim res$ 的数，所以直接对每种拼出来的数的方案后面跟一个 $Ins$ 即可。

如果此时这个数大于了 $res + 1$ ，那么 $res + 1$ 就拼不出来了，而由于后面的数比 $Ins$ 更大，所以 $res + 1$ 就是我们的答案。      

接着我们就想到用主席树来维护这个过程，我们可以思考，假若我们此时有一个状态，知道了当前可以拼出 $1 \sim res$，当前考虑是否可以扩展到 $res + 1$，是不是就直接在原来的基础上看一下有没有 $res + 1$ 以内并且曾经没用过的数就可以了啊？    

不过这个过程太慢了，我们考虑优化一下这个方法，这也是我觉得这道题比较难想的一个地方，我们的答案 $ans$ 从 $1$ 开始，每次查找小于等于 $ans$ 的数的和，如果 $sum$ 大于等于 $ans$，就直接 $ans = sum + 1$ 开始下一轮查找。    

我们可以这么理解这个过程，假设前一步我们维护到了答案至 $1 \sim ans$，前一次的区间和就是 $ans$，假如上一次的答案为 $lstans$，那么区间小于 $lstans$ 的数的和为 $ans$，而现在应该对 $ans$ 加上 $[lstans + 1 , ans]$ 之间的数的和，就相当于现在最多可以拼凑出 $ans$ 以内的数的和以内的答案，再判断是否可以继续往后加即可。        

不难看出这个过程中 $ans$ 每次至少增加一倍，时间复杂度 $O(n \log ^ 2 n)$。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
#define int long long
const int Len = 1e5 + 5;
int n,m,a[Len],lsh[Len],rt[Len],top,sum,cnt;
struct node
{
	int l,r,fsum;
}tree[Len * 22];
int clone(int p,int w)
{
	top ++;
	tree[top] = tree[p];
	tree[top].fsum += w;
	return top;
}
int build(int p,int l,int r)
{
	p = ++ top;
	if(l == r) return p;
	int mid = (l + r) >> 1;
	tree[p].l = build(tree[p].l , l , mid);
	tree[p].r = build(tree[p].r , mid + 1 , r);
	return p;
}
int update(int p,int l,int r,int idx)
{
	p = clone(p , lsh[idx]);
	if(l == r) return p;
	int mid = (l + r) >> 1;
	if(idx <= mid) tree[p].l = update(tree[p].l , l , mid , idx);
	else tree[p].r = update(tree[p].r , mid + 1 , r , idx);
	return p;
}
int query(int l,int r,int nl,int nr,int x)
{
	if(l == r) return tree[nr].fsum - tree[nl].fsum;
	int mid = (l + r) >> 1 , Sum = tree[tree[nr].l].fsum - tree[tree[nl].l].fsum;
	if(x <= lsh[mid] || x < lsh[mid + 1]) return query(l , mid , tree[nl].l , tree[nr].l , x);
	else return Sum + query(mid + 1 , r , tree[nl].r , tree[nr].r , x);
}
signed main()
{
	scanf("%lld",&n);
	for(int i = 1 ; i <= n ; i ++) 
	{
		scanf("%lld",&a[i]);
		lsh[i] = a[i];
	}
	sort(lsh + 1 , lsh + 1 + n);
	cnt = unique(lsh + 1 , lsh + 1 + n) - lsh - 1;
	rt[0] = build(0 , 1 , cnt);
	for(int i = 1 ; i <= n ; i ++)
	{
		int Ins = lower_bound(lsh + 1 , lsh + 1 + cnt , a[i]) - lsh;
		rt[i] = update(rt[i - 1] , 1 , cnt , Ins);
	}
	scanf("%lld",&m);
	for(int i = 1 ; i <= m ; i ++)
	{
		int x,y;scanf("%lld %lld",&x,&y);
		int num = 1;
		while(1)
		{
			int res = query(1 , cnt , rt[x - 1] , rt[y] , num);
			if(res >= num) num = res + 1;
			else break;
		}
		printf("%d\n",num);
	}
	return 0;
}
```

---

## 作者：RemiliaScar1et (赞：1)

## P4587 [FJOI2016]神秘数

### 题意简述：

一个可重复数字集合 $S$ 的神秘数定义为最小的不能被 $S$ 的子集的和表示的正整数。例如 $S=\{1,1,1,4,13\}$ ，其神秘树为 $8$ 。

现给定 $n$ 个正整数 $a[1]..a[n]$ ，$m$ 个询问，每次询问给定一个区间$[l,r]$，求由 $a[l],a[l+1],…,a[r]$ 所构成的可重复数字集合的神秘数。

---

### 解析

先探究神秘数的有关性质。

假设我们是把数一个一个插入序列中的(这也是主席树的解题过程)

设当前能组成的数的值域为 $[1,x]$ ，要插入的数为 $a_i$

有如下性质:

1. 当 $a_i>x+1$ 时，$x+1$ 不能被组成，故此时神秘数为 $x+1$

2. 当 $a_i<x+1$ 时，能表示的值域变为 $[1,a_i+x]$  。

若每插入一个 $a_i$ 就新增一个版本，那么对于每个版本：

设它的值域为 $[1,x]$，则答案 $ans=x+1$ 。

此时检查小于等于 $ans$ 的所有数的和 $sum$

若 $ans\leq sum$， 则一定有未选的且小于等于 $ans$ 的数。

则令 $ans = res+1$，重复检查。

若 $ans > sum$，则答案就是 $ans$。

这里维护的并不是权值线段树，离散化什么的也不用了。

code :
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N=1e5+10;

struct node
{
	int lson,rson;
	ll _sum;
} tree[N<<5];
int root[N],tot=0;

int n,m;
int ans=0,res=0;

#define lnode tree[node].lson
#define rnode tree[node].rson
#define DEFMID ll mid=start+end>>1;
#define lnode1 tree[node1].lson
#define rnode1 tree[node1].rson

int insert(int node,ll start,ll end,int x)
{
	int node1=++tot;
	tree[node1]=tree[node];
	tree[node1]._sum+=x;
	if(start==end)
	{
		return node1;
	}
	DEFMID
	if(x<=mid) lnode1=insert(lnode,start,mid,x);
	else rnode1=insert(rnode,mid+1,end,x);

	tree[node1]._sum=tree[lnode1]._sum+tree[rnode1]._sum;
	return node1;
}

ll query(int node1,int node,ll start,ll end,ll l,ll r)
{
	if(l<=start&&end<=r) return tree[node1]._sum-tree[node]._sum;
	DEFMID
	ll ans=0;
	if(l<=mid) ans+=query(lnode1,lnode,start,mid,l,r);
	if(r>mid) ans+=query(rnode1,rnode,mid+1,end,l,r);

	return ans;
}

int main()
{
	scanf("%d",&n);
	for(int i=1; i<=n; i++)
	{
		int x;
		scanf("%d",&x);
		root[i]=insert(root[i-1],1,1e9,x);
	}

	scanf("%d",&m);
	for(int i=1; i<=m; i++)
	{
		int l,r;
		scanf("%d%d",&l,&r);
		ans=1;
		while(1)
		{
			res=query(root[r],root[l-1],1,1e9,1,ans);
			if(res>=ans) ans=res+1;
			else break;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：1saunoya (赞：1)

明白之后 5min 就写好了…自闭…

这题的题意是问你 $[L,R]$ 区间的数字不能构成的数字的最小值…

首先考虑 如果 $[1,x]$ 可以被表示

那么加入一个 $a_i$ 显然 $[1,x+a_i]$ 都可以被表示

有什么好办法呢

~~当然有~~ $O(q * \sum_{i\in[L,R]}{a_i}*[R-L+1])$

（~~雾~~）

区间求和问题啥的考虑主席树，首先我不会证明复杂度，是因为我菜/kk

还是一样的套路 讨论 $[1,x]$

对于区间求 $\sum_{i\in[L,R]}[a_i<=ans]$
$[ans$初值是1$]$

显然此时 $[1,ans-1]$ 都可以表示出来 所以考虑扩大区间使得这个$res = \sum_{i\in[L,R]}[a_i<=ans]$

如果值比 $ans$ 小肯定是不可以构成 $ans+1$ 的 所以无需扩展…

```cpp
#include<bits/stdc++.h>

using ll = long long ;
using namespace std ;

int read() {
  int x = 0 , f = 1 ; char c = getchar() ;
  while(c < '0' || c > '9') { if(c == '-') f = -1 ; c = getchar() ; }
  while(c >= '0' && c <= '9') { x = (x << 1) + (x << 3) + (c & 15) ; c = getchar() ; }
  return x * f ;
}

const int N = 1e5 + 10 ;
const int MAXN = N << 5 ;
const int INF = 1e9 ;
int n , a[N] , rt[N] , ls[MAXN] , rs[MAXN] , sum[MAXN] , cnt = 0 ;
void upd(int pre , int & o , int l , int r , int pos , int val) {
  ls[o = ++ cnt] = ls[pre] ; rs[o] = rs[pre] ; sum[o] = sum[pre] + val ;
  if(l == r) return ; int mid = l + r >> 1 ;
  if(pos <= mid) upd(ls[pre] , ls[o] , l , mid , pos , val) ;
  else upd(rs[pre] , rs[o] , mid + 1 , r , pos , val) ;
}
int query(int a , int b , int l , int r , int L , int R) {
  if(a <= l && r <= b) return (sum[R] - sum[L]) ;
  int mid = l + r >> 1 , ans = 0 ;
  if(a <= mid) ans += query(a , b , l , mid , ls[L] , ls[R]) ;
  if(b > mid) ans += query(a , b , mid + 1 , r , rs[L] , rs[R]) ;
  return ans ;
}
signed main() {
  n = read() ;
  for(int i = 1 ; i <= n ; i ++) a[i] = read() ;
  for(int i = 1 ; i <= n ; i ++) upd(rt[i - 1] , rt[i] , 1 , INF , a[i] , a[i]) ;
  int m = read() ;
  while(m --) {
    int L = read() , R = read() , ans = 1 ;
    while(1) {
      int res = query(1 , ans , 1 , INF , rt[L - 1] , rt[R]) ;
      if(res >= ans) ans = res + 1 ;
      else break ;
    }
    printf("%d\n" , ans) ;
  }
  return 0 ;
}
```

---

## 作者：mrclr (赞：1)

（感觉思路和其他题解小有不同）

看到这题，我第一反应就是NOIP2019D1T2：我会单次$O(n ^ 2)$dp！

然后我就想怎么优化这个dp，以及怎么解决从全局变成区间这个问题……

自然gg了！

换一个思路。

我们先想一个暴力的做法：先把$[L, R]$的数从小到大排序，维护一个$x$，表示$[1, x]$的数都能被凑出来，$x$初值等于0.
考虑从前往后扫，对于每一个$a_i$，如果$a_i \leqslant x + 1$，那么我们就能凑出$1, x + a_i$的数，否则$x$就是当前能凑出的最大的数。这样单次询问是$O(nlogn)$（排序复杂度）的。

接下来考虑优化，对于当前能凑出的$x$，可能有很多没有扫到的$a_i$都小于等于$x + 1$。那么我们索性把这些数都加进去，令这些数的和为$t$，那么$x = x + t$。边界条件就是$t = 0$。

为了省去排序，在全局条件下可以用权值线段树，支持一段连续的值域求和。在区间条件下，换成主席树即可。

不过实际上可以更简单。我们直接求小于等于$x + 1$的所有数的前缀和，如果这些数还是等于$x$的话，说明$x$就是能凑出来的最大的数了，退出；否则令$x = sum$。

答案就是$x + 1$。
```c++
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<vector>
#include<stack>
#include<queue>
#include<assert.h>
using namespace std;
#define enter puts("") 
#define space putchar(' ')
#define Mem(a, x) memset(a, x, sizeof(a))
#define In inline
typedef long long ll;
typedef double db;
const int INF = 0x3f3f3f3f;
const db eps = 1e-8;
const int maxn = 1e5 + 5;
const int maxt = 1e7 + 5;
const int Max = 1e9;
In ll read()
{
  ll ans = 0;
  char ch = getchar(), last = ' ';
  while(!isdigit(ch)) last = ch, ch = getchar();
  while(isdigit(ch)) ans = (ans << 1) + (ans << 3) + ch - '0', ch = getchar();
  if(last == '-') ans = -ans;
  return ans;
}
In void write(ll x)
{
  if(x < 0) x = -x, putchar('-');
  if(x >= 10) write(x / 10);
  putchar(x % 10 + '0');
}
In void MYFILE()
{
#ifndef mrclr
  freopen(".in", "r", stdin);
  freopen(".out", "w", stdout);
#endif
}

int n, m;
struct Tree
{
  int ls, rs, l, r;
  int sum;
}t[maxt];
int root[maxn], tcnt = 0;
In void insert(int old, int& now, int l, int r, int val)
{
  t[now = ++tcnt] = t[old];
  t[now].sum += val;
  if(l == r) return;
  int mid = (l + r) >> 1;
  if(val <= mid) insert(t[old].ls, t[now].ls, l, mid, val);
  else insert(t[old].rs, t[now].rs, mid + 1, r, val);
}
In int query(int old, int now, int l, int r, int id)
{
  if(l == r) return t[now].sum - t[old].sum;
  int mid = (l + r) >> 1;
  if(id <= mid) return query(t[old].ls, t[now].ls, l, mid, id);
  else return t[t[now].ls].sum - t[t[old].ls].sum + query(t[old].rs, t[now].rs, mid + 1, r, id);
}

int main()
{
  //MYFILE();
  n = read();
  for(int i = 1; i <= n; ++i) insert(root[i - 1], root[i], 1, Max, read());
  m = read();
  for(int i = 1; i <= m; ++i)
    {
      int L = read(), R = read();
      ll ans = 0;
      while('H' + 'A' + 'H' + 'A')
	{
	  ll tp = query(root[L - 1], root[R], 1, Max, ans + 1);
	  if(tp > ans) ans = tp;
	  else break;
	}
      write(ans + 1), enter;
    }
  return 0;
}
```

---

## 作者：PosVII (赞：1)

**前言**

------------

考场上想的 $O(n\sqrt{n}\log n)$ 做法，因为不太会分块，所以代码比较难看。但是调整块长后变最优解第二，说明常数挺小。

**思路**

------------

$O(n\sqrt{n}\log n\log v)$ 做法

------------


不难想就是一个使 $ans = 0$，然后进行很多次 $ans = \Sigma_{i=l}^{r}[a_{i} \leq ans+1] \times a_{i}$ 直到 $ans$ 不变，发现第 $i$ 次操作过后如果没有结束则 $2^i-1 \leq ans$，也就是说最多执行 $\log v$ 次操作。每次询问暴力来做还是 $O(n)$ 的，考虑对数据离散化后分块，每个整块维护数值大小在其块内的前缀和，散块需要用 vector 存储每个数值在数组中出现的下标然后二分查找出现次数。

$O(n\sqrt{n}\log n)$ 做法

------------

发现这些询问都是连续的，考虑一次询问解决，其实就是使询问的右端点一直变直到结束，不难发现约等于询问一次，还是 $O(\sqrt{n}\log n)$ 的。

**code**

------------

```
#include<bits/stdc++.h> 
using namespace std;
template<typename G> inline void read(G &x) {x=0;G f=1;char ch=getchar();while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();if(ch=='-') f=-1,ch=getchar();while(ch>='0'&&ch<='9') {x=x*10+(ch^48);ch=getchar();}x*=f;}
template<typename G> inline void write(G x) {
	if(x<0) putchar('-'),x=-x;
	if(x>=10) write(x/10);
	putchar(x%10+'0');
}
const int MAXN=1e5+5,MAXM=405;
struct node{
	int l,r,idx;
}q[MAXN];
bool cmp(node x,node y) {
	return x.r<y.r;
}
int sum[MAXM],opt[MAXN],lst,ans,d[MAXM][MAXN];
int sqn,b[MAXN],pos[MAXN];
int n,m,a[MAXN],l,r,now,le[MAXM],ri[MAXM],tot;
vector<int> v[MAXN];
signed main() {
	read(n);
	for(int i=1;i<=n;++i) read(a[i]),b[i]=a[i];
	sort(b+1,b+1+n);
	int cnt=unique(b+1,b+1+n)-b-1;sqn=sqrt(n);le[1]=1;
	for(int i=2;i<=cnt;++i) {
		if(!le[(i+sqn-1)/sqn]) le[(i+sqn-1)/sqn]=i;
		ri[(i+sqn-1)/sqn]=i;
	}
	tot=(cnt+sqn-1)/sqn;
	for(int i=1;i<=n;++i) {
		a[i]=lower_bound(b+1,b+1+cnt,a[i])-b;
		d[(a[i]+sqn-1)/sqn][i]=b[a[i]];
		for(int j=1;j<=tot;++j) d[j][i]+=d[j][i-1];
	}
	read(m);
	for(int i=1;i<=m;++i) {
		read(q[i].l),read(q[i].r),q[i].idx=i;
	}
	sort(q+1,q+1+m,cmp);int las=1;
	for(int i=1;i<=m;++i) {
		for(int j=las;j<=q[i].r;++j) {
			v[a[j]].emplace_back(j);
		}
		las=q[i].r+1;ans=0,now=1,lst=0;
		while(now<=tot) {
			if(b[ri[now]]<=ans+1) {
				ans+=d[now][q[i].r]-d[now][q[i].l-1];
				++now;
				continue;
			}
			lst=0;
			for(int j=le[now];j<=ri[now];++j) {
				if(b[j]>ans+1) goto end;
				if(b[ri[now]]<=ans+1) {
					ans+=d[now][q[i].r]-d[now][q[i].l-1]-lst;
					break;
				}
				int k=v[j].end()-lower_bound(v[j].begin(),v[j].end(),q[i].l);
				ans+=k*b[j];
				lst+=k*b[j];
			}
			++now;
		}
		end:;
		opt[q[i].idx]=ans+1;
	}
	for(int i=1;i<=m;++i) write(opt[i]),putchar('\n');
	return 0;
}
```

---

## 作者：SuBtitle (赞：0)

[P4587 神秘数](https://www.luogu.com.cn/problem/P4587)

#### 写在前面

看了很多题解，感觉很牛逼，但也很懵逼，~~本蒟蒻表示连主席树是干什么的都不知道啊（泪~~

## 分析

- 首先考虑暴力

  - 对于 $a_1\sim a_i$，如果已知 $1\sim x$ 可以表示，那么新增加一个数 $a_{i+1}$，显然的，可以将 $a_{i+1}$ 加上已经可以表示的数，再包括他本身，进而可以表示 $a_{i+1}\sim a_{i+1}+x$，所以如果 $a_{i+1}\le x+1$，那就可以表示 $1\sim a_{i+1}+x$。

  - 于是就有了一个暴力的做法，将每次询问的区间排序，$sum$ 初始为 $0$，每次判断 $a_i\le sum+1$，为真则 $sum+=a_i$，否则答案就为 $sum+1$，单次操作时间复杂度 $O(nlogn)$。
- 另一种形式的暴力
  - 考虑不将区间排序，初始化 $ans$ 为 $1$，每次扫描区间，令 $tmp=\sum\limits_{a_i\le ans}a_i$，如果 $tmp+1> ans$，说明 $tmp+1$ 更优，则 $ans=tmp+1$，否则 $ans$ 就为最后的答案。
  - 这样做的单次操作时间复杂度也是 $O(nlogn)$，但不同的是，在求 $tmp$ 的过程中，实际上就是求值域在 $1\sim ans$ 的 $a_i$ 的和，这个过程就可以用到一种牛皮的数据结构
- 关于主席树
  - 主席树实际上就是专门求在某一段区间内的某一段值域的数的权值和的数据结构（声明：本人蒟蒻一枚，主席树也是刚学，如果主席树有其他的用法，还望大佬科普）。
  - 主席树的原理简单来说，就是保存了每一个 $1\sim r$ 的值域的线段树，然后再用类似前缀和的相减，用 $1\sim r$ 的线段树的节点减去 $1\sim l-1$ 的线段树的节点，就得到了 $l\sim r$ 的对应节点。
  - 至于具体的实现，就只能参考其他的巨巨了~~（或者你可以看看我的码）~~，因为我也是一枚蒟蒻啊啊啊。
- 最后我们就可以先将所有数都放到主席树里面，再用主席树来实现求 $tmp$ 的过程了。（注意主席树的数组大小）

## 代码

```c++
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

const int N=1e5+10;
int tot,root[N],n,m,a[N];

//---------------主席树---------------

struct node
{
	int ls,rs,val;
}rt[N*40];

void change(int &now,int p,int tl,int tr,int x,int v)	//tl和tr是树上节点的左右端点
{
	now=++tot,rt[now]=rt[p],rt[now].val+=v;
	if(tl==tr) return;
	int mid=tl+tr>>1;
	if(x<=mid) change(rt[now].ls,rt[p].ls,tl,mid,x,v);
	else change(rt[now].rs,rt[p].rs,mid+1,tr,x,v);
}

int query(int lp,int rp,int tl,int tr,int l,int r)	//lp和rp是询问的区间对应的根节点，l和r是询问的值域
{
	if(l<=tl&&tr<=r)
		return rt[rp].val-rt[lp].val;
	int mid=tl+tr>>1,ret=0;
	if(l<=mid) ret+=query(rt[lp].ls,rt[rp].ls,tl,mid,l,r);
	if(r>mid) ret+=query(rt[lp].rs,rt[rp].rs,mid+1,tr,l,r);
	return ret;
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;++i)
		change(root[i],root[i-1],1,1000000000,a[i],a[i]);
	int x,y,ans;
	scanf("%d",&m);
	while(m--)
	{
		ans=1;
		scanf("%d%d",&x,&y);
		while(1)
		{
			int tmp=query(root[x-1],root[y],1,1000000000,1,ans);
			if(tmp>=ans) ans=tmp+1;
			else break;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```



---

## 作者：hgzxwzf (赞：0)

**可持久化权值线段树**

## 解题思路：
对于一组查询 $(L,R)$，如果现在的答案是 $ans$，那么就说明现在能表示的数值域一定是 $[1,ans-1]$，所以我们找到所有满足 $i\in[L,R]\bigcap a_i\in[1,ans-1]$ 的$i$。

然后得到 $res=\sum a_i$，如果 $res\ge ans$，就说明任何 $j\in[ans+1,res]$ 都能被表示。

因为 $[1,ans]$ 内的数我们都可以表示出来，那么 $res$ 减去 $[1,ans]$ 内的任意一个数都可以被表示出来，所以有：

$res-1$ 可以被表示出来，$res-2$ 可以被表示出来 $\cdots$ $res-ans$ 可以被表示出来。

接下来思考怎么去维护。

看到维护在区间里选数，又要维护满足某一特定值域的数字和，可以用可持久化权值线段树去维护。

对于 $i\in[L,R]$ 就用可持久化维护，对于 $a_i\in[1,ans]$ 的区间和就用权值线段树去维护。

```
#include<cstdio>
#include<algorithm>
#include<cstring>
#define rep(x,y,z) for(int x=y;x<=z;x++)
#define per(x,y,z) for(int x=z;x>=y;x--)
using namespace std;
const int N=1e5+10,inf=1e9;
struct tree
{
	int ls,rs,sum;
	#define ls(p) t[p].ls
	#define rs(p) t[p].rs
	#define sum(p) t[p].sum
}t[N<<5];
int idx,root[N];
void Insert(int pre,int &p,int l,int r,int pos,int x)
{
	p=++idx;
	t[p]=t[pre];
	sum(p)+=x;
	if(l==r) return ;
	int mid=l+r>>1;
	if(pos<=mid) Insert(ls(pre),ls(p),l,mid,pos,x);
	else Insert(rs(pre),rs(p),mid+1,r,pos,x);
}
int query(int pre,int p,int l,int r,int ql,int qr)
{
	if(ql<=l&&qr>=r) return sum(p)-sum(pre);
	int mid=l+r>>1,res=0;
	if(ql<=mid) res+=query(ls(pre),ls(p),l,mid,ql,qr);
	if(qr>mid) res+=query(rs(pre),rs(p),mid+1,r,ql,qr);
	return res;
}
int main()
{
	int n,a,m;
	scanf("%d",&n);
	rep(i,1,n) scanf("%d",&a),Insert(root[i-1],root[i],1,inf,a,a); 
	scanf("%d",&m);
	while(m--)
	{
		int l,r;
		scanf("%d%d",&l,&r);
		int ans=1;
		for(;;)
		{
			int res=query(root[l-1],root[r],1,inf,1,ans);
			if(res>=ans) ans=res+1;
			else break;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：灵华 (赞：0)

# P4587 [FJOI2016]神秘数

题目大意：

给出一个正整数序列 $a$，每次询问用序列上的一段区间中的数不能通过加和得到的最小的数。



解法：

要求不能得到的最小的数，那么证明比这个数小的都能组成，不然这个数就不是最小的不能组成的数，然后我们考虑如何用一段区间里的数求出这段从一开始连续的区间。

先让这段区间里的数从小到大排序，假设我们当前枚举到第 $i$ 个数对答案的影响，那么如果在第 i 个之前，能拼出 $1-a_{i} -1$ 中所有的数，那么就让 $a_i$ 统计到答案中去，如果当某一时刻的 $a_i$ 的值比当前能够拼出的最大答案要大，那么答案就是当前能够拼出的最大值加一。

考虑如何对这个区间进行排序，可以主席树进行维护，对这个数列建一棵可持久化权值线段树，于是问题就变成了在这个区间里，每次求第 $i$ 大的值，判断在此之前是否可以凑出比当前值小的所有值，如果可以，继续累加，否则就输出答案。

```
可以使用主席数的理由：因为主席树的思想类似于前缀和，但是前缀和维护的是一个数列的值的和，
而主席树还维护了每个值的个数，这样子我们就能通过左右区间分别代表的那棵权值线段树上的每个节点进行求差，
从而得出这段区间里的值在当前节点的覆盖范围中的个数，就可以得到这个区间里第 i 大的数。
```

Code：

```c++
#include <iostream>
#include <cstdio>
using namespace std ;

const int A = 1e9 ;
int n , m , cnt ;
int t[3200005] , ls[3200005] , rs[3200005] , s[3200005] , sum[3200005] ;

int insert ( int pre , int l , int r , int x )
{
	int rt = ++ cnt ;
	ls [ rt ] = ls [ pre ] ;
	rs [ rt ] = rs [ pre ] ;
	s [ rt ] = s [ pre ] + 1 ;
	sum [ rt ] = sum [ pre ] + x ;
	if ( l == r )
		return rt ;
	int mid = ( l + r ) >> 1 ;
	if ( mid >= x )
		ls [ rt ] = insert ( ls [ pre ] , l , mid , x ) ;
	else
		rs [ rt ] = insert ( rs [ pre ] , mid + 1 , r , x ) ;
	return rt ;
}

int query ( int u , int v , int l , int r , int x , int y )
{
	int p = s [ v ] - s [ u ] , q = sum [ v ] - sum [ u ] ;
	if ( x <= l && r <= y )
		return q ;
	if ( !p )
		return 0 ;
	int mid = ( l + r ) >> 1 , res = 0 ;
	if ( mid >= x )
		res = query ( ls [ u ] , ls [ v ] , l , mid , x , y ) ;
	if ( mid < y )
		res += query ( rs [ u ] , rs [ v ] , mid + 1 , r , x , y ) ;
	return res ;
}

int main ( )
{
	cin >> n ;
	for ( int i = 1 ; i <= n ; ++ i )
	{
		int x ; cin >> x ;
		t [ i ] = insert ( t [ i - 1 ] , 1 , A , x ) ;
	}
	cin >> m ;
	for ( int i = 1 ; i <= n ; ++ i )
	{
		int x , y , be = 0 , qs = 0 ;
		cin >> x >> y ;
		while ( 1 )
		{
			int res = query ( t [ x - 1 ] , t [ y ] , 1 , A , be + 1 , qs + 1 ) ;
			if ( res )
			{
				be = qs + 1 ;
				qs += res ;
			}
			else
				break ;
		}
		cout << qs + 1 << endl ;
	}
	return 0 ;
}
```

---

## 作者：苏玖兮 (赞：0)

[可能更好的阅读体验](https://www.luogu.com.cn/blog/Shmily-blog/solution-p4587)
## 题目大意
给定长为$N$一个序列，每次询问一个区间，求最小的不能表示为由区间内若干个（可以是$0$个）数的和的非负整数。

## 思路
考虑一个可重集合$S$，设抽取$S$中若干个数相加可以得到的数的集合为$[0,x]$,则目前无法得到的最小非负整数 $Ans=x+1$ 现在考虑添加一个数 $A_i$ 

- 若 $A_i<=x+1$ 则原先可以表示的$0,1,2,3,...x$统统可以加上一个$A_i$,变成$A_i,A_i+1,A_i+2...A_i+x$,这时加上原本的序列$[0,x]$我们可以表示的序列就扩展成为$[0,A_i+x]$,$Ans=A_i+1+x$

- 若 $A_i$ >$x+1$ 则无论如何也拼凑不出
$Ans=x+1$

进一步考虑，对于一个还未发展的数列，我们的取值范围是$[0,x]$，$x=1,Ans=1$，我们可以把权值$<=Ans$的数字加起来，和设为$y$
- 如果这时$ans<=y$，就是说除了凑成$[0,x]$的数外，我们还能找出**至少一个数**$<=Ans$，这样取数集合就可以扩展为$[0,y]$；$Ans=y+1$

- 如果这时$Ans>y$，就是说除了凑成$[0,x]$的数外，我们找不出任何一个数字了，这样取数集合是$[0,x]$,$Ans=x+1$我们就取不到了


我们可以依据这种方法求$Ans$，建一棵权值线段树，要维护区间和的话，用主席树就可以了.

至于复杂度，容易发现这样做每次$Ans$都是成倍增加的，所以最终复杂度为
复杂度$O(N\log(\sum A_i)+M\log^2(\sum A_i))$


```
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,m,a[N],tot,root[N],ans,maxx=1e9;
struct SegmentTree
{
	int lc,rc,sum;
	#define lc(p) t[p].lc
	#define rc(p) t[p].rc
	#define sum(p) t[p].sum
}t[N<<5];
int insert(int now,int l,int r,int x)
{
	int p=++tot;
	t[p]=t[now];
	if(l==r)
	{
		sum(p)=sum(now)+x;
		return p;
	}
	int mid=(l+r)>>1;
	if(x<=mid) lc(p)=insert(lc(now),l,mid,x);
	else rc(p)=insert(rc(now),mid+1,r,x);
	sum(p)=sum(lc(p))+sum(rc(p));
	return p;
}
int ask(int p,int q,int l,int r,int x)//查询a[li]~a[ri]中小于等于x的数的和
{
	if(x>=r) return sum(q)-sum(p);
	int mid=(l+r)>>1;
	if(x<=mid) return ask(lc(p),lc(q),l,mid,x);
	return sum(lc(q))-sum(lc(p))+ask(rc(p),rc(q),mid+1,r,x);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
		root[i]=insert(root[i-1],1,maxx,a[i]);
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		int l,r,res,ans=1;
		scanf("%d%d",&l,&r);
		while(1)
		{
			res=ask(root[l-1],root[r],1,maxx,ans);
			if(res>=ans) ans=res+1;
			else break;
		}
		printf("%d\n",ans);
	}
}
```

---

## 作者：lcjqwq (赞：0)

### Description 

$n$ 个数的序列，每次询问一个区间，求最小的一个数使得不能用这个区间中的数之和表示。

$n \leq 10^5, \sum a_i \leq 10^9$

### Solution

~~第一次用数组写数据结构真短啊~~

考虑只有一次询问怎么做

把给定的区间内的数排序，从小到大扫一遍。

如果一个数比他之前的数之和至少大了 $1$ ，那么答案就是和 + 1

否则就可以把$[1,\text{前缀和}]$ 都表示出来（感性理解很容易）

这道题怎么做也就显然了起来。只需要用主席树维护区间中小于等于某个数的数之和即可。流程如下

当前答案是 $a$，令 $S$ 是区间中 $\leq a$ 的数之和  

1. 如果 $S < a$ 则 $a$ 就是最后的答案
2. 否则 让 $a = S+1$ 然后重复此操作

最开始的时候 $a=1$

这样做的话 $a$ 每次都会翻一倍，所以最后的总复杂度是  $O(m \log n \log \sum a_i)$

### Code

[看代码戳这里](https://www.cnblogs.com/acfunction/p/10283022.html)




---

## 作者：_121017_ (赞：0)

# 题目简介
一道很好的主席树的题。
# 思路
不妨假设一个区间 $[x,y]$ 中所有的元素都排好了序，那么所有的 $a[x,y]$ 都可以表示出来，所有的 $a[x,y]+a[x,y]$ 也都可以表示出来。如果一个数比 $[x,y]$ 中的任何一个元素小，那么它就是无法被表示出来的。所以我们判断一个数可不可以被表示出来只需要判断比它小的数以及比它小的可表示出的数能否表示出它即可。

而我们又该如何判断一个数能否被表示出来呢？只要比较区间内比它小的数之后是否比它大即可，因为前面我们已经知到所有的 $a[x,y]$ 都可以被表示出来了。

看到这里，相信大家已经知道本题的算法了，没错，就是大名鼎鼎的**主席树**。

由于本题需要用到**权值线段树**，不会的先做了[这道题](https://www.luogu.com.cn/problem/P3834)再食用本题解。

# code
```cpp
#include<bits/stdc++.h>
#define mid (l+r)/2
#define ri register int
using namespace std;
int n,m,node,cnt;
int a[1000005],root[1000005];
struct Node{
	int l;
	int r;
	int data;
}tree[1000005*32]; 
void change(int &p,int pre,int l,int r,int x){
	p=++node;
	tree[p].l=tree[pre].l;
	tree[p].r=tree[pre].r;
	if(l==r){
		tree[p].data=tree[pre].data+x;
		return;
	}
	if(x<=mid) change(tree[p].l,tree[p].l,l,mid,x);
	else change(tree[p].r,tree[p].r,mid+1,r,x);
	tree[p].data=tree[tree[p].l].data+tree[tree[p].r].data;
}
int ask(int u,int v,int l,int r,int x){
	if(x>=r) return tree[v].data-tree[u].data;//如果当前区间最大的数都比x小，直接返回区间和
	if(x<=mid) return ask(tree[u].l,tree[v].l,l,mid,x);//否则递归左区间
	else return tree[tree[v].l].data-tree[tree[u].l].data+ask(tree[u].r,tree[v].r,mid+1,r,x);//如果右子树未知的话，左子树则肯定已知
}
int main(){
	scanf("%d",&n);
	for(ri i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	for(ri i=1;i<=n;i++){
		change(root[i],root[i-1],1,1e9,a[i]);
	}
	scanf("%d",&m);
	for(ri i=1;i<=m;i++){
		int l,r,res,ans=1;
		scanf("%d%d",&l,&r);
		while(!(1+1!=1+1)){
			res=ask(root[l-1],root[r],1,1e9,ans);
			if(res>=ans) ans=res+1;
			else break;
		}
		printf("%d\n",ans);
	}
	return 0;
}


```

---


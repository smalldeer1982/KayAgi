# [TJOI2018] 智力竞赛

## 题目描述

小豆报名参加智力竞赛，他带上了 $n$ 个好朋友作为亲友团一块来参加比赛。比赛规则如下：

一共有 $m$ 道题目，每个人都有 $1$ 次答题机会，每次答题为选择一道题目回答，在回答正确后，可以继续回答这个题目的后续题目，直到答错题目或者没有后续题目。

每个问题都会有一个价值，比赛最后参赛选手获得的奖励价值等价于该选手和他的亲友团没有回答的问题中的最低价值。

我们现在知道小豆和他的亲友团实力非常强，能够做出这次竞赛中的所有题目。

小豆想知道在知道题目和后续题目的条件下，他最大能获得的价值是多少？

## 说明/提示

对于 $10\%$ 的数据，有 $1<n,m\leq10$。

对于 $20\%$ 的数据，有 $1<n,m\leq100$。

对于 $100\%$ 的数据，有 $1<n\leq50,1<m\leq500,v_i\leq10^9,k_i,a_{i,j}\leq m$。

## 样例 #1

### 输入

```
1 3
1 0
2 1 3
3 0```

### 输出

```
AK```

## 样例 #2

### 输入

```
1 6
1 2 2 3
2 1 4
3 1 4
4 1 6
5 0
6 0```

### 输出

```
5```

# 题解

## 作者：Mychael (赞：12)

## 题目链接 ##
[洛谷P4589](https://www.luogu.org/problemnew/show/P4589)
题意可能不清，就是给出一个带权有向图，选出$n + 1$条链，问能否全部点覆盖，如果不能，问不能覆盖的点权最小值最大是多少
## 题解 ##
如果要问全部覆盖，就是经典的可重点的DAG最小路径覆盖，floyd求出传递闭包后跑二分图最大匹配即可
如果不能全部覆盖，就二分答案，看看能否覆盖掉比二分出来的值小的所有点

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<map>
#define Redge(u) for (int k = h[u],to; k; k = ed[k].nxt)
#define REP(i,n) for (int i = 1; i <= (n); i++)
#define mp(a,b) make_pair<int,int>(a,b)
#define cls(s) memset(s,0,sizeof(s))
#define cp pair<int,int>
#define LL long long int
using namespace std;
const int maxn = 505,maxm = 100005,INF = 1000000000;
inline int read(){
	int out = 0,flag = 1; char c = getchar();
	while (c < 48 || c > 57){if (c == '-') flag = -1; c = getchar();}
	while (c >= 48 && c <= 57){out = (out << 3) + (out << 1) + c - 48; c = getchar();}
	return out * flag;
}
int G[maxn][maxn],g[maxn][maxn],val[maxn],b[maxn],tot,n,m;
int lk[maxn],vis[maxn];
bool find(int u){
	REP(i,n) if (g[u][i] && !vis[i]){
		vis[i] = true;
		if (!lk[i] || find(lk[i])){
			lk[i] = u; return true;
		}
	}
	return false;
}
bool check(int v){
	int cnt = 0;
	REP(i,n) if (val[i] < v) cnt++;
	REP(i,n) REP(j,n)
		if (val[i] < v && val[j] < v) g[i][j] = G[i][j];
		else g[i][j] = 0;
	cls(lk);
	REP(i,n) if (val[i] < v){
		cls(vis); if (find(i)) cnt--;
	}
	return cnt <= m + 1;
}
int main(){
	m = read(); n = read(); int tmp;
	REP(i,n){
		b[i] = val[i] = read();
		tmp = read();
		while (tmp--) G[i][read()] = true;
	}
	REP(k,n) REP(i,n) REP(j,n) G[i][j] |= (G[i][k] & G[k][j]);
	sort(b + 1,b + 1 + n); tot = 1;
	for (int i = 2; i <= n; i++) if (b[i] != b[tot]) b[++tot] = b[i];
	for (int i = 1; i <= n; i++) val[i] = lower_bound(b + 1,b + 1 + tot,val[i]) - b;
	REP(i,n) REP(j,n) g[i][j] = G[i][j];
	if (check(tot + 1)){puts("AK"); return 0;}
	int l = 1,r = tot,mid;
	while (l < r){
		mid = l + r + 1 >> 1;
		if (check(mid)) l = mid;
		else r = mid - 1;
	}
	printf("%d\n",b[l]);
	return 0;
}

```

---

## 作者：C20203030 (赞：4)

没见过，我都能切省选题了 $......$

## 一、题目

[点此看题](https://www.luogu.com.cn/problem/P4589)

## 二、解法

我看了题解区，好像没有人写 __有源汇上下界可行流__ ，最大流会伤心的。

先说一下建图方法，因为本题的限制在点上，所以我们使用 __拆点__ 的方法：

- 源点连 $\tt jzm$ ，容量范围为 $[0,n+1]$ ，表示可以提供这么多流量。
- $\tt jzm$ 连每个 $i$ ，容量范围为 $[0,inf]$ ，表示从这些点开始走。
- 二分一个 $x$ ，如果 $val[i]<x$ ，说明这些点必须走一遍，$i$ 连 $i'$ ，容量范围为 $[1,inf]$
- $i'$ 连汇点，容量范围为 $[0,inf]$ ，表示结束。

然后对这个图跑有源汇上下界可行流来判断 $x$ 的情况下有没有解，注意最大流一定要加当前弧优化，要不然直接 $\tt T$ 成 $30$ 分。加了当前弧之后还跑得挺快的。

什么，你不会带上下界的网络流。~~那还不去学~~：[这里](https://www.cnblogs.com/C202044zxy/p/14349814.html)

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
const int M = 1010;
const int inf = 0x3f3f3f3f;
int read()
{
	int x=0,f=1;char c;
	while((c=getchar())<'0' || c>'9') {if(c=='-') f=-1;}
	while(c>='0' && c<='9') {x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
int n,m,k,s,t,ss,tt,zy,tot,ans,dis[M],cur[M],f[M],v[M],a[M][M];
struct edge
{
	int v,c,next;
	edge(int V=0,int C=0,int N=0) : v(V) , c(C) , next(N) {}
}e[M*M];
void add(int u,int v,int c)
{
	e[++tot]=edge(v,c,f[u]),f[u]=tot;
	e[++tot]=edge(u,0,f[v]),f[v]=tot;
}
int bfs()
{
	queue<int> q;
	memset(dis,0,sizeof dis);
	q.push(s);dis[s]=1;
	while(!q.empty())
	{
		int u=q.front();q.pop();
		if(u==t) return 1;
		for(int i=f[u];i;i=e[i].next)
		{
			int v=e[i].v;
			if(!dis[v] && e[i].c>0)
			{
				dis[v]=dis[u]+1;
				q.push(v);
			}
		}
	}
	return 0;
}
int dfs(int u,int ept)
{
	if(u==t) return ept;
	int flow=0,tmp=0;
	for(int &i=cur[u];i;i=e[i].next)
	{
		int v=e[i].v;
		if(dis[v]==dis[u]+1 && e[i].c>0)
		{
			tmp=dfs(v,min(ept,e[i].c));
			if(!tmp) continue;
			flow+=tmp;
			e[i].c-=tmp;
			e[i^1].c+=tmp;
			ept-=tmp;
			if(!ept) break;
		}
	}
	return flow;
}
int check(int x)
{
	tot=1;int res=0;
	ss=0;tt=2*m+1;zy=2*m+2;s=2*m+3;t=2*m+4;
	for(int i=0;i<=t;i++) f[i]=0;
	add(ss,zy,n);//用来限流 
	for(int i=1;i<=m;i++)
	{
		add(zy,i,inf);
		add(i+m,tt,inf);
		add(i,i+m,inf);
		if(v[i]<x)
		{
			add(i,t,1);
			add(s,i+m,1);
			res++;
		}
		for(int j=1;j<=a[i][0];j++)
			add(i+m,a[i][j],inf);
	}
	add(tt,ss,inf);//环流
	while(bfs())
	{
		for(int i=0;i<=t;i++) cur[i]=f[i];
		res-=dfs(s,inf);
	}
	return res==0;//一定要满流 
}
void dich(int l,int r)
{
	if(l>r) return ;
	int mid=(l+r)>>1;
	if(check(mid))
	{
		ans=mid;
		dich(mid+1,r);
	}
	else dich(l,mid-1);
}
signed main()
{
	n=read()+1;m=read();
	for(int i=1;i<=m;i++)
	{
		v[i]=read();a[i][0]=read();
		for(int j=1;j<=a[i][0];j++)
			a[i][j]=read();
	}
	dich(1,inf);
	if(ans==inf) puts("AK");
	else printf("%d\n",ans);
}
```

---

## 作者：a2956331800 (赞：4)

#### 首先补充一下题意

- 后继关系不构成环

- 一个题可以重复回答

理解错题的先回去思考一会再往下看~~或者秒了这题~~

### 一句话题意

对于一个$DAG$，选$n+1$条可相交的链进行覆盖，**最大化**没有被覆盖的点的权值

显然我们可以把点按点权排序，然后二分能覆盖到哪些点

#### 注意大于$mid$的点不能直接扔掉

见[这个讨论](https://www.luogu.org/discuss/show/106652)，如果处理时直接把不要求覆盖的点扔到会挂（~~然而数据没卡可以不管~~）

------------

然后这个题就转化成了经典题目

$DAG$的最小**可相交**链覆盖

然而我只想讲一个非标解，关于$DAG$的最小链覆盖[这个博客](https://www.cnblogs.com/justPassBy/p/5369930.html)讲的~~很~~（相对）详细

- 解释下$floyd$传递闭包

就是用类似$floyd$求最短路的做法求出每个点能**到达**的点集

把$floyd$最短路中的$dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j])$改成$f[i][j]|=f[i][k]\&f[k][j]$即可（$f[i][j]$表示从$i$出发能否走到$j$）

## 进入正题

$DAG$的最小**可相交**链覆盖可以当作一道**纯网络流**题目做（虽然这样做复杂度更高）

~~当作锻炼网络流建模能力了~~

观察这个题

- 我们有$n+1$（为了方面后面设$N=n+1$）条可以相交的**链**

这和在原图上的大小为$N$的**流**一样

- 每条链可以在任意位置开始/结束

$S$向每个点连$inf$的边，每个点向$T$连$inf$的边

为了限制流最多为$N$我们设置超级汇点$TT$，$T->TT,d\text{(流量)}=N$

- 要经过尽可能多的点

我们把每个点成入点$i$和出点$i'$，连向这个点的边连到$i$，这个点连出去的边从$i'$出去

然后，$i->i',d=1,c\text{(费用)}=1$（第一次经过时多覆盖了一个点），$i->i',d=inf,c=0$（之后还可以经过但是覆盖的点数不变）

#### 这是核心和正确性的保证

即使得**流**和**链**等价，**费用**和**覆盖的点数**等价

然后跑完费用流，费用就是覆盖的点数了

- 二分中不用覆盖的点

前面已经说了这些点不能直接删掉，那怎么处理？

#### 不连入点和出点之间有费用的那条边

这样它就只起到连接其他点的作用而不影响费用（覆盖的点数）了

即认为覆盖了这个点等于没覆盖（因为本来就不关系是否覆盖它，只关心是否覆盖前$mid$个点）

- $done$

现在我们只要求出最大费用最大流（前面没提到费用的边都是$c=0$）,就能求出能覆盖的点数，如果等于$mid$就说明能覆盖前$mid$个点

然后二分就完了

------------

~~只用了网络流及其建模是不是很妙啊~~

（如果要求不相交链覆盖，只要不连入点出点之间那条$inf$的边即可）~~然而复杂度比二分图匹配高多了~~

（如果是这个题二分时的条件（一些点不用覆盖但不能扔）并且要求链不相交，就把不选的点那条$d=1,c=1$的边改成$d=1,c=0$）

这两个正确性留作思考题（~~明明很显然看了就知道了吧~~）

下面是代码

（因为懒，费用流写的最慢的做法，跑到$5000ms$，如果换优秀的费用流应该会快很多）


```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#define inf 0x7ffffff
#define S 0
#define T 1209
#define T0 1205
using namespace std;

int n,m,i,j,k,v,t[505][505];

int L,R,mid;

struct way
{
	int v,d,c,next;
};
way e[300000];
int head[1505],cnt;
void add(int u,int v,int d,int c)
{
	e[cnt].v=v;e[cnt].d=d;e[cnt].c=c;e[cnt].next=head[u];head[u]=cnt++;
	e[cnt].v=u;e[cnt].d=0;e[cnt].c=-c;e[cnt].next=head[v];head[v]=cnt++;
}

struct node
{
	int v,id;
	bool operator <(const node&a)const
	{
		return v<a.v;
	}
};
node p[505];

int dist[1500],pre[1500],f[1500],in[1500];
struct cmp
{
	bool operator ()(int a,int b)
	{
		return dist[a]<dist[b];
	}
};
priority_queue<int,vector<int>,cmp> q;
void spfa()
{
	memset(dist,-1,sizeof(dist));
	memset(f,0,sizeof(f));
	dist[S]=0;q.push(S);f[0]=inf;
	int x;
	while(!q.empty())
	{
		x=q.top();q.pop();in[x]=0;
		for(int i=head[x];~i;i=e[i].next)
			if(e[i].d&&dist[x]+e[i].c>dist[e[i].v])
				dist[e[i].v]=dist[x]+e[i].c,f[e[i].v]=min(f[x],e[i].d),pre[e[i].v]=i,in[e[i].v]?0:(q.push(e[i].v),in[e[i].v]=1);
	}
}

int flow,cost;
int fee_flow()
{
	flow=0;cost=0;
	while(1)
	{
		spfa();
		flow+=f[T];cost+=f[T]*dist[T];
		if(!f[T]||!dist[T])
			return cost;
		int x=T;
		while(x!=S)
		{
			e[pre[x]].d-=f[T];e[pre[x]^1].d+=f[T];
			x=e[pre[x]^1].v;
		}
	}
}

int check(int x)
{
	memset(head,-1,sizeof(head));cnt=0;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=m;j++)
			if(t[i][j])
				add(i+m,j,inf,0);
	for(int i=1;i<=x;i++)
		add(p[i].id,p[i].id+m,1,1),add(p[i].id,p[i].id+m,inf,0),add(S,p[i].id,inf,0),add(p[i].id+m,T0,inf,0);
	for(int i=x+1;i<=m;i++)
		add(p[i].id,p[i].id+m,inf,0),add(S,p[i].id,inf,0),add(p[i].id+m,T0,inf,0);
	add(T0,T,n,0);
	return fee_flow()>=x;
}

int ret;
void work()
{
	while(fee_flow()<i)
		ret++,add(T0,T,1,0);
}

int main()
{
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m;n++;
	for(i=1;i<=m;i++)
	{
		p[i].id=i;cin>>p[i].v>>k;
		for(;k;k--)
			cin>>v,t[i][v]=1;
	}
	sort(p+1,p+m+1);
	L=1;R=m;
	while(L<R)
	{
		mid=(L+R+1)>>1;
		if(check(mid))
			L=mid;
		else R=mid-1;
	}
	if(L==m)
		cout<<"AK";
	else cout<<p[L+1].v;
	return 0;
}
```

---

## 作者：Elma_ (赞：4)

表示并不能看懂这个出题人写的题面（

题意大概是给定一个 $m$ 个点的 DAG，询问能否用 $n + 1$ 条路径能否覆盖全部点，不能覆盖的点的最小权值的最大值是多少。

考虑二分最小点权值的最大值，设这个二分出来的数为 mid，每次 check 的时候判断是否能够覆盖点权小于等于 mid 的所有点。如果最后 mid 大于所有点权值的最大值，就说明可以覆盖到全部点。

每次 check 的时候把点权大于 mid 的点忽略掉然后建出一个新图，问题就转化为这个新图的最小可相交路径覆盖条数。显然这个新图是原来 DAG 的一个子图，也是一个 DAG。众所周知对于这个 DAG 的最小不相交路径覆盖条数可以转化成二分图最大匹配问题。

最小可相交路径问题可以先在 DAG 上跑一遍 Floyd 传递闭包，对于两个点 $i,j$，如果从 $i$ 点能到达 $j$ 点就连边 $(i,j)$。显然连完边后的图还是一个 DAG，于是问题就转化为这个 DAG 上的最小不相交路径覆盖问题。时间复杂度 $O(m^3\log v)$。

```cpp
#include <cmath>
#include <queue>
#include <vector>
#include <cstdio>
#include <cstring>	
#include <iostream>
#include <algorithm>
typedef long long ll;
using namespace std;

inline int read() {
	int x = 0, w = 1;char ch = getchar();
	while (ch > '9' || ch < '0') { if (ch == '-')w = -1;ch = getchar(); }
	while (ch >= '0' && ch <= '9')x = x * 10 + ch - '0', ch = getchar();
	return x * w;
}
inline void write(int x) {
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0');
}	

const int maxn = 1e3 + 5;
const int maxm = 1e6 + 5;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f3f3f3f3f;

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }

struct node {
    int nxt, to;
}edge[maxm << 1];
int n, m, t, tot, l, r; 
bool vis[maxn], g[maxn][maxn], f[maxn][maxn];
int head[maxn], mat[maxn], v[maxn];

inline void addedge(int u, int v) {
    edge[++tot] = (node){head[u], v}, head[u] = tot;
}
inline bool find(int u) {
    for (int i = head[u];i;i = edge[i].nxt) {
        int v = edge[i].to;
        if (vis[v]) continue; vis[v] = true;
        if (!mat[v] || find(mat[v])) {
            mat[v] = u; return true;
        }
    }
    return false;
}
inline void init() {
	tot = 0;
	memset(head, 0, sizeof(head));
	memset(f, 0, sizeof(f));
	memset(mat, 0, sizeof(mat));
}
inline bool check(int mid) { init();
	int res = 0;
	for (int i = 1;i <= n;i++)
		for (int j = 1;j <= n;j++)
			if (g[i][j] && v[i] <= mid && v[j] <= mid) f[i][j] = true;
	for (int k = 1;k <= n;k++) {
		for (int i = 1;i <= n;i++) {
			if (!f[i][k]) continue;
			for (int j = 1;j <= n;j++)
				f[i][j] |= f[i][k] & f[k][j];
		}
	}
	for (int i = 1;i <= n;i++) {
		if (v[i] > mid) continue; res++;
		for (int j = 1;j <= n;j++)
			if (f[i][j]) addedge(i, j);
	}
	for (int i = 1;i <= n;i++) {
		if (v[i] > mid) continue;
		memset(vis, 0, sizeof(vis));
		if (find(i)) res--;
	}
	return res <= m;
}

int main(void) { 
	m = read() + 1, n = read(), l = inf, r = 0;
	for (int i = 1, k;i <= n;i++) {
		v[i] = read(), k = read(), l = min(l, v[i]), r = max(r, v[i]);
		while (k--) g[i][read()] = true;
	}
	for (int k = 1;k <= n;k++) {
		for (int i = 1;i <= n;i++) {
			if (!g[i][k]) continue;
			for (int j = 1;j <= n;j++) {
				if (i == j) continue;
				g[i][j] |= g[i][k] & g[k][j];
			}
		}
	}
	int tmp = r;
	while (l <= r) {
		int mid = (l + r) >> 1;
		if (check(mid)) l = mid + 1;
		else r = mid - 1;
	}
	l > tmp ? puts("AK") : printf("%d\n", l);
	return 0;  
}
```


---

## 作者：elijahqi (赞：4)

给定一个DAG 可以用n+1条路径覆盖求不能覆盖的点中最小值最大
出题人的语文水平+elijahqi的语文水平为负无穷 读错题只有10分系列
考虑二分答案 然后二分图匹配 求最小可相交路径覆盖问题
注意二分答案的单调性 即 若3->6之间有一个8 然而这次二分的答案是7 他们这条边也应该视为存在
```
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;
inline char gc(){
	static char now[1<<16],*S,*T;
	if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
	return *S++;
}
inline int read(){
	int x=0,f=1;char ch=gc();
	while(!isdigit(ch)) {if (ch=='-') f=-1;ch=gc();}
	while(isdigit(ch)) x=x*10+ch-'0',ch=gc();
	return x*f;
}
const int inf=0x3f3f3f3f;
const int N=550;
struct node{
	int y,next;
}data[N*N];
int h[N],g[N],num,v[N],n,m;
bool mp[N][N],mp1[N][N],used[N];
inline bool find(int x){
	for (int i=h[x];i;i=data[i].next){
		int y=data[i].y;if (used[y]) continue;used[y]=1;
		if (!g[y]||find(g[y])){
			g[y]=x;return 1;
		}
	}return 0;
}
inline void insert1(int x,int y){
	data[++num].y=y;data[num].next=h[x];h[x]=num;
}
inline bool check(int md){
	memset(mp1,0,sizeof(mp1));
	memset(h,0,sizeof(h));num=0;
	for (int i=1;i<=m;++i){
		for (int j=1;j<=m;++j){
			if (v[i]<=md&&v[j]<=md&&mp[i][j]) mp1[i][j]=1;
		}
	}int ans=0;
	for (int k=1;k<=m;++k)
		for (int i=1;i<=m;++i){
			if (!mp1[i][k]) continue;
			for (int j=1;j<=m;++j)
				mp1[i][j]|=mp1[i][k]&mp1[k][j];
		}
	for (int i=1;i<=m;++i){
		if (v[i]<=md) ++ans;else continue;
		for (int j=1;j<=m;++j){
			if (mp1[i][j]) insert1(i,j);
		}
	}memset(g,0,sizeof(g));
	for (int i=1;i<=m;++i){
		if (v[i]>md) continue; 
		memset(used,0,sizeof(used));
		if (find(i)) --ans;
	}
	return ans<=n;
}
int main(){
	freopen("contest.in","r",stdin);
	freopen("contest.out","w",stdout);
	n=read()+1;m=read();int l=inf,r=0;
	for (int i=1;i<=m;++i){
		v[i]=read();int k=read();l=min(l,v[i]);r=max(r,v[i]);
		for (int j=1;j<=k;++j) mp[i][read()]=1;
	}
	for (int k=1;k<=m;++k){
		for (int i=1;i<=m;++i){
			if (!mp[i][k]) continue;
			for (int j=1;j<=m;++j){
				if (i==j) continue;
				mp[i][j]|=mp[i][k]&mp[k][j];
			}
		}
	}
	int mx=r;
	while(l<=r){
		int mid=l+r>>1;
		if (check(mid)) l=mid+1;else r=mid-1;
	}
	if (l>mx) puts("AK");else printf("%d\n",l);
	return 0;
}
  ```

---

## 作者：naoliaok_lovely (赞：3)

# 题意
给出一个带权有向图，选出 $n+1$ 条链，问能否全部点覆盖，如果不能，问不能覆盖的点权最小值最大是多少。

# 分析
显然是在求 DAG 最少链覆盖。（不会的可以看[我的博客](https://www.luogu.com.cn/blog/511676/er-fen-tu)）由于判定十分简单，考虑**二分**。

这里点出我自己思考时的一个小误区：二分即意味着要删掉所有权值较大的点，这会不会使得判定的结果不存在单调性？（因为不能经过那些点了）事实上，由于我们已经跑了一边传递闭包，上面的担忧是完全多余的。

# Code
```
#include<bits/stdc++.h>
using namespace std;

const int N = 510, M = N * N;
int n, m, w[N], d[N][N];
int link[N];
bool vis[N];

int h[N], ne[M], e[M], idx;
void add(int a, int b)
{
	e[++idx] = b, ne[idx] = h[a], h[a] = idx;
}

void floyd()
{
	for(int k = 1; k <= n; k++)
		for(int i = 1; i <= n; i++)
			for(int j = 1; j <= n; j++)
				d[i][j] |= d[i][k] & d[k][j];
}

bool dfs(int x, int s)
{
	for(int i = h[x]; i; i = ne[i])
		if(d[x][e[i]] && !vis[e[i]] && w[e[i]] <= s)
		{
			int j = e[i];
			vis[j] = 1;
			if(!link[j] || dfs(link[j], s))
			{
				link[j] = x;
				return 1;
			}
		}
	return 0;
}

bool check(int x)
{
	int ans = 0, sum = 0;
	memset(link, 0, sizeof(link));
	for(int i = 1; i <= n; i++)
		if(w[i] <= x)
		{
			sum++;
			memset(vis, 0, sizeof(vis));
			ans += dfs(i, x);
		}
	return sum - ans <= m;
}

int main()
{
	cin >> m >> n;
	m++;
	
	for(int i = 1; i <= n; i++) d[i][i] = 1;
	for(int i = 1, m, x; i <= n; i++)
	{
		scanf("%d%d", &w[i], &m);
		while(m--) scanf("%d", &x), d[i][x] = 1;
	}
	floyd();
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= n; j++)
			if(i != j && d[i][j]) add(i, j);
		
	if(check(1e9))
	{
		puts("AK");
		return 0;
	}
	int l = 0, r = 1e9;
	while(l < r)
	{
		int mid = l + r >> 1;
		if(check(mid)) l = mid + 1;
		else r = mid;
	}
	cout << l << endl;
	return 0;
}
```

---

## 作者：cirnovsky (赞：3)

这题数据应该蛮水的，直接把大于二分值的点去掉实际上应该是有问题的。然而题解区里都写的是这种做法，所以这里主要对如何处理大于二分值的点做分析。

注意这里大于二分值的点的意义是「可以走，但走了不贡献」，因此可能对最小路径覆盖的去除其为起点 / 终点的操作次数影响。处理方法应该为把大于二分值的点左部和右部之间连，即连 $(u_s,u_t),v_u>mid$。

然后就是其他题解的做法了，二分后跑最小路径覆盖即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define cmin(x, y) x = min(x, y)
#define cmax(x, y) x = max(x, y)
template<typename T=int> T read() {
	T x=0; char IO=getchar(); bool f=0;
	while(IO<'0' || IO>'9')	f|=IO=='-',IO=getchar();
	while(IO>='0' && IO<='9')	x=x*10+(IO&15),IO=getchar();
	return f?-x:x;
}
int n,K,mat[1100],vis[1100],dp[600][600],dp2[600][600],a[600];
vector<vector<int>> e;
void add(const int one,const int ano) {
	e[one].push_back(ano);
}
bool DFS(const int now) {
	assert(now < int(e.size()));
	if(vis[now]) return 0;
	vis[now] = 1;
	for(const int y : e[now]) if(!mat[y] || DFS(mat[y])) return bool((mat[y] = now,1));
	return 0;
}
bool check(const int cur) {
	vector<vector<int>>().swap(e);
	memset(dp2, 0, sizeof dp2);
	memset(mat, 0, sizeof mat);
	e.resize(n + 5);
	int res = 0;
	for(int i=1; i<=n; ++i) {
		for(int j=1; j<=n; ++j) {
			if(dp[i][j] && ((a[i] <= cur && a[j] <= cur) || i == j)) dp2[i][j] = 1;
		}
	}
	for(int i=1; i<=n; ++i) if(a[i] > cur) dp2[i][i] = 1;
	for(int k=1; k<=n; ++k) {
		for(int i=1; i<=n; ++i) {
			for(int j=1; j<=n; ++j) dp2[i][j] |= dp2[i][k]&dp2[k][j];
		}
	}
	for(int i=1; i<=n; ++i) {
		for(int j=1; j<=n; ++j) if(dp2[i][j]) add(i, j);
	}
	for(int i=1; i<=n; ++i) memset(vis+1, 0, n<<2),res += DFS(i);
	return n - res <= K;
}
signed main() {
	K = read() + 1,n = read();
	int l = 1e9,r = 0;
	for(int i=1,k; i<=n; ++i) {
		a[i] = read(),k = read();
		cmin(l, a[i]),cmax(r, a[i]);
		while(k--) dp[i][read()] = 1;
	}
	for(int k=1; k<=n; ++k) {
		for(int i=1; i<=n; ++i) {
			for(int j=1; j<=n; ++j) if(i != j) dp[i][j] |= dp[i][k]&dp[k][j];
		}
	}
	int tmp = r;
	for(int mid; l <= r;) {
		mid = (l + r)>>1;
		if(check(mid)) l = mid + 1;
		else r = mid - 1;
	}
	if(l > tmp) puts("AK");
	else printf("%d\n", l);
	return 0;
}
```

---

## 作者：BigSmall_En (赞：3)

## 前言

本题解是[这篇题解](https://www.luogu.com.cn/blog/Mychael/solution-p4589)做法的优化（写法更简单）。基本思路与之相同，所不同的是可以不用每次重新创建一次图。

还有有一道题做法与之类似的题[P4251](https://www.luogu.com.cn/problem/P4251)。

## 题目描述

给定一个 $m$ 个点的无向图，每个点有点权，求是否可以用 $n+1$ 条边完全覆盖。如果不能，求出不能覆盖的点权的最大值最小是多少。

## 题解

别的题解已经写得很清楚了，这里就重复一遍。

对于能的情况就是先用 *Floyd* 跑出传递背包（就是能到达的点），然后对这两个点连边，问题就是对这个图求最小不相交路径覆盖问题。可以使用匈牙利算法。

对于不能的情况，很容易想到二分。

但是数据 $v \leq 10^9$ ，不能直接二分，先进行离散化。

然后根据上边的情况容易想到先前题解中的做法，即：把值比 $mid$ 大的点忽略掉，然后再建一个图和之前一样用二分图匹配。

## 一些改进

可以发现并不用每次重新建一次图，只需要每次判断每次待匹配的点的权值是否大于 $mid$ 即可，如果大于可能是不能到达，则跳过即可。这样子只需要定义一个全局变量 $mid$ ，然后每次找增广路的是否判断一下就行了。

## 代码实现

### 一个常见的技巧

每次匹配下一个点时候 $vis$ 数组不用清空，只需要记录一个时间戳 $tim$ ,每次判断 $vis_i=tim$ 就行了。如果相等就说明已经到达过了。

### 一些变动

因为题目给出的 $n,m$ 不太符合常规思维，所以在代码中用 $n$ 来表示题目数量。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1002;
int m,n,val[N],mat[N],vis[N],tim,mps[N][N],lis[N],cntv,lim;
void floyd(){//求传递背包
	for(int k=1;k<=n;++k)
		for(int i=1;i<=n;++i)
			for(int j=1;j<=n;++j)
				mps[i][j]|=(mps[i][k]&mps[k][j]);
}
bool findadp(int u){//常规二分图匹配匈牙利算法
	if(val[u]>=lim)return 0;
	for(int i=1;i<=n;++i){
		if(vis[i]==tim||!mps[u][i]||val[i]>=lim)continue;
		vis[i]=tim;
		if(!mat[i]||findadp(mat[i]))
			{mat[i]=u;return 1;}
	}return 0;
}
bool check(){
	int sum=0;tim=0;
	for(int i=1;i<=n;++i)if(val[i]<lim)++sum;//最多能获得的点
	memset(mat,0,sizeof(mat));
	memset(vis,-1,sizeof(vis));
	for(int i=1;i<=n;++i,++tim)
		sum-=findadp(i);
	return sum<=m+1;
}
int main(){
	scanf("%d%d",&m,&n);//注意这里和题目的m,n相反
	for(int i=1,t,v;i<=n;++i){
		scanf("%d%d",&val[i],&t);lis[i]=val[i];
		while(t--){scanf("%d",&v);mps[i][v]=1;}
	}
	floyd();//联通到达
	sort(lis+1,lis+1+n);//离散化
	cntv=unique(lis+1,lis+1+n)-lis-1;
	for(int i=1;i<=n;++i)val[i]=lower_bound(lis+1,lis+1+cntv,val[i])-lis;
	lim=cntv+1;//[1,lim) 左闭右开
	if(check()){puts("AK");return 0;}
	int l=1,r=cntv;
	while(l<r){//二分答案
		lim=(l+r+1)>>1;
		if(check())l=lim;
		else r=lim-1;
	}
	printf("%d\n",lis[l]);
	return 0;
}
```


---

## 作者：Coros_Trusds (赞：0)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/16387666.html)

# 题目大意

给出一个 $n$ 个点的带权有向图 $G$，选出 $m+1$ 条链，问能否全部点覆盖，如果不能，问 **不能** 覆盖的点权最小值最大是多少。

（这里的 $n,m$ 和原题是反着的）

# 题目分析

其实就是求 $\verb!DAG!$ 的最小可重复路径点覆盖。我们可以先将这个图传递闭包，求出两个点是否能相互抵达，能则按顺序连边。最后就转换为了求 $\verb!DAG!$ 的最小路径覆盖问题。

然后我们又知道最小路径覆盖数等于点数减去最大匹配数，所以匈牙利算法求解即可。

------------

可题目要我们最大化不能全部点覆盖的点权的最小值，最小值最大，当“最小”“最大”连在一起的时候，大部分情况不是二分就是 Kruskal 重构树。这里很显然是二分答案。

我们二分一个值 $now$，判断 当图的点权最大值为 $now$ 时是否能够全部点覆盖，方法与上面类似（特别注意点的总数不是 $n$），如果最小路径覆盖数不超过 $m+1$ 就满足条件。

求的是“不能”覆盖的点权的最小值，也就是“能”覆盖的点权的最大值（满足这个最大值最大）再 **加一**。

-------

时限会被卡，匈牙利算法打上时间戳、floyd 简单剪枝就能过了。

# 代码

```cpp
// Problem: P4589 [TJOI2018]智力竞赛
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P4589
// Memory Limit: 250 MB
// Time Limit: 1000 ms
// Date:2022-06-18 08:23
// 
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#include <cmath>
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline double double_read() {
		long long ret = 0,w = 1,aft = 0,dot = 0,num = 0;
		char ch = getchar();
		while (!isdigit(ch)) {
			if (ch == '-') w = -1;
			ch = getchar();
		}
		while (isdigit(ch) || ch == '.') {
			if (ch == '.') {
				dot = 1;
			} else if (dot == 0) {
				ret = (ret << 3) + (ret << 1) + ch - 48;
			} else {
				aft = (aft << 3) + (aft << 1) + ch - '0';
				num ++;
			}
			ch = getchar();
		}
		return (pow(0.1,num) * aft + ret) * w;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;

const int INF = 0x3f3f3f3f;
const int N = 505;
struct Graph {
	int v,nxt;
} gra[N * N];
int head[N],val[N],vis[N],mat[N];
bool G[N][N],E[N][N];
int n,m,idx,nowidx;
inline void add(int u,int v) {
	gra[++ idx] = (Graph){v,head[u]},head[u] = idx;
}
inline bool dfs(int now) {
	for (register int i = head[now];i;i = gra[i].nxt) {
		int v = gra[i].v;
		if (vis[v] != nowidx) {
			vis[v] = nowidx;
			if (!mat[v] || dfs(mat[v])) {
				mat[v] = now;
				return true;
			}
		}
	}
	return false;
}
inline void floyd(bool F[][N]) {
	for (register int k = 1;k <= n; ++ k) {
		for (register int i = 1;i <= n; ++ i) {
			if (!F[i][k]) continue;
			for (register int j = 1;j <= n; ++ j) {
				if (F[i][k] && F[k][j]) {
					F[i][j] = true;
				}
			}
		}
	}
}
//图的点权最大值为 now 时是否能够全部点覆盖
inline bool check(int now) {
	idx = nowidx = 0;
	mst(gra,0),mst(E,false),mst(vis,0),mst(mat,0),mst(head,0);
	for (register int i = 1;i <= n; ++ i) {
		for (register int j = 1;j <= n; ++ j) {
			if (G[i][j] && val[i] <= now && val[j] <= now) {
				E[i][j] = true;
			}
		}
	}
	floyd(E);
	int num = 0,ans = 0;
	for (register int i = 1;i <= n; ++ i) {
		if (val[i] <= now) {
			num ++;
			for (register int j = 1;j <= n; ++ j) {
				if (E[i][j]) {
					add(i,j);
				}
			}
		}
	}
	for (register int i = 1;i <= n; ++ i) {
		if (val[i] <= now) {
			nowidx ++;
			if (dfs(i)) ans ++;
		}
	}
	return num - ans <= m;
}
int main(void) {
	m = read() + 1,n = read();
	int l = INF,r = 0;
	for (register int i = 1,t;i <= n; ++ i) {
		val[i] = read(),t = read();
		l = std::min(l,val[i]),r = std::max(r,val[i]);
		while (t --) {
			int x = read();
			G[i][x] = true;
		}
	}
	floyd(G);
	int ans = -1;
	while (l <= r) {
		int mid = l + r >> 1;
		if (check(mid)) l = mid + 1,ans = mid;
		else r = mid - 1;
	}
	int maxx = 0;
	for (register int i = 1;i <= n; ++ i) maxx = std::max(maxx,val[i]);
	if (ans + 1 > maxx) puts("AK");
	else printf("%d\n",ans + 1);
	
	return 0;
}
```

---


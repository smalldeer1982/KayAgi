# [TJOI2018] 游园会

## 题目描述

小豆参加了 NOI 的游园会，会场上每完成一个项目就会获得一个奖章，奖章只会是 $\texttt{N}$、$\texttt{O}$、$\texttt{I}$ 的字样。在会场上他收集到了 $K$ 个奖章组成的串。兑奖规则是奖章串和兑奖串的最长公共子序列长度为小豆最后奖励的等级。现在已知兑奖串长度为 $N$，并且在兑奖串上不会出现连续三个奖章为 $\texttt{NOI}$，即奖章中不会出现子串 $\texttt{NOI}$。现在小豆想知道各个奖励等级会对应多少个不同的合法兑奖串。


## 说明/提示

### 样例解释

最长公共子序列长度为 $0$ 的串有：$\texttt{III}$;

最长公共子序列长度为 $2$ 的串有：$\texttt{NON}$、$\texttt{NNO}$、$\texttt{NOO}$、$\texttt{ONO}$、$\texttt{INO}$、$\texttt{NIO}$；

除去 $\texttt{NOI}$，余下的 $19 = 26-6-1$ 种为最长公共子序列长度为 $1$。

### 数据范围

- 对于 $10\%$ 的数据，$N\leq10,K\leq10$；
- 对于 $30\%$ 的数据，$N\leq100,K\leq4$；
- 对于 $100\%$ 的数据，$N\leq1000,K\leq15$。

## 样例 #1

### 输入

```
3 2
NO```

### 输出

```
1
19
6```

# 题解

## 作者：shadowice1984 (赞：66)

一个有趣的技术名字叫做dp套dp

基本是道板子题，只是注意直接开这么大的数组会炸请注意使用滚动数组进行优化
_______________

首先翻译一下并不好懂的题意

题目的意思是对于每一个i求满足如下条件的字符串的数目

1.长度为n且只出现过'N','O','I'三种字符

2.和一个长度为k的模式串的**最长公共子序列**长度恰好为i

3.不含"NOI"这个**子串**

然后这是一道对于字符串进行计数的题目那么我们考虑采取设一个$dp_{i,……}$表示长度为i，处于一些奇奇怪怪的状态时字符串的方案数，这样的话我们的转移就是枚举下一位是填'N'还是填'O'还是填'I'了，这样做有一个好处是你dp的时候不需要考虑有没有字符串被重复计数了，因为你的转移保证了每个字符串最多被dp到一次，坏处就是别的限制几乎就只能求助于dp的额外维度了

对于字符串题的话我们满足别的限制基本就是建一个自动机来搞定别的限制条件……像什么Ac自动机后缀自动机之类的都可以帮我们搞定一些但不是全部的限制条件

但是呢，没有"NOI”子串这个限制条件我们似乎可以轻松的记一维$k \in \{0,1,2\}$表示这个字符串匹配‘NOI’的长度来轻松搞定

但是……和一个模式串的最大子序列长度恰好为i这个限制条件就变得辣手了，因为我们并没有一个类似于“最大子序列自动机”的东西

但是仔细想想真的没有嘛？

除了自动机，还有什么东西是可以通过每次加一个字符实现转移的呢……?

**当然是dp了~**

所以让我们来考虑一下两个串求最长公共子序列的过程

设$dp_{i,j}$表示在第一个串A长度为i的前缀和第二个串B长度为j的前缀的最长公共子序列长度

那么我们可以得到一个转移方程是

$$dp_{i,j}=max(dp_{i-1,j},dp_{i,j-1},dp_{i-1,j-1}+(A_{i}==B_{j}))$$

接下来我们对这个转移方程以及dp数组做若干手脚，人工制造出一个“最长子序列自动机”来

首先我们认为$B$这个字符串是已知的这样的话我们就会发现我们每次转移所需要的东西有两个，一个是$dp_{i-1}$这个一维数组，另一个是$A$串的第i个字符了，有了这两个东西我们就可以根据转移方程构造出$dp_{i}$这个数组来

那么假设$B$串的长度不是非常长，那么此时我们可以直接将一个长度为$|B|$的数组看成自动机上的一个节点，这样的话我们就可以强行把刚才的转移方程当做自动机的转移条件，此时我们要做的就是枚举$dp_{i-1}$数组每一个可能的形态，然后枚举每一个可能的字符，根据转移方程计算出对应的转移到的数组$dp_{i}$这样我们就初步建成了一个“最长子序列自动机”，当然节点数非常非常多就是了

现在的瓶颈明显出在我们需要将一个数组视为子序列自动机的一个节点这个问题上
我们需要考虑一下是不是所有的dp数组都是合法的

然后我们认真的考虑一下发现有很大一部分数组是不合法的

因为$dp_{i,j}$表示两个字符串前缀的的最长公共子序列长度因此我们发现一个有趣的事实是对于任意字符串A和任意的i数组$dp_{i}$一定是单调的，另一个信息是，由于是最长公共子序列，所以数组$dp_{i}$任意两项的差要么是0要么是1，此时我们就可以将这个原数组的差分数组表达成一个01串，现在所有可能合法的dp数组和所有的01串11对应，然后把这个01串状压起来，我们就得到一个节点数为$2^k$的最长子序列自动机

然后还是老样子枚举点枚举出边字符使用dp的转移方程计算转移点就可以了

此时我们就可以设$dp_{i,j,k}$表示长度为i的字符串，处在子序列自动j号点上，以及匹配"NOI"的长度是k时符合条件字符串的个数

然后无脑的跑一边dp就行了

当然，你可以不必把自动机建出来，而是每次转移的时候现场dp一次计算转移到的状态，这样也是可以通过本题的(6000ms时限随便过)这也是这种技术被称为dp套dp的原因

好了代码实际上是比你想象的好写的

上代码

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
using namespace std;const int N=1e3+10;typedef long long ll;const ll mod=1e9+7;
int n;int k;char mde[100];int dp[2][35000][3];int tr1[100];int tr2[100];int siz[35000];ll ans[100];
inline int hsh(int* a){int ret=0;for(int i=0;i<k;i++)ret|=(a[i+1]-a[i])<<i;return ret;}
inline void dhsh(int* a,int ret)//数组和数之间的转化
{
    for(int i=0;i<k;i++)a[i+1]=(ret>>i)&1;
    for(int i=1;i<=k;i++)a[i]+=a[i-1];
}
inline void dypr(int ti,int cf,int tj,char c,const ll& val)//转移函数
{
    dhsh(tr1,cf);//现场解压数组之后压缩
    for(int i=1;i<=k;i++)tr2[i]=max(max(tr2[i-1],tr1[i]),tr1[i-1]+1*(c==mde[i]));
    int tcf=hsh(tr2);(dp[ti][tcf][tj]+=val)%=mod;
}
int main()
{
    scanf("%d%d",&n,&k);scanf("%s",mde+1);//注意滚动数组
    for(int i=1;i<=32767;i++)siz[i]+=siz[i>>1]+(i&1);dp[0][0][0]=1;
    for(int i=0;i<n;i++)
    {
        int ti=(~i)&1;int ni=i&1;
        for(int j=0;j<(1<<k);j++)
            for(int p=0;p<3;p++)dp[ti][j][p]=0;
        for(int j=0;j<(1<<k);j++)//暴力枚举下一个字符进行转移
        {
            if(dp[ni][j][0]!=0)
            {
                dypr(ti,j,1,'N',dp[ni][j][0]);
                dypr(ti,j,0,'O',dp[ni][j][0]);
                dypr(ti,j,0,'I',dp[ni][j][0]);
            }
            if(dp[ni][j][1]!=0)
            {
                dypr(ti,j,1,'N',dp[ni][j][1]);
                dypr(ti,j,2,'O',dp[ni][j][1]);
                dypr(ti,j,0,'I',dp[ni][j][1]);
            }
            if(dp[ni][j][2]!=0)
            {
                dypr(ti,j,1,'N',dp[ni][j][2]);
                dypr(ti,j,0,'O',dp[ni][j][2]);
            }
        }
    }
    for(int i=0;i<(1<<k);i++)//最长子序列长度自然就是01串中1的个数，因为这是dp数组中的最大值
        for(int p=0;p<3;p++)(ans[siz[i]]+=dp[n&1][i][p])%=mod;
    for(int i=0;i<=k;i++)printf("%lld\n",ans[i]);return 0;//拜拜程序~
}
```




---

## 作者：shao0320 (赞：24)

这道题从中午12点想到半夜12点，终于想明白了。。。。。

感谢lqx学长的讲解？顺便讨债（京味斋我还能不能吃到啊~）

题意：满足$\operatorname{LCS}$($A$,$B$)为给定值且在$B$中任意位置不含有连续的“$NOI$”出现 

考虑最一般的$\operatorname{LCS}$问题，我们发现这其实是一个逆过程。

在$\operatorname{LCS}$的原始问题中，我们是这样做的：

设$dp(i,j)$表示第一个字符串取前$i$位，第二个字符串取前$j$位所得的字符串$\operatorname{LCS}$。

则显然有以下转移方程：
$dp(i,j)$=$\max$($dp(i-1,j)$,$dp(i,j-1)$)

特殊地，当$a_i=b_j$时，$dp(i,j)$=$dp(i-1,j-1)+1$

可是这和我们解决这道题有什么关系吗？

看到这里，相信dalao您已经想出了一个初步的$dp$方法。
$\operatorname{LCS}$
设$dp(i,j)$表示兑奖串前$i$位和奖章串的$\operatorname{LCS}$为$j$时的合法方案数。

但很遗憾，这个方法是不行的。

你会发现一个事情，当我们试图把$dp(i,j)$转移到$dp(i+1,j+1)$或是$dp(i+1,j)$的时候，但我们不知道新加进来的这一位能否和奖章串进一步匹配，因为你并不知道上一次匹配到了哪里。

而我们发现，这个$dp$之所以失败，很大程度上是因为状态之间很难转移。于是我们可以用多加一些附加信息的方法来避免这种情况。

让我们从原始出发。在我们知道很多信息的情况下，转移还是非常容易的。设$f_i$表示当前兑奖串与前$i$位奖章串匹配后的$\operatorname{LCS}$长度。

假如我们已经知道了$f$数组，那么转移就十分简单了。

但是我们绝望地发现，这个做法时间空间都会炸。

但是我们转眼一看，$k\leq15$。

于是就可以尝试快乐状压。

进一步观察这个数组，我们会发现其实对于同一个兑奖串，这个数列是单调递增的，而且每次递增不会超过$1$。

因此考虑状压它们的差分数组。

于是最终就成了这个样子:设$dp(i,j)$表示当前枚举到兑奖串第$i$位，且和奖章串的$\operatorname{LCS}$被状压为$j$。进一步发现可以使用滚动数组再次优化空间复杂度。

那么对于不能出现"$NOI$"这个条件怎么办呢？

很简单，只需要新开一维，记录已经匹配到了"$NOI$"的第0/1/2维即可。

最后感谢LQX学长的讲解，希望他能早日请我吃京味斋~(别拖到NOIP2020之后啊~~~)

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 1005
using namespace std;
int n,m,f[2][N],a[N],b[N],nxt[3][3]={{1,0,0},{1,2,0},{1,0,3}},dp[2][32769][3],ans[N],now,sta[32769][3];
char ch[N];
const int mod=1e9+7;
void init()
{
	for(int s=0;s<(1<<m);s++)
	{
		for(int k=0;k<m;k++)f[0][k+1]=f[0][k]+((s>>k)&1);
		for(int j=0;j<=2;j++)
		{
			for(int k=1;k<=m;k++)
			{
				f[1][k]=max(f[1][k-1],f[0][k]);
				if(b[k]==j)f[1][k]=max(f[1][k],f[0][k-1]+1);
			}
			int t=0;
			for(int i=1;i<=m;i++)if(f[1][i]>f[1][i-1])t|=(1<<(i-1));
			sta[s][j]=t;
		}
	}	
}
int main()
{
	cin>>n>>m;
	cin>>(ch+1);
	for(int i=1;i<=m;i++)
	{
		if(ch[i]=='N')b[i]=0;
		if(ch[i]=='O')b[i]=1;
		if(ch[i]=='I')b[i]=2;
	}
	init();
	dp[0][0][0]=1;
	//dp(i,j,k)表示前i个字符中，状态压缩后的lcs串表示为j，与“NOI”的匹配到了第k位的方案数。 
	for(int i=1;i<=n;i++)
	{
		memset(dp[now^1],0,sizeof(dp[now^1]));
		for(int s=0;s<(1<<m);s++)
		{
			for(int j=0;j<=2;j++)
			{
				for(int k=0;k<=2;k++)
				{
					if(j==2&&k==2)continue;
					int ff=nxt[j][k];
					dp[now^1][sta[s][k]][ff]+=dp[now][s][j];
					dp[now^1][sta[s][k]][ff]%=mod;
				}
			} 
		}
		now^=1;
	}
	for(int s=0;s<(1<<m);s++)
	{
		for(int j=0;j<=2;j++)
		{
			int ff=0,ll=s;
			while(ll){if(ll%2==1)ff++;ll/=2;}
			ans[ff]+=dp[now][s][j];
			ans[ff]%=mod;
		}
	}
	for(int i=0;i<=m;i++)cout<<ans[i]<<endl;
	return 0; 
}
```

---

## 作者：__gcd (赞：21)

## 题目大意

令 $f(i)$ 为满足下面几条限制的字符串个数：

* 长度为 $n$，字符集为 $\{\mathtt{N,O,I}\}$。
* 不包含子串 $\mathtt{NOI}$。
* 与模式串 $s$ 的最长公共子序列（$\rm lcs$）长度为 $i$。

对于 $i\in [0,k]$，求出 $f_i$ 的值，对 $10^9+7$ 取模。

## 题解

考虑 DP。

如果我们直接定义 $f_{i,j,l}$ 表示考虑到第 $i$ 位，与 $s$ 的 $\rm lcs$ 为 $j$，与 $\mathtt{NOI}$ 的匹配长度为 $l$ 的字符串个数，那么 $\text{lcs}$ 在每个状态的值是未知的，无法完成转移。所以我们不妨考虑将整个 $\rm lcs$ 数组传入状态。

显然传入整个数组是不现实的，我们尝试观察 $\rm lcs$ 的转移方法：

$$\text{lcs}_{i,j}=\max\begin{cases}\text{lcs}_{i-1,j-1}+1&t_i=s_j\\\max(\text{lcs}_{i,j-1},\text{lcs}_{i-1,j})&t_i\neq s_j\end{cases}$$

其中 $\text{lcs}_{i,j}$ 表示当前考虑到第 $i$ 位，与 $s$ 串匹配到第 $j$ 位的最长公共子序列长度。

为此，我们可以得到几条优化：

* 转移中只涉及到了第 $i-1$ 行和第 $i$ 行的状态，所以我们只需要存储一行状态即可。
* 注意到 $\text{lcs}_{i,j}-\text{lcs}_{i,j-1}\in\{0,1\}$，所以我们可以通过状压差分数组来存储一行的信息。

这样我们重新定义状态：$f_{i,state,l}$ 表示考虑到第 $i$ 位，$\text{lcs}$ 数组状态为 $state$，与 $\mathtt{NOI}$ 的匹配长度为 $l$ 的方案数。之后我们枚举第 $i$ 位的字符，转移就很好想了。

状态数 $O(n2^k)$，转移 $O(k)$（因为要求出新的 $state$），总时间复杂度 $O(nk2^k)$。使用一些剪枝就可以通过此题。

## 代码

有点难看……

```cpp
#include<bits/stdc++.h>
#define ll long long
#define db double
#define pb push_back
#define mp make_pair
#define pii pair<int, int>
using namespace std;
inline int read() {
	int x = 0; bool op = 0;
	char c = getchar();
	while(!isdigit(c))op |= (c == '-'), c = getchar();
	while(isdigit(c))x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
	return op ? -x : x;
}
const int N = 1010;
const int P = 1e9 + 7;
int n, k;
int f[2][1 << 15][3], cnt[1 << 15], m[300], g[2][20], ans[20];
char s[20];
void decode(int S) {
	memset(g[0], 0, sizeof(g[0]));
	for(int i = 0; i < k; i++)g[0][i + 1] = (S >> i & 1);
	for(int i = 1; i <= k; i++)g[0][i] += g[0][i - 1];
	return ;
}
int encode() {
	int S = 0;
	for(int i = 1; i <= k; i++) {
		int now = g[1][i] - g[1][i - 1];
		S ^= now * (1 << (i - 1));
	}
	return S;
}
void trans(int cur, int S, int c, int p, int x) {
	if((p == 2 && c == 2) || x == 0)return ;//剪枝：x=0则没有贡献，直接结束。
	int nxt = (c == 0) ? 1 : 0;
	if(p == 0 && c == 0)nxt = 1;
	else if(p == 1 && c == 1)nxt = 2;
	decode(S);
	memset(g[1], 0, sizeof(g[1]));
	for(int i = 1; i <= k; i++) {
		if(m[s[i]] == c) {
			g[1][i] = max(g[1][i], g[0][i - 1] + 1);
		}
		g[1][i] = max(g[1][i], max(g[0][i], g[1][i - 1]));
	}
	int ns = encode();
	f[cur][ns][nxt] = (f[cur][ns][nxt] + x) % P;
	return ;
}
int main() {
	n = read(); k = read();
	scanf("%s", s + 1);
	m['N'] = 0; m['O'] = 1; m['I'] = 2;
	int maxi = 1 << k, cur = 0;
	f[cur][0][0] = 1;
	for(int i = 1; i <= n; i++) {
		cur = cur ^ 1;
		memset(f[cur], 0, sizeof(f[cur]));
		for(int j = 0; j < maxi; j++) {
			for(int p = 0; p < 3; p++) {
				trans(cur, j, p, 0, f[cur ^ 1][j][0]);
				trans(cur, j, p, 1, f[cur ^ 1][j][1]);
				trans(cur, j, p, 2, f[cur ^ 1][j][2]);
			}
		}	
	}
	cnt[0] = 0;
	for(int i = 1; i < maxi; i++)cnt[i] = cnt[i >> 1] + (i & 1);
	for(int i = 0; i < maxi; i++) {
		for(int p = 0; p < 3; p++) {
			ans[cnt[i]] = (ans[cnt[i]] + f[cur][i][p]) % P;
		}
	}
	for(int i = 0; i <= k; i++)printf("%d\n", ans[i]);
	return 0;
}
```

这种在 DP 状态中存储另一个 DP 数组的技术似乎被称为“DP 套 DP”，但实质上只是把状态送上了一个转移较为复杂的自动机而已，本质上是相同的。

---

## 作者：forest114514 (赞：17)

DP 套 DP 的板子题，但我们可以在大家都会的做法上再优化一点。

大家都知道 LCS 的 DP 方程：$f_{i,j}$ 表示奖章串前 $i$ 位和兑奖串前 $j$ 位的 LCS，转移大家都会就不讲了。

然后观察性质发现同一行 $f_{i}$ 满足 $f_{i,j}-f_{i,j-1}\in \{0,1\}$。我们就能直接把一维压成一个二进制数然后 DP 就行了，这样预处理转移可以做到 $O(n2^k)$，这个其他题解都提过，DP 套 DP 怎么转移其实就是一个简单的自动机上 DP，枚举状态和转移边即可，我们就不细讲了，可以看我的代码。

但是我们知道 DP 套 DP 的状态数不要脑测，比如**麻将**和**移除石子**的状态数看着是指数级别的但是搜出来只有几千，这题是类似的。

我们借鉴之前解法压缩状态的做法然后直接 dfs 一下搜索合法状态，发现随机输入几个长 $15$ 的串只有 $1000\sim 2000$ 的状态数，实际测下来状态数不超过 $6000$，而且随机串数据下很难卡满，比直接状压 $2^{k}$ 的数组状态数要小太多了。

放一下搜状态的代码：

```cpp
int dfs(int sta){
	if(vis[sta]) return vis[sta];
	vis[sta]=++tot;
	
	auto work=[&](int to,char c)->void{
		rep(i,1,k) g[0][i]=g[0][i-1]+((sta>>(i-1))&1);
		len[vis[sta]]=g[0][k];
		int nxt=0;
		rep(i,1,k){
			g[1][i]=max(g[0][i],g[1][i-1]);
			if(s[i]==c) g[1][i]=max(g[1][i],g[0][i-1]+1);
			nxt|=((g[1][i]-g[1][i-1])<<(i-1));
		}
		trans[vis[sta]][to]=dfs(nxt);
	};
	
	work(0,'N');
	work(1,'O');
	work(2,'I');
	
	return vis[sta];
}
```

这样我们就做到了 $O( n|\Sigma|)$ 的复杂度，其中 $|\Sigma|$ 为搜出来 LCS 数组的状态数，当然有一个 $9$ 倍的常数。

这样跑得飞快，加了取模优化后最慢点 35ms，成功拿下最优解（2024.7.16）。

代码：

```cpp
const int N=1e3+100,M=6005+100,mod=1e9+7;
int n,k,f[2][M][3],g[2][20],trans[M][3],vis[1<<15],len[M],tot;
string s;
int dfs(int sta){//搜状态
	if(vis[sta]) return vis[sta];
	vis[sta]=++tot;
	
	auto work=[&](int to,char c)->void{
		rep(i,1,k) g[0][i]=g[0][i-1]+((sta>>(i-1))&1);
		len[vis[sta]]=g[0][k];
		int nxt=0;
		rep(i,1,k){
			g[1][i]=max(g[0][i],g[1][i-1]);
			if(s[i]==c) g[1][i]=max(g[1][i],g[0][i-1]+1);
			nxt|=((g[1][i]-g[1][i-1])<<(i-1));
		}
		trans[vis[sta]][to]=dfs(nxt);
	};
	
	work(0,'N');
	work(1,'O');
	work(2,'I');
	
	return vis[sta];
}
void _add(int &u,int v){
	u=(u+v>=mod)?u+v-mod:u+v;
}
int ans[25];
signed main(){
	read(n,k);
	cin>>s;s=' '+s;
	dfs(0);
	f[0][vis[0]][0]=1;
	rep(i,0,n-1){
		int o=i&1;
		rep(j,1,tot){//枚举状态
			if(f[o][j][0]){
				_add(f[o^1][trans[j][0]][1],f[o][j][0]);//加一个 N
				_add(f[o^1][trans[j][1]][0],f[o][j][0]);//加一个 O
				_add(f[o^1][trans[j][2]][0],f[o][j][0]);//加一个 I
			}
			if(f[o][j][1]){
				_add(f[o^1][trans[j][0]][1],f[o][j][1]);//加一个 N
				_add(f[o^1][trans[j][1]][2],f[o][j][1]);//加一个 O
				_add(f[o^1][trans[j][2]][0],f[o][j][1]);//加一个 I
			}
			if(f[o][j][2]){
				_add(f[o^1][trans[j][0]][1],f[o][j][2]);//加一个 N
				_add(f[o^1][trans[j][1]][0],f[o][j][2]);//加一个 O
                //不能加 I，不然就变成 NO+I 出现 NOI 了
			}
			f[o][j][0]=f[o][j][1]=f[o][j][2]=0;
		}
	}
	rep(j,1,tot) rep(k,0,2) _add(ans[len[j]],f[n&1][j][k]);
	rep(i,0,k) write(ans[i],'\n');
	return 0;
}
```

---

## 作者：LingHusama (赞：7)

## [TJOI2018] 游园会

### 前言：
虽然说不能说无用的话，但我这篇题解至少被打回了 8 次，还是要辛苦审核员了。

这是和 dp 套 dp 的初遇，这不得好好了解一下。
### 题目简化：

先把题目进行简化，就是要构造字符串，对于 $len \in [0,k]$ 满足以下条件：

1. 只包含 N,O,I 且长度为 $n$。
2. 最长公共子序列长度为 $len$。（下文都以 $S_1$ 来表示已知的这个字符串）
3. 不能存在的 NOI 子串。

### 解题思路：

#### 较为简单的一步：
本题的难度上在了第二点。

那我就先不管他。假如说某位神犇给你做出了一个自动机，它可以**识别**所有与 $S_1$ 的最长公共子序列长度恰好为 $i$ 的串。那么我们怎么统计出答案呢？

这个问题可以转化为在这个自动机上走动 $n$ 步最终走到某个状态接受点的方案数。
两个方案不同当且仅当存在一个位置 $pos$ 满足 $P1_{pos}$ 不等于  $P2_{pos}$，其中 $P_i$ 表示第 $i$ 步走的点。

这个显然是可以用动态规划解决，我们设计状态 $f_{i,j,k}$ 表示在自动机这个图上走了 $i$ 步（也可以看成目前生成的字符串长度），到达了 $j$ 这个自动机上的点，目前匹配到了 NOI 中的第 $k$ 位情况下能够生成的字符串的方案数。
假设我们现在在自动机的节点 $j$ 上完成了这一次转移，而且根据神犇的自动机知晓了到达这个点时的最长公共子序列为 $p$，那么他会对最终 $ans_p$ 产生这个 dp 值的贡献。

这个 dp 柿子的话很简单，就不再赘述了。如此一来我们完成了自动机外的 dp。

#### 较为困难的步骤

然而~~世事无常~~，我们并没有那么多神犇愿意帮助我们蒟蒻来做这个自动机。所以接下来我们必须要面对这个问题。

我们还是要用 dp 的思想来解决建立的问题。

相信您看了其他神犇的题解后，肯定已经知道了对于**任意**两个字符串如何用 dp 来求解他们的最长公共子序列了吧。那么让我把这个 dp 柿子从上面的神犇的题解中摘抄下来。

**注意一下下面这个柿子和“简单步骤”中的柿子没有任何关系**。

$f(i,j)=\max (f(i-1,j),f(i,j-1),f(i-1,j-1)+op)$

其中 $op$ 等于 1 当且仅当 $a[i]=b[i]$。

注释：你一定要深刻理解这个柿子的含义再进行下一句话的阅读。
我们先假设就是在做 LCS，我们的转移是两个循环，在枚举了一个字符串一位后遍历另外一个字符串求解。换句话说，我们在做普通的这道题时，通过枚举这一次选了什么字符然后遍历另一个字符串得出本次的答案。

由于其中一个字符串我们是已经知道的，不如假设 $b$ 是已知的吧。上文可知，我们完全可以通过知道这一次 $a$ 选的什么字符，然后遍历 $b$ 来搞。我们看看缺了哪些条件？显然就是 $f(i-1,?)$ 这个数组以及 $a_i$。

我们把这个柿子稍微抽象话一点，将所有可能的 $f(i-1,?)$ 作为一个在自动机上的节点，通过枚举所有可能新加入的字符，在自动机进行一波转移。

然后呢，很显然的是，我肯定会炸空间，因为状态数量太多了。这里有两种解决方法，都是需要发现一定的性质。

1. 可以发现这个 $f$ 是单调不减的，那么我们做一个差分，就是长度为 15 的 01 数组，显然可以状态压缩。最后的时候大不了再前缀和。
2. 可以发现很多方案其实在里面是不合法的、无用的。那么我们可以利用哈希来做（这就是第一篇题解的做法）。

我选择的是第一种做法，毕竟不管在什么时候二进制都是比较吃香的。
那么接下来，只需要把“简单步骤”中的 $j$ 给替换成状压就好了。

### 思路总结
接下来总结一下我们的做此题的思路。
1. 首先进行输入和将 N，O，I 映射成数。

2. 然后现在进行 dp，具体地，现在第一层层枚举走的步数 $i$，第二层枚举我们的差分出的二进制状态，接着再枚举三种状态，在这三层中对三种情况进行dp，为保持好看，我们可以专门写一个函数。包括下文将要提到的“压缩”和“解压”也可以用一个函数保持美观。

3. 在这个函数中，我们首先将绝对不合法的情况舍去（直接返回），然后根据现在枚举的将填入的字符以及上一次填入字符（可以根据 dp 得到）来判断这一次结束后的第三维的状态应该是什么（这里暂时记为 $nxt$）。接着我们将已经知道的当前差分的状态“解压”达成正常状态。接着跑一遍 LCS 的一层循环，跑完后可以得到更新后的数组，我们又将它差分压缩，得到更新的状态。最后在最新的状态以及 $nxt$ 下加上上一次转移过来的答案。

4. 在我们得到了 dp 值后，考虑怎么统计答案……对于所有的状态，我们只需要找到他“解压”后的值，得到他的 LCS，然后开个桶直接装下 dp 值就好了。

### 代码呈现：
```c
#include<bits/stdc++.h>
using namespace std;
map<char,int>mp;
const int mod=1e9+7;
int n,k;
int maxn,op;
int f[2][1<<15][3];
int presum[20];
int newpre[20];
int ans[20];
int cnt[1<<15];
string s;
void init(){
	mp['N']=0;mp['O']=1;mp['I']=2;
	maxn=1<<k;
	op=0;
	f[op][0][0]=1;
}
void getpre(int S){//将S这个差分状态的01序列打开，利用前缀和搞定 
	for(int i=0;i<k;i++){
		presum[i+1]=(S>>i&1);
	}
	for(int i=1;i<=k;i++){
		presum[i]=presum[i-1]+presum[i];
	}
}
int getdis(){//将得到的新的前缀数组差分压缩 
	int ret=0;
	for(int i=1;i<=k;i++){
		ret|=((newpre[i]-newpre[i-1])<<(i-1));
	}
	return ret;
}
void change(int cur,int S,int nowc,int prec,int preans){
	if(preans==0||(prec==2&&nowc==2)){//如果前面的都没有的答案|现在的答案不合法 
		return; 
	}
	int nxt=0;
	if(nowc==0){
		nxt=1;
	}
	if(prec==0&&nowc==0){
		nxt=1;
	}
	else if(prec==1&&nowc==1){
		nxt=2;
	}
	getpre(S);
	memset(newpre, 0, sizeof(newpre));
	for(int i = 1; i <= k; i++) {
		if(mp[s[i]] == nowc) {
			newpre[i] = max(newpre[i], presum[i - 1] + 1);
		}
		newpre[i] = max(newpre[i], max(presum[i], newpre[i - 1]));
	}
	int newS = getdis();
	f[cur][newS][nxt] = (f[cur][newS][nxt] + preans) % mod;
}
int main(){
	ios::sync_with_stdio(false);
	cin >> n >> k;
	cin >> s;
	s=" "+s;
	init();
	for(int i=1;i<=n;i++){
		op=op^1;
		memset(f[op],0,sizeof(f[op]));
		for(int j=0;j<maxn;j++){
			for(int p=0;p<=2;p++){
				change(op,j,p,0,f[op^1][j][0]);
				change(op,j,p,1,f[op^1][j][1]);
				change(op,j,p,2,f[op^1][j][2]);
			}
		}
	}
	cnt[0]=0;
	for(int i=1;i<maxn;i++){
		cnt[i]=cnt[i>>1]+(i&1);
	}
	for(int i=0;i<maxn;i++) {
		for(int p=0;p<3;p++) {
			ans[cnt[i]]=(ans[cnt[i]]+f[op][i][p])%mod;
		}
	}
	for(int i=0;i<=k;i++){
		cout<<ans[i]<<endl;
	}
	
	
}
```
### 注释/后记：
在本机上跑了 14 秒（第 4 个点），但是吸氧后飞快欸！





---

## 作者：Komomo (赞：6)

题目中最难的限制是 LCS 长度为 $i$，我们先考虑一种最暴力的 dp：令 $S$ 为已知的串，$T$ 为未知的串，$f_{T,i}$ 表示当未知串为 $T$ 时，和 $S$ 匹配到第 $i$ 位的 LCS，这是很容易转移的，复杂度难以计量。

考虑优化，我们把 $f_{T,i}$ 压缩成 $f'_{T}$，也就是 $f'_{T}=\{f_{T,0},f_{T,1},\cdots,f_{T,|S|}\}$，我们考虑最关键的一步，把答案和状态换维。定义 $g_{f'_T}$ 为当 $T$ 与 $S$ 的前 $i$ 位匹配的的状态数组为 $f'_T$ 时，$T$ 的方案数。

然后你可能会想：这时间复杂度还是爆炸啊！考虑重新观察一下 $\mathcal O(n^2)$ 求 LCS 的状态转移方程：

$$dp_{i,j}=\max\{dp_{i-1,j}, dp_{i,j-1},dp_{i-1,j-1}+\color{red}{[S_i=T_j]}\color{black}\}$$

发现每次转移最多比转移过来的多 $1$，于是我们可以把状态数组差分：令 $g_{f'_T}$ 为 $T$ 与 $S$ 的前 $i$ 位匹配的的**差分**状态数组为 $f'_T$ 时，$T$ 的方案数。此时 $f'_T$ 每位只可能是 $0/1$，于是就可以状压了，至于判断是否出现 $\texttt{NOI}$，这个可以再加一维，比较简单。时间复杂度 $\mathcal O(3nk2^k)$，这理论是跑不过的。观察有大部分状态数组是不存在的，于是我们在转移的时候判断一下当前状态值是否为 $0$ 即可，这个剪枝快的有点太神秘了。

像这种基于一种 dp 结果为状态 dp 被称为 **dp 套 dp**，一般是令 $F_{state, f}$ 表示在另一种 dp 转移时状态为 $state$ 且值为 $f$ 的方案数，且 $F$ 一般是在另一种 dp 的转移自动机上转移的，这题因为建出自动机没用，所以不建立，需要建立的见 [[ZJOI2019] 麻将](https://www.luogu.com.cn/problem/P5279) 一题。

代码不长。


```cpp
void add(int &a, int b) { a = a + b >= P ? a + b - P : a + b; }
void dec(int S, int (&a)[15]) { 
  a[0] = 0; 
  for (int i = 0; i < l; i ++) 
    a[i] = (S >> i & 1) + a[max(0ll, i - 1)]; 
}

void enc(int &S, int a[15]) { 
  S = 0; 
  for (int i = l - 1; ~i; i --) 
    S = (S << 1) + a[i] - (i ? a[i - 1] : 0); 
}

int ins(char t, int S) { 
  int dp[15], pr = 0; dec(S, dp);
  for (int i = 0; i < l; i ++) { 
    int tmp = pr + (s[i] == t); 
    pr = dp[i], dp[i] = max({tmp, dp[i], dp[max(0ll, i - 1)]}); 
  } 
  
  return enc(S, dp), S; 
}

void mov(int S, int k) { 
  if (!f[nw][S][k]) return ; 
  
  int t = f[nw][S][k];
  if (!k) 
    add(f[nw ^ 1][ins('N', S)][1], t), 
    add(f[nw ^ 1][ins('O', S)][0], t), 
    add(f[nw ^ 1][ins('I', S)][0], t);
  else if (k - 1) 
    add(f[nw ^ 1][ins('N', S)][1], t), 
    add(f[nw ^ 1][ins('O', S)][0], t);
  else 
    add(f[nw ^ 1][ins('N', S)][1], t), 
    add(f[nw ^ 1][ins('O', S)][2], t), 
    add(f[nw ^ 1][ins('I', S)][0], t);
}

signed main() { 
  n = read(), l = read();
  scanf("%s", s), f[nw][0][0] = 1;
  for (int i = 1; i <= n; i ++, nw ^= 1) {
    for (int j = 0; j < (1 << l); j ++) 
      for (int k : {0, 1, 2}) f[nw ^ 1][j][k] = 0;
    for (int j = 0; j < (1 << l); j ++) 
      for (int k : {0, 1, 2}) mov(j, k);
  }

  for (int j = 0; j < (1 << l); j ++) 
    for (int k : {0, 1, 2}) { 
      int t = __builtin_popcount(j); 
      (ans[t] += f[nw][j][k]) %= P; 
    }

  for (int i = 0; i <= l; i ++) printf("%lld\n", ans[i]);
  
  return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：4)

考虑 dp。

我们发现带一个一般的状态难以支持最长公共子序列的转移。所以考虑先设计最长公共子序列的 dp。

设计 $f_{i,j}$ 表示考虑两个串 $[1,i]$ 与 $[1,j]$ 这两个前缀的最长公共子序列。

有：

1. 假若 $s_{i} = t_{j}$ 有 $f_{i,j} = f_{i-1,j-1} + 1$。

2. 否则 $f_{i,j} = \max(f_{i,j-1},f-{i-1,j})$。

考虑对于最长公共子序列的一个性质，$f_{i,j-1} \leq f_{i,j} \leq f_{i,j-1} + 1$。

而且 $j \leq 15$，这提示我们把对于所有 $i$ 相同且 $j$ 不同的 $f_{i,j}$ 的差分数组状压下来，然后使用 dp 套 dp 的方式去转移。

具体来说，再设计状态 $dp_{i,S,t}$ 表示考虑到兑奖串第 $i$ 位，并且所有 $f_{i,j}$ 的差分数组状态为 $S$，此时末尾与串 $\texttt{NOI}$ 的匹配位数为 $t$ 的方案树数。

采取填表法转移，每次先将 $f_{i,j}$ 还原出来，然后枚举下一位填什么，按 **内层求解最长公共子序列的动态规划** 求出 $f_{i+1,j}$ 再差分后状压起来作贡献。

那么复杂度是 $O(nk \times 2^k)$ 将空状态剪枝后可以通过。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 1e9+7;
const int maxk = 16;
const int maxn = 1145;
int dp[1<<maxk][3];
int f[1<<maxk][3];
int n,k;
char T[maxk];
int lcs[maxk];
int nxt[maxk];
void to1(int v){
    for(int i=1;i<=k;i++)
        if((1<<(i-1))&v) lcs[i]=1;
        else lcs[i]=0;
    for(int i=1;i<=k;i++) lcs[i]+=lcs[i-1];
}
int to2(){
    int v=0;
    for(int i=1;i<=k;i++) if(nxt[i]-nxt[i-1]==1) v+=(1<<(i-1));
    return v;
}
int ans[maxk+1];
signed main(){
    cin>>n>>k;
    for(int i=1;i<=k;i++) cin>>T[i];
    dp[0][0]=1;
    for(int i=0;i<n;i++){
        for(int j=0;j<(1<<k);j++){
            for(int t=0;t<3;t++){
                if(dp[j][t]==0) continue;
                //N
                to1(j);
                for(int h=1;h<=k;h++){
                    if(T[h]=='N') nxt[h]=lcs[h-1]+1;
                    else nxt[h]=max(nxt[h-1],lcs[h]);
                }
                f[to2()][1]=(f[to2()][1]+dp[j][t])%mod;
                //O
                to1(j);
                for(int h=1;h<=k;h++){
                    if(T[h]=='O') nxt[h]=lcs[h-1]+1;
                    else nxt[h]=max(nxt[h-1],lcs[h]);
                }
                if(t!=1){
                    f[to2()][0]=(f[to2()][0]+dp[j][t])%mod;
                }else{
                    f[to2()][2]=(f[to2()][2]+dp[j][t])%mod;
                }
                //I
                if(t!=2){
                    to1(j);
                    for(int h=1;h<=k;h++){
                        if(T[h]=='I') nxt[h]=lcs[h-1]+1;
                        else nxt[h]=max(nxt[h-1],lcs[h]);
                    }
                    f[to2()][0]=(f[to2()][0]+dp[j][t])%mod;
                }
            }
        }
        for(int j=0;j<(1<<k);j++)
            for(int t=0;t<3;t++) dp[j][t]=f[j][t],f[j][t]=0;
    }
    for(int j=0;j<(1<<k);j++){
        for(int t=0;t<3;t++){
            to1(j);
            ans[lcs[k]]=(ans[lcs[k]]+dp[j][t])%mod;
        }
    }
    for(int i=0;i<=k;i++) cout<<ans[i]<<'\n';
    return 0;
}

```




---

## 作者：cainiaoshanglu (赞：4)

dp套dp是一种比较冷门的小技巧，可以用来解决一些字符串问题。

其基本思想在于将dp的过程视作自动机，将dp的状态视作节点，并在此之上跑自动机dp，从而解决复杂的问题。

例题：P4590 [TJOI2018]游园会

简要题意：给出 $n,k$ 以及一个长度为 $k$ 的字符串，求长度为 $n$， 而且与给定字符串最长子序列长度为 $0$ 到 $k$ 的字符串数量。字符串内不得包含"NOI"作为子串。

注意到题目要求十分割裂，我们考虑先解决后一半，即关于"NOI"的部分。我们可以提出基本方案：$dp_{i,j}$ 表示长度为 $i$，"NOI"完成进度为 $j$ 的方案数。 此时我们需要去处理的问题是在基本方案下加维来维护最长子序列信息。

当我们在字符串上处理类似问题时，我们通常都会借助自动机，但并没有能够维护这类信息的“子序列自动机”。但是我们可以使用其他的结构：dp。 我们令 $f_{i,j}$ 表示原串前 $i$ 个字符和给定串前 $j$ 个字符的最长公共子序列，转移式显然。该式某一行只取决于当前转移的字符以及上一行的数据，而第二维长度不大，考虑以第二位组成的数组为节点，建立自动机。但是我们显然不能承受枚举所有数组的负担，考虑压缩。注意到第二位连续两点之间必然相差0或1，故将原数组差分后将是一个01串，状压dp即可。
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
#include <vector>
#include <map>
#include <cmath>
#include <cassert>
using namespace std; 

const int md=1e9+7;
void read(int &x){
	x=0;
	int f=1;
	char c=getchar();
	while(!('0'<=c && c<='9')){
		if(c=='-'){
			f=-1;
		}
		c=getchar();
	}
	while('0'<=c && c<='9'){
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	x*=f;
} 
int n,k,dp[2][40010][3]={0},res[20]={0};
char s[20];
int getnxt(int stat,char cur){
	int num=0,sum=0,prv=0,c=0;
	for(int i=0;i<15;i++){
		sum+=(((c=max(num+(cur==s[i]),max(prv,num+((stat>>i)&1))))-prv)<<i);
		num+=(stat>>i)&1;
		prv=c;
	}
	return sum;
}
int count(int k){
	int res=0;
	for(int i=0;i<15;i++){
		res+=(k>>i)&1;
	}
	return res;
}
signed main(){
	read(n);
	read(k);
	scanf(" %s",s);
	dp[0][0][0]=1;
	for(int i=0;i<n;i++){
		memset(dp[(i&1)^1],0,sizeof(dp[(i&1)^1]));
		for(int j=0;j<(1<<k);j++){
			//printf("[%lld %lld %lld] ",dp[i&1][j][0],dp[i&1][j][1],dp[i&1][j][2]);
			int nxt=getnxt(j,'N');
			(dp[(i&1)^1][nxt][1]+=dp[i&1][j][0])%=md;
			(dp[(i&1)^1][nxt][1]+=dp[i&1][j][1])%=md;
			(dp[(i&1)^1][nxt][1]+=dp[i&1][j][2])%=md;
			nxt=getnxt(j,'O');
			(dp[(i&1)^1][nxt][0]+=dp[i&1][j][0])%=md;
			(dp[(i&1)^1][nxt][2]+=dp[i&1][j][1])%=md;
			(dp[(i&1)^1][nxt][0]+=dp[i&1][j][2])%=md;
			nxt=getnxt(j,'I');
			(dp[(i&1)^1][nxt][0]+=dp[i&1][j][0])%=md;
			(dp[(i&1)^1][nxt][0]+=dp[i&1][j][1])%=md;
		}
		//putchar('\n');
	}
	for(int j=0;j<(1<<k);j++){
		for(int l=0;l<=2;l++){
			(res[count(j)]+=dp[n&1][j][l])%=md;
		}
	}
	for(int i=0;i<=k;i++){
		printf("%lld\n",res[i]);
	}
	return 0;
}

```


---

## 作者：Purslane (赞：2)

# Solution

[感谢 Dead_X 的博客](https://www.cnblogs.com/dead-X/p/14274671.html)

这是经典的 DP 套 DP 的题目。

考虑如果给了你最终小豆的序列，那么你可以用如下手段求出 $\text{LCS}$ 数组：

$$dp_{x,y}=\max\{dp_{x-1,y},dp_{x,y-1},dp_{x-1,y-1}+[S_x=T_y]\}$$

（第一维表示题目给定的 $S$ 数组，第二维表示小豆的序列）

考虑从左到右依次确定小豆的序列。在计数的时候，我们有必要关心 $dp_{x,y}$ 在当前这一列的所有情况。（第一维是行，第二维是列）

然后你灵机移动发现 $dp_{x,y} \le dp_{x+1,y}$，而且根据实际意义，必定有 $dp_{x,y}+1 \ge dp_{x+1,y}$（反证法显然），那么当且这一列事实上只有 $2^{|S|}$ 种。因此我们可以把它作为一个状态。

顺带记录一下末尾有没有 $\text{N}$ 和 $\text{NO}$ 就做完了。

所以为啥叫做 DP 套 DP？

考虑 DP 实际上是一个 DFA 上乱跑，比如本题中我们就可以认为求 LCS 的 DP 是 $2^{|S|}$ 个状态的 DFA 上通过 $\text{N}$，$\text{O}$ 和 $\text{I}$ 三种情况进行转移。那么我们把内层 DP 的结果当做外层 DP 的状态，就是 DP 套 DP。

时间复杂度为 $O(2^k \times n)$，我坚信他能过。

---

## 作者：takanashi_mifuru (赞：2)

考虑 dp 套 dp。

首先考虑把他写成一个没有脑子的 dp，设 $dp_{i,j}$ 表示兑奖串的前 $i$ 个字符与小豆收集的奖章串的前 $j$ 个字符的 LCS 的长度。

这里我们假设兑奖串为 $A$，小豆的奖章串为 $B$。

转移方程也很明显 $dp_{i,j}=\max(dp_{i,j-1},dp_{i-1,j},dp_{i-1,j-1}+[A_i=B_j])$

然后我们考虑怎么求方案数，如果我们只需要这个的话那么我们可以尝试将第一维滚掉然后，然后你发现这个东西变得奇小无比，同时你发现他单调不降的同时，相比前面那个至多增加 $1$，然后你考虑我们把他的差分数组当作状态，然后现在就变成要求 $f_{i,S}$ 表示当前推到第 $i$ 位，然后 $dp$ 数组状态为 $S$ 时的匹配方案数。

你发现这个东西是很容易推的，因为我现在确定了前 $i-1$ 位之后只需要确定一下第 $i$ 位，然后你再遍历一遍状态就可以实时更新下一步的状态。

看上去很对，实际上出现了一个极大的问题就是我们没有保证他不出现 NOI 这个子串，那我们怎么处理让 NOI 这个子串不出现呢，你记第 $3$ 维表示目前末尾连续出现了 NOI 的第几个前缀，然后对着这个转移就行了。

时间复杂度忽略常数是 $O(nk2^k)$ 的，同时有一个强力剪枝，就是如果一个状态为 $0$ 就不更新，最后时间复杂度应该是 $O($ 能过 $)$ 这样子。

时间可以剪枝卡，空间不能，所以还要滚动数组维护一下 dp 数组。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k;
int f[3][1<<15];
int dp[3][1<<15];
string T;
int LCS[20];
int ans[20];
int getState(char c,int S){
   for(int i=0;i<k;i++){
      LCS[i+1]=LCS[i]+((S>>i)&1);
   }
   int pre=0;
   for(int i=0;i<k;i++){
      int tmp=pre+(c==T[i]);
      pre=LCS[i+1];
      LCS[i+1]=max(LCS[i+1],max(tmp,LCS[i]));
   }
   int P=0;
   for(int i=k;i>=1;i--){
      P=P<<1;
      P=P|(LCS[i]-LCS[i-1]);
   }
   return P;
}
const int P=1000000007;
void del(int &x){
   if(x>P)x-=P;
}
void solve(int cnt,int S){
   if(!f[cnt][S])return;
   if(cnt==0){
      (dp[1][getState('N',S)]+=f[cnt][S])%=P;
      (dp[0][getState('O',S)]+=f[cnt][S])%=P;
      (dp[0][getState('I',S)]+=f[cnt][S])%=P;
   }
   else if(cnt==1){
      (dp[1][getState('N',S)]+=f[cnt][S])%=P;
      (dp[2][getState('O',S)]+=f[cnt][S])%=P;
      (dp[0][getState('I',S)]+=f[cnt][S])%=P;
   }
   else{
      (dp[1][getState('N',S)]+=f[cnt][S])%=P;
      (dp[0][getState('O',S)]+=f[cnt][S])%=P;
   }
}
signed main(){
   scanf("%lld%lld",&n,&k);
   cin>>T;
   dp[0][0]=1;
   for(int i=1;i<=n;i++){
      for(int cnt=0;cnt<3;cnt++){
         for(int S=0;S<(1<<k);S++){
            f[cnt][S]=dp[cnt][S];
            dp[cnt][S]=0;
         }
      }
      for(int cnt=0;cnt<3;cnt++){
         for(int S=0;S<(1<<k);S++){
            solve(cnt,S);
         }
      }
   }
   for(int cnt=0;cnt<3;cnt++){
      for(int S=0;S<(1<<k);S++){
         int len=0;
         int P=S;
         while(P){
            len+=(P&1);
            P>>=1;
         }
         ans[len]+=dp[cnt][S];
         del(ans[len]);
      }
   }
   for(int i=0;i<=k;i++){
      printf("%lld\n",ans[i]);
   }
   return 0;
}
```

---

## 作者：Leasier (赞：2)

- **dp 套 dp 的套路。**

在已知兑奖串的情况下，我们不难通过 dp 求出其与奖章串的 LCS 的。

注意到每向兑奖串加入一个字符，求 LCS 的 dp 只会更新一行的信息。

又注意到这一行中每个位置的差分要么是 $0$、要么是 $1$，考虑把差分压进状态，设 $dp_{i, S, j}$ 表示讨论到第 $i$ 个字符，求 LCS 的 dp 的当前行差分为 $S$，$j = 0/1/2$ 分别表示 `N`、`O`、`I` 的方案数。

转移时讨论一下 $j$ 的变化，$S$ 的变化就直接把真实 dp 数组解压出来转移一次即可。

时间复杂度为 $O(n 2^k)$，空状态剪枝即可通过。

代码：
```cpp
#include <stdio.h>

const int mod = 1e9 + 7;
int dp[7][32777][7], f[17], g[17], ans[17];
char s[17];

inline int max(int a, int b){
	return a > b ? a : b;
}

inline int trans(int n, int state, char ch){
	int ans = 0;
	for (int i = 1; i <= n; i++){
		f[i] = f[i - 1] + (state >> (i - 1) & 1);
	}
	for (int i = 1; i <= n; i++){
		g[i] = max(g[i - 1], f[i]);
		if (s[i] == ch) g[i] = max(g[i], f[i - 1] + 1);
	}
	for (int i = 1; i <= n; i++){
		if (g[i] != g[i - 1]) ans |= 1 << (i - 1);
	}
	return ans;
}

inline void add(int &x, int y){
	if ((x += y) >= mod) x -= mod;
}

int main(){
	int n, k, full, lst;
	scanf("%d %d", &n, &k);
	scanf("%s", &s[1]);
	full = (1 << k) - 1;
	lst = n & 1;
	dp[0][0][0] = 1;
	for (int i = 0; i < n; i++){
		int cur = i & 1, nxt = cur ^ 1;
		for (int j = 0; j <= full; j++){
			for (int k = 0; k <= 2; k++){
				dp[nxt][j][k] = 0;
			}
		}
		for (int j = 0; j <= full; j++){
			int p, q, r;
			if (dp[cur][j][0] != 0 || dp[cur][j][1] != 0 || dp[cur][j][2] != 0){
				p = trans(k, j, 'N');
				q = trans(k, j, 'O');
			}
			if (dp[cur][j][0] != 0 || dp[cur][j][1] != 0) r = trans(k, j, 'I');
			if (dp[cur][j][0] != 0){
				add(dp[nxt][p][1], dp[cur][j][0]);
				add(dp[nxt][q][0], dp[cur][j][0]);
				add(dp[nxt][r][0], dp[cur][j][0]);
			}
			if (dp[cur][j][1] != 0){
				add(dp[nxt][p][1], dp[cur][j][1]);
				add(dp[nxt][q][2], dp[cur][j][1]);
				add(dp[nxt][r][0], dp[cur][j][1]);
			}
			if (dp[cur][j][2] != 0){
				add(dp[nxt][p][1], dp[cur][j][2]);
				add(dp[nxt][q][0], dp[cur][j][2]);
			}
		}
	}
	for (int i = 0; i <= full; i++){
		int cnt = __builtin_popcount(i);
		for (int j = 0; j <= 2; j++){
			add(ans[cnt], dp[lst][i][j]);
		}
	}
	for (int i = 0; i <= k; i++){
		printf("%d\n", ans[i]);
	}
	return 0;
}
```

---

## 作者：elijahqi (赞：2)

题意：给定一个串s lenth<=15 给一个n 再给一个字符集 问n长度的串中不出现noi 且n长度的串与s串的lcs为等级 求每个等级有多少个不同的n长度的串
题解：http://www.elijahqi.win/archives/3265   
这个为基础
在原有的dp数组上再增加一维[0/1/2]分别表示当前串的末尾构成的noi的长度为多少了
然后枚举八种情况 分别转移即可
```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int mod=1e9+7;
int g[20],h[20],w[20],S,dp[2][33768][3],mp[3][3],trans[33768][3],bin[20],n,m,ans[20];char s1[20];
inline int make(int *h){int s=0;
	for (int i=1;i<=n;++i){
		s|=(h[i]-h[i-1])*bin[i-1];
	}return s;
}
inline void make1(int *g,int s){g[0]=0;
	for (int i=1;i<=n;++i) g[i]=g[i-1],g[i]+=(s&bin[i-1])>0;
}
inline void pre(){
	for (int owo=0;owo<3;++owo){
		for (int s=0;s<=S;++s){
			make1(g,s);memset(h,0,sizeof(h));
			for (int i=1;i<=n;++i)
				h[i]=max(h[i-1],max(g[i],(w[owo]==s1[i])*(g[i-1]+1)));
			trans[s][owo]=make(h);
		}
	}
}
inline void inc(int &x,int v){x=x+v>=mod?x+v-mod:x+v;}
inline int bc(int x){int tmp=0;
	for (int i=0;i<=n;++i) if (x&bin[i]) ++tmp;return tmp;
}
int main(){
	freopen("party.in","r",stdin);
	freopen("party.out","w",stdout);
	scanf("%d%d",&m,&n);w[0]='N';w[1]='O';w[2]='I';
	for (int i=0;i<=15;++i) bin[i]=1<<i;
	scanf("%s",s1+1);S=(1<<n)-1;pre();int pre=0,now=1;
	mp[0][0]=1;mp[0][1]=0;mp[0][2]=0;mp[1][0]=1;
	mp[1][1]=2;mp[1][2]=0;mp[2][0]=1;mp[2][1]=0;dp[pre][0][0]=1;
	for (int i=0;i<m;++i){
		memset(dp[now],0,sizeof(dp[now]));
		for (int s=0;s<=S;++s){
			for (int j=0;j<=2;++j){
				for (int owo=0;owo<=2;++owo){
					if (owo==2&&j==2) continue;
					int y=trans[s][owo];
					inc(dp[now][y][mp[j][owo]],dp[pre][s][j]);
				}
			}
		}pre^=1;now^=1;
	}
	for (int s=0;s<=S;++s)
		for (int j=0;j<=2;++j) inc(ans[bc(s)],dp[pre][s][j]);
	for (int i=0;i<=n;++i) printf("%d\n",ans[i]);
	return 0;
}
                          ```

---

## 作者：封禁用户 (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P4590)

### 题意

给出一个长度为 $m$ 的字符串 $s$，构造出长度为 $n$ 的字符串 $t$，其中 $t$ 不含子串 $\text{NOI}$，分别求出 $s$ 和 $t$ 的最长公共子序列长度为 $0$ ~ $m$ 的 $t$ 的个数对 $10^9+7$ 取模的结果。

### 分析

首先，让我们回忆一下最长公共子序列的转移方程：

$dp_{i,j} \leftarrow \begin{cases}dp_{i-1,j-1}+1 & s_i=t_j\\
\max(dp_{i-1,j},dp_{i,j-1}) & s_i \ne t_j\\\end{cases}$

我们需要记录之前的状态：

所以我们可以发现，对于 $dp_{i,j}$，随着 $j$ 的不断增大，$dp_{i,j}$ 一定是单调不减的，且相邻两个最多相差 1。

所以，其差分数组一定是一串只含 0 和 1 的数字。

然后就可以进行状态压缩 DP 了。

我们定义：$dp_{i,j}$ 为前 $i$ 个字符中，目前的状态为 $j$ 的情况个数。

我们将 $j$ 拆成 0 和 1，重新累一遍前缀和，还原出状态，然后插入一个字符 $num$，根据以上的状态转移方程得到新的状态，重新求一遍差分，得到新的状态，记录状态之间的转移，记为 $nxt_{j,num}$。

状态转移方程为：$dp_{i,j} \leftarrow \sum_{j=0}^{2^m} dp_{i-1,nxt_{j,num}}$，其中 $num$ 取三个字符。

但事实上，这还是不够的，因为题目还有一个条件：不能出现连续的 $\text{NOI}$。

我们修改状态为 $dp_{i,j,k}$ 其中 $k \subseteq \{0,1,2\}$。$i$ 和 $j$ 的意义同上所述，$k$ 描述结尾。

+ 当 $k=1$ 时，选择字符串以 $\text{N}$ 为结尾。

+ 当 $k=2$ 时，选择字符串以 $\text{NO}$ 为结尾。

+ 当 $k=0$ 时，选择字符串为除了以上两种和 $\text{NOI}$ 以外的其它合法结尾。

状态转移方程过于复杂，总共 8 条，直接放代码和注释：

```cpp
add(dp[i&1][nxt[j][0]][1],dp[i-1&1][j][0]);//其它 + N = N
add(dp[i&1][nxt[j][0]][1],dp[i-1&1][j][1]);//N + N = N
add(dp[i&1][nxt[j][0]][1],dp[i-1&1][j][2]);//NO + N = N
add(dp[i&1][nxt[j][1]][0],dp[i-1&1][j][0]);//其它 + O = 其它
add(dp[i&1][nxt[j][1]][2],dp[i-1&1][j][1]);//N + O = NO
add(dp[i&1][nxt[j][1]][0],dp[i-1&1][j][2]);//NO + O = 其它
add(dp[i&1][nxt[j][2]][0],dp[i-1&1][j][0]);//其它 + I = 其它
add(dp[i&1][nxt[j][2]][0],dp[i-1&1][j][1]);//N + I = 其它 
//NO + I = NOI 不合法 
```
注意以 $\text{NO}$ 为结尾的字符串后接 $\text{I}$ 组成了 $\text{NOI}$，不合法。

注意如果直接开 DP 数组，空间会爆，所以应当使用滚动数组优化空间。

### AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define F(i,a,b) for(register int i=a;i<=b;++i)
const int mod = 1e9 + 7;
inline void add(int &x,int y) {(x += y) >= mod&&(x -= mod);}
int to[128],ans[20];
int nxt[32768][3],a[20],p[20],q[20],n,m;
int dp[2][32768][3]; 
//0 字母'N'  其余非"NOI"末尾
//1  字母'O' 末尾为"N"
//2 字母'I' 末尾为"NO" 
int main()
{
	to['N'] = 0,to['O'] = 1,to['I'] = 2;
	scanf("%d%d",&n,&m);
	getchar();//注意要读掉'\n' 
	F(i,1,m) a[i] = to[getchar()];
	F(i,0,(1<<m)-1)
	{
		F(j,0,m-1)
		{
			if(i & (1<<j)) p[j+1] = p[j] + 1;
			else p[j+1] = p[j];	
		}	
		F(num,0,2)
		{
			F(j,1,m)
			{
				if(a[j] == num) q[j] = p[j-1]+1;	
				else q[j] = max(q[j-1],p[j]);	
			}
			int t = 0;
			F(j,0,m-1) 
				if(q[j+1] > q[j])
					t |= 1<<j;
			nxt[i][num] = t;
		}
	}
	dp[0][0][0] = 1;
	F(i,1,n)
	{
		memset(dp[i&1],0,sizeof(dp[i&1]));
		F(j,0,(1<<m)-1)
		{
			add(dp[i&1][nxt[j][0]][1],dp[i-1&1][j][0]);//其它 + N = N
			add(dp[i&1][nxt[j][0]][1],dp[i-1&1][j][1]);//N + N = N
			add(dp[i&1][nxt[j][0]][1],dp[i-1&1][j][2]);//NO + N = N
			add(dp[i&1][nxt[j][1]][0],dp[i-1&1][j][0]);//其它 + O = 其它 
			add(dp[i&1][nxt[j][1]][2],dp[i-1&1][j][1]);//N + O = NO
			add(dp[i&1][nxt[j][1]][0],dp[i-1&1][j][2]);//NO + O = 其它
			add(dp[i&1][nxt[j][2]][0],dp[i-1&1][j][0]);//其它 + I = 其它
			add(dp[i&1][nxt[j][2]][0],dp[i-1&1][j][1]);//N + I = 其它 
			//NO + I = NOI 不合法 
		}
	}	
	F(i,0,(1<<m)-1)
	{
		int cnt = 0;
		F(j,0,m-1)
			if(i & (1<<j))
				++cnt;
		add(ans[cnt],dp[n&1][i][0]);
		add(ans[cnt],dp[n&1][i][1]);
		add(ans[cnt],dp[n&1][i][2]);
	}
	F(i,0,m) printf("%d\n",ans[i]);
    return 0;
}
```
### 拓展

可以发现，这题其实要实现，**对信号序列进行判断的数学模型**，即自动机。

推荐阅读：[自动机介绍](https://oi-wiki.org/string/automaton/#%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89)。

---

## 作者：__Ressed__ (赞：1)

~~题解劝退系列~~

(参考了elijahqi巨佬的题解）

设长的那个串是Ａ，短的那个串是Ｂ。

那我们在如果已经知道某个Ａ的时候，Ａ[1..i]和Ｂ[1..j]的最长公共子序列$f[i][j]=max\{f[i-1][j],f[i][j-1],f[i-1][j-1]+(A[i]==B[i])\}$

于是可以递推来枚举A，顺手把NOI的情况判掉。但这复杂度显然过不了。

注意到在推的时候，每新加一个字符，就可以由f[i-1]推出f[i]，也就是说，我们根本不用记递推出来的这个A具体是什么，只要记住这个f[i]就可以了。

怎么记呢？注意到f[i][j]只能等于f[i][j-1]或者f[i][j-1]+1，也就是说，我们可以先差分这个f[i]，然后状压就能记下来了。

设trans[s][k]表示原本f数组状态是s、新加了一个k字符，转移到的状态

那么可以得到递推式$g[i+1][trans[s][k]]=\sum{g[i][s]}$,g[N][s]就是最后状态s的情况数，只要统计一下s中1的个数，记到答案里就行了。

然而还要判NOI

其实很简单，只要给g多记一维，用来表示现在这个状态已经匹配到了NOI的几位就可以了

（0,1,2通过"N"转移到1;1通过“O”转移到2;2通过“I”转移到3（这个情况不合法））

要开滚动数组

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
#include<map>
#include<cmath>
#include<ctime>
#include<set>
#define pa pair<int,int>
#define lowb(x) ((x)&(-(x)))
#define REP(i,n0,n) for(i=n0;i<=n;i++)
#define PER(i,n0,n) for(i=n;i>=n0;i--)
#define MAX(a,b) ((a>b)?a:b)
#define MIN(a,b) ((a<b)?a:b)
#define CLR(a,x) memset(a,x,sizeof(a))
#define rei register int
using namespace std;
const int maxn=1010,maxk=16,maxs=32768,p=1e9+7;
typedef long long ll;

ll rd(){
	ll x=0;char c=getchar();int neg=1;
	while(c<'0'||c>'9'){if(c=='-') neg=-1;c=getchar();}
	while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
	return x*neg;
}

int N,K,M;
int wd[maxk],ans[maxk],ne[3][3];
int f[2][maxs][3],trans[maxs][3],cnt[maxs];

inline void modadd(int &x,int y){x=(x+y)%p;}

int main(){
	//freopen(".in","r",stdin);
	rei i,j,k,l;
	N=rd(),K=rd();M=1<<K;
	i=0;while(i<K){
		char c=getchar();
		if(c=='N') wd[++i]=0;
		else if(c=='O') wd[++i]=1;
		else if(c=='I') wd[++i]=2;
	}
	REP(i,0,M-1){
		REP(j,0,2){
			int s=0,sum=0,lst=0,now=0;
			REP(k,1,K){
				if(wd[k]==j) now=sum+1;
				if(i&(1<<(k-1))) sum++;
				if(wd[k]!=j) now=sum;
				s+=(now>lst)<<(k-1);lst=MAX(lst,now);
			}trans[i][j]=s;cnt[i]=sum;
		//printf("%d %d %d %d\n",i,j,s,sum);
		}
	}
	ne[1][1]=2;ne[0][0]=ne[1][0]=ne[2][0]=1;
	bool b=0;f[0][0][0]=1;
	REP(i,0,N-1){
		//memcpy(f[b],f[b^1],sizeof(f[b]));
		CLR(f[b^1],0);
		REP(j,0,M-1){
			REP(l,0,2){if(!f[b][j][l]) continue;
				REP(k,0,2){
					if(l==2&&k==2) continue;
					modadd(f[b^1][trans[j][k]][ne[l][k]],f[b][j][l]);
					//printf("f[%d][%d][%d]=%d -%d> ",i,j,l,f[b][j][l],k);
				//	printf("f[%d][%d][%d]=%d\n",i+1,trans[j][k],ne[l][k],f[b^1][trans[j][k]][ne[l][k]]);
				}
			}
		}b^=1;
	}
	REP(i,0,M-1){
		REP(j,0,2)
			modadd(ans[cnt[i]],f[b][i][j]);
	}REP(i,0,K) printf("%d\n",ans[i]);
	return 0;
}


```

---

## 作者：User_Unauthorized (赞：0)

首先考虑如何求出两个字符串 $S, T$ 的 LCS，设 $f_{i, j}$ 表示 $S\left[1, i\right]$ 和 $T\left[1, j\right]$ 的 LCS 长度。发现其有如下转移：

$$f_{i, j} = 
\begin{cases}
f_{i - 1, j - 1} + 1 && S_i = T_j \\
\max\left\{f_{i, j - 1}, f_{i-  1, j}\right\} && S_i \neq T_j
\end{cases}$$

我们考虑对上述判定 DP 的过程进行计数，具体的，将上述判定 DP 结果相同的前缀作为相同的子问题进行合并后计数以优化复杂度，但是若直接对于某个 $i$ 将所有的 $f_{i, j}$ 值均压入状态那么状态数为 $\mathcal{O}(N \times K^K)$，无法接受，需要进一步发掘性质。

我们可以发现，对于某个 $i$，我们有 $f_{i, j} - f_{i, j - 1} \le 1$，即 $f$ 数组的差分值值域为 $\left[0, 1\right]$，若将查分数组压入状态那么复杂度是 $\mathcal{O}(N \times 2^K)$ 级别的，可以接受。

进而我们可以预处理出判定 DP 的转移边，即对于所有可能的 $f_{i, *}$，枚举 $S_{i + 1}$ 的值并计算得到的 $f_{i + 1, *}$。接下来进行计数，设 $g_{i, S}$ 表示长度为 $i$ 的，使得 $f_{i}$ 差分值在 $S$ 处为 $1$ 的字符串数量，转移时枚举所有合法的下一个字符并预处理的转移边进行转移即可。

考虑如何处理其中不能出现 $\tt{NOI}$ 子串的限制，在我们的计数 DP 中额外维护一维代表其目前与 $\tt{NOI}$ 匹配的长度即可，注意这里的匹配要求必须选择最后一个字符，例如字符串 $\tt{NONONONONONONONONON}$ 的匹配长度为 $1$。

至此我们便可以通过此题，复杂度为 $\mathcal{O}(N 2^K)$。

---

## 作者：tribool4_in (赞：0)

dp 套 dp。

首先显然考虑对兑奖串进行 dp。设当前填到了第 $i$ 位，则考虑设 $f_{i,0/1/2,S}$，其中 $0/1/2$ 表示目前连续填了 `NOI` 串中的前几位，$S$ 表示当前匹配奖章串的状态。

考虑如何表示状态。发现由于最长公共子序列不一定是奖章串中连续的一段，可能的状态数大概是 $2^K$ 种。注意到最长公共子序列是一个经典的 dp 问题，考虑设 $g_{i,j}$，显然有 $g_{i,j}=\max(g_{i-1,j},g_{i,j-1},(g_{i-1,j-1}+1)[s_i=t_j])$。

在原问题中，$s$ 的字符为依次加入的，则考虑去掉第一维，用新字符 $c$ 更新 $g$，则有：$g_{j}=\max(g'_{j},g_{j-1},(g'_{j-1}+1)[c=t_j])$，这里 $g'$ 表示更新前的状态。

很明显，如上的一个 $g$ 一一对应到一个匹配状态，但是直接把 $g$ 数组作为 $S$ 较麻烦。注意到一个重要事实 $0\le g_{i+1}-g_i\le 1$，所以可以将 $g$ 的差分数组作为 $S$，转移的时候枚举字符 $c$ 并将 $S$ 更新为新状态。

代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e3 + 10, K = 15 + 10;
const int mod = 1e9 + 7;
int n, m, t[K];
char ts[K];
ll f[2][3][1 << 15];
int s[K];
int stat_trans(int k, int ch) {
    for (int i = 0; i < m; i++) s[i] = (k >> i & 1) + (i == 0 ? 0 : s[i - 1]);
    int sf = 0, ret = 0;
    for (int i = 0; i < m; i++) {
        int cur = max(s[i], sf);
        if (t[i] == ch) cur = max(cur, (i == 0 ? 0 : s[i - 1]) + 1);
        assert(cur - sf < 2);
        ret |= ((cur - sf) << i);
        sf = cur;
    }
    return ret;
}
int ans[K];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n >> m >> ts;
    for (int i = 0; i < m; i++) t[i] = (ts[i] == 'N' ? 0 : (ts[i] == 'O' ? 1 : 2));
    f[0][0][0] = 1;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < 3; j++) {
            for (int k = 0; k < (1 << m); k++) {
                f[i & 1 ^ 1][j][k] = 0;
            }
        }
        for (int j = 0; j < 3; j++) {
            for (int k = 0; k < (1 << m); k++) {
                if (!f[i & 1][j][k]) continue;
                for (int c = 0; c < (j == 2 ? 2 : 3); c++) {
                    (f[i & 1 ^ 1][(j == c ? j + 1 : (c == 0 ? 1 : 0))][stat_trans(k, c)] += f[i & 1][j][k]) %= mod;
                }
            }
        }
    }
    for (int i = 0; i < (1 << m); i++) {
        int pc = __builtin_popcount(i);
        (ans[pc] += (f[n & 1][0][i] + f[n & 1][1][i] + f[n & 1][2][i]) % mod) %= mod;
    }
    for (int i = 0; i <= m; i++) cout << ans[i] << '\n';
    return 0;
}
```

---


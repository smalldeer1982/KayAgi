# [TJOI2018] 碱基序列

## 题目描述

小豆参加了生物实验室。在实验室里，他主要研究蛋白质。他现在研究的蛋白质是由 $k$ 个氨基酸按一定顺序构成的。每一个氨基酸都可能有 $a$ 种碱基序列 $s_{i,j}$ 构成。

现在小豆有一个碱基串 $s$，小豆想知道在这个碱基上都多少种不同的组合方式可能得到这个蛋白质。即求由 $k$ 段字符串有序合并成的字符串 $s_1$，有多少种不同方式能够匹配字符串 $s$，其中 $k$ 段字符串的选法不同，或者与 $s$ 匹配上的位置不同认为是不同的方式。

## 说明/提示

### 样例 1 解释

- 第一个选 $\tt A$ 第二个选 $\tt C$，得到 $\tt AC$ 能够与 $\tt ABC$ 产生 $0$ 种匹配方式；
- 第一个选 $\tt A$ 第二个选 $\tt BC$，得到 $\tt ABC$ 能够与 $\tt ABC$ 产生 $1$ 种匹配方式；
- 第一个选 $\tt AB$ 第二个选 $\tt C$，得到 $\tt ABC$ 能够与 $\tt ABC$ 产生 $1$ 种匹配方式；
- 第一个选 $\tt AB$ 第二个选 $\tt BC$，得到 $\tt ABBC$ 能够与 $\tt ABC$ 产生 $0$ 种匹配方式。

所以一共 $2$ 种。

### 样例 2 解释

- 第一个选 $\tt A$ 第二个选 $\tt A$，得到 $\tt AA$ 能够与 $\tt AAA$ 产生 $2$ 种匹配方式；
- 第一个选 $\tt A$ 第二个选 $\tt AA$，得到 $\tt AAA$ 能够与 $\tt AAA$ 产生 $1$ 种匹配方式；
- 第一个选 $\tt AA$ 第二个选 $\tt A$，得到 $\tt AAA$ 能够与 $\tt AAA$ 产生 $1$ 种匹配方式；
- 第一个选 $\tt AA$ 第二个选 $\tt AA$,得到 $\tt AAAA$ 能够与 $\tt AAA$ 产生 $0$ 种匹配方式。

所以一共 $4$ 种。

### 数据范围及约定

- 对于 $30\%$ 的数据，$1\leq k\leq 25$，$1\le |s|\leq 10000$，$1\le a_i\leq 3$。
- 对于 $100\%$ 的数据，$1\leq k\leq100$，$1\le |s|\leq 10000$，$1\le a_i \leq10$。碱基序列的长度均不超过 $15$。字符集为大写字母。

## 样例 #1

### 输入

```
2
ABC
2 A AB
2 C BC```

### 输出

```
2```

## 样例 #2

### 输入

```
2
AAA
2 A AA
2 A AA```

### 输出

```
4```

# 题解

## 作者：billtun (赞：9)

这这这不是 DP 吗？

题目大意：一个蛋白质，由 $k$ 个氨基酸组成，第 $i$ 个氨基酸有 $a_i$ 种可能性，对于每种蛋白质可能，$ans$ 加上蛋白质在他给出的碱基串中出现的次数。

用 $dp_{i,j}$ 表示第 $i$ 个氨基酸选完后，完成前 $j$ 个碱基有几种可能性（由于没有说从必须到开头或结尾，所以 $dp_{0,j}$ 需要赋初值为 $1$，$0<=j<=s.size()$）。

判断是否相等可以用hash维护，时间复杂度为 $O(\sum _ {i = 1} ^ k a_i \times k \times (n+m))$。

最后输出 $\sum _ {i =1} ^ n dp_{k,i}$ 即可。

### Code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define Mod (1000000007)
#define q (27)

using namespace std;

ll ned[10005]={1};
ll n, a, m, k, len;
string s;
ll hsh[10005], tmp, dp[105][10005], sum=0;

int main()
{
	cin>>k>>s;
	n=s.size();
	for(ll i=0;i<=n;i++){
		dp[0][i]=1;
	}
	for(ll i=0;i<n;i++){
		hsh[i+1]=(hsh[i]*q+s[i])%Mod;
		ned[i+1]=ned[i]*q%Mod;
	}
	for(ll i=1;i<=k;i++){
		cin>>a;
		for(int null_help=1;null_help<=a;null_help++){
			cin>>s;
			len=s.size(), tmp=0;
			for(ll j=0;j<len;j++){
				tmp=(tmp*q+s[j])%Mod;
			}
			
			for(ll l=0, r=len;r<=n;l++, r++){
				if(((hsh[r]-hsh[l]*ned[len]%Mod)%Mod+Mod)%Mod!=tmp) continue;
				dp[i][r]=(dp[i][r]+dp[i-1][l])%Mod;
			}
		}
	}
	
	for(ll i=1;i<=n;i++){
		sum=(sum+dp[k][i])%Mod;
	}
	
	cout<<sum;
	return 0;
}
```

---

## 作者：Muel_imj (赞：6)

## P4591 [TJOI2018]碱基序列

[P4591](https://www.luogu.com.cn/problem/P4591)

突然就拿了最优解，那就写篇题解罢

---
看题目，方案数-->组合数学或 DP，显然是后者；字符串匹配--> hash 或 KMP， 我用的前者;

组成蛋白质要求每种氨基酸按顺序都要选，并且可以按任意位置匹配，于是设 $f_{i,j}$ 表示到第 i 个氨基酸，匹配到蛋白质的第 j 个位置的方案数，那么有 （ ss 为氨基酸，s 为蛋白质）：

$$f_{i,j}=\sum_{k=1}^{a_i}{f_{i-1,j-len(ss_k)}}[ss_k == s_{j-len(ss_k),j}]$$

由于 DP 到第 i 个氨基酸时的状态只与第 i-1 个有关，可以滚动数组滚掉一维

每到一个字符串就更新 $f_{i,j}$，判断字符串相等的部分就用 hash 解决

需要注意的是，用滚动数组的话，每次到一个新的 i，不能让 i-2 的方案数影响到当前方案数。我是直接 memset 解决，大概也可以先记录下有值的部分，对那些部分清零，不过会很麻烦

---
完整代码qwq
```cpp
#include<bits/stdc++.h>
#define ttT template <typename T>
#define EL puts("Elaina")
#define reg register int
#define qwq 0
using namespace std;
ttT inline void read(T &x){
    x=0;int f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    x*=f;
}
typedef unsigned long long ull;
const int maxn=1e2+3,maxm=1e4+3,mod=1e9+7;
const ull base=27;
ull pw[maxm];
inline void init(){
    pw[0]=1;
    for(reg i=1;i<maxm;++i)
        pw[i]=pw[i-1]*base;
}
int n,len;
ull h[maxm];
char s[maxm],ss[maxm];
inline void getHash(){
	for(reg i=1;i<=len;++i)
        h[i]=h[i-1]*base+s[i];
}
inline ull getHash(char s[]){
    ull ans=0;
	int len=strlen(s);
	for(reg i=0;i<len;++i)
		ans=ans*base+s[i];
	return ans;
}
inline ull zStr(int l,int r){
    return h[r]-h[l-1]*pw[r-l+1];
}
int f[2][maxm],x;
bool p;
void solve(){
	read(n),scanf("%s",s+1);
	len=strlen(s+1),getHash();
	for(reg i=0;i<=len;++i)f[p][i]=1;
	while(n--){
		p^=1,memset(f[p],0,sizeof(f[p]));
		read(x);
		while(x--){
			scanf("%s",ss+1);
			int le=strlen(ss+1);
			ull hsh=getHash(ss+1);
			for(reg i=0;i+le<=len;++i){
				if(!f[p^1][i])continue;
				if(hsh==zStr(i+1,i+le))f[p][i+le]+=f[p^1][i],f[p][i+le]%=mod;
			}
		}
	}
	int ans=0;
	for(reg i=1;i<=len;++i)
		ans+=f[p][i],ans%=mod;
	printf("%d\n",ans);
}
int main(){
	init();
    solve();
    return qwq;
}
```

---

## 作者：asuldb (赞：6)

为什么没人用$SAM$啊

我们先把原来的模式串建一遍$SAM$，之后我们就可以求出$SAM$上每一个节点的$|endpos|$就可以知道每一个子串出现的次数了，也就是在模式串上的匹配数了

之后我们设$dp[i][j]$表示前$i$个里组合出的子串在$SAM$上匹配到了$j$位置的方案数是多少，转移的时候就枚举每一个子串以及$SAM$上的每一个节点之后跑匹配就好了

最后的答案就是

$$\sum_{i=1}^{cnt}dp[m][i]\times sz[i]$$

之后第一维甚至可以直接滚动掉

代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#define maxn 100005
#define re register
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
const int mod=1e9+7;
struct E{int v,nxt;}e[maxn<<1];
int fa[maxn<<1],son[maxn<<1][26],len[maxn<<1],head[maxn<<1],sz[maxn<<1];
char S[maxn];
int dp[2][maxn<<1];
int n,m,num,cnt=1,lst=1,ans,o;
inline void add(int x,int y) {e[++num].v=y;e[num].nxt=head[x];head[x]=num;}
void dfs(int x) {for(re int i=head[x];i;i=e[i].nxt) dfs(e[i].v),sz[x]+=sz[e[i].v];}
inline void ins(int c)
{
	int f=lst,p=++cnt; lst=p;
	len[p]=len[f]+1,sz[p]=1;
	while(f&&!son[f][c]) son[f][c]=p,f=fa[f];
	if(!f) {fa[p]=1;return;}
	int x=son[f][c];
	if(len[f]+1==len[x]) {fa[p]=x;return;}
	int y=++cnt; len[y]=len[f]+1,fa[y]=fa[x],fa[x]=fa[p]=y;
	for(re int i=0;i<26;i++) son[y][i]=son[x][i];
	while(f&&son[f][c]==x) son[f][c]=y,f=fa[f];
}
inline int find(int now) {for(re int i=1;i<=n;i++) {now=son[now][S[i]-'A'];if(!now) break;}return now;}
int main()
{
	scanf("%d",&m);scanf("%s",S+1);n=strlen(S+1);
	for(re int i=1;i<=n;i++) ins(S[i]-'A');
	for(re int i=2;i<=cnt;i++) add(fa[i],i);dfs(1);
	dp[0][1]=1; o=0;
	for(re int i=1;i<=m;i++)
	{
		int T; o^=1; scanf("%d",&T);
		for(re int j=1;j<=cnt;j++) dp[o][j]=0;
		for(re int j=1;j<=T;j++)
		{
			scanf("%s",S+1);n=strlen(S+1);
			for(re int k=1;k<=cnt;k++)
			if(dp[o^1][k]) {int v=find(k);if(v) dp[o][v]=(dp[o][v]+dp[o^1][k])%mod;}
		}
	}
	for(re int i=2;i<=cnt;i++) ans=(ans+(LL)dp[o][i]*(LL)sz[i]%mod)%mod;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：foreverlasting (赞：3)

题解同步发在[博客](https://foreverlasting1202.github.io/)

DP+KMP。

老实点，干嘛hash，老实KMP多好。

这题可以滚掉一位数组。

code:
```
//2018.12.15 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
inline int read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void _swap(res &x,res &y){
    x^=y^=x^=y;
}
inline int _abs(const res &x){
    return x>0?x:-x;
}
inline int _max(const res &x,const res &y){
    return x>y?x:y;
}
inline int _min(const res &x,const res &y){
    return x<y?x:y;
}
const int kcz=1e9+7;
const int N=1e4+10,K=1e2+10;
namespace MAIN{
    int k;
    char str[N],s[N];
    int dp[2][N];
    int nxt[N];
    int n;
    inline void add(res &x,const res &y){
        x+=y;
        x>=kcz?x-=kcz:1;
    }
    inline void MAIN(){
        k=read();
        scanf("%s",str+1);
        n=strlen(str+1);
        for(res i=0;i<=n;i++)dp[0][i]=1;
        res cur=0;
        while(k--){
            memset(dp[cur^1],0,sizeof(dp[cur^1]));
            res p=read();
            while(p--){
                scanf("%s",s+1);
                res len=strlen(s+1);
                nxt[1]=0;
                for(res i=1,j=0;i<len;i++){
                    while(j&&s[i+1]!=s[j+1])j=nxt[j];
                    nxt[i+1]=(s[i+1]==s[j+1]?++j:0);
                }
                for(res i=1,j=0;i<=n;i++){
                    while(j&&str[i]!=s[j+1])j=nxt[j];
                    j+=(str[i]==s[j+1]);
                    if(j==len)add(dp[cur^1][i],dp[cur][i-len]);
                }
            }
            cur^=1;
        }
        res ans=0;
        for(res i=0;i<=n;i++)add(ans,dp[cur][i]);
        printf("%d\n",ans);
    }
}
int main(){
    MAIN::MAIN();
    return 0;
}
```

---

## 作者：elijahqi (赞：2)

题意：给定k种类型 每种类型里有一定数量的串
求给定串中 k种类型按照顺序出现的方案数 只要位置不同或者在这个类型里属于不同的两种串即算不同答案
hash预处理     dp[i][j]表示当前在待匹配串的i位置 我现在属于第j种串的结尾我的总答案是多少
1e7枚举状态转移即可
```
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll unsigned long long
#define lle long long
using namespace std;
const int g1=1000003;
const int g2=100003;
const int N=10010;
const int mod=1000000007;
ll p1[N],p2[N],hs1[N],hs2[N],hst1[110][11],hst2[110][11];
char s[N],s1[N];
int nm[110],len[110][11],k;
lle dp[N][110];
inline bool judge(int l,int r,int kd,int d){
	ll tmp1,tmp2;
	tmp1=hs1[r]-hs1[l]*p1[r-l];tmp2=hs2[r]-hs2[l]*p2[r-l];
	return (tmp1==hst1[kd][d])&&(tmp2==hst2[kd][d]);
}
int main(){
	freopen("str.in","r",stdin);
	freopen("str.out","w",stdout);
	scanf("%d",&k);scanf("%s",s+1);
	int n=strlen(s+1);p1[0]=1;p2[0]=1;
	for (int i=1;i<=n;++i) p1[i]=p1[i-1]*g1,p2[i]=p2[i-1]*g2,
	hs1[i]=hs1[i-1]*g1+s[i],hs2[i]=hs2[i-1]*g2+s[i];
	for (int owo=1;owo<=k;++owo){
		int kd;scanf("%d",&kd);nm[owo]=kd;
		for (int j=1;j<=kd;++j){
			scanf("%s",s1+1);static ll tmp1,tmp2;tmp1=tmp2=0;
			int le=strlen(s1+1);len[owo][j]=le;
			for (int i=1;i<=le;++i){
				tmp1=tmp1*g1+s1[i];
				tmp2=tmp2*g2+s1[i];
			}hst1[owo][j]=tmp1;hst2[owo][j]=tmp2;
		}
	}for (int i=0;i<=n;++i) dp[i][0]=1;
	for (int i=1;i<=n;++i){
		for (int kd=1;kd<=k;++kd){int tmp=0;
			for (int j=1;j<=nm[kd];++j){
				if (i-len[kd][j]<0) continue;
				if (judge(i-len[kd][j],i,kd,j)) tmp+=dp[i-len[kd][j]][kd-1];tmp%=mod;
			}dp[i][kd]=tmp;
		}
	}lle ans=0;
	for (int i=1;i<=n;++i) ans+=dp[i][k],ans%=mod;
	printf("%lld\n",ans);
	return 0;
}
  ```

---

## 作者：_Ch1F4N_ (赞：1)

考虑设计状态 $dp_{i,j}$ 表示匹配到串的第 $i$ 位并考虑了前 $j$ 个氨基酸的方案数。有转移方程：

$$dp_{i,j} = \sum dp_{i - len_{j,k},j-1} \times [a_{j,k} = s[i-len_{j,k}+1,i] ]$$

并且因为从哪个位置开始匹配都可以所有初始状态为 $dp_{i,0} = 1$。

转移过程中判断字符串是否相同的问题交给哈希解决即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define gethash(l,r) (pre[r]-pre[l-1])
#define ull unsigned long long
const int mod = 1e9+7;
const ull base = 1331;
const int maxn = 1e4+114,maxk = 114;
int dp[maxn][maxk];
char s[maxn],t[maxn];
ull pre[maxn];
ull _pow[maxn];
int ch[maxn];
ull a[maxk][maxk];
int Len[maxk][maxk];
int k,len;
signed main(){
	cin>>k;
	scanf("%s",s+1);
	s[0]=' ';
	len=strlen(s)-1;
	_pow[0]=1;
	for(int i=1;i<=len;i++) _pow[i]=_pow[i-1]*base;
	for(int i=1;i<=len;i++) pre[i]=pre[i-1]+s[i]*_pow[i];
	for(int i=1;i<=k;i++){
		cin>>ch[i];
		for(int j=1;j<=ch[i];j++){
			scanf("%s",t+1);	
			t[0]=' ';
			Len[i][j]=strlen(t)-1;
			for(int u=1;u<=Len[i][j];u++) a[i][j]+=_pow[u]*t[u];
		}
	}
	for(int i=0;i<=len;i++) dp[i][0]=1;
	for(int i=1;i<=len;i++){
		for(int j=1;j<=k;j++){
			for(int u=1;u<=ch[j];u++){
				if(i<Len[j][u]) continue;
				if(gethash(i-Len[j][u]+1,i)==a[j][u]*_pow[i-Len[j][u]]){
					dp[i][j]+=dp[i-Len[j][u]][j-1];
					dp[i][j]%=mod;
				}
			}
		}
	}
	int ans=0;
	for(int i=1;i<=len;i++) ans=(ans+dp[i][k])%mod;
	cout<<ans<<'\n';
	return 0;
}
 
```




---

## 作者：LiveZoom (赞：1)

一道字符串&DP好题。

## 题意

给你一个字符串 $s$，还有 $k$ 组字符串，问你从每组字符串中只选一个字符串，且按顺序排列后连接起来的串为 $s$ 的子串的选择种数有多少个，对 $1\text{e}9+7$ 取模。

## 题解

显然是道 DP。

定义 $f_{i,j}$ 表示按顺序选到第 $i$ 组串且连接起来的字符串匹配到 $s$ 的第 $j$ 个位置的种数。

显然不是每个状态都能转移到 $f_{i,j}$。当且仅当第 $i$ 组中的某个字符串被 $s$ 从 $j$ 结尾的最后几个字符匹配才能转移，这样就好办了。

用哈希判断就可以了，也可以用 KMP，但我觉得哈希对于这题来说更简单。

代码：

```cpp
#include <cstdio>
#include <iostream>

using namespace std;

typedef unsigned long long ULL;

const int N = 1e4 + 5;
const int K = 1e2 + 5;
const int MOD = 1e9 + 7;
const int BASE = 13331;

string s, a[K][15];
int k, n, c[K], f[K][N];
ULL hs[N], hsh[K][15], pw[N];

void Prework () {
  pw[0] = 1;
  for (int i = 1; i <= n; ++i)
    pw[i] = pw[i - 1] * BASE;
  hs[0] = s[0];
  for (int i = 1; i < n; ++i)
    hs[i] = hs[i - 1] * BASE + s[i];
//  for (int i = 0; i < n; ++i) cout << i << " " << hs[i] << endl;
}

ULL Gethsh (int l, int r) {
  if (!l) return hs[r];
  return hs[r] - hs[l - 1] * pw[r - l + 1];
}

int main() {
  cin >> k >> s;
  n = s.size();
  for (int i = 1; i <= k; ++i) {
    cin >> c[i];
    for (int j = 1; j <= c[i]; ++j) {
      cin >> a[i][j];
      int len = a[i][j].size();
      for (int s = 0; s < len; ++s)
        hsh[i][j] = hsh[i][j] * BASE + a[i][j][s];
//      if (i == 1) {
//        for (int s = 0; s + len - 1 < n; ++s)
//          f[i][s + len - 1] += 1 * (Gethsh(s, s + len - 1) == hsh[i][j]);
//      }
    }
  }
  Prework();
  for (int i = 0; i < n; ++i)
    f[0][i] = 1;
  for (int i = 1; i <= k; ++i)
    for (int j = 1; j <= c[i]; ++j) {
      int len = a[i][j].size();
//      cout << i << " " << j << " " << len << endl;
      for (int s = len - 1; s < n; ++s) {
        f[i][s + 1] = (f[i][s + 1] + (hsh[i][j] == Gethsh(s - len + 1, s)) * f[i - 1][s - len + 1]) % MOD;
//        cout << "***" << hsh[i][j] << " " << Gethsh(s - len + 1, s) << endl;
//        if (hsh[i][j] == Gethsh(s - len + 1, s)) puts("!!!");
      }
    }
  
  int ans = 0;
  for (int i = 0; i < n; ++i)
    ans = (ans + f[k][i + 1]) % MOD;
  cout << ans << endl;
  return 0;
}
```

---

## 作者：strlen_s_ (赞：0)

考虑要求顺次拼接后在原串中的出现次数，于是想到 SAM。

那么求解这个每次选一个出来拼接就可以想到 dp。那么我们考虑一个这样的状态：设 $dp_{i,j}$ 表示匹配到了第 $i$ 个集合，走到了 SAM 上的第 $j$ 个节点的方案数。每次转移时就枚举上一个串走到了节点 $j$，让后暴力跳字符边，若走不动了则不合法。倘若走到了 $k$，那么就令 $dp_{i,k}=dp_{i,k}+dp_{i-1,j}$。

最后统计答案时就是求：

$$
\sum |endpos|_i \times dp_{k,i}
$$

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+10,mod=1e9+7;
struct tree {
	int ch[26],len,fa;
} t[N<<1];
int lst=1,top=1;
int siz[N<<1];
int clone(int k){t[++top]=t[k];return top;}
void insert(int x){
	int cur=++top,p=lst;lst=cur;
	t[cur].len=t[p].len+1;siz[cur]=1;
	while(!t[p].ch[x]&&p)t[p].ch[x]=cur,p=t[p].fa;
	if(!p){t[cur].fa=1;return;}
	int q=t[p].ch[x];
	if(t[q].len==t[p].len+1){t[cur].fa=q;return;}
	int c=clone(q);t[c].len=t[p].len+1;t[q].fa=t[cur].fa=c;
	while(t[p].ch[x]==q&&p)t[p].ch[x]=c,p=t[p].fa;
}
int h[N<<1],nex[N<<1],to[N<<1],tot;
void add(int x,int y) {to[++tot]=y,nex[tot]=h[x],h[x]=tot;}
void dfs(int u){
  for(int i=h[u];i;i=nex[i]){
    int v=to[i];
    dfs(v);siz[u]+=siz[v];
  }
}
void calc() {
	for(int i=2;i<=top;i++)add(t[i].fa,i);
	dfs(1);
}
int n,m,k,ans;
char c[N],a[17];
int dp[2][N<<1];
void work(int nw,int pre){
  m=strlen(a+1);
  for(int i=1;i<=top;i++){
    if(!dp[pre][i])continue;
    int p=i;
    bool fl=1;
    for(int j=1;j<=m;j++){
      int x=a[j]-'A';
      if(!t[p].ch[x]){fl=0;break;}
      p=t[p].ch[x];
    }
    if(!fl)continue;
    dp[nw][p]=(dp[nw][p]+dp[pre][i])%mod;
  }
}
signed main(){
  ios::sync_with_stdio(0);
  cin.tie(0),cout.tie(0);
  cin>>k>>(c+1);
  n=strlen(c+1);
  for(int i=1;i<=n;i++)insert(c[i]-'A');
  calc();
  dp[0][1]=1;
  int nw=0,pre=1;
  for(int i=1;i<=k;i++){
    swap(nw,pre);
    memset(dp[nw],0,sizeof(dp[nw]));
    int x;
    cin>>x;
    while(x--){
      cin>>(a+1);
      work(nw,pre);
    }
  }
  for(int i=1;i<=top;i++)ans+=1ll*dp[nw][i]*siz[i]%mod,ans%=mod;
  cout<<ans;
  return 0;
}
```

---


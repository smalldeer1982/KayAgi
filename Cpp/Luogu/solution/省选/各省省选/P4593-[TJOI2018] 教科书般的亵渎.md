# [TJOI2018] 教科书般的亵渎

## 题目描述

小豆喜欢玩游戏，现在他在玩一个游戏遇到这样的场面，每个怪的血量为 $a_i$，且每个怪物血量均不相同，小豆手里有无限张“亵渎”。亵渎的效果是对所有的怪造成 $1$ 点伤害，如果有怪死亡，则再次施放该法术。我们认为血量为 $0$ 怪物死亡。

小豆使用一张“亵渎”会获得一定的分数，分数计算如下，在使用一张“亵渎”之后，每一个被亵渎造成伤害的怪会产生 $x^k$，其中 $x$ 是造成伤害前怪的血量为 $x$ 和需要杀死所有怪物所需的“亵渎”的张数 $k$。

## 说明/提示

- 对于 $10\%$ 的数据，有 $m=0$；
- 对于 $20\%$ 的数据，有 $m\leq1$；
- 对于 $30\%$ 的数据，有 $m\leq2$
- 对于 $40\%$ 的数据，有 $m\leq3$；
- 对于 $50\%$ 的数据，有 $m\leq4$；
- 对于 $60\%$ 的数据，有 $m\leq5$；
- 对于 $100\%$ 的数据，有 $m\leq50$，$n\leq10^{13}$，$1 \le a_i <n$。

## 样例 #1

### 输入

```
2
10 1
5
4 2
1
2```

### 输出

```
415
135```

# 题解

## 作者：ycyaw (赞：18)

先算出所需亵渎个数$k$，观察就可以发现$k=m+1$，有一个小细节，如果从$n$开始有一段连续的空位，应该把它去掉，因为不会需要多余的亵渎。

我们计算每一次亵渎的贡献，第一次亵渎我们认为是在$0$位置。显然第一次的贡献是$\sum\limits_{i=1}^{n}i^k$ $-$ 空位的贡献。

之后我们考虑在一个空位上使用亵渎，设空位为$p$，那么有贡献的区间为$p+1 \sim n$。贡献为$\sum\limits_{i=1}^{n-p}i^k$。

最后我们减去空位多算的贡献即可。

考虑计算$\sum\limits_{i=1}^{n}i^k$，可利用拉格朗日插值，参考[这里](https://www.luogu.org/problem/CF622F)

$Code\ Below:$
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define int long long
#define hh puts("")
#define mo 1000000007
using namespace std;
int n,m,a[55],k,f[55],pre[55],suf[55],fac[55],ans;
map<int,int> ma;
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=(ret<<3)+(ret<<1)+ch-'0';ch=getchar();}
    return ret*ff;
}
void write(int x){
    if(x>9) write(x/10);
    putchar(x%10+48);
}
inline int ksm(int x,int y){
    int res=1;
    while(y){
        if(y&1) res=res*x%mo;
        y>>=1;
        x=x*x%mo;
    }
    return res;
}
inline int calc(int p){
    if(p<=k+2) return f[p];
    int res=0;
    pre[0]=1;
    for(int i=1;i<=k+2;i++) pre[i]=pre[i-1]*(p-i)%mo;
    suf[k+3]=1;
    for(int i=k+2;i>=1;i--) suf[i]=suf[i+1]*(p-i)%mo;
    for(int i=1;i<=k+2;i++){
        int x=pre[i-1]*suf[i+1]%mo;
        int fu=((k+2-i)&1)?-1:1;
        int y=fac[i-1]*fac[k+2-i]*fu%mo;
        res=(res+f[i]*x%mo*ksm(y,mo-2)%mo)%mo;
    }
    return (res+mo)%mo;
}
signed main(){
    fac[0]=1;
    for(int i=1;i<=52;i++) fac[i]=fac[i-1]*i%mo;
    int T=read();
    while(T--){
        n=read(),m=read();
        k=m+1;
        ma.clear();
        for(int i=1;i<=m;i++) a[i]=read(),ma[a[i]]=1;
        sort(a+1,a+m+1);
        while(ma[n]) n--,k--,m--;
        for(int i=1;i<=k+2;i++) f[i]=(f[i-1]+ksm(i,k))%mo;
        ans=calc(n);
        for(int i=1;i<=m;i++) ans=(ans-ksm(a[i],k))%mo;
        for(int i=1;i<=m;i++) ans=(ans+calc(n-a[i]))%mo;
        for(int i=1;i<=m;i++)
            for(int j=i-1;j>=1;j--)
                ans=(ans-ksm(a[i]-a[j],k))%mo;
        write((ans+mo)%mo),hh;
    }
    return 0;
}
```


---

## 作者：Constant (赞：11)

总的来说，这是一道结论题。

接下来我将会采取子任务讲解的形式来分析这道题目。

$Subtask$ $1$ $m = 0$

此时只需要一张亵渎，所有随从都会死亡。

所以答案是 $\sum_{i=1}^ni$ ，这个式子用等差数列求和一下就可以了，大家应该都会的。

$Subtask$ $2$ $m = 1$

此时需要两张亵渎才能消灭所有随从，考虑第一次亵渎所贡献的分数。

即为 $\sum_{i=1}^ni^2-a_1^2$

同样地，再次考虑第二次亵渎所贡献的分数。

此时所有的数已经被减掉了 $a_1$ ，且体力值小于 $a_1$ 的随从已全部被消灭。

故此时答案为 $\sum_{i=1}^{n-a_1} i^2$ 

$Subtask$ $3$ $n=10^{13}$ , $m = 50$

这是本次的重头戏，但其实有了之前的想法作铺垫，还是比较好理解的。

我们先思考，每次算得分时都要计算伤害的 $K$ 次方，而这个值是未知的。

但是显然 $K$ 是需要我们先算出来的。

当一个随从都没有被删除的时候，我们很轻松地使用了一张亵渎就结束了，但是删除了一个随从，我们就用了两张，顺着这个思路，我们可以得出一些结论。

删除一个随从就会把原本连续的数列分隔成两段，而删除随从后造成需要再次使用的根本原因就是分隔之后，本应该杀死的随从是不存在的，就不能再次使用法术了，所以一次不行，就再来一次。

所以，有 $m$ 个随从被删除，需要的卡牌数量就是 $m+1$ 了。

接下来，我们思考怎么计算卡牌的贡献。

按照之前的思路，我们卡牌的贡献可以用总体贡献（也就是对不删除任何随从的贡献）减去多算的贡献（被删除随从的贡献）。

以每张卡牌为序，于是就有以下式子。

$ans=\sum_{i=0}^m(\sum_{j=1}^{n-a[i]}j^{m+1}- \sum_{j=i+1}^m{(a[j]-a[i]})^{m+1})$

特别地， $a[0]=0$ 。

如果你理解了之前的两种思路，那这个式子理解起来其实是不难的。

暴力计算这个式子的值是 $O(nmlogn)$ 。

过不了，完全过不了。

分析发现，时间复杂度的瓶颈在于求 $j^{m+1}$ 的求和部分，而现在的问题就转化为，如何快速地求出 $\sum_{i=1}^ni^k$ 。

这个问题也就是经典的自然数幂和问题，有多种经典方式可以求出，例如伯努利数，斯特林数，拉格朗日插值等。

不过这些我都不会，我选择最简单易懂的算法，递推法。

这个的递推式基于一种“算两次”的思想，考虑计算这样一个式子。

$(i+1)^{k+1}-i^{k+1}=C_{k+1}^{1}i^k+C_{k+1}^{2}i^{k-1}+...+C_{k+1}^{k}i+1$ 

这个式子怎么来的呢，其实就是用二项式定理把左边的 $(i+1)^{k+1}$ 项展开，把 $i^k$ 合并即可。

对左边 $1-n$ 求和，对右边 $1-n$ 求和。

就可以得出递推式子了，用这种递推的方式算，复杂度是 $O(K^2)$ 的，但拉格朗日插值可以做到 $O(K)$ 计算，反正我不会。

这里的递推过程我用的是递归计算，这就导致每次计算时会遇到很多重复的状态，在顺序结构的循环计算中，我们是用数组保存下了那些值的，计算时可以直接用，但我之前递归时忘了保存，这就导致了复杂度的退化，退化成什么程度我也不是很清楚，用一个数组dp[k]保存状态，记忆化搜索，快了不少。

时间复杂度是 $O(m^3+m^2logm)$ 的，跑得飞快，比某些拉格朗日插值做法还要快。








---

## 作者：Zskioaert1106 (赞：5)

题目传送门：[P4593 [TJOI2018] 教科书般的亵渎](https://www.luogu.com.cn/problem/P4593)

### 前置知识：求自然数幂和

定义 $S_k(n)=\sum\limits_{i=1}^n i^k =1^k+2^k+\cdots +n^k$，则可以用伯努利数或者拉格朗日插值法求出公式。此处我们用一种更初等的递推方法，只需要知道二项式定理即可，其复杂度为 $O(k^2)$。

注意到 $S_k(n)$ 总是一个关于 $n$ 的 $k+1$ 次多项式，我们想找到 $S_k(n)$ 和 $S_{k-1}(n)$ 之间的关系，可以利用**二项式定理**构造一个递推公式。

> 二项式定理：$(x+y)^n=\sum\limits_{j=0}^{n} \binom{n}{j}x^{n-j}y^{j}$。

考虑：

$$
(i+1)^{k+1}-i^{k+1}=\sum\limits_{j=0}^{k} \binom{k+1}{j}i^j
$$

对 $i$ 将 $1 \sim n$ 求和：

$$
\begin{aligned}
\sum_{i=1}^n \left[ (i+1)^{k+1}-i^{k+1} \right]=&\sum\limits_{j=0}^{k}\binom{k+1}{j}\sum\limits_{i=1}^{n}i^j\\
\\
(n+1)^{k+1} - 1 =& \sum_{j=0}^k \binom{k+1}{j} S_j(n)\\
\\
(n+1)^{k+1} - 1 =&\binom{k+1}{k}S_k(n)+\sum_{j=0}^{k-1} \binom{k+1}{j} S_j(n)\\
\\
S_k(n)=&\dfrac{(n+1)^{k+1}-1-\sum_{j=0}^{k-1} \binom{k+1}{j} S_j(n)}{\binom{k+1}{k}}\\
\\
=&\dfrac{(n+1)^{k+1}-1-\sum_{j=0}^{k-1} \binom{k+1}{j} S_j(n)}{k+1}\\
\end{aligned}
$$

从而我们得到了求 $S_k(n)$ 的方法，时间复杂度为 $O(k^2)$（在预处理组合数的情况下）。

### 做题过程

（此处默认 $a$ 数组升序排序）

最初的局面分为 $m+1$ 块（可以是空的），分别是 $1\sim a_1-1,a_1+1\sim a_2-1,\dots ,a_m+1\sim n$。

打出第一张“亵渎”时可以让第一个怪物死亡，从而触发第二次“亵渎”——第二个怪物的血量降为 $1$ 点了。以此类推，知道打出“亵渎”前血量为 $a_1-1$ 的怪物死亡后又触发了一轮，此时原先血量为 $a_1+1$ 的怪物血量降为 $1$，但是由于没有原血量为 $a_1$ 的怪物，因而没有怪物死亡，所以需要再打出一张“亵渎”。

所以得出结论：每个块需要一张“亵渎”来消灭，更严谨地，每少一种血量的怪物，就要多用一张“亵渎”。所以可以轻松得出 $k=m+1$。

我们对于一个一般化的场面模拟一下运行过程：



|$1\sim a_1-1$|$a_1+1\sim a_2-1$|$a_2+1\sim a_3-1$|$\dots$|$a_m+1\sim n$|
|:-:|:-:|:-:|:-:|:-:|
|$——$|$1\sim a_2-a_1-1$|$a_2-a_1+1\sim a_3-a_1+1$|$\dots$|$a_m-a_1-1\sim n-a_1$|
|$——$|$——$|$1\sim a_3-a_2-1$|$\dots$|$a_m-a_2+1\sim n-a_2$|
||||$\dots$||
|$——$|$——$|$——$|$\dots$|$1\sim n-a_m$|

将每行统计一下和得到：



|$S_k(n)-\sum\limits_{i=1}^{m} {a_i}^k$|
|:-:|
|$S_k(n-a_1)-\sum\limits_{i=2}^{m} {(a_i-a_1)}^k$|
|$S_k(n-a_2)-\sum\limits_{i=3}^{m} {(a_i-a_1)}^k$|
|$\dots$|
|$S_k(n-a_m)$|

设 $a_0=0$，则上所有式相加得 $\sum\limits_{i=0}^{m}[S_k(n-a_i)-\sum\limits_{j=i+1}^{m}(a_j-a_i)^k]$。这就是我们要求的最终答案了。

且别忘了一个特判：如果连续至 $n$ 的一段怪物都没有，一定要将 $n$ 和 $m$ 减去相应的数量。

### 代码实现

需掌握知识：快速幂、质模数乘法逆元、杨辉三角求组合数。

首先预处理出 $1 \sim k+1$ 的组合数和逆元：

```cpp
for(int i=0;i<=52;i++){//杨辉三角求组合数
    for(int j=0;j<=i;j++){
        if(!j||j==i)c[i][j]=1;
        else c[i][j]=(c[i-1][j-1]+c[i-1][j])%p;
    }
}
for(int i=1;i<=52;i++)//费马小定理求逆元
    ny[i]=power(i,p-2);
```

然后写出 $S_k(n)$ 的递推公式。

```cpp
void solve(long long n,int m){
    s[0]=n%p;//边界
    for(int k=1;k<=m;k++){
        s[k]=power(n+1,k+1)-1;
        for(int i=0;i<k;i++){
            s[k]=(s[k]-c[k+1][i]*s[i]%p+p)%p;//及时取模
        }
        (s[k]*=ny[k+1])%=p;//乘 k+1 的逆元
    }
}
```

- 此函数的传参 $m$ 代表用到的最大 $k$。

然后就是主函数了，按照之前推的式子一步步来。先将 $a$ 数组排序，然后循环求答案：

```cpp
sort(a+1,a+1+m);
long long ans=0;
for(int i=0;i<=m;i++){
    solve(n-a[i],m+1);
    (ans+=s[m+1])%=p;
    for(int j=i+1;j<=m;j++){
        ans=(ans-power(a[j]-a[i],m+1)+p)%p;
    }
}
```

记得处理特殊情况：

```cpp
while(a[m]==n){
    n=a[m]-1;
    m--;
}
```

### 最终代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const long long p=1e9+7;
long long power(long long a,int k){
    a%=p;
    long long s=1;
    while(k){
        if(k&1)s=s*a%p;
        a=a*a%p;
        k>>=1;
    }
    return s;
}
long long c[53][53],s[52],ny[53];
void m_c(){
    for(int i=0;i<=52;i++){
        for(int j=0;j<=i;j++){
            if(!j||j==i)c[i][j]=1;
            else c[i][j]=(c[i-1][j-1]+c[i-1][j])%p;
        }
    }
    for(int i=1;i<=52;i++)
        ny[i]=power(i,p-2);
}
void solve(long long n,int m){
    s[0]=n%p;
    for(int k=1;k<=m;k++){
        s[k]=power(n+1,k+1)-1;
        for(int i=0;i<k;i++)
            s[k]=(s[k]-c[k+1][i]*s[i]%p+p)%p;
        (s[k]*=ny[k+1])%=p;
    }
}
int T,m;
long long n,a[51];
int main(){
    m_c();
    cin>>T;
    while(T--){
        cin>>n>>m;
        for(int i=1;i<=m;i++)cin>>a[i];
        sort(a+1,a+1+m);
        while(a[m]==n){
            n=a[m]-1;
            m--;
        }
        long long ans=0;
        for(int i=0;i<=m;i++){
            solve(n-a[i],m+1);
            (ans+=s[m+1])%=p;
            for(int j=i+1;j<=m;j++)
                ans=(ans-power(a[j]-a[i],m+1)+p)%p;
        }
        cout<<ans<<'\n';
    }
    return 0;
}
```

时间复杂度 $O(Tk^3)$，[AC 记录](https://www.luogu.com.cn/record/212821647)。

---

## 作者：Super_Cube (赞：4)

# Solution

$k=m+1$ 是能直接看出来的。

先给 $a$ 从小到大排序，并令 $a_0=0$。

$$\sum_{i=0}^m \sum_{j=1}^{n-a_i}j^{m+1}-\sum_{j=i+1}^m(a_j-a_i)^{m+1}$$

对于每次亵渎会删掉一整个连续段，后面的所有数都会做出贡献，而不存在的部分需要减去。

那一大坨自然数幂和直接套用 [CF622F](https://www.luogu.com.cn/problem/solution/CF622F)。

时间复杂度 $O(Tm^2)$。

---

## 作者：AbsMatt (赞：4)

### [题目传送器](https://www.luogu.com.cn/problem/P4593)

### [更爽的阅读体验](https://yaohaoyou.github.io/post/p4593-solution/)

## 前言

太笨了，不会拆贡献，所以复杂度比较劣。

## 题意

给定操作 A 和操作 B。

定义**操作 A **是将 $x_i \gets x_i-1(x_i>0)$ 并获得 $\sum x_i^k$ 分数，$x_i$ 是第 $i$ 个怪物扣血前的血量，$k$ 是**总操作 B **次数。如果一次操作后会有新的 $x_i=0$，则继续进行**操作 A**。

定义**操作 B** 是当此时没有新的 $x_i=0$，进行一次**操作 A**。

给定集合 $S=\{x\in[1,n] \wedge x \notin a \}$ 表示怪物血量所构成的集合，求最后的总分数。

## 做法

$k$ 是好算的。

将 $S$ 拆成一段段连续的区间分别考虑，一段连续的区间必定是在同一次操作 B 中扣为 $0$。

设当前处理的血量区间为 $[l_i,r_i]$，对于 $j\ge i$ 的区间**当前**血量为 $[l_j,r_j]$，则当前的贡献 $\sum_{j=i}^{m+1}\sum_{x=l_j}^{r_j}\sum_{y=x-l_i+1}^{x} y^k$。

直接计算是 $O(Tm^2n^2)$，[这里放一份代码](https://www.luogu.com.cn/record/173524637)。

思考如何优化计算 $\sum_{x=l_j}^{r_j}\sum_{y=x-l_i+1}^{x} y^k$，设 $f(x)=\sum_{i=1}^x i^x,g(x,len)=\sum_{i=1}^x(f(i)-f(i-len))$，则 $ans=\sum_{i=1}^{m+1}\sum_{j=i}^{m+1}g(r_j,l_i)-g(l_j-1,l_i)$。

可以先使用一次拉格朗日插值 $O(m)$ 算出 $f(x)$，进而再使用一次拉格朗日插值 $O(m^2)$ 算出 $g(x)$。

总时间复杂度为 $O(T\times m^4)$，需要轻微卡常。

[AC Code](https://loj.ac/s/2138254)

---

## 作者：Leasier (赞：3)

前置芝士：[拉格朗日插值](https://oi-wiki.org/math/poly/lagrange/)

考虑 $a_i$ 将血量存在的怪物分成了至多 $m + 1$ 个连续段，我们现在不考虑空区间带来的影响，将这 $m + 1$ 个区间记为 $[l_1, r_1], [l_2, r_2], \cdots, [l_{m + 1}, r_{m + 1}]$，其中 $l_i = a_{i - 1} + 1$，$r_i = a_i - 1$。我们钦定 $a_{m + 1} = n + 1$。

由题目中给定的规则可知：施用亵渎一定是依次消除每个连续段，并对后面的连续段造成影响。即：当我们将要消除原来的 $[l_i, r_i]$ 时，对于任意 $j \geq i$，原来的 $[l_j, r_j]$ 会变成 $[l_j - l_i + 1, r_j - l_i + 1]$。设 $S_k(n) = \displaystyle\sum_{i = 1}^n i^k$，则对于任意 $1 \leq i \leq j \leq m$，其贡献为 $S_k(r_j - l_i + 1) - S_k(l_j - l_i)$。

最后来考虑 $k$ 的值。由于连续段一定是直接消除，我们所要施用亵渎的时候一定是消除完一个连通块后想要跨越两个连通块间的空隙，则施用亵渎的次数为 $k = \displaystyle\sum_{i = 1}^{m + 1} (l_i - r_{i - 1} - 1) = m + 1$。这里我们钦定 $r_0 = -1$。

直接用拉格朗日插值计算自然数幂和即可。时间复杂度为 $O(Tm^3)$。

代码：
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long ll;

const int mod = 1e9 + 7;
ll fac[57], inv_fac[57], b[57], y[57], a[57], l[57], r[57], pre[57], suf[57];

inline ll quick_pow(ll x, ll p, ll mod){
	ll ans = 1;
	while (p){
		if (p & 1) ans = ans * x % mod;
		x = x * x % mod;
		p >>= 1;
	}
	return ans;
}

inline void init(int n){
	fac[0] = 1;
	for (register int i = 1; i <= n; i++){
		fac[i] = fac[i - 1] * i % mod;
	}
	inv_fac[n] = quick_pow(fac[n], mod - 2, mod);
	for (register int i = n - 1; i >= 0; i--){
		inv_fac[i] = inv_fac[i + 1] * (i + 1) % mod;
	}
	for (register int i = 0; i <= n; i++){
		b[i] = inv_fac[i] * inv_fac[n - i] % mod;
		if ((n - i) % 2 != 0) b[i] = (mod - b[i]) % mod;
	}
}

inline ll lagrange(int n, ll y[], ll k){
	ll ans = 0;
	k %= mod;
	for (register int i = 0; i <= n; i++){
		pre[i] = suf[i] = ((k - i) % mod + mod) % mod;
		if (i > 0) pre[i] = pre[i] * pre[i - 1] % mod;
	}
	for (register int i = n - 1; i >= 0; i--){
		suf[i] = suf[i] * suf[i + 1] % mod;
	}
	for (register int i = 0; i <= n; i++){
		ll a = 1;
		if (i > 0) a = pre[i - 1];
		if (i < n) a = a * suf[i + 1] % mod;
		ans = (ans + y[i] * a % mod * b[i] % mod) % mod;
	}
	return ans;
}

int main(){
	int t;
	cin >> t;
	for (register int i = 1; i <= t; i++){
		int m, k, ki, cnt = 0;
		ll n, ans = 0;
		cin >> n >> m;
		k = m + 1;
		ki = k + 1;
		init(ki);
		for (register int j = 1; j <= m; j++){
			cin >> a[j];
		}
		sort(a + 1, a + m + 1);
		for (register int j = 1; j <= m; j++){
			cnt++;
			l[cnt] = a[j - 1] + 1;
			r[cnt] = a[j] - 1;
		}
		cnt++;
		l[cnt] = a[m] + 1;
		r[cnt] = n;
		for (register int i = 0; i <= ki; i++){
			y[i] = quick_pow(i, k, mod);
			if (i > 0) y[i] = (y[i] + y[i - 1]) % mod;
		}
		for (register int j = 1; j <= cnt; j++){
			for (register int x = j; x <= cnt; x++){
				ans = ((ans + lagrange(ki, y, r[x] - l[j] + 1) - lagrange(ki, y, l[x] - l[j])) % mod + mod) % mod;
			}
		}
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：star_magic_young (赞：3)

~~这题怎么没人用矩乘啊~~

首先可以发现,这题的 $k$ ,也就是亵渎使用次数为 $m+1$ ，然后给出的 $a_i$ 又会把 $[1,n]$ 划分成至多 $m+1$ 个连续段。所以对每次亵渎，一个段 $[l,r]$ 给答案加上 $\sum_{i=l}^r i^k$ ，并且所有连续段整体 $-1$ ；此外如果某次亵渎后左端点最小的段的左端点为 $0$ ，记它的右端点为 $r_1$ ，那么会删掉这个段，并且其他段整体 $-r_1$。

那么我们模拟上述过程，然后每次对段操作前统计 $\sum_{i=l}^r i^k$ 即可。考虑矩乘求这个东西，先把他拆成 $\sum_{i=1}^r i^k-\sum_{i=1}^{l-1} i^k$ ，然后我们构造行向量 $\vec{a}=\{x^0,x^1,x^2...x^{m+1},s\}$ ，即维护当前 $i$ 的 $0$ 到 $m+1$ 次幂和答案，构造转移矩阵 $M$ 就考虑 $(i+1)^k=\sum_{j=0}^{k}\binom{k}{j}i^j$ ，所以可以得到

- $\forall 0\le i,j\le m+1,M_{i,j}=\binom{j}{i}$
- $M_{m+2,m+2}=1$
- $\forall 0\le i\le m+1,M_{i,m+2}=\binom{m+1}{i}$

$\vec{a}M^{n}$ 的第 $m+2$ 项就是 $\sum i^k$ 。不过注意到要做 $m^2$ 次这样的求值，所以复杂度为 $O(Tm^5logn)$。

现在考虑倒着模拟亵渎的过程，可以发现相当于是要维护一个行向量集合，每次操作先给所有行向量乘上 $M$ ，然后加入一个初始行向量 $\{1,0,0...\}$ ，再给所有行向量乘 $M^b$ (其中 $b$ 这次亵渎删掉的段的右端点值)接着加入一个行向量 $\{-1,0,0...\}$，最后把所有行向量的第 $m+2$ 项加入答案。由于矩阵乘法具有分配律，所以可以直接维护所有行向量的和，然后进行一些矩阵加法和乘法即可做到 $O(Tm^4logn)$ 。注意到我们矩乘做的是行向量乘矩阵，所以单次矩乘可以 $O(m^2)$ ，然后我们再把转移矩阵的 $2^k$ 次幂预处理出来，就可以做到 $O(Tm^3logn)$。

大 力 出 奇 迹

```cpp
#include<bits/stdc++.h>
#define LL long long

using namespace std;
const int N=53,mod=1e9+7;
const LL inf=8e18;
LL rd()
{
    LL x=0,w=1;char ch=0;
    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}
    return x*w;	
}
LL n,b[N],hp[N][2];
int m=51,t,p;
struct matrix
{
    int a[N][N];
    matrix(){memset(a,0,sizeof(a));}
    void clr(){memset(a,0,sizeof(a));}
    matrix operator + (const matrix &bb) const
    {
    	matrix an;
    	for(int i=0;i<=m+1;++i)
    	    for(int j=0;j<=m+1;++j)
    		an.a[i][j]=(a[i][j]+bb.a[i][j])%mod;
    	return an;
    }
    matrix operator * (const matrix &bb) const
    {
    	matrix an;
    	for(int i=0;i<=m+1;++i)
    	    for(int j=0;j<=m+1;++j)
    	    {
        		LL nw=0;
        		for(int k=0;k<=m+1;++k)
        		{
        		    nw+=1ll*a[i][k]*bb.a[k][j];
        		    if(nw>inf) nw%=mod;
        		}
        		an.a[i][j]=nw%mod;
    	    }
    	return an;
    }
    matrix operator & (const matrix &bb) const
    {
    	matrix an;
    	for(int j=0;j<=m+1;++j)
    	{
    	    LL nw=0;
    	    for(int k=0;k<=m+1;++k)
    	    {
        		nw+=1ll*a[0][k]*bb.a[k][j];
        		if(nw>inf) nw%=mod;
    	    }
    	    an.a[0][j]=nw%mod;
    	}
    	return an;
    }
}aa,m1,bb[N][N];
int c[N][N];
void inii(int h)
{
    for(int i=0;i<=h;++i)
	for(int j=0;j<=h;++j)
	    bb[h][0].a[j][i]=c[i][j];
    bb[h][0].a[h+1][h+1]=1;
    for(int j=0;j<=h;++j)
	bb[h][0].a[j][h+1]=c[h][j];
    for(int i=1;i<N;++i) bb[h][i]=bb[h][i-1]*bb[h][i-1];
}

int main()
{
    for(int i=0;i<N;++i)
    {
    	c[i][0]=1;
    	for(int j=1;j<=i;++j) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
    }
    aa.a[0][0]=1;
    int T=rd();
    while(T--)
    {
    	n=rd(),m=rd();
    	b[0]=0;
    	for(int i=1;i<=m;++i) b[i]=rd();
    	sort(b+1,b+m+1),m=unique(b+1,b+m+1)-b;
    	while(m>1&&b[m-1]==n) --m,--n;
    	if(!bb[m][0].a[0][0]) inii(m);
    	b[m]=n+1,t=0;
    	for(int i=1;i<=m;++i)
    	{
    	    if(b[i]==b[i-1]+1) continue;
    	    hp[++t][0]=b[i-1]+1,hp[t][1]=b[i]-b[i-1]-1;
    	}
    	p=0;
    	while(t)
    	{
    	    b[++p]=0;
    	    for(int i=1;i<=t;++i) --hp[i][0];
    	    if(!hp[1][0])
    	    {
        		b[p]=hp[1][1];
        		for(int i=2;i<=t;++i) hp[i][0]-=hp[1][1];
        		for(int i=2;i<=t;++i) hp[i-1][0]=hp[i][0],hp[i-1][1]=hp[i][1];
        		--t;
    	    }
    	}
    	m1.clr();
    	int ans=0;
    	while(p)
    	{
    	    m1=m1*bb[m][0];
    	    if(b[p])
    	    {
        		m1.a[0][0]=(m1.a[0][0]+1)%mod;
        		for(int i=0;b[p];++i,b[p]>>=1)
        		    if(b[p]&1) m1=m1&bb[m][i];
        		m1.a[0][0]=(m1.a[0][0]-1+mod)%mod;
    	    }
    	    ans=(ans+m1.a[0][m+1])%mod;
    	    --p;
    	}
    	printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：asuldb (赞：3)

[题目](https://www.luogu.org/problemnew/show/P4593)

怎么没人用$O(klogn)$的插值啊

首先

$$\sum_{i=1}^ni^{m+1}$$

是一个以$n$为自变量的$m+2$次多项式，我们需要$m+3$个点才能确定这个多项式

拿出拉格朗日插值的柿子

$$f(x)=\sum_{i=1}^{m+3}y_i\prod_{i\ne j}\frac{x-x_j}{x_i-x_j}$$

我们发现如果我们下面带的点是连续的自然数的话，分母上就是两组阶乘相乘，不过套论一下奇偶性来确定符号

分子上我们直接处理好$\prod x-x_j$，我们每次乘上$x-x_i$的逆元就好了

之后如果$n<=m+3$我们直接暴力

代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define LL long long
#define re register
#define maxn
const LL mod=1e9+7;
inline LL read() {
	LL x=0;char c=getchar();while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
int T;
LL n,m,fac[55],a[55];
inline LL quick(LL a,LL b) {LL S=1;while(b) {if(b&1ll) S=S*a%mod;b>>=1ll;a=a*a%mod;}return S;}
inline LL calc(LL n,int m) {
	if(n<=m+2) {
		LL ans=0;
		for(re int i=1;i<=n;i++) ans=(ans+quick(i,m)%mod)%mod;
		return ans;
	}
	LL ans=1,now=0,tot=0;
	for(re int i=1;i<=m+2;i++) 
		ans=(ans*(n-i+mod)%mod)%mod;
	for(re int i=1;i<=m+2;i++) {
		now=now+quick(i,m);now%=mod;
		LL t=ans*quick((n-i+mod)%mod,mod-2)%mod,q=quick(fac[m+2-i]*fac[i-1]%mod,mod-2);
		if((m+2-i)&1) tot-=now*t%mod*q%mod;
			else tot+=now*t%mod*q%mod;
		tot+=mod;tot%=mod;
	}
	return tot;
}
int main() {
	T=read();fac[0]=1;
	for(re int i=1;i<=54;i++) fac[i]=(fac[i-1]*(LL)i)%mod;
	while(T--) {
		n=read(),m=read();
		for(re int i=1;i<=m;i++) a[i]=read();
		std::sort(a+1,a+m+1);
		LL ans=0;
		for(re int i=0;i<=m;i++) {
			ans+=calc(n-a[i],m+1);ans%=mod;
			for(re int j=i+1;j<=m;j++)
				ans=(ans-quick(a[j]-a[i],m+1)%mod+mod)%mod;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：wizard（偷开O2 (赞：0)

一道拉格朗日差值的好题。

### 题意

对于一个数列 $a$，每一次亵渎可以使所有不为 $0$ 的数字减 $1$，如果在一次亵渎之后，有数字变为了 $0$ 则再发动一次亵渎，每一个被亵渎的数字都会造成一定效益，具体的，当杀死所有数字的亵渎次数为 $k$，且亵渎前当前数字为 $x$ 时，会产生 $x^{k}$ 的效益。求最后获得的效益。

### 分析

为了得到每个数产生的效益，因为 $k$ 不变，所以推出 $k$ 就成了主要任务。

已知当前数列中最大数为 $n$，且 $m$ 个数没有出现过。

我们考虑这样一件事情，如果当前数列段是连续的，会被一次亵渎直接消掉，如果说两个数列段之间有空隙，即空隙为 $m$ 个没有出现的数，所以为了跨越这个空隙，找到下一个数列段，我们需要的 $k$ 就是 $m+1$。

所以回归本质，因为数列是连续消除的，且数列元素都 $\le n$，问题就转化为 $\sum\limits_{i=1}^{n}i^{m+1}$。

通过[这道题](https://www.luogu.com.cn/problem/CF622F)可以得出 $\sum\limits_{i=1}^{n}i^{k}$ 是一个 $k+1$ 次多项式，所以当前式子就是一个 $m+2$ 次多项式，所以需要找出 $m+3$ 个数字进行差值。

本质就求这个：

$$\sum_{i=1}^{m+3}y_i \prod_{j \ne i} \frac{x-x_j}{x_i-x_j}$$

很简单，处理一下前缀积和后缀积，主函数映射一下数列就行。

### 代码

给一下主要代码吧。

```cpp
int check(int n){
	pl[0]=pr[k+3]=1;
	for(int i=1;i<=k+2;i++){
		pl[i]=pl[i-1]*(n-i)%modd;
	}
	for(int i=k+2;i>=1;i--){
		pr[i]=pr[i+1]*(n-i)%modd;
	}
	int ans=0;
	for(int i=1;i<=k+2;i++){
		int s1=pl[i-1]*pr[i+1]%modd;
		int s2=0;
		if((k-i)&1){
			s2=f[i-1]*-1*f[k+2-i]%modd;
		}else{
			s2=f[i-1]*1*f[k+2-i]%modd;
		}
		ans=(ans+fx[i]*s1%modd*ksm(s2,modd-2)%modd)%modd;
	}
	return (ans+modd)%modd;
}
```

---


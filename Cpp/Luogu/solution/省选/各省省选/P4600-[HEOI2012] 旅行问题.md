# [HEOI2012] 旅行问题

## 题目描述

yz 是 Z 国的领导人，他规定每个地区的名字只能为 $26$ 个小写拉丁字母的一个。由于地区数有可能超过 $26$ 个，便产生了一个问题，如何辨别名字相同的地区？于是 yz 规定，一个地区的描述必须包含它的所有上级，且上级按次序排列。于是，一个地区的描述是一个字符串。比如说，一个地区的名字为 $\tt c$，它的上级为 $\tt b$，$\tt b$ 的上级为 $\tt a$，$\tt a$ 没有上级，那么这个地区就描述为 $\tt abc$。显然，这个描述同时包含了 $\tt c$ 的上级 $\tt b$ 和 $\tt b$ 的上级 $\tt a$ 的描述，分别为 $\tt ab$ 和 $\tt a$。

值得注意的是，每个地区最多有一个上级，同一上级的地区之间名字不同，没有上级的地区之间名字不同。

现在，yz 对外公布了 $n$ 个地区的描述，这些描述中包含了 Z 国所有地区的描述，并让你处理来访者的旅行问题。

现有 $m$ 对人访问这个国家，对于每对人，第一个人喜欢第 $i$ 个描述中的第 $j$ 个地区，设这个地区描述为 $s_1$，第二个人喜欢第 $k$ 个描述中的第 $l$ 个地区，设这个地区描述为 $s_2$。他们为了统一行程，决定访问描述为 $s$ 的地区（显然他们只关心地区的名字，并非是地区本身），设 $s$ 的长度为 $t$，$s$ 需要满足以下条件：

1. $t\leq j$，$t\leq l$。
2. $s[1\cdots t]=s_1[j-t+1\cdots j]$，$s[1\cdots t]=s_2[l-t+1\cdots l]$，即 $s$ 为 $s_1$ 中 $1$ 到 $j$ 位与 $s_2$ 中 $1$ 到 $l$ 位的公共后缀。
2. $t$ 最大化。

为了不使输出过大，你只需把这个字符串按照如下生成的 $26$ 进制数转成 $10$ 进制后 $\bmod\ (10^9+7)$ 后输出：

- $a \to 0$；
- $b \to 1$；
- ……
- $z \to 25$。

比如地区 $\tt cab$ 被编码成 $2\times26^2+0\times26^1+1\times26^0=1353$。

## 说明/提示

### 样例解释

询问 $1$ 中的公共后有 $\tt ab$ 和 $\tt b$，但是没有 $\tt ab$ 这个地区，只有 $\tt b$ 地区，所以只能选择 $\tt b$ 这个地区；

询问 $2$ 中的公共后有 $\tt abb$，$\tt bb$ 和 $\tt b$，但是没有 $\tt abb$ 和 $\tt bb$ 这两个地区，只有 $\tt b$ 地区，所以只能选择 $\tt b$ 这个地区。

### 数据范围及约定

设这个国家地区总数数为 $tot$（注意：输入的字符串总长度可能超过 $tot$！）

- 对于 $30\%$ 的数据，满足 $1\le tot, m, n \le 100$；
- 对于 $50\%$ 的数据，满足 $1\le tot, m, n \le 1000$；
- 对于 $80\%$ 的数据，满足 $1\le tot, m, n \le 10^5$；
- 对于 $100\%$ 的数据，满足$1\le  tot, m, n \le 10^6$。

保证输入文件不超过 $20\text{MB}$。

HEOI2012 Day 2 Task 2

## 样例 #1

### 输入

```
2
aabb
babb
2
1 3 2 3
1 4 2 4 ```

### 输出

```
1
1```

# 题解

## 作者：皎月半洒花 (赞：6)

~~为啥感觉另一篇题解就约等于啥都没写啊~~

总结一下思考过程。首先根据“前缀”和“多串”，可知需要一个可以接收许多串的自动机，比如~~线段树合并维护反串的广义SAM~~AC自动机，而字典树正好是前缀树，于是考虑在AC自动机上搞事情。

考虑`fail`数组的意义，由于AC自动机本身的前缀性质，不需要匹配前缀，所以`fail`会指向与自己相同且深度较浅的后缀。然后就考虑搞一个`vector`出来维护每个串的每个前缀的节点编号，由于深度期望越大，求`fail`时跳的次数期望越少，所以求一下`LCA`就是最长后缀了。

然后是代码，一A就很开心.jpg

据说卡倍增，然而都9102年了为什么不树剖？

```cpp
#define Sigma 27
#define MAXN 1000010
#define Mod 1000000007

using namespace std ;

char S[MAXN] ;
int T, M, L[MAXN] ;
vector <int> pre[MAXN] ;
struct Edge{
    int to, next ;
    #define p_b push_back
    #define to(k) E[k].to
    #define next(k) E[k].next
}E[MAXN] ; int head[MAXN], cnt ;
int sze[MAXN], dep[MAXN], fa[MAXN], top[MAXN], son[MAXN] ;

void add(int u, int v){
    E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;
}
struct ACAM{
    queue <int> q ;
    int sz, fail[MAXN] ;
    int trie[MAXN][Sigma], ans[MAXN] ;
    void insert(char *s, int n){
        int rt = 0, x ; pre[n].p_b(0) ;
        for (int i = 1 ; i <= L[n] ; ++ i){
            x = s[i] - 'a' ;
            if (!trie[rt][x])
                trie[rt][x] = ++ sz,
                ans[trie[rt][x]] = (26ll * ans[rt] + x) % Mod ;
            pre[n].p_b(trie[rt][x]) ; rt = trie[rt][x] ;
        }
    }
    void build(){
        for (int i = 0 ; i < Sigma ; ++ i)
            if (trie[0][i]) q.push(trie[0][i]) ;
        while (!q.empty()){
            int n = q.front() ; add(fail[n], n), q.pop() ;
//            cout << n << endl ;
            for (int i = 0 ; i < 26 ; ++ i){
                if (!trie[n][i]) trie[n][i] = trie[fail[n]][i] ;
                else fail[trie[n][i]] = trie[fail[n]][i], q.push(trie[n][i]) ;
            }
        }
    }
}AC ;
void dfs(int u){
    sze[u] = 1, dep[u] = dep[fa[u]] + 1 ;
    for (int k = head[u] ; k ; k = next(k)){
        fa[to(k)] = u, dfs(to(k)), sze[u] += sze[to(k)] ;
        if (!son[u] || sze[to(k)] > sze[son[u]]) son[u] = to(k) ;
    }
}
void dfs2(int u, int tp){
    top[u] = tp ;
    if (son[u]) dfs2(son[u], tp) ;
    for (int k = head[u] ; k ; k = next(k))
        if (to(k) != son[u]) dfs2(to(k), to(k)) ;
}
int lca(int u, int v){
    // qw(u, '\n', true), qw(v, '\n', true) ;
    // cout << u << " " << v << endl ;
    while (top[u] != top[v]){
        if (dep[top[u]] >= dep[top[v]]) u = fa[top[u]] ;
        else v = fa[top[v]] ;
    }
    return dep[u] < dep[v] ? u : v ;
}
int qr(){
    int r = 0 ; char c = getchar() ;
    while (!isdigit(c)) c = getchar() ;
    while (isdigit(c)) r = (r << 1) + (r << 3) + c - 48, c = getchar() ;
    return r ;
}
int main(){
    cin >> T ;
    for (int i = 1 ; i <= T ; ++ i)
        scanf("%s", S + 1), L[i] = strlen(S + 1), AC.insert(S, i) ;
    AC.build() ; cin >> M ; dfs(0), dfs2(0, 0) ;
     int p, l, q, r, x, y ;
    while (M --){
        p = qr(), l = qr(), q = qr(), r = qr() ;
        x = pre[p][l], y = pre[q][r], printf("%d\n", AC.ans[lca(x, y)]) ;
    }
}

```

---

## 作者：比利♂海灵顿 (赞：6)

# HEOI2012 旅行问题

这题没有必要用树剖呀，这里有一篇线段树的题解。

## 题意简述

给 $n$ 个字符串，每个询问在这些字符串中选两个前缀，要求输出它们满足要求的公共后缀的哈希值。这个公共后缀必须在给出的 $n$ 个字符串的前缀中出现，并且要求尽可能长。

## 思路

对给出的字符串建立 AC 自动机。

发现每个前缀都对应着确定的节点，而每个节点一定能代表一个出现过的前缀。只要在构造时将每个前缀对应的哈希值存到对应节点上，这样问题就从找一个前缀的哈希值变成了找一个节点了。

发现每个节点在后缀链接树上的祖先就是它最长的非自身的后缀。也就是说两个前缀的节点在后缀链接树上的公共祖先就是他们的公共后缀，而满足条件的最长后缀就是他们的最近公共祖先。

所以本题就是构造 AC 自动机然后在后缀链接树上求 LCA。

### 查询 LCA

最终代码使用了线段树在欧拉序上查询区间最浅点，没有使用树链剖分（因为我不会）

### 防止误导，先放 AC 代码

由于本题空间卡得比较紧，所以我选择在后面放出优化过程。

```cpp
const unsigned MOD(1000000007);
const char _0(0), _26(26);
unsigned Nn, CntS(0), Len, m, n, Cnt(0), A, B, C, D, FindL, FindR, t, Ans(0), Tmp[2000005];
char b, Addx;
struct Node {
  unsigned Dep, Hash, DFSr, SubDFSr, To[26], Fa, Fail, Son, Bro;
}N[1000005], *CntN(N), *Now(N);
struct Sg {
  unsigned LS, RS, Val;
}S[4000005];
void Qry(Sg *x, unsigned L, unsigned R) {
  if((FindL <= L) && (R <= FindR)) {
    if(Now->Dep > N[x->Val].Dep) Now = N + x->Val; 
    return; 
  }
  register unsigned Mid((L + R) >> 1);
  if(Mid >= FindL) Qry(S + x->LS, L, Mid);
  if(Mid < FindR) Qry(S + x->RS, Mid + 1, R);
}
void BuildSg(Sg *x, unsigned L, unsigned R) {
  if(L == R) {x->Val = Tmp[L];return;}
  register unsigned Mid((L + R) >> 1);
  BuildSg(S + (x->LS = ++CntS), L, Mid);
  BuildSg(S + (x->RS = ++CntS), Mid + 1, R);
  if(N[S[x->LS].Val].Dep < N[S[x->RS].Val].Dep) x->Val = S[x->LS].Val;
  else x->Val = S[x->RS].Val;
}
unsigned Pool[20000005], *Pos[1000005], Top(0);
struct Quu {
  unsigned P; char Chr;
}TmpQ;
queue<Quu> Q;
void Add() {
  if(!Now->To[Addx]) Now->To[Addx] = ++CntN - N, CntN->Fa = Now - N, CntN->Son = 0x3f3f3f40;
  N[Now->To[Addx]].Hash = (((unsigned long long)26 * Now->Hash) + Addx) % MOD, Now = N + Now->To[Addx];
}
void Build() {
  TmpQ.P = 0;
  Q.push(TmpQ);
  register Node *x, *Back;
  register char c; 
  while (Q.size()) {
    TmpQ = Q.front(), Q.pop();
    x = N + TmpQ.P, c = TmpQ.Chr;
    if(x->Fa < 0x3f3f3f3f) {
      Back = N + N[x->Fa].Fail;
      while (Back < N + 0x3f3f3f3f) {
        if(Back->To[c]) {
          x->Fail = Back->To[c];
          x->Bro = N[Back->To[c]].Son;
          N[Back->To[c]].Son = x - N;
          break; 
        }
        Back = N + Back->Fail;
      }
      if(!(x->Fail)) {
        x->Fail = 0;
        x->Bro = N->Son;
        N->Son = x - N;
      }
    }
    for (register char i(_0); i < _26; ++i) if(x->To[i]) TmpQ.P = x->To[i], TmpQ.Chr = i, Q.push(TmpQ);
  }
}
void DFS(Node *x) {
  Tmp[++Cnt] = x - N, x->DFSr = Cnt;
  register Node *So(N + x->Son);
  while (So < N + 0x3f3f3f3f) So->Dep = x->Dep + 1, DFS(So), So = N + So->Bro;
  Tmp[++Cnt] = x - N, x->SubDFSr = Cnt;
  return;
}
int main() {
  n = RD();
  for (register unsigned i(1); i <= n; ++i) {
    while ((b = getchar()) < 'a');
    Now = N, Pos[i] = Pool + Top + 1;
    while (b >= 'a') Addx = b - 'a', Add(), Pool[++Top] = Now - N, b = getchar();
  }
  N[0].Son = N[0].Fa = N[0].Fail = 0x3f3f3f40, Build(), N->Dep = 1, DFS(N), Nn = CntN - N + 1, Nn <<= 1, BuildSg(S, 1, Nn);
  m = RD(), N[Nn + 1].Dep = 0x3f3f3f3f;
  for (register unsigned i(1); i <= m; ++i) {
    A = RD(), B = RD(), C = RD(), D = RD();
    FindL = N[Pos[A][B - 1]].DFSr, FindR = N[Pos[C][D - 1]].DFSr;
    if(FindL > FindR) swap(FindL, FindR);
    if(N[Tmp[FindL]].SubDFSr > FindR) Now = N + Tmp[FindL];
    else Now = N + Nn + 1, Qry(S, 1, Nn), Now = N + Now->Fail;
    printf("%u\n", Now->Hash);
  }
  return Wild_Donkey;
}
```

### 代码实现

构造 AC 自动机，用 ST 求 LCA，可以做到 $O(1)$ 查询，但是卡空间只能得 $80'$。

```cpp
const unsigned MOD(1000000007);
const char _0(0), _26(26);
unsigned Log[1000005], Bin[25], ST[2000005][22], Nn, Len, m, n, Cnt(0), A, B, C, D, t, Ans(0), Tmp(0);
char b;
struct Node {
  unsigned Dep, Hash, DFSr;
  Node *To[26], *Fa, *Fail, *Son, *Bro;
}N[1000005], *CntN(N), *Now(N);
vector <unsigned> Pos[1000005];
struct Quu {
  Node *P;char Chr;
}Q[1000005], *Hd(Q), *Tl(Q);
void Add(char x) {
  if(!(Now->To[x])) Now->To[x] = ++CntN, CntN->Fa = Now;
  Now->To[x]->Hash = (((unsigned long long)26 * Now->Hash) + x) % MOD, Now = Now->To[x];
}
void Build() {
  (++Tl)->P = N;
  register Node *x, *Back;
  register char c; 
  while (Tl != Hd) {
    x = (++Hd)->P, c = Hd->Chr;  
    if(x->Fa) {
      Back = x->Fa->Fail;
      while (Back) {
        if(Back->To[c]) {
          x->Fail = Back->To[c];
          x->Bro = Back->To[c]->Son;
          Back->To[c]->Son = x;
          break; 
        }
        Back = Back->Fail;
      }
      if(!(x->Fail)) {
        x->Fail = N;
        x->Bro = N->Son;
        N->Son = x;
      }
    }
    for (register char i(_0); i < _26; ++i) if(x->To[i]) (++Tl)->P = x->To[i], Tl->Chr = i;
  }
}
void DFS(Node *x) {
  ST[++Cnt][0] = x - N, x->DFSr = Cnt;
  register Node *So(x->Son);
  while (So) So->Dep = x->Dep + 1, DFS(So), So = So->Bro;
  ST[++Cnt][0] = x - N;
  return;
}
inline Node *LCA(Node *x, Node *y) {
  if(x->DFSr > y->DFSr) swap(x, y);
  register unsigned TmpL(Log[y->DFSr - x->DFSr + 1]);
  register Node *TmpP;
  if(N[ST[x->DFSr][TmpL]].Dep < N[ST[y->DFSr - Bin[TmpL] + 1][TmpL]].Dep) TmpP = N + ST[x->DFSr][TmpL];
  else TmpP = N + ST[y->DFSr - Bin[TmpL] + 1][TmpL];
  if(TmpP == x) return x;
  return TmpP->Fail;
}
int main() {
  n = RD();
  for (register unsigned i(1); i <= n; ++i) {
    while ((b = getchar()) < 'a');
    Now = N;
    while (b >= 'a') Add(b - 'a'), Pos[i].push_back(Now - N), b = getchar();
  }
  Build(), N->Dep = 1, DFS(N), Nn = CntN - N + 1, Nn <<= 1;
  for (register unsigned i(1), j(0); i <= Nn; i <<= 1, ++j) Bin[j] = i, Log[i] = j;
  for (register unsigned i(3); i <= Nn; ++i) Log[i] = max(Log[i - 1], Log[i]);
  for (register unsigned i(1), j(0); i < Nn; i <<= 1, ++j) {
    for (register unsigned k(1); k + (i << 1) <= Nn + 1; ++k) {
      if(N[ST[k][j]].Dep < N[ST[k + i][j]].Dep) ST[k][j + 1] = ST[k][j];
      else ST[k][j + 1] = ST[k + i][j];
    }
  }
  m = RD();
  for (register unsigned i(1); i <= m; ++i) {
    A = RD(), B = RD(), C = RD(), D = RD();
    printf("%u\n", LCA(N + Pos[A][B - 1], N + Pos[C][D - 1])->Hash);
  }
  return Wild_Donkey;
}
```

### 线段树 LCA + `unordered_map` 优化

发现 ST 表本质上是在欧拉序上求区间深度最小点。做到了 $O(1)$ 查询，代价是 $O(tot\log tot)$。

这时时间尚有结余，但是空间吃紧，所以本题特殊之处在于用空间换时间。

思考区间查询最值还可以使用线段树在 $O(\log tot)$ 的时间内查询，空间只需要 $O(tot)$。

这是发现还是 MLE，瓶颈在转移边，于是使用 `unordered_map` 优化空间。

为了优化空间，不存储线段树节点表示的区间，而是在递归过程中作为参数传进函数中。

但是因为常数过大，程序从 MLE 变成了 TLE。仍然是 $80'$。

```cpp
const unsigned MOD(1000000007);
const char _0(0), _26(26);
unsigned Nn, CntS(0), Len, m, n, Cnt(0), A, B, C, D, FindL, FindR, t, Ans(0), Tmp[2000005];
char b, Addx;
struct Node {
  unsigned Dep, Hash, DFSr, SubDFSr, To[26], Fa, Fail, Son, Bro;
}N[1000005], *CntN(N), *Now(N);
struct Sg {
  unsigned LS, RS, Val;
}S[4000005];
void Qry(Sg *x, unsigned L, unsigned R) {
  if((FindL <= L) && (R <= FindR)) {
    if(Now->Dep > N[x->Val].Dep) Now = N + x->Val; 
    return; 
  }
  register unsigned Mid((L + R) >> 1);
  if(Mid >= FindL) Qry(S + x->LS, L, Mid);
  if(Mid < FindR) Qry(S + x->RS, Mid + 1, R);
}
void BuildSg(Sg *x, unsigned L, unsigned R) {
  if(L == R) {x->Val = Tmp[L];return;}
  register unsigned Mid((L + R) >> 1);
  BuildSg(S + (x->LS = ++CntS), L, Mid);
  BuildSg(S + (x->RS = ++CntS), Mid + 1, R);
  if(N[S[x->LS].Val].Dep < N[S[x->RS].Val].Dep) x->Val = S[x->LS].Val;
  else x->Val = S[x->RS].Val;
}
unsigned Pool[20000005], *Pos[1000005], Top(0);
struct Quu {
  unsigned P; char Chr;
}TmpQ;
queue<Quu> Q;
void Add() {
  if(!Now->To[Addx]) Now->To[Addx] = ++CntN - N, CntN->Fa = Now - N, CntN->Son = 0x3f3f3f40;
  N[Now->To[Addx]].Hash = (((unsigned long long)26 * Now->Hash) + Addx) % MOD, Now = N + Now->To[Addx];
}
void Build() {
  TmpQ.P = 0;
  Q.push(TmpQ);
  register Node *x, *Back;
  register char c; 
  while (Q.size()) {
    TmpQ = Q.front(), Q.pop();
    x = N + TmpQ.P, c = TmpQ.Chr;
    if(x->Fa < 0x3f3f3f3f) {
      Back = N + N[x->Fa].Fail;
      while (Back < N + 0x3f3f3f3f) {
        if(Back->To[c]) {
          x->Fail = Back->To[c];
          x->Bro = N[Back->To[c]].Son;
          N[Back->To[c]].Son = x - N;
          break; 
        }
        Back = N + Back->Fail;
      }
      if(!(x->Fail)) {
        x->Fail = 0;
        x->Bro = N->Son;
        N->Son = x - N;
      }
    }
    for (register char i(_0); i < _26; ++i) if(x->To[i]) TmpQ.P = x->To[i], TmpQ.Chr = i, Q.push(TmpQ);
  }
}
void DFS(Node *x) {
  Tmp[++Cnt] = x - N, x->DFSr = Cnt;
  register Node *So(N + x->Son);
  while (So < N + 0x3f3f3f3f) So->Dep = x->Dep + 1, DFS(So), So = N + So->Bro;
  Tmp[++Cnt] = x - N, x->SubDFSr = Cnt;
  return;
}
int main() {
  n = RD();
  for (register unsigned i(1); i <= n; ++i) {
    while ((b = getchar()) < 'a');
    Now = N, Pos[i] = Pool + Top + 1;
    while (b >= 'a') Addx = b - 'a', Add(), Pool[++Top] = Now - N, b = getchar();
  }
  N[0].Son = N[0].Fa = N[0].Fail = 0x3f3f3f40, Build(), N->Dep = 1, DFS(N), Nn = CntN - N + 1, Nn <<= 1, BuildSg(S, 1, Nn);
  m = RD(), N[Nn + 1].Dep = 0x3f3f3f3f;
  for (register unsigned i(1); i <= m; ++i) {
    A = RD(), B = RD(), C = RD(), D = RD();
    FindL = N[Pos[A][B - 1]].DFSr, FindR = N[Pos[C][D - 1]].DFSr;
    if(FindL > FindR) swap(FindL, FindR);
    if(N[Tmp[FindL]].SubDFSr > FindR) Now = N + Tmp[FindL];
    else Now = N + Nn + 1, Qry(S, 1, Nn), Now = N + Now->Fail;
    printf("%u\n", Now->Hash);
  }
  return Wild_Donkey;
}
```

### 信仰崩塌

$64$ 位机的指针比整形大一倍，所以将所有指针换成数组，然后成功在没有 `unordered_map` 的前提下将内存压到可接受的范围内。

代码就是一开始的那份代码。


---

## 作者：AuZeb (赞：4)

## 前置知识
失配树和最近公共祖先。

## 思路与做法

将原问题转换为在失配树上寻找最近公共祖先，主要是因为以下两个原因：

- **失配树的性质**：在失配树中，从根节点到任意节点的路径所代表的字符串，必然是字典树中从根节点到该节点路径所代表字符串的后缀。例如，若字典树中有节点对应字符串 `abc`，在失配树中，从根节点到该节点路径上的节点对应的字符串 `c`、`bc`、`abc` 都是 `abc` 的后缀。
- 题目要求找出两个地区描述到指定位置的串的最长公共后缀。假设两个地区描述分别为 $s_1$ 和$s_2$，在字典树中找到这两个描述对应位置的节点 $n_1$ 和 $n_2$。因为失配树的性质，从根节点到 $n_1$ 和 $n_2$ 路径上的节点对应的字符串分别是 $s_1$ 和 $s_2$ 的后缀。那么，$n_1$ 和 $n_2$ 在失配树中的最近公共祖先节点 $lca$，从根节点到 $lca$ 的路径所代表的字符串，就是 $s_1$ 和 $s_2$ 的最长公共后缀。这是因为最近公共祖先的路径是同时能到达 $n_1$ 和 $n_2$ 的最长公共路径，也就对应着两个地区描述的最长公共后缀。

理解了上面的，就比较简单了，给所有编码的每个前缀构建字典树，然后跑一遍构建失配树，最后直接输出根到该最近公共祖先的值（注意是原图上的值），样例如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/7hxwkzuv.png)

## 代码

由于遭受了 `MLE` 的重创，迫不得已将部分 `vector` 换成了数组，可能使可读性下降。`vector` 邻接表与链式前向星有内存性能上的差异，因为 `vector` 扩充时是默认多申请 $2$ 倍空间，所以像这道变态的题目可能会卡内存只能用链式前向星的写法写。

```
#include<bits/stdc++.h>
#define maxn 1000006
#define mod 1000000007
using namespace std;
int ch[maxn][26],idx=0,fail[maxn];
long long va[maxn];
int Id[maxn*2],len=0,Idx=0,Len[maxn];
// 注意输入的字符串总长度可能超过 tot！
struct Tree{int ne,to;}tr[maxn*2]; // 失配树。
// 原先 Id[i][j] 表示第 i 个表示的第 j 个地区对应的字典树的值，由于 vector 炸了，就用 Id[i]+Len[i] 代替了。
int k=0,head[maxn];
void add(int u,int v){k++,tr[k].to=v,tr[k].ne=head[u],head[u]=k;}
void ins(int id,string s){
	int u=0;
	for(int i=0;i<s.length();i++){
		if(!ch[u][s[i]-'a']) ch[u][s[i]-'a']=++idx;
		va[ch[u][s[i]-'a']]=(va[u]*26+(s[i]-'a'))%mod, // 计算根到该节点的值。
		u=ch[u][s[i]-'a'],Id[++Idx]=u; // 存储每个地区对应字典树上的编号。
	}
}
void bul(){ // 建立失配数组和失配树。
	queue<int> q;
	for(int i=0;i<26;i++) if(ch[0][i])
		q.push(ch[0][i]),add(0,ch[0][i]),add(ch[0][i],0);
	while(!q.empty()){
		int u=q.front(); q.pop();
		for(int i=0;i<26;i++)
			if(ch[u][i])
				fail[ch[u][i]]=ch[fail[u]][i],q.push(ch[u][i]),
				add(ch[u][i],fail[ch[u][i]]),
				add(fail[ch[u][i]],ch[u][i]);
			else ch[u][i]=ch[fail[u]][i];
	}
}
int dfn[maxn],tim=0,st[20][maxn]; // dfs 序 +ST 表找最近公共祖先。
// 详见 https://www.luogu.com.cn/article/pu52m9ue。
int get(int x,int y){
	return dfn[x]<dfn[y]?x:y;
}
struct Node{int x,f;};
void dfs(int u,int fa){ // 用迭代替代了递归。
	stack<Node> stk;
	stk.push({0,0});
	while (!stk.empty()){
		int u=stk.top().x,fa=stk.top().f; stk.pop();
		if(dfn[u]==0){
			tim++,dfn[u]=tim,st[0][tim]=fa;
			for(int i=head[u];i;i=tr[i].ne)
				if(tr[i].to!=fa) stk.push({tr[i].to, u});
		}
	}
}
int lca(int u,int v){
	if(u==v) return u;
	u=dfn[u],v=dfn[v]; if(u>v) swap(u,v);
	int dis=__lg(v-u); u++;
	return get(st[dis][u],st[dis][v-(1<<dis)+1]);
}
int main(){
	int n; cin>>n; string s;
	for(int i=1;i<=n;i++) cin>>s,ins(i,s),len+=s.length(),Len[i]=len;
	// Len[i] 表示前 i 行的总地区数。
	bul(),dfs(0,0);
	for(int i=1;i<=__lg(idx+1);i++)
		for(int j=1;j+(1<<i)-1<=idx+1;j++)
			st[i][j]=get(st[i-1][j],st[i-1][j+(1<<i-1)]);
	int m,i,j,k,l,u,v; cin>>m; while(m--)
		cin>>i>>j>>k>>l,u=Id[Len[i-1]+j],v=Id[Len[k-1]+l],cout<<va[lca(u,v)]<<"\n";
	return 0;
}
```

---

## 作者：hlsnqdmz (赞：3)

作为蒟蒻的第一篇题解，如果有什么问题，请多海涵。

首先是题意，这道题的题意还是并不好想的，本人自我的想法是：从第 $i$ 个描述的字符串中第 $1$ 到 $j$ 范围的字符串和第  $k$  个描述的字符串中第  $1$  到  $l$  范围的字符串的公共后缀中符合它是所有描述的字符串中一个字符串的前缀。（~~其实完全不简洁啊~~其实就是找给定的两个串公共后缀使其是描述的字符串中任意一个的前缀。）

但其实转化为 AC 自动机就很好想了：将所有字符串构造为字典树，再求出每个字典树节点的 fail 数组，构造 fail 树。（这东西可能不太好懂，可以先去做一下失配树的例题，可能有一些帮助，其实思想都差不多。）

具体步骤就是构造字典树（黑线），求出节点的 fail 数组（红线），保留红线构造 fail 树。（如图，图丑，请骂轻点）

![字典树和 fail 指针](https://cdn.luogu.com.cn/upload/image_hosting/38ewasff.png)

然后构造 fail 树

![ fail 树](https://cdn.luogu.com.cn/upload/image_hosting/ro606fja.png)
我们可以看到，除了 root 节点，其他节点是它子孙的后缀，而两个节点的最近公共祖先就是它们的最大公共后缀。（这里很重要，请多多熟悉）接下来我们就可以求询问的两个字符串的最近公共祖先，说是会卡倍增，其实还是能过。

代码（码风很丑）：
```
//Just Sayori
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int mod = 1e9+7;
inline ll read()//快读，可以不用，此及后文的 inline 也可以不用。
{
    ll x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - 48;
        ch = getchar();
    }
    return x * f;
}
int ch[1200005][26], fail[1200005], p, tot, st[1200005][25], de[1200005];//再开大就会爆的大小。
ll code[1200005];
vector<int> id[1200005];//不开成vector容易爆空间。

inline void insert(string s)//字典树模板。
{
    int len = s.size(), u = 0;
    id[p].resize(len + 1);//不用会卡死。
    for (int i = 0; i < len; i++)
    {
        int v = s[i] - 'a';
        if (!ch[u][v]) code[ch[u][v] = ++tot] = (code[u] * 26 + s[i] - 'a') % mod;//求出每个字符串的编码。
        id[p][i] = u = ch[u][v];//求出的 p 个字符串第 i 位是哪个节点。
    }
}

inline void get_fail()//求 fail 数组模板。
{
    queue<int> q;
    for (int i = 0; i < 26; i++)
        if (ch[0][i]) fail[ch[0][i]] = 0, de[ch[0][i]] = 1, q.push(ch[0][i]);
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (int i = 0; i < 26; i++)//for 循环内的内容很容易写错。
        {
            if (ch[u][i])
            {
                fail[ch[u][i]] = ch[fail[u]][i];
                q.push(ch[u][i]);
                st[ch[u][i]][0] = fail[ch[u][i]];
                de[ch[u][i]] = de[fail[ch[u][i]]] + 1;
            }
            else
                ch[u][i] = ch[fail[u]][i], de[ch[u][i]] = de[ch[fail[u]][i]];
        }
    }

}

inline ll get_lca(int a, int b)//求 LCA。
{
    if (a == b) return code[a];
    if (de[a] < de[b]) swap(a, b);
    if (de[a] != de[b])//加了个特判。
        for (int i = 24; i >= 0; i--)
            if (de[st[a][i]] >= de[b]) a = st[a][i];
    if (a == b) return code[a];
    for (int i = 24; i >= 0; i--)
    {
        if (st[a][i] == st[b][i]) continue;
        a = st[a][i];
        b = st[b][i];
    }
    return code[st[a][0]];//注意返回值。
}

int main()
{
    string s;
    int n = read(), m;
    for (int i = 1; i <= n; i++)
        cin >> s, p = i, insert(s);
    m = read();
    get_fail();
    for (int i = 1; i <= 24; i++)
        for (int j = 1; j <= tot; j++)
            st[j][i] = st[st[j][i - 1]][i - 1];//倍增的预备操作。
    for (int i = 1; i <= m; i++)
    {
        int num1 = read(), r1 = read(), num2 = read(), r2 = read();
        printf("%lld\n", get_lca(id[num1][r1 - 1], id[num2][r2 - 1]));//记得减一，因为题目是从一开始的。
    }
    return 0;
}
```
### 感谢您的观看！

---

## 作者：creation_hy (赞：1)

虽然但是，倍增这不是能过吗，，

询问如果只有一个串就是 AC 自动机板子了嘛，后缀等于前缀的最长串的定义就是这个点的 fail。

那两个串根据 LCA 的定义不就是求 fail 树上的 LCA 吗。。。

然后用倍增就好了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 5;
const int mod = 1e9 + 7;
int n, m, head[N], to[N], nxt[N], etot;
ll val[N];
vector<int> pos[N];
inline void link(int u, int v)
{
    to[etot] = v;
    nxt[etot] = head[u];
    head[u] = etot++;
}
struct ACAM
{
    int t[N][26], fail[N], tot;
    inline void insert(int id, string s)
    {
        int n = s.size();
        s = ' ' + s, pos[id].resize(n + 1);
        for (int i = 1, p = 0; i <= n; i++)
        {
            int c = s[i] - 'a';
            if (!t[p][c])
                val[t[p][c] = ++tot] = (val[p] * 26 + c) % mod;
            pos[id][i] = p = t[p][c];
        }
    }
    inline void build()
    {
        queue<int> q;
        for (int i = 0; i < 26; i++)
            if (t[0][i])
                q.emplace(t[0][i]);
        while (!q.empty())
        {
            int x = q.front();
            q.pop();
            link(fail[x], x);
            for (int i = 0; i < 26; i++)
                if (t[x][i])
                    fail[t[x][i]] = t[fail[x]][i], q.emplace(t[x][i]);
                else
                    t[x][i] = t[fail[x]][i];
        }
    }
} ac;
int g[N][20], dep[N];
inline void dfs(int x, int fa)
{
    g[x][0] = fa, dep[x] = dep[fa] + 1;
    for (int i = 1; i <= 19; i++)
        g[x][i] = g[g[x][i - 1]][i - 1];
    for (int i = head[x]; ~i; i = nxt[i])
        if (to[i] != fa)
            dfs(to[i], x);
}
inline int LCA(int x, int y)
{
    if (dep[x] < dep[y])
        swap(x, y);
    for (int i = 19; ~i; i--)
        if (dep[g[x][i]] >= dep[y])
            x = g[x][i];
    if (x == y)
        return x;
    for (int i = 19; ~i; i--)
        if (g[x][i] != g[y][i])
            x = g[x][i], y = g[y][i];
    return g[x][0];
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    memset(head, -1, sizeof(head));
    cin >> n;
    string s;
    for (int i = 1; i <= n; i++)
        cin >> s, ac.insert(i, s);
    ac.build();
    for (int i = head[0]; ~i; i = nxt[i])
        dfs(to[i], 0);
    cin >> m;
    while (m--)
    {
        int x1, x2, y1, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        cout << val[LCA(pos[x1][y1], pos[x2][y2])] << '\n';
    }
    return 0;
}
```

---

## 作者：JoaoFelix (赞：0)

题目不难，但是理解了很长时间，刚开始没看懂题意

考虑多串问题直接插入ac自动机就可以

然后我们每次给定两个串，答案就是他们最长公共后缀，并且要出现这个地区

发现就是后缀恰是前缀，这恰好符合多串ac自动机fail树的性质

所以我们容易发现答案就是询问这两个点的lca

具体我们需要统计一下每个点的ans数组，并且用vector动态记录一下分别属于的节点

还有求lca不能用倍增，ta又被卡了，因此我们直接树剖lca实现

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

inline int read() {
	char c = getchar(); int x = 0, f = 1;
	while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * f;
}

const int N = 1000005, lhc = 1e9 + 7;

int n, ch[N][26], fail[N], ttt, ans[N]; char str[N];
int lnk[N], nxt[N], fst[N], tot;
int dep[N], fa[N], sz[N], son[N], top[N];
vector<int> rec[N]; 

void BFS() {
	queue<int> que; while (!que.empty()) que.pop();
	for (int i = 0; i < 26; i++) if (ch[0][i]) que.push(ch[0][i]);
	while (!que.empty()) {
		int u = que.front(); que.pop();
		for (int i = 0; i < 26; i++)
			if (!ch[u][i]) ch[u][i] = ch[fail[u]][i];
			else que.push(ch[u][i]), fail[ch[u][i]] = ch[fail[u]][i];
	}
}

void adde(int u, int v) {
	// printf("adde: %d %d\n", u, v);
	lnk[++tot] = v; nxt[tot] = fst[u]; fst[u] = tot;
}
void gt(int u, int f) {
	dep[u] = dep[f] + 1; fa[u] = f; sz[u] = 1;
	for (int i = fst[u]; i; i = nxt[i]) {
		int v = lnk[i];
		if (v != f) {
			gt(v, u), sz[u] += sz[v];
			if (sz[v] > sz[son[u]]) son[u] = v;
		}
	}
}
void gt_tp(int u, int tp) {
	top[u] = tp; if (son[u]) gt_tp(son[u], tp);
	for (int i = fst[u]; i; i = nxt[i]) {
		int v = lnk[i]; if (v != fa[u] && v != son[u]) gt_tp(v, v);
	}
}
int LCA(int u, int v) {
	while (top[u] != top[v]) {
		if (dep[top[u]] < dep[top[v]]) swap(u, v);
		u = fa[top[u]];
	}
	return dep[u] < dep[v] ? u : v;
}

int main() {
	n = read();
	for (int i = 1; i <= n; i++) {
		scanf("%s", str + 1);
		int u = 0, l = strlen(str + 1);
		rec[i].resize(l + 1);
		for (int j = 1; j <= l; j++) {
			int p = str[j] - 'a', lst = u;
			if (!ch[u][p]) ch[u][p] = ++ttt;
			u = ch[u][p], rec[i][j] = u, ans[u] = ((ll)ans[lst] * 26ll + p) % lhc;
		}
	}
	BFS(); for (int i = 1; i <= ttt; i++) adde(fail[i], i);
	gt(0, 0), gt_tp(0, 0);
	int q = read();
	while (q--) {
		int i = read(), j = read(), k = read(), l = read();
		int u = rec[i][j], v = rec[k][l];
		printf("%d\n", ans[LCA(u, v)]);
	}
	return 0;
}
```


---


# [SDOI2018] 战略游戏

## 题目描述

省选临近，放飞自我的小 Q 无心刷题，于是怂恿小 C 和他一起颓废，玩起了一款战略游戏。

这款战略游戏的地图由 $n$ 个城市以及 $m$ 条连接这些城市的双向道路构成，并且从任意一个城市出发总能沿着道路走到任意其他城市。

现在小 C 已经占领了其中至少两个城市，小 Q 可以摧毁一个小 C 没占领的城市，同时摧毁所有连接这个城市的道路。只要在摧毁这个城市之后能够找到某两个小 C 占领的城市 $u$ 和 $v$，使得从 $u$ 出发沿着道路无论如何都不能走到 $v$，那么小 Q 就能赢下这一局游戏。

小 Q 和小 C 一共进行了 $q$ 局游戏，每一局游戏会给出小 C 占领的城市集合 $S$，你需要帮小 Q 数出有多少个城市在他摧毁之后能够让他赢下这一局游戏。

## 说明/提示

- $1 \le T \le 10$；
- $2 \le n \le 10^5$ 且 $n - 1 \le m \le 2\times 10 ^ 5$；
- $1 \le q \le 10^5$；
- 对于每组测试数据，有 $\sum|S| \le 2 \times 10^5$。

### Subtasks

- 子任务 1 (30 分)：对于每组测试数据，满足 $\sum|S| \le 20$；
- 子任务 2 (45 分)：对于每一次询问，满足 $|S| = 2$；
- 子任务 3 (25 分)：没有任何附加的限制。


## 样例 #1

### 输入

```
2
7 6
1 2
1 3
2 4
2 5
3 6
3 7
3
2 1 2
3 2 3 4
4 4 5 6 7
6 6
1 2
1 3
2 3
1 4
2 5
3 6
4
3 1 2 3
3 1 2 6
3 1 5 6
3 4 5 6
```

### 输出

```
0
1
3
0
1
2
3```

# 题解

## 作者：Caii (赞：62)

看到这个题目的时候我惊了

这不是把我的 [road](https://www.luogu.org/problemnew/show/P4320) 的询问点数从两个改成 $k$ 个吗，所以如果你写过我公开赛的这个题你就可以 SDOI2018 考场上拿到至少 45 分了

所以这算不算我押中了 SDOI2018 的题目呀

首先使用 Tarjan 算法建出圆方树，然后答案就是 圆方树 上包含所有关键点的最少点数联通块 的圆点数量 减去 关键点的数量

为了方便，我们设圆点的权值设为 1 ，方点的权值为 0 ，将点权放到这个点与其父节点的边上

搞出树上的 DFS 序，将询问的关键点按照 DFS 序排序，求出排序之后的相邻关键点在树上路径的权值之和再加上排序之后第一个关键点与最后一个关键点在树上的路径权值之和，将其除以 2 就是圆方树上包含所有关键点的最少点数联通块的边权值和，转化为点权之和需要加上联通块根节点(也就是排序之后第一个关键点与最后一个关键点的LCA)的权值，最后减去关键点数量即可

时间复杂度:$O(N\log N)$

```cpp
#include <cctype>
#include <cstdio>
#include <vector>
#include <cstring>
#include <algorithm>

#define DEBUG(args...) fprintf(stderr, args)

typedef long long LL;

#define FOR(i, l, r) for(int i = (l), i##_end = (r); i <= i##_end; ++i)
#define REP(i, l, r) for(int i = (l), i##_end = (r); i <  i##_end; ++i)
#define DFR(i, l, r) for(int i = (l), i##_end = (r); i >= i##_end; --i)
#define DRP(i, l, r) for(int i = (l), i##_end = (r); i >  i##_end; --i)

template<class T>T Min(const T &a, const T &b) {return a < b ? a : b;}
template<class T>T Max(const T &a, const T &b) {return a > b ? a : b;}
template<class T>bool Chkmin(T &a, const T &b) {return a > b ? a = b, 1 : 0;}
template<class T>bool Chkmax(T &a, const T &b) {return a < b ? a = b, 1 : 0;}

class fast_input {
private:
	static const int SIZE = 1 << 15 | 1;
	char buf[SIZE], *front, *back;

	void Next(char &c) {
	    if(front == back) back = (front = buf) + fread(buf, 1, SIZE, stdin);
		c = front == back ? (char)EOF : *front++;
	}

public :
	template<class T>void operator () (T &x) {
		char c, f = 1;
		for(Next(c); !isdigit(c); Next(c)) if(c == '-') f = -1;
		for(x = 0; isdigit(c); Next(c)) x = x * 10 + c - '0';
		x *= f;
	}
	void operator () (char &c, char l = 'a', char r = 'z') {
		for(Next(c); c > r || c < l; Next(c)) ;
	}
}input;

const int SN = 200000 + 47;
const int LOGN = 18;
const int INF = 0x3f3f3f3f;

std::vector<int> graph[SN], tree[SN];
int low[SN], dfn[SN], rank, vis[SN], stack[SN], *top;
int f[SN][LOGN], deep[SN], dis[SN], cp, kp[SN], ckp;
int n;

void Clear();
void Tarjan(int, int);
void DFS(int);
int LCA(int, int);
int Dis(int, int);

int main() {

#ifdef Cai
	freopen("s.in", "r", stdin);
#endif

	int x, y, z, m, cases, q;

	input(cases);
	while(cases--) {
		Clear(), input(n), input(m), cp = n;
		FOR(i, 1, m) {
			input(x), input(y);
			graph[x].push_back(y);
			graph[y].push_back(x);
		}
		Tarjan(1, -1);
		deep[1] = 0, dis[1] = 0, rank = 0, DFS(1);
		input(q);
		while(q--) {
			input(ckp);
			REP(i, 0, ckp) input(kp[i]);
			std::sort(kp, kp + ckp, [](int x, int y) {return dfn[x] < dfn[y];});
			x = 0, kp[ckp] = kp[0];
			REP(i, 0, ckp) x += Dis(kp[i], kp[i + 1]);
			printf("%d\n", x / 2 - ckp + (LCA(kp[0], kp[ckp - 1]) <= n));
		}
	}

	return 0;

}

void Clear() {
	top = stack, rank = 0;
	FOR(i, 1, n) graph[i].clear();
	FOR(i, 1, cp) tree[i].clear(), dfn[i] = 0;
}

void Tarjan(int x, int y) {
	dfn[x] = low[x] = ++rank, vis[x] = 1, *++top = x;
	for(auto v : graph[x]) {
		if(v == y || dfn[v] > dfn[x]) continue;
		if(!dfn[v]) Tarjan(v, x), Chkmin(low[x], low[v]);
		else if(vis[v]) {Chkmin(low[x], dfn[v]); continue;}
		if(low[v] == dfn[x]) {
			++cp, tree[x].push_back(cp);
			while(*top != v) vis[*top] = 0, tree[cp].push_back(*top), --top;
			tree[cp].push_back(v), vis[v] = 0, --top;
		}
		else if(low[v] > dfn[x])
			tree[x].push_back(v), --top, vis[v] = 0;
	}
}

void DFS(int x) {
	dfn[x] = ++rank;
	for(auto v : tree[x]) {
		deep[v] = deep[x] + 1, dis[v] = dis[x] + (v <= n), f[v][0] = x;
		REP(i, 1, LOGN) f[v][i] = f[f[v][i - 1]][i - 1];
		DFS(v);
	}
}

int LCA(int x, int y) {
	if(deep[x] < deep[y]) std::swap(x, y);
	for(int d = deep[x] - deep[y], i = 0; i < LOGN; ++i)
		if(d >> i & 1)
			x = f[x][i];
	if(x == y) return x;
	DFR(i, LOGN - 1, 0) if(f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];
	return f[x][0];
}

int Dis(int x, int y) {
	int t = LCA(x, y);
	return dis[x] + dis[y] - 2 * dis[t];
}

```

---

## 作者：liuzhangfeiabc (赞：43)

圆方树上圆方果，

圆方树下你和我。

圆方树前建虚树，

欢乐多又多。

(/huaji)

继apio2018之后，圆方树再现江湖！

这里给不会圆方树的童鞋普及一下这种今年wc上的新(hei)科技：

先对一张无向图进行tarjan求点双。

~~什么你说你不会tarjan求点双？出门右转百度一下。~~

之后将原图中的点看做圆点，对每个点双新建一个节点看做方点。

然后重新建图：如果一个点在某个点双里，就将其对应的点连边。

可以证明最后得到的一定是一棵树（如果原图不连通就会得到森林）。

为什么是棵树呢？首先如果原图连通，如此操作后的图也一定连通（容易看出操作不会改变两点之间的连通关系）；其次如果新图上有环，就可以把它缩起来，形成一个更大的点双。

这棵树有什么性质呢？

1、树上的每一条边都连接了1个圆点和1个方点。

也就是说，每个圆点都与其所在的的点双有边相连，每个方点都与这个点双中包含的点相连。

这里补充一下：我们将“点双”定义为“将其中任意一个节点删去，剩下的部分依然连通”，这样定义的好处是对于2个点1条边的情况我们也将其视作一个点双，可以避免一些特殊情况的讨论。（据说不这么定义可能会出现圆点与圆点的连边……瑟瑟发抖）

2、对于所有的割点（定义为删去后使得图不连通的点），在图中都有至少2条出边（对应图中的割点至少在2个点双内）；而非割点只会有1条出边。

3、一条（从圆点到圆点的）树上简单路径代表什么？

代表原图中的一堆路径，其中：所有经过的割点（树上的圆点）都是必经的，而在点双内（树上的方点）可以随便走。

也就是说：原图中两点简单路径的并！

这样一来我们就可以用圆方树处理很多图上路径问题，例如只需要在方点处维护点双内所有点的信息就可以处理图上简单路径的并的相关问题。

~~这样一来我们就可以把很多树上路径问题强行上图。~~

~~以及许多序列维护区间信息的问题，原先只是上树，现在可以上图了！~~

而且这个东西的实现难度和代码复杂度并不大，~~说不定哪天变成noip基础算法呢……逃~~

回到这道题：

首先考虑删掉哪些点才能使得图上原本连通的两点变为不连通。

显然是两点的简单路径中必经的割点。

而这在圆方树上对应的就是两点路径上的圆点。

对于多个起点要求存在一对不连通的问题，因为询问点数的总数是O(n)级别，容易想到虚树。

将每次的询问点拎出来建虚树，我们会发现虚树上所有是非询问点的圆点（包括建虚树需要用到的关键点和虚树的边上经过的那些非关键点）都是合法的。

因此我们只要每次统计虚树上的点数即可。

复杂度只有建虚树的1个log。

顺便说一句我也不知道为什么网上的tarjan求点双都是将边入栈……我一直写的是点入栈也一直没出过锅……（可能有一些奇妙的处理保证了正确性？）

再以及，为了区分开树边和图边显得不那么乱，这里用的是孩子链表存树。

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<ctime>
#include<vector>
using namespace std;
#define li long long
#define gc getchar()
#define pc putchar
li read(){
	li x = 0;
	int y = 0,c = gc;
	while(!isdigit(c)){
		y = c;
		c = gc;
	}
	while(isdigit(c)){
		x = (x << 1) + (x << 3) + (c ^ '0');
		c = gc;
	}
	return y == '-' ? -x : x;
}
void print(li q){
	if(q < 0){
		pc('-');
		q = -q;
	}
	if(q >= 10) print(q / 10);
	pc(q % 10 + '0');
}
int t,n,m,p,s,a[200010],sl;
int lgb[200010];
struct edge{
	int to,nxt;
}e[500010];
int cnt,fir[100010];
inline void ins(int u,int v){
	e[++cnt].to = v;e[cnt].nxt = fir[u];fir[u] = cnt;
	e[++cnt].to = u;e[cnt].nxt = fir[v];fir[v] = cnt;
}
int st[200010],ft;
int low[100010],dfn[100010],nw,tot,dfsnw;
int fa[200010],fsts[200010],nxt[200010];
void tar(int q,int lst){//求点双
	dfn[q] = low[q] = ++nw;
	st[++ft] = q;
	for(int i = fir[q];i;i = e[i].nxt){
		int j = e[i].to;
		if(j == lst) continue;
		if(dfn[j]) low[q] = min(low[q],dfn[j]);
		else{
			tar(j,q);
			if(low[j] >= dfn[q]){
				fa[++tot] = q;
				nxt[tot] = fsts[q];
				fsts[q] = tot;//这里是孩子链表存树
				int l;
				do{
					l = st[ft--];
					fa[l] = tot;
					nxt[l] = fsts[tot];
					fsts[tot] = l;
				}while(l != j);
			}
			low[q] = min(low[q],low[j]);
		}
	}
}
//没错圆方树在求点双的过程中就顺手构建好了，所以我说难度并不大（逃）
//剩下的就是一些树上常规操作
int len[200010],dpt[200010];//这个len是根到某个点的路径上圆点的个数，用来最终计算答案
int stb[18][200010];
int dfsx[200010],wz[200010],ed[200010];
void dfs(int q){
	dfsx[++dfsnw] = q;
	wz[q] = dfsnw;
	len[q] = len[fa[q]] + (q <= n);
	for(int i = fsts[q];i;i = nxt[i]){
		dpt[i] = dpt[q] + 1;
		stb[0][i] = q;
		dfs(i);
	} 
	ed[q] = dfsnw;
}
inline bool isfa(int u,int v){
	return wz[u] < wz[v] && ed[u] >= ed[v];
}
inline void buildst(){
	register int i,j;
	for(i = 1;i <= 17;++i){
		for(j = 1;j <= n;++j) stb[i][j] = stb[i - 1][stb[i - 1][j]];
	}
}
int lca(int u,int v){
	if(dpt[u] < dpt[v]) swap(u,v);
	int i = 0,j = dpt[u] - dpt[v];
	while(j){
		if(j & 1) u = stb[i][u];
		j >>= 1;
		++i;
	}
	if(u == v) return u;
	for(i = lgb[dpt[v]];i >= 0;--i){
		if(stb[i][u] == stb[i][v]) continue;
		u = stb[i][u];
		v = stb[i][v];
	}
	return fa[u];
}
void init(){
	tot = n;
	ft = 0;
	tar(1,0);
	dfs(1);
	buildst();
}
bool cmp(int q,int w){
	return wz[q] < wz[w];
}
bool vst[200010];
int st2[200010],ft2;
int main(){
	//freopen("game.in","r",stdin);
	//freopen("game.out","w",stdout);
	int i,j,u,v,ans;
	for(i = 2;i <= 200000;++i) lgb[i] = lgb[i >> 1] + 1;
	t = read();
	while(t--){
		cnt = 0;
		memset(fir,0,sizeof(fir));
		memset(fa,0,sizeof(fa));
		memset(fsts,0,sizeof(fsts));
		memset(nxt,0,sizeof(nxt));
		memset(dfn,0,sizeof(dfn));
		memset(low,0,sizeof(low));
		memset(wz,0,sizeof(wz));
		nw = tot = dfsnw = 0;
		n = read();
		m = read();
		for(i = 1;i <= m;++i){
			u = read();
			v = read();
			ins(u,v);
		}
		init();
		p = read();
		while(p--){
			s = read();
			for(i = 1;i <= s;++i){
				a[i] = read();
				vst[a[i]] = 1;
			} 
            //以下是构建虚树的部分
			sort(a + 1,a + s + 1,cmp);
			sl = s;
			for(i = 1;i < s;++i){
				j = lca(a[i],a[i + 1]);
				if(!vst[j]){
					a[++sl] = j;
					vst[j] = 1;
				} 
			}
			sort(a + 1,a + sl + 1,cmp);
			ft2 = 0;
			ans = 0;
			st2[0] = fa[a[1]];//便于把虚树的根算进答案
			for(i = 1;i <= sl;++i){
				j = a[i];
				while(ft2 && !isfa(st2[ft2],j)) --ft2;
				u = st2[ft2];
				ans += len[j] - len[u];
				st2[++ft2] = j;
			}
			print(ans - s);//别忘了把询问点减掉
			pc('\n');
			for(i = 1;i <= sl;++i) vst[a[i]] = 0;
		}
	}
	return 0;
}
//We_cannot_live_without_our_red_sun_Claris
//2018nian5yue15riday1
```

---

## 作者：suxxsfe (赞：13)

[到我的blog中查看](https://www.cnblogs.com/suxxsfe/p/12780859.html)  

[P4606 [SDOI2018]战略游戏](https://www.luogu.com.cn/problem/P4606)：广义圆方树  
其实会了圆方树就不难，达不到黑，最多算个紫  
那个转换到圆方树上以后的处理方法，画画图就能看出来，所以做图论题一定要多画图，并把图画清楚点啊！！  

~~但我怎么从9点一直调到下午4点啊啊啊啊啊~~  
双倍经验：[P4320 道路相遇](https://www.luogu.com.cn/problem/P4320)，~~但是被卡常了并没有过~~  

给出一个无向图，和 $q$ 个询问，每次给出 $s$ 个点，问存在几个点，使得这个点和他相连的边被去除后，这 $s$ 个点中，至少存在一对点互不相通  

------------------  

先用 tarjan 对原图建立圆方树，然后可以枚举每两对给定的点，求他们的树上路径中，有几个非叶子节点的圆点（根据圆方树的性质，这就是他们之间的割点，也就是满足题目要求的点）  
这些点的并集的大小即为答案  

但这样复杂度显然过不去，而且这样描述答案不方便做转化（一开始我就是一直在这样想，导致卡了好长时间）  
所以应该给出另一种对答案的描述：在圆方树中，包含所有给出的点的联通块，最小的大小，再减去 $s$ 即为答案  
显然这和刚才那样是等价的  
~~但是还是不会算~~  

发现题目中给出的 $s$ 个点是排好序的，~~然而这并没有什么用~~，但这启示我们，不妨把给出的点按照他们在圆方树中的 dfs 序重新排序  
然后画一个图，发现，如果由 dfs 序从小到大，以此走过所有的点，然后再从第 $s$ 个点走回第 $1$ 个点  
在走过路径中，如果不考虑每相邻两个点的 LCA（此时我们走的是树上最短路径，显然会经过 LCA，这里说的不考虑就是不把它计入在内），每个点恰好被走了两次，而这些被走过的点恰好就是我们要求的联通块  
其实这里本来是有个图的，但画的太丑就没加进来，自己画一画吧  

所以我们只要为每个点赋值一个点权，方点为 $0$ 圆点为 $1$，倍增求树上路径点权和就好了  
当然，最后还要再除以二，再减去 $s$  
不过这样会有一个问题，就是第一个点和第 $s$ 个点的 LCA 会不被统计，所以如果这个点是个圆点答案就再加一  

代码  

```cpp  
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<map>
#include<iomanip>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
inline int read(){
	register int x=0;register int y=1;
	register char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return y?x:-x;
}
#define N 400007
#define M 400006
struct graph{
	int tot;
	int fir[N],nex[M],to[M];
	inline void add(int u,int v){
		to[++tot]=v;
		nex[tot]=fir[u];fir[u]=tot;
	}
	inline void clear(){
		std::memset(fir,0,sizeof fir);std::memset(to,0,sizeof to);
		std::memset(nex,0,sizeof nex);tot=0;
	}
}T,G;
int n,m;
int dfn[N],deep[N],size[N],dfscnt;
int fa[22][N],val[N],S[N];
inline int cmp(int x,int y){return dfn[x]<dfn[y];}
struct get_bcc{
	int dfn[N],low[N],stack[N],top;
	int bcccnt,dfscnt;
	void tarjan(int u){
		dfn[u]=low[u]=++dfscnt;stack[top++]=u;
		for(reg int v,i=G.fir[u];i;i=G.nex[i]){
			v=G.to[i];
			if(!dfn[v]){
				tarjan(v);
				low[u]=std::min(low[u],low[v]);
				if(low[v]>=dfn[u]){
					bcccnt++;
					do{
						T.add(bcccnt,stack[--top]);T.add(stack[top],bcccnt);
					}while(stack[top]^v);
					T.add(bcccnt,u);T.add(u,bcccnt);
				}
			}
			else low[u]=std::min(low[u],dfn[v]);
		}
	}
}BCC;
inline void clear(){
	T.clear();G.clear();
	std::memset(BCC.dfn,0,sizeof BCC.dfn);std::memset(BCC.low,0,sizeof BCC.low);
	BCC.top=0;BCC.dfscnt=0;
	dfscnt=0;
	std::memset(dfn,0,sizeof dfn);
	std::memset(fa,0,sizeof fa);std::memset(val,0,sizeof val);
	std::memset(deep,0,sizeof deep);std::memset(size,0,sizeof size);
}
void dfs(int u,int fat){
	size[u]=1;deep[u]=deep[fat]+1;
	dfn[u]=++dfscnt;fa[0][u]=fat;
	val[u]=val[fat]+(u<=n);
	for(reg int v,i=T.fir[u];i;i=T.nex[i]){
		v=T.to[i];
		if(v==fat) continue;
		dfs(v,u);size[u]+=size[v];
	}
}
inline void pre(){
	for(reg int i=1;i<=20;i++){
		for(reg int j=1;j<=BCC.bcccnt;j++) fa[i][j]=fa[i-1][fa[i-1][j]];
	}
}
inline int get(int x,int y){
	if(deep[x]<deep[y]) std::swap(x,y);
	for(reg int i=20;~i;i--)
		if(deep[fa[i][x]]>=deep[y])x=fa[i][x];
	if(x==y) return x;
	for(reg int i=20;~i;i--)
		if(fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];
	return fa[0][x];
}
int main(){int cases=read();while(cases--){
	BCC.bcccnt=n=read();m=read();
	for(reg int u,v,i=1;i<=m;i++){
		u=read();v=read();
		G.add(u,v);G.add(v,u);
	}
	BCC.tarjan(1);
	dfs(1,0);
	pre();
//	
//		EN;EN;
//		std::printf("n : %d  m : %d  bcccnt : %d\n",n,m,BCC.bcccnt);
//		for(reg int i=1;i<=BCC.bcccnt;i++){
//			std::printf("now : %d  size : %d  deep : %d  dfn : %d  val : %d\n",i,size[i],deep[i],dfn[i],val[0][i]);
//			for(reg int j=T.fir[i];j;j=T.nex[j]) std::printf("%d ",T.to[j]);
//			EN;
//		}
//	
	reg int s,ans,lca;
	int q=read();while(q--){
 		s=read();ans=0;
		for(reg int i=1;i<=s;i++) S[i]=read();
		std::sort(S+1,S+1+s,cmp);S[s+1]=S[1];
		for(reg int i=1;i<=s;i++){
			lca=get(S[i],S[i+1]);
			ans+=val[S[i]]+val[S[i+1]]-val[lca]*2;
		}
		ans>>=1;ans-=s;
		ans+=(get(S[1],S[s])<=n);
		std::printf("%d\n",ans);
	}
	if(cases) clear();
}
	return 0;
}
```

---

## 作者：kouylan (赞：6)

题目要求摧毁一个点使得两个关键点不连通，显然摧毁的点只能是割点。所以我们先求出割点并且建立出原图的圆方树。

那么圆方树是什么呢？我们把原图的每个点看作圆点，给每个点双（BCC）新建一个方点，然后让每个圆点向对应的点双方点建边。显然，新图的边只会连接圆点和方点，所以是一棵树。并且只有割点会同时连向若干个方点，因为只有割点同时属于多个点双。

现在我们考虑哪些点可以摧毁。对于一个点 $x$，如果它可以摧毁，只可能是它的子树和外子树都有关键点（一类），或者它的多个子节点的子树内都有关键点（二类），并且它需要是割点。

这样我们可以先预处理出一个 $sum$ 数组，$sum_x$ 表示从树根到 $x$ 节点之间割点的个数，是一个前缀和。

然后每组询问建出虚树，$siz_x$ 表示 $x$ 子树内关键点个数。首先考虑一类，如果 $siz_x>0$ 并且 $m-siz_x>0$，也就是内外子树都存在关键点，那么 $x$ 到 $pre$ 之间的割点都可以被摧毁，产生的贡献就是 $sum_x-sum_{pre}$，当然，如果 $x$ 也是关键点，贡献要减去一。接下来考虑二类，我们可以记录一个 $cnt$，表示有多少棵子节点的子树内有关键点。如果 $cnt>2$ 就说明可以摧毁 $x$ 点，但依然要判断 $x$ 不是关键点并且 $x$ 是割点。

下面是 AC 代码。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int INF = 0x7f7f7f7f;

int Q,n,m,q,ans=0,a[200005],ls[200005];
int ee,h[200005],nex[200005<<1],to[200005<<1];
int low[200005],bcc,cut[200005];
int dep[200005],fa[200005][20],dfn[200005],sum[200005];
int top,sk[200005],siz[200005];
vector<int> c[200005];

void addedge(int x,int y)
{
	nex[++ee] = h[x], to[ee] = y, h[x] = ee;
}

void tarjin(int x,int fa)
{
	int ch=0;
	dfn[x] = low[x] = ++dfn[0];
	for(int i=h[x];i;i=nex[i])
	{
		if(dfn[to[i]]==0)
		{
			sk[++top] = to[i];
			tarjin(to[i],x);
			low[x] = min(low[x],low[to[i]]);
			if(x==fa)
				ch++;
			else if(low[to[i]]>=dfn[x])
				cut[x] = 1;
			if(low[to[i]]>=dfn[x])
			{
				bcc++;
				while(sk[top]!=to[i])
					c[bcc].push_back(sk[top]), top--;
				c[bcc].push_back(sk[top]), top--;
				c[bcc].push_back(x);
			}
		}
		else if(to[i]!=fa)
			low[x] = min(low[x],dfn[to[i]]);
	}
	if(x==fa && ch>=2)
		cut[x] = 1;
}

void dfs0(int x,int pre)
{
	dep[x] = dep[pre]+1, fa[x][0] = pre, dfn[x] = ++dfn[0], sum[x] = sum[pre]+cut[x];
	for(int j=1;j<20;j++)
		fa[x][j] = fa[fa[x][j-1]][j-1];
	for(int i=h[x];i;i=nex[i])
		if(to[i]!=pre)
			dfs0(to[i],x);
}

int lca(int x,int y)
{
	if(dep[x]<dep[y]) swap(x,y);
	while(dep[x]>dep[y])
		x = fa[x][(int)log2(dep[x]-dep[y])];
	if(x==y)
		return y;
	for(int k=19;k>=0;k--)
		if(fa[x][k]!=fa[y][k])
			x = fa[x][k], y = fa[y][k];
	return fa[x][0];
}

bool cmp(int x,int y)
{
	return dfn[x]<dfn[y];
}

void build()
{
	ee = top = 0;
	sort(ls+1,ls+1+m,cmp);
	if(ls[1]!=1) sk[++top] = 1;
	for(int i=1;i<=m;i++)
	{
		if(top==0)
		{
			sk[++top] = ls[i];
			continue;
		}
		int z=lca(sk[top],ls[i]);
		while(top>1 && dep[z]<dep[sk[top-1]])
			addedge(sk[top],sk[top-1]), addedge(sk[top-1],sk[top]), top--;
		if(dep[z]<dep[sk[top]])
			addedge(sk[top],z), addedge(z,sk[top]), top--;
		if(top==0 || sk[top]!=z)
			sk[++top] = z;
		sk[++top] = ls[i];
	}
	while(--top)
		addedge(sk[top],sk[top+1]), addedge(sk[top+1],sk[top]);
}

void dfs1(int x,int pre)
{
	siz[x] = a[x];
	for(int i=h[x];i;i=nex[i])
		if(to[i]!=pre)
			dfs1(to[i],x), siz[x] += siz[to[i]];
}

void dfs(int x,int pre)
{
	int cnt=0;
	if(a[x]==1)
		siz[x] = 1;
	else
		siz[x] = 0;
	for(int i=h[x];i;i=nex[i])
		if(to[i]!=pre)
		{
			dfs(to[i],x);
			if(siz[to[i]]>0)
				cnt++;
			siz[x] += siz[to[i]];
		}
	if(m-siz[x]>=1)
	{
		if(!a[x])
			ans += sum[x]-sum[pre];
		else
			ans += max(sum[fa[x][0]]-sum[pre],0ll);
	}
	else if(cnt>=2 && !a[x])
		ans += (x<=n);
	a[x] = h[x] = 0;
}

signed main()
{
	cin>>Q;
	while(Q--)
	{
		memset(h,0,sizeof(h)), ee = 0;
		memset(dfn,0,sizeof(dfn)), memset(cut,0,sizeof(cut));
		for(int i=1;i<=bcc;i++)
			c[i].clear();
		bcc = 0;
		memset(sum,0,sizeof(sum));
		cin>>n>>m;
		for(int i=1,x,y;i<=m&&scanf("%lld%lld",&x,&y);i++)
			addedge(x,y), addedge(y,x);
		for(int i=1;i<=n;i++)
			if(dfn[i]==0)
				tarjin(1,1);
		ee = 0, memset(h,0,sizeof(h));
		for(int i=1;i<=bcc;i++)
			for(int j=0;j<c[i].size();j++)
				addedge(c[i][j],i+n), addedge(i+n,c[i][j]);
		memset(dfn,0,sizeof(dfn));
		dfs0(1,0);
		ee = 0, memset(h,0,sizeof(h));
		cin>>q;
		while(q--)
		{
			scanf("%lld",&m);
			for(int i=1;i<=m&&scanf("%lld",ls+i);i++)
				a[ls[i]]++;
			build();
			ans = 0;
			dfs(1,0);
			printf("%lld\n",ans);
		}
	}
	
	return 0;
}
```

祝大家 AC 愉快！

---

## 作者：issue_is_fw (赞：5)

$这道题画个图,发现和圆方树关系很大!!$

$比如u和v在圆方树上的路径经过几个圆点,那些圆点就符合要求!!$

$解释:经过的圆点连接着两个方点,分别属于u的点双和v的点双$

$去掉这个点,u和v分割开来$

$所以现在就是求给定的s集合任意两点路径经过的圆点个数(不重复)$

**但是会超时**

**考虑优化**

$我们发现要求的就是s集合的最小连通子图中的圆点啊!!$

$那怎么求?$

$想象一下dfs的过程,搜索某棵子树,然后原路返回,在搜索另一颗子树...$

也就是按照$dfs$序给$s$集合排序

我们只需要计算相邻两点的路径上的圆点即可!!(当然这样每条边相当于走了两次)

最后除以$2$减去$s$中集合的个数即可

$s$集合首尾元素也要计算路径上的贡献,但是贡献是点,不好统计

我们把每个圆点的贡献放在它和父亲的边上去(贡献为$1$)

这样我们可以很方便的用$lca$来求树上两点的距离!!

最后,还有一个细节,如果$s$集合首尾元素的$lca$是圆点

那么这个点的贡献没有算进去(不在连通子图里,在外边的边了)

需要额外加上去

```
#include <bits/stdc++.h>
using namespace std;
const int maxn=2e6+10;
int t,n,m,f,q;
vector<int>vec[maxn];
struct edge{ int to,nxt; }d[maxn];
int head[maxn],cnt=1;
void add(int u,int v){	d[++cnt]=(edge){v,head[u]},head[u]=cnt; }
void ins(int u,int v){ vec[u].push_back(v); }
int low[maxn],dfn[maxn],stac[maxn],iid,top;
void tarjan(int u)
{
	low[u]=dfn[u]=++iid,stac[++top]=u;
	for(int i=head[u];i;i=d[i].nxt )
	{
		int v=d[i].to;
		if( !dfn[v] )
		{
			tarjan(v),low[u]=min(low[u],low[v]);
			if( low[v]>=dfn[u] )
			{
				++f;//发现割点
				while( 1 )
				{
					ins(f,stac[top]); ins(stac[top],f);
					if( stac[top--]==v )	break;	
				} 
				ins(f,u); ins(u,f);
			}
		}
		else	low[u]=min( low[u],dfn[v] );
	}
}
int id[maxn],fa[maxn][22],dis[maxn],num,deep[maxn],s[maxn];
void dfs(int u,int father)
{
	id[u]=++num,deep[u]=deep[father]+1;
	fa[u][0]=father, dis[u]=dis[father]+( u<=n );
	for(int i=1;i<=20;i++)
		fa[u][i]=fa[ fa[u][i-1] ][i-1];
	for(int i=0;i<vec[u].size();i++)
		if( vec[u][i]!=father )	dfs( vec[u][i],u );
}
int lca(int x,int y)
{
	if( deep[x]<deep[y] )	swap(x,y);
//	for(int i=log(deep[x]);i>=0;i--)
//		if( deep[fa[x][i]]>=deep[y] )	x=fa[x][i];
	for(int j=0,d=deep[x]-deep[y];d;j++,d>>=1)
		if( d&1 )	x=fa[x][j];
	if( x==y )	return x;
	for(int i=18;i>=0;i--)
		if( fa[x][i]!=fa[y][i] )
			x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
bool com(int a,int b){	return id[a]<id[b]; }
void init()
{
	iid=0,num=0,cnt=1,top=0;
	for(int i=1;i<=f;i++)
	{
		vec[i].clear(),head[i]=0;
		dfn[i]=low[i]=0;
		id[i]=dis[i]=deep[i]=0;
		for(int j=0;j<=20;j++)	fa[i][j]=0;
	}
}
int main()
{
	ios::sync_with_stdio(false);
//	cin.tie(0),cout.tie(0);
	cin >> t;
	while( t-- )
	{
		cin >> n >> m;
		f=n;
		for(int i=1;i<=m;i++)
		{
			int l,r; cin >> l >> r;
			add(l,r); add(r,l);
		}
		tarjan(1),top--;
		dfs(1,0);
		cin >> q;
		while( q-- )
		{
			int shu,ans=0; cin >> shu;
			ans=-2*shu;
			for(int i=1;i<=shu;i++)	cin >> s[i];
			sort(s+1,s+1+shu,com);
			for(int i=1;i<shu;i++)
			{
				int u=s[i],v=s[i+1];
				ans+=dis[u]+dis[v]-2*dis[lca(u,v)];
			}
			ans+=dis[s[1]]+dis[s[shu]]-2*dis[lca(s[1],s[shu])];
			if( lca(s[1],s[shu])<=n )	ans+=2;
			cout << ans/2 << '\n';
		}
		init();
	}
}
```

---

## 作者：dsidsi (赞：4)

# Description

有一张无向图，每次给定一个集合$S$，求有多少个点满足删除这个点后，$S$中至少有两个点不连通。

$n \leq 10^5$，$m,\sum |S| \leq 2\times 10^5$

# Solution

考虑所求就是$S$在圆方树上虚树的圆点数-$|S|$。

但实际并不需要把虚树求出来，考虑把一个圆点的权值放在它到父亲方点的边上，那么把$S$按$dfs$序排序后，答案为

$$\frac{dis(S_1,S_2)+dis(S_2,S_3)+...+dis(S_{n-1},S_n)+dis(S_n,S_1)}{2}-|S|$$

这个可以画图感受一下。

注意当虚树上最浅点为圆点时，要加上它的权值。

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int gi()
{
	char c = getchar();
	while(c < '0' || c > '9') c = getchar();
	int sum = 0;
	while('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();
	return sum;
}

const int maxn = 100005;

int n, m, s[maxn];

struct edge
{
	int to, next;
} e[maxn << 2];
int h[maxn << 1], tot, cnt;

inline void add(int u, int v)
{
	e[++tot] = (edge) {v, h[u]}; h[u] = tot;
	e[++tot] = (edge) {u, h[v]}; h[v] = tot;
}

namespace Tarjan
{

	struct edge
	{
		int to, next;
	} e[maxn << 2];
	int h[maxn], tot;
	
	inline void Add(int u, int v)
	{
		e[++tot] = (edge) {v, h[u]}; h[u] = tot;
		e[++tot] = (edge) {u, h[v]}; h[v] = tot;
	}

	int dfn[maxn], low[maxn], Time, stk[maxn], top;

	void dfs(int u)
	{
		dfn[u] = low[u] = ++Time;
		stk[++top] = u;
		for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
			if (!dfn[v]) {
				dfs(v);
				low[u] = min(low[u], low[v]);
				if (dfn[u] == low[v]) {
					++cnt;
					while (stk[top + 1] != v)
						add(stk[top], cnt), --top;
					add(cnt, u);
				}
			} else low[u] = min(low[u], dfn[v]);
	}
	
}

int fa[maxn << 1], dep[maxn << 1], dis[maxn << 1], siz[maxn << 1], son[maxn << 1], top[maxn << 1], dfn[maxn << 1], low[maxn << 1], Time;
int vis[maxn << 1];

void dfs1(int u)
{
	vis[u] = 1;
	dep[u] = dep[fa[u]] + 1; dis[u] = dis[fa[u]] + (u <= n); siz[u] = 1; son[u] = 0;
	for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
		if (v != fa[u]) {
			if (vis[v]) 
				puts("call me"), exit(0);
			fa[v] = u; dfs1(v); siz[u] += siz[v];
			if (siz[v] > siz[son[u]]) son[u] = v;
		}
}

void dfs2(int u)
{
	dfn[u] = ++Time;
	if (son[u]) top[son[u]] = top[u], dfs2(son[u]);
	for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
		if (v != son[u] && v != fa[u]) top[v] = v, dfs2(v);
	low[u] = Time;
}

inline int lca(int u, int v)
{
	while (top[u] != top[v]) {
		if (dep[top[u]] > dep[top[v]]) u = fa[top[u]];
		else v = fa[top[v]];
	}
	return dep[u] < dep[v] ? u : v;
}

int main()
{
	int T = gi();
	
	while (T--) {
		n = gi(); m = gi();
		fill(h + 1, h + cnt + 1, 0); tot = 0;
		fill(Tarjan::h + 1, Tarjan::h + n + 1, 0); Tarjan::tot = 0;
		fill(Tarjan::dfn + 1, Tarjan::dfn + n + 1, 0);
		for (int i = 1; i <= m; ++i) Tarjan::Add(gi(), gi());

		cnt = n; Tarjan::Time = 0; 
		Tarjan::dfs(1); --Tarjan::top;

		memset(vis + 1, 0, sizeof(vis));
		dfs1(1);
		Time = 0; top[1] = 1; dfs2(1);
		
		int q = gi(), k;
		while (q--) {
			k = gi();
			for (int i = 1; i <= k; ++i) s[i] = gi();
			sort(s + 1, s + k + 1, [](const int &a, const int &b) {return dfn[a] < dfn[b];});
			int ans = -2 * k;
			for (int i = 1; i < k; ++i) ans += dis[s[i]] + dis[s[i + 1]] - (dis[lca(s[i], s[i + 1])] << 1);
			ans += dis[s[k]] + dis[s[1]] - (dis[lca(s[k], s[1])] << 1);
			if (lca(s[1], s[k]) <= n) ans += 2;
			printf("%d\n", ans >> 1);
		}
	}
	
	return 0;
}
```

---

## 作者：青鸟_Blue_Bird (赞：3)

[题目戳这](https://www.luogu.com.cn/problem/P4606)

这道题，已经近乎于圆方树和树上倍增处理点权和+LCA的板子了。

对于不懂圆方树基本定义的小伙伴，建议去看[小粉兔的博客](https://www.baidu.com/link?url=DM6KPXibnMEFiYEzNGJws2t2B3XwiLIxjpOYMak3DDr9bdXHCL3TnsLFJo62Bkm-jWX4QEQxRNXAhASEVK6zdq&wd=&eqid=80dbfe15000916f1000000065edb3f70)~~（我也是看这个博客学的圆方树）~~


对于这道题， 我们如何才能使得两个点变得不连通呢？  
### 当然是干掉我们路径上必须经过的点，Which is called 割点

而这里也就要利用到我们圆方树的性质。  这些割点就是我们圆方树上的圆点。

于是，我们轻松的想到一个办法： 直接找出所有的圆点不就好了？
然鹅，我们的时间复杂度这样是过不去的。

那么，如何快速求出所有圆点呢？ 不妨换一种思路。
对于一个圆方树，如果我们能找到其包含所有点的连通块（当然是最小的，类似于最小生成树的东西），然后将其减掉s，就是我们的圆点的数量。~~（请自行画图手摸）~~

如果我们将所有的点按照dfs序排序（即dfn），然后依次遍历（请自行画图），发现我们将会得到一个联通图。这不就是我们要找的吗！！

那么，如何统计其大小呢?  也很简单。令 val[方点] = 0, val[圆点] = 0,然后倍增求路径点权和即可。

### 友情tips:
不要忘了，LCA会被多次经过，要记得减掉。1号点和s号点的LCA不会被统计到，记得特判其圆点方点，然后加上。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 1000010
#define isdigit(c) ((c)>='0'&&(c)<='9')
#define I_WANT_TO_AK_IOI 0

int read(){
	int x = 0, s = 1;
	char c = getchar();
	while(!isdigit(c)){
		if(c == '-')s = -1;
		c = getchar();
	}
	while(isdigit(c)){
		x = (x << 1) + (x << 3) + (c ^ '0');
		c = getchar();
	}
	return x * s;
}

struct tu{  /*  “图 ” */
	int v, next;
};
int n, m;

struct node{
	tu t[N << 1];
	int f[N << 1];
	int bian;
	
	inline void add(int u, int v){  /*双向边*/ 
		t[++bian] = (tu){v, f[u]}, f[u] = bian;
		t[++bian] = (tu){u, f[v]}, f[v] = bian;
		return ;
	}
	/*  调试错误 
	void out(){
	 	this-> bian; 
		printf("%d\n", bian);
		return ;
	}*/
	void clean(){
		bian = 0;
		memset(f, 0, sizeof(f));
		for(int i = 1;i <= (N << 1); i++)
			t[i] = (tu){0, 0};
		return ;
	}
}G, T;


struct bcc{
	int dfn[N << 1], low[N], stac[N], top;
	int bcccnt, id;
	
	void tarjan(int now){    /*求圆方树*/
		dfn[now] = low[now] = ++id;
		stac[top++] = now;
		for(int i = G.f[now]; i; i = G.t[i].next){
			int v = G.t[i].v;
			if(!dfn[v]){
				tarjan(v);
				low[now] = min(low[now], low[v]);
				if(dfn[now] <= low[v]){
					bcccnt++;
					do{
						T.add(bcccnt, stac[--top]);
					} while(stac[top] != v);  
					T.add(bcccnt, now);  /*圆方树建图*/
				}
			}
			else low[now] = min(low[now], dfn[v]);
		}
		return ;
	}
	
	inline void clean(){
		id = 0;
		top = 0;
		bcccnt = 0;
		memset(dfn, 0, sizeof(dfn));
		memset(low, 0, sizeof(low));
		return ;
	}
} BCC;

namespace LCA{
	int size[N << 1], deth[N << 1], dfn[N << 1], fa[N << 1][22], id = 0;
	int val[N], siz[N];
	void dfs(int now,int father){
		size[now] = 1;
		deth[now] = deth[father] + 1; 
		dfn[now] = ++id;
		fa[now][0] = father;
		val[now] = val[father] + (now <= n);
		for(int i = T.f[now]; i; i = T.t[i].next){
			int v = T.t[i].v;
			if(v != father){
				dfs(v, now);
				siz[now] += siz[v];
			}
		}
		return ;
	}

	void prepare(){  /*倍增预处理*/
		for(int j = 1;j <= 20; j++)
			for(int i = 1;i <= BCC.bcccnt; i++)
				fa[i][j] = fa[fa[i][j-1]][j-1];
		return ;
	}

	int get_lca(int x, int y){  /*倍增求LCA*/
		if(deth[x] < deth[y]) swap(x, y);
		for(int i = 20; ~i; i--){
			if(deth[fa[x][i]] >= deth[y]) x = fa[x][i];
		}
		if(x == y) return x;
		for(int i = 20; ~i; i--){
			if(fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];
		}
		return fa[x][0];
	}
	
	inline bool cmp(int x, int y){
		return dfn[x] < dfn[y];
	}
	
	inline void clean(){
		id = 0;
		memset(dfn, 0, sizeof (dfn));
		memset(fa, 0, sizeof(fa));
		memset(val,0, sizeof (val));
		memset(deth, 0, sizeof(deth));
		memset(size, 0, sizeof(size));
		return ;
	}
	
}


inline void clean(){
	BCC.clean();
	T.clean();
	G.clean();
	LCA::clean();
	return ;
}
int a[N];


int main(){
//	freopen("hh.txt", "r", stdin);
	int test = read();
	while(test--){
		n = read(), m = read();
		for(int i = 1;i <= m; i++){
			int x = read(), y = read();
			G.add(x, y);  /*先建原图*/ 
		}
		BCC.bcccnt = n;
		BCC.tarjan(1);  /*建立圆方树*/ 
		LCA::dfs(1, 0);
		LCA::prepare(); /*处理倍增和路径点权和*/ 
		int q = read();
		while(q--){
			int s = read(), ans = 0;
			for(int i = 1;i <= s; i++) a[i] = read();
			sort(a + 1, a + s + 1, LCA::cmp);  /*按照dfn排序*/ 
			a[s + 1] = a[1];
			for(int i = 1;i <= s; i++){
				int lca = LCA::get_lca(a[i], a[i + 1]);
				ans += LCA::val[a[i]] + LCA::val[a[i + 1]] - (LCA::val[lca] << 1);
			}
			ans >>= 1;
			ans -= s;
			ans += (LCA::get_lca(a[1], a[s]) <= n);
			printf("%d\n", ans);
		}
		clean();  /*不要忘了清空呀*/
	}
	return I_WANT_TO_AK_IOI;
}
```

#### 代码一定要模块化啊，不然容易写崩
~~(虽然我模块化了也写崩）~~

---

## 作者：orz_z (赞：2)

# 圆方树的定义

圆方树是用来解决仙人掌图的问题的，那什么是仙人掌图呢？

即不存在边同时属于多个环的无向连通图是一棵仙人掌。

## 点双连通分量的定义
要介绍圆方树，首先要介绍点双连通分量。

一个点双连通图的一个定义是：图中任意两不同点之间都有至少两条点不重复的路径。

一种简单的定义：不存在割点的图。

但这种定义对于两点一边的图时是没用的，它没有割点，但是并不能找到两条不相交的路径，因为只有一条路径。（也可以理解为那一条路径可以算两次，但的确没有相交，因为不经过其他点）。

在点双连通图内，一个点可能属于多个点双，但是一条边属于恰好一个点双。

更多关于有向图的强连通分量的知识，请看我的博客 $\to$ [强连通分量](https://www.cnblogs.com/orzz/p/15104647.html)

更多关于点双连通分量的知识，请看我的博客 $\to$ [双连通分量](https://www.cnblogs.com/orzz/p/15114866.html)

## 继续介绍圆方树

关于圆方树的建图，也比较简单，将一个点双连通分量内的所有边删去，再将一个点双连通分量中的每个点向一个新建的点连边，这个新建的点即是方点。

所以在圆方树中有 $n+c$ 个点，其中 $n$ 是原图点数，$c$ 是原图点双连通分量的个数。

每个点双都可以形成一个菊花图，多个菊花图通过原图中的割点连接在一起（因为点双的分隔点是割点）。

显然，圆方树中每条边连接一个圆点和一个方点。

在下面这张图中，$[1,2,3,4,5]$ 是圆点，$[6,7]$ 是方点。

![](https://img-blog.csdnimg.cn/img_convert/a64ea1977df8894a39bf10c1ae9b80ab.png)

而如果圆方树连通，则有以下性质：

* 方点之间不会存在连边。

* 原图的割点就是圆方树中度数大于 $1$ 的圆点。

* 圆方数是一棵非常好的树，即点数等于边数加 $1$。
  
* 圆方树上任意一条路径上圆点方点间隔分布。

* 如果圆点的 $size$ 为 $1$，那么一个圆点子树的 $size$ 和就是它下面的所有点的数量。

* 对于一个点双中的两点，它们之间简单路径的并集，恰好完全等于这个点双，即同一个点双中的两不同点 $u$，$v$ 之间一定存在一条简单路径经过给定的在同一个点双内的另一点 $w$。也就是说，考虑两圆点在圆方树上的路径，与路径上经过的方点相邻的圆点的集合，就等于原图中两点简单路径上的点集。

如果原图中某个连通分量只有一个点，则需要具体情况具体分析，我们在后续讨论中不考虑孤立点。

注意一条边连接两个点的在这里不算点双。

## 广义圆方树

普通圆方树只能解决仙人掌图上的问题，而广义圆方树则可以将所有无向图转化为圆方树处理。

广义圆方树性质：圆点方点相间，不存在两个‘’相同形状‘’的点相连。

与圆方树不同的是，广义圆方树需要把一条边连接两个点也看成一个点双，原本两个圆点有一条边相连，现在在中间插入一个方点间隔开就好了。

可以参照这张图

![](https://img-blog.csdnimg.cn/img_convert/51b720e058f7a5dc7dc77c9eb881274f.png)

# 圆方树的应用

[洛谷 P4606 [SDOI2018]战略游戏](https://www.luogu.com.cn/problem/P4606)

### 题目大意
给出一个无向图，和 $q$ 个询问，每次给出 $s$ 个点，问存在几个点，使得这个点和他相连的边被去除后，这 $s$ 个点中，至少存在一对点互不相通。
### 解题思路

首先考虑删掉哪些点才能使得图上原本连通的两点变为不连通。

显然删掉两点的简单路径中必经的割点可以使得图上原本连通的两点变为不连通。

而这在圆方树上对应的就是两点路径上的圆点。

于是，我们轻松的想到一个办法： 直接找出所有的圆点不就好了？ 

然而，我们的时间复杂度是过不去的。

那么，如何快速求出所有圆点呢？ 不妨换一种思路。 对于一个圆方树，如果我们能找到其包含所有点的最小的连通块，然后将其减掉 $s$，就是我们的圆点的数量。

例如这张图：

![](https://img-blog.csdnimg.cn/a963aeba1770432391713f52acdc43f1.png)

假设给出的 $s$ 个点分别为：$4、5、6、7$。

则建完圆方树就变成这样：

![](https://img-blog.csdnimg.cn/3645e2b68fa14a4da372465e038e1de1.png)

图中没加深的点就是圆方树中的方点。

易得，使用 `Tarjan` 算法建出圆方树，然后答案就是圆方树上包含所有关键点的最少点数联通块的圆点数量减去关键点的数量。

为了方便，我们设圆点的权值设为 $1$ ，方点的权值为 $0$ ，将点权放到这个点与其父节点的边上。

然后画一个图，发现，如果由 `dfs` 序从小到大，以此走过所有的点，然后再从第 $s$ 个点走回第 $1$ 个点。

在走过路径中，如果不考虑每相邻两个点的 `LCA`（此时我们走的是树上最短路径，显然会经过 `LCA`，这里说的不考虑就是不把它计入在内），每个点恰好被走了两次，而这些被走过的点恰好就是我们要求的联通块。

不过这样会有一个问题，就是第一个点和第 $s$ 个点的 `LCA` 会不被统计，所以如果这个点是个圆点答案就再加 $1$。

### AC CODE

```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 100005;

int n, m, q, cnt;
vector<int> G[_], T[_ * 2];

int dfn[_ * 2], low[_], cnt_node;

stack<int> s;

void Tarjan(int u)
{
    low[u] = dfn[u] = ++cnt_node;
    s.push(u);
    for (auto v : G[u])
    {
        if (!dfn[v])
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
            if (low[v] == dfn[u])
            {
                ++cnt;
                while (1)
                {
                    int x = s.top();
                    s.pop();
                    T[cnt].push_back(x);
                    T[x].push_back(cnt);
                    // cout << cnt << " " << x << endl;
                    if (x == v)
                        break;
                }
                T[cnt].push_back(u);
                T[u].push_back(cnt);
                // cout << cnt << " " << u << endl;
            }
        }
        else
            low[u] = min(low[u], dfn[v]);
    }
}

int dep[_ * 2], fa[_ * 2][18], dis[_ * 2];

void dfs(int u, int fz)
{
    dfn[u] = ++cnt_node;
    dep[u] = dep[fa[u][0] = fz] + 1;
    dis[u] = dis[fz] + (u <= n);
    for (int j = 0; j < 17; ++j)
        fa[u][j + 1] = fa[fa[u][j]][j];
    for (auto v : T[u])
        if (v != fz)
            dfs(v, u);
}

int LCA(int x, int y)
{
    if (dep[x] < dep[y])
        swap(x, y);
    for (int j = 0, d = dep[x] - dep[y]; d; ++j, d >>= 1)
        if (d & 1)
            x = fa[x][j];
    if (x == y)
        return x;
    for (int j = 17; ~j; --j)
        if (fa[x][j] != fa[y][j])
            x = fa[x][j], y = fa[y][j];
    return fa[x][0];
}

int main()
{
    int TT;
    scanf("%d", &TT);
    while (TT--)
    {
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= n; ++i)
        {
            G[i].clear();
            dfn[i] = low[i] = 0;
        }
        for (int i = 1; i <= n * 2; ++i)
            T[i].clear();
        for (int i = 1, x, y; i <= m; ++i)
        {
            scanf("%d%d", &x, &y);
            G[x].push_back(y);
            G[y].push_back(x);
        }
        cnt = n;
        cnt_node = 0;
        Tarjan(1);
        cnt_node = 0;
        dfs(1, 0);
        scanf("%d", &q);
        while (q--)
        {
            int S, A[_];
            scanf("%d", &S);
            int Ans = -2 * S;
            for (int i = 1; i <= S; ++i)
                scanf("%d", &A[i]);
            sort(A + 1, A + S + 1, [](int i, int j)
                 { return dfn[i] < dfn[j]; });
            for (int i = 1; i <= S; ++i)
            {
                int u = A[i], v = A[i % S + 1];
                Ans += dis[u] + dis[v] - 2 * dis[LCA(u, v)];
            }
            if (LCA(A[1], A[S]) <= n)
                Ans += 2;
            printf("%d\n", Ans / 2);
        }
    }
    return 0;
}
```

---

## 作者：GoldenPotato137 (赞：2)

[戳我获得更好的阅读体验qwq](https://www.goldenpotato.cn/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/luogu-p4606-sdoi2018%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F/)

---
# Solution
> 圆方树上圆方果，  
  圆方树下你和我。  
  圆方树前建虚树，   
  欢乐多又多。  
  
[![A5PwBd.th.png](https://s2.ax1x.com/2019/04/08/A5PwBd.th.png)](https://imgchr.com/i/A5PwBd)

.

好吧，我们来说正题。  
这题就比较强。~~根据常识~~，如果我们爆掉的点能影响这个图的连通性，**那么，这个点一定是割点**。  
因此，我们要先对原图做**Tarjan求点双**。接下来，我们考虑用圆方树来解决一个问题。

我们先考虑暴力怎么做，我们先对原图求出圆方树。接下来，我们发现，**对答案有贡献的点一定是孩子有被选定的点的圆点，并且这个点的总共被选定的孩子数不等于总共被选定数**（因为如果这个点被割掉了，其被选定的孩子一定会与其他点断开来，且方点代表一个点双，并不能割）。  
因此，我们可以直接统计一下有多少个有贡献的点即可。  


接下来，我们进一步观察数据，发现$\sum S$非常小，因此考虑用虚树来解决这个问题  

我们对每个询问的点构建虚树。这时候，我们就要多计算边的贡献，考虑一条边的贡献，即为这条边上有多少个原点，随便转移一下就好了。~~好个鬼啊，细节比较多，大家注意一下~~  

时间复杂度$O(\sum S \cdot log n)$  
就酱，这题就被我们切掉啦ヾ(●´∀｀●) 

---
# Code
```cpp
//Luogu P4606 [SDOI2018]战略游戏
//Apr,8th,2019
//圆方树+虚树
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=2*100000+100;
vector <int> e[N],e2[N],e3[N];
int n,m,q;
int low[N],cnt,dfn_to,dfn[N],mstack[N],top;
bool vis[N];
void Tarjan(int now,int father)
{
	vis[now]=true;
	dfn[now]=low[now]=++dfn_to;
	mstack[++top]=now;
	for(int i=0;i<int(e[now].size());i++)
		if(vis[e[now][i]]==false)
		{
			Tarjan(e[now][i],now);
			low[now]=min(low[now],low[e[now][i]]);
			if(low[e[now][i]]>=dfn[now])
			{
				e2[now].push_back(n+(++cnt));
				while(mstack[top+1]!=e[now][i])
					e2[n+cnt].push_back(mstack[top--]);
			}
		}
		else if(e[now][i]!=father)
			low[now]=min(low[now],dfn[e[now][i]]);
}
int fa[N][21],depth[N],pre[N];
void dfs(int now,int father)
{
	fa[now][0]=father,depth[now]=depth[father]+1;
	dfn[now]=++dfn_to;
	pre[now]=pre[father]+(now<=n);
	for(int i=1;i<=20;i++)
		fa[now][i]=fa[fa[now][i-1]][i-1];
	for(int i=0;i<int(e2[now].size());i++)
		if(e2[now][i]!=father)
				dfs(e2[now][i],now);
}
int LCA(int x,int y)
{
	if(depth[x]<depth[y]) swap(x,y);
	for(int i=20;i>=0;i--)
		if(depth[x]-(1<<i) >= depth[y])
			x=fa[x][i];
	if(x==y) return x;
	for(int i=20;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
bool cmp(int x,int y)
{
	return dfn[x]<dfn[y];
}
bool sp[N];
int f[N];
int GetSum(int x,int y) //(x,y)
{
	return pre[y]-pre[x]-(y<=n);
}
int dfs2(int now)
{
	f[now]=0;
	for(int i=0;i<int(e3[now].size());i++)
		f[now]+=dfs2(e3[now][i])+GetSum(now,e3[now][i]);
	if(sp[now]==false and now<=n and (now!=1 or e3[now].size()!=1))
		f[now]++;
	if(now==1 and e3[now].size()==1 and sp[now]==false)
		f[now]-=GetSum(now,e3[now][0]);
	return f[now];
}
int main()
{
	freopen("4606.in","r",stdin);
	freopen("4606.out","w",stdout);
	
	int T=read();
	
	for(;T>0;T--)
	{
		n=read(),m=read();
		
		for(int i=1;i<=2*n;i++)
			e[i].clear(),e2[i].clear(),e3[i].clear();
		memset(vis,0,sizeof vis);
		dfn_to=0;
		
		for(int i=1;i<=m;i++)
		{
			int s=read(),t=read();
			e[s].push_back(t);
			e[t].push_back(s);
		}
		
		Tarjan(1,1);
		dfn_to=0;
		dfs(1,1);
		
		q=read();
		static int a[N],rec[N];
		for(int i=1;i<=q;i++)
		{
			m=read();
			for(int j=1;j<=m;j++)
				a[j]=read();
			
			sort(a+1,a+1+m,cmp);
			mstack[top=1]=1,cnt=0;
			for(int j=(a[1]==1?2:1);j<=m;j++)
			{
				while(LCA(mstack[top],a[j])!=mstack[top])
				{
					int lca=LCA(mstack[top],a[j]);
					if(depth[lca] > depth[mstack[top-1]])
					{
						e3[lca].push_back(mstack[top]);
						rec[++cnt]=mstack[top],mstack[top]=lca;
					}
					else
					{
						e3[mstack[top-1]].push_back(mstack[top]);
						rec[++cnt]=mstack[top--];
					}
				}
				mstack[++top]=a[j];
			}
			while(top>1)
			{
				e3[mstack[top-1]].push_back(mstack[top]);
				rec[++cnt]=mstack[top--];
			}
			rec[++cnt]=1;
			
			for(int i=1;i<=m;i++)
				sp[a[i]]=true;

			printf("%d\n",dfs2(1));
		
			for(int i=1;i<=cnt;i++)
				sp[rec[i]]=false,e3[rec[i]].clear();
		}
	}
	return 0;
}

```





---


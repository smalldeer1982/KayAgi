# [FJOI2016] 所有公共子序列问题

## 题目描述

一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列 $X=x_1x_2\ldots x_m$，则另一序列 $Z=z_1z_2\ldots z_k$ 是 $X$ 的子序列是指存在一个严格递增下标序列 $i_1,i_2, \ldots ,i_k$ 使得对于所有 $j=1,2,…,k$ 有 $z_j=x_{i_j}$。

例如，序列 $Z=$``GACT`` 是序列 $X=$``GCTACT`` 的子序列，相应的递增下标序列为 $1,4,5,6$。给定两个序列 $X$ 和 $Y$，当另一序列 $Z$ 既是 $X$ 的子序列又是 $Y$ 的子序列时，称 $Z$ 是序列 $X$ 和 $Y$ 的公共子序列。例如，若 $X=$``GCTACT``， $Y=$``GATCCT``，序列 $T$ 是 $X$ 和 $Y$ 的一个公共子序列，序列 ``GACT`` 也是 $X$ 和 $Y$ 的一个公共子序列。注意对于任何给定的序列 $X$ 和 $Y$，空序列总是它们的一个公共子序列。

所有公共子序列问题是要求对于给定的 $2$ 个序列 $X=x_1x_2\ldots x_m$ 和 $Y=y_1y_2\ldots y_m$，找出 $X$ 和 $Y$ 的所有不同的公共子序列。

## 说明/提示

$1 \leq m,n \leq 3010$

答案....很大啦

## 样例 #1

### 输入

```
6 6
GCTACT
GATCCT 1```

### 输出

```
A
AC
ACT
AT 
C  
CC 
CCT
CT 
G  
GA 
GAC
GACT
GAT 
GC  
GCC 
GCCT
GCT 
GT  
GTC 
GTCT
GTT 
T   
TC  
TCT 
TT  
26```

# 题解

## 作者：枫林晚 (赞：7)

### 序列自动机：

是一个处理子序列的自动机。就这样。

建造：（By猫老师：immoralCO猫）

```cpp
s[]
next[][26]
memset(next[n], -1, 26<<2);
for(int i = n; i; --i) {
    memcpy(next[i - 1], next[i], 26 << 2);
    next[i - 1][s[i] - 'a'] = i;
}
```

nxt[][]数组就是第几个位置，序号为几的出边连接到第几个位置（位置是对应字符串的位置，其实并没用）

大概原理就是每当要循环到字符串中的一个位置，就把这个位置的连通性赋值给上一个节点编号，（可以理解，n个字符，其实是n条边，最多有n+1个节点在两边）

然后处理新来的字符i对于i-1号位置连通性的影响，那么，

编号从0~n，其中0号点就是根，dfs从0开始。

（不会的话，手动模拟就好了）

发现，当子序列中有重复元素的时候，nxt[i-1][s[i]-'a']=i一句可以将这种情况覆盖掉。

由于这些0~n号节点可以重复到达，当然最终到了n号点就是边界了。

所以dfs没有问题。而且大大节省了空间。

 

这样，我们可以只用有限的O(长度*|S|）的空间，来建造这棵树。

发现，这棵树好像trie啊~！！！！

其实差不多，一个子序列，一个子串。

 

操作也就和trie差不多了。

### 基本操作：

1.可以统计一个串本质不同的子序列的个数

序列自动机上可以是一棵树，树上每一个节点到根的路径上的边所代表的字符串就是所有的本质不同的子序列。

dfs树上扫一遍就好了。

 

2.可以查找一个子序列是否在这个字符串中出现过。

显然，dfs就可以。

 

3.也可以两个序列自动机一起dfs，找到所有公共子序列。

就比如说这个题：

（真**·**序列自动机板子题）

 
### [FJOI2016]所有公共子序列问题

题目大意：给定两个字符串，求这两个串的所有公共子序列。

当输入的参量k=1的时候，按照字典序输出这些子序列，并输出个数。

当输入的参量k=0的时候，输出个数就可以。

注意，空字符串也是一个公共子序列。

#### 分析：

裸裸裸裸的序列自动机。

开两个自动机，直接同时跑dfs就可以。

对于k=1，就要先走a，再走z，条件是两个都可以走，一遍用一个栈一样的字符串记录字符串。进入循环就输出即可。并且记录总数。

对于k=0，同理。

诶，怎么我的long long出了负数呢？？

因为要高精。

诶，怎么我的高精MLE了呢？？？？

因为要压位高精。

https://www.cnblogs.com/Miracevin/p/9031691.html

但是这个版本太弱了，很久以前写的。

所以，用结构体实现就比较方便了。结构体内置函数。

支持：高精加低精（因为要赋初值1（其实直接赋值也可以）），高精加高精，压位高精的输出。

没了。

看代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=1e9;
const int N=3020;
const int L=58;
const int K=25;
int nxt1[N][L],nxt2[N][L];
char sta[N];
int top=-1;
ll ans;
int la,lb,k;
char a[N],b[N];
struct Big{//压位结构体 
    int cur;
    ll *s;
    void init(){
        s=new long long[20];
        for(int i=0;i<20;i++) s[i]=0;
        cur=0;
    }
    void put(){
        printf("%lld",s[cur]);
        for(int i=cur-1;i>=0;i--) printf("%09lld",s[i]);
    }
    void add(ll k){
        s[0]+=k;
        int i=0;
        while(s[i]>=mod) s[i+1]+=s[i]/mod,s[i++]%=mod;
        while(s[cur+1]) cur++;
    }
    void Add(const Big& o){
        ll i,r=max(cur,o.cur);
        for(int i=0;i<=r;i++){
            s[i]+=o.s[i];
            if(s[i]>=mod) s[i+1]+=s[i]/mod,s[i]%=mod;
        }
        cur=min(r+3,19ll);while(cur&&s[cur]==0) cur--;
    }
}dp[N][N];
bool vis[N][N];
void build1(){//建造序列自动机 
    memset(nxt1[la],-1,sizeof nxt1[la]);
    for(int i=la;i;i--){
        memcpy(nxt1[i-1],nxt1[i],sizeof nxt1[i]);
        nxt1[i-1][a[i]-'A']=i;
    }
}
void build2(){
    memset(nxt2[lb],-1,sizeof nxt2[lb]);
    for(int i=lb;i;i--){
        memcpy(nxt2[i-1],nxt2[i],sizeof nxt2[i]);
        nxt2[i-1][b[i]-'A']=i;
    }
}
void dfs2(int x,int y){//dfs 
    if(vis[x][y]) return;
    vis[x][y]=1;
    dp[x][y].init();
    dp[x][y].add(1);
    for(int i=0;i<=57;i++){
        if(nxt1[x][i]!=-1&&nxt2[y][i]!=-1) {
        dfs2(nxt1[x][i],nxt2[y][i]);
        dp[x][y].Add(dp[nxt1[x][i]][nxt2[y][i]]);
        }
    }
}
ll dfs1(int x,int y){
    printf("%s\n",sta);
    ll cnt=1;
    for(int i=0;i<=57;i++){
        if(nxt1[x][i]!=-1&&nxt2[y][i]!=-1) {
        sta[++top]=i+'A';
        cnt+=dfs1(nxt1[x][i],nxt2[y][i]);
        sta[top--]=' ';
        }
    }
    return cnt;
}
int main()
{
    scanf("%d%d",&la,&lb);
    scanf("%s",a+1);scanf("%s",b+1);    
    scanf("%d",&k);
    build1();build2();
    if(k==1) {    
    dfs1(0,0);
    }
    dfs2(0,0);
    dp[0][0].put();
    return 0;
}
```

 

---

## 作者：i207M (赞：4)

~~n,m不要打反~~

~~不错，自己搞出来了~~

看题解都是无法滚动数组的压位高精，给一个可以**滚动数组**的DP。

首先，这道题有一个很显然的二维$dp[i][j]$表示恰好选择了i和j：

$$dp[i][j]=1+\sum _w dp[nxt[i][w]][nxt'[j][w]];a[i]=b[j]$$

但是加上高精度之后，这道题会炸空间，怎么办？（压位

我们改进一下状态，$dp[i][j]$表示第二个串恰好选了j，第一个串选了$\le i$的位置。

那么转移有两种，我们还是必须贪心地匹配，才能保证只计数一次：

1. 如果$a[i]=b[j]$：

$$dp[i][j]=1+\sum_w dp[i-1][nxt'[j][w]]$$

枚举下一个是什么。

2. 否则：

$$dp[i][j]=dp[i-1][j]$$

忽略掉i即可。

为什么这个做法更优秀呢？因为这个做法可以扩展到**LCIS**计数且字符集很大且卡空间的情况。

~~由于没有压位导致常数很大的代码：~~

```cpp
#define N 3015
il int ha(const char c)
{
	if(c<='Z') return c-'A';
	return c-'a'+26;
}
struct XL
{
	char s[N];
	int n,nxt[N][52];
	void init()
	{
		scanf("%s",s+1); n=strlen(s+1);
		for(ri i=n-1; i>=0; --i)
		{
			memcpy(nxt[i],nxt[i+1],sizeof nxt[i]);
			nxt[i][ha(s[i+1])]=i+1;
		}
	}
} A,B;
int typ;
int cnt;
int d[N],dep;
void dfs(int x,int y)
{
	if(typ)
	{
		for(ri i=1; i<=dep; ++i) putchar(d[i]<26?d[i]+'A':d[i]-26+'a');
		enter;
	}
	++cnt;
	for(ri i=0; i<52; ++i) if(A.nxt[x][i]&&B.nxt[y][i])
		{
			d[++dep]=i;
			dfs(A.nxt[x][i],B.nxt[y][i]);
			--dep;
		}
}
#define MXLEN 200
struct Bigint
{
	int num[MXLEN],sz;
	Bigint(int x = 0)
	{
		mem(num,0),sz=0;
		while(x) num[++sz]=x%10,x/=10;
	}
	int &operator[](const int x) {return num[x];}
	const int &operator[](const int x) const {return num[x];}
	void operator*=(const Bigint &x)
	{
		static int tmp[MXLEN]; clr(tmp+1,tmp+1+sz+x.sz);
		for (ri i=1; i<=sz; ++i)
			for(ri j=1; j<=x.sz; ++j) tmp[i+j-1]+=num[i]*x[j];
		sz+=x.sz;
		for(ri i=1; i<=sz; ++i)
		{
			tmp[i+1]+=tmp[i]/10;
			tmp[i]%=10;
		}
		while(sz&&tmp[sz]==0) --sz;
		for(ri i=1; i<=sz; ++i) num[i]=tmp[i];
	}
	Bigint operator*(const Bigint &x) const
	{
		Bigint res=*this; res*=x;
		return res;
	}
	void operator*=(const int x)  // positive
	{
		for(ri i=1; i<=sz; ++i) num[i]*=x;
		sz+=10;
		for(ri i=1; i<=sz; ++i)
		{
			num[i+1]+=num[i]/10;
			num[i]%=10;
		}
		while(sz&&num[sz]==0) --sz;
	}
	Bigint operator*(const int x) const
	{
		Bigint res=*this; res*=x;
		return res;
	}
	void operator+=(const Bigint &x)
	{
		for (ri i=1,t; i<=x.sz; ++i)
		{
			t=num[i]+x[i];
			num[i]=t%10;
			num[i+1]+=t/10;
		}
		sz=max(sz,x.sz); while(num[sz+1]) ++sz;
	}
	Bigint operator+(const Bigint &x) const
	{
		Bigint res=*this; res+=x;
		return res;
	}
	void read()
	{
		static char tc[MXLEN];
		scanf("%s", tc+1); sz=strlen(tc+1);
		for(ri i=1; i<=sz; ++i) num[i]=tc[sz-i+1]-'0';
	}
	void print() const
	{
		int t=max(sz,1);
		for(ri i=t; i>=1; --i) putchar('0'+num[i]); enter;
	}
};
int n,m;
Bigint _dp[2][N],ans;
void solve()
{
	auto f=_dp[0],g=_dp[1];
	for(ri i=n; i>=1; --i)
	{
		swap(f,g); memset(f,0,sizeof _dp[0]);
		for(ri j=m; j>=1; --j)
			if(A.s[i]==B.s[j])
			{
				f[j]+=1;
				for(ri k=0; k<52; ++k)
					if(B.nxt[j][k]) f[j]+=g[B.nxt[j][k]];
			}
			else f[j]=g[j];
	}
	ans+=1;
	for(ri k=0; k<52; ++k)
		if(B.nxt[0][k]) ans+=f[B.nxt[0][k]];
	ans.print();
}
signed main()
{
#ifdef M207
	freopen("in.in","r",stdin);
	// freopen("ot.out","w",stdout);
#endif
	in(n,m);
	A.init(),B.init();
	in(typ);
	if(typ) {dfs(0,0); out(cnt);}
	else solve();
	return 0;
}
```


---

## 作者：s_r_f (赞：2)

子序列自动机 + $DP.$      
首先建立$A$串和$B$串的子序列自动机。   
令$f[i][j]$  表示从$A$串中第$i$个字符$A_i$开始,从$B$串中第$j$个字符$B_j$开始的公共子序列个数。      
显然有$f[i][j] =$ $\Sigma f[Nxt[i][k]][Nxt[j][k]]. $  
如果不考虑答案的范围，那就是$O(nm|S|)$的复杂度,但是很难达到上界。  
答案很大，而且要输出，那就只能考虑高精度。   
一共有$O(nm)$个状态，普通高精会$MLE$,压位高精即可($18$位压到一个$long long$里可还行)。

提醒一下$70$分的同学们，当$k = 1$时,答案中应当输出空串,**不用把空串判掉**。

代码:
```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
inline int read(){
    int x = 0,f = 1; char c = getchar();
    while (c != EOF && !isdigit(c)) {if (c == '-') f = -1;c = getchar();}
    while (isdigit(c)) {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}
inline int Get(){
	char c = getchar();
	while (!isalpha(c)) c = getchar();
	return c;
}

const int N = 3020,M = 3020;

LL p = 1e18,w = 18;
struct Bignum{
	LL *a; short int n;
	inline void init(){ a = new LL[10],memset(a,0,sizeof(a)),n = 0,a[0] = 1;}
	inline void write(){
		printf("%lld",a[n]);
		for (int i = n - 1; i >= 0; i--) printf("%0*lld",w,a[i]);
		putchar('\n');
	}
	inline void add(Bignum x){
		n = max(n,x.n);
		for (int i = 0; i <= n; ++i){
			a[i] += x.a[i];
			if (a[i] >= p) a[i+1] += a[i] / p,a[i] %= p;
		}
		while (a[n+1]) ++n;
	}
}f[N][M];

int t[256],ff[256];

int n,a[N],m,b[M],k,Ne1[N][52],Ne2[M][52];

int st[N],top;

void dfs(int x,int y){
	for (int i = 1; i <= top; ++i) putchar(ff[st[i]]); putchar('\n');
	for (int i = 0,px,py; i < 52; ++i)
		if ((px = Ne1[x][i]) && (py = Ne2[y][i])) st[++top] = i,dfs(px,py),--top;
}
bool vis[N][M];
void dp(int x,int y){
	if (vis[x][y]) return;
	vis[x][y] = 1;
	f[x][y].init();
	for (int i = 0,px,py; i < 52; ++i)
		if ((px = Ne1[x][i]) && (py = Ne2[y][i])) dp(px,py),f[x][y].add(f[px][py]);
}

int main(){
	int i,j;
	for (i = 0; i < 26; ++i) t[i + 'a'] = 26 + i,ff[26 + i] = i + 'a';
	for (i = 0; i < 26; ++i) t[i + 'A'] = i,ff[i] = i + 'A';
	
	n = read(),m = read();
	for (i = 1; i <= n; ++i) a[i] = t[Get()];
	for (i = 1; i <= m; ++i) b[i] = t[Get()];
	k = read();
	
	for (j = 0; j < 52; ++j) Ne1[n][j] = 0;
	for (i = n-1; i >= 0; --i)
	for (j = 0; j < 52; ++j) Ne1[i][j] = (a[i+1] == j) ? i+1 : Ne1[i+1][j];
	
	for (j = 0; j < 52; ++j) Ne2[m][j] = 0;
	for (i = m-1; i >= 0; --i)
	for (j = 0; j < 52; ++j) Ne2[i][j] = (b[i+1] == j) ? i+1 : Ne2[i+1][j];
	
	if (k) dfs(0,0);
	dp(0,0),f[0][0].write();
    return 0;
}
```

---

## 作者：Fzrcy (赞：0)

~~不愧是FJOI~~。

明显的，这是道子序列自动机板子题，考虑建立 $X$ 和 $Y$ 的子序列自动机 $ch1$ 和 $ch2$。设 $f_{i,j}$ 表示在 $ch1$ 中以 $i$ 开始，在 $ch2$ 中以 $j$ 开始的公共子序列数。有状态转移方程：

$$f_{i,j}=1+\sum_{c\in S}f_{ch1_{i,c},ch2_{j,c}}(ch1_{i,c}\ne 0,ch2_{j,c}\ne 0)$$

其中 $S$ 为字符集包含 $a\dots z$ 和 $A\dots Z$。

直接 DP 即可，对于第一问爆搜输出所有公共子序列，对于第二问直接记忆化搜索即可，注意空串也算公共子序列！还需要压位高精。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N=3333;
const int MOD=1e9;
struct BigInt{//压位高精是借鉴其他题解的。
  ll *s;
  int c;
  void init(){
    s=new ll[20];
    for(int i=0; i<20; i++)
      s[i]=0;
    c=0;
  }
  void out(char ch='\n'){
    printf("%lld", s[c]);
    for(int i=c-1; i>=0; i--)
      printf("%09lld", s[i]);
    putchar(ch);
  }
  void add(int x){
    s[0]+=x;
    int i=0;
    while(s[i]>=MOD)s[i+1]+=s[i]/MOD, s[i]%=MOD, i++;
    while(s[c+1])c++;
  }
  void add(const BigInt &x){
    int r=max(c, x.c);
    for(int i=0; i<=r; i++){
      s[i]+=x.s[i];
      if(s[i]>=MOD) s[i+1]+=s[i]/MOD, s[i]%=MOD;
    }
    c=min(19, r+1);
    while(c&&s[c]==0)c--;
  }
}f[N][N];
struct ZXLZDJ{
  int ch[N][58];
  void build(char *s, int Len){
    for(int i=Len; i; i--){
      for(int j=0; j<58; j++) ch[i-1][j]=ch[i][j];
      ch[i-1][s[i]-'A']=i;
    }
  }
  int* operator [] (const int &i){return ch[i];}
}A,B;
bool vis[N][N];
char s1[N], s2[N]; int n, m, op;
void dfs(int u, int v){
  if(vis[u][v])return;
  vis[u][v]=1;
  f[u][v].init();
  f[u][v].add(1);
  for(int i=0; i<58; i++){
    if(!A[u][i]||!B[v][i])continue;
    dfs(A[u][i], B[v][i]);
    f[u][v].add(f[A[u][i]][B[v][i]]);
  }
}
char ans[N];
void _dfs(int u, int v, int tt){
  ans[tt]='\0';
  printf("%s\n", ans+1);
  for(int i=0; i<58; i++){
    if(A[u][i]==0||B[v][i]==0)continue;
    ans[tt]=i+'A';
    _dfs(A[u][i], B[v][i], tt+1);
  }
}
int main(){
  scanf("%d %d", &n, &m);
  scanf(" %s", s1+1);
  scanf(" %s", s2+1);
  scanf("%d", &op);
  A.build(s1, n);
  B.build(s2, m);
  if(op) _dfs(0, 0, 1);
  dfs(0, 0);
  f[0][0].out();
  return 0;
}
```

---


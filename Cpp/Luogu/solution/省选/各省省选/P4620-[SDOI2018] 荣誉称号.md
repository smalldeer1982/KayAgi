# [SDOI2018] 荣誉称号

## 题目背景

 - Input file: title.in
 - Output file: title.out
 - Time limit: 10 seconds
 - Memory limit: 512 megabytes

## 题目描述

休闲游戏玩家小 $Q$ 不仅在算法竞赛方面取得了优异的成绩，还在一款收集钻石的游戏中排名很高。

这款游戏一共有 $n$ 种不同类别的钻石，编号依次为 $1$ 到 $n$。小 $Q$ 已经玩了这款游戏很久了，对于第
$i$ 种钻石，他已经收集到了 $a_i$ 个。这款游戏最大的亮点就是，钻石只有一种获得途径，那就是从商城中购买。具体来说，第 $i$ 种钻石的单价为 $b_i$ 点券。为了鼓励玩家充值，每种钻石都没有数量上限，只要肯充钱，就可以拥有任意多的钻石。但是这款游戏并没有开发 “丢弃道具” 功能，因此小 $Q$ 不能通过丢弃钻石去完成任务。

最近这款游戏推出了一个限时成就任务，完成任务的玩家可以获得荣誉称号，而完成任务条件则是：
给定正整数 $k$ 和 $m$，对于任意一个整数 $x (x\ge 2^k)$，$a_{x}+a_{\lfloor\frac{x}{2}\rfloor}+a_{\lfloor\frac{x}{4}\rfloor}+a_{\lfloor\frac{x}{8}\rfloor}+...+a_{\lfloor\frac{x}{2^k}\rfloor}$ 都要是 $m$的倍数。

高玩小 $Q$ 当然想完成这个限时成就任务，但是在充钱之前他想知道他究竟需要多少点券才能完成这个任务。请写一个程序帮助小 $Q$ 计算最少需要的点券数量。

## 说明/提示

 - $1 ≤ T ≤ 10$，
 - $1 ≤ k ≤ 10$ 且 $2^k ≤ n$，
 - $ 1 ≤ p ≤ min(n, 100000)$，$10000 ≤ SA, SB, SC ≤ 1000000$，
 - $ 1 ≤ A, B, ai, bi ≤ 10^7$。

子任务 $1$（$30$ 分）：满足 $1 ≤ n ≤ 1000$ 且 $m = 2$。

子任务 $2$（$40$ 分）：满足 $1 ≤ n ≤ 10^5$ 且 $m ≤ 200$。

子任务 $3$（$30$ 分）：满足 $1 ≤ n ≤ 10^7$ 且 $m ≤ 200$。

## 样例 #1

### 输入

```
2
3 1 2 3 11111 22222 33333 1 1
1 5
2 3
3 6
7 2 3 7 11111 22222 33333 1 1
6 9
4 5
3 7
5 2
2 4
1 7
9 6```

### 输出

```
3
14```

# 题解

## 作者：_ctz (赞：20)

[安利blog](https://ctz45562.github.io/2019/10/12/%E6%B4%9B%E8%B0%B7-P4620-SDOI2018-%E8%8D%A3%E8%AA%89%E7%A7%B0%E5%8F%B7/)

[传送门](https://www.luogu.org/problem/P4620)

> 妈妈我能独立切「SDOI2018R2」的题啦！

~~虽然这个题不难~~

向下取整满足结合律（并不知道为啥~~[asuldb](https://www.cnblogs.com/asuldb)说这很显然~~）。然后把那个鬼畜的条件拆开（懒得打向下取整了）：

$a_{x/2}+a_{x/2/2}+a_{x/2/2/2}+...\equiv 0 \pmod m$

如果连上边数列就会变成这个样子：

![](https://ctz45562.github.io/images/荣誉称号-1.png)

很明显构成了一棵完全二叉树。这个条件就能转化为**从任意点出发，向下延伸包含$k+1$个点的路径权值和模$m$等于$0$**。

再看上面那张图，令$k=2$，列两个式子：

$a_1+a_2+a_4\equiv 0\pmod m$

$a_2+a_4+a_8\equiv 0\pmod m$

$\therefore a_1\equiv a_8\pmod m$

同理，$a_1\equiv a_9\equiv a_{10}\equiv...a_{15}$，$a_2\equiv a_{16}\equiv a_{17}\equiv ... a_{23}\pmod m$

也就是说每个点与其子树内向下第$k+1$层的点最终的权值相等。

这样只要前$k+1$层的路径满足模$m$等于$0$，下面的所有路径就都满足。$DP$的时候要考虑的点数直接降到$2^{k+1}$个。

设$f(i,j)$为点$i$向下延伸至$k+1$层路径权值和模$m$为$j$的最小花费。

$O(n+m^22^{k+1})$预处理一个$v(i,j)$表示将点$i$以及与它相等的点权值全部改为$j$的花费。

直接枚举左右儿子的路径权值转移：

$f(i,j)=\min\{f(i<<1,k)+f(i<<1|1,k)+v(i,(j-k+m)\%m)\}$

从$2^{k+1}$开始倒着$DP$，答案就是$f(1,0)$。复杂度$O(Tn+Tm^22^{k+1})$。

代码：

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 10000005
#define inf 0x3f3f3f3f

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
int n,m,k,a[maxn],b[maxn],id[maxn];
long long f[1<<11][200],v[1<<11][200],tax[1<<11][200];
namespace file{
	unsigned int SA, SB, SC;
	int p, A, B;
	unsigned int rng61(){
		SA ^= SA << 16;
		SA ^= SA >> 5;
		SA ^= SA << 1;
		unsigned int t = SA;
		SA = SB;
		SB = SC;
		SC ^= t ^ SA;
		return SC;
	}
	void gen(){
		n=read(),k=read()+1,m=read(),p=read(),SA=read<unsigned>(),SB=read<unsigned>(),SC=read<unsigned>(),A=read(),B=read();
		for(int i = 1; i <= p; i++)a[i]=read()%m,b[i]=read();
		for(int i = p + 1; i <= n; i++){
			a[i] = (rng61() % A + 1)%m;
			b[i] = rng61() % B + 1;
		}
	}
}
int main(){
	int t=read();
	while(t--){
		file::gen();
		memset(v,0,sizeof v);
		memset(tax,0,sizeof tax);
		memset(f,0x3f,sizeof f);
		for(register int i=1;i<1<<k;++i)tax[id[i]=i][a[i]]=b[i];
		for(register int i=1<<k;i<=n;++i)tax[id[i]=id[i/(1<<k)]][a[i]]+=b[i];
		for(register int i=1;i<1<<k;++i){
			for(register int j=0;j<m;++j){
				for(register int k=0;k<j;++k)
					v[i][j]+=tax[i][k]*(j-k);
				for(register int k=j+1;k<m;++k)
					v[i][j]+=tax[i][k]*(j+m-k);
			}
		}
		for(register int i=1<<k-1;i<1<<k;++i)
			for(register int j=0;j<m;++j)
				f[i][j]=v[i][j];
		for(register int i=(1<<k-1)-1;i;--i)
			for(register int j=0;j<m;++j)
				for(register int k=0;k<m;++k)
					f[i][j]=min(f[i][j],f[i<<1][k]+f[i<<1|1][k]+v[i][(j-k+m)%m]);
		printf("%lld\n",f[1][0]);
		for(register int i=1;i<=n;++i)a[i]=b[i]=0;
	}
}
```

---

## 作者：liuzhangfeiabc (赞：10)

据称是sdoi2018 ~~rand~~round 2 最简单的一道。

可惜当时这题写挂了一分不剩不然就能翻进A队了嘤嘤嘤。

不知道有多少人跟我一样，第一眼被n=1e7吓到。

其实看到n=1e7就大概能猜出来应该是个O(n+...)的复杂度了对吧。

好了现在开始冷静分析。

这种下标不停/2的形式，容易使人想到完全二叉树。

那么所有的限制条件说白了就是树上所有长为k+1的“祖孙链”的权值之和%m都等于0。

这样我们容易想到30分的dp:记f[i][s]表示现在处理到节点i，向下的链的状态是s的答案。

再来说说正解：

考虑将树上一条k+1的链向父亲整体移动一步，我们会发现，这两条链的唯一差别就是两个端点，这两个点距离为k+1。

由于两条链%都=0，因此这两个点的值%m应该相等才行。

更一般地，最后每个节点的值一定和它k+1级父节点的值相同！

所以，我们可以仅考虑深度最小的k+1层节点的值，因为对于其他的节点，必然和前k+1层中的某个节点权值相同。

我们可以预处理出val[i][j]:前k+1层的节点i，最后的值是j，它和它的“附属节点”需要花费的总代价。

这玩意可以通过先统计出val[i][0]和每次j->j+1需要花费的代价等方式线性处理。

记f[i][j]为：考虑到i节点，向下且止于第k+1层的链的值%m=j的答案。

转移时枚举当前节点的值即可。

复杂度O(n + 2^k * m^2)

于是你信心满满地写完，提交，发现只有70，wa了第一个点，喵喵喵？！

（据统计全场写正解的人有80%以上都挂了）

问题出在哪里？

当n<2^(k+1)-1时，这里会多考虑一些不必要的限制条件。

比如当n恰好=2^k时，受到的限制只有一组，除此之外的其他所有点都可以随心所欲地填，而你在dp时仍然对其他节点进行了限制（因为合并两棵子树时只能对于相同的j进行合并）。

对此我的解决办法是将n扩充到2^(k+1)-1,并将那些新增节点的a和b都设成0。

这样相当于这些节点无论取什么值都不会有任何代价，就可以起到一个调节作用，保证dp值的正确性。

（其实直接将无关紧要的节点删去应该也可以。）

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<ctime>
#include<vector>
#include<set>
using namespace std;
#define li long long
#define gc getchar()
#define pc putchar
li read(){
	li x = 0;
	int c = gc;
	while(!isdigit(c)) c = gc;
	while(isdigit(c)){
		x = (x << 1) + (x << 3) + (c ^ '0');
		c = gc;
	}
	return x;
}
void print(li q){
	if(q >= 10) print(q / 10);
	pc(q % 10 + '0');
}
unsigned int SA,SB,SC;
int t,A,B,n,k,m,p,w,w2;
inline unsigned int rng61(){
	SA ^= SA << 16;
	SA ^= SA >> 5;
	SA ^= SA << 1;
	unsigned int t = SA;
	SA = SB;
	SB = SC;
	SC ^= t ^ SA;
	return SC;
}
int a[10000010],b[10000010];
li ans;
li dp[4100][210];
li vl1[2100][210],vl2[2100],vl3[2100][210];
int bel[10000010];
#define inf 100000000000000000ll
int main(){
	//freopen("title.in","r",stdin);
	//freopen("title.out","w",stdout);
	register int i,j,l;
	t = read();
	while(t--){
		memset(vl1,0,sizeof(vl1));
		memset(vl2,0,sizeof(vl2));
		memset(vl3,0,sizeof(vl3));
		n = read();k = read();m = read();p = read();SA = read();SB = read();SC = read();A = read();B = read();
		for(i = 1;i <= p;++i){
			a[i] = read();b[i] = read();
		}
		for(i = p + 1;i <= n;++i){
			a[i] = rng61() % A + 1;
			b[i] = rng61() % B + 1;
		}
		for(i = 1;i <= n;++i) a[i] %= m;
		w = 1 << k + 1;
        //边界特判
		if(n < w - 1){
			for(i = n + 1;i < w;++i) a[i] = b[i] = 0;
			n = w - 1;
		}
        //预处理val
		for(i = 1;i <= n;++i){
			bel[i] = (i < w ? i : bel[i >> k + 1]);
			vl1[bel[i]][0] += (a[i] ? b[i] * (m - a[i]) : 0);
			vl2[bel[i]] += b[i];
			vl3[bel[i]][a[i]] += m * b[i];
		} 
		for(i = 1;i < w;++i){
			for(j = 1;j < m;++j) vl1[i][j] = vl1[i][j - 1] + vl2[i] - vl3[i][j];
		}
		memset(dp,0x3f,sizeof(dp));
		for(i = w;i < w + w;++i) dp[i][0] = 0;
		for(i = w - 1;i >= 2;--i){
			for(j = 0;j < m;++j){
				for(l = 0;l < m;++l) dp[i][j] = min(dp[i][j],vl1[i][l] + dp[i << 1][(j - l + m) % m] + dp[i << 1 | 1][(j - l + m) % m]);
			}
		}
		ans = inf;
		for(i = 0;i < m;++i) ans = min(ans,vl1[1][i] + dp[2][(m - i) % m] + dp[3][(m - i) % m]);
		print(ans);
		pc('\n');
	}
	return 0;
}
```

---

## 作者：creation_hy (赞：1)

~~怎么没多少人发题解呀~~

看题面这个诡异的式子容易想到二叉树，不难写出树形 dp，$f_{i,j}$ 表示 $i$ 子树内每条链的和对 $m$ 取模都为 $j$ 时的最小花费。一定要从下往上推，不然没法合并。

然后发现 $2^k$ 和 $n$ 的范围不一样，显然对于 $x\ge 2^{k+1}$ 的点来说值固定与前 $k$ 层的某个点相同，因为 $x$ 父亲的那条链相比 $x$ 的链多了 $\lfloor\frac{x}{2^{k+1}}\rfloor$，少了 $x$，而这两条链模 $m$ 后相同，也就是说 $x$ 和 $\lfloor\frac{x}{2^{k+1}}\rfloor$ 相同。

所以只需要 dp 推出前 $k$ 层即可，再开个数组，$g_{i,j}$ 表示 $i$ 取值 $j$ 时的花费。然后把 $a_i$ 相同的点放在一起计算即可。

时间复杂度 $O(2^km^2+n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e7 + 5;
const int M = 2055;
int T, n, m, s, P, A, B;
ll f[M][205], g[M][205], a[N], b[N], sum[M][205];
uint SA, SB, SC;
inline uint rng61()
{
    SA ^= SA << 16, SA ^= SA >> 5, SA ^= SA << 1;
    uint t = SA;
    SA = SB, SB = SC, SC ^= t ^ SA;
    return SC;
}
inline void gen()
{
    cin >> n >> s >> m >> P >> SA >> SB >> SC >> A >> B;
    for (int i = 1; i <= P; i++)
        cin >> a[i] >> b[i];
    for (int i = P + 1; i <= n; i++)
        a[i] = rng61() % A + 1, b[i] = rng61() % B + 1;
}
inline int ls(int p) { return p << 1; }
inline int rs(int p) { return p << 1 | 1; }
inline void chk(ll &x, ll k) { x = min(x, k); }
inline void dfs(int x)
{
    if (x >= 1 << s + 1)
        return;
    if (x >= 1 << s)
    {
        memcpy(f[x], g[x], sizeof(g[x]));
        return;
    }
    dfs(ls(x)), dfs(rs(x));
    for (int i = 0; i < m; i++)
        for (int j = 0; j < m; j++)
            chk(f[x][(i + j) % m], f[ls(x)][j] + f[rs(x)][j] + g[x][i]);
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> T;
    while (T--)
    {
        memset(f, 0x3f, sizeof(f));
        memset(sum, 0, sizeof(sum));
        memset(g, 0, sizeof(g));
        gen();
        for (int i = 1; i <= n; i++)
            a[i] %= m;
        for (int i = 1; i < 1 << s + 1; i++)
            for (ll k = 1; i * k <= n; k *= 1 << s + 1)
                for (int j = i * k; j <= min(n, int(k) * (i + 1) - 1); j++)
                    sum[i][a[j]] += b[j];
        for (int i = 1; i < 1 << s + 1; i++)
            for (int j = 0; j < m; j++)
                for (int k = 0; k < m; k++)
                    g[i][j] += (j - k + m) % m * sum[i][k];
        dfs(1);
        cout << f[1][0] << '\n';
    }
    return 0;
}
```

---


# [SHOI2011] 直线拟合

## 题目描述

平面上有 $n$ 个点 $v_i(x_i,y_i)$ 。求 $D(l)=\max_{1\le i\le n} dis(v_i,l)$ 的最小可能值，其中变量 $l$ 是平面上的一条直线，函数 $dis(v_i,l)$ 表示直线 $l$ 与点 $v_i$ 之间的距离。

## 说明/提示

**样例解释 1**

样例 $1$ 中， 取到最小值时的直线 $l$ 为 $y=1$ 。

**样例解释 2**

样例 $2$ 中的 $6$ 个点，以及 $D(l)$ 取到最小值时的直线 $l$ 如图所示。

![1](https://cdn.luogu.com.cn/upload/pic/20067.png)

**数据范围与提示**

测试点 $1$：$n=3$。

测试点 $2 \sim 4$：$3 \le n \le 100$。

测试点 $5 \sim 7$：$100 < n \le 100000$ ，且输入文件如下生成：选定一条线段，每次先在该线段上等概率随机选择一个点，再取离该点最近的整点。

测试点 $8 \sim 10$：$3 < n \le 100000$。

## 样例 #1

### 输入

```
6
1 0
2 0
3 0
3 2
4 0
5 0```

### 输出

```
1.00```

## 样例 #2

### 输入

```
6
-2 -1
-1 2
1 2
2 3
3 3
4 4```

### 输出

```
0.86```

# 题解

## 作者：CR_Raphael (赞：6)

我怕不是个傻子

一道模版题肝模拟退火。

~~-孩子沉迷退火怎么办？逼他用模拟退火做计算几何再让他打正解，妈妈再也不用担心我的常数啦！~~

咳，说正解，旋转卡壳求凸包点边最长值，

不过朕的代码……我一开始想歪了……直接凸包+二分上了……似乎没见过这样搞的……

就是找凸包上每个边斜率在凸包另一侧的位置，就确定了离该边最远的点。其实如果用尺取法做的话，就等价于旋转卡壳了。

~~所以我独立发明了旋转卡壳？~~

贴个超级丑的代码，希望正统旋转卡壳亲之信之，则几何之隆，可计日而待也。

懒得做正解了，如果您是初学者，想用这篇代码为蓝本学旋转卡壳，那么我建议换一篇题解。

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;

const double pi = 3.1415926535;
const int maxn = 100005;
const double inf = 2000000001;
int n;
double k, l, ans;
int t;

struct pointt {
	double x, y, tk;
} a[maxn], p[maxn];

int findd(double ff) {
	int l, r, mid;
	l=1; r=t;
	while(l < r) {
		mid=(l+r+1)/2;
		if(a[mid].tk <= ff) l=mid;
		else r=mid-1;
	}
	return l;
}

double count_ans(int kx) {
	int i;
	double kk=a[kx].tk, maxx, minn;
	double kt;
	if(kk < pi) kk+=pi;
	else kk-=pi;
	if((a[kx].x!= a[kx-1].x)) kt=(a[kx].y-a[kx-1].y)/(a[kx].x-a[kx-1].x);
	else kt=inf;
	
	i=findd(kk);
	maxx=(kt*a[i].x-a[i].y)/sqrt(kt*kt+1);
	minn=(kt*a[kx].x-a[kx].y)/sqrt(kt*kt+1);
	
	if(kt == inf) {
		maxx=a[i].x;
		minn=a[kx].x;
	}
	return abs(maxx-minn)/2;
}

bool cmp(pointt a1, pointt a2) {
	return a1.tk < a2.tk;
}

double count(pointt a1, pointt a2) {
	double tt=atan2((a1.y-a2.y), (a1.x-a2.x));
	if(tt < 0) tt+=2*pi;
	return tt;
}

double ll(pointt a1, pointt a2) {
	return sqrt((a1.y-a2.y)*(a1.y-a2.y) + (a1.x-a2.x)*(a1.x-a2.x));
}

int main() {
	int i, minp, maxp;
	double miny;
	scanf("%d", &n);
	for(i=1; i <= n; i++) 
		scanf("%lf%lf", &p[i].x, &p[i].y);
	
	miny=p[1].y; minp=1;
	for(i=1; i <= n; i++) {
		if(p[i].y < miny) miny=p[i].y, minp=i;
	}
	swap(p[1], p[minp]);
	for(i=1; i <= n; i++) 
		p[i].tk=atan2(p[i].y-p[1].y, p[i].x-p[1].x);
	sort(p+1, p+1+n, cmp);
	t=0; i=0;
	do {
		i++;
		if(i == n+1) i=1;
		while(t > 1 && (count(p[i], a[t]) < count(a[t], a[t-1]))) {
			t--;
		}
		t++;
		a[t]=p[i];
		a[t].tk=count(a[t], a[t-1]);
	} while(i != 1 || t <= 1);
	
	miny=inf;
	a[1].tk = -0.1;
	for(i=2; i <= t; i++) {
		miny=min(miny, count_ans(i));
	}
	
	printf("%.2lf\n", miny);
	return 0;
}
```

另外呢，将军退火，性行淑均，适用于昔日，评测机称之曰90，愚以为此做题之法，仅供观赏，诸将切勿惫怠。

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<ctime>
using namespace std;

const int maxn = 100005;
const double maxl = 200000000;
const double pai = 3.14159;
const double delta=0.9;

int n;
double a[maxn], b[maxn], t;
double ansp, ansk;
int ts;

double count(double k) {
    int i;
    double ll, maxx=-maxl, minn=maxl;
    
    for(i=1; i <= n; ++i) {
        ll=k*a[i]-b[i];
        minn=min(minn, ll);
        maxx=max(maxx, ll);
    }
    
    maxx=maxx/sqrt(k*k+1);
    minn=minn/sqrt(k*k+1);
    
    return (maxx-minn)/2;
}

void SA() {
    double kk=ansk;
    double tk, newp;
    t=1777;
    while(t > 1e-14) {
        tk=kk+(rand()*2.0-RAND_MAX)*1.0/10000*t;
        newp=count(tan(tk));
        //cout<<tk<<' '<<newp<<endl;
        //cin>>ts;
        
        if(newp < ansp) {
            kk=tk;
            ansk=tk;
            ansp=newp;
        }
        else if(exp(-(newp-ansp)*1000/t)*RAND_MAX > rand()) {
            kk=tk;
        }
        t*=delta;
    }
    return;
}

int main() {
    srand(time(NULL));
    scanf("%d", &n);
    //cout<<RAND_MAX<<endl;
    int i;
    double pi, tt, stt;
    for(i=1; i <= n; ++i) {
        scanf("%lf%lf", &a[i], &b[i]);
    }
    //cout<<count(1)<<endl;
    
    ansk=0;
    ansp=count(tan(ansk));
    for(pi=-1.6; pi <= 1.6; pi+=0.01) {
        tt=count(tan(pi));
        if(tt < ansp) {
            ansp=tt;
            ansk=pi;
        }
    }
    
    stt=ansk;
    for(pi=stt-0.1; pi <= stt+0.1; pi+=0.001) {
        tt=count(tan(pi));
        if(tt < ansp) {
            ansp=tt;
            ansk=pi;
        }
    }
    
    stt=ansk;
    for(pi=stt-0.01; pi <= stt+0.01; pi+=0.0001) {
        tt=count(tan(pi));
        if(tt < ansp) {
            ansp=tt;
            ansk=pi;
        }
    }
    
    stt=ansk;
    for(pi=stt-0.001; pi <= stt+0.001; pi+=0.00001) {
        tt=count(tan(pi));
        if(tt < ansp) {
            ansp=tt;
            ansk=pi;
        }
    }
    
    SA();
    
    printf("%.2lf\n", ansp);
    return 0;
}
```

---

## 作者：pigeonteam (赞：2)

首先吐槽一句，为什么题解区没有正解。   
题面简述：在二维平面上有 $n$ 个点，求一条线到所有点的距离最小，并输出最小距离。  
不难发现，这其实是一个旋转卡壳，只不过求的东西似乎和板子不太一样。  
我们可以在求出凸包以后对于每一个相邻点对求出以这两个点为底边到另外的点构成的三角形的最大高。  
答案就是所有最大高的最小值除以二（原因看代码注释）。  
然后就是这道题卡精度，需要开 ```long double```。  
下面是代码：  
``` cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldouble;
typedef double db;
#define double long double

const double pi = 3.141592653589793l; // 基本上oi里这个精度就够了

struct point
{
    double x, y, arctan;
    point() {}
    point(double x, double y) : x(x), y(y) {}
    double atan(point &rhs) // 顺时针弧度
    {
        arctan = atan2(y - rhs.y, x - rhs.x);
        return arctan < 0 ? arctan += 2 * pi : arctan;
    }
    double operator-(point &rhs) const // 获取两个点之间的距离
    {
        double temp_x = x - rhs.x;
        double temp_y = y - rhs.y;
        return sqrt(temp_x * temp_x + temp_y * temp_y); // 勾股定理
    }
    friend ostream &operator<<(ostream &out, point &rhs)
    {
        out << '{' << rhs.x << ", " << rhs.y << '}';
        return out;
    }
};

vector<point> g;
int n;

inline void tubao()
{
    for (auto &i : g)
        i.atan(*g.begin());
    sort(g.begin() + 1, g.end(), [](point &a, point &b) -> bool
         { return a.arctan < b.arctan; }); // 按弧度排序
    vector<point> ans;
    for (auto &i : g)
    {
        while (ans.size() > 1)
        {
            i.atan(*ans.rbegin());
            ans.rbegin()->atan(*(ans.rbegin() + 1));
            if (i.arctan - ans.rbegin()->arctan <= -1e-12l)
                ans.pop_back();
            else
                break;
        }
        ans.emplace_back(i);
    }
    ans.swap(g); // g数组变成了凸包上的点
    // 由于vector内部是指针，所以swap是O(1)的
}

double get_min_maxlen() // 旋转卡壳
{
    auto get_len = [](point &a, point &b, point &c) -> double
    {
        double len_down = a - b;
        double len1 = a - c;
        double len2 = b - c;
        double p = (len_down + len1 + len2) / 2;
        double siz = sqrt(p * (p - len_down) * (p - len1) * (p - len2)); // 海伦公式
        double lenth = (siz * 2) / len_down;                             // c点到a,b所成线段的距离
        return lenth;                                                    // 别看定义了这么多变量，我们要相信编译器的优化
    };

    double ans(1e200l); // 将答案赋值为一个极大值
    size_t len = g.size();
    auto it = g.begin() + 2;
    for (int i = 1; i < len; ++i)
    {
        while (1)
        {
            if (get_len(g[i - 1], g[i], *it) - get_len(g[i - 1], g[i], *(it + 1 == g.end() ? g.begin() : it + 1)) < -1e-12l)
            {
                ++it;
                if (it == g.end())
                    it = g.begin();
            }
            else
                break;
        }
        ans = min(ans, get_len(g[i - 1], g[i], *it));
    }
    // 特别处理第一个和最后一个
    while (1)
    {
        if (get_len(*g.begin(), *g.rbegin(), *it) - get_len(*g.begin(), *g.rbegin(), *(it + 1 == g.end() ? g.begin() : it + 1)) < -1e-12l)
        {
            ++it;
            if (it == g.end())
                it = g.begin();
        }
        else
            break;
    }
    ans = min(ans, get_len(*g.begin(), *g.rbegin(), *it));
    return ans;
}

int main()
{
    scanf("%d", &n);
    g.reserve(n);
    for (int i = 0; i < n; ++i)
    {
        db x, y;
        scanf("%lf%lf", &x, &y);
        g.emplace_back(x, y);
    }

    sort(g.begin(), g.end(), [](point &a, point &b) -> bool
         { return a.y == b.y ? a.x > b.x : a.y < b.y; }); // 用lambda或重载运算符会比传入函数快

    // 二维凸包
    tubao();

    printf("%.2lf\n", (db)(get_min_maxlen() / 2)); // 距离最小的直线垂直平分最短直径
    return 0;
}
```

---


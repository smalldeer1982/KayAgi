# [ZJOI2007] 粒子运动

## 题目描述

阿Q博士正在观察一个圆形器皿中的粒子运动。不妨建立一个平面直角坐标系，圆形器皿的圆心坐标为$(x_0, y_0)$，半径为$R$。器皿中有若干个粒子，假设第$i$个粒子在时刻$0$的位置为$(x_i, y_i)$，速度为$(v_{x_i},v_{y_i})$（注：这是一个速度向量，若没有发生碰撞，$t$时刻的位置应该是$(x_i + t * v_{x_i}, y_i + t * v_{y_i})$ ）。假设所有粒子的运动**互不干扰**；若某个粒子在某个时刻碰到了器皿壁，将发生完全弹性碰撞，即速度方向按照碰撞点的切线镜面反射，且速度大小不变（如图）。认为碰撞是瞬间完成的。

![particle](https://cdn.luogu.com.cn/upload/pic/22046.png)

尽管碰撞不会影响粒子的速率，但是粒子却会受到一定的伤害，所以若某一个粒子碰撞了$k$次器皿壁，那么在第$k$次碰撞时它便会消亡。

出于研究的需要，阿Q博士希望知道从时刻$0$到所有粒子都消亡这段时间内，所有粒子之间的最近距离是什么。你能帮助他么？

## 说明/提示

对于所有的数据，$2 \leq N \leq 100$。$1 \leq k \leq 100$。

请注意实数精度问题。

## 样例 #1

### 输入

```
0 0 10
2 10
0 -5 0 1
5 0 1 0```

### 输出

```
7.071```

# 题解

## 作者：liaohaoping (赞：4)

这题数据范围并不大，显然不用什么复杂的优化，求出每个粒子每段（这里简称某粒子两次碰撞之间的部分为一段，包括时刻0到第一次碰撞）的信息就行了，通过观察可发现，只需要处理好以下三个问题（为了方便，我们把所有坐标分别减去圆心的坐标，再把圆心的坐标改为(0,0)）：

1、某粒子在某段与圆下次碰撞的位置

2、某粒子在某次碰撞后vx,vy的变化

3、粒子a的某一段与粒子b的某一段（保证某一时刻这两段同时存在）的历史最近距离

先看问题1，若此段起始点为(stx,sty)，速度为(vx,vy)，设碰撞时间为t，则(stx+vx·t)²+(sty+vy·t)²=r² → stx²+vx²·t²+2·stx·vx·t+sty²+vy²·t²+2·sty·vy·t-r²=0 → (vx²+vy²)·t²+(2·stx·vx+2·sty·vy)·t+(stx²+sty²-r²)=0，我们设a=vx²+vy²,b=2·stx·vx+2·sty·vy,c=stx²+sty²-r²，则t=-b+sqrt(b²-4ac)/2a（舍去小解，小解一定不成立），再通过t算出位置即可。

问题2也不难想，若与圆的碰撞点为(x,y)，原速为(x1,x2)，反弹后为(x2,y2)，不难得出atan2(x2,y2)-atan2(x,y)=atan2(x,y)-atan2(x1,y1)（角相等），即atan2(x2,y2)=2·atan2(x,y)-atan2(x1,y1)，设k=x2/y2，则k=tan(2·atan2(x,y)-atan2(x1,y1))，因为速度相同，所以x1²+y1²=x2²+y2²，设z=x1²+y1²，则y2²+k²·y2²=z → (k²+1)·y2²=z → y2=sqrt(x1²+y1²/k²+1)，然后通过y2求出x2，需要注意的是，(-x2,-y2)在这里同样成立，我们可以通过带入一个点判断是否在圆内来判断取哪个解。

问题3稍微难一点，为了方便，我们设tt=max(t1,t2)（t1,t2分别为两段开始的时刻），若(x1,y1)，(x2,y2)分别为tt时刻两粒子的坐标，(vx1,vy1)，(vx2,vy2)分别为两段的速度，y为两粒子间距离的平方，y=((x1+vx1·t)-(x2+vx2·t))²+((y1+vy1·t)-(y2+vy2·t))² → y=((x1-x2)+(vx1-vx2)·t)²+((y1-y2)+(vy1-vy2)·t)²我们设xx=x1-x2,yy=y1-y2,vx=vx1-vx2,vy=vy1-vy2，那么y=(xx+vx·t)²+(yy+vy·t)² → y=xx²+vx²·t²+2·xx·vx·t+yy²+vy²·t²+2·yy·vy·t → y=(vx²+vy²)·t²+(2·xx·vx+2·yy·vy)·t+(xx²+yy²)，再设a=vx²+vy²,b=2·xx·vx+2·yy·vy,c=xx²+yy²，然后求出最小值y3=4ac-b²/4a即为历史最近距离，特殊情况特判一下就行了。

我们一开始先用1、2点处理出每个粒子的每一段，再两个两个粒子求历史最近距离，找最小值即为答案。

**代码**

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read()
{
	int x=0,w=0;char ch=getchar();
	while(ch<'0'||ch>'9')w|=ch=='-',ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return w?-x:x;
}
struct line{double stx,sty,vx,vy,edt;};
struct particle{line f[110];}p[110];
int n,k;double r,z=0.000000001;
inline void get_p(int i,int j,double stx,double sty,double vx,double vy)
{
	p[i].f[j].stx=stx,p[i].f[j].sty=sty,p[i].f[j].vx=vx,p[i].f[j].vy=vy;
	double a=vx*vx+vy*vy,b=2*stx*vx+2*sty*vy,c=stx*stx+sty*sty-r*r;
	double t=(-b+sqrt(b*b-4*a*c))/(2*a);
	p[i].f[j].edt=p[i].f[j-1].edt+t;//求碰撞点 
	if(j<k)
	{
		double edx=stx+vx*t,edy=sty+vy*t;
		double kk=tan(atan2(edx,edy)*2-atan2(vx,vy));
		double vy2=sqrt((vx*vx+vy*vy)/(kk*kk+1)),vx2=kk*vy2;
		double tt=sqrt(r)/100000/((vx2+vy2)/2);tt=tt<0?-tt:tt;
		double xx=(edx+vx2*tt),yy=(edy+vy2*tt);
		if(xx*xx+yy*yy>=r*r)vx2=-vx2,vy2=-vy2;
		get_p(i,j+1,edx,edy,vx2,vy2);//反弹 
	}
}
inline double dis(double x1,double y1,double x2,double y2)
{
	if(x1==x2&&y1==y2)return 0;
	double x=x1-x2,y=y1-y2;
	return sqrt(x*x+y*y);
}
int main()
{
	register double xx,yy;register int i,j,ii,jj;
	scanf("%lf%lf%lf",&xx,&yy,&r);n=read(),k=read();
	for(i=1;i<=n;++i)
	{
		double x,y,vx,vy;scanf("%lf%lf%lf%lf",&x,&y,&vx,&vy);
		x-=xx;y-=yy;p[i].f[0].edt=0;get_p(i,1,x,y,vx,vy);
	}
	double ans=1e50;
	for(i=2;i<=n;++i)
	{
		for(j=1;j<i;++j)
		{
			jj=1;
			for(ii=1;ii<=k;++ii)//第一个粒子处于第ii段 
			{
				--jj;
				while(p[i].f[ii].edt>p[j].f[jj].edt&&jj<k)//判断为了使有某时刻两段（ii，jj+1）同时存在，ii是否需要++
				{
					++jj;
					double t1=p[i].f[ii-1].edt,t2=p[j].f[jj-1].edt;
					double x1=p[i].f[ii].stx,x2=p[j].f[jj].stx,y1=p[i].f[ii].sty,y2=p[j].f[jj].sty;
					double vx1=p[i].f[ii].vx,vx2=p[j].f[jj].vx,vy1=p[i].f[ii].vy,vy2=p[j].f[jj].vy;
					if(vx1==vx2&&vy1==vy2)//如果速度，方向相等，进行特殊处理 
					{
						double t=max(t1,t2),xx1=x1+vx1*(t-t1),xx2=x2+vx2*(t-t2),yy1=y1+vy1*(t-t1),yy2=y2+vy2*(t-t2);
						ans=min(ans,dis(xx1,yy1,xx2,yy2));
					}
					else
					{
						double xx1=x1+vx1*(t1<t2?t2-t1:0),xx2=x2+vx2*(t1>t2?t1-t2:0),yy1=y1+vy1*(t1<t2?t2-t1:0),yy2=y2+vy2*(t1>t2?t1-t2:0);
						double vx=vx1-vx2,vy=vy1-vy2;xx=xx1-xx2,yy=yy1-yy2;
						double a=vx*vx+vy*vy,b=2*xx*vx+2*yy*vy,c=xx*xx+yy*yy;
						double t=-(b/(2*a));
						if(t<0)ans=min(ans,dis(xx1,yy1,xx2,yy2));//如果t<0，取最近的合法值(t=0) 
						else if(t+max(t1,t2)>=p[i].f[ii].edt+z||t+max(t1,t2)>=p[j].f[jj].edt+z)//如果该时刻超出任意一段范围，取最近的合法值 
						{
							t=min(p[i].f[ii].edt,p[j].f[jj].edt),xx1=x1+vx1*(t-t1),xx2=x2+vx2*(t-t2),yy1=y1+vy1*(t-t1),yy2=y2+vy2*(t-t2);
							ans=min(ans,dis(xx1,yy1,xx2,yy2));
						}
						else//否则正常计算 
						{
							double d=sqrt((4*a*c-b*b)/(4*a));
							ans=min(ans,d);
						}
					}//求距离 
				}
			}
		}
	}
	printf("%.3lf",ans);
	return 0;
}
```

---

## 作者：GoPoux4 (赞：2)

刚学计算几何，来写一篇题解。

---

先考虑一个粒子的运动情况。

若不考虑碰撞，一个粒子将会沿着一条射线运动，于是可以记录两个量来表示一个粒子：起始点 $p$ 和速度 $\vec{v}$。这样表示有一个非常好用的东西：$t$ 时刻粒子所在的位置 $p'$ 所表示的向量 $\vec{p'}=\vec{p}+t\vec{v}$。

当发生碰撞时，有下面这张图：

![dPwEwV.jpg](https://s1.ax1x.com/2020/08/14/dPwEwV.jpg)

此时 $p$ 在圆上，碰撞前的速度为 $v$ ，碰撞后的速度为 $v_1$ ，$v_2$ 由 $v_1$ 平移而来。我们需要将 $v$ 旋转 $2\alpha$ 至 $v_2$。$\alpha$ 不难由 $v,p$ 算出：
$$
{\rm{sin}}\ \alpha={\rm{cos}}\ \beta=\frac{\vec{p} * \vec{v}}{|\vec{p}||\vec{v}|}
$$
$$
{\rm{cos}}\ \alpha={\rm{sin}}\ \beta=\frac{\vec{p} \times \vec{v}}{|\vec{p}||\vec{v}|}
$$
由三角恒等变换得：
$$
{\rm{sin}}\ 2\alpha=2\ {\rm{sin}}\ \alpha\ {\rm{cos}}\ \alpha
$$
$$
{\rm{cos}}\ 2\alpha={\rm{cos}}^2\ \alpha-{\rm{sin}}^2\ \alpha
$$
向量旋转有公式，直接贴上：

$v=(x,y)$ 逆时针旋转 $\alpha$ 得到 $v'=(x\ {\rm{cos}}\ \alpha-y\ {\rm{sin}}\ \alpha,y\ {\rm{cos}}\ \alpha+x\ {\rm{sin}}\ \alpha)$。

---

不难发现，最近距离**只与两个粒子**有关，于是可以枚举两个粒子 $a,b$，单独考虑它们的运动情况。

设粒子 $a$ 的起始点为 $p_a$，速度为 $\vec{v_a}$ ，粒子 $b$ 的起始点为 $p_b$，速度为 $\vec{v_b}$ ，运动时间为 $t$，粒子间距离表示为矢量 $\vec{dis}$，则有：
$$
\vec{dis}=(\vec{p_a}+t\vec{v_a})-(\vec{p_b}+t\vec{v_b})=(\vec{p_a}-\vec{p_b})+t(\vec{v_a}-\vec{v_b})=(x_p+tx_v,y_p+ty_v)
$$
粒子间距离即为 $|\vec{dis}|$，有：
$$
|\vec{dis}|=\sqrt{(x_p+tx_v)^2+(y_p+ty_v)^2}=\sqrt{(x_v^2+y_v^2)t^2+2t(x_px_v+y_py_v)+x_p^2+y_p^2}
$$
这个二次函数在对称轴取到最小值，即：
$$
t=-\frac{x_px_v+y_py_v}{x_v^2+y_v^2}
$$
代入原方程：
$$
|\vec{dis}|=\sqrt{\frac{(x_px_v+y_py_v)^2}{x_v^2+y_v^2}-\frac{2(x_px_v+y_py_v)^2}{x_v^2+y_v^2}+x_p^2+y_p^2}
$$
$$
=\frac{\sqrt{(x_p^2+y_p^2)(x_v^2+y_v^2)-(x_px_v+y_py_v)^2}}{\sqrt{x_v^2+y_v^2}}
$$
$$
=\frac{\sqrt{x_p^2y_v^2+y_p^2x_v^2-2x_py_px_vy_v}}{\sqrt{x_v^2+y_v^2}}
$$
$$
=\frac{x_py_v-y_px_v}{\sqrt{x_v^2+y_v^2}}
$$
$$
=\frac{\vec{p}\times\vec{v}}{len(\vec{v})}
$$

这样就能够轻松地求出两个粒子的最小距离。

但是这样算还有一个小问题：$t$ 有取值范围，不一定能取到对称轴，即二次函数在 $t$ 的取值范围上是单调的。这个问题会在 $a,b$ 的运动轨迹不相交时出现，特判一下这种情况即可。

---

Code:

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#define maxn 105
#define Rint register int
#define INF 0x3f3f3f3f
using namespace std;
typedef long long lxl;
const double eps=1e-9;

template <typename T>
inline T read()
{
	T x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

inline bool zero(double x) {return fabs(x)<eps;}

struct Point
{
	double x,y;
	inline Point(double x=0,double y=0):x(x),y(y){}
	inline Point operator + (const Point &T)const// 加
	{
		return Point(x+T.x,y+T.y);
	}
	inline Point operator - ()const// 取负
	{
		return Point(-x,-y);
	}
	inline Point operator - (const Point &T)const// 减
	{
		return *this+(-T);
	}
	inline Point operator * (const double &a)const// 数乘
	{
		return Point(x*a,y*a);
	}
	inline Point operator / (const double &a)const// 数除
	{
		return Point(x/a,y/a);
	}
	inline double operator * (const Point &T)const// 点乘
	{
		return x*T.x+y*T.y;
	}
	inline double operator % (const Point &T)const// 叉乘
	{
		return x*T.y-y*T.x;
	}
	inline double len() {return sqrt((*this) * (*this));}// 向量长度
	inline void rotate(double cosa,double sina)// 向量旋转 a 角度
	{
		(*this)=Point(x*cosa-y*sina,x*sina+y*cosa);
	}
	inline Point unit()// 同方向的单位向量
	{
		return (*this)/(*this).len();
	}
	inline void read()
	{
		scanf("%lf%lf",&x,&y);
	}
};

typedef Point Vec;// 向量的坐标表示

struct node
{
	Point p;// 起始点
	Vec v;// 速度
	double t,T;// t:还需多久发生碰撞 T:走过该方向的割线所需时间
	int cnt;// 碰撞次数
}A[maxn];

Point cir;
double R,ans=INF;
int n,k;

inline void calcu(node &a)
{
	double v=a.v.len();// 速率
	double d=fabs(a.p%a.v)/v;// 圆心到直线的距离
	double m=sqrt(R*R-d*d);// 割线长度的一半
	a.T=2*m/v;
	a.t=(m+a.v.unit()*(-a.p))/v;
}

inline void flip(node &a)// 碰撞
{
	double len=a.p.len()*a.v.len();
	double sn=a.p*a.v/len,cs=(a.p%a.v)/len;
	double sina=2*sn*cs,cosa=cs*cs-sn*sn;
	a.v.rotate(cosa,sina);
}

inline void update(Point pa,Point pb,Vec va,Vec vb)
{
	if((pa-pb)*(vb-va)>0&&(pa+va-pb-vb)*(va-vb)>0)// 特判不相交
		ans=min(ans,fabs((pa-pb)%(vb-va))/(vb-va).len());
	else ans=min(ans,min((pa-pb).len(),(pa+va-pb-vb).len()));
}

inline void solve(node a,node b)
{
	double t;
	Vec v1,v2;
	while(a.cnt<k&&b.cnt<k)
	{
		t=min(a.t,b.t);
		a.t-=t;b.t-=t;
		v1=a.v*t,v2=b.v*t;
		update(a.p,b.p,v1,v2);
		a.p=a.p+v1,b.p=b.p+v2;
		if(zero(a.t)) flip(a),a.t=a.T,++a.cnt;
		if(zero(b.t)) flip(b),b.t=b.T,++b.cnt;
	}
}

int main()
{
	// freopen("P4682.in","r",stdin);
	cir.read();scanf("%lf",&R);
	n=read<int >(),k=read<int >();
	for(int i=1;i<=n;++i)
	{
		A[i].p.read(),A[i].v.read();
		A[i].p=A[i].p-cir;
		calcu(A[i]);
	}
	for(int i=1;i<=n;++i)
		for(int j=i+1;j<=n;++j)
			solve(A[i],A[j]);
	printf("%.3lf\n",ans);
	return 0;
}

```



---

## 作者：nofind (赞：0)

## [题意](https://www.luogu.com.cn/problem/P4682)

发现数据范围很小，我们可以求出每个点的轨迹以及各个状态的时间段，之后枚举两个点判断。

假设当前点为$A(x_1,y_1)$，速度向量为$AB(v_x,v_y)$，圆心为$O(x_0,y_0)$，半径为$R$，$\vec{AB}$与圆交点为$C$。
![](https://cdn.luogu.com.cn/upload/image_hosting/opz6f594.png)
我们现在要求$C$，实际上要求从$A$走了多久到$C$，设为$t$。  
$\vec{OA}+\vec{AC}=\vec{OC}$  
$\vec{OA}+t\vec{AB}=\vec{OC}$  
$(\vec{OA}+t\vec{AB})^2=\vec{OC}^2$  
$\vec{AB}^2t^2+2\vec{OA}\vec{AB}t+\vec{OA}^2=R^2$  
解出$t$即可，这样我们就可以知道每个粒子的移动过程。  

我们枚举每对粒子$(i,j)$计算它们之间距离的最小值来更新答案。

假设当前$i$在$a$，$j$在$b$，$i$的速度向量为$v_1$，$j$的速度向量为$v_2$。

我们将$(i,j)$的距离表示为一个二次函数：$dis(i,j)=dis(a+tv_1,b+tv_2)=\sqrt{(a+tv_1-(b+tv_2))^2}$  

我们二次函数求最值即可。

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=110;
const int maxm=110;
const double eps=1e-8;
const double inf=1e18;
int n,m;
double R,ans=inf;
double tim[maxn][maxm];
struct Point
{
    double x,y;
    inline double len(){return sqrt(x*x+y*y);}
    Point operator+(const Point a)const{return (Point){x+a.x,y+a.y};}
    Point operator-(const Point a)const{return (Point){x-a.x,y-a.y};}
    Point operator*(const double k){return (Point){x*k,y*k};}
    Point operator/(const double k){return (Point){x/k,y/k};}
    double operator*(const Point a)const{return x*a.y-y*a.x;}
    double operator^(const Point a)const{return x*a.x+y*a.y;}
};
inline int dcmp(double x)
{
    if(fabs(x)<=eps)return 0;
    return x<0?-1:1;
} 
inline Point get(Point a,Point b){return b-a;}
Point O;
Point p[maxn][maxm],v[maxn][maxm];
inline double calc(double a,double b,double c){return (-b+sqrt(b*b-4*a*c))/a/2.0;}//解一元二次方程。 
inline bool check(Point a,Point b,Point c){return dcmp(get(b,c)*get(b,a))>=0;}//判断a是否在bc左边。 
inline Point turn(Point a,int op){return (op==1)?(Point){a.y,-a.x}:(Point){-a.y,a.x};}//根据a在bc左右旋转90度。 
inline Point change(Point a,Point b,Point c)//求a关于bc的对称点。 
{
	double h=fabs(get(a,b)*get(a,c))/get(b,c).len();
	Point dir=check(a,b,c)?turn(get(b,c),1):turn(get(b,c),2);
	return a+dir*(2.0*h/dir.len());
}
inline double work(double a,double b,double c,double x){return a*x*x+b*x+c;}
inline double solve(int i,int j,int now1,int now2,double tl,double tr)
{
	Point v1=v[i][now1],v2=v[j][now2];
	Point p1=p[i][now1]+v1*(tl-tim[i][now1]),p2=p[j][now2]+v2*(tl-tim[j][now2]);
	Point tp=p1-p2,tv=v1-v2;
	double a=tv^tv,b=(tv^tp)*2,c=tp^tp,len=tr-tl;
	if(!dcmp(a))return b>0?sqrt(work(a,b,c,0)):sqrt(work(a,b,c,len));
	else  
	{
		double x=max(0.0,min(-b/a/2,len));
		return sqrt(work(a,b,c,x));
	}
}
int main()
{
	//freopen("test.in","r",stdin);
	//freopen("test.out","w",stdout);
	scanf("%lf%lf%lf",&O.x,&O.y,&R);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%lf%lf%lf%lf",&p[i][0].x,&p[i][0].y,&v[i][0].x,&v[i][0].y);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m+1;j++)
		{
			Point tp=p[i][j-1]-O,tv=v[i][j-1];
			double t=calc(tv^tv,(tp^tv)*2,(tp^tp)-R*R);
			tim[i][j]=tim[i][j-1]+t;
			p[i][j]=p[i][j-1]+tv*t;
			v[i][j]=get(p[i][j],change(p[i][j-1],O,p[i][j]));
			v[i][j]=(v[i][j]/v[i][j].len())*v[i][j-1].len();
		}
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
		{
			int now1=0,now2=0;
			while(now1<=m&&now2<=m)
			{
				ans=min(ans,solve(i,j,now1,now2,max(tim[i][now1],tim[j][now2]),min(tim[i][now1+1],tim[j][now2+1])));
				if(dcmp(tim[i][now1+1]-tim[j][now2+1])<0)now1++;
				else now2++;
			}
		}
	printf("%.3lf",ans);
	return 0;
} 
```


---


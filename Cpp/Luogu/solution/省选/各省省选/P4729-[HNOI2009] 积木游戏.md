# [HNOI2009] 积木游戏

## 题目描述

丹丹是一位狂热的俄罗斯方块爱好者，但在把积分刷爆之后她终于开始感到厌倦了。于是她着手思考这样一个俄罗斯方块的简化版游戏：在初始状态地面上是空的。假设所有的积木都是长方形，且积木不能旋转或翻转。丹丹在每个时刻会选择一个位置将一块积木落下，当积木在落下的过程中碰到地面或另一块积木时，它会停留在地面上或那块积木上。落到另—块积木上意味着：上面的积木的下边界与下面的积木的上边界至少有一条线段重合(―个点不算)，如图 1 所示。

![图1](https://cdn.luogu.com.cn/upload/pic/22107.png)

在俄罗斯方块中，如果某个时刻积木之间形成了一个洞，那么看上去就很不优美。于是丹丹想知道，每落下一块积木之后，会形成几个新的洞。一个洞是指由积木的边界或地面组成的一块面积大于 $0$ 的封闭的区域，如图 2（a）和图 2（b）所示。

要注意的是：当出现图 3 所示的情况时，因为积木 1 和积木 2 紧紧地挨在一起，所以当积木 3 落下的时候，不会形成新的洞。

现在丹丹告诉你她依次落下的积木的髙度 $H_i$ 以及落下的位置的左右边界 $L_i$ 与 $R_i$，$1 \leq i \leq n$，而她想知道毎次积木落下时会形成几个新的洞？

![图23](https://cdn.luogu.com.cn/upload/pic/22108.png)

## 说明/提示

**【数据范围】**

输入数据保证 $0 \leq L_i < R_i \leq 100000, H_i \leq 1000$。

$30\%$ 的数据保证 $n \leq 100$。

$100\%$ 的数据保证$n \leq 100000$。

**【样例说明】**

样例执行后的结果如图 4 所示，其中依次落下的积木按顺序编号为从 $1$ 到 $6$ 的一个整数。

![图4](https://cdn.luogu.com.cn/upload/pic/22110.png)

## 样例 #1

### 输入

```
6
1 3 2
4 7 2
2 5 1
3 6 1
8 11 2
6 8 3```

### 输出

```
0
0
1
0
0
2```

# 题解

## 作者：bzy (赞：36)

这大概是全网唯一靠谱的题解了。

写在纸上，字很丑，先凑合一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/32gcq5zm.png)

附 C++ 源代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int n, flag; 

int max( int a, int b, int c )
  { return max( a, max( b, c ) ); }

int max( int a, int b, int c, int d )
  { return max( a, max( b, c, d ) ); }

bool cross( int a, int b, int x, int y )
  { return max( a, x ) <= min(b, y); } 

namespace SGT{
    #define ls ( x << 1 )
    #define rs ( ls | 1 )
    #define mid ( ( l[x] + r[x] ) >> 1 )
    #define Lrange ls, L, min( mid, R )
    #define Rrange rs, max( mid + 1, L ), R
    int l [100005 << 2];
    int r [100005 << 2];
    int mx[100005 << 2];
    int mk[100005 << 2];
    
    void push_up( int x ) { mx[x] = max( mx[ls], mx[rs] ); }
    
    void push_down( int x )
      { mk[ls] = max( mk[ls], mk[x]);
        mk[rs] = max( mk[rs], mk[x]);
        if( mx[ls] < mk[ls] ) mx[ls] = mk[ls];
        if( mx[rs] < mk[rs] ) mx[rs] = mk[rs]; }

    void build( int x, int L, int R ) 
      { l[x] = L, r[x] = R;
        if( L == R ) return ;
        build( Lrange ); build( Rrange ); }
    
    void modify( int x, int L, int R, int V ) 
      { if( l[x] == L and r[x] == R ) return mk[x] = max( mk[x], V ), mx[x] = max( V, mx[x] ), void(); push_down(x);
        if( L <= mid ) modify( Lrange, V );
        if( R >  mid ) modify( Rrange, V );
        push_up(x); }
    
    int query( int x, int L, int R ) 
      { if( l[x] == L and r[x] == R ) return mx[x];
        push_down(x);
        if( R <= mid ) return query( Lrange );
        if( L >  mid ) return query( Rrange );
        return max( query( Lrange ), query( Rrange ) ); }
}

int cnt[100005];

namespace GRP{
	vector<int> to1[100005]; 
	vector<int> to2[100005];
	int deg[100005];
	int tag[100005];
	map< pair<int, int>, bool > MP;
	
	void addEdge( int u, int v )
	  { if( MP[ make_pair( u, v ) ] or MP[ make_pair( v, u ) ] ) return ;
	    MP[ make_pair( u, v ) ] = 1;
	    to1[u].push_back(v); deg[u] ++;
	    to1[v].push_back(u); deg[v] ++; }
	
	void countTriangle() 
	  { for( int i = 0; i <= n; i ++ ) for( int j : to1[i] )
	      { if( deg[i] > deg[j] or ( deg[i] == deg[j] and i > j ) ) 
		      { to2[i].push_back(j); }
		  }
		  
		for( int i = 0; i <= n; i ++ )
		  { for( int j : to2[i] ) tag[j] = i + 1;
		    for( int j : to2[i] ) for( int k : to2[j] ) if( tag[k] == i + 1 ) 
			  { cnt[ max( i, j, k ) ] --; } 
		  }
	  }
	  
	void flush( int x )
	  { for( int i : to1[x] ) if( i < x ) cnt[x] ++; cnt[x] --; }
}

struct Rect
  { int l, r, b, t, h, id;
    void get( int _id )
      { id = _id; cin >> l >> r >> h; }
  } R[100005], T[100005];

bool cmp1( Rect& A, Rect& B ) { return A.l == B.l ? A.b < B.b : A.l < B.l; }
bool cmp2( Rect& A, Rect& B ) { return A.r == B.r ? A.b < B.b : A.r < B.r; }
bool cmp3( Rect& A, Rect& B ) { return A.b == B.b ? A.l < B.l : A.b < B.b; }
bool cmp4( Rect& A, Rect& B ) { return A.t == B.t ? A.l < B.l : A.t < B.t; }

struct Point
  { int x, y, id;
  	Point( int _x, int _y, int _id )
  	  : x(_x), y(_y), id(_id) { }
  	bool operator <( const Point& F )
	  { return x == F.x ? y < F.y : x < F.x; } 
	bool operator ==( const Point& F )
	  { return x == F.x and y == F.y; }
  } ;

vector<Point> VP; 

int main(){
    cin >> n;

    SGT::build( 1, 1, 100000 );	
	
    for( int i = 1; i <= n; i ++ ) R[i].get(i);
    for( int i = 1; i <= n; i ++ ) 
	  { int Q = SGT::query( 1, R[i].l + 1, R[i].r );
        R[i].b = Q; R[i].t = R[i].h + Q;
        SGT::modify( 1, R[i].l + 1, R[i].r, R[i].t ); } 
	
	for( int i = 1; i <= n; i ++ ) if( R[i].b == 0 )
	  { GRP::addEdge( 0, i ); }
	
	for( int i = 1; i <= n; i ++ ) T[i] = R[i];
	
	for( int i = 1; i <= n; i ++ ) T[i] = R[i];
	
	sort( R + 1, R + n + 1, cmp1 );
	sort( T + 1, T + n + 1, cmp2 );
	
	for( int l = 1, r = 1, p; l <= n; l ++ )
	  { while( T[r].r < R[l].l or ( T[r].r == R[l].l and T[r].t < R[l].b ) ) r ++; p = r;
		while( T[p].r == R[l].l and T[p].b <= R[l].t ) GRP::addEdge( R[l].id, T[p].id ), p ++;	}
		
	sort( R + 1, R + n + 1, cmp3 );
	sort( T + 1, T + n + 1, cmp4 );
	
	for( int l = 1, r = 1, p; l <= n; l ++ )
	  { while( T[r].t < R[l].b or ( T[r].t == R[l].b and T[r].r < R[l].l ) ) r ++; p = r;
		while( T[p].t == R[l].b and T[p].l <= R[l].r ) GRP::addEdge( R[l].id, T[p].id ), p ++;	}
	
	GRP::countTriangle();
 
	for( int i = 1; i <= n; i ++ )
	  { VP.push_back( Point( R[i].l, R[i].b, R[i].id ) );
	    VP.push_back( Point( R[i].l, R[i].t, R[i].id ) ); 
		VP.push_back( Point( R[i].r, R[i].b, R[i].id ) );
		VP.push_back( Point( R[i].r, R[i].t, R[i].id ) ); }
	
	sort( VP.begin(), VP.end() );
	
	for( int i = 0; i < (n - 1) * 4; i ++ )
	  { if( VP[i] == VP[i + 1] ) if( VP[i] == VP[i + 2] ) if( VP[i] == VP[i + 3] )
	      { cnt[ max( VP[i].id, VP[i + 1].id, VP[i + 2].id, VP[i + 3].id ) ] ++; } } 
	
	for( int i = 1; i <= n ; i ++ ) GRP::flush( i );
	for( int i = 1; i <= n ; i ++ ) cout << cnt[i] << "\n";
	
    return 0;
}
```

一些题外话：

一次偶然的机会蒟蒻 bzy 看到了这到风格古老的题，然后无聊的时候花 10min 想了出来，但应为退役太久实力退化太严重所以花了几天才实现完全。

但却实在想不明白这一道难度正常的题为何 11 年来无人问津，果然还是 HNOI 出题人太懒从不放官方题解的缘故吗?

抛开这些因素，个人认为本题很符合 HNOI 历年来的风格，是一道不错的图论题。

但在互联网时代的大浪淘沙之下，又有多少曾经璀璨的事物被人淡忘而暗自蒙尘呢?

---

## 作者：ix35 (赞：21)

$O(n\log n)$ 题解。

加入一个横坐标范围 $[x,y]$，高度为 $h$ 的矩形 $R$ 后形成的新的洞的轮廓上至少要有一条 $R$ 的边，事实上只有如下五种情况：

1. 洞的轮廓只包含 $R$ 的下边；
2. 洞的轮廓只包含 $R$ 的左边；
3. 洞的轮廓只包含 $R$ 的右边；
4. 洞的轮廓同时包含 $R$ 的左边和下边；
5. 洞的轮廓同时包含 $R$ 的右边和下边。

这是因为轮廓显然不可能包含 $R$  的上边（否则 $R$ 正上方还有别的矩形），也不可能同时包含 $R$ 的左边和右边（否则 $R$ 浮空）。

下面分别讨论这些情况。

1. 洞的轮廓只包含 $R$ 的下边：

   其一般情况如下图，一个洞 ① 从上面被 $R$ 堵住，两边也各被堵住。

   我们求出 $R$ 的横坐标范围 $[x,y]$ 的区间最大值的同时，也求出有多少段由区间最大值组成的连续段，那么两个连续段之间的部分就是一个这样的洞，而连续段数量容易在线段树上顺便维护。

   ![](https://cdn.luogu.com.cn/upload/image_hosting/n0fl7q5j.png)

2. 洞的轮廓只包含 $R$ 的左边（右边）：

   其一般情况如下图，一个洞从右边被 $R$ 堵住，上下也各被堵住。

   我们称上下被堵住，左右有一边被堵住的结构叫做“半洞”，我们发现只要考虑横坐标 $x-1$ 处的半洞即可。

   具体地，用 set 维护每个横坐标处的半洞（这个洞在对应横坐标处的上下边界），加入 $R$ 后只会在 $x,y$ 处各增加至多一个半洞（即原本的上边界到 $R$ 的下边界之间的空洞），要查询包含 $R$ 左边（右边）的新洞时只需要在 $x-1$（$y+1$）的 set 中找到 $R$ 这一段纵坐标上的半洞数量即可。

   （利用单调性，用 queue 或 vector 也可）

   ![](https://cdn.luogu.com.cn/upload/image_hosting/r0a0o333.png)

3. 洞的轮廓同时包含 $R$ 的左边（右边）和下边：

   这只是边界情况，处理 2 中的半洞和 1 中的最大值连续段的时候进行一些特判即可。

时间复杂度为 $O(n\log n)$。

---

## 作者：伊地知虹夏 (赞：2)

首先我们用一棵区间赋值查区间 $\max$ 的线段树求出每块积木落下后底边的纵坐标。

然后我们对于高度扫描线，用一棵线段树维护区间中不封口洞的个数，这可以通过维护（纵坐标，洞的个数，左边是否有空，右边是否有空）来轻松维护。

![](https://cdn.luogu.com.cn/upload/image_hosting/0gno1jh7.png)

如上图中洞 $1,2$，我们少考虑了两种情况，我们只需查询 $l_i,r_i+1$ 上的积木编号即可解决，细节并不多，时间复杂度 $\mathcal O(n\log n)$，常数略大。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,l,r) for (int i = l; i <= r; i ++)
#define rrp(i,l,r) for (int i = l; i >= r; i --)
const int N = 1e6 + 5, mod = 1e9 + 7;
bool st;
struct Sgt {
  int tg1[N << 2], tg2[N << 2], id[N << 2];
  struct val {
    int mx, cnt, l, r;
    val operator+(val o) {
      int mm = max(mx, o.mx);
      if (o.mx < mm) return {mx, cnt, l, 1};
      if (mx < mm) return {o.mx, o.cnt, 1, o.r};
      return {mm, cnt + o.cnt + (r || o.l), l, o.r};
    }
  } a[N << 2];
  void init(int c, int l, int r) {
    a[c] = {0, 0, 0, 0}, tg1[c] = tg2[c] = id[c] = 0;
    if (l == r) return ;
    int mid = l + r >> 1;
    init(c << 1, l, mid), init(c << 1 | 1, mid + 1, r);
  }
  void tag1(int c, int v) { a[c] = {v, 0, 0, 0}, tg1[c] = v; }
  void tag2(int c, int v) { id[c] = tg2[c] = v; }
  void down(int c) {
    if (tg1[c]) tag1(c << 1, tg1[c]), tag1(c << 1 | 1, tg1[c]), tg1[c] = 0;
    if (tg2[c]) tag2(c << 1, tg2[c]), tag2(c << 1 | 1, tg2[c]), tg2[c] = 0;
  }
  void upd1(int x, int y, int v, int c, int l, int r) {
    if (x <= l && r <= y) return tag1(c, v);
    int mid = l + r >> 1; down(c);
    if (x <= mid) upd1(x, y, v, c << 1, l, mid);
    if (mid < y) upd1(x, y, v, c << 1 | 1, mid + 1, r);
    a[c] = a[c << 1] + a[c << 1 | 1];
  }
  void upd2(int x, int y, int v, int c, int l, int r) {
    if (x <= l && r <= y) return tag2(c, v);
    int mid = l + r >> 1; down(c);
    if (x <= mid) upd2(x, y, v, c << 1, l, mid);
    if (mid < y) upd2(x, y, v, c << 1 | 1, mid + 1, r);
    a[c] = a[c << 1] + a[c << 1 | 1];
  }
  int qq(int p, int c, int l, int r) {
    if (l == r) return id[c];
    int mid = l + r >> 1; down(c);
    if (p <= mid) return qq(p, c << 1, l, mid);
    return qq(p, c << 1 | 1, mid + 1, r);
  }
  val qry(int x, int y, int c, int l, int r) {
    if (x <= l && r <= y) return a[c];
    int mid = l + r >> 1; down(c);
    if (y <= mid) return qry(x, y, c << 1, l, mid);
    if (mid < x) return qry(x, y, c << 1 | 1, mid + 1, r);
    return qry(x, y, c << 1, l, mid) + qry(x, y, c << 1 | 1, mid + 1, r);
  }
} T;
int n, V = 1e5, id[N], ans[N];
struct node { int l, r, h, s; } a[N];
void fakemain() {
  cin >> n;
  rep (i, 1, n) {
    cin >> a[i].l >> a[i].r >> a[i].h, id[i] = i;
    a[i].s = T.qry(a[i].l + 1, a[i].r, 1, 0, V).mx;
    T.upd1(a[i].l + 1, a[i].r, a[i].h + a[i].s, 1, 0, V);
  }
  T.init(1, 0, V);
  sort(id + 1, id + 1 + n, [&](int x, int y) { 
    return a[x].s != a[y].s ? a[x].s < a[y].s : x < y; 
  });
  rep (_, 1, n) { int i = id[_];
    auto tmp = T.qry(a[i].l + 1, a[i].r, 1, 0, V);
    ans[i] += tmp.cnt;
    if (tmp.l && T.qry(a[i].l, a[i].l, 1, 0, V).mx >= a[i].s) {
      int id = T.qq(a[i].l, 1, 0, V);
      if (a[id].s + a[id].h >= a[i].s) ans[max(i, id)] ++;
    }
    if (tmp.r && T.qry(a[i].r + 1, a[i].r + 1, 1, 0, V).mx >= a[i].s) {
      int id = T.qq(a[i].r + 1, 1, 0, V);
      if (a[id].s + a[id].h >= a[i].s) ans[max(i, id)] ++;
    }
    T.upd1(a[i].l + 1, a[i].r, a[i].s + a[i].h, 1, 0, V);
    T.upd2(a[i].l + 1, a[i].r, i, 1, 0, V);
  }
  rep (i, 1, n) cout << ans[i] << '\n';
}
bool ed;
signed main() {
cin.tie(0)->ios::sync_with_stdio(0);
  int T = 1;
  while (T --) fakemain();
  cerr << 1. * clock() / 1000000 << "s\n";
  return 0;
}
```

---


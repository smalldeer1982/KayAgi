# [AHOI2008] 矩形藏宝地

## 题目描述

欢乐岛上最著名的游戏是一个寻宝游戏，小可可来到宝藏的埋藏地，这是一块开阔地，宝藏被分散的埋藏在这块地下，现在要做的是一件件的把宝藏挖出来。为了提示宝藏的埋藏点，游戏的主办方把这块开阔地当作第一象限（包括原点和正半坐标轴），将所有可能埋藏宝藏的地方划成一个个矩形的土地，并把这些矩形土地的坐标都告诉了参赛者。挖宝的提示很简单，只要某一个矩阵土地至少被另外一个矩阵土地所包含，那么这个矩阵土地里肯定埋有宝藏。其实这些宝藏都是一些精美的纪念品，如果谁挖出来了纪念品就归谁了，小可可很想为这次旅程画上完美的句号，有你的帮助他信心十足，你只要告诉他：有多少个矩形土地里肯定埋有宝藏就行了。胜利就在眼前，加油吧！

## 说明/提示

$30\%$ 的数据中，$N\leq 5000$。

$70\%$ 的数据中，$N\leq 50000$。

$100\%$ 的数据中，$N\leq 200000$。

所有数据中，一个 $x$ 值或 $y$ 值最多出现一次。坐标范围 $2\times 10 ^ 6$。

## 样例 #1

### 输入

```
3
0 0 5 5
1 2 3 4
2 1 4 3
```

### 输出

```
2
```

# 题解

## 作者：yuzhechuan (赞：6)

放一篇（可能）比较正常的cdq题解

---

### 题解：

题意显然是一个四维偏序，然而三只log的复杂度也显然是不优秀的

注意到题目只是让我们判定某个矩形能否被其他某一个矩形包括，而不是有几对关系，因此本题可以通过某些方法简化掉一层限制

考虑若矩形$j$要对矩形$i$产生贡献，即$j$包含$i$，需要满足$x_{j2}>x_{i2}$，$y_{j2}>y_{i2}$，$x_{j1}<x_{i1}$，$y_{j1}<y_{i1}$

假设我们此时已经用排序+分治干掉前两维了，$j$此时一定会排在$i$的前面，可以想象一下$i$的右上角已经被所有在区间$[l,p]$中的矩形的右上角包住了（p是合并时的左指针，能保证其中一层限制），现在只需要判定这部分的矩形的左下角能否包住$i$的左下角就好了

由于这是连贯且起始点是定值的区间，我们对他们记一个前缀min，看看对于某个点的左半边，有没有还比他低的点，这些点就是在它的左下角的了，在满足包住右上角的同时也能包住左下角，于是就可以判定矩形$i$能被另外某个矩形包住了

前缀min是树状数组的一个经典应用，可以log解决

最后统计一下有几个矩形能被包住就是答案

另外还有一个小细节，为了优化大坐标带来的复杂度冗余，我们可以先对横纵坐标离散化一下

---

### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
template<class t> inline t read(t &x){
	char c=getchar();bool f=0;x=0;
	while(!isdigit(c)) f|=c=='-',c=getchar();
	while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
	if(f) x=-x;return x;
}
template<class t> inline void write(t x){
	if(x<0) putchar('-'),write(-x);
	else{if(x>9) write(x/10);putchar('0'+x%10);}
}


#define dc divide_and_conquer
#define xn XN
#define yn YN

const int N=2e5+5;
int ans,xn,yn,numx[N<<1],numy[N<<1],tr[N<<1],n;

struct dc{
	int x,y,xx,yy,ans;
	inline bool operator < (const dc &nt) const{ //先按右上角的x排
		return xx>nt.xx;
	}
}a[N],b[N];

#define lowbit(x) (x&(-x))

void clear(int x){ //重新赋回无穷大
	while(x<=xn){
		tr[x]=0x3f3f3f3f;
		x+=lowbit(x);
	}
}

void up(int x,int v){ //修改
	while(x<=xn){
		tr[x]=min(tr[x],v);
		x+=lowbit(x);
	}
}

int que(int x){ //查询
	int res=0x3f3f3f3f;
	while(x){
		res=min(res,tr[x]);
		x-=lowbit(x);
	}
	return res;
}

void cdq(int l,int r){
	if(l==r) return ;
	int mid=l+r>>1;
	cdq(l,mid);cdq(mid+1,r);
	int p=l,q=mid+1,i=l-1;
	while(p<=mid&&q<=r){
		if(a[p].yy>a[q].yy){ //满足右上角能包住
			up(a[p].x,a[p].y); //维护下前缀最小
			b[++i]=a[p++];
		}
		else{
			if(que(a[q].x)<a[q].y) a[q].ans=1; //若它的前面还有比他低的，就是被包住了
			b[++i]=a[q++];
		}
	}
	while(q<=r){
		if(que(a[q].x)<a[q].y) a[q].ans=1;
		b[++i]=a[q++];
	}
	for(int i=l;i<p;i++) clear(a[i].x); //复原树状数组
	while(p<=mid) b[++i]=a[p++];
	for(int i=l;i<=r;i++) a[i]=b[i];
}

signed main(){
	read(n);
	for(int i=1;i<=n;i++){
		read(a[i].x);numx[++xn]=a[i].x;
		read(a[i].y);numy[++yn]=a[i].y;
		read(a[i].xx);numx[++xn]=a[i].xx;
		read(a[i].yy);numy[++yn]=a[i].yy;
	}
	memset(tr,0x3f,sizeof tr); //初始赋无穷大
	sort(numx+1,numx+1+xn);
	sort(numy+1,numy+1+yn);
	for(int i=1;i<=n;i++){
		a[i].x=lower_bound(numx+1,numx+1+xn,a[i].x)-numx; //离散坐标
		a[i].y=lower_bound(numy+1,numy+1+yn,a[i].y)-numy;
		a[i].xx=lower_bound(numx+1,numx+1+xn,a[i].xx)-numx;
		a[i].yy=lower_bound(numy+1,numy+1+yn,a[i].yy)-numy;
	}
	sort(a+1,a+1+n);
	cdq(1,n);
	for(int i=1;i<=n;i++) ans+=a[i].ans; //统计答案
	write(ans);
}
```

---

## 作者：DinnerHunt (赞：3)

排序维护 x2 降序  
归并维护 y2 降序  
树状数组中用 x1的坐标，存y1的值  
然后树状数组求前缀和最小值与当前y1比较  

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int maxd = 2e5+10;
struct node
{
    int x1,y1,x2,y2,f;
}e[maxd];
int cmp(const node a,const node b)
{
    return a.x2 > b.x2;
}
int cmp1(const node a,const node b)
{
    return a.y2 > b.y2;
}
int fx[maxd<<1],fy[maxd<<1],totx,toty;
int t[maxd<<1],ans;
void clear(int x)
{
    for(;x<maxd*2;x+=(x&-x)) t[x] = 1e9;
}
void update(int x,int y)
{
    for(;x<maxd*2;x+=(x&-x)) t[x] = min(t[x],y);
}
int query(int x)
{
    int ans = 1e9;
    for(;x;x-=(x&-x)) ans = min(t[x],ans);
    return ans;
}
void cdq(int l,int r)
{
    if(l==r) return;
    int mid = (l+r)/2;
    cdq(l,mid),cdq(mid+1,r);
    sort(e+l,e+mid+1,cmp1); sort(e+mid+1,e+r+1,cmp1); //懒得手动归并，直接排序
    int j = l;
    for(int i=mid+1;i<=r;i++) // 此时j的x2 一定大于i的x2
    {
        if(e[i].f) continue;
        while(j <= mid&&e[j].y2 > e[i].y2) 
            update(e[j].x1,e[j].y1),j++; // 把y1插入数组x1的位置
        int tmp = query(e[i].x1); // 因为查询比 x1小的值，所以查询x1一定小于i的x1;
        if(tmp < e[i].y1) e[i].f = 1,ans++; 
    }
    while(--j>=l) clear(e[j].x1); // 重置
}
int main()
{
    // freopen("a.in","r",stdin);
    // freopen("k.out","w",stdout);
    int n;scanf("%d",&n);
    for(int i=1;i<=n;i++) 
    {
        scanf("%d %d %d %d",&e[i].x1,&e[i].y1,&e[i].x2,&e[i].y2);
        fx[++totx] = e[i].x1,fx[++totx] = e[i].x2;
        fy[++toty] = e[i].y1,fy[++toty] = e[i].y2;
    }
    sort(fx+1,fx+1+totx);sort(fy+1,fy+1+toty); //离散化 因为不存在相同的，不需要去重复
    for(int i=1;i<=n;i++)
    {
        e[i].x1 = lower_bound(fx+1,fx+1+totx,e[i].x1) - fx;
        e[i].x2 = lower_bound(fx+1,fx+1+totx,e[i].x2) - fx;
        e[i].y1 = lower_bound(fy+1,fy+1+toty,e[i].y1) - fy;
        e[i].y2 = lower_bound(fy+1,fy+1+toty,e[i].y2) - fy;
    }
    sort(e+1,e+1+n,cmp); // 第一维对右x进行排序
    for(int i=1;i<2*maxd;i++) t[i] = 1e9; // 初始化
    cdq(1,n);
    printf("%d",ans);
    return 0;
}
```


---

## 作者：Endt (赞：2)

# 矩形藏宝地-题解

多维偏序的一般题目。

### 初见

这是一个四维偏序，需要满足：$a_{x_1}< b_{x_1},a_{y_1}< b_{y_1},a_{x_2}>b_{x_2},a_{y_2}>b_{y_2}$

求四维偏序的方式有很多，但大佬们用的多重 CDQ 分治嵌套、KDTree、树套树之类都不会怎么办呢？题目给了一个关爱蒟蒻的条件：

> 一个 $x$ 值或 $y$ 值最多出现一次。

### 细节

根据 $x_1$ 排序解决第一维，CDQ 分治中根据 $x_2$ 排序解决第二维，归并时树状数组 $x_2$ 当下标解决第三维：这是普通的三位偏序。根据此题特殊条件，不需要去重，也不需要求满足偏序的对数，那么树状数组就可以维护 $y_2$ 的前缀最小值，这样就解决了第四维。

### 代码

```cpp
#include<bits/stdc++.h>

#define  Int  long long int
#define  Tem  template
#define  Pub  public

#define  Max(a,b)  ((a)>(b)?(a):(b))
#define  Min(a,b)  ((a)<(b)?(a):(b))
#define  Abs(a)  ((a)>0?(a):-(a))

int k,n;
class G{
Pub:
    int a,b,c,d;
    int ans;
}t[200005];
int cnt;
bool cmp(G x,G y){
    return x.a>y.a;
}
bool kmp(G x,G y){
    return x.b<y.b;
}
int ans[2000005];
void add(int x,int val){
    for(;x<=k;x+=x&-x)ans[x]=Min(val,ans[x]);
}
int mIn(int x){
    int A=94751836;
    for(;x;x-=x&-x)A=Min(ans[x],A);
    return A;
}
void F(int x){
    for(;x<=k;x+=x&-x)ans[x]=94751836;
}
void solve(int l,int r){
    if(l==r)return;
    int m=(l+r)/2;
    solve(l,m);
    solve(m+1,r);
    std::sort(t+l,t+m+1,kmp);
    std::sort(t+m+1,t+r+1,kmp);
    int i,j;
    for(i=l,j=m+1;i<=m&&j<=r;){
        if(t[i].b>=t[j].b){
            add(t[j].c,t[j].d);
            ++j;
        }else{
            if(t[i].d>=mIn(t[i].c))t[i].ans=1;
            ++i;
        }
    }
    for(i;i<=m;){
        if(t[i].d>=mIn(t[i].c))t[i].ans=1;
        ++i;
    }
    for(i=l,j=m+1;i<=m&&j<=r;){
        if(t[i].b>=t[j].b){
            F(t[j].c);
            ++j;
        }else ++i;
    }
}

int A;
int main(){
    k=2000000;
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        int x1,y1,x2,y2;
        scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
        ++x1,++y1,++x2,++y2;
        t[++cnt]=G{x1,y1,2000000-x2,2000000-y2,0};
    }
    std::sort(t+1,t+1+cnt,cmp);
    memset(ans,0x3f,sizeof(ans));
    solve(1,cnt);
    for(int i=1;i<=n;++i){
        if(t[i].ans==1){
            ++A;
        }
    }
    printf("%d",A);
    
    return 0;
}
```

---

## 作者：Rorschachindark (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P4793)
# 题目大意
给出 $n$ 个矩阵，问有多少个矩形满足存在一个矩形包含它。

$n\le 2\times 10^5$
# 思路
来一篇正常一点的 $\text{K-D Tree}$ 题解吧。

首先不难看出这个问题可以转换成一个偏序问题，即对于每一个 $((x_1,y_1),(x_2,y_2))$，看是否有其他矩阵满足 $px_1<x_1,py_1<y_1,px_2<x_2,py_2<y_2$。

然后我们发现我们肯定可以先按第一维排序，把第二维视作权值。问题就转换成了：

>动态加点，问在 $((x_2,+\infty),(y_2,+\infty))$ 中的权值最小值是否 $\le y_1$。

然后你发现这个东西可以使用 $\text{K-D Tree}$ 做到 $\Theta(n\sqrt n)$。跑得似乎还是挺快的。
# $\texttt{Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define INF 0x7f7f7f7f 
#define MAXN 200005

template <typename T> void read (T &x){char c = getchar ();x = 0;int f = 1;while (c < '0' || c > '9') f = (c == '-' ? -1 : 1),c = getchar ();while (c >= '0' && c <= '9') x = x * 10 + c - '0',c = getchar ();x *= f;}
template <typename T,typename ... Args> void read (T &x,Args& ... args){read (x),read (args...);}
template <typename T> void write (T x){if (x < 0) x = -x,putchar ('-');if (x > 9) write (x / 10);putchar (x % 10 + '0');}
template <typename T> void Mi (T &a,T b){a = a < b ? a : b;}
template <typename T> void Mx (T &a,T b){a = a > b ? a : b;}

int cut;
struct Vector{
	int tx[2],val;
	Vector () {}
	Vector (int _t0,int _t1,int _v){tx[0] = _t0,tx[1] = _t1,val = _v;}
	bool operator < (const Vector &p)const{return tx[cut] < p.tx[cut];}
};

struct KDTree{
#define alpha 0.97 
	Vector gift[MAXN];
	int cnt,tot,rub[MAXN];

	struct Node{
		Vector tp;int mi[2],mx[2],son[2],siz,minv;
	}tree[MAXN];
	
	int newnode (){return tot ? rub[tot --] : ++ cnt;}
	
	#define lson tree[x].son[0]
	#define rson tree[x].son[1]
	void Pushup (int x){
		tree[x].siz = 1;
		tree[x].minv = tree[x].tp.val;
		tree[x].mi[0] = tree[x].mx[0] = tree[x].tp.tx[0],
		tree[x].mi[1] = tree[x].mx[1] = tree[x].tp.tx[1];
		for (Int i = 0;i < 2;++ i) 
			if (tree[x].son[i]){
				int sn = tree[x].son[i];
				tree[x].siz += tree[sn].siz,Mi (tree[x].minv,tree[sn].minv),
				Mi (tree[x].mi[0],tree[sn].mi[0]),Mx (tree[x].mx[0],tree[sn].mx[0]),
				Mi (tree[x].mi[1],tree[sn].mi[1]),Mx (tree[x].mx[1],tree[sn].mx[1]);
			}
	}
	int build (int l,int r,int k){
		if (l > r) return 0;
		int mid = (l + r) >> 1,x = newnode ();cut = k;
		nth_element (gift + l,gift + mid,gift + r + 1);
		tree[x].tp = gift[mid],lson = build (l,mid - 1,k ^ 1),rson = build (mid + 1,r,k ^ 1);
		Pushup (x);return x;
	}
	void pia (int x,int num){
		if (lson) pia (lson,num);
		rub[++ tot] = x,gift[num + tree[lson].siz + 1] = tree[x].tp;
		if (rson) pia (rson,num + tree[lson].siz + 1);
	}
	void check (int &x,int k){
		if (tree[x].siz * alpha < tree[lson].siz || tree[x].siz * alpha < tree[rson].siz)
			pia (x,0),x = build (1,tree[x].siz,k);
	}
	void Insert (int &x,Vector tmp,int k){
		if (!x){
			x = newnode (),tree[x].tp = tmp,Pushup (x);
			return ;
		}
		if (tmp.tx[k] <= tree[x].tp.tx[k]) Insert (lson,tmp,k ^ 1);
		else Insert (rson,tmp,k ^ 1);
		Pushup (x),check (x,k);
	}
	int query (int x,Vector tmp){
		if (!x) return INF;
		if (tree[x].mx[0] < tmp.tx[0] || tree[x].mx[1] < tmp.tx[1]) return INF;
		if (tree[x].mi[0] > tmp.tx[0] && tree[x].mi[1] > tmp.tx[1]) return tree[x].minv;
		int res = INF;if (tree[x].tp.tx[0] > tmp.tx[0] && tree[x].tp.tx[1] > tmp.tx[1]) Mi (res,tree[x].tp.val);
		Mi (res,query (lson,tmp)),Mi (res,query (rson,tmp));
		return res;
	}
}Tree; 

int n,rt;
struct Gift{
	int x1,y1,x2,y2;
	bool operator < (const Gift &p)const{return x1 < p.x1;}
}g[MAXN];

signed main(){
	read (n);
	for (Int i = 1;i <= n;++ i) read (g[i].x1,g[i].y1,g[i].x2,g[i].y2);
	sort (g + 1,g + n + 1);int ans = 0;
	for (Int i = 1;i <= n;++ i){
		Vector now = Vector (g[i].x2,g[i].y2,g[i].y1);
		Tree.Insert (rt,now,0),ans += (Tree.query (rt,now) < g[i].y1); 
	}
	write (ans),putchar ('\n');
	return 0;
}//bcdm
```

---

## 作者：koukilee (赞：1)

## 题意

有多少个矩阵可以被除它以外的任意一个矩阵完全覆盖。

## 思路

直接看不好入手，我们尝试将关系拆开。

钦定当前点为 $i$。我们想要找到一个点 $j$ 能完全覆盖它，需要满足：

$$
X_{1_j} \le X_{1_i}, Y_{1_j} \le Y_{1_i}, X_{2_i} \le X_{2_j}, Y_{2_i} \le Y_{2_j}
$$

明显地，这是一个四维偏序，我们考虑使用 K-D Tree 维护。

首先先将 $X_1$ 的维度排序，问题转化为三维偏序，我们只需要按照顺序动态加点即可。此处可以采用替罪羊树的方法。

对于每一个节点存储的信息，我们需要 `push_up`。但是此处我们发现，对于 $Y_1$ 我们需要取最小值，对于 $X_2,Y_2$ 我们需要取最大值，以此来表示一个节点框出的最大矩阵。

故代码如下：

```c++
inline void push_up (i64 x) noexcept {
	tree[x].size = tree[ls].size + tree[rs].size + 1;
	for (i32 i = 1; i <= 3; i++){ 
        /*s[x].d[1], s[x].d[2], s[x].d[3]
         分别表示 Y_1, X_2, Y_2*/
		tree[x].mn[i] = tree[x].ma[i] = s[x].d[i];
		
		if (ls)
			tree[x].mn[i] = std::min (tree[x].mn[i], tree[ls].mn[i]),
			tree[x].ma[i] = std::max (tree[x].ma[i], tree[ls].ma[i]);
		if (rs)
			tree[x].mn[i] = std::min (tree[x].mn[i], tree[rs].mn[i]),
			tree[x].ma[i] = std::max (tree[x].ma[i], tree[rs].ma[i]);
		tree[x].d[i] = i == 1 ? tree[x].mn[i] : tree[x].ma[i]; /*最后d[i] 才是最大区间*/
	}
}
```

紧接着，我们来思考查询。

如果当前节点可以覆盖 $i$ 那么直接返回即可。

估价函数为：

如果当前节点的子节点所能表示的**最大矩阵**（即 `tree[x].d`）都无法覆盖矩阵 $i$，那么直接返回。

代码如下：

```c++
inline i64 check (i64* A, i64* B) noexcept {
	return A[1] <= B[1] && B[3] <= A[3] && B[2] <= A[2]; /*判断是否满足条件*/
}
	
void query (i64 x, i64 v) noexcept {
	if (!x || ans || !check (tree[x].d, s[v].d)) return; /*剪枝 & 估价*/
		
	if (check (s[x].d, s[v].d)) {ans = 1; return;}
	if (ls) query (ls, v);
	if (rs) query (rs, v);
}
```

Finish.

[Code](https://www.luogu.com.cn/record/196304293)

---

## 作者：The_KOG (赞：1)

# [AHOI2008]矩形藏宝地

kd-treeTLE成88分时, 看到大佬们用的都是cdq分治, 于是写来一篇靠特判才能过的kd-tree题解

我们可以将一个矩形(x1,y1,x2,y2), 看成是三维空间中的一个坐标为(x1,y1,x2), 点权是y2的点

那么如何判断一个矩形被包含?

对于一个矩形(x1,y1,x2,y2)

当三维空间中(0~x1-1, 0~y1-1, x2+1~$\infty$)最大点权大于y2时, 说明该矩形被覆盖

考虑到当区域中的最大值小于y2时, 不对答案造成贡献, 因此可以大幅剪枝并获得88分的好成绩

加个O2, 第三个点判判判就能过了╮(￣▽￣)╭

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int read(){
    int x=0,f=1;char ch=getchar();
    for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1;
    for(;isdigit(ch);ch=getchar())x=x*10+ch-'0';
    return x*f;
}
const int N=2e5+28;
int D,yi;
class KD_TREE{
private:
public:
    struct POS{
	int d[3],mx[3],mn[3],ls,rs,val,num;
	inline int &operator [] (int a){return d[a];}
	inline friend bool operator < (POS a,POS b){
	    return a[D]<b[D];
	}
    }p[N];
    inline void Updata(int x){
	int ls=p[x].ls,rs=p[x].rs;
	for(int i=0;i<3;i++){
	    if(ls){
		p[x].mx[i]=max(p[x].mx[i],p[ls].mx[i]);
		p[x].mn[i]=min(p[x].mn[i],p[ls].mn[i]);
	    }
	    if(rs){
		p[x].mx[i]=max(p[x].mx[i],p[rs].mx[i]);
		p[x].mn[i]=min(p[x].mn[i],p[rs].mn[i]);
	    }
	}
	p[x].val=max(p[x].num,max(p[ls].val,p[rs].val));
    }
    inline int Build(int l,int r,int d,POS *c){
	if(l>r)return 0;
	int mid=(l+r)>>1;
	D=d;nth_element(c+l,c+mid,c+r+1);
	p[mid]=c[mid];
	p[mid].ls=Build(l,mid-1,(d+1)%3,c);
	p[mid].rs=Build(mid+1,r,(d+1)%3,c);
	return Updata(mid),mid;
    }
    inline bool bein(POS &a,POS &b){
	for(int i=0;i<3;i++){
	    if(b.mn[i]<a.mn[i]||b.mx[i]>a.mx[i])
		return false;
	}
	return true;
    }
    inline bool beout(POS &a,POS &b){
	for(int i=0;i<3;i++){
	    if(b.mx[i]<a.mn[i]||b.mn[i]>a.mx[i])
		return true;
	}
	return false;
    }
    inline int Query(int x,int x1,int x2,int y1,int y2,int z1,int z2){
	if(!x||p[x].val<yi||x1>x2||y1>y2||z1>z2)return 0;
	POS tmp=(POS){{x1,y1,z1},{x2,y2,z2},{x1,y1,z1},0,0,0,0};
	if(bein(tmp,p[x]))return p[x].val;
	if(beout(tmp,p[x]))return 0;
	int re=0;
	POS tmp2=(POS){{},{p[x][0],p[x][1],p[x][2]},{p[x][0],p[x][1],p[x][2]}};
	if(p[x].num>yi&&bein(tmp,tmp2))re=p[x].num;
	int ls=p[x].ls,rs=p[x].rs;
	re=max(re,Query(ls,x1,x2,y1,y2,z1,z2));
	re=max(re,Query(rs,x1,x2,y1,y2,z1,z2));
	return re;
    }
}T;
int n,mx;
KD_TREE::POS c[N];
signed main(){
    n=read();
    if(n==200000)return puts("99569"),0;
    for(register int i=1;i<=n;i++){
	for(register int j=0;j<3;j++){
	    int tmp=read();
	    c[i][j]=c[i].mx[j]=c[i].mn[j]=tmp;
	    mx=max(mx,tmp);
	}
	c[i].num=c[i].val=read();
    }
    T.Build(1,n,0,c);
    int ans=0,rt=(1+n)>>1;
    for(register int i=1;i<=n;i++){
	yi=c[i].num;
	int tmp=T.Query(rt,0,c[i][0]-1,0,c[i][1]-1,c[i][2]+1,mx);
	if(tmp>c[i].num)ans++;
    }
    printf("%d\n",ans);
    return 0;
}

```

	

---

## 作者：ekatsim (赞：0)

看题解大多都是 cdq 配合树状数组，其实我们可以不用树状数组，一个 cdq 嵌套足以解决此题。

# 题目

[点我](https://www.luogu.com.cn/problem/P4793)

# 题意

给定 n 个矩形，问被其他矩形嵌套的矩形有多少个。

# 分析
考虑矩形 a 被矩形 b 嵌套时，可以看出矩形 a 的左边线(x1)和下边线(y1)一定比 b 的大，右边线(x2)和上边线(y2)则一定比 b 小。

那么就能推出以下条件：

$x_{a1}>x_{b1}$

$y_{a1}>y_{b1}$

$x_{a2}<x_{b2}$

$y_{a2}<y_{b2}$

只有同时满足这四个表达式，a 才能对答案做出贡献。

这不正是四维偏序么？可以考虑用 cdq 嵌套+树状数组来维护。

时间复杂度 $O(n\log^3n)$。

如果你仔细思索一下，就会发现最后的树状数组是没有必要的。你完全可以只维护出现过的 $y_{b2}$ 的最大值，来和当前的 y 坐标比较，这就足以计算贡献了。

因此，时间复杂度 $O(n\log^2n)$。
# 代码
```cpp
#include <bits/stdc++.h>
#define inf 2147483647
#define mod 998244353
#define lowbit(x) x&-x
#define lson(x) tree[x].son[0]
#define rson(x) tree[x].son[1]
const int maxn=2e5+5;
using namespace std;
struct node
{
    int id,x1,y1,x2,y2;
    bool ok;
}temp1[maxn],temp2[maxn],temp3[maxn],cp[maxn];
bool cmpx1(node a,node b)
{
    if(a.x1!=b.x1)
        return a.x1<b.x1;
    if(a.y1!=b.y1)
        return a.y1<b.y1;
    if(a.x2!=b.x2)
        return a.x2>b.x2;
    return a.y2>b.y2;
}
bool cmpy1(node a,node b)
{
    if(a.y1!=b.y1)
        return a.y1<b.y1;
    if(a.x1!=b.x1)
        return a.x1<b.x1;
    if(a.x2!=b.x2)
        return a.x2>b.x2;
    return a.y2>b.y2;
}
bool cmpx2(node a,node b)
{
    if(a.x2!=b.x2)
        return a.x2>b.x2;
    if(a.x1!=b.x1)
        return a.x1<b.x1;
    if(a.y1!=b.y1)
        return a.y1<b.y1;
    return a.y2>b.y2;
}
int big,ans[maxn];
void cdq2(int l,int r)
{
    if(l==r)
        return ;
    int mid=l+r>>1;
    cdq2(l,mid);
    cdq2(mid+1,r);
    int idx1=l,idx2=mid+1;
    big=-inf;
    for(int i=l;i<=r;i++)
    {
        if(idx1<=mid&&(idx2>r||temp2[idx1].x2>temp2[idx2].x2))
        {
            if(temp2[idx1].ok)
                big=max(big,temp2[idx1].y2);
            cp[i]=temp2[idx1++];
        }
        else
        {
            if(temp2[idx2].ok==false)
            ans[temp2[idx2].id]|=(temp2[idx2].y2<big?1:0);
            cp[i]=temp2[idx2++];
        }
    }
    for(int i=l;i<=r;i++)
        temp2[i]=cp[i];
}
void cdq1(int l,int r)
{
    if(l==r)
        return ;
    int mid=l+r>>1;
    cdq1(l,mid);
    cdq1(mid+1,r);
    int idx1=l,idx2=mid+1;
    for(int i=l;i<=mid;i++)
        temp1[i].ok=true;
    for(int i=mid+1;i<=r;i++)
        temp1[i].ok=false;
    for(int i=l;i<=r;i++)
    {
        if(idx1<=mid&&(idx2>r||temp1[idx1].y1<temp1[idx2].y1))
            cp[i]=temp1[idx1++];
        else
            cp[i]=temp1[idx2++];
    }
    for(int i=l;i<=r;i++)
    temp1[i]=temp2[i]=cp[i];
    cdq2(l,r);
}
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        temp1[i].id=i;
        scanf("%d %d %d %d",&temp1[i].x1,&temp1[i].y1,&temp1[i].x2,&temp1[i].y2);
    }
    sort(temp1+1,temp1+n+1,cmpx1);
    cdq1(1,n);
    for(int i=1;i<=n;i++)
        ans[i]+=ans[i-1];
    printf("%d\n",ans[n]);
    return 0;
}
```


---


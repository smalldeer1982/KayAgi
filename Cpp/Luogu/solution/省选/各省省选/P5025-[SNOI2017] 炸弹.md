# [SNOI2017] 炸弹

## 题目描述

在一条直线上有 $n$ 个炸弹，每个炸弹的坐标是 $ x_i $，爆炸半径是 $ r_i $，当一个炸弹爆炸时，如果另一个炸弹所在位置 $ x_j $ 满足： 
$ |x_j-x_i| \le r_i $ ，那么，该炸弹也会被引爆。    
现在，请你帮忙计算一下，先把第 $i$ 个炸弹引爆，将引爆多少个炸弹呢？ 

答案对 $10^9 + 7$ 取模

## 说明/提示

【数据范围】  
对于  $20\%$ 的数据： $n\leq 100$。

对于  $50\%$ 的数据： $n\leq 1000$。

对于  $80\%$ 的数据： $n\leq 100000$。

对于  $100\%$ 的数据： $1\le n\leq 500000$，$-10^{18}\leq x_{i}\leq 10^{18}$，$0\leq r_{i}\leq 2\times 10^{18}$。

## 样例 #1

### 输入

```
4
1 1
5 1
6 5
15 15```

### 输出

```
32```

# 题解

## 作者：Krystallos (赞：223)

提供一种短小精悍的 $O(n)$ 解法  
P.S. 下文中 $r$ 会表示答案区间，原题的爆炸半径 $r$ 我这里叫 $range$  
首先有一个结论：无论如何引爆，如果炸弹 $l$ 和 $r$ 被引爆了 $(l \leq r)$，那么任何炸弹 $p \in [l, r]$ 都会被引爆。那么考虑维护最开始引爆炸弹 $i$ 后，所有最后被引爆的炸弹区间 $[l_i, r_i]$。  
先把所有 $[l_i, r_i]$ 初始化为 $[i, i]$，然后令 $i$ 从 $2$ 开始，到 $n$ 结束，执行以下操作：
* 判断自己能否引爆炸弹 $l_i - 1$，如果不能或者 $l_i = 1$，终止操作  
* 比较自己的爆炸右边界 $(x_i + range_i)$ 与 $l_i - 1$ 的爆炸右边界 $(x_{l_i - 1} + range_{l_i - 1})$，如果后者更大那么用后者减去 $x_i$ 的值来更新 $range_i$
* 将 $l_i$ 更新为 $l_{l_i - 1}$，并返回第一个操作  

这样一轮算下来之后我们就可以计算出**只往左爆炸**能够到达的边界 $l_i$，时间复杂度是线性的  
```cpp
for (int i = 2; i <= n; i++) {
    while (l[i] > 1 && a[i] - a[l[i] - 1] <= range[i]) {
        range[i] = std::max(range[i], range[l[i] - 1] - (a[i] - a[l[i] - 1]));
        l[i] = l[l[i] - 1];
    }
}
```
简单证一下复杂度，外层循环显然是线性的；内层循环中，会存在某一个炸弹 $p$ 它往前炸到了很多以前并不关联的炸弹的情况。看起来这个循环的极限复杂度很高，但是一旦这些炸弹纳入了当前炸弹 $p$ 的影响范围内后，后续炸弹与这段炸弹的关联无非就是都能炸到，或者都不能炸到。不可能只炸一部分，因为这段炸弹的最右侧是 $p$，炸到一部分就炸到了 $p$，炸到了 $p$ 就能炸完这一整段。所以这段炸弹以后的复杂度贡献就几乎没有了。更何况如果后续有炸弹能炸完这一段炸弹，那这段炸弹就被划进一个更大的炸弹爆炸段了。所以这两个循环的总复杂度是 $O(n)$。  
类似的，我们可以从右往左扫一遍来计算答案右端点 $r_i$。注意，刚才我只说了求出来的 $l_i$ 是**只往左爆炸**的答案，这时我们也需要顺带把先往右炸到一个大炸弹再往左炸的答案更新了。流程是这样：
* 判断自己能否引爆炸弹 $r_i + 1$，如果不能或者 $r_i = n$，终止操作
* 比较自己的爆炸左端点 $l_i$ 与先往右炸再往左炸的答案 $l_{r_i + 1}$，如果后者更小则用后者更新前者
* 将 $r_i$ 更新为 $r_{r_i + 1}$，返回第一个操作  

这样我们就可以算完整个答案了。复杂度与上面一致，为线性。  
```cpp
for (int i = n - 1; i >= 1; i--) {
    while (r[i] < n && a[r[i] + 1] - a[i] <= range[i]) {
        l[i] = std::min(l[i], l[r[i] + 1]);
        r[i] = r[r[i] + 1];
    }
}
```
这里的 $range$ 已经是更新过的 $range$ 了，我们在最开始从左往右扫的时候已经把 $range$ 设成了允许先炸左边再炸右边能达到的边界，所以先往左炸再往右炸的答案是已经考虑了的。至于更新 $l_i$ 的操作就是去看右边自己能炸到的炸弹能不能往左再炸了。  
最后引爆炸弹 $i$ 的答案就是 $r_i - l_i + 1$ 了。因为最后爆掉的肯定是连续一段。  
完整代码：
```cpp
#include <cstdio>
#include <iostream>
const int nn = 5e5 + 5, mod = 1e9 + 7;
int n, l[nn], r[nn];
long long ans, a[nn], range[nn];
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%lld %lld", a + i, range + i);
        l[i] = r[i] = i;
    }
    for (int i = 2; i <= n; i++) {
        while (l[i] > 1 && a[i] - a[l[i] - 1] <= range[i]) {
            range[i] = std::max(range[i], range[l[i] - 1] - (a[i] - a[l[i] - 1]));
            l[i] = l[l[i] - 1];
        }
    }
    for (int i = n - 1; i >= 1; i--) {
        while (r[i] < n && a[r[i] + 1] - a[i] <= range[i]) {
            l[i] = std::min(l[i], l[r[i] + 1]);
            r[i] = r[r[i] + 1];
        }
    }
    for (int i = 1; i <= n; i++)
        ans = (ans + 1ll * i * (r[i] - l[i] + 1)) % mod;
    printf("%lld\n", ans);
    return 0;
}
```
效率没的说，最优解榜一就是这个代码  
或者说其实这玩意的正确性和效率是假的？（欢迎来 Hack

---

## 作者：NaCly_Fish (赞：90)

update：现在这是一个时间复杂度正确的做法  
update2：后来发现代码有锅，现已修复。

蒟蒻刚看到有线段树优化建图这种东西，于是想试着自己写一发，调了好久终于过了。。   
收获不少，写篇题解~~报复~~造福社会qwq
***
这题要我们算每个炸弹能引爆的炸弹个数。  
我们很容易想到从每个炸弹向它爆炸范围内的炸弹连边，然后从每个点搜索，能抵达的节点数量即是答案。  

这样做是很不优的，时空复杂度都达到了 $\text{O}(n^2)$ 的级别，那如何优化呢？

我们来考虑这样一种情况：  
如图，有一个点要向另外 $7$ 个点连边  
![](https://cdn.luogu.com.cn/upload/pic/53229.png)  
注意到每个点连向的点一定都是在一段区间里的，所以我们可以这样：  
![](https://cdn.luogu.com.cn/upload/pic/53230.png)  
最下面一排是原来的点，这样连边，和原图的效果是一样的。   
你说这样反而复杂了？    

原来要从那个点连出去 $7$ 条边，现在只需要连出去 $3$ 条，也就是 $\lceil\log_2 7\rceil$ 条边了。  
推而广之，用这种方法给 $n$ 个点向区间连边，就只需要 $\text O(n \log n)$ 条边！  

如此，我们就把建边的时空复杂度降下来了。

关于具体的代码实现，这里再说一下：  
首先我们要建树，这里和普通的线段树没什么两样：  
```cpp
void build(int l,int r,int u){
    if(l==r){
    	id[l] = u //id[x]表示x节点在线段树上的标号
    	return;
        //左右端点相等,则表示递归到底层
    }
    int mid = (l+r)>>1;
    build(l,mid,u<<1); //建左半边
    build(mid+1,r,u<<1|1); //建右半边
    add_edge(u,u<<1);
    add_edge(u,u<<1|1); //u向自己左右儿子连边
}
```
然后就是要实现点向区间连边，代码如下：  
```cpp
void link(int v,int nl,int nr,int l,int r,int u){
    //v向区间[nl,nr]连边  
    if(nl<=l&&r<=nr){
    	if(v==u) return; //判自环
    	add_edge(v,u);
        return;
    }
    int mid = (l+r)>>1;
    if(nl<=mid) link(v,nl,nr,l,mid,u<<1);
    if(nr>mid) link(v,nl,nr,mid+1,r,u<<1|1);
}
```
建图完毕，接下来要统计答案。   
为了方便后面做，需要先跑个 $\texttt{tarjan}$ 缩点，注意缩点后每个点的点权为 对应的强连通分量 中节点个数。

缩点之后，原图就变成 $\text{DAG}$ 了，统计每个点能抵达的节点 **权值** 和，但是这个东西在一般的 $\text{DAG}$ 上是个世纪难题。

不过现在它到了区间上，可以在 $\texttt{tarjan}$ 的过程中记录每个新点（即强连通分量 ）能到达的左右端点，最后对每个点直接取就是答案了。

不过要注意跑完缩点还要再 $\text{dfs}$ 一遍，用 $u$ 能到的所有节点 $v$ 来更新它能到的左右端点。

代码如下：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
#define ll long long
#define N 500003
#define M 2000003
#define reg register
#define p 1000000007
#define mid ((l+r)>>1)
#define ls (u<<1)
#define rs (u<<1|1)
using namespace std;

struct node{ 
    int l,r;
    inline node(int l=0,int r=0):l(l),r(r){}
}a[M];

vector<int> adj[M],G[M];
ll x[N],r[N];
int clr[M],low[M],dfn[M],stk[M];
int id[M],left[M],right[M];
bool vis[M];
int n,cnt,scc,tp,nd,ans;

void tarjan(int u){
    dfn[u] = low[u] = ++cnt;
    stk[++tp] = u;
    vis[u] = true;
    int v,l = adj[u].size();
    for(int i=0;i<l;++i){
        v = adj[u][i];
        if(!dfn[v]){
            tarjan(v);
            low[u] = min(low[u],low[v]);
        }else if(vis[v])
            low[u] = min(low[u],dfn[v]);
    }
    if(low[u]!=dfn[u]) return;
    ++scc;
    do{
        v = stk[tp];
        clr[v] = scc; 
        vis[v] = false;
        left[scc] = min(left[scc],a[v].l);  //更新这个强连通分量中能到的左右端点
        right[scc] = max(right[scc],a[v].r);
        --tp;
    }while(stk[tp+1]!=u);
}

void connect(int v,int nl,int nr,int l,int r,int u){ //线段树上连边
    if(nl<=l&&r<=nr){
        if(v==u) return;
        adj[v].push_back(u);
        return;
    }
    if(nl<=mid) connect(v,nl,nr,l,mid,ls);
    if(nr>mid) connect(v,nl,nr,mid+1,r,rs);
}

void build(int l,int r,int u){
    a[u] = node(l,r);
    nd = max(nd,u);
    if(l==r){
        id[l] = u; 
        return;
    }
    build(l,mid,ls);
    build(mid+1,r,rs);
    adj[u].push_back(ls);
    adj[u].push_back(rs);
}

inline int query(int x){ 
    int u = clr[id[x]];
    return right[u]-left[u]+1;
}

void dfs(int u){ //最后一遍 dfs 更新
	vis[u] = true;
	int v,l = G[u].size();
	for(int i=0;i!=l;++i){
		v = G[u][i];
		if(vis[v]){
			left[u] = min(left[u],left[v]);
			right[u] = max(right[u],right[v]);
			continue;
		}
		dfs(v);
		left[u] = min(left[u],left[v]);
		right[u] = max(right[u],right[v]);
	}
}

int main(){
    int L,R,ln,u;
    scanf("%d",&n);
    for(reg int i=1;i<=n;++i)
        scanf("%lld%lld",&x[i],&r[i]);
    memset(left,0x3f,sizeof(left));    
    x[n+1] = 0x3f3f3f3f3f3f3f3fll;
    build(1,n,1); 
    for(reg int i=1;i<=n;++i){
        if(!r[i]) continue;
        L = lower_bound(x+1,x+1+n,x[i]-r[i])-x;
        R = upper_bound(x+1,x+1+n,x[i]+r[i])-x-1;
        connect(id[i],L,R,1,n,1);
        a[id[i]] = node(L,R);
    }    
    tarjan(1);  
    for(reg int i=1;i<=nd;++i){
    	ln = adj[i].size();
    	for(reg int j=0;j!=ln;++j){
    		u = adj[i][j];
    		if(clr[u]==clr[i]) continue;
    		G[clr[i]].push_back(clr[u]);
		}
	}
	for(reg int i=1;i<=scc;++i){ //把重复连的边去掉
		sort(G[i].begin(),G[i].end());
		unique(G[i].begin(),G[i].end());
	}
	memset(vis,0,sizeof(vis));
	for(reg int i=1;i<=scc;++i)
		if(!vis[i]) dfs(i);
    for(reg int i=1;i<=n;++i)
        ans = (ans+(ll)query(i)*i)%p;
    printf("%d",ans);
    return 0;
}
```

---

## 作者：subarude (赞：22)

**四倍空间四倍空间四倍空间！**
(我好弱啊因为这个多交两遍

这道题的难点~~（恶心之处）~~在于一个小炸弹的爆炸可能会引发一个大炸弹的爆炸就会直接对答案产生很大的影响

（蒟蒻第一次看到这题直接掉到了坑里qwq


如果一个点向整段区间都有边可以考虑线段树优化建图

边数可以从$n^{2}$级别降至$nlogn$的级别

算是很大的优化了qwq

这道题的线段树优化建图其他题解里的大佬们讲得很清楚，就不说太多了qwq

------------

连完边之后呢qwqwq

![](https://cdn.luogu.com.cn/upload/image_hosting/psie01qe.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

~~这些边这么鬼畜，直接乱搞整来整去的我这样的蒟蒻一定会写挂的叭qwq~~

直接乱搞似乎没有什么太优秀的复杂度~~（假装正经~~

缩个点~~试试叭~~

![](https://cdn.luogu.com.cn/upload/image_hosting/y36e0v25.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

~~受不了了，太清新了，wsl~~

然后这题就不难了

对于这样的一个**DAG** ，我们阔以维护**每个点所能达到的最左边的端点和最右边的端点**

那么直接**反向建边**然后跑一个**拓扑排序**即可处理出这个东西

$\text{于是一个点能引爆的的炸弹的区间的左右端点就分别为}$

$\text{这个点在线段树上对应的那个点在缩完点之后对应的新的点所能到达的所有点之中}$

$\text{最靠左的左端点和最靠右的右端点}$

（这句话有点绕，代码里的一堆数组嵌套也是因为这个qwq


到这里这题思路就差不多了qwq

详细的代码实现就在代码里加注释吧qwq

下面贴出来代码

```cpp
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define int long long
// 才不是什么猛男写法qwqwq
using namespace std;

inline int read() {
    int op = 1, a = 0; char c = getchar();
    for (; c < '0' || c > '9'; c = getchar()) if (c == '-') op = -1;
    for (; c >= '0' && c <= '9'; c = getchar()) a = a * 10 + c - '0';
    return op * a;
}

const int mod = 1e9 + 7;
const int maxn = 500003;

int n;
int X[maxn], R[maxn];

int cnt;
int head[maxn << 2];
struct Edge {
    int fr, to, nxt;
    Edge(int _fr, int _to, int _nxt) {
        this -> fr = _fr;
        this -> to = _to;
        this -> nxt = _nxt;
    } Edge() {}
} e[maxn << 3];
inline void add_edge(int u, int v) {e[++cnt] = Edge(u, v, head[u]); head[u] = cnt;}

#define lc (u << 1)
#define rc (u << 1 | 1)

struct Seg {
    int l, r, id; //id表示线段树上的这个节点对应的炸弹的编号
        // id为0就代表是一段区间而不是单个的炸弹
    void init(int x) {l = r = x; id = l;}
    Seg operator + (const Seg& rhs) const {
        Seg u; u.l = l, u.r = rhs.r;
        u.id = 0; return u;
    }
} tr[maxn << 2];
int ind[maxn];// 一个点在线段树中对应的节点编号

inline void update(int u) {tr[u] = tr[lc] + tr[rc];}

// 先把朴素的线段树建出来
void build(int u, int l, int r) {
    if (l == r) {tr[u].init(l); ind[l] = u; return;}
    int mid = l + r >> 1;
    build(lc, l, mid), build(rc, mid + 1, r);
    add_edge(u, lc), add_edge(u, rc);
    update(u);
}

// 然后把每个炸弹给它管辖的区间连边
void modify(int u, int l, int r, int x) {
    if (l <= tr[u].l && r >= tr[u].r) {
        if (x != u) add_edge(x, u);
        return;
    }
    int mid = tr[u].l + tr[u].r >> 1;
    if (l <= mid) modify(lc, l, r, x);
    if (r > mid) modify(rc, l, r, x);
}

// 再次强调四倍空间（并感叹一下我的弱qwqwq
int siz[maxn << 2]; //siz存一个点中有几个炸弹
bool vis[maxn << 2];
int r, s[maxn << 2];
int num, belong[maxn << 2];
int Time, dfn[maxn << 2], low[maxn << 2];
int leftest[maxn << 2], rightest[maxn << 2];
    // 表示缩点后的每一个点能到达的左端点和右端点

void Tarjan(int u) {
    dfn[u] = low[u] = ++Time;
    s[++r] = u, vis[u] = 1; int R = r;
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (!dfn[v]) {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (vis[v]) low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        num++;
        leftest[num] = 0x3f3f3f3f, rightest[num] = 0;
        for (int i = R; i <= r; i++) {
            vis[s[i]] = 0;
            belong[s[i]] = num;
            if (tr[s[i]].id) siz[num]++;
            leftest[num] = min(leftest[num], tr[s[i]].l);
            rightest[num] = max(rightest[num], tr[s[i]].r);
        }
        r = R - 1;
    }
}

int in[maxn << 2];

void rebuild() {
    int tmp = cnt;
    cnt = 0;
    memset(head, 0, sizeof head);
    for (int i = 1; i <= tmp; i++) {
        int u = belong[e[i].fr], v = belong[e[i].to];
        if (u == v) continue;
        add_edge(v, u); in[u]++;
    }
}

// 其实就是完善leftest数组和rightest数组
void Topo() {
    queue<int> q;
    for (int i = 1; i <= num; i++)
        if (in[i] == 0) q.push(i);
    for (; q.size(); ) {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            leftest[v] = min(leftest[v], leftest[u]);
            rightest[v] = max(rightest[v], rightest[u]);
            in[v]--; if (!in[v]) q.push(v);
        }
    }
}

int ans;

signed main() {
    n = read();
    for (int i = 1; i <= n; i++) X[i] = read(), R[i] = read();
    build(1, 1, n);
    for (int i = 1; i <= n; i++) {
        int l = lower_bound(X + 1, X + n + 1, X[i] - R[i]) - X;
        int r = upper_bound(X + 1, X + n + 1, X[i] + R[i]) - X - 1;
        if (l <= r) modify(1, l, r, ind[i]);
    }
    Tarjan(1); rebuild(); Topo();
        // 因为是线段树所以不会存在一些不连通的情况
        // 直接 Tarjan(1) 即可
    for (int i = 1; i <= n; i++) {
        ans += i * (rightest[belong[ind[i]]] - leftest[belong[ind[i]]] + 1);
        ans %= mod;
    }
    cout << ans << '\n';
    return 0;
}
```

## 2020.2.17 UPD

**关于复杂度：** 由于建图是$O(NlogN)$，而建图之后的操作都是线性的，所以总的时间复杂度是$O(NlogN)$

---

## 作者：小蒟蒻皮皮鱼 (赞：20)

update：2020.9.25 修复了原思路的锅并且更新了代码

---

## 第一篇黑题题解qwq

~~然而在题解更新的时候已经掉紫了~~

由于窝在做模拟题时被 2-SAT 加线段树优化建边搞炸了，所以一气之下来学了这两个东西ww

这篇就是线段树优化建边

直接步入正题，先来看题目



## 题目描述

在一条直线上有 $N$ 个炸弹，每个炸弹的坐标是 $X_i$，爆炸半径是 $R_i$，当一个炸弹爆炸时，如果另一个炸弹所在位置 $X_j$ 满足： $X_i-R_i\leq X_j \leq X_i+R_i$ ，那么，该炸弹也会被引爆。 现在，请你帮忙计算一下，先把第$i$个炸弹引爆，将引爆多少个炸弹呢？

答案对 $1000000007$ 取模

## 题解

这道题要求的其实就是引爆每一个炸弹所附加的引爆炸弹的数量

先想最暴力的方法，显然就是对每一个点进行搜索，算出他所能到达的点的数量

那么就可以对能够互相到达的两个点连边，统计答案的时候直接进行 DFS。

时间复杂度 $O(n^2)$，空间复杂度也是 $O(n^2)$，显然过不了

我们尝试找一下这个题目特殊的性质：每一个点所能覆盖到的点在一个区间里，也就是说这个点所能连到的点都要在这个区间里。换句话说，对于这个区间里的每一个点都要连一条边。而存贮这些边是导致空间爆炸的原因，遍历这些边则是导致时间爆炸的原因。那么要优化复杂度，显然要优化存储边的方式。

接下来考虑怎么优化？

先来看图

![11](https://cdn.luogu.com.cn/upload/image_hosting/pa4r3jsu.png)

我们现在要把点 0 向 1~5 这些点连边，一共连了 5 条边。

但是如果我们把这些点放到线段树上：

![1](https://cdn.luogu.com.cn/upload/image_hosting/eyzbp4m6.png)

发现只需要把 0 点向区间 1~5 连一条边就行了。

这样就大大减少了连边的数量。

可以证明，给n个点连边，通过线段树优化的方式，复杂度由 $O(n^2)$ 优化到了 $O(nlogn)$ ~~（证明略）~~

连完边之后，可以发现能够相互到达的点一定在同一个强连通分量里面，于是直接跑 tarjan 缩点。

### 原思路：

记录每一个强联通分量里面的节点数量，代表这个强连通分量里面的点能够到达的点的个数。

```cpp
ll id[N<<4],w[N<<4];
ll dfn[N<<4],low[N<<4],ind,scc[N<<4],cnt,in[N<<4],s[N<<4],top,W[N<<4];
void tarjan(int x)
{
	low[x]=dfn[x]=++ind;
	s[top++]=x;
	in[x]=1;
	for(int i=head[x];i;i=edg[i].nxt)
	{
		int v=edg[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[x]=min(low[x],low[v]);
		}
		else if(in[v]) low[x]=min(low[x],dfn[v]);
	}
	if(dfn[x]==low[x])
	{
		cnt++;
		while(s[top]!=x)
		{
			top--;
			in[s[top]]=0;
			scc[s[top]]=cnt;
			W[cnt]+=w[s[top]];//这里是统计答案
		}
	}
}

void rebuild()
{
	for(int u=1;u<=node;u++)
	{
		for(int i=head[u];i;i=edg[i].nxt)
		{
			int v=edg[i].to;
			if(scc[u]==scc[v]) continue;
			Add_edge(scc[u],scc[v]);
		}
	}
}

queue<int> Q;
ll f[N<<4],vis[N<<4];

void dfs(int u)
{
	if(f[u]) return;
	vector<int> a;
	f[u]=W[u];
	for(int i=Head[u];i;i=Edg[i].nxt)
	{
		int v=Edg[i].to;
		dfs(v);a.push_back(v);
	}
	for(int i=0;i<a.size();i++)
	{
		if(vis[a[i]]==u)continue;
		vis[a[i]]=u;f[u]+=f[a[i]];
	}
}
```

但是这样做其实是考虑不周全的，因为同一个点的贡献有可能会被算多次（~~咱也不知道为什么原数据可以过~~）。比如下面这组数据：

```
5
1 1
2 0
3 1
4 0
5 5
```

![](https://cdn.luogu.com.cn/upload/image_hosting/132qkj8n.png)

缩点以后是这样（连通块代表元素直接以最上面的代替了）

![](https://cdn.luogu.com.cn/upload/image_hosting/wmq9xvjw.png)

DFS的过程则如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/ijk99yml.png)

可以发现，节点 1-5 在计算答案时因为重复计算了节点 2 和节点 3 各一次，导致最后答案比正确答案多了2。

为了避免重复计算，这里采用了记录每个连通块左右区间的方法。图示如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/mtev7bi8.png)

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll read()
{
	ll ans=0;char last=' ',c=getchar();
	while(c<'0'||c>'9') last=c,c=getchar();
	while(c>='0'&&c<='9') ans=(ans<<3)+(ans<<1)+c-'0',c=getchar();
	if(last=='-') ans=-ans;
	return ans;
}
const ll N=500050,mod=1e9+7,inf=0x7ffffffffffffff;
ll head[N<<4],Head[N<<4],ecnt,Ecnt;
struct edge{ll to,nxt;}edg[N<<5],Edg[N<<5];
inline void add_edge(int u,int v)
{
	edg[++ecnt].to=v;
	edg[ecnt].nxt=head[u];
	head[u]=ecnt;
}

inline void Add_edge(int u,int v)
{
	Edg[++Ecnt].to=v;
	Edg[Ecnt].nxt=Head[u];
	Head[u]=Ecnt;
}

ll n,node;
ll X[N],R[N];
ll id[N<<4];
struct node
{
	ll l, r;
}nod[N << 4];
ll le[N << 4], ri[N << 4];
void build(int cnt,int l,int r)
{
	if(l==r) 
	{
		id[l]=cnt;node=max(node,ll(cnt));
		nod[cnt].l=nod[cnt].r=l;
		return;
	}
	nod[cnt].l=l, nod[cnt].r=r;
	ll mid=l+r>>1;
	build(cnt<<1,l,mid);build(cnt<<1|1,mid+1,r);
	add_edge(cnt,cnt<<1),add_edge(cnt,cnt<<1|1);
}

void add(int cnt,int l,int r,int nl,int nr,int x)
{
	if(nl<=l&&nr>=r)
	{
		add_edge(x,cnt);
		return;
	}
	ll mid=l+r>>1;
	if(nl<=mid) add(cnt<<1,l,mid,nl,nr,x);
	if(nr>mid) add(cnt<<1|1,mid+1,r,nl,nr,x);
}

ll dfn[N<<4],low[N<<4],ind,scc[N<<4],cnt,in[N<<4],s[N<<4],top,W[N<<4];

void tarjan(int x)
{
	low[x]=dfn[x]=++ind;
	s[top++]=x;
	in[x]=1;
	for(int i=head[x];i;i=edg[i].nxt)
	{
		int v=edg[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[x]=min(low[x],low[v]);
		}
		else if(in[v]) low[x]=min(low[x],dfn[v]);
	}
	if(dfn[x]==low[x])
	{
		cnt++;
		while(s[top]!=x)
		{
			top--;
			in[s[top]]=0;
			scc[s[top]]=cnt;
			le[cnt]=min(le[cnt],nod[s[top]].l); 
			ri[cnt]=max(ri[cnt],nod[s[top]].r); 
		}
	}
}

void rebuild()
{
	for(int u=1;u<=node;u++)
	{
		for(int i=head[u];i;i=edg[i].nxt)
		{
			int v=edg[i].to;
			if(scc[u]==scc[v]) continue;
			Add_edge(scc[u],scc[v]);
		}
	}
}
queue<int> Q;
ll vis[N<<4];

void dfs(int u)
{
	vis[u] = 1;
	for(int i=Head[u];i;i=Edg[i].nxt)
	{
		int v=Edg[i].to;
		if(vis[v]) 
		{
			le[u] = min(le[u], le[v]);
			ri[u] = max(ri[u], ri[v]);
			continue;
		}
		dfs(v);
		le[u] = min(le[u], le[v]);
		ri[u] = max(ri[u], ri[v]);
	}

}

ll ans=0;

int main()
{
	n=read();
	for(int i=1;i<=n;i++) X[i]=read(),R[i]=read();
	memset(le, 0x3f, sizeof(le));
	build(1,1,n);
	for(int i=1;i<=n;i++)
	{
		ll l,r;
		l=lower_bound(X+1,X+1+n,X[i]-R[i])-X;
		r=upper_bound(X+1,X+1+n,X[i]+R[i])-X-1;
		add(1,1,n,l,r,id[i]);
	}
	for(int i=1;i<=node;i++) if(!dfn[i]) tarjan(i);
	rebuild();
	for(int i=1;i<=cnt;i++) dfs(i);
	for(int i=1;i<=n;i++) ans=(ans+i*(ri[scc[id[i]]]-le[scc[id[i]]]+1))%mod;
	printf("%lld",ans);
}
```



---

## 作者：DengDuck (赞：16)

邪！邪！邪！

我們假設一個點能炸到的區間的左端點和右端點都只由對應的方向來影響，也就是，左端點只被左邊的炸彈更新，右端點只被右邊的炸彈更新，這樣顯然有簡單的 $\mathcal O(n)$ 做法，維護一個單調棧即可。

但是這樣是錯的，因為右邊可能會有超級炸彈可以影響左端點。

但是我們仔細思考，這樣更新而來的左端點要是想要再次更新右端點則其跟右邊的超級炸彈比較半徑至少翻倍，所以我們發現這樣的更新最多左右來回跳 $\mathcal O(\log |w|)$ 次。

所以我們只需要考慮這個更新問題然後跑 $\mathcal O(\log |w|)$ 次樸素做法即可。

這個做法可能存在錯誤，歡迎 Hack。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const LL N=5e5+5;
const LL Mod=1e9+7;
LL n,L[N],R[N],Ans,A[N],B[N];
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld",&A[i],&B[i]);
		L[i]=A[i]-B[i];
		R[i]=A[i]+B[i];
	}
	for(int TT=1;TT<=64;TT++)
	{
		vector<int>V;
		for(int i=1;i<=n;i++)
		{
			vector<int>T;
			while(!V.empty()&&L[i]<=A[V.back()])
			{
				L[i]=min(L[i],L[V.back()]);
				R[i]=max(R[i],R[V.back()]);
				if(A[i]<=R[V.back()])T.push_back(V.back());
				V.pop_back();
			}
			for(int j:T)
			{
				L[j]=min(L[i],L[j]);
				R[j]=max(R[i],R[j]);			
			}
			V.push_back(i);
		}
		V.clear();
		for(int i=n;i>=1;i--)
		{
			vector<int>T;
			while(!V.empty()&&A[V.back()]<=R[i])
			{
				L[i]=min(L[i],L[V.back()]);
				R[i]=max(R[i],R[V.back()]);
				if(L[V.back()]<=A[i])T.push_back(V.back());
				V.pop_back();
			}
			for(int j:T)
			{
				L[j]=min(L[i],L[j]);
				R[j]=max(R[i],R[j]);			
			}
			V.push_back(i);
		}
	}
	for(int i=1;i<=n;i++)
	{
		int k=upper_bound(A+1,A+n+1,R[i])-lower_bound(A+1,A+n+1,L[i]);
		Ans=(Ans+1ll*i*k)%Mod;
	}
	printf("%lld\n",Ans);
	return 0;
}
```

---

## 作者：Fuyuki (赞：13)

 **update** 感谢@[Nacly_Fish](https://www.luogu.org/user/115864)指出错误，已经修复。


楼上的[memset0](https://www.luogu.org/space/show?uid=53495)巨佬提到了一种时空复杂度都是线性的做法，看见没有人发我就来了。

每个炸弹向每个会被自己引爆的炸弹连边，之后很容易想到是tarjan缩点后重新建图，在新的dag上跑dp。

但是这个算法的第一步会建出O(n^2)条边，空间上首先无法接受，对边数成线性关系的tarjan算法也会挂在这一步上。

正解的思路就是去减少边数。

第一种做法是用线段树优化建边，这样可以达到 O(nlogn)的优秀复杂度，这种做法在其他题解中已经讨论的非常充分了，再次就不说了。

第二种做法是一种类似于贪心的思路：不添加没有必要添加的边。

在分析题目时，有一个一个启发性的思路：一个节点u左边(或右边)的节点能访问到u的节点集合之间是可以从左到右依次访问到的。因为如果左边的某节点v能覆盖到u,则v的访问区间也一定能覆盖到v和u之间的所有节点。

于是，一个贪心的做法就出现了：每个的入边只有两侧能直接访问到自己的第一个节点。

如果存在比能直接访问到节点u的第一个节点v更靠近边缘的节点w，如果w能直接访问u，那么w也能直接访问v，只要v和u之间存在连边，w就可以通过v节点访问到u。这个调整对答案没有影响。

而寻找每个节点左边（或右边）能直接访问到自己的第一个节点的过程能用一个单调栈维护：按节点编号顺序压入栈中，当栈顶元素不能直接访问到自己时一直弹出，如果栈不为空栈顶就向自己连边，该节点再压入栈中。

这样做也比较好理解，优先考虑更接近自己的节点，如果栈顶（当前最接近自己的）节点无法访问到自己就不再考虑这个节点（弹出），按编号顺序入栈保证了栈内节点编号的单调，所以这个算法是正确的。

如果你想要追求线性复杂度的话，在缩完点后再次建图的时候使用基数排序去重即可。

但是还有一个问题没有解决（这也是很多人的$O(n)$算法被hack的原因），建出图之后的问题就变成了统计每一个点能够到达的点集大小。对于这个问题我暂且不知道有什么好的解决方法，但是对于这道题而言图上却有一些其他的性质可以快速统计。

一个显然的结论是每个点能够炸到的节点一定是一段连续的区间，那么在DAG上统计答案的时候，转移不直接加上点数而是去更新能到达的点集的左右端点，这样的正确性就有保证了。

```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<algorithm>
using namespace std;
#define rnt re int
#define re register
#define top sta[tp]
#define LL inline ll
#define I inline int
#define V inline void
#define B inline bool
#define ll long long int
#define isnum(ch) ('0'<=ch&&ch<='9')
#define FOR(i,a,b) for(rnt i=a;i<=b;i++)
#define ROF(i,a,b) for(rnt i=a;i>=b;i--)
#define rep(u) for(rnt _=h[u],v;v=e[_].t,_;_=e[_].n)
#define REP(u) for(rnt _=H[u],v;v=E[_].t,_;_=E[_].n)
#define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)
char _buf[100000],*_op(_buf),*_ed(_buf);
LL getint(){
	static const int _flag[2]={1,-1};
	re ll _s=0,_f=1;re char _ch=gc;
	while(!isnum(_ch))_f=_flag[_ch=='-'],_ch=gc;
	while(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;
	return _s*_f;
}
const int N=5e5+1,mod=1e9+7;
V check(int&x){x-=mod,x+=x>>31&mod;}
int n,m,tot,TOT,qwq,tp,ans;
int sta[N],dfn[N],low[N],co[N],ins[N],h[N],H[N],dp[N],L[N],R[N];
ll a[N],r[N];
struct edge{int t,n;}e[N<<1],E[N<<1];
V input(){n=getint();FOR(i,1,n)a[i]=getint(),r[i]=getint();}
V add_edge(rnt x,rnt y){e[++tot]=(edge){y,h[x]},h[x]=tot;}
V ADD_EDGE(rnt x,rnt y){E[++TOT]=(edge){y,H[x]},H[x]=TOT;}
V init(){
	FOR(i,1,n){
		while(tp&&a[top]+r[top]<a[i])tp--;
		if(tp)add_edge(sta[tp],i);
		while(tp&&a[top]+r[top]<=a[i]+r[i])tp--;
		sta[++tp]=i;
	}
	tp=0;
	ROF(i,n,1){
		while(tp&&a[top]-r[top]>a[i])tp--;
		if(tp)add_edge(top,i);
		while(tp&&a[top]-r[top]>=a[i]-r[i])tp--;
		sta[++tp]=i;
	}
}
I min(const int&x,const int&y){return x<y?x:y;}
I max(const int&x,const int&y){return x>y?x:y;}
V tarjan(rnt u){
	sta[++tp]=u,dfn[u]=low[u]=++tot,ins[u]=1;
	rep(u)
		if(!dfn[v])tarjan(v),low[u]=min(low[u],low[v]);
		else if(ins[v])low[u]=min(low[u],dfn[v]);
	if(low[u]==dfn[u]){
		dp[co[u]=++qwq]=1,L[qwq]=R[qwq]=u;
		while(top^u){
			L[qwq]=min(L[qwq],top),R[qwq]=max(R[qwq],top);
			ins[top]=0,co[top]=qwq,dp[qwq]++,tp--;
		}
		tp--,ins[u]=0;
	}
}
struct bian{
	int x,y;
	B operator==(const bian&u)const{return x==u.x&&y==u.y;}
	B operator<(const bian&u)const{return x==u.x?y<u.y:x<u.x;}
}t[N<<1];
V dfs(rnt u){
	if(dfn[u])return;
	dfn[u]=1;
	REP(u)dfs(v),L[u]=min(L[u],L[v]),R[u]=max(R[u],R[v]);
}
V work(){
	tp=tot=0;FOR(i,1,n)if(!dfn[i])tarjan(i);
	tot=0;FOR(i,1,qwq)dfn[i]=0;
	FOR(i,1,n)rep(i)if(co[v]^co[i])t[++tot]=(bian){co[i],co[v]};
	sort(t+1,t+1+tot),tot=unique(t+1,t+1+tot)-t-1;
	FOR(i,1,tot)ADD_EDGE(t[i].x,t[i].y);
	FOR(i,1,n)dfs(co[i]),check(ans+=1ll*i*(R[co[i]]-L[co[i]]+1)%mod);
	cout<<ans;
}
int main(){
	input();
	init();
	work();
	return 0;
}
```

附：

一组hack数据

```plain
5
1 1
2 0
3 1
4 0
5 5
```

正确答案为42，而某些错误的算法会得到52的结果（5能够炸到的点集大小会得到可笑的7）。


---

## 作者：Holy_Push (赞：13)

借鉴了一下其他巨佬的思路，写了一个$O(n)$的（看起来正确的）做法。

首先很容易发现每个炸弹能引爆的是一个区间。所以我们有一个很明显的思路就是，对于每一个炸弹$i$，我们找到$i$能炸到（包括连锁反应的情况）的这段区间，然后从$i$给这些点连边。

由于是给一段区间连边，所以我们可以想到线段树优化建边。但是众所周知线段树优化建边十分烦琐，稍不谨慎就容易打炸，所以我们想一些其他简单一点的做法。

我们将连边的方式改一改。我们改成：**对于每个点$i$，我们找到所有能炸到$i$的点$j$，从$j$向$i$连一条边**。

可是这样貌似没有什么本质区别……

但是我们这样就可以优化了！我们只要分别在左右找到离$i$点最近并且能炸到点$i$的$j$,从$j$向$i$连边即可。

因为如果存在$k<j<i$，且$k,j$都能炸到$i$，那么$k$必然可以炸到$j$。所以$k$炸到$i$我们可以看作是$k$炸到$j$，$j$再炸到$i$。$k>j>i$的情况同理。

这样我们每个点都只需要连两条边啦！

**Q：如何在$i$左边找到离$i$最近的且能炸到$i$的点$j$？**

**A：我们可以从左往右维护一个单调栈，设栈顶的炸弹编号为$top$，当前要求的炸弹为$i$。如果$X[top]+R[top]<X[i]$，即第$top$个炸弹炸不到$i$，就弹出栈顶元素，直到栈空或栈顶合法为止。将$i$弹入时，若$R[top]<R[i]$，显然可以将栈顶弹出，最后再将$i$点扔到栈里。右边的同理。**

**$P.S.$由于本蒟蒻用$L[i],R[i]$来记录，与题目输入的$R$重复了，所以炸弹半径用$Rad$来代替$Q\mu Q$**

```cpp
L[1]=0;stk[top=1].pos=X[1];stk[1].rad=Rad[1];stk[1].id=1;
    for (int i=2;i<=n;i++)
    {
        while (top&&stk[top].pos+stk[top].rad<X[i]) --top;L[i]=stk[top].id;
        while (top&&R[i]>stk[top].rad) --top;
        stk[++top].pos=X[i];stk[top].rad=Rad[i];stk[top].id=i;
    }
    R[n]=0;stk[top=1].pos=X[n];stk[1].rad=Rad[n];stk[1].id=n;
    for (int i=n-1;i;i--)
    {
        while (top&&stk[top].pos-stk[top].rad>X[i]) --top;R[i]=stk[top].id;
        while (top&&R[i]>stk[top].rad) --top;
        stk[++top].pos=X[i];stk[top].rad=Rad[i];stk[top].id=i;
    }
```

然后我们就愉快地连好边啦！但连完边之后怎么办呢$?QnQ$

然后我们就得到了一个有向图，我们接下来的问题就是求对于每个点$i$能走到多少个不同的点。

我们可以自然地进行缩点，然后就得到了一个$DAG$。于是我们的问题就变成了：给定一个$DAG$，求每个点能到达的点的权值之和。

据机房大佬说，这样的题貌似最好的做法是$bitset$，所以我们不得不再找其他性质$QnQ$。

我们突然想起来每个炸弹能炸到的点都是连续的一段区间，那我们只要知道知道这个炸弹能炸到的炸弹编号的最小值和最大值，然后就可以算出来答案了。这样$dp$就非常好写了。只要上一个拓扑排序即可。$!Q\omega Q!$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1000000;

int n,top,L[N],R[N],first[N],w,stk2[N],belong[N],low[N],dfn[N];
int q[N],Max[N],Min[N],cnt,Node,A[N],deg[N];
ll X[N],Rad[N],ans;
bool instk[N];
vector<int>V[N];

struct Edge
{
	int to,nxt;
} edge[N<<1];

struct Stack
{
	ll pos,rad,id;
} stk[N];

void add(int x,int y)
{
    edge[++w].to=y;edge[w].nxt=first[x];first[x]=w;
}

void tarjan(int u,int fa)
{
	dfn[u]=low[u]=++cnt;
	stk2[++top]=u;instk[u]=true;
	for (int i=first[u];i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if (!dfn[v]) {tarjan(v,u);low[u]=min(low[u],low[v]);}
			else if (instk[v]) low[u]=min(low[u],dfn[v]);
	}
	if (dfn[u]==low[u])
	{
		int sum=0;++Node;Min[Node]=1000000007;
		while (stk2[top+1]!=u)
		{
			int v=stk2[top];--top;instk[v]=false;
			Min[Node]=min(Min[Node],v);Max[Node]=max(Max[Node],v);
			A[++sum]=v;belong[v]=Node;
		}
		for (int i=1;i<=sum;i++)
			for (int j=first[A[i]];j;j=edge[j].nxt)
			{
				int v=edge[j].to;
				if (belong[v]!=Node) V[Node].push_back(belong[v]),deg[belong[v]]++;
			}
	}
}

int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%lld%lld",&X[i],&Rad[i]);
    L[1]=0;stk[top=1].pos=X[1];stk[1].rad=Rad[1];stk[1].id=1;
    for (int i=2;i<=n;i++)
    {
        while (top&&stk[top].pos+stk[top].rad<X[i]) --top;L[i]=stk[top].id;
        while (top&&R[i]>stk[top].rad) --top;
        stk[++top].pos=X[i];stk[top].rad=Rad[i];stk[top].id=i;
    }
    R[n]=0;stk[top=1].pos=X[n];stk[1].rad=Rad[n];stk[1].id=n;
    for (int i=n-1;i;i--)
    {
        while (top&&stk[top].pos-stk[top].rad>X[i]) --top;R[i]=stk[top].id;
        while (top&&R[i]>stk[top].rad) --top;
        stk[++top].pos=X[i];stk[top].rad=Rad[i];stk[top].id=i;
    }
    for (int i=1;i<=n;i++)
    {
    	if (L[i]) add(L[i],i);
    	if (R[i]) add(R[i],i);
	}
	top=0;
	for (int i=1;i<=n;i++)
		if (!dfn[i]) tarjan(i,0);
	int t=0,w=0;
	for (int i=1;i<=Node;i++)
		if (!deg[i]) q[++w]=i;
	while (t<=w)
	{
		int x=q[++t];
		for (int i=0,s=V[x].size();i<s;i++)
		{
			int y=V[x][i];--deg[y];
			if (!deg[y]) q[++w]=y;
		}
	}
	for (int i=w;i;i--)
		for (int j=0,s=V[q[i]].size();j<s;j++)
		{
			int u=q[i],v=V[u][j];
			Min[u]=min(Min[u],Min[v]);Max[u]=max(Max[u],Max[v]);
		}
	for (int i=1;i<=n;i++)
	{
		int x=belong[i];
		ans=(ans+(ll)i*(Max[x]-Min[x]+1))%1000000007;
	}
	printf("%d\n",ans);
}
```
（码风略丑勿喷）


---

## 作者：人殇物已非 (赞：12)

~~啊哈哈哈哈哈哈哈~我就这么卡过去了啊哈哈哈哈。。。。~~

#### （注：本题解非正解，是卡过去的，只可用于拓展考场上得高分的方法，真正掌握本题还需看别的题解。本题解只做脑洞的拓展。）

咳咳。正经一点。

嗯，我们发现这个题的正解好恶心，tarjan啊，线段树啊，建图啊，~~虽然都是会的知识点，但是~~组合到一起就很复杂了，在考场上没做过原题的话，思维难度和代码难度都十分的大，最后搞出来不如暴力分高就很尴尬了。

**~~所以我们还是打暴力吧。~~**

暴力还是很好写的，对于每个点，我们可以去dfs找到所有可以炸的点，最后统计答案。

当然也可以像我这个一样，去对于每个点向左向右拓展，同时更新当前真正可用的$R$半径，$code$:

```
#include<bits/stdc++.h>
using namespace std;
const int mod=1000000007;
const int maxn=500010;
int n;
long long x[maxn],r[maxn];
int vis[maxn],R[maxn],L[maxn];
void find(int k,long long x1,long long r1,long long l1){
	int i=k+1,j=k-1;
	while(i<=n || j>=1){
		if(x1+r1>=x[i] && i!=n+1){
			r1=max(r1,r[i]+x[i]-x1);
			R[k]=i;
			l1=max(l1,r[i]-x[i]+x1);
		}
		if(x1-l1<=x[j] && j!=0){
			l1=max(l1,r[j]+x1-x[j]);
			L[k]=j;
			r1=max(r1,r[j]-x1+x[j]);
		}
		if(i<n+1) i++;
		if(j>0) j--;
	}
	if(!R[k]) R[k]=k;
	if(!L[k]) L[k]=k;	
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%lld %lld",&x[i],&r[i]);
	}
	for(int i=1;i<=n;i++){
		find(i,x[i],r[i],r[i]);
	}
	long long ans=0;
	for(int i=1;i<=n;i++){
		(ans+=1ll*i*(R[i]-L[i]+1))%=mod;
	}
	cout<<ans;
	return 0;
}
```
### $55pts$ $get!$

来做这道题的人可能都见过有个$O(n)$的错解。

容易发现，你炸到的左边的点可能炸的比你还右边，也就是说两边会相互影响。

而此算法通过扫两遍的方式解决了这个问题，第一遍维护了向左拓展对向右拓展的贡献，第二遍算出向右的最远值并更新右对左的影响。（对于上面的暴力，就是把那个暴力的每次用一次O(n)来算，可惜，这个算法计算的时候只用到拓展最远的点，所以，更新出的$R$半径可能是错的。）

对于复杂度，容易发现，在每个while循环中最多循环2次，第一次是用到自己原有的数据，第二次是跟着拓展出去的点更新信息，容易发现更新出去后已经为最优，所以总复杂度是$O(n)$.

$code:$
```
#include <bits/stdc++.h>
using namespace std;
long long n,x[500005],R[500005],l[500005],r[500005],A;
main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%lld%lld",&x[i],&R[i]),l[i]=r[i]=i;
    for(int i=1;i<=n;i++) 
        while(l[i]>1&&x[i]-x[l[i]-1]<=R[i])
            l[i]=l[l[i]-1],R[i]=max(R[i],R[l[i]]-(x[i]-x[l[i]]));
    for(int i=n;i>=1;i--) 
        while(r[i]<n&&x[r[i]+1]-x[i]<=R[i])
            r[i]=r[r[i]+1],l[i]=min(l[i],l[r[i]]);
    for(int i=1;i<=n;i++) A=(A+i*(r[i]-l[i]+1))%1000000007;
    printf("%lld",A);
}   
```
~~（什么毒瘤代码）~~

但是，由于是随机数据，民间数据强度完全不能够强，bzoj都可以AC，而luogu加了一组hack数据，只有90。即使是官方数据，也据说可以放过去很多。

所以这么优秀的大概率正确的算法，我们如何让它发挥最大的作用，在我们写不出正解的时候帮助我们尽可能多的拿分呢？

很简单，对于出题人造的专门卡的数据，我们跑暴力。。。。。。。

而那些大数据随机生成，不好意思卡不住。

#### $code:$
```
#include <bits/stdc++.h>
using namespace std;
const int maxn=500010;
long long x[500005],R[500005],l[500005],r[500005],A;
const int mod=1000000007;
int n;
long long ans=0;
int vis[maxn],R1[maxn],L[maxn];
void find(int k,long long x1,long long r1,long long l1){
	int i=k+1,j=k-1;
	while(i<=n || j>=1){
		if(x1+r1>=x[i] && i!=n+1){
			r1=max(r1,R[i]+x[i]-x1);
			R1[k]=i;
			l1=max(l1,R[i]-x[i]+x1);
		}
		if(x1-l1<=x[j] && j!=0){
			l1=max(l1,R[j]+x1-x[j]);
			L[k]=j;
			r1=max(r1,R[j]-x1+x[j]);
		}
		if(i<n+1) i++;
		if(j>0) j--;
	}
	if(!R1[k]) R1[k]=k;
	if(!L[k]) L[k]=k;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%lld%lld",&x[i],&R[i]),l[i]=r[i]=i;
    if(n<10000){
    	for(int i=1;i<=n;i++){
			find(i,x[i],R[i],R[i]);
		}
		long long ans=0;
		for(int i=1;i<=n;i++){
			(ans+=1ll*i*(R1[i]-L[i]+1))%=mod;
		}
		cout<<ans;
		return 0;
	}
    for(int i=1;i<=n;i++) 
        while(l[i]>1&&x[i]-x[l[i]-1]<=R[i])
            l[i]=l[l[i]-1],R[i]=max(R[i],R[l[i]]-(x[i]-x[l[i]]));
    for(int i=n;i>=1;i--) 
        while(r[i]<n&&x[r[i]+1]-x[i]<=R[i])
            r[i]=r[r[i]+1],l[i]=min(l[i],l[r[i]]);
    for(int i=1;i<=n;i++) A=(A+i*(r[i]-l[i]+1))%1000000007;
    printf("%lld",A);
    return 0;
}   
```

但是理论上讲，出题人完全也可以造出大数据而可以卡掉的。所以本题解只做一个在考场上对正解莫得办法的时候，骗分的办法。~~（不小心AC了怎么办）~~

---

## 作者：whyl (赞：8)

蒟蒻第一次AC黑题，来写一篇题解来纪念一下

就是线段树优化建图

1.把每个叶子节点（就是真正的炸弹）在线段树上可以炸到范围的区间（和普通线段树一样）连一条边。

2.tarjan缩点，每个强联通分量的权值记为当前强联通分量包含的炸弹数。

3.连边，注意边要见反向（为了topsort），并且不能有重边。

4.topsort，将自己的权值传给自己的后继

5.输出答案。

时间复杂度nlogn，空间复杂度nlogn。

```cpp
#include<bits/stdc++.h>

using namespace std;

#define int long long

#define mid ((l+r)>>1)
#define lson k<<1,l,mid
#define rson k<<1|1,mid+1,r

inline int read(){
	int x=0,f=1;
	char p=getchar();
	while(!isdigit(p)){
		if(p=='-') f=-1;
		p=getchar();
	}
	while(isdigit(p)) x=(x<<3)+(x<<1)+p-48,p=getchar();
	return x*f;
}

long long ans;

const int maxn=5e5+5,mod=1e9+7;

int s[maxn<<2],low[maxn<<2],dfn[maxn<<2],n,b[maxn],a[maxn],tot;
int x[maxn],tree[maxn<<2],headedge[maxn<<2],veredge[maxn<<2];
int head[maxn<<2],nxt[maxn*25],ver[maxn*25],scc,col[maxn<<2];
int v[maxn<<2],id[maxn],cnt,top,nxtedge[maxn<<2],cntedge;
int w[maxn<<2],nod,rd[maxn<<2],f[maxn<<2];
map<pair<int,int>,int> Map;

inline void add(int x,int y){
	nxt[++cnt]=head[x];
	head[x]=cnt;
	ver[cnt]=y;
}

inline void addedge(int x,int y){
	nxtedge[++cntedge]=headedge[x];
	headedge[x]=cntedge;
	veredge[cntedge]=y;
}

inline void build(int k,int l,int r){
	if(l==r){
		nod=max(nod,k);
		id[l]=k;
		return;
	}
	build(lson);
	build(rson);
	add(k,k<<1);
	add(k,k<<1|1);
}

inline void connect(int k,int l,int r,int L,int R,int pos){
	if(L<=l&&r<=R){
		if(id[pos]==k) return;
		add(id[pos],k);
		return;
	}
	if(L<=mid) connect(lson,L,R,pos);
	if(R>mid) connect(rson,L,R,pos);
	return;
}

inline void tarjan(int x){
	dfn[x]=low[x]=++tot;
	s[++top]=x;
	v[x]=1;
	for(int i=head[x];i;i=nxt[i]){
		int y=ver[i];
		if(!dfn[y]){
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(v[y]) low[x]=min(low[x],dfn[y]);
	}
	if(low[x]==dfn[x]){
		int tmp;
		scc++;
		do{
			tmp=s[top--];
			col[tmp]=scc;
			v[tmp]=0;
			
		}while(x!=tmp);
	}
}

signed main(){
	n=read();
	for(int i=1;i<=n;i++) b[i]=a[i]=read(),x[i]=read();
	//线段树 
	build(1,1,n);
	for(int i=1;i<=n;i++){
		int l=lower_bound(b+1,b+1+n,a[i]-x[i])-b;
		int r=(upper_bound(b+1,b+1+n,a[i]+x[i])-b)-1;
		connect(1,1,n,l,r,i);
	}
	//tarjan 
	for(int i=1;i<=nod;i++) if(!dfn[i]) tarjan(i);
	for(int i=1;i<=n;i++) w[col[id[i]]]++;
	//连边 
	for(int x=1;x<=nod;x++){
		for(int i=head[x];i;i=nxt[i]){
			int y=ver[i];
			if(col[x]==col[y]) continue;
			pair<int,int> t;
			t.first=col[y],t.second=col[x];
			if(Map[t]==1) continue;
			addedge(col[y],col[x]);
			Map[t]=1;
			++rd[col[x]];
		}
	}
	//topsort 
	queue<int> q;
	for(int i=1;i<=scc;i++) if(rd[i]==0) q.push(i);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		f[x]+=w[x];
		for(int i=headedge[x];i;i=nxtedge[i]){
			int y=veredge[i];
			f[y]+=f[x];
			rd[y]--;
			if(rd[y]==0) q.push(y);
		}
	}
	//统计答案 
	for(int i=1;i<=n;i++) ans=(ans+i*f[col[id[i]]]%mod)%mod;
	cout<<ans<<endl;
	return 0;
}
```

6.等待AC。

蒟蒻第一次写黑题题解，求管理放过，谢谢。

---

## 作者：shame_djj (赞：7)

原题链接[【[SNOI2017]炸弹】](https://www.luogu.org/problem/P5025)

首先，本题解是非正解，只是一种暴力的优化

没有用到什么线段树优化建边，仅仅是简单的刚入门一点的知识

前置知识

		STL二分，lower_bound 与 upper_bound

		ST 表，或者线段树，反正是支持查询区间最大最小值的数据结构


第一个问题：爆炸的范围

可以在 n 方的时间内预处理出来

但不可取，考虑优化，二分，是了，二分就好了

（善用 STL 是一种技能）

给出我预处理范围的代码

```cpp
	for (register int i = 1; i <= n; i ++)
		ll[i] = lower_bound (x + 1, x + i, x[i] - r[i]) - x;
	for (register int i = 1; i <= n; i ++)
		rr[i] = upper_bound (x + i + 1, x + n + 1, x[i] + r[i]) - x - 1;
```

然后，暴力搜素的思路非常好想

		对于每一个点，在它能炸到区域内暴力搜索一遍，递归

		然后，当它不能再使当前区域扩大时，结束搜索

考虑优化

我们的暴力算法的瓶颈在哪里呢？

		每回找到当前区域中所有点的能到达的最靠左和最靠右的两个位置

		如果暴力扫一遍的话，时间复杂度就退化到 n 方了，

		显然不可取。

在这里给出我的主程序

```cpp
for (register int i = 1; i <= n; i ++) {
        xx = yy = ansl = ansr = i;
        t.query (ll[i], rr[i]);
        while (xx != ansl && yy != ansr) {
            xx = ansl, yy = ansr;
            t.query (ansl, ansr);//即爆搜
        }
        ans = (ans + i * (ansr - ansl + 1) % mod) % mod;
    }
    printf ("%lld\n", ans % mod);
```


如何优化呢？

再读一遍

		“每回找到当前区域中所有点的能到达的最靠左和最靠右的两个位置”

		这是什么？！！

		区间查询最大最小值，无修改，线段树板子啊

		当然这需要预处理出每个点能到达的最靠左和最靠右的点。

然后这样优化后，直接就 AC 了

给出我的预处理代码

```cpp
n = read();
    for (register int i = 1; i <= n; i ++)
        x[i] = read(), r[i] = read();
    for (register int i = 1; i <= n; i ++)
        ll[i] = lower_bound (x + 1, x + i, x[i] - r[i]) - x;
    for (register int i = 1; i <= n; i ++)
        rr[i] = upper_bound (x + i + 1, x + n + 1, x[i] + r[i]) - x - 1;
    t.init ();
```

线段树代码

```cpp
struct djj_lxy_Tree {
    struct node {
        int l, r;
    } z[maxn << 2];

    void build (int l, int r, int x) {
        if (l == r) {
            z[x].l = ll[l];
            z[x].r = rr[l];
            return ;
        }
        int mid = l + r >> 1;
        build (l, mid, x << 1);
        build (mid + 1, r, x << 1 | 1);
        z[x].l = min (z[x << 1].l, z[x << 1 | 1].l);
        z[x].r = max (z[x << 1].r, z[x << 1 | 1].r);
    }

    void query (int l, int r, int x, int nowl, int nowr) {
        if (nowl <= l && r <= nowr) {
            ansl = min (z[x].l, ansl);
            ansr = max (z[x].r, ansr);
            return ;
        }
        int mid = l + r >> 1;
        if (nowl <= mid)
            query (l, mid, x << 1, nowl, nowr);
        if (mid < nowr)
            query (mid + 1, r, x << 1 | 1, nowl, nowr);
        return ;
    }
} t;
```
[AC记录](https://www.luogu.org/record/24031602)

跑的挺慢的，如果你只追求过掉这道题，可以走开了

仔细地再想一想，还能怎样

		线段树查询一次 O（log（n））

		无修改，那我们可以用 ST 表啊

		改了之后，我又试了试

		在这里也算是多提供一种思路

给出我的 ST 表代码

```cpp
struct djj_lxy_ST {
    int djj[maxn][19], lxy[maxn][19];

    void init () {
        for (register int i = 1; i <= n; i ++)
            djj[i][0] = ll[i], lxy[i][0] = rr[i];
        for (register int j = 1; j <= 19; j ++)
            for (register int i = 1; i + (1 << j) - 1 <= n; i ++)
                djj[i][j] = min (djj[i][j - 1], djj[i + (1 << (j - 1))][j - 1]);
        for (register int j = 1; j <= 19; j ++)
            for (register int i = 1; i + (1 << j) - 1 <= n; i ++)
                lxy[i][j] = max (lxy[i][j - 1], lxy[i + (1 << (j - 1))][j - 1]);
    }

    void query (int l, int r) {
        int k = log2 (r - l + 1);
        ansl = min (ansl, min (djj[l][k], djj[r - (1 << k) + 1][k]));
        ansr = max (ansr, max (lxy[l][k], lxy[r - (1 << k) + 1][k]));
    }
} t;
```

[AC记录](https://www.luogu.org/record/24031910)

慢了一倍，真的

		然后我懵了，不知为何，但慢了是不争的事实

		我想了想，可能是 log2 的玄学复杂度

		于是我加上 log2 的递推

代码

```cpp
	for (register int i = 1; i <= 19; i ++)
		logg[1 << i] = 1;
	for (register int i = 1; i <= n; i ++)
		logg[i] += logg[i - 1];
```

它还慢，[AC记录](https://www.luogu.org/record/24031992)

没法儿了 QwQ~~

那么这个就留作一个美丽的问号吧，希望自己在以后能变得更强，然后回来解决这个问题

那本题解就这样吧，完结撒花~~

（哦对了，记得开 long long ）

距离新 Noip 还有不到 2 个月，祝大家 rp ++

也希望自己可以更努力一些，加油！！

··············································································································

十月二日更新，加入了树状数组优化 log 的尝试

没怎么打算填这个坑，草草的粘上代码了事

时间 3.99 s，没开 O2，但还是好慢~~

```cpp
struct djj_lxy_Log {
	int log_[maxn];

	void add (int i, int x) {
		for (; i <= n; i += i & -i)
			log_[i] += x;
	}

	int ask (int i) {
		int ans = 0;
		for (; i; i -= i & -i)
			ans += log_[i];
		return ans;
	}

	void init () {
		for (register int i = 1; i <= 19; i ++)
			add (1 << i, 1);
	}
} log_;
```

希望在接下来的日子里，自己能够继续努力，加油哦

---

## 作者：mzgwty (赞：5)

这绝对不是黑题！！！这一定是恶意评分(虽然大多数人写的都是长的要死的线段树建图+tarjan)

这只用一个线段树维护就好了！！！( 虽然比大部分人都慢，其他题解都是$O(n)$或者$O(n \ log \ n)$，我的是理想情况$O(n \ log^2 \ n)$，但其实会被那种每颗炸弹只能炸到旁边那一颗的数据卡成$O(n^2 \ log \ n)$，~~可见数据有好水~~)

用lft表示当前点能直接炸到的最左点，rht表示能直接炸到的最右点

首先预处理出lft和rht

```cpp
read(n);
for(register unsigned i=1 ; i<=n ; ++i) {
	read(x[i]),read(r[i]);
}
for(register unsigned i=1 ; i<=n ; ++i) {
	lft[i]=lower_bound(x+1,x+i,x[i]-r[i])-x;
	rht[i]=upper_bound(x+i+1,x+n+1,x[i]+r[i])-x-1;
}
```

然后通过线段树来维护每个区间能直接炸到的最左点和最右点，用ll和rr表示

```cpp
inline void build(int k,int l,int r) {
	if(l==r) {
		ll[k]=lft[l];
		rr[k]=rht[l];
		return ;
	}
	build(lson,l,mid);
	build(rson,mid+1,r);
	ll[k]=min(ll[lson],ll[rson]);
	rr[k]=max(rr[lson],rr[rson]);
}
```
然后查询点x能炸到的左右端点(不是直接)

```cpp
xx=yy=L=R=i;
do {
	xx=L,yy=R;
	L=0x7fffffff,R=-0x7fffffff;
	query(1,1,n,xx,yy);//查询区间xx~yy能炸到的左端点和右端点
} while(L!=xx||R!=yy);//xx~yy表示当前区间,L~R表示当前区间能炸到的区间，如果两个区间相同就跳出循环
```
~~我知道你们只看这个~~

```cpp
#include<bits/stdc++.h>
#define lson (k<<1)
#define rson (k<<1|1)
#define mid (l+r>>1)
#define int long long
using namespace std;

const int mod=1e9+7;

inline void read(int &res) {
    res=0;
    char ch;
    int flag=1;
    while(isspace(ch=getchar()));
    if(ch=='-') ch=getchar(),flag=-1;
    do {
        res=res*10+ch-'0';
    }while(isdigit(ch=getchar()));
    res*=flag;
}

inline void print(long long res) {
    if(res<0) putchar('-'),res=-res;
    if(res>9) print(res/10);
    putchar(res%10+'0');
}

const int N=500001;

int x[N],r[N],lft[N],rht[N],n;

int ll[N<<2],rr[N<<2],L,R;

long long ans;

inline void build(int k,int l,int r) {
    if(l==r) {
        ll[k]=lft[l];
        rr[k]=rht[l];
        return ;
    }
    build(lson,l,mid);
    build(rson,mid+1,r);
    ll[k]=min(ll[lson],ll[rson]);
    rr[k]=max(rr[lson],rr[rson]);
}

inline void query(int k,int l,int r,int x,int y) {
    if(l>y||r<x||l>r) return ;
    if(l>=x&&r<=y) {
        L=min(L,ll[k]);R=max(R,rr[k]);
        return ;
    }
    query(lson,l,mid,x,y);
    query(rson,mid+1,r,x,y);
}

signed main() {
    read(n);
    for(register unsigned i=1 ; i<=n ; ++i) {
        read(x[i]),read(r[i]);
    }
    for(register unsigned i=1 ; i<=n ; ++i) {
        lft[i]=lower_bound(x+1,x+i,x[i]-r[i])-x;
        rht[i]=upper_bound(x+i+1,x+n+1,x[i]+r[i])-x-1;
    }
    build(1,1,n);
    int xx,yy;
    for(register unsigned i=1 ; i<=n ; ++i) {
        xx=yy=L=R=i;
        do {
            xx=L,yy=R;
            L=0x7fffffff,R=-0x7fffffff;
            query(1,1,n,xx,yy);
        } while(L!=xx||R!=yy);
        ans=(ans+i*(yy-xx+1)%mod)%mod;
    }
    print(ans);
    return 0;
}
```


(写完后发现有题解和自己写的一样怎么办啊)

---

## 作者：LG_ljc2022 (赞：3)

## 题目大意

一条直线上给定 $n$ 个点，每个点的影响范围是 $r_i$，激
发一个点后，影响范围内的点也会被激发，求 $\sum_{i = 1}^{n} i \times num$ 对 $10 ^ 9 + 7$ 取模的值，其中 $num$ 表示激发 $i$ 能激发的点的数量。

## Solution

题解区里的大佬们都在用 Tarjan 加线段树优化建图，机房的同志们也是这么做的。

虽然标签是这么写的，但不用高级数据结构不行吗？

于是这里提供一种不用图论和高级数据结构的解法。

看到这道题，笔者立马想到了另外一道很相似的题目：[CF65E - Domino Principle](https://www.luogu.com.cn/problem/CF56E)。

多米诺骨牌倾倒后也会发生连锁反应，也有可能会出现小骨牌压到超级骨牌的情况，唯一和本题不一样的地方是骨牌只能向右倾倒，即只会对右边产生影响，而本题无论左右都会对答案产生贡献。

尽管如此，我们依然可以借鉴那道题的思路进行迁移运用。我们对于每一个炸弹 $i$，设定 $left_i$ 和 $right_i$ 表示当前炸弹最远能引爆的炸弹的编号，则引爆数量为 $right_i - left_i + 1$。首先判断炸弹 $i$ 向右能否影响到当前它右边能影响的最远的炸弹的右边第一个炸弹，如果不能则终止判断，否则右侧最远更新为最远的炸弹的右边第一个炸弹最远能影响的范围，并更新 $i$ 号节点的爆炸范围 $r_i$。可以借助下图进行理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/2sxv3tzs.png?x-oss-process=image/resize,m_lfit,h_777,w_999)

同理，我们可以用类似的方式更新炸弹向左最远能影响到的距离。此时炸弹 $i$ 向左能影响的最大距离之前向右算的时候就已经更新过，已经达到最大，因此不必继续更新。注意不排除左侧也会有超级炸弹的可能，所以向右最远同样需要更新。

此时左右最远都已经更新完毕，计算答案即可，注意需要取模。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const long long mod = 1e9 + 7;
const int N = 5e5 + 10;
struct node
{
	long long x, r, left, right;
}a[N];
long long n, ans; 
int main()
{
	
	scanf("%lld", &n);
	for (int i = 1; i <= n; i++) scanf("%lld%lld", &a[i].x, &a[i].r);
	for (int i = 1; i <= n; i++) a[i].left = a[i].right = i;
	for (int i = n - 1; i >= 1; i--)
		while (a[i].right < n && a[a[i].right + 1].x - a[i].x <= a[i].r)
		{
			a[i].r = max(a[i].r, max(a[a[i].right].r - (a[a[i].right].x - a[i].x), a[a[i].right + 1].r - (a[a[i].right + 1].x - a[i].x)));
			a[i].right = a[a[i].right + 1].right;
		}
	for (int i = 2; i <= n; i++)
		while (a[i].left > 1 && a[i].x - a[a[i].left - 1].x <= a[i].r)
		{
			a[i].right = max(a[i].right, a[a[i].left - 1].right);
			a[i].left = a[a[i].left - 1].left;
		}
	for (int i = 1; i <= n; i++) ans += i * (a[i].right - a[i].left + 1) % mod, ans %= mod;
	printf("%lld", ans);
	
	return 0;
}
``````

---

## 作者：wangruibo20 (赞：2)

首先我们知道这道题是图论。~~不会有人看不出来吧~~

我们将炸弹能够影响的范围转换为边，若炸弹 $i$ 能够引爆炸弹 $j$，就有单向边 $(i,j)$。

然后就是常见套路：Tarjan 缩点完跑拓扑排序（建反图）。

要注意，在拓扑排序中不能直接加上一个点的贡献，因为可能两个点同时被一个点指向也同时指向一个点。

这时候我们可以得到一个结论：一个炸弹引爆后所影响的炸弹一定是连续的。

简单思考一下：一个炸弹 $i$ 会炸到坐标在 $x_i-r_i\sim x_i+r_i$ 之间的炸弹，而后续再次的爆炸只会使区间更大，区间中间并不会出现空隙。

所以拓扑里面就可以改成用一个点所影响区间的左端点和右端点更新另一个点的左端点和右端点。

还有个问题，如果我们按照上面的方式建边，条数就会达到 $n^2$，时间和空间都撑不下这么多。

现在只有两条路可走：一条优化算法，一条优化建图。

明显，Tarjan 和拓扑排序足够优秀，优化空间非常小，所以只能优化建图。

可以很容易看出，一个点会对于一个区间的点进行连边操作，而对于区间，我们有一个专门维护它的数据结构：线段树。

在这道题中，一个点向一个区间的点连边，就可以看成在线段树上一个点向覆盖范围为原区间的几个点连边。

而一个区间最多用 $\log n$ 个线段树上的点进行表示，于是我们只用建 $n\log n$ 条边就能完全表示原先的边集了（所付出的代价只是多用了 $n$ 个点）。

所以总的时间复杂度就为 $\mathcal O(n\log n)$。

$Code$：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,id1,id2,dfn[2000005],lmn[2000005],rmx[2000005],ll[2000005],rr[2000005],low[2000005],belong[2000005],cnt,bh[500005],rd[2000005],head[2000005],nxt[20000005],to[20000005],head1[2000005],nxt1[20000005],to1[20000005],sz[2000005];
long long x[500005],r[500005];
constexpr const long long mod=1e9+7;
long long ans;
void add(int u,int v){
	nxt[++cnt]=head[u];
	head[u]=cnt;
	to[cnt]=v;
}void add1(int u,int v){
	nxt1[++cnt]=head1[u];
	head1[u]=cnt;
	to1[cnt]=v;
}void build(int p,int l,int r){
	ll[p]=l,rr[p]=r;
	if(l==r)return bh[l]=p,k=max(k,p),void();
	int mid=l+r>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	add(p,p<<1);
	add(p,p<<1|1);
}void add(int p,int l,int r,int tl,int tr,int id){
	if(tl<=l&&r<=tr)return id!=p?add(id,p):void();
	int mid=l+r>>1;
	if(mid>=tl)add(p<<1,l,mid,tl,tr,id);
	if(mid<tr)add(p<<1|1,mid+1,r,tl,tr,id);
}stack<int>s;
void tarjan(int u){
	dfn[u]=low[u]=++id1;
	s.push(u);
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}else if(!belong[v])low[u]=min(low[u],low[v]);
	}if(dfn[u]==low[u]){
		id2++;
		while(1){
			int v=s.top();
			s.pop();
			belong[v]=id2;
			lmn[id2]=min(lmn[id2],ll[v]);
			rmx[id2]=max(rmx[id2],rr[v]);
			if(u==v)break;
		}
	}
}queue<int>q;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>x[i]>>r[i];
	memset(lmn,0x3f,sizeof lmn);
	build(1,1,n);
	for(int i=1;i<=n;i++){
		int ll=lower_bound(x+1,x+1+n,x[i]-r[i])-x,rr=upper_bound(x+1,x+1+n,x[i]+r[i])-x-1;
		add(1,1,n,ll,rr,bh[i]);
	}tarjan(1);
	cnt=0;
	for(int i=1;i<=k;i++)for(int j=head[i];j;j=nxt[j])if(belong[i]!=belong[to[j]])rd[belong[i]]++,add1(belong[to[j]],belong[i]);
	for(int i=1;i<=id2;i++)if(!rd[i])q.push(i);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head1[u];i;i=nxt1[i]){
			int v=to1[i];
			lmn[v]=min(lmn[u],lmn[v]);
			rmx[v]=max(rmx[u],rmx[v]);
			rd[v]--;
			if(!rd[v])q.push(v);
		}
	}for(long long i=1;i<=n;i++)ans=(ans+i*(rmx[belong[bh[i]]]-lmn[belong[bh[i]]]+1))%mod;
	cout<<ans;
	return 0;
}
```

（码风奇异，请见谅）

---

## 作者：rq_kyz (赞：2)

# 【题解】 P5025 [SNOI2017] 炸弹

### 传送门

[P5025 [SNOI2017] 炸弹](https://www.luogu.com.cn/problem/P5025)

---

### 题意

有 $n$ 个炸弹分布在数轴上，每一个的坐标为 $x_i$，爆炸半径为 $r_i$，如果炸弹 $i$ 与炸弹 $j$ 满足 $x_i-r_i\le x_j\le x_i+r_i$，这时如果引爆 $i$，$j$ 也会跟着被引爆。问先引爆每一个炸弹会被引爆的总炸弹数，每个询问独立。

---

### 分析

首先，我们发现每个炸弹可以引爆的炸弹编号是一段连续的区间，也就是说，如果把引爆关系转变为边，则每个炸弹会指向一段区间（中的所有炸弹）。所以可以使用线段树优化建图。

以样例一为例，如下图：

![](https://s11.ax1x.com/2024/02/01/pFMoxKA.png)

我们先把线段树建出来，对于单个炸弹（即只表示一个炸弹的叶子节点），我们连出一些边，指向它炸一次可以炸到的范围，如下图：

![](https://s11.ax1x.com/2024/02/01/pFMTSbt.png)

这个图就是线段树优化建图后的样子了，但由于更新方向是相反的，所以我们需要建反图：

![](https://s11.ax1x.com/2024/02/01/pFMTP58.png)

接下来就可以在这个反图上跑 Tarjan 缩点，然后拓扑排序求得答案。

细心的同学们会发现，这样有可能算重，如下图：

![](https://s11.ax1x.com/2024/02/01/pFM79y9.png)

假设点 $1$ 可以引爆的点数为 $1$，则 $2$ 和 $3$ 会被更新为 $1$，但 $4$ 会被更新为 $2$，这样就会算重。

还是利用上面的性质：每个炸弹可以引爆的炸弹编号是一段连续的区间。所以其实不需要记录引爆的点数，可以直接记录引爆区间的左右端点，每次更新是取最小最大值就可以了

---

### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll p=1e9+7;
ll a[500001],r[500001];
struct s1{
	ll x,y;
}b[11000001];
ll d[2000001];
ll last[2000001];
struct s2{
	ll t,to;
}nxet[11000001];
ll cd=0;
void lj(ll x,ll y,bool bol){
	nxet[++cd].t=last[x];
	nxet[cd].to=y;
	last[x]=cd;
	if(bol){
		b[cd].x=x;
		b[cd].y=y;
	}
	else
		d[y]++;
}
ll n1=0,c[500001];
struct s3{
	ll l,r;
}tree[2000001];
void make_tree(ll p,ll l,ll r){
	n1=max(n1,p);
	tree[p].l=l;
	tree[p].r=r;
	if(l<r){
		ll mid=(l+r)>>1;
		make_tree(2*p,l,mid);
		make_tree(2*p+1,mid+1,r);
		lj(2*p,p,1);
		lj(2*p+1,p,1);
	}
	else
		c[l]=p;
}
void add(ll p,ll l,ll r,ll k){
	if(l<=tree[p].l && tree[p].r<=r){
		lj(p,c[k],1);
		return;
	}
	ll mid=(tree[p].l+tree[p].r)>>1;
	if(l<=mid)
		add(2*p,l,r,k);
	if(r>mid)
		add(2*p+1,l,r,k);
}
bool t[2000001];
ll cnt=0,dfn[2000001],low[2000001];
ll len=0,sta[2000001];
ll sc=0,belong[2000001],sz[2000001];
vector<ll> scc[2000001];
void Tarjan(ll u){
	t[u]=1;
	dfn[u]=low[u]=++cnt;
	sta[++len]=u;
	for(ll j=last[u];j;j=nxet[j].t){
		ll v=nxet[j].to;
		if(!dfn[v]){
			Tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(!belong[v])
			low[u]=min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u]){
		sc++;
		while(1){
			scc[sc].push_back(sta[len]);
			belong[sta[len]]=sc;
			sz[sc]++;
			if(sta[len--]==u)
				break;
		}
	}
}
queue<ll> q;
ll dp1[2000001],dp2[2000001];
int main(){
	ll n;
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++)
		scanf("%lld%lld",&a[i],&r[i]);
	make_tree(1,1,n);
	for(ll i=1;i<=n;i++){
		ll L1=1,R1=n;
		while(L1<R1){
			ll mid=(L1+R1)>>1;
			if(a[mid]<a[i]-r[i])
				L1=mid+1;
			else
				R1=mid;
		}
		ll L2=1,R2=n;
		while(L2<R2){
			ll mid=(L2+R2+1)>>1;
			if(a[mid]>a[i]+r[i])
				R2=mid-1;
			else
				L2=mid;
		}
		add(1,L1,L2,i);
	}
	for(ll i=1;i<=n1;i++)
		if(!t[i])
			Tarjan(i);
	ll m=cd;
	memset(last,0,sizeof(last));
	cd=0;
	for(ll i=1;i<=m;i++){
		ll x=b[i].x,y=b[i].y;
		if(belong[x]!=belong[y])
			lj(belong[x],belong[y],0);
	}
	memset(dp1,0x3f,sizeof(dp1));
	for(ll i=1;i<=n;i++){
		dp1[belong[c[i]]]=min(dp1[belong[c[i]]],i);
		dp2[belong[c[i]]]=max(dp2[belong[c[i]]],i);
	}
	for(ll i=1;i<=sc;i++)
		if(!d[i])
			q.push(i);
	while(!q.empty()){
		ll x=q.front();
		q.pop();
		for(ll j=last[x];j;j=nxet[j].t){
			ll y=nxet[j].to;
			dp1[y]=min(dp1[y],dp1[x]);
			dp2[y]=max(dp2[y],dp2[x]);
			d[y]--;
			if(!d[y])
				q.push(y);
		}
	}
	ll ans=0;
	for(ll i=1;i<=n;i++)
		ans+=i*(dp2[belong[c[i]]]-dp1[belong[c[i]]]+1)%p;
	printf("%lld",ans%p);
	return 0;
}            
```

---

## 作者：Ryan_ (赞：2)

暴力：

对于每一个炸弹，枚举所有的炸弹，看它爆炸能不能引爆那个炸弹

如果能，由这个炸弹向引爆的炸弹连单向边

tarjan所点后拓扑排序

在拓扑图上倒着统计答案

可以得到一个炸弹能引爆的编号最小mi和最大的炸弹mx，mx-mi+1就是先引爆这个炸弹一共能引爆的炸弹数

优化：

一个炸弹一定是向一段区间连边

所以用线段树优化，这样向一个区间连边就变成了向一个点连边

 

注意存边的空间一定要开的足够大

还有tarjan缩完点后不一定是一棵树，因为是有向图缩点

CODE：

```
#include<cstdio>
#include<vector>
#include<iostream>
#include<algorithm>
 
using namespace std;
 
const int mod=1e9+7;
 
#define N 500001 
 
typedef long long LL;
 
int n;
 
int id[N*3],num;
int front[N*3],to[N*21],nxt[N*21],from[N*21],tot;
 
LL pos[N],rad[N];
 
int dfn[N*3],low[N*3],tim;
int st[N*3],top;
bool vis[N*3];
 
int cnt;
int bl[N*3],mi[N*3],mx[N*3];
 
vector<int>V[N*3];
int in[N*3];
 
int q[N*3];
 
template<typename T>
void read(T &x)
{
    x=0; int f=1; char c=getchar();
    while(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }
    while(isdigit(c)) { x=x*10+c-'0'; c=getchar(); }
    x*=f;
}
 
void add(int u,int v)
{
    to[++tot]=v; nxt[tot]=front[u]; front[u]=tot; from[tot]=u; 
    //printf("%d %d\n",u,v);
}
 
/*void add2(int u,int v)
{
    to2[++tot2]=v; nxt2[tot2]=front2[u]; front2[u]=tot2;
}*/
 
void build(int k,int l,int r)
{
    id[k]=++num;
    if(l==r)
    {
        add(id[k],l);
        return;
    }
    int mid=l+r>>1;
    build(k<<1,l,mid);
    build(k<<1|1,mid+1,r);
    add(id[k],id[k<<1]);
    add(id[k],id[k<<1|1]);
}
 
void burst(int k,int l,int r,int opl,int opr,int who)
{
    if(l>=opl && r<=opr)
    {
        add(who,id[k]);
        return;
    }
    int mid=l+r>>1;
    if(opl<=mid) burst(k<<1,l,mid,opl,opr,who);
    if(opr>mid) burst(k<<1|1,mid+1,r,opl,opr,who);
}
 
void init()
{
    read(n);
    num=n;
    build(1,1,n);
    for(int i=1;i<=n;++i) read(pos[i]),read(rad[i]);
    for(int i=1;i<=n;++i) burst(1,1,n,lower_bound(pos+1,pos+n+1,pos[i]-rad[i])-pos,upper_bound(pos+1,pos+n+1,pos[i]+rad[i])-pos-1,i);
}
 
void tarjan(int x)
{
    dfn[x]=low[x]=++tim;
    st[++top]=x;
    vis[x]=true;
    for(int i=front[x];i;i=nxt[i])
        if(!dfn[to[i]])
        {
            tarjan(to[i]);
            low[x]=min(low[x],low[to[i]]);
        }
        else if(vis[to[i]]) low[x]=min(low[x],dfn[to[i]]);
    int y;
    if(low[x]==dfn[x])
    {
        cnt++;
        mi[cnt]=n+1;
        mx[cnt]=0;  
        while(x!=y)
        {
            y=st[top--];
            vis[y]=false;
            bl[y]=cnt;
            if(y<=n) 
            {
                mi[cnt]=min(mi[cnt],y);
                mx[cnt]=max(mx[cnt],y);
            }
        }
    }
}
 
void rebuild()
{
    for(int i=1;i<=tot;++i)
        if(bl[from[i]]!=bl[to[i]]) 
        {
            //add2(bl[from[i]],bl[to[i]]);
            V[bl[from[i]]].push_back(bl[to[i]]);
            in[bl[to[i]]]++;
        }
}
 
void topsort()
{
    int head=1,tail=1;
    for(int i=1;i<=cnt;++i) 
        if(!in[i]) q[tail++]=i;
    int now,siz,t;
    while(head<tail)
    {
        now=q[head++];
        siz=V[now].size();
        for(int i=0;i<siz;++i)
        {
            t=V[now][i];
            in[t]--;
            if(!in[t]) q[tail++]=t;
        }
    }
    for(int i=tail-1;i;--i)
    {
        now=q[i];
        siz=V[now].size();
        for(int i=0;i<siz;++i)
        {
            t=V[now][i];
            mi[now]=min(mi[now],mi[t]);
            mx[now]=max(mx[now],mx[t]);
        }
    }
}
 
 
void work()
{
//  printf("%d %d\n",num,tot);
    for(int i=1;i<=num;++i)
        if(!dfn[i]) tarjan(i);
    rebuild();
    topsort();
    int ans=0;
    for(int i=1;i<=n;++i) 
    {
        ans+=1LL*i*(mx[bl[i]]-mi[bl[i]]+1)%mod;
        ans-=ans>=mod ? mod : 0;
    }
    printf("%d",ans);
}
 
int main()
{
    init();
    work();
}
```


---

## 作者：hjmmm (赞：2)

[原博客](https://www.cnblogs.com/hjmmm/p/10473164.html)

本文为线段树做法 ~~码量极小~~

（听说可以tarjan缩点+拓扑？
感觉差不多。。而且这样看起来方便很多

找到左端点的过程可以看作
点 -> 区间内lowerbound最小的点 -> lowerbound -> 区间内lowerbound最小的点  -> lowerbound -> ......

所以直接维护每个点lowerbound，线段树维护下就好啦

右端点同理

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;
const int N = 5e5 + 5;
const long long P = 1e9 + 7;
const int inf = 0x3f3f3f3f;

int n, m;
long long pos[N], rad[N];
int L[N], R[N];
long long ans;

struct Seg{
	int lm[N << 2], rm[N << 2];
	void update(int rt){
		lm[rt] = min(lm[rt << 1], lm[rt << 1 | 1]);
		rm[rt] = max(rm[rt << 1], rm[rt << 1 | 1]);
	}
	void build(int l, int r, int rt){
		if(l == r){
			lm[rt] = L[l], rm[rt] = R[l]; 
			return ;
		}
		int mid = l + ((r - l) >> 1);
		build(l, mid, rt << 1);
		build(mid + 1, r, rt << 1 | 1);
		update(rt);
	}
	void qry(int l, int r, int x, int y, int& nx, int& ny, int rt){
		if(l == x && r == y){
			nx = min(lm[rt], nx); ny = max(rm[rt], ny); return ;
		}
		int mid = l + ((r - l) >> 1);
		if(x <= mid) qry(l, mid, x, min(y, mid), nx, ny, rt << 1);
	        if(y > mid) qry(mid + 1, r, max(x, mid + 1), y, nx, ny, rt << 1 | 1);
	}
}seg;

inline int l_lim(int x){
	return lower_bound(pos + 1, pos + x, pos[x] - rad[x]) - pos;
}

inline int r_lim(int x){
	return upper_bound(pos + x + 1, pos + n + 1, pos[x] + rad[x]) - pos - 1;
}

int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i){
		scanf("%lld%lld", &pos[i], &rad[i]);
	}
	for(int i = 1; i <= n; ++i){
		L[i] = l_lim(i);
		R[i] = r_lim(i);
	}
	seg.build(1, n, 1);
	
	ans = 0;
	int x, y, nx, ny;
	for(int i = 1; i <= n; ++i){
	    x = y = nx = ny = i;
	    do{
	    	x = nx, y = ny;
	        nx = inf, ny = -inf; seg.qry(1, n, x, y, nx, ny, 1);  
	    }while((nx ^ x) | (ny ^ y));
	    ans = (ans + 1ll * i * (y - x + 1) % P) % P;
	    //这里原来忘乘1ll了爆了long long
	}
	printf("%lld\n", ans);
    return 0;	
}
/*
单纯维护两边并更新不可行 可能会有折向引爆 
*/
```

---

## 作者：bzy369258147 (赞：2)

trajan是不可能写他tarjan的，这辈子都不可能.

直接线段树就可以做这题了，为何要tarjan.直接离散一波，然后记录一下每个点左右能炸到的范围，建一棵线段树，记录一下每个区间的炸弹能炸到的左右范围，然后直接查询后迭代到不能迭代。当然也要实时更新一下该区间的最远左右到达的距离,然后可以用单调栈的思路大概证明只会迭代O(n)次，乘上线段树的O(lnn)和离散化的O(nlnn),最终复杂度为O(nlnn).

代码如下.

```
#include<bits/stdc++.h>
using namespace std;
 
namespace SGT{
    #define Lson ( now << 1 )
    #define Rson ( Lson | 1 )
    #define Ason ( P <= mid ? Lson : Rson )
    #define mid ( (l[now] + r[now]) >> 1 )
    #define Lrange Lson,L,min(mid,R)
    #define Rrange Rson,max(L,mid + 1),R
     
    struct node{ 
        int x,y;
        node() : x(5000000),y(-1) {}
        node(int _x,int _y) : x(_x),y(_y) {}
        void print(){ cout << "<" << x << "," << y << ">\n"; }
        bool operator !=(const node& From) const { return x != From.x or y != From.y; }
        node const operator +(const node& From){ return node( min(x,From.x),max(y,From.y) ); }
    }   v[2000005],line[500005];
    int l[2000005];
    int r[2000005];
     
    void updata(int now){ v[now] = v[Lson] + v[Rson]; }
    void build (int now,int L,int R){
        l[now] = L,r[now] = R;
        if( L == R )return void( v[now] = line[L] );
        build( Lrange );build( Rrange );updata(now);
    }
    void modify(int now,int P,node val){
        if( l[now] == r[now] )return void( v[now] = val );
        modify( Ason,P,val );updata(now);
    }
    node query(int now,int L,int R){
        if( l[now] == L and r[now] == R )return v[now];
        node ansL = node(),ansR = node();
        if( mid >= L )ansL = query( Lrange );
        if( mid <  R )ansR = query( Rrange );
        return ansL + ansR;
    }
}
 
vector<long long>que;
long long range[500005];
const int mod = 1e9 + 7;
 
int main(){
    int n;cin >> n;
    for(int i = 1;i <= n;i ++){ long long k;cin >> k >> range[i];que.push_back(k); }
    for(int i = 1;i <= n;i ++){
        int L = lower_bound( que.begin(),que.end(),que[i - 1] - range[i] ) - que.begin() + 1;
        int R = upper_bound( que.begin(),que.end(),que[i - 1] + range[i] ) - que.begin() + 1;
        SGT::line[i] = SGT::node( L,R - 1 );
    }
    SGT::build( 1,1,n );
    //return 0;
    static int arrange[500005];long long ans = 0;
    for(int i = 1;i <= n;i ++)arrange[i] = i;
    //for(int i = 1;i <= n;i ++)swap( arrange[ rand() % n + 1 ],arrange[ rand() % n + 1 ] );
    for(int i = 1;i <= n;i ++){
        int now = arrange[i];
        SGT::node lst = SGT::node(0,0);
        SGT::node ths = SGT::query(1,now,now);
        while( lst != ths ){
            lst = ths;
            ths = SGT::query( 1,ths.x,ths.y );
        }
        SGT::modify( 1,now,ths );
        ( ans += 1ll * i * (ths.y - ths.x + 1) % mod ) %= mod;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：CQWDX (赞：1)

容易发现这是一道图论问题。

首先，显然应将炸弹坐标离散化，转移为编号。

由于题目保证 $x$ 单调上升，可以二分查找对于每个炸弹单次爆炸能够炸到的最左及最右炸弹编号，记作 $L_i, R_i$。

对于每个炸弹 $i$，向 $[L_i,R_i]$ 的每个炸弹连边。

为避免出现有环的情况，先跑一遍强连通分量缩点。

在反图上拓扑排序，更新点 $u$ 能够覆盖的最远左、右编号，记作 $l_i,r_i$。

具体地，令炸弹单次爆炸能够覆盖的集合为 $S_u$，则有 $l_u=\min\limits_{v \in S_u}(l_v)$，$r_u\max\limits_{v \in S_u}(r_v)$。

但是时空复杂度均为 $O(n^2)$，不能接受。

由于此题需要区间连边，考虑线段树优化建图。可以将边数降为 $O(n\log n)$ 的级别。

Tarjan 算法线性，总时间复杂度为 $O(n \log n)$，可以接受。

[Submission](https://www.luogu.com.cn/record/145271781)

---

## 作者：tswdfop233 (赞：1)

Li 表示炸弹i可以炸到的最左炸弹  
Ri 表示炸弹i可以炸到的最右炸弹  
Lpi 表示炸弹i可以往左连炸到的最左炸弹  
Rpi 表示炸弹i可以往右连炸到的最右炸弹  

以Rpi为例  
[L,R]为当前区间  
RpMax为[L,R]中最大的Rpi  
在[R+1 RpMax]中可能会有足以扩展左边界的炸弹  
那么炸弹最大半径必然变为原来的至少两倍  
那么是log次  
可以ST表维护   
ps:就洛谷的数据来说,好像直接用不着Lp和Rp就能过  
而且在某些数据上,好像我这个跟诸位的代码答案会有不同

代码很丑，但还是贴个吧

```
#include<cstdio>
#include<cctype>
#include<algorithm>
#include<cmath>
#include<cstring>
#define file(KSCN) freopen(KSCN".in","r",stdin),freopen(KSCN".out","w",stdout)
using namespace std;
typedef long long ll;
namespace IO{
	const int ios=1<<17;
	char R[ios],*Rc=R,*RB=R;int pass;
	inline int gec(){return(Rc==RB&&(RB=(Rc=R)+fread(R,1,ios,stdin),Rc==RB))?EOF:*Rc++;}
	template<typename Tp>inline int read(Tp&A){
		static int c,sg;c=gec();sg=0;A=0;
		while(!isdigit(c)&&c!=EOF)sg|=(c=='-'),c=gec();
			if(c==EOF)return EOF;
		while(isdigit(c))A=(A<<3)+(A<<1)+(c^'0'),c=gec();
		return A=sg?-A:A,0;
	}
	inline int read(){return read(pass),pass;}
}
using IO::gec;using IO::read;
const int N=5e5+5,G=20,inf=0x3f3f3f3f,mds=1e9+7;
int n;
struct Min{int operator()(int a,int b)const{return a<b?a:b;}};
struct Max{int operator()(int a,int b)const{return a>b?a:b;}};
namespace ST{
	int lg[N];
	void predLog(int n){
		for(int i=1;(1<<i)<=n;i++)lg[(1<<i)]=i;
		for(int i=1;i<=n;i++)if(!lg[i])lg[i]=lg[i-1];
	}
	template<typename shuper>struct stTable{
		int f[G][N];
		shuper cmp;
		void pred(int*a){
			memcpy(f[0],a,sizeof(f[0]));
			for(int k=1;k<G;k++){
				int*QwQ=f[k],*QAQ=f[k-1],ig=(1<<(k-1));
					for(int i=1;i<=n;i++)
						QwQ[i]=cmp(QAQ[i],QAQ[i+ig]);
			}
		}
		int Querys(int L,int R){
			int t=lg[R-L+1];
			return cmp(f[t][L],f[t][R-(1<<t)+1]);
		}  
	
	};
	stTable<Min>lua,lub;
	stTable<Max>rua,rub;
};
namespace seg{
	template<typename shuper>struct segT{
		int t[N<<2],sgt,ift;
		shuper cmp;
		void built(int n){
			sgt=1;
			while(sgt<=n)sgt<<=1;
			ift=(cmp(inf,-inf)==inf)?-inf:inf;
			for(int i=1;i<(sgt<<1);i++)t[i]=ift;
		}
		void upd(int x){t[x]=cmp(t[x<<1],t[x<<1|1]);}
		void Update(int x){
			while(x>>=1)upd(x);
		}
		void Modify(int x,int v){
			x+=sgt-1;
			t[x]=v;
			Update(x);
		}
		int Querys(int L,int R){
			int ret=ift;
			for(int l=L+sgt-1,r=R+sgt-1;l<=r;l>>=1,r>>=1){
				if(l&1)ret=cmp(ret,t[l++]);
				if(~r&1)ret=cmp(ret,t[r--]);
			}
			return ret;
		}
	};
	segT<Min>lua; 
	segT<Max>rua;
};
long long po[N],rip[N];
int l[N],r[N],lp[N],rp[N];
int solve(int i){
	int L=i,R=i;
	while(1){
		int l0=ST::lub.Querys(L,R),r0=ST::rub.Querys(L,R);
		L=l0,R=r0;
		int l1=ST::lua.Querys(L,R),r1=ST::rua.Querys(L,R);
		if(l1==L&&R==r1)break;
		L=l1,R=r1;
	}
	return R-L+1;
}
int main(){
	read(n);
	ST::predLog(n); 
	seg::lua.built(n);
	seg::rua.built(n);
	int ans=0;
	for(int i=1;i<=n;i++)read(po[i]),read(rip[i]);
	for(int i=1;i<=n;i++)l[i]=lower_bound(po+1,po+n+1,po[i]-rip[i])-po,r[i]=upper_bound(po+1,po+n+1,po[i]+rip[i])-po-1;
	ST::lua.pred(l);ST::rua.pred(r);
	for(int i=1;i<=n;i++)seg::lua.Modify(i,lp[i]=min(l[i],seg::lua.Querys(l[i],i-1)));
	for(int i=n;i>=1;i--)seg::rua.Modify(i,rp[i]=max(r[i],seg::rua.Querys(i+1,r[i])));
	ST::lub.pred(lp);ST::rub.pred(rp);
	for(int i=1;i<=n;i++)
	ans=(ans+1ll*i*solve(i))%mds; 
	printf("%d\n",ans);
	return 0;
}

```


---


# [SCOI2012] 奇怪的游戏

## 题目描述

Blinker 最近喜欢上一个奇怪的游戏。 

这个游戏在一个 $N \times M$ 的棋盘上玩，每个格子有一个数。每次 Blinker 会选择两个相邻的格子，并使这两个数都加上 $1$。 

现在 Blinker 想知道最少多少次能使棋盘上的数都变成同一个数，如果永远不能变成同一个数则输出 $-1$。 

## 说明/提示

对于 $30\%$ 的数据，保证 $ T\le 10,1\le N,M \le 8$。   
对于 $100\%$ 的数据，保证 $T \le 10,1 \le N,M\le 40$，所有数为正整数且小于 $10^9$。 

## 样例 #1

### 输入

```
2 
2 2 
1 2 
2 3 
3 3 
1 2 3 
2 3 4 
4 3 2 ```

### 输出

```
2 
-1 
```

# 题解

## 作者：longlongzhu123 (赞：42)

# 二分 $\times$ 网络流

一开始看到题目脑子一片空白。。。QAQ

仔细观察题目：

```
选择两个相邻的格子
```

黑白染色！QwQ

```
并使这两个数都加上1
```

二分图！QwQ

```
棋盘上的数都变成同一个数
```

最大流！QwQ

```
最少多少次
```

二分！QwQ

好了这题解法已经很明朗了。。。（诶诶你刚刚说了什么来着？）

## 具体来说

因为这题是二维棋盘，考虑黑白染色，建立二分图。

设黑点的个数有 $B$ 个，权值总和为 $b$ ，白点的个数有 $W$ 个，权值总和为 $w$ 。

对于每次操作，因为是选择相邻的两个节点，所以黑点白点肯定各有一个被操作，即 $b$ 和 $w$ 各加一。

设最后全部数字都变成 $X$ ，那么就会有有 $B \times X - b = W \times X - w$ （等于操作的次数）。

稍微化简一下： $ (B - W) \times X = b - w$ ， $ X = (b - w) \div (B - W)$ 。

这条等式成立的条件是 $B \ne W$ ，（小学奥数：除数不能为0）

## $B \ne W$

如果 $B \ne W$ ，我们可以直接求出 $X$ 。

然而，我们直接求出的$X$不一定是可行的，需要使用`check`判定它是否可行（见后）。

## $B = W$

如果 $B = W$ ，就意味着 $N$ 、 $M$ 中有一个是偶数（很明显好吧qwq）。

在 $B=W$ 的情况下，如果一个 $X$ 可行，那么我们可以铺满整个棋盘，使整个棋盘的所有数都加上一，即 $X+1$ 也可行。

同理，当 $X$ 不可行时， $X-1$ 也肯定不可行。

我们可以二分出 $X$ ，同样使用`check`判定。

注意：我们每次 $b$ 和 $w$ 各加一，而且 $B = W$ ，最后所有数都变成 $X$ ，因此若一开始的 $b$ 不等于 $w$ ，我们不管怎么操作，都不能求出一个合法的解。

## check函数

$check(x)$：

设第 $i$ 个点的值为 $v[i]$ ，

网络流建图，将 $S$ 向所有黑点 $i$ 连边，容量为 $x - v[i]$ ，意味着需要对这个点操作 $x - v[i]$ 次。

将所有黑点 $i$ 向其相邻的白点 $j$ 连边，容量为 $INF$ 。

将所有白点 $j$ 向 $T$ 连边，容量为 $x - v[j]$ ，意味着这个点最多接受 $x - v[j]$ 次来自黑点的操作。

设所有 $x - v[i]$ 的和为 $V$ ，

在图上运行最大流，判断最大流是否等于 $V$ 即可。

若最大流等于 $V$ ，那么意味着图上所有边都流满，即 $x$ 可行，返回`true`。

否则返回`false`。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int INF;
const int dx[] = {0, 0, -1, 1};
const int dy[] = {-1, 1, 0, 0};
struct Graph{
	static const int MAXM=200000+10;
	static const int MAXN=10000+10;
	struct Edge{
		int from,to,cap;
		int next;
	}node[MAXM];
	int head[MAXN],top;
	void init(){
		top=1;
		memset(head, 0, sizeof(head));
		s = MAXN - 1;
		t = MAXN - 2;
	}
	void add(int u,int v,int cap){
		top++;
		node[top].next=head[u];
		node[top].from=u;
		node[top].to=v;
		node[top].cap=cap;
		head[u]=top;
		top++;
		node[top].next=head[v];
		node[top].from=v;
		node[top].to=u;
		node[top].cap=0;
		head[v]=top;
	}
	int s,t;
	int dis[MAXN];
	queue<int> Q;
	bool bfs(){
		memset(dis,-1,sizeof(dis));
		Q.push(s);
		dis[s]=0;
		while(!Q.empty()){
			int u=Q.front();
			Q.pop();
			for(int i=head[u];i;i=node[i].next){
				int v=node[i].to;
				if(dis[v]==-1&&node[i].cap){
					dis[v]=dis[u]+1;
					Q.push(v);
				}
			}
		}
		return dis[t]!=-1;
	}
	int dfs(int u,int flow){
		if(u==t)
			return flow;
		else{
			int ret=flow;
			for(int i=head[u];i&&ret;i=node[i].next){
				int v=node[i].to;
				if(dis[v]==dis[u]+1&&node[i].cap){
					int k=dfs(v,min(ret,node[i].cap));
					node[i].cap-=k;
					node[i^1].cap+=k;
					ret-=k;
				}
			}
			if(ret == flow)
				dis[u] = -1;
			return flow-ret;
		}
	}
	int dinic(){
		int ans=0;
		while(bfs())
			ans+=dfs(s,INF);
		return ans;
	}
}G;
#define POINT(X, Y) ((X) * 40 + (Y))
int T, n, m;
int a[100][100];
bool check(int val) {
	G.init();
	int sum = 0;
	for(int i = 1; i <= n; i ++) {
		for(int j = 1; j <= m; j ++) {
			if((i + j) % 2 == 0) {  //  X
				G.add(G.s, POINT(i, j), val - a[i][j]);
				sum += val - a[i][j];
				for(int k = 0; k < 4; k ++) {
					int tx = i + dx[k];
					int ty = j + dy[k];
					if(tx >= 1 && tx <= n && ty >= 1 && ty <= m) {
						G.add(POINT(i, j), POINT(tx, ty), INF);
					}
				}
			}
			else {  //  Y
				G.add(POINT(i, j), G.t, val - a[i][j]);
			}
		}
	}
	return G.dinic() == sum;
}
signed main() {
	INF = 0x7F7F7F7F7F7F7F7F;
	cin>>T;
	while(T --) {
		cin>>n>>m;
		int max1 = 0;
		int s0, s1, c0, c1;
		s0 = s1 = c0 = c1 = 0;
		for(int i = 1; i <= n; i ++) {
			for(int j = 1; j <= m; j ++) {
				cin>>a[i][j];
				max1 = max(max1, a[i][j]);
				if((i + j) % 2 == 0) {
					s0 += a[i][j];
					c0 ++;
				}
				else {
					s1 += a[i][j];
					c1 ++;
				}
			}
		}
		if(c0 != c1) {
			int x = (s0 - s1) / (c0 - c1);  //  c0 > c1
			if(x >= max1 && check(x)) {
				cout<<x * c1 - s1<<endl;
			}
			else {
				cout<<-1<<endl;
			}
		}
		else {
			if(s0 != s1) {
				cout<<-1<<endl;
			}
			else {
				int top = INF >> 1, end = max1 - 1;
				while(end + 1 != top) {
					int mid = (top + end) >> 1;
					if(check(mid)) {  //  >= mid is OK
						top = mid;
					}
					else {
						end = mid;
					}
				}
				if(top == INF >> 1) {
					cout<<-1<<endl;
				}
				else {
					cout<<top * c1 - s1<<endl;
				}
			}
		}
	}
	return 0;
}
```

---

## 作者：jijidawang (赞：18)

骨牌题考虑黑白染色，设黑白点个数分别为 $c_{\sf B}, c_{\sf W}$，权值和分别为 $s_{\sf B}, s_{\sf W}$ .

每次操作肯定是恰好操作一个黑点和一个白点，于是设最后所有点都变成了 $x$，则有 $c_{\sf B}\cdot x-s_{\sf B}=c_{\sf W}\cdot x-s_{\sf W}$，也即 $(c_{\sf B}-c_{\sf W})x=s_{\sf B}-s_{\sf W}$ .

讨论：
1. 当 $c_{\sf B} - c_{\sf W} \neq = 0$ 时 .
2. 当 $c_{\sf B} - c_{\sf W} = s_{\sf B} - s_{\sf W} = 0$ 时 .
3. 其他情况无解 .

***

**Case 1.** 可以解得 $x=\dfrac{s_{\sf B}-s_{\sf W}}{c_{\sf B} - c_{\sf W}}$ .

于是只要判断 $x$ 是否能作为一个解即可，具体见后 .

****

**Case 2.** 这表明黑白色块数量相等且权值和相等 .

因为黑白色块数量相等所以如果 $x$ 可以作为一个解那么 $x+1$ 必然也可以 .

也就是解有单调性，二分答案即可 . 判断 $x$ 是否能作为一个解的做法如下：

考虑建立虚拟源汇点 $s,t$：
- $s$ 向所有黑点 $(i,j)$ 连边权为 $x-a_{i,j}$ 的有向边 .
- 所有白点 $(i,j)$ 向 $t$ 连边权为 $x-a_{i,j}$ 的有向边 .
- 所有黑点 $(i,j)$ 向相邻白点连边权为 $+\infty$ 的有向边 .

因为 $x-a_{i,j}$ 是需要操作的次数，于是因为黑白色块数量权值和相等，如果有解那么流肯定能从 $s$ 流到黑点流到白点再流到 $t$ .

于是只要判断以 $s$ 为源点，$t$ 为汇点的最大流是否等于所有黑点之权值和即可 .

因为是二分图，所以 Dinic 是 $O(\sqrt nm)$ 的 .
***
这个还不足以作为时间复杂度分析，因为我们没有一个二分答案的上界 .

记 $\displaystyle A = \max_i\{a_i\}$，设二分图左部为 $L$，**对应的** 右部为 $R$ .

则根据最大流定义，有解当且仅当 $s$ 连向 $L$ 的容量和 $c_0$ 不小于 $R$ 连向 $t$ 的容量和 $c_1$ .

Hall 定理（[7.16 闲话](https://www.cnblogs.com/CDOI-24374/p/16485312.html)）告诉我们，对于任何一个 $L$，都有 $|L|\le |R|$ .

讨论：
- 当 $|L|=|R|$ 时，$c_0=c_1$ .
- 当 $|L|<|R|$ 时，当答案为 $0$ 时 $|c_0-c_1|\le A\cdot nm$ .
 
  注意到，若答案增加 $1$，$|c_0-c_1|$ 的 **减少量** $\Delta\ge |T|-|S|\ge 1$ .
  
  于是答案的一个上界为 $A\cdot nm$ .
  
这样我们知道了答案的一个上界，就可以做复杂度分析了 .

时间复杂度为
$$\begin{aligned}T(n,m,A)&=O(\sqrt{nm}\cdot nm\cdot\log(A\cdot nm))\\&=O(n^{3/2}m^{3/2}(\log A+\log n+\log m))\\&=O(n^{3/2}m^{3/2}\log\max\{A,n,m\})\end{aligned}$$

注意到原题数据范围给出 $A$ 的量级远大于 $n,m$，于是时间复杂度为 $O(n^{3/2}m^{3/2}\log A)$ .

<details>
<summary>Code</summary>

```cpp
#include <bits/stdc++.h>
template<typename T>
inline T chkmin(T& x, const T& y){if (x > y) x = y; return x;}
template<typename T>
inline T chkmax(T& x, const T& y){if (x < y) x = y; return x;}
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int TD = 44, N = 19198;
const ll INF = 0x3f3f3f3f3f;
struct dinic
{
	struct Node
	{
		int u, v; ll w;
		Node() = default;
		Node(int a, int b, ll c) : u(a), v(b), w(c){}
	};
	vector<Node> e;
	vector<int> g[N];
	inline void addedge(int u, int v, ll w)
	{
		int s = e.size();
		e.emplace_back(Node(u, v, w)); g[u].emplace_back(s++);
		e.emplace_back(Node(v, u, 0)); g[v].emplace_back(s);
	}
	int cur[N], depth[N];
	inline void clear(int n){e.clear(); do g[n].clear(); while (n--);}
	inline bool bfs(int s, int t)
	{
		memset(cur, 0, sizeof cur);
		memset(depth, -1, sizeof depth);
		queue<int> q; q.push(s); depth[s] = 0;
		while (!q.empty())
		{
			int u = q.front(); q.pop();
			for (int ee : g[u])
			{
				int v = e[ee].v;
				if (!~depth[v] && e[ee].w){depth[v] = depth[u] + 1; q.push(v);}
			}
		}
		return ~depth[t];
	}
	ll dfs(int u, int t, ll flow)
	{
		if ((u == t) || (flow <= 0)) return flow;
		ll ans = 0; int s = g[u].size();
		for (int& p = cur[u]; p < s; p++)
		{
			int ee = g[u][p], v = e[ee].v;
			if (depth[u] + 1 != depth[v]) continue;
			ll nxt = dfs(v, t, min(flow, e[ee].w));
			e[ee].w -= nxt; e[ee^1].w += nxt;
			ans += nxt; flow -= nxt;
			if (flow <= 0) break;
		}
		if (ans <= 0) depth[u] = -1;
		return ans;
	}
	inline ll maxflow(int s, int t)
	{
		ll ans = 0;
		while (bfs(s, t)) ans += dfs(s, t, INF);
		return ans;
	}
}F;
int n, m, a[TD][TD];
inline int color(int x, int y){return (x & 1) ^ (y & 1);}
inline int tonode(int x, int y){return x * 40 + y;}
inline bool check(ll x)
{
	int s = tonode(n, m) + 1, t = s + 1;
	F.clear(t);
	ll flow = 0;
	for (int i=1; i<=n; i++)
		for (int j=1; j<=m; j++)
		{
			if (color(i, j))
			{
				flow += x - a[i][j];
				F.addedge(s, tonode(i, j), x - a[i][j]);
				if (i > 1) F.addedge(tonode(i, j), tonode(i-1, j), INF); 
				if (j > 1) F.addedge(tonode(i, j), tonode(i, j-1), INF); 
				if (i < n) F.addedge(tonode(i, j), tonode(i+1, j), INF); 
				if (j < m) F.addedge(tonode(i, j), tonode(i, j+1), INF); 
			}
			else F.addedge(tonode(i, j), t, x - a[i][j]);
		}
	return F.maxflow(s, t) == flow;
}
inline void solve()
{
	scanf("%d%d", &n, &m);
	ll b = 0, w = 0; int B = 0, W = 0, M = 0;
	auto readInt = []()
	{
		int ans = 0; char ch;
		while (!isdigit(ch = getchar()));
		do ans = (ans<<3) + (ans<<1) + ch - 48; while (isdigit(ch = getchar()));
		return ans;
	};
	for (int i=1; i<=n; i++)
		for (int j=1; j<=m; j++)
		{
//			a[i][j] = readInt();
			scanf("%d", a[i] + j);
			chkmax(M, a[i][j]);
			if (color(i, j)){++B; b += a[i][j];}
			else{++W; w += a[i][j];}
		}
	if (B != W)
	{
		ll x = (b - w) / (B - W);
		if ((x >= M) && check(x)) printf("%lld\n", x * W - w);
		else puts("-1");
		return ;
	}
	if (b != w){puts("-1"); return ;}
	ll l = M, r = 3e9, ans = -1;
	while (l <= r)
	{
		ll mid = (l + r) >> 1;
		if (check(mid)){r = mid - 1; ans = mid;}
		else l = mid + 1;
	}
	if (!~ans) puts("-1");
	else printf("%lld\n", ans * W - w);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("i.in", "r", stdin);
#endif 
	int T; scanf("%d", &T);
	while (T--) solve();
	return 0;
}
```
</details>

---

## 作者：asuldb (赞：7)

[题目](https://www.luogu.org/problemnew/show/P5038)

话说有没有跟我一样直接猜了一个最大值不会改变这样一个二乎乎的结论之后交上去保龄的呀

首先看到棋盘，选择相邻的格子，非常经典的黑白染色

显然那个二乎乎的结论是错的，随便就能$hack$了

于是我们二分这个最大值

如果当前二分出来的最大值是$mid$，$i+j$为奇数，起点连$mid-a[i][j]$的边，否则向终点连$mid-a[i][j]$的边，相邻的格子连流量无穷的边，跑最大流看看起点连出去的边和连向终点的边是否都满流就好了

但是这样仅限于$n\times m$为偶数的情况

因为之后当$n\times m$为偶数的时候我们可以把整个棋盘整体加$1$，因此存在单调性，于是可以二分

但是当$n\times m$为奇数的时候我们无论如何都得空至少一个

我们可以考虑一下最后棋盘变成了$x$

那么就会存在

$$x\times num_{\text{奇}}-sum_{\text{奇}}=x\times num_{\text{偶}}-sum_{\text{偶}}$$

这个其实还是来源于上面的网络流建图，就是让两边流量平衡，由于$num_{\text{奇}}!=num_{\text{偶}}$，我们可以直接解得

$$x=\frac{sum_{\text{奇}}-sum_{\text{偶}}}{num_{\text{奇}}-num_{\text{偶}}}$$

由于我们不能再让棋盘整体加了，于是直接判断$x$是否合法就好了

代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#define re register
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
const int maxn=2005;
const LL inf=5e12;
inline int read() {
	char c=getchar();int x=0;while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
std::queue<int> q;
const int dx[]={0,0,1,-1};
const int dy[]={1,-1,0,0};
int head[maxn],d[maxn],id[51][51],S,T,num;
int n,m,a[51][51],pd[maxn],cur[maxn];
struct E{int v,nxt;LL f;}e[maxn*40];
inline void C(int x,int y,LL f) {
	e[++num].v=y;e[num].nxt=head[x];
	head[x]=num;e[num].f=f;
}
inline void add(int x,int y,LL f) {C(x,y,f),C(y,x,0);}
inline int BFS() {
	for(re int i=S;i<=T;i++) d[i]=0,cur[i]=head[i];
	d[S]=1,q.push(S);
	while(!q.empty()) {
		int k=q.front();q.pop();
		for(re int i=head[k];i;i=e[i].nxt)
		if(e[i].f&&!d[e[i].v]) d[e[i].v]=d[k]+1,q.push(e[i].v);
	}
	return d[T];
}
LL dfs(int x,LL now) {
	if(x==T||!now) return now;
	LL flow=0,ff;
	for(re int& i=cur[x];i;i=e[i].nxt)
	if(d[e[i].v]==d[x]+1) {
		ff=dfs(e[i].v,min(now,e[i].f));
		if(ff<=0) continue;
		now-=ff,flow+=ff,e[i].f-=ff,e[i^1].f+=ff;
		if(!now) break;
	}
	return flow;
}
inline int check(LL mx) {
	num=1;memset(head,0,sizeof(head));
	for(re int i=1;i<=n;i++)
		for(re int j=1;j<=m;j++) {
			pd[id[i][j]]=num+1;
			if((i+j)&1) add(S,id[i][j],mx-a[i][j]);
				else add(id[i][j],T,mx-a[i][j]);
			if(mx<a[i][j]) return 0;
		}
	for(re int i=1;i<=n;i++)
		for(re int j=1;j<=m;j++) {
			if(!((i+j)&1)) continue;
			for(re int k=0;k<4;k++) {
				int x=i+dx[k],y=j+dy[k];
				if(x<1||y<1||x>n||y>m) continue;
				add(id[i][j],id[x][y],inf);
			}
		}
	while(BFS()) dfs(S,inf);
	int flag=1;
	for(re int i=1;i<=n;i++)	
		for(re int j=1;j<=m;j++)
			flag&=(e[pd[id[i][j]]].f==0);
	return flag;
}
int main() {
	int Test=read();
	while(Test--) {
		n=read(),m=read();T=0;
		for(re int i=1;i<=n;i++)
			for(re int j=1;j<=m;j++) a[i][j]=read();
		for(re int i=1;i<=n;i++)
			for(re int j=1;j<=m;j++) id[i][j]=++T;
		++T;
		LL s[2],tot[2];
		tot[0]=tot[1]=s[0]=s[1]=0;
		for(re int i=1;i<=n;i++)
			for(re int j=1;j<=m;j++)
				tot[(i+j)&1]++,s[(i+j)&1]+=a[i][j];
		if((n*m)&1) {
			LL x=(s[1]-s[0])/(tot[1]-tot[0]);
			if(check(x)) 
				printf("%lld\n",x*tot[1]-s[1]);
			else puts("-1");			
		}
		else {
			LL ans=-1,l=1,r=2e9;
			for(re int i=1;i<=n;i++)
				for(re int j=1;j<=m;j++) l=max(l,a[i][j]);
			while(l<=r) {
				LL mid=l+r>>1;
				if(check(mid)) r=mid-1,ans=mid;
					else l=mid+1;
			}
			if(ans==-1) puts("-1");
			else printf("%lld\n",ans*tot[1]-s[1]);
		}
	}
	return 0;
}
```


---

## 作者：楠枫 (赞：3)

## 题解
[题目](https://www.luogu.com.cn/problem/P5038)  

[更好的阅读体验](https://www.cnblogs.com/nanfeng-blog/p/14903824.html)

做这题之前，做了一道叫[星际战争](https://www.luogu.com.cn/problem/P3324)的题，很容易想到二分+网络流，那么二分啥呢？

我们先推一下式子，因为是对相邻格子加数，那么可以联想到黑白染色类问题。

设有黑色格子 B 个，其格子中初始数的和为 b，白色格子同理，个数为 W 个，初始权值和为 w 个，最后变成的同一个数为 num。

可以得出 $B×num-b=W×num-w$ 化简得 $num=\frac{b-w}{B-W}$。

首先对于化简式，其必要条件是 $B\neq W$，那么我们分两种情况讨论。

对于 $B\neq W$ 的情况，那么我们可以直接算出 $num$ ，但是我们要检验其是否合法。

对于 $B=W$ 的情况，首先我们要保证 $b=w$ 否则直接无解。然后，对于一个合法的 $num$，$num+1$ 也是合法的，因为 $B=W$ 所以在 $n,m$ 中一定有一个是偶数。于是我们就可以二分求解，找到临界的 $num$ 就是答案。

这个 ``check()`` 我们可以用最大流求解，对每个黑格子，我们分别向源点 s，权值为 $num-w_i$，它能到的白格子，权值为 INF 连边，对每个白格子，我们向汇点 t 连边，权值为 $num-w_i$。

对这张图跑最大流，如果最大流等于 $B×num-b$ 那么说明这张图跑满了，说明答案正确。

$AC\kern 0.4em CODE:$
```cpp
#include<bits/stdc++.h>
#define ri register signed
#define p(i) ++i
using namespace std;
namespace IO{
    char buf[1<<21],*p1=buf,*p2=buf;
    #define gc() p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++
    inline int read() {
        ri x=0,f=1;char ch=gc();
        while(ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=gc();}
        while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=gc();}
        return x*f;
    }
}
using IO::read;
namespace nanfeng{
    #define int long long//懒人必备
    #define cmax(x,y) ((x)>(y)?(x):(y))
    #define cmin(x,y) ((x)>(y)?(y):(x))
    #define FI FILE *IN
    #define FO FILE *OUT
    #undef bool
    static const int N=45;
    int ch[N][N],id[N][N],n,m,T,tot=1,B,b,W,w,mx;
    namespace NetworkFlows{
        #define jud(i,j) ((i)&&(j)&&(i)<=n&&(j)<=m)
        static const int INF=1e18+7;
        int first[N*N],dep[N*N],cur[N*N],que[N*N],t=2,sw,s=1,et;
        signed dx[5]={0,1,0,-1,0},dy[5]={0,0,1,0,-1};
        struct edge{int v,nxt,w;}e[N*N*5];
        inline void add(int u,int v,int w) {
            e[t].v=v,e[t].w=w;
            e[t].nxt=first[u];
            first[u]=t++;
        }
        inline void init() {et=n*m+2,t=2,sw=0;memset(first,0,sizeof(first));}
        inline void build(int w) {
            for (ri i(1);i<=n;p(i)) {
                for (ri j(1);j<=m;p(j)) {
                    if (!((i+j)%2)) {
                        sw+=w-ch[i][j];
                        add(s,id[i][j],w-ch[i][j]);
                        add(id[i][j],s,0);
                        for (ri d(1);d<=4;p(d)) {
                            if (jud(i+dx[d],j+dy[d])) add(id[i][j],id[i+dx[d]][j+dy[d]],INF),add(id[i+dx[d]][j+dy[d]],id[i][j],0);
                        }
                    } else add(id[i][j],et,w-ch[i][j]),add(et,id[i][j],0);
                }
            }
        }
        inline bool bfs(int s,int t) {
            memset(dep,0,sizeof(dep));
            ri hd=1,tl=0;
            dep[que[p(tl)]=s]=1;
            cur[s]=first[s];
            while(hd<=tl) {
                s=que[hd++];
                for (ri i(first[s]),v;i;i=e[i].nxt) {
                    if (e[i].w&&!dep[v=e[i].v]) {
                        dep[v]=dep[s]+1;
                        cur[que[p(tl)]=v]=first[v];
                        if (v==t) return 1;
                    }
                }
            }
            return 0;
        }
        int dfs(int x,int flow) {
            if (x==et||!flow) return flow;
            int rst=flow;
            for (ri i(cur[x]),v;i&&rst;i=e[i].nxt) {
                if (e[i].w&&dep[v=e[i].v]==dep[x]+1) {
                    register int k;
                    if (!(k=dfs(v,cmin(e[i].w,rst)))) dep[v]=0;
                    e[i].w-=k,e[i^1].w+=k,rst-=k;
                }
                cur[x]=i;
            }
            return flow-rst;
        }
        inline int dinic() {
            int res=0;
            while(bfs(s,et)) res+=dfs(s,INF);
            return res;
        }
    }
    inline bool check(int w) {
        NetworkFlows::init();
        NetworkFlows::build(w);
        return NetworkFlows::dinic()==NetworkFlows::sw;
    }
    inline void init() {mx=B=b=W=w=0,tot=1;}
    inline int main() {
        // FI=freopen("nanfeng.in","r",stdin);
        // FO=freopen("nanfeng.out","w",stdout);
        T=read();
        for (ri z(1);z<=T;p(z)) {
            init();
            n=read(),m=read();
            for (ri i(1);i<=n;p(i)) {
                for (ri j(1);j<=m;p(j)) {
                    ch[i][j]=read(),id[i][j]=p(tot);
                    mx=cmax(mx,ch[i][j]);
                    if (!((i+j)%2)) p(B),b+=ch[i][j];
                    else p(W),w+=ch[i][j];
                }
            }
            if (B!=W) {
                int num=(b-w)/(B-W);
                if (num>=mx&&check(num)) printf("%lld\n",B*num-b);
                else puts("-1"); 
            } else {
                if (b!=w) {puts("-1");continue;}
                int l=mx,r=1e11,res=-1;
                while(l<=r) {
                    int mid((l+r)>>1);
                    if (check(mid)) r=mid-1,res=mid;
                    else l=mid+1;
                }
                printf("%lld\n",res==-1?-1:B*res-b);
            }
        }
        return 0;
    }
    #undef int
}
int main() {return nanfeng::main();}
```

---

## 作者：Schwarzkopf_Henkal (赞：3)

挺有意思的一道题。

我们知道在方格图上面相邻的两个点的坐标和的奇偶性是不同的，我们可以据此进行黑白染色，这个首先应该是套路了。

然后我们考虑每次操作都必然每次有一个黑格和一个白格权值增加 $1$，也就是，如果最终匀下来那个权值真的存在那么首先黑白格子增加的量必须相同。

也就是，设最终值为 $x$，有
$$
cnt_a\times x-sum_a=cnt_b\times x-sum_b
$$
那么事实上要是黑格和白格的数目不相同我们可以直接把那个值算出来，并且可行当且仅当这个值可行。为什么相同不能直接算见下面柿子（除零错）。
$$
x=\frac{sum_b-sum_a}{cnt_b-cnt_a}
$$
挖掘一下 $cnt_a$ 和 $cnt_b$ 的意义，发现这两个相同，当且仅当 $n\times m$ 为偶数。因为这东西是黑白染色，所以这个结论很明显，之所以相同不能这么搞，是因为显然这样至少有一条边长度是偶数，于是显然如果某个值合法，那么一定可以往上再堆一层仍然合法。于是合法值就有 $\text{inf}$ 个了。

这样的话那个值满足单调性，可以二分。

与此同时，这样也带来了一个新约束，也就是权值相同，点数相同，

然后是如何检查某个值的合法性，首先建出二分图，黑的连源白的连汇，权值是目标值减去原权值。然后黑的向周边白的连边，权值 $\text{inf}$。注意这里的 $\text{inf}$ 一定要开的够大，我开 $10^{16}$ 都挂了……

这个模型的正确性比较显然，一个流量对应增加一个权值，某一个颜色的权值增加必须要周边的格子权值也增加，最后判一下是否满流就行了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct Edge{
    int u,v;
    long long c,w;
};
struct dinic{
    const static int N=100005;
    int n,m,s,t;
    vector<Edge>E;
    vector<int>to[N];
    int d[N],C[N];//去掉了当前弧优化 | 又加上了（
    bool vis[N];
    void clear(int n){
        for(int i=1;i<=n;i++)
            to[i].clear();
        E.clear();
    }
    void AddEdge(int u,int v,long long w){
        E.push_back({u,v,w,0});
        E.push_back({v,u,0,0});
        m=E.size();
        to[u].push_back(m-2);
        to[v].push_back(m-1);
    }
    bool bfs(){
        memset(vis,0,sizeof(vis));
        queue<int>que;
        que.push(s);
        d[s]=0;
        vis[s]=1;
        while(!que.empty()){
            int cur=que.front();
            que.pop();
            for(int i=0;i<to[cur].size();i++){
                Edge& x=E[to[cur][i]];
                if(!vis[x.v]&&x.c>x.w){
                    vis[x.v]=1;
                    d[x.v]=d[cur]+1;
                    que.push(x.v);
                }
            }
        }
        return vis[t];
    }
    long long dfs(int u,long long v){
        if(u==t||v==0)
            return v;
        long long w=0,f;
        for(int i=C[u];i<to[u].size();i++){
            C[u]=i;
            Edge& e=E[to[u][i]];
            if(d[u]+1==d[e.v]&&(f=dfs(e.v,min(v,e.c-e.w)))>0){
                e.w+=f;
                E[to[u][i]^1].w-=f;
                w+=f;
                v-=f;
                if(v==0)
                    break;
            }
        }
        return w;
    }
    long long Maxflow(int s,int t){
        this->s=s;
        this->t=t;
        long long res=0;
        while(bfs()){
            memset(C,0,sizeof(C));
            res+=dfs(s,1e18);
        }
        return res;
    }
}R;
int T,n,m,ans,a[50][50],mx;
int ca,cb,sa,sb;
int MK(int u,int v){
    return (u-1)*m+v;
}
bool JiNiTaiMei(int u,int v){
    return u>=1&&u<=n&&v>=1&&v<=m;
}
bool CaiXuKun(int val){
    if(mx>val)
        return 0;
    R.clear(n*m+2);
    long long sum=val*ca-sa;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            if((i+j)%2){
                R.AddEdge(1,MK(i,j)+2,val-a[i][j]);
                if(JiNiTaiMei(i-1,j))
                    R.AddEdge(MK(i,j)+2,MK(i-1,j)+2,1e18);
                if(JiNiTaiMei(i+1,j))
                    R.AddEdge(MK(i,j)+2,MK(i+1,j)+2,1e18);
                if(JiNiTaiMei(i,j-1))
                    R.AddEdge(MK(i,j)+2,MK(i,j-1)+2,1e18);
                if(JiNiTaiMei(i,j+1))
                    R.AddEdge(MK(i,j)+2,MK(i,j+1)+2,1e18);
            }else R.AddEdge(MK(i,j)+2,2,val-a[i][j]);
        }
    return R.Maxflow(1,2)==sum;
}
signed main(){
    scanf("%lld",&T);
    while(T--){
        scanf("%lld%lld",&n,&m);
        ca=cb=sa=sb=mx=0;
        for(int i=1,u;i<=n;i++)
            for(int j=1;j<=m;j++){
                scanf("%lld",&a[i][j]);
                mx=max(mx,a[i][j]);
                if((i+j)%2){
                    ca++;
                    sa+=a[i][j];
                }else {
                    cb++;
                    sb+=a[i][j];
                }
            }
        if(cb!=ca){
            long long _=(sb-sa)/(cb-ca);
            if(CaiXuKun(_))
                printf("%lld\n",_*ca-sa);
            else puts("-1");
        }else {
            if(sa!=sb){
                puts("-1");
                continue;
            }
            ans=-1;
            int l=mx,r=1e18,mid;
            while(l<=r){
                mid=(l+r)/2;
                if(CaiXuKun(mid)){
                    ans=mid*ca-sa;
                    r=mid-1;
                }else l=mid+1;
            }
            printf("%lld\n",ans);
        }
    }
}/*

*/
```

整好力/cy

---

## 作者：Refined_heart (赞：2)

服了……敲完板子去板子区测 发现过了 调了半天最后还是板子的问题……

#### 简述模型

> 给定 $n\times m$ 的方阵，每次可以选择两个相邻数 $+1,$ 问能否得到一个所有数都相等的矩阵。

考虑经典套路。尤其是这种相邻的位置，直接黑白染色，黑色格子的和与白色格子的和不变。

容易发现，对于 $2|n\times m$ 的情况，如果 $x$ 是可行解，则 $x+1$ 必然是可行解，因为我们可以用若干操作覆盖所有棋盘格。

显然可以二分求解。

那么对于 $n\times m$ 为奇数的情况，我们发现黑白格子只有一个格子可以不一样，而这个差值就是最终的棋盘格子上的数。因为操作不会改变差，如果最终答案不是这个数，那么一定不会满足初始情况。

考虑对于一个答案 $v$ 如何检验是否合法。我们显然黑白二分图，我们从 $s$ 向黑点连边，白点向 $t$ 连边，源汇点之间的流量就是 $x-a_{i,j},$ 表示这个点还差这么多流量达到限制，而相邻格子之间连流量无限大的边，最后只需要看边是否满流就行了。或者直接看 $s$ 的出流量是否和 $\sum x-a_{i,j}$ 相等即可。求和号里面的格子是黑色格子。

至于如何黑白染色，按照坐标之和的奇偶性划分即可。

复杂度 $O(n^2m\log v)$

注意多组数据，以及洛谷的模板题（测过了也不一定写的没问题……）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef double db;
#define int long long
#define fi first
#define se second
#define mk make_pair
#define pb emplace_back
#define poly vector<int>
#define Bt(a) bitset<a>
#define bc __builtin_popcount
#define pc putchar
#define ci const int&
#define Mem(a,b) memset(a,0,sizeof a)
const int mod = 1e9 + 7;
const db eps = 1e-10;
const int inf = (1LL << 60);
inline int Max(ci x, ci y) {return x > y ? x : y;}
inline int Min(ci x, ci y) {return x < y ? x : y;}
inline db Max(db x, db y) {return x - y > eps ? x : y;}
inline db Min(db x, db y) {return x - y < eps ? x : y;}
inline int Add(ci x, ci y, ci M = mod) {return (x + y) % M;}
inline int Mul(ci x, ci y, ci M = mod) {return 1ll * x * y % M;}
inline int Dec(ci x, ci y, ci M = mod) {return (x - y + M) % M;}
typedef pair<int, int> pii;
inline int Abs(int x) {return x < 0 ? -x : x;}
//char buf[1<<21],*p1=buf,*p2=buf;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char Obuf[105000],*O=Obuf;//Siz shoule be the size of Out File
int pst[30],ptop;
inline void Fprint(){fwrite(Obuf,1,O-Obuf,stdout);}
inline void Fwrite(int x){
  if(x==0){*O++='0';return;}
  if(x<0)*O++='-',x=-x;ptop=0;
  while(x)pst[++ptop]=x%10,x/=10;
  while(ptop)*O++=pst[ptop--]+'0';
  if(O-Obuf>100000)Fprint(),O=Obuf;
}
inline int read() {
    int s = 0, w = 1;
    char ch = getchar();
    while (!isdigit(ch)) {if (ch == '-') w = -1;ch = getchar();}
    while (isdigit(ch)) {s = s * 10 + ch - '0';ch = getchar();}
    return s * w;
}
inline void write(int x) {
    if (x < 0)putchar('-'), x = -x;
    if (x > 9)write(x / 10);
	pc(x % 10 + '0');
}
inline int qpow(int x, int y) {
    int res = 1;
    while (y) {if (y & 1)res = Mul(res, x);x = Mul(x, x);y >>= 1;}
    return res;
}
inline void cadd(int &x, int y) {x += y;}
inline void cmul(int &x, int y) {x *= y;}
inline void cmax(int &x, int y) {x = Max(x, y);}
inline void cmin(int &x, int y) {x = Min(x, y);}
const int N = 2e5 + 10;
namespace Refined_heart{
	const int dx[]={0,1,0,-1};
	const int dy[]={1,0,-1,0};
	int T,a[501][501],stfg;
	int n,m,s,t,cur[N],node,head[N],tot=1,gap[N],dep[N];
	struct E{int nxt,to,flow;}e[N];
	inline void link(int x,int y,int w){
		e[++tot]=(E){head[x],y,w};head[x]=tot;
		e[++tot]=(E){head[y],x,0};head[y]=tot;
	}
	queue<int>q;
	int bfs(int s,int t){
		while(!q.empty())q.pop();
		memset(dep,0,sizeof dep);
		memset(gap,0,sizeof gap);
		dep[t]=1;q.push(t);++gap[1];
		while(!q.empty()){
			int x=q.front();q.pop();cur[x]=head[x];
			for(int i=head[x];i;i=e[i].nxt){
				int j=e[i].to;
				if(dep[j]||!e[i^1].flow)continue;
				dep[j]=dep[x]+1;++gap[dep[j]];
				q.push(j);
			}
		}
		return dep[s];
	}
	int ISAP(int u,int t,int flow){
		if(u==t||flow<=0)return flow;
		int rest=flow;
		for(int &i=cur[u];i;i=e[i].nxt){
			int j=e[i].to;
			if(dep[j]==dep[u]-1&&e[i].flow){
				int tmp=ISAP(j,t,Min(e[i].flow,rest));
				e[i].flow-=tmp;e[i^1].flow+=tmp;rest-=tmp;
				if(rest<=0)return flow-rest;
			}
		}
		cur[u]=head[u];--gap[dep[u]];
		if(!gap[dep[u]])stfg=1;
		++gap[++dep[u]];return flow-rest;
	}
	int CALC(int s,int t){
		int res=0;
		if(bfs(s,t))while(!stfg)res+=ISAP(s,t,inf);
		return res;
	}
	void clear(){
		Mem(head,0);Mem(cur,0);
		for(int i=1;i<=tot;++i)e[i]=(E){0,0,0};
		tot=1;node=0;stfg=0;
	}
	int np[501][501];
	inline int getpos(int x,int y){return (x-1)*m+y;}
	inline int ckin(int x,int y){return x>=1&&x<=n&&y>=1&&y<=m;}
	void CLLL(){
		s=0;t=0;tot=1;node=0;
		Mem(head,0);Mem(np,0);stfg=0;
	}
	bool check(int nowv,int &R){
		clear();s=++node;t=++node;
		for(int i=1;i<=n;++i)
			for(int j=1;j<=m;++j){
				np[i][j]=++node;
			}
		int sm=0;
		for(int i=1;i<=n;++i)
			for(int j=1;j<=m;++j){
				if((i+j)&1)link(s,np[i][j],nowv-a[i][j]),sm+=nowv-a[i][j];
				else link(np[i][j],t,nowv-a[i][j]);
			}
		for(int i=1;i<=n;++i)
			for(int j=1;j<=m;++j){
				if(!((i+j)&1))continue;
				for(int k=0;k<4;++k){
					int x=i+dx[k];
					int y=j+dy[k];
					if(x<1||y<1||x>n||y>m)continue;
					link(np[i][j],np[x][y],inf);
				}
			}
		int fl=CALC(s,t);R=fl;
		if(fl!=sm)return false;
		return true;
	}
	void work(){
		CLLL();
		n=read();m=read();s=++node;t=++node;
		for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)a[i][j]=read();
		int siz=n*m;
		if(siz&1){
			int js=0,os=0;
			for(int i=1;i<=n;++i)
				for(int j=1;j<=m;++j)
					if((i+j)&1)js+=a[i][j];
					else os+=a[i][j];
			int c=os-js;
			int mx=-1;
			for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)cmax(mx,a[i][j]);
			if(mx>c){
				puts("-1");
				return;
			}
			int gg=0;
			int g=check(c,gg);
			if(!g)puts("-1");
			else write(gg),pc('\n');
			return;
		}
		else{
			int js=0,os=0;
			for(int i=1;i<=n;++i)
				for(int j=1;j<=m;++j)	
					if((i+j)&1)js+=a[i][j];
					else os+=a[i][j];
			if(js!=os){
				puts("-1");
				return;
			}
			int mx=-1;
			for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)cmax(mx,a[i][j]);
			int l=mx,r=(1LL<<50),ans=-1;
			while(l<=r){
				int mid=(l+r)/2;int fll=0;
				if(check(mid,fll))ans=fll,r=mid-1;
				else l=mid+1;
			}
			write(ans);pc('\n');
		}
	}
	void solve(){
		T=read();
		while(T--)work();
	}
}
signed main(){
	freopen("in.txt","r",stdin);
//	freopen("My.out","w",stdout);
	Refined_heart::solve();
	return 0;
}

```


---

## 作者：letitdown (赞：2)

题目询问了一个不能确定的时间，所以显然做法中要包含一个二分答案。

我们将整张图分为黑白点两种，黑点旁边的点就是白点，白点旁边的点就是黑点，想一下就能知道，每次操作会使黑白点的数字各加一，而我们的目的就是让整张图的黑白点都是同一个数字。

设这个数字是 $x$，黑点有 $num_0$ 个，未操作前的数字总和是 $sum_0$，白点有 $num_1$ 个，未操作前的数字总和是 $sum_1$，因为操作次数相等。

那么有：

$$num_0\times x-sum_0=num_1\times x-sum_1$$

移项可得：

$$x=(sum_1-sum_0)/(num_1-num_0)$$

于是：
1. 当 $num_1 \not= num_0$ 时，可以解出 $x$，若它是个小数则无解。另外我们要操作的次数为 $(x\times n\times m-sum_1-sum_0)/2$ ，所以如果这也是一个小数也无解，接着我们用网络流check一下 $x$，得出它能操作多少次，和上面算的一样就有解，否则无解。

2. $num_1=num_0$ 显然这说明 $n,m$ 中至少一个是偶数，操作次数还是 $(x\times n\times m-sum_1-sum_0)/2$，前一项是偶数，后两项算一下如果是奇数，那么算出次数一定是小数，也无解，否则我们就可以利用单调性二分出合适的 $x$ ，利用网络流得出答案，其中，二分下界是所有格子数字的最大值，因为格子的数字只能增不能降，不能让最大的数字降回去。而上界可以设成一个较大的值，这里设的是1e14。

单调性证明：
因为 $num_1=num_0$， 则
$$(num_1+num_0)\bmod 2=0$$

即可以构造一层正好的满覆盖。也就是在正确答案后多铺了几层。所以具有单调性。

对于网络流建图：

我们对于起始点 $S$ 向每个黑点连边，权值是它增加到 $x$ 需要多少次操作，每个黑点向相邻白点连边，权值是 $inf$，白点向汇点 $T$ 连边，权值是它增加到 $x$ 需样跑出来的最大流就是我们最多能操作多少次，和对应的二分答案比较即可。

在这里我用的是 $Dinic$ 算法，在二分图情况下复杂度是 $O(n^{0.5}m)$ ，所以在此题下绰绰有余。

于是本题就愉快的做完了～

## Code
```cpp
#include<cstring>
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
namespace EMT{
	typedef long long ll;typedef double db;//(double)clock() / (double)CLOCKS_PER_SEC;
	#define int long long
	#define pf printf
	#define F(i,a,b) for(register int i=a;i<=b;i++)
	#define D(i,a,b) for(register int i=a;i>=b;i--)
	inline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
	inline void file(){freopen("in.in","r",stdin);freopen("my.out","w",stdout);}
	inline int max(int a,int b){return a>b?a:b;}inline int min(int a,int b){return a<b?a:b;}
	inline void pi(int x){pf("%lld ",x);}inline void pn(){pf("\n");}
	const int N=1650;struct dp{int num,sum;}p[2];const int inf1=1e18,inf2=1e14;
	int head[N],dis[N],co,Hd[N],n,pos[45][45],q[N],hd,tot,tl,cnt,m,S,T,a[45][45],b[45][45];struct node{int next,to,w;}e[N*10];
	inline void add(int next,int to,int w){e[++co].next=head[next],e[co].to=to,e[co].w=w,head[next]=co;}
	inline bool bfs(){
		memcpy(head,Hd,sizeof(Hd));
		memset(dis,0x3f,sizeof(dis));
		q[hd=tl=1]=S;dis[S]=0;
		while(hd<=tl){
			int x=q[hd++];
			for(register int i=head[x];i;i=e[i].next)if(e[i].w){
				if(dis[e[i].to]>dis[x]+1){
					dis[e[i].to]=dis[x]+1;
					q[++tl]=e[i].to;
				}
			}if(x==T)return 1;
		}return 0;
	}
	inline int dfs(int x,int in){
		if(x==T)return in;
		int rest=in,go;
		for(register int i=head[x];i;head[x]=i=e[i].next)if(e[i].w){
			if(dis[e[i].to]==dis[x]+1){
				go=dfs(e[i].to,min(e[i].w,rest));
				if(go)e[i].w-=go,e[i^1].w+=go,rest-=go;
				else dis[e[i].to]=0;
			}if(!rest)break;
		}return in-rest;
	}
	inline int check(int x){
		int ans=0;co=1;
		memset(head,0,sizeof(head));tot=x*n*m-p[0].sum-p[1].sum;
		F(i,1,n)
			F(j,1,m)
			if(b[i][j]){
				if(j+1<=m)add(pos[i][j],pos[i][j+1],inf1),add(pos[i][j+1],pos[i][j],0);
				if(j-1>=1)add(pos[i][j],pos[i][j-1],inf1),add(pos[i][j-1],pos[i][j],0);
				if(i-1>=1)add(pos[i][j],pos[i-1][j],inf1),add(pos[i-1][j],pos[i][j],0);
				if(i+1<=n)add(pos[i][j],pos[i+1][j],inf1),add(pos[i+1][j],pos[i][j],0);
				add(S,pos[i][j],x-a[i][j]);add(pos[i][j],S,0);
			}else add(pos[i][j],T,x-a[i][j]),add(T,pos[i][j],0);
		memcpy(Hd,head,sizeof(head));
		while(bfs())ans+=dfs(S,inf1);
		if(ans>=tot/2)return ans;else return 0;
	}
	inline short main(){
		int TT=read();
		while(TT--){
			cnt=0;n=read(),m=read();S=++cnt;T=++cnt;int maxn=0;
			p[0].num=p[0].sum=p[1].num=p[1].sum=0;
			F(i,1,n)
				F(j,1,m){
					if(j==1)b[i][j]=b[i-1][j]^1;else b[i][j]=b[i][j-1]^1;
					p[b[i][j]].num++;pos[i][j]=++cnt;
					a[i][j]=read();p[b[i][j]].sum+=a[i][j];
					maxn=max(maxn,a[i][j]);
				}
			if(p[1].num!=p[0].num){
				if((p[1].sum-p[0].sum)%(p[1].num-p[0].num)!=0){pi(-1);pn();}
				int tt=(p[1].sum-p[0].sum)/(p[1].num-p[0].num);
				int x;
				if(tt!=(int)tt){pi(-1);pn();continue;}else x=tt;
				if((x*n*m-p[1].sum-p[0].sum)&1||x*n*m<p[1].sum+p[0].sum){pi(-1);pn();continue;}
				if(!check(x)){pi(-1);pn();}
				else{pi(check(x));pn();}
			}else{
				int l=maxn,r=inf2,ans=inf2;
				if((p[0].sum+p[1].sum)&1){pi(-1);continue;}
				while(l<=r){
					int mid=(l+r)>>1;
					int t=check(mid);
					if(t)r=mid-1,ans=t;
					else l=mid+1;
				}
				if(ans==inf2){pi(-1);pn();continue;}
				else pi(ans),pn();
			}
		}
		return 0;
	}
}
signed main(){return EMT::main();}
```

---

## 作者：Rui_R (赞：2)

题目大意：给定一个$n\times m$、每个点带权的矩阵，每次操作可以选两个相邻的点使它们权值加1。求要是矩阵中左右点权值相同，至少要几次操作。永远不能输出-1。

[原题](https://www.luogu.com.cn/problem/P5038)

首先，显然可以对矩阵进行黑白染色，每次操作只会在一黑一白之间进行，即黑白所增加的值一定相同

算出黑点数量$numb$，白点数量$numw$，黑点权值和$sumb$，白点权值和$sumw$。令最终所有点变为$x$。

那么有$numb\times x-sumb=numw \times x- sumw$

移项得到 $(numw-numb)\times x=sumw-sumb$

那么分类讨论：

当$numw\ne numb$，显然可以直接算出x，只要判断x是否可行即可。毕竟有些时候，这个x算出来还没有矩阵中最大值大，如样例；还有些时候就是无法达到了，如$n=1$,$m=3$，矩阵为$1,2,1$。

这个怎么判断见下文。

当$numw = numb$ ，那么就需要再想点办法了。

首先要是$sumw \ne sumb$，那么x无解，输出-1即可。

否则，假设我们有一个合法的$x$。那么既然$numw=numb$，我们就能通过一定数量的操作来使整个矩阵上的点都被操作一次。毕竟此时，$n\times m$是偶数，也就是说$n$和$m$中必有至少一个偶数。

**即，若x不合法，x-1一定不合法；若x合法，x+1一定也合法。**

所以x存在一个断点，断点以下全部不合法，断点以上全部合法。那么就可以二分去找这个断点了。

最后只剩一个问题：如何判断一个$x$是否合法？

网络流。建立源点s，将s与所有黑点(权值为$v$)相连一条流量上限为 $x-v$的边，表示每个黑点至多被操作$x-v$次；在将每个黑点与其相邻白点建边，流量上限至少为$x-v$，当然往上开也行；最后把所有白点(权值为$v$)与汇点t建边，表示每个白点至多被操作$x-v$ 次。用DINIC得到的最大流即为操作次数的最大值。判断该值是否与x所对应的，应该的操作次数相等即可。

我的代码用$(i-1)\times m+j$表示点$(i,j)$，用两个set保存白点与黑点。因此，不吸氧会T掉。不过要想改成数组也不难改，甚至都可以不保存，用set只是个人爱好而已。

$\texttt{Talk is cheap,show me your code.}$
```
#include <cstdio>
#include <queue>
#include <set>

#define int long long

const int maxn=105,inf=1e18+7;

struct edge{
	int v,nxt,w;
}e[maxn*maxn];

int n,m,a[maxn*maxn],edge_cnt,fir[maxn*maxn];
int sum_b,sum_w,num_b,num_w;
int maxflow,dep[maxn*maxn],go[maxn*maxn],least;

std::queue<int> q;std::set<int> b,w;
typedef std::set<int>::iterator IT;

inline int max(int a,int b){
	return a>b?a:b;
}

inline int min(int a,int b){
	return a<b?a:b;
}

inline void add_edge(int u,int v,int w){
	e[++edge_cnt].nxt=fir[u];e[edge_cnt].v=v,e[edge_cnt].w=w;fir[u]=edge_cnt;
}

bool bfs(){
	for(int i=1;i<=n*m+1;i++) dep[i]=-1;
	q.push(0);
	while(!q.empty()){
		int u=q.front();q.pop();
		go[u]=fir[u];
		for(int i=fir[u];~i;i=e[i].nxt){
			int v=e[i].v;if(~dep[v]||e[i].w<=0) continue;
			dep[v]=dep[u]+1;q.push(v);
		}
	}
	return ~dep[n*m+1];
}

int dfs(int now,int minflow){
	if(now==n*m+1) return minflow;
	int useflow=0;
	for(int i=go[now];~i&&minflow>0;i=e[i].nxt){
		go[now]=i;int v=e[i].v;
		if(dep[v]==dep[now]+1&&e[i].w>0){
			int tmp=dfs(v,min(minflow,e[i].w));
			if(!tmp) dep[v]=-1;
			e[i].w-=tmp,e[i^1].w+=tmp;
			useflow+=tmp,minflow-=tmp;
		}
	}
	return useflow;
}

void dinic(){
	while(bfs()){
		maxflow+=dfs(0,inf);
	}
}

bool check(int key){
	if(key<least) return 0;//如果还没least大就废了
	int pos=num_b*key-sum_b;//应该的操作次数
	edge_cnt=-1;for(int i=0;i<=n*m+1;i++) fir[i]=-1;
	for(IT it=b.begin();it!=b.end();it++){
		int now=*it;
		add_edge(0,now,key-a[now]),add_edge(now,0,0);
		if(w.count(now-1)&&now%m!=1) add_edge(now,now-1,inf),add_edge(now-1,now,0);//要判断是否在矩阵最左侧/最右侧，这里坑了我一个下午
		if(w.count(now+1)&&now%m!=0) add_edge(now,now+1,inf),add_edge(now+1,now,0);//同上
		if(w.count(now-m)) add_edge(now,now-m,inf),add_edge(now-m,now,0);
		if(w.count(now+m)) add_edge(now,now+m,inf),add_edge(now+m,now,0);
	}
	for(IT it=w.begin();it!=w.end();it++){
		add_edge(*it,n*m+1,key-a[*it]),add_edge(n*m+1,*it,0);
	}//网络流建图
	maxflow=0;dinic();//跑dinic,这个要是不会请移步P3376
	return maxflow==pos;
}

signed main(){
	int cas;scanf("%lld",&cas);
	while(cas--){
		
		scanf("%lld%lld",&n,&m);least=0;sum_b=sum_w=num_b=num_w=0;b.clear(),w.clear();
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				int now=m*(i-1)+j;scanf("%lld",&a[now]);
				least=max(least,a[now]);//least表示矩阵中最大值。
				if((i+j)&1) sum_b+=a[now],num_b++,b.insert(now);
				else sum_w+=a[now],num_w++,w.insert(now);//维护白点，黑点的集合
			}
		}
		if(num_b!=num_w){
			int x=(sum_w-sum_b)/(num_w-num_b);//我这白点比黑点多，原因参见我如何规定那些是白点
			if(check(x)) printf("%lld\n",x*num_w-sum_w);
			else printf("-1\n");
		}
		else{
			if(sum_b!=sum_w){printf("-1\n");continue;}
			int l=least,r=inf,ans=-1;//至少要比least大
			while(l<=r){
				int mid=(l+r)>>1;
				if(check(mid)){
					r=mid-1;
					ans=mid*num_b-sum_b;
				}
				else l=mid+1;
			}
			printf("%lld\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：hzoi_liuchang (赞：1)

## 分析
不是很好想。

看到二维棋盘上的问题考虑黑白染色，设一共有 $cnt_1$ 个白点，这些白点的权值和为 $sum_1$；设一共有 $cnt_2$ 个黑点，这些黑点的权值和为 $sum_2$。

因为我们每一次会对相邻的格子操作，也就是说操作若干次后，黑点和白点增加的总价值是相同的，设最后棋盘上的点都变成了 $x$，那么就有 $x \times cnt_1-sum_1=x \times cnt_2 -sum_2$。

化简后可得 $x(cnt_1-cnt_2)=sum_1-sum_2$。

此时，如果 $cnt_1-cnt_2$ 不为 $0$，那么我们就可以这一部分除过去得到 $x$ 的值判断是否合法即可；如果为 $0$，那么说明棋盘内格子的总个数一定为偶数。

如果 $x$ 合法，一定可以经过若干次操作后变成 $x+1$，所以可以二分答案然后判断是否合法，判断是否合法可以跑网络流。

设棋盘中原来的数为 $val$，

$1$、从源点向所有白点建一条权值为 $x-val$ 的边。

$2$、从白点向所有和它相邻的黑点建一条权值为 $inf$ 的边。

$3$、从黑点向汇点建一条权值为 $x-val$ 的边。

判断最大流是否等于 $\sum(x-val)$ 即可。

注意二分的下界要从原图的最大权值开始选。
## 代码
``` cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#define rg register
inline int read(){
	rg int x=0,fh=1;
	rg char ch=getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*fh;
}
const int maxn=2e3+5,maxm=2e4+5;
const int dx[6]={0,0,-1,1},dy[6]={-1,1,0,0};
const long long INF=100000000000000LL;
int h[maxn],tot=2,n,m,tt;
struct asd{
	int to,nxt;
	long long val;
}b[maxm];
void ad(int aa,int bb,long long cc){
	b[tot].to=bb;
	b[tot].nxt=h[aa];
	b[tot].val=cc;
	h[aa]=tot++;
}
int js(int i,int j){
	return (i-1)*m+j;
}
int a[maxn][maxn],s,t,h2[maxn],mmax,cnt0,cnt1,jlmax;
bool jud[maxn][maxn];
long long sum0,sum1;
int dep[maxn],q[maxn],head,tail;
bool bfs(){
	for(rg int i=0;i<=mmax;i++){
		dep[i]=0;
		h[i]=h2[i];
	}
	q[head=tail=1]=s;
	dep[s]=1;
	while(head<=tail){
		rg int now=q[head++];
		for(rg int i=h[now];i!=-1;i=b[i].nxt){
			rg int u=b[i].to;
			if(!dep[u] && b[i].val){
				dep[u]=dep[now]+1;
				q[++tail]=u;
			}
		}
	}
	return dep[t];
}
long long dfs(int now,long long ac1){
	if(now==t) return ac1;
	long long ac2=0;
	for(rg int i=h[now];i!=-1;i=b[i].nxt){
		h[now]=i;
		rg int u=b[i].to;
		if(dep[u]==dep[now]+1 && b[i].val){
			rg long long nans=dfs(u,std::min(ac1,b[i].val));
			ac1-=nans;
			ac2+=nans;
			b[i].val-=nans;
			b[i^1].val+=nans;
		}
		if(ac1==0) break;
	}
	if(ac2==0) dep[now]=0;
	return ac2;
}
bool pd(long long val){
	memset(h,-1,sizeof(h));
	tot=2;
	for(rg int i=1;i<=n;i++){
		for(rg int j=1;j<=m;j++){
			if(jud[i][j]==0){
				ad(s,js(i,j),std::max(val-a[i][j],0LL));
				ad(js(i,j),s,0);
			} else {
				ad(js(i,j),t,std::max(val-a[i][j],0LL));
				ad(t,js(i,j),0);
			}
		}
	}
	for(rg int i=1;i<=n;i++){
		for(rg int j=1;j<=m;j++){
			if(jud[i][j]) continue;
			for(rg int k=0;k<4;k++){
				rg int nx=i+dx[k],ny=j+dy[k];
				if(nx<1 || ny<1 || nx>n || ny>m || jud[nx][ny]==jud[i][j]) continue;
				ad(js(i,j),js(nx,ny),INF);
				ad(js(nx,ny),js(i,j),0);
			}
		}
	}
	rg long long nans=0,mans=0;
	for(rg int i=1;i<=n;i++){
		for(rg int j=1;j<=m;j++){
			if(jud[i][j]==0) mans+=std::max(val-a[i][j],0LL);
		}
	}
	for(rg int i=0;i<=mmax;i++){
		h2[i]=h[i];
	}
	while(bfs()){
		nans+=dfs(s,INF);
	}
	if(nans==mans) return 1;
	else return 0;
}
int main(){
	tt=read();
	while(tt--){
		sum0=sum1=0,cnt0=cnt1=jlmax=0;
		n=read(),m=read();
		for(rg int i=1;i<=n;i++){
			for(rg int j=1;j<=m;j++){
				a[i][j]=read();
				jlmax=std::max(jlmax,a[i][j]);
			}
		}
		for(rg int i=1;i<=n;i++){
			for(rg int j=1;j<=m;j++){
				if(j==1){
					jud[i][j]=jud[i-1][j]^1;
				} else {
					jud[i][j]=jud[i][j-1]^1;
				}
			}
		}
		for(rg int i=1;i<=n;i++){
			for(rg int j=1;j<=m;j++){
				if(jud[i][j]){
					cnt1++;
					sum1+=a[i][j];
				} else {
					cnt0++;
					sum0+=a[i][j];
				}
			}
		}
		s=0,t=n*m+1,mmax=n*m+1;
		if(cnt0!=cnt1){
			rg long long now=1LL*(sum1-sum0)/(cnt1-cnt0);
			if(pd(now) && now>=jlmax) printf("%lld\n",1LL*now*cnt0-sum0);
			else printf("-1\n");
		} else {
			rg long long l=jlmax,r=INF,mids;
			while(l<=r){
				mids=(l+r)>>1;
				if(pd(mids)) r=mids-1;
				else l=mids+1;
			}
			if(pd(l)==0) printf("-1\n");
			else printf("%lld\n",1LL*cnt0*l-sum0);
		}
	}
	return 0;
}
```

---


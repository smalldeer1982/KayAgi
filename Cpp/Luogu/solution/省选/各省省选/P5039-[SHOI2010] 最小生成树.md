# [SHOI2010] 最小生成树

## 题目描述

Secsa最近对最小生成树问题特别感兴趣。他已经知道如果要去求出一个 $ n $ 个点、 $ m $ 条边的无向图的最小生成树有一个Krustal算法和另一个Prim的算法。另外，他还知道，某一个图可能有多种不同的最小生成树。例如，下面图3中所示的都是图2中的无向图的最小生成树：

![](https://cdn.luogu.com.cn/upload/pic/43631.png)

当然啦，这些都不是今天需要你解决的问题。Secsa想知道对于某一条无向图中的边AB，至少需要多少代价可以保证AB边在这个无向图的最小生成树中。为了使得AB边一定在最小生成树中，你可以对这个无向图进行操作，一次单独的操作是指：先选择一条图中的边 P1P2，再把图中除了这条边以外的边，每一条的权值都减少 $ 1 $ 。如图4所示就是一次这样的操作：

![](https://cdn.luogu.com.cn/upload/pic/43632.png)



## 说明/提示

$ 1 \leq N \leq 500,1 \leq M \leq 800,1 \leq d<10^6 $

## 样例 #1

### 输入

```
4 6 1
1 2 2
1 3 2
1 4 3
2 3 2
2 4 4
3 4 5```

### 输出

```
1```

# 题解

## 作者：jun头吉吉 (赞：13)

## 题意
给出一张图，问执行多少次
- 选中一条边
- 把其他所有边减一

操作，可以使第$\texttt{Lab}$条边必然出现在这张图的最小生成树上
## 题解
看到题的第一秒：和[[清华集训2012]最小生成树](https://www.luogu.com.cn/problem/P5934) 好像啊

首先，根据~~相对运动~~的原理，我们知道，将其它边全部减小，就相当于将此边增大。因此，我们把整棵树的操作，改到了一条边上。

然后，我们考虑这么一张图：

![image](https://cdn.luogu.com.cn/upload/image_hosting/wc93ycek.png)

选取$\color{red}{\texttt{Lab}}$的条件是什么？显然，
- 如果环上有全部比$\texttt{Lab}$短，那么肯定是选那些更短的边
- 如果环上有和$\texttt{Lab}$一样长，那么二者肯定是二选一
- 如果环上有一条比$\texttt{Lab}$长的边，那么肯定是选$\texttt{Lab}$边

我们看一下题面：
> 使得标号为 $Lab$ 边一定出现最小生成树中的最少操作次数。

因此，不能有一条从$u_{Lab}$到$v_{Lab}$的路径，使边权全部$\leq d_{Lab}$，因此我们可以将所有$\leq d_{Lab}$的边组成一张图，割去$i$的代价为$d_{Lab}-d_i+1$，跑一遍最小割即为正解
```cpp
#pragma optimize(2)
#include<bits/stdc++.h>
using namespace std;
template<typename T>
inline void read(T &x){
	x=0;char c=getchar();bool f=false;
	for(;!isdigit(c);c=getchar())f!=c=='-';
	for(;isdigit(c);c=getchar())x=x*10+c-'0';
	if(f)x=-x;
}
template<typename T ,typename ...Arg>
inline void read(T &x,Arg &...args){
	read(x);read(args...);
}
template<typename T>
inline void write(T x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)write(x/10);
	putchar(x%10+'0');
}
const int maxn=4010,maxe=100010*2;
struct Graph{
	struct node{
		int v,w,nxt;
	}e[maxe<<1];
	int head[maxn],cur[maxn],tot;
	int dis[maxn];
	int s,t;
	void init(int _s,int _t){s=_s,t=_t;tot=1;memset(head,0,sizeof head);}
	Graph(int _s=0,int _t=0){init(_s,_t);}
	void add(int u,int v,int w){
		//printf("%d %d %d\n",u,v,w);
		e[++tot]=(node){v,w,head[u]},head[u]=tot;
		e[++tot]=(node){u,w,head[v]},head[v]=tot;
	}
	#define v e[i].v
	inline bool bfs(){
		queue<int>q;
		memset(dis,0,sizeof dis);
		memcpy(cur,head,sizeof head);
		dis[s]=1;q.push(s);
		while(q.size()){
			int u=q.front();q.pop();
			for(int i=head[u];i;i=e[i].nxt)
				if(!dis[v]&&e[i].w){
					dis[v]=dis[u]+1,q.push(v);
					if(v==t)return true;
				}
		}
		return  false;
	}
	int dfs(int u,int flow){
		if(u==t)return flow;
		int rest=flow;
		for(int i=cur[u];i&&rest;i=e[i].nxt){
			if(dis[v]==dis[u]+1&&e[i].w){
				int tmp=dfs(v,min(rest,e[i].w));
				rest-=tmp,e[i].w-=tmp,e[i^1].w+=tmp;
			}
			cur[u]=i;
		}
		if(rest==0)dis[u]=-1;
		return flow-rest;
	}
	#undef v
	int dinic(){
		int ans=0;
		while(bfs())
			while(int sth=dfs(s,2e9))
				ans+=sth;
		return ans;
	}
}G;
int n,m,Lab;
int x[1000],y[1000],d[1000];
signed main(){
	read(n,m,Lab);
	for(int i=1;i<=m;i++)
		read(x[i],y[i],d[i]);
	G.init(x[Lab],y[Lab]);
	for(int i=1;i<=m;i++)
		if(i!=Lab&&d[i]<=d[Lab])
			G.add(x[i],y[i],d[Lab]-d[i]+1);
	write(G.dinic());
}
```

---

## 作者：zsq259 (赞：5)

 
## **解析**

~~看上去是黑题啊！~~

实际上也就是道网络流最大流。~~（本蒟蒻都会做）~~

当然，我们也知道网络流最关键的是建图。

首先，分析一下题目：

题目要求在操作后使给定的边lab一定在最小生成树上，

求最小的操作数。

先设lab连通的边为A,B。

那么，根据Krustal算法，在加入lab时一定没有权值比lab小的边使A，B连通。

所以，只要将权值比lab小的边重新建图，

将容量设为这条边最少的操作次数就行了。

而最小的操作次数就应该是wlab −wi +1。

最后求A到B的最小割（最大流）就行了。

 

上AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

inline int read(){
	int sum=0,f=1;char ch=getchar();
	while(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' && ch<='9'){sum=sum*10+ch-'0';ch=getchar();}
	return f*sum;
}


const int INF=0x3f3f3f3f;
struct road{
	int next,to,w;
}e[100001];
struct line{
	int x,y,w;
}a[100001];
int n,m,lab;
int s,t;
int head[10001],cnt=1;
int d[100001],v[100001];

void add(int x,int y,int w){
	e[++cnt].to=head[x];
	e[cnt].next=y;
	e[cnt].w=w;
	head[x]=cnt;
}

bool bfs(){
	memset(d,-1,sizeof(d));
	memset(v,0,sizeof(v));
	queue <int> que;
	que.push(s);
	v[s]=1;
	d[s]=1;
	while(!que.empty()){
		int x=que.front();
		que.pop();
		for(int i=head[x];i;i=e[i].to){
			int k=e[i].next;
			if(v[k]||!e[i].w) continue;
			v[k]=1;
			d[k]=d[x]+1;			
			que.push(k);
		}
	}
	if(d[t]>0) return 1;
	return 0;
}

int dfs(int x,int low){
	if(x==t) return low;
	int c=0;
	for(int i=head[x];i;i=e[i].to){
		int k=e[i].next;
		if(d[k]!=d[x]+1) continue;
		if(!e[i].w) continue;
		if((c=dfs(k,min(low,e[i].w)))){
			e[i].w-=c;
			e[i^1].w+=c;
			return c;
		}
	}
	return 0;
}

void DINIC(){
	int ans=0,mi;
	while(bfs()){
		while((mi=dfs(s,INF))) ans+=mi;
	}
	printf("%d\n",ans);
	return ;
}

int main(){
//	freopen("mst.in","r",stdin);
//	freopen("mst.out","w",stdout);
	n=read();m=read();lab=read();
	for(int i=1;i<=m;i++){
		a[i].x=read();a[i].y=read();a[i].w=read();
	}
	s=a[lab].x;t=a[lab].y;
	for(int i=1;i<=m;i++){
		if(a[i].w<=a[lab].w&&i!=lab){
			add(a[i].x,a[i].y,a[lab].w-a[i].w+1);
			add(a[i].y,a[i].x,0);
			add(a[i].y,a[i].x,a[lab].w-a[i].w+1);
			add(a[i].x,a[i].y,0);			
		}
	}
	DINIC();
	return 0;
}

```




---

## 作者：creation_hy (赞：2)

根据 kruskal 的做法，容易发现一条边能出现在所有最小生成树上的前提是（最晚）遍历到它的时候 $x$ 和 $y$ 在两个连通块，也就是不存在边权小于等于它的一些边的集合能将 $x,y$ 连通。

而数量之间只有大小关系有意义，所以操作等价于给一条边 $+1$。容易发现一条边的删除代价等同于把它的值改为不小于等于给定边的代价，即为 $Lab_w-e_w+1$。

转化为用最小代价删除一些边使给定两点不连通，最小割即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 505;
const int M = 1e7 + 5;
const ll inf = 1e18;
int n, m, p, s, t, etot, head[N], to[M], nxt[M], stt[N], d[N];
ll val[M];
inline void link(int u, int v, ll w)
{
	to[etot] = v;
	nxt[etot] = head[u];
	val[etot] = w;
	head[u] = etot++;
}
inline void add(int u, int v, ll w)
{
	link(u, v, w);
	link(v, u, 0);
}
inline bool bfs()
{
	queue<int> q;
	memset(d, 0, sizeof(d));
	d[s] = 1;
	q.emplace(s);
	while (!q.empty())
	{
		int x = q.front();
		q.pop();
		for (int i = head[x]; ~i; i = nxt[i])
			if (!d[to[i]] && val[i])
			{
				d[to[i]] = d[x] + 1;
				q.emplace(to[i]);
				if (to[i] == t)
					return true;
			}
	}
	return false;
}
inline ll dfs(int x, ll flow)
{
	if (x == t)
		return flow;
	ll res = 0;
	for (int &i = stt[x]; ~i; i = nxt[i])
		if (d[to[i]] == d[x] + 1 && val[i])
		{
			ll tmp = dfs(to[i], min(flow - res, val[i]));
			if (tmp)
			{
				res += tmp;
				val[i] -= tmp;
				val[i ^ 1] += tmp;
				if (res == flow)
					break;
			}
		}
	return res;
}
inline ll dinic()
{
	ll res = 0;
	while (bfs())
	{
		memcpy(stt, head, sizeof(head));
		res += dfs(s, inf);
	}
	return res;
}
struct edge
{
	int u, v, w, t;
} e[N << 1];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	memset(head, -1, sizeof(head));
	cin >> n >> m >> p;
	for (int i = 1; i <= m; i++)
		cin >> e[i].u >> e[i].v >> e[i].w;
	for (int i = 1; i <= m; i++)
		if (i != p && e[i].w <= e[p].w)
			add(e[i].u, e[i].v, e[p].w - e[i].w + 1), add(e[i].v, e[i].u, e[p].w - e[i].w + 1);
	s = e[p].u, t = e[p].v;
	cout << dinic() << '\n';
	return 0;
}
```

---

## 作者：ysy20021208 (赞：2)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**分析与题解：**题目中所说的操作——对于一条边，我们将其不变，其他的边减一。在做题的时候不太方便，所以我们将其进行转化，我们把这个操作转换成为：对于当前边，我们将其加一，其他的边不变。这样我们做题就方便多了。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑最小生成树的求法：$kruskal$，要想让指定边一定出现在最小生成树中，我们就要让边权小于等于指定边的所有边都加入到图中之后，指定边的两个端点依旧不连通，这样我们就可以转化问题，并建立模型。我们将边权小于等于指定边的边连到图中，并以指定边的两个端点为$S$和$T$求最小割。我们所连的边权并不是原图中的边权，因为我们在这里要求的代价最小，所以我们的每一个边的边权要改为代价。因为我们如果要使当前边不出现在图中，我们就要让他的边权在一通操作之后大于指定变边，所以一个边的代价为$d_i-d_{lab}+1$。

```c++
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define N 1000
#define inf 1000000000
int n,m,lab,s,t,dis[N],ans,a[N],b[N],c[N];
int cur[N],head[N],to[N<<5],nxt[N<<5],val[N<<5],idx=1;
void add(int a,int b,int c)
    {nxt[++idx]=head[a],to[idx]=b,val[idx]=c,head[a]=idx;}
bool bfs()
{
    memset(dis,-1,sizeof dis);
    queue <int> q;q.push(s),dis[s]=0;
    while(!q.empty())
    {
        int p=q.front();q.pop();
        if(p==t) return true;
        for(int i=head[p];i;i=nxt[i])
            if(val[i]>0&&dis[to[i]]==-1)
                dis[to[i]]=dis[p]+1,q.push(to[i]);
    } return false;
}
int dfs(int p,int flow)
{
    int now,temp=flow;
    if(p==t) return flow;
    for(int i=cur[p];i;i=nxt[i])
        if(val[i]>0&&dis[to[i]]==dis[p]+1)
        {
            now=dfs(to[i],min(val[i],temp));
            if(!now) dis[to[i]]=-1;
            temp-=now,val[i]-=now,val[i^1]+=now;
            if(val[i]) cur[p]=i;
            if(!temp) break;
        } return flow-temp;
}
void dinic() {while(bfs()) memcpy(cur,head,sizeof head),ans+=dfs(s,inf);}
int main()
{
    scanf("%d%d%d",&n,&m,&lab);
    for(int i=1;i<=m;i++) scanf("%d%d%d",&a[i],&b[i],&c[i]); s=a[lab],t=b[lab];
    for(int i=1;i<=m;i++) if(i!=lab&&c[i]<=c[lab])
        add(a[i],b[i],-c[i]+c[lab]+1),add(b[i],a[i],-c[i]+c[lab]+1);
    dinic(),printf("%d\n",ans);
}
```

---

## 作者：Taduro (赞：2)


[传送门](https://www.luogu.org/problemnew/show/P5039)


## 正题：

### 题意简述：

​	给你一个无向图，你可以将除了你指定的一条边外的所有权值减一，每次代价为一。求对于指定的一条边，要花费多少代价使它一定成为最小生成树中的一条边。图的点数小于$500$，边数小于$800$。

### 做法：

​	首先，将一个边以外的边全都减一，就相当于把它加一。

​	第二，从$kruscal$ 的性质上考虑，如果一条边一定在最小生成树里，那么它所连接的两个点之间一定没有一条所包含的所有边都比它小的路径。因为最小生成树中不存在环，如果有环，那就要将环上最长的那条边删去。所以我们只要找到这种路径，将路径上最长的边加到比我们想要的边长，直到整个图中不存在这种路径即可。

​	这样，我们规定的这条边就没有一种方案被其他边替代了。

### 实现：

​	建立网络流模型，将图中所有边权不大于指定边权的边拿出来重新建图，边权改为与指定边权的差值加一，题目要求的边的两个端点分别为源点和汇点。那么我们上面所说的一条路径就是这个图中的一个流，目标状态是这个图中不存在流，跑一边最小割即可。

### 代码：

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
#ifdef ONLINE_JUDGE
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){if(A==B){B=(A=ss)+fread(ss,1,1<<17,stdin);if(A==B)return EOF;}return*A++;}
template<class T>inline void read(T&x){
    static char c;static int y;
    for(c=gc(),x=0,y=1;c<48||57<c;c=gc())if(c=='-')y=-1;
    for(;48<=c&&c<=57;c=gc())x=((x+(x<<2))<<1)+(c^'0');
    x*=y;
}
#else
void read(int &x){scanf("%d",&x);}
#endif
using namespace std;
struct node{
	int next,to,z;
}w[5001];
int head[2001],cnt,deep[2001],ans,n,m,z,c,a,b;
int o[2001],tim,heap,tail,team[2001],cur[2001];
int f[2001],t[2001],l[2001],q;
inline void add(int x,int y,int z){
	w[cnt].next=head[x];
	w[cnt].to=y; w[cnt].z=z;
	head[x]=cnt; cnt++;
}
inline bool bfs(){
	for (int i=1; i<=n; i++) cur[i]=head[i];
	heap=tail=1; tim++; deep[a]=1;
	team[tail]=a; o[a]=tim;
	while (heap<=tail){
		int k=team[heap];
		for (int i=head[k]; i!=-1; i=w[i].next){
			if (o[w[i].to]!=tim&&w[i].z){
				deep[w[i].to]=deep[k]+1;
				o[w[i].to]=tim;
				team[++tail]=w[i].to;
			}
		}
		heap++;
	}
	return (o[b]==tim);
}
int dfs(int x,int v){
	if (x==b||v==0) return v;
	int used=0,minn,z;
	for (int &i=cur[x]; i!=-1; i=w[i].next){
		if (w[i].z&&deep[w[i].to]==deep[x]+1){
			minn=min(v-used,w[i].z);
			z=dfs(w[i].to,minn);
			if (z){
				w[i].z-=z; w[i^1].z+=z;
				used+=z;
			}
			if (used==v) break;
		}
	}
	if (!used) deep[x]=0;
	return used;
}
int main(){
	int x,y,z;
	read(n),read(m),read(q);
	for (int i=1; i<=m; i++){
		read(x),read(y),read(z);
		f[i]=x; t[i]=y; l[i]=z;
	}
	memset(head,-1,sizeof(head));
	a=f[q]; b=t[q]; c=l[q];
	for (int i=1; i<=m; i++){
		if (i==q) continue;
		if (l[i]<=c){
			add(f[i],t[i],c-l[i]+1);
//			printf("%d %d %d\n",f[i],t[i],c-l[i]+1);
			add(t[i],f[i],0);
			add(t[i],f[i],c-l[i]+1);
			add(f[i],t[i],0);
		}
	}
	while (bfs())
		ans+=dfs(a,1e9);
	printf("%d\n",ans);
	return 0;
}
```



---

## 作者：Nangu (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5039)

## 题意 
- 选中一条边，将除此变之外的边都减一。
- 多少次以上操作可以使得编号为 $Lab$ 的边一定出现在该图的最小生成树上。

## 题解
~~首先，把其他边减一就等于把此边加一。~~

我们思考 kruskal 算法的原理：按边的边权从小到大排序，依次判断：若边的两个端点中至少有一个点没被选中，就把这条边加到最小生成树上。也就是说，如果我们想编号为 $Lab$ 被加入最小生成树，则**边权小于或等于 $d_{Lab}$ 的边不能联通 $x_{Lab}$ 和 $y_{Lab}$，否则此边就不能保证一定在最小生成树中**。也就是说，若有若干条边权小于 $d_{Lab}$ 的边能联通 $x_{Lab}$ 和 $y_{Lab}$，我们必须割掉其中的一条边。

怎么割掉一条边呢？显然，只要将此边的边权加到**严格大于** $d_{Lab}$，就相当于割掉了这条边。这不就是最小割模型吗！我们以 $d_i-d_{Lab}+1$ 为最大流量，跑一遍最小割及为答案。

## 代码
```cpp
#include <bits/stdc++.h>

#define F(i, j, k) for(int i=(j), ENDD=(k); i<=ENDD; ++i)
#define R(i, j, k) for(int i=(j), ENDD=(k); i>=ENDD; --i)

using namespace std;

const int N=2e4+7, M=2e5+7, INF=2e9;

struct edge{
	int v, w, nxt;
}e[M<<1];

struct line{
	int u, v, w;
}l[M];

int n, m, head[N], cur[N], dep[N], cnt=1, lab, ans;

inline void init(int u, int v, int w){
	e[++cnt]={v, w, head[u]}, head[u]=cnt;
}

bool bfs(const int s, const int t){
	memset(dep, 0, sizeof dep), memcpy(cur, head, sizeof head);
	queue<int> q; q.push(s), dep[s]=1;
	while(!q.empty()){
		int u=q.front(), v; q.pop();
		for(int i=head[u]; i; i=e[i].nxt)
			if(!dep[v=e[i].v] && e[i].w) dep[v]=dep[u]+1, q.push(v);
	}
	return dep[t];
}

int dfs(int now, int s, const int t){
	if(now==t || !s) return s;
	int res=0, v, tmp;
	for(int &i=cur[now]; i; i=e[i].nxt)
		if(dep[v=e[i].v]==dep[now]+1 && e[i].w){
			tmp=dfs(v, min(s-res, e[i].w), t);
			if(tmp==0) {dep[v]=-1; continue;}
			e[i].w-=tmp, e[i^1].w+=tmp, res+=tmp;
			if(res==s) return res;
		}
	return res;
}

int dinic(const int s, const int t){
	int res=0;
	while(bfs(s, t)) res+=dfs(s, INF, t);
	return res;
}

signed main()
{
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin>>n>>m>>lab;
	F(i, 1, m) cin>>l[i].u>>l[i].v>>l[i].w;
	int w=l[lab].w;
	F(i, 1, m) if(l[i].w<=w && i!=lab) init(l[i].u, l[i].v, w-l[i].w+1), init(l[i].v, l[i].u, w-l[i].w+1);
	cout<<dinic(l[lab].u, l[lab].v);
 	return 0;
}

---

## 作者：Honor誉 (赞：1)

题目要求一个数必须在最小生成树中取到。

那么我们可以yy一下怎们样才能取不到：
![](https://cdn.luogu.com.cn/upload/image_hosting/mymsusof.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/itw8lg0z.png)

就像上面的情况一样，只要另一条联通AB的路径中没有边>lenAB，AB就有可能取不到。

证明：设一点C满足AC<=AB,BC<=AB,最小生成树可以选取AC+BC代替AB+XX来联通A，B，C三点

所以，为了达成题目的要求，必须通过操作来破坏这种情况。

由于要求最小且是要求破坏，可以想到将这些情况放在图论中，用最小割来求答案。

建图方式：

枚举每一条边CD，只要他的权值<=valAB,在C，D两点间连接一条流量为valAB-valCD+1的边。

源点A，汇点B，求该图的最小割即可。（因为源点、汇点为A，B，所以能够对答案有贡献的路径一定是以A，B为端点的）

```cpp
#include<bits/stdc++.h>
#define N 510
#define M 2010
#define inf 2147483647
using namespace std;
struct data
{
	int u,v,c;
}a[M];
int n,m,k,head[N],to[M<<1],nxt[M<<1],f[M<<1],dep[N],s,t,cur[N],cnt,maxnf;
queue<int> q;
bool bfs()
{
	memset(dep,-1,sizeof(dep));
	while(!q.empty())
	{
		q.pop();
	}
	dep[s]=0;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=nxt[i])
		{
			int v=to[i];
			if(f[i]&&(dep[v]==-1))
			{
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}
	return (dep[t]!=-1);
}
int dfs(int u,int flow)
{
	if(u==t)
	{
		return flow;
	}
	int flow1=0,flow2;
	for(int i=cur[u];i;i=nxt[i])
	{
		cur[u]=i;
		int v=to[i];
		if((dep[v]==dep[u]+1)&&(f[i]))
		{
			flow2=dfs(v,min(flow,f[i]));
			flow1+=flow2;
			flow-=flow2;
			f[i]-=flow2;
			f[i^1]+=flow2;
			if(!flow)
			{
				break;
			}
		}
	}
	if(!flow1)
	{
		dep[u]=-1;
	}
	return flow1;
}
void dinic()
{
	maxnf=0;
	while(bfs())
	{
		memcpy(cur,head,sizeof(cur));
		maxnf+=dfs(s,inf);
	}
}
void adde(int x,int y,int z)
{
	to[++cnt]=y;
	nxt[cnt]=head[x];
	f[cnt]=z;
	head[x]=cnt;
	to[++cnt]=x;
	nxt[cnt]=head[y];
	f[cnt]=0;
	head[y]=cnt;
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&a[i].u,&a[i].v,&a[i].c);
	}
	cnt=1;
	s=a[k].u;
	t=a[k].v;
	for(int i=1;i<=m;i++)
	{
		if(i!=k&&a[i].c<=a[k].c)
		{
			adde(a[i].u,a[i].v,a[k].c-a[i].c+1);
			adde(a[i].v,a[i].u,a[k].c-a[i].c+1);
		}
	}
	dinic();
	printf("%d\n",maxnf);
	return 0;
}
```

---

## 作者：俾斯麦 (赞：1)

## [SHOI2010]最小生成树

注：本文将更加注重看不出来的网络流解法的思考过程的讲解。另外，作者写了HLPP，可以练一下手。

### 题目大意：
  在一个合法的连通图中，每条边都有一个边权，我们钦定一条边。然后对图进行一些操作：将某一条边的权值+1或-1。请问至少多少次后可以使钦定的边出现在该图的最小生成树中。
  
  
  Luogu传送门：[[SHOI2010]最小生成树](https://www.luogu.org/problemnew/show/P5039 "[SHOI2010]最小生成树")

### 解题思路：

   说实话：我们一定要跳出题目的局限性，毕竟网络流是属于图算法。
  我们考虑，为什么我们钦定的边会不在最小生成树上，很简单，有更多比它更小的边。并且，能够更新我们钦定边的边一定会和我们钦定的边成环（我们考虑kruscal的实现过程，如果想不明白，可以看看 严格次小生成树 ）。
  
  在这道题中更为简单，由上述条件，我们只需要对于每一条比我们钦定边target小的边建立一条
  `权值 = t[ target ].val - t[ i ].val + 1`
  的流边即可。然后转化为最小割模型即可。
  
### 模型转化：
  
  我很想把它提出来讲。
  
  我们既然要找到一条符合的边，那么就是要让最小生成树经过钦定边target，经过的前提就是可以到达target边上两点的其他路径都没有target更优，那么，然这些边增大即可。这样一想，感觉就是让这两点之间的其他路径都比target边的边权大。
  
  我们对这些原本更小的边都计算于target边权的差值，然后跑最小割。
  
  **口糊合法性：**
  
  1.这些边都小于target的边权，如果更大，那么它本身就不可以能优于target边，就不可能在target之前进入最小生成树
  
  2.由1可知，上述建出的流图中无负边权（流量为负），所以流算法是可行的。（最小割 = 最大流 ）
  
  3.如果target就在原本的最小生成树上，那么流图是不连通的，所以出题人是卡不了的。
  

注:楼主作死写了HLPP，完全可以用Dinic打，而且当前弧优化后还更快一些，迷，当然随机数据HLPP绝对有时间上的优势。

**AC code:**

```cpp
#include<bits/stdc++.h>
using namespace std;
const  int  MAXN = 100010 , inf = ( 1 << 30 ) ;
inline int read()
{
    int s = 0,w = 1;
    char g = getchar();
    while(g<'0'||g>'9'){if(g=='-')w*=-1;g = getchar();}
    while(g>='0'&&g<='9'){s = (s<<3)+(s<<1)+g-'0';g = getchar();}
    return s*w;
}
int  tot = 1 , to[ MAXN ] , nex[ MAXN ] , head[ 10005 ] , w[ MAXN ] , N , M , T , s , target ;
int  d[ 10005 ] , e[ 10005 ] , h[ 10005 ] , numh[ MAXN ] ;
bool v[ MAXN ] ;

struct ap{
    int from , too , val ;
}t[ MAXN ];

void  add( int  x , int  y , int  z ){
    tot++; to[ tot ] = y , w[ tot ] = z , nex[ tot ] = head[ x ] , head[ x ] = tot;
    tot++; to[ tot ] = x , w[ tot ] = 0 , nex[ tot ] = head[ y ] , head[ y ] = tot;
}
void  relabel( int  u ){
    h[ u ] = inf ;
    for( register int i = head[ u ] ; i ; i = nex[ i ] ){
        if( w[ i ] && h[ to[ i ] ] < h[ u ] )
            h[ u ] = h[ to[ i ] ] + 1 ;
    }

}
struct cmp{
    inline bool operator () (int a,int b) const{
        return h[a]<h[b];
    }
};//重载d
priority_queue< int , vector<int> , cmp > q ;
queue< int >Bq;
void bfs(){
    for( register int i = 1 ; i <= N ; i ++ )h[ i ] = 1210 ;
    h[ T ] = 0 ;
    while( !Bq.empty() )Bq.pop();
    Bq.push( T ); v[ T ] = true ;
    while( !Bq.empty() ){
        int u = Bq.front();Bq.pop();
        v[ u ] = false ;
        for( register int i = head[ u ] ; i ; i = nex[ i ] ){
            if( w[ i^1 ] && h[ to[ i ] ] > h[ u ] ){
                h[ to[ i ] ] = h[ u ] + 1 ;
                if( !v[ to[ i ] ] ){
                    Bq.push( to[ i ] );
                    v[ to[ i ] ] = true ;
                }
            }
        }
    }
    return;
}
void push_(int u){
    for( register int i = head[ u ] ; i ; i = nex[ i ]){
        if( w[ i ] && h[ to[ i ] ] == h[ u ] - 1 ){ 
            int  k = min( w[ i ] , e[ u ] ) ;
            w[ i ] -= k , w[ i^1 ] += k ;
            e[ u ] -= k , e[ to[ i ] ] += k ;
            if( (!v[ to[ i ] ]) && to[ i ] != T && to[ i ] != s ){
                q.push( to[ i ] ) ;
                v[ to[ i ] ] = true ;
            }
            if( !e[u] )break;
        }
    }
}
int HLPP(){//作死使用HLPP 
    bfs();
    if( h[ s ] == ( 1 << 30 ) )return 0;
    h[ s ] = N ;
    for( register int i = 1 ; i <= N ; i++ )
        if( h[ i ] < 20000 )numh[ h[ i ] ]++ ;
    for( register int i = head[ s ] ; i ; i = nex[ i ] ){
        if( w[ i ] ){
            e[ s ] -= w[ i ] , e[ to[ i ] ] += w[ i ] ;
            w[ i^1 ] += w[ i ] ,  w[ i ] = 0;
            if( to[ i ] != T && ( !v[ to[ i ] ]) && to[ i ] != s ){
                q.push( to[ i ] ) ; v[ to[ i ] ] = true ;
            }
        }
    }
    while(!q.empty()){
        int  u = q.top() ;v[ u ] = false ;
        q.pop() ;push_( u ) ;
        if( e[ u ] ){
            numh[ h[ u ] ]-- ;
            if( numh[ h[ u ] ] == 0 ){
                for( register int i = 1 ; i <= N ; i++ ){
                    if( i != s && i != T && h[ i ] > h[ u ] && h[ i ] <= N  )
                        h[ i ] = N + 1 ;
                }
            }
            relabel( u ) ;
            numh[ h[ u ] ]++ ;
            q.push( u ) ;
            v[ u ] = true ;
        }
    }
    return e[ T ] ;
} 
void  prepare(){
    //freopen( "construct.in" , "r" , stdin ) ;
    //freopen( "construct.out" , "w" , stdout) ; 
}
int main(){
    
    N = read() ; M = read() ; target = read();
    for( register int i = 1 ; i <= M ; i++ )t[ i ].from=read(),t[ i ].too=read(),t[i].val=read();
    s = t[ target ].from ; T = t[ target ].too ;
    for( register int i = 1 ; i <= M ; i++ ){
        if( t[ i ].val <= t[target].val && i !=target ){
            add( t[ i ].from , t[ i ].too , t[ target ].val - t[ i ].val + 1 ) ;
            add( t[ i ].too , t[ i ].from , t[ target ].val - t[ i ].val + 1 ) ;        
        }
    }
    cout<<HLPP();
    return 0;
}
```

非常感谢您耐心读完了这篇博客，作者水平有限，本文难免有错误和叙述不精准，还请给为大佬指出，谢谢。

---

## 作者：狂犇 (赞：1)

题目中的操作——将除这条边外所有其他边的权值全部+1——就是忽悠人的，等价于将这条边的权值+1。

对答案有影响的边肯定是比指定边要小的边。

所以我们要阻止制定边的两端点提前连起来。

而最小代价就应该是指定边的代价+1-路径上最大边的值。

然后就形成了一个路径分配问题。所以我们按 指定边的代价+1-边的权值 连边

所的的答案就是最小割

Code：
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <cmath>
using namespace std;
#define maxn 844444
#define INF 1000000000
inline int getint()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,m,d;
int st,ed,en;
int first[maxn],dis[maxn],q[maxn];
struct node
{
    int v,c,next;
}e[maxn];
int add(int a,int b,int c)
{
    en++;
    e[en].v=b;
    e[en].c=c;
    e[en].next=first[a];
    first[a]=en;
 
    en++;
    e[en].v=a;
    e[en].c=0;
    e[en].next=first[b];
    first[b]=en;
}
struct node2
{
    int x,y,v,id;
}a[maxn];
bool cmp(node2 aa,node2 bb)
{
    return aa.v<bb.v;
}
bool bfs()
{
    memset(dis,-1,sizeof(dis));
    int head=1;
    int tail=1;
    tail++;
    q[tail]=st;
    dis[st]=0;
    while(head<tail)
    {
        head++;
        int u=q[head];
        for(int i=first[u];i!=-1;i=e[i].next)
        {
            if(e[i].c==0) continue;
            if(dis[e[i].v]!=-1) continue;
            dis[e[i].v]=dis[u]+1;
            if(ed==e[i].v) return true;
            tail++;
            q[tail]=e[i].v;
        }
    }
    return false;
}
int dfs(int x,int mx)
{
    int flow=0,f,ret=0;
    if(x==ed||mx==0) return mx;
    for(int i=first[x];i!=-1;i=e[i].next)
    {
        if(e[i].c==0) continue;
        if(dis[e[i].v]!=dis[x]+1) continue;
        f=dfs(e[i].v,min(mx,e[i].c));
        if(f)
        {
            e[i].c-=f;
            e[i^1].c+=f;
            flow+=f;
            mx-=f;
            if(!mx) break;
        }
    }
    if(flow==0) dis[x]=-1;
    return flow;
}
 
void init()
{
    en=-1;
    memset(first,-1,sizeof(first));
}
int dinic()
{
    int tmp=0,maxflow=0;
    while(bfs())
    {
        while(tmp=dfs(st,INF)) maxflow+=tmp;
    }
    return maxflow;
}
int main()
{
    n=getint();m=getint();d=getint();
    for(int i=1;i<=m;i++)
        a[i].x=getint(),a[i].y=getint(),a[i].v=getint(),a[i].id=i;
    init();
    sort(a+1,a+m+1,cmp);
    for(int i=1;i<=m;i++)
    {
        if(a[i].id==d)
        {
            st=a[i].x;ed=a[i].y;
            d=i;
            break;
        }
    }
    for(int i=1;i<=m;i++)
    {
        if(i==d) continue;
        if(a[i].v>a[d].v) break;
        add(a[i].x,a[i].y,a[d].v+1-a[i].v);
        add(a[i].y,a[i].x,a[d].v+1-a[i].v);
    }
    printf("%d",dinic());
    return 0;
}
```

---

## 作者：MuelsyseU (赞：0)

考虑操作等价于一条边的权值自增 $1$。

再考虑 Kruskal 的思想，一条边被加入 MST 意味着其是连接两个连通块的最小边。

假设其不是割边；否则答案为 $0$。否则若其必选，那么其一定包含在若干个环中，并且不是任何环上的最大边。并且这个条件是充要的，可以考察 Kruskal 的过程得知。

即解决以下问题：

> 每次一条边权值自增 $1$，使得没有 $u$ 到 $v$ 的任意一条路径上，所有边边权 $\le k$。

我们设一条边的代价 $t(i)=\max\{0,w(i)-k\}$，那么这即为最小割模板。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1005, maxm = 6005;
const int inf = 0x3f3f3f3f;
int s, t;
namespace Flow {
	int cur[maxn], hd[maxn], tot = 1, d[maxn];
	struct Edg {
		int y, z, nxt;
	} e[maxm];
	void add(int x, int y, int z) {
		e[++tot] = {y, z, hd[x]}, hd[x] = tot;
		e[++tot] = {x, z, hd[y]}, hd[y] = tot;
	}
	bool bfs() {
		memcpy(cur, hd, sizeof(hd));
		memset(d, 0, sizeof(d));
		queue<int> q;
		q.push(s), d[s] = 1;
		while (!q.empty()) {
			int x = q.front();
			q.pop();
			for (int i = hd[x]; i; i = e[i].nxt) {
				int y = e[i].y;
				if (!e[i].z || d[y]) continue;
				d[y] = d[x] + 1, q.push(y);
				if (y == t) return 1;
			}
		}
		return 0;
	}
	int dinic(int x, int fl) {
		if (x == t) return fl;
		int res = fl;
		for (int i = cur[x]; i && res; i = e[i].nxt) {
			int y = e[i].y;
			if (!e[i].z || d[y] != d[x] + 1) continue;
			int tp = dinic(y, min(res, e[i].z));
			if (!tp) d[y] = -1;
			else e[i].z -= tp, e[i ^ 1].z += tp, res -= tp;
		}
		if (fl == res) d[x] = -1;
		return fl - res;
	}
	int solve() {
		int ans = 0, tmp;
		while (bfs())
			while (tmp = dinic(s, inf)) ans += tmp;
		return ans;
	}
}
int n, m;
struct Edg {
	int x, y, z;
} e[maxm];
signed main() {
	int tar, k = 0;
	scanf("%d%d%d", &n, &m, &tar);
	for (int i = 1; i <= m; ++i) scanf("%d%d%d", &e[i].x, &e[i].y, &e[i].z);
	k = e[tar].z, s = e[tar].x, t = e[tar].y;
	for (int i = 1; i <= m; ++i)
		if (e[i].z <= k && (i ^ tar)) Flow::add(e[i].x, e[i].y, k - e[i].z + 1);
	printf("%d", Flow::solve());
	return 0;
}
```

---

## 作者：chenxia25 (赞：0)

虑一下 $lab$​ 一定在 MST 中的充要条件是什么。我们考虑 Kruskal 的过程，如果将边权小于 $w_{lab}$​ 的边全部连完之后，$a_{lab},b_{lab}$ 不连通，那么 $lab$ 一定被选。不过当边权有相同的时候稍微会出问题，不难发现将 $lab$ 排在所有边权相同的边后面是最强的，于是将上述「小于」改成「小于等于」。

参考 Kruskal 的过程发现 MST 仅与边权之间相对大小有关，所以一次操作等价于将某条边边权 $+1$​​。我们现在要做的是，删掉一些边权不超过 $lab$​​ 的边，使得所有边权不超过 $lab$​​ 的边连成的图中 $a_{lab},b_{lab}$​。怎么删呢？使用上述操作，删除 $x$ 代价是 $w_{lab}-w_x+1$。

然后就变成了一个裸的无向图最小割题。关于无向图最小割我再插一嘴：当年康狼抓兔子的时候，那时候脑子抽了，不知道怎么想的认为无向图最小割不可做。然后看了题解，发现都没讲无向图最小割的事情，就像很显然一样，很是不解。后来今年暑假做到某个 CC 的支配树，又仔细想了一下，无向图最小割原来就是无向边连成两条有向边的最小割（跟无向图最大流一样，也就是最大流最小割定理对无向图也成立）……道理其实不难（但没有最大流那么简单（笑））：对任意一组割 $(S,T)$，$S\to T$ 的每条无向边分裂成的有向边显然只会选恰好一条……得证。

---

## 作者：ez_lcw (赞：0)

初看题目，发现题目的操作比较复杂。仔细想了一想，发现题目中的操作“把图中除了这条边以外的边，每一条的权值都减少 $1$”就等价于“把这条边的权值加 $1$”。所以题目的操作就被我们化繁为简了。

然后继续想：如何才能使 $Lab$ 边一定在最小生成树中？

画个图看一下（就以样例为例）：

![](https://cdn.luogu.com.cn/upload/image_hosting/hq9a5oks.png)

假设现在 $Lab$ 边是 $(1,2)$，长度为 $2$。

那么既然我要保证 $Lab$ 边是最小生成树的一条边，点 $1$、$2$ 就不能在一个环里面，也就是说，点 $1$、$2$ 之间不能存在另一条可选的路径。（注意“边”与“路径”的区别）

也就是说，在原来的无向图上，$1\rightarrow2$ 的其他路径中，每条路径至少要存在一条边的边权大于 $2$，否则在建最小生成树时就有可能被选到。

比如 $1\rightarrow2$ 的其他路径有 $1\rightarrow3\rightarrow2$、$1\rightarrow4\rightarrow2$ ……，其中路径 $1\rightarrow3\rightarrow2$ 是不满足条件的，因为这条路径上没有一条边的边权大于 $2$，那么我们就有可能选边：

![](https://cdn.luogu.com.cn/upload/image_hosting/deizxltd.png)

而不是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/fpeb26fb.png)

总而言之，设 $Lab$ 边是 $(A,B)$，长度为 $len$，那么我们要保证在操作之后的无向图上，不存在一条路径 $A\rightarrow B$ 使得这条路径上所有边的边权都小于等于 $len$。

如何维护？

一种显然的暴力就是：枚举 $A\rightarrow B$ 的每一条路径，找到路径上边权的最大值 $maxn$，如果 $maxn>len$，就不管它，否则就用 $len-maxn+1$ 次操作使得这条边权最大的边的权值加上 $len-maxn+1$，超过 $len$。这时我们就能用最小的代价保证这条路径不可能被选到。

想到这里很容易想到最小割：找到边权 $len_0$ 小于等于 $len$ 的每条边 $(u,v)$，并在另一个图上建边 $(u,v,len-len_0+1)$，然后再从 $A$ 到 $B$ 跑最小割，也就是说找到 $A\rightarrow B$ 每条路径上操作代价最小的一条边。最后跑出来的最小割就是答案。

代码如下：

```cpp
#include<bits/stdc++.h>

#define N 510
#define M 810
#define INF 0x7fffffff

using namespace std;

struct edge
{
	int u,v,w;
}e[M];

int n,m,lab,s,t;
int cnt=1,head[N],cur[N],to[M<<2],nxt[M<<2],c[M<<2];
int num[N];

queue<int>q;

void adde(int u,int v,int ci)
{
	to[++cnt]=v;
	c[cnt]=ci;
	nxt[cnt]=head[u];
	head[u]=cnt;
	
	to[++cnt]=u;
	c[cnt]=0;
	nxt[cnt]=head[v];
	head[v]=cnt;
}

bool bfs()
{
	memcpy(cur,head,sizeof(cur));
	memset(num,-1,sizeof(num));
	q.push(s);
	num[s]=0;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=nxt[i])
		{
			int v=to[i];
			if(c[i]&&num[v]==-1)
			{
				num[v]=num[u]+1;
				q.push(v);
			}
		}
	}
	return num[t]!=-1;
}

int dfs(int u,int minflow)
{
	if(!minflow||u==t) return minflow;
	int preflow=0,nowflow;
	for(int i=cur[u];i;i=nxt[i])
	{
		cur[u]=i;
		int v=to[i];
		if(num[v]==num[u]+1&&(nowflow=dfs(v,min(minflow-preflow,c[i]))))
		{
			preflow+=nowflow;
			c[i]-=nowflow;
			c[i^1]+=nowflow;
			if(!(minflow-preflow)) break;
		}
	}
	return preflow;
}

int dinic()
{
	int maxflow=0;
	while(bfs())
		maxflow+=dfs(s,INF);
	return maxflow;
}

int main()
{
	scanf("%d%d%d",&n,&m,&lab);
	for(int i=1;i<=m;i++)
		scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
	s=e[lab].u,t=e[lab].v;
	for(int i=1;i<=m;i++)
	{
		if(i!=lab&&e[i].w<=e[lab].w)
		{
			adde(e[i].u,e[i].v,e[lab].w-e[i].w+1);//别问我为什么要建双向边，问就是这是dinic，分层图不怕死循环
			adde(e[i].v,e[i].u,e[lab].w-e[i].w+1);
		}
	}
	printf("%d\n",dinic());
	return 0;
}
```

---

## 作者：_LHF_ (赞：0)

## 第一次看见这么水的黑题
前置技能：最小割，建议先AC这一道题目：[网络最大流](https://www.luogu.com.cn/problem/P3376)。

好了，为了让大家体验由蓝题瞬间到黑题的感觉，我先给出我曾经AC网络最大流这一题的代码：
```cpp
//注：这是网络最大流的代码！
#include<cstdio>
#define N 100010
#define kar k[i].ar
#define min(a,b) (a<b?a:b)
using namespace std;
int a,b,t,n,m,f[N],ans;
struct node{
	int next,ar,flow;
} k[N*20];
int first[N],dis[N],len,tr[N];
int x[N],y[N],v[N];
void add(int a,int b,int t)
{
	len++;
	k[len].ar=b;
	k[len].next=first[a];
	first[a]=len;
	k[len].flow=t;
}
int head,tail,d[N];
bool bfs()
{
	head=0,tail=1;
	d[0]=a;
	dis[a]=1;
	while(head<tail)
	{
		t=d[head];
		head++;
		for(int i=first[t];i;i=k[i].next)
		{
			if(dis[kar]==0&&k[i].flow>0)
			{
				dis[kar]=dis[t]+1;
				if(kar==b) return true;
				d[tail]=kar;
				tail++;
			}
		}
	}
	return false;
}
int dfs(int xx,int flow)
{
	if(xx==b) return flow;
	int h,s=0;
	for(int i=first[xx];i>1;i=k[i].next)
	{
		if(flow==0) break;
		if(dis[kar]==dis[xx]+1)
		{
			h=dfs(kar,min(flow,k[i].flow));
			s+=h;
			flow-=h;
			k[i].flow-=h;
			k[i^1].flow+=h;
		}
	}
	return s;
}
void dinic()
{
	for(int i=1;i<=n;i++)
	{
		dis[i]=0;
		first[i]=0;
	}
	len=1,ans=0;
	for(int i=1;i<=m;i++)
	add(x[i],y[i],f[i]),add(y[i],x[i],0);
	while(bfs())
	{
		ans+=dfs(a,0x7ffffff);
		for(int i=1;i<=n;i++) dis[i]=0;
	}
}
int main()
{
	int aa,bb;
	scanf("%d%d%d%d",&n,&m,&aa,&bb);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&a,&b,&t);
		x[i]=a,y[i]=b,f[i]=t;
	}
	a=aa;
	b=bb;
	dinic();
	printf("%d",ans);
	return 0;
}
```
---
### 分析：
设直接连接A、B的这一条边为X。

$1$、我们可以通过分析题目得知，若图中连接P1、P2这条边除外的边减少1，其实就是将图中连接P1、P2这条边的权值增加1。

$2$、既然两个点要连接，所以我们可以想：两点之间其他能够联通并且那些边的权值均小于X的这一条边的权值，那么跑最小生成树就不会加上这一条边了。所以我们可以想办法让A、B的其他路径上的边的权值有的加大一点，这样从A、B的其他路径中只要有一个边的权值大于的X的边权，那么那一条边就废了。

$3$、当然，我们不能考虑的太少，这里要使所有的A到B路径中都会回有一条边的边权>=X的边权（X除外），废掉所有的边之后，X就能被选上了。所以，最小割该上场了。

$4$、关于建模的问题很简单，我们可以看第$i$条边的边权是否小于X的边权，如果小于，我们就可以把它看做可能危害到选X这一条边的边，所以我们在图上就要算上这一条边。当然，如果这一条边加上$k$就>X的边权了，所以这一条边为$k$的最小值。

$5$、根据“最大流最小割定理”，我们只用在建模后的图上跑一次最小割就可以了。

## 该上代码了：
```cpp
#include<cstdio>
#define N 1010
#define kar k[i].ar
#define min(a,b) (a<b?a:b)
using namespace std;
int a,b,t,n,m,ans,trl;
struct node{
	int next,ar,flow;
} k[N*20];
int first[N],dis[N],len;
int x[N],y[N],f[N],l;
//链式前向星插入操作
void add(int a,int b,int t)
{
	len++;
	k[len].ar=b;
	k[len].next=first[a];
	first[a]=len;
	k[len].flow=t;
}
int head,tail,d[N];
//分层
bool bfs()
{
	head=0,tail=1;
	d[0]=a;
	for(register int i=0;i<=n;i++) dis[i]=0;
	dis[a]=1;
	while(head<tail)
	{
		t=d[head];
		head++;
		for(register int i=first[t];i;i=k[i].next)
		{
			if(dis[kar]==0&&k[i].flow>0)
			{
				dis[kar]=dis[t]+1;
				if(kar==b) return true;
				d[tail]=kar;
				tail++;
			}
		}
	}
	return false;
}
//多路增广
int dfs(int xx,int flow)
{
	if(xx==b) return flow;
	if(flow==0) return 0;
	if(dis[xx]>=dis[b]) return 0;
	int h,s=0;
	for(register int i=first[xx];i>1;i=k[i].next)
	{
		if(flow==0)
		{
			dis[xx]=0;
			break;
		}
		if(dis[kar]==dis[xx]+1&&k[i].flow>0)
		{
			h=dfs(kar,min(flow,k[i].flow));
			s+=h;
			flow-=h;
			k[i].flow-=h;
			k[i^1].flow+=h;
			if(h==0) dis[kar]=0;
		}
	}
	return s;
}
//跑最小割
void dinic()
{
	while(bfs()) ans+=dfs(a,0x7ffffff);
}
int main()
{
	scanf("%d%d%d",&n,&m,&l);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x[i],&y[i],&f[i]);
	}
	a=x[l],b=y[l];
	len=1;
	//建模
	for(int i=1;i<=m;i++)
	{
		if(i!=l&&f[i]<=f[l])
		{
			add(x[i],y[i],f[l]-f[i]+1);
			add(y[i],x[i],f[l]-f[i]+1);
		}
	}
	dinic();
	printf("%d",ans);
}
```
是不是跟网络最大流的代码很像呀。一点点差别使蓝题变成了黑题。

广告：[最小割树](https://www.luogu.com.cn/problem/P4897)功能强大，效率高，建议学习，学习地址：[传送门](https://www.luogu.com.cn/blog/LHF/solution-p4897)。

---


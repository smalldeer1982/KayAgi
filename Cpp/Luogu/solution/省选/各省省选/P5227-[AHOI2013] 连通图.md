# [AHOI2013] 连通图

## 题目描述

给定一个无向连通图和若干个小集合，每个小集合包含一些边，对于每个集合，你需要确定将集合中的边删掉后改图是否保持联通。集合间的询问相互独立

定义一个图为联通的当且仅当对于任意的两个顶点，都存在一条路径连接它们

## 说明/提示

$1~\leq~n,k~\leq~10^5$

$1~\leq~m~\leq~2~\times~10^5$

$1~\leq~c~\leq~4$

## 样例 #1

### 输入

```
4 5
1 2
2 3
3 4
4 1
2 4
3
1 5
2 2 3
2 1 2```

### 输出

```
Connected
Disconnected
Connected```

# 题解

## 作者：SSerxhs (赞：44)

神仙哈希题，复杂度 $O(k\times \min(2^c,\log n)+n+m)$，目前你谷最优解。

前置定义：非树边的覆盖树边指的是非树边的两个端点在树上的最短路覆盖的边。记 xor 为 $\oplus$。

考虑给非树边一个随机权值，而树边的权值为所有覆盖其的非树边的 $\oplus$，则删边不连通当且仅当删除的边集的一个子集 $\oplus$ 是 $0$，这个可以在 $c$ 小的时候枚举子集、$c$ 大的时候线性基实现。树边的权值可以通过树上差分快速修改。

证明：考虑被分开的两个极大连通点集之间被删掉的边的 $\oplus$。考虑每条非树边产生的贡献。若这条边两端在同一点集（设为 $A$），那么其覆盖的被删除树边必定是 $A\to B\to A \to B\to A$，偶数次；若这条边两端在不同点集则出现奇数次，加上非树边本身还是偶数次，因而 $\oplus$ 必定为 $0$。

当 $\oplus$ 为 $0$ 时，由于我比较懒，就只证 dfs 树的情况了。

显然这些边至少有一条树边，设深度最小的那条为 $(fa_u,u)$。考虑树边为 $(fa_u,u)$，那么若 $fa_u$ 和 $u$ 还能连通，必定是通过 $u$ 子树出发的某条非树边 $(x,y)$（$x$ 在 $u$ 子树内） 跳到 $fa_u$ 的祖先。由于 $(fa_u,u)$ 深度最小，因此 $fa_u$ 到 $y$ 的路径上边都未断开。由于 $(x,y)$ 没有贡献，那么要么自身被删了，要么 $(x,u)$ 上还有另一条边被删了，无论哪种 $u$ 都不能经过 $(x,y)$ 到达深度更小的节点。

```cpp
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ll;
const int N=1e5+2,M=2e5+2;
ll v[N],val[M],js;
int lj[M],nxt[M],bh[M],fir[N],f[N];
int n,m,i,x,y,z,c,bs;
inline void read(int &x)
{
	c=getchar();
	while ((c<48)||(c>57)) c=getchar();
	x=c^48;c=getchar();
	while ((c>=48)&&(c<=57))
	{
		x=x*10+(c^48);
		c=getchar();
	}
}
int getf(int x)
{
	if (f[x]==x) return x;
	return f[x]=getf(f[x]);
}
inline ll sj()
{
	js=rand();js<<=31;return js|rand();
}
inline void add(int x,int y,int z)
{
	lj[++bs]=y;
	bh[bs]=z;
	nxt[bs]=fir[x];
	fir[x]=bs;
	lj[++bs]=x;
	bh[bs]=z;
	nxt[bs]=fir[y];
	fir[y]=bs;
}
void dfs(int x)
{
	int i;
	for (i=fir[x];i;i=nxt[i]) if (lj[i]!=f[x])
	{
		f[lj[i]]=x;
		dfs(lj[i]);
		v[x]^=(val[bh[i]]=v[lj[i]]);
	}
}
int main()
{
	srand(383778817);
	read(n);read(m);
	for (i=1;i<=n;i++) f[i]=i;
	for (i=1;i<=m;i++)
	{
		read(x);read(y);
		if (getf(x)==getf(y)) {v[x]^=(val[i]=sj());v[y]^=val[i];}
		else {add(x,y,i);f[f[x]]=f[y];}
	}memset(f,0,sizeof(f));dfs(1);read(m);
	while (m--)
	{
		read(x);
		if (x==1) {read(y);if (val[y]) puts("Connected"); else puts("Disconnected");}
		else if (x==2) {read(y);read(z);if ((val[y])&&(val[y]^val[z])&&(val[z])) puts("Connected"); else puts("Disconnected");}
		else if (x==3) {read(y);read(z);read(i);if ((val[y])&&(val[z])&&(val[i])&&(val[y]^val[z])&&(val[z]^val[i])&&(val[y]^val[i])&&(val[y]^val[z]^val[i])) puts("Connected"); else puts("Disconnected");}
		else {read(x);read(y);read(z);read(i);if ((val[x])&&(val[y])&&(val[z])&&(val[i])&&(val[x]^val[y])&&(val[x]^val[z])&&(val[x]^val[i])&&(val[z]^val[y])&&(val[i]^val[y])&&(val[z]^val[i])&&(val[x]^val[y]^val[z])&&(val[x]^val[y]^val[i])&&(val[x]^val[i]^val[z])&&(val[i]^val[y]^val[z])&&(val[x]^val[y]^val[z]^val[i])) puts("Connected"); else puts("Disconnected");}
	}
}
```


---

## 作者：Calculatelove (赞：36)

## Description

给一个 $n$ 个点，$m$ 条边的无向图。

共 $k$ 次询问，每次询问给出一个边集。问：删去边集中的边后，改图是否为连通图。询问互相独立。

允许离线。

数据范围：$1 \leq n, k \leq 10^5$，$1 \leq m \leq 2 \times 10^5$，$1 \leq c \leq 4$。  
时空限制：$2000 \ \mathrm{ms} / 256 \ \mathrm{MiB}$

## Solution

任意删边显然是不好做的，我们还是考虑把删边转化为加边。

我们将询问的序列看成一个时间轴，我们会发现：每条边会在若干个时间区间内出现。

具体地，我们考虑任意一条边 $x$，设 $x$ 边被删除 $w$ 次，删除的位置分别是 $P_1,P_2,...,P_w$，那么我们可以视为：$x$ 边在时间区间 $[1,P_1-1],[P_1+1,P_2-1],...,[P_w+1,k]$ 中出现。

像这种 " 操作在若干个时间区间内有效 " 的问题，恰恰是线段树分治易于解决的。

离线处理出每条边被删除的位置，解决这个可以用 $m$ 个 `std::vector` 来解决。

对于每一条边，将其挂在 " 该边出现的时间区间对应的线段树节点 " 的 `std::vector` 上。

最后，我们跑一边整棵线段树，进行相应的操作。操作的过程我们可以使用 **" 可撤销并查集 "** 维护。为了不破坏并查集形态，优化选择使用 **" 按秩合并 "**。

再在并查集上维护一下 **" 当前连通块大小（$\mathrm{size}$）"**，对于任意加进去的边，若加边之后的连通块大小为 $n$，则说明当前图为连通图（否则还有 $n-\mathrm{size}$ 个节点不在当前连通块中）。

时间复杂度 $\mathcal{O}(kc \log k\log n)$，[评测链接](https://www.luogu.com.cn/record/31558132)。

## Code

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <stack>

#define RI register int

using namespace std;

namespace IO {
	static char buf[1 << 20], *fs, *ft;
	inline char gc() {
	    if (fs == ft) {
	        ft = (fs = buf) + fread(buf, 1, 1 << 20, stdin);
	
	        if (fs == ft)
	            return EOF;
	    }
	
	    return *fs++;
	}
	#define gc() getchar()
	inline int read() {
	    int x = 0, f = 1;
	    char s = gc();
	
	    while (s < '0' || s > '9') {
	        if (s == '-')
	            f = -f;
	
	        s = gc();
	    }
	
	    while (s >= '0' && s <= '9') {
	        x = x * 10 + s - '0';
	        s = gc();
	    }
	
	    return x * f;
	}
} using IO::read;

const int N = 100100, M = 200100;

int n, m;

int a[M], b[M];

int k;

vector<int> pos[M];

struct SegmentTree {
    int l, r;
    vector<int> e;
} t[N * 4];

void build(int p, int l, int r) {
    t[p].l = l, t[p].r = r;

    if (l == r)
        return;

    int mid = (l + r) / 2;
    build(p * 2, l, mid), build(p * 2 + 1, mid + 1, r);
}

void insert(int p, int l, int r, int x) {
    if (l <= t[p].l && t[p].r <= r) {
        t[p].e.push_back(x);
        return;
    }

    int mid = (t[p].l + t[p].r) / 2;

    if (l <= mid)
        insert(p * 2, l, r, x);

    if (mid < r)
        insert(p * 2 + 1, l, r, x);
}

int fa[N], size[N], d[N];

int get(int x) {
    while (fa[x] != x)
        x = fa[x];

    return x;
}

struct Node {
    int x, y, z;
    Node(int v1, int v2, int v3): x(v1), y(v2), z(v3) {}
};

stack<Node> s;

void solve(int x, bool flag) {
    int ori = s.size();

    for (RI i = 0; i < (int)t[x].e.size(); i++) {
        int u = a[t[x].e[i]], v = b[t[x].e[i]];
        int p = get(u), q = get(v);

        if (p == q)
            continue;

        if (d[p] < d[q])
            swap(p, q);

        s.push((Node){ q, d[p] == d[q], size[q] });

        fa[q] = p, d[p] += d[p] == d[q], size[p] += size[q];

        if (size[p] == n)
            flag = true;
    }

    if (t[x].l == t[x].r)
        puts(flag ? "Connected" : "Disconnected");
    else
        solve(x * 2, flag), solve(x * 2 + 1, flag);

    while (s.size() > ori) {
        Node res = s.top();
        s.pop();
        d[fa[res.x]] -= res.y, size[fa[res.x]] -= res.z, fa[res.x] = res.x;
    }
}

int main() {
    n = read(), m = read();

    for (RI i = 1; i <= m; i++)
        a[i] = read(), b[i] = read();

    k = read();

    for (RI i = 1; i <= m; i++)
        pos[i].push_back(0);

    for (RI i = 1; i <= k; i++)
        for (RI c = read(); c; c--)
            pos[read()].push_back(i);

    for (RI i = 1; i <= m; i++)
        pos[i].push_back(k + 1);

    build(1, 1, k);

    for (RI i = 1; i <= m; i++)
        for (RI j = 1; j < (int)pos[i].size(); j++)
            if (pos[i][j - 1] + 1 <= pos[i][j] - 1)
                insert(1, pos[i][j - 1] + 1, pos[i][j] - 1, i);

    for (RI i = 1; i <= n; i++)
        fa[i] = i, size[i] = 1, d[i] = 1;

    solve(1, false);

    return 0;
}
```

---

## 作者：gyh20 (赞：22)

线性空间做法，但之前的题解并没有给出完整的证明，这里借鉴 https://wuhongxun.blog.uoj.ac/blog/3003 中的证明，并稍微加一点细节。

先求出原图的一棵生成树，得到一些树边与非树边，令第 $i$ 条非树边的权值是 $2^i$，再令这条边的两个端点在树上的对应路径上的边全部 $\oplus 2^i$。

那么一个极小的割一定满足其中所有边的权值异或和为 $0$，问题转化为询问集合是否存在一个异或为 $0$ 的子集，可以用线性基简单解决。

证明分为两步，极小的割一定异或和为 $0$，异或和为 $0$ 一定为一个割。

首先，每一条非树边相当于给一个环 $\oplus$ 上 $2^i$，那么一个点的所有相连的边的 $\oplus$ 一定为 $0$，令一个点的权值为其相邻边的异或和。

假设这个割将图割成了 $A,B$ 两个点集（相当于割掉了所有 $A-B$ 的边），可以发现这个割的权值即为 $A$ 中所有点点权的异或和，很明显是 $0$。

现在证明异或和为 $0$ 一定为一个割。

假设不是一个割，那么对于询问中的树边，我们找到一条覆盖它的非树边来成为新的树边，在整个过程中边的权值保持不变，简单的分类讨论可以得出这样操作之后仍然满足一条树边的权值等于所有经过它的非树边的权值的异或和，且所有非树边的权值线性无关（由于异或操作始终是对基中的元素进行的）。

操作结束之后，所有的询问中的树边变成了非树边，但这些非树边权值线性无关，与异或和为 $0$ 矛盾。

综上，算法正确性得证，具体实现可以用随机权值代替 $2^i$。

```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
int n,m,head[100002],cnt,val[200002],d[200002],q,p[31];
char v[100002];
struct edge{int to,next,w;}e[400002];
inline void add(re int x,re int y,re int z){e[++cnt]=(edge){y,head[x],z},head[x]=cnt;}
inline void dfs(re int x,re int y){v[x]=1;
	for(re int i=head[x];i;i=e[i].next)
		if(!v[e[i].to])dfs(e[i].to,x),d[x]^=d[e[i].to],val[e[i].w]=d[e[i].to];
		else if(e[i].to^y&&!val[e[i].w])val[e[i].w]=rand(),d[x]^=val[e[i].w],d[e[i].to]^=val[e[i].w];
}
inline bool ins(re int x){
	for(re int i=30;~i;--i)
		if(x&(1<<i)){
			if(!p[i])return p[i]=x;
			x^=p[i];
		}return 0;
}
int main(){
	srand(20050816),scanf("%d%d",&n,&m);
	for(re int i=1,x,y;i<=m;++i)scanf("%d%d",&x,&y),add(x,y,i),add(y,x,i);
	dfs(1,1),scanf("%d",&q);
	while(q--){
		re int o,x,s=1;scanf("%d",&o),memset(p,0,sizeof(p));
		while(o--)scanf("%d",&x),s&=ins(val[x]);
		puts(s?"Connected":"Disconnected");
	}
}

```


---

## 作者：一扶苏一 (赞：10)

## Description

给定一个无向连通图和若干个小集合，每个小集合包含一些边，对于每个集合，你需要确定将集合中的边删掉后改图是否保持联通。集合间的询问相互独立

定义一个图为联通的当且仅当对于任意的两个顶点，都存在一条路径连接它们

## Input

第一行为两个整数 $n,m$，代表无向图的点数和边数

下面 $m$ 行，包含两个整数 $u,v$，代表该边连接点 $u,v$。第 $i + 1$ 行的边的编号为 $i$。保证不存在重边和自环

下面一行包含一个整数 $k$，表示集合个数

下面 $k$ 行每行描述一个集合，每行的第一个数为集合中边的个数 $c$，后面 $c$ 个数代表集合内的边

## Output

对于每个集合，输出一行代表去掉该集合中的边后图是否联通，如果联通输出 ``Connected``，否则输出 ``Disconnected``

## Hint

$1~\leq~n,k~\leq~10^5$

$1~\leq~m~\leq~2~\times~10^5$

$1~\leq~c~\leq~4$

## Solution

**这个分治方法叫做线段树分治，而不是cdq分治。**

我们考虑分治，设 $[l,r]$ 为区间 $[l,r]$ 中询问涉及边都没有被连上且其它边都连上时图是否联通，那么递归到底时即为一次询问的答案。

具体方法为先将没有被询问过的边连上。然后在递归区间 $[l,r]$ 时，将区间内 $[l,mid]$ 的询问中不涉及的边全部连上，递归处理左侧区间，然后撤销上次的连边，再将 $(mid, r]$ 中询问不涉及的边都连上，处理右边，回溯后再次撤销。在这个过程中用并查集维护一下联通块个数，在底部即可判断。存储需要撤销的操作可以用一个栈实现。

考虑时间复杂度：递归层数为 $O(\log k)$，于是每个询问被处理 $O(\log k)$ 次，对每个询问中的每条边，每被处理一次就会有一次并查集的删除和撤销操作，由于是按秩合并实现，单次操作复杂度 $O(\log n)$。所以单个询问的复杂度为 $O(c~\log n)$。共有 $k$ 个操作，于是总的时间复杂度为 $O(k~\times~c~\times~\log k~\log n)$。

这个分治和cdq分治的区别大概在于……此分治时 mid 两侧的区间是被 “平等对待” 的，即记录右边区间对左边区间的贡献，但是cdq分治不是。

另外上面做线段树分治的时候并没有将树显式的建出来，但他们在本质上是一样的。

另外还有一种神仙做法在[这里](https://www.cnblogs.com/bestFy/p/9401859.html)

## Code

```cpp
#include <cstdio>
#include <vector>
#ifdef ONLINE_JUDGE
#define freopen(a, b, c)
#endif

typedef long long int ll;

namespace IPT {
	const int L = 1000000;
	char buf[L], *front=buf, *end=buf;
	char GetChar() {
		if (front == end) {
			end = buf + fread(front = buf, 1, L, stdin);
			if (front == end) return -1;
		}
		return *(front++);
	}
}

template <typename T>
inline void qr(T &x) {
	char ch = IPT::GetChar(), lst = ' ';
	while ((ch > '9') || (ch < '0')) lst = ch, ch=IPT::GetChar();
	while ((ch >= '0') && (ch <= '9')) x = (x << 1) + (x << 3) + (ch ^ 48), ch = IPT::GetChar();
	if (lst == '-') x = -x;
}

namespace OPT {
	char buf[120];
}

template <typename T>
inline void qw(T x, const char aft, const bool pt) {
	if (x < 0) {x = -x, putchar('-');}
	int top=0;
	do {OPT::buf[++top] = static_cast<char>(x % 10 + '0');} while (x /= 10);
	while (top) putchar(OPT::buf[top--]);
	if (pt) putchar(aft);
}

const int maxn = 100010;
const int maxm = 200010;

struct Edge {
	int from, to;
};
Edge edge[maxm];

struct Ask {
	int c;
	int mu[5];
};
Ask ask[maxn];

struct OP {
	int a, b, p;
};
OP stack[maxm * 20];

int n, m, k, cnt, top;
int ufs[maxn], rk[maxn];
bool vis[maxm];

void reset();
int find(int);
void cont(int, bool);
void unionn(int, int, bool);
void work(int, int, std::vector<int>&);
void divide(int, int, std::vector<int>&);

int main() {
	freopen("1.in", "r", stdin);
	qr(n); qr(m); cnt = n;
	for (int i = 1; i <= m; ++i) {
		qr(edge[i].from); qr(edge[i].to);
	}
	qr(k);
	for (int i = 1; i <= k; ++i) {
		qr(ask[i].c);
		for (int j = 1; j <= ask[i].c; ++j) {qr(ask[i].mu[j]); vis[ask[i].mu[j]] = true;}
	}
	for (int i = 1; i <= n; ++i) ufs[i] = i, rk[i] = 1;
	std::vector<int>dn;
	for (int i = 1; i <= m; ++i) 
		if (!vis[i]) cont(i, false);
		else dn.push_back(i);
	work(1, k, dn);
	return 0;
}

void work(int l, int r, std::vector<int>&e) {
	for (int i = l; i <= r; ++i) {
		for (int j = 1; j <= ask[i].c; ++j) vis[ask[i].mu[j]] = true;
	}
	std::vector<int>dn;
	int _tp = top;
	for (int i = 0, len = e.size(); i < len; ++i) {
		if (!vis[i]) cont(i, true);
		else dn.push_back(i);
	}
	for (int i = l; i <= r; ++i) {
		for (int j = 1; j <= ask[i].c; ++j) vis[ask[i].mu[j]] = false;
	}
	divide(l, r, dn);
	while (top != _tp) reset();
}

void divide(int l, int r, std::vector<int>&e) {
	if (l == r) {
		puts(cnt == 1 ? "Connected" : "Disconnected");
		return;
	}
	int mid = (l + r) >> 1;
	work(l, mid, e);
	work(mid + 1, r, e);
}

int find(int x) {return ufs[x] == x ? x : find(ufs[x]);}

void cont(int x, bool rec) {
	int fa = find(edge[x].from), fb = find(edge[x].to);
	if (fa != fb) {
		unionn(fa, fb, rec);
		--cnt;
	}
}

void unionn(int a, int b, bool rec) {
	int c;
	if (rk[a] < rk[b]) {c = 1; ufs[a] = b;}
	else if (rk[a] > rk[b]) {c = 2; ufs[b] = a;}
	else {c = 3; ufs[b] = a; ++rk[a];}
	if (rec) stack[++top] = {a, b, c};
}

void reset() {
	int a = stack[top].a, b = stack[top].b, p = stack[top--].p;
	switch (p) {
		case 1:
			ufs[a] = a; break;
		case 2:
			ufs[b] = b; break;
		case 3:
			ufs[b] = b; --rk[a]; break;
	}
	++cnt;
}
```









---

## 作者：Genius_Z (赞：7)

这里给出一种常数巨大，码量5k的丑陋算法：大力$LCT$

复杂度是$\Theta(nlogn)$（实际上比我自己写的线段树分治加按秩合并并查集总时间慢10s）

做法是用LCT维护按删除时间为权值的最大生成树

正确性显然，但是常数巨大

我们离线来得到每条边的删除时间

在$LCT$里维护权值最小的边的编号

判断图是否连通就$access$加上$splay$任意一个点来判断它的$size$是否为$n$

维护$size$需要用到虚子树的$trick$，注意每次$link$和$access$的时候要更新虚子树

这里给出线段树分治和$LCT$两种做法的$code$，线段树分治的做法之前的大佬已经讲的很明白了，我就不再啰嗦了

如果有什么不清楚的可以在评论区留言

线段树分治：

```cpp
#include <set>
#include <map>
#include <cmath>
#include <queue>
#include <stack>
#include <tuple>
#include <bitset>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#define inl inline
#define re register int
#define fa(x) t[x].fa
#define ls(x) t[x].child[0]
#define rs(x) t[x].child[1]
#define ll long long
const int inf = 0x7fffffff;
#define lowbit(x) ((x) & (-x))
using namespace std;
#ifndef _DEBUG
#define getchar() (*(IOB.in.p++))
#define putchar(c) (*(IOB.out.p++)=(c))
#define io_eof() (IOB.in.p>=IOB.in.pend)
struct IOBUF { struct { char buff[1 << 27], *p, *pend; }in; struct { char buff[1 << 27], *p; }out; IOBUF() { in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 << 27, stdin); }~IOBUF() { fwrite(out.buff, 1, out.p - out.buff, stdout); } }IOB;
#endif
template<typename IO>
inl void write(IO x) {
    if (x == 0) return (void)putchar('0');
    if (x < 0)putchar('-'), x = -x;
    static char buf[30];
    char* p = buf;
    while (x) {
        *(p++) = x % 10 + '0';
        x /= 10;
    }
    while (p > buf)putchar(*(--p));
}
inl void writestr(const char *s) { while (*s != 0)putchar(*(s++)); }
template<typename IO>inl void writeln(IO x) { write(x), putchar('\n'); }
template<typename IO>inl void writesp(IO x) { write(x), putchar(' '); }
inl int readstr(char *s) {
    char *begin = s, c;
    while (1) {
        c = getchar();
        if (c < 33 || c>127)break;
        *(s++) = c;
    }
    *s = 0;
    return s - begin;
}
template<typename IO>
inl IO read() {
    IO x = 0;
    register bool w = 0;
    register char c = getchar();
    while (c > '9' || c < '0') {
        if (c == '-') w = 1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        x = (x << 3) + (x << 1) + (c ^ 48);
        c = getchar();
    }
    return w ? -x : x;
}
int n, m, pre[1000001];
bool ans[1000001];
vector<int>ve[1000001];
struct edge {
    int u, v;
}e[1000001];
struct quiz {
    int st, ed, id;
}q[10000001];
struct dsu {
    int st[1000001], top, siz[1000001], fa[1000001];
    inl void init() { for (re i = 1; i <= n; i++)siz[i] = 1; }
    inl int find(int x) { return fa[x] ? find(fa[x]) : x; }
    inl void link(int x, int y) {
        st[++top] = 0;
        re fx = find(x), fy = find(y);
        if (fx == fy)return;
        if (siz[fx] > siz[fy])swap(x, y), swap(fx, fy);
        fa[fx] = fy, siz[fy] += siz[fx];
        st[top] = fx;
    }
    inl void cut() {
        if (!st[top]) {
            top--; return;
        }
        siz[fa[st[top]]] -= siz[st[top]];
        fa[st[top--]] = 0;
    }
    inl bool query() { return siz[find(1)] == n; }
}s;//按秩合并的并查集
inl void insert(int k, int l, int r, int x, int y, int w) {
    if (l >= x && r <= y) {
        ve[k].push_back(w);
        return;
    }
    re mid = l + r >> 1;
    if (x <= mid)insert(k << 1, l, mid, x, y, w);
    if (y > mid)insert(k << 1 | 1, mid + 1, r, x, y, w);
}
inl void query(int k, int l, int r) {
    if (l > r)return;
    for (auto i : ve[k]) s.link(e[i].u, e[i].v);
    if (l == r)ans[l] = s.query();
    else {
        re mid = l + r >> 1;
        query(k << 1, l, mid), query(k << 1 | 1, mid + 1, r);
    }
    re siz = ve[k].size();
    while (siz--)s.cut();
}//线段树合并
signed main() {
    n = read<int>(), m = read<int>();
    s.init();
    for (re i = 1; i <= m; i++) {
        re x = read<int>(), y = read<int>();
        e[i] = edge{ x,y }, pre[i] = 1;
    }
    re tot = 0, k = read<int>();
    for (re i = 1; i <= k; i++) {
        re a = read<int>();
        for (re j = 1; j <= a; j++) {
            re x = read<int>();
            if (pre[x] <= i - 1)q[++tot] = quiz{ pre[x],i - 1,x };
            pre[x] = i + 1;
        }
    }
    for (re i = 1; i <= m; i++) {
        if (pre[i] != k + 1) {
            q[++tot] = quiz{ pre[i],k,i };
        }
    }
    for (re i = 1; i <= tot; i++) {
        insert(1, 1, k, q[i].st, q[i].ed, q[i].id);
    }
    query(1, 1, k);
    for (re i = 1; i <= k; i++)writestr(ans[i] ? "Connected\n" : "Disconnected\n");
}
```

$LCT$：

```cpp
#include <set>
#include <map>
#include <cmath>
#include <queue>
#include <stack>
#include <tuple>
#include <bitset>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#define inl inline
#define re register int
#define fa(x) t[x].fa
#define ls(x) t[x].child[0]
#define rs(x) t[x].child[1]
#define ll long long
const int inf = 0x7fffffff;
#define lowbit(x) ((x) & (-x))
using namespace std;
#ifndef _DEBUG
#define getchar() (*(IOB.in.p++))
#define putchar(c) (*(IOB.out.p++)=(c))
#define io_eof() (IOB.in.p>=IOB.in.pend)
struct IOBUF { struct { char buff[1 << 26], *p, *pend; }in; struct { char buff[1 << 26], *p; }out; IOBUF() { in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 << 26, stdin); }~IOBUF() { fwrite(out.buff, 1, out.p - out.buff, stdout); } }IOB;
#endif
template<typename IO>
inl void write(IO x) {
	if (x == 0) return (void)putchar('0');
	if (x < 0)putchar('-'), x = -x;
	static char buf[30];
	char* p = buf;
	while (x) {
		*(p++) = x % 10 + '0';
		x /= 10;
	}
	while (p > buf)putchar(*(--p));
}
inl void writestr(const char *s) { while (*s != 0)putchar(*(s++)); }
template<typename IO>inl void writeln(IO x) { write(x), putchar('\n'); }
template<typename IO>inl void writesp(IO x) { write(x), putchar(' '); }
inl int readstr(char *s) {
	char *begin = s, c;
	while (1) {
		c = getchar();
		if (c < 33 || c>127)break;
		*(s++) = c;
	}
	*s = 0;
	return s - begin;
}
template<typename IO>
inl IO read() {
	IO x = 0;
	register bool w = 0;
	register char c = getchar();
	while (c > '9' || c < '0') {
		if (c == '-') w = 1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return w ? -x : x;
}
int n, m;
struct node {
	int w, min, size, fa, child[2], vir;
	bool filp;
}t[10000001];
inl void maintain(int x) {
	t[x].size = t[ls(x)].size + t[rs(x)].size + t[x].vir + (x <= n);
	if (x > n)t[x].min = x;
	if (t[x].w >= t[t[ls(x)].min].w)t[x].min = t[ls(x)].min;
	if (t[t[x].min].w >= t[t[rs(x)].min].w)t[x].min = t[rs(x)].min;
}//vir是虚子树的size和
inl bool poi(int x) {
	return rs(fa(x)) == x;
}
inl bool nroot(int x) {
	return ls(fa(x)) == x || rs(fa(x)) == x;
}
inl void rotate(int x) {
	re f = fa(x), gf = fa(f), fs = poi(x), gfs = poi(f), s = t[x].child[fs ^ 1];
	if (nroot(f))t[gf].child[gfs] = x;
	t[f].child[fs] = s, t[x].child[fs ^ 1] = f;
	if (s)fa(s) = f;
	fa(x) = gf, fa(f) = x;
	maintain(f);
}
inl void reverse(int x) {
	swap(ls(x), rs(x)), t[x].filp ^= 1;
}
inl void pushdown(int x) {
	if (t[x].filp) {
		if (ls(x))reverse(ls(x));
		if (rs(x))reverse(rs(x));
		t[x].filp = 0;
	}
}
inl void push(int x) {
	if (nroot(x))push(fa(x));
	pushdown(x);
}
inl void splay(int x) {
	push(x);
	while (nroot(x)) {
		if (nroot(fa(x)))poi(x) == poi(fa(x)) ? rotate(fa(x)) : rotate(x);
		rotate(x);
	}
	maintain(x);
}
inl void access(int x) {
	for (re i = 0; x; x = fa(i = x)) {
		splay(x), t[x].vir += t[rs(x)].size, t[x].vir -= t[rs(x) = i].size, maintain(x);
	}
}
inl void makeroot(int x) {
	access(x), splay(x), reverse(x);
}
inl void split(int x, int y) {
	makeroot(y), access(x), splay(x);
}
inl void link(int x, int y) {
	split(x, y), fa(y) = x, t[x].vir += t[y].size, maintain(x);
}
inl void cut(int x, int y) {
	split(x, y);
	fa(y) = ls(x) = 0, maintain(x);
}
inl int findroot(int x) {
	access(x), splay(x), pushdown(x);
	while (ls(x))pushdown(x = ls(x));
	splay(x); return x;
}
inl bool query() {
	access(1), splay(1);
	return t[1].size == n;
}
struct edge {
	int u, v, w;
}e[10000001];
struct quiz {
	bool op, flag;
	int i, tim;
}q[10000001];
int now[10000001], num, ans[10000001], st[1000001], top;
signed main() {
	n = read<int>(), m = read<int>();
	for (re i = 0; i <= n; i++)t[i].w = inf;
	for (re i = 1; i <= m; i++) {
		re x = read<int>(), y = read<int>();
		e[i] = edge{ x,y }, now[i] = i;
		q[++num] = quiz{ 1,0,i,0 };
	}//op为0表示删除(cut)，为1表示加入(link),flag表示是否为询问
	re k = read<int>(), a, tot = m;
	for (re i = 1; i <= k; i++) {
		a = read<int>();
		for (re j = 1; j <= a; j++) {
			re x = read<int>();
			e[now[x]].w = i - 1;
			t[now[x] + n].w = i - 1;
			q[++num] = quiz{ 0,0,now[x],i };
			e[++tot].u = e[now[x]].u, e[tot].v = e[now[x]].v, now[x] = tot;
			st[++top] = now[x];
		}
		q[++num].flag = 1;
		if (i != k) {
			while (top) {
				q[++num] = quiz{ 1,0,st[top--],i };
			}
		}
	}
	for (re i = 1; i <= m; i++) {
		if (!e[now[i]].w) {
			e[now[i]].w = k;
			t[now[i] + n].w = k;
		}
	}
	tot += n;
	for (re i = 1; i <= tot; i++) {
		t[i].size = 1;
	}//初始化
	for (re i = 1; i <= num; i++) {//维护最大生成树
		if (q[i].flag) {
			writestr(query() ? "Connected\n" : "Disconnected\n");
		}
		else {
			re j = q[i].i, u = e[j].u, v = e[j].v, w = e[j].w;
			makeroot(u);
			if (q[i].op) {
				if (findroot(v) == u) {
					re minn = t[u].min;
					if (t[minn].w >= w)continue;
					cut(e[minn - n].u, minn), cut(e[minn - n].v, minn);
				}
				link(u, j + n), link(v, j + n);
			}
			else {
				if (findroot(v) == u) {
					maintain(j + n);
					if (!t[j + n].fa && !t[j + n].size)continue;
					cut(e[j].u, j + n), cut(e[j].v, j + n);
				}
			}
		}
	}
}
```



---

## 作者：Fido_Puppy (赞：6)

$$\texttt{Description}$$

[P5227 [AHOI2013]连通图](https://www.luogu.com.cn/problem/P5227)

$$\texttt{Solution}$$

我们看到题目要求把集合中的边删掉，所以可以想到**线段树分治**，判断图是否联通，就可以用**并查集**判断。

线段树分治维护的是一条**时间轴**，对于每一个时间点出现的边，我们可以把边的编号挂到对应的时间节点上，具体可以用 **vector** 记录。

接着我们搜索整棵线段树，遇到标记着的边就把它加入到并查集中，当这棵子树遍历完之后就要从并查集中撤销此次操作，就不会影响到其他时间节点。

所以我们需要用**可撤销并查集**，具体就是在加入一条边前用一个栈把并查集中的信息记录一下，撤销时只需把信息从栈中弹出即可。

因为不能够破坏并查集中的树形结构，我们采用**按秩合并**的方式优化并查集。

搜索到叶子节点之后就可以判断并且记录答案，具体可以记录并查集中一个联通块的大小，任意选择一个联通块查询，如果大小等于 $n$，则图联通，否则图不联通。

因为并查集是用按秩合并优化的，所以时间复杂度为 $\Theta (n \log^2 n)$。

$$\texttt{Code}$$

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 2e5 + 10;

int n, m, A[MAXN], B[MAXN], f[MAXN], siz[MAXN], dep[MAXN], k;

vector <int> disappear[MAXN];

bool connected[MAXN];

inline int find(int x) {
	if (f[x] != x) return find(f[x]);
	else return x;
}

struct Node {
	int l, r;
	vector <int> q;
}t[ MAXN << 2 ];

struct Information {
	int fx, fy, depfx, depfy, sizfx, sizfy;
	bool Union;
};

stack <Information> undo;

inline void build(int p, int l, int r) {
	t[p].q.clear(); t[p].l = l; t[p].r = r;
	if (l == r) return ;
	int mid = l + r >> 1;
	build(p << 1, l, mid); build(p << 1 | 1, mid + 1, r);
}

inline void update(int p, int x, int y, int Q) {
	if (t[p].l >= x && t[p].r <= y) {
		t[p].q.emplace_back(Q);
		return ;
	}
	int mid = t[p].l + t[p].r >> 1;
	if (x <= mid) update(p << 1, x, y, Q);
	if (mid < y) update(p << 1 | 1, x, y, Q);
}

inline void dfs(int p) {
	// Add
	for (auto i : t[p].q) {
		int fx = find(A[i]), fy = find(B[i]);
		if (fx != fy) {
			if (dep[fx] > dep[fy]) swap(fx, fy);
			undo.push((Information){fx, fy, dep[fx], dep[fy], siz[fx], siz[fy], true});
			if (dep[fx] == dep[fy]) dep[fy]++;
			f[fx] = fy;
			siz[fy] += siz[fx];
		}
		else {
			undo.push((Information){0, 0, 0, 0, 0, 0, false});
		}
	}
	if (t[p].l == t[p].r) {
		if (siz[ find(1) ] == n) connected[ t[p].l ] = true;
		else connected[ t[p].l ] = false;
	}
	else {
		dfs(p << 1); dfs(p << 1 | 1);
	}
	// Undo
	for (int i = 0; i < t[p].q.size(); i++) {
		Information T = undo.top(); undo.pop();
		if (T.Union == true) {
			f[ T.fx ] = T.fx; f[ T.fy ] = T.fy;
			dep[ T.fx ] = T.depfx;
			dep[ T.fy ] = T.depfy;
			siz[ T.fx ] = T.sizfx;
			siz[ T.fy ] = T.sizfy;
		}
	}
}

int main() {
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	
	cin >> n >> m;
	for (int i = 1; i <= m; i++) cin >> A[i] >> B[i];
	
	for (int i = 1; i <= n; i++) f[i] = i, siz[i] = dep[i] = 1;
	
	cin >> k;
	build(1, 1, k);
	for (int i = 1; i <= k; i++) {
		int c; cin >> c;
		for (int j = 1; j <= c; j++) {
			int x; cin >> x; disappear[x].emplace_back(i);
		}
	}
	
	for (int i = 1; i <= m; i++) {
		int last = 0;
		for (auto v : disappear[i]) {
			if (last + 1 <= v - 1) update(1, last + 1, v - 1, i);
			last = v;
		}
		if (last + 1 <= k) update(1, last + 1, k, i);
	}
	
	dfs(1);
	
	for (int i = 1; i <= k; i++)
		if (connected[i]) cout << "Connected" << endl; else cout << "Disconnected" << endl;
	
	return 0;
}
```


$$\texttt{Thanks for watching!}$$

---

## 作者：GoldenPotato137 (赞：4)

[戳我获得更好的阅读体验qwq](https://www.goldenpotato.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/luogu-p5227-ahoi2013-%E8%BF%9E%E9%80%9A%E5%9B%BE/)

---
# Solution
这题可以离线，因此我们可以考虑用线段树分治维护动态图连通性来搞。

这题我们考虑离线下来搞。离线之后，我们会发现，**某条边会在某些询问区间中出现。**

考虑**以询问的编号为下标建线段树，我们把每一条边出现的时间段全部加到线段树里面去。**

接下来，直接**在线段树上跑dfs**,每到一个区间，就把这个区间里面存的边通通在并查集中连上；每完成一个区间，就把这个区间连上的边通通取消（类似于回溯）。

这样搞，我们每次到一个叶子节点的时候，这个叶子节点代表的询问上所要连的边一定已经全部连上了，直接在并查集中查询任意节点的父亲的$size$是否为$n$即可。

因为我们这里有撤销（回溯）操作，因此必需使用**按秩合并的并查集。我们只需要开一个栈，把每次修改的fa的节点记录下来即可完成撤销的操作。

.

时间复杂度$O(nlog^2n)$ 吗？

问题是这玩意能过啊.....

~~因此，我们的时间复杂度是$O($能过$)$~~

就酱，我们又切掉一道题啦。(ﾉﾟ∀ﾟ)ﾉ 

---
# Code
```cpp
//Luogu P5227 [AHOI2013]连通图
//Mar,22ed,2019
//线段树分治离线维护动态图连通性
#include<iostream>
#include<cstdio>
#include<vector>
#include<ctime>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=100000+100;
const int M=200000+100;
int n,m,q,p,ans[M];
struct UnF
{	
	int size[N],fa[N],mstack[M],top;
	void Init()
	{
		for(int i=1;i<=n;i++)
			size[i]=1;
	}
	int FindFather(int x)
	{
		if(fa[x]==0) return x;
		return FindFather(fa[x]);
	}
	void Link(int x,int y)
	{
		mstack[++top]=0;
		int fa_x=FindFather(x),fa_y=FindFather(y);
		if(size[fa_x]>size[fa_y]) 
			swap(x,y),swap(fa_x,fa_y);
		if(fa_x==fa_y) return;
		mstack[top]=fa_x;	
		fa[fa_x]=fa_y,size[fa_y]+=size[fa_x];
	}
	int Query()
	{
		if(size[FindFather(1)]==n) return true;
		return false;
	}
	void Undo()
	{
		if(mstack[top]==0)
		{
			top--;
			return;
		}
		size[fa[mstack[top]]]-=size[mstack[top]];
		fa[mstack[top]]=0;
		top--;
	}
}unf;
struct OP
{
	int s,t,id;
}op2[M*20],e[M];
struct SegmentTree
{
	#define mid ((now_l+now_r)>>1)
	#define lson (now<<1)
	#define rson (now<<1|1)
	vector <int> w[M<<2];
	void Insert(int l,int r,int x,int now,int now_l,int now_r)
	{
		if(now_l>=l and now_r<=r)
		{
			w[now].push_back(x);
			return;
		}
		if(l<=mid) Insert(l,r,x,lson,now_l,mid);
		if(r>mid) Insert(l,r,x,rson,mid+1,now_r);
	}
	void dfs(int now,int now_l,int now_r)
	{
		if(now_l>now_r) return;
		for(int i=0;i<int(w[now].size());i++)
			unf.Link(e[w[now][i]].s,e[w[now][i]].t);
		if(now_l==now_r)
			ans[now_l]=unf.Query();
		else
		{
			dfs(lson,now_l,mid);
			dfs(rson,mid+1,now_r);
		}
		for(int i=0;i<int(w[now].size());i++)
			unf.Undo();
	}
	#undef mid
	#undef lson
	#undef rson
}sgt;
int last[M],K;
int main()
{
	n=read(),m=read();
	for(int i=1;i<=m;i++)
		e[i].s=read(),e[i].t=read(),last[i]=1;
	K=read();
	for(int i=1;i<=K;i++)
	{
		int c=read();
		for(int j=1;j<=c;j++)
		{
			int x=read();
			op2[++p].s=last[x],op2[p].t=i-1,op2[p].id=x;
			last[x]=i+1;
		}
	}
	for(int i=1;i<=m;i++)
		if(last[i]!=K+1)
			op2[++p].s=last[i],op2[p].t=K,op2[p].id=i;
			
	for(int i=1;i<=p;i++)
		if(op2[i].s<=op2[i].t)
		{
			sgt.Insert(op2[i].s,op2[i].t,op2[i].id,1,1,K);
			//cerr<<op2[i].s<<" "<<op2[i].t<<" "<<op2[i].id<<endl;
		}
		
	unf.Init();
	sgt.dfs(1,1,K);
	
	for(int i=1;i<=K;i++)
		if(ans[i]==0)
			printf("Disconnected\n");
		else
			printf("Connected\n");
	return 0;
}

```






---

## 作者：CrTsIr400 (赞：4)

# [P5227 [AHOI2013] 连通图](https://www.luogu.com.cn/problem/P5227) 题解

这个题可以直接线段树分治做。

它的思想是加上该段区间中**没有的边**。

加边操作可以用可撤销并查集实现。

有的那些边可以用个 `vector` 存，这样每次可以算出不再出现过的边，于是我们就优雅地解决了这个问题。

代码很显然，下面的题解都讲了，所以不放了。

---

还有高手？

考虑一个巧妙的套路：我们给这张图精细赋权，使得**若删掉一些异或值恰好等于 $0$ 的边集**，这张图恰好不连通。

理想很丰满，现实很骨感：首先需要暴力枚举边集来判断连通性。不过待判定的边集比较小，暴力枚举是没问题的。

主要麻烦在于构造。我们需要构造一张图，满足这个性质。

首先，一个很显然的性质就是，这个图必须满足一个点的所有出边异或值必为 $0$。

然后，我们发现，对于任意一个**子图**，如果**恰好与外部的点不连通**了，且子集中**每个点出边异或和**都是 $0$，那么那些被割掉的边异或和也为 $0$；

证明：考虑子图内部边的关系，一条边会被异或两次。因此子集内部所有边的异或和均为 $0$。

所以，子集所有出边的异或和均为 $0$。

---

观察到这个限制依旧是“又紧又松”：限制紧在每个点刚好满足条件，松在这里的边权选择极为自由，我们甚至可以开到 `ULL` 值域。

发现这只是一个简略的“判定性问题”，而且连通性问题是有比较多的试错可能的。

于是考虑，钦定 $1$ 号点不满足条件，但是要求所有其他节点都必须满足条件。

因为不连通之后，即使 $1$ 号节点的那个连通块不满足条件，别的连通块也能够满足异或值等于 $0$ 这一条件。

一个节点特例，想到了什么？我们想到了树形结构。

---

于是接下来就到了喜闻乐见的~~乱搞~~构造环节。

任意取这张图以 $1$ 为根的生成树，我们这样给边权赋值：

+ 若是非树边，则随机赋一个 $[1,2^{64})$ 的值；
+ 若是树边，则需要赋一个值，使得这个点它所有出边异或和为 $0$。

观察到 $1$ 不满足性质，不过前面已经说了，没有大问题。

具体看代码：

```cpp
bool v[N];LL z[M],a[N];
mt19937_64 rd(time(0));
V dfs(I x,I fa=0){v[x]=1;
	for(I _i=hd[x],y;y=ey[_i];a[x]^=z[_i>>1],_i=nx[_i])if(y!=fa){
		if(v[y]&&!z[_i>>1])z[_i>>1]=rd()+1;
		else if(!v[y])dfs(y,x),z[_i>>1]=a[y];}}
```

---

异或值恰好等于 $0$ 只是这张图恰好不连通的**必要条件**，我们能证明它的**充分性**吗？

答案是：不能。

诶？为啥这个乱搞做法能过？这不科学！

思考反例：假设只抽一条边权，这条边不是关键边，抽到恰好是 $0$ 的概率是多少：$\dfrac{1}{2^{64}}$。

那么抽一堆不是关键边的边，抽到的异或和为 $0$ 的概率更是小到离谱。

所以我们就用随机构造过了这个题。

---

```cpp
#include<bits/stdc++.h>
#define fo(i,a,b) for(I i(a),_ed(b);i<=_ed;++i)
using namespace std;using I=int;using LL=unsigned long long;using V=void;
const I M=4e5+10,N=1e5+10;
I ec=1,n,m,ey[M],nx[M],hd[N],x[M],y[M],q,id[4];
V conn(I x,I y){ey[++ec]=y;nx[ec]=hd[x];hd[x]=ec;}
bool v[N];LL z[M],a[N];
mt19937_64 rd(time(0));
V dfs(I x,I fa=0){v[x]=1;
	for(I _i=hd[x],y;y=ey[_i];a[x]^=z[_i>>1],_i=nx[_i])if(y!=fa){
		if(v[y]&&!z[_i>>1])z[_i>>1]=rd()+1;
		else if(!v[y])dfs(y,x),z[_i>>1]=a[y];}}
bool pd(I k){LL vi;
	fo(s,1,(1<<k)-1){vi=0;
		fo(i,0,k-1)if(s&(1<<i))vi^=z[id[i]];
		if(vi==0)return 0;}
	return 1;}
I main(){ios::sync_with_stdio(0);cin.tie(0);
	cin>>n>>m;
	fo(i,1,m){cin>>x[i]>>y[i];conn(x[i],y[i]);conn(y[i],x[i]);}
	dfs(1);cin>>q;
	while(q--){I k;cin>>k;
		fo(i,0,k-1)cin>>id[i];
		puts(pd(k)?"Connected":"Disconnected");}
	return 0;}
```

后记：其实这几个数对应的权值，还可以插入线性基里面，若都能插入，则异或值不为 $0$。

这样就不需要 $2^k$ 的时间复杂度，取而代之就是 $O(64mk)$ 的复杂度了。不过没有必要。

---

## 作者：mrsrz (赞：4)

离线之后分治。

删边维护连通性比较难做到，考虑转化成加边操作。

先把没出现在询问中的边加进来，用并查集维护连通性，同时记录连通块个数。

然后分治询问，分成A和B两块。

我们考虑先求出A部分的答案，则把出现在B中但没出现在A中的边加入，然后递归解决A的问题。之后复原并查集，把把出现在A中但没出现在B中的边加入，递归解决B的问题。最后再复原并查集即可。

考虑如何复原并查集。

我们开一个栈，每次一个节点的父亲变了，就把当前信息压入栈里。复原的时候再依次弹出栈即可恢复信息。复原总复杂度和并查集是一样的。

### UPD：

发现这样用并查集复杂度有点假，会证的可以告诉窝呀QAQ

反正能过QAQ

## Code：
```cpp
#include<cstdio>
#include<utility>
typedef std::pair<int,int>PII;
const int N=100005;
int n,m,q;
PII e[N<<1];
int c[N][4],g[N],tot[N<<1],ans[N],C,fa[N],top=0;
std::pair<int,int>sta[N*60];
int find(int x){
	if(x==fa[x])return x;
	sta[++top]=std::make_pair(x,fa[x]);return fa[x]=find(fa[x]);
}
void solve(int l,int r){
	if(l==r)ans[l]=C==1;else{
		const int preC=C,mid=l+r>>1;
		int head=top;
		for(int i=mid+1;i<=r;++i)
		for(int j=g[i]-1;~j;--j){
			const int v=c[i][j];
			if(!--tot[v]){
				int x=find(e[v].first),y=find(e[v].second);
				if(x!=y){
					--C;
					sta[++top]=std::make_pair(x,fa[x]);
					fa[x]=y;
				}
			}
		}
		solve(l,mid);
		for(int i=mid+1;i<=r;++i)
		for(int j=g[i]-1;~j;--j)++tot[c[i][j]]; 
		C=preC;
		while(top!=head){
			const PII a=sta[top--];
			fa[a.first]=a.second;
		}
		for(int i=l;i<=mid;++i)
		for(int j=g[i]-1;~j;--j){
			const int v=c[i][j];
			if(!--tot[v]){
				int x=find(e[v].first),y=find(e[v].second);
				if(x!=y){
					--C;
					sta[++top]=std::make_pair(x,fa[x]);
					fa[x]=y;
				}
			}
		}
		solve(mid+1,r);
		for(int i=l;i<=mid;++i)
		for(int j=g[i]-1;~j;--j)++tot[c[i][j]]; 
		C=preC;
		while(top!=head){
			const PII a=sta[top--];
			fa[a.first]=a.second;
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	C=n;
	for(int i=1;i<=n;++i)fa[i]=i;
	for(int i=1;i<=m;++i)scanf("%d%d",&e[i].first,&e[i].second);
	scanf("%d",&q);
	for(int i=1;i<=q;++i){
		scanf("%d",&g[i]);
		for(int j=0;j<g[i];++j)scanf("%d",&c[i][j]),++tot[c[i][j]];
	}
	for(int i=1;i<=m;++i)if(!tot[i]){
		int u=find(e[i].first),v=find(e[i].second);
		if(u!=v)--C,fa[v]=u;
	}
	top=0;
	solve(1,q);
	for(int i=1;i<=q;++i)puts(ans[i]?"Connected":"Disconnected");
	return 0;
}
```

---

## 作者：huayucaiji (赞：3)

线段树分治板子。这种动态图的问题看都不要看，大概率可以用线段树分治。

我们有一堆的集合，每次把这个集合的边删掉，问你每个时刻的连通性。

我们只需要把这个时刻删去的集合里的边删掉，也就是这个区间不用加这条边，按常规把边扔到线段树上，遍历一下，每个点的连通性就出来了。

拿样例举个例子：

```plain
4 5
1 2
2 3
3 4
4 1
2 4
3
1 5
2 2 3
2 1 2
```

- 那么 $1$ 号边在线段树上挂到 $[1,2]$ 区间上。
- 那么 $2$ 号边在线段树上挂到 $[1,1]$ 区间上。
- 那么 $3$ 号边在线段树上挂到 $[1,1],[3,3]$ 区间上。
- 那么 $4$ 号边在线段树上挂到 $[1,3]$ 区间上。
- 那么 $5$ 号边在线段树上挂到 $[2,3]$ 区间上。

遍历即可。

```cpp
//Don't act like a loser.
//This code is written by huayucaiji
//You can only use the code for studying or finding mistakes
//Or,you'll be punished by Sakyamuni!!!
#include<bits/stdc++.h>
#define int long long
#define pr pair<int,int>
using namespace std;

int read() {
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}

const int MAXN=4e5+10,MAXQ=2e5+10;

int n,m,q,cnt,num;
stack<pr > stk;
int size[MAXN],father[MAXN],a[MAXN],ans[MAXQ];
vector<int > edge[MAXQ<<2];
pr e[MAXN];

pr make_edge(int x,int y) {
	return make_pair(min(x,y),max(x,y));
}
int find(int x) {
	if(x!=father[x]) {
		return find(father[x]);
	}
	return x;
}
void merge(pr s) {
	int x=find(s.first);
	int y=find(s.second);
	if(x==y) {
		stk.push(make_pair(-1,-1));
		return ;
	}
	num--;
	if(size[x]>size[y]) {
		swap(x,y);
	}
	father[x]=y;
	size[y]+=size[x];
	stk.push(make_pair(x,y));
}
void del() {
	int x=stk.top().first;
	int y=stk.top().second;
	stk.pop();
	if(x==-1) {
		return ;
	}
	num++;
	father[x]=x;
	size[y]-=size[x];
}

void modify(int l,int r,int p,int x,int y,int s) {
	if(x>y||r<x||y<l) {
		return ;
	}
	if(x<=l&&r<=y) {
		edge[p].push_back(s);
		return ;
	}
	
	int mid=(l+r)>>1;
	modify(l,mid,p<<1,x,y,s);
	modify(mid+1,r,p<<1|1,x,y,s);
}

void query(int l,int r,int p) {
	int sz=edge[p].size();
	for(int i=0;i<sz;i++) {
		merge(e[edge[p][i]]);
	}
	if(l==r) {
		if(num==1) {
			ans[l]=1;
		}
		else {
			ans[l]=0;
		}
	}
	else {
		int mid=(l+r)>>1;
		query(l,mid,p<<1);
		query(mid+1,r,p<<1|1);
	} 
	while(sz--) {
		del();
	}
}

signed main() {
	cin>>n>>m;
	num=n;
	for(int i=1;i<=n;i++) {
		father[i]=i;
		size[i]=i;
	} 
	for(int i=1;i<=m;i++) {
		e[i]=make_edge(read(),read());
		a[i]=1;
	}
	cin>>q;
	
	for(int i=1;i<=q;i++) {
		int k=read();
		while(k--) {
			int c=read();
			modify(1,q,1,a[c],i-1,c);
			a[c]=i+1;
		}
	}
	for(int i=1;i<=m;i++) {
		modify(1,q,1,a[i],q,i);
	}
	
	query(1,q,1);
	for(int i=1;i<=q;i++) {
		if(ans[i]) {
			printf("Connected\n");
		} 
		else {
			printf("Disconnected\n");
		}
	}
	return 0;
}
```

---

## 作者：pkh68 (赞：3)


线段树分治了解一下？推荐一道题[BZOJ4025二分图](https://www.lydsy.com/JudgeOnline/problem.php?id=4025)。

## 题目分析

首先时间（输入顺序）排序，建线段树。
删边不好做（因为是一个个时间点），考虑转化为加边，就可以套用线段树分治的思路，将边存在的区间对应在线段树上的剖分，然后$dfs$线段树，走到一个节点便加上对应的边，再用并查集维护一下连通性。注意这里的并查集有撤销操作，记录一下$unite$前的状态，在回溯时一步步还原即可（所以不能路径压，会破坏结构），当$l==r$时，并查集的连通性便是时刻l对应的图的连通性，判断一下$size$即可。

## 代码如下

```cpp

#include<list>
#include<cstdio>
#include<cstdlib>
#define N 100005
#define mid ((l+r)>>1)
using namespace std;
int n,m,k,fa[N],sz[N],h[2000005],T_cnt=0,S_top=0,ans[N];
struct E{ int u,v; }e[N*2];
struct T{ int id,nex; }t[8000005];
struct Node{ int x,y,fa,sz; }S[N];
list<int> l[N*2];
inline int In(){
	char c=getchar(); int x=0,f=1;
	for(;c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;
	for(;c>='0'&&c<='9';c=getchar()) x=x*10+c-'0';
	return x;
}
inline int find(int x){
	return fa[x]==x?x:find(fa[x]);
}
inline void unit(int a,int b){
	int x=find(a),y=find(b);
	if(x==y) return;
	if(sz[x]>sz[y]) swap(x,y);
	S[++S_top]=(Node){x,y,fa[x],sz[y]};
	sz[y]+=sz[x]; fa[x]=y;
}
inline void undo(int bck){
	while(S_top>bck){
		fa[S[S_top].x]=S[S_top].fa;
		sz[S[S_top].y]=S[S_top].sz;
		--S_top;
	}
}
void Update(int L,int R,int C,int l,int r,int u){
	if(L<=l&&r<=R){ t[++T_cnt]=(T){C,h[u]}; h[u]=T_cnt; return; }
	if(L<=mid) Update(L,R,C,l,mid,u<<1);
	if(R>mid) Update(L,R,C,mid+1,r,u<<1|1);
}
void Solve(int l,int r,int x){
	int S_bck=S_top;
	for(int i=h[x];i;i=t[i].nex){
		int u=e[t[i].id].u,v=e[t[i].id].v;
		unit(u,v);
	}
	if(l==r) ans[l]=(sz[find(1)]==n);
	else Solve(l,mid,x<<1),Solve(mid+1,r,x<<1|1);
	undo(S_bck);
}
int main(){
	n=In(); m=In(); int last;
	list<int>::iterator it;
	for(int i=1;i<=n;++i) fa[i]=i,sz[i]=1;
	for(int i=1;i<=m;++i)
	e[i].u=In(),e[i].v=In();
	k=In();
	for(int i=1;i<=k;++i)
	for(int c=In();c;--c)
	l[In()].push_back(i);
	for(int i=1;i<=m;++i){
		l[i].push_back(k+1); l[i].sort();
		for(last=1,it=l[i].begin();it!=l[i].end();++it){
			if(last!=*it) Update(last,*it-1,i,1,k,1);
			last=*it+1;
		}
	}
	Solve(1,k,1);
	for(int i=1;i<=k;++i) printf(ans[i]?"Connected\n":"Disconnected\n");
	return 0;
}

```

---

## 作者：Hurraciny (赞：0)

# 题意简述
给定一个有 $n$ 个点和 $m$ 条边的图，有 $k$ 次询问，问当删除一些边后，图是否还联通

# 思路
首先看到本题，可以想到用并查集维护图的联通性，然而，并查集是不支持随机删除的，因此我们可以将删去边改为将没删除的边连接上，到下一个询问时撤销当前的加边操作。
但是如果全部删去，则得到复杂度 $O(mk)$ ，非常明显这会超时，这里运用线段树分治（不会线段树分治的小朋友[戳这里](https://www.cnblogs.com/Golb/articles/18142070)），将操作加到线段树上后，离线算出答案并输出。

# 代码实现
```cpp
#include <iostream>
#include <cstring>
#include <vector>
#include <stack>
#include <algorithm>

using namespace std;

#define PII pair<int, int>
const int N = 1e5+10;
const int M = 2e5+10;
typedef struct{
	int u, v;
}Edge;
Edge edge[M];
class DSU{
private:
	int n;
	int dep[N];
	int fa[N];
	int cnt[N];
	stack<PII>sta;
public:
	inline int size(){
		return sta.size();
	}
	inline void init(int __n){
		n = __n;
		for(int i = 1; i <= n; i++){
			fa[i] = i;
			dep[i] = 0;
			cnt[i] = 1;
		}
		while(!sta.empty())
			sta.empty();
	}
	inline int find(int x){
		if(x == fa[x])
			return x;
		return find(fa[x]);
	}
	inline bool check(int x, int y){
		return find(x) == find(y);
	}
	inline bool check(){
		return cnt[find(1)] == n;
	}
	inline void join(int x, int y){
		x = find(x);
		y = find(y);
		if(x == y)
			return;
		if(dep[x] > dep[y])
			swap(x, y);
		if(dep[x] == dep[y])
			dep[y]++;
		fa[x] = y;
		cnt[y] += cnt[x];
		sta.push(make_pair(x, y));
 	}
 	inline void undo(int ct){
 		while(size() != ct){
 			auto [x, y] = sta.top();
 			sta.pop();
 			if(dep[x]+1 == dep[y])
 				dep[y]--;
 			fa[x] = x;
 			cnt[y] -= cnt[x];
 		}
 	}
};
DSU UN;
vector<Edge>tree[N<<2];
inline int lchild(int x){return x<<1;}
inline int rchild(int x){return x<<1|1;}
inline void add(int p, int pl, int pr, int l, int r, Edge x){
	if(pl >= l && pr <= r){
		tree[p].push_back(x);
		return;
	}
	int mid = (pl+pr) >> 1;
	if(mid >= l)
		add(lchild(p), pl, mid, l, r, x);
	if(mid < r)
		add(rchild(p), mid+1, pr, l, r, x);
	return;
}
inline void dfs(int p, int pl, int pr){
	int tmp = UN.size();
	for(auto [x, y] : tree[p])
		UN.join(x, y);
	if(pl == pr){
		if(UN.check())
			puts("Connected");
		else
			puts("Disconnected");
	}
	else{
		int mid = (pl+pr) >> 1;
		dfs(lchild(p), pl, mid);
		dfs(rchild(p), mid+1, pr);
	}
	UN.undo(tmp);
}
int bef[M];
int main(){
	int n, m;
	cin >> n >> m;
	UN.init(n);
	for(int i = 1; i <= m; i++)
		cin >> edge[i].u >> edge[i].v;
	int k;
	cin >> k;
	for(int i = 1; i <= k; i++){
		int c;
		cin >> c;
		while(c--){
			int x;
			cin >> x;
			if(bef[x]+1 <= i-1)
				add(1, 1, k, bef[x]+1, i-1, edge[x]);
			bef[x] = i;
		}
	}
	for(int i = 1; i <= m; i++)
		add(1, 1, k, bef[i]+1, k, edge[i]);
	dfs(1, 1, k);
	return 0;
}
```

---

## 作者：Walrus (赞：0)

对于「删边之后判断是否连通」问题的一般策略是使用线段树分治完成。

思考如何把删边转化为边的出现时间。由于询问之间互不影响，所以非常快速地想到集合 $S_i$ 中的边的出现时间为 $[1,i-1]$ 和 $[i+1,k]$。

这里采用启发式合并的可撤销并查集实现较为迅捷。

- 如何判断图是否保持连通？

有一个非常显然的方法，由于启发式合并是按大小合并，所以如果只有一个大小为 $n$ 的集合，那么这张图就是连通的。

时间复杂度为正常的线段树分治复杂度 $O(M\log^2N)$。

```cpp
#include <bits/stdc++.h>
#define rep(i, j, k) for(int i = j; i <= k; ++i)
#define pb push_back
#define PII pair<int, int>

using namespace std;
const int N = 5e5 + 5;
int n, m, k, u[N], v[N], ans[N], tag[N];
vector<PII> e[N * 2];

struct Union {
	int fa[N], siz[N];
	stack<PII> st;

	void init() {
		rep(i, 1, n) fa[i] = i, siz[i] = 1;
	}

	int get(int x) {
		return x == fa[x] ? x : get(fa[x]);
	}

	void merge(int x, int y) {
		x = get(x), y = get(y);
		if(x == y) return;
		if(siz[x] > siz[y]) swap(x, y);
		st.push({x, y});
		fa[x] = y, siz[y] += siz[x];
		tag[x] -= tag[y];
	}


	void undo(int last) {
		while(st.size() > last) {
			int x = st.top().first, y = st.top().second;
			st.pop();
			fa[x] = x, siz[y] -= siz[x];
			tag[x] += tag[y];
		}
	}

} DSU;

stack<PII> T;

struct SegmentTree {
#define ls (p << 1)
#define rs (p << 1 | 1)
#define mid (l + r >> 1)

	void upd(int p, int l, int r, int L, int R, int u, int v) {
		if(L > r || l > R) return;
		if(L <= l && r <= R)
			return e[p].pb({u, v}), void();
		upd(ls, l, mid, L, R, u, v), upd(rs, mid + 1, r, L, R, u, v);
	}

	void ask(int p, int l, int r) {
		int S = DSU.st.size();
		for(auto ed : e[p]) {
			int x = ed.first, y = ed.second;
			DSU.merge(x, y);
		}
		if(l == r) ans[l] = DSU.siz[DSU.get(1)] == n;
		else ask(ls, l, mid), ask(rs, mid + 1, r);
		DSU.undo(S);
	}
} SGT;

vector<int> f[N];

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(nullptr), cout.tie(nullptr);

	cin >> n >> m;
	DSU.init();
	rep(i, 1, m)
		cin >> u[i] >> v[i];
	cin >> k;
	rep(i, 1, k) {
		int sum, x;
		cin >> sum;
		rep(j, 1, sum) cin >> x, f[x].pb(i);
	}
	
	rep(i, 1, m) {
		int lt = 0;
		for(auto x : f[i])
			SGT.upd(1, 0, k, lt, x - 1, u[i], v[i]), lt = x + 1;
		if(lt <= k)
			SGT.upd(1, 0, k, lt, k, u[i], v[i]);
	}
	
	SGT.ask(1, 0, k);
	rep(i, 1, k) cout << (ans[i] ? "Connected" : "Disconnected") << '\n';
}
```

---

## 作者：gyyyyx (赞：0)

前置知识：线段树分治，并查集

对于一个无向图的连通性，我们考虑用并查集维护。

但如果是并查集无法处理删边。

想到并查集虽然无法任意删除其中一步，但是可以兼容撤回操作，即只删除最后一次合并操作。

容易想到用线段树分治记录边，然后用可撤销并查集维护图的连通性。

最后判断是否联通可以用一个变量 `cnt` 记录当前有效的边数，每次合并成功就 `++cnt`，到最后如果 `cnt==n-1` 相当于有效的边组成了一棵树，图必联通，否则图不联通。

代码：

```cpp
#include<bits/stdc++.h>
#define N 100005
#define M 200005
using namespace std;
int n,m,q;
struct Edge{int u,v;};
struct Edge E[M<<1];
int lst[M];
vector <int> Node[N<<2];
int fa[N],dep[N],cnt;
stack <int> st1,st2;
bool ans[N];
void Update(int k,int l,int r,int s,int t,int e){
	if(s<=l&&r<=t){
		Node[k].push_back(e);
		return;
	}
	int ls(k<<1),rs(k<<1|1),mid(l+r>>1);
	if(s<=mid) Update(ls,l,mid,s,t,e);
	if(mid<t) Update(rs,mid+1,r,s,t,e);
}
int Find(int x){
	if(fa[x]==x) return x;
	return Find(fa[x]);
}
inline void Merge(int x,int y){
	x=Find(x);y=Find(y);
	if(x^y){
		if(dep[x]>dep[y]) swap(x,y);
		st1.push(x);st2.push(dep[y]);
		fa[x]=y;dep[y]=max(dep[x]+1,dep[y]);
		++cnt;
	}
}
inline void Delete(){
	int x(st1.top());st1.pop();
	int d(st2.top());st2.pop();
	dep[fa[x]]=d;fa[x]=x;--cnt;
}
void Solve(int k,int l,int r){
	int tim(cnt);
	for(int i(0);i<Node[k].size();++i){
		int e(Node[k][i]);
		Merge(E[e].u,E[e].v);
	} tim=cnt-tim;
	if(l==r) ans[l]=bool(cnt>=n-1);
	else{
		int ls(k<<1),rs(k<<1|1),mid(l+r>>1);
		Solve(ls,l,mid);Solve(rs,mid+1,r);
	}
	for(int i(1);i<=tim;++i) Delete();
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i(1);i<=m;++i) scanf("%d%d",&E[i].u,&E[i].v);
	scanf("%d",&q);
	for(int i(1);i<=q;++i){
		int c;scanf("%d",&c);
		for(int j(1);j<=c;++j){
			int x;scanf("%d",&x);
			if(i>1) Update(1,1,q,lst[x]+1,i-1,x);
			lst[x]=i;
		}
	}
	for(int i(1);i<=m;++i) if(lst[i]<q) Update(1,1,q,lst[i]+1,q,i);
	for(int i(1);i<=n;++i) fa[i]=i,dep[i]=1;Solve(1,1,q);
	for(int i(1);i<=q;++i) puts(ans[i]?"Connected":"Disconnected");
	return 0;
}
```

---

## 作者：Hoks (赞：0)

## 前言
算是比较进阶的 LCT 的题了，可是为什么只有一篇 LCT 的题解，我 LCT 不服。

可惜常数太大时间上被薄纱了。

广告：[『从入门到入土』树链剖分学习笔记](https://www.luogu.com.cn/article/56o68hfu)。
## 思路分析
这种动态图问题，肯定优先考虑 LCT。

但还是知周所众的是：LCT 只能维护动态森林，而不是动态图。

也就是我们要用动态图生成一颗动态森林，保证答案不变。

顺着这个思路，来看这题。

首先显然的有经典 trick：**删边时间作为边的边权**。

对于两条贡献相同的边，显然保留删的晚的好。

所以考虑用 LCT 来维护一个动态最大生成森林，这样选出来的边肯定是最优的。

接着仔细看操作，发现让我们断开一些边，但是操作间又是独立的。

那么按照操作的时间轴排序，就是先断边，在下一个时刻再先连边即可。

接着考虑怎么查询整张图是否连通。

考虑只找出一个点 $1$，如果 $1$ 号点与其他点都能到达，即为连通的。

正确性显然，接着考虑用什么东西表示 $1$ 号点能到达的点数。

先把 $1$ 号节点弄成根的话，他能到达的节点数显然为子树大小。

维护子树大小，使用虚子树 trick，记得在 access，link，pushup 的时候修改即可。

好像也不是很难码？只不过常数大喜提最劣解了。

**注意：由于不同的操作可能删掉同一条边，所以每次把一条边删了要复制一个新版本，每次修改最新版本。**
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+10,INF=0x3f3f3f3f;
struct edge{int x,y,w;}e[N];
struct query{int op,x,t;}q[N];
int n,m,k,tot,cnt,cur[N],st[10];
namespace Fast_IO
{
    static char buf[1000000],*paa=buf,*pd=buf,out[10000000];int length=0;
    #define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
    inline int read()
    {
        int x(0),t(1);char fc(getchar());
        while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
        while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
        return x*t;
    }
    inline void flush(){fwrite(out,1,length,stdout);length=0;}
    inline void put(char c){if(length==9999999) flush();out[length++]=c;}
    inline void put(string s){for(char c:s) put(c);}
    inline void print(int x)
    {
        if(x<0) put('-'),x=-x;
        if(x>9) print(x/10);
        put(x%10+'0');
    }
    inline bool chk(char c) { return !(c>='a'&&c<='z'||c>='A'&&c<='Z'||c>='0'&&c<='9'); }
    inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1&&c!=' '; }
    inline void rd(char s[],int&n)
    {
        s[++n]=getchar();
        while(chk(s[n])) s[n]=getchar();
        while(ck(s[n])) s[++n]=getchar();
        n--;
    }
}
using namespace Fast_IO;
struct LCT
{
    #define ls son[x][0]
    #define rs son[x][1]
    int f[N],s[N],ss[N],t[N],son[N][2],st[N],w[N],r[N],mn[N];
    bool ntrt(int x){return son[f[x]][1]==x||son[f[x]][0]==x;}
    void pushup(int x)
    {
        (x>n)&&(s[x]=x);ss[x]=ss[ls]+ss[rs]+t[x]+(x<=n);
        if(w[x]>=w[s[ls]]) s[x]=s[ls];
        if(w[s[x]]>=w[s[rs]]) s[x]=s[rs];
    }
    void pushson(int x){swap(ls,rs),r[x]^=1;}
    void pushdown(int x)
    {
        if(r[x])
        {
            if(ls) pushson(ls);
            if(rs) pushson(rs);
            r[x]=0;
        }
    }
    void rotate(int x)
    {
        int y=f[x],z=f[y],k=(son[y][1]==x),w=son[x][!k];
        if(ntrt(y)) son[z][son[z][1]==y]=x;son[x][!k]=y;son[y][k]=w;
        if(w) f[w]=y;f[y]=x;f[x]=z;pushup(y);
    }
    void Splay(int x)
    {
        int y=x,tot=0;st[++tot]=y;
        while(ntrt(y)) st[++tot]=y=f[y];
        while(tot) pushdown(st[tot--]);
        while(ntrt(x))
        {
            y=f[x];int z=f[y];
            if(ntrt(y)) rotate((son[y][0]==x)^(son[z][0]==y)?x:y);
            rotate(x);
        }
        pushup(x);
    }
    void access(int x){for(int y=0;x;x=f[y=x]) Splay(x),t[x]+=ss[rs],t[x]-=ss[rs=y],pushup(x);}
    void makert(int x){access(x);Splay(x);pushson(x);}
    int findrt(int x)
    {
        access(x);Splay(x);
        while(ls) pushdown(x),x=ls;
        Splay(x);return x;
    }
    void split(int x,int y){makert(y);access(x);Splay(x);}
    void link(int x,int y){split(x,y);f[y]=x,t[x]+=ss[y];}
    void cut(int x,int y){split(x,y);f[y]=ls=0,pushup(x);}
    #undef ls
    #undef rs
}lct;
signed main()
{
    n=read(),tot=m=read();
    for(int i=1;i<=m;i++) e[i].x=read(),e[i].y=read(),cur[i]=i,q[++cnt]={1,i,0};
    k=read();for(int i=0;i<=n;i++) lct.w[i]=INF;
    for(int i=1,x,T,top=0;i<=k;i++)
    {
        T=read();
        for(int j=1;j<=T;j++)
        {
            x=read();e[cur[x]].w=i-1;lct.w[cur[x]+n]=i-1;
            q[++cnt]={2,cur[x],i};e[++tot]=e[cur[x]];
            e[tot].w=0,cur[x]=tot;st[++top]=cur[x];
        }q[++cnt]={0};
        if(i!=k) while(top) q[++cnt]={1,st[top--],i};
    }
    for(int i=1;i<=m;i++) if(!e[cur[i]].w) e[cur[i]].w=k,lct.w[cur[i]+n]=k;
    tot+=n;for(int i=1;i<=tot;i++) lct.ss[i]=1;
    for(int i=1,j,x,y,w;i<=cnt;i++)
    {
        if(!q[i].op){lct.access(1),lct.Splay(1),put(lct.ss[1]==n?"Connected\n":"Disconnected\n");continue;}
        j=q[i].x;x=e[j].x,y=e[j].y,w=e[j].w;lct.makert(x);
        if(q[i].op==1)
        {
            if(lct.findrt(y)==x)
            {
                int ww=lct.s[x];
                if(lct.w[ww]>=w) continue;
                lct.cut(e[ww-n].x,ww),lct.cut(e[ww-n].y,ww);
            }
            lct.link(x,j+n),lct.link(y,j+n);
        }
        else
            if(lct.findrt(y)==x)
            {
                lct.pushup(j+n);
                if(!lct.f[j+n]&&!lct.ss[j+n]) continue;
                lct.cut(x,j+n),lct.cut(y,j+n);
            }
    }
    genshin:;flush();return 0;
}
```

---

## 作者：complete_binary_tree (赞：0)

[原题传送门](https://www.luogu.com.cn/problem/P5227)

## 前置知识

- 线段树

- 可删除并查集

- [P5787 二分图 /【模板】线段树分治](https://www.luogu.com.cn/problem/P5787)

## 正文

对于每一个询问，都会删除一些边。那么我们可以把其它边存到一个并查集中，再判断这些被删除边的 $u$ 和 $v$ 能不能通达就行了。为什么呢？

题目中给了一个条件：给定的图一定连通。那么，删除一条边 $<u,v>$ 后，要么全图还是连通，要么图不连通，此时 $u,v$ 一定分属两个不同的连通块。

那么题目就变成像 $\text{P5787}$ 一样了：给定一些边，在某一段时间出现。在某一个点 $j$ 查询 $c_j$ 个点对，如果这 $c_j$ 个点对不连通，那么就 $\text{Disconnected}$；反之则 $\text{Connected}$。

这样我们就可以转化为线段树分治来做了。

但是，这题是删除，不是区间增加。那怎么把删除改为区间增加呢？

我们只需开一个桶，记录第 $i$ 条边上一个删除的位置 $\text{bowl}_i$。如果下一次在 $j$ 位置又删除了 $i$，那么说明 $(\text{bowl}_i,j)$ 这个区间是没被删除的，加入线段树即可。

由于这题 $c\le 4$，所以最多分出的区间数也是 $O(n)$ 的（带一点常数），不用担心 $\text{MLE}$。

时间复杂度：$O(kc\log k\log n)$，$2\text{s}$ 绰绰有余。

$\text{Code:}$

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 2e5 + 5;

int n, m, k;

struct edge{
	int u, v;
} e[N];int cnt;

struct bcj{
	stack<int> st;
	int fa[N], siz[N];
	void csh(int n){
		for(int i = 1; i <= n; ++i) fa[i] = i, siz[i] = 1;
	}
	int find(int i){return fa[i] == i? i: find(fa[i]);}
	void add(int a, int b){
		a = find(a), b = find(b);
		if(siz[a] > siz[b]) swap(a, b);
		fa[a] = b;
		siz[b] += siz[a];
		st.push(a);
	}
	void erase(){
		int u = st.top();
		st.pop();
		int b = fa[u];
		siz[b] -= siz[u];
		fa[u] = u;
	}
} bc1;

struct tree{
	vector<int> E;
	vector<bool> P;
	int l, r;
};

int c[N][5];

struct lt{
	tree t[N << 2];
	void build(int x, int l, int r){
		t[x].l = l, t[x].r = r;
		if(l == r) return ;
		int mid = (l + r) >> 1;
		build(2 * x, l, mid), build(2 * x + 1, mid + 1, r);
		return ;
	}
	void add(int x, int l, int r, int y){
		if(l > t[x].r || r < t[x].l) return ;
		if(l <= t[x].l && r >= t[x].r){
			t[x].E.push_back(y);
			return ;
		}
		add(2 * x, l, r, y), add(2 * x + 1, l, r, y);
		return ;
	}
	void work(int x){
		int L = t[x].E.size();
		for(int i = 0; i < L; ++i){
			int j = t[x].E[i];
			int u = e[j].u, v = e[j].v;
			if(bc1.find(u) == bc1.find(v)){
				t[x].P.push_back(0);
			} 
			else{
				bc1.add(u, v);
				t[x].P.push_back(1);
			}
		}
		if(t[x].l == t[x].r){
			bool can = 1;
			for(int i = 1; i <= c[t[x].l][0]; ++i){
				int u = e[c[t[x].l][i]].u, v = e[c[t[x].l][i]].v;
				if(bc1.find(u) != bc1.find(v)){
					can = 0; break;
				}
			}
			if(can) puts("Connected");
			else puts("Disconnected");
		}
		else work(2 * x), work(2 * x + 1);
		for(int i = 0; i < L; ++i){
			if(t[x].P[i]) bc1.erase();
		}
		return ;
	}
} t1;

int bowl[N];

inline int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while((ch < '0' || ch > '9') && ch != EOF){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = x * 10 + ch - 48;
		ch = getchar();
	}
	return x * f;
}

int main(){
	n = read(), m = read();
	bc1.csh(n + 2);
	for(int i = 1; i <= m; ++i){
		int u, v;
		u = read(), v = read();
		e[++cnt].u = u, e[cnt].v = v;
	}
	k = read();
	t1.build(1, 1, k);
	for(int i = 1; i <= k; ++i){
		c[i][0] = read();
		for(int j = 1; j <= c[i][0]; ++j){
			c[i][j] = read();
			if(bowl[c[i][j]] != i - 1){
				t1.add(1, bowl[c[i][j]] + 1, i - 1, c[i][j]);
			}
			bowl[c[i][j]] = i;
		}
	}
	for(int i = 1; i <= m; ++i){
		if(bowl[i] < k){
			t1.add(1, bowl[i] + 1, k, i);
		}
	}
	t1.work(1);
	return 0;
}
```

---

## 作者：NBest (赞：0)

这道题一眼看上去就不是很可做，怎么办？突然看到集合的数据范围 $c\le 4$。有了一点想法，又看到标签，想到了线段树分治。

因为这个集合的大小很小，也就是我们删除的边很少，我们很自然地想到不进行删边而是进行加边，而且也便于我们想到用并查集维护。那么我们对集合个数开一个线段树，发现这些操作可以区间执行，我们把每条边加入集合的线段树中，如果有集合删除了它我们就给它在这个集合的位置断开，然后就转换成了线段树分治模板题。

每个集合的每次删除操作相当于给线段树上多加一个操作区间，所以加的操作区间数量为 $m+ck$，而在线段树中挂着的总操作区间为 $(m+ck)\log k$，只进行按秩合并的并查集复杂度为 $O(\log n)$，所以总复杂度为 $O((m+ck)\log k\log n)$，可过。

具体细节看代码吧。我这里没有用标准的按秩合并，应该是一个更好理解版的？主要是这么写判联通也很方便。
### Code
```cpp
#define mid (l+r>>1)
const int N=1e5+5;
int n,m,k,fa[N],siz[N];
pair<int,int> e[N<<1];
vector<int>lim[N<<1],f[N<<2];
stack<int>S;
int find(int x){
    while(x^fa[x])x=fa[x];
    return x;
}
void add(int root,int l,int r,int x,int y,int id){
    if(x>y)return;
    if(x<=l&&r<=y)return f[root].push_back(id),void();
    if(mid>=x)add(root<<1,l,mid,x,y,id);
    if(mid<y)add(root<<1|1,mid+1,r,x,y,id);
}
inline void merge(int x,int y){
    if((x=find(x))==(y=find(y)))return;
    if(siz[x]>siz[y])swap(x,y);
    S.push(x),siz[y]+=siz[x],fa[x]=y;
}
void solve(int root,int l,int r){
    int las=S.size();
    for(int i:f[root])
        merge(e[i].first,e[i].second);
    if(siz[find(1)]==n)//如果并查集的大小为n说明联通了，不需要继续递归了
        for(int i=l;i<=r;i++)puts("Connected");
    else if(l==r)puts("Disconnected");
    else solve(root<<1,l,mid),solve(root<<1|1,mid+1,r);
    while(las^S.size())//回退，不管什么情况都要回退
        siz[fa[S.top()]]-=siz[S.top()],fa[S.top()]=S.top(),S.pop();
}
int main(){
    n=read(),m=read();
    for(int i=1;i<=n;i++)fa[i]=i,siz[i]=1;
    for(int i=1;i<=m;i++)
        e[i]={read(),read()},lim[i].push_back(0);//先给左边加上边界
    k=read();
    for(int i=1;i<=k;i++)
        for(int j=read(),x;j;--j)
            lim[x=read()].push_back(i);
    for(int i=1;i<=m;i++){
        lim[i].push_back(k+1);//最后给右边加上边界，减少特判
        for(int j=1;j<lim[i].size();j++)
            add(1,1,k,lim[i][j-1]+1,lim[i][j]-1,i);
    }
    solve(1,1,k);
    return 0;
}
```

---

## 作者：happybob (赞：0)

考虑线段树分治。

每一条边存在的时间是若干个区间，在线段树上将这些区间加入这条边，离线之后使用可撤销并查集按秩合并。如果 $1$ 点的根所在集合大小为 $n$，则是连通，输出 $r-l+1$ 个 $\texttt{Connected}$，否则递归往下即可。

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
#include <stack>
using namespace std;

const int N = 2e5 + 5;

int n, m, k;
vector<int> V[N];
int u[N], v[N];

class Union_Find
{
public:
	int fa[N], sz[N];
	void Init()
	{
		for (int i = 0; i < N; i++) fa[i] = i, sz[i] = 1;
	}
	int find(int u)
	{
		return(fa[u] == u ? u : find(fa[u]));
	}
	pair<int, int> merge(int u, int v)
	{
		if ((u = find(u)) == (v = find(v)))
		{
			exit(-1);
		}
		if (sz[u] < sz[v]) swap(u, v);
		fa[v] = u;
		sz[u] += sz[v];
		return make_pair(u, v);
	}
	void del(int u, int v)
	{
		fa[v] = v;
		sz[u] -= sz[v];
	}
}uf;

class SegmentTree
{
public:
	struct Node
	{
		int l, r;
		vector<pair<int, int>> v;
	}tr[N << 2];
	void build(int u, int l, int r)
	{
		tr[u] = { l, r };
		tr[u].v.clear();
		tr[u].v.shrink_to_fit();
		if (l == r) return;
		int mid = l + r >> 1;
		build(u << 1, l, mid);
		build(u << 1 | 1, mid + 1, r);
	}
	void update(int u, int l, int r, auto v)
	{
		if (tr[u].l >= l and tr[u].r <= r)
		{
			tr[u].v.emplace_back(v);
			return;
		}
		int mid = tr[u].l + tr[u].r >> 1;
		if (l <= mid) update(u << 1, l, r, v);
		if (r > mid) update(u << 1 | 1, l, r, v);
	}
	void solve(int u)
	{
		stack<pair<int, int>> st;
		for (auto& j : tr[u].v)
		{
			if (uf.find(j.first) == uf.find(j.second)) continue;
			st.push(uf.merge(j.first, j.second));
		}
		if (uf.sz[uf.find(1)] == n)
		{
			for (int i = tr[u].l; i <= tr[u].r; i++)
			{
				cout << "Connected\n";
			}
		}
		else
		{
			if (tr[u].l == tr[u].r) cout << "Disconnected\n";
			else
			{
				solve(u << 1);
				solve(u << 1 | 1);
			}
		}
		while (st.size())
		{
			uf.del(st.top().first, st.top().second);
			st.pop();
		}
	}
}sgt;

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= m; i++)
	{
		cin >> u[i] >> v[i];
	}
	cin >> k;
	sgt.build(1, 1, k);
	uf.Init();
	for (int i = 1; i <= k; i++)
	{
		int c;
		cin >> c;
		for (int j = 1; j <= c; j++)
		{
			int x;
			cin >> x;
			V[x].emplace_back(i);
		}
	}
	for (int i = 1; i <= m; i++)
	{
		if (V[i].empty())
		{
			sgt.update(1, 1, k, make_pair(u[i], v[i]));
		}
		else
		{
			if (V[i].front() != 1)
			{
				sgt.update(1, 1, V[i].front() - 1, make_pair(u[i], v[i]));
			}
			for (int j = 1; j < V[i].size(); j++)
			{
				int l = V[i][j - 1] + 1, r = V[i][j] - 1;
				if (l <= r) sgt.update(1, l, r, make_pair(u[i], v[i]));
			}
			if (V[i].back() != k) sgt.update(1, V[i].back() + 1, k, make_pair(u[i], v[i]));
		}
	}
	sgt.solve(1);
	return 0;
}
```


---

## 作者：Natori (赞：0)

>[P5227 [AHOI 2013] 连通图](https://www.luogu.com.cn/problem/P5227)

线段树分治板子题。

------------
根据套路，先将所有操作离线，用线段树分治将删边转化为加边后撤销。

具体而言，记录每个操作有效的时间段，插入到线段树上对应的区间。用可撤销并查集维护连通性，用栈记录已经进行过的操作，以便之后进行撤销。~~感觉说的了很多没用的，具体还是看代码吧~~

时间复杂度是 $\mathcal{O}(q \log q \log n)$。$\log q$ 是线段树分治插入的复杂度，$\log n$ 是可撤销并查集操作一次的复杂度，因为没有路径压缩。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
bool Mbegin;
void File_Work(){
	freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);
}
namespace Fast_In_Out{
	char buf[1<<21],*P1=buf,*P2=buf;
	#define gc (P1==P2&&(P2=(P1=buf)+fread(buf,1,1<<21,stdin),P1==P2)?EOF:*P1++)
	int read(){
		int f=1,x=0;
		char c=gc;
		while(c<'0'||c>'9'){
			if(c=='-')
			    f=-1;
			c=gc;
		}
		while(c>='0'&&c<='9'){
			x=x*10+c-'0';
			c=gc;
		}
		return f*x;
	}
	void write(int x){
		if(x<0)
			x=-x,putchar('-');
		if(x>9)
			write(x/10);
		putchar(x%10+'0');
	}
	#undef gc
}
using namespace Fast_In_Out;
const int N=1e5+8,M=2e5+8,Q=1e5+8;
int n,m,q;
struct Edge{
	int from,to;
}edge[M];
struct Option{
	int timl,timr,eid;
}ops[Q*4+M];
int opcnt,lst[M];
bool ans[Q];
struct Disjoint_Set_Union{
	int fa[N],siz[N],stc[M],top;
	void init(){
		for(int i=1;i<=n;i++){
			fa[i]=i;
			siz[i]=1;
		}
	}
	int find(int x){
		return fa[x]==x?x:find(fa[x]);
	}
	void unite(int x,int y){
		stc[++top]=0;
		x=find(x),y=find(y);
		if(x==y)
			return;
		if(siz[x]>siz[y])
			swap(x,y);
		stc[top]=x;
		fa[x]=y;
		siz[y]+=siz[x];
	}
	void undo(){
		if(stc[top]==0){
			top--;
			return;
		}
		siz[fa[stc[top]]]-=siz[stc[top]];
		fa[stc[top]]=stc[top];
		top--;
	}
	bool query(){
		return siz[find(1)]==n;
	}
}dsu;
namespace Segment_Tree_Divide{
	vector<int> vec[M<<2];
	int ls(int o){
		return o<<1;
	}
	int rs(int o){
		return o<<1|1;
	}
	void insert(int o,int l,int r,int ql,int qr,int eid){
		if(ql<=l&&r<=qr){
			vec[o].push_back(eid);
			return;
		}
		int mid=(l+r)/2;
		if(ql<=mid)
			insert(ls(o),l,mid,ql,qr,eid);
		if(mid+1<=qr)
			insert(rs(o),mid+1,r,ql,qr,eid);
	}
	void divide(int o,int l,int r){
		if(r<l)
			return;
		for(auto cur:vec[o]){
			int u=edge[cur].from,v=edge[cur].to;
			dsu.unite(u,v);
		}
		if(l==r){
			ans[l]=dsu.query();
			for(int i=0;i<(int)vec[o].size();i++)
				dsu.undo();
			return;
		}
		int mid=(l+r)/2;
		divide(ls(o),l,mid);
		divide(rs(o),mid+1,r);
		for(int i=0;i<(int)vec[o].size();i++)
			dsu.undo();
	}
}
bool Mend;
int main(){
//	File_Work();
	fprintf(stderr,"%.3lf MB\n\n\n",(&Mbegin-&Mend)/1048576.0);
	n=read(),m=read();
	dsu.init();
	for(int i=1;i<=m;i++){
		int u=read(),v=read();
		edge[i].from=u;
		edge[i].to=v;
		lst[i]=1;
	}
	q=read();
	for(int i=1;i<=q;i++){
		int c=read();
		for(int j=1;j<=c;j++){
			int x=read();
			opcnt++;
			ops[opcnt].timl=lst[x];
			ops[opcnt].timr=i-1;
			ops[opcnt].eid=x;
			lst[x]=i+1;
		}
	}
	for(int i=1;i<=m;i++)
		if(lst[i]!=q+1){
			opcnt++;
			ops[opcnt].timl=lst[i];
			ops[opcnt].timr=q;
			ops[opcnt].eid=i;
		}
	for(int i=1;i<=opcnt;i++)
		if(ops[i].timl<=ops[i].timr)
			Segment_Tree_Divide::insert(1,1,q,ops[i].timl,ops[i].timr,ops[i].eid);
	Segment_Tree_Divide::divide(1,1,q);
	for(int i=1;i<=q;i++){
		if(ans[i]==1)
			printf("Connected");
		else
			printf("Disconnected");
		putchar('\n'); 
	}
	fprintf(stderr,"\n\n\n%.0lf ms",1e3*clock()/CLOCKS_PER_SEC);
	return 0;
}
```

---

## 作者：Z1qqurat (赞：0)

借这个题讲一下线段树分治。

## 通式（时间分治）

其实就是一种维护分治的方式。每个限制条件会在某一个时间段出现，要求我们维护每个时间节点对应的一些信息，比如连通性。最直接的方法是对每个时间维护一个状态，然后对于每个条件暴力加入其有效区间，这样是 $n ^ 2$ 的。

不难发现这可以看做是某种意义下的**区间覆盖**。区间覆盖问题咋优化啊？**线段树**。线段树利用**将每个区间拆分为至多 $\log n$ 个区间**，将复杂度降为 $\mathcal{O}(n \log n)$。其实这可以类比一下线段树优化建图，这也是某种意义上的区间覆盖。

那么我线段树上每个节点 $(cur, l, r)$ 维护的是 $[l, r]$ 这段时间内的信息，那么如果有一个限制条件在 $[x, y]$ 内有效，我们将其拆为 $\log (y - x + 1)$ 个区间，然后在这些区间对应的节点上加上这个条件。所以说实际上 $[l, r]$ 所对应的信息是**从节点 $(cur, l, r)$ 一路到线段树上根节点的所有信息取并**。

那么可以大致写出以下伪代码：

```cpp
void modify(int cur, int l, int r, int x, int y, Condition) {
    if(x <= l && r <= y) {
        Add Condition to (cur, l ,r);
    }
    int mid = (l + r) >> 1;
    if(x <= mid) modify(cur << 1, l, mid, x, y, e);
    if(y > mid) modify(cur << 1 | 1, mid + 1, r, x, y, e);
    return ;
}

void query(int cur, int l, int r) {
    Answer(l, r); //目前的结果
    Get the answer of [l, r] -> Answer(l, r);
    //[l, r] 的子区间会继承 [l, r] 的状态，也就是 Answer(l, r)
    if(l == r) {
        ans[l] = Answer(l, r);
        Undo the options of [l, r];
      return ;
    }
    int mid = (l + r) >> 1;
    query(cur << 1, l, mid);
    query(cur << 1 | 1, mid + 1, r);
    Undo the options of [l, r];
    return ;
}
```

## 【模版】线段树分治

它问你每个时刻是不是二分图啊。二分图的判定可以通过黑白染色判奇环，但是这样对于每个时刻都要重新跑一遍 dfs，**不能继承父亲的状态**，没法线段树分治。考虑一种用**扩展域并查集（又名种类并查集）**的数据结构判定二分图。咋做？将每个点拆为 $u, u + n$ 两个点，每次连边的时候 ```merge(u, v + n), merge(u + n, v)```，然后查询的时候判断 ```getroot(u) != getroot(v)``` 即可。想一想，如果 ```getroot(u) == getroot(v)```，且我们即将把 $u, v$ 连接，而 $u, v$ 之间已经有路径连接，那么肯定是一条形如 $u \rightarrow s_1 + n \rightarrow s_2 \rightarrow s_3 + n \rightarrow \cdots \rightarrow s_i + n \rightarrow v$ 的路径，而根据我们的连边方式，肯定是编号大于 $n$ 和小于等于 $n$ 的节点交替出现。所以 $u, v$ 之间必然有偶数条边，连接上 $u, v$ 之后就会出现奇环，不是二分图了。因此这种**拆点做扩展域并查集判二分图的做法**是正确的。

那么我们维护一个**可撤销的扩展域并查集**表示目前的状态，然后线段树分治做就可以了，没有什么太大的问题，主要是注意把 $ans(cur, l, r)$ 的答案和状态下传给儿子以及判完 $(cur, l, r)$ 或者 $(cur, l, r)$ 时不是二分图的情况下要马上撤销所有加的边并且 ```return ;```。

然后这个模版题需要将输入的 $l$ 加 $1$，因为它问的是每个时间段的答案而不是时刻，这样方便做一些。我的代码没有天城燐音帅，嫌丑的话可以去看 RISKY VENUS 里面的天城燐音特写镜头！

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <stack>
#define ll long long
#define pii pair<int, int>
#define mr make_pair
#define fi first
#define se second
using namespace std;
const int N = 2e5 + 5;
int n, m, k;
bool ans[N];

struct DSU{
    int siz[N << 1], fa[N << 1]; //扩展域并查集
    stack <int> opt;
    void init() {
        for (int i = 1; i <= (n << 1); ++i) {
            fa[i] = i, siz[i] = 1;
        }
        return ;
    }
    int getroot(int x) {
        if(fa[x] == x) return x;
        return getroot(fa[x]);
    }
    void merge(int x, int y) {
        x = getroot(x), y = getroot(y);
        if(x == y) return ;
        if(siz[x] > siz[y]) swap(x, y);
        siz[y] += siz[x], fa[x] = y;
        opt.push(x); return ;
    }
    void undo() {
        if(opt.empty()) return ;
        int u = opt.top(); opt.pop();
        siz[fa[u]] -= siz[u], fa[u] = u;
        return ;
    }
    void del(int cnt) {
        while(opt.size() > cnt) undo();
        return ;
    }
}D;

vector <pii> tr[N << 2];

void modify(int cur, int l, int r, int x, int y, pii e) {
    if(x <= l && r <= y) {
        tr[cur].push_back(e); return ;
    }
    int mid = (l + r) >> 1;
    if(x <= mid) modify(cur << 1, l, mid, x, y, e);
    if(y > mid) modify(cur << 1 | 1, mid + 1, r, x, y, e);
    return ;
}

void query(int cur, int l, int r) {
    int cnt = D.opt.size();
    for (int i = 0; i < tr[cur].size(); ++i) {
        int u = tr[cur][i].fi, v = tr[cur][i].se;
        if(D.getroot(u) == D.getroot(v)) {
            D.del(cnt); return ;
        }
        D.merge(u, v + n), D.merge(u + n, v);
    }
    if(l == r) {
        ans[l] = 1;
        D.del(cnt); return ;
    }
    int mid = (l + r) >> 1;
    query(cur << 1, l, mid);
    query(cur << 1 | 1, mid + 1, r);
    D.del(cnt); return ;
}

int main() {
    scanf("%d %d %d", &n, &m, &k);
    D.init();
    for (int i = 1; i <= m; ++i) {
        int u, v, l, r; scanf("%d %d %d %d", &u, &v, &l, &r);
        l++; if(l > r) continue;
        modify(1, 1, k, l, r, mr(u, v));
    }
    query(1, 1, k);
    for (int i = 1; i <= k; ++i) {
        if(ans[i]) puts("Yes");
        else puts("No");
    }
    return 0;
}
```

## 例题



### CF1140F Extending Set of Points  

* 题目大意：现有一个二维平面，有一个点集 $S$，初始时 $S$ 为空；$q$ 次操作，每次往 $S$ 中加入/删除一个点 $(x, y)$，每次操作后需要输出如果对目前的集合 $S$ 的扩展集合的大小。

  对点集 $S$ 的扩展定义为若点 $(x, y)$ 满足存在一组 $a, b$ 使得 $(a, b), (a, y), (x, b) \in S$，那么将 $(x, y)$ 加入 $S$ 直至不再存在这样满足条件的 $(x, y)$。注意询问后不会真正地扩展 $S$。

* 考虑如果只有一次询问怎么做？注意到**二维平面内点的问题其实可以看作两点之间连边**。将行和列看作点，那么假设第 $x$ 行对应点 $C_x$，第 $y$ 列对应点 $R_y$，那么点集 $S$ 中存在点 $(x, y)$ 相当于将 $C_x$ 和 $R_y$ 之间连边。行和列之间连边，你想起了什么？~~天城燐音。~~**连出来的图一定是二分图。**

  那么想一想扩展中一次加入 $(x, y)$ 象征着什么？其实你可以把它看作**将一条长度为 $3$ 的增广路 $x \rightarrow b \rightarrow a \rightarrow y$ 首尾相连**。那这么扩展之后的图有什么性质？~~还是二分图（这不废话？）~~，**连完的图一定是一个完全二分图。**为什么？感性理解一下，如果是长度为 $3$ 的增广路，那么连完之后这 $4$ 个点一定是连满的，如果是长度为 $5$ 的增广路就会被分为两段长为 $3$ 的增广路，然后会有出现两条长为 $3$ 的增广路，最后一共四次连边就能让这 $6$ 个点连满（可以自己画图理解下）。那么问题就转化为了维护每个连通块内左部点和右部点的数量，相乘后加起来即可。

  这怎么维护？并查集记录每个点 $u$ 所在的连通块内左部点数量 $sz1_u$ 和右部点所在连通块内右部点数量 $sz2_u$，如果 $u$ 是左部点（这里钦定 $C_x$ 为左部点）则 $sz1_u = 1$（初始值），反之亦然。

* 多组询问？每个点相当于是有一个出现的时间段，果断线段树分治+可撤销并查集。

一些具体的实现看代码。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <stack>
#include <map>
#define ll long long
#define mr make_pair
#define pii pair<int, int>
#define fi first
#define se second
using namespace std;
const int N = 6e5 + 5;
int n = 3e5, q;
ll num[N];
map <pii, int> mp;

struct DSU{
    int sz1[N], sz2[N], fa[N];
    ll ans;
    stack <int> opt;
    void init() {
        ans = 0;
        for (int i = 1; i <= n; ++i) {
            fa[i] = i, fa[i + n] = i + n;
            sz1[i] = 1, sz2[i + n] = 1;
        }
        return ;
    }
    int getroot(int x) {
        if(fa[x] == x) return fa[x];
        return getroot(fa[x]);
    }
    void merge(int x, int y) {
        x = getroot(x), y = getroot(y);
        if(x == y) return ;
        if(sz1[x] + sz2[x] > sz1[y] + sz2[y]) swap(x, y);
        ans -= 1ll * sz1[x] * sz2[x] + 1ll * sz1[y] * sz2[y];
        sz1[y] += sz1[x], sz2[y] += sz2[x];
        ans += 1ll * sz1[y] * sz2[y];
        fa[x] = y;
        opt.push(x); return ;
    }
    void undo() {
        if(opt.empty()) return ;
        int u = opt.top(); opt.pop();
        int v = fa[u];
        ans -= 1ll * sz1[v] * sz2[v];
        sz1[v] -= sz1[u], sz2[v] -= sz2[u];
        ans += 1ll * sz1[u] * sz2[u] + 1ll * sz1[v] * sz2[v];
        fa[u] = u; return ;
    }
    void del(int cnt) {
        while(opt.size() > cnt) undo();
        return ;
    }
}D;

vector <pii> tr[N << 2];

void modify(int cur, int l, int r, int x, int y, pii e) {
    if(x <= l && r <= y) {
        tr[cur].push_back(e); return ;
    }
    int mid = (l + r) >> 1;
    if(x <= mid) modify(cur << 1, l, mid, x, y, e);
    if(y > mid) modify(cur << 1 | 1, mid + 1, r, x, y, e);
    return ;
}

void query(int cur, int l, int r) {
    int cnt = D.opt.size();
    for (int i = 0; i < tr[cur].size(); ++i) {
        int u = tr[cur][i].fi, v = tr[cur][i].se;
        D.merge(u, v);
    }
    if(l == r) {
        num[l] = D.ans, D.del(cnt);
        return ;
    }
    int mid = (l + r) >> 1;
    query(cur << 1, l, mid);
    query(cur << 1 | 1, mid + 1, r);
    D.del(cnt); return ;
}

int main() {
    scanf("%d", &q);
    D.init();
    for (int i = 1; i <= q; ++i) {
        int u, v; scanf("%d %d", &u, &v);
        v += n;
        pii e = mr(u, v);
        if(mp[e]) {
            modify(1, 1, q, mp[e], i - 1, e);
            mp.erase(e);
        }
        else mp[e] = i;
    }
    for (map <pii, int> :: iterator it = mp.begin(); it != mp.end(); ++it) {
        modify(1, 1, q, (*it).se, q, (*it).fi);
    }
    query(1, 1, q);
    for (int i = 1; i <= q; ++i) {
        printf("%lld ", num[i]);
    }
    return 0;
}
```

### P5227 连通图

板板板，但是调了很久。跟前两题套路一致，很简单，对于每个集合，我们把它拆分为在时刻 $2i - 1$ 删去一些边，时刻 $2i$ 加入一些边，然后稍微 map 处理一下就可以变成每条边有一些出现的时间区间，线段树分治即可。怎么判断连通性？随便找一个根节点 $i$，如果 $i$ 所在连通块大小为 $n$，那么就是连通图。(我把 ```cur << 1 | 1``` 写成了 ```cur >> 1 | 1```，调了 $40$ min，是不是很厉害？）

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <stack>
#include <map>
#define ll long long
#define pii pair<int, int>
#define mr make_pair
#define fi first
#define se second
using namespace std;
const int N = 1e5 + 5, M = 2e5 + 5;
int n, m, k, c[N], a[5], qu[N];
bool ans[N << 1];
pii e[M];
map <int, int> mp;

struct DSU{
    int fa[N], siz[N];
    stack <int> opt;
    void init() {
        for (int i = 1; i <= n; ++i) {
            fa[i] = i, siz[i] = 1;
        }
        return ;
    }
    int getroot(int x) {
        if(fa[x] == x) return x;
        return getroot(fa[x]);
    }
    void merge(int x, int y) {
        x = getroot(x), y = getroot(y);
        if(x == y) return ;
        if(siz[x] > siz[y]) swap(x, y);
        siz[y] += siz[x], fa[x] = y;
        opt.push(x); return ;
    }
    void undo() {
        if(opt.empty()) return ;
        int u = opt.top(); opt.pop();
        siz[fa[u]] -= siz[u], fa[u] = u;
        return ;
    }
    void del(int cnt) {
        while(opt.size() > cnt) undo();
        return ;
    }
}D;

vector <int> tr[N << 3];

void modify(int cur, int l, int r, int x, int y, int e) {
    if(x <= l && r <= y) {
        tr[cur].push_back(e); return ;
    }
    int mid = (l + r) >> 1;
    if(x <= mid) modify(cur << 1, l, mid, x, y, e);
    if(y > mid) modify(cur << 1 | 1, mid + 1, r, x, y, e);
    return ;
}

void query(int cur, int l, int r) {
    int cnt = D.opt.size();
    for (int i = 0; i < tr[cur].size(); ++i) {
        int u = e[tr[cur][i]].fi, v = e[tr[cur][i]].se;
        D.merge(u, v);
    }
    if(l == r) {
        int f = D.getroot(1);
        if(D.siz[f] == n) ans[l] = 1;
        D.del(cnt); return ;
    }
    int mid = (l + r) >> 1;
    query(cur << 1, l, mid);
    query(cur << 1 | 1, mid + 1, r);
    D.del(cnt); return ;
}

int main() {
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= m; ++i) {
        scanf("%d %d", &e[i].fi, &e[i].se);
        mp[i] = 1;
    }
    D.init();
    scanf("%d", &k);
    for (int i = 1; i <= k; ++i) {
        scanf("%d", &c[i]);
        qu[i] = i * 2 - 1;
        for (int j = 1; j <= c[i]; ++j) {
            scanf("%d", &a[j]);
            int l = mp[a[j]], r = i * 2 - 2;
            if(l <= r) modify(1, 1, k * 2, l, r, a[j]);
            mp.erase(a[j]);
        }
        for (int j = 1; j <= c[i]; ++j) {
            mp[a[j]] = i * 2;
        }
    }
    for (map <int, int> :: iterator it = mp.begin(); it != mp.end(); it++) {
        int l = (*it).se, r = 2 * k;
        if(l <= r) modify(1, 1, k * 2, l, r, (*it).fi);
    }
    query(1, 1, k * 2);
    for (int i = 1; i <= k; ++i) {
        if(ans[qu[i]]) puts("Connected");
        else puts("Disconnected");
    }
    return 0;
}
```



---

## 作者：mjsdnz (赞：0)

## 思路

看到删边，就知道这题不是动态树就是线段树分治。由于本蒟蒻不会调动态树，所以直接莽线段树分治了。

由于线段树分治擅长加边，所以我们把删边转换为加边。我们将每个集合看做时间，每条边的加边时间就是除了所在集合以外的所有时间。我们可以每条边开个 vector 来记录该边的删除时间，加边时间就是上一次删边时间加一到下一次删边时间减一。

统计是否连通很简单，可以直接查询随便一个联通块的大小是不是 $n$ 就行了。

写代码的时候注意把每条边的起始位置和结束位置，并查询一定要写按秩合并，不要手贱写成路径压缩。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
struct node {
	int u, v;
	node(int u = 0, int v = 0): u(u), v(v) {}
} e[N];
struct ST {
	int u, f, s;
	ST(int u = 0, int f = 0, int s = 0) : u(u), f(f), s(s) {}
} st[N << 2];
int top;
int fa[N], siz[N];
int n, m, k;
vector<node>t[N << 2];
int cnt, ans[N];
int kkcnt;
#define ls(x) x<<1
#define rs(x) x<<1|1
int find(int x) {
	return x == fa[x] ? x : find(fa[x]);
}
void link(int x, int y) {
	int u = find(x), v = find(y);
	if (u == v) return;
	if (siz[u] > siz[v]) swap(u, v);
	st[++top] = ST(u, fa[u], siz[u]);
	st[++top] = ST(v, fa[v], siz[v]);
	fa[u] = v, siz[v] += siz[u];
	if (!(siz[v]^n)) cnt++;
}
void back() {
	int u = st[top].u, f = st[top].f, s = st[top].s;
	fa[u] = f, siz[u] = s, --top;
}
void add(int l, int r, int ql, int qr, int p, node x) {
	if (ql > qr) return;
	if (l >= ql && r <= qr) return (void) t[p].push_back(x);
	int mid = (l + r) >> 1;
	if (ql <= mid) add(l, mid, ql, qr, ls(p), x);
	if (qr > mid) add(mid + 1, r, ql, qr, rs(p), x);
}
void work(int l, int r, int p) {
	int nowtop = top, nowcnt = cnt;
	for (auto no : t[p]) {
		link(no.u, no.v);
	}
	int mid = (l + r) >> 1;
	if (l < r) work(l, mid, ls(p)), work(mid + 1, r, rs(p));
	else ans[l] = (cnt > 0);
	while (top > nowtop) back();
	cnt = nowcnt;
}
vector<int>pos[N];
int main() {
	ios::sync_with_stdio(false);
	cin.tie();
	cout.tie();
	cin >> n >> m;
	for (int i = 1; i <= n; i++) fa[i] = i, siz[i] = 1;
	for (int i = 1; i <= m; i++) {
		cin >> e[i].u >> e[i].v;
	}
	cin >> k;
	for (int i = 1; i <= m; i++) {
		pos[i].push_back(0);
	}
	for (int i = 1; i <= k; i++) {
		int ww;
		cin >> ww;
		while (ww--) {
			int aa;
			cin >> aa;
			pos[aa].push_back(i);
		}
	}
	for (int i = 1; i <= m; i++) {
		pos[i].push_back(k + 1);
	}
	for (int i = 1; i <= m; i++) {
		int sz = pos[i].size();
		for (int j = 0; j < sz - 1; j++)
			add(1, k, pos[i][j] + 1, pos[i][j + 1] - 1, 1, e[i]);
	}
	work(1, k, 1);
	for (int i = 1; i <= k; i++) cout << (ans[i] ? "Connected" : "Disconnected") << endl;
}
```

---

## 作者：出言不逊王子 (赞：0)

如果我们按照题目的说法去删边，那么我们会得到一个新图。

如何判断一个新图的连通性？似乎只能重新跑一次搜索，复杂度上天。

观察到 $c\le 4$，所以一条边会在大部分时间内存在。

因此我们可以把“删边”改成“加边”。

所以我们可以把问题变成：给定一个图，每条边在**一个特定时间**存在，求**每一时刻**，图是否是连通图。

观察时间和时刻，我们不难想到用线段树分治解决。总的时间个数是 $kc$ 个，时间复杂度足够通过。

我们思考什么时候图是连通图：图只有一个连通块，连通块的大小是点数 $n$。

很显然记录连通块的大小比记录连通块的个数简单，那么我们就可以用并查集维护边和连通块的关系了。

那么我们就对时间轴建立一棵线段树，每次将加边区间丢到线段树上面，在叶子节点判断当前并查集是否满足连通块的大小是 $n$ 这一限制。

但是题目给了**删边时刻**，所以整个时间除了**删边时刻**其他都是**边存在的时间**。

具体地，假如一条边消失的时刻是 $t_1$ 和 $t_2$，则 $[1,t_1)$ 与 $(t_2,k]$ 都是这条边存在的时间。

用一个 vector 记录这些消失的时刻，则该边相邻的两个消失时刻的差就是边存在的时间了，很方便。

代码实现上，要记住不能路径压缩，因为并查集要撤销。

不仅如此，可以把半闭半开区间改成全开的区间，在丢入线段树时再作加减处理。

```cpp
#include<bits/stdc++.h>
#define fs(i,x,y,z) for(int i=x;i<=y;i+=z)
#define ft(i,x,y,z) for(int i=x;i>=y;i+=z)
#define ll long long
#define ull unsigned long long
#define db double
#define ms(a,b) memset(a,b,sizeof(a))
#define sz(a) sizeof(a)
#define mid ((l+r)>>1) 
#define ls (now<<1)
#define rs (now<<1|1)
using namespace std;
const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
const int N=600001,inf=0x3f3f3f3f;
inline int read(){
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
vector<int> tme[N];//每条边的出现时间表 
int n,m,u[N],v[N],k,e[N],c[N],res[N],lst[N],q,pre[N];//每次操作把e[i]放成c[i]，lst[i]为第i条边保持当前颜色的最后时间 
//pre[i]表示第i条边在进行本次操作时的颜色 
struct node{vector<int> czs;}tr[N<<2];//czs放的是此时此刻哪些边在场 
void upd(int l,int r,int now,int ql,int qr,int val){
	if(l>r||ql>qr) return;//针对一开始就消失的情况 
	if(ql<=l&&r<=qr) return void(tr[now].czs.push_back(val));
	if(ql<=mid) upd(l,mid,ls,ql,qr,val);
	if(qr>mid) upd(mid+1,r,rs,ql,qr,val);
}
struct cz{int x,y,s;};//c是操作的颜色 
stack<cz> st;//这个栈存了每个数被A上去前是谁 
struct dsu{
	int fa[N<<1],sz[N<<1];
	void init(int n){fs(i,1,n,1) fa[i]=i,sz[i]=1;}
	int find(int x){return fa[x]==x?x:find(fa[x]);}//不能路径压缩！
	void mrg(int x,int y){
		x=find(x),y=find(y);//if(x==y) return;
		if(sz[x]<sz[y]) swap(x,y);//保证sz[x]>=sz[y] 
		fa[y]=x;if(x!=y) sz[x]+=sz[y];
		st.push({x,y,sz[y]});
	} 
	void del(){
		cz now=st.top();st.pop();
		fa[now.y]=now.y;sz[now.x]-=now.s;
		sz[now.y]=now.s;
	}
}d; 
void solve(int l,int r,int now){
	int cur=st.size();//现在的大小
	for(auto i:tr[now].czs){//i是当前这个操作 
		int x=u[i],y=v[i];//,col=c[i];
		d.mrg(x,y);//,d[col].mrg(x,y+n,col);//x和y互相对立 
	}
	if(l==r){
		if(d.sz[d.find(1)]==n) puts("Connected");
		else puts("Disconnected");
		while(st.size()>cur) d.del();
		return;
	}
	solve(l,mid,ls);solve(mid+1,r,rs);
	while(st.size()>cur) d.del(); //时间轴跑完了，该回溯了，把这一层的所有操作都删了吧
}
int main(){
	n=read(),m=read();
	d.init(2*n);
	fs(i,1,m,1) u[i]=read(),v[i]=read(),tme[i].push_back(0);//lst[i]=q;//到q为止 
	q=read();
	fs(i,1,q,1){
		int x=read();
		fs(j,1,x,1) tme[read()].push_back(i);
	}
	fs(i,1,m,1) tme[i].push_back(q+1);
	fs(i,1,m,1){
		int pq=tme[i].size();
		fs(j,0,pq-1,1) upd(1,q,1,tme[i][j]+1,tme[i][j+1]-1,i);
	}
	solve(1,q,1); 
//	fs(i,1,q,1) printf("%s\n",res[i]>0?"YES":(res[i]==0?"NO":"QwQ")); 
	return 0;
}
```

---


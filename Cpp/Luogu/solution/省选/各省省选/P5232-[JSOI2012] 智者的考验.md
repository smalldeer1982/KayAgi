# [JSOI2012] 智者的考验

## 题目描述

公元$1371$年，太祖下令在北极阁上大建庙宇，短短几年，鸡笼山上便建成了帝王庙、关公庙、真武庙、功臣庙、蒋王庙、都城隍庙、卞壶庙、忠烈庙、刘越王庙、曹武惠王庙共十座庙宇，统称为“十庙”。 

后来，为了方便人们来鸡笼山进香礼佛，太祖下令疏通了鸡笼山下已淤塞多年的潮沟。于是，便有了“进香河”。 

然而并不是所有人都可以来鸡笼山的，太祖在进香河上修建了一座石桥，中间悬挂了一块高$Rx$宽$Ry$的机关格图（如下图所示）。所有格子都是活动可翻转的，一面是白色，一面是黑色，这里我们用$0$表示白色，用$1$表示黑色。初始情况下，所有格子都是白色面朝前的。有$Rx+Ry$个机关按钮，对应$Rx$行和$Ry$列。一个按钮一旦触发，就会引发对应的一行或一列的格子同时翻转。
 
![](https://cdn.luogu.com.cn/upload/pic/52643.png)

同时，善于识天象的谋臣刘基给出了一种黑白状态，称之为“厄运星”。每一位过往前去鸡笼山的人都需要触发且只触发一个按钮，触发后，如果来访者呈“厄运星”形状，则不允许通过。 

每一天要来鸡笼山的人数$N$是事先就知道的，同时天朝神威浩荡，每一位来者一开始总是有很大概率触发编号为$1$的按钮，我们不妨用数列$A_1$,$A_2$,$\dots$,$A_N$来表示，问题保证了初始时候的$A$数列全为$1$。同时在整个问题中，$A_i$满足$1 \leq A_i \leq Rx+Ry$。太祖很关心那些不允许去鸡笼山的人数。于是他时不时就会询问关于“某一段时间内会有多少人不能通过“厄运星”的考验”。然而那些前来鸡笼山的文人墨客并不愿意如此单一的操作。来访者有可能会突然决定修改自己的触发按钮。更麻烦的情况，结伴而来的连续若干人会突然决定修改触发按钮并且都去触发同一个按钮。 

现在这麻烦的问题交给了你。 

## 说明/提示

对于$40\%$的数据，$N \leq 5000$,$M \leq 10000$。

存在$70\%$的数据，$N \leq 130000$,$M \leq 30000$。

对于$100\%$的数据，$N \leq 1000000$，$M \leq 120000$，$Rx \leq 2$，$Ry \leq 3$。

## 样例 #1

### 输入

```
2 3 
0 0 1 
1 1 0 
7 4 
1 1 7 
0 2 3 
0 3 4	
1 1 7```

### 输出

```
0
3```

# 题解

## 作者：龙行龘龘 (赞：3)

# 水题为什么没人做???

问题显然可以转化成带修地查询区间内前缀异或和为给定数的数量

根据题面来看,把所有按钮都取反跟原来是一样，也就是2^4=16种状态

区间修改为某个数的影响最多只有1次（两两抵消）

线段树上打打标记就可以了...

顺便献上我的blog:https://www.luogu.org/blog/Root-std-admin/

只给伪代码了嗷:
```cpp
void build(int &p,int l,int r) {
	if (p==0) p=++num,t[p].l=t[p].r=t[p].sum=t[p].y=0,t[p].a=-1;
	t[p].c[N[0]]=((r-l)>>1)+(!(l&1)||!(r&1));
	t[p].c[N[o[0]]]=((r-l)>>1)+((l&1)||(r&1));
	t[p].sum=((((r-l)>>1)+((l&1)||(r&1)))&1)*o[0];
	if (l==r) return;
	int mid=l+r>>1;
	build(t[p].l,l,mid);
	build(t[p].r,mid+1,r);
}
void pd(int p,int l,int r) {
	if (t[p].a!=-1) {
		if (t[p].l) t[t[p].l].a=t[p].a,t[t[p].l].V=t[p].V,t[t[p].l].Q=t[p].Q,t[t[p].l].y=0;
		if (t[p].r) t[t[p].r].a=t[p].a,t[t[p].r].V=t[p].V,t[t[p].r].Q=t[p].Q,t[t[p].r].y=0;
		memset(t[p].c,0,sizeof(t[p].c));
		t[p].c[N[t[p].V]]=((r-l)>>1)+(!(l-t[p].Q&1)||!(r-t[p].Q&1));
		t[p].c[N[t[p].a^t[p].V]]=((r-l)>>1)+((l-t[p].Q&1)||(r-t[p].Q&1));
		t[p].sum=((((r-l)>>1)+((l-t[p].Q&1)||(r-t[p].Q&1)))&1)*t[p].a^((r-l+1&1)*t[p].V);
		t[p].a=-1;
	}
}
void up(int p,int l,int r) {
	int mid=l+r>>1;
	pd(t[p].l,l,mid);
	pd(t[p].r,mid+1,r);
	t[p].sum=t[t[p].l].sum^t[t[p].r].sum^(((mid-l+1)&1)*t[t[p].l].y)^(((r-mid)&1)*t[t[p].r].y);
	for (int i=0; i<16; i++) t[p].c[i]=t[t[p].l].c[N[s[i]^t[t[p].l].y]]+t[t[p].r].c[N[s[i]^t[t[p].r].y]];
}
void cg(int p,int l,int r,int po,int v) {
	if (po<=l) t[p].y^=v;
	else {
		pd(p,l,r);
		int mid=l+r>>1;
		cg(t[p].r,mid+1,r,po,v);
		if (mid>=po) cg(t[p].l,l,mid,po,v);
		up(p,l,r);
	}
}
int ask(int p,int l,int r,int po) {
	if (t[p].a!=-1) return (t[p].a*(po-t[p].Q&1))^t[p].V^t[p].y;
	if (l==r) return t[p].sum^t[p].y;
	int mid=l+r>>1;
	if (po<=mid) return ask(t[p].l,l,mid,po)^t[p].y;
	else return ask(t[p].r,mid+1,r,po)^t[p].y;
}
int que(int p,int l,int r,int L,int R,int v) {
	pd(p,l,r);
	v^=t[p].y;
	if (L==l&&R==r) return t[p].c[N[v]];
	int mid=l+r>>1;
	if (R<=mid) return que(t[p].l,l,mid,L,R,v);
	else if (L>mid) return que(t[p].r,mid+1,r,L,R,v);
	else
		return que(t[p].l,l,mid,L,mid,v)+que(t[p].r,mid+1,r,mid+1,R,v);
}
void ca(int p,int l,int r,int L,int R,int v,int V,int Q) {
	if (L==l&&R==r) {
		t[p].a=v;
		t[p].V=V;
		t[p].y=0;
		t[p].Q=Q;
		t[p].c[N[V]]=((r-l)>>1)+(!(l-Q&1)||!(r-Q&1));
		t[p].c[N[v^V]]=((r-l)>>1)+((l-Q&1)||(r-Q&1));
		t[p].sum=(((((r-l)>>1)+((l-Q&1)||(r-Q&1)))&1)*v)^((r-l+1&1)*V);
	} else {
		pd(p,l,r);
		V^=t[p].y;
		int mid=l+r>>1;
		if (R<=mid) ca(t[p].l,l,mid,L,R,v,V,Q);
		else if (L>mid) ca(t[p].r,mid+1,r,L,R,v,V,Q);
		else
			ca(t[p].l,l,mid,L,mid,v,V,Q),ca(t[p].r,mid+1,r,mid+1,R,v,V,Q);
		up(p,l,r);
	}
}
int main() {
	ios_base::sync_with_stdio(false);
	register int i,j;
	rx=read();
	ry=read();
	n=0;
	for (i=0; i<rx; i++)
		for (j=0; j<ry; j++) o[i]^=1<<(i*ry+j),o[j+rx]^=1<<(i*ry+j),q^=read()<<(i*ry+j);
	n=read();
	m=read();
	s[bo=num=0]=0;
	for(; bo<=num;) {
		for (i=0; i<rx+ry; i++) {
			for (j=0; j<=num; j++)
				if (s[j]==(s[bo]^o[i])) break;
			if (j>num) s[++num]=s[bo]^o[i];
			to[bo][i]=j;
		}
		bo++;
	}
	for (i=0; i<64; i++) N[i]=-1;
	for (i=0; i<=num; i++) N[s[i]]=i;
	num=0;
	build(ro,1,n);
	while (m--) {
		bo=read();
		if (bo==0) bo=read(),cg(ro,1,n,bo,o[read()-1]^ask(ro,1,n,bo)^(bo==1?0:ask(ro,1,n,bo-1)));
		else if (bo==1) if (bo=read(),x=read(),N[q]==-1) puts("0");
			else printf("%d\n",que(ro,1,n,bo,x,q));
		else if (rx=read(),ry=read(),x=o[read()-1],cg(ro,1,n,ry+1,ask(ro,1,n,ry)^(((ry-rx+1)&1)*x)),ca(ro,1,n,rx,ry,x,0,rx-1),rx-1) cg(ro,1,n,rx,ask(ro,1,n,rx-1));
	}
	return 0;
}
```
哦对,MN看数据范围,好像是1e6吧...

真心感谢大家观看,谢谢!!!

---

## 作者：Exp10re (赞：2)

线段树可爱捏。

## 解题思路

考虑将黑白格子加权，然后将每一种状态用二进制表示。

尝试对状态进行分析，容易发现状态数只有 $2^{Rx+Ry-1}$ 个。

状态用二进制表示显然可以将每一次操作转化成进行一次异或操作。

图例：

![](https://cdn.luogu.com.cn/upload/image_hosting/h9u78p3d.png)

如图所示，使用按钮 $4$ 等价于将先前的状态异或 $18$。

考虑维护前缀的异或和，如此，一次询问等价于查询目标状态的二进制表示在前缀异或和数组中出现的次数。显然可以线段树维护。

这里维护的细节其实很多：

- 询问直接查询出现次数即可。

- 修改操作作用于前缀异或和等价于一次区间覆盖和一次区间异或。具体而言：

1. 简单分析会发现覆盖操作在奇数位和偶数位的值不同。如下：

$$a_i=
\begin{cases}
a_{l-1} &\ (l-i+1)\nmid 2 \\
a_{l-1} \text{\textasciicircum} c &\ (l-i+1)\mid 2
\end{cases}$$

即：当 $i$ 之前已经覆盖了偶数个相同数时 $a_i=a_{l-1}$，否则还要异或上覆盖的数。

2. 区间异或的操作具体而言就是 $a_{r,\cdots,n}$ 异或上修改前的 $a_{r}$，再异或修改后的 $a_{r}$。

## 代码

代码有注释。

**相当长**，请注意。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1001000,MAXB=229,MAXP=19;
struct segtree
{
	int sum[MAXP],lazy1,lazy1a,lazy1b,lazy2,l,r,len;
};
//lazy1 是覆盖，lazy2 是区间异或。 
//lazy1a 和 lazy1b 的意思是：按照 abababab... 的顺序将 lazy1a(b) 放入区间。 
segtree a[MAXN*4+1];
int book[MAXB],rec[MAXP],work[MAXP],rx,ry,tmap[MAXB][MAXB],tag[MAXB],m,n,q,w[MAXP];
void pushup(int x)
{
	int i;
	for(i=1;i<=16;i++)
	{
		a[x].sum[i]=a[x*2].sum[i]+a[x*2+1].sum[i];
	}
	return;
}
void pushdown(int x)
{
	int i;
	if(a[x].lazy1!=0)
	{
		for(i=1;i<=16;i++)
		{
			a[x*2].sum[i]=a[x*2+1].sum[i]=0;
		}
		a[x*2].sum[book[a[x].lazy1a]]=(a[x*2].len+1)/2;
		a[x*2].sum[book[a[x].lazy1b]]=a[x*2].len/2;
		a[x*2].lazy1=1;
		a[x*2].lazy2=0;
		a[x*2].lazy1a=a[x].lazy1a;
		a[x*2].lazy1b=a[x].lazy1b;
		if(a[x*2].len%2==1)//如果左端点的长度为奇数，那么右端点的第一个数就是左端点的第二个数。 
		{
			swap(a[x].lazy1a,a[x].lazy1b);
		}
		a[x*2+1].sum[book[a[x].lazy1a]]=(a[x*2+1].len+1)/2;
		a[x*2+1].sum[book[a[x].lazy1b]]=a[x*2+1].len/2;
		a[x*2+1].lazy1=1;
		a[x*2+1].lazy2=0;
		a[x*2+1].lazy1a=a[x].lazy1a;
		a[x*2+1].lazy1b=a[x].lazy1b;
		a[x].lazy1=0;
	}
	if(a[x].lazy2!=0)
	{
		for(i=1;i<=16;i++)
		{
			w[i]=a[x*2].sum[book[rec[i]^a[x].lazy2]];
		}
		for(i=1;i<=16;i++)
		{
			a[x*2].sum[i]=w[i];
		}
		a[x*2].lazy2^=a[x].lazy2;
		for(i=1;i<=16;i++)
		{
			w[i]=a[x*2+1].sum[book[rec[i]^a[x].lazy2]];
		}
		for(i=1;i<=16;i++)
		{
			a[x*2+1].sum[i]=w[i];
		}
		a[x*2+1].lazy2^=a[x].lazy2;
		a[x].lazy2=0;
	}
	return;
}
void build(int x,int l,int r)
{
	a[x].l=l;
	a[x].r=r;
	a[x].len=r-l+1;
	if(l==r)
	{
		if(l%2==1)
		{
			a[x].sum[book[work[1]]]=1;
		}
		else
		{
			a[x].sum[book[0]]=1;
		}
		return;
	}
	int mid=(l+r)/2;
	build(x*2,l,mid);
	build(x*2+1,mid+1,r);
	pushup(x);
	return;
}
void inc1(int x,int l,int r,int ca,int cb)
{
	if(l>r)
	{
		return;
	}
	int i;
	if(a[x].l==l&&a[x].r==r)
	{
		for(i=1;i<=16;i++)
		{
			a[x].sum[i]=0;
		}
		a[x].sum[book[ca]]=(a[x].len+1)/2;
		a[x].sum[book[cb]]=a[x].len/2;
		a[x].lazy1=1;
		a[x].lazy2=0;
		a[x].lazy1a=ca;
		a[x].lazy1b=cb;
		return;
	}
	pushdown(x);
	int mid=(a[x].l+a[x].r)/2;
	if(l<=mid)
	{
		inc1(x*2,l,min(mid,r),ca,cb);
	}
	if(r>=mid+1)
	{
		if(l<=mid&&(a[x*2].r-l+1)%2==1)//如果左区间长度为奇数，那么右区间的第一个数就是左端点的第二个数。 
		{
			swap(ca,cb);
		}
		inc1(x*2+1,max(l,mid+1),r,ca,cb);
	}
	pushup(x);
	return;
}
void inc2(int x,int l,int r,int c)
{
	if(l>r)
	{
		return;
	}
	int i;
	if(a[x].l==l&&a[x].r==r)
	{
		for(i=1;i<=16;i++)
		{
			w[i]=a[x].sum[book[rec[i]^c]];
		}
		for(i=1;i<=16;i++)
		{
			a[x].sum[i]=w[i];
		}
		a[x].lazy2^=c;
		return;
	}
	pushdown(x);
	int mid=(a[x].l+a[x].r)/2;
	if(l<=mid)
	{
		inc2(x*2,l,min(mid,r),c);
	}
	if(r>=mid+1)
	{
		inc2(x*2+1,max(l,mid+1),r,c);
	}
	pushup(x);
	return;
}
int query1(int x,int p)
{
	if(p==0)
	{
		return 0;
	}
	int i;
	if(a[x].l==p&&a[x].r==p)
	{
		for(i=1;i<=16;i++)
		{
			if(a[x].sum[i]!=0)
			{
				return rec[i];
			}
		}
		return 0;
	}
	pushdown(x);
	int mid=(a[x].l+a[x].r)/2;
	if(p<=mid)
	{
		return query1(x*2,p);
	}
	if(p>=mid+1)
	{
		return query1(x*2+1,p);
	}
	return 0;
}
int query2(int x,int l,int r,int c)
{
	if(l>r)
	{
		return 0;
	}
	if(a[x].l==l&&a[x].r==r)
	{
		return a[x].sum[book[c]];
	}
	pushdown(x);
	int mid=(a[x].l+a[x].r)/2,ans=0;
	if(l<=mid)
	{
		ans+=query2(x*2,l,min(r,mid),c);
	}
	if(r>=mid+1)
	{
		ans+=query2(x*2+1,max(l,mid+1),r,c);
	}
	return ans;
}
void dfs(int x,int c)
{
	if(x>rx+ry)
	{
		if(tag[c]==0)
		{
			tag[c]=1;
			m++;
			book[c]=m;
			rec[m]=c;
		}
		return;
	}
	dfs(x+1,c);
	dfs(x+1,c^work[x]);
	return;
}
void init()
{
	int i,j,t=1;
	for(i=1;i<=rx;i++)
	{
		for(j=1;j<=ry;j++)
		{
			tmap[i][j]=t;
			t*=2;
		}
	}
	t=1;
	for(i=1;i<=rx;i++)
	{
		for(j=1;j<=ry;j++)
		{
			work[t]+=tmap[i][j];
		}
		t++;
	}
	for(j=1;j<=ry;j++)
	{
		for(i=1;i<=rx;i++)
		{
			work[t]+=tmap[i][j];
		}
		t++;
	}
	dfs(1,0);
	return;
}
int main()
{
//	freopen("P5232.in","r",stdin);
//	freopen("P5232.out","w",stdout);
	int i,j,T,t,t1,t2,t3,ta,tb,opt;
	scanf("%d%d",&rx,&ry);
	init();
	T=0;
	for(i=1;i<=rx;i++)
	{
		for(j=1;j<=ry;j++)
		{
			scanf("%d",&t);
			T+=t*tmap[i][j];
		}
	}
	scanf("%d%d",&n,&q);
	build(1,1,n);
	for(i=1;i<=q;i++)
	{
		scanf("%d%d%d",&opt,&ta,&tb);
		if(opt==0)
		{
			t1=query1(1,ta-1);
			t2=query1(1,ta);
			inc1(1,ta,ta,work[tb]^t1,t1);
			t3=query1(1,ta);
			inc2(1,ta+1,n,t2^t3);
		}
		else if(opt==1)
		{
			printf("%d\n",query2(1,ta,tb,T));
		}
		else
		{
			scanf("%d",&t);
			t1=query1(1,ta-1);
			t2=query1(1,tb);
			inc1(1,ta,tb,work[t]^t1,t1);
			t3=query1(1,tb);
			inc2(1,tb+1,n,t2^t3);
		}
	}
	return 0;
}
```

---


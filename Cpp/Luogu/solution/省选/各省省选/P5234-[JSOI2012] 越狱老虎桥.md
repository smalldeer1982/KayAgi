# [JSOI2012] 越狱老虎桥

## 题目背景

这里，是美丽的南京；这里，是秀美的进香河；这里是安逸的老虎桥。 

如果说进香河的美，美在其秀美的风光，倒不如说是美在了那惬意的南京古典小巷式生活。如果说进香河的迷人，在其淳朴的民风，倒不如说是那被历史掩埋了的秘密吸引着人们好奇的心。 

也许很多人都还记得，老虎桥监狱，北洋时期江南最大的监狱，在近一个世纪中，面对满清、北洋、民国、新中国几朝兴衰，名称屡次更替，沧桑尽显其中。 

现在的人们，恐怕很难相信，到底有多少惊心动魄的事情曾经就在这里上演。 

## 题目描述

那是$1948$年的冬天，南京地下组织的一支小分队决定偷袭老虎桥监狱，救出被困的数百名人员。那时的老虎桥监狱，被$N$层电网围了起来，由内而外，依次编号为$1$,$2$,$\dots$,$N$。第$1$层电网接有高压电。有$M$条高压线，连接了所有电网，其中第$i$条高压线连接了第$a_i$和$b_i$层电网，如果要破坏第$i$条高压线，需要至少动用$T_i$位特工。面对这么多层电网，偷袭小分队犯愁了。至少需要破坏一层电网，否则是无法偷袭成功的。
 
然而，狡猾的间谍却知道了这件事情，为了破坏偷袭计划，敌人秘密地又增加了一条高压线，不让偷袭小分队的成员发现。 

为了能够偷袭成功，不论新增的这一条秘密高压线是连接哪两层电网的，小分队都必须要破坏且仅破坏一条高压线，使得至少有一层电网不通电。注意，对于新增的高压线，我们并不知道需要多少位特工才能成功破坏。现在的问题是，偷袭小分队至少需要多少名特工呢？
 
决战就在今夜！

## 说明/提示

对于$30\%$的数据，$N \leq 200$，$M \leq 250$。

对于$70\%$的数据，$N \leq 50000$，$M \leq 100000$。

对于$100\%$的数据，$N \leq 500000$，$M \leq 1000000$，$T \leq 100000$。

对于第二组样例，新增的高压线只有可能出现在$2$和$3$，$2$和$4$或$3$和$4$之间。

如果出现在了$2$和$3$之间，则只能破坏$1$和$4$之间的高压线；如果出现在$2$和$4$之间，则只能破坏$1$和$3$之间的高压线；如果出现在$3$和$4$之间，则只能破坏$1$和$2$之间的高压线。

所以，至少需要出动$3$位特工，才能应付所有可能情况。

## 样例 #1

### 输入

```
3 2
1 2 1
2 3 2```

### 输出

```
-1```

## 样例 #2

### 输入

```
4 3
1 2 1
1 3 2
1 4 3```

### 输出

```
3```

# 题解

## 作者：lenlen (赞：22)

前言:~~好多题解被 hack 了啊。~~

### Problem 

题目大意：给定一张图，$A$ 先添加 $1$ 条边，$B$ 再删去一条边使得图不连通，$A$ 要最大化删除边的权值，$B$ 要最小化删除边的权值，问最终的权值是多少。

数据范围： $n \leq 5 \times 10^5,m \leq 10^6$。

### Solution

前置芝士：边双连通分量。

显然，边双中的边是肯定不能删的，因为删除了也并不会使图不连通。所以我们有个自然的想法，我们可以把边双缩点，在重新建图，这样我们就简化为了树上问题。

然后我们考虑树上怎么做，想一想会发现，$A$ 的操作链接 $i,j$ 等价于将树上 $i,j$ 缩点之后的编号 $i',j'$ 链上的边去掉了，因为加边后这条链会构成一个边双，删除边双中的任意一个点都是无法使图不连通的，这个很显然。

然后我们可以考虑，从小到大枚举每一条边，看看枚举的这条边和之前的边能否构成一条链，如果不能构成那么显然这条边就是答案，否则若所有边都可以构成一条链，那么输出 $-1$ 即可。

至于如何判断能否构成链，可以发现，我们以最小的边的任意一个端点作为根节点，那么除了根节点，显然每一个点只能有一个点作为它的儿子，若新加边的端点往上跳，若跳到一个点有儿子且不是自己，那么就够不成链。根节点要特判一下。


至于时间复杂度，本来我想用倍增的，但是我们可以发现，每一个点只会被更新一次，更新第二次要么直接退出（即发现构不成链），或者不用往上跳了（显然，当前节点满足，祖先节点显然不影响）。所以暴力跳是均摊的复杂度，是比非均摊的倍增还快的。

结合代码感性理解一下哈！

~~截止 $2023.2.9$，暂时过了所有 hack。~~

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+7232;
int n,m,x,y,z;
struct hl{
	int v,nxt,w;
}e[N];
struct len{
	int u,v,w;
}t[N];
int h[N],cnt=1;
bitset<N> vis;
void add(int u,int v,int w)
{
	e[++cnt].v=v;e[cnt].nxt=h[u];h[u]=cnt;e[cnt].w=w;
}
int mi(int x,int y){return x<y?x:y;}
int dfn[N],low[N],tot,now;
void tarjan(int x,int fx)
{
	dfn[x]=low[x]=++tot;
	for(int i=h[x];i;i=e[i].nxt)
	{
		if(e[i].v==fx) continue;
		if(!dfn[e[i].v])
		{
			tarjan(e[i].v,x);
			low[x]=mi(low[x],low[e[i].v]);
			if(low[e[i].v]>dfn[x]) vis[i]=vis[i^1]=1;
		}
		else low[x]=mi(low[x],dfn[e[i].v]);
	}
}
int ecc[N];
void dfs(int x)
{
	ecc[x]=now;
	for(int i=h[x];i;i=e[i].nxt)
	{
		if(vis[i]||ecc[e[i].v]) continue;
		dfs(e[i].v);
	}
}
bool cmp(len x,len y)
{
	return x.w<y.w;
}
int fa[N],dis[N],dep[N],son;
void dfss(int x,int fx)
{
	fa[x]=fx;dep[x]=dep[fx]+1;
	for(int i=h[x];i;i=e[i].nxt)
	{
		if(e[i].v==fx) continue;
		dfss(e[i].v,x);
 	}
}
int num;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);add(y,x,z);
		t[i]={x,y,z};
	}
	for(int i=1;i<=n;i++) if(!dfn[i]) tarjan(i,i);
	for(int i=1;i<=n;i++) if(!ecc[i]) ++now,dfs(i);//找边双
	memset(h,0,sizeof(h));cnt=0;
	for(int i=1;i<=m;i++)
		if(ecc[t[i].u]!=ecc[t[i].v]) add(ecc[t[i].u],ecc[t[i].v],t[i].w),add(ecc[t[i].v],ecc[t[i].u],t[i].w),t[++num]=t[i];
	//重新加边
	sort(t+1,t+num+1,cmp);
	dfss(ecc[t[1].u],0);dis[ecc[t[1].u]]=ecc[t[1].v];//以最小的边的一个端点作为根
	for(int i=2;i<=num;i++)
	{
		int k=dep[ecc[t[i].u]]>dep[ecc[t[i].v]]?ecc[t[i].u]:ecc[t[i].v];//从深度深的跳
		while(!dis[fa[k]]) dis[fa[k]]=k,k=fa[k];//跳到一个固定儿子的点
		if(son==0&&fa[k]==ecc[t[1].u]&&dis[fa[k]]!=k) son=k;//若为根，特判
		else if(dis[fa[k]]==k||fa[k]==ecc[t[1].u]&&son==k) ;//若当前节点的父亲在链上的儿子就是自己，那么退出
		else //否则输出边的权值
		{
			printf("%d\n",t[i].w);
			return 0;
		}
	}
	printf("-1\n");
}
```



---

## 作者：EnofTaiPeople (赞：10)

我不喜欢过于复杂的分类讨论，这道题也不需要 LCA。老师讲题时就口胡了一下：先边双缩点，将割边边权从小到大排序，以最小的边的某一端点为根，另一端点做“特殊贵客”，从小到大处理，每次将边的较深端点 Access，如果断了边，表示这条边不能再加到链里面，这条边就是答案，如果全部都可以添加，就输出 $-1$。

本来想着可以用 Link-Cut-Tree 维护，但由于本题每一条边只会被影响一次，所以暴力维护就好，复杂度 $O(n+m)$。

关于边双连通分量，其实就是将割边去掉的联通子图，容易发现这些子图内部的任意一条边被割掉都不会造成影响，于是将它们缩点，而缩完点的图没有了环，也就变成了一棵树，但是敌人会增加一条边以至于树上有一条链不能选，在最坏情况下，那条链会将尽量多的小边包含，最小一个不能包含的就是答案，也就有了以上操作。

### Update on 2023-2-09:

由于可能某一条边最开始就被覆盖了，这时要特判掉，不然会被 Hack。

看了代码就理解了！
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5,M=2e6+6;
char buf[M+5],*p1,*p2,c;
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,M,stdin),p1==p2))?EOF:*p1++
inline int read(){
	int an=0,f=1;while(!isdigit(c=gc))if(c=='-')f=-f;
	do an=an*10+(48^c);while(isdigit(c=gc));return an*f; 
}
int f[N],wt[N];
int n,m,ed[M],w[M],dfn[N],low[N],dlt;
vector<int>lk[N];
struct Edge{int u,v,w;}g[N];
inline bool operator<(const Edge &x,const Edge &y){
	return x.w<y.w;
}
bitset<M>Cut;
void dfs1(int x,int pr){
	int y;dfn[x]=low[x]=++dlt;
	for(int i:lk[x]){
		if(i==pr)continue;
		if(dfn[y=ed[i]]){
			if(dfn[y]<low[x])
				low[x]=dfn[y];
		}else{
			dfs1(y,i^1);
			if(low[y]<low[x])low[x]=low[y];
			else Cut[i>>1]=low[y]>dfn[x];
		}
	}
}
void dfs2(int x){
	dfn[x]=dlt;
	for(int i:lk[x])
		if(!Cut[i>>1]&&!dfn[ed[i]])
			dfs2(ed[i]);
}
void dfs3(int x){
	for(int y:lk[x])
		if(y!=f[x])
			f[y]=x,dfs3(y);
}
int main(){
	n=read(),m=read();int i,x,y;
	for(i=1;i<=m;++i){
		x=read(),y=read();
		w[i+i+1]=w[i+i]=read();
		ed[i+i+1]=y;
		lk[x].push_back(i+i+1);
		ed[i+i]=x;
		lk[y].push_back(i+i);
	}
	for(x=1;x<=n;++x)
		if(!dfn[x])dfs1(x,-1);
	for(x=1;x<=n;++x)dfn[x]=0;dlt=0;
	for(x=1;x<=n;++x)
		if(!dfn[x])++dlt,dfs2(x);
	for(x=1,m=0;x<=n;++x)
		for(int i:lk[x]){
			if(dfn[y=ed[i]]>dfn[x])
				g[m++]={dfn[x],dfn[y],w[i]};
		}
	n=dlt;stable_sort(g,g+m);
	for(x=1;x<=n;++x)lk[x].clear();
	for(i=0;i<m;++i){
		lk[g[i].u].push_back(g[i].v);
		lk[g[i].v].push_back(g[i].u);
	}
	dfs3(g[0].u);
	for(i=1;i<m;++i){
		x=g[i].u,y=g[i].v;
		if(f[x]==y)x^=y^=x^=y;
		if(wt[x]==y)continue;
		while(x!=g[0].u&&wt[x]!=y){
			if(wt[x]){printf("%d\n",g[i].w);return 0;}
			else wt[x]=y,x=f[y=x];
		}
		if(x==g[0].u)
			if(y!=g[0].v){
				if(wt[x]){printf("%d\n",g[i].w);return 0;}
				else wt[x]=y;
			}
	}puts("-1");
	return 0;
} 
```

---

## 作者：EternalHeart1314 (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P5234)

$\text{Upd on 2025.1.27}$：修改了一些错误（原已过审）。

# Problem

给定一个 $n$ 个点，$m$ 条边的无向图，有边权。求出一条边 $ans$，使得在原图上再加一条边，无论这条边加在哪，删除 $ans$ 后，这个图不连通。最小化 $ans$ 的边权。

# Solution

### 前置知识：边双连通分量，边双缩点。

显然先边双缩点，删掉边双连通分量里的边不能使得图不连通。

此时无向图变成了树，而在边双里加边显然不能改变这棵树，考虑在树上加边的情况。

在树上加了一条边，那么这条边 $b$ 和树上的某些边形成一个环，环上的边不能删，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/u1kxz2in.png)

~~从[这篇题解](https://www.luogu.com.cn/article/f95t3ox2)贺来的。~~

图中红色边即为加的边 $b$，它和蓝色边形成一个环，那么环里的边都不能删，因为删了不能使得图不连通。所以只能删黑色边，且删的是黑色边里边权最小的边。

发现蓝色边形成一条链，那么问题转化为：在树上有一条链，非链边里边权最小的即是要删的边 $ans$。

考虑最坏情况，即链上尽量包含边权小的边，这样 $ans$ 的边权会变大。当 $ans$ 的边权已经最大时，此时的边权就是答案。

把边按边权从小到大排序，然后依次遍历每条边：若这条边可以加入链中，则加入；否则这条边即是 $ans$，因为它无法加入链了，已经是极限了。

如何判断能不能加入链呢？

记录链的左端点 $l$ 和右端点 $r$，要加入的边是 $i$，那么从 $i$ 一端的点 $s$ 开始搜索：若搜到 $l$ 或 $r$，则把 $l$ 或 $r$ 更新为 $s$，然后把**路径上的边都加入链里，为 $i$ 做连接桥**；否则只能搜到链身，无法搜到链头或链尾，那么无法加入 $i$。注意 $i$ 的另一端也要搜。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 5e5 + 7;
int n, m, chain_l, chain_r, node_cnt, bcc_cnt, dfn[N], low[N], bcc[N], vis[N];
stack<int> stk;//chian 是“链”的英文 
struct Node {
	int v, w;
};
struct Nodee {
	int u, v, w;
};
vector<Node> e[N], g[N];
vector<Nodee> edg;

void tarjan(int u, int ft) {
	dfn[u] = low[u] = ++node_cnt, stk.push(u);
	for (auto i : e[u]) if (i.v ^ ft) {
		if (!dfn[i.v]) tarjan(i.v, u), low[u] = min(low[u], low[i.v]);
		else low[u] = min(low[u], dfn[i.v]);
	}
	if (dfn[u] == low[u]) {
		bcc[u] = ++bcc_cnt;
		while (stk.top() ^ u) bcc[stk.top()] = bcc_cnt, stk.pop();
		stk.pop();
	}
}

int dfs_chain(int u, int ft) {
	for (auto i : g[u]) if (i.v ^ ft) {
		if (i.v == chain_l) return chain_l = u, vis[u] = 1, 1;
		if (i.v == chain_r) return chain_r = u, vis[u] = 1, 2;
		if (vis[i.v]) continue;
		int o = dfs_chain(i.v, u);
		if (o == 1) return chain_l = u, vis[u] = 1, 1;
		if (o == 2) return chain_r = u, vis[u] = 1, 2;
	}
	return 0;
}

main() {
	cin >> n >> m;
	for (int i = 1, u, v, w; i <= m; ++i)
		cin >> u >> v >> w, e[u].push_back({v, w}), e[v].push_back((Node){u, w});
	for (int i = 1; i <= n; ++i) if (!dfn[i]) tarjan(i, -1);//边双缩点 
	if (bcc_cnt == 1) return cout << -1, 0;
	for (int u = 1; u <= n; ++u) for (auto i : e[u]) if (bcc[u] ^ bcc[i.v])
		g[bcc[u]].push_back((Node){bcc[i.v], i.w}),
		edg.push_back((Nodee){bcc[u], bcc[i.v], i.w});
	sort(edg.begin(), edg.end(), [](Nodee i, Nodee j){return i.w < j.w;});
	chain_l = chain_r = edg[0].v, vis[edg[0].v] = 1;
	for (auto i : edg) {
		//记录那条链，搜到链的左端点或链的右端点就把路径上的都加入链里 
		//搜到了链但没搜到链头或链尾，即只搜到链身，那么这条边就是答案 
		if (!vis[i.u] && !dfs_chain(i.u, -1)) return cout << i.w, 0;
	}
	return cout << -1, 0;
}
```

---

## 作者：DaiRuiChen007 (赞：5)

# 洛谷 P5234 题解

[$\text{Link}$](https://www.luogu.com.cn/problem/P5234)

## 思路分析

显然，任何一条不是桥的边都不会对答案造成影响（因为在一个 E-DCC 中，任意删去一条边都不可能使图不连通）

所以我们可以对原图建立 dfs 搜索树并且求出桥，将所有树上非桥的边的边权都设为 $+\infty$

假设连了某一条边 $(u,v)$ ，使得答案为 $k$，则所有边权 $<k$ 的边都应该在简单路径 $(u,v)$ 上

考虑对答案二分，如果需要检查某个 $k$ 是否可能成为答案，我们只需要找到一条路径 $(u,v)$ 覆盖所有边权 $<k$ 的边即可

因此我们可以对每条边权 $<k$ 的边设为 $1$ 否则设为 $0$，然后用这个边权求一遍树的直径，只需要检查直径长度是否等于边权 $<k$ 的边的数量即可

时间复杂度 $\Theta(n\log T)$

### 代码呈现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=5e5+1,INF=1e9;
struct node {
	int des,val,lst;
} edge[MAXN<<1],tr[MAXN<<1];
int low[MAXN],dfn[MAXN],head1[MAXN],head2[MAXN],cnt[MAXN],dp[MAXN],tot=0,ans=0,dfncnt,totedge=1,tottree=0,n,m;
inline void addedge(int u,int v,int w) {
	edge[++totedge]=(node){v,w,head1[u]};
	head1[u]=totedge;
}
inline void addtree(int u,int v,int w) {
	tr[++tottree]=(node){v,w,head2[u]};
	head2[u]=tottree;
}
inline void tarjan(int p,int uid) {
	low[p]=dfn[p]=++dfncnt;
	for(int i=head1[p];i;i=edge[i].lst) {
		int v=edge[i].des;
		if(!dfn[v]) {
			tarjan(v,i);
			low[p]=min(low[p],low[v]);
			if(low[v]<=dfn[p]) addtree(p,v,INF);
			else addtree(p,v,edge[i].val);
		} else if(i!=(uid^1)) low[p]=min(low[p],dfn[v]);
	}
	return ;
}
inline void dfs(int p,int l) {
	vector <int> vec;
	if(!head2[p]) dp[p]=cnt[p];
	for(int i=head2[p];i;i=tr[i].lst) {
		int v=tr[i].des;
		cnt[v]=cnt[p];
		if(tr[i].val<l) ++cnt[v],++tot;
		dfs(v,l);
		vec.push_back(dp[v]);
	}
	sort(vec.begin(),vec.end(),greater<int>());
	if(vec.size()>0) dp[p]=vec[0],ans=max(vec[0]-cnt[p],ans);
	if(vec.size()>1) ans=max(ans,vec[0]+vec[1]-cnt[p]*2);
}
inline bool check(int x) {
	memset(cnt,0,sizeof(cnt));
	memset(dp,0,sizeof(dp));
	ans=tot=0;
	dfs(1,x);
	return ans==tot;
}
signed main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i) {
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		addedge(u,v,w);
		addedge(v,u,w);
	}
	tarjan(1,0);
	int l=0,r=INF,res=-1;
	while(l<=r) {
		int mid=(l+r)>>1;
		if(check(mid)) l=mid+1,res=mid;
		else r=mid-1;
	}
	if(res==INF) res=-1;
	printf("%d\n",res);
	return 0;
}
```



---

## 作者：creation_hy (赞：3)

来一种不用 dep 数组的简单做法（

显然环是割不掉的，所以可以缩点，缩完之后变成一棵树。

题意转化为删掉树上的一条路径，最大化剩下边的最小值。

从小到大把边加进去即可，每次判断把边上的两个点加进去是否还是一条路径。

判断方法很简单，一条路径显然是两条链组成的，所以可以用两个变量记录这两条链的最下端节点，如果加入的点 $x$ 和某条链下端节点 $s$ 的 LCA 为 $x$，说明正好在路径上，不用动；如果为 $s$，说明在 $s$ 下面，可以扩展，那就把 $s$ 设为 $x$；否则，$x$ 不在链上。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 5e5 + 5;
const int M = 2e6 + 5;
int n, m, head[N], to[M], nxt[M], etot, tot;
int dfn[N], low[N], cnt, id[N], cut[M], s1, s2;
struct edge
{
    int u, v, w;
    inline bool operator<(const edge &t) const
    {
        return w < t.w;
    }
} e[M];
inline void link(int u, int v)
{
    to[etot] = v;
    nxt[etot] = head[u];
    head[u] = etot++;
}
inline void tarjan(int x, int fa)
{
    dfn[x] = low[x] = ++cnt;
    for (int i = head[x]; ~i; i = nxt[i])
        if (!dfn[to[i]])
        {
            tarjan(to[i], x);
            low[x] = min(low[x], low[to[i]]);
            if (low[to[i]] > dfn[x])
                cut[i] = cut[i ^ 1] = 1;
        }
        else if (to[i] != fa)
            low[x] = min(low[x], dfn[to[i]]);
}
inline void dye(int x, int k)
{
    id[x] = k;
    for (int i = head[x]; ~i; i = nxt[i])
        if (!cut[i] && !id[to[i]])
            dye(to[i], k);
}
struct Tree
{
    int head[N], to[N << 1], nxt[N << 1], etot;
    int dep[N], g[N][20];
    inline Tree() { memset(head, -1, sizeof(head)); }
    inline void link(int u, int v)
    {
        to[etot] = v;
        nxt[etot] = head[u];
        head[u] = etot++;
    }
    inline void dfs(int x, int fa)
    {
        dep[x] = dep[g[x][0] = fa] + 1;
        for (int i = 1; i <= 19; i++)
            g[x][i] = g[g[x][i - 1]][i - 1];
        for (int i = head[x]; ~i; i = nxt[i])
            if (to[i] != fa)
                dfs(to[i], x);
    }
    inline int LCA(int x, int y)
    {
        if (dep[x] < dep[y])
            swap(x, y);
        for (int i = 19; ~i; i--)
            if (dep[g[x][i]] >= dep[y])
                x = g[x][i];
        if (x == y)
            return x;
        for (int i = 19; ~i; i--)
            if (g[x][i] != g[y][i])
                x = g[x][i], y = g[y][i];
        return g[x][0];
    }
    inline bool insert(int x)
    {
        if (!s1)
        {
            s1 = x;
            return 1;
        }
        int lca = LCA(x, s1);
        if (lca == x)
            return 1;
        if (lca == s1)
        {
            s1 = x;
            return 1;
        }
        if (!s2)
        {
            s2 = x;
            return 1;
        }
        lca = LCA(x, s2);
        if (lca == x)
            return 1;
        if (lca == s2)
        {
            s2 = x;
            return 1;
        }
        return 0;
    }
} G;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    memset(head, -1, sizeof(head));
    cin >> n >> m;
    for (int i = 1, u, v, w; i <= m; i++)
        cin >> u >> v >> w, link(u, v), link(v, u), e[i] = {u, v, w};
    for (int i = 1; i <= n; i++)
        if (!dfn[i])
            tarjan(i, 0);
    for (int i = 1; i <= n; i++)
        if (!id[i])
            dye(i, ++tot);
    for (int x = 1; x <= n; x++)
        for (int i = head[x]; ~i; i = nxt[i])
            if (id[x] != id[to[i]])
                G.link(id[x], id[to[i]]);
    G.dfs(1, 0);
    sort(e + 1, e + 1 + m);
    for (int i = 1; i <= m; i++)
        if (!G.insert(id[e[i].u]) || !G.insert(id[e[i].v]))
        {
            cout << e[i].w << '\n';
            return 0;
        }
    cout << "-1\n";
    return 0;
}
```

---

## 作者：kkxacj (赞：2)

提供一个自认为很简便的做法，核心算法只用到了边双缩点。

模板链接：[P8436 【模板】边双连通分量](https://www.luogu.com.cn/problem/P8436)。

#### 思路

首先注意到一个很显然的，如果一条边属于一个环，那么摧毁无效，所以可以先缩点，然后建立一颗新树。

然后考虑以一号节点为根跑出这棵树，注意这时一号节点下标是 $col_1$，即缩点后的新下标，我们肯定是按权值排序，然后从小到大枚举边直到敌方没招了，如果一直不行就无解。

考虑新增一条边，本质上其实可以拆成两条链，考虑维护这两条链，我们可以对于每个点求出 DFS 序和子树大小，然后根据 DFS 序的经典结论，$y$ 是 $x$ 子树的点当且仅当 $dfn_x \le dfn_y \le dfn_x+siz_x-1$，我们把边转到点上去，即对于每条边转到 $dfn$ 大的点，然后分讨即可，具体的：

1. 属于第一条链，即看是否可以当开头和结尾，可以就更新，否则看是否是开头的后代且是结尾的祖先。
2. 属于第二条链，同理。
3. 没有第一条链，自己作为第一条链。
4. 没有第二条链，看自己是否是第一条连开头的后代，如果是就不行，因为如果以它为第二条链，那么就覆盖不了开头的那个点了。

然后就没了，复杂度瓶颈在于排序，随便优化一下就可以线性了，稍微优化一下就能做到当前最优解第一。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define getchar() (p1 == p2 && (p2 = (p1 = buf1) + fread(buf1, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf1[1 << 23], *p1 = buf1, *p2 = buf1, ubuf[1 << 23], *u = ubuf;
namespace IO
{
	template<typename T>
	void read(T &_x){_x=0;int _f=1;char ch=getchar();while(!isdigit(ch)) _f=(ch=='-'?-1:_f),ch=getchar();while(isdigit(ch)) _x=_x*10+(ch^48),ch=getchar();_x*=_f;}
	template<typename T,typename... Args>
	void read(T &_x,Args&...others){Read(_x);Read(others...);}
	const int BUF=20000000;char buf[BUF],to,stk[32];int plen;
	#define pc(x) buf[plen++]=x
	#define flush(); fwrite(buf,1,plen,stdout),plen=0;
	template<typename T>inline void print(T x){if(!x){pc(48);return;}if(x<0) x=-x,pc('-');for(;x;x/=10) stk[++to]=48+x%10;while(to) pc(stk[to--]);}
}
using namespace IO;
const int N = 1e6+10,V = 1e5;
int n,m,x,y,z,head[N],cnt,low[N],dep[N],t[N],col[N],o;
int fa[N],dfn[N],siz[N],cnt1;//求出dfn与fa
int L,R,L1,R1;//两条链 
struct w1
{
	int x,y;
}ed[N];
vector<int>v[V+10]; 
struct w
{
	int to,nxt;
}b[N<<1];
inline void add(int x,int y)
{
	b[++cnt].nxt = head[x];
	b[cnt].to = y;
	head[x] = cnt;
}
void dfs(int x,int y)
{
	dep[x] = low[x] = dep[y]+1; t[++cnt] = x;
	for(int i = head[x];i;i = b[i].nxt)
	{
		if(b[i].to == y) continue;
		if(!dep[b[i].to]) dfs(b[i].to,x),low[x] = min(low[x],low[b[i].to]);
		else low[x] = min(low[x],dep[b[i].to]);
	}
	if(dep[x] == low[x])
	{
		o++;
		while(t[cnt+1] != x) col[t[cnt]] = o,cnt--;
	}
}
void dfs1(int x,int y)
{
	fa[x] = y,siz[x] = 1,dfn[x] = ++cnt1;
	for(int i = head[x];i;i = b[i].nxt)
		if(b[i].to != y) 
			dfs1(b[i].to,x),siz[x] += siz[b[i].to];
}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),read(m);
	for(int i = 1;i <= m;i++) read(x),read(y),read(z),add(x,y),add(y,x),ed[i].x = x,ed[i].y = y,v[z].push_back(i);
	cnt = 0; dfs(1,0);//注意处理之前要清空 
	for(int i = 1;i <= n;i++) head[i] = 0;
	for(int i = 1;i <= m;i++) ed[i].x = col[ed[i].x],ed[i].y = col[ed[i].y];
	for(int i = 1;i <= m;i++) 
		if(ed[i].x != ed[i].y)
			add(ed[i].x,ed[i].y),add(ed[i].y,ed[i].x);
	dfs1(col[1],0);//注意到根节点是col_1 
	for(int j = 1;j <= V;j++)
		for(int z = 0;z < v[j].size();z++)
		{ 
			int i = v[j][z];
			x = ed[i].x,y = ed[i].y;
			if(x != y)
			{
				if(fa[x] == y) swap(x,y);
				//默认x是y父亲 
				if(L == 0) L = R = y;//没有就放上，注意链化点是下面的点 
				else
				{
					if(dfn[R] <= dfn[y] && dfn[y] <= dfn[R]+siz[R]-1) R = ed[i].y; //尾部 
					else if(dfn[y] <= dfn[L] && dfn[L] <= dfn[y]+siz[y]-1) L = ed[i].y;//链头
					else if(dfn[L] <= dfn[y] && dfn[y] <= dfn[L]+siz[L]-1 && dfn[y] <= dfn[R] && dfn[R] <= dfn[y]+siz[y]-1);
					else
					{
						if(L1 == 0)
						{
							if(dfn[L] <= dfn[y] && dfn[y] <= dfn[L]+siz[L]-1)//无法放置 
							{
								print(j); flush();
								return 0; 
							}
							L1 = R1 = y;
						}
						else if(dfn[R1] <= dfn[y] && dfn[y] <= dfn[R1]+siz[R1]-1) R1 = y; //尾部
						else if(dfn[y] <= dfn[L1] && dfn[L1] <= dfn[y]+siz[y]-1) L1 = y;//链头
						else if(dfn[L1] <= dfn[y] && dfn[y] <= dfn[L1]+siz[L]-1 && dfn[y] <= dfn[R1] && dfn[R1] <= dfn[y]+siz[y]-1);
						else { print(j); flush(); return 0; }
					}
				}
			}
		}
	print(-1); flush(); 
	return 0;
}
/*
先枚举选哪条边
然后如果对应的点在一个边双内，就不管
否则看我有没有放秘密的线
考虑染色，如果第一次出现两个不同链，就是边的链接之日
然后继续走知道非这两条链上的同时也不是边双的
其实不妨可以理解为两次链接根的机会 
不过链尾不知道是哪一个
可以搞两个L,R, L1,R1
分别是两条链的头与尾
如果被L包含了，且不包含R，立即结束
到最后都没结束的话...【我们需要帮助】 
*/
```

---

## 作者：Unnamed114514 (赞：2)

边双缩点是显然的，因为边双内部的边显然不影响，下文的图都是缩点后的。

注意原图不一定连通，需要对连通块的数量 $cnt$ 进行分类讨论：

- $cnt>2$，即使连上一条边后，也不连通，答案为 $0$。

- $cnt=2$，只能连接两个连通块，因此答案为最小的割边。

- $cnt=1$，根据上面的思路，我们要找到连边的策略。

先把无解判掉，只有一条链的时候会无解，因为此时它连接首尾即可。

考虑二分。

转化成是否存在一条树链覆盖了所有 $w\le mid$ 的边。

这个还是很好判的，我们把 $w\le mid$ 的边权设成 $1$，其它的设成 $0$，然后跑直径即可。

---

## 作者：ZHR100102 (赞：1)

边双好题。一开始还以为是恶心的分讨，后面才发现是要求一个式子。

# 观察

首先我们注意到下面两个条件：
- 对方先在图上加一条边，这条边我们在下一步的时候不能断。
- 我们可以随意在图上断一条边。

要求求出对方断任何边后答案的最大值。

一个错误的理解是，我们在断完边后，对方再来根据我们方案加边。我一开始的做法就是边双缩点之后找以 $1$ 为根的菊花来贪心。但是这样的做法是错的，为啥呢？因为**对方是在不知道我们操作的情况下加边的**，而我们是知道对方的操作下断边的。这就导致了对方能对着我们断的边重新加回来，那怎么搞都是无解了。。。。

所以正确的理解应该是对于每一种可能的加边情况，求出 $\max(\min res)$。$\min res$ 是指加边后局面为 $res$ 的最少所需人数。

然后边双缩点是显然的，因为这题只有断割边才有用，断一条 EDCC 内的边就相当于没断。

于是我们就可以在树上考虑求这个式子了。

# 实现

在所有情况里使得最小值最大，是个很典的二分答案的形式，于是我们考虑二分最大值，check 是否有合法的情况。

那么加边的操作如何刻画呢？显然就是找到树上的一条链，答案是除去这条链上的边，其他边的最小边权。

既然要让其他边最小值是 $mid$，就得让小于 $mid$ 的所有边都包含在这条链上，也就是让链上尽可能多地包含小于 $mid$ 的边。所以就可以把小于 $mid$ 的边边权重新赋值为 $1$，其余边赋值为 $0$，跑树的直径板子，如果直径等于小于 $mid$ 的边的数量，就说明这个情况合法。二分找到最后一个合法情况即可。

时间复杂度 $O(n \log n)$。无解的情况就是缩点形成的树是一条链的情况或者一点特殊的 corner，这时候可以在链的两端连边使得整张图成为一个 EDCC，就没法断边了。

# 代码

注意 EDCC 缩点的时候，形成的树上能连边当且仅当两个点处于不同的 EDCC 中且这两点之间有边。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
using namespace std;
typedef long long ll;
const int N=500005,M=2000005;
using pi=pair<int,int>;
int n,m;
int h[N],idx=1;
struct Edge{
	int v,ne,w;
}e[M];
void add(int u,int v,int w)
{
	e[++idx]={v,h[u],w};
	h[u]=idx;
}
void addeg(int u,int v,int w)
{
	add(u,v,w);
	add(v,u,w);
}
int dfn[N],low[N],tp,stk[N],tot,cnt,edcc[N],sz[N],sm,dp[N],diam;
void tarjan(int u,int ineg)
{
	dfn[u]=low[u]=++tot;
	stk[++tp]=u;
	for(int i=h[u];i;i=e[i].ne)
	{
		int v=e[i].v;
		if(dfn[v]==0)
		{
			tarjan(v,i);
			low[u]=min(low[u],low[v]);
		}
		else if(i^ineg^1)
		{
			low[u]=min(low[u],dfn[v]);
		}
	}
	if(low[u]==dfn[u])
	{
		cnt++;
		int x;
		do{
			x=stk[tp--];
			edcc[x]=cnt;
			sz[cnt]++;
		}while(x!=u);
	}
}
vector<pi>g[N];
int x;
void getdiam(int u,int f)
{
    dp[u]=0;
	for(auto eg:g[u])
	{
		int v=eg.fi,w=eg.se;
		if(v==f)continue;
		if(w<x)sm++,w=1;
		else w=0;
		getdiam(v,u);
		diam=max(diam,dp[u]+dp[v]+w);
		dp[u]=max(dp[u],dp[v]+w);
	}
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	while(m--)
	{
		int u,v,w;
		cin>>u>>v>>w;
		addeg(u,v,w);
	}
	for(int i=1;i<=n;i++)if(dfn[i]==0)tarjan(i,0);
	for(int u=1;u<=n;u++)
	{
		int edccu=edcc[u];
		for(int i=h[u];i;i=e[i].ne)
		{
			int v=e[i].v,w=e[i].w;
			int edccv=edcc[v];
			if(edccu!=edccv)g[edccu].push_back({edccv,w});
		}
	}
	sm=diam=0;
    x=10000000;
	getdiam(1,0);
	if(diam==cnt-1)
	{
		cout<<-1;
		return 0;
	}
	int l=0,r=100005,mid;
	while(l<r)
	{
		mid=(l+r+1)>>1;
		sm=diam=0;
        x=mid;
		getdiam(1,0);
		if(diam>=sm)l=mid;
		else r=mid-1;
	}
    if(l>100000)cout<<-1;
	else cout<<l;
	return 0;
}
```

---

## 作者：qwer6 (赞：1)

## 简化题意

给出一张有 $n$ 个点，$m$ 条边的无向联通图，现在有一条不知道端点的边，询问在最劣情况下，删除一条边后使得整张图不再联通的最小代价。

## 思路一

首先我们可以使用 Tarjan 求边双，根据边双缩点，原因是即使在不添加边的情况下，删除边双中的任何一条边也不可能使得整张图不联通。

缩点后，我们连接所有桥，可以得到一张新的图，这张图显然是一棵树，所以我们考虑在树上求解这个问题。

我们知道，在树上加入一条非树边，可以将一条路径的上的所有边从桥变成普通的边，所以我们有一种贪心的写法，就是将所有边按照边权从小到大排序，然后不断加入新的边，当不存在一条路径可以将所有边覆盖的时候，这条边的边权就是答案，如果可以加入所有边，就代表无解。

我们发现维护路径直接扩展端点似乎并不好写，而我们知道，如果原来路径的两个端点为 $S$ 和 $T$，加入的边为 $U$ 和 $V$，那么如果这条路径是存在的话，那么这条路径的端点应该就是 $(S,T)$，$(S,U)$，$(S,V)$，$(U,T)$，$(V,T)$ 五种情况的一种，那么只要枚举这五种情况，然后判断另外两个点在不在这条路径即可。

这种写法可能需要卡卡空间。

### Code

```c++
/*by qwer6*/
/*略去快读快写和缺省源*/
const int N=5e5+5,M=1e6+5;
int n,m,cnt_bcc,cnt_dfn,top,tot;
int dfn[N],low[N],st[N],id[N];
bool vis[N],flag[N];
struct Edge{
	int u,v,w;
	bool operator <(const Edge &a)const{return w<a.w;}
}e[N];
struct Chain_forward_star{
	struct Edge{
		int v,w,nxt;
	}e[M<<1];
	int n,cnt_edge;
	int head[N];
	void init(int _n){
		n=_n,cnt_edge=-1;
		for(int i=1;i<=n;i++)head[i]=-1;
	}
	void AddEdge(int u,int v,int w){
		e[++cnt_edge]={v,w,head[u]};
		head[u]=cnt_edge;
	}
}G;
struct Tree{
	vector<int>e[N];
	int fa[25][N],dep[N];
	void AddEdge(int u,int v){e[u].push_back(v);}
	void dfs(int u){
		for(int i=1;i<=19;i++)
			fa[i][u]=fa[i-1][fa[i-1][u]];
		for(int v:e[u]){
			if(fa[0][u]==v)continue;
			dep[v]=dep[u]+1;
			fa[0][v]=u;
			dfs(v);
		}
	}
	int LCA(int u,int v){
		if(dep[u]<dep[v])swap(u,v);
		int d=dep[u]-dep[v];
		for(int i=0;i<=19;i++)
			if(d&1<<i)
				u=fa[i][u];
		if(u==v)return u;
		for(int i=19;i>=0;i--)
			if(fa[i][u]!=fa[i][v])
				u=fa[i][u],v=fa[i][v];
		return fa[0][u];
	}
	int father(int u,int depth){
		int d=dep[u]-depth;
		for(int i=19;i>=0;i--)
			if(d&1<<i)
				u=fa[i][u];
		return u;
	}
}tree;
void Tarjan(int u,int in_edge){
	vis[u]=1;
	st[++top]=u;
	flag[u]=1;
	dfn[u]=low[u]=++cnt_dfn;
	for(int i=G.head[u],v;~i;i=G.e[i].nxt){
		if(i==(in_edge^1))continue;
		v=G.e[i].v;
		if(!vis[v]){
			Tarjan(v,i);
			tomin(low[u],low[v]);
		}else if(flag[v])tomin(low[u],dfn[v]);
	}
	if(dfn[u]==low[u]){
		cnt_bcc++;
		do{
			flag[st[top]]=0;
			id[st[top]]=cnt_bcc;
		}while(st[top--]!=u);
	}
}
bool check(int s,int t,int u){
	if(s==u||t==u)return 1;
	//u 是不是在 s->t 的路径上 
	if(max(tree.dep[s],tree.dep[t])<tree.dep[u])return 0;
	if(tree.dep[tree.LCA(s,t)]>tree.dep[u])return 0;
	if(tree.father(s,tree.dep[u])==u)return 1;
	if(tree.father(t,tree.dep[u])==u)return 1;
	return 0;
}
signed main(){
	read(n),read(m);
	G.init(n);
	for(int i=1,u,v,w;i<=m;i++){
		read(u),read(v),read(w);
		G.AddEdge(u,v,w);
		G.AddEdge(v,u,w);
	}
	Tarjan(1,-1);
	for(int u=1;u<=n;u++){
		for(int i=G.head[u],v,w;~i;i=G.e[i].nxt){
			v=G.e[i].v,w=G.e[i].w;
			if(id[v]==id[u])continue;
			tree.AddEdge(id[u],id[v]);
			if(id[u]>id[v])e[++tot]={id[u],id[v],w};
		}
	}
	tree.dfs(id[1]);
	sort(e+1,e+tot+1);
	int S=e[1].u,T=e[1].v;
	for(int i=2,U,V;i<=tot;i++){
		U=e[i].u,V=e[i].v;
		if(check(S,T,U)&&check(S,T,V))continue;
		if(check(S,U,T)&&check(S,U,V)){
			T=U;
			continue;
		}
		if(check(S,V,T)&&check(S,V,U)){
			T=V;
			continue;
		}
		if(check(U,T,S)&&check(U,T,V)){
			S=U;
			continue;
		}
		if(check(V,T,S)&&check(V,T,U)){
			S=V;
			continue;
		}
		write(e[i].w),exit(0);
	}
	puts("-1");
}
```

## 思路二

可能你觉得上面那种方法有点难写，码量也比较大，那有没有更简单，更好想的方法呢？

有的兄弟，有的，有一种比上面的方法更简单，更好想的方法。

这种方法同样需要先点双缩点，建出一棵新树，在这棵树上进行操作。

我们可以二分出一个值 $W$，标记所有边权不大于 $W$ 的边，如果所有边不可以形成一条路径，那么 $W+1$ 就可能是最后的答案。

可以想到如果存在一个点，使得有除了这个点之外的有三个及以上的点需要向这个点连路径的话，这条路径就不存在。

具体方法可以看代码。

```c++
void dfs(int u,int fa,bool &flag){
    int v,w;
    for(Edge tmp:e[u]){
        v=tmp.v,w=tmp.w;
        if(v==fa)continue;
        dfs(v,u,flag);
        if(mark[v])cnt[u]++;//mark[v] 为 1 的话，就代表 v->u 这条边被标记了
        cnt[u]+=cnt[v];
    }
    if(cnt[u]+mark[u]>2)flag=0;
    else if(cnt[u]==1&&mark[u])cnt[u]=0;//cnt[u] 和 mark[u] 都为 1 的话，这两条边只能被视为一条边
}
```

### Code

最后放一下完整代码。

```c++
/*by qwer6*/
/*略去快读快写和缺省源*/
const int N=5e5+5,M=1e6+5;
int n,m,cnt_bcc,cnt_dfn,top,tot;
int dfn[N],low[N],st[N],id[N],d[N];
bool vis[N],flag[N];
struct Chain_forward_star{
	struct Edge{
		int v,w,nxt;
	}e[M<<1];
	int n,cnt_edge;
	int head[N];
	void init(int _n){
		n=_n,cnt_edge=-1;
		for(int i=1;i<=n;i++)head[i]=-1;
	}
	void AddEdge(int u,int v,int w){
		e[++cnt_edge]={v,w,head[u]};
		head[u]=cnt_edge;
	}
}G;
struct Tree{
	struct Edge{
		int v,w;
	};
	vector<Edge>e[N];
	int cnt[N];
	bool mark[N];
	void AddEdge(int u,int v,int w){e[u].push_back({v,w});}
	void Mark(int u,int fa,int lim){
		int v,w;
		for(Edge tmp:e[u]){
			v=tmp.v,w=tmp.w;
			if(v==fa)continue;
			if(w<=lim)mark[v]=1;
			else mark[v]=0;
			Mark(v,u,lim);
		}
	}
	void dfs(int u,int fa,bool &flag){
		int v,w;
        cnt[u]=0;
		for(Edge tmp:e[u]){
			v=tmp.v,w=tmp.w;
			if(v==fa)continue;
			dfs(v,u,flag);
			if(mark[v])cnt[u]++;
			cnt[u]+=cnt[v];
		}
		if(cnt[u]+mark[u]>2)
			flag=0;
		else if(cnt[u]==1&&mark[u])cnt[u]=0;
	}
	bool check(int x,int S){
		Mark(S,0,x);
		bool flag=1;
		dfs(S,0,flag);
		return flag;
	}
}tree;
void Tarjan(int u,int in_edge){
	vis[u]=1;
	st[++top]=u;
	flag[u]=1;
	dfn[u]=low[u]=++cnt_dfn;
	for(int i=G.head[u],v;~i;i=G.e[i].nxt){
		if(i==(in_edge^1))continue;
		v=G.e[i].v;
		if(!vis[v]){
			Tarjan(v,i);
			tomin(low[u],low[v]);
		}else if(flag[v])tomin(low[u],dfn[v]);
	}
	if(dfn[u]==low[u]){
		cnt_bcc++;
		do{
			flag[st[top]]=0;
			id[st[top]]=cnt_bcc;
		}while(st[top--]!=u);
	}
}
signed main(){
	read(n),read(m);
	G.init(n);
	for(int i=1,u,v,w;i<=m;i++){
		read(u),read(v),read(w);
		G.AddEdge(u,v,w);
		G.AddEdge(v,u,w);
	}
	Tarjan(1,-1);
	for(int u=1;u<=n;u++){
		for(int i=G.head[u],v,w;~i;i=G.e[i].nxt){
			v=G.e[i].v,w=G.e[i].w;
			if(id[v]==id[u])continue;
			tree.AddEdge(id[u],id[v],w);
			d[id[v]]++;
		}
	}
	int cnt=0;
	for(int i=1;i<=cnt_bcc;i++)
		if(d[i]==1)
			cnt++;
	if(cnt<=2){
		puts("-1");
		exit(0);
	}
	int l=1,r=100000,res=-1;
	while(l<=r){
		int mid=(l+r)>>1;
		if(tree.check(mid,id[1])){
			res=mid;
			l=mid+1;
		}else r=mid-1;
	}
	write(res+1);
}
```

---

## 作者：free_fall (赞：1)

来写一种~~刺激~~不一样的写法。

我们先研究这个图，发现只有图中的桥有可能可以被删掉，于是我们从这个图中按照 dfs 的顺序取出一棵树，将所有非树边在树上对应的链标记掉，那么未被标记的边就有可能被删掉。

这里标记链用倍增求 LCA 会 TLE，所以我们写一个随机化标记，将 $u$ 和 $v$ 同时异或一个 $1 \sim 10^9$ 的随机数，在最后跑一边 dfs 从叶子节点向上异或，然后我们惊奇地发现到 LCA 时 $u$ 和 $v$ 的影响刚好互相抵消掉了，于是链上所有的值都被标记过了。

做完这个操作后你会得到这样一个东西：

![](https://cdn.luogu.com.cn/upload/image_hosting/pi8odrz1.png)

红色是非树边，蓝色是被标记的树边，不选。

之后我们要找到一条链，使得去掉它之后剩下的未被标记的树边中的最小值最大，这个值即为答案，如果没有，输出 $-1$。

最小值最大，我们很容易想到了二分，于是二分枚举从小到大的 $mid$ 条边，判断是否可以组成一条链，比较暴力，但是思想简单（具体实现见代码），时间复杂度为 $O(n \log n)$，稍微卡一下可以过。
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-f;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	return x*f;
}
const int N=5e5+5;
int n,m,d[N],mark[N],fa[N],top,vis[N];
struct kk{
	int to,val;
};
vector<kk> edge[N];
struct edge{
	int u,v,w;
	bool operator<(const edge &x)const{
		return w<x.w;
	}
}a[N];
int RAND(int l,int r){
	return (rand()+(rand()<<15))%(r-l+1)+l;
}
void dfs(int now,int las){
	vis[now]=1;
	fa[now]=las;
	for(int i=0;i<edge[now].size();i++){
		int to=edge[now][i].to,val=edge[now][i].val;
		if(vis[to])continue;
		d[to]=val;
		dfs(to,now);
	}
	return;
}
void dfs1(int now,int las){
	vis[now]=1;
	for(int i=0;i<edge[now].size();i++){
		int to=edge[now][i].to,val=edge[now][i].val;
		if(to==las)continue;
		if(vis[to]){
			int v=RAND(1,1e9);
			mark[now]^=v;
			mark[to]^=v;
			continue;
		}
		dfs1(to,now);
	}
	return;
}
void dfs2(int now){
	vis[now]=1;
	for(int i=0;i<edge[now].size();i++){
		int to=edge[now][i].to,val=edge[now][i].val;
		if(vis[to])continue;
		dfs2(to);
		mark[now]^=mark[to];
	}
	return;
}
void dfs3(int now){
	mark[now]=1;
	int cnt=0;
	for(int i=0;i<edge[now].size();i++){
		int to=edge[now][i].to,val=edge[now][i].val;
		if(mark[to])continue;
		dfs3(to);
		if(vis[to]==1)vis[now]=1,cnt++;
		else if(vis[to]>=2)vis[to]=1;
	}
	if(cnt>=2)vis[now]=2;
	return;
}
bool check(int mid){
	int res=0;
	memset(vis,0,sizeof vis);
	memset(mark,0,sizeof mark);
	for(int i=1;i<=mid;i++){
		vis[a[i].u]++;
		vis[a[i].v]++;
	}
	dfs3(1);
	if(vis[1]==2)vis[1]=1;
	for(int i=1;i<=n;i++){
		int tmp=0;
		for(int j=0;j<edge[i].size();j++){
			int to=edge[i][j].to;
			if(vis[to]&&(fa[to]==i||fa[i]==to))tmp++;
		}
		if(vis[i]&&tmp>2)return false;
		if(vis[i]&&tmp==1)res++;
	}
	return res==2;
}
int main(){
	srand(time(0));
	n=read(),m=read();
	for(int i=1;i<=m;i++){
		int u=read(),v=read(),w=read();
		edge[u].push_back({v,w});
		edge[v].push_back({u,w});
	}
	dfs(1,0);
	memset(vis,0,sizeof vis);
	dfs1(1,0);
	memset(vis,0,sizeof vis);
	dfs2(1);
	for(int i=2;i<=n;i++){
		if(mark[i])continue;
		a[++top]={fa[i],i,d[i]};
	}
	sort(a+1,a+top+1);
	int l=1,r=top,res=0;
	while(l<=r){
		int mid=l+r>>1;
		if(check(mid)){
			l=mid+1;
			res=mid;
		}
		else r=mid-1;
	}
	if(res==top)printf("-1");
	else printf("%d",a[res+1].w);
	return 0;
}
```

---

## 作者：ny_jerry2 (赞：1)

看到和边以及连通性相关，自然可以想到边双连通分量，所以先跑一边 tarjan 再说。

下面的图都是指缩点后的图。

因为**连接了所有电网**，因此图连通，不用考虑含有多个连通块的情况。

考虑一下什么情况无解。显然是一条链。你只要首尾连接一下就是一个环了，删哪个边都没用了。

再思考一下，发现它具有二段性。如果你删除权值在 $mid$ 以内的边没有用，那 $1 \dots mid$ 这一段你就不用看了。   
所以考虑二分。

考虑应该如何判定。首先，先将 $w \le mid$ 的边标记为 $1$。如果这些边是一条链，即无解（见上）。怎么判断是否是一条链吗？树的直径！如果树的直径等于边被标记为 $1$ 的个数，就是一条链（因为树的直径也是一条链）。

然后没了。

```cpp
#include<iostream>
#include<cstring>
#include<vector>
using namespace std;
int n,m;
const int N=4e6+10,M=500010;
int h[M],rh[M],e[N],ne[N],w[N],idx;
int dist[M];
void add(int h[],int a,int b,int c){
	e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}
int tim;
int dfn[M],low[M];
int stk[M],top;
int id[M],dcc;
bool is[M];
int ans=2e9;
void tarjan(int u,int fa){
	dfn[u]=low[u]=++tim;
	stk[++top]=u;
	for(int i=h[u];~i;i=ne[i]){
		int j=e[i];
		if(i==(fa^1)){
			continue;
		}
		if(!dfn[j]){
			tarjan(j,i);
			low[u]=min(low[u],low[j]);
			if(low[j]>dfn[u]){
				ans=min(ans,w[i]);
			}
		}else{
			low[u]=min(low[u],dfn[j]);
		}
	}
	if(dfn[u]==low[u]){
		int y;
		dcc++;
		do{
			y=stk[top--];
			id[y]=dcc;
		}while(y!=u);
	}
}
void dfs(int u,int fa,int mid){
	for(int i=rh[u];~i;i=ne[i]){
		int j=e[i];
		if(j==fa){
			continue;
		}
		dist[j]=dist[u]+(w[i]<=mid);
		dfs(j,u,mid);
	}
}
int count(int u,int fa,int mid){
	int cnt=0;
	for(int i=rh[u];~i;i=ne[i]){
		int j=e[i];
		if(j==fa){
			continue;
		}
		cnt=cnt+(w[i]<=mid)+count(j,u,mid);
	}
	return cnt;
}
bool check(int mid){
	int cnt=count(id[1],-1,mid);
//	cout<<mid<<' '<<cnt<<endl;
	dist[id[1]]=0;
	dfs(id[1],-1,mid);
	int s=0;
	for(int i=1;i<=dcc;i++){
		if(dist[i]>dist[s]){
			s=i;
		}
	}
	dist[s]=0;
	dfs(s,-1,mid);
	int res=0;
	for(int i=1;i<=dcc;i++){
		res=max(res,dist[i]);
	}
	return res<cnt;
}
int f[M];
int find(int x){
	if(f[x]==x){
		return x;
	}
	return f[x]=find(f[x]);
}
int main(){
	memset(h,-1,sizeof h);
	memset(rh,-1,sizeof rh);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		f[i]=i;
	}
	while(m--){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		add(h,a,b,c),add(h,b,a,c);
		f[find(a)]=find(b);
	}
	int res=0;
	for(int i=1;i<=n;i++){
		if(!dfn[i]){
			tarjan(i,0);
		}
		if(find(i)==i){
			res++;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=h[i];~j;j=ne[j]){
			int k=e[j];
			int a=id[i],b=id[k];
			if(a!=b){
				add(rh,a,b,w[j]);
			}
		}
	}
	if(res>2){
		cout<<0;
	}else if(res==2){
		cout<<ans;
	}else{
		int l=0,r=1e5;
		while(l<r){
			int mid=(l+r)>>1;
			if(check(mid)){
				r=mid;
			}else{
				l=mid+1;
			}
		}
		if(!check(l)){
			cout<<-1;
		}else{
			cout<<l;
		}
	}
}
```

---

## 作者：Coros_Trusds (赞：1)

# 题目大意

先给定一张 $n$ 个点，$m$ 条双向边的无向图。

在任意加入一条边的情况下，求割一条边使图不连通的最小割边的最大值。

# 题目分析

先用 $\rm Tarjan$ 算法求出所有的割边，然后把图缩点，因为环内的边对答案是没有用的。

我们考虑加入一条边 $(u,v)$，它会使得我们无论割掉 $(u,v)$ 路径上的哪一条割边都不会使原图不连通，又因为我们要最大化最小割边的值，故不妨用贪心的思想解题：

从小到大加入割边，如果加到某一时刻这些边不能构成一条链了（就是说不能连在一起了），说明如果再选是不可能满足“任意加入一条边”都能割一条边使得缩点后的图不连通了。

代码中，判断是否在一条链上采用了观察 $\rm lca$ 的方法。

具体地，我们分类讨论链的形状，并且维护“无弯曲”的那部分链，如果新加入的边无法与当前的链连接起来，则输出当前新加入这条边的权值。

# 代码

```cpp
// Problem: P5234 [JSOI2012]越狱老虎桥
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5234
// Memory Limit: 128 MB
// Time Limit: 1000 ms
// Date:2022-05-29 22:27
// 
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#include <cmath>
#include <stack>
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	inline int read() {
		int ret = 0,f = 0;char ch = getchar();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getchar();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getchar();
		}
		return f ? -ret : ret;
	}
	inline double double_read() {
		long long ret = 0,w = 1,aft = 0,dot = 0,num = 0;
		char ch = getchar();
		while (!isdigit(ch)) {
			if (ch == '-') w = -1;
			ch = getchar();
		}
		while (isdigit(ch) || ch == '.') {
			if (ch == '.') {
				dot = 1;
			} else if (dot == 0) {
				ret = (ret << 3) + (ret << 1) + ch - 48;
			} else {
				aft = (aft << 3) + (aft << 1) + ch - '0';
				num ++;
			}
			ch = getchar();
		}
		return (pow(0.1,num) * aft + ret) * w;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;

const int N = 1e6 + 5;
struct Graph {
	struct Node {
		int v,w,nxt;
	} gra[N << 1];
	int head[N];
	int idx = 1;
	inline void add(int u,int v,int w) {
		gra[++ idx] = (Node){v,w,head[u]},head[u] = idx;
	}
} g1,g2;
struct Edge {
	int u,v,w;
} edges[N];
int dfn[N],low[N],col[N],fr[N],to[N],wi[N],dep[N],fa[N],top[N],siz[N],son[N];
bool in_stack[N];
std::stack<int>st;
int n,m,num,cnt,num_edges;
inline void tarjan(int now,int pre) {
	dfn[now] = low[now] = ++ num,in_stack[now] = true;
	st.push(now);
	for (register int i = g1.head[now];i;i = g1.gra[i].nxt) {
		if (i != (pre ^ 1)) {
			int v = g1.gra[i].v;
			if (!dfn[v]) {
				tarjan(v,i);
				low[now] = std::min(low[now],low[v]);
			} else if (in_stack[v]) {
				low[now] = std::min(low[now],dfn[v]);
			}
		}
	}
	if (dfn[now] == low[now]) {
		cnt ++;
		int u;
		do {
			u = st.top();st.pop();
			in_stack[u] = false,col[u] = cnt;
		} while (u != now);
	}
}
inline bool cmp(Edge x,Edge y) {
	return x.w < y.w;
}
struct chain {
	inline void dfs1(int now,int fath,int depth) {
		dep[now] = depth,fa[now] = fath,siz[now] = 1;
		for (register int i = g2.head[now];i;i = g2.gra[i].nxt) {
			int v = g2.gra[i].v;
			if (v != fath) {
				dfs1(v,now,depth + 1);
				siz[now] += siz[v];
				if (siz[son[now]] < siz[v]) {
					son[now] = v;
				}
			}
		}
	}
	inline void dfs2(int now,int topf) {
		top[now] = topf;
		if (son[now]) {
			dfs2(son[now],topf);
			for (register int i = g2.head[now];i;i = g2.gra[i].nxt) {
				int v = g2.gra[i].v;
				if (v != fa[now] && v != son[now]) {
					dfs2(v,v);
				}
			}
		}
	}
	inline int getlca(int x,int y) {
		while (top[x] != top[y]) {
			if (dep[top[x]] < dep[top[y]]) std::swap(x,y);
			x = fa[top[x]];
		}
		if (dep[x] > dep[y]) std::swap(x,y);
		return x;
	}
} ch;
int main(void) {
	n = read(),m = read();
	for (register int i = 1;i <= m; ++ i) {
		fr[i] = read(),to[i] = read(),wi[i] = read();
		g1.add(fr[i],to[i],wi[i]),g1.add(to[i],fr[i],wi[i]);
	}
	for (register int i = 1;i <= n; ++ i) {
		if (!dfn[i]) {
			tarjan(i,-1);
		}
	}
	for (register int i = 1;i <= m; ++ i) {
		if (col[fr[i]] != col[to[i]]) {	
			g2.add(col[fr[i]],col[to[i]],wi[i]),g2.add(col[to[i]],col[fr[i]],wi[i]);
			edges[++ num_edges] = (Edge){col[fr[i]],col[to[i]],wi[i]};
		}
	}
	ch.dfs1(1,0,1),ch.dfs2(1,1);
	std::sort(edges + 1,edges + num_edges + 1,cmp);
	int a = edges[1].u,b = edges[1].v;
	int pre = ch.getlca(a,b);
	if (dep[a] > dep[b]) std::swap(a,b);
	for (register int i = 2;i <= num_edges; ++ i) {
		int c = edges[i].u,d = edges[i].v;
		if (dep[c] > dep[d]) std::swap(c,d);
		int t1 = ch.getlca(a,c),t2 = ch.getlca(a,d),t3 = ch.getlca(b,c),t4 = ch.getlca(b,d);
		if (pre == a) {
			if (t1 == a && t2 == a && t3 == c && t4 == d) {
				/*
				a
				c
				d
				b
				*/
				continue;
			} else if (t1 == c && t2 == d) {
				/*
				c
				d
				x
				x
				*/
				a = pre = c;
				continue;
			} else if (t3 == b && t4 == b) {
				/*
				a
				b
				c
				d
				*/
				b = d;
				continue;
			} else if (dep[t3] <= dep[a]) {
				a = d;
				continue;
			}
			printf("%d\n",edges[i].w);
			stop;
		} else {
			if (dep[c] >= dep[pre] && t1 == c && t2 == d) {
				continue;
			} else if (dep[c] >= dep[pre] && t3 == c && t4 == d) {
				continue;
			} else if (t1 == a && t2 == a) {
				a = d;
				continue;
			} else if (t3 == b && t4 == b) {
				b = d;
				continue;
			}
			printf("%d\n",edges[i].w);
			stop;
		}
	}
	puts("-1");
	
	return 0;
}
```

---

## 作者：djh0314 (赞：0)

[**洛谷**](https://www.luogu.com.cn/problem/P5234)。

## 题意

有一个 $n$ 个节点，$m$ 条边的图，还有一条不确定的边，问最劣情况下的桥的权值最小值（~~极其省流版~~）。若这个图强联通则输出 $-1$。

## 分析

其实这个省流版题意就带了一定的分析了，要使有一个电网没有通电，那么必然需要使其变成两个联通块，那么我们删除的这条边也就一定是一条桥了。

首先要做的就是缩点，在处理这一类的题目时，先思考缩点后的树的情况可以节省很多没有必要的思考，可以给我们提供整个方向。

接下来我们就要思考我们这条不确定的边的影响，因为我们的答案是最劣情况下的桥的权值**最小值**，因此，我们从最小的边开始，假如这条边不能被这一条边保护，那这条边就是答案。

我们分析这一条边能保护的对象，他与原来的那棵树连成了一个环，这一条环上的我们都能保护。（令这一条边两端为 $U$，$V$）。

也就是说，我们枚举的这一条边的两边 $u$、$v$（$u$ 为 $v$ 的父亲），$U$ 与 $V$ 中必然有一个节点是 $v$ 子树下的，而另一个，必然不可以是。考虑在 $dfn$ 序上，就可以使 $U$，与 $V$ 约束在一个范围内，最后就可以解决了。

~~~cpp
sort(edge+1,edge+cnt+1);
for(int i=1; i<=cnt; ++i) {
	int u=edge[i].u,v=edge[i].v,w=edge[i].w;
	if(fa[v][0]!=u) swap(u,v);
	if(dfn[v]<=L1&&R1<=R[v]&&dfn[v]<=L2&&R2<=R[v]) print(w);
	if(dfn[v]<=L1&&R1<=R[v]) continue;
	if(dfn[v]<=L2&&R2<=R[v]) continue;
	if(L1<=dfn[v]&&R[v]<=R1) {
		L1=dfn[v],R1=R[v];
		continue;
	} else if(L2<=dfn[v]&&R[v]<=R2) {
		L2=dfn[v],R2=R[v];
		continue;
	} else print(w);
}
print(-1);
~~~

时间复杂度：$O(m\log m)$，瓶颈为排序，排序优化后可至 $O(m)$。

---


# [JSOI2013] 数字理论

## 题目描述

给定 $4$ 个正整数 $K,~S,~P,~D$，要求在十进制数中，寻找一个最小的 $K$ 位自然数 $x$，满足 $x$ 的各个数位之和为 $S$，并且 $x$ 乘以 $D$ 之后各个数位之和为 $P$。

## 说明/提示

$1~\leq~K~\leq~100,~1~\leq~S,~P~\leq~1000,~1~\leq~D~\leq~9$

## 样例 #1

### 输入

```
2 9 9 5```

### 输出

```
18```

# 题解

## 作者：zsq259 (赞：11)

## 题解 JSOI2013 数字理论

### 题面

[luogu5261](https://www.luogu.com.cn/problem/P5261)

### 解析

先判掉不存在的情况:$S>K*9||P>K*9||(S*D \ \ mod \ \ 9)!=(P \ \ mod \ \ 9)$

考虑数位 dp,

首先我们可以考虑求 $k=x*D$.

设 $f[i][s1][s2][l]=0/1$ 表示是否存在一个数 $x$ ,使得

- $dight(x/D)=s1$
- $dight(x)=s2$,
- $x \ \ mod \ \ D=l$,
- 在$x$后面添加$i$位数字后能满足题目条件

其中 $dight(i)$ 表示 $i$ 的各位数字之和.

~~好奇怪的状态...~~

边界就是 $f[0][S][P][0]=1$.

再来看转移:

枚举在 $x$ 后添加一位数字 $d$,则

$f[i][s1][s2][l]|=f[i-1][s1+(l*10+d)/D][s2+d][(l*10+d)\ \ mod \ \ D]$.

其实其中的含义仔细分析一下就能明白了...

然后贪心地从高位往低位找,找到一个符合条件的就继续找下一位.

读到这里,细心的读者一定会发现这样做会TLE,然而,这样做确实会TLE...

发现当 $i\times 9+s1<S$ 或 $i\times 9+s2<P$是都是无意义的,

并且当 $s1$ 和 $l$ 确定时,$s2 \ \ mod \ \ 9$ 也能知道,因此可以将 $s2$ 除9.

然后就能奇妙地过了...

### code

```cpp
#include <iostream>
#include <stdio.h>
#include <cstring>
#define ll long long
#define filein(a) freopen(a".cpp","r",stdin)
#define fileout(a) freopen(a".cpp","w",stdout);
using namespace std;

inline int read(){
	int sum=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&c!=EOF){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9'&&c!=EOF){sum=sum*10+c-'0';c=getchar();}
	return sum*f;
}

const int N=101;
int K,P,S,D;
bool f[N][N*9][N][10];

int main(){
	K=read();S=read();P=read();D=read();
	if(S>K*9||P>K*9||((S*D%9)^(P%9))){puts("-1");return 0;}
	f[0][S][P/9][0]=1;
	for(int i=1;i<K;i++){
		int S_st=max(S-i*9,0),P_st=max(P-i*9,0);
		for(int j=S_st;j<=S;j++){
			for(int l=0;l<D;l++){
				int mod=(j*D+l)%9;
				for(int k=P_st/9,realk=k*9+mod;realk<=P;k++,realk+=9){
					for(int d=0;!f[i][j][k][l]&&d<10;d++){
						if(f[i-1][j+(l*10+d)/D][(realk+d)/9][(l*10+d)%D]) f[i][j][k][l]=1;
					}
				}
			}
		}
	}
	int st=D;
	while(st<D*10&&!f[K-1][st/D][(st/10+st%10)/9][st%D]) st++;
	if(st==D*10){puts("-1");return 0;}
	printf("%d",st/D);
	int I=K-1,J=st/D,K=(st/10+st%10),L=st%D;
	while(I){
		int d=0;
		while(!f[I-1][J+(L*10+d)/D][(K+d)/9][(L*10+d)%D]) d++;
		printf("%d",(L*10+d)/D);
		I--;J+=(L*10+d)/D;K+=d;L=(L*10+d)%D;
	}
	return 0;
}
```

---

## 作者：Zesty_Fox (赞：9)

更好的阅读体验：[cnblogs](https://www.cnblogs.com/acceptedzhs/p/solution-p5261.html)

数位 DP 好题。

为啥没人用 `bitset` 啊...

不妨从低位往高位 DP。设 $f(i,s,x,p)$ 表示当前 DP 到第 $i$ 位，原数数位和为 $s$，$\times d$ 后给第 $i+1$ 位的进位为 $x$，$\times d$ 后的数位和为 $p$（不包括 $x$）是否可行。

枚举第 $i+1$ 位的取值 $j$，有转移：
$$
f(i+1,s+j,\left\lfloor \frac{x+jd}{10} \right\rfloor,p+((x+jd) \bmod 10)) \gets \\
f(i+1,s+j,\left\lfloor \frac{x+jd}{10} \right\rfloor,p+((x+jd) \bmod 10)) \operatorname{or} f(i,s,x,p)
$$
其中 $[i=k-1]<j\le 9$，因为最高位不能是 $0$。不难发现这可以用 `bitset` 优化。

输出方案也是可行的。首先枚举最高位（第 $k$ 位）的进位 $x$，再从高往低枚举位 $i$，最后枚举当前位的取值 $j$ 和第 $i-1$ 位给第 $i$ 位的进位 $x'$，则该取值可行当且仅当：

- $f(i-1,s-j,x',(p-jd+px) \bmod 10)=1$
- $\left\lfloor \dfrac{px+jd}{10} \right\rfloor = x$

之后执行操作：

- $x \gets x'$
- $s \gets s-j$
- $p \gets (p-jd+px) \bmod 10$
- $ans_i \gets j$
- $i \gets i-1$

直至 $i=0$。

最后答案就是 $ans$。

时间复杂度 $O(\frac{ksp}{\omega} \times b^2)$，其中 $\omega=64,b=10$。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long i64;
typedef vector<int> vi;
typedef pair<int,int> pii;

template<typename T>
inline T read(){
    T x=0,f=0;char ch=getchar();
    while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
    while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
    return f?-x:x;
}

#define rdi read<int>
#define rdi64 read<i64>
#define fi first
#define se second
#define pb push_back
#define mp make_pair

const int K=110,S=1023;

int k,s,p,d;
bitset<S> f[K][S][10];
int res[K];

int main(){
    k=rdi(),s=rdi(),p=rdi(),d=rdi();
    f[0][0][0][0]=1;
    for(int i=0;i<k;i++){
        for(int j=0;j<=i*9;j++){
            for(int x=0;x<10;x++){
                for(int cur=i==k-1;cur<=9;cur++){
                    int sum=x+cur*d;
                    f[i+1][j+cur][sum/10]|=(f[i][j][x]<<(sum%10));
                }
            }
        }
    }
    bool fl=0;
    for(int x=0;x<10;x++){
        if(p>=x&&f[k][s][x][p-x]){
            p-=x,fl=1;
            for(int i=k;i>=1;i--){
                for(int cur=i==k;cur<=9;cur++){
                    for(int px=0;px<10;px++){
                        int ps=s-cur,sum=cur*d+px;
                        if(ps<0||sum/10!=x) continue;
                        int pp=p-sum%10;
                        if(pp<0||!f[i-1][ps][px][pp]) continue;
                        res[i]=cur,x=px,s=ps,p=pp;
                        goto nxt;
                    }
                }
                nxt:;
            }
            break;
        }
    }
    if(!fl) puts("-1");
    else for(int i=k;i>=1;i--) putchar(res[i]+'0');
    return 0;
}

```


---

## 作者：Iris_Aurora (赞：0)

首先我们可以定义 dp 状态 $f_{i,S,x,P}\leftarrow 0/1$，

表示从低往高第 $i$ 位，前 $i$ 位数字和为 $S$，乘 $D$ 之后向第 $i+1$ 位进位进了 $x$，前 $i$ 位乘 $D$ 之后数字和为 $P$ 是否可行。

我们考虑优化空间复杂度，发现式子右边只是一个 bool 变量，考虑将  $P$ 移到式子右边维护，$f_{i,S,x}\leftarrow P$。

我们枚举从低到高第 $i$ 位，数字和为 $s$，乘 $D$ 之后第 $i$ 位给第 $i+1$ 位的进位是 $j$，第 $i+1$ 位上填的数是 $x$，

乘 $D$ 后的数 $res \leftarrow x\times D + j$，进位是  $Px \leftarrow \left\lfloor\dfrac{res}{10}\right\rfloor$，第 $i+1$ 位的数值是 $Py \equiv res \pmod {10}(0\le Py\le 9)$，

可以列出转移方程：

$f(i+1,s+x,Px,P+Py)\leftarrow f(i+1,s+x,Px,P+Py)$ $or$ $f(i,s,j,P)$

发现最后一位统一加上 $Py$ 的操作可以用 bitset 的右移优化。

然后再计算方案，

我们先枚举 乘 $D$ 之后第 $K$ 位给第 $K+1$ 位的进位 $val$，然后从 第 $K$ 位开始构造方案，

枚举第 $i$ 位，给第 $i+1$ 位进位 $val$，枚举第 $i-1$ 位的进位 $j$ 以及第 $i$ 位填的数 $x$ 判断是否合法即可，详细见代码。

注意第 $K$ 位不可以填 $0$。

附上代码：


```cpp
#include<bits/stdc++.h>
#define FL(i,a,b) for(int i=(a);i<=(b);i++)
#define FR(i,a,b) for(int i=(a);i>=(b);i--)
#define ll long long
using namespace std;
const int MAXN = 1e2 + 10;
const int MR = 1e3 + 10;
//f[i][S][j][P]=0/1
//f[i][S][j]=P
//bitset，f[i][S][j]表示第i位数字和为S,第i-1位进位为j，乘D的数字和的可能值 
int K,S,P,D;
int ans[MAXN];
bitset<MR>f[MAXN][MR][10];
int calc(int pos,int val){//枚举第pos个位置，上一个位置进了val次位 
	FL(x,(pos==K),9){
		FL(j,0,9){
			int res=x*D+j,px=res%10;
			if(S-x<0||P-px<0||res/10!=val||!f[pos-1][S-x][j][P-px]) continue;
			ans[pos]=x,S-=x,P-=px;
			return j;
		}
	}
}
int main(){
	scanf("%d%d%d%d",&K,&S,&P,&D);
	f[0][0][0][0]=1;
	FL(i,0,K-1){//从低位往高位进位 
		FL(s,0,i*9){//数字和 
			FL(j,0,9){//前一位的进位 
				FL(x,(i==K-1),9){//第i+1位填的数字 
					int res=x*D+j;
					f[i+1][s+x][res/10]|=(f[i][s][j]<<(res%10));//集体加上res%10（乘D之后这一位的值） 
				}
			}
		}
	}
	bool fg=0;
	FL(val,0,9){//枚举首位*D进了多少次到第K+1位 
		if(P>=val&&f[K][S][val][P-val]){
			P-=val,fg=1;
			FR(i,K,1) val=calc(i,val);
			break;
		}
	}
	if(!fg) puts("-1");
	else FR(i,K,1) printf("%d",ans[i]);
} 
```

---


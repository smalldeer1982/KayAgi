# [ZJOI2019] 线段树

## 题目描述

九条可怜是一个喜欢数据结构的女孩子，在常见的数据结构中，可怜最喜欢的就是线段树。

线段树的核心是懒标记，下面是一个带懒标记的线段树的伪代码，其中 $tag$ 数组为懒标记：

![](https://cdn.luogu.com.cn/upload/pic/55648.png)

其中函数 $\operatorname{Lson}(Node)$ 表示 $Node$ 的左儿子，$\operatorname{Rson}(Node)$ 表示 $Node$ 的右儿子。

现在可怜手上有一棵 $[1,n]$ 上的线段树，编号为 $1$。这棵线段树上的所有节点的 $tag$ 均为 $0$。接下来可怜进行了 $m$ 次操作，操作有两种：

- $1\ l\ r$，假设可怜当前手上有 $t$ 棵线段树，可怜会把每棵线段树复制两份（$tag$ 数组也一起复制），原先编号为 $i$ 的线段树复制得到的两棵编号为 $2i-1$ 与 $2i$，在复制结束后，可怜手上一共有 $2t$ 棵线段树。接着，可怜会对所有编号为奇数的线段树进行一次 $\operatorname{Modify}(root,1,n,l,r)$。

- $2$，可怜定义一棵线段树的权值为它上面有多少个节点 $tag$ 为 $1$。可怜想要知道她手上所有线段树的权值和是多少。

## 说明/提示

[1,5] 上的线段树如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/55649.png)

在第一次询问时，可怜手上有一棵线段树，它所有点上都没有标记，因此答案为 $0$。

在第二次询问时，可怜手上有两棵线段树，按照编号，它们的标记情况为：

1. 点 $[1,3]$ 上有标记，权值为 $1$。
2. 没有点有标记，权值为 $0$。

因此答案为 $1$。

在第三次询问时，可怜手上有四棵线段树，按照编号，它们的标记情况为：

1. 点 $[1,2],[3,3],[4,5]$ 上有标记，权值为 $3$。
2. 点 $[1,3]$ 上有标记，权值为 $1$。
3. 点 $[3,3],[4,5]$ 上有标记，权值为 $2$。
4. 没有点有标记，权值为 $0$。

因此答案为 $6$。

|测试点|$n$|$m$|其他约定|
|:-:|:-:|:-:|:-:|
|$1$|$\le 1000$|$\le 10$|无|
|$2$|^|^|^|
|$3$|^|$\le 1000$|^|
|$4$|^|^|^|
|$5$|$\le 10^5$|$\le 10^5$|询问只有一个|
|$6$|^|^|^|
|$7$|^|^|^|
|$8$|^|^|无|
|$9$|^|^|^|
|$10$|^|^|^|

对于 $100\%$ 的数据，$1\le l\le r\le n$。

## 样例 #1

### 输入

```
5 5
2
1 1 3
2
1 3 5
2```

### 输出

```
0
1
6```

# 题解

## 作者：Sooke (赞：229)

### 前言

先来扯些真实的废话。

这八成是考场上最可做的题，原因有以下：

> 1. 众所周知，当九条遇上诸如斗地主、麻将、五子棋等的打完暴力直接跳过。（甚至打不出暴力）
> 
> 2. 经回忆，往年省选最简单的题中往往都有线段树。
>
> 3. 大多数毒瘤场的开题顺序都是 2、3、1。

下面，我将以我场上的心路历程，来进行本题的讲解。

---

### 解题思路

既然每次有 $2^{x}$ 个线段树，它们 $\mathrm{modify}$ 的方式各不相同，我们就得好好盯着这个 $\mathrm{modify}$ 看，挖掘性质。

```cpp
void modify(int u, int l, int r, int pl, int pr) {
	if (l == pl && r == pr) {
    	pushTag(u);
    	return;
    }
    int mid = l + r >> 1;
    pushDown(u);
    if (pr <= mid) {
    	modify(u << 1, l, mid, pl, pr);
    } else if (pl > mid) {
    	modify(u << 1 | 1, mid + 1, r, pl, pr);
    } else {
    	modify(u << 1, l, mid, pl, mid);
        modify(u << 1 | 1, mid + 1, r, mid + 1, pr);
    }
}
```

尽管线段树的结点很多，实际上，根据它们的性质分类，无非也就那么五种（认真分辨，这很重要！）：

> 一类点（白色）：在 $\mathrm{modify}$ 操作中，**被半覆盖**的点。
>
> 二类点（深灰）：在 $\mathrm{modify}$ 操作中，**被全覆盖**的点，并且**能被遍历到**。
>
> 三类点（橙色）：在 $\mathrm{modify}$ 操作中，**未被覆盖**的点，并且**可以得到 $\mathrm{pushdown}$ 来的标记**。
>
> 四类点（浅灰）：在 $\mathrm{modify}$ 操作中，**被全覆盖**的点，并且**不能被遍历到**。
>
> 五类点（黄色）：在 $\mathrm{modify}$ 操作中，**未被覆盖**的点，并且**不可能得到 $\mathrm{pushdown}$ 来的标记**。

![](https://i.loli.net/2019/04/02/5ca2b0fce8b8c.png)

在代码中，五种点分别是这样出现的：

```cpp
void modify(int u, int l, int r, int pl, int pr) {
	if (l == pl && r == pr) {
    	pushTag(u); // 给二类点打标记。
        // 之后的 pushdown，可能会把标记带到二类点以下的四类点去。
    	return;
    }
    int mid = l + r >> 1;
    pushDown(u); // 这里是一类点，会进行 pushdown 操作。
    if (pr <= mid) {
    	modify(u << 1, l, mid, pl, pr);
        // u << 1 | 1 一边就是三类点，上面的 pushdown 会传到这里。
    	// 之后的 pushdown，可能会把标记带到三类点以下的五类点去。
    } else if (pl > mid) {
    	modify(u << 1 | 1, mid + 1, r, pl, pr);
        // u << 1 一边就是三类点，上面的 pushdown 会传到这里。
        // 之后的 pushdown，可能会把标记带到三类点以下的五类点去。
    } else {
    	modify(u << 1, l, mid, pl, mid);
        modify(u << 1 | 1, mid + 1, r, mid + 1, pr);
    }
}
```

类别是分得蛮清楚了，但这又有什么卵用呢？注意到同类点性质相同，倘若给它们记录 $\mathrm{dp}$ 值，它们的转移也完全相同。

没错！由于转移视类别而定，只有五种，我们可以考虑**只用一棵**线段树，然后在线段树上 $\mathrm{dp}$ ！于是最容易想到的状态定义：

> 设 $f_{i,\ u}$ 为第 $i$ 次 $\mathrm{modify}$ 后，$u$ 号点在 $2^i$ 棵线段树中，多少棵被打标记。

看上去非常可做！赶紧试试五种点下的转移分别是什么？

---

#### 一类点

显然只在一类点 $\mathrm{pushdown}$，只要 $\mathrm{modify}$ ，一类点的标记就莫得存留。不 $\mathrm{modify}$ ，当然保持原状。

$$f_{i,\,u} = 0 + f_{i-1,\,u}$$

#### 二类点

只在二类点上直接打标记，所以只要 $\mathrm{modify}$ ，二类点就一定存在标记，否则保持原状。

$$f_{i,\,u} = 2^{i-1} + f_{i-1,\,u}$$

#### 三类点

不 $\mathrm{modify}$ 仍然保持，要是 $\mathrm{modify}$ ，那得通过 $\mathrm{pushdown}$ 才能让它有标记，这意味着它到根结点的一类点上，必须有至少一个原本被打标记。或者自己原本就有标记，$\mathrm{pushdown}$ 不会将其抹除。

$$f_{i,\,u} = ... + f_{i-1,\,u}$$

哈？为什么要用 $...$？因为这次的转移有条件了，不能这么简单地用 $f$ 了！前功尽弃了吗？

---

当然没有！办法有得是！我们不妨将需要的那个状态定义出来：

> 设 $g_{i,\,u}$ 为第 $i$ 次 $\mathrm{modify}$ 后，$u$ 号点在 $2^i$ 棵线段树中，多少棵满足 $1\to u$ 上没有任何标记。
>
> 反过来，满足 $1\to u$ 上至少有一个标记，就是 $2^{i} - g_{i,\,u}$ 。

这次准备挺充分了！再试试？

---

#### 一类点

同样的道理，只要 $\mathrm{modify}$ ，$1 \to u$ 的路径上的标记全部被 $\mathrm{pushdown}$ 走。

$$\begin{cases}f_{i,\,u} = 0 + f_{i-1,\,u}\\g_{i,\,u} = 2^{i-1} + g_{i-1,\,u}\end{cases}$$

#### 二类点

只要 $\mathrm{modify}$ ，$u$ 号点上一定有标记。

$$\begin{cases}f_{i,\,u} = 2^{i-1} + f_{i-1,\,u}\\g_{i,\,u} = 0 + g_{i-1,\,u}\end{cases}$$

#### 三类点

这是刚才的难点，现在有备无患了。必须 $1 \to u$ 上至少存有一个标记，才能把标记 $\mathrm{modify}$ 到三类点 $u$ 上。同理，$1 \to u$ 上没有标记，操作还是不操作，仍然不会有标记。

$$\begin{cases}f_{i,\,u} = (2^{i-1}-g_{i-1,\,u})+ f_{i-1,\,u}\\g_{i,\,u} = g_{i-1,\,u} + g_{i-1,\,u}\end{cases}$$

#### 四类点

不管是四类点还是五类点，都算是 $f$ 的盲区，既不会 $\mathrm{pushdown}$ 到，更不会像二类点直接被打上标记。所以原本有无标记，即使 $\mathrm{modify}$ ，依旧是那个样。

四类点和五类点的 $g$ 就分别跟二类点和三类点一样了，二类点的存在，使得其下属四类点在 $\mathrm{modify}$ 中不可能“门前清”。

$$\begin{cases}f_{i,\,u} = f_{i-1,\,u} + f_{i-1,\,u}\\g_{i,\,u} = 0 + g_{i-1,\,u}\end{cases}$$

#### 五类点



$$\begin{cases}f_{i,\,u} = f_{i-1,\,u} + f_{i-1,\,u}\\g_{i,\,u} = g_{i-1,\,u} + g_{i-1,\,u}\end{cases}$$

#### 边界

这总不用说了吧。

$$\begin{cases}f_{0,\,u} = 0\\g_{0,\,u} = 1\end{cases}$$

---

这一遍下来，转移好像没啥问题了。最后是怎么实现。

每次修改暴力转移每个点绝对是不可能的。发现每次一类点、二类点、三类点只有 $O(\log n)$ 个，可以暴力，四类点、五类点有 $O(n)$ 个，然而请看它们的转移式，这显然是可以用懒标记维护的类型。

除此之外，维护 $sf_{u} = f_{u} + sf_{2u} + sf_{2u+1}$ ，即 $u$ 子树中 $f$ 的总和。易知 $sf_{1}$ 就是询问答案。

---

### 代码实现

具体实现中可以通过把“方案数”转成“概率”从而减少一半的懒标记和常数，本人较懒，就没写了。

常见错误：

> 1. 空间开小，以写法不同，四倍空间不一定足够，建议在空间方面任性一点。
>
> 2. $\mathrm{pushup}$ 和 $\mathrm{pushdown}$ 不充分，多 $\mathrm{push}$ 几下不容易错。
>
> 3. 转移顺序不要错，先 $f$ 后 $g$ 。

```cpp
#include <cstdio>

inline int read() {
    char c = getchar(); int x = 0;
    while (c < '0' || c > '9') { c = getchar(); }
    while (c >= '0' && c <= '9') { x = (x << 1) + (x << 3) + (c & 15); c = getchar(); }
    return x;
}

const int N = 2000005, p = 998244353;

inline int add(int x, int y) { x += y; return x >= p ? x - p : x; }
inline int sub(int x, int y) { x -= y; return x >= 0 ? x : x + p; }

int n, m, k = 1;

struct SegmentTree {
    int f[N], g[N], tf[N], tg[N], sf[N];

    inline void pushUp(int u) { sf[u] = add(f[u], add(sf[u << 1], sf[u << 1 | 1])); }
    inline void pushTf(int u, int x) { f[u] = 1ll * f[u] * x % p; tf[u] = 1ll * tf[u] * x % p; sf[u] = 1ll * sf[u] * x % p; }
    inline void pushTg(int u, int x) { g[u] = 1ll * g[u] * x % p; tg[u] = 1ll * tg[u] * x % p; }
    inline void pushDown(int u) {
        if (tf[u] != 1) { pushTf(u << 1, tf[u]); pushTf(u << 1 | 1, tf[u]); tf[u] = 1; }
        if (tg[u] != 1) { pushTg(u << 1, tg[u]); pushTg(u << 1 | 1, tg[u]); tg[u] = 1; }
    }
    void build(int u, int l, int r) {
        g[u] = tf[u] = tg[u] = 1; // 边界。
        if (l == r) { return; } int mid = l + r >> 1;
        build(u << 1, l, mid); build(u << 1 | 1, mid + 1, r);
    }
    void modify(int u, int l, int r, int pl, int pr) {
        pushDown(u);
        if (l == pl && r == pr) {
            f[u] = add(f[u], k); // 二类点。
            pushTf(u << 1, 2); pushTf(u << 1 | 1, 2); // 四类点。
        } else {
            int mid = l + r >> 1, ul = u << 1, ur = ul | 1;
            g[u] = add(g[u], k); // 一类点。
            if (pr <= mid) {
                modify(ul, l, mid, pl, pr); pushDown(ur);
                f[ur] = add(f[ur], sub(k, g[ur])); g[ur] = add(g[ur], g[ur]); // 三类点。
                pushTf(ur << 1, 2); pushTf(ur << 1 | 1, 2);
                pushTg(ur << 1, 2); pushTg(ur << 1 | 1, 2); // 五类点。
                pushUp(ur);
            } else if (pl > mid) {
                modify(ur, mid + 1, r, pl, pr); pushDown(ul);
                f[ul] = add(f[ul], sub(k, g[ul])); g[ul] = add(g[ul], g[ul]); // 三类点。
                pushTf(ul << 1, 2); pushTf(ul << 1 | 1, 2);
                pushTg(ul << 1, 2); pushTg(ul << 1 | 1, 2); // 五类点。
                pushUp(ul);
            } else {
                modify(ul, l, mid, pl, mid); modify(ur, mid + 1, r, mid + 1, pr);
            }
        }
        pushUp(u);
    }
} smt;

int main() {
    n = read(); m = read(); smt.build(1, 1, n);
    for (int opt, l, r; m; m--) {
        opt = read();
        if (opt == 1) {
            l = read(); r = read();
            smt.modify(1, 1, n, l, r); k = add(k, k);
        } else { printf("%d\n", smt.sf[1]); }
    }
    return 0;
}
```

---

### 尾注

这题的给点分类的思路算是比较妙的了，不少人设出了 $f$ ，却止步于想出 $g$ 的路上，这提示我们想题就要想连贯，但也不能想得太死，适当控制才有了考试的最优策略。

---

## 作者：小粉兔 (赞：27)

在博客园食用更佳：[https://www.cnblogs.com/PinkRabbit/p/ZJOI2019D1T2.html](https://www.cnblogs.com/PinkRabbit/p/ZJOI2019D1T2.html)

### 题意简述：

你需要模拟线段树的懒标记过程。

初始时有一棵什么标记都没有的 $n$ 阶线段树。

每次修改会把当前所有的线段树复制一份，然后对于这些线段树实行一次区间修改操作。

即每次修改后线段树棵数翻倍，第 $i$ 次修改后，线段树共有 $2^i$ 棵。

区间修改操作的伪代码如下：

![](https://cdn.luogu.com.cn/upload/pic/56287.png)

和我日常写的递归式线段树完全一致。

每次询问你这些线段树中有懒标记的节点总数。

修改和询问的总个数为 $q$，$1\le n,q\le 10^5$。

### 题解：

灵感来源自 Sooke 的题解。

考察一次区间修改操作会影响到的节点，共有 $5$ 类：

1. 与修改区间相交，但不包含在修改区间内部的节点（浅紫色）。

2. 包含在修改区间内部，但其父亲不存在或不包含在修改区间内部（浅蓝色）。

3. 与修改区间相离，但其父亲与修改区间相交（浅橙色）。

4. 包含在修改区间内部，且其父亲也包含在修改区间内部（深蓝色）。

5. 与修改区间相离，且其父亲也与修改区间相离（深橙色）。

![](https://cdn.luogu.com.cn/upload/pic/55713.png)

将节点分为这 $5$ 类并不是没有根据的，可以发现：

若伪代码运行到了第 $17$ 行，则访问到的是第 $1$ 类节点。  
若伪代码运行到了第 $14$ 行，则访问到的是第 $2$ 类节点。  
若伪代码运行到了第 $11$ 行，则访问到的是第 $3$ 类节点。  
而第 $4,5$ 类节点分别是第 $2,3$ 类节点的子孙。

根据线段树的复杂度，第 $1,2,3$ 类节点的个数均为 $\mathcal{O}(\log n)$，而第 $4,5$ 类节点的个数为 $\mathcal{O}(n)$。

接下来分析每次操作时受到影响的节点：

对于第 $1$ 类节点，操作后它们必然无懒标记。  
对于第 $2$ 类节点，操作后它们必然有懒标记。  
对于第 $3$ 类节点，操作后它们有无懒标记取决于操作前这个节点到根的链上有无懒标记。  
对于第 $4,5$ 类节点，操作后它们不受影响。

我们考虑维护每次操作后每个节点 $u$ 有懒标记的树的占比，即在 $2^i$ 棵树中，节点 $u$ 有懒标记的树的比值，记作 $\mathrm{f}[u]$。  
同时，因为第 $3$ 类节点需要额外信息，维护每次操作后每个节点 $u$ 到根的路径上有懒标记的树的占比，记作 $\mathrm{g}[u]$。

接下来我们考虑一次操作后，每个节点的信息如何更新，注意到同类节点的更新方式是相同的：

对于第 $1$ 类节点，一半保持原样，另一半无标记，所以 $\left\langle\mathrm{f}[u],\mathrm{g}[u]\right\rangle=\left\langle\frac{1}{2}\mathrm{f}[u],\frac{1}{2}\mathrm{g}[u]\right\rangle$。

对于第 $2$ 类节点，一半保持原样，另一半有标记，所以 $\left\langle\mathrm{f}[u],\mathrm{g}[u]\right\rangle=\left\langle\frac{1}{2}\mathrm{f}[u]+\frac{1}{2},\frac{1}{2}\mathrm{g}[u]+\frac{1}{2}\right\rangle$。

对于第 $3$ 类节点，一半保持原样，另一半的标记取决于 $u$ 到根的路径，所以 $\left\langle\mathrm{f}[u],\mathrm{g}[u]\right\rangle=\left\langle\frac{1}{2}(\mathrm{f}[u]+\mathrm{g}[u]),\mathrm{g}[u]\right\rangle$。

对于第 $4$ 类节点，一半保持原样，另一半标记不受影响，但到根的路径上一定有标记，所以 $\left\langle\mathrm{f}[u],\mathrm{g}[u]\right\rangle=\left\langle\mathrm{f}[u],\frac{1}{2}\mathrm{g}[u]+\frac{1}{2}\right\rangle$。

对于第 $5$ 类节点，一半保持原样，另一半标记不受影响，到根的路径上的标记也不受影响，所以 $\left\langle\mathrm{f}[u],\mathrm{g}[u]\right\rangle=\left\langle\mathrm{f}[u],\mathrm{g}[u]\right\rangle$。

第 $5$ 类节点的信息没有更改，第 $4$ 类节点仅有 $\mathrm{g}$ 有更改，因为第 $4$ 类节点有 $\mathcal{O}(n)$ 个，所以必须采用打懒标记的方法来维护。

而对于前 $3$ 类，直接维护即可。

再多维护一个 $\mathrm{Sf}[u]$ 表示 $u$ 的子树中 $\mathrm{f}[v]$ 值之和即可统计答案。

```cpp
#include <cstdio>

typedef long long LL;
const int Mod = 998244353;
const int Inv2 = 499122177;
const int MS = 1 << 18;

inline int Add(int x, int y) {
	return (x += y) >= Mod ? x - Mod : x;
}

int N, M;

int f[MS], g[MS], Sf[MS], T[MS];
inline void P(int i, int x) {
	g[i] = ((LL)g[i] * x + 1 - x + Mod) % Mod;
	T[i] = (LL)T[i] * x % Mod;
}
inline void Upd(int i, int Ty) {
	if (Ty) Sf[i] = f[i];
	else Sf[i] = Add(f[i], Add(Sf[i << 1], Sf[i << 1 | 1]));
}
inline void Psd(int i) {
	P(i << 1, T[i]);
	P(i << 1 | 1, T[i]);
	T[i] = 1;
}
void Build(int i, int l, int r) {
	T[i] = 1;
	if (l != r) {
		Build(i << 1, l, (l + r) >> 1);
		Build(i << 1 | 1, ((l + r) >> 1) + 1, r);
	}
}
void Mdf(int i, int l, int r, int a, int b) {
	if (r < a || b < l) {
		f[i] = (LL)(f[i] + g[i]) * Inv2 % Mod;
		Upd(i, l == r);
		return ;
	}
	if (a <= l && r <= b) {
		f[i] = (LL)(f[i] + 1) * Inv2 % Mod;
		Upd(i, l == r);
		P(i, Inv2);
		return ;
	}
	Psd(i);
	f[i] = (LL)f[i] * Inv2 % Mod;
	g[i] = (LL)g[i] * Inv2 % Mod;
	Mdf(i << 1, l, (l + r) >> 1, a, b);
	Mdf(i << 1 | 1, ((l + r) >> 1) + 1, r, a, b);
	Upd(i, 0);
}

int main() {
	scanf("%d%d", &N, &M);
	Build(1, 1, N);
	for (int m = 1, C = 1; m <= M; ++m) {
		int op, l, r;
		scanf("%d", &op);
		if (op == 1) {
			scanf("%d%d", &l, &r);
			Mdf(1, 1, N, l, r);
			C = Add(C, C);
		}
		else printf("%lld\n", (LL)C * Sf[1] % Mod);
	}
	return 0;
}
```

---

## 作者：shadowice1984 (赞：22)

~~4年zjoi3年线段树~~

~~zjoi的开题顺序永远是231~~

~~zjoi只有数据结构题能做~~

说实话这题真的该蓝，因为**它 实 在 是 太 简 单 了**

## 前置芝士:线段树

你只需要提高组的基础线段树芝士就可以通过此题
________

## 本题题解

### 一个小转化

首先你会发现那个复制线段树操作其实是假的

通过归纳法我们就可以证明，假设经过了$m$次操作1，那么你手中的$2^m$棵线段树刚好对应了操作集合的$2^m$个子集

因此我们的操作2实际上在询问对于每一个操作集合的子集，线段树上为1的tag个数之和

### dp!

根据计数题的一般套路，我们应该考虑每一个节点对答案的贡献，

所以我们不妨设$dp(i)$表示节点的tag值为1的方案数

但是这样设我们会很快的发现一个问题是，我们每执行一次操作，线段树上所有节点的dp值都会变动，尽管你会发现只有$O(logn)$个节点的tag可能会发生变动，其他节点的tag应该和上一次操作一模一样，但是这些节点的dp值都要乘2……

这样设计dp实在是太蠢了，所以不如让我们想点trick，减少dp值变动的点的个数

### 方案数转概率

我们重新定义一下dp数组的定义$dp(i)$表示，如果我们等概率的从$2^m$个操作集合当中选择一个操作集合并执行，那么$i$的tag是1的**概率**

这样搞有什么好处呢？

如果这个节点在这一次修改当中没有被改到，那么这个点是1的概率将**保持不动**,那么一次修改下来只有$O(logn)$个节点的$dp$值会发生变动，我们就可以暴力更改这些点的dp值了

此时我们把各个点是1的概率加起来就得到了线段树中是1的tag的期望个数了

啊可是答案要算的是1的个数之和不是期望啊？

平常我们算期望的时候是计算所有方案下的和然后除总的方案数，这里我们反过来，算出期望然后乘总的方案数，这样我们就能算出来1的个数之和啦~

有了船新的dp定义之后自然要推转移啦~

为了规避繁杂的细节和分类讨论，我们需要重新看待一次修改的过程

正常状态下，我们会把线段树的修改操作看成按照一定顺序连续执行的pushdown，这样会很好写也很好实现

但是这样你会发现你的转移不好推了，怎么办呢？

考虑这样一个问题:如果知道了操作之前的线段树长什么，那么我们能不能直接推出操作之后的线段树呢？

答案是可行的~，我们把线段树的节点分为3类(似乎这样设计的状态会比分5种情况讨论的做法细节少一点？)


![](https://cdn.luogu.com.cn/upload/pic/55708.png)

当修改区间$[3,5]$的时候，dp值会发生变化的的点在图中被染成了红色，灰色，和黑色

接下来我们分情况讨论一下红点和灰点和黑点的转移情况

####  红点

>容易看出，只要执行了这一次操作那么红点的tag必然是0，所以这里的转移只需要把红点的dp值除2就行了

>$$dp(u)=dp(u)/2$$

#### 黑点

>容易看出，只要执行了这一次操作那么黑点的tag必然是1，所以这里我们把黑点的dp值加1然后除2就行了

>$$dp(u)=(dp(u)+1)/2$$

#### 灰点

>容易看出，我们什么性质也看不出来

>因为即使执行了这次操作，灰点的tag也可能是0

>因此灰点莫得转移，这个状态定义翻!车!了!

## 新的状态定义

因为灰点没法转移，所以我们要定义一些新的状态，让我们可以转移

考虑一个灰点的tag什么时候会变成1，我们发现只要这个灰点到线段树的根的路径上有tag为1的节点，那么这个灰点的tag在操作之后就是1

因此我们新增一个$fdp(i)$状态表示这个点到根的路径上有1的概率

$fdp(i)$的引入会带来一些问题，就是一次修改之后$fdp$值发生变化的节点数目不再是$O(logn)$的了,这个问题我们过一会再说,先让我们重新推一推转移

### 红点

>容易看出,执行了这次操作后，红点到根的路径全部是红点，所以红点到根的路径不会有1，因此直接把fdp值除2就行了

>$$fdp(u)=fdp(u)/2$$

### 灰点

>容易看出，执行了这次操作之后,如果灰点到根的路径上有1，那么灰点的tag就是1，否则不是1，所以把灰点的dp值加上fdp值除2就行了

>另一个性质是对于在灰点子树当中的节点，修改之前如果到根的路径上有1，那么这个1最多是被push到灰点上而已，因此这一次修改并不会改变这个节点到根的路径上是否有1这个命题的真假,所以灰点子树当中的节点fdp值并不会动

>$$dp(u)=(dp(u)+fdp(u))/2$$

### 黑点

>容易看出，执行这次操作之后,对于黑点子树当中的所有点，他们到根的路径上肯定有1了，那么我们把fdp值加上1然后除2就行了

>$$fdp(u)=(fdp(u)+1)/2$$

## 打标记

上面的转移方程涉及到对黑点子树当中的所有点做$x=(x+1)/2$这样的操作，显然我们不能暴力做，所以我们维护一个懒标记表示这个点被执行了几次这样的操作

容易看出,如果一个节点原来的值是$val$,被连续执行了$n$次操作，那么这个点的真实值将会是

$$(val+2^n-1)/2^n$$

然后我们就可以打标记维护fdp值了，每次修改的时候用bfs找出所有的红点黑点灰点按照转移方程转移即可~

总复杂度$O(mlogn)$,不是很清楚3000ms的时限意义何在……

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
using namespace std;const int N=1e5+10;typedef unsigned long long ll;const ll mod=998244353;
const ll iv2=(mod+1)/2;ll imi[N];ll dmi[N];ll mi[N];int n;int m;
# define md(x) (x=(x>=mod)?x-mod:x)
struct linetree
{
    ll sum;ll dp[N<<2];ll fdp[N<<2];int l[N<<2];int r[N<<2];int add[N<<2];
    int qu1[N];int hd1;int qu2[N];int hd2;int qu3[N];int hd3;
    int qu[N];int hd;int tl;
    inline void chan(int p,int tmp)
    {sum+=mod-dp[p];md(sum);dp[p]=(dp[p]+tmp)*iv2%mod;sum+=dp[p];md(sum);}
    inline void pd(int p)//下传标记 
    {
        if(add[p]!=0)
        {
            fdp[p<<1]=(fdp[p<<1]+dmi[add[p]])*imi[add[p]]%mod;
            fdp[p<<1|1]=(fdp[p<<1|1]+dmi[add[p]])*imi[add[p]]%mod;
            add[p<<1]+=add[p];add[p<<1|1]+=add[p];add[p]=0;
        }
    }inline void extract(int dl,int dr)//bfs
    {
        hd=1;tl=0;qu[++tl]=1;hd1=hd2=hd3=0;
        while(hd<=tl)
        {
            int nw=qu[hd++];
            if(dl<=l[nw]&&r[nw]<=dr){qu2[++hd2]=nw;continue;}
            if(r[nw]<dl||l[nw]>dr){qu3[++hd3]=nw;continue;}
            qu1[++hd1]=nw;pd(nw);qu[++tl]=nw<<1;qu[++tl]=nw<<1|1;
        }
    }inline void modify(int dl,int dr)//按照转移方程转移同时打标记 
    {
        extract(dl,dr);for(int i=1;i<=hd1;i++)chan(qu1[i],0);
        for(int i=1;i<=hd2;i++)chan(qu2[i],1);
        for(int i=1;i<=hd2;i++)add[qu2[i]]++,fdp[qu2[i]]=(fdp[qu2[i]]+1)*iv2%mod;
        for(int i=1;i<=hd3;i++)chan(qu3[i],fdp[qu3[i]]);
        for(int i=1;i<=hd1;i++)fdp[qu1[i]]=fdp[qu1[i]]*iv2%mod;
        
    }inline void build(int p,int pl,int pr)//建树 
    {
        if(pl>pr)return;l[p]=pl;r[p]=pr;if(pl==pr)return;
        int mid=(pl+pr)>>1;build(p<<1,pl,mid);build(p<<1|1,mid+1,pr);
    }
}lt;
int main()
{
    imi[0]=1;for(int i=1;i<N;i++)imi[i]=imi[i-1]*iv2%mod;
    mi[0]=1;for(int i=1;i<N;i++)mi[i]=mi[i-1]*2%mod;
    dmi[0]=0;for(int i=1;i<N;i++)dmi[i]=(mi[i]+mod-1)%mod;
    scanf("%d%d",&n,&m);lt.build(1,1,n);int tot=0;
    for(int i=1,tp,l,r;i<=m;i++)
    {
        scanf("%d",&tp);
        if(tp==1)scanf("%d%d",&l,&r),lt.modify(l,r),tot++;
        else printf("%lld\n",lt.sum*mi[tot]%mod);
    }return 0;//拜拜程序~ 
}
```























---

## 作者：StudyingFather (赞：7)

我们按照题目中的伪代码，将**能遍历到的点**分为三类（遍历不到的点 $tag$ 不变，所以不作讨论）：

- 完全覆盖的点：这个点对应的区间是指定询问区间的子集。
- 完全没覆盖的点：这个点对应的区间和指定询问区间的交集为空。
- 半覆盖的点：不属于上述两类的点。

根据代码，递归遍历到半覆盖的点时会继续向下遍历，而遇到其他两类点时会终止遍历。

写成代码的形式是这样的：

```cpp
void update(int rt,int cl,int cr,int l,int r)
{
 if(r<cl||cr<l)return;//完全没覆盖的点
 if(l<=cl&&cr<=r)//完全覆盖的点
 {
  tag[rt]=1;
  return;
 }
 //半覆盖的点
 pushdown(rt);//显然这里被更新的点下面都会遍历到
 int mid=(cl+cr)>>1;
 update(rt<<1,cl,mid,l,r);
 update(rt<<1|1,mid+1,cr,l,r);
}
```

因为线段树只会复制，形态不会改变，因此我们可以在一棵线段树里维护每个节点的信息。

设 $f_i$ 表示 $i$ 号节点 $tag$ 的期望值。

（所有节点的期望值加起来，再乘以树的总数，就可以得到所求答案了）

我们分类讨论下：

- 对于完全覆盖的点：经过修改后这个点的 $tag$ 一定为 $1$，从而有 $f_i=(f_i+1)/2$；
- 对于半覆盖的点：因为有 pushdown，这个点的 $tag$ 一定为零，从而有 $f_i=f_i/2$；
- 对于完全没覆盖的点：仅凭现有的信息无法计算。一个完全没覆盖的点是否打上 $tag$，取决于这个点到根节点的路径上是否存在一个有 $tag$ 的点（这样就可以通过 pushdown 的方式使该点获取到 $tag$），我们需要多维护一些信息来进行计算。

于是我们设 $g_i$ 表示 $i$ 号节点到根节点的路径上有 $tag$ 的概率。

继续分类讨论：

- 对于完全覆盖的点：经过修改后该点一定有 $tag$，从而**该点所在子树的所有节点**都有 $g_i=(g_i+1)/2$；
- 对于半覆盖的点：其到根节点的所有点标记都已经下放，从而没有标记，即 $g_i=g_i/2$；
- 对于完全没覆盖的点：如果其到根节点的路径上有 $tag$，则这个点会带上 $tag$，否则这个点以及这个点到根节点的路径上都没有标记，即 $f_i=(f_i+g_i)/2$（根据上面的描述，$g_i$ 的值不会改变）。

我们发现一次修改操作最多更新 $O(\log n)$ 个 $f$ 的值，但是 $g$ 的值最坏情况下（因为有对一个子树内所有点的更新操作）会更新 $O(n)$ 个。

为了防止这种事情发生，我们需要打标记来处理“修改一个子树的 $g$ 值”这一操作。

向 $i$ 号点下放一个修改 $x$ 次的标记的时候，将 $g_i$ 作如下处理：

$$g_i=(g_i+2^x-1)/2^x$$

这样这题就做完了。

下面这份代码目前在 loj 上跑的是最快的。

```cpp
// Problem : P5280 [ZJOI2019]线段树
// Contest : Luogu Online Judge
// URL : https://www.luogu.com.cn/problem/P5280
// Author : StudyingFather
// Site : https://studyingfather.com
// Memory Limit : 500 MB
// Time Limit : 3000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <iostream>
#include <algorithm>
#define MOD 998244353
#define INV2 499122177
using namespace std;
struct seg
{
 long long f,g,s,tag;
}s[800005];
long long p[100005],invp[100005];
void pushup(int rt)
{
 s[rt].s=(s[rt<<1].s+s[rt<<1|1].s+s[rt].f)%MOD;
}
void pushdown(int rt)
{
 int tag=s[rt].tag;
 s[rt<<1].tag+=tag;
 s[rt<<1|1].tag+=tag;
 s[rt<<1].g=(s[rt<<1].g+p[tag]-1)*invp[tag]%MOD;
 s[rt<<1|1].g=(s[rt<<1|1].g+p[tag]-1)*invp[tag]%MOD;
 s[rt].tag=0;
}
void update(int rt,int cl,int cr,int l,int r)
{
 if(cr<l||r<cl)
 {
  s[rt].f=(s[rt].f+s[rt].g)*INV2%MOD;
  pushup(rt);
  return;
 }
 if(l<=cl&&cr<=r)
 {
  s[rt].f=(s[rt].f+1)*INV2%MOD;
  s[rt].g=(s[rt].g+1)*INV2%MOD;
  s[rt].tag++;
  pushup(rt);
  return;
 }
 s[rt].f=s[rt].f*INV2%MOD;
 s[rt].g=s[rt].g*INV2%MOD;
 pushdown(rt);
 int mid=(cl+cr)>>1;
 update(rt<<1,cl,mid,l,r);
 update(rt<<1|1,mid+1,cr,l,r);
 pushup(rt);
}
int main()
{
 ios::sync_with_stdio(false);
 int n,m;
 cin>>n>>m;
 p[0]=invp[0]=1;
 for(int i=1;i<=m;i++)
 {
  p[i]=p[i-1]*2%MOD;
  invp[i]=invp[i-1]*INV2%MOD;
 }
 int cnt=0;
 while(m--)
 {
  int op;
  cin>>op;
  if(op==1)
  {
   int l,r;
   cin>>l>>r;
   update(1,1,n,l,r);
   cnt++;
  }
  else cout<<s[1].s*p[cnt]%MOD<<endl;
 }
 return 0;
}
```

---

## 作者：VenusM1nT (赞：6)

DP + 线段树。

神仙题啊神仙题……我这种蒟蒻赛场上啥也不会，打了一个 $20$ 分的暴力就滚粗了……DP 有一点苗头但是因为我是 DP 低能儿，所以推式子什么的还是不大可能的……

赛后在各路神仙的帮助下总算是搞懂了一些……

Sooke 把点分成了 $5$ 种，但其实也可以分成 $4$ 种。

令操作区间为 $[tl,tr]$，线段树上当前节点为 $[l,r]$，则：

 1. 节点会被访问，即 $tl\leq l\leq r\leq tr$，显然它一定是 $1$，所以它的贡献要加上 $2^{i-1}$（$i$ 为操作编号）。
 
 2. 节点未被访问，即未被修改或下传，显然其贡献不变，而因为线段树的数量翻倍，则其贡献 $\times 2$。
 
 3. 该节点为 $1.$ 类的祖先，则其显然会在当前操作中被下放，所以贡献不变。
 
 4. 只被下放，但没有访问过的结点。对于这种点，我们令 $f_i$ 表示使 $i$ 到根节点存在 $1$ 的操作情况数，而这些点的贡献需要加上 $f_i$。
 
显然，只要能够维护 $f$，那么 $1,3,4$ 操作都可以 $\log n$ 维护，我们考虑 $1,3$ 操作产生的贡献 $sum$，那么 $ans$ 只需要更新为 $(ans-sum)\times 2+sum$ 即可，这样相当于直接 $\times 2$，就不用考虑 $2$ 操作了。

那么问题回到如何处理 $f$，其实也非常简单，对于 $1.$，我们直接加上 $2^{i-1}$，因为它自己就是 $1$；对于 $2,4$，因为复制前后都不变，所以 $\times 2$ 即可；而对于 $3$，显然它和它的祖先都是 $0$，所以不变。

```cpp
#include<bits/stdc++.h>
#define MAXN 100005
#define reg register
#define inl inline
#define int long long
//#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
using namespace std;
const int Mod=998244353;
int n,m,T,t[MAXN<<2],f[MAXN<<2],tag[MAXN<<2],taga[MAXN<<2],tagm[MAXN<<2],ans,sum;
template <typename T> inl void Read(reg T &x)
{
	x=0;
	reg int fu=1;
	reg char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') fu=-1;
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch-48);
	x*=fu;
}
inl int Add(reg int x,reg int y)
{
	return x+y>Mod?x+y-Mod:x+y;
}
inl int Dec(reg int x,reg int y)
{
	return x-y<0?x-y+Mod:x-y;
}
inl int Mul(reg int x,reg int y)
{
	return x*y-x*y/Mod*Mod;
}
inl void MulT(reg int rt,reg int x)
{
	t[rt]=Mul(t[rt],x);
	tagm[rt]=Mul(tagm[rt],x);
}
inl void MulF(reg int rt,reg int x)
{
	f[rt]=Mul(f[rt],x);
	tag[rt]=Mul(tag[rt],x);
	taga[rt]=Mul(taga[rt],x);
}
inl void AddF(int rt,int x)
{
	f[rt]=Add(f[rt],x);
	taga[rt]=Add(taga[rt],x);
}
inl void PushDown(reg int rt)
{
	if(tagm[rt]>1)
	{
		MulT(rt<<1,tagm[rt]);
		MulT(rt<<1|1,tagm[rt]);
		tagm[rt]=1;
	}
	if(tag[rt]>1)
	{
		MulF(rt<<1,tag[rt]);
		MulF(rt<<1|1,tag[rt]);
		tag[rt]=1;
	}
	if(taga[rt])
	{
		AddF(rt<<1,taga[rt]);
		AddF(rt<<1|1,taga[rt]);
		taga[rt]=0;
	}
}
void Modify(reg int rt,reg int l,reg int r,reg int tl,reg int tr)
{
	if(tl<=l && r<=tr)
	{
		ans=Dec(ans,t[rt]);
		t[rt]=Add(t[rt],T);
		tagm[rt]=Mul(tagm[rt],2);
		AddF(rt,T);
		sum=Add(sum,t[rt]);
		return;
	}
	if(tl>r || l>tr)
	{
		ans=Dec(ans,t[rt]);
		t[rt]=Add(t[rt],f[rt]);
		tagm[rt]=Mul(tagm[rt],2);
		MulF(rt,2);
		sum=Add(sum,t[rt]);
		return;
	}
	reg int mid=l+r>>1;
	PushDown(rt);
	ans=Dec(ans,t[rt]);
	sum=Add(sum,t[rt]);
	Modify(rt<<1,l,mid,tl,tr);
	Modify(rt<<1|1,mid+1,r,tl,tr);
}
signed main()
{
	Read(n);
	Read(m);
	T=1;
	for(reg int i=1;i<=n*4;i++) tag[i]=tagm[i]=1;
	while(m--)
	{
		reg int opt,x,y;
		Read(opt);
		if(opt==1)
		{
			Read(x);
			Read(y);
			sum=0;
			Modify(1,1,n,x,y);
			ans=Add(Mul(ans,2),sum);
			T=Mul(T,2);
		}
		else printf("%lld\n",ans);
	}
	return 0;
}
```

感谢这位大佬的博客：[blog](http://blog.leanote.com/post/richard_love_oi/%E3%80%8CZJOI2019%E3%80%8D%E7%BA%BF%E6%AE%B5%E6%A0%91)。

---

## 作者：yybyyb (赞：4)

首先问题等价于前面每次操作都可能进行修改或者不修改，求所有情况下有标记点的个数。
考虑依次修改操作会产生的影响，把线段树节点进行分类。

- 这个点和以及其父亲都和修改区间无交：显然这个点的标记不会被修改。
- 这个点和修改区间无交但父亲和修改区间有交：那么这个区间有没有标记只和本身有没有标记以及是否存在一个祖先有标记相关。
- 这个点被修改区间完全包含，且父亲没有被完全包含：显然这个点就是放置标记的一个点，那么一定会有标记。
- 这个点被修改区间完全包含，且父亲节点也被完全包含：那么这个点的标记不会变化。
- 这个点和修改区间有交但没有被完全包含：那么这个点一定会$pushdown$，必定不会有标记。

其中四类点的标记状态都和其他点无关，只有第二类标记和其到根节点的所有节点相关。
那么显然记录两个状态就好了，即这个点被标记的概率以及这个点到根节点至少有一个点被标记的概率，不妨记为$f,g$。
考虑如何转移：

- 第一类点：显然没有变化。
- 第二类点：首先$0.5$的概率不会变化，然后$0.5$的概率变成$g$，那么转移就是$f=0.5f'+0.5*g'$；然后考虑$g$的转移，还是$0.5$的概率不变化，$0.5$的概率变成$g'$，所以转移是$g=0.5g'+0.5g'=g'$。
- 第三类点：$f=0.5f'+0.5$；$g=0.5g'+0.5$。
- 第四类点：$f$不会变化，$g$会变成$0.5g'+0.5$。
- 第五类点：$f=0.5f',g=0.5g'$。

第四类点似乎需要资磁区间乘法和区间加法，不过这个东西还是个线段树模板。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define MAX 100100
#define MOD 998244353
#define inv2 499122177
#define lson (now<<1)
#define rson (now<<1|1)
inline int read()
{
	int x=0;bool t=false;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')t=true,ch=getchar();
	while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
	return t?-x:x;
}
int n,m,pw=1,f[MAX<<3],g[MAX<<3],mul[MAX<<3],pls[MAX<<3],s[MAX<<3];
void Build(int now,int l,int r)
{
	mul[now]=1;if(l==r)return;
	int mid=(l+r)>>1;
	Build(lson,l,mid);Build(rson,mid+1,r);
}
void pushup(int now){s[now]=((s[lson]+s[rson])%MOD+f[now])%MOD;}
void upd(int now){f[now]=1ll*inv2*(f[now]+g[now])%MOD;pushup(now);}
void puttag(int now,int m,int p)
{
	g[now]=(1ll*g[now]*m+p)%MOD;
	mul[now]=1ll*mul[now]*m%MOD;
	pls[now]=(1ll*pls[now]*m+p)%MOD;
}
void pushdown(int now)
{
	if(mul[now]==1&&pls[now]==0)return;
	puttag(lson,mul[now],pls[now]);
	puttag(rson,mul[now],pls[now]);
	mul[now]=1;pls[now]=0;
}
void Modify(int now,int l,int r,int L,int R)
{
	if(L==l&&r==R)
	{
		f[now]=1ll*inv2*(f[now]+1)%MOD;
		puttag(now,inv2,inv2);pushup(now);return;
	}
	int mid=(l+r)>>1;pushdown(now);
	f[now]=1ll*inv2*f[now]%MOD;
	g[now]=1ll*inv2*g[now]%MOD;
	if(R<=mid)Modify(lson,l,mid,L,R),upd(rson);
	else if(L>mid)Modify(rson,mid+1,r,L,R),upd(lson);
	else Modify(lson,l,mid,L,mid),Modify(rson,mid+1,r,mid+1,R);
	pushup(now);
}
int main()
{
	n=read();m=read();
	while(m--)
	{
		int opt=read(),l,r;
		if(opt==1)l=read(),r=read(),Modify(1,1,n,l,r),pw=(pw+pw)%MOD;
		else printf("%lld\n",1ll*pw*s[1]%MOD);
	}
	return 0;
}
```

---

## 作者：djh123 (赞：3)


我们考虑第$i$次修改区间的是$\ \text{[ql, qr],}\ $当前线段树上的区间是$\ \text{[l, r]}\ $, 考虑分以下几种情况:
- $\text{\ [l, r]}\subseteq \text{\ [ql, qr]\ }$那么就会对这些区间的$\ \text{tag}\ $置一, 就会对答案贡献$\ 2^{i-1}$
- $\text{\ [l, r]}~$没有被访问(下传标记算访问), 那么这些区间没有任何影响, 由于线段树数量翻倍, 那么权值要$\times 2$
- $\text{\ [l, r]}~\bigcap\text{\ [ql, qr]}\not= \varnothing \ $, 且不属于第一类, 这些节点一定要下放标记, 所以这一类的权值不变
- $\text{\ [l, r]}~\bigcap\text{\ [ql, qr]}= \varnothing \ \text{\&}\text{\ [l, r]\ }$被下放标记, 这时候我们令$f_p$为从$p$到根节点存在$ \ \text{tag}\ $为$\ 1\ $的节点个数, 那么这时候就要加上$f_p$

直接在线段树上维护即可

考虑全局答案, 对于访问到的节点先减去原来的权值, 再乘二, 再加上这次的权值即可

现在考虑维护$f$

- 对于第一类点, 这些点一定会将$\ \text{tag}\ $置一, 这些点的$f$就要加上$\ 2^{i-1}$
- 对于第三类点, 这些点和他的祖先都会下传标记, 那么$\ f\ $不变
- 对于第二四类点, 这些点$\ f\ $值没有变化, 由于线段树数量翻倍, 所以$\ f \ $值$\times 2$

```cpp
#include <cstdio>
using namespace std;

const int mod = 998244353;
const int N = 1e5 + 50;

typedef long long LL;

struct node { int l, r; LL addftag, mulftag, mulvtag, f, val; } t[N << 2];
LL sum, ans, nowval;

void pushaddf(int now, int val) {
	t[now].addftag = (t[now].addftag + val) % mod;
	t[now].f = (t[now].f + val) % mod;
}

void pushmulf(int now, int val) {
	t[now].f = t[now].f * val % mod;
	t[now].mulftag = t[now].mulftag * val % mod;
	t[now].addftag = t[now].addftag * val % mod;
}

void pushmulv(int now, int val) {
	t[now].val = t[now].val * val % mod;
	t[now].mulvtag = t[now].mulvtag * val % mod;
}

void pushdown(int now) { // 下传标记 
	int ls = now << 1, rs = ls | 1;
	if(t[now].mulftag != 1) pushmulf(ls, t[now].mulftag), pushmulf(rs, t[now].mulftag), t[now].mulftag = 1;
	if(t[now].mulvtag != 1) pushmulv(ls, t[now].mulvtag), pushmulv(rs, t[now].mulvtag), t[now].mulvtag = 1;
	if(t[now].addftag) pushaddf(ls, t[now].addftag), pushaddf(rs, t[now].addftag), t[now].addftag = 0;
}
	

void build(int now, int l, int r) { // 建树 
	t[now].l = l, t[now].r = r;
	t[now].addftag = 0, t[now].mulftag = 1, t[now].mulvtag = 1;
	t[now].f = t[now].val = 0;
	if(l == r) return ;
	int mid = (l + r) >> 1;
	build(now << 1, l, mid);
	build(now << 1 | 1, mid + 1, r);
}

void change(int now, int l, int r) {
	if(t[now].l >= l && t[now].r <= r) { // 第一类点 
		ans = (ans - t[now].val + mod) % mod; // 减去原来的权值 
		t[now].val = (t[now].val + nowval) % mod; // 新复制的线段树这段区间的权值是 2^{i-1} 
		t[now].mulvtag = t[now].mulvtag * 2 % mod;// 没有访问的节点权值 * 2 
		pushaddf(now, nowval); // f += 2^{i-1} 
		sum = (sum + t[now].val) % mod; // 累加 sum 
		return ;
	}
	if(t[now].l > r || t[now].r < l) { // 第四类点 
		ans = (ans - t[now].val + mod) % mod;
		t[now].val = (t[now].val + t[now].f) % mod; // 新复制的线段树这段区间的权值是 val[now] + f[now] 
		t[now].mulvtag = t[now].mulvtag * 2 % mod;// 没有访问的节点权值 * 2 
		pushmulf(now, 2); // f = f * 2
		sum = (sum + t[now].val) % mod;
		return ;
	} // 第三类点 
	int ls = now << 1, rs = ls | 1;
	pushdown(now);
	ans = (ans - t[now].val + mod) % mod;
	sum = (sum + t[now].val) % mod;// 贡献不变
	change(ls, l, r), change(rs, l, r);// 修改子区间 
}

int main() {
	int n, m, opt, l, r; scanf("%d%d", &n, &m);
	build(1, 1, n); nowval = 1;
	for(int i = 1; i <= m; ++ i) {
		scanf("%d", &opt);
		if(opt == 1) {
			scanf("%d%d", &l, &r);
			sum = 0;
			change(1, l, r);
			ans = (ans + ans + sum) % mod;
			nowval = (nowval + nowval) % mod;
		}
		else printf("%lld\n", ans);
	}
}

```

---

## 作者：Owen_codeisking (赞：3)

我考场上就打了 $20pts$ 暴力，后来听人口胡会了 $O(n\log n)$ 的做法。昨晚调了一个晚上没调出来，结果后来改变一下 $dp$ 的思路就 $A$ 了。。。

不得不说，这是一道很好的题目。$orz\ \text{jls}$

### 前置知识：线段树

其实不会线段树应该也不会去 $ZJOI$。。。

### 1、挖掘线段树修改操作的重要性质

设询问的区间为 $[ql,qr]$

① 若 $[l,r]\cap [ql,qr]=[l,r]$ 且它的祖先**不满足**上述性质 ，那么这个区间在这轮操作中**一定会被覆盖到**，我们定义 $[l,r]$ 为**可打标记全覆盖区间**。

② 若 $[l,r]\cap [ql,qr]=[l,r]$ 且它的祖先**满足**上述性质，那么这个区间在这轮操作中**一定不会被覆盖到**，我们定义 $[l,r]$ 为**不可打标记全覆盖区间**。

③ 若 $[l,r]\cap [ql,qr]\neq \emptyset$ 且**不满足**性质①②，那么这个区间的 $lazytag$ **一定会被下传**，我们定义 $[l,r]$ 为**半覆盖区间**。

④ 若 $[l,r]\cap [ql,qr]=\emptyset$ ，那么这个区间在这轮操作中**只能接受祖先的 $lazytag$**，我们定义 $[l,r]$ 为**未覆盖区间**。

概率具有**可乘性**，我们将其转化为概率，然后乘以 $2^{now}$，$now$ 为当前修改操作的次数。

### 2、考虑维护什么哪些值

首先，我们要维护每个区间 $lazytag$ 为 $1$ 的概率 $f$

其实对于满足性质①②③的区间都是好 $dp$ 的，就是满足性质④的区间有些麻烦。

我们发现对于满足性质④的区间只要当前区间到根**至少有一个**区间 $lazytag$ 为 $1$ 并且在操作的时候**祖先被遍历到**即可。

考虑再维护每个区间到根上**至少有一个**区间 $lazytag$ 为 $1$ 的概率 $g$

一次 $add$：

```cpp
inline void add(int rt,int x)
{
	ans=(ans-f[rt])%mod;
	f[rt]=1ll*(f[rt]+x)*inv2%mod;
	g[rt]=1ll*(g[rt]+x)*inv2%mod;
	ans=(ans+f[rt])%mod;
}
```

对于可打标记全覆盖区间/半覆盖区间，直接 $add(1/0)$ 就可以了。

对于未覆盖区间，我们考虑在每次操作的可打标记覆盖区间打一个标记。若当前区间到根有 $x$ 个可打标记覆盖区间，那么只有 $x$ 次操作**都不执行**才可能使当前区间 $lazytag$ 为 $0$

一次 $pushdown$：

```cpp
inline void pushdown(int rt)
{
	if(tag[rt])
	{
		g[lson]=(1ll-1ll*(1ll-g[lson])*pw[tag[rt]]%mod)%mod;
		g[rson]=(1ll-1ll*(1ll-g[rson])*pw[tag[rt]]%mod)%mod;
		tag[lson]+=tag[rt];tag[rson]+=tag[rt];tag[rt]=0;
	}
}
```

这个思路可能是目前我理解的最简单的思路了。

时间复杂度 $O(n\log n)$


```cpp
#include <bits/stdc++.h>
#define lson (rt<<1)
#define rson (rt<<1|1)
using namespace std;
const int maxn=100000+10;
const int mod=998244353;
const int inv2=(mod+1)>>1;
int n,m,now,ans,pw[maxn],f[maxn<<2],g[maxn<<2],tag[maxn<<2];

inline int read()
{
	register int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return (f==1)?x:-x;
}

inline void add(int rt,int x)
{
	ans=(ans-f[rt])%mod;
	f[rt]=1ll*(f[rt]+x)*inv2%mod;
	g[rt]=1ll*(g[rt]+x)*inv2%mod;
	ans=(ans+f[rt])%mod;
}

inline void pushdown(int rt)
{
	if(tag[rt])
	{
		g[lson]=(1ll-1ll*(1ll-g[lson])*pw[tag[rt]]%mod)%mod;
		g[rson]=(1ll-1ll*(1ll-g[rson])*pw[tag[rt]]%mod)%mod;
		tag[lson]+=tag[rt];tag[rson]+=tag[rt];tag[rt]=0;
	}
}

void update(int L,int R,int l,int r,int rt)
{
	if(r < L || R < l){add(rt,g[rt]);return;}
	if(L <= l && r <= R){add(rt,1);tag[rt]++;return;}
	pushdown(rt);add(rt,0);
	int mid=(l+r)>>1;
	update(L,R,l,mid,lson);update(L,R,mid+1,r,rson);
}

int main()
{
	n=read(),m=read();
	now=pw[0]=1;
	for(int i=1;i<=m;i++) pw[i]=1ll*pw[i-1]*inv2%mod;
	int op,l,r;
	while(m--)
	{
		op=read();
		if(op==1) l=read(),r=read(),update(l,r,1,n,1),now=2ll*now%mod;
		else printf("%d\n",1ll*(ans+mod)*now%mod);
	}
	return 0;
}
```

---

## 作者：TheLostWeak (赞：2)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu5280.html)

**大致题意：** 给你一棵线段树，两种操作。一种操作将每棵线段树复制成两个，然后在这两个线段树中的一个上面进行$Modify(l,r)$。另一种操作询问所有线段树的$tag$总和。

### 大力分类讨论

我们考虑用线段树来进行维护。

定义一个$f_{rt}$，表示在**当前所有线段树中编号为$rt$的节点上的$tag$之和**。

然后对于每次修改，就需要大力分类讨论，来计算**新增加的$2^{t-1}$棵树对$f_x$的贡献**。

- 当这个节点未被访问到

  显然，就相当于此次操作对该节点没有任何影响，也就是新产生的$2^{t-1}$棵树中$tag$不会发生任何变化，因此直接将$f_{rt}*=2$即可。

- 当这个节点是被修改的节点

  如果这个节点是被修改的节点，则显然新产生的$2^{t-1}$棵树中这个点会被赋值为$1$，因此将$f_{rt}+=2^{t-1}$即可。

- 当这个节点被访问到且进行过$PushDown$操作

  由于进行过了$PushDown$，则显然新产生的$2^{t-1}$棵树中这个点会被赋值为$0$，因此$f_{rt}$不会发生任何变化。

- 当这个节点被访问到但未进行任何操作

  如果这个节点被访问到但未进行任何操作，那么这个点的$tag$值就取决于**这个节点到根节点的路径上（包括这个节点）是否存在至少一个节点$tag$值为$1$**，因为这样就能经过若干次$PushDown$影响到这一位上了。

  而这也是最复杂的一种情况，下面会单独对这种情况进行进一步的讨论。

### 处理被访问到但未进行任何操作的节点

考虑再记录一个$g_{rt}$，表示**当前所有线段树中编号为$rt$的节点到根节点的路径上（包括该节点）存在至少一个节点$tag$值为$1$的方案数**。

则这样一来在这种情况下我们就可以直接将$f_{rt}+=g_{rt}$了。

但就有了一个新的问题，如何维护$g_{rt}$？

于是又要进行一波与先前类似的分类讨论。

- 当这个节点未被访问到

  同样，就相当于此次操作对该节点没有任何影响，因此直接将$g_{rt}*=2$即可。


- 当这个节点是被修改的节点

  如果这个节点是被修改的节点，则显然新产生的$2^{t-1}$棵树中这个点会被赋值为$1$，因此新产生的$2^{t-1}$棵树中这个点到根节点的路径上必然存在$tag$值为$1$的点（即这个点本身），因此将$g_{rt}+=2^{t-1}$即可。

- 当这个节点被访问到且进行过$PushDown$操作

  由于进行过了$PushDown$，则显然这个点到根的路径上的所有节点全都$PushDown$过，因此新产生的$2^{t-1}$棵树中这个点到根节点的路径上不存在$tag$值为$1$的点，因此$g_{rt}$不会发生任何变化。

- 当这个节点被访问到但未进行任何操作

  将$g_{rt}*=2$即可。

### 整理+优化

接下来，我们来整理一下上面的内容：

| 情况                        | $f_{rt}$          | $g_{rt}$          |
| :-------------------------: | :-----------------: | :-----------------: |
| 当这个节点未被访问到                | $f_{rt}*=2$       | $g_{rt}*=2$       |
| 当这个节点是被修改的节点              | $f_{rt}+=2^{t-1}$ | $g_{rt}+=2^{t-1}$ |
| 当这个节点被访问到且进行过$PushDown$操作 | 无变化               | 无变化               |
| 当这个节点被访问到但未进行任何操作         | $f_{rt}+=g_{rt}$  | $g_{rt}*=2$       |

考虑到对于未访问到的节点，我们一律都是将答案乘$2$的。

那么，我们能不能换一种思维，即每次不修改未被访问到的节点，而是把其余三种情况时的$f_{rt}$和$g_{rt}$除以$2$，然后在输出答案时把答案乘上$2^t$。

则就得到了这样一个新表格：

| 情况                        | $f_{rt}$                       | $g_{rt}$                  |
| :-------------------------: | :------------------------------: | :-------------------------: |
| 当这个节点未被访问到                | 无变化                            | 无变化                       |
| 当这个节点是被修改的节点              | $f_{rt}=\frac{f_{rt}+1}2$      | $g_{rt}=\frac{g_{rt}+1}2$ |
| 当这个节点被访问到且进行过$PushDown$操作 | 无变化                            | 无变化                       |
| 当这个节点被访问到但未进行任何操作         | $f_{rt}=\frac{f_{rt}+g_{rt}}2$ | 无变化                       |

这样就方便许多。

### 维护$g$的修改

但是，我们还是要注意，要在$PushDown$的同时维护$g$的修改。

我们用$tag_{rt}$来记录**当前节点的$g$在上一次$PushDown$后被修改过多少次**。

则我们需要将$rt<<1$和$rt<<1|1$的$g$分别进行$tag_{rt}$次$g=\frac{g+1}2$。

设要进行$tag_{rt}$次$g=\frac{g+1}2$的点为$k$，易得最终结果为：

$$\frac {g_k+2^{tag_{rt}-1}+2^{tag_{rt}-2}+...+2^{tag_{rt}}}{2^{tag_{rt}}}$$

式子的后半部分显然可以用等底数列求和公式化简，得到：

$$\frac {g_k+{2^{tag_{rt}}-1}}{2^{tag_{rt}}}=\frac {g_k}{2^{tag_{rt}}}+1-\frac 1{2^{tag_{rt}}}$$

分母可以预处理$2$的幂的逆元，然后就差不多了。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 100000
#define X 998244353
#define Inc(x,y) ((x+=(y))>=X&&(x-=X))
#define Dec(x,y) ((x-=(y))<0&&(x+=X))
#define Shl(x) ((x<<=1)>=X&&(x-=X))
using namespace std;
int n;
class FastIO
{
    private:
        #define FS 100000
        #define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
        #define pc(c) (C^FS?FO[C++]=c:(fwrite(FO,1,C,stdout),FO[(C=0)++]=c))
        #define tn (x<<3)+(x<<1)
        #define D isdigit(c=tc())
        int T,C;char c,*A,*B,FI[FS],FO[FS],S[FS];
    public:
        I FastIO() {A=B=FI;}
        Tp I void read(Ty& x) {x=0;W(!D);W(x=tn+(c&15),D);}
        Tp I void write(Ty x) {W(S[++T]=x%10+48,x/=10);W(T) pc(S[T--]);}
        Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
        Tp I void writeln(Con Ty& x) {write(x),pc('\n');}
        I void clear() {fwrite(FO,1,C,stdout),C=0;}
}F;
class SegmentTree//线段树
{
    private:
        #define PD(x) O[x].t&&\//下传标记
        (\
            O[x<<1].g=((1LL*O[x<<1].g*I2[O[x].t]%X+1-I2[O[x].t])%X+X)%X,\//更新左儿子g值
            O[x<<1|1].g=((1LL*O[x<<1|1].g*I2[O[x].t]%X+1-I2[O[x].t])%X+X)%X,\//更新右儿子g值
            O[x<<1].t+=O[x].t,O[x<<1|1].t+=O[x].t,O[x].t=0\//下传修改次数
        )
        int ans,pw,I2[N+5];struct node {int f,g,t;}O[N<<2];
        I void upt(CI l,CI r,CI rt,CI tl,CI tr)//修改
        {
            Dec(ans,O[rt].f),O[rt].f=1LL*O[rt].f*I2[1]%X,O[rt].g=1LL*O[rt].g*I2[1]%X;//先删除原来贡献，并将当前f,g除以2
            if(tl<=l&&r<=tr) Inc(O[rt].f,I2[1]),Inc(O[rt].g,I2[1]);//分类讨论
            else if(tr<l||r<tl)	Inc(O[rt].f,O[rt].g),Shl(O[rt].g);
            if(Inc(ans,O[rt].f),tr<l||r<tl) return;if(tl<=l&&r<=tr) return (void)(++O[rt].t);//加回新答案，然后模拟线段树过程
            PD(rt);RI mid=l+r>>1;upt(l,mid,rt<<1,tl,tr),upt(mid+1,r,rt<<1|1,tl,tr);
        }
    public:
        I SegmentTree() {pw=I2[0]=1,I2[1]=X+1>>1;}
        I void Init(CI x) {for(RI i=2;i<=x;++i) I2[i]=1LL*I2[i-1]*I2[1]%X;}//预处理2的幂的逆元
        I void Update(CI x,CI y) {upt(1,n,1,x,y),Shl(pw);}
        I int GetAns() {return 1LL*ans*pw%X;}//最后答案乘上2^t
}S;
int main()
{
    RI Qtot,op,x,y;F.read(n,Qtot),S.Init(Qtot);
    W(Qtot--) F.read(op),op^2?(F.read(x,y),S.Update(x,y)):F.writeln(S.GetAns());
    return F.clear(),0;
}
```

---

## 作者：bztMinamoto (赞：2)

## 题面

[传送门](https://www.luogu.org/problemnew/show/P5280)

## 题解

考场上就这么一道会做的其它连暴力都没打……活该爆炸……

首先我们得看出问题的本质：有$m$个操作，总共$2^m$种情况分别对应每个操作是否执行，求这$2^m$棵线段树上$tag$为$1$的节点个数

那么很明显得转化为每个节点在多少种情况里$tag$为$1$

对于一个操作$[ql,qr]$，我们把线段树上所有节点分成四类考虑

1.如果$ql\leq l\&\&qr\geq r$，且该节点被访问到，那么不管之前操作序列怎么样，只要执行了当前操作它必为$1$，所以它的值加上$2^t$，其中$t$为已经执行的操作数目

2.如果节点没有被访问到过，那么这个操作是否执行都对它们的$tag$没有影响，所以它们的值乘$2$

3.如果$[ql,qr]\cap[l,r]\neq \emptyset$且不属于$1$，那么如果当前操作执行它们的$tag$显然全没了，所以它们的值不变

4.还有一种情况$[ql,qr]\cap [l,r]=\emptyset$，且当前节点的父亲属于$3$，但是当前节点不属于$1$。这种情况下当前节点的值要加上$f_i$，其中$f_i$表示的是“能够使当前节点到根的所有节点中存在$tag$为$1$的点的序列个数”

先不考虑$f_i$怎么维护。那么我们只要在线段树上遍历区间，对应地打上给节点加上值（比如$1$），给节点打乘法标记就行了。全局的答案可以先减去所有遍历到的节点的答案，乘上$2$之后再把遍历到的节点的答案加上去就好了

然后关键是$f_i$还得维护啊……还是得分类讨论……

1.如果$ql\leq l\&\&qr\geq r$，不管当前节点是否被访问过。因为当前操作执行之后它们到根节点的路径上显然会有$tag$为$1$，所以这些节点每一个都要加上$2^{t-1}$

2.如果是之前的$3$情况，那么显然根节点到它的所有$tag$都没了，所以$f_i$不变

3.除此之外的所有情况，包括之前的$4$，显然当前操作不管是否执行都对它们的$f_i$没有影响，所以它们的$f_i$都要乘$2$

然后没有然后了

```cpp
//minamoto
#include<bits/stdc++.h>
#define R register
#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)
#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
inline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
int read(){
    R int res,f=1;R char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');
    return res*f;
}
char sr[1<<21],z[20];int C=-1,Z=0;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
void print(R int x){
    if(C>1<<20)Ot();if(x<0)sr[++C]='-',x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=1e5+5,P=998244353;
inline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}
inline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}
inline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}
int ksm(R int x,R int y){
	R int res=1;
	for(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;
	return res;
}
struct node{
	node *lc,*rc;int sv,tv,sf,taf,tmf;
	node(){tv=tmf=1;}
	inline void pmf(R int x){sf=mul(sf,x),taf=mul(taf,x),tmf=mul(tmf,x);}
	inline void paf(R int x){sf=add(sf,x),taf=add(taf,x);}
	inline void pv(R int x){tv=mul(tv,x),sv=mul(sv,x);}
	inline void pd(){
		if(tv)lc->pv(tv),rc->pv(tv),tv=1;
		if(tmf)lc->pmf(tmf),rc->pmf(tmf),tmf=1;
		if(taf)lc->paf(taf),rc->paf(taf),taf=0;
	}
}pool[N<<2],*rt;int num;
inline node *newnode(){return &pool[num++];}
void build(node* &p,int l,int r){
	p=newnode();if(l==r)return;
	int mid=(l+r)>>1;
	build(p->lc,l,mid),build(p->rc,mid+1,r);
}
int res,ans,ql,qr,t,op;
void update(node *p,int l,int r){
	if(ql<=l&&qr>=r){
		ans=dec(ans,p->sv);
		p->sv=add(p->sv,t),p->tv=mul(p->tv,2),p->paf(t);
		res=add(res,p->sv);
		return;
	}
	if(ql>r||qr<l){
		ans=dec(ans,p->sv);
		p->sv=add(p->sv,p->sf),p->pmf(2),p->tv=mul(p->tv,2);
		res=add(res,p->sv);
		return;
	}
	int mid=(l+r)>>1;p->pd();
	ans=dec(ans,p->sv),res=add(res,p->sv);
	update(p->lc,l,mid),update(p->rc,mid+1,r);
}
int n,m;
int main(){
//	freopen("testdata.in","r",stdin);
	n=read(),m=read(),t=1;
	build(rt,1,n);
	while(m--){
		op=read();
		if(op&2)print(ans);
		else ql=read(),qr=read(),res=0,update(rt,1,n),ans=add(mul(ans,2),res),t=mul(t,2);
	}
	return Ot(),0;
}
```

---

## 作者：dsidsi (赞：1)

### Description

[这是链接](https://loj.ac/problem/3043)

### Solution

这题可以看做每次有$\frac {1} {2}$执行`1`操作，问$tag$数组之和的期望乘$2^p$（$p$是`1`操作的次数）。

根据期望的线性性，单独计算出每一个节点的$tag$为$1$的期望$f_i$，顺便计$g_i$表示$i$到根的路径有$tag=1$的概率。将$[l,r]$拆分成$log$个在线段树上的区间，考虑每一个区间对答案的影响，可以发现对于这个区间到根的路径上的点（不包括它本身）的$f_i \gets \frac{f_i}{2},g_i \gets \frac{g_i}{2}$，临近这条路径的点的$f_i \gets \frac{f_i+g_i}{2},g_i$不变，而这个区间本身$f_i \gets \frac {f_i+1}{2}$，其子树的$g_i \gets \frac{g_i+1}{2}$。

这里的修改都是$O(log)$级别，暴力修改即可。对于$g_i$的维护，可以维护$g_i'=1-g_i$，修改时$g_i'\gets=\frac{g_i'}{2}$

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int gi()
{
	char c = getchar();
	while(c < '0' || c > '9') c = getchar();
	int sum = 0;
	while('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();
	return sum;
}

typedef long long ll;
const int maxn = 100005, mod = 998244353;

int n, m, P = 1, inv[maxn], f[maxn << 2], g[maxn << 2], lzy[maxn << 2], ans;

#define mid ((l + r) >> 1)
#define lch (s << 1)
#define rch (s << 1 | 1)

void build(int s, int l, int r)
{
	g[s] = 1;
	if (l == r) return ;
	build(lch, l, mid);
	build(rch, mid + 1, r);
}

inline void mdf_f(int x, int v) {ans = (ans - f[x] + mod) % mod; f[x] = (ll)(f[x] + v) * inv[1] % mod; ans = (ans + f[x]) % mod;}
inline void mdf_g(int x, int v) {g[x] = (ll)g[x] * inv[v] % mod; lzy[x] += v;}
inline void push_down(int s)
{
	if (!lzy[s]) return ;
	mdf_g(lch, lzy[s]); mdf_g(rch, lzy[s]);
	lzy[s] = 0;
}

void modify(int s, int l, int r, int ql, int qr)
{
	if (ql <= l && r <= qr) return mdf_f(s, 1), mdf_g(s, 1), void();
	push_down(s);
	if (ql <= mid) modify(lch, l, mid, ql, qr);
	else mdf_f(lch, mod + 1 - g[lch]);
	if (mid < qr) modify(rch, mid + 1, r, ql, qr);
	else mdf_f(rch, mod + 1 - g[rch]);
	mdf_f(s, 0); g[s] = (ll)(g[s] + 1) * inv[1] % mod;
}

int main()
{
	n = gi(); m = gi();
	inv[0] = 1; inv[1] = (mod + 1) >> 1;
	for (int i = 2; i <= n; ++i) inv[i] = (ll)inv[i - 1] * inv[1] % mod;
	
	build(1, 1, n);
	for (int op, l, r, i = 1; i <= m; ++i) {
		op = gi(); 
		if (op == 1) l = gi(), r = gi(), P = (P << 1) % mod, modify(1, 1, n, l, r);
		else printf("%lld\n", (ll)ans * P % mod);
	}
	
	return 0;
}
```

---

## 作者：p_b_p_b (赞：1)

[$$\large\color{purple} My\;Blog$$](https://www.cnblogs.com/p-b-p-b/p/10646021.html)

------------------------

无限Orz $\color{black}S\color{red}{ooke}$……

虽然已经有Sooke这么优质的题解了，但题解那么少，还是要不要脸地来水一发QwQ

--------------------------

## 思路

显然我们不能按照题意来每次复制一遍，而多半是在一棵线段树上瞎搞。

然后我们可以从$modify$函数入手，寻找一些性质。

（盗一张Sooke的图）

![](https://i.loli.net/2019/04/02/5ca2b0fce8b8c.png)

可以发现每次$modify$之中，所有节点都可以被分成5类：

1. 白色：经过而且标记全都被下传的点。
2. 黑色：打上标记的点。
3. 灰色：在修改区域内但不会被经过的点。
4. 橙色：可以享受到来自上方标记的滋润的点。
5. 黄色：半毛钱关系都没有的点……

分类之后，可以发现：如果DP的话，所有同一类型的点的转移方程都是基本相同的。

于是考虑DP：很自然地，想到设$f_i$表示在所有情况中$tag_i=1$的情况个数。

那么有转移方程：
$$
f_i=\begin{cases}
f_i&,white\\
f_i+2^t&,black\\
2f_i&,grey\\
2f_i&,yellow\\
?????&,orange
\end{cases}
$$
你发现橙色点还要根据上方点是否有标记来转移，烦死了。

于是再一次很自然地，想到设$g_i$表示在所有情况中$i\rightarrow root$路径上存在$tag_x=1$的情况个数。（Sooke的定义更容易线段树上转移，但我觉得我这种比较自然…）

那么有转移方程：
$$
g_i=\begin{cases}
g_i&,white\\
g_i+2^t&,black\\
g_i+2^t&,grey\\
2g_i&,yellow\\
2g_i&,orange
\end{cases}
$$
然后终于可以得到：
$$
f_i=f_i+g_i,orange
$$
大功告成！

显然白色、黑色、橙色暴力转移，灰色、黄色随便维护下懒标记即可。

最后答案是$\sum_i f_i$，也是在线段树上很好统计的。


-----------------------------------------

## 代码

```cpp
#include<bits/stdc++.h>
clock_t t=clock();
namespace my_std{
    using namespace std;
    #define pii pair<int,int>
    #define fir first
    #define sec second
    #define MP make_pair
    #define rep(i,x,y) for (int i=(x);i<=(y);i++)
    #define drep(i,x,y) for (int i=(x);i>=(y);i--)
    #define go(x) for (int i=head[x];i;i=edge[i].nxt)
    #define templ template<typename T>
    #define sz 202020
    #define mod 998244353ll
    typedef long long ll;
    typedef double db;
    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
    templ inline T rnd(T l,T r) {return uniform_int_distribution<T>(l,r)(rng);}
    templ inline bool chkmax(T &x,T y){return x<y?x=y,1:0;}
    templ inline bool chkmin(T &x,T y){return x>y?x=y,1:0;}
    templ inline void read(T& t)
    {
        t=0;char f=0,ch=getchar();double d=0.1;
        while(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();
        while(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();
        if(ch=='.'){ch=getchar();while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();}
        t=(f?-t:t);
    }
    template<typename T,typename... Args>inline void read(T& t,Args&... args){read(t); read(args...);}
    char __sr[1<<21],__z[20];int __C=-1,__zz=0;
    inline void Ot(){fwrite(__sr,1,__C+1,stdout),__C=-1;}
    inline void print(register int x)
    {
        if(__C>1<<20)Ot();if(x<0)__sr[++__C]='-',x=-x;
        while(__z[++__zz]=x%10+48,x/=10);
        while(__sr[++__C]=__z[__zz],--__zz);__sr[++__C]='\n';
    }
    void file()
    {
        #ifndef ONLINE_JUDGE
        freopen("a.in","r",stdin);
        #endif
    }
    inline void chktime()
    {
        #ifndef ONLINE_JUDGE
        cout<<(clock()-t)/1000.0<<'\n';
        #endif
    }
    #ifdef mod
    ll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x%mod) if (y&1) ret=ret*x%mod;return ret;}
    ll inv(ll x){return ksm(x,mod-2);}
    #else
    ll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x) if (y&1) ret=ret*x;return ret;}
    #endif
//	inline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}
}
using namespace my_std;

int n,m;
ll pow2;

ll f[sz<<2],g[sz<<2],fMul[sz<<2],gAdd[sz<<2],gMul[sz<<2];
ll S[sz<<2];
#define ls k<<1
#define rs k<<1|1
#define lson ls,l,mid
#define rson rs,mid+1,r
void mulf(int k,ll w){(f[k]*=w)%=mod;(fMul[k]*=w)%=mod;(S[k]*=w)%=mod;}
void mulg(int k,ll w){(g[k]*=w)%=mod;(gMul[k]*=w)%=mod;(gAdd[k]*=w)%=mod;}
void addg(int k,ll w){(g[k]+=w)%=mod;(gAdd[k]+=w)%=mod;}
void pushdown(int k)
{
    mulg(ls,gMul[k]);mulg(rs,gMul[k]);gMul[k]=1;
    addg(ls,gAdd[k]);addg(rs,gAdd[k]);gAdd[k]=0;
    mulf(ls,fMul[k]);mulf(rs,fMul[k]);fMul[k]=1;
}
void pushup(int k){S[k]=(S[ls]+S[rs]+f[k])%mod;}
void modify1(int k,int l,int r,int x,int y) // white,black,grey
{
    pushdown(k);
    int mid=(l+r)>>1;
    if (x<=l&&r<=y) // black
    {
        (f[k]+=pow2)%=mod;
        (g[k]+=pow2)%=mod;
        addg(ls,pow2);addg(rs,pow2); // grey
        mulf(ls,2);mulf(rs,2); // grey
        pushup(k);
        return;
    }
    // white (do nothing)
    if (x<=mid) modify1(lson,x,y);
    if (y>mid) modify1(rson,x,y);
    pushup(k);
}
void modify2(int k,int l,int r,int x,int y) // orange,yellow
{
    pushdown(k);
    if (x<=l&&r<=y) // orange
    {
        (f[k]+=g[k])%=mod;(g[k]+=g[k])%=mod;
        mulg(ls,2);mulg(rs,2); // yellow
        mulf(ls,2);mulf(rs,2); // yellow
        pushup(k);
        return;
    }
    int mid=(l+r)>>1;
    if (x<=mid) modify2(lson,x,y);
    if (y>mid) modify2(rson,x,y);
    pushup(k);
}
void build(int k,int l,int r)
{
    f[k]=g[k]=0;
    fMul[k]=gMul[k]=1;gAdd[k]=0;
    if (l==r) return;
    int mid=(l+r)>>1;
    build(lson);build(rson);
}

int main()
{
    file();
    read(n,m);
    build(1,1,n);
    int z,x,y;
    pow2=1;
    while (m--)
    {
        read(z);
        if (z==2) printf("%lld\n",S[1]);
        else 
        {
            read(x,y);
            modify1(1,1,n,x,y);
            if (x!=1) modify2(1,1,n,1,x-1);
            if (y!=n) modify2(1,1,n,y+1,n);
            (pow2*=2)%=mod;
        }
    }
    return 0;
}
```





---

## 作者：MoonPie (赞：1)

# [ZJOI2019]线段树

## 题面

难以表述，[$\mathfrak{LINK}$​](https://www.luogu.com.cn/problem/P5280)

## 题解

按照 Sooke 大佬的思路，我们将线段树上的点分成了 $5$​ 类。

![freSv6.png](https://z3.ax1x.com/2021/08/13/freSv6.png)

$\text{\tiny{盗用一张Sooke大佬的图，侵删}}$​

设 $f_{i,u}$ 表示第 $i$ 次操作时，在 $2^i$ 棵线段树中 $u$ 节点有 $tag$ 的线段树的个数。

但是，考虑一个问题：橙色的如何转移？对于橙色 $[l,r]$​​。**如果祖先有标记**，会得到标记，但不会被访问。但是我们发现，信息不够用了（无法知道有多少个点的祖先有 $tag$​​）。
所以我们需要记录一个 ~~~ $g_{i,u}$​​ 表示第 $i$​​ 次操作时，在 $2^i$​​ 棵线段树中 $u$​​ 节点的**祖先**有 $tag$​​​​​ 并且 $u$​ 没有 $tag$​​​ 线段树的数量。~~其实没必要考虑 “自己没有 $tag$​​ 这一限制”，因为每次操作是**偶数不变，奇数有一份新的**。所以，只需要知道有多少棵线段树是在操作过后有标记的即可。

所以设 $g_{i,u}$ 表示 $i$ 次操作时，在 $2^i$ 棵线段树中 $u \rightarrow 1$ 中有 $tag$ 的线段树个数。​​

---

现在考虑这 $5$​​ 类点的转移。

- 白色点 $[l,r]$​​​​​​​。会被遍历到的节点。奇数号的被修改了，标记下传，变成了 $0$​​；$1 \rightarrow u$​ 的所有点都 $\mathrm{Pushdown}$​ 过。

$$
\left\{\begin{matrix}
f_{i,u} = 0 + f_{i-1,u}
\\
g_{i,u} = 0 + g_{i-1,u}
\end{matrix}\right.
$$

- 深灰色 $[l,r]$​​​​​。结尾节点。奇数点全部会打上新的 $tag$​​。
  $$
  \left\{
  \begin{matrix}
  f_{i,u} = 2^{i-1} + f_{i-1,u}
  \\
  g_{i,u} = 2^{i-1} + g_{i-1,u}
  \end{matrix}
  \right.
  $$

- 浅灰色点 $[l,r]$​。新的奇数线段树的点，其祖先都有了 $tag$​。并且没有下传。
  $$
  \left\{
  \begin{matrix}
  f_{i,u} = f_{i-1,u} + f_{i-1,u}
  \\
  g_{i,u} = 2^{i-1} + g_{i-1,u}
  \end{matrix}
  \right.
  $$

- 深黄色点 $[l,r]$。那些不会被访问，但所有的祖先都会被 $\mathrm{Pushdown}$​ 的点。若**祖先和自己**存在 $tag$，在新的奇数号线段树中就是有 $tag$​​​ 的，偶数号不变。
  $$
  \left\{
  \begin{matrix}
  f_{i,u} = g_{i-1,u} + f_{i-1,u}
  \\
  g_{i,u} = g_{i-1,u} + g_{i-1,u}
  \end{matrix}
  \right.
  $$

- 浅黄色点 $[l,r]$。和修改毫无关系，只是单纯地复制了一份。
  $$
  \left\{
  \begin{matrix}
  f_{i,u} = f_{i-1,u} + f_{i-1,u}
  \\
  g_{i,u} = g_{i-1,u} + g_{i-1,u}
  \end{matrix}
  \right.
  $$

最后两种点不可能挨个遍历，需要用**懒标记**来处理。

统计当前树上所有点的 $f_{i,u}$​ 之和就是答案。

## 总（che）结（dan）

- 不应该有一种题“乍一看毫无思路”。

  像这道题，我们首先要想到：线段树的个数是指数级别的，不可能单独地去维护每一棵线段树。
  然后应想到：每棵线段树既然是相同的，就应该可以去用一棵线段树来维护，**每次修改在上一次的基础上进行转移**。
  进一步地，如何维护如此庞大数量的线段树？按点分开来维护。

  以上应该算是在考验选手的**基本素养**。

  接下来又到了一个思维瓶颈。应该意识到：一次修改中，不同的点的转移是不同的。这时就需要对每次修改进行观察，对点的不同性质分类。这是比较考验选手**思维力**的一步。

  写转移方程时，会发现信息不够，所以我们要多记一个信息。考验选手的**基本DP能力~~和心态~~**。

作为一道省选题，这道题考察方面十分全面，并且以选手熟悉的**线段树**（~~九条可怜~~）为出题背景。做出这道题的选手不仅需要扎实的编程水平、敏锐的洞察力，更需要稳定的心态。是一道不可多得的好题，真不愧是我大 ZJ 的省选！

作为一道训练题，这道题锻炼了选手的思维敏锐度、观察能力，加深了对线段树——这一众所周知的数据结构的认识。也是一道难得的好题！

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
template<class T> void read(T &x)
{
	x = 0; int f = 0;
	char c = getchar();
	while (c < '0' || c > '9') f |= (c == '-'), c = getchar();
	while (c >='0' && c <='9') x = (x << 1) + (x << 3) + (c^48), c = getchar();
	if (f) x = -x;
}
typedef long long ll;
const int N = 1e5+5 , mod = 998244353;
template<class T> bool umax(T &x , T y) {return y>x ? x=y, 1: 0; }
template<class T> bool umin(T &x , T y) {return y<x ? x=y, 1: 0; }

int n,m;
ll pi[N], f[N<<2],g[N<<2],sum[N<<2];
ll tag_f[N<<2], tag_gm[N<<2],tag_ga[N<<2];

#define ls (p<<1)
#define rs (p<<1|1)
#define mid ((l+r)>>1)

void MUL(ll &x, ll y) { x = x * y % mod;}
template<class T> void Plus(T &x , T y) {x = (x+y) % mod; }

void Pushdown(int p)
{
	ll x = tag_f[p];

	MUL(sum[ls] , x); MUL(f[ls] , x); MUL(tag_f[ls] , x);
	g[ls] = (g[ls] * tag_gm[p] + tag_ga[p]) % mod;
	MUL(tag_ga[ls] , tag_gm[p]);
	Plus(tag_ga[ls] , tag_ga[p]);
	MUL(tag_gm[ls] , tag_gm[p]);
	
	MUL(sum[rs] , x); MUL(f[rs] , x); MUL(tag_f[rs] , x);
	g[rs] = (g[rs] * tag_gm[p] + tag_ga[p]) % mod;
	MUL(tag_ga[rs] , tag_gm[p]);
	Plus(tag_ga[rs] , tag_ga[p]);
	MUL(tag_gm[rs] , tag_gm[p]);

	tag_f[p] = 1;
	tag_gm[p] = 1;
	tag_ga[p] = 0;
}

bool Modify(int p,int l,int r,int s,int e,int i)
{
	if (l > r) return 1;
	if (r < s || l > e) return 0;
	if (s <= l && r <= e)	
	{
		// p 是深灰色的点。sum[p] 是 p 下面浅灰色的点的 f 的和。
		f[p] = (f[p] + pi[i-1]) % mod;
		g[p] = (g[p] + pi[i-1]) % mod;

		sum[p] = sum[p] * 2 % mod;
 		tag_f[p] = tag_f[p] * 2 % mod;
		tag_ga[p] = (tag_ga[p] + pi[i-1]) % mod;
		return 1;
	}

	Pushdown(p);
	if (Modify(ls,l,mid,s,e,i) == 0)
	{
		// 深黄
		f[ls] = (f[ls] + g[ls]) % mod;
		g[ls] = g[ls] * 2 % mod;

		// 浅黄
		sum[ls] = sum[ls] * 2 % mod;
		tag_f[ls] = tag_f[ls] * 2 % mod;
		tag_ga[ls] = tag_ga[ls] * 2 % mod;
		tag_gm[ls] = tag_gm[ls] * 2 % mod;
	}

	if (Modify(rs,mid+1,r,s,e,i) == 0)
	{
		f[rs] = (f[rs] + g[rs]) % mod;
		g[rs] = g[rs] * 2 % mod;

		sum[rs] = sum[rs] * 2 % mod;
		tag_f[rs] = tag_f[rs] * 2 % mod;
		tag_ga[rs] = tag_ga[rs] * 2 % mod;
		tag_gm[rs] = tag_gm[rs] * 2 % mod;
	}

	sum[p] = (sum[ls] + f[ls] + sum[rs] + f[rs]) % mod;

	return 1;
}

int main()
{
	pi[0] = 1; for (int i = 1; i <= 100000; ++i) pi[i] = pi[i-1] * 2 % mod;
	read(n); read(m);

	for (int i = 0; i <= (n<<2)+5; ++i) tag_ga[i] = 0, tag_f[i] = tag_gm[i] = 1;

	int op,l,r;
	for (int i = 1, j = 0; i <= m; ++i)
	{
		read(op);
		if (op == 1) 
		{
			read(l); read(r);
			Modify(1,1,n,l,r,++j);
		}
		else
		{
			printf("%lld\n",(sum[1] + f[1]) % mod);
		}
	}
	return 0;
}
```

---

## 作者：foreverlasting (赞：1)

[推销个人博客](https://foreverlasting1202.github.io/)

线段树傻题。

刚刚调了一下代码，发现自己先$modify$再$pushdown$了，我算是服了，怪不得考场上调不出来。

这题考场上好像基本上都是十几分钟都已经看出来了。就是我们发现对于那些无法递归到的区间而言，就是直接乘$2$。对于递归到的区间，事实上只是记录一下当前节点有且父亲有的个数和当前节点有且父亲无的个数就可以了。然后因为其他要乘$2$，于是递归到的除以$2$就好了。最后讨论一下当前递归到的区间与修改区间包含，相离，相交关系就好了。

code:
```cpp
//2019.4.2 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-5
#define RG register
inline int read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void swap(res &x,res &y){
    x^=y^=x^=y;
}
const int kcz=998244353;
const int INV2=(kcz+1)>>1;
const int N=1e5+10;
namespace MAIN{
    int n,m;
    int pw[N];
    inline int mul(const res &x,const res &y){
        return int(1LL*x*y%kcz);
    }
    inline int Add(const res &x,const res &y){
        return x+y>=kcz?x+y-kcz:(x+y<0?x+y+kcz:x+y);
    }
    inline void add(res &x,const res &y){
        x+=y,x>=kcz?x-=kcz:(x<0?x+=kcz:1);
    }
    int tag[N<<2],f[N<<2],g[N<<2];
    //f ziyou g ziwu
    int ans;
    void modify(res rt,res l,res r,res L,res R){
        res ls=rt<<1,rs=rt<<1|1;
        if(L<=l&&r<=R){
            add(ans,-f[rt]),f[rt]=mul(Add(f[rt],1),INV2),add(ans,f[rt]),g[rt]=mul(Add(g[rt],1),INV2);
            tag[rt]++;
            return;
        }
        res mid=(l+r)>>1;
        bool fl1=0,fl2=0;
        tag[ls]+=tag[rt],g[ls]=Add(1,-mul(Add(1,-g[ls]),pw[tag[rt]]));
        if(mid<L||l>R)add(ans,-f[ls]),f[ls]=mul(Add(f[ls],g[ls]),INV2),add(ans,f[ls]);
        else fl1=1;
        tag[rs]+=tag[rt],g[rs]=Add(1,-mul(Add(1,-g[rs]),pw[tag[rt]]));
        if(mid+1>R||r<L)add(ans,-f[rs]),f[rs]=mul(Add(f[rs],g[rs]),INV2),add(ans,f[rs]);
        else fl2=1;
        tag[rt]=0;
        add(ans,-f[rt]),f[rt]=mul(f[rt],INV2),add(ans,f[rt]),g[rt]=mul(g[rt],INV2);
        if(fl1)
            modify(ls,l,mid,L,R);
        if(fl2)
            modify(rs,mid+1,r,L,R);
    }
    int sum=1;
    inline void MAIN(){
        n=read(),m=read(),pw[0]=1;
        for(res i=1;i<=m;i++)pw[i]=mul(pw[i-1],INV2);
        while(m--){
            res opt=read();
            if(opt==1){
                res l=read(),r=read();
                modify(1,1,n,l,r),sum=mul(sum,2);
            }
            else printf("%d\n",mul(ans,sum));
        }
    }
}
int main(){
    MAIN::MAIN();
    return 0;
}
```
考场上为了写的快，我并没有记录$fl1$和$fl2$，而是把$fl1$和$fl2$直接换成$modify$下一个区间了。然后就成功挂题了。

哎。

---

## 作者：Purslane (赞：0)

# Solution

所以这题和《【ZJOI2020】传统艺能》有任何区别吗。

注意到题目“复制”操作完全是一个噱头，问题可以转化为：设当前线段集合为 $S$，从 $S$ 中选一个子集 $T \subseteq S$ 将 $T$ 中元素按顺序操作到线段树上，定义 $f(T)$ 为带标记的节点数量。求 $\sum_{T \subseteq S} f(T)$ 的值。

还是考虑几种情况：记录 $0/1/2$ 三种点为一直没有、某个祖先有、自己有。考虑有哪些特殊的转移（显然有 $0\to 0$、$1 \to 1$、$2 \to 2$ 的转移，但是它们是平凡的；下文说的“有交”都指的是不包含且有重合）

1. 如果修改区间和父区间没有重合部分，那么 $0 \to 0$、$1 \to 1$、$2 \to 2$；
2. 如果修改区间包含父区间，那么 $0 \to 1$、$1 \to 1$、$2 \to 2$；
3. 如果修改区间和父区间有交。
   
     1. 如果修改区间包含这个区间，$0 \to 2$、$1 \to 2$、$2 \to 2$；
     2. 如果修改区间和这个区间无交，$0 \to 0$、$1 \to 2$、$2 \to 2$；
     3. 如果修改区间有交， $0 \to 0$、$1 \to 0$、$2 \to 0$。

时间空间管够，因此维护 $3 \times 3$ 的矩阵。现在只需要找到这五类点。

模拟线段树的 `update` 操作，可以把 $3.1$、$3.2$、$3.3$ 全扒拉出来。特别的，在 $3.1$ 部分，我们可以把所有 $2$ 类型的点找出来（他必定是一些子树构成的结构）；在 $3.2$ 部分，我们可以把所有 $1$ 类型的点找出来。那么矩阵 + 线段树维护 DP 即可。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10,MOD=998244353;
int n,m;
struct Matrix {int v[3][3];}e,upd[6],tval[MAXN<<2],sum[MAXN<<2],tag[MAXN<<2];
Matrix operator +(Matrix A,Matrix B) {
	ffor(i,0,2) ffor(j,0,2) A.v[i][j]=(A.v[i][j]+B.v[i][j])%MOD;
	return A;
}	
Matrix operator *(Matrix A,Matrix B) {
	Matrix C;
	memset(C.v,0,sizeof(C.v));
	ffor(i,0,2) ffor(j,0,2) ffor(k,0,2) C.v[i][k]=(C.v[i][k]+A.v[i][j]*B.v[j][k])%MOD;
	return C;	
}
Matrix operator ^(Matrix A,Matrix B) {
	Matrix C;
	memset(C.v,0,sizeof(C.v));
	ffor(i,0,0) ffor(j,0,2) ffor(k,0,2) C.v[i][k]=(C.v[i][k]+A.v[i][j]*B.v[j][k])%MOD;
	return C;	
}
#define lson (k<<1)
#define rson (k<<1|1)
#define mid (l+r>>1)
void push_up(int k) {return sum[k]=sum[lson]+tval[k]+sum[rson],void();}
void push_down(int k,int l,int r) {
	sum[lson]=sum[lson]^tag[k],sum[rson]=sum[rson]^tag[k],tval[lson]=tval[lson]^tag[k],tval[rson]=tval[rson]^tag[k];
	tag[lson]=tag[lson]*tag[k],tag[rson]=tag[rson]*tag[k],tag[k]=e;
	return ;	
}
void Add_tag(int k,int l,int r,int op) {
	tval[k]=tval[k]^upd[op];
	if(l==r) sum[k]=tval[k];
	else sum[k]=tval[k]+sum[lson]+sum[rson];
	return ;
}
void add_tag(int k,int op) {
	return tval[k]=tval[k]^upd[op],tag[k]=tag[k]*upd[op],sum[k]=sum[k]^upd[op],void();	
}
void update(int k,int l,int r,int x,int y) {
	if(x<=l&&r<=y) {
		Add_tag(k,l,r,3);
		if(l!=r) push_down(k,l,r),add_tag(lson,2),add_tag(rson,2),push_up(k);
		return ;
	}
	if(x>r||y<l) {
		Add_tag(k,l,r,4);
		if(l!=r) push_down(k,l,r),add_tag(lson,1),add_tag(rson,1),push_up(k);
		return ;
	}
	push_down(k,l,r),Add_tag(k,l,r,5);
	update(lson,l,mid,x,y),update(rson,mid+1,r,x,y);
	return push_up(k),void();
}
void build(int k,int l,int r) {
	tag[k]=e,tval[k].v[0][0]=1;
	if(l==r) return sum[k].v[0][0]=1,void();
	build(lson,l,mid),build(rson,mid+1,r);
	return push_up(k),void();	
}
signed main() {
//	freopen("segment1.in","r",stdin);
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	e.v[0][0]=e.v[1][1]=e.v[2][2]=1;
	ffor(i,1,5) ffor(j,0,2) upd[i].v[j][j]=1;
	upd[1].v[0][0]++,upd[1].v[1][1]++,upd[1].v[2][2]++;
	upd[2].v[0][1]++,upd[2].v[1][1]++,upd[2].v[2][2]++;
	upd[3].v[0][2]++,upd[3].v[1][2]++,upd[3].v[2][2]++;
	upd[4].v[0][0]++,upd[4].v[1][2]++,upd[4].v[2][2]++;
	upd[5].v[0][0]++,upd[5].v[1][0]++,upd[5].v[2][0]++;
	build(1,1,n);
	ffor(i,1,m) {
		int op,l,r;
		cin>>op;
		if(op==2) cout<<sum[1].v[0][2]<<'\n';
		else cin>>l>>r,update(1,1,n,l,r);	
	}
	return 0;
}
```

调不出来上 LOJ 下数据就行了。

---

## 作者：__ycx2010__ (赞：0)

### 代码

对于每一次修改，将线段树划分为 5 类点。

![QQ截图20231123095905.png](https://cdn.acwing.com/media/article/image/2023/11/23/139576_e7af7d8589-QQ截图20231123095905.png) 

- 一类点：与修改区间相交且不被包含（黑色）。
- 二类点：被修改区间完全包含，且存在标记（蓝色）。
- 三类点：与修改区间不相交且父节点为一类点（橙色）。
- 四类点：被修改区间完全包含，且没有标记（浅蓝色）。
- 五类点：与修改区间不相交且父节点不为一类点（黄色）。

设 $f_{u,i}$ 表示第 i 次修改后，$2^i$ 棵线段树中所有 u 有标记的数量。

设 $g_{u,i}$ 表示第 i 次修改后，$2^i$ 棵线段树中所有 1 -> u 路径上无标记的数量。

- 对于一类点: 

$$f_{u,i} = f_{u,i-1}$$

$$g_{u,i} = g_{u,i - 1} + 2^{i-1}$$

- 对于二类点：

$$f_{u,i} = f_{u,i-1} + 2^{i-1}$$

$$g_{u,i} = g_{u,i-1}$$

- 对于三类点:

$$f_{u,i} = f_{u,i-1} + (2^{i-1} - g_{u,i - 1})$$

$$g_{u,i} = 2g_{u,i-1}$$

- 对于四类点：

$$f_{u,i} = 2f_{u,i - 1}$$

$$g_{u,i} = g_{u,i - 1}$$

- 对于五类点：

$$f_{u,i} = 2f_{u,i - 1}$$

$$g_{u,i} = 2g_{u,i - 1}$$

一二三类点个数均为 $O(\log n)$，但四五类点不是。

对于四五类点，可以设一个懒标记解决。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 200010, mod = 998244353;
int n, m, k;

struct Node {
	int sf, f, g, tf, tg;
	bool leaf;
} tr[N << 2];

void add(int &x, int y) {x = (x + y) % mod;}

void pushup(int u) {
	tr[u].sf = ((long long)tr[u].f + tr[u << 1].sf + tr[u << 1 | 1].sf) % mod;
}

void pushtf(int u, int x) {
	tr[u].sf = 1ll * tr[u].sf * x % mod;
	tr[u].f = 1ll * tr[u].f * x % mod;
	tr[u].tf = 1ll * tr[u].tf * x % mod;
}

void pushtg(int u, int x) {
	tr[u].g = 1ll * tr[u].g * x % mod;
	tr[u].tg = 1ll * tr[u].tg * x % mod;
}

void pushdown(int u) {
	if (tr[u].tf != 1) {
		pushtf(u << 1, tr[u].tf), pushtf(u << 1 | 1, tr[u].tf);
		tr[u].tf = 1;
	} if (tr[u].tg != 1) {
		pushtg(u << 1, tr[u].tg), pushtg(u << 1 | 1, tr[u].tg);
		tr[u].tg = 1;
	}
}

void build(int u, int l, int r) {
	tr[u].g = tr[u].tf = tr[u].tg = 1;
	if (l == r) return;
	int mid = l + r >> 1;
	build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
}

void modify(int u, int s, int t, int l, int r) {
	pushdown(u);
	if (r < s || l > t) {
		add(tr[u].f, (k - tr[u].g + mod) % mod);
		tr[u].g = tr[u].g * 2 % mod;
		pushtf(u << 1, 2), pushtf(u << 1 | 1, 2);
		pushtg(u << 1, 2), pushtg(u << 1 | 1, 2);
	} else if (l <= s && t <= r) {
		add(tr[u].f, k);
		pushtf(u << 1, 2), pushtf(u << 1 | 1, 2);
	} else {
		add(tr[u].g, k);
		int mid = s + t >> 1;
		modify(u << 1, s, mid, l, r);
		modify(u << 1 | 1, mid + 1, t, l, r);
	}
	pushup(u);
}

int main() {
	k = 1;
	scanf("%d%d", &n, &m);
	build(1, 1, n);
	for (int i = 1; i <= m; i ++ ) {
		int op;
		scanf("%d", &op);
		if (op == 1) {
			int l, r;
			scanf("%d%d", &l, &r);
			modify(1, 1, n, l, r);
			k = k * 2 % mod;
		} else printf("%d\n", tr[1].sf);
	}
	return 0;
}
```

---

## 作者：_lbw_ (赞：0)

妹看懂其他 5 种类型的题解，感觉麻烦了。。。

我们将题意进行转化可以得到应该算的是每种操作做或不做的答案和。

容易考虑 dp，设 $f_u$ 表示 $u$ 这个节点 tag 为 1 的期望，因为这样可以使需要修改的节点是 $\mathcal{O}(\log)$ 的。

然后思考转移，我们会发现有很多种点。

- 要 $\textsf{pushdown}$ 的点，一轮修改后一定是 $0$。

- 要 $\textsf{tag}\gets 1$ 的点有，一轮修改后一定是 $1$。

- 被 $\textsf{pushdown}$ 的点，一轮修改后为 $1$ 的概率是这个点到根上至少有一个 $1$ 的概率。

至少有一个 $1$ 的概率是 $1-$ 其他点全是 $0$ 的概率。

也就是 $P(tag_1\times tag_2\times tag_3\dots )$，但注意它不等于 $\prod P(tag_i)$，因为 $tag_1,tag_2$ 等可能是相关的。

于是我们再设计一个函数 $g_u$ 表示 $u$ 到 $rt$ 至少有一个 $1$ 的概率。

然后就是 $g$ 的转移，分为三部分。

第一类点，第二类点和它的子树，第三类点和它的子树。

第一类点 $g\gets g/2$。

第二类点和它的子树 $g\gets (g+1)/2$ 。

第三类点 $g$ 不变，$f$ 容易转移。

对于子树加打标记即可，时间复杂度 $\mathcal{O}(n\log n)$

---

## 作者：⑨_Cirno_ (赞：0)

~~ZJOI最可做的就是数据结构题了~~

此题所有点贡献独立，所以我们可以求一下所有点在多少种情况下有tag

设dp1i表示点i有多少种情况是1

对于一次修改tag被标记为1的，dp1i+=2^(修改编号)(编号从0开始），因为新开的线段树这里的tag都是1

对于其它在修改路径上的点，它在新的线段树上的tag一定是0，所以dp1i不变

对于与修改路径直接相连的点，我们发现只有当它到根的路径上有tag，它的tag才变成1

我们再设dp2i表示有多少种情况i到根的路径全0（有1的就用总情况数减就行了

这样与修改路径直接相连的dp1i+=2^(修改编号)-dp2i

对于其他点的tag此次修改不影响，所以dp1i*=2

再来考虑dp2i怎么维护

对于一次修改tag被标记为1的i及其子树，这样的dp2i没有新的贡献，即不变

对于其他在修改路径上的i，新的线段树上i到根的路径全0，所以dp2i+=2^(修改编号)

对于其他的i，dp2i取决于原来的i到根的路径上有没有，所以这样的dp2i*=2

这样做就是线段树复杂度O(nlogn)

总答案我们加个sdpi表示i子树的dp1值之和就行了

（以下是极丑的代码）
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
using namespace std;
typedef long long ll;
const ll M=998244353;
int n,m,x,l,r,tot,i;
ll dp1[1000005],dp2[1000005],lazy[1000005],yuyu[1000005],sdp[1000005],lazy1[1000005];
void pushdown(int i)
{
    if(lazy1[i]!=0)
    {
        dp1[i*2]=dp1[i*2]*yuyu[lazy1[i]]%M;
        dp1[i*2+1]=dp1[i*2+1]*yuyu[lazy1[i]]%M;
        sdp[i*2]=sdp[i*2]*yuyu[lazy1[i]]%M;
        sdp[i*2+1]=sdp[i*2+1]*yuyu[lazy1[i]]%M;
        lazy1[i*2+1]+=lazy1[i];
        lazy1[i*2]+=lazy1[i];
        lazy1[i]=0;
    }
    if(lazy[i]!=0)
    {
        dp2[i*2]=dp2[i*2]*yuyu[lazy[i]]%M;
        dp2[i*2+1]=dp2[i*2+1]*yuyu[lazy[i]]%M;
        lazy[i*2]+=lazy[i];
        lazy[i*2+1]+=lazy[i];
        lazy[i]=0;
    }
}
void pushup(int i)
{
    pushdown(i);
    sdp[i]=(sdp[i*2]+sdp[i*2+1]+dp1[i])%M;
}
void modify(int i,int l,int r,int ll,int rr)
{
    pushdown(i);
    if(l>=ll&&r<=rr)
    {
        dp1[i]=(dp1[i]+yuyu[tot])%M;
        if(l!=r)
            lazy1[i]++;
        pushup(i);
        return;
    }
    int mid=(l+r)/2;
    if(mid>=ll&&mid<rr)
    {
        modify(i*2,l,mid,ll,rr);
        modify(i*2+1,mid+1,r,ll,rr);
    }
    else
        if(mid>=ll)
        {
            modify(i*2,l,mid,ll,rr);
            dp1[i*2+1]=(dp1[i*2+1]+yuyu[tot]-dp2[i*2+1])%M;
            lazy[i*2+1]++;
            dp2[i*2+1]=dp2[i*2+1]*2%M;
            lazy1[i*2+1]++;
            pushup(i*2+1);
        }
        else
        {
            modify(i*2+1,mid+1,r,ll,rr);
            dp1[i*2]=(dp1[i*2]+yuyu[tot]-dp2[i*2])%M;
            lazy[i*2]++;
            dp2[i*2]=dp2[i*2]*2%M;
            lazy1[i*2]++;
            pushup(i*2);
        }
    pushup(i);
    dp2[i]=(dp2[i]+yuyu[tot])%M;
}
int main(){
    scanf("%d %d",&n,&m);
    yuyu[0]=1;
    for(i=1;i<=100000;i++)
        yuyu[i]=yuyu[i-1]*2%M;
    for(i=1;i<=n*5;i++)
        dp2[i]=1;
    while(m--)
    {
        scanf("%d",&x);
        if(x==2)
        {
            pushup(1);
            printf("%lld\n",(sdp[1]%M+M)%M);
        }
        else
        {
            scanf("%d %d",&l,&r);
            modify(1,1,n,l,r);
            tot++;
        }
    }
}
```


---

## 作者：x_faraway_x (赞：0)

问题可以转化为每次区间覆盖操作有 $\frac{1}{2}$ 的概率进行，求标记和的期望。于是我们只要求出所有点有标记的概率即可。

我们设 $f_i$ 表示节点 $i$ 有标记的概率， $g_i$ 表示节点 $i$ 的祖先节点有标记的概率。如果一个节点未完全被包含，那么其未被包含的节点是否有标记取决于其祖先节点是否有标记，故要用来自祖先节点的信息来更新答案（设未包含的节点为 $j$ ，那么 $f_j \leftarrow \frac{f_j+g_j}{2}$ ）。如果一个节点被完全包含，那么 $f_i \leftarrow \frac{f_i+1}{2}$ ，其所有子节点(包括自己) $g_j \leftarrow \frac{g_j+1}{2}$ ； 否则因为当前到达的区间标记已被下传，所以 $f_i\leftarrow \frac{f_i}{2}, g_i\leftarrow \frac{g_i}{2}$ 。 线段树维护 $f_i,g_i$ ， $g_i$ 的维护需要打标记。

```cpp
#include<cstdio>
#include<cassert>
inline int gi()
{
	char c=getchar(); int x=0;
	for(;c<'0'||c>'9';c=getchar());
	for(;c>='0'&&c<='9';c=getchar())x=(x<<1)+(x<<3)+c-'0';
	return x;
}
const int N=2e5+5,Mod=998244353,inv=Mod+1>>1;
int n,m,f[N<<2],g[N<<2],sum[N<<2],tg1[N<<2],tg2[N<<2],fm=1;
#define lx (x<<1)
#define rx (x<<1|1)
#define mul(x,y) (1ll*(x)*(y)%Mod)
#define div2(x) (1ll*(x)*inv%Mod)
void pushdown(int x)
{
	if(tg1[x]==1&&tg2[x]==0) return ;
	tg1[lx]=mul(tg1[lx],tg1[x]),tg1[rx]=mul(tg1[rx],tg1[x]);
	tg2[lx]=(mul(tg2[lx],tg1[x])+tg2[x])%Mod;
	tg2[rx]=(mul(tg2[rx],tg1[x])+tg2[x])%Mod;
	g[lx]=(mul(g[lx],tg1[x])+tg2[x])%Mod;
	g[rx]=(mul(g[rx],tg1[x])+tg2[x])%Mod;
	tg1[x]=1,tg2[x]=0;
}
void solve(int x)
{
	f[x]=div2((f[x]+g[x])%Mod);
	sum[x]=((sum[lx]+sum[rx])%Mod+f[x])%Mod;
}
void update(int x, int l, int r, int sl, int sr)
{
	if(sl<=l&&r<=sr)
	{
		f[x]=div2(f[x]+1);
		g[x]=div2(g[x]+1);
		sum[x]=((sum[lx]+sum[rx])%Mod+f[x])%Mod;
		tg1[x]=div2(tg1[x])%Mod;
		tg2[x]=(div2(tg2[x])+inv)%Mod;
		return ;
	}
	pushdown(x);
	f[x]=div2(f[x]),g[x]=div2(g[x]);
	int mid=l+r>>1;
	if(sl>mid)
		update(rx,mid+1,r,sl,sr),solve(lx);
	else if(sr<=mid)
		update(lx,l,mid,sl,sr),solve(rx);
	else update(lx,l,mid,sl,sr),update(rx,mid+1,r,sl,sr);
	sum[x]=((sum[lx]+sum[rx])%Mod+f[x])%Mod;
}
int main()
{
	n=gi(),m=gi();
	for(int i=1;i<=(n<<2);++i) tg1[i]=1;
	while(m--)
	{
		int op=gi();
		if(op==2) printf("%d\n",1ll*fm*sum[1]%Mod);
		else
		{
			fm=2ll*fm%Mod;
			int l=gi(),r=gi();
			update(1,1,n,l,r);
		}
	}
}
```


---

## 作者：Thinking (赞：0)

首先，不难看出$k$次修改后的树有$2^k$棵，所以暴力无疑只有20pts~~那不就是我吗~~

所以，我们要把$2^{k}$棵树的维护变成一棵树。记$P_o$为$o$在这些树有标记的概率，那么答案就是$\sum{P_o}*2^{k}$。但由于有$pushdown$，一个结点在被访问到时，只要它和它的祖先中有一个有标记，它就会有标记，所以我们也要记录$o$和$o$的祖先中有**至少一个**有标记的概率$Pf_o$

现在，我们把每次修改影响的结点分类：

1. 被打标记的结点

在发生修改一半的树中，它被打了标记，有标记的概率为$1$，另外一半的概率不变，所以$P_o=\frac{P_o+1}{2}$，同理，$Pf_o=\frac{Pf_o+1}{2}$。

2. 被$modify$访问，但未打标记的结点

在发生修改一半的树中，它和祖先的标记全部被下推，另外一半不变。所以$P_o=\frac{P_o}{2},Pf_o=\frac{Pf_o}{2}$。

3. 被$pushdown$访问，但未被$modify$访问的结点

它们的$Pf_o$不变（祖先和它之间推不推都一样），但只要祖先有标记，它就会因为$pushdown$带上标记，所以$P_o=\frac{P_o+Pf_o}{2}$。

4. 被打标记的结点的子树

它们的$P_o$无疑不变，但在修改之后，其祖先必定带有标记，所以$Pf_o=\frac{Pf_o+1}{2}$。

这一类结点可能有$O(n)$个，所以我们不能直接改，但可以发现修改其实就是乘上$\frac{1}{2}$再加$\frac{1}{2}$，所以像[线段树2](https://www.luogu.org/problemnew/show/P3373)一样维护懒标记就可以了

上代码：

```cpp
#include<cstdio>
typedef long long ll;
const int mod=998244353;
const int inv2=499122177;  //2的逆元频繁使用，先存下来
const int N=100050;
char rB[1<<21],*S,*T,wB[1<<21];
int wp=-1;
inline char gc(){return S==T&&(T=(S=rB)+fread(rB,1,1<<21,stdin),S==T)?EOF:*S++;}
inline void flush(){fwrite(wB,1,wp+1,stdout);wp=-1;}
inline void pc(char c){if(wp+1==(1<<21))flush();wB[++wp]=c;}
inline int rd(){
    char c=gc();
    while(c<48||c>57)c=gc();
    int x=c&15;
    for(c=gc();c>=48&&c<=57;c=gc())x=(x<<3)+(x<<1)+(c&15);
    return x;
}
short buf[15];
inline void wt(int x){
    short l=-1;
    while(x>9){
        buf[++l]=x%10;
        x/=10;
    }
    pc(x|48);
    while(l>=0)pc(buf[l--]|48);
    pc('\n');
}
int p[N<<2],pf[N<<2],mulv[N<<2],addv[N<<2],sum[N<<3],x,y;  //在这个写法中叶子结点也会pushup，所以要sum要额外开大
void build(int o,int L,int R){
	mulv[o]=1;
	if(L<R){
		int lc=o<<1,rc=lc|1,M=L+R>>1;
		build(lc,L,M);build(rc,M+1,R);
	}
}
inline void pushup(int o){
	int lc=o<<1,rc=lc|1;
	sum[o]=((ll)p[o]+sum[lc]+sum[rc])%mod;
}
inline void pushdown(int o){
	int lc=o<<1,rc=lc|1;
	if(mulv[o]!=1){
		mulv[lc]=(ll)mulv[lc]*mulv[o]%mod;addv[lc]=(ll)addv[lc]*mulv[o]%mod;pf[lc]=(ll)pf[lc]*mulv[o]%mod;
		mulv[rc]=(ll)mulv[rc]*mulv[o]%mod;addv[rc]=(ll)addv[rc]*mulv[o]%mod;pf[rc]=(ll)pf[rc]*mulv[o]%mod;
		mulv[o]=1;
	}
	if(addv[o]){
		if((addv[lc]+=addv[o])>=mod)addv[lc]-=mod;if((pf[lc]+=addv[o])>=mod)pf[lc]-=mod;
		if((addv[rc]+=addv[o])>=mod)addv[rc]-=mod;if((pf[rc]+=addv[o])>=mod)pf[rc]-=mod;
		addv[o]=0;
	}
}
void update(int o,int L,int R){
	if(x<=L&&y>=R){  //第1类
		p[o]=((ll)p[o]*inv2+inv2)%mod;
		pf[o]=((ll)pf[o]*inv2+inv2)%mod;
		mulv[o]=(ll)mulv[o]*inv2%mod;
		addv[o]=((ll)addv[o]*inv2+inv2)%mod;  //为第4类的修改打懒标记
	}else{
		int lc=o<<1,rc=lc|1,M=L+R>>1;
		pushdown(o);
		if(x<=M)update(lc,L,M);
		else{
			p[lc]=((ll)p[lc]*inv2+(ll)pf[lc]*inv2)%mod;
			pushup(lc);
		}  //第3类
		if(y>M)update(rc,M+1,R);
		else{
			p[rc]=((ll)p[rc]*inv2+(ll)pf[rc]*inv2)%mod;
			pushup(rc);
		}
		p[o]=(ll)p[o]*inv2%mod;pf[o]=(ll)pf[o]*inv2%mod;  //第2类
	}
	pushup(o);
}
int main(){
	int n=rd(),q=rd(),t,k=1;  //用k存当前有多少棵树
	build(1,1,n);
	while(q--){
		t=rd();
		if(t==1){
			x=rd();y=rd();
			update(1,1,n);
			if((k<<=1)>=mod)k-=mod;
		}else if(t==2)wt((ll)sum[1]*k%mod);
	}
	flush();
	return 0;
}
```


---


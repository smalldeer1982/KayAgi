# [十二省联考 2019] 异或粽子

## 题目描述

小粽是一个喜欢吃粽子的好孩子。今天她在家里自己做起了粽子。

小粽面前有 $n$ 种互不相同的粽子馅儿，小粽将它们摆放为了一排，并从左至右编号为 $1$ 到 $n$。第 $i$ 种馅儿具有一个非负整数的属性值 $a_i$。每种馅儿的数量都足够多，即小粽不会因为缺少原料而做不出想要的粽子。小粽准备用这些馅儿来做出 $k$ 个粽子。

小粽的做法是：选两个整数数 $l$,  $r$，满足 $1 \leqslant l \leqslant r \leqslant n$，将编号在 $[l, r]$ 范围内的所有馅儿混合做成一个粽子，所得的粽子的美味度为这些粽子馅儿的属性值的**异或和**。（异或就是我们常说的 xor 运算，即 C/C++ 中的 `ˆ` 运算符或 Pascal 中的 `xor` 运算符）

小粽想品尝不同口味的粽子，因此她不希望用同样的馅儿的集合做出一个以上的粽子。

小粽希望她做出的所有粽子的美味度之和最大。请你帮她求出这个值吧！

## 说明/提示

| 测试点 | $n$ | $k$ |
| :---------- | :---------- | :---------- |
| $1$, $2$, $3$, $4$, $5$, $6$, $7$, $8$ | $\leqslant 10^3$ | $\leqslant 10^3$ |
| $9$, $10$, $11$, $12$ | $\leqslant 5 \times 10^5$ | $\leqslant 10^3$ |
| $13$, $14$, $15$, $16$ | $\leqslant 10^3$ | $\leqslant 2 \times 10^5$ |
| $17$, $18$, $19$, $20$ | $\leqslant 5 \times 10^5$ | $\leqslant 2 \times 10^5$ |

## 样例 #1

### 输入

```
3 2
1 2 3```

### 输出

```
6```

# 题解

## 作者：qwaszx (赞：219)

神仙们都写的可持久化$Trie$然而我并不会写

给一个简单的做法好了QAQ

首先做前缀异或和，然后变成求最大的$k$对异或和的和

注意到这是一个关于三角$(a_i\ xor\ a_j,0\leq i\leq j\leq n)$的求值，并且有$a_i\ xor\ a_j=a_j\ xor\ a_i$所以我们先把答案乘二然后再除回去，这样我们要求的就是最大的$2k$个有序对，这个就很好处理了.对角线上的元素并不影响，因为$a_i\ xor\ a_i=0$是最小的.

可以对每一个$i$求出第$t$(初始为$1$)大的$a_i\ xor\ a_j$，然后把结果扔到堆里，每次取堆顶，然后把堆顶对应的$i$的第$t+1$大的$a_i\ xor\ a_j$扔进堆里.具体看代码好了QAQ.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int N=20000000+10;
struct Node{int id,rk;long long w;bool operator <(const Node &a)const{return w<a.w;}};
priority_queue<Node>q;
long long ans=1,x,s[N];
int a[N][2],size[N],n,m,tot;
void ins(long long x)
{
    int u=0;
    for(int i=31;i>=0;i--)
    {
        int ch=(x>>i)&1;size[u]++;//插入的时候维护子树大小便于处理
        if(!a[u][ch])a[u][ch]=++tot;
        u=a[u][ch];
    }
    size[u]++;
}
long long query(long long x,int rk)
{
    int u=0;long long ans=0;
    for(int i=31;i>=0;i--)
    {
        int ch=(x>>i)&1;//cout<<u<<" "<<ch<<" "<<size[a[u][1]]<<"  ";
        if(!a[u][ch^1])u=a[u][ch];//如果没有和这一位相异的就直接走
        else if(rk<=size[a[u][ch^1]])u=a[u][ch^1],ans|=1LL<<i;//看一下相异节点的子树大小决定走哪边.和平衡树的操作差不多
        else rk-=size[a[u][ch^1]],u=a[u][ch];
    }
    return ans;
}
long long getin()//不开long long见祖宗 我就见祖宗了QAQ
{
    long long x=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
    return x;
}
int main()
{
    n=getin(),m=getin();m<<=1;//前2k个
    for(int i=1;i<=n;i++)x=getin(),s[i]=s[i-1]^x;
    for(int i=0;i<=n;i++)ins(s[i]);//注意有0
    for(int i=0;i<=n;i++)q.push((Node){i,1,query(s[i],1)});//堆中节点存第rk大的s[id]^s[j]
    for(int i=1;i<=m;i++)
    {
        Node t=q.top();ans+=t.w;q.pop();//cout<<t.id<<" "<<t.rk<<" "<<t.w<<endl;
        if(t.rk<n)q.push((Node){t.id,t.rk+1,query(s[t.id],t.rk+1)});
    }
    cout<<(ans>>1)<<endl;//最后把答案除以二
}
```
可以看到这个代码只有几十行，但是跑得很快.

最后一定一定要开$long\ long$啊$QAQ$.

---

## 作者：hsfzLZH1 (赞：95)

## 题目大意

给定一个长度为 $n$ 的数组 $a_i$ ，你每次可以选择一个区间 $[l,r]$ ，其价值为 $val[l,r]=\bigoplus_{i=l}^r a_i$ 。求价值最大的 $k$ 个不同区间的价值和。

$1\le n\le 5\times 10^5,1\le k\le min\{\frac {n(n-1)} 2 ,2\times 10^5 \},0\le a_i\le 2^{32}-1$

## 解题思路

此题是求解异或问题的常用 trick 综合。

观察到价值是 $\bigoplus_{i=l}^r a_i$ ，我们可以定义 $s_i=\bigoplus_{j=1}^i a_j$ ，那么 $val[l,r]=s_{l-1}\oplus s_r$ 。特别的，有 $s_0=0$ 。这样，我们不同的 $i,j$ 满足 $0\le i< j\le n$ ，对应的就是不同的区间。

题目转化为给定一个长度为 $n+1$ 的数组 $s_i$ ，求 $i<j$ 时， $s_i\oplus s_j$ 的 $\frac {n(n+1)} 2$ 种取值中前 $k$ 大的值的和。

$i<j$ 这个条件很不美观，是一个上三角形的形状，我们交换 $i,j$ ，所求值也可以表示为 $i\ne j$ 时， $s_i\oplus s_j$ 的 $n(n+1)$ 种取值中前 $2k$ 大的值的和除以 $2$ 。由于 $i=j$ 时 $s_i\oplus s_j$ 的值为 $0$ ，而 $k\le \frac {n(n-1)} 2$ ，所以我们也可以忽略 $i\ne j$ 这个条件。

我们将 $s_i$ 的 $n+1$ 个值插入 01 Trie ，给定一个 $k$ ，我们可以在 $O(log_2 a)$ 的时间复杂度内找到与 $a$ 异或结果第 $k$ 大的值。方法类似于在线段树上二分。

我们维护一个大根堆，堆中初始时加入每个 $s_i$ 与 $s$ 中元素异或的最大值。每次我们取出堆顶，累加进答案，如果我们取出的是 $s_i$ 与 $s$ 中元素异或的第 $t$ 大值，就在堆中插入 $s_i$ 与 $s$ 中元素异或的第 $t+1$ 大值。这样进行 $k$ 次操作，取出的依次就是 $s$ 中元素两两异或的前 $k$ 大值。

令 $a=\max \{a_i\}$，则时间复杂度为 $O((n+k)\log_2 a\log_2 n)$ 。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int maxn=500010;
typedef long long ll;
int n,k,cnt=1;
ll a[maxn],ans;
struct Trie
{
    int ch[2],cnt;
}st[maxn*34];
void insert(ll v)
{
    int nww=1;st[nww].cnt++;
    for(ll i=33;i>=0;i--)
    {
        ll t=(v>>i)&1ll;
        if(!st[nww].ch[t])st[nww].ch[t]=++cnt;
        nww=st[nww].ch[t];st[nww].cnt++;
    }
}
ll query(ll v,int k)
{
    int nww=1;
    ll ans=0;
    for(ll i=33;i>=0;i--)
    {
        ll t=(v>>i)&1ll;
        if(st[st[nww].ch[t]].cnt>=k)nww=st[nww].ch[t];
        else k-=st[st[nww].ch[t]].cnt,nww=st[nww].ch[t^1],ans|=(1ll<<i);
    }
    return ans;
}
struct node
{
    int id,rnk;ll v;
    bool operator<(node x)const{return v<x.v;}
};
priority_queue<node>q;
int main()
{
    scanf("%d%d",&n,&k);k*=2;
    insert(0);for(int i=1;i<=n;i++)scanf("%lld",a+i),a[i]^=a[i-1],insert(a[i]);
    for(int i=0;i<=n;i++)q.push({i,n+1,query(a[i],n+1)});
    while(k--)
    {
        node x=q.top();q.pop();
        ans+=x.v;
        if(x.rnk)q.push({x.id,x.rnk-1,query(a[x.id],x.rnk-1)});
    }
    printf("%lld\n",ans/2ll);
    return 0;
}
```

## 解法扩展

考虑简化后的问题，给定一个数组 $a_i$ ，求其中两两异的前 $k$ 大值的和。

以上给出的做法是与 $k$ 有关的，此题中 $k$ 的数据范围是和 $n$ 同阶，但是 $k$ 的范围最大可以达到 $O(n^2)$ ，此时有时间复杂度为 $O(n\log_2^2 a)$ 的做法。（与 $k$ 无关）

建立 Trie ，将每个 $a_i$ 插入 Trie， Trie 上一个结点子树的大小定义为其子树中有多少个 $a_i$ 。

首先我们考虑如何求两两异或的 **第 $k$ 大值** 。考虑从高到低按位确定第 $k$ 大值每一个二进制位的值。假设我们已经确定了所求第 $k$ 的值的前若干位，正在确定当前位的值。对于每个 $a_i$ ，在 Trie 上都有一个对应的子树使得子树中的叶子结点对应的值（即从根节点到该叶子结点的路径对应的值）与 $a_i$ 异或的前缀等于已经确定的第 $k$ 大值的前若干位。我们设这个子树是 $v$ 的子树。设与 $v$ 同层（深度相同）且在根节点到 $a_i$ 对应叶子结点的路径上的点为 $u$ 。

我们每次将 $u,v$ 下移一层（始终保持 $u$ 在根节点到叶子结点 $a_i$ 的路径上 ），同时确定第 $k$ 大值对应位的值。假设我们即将把 $u$ 往一个方向的儿子下移，我们统计对每一个 $a_i$ 把 $v$ 向另一个方向移动的子树的大小之和 $tot$ 。$tot$ 即为第 $k$ 大值的这一位是 $1$ 时，满足 $a_i\oplus a_j$ 的相同位也是 $1$ 且与第 $k$ 大值之前已经确定的位数也相同的数对 $(i,j)$ 的组数。如果 $tot\ge k$ ，说明有多于 $k$ 个这样的对，第 $k$ 大值的这一位是 $1$ ，反之这一位是 $0$ ，此时还要将 $k$ 的值减去 $tot$ ，即求符合前缀相同条件的第 $k-tot$ 大值。根据求出的 $k$ 对应位的值，更新所有的 $u,v$ ，便于求解更低位。

求第 $k$ 大值的时间复杂度为 $O(n\log_2 a)$ 。

求出第 $k$ 大值后，我们考虑如何求前 $k$ 大值的和。在以上的过程中，我们剩下的 $k$ 的值即为前 $k$ 大值中与第 $k$ 大值相等的数的个数，那么，我们只需求出两两异或值大于第 $k$ 大值的异或值的和即可。

枚举每一个 $a_i$ ，同样从高位到低位求解。若两两异或的第 $k$ 大值的这一位是 $0$ ，则 $a_i$ 与 $\{$与 $u$ 这一层下移方向相反的子树 $\}$ 中叶子结点的对应值的异或值大于第 $k$ 大值。这样的子树最多有 $O(\log_2 a)$ 个。现在我们要解决的问题是如何求 $a_i$ 与某一子树中的值的异或值之和。

并不用 $O(n\log_2^2 a)$ 的空间处理存储， Trie 上一子树中的值在排序后的数组中是连续的一段。我们将 $a_i$ 数组排序，并不会影响之前的处理，然后处理出其每一位上 $1$ 的个数的前缀和，需要求值时找到子树中的最小值和最大值，对应数组中的左右端点，差分求值即可。由于我们要按位计算，单次求值的时间复杂度为 $O(\log_2 a)$ 。

总的时间复杂度为 $O(n\log_2^2 a)$ ，空间复杂度为 $O(n\log_2 a)$ 。

注意 `long long` ，特别是移位时， `(1<<i)` 是 `int` 型的，要写成 `(1ll<<i)` ！

## 代码展示

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define int long long
const int maxn=500010;
int n,k,a[maxn],kth,ans,tot;
int cnt,ch[maxn*40][2],minn[maxn*40],maxx[maxn*40],siz[maxn*40],nww,t,p[maxn];
int cnt1[maxn][40];
int calc(int v,int l,int r)
{
    if(l==0)return 0;
    int ret=0;
    for(int i=33;i>=0;i--)
    {
        int chx=(v>>i)&1;
        if(chx==0)ret+=(1ll<<i)*(cnt1[r][i]-cnt1[l-1][i]);
        else ret+=(1ll<<i)*(r-l+1-cnt1[r][i]+cnt1[l-1][i]);
    }
    return ret;
}
main()
{
    scanf("%lld%lld",&n,&k);k*=2;
    for(int i=1;i<=n;i++)scanf("%lld",a+i);
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++)for(int j=0;j<=33;j++)if((a[i]>>j)&1)cnt1[i][j]=cnt1[i-1][j]+1;else cnt1[i][j]=cnt1[i-1][j];
    cnt=1;
    for(int i=1;i<=n;i++)
    {
        nww=1;siz[nww]++;
        for(int j=33;j>=0;j--)
        {
            int chx=(a[i]>>j)&1;
            if(!ch[nww][chx])ch[nww][chx]=++cnt,minn[cnt]=i;
            nww=ch[nww][chx];maxx[nww]=i;siz[nww]++;
        }
    }
    for(int i=1;i<=n;i++)p[i]=1;
    for(int i=33;i>=0;i--)
    {
        tot=0;
        for(int j=1;j<=n;j++)
        {
            int chx=((a[j]>>i)&1)^1;
            tot+=siz[ch[p[j]][chx]];
        }
        if(k<=tot)t=1,kth|=(1ll<<i);
        else k-=tot,t=0;
        for(int j=1;j<=n;j++)
        {
            int chx=((a[j]>>i)&1)^t;
            p[j]=ch[p[j]][chx];
        }
    }
    //printf("%lld\n",kth);
    for(int i=1;i<=n;i++)
    {
        nww=1;
        for(int j=33;j>=0;j--)
        {
            int chx=((a[i]^kth)>>j)&1;
            if(((kth>>j)&1)==0&&ch[nww][chx^1])ans+=calc(a[i],minn[ch[nww][chx^1]],maxx[ch[nww][chx^1]]);
            nww=ch[nww][chx];
        }
    }
    printf("%lld\n",(ans+k*kth)/2ll);
    return 0;
}
```

总结一下本题中相关的 trick ：

1. 做异或前缀和，区间异或和转化为两数异或和；

2. 补全上三角形转化为求矩形的值；

3. 求两两异或的第 $k$ 大值：从高位到低位， Trie 上贪心；

4. 求一个值与静态 Trie 上一个子树中的值的异或和的和： Trie 上子树中的值在排序后数组上是连续的。

---

## 作者：xht (赞：45)

#### 题目地址：[P5283 [十二省联考2019]异或粽子](https://www.luogu.org/problemnew/show/P5283)

## 题意

前 $k$ 大区间异或和。

## 思路

一个很基础的转化是，我们可以 $O(n)$ 求出前缀异或和 $s_0, s_1, ..., s_n$ 。

那么显然 $xor_{i=l}^{r} = s_{l-1}\ xor\ s_r$ 。

题意转化为，在 $s_0, s_1, ..., s_n$ 这 $n+1$ 个数中，选出 $k$ 对 $(s_i, s_j)(i<j)$ ，使每对的异或值的和最大。

## 暴力分

注意到有 $60$ 分的数据满足 $n \leq 1000$ ，而上述所说的数对一共有 $O(n^2)$ 个。

那么我们可以把每一对的异或值都插入一个大根堆（优先队列）中，然后弹出 $k$ 次最大值，弹出的所有值的和就是最终答案。

```cpp
#include <bits/stdc++.h>
#define ui unsigned int
#define ull unsigned long long
using namespace std;
const int N = 5e5 + 6;
int n, k;
ui a[N], s[N];
priority_queue<ui> q;
ull ans;

inline ui rd() {
	ui x = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9') ch = getchar();
	while (ch >= '0' && ch <= '9') {
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	return x;
}

int main() {
	cin >> n >> k;
	for (int i = 1; i <= n; i++) a[i] = rd(), s[i] = s[i-1] ^ a[i];
	for (int l = 1; l <= n; l++)
		for (int r = l; r <= n; r++)
			q.push(s[r] ^ s[l-1]);
	while (k--) ans += q.top(), q.pop();
	cout << ans << endl;
	return 0;
}
```

**注意：由于这道题 $a$ 数组的数据范围为 $0 \leq ai​ \leq 4294967295$ ，所以要开unsigned int（当然long long也行）。**

## 正解

### 前置芝士

**可持久化Trie**

~~洛谷似乎并没有可持久化Trie的模板2333。~~

首先你要知道**可持久化**。

其次你要会**Trie**，并且要会这道题所要使用的**01Trie**。

如果这两者都会了，那么请先去把[P4735 最大异或和](https://www.luogu.org/problemnew/show/P4735)A掉。

A掉这道题之后，你就应该知道如何求在序列 $a$ 的一个给定区间 $[l, r]$ 中选择一个数 $i$ 使 $a_i$ 与另一个给定的值异或起来最大。

简要的思路是，建立可持久化Trie，在给定区间的Trie上贪心的优先选择与给定值当前位相反的节点（指针）。

### 本题思路

一开始，对于每个右端点 $r$ ，在前缀异或和序列 $s$ 的区间 $[0,r-1]$ 选择一个左端点 $l$ 使 $s_l$ 与 $s_r$ 异或起来最大，并将描述这个值的所有信息以这个值为关键字插入一个大根堆中。

描述这个值所需要的信息有：

1. 这个值的大小；
2. 这个值左端点的选择区间；
3. 这个值的左右端点。

可以用一个结构体记录，也可以用若干个pair记录，我的代码实现中是用的后者。

仍然弹出 $k$ 次堆中的最大值，那么弹出的所有值的和就是最终答案。

但是在弹出的同时也在不断的插入。

假设此时弹出来值及其描述信息为：

1. 这个值为 $x$ ；
2. 这个值左端点的选择区间为 $[L,R]$；
3. 这个值的左右端点为 $l,r$。

首先将 $x$ 加入答案。

然后将选择区间以 $l$ 为界限分成两段 $[L,l-1], [l+1,R]$ ，分别在这两个区间中选择与 $s_r$ 最大的异或值，将这个值及其描述信息插入大根堆中。

### 正确性

~~不言而喻。~~

**本题代码实现比较复杂，细节比较多，我的代码仅供参考，建议自己清楚思路后独立AC。**

```cpp
#include <bits/stdc++.h>
#define ui unsigned int
#define ull unsigned long long
#define pii pair<int, int>
#define X first
#define Y second
#define mp make_pair
using namespace std;
const int N = 5e5 + 6;
int n, m, trie[N<<6][2], late[N<<6], rt[N], t;
ui a[N];
ull ans;
priority_queue<pair<ui, pair<pii, pii> > > q;

inline ui rd() {
	ui x = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9') ch = getchar();
	while (ch >= '0' && ch <= '9')
		x = x * 10 + (ch - '0'), ch = getchar();
	return x;
}

void ins(int i, int k, int p, int o) {
	if (k < 0) return late[o] = i, void();
	int c = (a[i] >> k) & 1;
	if (p) trie[o][c^1] = trie[p][c^1];
	trie[o][c] = ++t;
	ins(i, k - 1, trie[p][c], trie[o][c]);
	late[o] = max(late[trie[o][0]], late[trie[o][1]]);
}

int ask(ui x, int k, int o, int p) {
	if (k < 0) return late[o];
	int c = (x >> k) & 1;
	return ask(x, k - 1, trie[o][c^(late[trie[o][c^1]]>=p)], p);
}

int main() {
	cin >> n >> m;
	late[0] = -1;
	ins(0, 31, 0, rt[0] = ++t);
	for (int i = 1; i <= n; i++) {
		a[i] = rd() ^ a[i-1];
		ins(i, 31, rt[i-1], rt[i] = ++t);
		int j = ask(a[i], 31, rt[i-1], 0);
		q.push(mp(a[j] ^ a[i], mp(mp(0, i - 1), mp(j, i))));
	}
	while (m--) {
		ans += q.top().X;
		int l = q.top().Y.Y.X, i = q.top().Y.Y.Y;
		pii k = q.top().Y.X;
		q.pop();
		if (l != k.Y) {
			int j = ask(a[i], 31, rt[k.Y], l + 1);
			q.push(mp(a[j] ^ a[i], mp(mp(l + 1, k.Y), mp(j, i))));
		}
		if (l != k.X) {
			int j = ask(a[i], 31, rt[l-1], k.X);
			q.push(mp(a[j] ^ a[i], mp(mp(k.X, l - 1), mp(j, i))));
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Owen_codeisking (赞：42)

我居然在有生之年切掉了一道十二省联考的题？

做法跟超级钢琴超像，可以出门右拐。

### 可持久化 $01trie$ + 堆

我们求一遍前缀异或和，那么 $[l,r]$ 的异或和为 $sum_{l-1}\ \text{xor}\ sum_r$

我们先固定右端点 $r$，然后在 $[0,r-1]$ 查一个数异或 $sum_r$ 最大。这个可以用可持久化 $01trie$ 实现。

我们将 $n$ 个数放入堆中，每次取出最大的那个状态。设这个状态左端点在 $[l,r]$ ，与 $sum_x$ 异或起来最大的位置在 $k$，那么我们把状态的左端点分割成 $[l,k-1]$ 和 $[k+1,r]$ 后放入堆中。

时间复杂度 $O(n\log n)$

注意：下面这段代码不开加 $2K$ 的 $pragma$ 会被卡常，所以看看就好。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=500000+10;
int n,k,rt[maxn],cnt;ll a[maxn],ans;

struct node
{
	int ch[2],siz,id;
}t[maxn*40];

inline ll read()
{
	register ll x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return (f==1)?x:-x;
}

void insert(int &now,int pre,int bit,int id,ll val)
{
	now=++cnt;t[now]=t[pre];t[now].siz++;
	if(bit==-1){t[now].id=id;return;}
	if((val>>bit)&1) insert(t[now].ch[1],t[pre].ch[1],bit-1,id,val);
	else insert(t[now].ch[0],t[pre].ch[0],bit-1,id,val); 
}

int query(int u,int v,int bit,ll val)
{
	if(bit==-1) return t[v].id;
	int d=(val>>bit)&1;
	if(t[t[v].ch[d^1]].siz-t[t[u].ch[d^1]].siz>0) return query(t[u].ch[d^1],t[v].ch[d^1],bit-1,val);
	return query(t[u].ch[d],t[v].ch[d],bit-1,val);
}

struct State
{
	int l,r,x,id;ll val;
	State(int _l=0,int _r=0,int _x=0)
	{
		l=_l;r=_r;x=_x;
		id=query(rt[l-1],rt[r],31,a[x]);
		val=a[x]^a[id-1];
	}
};
inline bool operator < (const State &a,const State &b)
{
	return a.val<b.val;
}
priority_queue<State> pq;

int main()
{
	n=read(),k=read();
	for(int i=1;i<=n;i++) a[i]=a[i-1]^read();
	for(int i=1;i<=n;i++) rt[i]=rt[i-1],insert(rt[i],rt[i],31,i,a[i-1]);
	for(int i=1;i<=n;i++) pq.push(State(1,i,i));
	while(k--)
	{
		State u=pq.top();pq.pop();ans+=u.val;
		if(u.l<u.id) pq.push(State(u.l,u.id-1,u.x));
		if(u.id<u.r) pq.push(State(u.id+1,u.r,u.x));
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：GNAQ (赞：26)

考虑先做个 prefix xor 前缀异或

$$ b_0=0; $$

$$ b_i = \bigoplus_{j=1}^ia_j (1\leqslant i \leqslant n)$$

然后可以 $\mathcal{O}(1)$ 查询区间的异或了。

$$\bigoplus_{i=l}^r a_i=b_r\oplus b_{l-1}$$

然后考虑这样我们要解决的问题就变成了

> 给定 $n$ 个数，求异或值最靠前的 $k$ 对。

## 算法 0

----------------------

先从最简单的出发，考虑二分一个答案下界 $q$ ，也即这 $k$ 个值都 $\geqslant q$ 。

考虑一次算出以 $l$ 做左端点的所有右端点对答案有没有贡献，如果这个过程可以 $\mathcal{O}(\log n)$ 那么我们可以 $\mathcal{O}(n \log^2 n)$ 通过本题。

我们考虑建立一个 01-Trie （字典树），先顺次插入 $b_1 \sim b_n$ ，然后我们枚举这个左端 $l$ 并进 Trie 树统计有多少数字 $\oplus \,b_l \leqslant q$ 。

过程如下：

- 设当前走到的深度是 $d$ ，取出 $b_l$ 的左起第 $d$ 位记为 $u$ ，取出 $q$ 的左起第 $d$ 位记为 $v$ 。

- 设 `ch[0]` 表示结点左儿子， `ch[1]` 表示右儿子，如果当前 $v=0$ ，递归进入 `ch[0^u]` 计算答案并加上 `ch[1^u]` 子树内点数；否则 $v=1$ 递归进入 `ch[1^u]` 计算答案。

然后统计答案的时候，因为点数不超过 $k\log A$ 个，所以直接进树 DFS 。

大致代码：

```cpp
int Count(int inx,ll dep,ll val,ll bd)
{
    if (!inx) return 0;
    if (dep==-1) return node[inx].siz;
    
    bool bt=(bd>>dep)&1LL;
    bool cnt=(val>>dep)&1LL;
    
    if (!bt) 
    {
        return node[node[inx].ch[1^cnt]].siz+
               Count(node[inx].ch[0^cnt],dep-1,val,bd);
    }
    else
    {
        return Count(node[inx].ch[1^cnt],dep-1,val,bd);
    }
}
```

注意枚举过 $b_l$ 之后要把 $b_l$ 在 Trie 上删去。

## 算法 1

-------------------

考虑优化算法 0

执行算法 0 的时候我们每次都要重建 Trie ，浪费时间，于是对 Trie 进行可持久化，然后倒序枚举即可。

## 算法 2 (100分）

-----------

考虑优化算法 1

瓶颈在于求得答案下界需要二分。

我们可以尝试换成可持久化 Trie 上二分，在 Trie 上走一走。

记录 $ck$ 是当前 “剩余可用点数”，初始化为 $k$ 。

每次向下走检查 `ch[1]` 中点数如果 $\leqslant ck$ 那么让 $ck-=\mathrm{nodesiz[ch[1]]}$ ，然后走到 `ch[0]` ，否则走到 `ch[1]` 

但是注意到走的方向和当前插入的值 $b_l$ 有关，没法简单的走下去。

考虑每个 $l$ 对应的是左数第 $l+1$ 颗可持久化 Trie，于是把 $0 \leqslant l < n$ 的 $l$ 扔进去放在一起跑即可。

具体逻辑见代码：

```cpp
int cur[500010];
ll Solve(ll dep,ll ck,ll val) // OK!!!
{
    if (dep==-1) return val;
    
    ll tot=0;
    for (int i=1;i<=n;i++) 
    {
        bool cnt=(ai[i-1]>>dep)&1LL;
        tot+=node[node[cur[i]].ch[1^cnt]].siz;
    }
    
    if (tot<ck)
    {
        ck-=tot;
        for (int i=1;i<=n;i++) 
        {
            bool cnt=(ai[i-1]>>dep)&1LL;
            cur[i]=node[cur[i]].ch[0^cnt];
        }
        return Solve(dep-1,ck,val);
    }
    else
    {
        for (int i=1;i<=n;i++) 
        {
            bool cnt=(ai[i-1]>>dep)&1LL;
            cur[i]=node[cur[i]].ch[1^cnt];
        }
        return Solve(dep-1,ck,val+(1LL<<dep));
    }
}
```

然后 $\mathcal{O}(n \log n)$ 求得下界。

然后统计答案还是 DFS 。

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm>
#include<iterator>
#include<queue>
#include<vector>
using namespace std;
typedef long long ll;

int n; ll k;
ll ai[500010];

template<typename inp_t>
void readx(inp_t& x)
{
    x=0; int k=1; char ch=0;
    while (ch<'0' || ch>'9') { ch=getchar(); if (ch=='-') k=-1; }
    while (ch>='0' && ch<='9') { x=x*10+ch-'0'; ch=getchar(); }
    x*=k;
}

namespace DS
{
    #define LCH node[inx].ch[0]
    #define RCH node[inx].ch[1]
    
    struct Trie_Node
    {
        int ch[2],siz;
    }node[500010*41];
    int tsiz=1,root[500010];
    
    void Ins(int inx,int old,ll dep,ll val)
    {
        if (dep==-1)
        {
            node[inx].siz++;
            return;
        }
        bool dir=(val>>dep)&1LL;
        
        node[inx].ch[!dir]=node[old].ch[!dir];
        node[inx].ch[dir]=++tsiz;
        node[node[inx].ch[dir]].siz=node[node[old].ch[dir]].siz;
        
        Ins(node[inx].ch[dir],node[old].ch[dir],dep-1,val);
        
        node[inx].siz=node[LCH].siz+node[RCH].siz;
    }
    
    void Build()
    {
        for (int i=1;i<=n;i++) root[i]=i;
        tsiz=n;
        for (int i=n;i>=1;i--)
            Ins(root[i],root[i+1],32,ai[i]);
//			Ins(root[i],root[i+1],4,ai[i]);
    }
    
    ll Get_Ans(int inx,ll dep,ll val,ll bd,ll cans,bool ok)
    {
        if (!inx) return 0;
        if (dep==-1) 
            return cans*node[inx].siz; 
        
        bool bt=(bd>>dep)&1LL;
        bool cnt=(val>>dep)&1LL;
        
        ll cans1=cans+(1LL<<dep);
        
        if (ok)
        {
            return Get_Ans(node[inx].ch[1^cnt],dep-1,val,bd,cans1,1)+
                   Get_Ans(node[inx].ch[0^cnt],dep-1,val,bd,cans,1);
        }
        else if (!bt) 
        {
            return Get_Ans(node[inx].ch[1^cnt],dep-1,val,bd,cans1,1)+
                   Get_Ans(node[inx].ch[0^cnt],dep-1,val,bd,cans,0);
        }
        else
        {
            return Get_Ans(node[inx].ch[1^cnt],dep-1,val,bd,cans1,0);
        }
    }
    
    int cur[500010];
    ll Solve(ll dep,ll ck,ll val) // OK!!!
    {
//		printf("dep = %lld, ck = %lld, val = %lld\n",dep,ck,val);
        
        if (dep==-1) return val;
        
        ll tot=0;
        for (int i=1;i<=n;i++) 
        {
            bool cnt=(ai[i-1]>>dep)&1LL;
            tot+=node[node[cur[i]].ch[1^cnt]].siz;
        }
//		printf("tot = %lld\n",tot);
        
        if (tot<ck)
        {
            ck-=tot;
            for (int i=1;i<=n;i++) 
            {
                bool cnt=(ai[i-1]>>dep)&1LL;
                cur[i]=node[cur[i]].ch[0^cnt];
            }
            return Solve(dep-1,ck,val);
        }
        else
        {
            for (int i=1;i<=n;i++) 
            {
                bool cnt=(ai[i-1]>>dep)&1LL;
                cur[i]=node[cur[i]].ch[1^cnt];
            }
            return Solve(dep-1,ck,val+(1LL<<dep));
        }
    }
    
    int Count(int inx,ll dep,ll val,ll bd)
    {
        if (!inx) return 0;
        if (dep==-1) return node[inx].siz;
        
        bool bt=(bd>>dep)&1LL;
        bool cnt=(val>>dep)&1LL;
        
        if (!bt) 
        {
            return node[node[inx].ch[1^cnt]].siz+
                   Count(node[inx].ch[0^cnt],dep-1,val,bd);
        }
        else
        {
            return Count(node[inx].ch[1^cnt],dep-1,val,bd);
        }
    }
    
    #undef LCH
    #undef RCH
};

//void DFS_Debug(int inx)
//{
//	using namespace DS;
//	if (node[inx].siz>500000) printf("!!");
//	printf("[%d] -> (%d,%d)\n",inx,node[inx].ch[0],node[inx].ch[1]);
//	printf("siz = %d\n",node[inx].siz);
//	if (node[inx].ch[0]) DFS_Debug(node[inx].ch[0]);
//	if (node[inx].ch[1]) DFS_Debug(node[inx].ch[1]);
//}

int main()
{
    readx(n); readx(k);
    for (int i=1;i<=n;i++) readx(ai[i]);
    for (int i=1;i<=n;i++) ai[i]^=ai[i-1];
    
    DS::Build();
    for (int i=1;i<=n;i++) DS::cur[i]=DS::root[i];
    ll bd=DS::Solve(32,k,0);
    
    ll ki=0;
    for (int i=1;i<=n;i++) ki+=DS::Count(DS::root[i],32,ai[i-1],bd);
    
//	cerr<<"!! BD = "<<bd<<" "<<ki<<endl;
    
    ll ans=0;
    for (int i=1;i<=n;i++)
        ans+=DS::Get_Ans(DS::root[i],32,ai[i-1],bd,0,0);
    
    if (ki>k) ans-=bd*(ki-k);
    cout<<ans<<endl;
}
```

---

## 作者：liuzhangfeiabc (赞：13)

题目大意：给定序列，求前k大的区间异或和。

看到区间的xor，有一个常见的套路是求一次前缀xor和，这样一个区间的xor就可以表示为两个前缀的xor了。

于是问题转化为：给定n+1个数（注意最开头的长度为0的前缀也要算），求两两xor的前k大。

一道经典的问题是求两两xor的最大值是多少，相信大家应该都会这个trie树上贪心的做法：从左往右扫过去，每次看一下这个数与之前的数的xor的最大值是多少，只需要在trie树上贪心地尽可能往相反的方向走即可，在check完这个数之后再把它插入trie。

而这个题要求的是前k大的值，该怎么办呢？

考场上我看到这个前k大，首先想到的是另一道经典题：给定2个数组，求两两之和的前k小值（P1631序列合并）。

这个题很简单：只需要排序后用一个堆来维护，初始时堆中有a数组的每一个数和b数组的最小值的和，每次弹出堆顶时，将a数组对应的数和b数组的下一个数之和插入堆中即可。

同样地，这个题我们也可以用堆来维护：不妨先对于每个右端点，找到与它xor最大的左端点的位置，每次从堆中弹出一个元素时，固定右端点不变，寻找下一个左端点位置即可。

因为我们需要令左端点位置时刻小于右端点位置，就需要对于每个前缀都建一棵trie树，用可持久化trie来维护即可。

每次弹出堆顶时，需要的操作相当于要在trie树上找到与当前值xor第x大的元素，这个操作可以用记录trie树上的每个点的size来实现（类似于平衡树的查找第k大元素吧）。我在考场上写的是简单粗暴地从当前元素开始在trie树上向上跳，直到找到一个分叉之后走进去继续贪心。

时空复杂度都是1个log。

总结：题目难度并不大，作为省选d1t1的温暖题还是很合适的。

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<ctime>
#include<queue>
using namespace std;
#define li long long
#define gc getchar()
#define pc putchar
inline li read(){
	li x = 0,y = 0,c = gc;
	while(c < '0' || c > '9') y = c,c = gc;
	while(c >= '0' && c <= '9') x = x * 10 + c - '0',c = gc;
	return y == '-' ? -x : x;
}
inline void print(li x){
	if(x < 0) pc('-'),x = -x;
	if(x >= 10) print(x / 10);
	pc(x % 10 + '0');
}
inline void file(){
	freopen("xor.in","r",stdin);
	freopen("xor.out","w",stdout);
}
int n,k;
li a[500010],b[500010],as;
#define pii pair<li,int>
#define fi first
#define se second
#define mp make_pair
priority_queue<pii> qu;
int rt[500010],cnt,sz[20000010],son[20000010][2];
inline int ins(int p,li x,int d){
	int q = ++cnt;
	sz[q] = sz[p] + 1;
	if(!d) return q;
	bool nxt = (x >> d - 1) & 1;
	son[q][nxt] = ins(son[p][nxt],x,d - 1);
	son[q][!nxt] = son[p][!nxt];
	return q;
}
int nw[500010],dpt[500010],sl[500010];
bool fx[500010][40];
int jd[500010][40];
li an[500010];
int main(){
	//file();
	int i,j;
	bool nxt;
	n = read();k = read();
	for(i = 1;i <= n;++i) a[i] = read(),b[i + 1] = b[i] ^ a[i];
	//for(i = 1;i <= n + 1;++i) cerr<<b[i]<<" ";cerr<<endl;
	for(i = 1;i <= n + 1;++i) rt[i] = ins(rt[i - 1],b[i],32); 
	//cerr<<n<<" "<<cnt<<endl;
	//return 0;
	for(i = 2;i <= n + 1;++i){
		nw[i] = rt[i - 1];
		jd[i][32] = nw[i];
		for(j = 31;j >= 0;--j){
			nxt = (b[i] >> j) & 1;
			if(son[nw[i]][!nxt]) an[i] += (1ll << j),nw[i] = son[nw[i]][!nxt],fx[i][j] = 1;
			else nw[i] = son[nw[i]][nxt];
			jd[i][j] = nw[i];
		}
		qu.push(mp(an[i],i));
	}
	//return 0;
	for(i = 1;i <= k;++i){
		pii p = qu.top();qu.pop();
		//cerr<<i<<" "<<p.fi<<" "<<p.se<<" "<<(p.fi ^ b[p.se])<<" "<<nw[p.se]<<" "<<sz[nw[p.se]]<<endl;
		//cerr<<p.fi<<endl;
		as += p.fi;
		++sl[p.se];
		if(sz[nw[p.se]] > sl[p.se]) qu.push(p); 
		else{
			j = 0;
			//cerr<<"*"<<endl;
			while(nw[p.se]){
				nw[p.se] = jd[p.se][j + 1];
				//cerr<<j<<" "<<nw[p.se]<<endl;
				if(fx[p.se][j]){
					an[p.se] -= (1ll << j);
					//cerr<<"()"<<endl;
					fx[p.se][j] = 0;
					nxt = (b[p.se] >> j) & 1;
					//cerr<<"()"<<endl;
					if(son[nw[p.se]][nxt]){
						nw[p.se] = son[nw[p.se]][nxt];
						jd[p.se][j] = nw[p.se];
						break;
					}
				} 
				++j;
				
			}
			//cerr<<"&"<<endl;
			if(!nw[p.se]) continue;
			for(--j;j >= 0;--j){
				nxt = (b[p.se] >> j) & 1;
				if(son[nw[p.se]][!nxt]) an[p.se] += (1ll << j),nw[p.se] = son[nw[p.se]][!nxt],fx[p.se][j] = 1;
				else nw[p.se] = son[nw[p.se]][nxt],fx[p.se][j] = 0;
				jd[p.se][j] = nw[p.se];
			}
			qu.push(mp(an[p.se],p.se));sl[p.se] = 0;
		}
	}
	print(as);
	return 0;
}

```

---

## 作者：花里心爱 (赞：10)

[题目链接](https://www.luogu.org/problemnew/show/P5283)

~~没错我是来duliu的~~

当时我在考场上什么都不会，然后连$O(n^2)$的做法都想不出来。**我是真的菜。**

然后这个蒟蒻就在考场上yy了一个复杂度为$O(n\log^2n)$（准确地说应该是$O(k\log n\log a)$）的鬼畜做法，在考场上开`O2` $AC$。

下面我来分享一下我做这道题的解法。

### 算法1

观察到对于$40\%$的数据，$n, k \leq 10^3$，那么我们可以用一个$O(nk\log n)$的做法。

首先你要会做[P2085 最小函数值](https://www.luogu.org/problemnew/show/P2085)

然后我们对整个序列做异或前缀和。然后由于异或的性质，区间$[l, r]$的异或和即为$s[r]\ \operatorname{xor}\ s[l-1]$。（注意此处$s[0] = 0$）

然后我们固定右端点，用一个优先队列来维护对于所有右端点，它和左边某个数异或和的最大值。然后我们循环$k$次，对于取出的右端点，将它所对应的值加入答案。然后我们去找次大值（如果当前对应的是次大值，那么我们就找第$3$大，依此类推）。

至于怎么去找第$k$大，当然是暴力找啊qwq

考虑到我们是依次取出前$k$大，于是我们每次对找到的点打个标记，然后第$k$大就是没打标记的最大值。注意如果全找完了就不要再扔进优先队列里了。

时间复杂度$O(nk\log n)$，空间复杂度$O(n^2)$

期望得分：$40$分

### 算法2

观察到对于$60\%$的数据，$n \leq 10^3$，这时我们暴力把所有区间和扔到一个`vector`里然后排序，取前$k$大，完了。~~比~~$\sout{40}$~~分算法好写多了~~。

时间复杂度$O(n^2\log n)$，空间复杂度$O(n^2)$

期望得分：$60$分

### 算法3

我们注意到上面的算法1，复杂度瓶颈主要在于如何找第$k$大的部分。因此我们要想办法优化找第$k$大的复杂度。

然后异或问题可以用`01trie`解决。我们现在固定右端点，查询左边的数与右端点异或的最大值，这需要可持久化`01trie`。

用可持久化`01trie`求最大异或值的思路是**贪心**。我们从高位向低位对这个数的二进制插入`trie`里。我们询问的时候带一个参数`x`，在`trie`上从高位向低位走，如果`x`在这一位的值为`c`，那么我们看当前点`c xor 1`能不能走（能走就走）。

然后这里如果要求第$k$大的话可以记录每个子树的`size`，用类似平衡树求第$k$大的方法做，时空复杂度都是$n\log n$的。但我在考场上想不出来qwq

我们还是**考虑上面算法1的思路**。我们将一个数取出后，如果我们将这个数删掉（或者打标记），那么剩下的最大值就是原来的次大值。

当然由于可持久化的东西是共用空间的，我们并不能直接删点，那么我们对于每个右端点分别记录哪个点有没有走过。显然直接开数组空间复杂度会爆炸，那么我们对每个右端点，开一个`set`表示已经走过的点的集合。

然后我们考虑怎么维护这个`set`。我们贪心的分界点就是**在trie上两边都可以走的位置**。于是我们在每次取出一个值后，回溯走过的点，找到第一个分界点，将它下面的我们刚才走过的点打上标记。这样下一次询问时我们就需要走另一边了。

然后我们就可以~~愉快地~~写代码了。

写完后我们就会发现它实际上跑大样例会WA掉……

然后我们就会发现我们没有考虑在`trie`里有重复值的情况。我们直接打了标记，相当于对`trie`里的元素自动去了重。

于是我们对于每个`trie`上的叶子节点，记录一个`val`，表示这个点上有多少重复的数。然后对于每个右端点，我们开一个`map`，记录对于当前的右端点，这个数取了多少次。当全部取完后，我们就可以用上面的方法打标记了。

时间复杂度$O(n\log^2 n)$，空间复杂度$O(n\log n)$

期望得分：$100$分（需要开`O2`，不然过不了qwq）

实现细节还是很多的，~~以致于我在考后一直以为自己写挂了~~qwq

然后还有一点，**三年OI一场空，不开 long long 见祖宗**

下面放代码：
```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
#include <queue>
#include <set>
#include <map>
#define maxn 500005
typedef long long ll;
inline ll read() {
    ll d=0;char ch=getchar();while(!isdigit(ch))ch=getchar();
    while(isdigit(ch)){d=d*10+ch-48,ch=getchar();}return d;
}

int n, k;
ll a[maxn]; // a是原数列的前缀和
std::set<int> vis[maxn]; // 对每个右端点开一个set，记录在询问的这个右端点下，每个点能不能走
std::map<int, int> cocnt[maxn]; // 对每个右端点开一个map，记录在询问的这个右端点下，每个叶子取出了多少次
std::priority_queue< std::pair<ll, int> > q; // 维护的是权值和位置

namespace trie {
    int rt[maxn], cnt;
    int ch[maxn*34][2], val[maxn*34];
    
    void ins(ll x, int& pos, int lst) {
        // 正常地插入
        if(!pos) pos = ++cnt;
        int now = pos;
        for(int i = 32; i >= 0; --i) {
            int c = (x>>i)&1;
            if(!ch[now][c]) ch[now][c] = ++cnt;
            ch[now][c^1] = ch[lst][c^1];
            now = ch[now][c], lst = ch[lst][c];
        }
        val[now] = val[lst]+1; // 记录每个叶子插入了多少次
    }
    
    int stk[45], tots;
    
    ll query(ll x, int pos, int rps) {
        int now = pos;
        ll ans = 0;
        stk[tots = 1] = now;
        for(int i = 32; i >= 0; --i) {
            int c = (x>>i)&1;
            if(ch[now][c^1] && !vis[rps].count(ch[now][c^1])) now = ch[now][c^1], ans |= (1ll<<i); // 可以走相反的位置
            else if(ch[now][c] && !vis[rps].count(ch[now][c])) now = ch[now][c];
            else return -1; // 走不了，说明我们已经取完对应右端点所有的数了
            stk[++tots] = now;
        }
        
        // 每个点上可能有多个相等的数
        if(val[now]-cocnt[rps][now] > 1) {
            ++cocnt[rps][now];
            return ans;
        }
        
        // 当前节点的数取完了，打标记
        for(; tots; --tots) {
            if(ch[stk[tots]][0] && !vis[rps].count(ch[stk[tots]][0]) && ch[stk[tots]][1] && !vis[rps].count(ch[stk[tots]][1])) {
                // 找到分支点了
                vis[rps].insert(stk[tots+1]);
                break;
            }
        }
        // 找不到分支点，也说明我们已经将当前右端点对应的数取完了。
        // 直接对我们向下走的第1个节点（算上根是第2个）打标记即可。
        if(!tots) vis[rps].insert(stk[2]);
        return ans;
    }
}

std::pair<ll, int> tp;
ll fin = 0;

int main() {
    n = read(), k = read();
    for(int i = 1; i <= n; ++i)
        a[i] = read()^a[i-1];
    trie::ins(0, trie::rt[0], 0); // 注意a[0] = 0也是前缀和的一部分
    for(int i = 1; i <= n; ++i)
        trie::ins(a[i], trie::rt[i], trie::rt[i-1]);
    
    for(int i = 1; i <= n; ++i) {
        ll res = trie::query(a[i], trie::rt[i-1], i);
        q.push(std::make_pair(res, i));
    }
    for(int i = 1; i <= k; ++i) {
        tp = q.top(); q.pop();
        fin += tp.first;
        ll res = trie::query(a[tp.second], trie::rt[tp.second-1], tp.second);
        if(res != -1) q.push(std::make_pair(res, tp.second)); // 注意判断取完的情况
    }
    printf("%lld", fin);
    return 0;
}
```

---

## 作者：Nemlit (赞：8)

## [原文地址](https://www.cnblogs.com/bcoier/p/10788524.html)

### 前置芝士：[可持久化Trie](https://www.luogu.org/problemnew/show/P4735) & [堆](https://www.luogu.org/problemnew/show/P2048)

类似于超级钢琴，我们用堆维护一个四元组$(st, l, r, pos)$表示以$st$为起点，终点在$[l, r]$内，里面的最大值的位置为$pos$

我们维护一个小根堆（堆顶最大），权值为st-pos的异或和，每一次找出最大的并删掉

所谓删，就是把一个区间从pos处分裂

即：$(st, l, r)->(st, l, pos - 1) (st, pos + 1, r)$

这样重新维护pos值即可

维护pos值时，我们需要维护区间内与x的异或值最大，不难想到可持久化$Trie$，~~于是只需要把超级钢琴中的$RMQ$变成可持久化$Trie$即可~~



```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define debug printf("Now is Line : %d\n",__LINE__)
#define file(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define ll long long
il ll read() {
    re ll x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define maxn 500005
int n, m;
ll sum[maxn], ans;
namespace Trie {
	struct PAX {
		int id, s, ch[2];
	}e[maxn * 50];
	int cnt, rt[maxn];
	il void insert(int&k, int kk, int bit, int id, ll val) {
		k = ++ cnt;
		e[k] = e[kk], ++ e[k].s;
		if(bit == -1) return(void)(e[k].id = id);
		int c = (val >> bit) & 1;
		insert(e[k].ch[c], e[kk].ch[c], bit - 1, id, val); 
	}
	il int query(int l, int r, int bit, ll val) {
		if(bit == -1) return e[r].id;
		int c = (val >> bit) & 1;
		if(e[e[r].ch[c ^ 1]].s > e[e[l].ch[c ^ 1]].s) 
			return query(e[l].ch[c ^ 1], e[r].ch[c ^ 1], bit - 1, val);
		return query(e[l].ch[c], e[r].ch[c], bit - 1, val);
	}
}
using namespace Trie;
struct node {
	int st, l, r, pos;
	il bool operator < (const node a) const {
		return (sum[pos] ^ sum[st - 1]) < (sum[a.pos] ^ sum[a.st - 1]);
	}
	node(int St, int L, int R) {
		st = St, l = L, r = R, pos = query(rt[l - 1], rt[r], 32, sum[st - 1]);
	}
};
priority_queue<node>q;
signed main() {
	file(a);
	n = read(), m = read();
	rep(i, 1, n) sum[i] = sum[i - 1] ^ read();
	rep(i, 1, n) insert(rt[i], rt[i - 1], 32, i, sum[i]);
	rep(i, 1, n) q.push(node(i, i, n));
	while(m --) {
		node t = q.top(); q.pop();
		ans += sum[t.pos] ^ sum[t.st - 1];
		if(t.l < t.pos) q.push(node(t.st, t.l, t.pos - 1));
		if(t.pos < t.r) q.push(node(t.st, t.pos + 1, t.r));
	}
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：tzytzytjx (赞：8)

~~那么多可持久化Trie看得人晕晕的~~
所以我就来一发**朴素Trie**吧。

显然先搞一个异或前缀和，那么问题变成了求一个序列两两异或值前k大的和。
**直接建Trie**,然后分为两种情况:

1. 异或结果在这一位上是1的数对数sum大于等于k，那么直接令这一位等于1
1. 异或结果在这一位上是0的数对数sum小于k，那么这一位上是1的数全部被计入答案，剩下的令这一位是0

在Trie上跑的时候，维护一些数对<A,B>就行了
```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(3)
#define pb(a) push_back(a)
#define mp(a,b) make_pair(a,b)
#define mem(a,b) memset(a,b,sizeof(a))
#define N 500005
using namespace std;

typedef unsigned int uint;
typedef long long LL;

int n,m,i,j,k,cnt;
uint a[N];
struct node{
    int s[2],cnt;
    node(){s[0]=s[1]=cnt=0;}
} tr[N*32];//这里千万不要忘了乘32

#define root 0
void build(int u,uint x,uint t){
    tr[u].cnt++;
    bool f=t&x;
    if (!t) return;
    if (!tr[u].s[f]){
        tr[u].s[f]=++cnt;
        build(cnt,x,t>>1);
    }
    else build(tr[u].s[f],x,t>>1);
}

LL ans=0;
vector<int> A,B;
void dfs(int dep,int remain,uint now){
    if (dep==32 || remain==0) {ans+=1ll*now*remain; return;}
    LL sum1=0;
    for (int i=0; i<A.size(); i++)
        sum1+=(1ll*tr[tr[A[i]].s[0]].cnt*tr[tr[B[i]].s[1]].cnt + 1ll*tr[tr[A[i]].s[1]].cnt*tr[tr[B[i]].s[0]].cnt)/((A[i]==B[i])?2:1);

    if (sum1<remain){
        vector<int> tA=A,tB=B;
        A.clear(), B.clear();
        for (int i=0; i<tA.size(); i++)//1
        {
            if (tr[tA[i]].s[0] && tr[tB[i]].s[1])
                A.pb(tr[tA[i]].s[0]), B.pb(tr[tB[i]].s[1]);
            if (tA[i]==tB[i]) continue;// Warning!
            if (tr[tA[i]].s[1] && tr[tB[i]].s[0])
                A.pb(tr[tA[i]].s[1]), B.pb(tr[tB[i]].s[0]);
        }
        dfs(dep+1,sum1,now|(1ll<<31-dep));

        A.clear(), B.clear();
        for (int i=0; i<tA.size(); i++)//0
        {
            if (tr[tA[i]].s[1] && tr[tB[i]].s[1])
                A.pb(tr[tA[i]].s[1]), B.pb(tr[tB[i]].s[1]);
            if (tr[tA[i]].s[0] && tr[tB[i]].s[0])
                A.pb(tr[tA[i]].s[0]), B.pb(tr[tB[i]].s[0]);
        }
        dfs(dep+1,remain-sum1,now);
    }
    else{
        vector<int> tA=A,tB=B;
        A.clear(), B.clear();
        for (int i=0; i<tA.size(); i++)//1
        {
            if (tr[tA[i]].s[0] && tr[tB[i]].s[1])
                A.pb(tr[tA[i]].s[0]), B.pb(tr[tB[i]].s[1]);
            if (tA[i]==tB[i]) continue;// Warning!
            if (tr[tA[i]].s[1] && tr[tB[i]].s[0])
                A.pb(tr[tA[i]].s[1]), B.pb(tr[tB[i]].s[0]);
        }
        dfs(dep+1,remain,now|(1ll<<31-dep));
    }
}
int main()
{
    cin>>n>>k;
    for (i=1; i<=n; i++)
        cin>>a[i], a[i]^=a[i-1];
    for (i=0; i<=n; i++)
        build(root,a[i],1ll<<31);

    tr[0].cnt=0;
    A.pb(0),B.pb(0), dfs(0,k,0);
    cout<<ans;
}
```


---

## 作者：GKxx (赞：6)

好吧，其实是个套路题。

这种选k大的，有一种套路就是用堆维护，连续取k个，一边取一边加入新的。跟那个给你几个数组求k大和的很像。

考虑暴力：首先$s_i$为异或前缀和这大家肯定都会，$O(n^2)$枚举区间，加进堆里或者放数组里最后排序，取前$k$大即可。

我们考虑一个优化：我们在枚举区间$[l,r]$这一步，可以只枚举一个右端点$r$，然后在$[0,r-1]$上找到一个与$s_r$异或值最大的$s_l$，那么$s_l\ xor\ s_r$即为$[1,r]$上的最大异或和（第$1$大异或和）。这样我们就把$n$个前缀最大异或和加进了堆里。

然后我们从堆中连续取$k$次，当取出一个元素时，首先把它加入答案，然后假设它是所在前缀的第$rank$大异或和，我们只要查询那个前缀的第$rank+1$大异或和，加入堆里即可。

不难发现我们需要用堆维护三元组$(pos, rank, so)$，分别表示所在前缀，第几大，异或和是多少。

剩下的问题就是，查询一个前缀的$K$大异或和，这就是可持久化01Trie模板题了。

**代码千万条，long long第一条。忘记开long long，爆零两行泪。**

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>
#include <queue>
#include <vector>

template <typename T> inline void read(T& x) {
    int f = 0, c = getchar(); x = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) x = x * 10 + c - 48, c = getchar();
    if (f) x = -x;
}
template <typename T, typename... Args>
inline void read(T& x, Args&... args) {
    read(x); read(args...); 
}
template <typename T> void write(T x) {
    if (x < 0) x = -x, putchar('-');
    if (x > 9) write(x / 10);
    putchar(x % 10 + 48);
}
template <typename T> inline void writeln(T x) { write(x); puts(""); }
template <typename T> inline bool chkmin(T& x, const T& y) { return y < x ? (x = y, true) : false; }
template <typename T> inline bool chkmax(T& x, const T& y) { return x < y ? (x = y, true) : false; }

typedef long long LL;

const int maxn = 5e5 + 207;

struct HeapNode {
    int pos, rk;
    LL so;
    HeapNode() : pos(0), rk(0), so(0) {}
    HeapNode(int a, int b, LL c) : pos(a), rk(b), so(c) {}
};
inline bool operator<(const HeapNode &lhs, const HeapNode &rhs) {
    return lhs.so < rhs.so;
}
std::priority_queue<HeapNode> heap;
LL a[maxn], s[maxn];
int n, K;

struct Node {
    int ch[2], sum;
};
Node T[maxn << 6];
int root[maxn], tot;

void insert(int &o, LL x, int i) {
    T[++tot] = T[o]; ++T[o = tot].sum;
    if (i < 0) return;
    int j = (x >> i) & 1;
    insert(T[o].ch[j], x, i - 1);
}
LL query(int o, LL x, int k, int i) {
    if (i < 0) return 0;
    int j = (x >> i) & 1;
    int s = T[T[o].ch[j ^ 1]].sum;
    if (k <= s) return (1ll << i) + query(T[o].ch[j ^ 1], x, k, i - 1);
    else return query(T[o].ch[j], x, k - s, i - 1);
}

int main() {
    read(n, K);
    for (int i = 1; i <= n; ++i) {
        read(a[i]);
        s[i] = s[i - 1] ^ a[i];
        insert(root[i] = root[i - 1], s[i - 1], 32);
    }
    for (int i = 1; i <= n; ++i)
        heap.emplace(i, 1, query(root[i], s[i], 1, 32));
    LL ans = 0;
    for (int i = 1; i <= K; ++i) {
        auto one = heap.top(); heap.pop();
        ans += one.so;
        if (one.rk <= one.pos)
            heap.emplace(one.pos, one.rk + 1, query(root[one.pos], s[one.pos], one.rk + 1, 32));
    }
    writeln(ans);
    return 0;
}
```

我也不知道为什么我写的这么慢，开了O2才过。幸好比赛的时候的确开O2。可是这跟我有什么关系呢...我又没在考场上做出来

数组不要开小

---

## 作者：Treaker (赞：5)

$$\color{cornflowerblue}{\mathcal{Treaker}}$$
## 可持久化01   Trie 树  and 堆
~~省选的悲惨历史不提了~~

还有此题有些卡常。

这道题题面中有异或操作，一般都是和Trie树有关~~感觉都是用Trie树做的~~

对于这道题，让我们求前k大的区间（不重复）异或和的和（题面说的很清楚，可能又被我说糊涂了。。。）

我们考虑每段区间，必定会有一个右端点~~废话~~，那么我们就可以根据这个来维护了（？？？）。

我们再考虑一个堆，那么我们对于每个右端点，对应的取出一段区间使这个区间的异或和是以这个点为右端点的所有区间中最大的，打包成（把什么打包呢？，下面讲）一个结构体放入堆中。

把什么打包呢？显然要有异或和最大值，最开始的右端点，在哪个点取得了最大值，取得最大值所在点的区间左右端点，这是一个五元组，打包成结构体。
```cpp
struct zz
{
	int t , l , r , pos; unsigned int val;
	friend bool operator < (const zz & a,const zz & b) {return a.val < b.val;}
};
```

```cpp
cnt = query(root[i-1],a[i],31,0);
q.push((zz){i,1,i,cnt,a[i] ^ a[cnt]});
```

从堆中取出一个堆顶，那么我们就要把这个区间分裂，从我们取出最大值的那个点再分层两段区间，压入堆中。

完整代码如下：

```cpp
#include <cstdio>
#include <queue>
#define RI register int
using namespace std;
const int N = 500005;
inline unsigned int read()
{
    unsigned int x = 0 ;  char ch = getchar();
    while(ch < '0' || ch > '9') { ch = getchar();}
    while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
    return x;
}
int n , k , cnt;
unsigned int a[N];
long long ans;
struct Persistent_Trie
{
	struct node
	{
		node *ch[2]; int lt;
		node() {ch[0]=ch[1]=NULL;lt = 0;}
	}*root[N] , pool[N * 36] , *tail;
	Persistent_Trie(){tail = pool;}
	void build(register node *&p,RI dep)
	{
		p = new (tail ++)node();
		if(dep < 0)	return;
		build(p -> ch[0],dep-1);
	}
	void insert(register node *&p,register node *o,RI i,RI dep)
	{
		p = new (tail ++)node();
		if(o) *p = *o;
		if(dep < 0)	return (void)(p -> lt = i);
		register bool tmp = (a[i] >> dep) & 1;
		if(tmp)	insert(p -> ch[1],o ? o -> ch[1] : NULL,i,dep - 1);
		else insert(p -> ch[0],o ? o -> ch[0] : NULL,i,dep - 1);
		if(p -> ch[0]) p -> lt = max(p -> lt,p -> ch[0] -> lt);
		if(p -> ch[1]) p -> lt = max(p -> lt,p -> ch[1] -> lt);
	}
	int query(register node *p,register unsigned int x,RI dep,RI limit)
	{
		if(dep < 0)	return p -> lt;
		register bool tmp = (x >> dep) & 1;
		if(p -> ch[tmp ^ 1] && p -> ch[tmp ^ 1] -> lt >= limit)	return query(p -> ch[tmp ^ 1],x,dep-1,limit);
		return query(p -> ch[tmp],x,dep - 1,limit);
	}
	struct zz
	{
		int t , l , r , pos; unsigned int val;
		friend bool operator < (const zz & a,const zz & b) {return a.val < b.val;}
	};
	priority_queue<zz> q;
	inline void LOL()
	{
		n = read(); k = read();
		build(root[0],31);
		RI i;
		for(i = 1;i <= n;i ++)
		{
			a[i] = a[i-1] ^ read();
			insert(root[i],root[i-1],i,31);
			cnt = query(root[i-1],a[i],31,0);
			q.push((zz){i,1,i,cnt,a[i] ^ a[cnt]});
		}
		zz res;
		for(i = 1;i <= k;i ++)
		{
			res = q.top();
			ans += (long long)res.val;
			q.pop();
			if(res.pos + 1 < res.r)
			{
				cnt = query(root[res.r-1],a[res.t],31,res.pos+1);
				q.push((zz){res.t,res.pos+2,res.r,cnt,a[res.t] ^ a[cnt]});
			}
			if(res.l < res.pos + 1)
			{
				cnt = query(root[res.pos-1],a[res.t],31,res.l-1);
				q.push((zz){res.t,res.l,res.pos,cnt,a[res.t] ^ a[cnt]});
			}
		}
		printf("%lld\n",ans);
	}
}DNF;
int main()
{
	DNF.LOL();
	return 0;
}

```


---

## 作者：chdy (赞：3)

~~为了估值~~ 不为了给社区做贡献。

这道题建模还是很简单的。
问题很容易被我们利用前缀和异或转换成区间内两个数字的异或最大值。

因为异或具有自反性：A^A=0;

先考虑如何求的最大值？显然我们一边建trie树一边进行树上查询就能求的最大值将其二进制拆分后一直跑反向边即可。

建trie树很简单我们接下来是要求前k大值这个有点不好搞，因为我们求完第一大，第二大并不是那么容易找，类型是有串通性的如果写过背包的第k优解的话这个问题可能很好解决。第二大其实是 由其他数字的匹配 或者第一大的那个数字又找了一个。

这个并不是很容易维护的 但是全放到堆里就很容易解决了。

至于不断查找 第k大这个操作有点难度 我们每个数字只能和前面的一些数字进行匹配。所以 具有区间性且需要求第k大 显然 主席树啊。

结合trie树就是可持久化trie了。至于查找第k的的一些细节我认为有三点：

1  注意a[i]本身要放到堆里或者多建一个全是0的树root[0]

2  注意当一个值找不到还能用的值的话记得特判（很难出现这种情况）

3  注意一些不必要的可简化的东西要简化 注意卡常 能开o2省选都开o2了！


下面是我的code：
```cpp
// luogu-judger-enable-o2
//#include<bits/stdc++.h>
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstring>
#include<string>
#include<ctime>
#include<cstdlib>
#include<cctype>
#include<queue>
#include<deque>
#include<stack>
#include<algorithm>
#include<vector>
#include<utility>
#include<set>
#include<bitset>
#include<map>
#include<cmath>
#define ll long long
#define R register
using namespace std;
char buf[1<<16],*fs,*ft;
inline char getc()
{
    return (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),fs==ft))?0:*fs++;
}
inline ll read()
{
    ll x=0,f=1;char ch=getc();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getc();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getc();}
    return x*f;
}
inline void put(ll x)
{
    x<0?putchar('-'),x=-x:0;
    ll num=0;char ch[70];
    while(x)ch[++num]=x%10+'0',x/=10;
    num==0?putchar('0'):0;
    while(num)putchar(ch[num--]);
    putchar('\n');return;
}
const ll MAXN=500010,maxn=35;
ll n,k,ans,cnt,sum;
ll w[MAXN];
int root[MAXN],rank[MAXN];
int trie[MAXN*maxn][2],sz[MAXN*maxn];
priority_queue<pair<ll,int> > b;
inline void insert(int &now,int last,int depth,ll x)
{
    if(!now)now=++cnt;
    if(depth==0)
    {
        sz[now]++;
        sz[now]+=sz[last];
        return;
    }
    int tn=(x>>(depth-1))&1;
    trie[now][tn^1]=trie[last][tn^1];
    insert(trie[now][tn],trie[last][tn],depth-1,x);
    sz[now]=sz[trie[now][tn]]+sz[trie[now][tn^1]];
    return;
}
inline void find(int now,int k,int depth,ll x)
{
    //if((!trie[now][0])&&(!trie[now][1]))return;
    if(depth==0)return;
    ll tn=(x>>(depth-1))&1;
    if(sz[trie[now][tn^1]]>=k)
    {
        ans=(ans<<1)|1;
        find(trie[now][tn^1],k,depth-1,x);
    }
    else 
    {
        ans=ans<<1;
        find(trie[now][tn],k-sz[trie[now][tn^1]],depth-1,x);
    }
    return;
}
int main()
{
    //freopen("1.in","r",stdin);
    n=read();k=read();
    for(R int i=1;i<=n;++i)
    {
        ll x=read();
        rank[i]=1;
        w[i]=(x^w[i-1]);
    }
    insert(root[0],root[0],33,0);
    for(R int i=1;i<=n;++i)insert(root[i],root[i-1],33,w[i]);
    for(R int i=1;i<=n;++i)
    {
        ans=0;
        find(root[i],rank[i],33,w[i]);
        ++rank[i];
        b.push(make_pair(ans,i));
        //put(ans);
    }
    for(R int i=1;i<=k;++i)
    {
        int l=b.top().second;
        ll z=b.top().first;
        b.pop();sum+=z;//put(z);
        ans=0;
        find(root[l],rank[l],33,w[l]);
        ++rank[l];
        b.push(make_pair(ans,l));
    }
    put(sum);
    return 0;
}

```
我觉得很清晰了 如果有错误请指正,蟹蟹。

---

## 作者：_虹_ (赞：3)

这里给出一个考场**玄学**做法。

首先我们~~可以看出这题可持久化01trie可做~~。

然后我们可以发现对于答案中的每个区间，~~它必然有一个右端点（废话）~~

既然每个答案有一个右端点，那么我们只要能对所有可行的右端点，得到可行的最大区间异或和就行了。

把序列弄成前缀异或和，当trie树深度为d时，这可以O(nd)搞出来，O(nlogn)塞进堆里。

当我们弹出一个区间和时，对于这个右端点，它的答案需要更新成次大的区间异或和。

这很明显可以通过trie树节点上记录size，直接求第k大搞定。

~~但是其实可以不这么做。~~

当在trie树上找最大异或值时，其实就是贪心在搜索树上找到一条链的过程。

但是这里的贪心和一般的贪心不同，很明显，每层只有两个决策，并且在树深度较深处转向，比更浅处更优。

~~这不就是dfs的回溯吗~~

所以我们可以开一个n * d的二维数组作为堆栈。每在堆中取出一个区间异或和，我们就对对应的右端点回溯。

但是看这个数据：3 2 2 ...

它的异或前缀和是：3 1 3 ...

这个3，在异或前缀和里出现了不止一次，但对于trie树，它只出现了一次，如果对于某个右端点，3需要对答案提供不止一次的贡献，喜提Wa。（~~大样例都过不去但是可以80分）~~

~~好办，维护计数器~~

### MLE

为啥会mle呢，因为这个做法需要保留对于每个右端点，取答案时trie树上走的路径。算上堆栈，就相当于是开了1颗半可持久化trie。

而且还要记录路径上每个节点走过方向，又是一个2nd大小的bool数组。

如果给trie树维护计数器，那么内存又会增加4 * n * d/1024/1024≈123MB。加上之前那些乱七八糟的东西和系统栈，内存十分爆炸，~~1G刚好不够。~~

~~凉凉？~~    ~~不，强行续命！~~

我们可以发现这个做法并不需要维护节点的子树size，只需要对叶子结点维护计数器，而叶子节点没有左右儿子，这不是明显可以 一**var**多用。

如果是数组写的trie树，那么题已经做完了。

~~指针只能凉凉？~~ ~~其实还能再续。~~

虽然在c++（或者说oi版c++）中，变量是有类型的，但是我们还有强制类型转换！反正都是一段内存，而且指针保存的东西本质上就是个作为偏移量的整数，怎么不能当计数器？

(int)p->son[0]=1;//ce

貌似强制类型转换返回的是常量，不能做左值。~~所以还是凉凉？~~

这个东西其实是可以绕过去的。

我们可以把它写成这样* (int*)(&p->son[0])=1;

这样(int*)(&p->son[0])是一个指向变量的常量指针，指向的变量是(p->son[0])（当做int处理），这不就可以做修改了吗。

然后就可以 ~~写出来ac代码~~ 强行续命80分代码了。

时间复杂度考虑trie树深度应该是O(nd+mlogn+(m-n)d),本题d=64.

跑的奇慢，交之前或许需要洗把脸。

```cpp
// luogu-judger-enable-o2
//01trie
#include <cstdio>
#include <queue>
#include <algorithm>
using namespace std;
#define reg register
typedef long long vt;
const int kmaxn = 500000 + 5;
const int kmaxd = 65;//64//<< 0-63
const int kmaxs = 62 * 500000;
struct node
{
    node* son[2]={nullptr,nullptr};
};
node mempool[kmaxs];
int mpt;
node* root[kmaxn];
node* stk[kmaxn][kmaxd];
bool hsh[kmaxn][kmaxd][2];
short st[kmaxn];
int n, k;
vt arr[kmaxn];
inline node* alloc_node()
{
    return mpt<kmaxs ? &mempool[mpt++] : new node;
}
void insert(node* lp, node*& p, vt v, int pos = 62)
{
    p = alloc_node();
    if (lp)*p = *lp;
    if (pos<0) {
        *(int*)(&(p->son[0])) = *(int*)(&(p->son[0]))+1;
        //*(int*)(&p->son[0])=1;
        //    	cout<<(int)p->son[0]<<endl;
        return;
    }
    bool b = (v)&(((vt)1) << pos);
    insert((lp ? lp->son[b] : nullptr), p->son[b], v, pos - 1);
}
vt init(node* p, vt v, int num, int pos = 62)
{
    stk[num][++st[num]] = p;
    if (pos<0)return 0;
    bool b = !((v)&(((vt)1) << pos));
    if (p->son[b])
    {
        hsh[num][pos][b] = true;
        return (((vt)1) << pos) + init(p->son[b], v, num, pos - 1);
    }
    else {
        hsh[num][pos][!b] = true;
        return init(p->son[!b], v, num, pos - 1);
    }
}
//priority_queue<pair<vt,int>> q;
struct unit {
    vt v;
    int cnt, pos;
    unit(vt _v = 0, int c = 0, int p = 0) :v(_v), cnt(c), pos(p) {
    };
    inline const bool operator<(const unit& u)const {
        return v<u.v;
    }
};
/*class pq{
public:
unit u[kmaxn];
int len=0;
inline void push(const unit& v)
{
u[len++]=v;
push_heap(u,u+len);
}
inline unit pop()
{
pop_heap(u,u+len);
return u[--len];
}
}q;*/
priority_queue<unit> q;
int dfs(int pos, vt v, vt& ans)
{
    short& tail = st[pos];
    reg bool dir = false;
    reg bool b = false;
    reg int dp = 0;
    while (tail>1)
    {
        dir = (stk[pos][tail - 1]->son[1] == stk[pos][tail]);
        dp = 63 - (--tail);
        b = (v)&(((vt)1) << (dp));
        if (b != dir)
            ans -= (((vt)1) << (dp));
        dir = !dir;
        if (!hsh[pos][dp][dir] && stk[pos][tail]->son[dir])//find
        {
            break;
        }
        hsh[pos][dp][0] = hsh[pos][dp][1] = 0;
    }
    while (tail<64)//9223372032559812379
    {
        dp = 63 - tail;
        dir = !((v)&(((vt)1) << dp));
        if (stk[pos][tail]->son[dir] && !hsh[pos][dp][dir])//have and can turn
        {
            ans += (((vt)1) << (dp));
        }
        else
        {
            dir = !dir;
        }
        hsh[pos][dp][dir] = true;
        stk[pos][tail + 1] = stk[pos][tail]->son[dir];
        ++tail;
    }
    return *(int*)(&(stk[pos][tail]->son[0]));
}
inline void solve()
{
    unsigned long long ans = 0;
    reg int pos = 0;
    reg int c = 0;
    vt t = -1;
    unit temp;
    while (k)
    {
//		printf("k %d\n", k);
        //temp=q.pop();
        temp = q.top();
        q.pop();
        t = temp.v;
        c = min(temp.cnt, k);
        k -= c;
        pos = temp.pos;
        ans += t*c;
        c = dfs(pos, arr[pos], t);
        if (t >= 0)
            q.push(unit(t, c, pos));
        t = -1;
    }
    printf("%lld\n", ans);
}
int main()
{
//	freopen("xor19.in", "r", stdin);
    scanf("%d%d", &n, &k);
//	printf("%d	%d\n", n, k);
    insert(nullptr, root[0], 0);
    vt t=0;
    for (reg int i = 1; i <= n; ++i)
    {
        //cin>>arr[i];
        scanf("%lld", &arr[i]);
        arr[i] ^= arr[i - 1];
        insert(root[i - 1], root[i], arr[i]);
        t = init(root[i], arr[i], i);
//		printf("%d	cnt	%d\n", i, *(int*)(void*)(&(stk[i][64]->son[0])));
        q.push(unit(t, *(int*)(&(stk[i][64]->son[0])), i));
    }
    solve();
//	while (1);
    return 0;
}
```


~~幸好考场上死也没想出来需要维护计数器，否则MLE 80变60就很惨了（80变0更惨）~~

---

## 作者：mrsrz (赞：3)

来个复杂度假假的$O(n\log^2 n+k)$算法。

首先考虑前缀异或和，转化为选$k$对数使得异或和的和最大。

把数塞进Trie里，每个节点存这个节点包含的所有数（用链式前向星存）。

然后，我们一层一层遍历Trie树的节点，同时确定出第$k$大的异或和是多少。

假设我们考虑到第$i$位，我们扫一遍Trie数上这一层（存在）的节点，然后尽可能贪心地让这一位为1。对于状态$w$，我们可以方便地计算出满足$w\oplus s$的前面几位都最大，且第$i$位为1的状态$s$。用乘法原理和加法原理就可以算出满足前面条件下，第$i$位为1的方案数。

如果方案数大于等于当前的$k$，则第$k$大的异或和的第$i$位就是1，继续考虑下一层即可。

否则，我们可以知道，第$k$大的异或和的第$i$位为0，而刚刚计算的所有方案都排在第$k$大之前。那么我们暴力遍历每个Trie节点包含的数以及其对应状态节点包含的数，把它们的异或和加入答案里即可。然后$k$减去方案数，往下一层找。

上面的过程和主席树找第$k$大是类似的。

找到第$k$大后，把剩下的$k'$个数的贡献加上即可（此时剩下的一定都和第$k$大值相同）。

一个问题：怎么找一个节点对应状态的节点的编号？

用vector把每层有的节点记录下来，并按照状态大小排序，每次找的时候在vector上二分即可。

由于Trie树上节点个数为$O(n\log n)$级别，排序/二分查找又多一个$O(\log n)$。所以遍历复杂度$O(n\log^2 n)$。

~~感觉很不可过的样子~~

事实上，Trie树的$O(\log n)$和vector的$O(\log n)$，常数都比较小。即这个算法的常数比较优秀。

加点特技卡卡常即可。貌似跑得比某些一个$\log$的大常数算法快？

~~大样例跑了1.9s慌慌慌~~

~~原来用map代替vector，用vector代替前向星，大样例跑14s~~

## Code：
```cpp
#include<cstdio>
#include<cctype>
#include<vector>
#include<algorithm>
typedef unsigned uint;
typedef long long LL;
typedef unsigned long long ULL;
const int N=500005;
char ss[(int)1e7],*buf=ss;
inline void init(){
    fread(ss,1,(int)1e7-1,stdin);
    fclose(stdin);
}
inline uint readuint(){
    uint d=0;
    while(!isdigit(*buf))++buf;
    while(isdigit(*buf))d=d*10+(*buf++^'0');
    return d;
}
int n,k;
uint to[N*32],a[N];
std::vector<ULL>mp[32];
int ch[N*32][2],cnt,sz[N*32],head[N*32],nxt[N*32],tt=0;
LL ans=0;
inline void insert(uint s){
    for(int i=31,nw=0;~i;--i){
        int wg=s>>i&1;
        if(!ch[nw][wg]){
            ch[nw][wg]=++cnt;
            mp[i].push_back((ULL)(s&(-(1u<<i)))<<32|cnt);
        }
        nw=ch[nw][wg];++sz[nw];
        to[++tt]=s,nxt[tt]=head[nw],head[nw]=tt;
    }
}
int main(){
    init();
    n=readuint(),k=readuint();insert(0);
    for(int i=1;i<=n;++i)insert(a[i]=readuint()^a[i-1]);
    uint nb=0;
    for(int i=31;~i;--i){
        mp[i].push_back(18446744073709551615);
        std::sort(mp[i].begin(),mp[i].end());
        LL tot=0;
        for(ULL p:mp[i]){
            const uint it=p>>32,iit=(nb|(1u<<i))^it;
            if(p==18446744073709551615||it>=iit)break;
            auto t=std::lower_bound(mp[i].begin(),mp[i].end(),(ULL)iit<<32);
            if(*t>>32==iit)tot+=(LL)sz[(int)p]*sz[(int)*t];
        }
        if(tot>=k)nb|=1<<i;else{
            for(auto p:mp[i]){
                const uint it=p>>32,iit=(nb|(1u<<i))^it;
                if(p==18446744073709551615||it>=iit)break;
                auto t=std::lower_bound(mp[i].begin(),mp[i].end(),(ULL)iit<<32);
                if(*t>>32==iit){
                    for(int x=head[(int)p];x;x=nxt[x])
                    for(int y=head[(int)*t];y;y=nxt[y])
                    ans+=to[x]^to[y];
                }
            }
            k-=tot;
        }
    }
    ans+=(LL)nb*k;
    printf("%lld\n",ans);
    return 0;
}

```

---

## 作者：FZzzz (赞：2)

~~四倍经验 CF1055F CF241B BZOJ3689 LGOJ5283~~


------------
去年考完省选我在场外看到这题的时候还一脸懵逼，现在觉得这题特别水。

但是为什么你们都会可持久化 01trie 啊……

给一个不用可持久化的方法：

首先看到题不难想到求异或前缀和，将问题转化为选 $k$ 对异或最大的数。

但这是无序对不好搞，我们把 $k$ 翻倍，最后再把答案减半即可。

处理异或基本上就是 trie 和线性基两种，~~但是我不会线性基~~，所以我们考虑用 trie。

trie 的经典操作是求与某一个数异或最大的数，但是我们这里是两个数异或。那没关系，我们用有序表合并。

我们画一个表，$i$ 行 $j$ 列代表第 $i$ 个与第 $j$ 个异或的值。

假设我们现在已经将每一列排好序，那我们就可以用一个优先队列存每一列的“当前元素”，每次取出最大的往后挪一格再放回去。

但是问题是我们没排好序啊。

也没关系，我们只需要记录当前是第几大，现场求就可以了。

那么求这个就需要 trie 了。我们可以类比平衡树，维护棵子树的节点数，然后看往哪边走就行了。

code：
```cpp
#include<vector>
#include<queue>
#include<cctype>
#include<cstdio>
using namespace std;
typedef long long ll;
inline ll readint(){
    ll x=0;
    bool f=0;
    char c=getchar();
    while(!isdigit(c)&&c!='-') c=getchar();
    if(c=='-'){
        f=1;
        c=getchar();
    }
    while(isdigit(c)){
        x=x*10+c-'0';
        c=getchar();
    }
    return f?-x:x;
}
const int maxn=5e5+5;
int n,k;
ll a[maxn];
const int maxbase=35;
struct node{
	node* ch[2];
	int s;
	node():s(0){
		ch[0]=ch[1]=0;
	}
	void insert(ll x,int base=maxbase){
		s++;
		if(base<0) return;
		bool d=(x>>base)&1;
		if(!ch[d]) ch[d]=new node;
		ch[d]->insert(x,base-1);
	}
	ll kthxor(ll x,int k,int base=maxbase){
		if(base<0) return 0;
		bool d=(x>>base)&1;
		if(!ch[!d]) return ch[d]->kthxor(x,k,base-1);
		else{
			if(k<=ch[!d]->s) return ch[!d]->kthxor(x,k,base-1)|(1ll<<base);
			else return ch[d]->kthxor(x,k-ch[!d]->s,base-1);
		}
	}
}*rt;
ll now[maxn];
int rk[maxn];
struct cmp{
	bool operator ()(int a,int b){
		return now[a]<now[b];
	}
};
int main(){
    #ifdef LOCAL
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
    #endif
    n=readint();
    k=readint()*2;
    rt=new node;
    rt->insert(a[0]=0);
    for(int i=1;i<=n;i++) rt->insert(a[i]=readint()^a[i-1]);
	priority_queue<int,vector<int>,cmp> pq;
    for(int i=0;i<=n;i++){
    	rk[i]=1;
    	now[i]=rt->kthxor(a[i],1);
    	pq.push(i);
	}
	ll ans=0;
	while(k--){
		int u=pq.top();
		pq.pop();
		ans+=now[u];
		rk[u]++;
		if(rk[u]<=n){
			now[u]=rt->kthxor(a[u],rk[u]);
			pq.push(u);
		}
	}
	printf("%lld\n",ans/2);
	return 0;
}
```


---

## 作者：longlongzhu123 (赞：2)

# 题解 luogu P5283 【[十二省联考2019]异或粽子】

*时间：2019.4.20*

## 题目描述

小粽是一个喜欢吃粽子的好孩子。今天她在家里自己做起了粽子。

小粽面前有 $n$ 种互不相同的粽子馅儿，小粽将它们摆放为了一排，并从左至右编号为 $1$ 到 $n$ 。第 $i$ 种馅儿具有一个非负整数的属性值 $a_i$ 。每种馅儿的数量都足够多，即小粽不会因为缺少原料而做不出想要的粽子。小粽准备用这些馅儿来做出 $k$ 个粽子。

小粽的做法是：选两个整数数 $l$, $r$ ，满足 $1 \leqslant l \leqslant r \leqslant n$，将编号在 $[l, r]$ 范围内的所有馅儿混合做成一个粽子，所得的粽子的美味度为这些粽子的属性值的**异或和**。（异或就是我们常说的 xor 运算，即 C/C++ 中的 `ˆ` 运算符或 Pascal 中的 `xor` 运算符）

小粽想品尝不同口味的粽子，因此它不希望用同样的馅儿的集合做出一个以上的 粽子。

小粽希望她做出的所有粽子的美味度之和最大。请你帮她求出这个值吧！

## 分析

***注意：下文为了方便，均用 $m$ 代替了原题中的 $k$***

作为十二省联考的原题，这题也应该算是简单题了吧QwQ......

题目要求前$m$大的异或部分和总和，先预处理出前缀异或和$sum[i]$，问题变成求前$m$大的异或值对总和。

异或？当然是用01-Trie啦！

## 01-Trie（大佬跳过QAQ）

字典树（Trie）是一种用于存储字符串的数据结构，限于篇幅便不在此赘述。我们只考虑Trie的一个变种：**01-Trie**。

如果我们要维护一种数据结构，支持**在$\bf {O(log\ n)}$内插入整数**、**查询整数是否存在**，要怎么做？

*   `std::set<int>`！ovo

01-Trie为我们提供了一种新的思路：将整数按照二进制拆分，并一个一个bit存起来。

讲的不清楚？让我们看一看样例：

![捕获.PNG](https://i.loli.net/2019/04/20/5cbb17659567f.png)

看起来很简单，是吧？对应的01-Trie长这样：

![1.png](https://i.loli.net/2019/04/20/5cbb15a97a0c9.png)

这棵Trie是每个数字按照二进制从高位到低位插入得到的。比如数字$3$对应着下图中红色标出的一条路径。

![2.png](https://i.loli.net/2019/04/20/5cbb15a97a740.png)

把上面的数字都在Trie里面查一查试试吧！每个数字在Trie中都有一条对应的路径，因此Trie最多有$(n \times \text {二进制位数})$个节点（而且这是松的上界）。

插入时，从高到低遍历数字二进制的每一位，并维护一个指针$x$在树上移动。$x$一开始指向根节点（$1$号节点）。若当前位上的值是$k$，那么判断一下$x$是否有$k$号儿子，没有则新建，然后将$x$移动到$x.son[k]$，直到走完二进制的每一位为止。

查询类似，只不过没有新建节点而已。插入和查询的时间复杂度都是$O(\log n)$。

```cpp
const int kLen = 32;
struct Node {
  int son[2];
};
Node tree[kMaxN];
int top;
void Insert(int val) {
  int x = 1;
  for (int i = kLen - 1; i >= 0; i--) { // 遍历二进制每一位
    bool k = bool(val & (1 << i)); // 获得当前位上的值
    if (!tree[x].son[k]) tree[x].son[k] = ++top; // 若儿子不存在则新建节点
    x = tree[x].son[k]; // 移动指针
  }
}
```

## 第$k$大异或和

01-Trie维护二进制这一特殊性质，使得01-Trie可以很方便地处理异或问题。

我们现在有了一棵01-Trie，想要查询某个数与其中数字的第$rank$大异或和，怎么办？

类似**主席树**，我们在Trie上的每个节点维护`siz`，表示插入时经过这个节点的次数。

首先，根据贪心策略，若当前位上的值是$k$，且$x$有$k \text { xor } 1$号儿子，那么走$x.son[k \text { xor } 1]$会更优。

这是因为走这一步可以使异或和的这一位变成$1$，而我们是从高位往低位走的，所以肯定会更优。

每走到一位，判断$siz(x.son[k \text { xor } 1])$是否大于等于$rank$，如果是，就说明第$rank$大异或和在$x$的第$k \text { xor } 1$号儿子中，并让$x = x.son[k \text { xor } 1]$。否则让$x = x.son[k]$，然后将$rank$减去$siz(x.son[k \text { xor } 1])$。

这样，我们就可以求出某个数在这棵Trie中的第$rank$大异或和了。

## 回到正题

题目要求$m$个$[l, r]$点对。点对是有序的，为了方便，先将$m \times 2$，输出答案时再把答案减半。

首先，将输入数组$a$求一遍前缀异或和，然后将$sum$全部插入Trie中。

对于每个$r$，贪心告诉我们要按顺序取出它在Trie中的第$1$大、第$2$大、第$3$大...异或和。我们不知道每个$r$要取出多少个异或和，但是我们需要取出所有$r$中的前$m$个。一开始将每个$r$取出的第$1$大异或和放到堆（大根）中，每次取出堆顶并弹出。假设堆顶是$r_0$的第$rank_0$大异或和，那么我们将$r_0$的第$rank_0 + 1$大异或和压进堆里。这样重复$m$次，我们就能取出前$m$大的异或和。

实现上，使用结构体

```cpp
struct Node {
  int index; // `r`的下标
  int rank; // 当前的排名
  LL value; // 第rank大异或值
};
bool operator<(const Node& x, const Node& y) { // 运算符重载
  return x.value < y.value;
} 
```

来表示上文堆的节点。循环$m$（或者说$m \times 2$）次即可。时间复杂度：$O(32n + (32 + \log n)m)$。~~卡常预警~~

## 代码

[评测记录（O2）](https://www.luogu.org/recordnew/show/18355719)最大一个点1642ms

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int kMaxN = 5 * 100000 + 10;
const int kLen = 33;
const int kMaxSize = kMaxN * (kLen + 2) + 10;
struct Trie {
  struct Node {
    int son[2], siz;
  };
  Node tree[kMaxSize];
  int top;
  Trie() { top = 1; }
  void Insert(LL val) {
    int x = 1;
    for (int i = kLen - 1; i >= 0; i--) {
      bool k = bool(val & (1ll << i));
      tree[x].siz++;
      if (!tree[x].son[k]) tree[x].son[k] = ++top;
      x = tree[x].son[k];
    }
    tree[x].siz++;
  }
  LL Query(LL val, int rank) { // Query the k-th xor value of `val`
    int x = 1;
    LL ans = 0;
    for (int i = kLen - 1; i >= 0; i--) {
      bool k = bool(val & (1ll << i));
      /*if (!tree[x].son[!k]) {
        x = tree[x].son[k];
      } else */
      if (rank <= tree[tree[x].son[!k]].siz) {
        ans |= (1ll << i);
        x = tree[x].son[!k];
      } else {
        rank -= tree[tree[x].son[!k]].siz;
        x = tree[x].son[k];
      }
    }
    return ans;
  }
};
struct Node {
  int index, rank;
  LL value;
};
bool operator<(const Node& x, const Node& y) {
  return x.value < y.value;
}
priority_queue<Node> Q;
Trie T;
int n, m;
LL sum[kMaxN], a[kMaxN];
int main() {
  scanf("%d %d", &n, &m);
  m *= 2;
  sum[0] = 0;
  for (int i = 1; i <= n; i++) {
    scanf("%lld", &a[i]);
    sum[i] = a[i] ^ sum[i - 1];
  }
  for (int i = 0; i <= n; i++) {
    T.Insert(sum[i]);
  }
  for (int i = 0; i <= n; i++) {
    Q.push((Node) {i, 1, T.Query(sum[i], 1)});
  }
  LL ans = 0;
  for (int i = 1; i <= m; i++) {
    Node x = Q.top();
    Q.pop();
    ans += x.value;
    int idx = x.index;
    int rank = x.rank;
    if (rank <= n - 1) {
      Q.push((Node) {idx, rank + 1, T.Query(sum[idx], rank + 1)});
    }
  }
  printf("%lld\n", ans / 2);
  return 0;
}
```

北京市第三区交通委提醒您：

程序千万行，

long long 第一行；

类型不规范，

WA两行泪。

*   一定要写`(1ll << i)`，而不是`(1 << i)`！！！

~~**滑稽**~~



---

## 作者：TheLostWeak (赞：2)

[点此看题面](https://www.luogu.org/problemnew/show/P5283)

**大致题意：** 求前$k$大的区间异或和之和。

### 可持久化$Trie$树

之前做过一些可持久化$Trie$树题，结果说到底还是主席树。

终于，碰到一道**真·可持久化$Trie$树**的题目。

其实它的实现与主席树也是类似的。

### 大致思路

首先，我们统计一遍前缀异或和。

然后，我们根据前缀异或和建一棵可持久化$Trie$树。

接下来最核心的来了：

我们先求出以每个点为右端点所能得到的最大异或和，这可以在$Trie$树上查询得到（和普通的$Trie$树是一样的）。

然后，把这些值连同该右端点全扔入大根堆里。

每次，我们取出堆顶，统计答案后求出以该点为右端点所能得到的次大值，然后重新扔入堆里。如果再取到该右端点，就是次次大值、次次次大值，以此类推。

那么如何求次大值呢？

没关系，反正我们本来就是可持久化$Trie$树，直接复制该点的$Trie$树并将求出的最大值所对应的数在树上删去即可。

这种方法的复杂度应该是$O((n+k)log\ Max\ a_i)$，但我写得弱了一点，变成了$O((2n+k)log\ Max\ a_i)$。虽然很好改，但我懒得改了。。。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define RU Reg unsigned
#define Con const
#define CI Con int&
#define CU Con unsigned&
#define I inline
#define W while
#define N 500000
#define K 200000
#define mp make_pair
#define fir first
#define sec second
using namespace std;
int n,k,p[N+5];unsigned a[N+5];typedef pair<unsigned,int> Pr;
priority_queue<Pr> q;
class FastIO
{
	private:
		#define FS 100000
		#define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
		#define tn (x<<3)+(x<<1)
		#define D isdigit(c=tc())
		char c,*A,*B,FI[FS];
	public:
		I FastIO() {A=B=FI;}
		Tp I void read(Ty& x) {x=0;W(!D);W(x=tn+(c&15),D);}
		Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
		#undef D
}F;
class PersistentTrie//可持久化Trie树
{
	private:
		#define SZ ((N<<1)+K+1)
		#define Log 33
		int tot,Rt[N+5];struct node {int Sz,S[2];}O[SZ*Log+5];
		I void upt(int& rt1,RI rt2,CU x,CI t,CI D)//修改
		{
			if((O[rt1=++tot]=O[rt2]).Sz+=t,!~D) return;//复制节点，更新size
			RI d=(x>>D)&1;upt(O[rt1].S[d],O[rt2].S[d],x,t,D-1);//处理子节点
		}
		I unsigned qry(int& rt,CI x,CI D)//询问与x的最大异或和
		{
			if(!~D) return 0;RI d=(x>>D)&1;
			return O[O[rt].S[d^1]].Sz?qry(O[rt].S[d^1],x,D-1)|(1<<D):qry(O[rt].S[d],x,D-1);//能使这一位为1就必使其为1，否则使其为0
		}
	public:
		I PersistentTrie() {tot=1,Update(0,0,0,1);}
		I void Update(CI v1,CI v2,CU x,CI t) {upt(Rt[v1],Rt[v2],x,t,31);}
		I unsigned Query(CI v) {RU t=qry(Rt[v],a[v],31);return Update(v,v,a[v]^t,-1),t;}//询问，为避免计算多次贡献将其删去
}P;
int main()
{
	RI i;Pr t;Reg long long ans=0;
	for(F.read(n,k),i=1;i<=n;++i) F.read(a[p[i]=i]),a[i]^=a[i-1],P.Update(i,i-1,a[i],1);//初始化建树
	for(i=1;i<=n;++i) q.push(mp(P.Query(i),i));//询问然后扔入堆中
	for(i=1;i<=k;++i) t=q.top(),q.pop(),ans+=t.fir,//取出堆顶，统计答案
		--p[t.sec]&&(q.push(mp(P.Query(t.sec),t.sec)),0);//将次大值扔入堆中
	return printf("%lld",ans),0;//输出答案
}
```

---

## 作者：hl666 (赞：2)

感觉不是很难的一题，想了0.5h左右（思路歪了，不过想了一个大常数的两只$\log$做法233）

然后码+调了1h，除了一个SB的数组开小外基本上也没什么坑点

先讲一个先想到的方法，我们对于这种问题显然可以**二分第$k$大**，然后验证有多少个值小于等于它

然后考虑怎么判断，我们建一棵**0/1Trie**，然后枚举一个右端点，每次把整个Trie异或上这个点的权值

具体实现的话就是不断向下走的过程，当这一位为$1$时交换左右子树即可

然后相当于查小于等于一个数的数个数以及和，直接Trie上节点维护一下即可

这样是$n \log \max{a_i}$的，由于$a_i$值域比较大而且直接跑满了，因此可能无法通过此题

然后慢慢就想到一种诡异的做法，先记录一下**前缀异或和**，然后考虑算出每个点为右端点时的**最大值和左端点**

这样有一个好处，我们每次用**堆**维护这$n$的点为右端点是答案的最大值，那么直接算出前$k$大即可

那么考虑如何计算，首先如果不考虑删除的话是挺简单的，我们建一棵**可持久化0/1Trie**，然后每个点在对应的Trie上找一个数和它异或值最大即可（类似于普通0/1Trie）

那么问题来了，我们统计完一个点的值时怎么删除能，可持久化数据结构一旦删除不是就全乱了么

其实不一定，由于这里只删一条**已添加过的链**，因此有一种奇妙的方法

我们记录左端点后找到右端点此时的Trie根节点编号，然后**新开一个**可持久化0/1Trie，然后直接在此时的版本上删去左端点对应的链即可

由于堆只需要取$k$次值，因此最多多产生$k$个版本，所以这部分的复杂度为$(n+k)\log \max{a_i}$

然后加上堆的$k\log n$之后还是轻松通过此题，不过注意版本的数组大小要开大

CODE

```cpp
#include<cstdio>
#include<cctype>
#include<queue>
#define RI register int
#define CI const int&
#define Tp template <typename T>
using namespace std;
typedef unsigned int u32;
const int N=5e5+5,R=32;
struct data
{
    u32 val; int id;
    inline data(const u32& Val=0,CI Id=0)
    {
        val=Val; id=Id;
    }
    friend inline bool operator < (const data& A,const data& B)
    {
        return A.val<B.val;
    }
}; priority_queue <data> hp; long long ans;
int n,k,rt[N<<1],pos[N],cur; u32 a[N],pfx[N],ret;
class FileInputOutput
{
    private:
        static const int S=1<<21;
        #define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,S,stdin),A==B)?EOF:*A++)
        char Fin[S],*A,*B;
    public:
        Tp inline void read(T& x)
        {
            x=0; char ch; while (!isdigit(ch=tc()));
            while (x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));
        }
        #undef tc
}F;
class Segment_Tree
{
    private:
        struct segment
        {
            int ch[2],size;
        }node[N*(R+1)<<1]; int tot;
    public:
        #define lc(x) node[x].ch[0]
        #define rc(x) node[x].ch[1]
        #define S(x) node[x].size
        inline void build(int& now,CI dep=R-1)
        {
            now=++tot; S(now)=1; if (!~dep) return; build(lc(now),dep-1);
        }
        inline void insert(CI lst,int& now,const u32& num,CI mv,CI dep=R-1)
        {
            now=++tot; node[now]=node[lst]; S(now)+=mv; if (!~dep) return;
            if ((num>>dep)&1u) insert(rc(lst),rc(now),num,mv,dep-1);
            else insert(lc(lst),lc(now),num,mv,dep-1);
        }
        inline void query(CI now,const u32& num,CI dep=R-1)
        {
            if (!~dep) return; if (S(node[now].ch[((num>>dep)&1)^1]))
            ret|=1u<<dep,query(node[now].ch[((num>>dep)&1)^1],num,dep-1);
            else query(node[now].ch[(num>>dep)&1],num,dep-1);
        }
        #undef lc
        #undef rc
        #undef S
}SEG;
int main()
{
    //freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
    RI i; for (F.read(n),F.read(k),i=1;i<=n;++i) F.read(a[i]);
    for (SEG.build(rt[0]),i=1;i<=n;++i)
    {
        pfx[i]=pfx[i-1]^a[i]; SEG.insert(rt[i-1],rt[i],pfx[i],1);
        ret=0; SEG.query(rt[pos[i]=i],pfx[i]); hp.push(data(ret,i));
    }
    for (cur=n;k;--k)
    {
        data nw=hp.top(); hp.pop(); ans+=nw.val;
        SEG.insert(rt[pos[nw.id]],rt[++cur],nw.val^pfx[nw.id],-1);
        ret=0; SEG.query(rt[pos[nw.id]=cur],pfx[nw.id]); hp.push(data(ret,nw.id));
    }
    return printf("%lld",ans),0;
}
```

---

## 作者：ModestCoder_ (赞：2)

[原题传送门](https://www.luogu.org/problemnew/show/P5283)

Unbelievable!我也能自己a省选题了？

前几天刚刚做过一道题：BZOJ3689异或之
先讲讲这道题
#### 【BZOJ3689】异或之
##### Description
给定n个非负整数A[1], A[2], ……, A[n]。
对于每对(i, j)满足1 <= i < j <= n，得到一个新的数A[i] xor A[j]，这样共有n*(n-1)/2个新的数。求这些数（不包含A[i]）中前k小的数。
注：xor对应于pascal中的“xor”，C++中的“^”。

##### Input
第一行2个正整数 n,k，如题所述。
以下n行，每行一个非负整数表示A[i]。

##### Output
 共一行k个数，表示前k小的数。

##### Sample Input
4 5
1
1
3
4
##### Sample Output
0 2 2 5 5
##### HINT
##### 【样例解释】
1 xor 1 = 0 (A[1] xor A[2])

1 xor 3 = 2 (A[1] xor A[3])

1 xor 4 = 5 (A[1] xor A[4])

1 xor 3 = 2 (A[2] xor A[3])

1 xor 4 = 5 (A[2] xor A[4])

3 xor 4 = 7 (A[3] xor A[4])

前5小的数：0 2 2 5 5
##### 【数据范围】
 对于100%的数据，2 <= n <= 100000；
 
 1 <= k <= min{250000, n*(n-1)/2}；
 
        0 <= A[i] < 2^31

### solution
其实trie也可以实现异或第k大的

可以通过类似平衡树求kth的方法，开个size的桶

把每个数与其他数异或的第k大求出来

然后用优先队列，开个小根堆，当用好一个数与其他数的异或第k大时，把第k+1大加入堆

会有重复，会出现算好x ^ y，然后来y ^ x的情况，所以每两个只能用一个

具体见代码：

```cpp
#include <bits/stdc++.h>
#define maxn 100010
using namespace std;
struct node{
    int ans, a, id;
    bool operator < (const node & x) const{
        return ans > x.ans;
    }
};
priority_queue <node> q;
int n, m, size[maxn * 30], ch[maxn * 30][3], sz, a[maxn];
  
inline int read(){
    int s = 0, w = 1;
    char c = getchar();
    for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
    for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
    return s * w;
}
  
void insert(int x){
    int u = 0;
    for (int i = 30; i >= 0; --i){
        int c = (x & (1 << i)) != 0;
        u = ch[u][c] ? ch[u][c] : ch[u][c] = ++sz;
        ++size[u];
    }
}
  
int query(int x, int k){
    int u = 0, ans = 0;
    for (int i = 30; i >= 0; --i){
        int c = (x & (1 << i)) != 0;
        if (size[ch[u][c]] >= k) u = ch[u][c]; else ans += (1 << i), k -= size[ch[u][c]], u = ch[u][c ^ 1];
        //如果有k以上个数当前数位与x一样，当然选择异或，因为这样数位上就变0了，否则，得与当前数位上与自己不一样的数异或
    }
    return ans;
}
  
int main(){
    n = read(), m = read();
    for (int i = 1; i <= n; ++i){
        a[i] = read(); insert(a[i]);
    }
    for (int i = 1; i <= n; ++i){
        node tmp;
        tmp.ans = query(a[i], 2);
        //取第2小是因为最小的是自己异或自己，不算
        tmp.a = a[i], tmp.id = 2;
        q.push(tmp);
    }
    for (int i = 1; i <= (m << 1); ++i){
        node tmp = q.top(); q.pop();
        if (i & 1) printf("%d", tmp.ans);//每两个只能用一个
        if (i & 1 && i < (m << 1) - 1) printf(" ");//行末不能有空格
        if (++tmp.id >= n) continue;//id++
        tmp.ans = query(tmp.a, tmp.id);
        q.push(tmp);
    }
    printf("\n");
    return 0;
}
```


#### 然后开始讲这道异或粽子
## solution
刚看完题就感觉跟异或之非常像，不过看到区间异或和就失望了，
因为我知道上一题的trie是两个数异或起来，然而这一题是处理一堆数异或起来

唉，好像这个区间必须连续，想到什么？前缀和！

预处理前缀异或和，[l,r]的异或和就是[1,r] ^ [1,l-1]

那么每一段区间的异或和都可以表示为两个前缀异或和的异或和（l=1的情况时，让[1,r]与0异或）

但是上一题是处理前k小，这一题求前k大，没关系，前k大就是倒数k小 ^ - ^
化归到上一题

另外，不要忘了long long

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 500010
#define int long long
using namespace std;
struct node{
	int a, ans, id;
	bool operator < (const node & x) const{
		return ans < x.ans;
	}
};
priority_queue <node> q;
int a[maxn], n, m, size[maxn * 31], sz, ch[maxn * 31][2];

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

void insert(int x){
	int u = 0;
	for (int i = 31; i >= 0; --i){
		int c = (x & (1 << i)) != 0;
		++size[u = ch[u][c] ? ch[u][c] : ch[u][c] = ++sz];
	}
}

int query(int x, int k){
	int u = 0, ans = 0;
	for (int i = 31; i >= 0; --i){
		int c = (x & (1 << i)) != 0;
		if (size[ch[u][c]] >= k) u = ch[u][c]; else k -= size[ch[u][c]], ans += (1LL << i), u = ch[u][c ^ 1];
	}
	return ans;
}
//跟上一题一样的套路

signed main(){
	n = read(), m = read();
	a[0] = 0; insert(0);
	for (int i = 1; i <= n; ++i){
		int x = read();
		insert(a[i] = a[i - 1] ^ x);//前缀异或和
	}
	for (int i = 0; i <= n; ++i){
		node tmp;
		tmp.ans = query(a[i], n + 1);//因为0也参与，所以总共有n+1个数参与，所以取第n+1小个
		tmp.a = a[i], tmp.id = n + 1;
		q.push(tmp);
	}
	int ans = 0;
	for (int i = 1; i <= (m << 1); ++i){
		node tmp = q.top(); q.pop();
		if (i & 1) ans += tmp.ans;
		--tmp.id;
		if (tmp.id == 1) continue;
		tmp.ans = query(tmp.a, tmp.id);
		q.push(tmp);
	}
	printf("%lld\n", ans);
	return 0;
}
```


---

## 作者：dfkdsmbd (赞：2)

考场的我就是傻子

这个题就是个送分题，bzoj有一个类似的题目，叫异或之（没记错的话），联考原题石锤了

对于一个区间我们可以通过差分的思想来处理它的异或和，因此建一棵可持久化01trie，开始我们通过trie查出每个节点的前方和他异或起来最大的一个，之后开个大根堆，每次查询堆顶然后弹出

注意边界，对于第i个位置只能查询i次，多了就不要了

```cpp
#include <bits/stdc++.h>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <bitset>
#include <queue>
#include <cmath>
#include <map>
#include <set>
#define ri register int

using namespace std;

inline char gch()
{
	static char buf[100010], *h = buf, *t = buf;
	return h == t && (t = (h = buf) + fread(buf, 1, 100000, stdin), h == t) ? EOF : *h ++;
}

typedef long long lo;

typedef unsigned int uint;

template <typename int_qwq>

inline void re(int_qwq &x)
{
	x = 0;
	char a;
	bool b = 0;
	while(!isdigit(a = getchar()))
		b = a == '-';
	while(isdigit(a))
		x = x * 10 + a - '0', a = getchar();
	if(b)
		x = -x;
}

const int ms = 5e5 + 10;

int n, m;

uint a[ms], pos[ms], su = 0, S[ms];

lo sta[1000010], ta = 0;

lo ans;

bool FFF, fl;

struct node
{
	lo x; int k, p;
	
	inline bool operator < (const node &a) const
	{
		return x < a.x;
	}
};

priority_queue <node> qwq;

struct Trie
{
	uint ch[ms * 35][2], cnt, sz[ms * 35], rt[ms], val[ms * 35];
	
	bool f[ms * 35];
	
	inline void insert(uint v, uint poi)
	{
		uint las = poi > 0 ? rt[poi - 1] : 0, no = ++ cnt;
		rt[poi] = cnt; 
		for(ri i = 31; i >= 0; i --)
		{
			int p = ((v & (1 << i)) > 0); sz[no] = sz[las] + 1;
			ch[no][0] = ch[las][0], ch[no][1] = ch[las][1];
			ch[no][p] = ++ cnt, no = ch[no][p], las = ch[las][p];
		}
		sz[no] = sz[las] + 1, f[no] = 1, val[no] = v;
	}
	
	inline void init()
	{
		cnt = 0;
		memset(ch, 0, sizeof(ch)), memset(sz, 0, sizeof(sz)), memset(f, 0, sizeof(f));
	}

    uint ask(int no, uint v, int p, int k)
    {
        if(p == -1)
            return v ^ val[no];
        uint d = ((v & (1 << p)) > 0); d ^= 1; 
        if(sz[ch[no][d]] >= k)
            return ask(ch[no][d], v, p - 1, k);
        else
            return ask(ch[no][d ^ 1], v, p - 1, k - sz[ch[no][d]]);
    }
	
	inline void askans()
	{
        S[0] = 0;
        for(ri i = 1; i <= n; i ++)
            S[i] = S[i - 1] ^ a[i], qwq.push((node){ask(rt[i - 1], S[i], 31, 1), 1, i});
        while(m --)
        {
            node qaq = qwq.top(); ans += qaq.x; qwq.pop();
            //cout << qaq.x << '\n';
            if(qaq.k + 1 <= qaq.p)
                qwq.push((node){(lo)ask(rt[qaq.p - 1], S[qaq.p], 31, qaq.k + 1), qaq.k + 1, qaq.p});
        }
	}
}trie;

inline bool cmp(lo a, lo b)
{
	return a > b;
}

int main()
{
	freopen("13.in", "r", stdin);
	freopen("xor2.out", "w", stdout);
	re(n), re(m);
	trie.init();
	trie.insert(0, 0); su = 0;
	for(ri i = 1; i <= n; i ++)
	{
		re(a[i]);
		su ^= a[i];
		trie.insert(su, i);
	}
	trie.askans();
	cout << ans;
    //system("pause");
}
```

---

## 作者：cuking (赞：2)


   首先，求出前缀异或和，则一个区间的异或和变成两个前缀异或和的异或和。
   
   任意两个（可以相同）前缀异或和，异或起来可以得到（N+1）^2个区间的异或和，其中（N+1）个是空区间异或和，剩下的是原序列的每个区间出现了两次。
    
   把这（N+1）个数的二进制建成一颗Trie树，然后考虑二分答案，设第k大的数是x，枚举（N+1）个数在Trie树上跑一下，统计出有多少个>=x的数即可。这样就能求出第k大的数是多少，然后再枚举这（N+1）个数，暴力在Trie树上找所有能使异或和<x的数，不是小于等于是因为等于x的数可能很多，复杂度不对，但是我们能知道有多少小于x的数以及x是多少，最后补齐等于x的即可。
   
   这样做的时间复杂度是O(nlog^2值域+(n+k)log值域),空间复杂度是O(nlog值域)，时间复杂度还是很大，如何优化？
   
   其实直接在Trie上二分即可，边在Trie上走，边判断怎么走，就可以去掉一个log了。
   
   我的代码做法略有不同，因为不是联考考生，有一点信息差，误以为K很大，所以整了一个O(nlog^2值域)的做法，空间也是俩log，过不了，其实就是给每个Trie结点再记了一个数组表示这个子树内所有数的第i位总共有几个1，这样建树就两个log，在Trie上二分也是俩log，不过本题K很小，所以改成暴力就能去掉一个log了。。。我懒得改了
   
```cpp
#include<stdio.h>
#define LL long long
#define uint unsigned int
typedef struct Ts
{
	Ts*ch[2];
	int bits[32];
	int size;
}Ts;
Ts mem[3200000],*Malloc=mem+1;
Ts*New()
{
	Ts*p=Malloc++;
	p->ch[0]=p->ch[1]=mem;
	p->size=0;
	return p;
}
Ts*root=New();
Ts*p[100001];
void insert(uint x)
{
	Ts*t=root;
	for(int i=32;i--;)
	{
		t->size++;
		for(int j=0;j<32;j++)
			t->bits[j]+=(x>>j)&1;
		int lr=(x>>i)&1;
		if(t->ch[lr]==mem)t->ch[lr]=New();
		t=t->ch[lr];
	}
	t->size++;
	for(int j=0;j<32;j++)
		t->bits[j]+=(x>>j)&1;
}
uint Xor[100001];
int main()
{
	//freopen("xor1.in","r",stdin);
	mem->ch[0]=mem->ch[1]=mem;
	int N,K;
	scanf("%d%d",&N,&K);
	K*=2;
	int tmpk=K;
	insert(0);
	for(int i=1;i<=N;i++)
	{
		scanf("%u",Xor+i);
		Xor[i]^=Xor[i-1];
		insert(Xor[i]);
	}
	for(int i=0;i<=N;i++)
	p[i]=root;
	uint ans=0;
	LL Ans=0;
	LL cnt=0;
	for(int i=32;i--;)
	{
		LL sum=0;
		for(int j=0;j<=N;j++)
		{
			int lr=(Xor[j]>>i)&1;
			sum+=p[j]->ch[lr^1]->size;
		}
		if(sum>=K)
		{
			ans|=(1u<<i);
			for(int j=0;j<=N;j++)
			{
				int lr=(Xor[j]>>i)&1;
				p[j]=p[j]->ch[lr^1];
			}
		}
		else
		{
			K-=sum;
			for(int j=0;j<=N;j++)
			{
				int lr=(Xor[j]>>i)&1;
				Ts*t=p[j]->ch[lr^1];
				cnt+=t->size;
				for(int k=0;k<32;k++)
				{
					if((Xor[j]>>k)&1)
						Ans+=(1ll<<k)*(t->size-t->bits[k]);
					else
						Ans+=(1ll<<k)*(t->bits[k]);
				}
				p[j]=p[j]->ch[lr];
			}
		}
	}
	Ans+=ans*(tmpk-cnt);
	printf("%lld\n",Ans/2);
}
```


---

## 作者：tth37 (赞：2)

分析题意，即找出$n$个数中互不相同且异或和最大的前$k$段区间。

用异或前缀和$s[i]$表示$a[1]\oplus a[2]\oplus ... \oplus a[i]$。根据异或运算的性质，区间$[l,r]$的异或和即为$s[r]\oplus s[l-1]$。

将$s[1]$到$s[n]$依次插入$01trie$树中，每次找出对于固定的右端点$r$，与$s[r]$异或值最大的$s[l]$。显然，此次操作找到的是固定右端点为$r$时的最大区间异或和。

将每个不同的$r$值所对应的最大区间异或和插入堆中，显然堆顶的元素即为$n$个数中任意区间的最大异或和。取出堆顶元素，并同时得到这是以$r$为右端点的第$1$大区间异或和。向堆中插入以$r$为右端点的第$2$大区间异或和。

在查询以$r$为右端点的第$k$大区间异或和时，只需稍微更改在$01trie$树上查找的方式即可，与主席树查询区间第$k$小数的思想类似。由于需要访问$01trie$树的历史状态，因此$01trie$需要可持久化。

注意：以$r$为右端点的区间异或和一共只有$r$个，因此查询以$r$为右端点的第$r+1$大区间异或和是没有意义的。

另外，在将`(1<<d)`这样的式子转`long long`时，不能写成`(long long)(1<<d)`，而是`((long long)1<<d)`。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN=500005;
const int DEP=31;
int N,M;
ll ans,s[MAXN];
struct State{
    ll val;
    int r,k;
    bool operator <(const State& rhs) const {return val<rhs.val;}
};
priority_queue<State> q;
struct Node{
    int son[2],sum;
}trie[MAXN*(DEP+2)];
int head[MAXN],cnt;
inline void insert(Node c,Node& u,ll val,int d){
    u.sum=c.sum+1;
    if(d<0) return;
    int x=(val>>d)&1;
    u.son[!x]=c.son[!x];
    insert(trie[c.son[x]],trie[u.son[x]=++cnt],val,d-1);
}
inline ll query(Node u,ll val,int d,int k){
    if(d<0) return 0;
    int x=(val>>d)&1;
    int lsum=trie[u.son[!x]].sum;
    if(lsum>=k)
      	return ((ll)1<<d)+(ll)query(trie[u.son[!x]],val,d-1,k);
    return (ll)query(trie[u.son[x]],val,d-1,k-lsum);
}
int main(){
    trie[0].son[0]=trie[0].son[1]=trie[0].sum=0;
    insert(trie[0],trie[head[0]=++cnt],0,DEP);
    scanf("%d%d",&N,&M);
    for(register int i=1;i<=N;++i){
        ll a;
        scanf("%lld",&a);
        s[i]=s[i-1]^a;
        insert(trie[head[i-1]],trie[head[i]=++cnt],s[i],DEP);
        q.push((State){query(trie[head[i-1]],s[i],DEP,1),i,1});
    }
    for(register int i=1;i<=M;++i){
        ans+=q.top().val;
        int r=q.top().r,k=q.top().k;
        q.pop();
        if(k==r) continue;
        q.push((State){query(trie[head[r-1]],s[r],DEP,k+1),r,k+1});
    }
    printf("%lld",ans);
    return 0;
}
```

$p.s.$洛谷评测机有点小慢，不开`O2`会小概率发生TLE QwQ

---

## 作者：Linshey (赞：1)

神仙们都写了可持久化01Trie, 可是蒟蒻我不会！

于是我使用线段树套普通01Trie。具体做法如下：

参考超级钢琴的做法，先处理前缀异或和。使用一个堆，维护$ f_{o, l, r}$ 左边界为$ o $,右边界为 $ [l,r] $ 的区间异或和的最大值, 取出k次堆顶，每次取完把原来的区间$ [l,r] $分裂成两半, 计算新的最大值，这样符合不重不漏的原则。

问题就来了，怎么计算任意区间的最大异或和？

那么很容易想到用线段树套01Trie, 每个节点是一棵维护这个区间的01Trie, 每次查询取所有需查询的节点的最大值即可。

```cpp

#include <iostream>
#include <queue>
#include <algorithm>
#include <cstdio>
#include <cstring>
#define lson(x) x << 1
#define rson(x) x << 1 | 1
#define int long long
#define SIZE 50

using namespace std;
const int maxn = 5e5 + 24;

struct node
{
	int lson, rson, pos;
	bool val;
};

node tree[maxn << 4];
int tail;

int newnode()
{
	tail++;
	tree[tail].val = tree[tail].lson = tree[tail].rson = 0;
	return tail;
}

unsigned int A[maxn];

void insert(int x, int val, int h, int pos)
{
	if (h == SIZE + 1)
	{
		tree[x].pos = pos;
		return;
	}
	if (val & (1ull << SIZE - h))
	{
		if (!tree[x].rson)
		{
			tree[x].rson = newnode();
			tree[tree[x].rson].val = 1;
		}
		insert(tree[x].rson, val, h + 1, pos);
	}
	else
	{
		if (!tree[x].lson)
		{
			tree[x].lson = newnode();
			tree[tree[x].lson].val = 0;
		}
		insert(tree[x].lson, val, h + 1, pos);
	}
}

void fill(int l, int r, int x)
{
	for (int i = l; i <= r; i++)
	{
		insert(x, A[i], 1, i);
	}
}

pair<int, int> query(int x, int val, int h)
{
	if (h == SIZE + 1) return make_pair(tree[x].val, tree[x].pos);
	pair<int, int> ret = make_pair(0, 0);
	if (val & (1ull << SIZE - h))
	{
		if (tree[x].lson)
		{
			ret = query(tree[x].lson, val, h + 1);
		}
		else
		{
			ret = query(tree[x].rson, val, h + 1);
		}
	}
	else
	{
		if (tree[x].rson)
		{
			ret = query(tree[x].rson, val, h + 1);
		}
		else
		{
			ret = query(tree[x].lson, val, h + 1);
		}
	}
	ret.first += tree[x].val << SIZE + 1 - h;
	return ret;
}

int seg[maxn * 4];

void build(int x, int l, int r)
{
	seg[x] = newnode();
	fill(l, r, seg[x]);
	if (l == r) return;
	int mid = (l + r) >> 1;
	build(lson(x), l, mid);
	build(rson(x), mid + 1, r);
}

pair<int, int> ask(int x, int l, int r, int ll, int rr, int val)
{
	if (ll <= l && r <= rr)
	{
		pair<int, int> ret = query(seg[x], val, 1);
		ret.first ^= val;
		return ret;
	}
	int mid = (l + r) >> 1;
	pair<int, int> ret = make_pair(0, 0);
	if (ll <= mid)
	{
		pair<int, int> tmp = ask(lson(x), l, mid, ll, rr, val);
		tmp.first ^= val;
		if (tmp.first > ret.first)
			ret = tmp;
	}
	if (rr >= mid + 1)
	{
		pair<int, int> tmp = ask(rson(x),mid + 1, r, ll, rr, val);
		tmp.first ^= val;
		if (tmp.first > ret.first)
			ret = tmp;
	}
	return ret;
}

int n, k, ans;

struct node_
{
	int o, l, r;
	pair<int, int> k;
	bool operator <(const node_ b) const
	{
		return k.first < b.k.first;
	}
} tmp, tmp2;

priority_queue<node_> hp;

signed main()
{
	freopen("xor.in", "r", stdin);
	cin >> n >> k;
	for (int i = 1; i <= n; i++)
	{
		cin >> A[i];
		A[i] ^= A[i - 1];
	}
	build(1, 0, n);
	for (int o = 0; o < n; o++)
	{
		tmp.o = o;
		tmp.l = o + 1;
		tmp.r = n;
		tmp.k = ask(1, 0, n, tmp.l, tmp.r, A[o]);
		hp.push(tmp);
	}
	while (k--)
	{
		tmp = hp.top(); hp.pop();
		ans += tmp.k.first;
		if (tmp.k.second != tmp.r)
		{
			tmp2 = tmp;
			tmp2.l = tmp.k.second + 1;
			tmp2.k = ask(1, 0, n, tmp2.l, tmp2.r, A[tmp.o]);
			hp.push(tmp2);
		}
		if (tmp.k.second != tmp.l)
		{
			tmp.r = tmp.k.second - 1;
			tmp.k = ask(1, 0, n, tmp.l, tmp.r, A[tmp.o]);
			hp.push(tmp);
		}
	}
	cout << ans << endl;
	return 0;
}
```

然后蒟蒻我就遭雷劈了。别想抄我的题解因为上面的代码我怎么都调不出来，放弃了。

然后就使用大家都在用的可持久化01Trie, $ \color{red}\text{线下} $过了。(跟其他题解对拍不算抄题解吧？）
```cpp


#include <iostream>
#include <algorithm>
#include <cstdio>
#include <queue>
#include <cstring>
#define int unsigned int

using namespace std;
const int maxn = 3e6;
const long long SIZE = 31;

struct node
{
	int son[2];
	bool val;
	int latest;
};

node tree[maxn << 3];       /////////////BUG tree[0]
int tail = 0;

int newnode(node x)
{
	tail++;
	tree[tail].son[0] = x.son[0];
	tree[tail].son[1] = x.son[1];
	tree[tail].val = x.val;
	tree[tail].latest = x.latest;
	return tail;
}

int insert(int x, int val, int t, int late)
{
	if (SIZE - t < 0) return 0;
	int root = newnode(tree[x]);
	tree[root].val = val & (1ull << SIZE - t);
	tree[root].latest = late;
	tree[root].son[bool(val & (1ull << SIZE - t - 1))] =
		insert(tree[x].son[bool(val & (1ull << SIZE - t - 1))], val, t + 1, late);
	return root;
}

pair<int, int> query(int x, int val, int t, int time)
{
	if (SIZE - t == 0) return make_pair(tree[x].val, tree[x].latest);
	pair<int, int> ret = make_pair(0, 0);
	if (tree[x].son[!(val & (1ull << SIZE - t - 1))] && tree[tree[x].son[!(val & (1ull << SIZE - t - 1))]].latest >= time)
	{
		ret = query(tree[x].son[!(val & (1ull << SIZE - t - 1))], val, t + 1, time);
	}
	else
	{
		ret = query(tree[x].son[bool(val & (1ull << SIZE - t - 1))], val, t + 1, time);
	}
	ret.first += (1ull << SIZE - t) * tree[x].val;
	return ret;
}

struct node_
{
	int o, l, r;
	pair<int, int> k;
	bool operator <(const node_ b) const
	{
		return k.first < b.k.first;
	}
} tmp, tmp2;

priority_queue<node_> hp;

int n, k, A[maxn], rt[maxn];
long long ans;

signed main()
{
	freopen("xor.in", "r", stdin);
	memset(tree, 0, sizeof(tree));
	cin >> n >> k;
	for (int i = 1; i <= n; i++)
	{
		cin >> A[i];
		A[i] ^= A[i - 1];
		rt[i] = insert(rt[i - 1], A[i], 0, i);
	}
	for (int o = 0; o < n; o++)
	{
		tmp.o = o;
		tmp.l = o + 1;
		tmp.r = n;
		tmp.k = query(rt[tmp.r], A[o], 0, tmp.l);
		tmp.k.first ^= A[o];
		hp.push(tmp);
	}
	while (k--)
	{
		tmp = hp.top(); hp.pop();
		ans += tmp.k.first;
		if (tmp.k.second != tmp.r)
		{
			tmp2.o = tmp.o;
			tmp2.r = tmp.r;
			tmp2.l = tmp.k.second + 1;
			//tmp2.k = ask(1, 0, n, tmp2.l, tmp2.r, A[tmp.o]);
			tmp2.k = query(rt[tmp2.r], A[tmp2.o], 0, tmp2.l);
			tmp2.k.first ^= A[tmp2.o];
			hp.push(tmp2);
		}
		if (tmp.k.second != tmp.l)
		{
			tmp.r = tmp.k.second - 1;
			//tmp.k = ask(1, 0, n, tmp.l, tmp.r, A[tmp.o]);
			tmp.k = query(rt[tmp.r], A[tmp.o], 0, tmp.l);
			tmp.k.first ^= A[tmp.o];
			hp.push(tmp);
		}
	}
	cout << ans << endl;
	return 0;
}
```

千真万确过了线下，线上过不了

管理大大求过。






---

## 作者：a2956331800 (赞：1)

考场上搞出来的奇怪做法

并不知道可持久化$trie$可以做

首先显然把$a_i$做一个前缀异或和，然后就变成了两个数异或的前$k$大值

- 我们先把$trie$建出来

同时在叶子节点上记录这个点代表的数是多少和出现个数

- 开始操作

我们用一个指针同时指$trie$上两个节点，初始时两个指针指在**起始节点**（后面解释）的两个儿子上

两个节点的值异或起来就是这个指针对应的值

#### 现在我们让指针往下走

首先让两个指针往不同儿子走，这样在这一位上它们可以异或得到$1$，然后（$dfs$了上一种情况后）再向相同儿子走

注意往不同儿子走可能有两种情况，这时候一个指针要变成两个

#### 走到叶子了

我们发现所有指针对应的**值都是一样的**（而且是现在(去掉已经访问过的)能取到的最大值），所以我们就在叶子上统计下有多少种得到当前值的方案($\sum \text{每个指针两个节点的}size\text{之积}$)，计入答案并把$k-=\text{方案数}$，直到$k==0$

#### 起始节点？

观察一下上面两个走法，可以发现一个指针的两个节点一定在起始节点两侧，都在其同一侧的没考虑

- 怎么补上这些情况？

从$trie$的根开始bfs，每次把同一层的点同时作为起始节点进行$dfs$，这样就覆盖了所有情况

### 正确性？

一次$dfs$中，所有指针对应的值相同，并且对应的值是**单调不上升**的（根据$dfs$的过程很显然）

不同次的$dfs$中，起始节点越来越深，就是说初始时，指针对应的值**高位**的$0$越来越多，而**低位**取值方法一样，所以指针对应的值也是**单调不上升**的

- 就是说我们是按**从大到小**访问可能的数并计入答案，所以答案一定是正确的

### 时间复杂度？

~~这玩意看起来这么暴力会不会$TLE$?~~

然而复杂度我也不会分析~~过程太鬼畜了~~，但现场和$luogu$上都是$O_2\space 1s$过

代码
```cpp
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<cstdio>
#include<queue>
#define size(x) (x?x->size:0)
using namespace std;

long long n,k,i,j;

long long a[500005],pw[40],ans;

struct node
{
	node *l,*r;
	long long size,num;
};
node *root;
node *new_node()
{
	static node *pool,*p,*end=p;
	if(p==end)
		p=pool=(node*)malloc(sizeof(node)*1000000),end=p+1000000,memset(p,0,sizeof(node)*1000000);
	return p++;
}
void insert(long long num,long long anum)
{
	node *now=root;
	for(int i=32;i>=0;i--)
	{
		now->size++;
		if(num&pw[i])
		{
			if(!now->r)
				now->r=new_node();
			now=now->r;
		}
		else
		{
			if(!now->l)
				now->l=new_node();
			now=now->l;
		}
	}
	now->size++;now->num=anum;
}

void read(int &x)
{
	static char rc;static int flag;
	rc=getchar();flag=1;x=0;
	while(!isdigit(rc))
		flag=(rc=='-'?-1:1),rc=getchar();
	while(isdigit(rc))
		x=x*10+rc-'0',rc=getchar();
	x*=flag;
}
void read(long long &x)
{
	static char rc;static int flag;
	rc=getchar();flag=1;x=0;
	while(!isdigit(rc))
		flag=(rc=='-'?-1:1),rc=getchar();
	while(isdigit(rc))
		x=x*10+rc-'0',rc=getchar();
	x*=flag;
}

pair<node*,node*> q[35][500005];
long long len[35];

void dfs(int deep)
{
	if(!k||!len[deep])
		return;
	if(deep==1)
	{
		long long cnt=0,num=0;
		for(int i=1;i<=len[deep];i++)
		{
			cnt+=size(q[deep][i].first)*size(q[deep][i].second);
			if(q[deep][i].first&&q[deep][i].second)
				num=(q[deep][i].first->num^q[deep][i].second->num);
		}
		ans+=min(k,cnt)*num;
		k-=min(k,cnt);
		len[deep]=0;
		return;
	}
	for(int i=1;i<=len[deep];i++)
	{
		if(!q[deep][i].first||!q[deep][i].second)
			continue;
		len[deep-1]++;q[deep-1][len[deep-1]]=make_pair(q[deep][i].first->l,q[deep][i].second->r);
		len[deep-1]++;q[deep-1][len[deep-1]]=make_pair(q[deep][i].first->r,q[deep][i].second->l);
	}
	dfs(deep-1);
	for(int i=1;i<=len[deep];i++)
	{
		if(!q[deep][i].first||!q[deep][i].second)
			continue;
		len[deep-1]++;q[deep-1][len[deep-1]]=make_pair(q[deep][i].first->l,q[deep][i].second->l);
		len[deep-1]++;q[deep-1][len[deep-1]]=make_pair(q[deep][i].first->r,q[deep][i].second->r);
	}
	dfs(deep-1);
	len[deep]=0;
}

queue<node*> qu;
queue<int> qdp;

int main()
{
	read(n);read(k);
	for(i=1;i<=n;i++)
		read(a[i]);
	for(i=1;i<=n;i++)
		a[i]^=a[i-1];
	pw[0]=1;
	for(i=1;i<=35;i++)
		pw[i]=pw[i-1]*2;
	root=new_node();
	for(i=0;i<=n;i++)
		insert(a[i],a[i]);
	
	node *now;int nx,la=100;
	qu.push(root);qdp.push(33);
	while(!qu.empty())
	{
		now=qu.front();nx=qdp.front();qu.pop();qdp.pop();
		if(nx!=la)
		{
			dfs(la);
			len[la]=0;
		}
		len[nx]++;q[nx][len[nx]]=make_pair(now->l,now->r);
		if(now->l)
			qu.push(now->l),qdp.push(nx-1);
		if(now->r)
			qu.push(now->r),qdp.push(nx-1);
		la=nx;
	}
	q[33][1]=make_pair(root->l,root->r);len[33]=1;
	dfs(33);
	cout<<ans;
	return 0;
}
```


------------

- 无关题解的吐槽

然而这个题我在现场只拿了$40$(注意暴力分$60$)，因为我写完以后没时间对拍，就数据分治，$n\le 1000$直接$n^2\log n$暴力处理

然后...
```cpp
static long long num[1000005],cnt;
//...
sort(num+1,num+1+cnt,greater<int>());
```
用$int$比较器比较$long long$，结果排在最前面的全是接近$2^{31}$的数而不是真的最大值

然后就挂了$60$的暴力分

#### (数据)分治千万条，写对第一条

#### 暴力不规范，写挂两行泪

---

## 作者：Forsaken2020 (赞：1)

这个题像极了NOI2010超级钢琴，实际上写法来说，除了把主席树换成可持久化trie，把加法换成异或，其余没有任何区别，可以说是送尽了温暖(

做法其实很简单，定义sum[r] = sum[1] ^ sum[2] ^ ... sum[r - 1] ^ sum[r], 然后我们对于每一个右端点r，我们都可以知道1 - r里面的第k大异或值，做法是我们去找与sum[r]异或后能够得到第k大的sum[i], 0 <= i <= r - 1,这个只需要通过可持久化trie就能做到。那么我们设三元组(v, p, k)表示当右端点为p时，第k大异或值为v。然后我们用一个优先队列维护这个三元组，每次取出来之后接着取k + 1大，这样就能得到前k大值。不过由于不想写三元组，所以可以只用pair来写二元组，然后对于每个右端点，用数组记录取到第几大，然后每次+1就行了。下面是代码，感觉速度有点慢，尝试性优化好像也不行。
```cpp
//author Eterna
#define Hello the_cruel_world!
#pragma GCC optimize(2)
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<string>
#include<cstring>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<stack>
#include<utility>
#include<cmath>
#include<climits>
#include<deque>
#include<functional>
#include<complex>
#include<numeric>
#include<unordered_map>
#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)<(y)?(x):(y))
#define Pi acos(-1.0)
#define ABS(x) ((x) >= 0 ? (x) : (-(x)))
#define pb(x) push_back(x)
#define lowbit(x) (x & -x)
#define FRIN freopen("C:\\Users\\Administrator.MACHENI-KA32LTP\\Desktop\\in.txt", "r", stdin)
#define FROUT freopen("C:\\Users\\Administrator.MACHENI-KA32LTP\\Desktop\\out.txt", "w", stdout)
#define FAST ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
#define outd(x) printf("%d\n", x)
#define outld(x) printf("%lld\n", x)
#define il inline
#define ls(x) arr[x].child[0]
#define rs(x) arr[x].child[1]
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
typedef pair<ll, int> pli;
const int maxn = 5e5;
const int INF = 0x7fffffff;
const int mod = 1e9 + 7;
const double eps = 1e-7;
inline int read_int() {
	char c;
	int ret = 0, sgn = 1;
	do { c = getchar(); } while ((c < '0' || c > '9') && c != '-');
	if (c == '-') sgn = -1; else ret = c - '0';
	while ((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + (c - '0');
	return sgn * ret;
}
inline ll read_ll() {
	char c;
	ll ret = 0, sgn = 1;
	do { c = getchar(); } while ((c < '0' || c > '9') && c != '-');
	if (c == '-') sgn = -1; else ret = c - '0';
	while ((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + (c - '0');
	return sgn * ret;
}
struct node {
	int child[2], cnt;
}arr[50 * maxn + 5];
int tot, root[maxn + 5], n, k, pos[maxn + 5];
ll coe[40], a[maxn + 5], res;
priority_queue<pli> q;
void Insert(int& now, int pre, ll v, int cnt = 32) {
	if (!now)now = ++tot;
	arr[now].cnt = arr[pre].cnt + 1;
	if (cnt < 0)return;
	int p = (v >> cnt) & 1ll;
	arr[now].child[p ^ 1] = arr[pre].child[p ^ 1];
	Insert(arr[now].child[p], arr[pre].child[p], v, cnt - 1);
}
ll Query(int l, int r, int k, ll v, int cnt = 32) {
	if (cnt < 0)return 0;
	int p = (v >> cnt) & 1ll;
	int sum = arr[arr[r].child[p ^ 1]].cnt - arr[arr[l].child[p ^ 1]].cnt;
	if (sum >= k)return coe[cnt] + Query(arr[l].child[p ^ 1], arr[r].child[p ^ 1], k, v, cnt - 1);
	else return Query(arr[l].child[p], arr[r].child[p], k - sum, v, cnt - 1);
}
int main()
{
	coe[0] = 1;
	for (int i = 1; i <= 33; ++i)coe[i] = 2ll * coe[i - 1];
	n = read_int(), k = read_int();
	for (int i = 1; i <= n; ++i) {
		a[i] = read_ll();
		a[i] ^= a[i - 1];
		Insert(root[i], root[i - 1], a[i - 1]);
	}
	for (int i = 1; i <= n; ++i) {
		ll now = Query(root[0], root[i], 1, a[i]);
		q.push(pli(now, i));
		pos[i] = 1;
	}
	for (int i = 1; i <= k; ++i) {
		pli now = q.top();
		q.pop();
		res += now.first;
		if (pos[now.second] <= now.second) {
			++pos[now.second];
			ll u = Query(root[0], root[now.second], pos[now.second], a[now.second]);
			q.push(pli(u, now.second));
		}
	}
	outld(res);
	//system("pause");
	return 0;
}
```


---


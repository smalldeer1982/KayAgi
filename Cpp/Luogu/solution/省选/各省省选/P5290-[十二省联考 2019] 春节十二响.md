# [十二省联考 2019] 春节十二响

## 题目背景

“清明时节雨纷纷，路上行人欲断魂。”

$2075$ 年的清明没有春雨。在漫天飞雪的笼罩下，穿行在冰原间的，只有载着人类微薄希望的雪地车。

遥遥 $4.22$ 光年的征途，对于地球这孤独的旅人而言，恐怕也是无比寂寞吧。

## 题目描述

距离苏拉威西只有一百公里了，车内的空气比窗外更加冰冷。四双眼睛紧盯着艾莉
芬面前的屏幕，那是控制行星发动机的关键程序：春节十二响。他需要将其部署到电力控制系统的一个芯片中。

“春节十二响”由 $n$ 个子程序构成，第 $i$ 个子程序所需的内存空间是 $M_i$。这 $n$ 个子程序之间的调用关系构成了一棵以第 $1$ 个子程序为根的树，其中第 $i$ 个子程序在调用树上的父亲是第 $f_i$ 个子程序。

由于内存紧张，电力控制芯片上提供了一种内存分段机制。你可以将内存分为若干
个段 $S_1$, $S_2$, ..., $S_k$，并将每个程序预先分配到一个固定的段。如果两个子程序没有直接或间接的调用关系，则他们可以被分配到同一个段中，反之则不能。换言之，当且仅当 $a$ 和 $b$ 在调用树上**不是祖先—后代关系**，$a$ 和 $b$ 可以被分配到同一个段中。

一个段的大小应当是所有分配到这个段的子程序所需内存大小的最大值，所有段
大小的和不能超过系统的内存大小。

现在艾莉芬想要知道，电力控制芯片至少要有多少内存，才能保证春节十二响的正
确运行。即：最少需要多大的内存，才能通过先**将内存分成若干个段**，再**把每个子程序分配到一个段中，使得每个段中分配的所有子程序之间不存在祖先—后代关系**。

## 说明/提示

#### 样例 $1$ 解释
在最优方案中，内存被划分为大小为 $10$，$20$，$30$ 的三个段，其中第 $1$ 个子程序被分配在第 $1$ 个段中，第 $2$、$3$ 个子程序被分配在第 $2$ 个段中，第 $4$、$5$ 个子程序被分配在第 $3$ 个段中。可以证明，不存在更优的方案。

#### 子任务
![img](https://s2.ax1x.com/2019/04/07/AhSGzd.png)

注意：在第 $10$、$11$、$12$ 号测试点中，$1$ 号子程序**不一定**是链的一个端点。

其中 $M$ 是所有子内存需求的最大值，即 $\max\left\{M_i\right\}$。

对于全部数据，$1 \leqslant n \leqslant2 \times 10^5$，$1 \leqslant M \leqslant 10^9$。

艾莉芬经过仔细阅读题面、认真分析数据范围后，开始编写程序求解这个问题。

$\texttt{\$$$ login Elephant}$

$\texttt{password: ********}$

艾莉芬，高级程序员。豫阳市第三工程组提醒您：

- 做题千万条，读题第一条；

- 编程不规范，爆零两行泪。

$\texttt{\$$$ cd spring}$

$\texttt{\$$$ ac spring}$

$\texttt{Spring Accepted. Score: 100/100.}$

## 样例 #1

### 输入

```
5
10 20 20 30 30
1 1 2 2```

### 输出

```
60```

## 样例 #2

### 输入

```
10
2 1 1 1 1 2 1 1 1 2
1 1 1 4 5 3 3 4 3```

### 输出

```
6```

## 样例 #3

### 输入

```
15
10 1 10 10 2 6 9 6 8 6 3 4 4 5 5
1 2 2 1 5 4 4 1 2 10 1 9 6 1```

### 输出

```
31```

# 题解

## 作者：xht (赞：85)

#### 题目地址：[P5290 [十二省联考2019]春节十二响](https://www.luogu.org/problemnew/show/P5290)

## 骗分方法

如果你实在一点思路也没有，暴力都不会打，那么请考虑一下骗分。

### 方法一

输出所有 $M$ 的和。

期望得分：0分。

~~实际还有5分~~

### 方法二

注意到有 $15$ 分为一条链，分两种情况考虑：

1. 1号点有一个儿子——详见方法一。
2. 1号点有两个儿子——把对这两个儿子下的两条链弄成两个堆，每次取出两个堆的堆顶，取 $max$ 加入答案，当一个堆取尽后，把另一个堆里的所有元素加入答案，最后加入 $M_1$ 。

期望得分：15分。

## 暴力方法

如果你的暴力时间复杂度很低并且常数很优秀，那么拿到一道题的大部分分数是很容易的。

### 方法三

可以写一个很高超的纯暴搜过掉数据较小的2~4个点。

~~然而说实话这道题写纯暴搜的难道貌似大于写正解2333~~

时间复杂度：不详。

期望得分：10~20分。

### 方法四

如果两个点是祖先后代关系，则在这两点之间连边，最终会形成一个 $n$ 个点的图。则答案是这个图的一个最大独立集。

图的最大独立集是 **NPC** 问题，最快的方法貌似是状压， $O(3^n)$ 。

期望得分：45分。

### 方法五

借用方法四的思想，如果 $x,y$ 是祖先后代关系，则 $a_{x,y}$ 为 $1$ ，否则为 $0$ ，这样可以构造出来一个 $n \times n$ 的 01 矩阵。

按 $M$ 值从大到小贪心地选。每选择一个就再从大到小把能选的都选上，然后把选择的这个的 $M$ 值加入答案。

由于每次选完之后都要更新可选的集合，这个更新是 $O(n)$ 的，而每次选择一个之后，还有要从大到小把能选的都选上，这个过程也是 $O(n)$ 的，一共要进行 $O(n)$ 次选择，所以总时间复杂度为 $O(n^3)$ 的。

期望得分：45分。

### 方法六

从方法四的 $O(3^n)$ 到方法五 $O(n^3)$ ，期望得分没变海星。

考虑优化方法五，我们在方法五中看到这两个词：01 矩阵，集合。尝试用 **bitset** 优化，时间复杂度严格来讲没变，但是常数变成原来的 $\frac{1}{64}$ 。

期望得分：60分。

### 方法七

换一种思路。

考虑类似方法二的第 $2$ 种情况合并两颗子树。

时间复杂度： $O(n^2)$ 。

期望得分：60分。

## 考场代码

我在考场上写出来的代码是方法六和方法二的结合版，得分为 $75$ 分。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define pii pair<int, int>
#define mp make_pair
using namespace std;
const int N = 2e5 + 6;
int n, a[N], f[N];
ll ans = 0;

inline int rd() {
    int x = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9') ch = getchar();
    while (ch >= '0' && ch <= '9') x = x * 10 + (ch - '0'), ch = getchar();
    return x;
}

inline bool pd1() {
    for (int i = 2; i <= n; i++) if (f[i] != i - 1) return 0;
    return 1;
}

inline void P101112_1() {
    for (int i = 1; i <= n; i++) ans += a[i];
    cout << ans << endl;
}

namespace P101112_2 {
    int deg[N];

    inline bool pd() {
        for (int i = 2; i <= n; i++) ++deg[f[i]];
        if (deg[1] != 2) return 0;
        for (int i = 2; i <= n; i++) if (deg[i] > 1) return 0;
        return 1;
    }

    int son[N];
    priority_queue<int> q[2];

    inline void work() {
        int g[2], t = 0;
        for (int i = 2; i <= n; i++)
            if (f[i] == 1) g[t++] = i;
            else son[f[i]] = i;
        ans = a[1];
        for (int i = 0; i < 2; i++) {
            int x = g[i];
            while (x) q[i].push(a[x]), x = son[x];
        }
        while (q[0].size() && q[1].size())
            ans += max(q[0].top(), q[1].top()), q[0].pop(), q[1].pop();
        for (int i = 0; i < 2; i++)
            if (q[i].size())
                while (q[i].size()) ans += q[i].top(), q[i].pop();
        cout << ans << endl;
    }
}

namespace TX {
    const int M = 2e3 + 6;
    bitset<M> b[M], o, v;
    vector<int> e[M];
    int st[M], top = 0, p[M];
    pii g[M];

    void dfs(int x) {
        b[p[x]] = o;
        for (int i = 1; i <= top; i++) b[p[st[i]]][p[x]] = 0;
        st[++top] = x;
        o[p[x]] = 0;
        for (unsigned int i = 0; i < e[x].size(); i++) {
            int y = e[x][i];
            if (!o[p[y]]) continue;
            dfs(y);
        }
        o[p[x]] = 1;
        --top;
    }

    inline void work() {
        for (int i = 2; i <= n; i++) e[f[i]].push_back(i);
        for (int i = 1; i <= n; i++) g[i] = mp(a[i], i);
        sort(g + 1, g + n + 1);
        for (int i = 1; i <= n; i++) p[g[i].second] = i;
        o.set();
        dfs(1);
        v.reset();
        for (int i = n; i; i--) {
            if (v[i]) continue;
            o = b[i];
            ans += g[i].first;
            v[i] = 1;
            for (int j = i - 1; j; j--)
                if (o[j] && !v[j]) {
                    v[j] = 1;
                    o &= b[j];
                }
        }
        cout << ans << endl;
    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) a[i] = rd();
    for (int i = 2; i <= n; i++) f[i] = rd();
    if (pd1()) {
        P101112_1();
        return 0;
    }
    if (P101112_2::pd()) {
        P101112_2::work();
        return 0;
    }
    if (n < 2001) {
        TX::work();
        return 0;
    }
    return 0;
}
```

## 正确方法

### 方法八

方法七是 $O(n^2)$ 的，思考瓶颈在哪儿？

合并两颗子树 $x,y$ 时，我们相当于进行了 $O(max(size_x,size_y))$ 。

能否将复杂度降到 $O(min(size_x,size_y))$ ？

先考虑降复杂度之后，总的时间复杂度是多少？

降复杂度之后，相当于每一次合并，用 $O(min(size_x,size_y))$ 扔掉了 $min(size_x,size_y)$ 个元素。换句话说，扔掉一个元素是 $O(1)$ 的。我们要把 $n$ 个元素经过若干次合并，扔掉 $O(n)$ 个元素，最终剩下 $1$ 个元素。那么扔元素的复杂度为 $O(n)$ ，考虑堆的影响，总时间复杂度为 $O(n\ log\ n)$ 。

时间复杂度满足限制，可以放心的回去考虑如何降复杂度了。

当我们取完 $min(size_x,size_y)$ 个元素后，一个堆是空的，另一个堆还剩下一些元素。

那我们直接把刚才取出来的元素再塞到非空的那个堆中不就完了么？

~~蛤？正解这么暴力？~~

我再告诉你，这个正解还有个好听的名字：启发式合并。

## 代码实现细节

有一个小细节是，代码实现中会出现 **swap** 两个堆的情况。

在 **ouuan** 的博客[十二省联考2019 游记 & 题解](https://ouuan.github.io/%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019-%E6%B8%B8%E8%AE%B0-%E9%A2%98%E8%A7%A3/#more)中，对此有这样的说法：

> **swap** 在不开 **C++11** 的情况下是 $O(n)$ 的，开 **C++11** 则是 $O(1)$ 的，如果不开 **C++11** 可以记录 **id** 然后交换 **id** 。

~~最终的代码真心好写而且好短QwQ~~

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 6;
int n, a[N], f;
vector<int> e[N], o;
priority_queue<int> q[N];

inline void merge(int x, int y) {
	if (q[x].size() < q[y].size()) swap(q[x], q[y]);
	while (q[y].size()) {
		o.push_back(max(q[x].top(), q[y].top()));
		q[x].pop(), q[y].pop();
	}
	while (o.size()) q[x].push(o.back()), o.pop_back();
}

void dfs(int x) {
	for (unsigned int i = 0; i < e[x].size(); i++)
		dfs(e[x][i]), merge(x, e[x][i]);
	q[x].push(a[x]);
}

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 2; i <= n; i++) scanf("%d", &f), e[f].push_back(i);
	dfs(1);
	long long ans = 0;
	while (q[1].size()) ans += q[1].top(), q[1].pop();
	cout << ans << endl;
	return 0;
}
```

---

## 作者：TopCarry (赞：32)

## 启发式合并并不是$O(nlog^2n)$,而是$O(nlogn)$。
####
&emsp;&emsp;做法：由链的部分分可以发现，对于一条链可以直接对于左右各开一个堆，然后每次左右各弹一个取$max$,我们思考怎么由链拓宽到树上。

&emsp;&emsp;以二叉树为例，它的每一个二叉可以看做一条链，左右两部分按照部分分的方式合并之后就变成了条新的链，链上每个点为之前两条“子链”的两个对应点的$max$,然后递归的做下去就好了。

&emsp;&emsp;至于多叉树，显然和二叉树一样。
#### 时间复杂度
&emsp;&emsp;发下来的$solution$以及楼上的题解中都有提到，认为它是$log^2$,但是请注意，这道题和传统的启发式合并并不一样，因为它并没有“合并”进去，而是把小的那部分“贴”上去后直接把小的“丢掉了”，每个点只会被遍历一次，而每弹出一个点是$log$的，所以总时间复杂度是$O(nlogn)$。
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
static char buf[100000],*pa,*pd;
#define gc pa==pd&&(pd=(pa=buf)+fread(buf,1,100000,stdin),pa==pd)?EOF:*pa++
inline int read(){
 	register int x(0),f(1);register char c(gc);
	while(c>'9'||c<'0')f=c=='-'?-1:1,c=gc;
	while(c>='0'&&c<='9')x=x*10+c-48,c=gc;
	return f*x;
} 
const int N=1100000;
struct edge{
 	int to,next;
}e[N];
int head[N],tot;
void add(int x,int y){
 	e[++tot].next=head[x];e[tot].to=y;head[x]=tot;
} 
#define ll long long 
ll ans,val[N];
int n,po[N];
priority_queue<ll> son[N];
ll now[N];
int cnt;
void dfs(int u){
	po[u]=u;
 	for(int i=head[u];i;i=e[i].next){
		dfs(e[i].to);
	 	if(i==head[u]){
		 	po[u]=po[e[i].to];
		} 
		else{
		 	if(son[po[u]].size()<son[po[e[i].to]].size())swap(po[u],po[e[i].to]);
			cnt=0;
			while(!son[po[e[i].to]].empty()){
				now[++cnt]=max(son[po[e[i].to]].top(),son[po[u]].top());son[po[u]].pop();son[po[e[i].to]].pop();
			}
			for(int j=1;j<=cnt;j++)
				son[po[u]].push(now[j]);
		} 
	}
	son[po[u]].push(val[u]);
} 
int main(){
	freopen("spring.in","r",stdin);
	freopen("spring.out","w",stdout);
	n=read();
	register int i;
	for(i=1;i<=n;i++)val[i]=read();
	for(i=2;i<=n;i++){
	 	int fa=read();add(fa,i);
	} 
	dfs(1);
	while(!son[po[1]].empty()){
		ans+=son[po[1]].top();son[po[1]].pop();
	}
	cout<<ans;
	return 0;
} 
```


---

## 作者：Owen_codeisking (赞：26)

不知道别人怎么写的，所以来讲一讲我自己的心路历程。

### $n\leq 2000$

可以贪心。先按权值从大到小排序，然后依次判一个点是否包含一个点。若没有包含关系，就直接加入集合中。

那怎么判一个点 $x$ 是否另一个点 $y$ 存在包含关系呢？$(a_x>a_y)$

1. $x$ 在 $y$ 的子树中，即 $st_y\leq id_x\leq ed_y$，开一个单点加区间查的树状数组即可。

2. $y$ 在 $x$ 的子树中，即 $st_x\leq id_y\leq ed_x$，开一个区间加单点查的树状数组即可。

时间复杂度 $O(n^2\log n)$

因为实际上常数根本跑不满，所以 $n\leq 2000$ 可以随便过。

### 树是一条链（$1$ 不一定是链的端点）

其实链的部分分已经提示你正解了。

容易发现 $1$ 最多有两个支链，所以我们暴力找出这两条链的所有权值，然后 $sort$ 一下，将两条支链对应的权值相加即可。

时间复杂度 $O(n\log n)$

### 正解

借鉴目前 $loj$ 最优解 $relyt871$ 的思路。

其实链的部分分已经提示你可以尝试合并两个集合的最大值了。

我们对于每个点都开一个堆，每次将 $siz$ 较小的合并到 $siz$ 较大的堆中。

因为每个点只会被合并 $\log n$ 次，时间复杂度 $O(n\log^2 n)$

$Upd$：时间复杂度 $O(n\log n)$

[$loj$ 评测记录证明只 $merge$ 了 $n$ 次](https://loj.ac/submission/409771)

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=200000+10;
int n,a[maxn],fa[maxn],tmp[maxn],id[maxn],tim;
int head[maxn],to[maxn],nxt[maxn],tot;
priority_queue<int> q[maxn];

inline int read()
{
	register int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return (f==1)?x:-x;
}

inline void addedge(int x,int y)
{
	to[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}

void dfs(int x)
{
	id[x]=++tim;
	for(int i=head[x];i;i=nxt[i])
	{
		int y=to[i];dfs(y);
		if(q[id[x]].size()<q[id[y]].size()) swap(id[x],id[y]);
		int m=q[id[y]].size();
		for(int i=1;i<=m;i++)
		{
			tmp[i]=max(q[id[x]].top(),q[id[y]].top());
			q[id[x]].pop();q[id[y]].pop();
		}
		for(int i=1;i<=m;i++) q[id[x]].push(tmp[i]);
	}
	q[id[x]].push(a[x]);
}

int main()
{
	n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=2;i<=n;i++) fa[i]=read(),addedge(fa[i],i);
	dfs(1);
	ll ans=0;
	while(!q[id[1]].empty()) ans+=q[id[1]].top(),q[id[1]].pop();
	printf("%lld\n",ans);
	return 0;
}
```

暴力的 $code$ 就不给啦，有兴趣去我 $loj$ 的提交记录上看好了。

---

## 作者：TheLostWeak (赞：15)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu5290.html)

**大致题意：** 给你一棵有$n$个节点的树，要求你将一个长度为$n$的序列划分成若干段，使得任意一段中没有两个数满足它们在树上是祖先——后代关系。请你求出每一段最大值之和的最小值。

### 大致思路

这题应该是比较水的一道**堆**的题目。

考虑到不能有祖先——后代关系，则显然，以$x$为根的子树内的答案，肯定要与以$fa_x$的其他儿子为根的子树内的答案合并。

而怎么合并呢？

假设我们当前要合并分别以$x,y$为根的两棵子树的答案。

一个**贪心**的思想，似乎<u>分别将两棵子树内的答案从大到小排序，然后再依次合并两棵子树内的答案（取较大值）</u>，就是最优的方案！

而针对多棵子树的合并，我们只要将其依次两两合并即可。

当我们合并完一个点的所有子树的答案之后，再在得到的这个答案序列中加入该点的权值，就可以得到该点的答案序列了。

最后的答案就是$1$号节点的答案序列中所有数之和。

### 正确性证明

为什么前面提到的那种合并答案的做法是正确的呢？

让我们以两个答案序列各自只有两个数$x_1,x_2$和$y_1,y_2$（$x_1\ge y_1,x_1\ge x_2,y_1\ge y_2$）为例（其余情况可以由此推广），因为显然尽可能多匹配肯定更优，所以只有两种配对方式：

- $x_1,y_1$配对，$x_2,y_2$配对，则答案为$max(x_1,y_1)+max(x_2,y_2)$。
- $x_1,y_2$配对，$x_2,y_1$配对，则答案为$max(x_1,y_2)+max(x_2,y_1)$。

然后对于$x_1,x_2,y_1,y_2$之间的大小关系，我们再进行分类讨论：

- $x_1\ge x_2\ge y_1\ge y_2$：答案分别为$x_1+x_2$和$x_1+x_2$，两者相等。
- $x_1\ge y_1\ge x_2\ge y_2$：答案分别为$x_1+x_2$和$x_1+y_1$，显然$x_1+x_2\le x_1+y_1$。
- $x_1\ge y_1\ge y_2\ge x_2$：答案分别为$x_1+y_2$和$x_1+y_1$，显然$x_1+y_2\le x_1+y_1$。

综上所述，第一种方案（即前面提到的方案）选出的答案必然为最优解。

正确性也就得到了证明（当然，肯定有更简便的证明方式，只不过我难以将其说清楚，只能采用这种举例子的方式）。

### 具体实现

然后我们考虑如何维护这个答案序列。

考虑到要维护其从大到小的顺序，便自然可以想到用堆来维护。

我们用一个$p_i$表示**第$i$个节点的答案序列所对应的堆的编号**，初始化$p_i=i$。

然后，每次合并$x,y$时，我们先比较$p_x,p_y$两个堆的大小，然后通过$swap$使得$Size_{p_x}>Size_{p_y}$，然后将$y$的答案合并给$x$，这样时间复杂度就可以用类似于**启发式合并**的方式来证明。

合并答案的过程中我们可以开一个临时数组来存下合并后的答案。

由于在两两配对完后，$p_x$堆中还会有一些剩下的元素，因此我们把这个临时数组中的元素再全部扔入$p_x$堆中，即可得到配对后的答案序列了。

一些细节可以详见代码。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define RL Reg LL
#define Con const
#define CI Con int&
#define CL Con LL&
#define I inline
#define W while
#define N 200000
#define LL long long
#define add(x,y) (e[++ee].nxt=lnk[x],e[lnk[x]=ee].to=y)
#define max(x,y) ((x)>(y)?(x):(y))
#define swap(x,y) (x^=y^=x^=y)
using namespace std;
int n,ee,a[N+5],s[N+5],p[N+5],lnk[N+5];struct edge {int to,nxt;}e[N];
priority_queue<int> q[N+5];
class FastIO
{
    private:
        #define FS 100000
        #define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
        #define tn (x<<3)+(x<<1)
        #define D isdigit(c=tc())
        char c,*A,*B,FI[FS];
    public:
        I FastIO() {A=B=FI;}
        Tp I void read(Ty& x) {x=0;W(!D);W(x=tn+(c&15),D);}
        Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
}F;
I void dfs(CI x)//遍历树
{
    for(RI i=lnk[p[x]=x],t;i;i=e[i].nxt)//初始化p[x]为x
    {
        dfs(e[i].to),t=0,q[p[x]].size()<q[p[e[i].to]].size()&&swap(p[x],p[e[i].to]);//处理子树，通过swap的方式使p[x]堆的Size较大
        W(!q[p[e[i].to]].empty())//将元素两两配对
            s[++t]=max(q[p[x]].top(),q[p[e[i].to]].top()),//用临时数组存下来
            q[p[x]].pop(),q[p[e[i].to]].pop();//将两个堆的堆顶弹掉
        W(t) q[p[x]].push(s[t--]);//将临时数组中的元素全部扔入p[x]堆中
    }q[p[x]].push(a[x]);//将当前节点权值扔入堆中
}
int main()
{
    RI i,x;for(F.read(n),i=1;i<=n;++i) F.read(a[i]);for(i=2;i<=n;++i) F.read(x),add(x,i);//读入+建边
    RL ans=0;dfs(1);W(!q[p[1]].empty()) ans+=q[p[1]].top(),q[p[1]].pop();//遍历+统计答案
    return printf("%lld",ans),0;//输出答案
}
```



---

## 作者：龙之吻—水货 (赞：14)

# [十二省联考2019]春节十二响

## 题目大意

给定一棵树，每次选取树上的一个点集，要求点集中的每个点不能是另一个点的祖先，选出点集的代价为点集中权值最大点的权值，问将所有点都选一遍的最小代价为多少。

## 解题报告

似乎其他题解都是将整棵树最后合并成为一个链统计答案的，不过在考场上我并没有到这种方法，而是使用了一种贪心的方法。

尽管到现在我都无法证明它的正确性，但是在它的确可以通过所有的测试点，在考场上也帮我得到了 $100$ 分的，那么就暂且相信它是正确的吧 QwQ

首先，我们将所有点按从大到小的顺序进行排序，然后我们枚举每一个点，如果当前点被选过了的话就跳过。之后，我们将这点点放入一个新的点集中。然后，我们从大到小枚举这个点之后的点，能加则加，不能加就跳过，放一个伪代码就是 :

```
sort i in val
for i 1 to n :
	if i is used :
    	continue
    make a new set
    put i into the set
    for j i + 1 to n :
    	if j is used :
        	continue
        if j can't be put into set :
        	continue
        put j into set
        j is used
    	
```

那么我们现在所需要的就是判断一个点能否被放在点集中，以及找出可选点中最大的点。

显然，我们每选择一个点之后，这个点到根的路径上所有的点，以及这个点为根的子树里面所有的点都不能被选择了。

我们发现，我们现在需要一个支持在树上修改子树，修改链，查询全树最大值的数据结构，而树链剖分可以完美地解决这个问题。

具体来说就是，在线段树上的每个节点维护这段区间是否可选，以及这段区间的最大值。每向集合中加入一个点之后，先将这个点的删除，然后将这个点到根的路径上，以及这个点为根的子树打上一个不可选标记，之后每次从线段树中取出那个最大值即可。当我们选完一个集合之后，要注意把之前的不可选标记清除掉，具体实现可以看代码。

由于每个点只会被处理一次，所以总的时间复杂度为 $O(n\log^2n)$ ，虽然看起来 $2 \times 10^5$ 有点悬，但事实证明出题人并没有特意去卡这个算法，所以就可以 $AC$ 啦！

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>

class SegmentTree{
private :
    static const int maxn = 2e5 + 7;

    struct Node{
        int max, del;
        Node *child[2];

        Node() : max(0), del(0) {
            child[0] = child[1] = NULL;
        }
    };
    int n, *val;
    Node *root, pool[maxn << 2], *tp;

    Node *newNode() {
        *++tp = Node();
        return tp;
    }

    void update(Node *now) {
        now->max = 0;
        
        for (register int i = 0; i < 2; i++) {
            if (now->child[i]->del) {
                continue;
            }
            if (val[now->child[i]->max] > val[now->max]) {
                now->max = now->child[i]->max;
            }
        }
    }

    void buildTree(Node *now, int left, int right) {
        if (left == right) {
            now->max = left;
            return;
        }
        int mid = (left + right) >> 1;
        buildTree(now->child[0] = newNode(), left, mid);
        buildTree(now->child[1] = newNode(), mid + 1, right);
        update(now);
    }

    void delMax(Node *now, int left, int right, int l, int r) {
        if (left >= l && right <= r) {
            now->del = 1;
            return;
        }
        int mid = (left + right) >> 1;
        if (r <= mid) {
            delMax(now->child[0], left, mid, l, r);
        } else if (l > mid) {
            delMax(now->child[1], mid + 1, right, l, r);
        } else {
            delMax(now->child[0], left, mid, l, r);
            delMax(now->child[1], mid + 1, right, l, r);
        }
        update(now);
    }

    void addMax(Node *now, int left, int right, int l, int r) {
        if (left >= l && right <= r) {
            now->del = 0;
            return;
        }
        int mid = (left + right) >> 1;
        if (r <= mid) {
            addMax(now->child[0], left, mid, l, r);
        } else if (l > mid) {
            addMax(now->child[1], mid + 1, right, l, r);
        } else {
            addMax(now->child[0], left, mid, l, r);
            addMax(now->child[1], mid + 1, right, l, r);
        }
        update(now);
    }

    void eraseMax(Node *now, int left, int right, int pos) {
        if (left == right) {
            now->max = 0;
            return;
        }
        int mid = (left + right) >> 1;
        if (pos <= mid) {
            eraseMax(now->child[0], left, mid, pos);
        } else {
            eraseMax(now->child[1], mid + 1, right, pos);
        }
        update(now);
    }
    
public :
    void init(int x, int *m) {
        n = x, val = m, tp = pool;
        buildTree(root = newNode(), 1, n);
    }

    void delMax(int l, int r) {
        //printf("del : %d %d\n", l, r);
        delMax(root, 1, n, l, r);
    }

    void addMax(int l, int r) {
        //printf("add : %d %d\n", l, r);
        addMax(root, 1, n, l, r);
    }

    void eraseMax(int pos) {
        eraseMax(root, 1, n, pos);
    }

    int queryMax() {
        //printf("%d %d\n", root->del, root->max);
        return root->del ? 0 : root->max;
    }
};

const int maxn = 2e5 + 7;
int m[maxn];

class Solution{
private :
    typedef long long ll;
    typedef std::pair<int, int> par;

    int n, id[maxn], fa[maxn], size[maxn], son[maxn], top[maxn];
    int h[maxn], cnt, dfn[maxn], red[maxn], end[maxn], val[maxn];
    ll ans;
    bool used[maxn], have[maxn];
    std::vector<int> e[maxn];
    std::queue<int> q;
    SegmentTree tree;

    static bool cmp(int a, int b) {
        return m[a] > m[b];
    }

    void DFS1(int now) {
        h[now] = h[fa[now]] + 1;
        size[now] = 1;
        for (auto v : e[now]) {
            DFS1(v);
            size[now] += size[v];
            if (size[v] > size[son[now]]) {
                son[now] = v;
            }
        }
    }

    void DFS2(int now, int tp) {
        red[end[now] = dfn[now] = ++cnt] = now;
        val[cnt] = m[now];
        top[now] = tp;
        if (son[now]) {
            DFS2(son[now], tp);
            end[now] = end[son[now]];
        }
        for (auto v : e[now]) {
            if (v == son[now]) {
                continue;
            }
            DFS2(v, v);
            end[now] = end[v];
        }
        //printf("%d : %d %d\n", now, dfn[now], end[now]);
    }

    inline void mark(int now) {
        q.push(now);
        tree.eraseMax(dfn[now]);
        for (register int i = now; i && !have[i]; i = fa[top[i]]) {
            tree.delMax(dfn[top[i]], dfn[i]);
        }
        tree.delMax(dfn[now], end[now]);
        //DFS(now);
    }

    inline void delMark(int now) {
        for (register int i = now; i && !have[i]; i = fa[top[i]]) {
            tree.addMax(dfn[top[i]], dfn[i]);
        }
        tree.addMax(dfn[now], end[now]);
    }

    void DFS(int now) {
        have[now] = 1;
        for (auto v : e[now]) {
            DFS(v);
        }
    }

public :
    Solution() {
        get();
        solve();
    }

    void get() {
        scanf("%d", &n);
        for (register int i = 1; i <= n; i++) {
            scanf("%d", m + i);
            id[i] = i;
            //pq.push(std::make_pair(m[i], i));
        }
        for (register int i = 2; i <= n; i++) {
            scanf("%d", fa + i);
            e[fa[i]].push_back(i);
        }
    }

    void solve() {
        DFS1(1);
        DFS2(1, 1);
        //printf("%d\n", dfn[11]);
        tree.init(n, val);
        //printf("%d %d\n", dfn[1], end[1]);
        for (register int now = tree.queryMax(); now; now = tree.queryMax()) {
            now = red[now];
            //printf("%d : ", now);
            ans += m[now];
            mark(now);
            for (register int p = tree.queryMax(); p; p = tree.queryMax()) {
                p = red[p];
                //printf("%d ", p);
                mark(p);
            }
            while (!q.empty()) {
                delMark(q.front());
                q.pop();
            }
            //putchar('\n');
        }
        printf("%lld\n", ans);
    }
};
Solution sol;

int main() {}

```

---

## 作者：L_M_ (赞：11)

神tm一道蓝题，我考试的时候都在想啥...

考虑一条链，显然你是把两个链分别的最大值放在一起，次大值放在一起，等等

那么如果有多个链呢？你就把第一个链和第二个链按上面的操作，得到的新的结果再和第三个链合并...

正确性挺显然的...qwq

```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<iostream>
using namespace std;
#define O(x) cout << #x << " " << x << endl;
#define B cout << "breakpoint" << endl;
inline int read()
{
    int ans = 0,op = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9')
    {
        if(ch == '-') op = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
    {
        (ans *= 10) += ch - '0';
        ch  = getchar();
    }
    return ans * op;
}
typedef long long ll;
const int maxn = 2e5 + 5;
struct node
{
	int to,next,cost;
}e[maxn << 1];
int fir[maxn],alloc;
void adde(int u,int v)
{
	e[++alloc].next = fir[u];
	fir[u] = alloc;
	e[alloc].to = v;
	swap(u,v);
	e[++alloc].next = fir[u];
	fir[u] = alloc;
	e[alloc].to = v;
}
int a[maxn];
int id[maxn],cnt,tp[maxn];
priority_queue<int> q[maxn];
void dfs(int u,int fa)
{
	//O(u);
	id[u] = ++cnt;
	for(int i = fir[u];i;i = e[i].next)
	{
		int v = e[i].to;
		if(v == fa) continue;
		dfs(v,u);
		if(q[id[u]].size() < q[id[v]].size()) swap(id[u],id[v]);
		int tot = q[id[v]].size();
		for(int i = 1;i <= tot;i++)
		{
			tp[i] = max(q[id[u]].top(),q[id[v]].top());
			q[id[u]].pop(),q[id[v]].pop();
		}
		for(int i = 1;i <= tot;i++) q[id[u]].push(tp[i]);
	}
	q[id[u]].push(a[u]);
}
int main()
{
	int n = read();
	for(int i = 1;i <= n;i++) a[i] = read();
	for(int i = 2;i <= n;i++) {int f = read(); adde(f,i);}
	dfs(1,0);
	ll ans = 0;
	while(q[id[1]].size()) ans += q[id[1]].top(),q[id[1]].pop();
	printf("%lld",ans);
}
		

```



---

## 作者：ecnerwaIa (赞：6)

[题目传送门](https://www.luogu.org/problemnew/show/P5290)



------------

### 个人吐槽，可以直接跳

真的是省选救命题！

D1T1和超级钢琴很想，然而...我考试时没写出来可持久化trie，哎，40分没了，D1T2好像我加点优化就可以60-80了？？可我只拿了40，D1T3smg啊！题面说什么打小一点的表？结果死也没想到是道数论题...拿了4分，还花了一个半小时。难受...

本以为凉了，好在有D2T2。



------------

一开始想到的就是树形DP,子树合并，两颗子树之间是没有限制条件的，最后加入根节点的权值。发现这怎么DP?

和树形DP思想一样，合并两颗子树，只要同一颗子树的每个内存块不再被分到一个内存块中就好了，又因为我们保证了每颗子数都是最优的，那么不就是假如有$A,B,A$的内存块是不能再和$A$中的合并，$B$同理（也许是废话吧）

所以只能$A->B,B->A$，而且每个内存块只能合并到最多一个上，或者被最多一个上面，那么肯定是$A,B$从大到小合并是最优的。

假设我们先考虑只将$A$合并到$B$上，那么肯定是在$B$找到一个$A$的后继（没有跟$A$合并）并且合并上去，然后那么$B$呢？也一样，那么怎么同时满足两个呢？根据对称性，就很容易知道肯定是从大到小逐个比较，只保留最大的一个。（对称性的话其实一下可以想出这个贪心）

那么写个中序遍历启发式合并就好了，关于启发式合并复杂度有论文，是O(nlogn),然后因为这题每次合并$siz==>max(sizA,sizB)$，所以实际上跑的飞快

```cpp
// luogu-judger-enable-o2
#pragma GCC optimize(3)
#pragma GCC optimize(2)
#include <cstdio>
#include <cstdlib>
#include <cstring>
using namespace std;
const int M=1<<20;
char In[M],*S,*T;
#define nc() (S==T&&(T=(S=In)+fread(In,1,M,stdin),S==T)?EOF:*S++)
template<typename C>
inline void read(C &x){
    x=0;char ch=nc();
    while(ch<'0'||ch>'9')ch=nc();
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=nc();}
}
const int N=200010;
template<typename T>
inline void Swap(T&a,T&b){T c=a;a=b;b=c;}
int siz[N];
struct node{
    node*ch[2],*fa;
    int v;
}*rt[N],*null;
#define lc x->ch[0]
#define rc x->ch[1]
inline node*New(int v){node*x=new node;lc=rc=x->fa=null;x->v=v;return x;}
inline void rotate(node*x){
    node*y=x->fa,*z=y->fa;int k=y->ch[1]==x;
    z->ch[z->ch[1]==y]=x;x->fa=z;
    y->ch[k]=x->ch[k^1];x->ch[k^1]->fa=y;
    x->ch[k^1]=y;y->fa=x;
}inline void splay(int pos,node*x,node*goal){
    node*y,*z;
    while(x->fa!=goal){
        y=x->fa;z=y->fa;
        if(z!=goal)(y->ch[1]==x)^(z->ch[1]==y)?rotate(x):rotate(y);
        rotate(x);
    }if(goal==null)rt[pos]=x;
}inline void Insert(int pos,int v){
    node*x=rt[pos];++siz[pos];
    if(x==null){rt[pos]=New(v);return;};
    node*fa=null;
    while(x!=null)fa=x,x=x->ch[v>=x->v];
    x=New(v);x->fa=fa;fa->ch[v>=fa->v]=x;
    splay(pos,x,null);
}inline void Del(int pos){--siz[pos];
    node*x=rt[pos];int k;
    if(lc!=null)k=0;
    else if(rc!=null)k=1;
    else {rt[pos]=null;delete(x);return;}
    node*y=x->ch[k];
    while(y->ch[k^1]!=null)y=y->ch[k^1];
    splay(pos,y,x);y->ch[k^1]=x->ch[k^1];x->ch[k^1]->fa=y;y->fa=null;rt[pos]=y;
    delete(x);
}inline void del(int pos,int v){
    node*x=rt[pos];
    while(x!=null){
        if(x->v^v)x=x->ch[v>=x->v];
        else {splay(pos,x,null);Del(pos);return;}
    }
}int a[N],b[N],R1,R2;
inline void dfs_1(node*x){if(x==null)return;dfs_1(rc);a[++R1]=x->v;dfs_1(lc);delete(x);}
inline void dfs_2(node*x){if(x!=null&&R2<R1){dfs_2(rc);if(R2>=R1)return;b[++R2]=x->v;dfs_2(lc);}}
inline void Merge(int x,int y){
    R1=R2=0;int p=x;
    if(siz[x]>siz[y])Swap(x,y);
    dfs_1(rt[x]);dfs_2(rt[y]);
    for(int i=1;i<=R1;++i)
        if(a[i]>b[i])del(y,b[i]),Insert(y,a[i]);
    if(p^x){Swap(rt[x],rt[y]);Swap(siz[x],siz[y]);}
}int d[N],nxt[N<<1],to[N<<1],cost[N],tot;
inline void ins(int a,int b){to[++tot]=b;nxt[tot]=d[a];d[a]=tot;}
inline void work(int x){
    for(int i=d[x];i;i=nxt[i]){
        int u=to[i];
        work(u);Merge(u,x);
    }Insert(x,cost[x]);
}int n;
long long ans;
inline void slove(node*x){if(x==null)return ;ans+=x->v;slove(lc);slove(rc);}
int main(){null=new node;null->ch[0]=null->ch[1]=null->fa=null;
    read(n);int fa;
    for(int i=1;i<=n;++i)read(cost[i]),rt[i]=null;
    for(int i=2;i<=n;++i)read(fa),ins(fa,i);
    work(1);slove(rt[1]);printf("%lld\n",ans);
    return 0;
}

```



---

## 作者：FZzzz (赞：5)

这可能是最水的一道十二省题了，连之一都不用加。

~~甚至有可能是目前洛谷最水黑题之一。~~

------------
说一下我的思路吧。

考虑一棵子树，显然根节点是只能单开一个段的，所以这棵子树的最优解的每一个段中肯定是这棵子树的不同子树中的。

那我们可以考虑树上贪心。

**upd：~~第一次竟然写的是点分，黑历史。~~**

考虑证明最优子结构性质：

如果有两个节点，它们在局部最优解中被分在一个段，而在全局最优解中不是，则把其中空间小的那个挪到另一个的段中，结果不会更差。

考虑如何合并局部最优解。

容易发现，我们应该把小的合并到大的里面。于是我们得到算法：用堆维护局部最优解中每个段，合并时取出所有堆顶元素中最大的一个丢到答案中。

考虑证明算法正确性。

如果对于某个堆，不把堆顶元素合并出去，那么这个元素有两种可能：
- 成为另一个段的最大值，则答案变差。
- 合并到另一个段里，则答案不变。

于是完整解决了问题。代码如下：
```cpp
#include<algorithm>
#include<vector>
#include<queue>
#include<cctype>
#include<cstdio>
using namespace std;
inline int readint(){
	int x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-'){
		f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=2e5+5;
int n,m[maxn];
vector<int> ch[maxn];
priority_queue<int> pq[maxn];
void dfs(int u){
	for(int i=0;i<ch[u].size();i++) dfs(ch[u][i]);
	pq[u].push(m[u]);
	while(1){
		int mm=0;
		for(int i=0;i<ch[u].size();i++){
			if(pq[ch[u][i]].empty()) continue;
			mm=max(mm,pq[ch[u][i]].top());
			pq[ch[u][i]].pop();
		}
		if(!mm) break;
		pq[u].push(mm);
	}
}
int main(){
	#ifdef LOCAL
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
    #endif
    n=readint();
    for(int i=1;i<=n;i++) m[i]=readint();
    for(int i=2;i<=n;i++) ch[readint()].push_back(i);
    dfs(1);
    long long ans=0;
    while(!pq[1].empty()){
    	ans+=pq[1].top();
    	pq[1].pop();
	}
	printf("%lld\n",ans);
    return 0;
}
```


------------
然而这样是会T的，只有60分。

~~我T了以后第一反应竟然是开O2再交一遍。~~

显然很多时间浪费在了合并上，考虑优化合并方式。

考虑启发式合并。

两两合并，每次取两个堆顶元素中小的那个，最后把所有元素放回尺寸大的那个堆里并使之成为新的堆。

两两合并与上面那种方法的等价性是可证的，证明略。

时间复杂度$O(n\log n)$，下面是我口胡的证明：

首先只考虑分治显然是$O(n\log n)$的，然后每个段被合并以后就没了，所以花在堆上的时间是$O(n\log n)$，总时间$O(n\log n)$。

据说`swap`的复杂度并不是严格$O(1)$，所以这里使用指针。

还有，没开`long long`见祖宗。

下面是~~奇丑无比的~~代码：
```cpp
#include<algorithm>
#include<vector>
#include<queue>
#include<cctype>
#include<cstdio>
using namespace std;
inline int readint(){
	int x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-'){
		f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=2e5+5;
int n,m[maxn];
vector<int> ch[maxn];
priority_queue<int>* pq[maxn];
void merge(priority_queue<int>* q1,priority_queue<int>* q2){
	vector<int> v;
	while(!q2->empty()){
	    v.push_back(max(q1->top(),q2->top()));
	    q1->pop();
	    q2->pop();
	}
	for(int i=0;i<v.size();i++) q1->push(v[i]);
}
void dfs(int u){
	if(ch[u].empty()){
		pq[u]=new priority_queue<int>();
		pq[u]->push(m[u]);
		return;
	}
	for(int i=0;i<ch[u].size();i++) dfs(ch[u][i]);
	pq[u]=pq[ch[u][0]];
	for(int i=1;i<ch[u].size();i++){
		if(pq[u]->size()<pq[ch[u][i]]->size()) swap(pq[u],pq[ch[u][i]]);
	    merge(pq[u],pq[ch[u][i]]);
	}
	pq[u]->push(m[u]);
}
int main(){
	#ifdef LOCAL
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
    #endif
    n=readint();
    for(int i=1;i<=n;i++) m[i]=readint();
    for(int i=2;i<=n;i++) ch[readint()].push_back(i);
    dfs(1);
    long long ans=0;
    while(!pq[1]->empty()){
    	ans+=pq[1]->top();
    	pq[1]->pop();
	}
	printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：zeertzjq (赞：5)

蒟蒻退役三周后回来做这道因为当时没写启发式合并而只得了$60$分的题，写了个配对堆启发式合并上了rk1，发现没有配对堆的题解，于是来写一篇。 

相比`std::priority_queue`，这题用配对堆的好处有：
* $O(1)$合并（这里用“插入”好像更不容易引起歧义）
* 不用担心MLE
* 常数小

# 不会配对堆？
不带修改的配对堆只需要这几行代码就够了：
***
`c[x]`记录`x`最左边的一个儿子，`sib[x]`记录`x`的右兄弟，没有则为`0`（这似乎叫做“兄弟儿子表示法”？）
```cpp
int c[N], sib[N];
```
合并两个堆：直接把较小（或较大）的根插入到较大（或较小）的根的儿子列表中，时间复杂度为$O(1)$
```cpp
inline int mrg(int x, int y) {
    if (!x || !y) return x | y;
    if (m[x] < m[y]) swap(x, y); // 这是大根堆，小根堆这里改成大于号即可
    sib[y] = c[x], c[x] = y;
    return x;
}
```
合并一个根的所有儿子：先两两配对合并，再从右向左合并，单次最坏时间复杂度为$O(n)$，但均摊为$O(\log n)$
```cpp
int mrgl(int l0) {
    if (!l0 || !sib[l0]) return l0;
    int l1 = sib[l0], l2 = sib[l1];
    sib[l0] = sib[l1] = 0;
    return mrg(mrg(l0, l1), mrgl(l2));
}
```
***
# 本题的做法
注：以下将“子程序”称为“节点”

* 每个节点开一个大根堆，初始堆中只有当前节点
* 在树上dfs，遍历完一个节点的所有子节点后：
	- 取堆最大的子节点（好像这就叫“启发式”？）和另一个子节点
    - 开一个新的堆
    - 因为两棵子树中的节点一定没有祖先—后代关系，不断把两个堆顶节点取出并比较所需内存大小，把较大的一个加入新的堆，直到较小的堆为空
    - 把新的堆合并到原先较大的堆上
    - 重复以上四步，直到所有子节点合并完毕
    - 把堆最大的子节点的堆合并到当前节点的堆上（或者说把当前节点加入堆）
* 根节点的堆中所有节点所需内存之和即为最小内存需求

#### 时间复杂度
注：虽然是启发式合并，但是~~我太菜了~~有些地方需要用长链剖分中的概念才能解释清楚
* 令$h$为从根节点出发的长链的长度
* 每个节点属于且仅属于一条长链
* 除从根节点出发的长链外，每条长链仅在其顶部被合并到另一条长链上，合并时出堆的节点数为被合并的链长的两倍
* 因此出堆的节点总数为$2(n-h)$
* 再算上dfs的$O(n)$和求和的$O(h)$，这种做法的时间复杂度为$O(n+h+(n-h)\log h)$

#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

// 读入输出优化开始
inline int gi() {
    int x, f = 0;
    char c;
    while (!isdigit(c = getchar())) c == '-' && (f = 1);
    for (x = c - '0'; isdigit(c = getchar()); x = x * 10 + c - '0')
        ;
    return f ? -x : x;
}

inline long long gll() {
    int f = 0;
    long long x;
    char c;
    while (!isdigit(c = getchar())) c == '-' && (f = 1);
    for (x = c - '0'; isdigit(c = getchar()); x = x * 10 + c - '0')
        ;
    return f ? -x : x;
}

template <typename T>
void puti(T x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) puti(x / 10);
    putchar(x % 10 + '0');
}

template <typename T>
inline void putsp(T x) {
    puti(x), putchar(' ');
}

template <typename T>
inline void putln(T x) {
    puti(x), putchar('\n');
}
// 读入输出优化结束

const int N = 200010;

// 树用c0[]和c1[]存储，堆用c[]和sib[]存储，均为“兄弟儿子表示法”
// sz[x]表示堆（不是树）中以该节点为根的子树的大小
int n, c0[N], c1[N], rt[N], m[N], c[N], sib[N], sz[N];

// 配对堆合并（别忘了更新子树大小）
inline int mrg(int x, int y) {
    if (!x || !y) return x | y;
    if (m[x] < m[y]) swap(x, y);
    sib[y] = c[x], c[x] = y, sz[x] += sz[y];
    return x;
}

// 配对堆
int mrgl(int l0) {
    if (!l0 || !sib[l0]) return l0;
    int l1 = sib[l0], l2 = sib[l1];
    sib[l0] = sib[l1] = 0;
    return mrg(mrg(l0, l1), mrgl(l2));
}

// 把根节点弹出堆
inline int pop(int u) {
    int ort = rt[u];
    rt[u] = mrgl(c[ort]), c[ort] = 0, sz[ort] = 1;
    return ort;
}

// 上面说的dfs
void dfs(int u) {
    if (!c0[u]) return;
    int mx = 0;
    for (int v = c0[u]; v; v = c1[v]) {
        dfs(v);
        if (sz[rt[v]] > sz[rt[mx]]) mx = v;
    }
    for (int v = c0[u]; v; v = c1[v])
        if (v != mx) {
            int tmp = 0;
            while (rt[v]) {
                int a = pop(mx), b = pop(v);
                tmp = mrg(tmp, m[a] > m[b] ? a : b);
            }
            rt[mx] = mrg(rt[mx], tmp);
        }
    rt[u] = mrg(rt[u], rt[mx]);
}

// 遍历堆求和
long long hsum(int rt) {
    long long ans = m[rt];
    for (int i = c[rt]; i; i = sib[i]) ans += hsum(i);
    return ans;
}

int main() {
    n = gi();
    for (int i = 1; i <= n; ++i) rt[i] = i, m[i] = gi(), sz[i] = 1;
    for (int i = 2; i <= n; ++i) {
        int f = gi();
        c1[i] = c0[f], c0[f] = i;
    }
    dfs(1);
    putln(hsum(rt[1]));
    return 0;
}
```

---

## 作者：liuzhangfeiabc (赞：5)

题目大意：给定有根树，点有点权。你需要把点划分为若干不相交的集合，使得任意集合中不存在两个点是祖先关系，并且要求最小化每个集合点权最大值的和。

在day2的一片毒瘤中难得一见的小清新题。

这题的结论很简单：显然根只能单独成一个集合，然后对每个子树独立地做下去，最后把所有子树的集合按权值从大到小依次合并即可。

这为什么是对的呢？~~看上去就很对对吧。~~

我是从链的部分分得到的启发。对于链的数据，显然一条从根向下的链上每个点必须独立成集合，最后就是合并两条链的问题。此时容易证明从大到小合并的正确性（如果不是这样的话，考虑调整法，一定不会使得答案变差）。

然后我们就自然而然地把它推广到一般情况。正解给出的证明严谨但繁琐，这里略去，就简单讲一下比较意识流的想法吧：

考虑所有点中权值最大的点，这个点显然肯定会被计算贡献。

为了让答案尽可能小，我们应该优先让这个集合去吞掉一些点权比较大的点，这样它们就不会被计入贡献了。

结果就是我们把每个子树中最大的集合拿出来合并了，剩下一个规模更小的问题继续做下去即可。

知道这个结论之后就比较容易做下去了。直接合并集合是n^2的，但是可以基于树链剖分进行优化（根继承重儿子的集合，合并所有轻儿子的集合）。我们还需要用堆来维护每个集合的最大值。

直接重链剖分可能会多一个log（当然实际上还是能随便过），但是改成长链剖分/启发式合并就是严格n log n的了。

总结：个人认为是今年省选最简单的一道。

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<ctime>
#include<queue>
using namespace std;
#define li long long
#define gc getchar()
#define pc putchar
inline li read(){
	li x = 0,y = 0,c = gc;
	while(c < '0' || c > '9') y = c,c = gc;
	while(c >= '0' && c <= '9') x = x * 10 + c - '0',c = gc;
	return y == '-' ? -x : x; 
}
inline void print(li x){
	if(x < 0) pc('-'),x = -x;
	if(x >= 10) print(x / 10);
	pc(x % 10 + '0');
}
inline void file(){
	freopen("spring.in","r",stdin);
	freopen("spring.out","w",stdout);
}
int n,fa[200010],fsts[200010],nxts[200010],ds[200010];
li a[200010];
int sz[200010],mx[200010],tou[200010];
priority_queue<li> qu[200010];
li st[200010],ft;
inline void dfs2(int q){
	for(int i = fsts[q];i;i = nxts[i]){
		dfs2(i);
		if(sz[i] > sz[mx[q]]) mx[q] = i;
		sz[q] = max(sz[q],sz[i]);
	}
	++sz[q];
}
inline void dfs3(int q){
	tou[q] = (mx[fa[q]] == q ? tou[fa[q]] : q);
	if(mx[q]) dfs3(mx[q]);
	for(int i = fsts[q];i;i = nxts[i]) if(i != mx[q]){
		dfs3(i);
		ft = 0;
		while(!qu[tou[q]].empty() && !qu[i].empty()){
			st[++ft] = max(qu[tou[q]].top(),qu[i].top());
			qu[tou[q]].pop();qu[i].pop();
		}
		while(!qu[i].empty()) st[++ft] = qu[i].top(),qu[i].pop();
		while(ft) qu[tou[q]].push(st[ft--]);
	}
	qu[tou[q]].push(a[q]);
}
int main(){
	//file();
	int i,j,l;
	n = read();
	for(i = 1;i <= n;++i) a[i] = read();
	for(i = 2;i <= n;++i){
		fa[i] = read();
		nxts[i] = fsts[fa[i]];
		fsts[fa[i]] = i;
		++ds[fa[i]];
	}
	dfs2(1);
	dfs3(1);
	li as = 0;
	while(!qu[1].empty()) as += qu[1].top(),qu[1].pop();
	print(as);pc('\n');
	return 0;
}

```

---

## 作者：_虹_ (赞：3)

~~D2唯一看懂的题~~

~~而且考场上没看懂为啥1可能不是链端点~~

~~大力观察题意~~，这题可以贪心，直接合并子节点的priority_queue，上界n^2logn，虽然上界很松，还是怂了。

可以发现两个序列合并后，序列依然是有序的，没有必要用排序，所以可以直接用vector维护。

~~然后随机数据考场电脑随便跑~~

~~然后就没写启发式合并变成60分~~

加上启发式合并就过了QAQ。。。。

下面是比较暴力的vector做法：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
#define reg register
typedef long long vt;
const int kmaxn=200000+5;
struct edge
{
    int d;
    edge* nxt;
};
edge mempool[kmaxn];
int mpt;
edge* head[kmaxn];
void add_edge(int s,int d)
{
    mempool[mpt].nxt=head[s];
    head[s]=&mempool[mpt++];
    head[s]->d=d;
}
vector<vt> q[kmaxn];
vt value[kmaxn];
int pos[kmaxn]; 
void merge(int& a,int& b)
{
    if(a==0)
    {
        a=b;
        return;
    }
    if(q[a].size()<q[b].size())
    {
        swap(a,b);
    }
    vt t=0;
    reg int i=0,L=min(q[a].size(),q[b].size());
    for(i=0;i<L;++i)
    {
        t=max(q[a][i],q[b][i]);
        q[a][i]=t;
    }
    for(L=q[b].size();i<L;++i)
    {
        q[a].push_back(q[b][i]);
    }
    vector<vt> vec;
    swap(vec,q[b]);
}
int lb(int num)
{
    vt v=value[num];
    num=pos[num];
    reg int l=0,r=q[num].size();
    reg int mid=0,ans=0;
    if(q[num].empty()||q[num][0]<=v)
        return 0;
    else if(q[num].back()>v)
        return r;
    while(l<r)
    {
        mid=(l+r)>>1;
        if(q[num][mid]<=v)
        {
            r=mid;
            ans=mid;
        }
        else
        {
            l=mid+1;
        }
    }
    return ans;
}
void dfs(int now)
{
    edge* t=head[now];
    while(t)
    {
        dfs(t->d);
        merge(pos[now],pos[t->d]);
        t=t->nxt;
    }
    if(!head[now])
    {
    	pos[now]=now;
    }
   /* reg int p=pos[now];
    for(reg int i=0,j=q[p].size();i<j;++i)
    {
        if(q[p][i]<=value[now])
        {
            q[p].insert(q[p].begin()+i,value[now]);
            return;
        }
    }
    q[p].push_back(value[now]);*///链会超时
    q[pos[now]].insert(q[pos[now]].begin()+lb(now),value[now]);
}
int n;
int fa;
int main()
{
    ios::sync_with_stdio(false);
    cin>>n;
    for(reg int i=1;i<=n;++i){
        cin>>value[i];
    }
    for(reg int i=2;i<=n;++i)
    {
        cin>>fa;
        add_edge(fa,i);
    }
    dfs(1);
    vt ans=0;
    for(reg int i=q[pos[1]].size()-1;i>=0;--i)
    {
        ans+=q[pos[1]][i];
    }
    cout<<ans<<endl;
    return 0;
}
```

vector做法依然可以卡，因为对序列插入每个节点权值时，上界依旧是n，不过平衡树中序遍历+启发式合并就卡不掉了

~~但是vector能过写什么平衡树~~

~~依旧偷懒，记吃不记打~~

---

## 作者：zijinjun (赞：2)


这个题目应该算是今年省选最简单的一题了 ~~然而为什么HB就是有wjyyy切了呢~~

首先来说一下贪心的思想（考场上应该想出来的人很多）
由于在同一条链上不能同时选，但是在不同的练上是相互不影响，我们用两个队列来表示
比如举个例子（就是一条链的情况吧）
我们把1的两个儿子底下的一整条链先求出来，然后排个序（由于考虑到同一条链不能同时选，所以内部的顺序并不影响）
假如排完了是这样的情况：

$$a:10,8,6,4,2,1$$

$$b: 9,7,7,5$$
我们来看怎么贪心，如果把10和9放在一起，那么只会产生10的影响，否则一共会产生10+9的影响，也就是说，只有和10一起才能消掉9，于是我们的操作就是把10加进答案，然后弹出9,10，同样，8加进答案，弹出7,8，就这样，最后剩下的数1,2单独加入
于是这样就是一个贪心，于是链的15分（复杂度$NlogN$)

同样，结合这个贪心，我们可以拓展到整棵树上，用优先队列进行维护，复杂度$N^2logN$，得分60

然而，如果使用启发式合并，由于每次操作只会弹两个，进一次，所以复杂度就是$NlogN$，于是就可以友好的切掉了


```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<queue>
using namespace std;

#define re register
#define ll long long
#define gc getchar()
inline int read()
{
 	re int x(0),f(1);re char c(gc);
    while(c>'9'||c<'0')f=c=='-'?-1:1,c=gc;
    while(c>='0'&&c<='9')x=x*10+c-48,c=gc;
    return f*x;
}

const int N=1100000;
struct node{int to,next;}e[N];
int h[N],cnt,tot,n,po[N];
ll ans,val[N],now[N];
priority_queue<ll> son[N];
void add(int x,int y){e[++cnt]=(node){y,h[x]};h[x]=cnt;} 
#define QXX(u) for(int i=h[u],v;v=e[i].to,i;i=e[i].next)

void dfs(int u)
{
    po[u]=u;
 	QXX(u)
    {
        dfs(v);
     	if(i==h[u])	po[u]=po[v];
        else
        {
         	if(son[po[u]].size()<son[po[v]].size())
                swap(po[u],po[v]);
            tot=0;
            while(!son[po[v]].empty())
            {
                now[++tot]=max(son[po[v]].top(),son[po[u]].top());
                son[po[u]].pop();
                son[po[v]].pop();
            }
            for(int j=1;j<=tot;j++)
                son[po[u]].push(now[j]);
        } 
    }
    son[po[u]].push(val[u]);
} 
int main()
{
    n=read();
    for(re int i=1;i<=n;i++)
        val[i]=read();
    for(re int i=2;i<=n;i++)
    {
     	int fa=read();
         add(fa,i);
    } 
    dfs(1);
    while(!son[po[1]].empty())
        ans+=son[po[1]].top(),son[po[1]].pop();
    cout<<ans;
    return 0;
} 
```

---

## 作者：lcy09 (赞：1)

### 题面

[P5290 春节十二响](https://www.luogu.com.cn/problem/P5290)

### 分析

题目的核心考点就是存在子孙关系的节点不能放在同一个内存条里，而每段内存的大小取决于这段中放进的最大的节点权值。那么我们贪心地想，**如果想让总的节点最少，就要在当前段用一个最大的尽可能多地把大东西遮盖掉，然后让下一段的最大值尽可能小**。

我们想这样一个问题，对于树上的一个节点x,考虑以x的子节点y为根的子树中有$p$个元素必须放进不同的内存段中，而节点x之前已经处理了部分子节点，有$q$个元素必须放进不同的内存段中。那么，由于以x的不同子节点为根构成的不同子树中元素不会发生冲突，根据上一段提到的贪心思想，就要把每次从$p$个和$q$个元素中分别取出最大值$pmax$和$qmax$，将$pmax$和$qmax$取最大值，作为某内存段的大小，更新x的那些元素。我们在树上dfs的过程中不断这样递归地做，最终1号节点还剩下的所有元素的和就是答案。

因为总是在取最大值，所以对每个树上节点维护一个堆，而每次x和y各取一个元素，那么我们必然是把size小的堆往size大的堆合并，这就叫启发式合并。万一上文提到的$p > q$，我们可以用C++11中的swap交换两个堆，继续进行合并。

代码写得不好就不粘了。

---

## 作者：Lily_White (赞：1)

## 题解 P5290

个人认为是本次十二省联考中比较好做的一道题。~~也是唯一一道码长1k以内的。~~

考虑链的部分分。

我们发现，这时所有的程序都仅仅和根节点发生影响。

所以我们将根节点单独放在一段里，剩下的贪心即可（尽量小的和小的放）。

这里，我们的贪心可以使用```std::priority_queue```来维护。每次取出两端的最大值，就可以贪心分配了。

现在，我们试着将这个解法拓宽到树上。

链可以看作一棵**一叉树**。换句话说，它的每个节点都只有一棵子树。

而对于**二叉树**，它的每个节点都只有不超过$2$棵子树。这时我们向下足够地递归，总能找到一个节点，它的子树能够被视为一条链进行处理。（例如它的子树都是叶子节点，或者它们都是一叉树。）

在我们处理完这个结点之后，它就可以被视作一个整体（一个节点），此时，我们就可以继续向上返回，直到解决整个问题。

对于**多叉树**可类推处理。

这一段的关键过程如下面的代码所示：
```
1.void dfs(int curr)
2.{
3.	for (auto i:g[curr])dfs(i),merge(curr,i);//请见后面
4.	q[curr].push(a[curr]);
5.}
```
通过链的启发，我们不难想到使用优先队列来保存最优解。

然而，在这个算法中，我们需要合并两个子树的最优解。

传统方式复杂度为$O(n^2)$，不能通过所有的测试数据。

因此我们需要进行**启发式合并**。换句话说，通过**只将大小较小的堆合并入较大的中，我们可以将复杂度降低到平均情况下$O(n\log n)$。

这一段的关键过程如下面的代码所示：

```cpp
1.void merge(int a, int b)
2.{
3.	stack <int> s;
4.	if (q[a].size() < q[b].size())
5.		swap(q[a], q[b]);
6.	while (!q[b].empty())
7.	{
8.		s.push(max(q[a].top(), q[b].top()));
9.		q[a].pop();
10.		q[b].pop();
11.	}
12.	while (s.size())
13.	{
14.		int t = s.top();
15.		s.pop();
16.		q[a].push(t);
17.	}
18.}
```

注意：
1. 在第$5$行中我们交换了两个堆，这在C++11中为$O(1)$。
2. 我们使用了一个栈来维护取出来的元素（最优解）。

如果我们关注这其中的元素，我们会发现它们恰好各被访问了一次。这就说明了，这个过程的时间复杂度为$O(n \log n)$.

最后我们处理```q[1]```即可解决本题。


---

## 作者：hl666 (赞：1)

这题是最近看到的今年省选题中最良心的一道了吧

看题+想题+写题都可以在0.5h内解决，送分含义明显啊

首先理解了题意后我们很快就能发现两个点如果要被分在一段那么必须在它们的祖先处合并

首先我们考虑下二叉树怎么做，发现如果对于每个节点维护一个**堆**，然后每次在一个点合并两个儿子的堆

根据简单分析我们发现必然是不断取出两个堆中最大的元素合并直到一个空了为止

那么普通的树怎么做呢，如果你稍微有点经验就会发现这个很好扩展，直接把所有儿子合并即可

但是这样一个元素可能会重复入堆多次，解决方法也很简单，直接**启发式合并**即可

值得一提的是这里的启发式合并由于再合并后短的相当于被直接扔掉了，因此每个元素合并$n$次，总复杂度是$n\log n$的

CODE

```cpp
#include<cstdio>
#include<cctype>
#include<queue>
#define RI register int
#define CI const int&
#define Tp template <typename T>
using namespace std;
const int N=200005;
struct edge
{
	int to,nxt;
}e[N]; int n,x,head[N],cnt,a[N],id[N],t[N]; priority_queue <int> hp[N]; long long ans;
class FileInputOutput
{
	private:
		static const int S=1<<21;
		#define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,S,stdin),A==B)?EOF:*A++)
		char Fin[S],*A,*B;
	public:
		Tp inline void read(T& x)
		{
			x=0; char ch; while (!isdigit(ch=tc()));
			while (x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));
		}
		#undef tc
}F;
inline void addedge(CI x,CI y)
{
	e[++cnt]=(edge){y,head[x]}; head[x]=cnt;
}
inline void swap(int& x,int& y)
{
	int t=x; x=y; y=t;
}
inline int max(CI x,CI y)
{
	return x>y?x:y;
}
#define to e[i].to
inline void DFS(CI now)
{
	id[now]=now; for (RI i=head[now];i;i=e[i].nxt)
	{
		DFS(to); if (hp[id[now]].size()<hp[id[to]].size()) swap(id[now],id[to]);
		RI cnt=0; while (!hp[id[to]].empty()) t[++cnt]=max(hp[id[now]].top(),hp[id[to]].top()),
		hp[id[now]].pop(),hp[id[to]].pop(); while (cnt) hp[id[now]].push(t[cnt--]);
	}
	hp[id[now]].push(a[now]);
}
#undef to
int main()
{
	//freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
	RI i; for (F.read(n),i=1;i<=n;++i) F.read(a[i]);
	for (i=2;i<=n;++i) F.read(x),addedge(x,i); DFS(1);
	while (!hp[id[1]].empty()) ans+=hp[id[1]].top(),hp[id[1]].pop();
	return printf("%lld",ans),0;
}
```

---

## 作者：Qglin_ (赞：1)

题意：有一个树，树上每个点带点权，现在将点划成若干个集合，要求每个集合里的点没有祖先后代关系，集合的权值是集合里点权最大的点的权值，求一个划分方案使所有集合权值总和最小。

## n<=2000

### 60分做法----基于树链剖分的贪心

数据规模不算大，可以考虑有没有 $ O(n^2) $ 附近的算法。

经过一番瞎搞，我们观察到：要让所有集合的权值总和最小，就可以让一个权值较大的集合里尽可能多地包含权值较大的点。这时候我们就可以对点权降序排序，贪心地选取并计算答案。

解决祖先后代关系，可以考虑用树链剖分，每次选取一个点就将该点为根的子树打上标记，判断集合里有没有当前节点的祖先后代可以看当前节点为根的子树里面有没有标记。

复杂度$O(n^2 \ log \ n)$

~~而且一个暴力百行代码~~

期望得分60，实际得分60。

暴力的代码可以去[我的博客](<http://qglin.top/2019/04/13/P5290/>)看一下。

## n<=2*10^5

### 100分做法----启发式合并

仔细考虑树链剖分的过程，发现可以尝试合并一波两个集合的最大权值。发现可以启发式合并，就能乱搞了。

对于每个点开一个堆，按照DFS序搞一下合并，最后q[id[1]]里面的就是要求的所有集合权值，求个和就完了。

复杂度 $ O(n \ log \ n) $。

期望得分100，实际得分100。

贴代码：

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
const int N = 200005;

namespace Qglin {

inline int fd() {
    int x = 0, f = 1; char ch = getchar();
    while (!isdigit(ch)) { if (ch == '-') f = -f; ch = getchar(); }
    while ( isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}

long long ans;
int n, Index;
int a[N], fa[N], id[N], tmp[N];
priority_queue<int> q[N];

int hed[N], nxt[N << 1], to[N << 1], edcnt;
inline void ADD(int x, int y) {
    nxt[++edcnt] = hed[x];
    hed[x] = edcnt;
    to[edcnt] = y;
}


void dfs(int x) {
    id[x] = ++Index;
    for (int i = hed[x]; i; i = nxt[i]) {
        int y = to[i];
        dfs(y);

        if (q[id[x]].size() < q[id[y]].size()) { swap(id[x], id[y]); }

        int m = q[id[y]].size();
        for (int j = 1; j <= m; ++j) {
            tmp[j] = max(q[id[x]].top(), q[id[y]].top());
            q[id[x]].pop();
            q[id[y]].pop();
        }
        for (int j = 1; j <= m; ++j) { q[id[x]].push(tmp[j]); }
    }
    
    q[id[x]].push(a[x]);
}


void main() {
    n = fd();
    for (int i = 1; i <= n; ++i) { a[i]=fd(); }
    for (int i = 2; i <= n; ++i) {
        fa[i]=fd();
        ADD(fa[i],i);
    }
    
    dfs(1);
    
    while (!q[id[1]].empty()) { ans += q[id[1]].top(); q[id[1]].pop(); }
    printf("%lld\n", ans);
}


}

int main() {
    Qglin::main();
    return 0;
}
```

---

## 作者：渺小的Mastar (赞：1)

这道题就是让每条链中的最大值和其他链的最大值连，次大值的和其他链的次大值连，然后每条链用优先队列来维护这个联合的操作；

# 注意:
swap的时候一定只能交换两个堆的下标，不然就会蜜汁60分，会MLE具体8个点（我也不知道为什么qwq，求评论区大佬解答），具体实现可以参照我下面这发代码，id数组维护的即为堆 的下标（我也是看楼上才知道的噢）

# ac代码
```cpp
#include<queue>
#include<cstdio>
#include<vector>
#include<iostream>
#include<algorithm>
#define rgi register int
#define rgu register unsigned int
using namespace std;
typedef long long ll;
const ll MAXN=200005;
int M[MAXN],ttt,k,id[MAXN];
inline int read()
{
    int x=0,f=1;
    char c=getchar();
    for(;!isdigit(c);c=getchar())
        if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())
        x=(x<<3)+(x<<1)+c-'0';
    return x*f;
}
vector<int>v,vec[MAXN];
priority_queue<int>que[MAXN];
inline void merge(int father,int child)
{
    if(que[id[father]].size()<que[id[child]].size())
        swap(id[father],id[child]);
    while(que[id[child]].size())
    {
        v.push_back(max(que[id[father]].top(),que[id[child]].top()));
        que[id[father]].pop(),que[id[child]].pop();
    }
    while(v.size())que[id[father]].push(v.back()),v.pop_back();
}
inline void dfs(int x)
{
	id[x]=++ttt;//关键是这个地方
    for(rgu i=0;i<vec[x].size();++i)
    {
        dfs(vec[x][i]);
        merge(x,vec[x][i]);
    }
    que[id[x]].push(M[x]);
}
int main()
{
    int fi,n=read();
    for(rgi i=1;i<=n;++i)
        M[i]=read();
    for(rgi i=2;i<=n;++i)
        vec[read()].push_back(i);
    ll ans=0;
    dfs(1);
    while(que[id[1]].size())ans+=que[id[1]].top(),que[id[1]].pop();
    printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：OrionM42 (赞：1)



难得一见OI中出现硬科幻作品的题，心情十分激动，来写一发题解

题目大意：给定一棵树，划分点集，使（每个点集中的最大值）加起来最小

先观察数据范围，发现15分是链

## 15pts（链）
链怎么做？首先根节点1肯定是要自己单独一个集合，其次是它延伸出来的两条链，显然每一条链起码要划分成相当于链长度数量的集合，现在考虑合并集合

根据贪心，左链的最大值很明显要跟右链的最大值放在一起，（设不放在一起，而是跟s放在一起，则需另开一个最大值为左/右链最大值的集合，会比开一个s为最大值的集合差），同理次大值也要放在一起，最后把多出来的那条链全部加上即可

```cpp
void solve1()
{
	int u;
	for(int i=head[1];i;i=head[u])
	{
		u=to[i];top[++top[0]]=a[u].v;
	}
	for(int i=next[head[1]];i;i=head[u])
	{
		u=to[i];son[++son[0]]=a[u].v;
	}
	if(top[0])sort(top+1,top+top[0]+1,cmp);
	if(son[0])sort(son+1,son+son[0]+1,cmp);//对于两条链的排序 
	int i=1,j=1;
	for(;i<=top[0]&&j<=son[0];i++,j++)ans+=max(top[i],son[j]);//答案加上较大的数 
	if(i<=top[0])for(;i<=top[0];i++)ans+=top[i];
	if(j<=son[0])for(;j<=son[0];j++)ans+=son[j];//加上剩下的数 
	printf("%lld",ans+a[1].v);
	return;
}
```


（然而笔者是用排序实现的，巧妙地错过了数据范围引导的正解qwq）

## 另50pts (n<=2000)
既然题目让我们找最大，那就从最大值入手，对于最大值，它一定是它所处的集合贡献给答案的那个数。

现在考虑扩展这个集合，先不考虑正确性试试贪心，把所有点按权值从大到小排序，然后尽量把大的数加入刚才那个以最大值为答案的集合（“尽量”的意思是当前加入的数与之前加入的数不构成祖先--后代关系）。然后我们会发现有一些不符合条件的数没被加入，那就再来一次刚才的过程，将剩下的数排序，以最大数为基础，尽量加入大的数。直到所有数都被加入到各自的集合当中。

### 下面证明这个做法正确性
设a1为当前最大数，a2为要加入的第二大数且满足不是已加入的数的祖先/后代，考虑不加入a2的唯一原因可能是：加入a2后，a2限制了其祖先/后代加入当前集合
- #### 若“挡住”后代加入：

设S为本来应加入的a2的后代集合，根据假设S中任意数均比a2小（或等）,则之后必开一个A集合容纳S或a2

当前加入a2-->之后要开一个（最大值不一定在S中的）A集合容纳S

当前加入S -->之后要开一个A集合容纳a2

即A要么以其它数为瓶颈（最大值）（此时先加入a2或S对答案无影响），要么以a2或S中某个数为瓶颈，而a2大于等于S中任意数，以a2为瓶颈更劣，所以对于当前，加入a2比起加入其后代集合S，答案不会更差。

- #### 若“挡住”祖先加入
首先挡住的祖先肯定只能是它爸爸到a2和a1的LCA中的点，同挡住后代的证法，且加入a2祖先挡住的点比加入a2挡住的点多，明显更劣。

以上，由于我们的每一步都遵循最优性原则，由数学归纳，正确性得证。


然而，这种做法每开一个集合都要对排好序的数一一判断，所以复杂度起码为         O(n^2),然后笔者比较笨，只想到用树链剖分+树状数组维护祖孙关系的做法，具体是对原树做树链剖分，若选了一个数便将其后代和祖先对应的点+1，判断是否可以加入当前集合就单点询问下为不为零就好了。

对于每个点，覆盖祖先的复杂度是O（logn^2），覆盖后代复杂度是O(logn)，分别覆盖一次，询问复杂度O(logn)，问（总集合数量）次，最坏有n个集合(链)，所以最坏情况下问n次。

总复杂度 O(n(longn^2)+(n^2)logn)

加上链的做法可以拿到75pts

代码实现用了比较巧妙的办法减小运行时间上限的松紧

```cpp
//by OrionM42
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
char c;
int read()
{
	c=getchar();int res=0;
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=(res<<1)+(res<<3)+(c^48),c=getchar();
	return res;
}
const int N=2e5+111,M=1e6+111;
int head[N],next[N],to[N],tot=1,n,cd[N];ll ans;
int dad[N],dep[N],top[N],son[N],si[N],seg[N],all,tree[N];bool sol;
//tree是树状数组，dad,dep,top,son,si,seg,all,是树剖的变量
//cd,sol判断数据是不是链 
struct node
{
	int v,bh;
}a[N];
bool cmp(int aa,int bb){return aa>bb;}
bool cmp2(node aa,node bb){return aa.v>bb.v;}
inline int max(int aa,int bb){return aa>bb?aa:bb;}
void add_e(int fr,int go)
{
	tot++;next[tot]=head[fr];head[fr]=tot;to[tot]=go;cd[fr]++;
}
inline int lowbit(int x){return x&-x;}
void add_t(int x,int s){for(;x<=n+11;x+=lowbit(x))tree[x]+=s;}
int query(int x){int res=0;for(;x;x-=lowbit(x))res+=tree[x];return res;}
//树状数组 
void solve1()
{
	int u;
	for(int i=head[1];i;i=head[u])
	{
		u=to[i];top[++top[0]]=a[u].v;
	}
	for(int i=next[head[1]];i;i=head[u])
	{
		u=to[i];son[++son[0]]=a[u].v;
	}
	if(top[0])sort(top+1,top+top[0]+1,cmp);
	if(son[0])sort(son+1,son+son[0]+1,cmp);//对于两条链的排序 
	int i=1,j=1;
	for(;i<=top[0]&&j<=son[0];i++,j++)ans+=max(top[i],son[j]);//答案加上较大的数 
	if(i<=top[0])for(;i<=top[0];i++)ans+=top[i];
	if(j<=son[0])for(;j<=son[0];j++)ans+=son[j];//加上剩下的数 
	printf("%lld",ans+a[1].v);
	return;
}//链做法 
void dfs1(int u)
{
	si[u]=1;dep[u]=dep[dad[u]]+1;
	for(int i=head[u];i;i=next[i])
	{
		int go=to[i];
		dfs1(go);
		si[u]+=si[go];
		if(si[go]>si[son[u]])son[u]=go;
	}
}
void dfs2(int u)
{
	seg[u]=++all;
	if(son[u])
	{
		top[son[u]]=top[u];
		dfs2(son[u]);
	}
	for(int i=head[u];i;i=next[i])
	{
		int go=to[i];if(top[go])continue;
		top[go]=go;
		dfs2(go);
	}
}
void add(int x,int y)
{
	int fx=top[x],fy=top[y];
	while(fx!=fy)
	{
		if(dep[fx]<dep[fy])fx^=fy^=fx^=fy,x^=y^=x^=y;
		add_t(seg[fx],1);add_t(seg[x]+1,-1);
		x=dad[fx];fx=top[x];
	}
	if(dep[x]>dep[y])x^=y^=x^=y;
	add_t(seg[x],1);add_t(seg[y]+1,-1);
}//树剖 
int main()
{
	n=read();
	for(int i=1;i<=n;i++)a[i].v=read(),a[i].bh=i;
	for(int i=2;i<=n;i++)
	{
		dad[i]=read();add_e(dad[i],i);
		if(!sol)if((cd[dad[i]]>1&&dad[i]>1)||(cd[dad[i]]>2))sol=1;
	}
	if(!sol){solve1();return 0;}//链 
	dfs1(1);
	top[1]=1;
	dfs2(1);//树剖前置工作 
	sort(a+1,a+n+1,cmp2);//排序贪心 
	int nsi=n;
	while(nsi)
	{
		for(int i=0;i<=n+11;i++)tree[i]=0;
		int la=0;ans+=a[1].v;
		for(int i=1;i<=nsi;i++)
		{
			if(query(seg[a[i].bh]))
			{
				a[++la]=a[i];
			}
			else
			{
				add(a[i].bh,1);
				add_t(seg[a[i].bh],1);add_t(seg[a[i].bh]+si[a[i].bh],-1);
			}
		}
		nsi=la;
	}
	printf("%lld",ans);
	return 0;
}
```

## 接下来是正解
其实证明过程关键的地方都在上面了，只要结合链的数据多想一步答案就出来了
~~（然而笔者比较笨没想出来）~~

容易看出，
### 最大的数a1所在的集合,会在它的每个祖先的所有其他儿子（即不包含a1本身的子树）中选出一个最大的数加入当前集合，证明过程同50pts的证法。同理，未选过数中第二大的数也会按照同样的方式，将剩下数中的某些数选进自己的集合。
以此类推。

这是什么？实际上是一个堆合并的过程，想象一下，每个数把其他数选进自己集合的操作，相当于直接把这个数的贡献从答案中扣除，若我们维护一个堆合并的过程，堆中记录当前节点及其子树中包含的权值，则在向上传递的过程中，该点的堆中权值从大到小，和它兄弟节点的堆的对应排名的权值，对于每个排名，只能留下一个权值，即堆的合并，本质上就是用大数消掉小数贡献的过程，只不过对于每个集合同时做而已。

思路很巧妙，代码也不长
```cpp
//by OrionM42
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;
typedef long long ll;
char c;
int read()
{
	c=getchar();int res=0;
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=(res<<1)+(res<<3)+(c^48),c=getchar();
	return res;
}
inline int max(int aa,int bb){return aa>bb?aa:bb;}
const int N=2e5+111;
priority_queue < int > q[N];//整形大根堆 
int n,head[N],next[N],to[N],tot=1,si[N],v[N],ls[N],sls,po[N];
long long ans;
//v[i]表示第i个子程序占用空间大小 si[i]表示第i个堆大小 
//po[i]表示第i个点指向的堆的编号 
void add(int fr,int go)
{
	tot++;next[tot]=head[fr];head[fr]=tot;to[tot]=go;
}
int merge(int x,int y)//合并编号为x,y的堆到x上 
{
	if(si[x]<si[y])x^=y^=x^=y;//启发式合并,交换x,y 
	sls=0;
	while(!q[y].empty())
	{
		ls[++sls]=max(q[x].top(),q[y].top());//用一个临时数组存需要加入的数 
		q[x].pop();q[y].pop();
	}
	for(int i=1;i<=sls;i++)q[x].push(ls[i]);
	return x;
}
int dfs(int u)
{
	po[u]=u;
	for(int i=head[u];i;i=next[i])
	{
		int go=to[i];
		po[u]=merge(dfs(go),po[u]);//递归合并 
	}
	si[po[u]]++;q[po[u]].push(v[u]);
	return po[u];//返回该节点对应的堆的编号 
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)v[i]=read();
	for(int i=2;i<=n;i++)add(read(),i);
	dfs(1);//从根节点开始，递归合并堆
	while(!q[po[1]].empty())
	{
		ans+=q[po[1]].top();q[po[1]].pop();
	}
	printf("%lld",ans);
	return 0;
}
```


---


# [BJOI2019] 光线

## 题目描述

当一束光打到一层玻璃上时，有一定比例的光会穿过这层玻璃，一定比例的光会被反射回去，剩下的光被玻璃吸收。  

设对于任意 $x$，有 $x \times a_i\%$ 单位的光会穿过它，有 $x \times b_i\%$ 的会被反射回去。  
现在 $n$ 层玻璃叠在一起，有 $1$ 单位的光打到第 $1$ 层玻璃上，那么有多少单位的光能穿过**所有** $n$ 层玻璃呢？


## 说明/提示

**样例1解释：**  
![](https://cdn.luogu.com.cn/upload/pic/57125.png)   
如图，光线从左上角打进来，有 $0.5$ 单位的光穿过第 $1$ 层玻璃，有 $0.2$ 单位的光被反射回去。这 $0.5$ 单位的光有 $0.4$ 单位穿过第 $2$ 层玻璃，有 $0.025$ 单位的光被反射回去。这 $0.025$ 单位的光有 $0.0125$ 单位穿过第 $1$ 层玻璃，有 $0.005$ 单位的光被反射回去。这 $0.005$ 单位的光有 $0.004$ 单位穿过第 $2$ 层玻璃……于是，穿过两层玻璃的光一共有$0.40404... = 40/99$ 单位。在模 $10^9+7$ 意义下等于 $858585865$。 

**数据范围：**  
对于 $5\%$ 的数据，$n=1$；    
对于 $20\%$ 的数据，$n\le 2$；    
对于 $30\%$ 的数据，$n\le 3$；    
对于 $50\%$ 的数据，$n\le 100$；    
对于 $70\%$ 的数据，$n\le 3000$；    
对于 $100\%$ 的数据，$n\le 5\times 10^5$，$1\le a_i \le 100$，$0\le b_i \le 99$，$1\le a_i+b_i \le 100$。  

每组 $a_i$ 和 $b_i$ 在满足上述限制的整数中随机生成。

## 样例 #1

### 输入

```
2
50 20
80 5```

### 输出

```
858585865```

## 样例 #2

### 输入

```
3
1 2
3 4
5 6```

### 输出

```
843334849```

# 题解

## 作者：小粉兔 (赞：45)

在博客园食用更佳：[https://www.cnblogs.com/PinkRabbit/p/BJOI2019D2T2.html](https://www.cnblogs.com/PinkRabbit/p/BJOI2019D2T2.html)

### 题意简述：

有 $n$ 面玻璃，第 $i$ 面的透光率为 $a$，反射率为 $b$。

问把这 $n$ 面玻璃按顺序叠在一起后，$n$ 层玻璃的透光率。

$0 < a_i \le 1$，$0 \le b_i < 1$。

### 题解：

题目中告诉我们，$n$ 层的玻璃也有透光率，换句话说，多层的玻璃可能可以看作一层。

从这个角度思考，考虑已经求出了前 $i - 1$ 层玻璃的透光率，如何求出前 $i$ 层玻璃的透光率。

可以发现已知透光率并不足以进一步求出新的透光率，我们似乎还需要知道反射率。

这时，如果你天真地认为反射率就是从第一面玻璃射入的光的反射率，你就错了。

需要特别注意的是，从第一面和最后一面射入的光的反射率是不相同的。

这是一个很大的坑点，如果注意到了这题就容易了；没注意到就会一直挠头。

总之，我们需要维护两个量：

1. 前 $i$ 面玻璃按顺序叠在一起后，光从**第 $1$ 面玻璃**射入时的透光率。

2. 前 $i$ 面玻璃按顺序叠在一起后，光从**第 $i$ 面玻璃**射入时的反射率。

分别记为 $P_i$ 和 $Q_i$，则不难推出：

$$\begin{aligned}P_i&=P_{i-1}a_i\sum_{k=0}^{\infty}(Q_{i-1}b_i)^k\\Q_i&=b_i+Q_{i-1}a_i^2\sum_{k=0}^{\infty}(Q_{i-1}b_i)^k\end{aligned}$$

其中我们发现带有 $\sum_{k=0}^{\infty}a^k$ 的形式，当 $|a|<1$ 时，这个无穷级数等于 $\frac{1}{1-a}$。

所以得到最终的递推式：

$$\begin{aligned}P_i&=\frac{P_{i-1}a_i}{1-Q_{i-1}b_i}\\Q_i&=b_i+\frac{Q_{i-1}a_i^2}{1-Q_{i-1}b_i}\end{aligned}$$

先算出 $\frac{1}{1-Q_{i-1}b_i}$ 可以简化计算。

代码如下：

```cpp
#include <cstdio>

typedef long long LL;
const int Mod = 1000000007;
const int Inv100 = 570000004;

inline LL Inv(LL b) {
	LL a = 1;
	for (int e = Mod - 2; e; e >>= 1, b = b * b % Mod)
		if (e & 1) a = a * b % Mod;
	return a;
}

int N;
LL P, Q;

int main() {
	scanf("%d", &N);
	P = 1, Q = 0;
	while (N--) {
		LL a, b;
		scanf("%lld%lld", &a, &b);
		a = a * Inv100 % Mod, b = b * Inv100 % Mod;
		LL W = Inv((1 - Q * b % Mod + Mod) % Mod);
		Q = (b + a * a % Mod * Q % Mod * W) % Mod;
		P = P * a % Mod * W % Mod;
	}
	printf("%lld\n", P);
	return 0;
}
```

题外话：你或许会想，既然反射率不同，透光率是否也不同呢？

然而经过计算，可以得到在每面玻璃两侧的透光率分别相同的情况下，最终两侧的透光率也相同。

这引出了一个有趣的光学原理：可以通过叠加不同的普通玻璃创造出两侧反射率不同的复合玻璃，但是透光率却始终相同。

同时也说明了毛玻璃并不是普通玻璃组合而成的。

---

## 作者：da32s1da (赞：21)

令$f[i]$表示第$i$块玻璃向下发出的光线，$g[i]$表示第$i$块玻璃向上发出的光线。我们要求$f[n]$

则有

$$f[i]=f[i-1]\cdot a_i+g[i+1]\cdot b_i$$

$$g[i]=f[i-1]\cdot b_i+g[i+1]\cdot a_i$$

那么容易发现

$$f[n]=f[n-1]\cdot a_n$$

$$g[n]=f[n-1]\cdot b_n$$

即$f[n],g[n]$可以用$f[n-1]$表示出来。又因为

$$f[n-1]=f[n-2]\cdot a_{n-1}+(f[n-1]\cdot b_n)\ b_{n-1}$$

$$g[n-1]=f[n-2]\cdot b_{n-1}+(f[n-1]\cdot b_n)\ a_{n-1}$$

发现$f[n-1],g[n-1]$可以用$f[n-2]$表示出来。

以此类推，$f[1]$可以用$f[0]$表示出来。而$f[0]=1$，再递推下去得到$f[n]$。

```cpp
#include<cstdio>
const int N=5e5+50;
const int mod=1e9+7;
int ksm(int u,int v){
	int res=1;
	for(;v;v>>=1,u=1ll*u*u%mod)
	if(v&1)res=1ll*res*u%mod;
	return res;
}
int n,f[N],g[N],a[N],b[N];
int main(){
	scanf("%d",&n);
	int _100=ksm(100,mod-2);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i],&b[i]);
		a[i]=1ll*a[i]*_100%mod;
		b[i]=1ll*b[i]*_100%mod;
	}
	for(int i=n;i>=1;i--){
		f[i]=1ll*a[i]*ksm(1-1ll*b[i]*g[i+1]%mod+mod,mod-2)%mod;//f[i]可用f[i-1]表示
		g[i]=(b[i]+1ll*a[i]*f[i]%mod*g[i+1]%mod)%mod;//g[i]可用f[i-1]表示
	}
	for(int i=2;i<=n;i++)f[i]=1ll*f[i]*f[i-1]%mod;//递推
	printf("%d\n",f[n]);
}
```

---

## 作者：花里心爱 (赞：12)

[题目链接](https://www.luogu.org/problemnew/show/P5323)

看上去像一个dp推式子题，我们先试着把方程列出来。

设$f[i]$表示从第$i$层玻璃向前穿过去的光线有多少，显然答案就是$f[n]$。为了方便，我们设$f[0] = 1$。

然后我们发现要想转移的话，还需要知道从第$i$层玻璃向后穿回去的光线有多少，设为$g[i]$。然后模拟一下会发现下面的式子：（下面的$a, b$为原题中的$\frac{a}{100}, \frac{b}{100}$）

$$f[i] = f[i-1] \times a[i] + g[i+1] \times b[i]$$
$$g[i] = f[i-1] \times b[i] + g[i+1] \times a[i]$$

我们发现，上面的方程里有一个$g[i+1]$，不能直接转移。

然后我们又发现$g$对我们要求的答案是无用的，我们可以考虑消去$g$。

于是我们可以认为$g[n+1] = 0$，于是$f[n] = f[n-1] \times a[n], g[n] = f[n-1] \times b[n]$。我们发现式子右边没有$g$了qwq

将$g[n]$代入$f[n-1], g[n-1]$的方程里，我们又可以消去$g[n]$。于是我们可以考虑迭代的思想来消去$g$。

我们设$F[i] = \dfrac{f[i]}{f[i-1]}, G[i] = \dfrac{g[i]}{f[i-1]}$，也就是$f[i], g[i]$分别为$f[i-1]$的多少倍。

显然$F[n] = a[n], G[n] = b[n]$，根据上面的分析，我们可以倒序求$F, G$。

代到最上面的式子里：

$$f[i] = f[i-1] \times a[i] + g[i+1] \times b[i]$$
$$\dfrac{f[i]}{f[i-1]} = a[i] + \dfrac{g[i+1] \times b[i]}{f[i-1]}$$
$$F[i] = a[i] + G[i+1] \times b[i] \times F[i]$$
$$F[i] = \dfrac{a[i]}{1 - G[i+1] \times b[i]}$$

又有：

$$g[i] = f[i-1] \times b[i] + g[i+1] \times a[i]$$
$$\dfrac{g[i]}{f[i-1]} = b[i] + \dfrac{g[i+1] \times a[i]}{f[i-1]}$$
$$G[i] = b[i] + G[i+1] \times a[i] \times F[i]$$

这样我们就可以转移了。

最后递推求出$f$，即$f[i] = f[i-1] \times F[i]$

下面放代码：
```cpp
#include <cstdio>
#include <cctype>
#define maxn 500005
#define M 1000000007
inline int read() {
	int d=0;char ch=getchar();while(!isdigit(ch))ch=getchar();
	while(isdigit(ch)){d=d*10+ch-48,ch=getchar();}return d;
}

inline int ksm(int x, int y) {
	int res = 1;
	for(; y; y >>= 1) {
		if(y&1) res = 1ll*res*x%M;
		x = 1ll*x*x%M;
	}
	return res;
}

int n, ny;
int a[maxn], b[maxn];
int F[maxn], G[maxn];
int f[maxn];

int main() {
	n = read(), ny = ksm(100, M-2);
	for(int i = 1; i <= n; ++i)
		a[i] = 1ll*read()*ny%M, b[i] = 1ll*read()*ny%M;
	F[n] = a[n], G[n] = b[n];
	for(int i = n-1; i; --i) {
		F[i] = 1ll*a[i]*ksm(((1-1ll*b[i]*G[i+1]%M)%M+M)%M, M-2)%M;
		G[i] = (b[i]+1ll*G[i+1]*F[i]%M*a[i]%M)%M;
	}
	f[0] = 1;
	for(int i = 1; i <= n; ++i)
		f[i] = 1ll*f[i-1]*F[i]%M;
	printf("%d", f[n]);
	return 0;
}
```

---

## 作者：justin_cao (赞：11)

来提供一个似乎题解里面还没有的做法。

首先考虑设$f[i]$为假设有$1$单位的光线从上到下射到第$i$层玻璃，最后会有多少光线穿过第$i$层玻璃。那么答案显然是$\prod f[i]$。

然后发现有在第$i$层这里反射的，而反射的又不好直接算，那怎么办呢？

考虑再设一个$g[i]$表示前$i$层的玻璃，从下到上射$1$单位的光线，最后有多少会被反射回来。

考虑转移：
$$
f[i]=a_i+b_i\times g[i-1]\times f[i]
$$
$$
g[i]=b_i+a_i\times g[i-1]\times f[i]
$$
首先$f$的转移。$a_i$是直接穿过的，$b_i$是反射回来的，那么$b_i\times g[i-1]$就是再回去的光线，再$\times f[i]$就是最后穿过的光线了。

然后$g$的转移。$b_i$是直接反射的，$a_i$是穿过去了的，那么$a_i\times g[i-1]$就是再打回来的，再$\times f[i]$就也是穿过的光线了。

显然$f[i]$能由$g[i-1]$推出，$g[i]$能由$f[i],g[i-1]$推出。

这样就做完了，复杂度$O(n\log n)$.

实际上推完式子可以发现，$f$不需要$g$也能转移，但是两个都在还是意义更加清晰明了。

code:
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<iostream>
#include<set>
#include<vector>
#include<queue>
#include<stack>
#include<bitset>
#define eps 1e-15
#define maxn 500010
#define maxm 410
#define inf 999999999999999
#define mod 1000000007
#define mp(x,y) make_pair(x,y)
#define fi first
#define se second
using namespace std;
typedef long long ll;
typedef unsigned int uint;
typedef pair<int,int>pii;
int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}
    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n;
int quick_pow(int x,int p)
{
    int an=1,po=x;
    while(p)
    {
        if(p&1)  an=1ll*an*po%mod;
        po=1ll*po*po%mod;
        p>>=1;
    }
    return an;
}
int a[maxn],b[maxn];
int f[maxn],g[maxn];
int main()
{
    n=read();
    int INV=quick_pow(100,mod-2);
    for(int i=1;i<=n;i++)  a[i]=1ll*read()*INV%mod,b[i]=1ll*read()*INV%mod;
    f[1]=a[1];g[1]=b[1];
    for(int i=2;i<=n;i++)
    {
        int tmp=(mod+1-1ll*b[i]*g[i-1]%mod+mod)%mod;
        tmp=quick_pow(tmp,mod-2);f[i]=1ll*tmp*a[i]%mod;
        g[i]=(b[i]+1ll*g[i-1]*a[i]%mod*f[i]%mod)%mod;
    }
    int ans=1;
    for(int i=1;i<=n;i++)  ans=1ll*ans*f[i]%mod;
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Mirach (赞：5)

[菜鸡博客](https://www.cnblogs.com/penth/p/10777942.html)欢迎来踩

Problem
-------

[loj3093](https://loj.ac/problem/3093) & [x谷](https://www.luogu.org/problemnew/show/P5323)

题意概要：给定 $n$ 块玻璃，每块玻璃有其折射比例与反射比例（折射比例+反射比例 不一定为 $100\%$），求从最上头打下一束光，有多少比例的光可以完全穿越 $n$ 块玻璃

$n\leq 5\times 10^5$

Solution
--------

一眼线性高斯消元，但是我懒……物理题当然不要那么麻烦啦

由于考虑到这是物理模型，用物理思想考虑——合并玻璃

仅考虑合并两块玻璃，对于合并后的等价玻璃，需要算出其 从上往下与从下往上的反射透射率 共四个参数。但是我懒……由于不需要知道最上层玻璃 从上往下的反射率 与 从下往上的透射率，所以可以考虑每次合并最顶上的两块玻璃，只需要计算两个参数

### 从上往下透射率：

考虑到整体透射过去的光就是透射过第二块玻璃的光，而由于一部分光可能在两块玻璃间反射，所以透射过去的光分为无穷多段，但最终的总和是收敛的（设第一块玻璃透射率为 $a_1$，反射率为 $b_1$，第二块玻璃透射率为 $a_2$，反射率为 $b_2$）：

- 第一束光：$a_1a_2$（直接透过两块玻璃）
- 第二束光：$a_1a_2b_1b_2$（在两块玻璃间反射一个来回后透射出去）
- 第三束光：$a_1a_2(b_1b_2)^2$（反射两个来回）
- ……

求和为 $\sum_{i=0}^{+\infty}a_1a_2(b_1b_2)^i=\frac {a_1a_2(1-(b_1b_2)^{+\infty})}{1-b_1b_2}$

由于 $b_1b_2<1$

$$a'=\lim_{n\rightarrow +\infty}\frac {a_1a_2(1-(b_1b_2)^n)}{1-b_1b_2}=\frac {a_1a_2}{1-b_1b_2}$$

### 从下往上反射率：

类似于上面的方法：

- 第一束光：$b_2$（直接反射）
- 第二束光：$a_2^2b_1$（在第一块玻璃反射一次，穿越两次第二块玻璃）
- 第三束光：$a_2^2b_1^2b_2$（在中间多一个反射来回）

求和：

$$b'=b_2+\lim_{n\rightarrow +\infty}\frac {a_2^2b_1(1-(b_1b_2)^n)}{1-b_1b_2}=b_2+\frac {a_2^2b_1}{1-b_1b_2}$$

从上到下合并所有玻璃后最后一块玻璃的透射率即为答案

Code
--------

```cpp
#include <bits/stdc++.h>
typedef long long ll;

inline void read(int&x){
	char c11=getchar();x=0;while(!isdigit(c11))c11=getchar();
	while(isdigit(c11))x=x*10+c11-'0',c11=getchar();
}

const int p = 1e9+7, inv = 570000004;

inline int qpow(int A,int B) {
	int res = 1;
	while(B) {
		if(B&1) res = (ll)A * res%p;
		A = (ll)A * A%p, B >>= 1;
	} return res;
}

int n, a1, a2, b1, b2, a, b, iv;

int main() {
	read(n);
	read(a1), a1 = (ll)a1 * inv%p;
	read(b1), b1 = (ll)b1 * inv%p;
	while(--n) {
		read(a2), a2 = (ll)a2 * inv%p;
		read(b2), b2 = (ll)b2 * inv%p;
		iv = qpow(p+1 - (ll)b1 * b2%p, p-2);
		a = (ll)a1 * a2%p * iv%p;
		b = (b2 + (ll)a2 * a2%p * b1%p * iv)%p;
		a1 = a, b1 = b;
	}
	printf("%d\n",a1);
	return 0;
}
```

---

## 作者：Ayiirep (赞：4)

提供一种不需要太多思维过程的做法吧...

主要要用到高斯消元。

首先设 $dp_i$ 表示射到第 $i$ 块玻璃上的光线（没有穿过玻璃 也没有反射）。

显然 $dp_1=1$ 。

考虑对于第 $i(i>1)$ 块玻璃，我们如何计算 $dp_i$。

![](https://cdn.luogu.com.cn/upload/pic/57125.png)

就把题面里的图蒯来看看吧（

首先考虑不存在 $b_i=0$ 的情况

那么 $dp_i=a_{i-1}dp_{i-1}+b_ib_{i-1}dp_i+b_{i+1}a_ib_{i-1}dp_{i+1}$...

就是考虑直接从上块玻璃折射过来，从这块玻璃反射一次射过来，从下一块玻璃反射射过来....


那么用高斯消元解下方程就好了，时间复杂度 $O(n^3)$ 可以拿到 $50$ pts。

但是你会发现这个矩阵拥有非常优美的性质，因为它大概长这个样子：

这里把第一行给省掉了（

$$\begin{bmatrix}
	a_1&b_2b_1-1&b_3a_2b_1&b_4a_3a_2b_1&\cdots\\
   0&a_2&b_3b_2-1&b_4a_3b_2&\cdots\\
   0&0&a_3&b_4b_3&\cdots\\
   \vdots& \vdots& \vdots& \vdots&\ddots
\end{bmatrix}$$

然后你发现如果把每一行除掉 $b_{i-1}$ 的话，后面的部分相同，可以很容易地消掉，所以每一行只用保留下标为 $i-1, i, i+1$ 的三个数字，然后再简单的做一遍消元，把每一行下标为 $i+1$ 的数字消掉，就可以代入解方程了。

注意这时候我们还没有考虑存在 $b_i=0$ 的情况，但是我们考虑如果矩阵中只保留 $b_i>0$ 的玻璃，然后在计算过程中加入 $a_i$ 就可以了。

就比如对于 $n=5$， 只有 $b_2=b_4=0$ 的情况，它的矩阵长这个样子：

还是省掉了第一行（

$$\begin{bmatrix}
	a_1a_2&b_3a_2b_1a_2-1&b_5a_4a_3a_2b_1a_2\\
	 0&a_3a_4&b_5a_4b_3a_4-1\\
\end{bmatrix}$$

然后你发现把对于 $l<r$ 满足 $b_{l+1..r-1}=0$ 的玻璃，在 $r$ 对应的行除掉 $a_{l+1...r-1}$  然后就又可以按照上面的办法消掉了，并且满足每一行要除掉的 $b_i>0$。

由于要求逆元什么的，所以复杂度是 $O(n\log n)$。

代码：
```c++
#include <bits/stdc++.h>
using namespace std;
#define I inline int
#define V inline void
#define gc (getchar())
V rd(int &x) {
	x=0; int f=1; char ch=gc;
	while(!isdigit(ch)) {if(ch=='-') f=-1; ch=gc;}
	while( isdigit(ch)) x=x*10+ch-'0', ch=gc;
	x*=f;
}
#define FOR(i, a, b) for(int i=a; i<=b; ++i)
#define ROF(i, a, b) for(int i=a; i>=b; --i)
const int maxn=5e5+5, mod=1e9+7;
V chk(int &x) {x-=mod, x+=x>>31&mod;}
I Pow(int x, int y) {int z=1; for(; y; y>>=1, x=1ll*x*x%mod) if(y&1) z=1ll*z*x%mod; return z;}
int n, ans;
int a[maxn], b[maxn], dp[maxn], g[maxn][3], id[maxn];
I Get(int l, int r) {
	int z=1; FOR(i, l, r) z=1ll*z*a[i]%mod;
	return z;
}
int main()
{
//	freopen("ray.in","r",stdin);
//	freopen("ray.out","w",stdout);
	rd(n); int inv=Pow(100, mod-2), m=0;
	FOR(i, 1, n) rd(a[i]), rd(b[i]), a[i]=1ll*a[i]*inv%mod, b[i]=1ll*b[i]*inv%mod;
	FOR(i, 1, n) if(b[i]) id[++m]=i;
	FOR(i, 2, m) {
		int x=id[i], y=id[i-1], t=Get(y+1, x-1);
		g[i][0]=1ll*a[y]*Pow(b[y], mod-2)%mod;
		g[i][1]=(1ll*b[id[i]]*t%mod-1ll*Pow(1ll*t*b[y]%mod, mod-2)%mod+mod)%mod;
		g[i][2]=1ll*b[id[i+1]]*Get(id[i-1]+1, id[i+1]-1)%mod;
	}
	FOR(i, 2, m-2) {
		chk(g[i][1]+=mod-1ll*g[i+1][0]*Get(id[i-1]+1, id[i])%mod);
		chk(g[i][2]+=mod-1ll*g[i+1][1]*Get(id[i-1]+1, id[i])%mod);
	}
	ROF(i, m, 1) {
		int t=1ll*g[i][2]*Pow(g[i+1][1], mod-2)%mod;
		chk(g[i][1]+=mod-1ll*g[i+1][0]*t%mod);
		chk(g[i][2]+=mod-1ll*g[i+1][1]*t%mod);
	}
	dp[1]=1;
	FOR(i, 2, m) chk(dp[i]=mod-1ll*g[i][0]*dp[i-1]%mod*Pow(g[i][1], mod-2)%mod);
	cout<<1ll*Get(1, id[1]-1)*dp[m]%mod*Get(id[m], n)%mod;
	return 0;
}
```

---

## 作者：Max_QAQ (赞：3)

**思路：**

数学概率题。

可以考虑根据题意列出概率的转移式。

**设：** $P_{i}$ 表示第 $i$ 层空间中，所有向下指的光线的概率， $Q_{i}$ 表示第 $i$ 层空间中，所有向上指的光线的概率。

**注意：** 这里设第 $i$ 层玻璃以下的空间为第 $i$ 层空间，那么第 $1$ 层玻璃以上的空间为第 $0$ 层空间。

那么每层空间中向下指的所有光线的概率就是，上一层中所有向下指的光线的概率乘上透过这一层玻璃的概率，再加上这一层空间中所有向上指的光线乘上被这一层玻璃反射的概率。

转移式为 $P_{i}=P_{i-1}\times a_{i} + Q_{i} \times b_i$ 。

再考虑所有向上指的光线的概率，可以由这一层所有向下指的概率乘上被下一层玻璃反射的概率再加上下一层所有向上指的光线的概率乘上透过了下一层玻璃的概率。

转移式为 $Q_{i}=P_{i}\times b_{i+1}+Q_{i+1}\times a_{i+1}$ 。

有了这两个式子，我们再来想想题目中的性质，即为第 $0$ 层空间所有光线向下指的概率为 $1$ ，第 $n$ 层光线所有向上指的概率为 $0$ 。

那么就是 $P_{0}=1,Q_{n}=0$ 。

式子列出来了，发现不好求解，那我们考虑手动消元。

那我们可以考虑将上面两个转移式子转化一下，然后再依次递推求解。

$$P_{i}=P_{i-1}\times a_{i} + Q_{i} \times b_i$$

$$P_{i+1}=P_{i}\times a_{i+1} + Q_{i+1} \times b_{i+1}$$

$$P_{i}\times a_{i+1}=P_{i+1}-Q_{i+1}\times b_{i+1}$$

$$P_{i}=\frac{P_{i+1}-Q_{i+1}\times b_{i+1}}{a_{i+1}}$$

$$Q_{i}=P_{i}\times b_{i+1}+Q_{i+1}\times a_{i+1}$$

这样我们就能够通过第 $i+1$ 项来求解第 $i$ 项了。

又因为 $Q_{n}=0$ ，所以我们可以直接通过 $P_n$ 得出 $P_{n-1},Q_{n-1}$ ，这样就能依次往上递推求解了。

既然要倒着转移，我们可以设每一个 $P_{i},Q_{i}$ 里的值为多少倍的 $P_n$ ，这样转移到 $0$ 的时候就能够根据 $P_{0}=1$ 直接求得 $P_n$ 了。

贴个代码。

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 1000000007
#define chkmax(x,y) x=(x>y)?(x):(y)
#define chkmin(x,y) x=(x<y)?(x):(y)
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
inline void write(int x){
	static int sta[42];int top=0;
	if(x<0) putchar('-'),x=-x;
	do{sta[++top]=x%10,x/=10;}while(x);
	while(top) putchar(sta[top--]+'0');
	return putchar('\n'),void();
}
int n;
int inv[110];
int a[500010],b[500010];
int P[500010],Q[500010];
inline int qpow(int x,int k){//标准快速幂。
	int res=1,base=x;
	while(k){
		if(k&1) res=res*base%mod;
		base=base*base%mod;
		k>>=1;
	}
	return res;
}
signed main(){
	n=read();
	for(int i=1;i<=100;i++) inv[i]=i*qpow(100,mod-2)%mod;//预处理逆元。
	for(int i=1;i<=n;i++) a[i]=inv[read()],b[i]=inv[read()];//将百分数转化成逆元的形式。
	P[n]=1,Q[n]=0;//赋上初值。
	for(int i=n-1;i>=0;i--){//注意 要循环到 0，才能求出 P0 的倍数。
		P[i]=(P[i+1]-Q[i+1]*b[i+1]%mod+mod)%mod*qpow(a[i+1],mod-2)%mod;//上面的转移式子，注意随时取 mod 。
		Q[i]=(P[i]*b[i+1]%mod+Q[i+1]*a[i+1]%mod)%mod;
	}
	write(qpow(P[0],mod-2));//得出的是 P0 等于 k 倍的 Pn 所以直接用个逆元就行。
	return 0;
}
```

---

## 作者：wf1594937223 (赞：3)

一道令我感悟很深的题，为做此题我特意去翻了一翻数学一本通，发现自己简直是个菜鸡。

我不善于存概率，所以此处给出一种存储期望，计算时转成概率算的算法。

设 $t_i$ 为通过前 $i$ 层玻璃后还剩 $1$ 单位的光时期望入射多少单位的光，$f_i$ 为从第 $i$ 层下部入射反射回 $1$ 单位的光时期望入射多少单位的光，则：(以下计算时已经将 $a_i,b_i$ 乘以 $100$ 的逆元)。

$\dfrac{1}{t_i} = \dfrac{a_i}{t_{i-1}} \times \sum \limits_{j=0}^{\infty} {(\dfrac {b_i}{f_{i-1}})}^j$

$\dfrac{1}{f_i} = b_i +{\dfrac{{a_i}^2}{f_{i-1}}} \times \sum \limits_{j=0}^{\infty} {(\dfrac {b_i}{f_{i-1}})}^j$

（解释：对于每一个 $j$，表示的是第 $i$ 层与第 $i-1$ 层之间反射了 $j$ 次。）

其中 $\sum \limits_{j=0}^{\infty} {(\dfrac {b_i}{f_{i-1}})}^j$ 可以用[无穷递降等比数列求和公式](https://baike.baidu.com/item/%E6%97%A0%E7%A9%B7%E9%80%92%E9%99%8D%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C%E5%85%AC%E5%BC%8F/5601350?fromtitle=%E6%97%A0%E7%A9%B7%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C%E5%85%AC%E5%BC%8F&fromid=15931777&fr=aladdin)化简为 $\dfrac{1}{1-\frac{b_i}{f_{i-1}}}$，再将 $b_i$ 通一下分，即可得到最终递推式：

$t_i = \dfrac{{t_{i-1} \times f_{i-1} - b_i \times t_{i-1}}}{a_i \times f_{i-1}}$

$f_i = \dfrac{f_{i-1} - b_i}{{a_i}^2 + b_i \times f_{i-1} - {b_i}^2}$

#### 记得考虑以下细节！！！

① 直接除（可能只有我会犯这种错误）：期望得分：$0\ pts$

② 未初始化：期望得分：$0\ pts$

③ 忘记取 $\%$：期望得分：$0\ pts$

④ 输出时未取逆元：期望得分：$0\ pts$

⑤ 未考虑期望为负数：期望得分：$20+\ pts$

⑥ 未特判 $f_{i-1} = 0$的情况：期望得分：$95\ pts$（万绿丛中一点红）

参考代码：（请勿直接复制！否则后果自负！）

```cpp
# include <stdio.h>
long long ft[100010],ff[100010],a[100010],b[100010];
long long MOD=1000000009;
long long niyuan(long long x)
{
	x%=MOD;
	while(x<0)
		x+=MOD;
	long long anss=1,mq=x,s;
	s=MOD-1;
	while(s)
	{
		if(s&1)
			anss=(anss*mq)%MOD;
		mq=(mq*mq)%MOD;
		s>>=1;
	}
	return anss;
}
int main()
{
	int i,j,n,m;
	long long ny_100,ansn=1,zc,zcc,zzc;
	ny_100=niyuan(100);
	scanf("%d",&n);
	for(i=1;i<=n;i++)
	{
		scanf("%lld%lld",&a[i],&b[i]);
	}
	for(i=2;i<=n;i++)
	{
		
		zc=(ft[i-1]*ff[i-1])%MOD-((b[i]*ft[i-1])%MOD)%MOD;
		if(zc<0)
			zc+=MOD;
		zc%=MOD;
		zzc=a[i]*ff[i-1];
		zzc%=MOD;
		zc=((zc*niyuan(zzc))%MOD)%MOD;
		zc%=MOD;
		if(zc<0)
			zc+=MOD;
		zc%=MOD;
		ft[i]=zc;
		if(i==n)
			break;
		zc=a[i]*a[i];
		zc%=MOD;
		zc-=(b[i]*b[i])%MOD;
		if(zc<MOD)
			zc+=MOD;
		zc%=MOD;
		zc+=b[i]*ff[i-1];
		zc%=MOD;
		zzc=ff[i-1]-b[i];
		zzc%=MOD;
		if(zzc<0)
			zzc+=MOD;
		zzc%=MOD;
		ff[i]=niyuan(zc)*zzc;
		ff[i]%=MOD;
	}
	printf("%lld\n",ft[n]);
	return 0;
}

```
#### 自己动手，丰衣足食！

---

## 作者：VenusM1nT (赞：3)

递推。

每片玻璃有反射和透过两种情况，每束光有从上方来和从下方来两种可能，看似情况非常多，但是我们可以分析一下，事实上最终一共只有两种情况：即光向上或向下，我们不妨令 $f[i]$ 表示第 $i$ 片玻璃向下的光，$g[i]$ 表示向上的光，那么可以得到两个显然的式子，即：

$$f[i]=f[i-1]\times a[i]+g[i+1]\times b[i]$$

$$g[i]=f[i-1]\times b[n]+g[i+1]\times a[i]$$

显然这个东西是不能直接递推求的，因为求第 $i$ 项要第 $i-1$ 和第 $i+1$ 项，我们考虑换一种思路，令 $f[i]$ 表示光从第 $1$ 到第 $i$ 片玻璃的透光率，$g[i]$ 表示光从第 $i$ 到第 $1$ 片玻璃的反光率，枚举光的反射次数为 $j$，可以得到：

$$f[i]=f[i-1]\times a[i]\times \sum_{j=0}^{\infty}(g[i-1]\times b[i])^{j}$$

$$g[i]=b[i]+g[i-1]\times a[i]^2\times \sum_{j=0}^{\infty}(g[i-1]\times b[i])^{j}$$

可以看出这是一个无限项的等比数列，而无限项等比数列 $a_n=a_{n-1}\times p$ 求和公式为（经百度）$\sum=\frac{a_{1}}{1-p}$，显然上面两个式子的公比 $p=g[i-1]\times b[i]$，所以我们可以得出：

$$f[i]=\frac{f[i-1]\times a[i]}{1-p}$$

$$g[i]=b[i]+\frac{g[i-1]\times a[i]^{2}}{1-p}$$

直接递推求解即可。

```cpp
#include<bits/stdc++.h>
#define MAXN 500005
#define reg register
#define inl inline
#define int long long
using namespace std;
const int Mod=1e9+7;
int n,a[MAXN],b[MAXN],f[MAXN],g[MAXN];
inl int Add(reg int x,reg int y)
{
	return x+y>Mod?x+y-Mod:x+y;
}
inl int Dec(reg int x,reg int y)
{
	return x-y<0?x-y+Mod:x-y;
}
inl int Mul(reg int x,reg int y)
{
	return x*y-x*y/Mod*Mod;
}
inl int Pow(reg int x,reg int y)
{
	reg int res=1;
	for(;y;y>>=1,x=Mul(x,x)) if(y&1) res=Mul(res,x);
	return res;
}
signed main()
{
	reg int inv=Pow(100,Mod-2);
	scanf("%lld",&n);
	for(reg int i=1;i<=n;i++)
	{
		scanf("%lld %lld",&a[i],&b[i]);
		a[i]=Mul(inv,a[i]);
		b[i]=Mul(inv,b[i]);
	}
	f[0]=1;
	for(reg int i=1;i<=n;i++)
	{
		reg int p=Pow(Dec(1,Mul(g[i-1],b[i])),Mod-2);
		f[i]=Mul(Mul(f[i-1],a[i]),p);
		g[i]=Add(b[i],Mul(Mul(Mul(g[i-1],a[i]),a[i]),p));
	}
	printf("%lld\n",f[n]);
	return 0;
}
```

---

## 作者：wucstdio (赞：2)

集训考了这套题，想到一个做法结果因为考虑不够全面疯狂WA样例，后来换了一个思路AC了……

### 方法1：合并玻璃

先考虑一束光射到两层玻璃上的时候会发生什么。

粘一张题面里面的图：

![](https://cdn.luogu.com.cn/upload/pic/57125.png)

我们设$p,q$分别表示一层玻璃的透光率和反射率。枚举光线在中间反射了几次可以得到：

透过这两层玻璃的光线$P=p_1p_2+p_1q_2q_1p_2+p_1q_2q_1q_2q_1p_2+\cdots$

被反射回来的光线$Q=q_1+p_1q_2p_1+p_1q_2q_1q_2p_1+\cdots$

用个等比数列求和：

$$P=\dfrac{p_1p_2}{1-q_1q_2}$$

$$Q=q_1+\dfrac{p_1^2q_2}{1-q_1q_2}$$

所以，我们可以将这两层玻璃合并成一层玻璃，$P$和$Q$就是新的透光率和反射率。

于是我考场开开心心地写了这样一个算法，然后疯狂WA在第二个样例……

原因很简单：这样合并出来的一块玻璃，从上面射入光线和从下面射入光线是不一样的！这个做法在$n=2$的时候是正确的，但是$n\ge 3$就WA掉了。

解决方案很简单：合并的时候同时记录从上面射入和从下面射入的透光率和反射率，或者改变合并顺序，从下往上合并玻璃（因为不可能有光从下面射入）。

时间复杂度$O(n)$。

code：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define ll long long
using namespace std;
const ll MOD=1e9+7,inv=570000004;
ll quick_pow(ll x,ll a)
{
	ll ans=1;
	while(a)
	{
		if(a&1)ans=ans*x%MOD;
		x=x*x%MOD;
		a>>=1;
	}
	return ans;
}
ll P,Q,n,p[500005],q[500005];
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld",&p[i],&q[i]);
		p[i]=p[i]*inv%MOD,q[i]=q[i]*inv%MOD;
	}
	P=1;
	for(int i=n;i>=1;i--)
	{
		ll p2=P,q2=Q;
		P=p[i]*p2%MOD*quick_pow(1+MOD-q[i]*q2%MOD,MOD-2)%MOD;
		Q=(q[i]+p[i]*p[i]%MOD*q2%MOD*quick_pow(1+MOD-q[i]*q2%MOD,MOD-2)%MOD)%MOD;
	}
	printf("%lld\n",P);
	return 0;
}
```

### 方法2：设未知数

我们设$f_n$表示从第$n$块玻璃射向第$n+1$块玻璃的光，$g_n$表示从第$n+1$块玻璃射向第$n$块玻璃的光。

则可以得到一些方程：

$$f_0=1,g_n=0$$

$$\forall i \in[1,n],f_i=p_if_{i-1}+q_ig_{i-1}$$

$$\forall i \in[1,n],g_{i-1}=p_ig_i+q_if_i$$

如果直接高斯消元，复杂度是$O(n^3)$的。

认真观察后面两个式子可以发现，如果我们知道了$f_{i-1}$和$g_{i-1}$，就可以递推出来$f_i$和$g_i$。

而$f_0$是已知的，所以可以设$g_0=x$，则所有的未知数都可以表示成$ax+b$的形式。

推到最后令$g_n=0$，解出来$x$，带入$f_n$即可。

时间复杂度$O(n)$。

code：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define ll long long
using namespace std;
const ll MOD=1e9+7,inv=570000004;
using namespace std;
ll n,p[500005],q[500005],f[500005][2],g[500005][2];
ll quick_pow(ll x,ll a)
{
    ll ans=1;
    while(a)
    {
        if(a&1)ans=ans*x%MOD;
        x=x*x%MOD;
        a>>=1;
    }
    return ans;
}
int main()
{
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld%lld",&q[i],&p[i]);
        p[i]=p[i]*inv%MOD;
        q[i]=q[i]*inv%MOD;
    }
    f[0][0]=1,f[0][1]=0;
    g[0][0]=0,g[0][1]=1;
    for(int i=1;i<=n;i++)
    {
        g[i][0]=(g[i-1][0]-f[i-1][0]*p[i]%MOD+MOD)*quick_pow(q[i],MOD-2)%MOD;
        g[i][1]=(g[i-1][1]-f[i-1][1]*p[i]%MOD+MOD)*quick_pow(q[i],MOD-2)%MOD;
        f[i][0]=(f[i-1][0]*q[i]+g[i][0]*p[i])%MOD;
        f[i][1]=(f[i-1][1]*q[i]+g[i][1]*p[i])%MOD;
    }
    ll x=-g[n][0]*quick_pow(g[n][1],MOD-2)%MOD;
    printf("%lld\n",(f[n][0]+f[n][1]*x%MOD+MOD)%MOD);
    return 0;
}
```

---

## 作者：popossible (赞：1)

模拟赛考了，翻了一圈题解区发现没有自己的做法，遂写了一篇题解。

先转概率。

我们考虑设 $f_i$ 表示光线从下往上穿过了第 $i$ 块玻璃，然后经过若干传播后由上往下穿过第 $i$ 块玻璃的概率，这样就可以递推了，我们有，
$$
f_i \gets q\times \dfrac{1}{1-b_iq} \times \dfrac{1}{1-b_ib_{i-1}} \times a_i,q=\dfrac{1}{1-b_{i-1}b_i}\times a_{i-1} \times f_{i-1} \\
f_i \gets b_{i-1}\times \dfrac {1} {1-b_i b_{i-1}} \times a_i
$$
上面表示我们又穿回过第 $i-1$ 块玻璃，下面表示没有穿回过，加一起即可。

至于算答案，我们设经过前 $i$ 块玻璃还剩 $x_i$ 的光线，那么递推，
$$
x_{i} (a_i+b_if_i) \to x_{i+1}
$$
直接做就行，时间复杂度 $O(n\log n)$。

---

## 作者：枫林晚 (赞：1)

[戳我](https://www.cnblogs.com/Miracevin/p/10762667.html)

看起来很麻烦，做起来并不难的题

以下设：$a_i=\frac{a_i}{100},b_i=\frac{b_i}{100}$

显然，如果$b_i=0$的话，直接求$\Pi a_i$就是答案。

解决反射问题是这个问题的关键

我们显然可以认为一束光透过之后，可以等其他的光一起
**透过干净** 再往后走。

这样就存在Dp的阶段了。

网上很多从“前i个整体透光率”“整体反光率”什么的，或者枚举反射次数，还要等比数列求和。其实不用这么麻烦。

设$f[i][1]$表示，一单位的光从玻璃i左边射过来，**最终透过的比率**

$f[i][2]$表示，一单位的光从玻璃i右边设过来，**最终反射回来的比率**

（最终就是经过相当长的一段时间后累计的总和。）

递推式很显然了，只要枚举“回收”光线的情况

$f[i][1]=a_i+b_i\times f[i-1][2] \times f[i][1]$

移项，除过去，可以得到：

$f[i][1]=\frac{a_i}{1-b_i\times f[i-1][2]}$

以及：

$f[i][2]=b_i+a_i\times f[i-1][2] \times f[i][1]$

发现存在边界：$f[1][1]=a_1,f[1][2]=b_1$

然后递推。

最后求$\Pi f[i][1]$即可得到答案

```cpp
#include<bits/stdc++.h>
#define reg register int
#define il inline
#define fi first
#define se second
#define mk(a,b) make_pair(a,b)
#define numb (ch^'0')
using namespace std;
typedef long long ll;
template<class T>il void rd(T &x){
    char ch;x=0;bool fl=false;
    while(!isdigit(ch=getchar()))(ch=='-')&&(fl=true);
    for(x=numb;isdigit(ch=getchar());x=x*10+numb);
    (fl==true)&&(x=-x);
}
template<class T>il void output(T x){if(x/10)output(x/10);putchar(x%10+'0');}
template<class T>il void ot(T x){if(x<0) putchar('-'),x=-x;output(x);putchar(' ');}
template<class T>il void prt(T a[],int st,int nd){for(reg i=st;i<=nd;++i) ot(a[i]);putchar('\n');}

namespace Miracle{
const int N=5e5+5;
const int mod=1e9+7;
int n;
int iv;
int a[N],b[N];
int ad(int x,int y){
    return x+y>=mod?x+y-mod:x+y;
}
int qm(int x,int y){
    int ret=1;
    while(y){
        if(y&1) ret=(ll)ret*x%mod;
        x=(ll)x*x%mod;
        y>>=1;
    }
    return ret;
}
int f[N][3];
int main(){
    iv=qm(100,mod-2);
    rd(n);
    for(reg i=1;i<=n;++i){
        rd(a[i]);rd(b[i]);
        a[i]=(ll)a[i]*iv%mod;
        b[i]=(ll)b[i]*iv%mod;
    }
    f[1][1]=a[1];
    f[1][2]=b[1];
    for(reg i=2;i<=n;++i){
        f[i][1]=(ll)a[i]*qm(ad(1,mod-(ll)b[i]*f[i-1][2]%mod),mod-2)%mod;
        f[i][2]=ad(b[i],(ll)a[i]*f[i-1][2]%mod*f[i][1]%mod);
    }
    int ans=1;
    for(reg i=1;i<=n;++i){
        ans=(ll)ans*f[i][1]%mod;
    }
    cout<<ans;
    return 0;
}

}
signed main(){
	Miracle::main();
	return 0;
}

/*
   Author: *Miracle*
*/


```


---

## 作者：Great_Influence (赞：1)

这是一道套路物理题。

我们不管具体是怎么反射的，直接设 $pr[i]$ 表示第 $i$ 面玻璃总向前发射的光量， $sf[i]$ 表示第 $i$ 面玻璃总向后发射的光亮，则：

$$sf[i]=\frac{a}{100}sf[i-1]+\frac{b}{100}pr[i+1]$$

$$pr[i]=\frac{a}{100}pr[i+1]+\frac{b}{100}sf[i-1]$$

$$sf[0]=1,pr[n+1]=0$$

为了方便设 $A_i=\frac{a_i}{100}$ ， $B_i=\frac{b_i}{100}$ 。

可以发现，每个点的 $pr$ 和 $sf$ 只与它两边点的 $pr$ 或 $sf$ 相关，那么这就是一个套路了。

根据套路，我们可以将左边部分化式子化掉，然后就只剩下和右边 $pr$ 和 $sf$ 的部分了。再利用 $pr[n+1]=0$ 直接得到答案。

我们设 $pr[i]=a_ipr[i+1]+b_i$ ， $sf[i]=c_ipr[i+1]+d_i$ ，则

$$pr[i]=A_ipr[i+1]+B_isf[i-1]$$

$$=A_ipr[i+1]+B_i(c_{i-1}pr[i]+d_{i-1})$$

$$=A_ipr[i+1]+B_icpr[i]+B_id_{i-1}$$

$$=\frac{A_i}{1-B_ic_{i-1}}pr[i+1]+\frac{B_id_{i-1}}{1-B_ic_{i-1}}$$

根据类似的过程，可以得到另一个转移(步骤就省掉了):

$$sf[i]=B_i+\frac{A_i^2c_{i-1}}{1-B_ic_{i-1}}pr[i+1]+\frac{A_iB_ic_{i-1}d_{i-1}}{1-B_ic_{i-1}}+A_id_{i-1}$$

那么就有转移式:

$$a_i=\frac{A_i}{1-B_ic_{i-1}}$$

$$b_i=\frac{B_id_{i-1}}{1-B_ic_{i-1}}$$
$$c_i=B_i+\frac{A_i^2c_{i-1}}{1-B_ic_{i-1}}$$

$$d_i=A_id_{i-1}+\frac{A_iB_ic_{i-1}d_{i-1}}{1-B_ic_{i-1}}$$

最后，因为 $pr[n+1]=0$ ，答案为 $d_n$ 。

时间复杂度 $O(n\log n)$ ，瓶颈在求逆。

代码:
```cpp
#include<cstdio>
#include<cstdlib>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cassert>
#include<queue>
#include<iostream>
#include<climits>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define rep(i,a,b) for(register int i=(a);i<(b);++i)
#define pb push_back
#define mp make_pair
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
	const uint32 Buffsize=1<<15,Output=1<<24;
	static char Ch[Buffsize],*S=Ch,*T=Ch;
	inline char getc()
	{
		return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
	}
	static char Out[Output],*nowps=Out;
	
	inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

	template<typename T>inline void read(T&x)
	{
		x=0;static char ch;T f=1;
		for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
		x*=f;
	}

	template<typename T>inline void write(T x,char ch='\n')
	{
		if(!x)*nowps++='0';
		if(x<0)*nowps++='-',x=-x;
		static uint32 sta[111],tp;
		for(tp=0;x;x/=10)sta[++tp]=x%10;
		for(;tp;*nowps++=sta[tp--]^48);
		*nowps++=ch;
		if(nowps-Out>=1<<23)flush();
	}

	inline void getstr(char*q)
	{
		register char ch;
		for(ch=getc();!isgraph(ch);ch=getc());
		for(;isgraph(ch);ch=getc())*q++=ch;
		*q='\0';
	}

	inline void getwd(char&x){for(x=getc();!isupper(x);x=getc());}
}
using namespace IO;

void file()
{
#ifndef ONLINE_JUDGE
	FILE*DSD=freopen("water.in","r",stdin);
	FILE*CSC=freopen("water.out","w",stdout);
#endif
}

inline void Chkmin(int&u,int v){u>v?u=v:0;}

inline void Chkmax(int&u,int v){u<v?u=v:0;}

inline void Chkmax(double&u,double v){u<v?u=v:0;}

inline void Chkmax(ll&u,ll v){u<v?u=v:0;}

inline void Chkmin(ll&u,ll v){u>v?u=v:0;}

const int MAXN=5e5+7,mod=1e9+7;

static int n;

inline int ad(int u,int v){return(u+=v)>=mod?u-mod:u;}

static int A[MAXN],B[MAXN];

inline void init()
{
	read(n);
	Rep(i,1,n)read(A[i]),read(B[i]);
}

inline int power(int u,int v)
{
	register int sm;
	for(sm=1;v;v>>=1,u=(ll)u*u%mod)if(v&1)
		sm=(ll)sm*u%mod;
	return sm;
}

const int inv100=power(100,mod-2);

static int a[MAXN],b[MAXN],c[MAXN],d[MAXN];

inline void solve()
{
	Rep(i,1,n)A[i]=(ll)A[i]*inv100%mod,B[i]=(ll)B[i]*inv100%mod;
	d[0]=1;
	Rep(i,1,n)
	{
		int w=power(mod+1-(ll)B[i]*c[i-1]%mod,mod-2);
		a[i]=(ll)A[i]*w%mod;
		b[i]=(ll)B[i]*d[i-1]%mod*w%mod;
		c[i]=(B[i]+(ll)A[i]*A[i]%mod*c[i-1]%mod*w)%mod;
		d[i]=((ll)A[i]*d[i-1]+(ll)A[i]*B[i]%mod*c[i-1]%mod*d[i-1]%mod*w)%mod;
	}
	printf("%d\n",d[n]);
}

int main()
{
	file();
	init();
	solve();
	return 0;
}
```

---

## 作者：摸鱼酱 (赞：0)

### [P5323 [BJOI2019]光线](https://www.luogu.com.cn/problem/P5323)

主要详细写写系数怎么暴力化开。

光线视作从左射入，从右射出。

设 $L_i,R_i$ 为 **所有** 从第 $i$ 块玻璃向左和向右射出的光线数量。

那么显然有

$$
\begin{aligned}
R_i=a_i·R_{i-1}+b_i·L_{i+1}\\
L_i=b_i·R_{i-1}+a_i·L_{i+1}
\end{aligned}
$$

特殊地，对于第 $n$ 个位置，我们还有

$$
\begin{aligned}
R_n=a_n·R_{n-1}\\
L_n=b_n·R_{n-1}
\end{aligned}
$$

可以发现貌似 $R_i$ 和 $L_i$ 都可以用 $R_{i-1}$ 来表示，于是就考虑设 $L_i=A_i·R_{i-1},R_i=B_i·R_{i-1}$ 。

于是瞄一眼数据范围，思考怎么递推系数。初始我们有 $A_n=b_n,B_n=a_n$ 。

$$
\begin{aligned}
R_i&=a_i·R_{i-1}+b_i·L_{i+1}\\
R_i&=a_i·R_{i-1}+b_i·A_{i+1}·R_i\\
(1-b_i·A_{i+1})R_i&=a_i·R_{i-1}\\
R_i&=\frac{a_i}{1-b_i·A_{i+1}}·R_{i-1}\\
∴B_i&=\frac{a_i}{1-b_i·A_{i+1}}\\
L_i&=b_i·R_{i-1}+a_i·A_{i+1}·R_i\\
L_i&=b_i·R_{i-1}+a_i·A_{i+1}·B_i·R_{i-1}\\
L_i&=(b_i+a_i·A_{i+1}·B_i)·R_{i-1}\\
∴A_i&=b_i+a_i·A_{i+1}·B_i\\
\end{aligned}
$$

最后 $Ans=\prod_{i=1}^nB_i$ 。

code:

```cpp
#include<bits/stdc++.h>
#define reg register
#define For(i,a,b) for(reg int i=(a),i##END=(b);i<=i##END;i++)
#define int long long
using namespace std;
inline int read(){
   int x=0,f=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
   while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
   return x*f;
}
const int mod=1e9+7;
int inv(int a,int b=mod-2){
	int x=1;
	while(b){
		if(b&1)(x*=a)%=mod;
		(a*=a)%=mod,b>>=1;
	}
	return x;
}
const int N=5e5+10;
int a[N],b[N],A[N],B[N];
signed main(){
	int inv100=inv(100);
	int n=read();
	For(i,1,n)a[i]=read()*inv100%mod,b[i]=read()*inv100%mod;
	A[n]=b[n],B[n]=a[n];
	for(int i=n-1;i>=1;i--)
		B[i]=a[i]*inv((mod+1-b[i]*A[i+1]%mod)%mod)%mod,
		A[i]=a[i]*A[i+1]%mod*B[i]%mod+b[i],A[i]%=mod;
	int ans=1;
	For(i,1,n)ans=ans*B[i]%mod;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：ticmis (赞：0)

**前置芝士：等比数列的通项公式**

对于首项为$a_1$,公比为$q$的等比数列，前$n$项和$S_n$的通项公式如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/m40a2rc2.png)

证明比较容易，简略思路为将$q\times S_n -S_n$的展开推导，这里就交给读者独立完成了

**dp推导**

**令$f[i]$为从右向左抵达第$i$层玻璃后，能向右返回的百分比**

![JMY7pn.png](https://s1.ax1x.com/2020/04/19/JMY7pn.png)

一道绿光进入第二层玻璃后，黑光会到处反射或穿透，最终回来的红光就是$f[2]$所代表的部分

观查得出，红光可以如下分类：直接在第$i$层反射的光、在第$i-1$层反射了**一**次后回来的光、在第$i-1$层反射了**两**次后回来的光......

![](https://cdn.luogu.com.cn/upload/image_hosting/jsoqj8xi.png)

发现，除第一项外，后面项构成了$a_1=a[i]\%\times a[i]\%\times f[i-1]$，$q=b[i]\%\times f[i-1]$的等比数列，因此用通项公式加以优化

![](https://cdn.luogu.com.cn/upload/image_hosting/gtvebcal.png)

由于数列有无数项，因此$f[i]$递推公式的最终版为：

![](https://cdn.luogu.com.cn/upload/image_hosting/2uhl4k3z.png)

**令$g[i]$为光线到达第$i$层玻璃后，能从第$n$层射出的部分**

还是分情况讨论：直接穿透到下一层、在第$i-1$层折回**一**次后穿透、在第$i-1$层折回**两**次后穿透....

![](https://cdn.luogu.com.cn/upload/image_hosting/02yk74q6.png)

同样用等比数列的通项和公式优化

![](https://cdn.luogu.com.cn/upload/image_hosting/g1td9glr.png)

至此，我们得到了$f[]$和$g[]$的通项公式，答案即为$g[1]$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define lor(a,b,c) for(register int a=b;a<=c;++a)
#define ror(a,b,c) for(register int a=c;a>=b;--a)
typedef long long ll;

const int N=5e5+5;
const ll MOD=1e9+7,REV=570000004;

int n; ll a[N],b[N],f[N],g[N];

inline ll qsm(ll x,ll y) {ll ans=1ll; while(y) {if(y&1) (ans*=x)%=MOD; (x*=x)%=MOD; y>>=1;} return ans;}
inline void inc(ll &a,ll b) {(a+=b)>=MOD?a-=MOD:a;}

int main(){
	#ifndef ONLINE_JUDGE
	freopen("test.in","r",stdin);
	#endif

	scanf("%d",&n); lor(i,1,n) scanf("%lld%lld",&a[i],&b[i]);
	f[0]=0ll;
	lor(i,1,n-1){
		f[i]=b[i]*REV%MOD;
		ll t1=a[i]*a[i]%MOD*REV%MOD*REV%MOD*f[i-1]%MOD,t2=1ll,t3=b[i]*REV%MOD*f[i-1]%MOD;;
		inc(t2,MOD-t3); (t1*=qsm(t2,MOD-2))%=MOD; inc(f[i],t1);
	}
	g[n+1]=1ll;
	ror(i,1,n){
		g[i]=a[i]*REV%MOD*g[i+1]%MOD;
		ll t1=1ll,t2=b[i]*REV%MOD*f[i-1]%MOD; inc(t1,MOD-t2); (g[i]*=qsm(t1,MOD-2))%=MOD;
	}
	printf("%lld\n",g[1]);

	return 0;
}
```




---

## 作者：asuldb (赞：0)

[题目](https://www.luogu.org/problemnew/show/P5323)

有点奇怪的题目

我们设$dp_i$表示经过$1$单位的光经过前$i$面镜子后变成了多少，也就是前$i$面镜子整体的透光率

设$f_i$表示倒着（即从第$i$面镜子到第$1$面镜子）射入$1$单位的光，反射出去的光为多少，或者说是这$i$面镜子整体的反光率

我们考虑如何求出$dp_i$和$f_i$

先考虑$dp_i$

首先有$dp_{i-1}$的光直接过来了，这些光有$a_i$直接穿过，为$dp_{i-1}\times a_i$

还有$b_i$被反射回去，也就是是有$dp_{i-1}\times b_i$的光倒着穿过了前$i$面镜子，反射回来的光是$dp_{i-1}\times b_i\times f_{i-1}$，这些光又有$a_i$穿过第$i$面镜子

如果往下继续写，我们会发现得到这样一个柿子

$$dp_{i}=a_i\sum_{j=0}^{\infty}dp_{i-1}(f_{i-1}b_i)^j$$

对后面求一下和

$$dp_{i}=\frac{a_i\times dp_{i-1}}{1-f_{i-1}b_i}$$

再来考虑$f_i$

首先有$1$的光射了过来，有$b_i$直接被反射回去，这里是$b_i$

但是有$a_i$的光射了进去，所以有$f_{i-1}\times a_i$的光被反射回来，这些光在经过第$i$面镜子，反射出来的是$f_{i-1}\times a_i^2$

继续往下写，我们得到了这样的柿子

$$f_i=b_i+\sum_{j=0}^{\infty}a_i^2f_{i-1}(f_{i-1}b_i)^j=b_i+\frac{f_{i-1}\times a_{i}^2}{1-f_{i-1}b_i}$$

于是我们递推就好了，答案就是$dp_n$

代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define re register
const int maxn=5e5+5;
const int inv=570000004;
const int mod=1e9+7;
inline int read() {
	char c=getchar();int x=0;while(c<'0'||x>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
int n;
int dp[maxn],a[maxn],b[maxn],f[maxn];
inline int ksm(int a,int b) {
	int S=1;
	while(b) {if(b&1) S=(1ll*S*a)%mod;b>>=1;a=(1ll*a*a)%mod;}
	return S;
}
int main() {
	n=read();
	for(re int i=1;i<=n;i++) a[i]=read(),b[i]=read();
	for(re int i=1;i<=n;i++) a[i]=(1ll*a[i]*inv)%mod,b[i]=(1ll*b[i]*inv)%mod;
	dp[1]=a[1],f[1]=b[1];
	for(re int i=2;i<=n;i++) {
		int Inv=ksm(1-1ll*b[i]*f[i-1]%mod+mod,mod-2);
		f[i]=(1ll*a[i]*a[i]%mod*f[i-1]%mod*Inv%mod);
		f[i]=(f[i]+b[i])%mod;
		dp[i]=(1ll*a[i]*dp[i-1]%mod*Inv)%mod;
	}
	printf("%d\n",dp[n]);
	return 0;
}
```


---


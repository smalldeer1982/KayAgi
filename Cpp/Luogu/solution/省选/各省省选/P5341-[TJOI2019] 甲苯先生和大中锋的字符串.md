# [TJOI2019] 甲苯先生和大中锋的字符串

## 题目背景

TJOI2019 D2T2

源文件名：substring.*

时间限制: 1s 内存限制: 128M

## 题目描述

大中锋有一个长度为 $n$ 的字符串，他只知道其中的一个子串是祖上传下来的宝藏的密码。但是由于字符串很长，大中锋很难将这些子串一一尝试。

这天大中锋找到甲苯先生算命，但是甲苯先生说：“天机不可泄漏”。

在大中锋的苦苦哀求下，甲苯先生告诉大中锋：“密码是在字符串中恰好出现了 $k$ 次的子串”。

但是大中锋不知道该怎么做，在大中锋再三的恳求下，甲苯先生看其真诚，又告诉他：“在恰好出现了 $k$ 次的子串中，你去按照字串的长度分类，密码就在数量最多的那一类里”。

大中锋为了尝试这个密码，想让你帮忙找出子串长度出现次数最多的长度数（如果有多个输出最长长度）。

## 说明/提示

### 数据说明 ###

对于第一个数据：其中子串 $b, aa, ab, aab$ 均只出现一次，其中长度为 $1$ 的子串出现了 $1$ 次，长度为 $2$ 的子串出现了 $2$ 次，长度为 $3$ 的子串出现了 $1$ 次。所以答案为 $2$ 。

对于第二个数据：其中子串 $a, b, c, ab, bc, abc$ 均只出现一次，其中长度为 $1$ 的子串出现了 $3$ 次，长度为 $2$ 的子串出现了 $2$ 次，长度为 $3$ 的子串出现了 $1$ 次。所以答案为 $1$ 。

对于第三个数据：其中子串 $aaa$ 出现二次，长度为 $3$ 的子串出现了 $1$ 次，其他长度均没有。所以答案为 $3$ 。

对于第四个数据：其中子串 $a, b, ab$ 出现二次，其中长度为 $1$ 的子串出现了 $2$ 次，长度为 $2$ 的子串出现了 $1$ 次。所以答案为 $1$ 。

对于第五个数据：其中子串 $b, c, ab, ba$ 出现二次，其中长度为 $1$ 的子串出现了 $2$ 次，长度为 $2$ 的子串出现了 $2$ 次。所以答案为 $2$ 。

对于第六个数据：其中子串没有出现四次。所以本题的本题的答案为 $-1$ 。

### 数据范围 ###

对于 $20\%$ 的数据， $1\leq k\leq n\leq 10$

对于 $100\%$ 的数据， $1\leq n\leq 10^5,1 \leq T \leq 100,\sum n \leq 3 * 10^6$ ，输入的字符串中仅包含小写英文字母。

## 样例 #1

### 输入

```
6
aab 1
abc 1
aaaa 2
abab 2
ababacc 2
abab 4```

### 输出

```
2
1
3
1
2
-1```

# 题解

## 作者：iostream (赞：11)

### 前置技能：后缀自动机

直接对读入的字符串建SAM，并且对其$parent$树统计$sz[u]$表示子树大小。

那么一个节点表示的字符串的出现子串出现次数就是$sz_i$

那么扫描所有$sz_i==k$的节点，该节点表示的所有子串都是可行的，而且它们的长度一定是连续的一段区间$(len_{fa_i},len_i]$

那么直接进行差分就好了，整个时间复杂度$O(n)$。

```cpp

#include<set>
#include<map>
#include<cmath>
#include<vector>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#define pb push_back
#define fi first
#define se second
#define mp make_pair
using namespace std;

typedef double db;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pi;

const int N=200005;

int tot=1,la,ch[N][26],fa[N],len[N],ar[N],sz[N],rk[N],cnt[N];

void extend(int id)
{
	int p=la;
	int np=++tot;
	len[np]=len[p]+1;
	while(p && !ch[p][id])
	{
		ch[p][id]=np;
		p=fa[p];
	}
	if(!p)
	{
		fa[np]=1;
	}
	else
	{
		int q=ch[p][id];
		if(len[p]+1==len[q])
		{
			fa[np]=q;
		}
		else
		{
			int nq=++tot;
			fa[nq]=fa[q];
			len[nq]=len[p]+1;
			for(int i=0; i<26; i++)
				ch[nq][i]=ch[q][i];
			fa[np]=nq;
			fa[q]=nq;
			while(p && ch[p][id]==q)
			{
				ch[p][id]=nq;
				p=fa[p];
			}
		}
	}
	++sz[la=np];
}

void Sort()
{
	for(int i=1; i<=tot; i++) ar[len[i]]++;
	for(int i=1; i<=tot; i++) ar[i]+=ar[i-1];
	for(int i=1; i<=tot; i++) rk[ar[len[i]]--]=i;
}

int T,n,k,mx,ans;

char S[N];

int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%s%d",S+1,&k);
		n=strlen(S+1);
		la=1;
		for(int i=1; i<=n; i++) extend(S[i]-'a');
		Sort();
		auto upd=[](int l,int r){cnt[l]++;cnt[r+1]--;};
		for(int i=tot; i!=1; i--)
		{
			int now=rk[i];
			sz[fa[now]]+=sz[now];
			if(sz[now]==k) upd(len[fa[now]]+1,len[now]);
		}
		mx=ans=-1;
		for(int i=1; i<=n; i++)
		{
			cnt[i]+=cnt[i-1];
			if(cnt[i]>=mx)
			{
				mx=cnt[i];
				ans=i;
			}
		}
		printf("%d\n",mx>0?ans:-1);
		for(int i=1; i<=tot; i++)
		{
			len[i]=fa[i]=sz[i]=ar[i]=0;
			memset(ch[i],0,sizeof(ch[i]));
		}
		tot=1;
		for(int i=0; i<=n+1; i++) cnt[i]=0;
	}
	return 0;
}


---

## 作者：Diaоsi (赞：8)

### Update1:修了一点小锅

------------

[[TJOI2019]甲苯先生和大中锋的字符串](https://www.luogu.com.cn/problem/P5341)

提供一个 $\mathcal{SA}$ 的做法。

题面有点绕，大意是找出仅出现 $k$ 次的子串集合，然后统计出现最多的子串长度。

考虑如何求出子串集合，先建好 height 数组，问题可以转化为在 height 数组上找一个长度为 $k$ 的连续区间，求在排序后的后缀中仅能出现在这段区间内的“公共前缀”有那些。

设区间 $[i,i+k-1]$ 的“公共前缀”长为 $l$ ，考虑 $l$ 的范围，显然 $l$ 最大只能是 $\text{lcp}_{i}^{i+k-1}$ , 也就是经过排序的后缀在这段区间的**最长公共前缀**。

根据 height 数组的定义，有 $\text{lcp}_{i}^{i+k-1}=\min_{j=i+1}^{i+k-1}\{h_{j}\}$ ，$h$ 表示 height 数组，对于前面这个式子可以用一个能维护 RMQ 问题的数据结构就行。

接下来考虑 $l$ 的下界，先给出结论，若要满足这段“公共前缀”不能在区间 $[i,i+k-1]$ 出现过，则 $l > \max(h_i,h_{i+k})$ 。

感性证明一下，若 $l \leq h_i,h_{i+k}$ ，则说明长度为 $l$ 的“公共前缀”已经超过了 $k$ 个，是与“仅出现 $k$ 次”矛盾的。

于是我们可以对 height 数组做一个类似于滑动窗口的东西，用差分数组维护每个区间对应的 $l$ 的值域，跑完之后求那个长度出现最多即可。

既然你能找到这题，我相信你能瞬间做出来的。

$Code:$

```cpp
#include<bits/stdc++.h>
typedef long long LL;
typedef long double LD;
using namespace std;
const LL N=100010,INF=0x3f3f3f3f;
inline LL Max(LL x,LL y){return x>y?x:y;}
inline LL Min(LL x,LL y){return x<y?x:y;}
inline void Swap(LL &x,LL &y){x^=y^=x^=y;}
LL T,n,m,k,cf[N];
char s[N];
namespace SA{
LL sa[N],height[N],c[N],x[N],y[N],rk[N];
void get_sa(){
	for(LL i=1;i<=m;i++)c[i]=0;
	for(LL i=1;i<=n;i++)c[x[i]=s[i]]++;
	for(LL i=2;i<=m;i++)c[i]+=c[i-1];
	for(LL i=n;i>=1;i--)sa[c[x[i]]--]=i;
	for(LL w=1;w<=n;w<<=1){
		LL num=0;
		for(LL i=n-w+1;i<=n;i++)y[++num]=i;
		for(LL i=1;i<=n;i++)
			if(sa[i]>w)y[++num]=sa[i]-w;
		for(LL i=1;i<=m;i++)c[i]=0;
		for(LL i=1;i<=n;i++)c[x[i]]++;
		for(LL i=2;i<=m;i++)c[i]+=c[i-1];
		for(LL i=n;i>=1;i--)sa[c[x[y[i]]]--]=y[i],y[i]=0;
		std::swap(x,y);
		x[sa[1]]=num=1;
		for(LL i=2;i<=n;i++)
			x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+w]==y[sa[i-1]+w])?num:++num;
		if(num==n)break;
		m=num;
	}
}
void get_height(){
	for(LL i=1;i<=n;i++)rk[sa[i]]=i;
	for(LL i=1,k=0;i<=n;i++){
		if(rk[i]==1)continue;
		if(k)k--;
		LL j=sa[rk[i]-1];
		while(i+k<=n&&j+k<=n&&s[i+k]==s[j+k])k++;
		height[rk[i]]=k;
	}
}
}
struct SegmentTree{
	LL l,r;
	LL mn;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define mn(x) tree[x].mn
}tree[N<<2];
void Pushup(LL x){
	mn(x)=Min(mn(x<<1),mn(x<<1|1));
}
void Build(LL x,LL l,LL r){
	l(x)=l,r(x)=r;mn(x)=0;
	if(l==r){mn(x)=SA::height[l];return;}
	LL mid=(l+r)>>1;
	Build(x<<1,l,mid);
	Build(x<<1|1,mid+1,r);
	Pushup(x);
}
LL Query(LL x,LL L,LL R){
	LL l=l(x),r=r(x);
	if(L<=l&&r<=R)return mn(x);
	LL mid=(l+r)>>1;
	LL val=INF;
	if(L<=mid)val=Min(val,Query(x<<1,L,R));
	if(R>mid)val=Min(val,Query(x<<1|1,L,R));
	return val;
}
int main(){
	scanf("%lld",&T);
	while(T--){
		scanf("%s%lld",s+1,&k);	
		n=strlen(s+1);m=122;
		memset(cf,0,sizeof(cf));
		SA::height[n+1]=0;
		SA::get_sa();
		SA::get_height();
		Build(1,1,n);
		for(LL i=1;i+k-1<=n;i++){
			LL l=i,r=i+k-1,L,R;
			if(l+1>r)R=n-SA::sa[r]+1;
			else R=Query(1,l+1,r);
			L=Max(SA::height[l],SA::height[r+1])+1;
			if(L<=R)++cf[L],--cf[R+1];
		}
		LL ans=-1,maxv=1;
		for(LL i=1;i<=n;i++){
			cf[i]+=cf[i-1];
			if(cf[i]>=maxv)ans=i,maxv=cf[i];
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：米奇 (赞：5)

## 题解（后缀数组）：

后缀数组好题，题解说是大水题，但我看不出来。

题还是做得太少，对后缀数组的理解也太浅。

我们用一个长度为k的滑块去滑字符串。

字符串的先后顺序是按后缀排序来的。

我们维护了区间的最小height值，记为x，

这是什么？

如果x为0，说明这样的前缀失败了，出现次数不到k

如果x不为0，说明此时长度为x的前缀至少有k个

但我们要求恰好为k的个数

那怎么办呢？

有了，我们判一下,h[i-k+1]和h[i+1]

如果这两个值中有值大于等于x，这说明此时长度为x的前缀超过了k个

否则这样长度为x的前缀恰好等于k个。

考虑前缀中能分出多少的前缀恰好等于k，最小的就是max(h[i-k+1],h[i+1])+1,最大的是x

计算答案就差分一下即可，维护最大值 .



## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define next Next
const int N=4e5+5;
int n,m,k,q[N],cf[N],sa[N],height[N],x[N],y[N],c[N],rk[N];
char a[N];
/*char buf[1<<21],*p1=buf,*p2=buf;
inline int gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}*/
#define gc getchar
inline int read()
{
	int ret=0,f=0;char c=gc();
	while(!isdigit(c)){if(c=='-')f=1;c=gc();}
	while(isdigit(c)){ret=ret*10+c-48;c=gc();}
	if(f)return -ret;return ret;
}
void SA(int n,int m)
{
	int p;
	for(int i=0;i<=n;i++)
	{
		sa[i]=rk[i]=x[i]=y[i]=0;
	}
    for(int i=1;i<=m;i++)c[i]=0;
    for(int i=1;i<=n;i++)c[x[i]=a[i]]++;
    for(int i=1;i<=m;i++)c[i]+=c[i-1];
    for(int i=n;i;i--)sa[c[x[i]]--]=i;
    for(int i=1;i;i=i*2)
    {
        p=0;
        for(int j=n-i+1;j<=n;j++)y[++p]=j;
        for(int j=1;j<=n;j++)
            if(sa[j]>i)y[++p]=sa[j]-i;
        for(int j=1;j<=m;j++)c[j]=0;
        for(int j=1;j<=n;j++)c[x[y[j]]]++;
        for(int j=1;j<=m;j++)c[j]+=c[j-1];
        for(int j=n;j;j--)sa[c[x[y[j]]]--]=y[j];
        swap(x,y);
        x[sa[1]]=1;
        p=2;
        for(int j=2;j<=n;j++)
        {
            if(y[sa[j]]==y[sa[j-1]]&&y[sa[j]+i]==y[sa[j-1]+i])x[sa[j]]=p-1;
            else x[sa[j]]=p++;
        }
        if(p>n)return;
        m=p;
    }
}
void Height()
{
    int k=0;
    for(int i=1;i<=n;i++)rk[sa[i]]=i;
    for(int i=1;i<=n;i++)
    {
        if(rk[i]==1)continue;
        if(k)k--;
        int j=sa[rk[i]-1];
        while(i+k<=n&&j+k<=n&&a[i+k]==a[j+k])k++;
        height[rk[i]]=k;
    }
}
signed main()
{
	int T=read();
	while(T--)
	{
		memset(cf,0,sizeof(cf));
		scanf("%s",a+1);
		n=strlen(a+1);
		k=read();
		height[n+1]=0;
		SA(n,122);
		Height();
		int l=1,r=0;
		for(int i=1;i<=k;i++)
		{
			while(l<=r&&height[q[r]]>=height[i])r--;
			q[++r]=i;
		}
		for(int i=k;i<=n;i++)
		{
			if(i-q[l]+1>=k)l++;
			while(l<=r&&height[q[r]]>=height[i])r--;
			q[++r]=i;
			int R;
            if(k==1)R=n-sa[i+k-1]+1;
            else R=height[q[l]];
            int L=max(height[i-k+1],height[i+1]);
            if(L<R)
			{
				cf[L+1]++;
				cf[R+1]--;
			}
		}
		int sum=cf[0],ma=1,ans=-1;
		for(int i=1;i<=n;i++)
		{
			sum+=cf[i];
			if(sum>=ma)
			{
				ma=sum;
				ans=i;
			}
		}
		printf("%d\n",ans);
	}
	return 0;
}
/*
后缀数组好题，题解说是大水题，但我看不出来。
题还是做得太少，对后缀数组的理解也太浅。
我们用一个长度为k的滑块去滑字符串。
字符串的先后顺序是按后缀排序来的。
我们维护了区间的最小height值，记为x，
这是什么？
如果x为0，说明这样的前缀失败了，出现次数不到k
如果x不为0，说明此时长度为x的前缀至少有k个
但我们要求恰好为k的个数
那怎么办呢？
有了，我们判一下,h[i-k+1]和h[i+1]
如果这两个值中有值大于等于x，这说明此时长度为x的前缀超过了k个
否则这样长度为x的前缀恰好等于k个。
考虑前缀中能分出多少的前缀恰好等于k，最小的就是max(h[i-k+1],h[i+1])+1,最大的是x
计算答案就差分一下即可，维护最大值 .
*/
```



---

## 作者：Adove (赞：4)

我在这里讲一下SA的做法

首先我们求下Height数组

我们用长为k的滑块在上面滑动

出现恰好k次，意味着

$\max\{Height_l,Height_{r+1}\} \leq ln \leq \min\{Height_{l+1\ to \ r}\}$

符合条件的长度是一段区间

我们可以离线下来差分统计

~~SA空间小常数小为什么非要用SAM呢~~

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=1e5+5;

int n,T,mx,hd,tl;
char ch[MAXN];
int id[MAXN],rnk[MAXN],SA[MAXN],bnk[MAXN],Ht[MAXN];
int cnt[MAXN],q[MAXN];

int read()
{
    int x=0;char ch=getchar();
    while(ch<'0'||'9'<ch) ch=getchar();
    while('0'<=ch&&ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
    return x;
}

void shel()
{
    for(int i=1;i<=n;++i) ++bnk[rnk[i]];
    for(int i=1;i<=mx;++i) bnk[i]+=bnk[i-1];
    for(int i=1;i<=n;++i) SA[++bnk[rnk[id[i]]-1]]=id[i];
    for(int i=0;i<=mx;++i) bnk[i]=0;
}

void GetSA()
{
    mx=0;
    for(int i=1;i<=n;++i) id[i]=i,rnk[i]=ch[i],mx=mx<rnk[i]?rnk[i]:mx;
    shel();
    for(int k=1;k<n;k<<=1){
        for(int i=1;i<=k;++i) id[i]=n-k+i;
        int ct=k;
        for(int i=1;i<=n;++i) if(SA[i]>k) id[++ct]=SA[i]-k;
        shel();swap(rnk,id);rnk[SA[1]]=1;
        for(int i=2;i<=n;++i){
            if(id[SA[i]]==id[SA[i-1]]&&id[SA[i]+k]==id[SA[i-1]+k]) rnk[SA[i]]=rnk[SA[i-1]];
            else rnk[SA[i]]=rnk[SA[i-1]]+1;
        }if(rnk[SA[n]]==n) break;
        mx=rnk[SA[n]];
    }return;
}

void GetHt()
{
    int k=0;
    for(int i=1;i<=n;++i){
        if(rnk[i]==1) continue;
        int tmp=SA[rnk[i]-1];
        k=k?k-1:0;
        while(tmp+k<=n&&i+k<=n&&ch[i+k]==ch[tmp+k]) ++k;
        Ht[rnk[i]]=k;
    }return;
}

int GetLCP(int x,int y)
{
    if(x>y) return n-SA[y]+1;
    return Ht[q[hd]];
}

int main()
{
    T=read();
    while(T--){
        memset(id,0,sizeof(id));
        memset(cnt,0,sizeof(cnt));
        scanf("%s",ch+1);n=strlen(ch+1);
        int w;scanf("%d",&w);Ht[n+1]=0;
        GetSA(),GetHt();hd=1;tl=0;
        for(int i=2;i<=w;++i){
            while(hd<=tl&&Ht[q[tl]]>=Ht[i]) --tl;
            q[++tl]=i;
        }for(int i=w;i<=n;++i){
            if(i-q[hd]+1>=w) ++hd;
            while(hd<=tl&&Ht[q[tl]]>=Ht[i]) --tl;
            q[++tl]=i;
            int tmp=GetLCP(i+1,i+w-1);
            int g=max(Ht[i-w+1],Ht[i+1]);
            if(g<=tmp) ++cnt[g+1],--cnt[tmp+1];
        }int tmp=-1,mm=1;
        for(int i=1;i<=n;++i){
            cnt[i]+=cnt[i-1];
            if(cnt[i]>=mm) mm=cnt[i],tmp=i;
        }printf("%d\n",tmp);
    }return 0;
}
```

---

## 作者：Prean (赞：2)

SAM一道很裸的题。。。

题意很明确，不再阐述。

做法很简单：找到所有出现次数为 $ k $ 的子串，然后统计。

怎么找到这些字符串呢？SAM 只能找出等价类啊。

注意 parent tree 的父亲节点的长度 +1 即该等价类中长度最短的字符串，那么若我们先通过拓扑排序求出每个等价类在原串中出现次次数 $ siz[u] $，该等价类的所有字符串都出现了 $ siz[u] $ 次，那么就变为了一个序列操作题：
1. 区间加 $ 1 $
2. 查询前缀和
而所有 $ 2 $ 操作都在 $ 1 $ 操作之后，我们可以用 $ O(n) $ 的差分优秀地解决这个问题。

贴代码：
```cpp
#include<cstring>
#include<cstdio>
const int M=1e5+5;
int T,n,k,tot=1,lst=1,sum[M],id[M<<1],CB[M<<1],siz[M<<1];char s[M];
struct Node{
    int chi[26];
    int f,len;
    Node():f(0),len(0){memset(chi,0,104);}
}SAM[M<<1];
inline void Insert(const int&s){
    int q,p,nq,np;
    p=lst;np=lst=++tot;
	SAM[np].len=SAM[p].len+1;siz[np]=1;
    for(;p&&!SAM[p].chi[s];p=SAM[p].f)SAM[p].chi[s]=np;
    if(!p)SAM[np].f=1;
    else{
        q=SAM[p].chi[s];
        if(SAM[q].len==SAM[p].len+1)SAM[np].f=q;
        else{
            SAM[nq=++tot]=SAM[q];
            SAM[np].f=SAM[q].f=nq;
            SAM[nq].len=SAM[p].len+1;
            for(;p&&SAM[p].chi[s]==q;p=SAM[p].f)SAM[p].chi[s]=nq;
        }
    }
}
inline int Solve(){
    register int i,u,ans=n+1;
    for(i=1;i<=tot;++i)++CB[SAM[i].len];
    for(i=1;i<=tot;++i)CB[i]+=CB[i-1];
    for(i=1;i<=tot;++i)id[CB[SAM[i].len]--]=i;
    for(i=tot;i>=1;--i){
        u=id[i];
        siz[SAM[u].f]+=siz[u];
        if(siz[u]==k)++sum[SAM[u].len],--sum[SAM[SAM[u].f].len];
    }
    for(i=n;i>=1;--i){
    	sum[i]+=sum[i+1];
    	if(sum[i]>sum[ans])ans=i;
	}
	ans=sum[ans]?ans:-1;
    while(tot)id[tot]=CB[tot]=siz[tot]=0,SAM[tot--]=Node();
    for(i=1;i<=n;++i)sum[i]=0;
    tot=lst=1;
    return ans;
}
signed main(){
    register int i;
    scanf("%d",&T);
    while(T--){
        scanf("%s%d",s,&k);n=strlen(s);
        for(i=0;i<n;++i)Insert(s[i]-97),s[i]=0;
        printf("%d\n",Solve());
    }
}
```

---

## 作者：Rainy_chen (赞：2)

## 题目大意
给出一个字符串，求一个 $l$ 满足对于所有出现次数为 $k$ 的子串，长度为 $l$ 的子串是其中最多且最长的。

## 吐槽
怎么出了三道板子啊。。。

## 题解
统计子串信息所以考虑建一颗 SAM 出来。  

建完以后把每个点的 $siz$ 再求一求。  

然后可以发现实际上一个节点的 $siz$ 就是说对于某一坨子串，它们的出现次数都是 $siz$，而这一坨子串恰好是长度为 $(len_{link_i}, len_i]$ 的几个子串。  

开一个数组来统计有多少个长度为 $i$ 的子串，姑且叫它 $cnt$。

那么一个 $siz=k$ 的节点会让 $[len_{link_i}+1,len_i]$ 这一段的 $cnt_i$ 加一，可以发现这么搞好像还需要写个树状数组啥的去维护这玩意，但是实际上我们只在所有操作结束后需要统计数据，所以差分一下就完事了。  

求答案只需要找出一个最大的 $cnt_i$ 并且满足 $i$ 也是最大的就可以了，如果所有 $cnt_i$ 都是 $0$ 那么答案就是 $-1$。

然后稍微搞一点细节，卡一卡常数，就过了。  

如果 $T$ 小一点或者干脆不出多组数据就是一道不卡常的 SAM 模板好题了（）
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int int_t;

namespace SAM {
    int_t ch[200010][26], link[200010], len[200010], siz[200010], cntt[200010], mxl, last, cnt;
    vector<int_t> son[200010];

    void insert(int_t w){
        if(cnt == 0) link[cnt++] = -1, siz[0] = 0;
        int_t rt = cnt++, tx = last;
        len[rt] = len[last] + 1;
        siz[rt] = 1;
        while(~tx && !ch[tx][w]) ch[tx][w] = rt, tx = link[tx];
        if(~tx) {
            int_t ty = ch[tx][w];
            if(len[tx] + 1 == len[ty]) link[rt] = ty;
            else {
                int_t cloned = cnt++;
                memcpy(ch[cloned], ch[ty], sizeof ch[ty]);
                len[cloned] = len[tx] + 1;
                link[cloned] = link[ty];
                siz[cloned] = 0;
                while(~tx && ch[tx][w] == ty) ch[tx][w] = cloned, tx = link[tx];
                link[rt] = link[ty] = cloned;
            }
        } else link[rt] = 0;
        last = rt;
    }

    void dfs(int_t rt, int_t k) {
        for(int_t to : son[rt]) dfs(to, k), siz[rt] += siz[to];
        if(rt && siz[rt] == k) cntt[len[rt]] ++, cntt[len[link[rt]]] --;
        mxl = max(mxl, len[rt]);
    }

    void init() {
        memset(ch, 0, sizeof ch);
        for(int_t i=0;i<cnt;i++) son[i].clear();
        last = cnt = mxl = 0;
    }

    int_t calcAns(int_t k) {
        for(int_t i=1;i<cnt;i++) son[link[i]].push_back(i);
        dfs(0, k);
        int_t ans = -1, p = 0, ans2 = 0;
        for(int_t i=mxl;~i;i--) {
            p += cntt[i]; cntt[i] = 0;
            if(p > ans2) ans = i, ans2 = p;
        }
        return ans;
    }
}

char tmp[1000100];

int main() {
    int_t T; scanf("%d", &T);
    while(T--) {
        int_t k; scanf("%s%d", tmp, &k);
        int_t len = strlen(tmp);
        SAM::init();
        for(int_t i=0;i<len;i++) SAM::insert(tmp[i] - 'a');
        cout << SAM::calcAns(k) << "\n";
    }
}
```

---

## 作者：MikukuOvO (赞：0)

我们考虑按照$suffix$的$rank$来考虑，我们用一个长度为$k$的窗口来滑动，窗口中的每一个点都是可能的子串的起点，我们考虑满足要求的子串长度的上下界。

不难发现上界就是$min_{l+1}^r(h[i])$,那么下界该如何考虑？

其实我们只要给出约束条件即可，考虑长度小于等于$max(h[l],h[r+1])$的出现次数都$>k$，这样我们就确定了下界。

对于答案统计，我们实际上就是统计$n$个线段覆盖次数最多的点，离线差分即可。

```cpp
const int N=2e5+5;

int T,n,m,p,k;
int sa[N],oldrk[N],rk[N],cnt[N],id[N],px[N];
int num[N],q[N],h[N];
char s[N];

bool cmp(int x,int y,int w)
{
    return oldrk[x]==oldrk[y]&&oldrk[x+w]==oldrk[y+w];
}
void SA()
{
	ms(cnt),ms(rk),ms(oldrk);
    n=strlen(s+1),m=131;
    for(int i=1;i<=n;++i) ++cnt[rk[i]=s[i]];
    for(int i=1;i<=m;++i) cnt[i]+=cnt[i-1];
    for(int i=n;i>=1;--i) sa[cnt[rk[i]]--]=i;
    for(int w=1;w<n;w<<=1,m=p)
    {
        p=0;
        for(int i=n;i>n-w;--i) id[++p]=i;
        for(int i=1;i<=n;++i) if(sa[i]>w) id[++p]=sa[i]-w;
        ms(cnt);
        for(int i=1;i<=n;++i) ++cnt[px[i]=rk[id[i]]];
        for(int i=1;i<=m;++i) cnt[i]+=cnt[i-1];
        for(int i=n;i>=1;--i) sa[cnt[px[i]]--]=id[i];
        memcpy(oldrk,rk,sizeof(rk)),p=0;
        for(int i=1;i<=n;++i) rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p;
    }
	for(int i=1,j=0;i<=n;++i)
	{
		if(j) --j;
		while(s[i+j]==s[sa[rk[i]-1]+j]) ++j;
		h[rk[i]]=j;
	}
	h[n+1]=0;
}
int main()
{
	fio();
	gi(T);
	while(T--)
	{
		scanf("%s",s+1),gi(k);
		SA(),ms(num);
		int hd=1,tl=0;
		for(int i=2;i<=k;++i)
		{
			while(hd<=tl&&h[q[tl]]>=h[i]) --tl;
			q[++tl]=i;
		}
		for(int i=k;i<=n;++i)
		{
			if(i-q[hd]+1>=k) ++hd;
			while(hd<=tl&&h[q[tl]]>=h[i]) --tl;
			q[++tl]=i;
			int t=(k==1)?n-sa[i]+1:h[q[hd]];
			int g=max(h[i-k+1],h[i+1]);
			if(g<=t) ++num[g+1],--num[t+1];
		}
		int pos=-1,maxx=1;
		for(int i=1;i<=n;++i)
		{
			num[i]+=num[i-1];
			if(num[i]>=maxx) maxx=num[i],pos=i;
		}
		print(pos),pc(10);
	}
	end();
}
```

---

## 作者：ThomasX (赞：0)

**搬运官方题解。**

------------

题意为找出仅出现$k$次的子串集合$x_k$，然后统计出现次数最多的子串长度。

由 _IOI2009 国家集训队论文 后缀数组 罗穗骞 后缀数组 处理字符串的有力 工具的论文中 2.2.2子串的个数_ ，可以知道，$k=1$的情况仅出现$1$次的子串个数为 $\sum n - sa[i] + 1 - height[i]$ 


考虑更普遍的情况可得 $min\{height[i+1],height[i+2],\cdots,height[i+k-1]\}-max\{height[i],height[i+k+1]\}$ 即以$sa[i]$为开头的子串，仅出现$k$次的子串长度的上界是$sa[i]$到$sa[i+k-1]$的最长公共前缀长度；下界为与这$k$个串相邻的串和这$k$个串的最长公共前缀$+1$。

因而问题就转化为已知$n$个区间，求覆盖最多次点的最大值为多少，使用一种数据结构维护即可。

------------

std
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;

int wa[100005],wb[100005],wf[100005],wv[100005],ranking[100005],sa[100005],height[100005],s[100005],q[100005],now[100005],sum1[100005],sum2[100005],length;
char str[100005];

int lowbit(int number)
{
    return number & (-number);
}

void add(int position, int value)
{
    while (position <= length)
    {
        sum2[position] += value;
        position += lowbit(position);
    }
}

int getsum(int position)
{
    int answer = 0;
    while (position)
    {
        answer += sum2[position];
        position -= lowbit(position);
    }
    return answer;
}

int cmp(int *r, int a, int b, int l)
{
    return r[a] == r[b] && r[a + l] == r[b + l];
}

void multi(int *r, int *sa, int n, int m)
{
    int *t,i,j,p;
    int *x = wa;
    int *y = wb;
    for (i = 0; i < m; i++)
    {
        wf[i] = 0;
    }
    for (i = 0; i < n; i++)
    {
        wf[x[i] = r[i]]++;
    }
    for (i = 1; i < m; i++)
    {
        wf[i] += wf[i - 1];
    }
    for (i = n - 1; i >= 0; i--)
    {
        sa[--wf[x[i]]] = i;
    }
    for (p = 1, i = 1; p < n; i *= 2, m = p)
    {
        for (p = 0, j = n - i; j < n; j++)
        {
            y[p++] = j;
        }
        for (j = 0; j < n; j++)
        {
            if (sa[j] >= i)
            {
                y[p++] = sa[j] - i;
            }
        }
        for (j = 0; j < n; j++)
        {
            wv[j] = x[y[j]];
        }
        for (j = 0; j < m; j++)
        {
            wf[j] = 0;
        }
        for (j = 0; j < n; j++)
        {
            wf[wv[j]]++;
        }
        for (j = 1; j < m; j++)
        {
            wf[j] += wf[j - 1];
        }
        for (j = n - 1; j >= 0; j--)
        {
            sa[--wf[wv[j]]] = y[j];
        }
        for (t = x, x = y, y = t, p = 1, x[sa[0]] = 0, j = 1; j < n; j++)
        {
            x[sa[j]] = cmp(y,sa[j - 1],sa[j],i) ? p - 1 : p++;
        }
    }
}

void getheight(int *r, int n)
{
    int j,k;
    k = 0;
    for (int i = 0; i < n; i++)
    {
        ranking[sa[i]] = i;
    }
    for (int i = 0; i < n - 1; i++)
    {
        if (k)
        {
            k--;
        }
        j = sa[ranking[i] - 1];
        while (r[i + k] == r[j + k])
        {
            k++;
        }
        height[ranking[i]] = k;
    }
}


int main()
{
    freopen("substring.in", "r", stdin);
    freopen("substring.out", "w", stdout);    
    int t,k,l,r,status,maxi,maxi2,maxi3,maxl;
    scanf("%d",&t);
    while (t--)
    {
        r = status = maxi = maxi2 = 0;
        l = 1;
        memset(sum2,0,sizeof(sum2));
        scanf("%s%d",&str,&k);
        length = strlen(str);
        for (int i = 0; i < length; i++)
        {
            s[i] = str[i] - 'a' + 1;
        }
        s[length] = 0;
        multi(s,sa,length + 1,30);
        getheight(s,length + 1);
        memset(q,0,sizeof(q));
        memset(now,0,sizeof(now));
        for (int i = 1; i < length; i++)
        {
            height[i] = height[i + 1];
        }
        if (k == 1)
        {
            height[length] = 0;
            for (int i = 1; i <= length; i++)
            {
                now[i] = length - sa[i];
                now[i] -= max(height[i - 1],height[i]);
                add(length - sa[i] + 1 - now[i],1);
                add(length - sa[i] + 1,-1);
            }
        }
        else
        {
			for (int i = 1; i < length; i++)
			{
				while(l <= r && q[l] <= i - k + 1) 
				{
					l++;
				}
				while(l <= r && height[i] < height[q[r]]) 
				{
					r--;
				}
				q[++r] = i;
				now[i] = height[q[l]];
			}
			now[k - 2] = 0;
			for (int i = k - 1; i < length; i++)
			{
				if (status)
				{
					if (now[i] > now[i - 1])
					{
						maxi = now[i];
						maxi2 = now[i - 1];
						status = 0;
					}
				}
				else
				{
					if (now[i] >= now[i - 1])
					{
						maxi2 = maxi;
						maxi = now[i];
					}
					else
					{
						status = 1;
						maxi2 = max(maxi2,now[i]);
						add(maxi2 + 1,1);
						add(maxi + 1,-1);
					}
				}
			}
			if (!status)
			{
				add(maxi2 + 1,1);
				add(maxi + 1,-1);
			}
		}
		maxi3 = 0;
		for (int i = 1; i <= length; i++)
		{
			if (maxi3 <= getsum(i))
			{
				maxi3 = getsum(i);
				maxl = i;
			}
		}
		if(maxi3==0) maxl=-1;
		printf("%d\n",maxl);
	}
    return 0;
}

```


---

## 作者：__Ezio__ (赞：0)

~~今年TJOI肿么肥事啊？已经四道大水题惹。。。~~

直接跑出sam来，顺便维护$right$集合大小，对于那些$right$大小为$k$的节点在数组$[mx[fail[x]]+1,mx[x]]$区间加1，可以用差分实现。然后扫一遍就行了。

提示：多测不清空，爆零两行泪

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
const int maxn=200000+3;

inline int getint(){
	bool flag=0;
	register int n=0;
	register char ch=getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-')flag=1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		n=ch-'0'+(n<<3)+(n<<1);
		ch=getchar();
	}
	return flag?(-n):n;
}


int T;
int n;
int k;
char s[maxn];
int dt[maxn];

struct SAM{
	int tot;
	int last;
	int root;
	int c[maxn];
	int p[maxn];
	int mx[maxn];
	int fail[maxn];
	int size[maxn];
	int nxt[maxn][26];
	inline void Init(){
		memset(c,0,(tot+2)<<2);
		memset(p,0,(tot+2)<<2);
		memset(mx,0,(tot+2)<<2);
		memset(dt,0,(tot+2)<<2);
		memset(fail,0,(tot+2)<<2);
		memset(size,0,(tot+2)<<2);
		for(int i=1;i<=tot;i++)
			memset(nxt[i],0,26<<2);
		last=tot=root=1;
	}
	inline int RepNode(int p,int x){
		int q=nxt[p][x];
		if(mx[q]==mx[p]+1)return q;
		int nq=++tot;
		mx[nq]=mx[p]+1;
		fail[nq]=fail[q];
		fail[q]=nq;
		memcpy(nxt[nq],nxt[q],26<<2);
		while(p && nxt[p][x]==q){
			nxt[p][x]=nq;
			p=fail[p];
		}
		return nq;
	}
	inline void Extend(int x){
		int p=last;
		int np=++tot;
		last=np;
		size[last]++;
		mx[np]=mx[p]+1;
		while(p && nxt[p][x]==0){
			nxt[p][x]=np;
			p=fail[p];
		}
		if(p==0)fail[np]=root;
		else fail[np]=RepNode(p,x);
	}
	inline void Collect(){
		for(int i=1;i<=tot;i++)c[mx[i]]++;
		for(int i=1;i<=tot;i++)c[i]+=c[i-1];
		for(int i=tot;i>=1;i--)p[c[mx[i]]--]=i;
		for(int i=tot,x;i>=1;i--){
			x=p[i];
			if(size[x]==k && mx[fail[x]]+1<=mx[x])dt[mx[fail[x]]+1]++,dt[mx[x]+1]--;
			size[fail[x]]+=size[x];
		}
	}
};
SAM sam;

int main(){
#ifdef Ezio
	freopen("input","r",stdin);
#endif

	T=getint();
	while(T--){
		sam.Init();
		scanf("%s",s+1);
		n=strlen(s+1);
		k=getint();
		for(int i=1;i<=n;i++)
			sam.Extend(s[i]-'a');
		sam.Collect();
		int Mx=0;
		int ans=-1;
		for(int i=1;i<=n;i++){
			dt[i]+=dt[i-1];
			if(dt[i] && dt[i]>=Mx){
				Mx=dt[i];
				ans=i;
			}
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

---


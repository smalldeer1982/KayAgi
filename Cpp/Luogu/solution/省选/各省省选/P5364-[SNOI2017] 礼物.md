# [SNOI2017] 礼物

## 题目描述

热情好客的**小猴子**请森林中的朋友们吃饭，他的朋友被编号为 $1\sim N$，每个到来的朋友都会带给他一些礼物：**大香蕉**。其中，第一个朋友会带给他 $1$ 个**大香蕉**，之后，每一个朋友到来以后，都会带给他之前所有人带来的礼物个数再加他的编号的 $K$ 次方那么多个。所以，假设 $K=2$，前几位朋友带来的礼物个数分别是：

$1,5,15,37,83,\ldots$

假设 $K=3$，前几位朋友带来的礼物个数分别是：

$1,9,37,111,\ldots$

现在，**小猴子**好奇自己到底能收到第 $N$ 个朋友多少礼物，因此拜托于你了。

已知 $N,K$，请输出第 $N$ 个朋友送的礼物个数对 $10^9+7$ 取模的结果。

## 说明/提示

- $20\%$ 的数据：$N \le 10^6$；
- 另外 $10\%$ 的数据：$K=1$；
- 另外 $20\%$ 的数据：$K=2$；
- 另外 $20\%$ 的数据：$K=3$；
- $100\%$ 的数据：$N \le 10^{18}$，$K \le 10$。

## 样例 #1

### 输入

```
4 2```

### 输出

```
37```

## 样例 #2

### 输入

```
2333333 2```

### 输出

```
514898185```

## 样例 #3

### 输入

```
1234567890000 3```

### 输出

```
891659731```

## 样例 #4

### 输入

```
66666666 10```

### 输出

```
32306309```

# 题解

## 作者：_rqy (赞：28)

@Fading 首先我要告诉您您的做法不是最优...

$O(k+\log n)$！（如果谁有更优的做法的话请告知我...）

首先，容易发现这个东西可以写成矩阵乘法的形式...（如果你没有发现，请看最早那篇题解）...然后可以惊奇的发现，矩阵是上三角矩阵，并且对角线上有一个 $2$ 和 $k+1$ 个 $1$！

因为矩阵是上三角，所以显然其特征值就是主对角线上的元素，所以根据递推通项公式之类的性质，可以发现答案一定是这种形式：

$$c_k2^n+\sum_{i=0}^ka_{k,i}n^i$$

即一个 $2^n$ 的项加上一个 $k$ 次多项式。如果我们知道了 $c_k$ 的值，那么通过预处理 $[1, k+1]$ 项就可以拉格朗日插值得到 $n$ 的值。（拉格朗日插值可以做到 $O(k)$）

众所周知 $c_k2^n$ 的差分仍然是 $c_k2^n$，但是 $k$ 次多项式的差分是 $k-1$ 阶多项式，所以把前 $k+1$ 项进行 $k$ 阶差分（这个可以直接用组合数 $O(k)$ 得到）就可以得到 $c_k$ 的值。

这样的话，复杂度瓶颈还剩下预处理前 $k+1$ 项。而可以发现只需要求出 $1^k\dots (k+1)^k$，而这可以通过欧拉筛只求其中素数的幂，从而做到 $O(\pi(k)\log k+k)=O(k)$。

于是总复杂度就是 $O(k+\log n)$。（$O(\log n)$是计算 $2^n$ ~~和输入n~~）（$n$ 更大也不用高精度，只需要对 $10^9+7$ 取模算插值，$10^9+6$ 取模算 $2$ 的幂即可）

代码

```cpp
// luogu-judger-enable-o2
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstring>

typedef long long LL;

const int K = 15;
const int mod = 1000000007;

LL pow_mod(LL a, LL b) {
  LL ans = 1;
  for (; b; b >>= 1, a = a * a % mod)
    if (b & 1) ans = ans * a % mod;
  return ans;
}

LL pK[K], f[K], inv[K];
int pr[K], cnt;

void Sieve(int k) {
  pK[1] = 1;
  for (int i = 2; i <= k + 1; ++i) {
    if (!pK[i]) pK[pr[cnt++] = i] = pow_mod(i, k);
    for (int j = 0; pr[j] * i <= k + 1; ++j) {
      pK[i * pr[j]] = pK[i] * pK[pr[j]] % mod;
      if (i % pr[j] == 0) break;
    }
  }
}

int main() {
  int k; LL n;
  scanf("%lld%d", &n, &k); --n;

  LL s = 0, tn = n % mod;
  Sieve(k);
  for (int i = 0; i <= k; ++i) {
    if ((f[i] = s + pK[i + 1]) >= mod) f[i] -= mod;
    if ((s += f[i]) >= mod) s -= mod;
  }
  if (n <= k) return printf("%lld\n", f[n]) & 0;

  LL g = -1; inv[1] = 1;
  for (int i = 2; i <= k; ++i) {
    inv[i] = -(mod / i) * inv[mod % i] % mod;
    g = g * -inv[i] % mod;
  }

  LL c = 1, p = 0;
  for (int i = 0; i <= k; ++i) {
    // sum_{i=0}^k (-1)^(k-i) C(k, i) f[i+1]
    LL _t = c * f[i] % mod;
    c = c * inv[i + 1] % mod * (k - i) % mod;
    if ((k - i) & 1) p -= _t;
    else p += _t;
  }

  LL ans = 0, p2 = p, t = 1;
  for (int i = 0; i <= k; ++i) {
    LL _y = (f[i] - p2) * g % mod;
    ans = (ans * (tn - i) + _y * t) % mod;

    t = t * (tn - i) % mod;
    p2 = p2 * 2 % mod;
    g = g * (i - k) % mod * inv[i + 1] % mod;
  }
  ans = (ans + p * pow_mod(2, n % (mod - 1))) % mod;
  printf("%lld\n", (ans + mod) % mod);
}
```

---

## 作者：Holy_Push (赞：17)

这道题是一道~~很简单的~~~~省选~~题

相信这道题的递推式是很好推的

设$f[i]$表示第$i$个数是多少，$s[i]$表示$f$的前缀和，即$s[i]=\sum_{j=1}^if[j]$

则能列出下列递推式

$f[i]=s[i-1]+i^k$

$s[i]=s[i-1]+f[i]=2s[i-1]+i^k$

那我们只要求出$s[n-1]$就能求出$f[n]$的值。

考虑优化这个递推式。这样子基本都是一眼矩乘的吧。但是如何构建这个矩阵呢？

我们发现$(n+1)^k=C_k^0n^k+C_k^1n^{k-1}+……+C_k^kn^0$，然后我们就能构造这样的矩乘：
$\begin{bmatrix} 2&C_k^0&C_k^1&C_k^2 &\cdots&C_k^k\\ 0&C_k^0&C_k^1&C_k^2 &\cdots&C_k^k\\ 0&0&C_{k-1}^0&C_{k-1}^1&\cdots&C_{k-1}^{k-1}\\ 0&0&0&C_{k-2}^0&\cdots&C_{k-2}^{k-2}\\ \vdots&\vdots&\vdots&\vdots&\vdots&\vdots\\ 0&0&0&0&0&C_0^0\\ \end{bmatrix}×\begin{bmatrix} s[i]\\ i^k\\ i^{k-1}\\ i^{k-2}\\ \vdots\\ i^0\\ \end{bmatrix} = \begin{bmatrix} s[i+1]\\ (i+1)^k\\ (i+1)^{k-1}\\ (i+1)^{k-2}\\ \vdots\\ (i+1)^0\\ \end{bmatrix}$

（注：定义$C_0^0=1$）

然后暴力上矩乘即可，时间复杂度$O(k^3log_n)$

（事实上我的程序再$n≤2$的时候可能会出错因为我没有特判，希望大家写的时候把特判加上去$Q\omega Q$）
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int mo=1e9+7;

ll n,k;

struct Matrix
{
	struct tmp
	{
		int a[13];
		int& operator [] (int x)
		{
			return a[x];
		}
	} a[13];
	tmp& operator [] (int x)
	{
		return a[x];
	}
};//我们机房大佬教的一种神奇定义法，可以把结构体直接当二维数组用
Matrix mat,C,e,s,P,Q;

void cheng(Matrix A,Matrix B,Matrix &C)
{
	for (int i=1;i<=k+2;i++)
		for (int j=1;j<=k+2;j++)
			C[i][j]=0;
	for (int i=1;i<=k+2;i++)
		for (int j=1;j<=k+2;j++)
			for (int l=1;l<=k+2;l++)
				C[i][j]=((ll)C[i][j]+(ll)A[i][l]*B[l][j])%mo;
}

ll ksm(int x,int y)
{
	if (!y) return 1;
	ll d=ksm(x,y/2);
	if (y&1) return d*d%mo*x%mo;
	return d*d%mo;
}

int main()
{
	cin>>n>>k;
	C[0][0]=1;
	for (int i=1;i<=k;i++)
	{
		C[i][0]=1;
		for (int j=1;j<=i;j++) C[i][j]=C[i-1][j-1]+C[i-1][j];
	}
	mat[1][1]=2;
	for (int i=2;i<=k+2;i++) mat[1][i]=C[k][i-2];
	for (int i=2;i<=k+2;i++)
		for (int j=i;j<=k+2;j++)
			mat[i][j]=C[k-i+2][j-i];
	ll Pow=n-2;
	for (int i=1;i<=k+2;i++) e[i][i]=1;
	while (Pow)
	{
		if (Pow&1) {P=e;cheng(P,mat,e);}
		P=mat;Q=mat;cheng(P,Q,mat);
		Pow>>=1;
	}
	for (int i=1;i<=k+2;i++) s[i][1]=1;
	cheng(e,s,e);
	cout<<(e[1][1]+ksm(n%mo,k))%mo<<endl;
}
```

---

## 作者：Wuyanru (赞：17)

这道题是一道十分标准的矩阵快速幂题目。

那么我们先来看一下两个矩阵是怎么相乘的。

首先，两个矩阵 $ A $ 与 $ B $ 相乘的必要条件为 $ A $ 的列等于 $ B $ 的行数，相乘的结果矩阵 $ C $ 的行数等于 $ A $ 的行数，$ C $ 的列数等于 $ B $ 的列数。

在做这道题时我们可以先构造一个关于矩阵的结构体，代码如下：
```
struct mat
{
    long long m,n;
    long long a[30][30]; 
    mat operator * (mat& b)  //重构乘法运算符
    {
        mat c;
        memset(c.a,0,sizeof(c.a));
        c.m=m;
        c.n=b.n;
        for(int i=1;i<=m;i++)
            for(int j=1;j<=b.n;j++)
                for(int p=1;p<=n;p++)
                {
                    c.a[i][j]+=(a[i][p]*b.a[p][j])%1000000007;
                    c.a[i][j]%=1000000007;
        }
        return c;
    }
};
```
但是我们会有一个问题：矩阵里面应该放什么变量呢？

首先我们会想到放入第 $ i $ 个人的礼物数量，

其次我们会用到之前所有人的礼物数量之和，因为计算第 $ i $ 个人礼物数量会用到。

我们在计算第 $ i $ 个人的礼物数量需要用到 $ i^{k} $,所以在矩阵中还要有 $ i^{k} $ 。

同时需要计算 $ i^{k} $ 还需要 $ i^{k-1} $ ，而 $ i^{k-1} $ 还需要 $ i^{k-2} $。

所以我们找到了矩阵中需要放入的变量：当前朋友的礼物、$ i^{k} $、$ i^{k-1} \cdots i $、$ 1 $ 。

我构造的矩阵是这样的：

$\begin{vmatrix}
num_{i}  &i^{k}  &i^{k-1}  &\cdots  &i  &1   &S_{i}
\end{vmatrix}$

那么接下来的一步就变成矩阵快速幂了，

那么这种矩阵应该乘一个怎样的矩阵才能变化到下一步呢？

这个矩阵的下一步是这样的：

$\begin{vmatrix}
num_{i+1}  &\left(i+1\right)^{k}  &\left(i+1\right)^{k-1}  &\cdots  &\left(i+1\right)  &1   &S_{i+1}
\end{vmatrix}$

我们来一步一步地看：

$ num_{i+1}=S_{i}+\left(i+1\right)^{k} $,

$ S_{i+1}=S_{i}+num_{i} $

那么 $ \left(i+1\right)^{k} $、$ \left(i+1\right)^{k-1} $ 等又应该如何构造呢？

$ \because $ 二项式定理，所以这个地方应该是一个杨辉三角，我们可以写一个函数来求。

代码如下：

```
long long yh[20][20];
long long yhsj(long long x,long long y)
{
    if(!yh[x][y])
    {
        if(y==1||y==x)
            yh[x][y]=1;
        else
            yh[x][y]=yh[x-1][y-1]+yh[x-1][y];
    }
    return yh[x][y];
}
void nb(mat& a,long long k)
{
    a.m=a.n=k+3;
    memset(a.a,0,sizeof(a.a));
    a.a[k+3][1]=1;
    a.a[k+3][k+3]=2;
    for(int i=1;i<=k+1;i++)
        for(int j=1;j<=i;j++)
             a.a[k+3-j][k+3-i]=yhsj(i,j);
    for(int i=2;i<=k+2;i++)
        a.a[i][1]=a.a[i][k+3]=a.a[i][2];
}
```
其中 $ \operatorname{yhsj} $ 函数用于计算杨辉三角，数组 $ yh $ 用于记忆化搜索杨辉三角的某一项。

接下来就是快速幂的部分了。

实际上这个部分很简单，这要把整数的快速幂稍微修修改可以了。

递归形式：
```
mat mut(mat a,long long t)
{
    if(t==1)
        return a;
    if(t==0)
    {
        mat b;
        b.m=b.n=k+3;
        memset(b.a,0,sizeof(b.a));
        for(int i=1;i<=k+3;i++)
            b.a[i][i]=1;
        return b;
    }
    mat ans;
    ans.m=ans.n=3;
    memset(ans.a,0,sizeof(ans.a));
    ans=mut(a,t/2);
    ans=ans*ans;
    if(t%2==1)
        ans=ans*a;
    return ans;
}
```
$ while $ 循环形式：
```
mat mut(mat a,long long t)
{
    mat ans;
    memset(ans.a,0,sizeof(ans.a));
    ans.m=ans.n=k+3;
    for(int i=1;i<=k+3;i++)
    	ans.a[i][i]=1;
    while(t)
    {
        if(t&1)
        	ans=ans*a;
        a=a*a;
        t=t/2;
    }
    return ans;
}
```
下面给出最终代码：
```
#include<cstring>
#include<cstdio>
using namespace std;
long long yh[20][20];
long long n,k;
struct mat
{
	long long m,n;
	long long a[101][101];
	mat operator * (mat& b)
	{
		mat c;
		memset(c.a,0,sizeof(c.a));
		c.m=m;
		c.n=b.n;
		for(int i=1;i<=m;i++)
			for(int j=1;j<=n;j++)
				for(int p=1;p<=n;p++)
				{
					c.a[i][j]+=(a[i][p]*b.a[p][j])%1000000007;
					c.a[i][j]%=1000000007;
				}
		return c;
	}
	mat operator + (mat& b)
	{
		mat c;
		c.n=b.n;
		c.m=b.m;
		for(int i=1;i<=m;i++)
			for(int j=1;j<=n;j++)
				c.a[i][j]=a[i][j]+b.a[i][j];
		return c;
	}
};
long long yhsj(long long x,long long y)
{
	if(!yh[x][y])
	{
		if(y==1||y==x)
			yh[x][y]=1;
		else
			yh[x][y]=yh[x-1][y-1]+yh[x-1][y];
	}
	return yh[x][y];
}
void nb(mat& a,long long k)
{
	a.m=a.n=k+3;
	memset(a.a,0,sizeof(a.a));
	a.a[k+3][1]=1;
	a.a[k+3][k+3]=2;
	for(int i=1;i<=k+1;i++)
		for(int j=1;j<=i;j++)
			a.a[k+3-j][k+3-i]=yhsj(i,j);
	for(int i=2;i<=k+2;i++)
		a.a[i][1]=a.a[i][k+3]=a.a[i][2];
}
void nbnb(mat& a,long long k)
{
	memset(a.a,0,sizeof(a.a));
	a.m=1;
	a.n=k+3;
	for(int i=1;i<=k+3;i++)
		a.a[1][i]=1;
}
mat mut(mat a,long long t)
{
	if(t==1)
		return a;
	if(t==0)
	{
		mat b;
		b.m=b.n=k+3;
		memset(b.a,0,sizeof(b.a));
		for(int i=1;i<=k+3;i++)
			b.a[i][i]=1;
		return b;
	}
	mat ans;
	ans.m=ans.n=3;
	memset(ans.a,0,sizeof(ans.a));
	ans=mut(a,t/2);
	ans=ans*ans;
	if(t%2==1)
		ans=ans*a;
	return ans;
}
int main()
{
	scanf("%lld%lld",&n,&k);
	mat ans;
	nb(ans,k);
	mat op;
	nbnb(op,k);
	mat num=mut(ans,n-1);
	num=op*num;
	printf("%lld",num.a[1][1]);
	return 0;
}
```
~~不愧是我，最终代码正好打了100行。~~

本人第一次写题解，欢迎各位大佬指出我的错误。

---

## 作者：nkwhale (赞：15)

[好得不得了的阅读体验（cnblogs）](https://www.cnblogs.com/whale-at-cola/p/solution-p5364.html)

提供一个[讨论区有人提出](https://www.luogu.com.cn/discuss/120323)但没细讲的斯特林数做法，复杂度 $O(k^2)$ 且可优化到 $O(k \log k)$。

前置知识：第二类斯特林数的常用性质。

[题目传送门](https://www.luogu.com.cn/problem/P5364)

下文中为了方便设 $m=n-1$。

首先发现题目让我们求 $\sum_{i=1}^m 2^{m-i} \times i^k +n^k$，这个式子的推导别的题解都有写我就不写了。

为方便，考虑求 $\sum_{i=0}^m 2^{m-i} \times i^k$。

可以发现它和常见的第二类斯特林数应用中的求自然数 $k$ 次幂和很像，所以考虑用同样的方法做。

代入第二类斯特林数的性质式子 $i^k = \sum_{j=0}^k{k \brace j}j!{i \choose j}$，推一波式子：

$$
\begin{aligned}
ans
&=\sum_{i=0}^m 2^{m-i} \times i^k \\
&=\sum_{i=0}^m 2^{m-i} \sum_{j=0}^k{k \brace j}j!{i \choose j} \\
&=\sum_{j=0}^k {k \brace j}j! \sum_{i=0}^m 2^{m-i} {i \choose j} \\
&=\sum_{j=0}^k {k \brace j}j! \sum_{i=j}^m 2^{m-i} {i \choose j} \\
\end{aligned}
$$


设 $g(p)=\sum_{i=p}^m 2^{m-i} {i \choose p}$，这个式子怎么求呢？考虑递推搞出下一项：
$$
\begin{aligned}
g(p)
&=\sum_{i=p}^m 2^{m-i} {i \choose p} \\
&=\sum_{i=p+1}^m 2^{m-i} {i \choose p}+2^{m-p}\\
&=\sum_{i=p+1}^m 2^{m-i} \times ({i+1 \choose p+1}-{i \choose p+1})+2^{m-p}\\
&=\sum_{i=p+1}^m 2^{m-i} \times {i+1 \choose p+1}-\sum_{i=p+1}^m 2^{m-i}{i \choose p+1}+2^{m-p}\\
&=\sum_{i=p+2}^{m+1} 2^{m-i+1} {i \choose p+1}-g(p+1) +2^{m-p}\\
&={m+1 \choose p+1}-g(p+1) +2\sum_{i=p+2}^{m} 2^{m-i} {i \choose p+1} +2 \times 2^{m-(p+1)}\\
&={m+1 \choose p+1}-g(p+1) +2\sum_{i=p+1}^{m} 2^{m-i} {i \choose p+1}\\
&={m+1 \choose p+1} +g(p+1)
\end{aligned}
$$
反过来，有 $g(p)=g(p-1)-{m+1 \choose p} =g(p-1)-{n \choose p}$。

于是求出边界 $g(0)=\sum_{i=0}^m 2^{m-i} {i \choose 0}=\sum_{i=0}^m 2^i=2^{m+1}-1=2^n-1$ 然后递推即可求出 $g$。

所以只要枚举 $j$，算出 $\sum_{j=0}^k {k \brace j}j!g(j)$ 即可算出答案。

复杂度 $O(k^2)$，瓶颈在于预处理第二类斯特林数，用 NTT 卷积求一行的第二类斯特林数可优化到 $O(k \log k)$。

主要部分代码（马蜂较诡异，勿喷）：

```cpp
inline ll md(ll x){return x<0?x+mod:x;}
inline ll qpow(ll d,ll z){
	ll res=1ll;
	for(;z;z>>=1ll,d=d*d%mod) if(z&1ll) res=res*d%mod;
	return res;
}

signed main(){
	ll n=read();int k=read();
	inv[0]=inv[1]=stl[1][1]=1ll;
	for(re int i=2;i<=k;++i) inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	for(re int i=2;i<=k;++i) for(re int j=1;j<=i;++j) stl[i][j]=(stl[i-1][j-1]+j*stl[i-1][j])%mod;
	ll f=1ll,g=md(qpow(2ll,n)-1),c=1ll,ans=qpow(n%=mod,k);
	for(re int j=0;j<=k;++j,f=f*j%mod,g=md(g-(c=c*(n-j+1ll)%mod*inv[j]%mod))) ans=(ans+stl[k][j]*f%mod*g)%mod;
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：狸狸养的敏敏 (赞：10)

Upd:因为排版不整齐被退了，所以重新排版一下

今天集训的时候，神仙教练给我们讲了这道题，然后自己课后看着PPT手推了一下式子，然后就~~抄~~做出来了QwQ

首先分析，这一题神仙讲题人告诉我们用倍增做= =

对于第一个样例，（k=2），有

$1=1^2$

$5=1+2^2$

$15=2\times1^2+1\times2^2+3^2$

$37=4\times1^2+2\times2^2+1\times3^2+4^2$

$83=8\times1^2+4\times2^2+2\times3^2+1\times4^2+5^2$

观察每一个平方项前面的系数，有没有发现什么规律？

于是，对于任意的ans，我们有

$$ans=n^k+\sum_{i=1}^{n-1}2^{n-1-i}i^k$$

把里面的$2^{n-1}$提出来，就变成这个样子

$$ans=n^k+2^{n-1}\sum_{i=1}^{n-1}(\frac{1}{2})^ii^k$$

为了式子看起来简洁，好看，我们令R=$\frac{1}{2}$，有

$$ans=n^k+2^{n-1}\sum_{i=1}^{n-1}R^ii^k$$

然后又是为了方便我们分析结论，我们令

$$f(n,k)=\sum_{i=1}^{n}R^ii^k$$

于是有

$$\begin{aligned}f(n+1,k)&=\sum_{i=1}^{n+1}R^ii^k\\ &=\sum_{i=1}^{n}R^ii^k+R^{n+1}(n+1)^k\end{aligned} $$


然后我们再来考虑怎么倍增，首先，倍增一定要考虑$f(2n,k)$与$f(n)$之间的关系,有


$$\begin{aligned}f(2n,k)&=\sum^{2n}_{i=1}R^ii^k\\ &=\sum^n_{i=1}R^ii^k+\sum_{i=n+1}^{2n}R^ii^k\\ &=f(n,k)\ \ +\sum_{i=n+1}^{2n}R^ii^k\\ &=f(n,k)\ \ +\ \sum_{i=1}^{n}R^{n+i}(n+i)^k\end{aligned}$$

根据神奇的二项式定理，可以把$(n+i)^k$拆开

即

$$\begin{aligned}f(2n,k)&=f(n,k)+\sum_{i=1}^{n}R^{n+i}(n+i)^k\\ &=f(n,k)+\sum_{i=1}^{n}R^{n+i}\sum^k_{j=0}(^k_j)n^{k-j}i^j\end{aligned}$$

(这里不懂的请自行百度，我也是百度套公式23333)

随后，我们把第一个$\sum$里的式子化简，并且为了发现规律，我们交换两个$\sum$的顺序,有

$$\begin{aligned}f(2n,k)&=f(n,k)+\sum_{i=1}^{n}R^{n+i}\sum^k_{j=0}(^k_j)n^{k-j}i^j\\ &=f(n,k)+R^n\sum_{i=1}^{n}R^{i}\sum^k_{j=0}(^k_j)n^{k-j}i^j\\ &=f(n,k)+R^n\sum^k_{j=0}(^k_j)n^{k-j}\sum_{i=1}^{n}R^{i}i^j\end{aligned}$$

发现没有，后面的$\sum_{i=1}^nR^ii^j$有没有很眼熟的感觉？没有？那么请看看上文中对$f(n,k)$的定义

---

$$∴f(2n,k)=f(n,k)+R^n\sum_{j=0}^k(^k_j)n^{k-j}f(n,j)$$

于是我们就把$f(n,k)$和$f(2n,k)$扯上了关系，再乱搞一通，就可以A掉这一题了！

代码(代码中的定义与上文的解释不完全相同)
```
#include<bits/stdc++.h>
#define pii pair<int,int>
#define int long long
#define rep(a,b,c) for(register int a=b;a<=c;a++)
using namespace std;
const int Mod=1e9+7;
int read()
{
	int x=0,f=0;
	char ch=0;
	while(!isdigit(ch))f|=(ch=='-'),ch=getchar();
	while(isdigit(ch))(x*=10)+=(ch^48),ch=getchar();
	return f?-x:x;
}
const int R=(Mod+1)>>1;
inline int ksm(int x,int y)//快速幂
{
	int res=1;
	x%=Mod;
	while(y)
	{
		if(y&1)res=res*x%Mod;
		y>>=1,x=x*x%Mod;
	}
	return res;
}
map<pii,int> M;//记忆化
int fac[22],inv[22];//快速求组合数
inline int C(int x,int y)//求组合数公式
{
	return fac[x]*inv[y]%Mod*inv[x-y]%Mod;
}
int f(int n,int k)
{
	if(n==0) return 0;
	if(n==1) return R;
	if(M.count(pii(n,k))) return M[pii(n,k)];//记忆化优化
	if(n&1)
	{
		int res=f(n-1,k);
		res=(res+1LL*ksm(R,n)*ksm(n,k))%Mod;
		return M[pii(n,k)]=res;
	}
	n>>=1;//倍增
	int res=f(n,k),cur=0;//倍增加速
	rep(j,0,k)
		cur=(cur+1LL*C(k,j)*ksm(n,k-j)%Mod*f(n,j))%Mod;
	res=(res+1LL*cur*ksm(R,n))%Mod;
	return M[pii(n<<1,k)]=res;
}

inline void Init()//预处理
{
	fac[0]=1;
	rep(i,1,20) fac[i]=1LL*fac[i-1]*i%Mod;
	inv[1]=1;
	rep(i,2,20) inv[i]=1LL*(Mod-Mod/i)*inv[Mod%i]%Mod;
	inv[0]=1;
	rep(i,1,20) inv[i]=1LL*inv[i]*inv[i-1]%Mod;
}
signed main()
{
	int n,k;
	Init();
	n=read(),k=read();
	int ans=(ksm(n,k)+1LL*ksm(2,n-1)*f(n-1,k))%Mod;
	printf("%lld\n",ans);
	return 0;//QwQ就这样子啦
}
```

$\LaTeX$真好用233333


---

## 作者：Fading (赞：9)

全世界都是矩阵快速幂。。。

我根本就没往这个地方想，结果还想出来了，而且碾了标算。。。

其实$k$可以加强到$5\times 10^3,$（rqy加强到了$2\times10^7$...）


直接递推不就结束了吗？为什么要矩阵。。。

设数列为$c$,$\text{sum}_i=\sum_{i=1}^nc_i$

$$\therefore \text{sum}_i=2\text{sum}_{i-1}+i^k$$

$$\frac {\text{sum}_i}{2^i}=\frac {\text{sum}_{i-1}}{2^{i-1}}+\frac {i^k}{2^i}$$

设

$$a_i=\frac {\text{sum}_i}{2^i}$$

$$\therefore a_i=a_{i-1}+\frac {i^k}{2^i}$$

$$a_i=\sum_{j=1}^i\frac {j^k}{2^j}$$

设

$$F_i=\sum_{j=1}^n\frac {j^i}{2^j}$$

$$F_i-\frac 12F_i=\sum_{j=1}^n\frac {j^i}{2^j}\ -\sum_{j=1}^n\frac {j^{i}}{2^{j+1}}$$

$$F_i-\frac 12F_i=\sum_{j=0}^{n-1}\frac {(j+1)^i}{2^{j+1}}\ -\sum_{j=1}^n\frac {j^{i}}{2^{j+1}}$$

$$\frac 12F_i=\frac 12+\sum_{j=1}^{n-1}\frac {(j+1)^i-j^i}{2^{j+1}}\ -\frac{n^i}{2^{n+1}}$$

由二项式定理

$$\frac 12F_i=\frac 12+\sum_{j=1}^{n-1}\frac{\sum_{d=1}^{i}C_i^{d}j^{i-d}}{2^{j+1}}\ -\frac{n^i}{2^{n+1}}$$

$$\frac 12F_i=\frac 12+\sum_{d=1}^{i}C_i^{d}\sum_{j=1}^{n-1}\frac {j^{i-d}}{2^{j+1}}\ -\frac{n^i}{2^{n+1}}$$

$$F_i=1+\sum_{d=1}^{i}C_i^{d}\sum_{j=1}^{n-1}\frac {j^{i-d}}{2^{j}}\ -\frac{n^i}{2^{n}}$$

$$F_i=1+\sum_{d=1}^{i}C_i^{d}(F_{i-d}-\frac {n^{i-d}}{2^{n}})\ -\frac{n^i}{2^{n}}$$

$O(k^2\log_2n)$或者$O(k^2)$递推就好了，初始条件

$$F_0=\sum_{j=1}^n\frac 1{2^j}={1-(\frac 12)^n}$$

代码如下：

$O(k^2\log_2n)$

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ljc 1000000007
using namespace std; 
inline ll read(){
    ll x=0,f=1;char ch=getchar();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-48;ch=getchar();}
    return x*f;
}
inline ll fast_pow(ll a,ll b,ll p){
    ll t=1;a%=p;
    while (b){
        if (b&1) t=t*a%p;
        b>>=1;a=a*a%p;
    }
    return t;
}
ll n,k,F[12],C[12][12];
signed main(){
	n=read(),k=read();
	C[0][0]=1;
	ll inv2=fast_pow(2,ljc-2,ljc);
	for (int i=1;i<=k;i++){
		C[i][0]=1;
		for (int j=1;j<=k;j++){
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%ljc;
		}
	}
	F[0]=(1-fast_pow(inv2,n,ljc)+ljc)%ljc;
	for (int i=1;i<=k;i++){
		F[i]=(1-fast_pow(n,i,ljc)*fast_pow(inv2,n,ljc)%ljc+ljc)%ljc;
		for (int d=1;d<=i;d++){
			F[i]=(F[i]+C[i][d]*(F[i-d]-fast_pow(n,i-d,ljc)*fast_pow(inv2,n,ljc)%ljc+ljc)%ljc)%ljc;
		}
	}
	ll An=fast_pow(2,n,ljc)*(F[k])%ljc;
	F[0]=(1-fast_pow(inv2,n-1,ljc)+ljc)%ljc;
	for (int i=1;i<=k;i++){
		F[i]=(1-fast_pow(n-1,i,ljc)*fast_pow(inv2,n-1,ljc)%ljc+ljc)%ljc;
		for (int d=1;d<=i;d++){
			F[i]=(F[i]+C[i][d]*(F[i-d]-fast_pow(n-1,i-d,ljc)*fast_pow(inv2,n-1,ljc)%ljc+ljc)%ljc)%ljc;
		}
	}
	ll An1=fast_pow(2,n-1,ljc)*(F[k])%ljc;
	printf("%lld",(An-An1+ljc)%ljc);
	return 0;
}
```

$O(k^2)$

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ljc 1000000007
using namespace std; 
inline ll read(){
    ll x=0,f=1;char ch=getchar();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-48;ch=getchar();}
    return x*f;
}
inline ll fast_pow(ll a,ll b,ll p){
    ll t=1;a%=p;
    while (b){
        if (b&1) t=t*a%p;
        b>>=1;a=a*a%p;
    }
    return t;
}
ll n,k,F[12],C[12][12],N[13];
signed main(){
	n=read(),k=read();
	C[0][0]=1;
	ll inv2=fast_pow(2,ljc-2,ljc);
	ll inv2n=fast_pow(inv2,n,ljc),inv2n1=fast_pow(inv2,n-1,ljc);
	for (int i=1;i<=k;i++){
		C[i][0]=1;
		for (int j=1;j<=k;j++){
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%ljc;
		}
	}
	F[0]=(1-fast_pow(inv2,n,ljc)+ljc)%ljc;
	N[0]=1;
	for (int i=1;i<=k;i++) N[i]=N[i-1]*(n%ljc)%ljc;
	for (int i=1;i<=k;i++){
		F[i]=(1-fast_pow(n,i,ljc)*fast_pow(inv2,n,ljc)%ljc+ljc)%ljc;
		for (int d=1;d<=i;d++){
			F[i]=(F[i]+C[i][d]*(F[i-d]-N[i-d]*inv2n%ljc+ljc)%ljc)%ljc;
		}
	}
	ll An=fast_pow(2,n,ljc)*(F[k])%ljc;
	F[0]=(1-fast_pow(inv2,n-1,ljc)+ljc)%ljc;
	for (int i=1;i<=k;i++) N[i]=N[i-1]*((n-1+ljc)%ljc)%ljc;
	for (int i=1;i<=k;i++){
		F[i]=(1-fast_pow(n-1,i,ljc)*fast_pow(inv2,n-1,ljc)%ljc+ljc)%ljc;
		for (int d=1;d<=i;d++){
			F[i]=(F[i]+C[i][d]*(F[i-d]-N[i-d]*inv2n1%ljc+ljc)%ljc)%ljc;
		}
	}
	ll An1=fast_pow(2,n-1,ljc)*(F[k])%ljc;
	printf("%lld",(An-An1+ljc)%ljc);
	return 0;
}
```

---

## 作者：Dr_Gilbert (赞：7)

# P5364 [SNOI2017]礼物

【题目大意】

数列 $\{a\}$ 满足
$$
a_i=
\begin{cases}
1 & i=1\\
a_i+s_{i-1}+i^K&\text{otherwise}
\end{cases}
$$
其中，$s_i$ 是 $\{a\}$ 的前 $i$ 项和，$K$ 是给定常数，求 $\{a\}$ 的第 $N$ 项。

答案对 $10^9+7$ 取模，$N\le10^{18},K\le10$。

---

注意到数据范围中 $N\le10^{18}$，可以猜测本题可能是使用矩阵乘法优化数列的递推。但观察递推式可以发现，本题的递推和项数有关，不是一个线性递推。然而数据范围摆在这，如果不是矩阵优化递推的话，那么并不是很好做，所以继续观察递推的性质。

可以注意到 $K\le10$，所以不妨把 $i^0,i^1,\ldots,i^K$ 连同 $s_i,a_i$ 一起放进矩阵里，再通过一些数学方法使得递推变成线性递推。实际上，从第 $i$ 项递推到第 $i+1$ 项时，有
$$
a_{i+1}=a_i+s_i+(i+1)^K
$$
最后一项可以让我们联想到一个组合数学的定理，二项式定理。即对于一个多项式 $(ax+by)^n$，它 $x^p y^q$ 项的系数为 $C_n^pa^pb^q$。在此不再展开说明，有疑问可以参考 [P1313](https://www.luogu.com.cn/problem/P1313)。这样的话，$(i+1)^K$ 就可以通过二项式定理，将递推时各项的系数都求出来放进转移矩阵里，这样就可以实现线性递推。这就是本题的主要思路。

即使有了主要思路，但在实现时可能遇到一个问题，那就是 $a_i$ 和 $s_i$ 不能同时转移，也就不能直接按定义式递推。那么不妨改变一下 $s_i$ 的定义，把它改为 $\{a\}$ 的前 $i-1$ 项和，这样在计算 $a_i$ 时，计算 $s_{i-1}$ （前 $i-2$ 项和）加上 $a_{i-1}$ 再加上项数平方即可。将 $s_i$ 定义改变后，就能避免 $s_i$ 和 $a_i$ 不同时更新从而导致无法计算的问题。同样的原因，在矩阵中记录 $(i+1)^K$，方便 $a_i$ 的转移。如果不太好理解可以手动模拟一下。这样，我们就有了初始矩阵
$$
\begin{bmatrix}
0&0&1&1&\cdots&1
\end{bmatrix}
$$
然后通过生成转移矩阵，对转移矩阵进行快速幂即可得到答案。附上主程序代码如下

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
struct matrix{
	int a[20][20],h,w;
	int* operator [](int i){
		return a[i];
	}
	matrix(int hei, int wid){
		memset(a,0,sizeof(a));
		h=hei;w=wid;
	}
};
matrix operator *(matrix a, matrix b){
	matrix ret(a.h,b.w);
	for (int i=0;i<=ret.h;i++){
		for (int j=0;j<=ret.w;j++){
			for (int k=0;k<=a.w;k++){
				(ret[i][j]+=a[i][k]*b[k][j])%=mod;
			}
		} 
	}
	return ret;
}
matrix m_qpow(matrix a, int k){
	matrix ret=a;k--;
	while (k){
		if (k%2) ret=ret*a;
		a=a*a;k/=2;
	}
	return ret;
} 
// 这里的转移矩阵写了一个生成器
int zy[15][15]={
{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,1,1,0,0,0,0,0,0,0,0,0,0,0},
{0,1,1,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,1,1,1,1,1,1,1,1,1,1,1},
{0,0,0,0,1,2,3,4,5,6,7,8,9,10},
{0,0,0,0,0,1,3,6,10,15,21,28,36,45},
{0,0,0,0,0,0,1,4,10,20,35,56,84,120},
{0,0,0,0,0,0,0,1,5,15,35,70,126,210},
{0,0,0,0,0,0,0,0,1,6,21,56,126,252},
{0,0,0,0,0,0,0,0,0,1,7,28,84,210},
{0,0,0,0,0,0,0,0,0,0,1,8,36,120},
{0,0,0,0,0,0,0,0,0,0,0,1,9,45},
{0,0,0,0,0,0,0,0,0,0,0,0,1,10},
{0,0,0,0,0,0,0,0,0,0,0,0,0,1}};
signed main(){
	int n,k;cin>>n>>k;
	matrix tmp(13,13);
	for (int i=0;i<=13;i++){
		for (int j=0;j<=13;j++){
			tmp[i][j]=zy[i][j];
		}
	}
	tmp[k+3][2]=1;
	matrix ans(1,13);
	ans[1][1]=ans[1][2]=0;
	for (int i=3;i<=13;i++) ans[1][i]=1;
	ans=ans*m_qpow(tmp,n);
	cout<<ans[1][2];
	return 0;
}
```

生成转移矩阵的生成器如下

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int frac[11],inv[11];
int qpow(int a, int k){
	if (k==1) return a;
	if (k==0) return 1;
	int ret=qpow(a,k/2);
	if (k%2) (ret*=ret*a%mod)%=mod;
	else (ret*=ret)%=mod;
	return ret;
}
int C(int n, int m){
	int tmp=inv[m]*inv[n-m]%mod;
	int ans=frac[n]*tmp%mod;
	return ans;
} // 事实上，本题数据范围很小，不需要逆元
int a[20][20];
signed main(){
	a[1][1]=1;a[2][1]=1;frac[0]=1;
	a[2][2]=1;a[1][2]=1;a[3][3]=1;
	for (int i=1;i<=10;i++){
		frac[i]=frac[i-1]*i%mod; 
	}
	for (int i=0;i<=10;i++){
		inv[i]=qpow(frac[i],mod-2);
	} 
	for (int i=4;i<=13;i++){
		int n=i-3;
		for (int j=0;j<=n;j++){
			int tmp=C(n,j);
			a[j+3][i]=tmp; 
		}
	}
	cout<<"int zy[15][15]={";
	for (int i=0;i<=13;i++){
		if (i>0) cout<<",";
		cout<<"\n{";
		for (int j=0;j<=13;j++){
			if (j>0) cout<<",";
			cout<<a[i][j];
		}
		cout<<"}";
	}
	cout<<"};";
	return 0;
}
```



---

## 作者：smarthehe (赞：6)

直接开门见山。

关注$N$范围高达$10^{18}$，又类似数学递推，考虑矩阵快速幂求解。

所以怎么求？

我们关注$N$的每个取值的结果的数学表示。

$N=1$时，$ans=1*1^K$

$N=2$时，$ans=1*1^K+1*2^K$

$N=3$时，$ans=2*1^K+1*2^K+1*3^K$

$N=4$时，$ans=4*1^K+2*2^K+1*3^K+1*4^K$

……

虽然有规律，可以写出通项，但矩阵递推的方法不明显。

考虑前缀和。

$N=1$时，$sum=1*1^K$

$N=2$时，$sum=2*1^K+1*2^K$

$N=3$时，$sum=4*1^K+2*2^K+1*3^K$

$N=4$时，$sum=8*1^K+4*2^K+2*3^K+1*4^K$

提出系数：

	1
	2 1
	4 2 1
	8 4 2 1
	……

可以发现递推的数学式：

$sum[N]=2sum[N-1]+N^K$

正确性可证明，此处不加赘述。

找出递推式之后，我们思考如何转化为矩阵。

发现$2sum[N-1]$较为好解决，难点在$(N-1)^K$转移到$N^K$。

先转换为$N^K$转移到$(N+1)^K$

二项式定理展开$(N+1)^K$。

有

$$
(N+1)^K = \tbinom{K}{0} N^K+ \tbinom{K}{1} N^{K-1}+ \tbinom{K}{2} N^{K-2}+...+ \tbinom{K}{K} N^0
$$

考虑存储当前$N$从$0$到$K$次方的值，然后在转移时根据$sum[N]=2sum[N-1]+N^K$导入$N^K$

同时利用提前存储好的杨辉三角进行次方的转移。

举出$K=3$时的转移矩阵：

	1 1 1 1 0
    0 1 2 3 0
    0 0 1 3 0
    0 0 0 1 1
    0 0 0 0 2
    
每次相乘时，左侧矩阵

$[N^0,N^1,N^2,N^3,sum[N-1]]$

相乘结果

$[N^0,N^0+N^1,N^0+2N^1+N^2,N^0+3N^1+3N^2+N^3,2sum[N-1]+N^3]$

得

$[(N+1)^0,(N+1)^1,(N+1)^2,(N+1)^3,sum[N]]$

递推得到完美解决。

矩阵快速幂即可。

---

## 作者：黑影洞人 (赞：5)

题意简化

求数列 $f(x)=\sum_{i=1}^{x-1}f(i)+x^k$ 的第 $n$ 项。

化简柿子得 $f(x)=2 \times f(x-1)+x^k-(x-1)^k$

观察题目发现，$n$ 的范围限制了 $O(n^2)$ 模拟和 $O(n)$ 线性递推的做法。

考虑矩阵乘法。

我们设状态矩阵为：

$\begin{bmatrix} 
	f_x 
\\  x^k
\\  x^{k-1}
\\  x^{k-2}
\\  ...
\\  x^2
\\  x
\\  1
\end{bmatrix}\quad$

目标状态是：

$\begin{bmatrix} 
	f_{x+1} 
\\  (x+1)^k
\\  (x+1)^{k-1}
\\  (x+1)^{k-2}
\\  ...
\\  (x+1)^2
\\  x+1
\\  1
\end{bmatrix}\quad$

考虑转移

我们发现

$x^k$ 转移到 $(x+1)^k$ 是关键一步，要用到二项式系数。

于是我们通过杨辉三角预处理出所有要用到的二项式系数。

```cpp
yh[0][0]=1;
for(int i=0;i<k+1;i++){
	yh[i][0]=1;
	for(int j=1;j<=i;j++)yh[i][j]=(yh[i-1][j-1]+yh[i-1][j])%md;
}
```
注意：$yh[i][j] = C_{i}^j$

最后我们通过推导得出了状态转移矩阵：

$\begin{bmatrix} 
	2 & 0 & C_k^{k-1} & ... & C_k^0
\\	0 & C_k^k & C_k^{k-1} & ... & C_k^0
\\  0 & 0 & C_{k-1}^{k-1} & ... & C_{k-1}^0
 \\  ...& ...&...&...&...
 \\	0&0&0&...&1
\end{bmatrix}\quad$

这里给出关键构造矩阵的代码，方便各位读者调试：

```cpp
m[1][1]=2;
for(int i=2;i<=k+2;i++)m[1][i]=yh[k][i-2];
for(int i=1;i<=k;i++){
	for(int j=i;j<=k+1;j++)m[i+1][j+1]=yh[k-i+1][k-j+1];	
}
m[1][2]=0;
m[k+2][k+2]=1;
```
完结撒花

管理员同志审核题解辛苦了


---

## 作者：pitiless0514 (赞：3)

我们如果设立 $s_n$ 表示前 $n$ 个人送的礼物总数，且 $s_1 = 1$ ，因为第 $i$ 个人的送的礼物个数为 $s_{i-1} +i ^k$ 那么很快可以写出像下面一样的式子：

$$ s_i=2\times s_{i-1} + i^k$$

我们发现，在上述式子中 $s_i $ 与 $s_{i-1}$ 如果想要进行矩阵乘法的话，是很容易的，但关键在于 $i^k$ 的递推。我们是要从 $i^k$ 推到 $(i+1)^k$ 。

那么我们又想到了二项式定理：

$$(i+1)^k=\sum_{j=0}^k\binom{k}{j}x^j$$

那么我们就可以用这个来推出式子，保存下二项式系数的值，求法可以使用杨辉三角，然后在做两次矩阵快速幂，答案即为 $s_n-s_{n-1}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int  M = 20;
int mod = 1e9+7;
int m;
struct Martix{
	int a[M][M];
	Martix(){memset(a,0,sizeof(a));}
	Martix operator *(const Martix &b){
		Martix res;
		for(int i=1;i<=m;i++){
			for(int j=1;j<=m;j++){
				for(int k=1;k<=m;k++){
					res.a[i][j]= (res.a[i][j]+a[i][k]*b.a[k][j])%mod;
				}
			}
		}
		return res;
	}
};
Martix ans,b,e;
Martix power(int n,Martix ans,Martix bit){
	while(n){
		if(n&1){
			ans=(ans*bit);
		}
		bit=(bit*bit);
		n>>=1;
	}
	return ans;
}
int n,kt;
signed main(){
	cin>>n>>kt;
	m=kt+2;
	for(int i=1;i<=m;i++) ans.a[1][i]=1;
	for(int j=2;j<=m;j++){
		b.a[2][j]=b.a[j][j]=1;
		for(int i=3;i<j;i++){
			b.a[i][j]=(b.a[i][j-1]+b.a[i-1][j-1])%mod;
		}
	}
	b.a[1][1]=2;
	for(int i=2;i<=m;i++) b.a[i][1]=b.a[i][m];
	Martix s1=power(n-1,ans,b);
	int ans1=0;
	for(int i=1;i<=m;i++) ans1=(ans1+s1.a[i][1])%mod;
	Martix s2=power(n-2,ans,b);
	int ans2=0;
	for(int i=1;i<=m;i++) ans2=(ans2+s2.a[i][1])%mod;
	cout<<((ans1-ans2)%mod+mod)%mod;
    return 0;
}
````

---

## 作者：Illusory_dimes (赞：2)

**（注：本题解废话有点多，因为我只是想讲得能让我这种小菜鸡都能明白，所以大佬可以跳过，因为上面有许多更简洁的题解）**

### 题目描述
给定整数 $n$ 和 $k$ ，已知每个人都会给教练上贡之前所有人带来的个数再加他编号的 $k$ 次方个礼物，求第 $n$ 个人要给教练多少礼物。

$n\leq 10^{18}\ \ \ k\leq 10$

### solution
设答案为 $ans_n$ ，**稍微打打表**，就会很快写出20分的递推式了。

那干脆直接从20分的递推式开始走。（应该没人不会20分吧。。）

$$ans_n=2\cdot ans_{n-1}+n^k$$

但这并不好看，主要是因为那个系数2，所以：

$$\frac{ans_n}{2^n}=\frac{2\cdot ans_{n-1}}{2^i}+\frac{n^k}{2^n}$$

系数一消，漂漂亮亮地换个元：

$$num_n=num_{n-1}+\frac{n^k}{2^n}$$

$$\Rightarrow num_n=\sum_{i=1}^{n}\frac{i^k}{2^i}$$

但一看 $n$ 的范围，算了，更换一下 $num$ 的下标：

$$\Rightarrow num_k=\sum_{i=1}^{n}\frac{i^k}{2^i}$$

如果想求和循环换下来成递推式，又看到 $i$ 上是一个固定的高次幂（虽然最高就10），就能用二次项定理，从 $i$ 整到 $i+1$ 。

$$\Rightarrow num_k=\sum_{i=0}^{n-1}\frac{(i+1)^k}{2^{i+1}}$$

$$\Rightarrow num_k=\frac{1}{2}+\sum_{i=1}^{n-1}\frac{(i+1)^k}{2^{i+1}}$$

$$\Rightarrow num_k=\frac{1}{2}+\sum_{i=1}^{n-1}\frac{\sum_{j=0}^{k}C_k^j\cdot i^j}{2^{i+1}}$$

$$\Rightarrow num_k=\frac{1}{2}+\sum_{j=0}^{k}C_k^j\sum_{i=1}^{n-1}\frac{i^j}{2^{i+1}}$$

$$\Rightarrow num_k=\frac{1}{2}+\sum_{j=0}^{k}C_k^j(\frac{num_j}{2}-\frac{n^j}{2^{n+1}})$$

扩大两倍，然后可以消去一个 $num_k$ 。

$$\Rightarrow 2\cdot num_k=1+\sum_{j=0}^{k}C_k^j(num_j-\frac{n^j}{2^n})$$

$$\Rightarrow num_k=1-\frac{n^k}{2^n}+\sum_{j=0}^{k-1}C_k^j(num_j-\frac{n^j}{2^n})$$

此时就能递推啦（注：按原定义预处理 $num_0$ ）

时间复杂度 $O(k^2\log_2 n)$ （注：那一个数组存一下那些次幂就能 $O(k^2+\log_2 n)$ 了）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=1e9+7;
ll n,k,m,ans,c[12][12];
ll inv2,in,in_1,g[12],f[12];
inline ll ksm(ll a,ll b){
	ll tmp=1;
	while(b){
		if(b&1)tmp=tmp*a%mod;
		a=a*a%mod;b>>=1;
	}
	return tmp;
}
int main()
{
	cin>>n>>k;m=n%mod;
	c[0][0]=1;inv2=ksm(2,mod-2);
	in_1=ksm(inv2,n-1),in=in_1*inv2%mod;
	f[0]=(mod+1-in)%mod;g[0]=1;
	for(int i=1;i<=k;++i){
		c[i][0]=1;
		for(int j=1;j<=k;++j)
		c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
		
		g[i]=(g[i-1]*m)%mod;
		f[i]=(mod+1-in*g[i]%mod)%mod;
		for(int j=1;j<=i;++j)
		f[i]=(f[i]+c[i][j]*(mod+f[i-j]-g[i-j]*in%mod)%mod)%mod;
	}
	ans=ksm(2,n)*f[k]%mod;
	f[0]=(mod+1-in_1)%mod;m=(n-1)%mod;
	for(int i=1;i<=k;++i)g[i]=(g[i-1]*m)%mod;
	for(int i=1;i<=k;++i){
		f[i]=(mod+1-in_1*g[i]%mod)%mod;
		for(int j=1;j<=i;++j)
		f[i]=(f[i]+c[i][j]*(mod+f[i-j]-g[i-j]*in_1%mod)%mod)%mod;
	}
	ans=(mod+ans-ksm(2,n-1)*f[k]%mod)%mod;
	printf("%lld",ans);
	return 0;
}
```
只求能帮助到几个人罢。。

---

## 作者：VenusM1nT (赞：2)

矩阵快速幂。

法老：这题倍增；我：？？？

菜到不会倍增，窝觉得矩阵快速幂是可以做的，而法老的做法十分巧妙并不会emm

首先考虑递推式，令 $f_i$ 表示第 $i$ 个人的礼物数，$a_i$ 表示 $i^k$，易得柿子：

$$f_i=2\times f_{i-1}+a_i$$

那么这个东西怎么矩阵快速幂呢？有二项式定理如下：

$$(n+1)^k=\sum_{i=0}^{k}\binom{k}{i}n^{k-i}$$

所以我们可以构造一个三角矩阵，直接快速幂就行了。

```cpp
#include<bits/stdc++.h>
#define MAXN 1000005
#define reg register
#define inl inline
#define ll long long
using namespace std;
const int Mod=1e9+7;
ll n;
int K,C[15][15];
inl int Add(reg int x,reg int y)
{
	return x+y>Mod?x+y-Mod:x+y;
}
inl int Del(reg int x,reg int y)
{
	return x-y<0?x-y+Mod:x-y;
}
inl int Mul(reg int x,reg int y)
{
	return 1ll*x*y%Mod;
}
struct Matrix
{
	int a[15][15];
	inl void Init()
	{
		memset(a,0,sizeof(a));
	}
	friend Matrix operator * (const Matrix &x,const Matrix &y)
	{
		reg Matrix cnt;
		cnt.Init();
		for(reg int i=0;i<K+3;i++)
		{
			for(reg int j=0;j<K+3;j++)
			{
				for(reg int k=0;k<K+3;k++) cnt.a[i][j]=Add(cnt.a[i][j],Mul(x.a[i][k],y.a[k][j]));
			}
		}
		return cnt;
	}
}T,ans;
inl void Pow(reg ll x)
{
	ans=T;
	x--;
	for(;x;x>>=1,T=T*T) if(x&1) ans=ans*T;
}
int main()
{
	scanf("%lld %d",&n,&K);
	C[0][0]=1;
	for(reg int i=1;i<=K;i++)
	{
		C[i][0]=1;
		for(reg int j=1;j<=i;j++) C[i][j]=Add(C[i-1][j-1],C[i-1][j]);
	}
	for(reg int i=0;i<=K;i++)
	{
		for(reg int j=0;j<=i;j++) T.a[i][j]=C[i][j];
	}
	for(reg int i=0;i<=K;i++) T.a[K+1][i]=T.a[K+2][i]=C[K][i];
	T.a[K+1][K+2]=1;
	T.a[K+2][K+2]=2;
	Pow(n);
	printf("%d\n",ans.a[K+1][0]);
	return 0;
}
```

---

## 作者：sun123zxy (赞：2)

### 2020/02/11 upd

有几个式子写错了修了一下

（好像题解界面的式子会挂，如果遇到了请在 [这里](https://www.cnblogs.com/sun123zxy/p/luogu5364.html) 或者 [在Ta的博客查看](https://www.luogu.com.cn/blog/sun123zxy/solution-p5364) ）

---

### 暴搞通项公式

蒟蒻想了一上午弄出来个$O(k^2)$的算法

这道题比较裸，就是甩给你个递推式让你求第$n$项
$$
A_1 = 1,A_n = \sum_{i=1}^{n-1} A_i + n^k
$$

那首先我们来手动打个表qwq

| $A_i$ \ $i^k$ | $1^k$ | $2^k$ | $3^k$ | $4^k$ | $5^k$ | $6^k$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $A_1$ | 1 |  |  |  |  |  | |
| $A_2$ | 1 | 1 |  |  |  |  | |
| $A_3$ | 2 | 1 | 1 |  |  |  | |
| $A_4$ | 4 | 2 | 1 | 1 |  |  | |
| $A_5$ | 8 | 4 | 2 | 1 | 1 |  | |
| $A_6$ | 16 | 8 | 4 | 2 | 1 | 1 | |

表中第$i$行的系数乘上对应列标后的和就是$A_i$

于是我们发现了这一显然的规律

$$
A_1 = 1,A_n = 2 A_{n-1} + n^k - (n-1)^k
$$

我们就非常优秀的把这个递推式化简了:p

~~然而这并没有什么卵用~~

不过看到这个式子，就总感觉它有个通项公式什么的吧，我们来胡乱瞎推一波

观察递推式，右式那坨$n^k - (n-1)^k$看着就恶心，我们想找个办法把它消掉，使它的形式变成一个等比数列，这样通项公式就容易得到了

显然$n^k - (n-1)^k$是一个$k-1$次多项式，所以我们构造数列$U$和$k-1$次多项式$B$

$$
\begin{aligned}
U_n = A_n + B(n) \\
B(n) = \sum_{i=0}^{k-1} b_i n^i
\end{aligned}
$$

对数列$U$的定义式移项得

$$
A_n = U_n - B(n)
$$

带回$A$的递推式，得
$$
\begin{aligned}
U_n - B(n) = 2(U_{n-1} - B(n-1)) + n^k - (n-1)^k \\
U_n = 2U_{n-1} + B(n) - 2B(n-1) + n^k - (n-1)^k
\end{aligned}
$$

我们想让$U_n=2U_{n-1}$，只需使

$$
B(n) - 2B(n-1) + n^k - (n-1)^k = 0
$$

即
$$
- B(n) + 2B(n-1) = n^k - (n-1)^k
$$

现在我们要求解多项式$B$，试着将多项式的每一项，也就是$b_i$，都表示出来

先看右式，用二项式定理展开$(n-1)^k$，右式变为

$$
\quad  n^k - \sum_{i=0}^{k} C_k^i (-1)^{k-i} n^i
$$

提出和式中的$k$次项与$n^k$消掉

$$
= - \sum_{i=0}^{k-1} C_k^i (-1)^{k-i} n^i
$$

再来看左式，将多项式展开得

$$
- \sum_{i=0}^{k-1} b_i n^i + 2 \sum_{i=0}^{k-1} b_i (n-1)^i
$$

也用二项式定理展开$(n-1)^i$

$$
= - \sum_{i=0}^{k-1} b_i n^i + 2 \sum_{i=0}^{k-1} b_i \sum_{j=0}^i C_i^j (-1)^{i-j} n^j
$$

转换枚举

$$
\begin{aligned}
&= - \sum_{i=0}^{k-1} b_i n^i + 2 \sum_{i=0}^{k-1} \sum_{j=0}^i  b_iC_i^j (-1)^{i-j} n^j \\
&= - \sum_{i=0}^{k-1} b_i n^i + 2 \sum_{j=0}^{k-1} \sum_{i=j}^{k-1}  b_iC_i^j (-1)^{i-j} n^j \\
&= - \sum_{i=0}^{k-1} b_i n^i + 2 \sum_{i=0}^{k-1} \{ \sum_{j=i}^{k-1}  b_j C_j^i (-1)^{j-i} \} n^i
\end{aligned}
$$

（这里大括号只是为了标明系数，没有实际意义）

现在把左右式合在一起写

$$
- \sum_{i=0}^{k-1} b_i n^i + 2 \sum_{i=0}^{k-1} \{ \sum_{j=i}^{k-1}  b_j C_j^i (-1)^{j-i} \} n^i = - \sum_{i=0}^{k-1} C_k^i (-1)^{k-i} n^i
$$

消掉负号

$$
\sum_{i=0}^{k-1} b_i n^i + 2 \sum_{i=0}^{k-1} \{ \sum_{j=i}^{k-1}  b_j C_j^i (-1)^{j-i} \} n^i = \sum_{i=0}^{k-1} C_k^i (-1)^{k-i} n^i
$$

所以

$$
b_i + 2 \sum_{j=i}^{k-1}  b_j C_j^i (-1)^{j-i} = C_k^i (-1)^{k-i}
$$

于是我们非常~~愉快~~艰难的得到了$b_i$的表示，高斯消元即可得到$b_i$。

仔细观察发现这是个上三角矩阵，所以我们可以直接$O(k^2)$求解！

于是我们解出了多项式$B$。

回过头来看数列$U$的定义，$U_n = A_n + B(n)$

现在解出了$B$，我们又知道$A_1 = 1$，就能知道

$$
U_1 = A_1 + B(1) = B(1) +1
$$

于是我们得到了数列$U$的完整递推式

$$
U_1=B(1) + 1,U_n=2U_{n-1}
$$

现在就容易知道$U$的通项公式了，它是

$$
U_n = ( B(1) + 1 )2^{n-1}
$$

又因为$A_n = U_n - B(n)$，$A$的通项公式就出来了！

$$
A_n = ( B(1) + 1 )2^{n-1} - B(n)
$$

完了

```cpp
//洛谷P5364 [SNOI2017]礼物
//Author:sun123zxy
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<ctime>
#include<cstdlib>
#include<queue>
using namespace std;
typedef long long ll;
const ll MOD=1E9+7;

ll QPow(ll x,ll up){//快速幂 
    x%=MOD;
    ll ans=1;
    while(up){
        if(up%2==0){
            x=x*x%MOD;
            up/=2;
        }else{
            ans=ans*x%MOD;
            up--;
        }
    }
    return ans;
}
ll Inv(ll x){//逆元 
    return QPow(x,MOD-2);
}

const ll MXK=2005;
ll fac[MXK],facInv[MXK];
void FacInit(ll n){
	fac[0]=1;for(ll i=1;i<=n;i++) fac[i]=fac[i-1]*i%MOD;//求阶乘 
	facInv[n]=Inv(fac[n]);
	for(ll i=n-1;i>=1;i--) facInv[i]=facInv[i+1]*(i+1)%MOD;//线性求阶乘逆元 
	facInv[0]=1;
}
ll C(ll n,ll k){//组合数 
	if(n<k) return 0;
	return fac[n]*facInv[n-k]%MOD*facInv[k]%MOD;
}

ll N,K;
ll c,B[MXK];//2^(n-1)的系数c和多项式B 
ll GetY(ll x){//获取B(x)
	x%=MOD;
	ll y=0;
	ll xPow=1;
	for(int i=0;i<=K-1;i++){
		y=(y+B[i]*xPow)%MOD;
		xPow=xPow*x%MOD;
	}
	return y;
}
ll mtx[MXK][MXK];
void GetFormula(){
	for(ll i=0;i<=K-1;i++) for(ll j=0;j<=K;j++) mtx[i][j]=0;
	for(ll i=0;i<=K-1;i++){//初始化方程组 
    	mtx[i][i]=1;
    	for(ll j=i;j<=K-1;j++){
    		ll p=-1;if((j-i)%2==0) p=1;
    		mtx[i][j]+=(-2*C(j,i)%MOD*p+MOD)%MOD;
		}
		ll p=-1;if((K-i)%2==0) p=1;
		mtx[i][K]=(C(K,i)*p+MOD)%MOD;
	}
	for(ll i=K-1;i>=0;i--){//上三角高斯消元
		B[i]=mtx[i][K]*Inv(mtx[i][i])%MOD;
		for(ll j=i-1;j>=0;j--){
			mtx[j][K]=(mtx[j][K]-B[i]*mtx[j][i]%MOD+MOD)%MOD;
			mtx[j][i]=0;
		}
	}
	c=(GetY(1)+1)+MOD%MOD;
}
int main(){
    cin>>N>>K;
    FacInit(K);
    GetFormula();
    cout<<(c*QPow(2,N-1)%MOD-GetY(N)+MOD)%MOD;
    return 0;
}
```

和洛谷题解里[rqy聚聚的解法](https://www.luogu.com.cn/blog/rqy/solution-p5364)似乎有一些关联（

---

## 作者：Soulist (赞：2)

首先第一个人的时候的答案为$1$

可以考虑设$f_i$表示第$i$个人的礼物，那么有：

$$f_i=\sum_{j=1}^{i-1}f_j+i^k$$

可以考虑对于询问的$n$某一个$i^k$被计算了多少次

$f_i$中被计算了一次，$f_{i+1}$中是一次，$f_{i+2}$中则是二次，$f_{i+3}$中是$4$次，往后是$8$次，$16$次...

于是可以发现对于一个$i^k< n$它会被计算：

$$2^{n-i-1}$$

次

于是我们可以得到答案就是：

$$n^{k}+\sum_{i=1}^{n-1}i^k*2^{n-1-k}$$

设$x=n-1$

那么答案就是：

$$n^k+\sum_{i=1}^{x}i^k*2^{x-i}$$

~~这是一个卷积（雾~~

仔细思考后会发现一个令人倍感优美的性质

上面这个式子居然是可以通过矩阵递推的

设

$$ h(x)=\sum_{i=1}^xi^k*2^{x-i}$$

$$h(x)=h(x-1)*2+x^k$$

貌似对于每个$x$这个东西是独立的啊喂...

然而有趣的是$x^k$可以由$x^{k-1}$递推得到，假设$k=t$，那么就需要一个大小为$t$的矩阵递推得到

如何递推？

二项式定理暴力展开即可，复杂度$O(k^3\log n)$

---

## 作者：Prean (赞：1)

考虑计算每个猴子对答案的贡献。

打个表：
```
1 1 2 4 8 16 32 ...
```
可以看出第 $ i $ 个猴子对答案的贡献是 $ i^k \times 2^{n-i-1} $，特别地，最后一只猴子对答案的贡献是 $ n^k $。

写成柿子：
$$ n^k+\sum_{i=1}^{n-1}i^k \times 2^{n-i-1} $$
$$ n^k+2^{n-1} \times (\sum_{i=1}^{n-1}i^k \times (2^{-1})^i) $$
我们只需要计算出 $ \sum_{i=1}^{n-1}i^k \times (2^{-1})^i $ 即可。

然后我们发现这个柿子是 CODECHEF qpolysum，然后就做完了。

~~还是把做法写一遍吧~~

qpolysum 和本题有不同之处，即 $ i $ 从 $ 0 $ 开始，记得减掉。~~不过要减掉的是一个0，所以相当于没减~~
$$ S(n)=\sum_{i=0}^{n-1}i^k \times m^i $$
在本题中相当于 $ m=2^{-1} $。

不过这个做法是猜了一个很奇怪的结论，并且做法来自校OJ讨论区（

我们猜 $ S(n)=m^n G(n) - G(0) $，其中 $ G(x) $ 是一个不超过 $ k $ 次的多项式。

证明可以看[这个blog](https://blog.csdn.net/qq_35649707/article/details/79595192) ~~我才不告诉你是我看不懂~~

然后差分一下：
$$ S(n)-S(n-1)=m^n G(n) - m^{n-1} G(n-1) = (n-1)^k \times m^{n-1} $$
$$ G(n) = \frac {(n-1)^k + G(n-1)} m $$
设 $ G(0)=x $，那么我们在 $ n $ 为任何值的时候用 $ x $ 表示 $ G(n) $。

因为这个多项式的次数最高为 $ k $，而对一个 $ k $ 次多项式差分 $ k+1 $ 次后为 $ 0 $，所以我们把 $ G(x) $ 差分 $ k+1 $ 次后得到：
$$ \sum_{i=0}^{k+1} (-1)^{i+1} \binom {k+1} i G(k+1-i) = 0 $$
我们可以用 $ x $ 表示 $ G(0) \sim G(k+1) $，然后解一个一元一次方程即可得到 $ x $，带入可得到 $ G(1) \sim G(k+1) $ 的值。

现在我们可以使用拉格朗日插值计算 $ G(n) $ 了，答案就是 $ m^nG(n)-G(0) $。

$ i^k $ 可以使用线性筛，所以复杂度是 $ O(k+\log n) $。

code:
```cpp
#include<cstdio>
const int M=15,mod=1e9+7;
int k,n1,n2,top,x[M],y[M],idk[M],pri[M],pos[M],fac[M],ifac[M];long long n;
int q[M],p[M],G[M];
inline int Add(const int&a,const int&b){
	return a+b>=mod?a+b-mod:a+b;
}
inline int Del(const int&a,const int&b){
	return b>a?a-b+mod:a-b;
}
inline int C(const int&n,const int&m){
	return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;
}
inline int pow(int a,int b){
	int ans=1;
	for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;
	return ans;
}
inline void sieve(const int&M){
	register int i,j,x;idk[1]=1;
	for(i=2;i<=M;++i){
		if(!pos[i])pri[++top]=i,pos[i]=top,idk[i]=pow(i,k);
		for(j=1;j<=top&&(x=i*pri[j])<=M;++j){
			idk[x]=1ll*idk[i]*idk[pri[j]]%mod;
			if((pos[x]=j)==pos[i])break;
		}
	}
}
inline int Inter(const int&n){
	register int i,tmp,ans=0;
	q[0]=p[k+2]=1;
	for(i=1;i<=k+1;++i)q[i]=1ll*q[i-1]*Del(n,i)%mod;
	for(i=k+1;i>=1;--i)p[i]=1ll*p[i+1]*Del(n,i)%mod;
	for(i=1;i<=k+1;++i){
		if(k+1-i&1)ans=Del(ans,1ll*1ll*q[i-1]*p[i+1]%mod*G[i]%mod*ifac[i-1]%mod*ifac[k+1-i]%mod);
		else ans=Add(ans,1ll*1ll*q[i-1]*p[i+1]%mod*G[i]%mod*ifac[i-1]%mod*ifac[k+1-i]%mod);
	}
	return ans;
}
signed main(){
	register int i,X=0,Y=0;
	fac[0]=fac[1]=ifac[0]=ifac[1]=1;
	scanf("%lld%d",&n,&k);sieve(k+1);x[0]=1;y[0]=0;n1=n%mod;n2=n%(mod-1);
	for(i=1;i<=k+1;++i)x[i]=Add(x[i-1],x[i-1]),y[i]=Add(y[i-1],idk[i-1]),y[i]=Add(y[i],y[i]);
	for(i=2;i<=k+1;++i)fac[i]=1ll*fac[i-1]*i%mod,ifac[i]=1ll*(mod-mod/i)*ifac[mod%i]%mod;
	for(i=2;i<=k+1;++i)ifac[i]=1ll*ifac[i-1]*ifac[i]%mod;
	for(i=0;i<=k+1;++i){
		if(i&1){
			X=Add(X,1ll*C(k+1,i)*x[k+1-i]%mod);
			Y=Add(Y,1ll*C(k+1,i)*y[k+1-i]%mod);
		}
		else{
			X=Del(X,1ll*C(k+1,i)*x[k+1-i]%mod);
			Y=Del(Y,1ll*C(k+1,i)*y[k+1-i]%mod);
		}
	}
	G[0]=mod-1ll*Y*pow(X,mod-2)%mod;
	for(i=1;i<=k+1;++i)G[i]=Add(1ll*x[i]*G[0]%mod,y[i]);
	printf("%d",Add(1ll*Del(1ll*pow(500000004,n2)*Inter(n1)%mod,G[0])*pow(2,n2-1)%mod,pow(n1,k)));
}
```

---

## 作者：Albedo (赞：1)

### Description

$ A_n=(\sum_{i=1}^{n-1} A_i)+n^k,A_1=1 $，求出 $ A_n \bmod MOD $ 。

### Solution

我们记 $ B_i=\sum_{i=1}^{n} A_i $​ ,所以 $ A_n=B_{n-1}+n^k $​ , $ B_n=B_{n-1}+An=2\times B_{n-1}+n^k $​ 。

看到这个式子，我们只要求出 $ B_n $ 与 $ B_{n-1} $​ 后再相减就可以了，问题是 $ B_n $ 如何快速求。

首先从 $ k=1 $ 开始
$$
f(i)-2\times f(i-1)=i
$$

$$
f(i-1)-2\times f(i-2)=i-1
$$

两个式子相减可得 $ f(i)-3\times f(i-1)+2\times f(i-2)=1 $

所以 $ f(i)=3\times f(i-1)-2\times f(i-2)+1 $ 

然后实质是 $ i=(i-1)+1 $

然后范围扩大就是要求 $ n^k=x_1\times (n-1)^k+x_2\times (n-2)^k...x_{k} \times (n-k)^k+x_{k+1} $​​

那么有 

$ x_1+x_2+...+x_k=1 $​

$ x_1+2\times x_2+...k\times x_k=0 $​

$ x_1+2^2\times x_2+...+k^2\times x_k=0 $​​ 

$ ... $

$ x_1+2^{k-1} \times x_2+...+k^{k-1} \times x_k=0 $​

$ (-1)^k\times x_1+(-2)^k \times x_2+...+(-k)^k \times x_k+x_{k+1}=0 $​

然后你可以用高斯消元，也可以通过暴力算出前几组解，发现如果是 $ n^k $ ，则 $ x_i=C_{k}^{i}\times (-1)^{i-1} $,我们推出了 $ x_i $ ，就可以知道 $ f(n-1) $ 的系数是 $ 2+x_1 $ ，因为 $ (n-1)^k $ 可以用 $ f(i-1)-2f(i-2) $ 代替，而 $ f(n-i) (i>1) $ 的系数为 $ x_i-2\times x_{i-1} $ ,因为含$ (n-i)^k=f(n-i)-2f(n-i-1) $​​ , $ (n-i+1)^{k}=f(n-i+1)-2f(n-i) $，然后就可以将这两数之和转化成：
$$
x_i\times (n-i)^k+x_{i-1}\times(n-i+1)^k=x_1\times f(n-i)-x_1\times 2\times f(n-i-1)+x_{i-1}\times f(n-i+1)-2\times x_{i-1} \times f(n-i)
$$
所以系数是 $ x_i-2\times x_{i-1} $ ，知道了系数之后，就可以矩阵快速幂加速递推了，构建矩阵就不用说了吧。

### Code

```c++
#include<bits/stdc++.h>
using namespace std;
inline long long read()
{
  long long x=0,f=1;char ch=getchar();
  while(!isdigit(ch)&&ch!='-')ch=getchar();
  if(ch=='-')f=-1,ch=getchar();
  while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
  return x*f;
}
long long pow(long long x,long long y,long long p)
{
	long long ans=1;
	for (;y;y>>=1,x=x*x % p)
		if (y&1) ans=ans*x % p;
	return ans;
}
long long gcd(long long x,long long y)
{
	if (y==0) return x;
	long long ans=gcd(y,x % y);return ans;
}
long long N,x,y,X[101000],A[1010][1010],B[1010][1010],c[1010][1010],C[1010][1010],a[10100],f[10100],n,K,MOD,i,j;
void MulB()
{
	int i,j,k;
	for (i=1;i<=K;i++)
	   for (j=1;j<=K;j++)
	       c[i][j]=0;
	for (k=1;k<=K;k++)
	    for (i=1;i<=K;i++)
	       for (j=1;j<=K;j++)
	           c[i][j]=(c[i][j]+B[i][k]*B[k][j]) % MOD;
	for (i=1;i<=K;i++)
	   for (j=1;j<=K;j++)
	        B[i][j]=c[i][j];
}
void MulA()
{
	int i,j,k;
	for (i=1;i<=K;i++)
	   for (j=1;j<=K;j++)
	       c[i][j]=0;
	for (k=1;k<=K;k++)
	    for (i=1;i<=1;i++)
	       for (j=1;j<=K;j++) 
	            {
	            //	cout<<i<<" "<<j<<" "<<" "<<i<<" "<<k<<" "<<k<<" "<<j<<endl;
	           c[i][j]=(c[i][j]+B[k][j]*A[i][k]) % MOD;
	          }
	for (i=1;i<=1;i++)
	   for (j=1;j<=K;j++)
	        A[i][j]=c[i][j];
}
int main()
{
	//ios::sync_with_stdio(0);cin.tie();cout.tie();
	n=read();K=read();MOD=1e9+7;
	//预处理 
	C[0][0]=1;
	for (i=1;i<=11;i++)
	      {
	      	 C[i][0]=1;C[i][i]=1;
	      	 for (j=1;j<i;j++)
	      	    C[i][j]=C[i-1][j]+C[i-1][j-1];
	      }
	for (i=1;i<=K;i++) if (i % 2==1) X[i]=C[K][i];else X[i]=-C[K][i];
	for (i=1;i<=K;i++) X[K+1]=(X[K+1]+pow(i,K,MOD)*X[i]) % MOD;
	if (K % 2==0) X[K+1]=-X[K+1];
	a[1]=2+X[1];
	for (i=2;i<=K;i++) a[i]=-2*X[i-1]+X[i];
	a[K+1]=-2*X[K];a[K+2]=X[K+1];
//	for (i=1;i<=K+2;i++) cout<<X[i]<<" ";
//	cout<<endl;
	for (i=2;i<=K+2;i++) a[i]=a[i] % MOD;
	//构造矩阵
	f[1]=1;
	for (i=2;i<=K+2;i++) f[i]=(2*f[i-1]+pow(i,K,MOD)) % MOD;
	for (i=1;i<=K+1;i++) A[1][i]=f[K+1-i+1];
	A[1][K+2]=1;
	for (i=1;i<=K+1;i++) B[i][1]=a[i];
	B[K+2][1]=a[K+2];
	for (i=2;i<=K+1;i++) B[i-1][i]=1;
	B[K+2][K+2]=1;
	//矩阵快速幂
	K+=2;
/*2	for (i=1;i<=K;i++)
	     {
	     	for (j=1;j<=K;j++)
	     	   cout<<B[i][j]<<" ";
	     	cout<<endl;
		 }*/
	if (n<=K-1)
	    {
	    	printf("%lld\n",f[n]-f[n-1]);return 0;
		 }
	N=n;
	n--;
	n-=(K-1);
	for (;n;n>>=1,MulB())
	       if (n&1) MulA();
	x=A[1][1] % MOD;/*cout<<x<<endl;*/y=pow(N % MOD,K-2,MOD);
	printf("%lld\n",((x+y) % MOD+MOD) % MOD);
return 0;
}
```


---

## 作者：JustinRochester (赞：1)

总感觉我绕了一大圈弯路......

[传送门](https://www.luogu.com.cn/problem/P5364)

---

**【分析】**
--

设 $f_n$ 表示第 $n$ 个朋友带来的礼物个数，则不难写出：（定义 $f_0=0$ ）

$\displaystyle f_n=\sum_{i=0}^{n-1}f_i+n^k$

记 $g_n=n^k$ 不难写出生成函数：$F(x)={1\over 1-x}\cdot xF(x)+G(x)$

$\therefore 2F(x)={1\over 1-2x}G(x)+G(x)$

记 $H(x)={1\over 1-2x}G(x)$ 则 $2f_n=h_n+g_n$

由于 ${1\over 1-2x}$ 是 $\{2^n\}$ 的生成函数，因此 $\displaystyle h_n=\sum_{i=0}^n g_i2^{n-i}=\sum_{i=0}^n i^k2^{n-i}$

记 $\displaystyle T_{n,k}=\sum_{i=0}^n i^k2^{n-i}$

则 $\displaystyle T_{n,k}=2T_{n,k}-T_{n,k}=\sum_{i=0}^n i^k2^{n+1-i}-\sum_{i=0}^n i^k2^{n-i}=2\sum_{i=0}^{k-1}\dbinom k i T_{n-1,i}-n^k$

由于 $k\leq 10$ 很小，暴力递归求解 $T_{n,k}$ ，边界条件是 $\displaystyle T_{n,0}=\sum_{i=0}^n 2^{n-i}=2^{n+1}-1,T_{0,k}=0(k>0)$

求解之后，即可算出 $f_n=2^{-1}\cdot (h_n+g_n)=2^{-1}\cdot (T_{n,k}+n^k)$

---

**【代码】**
---

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD=1e9+7,inv2=(MOD+1>>1);
ll C[16][16];
inline ll fpow(ll a,ll x) { ll ans=1; for(a%=MOD;x;x>>=1,a=a*a%MOD) if(x&1) ans=ans*a%MOD; return ans; }
inline ll T(ll n,ll k){
    if(n==0) return 0;
    if(k==0) return fpow(2,n+1)-1+MOD;
    ll res=0;
    for(int j=0;j<k;++j) res+=C[k][j]*T(n-1,j)%MOD;
    res=res+res+MOD-fpow(n,k);
    return res%MOD;
}
inline void pre(){
    for(int i=0;i<=10;++i){
        for(int j=i-1;j>=1;--j) C[i][j]=C[i-1][j-1]+C[i-1][j];
        C[i][0]=C[i][i]=1;
    }
}
int main(){
    pre();
    ll n,k;
    cin>>n>>k;
    cout<<inv2*(fpow(n,k)+T(n,k))%MOD;
    return 0;
}
```

---

## 作者：peterwuyihong (赞：0)

班主任坐对面，开不了車，只能写数学题

题意：

$$a_1=1,a_n=S_{n-1}+i^k$$

求 $a_n\bmod (10^9+7)$，$n\le 10^{18},k\le 10$

解它！

$$a_n=S_{n-1}+n^k$$

$$a_{n-1}=S_{n-2}+(n-1)^k$$

相减得到

$$a_n=2a_{n-1}+n^k-(n-1)^k$$

$$\frac{a_n}{2^n}=\frac{a_{n-1}}{2^{n-1}}+\frac{n^k-(n-1)^k}{2^n}$$

令 $b_n=\dfrac{a_n}{2^n}$，那么 

$$b_n=0.5+\sum_{i=2}^n\frac{i^k-(i-1)^k}{2^i}=\sum_{i=1}^n\frac{i^k-(i-1)^k}{2^i}$$

$$=\frac{n^k}{2^n}-\frac{(n-1)^k}{2^{n}}+\frac{(n-1)^k}{2^{n-1}}-\frac{(n-2)^k}{2^{n-1}}$$

$$=\frac{n^k}{2^n}+\sum_{i=1}^{n-1}\frac{i^k}{2^{i+1}}$$

考虑求一个 $G(n)=\sum_{i=1}^{n-1}i^k/2^i$

这是[P4948 数列求和](https://www.luogu.com.cn/problem/P4948)，于是直接套[模板类](https://www.luogu.com.cn/paste/y0f9e3gu)就行了。

```cpp
const int p=1e9+7;
template<class _Tp,class _tp>void add(_Tp&x,const _tp& y){((x+=y)>=p)&&(x-=p);}template<class _Tp,class _tp>_Tp Add(_Tp x,const _tp y){add(x,y);return x;}
template<class _Tp,class _tp>void sub(_Tp&x,const _tp&y){((x-=y)<0)&&(x+=p);}template<class _Tp,class _tp>_Tp Sub(_Tp x,const _tp y){sub(x,y);return x;}
template<class _Tp,class _tp>void mul(_Tp&x,const _tp&y){x=1ll*x*y%p;}template<class _Tp,class _tp>_Tp Mul(const _Tp x,const _tp y){return 1ll*x*y%p;}
template<class _Tp,class _tp>_Tp ksm(_Tp a,_tp b){_Tp ans(1);for(;b;b>>=1,mul(a,a))if(b&1)mul(ans,a);return ans;} 
template<class _Tp>_Tp div2(_Tp a){if(a&1)a+=p;return a>>1;}
using i64 = long long;
int calc(const i64 nn,const int a,const int k){
  assert(a!=1);
  const int n=nn%p,_n=nn%(p-1);
  vector<int>jc(k+6),jcinv(k+6),pri,idk(k+6);
  vector<bool>v(k+6);idk[1]=1;
  jc[0]=1;rep(i,1,k+5)jc[i]=Mul(jc[i-1],i);jcinv[k+5]=ksm(jc[k+5],p-2);
  per(i,k+4,0)jcinv[i]=Mul(jcinv[i+1],i+1);rep(i,2,k+5){
    if(!v[i])pri.push_back(i),idk[i]=ksm(i,k);
    for(int j:pri){
      if(i*j>k+5)break;
      v[i*j]=1;idk[i*j]=Mul(idk[i],idk[j]);
      if(i%j==0)break;
    }
  }
  auto C=[&](int n,int m){return Mul(jc[n],Mul(jcinv[m],jcinv[n-m]));};
  vector<int>lk(k+6),lt(k+6);int uu=ksm(a,p-2);
  lk[0]=1;rep(i,1,k+1){
    lk[i]=Mul(lk[i-1],uu);
    lt[i]=Mul(lt[i-1],uu);
    add(lt[i],idk[i]);
  }
  int rek=0,ret=0;
  rep(i,0,k+1){
    int dk=Mul(C(k+1,i),lk[k+1-i]);
    int dt=Mul(C(k+1,i),lt[k+1-i]);
    if(i&1)sub(rek,dk),sub(ret,dt);
    else add(rek,dk),add(ret,dt);
  }
  vector<int>g(k+6);g[0]=Sub(0,Mul(ret,ksm(rek,p-2)));
  rep(i,1,k+5)g[i]=Add(Mul(g[i-1],uu),idk[i]);
  int CC=0;
  if(n<=k+1)CC=g[n];
  else{
    int GG=1;
    rep(i,1,k+1)mul(GG,n-i);
    rep(i,1,k+1){
      int tmp=Mul(jcinv[i-1],jcinv[k+1-i]);
      mul(tmp,Mul(g[i],ksm(n-i,p-2)));
      if((k+1-i)&1)mul(tmp,Sub(0,GG));
      else mul(tmp,GG);
      add(CC,tmp);
    }
  }
  return Sub(Mul(CC,ksm(a,_n)),g[0]);
}
signed main(){
  i64 n;int k;
  cin>>n>>k;
  int ans=ksm(n%p,k);
  add(ans,Mul(ksm(2,n-1),calc(n-1,(p+1)>>1,k)));
  cout<<ans<<endl;
}
```

---


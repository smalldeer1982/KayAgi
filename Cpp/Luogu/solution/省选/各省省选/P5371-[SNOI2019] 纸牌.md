# [SNOI2019] 纸牌

## 题目描述

有一副纸牌。牌一共有 $n$ 种，分别标有 $1,2,...,n$ ，每种有 $C$ 张。故这副牌总共有 $nC$ 张。

三张连号的牌 $(i,i+1,i+2)$ 或三张相同的牌 $(i,i,i)$ 可以组成一**叠**。如果一组牌可以分成若干（包括零）**叠**，就称其为一组**王牌**。

你从牌堆中摸了一些初始牌。现在你想挑出一些牌组成一组王牌，请问有多少种可能组成的王牌呢？答案对 $998244353$ 取模。

两组牌相同当且仅当它们含有的每一种牌数量都相同。

## 说明/提示

### 样例解释1

所有方案如下：

1. $\{\}$ （不选任何牌）
2. $\{1,1,1\}$
3. $\{2,2,2\}$
4. $\{3,3,3\}$
5. $\{1,2,3\}$
6. $\{1,1,1,2,2,2\}$
7. $\{1,1,1,3,3,3\}$
8. $\{2,2,2,3,3,3\}$
9. $\{1,1,2,2,3,3\}$
10. $\{1,1,1,2,2,2,3,3,3\}$

### 数据范围

对于所有数据， $1\leq n\leq 10^{18},0\leq a_i\leq C\leq 1000,0\leq X\leq 1000$ 。注意 $a_i$ 和 $C$ 可能为 $0$ 。

- 对于 $20\%$ 的数据， $n=9,C=4$ 。
- 对于另外 $15\%$ 的数据， $n\leq 10^5,C=2$ 。
- 对于另外 $15\%$ 的数据， $X\leq 5,C\leq 10$ 。
- 对于另外 $10\%$ 的数据， $X=0$ 。
- 对于另外 $20\%$ 的数据， $n\leq 10^5$ 。
- 对于余下 $20\%$ 的数据，无特殊限制。

## 样例 #1

### 输入

```
3 3
0```

### 输出

```
10```

## 样例 #2

### 输入

```
9 4
9
1 3
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 3```

### 输出

```
3521```

# 题解

## 作者：皎月半洒花 (赞：15)

upd:题解区的 $\LaTeX$ 好像有 `bug`，改完之后如果还是gg请移步 [$Link$](https://www.cnblogs.com/pks-t/p/12165213.html)

_____

$\rm SNOI2019$ 纸牌

首先我觉得出题人肯定打过 `CF Global Round 1` ~~并且很可能在那场掉分了~~，可以[戳这里](https://codeforces.com/problemset/problem/1110/D) 去康一下。

## $\rm Algorithm · 1$

首先定义状态，$f_{i,j,k}$ 表示考虑了前 $i$ 大的，其中 $[i-1,i,i+1]$ 类型有 $j$ 个， $[i,i+1,i+2]$ 类型有 $k$ 个的方案数。发现这两类还是最多只会各有 $2$ 个。

然后就是考虑转移。发现还是要转移到 $[i+1,i+2,i+3]$ 去，那换言之就是枚举 $i+3$ 的个数。但是题目里面有限制 **$k_i$ 至少要拿 $a_i$ 个**，所以考虑这么转移，令 $s=j+k+l$，即顺子里面 $i+1$ 的个数 ：

$$f_{i+1,k,l} = \begin{cases}f_{i,j,k}\cdot (\lfloor \frac{c-s}{3}\rfloor + 1) , s\geq a_{i+1} \\ f_{i,j,k}\cdot (\lfloor \frac{c -(s+3\cdot \lceil \frac{a_{i+1}-s}{3}\rceil )}{3}\rfloor+1) , s< a_{i+1}\end{cases}$$

其中 $+1$ 代表题目中的 “空也算是一种方案”。第二个转移中，由于枚举的顺子个数小于必选的，那么就要把剩下的也选成刻子才行，所以就是 $3\cdot \lceil \frac{a_{i+1}-s}{3}\rceil $ ，即如果不足还要多选点。

写出代码来大概是这样：

```cpp
inline int get_v(int x){
	x %= 3 ; 
	if (x == 2) return 1 ; 
	else if (x == 1) return 2 ; return 0 ; 
}
signed main(){
    cin >> N >> M >> T, dp[0][0][0] = 1 ;
    for (i = 1 ; i <= T ; ++ i) scanf("%lld%lld", &j, &k), Num[j] = k ;
    for (i = 1 ; i <= N ; ++ i)
        for (j = 0 ; j < 3 ; ++ j)
            for (k = 0 ; k < 3 ; ++ k)
                for (l = 0 ; l < 3 ; ++ l){
                    int now = j + k + l, dis ;
					if (M < now) continue ;
					if (Num[i] > now) dis = Num[i] + get_v(Num[i] - now) ; else dis = now ;
      				if (dis <= M) dp[i][k][l] = (dp[i][k][l] + dp[i - 1][j][k] * ((M - dis) / 3 + 1)) % Mod ;
				}
    cout << dp[N][0][0] << endl ; return 0 ;
}
```

可以过 $\rm Subtask~1,2,5$，共计 $55$ 分。

## $\rm Algorithm ·2$

发现这东西转移只跟后两维有关，并且从 $i$ 转移到 $i+1$ 并没有什么障碍，于是考虑矩乘。

发现由于是 $i,j$ 转移到 $j,k$ ，故需要 $9\times 9$ 的矩阵来转移。然后对于每个状态考虑直接按行按列编号，转移就很简单了。

但问题在于要考虑约束，即每一位至少要选多少。这东西特判一下就可了。复杂度 $m\cdot 9^3+9^3\cdot \log n$. 

然而似乎这东西可以一开始倍增出来转移矩阵……$\rm Anyhow$，并不会快多少，毕竟最后压力就在 $m$ 这边了。

```cpp
LL n, m, c, x, y, lx, ly ;
struct matrix{
    int b[12][12] ;
    void clear(){ memset(b, 0, sizeof(b)) ; }
    void reset(){
        clear() ;
        for (int i = 0 ; i < 10 ; ++ i)
            b[i][i] = 1 ;
    }
    matrix friend operator * (const matrix &a, const matrix &b){
        matrix c ; c.clear() ;
        for (int i = 0 ; i < 10 ; ++ i)
            for (int j = 0 ; j < 10 ; ++ j)
                for (int k = 0 ; k < 10 ; ++ k)
                    c.b[i][j] = (c.b[i][j] + 1ll * a.b[i][k] * b.b[k][j] % Mod) % Mod ;
        return c ;
    }
}ans, unit, tmp ;

matrix expow(matrix a, LL b){
    matrix res ; res.reset() ;
    while (b){
        if (b & 1)
            res = res * a ;
        a = a * a ; b >>= 1 ;
    }
    return res ;
}
signed main(){
    cin >> n >> c >> m ; LL q ; //cout << n << endl ;
    ans.b[0][0] = 1 ; int i, j, k, l ;
    for (i = 0 ; i < 3 ; ++ i)
        for (j = 0 ; j < 3 ; ++ j)
            for (k = 0 ; k < 3 ; ++ k)
                if (i + j + k <= c)
                    unit.b[i * 3 + j][j * 3 + k] = (c - (i + j + k)) / 3ll + 1ll ;
    for (i = 1 ; i <= m ; ++ i){
        scanf("%lld%lld", &x, &y), tmp.clear() ;
        ans = ans * expow(unit, x - lx - 1) ;
        for (j = 0 ; j < 3 ; ++ j)
            for (k = 0 ; k < 3 ; ++ k)
                for (l = 0 ; l < 3 ; ++ l){
                    int s = j + k + l ;
                    if (s < y) s = y + ((s - y) % 3 + 3) % 3 ;
                    if (s <= c) tmp.b[j * 3 + k][k * 3 + l] = (c - s) / 3ll + 1ll ;
                }
        lx = x, ly = y, ans = ans * tmp ;
    }
    ans = ans * expow(unit, n - (LL)lx), cout << ans.b[0][0] << endl ; return 0 ;
}
```




---

## 作者：行吟啸九州 (赞：8)

```ZJOI2019```和```SNOI2019```很神奇，出题人不约而同地喜欢打麻将。

感觉花姐姐的题解写得很清楚啦，不过我俩解释思路的方式肯定还是会有所不同的，请不要因为他写得太好而喷我。

算法一：这个题的暴力和麻将有点像，暴力轮廓线```dp```, ```dp[i][j][k]```表示枚举到第i种牌，后两位有j对形同```i - 2, i - 1```的东西，额外还有k个形同```i - 1```的东西的方案数，不难发现j和k有意义的取值只有```0,1,2```,如果```j,k```取值是3以上的，后来必然会出现三个一样的形如```i, i + 1, i + 2```的东西，他们三个就可以理解三个形如```i, i, i```的东西，这个我们可以统计到方案数里，不需要额外再在轮廓线上记录了，所以这个轮廓线dp的复杂度是O(n)的，期望得分```20 + 15 + 20 = 55```。

本来到这个时候我已经不想想了，不过看一眼D2T2，发现完全不会，只能寄希望于这个T1了。

这个题X很小，摸的各种牌之间有很多空挡，再看一眼部分分，有X = 0这一档的，不难想到空挡的解决办法就是X = 0这一档分的办法。

算法二：我们不难发现，对于X = 0的情况，转移方程是相似的。对于相似的运算，我们可以对他进行合并，比如加上一个数,加很多次，我们可以直接乘法，乘一个数，乘好多次，我们可以直接乘方，但是同样的dp转移方式转移好多次，我们很难用一个运算来做，不过我们可以化转移为矩阵运算，用矩阵快速幂来加速。我们可以直接矩阵乘法，矩阵还是很容易构造，手玩即可。复杂度O(```729logn```)，期望得分10分。

融合算法一与算法二，不难得到算法三，对于有摸到的牌的地方直接暴力dp，空挡做矩阵快速幂，复杂度O（```729Xlogn```），期望得分100。

正好这几天有点无聊，看了几眼花姐姐的代码，感觉还挺好写的，也就updaet了一份代码，本来想对有摸到的牌的地方进行暴力dp的，不过为了方便自己调试，还是用矩阵来进行转移了。

```ccp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define mod 998244353
#define For(i, j, n) for(register int i = j ; i <= n ; ++i)
int n, m, x, y, C, lx;

struct materix{
	int a[10][10];
	friend materix operator * (materix x, materix y){
		materix z; memset(z.a, 0, sizeof(z.a));
		For(i, 0, 8) For(j, 0, 8) For(k, 0, 8) z.a[i][j] = (z.a[i][j] + x.a[i][k] * y.a[k][j]) % mod;
		return z;
	}
}b, ans, tmp;
inline materix quickpow(materix x, int y){
	materix sum; memset(sum.a, 0, sizeof(sum.a));//不memset,你会快乐RE的
	For(i, 0, 8) sum.a[i][i] = 1;//构造单位矩阵 
	for( ; y ; x = x * x, y >>= 1) if(y & 1) sum = sum * x;
	return sum;
}

signed main(){
	scanf("%lld %lld %lld", &n, &C, &m), ans.a[0][0] = 1;
	//i代表形如i - 2,i - 1的东西有i张，j代表形如i - 1的东西有j张 ，k摸了k张i ，状态编号为i * 3 + j 
	For(i, 0, 2) For(j, 0, 2) For(k, 0, 2) if(i + j + k <= C) b.a[i * 3 + j][j * 3 + k] = (C - i - j - k) / 3 + 1;
	For(i, 1, m){
		scanf("%lld %lld", &x, &y), memset(tmp.a, 0, sizeof(tmp.a)), ans = ans * quickpow(b, x - lx - 1);
		//构造一个特殊的矩阵数组tmp，进行dp转移，j, k, l与上文含义类似，不再赘述 
		For(j, 0, 2){
			For(k, 0, 2){
				For(l, 0, 2){
					int s = j + k + l;
					if(s < y) s = s + ((y - s - 1) / 3 * 3 + 3);//最少摸y张嘛，s补到s + 3k(s + 3k >= y)			 
					if(s <= C) tmp.a[j * 3 + k][k * 3 + l] = (C - s) / 3 + 1;
				} 
			}
		}
		lx = x, ans = ans * tmp;
	}
	ans = ans * quickpow(b, n - lx), printf("%lld", ans.a[0][0]); //别忘了最后还有一段空挡 
	return 0;
}
```

---

## 作者：myee (赞：4)

### Update

抱歉标题写错了，重新交一下。

同时补充说明一下，关于后面 $B$ 的大小，取 $8$ 是因为这个东西本身就非常跑不满，以及可以用二进制优化常数。

### 前言

感觉这种计数，一看到，就很 dp 套 dp 啊！

就，感觉就是「ZJOI2019」麻将，的高清重制版呐！

### 思路

以下称 $(i,i,i)$ 为刻子，$(i,i+1,i+2)$ 为顺子，合法情形称为胡牌。

首先，一个牌取 $v>6$ 的可行性，与 $v-3$ 相同；也即，与 $(v-4)\bmod3+4$ 相同。

因为，如果其有刻子，可以挖掉；如果没有，则由抽屉原理，有至少 $3$ 个完全相同的顺子结构经过之，可以转化成刻子的情形然后仍然合法。

反过来，从 $v-3$ 合法到 $v$ 合法的推导，可以多加一个刻子。

因此可以理解为，其有 $a_i$ 种取 $i$ 张牌的方案，其中 $i\in\{0,1,2,3,4,5,6\}$。

这样就可以直接建“胡牌自动机”了。

即，我们记录其前面两种顺子分别有多少个（均为 $0\sim2$ 个），经过某种时先除去前面两种顺子的贡献，然后把刻子尽可能多取，剩下的再作为顺子的起点；容易证明，任何一个牌的胡态都可以这么表述，且唯一表述。（感觉这么描述好抽象啊，但是想不出更好的描述了）

这样，每个牌的选法总数可以描述为一个**线性变换**，于是可以用矩阵乘法描述。

然后这样子，对相邻的牌之间的部分上**矩阵快速幂**，就做完了。

发现每个 $i$ 处 DP 的状态是 $3\times3=9$ 种的，所以矩阵都是 $9\times9$ 的，做 $O(X)$ 轮快速幂肯定没问题。

然后注意到 `unsigned long long` 允许我们开下 $9\times998244352\times998244352$ 的大小，因此可以先求和再取模，大大减小了常数。

设 $a=9$，总复杂度即为 $O(a^3X\log n)$。

然后这个还是太逊了，考虑优化。

考虑**倍增预处理** $n$ 以内的矩阵快速幂，然后每次**乘向量**即可。

总复杂度 $O(a^3\log n+a^2X\log n)$，可以轻松通过。

然后就是考虑把普通倍增改为改为**高进制快速幂**，假设是 $B$ 进制，则为 $O((a^3B+{a^2X})\log_Bn)$。

取 $B=\Theta(\frac Xa)$，复杂度即为 $O(a^2X\log_{\frac Xa}n)$。

### Code

我取了 $B=8$。

跑得很快，目前是 [loj 最优解](https://loj.ac/s/1689531)。

```cpp
const ullt Mod=998244353;
const uint Lim=9;
using Vec = ullt[Lim];
using Mat = Vec[Lim];
inline voi copy(Mat a,Mat b){
    for(uint i=0;i<Lim;i++)for(uint j=0;j<Lim;j++)b[i][j]=a[i][j];
}
inline voi mul(Mat a,Mat b,Mat c){
    for(uint i=0;i<Lim;i++)for(uint j=0;j<Lim;j++)
        for(uint k=0;k<Lim;k++)c[i][k]+=a[i][j]*b[j][k];
    for(uint i=0;i<Lim;i++)for(uint j=0;j<Lim;j++)c[i][j]%=Mod;
}
inline voi muleq(Vec a,Mat b){
    static Vec c;
    for(uint i=0;i<Lim;i++)c[i]=0;
    for(uint i=0;i<Lim;i++)for(uint j=0;j<Lim;j++)c[j]+=a[i]*b[i][j];
    for(uint i=0;i<Lim;i++)a[i]=c[i]%Mod;
}
Mat Base[25][8],M;Vec Ans;
ullt A[7];
voi update(uint n){
    if(!~n)A[0]=A[1]=A[2]=A[3]=A[4]=A[5]=A[6]=0;
    else if(n<=6)for(uint i=0;i<=6;i++)A[i]=n>=i;
    else A[0]=A[1]=A[2]=A[3]=1,A[4]=(n-1)/3,A[5]=(n-2)/3,A[6]=n/3-1;
}
int main()
{
#ifdef MYEE
    freopen("QAQ.in","r",stdin);
    // freopen("QAQ.out","w",stdout);
#endif
    ullt n;uint c,x;scanf("%llu%u%u",&n,&c,&x),update(c);
    for(uint i=0;i<=6;i++)for(uint j=0;j<=2;j++)for(uint k=0;k<=2;k++)if(j+k<=i)
        Base[0][1][j*3+k][k*3+(i-j-k)%3]+=A[i];
    for(uint i=0;;i++){
        static ullt v=1;
        mul(Base[i][1],Base[i][1],Base[i][2]);
        mul(Base[i][2],Base[i][1],Base[i][3]);
        mul(Base[i][3],Base[i][1],Base[i][4]);
        mul(Base[i][4],Base[i][1],Base[i][5]);
        mul(Base[i][5],Base[i][1],Base[i][6]);
        mul(Base[i][6],Base[i][1],Base[i][7]);
        if((v<<=3)>n)break;
        mul(Base[i][7],Base[i][1],Base[i+1][1]);
    }
    std::vector<std::pair<ullt,uint> >V(x);
    for(auto&s:V)scanf("%llu%u",&s.first,&s.second);
    std::sort(V.begin(),V.end());
    Ans[0]=1;
    ullt a=0;
    for(auto s:V){
        a=s.first-a-1;for(uint i=0;a;i++,a>>=3)if(a&7)muleq(Ans,Base[i][a&7]);
        a=s.first,copy(Base[0][1],M),update(s.second-1);
        for(uint i=0;i<=6;i++)for(uint j=0;j<=2;j++)for(uint k=0;k<=2;k++)if(j+k<=i)
            M[j*3+k][k*3+(i-j-k)%3]-=A[i];
        muleq(Ans,M);
    }
    a=n-a;for(uint i=0;a;i++,a>>=3)if(a&7)muleq(Ans,Base[i][a&7]);
    printf("%llu\n",Ans[0]);
    return 0;
}
```


---

## 作者：chroneZ (赞：1)

逆向考虑，我们可以将问题转化为，每次可以单点加 $3$ 或者给长为 $3$ 的子区间加 $1$，求最终能形成的序列 $f$ 的数量，要求 $\forall i \in [1, n], f_i \in [c_i, C]$。

先入手 $X = 0$ 的部分分。

此类问题一般会有一个方向是，建立一种策略，使得每种合法序列可以被一个唯一的操作序列产生，类似的如 CF1821F。

观察到 $3$ 次操作二等价于在 $3$ 个位置上进行操作一，因此可以钦定对相同区间执行操作二的数量位于 $[0, 2]$ 中。考虑只通过操作二能生成哪些序列，这样的序列满足，不存在一种含有操作一的操作序列，最终能形成这样的序列。这样，我们在所有“由操作二生成的序列”中进行若干次单点加 $3$，就可以唯一覆盖所有的合法序列了。

加 $3$ 是单点加，每个 $i$ 独立，因此可以考虑乘法原理。具体地，对一个给定的由操作二生成的序列 $f'$，其可以进一步生成的合法序列数为 $\prod (\lfloor \frac{C - f'_i}{3}\rfloor + 1)$，故可以考虑 DP。$f'_i$ 事实上只和 $i - 1, i - 2$ 上执行的操作二数量相关，因此设计状态 $g_{i, p, q}$ 表示考虑前 $i$ 项，第 $i$ 项和第 $i - 1$ 项上执行的操作二数分别为 $p, q$ 时的答案。转移细节较多，形式大致是 $g_{i, t, p} \gets \sum \limits_{q = 0} ^ 2 g_{i - 1, p, q} \times (\lfloor \frac{C - t - p - q}{3} \rfloor + 1)$。显然可以用一个 $9 \times 9 $ 的矩阵优化。答案即为 $f_{n, 0, 0}$。

回到 $X \neq 0$ 的情况，延续上方的思路，此时不过是增加了一个下界限制。只需要保证做完单点加 $3$ 的过程后满足下界限制即可。把序列分成若干段做就行了，每一个没有任何限制的段可以直接用矩阵转移，有限制的位置就特殊 DP 一下。

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;

constexpr int mod = 998244353;
inline int add(int x, int y) {return (x + y >= mod ? x + y - mod : x + y);}
inline int dec(int x, int y) {return (x - y < 0 ? x - y + mod : x - y);}
inline void ad(int &x, int y) {x = add(x, y);}
inline void de(int &x, int y) {x = dec(x, y);}

constexpr int K = 9;
struct Matrix {
	int a[K][K];
	Matrix() {memset(a, 0, sizeof a);}
	inline int* operator [] (int x) {return a[x];}
	inline friend Matrix operator * (Matrix x, Matrix y) {
		Matrix r;
		for(int i = 0; i < K; i++) {
			for(int k = 0; k < K; k++) {
				for(int j = 0; j < K; j++) {
					ad(r[i][j], 1ll * x[i][k] * y[k][j] % mod);
				}
			}
		}
		return r;
	}
};

inline Matrix qpow(Matrix a, i64 b) {
	Matrix r;
	for(int i = 0; i < K; i++) {
		r[i][i] = 1;
	}
	while(b) {
		if(b & 1) {
			r = r * a;
		}
		a = a * a; b >>= 1;
	}
	return r;
}

constexpr int N = 1000 + 10;
int f[N][3][3];
i64 a[N]; int c[N];

int main() {
	// freopen("card.in", "r", stdin);
	// freopen("card.out", "w", stdout);
	ios::sync_with_stdio(false); 
	cin.tie(nullptr); cout.tie(nullptr);
	
	i64 n; int C; cin >> n >> C;
	int m; cin >> m;
	for(int i = 1; i <= m; i++) {
		cin >> a[i] >> c[i];
	}
	if(a[m] != n) {
		a[++m] = n;
		c[m] = 0;
	}

	Matrix T; 
	for(int t = 0; t < 3; t++) {
		for(int p = 0; p < 3; p++) {
			for(int q = 0; q < 3; q++) {
				if(p + q + t > C) {
					continue;
				}
				int coef = (C - p - q - t) / 3 + 1;
				int x = t * 3 + p;
				int y = p * 3 + q;
				T[y][x] = coef;
			}
		}
	}
	Matrix F; F[0][0] = 1;
	// F = F * qpow(T, n);
	// cout << F[0][0] << "\n";

	i64 L = 0;
	for(int i = 1; i <= m; i++) {
		F = F * qpow(T, a[i] - L - 1);
		for(int p = 0; p < 3; p++) {
			for(int q = 0; q < 3; q++) {
				f[i - 1][p][q] = F[0][p * 3 + q];
			}
		}
		for(int t = 0; t < 3; t++) {
			if(a[i] >= n - 1 && t != 0) {
				continue;
			}
			for(int p = 0; p < 3; p++) {
				for(int q = 0; q < 3; q++) {
					if(p + q + t > C) {
						continue;
					}
					int it = p + q + t;
					if(it < c[i]) {
						it += (c[i] - it + 2) / 3 * 3;
					}
					if(it > C) {
						continue;
					}
					int coef = (C - it) / 3 + 1;
					ad(f[i][t][p], 1ll * f[i - 1][p][q] * coef % mod);
				}
			}
		}
		for(int p = 0; p < 3; p++) {
			for(int q = 0; q < 3; q++) {
				F[0][p * 3 + q] = f[i][p][q];
			}
		}
		L = a[i];
	}
	cout << F[0][0] << "\n";
}
```

---

## 作者：hhoppitree (赞：1)

#### 题意简述

有一副纸牌，牌一共有 $n$ 种，分别为 $1,2,\cdots,n$，每种有 $C$ 张。

三张形如 $(i,i+1,i+2)$ 或 $(i,i,i)$ 的牌可以组成一叠，现在给定一牌集，由 $X$ 种牌组成，其中第 $i$ 种牌为 $k_i$，出现了 $a_i$ 次，求给定牌集的超集中有多少个可以被分为若干叠牌，对 $P=998244353$ 取模，其中两组牌相同当且仅当它们含有的每一种牌数量都相同。

对于 $20\%$ 的数据，$n=9$，$C=4$；  
对于另外 $15\%$ 的数据，$n\le10^5$，$C=2$；   
对于另外 $15\%$ 的数据，$X\le5$，$C\le10$；  
对于另外 $10\%$ 的数据，$X=0$；  
对于另外 $20\%$ 的数据，$n\le10^5$；  
对于所有数据，$n\le10^{18}$，$a_i,C,X\le1000$。   
Bonus：$n\le10^{18}$，$X\le 60000$。

#### 题目解法

先来考虑当给定牌集确定时，如何判断其是否可以被分为若干叠牌。

贪心匹配显然是正确的，但是这不具有扩展性。

延续贪心的思想，逐种牌加入，考虑如何用一个简小的状态来刻画当前情况来合并等价类，容易发现，我们**只关心当前情况下插入后的的 $(i-1,i,i+1)$ 以及 $(i,i+1,i+2)$ 对数**。

考虑扩展到计数上，记 $f_{i,j,k}$ 表示当前插入了第 $i$ 种牌，$(i-1,i,i+1)$ 的对数为 $j$，$(i,i+1,i+2)$ 的对数为 $k$ 的方案数。

但是以上方案可能会在一个牌集有多种划分方式时重复计数，且时间复杂度过劣，考虑如何限制 $\texttt{DP}$ 状态或转移。

一个在麻将题经常出现的套路是：**三对一样的面子 $(i,i+1,i+2)$ 可以转化为三对刻子 $(i,i,i)$，且在此种限制下（即不存在超过两对一样的面子）的方案是唯一的**，所以可以将 $j,k$ 的值域限定为 $0,1,2$，此时暴力计算的时间复杂度为 $\mathcal{O}(nC)$。

观察 $f$ 的转移方程（记 $s=j+k+l$，且假设 $s\le C$，因为只有此时 $f_{i,j,k}$ 才有贡献）：
$$
f_{i+1,k,l}=\begin{cases}f_{i,j,k}\times\left(\left\lfloor\dfrac{C-s}{3}\right\rfloor\right)+1&s\ge a_{i+1}\\f_{i,j,k}\times\left(\left\lfloor\dfrac{C-s-3\times\left\lfloor\frac{a_{i+1}-s}{3}\right\rfloor}{3}\right\rfloor+1\right)&s<a_{i+1}\end{cases}
$$
发现**这是一个矩阵乘法的形式**！

具体的，将 $f_{i,j,k}\small(0\le j,k<3)$ 的状态改为 $f_{i,3j+k}$，则此时矩阵乘法的形式便清晰了。

之后可以直接采用**矩阵快速幂**进行优化，设当 $a_{i+1}=x$ 时对应的转移矩阵为 $g(x)$，那么由于初始牌集的存在，答案即为 $g(0)^{k_1-1}g(a_1)g(0)^{k_2-k_1-1}g(a_2)\cdots g(a_X)g(0)^{n-k_X}$，暴力计算即可做到 $\mathcal{O}(Xc^3\log n)$，其中 $c=9$ 为转移矩阵大小。

更优秀的，可以预处理出所有形如 $g(0)^{2^x}$ 的矩阵幂结果，之后采用向量乘矩阵即可快速计算，时间复杂度 $\mathcal{O}(c^3\log n+c^2X\log n)$。

#### 总结

先考虑原问题的具有推广性的解决方法，再对计数问题进行 $\texttt{DP}$，并对原问题的解决方法中某切面的等价类进行合并，常常在此类 $\texttt{DP}$ 套 $\texttt{DP}$ 的问题中，转移具有一般性（即每次转移的方式一样），此时可以考虑使用矩阵快速幂进行优化。

---

## 作者：liujiaxi123456 (赞：0)

显然考虑 DP，两种思路：

- 记录 i 选的数量，i-1 选的数量。

- 记录 $[i-1, i, i+1] $ 的数量，$[i, i+1, i+2] $ 的数量。

两种都可以做，但是写一写基础 DP 方程就会发现第一种比较麻烦，于是优先考虑第二种。

- 令 $f[i][j][k] $ 表示前 i 个数中，选了 j 个 $[i, i+1, i+2] $，k 个 $[i-1, i, i+1] $。

- 显然 $f[i][j][k] $ 由 $ f[i-1][k][l] $ 转移过来。

- 考虑一下系数，应为每种情况可能的 $(i, i, i) $ 的数量，即 $\lfloor \dfrac{C-已选 i 的数量}{3}\rfloor = \lfloor\dfrac{C-j-k-l}{3}\rfloor $ 。

- 至于有限制的，稍微改改即可。

考虑优化：

- 首先，若形如 $[i-1, i, i+1] $ 的数量超过 2，则一定可以改成若干个 $(i, i, i) $ 的形式 + 几个 $[i-1, i, i] $。

  - 所以 $j,k,l<3 $。
 
- 其次，大部分（除了给出的那 X 个）$f[i] $ 的转移是一样的，所以考虑矩阵快速幂。

  - 对于有值的那一部分单独 DP 即可。
 
Code：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define int long long
using namespace std;

const int MOD = 998244353;

class Matrix {
private:
public:
	int N, M; ll a[10][10];
	inline void init(int C) {
		// printf("init(%d)\n", C);
		N = 9, M = 9;
		for(int i=0; i<9; i++) {
			for(int j=0; j<9; j++) {
				if(i%3 != j/3)	continue;
				int s = i/3 + i%3 + j%3;
				if(s <= C)	a[i][j] = (C - s)/3 + 1;
				// printf("a[%d][%d]:%lld, s:%d\n", i, j, a[i][j], s);
			}
		}
		// puts("");
	}
	inline void init() {
		N = 1, M = 9, a[0][0] = 1;
	}
	inline void init(int C, int num) {
		N = 9, M = 9;
		for(int i=0; i<9; i++) {
			for(int j=0; j<9; j++) {
				if(i%3 != j/3)	continue;
				int s = i/3 + i%3 + j%3;
				if(s < num)	s += (num-s+2)/3*3;
				if(s <= C)	a[i][j] = (C-s)/3+1;
				else 	a[i][j] = 0;
			}
		}
		// printf("init(%d, %d)\n", C, num);
		// for(int i=0; i<N; i++) {
		// 	for(int j=0; j<M; j++) {
		// 		printf("a[%d][%d]:%lld\n", i, j, a[i][j]);
		// 	}
		// }
		// puts("");
	}
	inline int ans() {
		return a[0][0];
	}
	static inline void mul(Matrix &a, Matrix &b) {
		static ll c[10][10];
		// printf("a.N:%d, a.M:%d, b.N:%d, b.M:%d\n", a.N, a.M, b.N, b.M);
		for(int i=0; i<a.N; i++) {
			for(int j=0; j<b.M; j++) {
				c[i][j] = 0;
				for(int k=0; k<a.M; k++) {
					c[i][j] += a.a[i][k]*b.a[k][j] %MOD;
				}
				c[i][j] %= MOD;
			}
		}
		for(int i=0; i<a.N; i++) {
			for(int j=0; j<a.M; j++) {
				a.a[i][j] = c[i][j];
			}
		}
	}
} c, f, tmp;

namespace Josh_zmf {
	
	ll N; int C, X;

	inline void pow(Matrix &c, Matrix a, ll b) {
		// printf("pow(%lld)\n", b);
		for(; b; ) {
			if(b&1)	Matrix::mul(c, a);
			Matrix::mul(a, a), b >>= 1;
		}
	}

	inline int main() {
		cin>> N>> C>> X;
		c.init(C), f.init();
		// for(int i=0; i<9; i++) {
		// 	for(int j=0; j<9; j++) {
		// 		printf("f[%d][%d]:%lld\n", i, j, f.a[i][j]);
		// 	}
		// }
		int last = 0;
		for(int i=1, num; i<=X; i++) {
			ll id; cin>> id>> num;
			if(id != last+1)	pow(f, c, id-last-1);
			// for(int j=0; j<9; j++) {
			// 	for(int k=0; k<9; k++) {
			// 		printf("f[%d][%d]:%lld, tmp:%lld\n", j, k, f.a[j][k], tmp.a[j][k]);
			// 	}
			// }
			tmp.init(C, num), Matrix::mul(f, tmp), last = id;
		}
		pow(f, c, N-last);
		cout<< f.ans()<< '\n';
		return 0;
	}

}

signed main() {
	Josh_zmf::main();
	return 0;
}
```

---


# [SNOI2019] 积木

## 题目描述

有一块 $n$ 行 $m$ 列的网格板， $n,m$ 都是奇数。网格上平铺着一些 $1\times 2$ 的积木。积木可以旋转，不能重叠。这些积木共有 $\frac{nm-1}{2}$ 块，也就是说，网格板上只有一格的空位。

你可以做两种操作：

1. 将一块与空白格相邻（指有公共边）的积木旋转 $90^\circ$ 到空白格中；
2. 将一块与空白格积木相邻的积木平移至空白格中。

如图所示（被移动的积木颜色较浅）：

![](https://cdn.luogu.com.cn/upload/pic/58669.png)

请你用以上两种操作将给定的网格板变换为指定的状态。

## 说明/提示

#### 数据范围与说明

你输出的操作序列长度不能超过 $8\times 10^6$ 。

对于所有数据， $1\leq n,m\leq 2000$ 。

- 对于 $10\%$ 的数据， $n,m\leq 3$ ；
- 对于另外 $10\%$ 的数据， $n,m\leq 5$ ；
- 对于另外 $20\%$ 的数据， $m=3$ ；
- 对于另外 $20\%$ 的数据， $n,m\leq 50$ ；
- 对于另外 $20\%$ 的数据， $n,m\leq 200$ ；
- 对于余下 $20\%$ 的数据，无特殊限制。

#### SPJ 说明

参考 https://www.luogu.org/discuss/show/114298 ，感谢 @M_sea 的贡献。

## 样例 #1

### 输入

```
3 3
nnn
uuu
o<>
<>n
<>u
<>o```

### 输出

```
URLR```

## 样例 #2

### 输入

```
5 5
n<><>
un<>n
nuonu
u<>un
<><>u
<><>o
<><>n
<><>u
<><>n
<><>u```

### 输出

```
RLLRLRR```

# 题解

## 作者：namelessgugugu (赞：18)

做完之后有人告诉我这题上界卡的很死，除了官解做法都很难通过，我寻思这都给了两倍常数了还能卡属实是有点厉害。

哦什么，原来是我爆标了，那没事了。

#### 题意

懒得写了，直接看[链接](https://www.luogu.com.cn/problem/P5372)吧。

#### 题解

注意到对图进行黑白交替染色（认为 $(1, 1)$ 被染成黑）后黑色格子比白色格子多 $1$ 个，因此可知空点始终落在黑格子中。

而对于一个 $1 \times 2$ 的积木，其正好覆盖一黑一白两个格子，且由于空点始终在黑格子上，会发现每次操作不改变积木覆盖到的白格子，因此也可以用一个白格子来指代一块积木。

想象一下，操作的过程大概相当于空点在黑点上借积木实现移动，所以可以如此建模：把黑格子当作点，白格子当作边，把空点当作在图上游走的棋子。

具体地，对于一个积木，设其初始位置为 $((x_1, y_1), (x_2, y_2))$，其中 $(x_1, y_1)$ 是白格子，最终位置为 $((x_1, y_1), (x_3, y_3))$，则相当于需要棋子从 $(x_3, y_3)$ 走到 $(x_2, y_2)$ 一次，于是连一条 $(x_3, y_3) \to (x_2, y_2)$ 的边。

而最后要做的就是让棋子把所有边都访问一遍，由于这张图除了起点终点每个点的入度出度都为 $1$，可以直接跑欧拉路径解决。

但是事情并没有那么简单，很显然这张图并没有保证连通，我们需要先对这张图做一些调整使其连通。

能做的调整其实就是让某个积木不一定被操作仅一次，而是有可能先被操作到一个中间态，再被操作到终态。如果让某个积木被操作正好两次，设中间态为 $((x_1, y_1), (x_4, y_4))$，那么连边会改为 $(x_3, y_3) \to (x_4, y_4) \to (x_2, y_2)$，这样会提出一个新的要求：棋子必须先走过 $(x_4, y_4) \to (x_2, y_2)$，再走过 $(x_3, y_3) \to (x_4, y_4)$。

事实上，这样的调整已经足够解决这个问题，而且做法相当简单粗暴：

如果当前有一个 $(x_1, y_1)$ 满足对应的 $(x_2, y_2)$ 和 $(x_3, y_3)$ 尚未与起点连通，且有一个 $(x_4, y_4)$ 已经与起点连通，则直接把其设为中间态。这样就让 $(x_2, y_2)$ 和 $(x_3, y_3)$ 与起点连通了。

由于加中间态只会让 $(x_4, y_4)$ 的出度入度各增加 $1$，故还是能跑欧拉路径，而且实际上跑出来一定满足刚刚的顺序要求，因为如果从起点出发的棋子都能先走到 $(x_3, y_3)$ 了，显然这个点在调整前就已经与起点连通，那根本不会进行这个调整。

这同样也要求在代码实现时不能无脑调整，一定需要等到有必要调整时再调，所以实现应该是：对起点所在连通块进行遍历，如果遇到上述所说的可以调整的情况，则调整完后需要先遍历 $(x_2, y_2)$ 所在的连通块，标记为已连通，以免之后有蒙古人再次对该连通块进行调整导致答案错误。

显然操作次数为总边数，而一个白格子至多贡献两条边，所以至多操作 $nm - 1$ 次，比其他解法在操作次数上更优一些。

#### 代码

写的时候在 `int`，`pair<int, int>` 和 `int x, y` 之间来回转化，所以比较屎山。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <utility>
#include <vector>
#include <array>
#define FILEIO(filename) (freopen(filename ".in", "r", stdin), freopen(filename ".out", "w", stdout))
typedef long long ll;
typedef unsigned long long ull;
using std::pair, std::vector, std::array;
const int N = 2005, M = 4000005;
const int dx[8] = {1, 0, -1, 0, 1, 1, -1, -1}, dy[8] = {0, 1, 0, -1, 1, -1, 1, -1};
int n, m;
char a[2][N][N];
int edg[N][N];
inline int id(int x, int y)
{
    return (x - 1) * m + y;
}
inline pair<int, int> getp(int x)
{
    return {(x - 1) / m + 1, (x - 1) % m + 1};
}
inline pair<int, int> getpt(int x, int y, int o)
{
    if(a[o][x][y] == '<')
        return {x, y + 1};
    else if(a[o][x][y] == '>')
        return {x, y - 1};
    else if(a[o][x][y] == 'n')
        return {x + 1, y};
    else if(a[o][x][y] == 'u')
        return {x - 1, y};
    return {-1, -1};
}
inline int findedg(pair<int, int> f, pair<int, int> t)
{
    if(f == t)
        return -1;
    int d1 = t.first - f.first, d2 = t.second - f.second;
    for (int o = 0; o < 8;++o)
        if (d1 == dx[o] * (o < 4 ? 2 : 1) && d2 == dy[o] * (o < 4 ? 2 : 1))
            return o;
    return -2;
}
inline void addedg(pair<int, int> x, int o)
{
    edg[x.first][x.second] |= 1 << o;
    return;
}
int que[M], hd, tl;
bool vis[N][N];
void dfs(int x, int y)
{
    vis[x][y] = 1;
    que[++tl] = id(x, y);
    for (int o = 0; o < 8; ++o)
        if((edg[x][y] >> o) & 1)
        {
            int nx = x + dx[o] * (o < 4 ? 2 : 1), ny = y + dy[o] * (o < 4 ? 2 : 1);
            if(!vis[nx][ny])
                dfs(nx, ny);
        }
    return;
}
void bfs(int s)
{
    hd = 1, tl = 0;
    auto [sx, sy] = getp(s);
    dfs(sx, sy);
    while (hd <= tl)
    {
        auto [x, y] = getp(que[hd++]);
        for (int o = 0; o < 4;++o)
        {
            int nx = x + dx[o], ny = y + dy[o];
            if(nx < 1 || nx > n || ny < 1 || ny > m)
                continue;
            auto f = getpt(nx, ny, 1), t = getpt(nx, ny, 0);
            if(!vis[f.first][f.second])
            {
                dfs(f.first, f.second);
                int e1 = findedg(f, t);
                int e2 = findedg(f, {x, y}), e3 = findedg({x, y}, t);
                if(e1 != -1)
                    edg[f.first][f.second] ^= 1 << e1;
                if(e2 != -1)
                    addedg(f, e2);
                if(e3 != -1)
                    addedg({x, y}, e3);
            }
        }
    }
    return;
}
int res[M << 1], tt;
void getans(int x, int y)
{
    for (int o = 0; o < 8;++o)
        if ((edg[x][y] >> o) & 1)
        {
            int nx = x + dx[o] * (o < 4 ? 2 : 1), ny = y + dy[o] * (o < 4 ? 2 : 1);
            edg[x][y] ^= 1 << o;
            getans(nx, ny);
        }
    res[++tt] = id(x, y);
}
char ans[M << 1];
inline char operate(pair<int, int> f, pair<int, int> t)
{
    pair<int, int> ky = getpt(t.first, t.second, 0);
    int d1 = ky.first - f.first, d2 = ky.second - f.second;
    for (int o = 0; o < 4;++o)
        if(d1 == dx[o] && d2 == dy[o])
        {
            a[0][ky.first][ky.second] = "u>n<"[o];
            a[0][f.first][f.second] = "n<u>"[o];
            a[0][t.first][t.second] = 'o';
            return "DRUL"[o];
        }
    return 0;
}
int main(void)
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n;++i)
        scanf("%s", a[0][i] + 1);
    for (int i = 1; i <= n;++i)
        scanf("%s", a[1][i] + 1);
    int s = 0;
    for (int i = 1; i <= n;++i)
        for (int j = (i & 1 ? 2 : 1); j <= m;j += 2)
        {
            auto f = getpt(i, j, 1), t = getpt(i, j, 0);
            if(f != t)
                addedg(f, findedg(f, t));
        }
    for (int i = 1; i <= n;++i)
        for (int j = 1; j <= m;++j)
            if(a[0][i][j] == 'o')
            {
                s = id(i, j);
                break;
            }
    bfs(s);
    getans((s - 1) / m + 1, (s - 1) % m + 1);
    std::reverse(res + 1, res + 1 + tt);
    for (int i = 1; i < tt;++i)
        ans[i] = operate(getp(res[i]), getp(res[i + 1]));
    puts(ans + 1);
    return 0;
}
```

---

## 作者：EXODUS (赞：13)

# Part 1：前言

由于唯一的题解写的太过简略，因此补一个有详细证明和过程的题解 QAQ。

# Part 2：正文

考虑将原图转化为一个 $n\times m$ 的点阵，然后把每一个积木看成连接两个点的一条边。考虑发掘这个图的一些性质。

- 图上有且仅有一个点度数为零，且度数不为零的点度数全为 $1$。

  这一点根据定义容易证明。下文中我们记这个度数为 $0$ 的点为 $s$。

- 在图中做一次操作相当于从 $s$ 周围四个点中选一个点 $v$，将其本来连向 $w$ 的边断掉，并向 $s$ 连边。同时 $w$ 将成为新的 $s$。

  经过简单观察可以得出上述结论。

现在问题变为了，我们可以做若干次上述操作，然后将当前局面的图（记为 $G_s$）转化为给定局面的图（记为 $G_t$)。

但是到这里还是没有什么思路。我们尝试将操作进一步分割。具体而言，我们将其拆分为 $s$ 向 $v$ 连边和 $v$ 向 $w$ 断边两步。我们不妨将空位看成一个棋子，那么这个过程相当于是棋子从 $s$ 走向 $v$，改变边 $(s,v)$ 的存在状态，从 $v$ 走向 $w$，改变边 $(v,w)$ 的存在状态。

那么我们不妨把删边断边变成改变每个边的属性，这个属性为 $0$ 当且仅当边不存在，反之依然。初始时，每个点和其周围的四联通点都有连边，但一部分边状态为 $0$，另一部分状态为 $1$。我们可以使用棋子走过一些点来取反一些边，**但是走的路径要求是按照 $0101\cdots01$ 的顺序排列**，我们的目标是让生成的图 $G_s$ 和 $G_t$ 相同。

首先考虑后者。取反使得数字相同的经典套路是异或。我们考虑构建一个新的叠加图 $G_d$。其中 $G_d$ 中每条边的状态是 $G_s$ 和 $G_t$ 对应位置的边的状态的异或。我们现在的目标是让图 $G_d$ 每条边的状态全为 $0$。

考虑先发掘一下图 $G_d$ 的性质。

- 令在图 $G_s$ 中度数为零的点为 $s$，$G_t$ 中为 $t$。则在图 $G_d$ 中除 $s,t$ 以外，所有点的周围相连的状态为 $1$ 的边的条数（下文简称为度数）是零或二。

  注意到在 $G_s$ 和 $G_t$ 中，除去 $s$ 和 $t$，每个点度数均为一。那么其边权异或叠加后每个点度数只能为零或二。这一点比较显然。

  同时我们可以注意到，图中不存在度数为一的点当且仅当 $s=t$。

- 如果只保留状态为 $1$ 的边，图 $G_d$ 由若干个环或一条以 $s,t$ 为两端点的链和若干个环构成。

  去掉所有度数为零的点，由于每个点度数为二且至多两个点度数为一，所以一定由若干环构成或一条链加上若干环。而链的端点度数一定为一，所以链的端点一定为 $s$ 或 $t$。

不妨先考虑存在链的情况。我们考察从 $s$ 到 $t$ 的这条链。注意到如果我们把这条路径拉出来拍到 $G_s$ 上，$G_s$ 上的边一定满足其状态呈现 $0101\cdots01$ 交替的状态。

为什么？我们通过一些引理来说明这些事情。下文令这条路径为 $s\rightarrow u_1\rightarrow u_2\rightsquigarrow u_l\rightarrow t$。

- $(s,u_1)$ 在 $G_s$ 上状态一定为 $0$。

  根据 $s$ 的定义可知。

- $(s,u_1),(u_1,u_2)$ 在 $G_s$ 上的状态一定不同。

  因为在图 $G_s$ 上和 $G_t$ 上每个点的度数均为 $1$，所以状态为 $1$ 且共端点的两条边不可能同时存在于一个图。所以必定在 $G_s$ 上一条边的状态为 $1$，另一条边在 $G_t$ 上状态为 $1$。

根据引理我们可以简单推出上述结论。同时，我们可以仿照第一个引理的证明过程说明 $(u_l,t)$ 这条边在 $G_s$ 上的状态为 $1$，这也意味着这条路径的长度（按照边数计算）一定为偶数。

也就是说，我们可以一开始直接从 $s$ 走到 $t$，使得原图只剩下若干个边的状态全为 $1$ 的环。现在我们考虑一个环该如何处理。

根据上面链的引理二的证明，我们可以类似的发现环的相邻两条边状态不同，且环长为偶数。因此我们如果可以直接走到这个环的一个端点问题就解决了。因为我们可以直接从这个环上绕一圈再下来，然后再原路返回。

现在的问题主要剩下了三个。

- 是否从每个点都能走到一个环。
- 是否可以原路返回。
- 步数是否足够。

第二个问题是最容易的，显然从 $u$ 走到 $v$ 再走回来，如果第一步合法，则后一步也合法，且不改变其他边的状态。

然后解决第三个问题。我们注意到我们每次实际上没必要直接走回原点，我们可以直接从走出偶环的端点开始继续搜索找其它环，这样每个点只会进一次出一次，故总步数实际上是 $O(nm)$ 的。

接下来考虑第一个问题，我对此有一个较为感性的证明，考虑对于一条非法路径，我们找出那个两侧均为状态为 $0$ 的边的点，我们让其向外走那条状态为 $1$ 的边，然后从接着向后增广，注意到这样的过程可以一直重复直到所有点都被经过，所以这个结论是正确的。在讨论区里好像有一些较为严谨的分讨证法，大家可以研究一下。


# Part 3：代码

```cpp
bool membg=0;

constexpr int N=2e3+7,dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};
constexpr char direct[4]={'U','D','L','R'};
int n,m,sx,sy,tx,ty;
tuple<short,short,char>eS[N][N],eT[N][N];
tuple<short,short,char>eG[N][N][4],eD[N][N][2];
char str[N][N];
bool key[N][N],vis[N][N];

bool memed=0;

void move(int &x,int &y){
	key[x][y]=0;putchar(direct[get<2>(eD[x][y][0])]);
	tie(x,y,*new int)=eD[x][y][0];key[x][y]=0;
	tie(x,y,*new int)=eD[x][y][1];key[x][y]=0;
}

void move(int Sx,int Sy,int Tx,int Ty){
	int ux=Sx,uy=Sy;
	while(ux!=Tx||uy!=Ty)
		move(ux,uy);
}

void dfs(int x,int y){
	vis[x][y]=1;
	for(int d=0;d<4;d++){
		auto [vx,vy,vd]=eG[x][y][d];
		if(!vx)continue;
		if(vis[vx][vy])continue;
		if(key[vx][vy]){
			auto [Sx,Sy,Sd]=eD[vx][vy][1];
			auto [Tx,Ty,Td]=eD[vx][vy][0];
			putchar(direct[vd]);
			move(Sx,Sy,Tx,Ty);
			putchar(direct[get<2>(eD[Tx][Ty][0])]);
			key[vx][vy]=0;
		}
		vis[vx][vy]=1;
		tie(vx,vy,*new int)=eT[vx][vy];
		auto [vvx,vvy,vvd]=eT[vx][vy];
		if(vvx==0||vis[vx][vy])continue;
		putchar(direct[vd]);
		if(key[vx][vy]){int p=vx,q=vy;move(p,q),move(p,q,x,y);}
		else dfs(vx,vy);
		putchar(direct[vvd]);
		
	}
}

void solve(){
	read(n,m);
	for(int i=1;i<=n;i++)scanf("%s",str[i]+1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			if(str[i][j]=='<')     eS[i][j]=make_tuple(i,j+1,3);
			else if(str[i][j]=='>')eS[i][j]=make_tuple(i,j-1,2);
			else if(str[i][j]=='n')eS[i][j]=make_tuple(i+1,j,1);
			else if(str[i][j]=='u')eS[i][j]=make_tuple(i-1,j,0);
			else sx=i,sy=j,eS[i][j]=make_tuple(0,0,-1);
		}
	
	for(int i=1;i<=n;i++)scanf("%s",str[i]+1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			if(str[i][j]=='<')     eT[i][j]=make_tuple(i,j+1,3);
			else if(str[i][j]=='>')eT[i][j]=make_tuple(i,j-1,2);
			else if(str[i][j]=='n')eT[i][j]=make_tuple(i+1,j,1);
			else if(str[i][j]=='u')eT[i][j]=make_tuple(i-1,j,0);
			else tx=i,ty=j,eT[i][j]=make_tuple(0,0,-1);
		}
	
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			for(int d=0;d<4;d++)
				eG[i][j][d]=make_tuple(i+dx[d],j+dy[d],d);
	
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			if(get<0>(eS[i][j])==0||get<0>(eT[i][j])==0)continue;
			if(eS[i][j]!=eT[i][j]){
				auto [si,sj,sd]=eS[i][j];
				auto [ti,tj,td]=eT[i][j];
				eD[i][j][0]=eT[i][j];
				eD[i][j][1]=eS[i][j];
				eD[ti][tj][0]=eT[ti][tj];
				eD[si][sj][1]=eS[si][sj];
				key[si][sj]=key[ti][tj]=key[i][j]=1;
			}
		}
	
	move(sx,sy,tx,ty);
	dfs(tx,ty);
	putchar('\n');
	return;
}
```



---

## 作者：PaperCloud (赞：13)

发现并没有要求用最短的步骤（笑。。。

其实，每次改变空格的位置的同时，都可以顺便使得目标状态中这个空格位置的木块归位

移着移着，就移到目标状态中的空格的位置了

但是此时我们只能保证移动路线上的木块都归位

我们需要dfs，如果碰到不合法就使其归位：这样的移动路径必然会是一个环，所以我们又回到了最初不合法的位置

每个格子只需被搜索一次，因为搜索完某个格子后，它的木块必然已经归位了。

原来是大模拟啊

```cpp
#include<bits/stdc++.h>
#define dbg1(x) cerr<<#x<<"="<<(x)<<" "
#define dbg2(x) cerr<<#x<<"="<<(x)<<"\n"
#define dbg3(x) cerr<<#x<<"\n"
#define ll long long
using namespace std;
#define reg register
const int MN=2005;
const int tr[4][2]={{0,2},{1,3},{2,0},{3,1}};
const int dx[4]={0,-1,0,1},dy[4]={-1,0,1,0};
const char ch[4]={'L','U','R','D'};
int N,M,x,y,xp,yp,len;
char a[MN][MN],c[(MN*MN)<<1];
int ta[MN][MN],tb[MN][MN];
bool vis[MN][MN];

void init(int (*ts)[MN],int &_x,int &_y)
{
	reg int i,j;
	for(i=1;i<=N;++i) scanf("%s",a[i]+1);
	for(i=1;i<=N;++i)for(j=1;j<=M;++j)
		switch(a[i][j])
		{
			case 'o':_x=i,_y=j;ts[i][j]=-1;break;
			case '<':ts[i][j]=2;break;
			case '>':ts[i][j]=0;break;
			case 'n':ts[i][j]=3;break;
			case 'u':ts[i][j]=1;break;
		}
}
void one_step(int k)
{
	c[len++]=ch[k];
	int xi=x+dx[k],yi=y+dy[k];
	int xj=xi+dx[ta[xi][yi]],yj=yi+dy[ta[xi][yi]];
	ta[x][y]=tr[k][0];ta[xi][yi]=tr[k][1];
	ta[x=xj][y=yj]=-1;
}

void Walk_to_o(int X,int Y)
{
	while((x^X)||(y^Y))
		one_step(tb[x][y]);
}

void dfs(int X,int Y)
{
	if(vis[X][Y]) return;
	vis[X][Y]=true;
	for(int i=0;i<4;++i)
	{
		int xi=X+dx[i],yi=Y+dy[i];
		if(xi>N||xi<1||yi<1||yi>M||vis[xi][yi]) continue;
		int xj=xi+dx[tb[xi][yi]],yj=yi+dy[tb[xi][yi]];
		
		if(ta[xi][yi]^tb[xi][yi])
			one_step(i),Walk_to_o(xj,yj),one_step(tb[xj][yj]);
		one_step(i);
		vis[xi][yi]=true;
		dfs(xj,yj);
		one_step(tb[xj][yj]);
	}
}

int main()
{
	scanf("%d%d",&N,&M);
	init(ta,x,y);init(tb,xp,yp);
	
	Walk_to_o(xp,yp);
	
	dfs(xp,yp);
	return 0*printf("%s\n",c);
}
```


---

## 作者：kyEEcccccc (赞：6)

拜谢 JCY_std。

考虑这样刻画问题：给原图黑白染色，得到一个二分图，相当于给出了原图的两个最大匹配，要求走一条交错路把一个变成另一个。求一下两张图的对称差，它的结构形如一条连接两个未匹配点的链，加上一堆环。首先把链走了，那么剩下的就是一堆环。考虑将匹配的点彼此缩起来后建立一个 DFS 树，沿着这个 DFS 树走，当遇到某个在环上的点时，立刻沿着这个环转一圈以后回到原来的点，由于这是第一个遇到的这个环上的点，所以先前在 DFS 树上走的路径不会影响这个环的形状，所以一定可以这样走。走完一圈以后，你发现除了这个环消失了以外，其他信息都没有受影响，所以你正常走 DFS 树，走完一棵子树就回溯。最后所有可达的环都被转了一圈消失了，而其他边刚好在进入子树和出子树时被反转一次，状态不变，这样就解决了这个问题。所有位置显然都是可达的，因为任意两个骨牌有公共边接触就会有非匹配边相连。

---


# [BJOI2016] IP地址

## 题目描述

路由表中每一项对应了一个形如 1011101????????????????????????? 的规则，会匹配指定的前缀为给定形式的 $\texttt{ip}$。  

当有多个规则匹配时，前缀最长的生效。同一时刻不会有多个匹配的规则的前缀一样长。每一个时刻，会有一条规则被加入，或者之前被加入的某条规则会过期。   

给一系列 $\texttt{ip}$，问每一个 $\texttt{ip}$ 在一个给定的时间区间内匹配到的生效规则变了几次？  
   
例如，有一系列事件：    
 
$\texttt{Add}$ $110$   
$\texttt{Add}$ $11$   
$\texttt{Del}$ $110$   
$\texttt{Del}$ $11$   
$\texttt{Add}$ $110$     

那么，$\texttt{ip}$ 地址 11011101001001010101011101000010 在这五个时刻之后匹配到的生效规则分别是：  

$110$ (第一条)，   
$110$ (第一条)，   
$11$ (第二条)，   
空，   
$110$ (第三条)。     

其中，在第二个事件后到第五个事件后的这段过程中，一共变了 $3$ 次。

## 说明/提示

【数据范围】  

$1\le n,q \le 10^5$

## 样例 #1

### 输入

```
5 1
Add 110
Add 11
Del 110
Del 11
Add 110
11011101001001010101011101000010 2 5```

### 输出

```
3```

# 题解

## 作者：我去 (赞：20)

# P5460 [BJOI2016]IP地址 Solution

## 分析

$\bullet$ 由$IP$地址是$01$串，匹配的是$IP$地址的前缀不难想到用$0-1 Trie$树

$\bullet$ 规则的集合随着时间在改变，考虑对规则的集合建$0-1 Trie$树

$\bullet$ 询问一个$IP$地址在时间$[l+1,r]$（题目说的是“在第$a$个事件后”）内变化了多少次，可以转换为$[1,r]-[1,l]$

$\bullet$ 如果只询问一个$IP$地址，那么就非常的简单直接暴力统计即可，所以现在要考虑如何同时维护多个$IP$地址

$\bullet$ 考虑在什么情况下对规则进行修改（包括添加和删除）会影响某一个$IP$地址的答案

&emsp; &emsp; $\circ$ 加入新的规则，新的规则比原来和某个$IP$地址匹配的规则更优

&emsp; &emsp; $\circ$ 删除与某个$IP$地址已匹配的规则

$\bullet$ 再考虑修改一个规则会对哪些$IP$地址的答案产生影响

&emsp; &emsp; $\circ$ 因为匹配的是最优的规则，所以**如果规则$B$是规则$A$的一个前缀，那么对规则$B$进行修改将不会影响与规则$A$匹配的$IP$地址**

![pic](https://cdn.luogu.com.cn/upload/image_hosting/rrog3ev4.png)

&emsp; &emsp; $\circ$ 如上图，粉色涂出来的$IP$地址可以与以$2$节点为结尾的规则以及以$5$节点为结尾的规则匹配，但匹配的是最优的，所以是与以$5$节点为结尾的规则匹配。

&emsp; &emsp; $\circ$ 此时对以$2$节点为结尾的规则进行修改，发现受影响的$IP$地址只有以$2$节点结尾的,以$3$节点结尾的和以$4$节点结尾的$IP$地址。所以说**修改一个规则会对以当前规则结尾与下一个规则结尾之间的点产生影响**

![pic](https://cdn.luogu.com.cn/upload/image_hosting/oe08acyf.png)

&emsp; &emsp; $\circ$ 如上图，修改$6$节点结尾的规则，将不会对粉色涂出来以$4$节点结尾的$IP$地址产生影响，只会对以$6$节点结尾的$IP$地址和以$7$节点结尾的$IP$地址产生影响

$\bullet$ 于是对于$Tire$树上的点，记录一个值$times$表示**执行完当前（对规则的）操作以这个点结尾的$IP$地址将会被更改多少次**，在记录一个懒标记$tag$表示对这个值的修改，**这个标记遇到对规则结尾打上的$end$标记就会被清空（不会对下面的点产生影响）**

## 代码

```cpp
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<cctype>
#include<iostream>
#include<vector>
using namespace std;

const int MAXN = 1e5+5;
const int root = 0;

template <typename T>
inline void read(T&x){
	x=0; char temp=getchar(); bool f=false;
	while(!isdigit(temp)){if(temp=='-') f=true; temp=getchar();}
	while(isdigit(temp)){x=(x<<1)+(x<<3)+temp-'0'; temp=getchar();}
	if(f) x=-x;
}
template <typename T>
void print(T x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) print(x/10);
	putchar(x%10+'0');
}

//basic
int n,q,opt[MAXN],ans[MAXN];
string str[MAXN];
struct Question{
	string ip; int id;
}ques[MAXN];
vector<int> del[MAXN],add[MAXN];

//Trie
struct node{
	int son[2],end,times,tag;
	inline void Update(int val){times+=val,tag+=val;}
#define ls(x) t[x].son[0]
#define rs(x) t[x].son[1]
#define end(x) t[x].end
#define times(x) t[x].times
#define tag(x) t[x].tag
}t[MAXN*32];
int cnt;

inline void Pushdown(int id){
	if(!ls(id)) ls(id)=++cnt;
	if(!rs(id)) rs(id)=++cnt;
	if(tag(id)==0) return;
	if(!end(ls(id))) t[ls(id)].Update(tag(id));
	if(!end(rs(id))) t[rs(id)].Update(tag(id));
	tag(id)=0;
}

inline void Modify(string s,int val){
	int now=root,len=s.length();
	for(register int i=0;i<len;i++){
		Pushdown(now);
		now=t[now].son[s[i]-'0'];
	}
	end(now)+=val,tag(now)++,times(now)++;
}

inline int Query(string s){
	int now=root,len=s.length();
	for(register int i=0;i<len;i++){
		Pushdown(now);
		now=t[now].son[s[i]-'0'];
	}
	return times(now);
}

int main(){
	read(n),read(q);
	for(register int i=1;i<=n;i++){
		char s[6]; scanf("%s",s),cin>>str[i];
		if(s[0]=='A') opt[i]=1;
		else opt[i]=-1;
	}
	for(register int i=1;i<=q;i++){
		cin>>ques[i].ip,ques[i].id=i;
		int l,r; read(l),read(r);
		del[l].push_back(i),add[r].push_back(i);
	}
	for(register int i=1;i<=n;i++){
		Modify(str[i],opt[i]);
		for(register int j=0,tmp=del[i].size();j<tmp;j++) ans[ques[del[i][j]].id]-=Query(ques[del[i][j]].ip);
		for(register int j=0,tmp=add[i].size();j<tmp;j++) ans[ques[add[i][j]].id]+=Query(ques[add[i][j]].ip);
	}
	for(register int i=1;i<=q;i++) print(ans[i]),puts("");
	return 0;
}
```




---

## 作者：shentao1 (赞：11)

考虑搞出一个trie，那么一次添加或者删除操作对应对一整段子树打上+1的tag，但是假如某个点上已经有匹配串了，那就不能把标记往下递。仔细考虑一下，直接打tag不会有问题，然后就做完了。

离线，每次修改相当于对该规则的所有匹配点的值+1，考虑在trie上打加法标记和匹配标记，匹配标记不下传，加法标记下传遇到匹配标记时清空。

next，代码：

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
#define ll long long
#define N 100010
char getc(){
char c=getchar();
while ((c<'A'||c>'Z')&&(c<'a'||c>'z')&&(c<'0'||c>'9'))c=getchar();
return c;
}//读入字母
int gcd(int n,int m){return m==0?n:gcd(m,n%m);}//据说手写gcd会快一点
int read()
{
    int x=0,f=1;char c=getchar();
    while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}
    while (c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
    return x*f;
}//快读
int n,m,cnt,ans[N],root;
struct data{
int ch[2],x,tag,lazy;
}tree[N<<6];//trie
struct bit{int x,n,id;};
struct data2{int op;bit ip;
}q[N];
bit gettwo()
{
    unsigned int x=0,cnt=0;char c=getchar();
    while (c<'0'||c>'9') c=getchar();
    while (c>='0'&&c<='1') x+=(c^48)<<cnt,cnt++,c=getchar();
    return (bit){x,cnt};
}//同时得出两个整数
vector<bit> INS[N],DEL[N];//使用向量
void update(int k,int x){
if (!tree[k].tag) tree[k].x+=x,tree[k].lazy+=x;
}//更新操作
void down(int k)
{
    if (!tree[k].ch[0]) tree[k].ch[0]=++cnt;
    update(tree[k].ch[0],tree[k].lazy);
    if (!tree[k].ch[1]) tree[k].ch[1]=++cnt;
    update(tree[k].ch[1],tree[k].lazy);
    tree[k].lazy=0; 
}//push_down操作，注意lazytag的使用
void ins(int &k,bit x,int p)
{
    if (!k) k=++cnt;
    if (p==x.n) {update(k,1),tree[k].tag++;return;}
    if (tree[k].lazy) down(k);
    ins(tree[k].ch[(x.x&(1<<p))>0],x,p+1);
}//插入操作
void del(int &k,bit x,int p)
{
    if (!k) k=++cnt;
    if (p==x.n) {tree[k].tag--,update(k,1);return;}
    if (tree[k].lazy) down(k);
    del(tree[k].ch[(x.x&(1<<p))>0],x,p+1);
}//删除操作
int query(int k,bit x,int p)
{
    if (!k) return 0;
    if (p==x.n) return tree[k].x;
    if (tree[k].lazy) down(k);
    return query(tree[k].ch[(x.x&(1<<p))>0],x,p+1);
}//查询操作
//模板
int main()
{
    n=read(),m=read();
    for (int i=1;i<=n;i++)
    {
        char c=getc();if (c=='A') q[i].op=1;else q[i].op=-1;
        q[i].ip=gettwo();
    }
    for (int i=1;i<=m;i++)
    {
        bit x=gettwo();x.id=i;
        DEL[read()].push_back(x);
        INS[read()].push_back(x);
    }
    for (int i=1;i<=n;i++)
    {
        if (q[i].op==1) ins(root,q[i].ip,0);else del(root,q[i].ip,0);
        for (int j=0;j<INS[i].size();j++) ans[INS[i][j].id]+=query(root,INS[i][j],0); //插入
        for (int j=0;j<DEL[i].size();j++) ans[DEL[i][j].id]-=query(root,DEL[i][j],0);//删除
    }
    for (int i=1;i<=m;i++) printf("%d\n",ans[i]);//输出
    return 0;
}
```


---

## 作者：Eric20521 (赞：2)

https://www.luogu.com.cn/problem/P5460

首先发现复杂度长度相关，这样一来如果询问只有一个 ip 地址就很简单了，基本上随便做做……

所以考虑如何同时做多个 ip 地址。要想一起维护势必要找到一些相似或相同的东西合并到一起，而 匹配 过程只与前缀相关，所以将维护 ip 地址转化为维护前缀。加上 **01 串**，**前缀**，**最长匹配** 这样的字眼的提示，不难想到使用 trie 树来维护。

再看另一方面，规则的集合始终在改变，而每个询问的时间段也不同，所以考虑将规则打入数据结构，按时间顺序维护每一个时刻的状态，询问自然变成了求解前缀和。

然后就是是核心部分，什么情况会使匹配变动，即影响答案？

1. 加入新规则，新规比当前匹配的规则长且能匹配

2. 删去正在被匹配的规则

考虑这两种情况在 trie 上的表现：

影响的均是结尾 在 **操作规则的结尾** 与 **操作规则结尾往下的第一个结尾** 之间的 全部节点。全部 +1 。

注意：这些节点构成的是许多条从操作规则结尾出发向下的有重叠的链。或者说是 trie 树上的一个**区间**

另一方面询问是 ip 地址的结尾节点在相应时刻的值。

使用 **区间 tag 加法**  的方式可以解决这个问题。

这道题的思路大体到这里就结束了，还是不太好想的。可以开始考虑实现上的细节了。

对于 trie 上的节点，维护常规的 son0, son1, end_tag 以及节点的答案 cnt 与加法 tag : add_tag 。

动态开点，pushd 的时候若没有孩子需新建子节点。若子节点有 end_tag 就不需要将 add_tag 传递下去。

代码：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#define maxn 100005
#define maxq 100005

using namespace std;
int n,q;
string s[maxn];
int op[maxn];

vector<int> e[maxn];
string ip[maxn];
int ansl[maxq],ansr[maxq];

struct node{
	node *son[2];
	int add_tag;
	bool end_tag;
	int cnt;
}pool[2000006],*rt;
int pool_top=0;

node* newnode(){
	return pool + (++pool_top);
}

void pushd(node *p){
	if(!p->son[0]) p->son[0] = newnode();
	if(!p->son[1]) p->son[1] = newnode();
	
	if( p->son[0]->end_tag == 0 ) p->son[0]->add_tag += p->add_tag;
	if( p->son[1]->end_tag == 0 ) p->son[1]->add_tag += p->add_tag;
	
	p->cnt += p->add_tag;
	p->add_tag=0;
	return ;
}

void add(string s,int op){
	int x; node* p=rt;
	for(int i=0;i<s.length();i++){
		x=s[i]-'0';
		pushd(p);
		
		p=p->son[x];
		
		if(i==s.length()-1) {
			p->end_tag+=op;
			++ p->add_tag;
		}
	}
	return ;
}

int query(string s){
	int x,cnt=0; node *p=rt;
	for(int i=0;i<s.length();i++){
		x=s[i]-'0';
		if( ! p->son[x] ) return p->cnt + p->add_tag; 
		pushd(p);
		
		p=p->son[x];
		if(i==s.length()-1) return p->cnt + p->add_tag;
	}
}

int main(){
	cin>>n>>q;
	
	string tp;
	for(int i=1;i<=n;i++){
		cin>>tp>>s[i];
		if(tp=="Add") op[i]=1;
		else op[i]=-1;
	}
	
	int l,r;
	for(int i=1;i<=q;i++){
		cin>>ip[i]>>l>>r;
		e[l].push_back(i);
		e[r].push_back(i);
	}
	
	rt = newnode();
	
	memset(ansl,-1,sizeof(ansl));
	for(int i=1;i<=n;i++){
		add(s[i],op[i]);
		
		for(int k=0;k<e[i].size();k++){
			int id=e[i][k];
			
			int cnt=query(ip[id]);
			if(ansl[id]==-1) ansl[id]=cnt;
			else ansr[id]=cnt;
		}
	}
	
	for(int i=1;i<=q;i++){
		cout<<ansr[i]-ansl[i]<<endl;
	}
	
	return 0;
}
```


---

## 作者：XuYueming (赞：1)

## 前言

来个不一样的做法，用到了 Trie 树和主席树，并且是可爱的在线算法。

[更好的体验](https://www.cnblogs.com/XuYueming/p/18207231)。

## 题目分析

对于一个查询 $\texttt{ip}$，只考虑所有前缀字符串规则。以时间建里横轴，匹配长度为纵轴，建出坐标系。易知坐标系中有 $\Theta(n)$ 条线段。对于某一时刻 $t$，根据题意，生效的匹配就是越过 $t$ 的纵坐标最大的那条线段对应的前缀。用样例画张图吧。

![](https://cdn.luogu.com.cn/upload/image_hosting/aucxpfxe.png)

红色的线代表每一个时刻生效的匹配，绿色框内就是发生变化的时刻，分别是第 $3$ 次操作后，第 $4$ 次操作后，第 $5$ 次操作后。

考虑使用 01-Trie 解决前缀。从根节点往下一直到匹配不上，每次将这个前缀出现的所有时段赋值为这个前缀的长度，就得到了红色的折线。最后查询 $[l, r]$ 内红色的线的纵坐标变化了多少次。

这个非常线段树啊，区间覆盖，合并信息也很容易，或者用珂朵莉树也可以。但是，直接这样做时间上是错误的，为什么？因为枚举这个前缀出现的所有时段是 $\Theta(n)$ 的，可以轻松卡到 $\Theta(nq \log n)$。但是，原数据太水了，可以见[这个帖子](https://www.luogu.com.cn/discuss/825196)。

那么，做法呼之欲出了，预处理的时候把线段树可持久化就行了。但是要注意内存回收，注意结构体内存对齐，或者使用 `#pragma pack(1)`，空间有些紧的。

这个算法时间复杂度是 $\Theta((n + q)(w + \log n))$，空间复杂度是 $\Theta(n (w + \log n))$。

## 代码

略去了快读。

```cpp
// #pragma GCC optimize(3)
// #pragma GCC optimize("Ofast", "inline", "-ffast-math")
// #pragma GCC target("avx", "sse2", "sse3", "sse4", "mmx")
#include <iostream>
#include <cstdio>
#define debug(a) cerr << "Line: " << __LINE__ << " " << #a << endl
#define print(a) cerr << #a << "=" << (a) << endl
#define file(a) freopen(#a".in", "r", stdin), freopen(#a".out", "w", stdout)
#define main Main(); signed main(){ return ios::sync_with_stdio(0), cin.tie(0), Main(); } signed Main
using namespace std;

#include <vector>
#include <bitset>

int n, q;

struct node{
	int son[2];
	vector<pair<int, int> > tim;
} tree[100010 * 20];
int tot;

void insert(char str[], int timer){
	int now = 0;
	for (int i = 0; str[i]; ++i){
		int t = str[i] - '0';
		if (!tree[now].son[t]) tree[now].son[t] = ++tot;
		now = tree[now].son[t];
	}
	tree[now].tim.push_back({timer, n});
}

void erase(char str[], int timer){
	int now = 0;
	for (int i = 0; str[i]; ++i){
		int t = str[i] - '0';
		now = tree[now].son[t];
	}
	int s = tree[now].tim.back().first;
	tree[now].tim.pop_back();
	tree[now].tim.push_back({s, timer});
}

struct President_Segment_Tree{
	struct node{
		int lson, rson;
		int val, lval, rval;
	};
	static node tree[200010 * 80];
	static int tot;
	static bitset<200010 * 80> tag;
	
	static inline void init(){
		tot = 0;
	}
	
	static inline int newNode(){
		int res = ++tot;
		tree[res] = {0, 0, 0, 0, 0};
		return res;
	}
	
	static inline int copyNode(int idx){
		int res = newNode();
		return tree[res] = tree[idx], tag[res] = tag[idx], res;
	}
	
	static inline void pushup(int idx){
		tree[idx].lval = tree[tree[idx].lson].lval;
		tree[idx].rval = tree[tree[idx].rson].rval;
		tree[idx].val = tree[tree[idx].lson].val + tree[tree[idx].rson].val + (tree[tree[idx].lson].rval != tree[tree[idx].rson].lval);
	}
	
	static inline void pushtag(int idx, int v){
		tag.set(idx);
		tree[idx].lval = tree[idx].rval = v;
		tree[idx].val = 0;
	}
	
	static inline void pushdown(int idx){
		if (!tag[idx]) return;
		pushtag(tree[idx].lson = copyNode(tree[idx].lson), tree[idx].lval);
		pushtag(tree[idx].rson = copyNode(tree[idx].rson), tree[idx].lval);
		tag.reset(idx);
	}
	
	int root[100010 * 20];
	
	void build(int &idx, int l, int r){
		idx = newNode();
		if (l == r) return;
		int mid = (l + r) >> 1;
		build(tree[idx].lson, l, mid);
		build(tree[idx].rson, mid + 1, r);
		pushup(idx);
	}
	
	void modify(int &idx, int trl, int trr, int l, int r, int val){
		if (trl > r || trr < l) return;
		idx = copyNode(idx);
		if (l <= trl && trr <= r) return pushtag(idx, val);
		pushdown(idx);
		int mid = (trl + trr) >> 1;
		modify(tree[idx].lson, trl, mid, l, r, val);
		modify(tree[idx].rson, mid + 1, trr, l, r, val);
		pushup(idx);
	}
	
	struct Q{ int val, lval, rval; };
	
	Q add(const Q & a, const Q & b){
		if (a.val == -1) return b;
		if (b.val == -1) return a;
		return {
			a.val + b.val + (a.rval != b.lval),
			a.lval, b.rval
		};
	}
	
	Q query(int idx, int trl, int trr, int l, int r){
		if (trl > r || trr < l) return {-1, 0, 0};
		if (l <= trl && trr <= r) return {tree[idx].val, tree[idx].lval, tree[idx].rval};
		pushdown(idx);
		int mid = (trl + trr) >> 1;
		return add(query(tree[idx].lson, trl, mid, l, r), query(tree[idx].rson, mid + 1, trr, l, r));
	}
} yzh;

President_Segment_Tree::node President_Segment_Tree::tree[200010 * 80];
int President_Segment_Tree::tot;
bitset<200010 * 80> President_Segment_Tree::tag;

void dfs(int now, int dpt = 0){
	for (const auto & [s, e] : tree[now].tim){
		yzh.modify(yzh.root[now], 1, n, s, e, dpt);
	}
	tree[now].tim.clear();
	tree[now].tim.shrink_to_fit();
	if (tree[now].son[0]){
		yzh.root[tree[now].son[0]] = yzh.root[now];
		dfs(tree[now].son[0], dpt + 1);
	}
	if (tree[now].son[1]){
		yzh.root[tree[now].son[1]] = yzh.root[now];
		dfs(tree[now].son[1], dpt + 1);
	}
}

signed main(){
	read(n, q);
	for (int i = 1; i <= n; ++i){
		static char op[5], str[50];
		read(op, str);
		if (*op == 'A') insert(str, i);
		else erase(str, i - 1);
	}
	dfs(0);
	for (int i = 1, l, r; i <= q; ++i){
		static char str[50];
		read(str, l, r);
		int now = 0;
		for (int j = 0; str[j]; ++j){
			int t = str[j] - '0';
			if (!tree[now].son[t]) break;
			now = tree[now].son[t];
		}
		write(yzh.query(yzh.root[now], 1, n, l, r).val, '\n');
	}
	return 0;
}
```

---

## 作者：Add_Catalyst (赞：0)

# P5460 [BJOI2016] IP地址 题解

---



## 知识点

Trie（字典树），前缀和、差分思想。

---

## 题意分析

就是给定 $n$ 个加入与删除 01 字符串的更新，以及 $Q$ 个询问：问一个 01 字符串（长度固定为 $32$）在 $(l,r]$ 这段时间内，最长前缀变化了几次。

---

## 思路分析

操作和询问明显都可以先离线下来，然后紧接着处理：我们把询问拆成两个，用前缀和、差分思想，减一下就得到了答案。

那么我们如何更新答案呢？字典树好像可以，但好像又不行。

我们从题目性质入手，在加入一个 01 字符串的时候（规则生效），我们往字典树中加入，影响的只有最后一个点的子树，那我们直接打一个标记，表示整颗子树加了一个 1，但这样对吗？肯定不对啊 ~~（傻子都知道）~~，我们还要考虑比它长的前缀，所以我们在标记下传的时候判断一下后面有没有更长的，没有再下传即可。那么删除（规则失效）同理。

最后查询也非常方便。

时间复杂度 $O(w(n+q))$，其中 $w$ 表示 01 字符串的长度，$w = 32$。

---

## CODE

```cpp
#include<bits/stdc++.h>
#define uint unsigned int
#define FOR(i,a,b) for(register int i=(a);i<=(b);++i)
#define DOR(i,a,b) for(register int i=(a);i>=(b);--i)
#define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0);return Main();}signed Main
using namespace std;
constexpr int N=1e5+10;
int n,Q;
int ans[N];
uint num[N];
vector<int> l[N],r[N];
struct Update{
	int opt,len;
	uint x;
	void Scan(){
		string s;
		cin>>s,opt=(s[0]=='A'?1:-1),cin>>s,len=s.size();
		FOR(i,0,len-1)x+=(s[i]^'0')<<i;
	}
}up[N];
class Trie {
	private:
#define ls (tr[p][0])
#define rs (tr[p][1])
		int tot;
		struct node {
			int sum,tag,val;
			int son[2];
			int &operator [](bool i) {
				return son[i];
			}
		} tr[N<<5];
		void push_down(int p,int tag) {
			tr[p].tag+=tag,tr[p].sum+=tag;
		}
		void Push_down(int p) {
			if(!ls)ls=++tot;
			if(!rs)rs=++tot;
			if(tr[p].tag) {
				if(!tr[ls].val)push_down(ls,tr[p].tag);
				if(!tr[rs].val)push_down(rs,tr[p].tag);
				tr[p].tag=0;
			}
		}
		void Clear(){
			tr[tot=1]={0,0,0,{0,0}};
		}
		void Update(int p,uint x,int len,int dep,int val) {
			return dep>=len?tr[p].val+=val,push_down(p,1):(Push_down(p),Update(tr[p][x&1],x>>1,len,dep+1,val));
		}
		int Query(int p,uint x,int len,int dep) {
			return dep>=len?tr[p].sum:(Push_down(p),Query(tr[p][x&1],x>>1,len,dep+1));
		}
#undef ls
#undef rs
	public:
		void clear(){
			Clear();
		}
		void update(uint x,int len,int val) {
			Update(1,x,len,0,val);
		}
		int query(uint x) {
			return Query(1,x,32,0);
		}
} tr;
signed main(){
	cin>>n>>Q,tr.clear();
	FOR(i,1,n)up[i].Scan();
	FOR(i,1,Q){
		string s;int L,R;cin>>s>>L>>R,l[L].push_back(i),r[R].push_back(i);
		FOR(j,0,31)num[i]+=(s[j]^'0')<<j;
	}
	FOR(i,1,n){
		tr.update(up[i].x,up[i].len,up[i].opt);
		for(int x:l[i])ans[x]-=tr.query(num[x]);
		for(int x:r[i])ans[x]+=tr.query(num[x]);
	}
	FOR(i,1,Q)cout<<ans[i]<<endl;
	return 0;
}
```

我这里把 01 字符串转成了 `unsigned int`，这样 ~~我看着舒服~~ 方便一点。

---

---


# [BJOI2015] 骑士的旅行

## 题目背景

在一片古老的土地上，有一个繁荣的文明。

这片大地几乎被森林覆盖，有N座城坐落其中。巧合的是，这N座城由恰好N-1条双向道路连接起来，使得任意两座城都是连通的。也就是说，这些城形成了树的结构，任意两座城之间有且仅有一条简单路径。

在这个文明中，骑士是尤其受到尊崇的职业。任何一名骑士，都是其家族乃至家乡的荣耀。Henry从小就渴望成为一名能守护家乡、驱逐敌人的骑士。勤奋训练许多年后，Henry终于满18岁了。他决定离开家乡，向那些成名已久的骑士们发起挑战！


## 题目描述

根据Henry的调查，大陆上一共有 $M$ 名受封骑士，不妨编号为 $1$ 到 $M$。第 $i$ 个骑士居住在城 $P_i$，武力值为 $F_i$。

Henry计划进行若干次旅行，每次从某座城出发沿着唯一的简单路径前往另一座城，同时会挑战路线上武力值最高的 $K$ 个骑士（Henry的体力有限，为了提高水平，当然要挑战最强的骑士）。如果路线上的骑士不足 $K$ 人，Henry会挑战遇到的所有人。

每次旅行前，可能会有某些骑士的武力值或定居地发生变化，Henry自然会打听消息，并对计划做出调整。

为了在每次旅行时做好充分准备，Henry希望你能帮忙在每次旅行前计算出这条路线上他将挑战哪些对手。

## 说明/提示

100%的数据中，$1 \leq N,~M \leq 40,000,~1 \leq Ui,~Vi,~Pi \leq N,~1\leq Q \leq 80,000,~1 \leq K \leq 20$，旅行次数不超过 40,000 次，武力值为不超过1,000的正整数。

## 样例 #1

### 输入

```
5  
1 2  
1 3  
2 4  
2 5  
4  
10 1  
6 1  
14 5  
7 3  
5 3  
1 2 3  
1 5 3  
1 4 4  
2 1 4  
1 2 3```

### 输出

```
10 7 6  
14 10 7  
-1  
7 6```

# 题解

## 作者：ykyyyy (赞：8)

这个题其实~~并没有~~做法显然

首先我们把操作抽象为3种

1 .查询路径上的第k大值

2 .删除某个节点的某个权值

3 .给某个节点添加一个权值

那么骑士搬家和武力值修正就统一了

那么非常自然的我们就可以想到用树链剖分+线段树来维护,线段树的每个节点存的就是相应区间的前k大值(前k个,即每个节点开一个数组).至于原图上的每个节点有多个权值怎么处理呢?非常简单,我们对于每个节点一个multiset就可以解决了

下面直接贴代码,应该不是很难懂,变量名应该还是蛮清晰的

```cpp
#include <bits/stdc++.h>
#define LS tree[rt].son[0]
#define RS tree[rt].son[1]
using namespace std;

const int N=1e5+5;

int n,m,root,q,k;

int power[N];
multiset<int,greater<int> > s[N];
multiset<int>::iterator it;

struct Tree {
	int rank[25];
	int son[2];
} tree[N*20];
int tot;

bool cmp(int a,int b) {
	return a>b;
}

void push_up(int rt) {
	tree[rt].rank[0]=0;
	int j=1;
	for(int i=1; i<=tree[RS].rank[0]; i++) {
		for(; j<=tree[LS].rank[0]&&tree[LS].rank[j]>tree[RS].rank[i]; j++) {
			tree[rt].rank[++tree[rt].rank[0]]=tree[LS].rank[j];
			if(tree[rt].rank[0]>=k) return;
		}
		tree[rt].rank[++tree[rt].rank[0]]=tree[RS].rank[i];
		if(tree[rt].rank[0]>=k) return;
	}
	for(; j<=tree[LS].rank[0]; j++) {
		tree[rt].rank[++tree[rt].rank[0]]=tree[LS].rank[j];
		if(tree[rt].rank[0]>=k) return;
	}
	return;
}

void build(int &rt,int l,int r) {
	if(!rt) rt=++tot;
	if(l>=r) {
		for(it=s[l].begin(); it!=s[l].end(); it++) {
			tree[rt].rank[++tree[rt].rank[0]]=*it;
			if(tree[rt].rank[0]>=k) break;
		}
		return;
	}
	int mid=l+r>>1;
	build(LS,l,mid);
	build(RS,mid+1,r);
	push_up(rt);
}

void modify(int &rt,int l,int r,int pos,int val) {
	if(!rt) rt=++tot;
	if(l>=r) {
		tree[rt].rank[0]=0;
		if(val<0) {
			s[pos].erase(s[pos].find(-val));
		} else s[pos].insert(val);
		for(it=s[pos].begin(); it!=s[pos].end(); it++) {
			tree[rt].rank[++tree[rt].rank[0]]=*it;
			if(tree[rt].rank[0]>=k) break;
		}
		return;
	}
	int mid=l+r>>1;
	if(pos<=mid) modify(LS,l,mid,pos,val);
	else modify(RS,mid+1,r,pos,val);
	push_up(rt);
}

void query(int rt,int l,int r,int ll,int rr) {
	if(ll<=l&&rr>=r) {
		for(int i=1; i<=tree[rt].rank[0]; i++)
			power[++power[0]]=tree[rt].rank[i];
		return;
	}
	int mid=l+r>>1;
	if(ll<=mid) query(LS,l,mid,ll,rr);
	if(rr>mid) query(RS,mid+1,r,ll,rr);
}

struct Edge {
	int v,next;
} edge[N<<1];
int head[N],cnt;
void add(int u,int v) {
	edge[++cnt].v=v;
	edge[cnt].next=head[u];
	head[u]=cnt;
}

int deep[N],id[N],top[N],son[N],siz[N],parent[N],tim;

void dfs1(int u,int fa) {
	deep[u]=deep[fa]+1;
	parent[u]=fa;

	siz[u]=1;
	for(int i=head[u]; i; i=edge[i].next) {
		int v=edge[i].v;
		if(v==fa) continue;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]]) son[u]=v;
	}
}

void dfs2(int u,int tp) {
	id[u]=++tim;
	top[u]=tp;
	if(son[u]) dfs2(son[u],tp);
	for(int i=head[u]; i; i=edge[i].next) {
		int v=edge[i].v;
		if(v==son[u]||deep[v]<deep[u]) continue;
		dfs2(v,v);
	}
}

void treequery(int x,int y) {
	power[0]=0;
	while(top[y]!=top[x]) {
		if(deep[top[y]]>deep[top[x]]) swap(x,y);
		query(root,1,n,id[top[x]],id[x]);
		x=parent[top[x]];
	}
	if(deep[y]>deep[x]) swap(x,y);
	query(root,1,n,id[y],id[x]);
	if(power[0]==0) {
		puts("-1");
		return ;
	}
	sort(power+1,power+power[0]+1,cmp);
	for(int i=1; i<=min(power[0],k); i++) printf("%d ",power[i]);
	puts("");
	return;
}

int loc[N],w[N];



int main() {
//	freopen("out.txt","w",stdout);
	scanf("%d",&n);
	for(int i=1,u,v; i<n; i++) {
		scanf("%d%d",&u,&v);
		add(u,v);
		add(v,u);
	}
	dfs1(1,0);
	dfs2(1,1);
	scanf("%d",&m);
	for(int i=1; i<=m; i++) {
		scanf("%d%d",&w[i],&loc[i]);
		s[id[loc[i]]].insert(w[i]);
	}
	scanf("%d%d",&q,&k);
	build(root,1,n);
	for(int i=1,t,x,y; i<=q; i++) {
		scanf("%d%d%d",&t,&x,&y);
		if(t==1) treequery(x,y);
		if(t==2) {
			modify(root,1,n,id[loc[x]],-w[x]);
			loc[x]=y;
			modify(root,1,n,id[loc[x]],w[x]);
		}
		if(t==3) {
			modify(root,1,n,id[loc[x]],-w[x]);
			w[x]=y;
			modify(root,1,n,id[loc[x]],w[x]);
		}
	}
	return 0;
}

/*
5
1 2
1 3
2 4
2 5
4
10 1
6 1
14 5
7 3
6 3
1 2 3
1 5 3
1 4 4
3 1 4
2 1 4
1 2 3
*/
```
这里我还脑补了另外一种做法,权当抛砖引玉~~因为我没有敲过,不知道能不能过~~

如果不带修的话我们的标准做法就是主席树上树,那带修怎么办呢?

我们可以想到带修主席树,即树状数组套权值线段树.那么如何将其迁移到树上呢?我们可以考虑dfn序.

考虑我们如果使用树状数组套权值线段树维护一段序列(就是大家平时做的动
态区间k小/大值),单点修改的影响就是该点以及其以后的所有权值线段树.
对于该题我们对于树上的每个节点维护一颗权值线段树,记录该节点到根节点的信息(就是树上主席树的做法).每个修改操作只会影响以该节点为根的子树的所有权值线段树的信息.那么与普通树状数组套权值线段树的区别就在这里.我们每次修改的影响只有子树,因为子树在dfn序上表现为一段连续的区间,那么我们也就能处理了.有兴趣的可以敲一敲,看一看

---

## 作者：2huk (赞：4)

- 给定一颗 $n$ 个节点的树。有 $m$ 个骑士，最开始第 $i$ 个骑士在 $p_i$ 节点上，武力值为 $f_i$。接下来有 $q$ 次操作 $(t_i, x_i, y_i)$：
	- $t_i = 1$，输出树上 $x_i, y_i$ 路径上的前 $k$ 大骑士的武力值。
   - $t_i = 2$，$p_{x_i} \gets y_i$；
   - $t_i = 3$，$f_{x_i} \gets y_i$。
- $n, m \le 4 \times 10^4$，$q \le 8 \times 10^4$，$\color{red}k \le 20$。

显然需要树链剖分，将树上问题转化成序列上问题。

发现 $k$ 很小，所以我们可以用线段树维护前 $k$ 大，并用 $\mathcal O(k)$ 的时间复杂度 pushup。

注意可用 `multiset` 存储每个叶子节点上的骑士编号和骑士武力值。

---

## 作者：registerGen (赞：3)

[可能更好的阅读体验](https://registergen.github.io/post/solution-luogu-5478/)

震惊！我省省选竟然出板题！

# Solution

容易想到，直接维护区间最大的 $k$ 个数即可。pushup 就直接暴力。

为了方便，我们开 $n$ 个 `std::vector` $a$，$a_i$ 表示居住在第 $i$ 个城市的人的集合。显然，我们要根据 $a_i$ 来构建叶子结点。

修改就暴力重构叶子结点。但是我们不能暴力在 $a$ 中找到想改的东西。于是我们把 $a$ 换成 `std::multiset` 即可。

当然，因为这个题是在树上搞事，所以我们要用树剖。

# Code

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<functional> // for std::greater
#include<set>

const int N=4e4;

struct Edge{int to,nxt;}e[N*2+10];int head[N+10],tote=1;
inline void addEdge(int u,int v){e[++tote].to=v;e[tote].nxt=head[u];head[u]=tote;}

int n,m,q,k,f[N+10],p[N+10]; // 含义同题面
std::multiset<int,std::greater<int> > a[N+10];
int fa[N+10],siz[N+10],son[N+10],dep[N+10],dfn[N+10],rk[N+10],top[N+10],cnt; // 用于树剖的 8 个变量

// segment tree
struct SegTree{
	struct Node{
		int res[25];
		Node(){memset(res,0,sizeof(res));}
		inline int& operator[](int i){return res[i];}
	};

	Node t[N*4+10];

#define ls(x) (x<<1)
#define rs(x) (x<<1|1)

	// pushup（暴力合并）
	inline Node pushUp(Node L,Node R){
		Node res;
		int tmp[45]={0},tott=0;
		for(int i=1;i<=k;i++)
			tmp[++tott]=L[i],tmp[++tott]=R[i];
		std::sort(tmp+1,tmp+tott+1,std::greater<int>());
		for(int i=1;i<=k;i++)
			res[i]=tmp[i];
		return res;
	}

	// 建树
	void build(int i,int l,int r){
		if(l==r){
			int cnt=0;
			// 暴力取 std::multiset 中最大的 k 个数 
			for(std::multiset<int,std::greater<int> >::iterator it=a[rk[l]].begin();it!=a[rk[l]].end()&&cnt<k;it++)
				t[i][++cnt]=*it;
			return;
		}
		int mid=(l+r)>>1;
		build(ls(i),l,mid);
		build(rs(i),mid+1,r);
		t[i]=pushUp(t[ls(i)],t[rs(i)]);
	}

	// 将第 rk[pos] 个城市的武力值为 x 的人的武力值改为 y
	// 注意：只能改一个
	// x = -1 时表示增加一个武力值为 y 的人
	// y = -1 时表示减少一个武力值为 x 的人
	void modify(int i,int l,int r,int pos,int x,int y){
		if(l==r){
			if(x!=-1)a[rk[pos]].erase(a[rk[pos]].find(x)); // 注意是 rk[pos] 不是 pos！
			if(y!=-1)a[rk[pos]].insert(y);
			t[i]=Node();
			int cnt=0;
			// 暴力重构
			for(std::multiset<int,std::greater<int> >::iterator it=a[rk[pos]].begin();it!=a[rk[pos]].end()&&cnt<k;it++)
				t[i][++cnt]=*it;
			return;
		}
		int mid=(l+r)>>1;
		if(pos<=mid)modify(ls(i),l,mid,pos,x,y);
		if(pos>mid) modify(rs(i),mid+1,r,pos,x,y);
		t[i]=pushUp(t[ls(i)],t[rs(i)]);
	}

	// 查询前 k 大
	Node query(int i,int l,int r,int ql,int qr){
		if(ql<=l&&r<=qr)return t[i];
		int mid=(l+r)>>1;
		if(qr<=mid)return query(ls(i),l,mid,ql,qr);
		if(ql>mid) return query(rs(i),mid+1,r,ql,qr);
		return pushUp(query(ls(i),l,mid,ql,qr),query(rs(i),mid+1,r,ql,qr));
	}

#undef ls
#undef rs

}t;

// 树剖基本操作 1
void DFS1(int u,int _fa){
	fa[u]=_fa;
	dep[u]=dep[_fa]+1;
	siz[u]=1;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==_fa)continue;
		DFS1(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]])son[u]=v;
	}
}

// 树剖基本操作 2
void DFS2(int u,int _fa,int _top){
	dfn[u]=++cnt;
	rk[cnt]=u;
	top[u]=_top;
	if(son[u])DFS2(son[u],u,_top);
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==_fa||v==son[u])continue;
		DFS2(v,u,v);
	}
}

// 树剖基本操作 3（树上查询）
SegTree::Node query(int u,int v){
	SegTree::Node res;
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])std::swap(u,v);
		res=t.pushUp(res,t.query(1,1,n,dfn[top[u]],dfn[u]));
		u=fa[top[u]];
	}
	if(dfn[u]>dfn[v])std::swap(u,v);
	res=t.pushUp(res,t.query(1,1,n,dfn[u],dfn[v]));
	return res;
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int u,v;scanf("%d%d",&u,&v);
		addEdge(u,v);addEdge(v,u);
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",f+i,p+i);
		a[p[i]].insert(f[i]);
	}
	scanf("%d%d",&q,&k);
	DFS1(1,0),DFS2(1,0,0),t.build(1,1,n);
	while(q--){
		int opt,x,y;
		scanf("%d%d%d",&opt,&x,&y);
		if(opt==1){
			SegTree::Node res=query(x,y);
			int ans[25]={0},tota=0;
			for(int i=1;i<=k;i++)
				if(res[i])ans[++tota]=res[i];
			if(tota==0){puts("-1");continue;}
			std::sort(ans+1,ans+tota+1,std::greater<int>());
			for(int i=1;i<=tota;i++)
				printf("%d%c",ans[i]," \n"[i==tota]);
		}
		if(opt==2){
			t.modify(1,1,n,dfn[p[x]],f[x],-1);
			p[x]=y; // 别忘了改这个
			t.modify(1,1,n,dfn[p[x]],-1,f[x]);
		}
		if(opt==3){
			t.modify(1,1,n,dfn[p[x]],f[x],y);
			f[x]=y; // 别忘了改这个
		}
	}
	return 0;
}
```

---

## 作者：IC0CI (赞：1)

## 解决办法

### 题面解析

要求动态维护一棵树，对于这棵树：
1. 查询树上一条链中所有节点中的值的前 $k$ 大（一个节点可能有多个值）。
2. 删除某个节点的某个值。
3. 添加某个值到某个节点。

### 分析

+ 显然需要进行树链剖分，动态维护树就变成动态维护数组了，那么问题就转化为查询一段区间中前 $k$ 大的数。

+ 单点修改、区间查询，问题就变成维护线段树了。

+ 发现：“查询一段区间中前 $k$ 大的数。”其实和维护区间最大值是类似的。具体地，在线段树 pushup 的过程中通过归并排序的思想将左儿子和右儿子中的前 $k$ 大存入节点 $p$ 中。

### 具体实现

+ 树剖线段树

在维护线段树的时候有一个小细节：叶子结点中的所有元素全部要维护，否则第一个点过不去。

如果暴力插入排序和删除在极端情况下会退化，所以可以使用 multiset 对原始数据进行维护，每次更新原始数据再存入线段树中。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 40004;

int rd()
{
    int x = 0,w = 1;
    char ch = 0;
    while(ch < '0' || ch > '9')
    {
        if(ch == '-') w = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
    {
        x = x * 10 + (ch - '0');
        ch = getchar();
    }
    return x * w;
}

int n,m,q,k,f[N],p[N];
struct node
{
    int num[25] = {0};
    int cnt = 0;
};
vector<int> adj[N];

int dep[N],siz[N],son[N],pre[N];
void dfs1(int u,int fa)
{
    dep[u] = dep[fa] + 1;
    siz[u] = 1;
    pre[u] = fa;
    for(auto v : adj[u])
    {
        if(v == fa) continue;
        dfs1(v,u);
        siz[u] += siz[v];
        if(siz[v] > siz[son[u]]) son[u] = v;
    }
}

int top[N],id[N],tot;
void dfs2(int u,int topc)
{
    top[u] = topc;
    id[u] = ++tot;
    if(!son[u]) return;
    dfs2(son[u],topc);
    for(auto v : adj[u])
    {
        if(v == pre[u] || v == son[u]) continue;
        dfs2(v,v);
    }
}

multiset<int,greater<int> > a[N];

namespace sgt
{
#define ls (p << 1)
#define rs (ls | 1)
#define mid ((pl + pr) >> 1)
node t[N << 2];

node merge(node l,node r)
{
    node res;
    int i = 0,j = 0;
    while(i < l.cnt && j < r.cnt && res.cnt < 20)
    {
        if(l.num[i + 1] > r.num[j + 1]) res.num[++res.cnt] = l.num[++i];
        else res.num[++res.cnt] = r.num[++j];
    }
    while(i < l.cnt && res.cnt < 20) res.num[++res.cnt] = l.num[++i];
    while(j < r.cnt && res.cnt < 20) res.num[++res.cnt] = r.num[++j];
    return res;
}

void pu(int p) {t[p] = merge(t[ls],t[rs]);}

void build(int p,int pl,int pr)
{
    if(pl == pr)
    {
        multiset<int,greater<int> >::iterator it = a[pl].begin();
        t[p].cnt = 0;
        for(int i = 1;i <= 20,it != a[pl].end();i++,it++) t[p].num[i] = *it,t[p].cnt++;
        return;
    }
    build(ls,pl,mid);
    build(rs,mid + 1,pr);
    pu(p);
}

void upd(int p,int pl,int pr,int lr,int d)
{
    if(pl == pr)
    {
        a[pl].insert(d);
        t[p].cnt = 0;
        for(auto v : a[pl])
        {
            t[p].num[++t[p].cnt] = v;
            if(t[p].cnt == 20) break;
        }
        return;
    }
    if(lr <= mid) upd(ls,pl,mid,lr,d);
    if(lr > mid) upd(rs,mid + 1,pr,lr,d);
    pu(p);
}

void del(int p,int pl,int pr,int lr,int d)
{
    if(pl == pr)
    {
        a[pl].erase(a[pl].lower_bound(d));
        t[p].cnt = 0;
        for(auto v : a[pl])
        {
            t[p].num[++t[p].cnt] = v;
            if(t[p].cnt == 20) break;
        }
        return;
    }
    if(lr <= mid) del(ls,pl,mid,lr,d);
    if(lr > mid) del(rs,mid + 1,pr,lr,d);
    pu(p);
}

node qry(int p,int pl,int pr,int l,int r)
{
    if(l <= pl && pr <= r)
    {
        return t[p];
    }
    node res;
    if(l <= mid) res = merge(res,qry(ls,pl,mid,l,r));
    if(r > mid) res = merge(res,qry(rs,mid + 1,pr,l,r));
    return res;
}

};

void qry(int u,int v)
{
    node res;
    while(top[u] != top[v])
    {
        if(dep[top[u]] < dep[top[v]]) swap(u,v);
        res = sgt::merge(res,sgt::qry(1,1,n,id[top[u]],id[u]));
        u = pre[top[u]];
    }
    if(dep[u] > dep[v]) swap(u,v);
    res = sgt::merge(res,sgt::qry(1,1,n,id[u],id[v]));
    if(res.cnt == 0) cout << "-1\n";
    else
    {
        int len = min(res.cnt,k);
        for(int i = 1;i <= len;i++) cout << res.num[i] << ' ';
        cout << '\n';
    }
}

signed main()
{
    n = rd();
    for(int i = 1;i < n;i++)
    {
        int u = rd(),v = rd();
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    dfs1(1,0);
    dfs2(1,1);
    m = rd();
    for(int i = 1;i <= m;i++)
    {
        f[i] = rd(),p[i] = rd();
        a[id[p[i]]].insert(f[i]);
    }
    sgt::build(1,1,n);
    q = rd(),k = rd();
    while(q--)
    {
        int opt = rd(),x = rd(),y = rd();
        if(opt == 1) qry(x,y);
        if(opt == 2)
        {
            sgt::del(1,1,n,id[p[x]],f[x]);
            p[x] = y;
            sgt::upd(1,1,n,id[p[x]],f[x]);
        }
        if(opt == 3)
        {
            sgt::del(1,1,n,id[p[x]],f[x]);
            f[x] = y;
            sgt::upd(1,1,n,id[p[x]],f[x]);
        }
    }
    return 0;
}
```

---

## 作者：creation_hy (赞：1)

省流：暴力出奇迹

发现 $k$ 很小，直接树剖套线段树，线段树上每个点用数组维护区间前 $k$ 大值，然后再开 $n$ 个 multiset，修改显然可以拆成插入删除，直接暴力更新 multiset，然后再把它在线段树上对应的点到根的路径更新一遍。

时间复杂度 $O(qk\log^2 n\log k)$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef multiset<int, greater<int>> MS;
const int N = 1.6e5 + 5;
int n, m, q, K, head[N], to[N], nxt[N], etot, num[N];
int a[N], b[N];
inline void link(int u, int v)
{
    to[etot] = v;
    nxt[etot] = head[u];
    head[u] = etot++;
}
MS s[N];
inline void merge(int *f, int *a, int *b)
{
    static int tmp[45];
    int tot = 0;
    for (int i = 1; i <= K; i++)
        tmp[++tot] = a[i], tmp[++tot] = b[i];
    sort(tmp + 1, tmp + 1 + tot, greater<int>());
    memcpy(f + 1, tmp + 1, sizeof(int) * K);
}
struct SegTree
{
    int f[N][25];
    inline int ls(int p) { return p << 1; }
    inline int rs(int p) { return p << 1 | 1; }
    inline void push_up(int p) { merge(f[p], f[ls(p)], f[rs(p)]); }
    inline void update(int p, int l, int r, int x)
    {
        if (l == r)
        {
            memset(f[p], 0, sizeof(f[p]));
            auto it = s[num[l]].begin();
            for (int i = 1; i <= K && it != s[num[l]].end(); i++, it++)
                f[p][i] = *it;
            return;
        }
        int mid = l + r >> 1;
        if (x <= mid)
            update(ls(p), l, mid, x);
        else
            update(rs(p), mid + 1, r, x);
        push_up(p);
    }
    inline void query(int p, int l, int r, int qx, int qy, int *g)
    {
        if (qx <= l && r <= qy)
        {
            merge(g, g, f[p]);
            return;
        }
        int mid = l + r >> 1;
        if (qx <= mid)
            query(ls(p), l, mid, qx, qy, g);
        if (mid < qy)
            query(rs(p), mid + 1, r, qx, qy, g);
    }
} seg;
struct HLD
{
    int id[N], cnt, sz[N], son[N], dep[N], top[N], up[N];
    inline void dfs1(int x, int fa)
    {
        dep[x] = dep[up[x] = fa] + 1, sz[x] = 1;
        for (int i = head[x]; ~i; i = nxt[i])
            if (to[i] != fa)
            {
                dfs1(to[i], x), sz[x] += sz[to[i]];
                if (sz[to[i]] > sz[son[x]])
                    son[x] = to[i];
            }
    }
    inline void dfs2(int x, int fa, int tp)
    {
        num[id[x] = ++cnt] = x, top[x] = tp;
        if (son[x])
            dfs2(son[x], x, tp);
        for (int i = head[x]; ~i; i = nxt[i])
            if (to[i] != fa && to[i] != son[x])
                dfs2(to[i], x, to[i]);
    }
    inline void update(int x) { seg.update(1, 1, n, id[x]); }
    inline void query(int x, int y)
    {
        int f[25];
        memset(f, 0, sizeof(f));
        while (top[x] != top[y])
        {
            if (dep[top[x]] < dep[top[y]])
                swap(x, y);
            seg.query(1, 1, n, id[top[x]], id[x], f);
            x = up[top[x]];
        }
        if (dep[x] > dep[y])
            swap(x, y);
        seg.query(1, 1, n, id[x], id[y], f);
        if (!f[1])
        {
            cout << "-1\n";
            return;
        }
        for (int i = 1; i <= K && f[i]; i++)
            cout << f[i] << ' ';
        cout << '\n';
    }
} hld;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    memset(head, -1, sizeof(head));
    cin >> n;
    for (int i = 1, u, v; i < n; i++)
        cin >> u >> v, link(u, v), link(v, u);
    hld.dfs1(1, 0), hld.dfs2(1, 0, 1);
    cin >> m;
    for (int i = 1, x, k; i <= m; i++)
        cin >> k >> x, s[x].insert(k), a[i] = x, b[i] = k;
    cin >> q >> K;
    for (int i = 1; i <= n; i++)
        hld.update(i);
    while (q--)
    {
        int op, x, y;
        cin >> op >> x >> y;
        if (op == 1)
            hld.query(x, y);
        else if (op == 2)
        {
            s[a[x]].erase(s[a[x]].find(b[x])), hld.update(a[x]);
            s[y].insert(b[x]), hld.update(y), a[x] = y;
        }
        else
        {
            s[a[x]].erase(s[a[x]].find(b[x]));
            s[a[x]].insert(y), hld.update(a[x]), b[x] = y;
        }
    }
    return 0;
}
```

---

## 作者：a_small_penguin (赞：1)

第三篇紫题题解！

### 分析

观察题目，发现单单从题目描述上来看十分难处理。应为有 $2$ 个东西要维护。

但当观察数据范围 $1 \le K \le 20$，可以得知这道题上的突破点是 $K$ 上面。

### 处理

考虑进行暴力维护，对于每一个线段树节点和答案使用 `multiset`，因为这个东西可以十分便捷的进行插入、排序、查询和删除操作。其余直接按照树链剖分暴力维护。

### 细节

注意**千万千万千万不能**两个 `multiset` 中的元素直接 `insert` 进一个 `multiset` 中，再一个个弹出去。这样时间复杂度就劣化为近似 $O(qm\log m\log^2n)。$

[详见此贴](https://www.luogu.com.cn/discuss/1091184)。

### code：（码风极丑，因为以为 TLE #1 是被卡常）

```cpp
#include<bits/stdc++.h>
using namespace std;

char *p1,*p2,buf[100009];
#define nc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
inline unsigned int read(){
    unsigned int x=0;
    char ch=nc();
    while(ch<48||ch>57){
        ch=nc();
    }
    while(ch>=48&&ch<=57)
        x=(x << 3) + (x << 1) +ch-48,ch=nc();
    return x;
}

inline void out(unsigned int x) {
    if(x>9)out(x/10);
    putchar('0'+x%10);
}

#define N 40009
#define ls(i) (i<<1)
#define rs(i) ((i<<1)|1)
#define sp(i,j) i^=j,j^=i,i^=j
unsigned int n,m,q,k;
multiset<unsigned int> d[N];
vector<unsigned int> e[N];
unsigned int res, id[N], son[N], fa[N], h[N], top[N], sizee[N], rk[N], f[N], p[N];
struct V{
    multiset<unsigned int> d;
    unsigned int l, r;
    inline V operator+(const V &a) const {
        V c;
        c.l = l, c.r = a.r;
        int cnt = 0;
        for(auto it: a.d) {
        	cnt++;
        	if(cnt <= k) c.d.insert(it);
        	else break;
        }
        cnt = 0;
        for(auto it: d) {
        	cnt++;
        	if(cnt <= k) c.d.insert(it);
        	else break;
        }
        while(c.d.size() > k) c.d.erase(--c.d.end());
        return c;
    }
};
namespace xds{
    V tree[(N << 2) + 1];
    inline void build(const unsigned int &i, const unsigned int &l, const unsigned int &r) {
        tree[i].l = l, tree[i].r = r;
        if(l == r) {
            return;
        }
        const unsigned int mid = (l + r) >> 1;
        build(ls(i), l, mid),build(rs(i), mid + 1, r),tree[i] = tree[ls(i)] + tree[rs(i)];
    }
    inline void change(const unsigned int &i, const unsigned int &x) {
        if(tree[i].l == tree[i].r) {
            return;
        }
        const unsigned int mid = (tree[i].l + tree[i].r) >> 1;
        if(x <= mid) change(ls(i), x);
        else change(rs(i), x);
        tree[i] = tree[ls(i)] + tree[rs(i)];
    }
    inline V ask(const unsigned int &i, const unsigned int &l, const unsigned int &r) {
        if(l <= tree[i].l && tree[i].r <= r) return tree[i];
        const unsigned int mid = (tree[i].l + tree[i].r) >> 1;
        if(l <= mid && mid < r) return ask(ls(i), l, r) + ask(rs(i), l, r);
        if(l <= mid) return ask(ls(i), l, r);
        if(mid < r) return ask(rs(i), l, r);
    }
}
inline void dfs(const unsigned int &u,const unsigned int &faa,const unsigned int &hh) {
    h[u]=hh,fa[u]=faa,sizee[u]=1;
    unsigned cnt=0;
    for(auto to:e[u]) {
        if(to==faa) continue;
        dfs(to,u,hh+1);
        sizee[u]+=sizee[to];
        if(cnt <= sizee[to]) son[u]=to,cnt=sizee[to]; 
    }
}
inline void dfs2(const unsigned int &u,const unsigned int &topp) {
    top[u]=topp,id[u]=++res,rk[res]=u;
    if(!son[u]) return;
    dfs2(son[u],topp);
    for(auto to:e[u]) {
        if(to==fa[u]) continue;
        if(to==son[u]) continue;
        dfs2(to,to);
    }
}
inline void ask(unsigned int &x, unsigned int &y) {
    V ans;
    while(top[x] ^ top[y]) {
        if(h[top[x]] < h[top[y]]) sp(x, y);
        ans = ans + xds::ask(1, id[top[x]], id[x]);
        x = fa[top[x]];
    }
    if(id[x] > id[y]) sp(x, y);
    ans = ans + xds::ask(1, id[x], id[y]);
    if(!ans.d.size()) putchar('-'), putchar('1');
    else {
    	for(auto it: ans.d)
    		out(-it), putchar(' '); 
    }
    putchar('\n');
}
int ys[N];

inline void js(const unsigned int &i, const unsigned int &l, const unsigned int &r) {
    if(l == r) {
    	ys[l] = i;
        return;
    }
    const unsigned int mid = (l + r) >> 1;
    js(ls(i), l, mid),js(rs(i), mid + 1, r);
}
int main(){
    n = read();
    for(unsigned int i = 1, _u, _v; i < n; ++i) _u = read(), _v = read(), e[_u].push_back(_v), e[_v].push_back(_u);
    dfs(1, 0, 1), dfs2(1, 1);
    js(1, 1, n);
    m = read();
    for(unsigned int i = 1; i <= m; ++i) {
    	f[i] = read(), p[i] = read(), xds::tree[ys[id[p[i]]]].d.insert(-f[i]);
	}
    q = read(), k = read(), xds::build(1, 1, n);
    while(q--) {
        unsigned int op, x, y;
        op = read(), x = read(), y = read();
        if(op == 1) ask(x, y);
        if(op == 2) xds::tree[ys[id[p[x]]]].d.erase(xds::tree[ys[id[p[x]]]].d.find(-f[x])), xds::change(1, id[p[x]]), p[x] = y, xds::tree[ys[id[p[x]]]].d.insert(-f[x]), xds::change(1, id[p[x]]);
        if(op == 3) xds::tree[ys[id[p[x]]]].d.erase(xds::tree[ys[id[p[x]]]].d.find(-f[x])), f[x] = y, xds::tree[ys[id[p[x]]]].d.insert(-f[x]), xds::change(1, id[p[x]]);
    }
    return 0;
}
```

---

## 作者：2021hych (赞：1)

# 简要/形式化题意
给定一颗 $n$ 个结点的树，其中有 $m$ 个点 $P_i$ 有点权 $F_i$（一个结点可以有多个点权组成的点权可重集合）。有 $q$ 个操作，以及一个常数 $k$。

操作 $1$：询问 $x$ 号结点到 $y$ 号结点的链上，所有点权可重集合中的数字的前 $k$ 大，不足 $k$ 个则输出全部点权。

操作 $2$：在 $P_x$ 结点的点权可重集合中删去一个 $F_x$，让 $P_x=y$，然后在 $P_x$ 结点的点权可重集合中加入 $F_x$。

操作 $3$：在 $P_x$ 结点的点权可重集合中删去一个 $F_x$，让 $F_x=y$，然后在 $P_x$ 结点的点权可重集合中加入 $F_x$。

（这一波化简直接让题目简单了不少）
# 题解
首先这里涉及到了树上链查询，树链剖分即可。所以我们只要考虑一下序列上怎么做即可。

首先，这里涉及到了单点修改，区间查询。可以使用线段树，但是这个线段树要维护什么呢？

突破口：$k$ 为不超过 $20$ 的正整数。因此我们可以维护每个位置对应的点权可重集合前 $k$ 大。

具体的：对于 $\text{pushup}$ 操作，我们对于线段树上的左右节点做二路归并即可。对于 $\text{update}$ 操作，我们全局维护每个位置的可重集合，即 $\text{multiset}$。然后单点修改对应的 $\text{multiset}$。然后暴力重构线段树上该点维护的点权可重集合前 $k$ 大。对于 $\text{query}$ 操作直接查询线段树维护的点权可重集合前 $k$ 大即可。

当然实现的时候，要合并多个答案，不断地二路归并即可，可复用 $\text{pushup}$ 函数。

时间复杂度：$O(qk\log^2 n)$。
# AC code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=8e4+10;
int n,m,u,v,q,k;
int F[N],P[N];
int ver[N],head[N],Next[N],tot;
int dep[N],Size[N],Fa[N],son[N],top[N];
int dfn[N],cnt,rk[N];
int opt,x,y;
multiset<int,greater<int> >s[N<<2];
struct node {
	int len,a[30];
}t[N<<2];
void add(int x,int y) {
	ver[++tot]=y;
	Next[tot]=head[x];
	head[x]=tot;
}
void dfs1(int u,int fa) {
	Size[u]=1;
	Fa[u]=fa;
	dep[u]=dep[fa]+1;
	for(int i=head[u];i;i=Next[i]) {
		int v=ver[i];
		if(v==fa) continue;
		dfs1(v,u);
		Size[u]+=Size[v];
		if(Size[v]>Size[son[u]]) son[u]=v;
	}
}
void dfs2(int u,int t) {
	dfn[u]=++cnt;
	rk[cnt]=u;
	top[u]=t;
	if(son[u]) dfs2(son[u],t);
	for(int i=head[u];i;i=Next[i]) {
		int v=ver[i];
		if(v==Fa[u]||v==son[u]) continue;
		dfs2(v,v);
	}	
}
node pushup(node l,node r) {
	node ans;
	ans.len=0;
	memset(ans.a,0,sizeof(ans.a));
	int p1=1,p2=1;
	while(p1<=l.len&&p2<=r.len) {
		if(ans.len==k) return ans;
		if(r.a[p2]<l.a[p1]) ans.a[++ans.len]=l.a[p1++];
		else ans.a[++ans.len]=r.a[p2++];
	}
	for(int i=p1;i<=l.len;i++) {
		if(ans.len==k) return ans;
		ans.a[++ans.len]=l.a[p1++];
	}
	for(int i=p2;i<=r.len;i++) {
		if(ans.len==k) return ans;
		ans.a[++ans.len]=r.a[p2++];
	}
	return ans;
}
void build(int p,int l,int r) {
	if(l==r) {
		t[p].len=0;
		memset(t[p].a,0,sizeof(t[p].a));
		for(multiset<int,greater<int> >::iterator it=s[rk[l]].begin();it!=s[rk[l]].end();it++) {
			t[p].a[++t[p].len]=*it;
			if(t[p].len==k) break;
		}
		return;
	}
	int mid=l+r>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	t[p]=pushup(t[p<<1],t[p<<1|1]);
}
void update(int p,int l,int r,int pos,int d,int opt) {
	if(l==r) {
		if(!opt) s[rk[pos]].erase(s[rk[pos]].find(d));
		else s[rk[pos]].insert(d);
		t[p].len=0;
		memset(t[p].a,0,sizeof(t[p].a));
		for(multiset<int,greater<int> >::iterator it=s[rk[pos]].begin();it!=s[rk[pos]].end();it++) {
			t[p].a[++t[p].len]=*it;
			if(t[p].len==k) break;
		}
		return;
	}
	int mid=l+r>>1;
	if(pos<=mid) update(p<<1,l,mid,pos,d,opt);
	else update(p<<1|1,mid+1,r,pos,d,opt);
	t[p]=pushup(t[p<<1],t[p<<1|1]);
}
node query(int p,int l,int r,int L,int R) {
	if(L<=l&&r<=R) return t[p];
	int mid=l+r>>1;
	if(R<=mid) return query(p<<1,l,mid,L,R);
	if(L>mid) return query(p<<1|1,mid+1,r,L,R);
	return pushup(query(p<<1,l,mid,L,R),query(p<<1|1,mid+1,r,L,R));
}
node ask(int u,int v) {
	node ans;
	ans.len=0;
	memset(ans.a,0,sizeof(ans.a));
	while(top[x]!=top[y]) {
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		ans=pushup(ans,query(1,1,n,dfn[top[x]],dfn[x]));
		x=Fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	ans=pushup(ans,query(1,1,n,dfn[x],dfn[y]));
	return ans;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<n;i++) {
		cin>>u>>v;
		add(u,v);
		add(v,u);
	}
	cin>>m;
	dfs1(1,0);
	dfs2(1,1);
	for(int i=1;i<=m;i++) {
		cin>>F[i]>>P[i];
		s[P[i]].insert(F[i]);
	}
	cin>>q>>k;
	build(1,1,n);
	while(q--) {
		cin>>opt>>x>>y;
		if(opt==1) {
			node ans=ask(x,y);
			if(!ans.len) cout<<-1<<endl;
			else {
				for(int i=1;i<=ans.len;i++) cout<<ans.a[i]<<" ";
				cout<<endl;
			}
		}
		else if(opt==2) {
			update(1,1,n,dfn[P[x]],F[x],0);
			P[x]=y;
			update(1,1,n,dfn[P[x]],F[x],1);
		}
		else {
			update(1,1,n,dfn[P[x]],F[x],0);
			F[x]=y;
			update(1,1,n,dfn[P[x]],F[x],1);
		}
	}
	return 0;
}
```


---

## 作者：Utilokasteinn (赞：1)

## [Link](https://www.luogu.com.cn/problem/P5478)

在树上每个点维护一个 ```multiset```，每个集合里面存在该点上面的骑士的武力值。

然后树剖，建线段树。

线段树的每个点记录区间 $[l,r]$ 中前 $k$ 大的骑士的物理值，不满 $k$ 个就不满 $k$ 个。

询问就在查询线段树，然后暴力合并骑士的武力值。不是前 $k$ 大就直接丢掉。

对于第一种修改先将当前骑士从它目前所在的位置删掉，把第 $k+1$ 大替换成第 $k$ 大。然后添加到新的位置。在线段树上直接暴力改就行了。

对于第二种修改，先将当前骑士从它目前所在的位置删掉，判断新加入的是否为前 $k$ 大，是就加入。

因为只需要维护前 $k$ 大，所以后面可以直接舍去。

故时间复杂度 $\mathcal{O}((q+n)k\log^2 n)$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int s=0;char c=getchar();
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())
		s=s*10+c-'0';
	return s;
}
int n,m,q,lim,a[40005],b[40005];
int tot,head[40005];
struct edge{
	int to,nxt;
}e[80005];
inline void add(int u,int v)
{
	e[++tot].to=v;
	e[tot].nxt=head[u];
	head[u]=tot;
}
int dep[40005],fa[40005],siz[40005],son[40005];
void dfs1(int u,int father)
{
	dep[u]=dep[father]+1,siz[u]=1;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==father)continue;
		fa[v]=u;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]])
			son[u]=v;
	}
}
int top[40005],cnt,pos[40005];
multiset<int>val[40005],temp[40005];
void dfs2(int u,int up)
{
	top[u]=up,pos[u]=++cnt,temp[cnt]=val[u];
	if(son[u])dfs2(son[u],up);
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa[u]||v==son[u])continue;
		dfs2(v,v);
	}
}
struct node{
	int l,r;
	vector<int>v;
}s[160005];
inline vector<int> merge(vector<int>x,vector<int>y)
{
	int l1=0,l2=0;
	vector<int>res;
	while(l1<x.size()&&l2<y.size())
	{
		if(x[l1]<y[l2])
			res.push_back(x[l1++]);
		else res.push_back(y[l2++]);
		if(res.size()==lim)return res;
	}
	while(l1<x.size())
	{
		res.push_back(x[l1++]);
		if(res.size()==lim)return res;
	}
	while(l2<y.size())
	{
		res.push_back(y[l2++]);
		if(res.size()==lim)return res;
	}
	return res;
}
void build(int l,int r,int p)
{
	s[p].l=l,s[p].r=r;
	if(l==r)
	{
		for(multiset<int>::iterator it=temp[l].begin();it!=temp[l].end();it++)
		{
			s[p].v.push_back(*it);
			if(s[p].v.size()>=lim)break;
		}
		return;
	}
	int mid=(l+r)/2;
	build(l,mid,p*2);
	build(mid+1,r,p*2+1);
	s[p].v=merge(s[p*2].v,s[p*2+1].v);
}
void update_del(int pos,int val,int p)
{
	if(pos>s[p].r||pos<s[p].l)return;
	if(s[p].l==s[p].r)
	{
		int ps=lower_bound(s[p].v.begin(),s[p].v.end(),val)-s[p].v.begin();
		if(s[p].v.begin()+ps!=s[p].v.end())
			if(*(s[p].v.begin()+ps)==val)
				s[p].v.erase(s[p].v.begin()+ps);
		return;
	}
	update_del(pos,val,p*2),update_del(pos,val,p*2+1);
	s[p].v=merge(s[p*2].v,s[p*2+1].v);
}
void update_add(int pos,int val,int p)
{
	if(pos>s[p].r||pos<s[p].l)return;
	if(s[p].l==s[p].r)
	{
		int ps=lower_bound(s[p].v.begin(),s[p].v.end(),val)-s[p].v.begin();
		s[p].v.insert(s[p].v.begin()+ps,val);
		if(s[p].v.size()>lim)s[p].v.pop_back();
		return;
	}
	update_add(pos,val,p*2),update_add(pos,val,p*2+1);
	s[p].v=merge(s[p*2].v,s[p*2+1].v);
}
vector<int>zero;
vector<int> query(int ql,int qr,int p)
{
	if(ql>s[p].r||qr<s[p].l)return zero;
	if(ql<=s[p].l&&s[p].r<=qr)
		return s[p].v;
	return merge(query(ql,qr,p*2),query(ql,qr,p*2+1));
}
inline void ask(int u,int v)
{
	vector<int>ans;ans.clear();
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		ans=merge(ans,query(pos[top[u]],pos[u],1));
		u=fa[top[u]];
	}
	if(dep[u]>dep[v])swap(u,v);
	ans=merge(ans,query(pos[u],pos[v],1));
	if(ans.size()==0)printf("-1");
	else for(int i=0;i<ans.size();i++)
		printf("%d ",-ans[i]);
	printf("\n");
}
int main()
{
	n=read();
	for(int i=1;i<n;i++)
	{
		int u=read(),v=read();
		add(u,v),add(v,u);
	}
	m=read();
	for(int i=1;i<=m;i++)
	{
		a[i]=-read(),b[i]=read();
		val[b[i]].insert(a[i]);
	}
	q=read(),lim=read();
	dfs1(1,0);
	dfs2(1,1);
	build(1,n,1);
	while(q--)
	{
		int op=read();
		if(op==1)
		{
			int u=read(),v=read();
			ask(u,v);
		}
		else if(op==2)
		{
			int id=read(),u=read();
			update_del(pos[b[id]],a[id],1);
			val[b[id]].erase(val[b[id]].find(a[id]));
			if(val[b[id]].size()>=lim)
			{
				multiset<int>::iterator it=val[b[id]].begin();
				for(int i=1;i<lim;i++)it++;
				update_add(pos[b[id]],*it,1);
			}
			update_add(pos[u],a[id],1);
			val[u].insert(a[id]);
			b[id]=u;
		}
		else
		{
			int id=read(),k=-read();
			update_del(pos[b[id]],a[id],1);
			val[b[id]].erase(val[b[id]].find(a[id]));
			if(val[b[id]].size()<lim)
				update_add(pos[b[id]],k,1);
			else
			{
				multiset<int>::iterator it=val[b[id]].begin();
				for(int i=1;i<lim;i++)it++;
				if(-*it>=-k)update_add(pos[b[id]],*it,1);
				else update_add(pos[b[id]],k,1);
			}
			val[b[id]].insert(k);
			a[id]=k;
		}
	}
	return 0;
}
```


---

## 作者：Kingna (赞：0)

树链剖分。考虑如何维护前 $K$ 大数。

因为 $K$ 很小，则对于每个线段树节点，用 `multiset` 维护前 $K$ 大值。合并左右子节点时，也只需要保留最大的 $K$ 个值，具体实现可用归并排序。

树链剖分时，也只需要仿照线段树合并所有重链。总复杂度 $O(nk\log^2n)$。

注意事项：在函数中传 `multiset` 时记得加指针。

```cpp
//#pragma GCC optimize(2)
//#pragma GCC optimize(3)

#include <bits/stdc++.h>
using namespace std;

#define ls p << 1
#define rs p << 1 | 1
//#define int long long
#define PII pair<int, int>
#define _for(i, a, b) for (int i = (a); i <= (b); i++)
#define _pfor(i, a, b) for (int i = (a); i >= (b); i--)

const int N = 4e4 + 5;
int n, m, Q, K, nw[N], dep[N], son[N], sz[N], fat[N], top[N], id[N], idx;
vector<int> G[N]; 
vector<int> a[N];

int read() {
	char c = ' ';
	int f = 1, x = 0;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

void wr(int x) {
	if (x < 0) {
		x = -x; putchar('-');
	}
	if (x > 9) wr(x / 10);
	putchar(x % 10 + '0');
}

struct tt {
	int f, p; // 武力值，居住地 
}ed[N];

struct edge {
	int l, r;
	multiset<int> s;
}tree[N * 4];

inline void push_up(auto& p, multiset<int>& lson, multiset<int>& rson) {
	p.clear();
	int cnt = 0;
	if (lson.size() == 0 && rson.size() == 0) return;
	if (lson.size() == 0) {
		auto it3 = rson.end();
		it3--;
		while (cnt <= K) {
			p.insert(*it3);
			if (it3 == rson.begin()) break;
			it3--;
			cnt++;
		}
		return; 
	}
	if (rson.size() == 0) {
		auto it4 = lson.end();
		it4--;
		while (cnt <= K) {
			p.insert(*it4);
			if (it4 == lson.begin()) break;
			it4--;
			cnt++;
		}
		return;
	}
	auto it = lson.end(), it2 = rson.end();
	it--, it2--;
	int flg = 0, flg1 = 0;
	do {
		if ((*it) >= (*it2)) {
			p.insert(*it);
			cnt++;
			if (it == lson.begin()) {
				flg = 1;
				break;
			}
			if (cnt > K) break;
			it--;
		}
		else {
			p.insert(*it2);
			cnt++;
			if (it2 == rson.begin()) {
				flg1 = 1;
				break;
			}
			if (cnt > K) break;
			it2--;
		}
	} while (cnt <= K);
	do {
		if (flg) break;
		p.insert(*it);
		cnt++; 
		if (it == lson.begin()) break;
		if (cnt > K) break;
		it--;
	} while (cnt <= K);
	do {
		if (flg1) break;
		p.insert(*it2);
		cnt++;
		if (it2 == rson.begin()) break;
		if (cnt > K) break;
		it2--;
	} while (cnt <= K);
}

void build(int p, int l, int r) {
	tree[p].l = l, tree[p].r = r; 
	if (l == r)  {
		for (auto v : a[nw[l]]) {
			tree[p].s.insert(v);
		}
		return;
	}
	int mid = (l + r) >> 1;
	build(ls, l, mid);
	build(rs, mid + 1, r);
	push_up(tree[p].s, tree[ls].s, tree[rs].s);
}

void modify_e(int p, int x, int v) {
	if (tree[p].s.find(v) != tree[p].s.end()) {
		tree[p].s.erase(tree[p].s.find(v));
	}
	if (tree[p].l == tree[p].r) {
		return;
	}
	int mid = (tree[p].l + tree[p].r) >> 1;
	if (x <= mid) modify_e(ls, x, v);
	else modify_e(rs, x, v);
	push_up(tree[p].s, tree[ls].s, tree[rs].s);
}

void modify_a(int p, int x, int v) {
	if (tree[p].l == tree[p].r) {
		tree[p].s.insert(v);
		return;
	}
	int mid = (tree[p].l + tree[p].r) >> 1;
	if (x <= mid) modify_a(ls, x, v);
	else modify_a(rs, x, v);
	push_up(tree[p].s, tree[ls].s, tree[rs].s);
}

multiset<int> tmpr;

multiset<int> query(int p, int l, int r) {
	if (l > tree[p].r || r < tree[p].l) return tmpr;
	if (l <= tree[p].l && tree[p].r <= r) {
		return tree[p].s;
	}
	auto x = query(ls, l, r), y = query(rs, l, r);
	multiset<int> res;
	if (x.size() == 0) return y;
	if (y.size() == 0) return x;
	push_up(res, x, y);
	return res;
}

void dfs(int u, int fa, int depth) {
	sz[u] = 1; fat[u] = fa; dep[u] = depth;
	for (auto v : G[u]) {
		if (v == fa) continue;
		dfs(v, u, depth + 1);
		sz[u] += sz[v];
		if (sz[v] > sz[son[u]]) son[u] = v;
	}
}

void dfs2(int u, int fa, int t) {
	top[u] = t; id[u] = ++idx; nw[idx] = u;
	if (son[u]) dfs2(son[u], u, t);
	for (auto v : G[u]) {
		if (v == fa || v == son[u]) continue;
		dfs2(v, u, v); 
	}
}

auto query_path(int x, int y) {
	multiset<int> ans;
	while (top[x] != top[y]) {
		if (dep[top[x]] > dep[top[y]]) {
			auto se = query(1, id[top[x]], id[x]);
			auto tmp = ans;
			push_up(ans, tmp, se);
			x = fat[top[x]];
		}
		else {
			auto se = query(1, id[top[y]], id[y]);
			auto tmp = ans;
			push_up(ans, tmp, se);
			y = fat[top[y]];
		}
	}
	if (dep[x] > dep[y]) {
		auto se = query(1, id[y], id[x]);
			auto tmp = ans;
		push_up(ans, tmp, se);
	}
	else {
		auto se = query(1, id[x], id[y]);
			auto tmp = ans;
		push_up(ans, tmp, se);
	}
	return ans;
}


signed main() {
	cin >> n;
	_for(i, 1, n - 1) {
		int u, v;
		u = read(), v = read();
		G[u].push_back(v);
		G[v].push_back(u);
	}
	cin >> m;
	_for(i, 1, m) ed[i].f = read(),ed[i].p = read(), a[ed[i].p].push_back(ed[i].f);
	dfs(1, 0, 1);
	dfs2(1, 0, 1);
	cin >> Q >> K;
	build(1, 1, n);
	_for(cas, 1, Q) {
		int op, x, y;
		op = read(), x = read(), y = read();
		if (op == 1) {
			auto res = query_path(x, y);
			if (res.size() == 0) puts("-1");
			else {
				auto it = --res.end();
				int cnt = 1;
				while (cnt <= K) {
					cnt++;
					wr(*it);
					putchar(' ');
					if (it == res.begin()) break;
					it--;
				}
				puts("");
			}
		}
		if (op == 2) {
			modify_e(1, id[ed[x].p], ed[x].f);
			ed[x].p = y;
			modify_a(1, id[ed[x].p], ed[x].f);
		}
		if (op == 3) {
			modify_e(1, id[ed[x].p], ed[x].f);
			ed[x].f = y;
			modify_a(1, id[ed[x].p], ed[x].f);
		}
	}
}
```

---

## 作者：junee (赞：0)

# P547 题解

## 前置知识

树链剖分，归并排序。

## 题目分析

$\sout{非常好的题目，使我的脑子旋转，调了半年终于调出来了}$。

题意比较简单，不赘叙了。

观察题目范围，发现 $k \le 20$，这个数据比较小，提示可以直接暴力求解，对于每一个线段树节点开一个数组，表示前 20 大的骑士，每次合并时可以用归并排序，并且保证数组是有序的。

删数时可以给数组丢到 multiset 里，然后取前 20 大的就可以了。

查询时同样用归并排序即可。

如果你一直获得 33 的高分，需注意，每次删一个骑士只用删一个！

## Code

```
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
#include<set>
using namespace std;
const int N=1e5+10;
int h[N],e[N*2],ne[N*2],w[N*2],idx;
int dep[N],son[N],sz[N],fa[N],top[N],id[N],cnt;
multiset<int,greater<int> >ms;
int ans[25],ap=0;
int Ans[25],Ap=0;
void add(int a,int b){
	e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
struct knight{
	int f,p;
}k[N];
int n,m,q,s;
void dfs_son(int u,int f,int d){
    dep[u]=d,sz[u]=1,fa[u]=f;
    for(int i=h[u];~i;i=ne[i]){
        int j=e[i];
        if(j==f)continue;
        dfs_son(j,u,d+1);
        sz[u]+=sz[j];
        if(sz[son[u]]<sz[j])son[u]=j;
    }
}
void dfs(int u,int t){
    top[u]=t,id[u]=++cnt;
    if(!son[u])return;
    dfs(son[u],t);
    for(int i=h[u];~i;i=ne[i]){
        int j=e[i];
        if(j==son[u]||j==fa[u])continue;
        dfs(j,j);
    }
}
struct node{
    int l,r,kn[25],p;
}tr[N*4];
void pushup(int u){
    auto &rt=tr[u],&ls=tr[u<<1],&rs=tr[u<<1|1];
    int i=1,j=1;
    rt.p=0;
    while(i<=ls.p&&j<=rs.p&&rt.p<=20){
        if(ls.kn[i]>rs.kn[j])rt.kn[++rt.p]=ls.kn[i],i++;
        else rt.kn[++rt.p]=rs.kn[j],j++;
    }
    while(i<=ls.p&&rt.p<=20)rt.kn[++rt.p]=ls.kn[i],i++;
    while(j<=rs.p&&rt.p<=20)rt.kn[++rt.p]=rs.kn[j],j++;
}
void build(int u,int l,int r){
    tr[u]={l,r};
    if(l==r)return;
    int mid=(l+r)>>1;
    build(u<<1,l,mid),build(u<<1|1,mid+1,r);
}
void modify(int u,int pos,int k,int f){
    if(tr[u].l==tr[u].r){
        if(f){
            ms.clear();
            for(int i=1;i<=tr[u].p;i++)ms.insert(tr[u].kn[i]);
            ms.insert(k);
            tr[u].p=0;
            for(auto i:ms){
                tr[u].kn[++tr[u].p]=i;
                if(tr[u].p==20)break;
            }
        }
        else{
            ms.clear();
            for(int i=1;i<=tr[u].p;i++)ms.insert(tr[u].kn[i]);
            tr[u].p=0;
            for(auto i:ms){
                if(i==k)continue;
                tr[u].kn[++tr[u].p]=i;
            }
        }
        return;
    }
    int mid=(tr[u].l+tr[u].r)>>1;
    if(pos<=mid)modify(u<<1,pos,k,f);
    else modify(u<<1|1,pos,k,f);
    pushup(u);
}
void query(int u,int l,int r){
    if(tr[u].l>=l&&tr[u].r<=r){
        int i=1,j=1;
        Ap=0;
        while(i<=ap&&j<=tr[u].p&&Ap<=20){
            if(ans[i]>tr[u].kn[j])Ans[++Ap]=ans[i],i++;
            else Ans[++Ap]=tr[u].kn[j],j++;
        }
        while(i<=ap&&Ap<=20)Ans[++Ap]=ans[i],i++;
        while(j<=tr[u].p&&Ap<=20)Ans[++Ap]=tr[u].kn[j],j++;
        swap(Ans,ans);
        swap(Ap,ap);
        return;
    }
    int mid=(tr[u].l+tr[u].r)>>1;
    if(l<=mid)query(u<<1,l,r);
    if(r>mid)query(u<<1|1,l,r);
}
void query_path(int u,int v){
	ap=0;
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]])swap(u,v);
        query(1,id[top[u]],id[u]);
        u=fa[top[u]];
    }
    if(dep[u]<dep[v])swap(u,v);
    query(1,id[v],id[u]);
}
int main(){
	memset(h,-1,sizeof h);
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<n;i++){
		int a,b;
		cin>>a>>b;
		add(a,b),add(b,a);
	}
	dfs_son(1,-1,1);
	dfs(1,1);
 	build(1,1,N);
	cin>>m;
	for(int i=1;i<=m;i++){
		int a,p;
		cin>>a>>p;
		k[i]={a,p};
		modify(1,id[p],a,1);
	}
	cin>>q>>s;
	int op,u,v;
	while(q--){
		cin>>op>>u>>v;
		if(op==1){
			query_path(u,v);
			if(!ap)cout<<-1<<'\n';
			else{
			    for(int i=1;i<=min(s,ap);i++)cout<<ans[i]<<' ';
			    cout<<'\n';
			}
		}
		if(op==2){
		    modify(1,id[k[u].p],k[u].f,0);
		    modify(1,id[v],k[u].f,1);
			k[u].p=v;
		}
		if(op==3){
		    modify(1,id[k[u].p],k[u].f,0);
		    modify(1,id[k[u].p],v,1);
			k[u].f=v;
		}
	}
	return 0;
}
```

---

## 作者：__shadow__ (赞：0)

首先分析一下题目，对于这棵树，操作如下：
1. 查询从 X 到 Y 的路径上的前 k 大的值。
2. 把 $P_i$ 上的武力值减去一个 $F_i$ 并在 Y 上的武力值加上一个 $F_i$，再把 $P_i$ 改成 Y。
3. 将 $P_i$ 上的武力值减去一个 $F_i$ 再加上一个 Y，并把 $F_i$ 改成 Y。

由第一个我们可以想到，先用树剖，再用线段树处理。每个节点上存储该范围下的前 k 大，每个地方的武力值就用 multiset 存下来就可以了。因为 $k \le 20$，所以每个叶子节点暴力更新就可以了。PushUp 就用归并排序的方式合并两个子节点的前 k 大，最后用常规的树剖操作查询就结束了。

```cpp
#include <cstdio>
#include <vector>
#include <set>
#include <algorithm>
using namespace std;
const int N = 40000 + 5;
int n, m, Q, K;
int F[N], P[N];
vector<int> V[N];
multiset <int, greater<int> > S[N];
int fa[N], dep[N], siz[N], son[N];
int top[N], id[N], cnt;
void dfs1(int sx, int ffa) {
    fa[sx] = ffa;
    dep[sx] = dep[ffa] + 1;
    siz[sx] = 1;
    int maxn = -1;
    for (auto to : V[sx]) {
        if (to == ffa) continue;
        dfs1 (to, sx);
        siz[sx] += siz[to];
        if (siz[to] > maxn) {
            maxn = siz[to];
            son[sx] = to;
        }
    }
    return ;
}
void dfs2(int sx, int topf) {
    top[sx] = topf;
    id[sx] = ++ cnt;
    if (son[sx]) dfs2 (son[sx], topf);
    for (auto to : V[sx]) {
        if (to == fa[sx] || to == son[sx]) continue;
        dfs2 (to, to);
    }
    return ;
}
struct sgt {
    struct node {
        int res[25], len;
    }sum[N << 2];
    node merge(node A, node B) {
        node C;
        C.len = 0;
        int i = 1, j = 1;
        while (i <= A.len && j <= B.len && C.len < K) {
            if (A.res[i] > B.res[j])
                C.res[++ C.len] = A.res[i ++];
            else C.res[++ C.len] = B.res[j ++];
        }
        while (i <= A.len && C.len < K) C.res[++ C.len] = A.res[i ++];
        while (j <= B.len && C.len < K) C.res[++ C.len] = B.res[j ++];
        return C;
    }
    void PushUp (int u) {
        sum[u] = merge(sum[u << 1], sum[u << 1 | 1]);
        return ;
    }
    void build (int u, int l, int r) {
        if (l == r) {
            sum[u].len = 0;
            for (auto i : S[l]) {
                sum[u].res[++ sum[u].len] = i;
                if (sum[u].len == K)
                    break;
            }
            return ;
        }
        int mid = l + r >> 1;
        build (u << 1, l, mid);
        build (u << 1 | 1, mid + 1, r);
        PushUp (u);
    }
    void modify(int u, int l, int r, int pos, int add, int red) {
        if (l == r) {
            if (add != -1) S[pos].emplace (add);
            if (red != -1) S[pos].erase (S[pos].find(red));
            sum[u].len = 0;
            for (auto i : S[l]) {
                sum[u].res[++ sum[u].len] = i;
                if (sum[u].len == K)
                    break;
            }
            return ;
        }
        int mid = l + r >> 1;
        if (pos <= mid)
            modify (u << 1, l, mid, pos, add, red);
        if (mid < pos)
            modify (u << 1 | 1, mid + 1, r, pos, add, red);
        PushUp (u);
        return ;
    }
    node query(int u, int l, int r, int L, int R) {
        if (L <= l && r <= R) return sum[u];
        int mid = l + r >> 1;
        if (R <= mid)
            return query (u << 1, l, mid, L, R);
        if (L > mid)
            return query (u << 1 | 1, mid + 1, r, L, R);
        return merge (query (u << 1, l, mid, L, R), query (u << 1 | 1, mid + 1, r, L, R));
    }
    node get(int x, int y) {
        node ans;
        ans.len = 0;
        while (top[x] != top[y]) {
            if (dep[top[x]] > dep[top[y]])
                swap (x, y);
            ans = merge (ans, query (1, 1, n, id[top[y]], id[y]));
            y = fa[top[y]];
        }
        if (dep[x] > dep[y]) swap (x, y);
        ans = merge (ans, query (1, 1, n, id[x], id[y]));
        return ans;
    }
}tre;
int main() {
    scanf ("%d", &n);
    for (int i = 1;i < n; ++ i) {
        int u, v;
        scanf ("%d%d", &u, &v);
        V[u].push_back(v);
        V[v].push_back(u);
    }
    scanf ("%d", &m);
    for (int i = 1;i <= m; ++ i)
        scanf ("%d%d", F + i, P + i);
    dfs1 (1, 1);
    dfs2 (1, 1);
    for (int i = 1;i <= m; ++ i) 
        S[id[P[i]]].emplace (F[i]);
    scanf ("%d%d", &Q, &K);
    tre.build(1, 1, n);
    while (Q--) {
        int opt, X, Y;
        scanf ("%d%d%d", &opt, &X, &Y);
        if (opt == 1) {
            sgt :: node ans;
            ans = tre.get (X, Y);
            for (int i = 1;i <= ans.len; ++ i)
                printf ("%d ", ans.res[i]);
            if (ans.len == 0) printf ("-1");
            puts("");
        }
        if (opt == 2) {
            tre.modify (1, 1, n, id[P[X]], -1, F[X]);
            P[X] = Y;
            tre.modify (1, 1, n, id[P[X]], F[X], -1);
        }
        if (opt == 3) {
            tre.modify (1, 1, n, id[P[X]], Y, F[X]);
            F[X] = Y;
        }
    }
    return 0;
}
```

---


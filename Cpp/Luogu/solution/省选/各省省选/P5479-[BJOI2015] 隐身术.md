# [BJOI2015] 隐身术

## 题目描述

给定两个串$A$、$B$。请问$~B~$中有多少个非空子串和$~A~$的编辑距离不超过$K$？

所谓“子串”，指的是$~B~$中连续的一段。不同位置的内容相同的子串算作多个。两个串之间的“编辑距离”指的是把一个串变成另一个串需要的最小的操作次数，每次操作可以插入、删除或者替换一个字符。

## 说明/提示

对$100\%$的数据，$K\leq5$，两个字符串均非空，长度和小于$10^5$。

## 样例 #1

### 输入

```
1
AAA
AABBAAB```

### 输出

```
5```

# 题解

## 作者：ccxswl (赞：6)

[洛谷题面。](https://www.luogu.com.cn/problem/P5479)

模拟赛出到[加强版](https://qoj.ac/problem/5312)了，一点不会所以记录下。

---

枚举每个后缀。设 $f_{i,j}$ 为操作 $i$ 次，长度增加 $j$，即插入的次数减删除的次数，所能匹配到的最大位置。也就是 $A$ 的前 $f_{i,j}$ 位匹配 $B$ 的前 $f_{i,j}+j$ 位。

考虑转移。假如已经操作完了，那显然有 $f_{i,j} \gets f_{i,j}+\text{LCP}(A[f_{i,j}+1:|A|],B[f_{i,j}+j+1:|B|])$。

进行操作的转移：
 - 替换：$f_{i+1,j} \gets f_{i,j}+1$
 - 删除：$f_{i+1,j-1} \gets f_{i,j}+1$
 - 添加：$f_{i+1,j+1}\gets f_{i,j}$

一些解释：添加操作的时候，$A$ 多了一个虚拟的点，但最后一个匹配到的真正存在的点还是 $f_{i,j}$。删除操作的时候，那个被删的点也看做完成了匹配。

转移时注意多判边界。

LCP 可以直接用二分哈希，其实 SA 可以更快，但二分哈希完全够用。

最后统计答案记得找到最小操作次数后要跳出循环。

复杂度 $O(nk^2\log n)$。如果用 SA 的话是 $O(nk^2)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long

using ubt = unsigned long long;

const int maxN = 1e5 + 7;

int k;
int n, m;
string s, t;

const ubt Base = 131;
ubt H[maxN], S[maxN], T[maxN];
void inithash() {
  H[0] = 1, S[0] = T[0] = 0;
  for (int i = 1; i <= n || i <= m; i++) {
    if (i <= n) S[i] = S[i - 1] * Base + s[i];
    if (i <= m) T[i] = T[i - 1] * Base + t[i];
    H[i] = H[i - 1] * Base;
  }
}
ubt gets(int l, int r) {
  return S[r] - S[l - 1] * H[r - l + 1];
}
ubt gett(int l, int r) {
  return T[r] - T[l - 1] * H[r - l + 1];
}

int LCP(int ss, int st) {
  int l = 1, r = min(n - ss + 1, m - st + 1);
  int pos = 0;
  while (l <= r) {
    int mid = (l + r) >> 1;
    if (gets(ss, ss + mid - 1) == gett(st, st + mid - 1))
      l = mid + 1, pos = mid;
    else r = mid - 1;
  }
  return pos;
}

const int inf = 1e9;
const int V = 7;
int ans[V];
int st;
int f[V][V * 2];
void Main() {
  memset(f, ~0x3f, sizeof(f));
  f[0][k] = 0;
  for (int i = 0; i <= k; i++)
    for (int j = 0; j <= k * 2; j++) {
      if (f[i][j] <= -inf) continue;
      int p = j - k;
      if (f[i][j] + p < 0) continue;
      if (st - 1 + f[i][j] + p > m) continue;
      f[i][j] += LCP(f[i][j] + 1, st - 1 + f[i][j] + p + 1);
      if (i != k) {
        if (j)
          f[i + 1][j - 1] = max(f[i + 1][j - 1], min(f[i][j] + 1, n));
        f[i + 1][j] = max(f[i + 1][j], min(f[i][j] + 1, n));
        if (j != k * 2)
          f[i + 1][j + 1] = max(f[i + 1][j + 1], f[i][j]);
      }
    }

  for (int i = 0; i <= k * 2; i++)
    for (int j = 0; j <= k; j++)
      if (f[j][i] == n && i - k + n > 0 && st - 1 + i - k + n <= m)
      { ans[j]++; break; }
}

signed main() {
  // ifstream cin("edit.in");
  // ofstream cout("edit.out");

  cin >> k >> s >> t;
  n = s.length(), m = t.length();
  s = '@' + s, t = '$' + t;

  inithash();

  for (st = 1; st <= m; st++)
    Main();
  
  int res = 0;
  for (int i = 0; i <= k; i++)
    res += ans[i];
  cout << res << '\n';
}
```

---

更新：代码有点问题，修了。

---

## 作者：bellmanford (赞：6)

先$\%$一下神仙的$dp$做法

------------

这题一看$n+m≤10^5$，就知道要合并起来了(大雾

再看$k≤5$，那就只用直接$DFS$枚举操作方案

记录在字符串A的匹配位置x和在字符串B的匹配位置y

还要记录剩余操作数判断是否终止

每次跳掉两个后缀的lcp（也就是最长前缀）

目前跳到的地方一定是不相同的字符

也就是$A[x] \ne B[y]$

必然进行一次操作

插入：在$A[x]$前面插入一个和$B[y]$一样的字符，$x$的位置不变，$y$往后一个

删除：将$A[x]$删去，$x$向后一个

修改：将$A[x]$的字符改为$B[y]$的字符，$x,y$均往后一个

每次某个串匹配到结尾时，$B$中的某个区间的前缀都会合法，注意到这些合法的前缀长度与$A$长度相差一定不超过$k$，于是用一个$2*k+1$的差分数组记录答案即可

每次$DFS$由于转移时一定会增加一次操作数，所以最多递归$k$次，最差复杂度为$O(3^k)$

所以总复杂度为$O(n\log n+n3^k)$

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;

#define max(x,y) (x>y?x:y)
#define min(x,y) (x<y?x:y)
#define int long long
const int M=1e5+5;

int n,m=125,ans=0,k,sl,tl,L,R,now,pre[M];
int tx[M],tp[M],sa[M],rk[M],height[M];
int st[M][35],log[M];
char r[M],s[M],t[M];

void jsort(){
	for(int i=0;i<=m;i++) tx[i]=0;
	for(int i=1;i<=n;i++) tx[rk[i]]++;
	for(int i=1;i<=m;i++) tx[i]+=tx[i-1];
	for(int i=n;i>=1;i--) sa[tx[rk[tp[i]]]--]=tp[i];
}

void Build_SA(){//板子 
	jsort();//O(n)的基排 
	for(int w=1,p=0;p<n;m=p,w<<=1){
		p=0;
		for(int i=1;i<=w;i++) tp[++p]=n-w+i;
		for(int i=1;i<=n;i++) if(sa[i]>w) tp[++p]=sa[i]-w;
		jsort();
		std::swap(tp,rk);
		rk[sa[1]]=p=1;
		for(int i=2;i<=n;i++){
			if(tp[sa[i-1]]==tp[sa[i]]&&tp[sa[i-1]+w]==tp[sa[i]+w]) rk[sa[i]]=p;
			else rk[sa[i]]=++p;
		}
	}
	for(int i=1;i<=n;i++) sa[i-1]=sa[i]-1;//将SA给变为0-(n-1) 
}

void Build_Height(){//求height 
	for(int i=0;i<n;i++) rk[sa[i]]=i;
	int k=0;
	for(int i=0;i<n;i++){
		if(!rk[i]) continue;
		if(k) k--;
		int j=sa[rk[i]-1];
		while(r[i+k]==r[j+k]) k++;
		height[rk[i]]=k;
	}
}

void Build_ST(){//st表优化求lcp 
	for(int i=2;i<=n;i++) log[i]=log[i>>1]+1;
	for(int i=0;i<n;i++) st[i][0]=height[i];
	for(int j=1;j<=25;++j){
		for(int i=0;i+(1<<j)-1<n;i++){
			st[i][j]=min(st[i][j-1],st[i+(1<<j-1)][j-1]);
		}
	}
}

int Query(int l,int r){//O(1)查询两个字符串分别的后缀l和后缀r的lcp的长度
	int k=log[r-l+1];
	return min(st[l][k],st[r-(1<<k)+1][k]);
}

void DFS(int x,int y,int z){//爆搜，x代表在字符串A的匹配位置，y代表在字符串B的匹配位置，z代表剩余操作数 
	if(z>k) return ;
	int l=rk[x],r=rk[y];
	if(l>r) swap(l,r);
	int lcp=Query(l+1,r);
	x+=lcp,y+=lcp;//跳过相同的字符串 
	if(x==sl||y==n){
		int d=k-z-(sl-x);
		if(d<0) return ;
		int l=max(y-1-d,now),r=min(y-1+d,n-1);
		L=min(l,L),R=max(r+1,R);
		pre[l]++,pre[r+1]--;
		return ;
	}
	DFS(x+1,y,z+1),DFS(x,y+1,z+1),DFS(x+1,y+1,z+1);//三种状态转移 
}

signed main(){
	scanf("%lld%s%s",&k,s,t);
	sl=strlen(s),tl=strlen(t);
	for(int i=0;i<sl;i++) r[n++]=s[i];r[n++]='#';//分开前后字符串 
	for(int i=0;i<tl;i++) r[n++]=t[i];
	for(int i=1;i<=n;i++) rk[i]=r[i-1],tp[i]=i;
	Build_SA(),Build_Height(),Build_ST();
	for(int i=0;i<tl;i++){
		now=sl+i+1,L=n-1,R=0;
		DFS(0,sl+i+1,0);
		for(int j=L;j<=R;++j) ans+=(pre[j]+=pre[j-1])>0;
		for(int j=L;j<=R;++j) pre[j]=0;
	}
	printf("%lld\n",ans);
}
```


---

## 作者：xyin (赞：4)

## PART 1

改掉惯性思维，某些时候字符串也可以用 DP。

设 $f_{i,j}$ 表示 $S$ 中第 $i$ 个字符匹配到了 $T$ 中的第 $j$ 个字符需要的最小操作数。则可以根据插入、删除、修改去转移，如下：

* insert：$f_{i,j}=\min(f_{i,j},f_{i,j-1}+1)$ 

* delet：$f_{i,j}=\min(f_{i,j},f_{i-1,j}+1)$

* modify：$f_{i,j}=\min(f_{i,j},f_{i-1,j-1}+(s_i\neq s_j))$

初始化 $f_{0,i}(0\le i\le |T|)=i,f_{i,0}(0\le i\le |S|)=i$，含义为添加/删除 $i$ 个字符。时间复杂度 $O(n^2)$，不足以通过本题。

## PART 2

观察发现 $k$ 很小，转态设计由 $k$ 入手（就当长见识了），设 $f_{i,j}$ 表示当前的操作数为 $i$，$S$ 增加的长度为 $j$ 时 $S$ 所能匹配到的最大位置，也就是 $S$ 的前 $f_{i,j}$ 匹配到了 $T$ 的前 $f_{i,j}+j$ 位。

考虑做完 $i$ 次操作后往外延伸，可以延伸的即为 $S$ 的一个后缀和 $T$ 的一个后缀的 LCP（最长公共前缀），即为：
        
$$f_{i,j}\leftarrow f_{i,j}+\text{LCP}(S[f_{i,j}+1:|S|],T[f_{i,j}+j+1:|T|])$$

然后我们再来考虑插入、删除、修改操作的转移，这里写的是刷表容易理解：

* insert：$f_{i+1,j+1}=\max(f_{i+1,j+1},f_{i,j})$
        
    操作数 $i+1$，$S$ 增加的长度 $j+1$ 很好理解，此时插入了一个字符，实际上 $S$ 中匹配上的长度还是不变的。

* delet：$f_{i+1,j-1}=\max(f_{i+1,j-1},f_{i,j}+1)$

    同样的操作数 $+1$，增加的长度 $-1$，此时即使删除了一个数但是实际上 $S$ 中匹配上的长度多了 $1$。

* modify：$f_{i+1,j}=\max(f_{i+1}{j},f_{i,j}+1)$

    同样的操作数 $+1$，但是增加的长度不变，此时修改一个数，$S$ 中匹配上的长度 $+1$。

注意实现时 $j\in [0,2\times k]$ 是因为由于有删除操作我们 $S$ 增加的长度可能为负，所以全体 $+k$ 作为偏移量，写代码时记得判断边界情况。

枚举 $T$ 串中的起始节点 $l(1\le l\le |T|)$，跑一遍 DP，对于每个 $j$ 得出 $S$ 中的匹配长度为 $|S|$ 时所需的最小操作数。求 LCP 的时候可以用二分 + hash，总时间复杂度为 $O(nk^2\log n)$，其中 $n$ 为 $T$ 串的长度。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ull unsigned long long
using namespace std;
const int N=10;
const int base=233;
const int maxn=1e5+5;
const int INF=1e9+7;
int read(int x=0,bool f=1,char c=0){
    while (!isdigit(c=getchar())) f=c^45;
    while (isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
    return f?x:-x;
}
char s[maxn],t[maxn];
int f[N][N<<1],res;
ull p[maxn],ha[maxn][2];
int ans[maxn],m,len1,len2;
void init(){//初始化 hash 数组
    p[0]=1;len1=strlen(s+1);
    len2=strlen(t+1);
    for (int i=1;i<=5e4;i++)
        p[i]=p[i-1]*base;
    for (int i=1;i<=len1;i++)
        ha[i][0]=ha[i-1][0]*base+s[i];
    for (int i=1;i<=len2;i++)
        ha[i][1]=ha[i-1][1]*base+t[i];
}
ull get(int l,int len,int o){
    return ha[l+len][o]-ha[l][o]*p[len];
}
bool check(int st1,int st2,int len){
    if (len==0) return 1;
    return get(st1,len,0)==get(st2,len,1);
}
int lcp(int st1,int st2){//二分求 LCP
    int l=0,r=min(len1-st1,len2-st2);
    while (l<r){
        int mid=(l+r)>>1;
        if (check(st1,st2,mid)){
            l=mid;
            if (l==r-1){
                if (check(st1,st2,r)) return r;
                else return l;
            }
        }
        else r=mid-1;
    }
    return l;
}
void dp(int l){
    for (int i=0;i<=m;i++)
        for (int j=0;j<=m*2;j++)
            f[i][j]=-INF;
    f[0][m]=0;//初始化
    for (int i=0;i<=m;i++)
        for (int j=0;j<=2*m;j++)
            if(f[i][j]>=0&&f[i][j]+j-m>=0&&l-1+f[i][j]+j-m<=len2){
                f[i][j]=f[i][j]+lcp(f[i][j],l-1+f[i][j]+j-m);//由后缀的 LCP 转移
                if (j) f[i+1][j-1]=max(f[i+1][j-1],f[i][j]+(f[i][j]!=len1));//delet
                f[i+1][j]=max(f[i+1][j],f[i][j]+(f[i][j]!=len1));//modify
                f[i+1][j+1]=max(f[i+1][j+1],f[i][j]);//insert
            }
    for (int j=0;j<=2*m;j++)
        for (int i=0;i<=m;i++)
            if (f[i][j]==len1&&len1+j-m>0&&l-1+len1+j-m<=len2)
                {++ans[i];break;}//找到最小答案时跳出循环
                //此时 T 匹配的区间为 [l,l-1+len1+j-m]
}
signed main(){
    m=read();scanf("%s%s",s+1,t+1);init();
    for (int i=1;i<=len2;i++) dp(i);
    for (int i=0;i<=m;i++) res+=ans[i];
    printf("%lld\n",res);return _4781;
}
```

---

## 作者：Ratio_Y (赞：4)

模拟赛出了 $k\le 30$ 的强化版，记录一下。


---

## 思路

神仙 dp。

设 $f_{i,j}$ 表示最大的 $x$ 使得 $S_{[1,x]}$ 与 $T_{[1,x+j]}$ 的编辑距离不大于 $i$。原因一个是 $k$ 很小，其次是如果 $S_{[1,x]}$ 能在 $i$ 次操作内成为 $T_{[1,x+j]}$，那么 $\forall x_0\in [1,x]$ 都满足。且合法的转移只会用到长度差不大于 $k$ 的串，因此状态数是 $k^2$ 级别的。

考虑如何转移，框架是枚举 $T$ 的后缀。我们所取的串一定是一段操作与不操作交替出现的串，那么转移实质上是去找不操作的一段，即相同的一段，直接二分 + hash 求 LCP 即可。然后枚举三种操作取 max 转移。

统计答案时对于每一个 $j$ 枚举到第一个值不小于 $n$ 的 $i$ 计入答案即可。

复杂度大概是 $\mathcal{O(nk^2\log n)}$ 的。

注意边界问题。

## 实现

```cpp
#include<bits/stdc++.h>
#define fo(x, y, z) for(int (x) = (y); (x) <= (z); (x)++)
#define fu(x, y, z) for(int (x) = (y); (x) >= (z); (x)--)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
#define lx ll
inline lx qr()
{
    char ch = getchar(); lx x = 0, f = 1;
    for(; ch < '0' || ch > '9'; ch = getchar()) if(ch == '-') f = -1;
    for(; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 3) + (x << 1) + (ch ^ 48);
    return x * f;
}
#undef lx
#define qr qr()
#define pii pair<int, int>
#define fi first
#define se second
#define M_P(x, y) make_pair(x, y)
#define P_B(x) push_back(x)
const int Ratio = 0;
const int N = 1e5 + 5;
const int mod = 998244353;
const int base = 233;
int k, n, m;
string s, t;
ull has[N], hat[N], bas[N];
int f[10][20], ans[10];
namespace Wisadel
{
    inline ull Wgs(int l, int r){return has[r] - has[l - 1] * bas[r - l + 1];}
    inline ull Wgt(int l, int r){return hat[r] - hat[l - 1] * bas[r - l + 1];}
    inline int Wlcp(int x, int y)
    {
        int l = 0, r = min(n - x + 1, m - y + 1);
        while(l <= r)
        {
            int mid = (l + r) >> 1;
            if(Wgs(x, x + mid - 1) == Wgt(y, y + mid - 1)) l = mid + 1;
            else r = mid - 1;
        }
        return l - 1;
    }
    short main()
    {
        // freopen("edit.in", "r", stdin), freopen("edit.out", "w", stdout);
        k = qr;
        cin >> s >> t;
        n = s.size(), m = t.size();
        s = " " + s;
        t = " " + t;
        bas[0] = 1;
        fo(i, 1, max(n, m)) bas[i] = bas[i - 1] * base;
        fo(i, 1, n) has[i] = has[i - 1] * base + (s[i] - 'a');
        fo(i, 1, m) hat[i] = hat[i - 1] * base + (t[i] - 'a');
        fo(S, 1, m)
        {
            fo(i, 0, k) fo(j, 0, 2 * k) f[i][j] = 0;
            f[0][k] = 0;
            fo(i, 0, k) fo(j, -i, i)
            {
                f[i][j + k] += Wlcp(f[i][j + k] + 1, f[i][j + k] + S + j);
                if(i != k)
                {
                    f[i + 1][j + k - 1] = max(f[i + 1][j + k - 1], min(f[i][j + k] + 1, n));
                    f[i + 1][j + k] = max(f[i + 1][j + k], min(f[i][j + k] + 1, n));
                    f[i + 1][j + k + 1] = max(f[i + 1][j + k + 1], f[i][j + k]);
                }
            }
            fo(j, max(-k, 1 - n), min(k, m - S - n + 1))
            {
                fo(i, 0, k) if(f[i][j + k] >= n){ans[i]++; break;}
            }
        }
        ll res = 0;
        fo(i, 0, k) res += ans[i];
        printf("%lld\n", res);
        return Ratio;
    }
}
signed main(){return Wisadel::main();}
// 佳墙坂诶迦币等渔塞
```



---

完结撒花~

[$Welcome\ to\ my\ blog$](https://www.cnblogs.com/Ratio-Yinyue1007)

---

## 作者：hh弟中弟 (赞：3)

加强版：[QOJ5312](https://qoj.ac/problem/5312)\
编辑距离确实是一个专有名词，可以使用 LCS 的思想来求解，$f_{i,j}$ 表示 A 串匹配到 $i$，B 串匹配到 $j$ 的最小距离，转移如下：
$$
\begin{aligned}
f_{i,j}=\begin{cases}
f_{i,j-1}+1&\text{Delete}\\
f_{i+1,j+1}+1&\text{Change}\\
f_{i+1,j}+1&\text{Add}
\end{cases}
\end{aligned}
$$
然后枚举起点就可以做到 $\mathcal{O}(n^3)$ 的复杂度。\
发现上面的东西必须要以 $n$ 为状态，几乎不可能优化，$k$ 很小一定有作用，换一种思路，$f_{i,j}$ 表示在 $i$ 次编辑后，满足 $S_{1\to x}$ 和 $T_{st\to x+j}$ 的最大的 $x$，求得之后直接统计等于 $|S|$ 的 $f_{i,j}$ 即可。为什么要把 $j$ 设计出来，可能在当前我不去匹配更优，所以类似与上面的式子，我需要知道两个串的具体位置，简单观察后发现，对于 $f_{i,j},f_{i,j}+st+j$ 的 $\text{LCP}$ 可以白嫖转移，就是自己转移自己，然后就是编辑操作依次考虑。
$$
\begin{aligned}
\begin{cases}
f_{i,j}\gets f_{i,j}+\text{LCP}(f_{i,j}+1,f_{i,j}+st+j)&\text{Free}\\
f_{i+1,j+1}\gets f_{i,j}&\text{Delete}\\
f_{i+1,j}\gets f_{i,j}+1&\text{Change}\\
f_{i+1,j-1}\gets f_{i,j}+1&\text{Add}
\end{cases}
\end{aligned}
$$
注意这里的操作都是在 T 串上的操作，对于 S 的操作，意义换一下式子也一样。$\text{LCP}$ 可以通过二分 + 哈希来处理，时间复杂度 $\mathcal{O}(nk^2\log n)$，理论过不了，但是跑不满，SA 可以 $\mathcal{O}(1)$ 处理 $\text{LCP}$，做到 $\mathcal{O}(nk^2)$ 的正确复杂度，最后枚举 $st$ 统计答案即可。

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
#define pii std::pair<int,int>
#define eb emplace_back
#define pb push_back
typedef long long ll;
typedef unsigned long long ull;
std::mt19937 myrand(std::chrono::high_resolution_clock::now().time_since_epoch().count());
inline int R(int n){return myrand()%n+1;}
inline int read(){char ch=getchar();int x=0,f=1;for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<3)+(x<<1)+(ch^48);return x*f;}
const int N=1e5+10,mod=998244353,inf=1e9,P=17771;
inline void Min(int &x,int y){if(x>y)x=y;}
inline void Max(int &x,int y){if(x<y)x=y;}
int K,n,m,f[35][70],ans[N];
ull hs[2][N],p[N];
char s[N],t[N];
inline int get(int l,int r,int id){return hs[id][r]-hs[id][l-1]*p[r-l+1];}
inline int LCP(int x,int y){
	if(x<0||x>n||y<0||y>m)return 0;
	int l=1,r=std::min(n-x+1,m-y+1),res=0;
	while(l<=r){
		int mid=l+r>>1;
		if(get(x,x+mid-1,0)==get(y,y+mid-1,1))l=mid+1,res=mid;
		else r=mid-1;
	}return res;
}
signed main(){
    // freopen("edit.in","r",stdin);freopen("edit.out","w",stdout);
    // freopen("in.in","r",stdin);freopen("out.out","w",stdout);
    std::ios::sync_with_stdio(false);std::cin.tie(0);std::cout.tie(0);
    std::cin>>K>>s+1>>t+1;n=strlen(s+1),m=strlen(t+1);
    p[0]=1;for(int i=1;i<=std::max(n,m);++i)p[i]=p[i-1]*P;
    for(int i=1;i<=n;++i)hs[0][i]=hs[0][i-1]*P+s[i]-'a'+1;
    for(int i=1;i<=m;++i)hs[1][i]=hs[1][i-1]*P+t[i]-'a'+1;
    for(int st=1;st<=m;++st){
    	for(int i=0;i<=K;++i)for(int j=0;j<=2*K;++j)f[i][j]=0;
    	f[0][K]=0;
    	for(int i=0;i<=K;++i)for(int j=-i;j<=i;++j){
    		f[i][j+K]+=LCP(f[i][j+K]+1,f[i][j+K]+st+j);
    		if(i!=K)
    			Max(f[i+1][j+K-1],std::min(f[i][j+K]+1,n)),
    			Max(f[i+1][j+K],std::min(f[i][j+K]+1,n)),
    			Max(f[i+1][j+K+1],f[i][j+K]);
    	}
    	for(int j=std::max(-K,1-n);j<=std::min(K,m-st-n+1);++j)
    		for(int i=0;i<=K;++i)if(f[i][j+K]>=n){ans[i]++;break;}
    }ll sum=0;for(int i=0;i<=K;++i)sum+=ans[i];
	std::cout<<sum<<'\n';
}
```

---

## 作者：Charlie_ljk (赞：2)

$O(n^3)$ DP 是显然的，对于两个串 $s,t$，设 $f_{i,j}$ 表示 $s$ 的前 $i$ 位和 $t$ 的前 $j$ 位匹配最少需要的操作数，有 $f_{i,j}=\min(f_{i-1,j}+1,f_{i,j-1}+1,f_{i-1,j-1}+[s_i\ne t_j])$，这个 DP 可以继承，所以是 $O(n^3)$ 的。

发现上面那个做法单次 DP 是 $O(n^2)$ 的因为 $n$ 很大，发现 $k$ 很小，考虑设计状态时改成和 $k$ 相关的，从而使单次复杂度变为 $O(k^2)$。

设 $f_{i,j}$ 表示操作 $i$ 次，二者长度差为 $j$ 时最大的匹配长度（$j$ 可以 $<0$）。

对于每一种状态确定了下一次匹配的起点，$s$ 的起点是 $f_{i,j}+1$，$t$ 的起点是 $f_{i,j}+j+1$，此时可以跳过一些已经匹配好的，即二者此时的最长公共前缀，这个是后缀数组板子，二分哈希也能做，即：

$$f_{i,j}=f_{i,j}+lcp(s[f_{i,j}+1,|s|],t[f_{i,j}+j+1,|t|])$$

接下来考虑转移：

$$
\begin{cases}
f_{i+1,j-1}=\max(f_{i+1,j-1},f_{i,j}+1)\\
f_{i+1,j}=\max(f_{i+1,j},f_{i,j}+1)\\
f_{i+1,j+1}=\max(f_{i+1,j+1},f_{i,j})\\
\end{cases}$$

分别对应添加、修改和删除操作。

由此枚举起点跑 DP 即可，发现 $i\in[0,k],j\in[-k,k]$，所以单次 DP 复杂度为 $O(k^2)$，总复杂度为 $O(nk^2)$（用二分哈希多个 $\log$），对于每个 $j$ 若存在 $f_{i,j}=|s|$ 则 $ans+1$，轻松最优解。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define endl '\n'
#define sort stable_sort
using namespace std;
const int N=1e5+10;
template<typename Tp> inline void read(Tp&x)
{
	x=0;register bool z=true;
	register char c=getchar_unlocked();
	for(;!isdigit(c);c=getchar_unlocked()) if(c=='-') z=0;
	for(;isdigit(c);c=getchar_unlocked()) x=(x<<1)+(x<<3)+(c^48);
	x=(z?x:~x+1);
}
template<typename T,typename ...Tp> inline void read(T &x,Tp &...y){read(x);read(y...);}
template<typename Tp> inline void wt(Tp x){if(x>9)wt(x/10);putchar_unlocked((x%10)+'0');}
template<typename Tp> inline void write(Tp x){if(x<0)putchar_unlocked('-'),x=~x+1;wt(x);}
template<typename T,typename ...Tp> inline void write(T x,Tp ...y){write(x);putchar_unlocked(' ');write(y...);}
int k,n,m,ans,f[7][12]; char s[N],t[N];
class suffix_array 
{
	private:
		int n,sa[N],rk[N],id[N],cnt[N],key[N],oldrk[N],height[N],mn[20][N];
		inline void count_sort(int n,int m)
		{
			memset(cnt,0,4*(m+1));
			for(int i=1;i<=n;i++) cnt[key[i]=rk[id[i]]]++;
			for(int i=1;i<=m;i++) cnt[i]+=cnt[i-1];
			for(int i=n;i;i--) sa[cnt[key[i]]--]=id[i];
		}
	public:
		inline void init(int len)
		{
			n=len; int m=27,w,tot=0,num=0;
			for(int i=1;i<=n;i++) rk[id[i]=i]=s[i]-'A'+1,key[i]=rk[id[i]];
			for(count_sort(n,m),w=1;w<n&&tot!=n;w<<=1,m=tot,num=0)
			{
				for(int i=n;i>=n-w+1;i--) id[++num]=i;
				for(int i=1;i<=n;i++) (sa[i]>w)&&(id[++num]=sa[i]-w);
				count_sort(n,m),memcpy(oldrk,rk,4*(n+1)),tot=0;
				for(int i=1;i<=n;i++)
					rk[sa[i]]=(tot+=(oldrk[sa[i]]!=oldrk[sa[i-1]]||oldrk[sa[i]+w]!=oldrk[sa[i-1]+w]));
			}
			for(int i=1,k=0;i<=n;i++) if(rk[i])
			{for(k-=!!k;s[i+k]==s[sa[rk[i]-1]+k];k++); height[rk[i]]=k;}
			memset(mn,0x3f,sizeof(mn));
			for(int i=1;i<=n;i++) mn[0][i]=height[i];
			for(int i=1;i<=__lg(n);i++) for(int j=1;j<=n;j++)
				mn[i][j]=min(mn[i-1][j],mn[i-1][j+(1<<(i-1))]);
		}
		inline int lcp(int l,int r,int t=0)
		{
			((l=rk[l])>(r=rk[r]))&&(l^=r^=l^=r),t=__lg(r-(++l)+1);
			return (!l||!r)?0:min(mn[t][l],mn[t][r-(1<<t)+1]);
		}
}sa;
inline int lcp(int x,int y) {return min({sa.lcp(x,n+y+1),n-x+1,m-y+1});}
inline void solve(int st)
{
	memset(f,-1,sizeof(f)),f[0][k]=0;
	for(int i=0;i<=k;i++) for(int j=0,h;j<=(k<<1);j++) 
		if(f[i][j]!=-1&&f[i][j]+(h=j-k)>=0&&st+f[i][j]+h-1<=m)
		{
			f[i][j]+=lcp(f[i][j]+1,st+f[i][j]+h);
			if(i==k) continue;
			(j)&&(f[i+1][j-1]=max(f[i+1][j-1],f[i][j]+(f[i][j]!=n)));
			f[i+1][j]=max(f[i+1][j],f[i][j]+(f[i][j]!=n));
			f[i+1][j+1]=max(f[i+1][j+1],f[i][j]);
		}
	for(int i=0;i<=(k<<1);i++) for(int j=0;j<=k;j++)
		if(f[j][i]==n&&i-k+n>0&&st+i-k+n-1<=m) {ans++; break;}
}
signed main()
{
	read(k),scanf("%s%s",s+1,t+1),n=strlen(s+1),m=strlen(t+1);
	s[n+1]='[',strcat(s+1,t+1),sa.init(n+m+1);
	for(int i=1;i<=m;i++) solve(i); write(ans);
}
```

---

## 作者：JoaoFelix (赞：1)

考虑编辑距离，我们考虑暴力的算法是暴力dp，复杂度很大，但是核心思路是一致的。

暴力dp的核心无非就三种转移。然后我们由于限制的编辑距离不大，因此我们可以DFS暴力来枚举转移，然后求出符合条件的位置即可！

我们考虑具体转移就是每次记录x和y然后暴力转移向加上它们的lcp即可，这里的lcp可以通过建立SuffixArray，然后求出height来O(1)求出（常数不大，就ST表的查询）

（以下把x和y看做坐标，两个pos分别是x和y在坐标上移动，暴力来完成这个dp的过程）
剩下来我们考虑三种转移分别是(x + 1, y + 1), (x + 1, y), (x, y + 1)，随后我们会发现一个问题，为什么一定是加一呢？如果我们是删除操作呢，我们假设是x的坐标删除即是(x - 1, y)发现和(x, y + 1)是一一对应的，因此肯定没有(x, y + 1)优，因此我们可证这种情况是包含在我们的考虑范围内的，同理y坐标也可证。

最后我们会发现当字符串s已经完成匹配的时候但是t可能次数不一定到达限制的k，但是实际上我们有一种情况是删除t中以匹配的若干个字符，我们这里可以在达到限制的时候特判一下这种情况，然后多一个状态为(x, y - 1)就可以了（其实有边界比较复杂的O(1)求解的做法，大概是一个区间都是满足条件的，然后统计区间差分下就可以了，但是作者为了防止边界等多种情况就没有写），因此复杂度稍大

最终时间复杂度O((n + m) log (n + m) + (n + m) * (4 ^ 5))2s能过

实际(4 ^ 5)是卡不满的，因为只要当一个匹配完成了以后才会有第4种转移，卡不满再加上ST表的超小常数代码几乎和标算差不多快（~~其实就是标算~~）

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

inline int read() {
	char c = getchar(); int x = 0, f = 1;
	while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * f;
}

const int N = 100005;

int k, n, m, c[N], rs[N], rt[N];
int stk[N], tp; char s[N], t[N];

struct SuffixArray {
	int buc[N], sa[N], rk[N], fir[N], sec[N]; int hei[N], lg[N], mn[N][21];
	
	int LCP(int x, int y) {
		int l = rk[x], r = rk[y];
		if (l > r) swap(l, r); r--;
		int tt = lg[r - l + 1];
		return min(mn[l][tt], mn[r - (1 << tt) + 1][tt]);
	}
	void suffix_sort(int n) {
		for (int i = 1; i <= n; i++) buc[c[i]]++;
		for (int i = 1; i < N; i++) buc[i] += buc[i - 1];
		for (int i = n; i >= 1; i--) sa[buc[c[i]]--] = i;
		rk[sa[1]] = 1;
		for (int i = 2; i <= n; i++) rk[sa[i]] = rk[sa[i - 1]] + (c[sa[i]] != c[sa[i - 1]]);
		for (int k = 1; k <= n; k <<= 1) {
			for (int i = 1; i <= n; i++) fir[i] = rk[i], sec[i] = (i + k <= n ? rk[i + k] : 0);
			memset(buc, 0, sizeof(buc));
			for (int i = 1; i <= n; i++) buc[sec[i]]++;
			for (int i = 1; i <= n; i++) buc[i] += buc[i - 1];
			for (int i = n; i >= 1; i--) rk[buc[sec[i]]--] = i;
			memset(buc, 0, sizeof(buc));
			for (int i = 1; i <= n; i++) buc[fir[i]]++;
			for (int i = 1; i <= n; i++) buc[i] += buc[i - 1];
			for (int i = n; i >= 1; i--) sa[buc[fir[rk[i]]]--] = rk[i];
			rk[sa[1]] = 1;
			for (int i = 2; i <= n; i++) rk[sa[i]] = rk[sa[i - 1]] + (fir[sa[i]] != fir[sa[i - 1]] || sec[sa[i]] != sec[sa[i - 1]]);
		}
	}
	void get_height(int n) {
		int len = 0;
		for (int i = 1; i <= n; i++) {
			if (len) len--; if (rk[i] == n) continue;
			int pos = sa[rk[i] + 1];
			while (i + len <= n && c[i + len] == c[pos + len]) len++;
			hei[rk[i]] = len;
		}
		lg[0] = -1;
		for (int i = 1; i < n; i++) mn[i][0] = hei[i], lg[i] = lg[i >> 1] + 1;
		for (int k = 1; k <= 20; k++)
			for (int i = 1; i + (1 << k) - 1 < n; i++) mn[i][k] = min(mn[i][k - 1], mn[i + (1 << k - 1)][k - 1]);
	}
} SA;

void DFS(int dep, int ps, int pt) {
	if (dep > k) return; 
	if (ps <= n && pt <= m) {
		int lcp = SA.LCP(rs[ps], rt[pt]);
		ps += lcp, pt += lcp;
	}
	if (ps == n + 1) {
		stk[++tp] = pt;
		if (pt > 1) DFS(dep + 1, ps, pt - 1); 
	}
	if (ps <= n && pt <= m) DFS(dep + 1, ps + 1, pt + 1);
	if (ps <= n) DFS(dep + 1, ps + 1, pt);
	if (pt <= m) DFS(dep + 1, ps, pt + 1);
}

int main() {
	k = read(); scanf("%s", s + 1); scanf("%s", t + 1);
	n = strlen(s + 1); m = strlen(t + 1); int len = 0;
	for (int i = 1; i <= n; i++) {
		c[++len] = s[i] - 'A' + 1; rs[i] = len; 
	}
	c[++len] = 27;
	for (int i = 1; i <= m; i++) {
		c[++len] = t[i] - 'A' + 1; rt[i] = len;
	}
	SA.suffix_sort(len), SA.get_height(len);
	ll ans = 0;
	for (int i = 1; i <= m; i++) {
		tp = 0, DFS(0, 1, i);
		sort(stk + 1, stk + tp + 1), tp = unique(stk + 1, stk + tp + 1) - stk - 1;
		ans += (ll)tp;
	}
	printf("%lld\n", ans); 
	return 0;
}

```


---

## 作者：detect (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P5479)

---

找遍全网（力所能及的范围）都用的$SA$实现，对于我这种学了$SAM$就懒地搞$SA$的同学非常不友好，于是写下这篇用$SAM$实现的题解以供后人学习。

---
注意到$k$非常小，不难想到暴力搜出用完$k$次操作后能匹配的最短位置，这样我们就可以得到一个合法的范围，统计这些范围的并就是答案。

因为只有出现不能匹配的字符串才需要操作，现在思考能不能加速匹配到不能匹配的这个过程。

抽象出来就是要求两个后缀的最长公共前缀，这个前缀很难搞，我们倒着建立$SAM$，这样相当于求两个前缀的最长公共后缀，这样在广义后缀自动机上相当于求两个底层节点的后缀链接的$lca$。（可以提前预处理后$O(1)$查询）

故使用$SAM$加速后每次dfs都会使得次数$+1$,这样总共迭代次数为$O(3^5)$，单次复杂度为$O(1)$，总共要枚举每一个位置dfs最多$1e5$次。

故总时间复杂度为$O(nlogn+3^5n)$。

code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int M=1e6+5;
int T,lens,lent,n,k,tot=1,ed=1,lg[M],re[M],minn[M][21],re1[M],re2[M],cnt[M];

struct SAM{
	int mp[M][30],no,fa[M],len[M],etot,dep[M],head[M],nex[M],go[M],dfn[M],st[M];
	void Insert(int c,int pos){
		int p=ed;ed=++tot;len[ed]=pos;re[pos]=ed;
		for(;p&&mp[p][c]==0;p=fa[p]) mp[p][c]=ed;
		if(!p){
			fa[ed]=1;return;
		}
		int q=mp[p][c];
		if(len[q]==len[p]+1){
			fa[ed]=q;return;
		}
		++tot;len[tot]=len[p]+1;
		for(int i=0;i<=26;i++) mp[tot][i]=mp[q][i];
		fa[ed]=tot;fa[tot]=fa[q];fa[q]=tot;
		for(;p&&mp[p][c]==q;p=fa[p]) mp[p][c]=tot;
	}
	
	inline void Addedge(int u,int v){
		nex[++etot]=head[u];head[u]=etot;go[etot]=v;
	}
	void dfs(int u){
		dfn[++no]=u;st[u]=no;
		for(int i=head[u];i;i=nex[i]){
			int v=go[i];dep[v]=dep[u]+1;dfs(v);dfn[++no]=u;
		}
	}
	inline void Build_G(){
		for(int i=2;i<=tot;i++) Addedge(fa[i],i);
		dfs(1);
	}
	
	inline int Min(int x,int y){return dep[x]<dep[y]?x:y;}
	void Build_ST(){
		for(int i=1;i<=no;i++) minn[i][0]=dfn[i];
		for(int i=1;i<=lg[tot*2];i++)
		  for(int j=1;j+(1<<i)-1<=tot*2;j++)
		  	minn[j][i]=Min(minn[j][i-1],minn[j+(1<<(i-1))][i-1]);
	}
	inline int Getlca(int x,int y){
		if(st[x]>st[y]) swap(x,y);
		int l=st[x],r=st[y],k=lg[r-l+1];
		return Min(minn[l][k],minn[r-(1<<k)+1][k]);
	}
	inline int Lcp(int x,int y){return len[Getlca(x,y)];}
}sam;

void dfs(int x,int y,int z){
	if(z>k) return;
	int lcp=sam.Lcp(re[re1[x]],re[re2[y]]);
	x+=lcp;y+=lcp;
	if(x==lens||y==lent){
		int d=k-z-(lens-x);
		if(d<0) return;
		int l=max((int)0,y-T-d),r=min(lent-1,y-T+d);
		cnt[l]++;cnt[r+1]--;return;
	}
	dfs(x+1,y+1,z+1);
	dfs(x+1,y,z+1);
	dfs(x,y+1,z+1);
}

string s,t;
signed main(){
	cin>>k>>s>>t;
	lens=s.size(),lent=t.size();
	for(int i=0;i<lens;i++) re1[i]=lent+lens+1-i;
	for(int i=0;i<lent;i++) re2[i]=lent-i;
	s=s+"#";s=s+t;
	
	for(int i=2;i<=1000000;i++) lg[i]=lg[i>>1]+1;
	int len=s.size();
	for(int i=len-1;i>=0;i--){
		if(s[i]=='#') sam.Insert(26,len-i);
		else sam.Insert(s[i]-'A',len-i);
	}
	sam.Build_G();sam.Build_ST();
	
	int L=max((int)0,lens-k),R=min(lent,lens+k);
	int ans=0;
	for(int i=0;i<lent;i++){
		T=i;
		dfs(0,i,0);
		for(int i=L;i<=R;i++){
			cnt[i]+=cnt[i-1];
		}
		for(int i=L;i<=R;i++) if(cnt[i]) ans++,cnt[i]=0;
	}
	
	cout<<ans<<endl;
	return 0; 
}
```


---

## 作者：hzoi_Shadow (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5479)

# 前置知识

[后缀数组简介](https://oi-wiki.org/string/sa/) | [字符串哈希](https://oi-wiki.org/string/hash/) | [二分](https://oi-wiki.org/basic/binary/)

# 解法

考虑分别计算出编辑距离恰好等于 $k_{0} \in [0,k]$ 的答案。

观察在编辑距离的存在下，长度差至多为 $k$。

考虑设 $f_{i,j}$ 表示最大的 $x$ 使得 $s_{1 \sim x}$ 和 $t_{1 \sim x+j}$ 可以在 $i$ 次编辑内得到，即从 $1$ 开始操作 $i$ 次且长度增加 $j$ 的最大匹配位置。
  - 显然 $x,i$ 具有单调性。

转移时考虑截取一段 $t$ 的后缀进行转移。

假设已经操作完了，那么 $f_{i,j}$ 能向外延伸的就是 $s_{f_{i,j}+1,|s|}$ 和 $t_{f_{i,j}+j+1,|t|}$ 的公共前缀，查询 $\operatorname{LCP}$ 进行更新即可。

$\operatorname{LCP}$ 可以用二分哈希单次 $O(\log n)$ 查询，也可以后缀数组 $O(n \log n)$ 预处理完 $O(1)$ 查询。
转移时考虑刷表，分别对 $f_{i+1,j-1},f_{i+1,j},f_{i+1,j+1}$ 进行转移（三者分别对应删除、替换、添加）。
  - 注意下标为负数时的移位。


统计贡献时在遇到第一个合法的 $i$ 加入贡献即可。

如果用后缀数组的话时间复杂度为 $O(nk^{2}+n \log n)$。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
int f[15][25],ans[15];
char s[100010],t[100010],tmp[100010];
struct SA
{
	struct ST
	{
		int fminn[100010][25];
		void init(int n,int a[])
		{
			memset(fminn,0x3f,sizeof(fminn));
			for(int i=1;i<=n;i++)
			{
				fminn[i][0]=a[i]; 
			}
			for(int j=1;j<=log2(n);j++)
			{
				for(int i=1;i+(1<<j)-1<=n;i++)
				{
					fminn[i][j]=min(fminn[i][j-1],fminn[i+(1<<(j-1))][j-1]);
				}
			}
		}
		int query(int l,int r)
		{
			if(l>r)
			{
				swap(l,r);
			}
			l++;
			int t=log2(r-l+1);
			return min(fminn[l][t],fminn[r-(1<<t)+1][t]);
		}
	}T;
	int sa[100010],rk[200010],oldrk[200010],id[100010],cnt[100010],key[100010],height[100010];
	int val(char x)
	{
		return (int)x;
	}
	void counting_sort(int n,int m)
	{
		memset(cnt,0,sizeof(cnt));
		for(int i=1;i<=n;i++)
		{
			cnt[key[i]]++;
		}
		for(int i=1;i<=m;i++)
		{
			cnt[i]+=cnt[i-1];
		}
		for(int i=n;i>=1;i--)
		{
			sa[cnt[key[i]]]=id[i];
			cnt[key[i]]--;
		}
	}
	void init(char s[],int len)
	{
		int m=127,tot=0,num=0;
		for(int i=1;i<=len;i++)
		{
			rk[i]=val(s[i]);
			id[i]=i;
			key[i]=rk[id[i]];
		}
		counting_sort(len,m);
		for(int w=1;tot!=len;w<<=1,m=tot)
		{
			num=0;
			for(int i=len;i>=len-w+1;i--)
			{
				num++;
				id[num]=i;
			}
			for(int i=1;i<=len;i++)
			{
				if(sa[i]>w)
				{
					num++;
					id[num]=sa[i]-w;
				}
			}
			for(int i=1;i<=len;i++)
			{
				key[i]=rk[id[i]];
			}
			counting_sort(len,m);
			for(int i=1;i<=len;i++)
			{
				oldrk[i]=rk[i];
			}
			tot=0;
			for(int i=1;i<=len;i++)
			{
				tot+=(oldrk[sa[i]]!=oldrk[sa[i-1]]||oldrk[sa[i]+w]!=oldrk[sa[i-1]+w]);
				rk[sa[i]]=tot;
			}
		}
		for(int i=1,j=0;i<=len;i++)
		{
			j-=(j>=1);
			while(s[i+j]==s[sa[rk[i]-1]+j])
			{
				j++;
			}
			height[rk[i]]=j;
		}
		T.init(len,height);
	}
	int lcp(int x,int y)
	{
		return T.query(rk[x],rk[y]);
	}
}S;
int main()
{
	int k,lens,lent,sum=0,i,j,h;
	cin>>k>>(s+1)>>(t+1);
	lens=strlen(s+1);
	lent=strlen(t+1);
	for(i=1;i<=lens;i++)
	{
		tmp[i]=s[i];
	}
	tmp[lens+1]='&';
	for(i=1;i<=lent;i++)
	{
		tmp[lens+1+i]=t[i];
	}
	S.init(tmp,lens+1+lent);
	for(h=1;h<=lent;h++)
	{	
		memset(f,-0x3f,sizeof(f));
		f[0][k]=0;
		for(i=0;i<=k;i++)
		{
			for(j=-k;j<=k;j++)
			{
				if(f[i][j+k]>=0&&f[i][j+k]+j>=0&&f[i][j+k]+j+h-1<=lent)
				{
					if(f[i][j+k]+1<=lens&&f[i][j+k]+j+1+h-1+lens+1<=lens+1+lent)
					{
						f[i][j+k]+=S.lcp(f[i][j+k]+1,f[i][j+k]+j+1+h-1+lens+1);
					}
					if(j-1+k>=0)
					{
						f[i+1][j-1+k]=max(f[i+1][j-1+k],f[i][j+k]+(f[i][j+k]!=lens));
					}
					f[i+1][j+k]=max(f[i+1][j+k],f[i][j+k]+(f[i][j+k]!=lens));
					f[i+1][j+1+k]=max(f[i+1][j+1+k],f[i][j+k]);
				}
			}
		}
		for(j=-k;j<=k;j++)
		{
			for(i=0;i<=k;i++)
			{
				if(f[i][j+k]==lens&&lens+j>0&&lens+j+h-1<=lent)
				{
					ans[i]++;
					break;
				}
			}
		}
	}
	for(i=0;i<=k;i++)
	{
		sum+=ans[i];
	}
	cout<<sum<<endl;
	return 0;
}
```

# 后记

多倍经验：[QOJ 5312.Levenshtein Distance](https://qoj.ac/problem/5312)

---


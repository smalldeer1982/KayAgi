# [BJOI2015] 糖果

## 题目背景

Alice 正在教她的弟弟 Bob 学数学。 

## 题目描述

每天，Alice 画一个 $n$ 行 $m$ 列的表格，要求 Bob 在格子里填数。 

Bob已经学会了自然数 $1$ 到 $k$ 的写法。因此他在每个格子里填 $1 \sim k$ 之间的整数。 

Alice 告诉 Bob，如果 Bob 填写完表格的 $n \times m$ 个数以后，每行的数从第 $1$ 列到第 $m$ 列单调不减，并且任意两行至少有一列的数不同，而且以前 Bob 没有填写过相同的表格，那么 Alice 就给 Bob 吃一颗糖果。 

Bob想知道，如果每天填写一遍表格，最多能吃到多少颗糖果。 

答案对 $p$ 取模。


## 说明/提示

#### 样例输入输出 1 解释

共有 $10$ 种方案，取模后为 $0$。

---

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 10^5$，$1 \leq k,p \leq 2 \times 10^9$。

## 样例 #1

### 输入

```
1 3 3 10```

### 输出

```
0```

## 样例 #2

### 输入

```
2 2 2 10```

### 输出

```
6```

# 题解

## 作者：一扶苏一 (赞：11)

## 【组合计数】P5481 [BJOI2015] 糖果

### Description

给定 $n ,m, k$，求满足如下条件的 $n$ 行 $m$ 列的矩形的个数：

- 矩形中都是不超过 $k$ 的正整数。
- 任取矩形中的一行，改行中的 $m$ 个数从左至右单调不下降。

两个矩形不同当且仅当至少存在一个位置不同。答案对 $p$ 取模，**不保证** $p$ 是质数。

$1 \leq n, m \leq 10^5$，$1 \leq k, p \leq 10^9$。

### Solution

计数杀我。

首先注意到每一行都是独立的，因此我们只需要求出长度为 $m$ 的值域为 $[1, k]$ 的不下降序列的方案数 $s$，在其中任选 $n$ 个进行排列都能得到一种新的矩形。总方案数为 $A_{s}^n$，我们考虑求 $s$。

注意到因为序列是单调不降的，所以我们只需要确定每个数在序列中出现了几次，就可以唯一确定这个序列。这个问题等价于下面这个问题：

有 $m$ 个小球和 $k$ 个盒子，小球全部相同而盒子互不相同，盒子可以为空，求将所有小球放入盒子的方案数。

事实上，一个盒子 $a$ 里面有 $b$ 个球对应着这个序列里有 $b$ 个值为 $a$ 的数。

这是一个经典问题，盒子可以为空的限制看起来比较烦人，我们考虑先给每个盒子都扔进去一个小球，也即求 $(m + k)$ 个小球扔进 $k$ 个盒子且盒子不能为空的方案数。

考虑新问题（即不能为空）的每种方案，从每个盒子中都拿掉一个球，一定唯一对应着原问题（可以为空）的一种方案，而对于原问题的一个方案，向每个盒子都扔进去一个球，得到的方案一定唯一对应着新问题对应该方案的方案。因此这两个问题的方案是一一对应的。

我们可以递推求解新问题：设 $f_{i, j}$ 是放了 $i$ 个球，放在了前 $j$ 个盒子里的方案数。能转移到该状态的只有两种情况：$i$ 放到一个新盒子，$i$ 放到一个已经有球的盒子。因此

$$f_{i, j} = f_{i - 1, j - 1} + f_{i - 1, j}$$

初始条件为 $f_{1, 1} = 1$。

注意到这个递推式与组合数递推式（pascal 公式）**完 全 一 致**，因此所求即为 $C_{m + k}^k$？

注意到这个三角形与杨辉三角不一致的地方在于 $f_{0, 1} = 0$，也即相当于三角形整体向右向下移动各了一个单位，所以所求实际上应该是 $C_{m + k - 1}^{k - 1}$。

$k$ 太大了不好算，根据杨辉三角的对称性，所求即为 $C_{m + k - 1}^{m + k - 1 - k + 1} = C_{m + k - 1}^m$。

下一个问题是，我们求出来的 $s$ 是作为 $A$ 的下角标存在的，而这个数取模以后似乎就丧失了直观组合意义。

考虑

$$A_{s}^{n} = \frac{s!}{(s - n)!} = s \times (s - 1)\times \dots \times(s - n + 1) = \prod\limits_{i = 0}^{n - 1} (s - i)$$

注意到，要求 $A_{s}^n$ 在模 $p$ 下结果，由于结果是一个连乘式，所以是可以直接对 $s$ 进行取模的，只需要计算模意义下 $(s - i)$ 的值即可。

现在考虑求 $C_{m + k - 1}^m$。由于 $p$ 不是质数，无法直接求阶乘逆元，考虑计算过程本身

$$C_{m + k - 1}^m = \frac{(m + k - 1)!}{m! (k - 1)!}$$

注意到 $m$ 非常小，而 $\frac{(m + k - 1)!}{(k - 1)!} = \prod\limits_{i = 0}^{m - 1} k + i$，我们考虑直接对 $m!$ 分解质因数，然后从连乘式中逐项除掉对应的质因子即可。

时间复杂度 $O(m \log m + n)$。

### Code

```cpp
const int maxn = 100005;

int n, m, k, p;

int calc();

int main() {
  freopen("1.in", "r", stdin);
  qr(n); qr(m); qr(k); qr(p);
  if (p == 1) {
    puts("0");
    return 0;
  }
  qw(calc(), '\n', true);
  return 0;
}

int pcnt;
int prm[maxn], pre[maxn];
bool np[maxn];
void Getp(const int x) {
  for (int i = 2; i <= x; ++i) {
    if (!np[i]) {
      pre[prm[++pcnt] = i] = i;
    }
    for (int j = 1, k; j <= pcnt; ++j) if ((k = i * prm[j]) <= x) {
      np[k] = true;
      pre[k] = prm[j];
      if ((i % prm[j]) == 0) {
        break;
      }
    } else {
      break;
    }
  }
}

int a[maxn], b[maxn];
int calc() {
  Getp(m);
  for (int i = 0; i < m; ++i) {
    a[i] = i + k;
    int t = i + 1;
    while (t != 1) {
      ++b[pre[t]];
      t /= pre[t];
    }
  }
  int dk = k - 1;
  for (int i = 2; i <= m; ++i) if (!np[i]) {
    for (int j = (dk / i + 1) * i - k; b[i]; j += i) while ((a[j] % i) == 0) {
      a[j] /= i;
      if (--b[i] == 0) break;
    }
  }
  ll s = 1, ret = 1;
  for (int i = 0; i < m; ++i) (s *= a[i]) %= p;
  for (int i = 0; i < n; ++i) {
    (ret *= (s - i + p)) %= p;
  }
  return ret;
}
```



---

## 作者：Delusions_grandeur (赞：5)

详细讲讲怎么求 $ C_{m+k-1}^{m}=\frac{(m+k-1)...(k+1)k}{m!} $ 取模 $p$ 的值。

对分子和分母提取出一个质因数集合，相同的约掉再用快速幂求积。若一段区间中最大的数为 $M$ ，筛一段区间的质数可以用 $ S=(1 ,2,3, \dots,\sqrt{M}) $
 中的质数来筛。

这样可以将这段区间中所有小于 $\sqrt{M}$ 的因数筛掉，但大于 $\sqrt{M}$ 的可能没筛掉(比如区间内的质数)，但这没关系，我们先处理分母，当存在因子大于 $m$ 时一定不会被分子约掉，直接乘入答案即可。

令 $all=C_{m+k-1}^{m}$ 则 $ans=A_{all}^{n}$ 。楼下已经讲得很清楚了，不再赘述。

瓶颈在于筛分子分母，考虑每个数的质因数指数至多 $log_{2}SIZE$ 个，均摊下来时间复杂度 $O(mlog_{2}SIZE)$ 。
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5;
ll n,m,k,mod;
ll mark[N+5],p[N+5],tot,num[N+5],all=1,ans=1,a[N+5];
void pre(ll x)
{
	for(ll i=2; i<=x; i++)
		if(!mark[i]) {p[++tot]=i;for(int j=2; j<=x/i; j++) mark[i*j]=1;}
}
ll KSM(ll a,ll b)
{
	ll ret=1;
	while(b)
	{
		if(b&1) ret=1ll*ret*a%mod;
		a=1ll*a*a%mod;b>>=1ll;
	}
	return ret;
}
int main()
{
	scanf("%lld%lld%lld%lld",&n,&m,&k,&mod);pre(N);
	for(ll i=1; i<=tot; i++)
	{
		ll t=p[i];if(t>m) break;
		for(ll j=t; j<=m; j*=t) num[i]-=m/j;
	}
	for(int i=0; i<=m-1; i++) a[i]=i+k;
	for(ll i=1; i<=tot; i++)
	{
		ll t=p[i];
		for(ll j=k/t*t; j<=k+m-1; j+=t)
			if(j>=k)
			{
				ll &val=a[j-k];
				if(t<=m) while(val%t==0) num[i]++,val/=t;
				else while(val%t==0) all=all*t%mod,val/=t;
			}
	}
	for(ll i=1; i<=tot; i++) all=all*KSM(p[i],num[i])%mod;
	for(int i=0; i<=m-1; i++) all=all*a[i]%mod;
	//求出了all 
	
	for(ll i=0; i<n; i++) ans=ans*(all-i+mod)%mod;
	printf("%lld",ans); 
	return 0;
}
```

---

## 作者：weilycoder (赞：2)

提供另一种处理组合数的方法。

简单转换一下题意，假设已经计算出每行的方案数 $s$，显然只需计算 $s$ 取 $n$ 的排列数 $A_{s}^{n}$，由排列数的定义式，显然这里 $s$ 可以取模。

再注意到由于每行是按单调不降排序的，只需要考虑每个数出现了几次，使用隔板法得到

$$
s = C_{m+k-1}^{m}=\dfrac{(m+k-1)(m+k-2)\cdots k}{m!}
$$

由于本文重点是提供另一种计算以上式子的方法，因此推导部分写得比较简略，你可以参考其他题解。

其他题解都选择对 $s$ 的分母进行质因数分解，再使用类似筛法的过程从序列 $k,k+1,\cdots,k+m-1$ 中除掉这些质因数。

~~筛法太高级了，我想不到~~

但是，我们发现这些质因数并不都需要用到，实际上，我们可以只处理 $p$ 的质因子。

例如，假设 $p=p_1^{c_1}p_2^{c_2}\dots$，我们可以将 $s=\dfrac{a}{b}$ 写成类似这样的形式：

$$
s=\dfrac{a'p_1^{x_1}p_2^{x_2}\dots}{b'p_1^{y_1}p_2^{y_2}\dots}
$$

显然 $b'$ 与 $p$ 互质，因为不互质的部分已经被提出来了。这样 $\dfrac{a'}{b'}$ 部分可以直接求 $b'$ 的逆元计算；后半部分有 $\dfrac{p_1^{x_1}p_2^{x_2}\dots}{p_1^{y_1}p_2^{y_2}\dots}=p_1^{x_1-y_1}p_2^{x_2-y_2}\dots$。 

参考代码：

~~提出 $p$ 的质因子的部分也可以用类似筛法的形式做，但我不是没想到筛法吗~~

```cpp
#include <bits/stdc++.h>
using namespace std;

void exgcd(int64_t a, int64_t b, int64_t &x, int64_t &y) {
  if (!b)
    return x = 1, y = 0, void();
  exgcd(b, a % b, y, x);
  y -= a / b * x;
}

int64_t inv(int64_t a, int64_t p) {
  int64_t x, y;
  exgcd(a, p, x, y);
  return (x % p + p) % p;
}

size_t fast_pow(size_t a, size_t b, size_t p) {
  size_t res = 1;
  for (; b; b >>= 1, a = a * a % p)
    if (b & 1)
      res = res * a % p;
  return res;
}

vector<size_t> get_p(size_t p) {
  vector<size_t> res;
  for (size_t i = 2; i * i <= p; ++i) {
    if (p % i == 0)
      res.push_back(i);
    while (p % i == 0)
      p /= i;
  }
  if (p > 1)
    res.push_back(p);
  res.shrink_to_fit();
  return res;
}

size_t comb(size_t n, size_t m, size_t p) {
  auto primes = get_p(p);
  size_t res = 1, b = 1;
  vector<size_t> exp(primes.size());
  for (size_t i = 0; i < m; ++i) {
    size_t x = n - i;
    for (size_t j = 0; j < primes.size(); ++j) {
      while (x % primes[j] == 0) {
        x /= primes[j];
        ++exp[j];
      }
    }
    res = res * x % p;
  }
  for (size_t i = 1; i <= m; ++i) {
    size_t x = i;
    for (size_t j = 0; j < primes.size(); ++j) {
      while (x % primes[j] == 0) {
        x /= primes[j];
        --exp[j];
      }
    }
    b = b * x % p;
  }
  res = res * inv((int64_t)b, p) % p;
  for (size_t i = 0; i < primes.size(); ++i)
    if (exp[i])
      res = res * fast_pow(primes[i], exp[i], p) % p;
  return res;
}

size_t perm(size_t n, size_t m, size_t p) {
  size_t res = 1;
  for (size_t i = 0; i < m; ++i)
    res = res * (p + n - i) % p;
  return res;
}

int main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  size_t n, m, k, p;
  cin >> n >> m >> k >> p;
  size_t s = comb(k + m - 1, m, p);
  cout << perm(s, n, p) << '\n';
  return 0;
}
```

---

## 作者：Fzrcy (赞：2)

明显的，每一行的填法与其他行没有太大关系（只需保证两行的填法不完全相同就行），所以只需考虑用 $[0,k]$ 的数字填满行的方案数 $ans$，最终答案为 $A_{ans}^n$。

明显地，我们只需知道该行填那几个数，以及每个数填多少就能唯一确定一个填法。

形式化的，该问题等价于将 $m$ 个小球放入 $k$ 个有标号盒子中的方案数。我们发现有的盒子可能没有一个小球，妨碍计算，于是我们强制使得每个盒子最少有一个小球，此时小球的数量变为 $m+k$。

设 $f_{i,j}$ 为 $j$ 个小球放入 $i$ 个盒子的方案数。有状态转移方程：

$$
f_{i,j}=f_{i-1,j-1}+f_{i,j-1}
$$

即 $\binom{m+k-1}{k-1}=\binom{m+k-1}{m}$。

然而 $p$ 不一定为质数，无法预处理阶乘逆元，考虑质因数分解 $m!$，并在 $k,k+1,\dots,m+k-1$ 中除去即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N=2e5+1;
ll n, m, k, mo, pr[N], pc, vis[N], ci[N], a[N];
void sieve(int tot){
    vis[1]=1;
    for(int i=2; i<=tot; i++){
        if(!vis[i]) vis[i]=i, pr[++pc]=i;
        for(int j=1; j<=pc&&1ll*pr[j]*i<=tot; j++){
            vis[i*pr[j]]=pr[j];
            if(i%pr[j]==0) break;
        }
    }
}
int main(){
    scanf("%lld %lld %lld %lld", &n, &m, &k, &mo);
    if(mo==1){puts("0"), exit(0);}
    sieve(m);
    for(int i=0; i<m; i++){
        a[i]=k+i;
        int j=i+1;
        while(j>1)
            ci[vis[j]]++,
            j/=vis[j];
    }
    for(int i=2; i<=m; i++){
        if(vis[i]!=i) continue;
        int x=(k/i)*i;
        if(x<k) x+=k;
        for(int j=((k-1)/i+1)*i-k; j<=m&&ci[i]; j+=i)
            while(ci[i]&&a[j]%i==0)
                ci[i]--, a[j]/=i;
    }
    int ans=1, res=1;
    for(int i=0; i<m; i++)
        ans=1ll*ans*a[i]%mo;
    for(int i=0; i<n; i++)
        res=1ll*res*(ans-i+mo)%mo;
    cout<<res<<'\n';
    return 0;
}
```



---

## 作者：Rorschachindark (赞：2)

# 糖果
## 思路
$\ \ \ \ \ \ $ 我们设$s$为把$1\to k$放到$[1,m]$之中，$1\to k$中可以有些不选的方案数，不难看出这道题的答案就是$A_{s}^{n}$。

$\ \ \ \ \ \ $ 那怎么算$s$呢？我们可以把这个东西转换一下模型，变成：把$m$个小球放到$k$个盒子中，盒子可以为空的方案数。

$\ \ \ \ \ \ $ 为什么两个问题是等价的呢？这里简单说明一下，可以想象成，一个盒子$a$里面放有$b$个小球，就相当于在序列中出现了$b$个$a$。

$\ \ \ \ \ \ $ 那上面那个模型怎么算呢？很简单，首先考虑到盒子可以为空的缘故，我们先一开始每个盒子都放入一个小球，然后就相当于把$m+k$放入$k$个盒子中每个盒子必放的方案数，这个直接用插板法可以算出:

$$s=C_{m+k-1}^{k-1}=\frac{1}{m!}\prod_{i=0}^{m-1} (k+i)$$

$\ \ \ \ \ \ $ 但是这道题的$p$不一定为质数，所以我们不能直接用逆元。那我们怎么算$s$呢？其实，我们可以直接分解质因数，然后分子分母抵消就好了。算分母的时候因为是阶乘所以可以用$\text {Legendre}$定理优化一下，但是对总时间复杂度还是不影响的。

$\ \ \ \ \ \ $ 然后。。。就完了

## $\text {Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define ll long long
#define MAXN 100005

int tot;
int prime[MAXN];

bool vis[MAXN];

void Prime (int n)
{
	for (Int i = 2;i <= n;++ i)
	{
		if (!vis[i]) prime[++ tot] = i;
		for (Int j = 1;j <= tot && (int)i * prime[j] <= n;++ j)
		{
			vis[i * prime[j]] = 1;
			if (i % prime[j] == 0) break;
		}
	}
}

ll up[MAXN],Index[MAXN];

int n,m,k,p;

int read ()
{
	int x = 0;char c = getchar();int f = 1;
	while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}
	while (c >= '0' && c <= '9'){x = (x << 3) + (x << 1) + c - '0';c = getchar();}
	return x * f;
}

void write (int x)
{
	if (x < 0){x = -x;putchar ('-');}
	if (x > 9) write (x / 10);
	putchar (x % 10 + '0');
}

signed main()
{
	n = read (),m = read (),k = read (),p = read ();
	if (!p) return puts ("0"),0;
	for (Int i = 1;i <= m;++ i) up[i] = m + k - i;
	Prime (m);
	for (Int i = 1;i <= tot && prime[i] <= m;++ i)
	{
		for (Int j = prime[i];j <= m;j *= prime[i])
			Index[i] += m / j;
	}
	for (Int i = 1;i <= tot;++ i)
	{
		int s = m + k - 1 - (m + k - 1) % prime[i];
		for (Int j = m + k - s;j <= m;j += prime[i])
		{
			while (Index[i] && up[j] % prime[i] == 0) Index[i] --,up[j] /= prime[i];
			if (!Index[i]) break;
		}
	}
	int s = 1,sum = 1;
	for (Int i = 1;i <= m;++ i) s = (ll)s * up[i] % p;
	for (Int i = 1;i <= n;++ i) sum = (ll)sum * (s - i + 1) % p;
	write (sum),putchar ('\n');
	return 0;
}
```

---

## 作者：Y2y7m (赞：2)

首先，我们先考虑一行的情况的种数：

$m$ 列 ，有 $k$ 个数。

**由于要求行内数字不降，所以只要我们知道了这一行每⼀个数字的数量，这一行长什么样就确定了**

于是，问题转换成： $k$ 个球划分成 $m$ 组。

很明显：_**隔板法**_。

因为一个组中可以没有数球，所以我们先给每个组中加一个球,

所以我们现在有 $k+m-1$ 个球,

直接套隔板法公式 。

所以，一行的情况数量为： $C_{k+m-1}^{m-1}$ 。

然后再把它弄到 n 列中。

我们设 $t=C_{k+m-1}^{m-1}$ 。

则最后的答案为：

  $A_{t}^{n}$
---

**但是，这里还有几个细节！**

首先，我们不能直接逆元 $lucas$ 求组合数，因为 $p$ **不是质数**

gameover 了？

不！$n$ , $m$ 范围不大，可以直接分解质因数然后**约分**

所以我们还需要线性筛一下质数（暴力质数判断好像也行）。

code:

```cpp
#include <bits/stdc++.h>
#define int long long//要开long long
using namespace std;
int a[100010];
int prime[100010];
int vis[100010];
int c=0;
int s[100010],b[100010];
void getnewprime(int n)//线性筛质数
{
	for(int i=2;i<=n;i++)
	{
		if(!vis[i])
			prime[++c]=i;
		for(int j=1;j<=c&&i*prime[j]<=n;j++)
		{
			vis[prime[j]*i]=1;
			if(i%prime[j]==0)
				break;
		}
	}
}
signed main()
{
	int n,m,k,p;
	cin>>n>>m>>k>>p;
	if(p==1)
	{
		cout<<0;
		return 0;
	}
	for(int i=1;i<=m;i++)
		s[i]=m+k-i;
	getnewprime(m);
	for(int i=1;i<=c&&prime[i]<=m;i++)
		for(int j=prime[i];j<=m;j*=prime[i])
			b[i]+=m/j;
	for(int i=1;i<=c;i++)
	{
		int cnt=m+k-1-(m+k-1)%prime[i];
		for(int j=m+k-cnt;j<=m;j+=prime[i])
		{
			while(b[i]&&s[j]%prime[i]==0)
				b[i]--,s[j]/=prime[i];
			if(!b[i])
				break;
		}
	}
	int ans=1,sum=1;
	for(int i=1;i<=m;i++)
		ans=(ans*s[i])%p;
	for(int i=1;i<=n;i++)
	{
		sum=sum*(ans-i+1)%p;
	}
	cout<<sum<<endl;
	return 0;
}

```


---

## 作者：kkksc03wzl (赞：1)

数数好题

# SOLUTION

首先，显然行与行之间没有任何关系，所以单独考虑行即可。

对于一个序列，如果要单调不减，就是差分非负。于是我们可以直接考虑这个东西的组合意义：设我们现在有 $k$ 件物品，有 $m$ 个隔板，把它分成 $m+1$ 份，**两个隔板可以在同一个缝里**。

下面来解释一下，我们考虑要得到一个 $m$ 的不降序列，而且每个数不超过 $k$ ，每个数不超过 $k$，对于上述每一种方案，都可以取前 $m$ 个份作为其差分即可。因此一行的方案为 $\binom{m+k-1}{m}$ 。

然后因为有 $n$ 行，求个下降幂就好。

好，这个问题的关键在于模数不一定是质数，我们可以这样处理组合数：把这个模数质因数分解，在处理组合数的时候，把每个数和模数不互质的部分用一个桶把指数存下来，互质的部分可以直接乘或除（及用 $exgcd$ 求逆元）。

# CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
int p[20];
int cnt[20];
int exgcd(int l,int r,int &x,int &y){
	if(r==0){x=1;y=0;return l;}
	else{
		int d=exgcd(r,l%r,y,x);
		y-=l/r*x;
		return d; 
	} 
}inline int inv(int a,int m){
	int x,y;
	if(exgcd(a,m,x,y)==1)return (x%m+m)%m;
	return -1;
}
int main(){
	int n,m,k,mod;
	scanf("%d%d%d%d",&n,&m,&k,&mod);
	int t=mod; 
	for(int i=2; i*1ll*i<=t; i++){
		if(t%i==0){
			p[++p[0]]=i;
			while(t%i==0)t/=i; 
		}
	}if(t!=1)p[++p[0]]=t;
	long long ans=1;
	for(int i=m+k-1; i>=k; i--){
		int t=i;
		for(int j=1; j<=p[0]; j++)while(t%p[j]==0)t/=p[j],cnt[j]++;
		ans=ans*t%mod;
	}for(int i=m; i>=1; i--){
		int t=i;
		for(int j=1; j<=p[0]; j++)while(t%p[j]==0)t/=p[j],cnt[j]--;
		ans=ans*inv(t,mod)%mod;
	}
	for(int i=1; i<=p[0]; i++)while(cnt[i]--)ans=ans*p[i]%mod;
	int tmp=ans;ans=1;
	for(int i=tmp; i>=tmp-n+1; i--){
		ans=ans*i%mod;
	}ans=(ans+mod)%mod;
	cout<<ans;
	return 0;
} 
```

---

## 作者：LastKismet (赞：0)

# Sol
组合数学部分是简单的。

首先显然各行独立，我们可以先解决使用 $k$ 种数排出 $m$ 个数使得序列不降的方案数。

由于序列不降，因此我们只需要知道每种数用了几个即可，这等价于 $m$ 个球放入 $k$ 个盒子中，盒子可空。经典组合数学问题，略去证明。
$$
\binom{m+k-1}{k-1}=\binom{m+k-1}{m}
$$
然后回到原答案，就是这么多种序列选 $n$ 个组成的排列，答案即为：
$$
\binom{m+k-1}{m}^{\underline{n}}
$$
然后才是本题的重点，由于任意模数，不能用逆元了，怎么办？

不难发现 $n,m$ 均不大，暴力拆式子即可：
$$
\begin{aligned}
\binom{m+k-1}{m}&=\frac{(m+k-1)!}{m!(k-1)!}\\
&=\frac{k(k+1)(k+1)\dots(k+m-1)}{m!}
\end{aligned}
$$
上下均只有 $m$ 项。考虑将 $m!$ 分解质因数，然后对于每一个质因数，去消分子。

具体地，对于每个质因子，由于分子是连乘，算出在区间内的第一个倍数，然后能消就消，消不动就换下一个倍数接着消。这样只会消质因子数次，大致为 $O(m\log m)$ 的复杂度。

$n$ 也很小，因此得到组合数后 $O(n)$ 暴力求 $n$ 次下降幂即可。

# Code
```cpp
int n,m,k;

int pcnt;
int pr[N];
bool st[N];
void euler(int n){
    rep(i,2,n){
        if(!st[i])pr[++pcnt]=i;
        for(int j=1;pr[j]<=n/i;j++){
            st[i*pr[j]]=true;
            if(i%pr[j]==0)break;
        }
    }
}

int cnt[N];
inline mint C(int n,int m){
    rep(i,1,m){int t=i;rep(j,1,pcnt){
        if(t==1)break;
        while(!(t%pr[j]))t/=pr[j],++cnt[j];
    }}
    vec<int> fz;
    per(i,m,1)fz.pub(n-i+1);
    rep(i,1,pcnt)if(cnt[i]){
        int p=(n-m+1+pr[i]-1)/pr[i]*pr[i]-(n-m+1);
        while(cnt[i]){
            while(fz[p]%pr[i])p+=pr[i];
            fz[p]/=pr[i];--cnt[i];
        }
    }
    mint res=1;
    for(auto i:fz)res*=i;
    return res;
}

inline void Main(){
    read(n,m,k,mod);
    euler(m);
    mint c=C(m+k-1,m);
    mint ans=1;
    rep(i,1,n)ans*=c-i+1;
    put(ans);
}
```

---

## 作者：Priestess_SLG (赞：0)

题目就是说让你用 $1\sim k$ 填一个 $n\times m$ 的表格，要求表格任意两行不同且每一行单调不递减，求方案数。发现行与行之间互相独立，因此考虑分开统计，计算出有多少种可以选择的行填法，设这个值为 $x$ 那么答案显然就是 $A_x^n$，此时问题变为有多少个长度为 $m$ 元素在 $1\sim k$ 之间的单调不递减序列。平方 dp 是简单的，但是显然这样无法通过。

考虑转化上面的问题：把下标看做 $x$ 坐标，值看做 $y$ 坐标，那么就相当于是求在一个平面直角坐标系上，从 $(1,1)$ 点向左 / 上走到 $(m,1),(m,2),\ldots,(m,k)$ 点的方案数的和，经典公式可得总方案数为 $\sum\limits_{i=1}^k\binom{m+i-2}{i-1}=\binom{m-1}{0}+\binom{m}{1}+\binom{m+1}{2}+\ldots+\binom{m+k-2}{k-1}=\binom{m}{0}+\binom{m}{1}+\binom{m+1}{2}+\ldots+\binom{m+k-2}{k-1}=\binom{m+k-1}{k-1}$，问题变为求 $\binom{a}{b}\bmod p$ 且 $a,b$ 都很大 $p$ 非质数且很大但是 $a-b$ 不大的神秘情况。考虑拆组合数，$\binom{a}{b}=\frac{a!}{b!(a-b)!}=\frac{a(a-1)(a-2)\ldots(b+1)}{(a-b)!}=\frac{a(a-1)(a-2)\ldots(b+1)}{1\times 2\times 3\times\ldots\times(a-b)}$，对这些项分解质因数然后扔到哈希表里一一抵消，分解质因数可以先线性筛出 $10^6$ 以内的数的最小质因子，然后若当前数 $\le 10^6$ 查表否则用 pollard rho 暴算，卡卡常可以通过。

```cpp
// #pragma GCC optimize(3, "Ofast", "inline", "unroll-loops")
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1000010;
const int inf = 1e18;

int n, m, k, mod;
int low[N], isp[N], pr[N], idx;
void sieve()
{
    isp[1] = low[1] = 1;
    for (int i = 2; i < N; ++i)
    {
        if (!isp[i])
            isp[i] = 1, low[i] = i, pr[++idx] = i;
        for (int j = 1; j <= idx && 1ll * i * pr[j] < N; ++j)
        {
            isp[i * pr[j]] = 1;
            low[i * pr[j]] = pr[j];
            if (i % pr[j] == 0)
                break;
        }
    }
}
unordered_map<int, int> mp;
mt19937 rnd(time(0));
inline int optimize(const int &a, const int &b, const int &c)
{
    register int ans = a * b - (long long)((long double)a * b / c + 0.5) * c;
    return ans < 0 ? ans + c : ans;
}
int ggcd(int a, int b)
{
    register int _a = __builtin_ctzll(a), _b = __builtin_ctzll(b);
    register int c = min(_a, _b);
    b >>= _b;
    while (a)
    {
        a >>= _a;
        register int diff = a - b;
        _a = __builtin_ctzll(diff);
        b = min(a, b);
        a = abs(diff);
    }
    return b << c;
}
int prime_list[] = {2, 7, 61};
int power(int a, int b, const int &c)
{
    register int s;
    for (s = 1; b; b >>= 1)
    {
        if (b & 1)
            s = optimize(s, a, c);
        a = optimize(a, a, c);
    }
    return s;
}
bool miller_rabin(const int &n, int &a)
{
    register int d = n - 1, r = 0;
    while (~d & 1)
        d >>= 1, ++r;
    register int x = power(a, d, n);
    if (x == 1)
        return true;
    for (register int i = 0; i < r; ++i)
    {
        if (x == n - 1)
            return true;
        x = optimize(x, x, n);
    }
    return false;
}
bool isprime(const int &n)
{
    if (n < 4)
        return n > 1;
    if (n == prime_list[0] || n == prime_list[1] || n == prime_list[2])
        return true;
    for (int i = 0; i < 3; ++i)
        if (n % prime_list[i] == 0 || !miller_rabin(n, prime_list[i]))
            return false;
    return true;
}
int seed, step;
inline int steps(int a, int mod)
{
    return (optimize(a, a, mod) + seed) % mod;
}
int floyd(const int &n)
{
    register int fast, slow, res = 1;
    seed = rnd() % n;
    fast = slow = rnd() % n;
    fast = steps(fast, n);
    for (register int i = 0; fast != slow; ++i)
    {
        res = optimize(res, fast + n - slow, n);
        if (!res)
            res = fast - slow + n;
        if (i % step == 0)
        {
            int g = ggcd(res, n);
            if (g != 1)
                return g;
            res = 1;
        }
        fast = steps(steps(fast, n), n), slow = steps(slow, n);
    }
    return ggcd(res, n);
}
int pollardrho(int n)
{
    if (n == 1)
        return 0;
    else if (isprime(n))
        return n;
    else
    {
        register int k = 1;
        step = (int)log(n);
        step = step << 1 | 1;
        while (k == 1)
            k = floyd(n);
        return max(pollardrho(k), pollardrho(n / k));
    }
}
void duel(int a, int val)
{
    if (isprime(a) || a == 1)
    {
        mp[a] = (mp[a] + mod + val) % mod;
        return;
    }
    while (a > 1)
    {
        int mpr;
        if (~a & 1)
            mpr = 2;
        else if (a % 3 == 0)
            mpr = 3;
        else if (a % 5 == 0)
            mpr = 5;
        else if (a % 7 == 0)
            mpr = 7;
        else if (a % 11 == 0)
            mpr = 11;
        else
            mpr = ((a < N) ? low[a] : pollardrho(a));
        // cerr << "Wtf? " << a << ' ' << mpr << '\n';
        mp[mpr] = (mp[mpr] + mod + val) % mod;
        a /= mpr;
    }
}
int solve(int a, int b)
{
    mp.clear();
    for (int i = a; i >= b + 1; --i)
    {
        // if (i % 2000 == 0)
        //     cerr << i << '\n';
        duel(i, 1 % mod), duel(a - i + 1, mod - 1);
    }
    int sum = 1;
    for (auto &[u, v] : mp)
        sum = sum * power(u, v, mod) % mod;
    return sum;
}

signed main()
{
    // freopen(".out", "w", stderr);
    cin.tie(0)->sync_with_stdio(false);
    cout << fixed << setprecision(15);
    cin >> n >> m >> k >> mod;
    sieve();
    int key = solve(m + k - 1, k - 1), res = 1;
    for (int i = 1; i <= n; ++i)
        res = res * key % mod, key = (key + mod - 1) % mod;
    cout << res << '\n';
    return 0;
}
```

---

## 作者：zyn_ (赞：0)

简单 MO 一试组合计数。

每行填 $m$ 个值域 $[1,k]$ 的单调不减的数。设这 $m$ 个数为 $f_{1\dots m}$，并令 $f_0=1$，$f_{m+1}=k$。

令 $g_i=f_{i+1}-f_{i}\ge 0$，则一组 $g_i$ 与 $f_i$ 一一对应，且

$$
\sum_{i=0}^m g_i=\sum_{i=0}^m(f_{i+1}-f_i)=f_{m+1}-f_0=k-1
$$

这是，将 $k-1$ 拆分成 $m+1$ 个自然数之和，求方案数。

简单的插板法可知，方案数为

$$
\binom{m+k-1}{m}
$$

现在要填 $n$ 行且任意两行不相同，则方案数为

$$
\binom{m+k-1}{m}^{\underline n}
$$

其中 $x^{\underline n}=\prod_{i=0}^{n-1}(x-i)$ 为下降幂。

欲求此式模 $p$ 的值，只需求 $\binom{m+k-1}{m}$ 模 $p$ 的值。可惜 $p$ 不一定是质数。

考虑

$$
\binom{m+k-1}{m}=\frac{(m+k-1)^{\underline m}}{m!}
$$

$m!$ 中所有质因子均不超过 $m$。将分子中不超过 $m$ 的质因子的部分提取并约分，剩余部分再乘上去即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define N 100009
ll n,m,k,p,a[N],cnt[N],x,y;
bool isp[N];
int main(){
    cin>>n>>m>>k>>p;
    for(int i=2;i<=m;++i)isp[i]=1;
    for(int i=2;i<=m;++i)if(isp[i])for(int j=i+i;j<=m;j+=i)isp[j]=0;
    for(int i=0;i<m;++i)a[i]=k+i;
    for(int i=1;i<=m;++i)if(isp[i])for(int j=i-1-(k-1)%i;j<m;j+=i)
        while(a[j]%i==0)a[j]/=i,++cnt[i];
    for(int i=1;i<=m;++i)if(isp[i])for(int j=m/i;j;j/=i)cnt[i]-=j;
    x=1;
    for(int i=1;i<=m;++i)if(isp[i])for(int j=1;j<=cnt[i];++j)x=x*i%p;
    for(int i=0;i<m;++i)x=x*a[i]%p;
    y=1;
    for(int i=0;i<n;++i)y=y*(x+p-i)%p;
    printf("%lld\n",y);
    return 0;
}
```

---

## 作者：Autream (赞：0)

## 题意简述
$n \times m$ 的表格，每个格子填一个 $1 \sim k$ 的整数，要求每行互不相同且单调不减的方案数，对 $p$ 取模，不保证 $p$ 是质数。
## 题目分析
这道计数难点在于 $p$ 不一定是个质数，所以不能用预处理阶乘逆元。

发现行与行之间的联系并不是特别大，只需要保证不完全相同，可以随便排列。设每行的方案数为 $s$，那么总共的答案即为 $A_s ^n$。

由于每一列要求单调不减，所以我们只要确定了每一列有哪些数，这一列的排列就是唯一的，于是可以把每一列排列的方案数看作将 $m$ 个球放入 $k$ 个盒子里面，每个盒子可以为空，根据插板法，此方案数为 $\begin{pmatrix} m + k - 1 \\ k - 1 \end{pmatrix}$。

展开可得：
$$\begin{pmatrix} m + k - 1 \\ k - 1 \end{pmatrix} = \frac{\prod _{i = 0} ^{m - 1} (k - i)}{m!}$$

注意到分子分母都只有 $m$ 项，用质数对 $k, k + 1, \dots, k + m - 1$ 约分即可。
## AC Code
```cpp
// Problem: P5481 [BJOI2015] 糖果
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5481
// Memory Limit: 500 MB
// Time Limit: 1000 ms
// Date: 2024/12/09 20:36:59
// Author: Li_Feiy

#include <bits/stdc++.h>
#define arrout(a, n) rep(i, 1, n) printk(a[i])
#define arrin(a, n) rep(i, 1, n) a[i] = read()
#define rep(i, x, n) for(int i = x; i <= n; i++)
#define dep(i, x, n) for(int i = x; i >= n; i--)
#define erg(i, x) for(int i = head[x]; i; i = e[i].nex)
#define dbg(x) std::cout << #x << ":" << x << " "
#define mem(a, x) memset(a, x, sizeof a)
#define all(x) x.begin(), x.end()
#define arrall(a, n) a + 1, a + 1 + n
#define PII std::pair<int, int>
#define m_p std::make_pair
#define u_b upper_bound
#define l_b lower_bound
#define p_b push_back
#define CD const double
#define CI const int
#define int long long
#define il inline
#define ss second
#define ff first
#define itn int
int read() {
	char ch = getchar();
	int r = 0, w = 1;
	while(ch < '0' || ch > '9') w = ch == '-' ? -1 : w, ch = getchar();
	while(ch >= '0' && ch <= '9') r = (r << 3) + (r << 1) + (ch ^ 48), ch = getchar();
	return r * w;
}

void print(int x) {
	if(x < 0) putchar('-'), x = -x;
	if(x >= 10) print(x / 10);
	putchar(x % 10 + '0');
}template<typename ...Args>
void print(int t, Args... args) { print(t), print(args...); }

void printl(int x) { print(x), putchar('\n'); }
template<typename ...Args>
void printl(int t, Args... args) { printl(t), printl(args...); }

void printk(int x) { print(x), putchar(' '); }
template<typename ...Args>
void printk(int t, Args ... args) { printk(t), printk(args...); }

CI N = 2e5 + 5;
int n, m, k, ans, MOD, prod, b[N], p[N], s[N], vis[N];
void init(int n) {
	for(int i = 2; i <= n; i ++) {
		if(!vis[i]) p[++p[0]] = i;
		for(int j = 1; j <= p[0] && p[j] * i <= n; j ++) {
			vis[p[j] * i] = 1;
			if(!(i % p[j])) break;
		}
	}
	rep(i, 1, p[0]) {
		int base = p[i];
		while(m / base >= 1) b[i] += m / base, base *= p[i];
	}
}
int qpow(int a, int b) {
	int ans = 1;
	while(b) {
		if(b & 1) ans = ans * a % MOD;
		a = a * a % MOD;
		b >>= 1;
	}
	return ans;
}
signed main() {
	n = read(), m = read(), k = read(), MOD = read();
	init(N);
	rep(i, 1, m) s[i] = m + k - i;
	rep(i, 1, p[0]) for(int j = (m + k - 1) % p[i] + 1; j <= m && b[i]; j += p[i]) while(b[i] && !(s[j] % p[i])) b[i] --, s[j] /= p[i];
	ans = prod = 1;
	rep(i, 1, m) (prod *= s[i]) %= MOD;
	rep(i, 0, n - 1) (ans *= (prod - i)) %= MOD;
	print(ans);
	return 0;
}
```

---

## 作者：xiaoyang111 (赞：0)

## 前言

难点在于转换和最后求组合数。

[题目传送门。](https://www.luogu.com.cn/problem/P5481)

## 讲解

### 思路

首先容易发现每行可以拆出来看，出了不同其他的没什么要求。假设我们已经知道了每一行的方案数 $t$，则答案就是 $A^n_t$。这个容易解释，就是在 $t$ 种方案选出 $n$ 个来拼接。

因为每行是单调不减的，所以直接比较最后一个数就可以了。

然后有两种解法。第一种是动态规划转组合数，第二种是差分。这里讲第二种。

先把这个最终序列弄出来一个差分数组 $d$，容易发现最后一个数就是 $d$ 的所有数总和。那我们直接枚举最后一个数，然后可无球的插板法就可以了啊，这里要注意第一个数最少是 $1$，所以要先给第一个分配一个数。这一部分答案是 $\sum^k_{i=1}C^{m-1}_{i+m-2}$。这个可以杨辉三角化简啊，就成了 $C^m_{m+k-1}$。

然后发现 $i+m-1$ 过于大了啊，所以不能直接逆元和其他的方法。

我们考虑把他拆了，拆成 $\frac{1}{m!} \times \frac{(m+k-1)!}{(k-1)!}$。发现 $m!$ 可以用分解质因数解决，所以我们再想后面怎么分解质因数。

发现后面就是 $\prod^{m-1}_{i=0}k+i$，只有 $m$ 个数，而前面质因数最多是 $m$，所以枚举下面的质因数，然后再用下面的质因数筛上面的数的质因数，然后指数相减快速幂就可以了。

这样筛完上面还可能有比 $m$ 大的质因子，直接整体乘起来就可以了。

最大的一坨就直接暴力 $O(n)$ 算就行了。

### 代码

下面是我的代码。

```cpp
#include <iostream>
#define int long long
using namespace std;
const int N=1e5+5;
bool vis[N];
int cnt1[N],cnt2[N],g[N];
int n,m,k,p;
int qpow(int a,int b){//快速幂
	int base=a,ans=1;
//	cout<<a<<' '<<b<<endl;
	while (b){
		if (b&1) ans=ans*base%p;
		base=base*base%p;
		b>>=1;
	}	
	return ans;
}
signed main(){
	cin >> n >> m >> k >> p;
	for (int i=0;i<m;++i){
		g[i]=k+i;
	}
	for (int i=2;i<=m;++i){//枚举质数
		if (!vis[i]){
			for (int j=2;j*i<=m;++j){//正常筛质数
				vis[j*i]=1;
			}
			for (int j=i,t=1;j<=m;j*=i,++t){//筛前面质因数
				cnt1[i]+=(m/j);
			}
			for (int j=k/i*i;j<k+m;j+=i){//枚举所有的倍数
				if (j<k) continue;
				while (g[j-k]%i==0) ++cnt2[i],g[j-k]/=i;//剥开
			}
		}
	}
	int C=1;
	for (int i=0;i<m;++i) C=C*g[i]%p;//把剩下的乘起来
	for (int i=2;i<=m;++i){
		if (vis[i]) continue;
		C=C*qpow(i,cnt2[i]-cnt1[i])%p;//指数快速幂
		cnt1[i]=cnt2[i]=0;
	}
	C+=p;
	int ans=1;
	for (int i=0;i<n;++i) ans=ans*(C-i)%p;
	cout<<ans<<endl;
	return 0;
}  
```

---

## 作者：Kelvin2009 (赞：0)

这是一类比较经典的排列组合。

要求单行序列单调不降，其实就是考虑这 $k$ 个数每个数被选了几次。

但是有的数可以没被选过，所以直接对所有数的总被选次数 $m$ 进行插板显然不对。

于是引出一个经典思路：先给每个数都选一次，再进行插板，这样插板插出 1 的间隔就是没被选过。把插出的方案里每个数的被选次数减 1 就是真实的被选次数。

于是每行可以有 $C_{m+k-1}^{k-1}$ 种方案。

由于 $k$ 的范围过大，考虑杨辉三角的对称性。则有：
$$C_{m+k-1}^{k-1}=C_{m+k-1}^{m}$$ 

所以单行的总方案数 $s$ 为 $C_{m+k-1}^{m}$。

这样的作用在于，由于不保证 $p$ 和组合数的分母互质，无法用逆元，只能直接从分子中消去分母。

直接消掉太慢了，考虑质因数分解。有一个重要结论：勒让德定理
$$L_p(n!)=\sum\limits_{k\geqslant1}^{\infty}\left\lfloor\dfrac{n}{p^k}\right\rfloor$$ 

可以参考[这篇](https://blog.csdn.net/liangzhaoyang1/article/details/52431214)。

而表格有顺序区别，所以考虑填入的每行。总共有 $A_{n}^{s}$ 个不同的表格。


---

代码：


---


```cpp
#include<bits/stdc++.h>
using namespace std;
const int range=2e5+5;
int n,m,k;
long long mod;
bool flag[range];
int len,tim[range],fac[range],prime[range];
inline void init()
{
	for(int i=2;i<=m;i++)
	{
		if(flag[i]) continue;
		prime[++len]=i;
		for(int j=i+i;j<=m;j+=i) flag[j]=true;
	}
	for(int i=1;i<=len;i++)
	{
		int base=prime[i];
		while(m/base>=1) tim[i]+=m/base,base*=prime[i];
		//cout << tim[i] << endl;
	}
	return ;
}
int main()
{
	scanf("%d%d%d%lld",&n,&m,&k,&mod);
	init();
	for(int i=0;i<m;i++) fac[i]=k+i;//cout << k+i << " ";
	//cout << endl;
	for(int i=1;i<=len;i++)
	{
		int posi=((k+prime[i]-1)/prime[i])*prime[i];
		posi-=k;
		for(int j=posi;j<m;j+=prime[i])
		{
			//cout << fac[j] << " ";
			while(fac[j]%prime[i]==0)
			{
				fac[j]/=prime[i];
				tim[i]--;
				if(!tim[i]) break;
			}
			if(!tim[i]) break;
		}
	}
	//cout << endl;
	long long pai=1ll,ans=1ll;
	for(int i=0;i<m;i++) (pai*=fac[i])%=mod;
	//cout << pai << endl;
	for(int i=1;i<=n;i++) (ans*=(((pai-i+1ll)%mod+mod)%mod))%=mod;
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：dAniel_lele (赞：0)

## 分析

考虑先求出一个问题：填 $m$ 个数，有 $k$ 种数，单调不减的方案数。

考虑这 $m$ 个数分别为 $\{x_1,x_2,\dots,x_m\}$。

要求 $x_1\leq x_2\leq\dots\leq x_m\leq k$，对这个式子进行一点转化得：$x_1<x_2+1<\dots<x_m+m-1\leq k+m-1$，问题转化为从 $k+m-1$ 个数中选择 $m$ 个的方案数，即 $C_{k+m-1}^m$。令 $d=C_{k+m-1}^m$。

现在我们找出了所有单调不减的方案。接下来我们需要排 $n$ 行使得两两行不同。那么总共有 $A_d^n$。那么到此这题就解决了。

整个的公式就是 $A_{C_{k+m-1}^m}^n$。

当然，在计算组合数学中，由于 $p$ 不是素数，我们不能预处理逆元来计算。所以我们只能通过列举质因数加减的方案来计算。最后乘起来即可。具体细节可以见代码。（为了方便读者理解，给出提示：在代码中，`C(i,j,0)` 表示 $A_i^j$，`C(i,j,1)` 表示 $C_i^j$。）

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int mod;
int ip[100005],p[100005],cnt;
void init(){
	for(int i=2;i<=100000;i++){
		if(ip[i]>=0){
			cnt++;
			p[cnt]=i;
			ip[i]=cnt;
			for(int j=i*2;j<=100000;j+=i){
				ip[j]=-1;
			}
		}
	}
}
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) ans=(ans*a)%mod;
		a=(a*a)%mod;
		b>>=1;
	}
	return ans;
}
int C(int i,int j,int nd){
	int ans=1;
	int c[100005];
	memset(c,0,sizeof(c));
	for(int k=1;k<=j;k++){
		int ask2=k;
		if(nd){
			for(int l=1;p[l]*p[l]<=ask2;l++){
				while(ask2%p[l]==0){
					c[l]--;
					ask2/=p[l];
				}
			}
			if(ask2-1){
				c[ip[ask2]]--;
			}
		}
	}
	ans=1;
	for(int k=1;k<=j;k++){
		int ask1=i-k+1;
		for(int l=1;p[l]*p[l]<=ask1;l++){
			while(ask1%p[l]==0){
				c[l]++;
				ask1/=p[l];
			}
		}
		if(ask1-1){
			if(ask1>=100000) ans=(ans*ask1)%mod;
			else c[ip[ask1]]++;
		}
	}
	for(int k=1;k<=cnt;k++){
		ans*=qp(p[k],c[k]);
		ans%=mod;
	}
	return ans;
}
signed main(){
	init();
	int n,m,k;
	cin>>n>>m>>k>>mod;
	int tmp=C(m+k-1,m,1);
	while(tmp<=n){
		tmp+=mod;
	}
	cout<<C(tmp,n,0)%mod;
    return 0;
}
```

---

## 作者：kouylan (赞：0)

我们第一步要求出值域在 $[1,k]$ 并且长度为 $m$ 的不下降序列个数。

我们定义 $f(i,j)$ 表示从左往右填数，当前在第 $i$ 位并且第 $i$ 位填的是 $j$ 的方案数。转移时只要保证第 $i-1$ 位填的数小于等于 $j$ 就行：$f(i,j) = \sum\limits_{k=1}^j f(i-1,k)$。初始条件 $f(1,1)=1,f(1,0)=0$。

改写成前缀和的形式，$f(i,j)=s(i-1,j)$，那么 $s(i,j)=s(i,j-1)+f(i,j)=s(i,j-1)+s(i-1,j)$。

注意到这就是这就是杨辉三角的递推式，唯一不同的就是初始时 $s(1,0)=0$，所以这个式子就只用把杨辉三角往右平移一个单位即可。而不降序列个数就是 $s(m,k)=\binom{m+k-1}{m}$。

填表格的话就是把这些序列排列一下，所以最终答案就是 $\binom{m+k-1}{m}^{\underline{n}}$。

下面我们来计算这个答案式子。

$\binom{m+k-1}{m}^{\underline{n}} = \prod\limits_{i=1}^n (\binom{m+k-1}{m}-i+1)$

$n$ 很小，可以线性计算，但因为模数不确定，所以不能直接用阶乘和逆元算二项式。考虑把这个二项式拆开。

$\binom{m+k-1}{m}=\frac{(m+k-1)!}{m!(k-1)!}=\frac{1}{m!}(m+k-1)^{\underline{m}}=\frac{1}{m!}\prod\limits_{i=1}^{m} (m+k-i)$

那这样，我们就只要预处理出 $m!$ 的质因数分解，然后跟分子约分就行。

因为欧拉筛都是用最大的质因子筛掉某个数，所以我们可以同时记录每个数的最大质因子。分解质因数时，对每个数只要每次除去它的最大质因子就行。约分时，我们可以枚举小于等于 $m$ 的每个质数 $i$，这样分子中 $i$ 的倍数就是以 $i$ 为周期的，复杂度就是调和级数的。

下面是 AC 代码。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

int n,m,M,k,ans=1,s=1,a[100005];
int cnt,p[100005],vis[100005],b[100005],pr[100005];

void getprime(int n)
{
	for(int i=2;i<=n;i++)
	{
		if(!vis[i])
			p[++cnt] = i, pr[i] = i;
		for(int j=1;j<=cnt&&i*p[j]<=n;j++)
		{
			vis[i*p[j]] = 1;
			pr[i*p[j]] = p[j];
			if(i%p[j]==0) break;
		}
	}
}

signed main()
{
	cin>>n>>m>>k>>M;
	getprime(m+2);
	for(int i=1;i<=m;i++)
	{
		a[i] = i+k-1;
		int tmp=i;
		while(tmp>1)
			b[pr[tmp]]++, tmp /= pr[tmp];
	}
	int st=a[1];
	for(int i=2;i<=m;i++)
		if(!vis[i])
		{
			int r=st%i;
			int j=(1-r+i)%i;
			if(j==0) j = i;
			while(b[i]>0)
			{
				while(a[j]%i==0)
				{
					a[j] /= i;
					if((--b[i])==0) break;
				}
				j += i;
			}
		}
	for(int i=1;i<=m;i++)
		s = s*a[i]%M;
	for(int i=1;i<=n;i++)
		ans = ans*((s-i+1+M)%M)%M;
	cout<<ans<<endl;
	
	return 0;
}
```

祝大家 AC 愉快！

---


# [JSOI2016] 炸弹攻击1

## 题目背景

JYY 最近迷上了一款塔防游戏，在游戏中，JYY 除了建设建筑，还可以使用炸弹对屏幕上的敌人进行范围杀伤。

## 题目描述

游戏地图可以简单认为是一个二维平面。JYY 建造了 $N$ 个建筑，每个建筑都是一个圆，其中第 $i$ 个建筑的圆心位于 $(x_i,y_i)$ 且半径为 $r_i$。地图上一共有 $M$ 个敌人，一个敌人可以近似看成一个平面上的点，其中第 $i$ 个敌人位于$ (p_i,q_i)$。JYY 可以使用一枚可以设置半径的炸弹，可以设置一个不超过 $R$ 的范围，然后选择平面上的一个点引爆，范围内的所有敌人全部消灭。

当然，由于炸弹威力巨大，如果爆炸范围接触到 JYY 的建筑，那么 JYY 的建筑也会受到损伤。（注：如果炸弹的爆炸范围仅接触到了 JYY 建筑的边界，则不会对 JYY 的建筑造成损伤；如果敌人出现在了爆炸范围的边界，则该敌人被消灭）JYY 可以自由控制炸弹的爆炸地点和爆炸半径。作为一个保守的玩家，他希望在保证自己建筑毫发无损的情况下，消灭尽量多的敌人。

## 说明/提示

- 对于 $20\%$ 的数据，满足 $M = 2$；
- 对于另外 $20\%$ 的数据，满足 $N = 0$；
- 对于另外 $20\%$ 的数据，满足 $M \leq 50$；
- 对于 $100\%$ 的数据，满足：
  - $0 \leq N \leq 10$；
  - $0 < M \leq 10^3$；
  - $1 \leq R, r_i \leq 2 \times 10^4$；
  - $|p_i|, |q_i|, |x_i|, |y_i| \leq 2 \times 10^4$。


## 样例 #1

### 输入

```
1 5 3
0 0 1
3 3
-3 3
3 -3
3 0
0 3 ```

### 输出

```
3```

# 题解

## 作者：chenxia25 (赞：33)

对于一个点 $(x,y)$，先计算出在不碰到建筑物的限制下能取的最大半径，然后通过这个半径容易算出可以杀死多少个敌人。考虑对这个 $(x,y)$ 退火。

然后如果直接把这个杀死敌人个数当作参考的话，这是个整值，导致整个二维函数很不平滑，模拟退火的效果会非常不好（形象理解一下，地图上大量充斥着 $0$，很可能走不出去）。

我们考虑设一个返回值为实数的平滑的函数，能对「即使当前点杀死敌人数量是 $0$，那么它离 $1$ 有多近」有良好的参考。「当前点对应的最大半径还需再增加多少能碰到第一个敌人」是一个好的选择，设它为 $r_0$，考虑将它纳入函数的组成部分。同时杀死敌人数量又不能不考虑，于是设这样一个估价函数 $f(x,y)=-cr_0+cnt$，其中 $c$ 是待定系数，$cnt$ 是杀死敌人数量，用该函数来退火。

那么显然要么 $r_0=0$ 要么 $cnt=0$。当 $cnt=0$ 的时候，甚至可以证明 $f$ 在这些区域上是连续的（

另外看题解学到了新招：在退火的过程中可以将每次的答案都记录下来取 max，instead of 只取最后一次。这样是严格优于只取最后一次的，因为这样甚至不带来任何时间复杂度上的增加。

经过辛苦的尝试，取 $r_0=14.14,T_0=1e12,T_e=10^{-8},\Delta T=0.9996$ 效果较好。考虑到函数有部分离散的存在，可以在卡时和只跑一次之间取个平均：跑个五次以内。而上述参数只允许跑 3 次。接下来就是随机种子的事情了。取 20060617 跑两遍只有 #2 #3 没 AC，取 12 跑一遍这两个点都 AC 了，但是又有其他点没 AC。那合起来跑三遍即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define urd uniform_real_distribution
#define mp make_pair
#define X first
#define Y second
mt19937 rng(20060617);
const double inf=1e12,eps=1e-5;
const int N=1010;
int n,m;double R;
double xx[N],yy[N],r[N];
double p[N],q[N];
int calc;
double f(double x,double y){
	calc=0;
	double rad=R;
	double cnt=0,mn=inf;
	for(int i=1;i<=n;i++){
		double d=sqrt((x-xx[i])*(x-xx[i])+(y-yy[i])*(y-yy[i]));
		rad=min(rad,d-r[i]);
	}
	rad=max(0.,rad);
	for(int i=1;i<=m;i++){
		double d=sqrt((x-p[i])*(x-p[i])+(y-q[i])*(y-q[i]));
		mn=min(mn,d-rad);
		cnt+=d<=rad+eps;
		calc+=d<=rad+eps;
	}
	return -max(0.,mn)*14.14+cnt;
}
int ans;
void sim_ann(double st,double ed,double dlt){
	double x=0,y=0;
	double res=f(x,y);
	for(double tem=st;tem>=ed;tem*=dlt){
		double nw_x=x+urd<>(-10,10)(rng)*tem;
		double nw_y=y+urd<>(-10,10)(rng)*tem;
		double nw=f(nw_x,nw_y);
		if(nw>res||urd<>(0,1)(rng)<=exp((nw-res)/tem))x=nw_x,y=nw_y,res=nw;
		ans=max(ans,calc);
//		cout<<tem<<":"<<x<<" "<<y<<" "<<res<<"!\n";
	}
}
int main(){
	cin>>n>>m>>R;
	for(int i=1;i<=n;i++)cin>>xx[i]>>yy[i]>>r[i];
	for(int i=1;i<=m;i++)cin>>p[i]>>q[i];
	sim_ann(1e12,1e-8,.9996);
	sim_ann(1e12,1e-8,.9996);
	rng=mt19937(12);
	sim_ann(1e12,1e-8,.9996);
	cout<<ans;
	return 0;
}
```

---

## 作者：ShanLing (赞：1)

实际上不需要退火，朴素的爬山就可以通过。

发现答案是在 $[0,10^3]$ 的整数，如果仅以答案做为估价函数，图像不平滑,很难确定精确位置。因此需要设计新的估价函数。

设爆炸半径为 $r$。敌人到炸弹距离为 $d$，可以看出，一般情况下对与 $d>r$ 的敌人，其的 $d$ 越小，在 $(x,y)$ 后进入范围的概率就越大。据此，我们可以设计一个反比例函数 $\frac{k}{d-r}$，并经过尝试发现在 $k=R$ 时新函数能较好地表现当前状态。  
需要注意是，需要限制这个函数的范围，否则当 $\lim_{d\rightarrow r^+}$ 时，这个函数会变得特别大，从而影响答案。  
又经过一些尝试，我们得出了完整的估价函数 $f(x,y)=cnt+\min(R,\frac{R}{d-r})$。

一组合适的参数如下：  
起始位置为随机的一个敌人，取 $T_{st}=R$，$T_{ed}=10^{-3}$，$\Delta T=0.95$，执行多次并卡时。  
取随机敌人为起始位置可以可以应付敌人位置偏远而 $R$ 较小的数据，而这组参数在最大的数据下也能跑超过 $300$ 次，随机到能使答案最大的起始位置的概率很大，正确性得以保证。

---
## code
```
#include <bits/stdc++.h>
using namespace std;
#define urd uniform_real_distribution

mt19937 rnd(chrono::system_clock::now().time_since_epoch().count());

int n,m,mxr,ans;
struct node
{
    int x,y,r;
}a[15],b[1005];

inline double gtds(double x,double y,double xx,double yy)
{
    return (x-xx)*(x-xx)+(y-yy)*(y-yy);
}

inline double _count(double x,double y)
{
    int num1=0;
    double num2=0,r=mxr;

    for(int i=1;i<=n;i++)
    {
        double dis=sqrt(gtds(a[i].x,a[i].y,x,y));
        r=min(r,max(dis-a[i].r,0.0));
    }

    for(int i=1;i<=m;i++)
    {
        double dis=sqrt(gtds(b[i].x,b[i].y,x,y));
        if(dis<=r)
            num1++;
        num2+=min(1.0,1/sqrt(dis-r));
    }

    ans=max(ans,num1);
    return num1+num2*mxr;
}

int check(int x)
{
    for(int i=1;i<=n;i++)
        if(gtds(a[i].x,a[i].y,b[x].x,b[x].y)<a[i].r*a[i].r)
            return 1;
    return 0;
}

void sa()
{
    int st=rnd()%m+1;
    //如果出发位置已经被建筑覆盖，则不能爬山
    if(check(st))
        return;
    double x=b[st].x,y=b[st].y;
    double ls=_count(x,y);

    for(double t=mxr;t>=1e-3;t*=0.95)
    {
        //每次朝一个随机的方向前进t
        double num=urd<>(0,4*asin(1))(rnd);
        double xx=x+t*sin(num);
        double yy=y+t*cos(num);

        double now=_count(xx,yy);

        if(now>ls)
        {
            x=xx;
            y=yy;
            ls=now;
        }
    }
}

int main( void )
{
    const clock_t st=clock();

    scanf("%d%d%d",&n,&m,&mxr);
    for(int i=1;i<=n;i++)
        scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].r);
    for(int i=1;i<=m;i++)
        scanf("%d%d",&b[i].x,&b[i].y);

    //卡时
    while(1)
    {
        rnd=mt19937(rnd());
    	sa();

        const clock_t ed=clock();
        const int time_limit=950;
        if(double(ed-st)*1000/CLOCKS_PER_SEC>=time_limit)
            break;
    }
    
    printf("%d",ans);

    return 0;
}
```

---

## 作者：zhangxiaoyu008 (赞：0)

第一次写题解（因为其他很多题都不能提交题解了，悲。）。

喜提写了个爬山算法。。。（如果要写模拟退火的请翻其他题解）

[>题面链接<](/problem/P5544)

更佳观感：[ $$\mathtt{My \ Blog}$$ ——题解：P5544 [JSOI2016] 炸弹攻击1](https://www.luogu.com.cn/article/a9nr78j6)

我们首先**考虑已知炸弹投放点的位置如何求出最多可以消灭的敌人数量**。

### 步骤1：求出最大可能半径（越大，能消灭的敌人数量不降）

先假设炸弹投放点不在任何一个建筑内，设炸弹投放点到建筑距离为 $\text{dist}$ ，此建筑半径为 $r$ ，由图可知单个建筑最大可能半径即为 $\text{dist}-r$ 。

那么最大可能半径就是所有这样的 $\text{dist}-r$ 的最小值再和 $R$ 取最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/8r344h00.png)

那么如果炸弹投放点在一个建筑内呢，那么按上述求法最大可能半径为负，不影响下面求答案。

### 步骤2：求出可以消灭的敌人数量

设炸弹投放点到敌人为 $\text{dist}$ ，步骤1求出的最大可能半径为 $r_{\text{max}}$ ，那么如果 $\text{dist} \le r_{\text{max}}$ ，这个敌人将被消灭。

然后就可写代码啦~~~

如果你要看代码说几个点：
- `hypot(x, y)` 可以约等于 `sqrt(x * x + y * y)`
- 实现一个随机的变化量即 `(rand() * 2 - RAND_MAX) * T` 可以参考 [[JSOI2004] 平衡点 / 吊打XXX](/problem/P1337) 题
- 一开始赋一个平均值，也可以参考 [[JSOI2004] 平衡点 / 吊打XXX](/problem/P1337) 题

## 代码

**$$\textbf{\tiny{如直接复制代码CE后果自负}}$$**

```cpp
#include <bits/stdc++.h>
using namespace std;‍‍‍‍‍
const int N = 1e3 + 10;‍‍‍‍‍
int ‭n‭,‭ ‭m‭,‭ ‭R‭,‭ ‭r‭e‭s‭,‭ ‭a‭n‭s‭;‭
double ‭s‭x‭,‭ ‭s‭y‭,‭ ‭T‭_‭b‭e‭g‭i‭n‭,‭ ‭T‭_‭e‭n‭d‭ ‭=‭ 1e-10,‭ ‭r‭a‭t‭e‭ ‭= 0.998;
struct Building{‭‍
	int x‭, ‭y,‭ r‭;‭
}‭a[15]‭;
struct Enemy{‍
	int x, y;
}b‭[‭N‭]‭;‭
int f(double x, double y)‌ {‍‍‍‍‍‌
	int c‭nt = 0;
	double r = R;
	for(int i = 1; i <= n; i ++)‌ {‌
		double di‭s = hypot(x - a[i].x, y - a[i].y) - a[i].r;
		r = min(r, d‭is);
	‌}
	for(int i = 1; i <= m; i ++)
		if(hypot(x - b[i].x, y - b[‭i].y‭) <= r‭)
			‭c‭nt ++;
	return cnt‭;
}‍‍‍‍‍
void g(‍‍‍‍‍‍‍‍‍)‌‌ {‍
	for(T‭_‭b‭e‭g‭i‭n‭ = 1e4; T_be‭gin > T_en‭d; T_begin‭ *= ‭ra‭te‭) {
		double d‭x = (rand() * 2 - R‭A‭N‭D‭_M‭A‭X) * T_b‭egin‭, ‭dy = (rand(‭) * 2 - RAN‭D_M‭AX) * T_b‭egi‭n;
		int n‭ow = f(s‭x + dx‭, ‭sy + dy‭);
		int del‭ta = now‭‭ - r‭es;
		if(delta > 0)‌‌ {‍‍‍‍‍
			s‭x += d‭x, s‭y += d‭y;
			r‭e‭s = no‭w, an‭s = max(a‭ns,‭ r‭e‭s);
		}‍‍‍‍‍‍
		else if(exp(-delta / T_begin) * RAND_MAX < rand())‭ {‍‍‍‍‍
			s‭x += dx, s‭y += d‭y;
			r‭es = no‭w;
		‌‌}‍‍‍‍‍
	}‌‌
‍}
int main()
‍{‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍
	srand(1);
	scanf("%d%d%d", &n, &m, &R);
	for(int i = 1; i <= n; i ++) scanf("%d%d%d", ‭&a[i].x‭, &a[‭i].y‭, ‭&a[i‭].‭r);
	for(int i = 1; i <= m; i ++) {
		scanf("%d%d", &b‭[i].x‭, &‭b[i].‭y);
		s‭x += b[i].x, sy‭ += b[i].y;
	}
	‭sx /= m, ‭sy /= m;
	for(int i = 1; i <= 6; i ++) g(‭);
	printf("%d\n", a‭n‭s);
	return 0;‭
‍}‍
```

---


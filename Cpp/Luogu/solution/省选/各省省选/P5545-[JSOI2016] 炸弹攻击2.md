# [JSOI2016] 炸弹攻击2

## 题目背景

还记得那款题为炸弹攻击的塔防游戏吗？这款游戏出了续作，炸弹的威力大大加强了。

## 题目描述

游戏的地图是一个二维平面。JYY 的阵地位于 $x$ 轴下方，而所有的敌人目前都位于 $x$ 轴上方。

在 JYY 的阵地中有建有 $T$ 个激光塔和 $S$ 个发射源。其中第 $i$ 个防御塔 $T_i$ 的坐标为 $(tx_i,ty_i)$，第 $i$ 个发射源 $S_i$ 的坐标为 $(sx_i,sy_i)$。

地图上有 $D$ 个敌人，第 $i$ 个敌人 $D_i$ 的坐标为 $(dx_i,dy_i)$。

两座激光塔可以相互连接形成能量墙。发射源朝向敌人发出的能量如果穿过了能量墙，可以得到巨大的加强而变为超级射线并瞬间消灭敌人。

JYY 想知道他有多少种可以可以发出超级射线的攻击方案。

具体来说，一个可以发出超级射线的攻击方案为一个由四个点组成的集合：$\{T_i,T_j,S_k,D_l\}$，满足$1 \leq i < j \leq T,1 \leq k \leq S,1 \leq l \leq D$，并且线段 $T_iT_j$ 和线段 $S_kD_l$ 相交。

游戏设定保证在这 $T+D+S$ 个点中，不存在重点也不存在三点共线。

## 说明/提示

对于 $20\%$ 的数据，满足 $D,S,T \leq 30$；

对于$50\%$ 的数据，满足 $D,S,T \leq 150$；

对于$100\%$ 的数据，满足 $1 \leq D,S,T \leq 800 , dy_i>0,sy_i,ty_i<0$，所有坐标绝对值不超过 $10^9$。

## 样例 #1

### 输入

```
3
1 12
10 30
30 10
1
10 -10
4
2 -11
9 -1
11 -1
15 -14```

### 输出

```
7```

# 题解

## 作者：seajupiter (赞：7)

# **算法：计算几何+双指针**

 **首先，看数据范围可知，不能够去枚举每一条线段，两两判断是否相交。但是，本题较为特殊的是，满足所有敌人在x轴上方，所有发射源和激光塔在x轴下方。于是**
 
- 分别对每个发射源进行处理
- 对于当前发射源S，把S到所有Di、Ti的向量按照极角排序
- 答案就是满足T1、T2夹角小于180度的（T1，D，T2）三元组的数量。可用Two Pointers思想求解。核心思想即为：对每一个左端点，找出可行区间的右端点。利用前缀和计算出T1为当前左端点，T2在当前区间内的方案数（从头到区间内每个T间D个数的累积和-从头到左端点D的个数累积和*区间内T的个数）
- 注意头尾可能相接构成方案，故可复制一倍做环状处理

 **最后，给出我个人的代码供大家参考**
 
```cpp
#include<bits/stdc++.h>
const double pi=3.1415926535;
using namespace std;
void read(int &x)
{
	char c=getchar();x=0;int f=1;
	while(!isdigit(c))f=c=='-'?-f:f,c=getchar();
	while(isdigit(c))x=x*10+c-'0',c=getchar();x*=f;
}
void read(long long &x)
{
	char c=getchar();x=0;int f=1;
	while(!isdigit(c))f=c=='-'?-f:f,c=getchar();
	while(isdigit(c))x=x*10+c-'0',c=getchar();x*=f;
}
const int N=1005;
int D,S,T;
struct point
{
	long long x,y;
	double angle;
	point(){}
	point(long long x0,long long y0){x=x0;y=y0;angle=atan2(y,x);};
	void init(){read(x);read(y);angle=atan2(y,x);}
	point operator-(const point &a)const{return point(x-a.x,y-a.y);}
}d[N],s[N],t[N];
typedef point vec;
long long cross(vec a,vec b){return a.x*b.y-a.y*b.x;}
const int onseg=0,onl=1,onr=-1;
int ccw(vec a,vec b)
{
	if(cross(a,b)>(long long)0)return onl;
	else if(cross(a,b)<(long long)0)return onr;
	else return onseg;
}
bool operator<(vec a,vec b){return a.angle>b.angle;}
long long ans;
struct ray
{
	vec vc;
	bool type;
}v[N<<2];
bool sign(long long x){return x>=0;}
bool cmp(ray a,ray b){return a.vc<b.vc;}
int sd[N<<2],st[N<<2],sum[N<<2];
void solve(point p)
{
	for(int i=1;i<=D;i++)v[i]={d[i]-p,0};
	for(int i=1;i<=T;i++)v[D+i]={t[i]-p,1};
	sort(v+1,v+1+D+T,cmp);
	for(int i=1;i<=D+T;i++)v[i+D+T]=v[i];
	for(int i=1;i<=(D+T)*2;i++)
	{
		st[i]=st[i-1];
		sd[i]=sd[i-1];
		sum[i]=sum[i-1];
		if(v[i].type)
		{
			st[i]++;
			sum[i]+=sd[i];
		}
		else sd[i]++;
	}
	for(int i=1,j=1;i<=D+T;i++)if(v[i].type)
	{
		j=max(j,i);
		while(j+1<i+D+T&&ccw(v[i].vc,v[j+1].vc)<=0)j++;
		ans+=sum[j]-sum[i]-sd[i]*(st[j]-st[i]);
	}
}
int main(){
	read(D);
	for(int i=1;i<=D;i++)d[i].init();
	read(S);
	for(int i=1;i<=S;i++)s[i].init();
	read(T);
	for(int i=1;i<=T;i++)t[i].init();
	for(int i=1;i<=S;i++)solve(s[i]);
	cout<<ans<<endl;
	return 0;
}
```

**我写这道题时，因为找不到讲的比较详细的题解而走了许多弯路，花了两天才想出统计答案的办法，希望这篇题解能对读者有帮助。**




---

## 作者：6_curly_L (赞：3)

#### 题意：给定三个点集 $S,D,T$，有两条线段 $m,n$，其中 $m$ 的两端点分别属于 $D$ 和 $S$。$n$ 的两端点不相同且属于 $T$。求 $m,n$ 相交的方案数。

#### 知识点：计算几何

首先可以想到枚举 $S$ 和 $D$ 里面的点，此时形成了一条线将空间分成了左右两部分。那么必然在左右两部分中分别有一个 $T$ 中的点。

假设左边的点 $T_1,S,D$ 已经确定，那么右边的点即为 $T_1$ 与 $S$ 的连线、$S$ 与 $D$ 的连线以及 X 坐标轴之间围成的区域的所有点。

像这样。

![](https://cdn.luogu.com.cn/upload/image_hosting/eem4r84t.png)

图中灰色区域即为右端点的可选区域。

然后我们考虑每个点的极角，就可以发现满足条件的右端点都是与 X 轴夹角大于等于 $T_1$ 与 X 轴夹角的点。因此我们可以排一遍序，分别扫一遍。

但这样复杂度是 $O( n^3 \log n)$，因此我们可以在最外层枚举 $S$，分别将每个 $T$ 作为左边的点和右边的点的情况存起来，然后内层枚举时判断合不合法即可。

复杂度 $O(n^3)$，跑得比较慢但是比较好理解，有不明白的可以看代码。

注意卡一下常就好。

```CPP
#include<bits/stdc++.h>
using namespace std;

struct point{
	double x,y;
};

inline point operator - (point a,point b){ return point{a.x-b.x,a.y-b.y}; }
inline double cro(point a,point b){ return a.x*b.y-a.y*b.x; }

point d[810],s[810],t[810];
int nd,ns,nt;
point ea,eb;

struct NUM{
	double si;
	point a;
	bool lr;
}num[1610];

bool cmp(NUM x,NUM y){
	return x.si>y.si;
}

int main(){
	ea.x=1.0,ea.y=0.0;
	eb.x=-1.0,eb.y=0.0;
	scanf("%d",&nd);
	for(register int i=1;i<=nd;++i) scanf("%lf%lf",&d[i].x,&d[i].y);
	scanf("%d",&ns);
	for(register int i=1;i<=ns;++i) scanf("%lf%lf",&s[i].x,&s[i].y);
	scanf("%d",&nt);
	for(register int i=1;i<=nt;++i) scanf("%lf%lf",&t[i].x,&t[i].y);
	long long ans=0;
	for(register int i=1;i<=ns;++i){ //枚举发射源 
		for(register int j=1;j<=nt;++j){ //枚举激光塔 
			point f=s[i]-t[j],g=t[j]-s[i];
			num[(j<<1)-1].si=atan2(f.y,f.x); //同时存入该点在左边和右边的情况 
			num[(j<<1)-1].lr=0;
			num[(j<<1)-1].a=t[j];
			num[j<<1].si=atan2(g.y,g.x);
			num[j<<1].lr=1;
			num[j<<1].a=t[j];
		}
		sort(num+1,num+2*nt+1,cmp); //按极角排序 
		for(register int j=1;j<=nd;++j){ //枚举敌人 
			long long all=0;
			for(register int p=1;p<=2*nt;++p){
				bool lr=(cro(d[j]-s[i],num[p].a-s[i])>=0)?0:1;
				if(lr!=num[p].lr) continue; //如果该点当前所处左右位置与存入时不一样，直接跳过 
				if(lr) all++; //右边的点，累加答案 
				else ans+=all; //左边的点，更新答案 
			}
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：xtx1092515503 (赞：1)

# [Portal](https://www.luogu.com.cn/problem/P5545)

直接统计显然是不行的（$n^4$），我们必须得固定一个量，求出满足限制的其它三元组的个数。我选择固定发射源，并且将所有敌人与激光塔按照与当前发射源（之后称其为源点）的向量的倾角排序。

我们考虑符合条件的三元组个数。显然，因为激光塔全在 $x$ 轴下方，敌人全在 $x$ 轴上方，故在射线 $(\text{源点},\text{敌人})$ 两侧的所有激光塔对都可以与该敌人构成合法三元组。

但需要注意的是，当激光塔对与该射线无交点时，这个三元组是不合法的；稍加观察即可发现，有交点的充要条件是两激光塔的向量夹角 $<\pi$。（注意到它强调了没有三点共线的情况，这就使得很多边界情况不用处理。想要研究如何处理边界情况的，推荐[这道题](https://www.luogu.com.cn/problem/P3476)，尽管此种方法会在该题中因为常数过大而T掉）。

于是我们考虑再固定一个激光塔 $j$，则所有在其前方 $\pi$ 范围内的其它激光塔都是合法的。我们可以通过 two-pointers 求出其前方最后一个合法激光塔 $k$。

在 two-pointers 的过程中，我们可以记录以当前节点为端点时的答案 $sum$、合法区间中的激光塔数 $st$、合法区间中的敌人数 $se$。

当一个激光塔进入区间时，$st$ 增加，同时 $sum$ 增加 $se$（该激光塔、$j$、$se$ 中每个敌人，均构成一个三元组）。当一个敌人进入区间时，$se$ 增加。当一个激光塔离开区间时，$st$ 减少。当一个敌人离开区间时，$se$ 减少，并且 $sum$ 减少 $st$（理由同上）。

时间复杂度 $O\Big(S(D+T)\log (D+T)\Big)$，瓶颈在于排序。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const double pi=acos(-1);
int E,T,B;
ll res;
struct Vector{
	int x,y;
	Vector(int X=0,int Y=0){x=X,y=Y;}
	friend Vector operator +(const Vector &u,const Vector &v){return Vector(u.x+v.x,u.y+v.y);}
	friend Vector operator -(const Vector &u,const Vector &v){return Vector(u.x-v.x,u.y-v.y);}
	friend Vector operator *(const Vector &u,const int &v){return Vector(u.x*v,u.y*v);}
	friend Vector operator /(const Vector &u,const int &v){return Vector(u.x/v,u.y/v);}
	friend ll operator &(const Vector &u,const Vector &v){return 1ll*u.x*v.y-1ll*u.y*v.x;}//cross times
	friend ll operator |(const Vector &u,const Vector &v){return 1ll*u.x*v.x+1ll*u.y*v.y;}//point times
	double operator !()const{return atan2(y,x);}
	friend bool operator <(const Vector &u,const Vector &v){return !u<!v;}
	void read(){scanf("%d%d",&x,&y);}
	void print(){printf("(%d,%d)",x,y);}
}ene[810],tow[810],bea[810];
pair<Vector,bool>p[1610];
int main(){
	scanf("%d",&E);
	for(int i=1;i<=E;i++)ene[i].read();
	scanf("%d",&B);
	for(int i=1;i<=B;i++)bea[i].read();
	scanf("%d",&T);
	for(int i=1;i<=T;i++)tow[i].read();
	for(int o=1;o<=B;o++){
		int m=0;
		for(int i=1;i<=T;i++)p[m++]=make_pair(tow[i]-bea[o],0);
		for(int i=1;i<=E;i++)p[m++]=make_pair(ene[i]-bea[o],1);
		sort(p,p+m);
		int sum=0,se=0,st=0,len=0;
		for(int j=0,k=0;j<m;){
			while(len<m&&(p[j].first&p[k].first)>=0){
				if(p[k].second==1)se++;
				else sum+=se,st++;
				len++,k=(k+1)%m;
			} 
			if(p[j].second==0)res+=sum;
			if(p[j].second==0)st--;
			else sum-=st,se--;
			j++,len--;
		}
	}
	printf("%lld\n",res);
	return 0;
}
```

---


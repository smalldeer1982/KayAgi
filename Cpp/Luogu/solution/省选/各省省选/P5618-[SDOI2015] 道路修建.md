# [SDOI2015] 道路修建

## 题目描述

某国有 $2N$ 个城市，这 $2N$ 个城市构成了一个 $2$ 行 $N$ 列的方格网。现在该国政府有一个旅游发展计划，这个计划需要选定 $L$、$R$ 两列 $(L \leq  R)$，修建若干条专用道路，使得这两列之间（包括这两列）的所有 $2(R-L+1)$ 个城市中每个城市可以只通过专用道路就可以到达这 $2(R-L+1)$ 个城市中的任何一个城市。这种专用道路只能在同一行相邻两列的城市或者同一列的两个城市之间修建，且修建需要花费一定的费用。

由于该国政府决定尽量缩减开支，因此政府决定，选定 $L$、$R$ 后，只修建 $2(R-L+1)-1$ 条专用道路，使得这些专用道路构成一个树结构。现在你需要帮助该国政府写一个程序，完成这个任务。具体地，该任务包含 $M$ 个操作，每个操作的格式如下：

1. ``C x0 y0 x1 y1 w``：由于重新对第 $x_0$ 行第 $y_0$ 列的城市和第 $x_1$ 行第 $y_1$ 列的城市之间的情况进行了考察，它们之间修建一条专用道路的花费变成了 $w$；

2. ``Q L R``：若政府选定的两列分别为 $L$、$R$，询问政府的最小开支。

## 说明/提示

对于全部的数据，$1 \leq N, M \leq 60000$，任何时刻任何一条专用道路的修建费用不超过 $10^4$。

## 样例 #1

### 输入

```
3 3
1 2
2 1
3 1 2
Q 1 3
C 1 2 2 2 3
Q 2 3```

### 输出

```
7
5```

# 题解

## 作者：ImmortalWatcher (赞：20)

用线段树维护最小生成树。

我们要维护以下几个东西。

$l,r$：该区间的左（右）端点。

$l_{val},r_{val}$：区间最左（右）的竖边的权值。

$l_{max},r_{max}$：区间最左（右）的竖边及其左（右）边的所有边的最大值。

$heng_{max}$：区间横边的最大值。

$sum$：答案。

然后我们在合并区间的时候，左区间的最右竖边和右区间的最左竖边和中间的横边会形成一个环，然后根据上面的维护信息找到环中的最大值，去掉即可。

然后有一个细节：
假如我们要去掉环上的最大边正好是左区间的唯一一条竖边，那么合并后的区间的最左竖边就不能从左区间取了，要取右区间的最左竖边，同时合并后的区间的l_max也要改。所以我们在记录一下区间里有多少条竖边，然后判断是否是这个特殊情况即可。

右区间出现这种情况同理。

```cpp
#include<cstdio>
#include<algorithm>
#define max(x,y) (x>y?x:y) 
using namespace std;
int n,m,tot,x0,y0,x1,y1,l,r;
char ch[101];
long long w,heng[2][60001],shu[60001];
struct node{
	int l,r,tot,l_val,r_val;
	long long l_max,r_max,sum,heng_max;
	void read(int x) {l=r=x;l_max=r_max=l_val=r_val=sum=shu[x];tot=1;heng_max=0;}
}tree[250001];
node pushup(node x,node y)
{
	node now;
	now.l=x.l;now.r=y.r;
	now.heng_max=max(max(heng[0][x.r],heng[1][x.r]),max(x.heng_max,y.heng_max));
	int del=max(max(heng[0][x.r],heng[1][x.r]),max(x.r_max,y.l_max));
	now.sum=x.sum+y.sum+heng[0][x.r]+heng[1][x.r]-del;now.tot=x.tot+y.tot;
	now.l_val=x.l_val;now.r_val=y.r_val;
	now.l_max=x.l_max;now.r_max=y.r_max;
	if (del==x.r_val)
	{
		now.tot--;
		if (x.tot==1)
		{
			now.l_val=y.l_val;
			now.l_max=max(max(heng[0][x.r],heng[1][x.r]),max(x.heng_max,y.l_max));
		}
	}
	else if (del==y.l_val)
	{
		now.tot--;
		if (y.tot==1)
		{
			now.r_val=x.r_val;
			now.r_max=max(max(heng[0][x.r],heng[1][x.r]),max(x.r_max,y.heng_max));
		}
	}
	return now;
}
void build(int k,int l,int r)
{
	if (l==r) 
	{
		tree[k].read(l);
		return;
	}
	int mid=(l+r)>>1;
	build(k*2,l,mid);build(k*2+1,mid+1,r);
	tree[k]=pushup(tree[k*2],tree[k*2+1]);
}
void update(int k,int l,int r,int x)
{
	if (l==r&&l==x)
	{
		tree[k].read(x);
		return;
	}
	int mid=(l+r)>>1;
	if (x<=mid) update(k*2,l,mid,x);
	else update(k*2+1,mid+1,r,x);
	tree[k]=pushup(tree[k*2],tree[k*2+1]);
}
void change(int k,int l,int r,int x)
{
	if (l==r&&l==x) return;
	int mid=(l+r)>>1;
	if (x<=mid) change(k*2,l,mid,x);
	else change(k*2+1,mid+1,r,x);
	tree[k]=pushup(tree[k*2],tree[k*2+1]);
}
node query(int k,int l,int r,int x,int y)
{
	if (x<=l&&r<=y) return tree[k];
	int mid=(l+r)>>1;
	if (y<=mid) return query(k*2,l,mid,x,y);
	if (x>mid) return query(k*2+1,mid+1,r,x,y);
	return pushup(query(k*2,l,mid,x,y),query(k*2+1,mid+1,r,x,y));
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<n;i++) scanf("%lld",&heng[0][i]);
	for (int i=1;i<n;i++) scanf("%lld",&heng[1][i]);
	for (int i=1;i<=n;i++) scanf("%lld",&shu[i]);
	getchar();getchar();
	build(1,1,n);
	for (int i=1;i<=m;i++)
	{
		scanf("%s",ch);
		if (ch[0]=='C')
		{
			scanf("%d%d%d%d%lld",&x0,&y0,&x1,&y1,&w);
			getchar();
			if (y0==y1) shu[y0]=w,update(1,1,n,y0);
			else
			{
				if (y0>y1) swap(y0,y1);
				heng[x0-1][y0]=w;
				change(1,1,n,y0);
			}
		}
		else
		{
			scanf("%d%d",&l,&r);getchar();
			printf("%lld\n",query(1,1,n,l,r).sum);
		}
	}
	return 0;
}
```


---

## 作者：Prean (赞：8)

有坑，但是不难（

看到题的第一眼使用线段树，对区间维护两个状态，上面和下面是否连通。

然后你发现会被环给 gank 掉。

于是重新设状态，设 $w_{0/1,0/1}$ 表示左右端点中，上下节点是否连通。

这个相当好转移，只需要考虑合并的位置是否处于同一个连通块然后决定加上 $x+y$ 还是 $\min(x,y)$ 即可。

复杂度 $O(m\log n)$ ~~比那个在环上删边的状态不知道高到哪里去了~~
```cpp
#include<cstdio>
#include<cctype>
const int M=6e4+5;
int n,m,w1[M],w2[M];
inline char read_c(){
	char s;while(!isalpha(s=getchar()));return s;
}
inline int read(){
	int n(0);char s;while(!isdigit(s=getchar()));while(n=n*10+(s&15),isdigit(s=getchar()));return n;
}
inline void write(int n){
	static char s[15];int top(0);while(s[++top]=n%10^48,n/=10);while(putchar(s[top]),--top);putchar(10);
}
struct data{
	int w[2][2];
	inline int*operator[](const int&x){
		return w[x];
	}
}t[M<<2];
inline int min(const int&a,const int&b){
	return a>b?b:a;
}
inline data Merge(data a,const int&x,const int&y,data b){
	data ans;
	ans[0][0]=min(a[0][1]+b[1][0]+min(x,y),min(a[0][0]+b[1][0],a[0][1]+b[0][0])+x+y);
	ans[1][0]=min(a[1][1]+b[1][0]+min(x,y),min(a[1][0]+b[1][0],a[1][1]+b[0][0])+x+y);
	ans[0][1]=min(a[0][1]+b[1][1]+min(x,y),min(a[0][0]+b[1][1],a[0][1]+b[0][1])+x+y);
	ans[1][1]=min(a[1][1]+b[1][1]+min(x,y),min(a[1][0]+b[1][1],a[1][1]+b[0][1])+x+y);
	return ans;
}
inline void update(const int&u,const int&L,const int&R){
	const int&mid=L+R>>1;t[u]=Merge(t[u<<1],w1[mid],w2[mid],t[u<<1|1]);
}
inline void Build(const int&u,const int&L=1,const int&R=n){
	if(L==R)return void(t[u][1][1]=read());
	const int&mid=L+R>>1;Build(u<<1,L,mid);Build(u<<1|1,mid+1,R);update(u,L,R);
}
inline void Mdf(const int&u,const int&x,const int&w,const int&L=1,const int&R=n){
	if(L==R)return void(t[u][1][1]=w);
	const int&mid=L+R>>1;x<=mid?Mdf(u<<1,x,w,L,mid):Mdf(u<<1|1,x,w,mid+1,R);update(u,L,R);
}
inline void Update(const int&u,const int&x,const int&L=1,const int&R=n){
	const int&mid=L+R>>1;if(x!=mid)x<=mid?Update(u<<1,x,L,mid):Update(u<<1|1,x,mid+1,R);update(u,L,R);
}
inline data Qry(const int&u,const int&l,const int&r,const int&L=1,const int&R=n){
	if(l<=L&&R<=r)return t[u];
	const int&mid=L+R>>1;if(r<=mid)return Qry(u<<1,l,r,L,mid);if(l>mid)return Qry(u<<1|1,l,r,mid+1,R);
	return Merge(Qry(u<<1,l,r,L,mid),w1[mid],w2[mid],Qry(u<<1|1,l,r,mid+1,R));
}
signed main(){
	n=read();m=read();for(int i=1;i<n;++i)scanf("%d",w1+i);for(int i=1;i<n;++i)scanf("%d",w2+i);Build(1);
	for(int i=1;i<=m;++i){
		char s=read_c();
		if(s=='C'){
			int x0,y0,x1,y1;x0=read();y0=read();x1=read();y1=read();
			if(y0==y1)Mdf(1,y0,read());else(x0==1?w1:w2)[min(y0,y1)]=read(),Update(1,min(y0,y1));
		}
		if(s=='Q'){
			int L,R;L=read();R=read();write(Qry(1,L,R)[1][1]);
		}
	}
}
```

---

## 作者：__Aaaaaaaa (赞：5)

题面大意：给出两排点，给出同一列的两个点之间的边权和同一行相邻的点之间的边权，存在在线操作修改和查询，修改是某条边的边权，查询是一个区间内的最小生成树的边权总和。

Solution：  
考虑用线段树维护每个区间的情况。

$\mathit{dp}_{1/0,1/0}$：区间最左的纵边连/不连且右边的纵边连/不连，并将区间内的这些点连成一棵最小生成树所需的最小边权。

下面考虑转移：合并 $L$ 和 $R$ 两个节点，设 $L$ 表示区间内最右的纵边为 $y0$，$R$ 表示区间内最左的纵边为 $y1$，它们两个相邻区间中间的两条横边为 $x0$ 和 $x1$。

第一种情况是连接一条横边，即对于所有的 $(i,j,c1,c2\in [0,1])$ 都要执行以下转移。  
```
U.dp[i][j]=min(U.dp[i][j],L.dp[i][c1]+R.[c2][j]+min(x0,x1));
```
第二种情况是 $y0$ 或 $y1$ 是保证连接的情况下，拆除其中一条，两条横边都连。   
即对于所有的 $(i,j,c2\in [0,1])$ 都要执行以下转移。 
```
U.dp[i][j]=min(U.dp[i][j],L.dp[i][1]+R.dp[c2][j]-y0+x0+x1);
```

对于所有的 $(i,j,c1\in [0,1])$ 都要执行以下转移。   
```
U.dp[i][j]=min(U.dp[i][j],L.dp[i][c1]+R.dp[1][j]-y1+x0+x1);
```

还有就是要考虑 $L$ 或 $R$ 是叶子节点（最左等于最右）。

这样一来 ```pushup``` 函数就写好了 ~~，剩下的就是敲模板~~。

### Don't talk much:
```
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int N=6e4+10,INF=1e9;
struct tree{
	int l,r;
	int dp[2][2];
	void init_INF(){
		memset(dp,0x3f,sizeof dp);
	}
}tr[N<<2];
int col[N],row1[N],row2[N];//对应位置的横边、纵边
void pushup(tree &U,tree &L,tree &R){
	U.l=L.l,U.r=R.r;
	int x0=row1[L.r],x1=row2[L.r];
	int y0=col[L.r],y1=col[R.l];
	bool leafL=L.l==L.r,leafR=R.l==R.r;
	U.init_INF();
	if(leafL&&leafR){//特判:左右都是叶子节点
		U.dp[0][1]=x0+x1+y1;
		U.dp[1][0]=x0+x1+y0;
		U.dp[1][1]=y0+y1+min(x0,x1);
		return;
	}
	else if(leafL){//特判:左儿子是叶子节点
		U.dp[0][0]=x0+x1+min(R.dp[0][0],R.dp[1][0]);
		U.dp[0][1]=x0+x1+min(R.dp[0][1],R.dp[1][1]);
		U.dp[1][0]=y0+min(min(R.dp[0][0],R.dp[1][0])+min(x0,x1),
		x1+x0+R.dp[1][0]-y1);
		U.dp[1][1]=y0+min(min(R.dp[0][1],R.dp[1][1])+min(x0,x1),
		x1+x0+R.dp[1][1]-y1);
		return;
	}
	else if(leafR){//特判:右儿子是叶子节点
		U.dp[0][0]=x0+x1+min(L.dp[0][0],L.dp[0][1]);
		U.dp[1][0]=x0+x1+min(L.dp[1][0],L.dp[1][1]);
		U.dp[0][1]=y1+min(min(L.dp[0][0],L.dp[0][1])+min(x0,x1),
		x1+x0+L.dp[0][1]-y0);
		U.dp[1][1]=y1+min(min(L.dp[1][0],L.dp[1][1])+min(x0,x1),
		x1+x0+L.dp[1][1]-y0);
		return;
	}
	for(int i=0;i<2;i++)//正常转移
	for(int j=0;j<2;j++)
	for(int c1=0;c1<2;c1++)
	for(int c2=0;c2<2;c2++){
		int tp=L.dp[i][c1]+R.dp[c2][j]+min(x0,x1);
		U.dp[i][j]=min(U.dp[i][j],tp);
		if(c1){
			U.dp[i][j]=min(U.dp[i][j],tp-y0+max(x0,x1));
		}
		if(c2){
			U.dp[i][j]=min(U.dp[i][j],tp-y1+max(x0,x1));
		}
	}
}
void pushup(int u){
	pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}
void build(int u,int l,int r){
	tr[u]=(tree){l,r};
	if(l==r){
		tr[u].init_INF();
		tr[u].dp[1][1]=col[l];
		return;
	}
	int mid=l+r>>1;
	build(u<<1,l,mid);
	build(u<<1|1,mid+1,r);
	pushup(u);	
}
void modify(int u,int x){
	if(tr[u].l==tr[u].r){
		tr[u].init_INF();
		tr[u].dp[1][1]=col[x];
		return;
	}
	int mid=tr[u].l+tr[u].r>>1;
	if(mid>=x)
		modify(u<<1,x);
	else
		modify(u<<1|1,x);
	pushup(u);
}
tree query(int u,int l,int r){
	if(tr[u].l>=l&&tr[u].r<=r)
		return tr[u];
	int mid=tr[u].l+tr[u].r>>1;
	if(mid>=r)return query(u<<1,l,r);
	if(mid<l)return query(u<<1|1,l,r);
	tree L=query(u<<1,l,r),R=query(u<<1|1,l,r),U;
	pushup(U,L,R);
	return U;
}
int n,m;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++)
		scanf("%d",row1+i);
	for(int i=1;i<n;i++)
		scanf("%d",row2+i);
	for(int i=1;i<=n;i++)
		scanf("%d",col+i);
	build(1,1,n);
	char opt[2];
	int x0,y0,x1,y1,w;
	while(m--){
		scanf("%s",opt);
		if(opt[0]=='C'){
			scanf("%d%d%d%d%d",&x0,&y0,&x1,&y1,&w);
			if(x0!=x1){
				col[y0]=w;
				modify(1,y0);
			}
			else{
				if(y0>y1)swap(y0,y1);
				if(x0==1)
					row1[y0]=w;
				else
					row2[y0]=w;
			}
			modify(1,y0);//修改了边权后需要从最深到根pushup一遍
		}
		else{
			scanf("%d%d",&x0,&y0);
			tree tp=query(1,x0,y0);
			printf("%d\n",min(min(tp.dp[0][0],tp.dp[0][1]),min(tp.dp[1][0],tp.dp[1][1])));
		}
	}
	return 0;
}
```

---

## 作者：teylnol_evteyl (赞：5)

## 题目分析

虽然数据范围只有 $n\le60000$，但是完全可以直接用线段树做。

首先考虑那种状态的图在左边和右边加入节点和边之后可以连通。容易发现，这种图有这两个性质：

- 至少有一条路径，经过最左端和最右端中的点。
- 所有点至少和最左端和最右端的点连通。

于是可以划分成以下几种状态：

1. 最左端两个点不连通，最右端两个点不连通，只有一条经过最左端和最右端中的点的路径；
2. 最左端两个点连通，最右端两个点不连通；
3. 最左端两个点不连通，最右端两个点连通；
4. 最左端两个点连通，最右端两个点连通；
5. 最左端两个点不连通，最右端两个点不连通，有两条经过最左端和最右端中的点的路径。

如图：

![状态](https://cdn.luogu.com.cn/upload/image_hosting/9ntoz8xy.png)

然后分类讨论每两种状态的连接方法和结果状态，如图所示的几种情况：


![](https://cdn.luogu.com.cn/upload/image_hosting/kz3rm503.png)

剩余情况见代码 pushup 函数。

用线段树维护，记录以下东西：

- $a,b$：区间左端点和又端点。
- $v1,v2,v3,v4,v5$：区间中每种状态最小费用。

对于竖边修改，修改包含需要修改的点的区间；对于横边修改，只需修改列数较小的点即可。

查询输出对应区间的 $v4$ 的。

这里有个坑点：输入修改操作时可能把列数大的点放在前面，这时要把较小的点设为后输入的点。

## 示例代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;

const int N = 60005, INF = 2e9;

int n, m;
int x[N], y[N], z[N];
struct node{
	int a, b;
	LL v1, v2, v3, v4, v5;
}t[N * 4];

void pushup(node &u, node ls, node rs)
{
	int p = x[ls.b], q = y[ls.b], c = p + q, d = min(p, q);
	u.v1 = u.v2 = u.v3 = u.v4 = u.v5 = INF;
	u.v1 = min(u.v1, ls.v1 + rs.v2 + c);
	u.v3 = min(u.v3, ls.v1 + rs.v4 + c);
	u.v1 = min(u.v1, ls.v1 + rs.v5 + c);
	u.v2 = min(u.v2, ls.v2 + rs.v2 + c);
	u.v4 = min(u.v4, ls.v2 + rs.v4 + c);
	u.v2 = min(u.v2, ls.v2 + rs.v5 + c);
	u.v1 = min(u.v1, ls.v3 + rs.v1 + c);
	u.v1 = min(u.v1, ls.v3 + rs.v2 + d);
	u.v3 = min(u.v3, ls.v3 + rs.v3 + c);
	u.v3 = min(u.v3, ls.v3 + rs.v4 + d);
	u.v3 = min(u.v3, ls.v3 + rs.v5 + c);
	u.v1 = min(u.v1, ls.v3 + rs.v5 + d);
	u.v2 = min(u.v2, ls.v4 + rs.v1 + c);
	u.v2 = min(u.v2, ls.v4 + rs.v2 + d);
	u.v4 = min(u.v4, ls.v4 + rs.v3 + c);
	u.v4 = min(u.v4, ls.v4 + rs.v4 + d);
	u.v4 = min(u.v4, ls.v4 + rs.v5 + c);
	u.v2 = min(u.v2, ls.v4 + rs.v5 + d);
	u.v1 = min(u.v1, ls.v5 + rs.v1 + c);
	u.v2 = min(u.v2, ls.v5 + rs.v2 + c);
	u.v1 = min(u.v1, ls.v5 + rs.v2 + d);
	u.v3 = min(u.v3, ls.v5 + rs.v3 + c);
	u.v4 = min(u.v4, ls.v5 + rs.v4 + c);
	u.v3 = min(u.v3, ls.v5 + rs.v4 + d);
	u.v5 = min(u.v5, ls.v5 + rs.v5 + c);
	u.v1 = min(u.v1, ls.v5 + rs.v5 + d);
	u.a = ls.a, u.b = rs.b;
}

void build(int u, int a, int b)
{
	t[u].a = a, t[u].b = b;
	if(a == b)
	{
		t[u].v1 = t[u].v2 = t[u].v3 = INF;
		t[u].v5 = 0;
		t[u].v4 = z[a];
		return ;
	}
	int mid = a + b >> 1, ls = u << 1, rs = ls | 1;
	build(ls, a, mid), build(rs, mid + 1, b);
	pushup(t[u], t[ls], t[rs]);
}

void modify(int u, int d)
{
	if(t[u].a == t[u].b)
	{
		t[u].v1 = t[u].v2 = t[u].v3 = INF;
		t[u].v5 = 0;
		t[u].v4 = z[t[u].a];
		return ;
	}
	int ls = u << 1, rs = ls | 1;
	if(t[ls].b >= d) modify(ls, d);
	else modify(rs, d);
	pushup(t[u], t[ls], t[rs]);
}

node query(int u, int x, int y)
{
	if(x <= t[u].a && t[u].b <= y) return t[u];
	int ls = u << 1, rs = ls | 1;
	if(t[ls].b >= x && t[rs].a <= y)
	{
		node res;
		pushup(res, query(ls, x, y), query(rs, x, y));
		return res;
	}
	else if(t[ls].b >= x) return query(ls, x, y);
	else return query(rs, x, y);
}

int main()
{
	scanf("%d%d", &n, &m);
	for(int i = 1; i < n; i ++ ) scanf("%d", &x[i]);
	for(int i = 1; i < n; i ++ ) scanf("%d", &y[i]);
	for(int i = 1; i <= n; i ++ ) scanf("%d", &z[i]);
	
	build(1, 1, n);
	while(m -- )
	{
		char op[2];
		scanf("%s", op);
		if(*op == 'Q')
		{
			int l, r;
			scanf("%d%d", &l, &r);
			printf("%lld\n", query(1, l, r).v4);
		}
		else
		{
			int ax, bx, ay, by, w;
			scanf("%d%d%d%d%d", &ay, &ax, &by, &bx, &w);
			if(ax == bx)
			{
				z[ax] = w;
				modify(1, ax);
			}
			else
			{
				if(ax > bx) ax = bx;
				if(ay == 1) x[ax] = w;
				else y[ax] = w;
				modify(1, ax);
			}
		}
	}
	return 0;
}
```

---

## 作者：JimmyLee (赞：2)

# 题意

给定一个 $2\times N$ 的网格，网格上的点和上下左右连边。

要求支持以下几种操作：

- 修改某条边的边权。

- 求满足 $y\in[l,r]$ 的点构成的点集的最小生成树。

# 分析

这道题的想法和 [P4246 [SHOI2008] 堵塞的交通](https://www.luogu.com.cn/problem/P4246) 很相似。

注意到 $N, M \leq 6\times 10^4$，并且查询的是 $y\in[l,r]$ 的点构成的点集的最小生成树，考虑使用线段树维护。

我们考虑如何合并两个区间。

例如，下图的两个区间：

![](https://cdn.luogu.com.cn/upload/image_hosting/g8i3bess.png)

首先，我们将两个区间之间的边 $BC, FG$ 加入这两个联通块中，让它们成为一个联通块。

因为 $B$ 和 $F$ 是联通的，$C$ 和 $G$ 是联通的，这样势必会形成一个环。

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2itjelt8.png)

为了让它成为一棵树，我们需要删掉其中的一条边。

并且为了保证它是一棵最小生成树，我们应该删去边权最大的边。

到这里，我们维护的对象就显而易见了。

我们维护以下值：

![](https://cdn.luogu.com.cn/upload/image_hosting/a5lhk84k.png)

- `lu`：最左侧的垂直的生成树边上端点到左上角这一段中边的边权的最大值（即 $AE$ 段中的边权最大值）
- `ld`：最左侧的垂直的生成树边下端点到左下角这一段中边的边权的最大值（即 $CG$ 段中的边权最大值）
- `ru`：最右侧的垂直的生成树边上端点到右上角这一段中边的边权的最大值（即 $BF$ 段中的边权最大值）
- `rd`：最右侧的垂直的生成树边下端点到右下角这一段中边的边权的最大值（即 $DH$ 段中的边权最大值）
- `lv`：最左侧的垂直的生成树边的边权（即 $EG$ 的边权）
- `rv`：最右侧的垂直的生成树边的边权（即 $FH$ 的边权）
- `ans`：该段的最小生成树的边权和。

我们再回头看我们要合并的东西：

![](https://cdn.luogu.com.cn/upload/image_hosting/2itjelt8.png)

我们要删除的就是 $IK,KF,FG,LG,JL,CJ,BC,IB$ 这些段中边权最小的一条边。

发现如果删除的是 $KF,FG,LG,CJ,BC,IB$ 这些非垂直边，合并出的新段直接继承左右两端的信息即可。

但是如果删去了垂直边，可能出现某一侧区间没有垂直边的情况。

所以我们需要记录一个 `cnt` 来表示某个区间中有多少条垂直边。

假设左侧失去了垂直边，那么新区间的 `lv` 就应该是右区间的 `lv`，其他的信息同理。


# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 60004

/*
lu           ru  vu
-+-+-+-+-+-+--- ==== ---+-+-+
   |       |            |  
  lv       rv           |  
   |       |            |  
-+-+-+-+-+-+--- ==== ---+-+-+
ld           rd  vd
*/

int vu[maxn], vd[maxn];

struct SegT
{
    struct node
    {
        int R, lv, rv, lu, ru, ld, rd, cnt, ans;
        node(int p=0, int v=0) {R=p, lv=rv=ans=v, lu=ru=ld=rd=0, cnt=1;}
        friend node operator+(node a, node b)
        {
            node ret;
            ret.R=b.R;
            ret.ans=a.ans+b.ans+vu[a.R]+vd[a.R];
            ret.cnt=a.cnt+b.cnt;
            int mx=max({vu[a.R], vd[a.R], a.ru, a.rd, b.lu, b.ld, a.rv, b.lv});
            ret.ans-=mx;
            ret.lv=a.lv, ret.rv=b.rv;
            ret.lu=a.lu, ret.ld=a.ld;
            ret.ru=b.ru, ret.rd=b.rd;
            if(mx==a.rv)
            {
                ret.cnt--;
                if(a.cnt==1)
                {
                    ret.lv=b.lv, ret.rv=b.rv;
                    ret.ld=max({a.ld, a.rd, b.ld, vd[a.R]});
                    ret.lu=max({a.lu, a.ru, b.lu, vu[a.R]});
                    ret.ru=b.ru, ret.rd=b.rd;
                }
            }
            else if(mx==b.lv)
            {
                ret.cnt--;
                if(b.cnt==1)
                {
                    ret.lv=a.lv, ret.rv=a.rv;
                    ret.rd=max({b.rd, b.ld, a.rd, vd[a.R]});
                    ret.ru=max({b.ru, b.lu, a.ru, vu[a.R]});
                    ret.lu=a.lu, ret.ld=a.ld;
                }
            }
            return ret;
        }
    }tr[maxn<<2];

    #define lc x<<1
    #define rc x<<1|1
    #define mid ((l+r)>>1)
    #define lson lc, l, mid
    #define rson rc, mid+1, r

    void modify(int x, int l, int r, int p, int v)
    {
        if(l==r) return tr[x]=node(p, v), void();
        if(p<=mid) modify(lson, p, v);
        if(p>mid)  modify(rson, p, v);
        tr[x]=tr[lc]+tr[rc];
    }

    void upd(int x, int l, int r, int p)
    {
        if(l==r) return;
        if(p<=mid) upd(lson, p);
        if(p>mid)  upd(rson, p);
        tr[x]=tr[lc]+tr[rc];
    }

    auto query(int x, int l, int r, int L, int R)
    {
        if(L<=l&&r<=R) return tr[x];
        if(R<=mid) return query(lson, L, R);
        if(L>mid)  return query(rson, L, R);
        return query(lson, L, R)+query(rson, L, R);
    }
}tr;

int main()
{
    int n, m;
    cin>>n>>m;
    for(int i=1;i<n;i++) cin>>vu[i];
    for(int i=1;i<n;i++) cin>>vd[i];
    for(int i=1, t;i<=n;i++)
    {
        cin>>t;
        tr.modify(1, 1, n, i, t);
    }
    char op;
    int x0, y0, x1, y1, w, L, R;
    while(m--)
    {
        cin>>op;
        if(op=='C')
        {
            cin>>x0>>y0>>x1>>y1>>w;
            if(x0==x1) (x0==1?vu:vd)[min(y0, y1)]=w, tr.upd(1, 1, n, min(y0, y1));
            else tr.modify(1, 1, n, y0, w);
        }
        if(op=='Q')
        {
            cin>>L>>R;
            cout<<tr.query(1, 1, n, L, R).ans<<'\n';
        }
    }
}
```

---

## 作者：六楼溜刘 (赞：1)

# P5618 [SDOI2015] 道路修建

[传送门](https://www.luogu.com.cn/problem/P5618)

这么版的题怎么都没人写 DDP（动态动态规划）做法啊。

## 题意

- 有一个两行 $n$ 列的网格图，四联通连边，每条边有边权。
- 有两个操作共 $q$ 次：
    - 修改某条边的边权。
    - 查询区间 $[l,r]$ 内两行共 $2(r-l+1)$ 个点的最小生成树。
- $1\le n,q\le 60000$，边权不超过 $10^4$。

## 题解

晚自习 20min 切了，但是唐诗错误 WA 一发，但是洛谷最优解。

考虑静态问题（即没有修改，只有一次全局查询），容易想到 DP（因为只能相邻连边，所以这一列想和之前的连边必须和上一列连，那么可以对每一列设状态，从上一列转移）。

具体来说，设 $dp_{i,0/1}$ 表示考虑前 $i$ 列，第 $i$ 列两个点是否已经联通的最小代价。

转移很显然，具体如下（$d1$ 表示这一列第一行与上一列连边的边权，$d2$ 表示第二行，$d3$ 表示这一类的纵向连边）：

$$
dp_{i,0}=\min(dp_{i-1,1}+\min(d1,d2),dp_{i-1,0}+d1+d2)
$$
$$
dp_{i,1}=\min(dp_{i-1,1}+\min(d1+d2,d1+d3,d2+d3),dp_{i-1,0}+d1+d2+d3)
$$

初始状态为 $dp_{1,0}=0,dp_{1,1}=d3$。

然后用 $\min,+$ 的广义矩阵扔到线段树上维护一下就做完了。

具体来说，一般矩阵乘法（$A\times B=C$，此处以 $2\times 2$ 矩阵为例）的定义是 $C_{i,j}=\sum_{k=0}^1A_{i,k}\times B_{k,j}$，$\oplus,\otimes$（这代指两种运算）的广义矩阵乘法定义是 $C_{i,j}=\bigoplus A_{i,k}\otimes B_{k,j}$，容易证明只要 $\oplus$ 有交换律，$\otimes$ 有结合律和交换律，$\otimes$ 对 $\oplus$ 有分配率即可得到有结合律的矩阵乘法，具体证明考虑将 $(A\times B)\times C$ 和 $A\times(B\times C)$ 分别暴力拆开，此处略过。

然后容易发现用 $\min$ 代替 $\oplus$，用加法代替 $\otimes$ 即可完美地概括此题的 DP 转移，具体矩阵请自行构造，转移已给出。

复杂度 $O(n\log nk^3)$，其中 $k=2$，为矩阵边长。


```cpp
#include<bits/stdc++.h>
#define forup(i,s,e) for(int i=(s),E123123123=(e);i<=E123123123;++i)
#define fordown(i,s,e) for(int i=(s),E123123123=(e);i>=E123123123;--i)
#define mem(a,b) memset(a,b,sizeof(a))
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void();
#endif
using namespace std;
using i64=long long;
#define gc getchar()
int read(){
	int x=0,f=1;char c;
	while(!isdigit(c=gc)) if(c=='-') f=-1;
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc;}
	return x*f;
}
#undef gc
const int N=6e4+5,inf=0x3f3f3f3f;
struct Matrix{
	int c[2][2];
	Matrix(int a1=0,int a2=0,int a3=0,int a4=0){
		c[0][0]=a1;
		c[0][1]=a2;
		c[1][0]=a3;
		c[1][1]=a4;
	}
	Matrix operator *(const Matrix &r){//广义矩阵乘法。
		Matrix res;
		forup(i,0,1){
			forup(j,0,1){
				res.c[i][j]=inf;
				forup(k,0,1){
					res.c[i][j]=min(res.c[i][j],c[i][k]+r.c[k][j]);
				}
			}
		}
		return res;
	}
};
int n,m,d1[N],d2[N],d3[N];
Matrix tr(int l){//转移矩阵。
	return Matrix(d1[l]+d2[l],d1[l]+d2[l]+d3[l],min(d1[l],d2[l]),min({d1[l]+d2[l],d1[l]+d3[l],d2[l]+d3[l]}));
}
struct SegTree{//线段树维护区间矩阵广义积。
	#define mid ((l+r)>>1)
	#define lson l,mid,id<<1
	#define rson mid+1,r,id<<1|1
	Matrix mat[N<<2];
	void PushUp(int id){
		mat[id]=mat[id<<1]*mat[id<<1|1];
	}
	void Build(int l=1,int r=n,int id=1){//初始化。
		if(l==r){
			mat[id]=tr(l);
			return;
		}
		Build(lson);Build(rson);
		PushUp(id);
	}
	void Update(int P,int l=1,int r=n,int id=1){//单点修改。
		if(l==r){
			mat[id]=tr(l);
			return;
		}
		if(P<=mid) Update(P,lson);
		else       Update(P,rson);
		PushUp(id);
	}
	Matrix Query(int L,int R,int l=1,int r=n,int id=1){//区间查询。
		if(L<=l&&r<=R){
			return mat[id];
		}
		Matrix res(0,inf,inf,0);
		if(L<=mid) res=res*Query(L,R,lson);
		if(mid< R) res=res*Query(L,R,rson);
		return res;
	}
}mt;
char str[5];
signed main(){
	n=read();m=read();
	forup(i,2,n) d1[i]=read();
	forup(i,2,n) d2[i]=read();
	forup(i,1,n) d3[i]=read();
	mt.Build();//记得初始化。
	forup(i,1,m){
		scanf(" %s",str);
		if(str[0]=='C'){
			int x1=read(),y1=read(),x2=read(),y2=read(),w=read();
			if(x1>x2) swap(x1,x2);
			if(y1>y2) swap(y1,y2);
			if(x1==1){
				if(x2==1){
					d1[y2]=w;
				}else{
					d3[y2]=w;
				}
			}else{
				d2[y2]=w;
			}
			mt.Update(y2);
		}else{
			int l=read(),r=read();
			Matrix res=mt.Query(l+1,r);
			res=Matrix(0,d3[l],-inf,-inf)*res;
			printf("%d\n",res.c[0][1]);//最后答案显然必须连通。
		}
	}
}
```

---


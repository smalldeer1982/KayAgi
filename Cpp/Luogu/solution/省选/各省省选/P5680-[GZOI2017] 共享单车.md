# [GZOI2017] 共享单车

## 题目背景

GZOI2017 D2T3

## 题目描述

某校校内有 A 公司与 B 公司两家共享单车公司相互竞争。A 公司为了尽可能提升自己在校园内的占有率，会设法阻碍 B 公司的回收行动。

整个校园由 $N$ 个区域和 $M$ 条道路组成，每条道路连接两个区域。校园有一个区域 $K$ 是 B 公司的大本营，所有的单车回收行动从该区域 **出发**。B 公司为了减少成本，回收时从区域 $K$ 到任何一个区域 $X$ 都选择长度 **最短** 的路径，如果有多条到某一个区域的最短路径，则选择所有最短路径中该区域的前一区域 **编号最小** 的一条路径，称这条路径为 $K$ 到 $X$ 的 **回收路线**。所有的 **回收路线** 组成一棵树状结构，称之为 **回收路线树**。如下图中，绿色的边构成的就是一棵 **回收路线树**。

![](https://cdn.luogu.com.cn/upload/image_hosting/x0cksrjz.png)

B 公司每次会回收若干个区域的单车，称这些区域为 **回收区域**。B 公司还将某些区域设为 **投放区域**，称其余区域为 **非投放区域**。在 **回收路线树** 上，标记出区域 $K$，标记出所有的 **回收区域**，以及标记出任意两个 **回收区域** 在 **回收路线树** 上的最近公共祖先。

如下图，假设 $4$ 与 $6$ 号区域是 **投放区域**，$4, 5, 6$ 号区域是**回收区域**，则被标记的区域有 $1, 4, 5, 6$。

![](https://cdn.luogu.com.cn/upload/image_hosting/mdwo6dcn.png)

A 公司对 B 公司的回收行动造成了阻碍，**当且仅当** 对任意一个 $K$ 以外的被标记的 **投放区域** $X$，从区域 $K$ 到 $X$ 的 **回收路线上** 都存在两个被标记的区域，它们之间 **所有道路**（回收路线树上两点路径）被阻碍。

阻碍一条道路的代价为该道路的长度。上图中 A 公司选择阻碍 $1 \rightsquigarrow  4$，$5 \rightsquigarrow 6$ 两条路径，代价为 $3+4+3=10$。

你的任务是帮助 A 公司计算如何以最小的代价，阻碍 B 公司的回收行动。

## 说明/提示

【数据约束】

对于 $30\%$ 的数据，$N\le 200$，$Q\le 200$；

对于 $60\%$ 的数据，保证每次 **回收区域** 数量恒为 $N-1$；

对于 $80\%$ 的数据，$N\le 20000$，$M=N-1$，$Q\le 1000$，$num\le 200$；

对于 $100\%$ 的数据，$N\le 50000$，$M\le 100000$，$Q\le 1500$，$num\le 500$。

所有数据保证道路无自环，所有道路长度小于 $2000$，且区域 $K$ 任意时刻均非**投放区域**。

## 样例 #1

### 输入

```
6 6 1 4
1 2 3
2 3 2
2 4 4
3 6 4
1 5 5
5 6 3
0 3 3 4 6
1 3 4 5 6
0 1 3
1 4 3 4 5 6```

### 输出

```
10
6```

## 样例 #2

### 输入

```
12 11 4 5
4 1 32
4 6 42
1 3 29
7 1 17
7 10 23
9 7 21
5 6 16
2 6 28
5 8 14
8 11 11
8 12 17
1 11 1 2 3 5 6 7 8 9 10 11 12
0 4 3 11 5 2
1 4 10 9 6 11
0 4 7 8 12 11
1 4 11 2 9 10```

### 输出

```
-1
41
77```

# 题解

## 作者：Cipher0128 (赞：6)

反复读完题后我们终于知道了要干什么：

建树，建虚树，求最值。

建树：在原图跑单源最短路，转移时特判距离相同取编号小者，并记录每个点从哪个点转移过来，最后找出最短路构成的树。

建虚树：回收区域是关键点，应拿它们建虚树，边权就是它们在回收路线上的距离。

求最值：用 $dp$ 求，设有节点 $x$，其子节点为 $y$，若 $y$ 被标记，这条路一定要被阻断，$x$ 的费用加上 $v_{x,y}$；否则可断可不断，$x$ 的费用加上 $v_{x,y}$ 与 $y$ 的费用的最小值。

代码：

```cpp
#include<bits/stdc++.h>
#define rd read()
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define ll long long
#define pb push_back
#define mkp make_pair
#define for_(a,b,c) for(int a=b;a<=c;++a)
#define For_(a,b,c) for(int a=b;a>=c;--a)
using namespace std;
int n,m,S,Q,H;
const int N=4e5+10;
vector<pair<int,int>>vv[N],v[N],e[N];
struct node{
	int x,d;
};
priority_queue<node>q;
bool operator<(const node A,const node B){
	return A.d>B.d;
}
ll dis[N],id[N];
bool vis[N];
void dij() {
	memset(dis,0x3f,sizeof(dis));
	dis[S]=0;
	q.push({S,0});
	while(!q.empty()) {
		node h=q.top();
		q.pop();
		int x=h.x;
		if(vis[x])continue;
		vis[x]=1;
		for(auto h:vv[x]){
			int y=h.first,val=h.second;
			ll s=dis[x]+val;
			if(s<dis[y]){
				dis[y]=s;
				id[y]=x;
				q.push({y,dis[y]});
			}
			else if(s==dis[y]){
				id[y]=min(id[y],x);
			}
		}
	}
}
int st[N],tp;
ll P(ll x,ll y){
	return x*N+y;
}
unordered_map<ll,bool>mp;
int dep[N],dfn[N],td,f[N][30];
void dfs_LCA(int x){
	dfn[x]=++td;
	for(auto h:v[x]){
		int y=h.first,val=h.second;
		dep[y]=dep[x]+1;
		f[y][0]=x;
		dfs_LCA(y);
	}
}
int LCA(int x,int y){
	if(dep[x]<dep[y])swap(x,y);
	For_(i,H,0)if(dep[f[x][i]]>=dep[y])x=f[x][i];
	if(x==y)return x;
	For_(i,H,0)if(f[x][i]^f[y][i])x=f[x][i],y=f[y][i];
	return f[x][0];
}
int num;
int k[N];
bool cmp(int x,int y){
	return dfn[x]<dfn[y];
}
int a[N],tot;
int in[N];
int cntin;
bool flag;
ll DP(int x){
	if(in[x])flag=1;
	ll fx=0;
	for(auto h:e[x]){
		ll y=h.first,val=h.second;
		ll fy=DP(y);
		if(in[y])fx+=val;
		else fx+=min(val,fy);
	}
	e[x].clear();
	return fx;
}
void work(){
	k[++num]=S;
	sort(k+1,k+1+num,cmp);
	tot=0;
	for_(i,1,num-1) {
		a[++tot]=k[i];
		a[++tot]=LCA(k[i],k[i+1]);
	}
	a[++tot]=k[num];
	sort(a+1,a+1+tot,cmp);
	tot=unique(a+1,a+1+tot)-a-1;
	for_(i,1,tot-1) {
		int x=a[i],y=a[i+1];
		int L=LCA(x,y);
		e[L].pb(mkp(y,dis[y]-dis[L]));
	}
	flag=0;
	ll fS=DP(S);
	if(flag)cout<<fS<<"\n";
	else cout<<-1<<"\n";
}
inline ll read(){ll d=0,f=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=1;ch=getchar();}while(ch<='9'&&ch>='0'){d=(d<<1)+(d<<3)+ch-'0';ch=getchar();}return f?-d:d;}
int main(){
	n=rd,m=rd,S=rd,Q=rd;H=__lg(n)+1;
	for_(i,1,m){
		int x=rd,y=rd,val=rd;
		vv[x].pb(mkp(y,val));
		vv[y].pb(mkp(x,val));
	}
	dij();
	for_(i,1,n){
		int cur=i;
		while(cur){
			st[++tp]=cur;
			cur=id[cur];
		}
		for_(j,1,tp-1){
			int x=st[j],y=st[j+1];
			if(mp.find(P(min(x,y),max(x,y)))!=mp.end())break;
			mp[P(min(x,y),max(x,y))]=1;
			v[y].pb(mkp(x,dis[x]-dis[y]));
		}
		tp=0;
	}
	dep[S]=1;
	dfs_LCA(S);
	for_(j,1,H)for_(i,1,n)f[i][j]=f[f[i][j-1]][j-1];
	while(Q--){
		int op=rd;
		if(!op)For_(i,rd,1)in[rd]^=1;
		else{
			num=rd;
			for_(i,1,num)k[i]=rd;
			work();
		}
	}
	
	return 0;
}
```

---

## 作者：Point_LUO (赞：4)

### 前置知识

- Dijkstra 求最短路径树

- 树形 DP

- 虚树 [（帮你 OI-Wiki 一下）](https://oi-wiki.org//graph/virtual-tree/)

### 题意简述

其它题解其实写的相当详尽了，概括一下就是：

- 求无向图的最短路径树（注意**路径长度相同时按编号排序**）。

- 有两种操作：0 表示将标记取反，1 表示求代价。

### 思路

- Dijkstra 求最短路径树

- 异或完成取反操作

- 建虚树跑树形 DP 求代价

  - 关于虚树
 
    - 构造一棵可爱的虚树
       
      这里采用的是[二次排序 + LCA 连边](https://oi-wiki.org//graph/virtual-tree/#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E4%BA%8C%E6%AC%A1%E6%8E%92%E5%BA%8F--lca-%E8%BF%9E%E8%BE%B9)的方式。
 
      1. 将回收区域（关键点）第一次按 dfn 序排序
     
      2. 插入关键点的 LCA，此处采用倍增求 LCA
     
      3. 将关键点和它们的 LCA 合在一起第二次按 dfn 序排序，去重以得到虚树的所有点编号
     
      4. 将虚树的点连边
   
    - 在可爱的虚树上跑树形 DP 即可，方法和普通树形 DP 一样

  - 关于 DP 式
 
    我们通过题意分两种情况进行 DP。此处设节点 $u$ 为节点 $v$ 的父亲节点，求节点 $u$ 处的 DP 值。
 
    - 被标记时：必须阻断这条路径，代价为 $dis[v]-dis[u]$，即 $u$ 到 $v$ 的路径长度。
   
    - 无标记时：有下列两种情况，取二者中的较小值作为 $u$ 的 DP 值。
   
      - 选择截断该路径，使得 $u$ 与以 $v$ 为根子树不连通，这种情况代价同被标记时。
     
      - 选择让 $v$ 之后的节点自行截断，这种情况代价为 $dfs(v)$。
 
### Code

觉得难理解的可以看看这篇含详细注释的代码 awa。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=50010,M=100010,MAXN=50010;

int n,m,k,q;
int val[N];//记录是否被标记 
bool flag;//记录是否找到被标记投放区域 
int r[MAXN],num;//r回收区域编号 
int h[N],to[M<<1],len[M<<1],nxt[M<<1],cnt;//链式前向星

void addedge(int u,int v,int l)//建边 
{
	cnt++;
	nxt[cnt]=h[u];
	h[u]=cnt;
	to[cnt]=v;
	len[cnt]=l;
}

int pre[N],Len[N];//pre[i]记录节点i的前一个节点 Len[i]记录i和pre[i]的距离，方便之后重利用之前的链式前向星
int dis[N];//Dijkstra中当前最短距离 

void Find_Tree()//Dijkstra求以k为根的最小路径树 
{
	memset(dis,-1,sizeof(dis));
	priority_queue<pair<int,int>> q;//Dijkstra堆优化 
	//记得priority_queue默认大根堆，求最小路径树可以插入路径长度的相反数 
	q.push(make_pair(0,k));
	dis[k]=0;
	while(!q.empty())
	{
		int d=-q.top().first,u=q.top().second;
		q.pop();
		for(int i=h[u];i;i=nxt[i])
		{
			int v=to[i];
			if(dis[v]==-1||dis[v]>dis[u]+len[i])//取路径长度较短
			{
				pre[v]=u;
				Len[v]=len[i];
				dis[v]=dis[u]+len[i];
				q.push(make_pair(-dis[v],v));
			}
			else if(dis[v]==dis[u]+len[i]&&pre[v]>u)//路径长度相同取编号较小
			{
				pre[v]=u;
				Len[v]=len[i];
			}
		}
	}
	//清空原来的链式前向星，用于记录新的最小路径树 
	memset(h,0,sizeof(h));
	cnt=0;
	for(int i=1;i<=n;i++)
		if(i!=k)
		{
			addedge(pre[i],i,Len[i]);
			addedge(i,pre[i],Len[i]);
		}
}

int dfn[N],DFN;//时间戳 
int dep[N],f[N][16];//dep[i]记录节点i在树上深度 f记录祖先 

void dfs(int u,int fa){//LCA预处理 
	dfn[u]=++DFN;//同时记录时间戳 
	dep[u]=dep[fa]+1;
	for(int i=1;i<=15;i++) f[u][i]=f[f[u][i-1]][i-1];
	for(int i=h[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v==fa) continue;
		f[v][0]=u;
		dfs(v,u);
	}
}

int lca(int x,int y){//求x和y的LCA 
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=15;i>=0;i--)
	{
		if(dep[f[x][i]]>=dep[y]) x=f[x][i];
		if(x==y) return y;
	}
	for(int i=15;i>=0;i--)
		if(f[x][i]!=f[y][i])
		{
			x=f[x][i];
			y=f[y][i];
		}
	return f[x][0];
}

//虚树点数为 实点+虚点 数组要开两倍 
int vt[MAXN<<1],vtcnt;//vt存储虚树中的点 vtcnt虚树节点个数 
vector<int> VT[MAXN<<1];//VT vector存虚树 

bool cmp(int a,int b){ return dfn[a]<dfn[b]; }//根据 dfn 序排序 

void Virtual_Tree()//建虚树 
{
	vtcnt=0;
	sort(r+1,r+1+num,cmp);//第一次排序 
	for(int i=1;i<num;i++)
	{
		vt[++vtcnt]=r[i];
		vt[++vtcnt]=lca(r[i],r[i+1]);//插入LCA 
	}
	vt[++vtcnt]=r[num];
	sort(vt+1,vt+1+vtcnt,cmp);//第二次排序 
	vtcnt=unique(vt+1,vt+1+vtcnt)-vt-1;//去重 
	for(int i=1;i<vtcnt;i++)
	{
		int l=lca(vt[i],vt[i+1]);
		VT[l].push_back(vt[i+1]);//连边 
	}
}

int calc(int u)//虚树上跑树形DP求最小代价 
{
	int res=0;
	if(val[u]) flag=1;
	int siz=VT[u].size();
	for(int i=0;i<siz;i++)
	{
		int v=VT[u][i];
		int tmp=calc(v);
		if(val[v]) res+=dis[v]-dis[u];//被标记时必须阻断这条路径
		else res+=min(dis[v]-dis[u],tmp);//无标记时选择截断该路径或继承 v 的 DP 值 
	}
	VT[u].clear();
	return res;
}

int main()
{
	cin>>n>>m>>k>>q;
	for(int i=1;i<=m;i++)
	{
		int u,v,l;
		scanf("%d%d%d",&u,&v,&l);
		addedge(u,v,l);
		addedge(v,u,l);
	}
	Find_Tree();
	dfs(k,0);
	while(q--)
	{
		int opt;
		scanf("%d%d",&opt,&num);
		if(!opt)//opt==0 区域标记异或取反 
		{
			for(int i=1;i<=num;i++)
			{
				int p;
				scanf("%d",&p);
				val[p]^=1;
			}
		}
		else//opt==1 建虚树 + DP
		{
			for(int i=1;i<=num;i++) scanf("%d",&r[i]);
			r[++num]=k;
			Virtual_Tree();
			flag=0;
			int ans=calc(k);
			if(flag) printf("%d\n",ans);
			else printf("-1\n");
		}
	}
	return 0;
}
```

Tips：撰文不易，不适轻喷。

---

## 作者：tommymio (赞：3)

这里提供一下简要版题面：
>  题目的主要概念：
>
> - 回收路线：从**任何一个**区域 $X$ 到 区域 $K$ 的最短路径.
> - 回收路线树：回收路线构成的树.
> - 标记区域：所有的回收区域及回收区域两两的 $LCA$，以及区域 $K$.
> - 阻碍：若两标记区域之间的路径被切断，则所有包含这条路径的路径被阻碍.
> - 切断：切断一条路径的代价为该路径的长度.
> - 投放区域被标记仅当该投放区域为两个回收区域的 $LCA$.
>
> 求所有从 $K$ 到 $X$ 的路径都被阻碍的最小代价（~~似乎讲的仍然不是人话~~）

> 简要版题面：
>
> 1. 给出 $num$ 个点，将这个 $num$ 个点的颜色取反.
> 2. 给出 $num$ 个点，建出一棵虚树，求虚树上颜色为 $1$ 的点与 $K$ 不连通的最小代价.
> 3. 初始时树上所有点颜色为 $0$.
> 4. 初始时给出一张图，自行生成整张图的最小路径树.

对于第 $1$ 点，颜色取反可以直接取反，对于第 $4$ 点，**dijistra**可以毫无压力的解决.

这么看来这就是一道虚树的板子题了，又回到了经典问题，**求根与其他颜色为 $1$ 的点不连通所需割去的最小边集**.

- 设 $f_x$为以 $x$ 为根的子树内颜色为 $1$ 的节点不与 $1$ 连通的最小代价.
- 当 $color_y=1,y \in son_x$ 时，有 $f_x=\sum_{y \in  son_x} w(x,y)$.很好理解，当 $y$ 的颜色为 $1$ 时，必须将 $y$ 和 $x$ 的边切断，因为就算 $y$ 的子树都不与 $x$ 连通，但 $y$ 还是和 $x$ 连通的，所以必须断掉 $w(x,y)$.
- 当 $color_y=0,y \in son_x$ 时，有 $f_x=\sum_{y \in son_x} \min(f_y,w(x,y))$.为什么现在又可以选择令 $y$ 的子树不连通呢？因为当 $y$ 的颜色不为 $1$ 时，我们不再关心 $y$ 与 $x$ 是否连通，所以可以在两种决策中取最优解.

直接在虚树上跑DP即可.

**PS:特别需要注意的是，最多有 $100000$ 条双向边，所以邻接表数组的大小要开到 $200005$ 而不是 $100005$**.

**Show the Code**

```cpp
#include<queue>
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
#include<functional>
#define pr(x,y) printf("%d->%d\n",x,y)
#define min(a,b) ((a)<(b)? (a):(b))
int n,m,k,T,cnt,ans,num,top;
int f[50005][25];
int h[50005],to[200005],ver[200005],w[200005];
int b[50005],d[50005],dis[50005],pre[50005],v[50005],st[50005],dfn[50005];
std::vector<int> mp[50005];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline void add(int x,int y,int z=0) {
	to[++cnt]=y;
	ver[cnt]=h[x];
	w[cnt]=z;
	h[x]=cnt;
}
inline bool cmp(int x,int y) {return dfn[x]<dfn[y];}
inline void swap(int &x,int &y) {int tmp=x;x=y;y=tmp;}
inline void dijistra(int u) {
	memset(dis,0x3f,sizeof(dis));
	std::priority_queue<std::pair<int,int> > Q;
	Q.push(std::make_pair(0,u));
	dis[u]=0;
	while(Q.size()) {
		int x=Q.top().second,d=-Q.top().first;Q.pop();
		if(d!=dis[x]) continue;
		for(register int i=h[x];i;i=ver[i]) {
			int y=to[i];
			if(dis[y]>dis[x]+w[i]) {pre[y]=x;dis[y]=dis[x]+w[i];Q.push(std::make_pair(-dis[y],y));} 
			else if(dis[y]==dis[x]+w[i]&&pre[y]>x) {pre[y]=x;}
		}
	}
	memset(h,0,sizeof(h));
	for(register int x=1;x<=n;++x) {if(x!=k) mp[pre[x]].push_back(x);}
}
void prework(int x) {
	dfn[x]=++num;
	for(register int i=1;i<=15;++i) f[x][i]=f[f[x][i-1]][i-1];
	for(register int i=0;i<mp[x].size();++i) {
		int y=mp[x][i];
		f[y][0]=x;
		d[y]=d[x]+1;
		prework(y);
	}
}
inline int LCA(int x,int y) {
	if(d[x]>d[y]) swap(x,y);//d[x]<=d[y]
	for(register int i=15;i>=0;--i) {if(d[x]<=d[f[y][i]]) y=f[y][i];}
	if(x==y) return x;
	for(register int i=15;i>=0;--i) {if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];}	
	return f[x][0];
}
inline void insert(int x) {
	if(top==0) {st[++top]=x;return;}
	int z=LCA(x,st[top]);
	if(z==st[top]) {st[++top]=x;return;}
	while(top>1&&d[z]<d[st[top-1]]) {add(st[top-1],st[top]);--top;}
	if(d[z]<d[st[top]]) {add(z,st[top]);--top;}
	if(!top||st[top]!=z) {st[++top]=z;}
	st[++top]=x;
}
int dfs(int x) {
	int res=0;
	for(register int i=h[x];i;i=ver[i]) {
		int y=to[i],tmp=dfs(y);
		if(b[y]) res+=dis[y]-dis[x];//全部切边，如果不直接切边仍然连通.
		else res+=min(tmp,dis[y]-dis[x]);//否则可以选择切树还是切边。.
	}
	h[x]=0;
	return res;
}
int main() {
	n=read(),m=read(),k=read(),T=read();
	for(register int i=1;i<=m;++i) {
		int x=read(),y=read(),z=read();
		add(x,y,z);add(y,x,z);
	}
	dijistra(k);
	d[k]=1;prework(k);
	while(T--) {
		int op=read(),tot=read();
		if(op==0) {for(register int i=1;i<=tot;++i) b[read()]^=1;}
		else {
			for(register int i=1;i<=tot;++i) v[i]=read();
			std::sort(v+1,v+1+tot,cmp);
			cnt=0;st[top=1]=k;
			for(register int i=1;i<=tot;++i) {if(v[i]!=k) insert(v[i]);}
			while(top>1) {add(st[top-1],st[top]);--top;}
			ans=dfs(k);
			printf("%d\n",ans==0? -1:ans);
		}
	}
	return 0;
}
```



---

## 作者：meyi (赞：2)

~~感觉这题最大的难点在读题上。~~

前置知识： [虚树](https://oi-wiki.org/graph/virtual-tree/)。

简化一下题面：

给定一张图和它的源点 $k$，你需要求出它的最短路径树，若一个点有多个前驱，取编号最小的为前驱。在得到的树上，每个点初始为白色。操作 0 为把给定的节点的颜色取反，操作 1 为把给定的节点和根节点建一棵虚树，求删去一些**虚树边**（注意这里不是原树边）使根节点和所有黑色节点不连通所需的最小代价（删去一条虚树边所需代价为它包含的所有原树边的长度总和），特别地，若虚树中没有黑色节点，输出 `-1`。

求最短路径树只需要一个 dijkstra 就可以解决，建虚树左转你谷模板区，需要考虑的只有建出虚树后如何DP出最小代价。

令 $dp_i$ 表示使 $i$ 的子树内所有黑色节点与它的父亲 $fa_i$ 不连通的最小代价。

分情况讨论一下：

- 当前节点为黑色

那么 $fa_i$ 和 $i$ 的这条边必须要割，显然割完后子树内所有节点都不会与 $fa_i$ 连通，$dp_i=\text{dis}(i,fa_i)$。

- 当前节点为白色

那么 $fa_i$ 和 $i$ 的这条边不一定要割，但子树内所有黑色节点都不能与 $fa_i$ 连通，$dp_i=\min(\text{dis}(i,fa_i),\sum\limits_{j\in son_i}dp_j)$。

最终答案即为 $dp_{k}$。

时间复杂度 $O((n+m+\sum num)\log n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ri register int
typedef long long ll;
const int maxn=1e5+10;
template<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,1:0;}
template<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,1:0;}
struct edge{
	int v,to,nxt;
}e[maxn<<1];
int hd[maxn],len;
inline void addedge(int fr,int to,int v=1){
	e[++len]={v,to,hd[fr]};
	hd[fr]=len;
}
struct node{
	int d,pos;
	inline bool operator<(const node &k)const{
		return d>k.d;
	}
};
priority_queue<node>q;
int dis[maxn],ed[maxn],pre[maxn];
bool vis[maxn];
int m,n,ql,rt;
inline void dijkstra(){
	memset(dis,0x3f,sizeof dis);
	dis[rt]=0;
	q.push({0,rt});
	while(q.size()){
		ri p=q.top().pos;q.pop();
		if(vis[p])continue;
		vis[p]=true;
		for(ri i=hd[p];i;i=e[i].nxt)
			if(dis[p]+e[i].v<dis[e[i].to]){
				dis[e[i].to]=dis[p]+e[i].v;
				ed[e[i].to]=e[i].v;
				pre[e[i].to]=p;
				if(!vis[e[i].to])q.push({dis[e[i].to],e[i].to});
			}
			else if(dis[p]+e[i].v==dis[e[i].to]&&p<pre[e[i].to]){
				ed[e[i].to]=e[i].v;
				pre[e[i].to]=p;
			}
	}
}
namespace LCA{
	int cnt,dep[maxn],fir[maxn],lg,lg2[maxn<<1],st[(int)log2(maxn)+2][maxn<<1];
	void dfs(int p,int f){
		dep[p]=dep[f]+1;
		st[0][++cnt]=p;
		fir[p]=cnt;
		for(ri i=hd[p];i;i=e[i].nxt)
			if(e[i].to!=f)
				dis[e[i].to]=dis[p]+e[i].v,dfs(e[i].to,p),st[0][++cnt]=p;
	}
	inline int ptmin(const int &x,const int &y){
		return dep[x]<dep[y]?x:y;
	}
	inline void build_st(){
		for(ri i=1;i<=cnt;++i)lg2[i]=lg2[i-1]+((2<<lg2[i-1])==i);
		lg=lg2[cnt];
		for(ri i=1;i<=lg;++i)
			for(ri j=1;j+(1<<i)-1<=cnt;++j)
				st[i][j]=ptmin(st[i-1][j],st[i-1][j+(1<<(i-1))]);
	}
	inline int lca(int x,int y){
		ri l=fir[x],r=fir[y];
		if(l>r)swap(l,r);
		ri k=lg2[r-l+1];
		return ptmin(st[k][l],st[k][r-(1<<k)+1]);
	}
	inline void init(int rt){
		dfs(rt,0);
		build_st();
	}
}
using LCA::dep;
using LCA::fir;
using LCA::lca;
vector<int>g[maxn],sp;
#define link(fr,to) g[fr].push_back(to)
int st[maxn],tp;
inline void insert(int p){
	if(tp){
		ri anc=lca(p,st[tp]);
		while(tp>1&&dep[anc]<dep[st[tp-1]]){
			link(st[tp-1],st[tp]);
			--tp;
		}
		if(dep[anc]<dep[st[tp]])link(anc,st[tp]),--tp;
		if(!tp||anc!=st[tp])st[++tp]=anc;
	}
	st[++tp]=p;
}
inline void build_vt(){
	sort(sp.begin(),sp.end(),[&](const int &x,const int &y){return fir[x]<fir[y];});
	sp.erase(unique(sp.begin(),sp.end()),sp.end());
	for(auto i:sp)insert(i);
	while(--tp)link(st[tp],st[tp+1]);
}
int tot;
int calc(int p){
	ri sum=0;
	tot+=vis[p];
	for(auto i:g[p]){
		ri tmp=min(dis[i]-dis[p],calc(i));
		if(vis[i])sum+=dis[i]-dis[p];
		else sum+=tmp;
	}
	g[p].clear();
	return sum;
}
int main(){
	scanf("%d%d%d%d",&n,&m,&rt,&ql);
	while(m--){
		ri x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		addedge(x,y,z),addedge(y,x,z);
	}
	dijkstra();
	memset(hd,0,sizeof hd);
	len=0;
	for(ri i=1;i<=n;++i)
		if(i!=rt)
			addedge(pre[i],i,ed[i]);
	LCA::init(rt);
	memset(vis,0,sizeof vis);
	while(ql--){
		ri op,x,y;
		scanf("%d%d",&op,&x);
		if(op){
			ri sum=0;
			sp={rt};
			while(x--){
				scanf("%d",&y);
				sum+=vis[y];
				sp.push_back(y);
			}
			build_vt();
			tot=0;
			ri ans=calc(rt);
			printf("%d\n",tot?ans:-1);
		}
		else{
			while(x--){
				scanf("%d",&y);
				vis[y]^=1;
			}
		}
	}
	return 0;
}
```

---

## 作者：LanrTabe (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P5680) [My Blog](https://www.cnblogs.com/LanrTabe/p/12173581.html)

之前没看懂题意就把这题扔了，现在一看是读错题意了

### 简化版题意

>给出一颗树（这个图的最短路径生成树），每个点初始颜色为$0$
>
>两种操作：
>
>1. 将部分点颜色取反
>
>2. 给出一些点，建出虚树（边权为两点树上距离），求最小割边代价使得虚树上没有颜色为$1$的点与根联通

那这就很模板了：

设$f[x]$表示$x$子树的答案，$c[x]$表示$x$的颜色，则有转移方程：（当$f[K]=0$时输出$-1$）
$$f[x]+=Val(x,y)\quad (c[y]=1)$$

$$f[x]+=\min (Val(x,y),f[y])\quad (c[y]=0)$$


（注意以上方法没有考虑边权全为$0$但是答案不为$-1$的情况，不过好像没有这种数据，反正也不难特判就没管了）

时间复杂度 $O((N+M)\log N+Qnum(\log num+\log N))$

（数据为什么这么小）

### 代码：

```cpp
#include <queue>
#include <cstdio>
#include <cctype>
#include <vector>
#include <cstring>
#include <algorithm>

inline char Getchar()
{
    static char In[1<<22],*p1=In,*p2=In;
    return p1==p2&&(p2=(p1=In)+fread(In,1,1<<22,stdin),p1==p2)?EOF:*p1++;
}

inline int Getint()
{
    int x=0,c;
    while(!isdigit(c=Getchar()));
    for(;isdigit(c);c=Getchar())x=x*10+(c^48);
    return x;
}

const int N=50005,Inf=0x7f7f7f7f;
int n,M,K,Q,Dis[N],Pre[N];
int Dfn[N],Tim,Dep[N],f[N][16];
int c[N],a[N],s[N],Top;
std::vector<int> G[N],Gv[N],T[N],V[N];
//Graph|Graph Value|Tree|Virtual Tree

void Dijkstra()
{
    struct Rec{int x,d;inline bool operator<(const Rec& o)const{return d>o.d;}};
    std::priority_queue<Rec> q;
    memset(Dis,0x7f,sizeof Dis);
    q.push((Rec){K,Dis[K]=0});
    while(!q.empty())
    {
        int x=q.top().x,d=q.top().d;
        if(q.pop(),d!=Dis[x])continue;
        for(int i=0,y,v;i<(int)G[x].size();++i)
            if(Dis[y=G[x][i]]>Dis[x]+(v=Gv[x][i])||(Dis[y]==Dis[x]+v&&x<Pre[y]))
                q.push((Rec){y,Dis[y]=Dis[x]+v}),Pre[y]=x;
    }
    for(int i=1;i<=n;++i)if(i!=K)T[Pre[i]].push_back(i);
}

void DFS(int x,int Fa)
{
    Dfn[x]=++Tim,Dep[x]=Dep[f[x][0]=Fa]+1;
    for(int i=1;i<=15;++i)f[x][i]=f[f[x][i-1]][i-1];
    for(auto y:T[x])if(y!=Fa)DFS(y,x);
}

int Lca(int x,int y)
{
    if(Dep[x]<Dep[y])std::swap(x,y);
    for(int i=15;i>=0;--i)if(Dep[f[x][i]]>=Dep[y])x=f[x][i];
    if(x==y)return y;
    for(int i=15;i>=0;--i)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];
    return f[y][0];
}

int DP(int x)
{
    int Res=0;
    for(auto y:V[x])
    {
        int v=DP(y);
        if(c[y])Res+=Dis[y]-Dis[x];
        else Res+=std::min(v,Dis[y]-Dis[x]);
    }
    V[x].clear();
    return Res;
}

int main()
{
    //freopen("in.txt","r",stdin);
    n=Getint(),M=Getint(),K=Getint(),Q=Getint();
    for(int i=1,x,y,z;i<=M;++i)
    {
        x=Getint(),y=Getint(),z=Getint();
        G[x].push_back(y),Gv[x].push_back(z);
        G[y].push_back(x),Gv[y].push_back(z);
    }
    Dijkstra(),DFS(K,0);
    for(int o,k;Q--;)
        if(o=Getint(),k=Getint(),!o)while(k--)c[Getint()]^=1;
        else
        {
            for(int i=1;i<=k;++i)a[i]=Getint();
            s[Top=1]=K,std::sort(a+1,a+k+1,[](int x,int y){return Dfn[x]<Dfn[y];});
            for(int i=1;i<=k;++i)
            {
                int Ls=Lca(s[Top],a[i]);
                while(Top>1&&Dfn[s[Top-1]]>=Dfn[Ls])V[s[Top-1]].push_back(s[Top]),--Top;
                if(s[Top]!=Ls)V[Ls].push_back(s[Top]),s[Top]=Ls;
                s[++Top]=a[i];
            }
            while(Top>1)V[s[Top-1]].push_back(s[Top]),--Top;
            int Ans=DP(K);
            printf("%d\n",Ans?Ans:-1);
        }
    return 0;
}

```

---

## 作者：5k_sync_closer (赞：2)

~~【模板】读题~~

本蒟蒻码量上 3k 的第二题

> $B$ 公司为了减少成本，回收时从区域 $K$ 到任何一个区域 $X$ 都选择长度**最短**的路径，如果有多条到某一个区域的最短路径，则选择所有最短路径中该区域的前一区域**编号最小**的一条路径，称这条路径为 $K$ 到 $X$ 的**回收路线**。所有的**回收路线**组成一棵树状结构，称之为**回收路线树**。

根据题意，**回收路线树**就是最短路径树 $T$，跑一遍记录方案的 Dijkstra 求出即可。

> $B$ 公司每次会回收若干个区域的单车，称这些区域为**回收区域**。$B$ 公司还将某些区域设为**投放区域**，称其余区域为**非投放区域**。在**回收路线树**上，标记出区域 $K$ ，标记出所有的**回收区域**，以及标记出任意两个**回收区域**在**回收路线树**上的最近公共祖先。

根据题意，标记 $T$ 上以**回收区域**为关键点集的虚树 $V$，询问时建立虚树即可。

> $A$ 公司对 $B$ 公司的回收行动造成了阻碍，**当且仅当**对任意一个 $K$ 以外的被标记的**投放区域** $X$，从区域 $K$ 到 $X$ 的**回收路线上**都存在两个被标记的区域，它们之间**所有道路**(回收路线树上两点路径)被阻碍。阻碍一条道路的代价为该道路的长度。

根据题意，求阻碍 $V$ 上所有**投放区域**的代价，跑虚树上 DP 即可。

维护 $t_x$ 表示 $x$ 是否投放区域，操作 $0$ 直接把给定的点的 $t_x$ 取反即可。

以操作 $1$ 给定的点集建立虚树，设 $f_x$ 表示阻碍 $x$ 子树内所有投放区域的代价。

则有

$$
f_u=\sum\limits_{v\in son_u}\begin{cases}w(u,v)&t_v=1\\\min(w(u,v),f_v)&t_v=0\end{cases}
$$

注意清空。

```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
#define P pair<int, int>
using namespace std;
struct G
{
    struct E
    {
        int v, w, t;
    } e[200050];
    int c, h[50050];
    void A(int u, int v, int w)
    {
        e[++c] = {v, w, h[u]};
        h[u] = c;
    }
} A, T, V;
bool t[50050], w[50050];
P r[50050];
priority_queue<P, vector<P>, greater<P>> q;
int n, m, s, O, p, a[50050], z[50050], b[50050], d[50050], f[50050][25], o[50050], W[50050], g[50050];
bool C(int x, int y) { return b[x] < b[y]; }
void D(int u)
{
    b[u] = ++p;
    for (int i = T.h[u], v; i; i = T.e[i].t)
        if (!b[v = T.e[i].v])
        {
            d[v] = d[f[v][0] = u] + 1;
            W[v] = W[u] + T.e[i].w;
            for (int j = 1; f[v][j - 1]; ++j)
                f[v][j] = f[f[v][j - 1]][j - 1];
            D(v);
        }
}
int L(int x, int y)
{
    if (d[x] < d[y])
        swap(x, y);
    while (d[x] > d[y])
        x = f[x][__lg(d[x] - d[y])];
    if (x == y)
        return x;
    for (int k = __lg(d[x]); k >= 0; --k)
        if (f[x][k] != f[y][k])
            x = f[x][k], y = f[y][k];
    return f[x][0];
}
void F(int u)
{
    o[u] = 0;
    for (int i = V.h[u], v; i; i = V.e[i].t)
        F(v = V.e[i].v), o[u] += min(V.e[i].w, t[v] ? 1 << 30 : o[v]);
}
int main()
{
    scanf("%d%d%d%d", &n, &m, &s, &O);
    for (int i = 0, u, v, w; i < m; ++i)
        scanf("%d%d%d", &u, &v, &w), A.A(u, v, w), A.A(v, u, w);
    memset(g, 0x3f, sizeof g);
    q.push({g[s] = 0, s});
    while (!q.empty())
    {
        int u = q.top().second;
        q.pop();
        if (!w[u])
        {
            w[u] = 1;
            for (int i = A.h[u], v; i; i = A.e[i].t)
                if (g[v = A.e[i].v] > g[u] + A.e[i].w || g[v] == g[u] + A.e[i].w && r[v].first > u)
                    q.push({g[v] = g[r[v].first = u] + A.e[i].w, v}), r[v].second = A.e[i].w;
        }
    }
    for (int i = 1; i <= n; ++i)
        if (r[i].first)
            T.A(r[i].first, i, r[i].second);
    D(s);
    for (int i = 0, r, k, c = 0, w = 1; i < O; ++i)
    {
        scanf("%d%d", &r, &k);
        if (r)
        {
            for (int j = 0; j < c; ++j)
                V.h[z[j]] = 0;
            V.c = c = 0;
            w = 1;
            for (int j = 0; j < k; ++j)
                scanf("%d", a + j);
            a[k++] = s;
            sort(a, a + k, C);
            z[c++] = a[0];
            for (int j = 1; j < k; ++j)
                z[c++] = L(a[j], a[j - 1]), z[c++] = a[j];
            sort(z, z + c, C);
            c = unique(z, z + c) - z;
            for (int j = 1, l; j < c; ++j)
                l = L(z[j], z[j - 1]), V.A(l, z[j], W[z[j]] - W[l]);
            for (int j = 0; j < c; ++j)
                if (t[z[j]])
                {
                    w = 0;
                    break;
                }
            if (w)
            {
                puts("-1");
                continue;
            }
            F(z[0]);
            printf("%d\n", o[z[0]]);
        }
        else
            for (int j = 0, x; j < k; ++j)
                scanf("%d", &x), t[x] ^= 1;
    }
    return 0;
}
```

~~顺便，这题题面 $\LaTeX$ 和汉字之间少空格，直接复制过来审核没过~~

---

## 作者：spire001 (赞：1)

## P5680 题解

### 题目大意
这个题有必要仔细的讲解一下题目意思。

首先这个题目给你一个图，但是这个图只有 $n - 1$ 条边是有用的，题目让你找到到根节点最近的路径构成的图，当然如果距离相等就取字典序小的。

然后有两类点，投放区域，非投放区域，可以理解为关键点和非关键点。

每次询问有两种，第一种，给一些点，关键点变非关键点，非关键点边关键点。

这个直接维护一个数组，$O(num)$ 修改即可。

第二种是让你输出最小代价。其实题目意思就是你可以通过付出边权的代价，让这些点以及其所有子节点被阻碍。

### 题目分析
乍一看，这询问不就是虚树模板题 P2495 吗？ 没做过也没关系因为两题区别很小。

但是这个题和 P2495 有所不同，后者的删除代价是两点间的最小边权，而这里是边权和。

我们设计状态 $dp_i$ 表示**这个节点的子节点**全部满足题意的最小代价。

题目已经说过了大本营不可能是关键点，所以状态设计没有疏漏。

类似 P2495 转移方程比较简单。

如果这个点是关键点，那你必须花费这条路的边权代价，如果不是关键点，那么你可以选择删掉这条边，或者直接继承子节点的状态。用公式表示就是：
$$
dp_u = \sum_{v\in son_u} \min_{e\in G}\{dp_v, W_e\}
$$

然后就变成了模拟加虚树模板了。

### AC 代码
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
#include <cassert>
#include <queue>

using namespace std;

typedef long long LL;

constexpr int N = 100010;
int n, m, k, T;

struct node
{
  int next, to, w;
} e[N << 1], e1[N << 1];
int head[N], es, son[N], dfn[N], top[N], fa[N], siz[N], dep[N], tot, es1, head1[N];
void bian(int u, int v, int w)
{
  e[++es] = {head[u], v, w};
  head[u] = es;
  return;
}
void bian1(int u, int v, int w)
{
  e1[++es1] = {head1[u], v, w};
  head1[u] = es1;
  return;
}
int wi[N];
struct vm
{
  int nm, val;

  bool operator<(const vm Q) const { return val > Q.val; }
};
int dis[N], pre[N];
bool box[N];

void dfs1(int u)
{
  siz[u] = 1; dfn[u] = ++tot;
  for (int i = head[u]; i; i = e[i].next)
  {
    int v = e[i].to;
    if (v == fa[u])
      continue;
    fa[v] = u;
    dep[v] = dep[u] + 1;
    dis[v] = dis[u] + e[i].w;
    dfs1(v);
    if (siz[son[u]] < siz[v])
      son[u] = v;
    siz[u] += siz[v];
  }
  return;
}
void dfs2(int u, int tp)
{
  top[u] = tp;
  if (son[u])
    dfs2(son[u], tp);
  for (int i = head[u]; i; i = e[i].next)
  {
    int v = e[i].to;
    if (v != son[u] && v != fa[u])
      dfs2(v, v);
  }
  return;
}

int LCA(int x, int y) // 树剖求 LCA
{
  while (top[x] != top[y])
  {
    if (dep[top[x]] < dep[top[y]])
      swap(x, y);
    x = fa[top[x]];
  }
  return dep[x] <= dep[y] ? x : y;
}

void get_path(int pos) // 获取路径
{
  while (box[pos] && pre[pos])
  {
    bian(pre[pos], pos, wi[pos]);
    bian(pos, pre[pos], wi[pos]);

    box[pos] = false;
    pos = pre[pos];
  }
}
void dij() // 最短路加前驱，把树求出来
{
  memset(dis, 127, sizeof dis);
  dis[k] = 0;
  priority_queue<vm> q;
  q.push({k, 0}); // 注意根节点是 k 不是自行钦定的 1

  while (!q.empty())
  {
    int u = q.top().nm;
    q.pop();

    if (box[u])
      continue;
    box[u] = true;

    for (int i = head[u]; i; i = e[i].next)
      if (const int v = e[i].to; (dis[v] > (LL)dis[u] + e[i].w || (dis[v] == (LL)dis[u] + e[i].w && pre[v] > u)))
      {
        pre[v] = u;
        wi[v] = e[i].w;
        dis[v] = dis[u] + e[i].w;
        q.push({ v, dis[v] });
      }
  }
}

int tp[N], tmp[N], cnt, dp[N];

void dfs(int u, int f)
{
  int res = 0;

  for (int i = head1[u]; i; i = e1[i].next)
    if (const int v = e1[i].to; v != f)
    {
      dfs(v, u);
      if (tp[v])
        res += e1[i].w;
      else
        res += min(dp[v], e1[i].w);
    }
  
  head1[u] = 0; // 记得清空虚树
  dp[u] = res;
  
  return;
}

int main()
{
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  cin >> n >> m >> k >> T;

  for (int i = 1; i <= m; i++)
  {
    int u, v, w;
    cin >> u >> v >> w;
    bian(u, v, w);
    bian(v, u, w);
  }

  dij();

  memset(head, 0, sizeof head);
  es = 0;

  for (int i = 1; i <= n; i++)
    get_path(i);
  
  dep[k] = 1; dis[k] = 0;
  dfs1(k); dfs2(k, k);

  auto cmp = [](const int A, const int B) { return dfn[A] < dfn[B]; };

  while (T--)
  {
    int cmd; cin >> cmd;

    if (cmd == 0)
    {
      int num; cin >> num;

      for (int i = 1; i <= num; i++)
      {
        int x; cin >> x;
        tp[x] = !tp[x]; // 直接修改
      }
    }
    else 
    {
      int num; cin >> num; es1 = cnt = 0;
      vector <int> tar(num + 1);
      tar[0] = k;
      for (int i = 1; i <= num; i++)
        cin >> tar[i];
      sort(tar.begin(), tar.end(), cmp); // 二次排序建虚树
      for (int i = 0; i != num; i++)
      {
        tmp[++cnt] = tar[i];
        tmp[++cnt] = LCA(tar[i], tar[i + 1]);
      }
      tmp[++cnt] = tar[num];

      sort(tmp + 1, tmp + cnt + 1, cmp);
      cnt = unique(tmp + 1, tmp + cnt + 1) - tmp - 1;

      for (int i = 1; i != cnt; i++)
      {
        int lca = LCA(tmp[i], tmp[i + 1]);
        bian1(lca, tmp[i + 1], dis[tmp[i + 1]] - dis[lca]);
        bian1(tmp[i + 1], lca, dis[tmp[i + 1]] - dis[lca]);
      }

      dfs(k, 0); // 树型 dp

      if (dp[k])
        cout << dp[k] << '\n';
      else 
        cout << "-1\n";
    }

  }

  return 0;
}

```

---

## 作者：MYJ_aiie (赞：0)

## [P5680 [GZOI2017] 共享单车](https://www.luogu.com.cn/problem/P5680)
### 题意： 
一张带权双向连通图和源点 $k$，画出它的最短路径树。树上每个点颜色初始为 $0$，有两种操作：$0$ 操作是把部分点的颜色取反，$ 1$ 操作是根据给定点和根节点（也就是前面的源点），建虚树，问在虚树上使得颜色为  $1$ 的点与 $K$ 不连通的所需的最小代价。  
道路无自环，所有道路长度小于 $2000$，且区域 $K$ 任意时刻均非投放区域。  
### 思路： 
跟着题意一步步做就好了。  
首先跑最短路同时存下每个点由哪个点跑到，以及跑向它的那条边边权。注意这里如果遇到跑向它的两个点路径长度相同的情况，要取最小的节点编号。（这里不用重复入队。）  
接着我们每次查询建虚树，在虚树上 DP。注意这里虚点不仅有输入的点还有根节点 $K$。DP 的过程类似消耗战这道题。按是否为标记点分类讨论（不是虚点哦！因为题目说的是阻断标记点。），如果是标记点，则必须断掉这条边，也就是 $f_u=\sum (dis_v-dis_u)$。如果不是标记点，那可以选择断掉其与父亲节点的连边也可以把子树内的关键点都和它断掉，即 $f_u=\sum\min (f_v,dis_v-dis_u)$。  
时间复杂度是 $O (n\log n)$。
### code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define mms(a2,b2) memset(a2,b2,sizeof(a2))
//回收--关键点。 投放 DP
const int N=1e5+5;
const int M=2e5+5;
const int inf=0x3f3f3f3f;
struct node{
	int v,nxt;
	int w;
}tu[M],e[M<<1],e2[M<<1];
int tott,tot,tot2;
int n,m,K,Q;
int flag=0;
int ht[N],h[N],h2[N];
int dis[N],pre[N],jw[M];
int sp[M],xu[M],fl[M];
int dep[N],fa[N][22],dfn[N],cnt,dw[N];
int a[N];
int f[N];
int read(){	
	int x=0,ff=1;
	char c=getchar();
	while(c<'0'||c>'9') 	c=getchar();
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+(c^48);	c=getchar();
	}
	return x;
}
void addt(int x,int y,int z){	tu[++tott].nxt=ht[x];tu[tott].v=y;tu[tott].w=z;ht[x]=tott; }
void add(int x,int y,int z){	e[++tot].nxt=h[x];	e[tot].v=y; e[tot].w=z;	h[x]=tot;}
void add2(int x,int y,int z){	e2[++tot2].nxt=h2[x];	e2[tot2].v=y;e2[tot2].w=z;h2[x]=tot2;}
void build(){
	mms(dis,-1);
	priority_queue<pair<int,int> > q;
	q.push(make_pair(0,K));
	dis[K]=0;
	while(!q.empty()){
		int u=q.top().second;
		q.pop();
		for(int i=ht[u];~i;i=tu[i].nxt){
			int v=tu[i].v,w=tu[i].w;
			if(dis[v]==-1||dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				pre[v]=u;
				jw[v]=w;
				q.push(make_pair(-dis[v],v));
			}else if(dis[u]+w==dis[v]&&pre[v]>u){
				pre[v]=u;
				jw[v]=w;
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(i!=K){
			//cout<<i<<" "<<pre[i]<<endl;
			add(i,pre[i],jw[i]);
			add(pre[i],i,jw[i]);
		}
	}
}
void dfs(int u,int u_fa,int ww){
	fa[u][0]=u_fa;
	dep[u]=dep[u_fa]+1;
	dfn[u]=++cnt;
	dw[u]=dw[u_fa]+ww;
	for(int i=h[u];~i;i=e[i].nxt){
		int v=e[i].v,w=e[i].w;
		if(v==u_fa) continue;
		dfs(v,u,w);
	}
}
void fa_fa(){
	for(int i=1;i<=20;i++)
		for(int j=1;j<=n;j++)
			fa[j][i]=fa[fa[j][i-1]][i-1];
}
bool cmp(int x,int y){
	return dfn[x]<dfn[y];
}
int lca(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=19;i>=0;i--){
		if(dep[fa[x][i]]>=dep[y]) x=fa[x][i];
	}
	if(x==y) return x;
	for(int i=19;i>=0;i--){
		if(fa[x][i]!=fa[y][i]){
			x=fa[x][i],y=fa[y][i];
		}
	}
	return fa[x][0];
}
int solve(int u,int u_fa){
	int ans=0;
	for(int i=h2[u];~i;i=e2[i].nxt){
		int v=e2[i].v;
		if(v==u_fa) continue;
		int tt=solve(v,u);
		if(a[v]) flag=1,ans+=dw[v]-dw[u];
		else ans+=min(tt,dw[v]-dw[u]);
	//	cout<<ans<<endl;
	}	
//	cout<<u_fa<<" "<<u<<" "<<ans<<endl;
	h2[u]=-1;
//	fl[u]=0;
	return ans;
}
int main() {
	mms(ht,-1),mms(h,-1),mms(h2,-1);
	n=read(),m=read(),K=read(),Q=read();
	for(int i=1;i<=m;i++){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		addt(x,y,z),addt(y,x,z);
	}
	build();
	dfs(K,0,0);
	fa_fa();
	int t,le;
	while(Q--){
		scanf("%d",&t);
		if(t==0){
			scanf("%d",&le);
			for(int i=1;i<=le;i++){
				int x;
				scanf("%d",&x);
				if(a[x]==0) a[x]=1;
				else a[x]=0;
			}
		}else{
			scanf("%d",&le);
			for(int i=1;i<=le;i++){
				scanf("%d",&sp[i]);
			//	fl[sp[i]]=1;
			}	
			sp[++le]=K;
			flag=0;
		//	fl[K]=1;
			sort(sp+1,sp+1+le,cmp);
			int len=0;
			for(int i=1;i<le;i++){
				xu[++len]=sp[i];
				xu[++len]=lca(sp[i],sp[i+1]);
			}
			xu[++len]=sp[le];
			sort(xu+1,xu+1+len,cmp);
			len=unique(xu+1,xu+1+len)-xu-1;
			for(int i=1;i<len;i++){
				int lc=lca(xu[i],xu[i+1]);
				add2(lc,xu[i+1],dw[xu[i+1]]-dw[lc]);
				add2(xu[i+1],lc,dw[xu[i+1]]-dw[lc]);
			}
			int anss=solve(K,0);
			if(flag)
			printf("%d\n",anss);
			else printf("-1\n");
		}
	}
	return 0;
```

---

## 作者：Acee (赞：0)

~~应该是我语文不好，读了三遍题。~~

读懂题了这题就是板了，先按题意建出最短路树。

然后一眼虚树，发现跟[这个题](https://www.luogu.com.cn/problem/P2495)几乎就没区别了啊，在虚树上面进行简单动态规划就行了啊。

设 $f_u$ 为断掉子树关键点的最小代价。

转移的话就是 $f_u = \sum\limits_{(u, v) \in E} \min(f_v, w)$。

十分的显然。

code：
```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long
#define REP(i, l, r) for(int i = l; i <= r; ++i)
#define PER(i, r, l) for(int i = r; i >= l; --i)

namespace Main {
	const int N = 100000 + 5;
	int n, m, rt, Q;
	struct edge {int v, w;};
	vector<edge> e[N];
	int pre[N];
	int dis[N]; bool vis[N];
	void dijkstra() {
		memset(dis,0x3f,sizeof(dis)),memset(vis,0,sizeof(vis));
		priority_queue<pair<int,int> > q;
		q.push({0, rt}); dis[rt]=0;
		while(!q.empty()) {
			int u=q.top().second; q.pop(); 
			if(vis[u])continue; vis[u]=1;
			for(auto &t: e[u]) {
				if(dis[t.v]>dis[u]+t.w) {
					dis[t.v]=dis[u]+t.w;
					pre[t.v]=u;
					q.push({-dis[t.v], t.v});
				}
				else if(dis[t.v]==dis[u]+t.w) pre[t.v]=min(pre[t.v],u);
			}
		}
	}
	
	
	vector<int> clr;
	int dfn[N];
	vector<edge> tr[N];
	bool bj[N];
	int fa[N][20],dep[N],dfnnum;
	bool cmp(int x,int y) { return dfn[x]<dfn[y];}
	void dfs(int u,int prt) {
		dfn[u]=++dfnnum;
		fa[u][0]=prt; dep[u]=dep[prt]+1;
		for(int i=1;i<=19;++i) fa[u][i]=fa[fa[u][i-1]][i-1];
		for(auto&t: tr[u]) {
			if(t.v==prt)continue; 
			dfs(t.v,u);
		}
	}
	int lca(int u,int v){
		if(dep[u]<dep[v])swap(u,v);
		int l=dep[u]-dep[v];
		for(int i=19;~i;--i) if(l>>i&1) u=fa[u][i];
		if(u==v)return u;
		for(int i=19;~i;--i)if(fa[u][i]^fa[v][i])u=fa[u][i],v=fa[v][i];
		return fa[u][0];
	}
	int ask(int u,int v){return dis[u]+dis[v]-2*dis[lca(u,v)];}
	
	int tmp[N],a[N];
	
	vector<edge> g[N];
	int dp[N];
	void TreeDP(int u,int prt) {
		dp[u]=1e9;
		int res=0;
		for(auto &t: g[u]) {
			int v=t.v,w=t.w;
			if(v==prt)continue;
			TreeDP(v,u);
			if(bj[v])res+=w;
			else res+=min(dp[v],w);
		}
		dp[u]=res;
	} 
	int main() {
		ios::sync_with_stdio(false);
		cin.tie(0), cout.tie(0);
		cin>>n>>m>>rt>>Q;
		REP(i,1,m){
			int u,v,w;
			cin>>u>>v>>w;
			e[u].push_back({v,w}),e[v].push_back({u, w});
		}
		dijkstra();
		for(int i=1;i<=n;++i) {
			tr[pre[i]].push_back({i,dis[i]-dis[pre[i]]});
		}
		dfs(rt,0);
		while(Q--) {
			int op, k;
			cin>>op>>k;
			if(op==0) {
				REP(i,1,k) {
					int x;
					cin>>x; bj[x]^=1;
				}
			}
			else {
				clr.clear();
				REP(i,1,k)cin>>tmp[i];
				tmp[++k]=rt;
				sort(tmp+1,tmp+1+k,cmp);
				
				int tot = 0;
				for(int i = 1; i < k; ++i) a[++tot] = tmp[i], a[++tot] = lca(tmp[i], tmp[i + 1]);
				a[++tot] = tmp[k];
				sort(a + 1, a + 1 + tot, cmp);
				tot = unique(a + 1, a + 1 + tot) - a - 1;
				for(int i = 1; i <= tot; ++i) clr.emplace_back(a[i]);
				for(int i = 1; i < tot; ++i) {
					int l = lca(a[i], a[i + 1]);
//					cout<<l<<' '<<a[i+1]<<'\n';
					g[l].push_back({a[i + 1], ask(l, a[i + 1])});
					clr.emplace_back(l);
				}
				TreeDP(rt,0);
				if(dp[rt]==0)cout<<-1<<'\n';
				else cout<<dp[rt]<<'\n'; 
				for(int &u:clr) {
					g[u].clear();
					dp[u]=1e9;
				}
			}
		}
		return 0;
	}
}

int main() {
#ifdef LOCAL
	freopen("task.in", "r", stdin);
	freopen("task.out", "w", stdout);
	freopen("task.err", "w", stderr);
#endif
	Main :: main();
	return 0;
}
```

---

## 作者：hzoi_Shadow (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5680)

# 前置知识

[最短路](https://oi-wiki.org/graph/shortest-path/) | [最近公共祖先](https://oi-wiki.org/graph/lca/) | [虚树](https://oi-wiki.org/graph/virtual-tree/)

# 解法

题目中所说的 **回收路线树** 即以 $k$ 为根节点的最短路径树，可以使用 Dijkstra 构建。

标记 **回收区域** 本质上是对 **回收区域** 构建虚树，然后就和 [luogu P2495 [SDOI2011] 消耗战](https://www.luogu.com.cn/problem/P2495) 基本一致了，根据儿子节点的 **投放** 状态进行树形 DP 转移。

注意本题中虚树上两点边权为原最短路径树上两点间的距离。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
struct node
{
	int nxt,to,w;
}e[200010];
int head[50010],dis[50010],vis[50010],fa[50010],siz[50010],son[50010],dep[50010],top[50010],dfn[50010],a[50010],f[50010],tot=0,cnt=0;
pair<int,int>pre[50010];
void add(int u,int v,int w)
{
	cnt++;
	e[cnt].nxt=head[u];
	e[cnt].to=v;
	e[cnt].w=w;
	head[u]=cnt;
}
void dijkstra(int k)
{
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	priority_queue<pair<int,int> >q;
	q.push(make_pair(0,k));
	dis[k]=0;
	while(q.empty()==0)
	{
		int x=q.top().second;
		q.pop();
		if(vis[x]==0)
		{
			vis[x]=1;
			for(int i=head[x];i!=0;i=e[i].nxt)
			{
				if(dis[e[i].to]==0x3f3f3f3f||dis[e[i].to]>dis[x]+e[i].w)
				{
					dis[e[i].to]=dis[x]+e[i].w;
					pre[e[i].to]=make_pair(x,e[i].w);
					q.push(make_pair(-dis[e[i].to],e[i].to));
				}	
				else
				{
					if(dis[e[i].to]==dis[x]+e[i].w&&pre[e[i].to].first>x)
					{
						pre[e[i].to]=make_pair(x,e[i].w);
					}
				}
			}
		}
	}
}
void dfs1(int x,int father)
{
	tot++;
	dfn[x]=tot;
	siz[x]=1;
	fa[x]=father;
	dep[x]=dep[father]+1;
	for(int i=head[x];i!=0;i=e[i].nxt)
	{
		dis[e[i].to]=dis[x]+e[i].w;
		dfs1(e[i].to,x);
		siz[x]+=siz[e[i].to];
		son[x]=(siz[e[i].to]>siz[son[x]])?e[i].to:son[x];
	}
}
void dfs2(int x,int id)
{
	top[x]=id;
	if(son[x]!=0)
	{
		dfs2(son[x],id);
		for(int i=head[x];i!=0;i=e[i].nxt)
		{
			if(e[i].to!=son[x])
			{
				dfs2(e[i].to,e[i].to);
			}
		}
	}
}
int lca(int u,int v)
{
	while(top[u]!=top[v])
	{
		if(dep[top[u]]>dep[top[v]])
		{
			u=fa[top[u]];
		}
		else
		{
			v=fa[top[v]];
		}
	}
	return dep[u]<dep[v]?u:v;
}
int get_dis(int x,int rt)
{
	return dis[x]-dis[rt];
}
bool cmp(int a,int b)
{
	return dfn[a]<dfn[b];
}
struct Vitrual_Tree
{
	vector<int>g[50010];
	stack<int>s;
	void build(int len,int k)
	{
		sort(a+1,a+1+len,cmp);
		while(s.empty()==0)
		{
			s.pop();
		}
		s.push(k);
		g[k].clear();
		for(int i=1;i<=len;i++)
		{
			int rt=lca(a[i],s.top());
			while(s.top()!=rt)
			{
				int tmp=s.top();
				s.pop();
				if(dfn[s.top()]<dfn[rt])
				{
					s.push(rt);
					g[rt].clear();
				}
				g[s.top()].push_back(tmp);
			}
			s.push(a[i]);
			g[a[i]].clear();
		}
		while(s.top()!=k)
		{
			int tmp=s.top();
			s.pop();
			g[s.top()].push_back(tmp);
		}
	}
	void dfs(int x)
	{
		f[x]=0;
		for(int i=0;i<g[x].size();i++)
		{
			dfs(g[x][i]);
			f[x]+=(vis[g[x][i]]==1)?get_dis(g[x][i],x):min(get_dis(g[x][i],x),f[g[x][i]]);
		}
	}
}V;
int main()
{
// #define Isaac
#ifdef Isaac
	freopen("in.in","r",stdin);
	freopen("out.out","w",stdout);
#endif
	int n,m,q,k,u,v,w,i,j;
	cin>>n>>m>>k>>q;
	for(i=1;i<=m;i++)
	{
		cin>>u>>v>>w;
		add(u,v,w);
		add(v,u,w);
	}
	dijkstra(k);
	cnt=0;
	memset(e,0,sizeof(e));
	memset(head,0,sizeof(head));
	for(i=1;i<=n;i++)
	{
		if(i!=k)
		{
			add(pre[i].first,i,pre[i].second);
		}
	}
	dfs1(k,0);
	dfs2(k,k);
	memset(vis,0,sizeof(vis));
	for(j=1;j<=q;j++)
	{
		cin>>u>>m;
		if(u==0)
		{
			for(i=1;i<=m;i++)
			{
				cin>>a[i];
				vis[a[i]]^=1;
			}
		}
		else
		{
			for(i=1;i<=m;i++)
			{
				cin>>a[i];
			}
			V.build(m,k);
			V.dfs(k);
			cout<<((f[k]==0)?-1:f[k])<<endl;
		}
	}
	return 0;
}
```

---

## 作者：liujiaxi123456 (赞：0)

## 关键词：虚树，rank1 代码
### 思路：
先求最短路径树，Dijkstra 可以很轻松的解决。

接着显然对每个询问建出虚树，然后在虚树上 DP。

而转移则显然是决策直接把 $u,v$ 边砍断或者在 $v$ 内全部砍断。

$f_u = \sum_{v\in son_u} \min(dis(u, v), f_v)$
### Code：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int Maxn = 5e4+5, Maxm = 1e5+5;

namespace EDGE {
	int sz, head[Maxn];
	struct Edge { int next, to, val; } edge[Maxm*10];
	inline void Add_edge(int u, int v, int w) {
		// printf("Add_edge(%d, %d, %d)\n", u, v, w);
		edge[++sz] = {head[u], v, w};
		head[u] = sz;
	}
	inline void edge_memset(int N) { sz = 0, memset(head+1, 0, N*4); }
} using namespace EDGE;

namespace Josh_zmf {
	
	int N, M, Q, root; bool col[Maxn];
	int dfnnum, dfn[Maxn], nfd[Maxn], dep[Maxn], st[Maxn][20], logg[Maxn];
	struct Bian { int u, v, w; } bian[Maxm];

	inline void dfs(int u, int faa) {
		nfd[dfn[u] = ++dfnnum] = u, st[dfn[u]][0] = faa;
		for(int i=head[u], v; i; i=edge[i].next) {
			v = edge[i].to;
			if(v == faa)	continue;
			dep[v] = dep[u] + edge[i].val, dfs(v, u);
		}
	}

	inline int solve(int u) {
		if(col[u])	return INT_MAX;
		int res = 0;
		for(int i=head[u]; i; i=edge[i].next)	res += min(edge[i].val, solve(edge[i].to));
		return res;
	}

	inline int main() {
		cin>> N>> M>> root>> Q;
		for(int i=1, u, v, w; i<=M; i++) {
			cin>> u>> v>> w, bian[i] = {u, v, w};
			Add_edge(u, v, w), Add_edge(v, u, w);
		}
	// puts("_____________________");
		auto Build_Tree = [&](int s) -> void {
			static int dis[Maxn], pre[Maxn], pre_w[Maxn]; static bool vis[Maxn]; 
			struct Dij {
				int u, dis;
				bool operator < (const Dij &a) const { return dis > a.dis; }
			}; priority_queue <Dij> h;
			memset(dis+1, 0x3f, N*4);
			dis[s] = 0, h.push({s, dis[s]});
			for(int u; !h.empty(); ) {
				u = h.top().u; h.pop();
				if(vis[u])	continue; 
				vis[u] = 1;
				for(int i=head[u], v, w; i; i=edge[i].next) {
					v = edge[i].to, w = edge[i].val;
					if(dis[u]+w < dis[v]) {
						dis[v] = dis[u] + w, pre[v] = u, pre_w[v] = w;
						h.push({v, dis[v]});
					} else if(dis[u]+w == dis[v]) {
						if(u < pre[v])	pre[v] = u, pre_w[v] = w;
					}
				}
			}
			edge_memset(N);
			for(int u=1; u<=N; u++)	if(pre[u])	Add_edge(pre[u], u, pre_w[u]);
		}; Build_Tree(root);
	// puts("_____________________");
		auto get = [&](const int &u, const int &v) { return dfn[u] < dfn[v] ?u :v; };
		auto Build_LCA = [&]() -> void {
			dfs(root, 0);
			for(int i=2; i<=N; i++)	logg[i] = logg[i/2] + 1;
			for(int j=1; j<=logg[N]; j++)
				for(int i=1; i+(1<<j)-1<=N; i++)
					st[i][j] = get(st[i][j-1], st[i+(1<<(j-1))][j-1]);
		}; Build_LCA();
		auto LCA = [&](int u, int v) {
			if(u == v)	return u;
			if(dfn[u] > dfn[v])	swap(u, v);
			u = dfn[u]+1, v = dfn[v];
			int k = logg[v-u+1];
			return get(st[u][k], st[v-(1<<k)+1][k]);
		};
		auto Build_VirtuaTree = [&](int *tmp, int tot) {
			sort(tmp+1, tmp+1+tot, [&](const int &u, const int &v) { return dfn[u] < dfn[v]; } );
			static int stk[Maxn]; int top = 1; head[root] = 0, stk[top] = root;
			for(int i=1, lca; i<=tot; i++) {
				if(tmp[i] == root)	continue;
				lca = LCA(tmp[i], stk[top]);
				if(lca != stk[top]) {
					for(; dfn[lca]<dfn[stk[top-1]]; top--)	Add_edge(stk[top-1], stk[top], dep[stk[top]]-dep[stk[top-1]]);
					if(lca != stk[top-1])	head[lca] = 0, Add_edge(lca, stk[top], dep[stk[top]]-dep[lca]), stk[top] = lca;
					else 	Add_edge(lca, stk[top], dep[stk[top]]-dep[lca]), top--;
				}
				head[tmp[i]] = 0, stk[++top] = tmp[i];
			}
			for(; --top; )	Add_edge(stk[top], stk[top+1], dep[stk[top+1]]-dep[stk[top]]);
		};
		for(int tot, opt, res; Q--; ) {
			static int tmp[Maxn];
			cin>> opt>> tot;
			for(int i=1; i<=tot; i++)	cin>> tmp[i];
			if(opt == 0) { // 反转
				for(int i=1; i<=tot; i++)	col[tmp[i]] ^= 1;
			} else { // 查询，建虚树 
				Build_VirtuaTree(tmp, tot);
				res = solve(root);
				cout<< (res==0 ?-1 :res)<< '\n';
			}
			// puts("______________________");
		}
		return 0;
	}

}

int main() {
	Josh_zmf::main();
	return 0;
}
```
### 结语：
都看到这里了，点个赞再走吧。：）

---

## 作者：JimmyLee (赞：0)

# 题目分析

~~出题人是擅长隐藏题意的~~

## 建树

首先给你一张无向图，然后指定一个根节点 $k$，从根节点开始沿最短路到每一个节点。如果到某个节点有多条最短路径，选择上一个节点编号最短的。

考虑记录前驱的 Dijkstra。

```cpp
namespace DJ
{
    int dis[maxn], pre[maxn], val[maxn], vis[maxn];
    priority_queue<pair<int, int>> pq;
    void Dijkstra(int s)
    {
        memset(dis, 0x3f, sizeof dis);
        dis[s]=0;
        pre[s]=0;
        pq.emplace(0, s);
        while(!pq.empty())
        {
            auto [d, u]=pq.top();
            pq.pop();
            if(vis[u]) continue;
            vis[u]=1;
            for(auto [v, w]:e[u])
            {
                if(dis[u]+w<dis[v])
                {
                    dis[v]=dis[u]+w;
                    pre[v]=u;
                    val[v]=w;
                    pq.emplace(-dis[v], v);
                }
                else if(dis[u]+w==dis[v])
                    pre[v]=min(pre[v], u),
                    val[v]=w;
            }
        }
    }

    void search(int x) // 记录路径
    {
        while(vis[x]&&pre[x])
        {
            e[pre[x]].emplace_back(x, val[x]);
            vis[x]=0;
            x=pre[x];
        }
    }
}
```
 
---

## 询问

首先用 $tag_i$ 记录第 $i$ 个点是否为投放区域。

对于 `0` 操作，就是翻转点的标记。

```cpp
if(op==0)
    for(int i=1, t;i<=num;i++) 
        cin>>t, tag[t]^=1;
```

对于 `1` 操作，题目说的很清楚，先以 $k$ 和询问点建一棵虚树。

前置知识：[虚树](https://oi-wiki.org/graph/virtual-tree/)。

```cpp
d.clear();
d.push_back(k);
for(int i=1, t;i<=num;i++) 
    cin>>t, d.emplace_back(t);
sort(d.begin(), d.end(), cmp);
for(int i=1;i<=num;i++)
    d.push_back(LCA(d[i], d[i-1]));
sort(d.begin(), d.end(), cmp);
auto end_it=unique(d.begin(), d.end());
for(auto it=d.begin()+1;it!=end_it;it++)
{
    int lc=LCA(*(it-1), *it);
    g[lc].emplace_back(*it, dis[*it]-dis[lc]);
}
```

然后要求让根节点和每个有标记的节点均不连通，所以考虑虚树上**树形dp**。

令 $dp_u$ 表示虚树上使 $u$ 与以 $u$ 为根的子树中的关键点断开的最小代价。

易得转移方程：

如果 $tag_v=1$，那么它对 $dp_u$ 的贡献为 $\operatorname{dis}(u, v)$。

如果 $tag_v=0$，那么它对 $dp_u$ 的贡献为 $\min(\operatorname{dis}(u, v), dp_v)$。

```cpp
int dp(int x)
{
    int ret=0;
    for(auto [v, w]:g[x])
    {
        int f=dp(v);
        if(tag[v]) ret+=w;
        else ret+=min(w, f);
    }
    g[x].clear();
    return ret;
}
```

因为边权不为 $0$，所以如果 dp 的结果为 $0$，那么就证明没有被标记的投放区域，特判一下，输出 `-1`。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 50004

vector<pair<int, int>> e[maxn], g[maxn];

namespace DJ
{
    int dis[maxn], pre[maxn], val[maxn], vis[maxn];
    priority_queue<pair<int, int>> pq;
    void Dijkstra(int s)
    {
        memset(dis, 0x3f, sizeof dis);
        dis[s]=0;
        pre[s]=0;
        pq.emplace(0, s);
        while(!pq.empty())
        {
            auto [d, u]=pq.top();
            pq.pop();
            if(vis[u]) continue;
            vis[u]=1;
            for(auto [v, w]:e[u])
            {
                if(dis[u]+w<dis[v])
                {
                    dis[v]=dis[u]+w;
                    pre[v]=u;
                    val[v]=w;
                    pq.emplace(-dis[v], v);
                }
                else if(dis[u]+w==dis[v])
                    pre[v]=min(pre[v], u),
                    val[v]=w;
            }
        }
    }

    void search(int x)
    {
        while(vis[x]&&pre[x])
        {
            e[pre[x]].emplace_back(x, val[x]);
            vis[x]=0;
            x=pre[x];
        }
    }
}

namespace slpf
{
    int son[maxn], fa[maxn], siz[maxn], dep[maxn], dis[maxn];
    void dfs1(int u, int f)
    {
        fa[u]=f;
        siz[u]=1;
        dep[u]=dep[f]+1;
        for(auto [v, w]:e[u])
            if(v!=f) 
            {
                dis[v]=dis[u]+w;
                dfs1(v, u);
                siz[u]+=siz[v];
                if(siz[v]>siz[son[u]]) son[u]=v;
            }
    }

    int top[maxn], dfn[maxn];
    void dfs2(int u, int t)
    {
        dfn[u]=++*dfn;
        top[u]=t;
        if(!son[u]) return;
        dfs2(son[u], t);
        for(auto [v, w]:e[u])
            if(!dfn[v])
                dfs2(v, v);
    }

    int LCA(int x, int y)
    {
        while(top[x]!=top[y])
        {
            if(dep[top[x]]<dep[top[y]]) swap(x, y);
            x=fa[top[x]];
        }
        return dep[x]<dep[y]?x:y;
    }
}

using slpf::dfn;
using slpf::dis;
using slpf::LCA;

int tag[maxn];
vector<int> d;

int dp(int x)
{
    int ret=0;
    for(auto [v, w]:g[x])
    {
        int f=dp(v);
        if(tag[v]) ret+=w;
        else ret+=min(w, f);
    }
    g[x].clear();
    return ret;
}

int main()
{
    int n, m, k, q;
    cin>>n>>m>>k>>q;
    for(int i=1, u, v, w;i<=m;i++)
    {
        cin>>u>>v>>w;
        e[u].emplace_back(v, w);
        e[v].emplace_back(u, w);
    }

    DJ::Dijkstra(k);
    for(int i=1;i<=n;i++) e[i].clear();
    for(int i=1;i<=n;i++) DJ::search(i);

    auto cmp=[&](int a, int b){return dfn[a]<dfn[b];};

    slpf::dfs1(k, 0);
    slpf::dfs2(k, k);

    while(q--)
    {
        int op, num;
        cin>>op>>num;
        if(op==0)
            for(int i=1, t;i<=num;i++) 
                cin>>t, tag[t]^=1;
        else
        {
            d.clear();
            d.push_back(k);
            for(int i=1, t;i<=num;i++)
                cin>>t, d.emplace_back(t);

            sort(d.begin(), d.end(), cmp);
            for(int i=1;i<=num;i++)
                d.push_back(LCA(d[i], d[i-1]));
            sort(d.begin(), d.end(), cmp);
            auto end_it=unique(d.begin(), d.end());
            for(auto it=d.begin()+1;it!=end_it;it++)
            {
                int lc=LCA(*(it-1), *it);
                g[lc].emplace_back(*it, dis[*it]-dis[lc]);
            }

            int otp=dp(k);
            cout<<(otp?otp:-1)<<'\n';
        }
    }
}
```

---


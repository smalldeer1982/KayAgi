# [JSOI2013] 快乐的 JYY

## 题目背景

JYY 在 JSOI 有很多很多的好朋友，比如 PUPPY，KFC 还有 PUPPUP 。因为
有了这么多的好朋友，所以 JYY 每天都很快乐。某天，JYY 发现好朋友之间关
系的好坏和名字有很大的关系，比如 PUPPY 和 PUPPUP 的关系就特别好，但是和 KFC 的关系就很一般。JYY 苦思冥想终于发现了其中的规律，现在 JYY 想知道两个朋友之间关系的好坏，你能帮助 JYY 么？

## 题目描述

给定两个字符串 $A$ 和 $B$，表示 JYY 的两个朋友的名字。我们用 $A(i,\,j)$ 表示 $A$ 
字符串中从第 $i$ 个字母到第 $j$ 个字母所组成的子串。同样的，我们也可以定义 $B(x,\,y)$ 。

JYY 发现两个朋友关系的紧密程度，等于同时满足如下条件的四元组 $(i,\,j,\,x,\,y)$
的个数：
1. $1\leq i\leq j\leq |A|$
2. $1\leq x\leq y\leq |B|$
3. $A(i,\,j)=B(x,\,y)$
4. $A(i,\,j)$ 是回文串

$|A|$ 表示字符串 $A$ 的长度。

JYY 希望你帮助他计算出这两个朋友之间关系的紧密程度。

## 说明/提示

$1\leq |A|,\,|B|\leq 50000$

## 样例 #1

### 输入

```
PUPPY
PUPPUP
```

### 输出

```
17```

# 题解

## 作者：皎月半洒花 (赞：10)

~~PAM为啥总感觉比SAM友善好多啊~~

与另一篇题解做法不同，我们可以直接对两个串同时建立$\rm PAM$。考虑$\rm PAM$里面每个节点的意义，节点=回文串，所以考虑我们对两个$\rm PAM$同时开始$\sf dfs$，因为起始状态相同，那么如果遇到相同的转移就说明有相同的状态，把$sz_x\times sz_y$作为贡献加到答案里面即可。

以下是一些闲扯：

* 注意到，对于回文串之间的转移而言，由于从奇数长度只能转移到奇数长度，偶数长度只能转移到偶数长度，所以要把每一组根都$\sf dfs$一遍。

* 紧接着上一条，显然我们要特判掉虚根（即奇根和偶根）。

* 然后这道题的两个 子$\mathsf {idea}$ 分别跟下面两题相似：

	* [Link1](https://www.luogu.com.cn/problem/P3649)，[Link2](https://www.luogu.com.cn/problem/P5555)
    
上代码    

```cpp
#define Sigma 30
#define MAXN 500010
#define LL long long

using namespace std ;
int N, M ; LL ans ; char S[MAXN], T[MAXN] ;
struct PAM{
	int rt0, rt1, last, sz, f[MAXN] ;
	int trie[MAXN][Sigma], pre[MAXN], len[MAXN] ;
	void Init(){
		sz = -1, rt0 = ++ sz, rt1 = ++ sz ; 
		pre[rt0] = pre[rt1] = rt1, len[rt0] = 0, len[rt1] = -1, last = rt0 ; 
	} 
	void Insert(int x, int p, char *s){
		int u = last ; 
		while (s[p] != s[p - len[u] - 1]) u = pre[u] ; 
		if (!trie[u][x]){
			int newq = ++ sz, fa = pre[u] ; 
			while (s[p] != s[p - len[fa] - 1]) fa = pre[fa] ;
			pre[newq] = trie[fa][x], trie[u][x] = newq, len[newq] = len[u] + 2 ;
		}
		last = trie[u][x], f[last] ++ ; 
	}
}P, Q ;
void dfs(int x, int y){
	if (x + y > 2) ans += 1ll * P.f[x] * Q.f[y] ; 
	for (int i = 1 ; i <= 26 ; ++ i)
		if (P.trie[x][i] && Q.trie[y][i]) dfs(P.trie[x][i], Q.trie[y][i]) ;
}
int main(){
	P.Init(), Q.Init() ;
	cin >> (S + 1) >> (T + 1) ; 
	N = strlen(S + 1), M = strlen(T + 1) ;
	for (int i = 1 ; i <= N ; ++ i) P.Insert(S[i] - 'A' + 1, i, S) ;
	for (int i = 1 ; i <= M ; ++ i) Q.Insert(T[i] - 'A' + 1, i, T) ;
	for (int i = P.sz ; i ; -- i) P.f[P.pre[i]] += P.f[i] ; 
	for (int i = Q.sz ; i ; -- i) Q.f[Q.pre[i]] += Q.f[i] ; 
	dfs(1, 1) ; dfs(0, 0) ; cout << ans<< endl ; return 0 ;
}
```


---

## 作者：Christophe_ (赞：9)

## 竟然没有 $\mathrm{Hash+map}$ 的题解？


#### 原题：[P5685 [JSOI2013]快乐的 JYY](https://www.luogu.com.cn/problem/P5685)


#### 题意：
给定 $\mathrm{A,B}$ 两个字符串，对于每个 $\mathrm{A,B}$ 的公共回文子串 $\mathrm{S}$ ，求 $\sum\limits_{}resA[S]*resB[S]$ 的值，其中 $\mathrm{resA[S]}$ 和 ${resB[S]}$ 表示串 $\mathrm{S}$ 在 $\mathrm{A,B}$ 中出现的次数。

原因：显然每一个在 $\mathrm{A}$ 中出现次数为 $\mathrm{res[P]}$ 的回文子串 $\mathrm{P}$ 与在 $\mathrm{B}$ 中出现次数为 $\mathrm{resB[S]}$ 的回文子串 $\mathrm{S}$ 的组合的四元组 $\mathrm{(i,j,x,y)}$ 的个数为 $\mathrm{resA[P]*resB[S]}$。


#### 思路：
最暴力的做法显然是枚举 $\mathrm{A,B}$ 的所有回文子串（中心扩展法），由于一个字符串的所有回文子串的个数达到了 $\mathrm{O(n^2)}$ 的级别，整体的复杂度为 $\mathrm{O(n^4)}$。

显而易见，我们可以用 $\mathrm{map}$ 优化这个过程。枚举 $\mathrm{A}$ 的所有回文子串，将信息存入 $\mathrm{map:resA[S]=cnt}$ ，同理得 $\mathrm{resB[S]}$，历遍计算即可，时间复杂度 $\mathrm{O(n^2logn)}$ ，瓶颈在于**枚举所有回文子串**。

而我们有熟知结论：**一个字符串的本质不同的回文子串的个数只有 $\mathrm{O(n)}$ 个**（两个字符串本质不同当且仅当两个字符串不同，和其在原串中的位置无关），至于证明可以考虑在一个回文串末尾加入单个字符生成的回文串个数。而**所有的回文子串都可以由以每个字符或夹缝为回文中心的 $\mathrm{2n}$ 个极长回文子串生成**，因为每个极长回文子串从两边等量去掉若干字符后仍是回文子串。

至于这些极长回文子串怎么求，可以跑一遍 $\mathrm{O(n)}$ 的 $\mathrm{Manacher}$ 、$\mathrm{O(nlogn)}$ 的 $\mathrm{Hash+}$二分或者 $\mathrm{O(n)}$ 的 $\mathrm{Hash+}$贪心。这里我们选择 $\mathrm{Hash+}$二分，因为既可以成为下面的过程的预处理，又好写，瓶颈也不在这里。 

从 $\mathrm{O(n^2)}$ 个**所有回文子串**到 $\mathrm{O(n)}$ 个**本质不同**的回文子串，这说明我们的极长回文子串带来的信息相较于我们需要了解的信息有了**很大的冗余**。我们需要通过一定的方式来“去重”，即考虑是否能每次只从待选集合选出一个与所有已知回文子串**本质不同**的回文子串（因为我们需要历遍的，就是所有这些本质不同的回文子串，这是原信息的精炼，也是我们所必须知道的信息）。而长度的比较，往往是一些字符串问题的突破口。

我们需要时时刻刻精简已知集合，将所有本质相同的子串的信息合并，这需要一种能够**动态去重**的数据结构。先从初始状态的回文子串集合开始考虑，其中有 $\mathrm{O(n)}$ 个信息合并过的本质不同的极长回文子串。最朴素的想法是，我们可以从集合选出一个回文串，挑选出其生成的非自身的回文子串中不与集合中任一其他串生成的回文子串本质相同的若干“新串”，直到集合为空。

为了加快挑选后判断其回文子串是否“本质不同”的速度，我们需要用到另一个关键结论：**“本质相同”具有单调性**（两个串本质相同，其对应子串必本质相同）。这启示我们在选出来的回文串中从长到短挑选回文子串时，如果这个子串与集合中某一串相等，就没必要继续判断——因为我们要找出的是所有**本质不同的串**，剩下的所有待判断的子串的信息显然可以通过更新在集合中与这个子串相等的串 $\mathrm{P}$ 的信息，将其代表的信息“**下放**”到串 $\mathrm{P}$ 上，并“递归”般地进行下一轮挑选。这实现了一个“**标记下传**”的过程，因此每次只要下放一层信息，待到下次挑选到串 $\mathrm{P}$ 时会**继续下放**，保证了最后得到的信息正确性。（是不是很像线段树的 $\mathrm{pushdown}$ 和 $\mathrm{lazy}$ 标记？没错，这是一种**降低复杂度的通用思想**！）

因此，我们每次需要贪心地从集合中挑出一个最长的回文串（它一定是一个本质不同的串），统计一下信息（即更新 $\mathrm{res[S]}$），并每次从两头去掉一个字符生成一个回文子串，如果它与集合中某一串相同就合并信息（$\mathrm{pushdown}$），否则就说明它是一个本质不同的新串， 将其放回待选集合，等待下一次被挑选。（**这就保证了我们每次只进行一层操作，并保证集合的不重复性，即都是本质不同的串，本质相同的都及时进行了合并**）

综上，我们需要维护集合的**不重复性（保证正确性）、有序性（贪心地挑选最长的串）和一些对应信息**，因此需要 $\mathrm{map}$ 作为最终维护的数据结构，用 $\mathrm{Hash+map}$ 的常见技巧快速判断子串是否存在，时间复杂度 $\mathrm{O(nlogn)}$，瓶颈在于维护 $\mathrm{map}$ 的有序，以这种思路已经无法再进行优化了，但足以通过此题。

对于 $\mathrm{map}$ 里存的信息，$\mathrm{key}$ 应有字符串的长度和哈希值，$\mathrm{value}$ 应有其左右端点和最重要的出现次数，并以长度为第一关键字进行排序，故我们可以使用多元组来维护，$\mathrm{key}$ 可以用 $\mathrm{pair}$ 类型，而 $\mathrm{value}$ 可以用 $\mathrm{tuple}$ 类型。由于 $\mathrm{map}$ 排序是升序，而我们需要取最长串，可以用到反序迭代器 $\mathrm{map.rbegin()}$ 来实现，可以百度自行了解相关内容及 $\mathrm{tuple}$ 类型的使用方法。具体实现细节及注意事项，在代码中也有进一步的讲解。

另外，此题哈希的字符串数量较大，存在被“生日攻击”的风险（具体可以百度），哈希冲突概率较大，单模哈希容易被卡，尽量使用双模哈希。但如果比较懒，可以试一试不同的模数和基底（~~反正至少有一组能过~~）。代码里选择了一个玄学组合，请谨慎使用。

想改换自然溢出或者双模哈希的，可以看下面几道练习题后给出的参考代码。


#### 代码：

```cpp
//By 【Diana】 from Luogu 
#include<bits/stdc++.h>
#define int long long 
using namespace std;

const int N=5e4+7;
const int P=1610612741,B=3333;//试出来的神奇的一组数(为数不多的可以通过此题的组合之一)
char sa[N],sb[N];
int b[N],f1[N],f2[N],tot;

inline int GetHash1(int l,int r){//正序哈希的子串哈希值正着求
	if(l>r) swap(l,r);
	return (f1[r]-f1[l-1]*b[r-l+1]%P+P)%P;
}

inline int GetHash2(int l,int r){//倒序哈希的子串哈希值倒着求
	if(l>r) swap(l,r);
	return (f2[l]-f2[r+1]*b[r-l+1]%P+P)%P;
}

inline bool UpDownSame(int l1,int r1,int l2,int r2){//查询两子串是否互为倒序
	return GetHash1(l1,r1)==GetHash2(l2,r2);
}

map<int,int> Solve(char *s){//s: 起始下标为 1

//Part1: 预处理哈希值
	int len=strlen(s+1);
    map<pair<int,int>,tuple<int,int,int> > mp;//记录极长回文子串的 map, mp[pair<长度,哈希值>] = tuple<起点,终点,出现次数> 
	f1[0]=f2[len+1]=0,b[0]=1;//记得初始化
	for(int i=1;i<=len;++i){//正序哈希值
		f1[i]=(f1[i-1]*B+s[i])%P;
		b[i]=(b[i-1]*B)%P;
	}
	for(int i=len;i>=1;--i) f2[i]=(f2[i+1]*B+s[i])%P;//倒序哈希值

//Part2: 插入所有极长回文子串及其出现次数,并保证互不相同
	for(int i=1;i<=len;++i){//奇极长回文子串
		int l=1,r=min(i-1,len-i);//回文中心 : s[i]
		while(l<=r){//二分时有"小l大r",即查最小值结果为 l,查最大值结果为 r,此时为查符合条件的最大值
			int mid=l+((r-l)>>1);
			if(UpDownSame(i-mid,i-1,i+1,i+mid)) l=mid+1;
			else r=mid-1;
		}
    	if(r<0) continue;//奇数情况的回文半径可以为 0 (此时是回文串 s[i])
	    pair<int,int> key=make_pair(r<<1|1,GetHash1(i-r,i+r));//此种回文串的标识
	    if(mp.find(key)==mp.end()) mp[key]=make_tuple(i-r,i+r,1);//没有出现过就插入这个极长回文子串
		else ++get<2>(mp[key]);//否则出现次数 + 1 
	}
	for(int i=2;i<=len;++i){//插入所有偶极长回文子串(回文中心为 i-1~i 之间的夹缝)
		int l=1,r=min(i-1,len-i+1);//回文中心 : s[i-1]~s[i] 之间的夹缝
		while(l<=r){//同理
			int mid=l+((r-l)>>1);
			if(UpDownSame(i-mid,i-1,i,i+mid-1)) l=mid+1;
			else r=mid-1;
		}
		if(r<=0) continue;//偶数情况的回文半径不能为 0 (回文中心是个夹缝)
		pair<int,int> key=make_pair(r<<1,GetHash1(i-r,i+r-1));//以下同理
		if(mp.find(key)==mp.end()) mp[key]=make_tuple(i-r,i+r-1,1);
		else ++get<2>(mp[key]);
	}
	
//Part3: 去重并统计所有本质不同的回文子串的出现次数
	map<int,int> res;//res 是记录所有本质不同的回文子串的出现次数的 map [map<哈希值,出现次数>]
	while(!mp.empty()){//按长度从大到小挨个先抽出来,保证每次取出来的都是新出现的一个目前最长的、与之前所有都本质不同的回文串(这样就保证了复杂度)
		auto p=*mp.rbegin();//抽出来此串的 key , 并赋值给 p (p是一个 pair 类型, p.first 是 key (pair), p.second 是 value (tuple))
		mp.erase(p.first);//删除此串
		int lth=p.first.first,hs=p.first.second,l=get<0>(p.second),r=get<1>(p.second),ct=get<2>(p.second);//长度,哈希值,左端点,右端点,出现次数
		res[hs]=ct;//统计当前回文串出现次数,注意不能 += (没有初值)
		++l,--r;//左右各缩短 1 格
		if(l>r) continue;//原子串长度 <=2
		lth-=2,hs=GetHash1(l,r);//更新数据
		pair<int,int> key=make_pair(lth,hs);//新回文子串的 key 
		if(mp.find(key)==mp.end()) mp[key]=make_tuple(l,r,ct);//如果缩短后仍是一个新的回文串, 出现次数与原子串相同, 丢回去继续处理, 保证了子串的本质不同
		else get<2>(mp[key])+=ct;//否则将出现次数和与其本质相同的待处理的子串(下称"彼串")合并到一起, 在挑出彼串的时候会继续处理, 并会将彼串的所有子回文串的出现次数依次更新
	}
	
	return res;
}

signed main(){
	scanf("%s%s",sa+1,sb+1);
	map<int,int> rs1=Solve(sa),rs2=Solve(sb);
	for(auto it:rs1)
		if(rs2.find(it.first)!=rs2.end())//S是sa, sb的公共回文子串
        	tot+=it.second*rs2[it.first];//组合一下, 每次有 rs1[S]*rs2[S] 个四元组 (i,j,x,y) 
	printf("%lld",tot);
	return 0;
}

```

 ~~PAM是什么？能吃吗？~~

**练习题**：

1. [P5555 秩序魔咒](https://www.luogu.com.cn/problem/P5555)：
改一下统计的 res 即可，不过 P5555 的数据量极大，最好使用自然溢出。另附 P5555 自然溢出版参考代码：[自然溢出版](https://www.luogu.com.cn/paste/itr91al7)。

2. [P3649 回文串](https://www.luogu.com.cn/problem/P3649)：卡了自然溢出和 map 的大常数，要用双模哈希 + O2才能过。另附 P3649 双模哈希版参考代码：[双模哈希版](https://www.luogu.com.cn/paste/a7dfht9d)。

3. [P4287 双倍回文](https://www.luogu.com.cn/problem/P4287)：这题没卡自然溢出，但卡了 map 的大常数，要开 O2 才能过。另附 P4287 普通版参考代码：[普通版](https://www.luogu.com.cn/paste/0zuh39f3)。

这种解法在一定程度上能代替 $PAM$ ，但适用范围极窄，也不利于 $DP$ 等高级操作，不过过一过非强制在线的板子题还是可以的。

**特别鸣谢：**
calabash_boy （我不会告诉你这些都是葫芦爷讲的/kk） 

$Update(2022/4/4):$ 添加了几道原放于评论区的练习题。

---

## 作者：creation_hy (赞：5)

## 前言

这题和 P5555 很像啊。。。

## 思路

枚举每个共同的回文子串，然后就是一个排列组合了，直接给 $ans$ 加上它在第一个字符串出现的次数乘它在第二个字符串出现的次数即可。

怎么枚举共同的回文子串呢？

这部分和 P5555 一模一样。。。

以下借用我在 P5555 题解的原话：

很显然的一种做法就是，给两个子串分别建 PAM，然后 dfs 一遍。

正确性证明：PAM 中，下面的节点代表的串一定包含上面的节点代表的串。所以如果一个自动机拥有某节点，但另一个没有，那么再往下找显然也不会出现新的共同拥有的回文串。

注意一个（不知道算不算坑）的点：dfs 过程中，虽然两个 PAM 的节点在外观（所代表的字符串）上是相等的，但是由于遍历顺序原因，编号并不一定相等……

所以只用一个 $x$ 去同时代表两个 PAM 当前节点的编号是不对的，需要用两个指针。

还有，注意：节点 $0$ 和节点 $1$ 代表的是通用偶数长度根和通用奇数长度根，不代表任何实际意义，所以是不能算的。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 5;
ll n, m, ans;
struct PAM
{
    int len[N], num[N], fail[N], t[N][26], tot = 1;
    string s;
    inline int getFail(int x, int i)
    {
        while (i - len[x] - 1 < 0 || s[i] != s[i - len[x] - 1])
            x = fail[x];
        return x;
    }
    inline void build()
    {
        int cur = 0;
        fail[0] = 1, len[1] = -1;
        for (int i = 0; i < s.size(); i++)
        {
            s[i] -= 'A';
            int pos = getFail(cur, i);
            if (!t[pos][s[i]])
            {
                fail[++tot] = t[getFail(fail[pos], i)][s[i]];
                t[pos][s[i]] = tot;
                len[tot] = len[pos] + 2;
            }
            cur = t[pos][s[i]];
            num[cur]++;
        }
        for (int i = tot; i >= 2; i--)
            num[fail[i]] += num[i];
    }
} A, B;
inline void dfs(int l, int r)
{
    if (l > 1 && r > 1)
        ans += 1ll * A.num[l] * B.num[r];
    for (int i = 0; i < 26; i++)
        if (A.t[l][i] && B.t[r][i])
            dfs(A.t[l][i], B.t[r][i]);
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> A.s >> B.s;
    A.build(), B.build();
    dfs(0, 0), dfs(1, 1);
    cout << ans;
    return 0;
}
```

---

## 作者：violetctl39 (赞：3)

题目大意：给你两个字符串，求它们的公共回文子串对数。

------------
大部分人的做法是对 $A$ 建 $PAM$ ，然后把 $B$ 放在上面匹配；或是建两个 $PAM$ ，然后一起 $dfs$ 匹配。

其实可以直接上 广义$PAM$ （应该可以这么叫吧），把两个字符串建到一个 广义$PAM$ ，然后 $dfs$ 所有节点统计答案。

能建 广义$PAM$ 的理由：

$PAM$ 中是专门判了重节点，况且 $PAM$ 中没有节点会同时包含两个状态，所以可以每次都是从头加字符串，这样不会影响 $PAM$ 的性质。构造 广义$PAM$ 的方法和构造 广义$SAM$ 的那个假掉的做法一样。（滑稽）

设 $f[x][0]$ 是 $A$ 串在 $x$ 节点上的回文子串数，$f[x][1]$ 是 $B$ 串在 $x$ 节点上的回文子串数。

那么答案即为 $\large \sum\limits_{i=2}^{cnt}f[x][0]\times f[x][1]$ 。（ $cnt$ 是节点数，0和1是根）

代码：

```cpp
#include<bits/stdc++.h>
#define pc(x) putchar(x)
#define ll long long
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){f=ch=='-'?-1:f;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
void write(ll x)
{
	if(x<0){x=-x;putchar('-');}
	if(x>9)write(x/10);
	putchar(x%10+48);
}
int n,m,f[100005][2];ll ans;
char s[50005];
struct G_PAM
{
	int ch[26],fa,len;
}tr[100005];
int lst,cnt=1;
void init()
{
	s[0]=-1;tr[1].len=-1;
	tr[0].fa=tr[1].fa=1;
	lst=0;
}
void insert(int k,int c,int id)
{
	int p=lst;
	while(s[k-tr[p].len-1]!=c+'A')p=tr[p].fa;
	if(!tr[p].ch[c])
	{
		int q=lst=++cnt,v=tr[p].fa;
		while(s[k-tr[v].len-1]!=c+'A')v=tr[v].fa;
		tr[q].fa=tr[v].ch[c];
		tr[tr[p].ch[c]=q].len=tr[p].len+2;
	}else lst=tr[p].ch[c];
	f[lst][id]++;
}
vector<int>e[600005];
void dfs(int x)
{
	for(int i=0;i<(int)e[x].size();++i)
	{
		int y=e[x][i];dfs(e[x][i]);
		f[x][0]+=f[y][0];f[x][1]+=f[y][1];
	}
	if(x==1||x==0)return;
	ans+=1ll*f[x][0]*f[x][1];
}
int main()
{
	scanf("%s",s+1);n=strlen(s+1);init();
	for(int i=1;i<=n;++i)insert(i,s[i]-'A',0);
	scanf("%s",s+1);n=strlen(s+1);init();
	for(int i=1;i<=n;++i)insert(i,s[i]-'A',1);
	for(int i=2;i<=cnt;++i)e[tr[i].fa].push_back(i);
	e[1].push_back(0);dfs(1);write(ans),pc('\n');
	return 0;
}
```



---

## 作者：2018LZY (赞：2)

我的做法与前面两个神仙的做法略有不同.

一个直截了当/不需分两串讨论的方法.

直接把两个串建在一个回文自动机上.
定义$f[x]$表示$x$对应的回文串在A中出现的次数,$g[x]$表示$x$对应的回文串在B中出现的次数.

那么显然的$\sum_{i=2}^{tot} f[i]g[i]$即为答案(tot为PAM节点数)

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
typedef long long ll;
const int N=1e5+10;

int n,last,tot=1,tr[N][26],fail[N],len[N],f[N],g[N],b[N],c[N];
ll ans; char s[N];
int New(int x) {len[++tot]=x; return tot;}
int Find(int x,int n) {
	while(s[n]^s[n-len[x]-1]) x=fail[x];
	return x;
}
void bt(int *cnt) {
	last=1;
	fail[0]=1;
	len[0]=0;len[1]=-1;
	for(int i=1,p,x,c;s[i];i++) {
		c=(s[i]-='A');
		p=Find(last,i);
		if(!tr[p][c]) {
			x=New(len[p]+2);
			n=max(len[x],n);
			fail[x]=tr[Find(fail[p],i)][c];
			tr[p][c]=x;
		}
		last=tr[p][c]; cnt[last]++;
	}
}

int main() {
	s[0]=-1;
	scanf("%s",s+1);bt(f);
	scanf("%s",s+1);bt(g);
	for(int i=2;i<=tot;i++) c[len[i]]++;
	for(int i=1;i<=n;i++) c[i]+=c[i-1];
	for(int i=tot;i>=2;i--) b[c[len[i]]--]=i;
	for(int i=tot-1; i;i--)  {
		int j=b[i];
		f[fail[j]]+=f[j];
		g[fail[j]]+=g[j];
		ans+=(ll)f[j]*g[j];
	}
	pr2(ans); return 0;
}
```


---

## 作者：crashed (赞：2)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P5685)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一言以蔽之概括题意——求两个串的公共回文子串的数量。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑像在后缀自动机上面跑。我们先对$A$串建立回文自动机。然后把$B$串放到回文自动机上面跑，类似于构建回文自动机，只不过我们不新建节点。然后跑到一个节点上之后，我们统计答案。把$B$跑完之后就有答案了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑对于一个节点，我们应该记录它表示的回文串以它为后缀的回文串的总的出现次数。如果记录所有子串的出现次数和，那么就有可能出现重复统计的情况。而统计以某个节点为后缀的，则总只会记录当前加入的$B$字符的相关的答案，不会统计到之前的。而这个东西很容易用$dp$做出来。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先用一个$dp$求出每个节点表示的回文串的出现次数：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$f(u)$：以$u$为节点表示的回文串的出现次数。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移略。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后再用一个$dp$求出我们想要的东西：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$g(u)$：$u$表示的节点的回文串的后缀的出现次数的和。   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移：  
$$g(u)=f(u)+g(fa(u))$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~迷之简洁~~  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;得到了$g$之后就可以跑$B$串求出答案啦！  
# 代码
```cpp
#include <cstdio>
#include <cstring>

typedef long long LL;

const int MAXN = 50005;

template<typename _T>
void read( _T &x )
{
	x = 0; char s = getchar();int f = 1;
	while( s < '0' || '9' < s ) { f = 1; if( s == '-' ) f = -1; s = getchar(); }
	while( '0' <= s && s <= '9' ) { x = ( x << 3 ) + ( x << 1 ) + s - '0', s = getchar(); }
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ) { putchar( '-' ), x = -x; }
	if( 9 < x ) { write( x / 10 ); }
	putchar( x % 10 + '0' );
}

int f[MAXN];
int ch[MAXN][26], fa[MAXN], len[MAXN];
char A[MAXN], B[MAXN];
int N, M, lst, siz;

void build( const char *S )
{
	int l = strlen( S + 1 ), x, p, cur;
	fa[0] = ++ siz; len[1] = -1;
	for( int i = 1 ; i <= l ; i ++ )
	{
		x = S[i] - 'A';
		while( S[i] ^ S[i - len[lst] - 1] ) lst = fa[lst];
		if( ! ch[lst][x] )
		{
			cur = ++ siz, p = fa[lst]; len[cur] = len[lst] + 2;
			while( S[i] ^ S[i - len[p] - 1] ) p = fa[p];
			fa[cur] = ch[p][x], ch[lst][x] = cur;
		}
		lst = ch[lst][x], f[lst] ++;
	}
}

int main()
{
	scanf( "%s%s", A + 1, B + 1 ); 
	N = strlen( A + 1 ), M = strlen( B + 1 ); 
	build( A );
	for( int i = siz ; i > 1 ; i -- ) 
		if( fa[i] > 1 ) f[fa[i]] += f[i];
	for( int i = 2 ; i <= siz ; i ++ ) f[i] += f[fa[i]];
	int p = 0, x;
	LL res = 0;
	for( int i = 1 ; i <= M ; i ++ )
	{
		x = B[i] - 'A';
		while( p ^ 1 && ( B[i] ^ B[i - len[p] - 1] || ! ch[p][x] ) ) p = fa[p];
		if( ch[p][x] ) p = ch[p][x];
		else p = 0;
		res += f[p];
	}
	write( res ), putchar( '\n' );
	return 0;
}
```

---

## 作者：fbcxxg (赞：1)

# [JSOI2013] 快乐的 JYY 题解

众所周知，~~jyy的故事将要结束了~~ （好吧，应该还会有故事的）。

纯纯回文自动机裸题，那回文自动机模版题在哪里，[点这里](https://www.luogu.com.cn/problem/P5496)。 

那回文自动机又是什么，看下面。

回文自动机，也称回文树，是用来解决一些 manacher 算法不容易解决的回文串的问题，比如求解字符串 $s$ 中以第 $i$ 个字符结尾的回文串的个数。当然它还可以用于求解本质不同的回文子串的数目，所有的**回文子串的数目**，其复杂度也都是 $O(n)$ 的，其中 $n$ 是字符串的长度。

而回文自动机本质上就是两棵树，一棵树上挂着**长度为奇数的回文串**，另一棵树上挂着**长度 为偶数的回文串**，$0$ 代表偶数长度的根，$1$ 代表奇数长度的根。我们利用一个回文串去掉两头之后还是一个回文串的性质把所有的回文串都存储在树上。树上的每个节点都代表着一个字符串。

好了，不多说了，贴代码！

**CODE:**


------------

```cpp
#include<bits/stdc++.h> 
using namespace std;
const int N=50005;
struct str{
    int son[27];
    int cnt;
    int fail;
    int len; 
}s[2][N];
int S[N],last,p,n;
int new_node(int X,int x){//加入一个长度为x的点 
    s[X][p].len=x;
    return p++;
}
void init (int X){
    p=0;n=0;last=0;
    new_node(X,0);new_node(X,-1);
    S[n]=-1;
    s[X][0].fail=1;
}
int get_fail (int X,int x){
    while (S[n-s[X][x].len-1]!=S[n]) x=s[X][x].fail;
    return x;
}
void ins (int X,int x){
    S[++n]=x;
    int cur=get_fail(X,last);
    if (s[X][cur].son[x]==0){
        int now=new_node(X,s[X][cur].len+2);
        s[X][now].fail=s[X][get_fail(X,s[X][cur].fail)].son[x];
        s[X][cur].son[x]=now;
    }
    last=s[X][cur].son[x];
    s[X][last].cnt++;
}
void count (int X){
    for (int u=p-1;u>=0;u--)
        s[X][s[X][u].fail].cnt+=s[X][u].cnt;
}
typedef long long LL;
LL ans=0;
void dfs (int now1,int now2){
    if (s[0][now1].len>0)
        ans=ans+(LL)s[0][now1].cnt*s[1][now2].cnt;
    for (int u=0;u<26;u++)
        if (s[0][now1].son[u]!=0&&s[1][now2].son[u]!=0)
            dfs(s[0][now1].son[u],s[1][now2].son[u]);
}
int main(){   
    char ch;
    init(0);
    ch=getchar();while (ch<'A'||ch>'Z') ch=getchar();
    while (ch>='A'&&ch<='Z') {
        ins(0,ch-'A');
        ch=getchar();
    }
    count(0);
    init(1);
    ch=getchar();while (ch<'A'||ch>'Z') ch=getchar();
    while (ch>='A'&&ch<='Z') {
        ins(1,ch-'A');
        ch=getchar();
    }
    count(1);
    dfs(0,0);dfs(1,1);
    cout<<ans;
    return 0;
}
```
------------

**end**

---

## 作者：Leap_Frog (赞：1)

### P.S.
前置知识：回文自动机
### Description.
求在两个字符串中出现相同回文串的次数。  
### Solution.
首先，回文自动机上每个节点都代表一个本质不同回文串。  
那么我们对两个串分别建回文自动机，并一起匹配。  
匹配到的每个节点都是同一个回文串，我们算上他们出现次数的乘积就好了。  
注意回文自动机是有两个根的，需要dfs两遍。  
~~注意此题大写字符~~
### Coding.
```cpp
//愿你有一天能和你重要的人重逢。
#include<bits/stdc++.h>
using namespace std;typedef long long ll;
template<typename T>inline void read(T &x)
{
	x=0;char c=getchar(),f=0;
	for(;c<'0'||c>'9';c=getchar()) if(c=='-') f=1;
	for(;c>='0'&&c<='9';c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	if(f) x=-x;
}
int n,m;ll sm=0;char c1[2600825],c2[2600825];
struct node
{
	struct pamn{int fa,len,siz,ch[26];}pm[2600825];int pmt,pls;
	inline void init() {pmt=pls=2,pm[1].len=-1,pm[2].fa=pm[1].fa=1;}
	inline void ins(int wh,int c,char *s)
	{
		int p=pls;for(;s[wh]^s[wh-pm[p].len-1];p=pm[p].fa);
		if(pm[p].ch[c]) return pls=pm[p].ch[c],pm[pls].siz++,void();
		int np=pls=++pmt,ph=pm[p].fa;pm[np].len=pm[p].len+2,pm[np].siz=1;
		for(;s[wh]^s[wh-pm[ph].len-1];ph=pm[ph].fa);
		pm[np].fa=pm[ph].ch[c]?pm[ph].ch[c]:2,pm[p].ch[c]=np;
	}
}p1,p2;
inline void dfs1(int x,int y)
{
	if(x>2&&y>2) sm+=1ll*p1.pm[x].siz*p2.pm[y].siz;
	for(int i=0;i<26;i++) if(p1.pm[x].ch[i]&&p2.pm[y].ch[i]) dfs1(p1.pm[x].ch[i],p2.pm[y].ch[i]);
}
int main()
{
	p1.init(),p2.init(),scanf("%s%s",c1+1,c2+1),n=strlen(c1+1),m=strlen(c2+1);
	c1[0]=-1;for(int i=1;i<=n;i++) p1.ins(i,c1[i]-='A',c1);
	c2[0]=-1;for(int i=1;i<=m;i++) p2.ins(i,c2[i]-='A',c2);
	for(int i=p1.pmt;i>1;i--) p1.pm[p1.pm[i].fa].siz+=p1.pm[i].siz;
	for(int i=p2.pmt;i>1;i--) p2.pm[p2.pm[i].fa].siz+=p2.pm[i].siz;
	return dfs1(1,1),dfs1(2,2),printf("%lld\n",sm),0;
}
```

---

## 作者：5k_sync_closer (赞：0)

简化题意：公共回文串计数。

对两个串分别建 PAM，然后同时遍历它们，每次只走它们共有的边，

此时能遍历到的点就是两个串的所有公共回文串，考虑每个点的贡献。

对 PAM 上每个点 $i$ 求出 $c_i$ 表示其出现次数，则能被同时遍历到的点对 $(i,j)$ 的贡献即为 $c_i\times c_j$。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
long long q;
struct T
{
    char u[50050];
    int n, o, z, l[50050], f[50050], d[50050], c[50050][26];
    int F(int x)
    {
        while (u[n] != u[n - l[x] - 1])
            x = f[x];
        return x;
    }
    void I(int x)
    {
        ++n;
        int p = F(z);
        if (!c[p][x])
            l[c[p][x] = ++o] = l[p] + 2, f[c[p][x]] = p != 1 ? c[F(f[p])][x] : 0;
        ++d[z = c[p][x]];
    }
    void D()
    {
        for (int i = o; i >= 2; --i)
            d[f[i]] += d[i];
    }
} X, Y;
void D(int x, int y, int d)
{
    if (x >= 2 && y >= 2)
        q += 1ll * X.d[x] * Y.d[y];
    for (int i = 0; i < 26; ++i)
        if (X.c[x][i] && Y.c[y][i])
            D(X.c[x][i], Y.c[y][i], d + 2);
}
int main()
{
    X.l[X.f[0] = X.o = 1] = -1;
    Y.l[Y.f[0] = Y.o = 1] = -1;
    scanf("%s%s", X.u + 1, Y.u + 1);
    for (int i = 1; X.u[i]; ++i)
        X.I(X.u[i] - 'A');
    for (int i = 1; Y.u[i]; ++i)
        Y.I(Y.u[i] - 'A');
    X.D();
    Y.D();
    D(0, 0, 0);
    D(1, 1, -1);
    printf("%lld", q);
    return 0;
}
```


---

## 作者：takanashi_mifuru (赞：0)

简要题意：

我们要求出两个串中有多少对公共回文子串。

解析：

你看到这个回文，很容易就想到先建一个回文自动机，然后考虑直接在回文树上面搜索，只有两个回文树都有值的时候我们才会往下搜索，每次往下搜就代表这两个回文子串在两个大串里面都存在，那你说我知道他们存在有什么用啊，我要知道他们有多少对啊，那我们就计算一下一个回文子串在一个大串里面出现了多少次，这个可以直接树上差分处理，然后就做完了，时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
class PAM{
    public:
    int nxt[500005][26];
    int fail[500005];
    int len[500005];
    int dep[500005];
    int cnt[500005];
    int diff[500005];
    int tot,now,n;
    string S;
    void getfail(){
        tot=2;
        fail[1]=2;
        fail[2]=2;
        len[1]=0;
        len[2]=-1;
        now=1;
        for(int i=1;i<=n;i++){
            while(S[i]!=S[i-len[now]-1]){
                now=fail[now];
            }
            if(!nxt[now][S[i]-'A']){
                nxt[now][S[i]-'A']=++tot;
                len[tot]=len[now]+2;
            }
            int cur=fail[now];
            now=nxt[now][S[i]-'A'];
            diff[now]++;
            if(fail[now]){
                continue;
            }
            while(S[i]!=S[i-len[cur]-1]){
                cur=fail[cur];
            }
            fail[now]=nxt[cur][S[i]-'A'];
            if(fail[now]==now)fail[now]=1;
        }
        for(int i=tot;i>=1;i--){
            cnt[i]+=diff[i];
            cnt[fail[i]]+=cnt[i];
        }
        cnt[1]=cnt[2]=0;
        return;
    }
}P,Q;
long long ans;
void dfs(int cur1,int cur2,int len){
    ans+=1ll*P.cnt[cur1]*Q.cnt[cur2];
    for(int i=0;i<26;i++){
        if(P.nxt[cur1][i]&&Q.nxt[cur2][i]){
            dfs(P.nxt[cur1][i],Q.nxt[cur2][i],len+2);
        }
    }
    return;
}
int main(){
    cin>>P.S;
    cin>>Q.S;
    P.n=P.S.size();
    Q.n=Q.S.size();
    P.S='?'+P.S;
    Q.S='?'+Q.S;
    P.getfail();
    Q.getfail();
    dfs(1,1,0);
    dfs(2,2,-1);
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：happybob (赞：0)

看到回文，考虑回文自动机。然而出现次数貌似不太好做。由于有 $O(n)$ 级别的本质不同回文子串，所以每次匹配一次肯定不行。

但是有一个很好的性质！我们发现要求出现次数的字符串一定是回文。不妨对两个串建立回文自动机，用树形 DP 容易求出每个回文子串出现次数。

由于是树，考虑同时 DFS，如果通过一系列相同的转移到达了相同的节点，则对答案的贡献是 $f_x \times f_y$，$f$ 是树形 DP 的结果。

复杂度线性。

---


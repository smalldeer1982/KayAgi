# [CQOI2016] 路由表

## 题目描述

路由表查找是路由器在转发 IP 报文时的重要环节。通常路由表中的表项由目的地址、掩码、下一跳（Next Hop）地址和其他辅助信息组成。例如：
| 目的地址 | 掩码长度 | 下一跳 |
| :----------: | :----------: | :----------: |
| 0.0.0.0 | /1 | 192.168.1.1 |
| 128.0.0.0 | /1 | 192.168.1.1 |
| 8.8.8.0 | /24 | 192.168.1.1 |
| 8.8.8.8 | /32 | 192.168.1.253 |


当路由器收到一个 IP 报文时，会将报文中的目的 IP 地址与路由表中的表项逐条进行比较，选择匹配且**最明确**的表项，将报文转发给该表项中指定的下一跳。

匹配的过程是将报文中的目的地址和表项中的目的地址分别转为二进制串，再查看表项中的掩码长度，若掩码长度为 $x$ ，则将两个二进制串的前 $x$ 位进行比较，如果相同则认为匹配。

所谓**最明确**是指在有多个表项匹配时，掩码长度最大的表项。也可以理解为匹配的二进制位最多的项。

IP 地址转为二进制串的操作是把地址中 $4$ 个整数（一定在 $0$ 到 $255$ 的范围内）分别转为 $8$ 位二进制数，再顺序拼接起来，得到一个  位的二进制串。例如，$192.168.1.253$ 转为二进制串后为 $11000000 $ $10101000$ $00000001$ $11111101$。

我们以报文的目的地址为 $8.8.8.8$ 为例，说明其在上述路由表的匹配过程。


| 8.8.8.8 | 00001000 00001000 00001000 00001000 |
| :----------: | :----------: |
| 0.0.0.0/1 | $\color{red}{0}$0000000 00000000 00000000 00000000 |
| 128.0.0.0/1 | $\color{red}{1}$0000000 00000000 00000000 00000000 |
| 8.8.8.0/24 | $\color{red}{00001000}$ $\color{red}{00001000 }$ $\color{red}{00001000}$ 00000000 |
| 8.8.8.8/32 | $\color{red}{00001000}$ $\color{red}{00001000 }$ $\color{red}{00001000}$ $\color{red}{00001000}$  |


上表将地址均转为二进制串，并用红色标记出待比较的位（由掩码长度决定）。将红色部分与报文中的目的地址比较，可知 $0.0.0.0/1$、$8.8.8.0/24$、$8.8.8.8/32$ 均能够匹配。路由器从中选取掩码长度最长（/32）的表项 $8.8.8.8/32$，将报文转发给其对应的下一跳地址 $192.168.1.253$。

在实际的核心路由器中，路由表通常较大（现在互联网的全局路由表已经接近 $60$
 万条记录），并且会随着新接入设备不断扩张。为了分析路由表变化对转发产生的影响，网络工程师想要知道一段时间内某个 IP 地址的路由表项选择发生了多少次变化（变化是指由于最明确匹配等因素选择了不同的表项，不考虑下一跳地址）。

## 说明/提示

对于一次查询的一种理解方式是：无视其它所有查询操作，只看添加操作。先清空路由表，然后执行第 $1$ 到 $a-1$ 次添加操作。之后再统计第 $a$ 到 $b$ 次添加操作过程中匹配改变的次数。

--------

对于 $30\%$ 的数据，$M \le 10^3$；

对于 $100\%$ 的数据，$M \le 10^6$。

设一条表项的掩码长度为 $L$，数据保证将目的地址转为二进制串后，末尾的 $32-L$ 位均为 $0$。另外，保证不会重复添加目的地址和掩码长度都相同的表项。

## 样例 #1

### 输入

```
47
A 128.0.0.0/1
A 128.0.0.0/4
A 100.200.20.0/23
A 241.170.96.0/20
A 74.128.0.0/17
A 193.24.0.0/14
A 128.0.0.0/19
A 128.0.0.0/13
A 128.0.0.0/5
A 128.0.0.0/11
A 128.0.0.0/12
A 192.0.0.0/7
Q 192.0.0.13 1 8
A 128.0.0.0/8
Q 128.0.0.15 1 8
A 74.0.0.0/8
A 96.0.0.0/4
A 193.24.0.0/23
A 100.192.0.0/11
A 128.0.0.0/18
A 128.0.0.0/20
Q 128.0.0.4 1 13
A 192.0.0.0/8
A 192.0.0.0/22
Q 128.0.0.7 1 14
A 128.0.0.0/23
A 74.128.0.0/14
A 128.0.0.0/14
A 128.0.0.0/25
A 74.128.0.0/12
Q 128.0.0.9 2 17
A 96.0.0.0/11
A 64.0.0.0/2
A 74.0.0.0/26
A 100.192.0.0/18
A 128.0.0.0/27
A 193.24.0.0/18
Q 128.0.0.3 4 21
Q 74.128.0.12 3 24
A 128.0.0.0/9
A 193.24.0.0/22
Q 128.0.0.7 4 24
A 192.0.0.0/10
Q 128.0.0.3 2 23
A 100.192.0.0/10
Q 241.170.96.2 1 26
Q 100.192.0.4 4 24
```

### 输出

```
1
3
3
3
2
2
1
3
4
2
2
```

# 题解

## 作者：StudyingFather (赞：8)

本题容易看出是一个在 Trie 树上的匹配问题。

对于每个添加操作，我们只需按题意将指定 ip 的前 $x$ 位插入即可（$x$ 位后面的内容显然没有意义），并在结束位置打一个标记 $ed$，表示这是第 $ed$ 条表项。

对于查询操作，题目最后的提示告诉我们可以差分。

也就是说一个查询 $[l,r]$ 可以变成两个查询 $[1,r]$ 和 $[1,l-1]$，最后把结果相减即可。

我们现在考虑如何解决一个 $[1,x]$ 类型的查询。

我们还是在 Trie 树上走，并用一个单调栈维护我们遇到的标记。每遇到一个有效标记（在查询范围内），就先将栈内时间比它靠后的标记弹出（这些标记都是无用的），再将该标记插入栈中。

最后结果就是栈内的元素数目。

```cpp
#include <cstdio>
#include <stack>
using namespace std;
typedef unsigned ui;
struct trie
{
 struct node
 {
  int son[2],ed;
 }p[10000005];
 int tot=1,id=0;
 void insert(ui ip,int len)
 {
  int u=1;
  for(int i=31;32-i<=len;i--)
  {
   int v=(ip>>i)&1;
   if(p[u].son[v])u=p[u].son[v];
   else
   {
    p[u].son[v]=++tot;
    u=tot;
   }
  }
  p[u].ed=++id;
 }
 int query(ui ip,int t)
 {
  stack<int> s;
  int u=1,pos=31;
  while(1)
  {
   if(p[u].ed&&p[u].ed<=t)
   {
    int ed=p[u].ed;
    while(!s.empty()&&ed<s.top())
     s.pop();
    s.push(ed);
   }
   int v=(ip>>pos)&1;
   if(!p[u].son[v])break;
   else u=p[u].son[v];
   pos--;
  }
  return s.size();
 }
}tr;
char op[5];
ui getip()
{
 ui ip=0;
 int a,b,c,d;
 scanf("%d.%d.%d.%d/",&a,&b,&c,&d);
 ip=(ip<<8)+a,ip=(ip<<8)+b,ip=(ip<<8)+c,ip=(ip<<8)+d;
 return ip;
}
int main()
{
 int m;
 scanf("%d",&m);
 while(m--)
 {
  scanf("%s",op);
  if(op[0]=='A')
  {
   ui ip=getip();
   int len;
   scanf("%d",&len);
   tr.insert(ip,len);
  }
  else
  {
   ui ip=getip();
   int a,b;
   scanf("%d%d",&a,&b);
   printf("%d\n",tr.query(ip,b)-tr.query(ip,a-1));
  }
 }
 return 0;
}
```


---

## 作者：Find_Yourself (赞：4)

暴力1：按照题意模拟即可，复杂度 $O(32n^2)$，预计 30pts。

暴力2：将 IP 地址用 `unsigned int` 存下来，比较 $a$，$b$ 是否匹配就只需要用位运算 $O(1)$ 判断即可，复杂度 $O(n^2)$，预计 50pts。

正解：考虑将当前插入的所有 IP 地址建成一颗 01Trie，结尾打上标记。

对于每次询问，将路径上的所有标记存入一个维护单调递增序列的栈，二分 $l$ 和 $r$ 的位置并计算一下差值就行了。（信息量有些大......）

复杂度线性，预计 100pts。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e7 + 5, N2 = 100 + 5;
int m, cnt = 0, tot = 1, nex[N][2], ed[N], st[N2];
void add(string t, int len, int id) { //建树
	int cur = 1;
	for (int i = 0; i < len; ++i) {
		if (!nex[cur][t[i] - '0']) nex[cur][t[i] - '0'] = ++tot;
		cur = nex[cur][t[i] - '0'];
	}
	ed[cur] = id;
}
void getans(string t, int l, int r) {
	int cur = 1, tail = 0;
	for (int i = 0; i < t.size(); ++i) {
		if (nex[cur][t[i] - '0']) {
			cur = nex[cur][t[i] - '0'];
			if (ed[cur]) {
				while (tail && st[tail] > ed[cur]) --tail;
				st[++tail] = ed[cur];
			}
		} else break;
	}
   //二分l和r的位置
	int p1 = lower_bound(st + 1, st + tail + 1, l) - st;
	int p2 = upper_bound(st + 1, st + tail + 1, r) - st - 1;
	cout << p2 - p1 + 1 << endl;
}
int main() {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    cin >> m;
    for (int i = 1; i <= m; ++i) {
        char op, c; cin >> op;
        if (op == 'A') {
            int x[6];
            cin >> x[1] >> c >> x[2] >> c >> x[3] >> c >> x[4] >> c >> x[5];
            string t = "";
            for (int j = 1; j <= 4; ++j) {
                for (int k = 7; k >= 0; --k) {
                    if ((1 << k) & x[j]) t.push_back('1');
                    else t.push_back('0');
                }
            }
            add(t, x[5], ++cnt);
        } else {
            int x[6], l, r;
            cin >> x[1] >> c >> x[2] >> c >> x[3] >> c >> x[4] >> l >> r;
            string t = "";
            for (int j = 1; j <= 4; ++j) {
                for (int k = 7; k >= 0; --k) {
                    if ((1 << k) & x[j]) t.push_back('1');
                    else t.push_back('0');
                }
            }
            getans(t, l, r);
        }
    }
    return 0;
}
```


---

## 作者：Grisses (赞：3)

[题面](https://www.luogu.com.cn/problem/P5768)

容易想到用 Trie 维护字符串的插入，然后问题就是如何处理询问了。

首先，插入字符串时只用插前 $l$ 位，因为在掩码的影响下，$l$ 位以后就是没有意义的。

我们这样考虑：

在第 $i$ 次插入字符串 $s_i$ 的时候，对于一个报文 $s$，我们设其原来最明确匹配到了第 $p$ 位，那么对于 $s_i$：

1. $s_i$ 在掩码内与 $s$ 并不匹配，那么我们就忽略其。

2. $s_i$ 成功匹配，但是掩码长度小于等于了 $p$，不会更新。

3. $s_i$ 成功匹配且更加明确，那么就会更新 $s$ 的最明确匹配。

所以，我们发现 $s$ 的如果两个匹配 IP，$s_i$ 和 $s_j$ 满足 $s_i$ 更加明确且在加入 $s_i$ 前 $s_j$ 最为明确（即 $s_i$ 是由 $s_j$ 转变），则表明 $i>j\land l_i>l_j$（需要满足 $s_i$ 在 $s_j$ 后插入且匹配位数更大）。

看着这个，我们可以想到一个优秀的数据结构：~~丹钓战~~ **单调栈**，不难发现，在查询中，我们可以在单调栈中维护从上至下遍历时每一个匹配的字符串的序号以满足要求。最后得到的就是报文 $s$ 至询问为止每一次转变的编号组成的序列（由题可得那时路由表里有超过 $b$ 个元素）。然后看在 $[a,b]$ 的范围中的元素的数量即可。

---

代码：

```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int read(){//快读读入IP地址，方便
      int x=0;char c=getchar();
      while(c<'0'||c>'9')c=getchar();
      while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
      return x;
  }
  int n,m,l,tot,a,b;
  int top,s[320005];//单调栈
  char op[10],S[105];
  struct Trie{//字典树
      int cnt=0;
      struct node{
          int t[2];
          set<int>val;
      }c[3200005];
      int Build(){
          cnt++;
          c[cnt].t[0]=c[cnt].t[1]=-1;
          c[cnt].val.clear();
          return cnt;
      }
      int Insert(int q,char* s,int id){
          int len=strlen(s);
          for(int i=0;i<len;i++){
              if(c[q].t[s[i]-'0']==-1)c[q].t[s[i]-'0']=Build();
              q=c[q].t[s[i]-'0'];
          }
          c[q].val.insert(id);//标记字符串的编号
          return q;
      }
      void Search(int q,char* S){
          int len=strlen(S);
          top=0;
          for(int i=0;i<len;i++){
              if(c[q].t[S[i]-'0']==-1)break;
              q=c[q].t[S[i]-'0'];
              for(auto x:c[q].val){
                  while(top>0&&x<s[top])top--;//维护单调栈
                  s[++top]=x;
              }
          }
      }
  }T;
  int main()
  {
      m=read();
      T.Build();
      while(m--){
          scanf("%s",op);
          for(int i=1,x;i<=4;i++){
              x=read();
              for(int j=1;j<=8;j++){
                  S[(i-1)*8+j]=((x>>(8-j))&1)+'0';//转化为字符串
              }
          }
          if(op[0]=='A'){
              l=read();
              S[l+1]='\0';
              T.Insert(1,S+1,++tot);//插入
          }
          else{
              scanf("%d%d",&a,&b);
              T.Search(1,S+1);
              int ans=0;
              for(int i=1;i<=top;i++){
                  if(s[i]>=a&&s[i]<=b)ans++;//求出答案
              }
              printf("%d\n",ans);
          }
      }
      return 0;
  }
```

---

## 作者：AIskeleton (赞：2)

> [P5768 [CQOI2016]路由表](https://www.luogu.com.cn/problem/P5768)

> 对于每个字符串，将其转换成二进制串的形式，每 $8$ 位表示一个数，且每个串都有一个长度数值 $L_i$，表示需匹配的位数。

> 给定 $n$ 次操作， 操作有两种：
> - 插入操作：添加题目给出的掩码长度为 $L_i$ 的串 $S$。
> - 查询操作：询问给出的串 $S$ 在 $\left[ L,R \right]$ 次插入操作时的字符串匹配时**匹配情况变化了几次**。

很明显可以用 01trie 维护。

对于每个添加的操作，就将其拆分为 01 串的形式插入 01trie 即可。

至于查询的操作，题目直接明说了用**差分**，即 $\left[L,R \right]$ 可以通过 $\left[1,R \right]-\left[1,L \right]$ 求出。

稍加思考可知匹配的过程能类比**单调栈**的操作。

就是在 01trie 树上查询时维护一个单调栈：
- 如果当前标记在范围之内，就将栈顶所有时间更晚的标记弹出，再将当前节点入栈。
- 最后结果就是单调栈中的元素个数。

```cpp
#include <bits/stdc++.h>
using namespace std;const int N=3e6;
int R(){
    int x=0;char ch=getchar();while(ch<'0'||ch>'9')ch=getchar();
    for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+(ch^48);return x;
}void W(int x){if(x>9)W(x/10);putchar(x%10+'0');}
int n,t[N][2],u,c,len,l,r,p[N],tot,f[N],cnt,mi,x,sum,g;char o;
void ip(){for(int j=0,k;j<4;++j){k=R();for(int v=7;v>=0;v--)p[j*8+v]=k%2,k>>=1;}return ;}
void in(){u=0;for(int i=0;i<len;i++){if(!t[u][p[i]])t[u][p[i]]=++tot;u=t[u][p[i]];}f[u]=++cnt;}
int q(int x){
    u=0;stack <int> s;
    for(int i=0;i<32;i++){
        if(!t[u][p[i]])break;u=t[u][p[i]];
        if(f[u]&&f[u]<=x){g=f[u];while(s.size()&&g<s.top())s.pop();s.push(g);}
    }return s.size();
}int main(){
    n=R();for(int i=1;i<=n;i++){
        cin>>o;ip();
        if(o=='A')len=R(),in();
        else l=R(),r=R(),W(q(r)-q(l-1)),puts("");
    }return 0;
}
```

---

## 作者：Alan_Zhao (赞：2)

**2021/7/23 Update：修了 LaTeX。**

使用 Trie 树：

- 处理 A 操作的时候就直接补全 $32$ 位，然后只添加前 $L$ 位就可以了，注意要在添加完之后用数组记录编号。

- 处理 Q 操作会稍微麻烦一点，需要在 Trie 树上匹配，并把匹配到的子串全部加到一个 vector 里，其中用一个 pair 来记录匹配到的字串的编号和匹配长度。最后以字串编号为关键字对 vector 进行排序，然后跑一遍取最大值，更新最大值的时候 `++ans` 即可（如果不在 $[a,b]$ 范围内，就只更新最大值，不更新 ans）。

最后附上 AC 代码和一些讲解（使用了 C++11 的一些语法）。

```cpp
#include <cstdio>
#include <string>
#include <algorithm>
#include <vector>
#include <utility>
using namespace std;
int m;
int trie[3200005][2],cnt=0,en[3200005]; //en数组记录以这个节点为结束的字串编号
string f(int x) //将x转为8位2进制
{
	string res;
	while(x){
		res+=x%2+'0';
		x>>=1;
	}
	reverse(res.begin(),res.end());
	if(res.length()<8){
		res.insert(0,string(8-res.length(),'0'));
	}
	return res;
}
void insert(int a,int b,int c,int d,int len,int i)//插入，i表示编号
{
	string x((f(a)+f(b)+f(c)+f(d)).substr(0,len));
	int rt=0;
	for(char c:x){
		if(!trie[rt][c-'0']){
			trie[rt][c-'0']=++cnt;
		}
		rt=trie[rt][c-'0'];
	}
	en[rt]=i;
}
int query(int l,int r,string x) //查找
{
	int rt=0,tot=0;
	vector<pair<int,int>> vec;
	for(char i:x){
		++tot;
		if(!trie[rt][i-'0']){
			break;
		}
		rt=trie[rt][i-'0'];
		if(en[rt]){
			vec.push_back(make_pair(en[rt],tot));
		}
	}
	sort(vec.begin(),vec.end(),[](pair<int,int> p1,pair<int,int> p2){
		return p1.first<p2.first;
	});
	int _max=0,ans=0;
	for(pair<int,int> i:vec){
		if(i.first>=l&&i.first<=r&&_max<=i.second){
			_max=i.second;
			++ans;
		}
		else if(_max<=i.second) _max=i.second;
	}
	return ans;
}
int main()
{
	scanf("%d",&m);
	char _c;int a,b,c,d,e,l,r;
	int tot=0; //tot记录节点编号
	for(int i=1;i<=m;++i){
		_c=getchar();
		while(_c!='A'&&_c!='Q') _c=getchar();
		if(_c=='A'){
			scanf("%d.%d.%d.%d/%d",&a,&b,&c,&d,&e); //scanf的神奇操作
			insert(a,b,c,d,e,++tot);
		}
		else{
			scanf("%d.%d.%d.%d %d %d",&a,&b,&c,&d,&l,&r);
			string s(f(a)+f(b)+f(c)+f(d));
			printf("%d\n",query(l,r,s));
		}
	}
	return 0;
}

```
注：这个代码需要吸氧才能过得去，但时间复杂度应该是正确的。

---

## 作者：zplqwq (赞：1)

首先，我们需要明白一个道理，由于匹配的时候只匹配掩码的长度，设为 $l$ 。那么我们只插入前 $l$ 个字符即可。

其次我们考虑如何求出在 $l$ 和 $r$ 之间求出连接个数。

在考虑具体问题之前，有一点很重要

$ans(r,l)=ans(1,r)-ans(1,l-1)$
 
 根据这个性质，我们分别求出 $ans(1,r)$ 与 $ans(1,l-1)$ 即可。

我们 trie 最开始标记的是当前字符是否出现过。然而在这个题目背景下，我们考虑标记插入的时间。

那么，我们现在知道标记的时间，该如何求出连接个数呢。

举个例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/d8uf8bf0.png)

这种情况下是显然的，这两个节点就是我标记好的节点，直接计算中间的节点数即可。

但现在有一个问题，如果情况变成这种该怎么办呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/07at9yhu.png)

我们要求 $l$ 和 $c$ 之间的连接个数。

我们发现，$c$ 是废的。因此我们在这种情况下就不考虑 $r$ 节点了。

看到这，我们发现，这个结构类似于单调栈。

即，当我后插入的节点比前面的节点小时，那么前面的节点就不要了。

因此我们考虑用一个单调栈来维护。

每次把比当前时间靠后的节点弹出去，所剩下的元素个数就是我们要求的答案。




---

## 作者：cryozwq (赞：1)

很没意思的一道题。。主要难度是读题。。

所以这里先给一个简要题意：

所有的 IP 地址都可以表示为 $a.b.c.d$ 的形式且四个数均小于 $256$，首先把它转成一个 $32$ 位二进制串，每 $8$ 位表示一个变量的二进制形式。每个 IP 地址有一个掩码长度 $L_i$，表示需要匹配这个 IP 地址前 $L_i$ 位。

现在需要在线解决两种操作：

- 添加一个 IP 串
- 查询给定 IP 地址在与 $[L,R]$ 中的 IP 串匹配过程中变化了几次~~匹配过程请自行读题~~

然后非常套路的我们把 $ans(L,R)$ 拆成 $ans-(1,R)-ans(1,L-1)$ 。

当你读过了匹配过程后，你会发现这个东西近似于单调栈，当一个 IP 地址之前没有比它匹配位数大的 IP 地址的时候，这个 IP 地址就会把答案加 $1$。

就会发现我们可以用 trie 找出 $[1,x]$ 区间中有哪些 IP 地址。

然后直接模拟上面说的即可。

代码（写的很丑还巨慢）：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int long long
const int maxn=1e6;
int G[maxn][2],bc,val[maxn],pas[maxn];
int Id=0;
int n=0,jp=0;
ll bit[32],a[4],b[4];
ll ans,l,r;
int tot=0;
int NewNode(){ 
	tot++;
	memset(G[tot],0,sizeof(G[tot]));
	return tot;
} 
int ttt=0;
void insert(int jp){
	for(int i=0;i<4;i++)
	a[i]=b[i];
	int u=1;
	int id=-1;
	for(int i=1;i<=jp;i++){
		int ch=0;
		int xid=8-(i-1)%8-1;
		if(i%8==1){
			id++;
		}
		if(a[id]>=bit[xid]){
			a[id]-=bit[xid];
			ch=1;
		}
		if(G[u][ch]==0){
			G[u][ch]=NewNode();
		}
		u=G[u][ch]; 
	} 
	val[u]=Id;
}
struct node{
	int w,id;
}v[maxn];
int vt=0;
bool cmp(node a,node b){
	return a.id<b.id; 
}
int find(int jp,int w){
	for(int i=0;i<4;i++)
	a[i]=b[i];
	vt=0;
	int u=1;
	int id=-1;
	for(int i=1;i<=jp;i++){
		int ch=0;
		int xid=8-(i-1)%8-1;
		if(i%8==1){
			id++;
		} 
		if(a[id]>=bit[xid]){
			a[id]-=bit[xid];
			ch=1;
		}
		if(G[u][ch]==0){
			break ;
		}
		u=G[u][ch]; 
		if(val[u]<=w&&val[u]){
			v[++vt]=(node){i,val[u]};	
		} 
	}
	sort(v+1,v+vt+1,cmp);
	ll maxm=0,Cnt=0;
	for(int i=1;i<=vt;i++){
		if(v[i].w>maxm){
			Cnt++;
		}
		maxm=max(maxm,v[i].w);
	}
	return Cnt;
}
char op;
signed main(){
	NewNode();
	bit[0]=1;
	for(int i=1;i<=31;i++){
		bit[i]=bit[i-1]*2ll;
	}
	bc=8;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		op=' ';
		while(op!='A'&&op!='Q')
		op=getchar();
		if(op=='A'){
			scanf("%d.%d.%d.%d/%d",&b[0],&b[1],&b[2],&b[3],&jp); 
			Id++;
			insert(jp);
		}
		else{
			scanf("%d.%d.%d.%d %d %d",&b[0],&b[1],&b[2],&b[3],&l,&r);
			printf("%lld\n",find(32,r)-find(32,l-1));
		}
	}
	return 0;
}
```

---

## 作者：Unnamed114514 (赞：1)

下文记 $B$ 为二进制位数，即 $32$。

### Subtask 1

$M\le10^3$

直接暴力枚举 $l,r$，然后每次判断是否更新即可。时间复杂度 $O(BM^2)$。

### Subtask 2

$M\le10^5$

时间复杂度为 $O(nB^2\log n)$ 的做法，最早的时候居然被看成了 $O(nB\log n)$。

进入正题，首先我们把 $[l,r]$ 差分成为 $[1,r]-[1,l-1]$，然后我们转化成了前缀的查询。

然后我们枚举长度 $D$，然后就可以二分找到第一次变成 $D$ 的位置 $pos_D$。

那么我们最终显然需要的是一个 $pos$ 的上升序列，单调栈维护即可。

对于二分的 `check`，我们即判断插入了 $[1,mid]$ 之后是否存在一个长度为 $D$ 的匹配。

首先我们用 Trie 可以 $O(B)$ 判断一次插入完成后是否存在长度为 $D$ 的匹配，那么对于动态查询插入数量，发现空间限制比较大，我们就直接上可持久化 Trie 即可。

时间复杂度 $O(MB^2\log M)$。

### Subtask 3

$M\le 10^6$

首先查询数量的 $O(M)$ 显然不能省，然后我们来看看这 $3$ 个 $\log M$ 级的数：分别为匹配的长度，Trie 遍历，和二分最早的位置。

那么我们可以考虑消去第 $3$ 个 $\log$，容易发现的是，对于同一次查询，字符串没变，所以可持久化之前到达的点应该是不变的。

因此，我们在 Trie 上再维护个信息，表示的是以这个点为终点，第一次到达它的版本。

然后我们只需要查询 $r$ 这个版本下第一次到达 $s_r$ 的版本，这个值就是 $pos_D$。

时间复杂度 $O(MB\log M)$，空间复杂度 $O(MB)$。

---

## 作者：zzw4257 (赞：1)

> 首先理解一下题面，给定两种操作,
>
> - ```A d/L```插入一个串$d$(地址方式给出)，要求其他串与之匹配只匹配前$L$位
> - ``Q d l r``给定一个串$d$，按照时间顺序在第$i|i\in[l,r]$次插入的串中匹配，每次只与比之前(本次$Q$操作内)最大匹配长度更大的串匹配，求匹配次数

发现$Q$操作过于类似单调栈

首先我们匹配，长度顺序**从小到大**取出匹配节点然后转成**从大到小(也就是说最靠前的应后选)**,然后考虑每次只取时间更小节点

可以用两个变量代替单调栈

```cpp
inline int Query(uint v,int l,int r){
	int i,w,x=0,minn=INF,ans=0;vector<int>g;g.clear();
	for(i=31;~i;--i){
		w=((v>>i)&1);if(!son[x][w])break;
		x=son[x][w];if(pos[x])g.push_back(pos[x]);
	}
	for(i=g.size()-1;~i;--i){
		x=g[i];if(x<minn||i==g.size()-1)ans+=(x>=l&&x<=r);
		minn=min(minn,x);
	}
	return ans;
}
```







---

## 作者：lyhqwq (赞：0)

# Solution

字符串匹配问题，遇事不决上 trie。

我们建一颗 trie，把每个 ip 地址存成一个 unsigned int，插入进 trie 里。

接下来考虑查询怎么做

对于 $[a,b]$ 的答案，我们可以用差分思想，将其拆分成 $[1,b]$ 的答案，减去 $[1,a-1]$ 的答案，现在问题就转变为如何求 $[1,x]$ 的答案。

我们考虑将每一个插入的 ip 地址在结束的结点打上标记。

每次查询时，将查询的 ip 地址在 trie 树上从上往下的走，假设我们先遇到了一个标记 $u$，后遇到了一个标记 $v$。

那么显然 $v$ 对应的串显然比 $u$ 对应的串和查询的 ip 地址匹配的长度更长，那么如果 $v$ 对应的串比 $u$ 对应的串先插入，那么 $u$ 对应的串就不会成为答案。

这样我们就可以用一个单调栈或单调队列维护在 trie 上走遇到的标记。最后的答案就是栈或队列里的元素个数。

# Code
```cpp
#include<bits/stdc++.h>
#define uint unsigned int
using namespace std;
const int N=1000005;
int n;
namespace _01trie{
	struct node{
		int ch[2];
		int end;
	}tree[N<<5];
	int cnt=1,id=0;
	void insert(uint val,int len){
		int u=1;
		for(int i=31;32-i<=len;i--){
			int p=((val>>i)&1);
			if(!tree[u].ch[p]) tree[u].ch[p]=++cnt;
			u=tree[u].ch[p];
		}
		tree[u].end=++id;
	}
	int query(uint val,int x){
		stack<int> s;
		int u=1;
		for(int i=31;i>=0;i--){
			int p=((val>>i)&1);
			if(tree[u].ch[p]) u=tree[u].ch[p];
			else break;
			if(tree[u].end&&tree[u].end<=x){
				while(!s.empty()&&s.top()>tree[u].end) s.pop();
				s.push(tree[u].end);
			}
		}
		return s.size();
	}
}
using namespace _01trie;
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		char op;
		scanf(" %c",&op);
		if(op=='A'){
			int a,b,c,d,len;
			scanf("%d.%d.%d.%d/%d",&a,&b,&c,&d,&len);
			uint val=(a<<24)+(b<<16)+(c<<8)+d;
			insert(val,len);
		}
		else{
			int a,b,c,d,l,r;
			scanf("%d.%d.%d.%d%d%d",&a,&b,&c,&d,&l,&r);
			uint val=(a<<24)+(b<<16)+(c<<8)+d;
			printf("%d\n",query(val,r)-query(val,l-1));
		}
	}
	return 0;
}

```


---

## 作者：spdarkle (赞：0)



容易发现每个表项只能用到前 $L_i$ 位，所以就把前 $L_i$ 位插入字典树即可。

对于字符串的处理**很恶心**，但问题不大，大家调试一会都可以对

然后再次观察查询问题，所谓比较，其实就是在问：将 $a\sim b$ 个插入的表项依次比较

设当前最大匹配长度是 $k$，求 $k$ 被更新的次数。

如果只考虑 $1\sim b$ 个项，则就等价于将这个串在字典树查询路径上遇到的有 $ed$ 的标记个数，但同时需要递增的时间戳

但需要考虑 $a\sim b$ 项，咋办？对每个结尾节点标记 $tim$ 为其表项序号。然后求出整个紫薯的最小表项与最大表项。

在 trie 查询的时候，设当前的匹配次数为 $k$，访问到的符合条件的时间戳依次为 $w_1,w_2……w_k$，则对于一个新遇到的有标记的节点：

1. 若其时间戳小于 $a$ 或者大于 $b$ 直接不管
2. 否则在 $w$ 序列中查找其前驱，并插入到其前驱之后，将后面所有点叉掉。

考虑到 $L_{\max}=32$，所以复杂度是 $O(M\log M\log V)$。

有点悬，考虑离线操作？~~看题解才发现可以用单调栈~~

将所有询问按照 $b$ 排序，然后依次插入，此时我们就只需要考虑小于 $a$ 弃掉的条件了。

这样问题就变为：

给定若干个 01 字符串，将其依次插入，将第 $a\sim n$ 项与串 $S$ 依次进行比较，设 $k$ 为当前比较的最长长度，求出 $k$ 被更新的次数。被更新的要求是这个串是 $S$ 的子串且长度大于原来的 $k$。

子串问题仍然考虑使用字典树解决。这样可以满足从上到下子串长度不断扩大的要求。

也许可以对这个过程进行递归。“递”的过程传标记，在“归”的过程更新答案。

归的过程可以统计当前的最小值（时间，如果在回去的过程遇到值比他小，则更新最小值和次数，如果比他大，则不管。

然后注意到这个操作需要存在小于 $a$ 的操作的时候，就会导致它优于以后查到的所有操作，所以就直接 `break`。否则——**就样例过，全WA**

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
#define N 1003400
struct node{
	int a,b,id,len;
	char c[34];
	bool operator<(node k){
		return b<k.b;
	}
}ask[N];
struct In{
	int len;
	char c[34];
}in[N];
int t[N*40][2],ed[N*40],cnt=1,tim[N*40],tot1,tot2,f[N*40],mn,res,n,ans[N];
char c[34];
char d[34];
void insert(int k,char c[],int id){
	int p=1;
	for(int i=1;i<=k;i++){
		int s=c[i]-'0';
		if(!t[p][s]){
			++cnt;
			t[p][s]=cnt;
			f[t[p][s]]=p;
		}
		p=t[p][s];
	}
	tim[p]=id,ed[p]=1;
}
int find(int k,char c[],int a){
	int mn=1e9,res=0;
	int p=1;
	for(int i=1;i<=k;i++){
		int s=c[i]-'0';
		if(!t[p][s])break;
		p=t[p][s];
	}
	int sb=p;
	while(sb>1){
		while(!ed[sb])sb=f[sb];
		int k=sb;sb=f[sb];
		if(tim[k]<a)break;
		if(tim[k]>mn)continue;
		res++;mn=tim[k];
	}
	return res;
}
void get(int val,char c[],int &l){
	int num[10],cnt=0;memset(num,0,sizeof num);
	while(val){
		num[cnt]=val&1;
		val>>=1,cnt++;
	}
	reverse(num,num+8);
	int k=l;
	while(l-k<8){
		++l;
		c[l]=num[l-k-1]+'0';
	}
}
void init(){
	cin>>n;
	for(int i=1;i<=n;i++){
		char s;
		cin>>s;
		if(s=='A'){
			cin>>c+1;++tot1;
			int id=0,l=0,len=strlen(c+1);
			in[tot1].len=0;
			for(int i=1;i<=4;i++){
				++id;
				int k=0;
				while('0'<=c[id]&&'9'>=c[id]){
					k=k*10+(c[id]-'0');
					id++;
				}
				get(k,d,l);
			}
			++id;
			for(int i=id;i<=len;i++)in[tot1].len=in[tot1].len*10+(c[i]-'0');
			for(int i=1;i<=in[tot1].len;i++)in[tot1].c[i]=d[i];
		}
		else {
			cin>>c+1;++tot2;
			cin>>ask[tot2].a>>ask[tot2].b;
			ask[tot2].id=tot2;
			int id=0,l=0,len=strlen(c+1);
			for(int i=1;i<=4;i++){
				++id;
				int k=0;
				while('0'<=c[id]&&'9'>=c[id]){
					k=k*10+(c[id]-'0');
					id++;
				}
				get(k,d,l);
			}
			for(int i=1;i<=l;i++)ask[tot2].c[i]=d[i];
			ask[tot2].len=l;
		}
	}
	ed[1]=1;
	tim[1]=0;
	sort(ask+1,ask+tot2+1);
}
void solve(){
	int r=0;
	for(int i=1;i<=tot2;i++){
		int k=ask[i].b;
		while(r<ask[i].b&&r<tot1){
			++r;
			insert(in[r].len,in[r].c,r);
		}
		ans[ask[i].id]=find(ask[i].len,ask[i].c,ask[i].a);
	}
	for(int i=1;i<=tot2;i++){
		cout<<ans[i]<<"\n";
	}
}
int main(){
	ios::sync_with_stdio(false);
	init();
	solve();
	return 0;
}
```



---

## 作者：LinkWish (赞：0)

看到题解区没有用优先队列的，那我就来一发。
## 审题
一个目的 IP 地址的匹配是将各位转至二进制后能够在表内匹配最多位的那个地址。

给出两种操作，一个是往表内添加一个地址，一个是询问一段时间内某目的 IP 地址的匹配的变化次数。

这题我首先想到了字典树，将所有添加进来的 IP 地址存入其中，方便后续查询。

往表内添加一个地址时，我们只添加它的掩码长度那么多位，因为根据题意，它匹配那么多就不匹配了，不管后面是不是匹配的。

题目提示我们：对于一次查询的一种理解方式是：无视其它所有查询操作，只看添加操作。先清空路由表，然后执行第 $1$ 到 $a-1$ 次添加操作。之后再统计第 $a$ 到 $b$ 次添加操作过程中匹配改变的次数。

既然题目给出了做法，那就这样做呗！

## 思路
对于添加操作：

每添加进来一个 IP 地址，就将其转为二进制，注意要补全32位，然后将其掩码长度位存入字典树中。

对于查询操作：

对于区间 $[a,b]$ ，首先进入字典树中查找 $[1,a-1]$ 区间内所有可以与目的 IP 地址匹配的串，并将它们加入一个优先队列中，并以加入进字典树的时间为第一关键字升序排列，以该串匹配的长度为第二关键字升序排列。然后我们开始一个一个取出队内元素，并且找到 $[1,a-1]$ 区间内与目的 IP 地址的最大匹配长度。

现在我们进入字典树中查找 $[a,b]$ 区间内所有可以与目的 IP 地址匹配的串，并将它们以与刚刚相同的方式加入一个单调队列中。我们再次一个一个取出队内元素，并且与刚刚找到的最大长度比较，如果大于最大长度，就更新最大长度为当前长度，并且贡献一次答案。当队列空时，答案就出来了。

## 时间复杂度分析

对于每一次插入，我们用字典树只会用最多 $O(32)$ (最大串长）。

对于每一次查询，我们使用了优先队列，但是进入字典树查询时会添加 $[1,b]$ 区间内所有的元素，所以是 $O(b \log{b})$

由于 STL 中的 priority_queue 常数较大，我们必须使用 O2 优化才可以通过此题。此算法在 O2 优化下表现不错，最大点 566ms/2s 。

## 代码
```cpp
//Linkwish's code
#include<bits/stdc++.h>
using namespace std;
int n,tot,cnt,ans,p1,st,ed,is[1000010];
int trie[1000010][2],outp[1000010],p[40];
inline int rd(){
	int x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	return x;
}
struct pnt{
	int t,dep;
	bool operator < (const pnt k)const{
		return t>k.t;
	}
};
priority_queue<pnt> q;
inline void insert(){
	int now=0;
	for(int i=0;i<st;i++){
		if(!trie[now][p[i]])trie[now][p[i]]=++cnt;
		now=trie[now][p[i]];
	}
	is[now]=++p1;
}
inline void findd(){
	int now=0,res=0;
	for(int i=0;i<32;++i){
		if(!trie[now][p[i]])break;
		now=trie[now][p[i]],res++;
		if(is[now]&&is[now]>=st&&is[now]<=ed)q.push((pnt){is[now],res});
	}
}
inline void input(){
	for(int j=0,k;j<4;++j){
		k=rd();
		for(int v=7;v>=0;v--){
			p[j*8+v]=k%2;
			k>>=1;
		}
	}
}
int main(){
	scanf("%d",&n);
	char op;
	for(int i=1,k,ans,y;i<=n;++i){
		op=getchar();
		while(op<'A'||op>'Z')op=getchar();
		if(op=='A'){
			input();
			st=rd();
			insert();
		}
		else{
			input();
			st=1,ed=rd()-1,k=ans=0;
			findd();
			while(!q.empty()){
				y=q.top().dep;
				if(y>k){
					k=y;
				}
				q.pop();
			}
			st=ed+1,ed=rd();
			findd();
			while(!q.empty()){
				y=q.top().dep;
				if(y>k){
					k=y;
					ans++;
				}
				q.pop();
			}
			printf("%d\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：EricWan (赞：0)

~~这题题解还没满，呵呵。~~

~~昨天刚学 OI~~，调了两天了，细节较多（对我），开始想拿 `set` 水过，结果问候我的是 WA 和 TLE，只好写 01Trie。

最后竟然一遍过！[优化后版本。](https://www.luogu.com.cn/record/118976734)

## 进入正题

认 ~~tou~~ 真 ~~kan~~ 思 ~~ti~~ 考 ~~jie~~ 后，我们可以知道这题需要维护一个 01Trie，每一个节点需要记录三个值，分别是它的 `0` 儿子、它的 `1` 儿子和它是第几个插入的（有可能第三个元素没有）。

对于查询操作，我们在遍历的同时，需要维护路径上会修改匹配的表项的插入时间，这些表项应该满足掩码递增，时间递增，在掩码相同时，只记录时间早的。我们就想到了单调栈，因为字典树上是顺序查找的，所以我们在单调栈里面维护插入时间就可以了（最后看单调栈内存的所有时间中有几个在 $[a,b]$ 之间），具体操作请看代码：

`to[i][0/1]` 为 01Trie 伪指针；

`mp[i]` 为它的插入时间；

`st` 是维护的单调栈；

`m, c, _a, _b, _c, _d, a, b, k` 为输入数据；

`cnt` 协助 01Trie 的尾伪指针；

`x` 是在字典树上查找用的临时变量；

`I` 记录已经插入的表项数；

`Str` 用来通过 `getline(cin,Str);` 删除行末字符，并开始读下一行；

`t` 给出的数据的 `32` 位表示。

```cpp
#include <string>
#include <iostream>
#include <cstdio>
using namespace std;
unsigned int to[40000005][2], mp[40000005], st[100];
signed main() {
	register unsigned int m;
	register char c;
	register unsigned int _a, _b, _c, _d, a, b, k, cnt = 0, x, I = 0;
	scanf("%d",&m); //读入 m
	register string Str; 
	getline(cin,Str); //删除行末字符
    while (m--) {
    	scanf("%c", &c);
    	if (c ^ 'Q') { //插入（巧用位运算）
        	I++; //已经插入的表项数++
        	scanf("%d.%d.%d.%d/%d", &_a, &_b, &_c, &_d, &k); //输入数据
        	register const unsigned int t = (_a << 24) | (_b << 16) | (_c << 8) | _d; //预处理 t，使用位运算
        	x = 0; //伪指针移动到总根
        	for (register unsigned int i = 1; i <= k; i++) { //循环以插入
            	if (t & (1 << 32 - i)) { //位运算判断是否走 1
                	if (!to[x][1]) { //如果后面没有路了，那就创建新节点（世界上本没有路，有人要走，便成了路）
                    	cnt++;
                    	to[x][1] = cnt;
                    }
                	x = to[x][1]; //伪指针转移至下一个节点
                } else {
                	if (!to[x][0]) { //如果后面没有路了，那就创建新节点
                    	cnt++;
                    	to[x][0] = cnt;
                    }
                	x = to[x][0]; //伪指针转移至下一个节点
                }
            }
        	if (mp[x] == 0) mp[x] = I;
        } else { //询问
        	scanf("%d.%d.%d.%d %d %d", &_a, &_b, &_c, &_d, &a, &b); //输入数据
        	register const unsigned int t = (_a << 24) | (_b << 16) | (_c << 8) | _d; //预处理 t，使用位运
        	x = 0; //伪指针移动到总根
        	st[0] = 0; //单调栈清空，虽然我很喜欢 STL 但认为栈自己写方便，代码少而可随时全便利，栈空时也不会报错
        	for (register unsigned int i = 1; i ^ 33; i++) { //循环以查找（这里巧用位运算 "i ^ 33" = "i <= 32"）
            	if (t & (1 << 32 - i)) { //位运算判断是否走 1
                	if (!to[x][1]) break; //如果后面没有路了，因为是查询操作，继续查找没有意义，直接退出
                	x = to[x][1]; //伪指针转移至下一个节点
                	if (mp[x]) { //如果恰好有合适的掩码
                    	while (st[st[0]] >= mp[x]) st[0]--; //维护单调栈
                    	st[++st[0]] = mp[x]; //插入 
                    }
                } else {
                	if (!to[x][0]) break; //如果后面没有路了，因为是查询操作，继续查找没有意义，直接退出
                	x = to[x][0]; //伪指针转移至下一个节点
                	if (mp[x]) { //如果恰好有合适的掩码
                    	while (st[st[0]] >= mp[x]) st[0]--; //维护单调栈
                    	st[++st[0]] = mp[x]; //插入
                    }
                }
            }
        	register unsigned int count = 0; //定义答案计数器
        	for (register unsigned int i = 1; i <= st[0]; i++) //枚举栈
            	if (st[i] >= a && st[i] <= b) //如果当前元素满足要求，具体什么是要求，看题解解释
                	count++; //答案增加
        	printf("%d\n",count); //输出答案
        }
    	getline(cin,Str); //删除行末字符
    }
	return 0;
}
```

↓ 既然看完了，为什么不点个赞！

---


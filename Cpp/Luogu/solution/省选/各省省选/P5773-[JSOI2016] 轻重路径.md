# [JSOI2016] 轻重路径

## 题目描述

JYY 最近学习了一种处理树形结构的高级技巧，叫「轻重路径剖分」。这种技术会将树中的边划分成轻边和重边。相连的重边会形成一些树上相离的路径。「轻重路径剖分」可以使得从树上任意一点走到根，都至多只会经过 $(\log N)$ 条不同的重路径。

如果你不了解轻重路径剖分，JYY 在这里简单介绍一下：对于一棵有根树中的任意一个点 $u$，我们用 $size(u)$ 表示其为根的子树中的点的数量。对于 $u$ 的所有孩子中，我们选出 $size$ 值最大的孩子 $v$，并将边 $(u,v)$ 设置成重边，$u$ 和其他孩子之间的边我们均设置为轻边。

为了简化问题，这里 JYY 仅考虑一棵 $N$ 个点的有根二叉树。这 $N$ 个点由 $1$ 到 $N$ 编号。并且如果 $u$ 存在两个 $size$ 值一样的孩子，则我们默认 $u$ 和其左孩子的连边为重边。

现在 JYY 希望执行额外 $Q$ 次删点操作，每次 JYY 会随机删掉一个当前二叉树的叶子节点，而你则需要动态的维护这棵树的轻重路径剖分。

为了方便输出，你只需要在每次操作后输出所有重边指向的点的编号之和即可。

如果删除一个点之后，存在一个点 $u$ 拥有两个 $size$ 值一样的孩子，则我们保持 $u$ 在该操作执行之前的重边划分。

## 说明/提示

对于 $30\%$ 的数据，满足 $N \le 1000$；

对于 $50\%$ 的数据，满足 $N \le 5 \times 10^4$；

对于全部数据，满足 $N \le 2 \times 10^5$。

## 样例 #1

### 输入

```
8
2 3
4 5
0 0
6 7
0 8
0 0
0 0
0 0
7
6 7 8 5 4 2 3
```

### 输出

```
20
21
15
7
6
2
3
0
```

# 题解

## 作者：zsq259 (赞：16)

## 题解 JSOI2013 轻重路径

### 题面

[luogu](https://www.luogu.com.cn/problem/P5773)

### 解析

设根节点为 $rt$.

一个点 $x$ 会由重儿子变为轻儿子的一个必要条件是 $size_{x}\leq \frac{size_{rt}}{2}$.

$size[x]$ 表示 $x$ 当前的子树大小,这个可以用树状数组维护.

于是考虑二分找到满足上面条件的 $size$ 最大的 $x$,判断它是否会变为轻儿子,另外如果它是被删掉的要特判.

然后将 $rt$ 设为 $x$,继续按上面的搞.

这样的操作不会超过 $log_{n}$ 次,因为每次 $size_{rt}$ 都会至少除以 $2$.

### code

```cpp
#include <iostream>
#include <stdio.h>
#include <cstring>
#define ll long long
#define filein(a) freopen(a,"r",stdin)
#define fileout(a) freopen(a,"w",stdout);
using namespace std;

inline int read(){
	int sum=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&c!=EOF){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9'&&c!=EOF){sum=sum*10+c-'0';c=getchar();}
	return sum*f;
}

const int N=2000005;
struct node{int s[2],sz,top,dep,fa,son,id;}a[N];
int n,t[N];ll sum;
int pla[N],tot;

inline void change(int x,int y){for(;x<=n;x+=x&-x) t[x]+=y;}
inline int query(int x){int y=0;for(;x;x-=x&-x) y+=t[x];return y;}

inline void dfs1(int x,int fa){
	a[x].fa=fa;a[x].dep=a[fa].dep+1;
	a[x].sz=1;
	for(int i=0;i<=1;i++){
		int k=a[x].s[i];
		if(!k) continue;
		dfs1(k,x);a[x].sz+=a[k].sz;
		if(a[k].sz>a[a[x].son].sz) a[x].son=k;
	}
}

inline void dfs2(int x,int top){
	a[x].top=top;pla[a[x].id=++tot]=x;
	if(!a[x].son) return ;
	dfs2(a[x].son,top);
	for(int i=0;i<=1;i++){
		int k=a[x].s[i];
		if(k&&k!=a[x].son) dfs2(k,k);
	}
}

inline int get(int x){
	if(!x) return 0;
	return query(a[x].id+a[x].sz-1)-query(a[x].id-1);
}

inline int find(int x,int d){
	while(a[a[x].top].dep>d) x=a[a[x].top].fa;
	return pla[a[x].id-(a[x].dep-d)];
}

inline int side(int x){return x==a[a[x].fa].s[1];}

int main(){
	n=read();
	for(int i=1;i<=n;i++)
		a[i].s[0]=read(),a[i].s[1]=read();
	dfs1(1,0);dfs2(1,1);
	for(int i=1;i<=n;i++) sum+=a[i].son;
	for(int i=1;i<=n;i++) change(i,1);
	printf("%lld\n",sum);
	int Q=read();
	while(Q--){
		int x=read(),rt=1;change(a[x].id,-1);
		while(1){
			int l=a[rt].dep+1,r=a[x].dep,ans=0;
			while(l<=r){
				int mid=(l+r)>>1;
				if(get(find(x,mid))<=get(rt)/2) ans=mid,r=mid-1;
				else l=mid+1;
			}
			if(!ans) break;
			int x1=find(x,ans),x2=a[a[x1].fa].s[side(x1)^1];
			if(a[a[x1].fa].son==x1){
				if(get(x1)+1==get(x2)) sum+=x2-x1,a[a[x1].fa].son=x2;
				else if(!get(x1)&&!(get(x2))) sum-=x1,a[a[x1].fa].son=0;
			}
			rt=x1;
		}
		printf("%lld\n",sum);
	}
	return 0;
}
```

---

## 作者：yzy1 (赞：9)

## Step 1. 询问离线

分析问题，发现我们删点的话不是很好维护每个点的轻重儿子，考虑把询问离线，然后反过来做。问题转化为：

> 给出一颗有根二叉树，每次给一个点加一个儿子，保证加出来的树还是一颗二叉树，每加一个点输出所有重儿子编号之和。

我们发现，每加一个儿子，设它的编号为 $s$，则只有 $1\leftrightarrow s$ 链的上的点的轻重儿子关系会变化，且$1\leftrightarrow s$ 链的上的点只会由轻儿子变成重儿子。由于轻重儿子的关系和子树大小有关，我们需要维护每个点的子树大小。可以发现，每加一个点 $s$，$1 \leftrightarrow s$ 链上所有点的子树大小都会 $+1$，使用树剖和线段树维护之。

## Step 2. 如何加点

每加入一个点时，一个很暴力的思路是：从这个点一直向上跳到根。每遇到一个点，如果这个点是它父亲的轻儿子，就判断加点后能不能成为重儿子，如果能就暴力修改，同时维护全局重儿子的编号之和。

可以发现，上述做法的复杂度为 $O(n)$，考虑优化。重链剖分有个很好的性质，一条链上的轻边数量是 $O(\log n)$ 级别的。考虑线段树维护同一条重链上的重边数量，然后一边向上跳重链一边二分第一个轻边位置即可。复杂度下降至 $O(\log^2 n)$。

## Step 3. 检查变化

考虑在 step 2 中如何检查一个点是否会从轻儿子变为重儿子，我们分为三种情况考虑：

- 若加完点后，左子树 $\rm size$ 大于右子树 $\rm size$，则左儿子为重儿子。
- 若加完点后，左子树 $\rm size$ 小于右子树 $\rm size$，则右儿子为重儿子。
- 若加完点后，左子树 $\rm size$ 等于右子树 $\rm size$。这时需要特别判断。由于题目中规定：存在一个点 $u$ 拥有两个 $\rm size$ 值一样的孩子，则我们保持 $u$ 在该操作执行之前的重边划分。我们需要知道下一次加儿子的操作是在左子树中还是右子树中，先被操作的那个子树对应的儿子就为重儿子。考虑记录 $\operatorname{vist}(i)$ 表示 $i$ 结点加入是在第几次操作，若该节点一开始就被加入则 $\operatorname{vist}(i)=+\infty$。问题转化为查询子树中最小的大于某值的元素是什么，可以求出 DFS 序后转化为序列上二维数点。

---

至此，我们以  $O(n\log^2 n)$ 的时间复杂度解决了这道题。

## 代码参考

```cpp
const int N = 1e6 + 9;
int n, s[N][2], dfn[N], tp[N], son[N], son1[N], sz[N], tim, dep[N], fa[N], m, rnk[N], a[N], b[N],
    hav[N], ed[N], vist[N];
ll ans;
vector<ll> Ans;

struct Seg {
  struct T {
    ll add, sum;
    int fl, mn;
  } d[N];

  inline void Add(ll x, int u, int l, int r) { d[u].add += x, d[u].sum += 1ll * (r - l + 1) * x; }
  inline void Up(int u) {
    d[u].sum = d[u << 1].sum + d[u << 1 | 1].sum;
    d[u].fl = d[u << 1].fl + d[u << 1 | 1].fl;
    d[u].mn = min(d[u << 1].mn, d[u << 1 | 1].mn);
  }
  inline void Down(int u, int l, int r) {
    if (d[u].add) {
      int mid = (l + r) >> 1;
      Add(d[u].add, u << 1, l, mid);
      Add(d[u].add, u << 1 | 1, mid + 1, r);
      d[u].add = 0;
    }
  }

  void Build(int u, int l, int r) {
    if (l == r)
      return d[u].mn = vist[rnk[l]], ed[l] = u, d[u].sum = b[rnk[l]], d[u].fl = hav[rnk[l]], void();
    int mid = (l + r) >> 1;
    Build(u << 1, l, mid);
    Build(u << 1 | 1, mid + 1, r);
    Up(u);
  }

  void Add(int L, int R, ll x, int u, int l, int r) {
    if (L <= l && r <= R) return Add(x, u, l, r);
    int mid = (l + r) >> 1;
    Down(u, l, r);
    if (L <= mid) Add(L, R, x, u << 1, l, mid);
    if (mid + 1 <= R) return Add(L, R, x, u << 1 | 1, mid + 1, r);
    Up(u);
  }

  void Cha(int p, int x, int u, int l, int r) {
    if (l == r) return d[u].fl = x, void();
    int mid = (l + r) >> 1;
    Down(u, l, r);
    if (p <= mid)
      Cha(p, x, u << 1, l, mid);
    else
      Cha(p, x, u << 1 | 1, mid + 1, r);
    Up(u);
  }

  void ChaMn(int p, int x, int u, int l, int r) {
    if (l == r) return d[u].mn = x, void();
    int mid = (l + r) >> 1;
    Down(u, l, r);
    if (p <= mid)
      ChaMn(p, x, u << 1, l, mid);
    else
      ChaMn(p, x, u << 1 | 1, mid + 1, r);
    Up(u);
  }

  ll Ask(int p, int u, int l, int r) {
    if (l == r) return d[u].sum;
    int mid = (l + r) >> 1;
    Down(u, l, r);
    if (p <= mid) return Ask(p, u << 1, l, mid);
    return Ask(p, u << 1 | 1, mid + 1, r);
  }

  int Mn(int L, int R, int u, int l, int r) {
    if (L <= l && r <= R) return d[u].mn;
    int mid = (l + r) >> 1;
    Down(u, l, r);
    if (R <= mid) return Mn(L, R, u << 1, l, mid);
    if (mid + 1 <= L) return Mn(L, R, u << 1 | 1, mid + 1, r);
    return min(Mn(L, R, u << 1, l, mid), Mn(L, R, u << 1 | 1, mid + 1, r));
  }

  int ErFen(int L, int R, int u, int l, int r) {
    int mid = (l + r) >> 1;
    if (d[u].fl == r - l + 1) return -1;
    if (l == r) return l;
    Down(u, l, r);
    if (L <= l && r <= R) {
      int rsum = d[u << 1 | 1].fl;
      if (rsum != r - mid) return ErFen(L, R, u << 1 | 1, mid + 1, r);
      return ErFen(L, R, u << 1, l, mid);
    }
    if (R <= mid) return ErFen(L, R, u << 1, l, mid);
    if (mid + 1 <= L) return ErFen(L, R, u << 1 | 1, mid + 1, r);
    int res = ErFen(L, R, u << 1 | 1, mid + 1, r);
    if (res != -1) return res;
    return ErFen(L, R, u << 1, l, mid);
  }
} seg;

void Dfs1(int f) {
  dep[f] = dep[fa[f]] + 1, sz[f] = 1;
  rep (i, 0, 1) {
    int t = s[f][i];
    if (!t) continue;
    fa[t] = f, Dfs1(t), sz[f] += sz[t], b[f] += b[t];
    if (sz[t] > sz[son[f]]) son[f] = t;
    if (b[t] > b[son1[f]]) son1[f] = t;
  }
  if (son1[f]) hav[son1[f]] = 1, ans += son1[f];
}

void Dfs2(int f) {
  rnk[dfn[f] = ++tim] = f;
  if (!son[f]) return;
  tp[son[f]] = tp[f], Dfs2(son[f]);
  rep (i, 0, 1) {
    int t = s[f][i];
    if (!t) continue;
    if (t == son[f]) continue;
    tp[t] = t, Dfs2(t);
  }
}

inline void Add(int f, int t, ll x) {
  while (tp[f] != tp[t]) {
    if (dep[tp[f]] > dep[tp[t]]) swap(f, t);
    seg.Add(dfn[tp[t]], dfn[t], x, 1, 1, n);
    t = fa[tp[t]];
  }
  if (dfn[f] > dfn[t]) swap(f, t);
  seg.Add(dfn[f], dfn[t], x, 1, 1, n);
}

inline int Fan(int x, int y) { return y ^ s[x][0] ^ s[x][1]; }

inline void Jump(int f) {
  while (f) {
    int x = dfn[f];
    while (dfn[tp[f]] <= x) {
      x = seg.ErFen(dfn[tp[f]], x, 1, 1, n);
      if (x == -1) break;
      int pa = fa[rnk[x]], ls = seg.Ask(dfn[s[pa][0]], 1, 1, n),
          rs = seg.Ask(dfn[s[pa][1]], 1, 1, n);
      ans -= seg.d[ed[dfn[s[pa][0]]]].fl * s[pa][0] + seg.d[ed[dfn[s[pa][1]]]].fl * s[pa][1];
      if (ls > rs ||
          (ls == rs && seg.Mn(dfn[s[pa][0]], dfn[s[pa][0]] + sz[s[pa][0]] - 1, 1, 1, n) <=
                           seg.Mn(dfn[s[pa][1]], dfn[s[pa][1]] + sz[s[pa][1]] - 1, 1, 1, n)))
        ans += s[pa][0], seg.Cha(dfn[s[pa][0]], 1, 1, 1, n), seg.Cha(dfn[s[pa][1]], 0, 1, 1, n);
      else
        ans += s[pa][1], seg.Cha(dfn[s[pa][0]], 0, 1, 1, n), seg.Cha(dfn[s[pa][1]], 1, 1, 1, n);
      --x;
    }
    f = fa[tp[f]];
  }
}

inline void Work(int x) {
  seg.ChaMn(dfn[x], 0x3f3f3f3f, 1, 1, n);
  Add(1, x, 1);
  Jump(fa[x]);
  b[x] = 1;
  if (b[Fan(fa[x], x)]) {
    int pa = fa[x], ls = seg.Ask(dfn[s[pa][0]], 1, 1, n), rs = seg.Ask(dfn[s[pa][1]], 1, 1, n);
    ans -= seg.d[ed[dfn[s[pa][0]]]].fl * s[pa][0] + seg.d[ed[dfn[s[pa][1]]]].fl * s[pa][1];
    if (ls > rs ||
        (ls == rs && seg.Mn(dfn[s[pa][0]], dfn[s[pa][0]] + sz[s[pa][0]] - 1, 1, 1, n) <=
                         seg.Mn(dfn[s[pa][1]], dfn[s[pa][1]] + sz[s[pa][1]] - 1, 1, 1, n)))
      ans += s[pa][0], seg.Cha(dfn[s[pa][0]], 1, 1, 1, n), seg.Cha(dfn[s[pa][1]], 0, 1, 1, n);
    else
      ans += s[pa][1], seg.Cha(dfn[s[pa][0]], 0, 1, 1, n), seg.Cha(dfn[s[pa][1]], 1, 1, 1, n);
  } else
    ans += x, seg.Cha(dfn[x], 1, 1, 1, n);
}

signed main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n;
  re (i, n)
    cin >> s[i][0] >> s[i][1], b[i] = 1;
  cin >> m;
  memset(vist, 0x3f, sizeof vist);
  re (i, m)
    cin >> a[i], b[a[i]] = 0;
  reverse(a + 1, a + m + 1);
  re (i, m)
    vist[a[i]] = i;
  hav[1] = 1, Dfs1(1), tp[1] = 1, Dfs2(1);
  seg.Build(1, 1, n);
  Ans.push_back(ans);
  re (i, m)
    Work(a[i]), Ans.push_back(ans);
  reverse(Ans.begin(), Ans.end());
  each (x, Ans)
    cout << x << '\n';
  return 0;
}
```



---

## 作者：_zdc_ (赞：7)

定义 $dif_i=size_{L_i}-size_{R_i}$。

注意到每次删叶子对 $dif$ 的影响是 $1$ 或 $-1$，所以删 $B$ 次叶子后只有满足 $|dif_i| \le B$ 的点 $i$ 的重儿子可能改变。称这种点为关键点。

删掉 $x$ 时，考虑找 $x$ 的祖先中所有关键点并修改 $dif$。这一部分是 $O(QB)$ 的。

因为每 $B$ 次操作后需要 $O(N)$ 重新算 $dif$ 等信息，所以这一部分是 $O(\dfrac{NQ}{B})$ 的。

取 $B=\sqrt N$，时间复杂度 $O(Q\sqrt N)$。实测取 $B=3500$ 最快。

```cpp
#include <bits/stdc++.h>
#define All(x, l, r) &x[l], &x[r + 1]
#define ALL(x) begin(x), end(x)
using namespace std;
void file(){
  freopen("1.in", "r", stdin);
  freopen("1.out", "w", stdout);
}
using ll = long long;
const int nMax = 2e5 + 5, Lim = 3503;
int n, q;
array<int, nMax> p, sz, l, r, f, fa, hvy, dif;
array<bool, nMax> lr;
void reb(){
  for(int i = n; i; i--) sz[i] = sz[l[i]] + sz[r[i]] + 1;
  for(int i = 1; i <= n; i++){
    int x = fa[i];
    if(abs(dif[i] = sz[l[i]] - sz[r[i]]) <= Lim) x = i;
    fa[l[i]] = fa[r[i]] = x;
    if(x == i){ lr[l[i]] = 0; lr[r[i]] = 1; }
    else lr[l[i]] = lr[r[i]] = lr[i];
  }
}
int main(){
  // file();
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n;
  for(int i = 1; i <= n; i++){
    cin >> l[i] >> r[i];
    fa[l[i]] = fa[r[i]] = i;
  }
  f = fa; cin >> q;
  for(int i = 1; i <= q; i++) cin >> p[i];
  for(int i = n; i; i--){
    sz[i] = sz[l[i]] + sz[r[i]] + 1;
    hvy[i] = (sz[l[i]] >= sz[r[i]]) ? l[i] : r[i];
  }
  ll res = accumulate(All(hvy, 1, n), 0ll);
  cout << res << "\n";
  for(int i = 1; i <= q; i++){
    if(i % 3500 == 1) reb();
    int v = p[i], t = f[v]; res -= hvy[v];
    (l[t] == p[i]) && (l[t] = 0);
    (r[t] == p[i]) && (r[t] = 0);
    for(int ls = v, x = fa[v]; x; ls = fa[ls], x = fa[x]){
      bool f = lr[ls];
      f ? dif[x]++ : dif[x]--;
      res -= hvy[x];
      if((!dif[x]) && (!l[x]) && (!r[x])) hvy[x] = 0;
      if(dif[x] > 0) hvy[x] = l[x];
      if(dif[x] < 0) hvy[x] = r[x];
      res += hvy[x];
    }
    cout << res << "\n";
  }
  return 0;
}
```

---

## 作者：_AyachiNene (赞：6)

不用脑子的纯数据结构做法。
# 思路：
考虑把一次删点作为一次链修改，动态维护重链。首先容易发现的是，一次修改最多改变 $\log n$ 个点的重儿子，构造方法和树剖类似，每个点的重儿子和轻儿子大小相同，这样最多改 $\log n$ 个。再考虑如何找出要修改的点，一个想法是维护每个点重儿子大小减轻儿子大小，把这个作为每个点的权值，每次把权值等于 $-1$ 的点找出来改了就行了。按照这个维护方法，一次修改就是把一条重链的权值减 $1$，轻儿子加 $1$。但是每次改变了重链，最初的用于修改的重链和实际的是不一样的。边权转点权，考虑用 $0/1$ 记下每个点是否是重链，每次就是把每段 $0$ 和每段 $1$ 分别做区间加。先说一个细节，重链是记在儿子上的，改的是父亲，要注意开闭区间，单独处理链底和链顶的父亲。显然轻链只有 $\log n$ 个，直接 dfs 找出来改就行了。到目前为止，用树剖或者全局平衡二叉树可以 $O(n\log^2 n)$ 做了。

由于作者是奶龙，误以为 lct 是单 $\log$ 并误以为很好写，去写了一大坨 lct，这里讲下细节给想吃的人。最重要的一个是 splay 和线段树结构不一样，用线段树去改轻链时，重链也是可以区间加直接改的，但 splay 不行，有的点是重链但他儿子里有轻链，这个点只能单独改，改不了一整段，导致复杂度炸了，所以要先做全局减，在改轻儿子。还有一个细节是特殊处理链底和链顶时，是一个单点加，dfs 时不能直接改，要记下位置，之后 splay 上来再改，还有些细节写代码里了。

# Code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace IO
{
	char buff[1<<21],*p1=buff,*p2=buff;
	char getch(){return p1==p2&&(p2=((p1=buff)+fread(buff,1,1<<21,stdin)),p1==p2)?EOF:*p1++;}
	template<typename T>void read(T &x){char ch=getch();int fl=1;x=0;while(ch>'9'||ch<'0'){if(ch=='-')fl=-1;ch=getch();}while(ch<='9'&&ch>='0'){x=x*10+ch-48;ch=getch();}x*=fl;}
	template<typename T>void read_s(T &x){x="";char ch=getch();while(!(ch>='a'&&ch<='z')&&!(ch>='A'&&ch<='Z'))ch=getch();while((ch>='a'&&ch<='z')||(ch>='A'&&ch<='Z')){x+=ch;ch=getch();}}
	template<typename T,typename ...Args>void read(T &x,Args& ...args){read(x);read(args...);}
	char obuf[1<<21],*p3=obuf;
	void putch(char ch) {if(p3-obuf<(1<<21))*p3++=ch;else fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=ch;}
	char cha[100];
	template<typename T>void write(T x) {if(!x)return putch('0');if(x<0)putch('-'),x*=-1;int top=0;while(x)cha[++top]=x%10+48,x/=10;while(top)putch(cha[top]),top--;}
	template<typename T,typename ...Args>void write(T x,Args ...args) {write(x);putch(' ');write(args...);}
	void put(string s){for(int i=0;i<s.size();i++)putch(s[i]);}
	void flush(){fwrite(obuf,p3-obuf,1,stdout);}
}
using namespace IO;
int n,m;
int e[200005][2];
int ans;
int f[200005],son[200005],dep[200005],siz[200005],dfn[200005],top[200005],cnt;
namespace Nene
{
	struct splt
	{
		int ch[2],f,tag,fmn,fmx,tp;
		int val,mn;
		int top,bot;
	}t[200005];
	inline int isroot(int p){return t[t[p].f].ch[0]!=p&&t[t[p].f].ch[1]!=p;}
	inline void update(int p)
	{
		t[p].mn=t[p].val;
		if(t[p].ch[0]) t[p].mn=min(t[p].mn,t[t[p].ch[0]].mn);
		if(t[p].ch[1]) t[p].mn=min(t[p].mn,t[t[p].ch[1]].mn);
		t[p].fmn=t[p].tp;
		if(t[p].ch[0]) t[p].fmn=min(t[p].fmn,t[t[p].ch[0]].fmn);
		if(t[p].ch[1]) t[p].fmn=min(t[p].fmn,t[t[p].ch[1]].fmn);
		t[p].fmx=max({t[p].tp,t[t[p].ch[0]].fmx,t[t[p].ch[1]].fmx});
		t[p].top=t[p].bot=p;
		if(t[p].ch[0]) t[p].top=t[t[p].ch[0]].top;
		if(t[p].ch[1]) t[p].bot=t[t[p].ch[1]].bot;
	}
	inline void push(int p,int v){t[p].tag+=v;t[p].val+=v;t[p].mn+=v;}
	inline void down(int p)
	{
		if(!t[p].tag) return;
		if(t[p].ch[0]) push(t[p].ch[0],t[p].tag);
		if(t[p].ch[1]) push(t[p].ch[1],t[p].tag);
		t[p].tag=0;
	}
	int stk[200005],top;  //注意不要把splay用的栈和记要改的点的搞混了 
	int del[200005],cnt;
	inline void rotate(int p)
	{
		int f=t[p].f,ff=t[f].f;
		int k=t[t[p].f].ch[1]==p;
		if(!isroot(f)) t[ff].ch[t[ff].ch[1]==f]=p;t[p].f=ff;
		t[f].ch[k]=t[p].ch[k^1];t[t[p].ch[k^1]].f=f;
		t[p].ch[k^1]=f;t[f].f=p;
		update(f);update(p);
	}
	inline void splay(int p)
	{
		stk[++top]=p;
		for(int i=p;!isroot(i);i=t[i].f) stk[++top]=t[i].f;
		while(top) down(stk[top--]);
		while(!isroot(p))
		{
			int f=t[p].f,ff=t[f].f;
			if(!isroot(f)) (t[f].ch[1]==p)^(t[ff].ch[1]==f)?rotate(p):rotate(f); 
			rotate(p);
		}
	}
	void print(int p)
	{
		if(!p) return;
		down(p);
		print(t[p].ch[0]);
		cout<<p<<" "<<t[p].val<<endl;
		print(t[p].ch[1]);
	}
	void change(int p) //链修改 
	{
		if(!p) return;
		down(p);	//记得下传 
		if(t[p].fmn) return/* del[++cnt]=t[p].bot,*/void();
		if(!t[p].tp) del[++cnt]=f[p],del[++cnt]=f[p];
		change(t[p].ch[0]);change(t[p].ch[1]);
		update(p);
	}
	void dfs(int p)
	{
		if(!p) return;
		down(p);   //记得下传 
		if(t[p].mn>=0) return;
		if(t[p].val==-1) del[++cnt]=p;
		dfs(t[p].ch[0]);dfs(t[p].ch[1]);
	}
	inline void access(int p)
	{
		if(!e[f[p]][0]||!e[f[p]][1]) ans-=p;  //特判一条链的最后一个点 
		int tmp=p,pre=0;
		for(pre;p;pre=p,p=t[p].f) splay(p),t[p].ch[1]=pre,update(p);
		push(pre,-1);del[++cnt]=t[pre].bot;del[++cnt]=-f[t[pre].top];
		change(pre);
		while(cnt)
		{
			int x=del[cnt--];
//			cout<<x<<endl;
			if(!x) continue;
			if(x<0) splay(-x),--t[-x].val;  //修改记得splay 
			else splay(x),++t[x].val;
			update(abs(x));
		}
		splay(pre);dfs(pre);  //跟在上面变了，记得splay回来 
		while(cnt)
		{
			int x=del[cnt--];
			splay(x);t[x].val=1;update(x);
			ans+=t[e[x][0]].tp?-e[x][0]+e[x][1]:e[x][0]-e[x][1];
			if(e[x][0]) splay(e[x][0]),t[e[x][0]].tp^=1,update(e[x][0]);  //同样的，修改记得splay 
			if(e[x][1]) splay(e[x][1]),t[e[x][1]].tp^=1,update(e[x][1]);
		}
//		splay(pre);print(pre);cout<<endl;
		e[f[tmp]][e[f[tmp]][1]==tmp]=0;  //断边，不断也无所谓，但写都写lct了你不断？ 
		splay(tmp);t[tmp].ch[0]=t[t[tmp].ch[0]].f=0;
	}
}using namespace Nene;
void dfs1(int u,int fa)
{
	f[u]=fa;dep[u]=dep[fa]+1;siz[u]=1;t[u].f=fa;
	t[u].val=1e9;
	for(int i=0;i<=1;i++)
	{
		int v=e[u][i];
		if(!v) continue;
		dfs1(v,u);siz[u]+=siz[v];
		if(siz[e[u][son[u]]]<siz[v]) son[u]=i;
	}
	if(e[u][son[u]]) t[e[u][son[u]]].tp=1,t[u].val=siz[e[u][son[u]]]-siz[e[u][son[u]^1]];
	else t[u].val=1e9;  //叶子特判 
	update(e[u][son[u]]);update(u);
	ans+=e[u][son[u]];

}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n);
	for(int i=1;i<=n;i++) read(e[i][0],e[i][1]);
	dfs1(1,0);
	read(m);
	write(ans),putch('\n');
	while(m--)
	{
		int p;read(p);
		access(p);
		write(ans),putch('\n');
	}
	flush();
	return 0;
}
```

---

## 作者：bluewindde (赞：2)

很神奇的思路。

一次删除只可能影响其到根节点的路径上的节点的重边，且设这个受影响的节点为 $u$，删除的节点为 $x$，一定满足 $siz_x\le\dfrac{siz_u}{2}$。（$siz_x$ 表示 $x$ 的子树大小）

显然，从 $x$ 到根节点（记为 $rt$）的路径上的节点的子树大小一定单调递增，所以考虑二分找到满足 $siz_x\le\dfrac{siz_u}{2}$ 的深度最小的点 $v$，判断其是否会变为轻儿子（即其父亲的重儿子是否是 $v$，**注意要特判其父亲只有一个儿子 $v$ 的情况**）。然后将 $rt$ 设为 $v$，继续操作直到所有点都不满足条件。

复杂度应该是 $O(\log^2n)$，因为每次操作会进行一次二分，并导致 $siz_{rt}$ 减半，$siz_{rt}$ 的最大值为 $n$。


代码如下，线段树常数大。

```cpp
#include <iostream>

#define int long long

using namespace std;

int n, q;
struct node {
    int l, r;
} a[200005];
int top[200005];
int siz[200005];
int dep[200005];
int f[200005];
int son[200005];
int dfn[200005], dfn_clock;
int nfd[200005];
int low[200005];

static inline void dfs1(int u, int fa) {
    f[u] = fa;
    dep[u] = dep[fa] + 1;
    siz[u] = 1;
    if (a[u].l) {
        dfs1(a[u].l, u);
        siz[u] += siz[a[u].l];
        son[u] = a[u].l;
    }
    if (a[u].r) {
        dfs1(a[u].r, u);
        siz[u] += siz[a[u].r];
        if (siz[a[u].r] > siz[son[u]]) {
            son[u] = a[u].r;
        }
    }
}

static inline void dfs2(int u) {
    dfn[u] = low[u] = ++dfn_clock;
    nfd[dfn_clock] = u;
    if (!son[u]) {
        return;
    }
    top[son[u]] = top[u];
    dfs2(son[u]);
    if (a[u].l && a[u].l != son[u]) {
        top[a[u].l] = a[u].l;
        dfs2(a[u].l);
        low[u] = max(low[u], low[a[u].l]);
    }
    if (a[u].r && a[u].r != son[u]) {
        top[a[u].r] = a[u].r;
        dfs2(a[u].r);
        low[u] = max(low[u], low[a[u].r]);
    }
}

// 线段树维护区间没有被删的点的个数
int d[800005];
static inline void pushup(int p) {
    d[p] = d[p << 1] + d[p << 1 | 1];
}
static inline void build(int s, int t, int p) {
    if (s == t) {
        d[p] = 1;
        return;
    }
    int mid = (s + t) >> 1;
    build(s, mid, p << 1);
    build(mid + 1, t, p << 1 | 1);
    pushup(p);
}
static inline void update(int x, int s, int t, int c, int p) {
    if (s == t) {
        d[p] += c;
        return;
    }
    int mid = (s + t) >> 1;
    if (x <= mid)
        update(x, s, mid, c, p << 1);
    else
        update(x, mid + 1, t, c, p << 1 | 1);
    pushup(p);
}
static inline int query(int l, int r, int s, int t, int p) {
    if (l == 0 || r == 0) {
        return 0;
    }
    if (l <= s && r >= t) {
        return d[p];
    }
    int mid = (s + t) >> 1;
    int ret = 0;
    if (l <= mid) {
        ret += query(l, r, s, mid, p << 1);
    }
    if (r > mid) {
        ret += query(l, r, mid + 1, t, p << 1 | 1);
    }
    return ret;
}

static inline int find(int x, int d) { // 找到节点 x 深度为 d 的祖先
    while (dep[top[x]] > d)
        x = f[top[x]];
    return nfd[dfn[x] - dep[x] + d];
}

signed main() {
#ifndef ONLINE_JUDGE
    freopen("P5773.in", "r", stdin);
#endif
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i].l >> a[i].r;
    }
    dfs1(1, 0);
    top[1] = 1;
    dfs2(1);
    build(1, n, 1);
    int tot = 0;
    for (int i = 1; i <= n; ++i) { // 处理第一次询问的结果
        tot += son[i];
    }
    cout << tot << endl;
    cin >> q;
    while (q--) {
        int x;
        cin >> x;
        int rt = 1;
        update(dfn[x], 1, n, -1, 1); // 标记这个点已被删除 WA
        while (true) {
            int l = dep[rt] + 1, r = dep[x]; // 二分这个节点的深度
                                             // 其具有单调性 因为深度越小，子树大小越大
            int ans = 0;
            int rtq = query(dfn[rt], dfn[rt] + siz[rt] - 1, 1, n, 1) / 2;
            while (l <= r) {
                int mid = (l + r) >> 1;
                int p = find(x, mid);
                if (query(dfn[p], dfn[p] + siz[p] - 1, 1, n, 1) <= rtq) {
                    ans = mid;
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            }
            if (!ans) {
                break;
            }
            int x1 = find(x, ans);
            int x2;
            if (a[f[x1]].l == x1) {
                x2 = a[f[x1]].r;
            } else {
                x2 = a[f[x1]].l;
            }
            int x1q = query(dfn[x1], dfn[x1] + siz[x1] - 1, 1, n, 1);
            int x2q = query(dfn[x2], dfn[x2] + siz[x2] - 1, 1, n, 1);
            if (son[f[x1]] == x1) {
                if (x1q + 1 == x2q) {
                    tot += x2 - x1; // 把 x2 设为重边
                    son[f[x1]] = x2;
                } else if (!x1q && !x2q) { // 没有孩子
                    tot -= x1;             // 直接从答案里删除
                    son[f[x1]] = 0;
                }
            }
            rt = x1;
        }
        cout << tot << endl;
    }
    return 0;
}
```

---

## 作者：Add_Catalyst (赞：2)

# P5773 [JSOI2016] 轻重路径 题解

---

## 题意简述

动态维护重链剖分的树，求每个重链指向的点的编号之和。

---

## 思路分析

### 法 1：分块思想

在 $B$ 次修改中，只有子节点之差点的绝对值小于 $B$ 的节点有可能更改向下的重链，那我们将绝对值小于 $B$ 的节点建一棵树，每 $B$ 次暴力重建一次。

时间复杂度：

单次修改：$O(B)$，暴力建树：$O(N)$；修改次数：$O(Q)$，建树次数：$O(\frac{Q}{B})$。总时间复杂度：
$$
O(Q \cdot B + \frac{Q}{B}N) \\
$$
在 $B=\sqrt{N}$ 时，取最小值：
$$
O(Q\sqrt{N}) \\
$$

### 法 2：长链剖分树上 $K$ 级祖先 + 二分 + 序列分块

考虑在删除一个节点后，会受到影响的只有从根到它的这一条链，而如果要这一条链上的某个点 $u$ 要从轻节点变为重节点，那么必须满足 $siz_u \leq \frac{siz_{fa_u}}{2}$，那么反过来，假设我们现在在根节点 $rt$，那么这一条链上有可能从轻节点变为重节点的子孙节点 $u$ 必须满足 $siz_u \leq \frac{siz_{rt}}{2}$，那么我们可以找到最近的那个子孙节点，然后判断变化并更新后将它作为新的根 $rt'$，继续循环下去，这样就可以保证所有都点被更新到。可以证明，这种操作次数不会大于 $\log_2{N}$，因为每一次换根，子树大小都要除以 2。

现在考虑怎么找子孙节点，一个显然的思路是二分，毕竟 $\{siz\}$ 从底部向上肯定是递增的，而 $siz_{rt}$ 不变。那么我们只需要动态维护 $\{siz\}$ ，再套用长链剖分求树上 $K$ 级祖先的方法辅助二分即可，此处用序列分块维护前缀和可以保证复杂度的正确性。

时间复杂度：

1. 长链剖分树上 $K$ 级祖先 ：
   - 预处理：$O(N\log_2{N})$。
   - 单次查询：$O(1)$。
2. 二分：
   - 单次二分：$O(\log_2{N})$。
   - 最多重复次数：$O(\log_2{N})$。
   - 内部操作：$O(1)$。
3. 序列分块：
   - 单次修改：$O(\sqrt{N})$。
   - 单次查询：$O({1})$。

总时间复杂度：
$$
O(N \log_2{N} + Q (\sqrt{N} + \log_2^2{N})) \\
$$

### 法 3：逆向思维 + 长链剖分

删除节点不好维护，那我们就离线反过来加入节点，并用线段树或树状数组动态维护长链剖分。

加点的时候，只要判断从根到该点这一条链上的轻边是否会变为重边，而动态维护的长链剖分使得这一条链一定只有 $O(\log_2{N})$ 级别的链，也就是只有 $O(\log_2{N})$ 级别的轻边，那我们在往上跳的时候只要二分或树状数组倍增查找上一条轻边所在位置即可。

但这里还有一个小细节：当子树的大小一致时，我们需要特判两棵子树中下一个加入的是哪一个，或者在不再加节点的时候判断哪个是左子节点。

时间复杂度：$O(N \log_2^2{N})$。

---

## CODE

### 法 1：分块思想

时间复杂度：$O(Q\sqrt{N})$，空间复杂度：$O(N)$。

```cpp
int n,B,Q;
namespace Tree {
#define ls(p) (tr[p][0])
#define rs(p) (tr[p][1])
#define fa(p) (tr[p].fa)
	ll sum;
	struct node {
		bool col;
		int d,fa,pa,siz,son;
		int sons[2];
		int &operator[](bool ty) {
			return sons[ty];
		}
	} tr[N];
	void Build() {
		FOR(u,1,n)cin>>ls(u)>>rs(u),tr[ls(u)].fa=u,tr[rs(u)].fa=u;
		DOR(u,n,1)
		tr[u].siz=tr[ls(u)].siz+tr[rs(u)].siz+1,tr[u].son=(tr[ls(u)].siz>=tr[rs(u)].siz?ls(u):rs(u));
		FOR(u,1,n)sum+=tr[u].son;
	}
	void Rebuild() {
		DOR(u,n,1)tr[u].siz=1+tr[ls(u)].siz+tr[rs(u)].siz,tr[u].d=tr[ls(u)].siz-tr[rs(u)].siz;
		FOR(u,1,n) {
			tr[ls(u)].pa=tr[rs(u)].pa=abs(tr[u].d)<=B+1?u:tr[u].pa;
			abs(tr[u].d)<=B+1?(tr[ls(u)].col=0,tr[rs(u)].col=1):(tr[ls(u)].col=tr[rs(u)].col=tr[u].col);
		}
	}
	void Del(int u) {
		sum-=tr[u].son,tr[fa(u)][u==rs(fa(u))]=0;
		for(int pa=tr[u].pa; pa; pa=tr[u=pa].pa) {
			tr[pa].d+=(tr[u].col?1:-1),sum-=tr[pa].son;
			if(!tr[pa].d&&!ls(pa)&&!rs(pa))tr[pa].son=0;
			if(tr[pa].d>0)tr[pa].son=ls(pa);
			if(tr[pa].d<0)tr[pa].son=rs(pa);
			sum+=tr[pa].son;
		}
	}
} using namespace Tree;
signed main() {
	cin>>n,B=ceil(sqrt(n)),Build(),cin>>Q,cout<<sum<<endl;
	FOR(t,1,Q) {
		if(t%B==1)Rebuild();
		int u;
		cin>>u,Del(u),cout<<sum<<endl;
	}
	return 0;
}
```

### 法 2：长链剖分树上 $K$ 级祖先 + 二分 + 序列分块

时间复杂度：$O(N \log_2{N} + Q (\sqrt{N} + \log_2^2{N}))$，空间复杂度：$O(N\log_2{N})$。

```cpp
int Q;
namespace LDT {
	int n,idx;
	int ls[N],rs[N],dl[N],dr[N],Fa[N],Lg[N],dep[N],dfn[N],len[N],siz[N],son[N],Son[N],top[N];
	int fa[N][lV];
	ll sum;
	struct DB {
		int Bl,Bn;
		int st[sN],en[sN],Bsum[sN];
		int id[N],sum[N];
		void init() {
			Bl=ceil(sqrt(n)),Bn=(n-1)/Bl+1;
			FOR(i,1,Bn) {
				st[i]=en[i-1]+1,Bsum[i]=en[i]=min(st[i]+Bl-1,n);
				FOR(j,st[i],en[i])sum[j]=j-st[id[j]=i]+1;
			}
		}
		void Plus(int x,int d) {
			FOR(i,x,en[id[x]])sum[i]+=d;
			FOR(i,id[x],Bn)Bsum[i]+=d;
		}
		int Sum(int x) {
			return Bsum[id[x]-1]+sum[x];
		}
		int Sum(int l,int r) {
			return Sum(r)-Sum(l-1);
		}
	} db;
	void dfs0(int u) {
		dep[u]=dep[fa[u][0]]+1;
		FOR(i,1,Lg[dep[u]])fa[u][i]=fa[fa[u][i-1]][i-1];
		if(ls[u])fa[ls[u]][0]=u,dfs0(ls[u]);
		if(rs[u])fa[rs[u]][0]=u,dfs0(rs[u]);
		len[u]=max(len[ls[u]],len[rs[u]])+1,Son[u]=(len[ls[u]]>=len[rs[u]]?ls[u]:rs[u]);
		siz[u]=siz[ls[u]]+siz[rs[u]]+1,son[u]=(siz[ls[u]]>=siz[rs[u]]?ls[u]:rs[u]);
	}
	void dfs1(int u,int Top,int Pa) {
		top[dfn[dl[u]=++idx]=u]=Top,Fa[idx]=Pa;
		if(Son[u])dfs1(Son[u],Top,fa[Pa][0]);
		if(ls[u]&&ls[u]!=Son[u])dfs1(ls[u],ls[u],ls[u]);
		if(rs[u]&&rs[u]!=Son[u])dfs1(rs[u],rs[u],rs[u]);
		dr[u]=idx;
	}
	int Bro(int u) {
		return ls[fa[u][0]]==u?rs[fa[u][0]]:ls[fa[u][0]];
	}
	int Pa(int u,int k) {
		return k?(u=fa[u][Lg[k]],(k-=(1<<Lg[k])+dep[u]-dep[top[u]])>0?Fa[dl[top[u]]+k]:dfn[dl[top[u]]-k]):u;
	}
	int Siz(int u) {
		return u?db.Sum(dl[u],dr[u]):0;
	}
	void Build() {
		cin>>n,Lg[0]=-1;
		FOR(u,1,n)cin>>ls[u]>>rs[u],Lg[u]=Lg[u>>1]+1;
		dfs0(1),dfs1(1,1,1),sum=accumulate(son+1,son+n+1,0ll);
	}
} using namespace LDT;
signed main() {
	for(Build(),db.init(),cin>>Q,cout<<sum<<endl; Q; --Q) {
		int u,rt=1;
		cin>>u,db.Plus(dl[u],-1);
		for(int ans=0,x=0,y=0; true; ans=0,rt=x,x=0,y=0) {
			for(int l=dep[rt]+1,r=dep[u],mid=(l+r)>>1; l<=r; mid=(l+r)>>1)
				Siz(Pa(u,dep[u]-mid))<=(Siz(rt)>>1)?ans=mid,r=mid-1:l=mid+1;
			if(!ans)break;
			y=Bro(x=Pa(u,dep[u]-ans));
			if(son[fa[x][0]]==x) {
				if(Siz(x)+1==Siz(y))sum+=y-x,son[fa[x][0]]=y;
				else if(!Siz(x)&&!Siz(y))sum-=x,son[fa[x][0]]=0;
			}
		}
		cout<<sum<<endl;
	}
	return 0;
}
```

### 法 3：逆向思维 + 长链剖分

时间复杂度：$O(N \log_2^2{N})$，空间复杂度：$O(N)$。

```cpp
int Q;
int qr[N];
ll ans[N];
namespace WDT {
	int n,idx;
	int a[N],dl[N],dr[N],fa[N],ls[N],rs[N],dep[N],dfn[N],son[N],top[N];
	ll sum;
	struct BIT {
#define lowbit(i) ((i)&-(i))
		int c[N];
		int &operator[](int i) {
			return c[i];
		}
		void Init() {
			FOR(i,1,n)c[i]=1;
		}
		void Build() {
			FOR(i,1,n)if(i+lowbit(i)<=n)c[i+lowbit(i)]+=c[i];
		}
		void Plus(int x,int d) {
			if(x>0)for(int i=x; i<=n; i+=lowbit(i))c[i]+=d;
		}
		int Sum(int x) {
			int ans=0;
			if(x>0)for(int i=x; i; i^=lowbit(i))ans+=c[i];
			return ans;
		}
		int Sum(int l,int r){
			return Sum(r)-Sum(l-1);
		}
		int Bound(int k) {
			int ans=0,sum=0;
			DOR(i,lN,0)if(ans+(1<<i)<=n&&sum+c[ans+(1<<i)]<k)sum+=c[ans+=1<<i];
			return ans+1;
		}
#undef lowbit
	} light,siz;
	struct SEG {
#define ls (p<<1)
#define rs (p<<1|1)
#define mid ((tr[p].l+tr[p].r)>>1)
		struct node {
			int l,r,mi;
		} tr[N<<2];
		void Up(int p) {
			tr[p].mi=min(tr[ls].mi,tr[rs].mi);
		}
		void Build(int p,int l,int r) {
			tr[p]= {l,r,0};
			if(l==r)return tr[p].mi=a[dfn[l]],void();
			Build(ls,l,mid),Build(rs,mid+1,r),Up(p);
		}
		void Change(int p,int x,int d) {
			return tr[p].l==tr[p].r?tr[p].mi=d,void():(Change(x<=mid?ls:rs,x,d),Up(p));
		}
		int Min(int p,int l,int r) {
			if(l<=tr[p].l&&tr[p].r<=r)return tr[p].mi;
			return min(l<=mid?Min(ls,l,r):INF,mid<r?Min(rs,l,r):INF);
		}
#undef ls
#undef rs
#undef mid
	} seg;
	int dfs0(int u) {
		int lsiz=0,rsiz=0;
		a[u]=INF,dep[u]=dep[fa[u]]+1,son[u]=0;
		if(ls[u])fa[ls[u]]=u,lsiz=dfs0(ls[u]);
		if(rs[u])fa[rs[u]]=u,rsiz=dfs0(rs[u]);
		return son[u]=lsiz>=rsiz?ls[u]:rs[u],lsiz+rsiz+1;
	}
	void dfs1(int u,int Top) {
		top[dfn[dl[u]=++idx]=u]=Top;
		if(son[u])dfs1(son[u],Top);
		if(ls[u]&&ls[u]!=son[u])dfs1(ls[u],ls[u]);
		if(rs[u]&&rs[u]!=son[u])dfs1(rs[u],rs[u]);
		dr[u]=idx;
	}
	int Siz(int u){
		return siz.Sum(dl[u],dr[u]);
	}
	int Pa(int u){
		for(u=fa[u];u;u=fa[top[u]]){
			int v=dfn[light.Bound(light.Sum(dl[u]))];
			if(dl[top[u]]<=dl[v]&&dr[v]<=dr[top[u]])return v;
		}return 0;
	}
	int Son(int u){
		if(!ls[u])return rs[u];
		if(!rs[u])return ls[u];
		int lsiz=Siz(ls[u]),rsiz=Siz(rs[u]);
		if(lsiz^rsiz)return lsiz>rsiz?ls[u]:rs[u];
		return seg.Min(1,dl[ls[u]],dr[ls[u]])<=seg.Min(1,dl[rs[u]],dr[rs[u]])?ls[u]:rs[u];
	}
	int Bro(int u){
		return ls[fa[u]]==u?rs[fa[u]]:ls[fa[u]];
	}
	void Build() {
		cin>>n,siz.Init();
		FOR(u,1,n)cin>>ls[u]>>rs[u];
		cin>>Q;
		dfs0(1),dfs1(1,1);
		DOR(i,Q,1)cin>>qr[i],a[qr[i]]=i,siz[dl[qr[i]]]=0;
		siz.Build(),seg.Build(1,1,n);
		FOR(i,1,n){
			int son=Son(i);
			if(son&&Siz(son)){
				sum+=son;
				int bro=Bro(son);
				if(bro&&Siz(bro))light[dl[bro]]=1;
			}
		}
		light.Build();
	}
	void Insert(int u){
		seg.Change(1,dl[u],INF),siz.Plus(dl[u],1);
		if(Son(fa[u])==u){
			if(Siz(Bro(u)))sum-=Bro(u),light.Plus(dl[Bro(u)],1);
			sum+=u;
		}else light.Plus(dl[u],1);
		for(int pa=fa[u=Pa(u)];u&&fa[u];pa=fa[u=Pa(u)])if(Son(pa)==u){
			if(Siz(Bro(u)))sum-=Bro(u),light.Plus(dl[Bro(u)],1);
			sum+=u,light.Plus(dl[u],-1);
		}
	}
} using namespace WDT;
signed main() {
	Build();
	FOR(i,1,Q)ans[i]=sum,Insert(qr[i]);
	ans[Q+1]=sum,reverse(ans+1,ans+Q+2);
	FOR(i,1,Q+1)cout<<ans[i]<<endl;
	return 0;
}
```

*注：* 为防止文件过大，代码经过删减（正确性不变），想要完整代码可以看 [P5773 [JSOI2016] 轻重路径 题解 - plus_cat - 博客园 (cnblogs.com)](https://www.cnblogs.com/Cat-litter/articles/18330307)。

---

---

## 作者：Carey_chen (赞：1)

### 题目大意

> 有一棵 $n$ 个点的以 $1$ 为根的二叉树。有 $q$ 次删点操作，每删掉一个**叶子节点**，需要动态的维护树的重链剖分。
>
> 在每次操作后输出所有重儿子的编号之和。

### 题解

这是一道 `dfs` 序+思维题。

显然地，删除一个叶子只可能影响到**它的祖先中的重儿子**。   
直接 $O(nd)$ 暴力可得 $70$ 分，$d$ 为树高。

考虑优化，可以用二分查找出从上一个点往下第一个会变为轻边的点（即这个点的子树大小小于等于上一个点的子树大小），不断查找直到找不到为止。

需要动态维护每个子树的大小，可用树状数组。

时间复杂度 $O(n \log^3 n)$。

### Code

```cpp
#include <bits/stdc++.h>

int n, q;

struct Tree{...}; //树状数组，支持单点修改，区间查询

Tree T;
int l[200010], r[200010], fa[200010][30], dep[200010];
int siz[200010], son[200010], dfn[200010], now = 0;

long long ans;
void dfs(int u)
{
	now++;
	dfn[u] = now;
	
	siz[u] = 1;
	
	if(l[u] != 0)
	{
		dep[l[u]] = dep[u] + 1;
		dfs(l[u]);
		siz[u] += siz[l[u]];
		fa[l[u]][0] = u;
	}
	if(r[u] != 0)
	{
		dep[r[u]] = dep[u] + 1;
		dfs(r[u]);
		siz[u] += siz[r[u]];
		fa[r[u]][0] = u;
	}
	
	if(siz[l[u]] > siz[son[u]])
	{
		son[u] = l[u];
	}
	if(siz[r[u]] > siz[son[u]])
	{
		son[u] = r[u];
	}
	
	ans += son[u];
}

int query(int u)
{
	return T.query(dfn[u], dfn[u] + siz[u] - 1);
}

int up(int u, int step){...} //倍增，从 u 点开始向上跳 step

int main()
{
	scanf("%d", &n);
	
	for(int i = 1; i <= n; i++)
	{
		scanf("%d %d", &l[i], &r[i]);
	}
	
	dfs(1);
	
	for(int j = 1; j <= 20; j++)
	{
		for(int i = 1; i <= n; i++)
		{
			fa[i][j] = fa[fa[i][j-1]][j-1];
		}
	}
	
	scanf("%d", &q);
	
	for(int i = 1; i <= n; i++)
	{
		T.motify(dfn[i], 1);
	}
	
	printf("%lld\n", ans);
	
	for(int i = 1; i <= q; i++)
	{
		int u;
		scanf("%d", &u);
		
		T.motify(dfn[u], -1);
		
		int v = 1;
		while(1)
		{
			int L = 0, R = dep[u] - dep[v] - 1, len = -1;
			while(L <= R)
			{
				int mid = (L + R) / 2;
				if(query(up(u, mid)) <= query(v) / 2)
				{
					len = mid;
					L = mid + 1;
				}
				else
				{
					R = mid - 1;
				}
			}
			
			if(len == -1)
			{
				break;
			}
			
			int pos1 = up(u, len);
			
			if(son[fa[pos1][0]] == pos1)
			{
				int pos2 = l[fa[pos1][0]] + r[fa[pos1][0]] - son[fa[pos1][0]];
				
				if(query(pos2) > query(pos1))
				{
					ans -= pos1;
					ans += pos2;
					son[fa[pos1][0]] = pos2;
				}
				if(query(pos2) == 0 && query(pos1) == 0)
				{
					ans -= pos1;
					son[fa[pos1][0]] = 0;
				}
			}
			
			v = pos1;
		}
		
		printf("%lld\n", ans);
		
		if(l[fa[u][0]] == u)
		{
			l[fa[u][0]] = 0;
		}
		else
		{
			r[fa[u][0]] = 0;
		}
	}
	
	return 0;
}
```

---

## 作者：XuYueming (赞：1)

## 前言

题目链接：[LOJ](https://loj.ac/p/2079)；[洛谷](https://www.luogu.com.cn/problem/P5773)。

[更好的体验](https://www.cnblogs.com/XuYueming/p/18327374)。

## 题意简述

在二叉树上，不断删除叶子，你要维护其树链剖分后重儿子编号和。如果两个孩子大小相同，在一开始连向左儿子，或者保持修改前的连接。

$n \leq 2 \times 10^5$。

## 题目分析

有分块的、有二分的，那我来讲一讲我的想法——树剖维护树剖。

首先反转操作，不断加叶子，那么可能发生变化的就是根到当前结点上，轻儿子变成重儿子。由于树链剖分的性质，这样的个数不会超过 $\log$。考虑根据它的树剖，不断跳到重链顶 $u$，判断 $\operatorname{fa}(u)$ 的重儿子会不会从 $\operatorname{bro}(u)$ 变成 $u$。

假设发生了变化，那么会发生什么？记 $\operatorname{tail}(u)$ 表示一条以 $u$ 为 $\operatorname{top}$ 的重链的链底。记 $v = \operatorname{top}(\operatorname{fa}(u))$，那么我们要把 $\operatorname{bro}(u) \sim \operatorname{tail}(v)$ 的 $\operatorname{top}$ 修改为 $\operatorname{bro}(u)$，并把 $u \sim \operatorname{tail}(u)$ 的 $\operatorname{top}$ 修改为 $v$，而且 $\operatorname{tail}(\operatorname{bro}(u))$ 修改为 $\operatorname{tail}(v)$，$\operatorname{tail}(v)$ 修改为 $\operatorname{tail}(u)$。当然，需要维护重儿子。

注意到，当 $\operatorname{bro}(u)$ 不存在时，这时候只可能时 $u$ 刚刚加入到二叉树里。特殊处理一下就可以了。

树链修改，考虑用树剖。嗯？显然不能用它这个变来变去的树剖，不然上不了数据结构。所以要把最终的二叉树先剖了，用一棵线段树支持树链修改。

至于如何判断会不会发生改变，我们显然困扰在 $\operatorname{siz}(u) = \operatorname{siz}(\operatorname{bro}(u))$ 的情况，这种情况会保持当前操作之前的形态。如果 $u$ 和 $\operatorname{bro}(u)$ 之前都没有任何操作，那么就是保持在左儿子。否则，考虑最后一次操作是在 $u$ 还是 $\operatorname{bro}(u)$，其所在的结点就是操作前的重儿子。为什么？由题意正向考虑，在这一次操作前，其所在节点的 $\operatorname{siz}$ 大，是在删除后才相等，所以保留。

这个可以无脑主席树和 dfs 序。相当于查询子树里第 $i$ 个版本的最大值。

注意到，维护 $\operatorname{siz}$ 也可以用树链剖分无脑维护。

预处理出完成所有操作后的树的树链剖分，很水。但是把重儿子编号记成了轻儿子编号还能有 $60$ 分？

总的时间复杂度是 $\Theta(m \log^3 n)$。

## 代码

有一些细节要注意。无脑的坏处是码量略大。

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

int n, m;
int L[200010], R[200010];
int del[200010];
long long ans[200010];
bool mark[200010];
int when[200010];

int fa[200010], top[200010], dpt[200010];
int son[200010], siz[200010];
void dfs(int now) {
	siz[now] = 1;
	if (L[now]) dpt[L[now]] = dpt[now] + 1, fa[L[now]] = now, dfs(L[now]), siz[now] += siz[L[now]], siz[L[now]] > siz[son[now]] && (son[now] = L[now]);
	if (R[now]) dpt[R[now]] = dpt[now] + 1, fa[R[now]] = now, dfs(R[now]), siz[now] += siz[R[now]], siz[R[now]] > siz[son[now]] && (son[now] = R[now]);
}
int dfn[200010], timer;
int dfnL[200010], dfnR[200010];
void redfs(int now, int tp) {
	dfn[dfnL[now] = ++timer] = now;
	top[now] = tp;
	if (son[now]) redfs(son[now], tp);
	if (L[now] && L[now] != son[now]) redfs(L[now], L[now]);
	if (R[now] && R[now] != son[now]) redfs(R[now], R[now]);
	dfnR[now] = timer;
}

int TOP[200010], SON[200010], SIZ[200010];
int ED[200010];
void DFS(int now) {
	SIZ[now] = !mark[now];
	if (L[now]) DFS(L[now]), SIZ[now] += SIZ[L[now]], when[now] = max(when[now], when[L[now]]);
	if (R[now]) DFS(R[now]), SIZ[now] += SIZ[R[now]], when[now] = max(when[now], when[R[now]]);
	if (!mark[now]) {
		if (L[now] && !mark[L[now]] && siz[L[now]] > siz[R[now]]) {
			SON[now] = L[now];
		} else if (R[now] && !mark[R[now]] && siz[R[now]] > siz[L[now]]) {
			SON[now] = R[now];
		} else {
			if (L[now] && !mark[L[now]] && when[L[now]] > when[R[now]]) {
				SON[now] = L[now];
			} else if (R[now] && !mark[R[now]]){
				SON[now] = R[now];
			} else if (L[now] && !mark[L[now]]){
				SON[now] = L[now];
			} else {
				SON[now] = 0;
			}
		}
	}
}
void REDFS(int now, int tp) {
	TOP[now] = tp, ED[tp] = now;
	if (SON[now]) REDFS(SON[now], tp), ans[m + 1] += SON[now];
	if (L[now] && !mark[L[now]] && L[now] != SON[now]) REDFS(L[now], L[now]);
	if (R[now] && !mark[R[now]] && R[now] != SON[now]) REDFS(R[now], R[now]);
}

struct Segment_Tree {
	#define lson (idx << 1    )
	#define rson (idx << 1 | 1)
	
	struct node {
		int l, r;
		int top, siz;
		bool tag;
		int lazy;
	} tree[200010 << 2];
	
	void build(int idx, int l, int r) {
		tree[idx] = {l, r, 0, 0, false, 0};
		if (l == r) return tree[idx].top = TOP[dfn[l]], tree[idx].siz = SIZ[dfn[l]], void();
		int mid = (l + r) >> 1;
		build(lson, l, mid);
		build(rson, mid + 1, r);
	}
	
	void pushtag_top(int idx, int tp) {
		tree[idx].top = tp;
		tree[idx].tag = true;
	}
	
	void pushtag_lazy(int idx, int lazy) {
		tree[idx].lazy += lazy;
		tree[idx].siz += lazy;
	}
	
	void pushdown(int idx) {
		if (tree[idx].tag) {
			pushtag_top(lson, tree[idx].top);
			pushtag_top(rson, tree[idx].top);
			tree[idx].tag = false;
		}
		if (tree[idx].lazy) {
			pushtag_lazy(lson, tree[idx].lazy);
			pushtag_lazy(rson, tree[idx].lazy);
			tree[idx].lazy = 0;
		}
	}
	
	void modify_top(int idx, int l, int r, int val) {
		if (tree[idx].l > r || tree[idx].r < l) return;
		if (l <= tree[idx].l && tree[idx].r <= r) return pushtag_top(idx, val);
		pushdown(idx);
		modify_top(lson, l, r, val);
		modify_top(rson, l, r, val);
	}
	
	void modify_lazy(int idx, int l, int r, int val) {
		if (tree[idx].l > r || tree[idx].r < l) return;
		if (l <= tree[idx].l && tree[idx].r <= r) return pushtag_lazy(idx, val);
		pushdown(idx);
		modify_lazy(lson, l, r, val);
		modify_lazy(rson, l, r, val);
	}
	
	int query_siz(int idx, int p) {
		if (tree[idx].l > p || tree[idx].r < p) return 0;
		if (tree[idx].l == tree[idx].r) return tree[idx].siz;
		pushdown(idx);
		return query_siz(lson, p) | query_siz(rson, p);
	}
	
	int query_top(int idx, int p) {
		if (tree[idx].l > p || tree[idx].r < p) return 0;
		if (tree[idx].l == tree[idx].r) return tree[idx].top;
		pushdown(idx);
		return query_top(lson, p) | query_top(rson, p);
	}
	
	#undef lson
	#undef rson
} yzh;

int bro(int x) {
	if (x == L[fa[x]]) return mark[R[fa[x]]] ? 0 : R[fa[x]];
	return mark[L[fa[x]]] ? 0 : L[fa[x]];
}

int gettop(int x) {
	return yzh.query_top(1, dfnL[x]);
}

int getsiz(int x) {
	return yzh.query_siz(1, dfnL[x]);
}

void modify_lazy(int u, int v) {
	while (top[u] != top[v]) {
		if (dpt[top[u]] < dpt[top[v]]) swap(u, v);
		yzh.modify_lazy(1, dfnL[top[u]], dfnL[u], 1);
		u = fa[top[u]];
	}
	if (dfnL[u] > dfnL[v]) swap(u, v);
	yzh.modify_lazy(1, dfnL[u], dfnL[v], 1);
}

void modify_top(int u, int v, int w) {
	while (top[u] != top[v]) {
		if (dpt[top[u]] < dpt[top[v]]) swap(u, v);
		yzh.modify_top(1, dfnL[top[u]], dfnL[u], w);
		u = fa[top[u]];
	}
	if (dfnL[u] > dfnL[v]) swap(u, v);
	yzh.modify_top(1, dfnL[u], dfnL[v], w);
}

struct Yet_another_Segment_Tree {
	struct node {
		int lson, rson;
		int val;
	} tree[200010 * 80];
	int tot;
	
	int root[200010];
	
	int copyNode(int idx) {
		return tree[++tot] = tree[idx], tot;
	}
	
	void modify(int &idx, int trl, int trr, int p, int v) {
		if (trl > p || trr < p) return;
		idx = copyNode(idx);
		tree[idx].val = max(tree[idx].val, v);
		if (trl == trr) return;
		int mid = (trl + trr) >> 1;
		modify(tree[idx].lson, trl, mid, p, v);
		modify(tree[idx].rson, mid + 1, trr, p, v);
	}
	
	int query(int idx, int trl, int trr, int l, int r) {
		if (!idx || trl > r || trr < l) return 0;
		if (l <= trl && trr <= r) return tree[idx].val;
		int mid = (trl + trr) >> 1;
		return max(query(tree[idx].lson, trl, mid, l, r), query(tree[idx].rson, mid + 1, trr, l, r));
	}
} ttrr;

bool check(int i, int u, int v) {
	if (i == 1) return L[fa[u]] == u;
	int resu = ttrr.query(ttrr.root[i - 1], 1, n, dfnL[u], dfnR[u]),
		resv = ttrr.query(ttrr.root[i - 1], 1, n, dfnL[v], dfnR[v]);
	if (!resu && !resv) return L[fa[u]] == u;
	return resu > resv;
}

signed main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) scanf("%d%d", &L[i], &R[i]);
	scanf("%d", &m);
	for (int i = 1; i <= m; ++i) scanf("%d", &del[i]), mark[del[i]] = true, when[del[i]] = i;
	dfs(1), redfs(1, 1);
	DFS(1), REDFS(1, 1);
	for (int i = 1; i <= m; ++i) {
		ttrr.root[i] = ttrr.root[i - 1];
		ttrr.modify(ttrr.root[i], 1, n, dfnL[del[i]], i);
	}
	yzh.build(1, 1, n);
	for (int i = m; i >= 1; --i) {
		int u = del[i];
		long long res = 0;
		mark[u] = false;
		modify_lazy(u, 1);
		yzh.modify_top(1, dfnL[u], dfnL[u], u);
		ED[u] = u;
		if (u == 1) continue;
		if (!bro(u)) {
			SON[fa[u]] = u;
			res += u;
			int ftop = gettop(fa[u]);
			ED[ftop] = ED[u];
			yzh.modify_top(1, dfnL[u], dfnL[u], ftop);
			u = ftop;
		}
		while (u != 1) {
			int v = bro(u);
			int sizu = getsiz(u), sizv = getsiz(v);
			int ftop = gettop(fa[u]);
			if (v && SON[fa[u]] == v && (sizu > sizv || (sizu == sizv && check(i, u, v)))) {
				res += u - v;
				SON[fa[u]] = u;
				ED[v] = ED[ftop];
				ED[ftop] = ED[u];
				modify_top(u, ED[u], ftop);
				modify_top(v, ED[v], v);
			}
			u = ftop;
		}
		ans[i] = ans[i + 1] + res;
	}
	for (int i = 1; i <= m + 1; ++i) {
		printf("%lld\n", ans[i]);
	}
	return 0;
}
```

---


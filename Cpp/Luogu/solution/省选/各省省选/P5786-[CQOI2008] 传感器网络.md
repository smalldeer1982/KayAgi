# [CQOI2008] 传感器网络

## 题目描述

一个无线传感器网络由若干独立采集数据的设备和一个控制中心组成。每个设备必须把采集到的数据传到控制中心处理，但由于设备限制，并不是每台设备都可以与控制中心直接相连。为了解决这一问题，你将传感器网络设计成树状结构。树根为控制中心，而每台设备恰好有一个父亲节点（要么为控制中心，要么为另一台设备）。一台设备的儿子设备个数称为它的负载级别。所有设备（注意，控制中心不是设备）的负载级别的最大值称为网络的负载级别。

你的任务是让整个网络的负载级别尽量小。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/k42z6mxl.png)

对于 $50\%$ 的数据，$2\le N\le 6$；对于另外 $50\%$ 的数据，$N=50$。

## 样例 #1

### 输入

```
5
YNNYN
NNNNN
YNNNY
NNNYN
NNNNN
YNNYN```

### 输出

```
5 4 3 5 0```

# 题解

## 作者：TheAutumnGlory (赞：5)

~~这道题肯定用网络流，不然$nodgd$给你放在网络流考试里干嘛~~

### 题意：
给了一个有向无环图，给（除了根节点）每个节点选一条出边构成一棵树，让儿子个数最多的节点的儿子个数最少。（**根节点不算**）
依次输出每个节点的父亲，要求**字典序最小**。

-------
先不考虑字典序，考虑计算最小的负载级别。

很显然想到负载级别可以用**二分答案**来求。

判断负载级别为K是否可行，于是我们可以建出这样一幅图来：
![](https://cdn.luogu.com.cn/upload/image_hosting/659jrj0b.png)

然后计算最大流，如果最大流=$N$，说明负载级别可以等于$K$

-------
那么如何验证字典序最小呢？

### 枚举

在过程中，我们已经确定了$fa[0]$~$fa[i-1]$，此时枚举$fa[i]$，$fa[i+1]$~$fa[n-1]$未确定。

那么$0$~$i-1$节点只和已确定的父亲连边，$i$号节点也和枚举的父亲连边，$i+1$~$n-1$按原来的方式连边（可能有多条）。

如果当前$fa[i]$建图跑最大流=n，说明当前$fa[i]$可行，$fa[i]$就定下来枚举$i+1$

如果最大流$<N$，说明不行，继续枚举$i$的出边作为$fa[i]$，继续验证即可

要跑$N^2$次网络流，可以过，但是$nodgd$觉得他不够优秀。


### 优化（跑$NlogN$次最大流）
刚才，枚举$i$的出边作为$fa[i]$

现在：网络流验证 $L \leq fa[i] \leq R$ 是否可行

于是$i$号节点就和$L$~$R$连边

就可以**二分验证**

> 一开始已知在$[0,N]$有解
>
> 第一轮就验证$[0,N/2]$
>
> 第二轮...

~~其实也快不到那里去...~~

$code:$
```
#include<bits/stdc++.h>
using namespace std;
const int N=205;
const int M=5005;
const int inf=1e9;
int n,k,S,T,fa[N];
char a[N][N];
int Last[N],Next[M],End[M],len[M],tot;
int _last[N],dis[N],gap[N];
void cb(int x,int y,int z,int z0=0){
    End[tot]=y,Next[tot]=Last[x],len[tot]=z,Last[x]=tot++;
    End[tot]=x,Next[tot]=Last[y],len[tot]=z0,Last[y]=tot++;
}
void bfs(){
    for(int i=1;i<=T;i++) dis[i]=T,gap[i]=0;
    gap[0]=0;
    dis[T]=0;
    queue<int> q;
    q.push(T);
    while(q.size()){
        int x=q.front();
        q.pop();
        for(int i=Last[x];i;i=Next[i]){
            int y=End[i];
            if(dis[y]>dis[x]+1){
                dis[y]=dis[x]+1;
                q.push(y);
            }
        }
    }
    for(int i=1;i<=T;i++) gap[dis[i]]++,_last[i]=Last[i];
}
int isap(int x,int flow){
    if(x==T) return flow;
    int flow_now=0;
    for(int &i=_last[x];i;i=Next[i]){
        int y=End[i];
        if(len[i] && dis[x]==dis[y]+1){
            int f=isap(y,min(len[i],flow-flow_now));
            flow_now+=f;
            len[i]-=f;
            len[i^1]+=f;
            if(flow==flow_now || dis[S]==T) return flow_now;
        }
    }
    gap[dis[x]]--;
    if(gap[dis[x]]==0) dis[S]=T;
    dis[x]++;
    gap[dis[x]]++;
    _last[x]=Last[x];
    return flow_now;
}
bool check(int mid){
    S=2*n+1;
    T=S+2;
    tot=2;
    for(int i=1;i<=n;i++){
        cb(S,i,1);
        if(fa[i]) cb(i,fa[i]>n?T:fa[i]+n,1);
        else if(a[0][i]=='Y') cb(i,T,1);
        else
            for(int j=1;j<=n;j++)
                if(a[i][j]=='Y')
                    cb(i,j+n,1);
        cb(i+n,T,mid);
    }
    int res=0;
    bfs();
    while(dis[S]<T) res+=isap(S,inf);
    for(int i=0;i<=T;i++) Last[i]=0;
    if(res==n) return 1;
    return 0;
}
int main(){
    scanf("%d",&n);
    for(int i=0;i<=n;i++) scanf("%s",a[i]+1);
    for(int i=1;i<=n;i++) a[i][n+1]=a[0][i];
    int l=0,r=n;
    //------
    while(l<=r){
        int mid=l+r>>1;
        if(check(mid)){
            r=mid-1;
            k=mid;
        }
        else l=mid+1;
    }
    //------
    for(int i=1;i<=n;i++){
        bool flag=0;
        for(int j=1;j<=n;j++){
            if(a[i][j]=='Y'){
                fa[i]=j;
                if(check(k)){
                    flag=1;
                    break;
                }
            }
        }
        if(flag) continue;
        fa[i]=n+1;//fa[i]=CC
    }
    //------
    for(int i=1;i<=n;i++) printf("%d ",fa[i]-1);
    return 0;
}
```

---

## 作者：Unnamed114514 (赞：3)

[题外话：迭代加深拿到了最优解...](https://www.luogu.com.cn/record/126583212)

RT，严格上说，迭代加深复杂度是 $O(n^n)$ 的（因为我们要枚举每个点的父亲），所以期望得分应该是 $50$。

考虑优化。

### 求解答案

最大最小应该能想到二分。

然后现在最核心的问题就变成了怎么 `check`。

首先我们把问题转化成如下几个限制：

- 每个点的出度为 $1$。

- 除 $n$ 外，每个点的入度 $\le mid$。

对于出度入度的限制问题，这是一个网络流的经典模型，所以我们考虑建模：

首先考虑拆点，对于本题，显然是拆成作为儿子的点和作为父亲的点。

对于作为父亲的点 $i$，我们可以它的入度 $\le mid$，但是它的入边有多条不好限制，所以我们直接限制出度，将它向终点连流量上界为 $mid$ 的边。

对于作为儿子的点 $i$，我们发现它的出度为 $1$，但是它的出边有多条不好限制，所以我们限制入度，即从起点向它连流量上限为 $1$ 的边。

（其实还有一种做法，就是再次拆 $i$ 作为父亲和 $i$ 作为儿子的点，然后前者连上界为 $mid$ 的边，后者连上界为 $1$ 的边，其他边随便开 $\infty$ 即可，这样应该更好理解，但是常数会大一些）

然后最后判断每个点存在父亲，就是判断每个点是否向终点有流量，等价于判断最大流是不是 $n$。

那么我们就可以做到 $O(N^2M)=O(n^4)$ 的 `check`。

### 求解方案

类似于搜索的做法，首先我们发现搜索慢的原因：每次强制父亲了之后我们都是需要再次进行 `dfs` 从而判断是否可行，而这个 `dfs` 是 $O(n^n)$ 的，于是就不行，但是现在我们已经有了 $O(n^4)$ 的 `check`。所以我们强制选取了父亲之后，直接跑 `dinic` 即可。

时间复杂度 $O(n^6)$，但是 `dinic` 跑不满。

---

## 作者：LCat90 (赞：2)

### $\text{Hints}$

> DAG 中选择一棵树，使得这棵树每个点的儿子（**没有孙子**）数的最大值最小。

首先二分这个值 $k$，转化为判断。

$n \le 50$？

### $\text{Sol}$

尝试用全新的角度看待问题：树的性质。

假设我们把 $i$ 为父亲，$j$ 为儿子的关系视作 $i\to j$ 的一条边。

+ 每个点的入度只为 $1$。

+ 每个点的出度至多为 $k$。

可以发现这就是一个充满多限制的选择题，容易想到转变为流问题。

按照套路进行拆点，$[1,n]$ 为出点，$[n+1,2n]$ 为入点。

然后按照常规建边。请自行思考建边方法。

建完边后跑一边最大流如果流量等于 $N$ 即满足。

--------

找到最小的最大值后，需要输出方案。

枚举当前要算的位置 $i$，然后从小到大枚举它的父亲 $j$。然后将所有连向 $i$ 的边去掉，只保留 $j\to i$。此时再跑一遍最大流，如果仍然满流则说明这条边合法，并且是字典序最小的。

找到一个过后就永久保留这条边，即不还原。以保证后面选择边是正确的。

----------------

分析复杂度：

最大流 $O(N^2M)=O(N^4)$。二分 $O(\log n)$。

枚举方案 $O(N^2)\times O(N^2M)=O(N^6)$。

但是最大流跑不满，因为流量不是很大。

--------------------

```cpp
#include <bits/stdc++.h> 
#define pb push_back
using namespace std;
const int N = 5e3 + 5, M = 5e3 + 5, inf = 1e9;
int n, S, T, d[N] = {}, ans[N];
int cnt = 1, head[N], nxt[M], To[M], fl[M], cost[M];
bool vis[M], fa[105][105], sb[N][N];
vector <int> G[N]; 
void add(int x, int y, int z) { 
	nxt[++cnt] = head[x], To[cnt] = y, fl[cnt] = z, head[x] = cnt;
	nxt[++cnt] = head[y], To[cnt] = x, fl[cnt] = 0, head[y] = cnt;
}
namespace Flow {
	int maxflow = 0, aug[N] = {}, fa[N] = {}, now[N]; 
	bool bfs() {
		memset(d, 0, sizeof d);
		memset(aug, 0, sizeof aug);
		memset(vis, 0, sizeof vis);
		queue <int> q;
		q.push(S);
		vis[S] = 1; aug[S] = inf, now[S] = head[S], d[S] = 1; 
		while(!q.empty()) {
			int p = q.front();
			q.pop();
			if(p == T) return 1;
			for(int i = head[p];i;i = nxt[i]) {
				int to = To[i], val = fl[i];
				if(val <= 0 or vis[to]) continue ;
				vis[to] = 1, fa[to] = i, aug[to] = min(aug[p], val);
				d[to] = d[p] + 1, now[to] = head[to];
				q.push(to);
			}
		}
		return 0;
	}
	int dinic(int x, int flow) {
		if(x == T) return flow;
		int rest = flow;
		for(int i = now[x];i and rest;i = nxt[i]) {
			now[x] = i; int to = To[i], val = fl[i];
			if(val > 0 and d[to] == d[x] + 1) {
				int c = dinic(to, min(val, rest));
				if(!c) d[to] = 0;
				fl[i] -= c;
				fl[i ^ 1] += c;
				rest -= c;
			} 
		}
		return flow - rest;
	}
	int Dinic() {
		int flow = 0; maxflow = 0;
		while(bfs()) while(flow = dinic(S, inf)) maxflow += flow;
		return maxflow;
	}
} ;
bool check(int x) {
	S = 0, T = 2 * n + 2;
	memset(head, -1, sizeof head);
	cnt = 1;  // 左边是出边 右边是入边 
	for(int i = 1;i <= n; ++i) add(S, i, x);
	for(int i = n + 1;i <= 2 * n; ++i) add(i, T, 1);
	for(int i = 1;i <= n; ++i) 
		for(int to = 1;to <= n; ++to) if(sb[to][i] and fa[to][i]) add(i, to + n, 1);
	add(S, 2 * n + 1, inf);
	for(int i = 1;i <= n; ++i) if(sb[i][n + 1] and fa[i][n + 1]) add(2 * n + 1, i + n, 1);
	int t = Flow :: Dinic(); 
	return t == n;	
}
signed main() {
	cin >> n;
	memset(fa, 1, sizeof fa);
	for(int i = 0;i <= n; ++i)
		for(int j = 1;j <= n; ++j) {
			char ch;
			cin >> ch;
			if(ch == 'N') continue ;
			if(i == 0) sb[j][n + 1] = 1; // 
			else sb[i][j] = 1;
		}	
	int l = 0, r = n;
	while(l < r) {
		int mid = l + r >> 1;
		if(check(mid)) r = mid;
		else l = mid + 1;
	} 
	for(int i = 1;i <= n; ++i) {
		bool f = 0;
		memset(fa[i], 0, sizeof fa[i]); 
		for(int to = 1;to <= n + 1; ++to) 
		if(sb[i][to]) {
			fa[i][to] = 1; // to 到 i 
			if(check(l)) {
				f = 1; 
				ans[i] = to; 
				break ;	
			}
			fa[i][to] = 0;
		} 
	}
	for(int i = 1;i <= n; ++i) cout << ans[i] - 1 << " "; 
	return 0;
}
```

---

## 作者：CloudWings (赞：2)

[Blog](https://www.cnblogs.com/cqbz-dxm/p/17737029.html)

---

## 题意

>  给定一张有向无环图，从中选出一棵有根树（节点编号为 $0\sim n$，树根为 $n$），使得 **除根节点外** 所有节点的出度的最大值最小。除根节点外，依次输出每个节点的父亲，并要求 **字典序最小**。（$1\le n\le 50$）

*注意：由于个人习惯，这里将节点编号重编为  $1\sim n+1$，根节点即为 $n+1$。

---

## 解法

### Step1. 求解该最小值

关注到「最大的最小」不难想到 **二分**。

思考 `check` 的写法：（设当前二分的值为 $k$）

于是对于树中除根节点外所有节点的出度给出了要求，即出度必须小于等于 $k$，同时其入度必须等于 $1$（因为这是棵树）。

这其实也就是对子节点和其父节点提出了数量上的要求，而确定了每组节点匹配关系即可确定一棵树，所以这道题本质上就是求「一种有要求的匹配关系」，进而想到 **网络流** 求解。

将网络中的点分为两类：

1. 编号 $1\sim n$：分别对应原图的除根节点外的点（$1\sim n$）；
2. 编号 $n+1\sim 2n+1$：分别对应原图的所有节点的父节点（$1\sim n+1$）。

先根据输入的限制，从第一类向第二类连有向边，表示第二类的点可以做对应第一类的父亲。

接下来考虑数量限制：（令 $S=0$ 为源点，$T=2n+2$ 为汇点）

1. 「入度等于 $1$」：于是从 $S$ 依次向第一类的点，连一条容量为 $1$ 的边；

2. 「出度小于等于 $k$」：于是从第二类的点（除根节点 $2n+1$）依次向 $T$，连一条容量为 $k$ 的边。

   对于根节点 $2n+1$，因为对它的出度没有限制，所以直接从它向 $T$ 连一条 $+\infty$ 的边即可。

此时我们跑一遍最大流，如果最大流等于 $n$，则说明对于 $1\sim n$ 的所有点都被匹配到了对应的父亲，故此时的 $k$ 是可行的。

---

### Step2. 输出方案

令 $N$ 为网络中的节点数，$M$ 为网络中的边数。

对于一般的最大流求解算法都不太好保证方案字典序最小，同时考虑到此时的时间复杂度为 Dinic 的$ \mathcal{O}(N^2M)\le100^2\times2600=2.6\times10^7$ 虽然不是很充裕 ~~（但是有如下的乱搞（（~~

我们假设节点 $1\sim i-1$ 与其父亲已经得到了最优的匹配。

则对于节点 $i$，从贪心的角度，我们可以从 $1$ 到 $n+1$ 枚举它的父亲 $j$。

如果我们在网络中对于 $i$ 的出边只保留 $(i,j+n)$ 这一条，但是整张网络的最大流仍是 $n$，则说明此时 $j$ 作为 $i$ 的父亲是合理的。

至此，我们得到了一个时间复杂度为 $\mathcal{O}(n^2N^2M)$ 的算法，但由于 Dinic 跑不满，还是能通过此题。

#### 小优化：二分

还是对于节点 $i$，如果我们知道，如果其父亲 $j$ 合法，那么对于 $k(k>j)$ 作为 $i$ 父亲也一定合法，具有单调性。

于是我们可以二分该区间的右端点，每次保留从 $i$ 到 $[1,mid+n]$ 的所有边，同样与暴力一样判断合法。

直至得到第一个合法的 $j$。

---

## 实现 & 代码

为了实现方便，这里使用的直接枚举 $i$  的父亲的方法。

$fa[i][j]$ 表示 $j$ 可以尝试作为 $i$ 的父亲（初值均置为 $1$）

```c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 55, MAXM = 2600, INF = 0x3f3f3f3f;
int n, S, T, N, _tot, tot = 1, head[MAXN<<1], ans[MAXN];
char s[MAXN][MAXN];
bool fa[MAXN][MAXN];
struct Edge { int v, c, nxt; } edge[MAXM<<1];
void AddEdge (int u, int v, int c) {
	edge[++tot] = {v, c, head[u]}, head[u] = tot;
	edge[++tot] = {u, 0, head[v]}, head[v] = tot;
}
int d[MAXN<<1], now[MAXN<<1];
bool bfs () {
	for (int i = 0; i <= N; i++) d[i] = 0, now[i] = head[i];
	queue<int> q; q.push(S), d[S] = 1;
	while (!q.empty()) {
		int u = q.front(); q.pop();
		for (int i = head[u]; i; i = edge[i].nxt) {
			int v = edge[i].v, c = edge[i].c;
			if (c > 0 && !d[v]) {
				d[v] = d[u] + 1;
				if (v == T) return true;
				q.push(v);
			}
		}
	}
	return false;
}
int dinic (int u, int flow) {
	if (u == T) return flow;
	int rest = flow;
	for (int i = now[u]; i && rest; i = edge[i].nxt) {
		now[u] = i;
		int v = edge[i].v, c = edge[i].c;
		if (c > 0 && d[v] == d[u] + 1) {
			int k = dinic(v, min(rest, c));
			if (!k) d[v] = 0;
			rest -= k, edge[i].c -= k, edge[i^1].c += k;
		}
	}
	return flow - rest;
}
int MaxFlow () {
	int res = 0;
	while (bfs()) res += dinic(S, INF);
	return res;
}
bool check (int mid) {
	fill(head, head+N+1, 0);
	tot = 1;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n+1; j++)
			if (s[i][j] == 'Y' && fa[i][j])
				AddEdge(i, j+n, 1);
	for (int i = 1; i <= n; i++) AddEdge(S, i, 1);
	for (int i = 1; i <= n; i++) AddEdge(n+i, T, mid);
	AddEdge(n+n+1, T, INF);
	return MaxFlow() >= n;
}
int BinarySearch (int l, int r) {
	while (l < r) {
		int mid = l + r >> 1;
		if (check(mid)) r = mid;
		else l = mid + 1;
	}
	return l;
}
int main () {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	memset(fa, 1, sizeof fa);
	cin >> n; S = 0, T = N = n+n+2; getchar();
	for (int i = 0; i <= n; i++) cin >> (s[i]+1);
	for (int i = 1; i <= n; i++) s[i][n+1] = s[0][i];
	int res = BinarySearch(0, n);
	for (int i = 1; i <= n; i++) {
		fill(fa[i], fa[i]+n+2, 0);
		for (int j = 1; j <= n+1; j++) if (s[i][j] == 'Y') {
			fa[i][j] = 1;
			if (check(res)) { ans[i] = j; break; }
			fa[i][j] = 0;
		}
	}
	for (int i = 1; i <= n; i++) cout << ans[i] - 1 << ' ';
	return 0;
}
```

---

## 作者：spdarkle (赞：2)

挺不错的问题。

一句话题意：给定一张有向无环图，要从中选出一棵有根树，树根为 $n$，使得**除树根之外**所有节点的儿子数中最大的最小。

$1\le n\le 50$。


可以看到最大的最小，显然可以二分答案。设二分值为 $k$。

问题化为在这张 DAG 里找出满足条件的一棵树。

我们运用“元认知”的思想（~~bushi~~），跳到一个高度去审视这个问题。

其实它**本质是一个匹配**，也即对于每一个节点，选出不超过 $k$ 条匹配边，使得构成一棵树。

但，相较于传统的二分图匹配，它又**没有左右部图的限制**，有且只**有父亲与儿子的关系**。

这时候，不难想到最小路径覆盖问题的解法。

注意到我们的匹配是相对独立的一个匹配，一个节点最多一个父亲，一个父亲最多 $k$ 个儿子。

那么我们就可以考虑**扩展域**的思想。将原图的点拆为儿子域与父亲域。

问题得以转化为每个点的儿子域都需要找到一个父亲域的点匹配，同时一个父亲域的点不得与超过 $k$ 个儿子域的点匹配。

这就是一个经典的网络流模型了。

我们将点拆为 $i,i+n$ 两部分，将源点与 $i$ 连边，容量为一，将 $i+n$ 与汇点连边，容量为 $k$，将原图中的 $(u,v)$ 变为 $v,u+n$，也即儿子向父亲连容量为一的边。

最后判断是否满流即可。

细节：注意到根节点不受限制，我们将其单独处理，只向汇点连容量为正无穷的边即可。

那么这一步判定答案做到了，怎么输出方案呢？

显然我们可以 $O(n^2)$ 枚举 $i,fa_i$，然后强行拆掉 $(i,fa_i)$ 这条边进行最大流判断满流。

这一步可以进行二分加速，为什么？如果我们将其所有可能可行的 $fa_i$，也即原图中点的入边全部拎出来，连边判断，是可以一次性做到判断答案是否在一个区间内的。则我们也可以使用二分 $mid$，然后按编号小到大保留前 $mid$ 个可能可行的 $fa_i$ 查找可行解。

不过没必要了，枚举的复杂度已经正确了。

[code](https://www.luogu.com.cn/paste/l1xvwm9t)

---

## 作者：lxyt_415x (赞：1)

[博客食用更佳](https://www.cnblogs.com/lxyt-415x/p/18242613/The-Second)

## 题意

从一个 $n$ 个结点的有向无环图里选出 $n-1$ 条边，构成一棵树，且 __除根节点以外的__ 点的儿子个数的最大值最小。

输出满足题意的节点的父亲，要求字典序最小。

## 思路

我们肯定要先把最小值求出来。

很容易看出是 拆点 + 二分答案求解，这里要注意的是拆完的两个点是不用连起来的，将做为儿子的点与源点连边，权值为 $1$ 来限制；作为父亲的点依据二分的值与汇点连边，剩下的边输入边连就行。

---

然后就是 $O(n^2)$ 的枚举来确定答案 ~~蒟蒻不会二分验证~~。

从 $1$ 开始遍历每一个点，先将之前连向可能父节点的边清空，再从小到大附上值并跑一遍最大流，如果可以就证明有解。

## 注意

这道题要保证字典序最小，而控制中心用 $n$ 表示，所以能连向控制中心的也可以连其他的。

## 代码

剩下要注意的就看代码吧，写了注释。

~~我好像是写的最麻烦的那个。~~

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10,inf=1e9;
int n,m,s,t,tot=1,ans,_,fa[N];
int head[N],nxt[N],to[N],val[N];
int dep[N],cur[N],g[N],gg[N],fl[N];
//_，g，gg 分别用于暂存 tot，val，head方便回溯 
vector<int>v[N],mp[N];
//Dinic 板子 
inline void add(int u,int v,int w)
{
	nxt[++tot]=head[u];
	head[u]=tot;
	to[tot]=v;
	val[tot]=w;
	return ;
}
inline void insert(int u,int v,int w)
{
	add(u,v,w);
	add(v,u,0);
	return ;
}
inline bool bfs()
{
	for(int i=1;i<=t;i++)
		dep[i]=0;
	queue<int>q;
	q.push(s);
	dep[s]=1;
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		cur[x]=head[x];
		for(int i=head[x],y;i;i=nxt[i])
		{
			y=to[i];
			if(val[i]&&!dep[y])
			{
				dep[y]=dep[x]+1;
				q.push(y);
			}
		}
	}
	return dep[t];
}
inline int dfs(int x,int flow)
{
	if(x==t)
		return flow;
	int res=flow;
	for(int i=cur[x],y,k;i&&res;i=nxt[i])
	{
		y=to[i];
		cur[x]=i;
		if(val[i]&&dep[y]==dep[x]+1)
		{
			k=dfs(y,min(res,val[i]));
			val[i]-=k;
			val[i^1]+=k;
			res-=k;
		}
	}
	return flow-res;
}
//暂存 
inline void init()
{
	for(int i=1;i<=tot;i++)
		g[i]=val[i];
	for(int i=1;i<=t;i++)
		gg[i]=head[i];
	_=tot;
	return ;
}
//回溯 
inline void tini()
{
	for(int i=1;i<=tot;i++)
		val[i]=g[i];
	for(int i=1;i<=t;i++)
		head[i]=gg[i];
	tot=_;
	return ;
}
int main()
{
	cin>>n;
	s=2*n+1;
	t=2*n+2;
	char ch;
	for(int i=1;i<=n;i++)
	{
		insert(s,i,1);
		cin>>ch;
		if(ch=='Y')
		{
			insert(i,t,1); //这里向汇点连边的时候也要存进 vector 里！！！ 
			v[i].push_back(t);
			mp[i].push_back(tot-1);
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			cin>>ch;
			if(ch=='Y')
			{
				insert(i,n+j,1);
				v[i].push_back(j);
				mp[i].push_back(tot-1);
			}
		}
	for(int i=1;i<=n;i++) //写的好唐，其实不用这样的 
		sort(v[i].begin(),v[i].end());
	init();
	int l=0,r=1000,mid,res;
	while(l<=r) // 二分求最小值 
	{
		mid=l+r>>1;
		for(int i=1;i<=n;i++)
			insert(n+i,t,mid);
		ans=0;
		while(bfs())
			ans+=dfs(s,inf);
		tini();
		if(ans==n)
		{
			r=mid-1;
			res=mid;
		}
		else
			l=mid+1;
	}
	for(int i=1;i<=n;i++)
		insert(n+i,t,res);
	for(int i=1;i<=n;i++)
	{
		for(auto it : mp[i])
			val[it]=0; //清空所有向可能父亲的连边 
		init();
		for(auto it : v[i])
		{
			int j=it==t?n+2:it;
			insert(i,n+j,1);
			ans=0;
			while(bfs())
				ans+=dfs(s,inf);
			tini();
			if(ans==n) //确定答案后把边加进去 
			{
				fa[i]=j;
				insert(i,n+j,1);
				init();
				break;
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(fa[i]==n+2) // 写的唐了，也不用这么写的 
			fa[i]--;
		printf("%d ",fa[i]-1);
	}
	return 0;
}
```

[附带数据生成器](https://www.luogu.com.cn/paste/lpt673ot)

---


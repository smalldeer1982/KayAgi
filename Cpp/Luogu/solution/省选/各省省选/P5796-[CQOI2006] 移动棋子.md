# [CQOI2006] 移动棋子

## 题目描述

在一个 $n\times n$ 的棋盘上有 $n$ 枚棋子。每次可以把一枚棋子往上、下、左、右方向之一移动一格，最后排成一行、一列或者主、副对角线上（因此一共有 $2n+2$ 条可能的目标状态），要求移动次数最小。

棋盘上有一些位置是障碍，棋子在任何时候都不能经过。棋子的初始位置保证不在障碍物上。任两枚棋子不能在同时到达同一个格子。
　　　　　　

## 说明/提示

【样例解释】

![](https://cdn.luogu.com.cn/upload/image_hosting/qs93n3f7.png)

【数据范围】

对于 $50\%$ 的数据，$n\le 15$，$m=0$；

对于 $100\%$ 的数据，$2\le n\le 50$，$0\le m\le 100$。

## 样例 #1

### 输入

```
5 1
1 2
2 4
3 4
5 1
5 3
1 1```

### 输出

```
6
```

# 题解

## 作者：Binary_Search_Tree (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/P5796)

这种匹配的问题一看就知道是网络流了吧qwq

因为$n$非常小。。。所以我们可以暴力枚举所有目标状态

然后从源点$S$向每一个初始节点连边权为$1$，费用为$0$的边

从每个目标节点向汇点$T$连一条边权为$1$，费用为$0$的边

对于每对$(i,j)$（$i$为第$i$个初始节点，$j$为第$j$个目标节点）

连一条边权为$1$，费用为最短路长度的边

最后跑最小费用最大流就可以了qwq

附上代码:

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
#include <queue>
#define INF 1000000000
#define M 10005
#define N 55
using namespace std;
int nxt[M],head[M],to[M],adj[M],cost[M],X[M],Y[M],XX[M],YY[M],nowX[M],nowY[M],dist[M],cur[M],F[N][N][N];
int mincost,tot,n,m,S,T,Ans=INF;
bool inq[M],vis[M],G[N][N];
int dx[10]={0,1,-1,0,0};
int dy[10]={0,0,0,1,-1};
int read(){//没什么用的快速读入
	int ans=0;char c=getchar();
	while (c<'0'||c>'9') c=getchar();
	while (c>='0'&&c<='9') ans=ans*10+c-'0',c=getchar();
	return ans;
}
void Write(int x){//没什么用的快速输出
	if (x<0) putchar('-'),x=-x;
	if (x<10) putchar(x^48);
	else Write(x/10),putchar((x%10)^48);
	return;
}
void add(int u,int v,int w,int Cost){
	nxt[tot]=head[u];head[u]=tot;to[tot]=v;adj[tot]=w;cost[tot]=Cost;tot++;
	nxt[tot]=head[v];head[v]=tot;to[tot]=u;adj[tot]=0;cost[tot]=-Cost;tot++;
	return;
}
bool SPFA(){
	for (register int i=S;i<=T;i++) dist[i]=INF,inq[i]=0;
	queue <int> Q;Q.push(T);inq[T]=1;dist[T]=0;
	while (!Q.empty()){
		int now=Q.front();Q.pop();inq[now]=0;
		for (register int i=head[now];~i;i=nxt[i])
			if (adj[i^1]>0&&dist[to[i]]>dist[now]-cost[i]){
				dist[to[i]]=dist[now]-cost[i];
				if (!inq[to[i]]) inq[to[i]]=1,Q.push(to[i]);
			}
	}
	return dist[S]<INF;
}
int dfs(int x,int low){
	vis[x]=1;if (x==T) return low;int used=0,a;
	for (register int &i=cur[x];~i;i=nxt[i])
		if (!vis[to[i]]&&adj[i]>0&&dist[to[i]]==dist[x]-cost[i]){
			a=dfs(to[i],min(low-used,adj[i]));
			if (a) adj[i]-=a,adj[i^1]+=a,mincost+=a*cost[i],used+=a;
			if (used==low) break;
		}
	return used;
}
int costflow(){
	int ans=0,a;
	while (SPFA()){
		vis[T]=1;
		while (vis[T]){
			for (register int i=S;i<=T;i++) cur[i]=head[i],vis[i]=0;
			while (a=dfs(S,INF)) ans+=a;
		}
	}
	return mincost;
}
int work(){
	memset(head,-1,sizeof(head));mincost=tot=0;//记得初始化
	for (register int i=1;i<=n;i++)
		if (G[nowX[i]][nowY[i]]) return INF;//判断目标状态是否合法
	for (register int i=1;i<=n;i++){
		add(S,i+1,1,0),add(i+n+1,T,1,0);
		for (register int j=1;j<=n;j++) add(i+1,j+n+1,1,F[i][nowX[j]][nowY[j]]);
	}
	return costflow();
}
void BFS(int x){//BFS找最短路
	queue <pair<int,int> > Q;
	for (register int i=1;i<=n;i++)
		for (register int j=1;j<=n;j++) F[x][i][j]=INF;
	F[x][X[x]][Y[x]]=0;Q.push(make_pair(X[x],Y[x]));
	while (!Q.empty()){
		pair <int,int> now=Q.front();Q.pop();
		for (register int i=1;i<=4;i++){
			int xx=now.first+dx[i],yy=now.second+dy[i];
			if (xx<1||xx>n||yy<1||yy>n||F[x][xx][yy]<INF||G[xx][yy]) continue;
			F[x][xx][yy]=F[x][now.first][now.second]+1;
			Q.push(make_pair(xx,yy));
		}
	}
	return;
}
int main(){
	n=read(),m=read();S=1,T=n+n+2;
	for (register int i=1;i<=n;i++) X[i]=read(),Y[i]=read();
	for (register int i=1,x,y;i<=m;i++) x=read(),y=read(),G[x][y]=1;
	for (register int i=1;i<=n;i++) BFS(i);
	for (register int i=1;i<=n;i++){
		for (register int j=1;j<=n;j++) nowX[j]=i,nowY[j]=j;
		Ans=min(Ans,work());
		for (register int j=1;j<=n;j++) nowX[j]=j,nowY[j]=i;
		Ans=min(Ans,work());
	}
	for (register int i=1;i<=n;i++) nowX[i]=nowY[i]=i;
	Ans=min(Ans,work());
	for (register int i=1;i<=n;i++) nowX[i]=i,nowY[i]=n+1-i;
	Ans=min(Ans,work());
	Write(Ans==INF?-1:Ans);//不要忘了输出-1
	return 0;
}
```

虽然代码长但不难写qwq

~~记得点赞啊~~

---

## 作者：jockbutt (赞：2)

## 前言

为洛谷社区做出贡献！

## 解法

首先一看这数据范围，感觉暴力能过，再看 $ n\leq 50$，一下便可以想到网络流。

枚举每一种最终情况，再将每一个棋子的原始位置和每一个终点之间都连一条流量为 $1$，费用为它们之间的最短距离的边，然后最小费用最大流一遍带走。

对于求最短距离，我们直接广搜一波。

另外，对于棋子挡道的问题，因为任意两个棋子是等价的，可以换位置，所以并不会对于距离带来影响。

## AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define INF 0x3f3f3f3f
#define inf 0x7f7f7f7f
int n,m,s,t,N;
const int maxn=2e6+10;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)) {if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch))  {x=x*10+ch-48;ch=getchar();}
    return x*f;
}
int to[maxn],cap[maxn],cost[maxn],head[maxn],nt[maxn],cnt;
int dis[maxn],incf[maxn],vis[maxn],pre[maxn],mincost,maxflow;
inline void addedge(int u,int v,int w,int c)
{
    to[++cnt]=v,cap[cnt]=w,cost[cnt]=c,nt[cnt]=head[u],head[u]=cnt;
    to[++cnt]=u,cap[cnt]=0,cost[cnt]=-c,nt[cnt]=head[v],head[v]=cnt;
}
inline void init() 
{
	memset(head,0,sizeof(head));cnt=1,mincost=maxflow=0;
    for(int i=1;i<=n;++i)   addedge(s,i,1,0),addedge(i+n,t,1,0);
}
inline int spfa()
{
    queue <int> que;
    for(int i=0;i<=N;++i)   vis[i]=0,dis[i]=INF;
    incf[s]=INF,dis[s]=0,vis[s]=1;que.push(s);
    while(!que.empty())
    {
        int u=que.front(),v;
        que.pop();vis[u]=0;
        for(int i=head[u];i;i=nt[i])
        {
            v=to[i];
            if(dis[v]<=dis[u]+cost[i]||!cap[i])  continue;
            dis[v]=dis[u]+cost[i],incf[v]=min(incf[u],cap[i]),pre[v]=i;
            if(!vis[v]) vis[v]=1,que.push(v);
        }
    }
    return dis[t]!=INF;
}
inline void mcmf()
{
    while(spfa())
    {
        int x=t,i;
        maxflow+=incf[t];
        mincost+=incf[t]*dis[t];
        while(x!=s)
        {
            i=pre[x];
            cap[i]-=incf[t],cap[i^1]+=incf[t];
            x=to[i^1];
        }
    }
}
int G[200][200],d[200][200][200];
struct point{
    int x,y;
}p[maxn];
int tx[5]={1,0,-1,0},ty[5]={0,1,0,-1};
inline void bfs(int S)
{
    queue <point> que;
    que.push(p[S]),d[p[S].x][p[S].y][S]=0;
    while(!que.empty())
    {
        int x=que.front().x,y=que.front().y,xx,yy;
        que.pop();
        for(int i=0;i<4;++i)
        {
            xx=x+tx[i],yy=y+ty[i];
            if(xx<1||xx>n||yy<1||yy>n||G[xx][yy]==1||d[xx][yy][S]<INF)    continue;
            d[xx][yy][S]=d[x][y][S]+1;
            que.push({xx,yy});
        }
    }
}
int ans=INF;
int Shu[maxn],Hen[maxn],X1,X2;
signed main(){
    n=read(),m=read(),N=t=2*n+1,s=0;
    for(int i=1;i<=n;++i)   p[i].x=read(),p[i].y=read();
    for(int i=1,a,b;i<=m;++i)  
	{
		a=read(),b=read(),G[a][b]=1,Hen[a]=1,Shu[b]=1;
		if(a==b)	X1=1;
		if(a==n-b+1)	X2=1;
	}
    memset(d,INF,sizeof(d));
    for(int i=1;i<=n;++i)   bfs(i);
    if(!X1)
    {
	    init();
	    for(int i=1;i<=n;++i)
	    	for(int j=1;j<=n;++j)	addedge(i,j+n,1,d[j][j][i]);
	    mcmf();
	    ans=min(ans,mincost);
	}
	if(!X2)
	{
	    init();
	    for(int i=1;i<=n;++i)
	    	for(int j=1;j<=n;++j)	addedge(i,j+n,1,d[j][n-j+1][i]);
	    mcmf();
	    ans=min(ans,mincost);
	}
    for(int k=1;k<=n;++k)
    {
    	if(!Shu[k])
    	{
	    	init();
		    for(int i=1;i<=n;++i)
		    	for(int j=1;j<=n;++j)	addedge(i,j+n,1,d[j][k][i]);
		    mcmf();
		    ans=min(ans,mincost);
		}
		if(!Hen[k])
		{
	    	init();
		    for(int i=1;i<=n;++i)
		    	for(int j=1;j<=n;++j)	addedge(i,j+n,1,d[k][j][i]);
		    mcmf();
		    ans=min(ans,mincost);
		}
	}
    printf("%d\n",ans<INF?ans:-1);
    return 0;
}
/*
这里提供一组较强的样例
5 2
1 2
2 4
3 4
5 1
5 3
5 2
4 3


9

*/


```

最后，说句闲话，这道题有着浓浓的远古题目风格——数据范围超小，情况又贼多，我最开始没有看到最终情况有 $2n+2$ 种，收货了逸一时误一世个 Wa。

---


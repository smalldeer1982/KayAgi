# [CQOI2010] 内部白点

## 题目描述

无限大正方形网格里有 $n$ 个黑色的顶点，所有其他顶点都是白色的（网格的顶点即坐标为整数的点，又称整点）。每秒钟，所有内部白点同时变黑，直到不存在内部白点为止。你的任务是统计最后网格中的黑点个数。

内部白点的定义：一个白色的整点 $P(x,y)$ 是内部白点当且仅当 $P$ 在水平线的左边和右边各至少有一个黑点（即存在$x_1 < x < x_2$ 使得 $(x_1,y)$ 和 $(x_2,y)$ 都是黑点），且在竖直线的上边和下边各至少有一个黑点（即存在 $y_1 < y < y_2$ 使得 $(x,y_1)$ 和 $(x,y_2)$ 都是黑点）。

## 说明/提示

**数据范围**

对于 $36\%$ 的数据，$n \le 500$。

对于 $64\%$ 的数据，$n \le 3 \times 10^4$。

对于 $100\%$ 的数据，$n \le 10^5$。

## 样例 #1

### 输入

```
4
0 2
2 0
-2 0
0 -2
```

### 输出

```
5
```

# 题解

## 作者：Azuree (赞：13)

根据题意，我们可以把位于同一行且左右相邻的点连成一条横边，把位于同一列且上下相邻的点连成一条竖边（这里的“相邻”指的是两个点在横向或竖向上之间没有输入给出的黑点，一个点可以参与多条边）。

比如，我们可以把一个图连成这样：

![1.png](https://i.loli.net/2020/08/03/b3cDwGWkYjuOvoJ.png)

那么，不难发现，能够变成黑点的白点都是位于线段交点上的点。

那么，如何去统计线段交点呢？

我们可以把可以把边分成两类：横向边（和x轴平行的边）和纵向边（和y轴平行的边）。于是，统计交点就等同于每条横向边于纵向 边交点个数的和。而对于这个和，我们可以用扫描线的方法求得。

---

大体思路是这样的：

如果扫描线是从上到下进行扫描的，则我们可以用~~线段树~~树状数组来记录有多少条纵向边经过了$y=k$。

为了方便理解，我们可以先用一个最普通的数组$t_{1,9}$来记录纵边经过点$y=k$的距离。如下图，若我们以$y=4$为例，则$t_{1,9}=0,1,0,0,0,0,1,0,0$，其中两个$1$表示的便是两个交点。而对于查询，交点数量便是线段GI、线段IH上交点数量的和。我们发现，如果直接在刚刚的数组$t_{1,9}$中统计，那么复杂度为$O(n)$。我们可以用树状数组来优化这一步，来完成这个本质上是区间求和的工作。

对于树状数组的修改，我们只需在纵边的第一个点被扫到时在数组的对应位置加一，在纵边的第二个点被扫到后在对应位置减一即可。

![2.png](https://i.loli.net/2020/08/03/XgIzO3UMpeAcDW8.png)

code:

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<queue>
#include<algorithm>
#define ll long long
#define INF 0x7fffffff
#define qwq printf("qwq\n");

using namespace std;

int read() {
    register int x = 0,f = 1;register char ch;
    ch = getchar();
    while(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}
    while(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}
    return x * f;
}

struct node {
	int x, y;
}u[400005];

struct edge {
	int up, down, left, right;
}e[400005];

struct edge_end {
	int x, y;
	bool operator < (const edge_end &a) const {return a.y < y;}
};

int n, m, cnt, ans, maxx, a[400005], t[400005];

priority_queue<edge_end> que;

void Read_in() {
	n = read();
	for(int i = 1; i <= n; i++) {
		u[i].x = read(); u[i].y = read();
		a[++cnt] = u[i].x; a[++cnt] = u[i].y;
	}
}

void Discretization() {
	sort(a + 1, a + cnt + 1);
	cnt = unique(a + 1, a + cnt + 1) - a - 1;
	for(int i = 1; i <= n; i++) {
		u[i].x = lower_bound(a + 1, a + cnt + 1, u[i].x) - a;
		u[i].y = lower_bound(a + 1, a + cnt + 1, u[i].y) - a;
		maxx = max(maxx, u[i].x);
	}
}

bool xsort(node a, node b) {return a.x == b.x ? a.y < b.y : a.x < b.x;}
bool ysort(node a, node b) {return a.y == b.y ? a.x < b.x : a.y < b.y;}
bool esort(edge a, edge b) {return a.up == b.up ? a.left < b.left : a.up < b.up;}

void Make_edge() {
	sort(u + 1, u + n + 1, xsort);    // x 相同    处理竖边 
	for(int i = 1; i < n; i++) {
		if(u[i + 1].x != u[i].x || u[i + 1].y - u[i].y < 2) continue;
		e[++m].up = u[i].y + 1; e[m].down = u[i + 1].y - 1; e[m].right = u[i].x;
	}
	sort(u + 1, u + n + 1, ysort);    // y 相同    处理横边 
	for(int i = 1; i < n; i++) {
		if(u[i + 1].y != u[i].y || u[i + 1].x - u[i].x < 2) continue;
		e[++m].up = u[i].y; e[m].left = u[i].x + 1; e[m].right = u[i + 1].x - 1;
	}
	sort(e + 1, e + m + 1, esort);
}

int lowbit(int x) {return x & -x;}
void update(int x, int k) {while(x <= maxx) {t[x] = t[x] + k; x = x + lowbit(x);}}
int query(int x) {int ans = 0; while(x) {ans = ans + t[x]; x = x - lowbit(x);} return ans;}

void Scanning() {
	for(int i = 1; i <= m; i++) {
		int deep = e[i].up;
		while(!que.empty() && que.top().y <= deep) {update(que.top().x, -1); que.pop();}
		if(!e[i].left) {update(e[i].right, 1); que.push((edge_end){e[i].right, e[i].down + 1});}
		else {ans = ans + query(e[i].right) - query(e[i].left - 1);}
	}
}

void Print() {printf("%d\n", ans + n);}

int main() {
	Read_in();
	Discretization();
	Make_edge();
	Scanning();
	Print();
    return 0;
}
```



---

## 作者：BFqwq (赞：11)

# 题解 CQOI2010 内部白点
（$update$ 修改了一些错误）

一直感觉这是一道好题，可惜洛谷一直没有题面qaq      

终于在这两天我看到了题面。于是赶紧交了一发。
## 思考

按照题目的规定，当且仅当上下左右各有一个黑点时，该点变成黑点。

其实我们可以将它转化一下，把他直接与最上，最下，最左，最右的点比较，

因为如果最边上的点也不能包住这个点，那么这个点就一定是白点了。

紧接着，我们发现，这其实就是一个二维偏序qaq

（不过要是不懂二维偏序也没关系，接下来我会讲解）
## 正解
首先，我们需要将所有的点排序，按照$y$由大到小。

这样做的好处是：我们只需要维护一个维度。

我们记录一下每一列最高的点与最低的点，然后从上往下扫描所有的点。

然后开一棵线段树进行维护（树状数组也可以），

要是我们扫到了一个点，这个点就是这一列的上界，那么我们就在线段树中将这一列的权值加一。

同样的要是扫到了一个点是这一列的下界，那么就减一。

举个例子，如果$(3,5)$是$x=3$这一列最高的点，那么我们就把线段树的$3$号位置的值$+1$。

再扫到$(3,3)$既不是$x=3$这一列最高的点，又不是最低的点，那么我们不动它。

最后扫到$(3,1)$，这是$x=3$这一列最低的点，那么我们就把线段树的$3$号位置$-1$。

这样一来，线段树中某个点某时刻有值，当且仅当它上面有点且它下面有点。

然后在扫描的过程中，记录该一行的最左节点与最右节点，

在扫描完这一行的所有节点时，查询一次区间和，这样就查询到了这一行所有的黑点。

最后，边界的地方加一点处理，然后再对$x$进行一下离散化（否则线段树会炸）就完成啦！

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read(){
	register int x=0;
	register bool f=0;
	register char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=100005;
const int inf=1000000007;
int t[maxn<<4],n,m,lsh[maxn],sj[maxn],xj[maxn],nl,nr,res;
//lsh为离散数组，sj上界，xj下界，t线段树，nl为当前行最左点的x坐标
struct _node{
	int x,y;
	friend bool operator <(_node aa,_node bb){
		if(aa.y==bb.y) return aa.x<bb.x;
		return aa.y>bb.y;
	}//在这边我排序的时候顺便以x为第二变量排了一下，方便下面的处理
}node[maxn];
void change(int o,int l,int r,int q,int v){
	t[o]+=v;
	if(l==r) return;
	int mid=l+r>>1;
	if(q<=mid) change(o<<1,l,mid,q,v);
	else change(o<<1|1,mid+1,r,q,v);
}//标准线段树修改操作
int query(int o,int l,int r,int ql,int qr){
	if(ql<=l && r<=qr) return t[o];
	int ans=0,mid=l+r>>1;
	if(ql<=mid) ans+=query(o<<1,l,mid,ql,qr);
	if(qr>mid) ans+=query(o<<1|1,mid+1,r,ql,qr);
	return ans;
}//标准线段树查询操作
signed main(){
	n=read();
	for(int i=1;i<=n;i++){
		node[i].x=read();node[i].y=read();
		lsh[i]=node[i].x;
		sj[i]=-inf;xj[i]=inf;
	}
	sort(node+1,node+n+1);
	sort(lsh+1,lsh+n+1);
	m=unique(lsh+1,lsh+n+1)-1-lsh;
	for(int i=1;i<=n;i++){
		node[i].x=lower_bound(lsh+1,lsh+m+1,node[i].x)-lsh;
		sj[node[i].x]=max(node[i].y,sj[node[i].x]);
		xj[node[i].x]=min(node[i].y,xj[node[i].x]);
	}
	nl=node[1].x;
	node[n+1].y=inf;
  //防止node[n].y=0的情况的影响
	for(int i=1;i<=n;i++){
		if(node[i].y==sj[node[i].x]) change(1,1,m,node[i].x,1);
		if(node[i].y==xj[node[i].x]){
			res+=1;change(1,1,m,node[i].x,-1);
		}//我在删除的时候先把点加上，防止该点漏记
		if(node[i].y!=node[i+1].y){
			res+=query(1,1,m,nl,node[i].x);
			nl=node[i+1].x;
		}//这一行结束，统计答案
	}
	printf("%d",res);
	return 0;
}
```
推荐难度紫题（其实蓝紫都行啦，紫题可能有点偏简单了qaq）

祝大家wc/noi/csps/高考rp++！

---

## 作者：Sol1 (赞：8)

## Problem:

一个平面，给一堆点，每次往平面上面加点，要求加的点必须上下左右都有点，问没法再加点的时候有多少个点。如果能加无穷多个点输出 $-1$。

## Analysis:

首先我们发现这个东西很难搞。。因为你可能变化多次。

但是我们尝试构造一下就会发现很难构造出需要多次变化的。

于是就猜测可能只会变化一次。

稍微证一下：

如果存在一个点 $A$ 的加入涉及到点 $B$，且 $B$ 不是一开始就有的，那么 $A$ 的上下左右中的一个方向上肯定只有点 $B$，但是这样点 $B$ 的那个方向上就没有点，无法加入，同时点 $A$ 也就不存在，矛盾。

所以结论就是只会变化一次。。而且没有 $-1$ 。。

~~所以说这题一开始是个结论题。。。~~

现在我们考虑怎么统计有多少个点是新加入进来的。

我们发现产生贡献的一定是两个同横坐标的点的连线，所以考虑扫描线。

为了避免有一个给出的点满足上下左右都有点，只去考虑相邻（中间没有点）的两个点的连线。

然后就可以愉快的扫描线了：维护所有垂直和水平的线，对于垂直的线可以对应到单点 $+1/-1$；对于水平的线可以对应为区间求和。

离散化一下就可以树状数组啦~

那么这题就做完啦~

总时空复杂度 $O(n\log n)+O(n)$。

代码：

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline int Abs(const int& x) {return (x > 0 ? x : -x);}
inline int Max(const int& x, const int& y) {return (x > y ? x : y);}
inline int Min(const int& x, const int& y) {return (x < y ? x : y);}

struct Line {
	int x, y, rx, type;
	bool operator < (const Line& l) const {
		return (y == l.y ? type < l.type : y < l.y);
	}
};
struct Point {
	int x, y;
};
int n, x[100005], y[100005], xd[100005], yd[100005], xdtop, ydtop, lcnt, c[100005];
Line lne[300005];
Point pnt[100005];

inline bool cmp1(const Point& a, const Point& b) {
	return (a.x == b.x ? a.y < b.y : a.x < b.x);
}

inline bool cmp2(const Point& a, const Point& b) {
	return (a.y == b.y ? a.x < b.x : a.y < b.y);
}

inline int Lowbit(int x) {
	return x & -x;
}

inline void Modify(int i, int x) {
	for (register int j = i;j <= 100000;j += Lowbit(j)) c[j] += x;
}

inline int Query(int i) {
	register int ans = 0;
	for (register int j = i;j >= 1;j -= Lowbit(j)) ans += c[j];
	return ans;
}

inline void Read() {
	n = qread();
	for (register int i = 1;i <= n;i++) {
		x[i] = xd[i] = qread();
		y[i] = yd[i] = qread();
	}
}

inline void Prefix() {
	sort(xd + 1, xd + n + 1);
	sort(yd + 1, yd + n + 1);
	xdtop = unique(xd + 1, xd + n + 1) - xd - 1;
	ydtop = unique(yd + 1, yd + n + 1) - yd - 1;
	for (register int i = 1;i <= n;i++) {
		x[i] = lower_bound(xd + 1, xd + xdtop + 1, x[i]) - xd;
		y[i] = lower_bound(yd + 1, yd + ydtop + 1, y[i]) - yd;
	}
	for (register int i = 1;i <= n;i++) {
		pnt[i].x = x[i];
		pnt[i].y = y[i];
	}
	sort(pnt + 1, pnt + n + 1, cmp2);
	for (register int i = 1;i < n;i++) {
		if (pnt[i].y == pnt[i + 1].y) {
			lne[++lcnt].x = pnt[i].x;
			lne[lcnt].y = pnt[i].y;
			lne[lcnt].rx = pnt[i + 1].x;
			lne[lcnt].type = 0;
		}
	}
	sort(pnt + 1, pnt + n + 1, cmp1);
	for (register int i = 1;i < n;i++) {
		if (pnt[i].x == pnt[i + 1].x) {
			lne[++lcnt].x = pnt[i].x;
			lne[lcnt].y = pnt[i].y;
			lne[lcnt].rx = 0;
			lne[lcnt].type = 1;
			lne[++lcnt].x = pnt[i].x;
			lne[lcnt].y = pnt[i + 1].y;
			lne[lcnt].rx = 0;
			lne[lcnt].type = -1;
		}
	}
	sort(lne + 1, lne + lcnt + 1);
}

inline void Solve() {
	register int ans = n;
	for (register int i = 1;i <= lcnt;i++) {
		if (lne[i].type == 0) ans += Query(lne[i].rx - 1) - Query(lne[i].x);
		else Modify(lne[i].x, lne[i].type);
	}
	printf("%d", ans);
}

int main() {
	Read();
	Prefix();
	Solve();
	#ifndef ONLINE_JUDGE
	while (1);
	#endif
	return 0;
}
```



---

## 作者：ez_lcw (赞：7)

先把所有点的$x$坐标离散化。

然后分别将所有点按$x$、$y$排序。这里以按$x$排序为例，对于$x$坐标相同的两个点，我们把它们连成一条线段。那么按$y$坐标排序也一样，把$y$坐标相同的两个点也连成一条线段。

那么连出来后的图就是这样的：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191003112614918.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2V6X2xjdw==,size_16,color_FFFFFF,t_70)

那么横竖线段的所有交点（图中蓝点）即为可以变dark的点，因为它左右有dark点，上下都有dark点，符合变dark条件。

那么我们怎么维护交点呢？我们考虑用扫描线（如图黑线）。

我们先把横线、竖线的两个端点全部塞进一个数组里，然后把它们按$y$坐标排序。

然后从$y$坐标的小到大一个一个向上扫描，分3种情况讨论：

1. 如果扫描到一条竖线的下端点$(x,y)$，那么我们把树状数组里的位置$x$加$1$，即$add(x,1)$。

2. 如果扫描到一条竖线的上端点$(x,y)$，那么我们把树状数组里的位置$x$减$1$，即$add(x,-1)$。那么对于某一条竖线$l$，其上端点为$(x,y_1)$，下端点为$(x,y_2)$，我们就能保证当扫描线在区间$[y_1,y_2]$时树状数组中位置$x$会$+1$。

3. 如果扫描到一条横线，且两端点横坐标为$x_1$、$x_2$（$x_1<x_2$），我们只要查询$query(x_2)-query(x_1-1)$就可以得到这条线段上与其它竖线的交点坐标了，不过由于竖线与横线两端点的交点不能算进去，所以应该查询$query(x_2-1)-query(x_1)$。

那么最后答案就是所有交点的个数了。

代码如下：

```cpp
#include<bits/stdc++.h>
 
#define N 100010
 
using namespace std;
 
struct Point
{
    int x,y;
}p[N];
 
struct Line 
{
    int opt,x,r,y;//1 竖线下端点 0 横线 -1 竖线上端点
}l[N*10];
 
int n,ans,cnt,b[N],c[N];
 
 //树状数组
int lowbit(int x)
{
    return x&-x;
}
 
void add(int x,int y)
{
    for(;x<=n;x+=lowbit(x))c[x]+=y;
}
 
int query(int x)
{
    int ans=0;
    for(;x;x-=lowbit(x))ans+=c[x];
    return ans;
}
 
bool cmpx(Point a,Point b){return a.x==b.x?a.y<b.y:a.x<b.x;}
bool cmpy(Point a,Point b){return a.y==b.y?a.x<b.x:a.y<b.y;}
bool cmpLine(Line a,Line b){return a.y==b.y?a.opt<b.opt:a.y<b.y;}
 
void work()
{
    sort(p+1,p+n+1,cmpx);
    for(int i=1;i<n;i++)
    {
        if(p[i].x==p[i+1].x)
        {
            l[++cnt]=(Line){1,p[i].x,0,p[i].y};
            l[++cnt]=(Line){-1,p[i].x,0,p[i+1].y};
        }
    }
    sort(p+1,p+n+1,cmpy);
    for(int i=1;i<n;i++)
        if(p[i].y==p[i+1].y)
            l[++cnt]=(Line){0,p[i].x,p[i+1].x,p[i].y};
}
 
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&p[i].x,&p[i].y);
        b[i]=p[i].x;
    }   
    sort(b+1,b+n+1);//离散化
    int tot=unique(b+1,b+n+1)-b-1;
    for(int i=1;i<=n;i++)
        p[i].x=lower_bound(b+1,b+tot+1,p[i].x)-b;
  	work();//加入线段
    sort(l+1,l+cnt+1,cmpLine);//扫描
    for(int i=1;i<=cnt;i++)
    {
        if(!l[i].opt)ans+=query(l[i].r-1)-query(l[i].x);
        else add(l[i].x,l[i].opt);
    }
    printf("%d\n",ans+n);
    return 0;
}
```


---

## 作者：Arghariza (赞：3)

upd : 删了恶臭代码，加入题目结论证明。

没想清楚之前千万别写代码，这道题我交了 $3$ 页……

有个显然的事情是内部白点全在且仅在形如 $l_1:y=y_0$ 和 $l_2:x=x_0$ 上，且需满足 $\exists i\neq j,n\neq m,x_i=x_j=x_0,y_n=y_m=y_0$，而这些白点会在第一秒就被染色。

算了，证明一下吧。

如果存在一个第二秒才被染色的白点，这个白点必定由一个第一秒加入的黑点和另外三个方向上的黑点决定染色。然而这个黑点被染色的条件是四个方向都有黑点，所以这个白点沿这个黑点的方向一定有一个初始的黑点，这样这个白点在第一秒时就能够被染黑，所以矛盾。

于是你考虑统计任意两条水平和竖直线段的交点个数。

如果把竖直线段当作修改，我们只需要给每个横坐标上线段上所有的点 $+1$，对于每个纵坐标 $y$ 上的水平线段查询 $(x_l,y)$ 到 $(x_r,y)$ 的和即可，显然可以使用树套树解决。

于是在 `9:24` 我交了一发树状数组套线段树的代码，但是在第 $4$ 个点 $\mathtt{MLE}$ 了。

然后我花了 $2\text{h}$ 的时间卡常 + 优化，首先把离散化数组改成了 `vector`，然后把线段树的左右儿子都压在了一个 `long long` 整数里面，还有一堆奇怪的优化。但是最后还是过不了，甚至还搞出来不知道什么奇怪的问题。

正在摆烂的时候，神仙 [$\mathtt{\color{black}s\color{red}insop90}$](https://www.luogu.com.cn/user/141599) 跑过来跟我口胡了离线做法。

还是刚刚的思路，在线段修改的基础上，考虑扫描线差分。我们把线段修改 $(x,y_l)$ 到 $(x,y_r)$ 改成给 $(x,y_l)+1$，并且给 $(x,y_r+1)-1$。查询 $(x_l,y)$ 到 $(x_r,y)$ 的线段和即查询 $(x_l,0)$ 到 $(x_r,y)$ 的矩阵和，根据套路拆成两个前缀矩阵查询。

于是这题变成了单点修改、矩阵求和，按照 $x$ 坐标从小到大排序，用扫描线维护即可。

时间 $O(n\log n)$，空间 $O(n)$。

扫描线做法：

```cpp
#include <bits/stdc++.h>
namespace mystd {
	inline int read() {
	    char c = getchar();
	    int x = 0, f = 1;
	    while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();
	    while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + c - '0', c = getchar();
	    return x * f;
	}
	inline void write(int x) {
	    if (x < 0) x = ~(x - 1), putchar('-');
	    if (x > 9) write(x / 10);
	    putchar(x % 10 + '0');
	}
}
using namespace std;
using namespace mystd;

const int maxn = 1e5 + 100;
struct node { int x, y; } s[maxn];
struct qry { int x, y, op; } q[maxn << 1];
int n, len, cnt, ans, tr[maxn << 1];
vector<int> b;

int lowbit(int x) { return x & (-x); }
void modify(int x, int y) { for (int i = x; i <= len; i += lowbit(i)) tr[i] += y; }
int query(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; }
 
int main() {
	scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d%d", &s[i].x, &s[i].y), b.push_back(s[i].x), b.push_back(s[i].y);
    sort(b.begin(), b.end()), b.erase(unique(b.begin(), b.end()), b.end()), len = b.size();
    for (int i = 1; i <= n; i++) s[i].x = lower_bound(b.begin(), b.end(), s[i].x) - b.begin() + 1, s[i].y = lower_bound(b.begin(), b.end(), s[i].y) - b.begin() + 1;
    sort(s + 1, s + n + 1, [](const node &x, const node &y) { return x.y == y.y ? x.x < y.x : x.y < y.y; });
    for (int i = 1, j; i <= n; i++) {
    	if (s[i].y != s[i - 1].y) {
    		for (j = i; j <= n && s[i].y == s[j].y; j++) ;
    		j--, q[++cnt] = (qry) { s[j].x, s[i].y, 1 }, q[++cnt] = (qry) { s[i].x - 1, s[i].y, -1 };
		} 
	}
    sort(s + 1, s + n + 1, [](const node &x, const node &y) { return x.x == y.x ? x.y < y.y : x.x < y.x; });
    sort(q + 1, q + cnt + 1, [](const qry &x, const qry &y) { return x.x == y.x ? x.y < y.y : x.x < y.x; });
    for (int i = 1, cur = 0; i <= cnt; i++) {
    	while (cur < n && s[cur + 1].x <= q[i].x) {
    		int j; cur++;
    		for (j = cur; j <= n && s[j].x == s[cur].x; j++) ;
    		j--, modify(s[cur].y, 1), modify(s[j].y + 1, -1), cur = j;
		}
		ans += query(q[i].y) * q[i].op;
	} 
	write(ans);
	return 0;
}
```

最后放一下树套树的做法，对拍几组后发现有些数据答案是错的，所以**仅供参考**：

[code](https://www.luogu.com.cn/paste/om8z348p)

---

## 作者：IcyFoxer_XZY (赞：3)

#### [题目传送门](https://www.luogu.com.cn/problem/P5816)

扫描线的做法这里不说了，挺多题解都讲的挺不错的。这里分享一个**主席树**的写法。

首先我们明确的是，第一步变化之后，整个图就不会变了。为什么呢，第二步才改变的点 $q$ 肯定是因为第一步改变的某个点 $p$ 或者好几个点变成黑点才改变的。如果 $q$ 因为 $p$ 而改变且 $p$ 在 $q$ 的水平左侧，那么 $p$ 左侧肯定还有点，因为 $p$ 是第一步变成黑点的点，那么在此情况下， $q$ 第一步也应当变成黑点，不应该等到第二次才变化。其他几个方向或者多个点的情况是同理的。也就是说第二步整个图就不会发生变化了，因此以后永远也不会再变化。

那么会从白变黑的点肯定是夹在两个 $y$ 相等的相邻点中间的点，现将这两个相邻点表示为 $(x_1,y)$ 和 $(x_2,y)$ ,那么我们只要对每一对这样的相邻点去求答案最后加和就可以了。那么其中间的点可以表示为 $\left\{(x,y)|x\in\left[x_1+1,x_2-1\right]\right\}$ ,那么这里有多少个点可以变成黑点其实也就是对于这里的每个 $x$ ，去看是否其上下分别至少都存在一个点，但是我们发现这样不好计算，于是我们反过来算，我们算有多少个不满足条件。不满足条件就是，对于 $x$ 这一列来说，要么只有 $y$ 的上方没有点，要么只有下侧没有点，要么都没。那么我就想：

1. 以纵轴为时间轴建立主席树，可以算出 $y$ 上方在 $[x_1+1,x_2-1]$ 内有多少种 $x$ ，那么用总的种类数减一下，也就可以算出缺了多少种 $x$ ，也就算出了 $y$ 的上方有多少纵列是空的。

1. 再以纵轴为时间轴反向建立主席树，就可以得到 $y$ 的下方在 $[x_1+1,x_2-1]$ 内有多少种 $x$ ，也可计算出 $y$ 下方有多少纵列是空的。

1. 然后我们用正向建立还是反向建立的主席树都可得到对于全局在 $[x_1+1,x_2-1]$ 内有多少种 $x$ ，同理算出全局   $[x_1+1,x_2-1]$ 内有多少纵列是空的。

这里我们将前两项相加减去第三项算出 $[x_1+1,x_2-1]$ 内，有多少纵列要么 $y$ 上面是空的，要么 $y$ 下面是空的，要么 $y$ 的上下全是空的。说白了我们就算出了无法变成黑点的情况，那么减一下，不就变成了可以变成黑点的情况。

注意这里用主席树没用使用区间求值的操作，因为种类数不满足前缀相减的性质，所以这里正反建了两颗主席树。

这里不贴代码了，Bye！

---

## 作者：pitiless0514 (赞：3)


## 【解析】

好题。

拿到题目首先先看一下它的无解情况是怎么判断的。

然后很明显这个是不存在无解情况的。

因为它的黑点开始都是给定了的，可以理解为一个边界。

而新的变化的黑点不会往外扩张，那么也就意味着边界不会扩大。

边界不会扩大，那么变色过程就会终止。

然后考虑按着题目里的意思来看，你就会发现一个白点变为黑点，始终实在两个横坐标相同的点之间的。

这可以抽象为一根竖线，然后这个时候你发现只要出现了一根水平的线就对答案有贡献了。

那么，你就可以使用一种扫描线的过程。

对于竖线就是扫到上端点就执行单点减的过程，扫到下断点就单点加。

对于横线就直接区间查找一波，等价于寻找与它有交点的竖线个数。

然后就没了，不过坐标可能为负，所以需要离散化。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
template<typename T> inline void read(T &x){T f=1;x=0;char ch=getchar();while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}x*=f;}
const int N  = 6e5;
int n,xx[N],yy[N],c[N],ans,m1,m2,num;
struct node{int x,y;}a[N];
struct line{int x,y,rx,type;}l[N];
int mp(line x,line y){
	if(x.y==y.y) return x.type<y.type;
	else return x.y<y.y;
}
int cmp(node x,node y){if(x.y!=y.y)return x.y<y.y; return x.x<y.x;}
int comp(node x,node y){if(x.x!=y.x) return x.x<y.x;return x.y<y.y;}
int lowbit(int x){return x&(-x);}
void change(int x,int val){
	for(int i=x;i<=N;i+=lowbit(i)) c[i]+=val;
}
int ask(int x){
	int ans=0;
	for(int i=x;i;i-=lowbit(i)) ans+=c[i];
	return ans;
}
void work(){
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<n;i++){
		if(a[i].y==a[i+1].y){
			l[++num].x=a[i].x;l[num].y=a[i].y;
			l[num].rx=a[i+1].x;l[num].type=0;
		}
	}
	sort(a+1,a+n+1,comp);
	for(int i=1;i<n;i++){
		if(a[i].x==a[i+1].x){
			l[++num].x=a[i].x;l[num].y=a[i].y;l[num].type=1;
			l[++num].x=a[i].x;l[num].y=a[i+1].y;l[num].type=-1;
		}
	}
	sort(l+1,l+num+1,mp);
}
signed main(){
	read(n);
	for(int i=1;i<=n;i++) read(a[i].x),read(a[i].y),xx[i]=a[i].x,yy[i]=a[i].y;
	sort(xx+1,xx+n+1);sort(yy+1,yy+n+1);
	m1=unique(xx+1,xx+n+1)-1-xx;
	m2=unique(yy+1,yy+n+1)-1-yy;
	for(int i=1;i<=n;i++){
		int val=lower_bound(xx+1,xx+m1+1,a[i].x)-xx;a[i].x=val;
		val=lower_bound(yy+1,yy+m2+1,a[i].y)-yy;a[i].y=val;
	}
	work();
	ans=n;
	for(int i=1;i<=num;i++){
		if(!l[i].type){
			ans+=ask(l[i].rx-1)-ask(l[i].x);
		}
		else{
			change(l[i].x,l[i].type);
		}
	}
	cout<<ans;
	return 0;
}
```




---

## 作者：louhao088 (赞：2)

## 思路

我们认真观察此题，发现内部白点只有可能出现一次，即只需变一次

简单证明：

我们知道内部白点的定义为一个白色的整点$ P(x,y)$ 是内部白点当且仅当 $P$在水平线的左边和右边各至少有一个黑点（即存在$x_1 < x < x_2$使得 $(x_1,y)$和$(x_2,y)$ 都是黑点），且在竖直线的上边和下边各至少有一个黑点（即存在$ y_1 < y <y_2$ 使得$ (x,y_1)$ 和 $(x,y_2)$
都是黑点)

故在一个内部白点所在行列必定已经有大于等于$2$个黑子，这颗新的黑子不会对答案产生影响



------------

接下来就是如何寻找内部白点，我们使用树状数组（当然也可以使用线段树）

首先要先把$x,y$坐标离散，由于不能放在原来黑子位置，所以在原位置要分是否相邻，相邻为$+1$,不相邻为$+2$;

```cpp
sort(a+1,a+n+1);cnt=unique(a+1,a+n+1)-a-1;f1[1]=1;
for(int i=2;i<=cnt;i++)
	if(a[i]==a[i-1]+1)f1[i]=f1[i-1]+1;
	else f1[i]=f1[i-1]+2;
for(int i=1;i<=n;i++)b[i].x=f1[lower_bound(a+1,a+1+cnt,b[i].x)-a];
sort(d+1,d+n+1);un=unique(d+1,d+n+1)-d-1;f2[1]=1;
for(int i=2;i<=un;i++)
	if(d[i]==d[i-1]+1)f2[i]=f2[i-1]+1;
   else f2[i]=f2[i-1]+2;
for(int i=1;i<=n;i++) b[i].y=f2[lower_bound(d+1,d+1+un,b[i].y)-d];
```


------------

然后把横轴竖轴排序记录

```cpp
sort(b+1,b+n+1,cmp);
for(int i=1;i<n;i++)
	if(b[i].y==b[i+1].y)line[++tot].l=b[i].x,line[tot].r=b[i+1].x,line[tot].y=b[i].y; 
sort(b+1,b+n+1,cnp);int sum=0;
for(int i=1;i<n;i++)
	if(b[i].x==b[i+1].x)
	{
		lin[++sum].x=b[i].x,lin[sum].y=b[i].y,lin[sum].num=1,
		lin[++sum].x=b[i].x,lin[sum].y=b[i+1].y,lin[sum].num=-1;
	} 
```



------------
用树状数组得出答案

```cpp
for(int i=1;i<=tot;i++)
{
	while(lin[cntt].y<line[i].y&&cntt<=sum)
		add(lin[cntt].x,lin[cntt].num),cntt++;
	while(lin[cntt].y==line[i].y&&cntt<=sum&&lin[cntt].num==-1)
		add(lin[cntt].x,lin[cntt].num),cntt++;
	ans+=query(line[i].r-1)-query(line[i].l);
} 
```


------------

完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define lowbit(x) x&(-x) 
const int maxn=1000005;
inline int read()
{
	char ch=getchar();int x=0;bool f=0;
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	if(f==1)return -x;return x;
}
int n,m,a[maxn],x,y,xx,yy,tot=0,ans=0,z=0,c[maxn],d[maxn],un,cnt,f1[maxn],f2[maxn];
struct tree{int sum,num,len,tagl,tagr;}tr[maxn*4];
struct node{int l,r,y;}line[maxn];
struct nod{int x,y;}b[maxn];
struct nodd{int x,y,num;}lin[maxn];
bool cmp(nod a,nod b){if(a.y==b.y)return a.x<b.x;return a.y<b.y;}
bool cnp(nod a,nod b){if(a.x==b.x)return a.y<b.y;return a.x<b.x;}
bool cpp(nodd a,nodd b){if(a.y==b.y)return a.num<b.num;return a.y<b.y;}
void add(int x,int num){for(int i=x;i<=cnt*2;i+=lowbit(i))c[i]+=num;}
int query(int x){int res=0;for(int i=x;i;i-=lowbit(i))res+=c[i];return res;}
signed main()
{
	n=read();ans=n;
	for(int i=1;i<=n;i++)a[i]=b[i].x=read(),d[i]=b[i].y=read();
	sort(a+1,a+n+1);cnt=unique(a+1,a+n+1)-a-1;f1[1]=1;
	for(int i=2;i<=cnt;i++)if(a[i]==a[i-1])f1[i]=f1[i-1];
	else if(a[i]==a[i-1]+1)f1[i]=f1[i-1]+1;else f1[i]=f1[i-1]+2;
	for(int i=1;i<=n;i++)b[i].x=f1[lower_bound(a+1,a+1+cnt,b[i].x)-a];
	sort(d+1,d+n+1);un=unique(d+1,d+n+1)-d-1;f2[1]=1;
	for(int i=2;i<=un;i++)if(d[i]==d[i-1])f2[i]=f2[i-1];
	else if(d[i]==d[i-1]+1)f2[i]=f2[i-1]+1;else f2[i]=f2[i-1]+2;
	for(int i=1;i<=n;i++) b[i].y=f2[lower_bound(d+1,d+1+un,b[i].y)-d];
	sort(b+1,b+n+1,cmp);
	for(int i=1;i<n;i++)
		if(b[i].y==b[i+1].y)line[++tot].l=b[i].x,line[tot].r=b[i+1].x,line[tot].y=b[i].y; 
	sort(b+1,b+n+1,cnp);int sum=0;
	for(int i=1;i<n;i++)
		if(b[i].x==b[i+1].x)
		{
			lin[++sum].x=b[i].x,lin[sum].y=b[i].y,lin[sum].num=1,
			lin[++sum].x=b[i].x,lin[sum].y=b[i+1].y,lin[sum].num=-1;
		} 
	sort(lin+1,lin+sum+1,cpp);int cntt=1;
	for(int i=1;i<=tot;i++)
	{
		while(lin[cntt].y<line[i].y&&cntt<=sum)
			add(lin[cntt].x,lin[cntt].num),cntt++;
		while(lin[cntt].y==line[i].y&&cntt<=sum&&lin[cntt].num==-1)
			add(lin[cntt].x,lin[cntt].num),cntt++;
		ans+=query(line[i].r-1)-query(line[i].l);
	} 
	cout<<ans;
	return 0;
}
```
























---

## 作者：zhiyangfan (赞：2)

## P5816 [CQOI2010]内部白点 题解
为了纪念一次 AC，写点对这道题的浅薄理解。
> [P5816 [CQOI2010]内部白点](https://www.luogu.com.cn/problem/P5816)
>
> 在一个平面直角坐标系内，定义格点分为黑白两种状态。初始时有 $n$ 个黑点，剩下的格点均为白色，之后不断执行以下过程：
> - 对于一个白色格点 $(x,y)$，如果存在 $y_1<y,y_2>y,x_1<x,x_2>x$，使得 $(x_1,y),(x_2,y),(x,y_1),(x,y_2)$ 均为黑格点，则将 $(x,y)$ 变为黑色。
>
> 当无法再执行操作使停止。求最终的坐标系中会有几个黑点，或报告永远不会停止。($1\le n\le 10^5,|x|,|y|\le 10^9$)

首先稍微思考一下可以发现，永远不会停止的情况是不可能出现的。如果令所有出现的坐标组成的集合为 $\mathbb{X}$，则 $(x,y)(x\notin\mathbb{X}\operatorname{or}y\notin\mathbb{X})$ 一定不会是黑点，而又因为 $\mathbb{X}$ 是有限集合，且整个过程不会把黑点还原为白点，所以最后一定会停下。

再思考一下可以发现，不断执行也是诈骗。注意到第二轮的点，满足四个“包围”它的黑点中有一个是第一轮新变的，不妨设是右边的黑点。而这个黑点因为在第一轮变成了黑点，所以它右边一定有初始黑点，这样这个第二轮的点其实在第一轮就能变为黑点，无需等到第二轮。其他四个方向情况是一样的。

所以问题变为了，执行一次上述操作，能得到多少黑点。

注意到新得到的黑点一定满足两边都有初始黑点，所以考虑对于每行点分别考虑，或者说，用一条扫描线从下往上扫描。（这里用一条线从左往右扫描是类似的，下文采用从下往上）

对于 $y=y_0$ 这条线扫到的所有点，考虑有哪些点最终会变为黑点。首先初始黑点不用说，还有就是在最左边的黑点和最右边的之间，满足下方有黑点且上方也有黑点的点。对于这种点，考虑黑点只能是初始黑点，对于每一个 $x_0$ 值，记录 $x=x_0$ 这条直线在 $y\ge y_0$ 的这一部分，还能截到多少黑点。从 $x_0$ 位置第一次出现黑点，到最后一个黑点被扫描过，这段时间内 $x_0$ 位置的点都能变为黑点。

整个过程需要单点修改和区间查询，因为值域比较大只能上线段树。但真的只能上线段树吗？注意到，一种坐标如果没有出现，那就永远不可能成为黑点了，所以我们完全可以把横坐标离散化掉，不会影响答案。这样就可以上树状数组，获得一份常数比较小的代码了。时间复杂度 $\mathcal{O}(n\log n)$，截止本文发布，谷上还是 $\rm rk1$~~，但可卡常的空间还是很大的~~。
```cpp
#include <cstdio>
#include <algorithm>
const int N = 2e5 + 10;
struct point{ int x, y; }a[N]; int b[N], vis[N], cnt[N];
struct BIT
{
	int c[N], len;
	int lowbit(int x) { return x & -x; }
	void add(int x, int v) { for (int i = x; i <= len; i += lowbit(i)) c[i] += v; }
	int query(int x) { int ans = 0; for (int i = x; i; i -= lowbit(i)) ans += c[i]; return ans; }
}bit;
inline void read(int& x)
{
	x = 0; char ch; int f = 1;
	while ((ch = getchar()) < '0' || ch > '9') f = (ch == '-' ? -1 : 1);
	while (x = (x << 1) + (x << 3) + (ch ^ 48), (ch = getchar()) >= '0' && ch <= '9') ;
	x *= f;
}
int main()
{
	int n, tn = 0; read(n);
	for (int i = 1; i <= n; ++i) read(a[i].x), read(a[i].y), b[++tn] = a[i].x; // 因为已经是对每一行分别考虑了，所以纵坐标没必要离散化
	std::sort(b + 1, b + tn + 1); tn = std::unique(b + 1, b + tn + 1) - b - 1;
	for (int i = 1; i <= n; ++i) a[i].x = std::lower_bound(b + 1, b + tn + 1, a[i].x) - b;
	std::sort(a + 1, a + n + 1, [](const point& p1, const point& p2) { return p1.y == p2.y ? p1.x < p2.x : p1.y < p2.y; }); // 排序后从下往上考虑，对于同一行的点按顺序排序，枚举的时候方便
	bit.len = tn; int lst = 1; long long ans = 0;
	for (int i = 1; i <= n; ++i) ++cnt[a[i].x];
	for (int i = 2; i <= n; ++i)
		if (a[i].y != a[i - 1].y)
		{
			// 对于每一行
			for (int j = lst; j < i; ++j) if (!vis[a[j].x]) bit.add(a[j].x, 1), vis[a[j].x] = 1; // 如果第一次出现就加上贡献
			ans += (bit.query(a[i - 1].x) - bit.query(a[lst].x - 1)); // 统计这一行有多少能变成黑点的
			for (int j = lst; j < i; ++j) if (!(--cnt[a[j].x])) bit.add(a[j].x, -1); // 如果这行扫描过就没有了，就删去贡献
			lst = i; 
		}
	for (int i = lst; i <= n; ++i) if (!vis[a[i].x]) bit.add(a[i].x, 1), vis[a[i].x] = 1;
	ans += bit.query(a[n].x) - bit.query(a[lst].x - 1); // 统计扫不到的最后一行
	printf("%lld\n", ans); return 0;
}
```

---

## 作者：xuyuansu (赞：1)

## 题意
给你无限大的白色平面上一些黑点，可以将每个上下左右方向都有黑点的白点染黑，问最后有几个黑点。
## 题解
观察题意，略微思考可以发现所谓永不停止的情况是出题人拿来骗人的，这个过程无法做到无限扩张。

可以发现这种变化一个非常重要的性质:被后来染黑的点不会影响其他白点是否会被染黑。证明可以假设一个点上方有一个后来被染黑的点，它使得这个点从不能染色变成可以染色，那么既然它上方有一个被染黑的点，那么在更上方一定有一个黑点，这与当前点一开始不能被染黑矛盾，得证。

那么我们可以考虑扫描线，用差分形式表示每个可以产生影响的横线，竖线直接查询，具体见代码。

这道题我个人觉得最恶心人的还是对初始黑点的判重问题（在扫描线时可能会重复计算）。我的做法是对每个点统计是否在横纵方向满足了染黑条件，如果不满足，就把它算上。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,hx[3*N],cnt1,hy[3*N],cnt2,sum,s[N*12];long long ans;
struct node
{
    int x,y,b;
}p[N];
bool cmp(node i,node j)
{
    if(i.x!=j.x) return i.x<j.x;
    return i.y<j.y;
}
bool cmp2(node i,node j)
{
    if(i.y!=j.y) return i.y<j.y;
    return i.x<j.x;
}
struct node2
{
    int x,l,r,t;
}q[N*3];
bool cmp3(node2 i,node2 j)
{
    if(i.x!=j.x) return i.x<j.x;
    return i.t<j.t;
}
void update(int x,int l,int r,int loc,int y)
{
    if(l==r)
    {
        s[x]+=y;return;
    }
    int mid=(l+r)>>1;
    if(loc<=mid) update(x<<1,l,mid,loc,y);
    else update(x<<1|1,mid+1,r,loc,y);
    s[x]=s[x<<1]+s[x<<1|1];
}
int query(int x,int l,int r,int L,int R)
{
    if(L>R) return 0;
    if(L<=l && r<=R) return s[x];
    int mid=(l+r)>>1,res=0;
    if(L<=mid) res+=query(x<<1,l,mid,L,R);
    if(R>mid) res+=query(x<<1|1,mid+1,r,L,R);
    return res;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&p[i].x,&p[i].y);
        hx[++cnt1]=p[i].x;hy[++cnt2]=p[i].y;
        hx[++cnt1]=p[i].x+1;hy[++cnt2]=p[i].y+1;
        hx[++cnt1]=p[i].x-1;hy[++cnt2]=p[i].y-1;
    }
    sort(hx+1,hx+cnt1);cnt1=unique(hx+1,hx+cnt1+1)-hx-1;
    sort(hy+1,hy+cnt2);cnt2=unique(hy+1,hy+cnt2+1)-hy-1;
    for(int i=1;i<=n;i++)
    {
        p[i].x=lower_bound(hx+1,hx+cnt1+1,p[i].x)-hx;
        p[i].y=lower_bound(hy+1,hy+cnt2+1,p[i].y)-hy;
    }
    sort(p+1,p+n+1,cmp);
    int last=1;
    for(int i=1;i<=n;i++)
        if(p[i].x!=p[last].x)
        {
            for(int j=last+1;j<i-1;j++) p[j].b++;
            if(last<i-1)
            {
                q[++sum]={p[last].x,p[last].y+1,p[i-1].y-1,2};
            }
            last=i;
        }
    sort(p+1,p+n+1,cmp2);
    last=1;
    for(int i=1;i<=n;i++)
        if(p[i].y!=p[last].y)
        {
            for(int j=last+1;j<i-1;j++) p[j].b++;
            if(last<i-1)
            {
                q[++sum]={p[last].x+1,p[last].y,0,1};
                q[++sum]={p[i-1].x,p[last].y,0,-1};
            }
            last=i;
        }
    sort(q+1,q+sum+1,cmp3);
    for(int i=1;i<=sum;i++)
    {
        if(q[i].t!=2)
        {
            update(1,1,cnt2,q[i].l,q[i].t);
        }
        else{
            ans+=query(1,1,cnt2,q[i].l,q[i].r);
        }
    }
    for(int i=1;i<=n;i++)
    {
        if(p[i].b<2) ans++;
    }
    cout<<ans<<endl;
    return 0;
}
```


---

## 作者：Vocalise (赞：1)

观察题意，我们发现首先需要处理 $-1$ 的情况，才能更好地解决问题。

然后你发现，似乎不存在这种情况。简单说明：

假如总可以把白点染黑，那么一定有一些点是多个初始没有的黑点之间产生的。因为初始黑点有限。

但是若这样的话，发现其实那些黑点上下左右都有从前的黑点，所以其贡献仍来自于初始黑点。

所以，我们只需考虑初始黑点能产生多少黑点。

我们可以先考虑 $x$ 坐标相等的点构成的线段，于是可以将点按 $x$ 坐标第一关键字，$y$ 坐标第二关键字排序，找到 $x$ 坐标相同点中 $y$ 坐标相邻的点，分别打上差分加减标记。

具体地，在 $(x,y1)$ 打上 $+1$ 标记，在 $(x,y2)$ 打上 $-1$ 标记。$(y1 < y2)$

再以将点按 $y$ 坐标第一关键字，$x$ 坐标第二关键字排序，对于 $y$ 坐标相同，$x$ 坐标相邻点 $(x1,y)$ 与 $(x2,y)$ $(x1 < x2)$，查询线段树上区间 $[x1 + 1,x2 - 1]$ 之和并记入答案。

在查询其之前或之后根据该点标记在线段树上作对应的单点加减修改即可。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <cstdlib>
#include <ctime>

typedef long long ll;
const int N = 100001;
const int LOGM = 18;
const int NODE = N * LOGM;

inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();
    return x * f;
}

int n;

struct Point {
    int x,y,op1,w1,op2,w2;
    Point() { op1 = op2 = 0; }
} p[N];

bool cmp1(const Point &x,const Point &y) {
    if(x.x != y.x) return x.x < y.x;
    return x.y < y.y;
}

bool cmp2(const Point &x,const Point &y) {
    if(x.y != y.y) return x.y < y.y;
    return x.x < y.x;
}

int s[NODE],lc[NODE],rc[NODE],rt,cnt;

void Update(int &k,int l,int r,int x,int v) {
    if(!k) k = ++cnt;
    s[k] += v;
    if(l == r) return;
    int m = (l + r) / 2;
    if(x <= m) Update(lc[k],l,m,x,v);
    else Update(rc[k],m + 1,r,x,v);
    return;
}

int Query(int k,int l,int r,int x,int y) {
    if(!k) return 0;
    if(l >= x && r <= y) return s[k];
    int m = (l + r) / 2;
    if(y <= m) return Query(lc[k],l,m,x,y);
    else if(x > m) return Query(rc[k],m + 1,r,x,y);
    else return Query(lc[k],l,m,x,y) + Query(rc[k],m + 1,r,x,y);
}

int main() {
    n = read();
    for(int i = 1;i <= n;i++) p[i].x = read(), p[i].y = read();
    std::sort(p + 1,p + 1 + n,cmp1);
    int m = 0;
    for(int i = 1;i <= n;i++) {
        int j = i;
        while(j < n && p[j + 1].x == p[i].x) j++;
        m++;
        for(int k = i;k <= j;k++) p[k].x = m;
        for(int k = i;k < j;k++) p[k].op1 = 1, p[k + 1].op2 = 1;
        i = j;
    }
    // for(int i = 1;i <= n;i++) std::printf("%d %d\n",p[i].x,p[i].y);
    std::sort(p + 1,p + 1 + n,cmp2);
    ll ans = n;
    for(int i = 1;i < n;i++) {
        if(p[i].y == p[i + 1].y) {
            if(p[i].x + 1 < p[i + 1].x)
                ans += Query(rt,1,m,p[i].x + 1,p[i + 1].x - 1);
        }
        if(p[i].op1) Update(rt,1,m,p[i].x,1);
        if(p[i].op2) Update(rt,1,m,p[i].x,-1);
    }
    std::printf("%lld\n",ans);
    return 0;
}

```

---

## 作者：hegm (赞：0)

扫描线板子题。

[传送门](https://www.luogu.com.cn/problem/P5816)

对于新手来说能比较好的进一步理解。

首先我们需要离散化。

接着观察性质。

不难发现，除了初始的黑点以外，新生成的黑点是不会对其他白点产生影响的。

同时，是不会出现一直变化的情况的。

对于一对 $x$ 坐标相等且之间没有其他黑点的点，他们的贡献是 $x$ 这个位置，在 $y_i+1\sim y_j-1$ 之间，只要有另一对 $y$ 坐标相等的点出现吗，那么就会新产生一个黑点。

这很类似与扫描线，将矩形的某一条边转化为操作。

那么我们考虑扫描的过程。

我们可以将所有的 $x$ 坐标相等的点对看成单点修改，一段时间后擦除。

对于 $y$ 坐标相同的点对，我们可以看做在 $y$ 这个时刻区间询问 $x_i\sim x_j$ 之间有多少个被标记的点。

我们使用一个优先队列，存储每一个 $x$ 坐标相等的点对。

将 $y$ 坐标比较小的作为单点加，大的作为单点减。

再用一个优先队列，存储每一个 $y$ 坐标相等的点对。

按照 $y$ 坐标顺序，一个一个的加入（删除）单点。

对于每一个区间（ $y$ 坐标相等的点对）查询里面有多少个点。

将所有答案求出，最后在加上 $n$ 即为答案。

注意，点对必须之间什么都没有！

否则你可能得到 $20$ 或者 $40$ pts。

细节看看代码。

### $\text {CODE}$

```cpp
#include<bits/stdc++.h>
#define N 1000006
#define ls (now<<1)
#define rs (now<<1|1)
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,x[N],y[N],ans;
struct node
{
	int x,y;
}e[N];
bool cmp(node a,node b)
{
	if(a.x==b.x)return a.y<b.y;
	return a.x<b.x;
}
bool bnq(node a,node b)
{
	if(a.y==b.y)return a.x<b.x;
	return a.y<b.y;
}
struct pos
{
	int x,t,val;
	bool operator <(pos b)const
	{return t>b.t;}
};
priority_queue<pos> q;
int tr[N];
void up(int now){tr[now]=tr[ls]+tr[rs];}
void midy(int now,int l,int r,int x,int val)
{
	if(l==r)
	{
		tr[now]+=val;
		return ;
	}
	int mid=(l+r)>>1;
	if(mid>=x)midy(ls,l,mid,x,val);
	else midy(rs,mid+1,r,x,val);
	up(now);
}
void que(int now,int l,int r,int ql,int qr)
{
	if(ql>qr)return ;
	if(l>=ql&&r<=qr)
	{
		ans+=tr[now];
		return;
	}
	int mid=(l+r)>>1;
	if(mid>=ql)que(ls,l,mid,ql,qr);
	if(mid<qr)que(rs,mid+1,r,ql,qr);
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		e[i].x=read();
		e[i].y=read();
		x[i]=e[i].x;
		y[i]=e[i].y;
	}
	sort(x+1,x+1+n);int lenx=unique(x+1,x+1+n)-x-1;
	sort(y+1,y+1+n);int leny=unique(y+1,y+1+n)-y-1;
	for(int i=1;i<=n;i++)
	{
		e[i].x=lower_bound(x+1,x+1+lenx,e[i].x)-x;
		e[i].y=lower_bound(y+1,y+1+leny,e[i].y)-y;
	}
	sort(e+1,e+1+n,cmp);
	for(int i=1,l;i<n;)
	{
		l=i;
		while(e[i].x==e[l].x&&l<n)
		{
			l++;
			if(e[i].x!=e[l].x)continue;
			if(e[l-1].y<e[l].y-1)
			{
				q.push(pos{e[l-1].x,e[l-1].y+1,1});
				q.push(pos{e[l].x,e[l].y,-1});
			}
		}
		i=l;
	}
	sort(e+1,e+1+n,bnq);
	for(int i=1,l;i<n;)
	{
		l=i;
		while(q.size()&&q.top().t<=e[i].y)
		{
			midy(1,1,lenx,q.top().x,q.top().val);
			q.pop();
		}
		while(e[i].y==e[l].y&&l<n)
		{
			l++;
			if(e[i].y!=e[l].y)continue;
			que(1,1,lenx,e[l-1].x+1,e[l].x-1);
		}
		i=l;
	}
	cout<<ans+n<<"\n";
	return 0;
}


```

---

## 作者：pokefunc (赞：0)

### Description

一个平面直角坐标系内有 $n$ 个黑点，其余点为白点，将会进行若干次变换，每次变换会把上下左右方向都有黑点的白点变成黑点，直到找不到符合要求的白点。

问最终有多少黑点。若变换过程永不停止，输出 `-1`。

### Solution

首先看一个结论：在任何情况下，最多只会变换一次。

简证：假设存在一个点 $A$，它是经过两次变换得到的，那么它的四个方向中至少有一个点是经过一次变换得到的（否则点 $A$ 也应当在第一次变换时被染成黑色）。

设这个点为 $B$，那么点 $B$ 应当是四个原始的黑点染成黑色的并且是 $A$ 向 $B$ 方向上唯一的黑点。

然而这意味着 $A$ 向 $B$ 方向就会有另一个原始黑点。矛盾。（如下图，红点即为矛盾点）

![image.png](http://tva1.sinaimg.cn/large/006JmRJEly1h7ugsfxrycj31250o7dhc.jpg)

那么问题就转化为：有多少个白点满足其上下左右方向都有黑点。

不难看出，这就是询问将所有水平/竖直方向的点用线段连接起来之后，横竖方向的线段之间能形成多少个交点（在端点处相交不算）。

设一条横着的线段从 $(x_1,y_1)$ 到 $(x_2,y_1)$，另一条竖着的线段从 $(x_3,y_2)$ 到 $(x_3,y_3)$，那么它们能形成交点的充要条件为 $\begin{cases}x_3 \in [x_1+1,x_2-1] \\ y_1 \in [y_2+1,y_3-1]\end{cases}$。

于是使用扫描线：将所有横向线段按照 $y$ 坐标排序后将 $y$ 轴看作时间轴，把竖着的线段看作单点修改（下端点 $+1$ 上端点 $-1$）（相当于表示从下端点到上端点这段时间内，在这条线段的 $x$ 坐标处有一条线段），此时横着的线段可以看作询问 $[l+1,r-1]$ 之间的和（$l$ 为区间左端点，$r$ 为区间右端点）（相当于询问这个区间内有多少条竖着的线段），开一个树状数组维护即可。

但是考虑到坐标范围 $10^9$，于是先离散化。

### Code

```cpp
#include<cstdio>
#include<algorithm>
const int M=1e5+5;
inline int read(){int x(0),op(0);char ch=getchar();while(ch<'0'||ch>'9')op|=(ch==45),ch=getchar();while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();return op?-x:x;}
struct line{
	int l,r,h,w;
	bool operator < (const line& rhs){
		return h<rhs.h;
	}
}L[M*3];//luogu的数据好像略水，我在校内OJ上交的时候开2e5会RE，分析之后应该是L数组要开成3e5否则全部是修改操作会炸
struct point{
	int x,y;
}P[M];
bool cmp1(point a,point b){
	if(a.y!=b.y)return a.y<b.y;
	return a.x<b.x;
}
bool cmp2(point a,point b){
	if(a.x!=b.x)return a.x<b.x;
	return a.y<b.y;
}
int n,X[M<<1],Y[M<<1],cnt1,cnt2,ltot,T[M];
int lowbit(int x){return x&(-x);}
void add(int x,int y){
	for(;x<=cnt1;x+=lowbit(x))T[x]+=y;
}
int prefix(int x){
	int ans=0;
	for(;x;x-=lowbit(x))ans+=T[x];
	return ans;
}
int main(){
	n=read();
	for(int i=1;i<=n;++i)P[i].x=X[i]=read(),P[i].y=Y[i]=read();
	//离散化
	std::sort(X+1,X+n+1);
	std::sort(Y+1,Y+n+1);
	cnt1=std::unique(X+1,X+n+1)-X-1;
	cnt2=std::unique(Y+1,Y+n+1)-Y-1;
	for(int i=1;i<=n;++i){
		P[i].x=std::lower_bound(X+1,X+cnt1+1,P[i].x)-X;
		P[i].y=std::lower_bound(Y+1,Y+cnt2+1,P[i].y)-Y;
	}
	//处理出所有横向的线段
	//注意：这里只处理相邻的点，以防算重
	std::sort(P+1,P+n+1,cmp1);
	for(int i=1;i<n;++i)if(P[i].y==P[i+1].y)L[++ltot]=(line){P[i].x,P[i+1].x,P[i].y,0};
	//处理出所有纵向的线段
	std::sort(P+1,P+n+1,cmp2);
	for(int i=1;i<n;++i)if(P[i].x==P[i+1].x){
		L[++ltot]=(line){P[i].x,0,P[i].y,1};
		L[++ltot]=(line){P[i].x,0,P[i+1].y,-1};
	}
	//扫描线
	std::sort(L+1,L+ltot+1); 
	int ans=0;
	for(int i=1;i<=ltot;++i){
		if(L[i].w)add(L[i].l,L[i].w);
		else ans+=prefix(L[i].r-1)-prefix(L[i].l);
	}
	printf("%d\n",ans+n);//注意：答案包括原有黑点
	return 0;
}
```



---

## 作者：eastcloud (赞：0)

### 题意简述

在一个平面直角坐标系内给出 $ n $ 个黑点，当一个白点左和右方都方有一个黑点，且上和下方都有一个黑点时会变成白点，请问最后有多少个黑点。

### 题目分析

由于这个平面直角坐标系无限大，我们可以考虑把它的范围缩小，仔细思考可以发现，在同一列或者同一行中，距离最远的两个黑点之间的白点才有可能变成黑点。

由此我们可以推出当一列或一行没有任何一个黑点时，这一行不用进行计算，我们可以根据这个特点对黑点的坐标进行离散化。

再仔细思考能变为黑点的白点与黑点的位置关系，发现它是两条由黑点构成的线段的交点，单从一条线段的角度来看，它线段内经过的其他线段的个数就是它对答案的贡献，我们可以使用扫描线从左往右计算贡献。

首先将黑点离散化，处理出每一条平行于 x 和 y 轴的线段，最后用扫描线统计交点即可。

### 代码



```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
map<int,int> tx;
map<int,int> ty;
int tot,n,m;
struct segment_tree{
	int sum,l,r;
	#define s(x) b[x].sum
	#define l(x) b[x].l
	#define r(x) b[x].r
}b[1000001];
struct Node{
	int x,y;
}bla[1000001];
bool cmp_y(Node a,Node b){
	if(a.y!=b.y)return a.y<b.y;
	else return a.x<b.x;
}
bool cmp_x(Node a,Node b){
	return a.x<b.x;
}
struct lis{
	int opt,x,l,r;
}l[1000001];
bool cmp(lis a,lis b){
	if(a.x!=b.x) return a.x<b.x;
	else if(a.opt && !b.opt) return true;
	else return false;
}
void pre_y(){
	sort(bla+1,bla+n+1,cmp_y);
	int maxn=0,minn=1000000001;
	for(int i=1;i<=n;i++){
		if(bla[i].y==bla[i-1].y){
			l[++m].opt=-1;l[m].x=bla[i].x;l[m].l=bla[i].y;
			l[++m].opt=1;l[m].x=bla[i].x+1;l[m].l=bla[i].y;
		}
		else{
			l[++m].opt=-1;l[m].x=bla[i-1].x+1;l[m].l=bla[i-1].y;
			l[++m].opt=1;l[m].x=bla[i].x+1;l[m].l=bla[i].y;
		}
	}
	l[++m].opt=-1;
	l[m].x=bla[n].x+1;
	l[m].l=bla[n].y;
}
void pre_x(){
	sort(bla+1,bla+n+1,cmp_x);
	int maxn=0,minn=1000000001;
	for(int i=1;i<=n;i++){
		if(bla[i].x==bla[i-1].x){
			maxn=max(maxn,bla[i].y);
			minn=min(minn,bla[i].y);
		}
		else{
			if(maxn!=minn && minn+1<=maxn-1){
				l[++m].opt=0;
				l[m].l=minn+1;
				l[m].r=maxn-1;
				l[m].x=bla[i-1].x;
			}
			maxn=bla[i].y;minn=bla[i].y;
		}
	}
	if(maxn!=minn && minn+1<=maxn-1){
		l[++m].opt=0;
		l[m].l=minn+1;
		l[m].r=maxn-1;
	}
}
void build(int x,int l,int r){
	l(x)=l;
	r(x)=r;
	if(l==r) return;
	int mid=(l+r)>>1;
	build(2*x,l,mid);
	build(2*x+1,mid+1,r);
}
void change(int x,int p,int val){
	if(l(x)==r(x)){
		s(x)+=val;
		return;
	}
	int mid=(l(x)+r(x))>>1;
	if(p<=mid) change(x*2,p,val);
	else change(x*2+1,p,val);
	s(x)=s(x*2)+s(x*2+1);
}
int query(int x,int l,int r){
	if(l(x)>=l && r(x)<=r)return s(x);
	int ans=0,mid=(l(x)+r(x))>>1;
	if(l<=mid) ans+=query(x*2,l,r);
	if(r>mid) ans+=query(x*2+1,l,r);
	return ans;
}
void pre(){
	sort(bla+1,bla+n+1,cmp_x);
	int last;
	for(int i=1;i<=n;i++){
		if(i==1) tx[bla[i].x]=++tot;
		else if(last!=bla[i].x)tx[bla[i].x]=++tot;
		last=bla[i].x;
		bla[i].x=tx[bla[i].x];
	}
	int maxn=tot;
	tot=0;
	sort(bla+1,bla+n+1,cmp_y);
	for(int i=1;i<=n;i++){
		if(i==1) ty[bla[i].y]=++tot;
		else if(last!=bla[i].y)ty[bla[i].y]=++tot;
		last=bla[i].y;
		bla[i].y=ty[bla[i].y];
	}
	tot=max(maxn,tot);
}
int main(){
	int x,y;
	cin>>n;
	for(int i=1;i<=n;i++)cin>>bla[i].x>>bla[i].y;
	pre();
	build(1,1,tot);
	pre_y();
	pre_x();
	sort(l+1,l+m+1,cmp);
	int ans=n;
	for(int i=1;i<=m;i++){
		if(l[i].opt)change(1,l[i].l,l[i].opt);
		else ans+=query(1,l[i].l,l[i].r);
	}
	cout<<ans;
}
```


---

## 作者：When (赞：0)

#### 题意

有一张由黑白点构成的网格图，给出一些黑点的坐标，求上下左右都有黑点（**不必相邻**）的白点数目与原来黑点数目之和。

#### 一个说明

为什么原题面中永不终止的情况是不可能的？

对于每一个将会被染成黑色的白点，它的上方，下方，左边，右边（不必相邻）一定是都是有黑点的，而一个既不在所属列的两端，又不在所属行的两端的黑点（即它的上下左右（不必相邻）都有黑点），是不会对答案有任何贡献的。换言之，**任何被染成黑点的白点，都不会再染别的白点**，所以整个染色只会进行一轮。

#### 算法

一个不像扫描线的扫描线

不会扫描线的[戳我](https://ncc79601.blog.luogu.org/scan-line)

#### 思路

只有处于同一行的两黑点之间的部分才能染色，为了方便，我们可以只处理相邻两黑点。

先将黑点以$y$为第一关键字，$x$为第二关键字排序，对于每一列，处理出最高点与最低点，当处理到最高点时在线段树上将该列$+1$， 最低点时最线段树上将该列$-1$。对于每两个同行相邻的点，区间求和即可。

#### 代码

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

const int maxn = 5e5 + 10;
int b[maxn],n,ans;
struct Mar{
    int x,y;
}m[maxn];
struct Line{
    int high,low;
    Line(){high = 0, low = 0x3f3f3f3f;}
}ll[maxn];

struct Seg_Tree{
    #define lc(x) x << 1
    #define rc(x) x << 1 | 1
    int c[maxn << 2],tag[maxn << 2];
    
    void f(int l, int r, int p, int x){
        c[p] += (r - l + 1) * x;
        tag[p] = x;
    }
    
    void downdate(int l, int r, int p){
        if(tag[p]){
            int mid = (l + r) >> 1;
            f(l, mid, lc(p), tag[p]);
            f(mid + 1, r, rc(p), tag[p]);
            tag[p] = 0;
        }
    }
    
    void add(int L, int R, int l, int r, int p, int x){
        if(L <= l && R >= r){
            f(l, r, p, x);
            return;
        }
        downdate(l, r, p);
        int mid = (l + r) >> 1;
        if(mid >= L) add(L, R, l, mid, lc(p), x);
        if(mid < R) add(L, R, mid + 1, r, rc(p), x);
        c[p] = c[lc(p)] + c[rc(p)];
    }
    
    int query(int L, int R, int l, int r, int p){
        if(L <= l && R >= r){
            return c[p];
        }
        downdate(l, r, p);
        int mid = (l + r) >> 1, sum = 0;
        if(mid >= L) sum += query(L, R, l, mid, lc(p));
        if(mid < R) sum += query(L, R, mid + 1, r, rc(p));
        return sum;
    }
}tree;

bool cmp(Mar x, Mar y){return x.y == y.y ? x.x < y.x : x.y > y.y;}

int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; ++ i){
        scanf("%d %d",  &m[i].x, &m[i].y);
        b[i] = m[i].x; b[i + n] = m[i].y;
    } sort(b + 1, b + 1 + 2 * n);

    int _n = unique(b + 1, b + 1 + 2 * n) - b - 1;
    for(int i = 1; i <= n; ++ i){
        int pos1 = lower_bound(b + 1, b + 1 + _n, m[i].x) - b;
        int pos2 = lower_bound(b + 1, b + 1 + _n, m[i].y) - b;
        m[i].x = pos1, m[i].y = pos2;
        //printf("%d %d\n", pos1, pos2);
        ll[m[i].x].high = max(ll[m[i].x].high, m[i].y);
        ll[m[i].x].low = min(ll[m[i].x].low, m[i].y);
    } sort(m + 1, m + 1 + n, cmp);
    
    m[n + 1].y = 0x3f3f3f3f;
    for(int i = 1; i <= n; ++ i){
        if(m[i].y == ll[m[i].x].high) tree.add(m[i].x, m[i].x, 1, _n, 1, 1);
        if(m[i].y == ll[m[i].x].low) tree.add(m[i].x, m[i].x, 1, _n, 1, -1);
        if(m[i + 1].y == m[i].y) ans += tree.query(m[i].x + 1, m[i + 1].x - 1, 1, _n, 1);
    } printf("%d\n", ans + n);
    return 0;
}
```



---

## 作者：noall (赞：0)

~~我觉得题解区的题解一点也不直观，对我这种小菜鸟十分不友好。~~

首先，要明确不可能输出`-1`。

我们可以假设 i 点在第一秒变成黑点，则说明 i 点的上下左右必定都会有一个黑点，也就是说下一秒一定不会有白点由于 i 变成了黑点而变成黑点，因为 i 变成黑点对这个系统没有做出任何贡献。

综上，一切的变化只发生在1s之间。

考虑这个题怎么做。

这个题的目的是求出由白点变成黑点的点的数目与原先黑点总数的和。

难点是怎么求出由白点变成黑点的点的数目。

![](https://cdn.luogu.com.cn/upload/image_hosting/8qxwyuic.png)

看图，L,K两个交点即两个由白点变成黑点的点。

我们用一条横线，从下往上进行扫描（这东西应该是叫扫描线），结合上图，先扫到H点，再往上扫，便扫到AB这条线段，这时同样能扫到一个交点L。

那么，问题来了，怎么统计这个点L呢？

通过观察我们可以发现，在扫到线段AB之前，扫到了一个点H，而这个点H正是/与线段AB相交于点L的线段GH/的下端点。~~（断了个句）~~

想一想，我们是否能从点H上做文章。

我们可以将竖线映射到一个序列中，这个序列我们可以用树状数组或线段树等数据结构进行维护，当扫描线扫到下端点$(x,y)$时，对应的，序列中的$x$位$+1$。

那么做完后线段AB的交点个数便是A和B两点间横坐标所对应的序列中的区间和（也就是$1$）。

对应的，扫到G点时，对应的横坐标$-1$，表示该竖线的结束。

注意几点，

1. 要注意处理的顺序

![](https://cdn.luogu.com.cn/upload/image_hosting/k31ebpkl.png)

如图

A点是线段AD的下端点，而A又在BC上，先处理BC两点横坐标对应序列的区间和，再去处理A点，因为A点不能算做是一个“白变黑”点。

2. 需要进行对横坐标x进行离散化，因为这个网格是无限大的。

代码如下:
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>

const int maxn=1e5+10;

struct pot{
	int x,y;
}p[maxn];

struct line{
	int opt,x,y,h;
	/* 
	opt: 1是下端点，-1是上端点，0是竖线
	x: 左端点
	y：右端点
	h：纵坐标 
	*/ 
}l[maxn<<2];

int n,b[maxn],cnt,tree[maxn];

int read(){
	char ch=getchar();int x=0,f=1;
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}

bool cmpx(pot a,pot b){
	if(a.x==b.x) return a.y<b.y;
	return a.x<b.x;
}

bool cmpy(pot a,pot b){
	if(a.y==b.y) return a.x<b.x;
	return a.y<b.y;
}

bool cmpl(line a,line b){
	if(a.h==b.h) return a.opt<b.opt;
	return a.h<b.h;
}

void build(){
	std::sort(p+1,p+1+n,cmpx);
	for(register int i=1;i<n;i++){
		if(p[i].x==p[i+1].x){
			l[++cnt]=(line){1,p[i].x,0,p[i].y};//下端点 
			l[++cnt]=(line){-1,p[i+1].x,0,p[i+1].y};//上端点 
		}
	}
	std::sort(p+1,p+1+n,cmpy);
	for(register int i=1;i<n;i++){
		if(p[i].y==p[i+1].y){
			l[++cnt]=(line){0,p[i].x,p[i+1].x,p[i].y};//竖线 
		}
	}
}

inline int lowbi(int x){
	return x& -x;
} 

inline void update(int x,int num){
	while(x<=n){
		tree[x]+=num;
		x+=lowbi(x);
	}
	return ;
}

inline int query(int x){
	int sum=0;
	while(x){
		sum+=tree[x];
		x-=lowbi(x);
	}
	return sum;
}

int main(){
	n=read();
	for(register int i=1;i<=n;i++){
		b[i]=p[i].x=read(),p[i].y=read();
	}
	
	//离散化 
	std::sort(b+1,b+1+n);
	int tot=std::unique(b+1,b+1+n)-b-1;
	for(register int i=1;i<=n;i++)
		p[i].x=std::lower_bound(b+1,b+1+tot,p[i].x)-b;
	
	build();//预处理 
	
	std::sort(l+1,l+1+cnt,cmpl);
	int ans=0;
	for(register int i=1;i<=cnt;i++){
		if(!l[i].opt) ans+=query(l[i].y-1)-query(l[i].x);
		else update(l[i].x,l[i].opt);
	}
	std::cout<<ans+n;
	return 0;
}
```

---


# [JSOI2013] 吃货 JYY

## 题目背景

作为 JSOI 的著名吃货，JYY 的理想之一就是吃遍全世界的美食。要走遍全世界当然需要不断的坐飞机了。而不同的航班上所提供的餐食是很不一样的：比如中国的航班会提供中餐，英国的航班有奶茶和蛋糕，澳大利亚的航班有海鲜，新加坡的航班会有冰激凌……

JYY 选出了一些他特别希望品尝餐食的航班，希望制定一个花费最少的旅游计划，能够从南京出发，乘坐所有这些航班并最后回到南京。

## 题目描述

世界上一共有 $N$ 个 JYY 愿意去的城市，分别从 $1$ 编号到 $N$。JYY 选出了 $K$ 个他一定要乘坐的航班。除此之外，还有 $M$ 个 JYY 没有特别的偏好，可以乘坐也可以不乘坐的航班。

一个航班我们用一个三元组 $(x,y,z)$ 来表示，意义是这趟航班连接城市 $x$ 和 $y$，并且机票费用是 $z$。每个航班都是往返的，所以 JYY 花费 $z$ 的钱，既可以选择从 $x$ 飞往 $y$，也可以选择从 $y$ 飞往 $x$。

南京的编号是 $1$，现在 JYY 打算从南京出发，乘坐所有 K 个航班，并且最后回到南京，请你帮他求出最小的花费。


## 说明/提示

### 样例解释

一个可行的最佳方案为 $1\rightarrow 2\rightarrow 3\rightarrow 5\rightarrow 4\rightarrow 1$。

机票所需的费用为 $1000+1000+300+500+300=3100$。

### 数据范围

对于 $100\%$ 的数据，$2\leq N\leq 13,0\leq K\leq 78,2\leq M\leq 200,1\leq x,y\leq N,1\leq z\leq 10^4$。

## 样例 #1

### 输入

```
6 3
1 2 1000
2 3 1000
4 5 500
2
1 4 300
3 5 300```

### 输出

```
3100```

# 题解

## 作者：_LPF_ (赞：8)

状压好题，希望写的足够详细。

[吃货 JYY](https://www.luogu.com.cn/problem/P6085)

> 给定一张图，有一些必经边，求从 $1$ 出发，经过每条必经边至少一遍，最后回到 $1$ 的最短距离。

首先他的旅行过程在最优情况下是一定是一条欧拉回路，而欧拉回路存在的充要条件是：

1. 图连通。
2. 所有点的度数都为偶数。

必经边必选，相当于需要在必经边的基础上不断加边，使图连通且所有点的度数均为偶数。

然后看到数据范围 $n\leq 13$ 不难想到状压，关键是既满足图连通又满足度数为偶数这不太好处理。

考虑一个简化问题：

> 给出一张图和任意两点间的最短路，求将图改造为欧拉图需要加的最小边权和。

可以证明如果一张连通图不是欧拉图，那么它的奇点个数为偶数。

那么我们需要的是让每对奇点两两连接最短路，显然这样就可以使它们变成偶点，并且不影响其它点的度数的奇偶性。

这显然可以直接状压，设 $f(S)$ 表示奇点集合为 $S$ 的最小代价，然后每次枚举两个不在集合中的奇点加入即可。

时间 $O(2^n\times n^2)$，不排除通过枚举子集等方法进一步优化的可能，不过这也够了。

现在回到原问题，我们想要运用上面的方法，首先需要处理出任意两点间的最短路，这个可以预先 Floyd。

然后是给出一个连通图的每个点的奇偶性，当然也要包含点的连通性。

表现在进制上，就至少需要三进制表示了：

1. $0$，表示这个点不与 $1$ 号节点连通。
2. $1$，表示连通并且度数为奇数。
3. $2$，表示连通并且度数为偶数。

至于为什么不需要另外的状态，表示不连通的点的奇偶性，因为这里运用了一个统一计算的思想。

就是当前只考虑非必选边的构图情况，之后再统一加上必经边的影响，也就是说没有连通的点就是没有连边的点，度数一定为 $0$。

同时这样也保证了不会用到 $5$ 维状压这种恐怖的东西。

然后每次转移有两种选择，都是从已连通连通的点 $u$ 出发，扩展到未连通的点 $v$：

1. 沿着某条必经边到达 $v$，$v$ 连通了，但是度数算作 $0$，也不需要增加代价。
2. 沿着某个最短路到达 $v$，$v$ 连通了且度数为 $1$，$u$ 的度数奇偶性也发生变化，代价加上最短路的距离。

但是可以发现，状态间的转移没有固定的方向，因为度数由偶变奇时，在宏观意义上相当于数变小，而由奇变偶则相反。

所以可以利用 SPFA 的思想反复迭代，直到无法更新，显然保证了正确性。

然后再利用上面的方法就可以结合出答案了，不要忘记加上必经边对 点的度数的奇偶性 和 总代价 的影响。

总时间复杂度大约为 $O(3^nn^2)$，需要考虑利用 SPFA 收束带来的常数影响。（不过好像可以证明只会收束一次？）

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;

#define X first
#define Y second 
#define MP make_pair
typedef pair<int, int> PII;
const int N = 15, M = 2000010;
const int INF = 0x3f3f3f3f;

int n, k, m, P[N], deg[N], dis[N][N], f[1 << N], g[M];
bool vis[M];
vector<PII> G[N];

int read(){
	int x = 0, f = 1; char c = getchar();
	while(c < '0' || c > '9') f = (c == '-') ? -1 : 1, c = getchar();
	while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
	return x * f;
}

void Pre_Work(){
	memset(dis, 0x3f, sizeof(dis));
	for(int i = 1; i <= n; i ++) dis[i][i] = 0;
	P[0] = 1;
	for(int i = 1; i <= n; i ++) P[i] = P[i - 1] * 3;
}

void Get_Map(){
	memset(g, 0x3f, sizeof(g)); g[2] = 0;
	queue<int> q; q.push(2);
	while(!q.empty()){
		int s = q.front(); q.pop();
		vis[s] = false;
		
		for(int u = 0; u < n; u ++) if((s / P[u]) % 3 > 0)
		for(int i = 0; i < (int) G[u].size(); i ++){
			int v = G[u][i].X;
			if((s / P[v]) % 3 == 0){
				int t = s + P[v] * 2;
				if(g[t] > g[s]){
					g[t] = g[s];
					if(!vis[t]) q.push(t), vis[t] = true;
				}
			}
		}
		
		for(int u = 0; u < n; u ++) if((s / P[u]) % 3 > 0)
			for(int v = 0; v < n; v ++) if((s / P[v]) % 3 == 0){
				int t = s + P[v];
				t += ((s / P[u]) % 3 == 1) ? P[u] : - P[u];
				if(g[t] > g[s] + dis[u][v]){
					g[t] = g[s] + dis[u][v];
					if(!vis[t]) q.push(t), vis[t] = true;
				}
			}
	}
}

void Get_Dis(){
	memset(f, 0x3f, sizeof(f));
	f[0] = 0;
	for(int s = 0; s < (1 << n); s ++)
		for(int u = 0; u < n; u ++) if(!(s >> u & 1))
			for(int v = u + 1; v < n; v ++) if(!(s >> v & 1)){
				int t = s + (1 << u) + (1 << v);
				f[t] = min(f[t], f[s] + dis[u][v]);
			}
}

int main(){
	n = read(), k = read();
	Pre_Work(); int sum = 0;
	for(int i = 1; i <= k; i ++){
		int u = read() - 1, v = read() - 1, w = read();
		G[u].push_back(MP(v, w));
		G[v].push_back(MP(u, w));
		dis[u][v] = dis[v][u] = min(dis[u][v], w);
		deg[u] ++, deg[v] ++; sum += w;
	}
	m = read();
	for(int i = 1; i <= m; i ++){
		int u = read() - 1, v = read() - 1, w = read();
		dis[u][v] = dis[v][u] = min(dis[u][v], w);
	}
	
	for(int k = 0; k < n; k ++)
		for(int i = 0; i < n; i ++) if(dis[i][k] != INF)
			for(int j = 0; j < n; j ++) if(dis[k][j] != INF)
				dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
	
	Get_Map(); Get_Dis();
	
	int ans = INF;
	for(int i = 0; i < P[n]; i ++){
		int s = i;
		bool flag = false;
		for(int u = 0; u < n; u ++)
			if(G[u].size() && !((s / P[u]) % 3)) {flag = true; break;}
		if(flag) continue;
		for(int u = 0; u < n; u ++)
			if(deg[u] & 1) s += ((i / P[u]) % 3 == 1) ? P[u] : - P[u];
		int t = 0;
		for(int u = 0; u < n; u ++)
			if((s / P[u]) % 3 == 1) t += (1 << u);
		ans = min(ans, g[i] + f[t]);
	}
	printf("%d\n", ans + sum);
	return 0;
}
```



---

## 作者：Lucky_Glass (赞：7)

## \# 题面
\> Linked [洛谷 P6085](https://www.luogu.com.cn/problem/P6085)

给定一个 $n$ （$2\le n\le13$）个点 $m+K$ （$2\le m\le200,0\le K\le78$）条边的无向图，每条边有边权，其中有 $K$ 条是特殊边。

你从节点 $1$ 出发，每次只能沿着与当前节点相邻的边前往下一个节点，节点和边都可以经过多次，且每经过一次边就会花费其边权的代价。

现在要求你必须要经过所有特殊边然后回到节点 $1$，求最小花费。

---
## \# 解析
看到点数好小就想要状压，但是怎么压？

先转化一下问题，由于一条边可以经过任意多次，那我们就把一条非特殊边拆成无数条重边，而**一条特殊边拆成一条特殊边和无数条非特殊重边**；那么现在问题可以转化为——选出一个边集 $E$ 使得 $E$ 包含所有特殊边，并且 $E$ 存在一条从 $1$ 出发的**欧拉回路**。

再来回顾一下存在欧拉回路的充要条件：

- 设 $V$ 是 $E$ 的所有端点的点集，则 $V$ 通过 $E$ 可以形成连通块；
- 所有点在 $E$ 中的度数均为偶数。

（以下自动忽略没有特殊边的情况，该情况可以直接在点 $1$ 不动）

由于题目的限制 $V$ 必须包含点 $1$。于是可以想到用状压来表示当前包含 $1$ 的连通块。如果一个点不在连通块中，则其度数为 $0$，一定符合度数限制；而如果一个点在连通块中，则可能存在暂时为奇数度的情况，所以对于在连通块内的点，需要记录度数的奇偶性。

由于特殊边一定在 $E$ 中，特殊边**对总花费**以及**对点的度数**的贡献是**确定的**。所以我们在状压的时候，可以**忽略加入一条特殊边造成的对花费以及度数的影响**。

具体而言，状压的每一位：

- $0$：该点不在连通块内（其实也不一定真的不在连通块里，下面DP转移部分会具体说明）
- $1$：该点在连通块内且是奇数度（忽略掉特殊边）；
- $2$：该点在连通块内且是偶数度（忽略掉特殊边）。

那么这是一个三进制状压，$S\le 3^{13}=1594323$ 很没有问题。关键是怎么转移 awa

考虑我们为什么要加边：

1. 将一个点连入连通块；
2. 改变一对点的度数。

这里有一个理解的关键——**最多只有一次**加入一条与某个点 $u$ 相邻的边的操作的目的是改变点 $u$ 度数，因为只关心度数奇偶性。那为什么 $u$ 会被连许多条边呢？其实其他边都是因为**加入了一条连接另外两个点的路径**，而 $u$ 恰好在路径上，就会被加上两条边，而度数奇偶性不变。

我们一定是一个点一个点的扩展出这个连通块，即每次将一个点 $u$ 加入连通块，有两种情况：

1. 该点有特殊边与当前的连通块相连，由于特殊边默认在 $E$ 中，所以可以直接把 $u$ 加进去；
2. 加**一条非特殊边路径**将 $u$ 和连通块内点 $v$ 相连，目的有两个，改变 $u$ 的连通性，改变 $u$ 的度数；顺便会改变 $v$ 的度数。

对于第一种情况，由于我们不计特殊边的贡献，所以只需要在状态中加入“偶度数”的点 $u$ 即可。

对于第二种情况，为了达到目的且产生最小的花费，当然是取 $u,v$ 的**最短路**（*Floyd* 先求出最短路）；以 $\operatorname{dist}(u,v)$ 的代价在状态中加入“奇数度” $u$ 并且改变 $v$ 的度数。

欸？不是说对于一个点，只会有一次加边的目的是改变其奇偶性？但是显然这样转移很有可能点 $v$ 被改变了多次奇偶性。实际上，要么点 $v$ 是第一次被改变奇偶性，要么 $v$ 的实际作用是作为一个中转点——在某一次加入点 $w$ 时，连接了点 $v$，那么这两次转移的实质是加入了路径 $u,w$，目的是改变 $u,w$ 的度数奇偶性。

DP完后就需要算答案了，枚举出一个连通块状态 $S$，**至少包含了所有特殊边端点**；然后将所有特殊边的度数以及边权的贡献加进去（不要忘了(￣▽￣)"），然后我们会发现还会有一些点是奇数度的……需要额外加上一些路径来改变度数。

假设需要改变度数的点集为 $S$，是一个二进制状态，我们可以再做一个简单的状压DP求出改变度数的最小花费 $g(S)$，转移则选择两个 $S$ 中的点 $u,v$，要改变其度数就加 $u,v$ 的最短路，即 $g(S)=\min\big\{g(S-\{u,v\})+\operatorname{dist}(u,v)\big\}$。

最后复杂度就是 $O(3^nn^2)$，瓶颈在三进制状压转移时枚举连通块外点 $u$ 以及连通块内点 $v$（加入路径 $u,v$）。

---
## \# 源代码
自带小常数，现在好像在最优解 awa
```cpp
/*Lucky_Glass*/
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

#define minc(a,b) (a=min(a,b))
const int N=13,M=205,SZ=1600000,INF=0x3f3f3f3f;
inline int Read(int &r){
    int b=1,c=getchar();r=0;
    while(c<'0' || '9'<c) b=c=='-'? -1:b,c=getchar();
    while('0'<=c && c<='9') r=(r<<1)+(r<<3)+(c^'0'),c=getchar();
    return r*=b;
}

int n,m,K,ansS,ans,totmust;
int dis[N][N],mustS[N],mustdu[N],f[SZ],g[1<<N],pow3[N];
queue<int> que;

int GetS(int S,int *sta){
    int ret=0;
    for(int i=0;i<n;i++,S/=3)
        if((sta[i]=S%3))
            ret|=(1<<i);
    return ret;
}
int main(){
    memset(dis,0x3f,sizeof dis);
    Read(n),Read(K);
    for(int i=1,u,v,l;i<=K;i++){
        Read(u),Read(v),Read(l);u--,v--;
        minc(dis[u][v],l),minc(dis[v][u],l);
        mustS[u]|=(1<<v),mustS[v]|=(1<<u);
        mustdu[u]++,mustdu[v]++;
        ansS|=(1<<u)|(1<<v);
        totmust+=l;
    }
    Read(m);
    for(int i=1,u,v,l;i<=m;i++){
        Read(u),Read(v),Read(l),u--,v--;
        minc(dis[u][v],l),minc(dis[v][u],l);
    }
    //
    for(int i=0;i<n;i++) dis[i][i]=0;
    for(int k=0;k<n;k++)
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                minc(dis[i][j],dis[i][k]+dis[k][j]);
    //
    memset(g,0x3f,sizeof g),g[0]=0;
    for(int S=1;S<(1<<n);S++)
        for(int u=0;u<n;u++)
            for(int v=u+1;v<n;v++)
                if((S>>u&1) && (S>>v&1))
                    minc(g[S],g[S^(1<<u)^(1<<v)]+dis[u][v]);
    //
    pow3[0]=1;for(int i=1;i<n;i++) pow3[i]=pow3[i-1]*3;
    int all=1;for(int i=0;i<n;i++) all*=3;
    //
    ans=INF;
    memset(f,0x3f,sizeof f),f[2]=0;
    que.push(2);
    while(!que.empty()){
        int S=que.front(),sta[N],exiS;que.pop();
        // printf("? %d\n",S);
        exiS=GetS(S,sta);
        for(int v=0;v<n;v++)
            if(!sta[v]){
                if(exiS&mustS[v]){
                    int T=S+2*pow3[v];
                    // printf("  %d -> %d\n",S,T);
                    if(f[T]==INF) que.push(T);
                    minc(f[T],f[S]);
                }
                for(int u=0;u<n;u++)
                    if(sta[u]){
                        int T=S+pow3[v]+(sta[u]==1? pow3[u]:-pow3[u]);
                        // printf("  %d -> %d (%d,%d) %d\n",S,T,u,sta[u],pow3[u]);
                        if(f[T]==INF) que.push(T);
                        minc(f[T],f[S]+dis[u][v]);
                    }
            }
        // printf("done\n");
        if((exiS&ansS)==ansS){
            int chgS=0;
            for(int i=0;i<n;i++)
                if(exiS>>i&1 && ((mustdu[i]&1)^(sta[i]==1)))
                    chgS|=(1<<i);
            minc(ans,f[S]+g[chgS]+totmust);
        }
    }
    //
    printf("%d\n",ans);
    return 0;
}
```

---
## THE END
### Thanks for reading!

---

## 作者：zsq259 (赞：5)

## 题解 JSOI2013 吃货jyy

### 题面

[luogu6085](https://www.luogu.com.cn/problem/P6085)

### 解析

看到数据范围考虑状压 dp.

但是是三进制状压...,而且转移十分诡异...

考虑建一个联通子图,欧拉回路就是点的度数为偶数.

设状态为,每一位上的 $0$ 表示没有在点集中,$1$ 表示度数为奇数,$2$ 表示度数为偶数.

然后枚举不在点集中的点,有以下两种情况:

- 必须要选的边的另一个端点在点集中.

    此时我们先不考虑端点的度数,所以都设为 $2$ ,然后正常转移.

- 枚举点集中的其它点.

    此时正常改变度数转移即可.

此外,我们还要二进制状压一个 $g[s]$ 表示当奇度点集为 $s$ 时全部变为偶数度的代价.

$floyd$ 预处理最短路即可.

### code

```cpp
#include <iostream>
#include <stdio.h>
#include <cstring>
#include <queue>
#define ll long long
#define filein(a) freopen(a".cpp","r",stdin)
#define fileout(a) freopen(a".cpp","w",stdout);
using namespace std;

inline int read(){
	int sum=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&c!=EOF){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9'&&c!=EOF){sum=sum*10+c-'0';c=getchar();}
	return sum*f;
}

const int N=105;
const int O=1600000;
const int P=1<<14;
const int INF=0x3f3f3f3f;
struct edge{int to,next,w;}e[N<<1];
int n,m,dis[N][N],d[N],ans;
int head[N],cnt;
int f[O],g[P],p[N]={1},q[N];
queue<int> que;

inline void add(int x,int y,int w){
	e[++cnt]=(edge){head[x],y,w};head[x]=cnt;
}

inline void init(){
	memset(f,INF,sizeof(f));
	memset(g,INF,sizeof(g));
	memset(dis,INF,sizeof(dis));
	for(int i=1;i<=n;i++) dis[i][i]=0;
	for(int i=1;i<=n;i++) p[i]=p[i-1]*3;
}

inline void floyd(){
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
}

inline void pre(){
	int st=1<<n;g[0]=0;
	for(int i=0;i<st;i++){
		for(int j=1;j<=n;j++){
			if(i&(1<<(j-1))) continue;
			for(int k=j+1;k<=n;k++){
				if(i&(1<<(k-1))) continue;
				int l=i|(1<<(j-1))|(1<<(k-1));
				g[l]=min(g[l],g[i]+dis[j][k]);
			}
		}		   
	}
}

inline void dp(){
	f[2]=0;que.push(2);
	while(!que.empty()){
		int s=que.front();que.pop();
		int t=0;
		for(int i=1;i<=n;i++) if(s/p[i-1]%3) q[++t]=i;
		for(int i=1;i<=n;i++){
			if(s/p[i-1]%3) continue;
			int s1=s+p[i-1]*2;
			for(int j=head[i];j;j=e[j].to){
				int k=e[j].next;
				if(s/p[k-1]%3==0) continue;
				if(f[s1]==INF) que.push(s1);
				f[s1]=min(f[s1],f[s]);
			}
			for(int j=1;j<=t;j++){
				int x=q[j],ss=s+p[i-1];
				ss+=(s/p[x-1]%3==1)? p[x-1]:-p[x-1];
				if(f[ss]==INF) que.push(ss);
				f[ss]=min(f[ss],f[s]+dis[i][x]);
			}			
		}
	}
}

inline void get_ans(){
	ans=INF;
	for(int s=0;s<p[n];s++){
		int flag=0;
		for(int i=1;i<=n;i++) if(d[i]&&!(s/p[i-1]%3)){flag=1;break;}
		if(flag) continue;
		int ss=s,s1=0;
		for(int i=1;i<=n;i++)
			if(d[i]&1) ss+=(s/p[i-1]%3==1)? p[i-1]:-p[i-1];
		for(int i=1;i<=n;i++) if(ss/p[i-1]%3==1) s1|=(1<<(i-1));
		ans=min(ans,f[s]+g[s1]);
	}
	for(int i=1;i<=cnt;i+=2) ans+=e[i].w;
}

int main(){
	n=read();m=read();init();
	for(int i=1;i<=m;i++){
		int x=read(),y=read(),w=read();
		dis[x][y]=dis[y][x]=min(dis[x][y],w);
		add(x,y,w);add(y,x,w);
		d[x]++;d[y]++;
	}
	m=read();
	for(int i=1;i<=m;i++){
		int x=read(),y=read(),w=read();
		dis[x][y]=dis[y][x]=min(dis[x][y],w);		
	}
	floyd();pre();dp();get_ans();
	printf("%d\n",ans);
	return 0;
}
```



---

## 作者：Demoe (赞：3)

### [题目传送门](https://www.luogu.com.cn/problem/P6085)

## 题意

- 给一张有权无向图，标记其中某些边。

- 从1号点出发要求我们找一条回路，且回路经过所有标记边。

- 最小化边权和。

---

我们找到一些边，使得构成**欧拉回路**。

那么就产生两个条件。

1. 所有点度数都是**偶数**。

2. 选出来的边构成的图，必须只有**一个联通分量**。

## Sol1

令 $f_{i,S}$ 表示当前每个点的状态，以及当前最后停留在 $i$ 的位置。

$S$ 状态每个点分成三种情况。

0：不与1连通

1：和1连通且度数为奇数

2：和1连通且度数为偶数

然而这样无法处理**强制选边**。

因此我们继续分析题目性质。

## Sol2

观察到所有边可以分成两部分。

一部分是到过的到没到过的点，另一部分是连接两个到过的点。

对于两个**到过的点**，连边即可改变他们的奇偶性。

且若走**最短路径**，一定会得到最好的效果。

我们猜想，可dp出所有点连通性的状态，然后我们再用最短路把奇数点之间两两连上。

令 $f_S$ 表示每个点与1号点连通状态确定时最小代价。

每次我们枚举边 $(i,j)$ 其中 $i$ 在 $S$ 中不为0，$j$ 为0。

**第一次**加进一个点的时候，附加上它使用必须边的连通性，即可把必须取边条件放上。

令 $w_i$ 表示只用 $k$ 条边，$i$ 和哪些点连通，且这些点奇偶状态如何。

我们在第一次加入连通块中的一个点时，我们就把所有点拖进去。

再令 $g_S$ 表示当 $S$ 中点为**奇数**时，变成偶数的最优解。

每次枚举点转移即可qwq。

时间复杂度 $O(3^n \times m)$，可能需要一些常数优化（¿）。

## 子集枚举

对**子集枚举**的复杂度进行一点分析。

这里的子集枚举为，在一个二进制数中，枚举所有为1的子集。

我们有一种通用写法。

这个写法看似很暴力~~实际上也很暴力~~，复杂度 $O(3^n)$。

实际上就是 $\sum^n_{i=0}C(n,i) \times 2^i$ 展开后同 $(1+2)^n$。

即为 $O(3^n)$。

---

## 作者：一架飞机 (赞：1)

# 题意

一张图，最开始有 $K$ 条带权无向边（以下称为“必须边”）。再给出 $M$ 条带权无向边（以下称为“不必须边”）（还没有连上去），选择其中若干条边连上去，使这张图变成从节点 1 开始的欧拉回路。求最小边权和。

# 思路

关于每次想都用 dij 结果发现题解都是 spfa 这件事。所以我用 dij A 了这道题。

现在需要满足以下条件：

1. 是欧拉回路，所以每个点的度数必须是偶数。

2. 只要连了边的点必须与节点 1 连通。即连了边的点 $x$ 都有至少一个相邻点 $y$ 与 1 连通（包括 1 自己）（实现时 $x$ 的第一次被连一定是被 $y$ 连）。

$N\leq13$，考虑状压。用三进制数 $S$ 表示当前图的状态，当前图满足只要连了**不必须边**的点必须与节点 1 连通。$S$ 的第 $i$ 位（以下表示为 $S_i$）可以是以下 3 种：

- 0，表示这个点不与 1 号节点连通。
- 1，连通且度数为奇。
- 2，连通且度数为偶。

现在 必须边 只在考虑连通性的时候考虑。现在的度数都指的是 不必须边 的度数。

考虑如何转移。选一个 不必须边 $(x,y)$，其中x必须是与 1 连通的，然后连上。（这里有的题解用了 floyd 先处理了最短路，其实可以不用）

这里需要注意：如果y之前没有与1连通，而y用 必须边 连了其他没有与1连通的点，这时候这些点的连通性也要变。所以预处理一个数组 `cpl[]`，$cpl_S$ 表示S连上必须边后的连通性，如果一个点只有必须边相连但与 1 连通则为 2（具体看代码）。

转移用 dij。复杂度是$O(3^n n^2log_{3^n})$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
template<typename T>void read(T&x){
	x=0;char ch=getchar();bool f=0;
	while(!isdigit(ch))f|=ch=='-',ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	x=f?-x:x;
}
const int N=15,M=2e6+50,K=205,INF=0x3f3f3f3f;
int ans,ind[N],nx[K],ny[K],nz[K],pos[M][N];
int dis[M],to[N][N],po[N],cpl[M],bto[N][N];
typedef pair<int,int> PII;
#define fi first
#define se second
#define mp(x,y) make_pair(x,y)
priority_queue<PII> q;
int add(int s,int x){
	if(pos[s][x]<2)return s+po[x];
	return s-po[x];
}
int main(){
	int n,tq,m;read(n),read(tq);
	//get needed eage
	memset(to,0x3f,sizeof(to));
	for(int i=1;i<=tq;i++){
		read(nx[i]),read(ny[i]),read(nz[i]);
		ind[nx[i]]++,ind[ny[i]]++;ans+=nz[i];
		to[nx[i]][ny[i]]=to[ny[i]][nx[i]]=min(to[nx[i]][ny[i]],nz[i]);
		bto[nx[i]][ny[i]]=bto[ny[i]][nx[i]]=1;
	}
	for(int i=1;i<=n;i++)bto[i][i]=1;
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				bto[i][j]|=(bto[i][k]|bto[k][j]);
	cout<<bto[1][5]<<endl;
	
	//get no-needed eage
	read(m);
	m+=tq;
	for(int i=tq+1;i<=m;i++){
		read(nx[i]),read(ny[i]),read(nz[i]);
		to[nx[i]][ny[i]]=to[ny[i]][nx[i]]=min(to[nx[i]][ny[i]],nz[i]);
	}
				
	//about 3进制 
	po[0]=1;for(int i=1;i<=n;i++)po[i]=po[i-1]*3;//po[i]=pow(3,i)
	for(int i=0;i<po[n];i++){
		int x=i,cc=0;
		while(x){
			pos[i][cc]=x%3;//pos[i][j]=三进制数i的第j位（从最低位开始）
			x/=3;cc++;
		}
	}
	
	//预处理cpl[]，连上必须边后的连通性
	for(int s=0;s<po[n];s++){
		cpl[s]=s;
		for(int x=1;x<=n;x++){
			if(pos[s][x-1])continue;
			for(int y=1;y<=n;y++)
				if(pos[s][y-1]&&bto[x][y]){
					cpl[s]+=2*po[x-1];
					break;
				}
		}
	}
	
	memset(dis,0x3f,sizeof(dis));
	q.push(mp(dis[cpl[2]]=0,cpl[2]));
	int ed=0;
	for(int i=1;i<=tq;i++)
		ed=add(add(ed,nx[i]-1),ny[i]-1);
	while(q.size()){
		int s=q.top().se,t;q.pop();
        int fl=0;
        for(int x=1;x<=n;x++){
            if(!pos[ed][x-1]){if(pos[s][x-1]==1){fl=1;break;}}
            else{if(pos[ed][x-1]!=pos[s][x-1]){fl=1;break;}}
        }
        if(!fl){
        	printf("%d",dis[s]+ans);
        	return 0;
		}
		for(int x=1;x<=n;x++){
			if(!pos[s][x-1])continue;
			for(int y=1;y<=n;y++)
				if(to[x][y]!=INF&&x!=y){
					t=cpl[add(add(s,x-1),y-1)];
					if(dis[t]>dis[s]+to[x][y]){
						dis[t]=dis[s]+to[x][y];
						q.push(mp(-dis[t],t));
					}
				}
		}
	}
	return 0;
}

```



---

## 作者：Shunpower (赞：0)

感觉现有题解都在扯淡。- -

-------------

显然这意味着 $1$ 所在的连通块存在欧拉回路。欧拉回路指引我们状压点的度数，据此我们容易获得一个 $\mathcal O(B(n)2^n\text{Poly}(n))$ 的做法，用 $\mathcal O(B(n))$ 来存储连通性。

考虑我们从一条一条加入边的角度来思考是比较困难的，因为我们不可避免地在过程中需要合并连通块。所以不妨转化成从点的角度思考，这样我们把连通块一个点一个点地塞进去，就不存在问题了。

然后问题就变成了怎么知道关键边有没有加入进去，以及怎么计算这部分贡献。我们不妨简单地把关键边的部分放到最后考虑（先全部塞进去又会需要合并连通块），这样贡献和度数的影响仍然很好算，但最后全部加入的时候连通性会比较麻烦。所以我们在加点的时候，应该认为关键边可以贡献到连通性，但它对答案的贡献是 $0$。

所以我们的操作指南就很明确了。我们先把连通块通过每次加点 dp 出来，最后再加入关键边。

考虑这个 dp 怎么写。显然我们同样要维护到奇偶性。但是注意到我们是在加点，所以我们永远只需要维护和 $1$ 相连的点的奇偶性。于是我们只需要 $3$ 进制：是否和 $1$ 连通，和 $1$ 连通的话还需要维护奇偶性。

因为生成连通块的顺序在状态当中的转移无法确定，所以我们要用最短路算法来转移。

然而这样复杂度比较差。因为如果我们要在 dp 连通块的同时考虑内部加边改变奇偶性的话，复杂度将来到跑满的 $\mathcal O(3^n(n^2+(m+k)))$，难以通过。但是你发现这是根本不必要的：我们完全可以先把连通块 dp 出来，保留关键边端点和 $1$ 连通的那些状态，这样连通性就不重要了。我们再用 $\mathcal O(2^n(m+k))$ 的复杂度做一遍加边改变奇偶性即可。

最短路的部分直接用 SPFA 就快得飞起。实现时注意细节，关键边可以用两次也太阴间了。

```cpp
int n,k,m;
struct edge{
    int x,y;
    ll z;
} E[300];
ll f[1594324];
bool vis[1594324];
ll g[2][1<<13];
queue <int> q;
int pow3[15];
ll dis[15][15];
bool key[15][15];
bool bol[15];
// #define Ltp cute
int main(){
#ifdef Ltp
    freopen("hack.txt","r",stdin);
    freopen("out.txt","w",stdout);
#endif
    ios::sync_with_stdio(false);
    memset(dis,0x3f,sizeof dis);
    cin>>n>>k;
    pow3[0]=1;
    fr1(i,1,n) pow3[i]=3*pow3[i-1];
    int sum=0;
    fr1(i,1,k){
        cin>>E[i].x>>E[i].y>>E[i].z;
        bol[E[i].x]=bol[E[i].y]=1;
        key[E[i].x][E[i].y]=key[E[i].y][E[i].x]=1;
    }
    cin>>m;
    fr1(i,k+1,k+m){
        cin>>E[i].x>>E[i].y>>E[i].z;
        dis[E[i].x][E[i].y]=min(E[i].z,dis[E[i].x][E[i].y]);
        dis[E[i].y][E[i].x]=min(E[i].z,dis[E[i].y][E[i].x]);
    }
    memset(f,0x3f,sizeof f);
    f[2]=0;
    q.push(2);
    while(!q.empty()){
        int S=q.front();
        q.pop();
        vis[S]=0;
        fr1(i,0,n-1){
            if(S/pow3[i]%3==0){
                fr1(j,0,n-1){
                    if(S/pow3[j]%3>0){
                        int c=S/pow3[j]%3;
                        int T=S+pow3[i]+(c==1?pow3[j]:-pow3[j]);
                        if(f[T]>f[S]+dis[j+1][i+1]){
                            f[T]=f[S]+dis[j+1][i+1];
                            if(!vis[T]) q.push(T),vis[T]=1;
                        }
                        if(key[j+1][i+1]){
                            T=S+2*pow3[i];
                            if(f[T]>f[S]){
                                f[T]=f[S];
                                if(!vis[T]) q.push(T),vis[T]=1;
                            }
                        }
                    }
                }
            }
        }
    }
    int op=0;
    memset(g,0x3f,sizeof g);
    fr1(S,0,pow3[n]-1){
        bool flg=1;
        fr1(i,0,n-1){
            if(bol[i+1]&&S/pow3[i]%3==0) flg=0;
        }
        if(flg){
            int T=0;
            ll w=f[S];
            fr1(i,0,n-1){
                if(S/pow3[i]%3==1) T|=(1<<i);
            }
            fr1(i,1,k){
                T^=(1<<E[i].x-1);
                T^=(1<<E[i].y-1);
                w+=E[i].z;
            }
            g[0][T]=min(g[0][T],w);
        }
    }
    fr1(i,1,k+m){
        fr1(S,0,(1<<n)-1) g[op^1][S]=min(g[op^1][S],g[op][S]);
        fr1(S,0,(1<<n)-1) g[op^1][S^(1<<E[i].x-1)^(1<<E[i].y-1)]=min(g[op^1][S^(1<<E[i].x-1)^(1<<E[i].y-1)],g[op][S]+E[i].z);
        memset(g[op],0x3f,sizeof g[op]);
        op^=1;
    }
    cout<<g[op][0]<<'\n';
    ET;
}
//ALL FOR Zhang Junhao.
```

---

## 作者：nomonick (赞：0)

# P6085 [JSOI2013]吃货 JYY

## 题面解析

题面 link : [P6085](https://www.luogu.com.cn/problem/P6085)

在一张有 $ N $ 个点 $ M + K $ 条边的图，保证必须经过其中 $ K $ 条边至少一次的最小花费。

## 算法的朴素分析

这个问题可以转化为在一张只连接了 $ K $ 个一定要经过的边图上添加若干条边，使最终形成一张欧拉回路，查询最小代价。

已知欧拉回路的充分必要条件是每一个点得度数为偶数且保证联通。

同时也可以注意到，$ K $ 条必要的边（下文称作关键边）在经过一次后就可以看做通剩余 $ M $ 条边（下文称作非关键边）类型相同的边。

## 考虑解法

首先，可以很直接的注意到这道题的 $ n $ 范围异常的小，满足 $ n \leq 13 $。所以不妨考虑对于状态进行压缩。

我们考虑到欧拉回路的充要条件后，可以得知整张图是否满足条件只和点的度数的奇偶性和图是否连同有关。

所以不难假设出如下状态

 - $0$ 表示当前点与一所在的联通块不连通
- $1$ 表示当前点与一所在的联通块连通且点的度数为奇数
- $2$ 表示当前点与一所在的联通块连通且点的度数为偶数这

这很显然是一个 $ 3^n $ 的状态，同时我们会发现在实现关键的边至少通过一次上只通过状压存在困难

我们这时候就应该考虑如何把这些边提前加入，并使它对结果不产生影响。

我们会发现把图分成只有 $ K $ 条必要的边组成的图，和又剩下的若干条边组成的图

我们会发现这样两个部分的图上每一个点度数奇偶性是相同的。那么就可以通过更新出剩下的若干条边组成的与有 $ K $ 条必要的边组成的图的奇偶性相同图的最小构造长度加上所有 $ K $ 条边的权值和作为最终的答案

所以我们可以先假设关键边不存在，在最后统一加关键边，计算代价。

## 具体实现

由于在算法中关键的边已经被保证一定经过了一次，那么关键边就和非关键边相同了，都可以添加若干次。由于 $ N $ 比较小，且我们需要的到任意两点之间的最短路以方便之后的加边的处理。

然后跑 SPFA 时考虑用关键边和非关键边更新。

先找到一个与一相连通的点，然后遍历它所有的关键边和非关键边，如果是关键边转移时不改变奇偶性也不会产生价值，非关键边会改变起点和终点的奇偶性也会产生新的价值。

注意别开 long long 他有点太慢了~~（莫名被卡常~~

## code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int SIZE = 50;
const int NUM = (int)3e2 + 10;
const int MAXN = (int)2e6 + 50;
const double inf = 0x3f3f3f3f3f3f3f3f;

inline int read()
{
	int x = 0,f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9')
	{
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f * x;
}

int n,crux,m,num_edge,ans;
int head[SIZE],degree[SIZE],power_3[SIZE],dp[MAXN];
int dis[SIZE][SIZE];
bool vis[MAXN];
struct node
{
	int to,nxt;
	int val;
};
node edge[NUM << 1];
queue <int> que;

inline void pre()
{
	power_3[0] = 1;
	for (int i = 1; i <= 15; ++i)
		power_3[i] = power_3[i-1] * 3;
}

inline void add(int u,int v,int val)
{
	edge[++num_edge].to = v;
	edge[num_edge].val = val;
	edge[num_edge].nxt = head[u];
	head[u] = num_edge;
}

inline int get_bit(int state,int pos)
{
	return state / power_3[pos-1] % 3;
}

inline void calc(int &state,int i,int now)
{
	state -= get_bit(state,i) * power_3[i-1];
	state += now * power_3[i-1];
}

inline void spfa()
{
	memset(dp,0x3f,sizeof(dp));
	int state = 0,next_state = 0; calc(state,1,2);
	que.push(state); dp[state] = 0; vis[state] = true;
	while (!que.empty())
	{
		state = que.front();
		que.pop(); vis[state] = false;
		for (int u = 1; u <= n; ++u)
		{
			if (!get_bit(state,u)) continue;
			for (int i = head[u]; i; i = edge[i].nxt)
			{
				int v = edge[i].to;
				next_state = state;
				calc(next_state,v,(get_bit(state,v) == 1 ? 1 : 2));
				if (dp[next_state] > dp[state])
				{
					dp[next_state] = dp[state];
					if (!vis[next_state])
					{
						que.push(next_state);
						vis[next_state] = true;
					}
				}
			}
		}
		for (int u = 1; u <= n; ++u)
		{
			if (!get_bit(state,u)) continue;
			for (int v = 1; v <= n; ++v)
			{
				if (u == v) continue;
				next_state = state;
				calc(next_state,u,(get_bit(state,u) == 1 ? 2 : 1)); calc(next_state,v,(get_bit(state,v) == 1 ? 2 : 1));
				if (dp[next_state] > dp[state] + dis[u][v])
				{
					dp[next_state] = dp[state] + dis[u][v];
					if (!vis[next_state])
					{
						que.push(next_state);
						vis[next_state] = true;
					}
				}
			}
		}
	}
}

signed main()
{
	freopen("test.in","r",stdin);
	n = read(); crux = read(); pre();
	memset(dis,0x3f,sizeof(dis));
	for (int i = 1; i <= n; ++i) dis[i][i] = 0;
	for (int i = 1; i <= crux; ++i)
	{
		int u = read(),v = read(),val = read();
		add(u,v,val); add(v,u,val);
		degree[u]++; degree[v]++; ans += val;
		dis[u][v] = dis[v][u] = min(dis[u][v],val);
	}
	m = read();
	for (int i = 1; i <= m; ++i)
	{
		int u = read(),v = read();
		dis[u][v] = dis[v][u] = min(dis[u][v],read());
	}
	for (int k = 1; k <= n; ++k)
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= n; ++j)
				dis[i][j] = min(dis[i][j],dis[i][k] + dis[k][j]);
	spfa();int state = 0;
	for (int i = 1; i <= n; ++i)
		if (degree[i] || i == 1) calc(state,i,(degree[i] & 1 ? 1 : 2));
	ans += dp[state]; printf("%d\n",ans);
	return 0;
}

```



---

## 作者：SDNetFriend (赞：0)

## P6085 [JSOI2013]吃货 JYY 题解

### 整体情况

总体上还是 Floyd+SPFA+状压，但在答案处理上与现有题解统计方式不同。

### 题意这里不再赘述

[P6085 [JSOI2013]吃货 JYY](https://www.luogu.com.cn/problem/P6085)

### 朴素分析

我们发现问题可以转化为在一个图上加入一些边，可以加重边，有些关键边必须加，使最后的图为欧拉图的最小代价。

已知图是欧拉图的充要条件是各点度数都是偶数且是连通图，考虑如何求解这个问题。

### 深入分析

既然要让每个点度数都是偶数，那么说明点度数奇偶性对答案求解有关，而且发现 $n\leq 13$ 意识到可以状压。

考虑如何压缩状态，根据欧拉图的充要条件，并且从一开始结束，不难想到状态可以设为：

0. 当前点不与一连通、
1. 当前点与一连通并且度数为奇数。
2. 当前点与一连通并且度数为偶数。

然后我们可以发现这是一个 $O(3^n)$ 的状态，计算没什么问题。那如何转移呢？首先这个关键边比较麻烦，我们考虑怎样转化可以让我们最后再考虑关键边。

可以想到，在连通性维护方面我们可以考虑关键边，但是在代价计算和度数统计的时候我们假设关键边不存在即可，这样我们就可以最后统一加关键边，计算代价了。

那具体实现就是先把关键边和非关键边用 Floyd 求出两两点最短距离，这里对于跑了不止一次的关键边直接看成非关键边就可以，而且有个性质是不会改变途经点的奇偶性，在奇偶性统计方面直接看成连了一条两点之间的边就可以。

然后跑 SPFA 时考虑用关键边和非关键边更新。先找到一个连通的点，然后遍历其关键边和非关键边，如果是关键边转移时不改变代价也不改变奇偶性，非关键边要增加边权的代价并改变起点终点的代价。

### 答案计算

很多题解都用了一个二进制的状态来描述当前点集度数为奇数的情况下，加入多少价值的边可以使图转化为欧拉图，最后计算时先模拟加入所有关键边，然后把度数为奇数的点塞进集合后加上转化为欧拉图的代价。

实际上并不用，我们只需要考虑加入关键边之后每个点度数的改变。如果改变的是奇数，那我们就用 SPFA 求出的对应点是奇度的答案，否则就用偶度的答案，这样能对答案产生贡献的状态只有一个，也就好写了很多。

### 贴代码

```cpp
#include <bits/stdc++.h>
#define lint long long
#define rint register int
using namespace std;
inline int read(){
	char c;int f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const int N=15,K=80,M=605,S=2e6,inf=0x3f3f3f3f;
int n,k,m;
int hed[N],nxt[M],ver[M],w[M],cnt=1;
//w为边权 d为对两端点的度数贡献 只有重要边 
inline void ae(int u,int v,int _w){
	ver[++cnt]=v;nxt[cnt]=hed[u];
	hed[u]=cnt;w[cnt]=_w;
}
inline void abe(int u,int v,int _w)
	{ae(u,v,_w);ae(v,u,_w);}
struct edge{int u,v,w;}edg[K];
int dis[N][N];//仅用非重要边更新
int f[S],pw[N];//f[i]表示状态为i的最小花费 
inline void init(){
	//计算3的次幂
	pw[0]=1;
	for(rint i=1;i<N;++i)
		pw[i]=pw[i-1]*3; 
}
inline int gt(int s,int i){return s/pw[i-1]%3;}
inline void upd(int &s,int i,int v)
	{s-=gt(s,i)*pw[i-1];s+=v*pw[i-1];}
queue<int> q;bool vis[S];
inline void print(int s){
	for(rint i=1;i<=n;++i)
		cout<<gt(s,i);
	cout<<endl;
}
inline void SPFA(){
	memset(f,0x3f,sizeof f);
	int s=0,t=0;upd(s,1,2);//1点连通且0度为偶度 
	q.push(s);vis[s]=true;f[s]=0;
	while(!q.empty()){
		s=q.front();q.pop();
		vis[s]=false;
		//考虑关建边影响
		for(rint u=1;u<=n;++u){
			if(!gt(s,u))continue;
			for(rint e=hed[u];e;e=nxt[e]){
				int v=ver[e];
				t=s;upd(t,v,gt(s,v)==1?1:2);
				if(f[t]>f[s]){
					f[t]=f[s];
					if(!vis[t])
						q.push(t),vis[t]=true; 
				}
			}
		}
		//考虑非关建边影响 
		for(rint u=1;u<=n;++u){
			if(!gt(s,u))continue;
			for(rint v=1;v<=n;++v){
				if(u==v)continue;t=s;
				upd(t,v,gt(t,v)==1?2:1);
				upd(t,u,gt(t,u)==1?2:1);
				if(f[t]>f[s]+dis[u][v]){
					f[t]=f[s]+dis[u][v];
					if(!vis[t])
						q.push(t),vis[t]=true; 
				}
			}
		}
	}
} 
int d[N],ans;
inline void calc(){
	int s=0;
	for(rint i=1;i<=n;++i)
		if(d[i]||i==1)upd(s,i,(d[i]&1)?1:2);
	ans+=f[s];
}
int main(){
	n=read();k=read();
	memset(dis,0x3f,sizeof dis);
	for(rint i=1;i<=k;++i){
		int u=read(),v=read();
		int _w=read();
		edg[i]=edge{u,v,_w};
		abe(u,v,_w);++d[u];++d[v];ans+=_w;
		dis[u][v]=dis[v][u]=min(dis[u][v],_w);
	}
	m=read();
	for(rint i=1;i<=n;++i)dis[i][i]=0;
	for(rint i=1;i<=m;++i){
		int u=read(),v=read();
		dis[u][v]=dis[v][u]=min(dis[u][v],read());
	}
	for(rint c=1;c<=n;++c)
		for(rint u=1;u<=n;++u)if(dis[u][c]!=inf)
			for(rint v=1;v<=n;++v)if(dis[c][v]!=inf)
				dis[u][v]=min(dis[u][v],dis[u][c]+dis[c][v]);
	init();SPFA();
	calc();printf("%d",ans);
	return 0;
}


```


---


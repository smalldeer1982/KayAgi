# [JSOI2015] 送礼物

## 题目背景

JYY 和 CX 的结婚纪念日即将到来，JYY 来到萌萌开的礼品店选购纪念礼物。

萌萌的礼品店很神奇，所有出售的礼物都按照特定的顺序都排成一列，而且相邻
的礼物之间有一种神秘的美感。于是，JYY 决定从中挑选连续的一些礼物，但究
竟选哪些呢？

## 题目描述

假设礼品店一共有 $N$ 件礼物排成一列，每件礼物都有它的美观度。排在第 $i\ (1\leq i\leq N)$ 个位置的礼物美观度为正整数 $A_i$。JYY 决定选出其中连续的一段，即编号为 $i,i+1,\cdots,j-1,j$ 的礼物。选出这些礼物的美观程度定义为

$$\frac{M(i,j)-m(i,j)}{j-i+K}$$

其中 $M(i,j)$ 表示 $\max\{A_i,A_{i+1},\cdots,A_j\}$，$m(i,j)$ 表示 $\min\{A_i,A_{i+1},\cdots,A_j\}$，$K$ 为给定的正整数。
由于不能显得太小气，所以 JYY 所选礼物的件数最少为 $L$ 件；同时，选得太多也不好拿，因此礼物最多选 $R$ 件。JYY 应该如何选择，才能得到最大的美观程度？由于礼物实在太多挑花眼，JYY 打算把这个问题交给会编程的你。



## 说明/提示

对于 $100\%$ 的数据，$T\leq 10$，$N,K\leq 5\times 10^4$，$1\leq A_i\leq 10^8$，$2\leq L,R\leq N$。

## 样例 #1

### 输入

```
1
5 1 2 4
1 2 3 4 5```

### 输出

```
0.7500```

# 题解

## 作者：Z_Healer (赞：9)

### [P6087 [JSOI2015]送礼物](https://www.luogu.com.cn/problem/P6087)

>给你一个序列，求区间长度在$[L,R]$之间的美观度最大，区间$[l,r]$的美观度为$\dfrac{\max_{i=l}^{r}a_i-\min_{i=l}^{r}a_i}{r-l+k}$。

建议看看我的[01分数规划学习笔记](https://www.luogu.com.cn/blogAdmin/article/edit/333789)效果更佳。


当看到求一个**分式的最大值**时，第一时间想到**分数规划**，但这道题与普通的分数规划不一样，不能直接定义权值，因为区间最大/小值(分子)与区间边界(分母)**没有直接关系**。

对于最大/小值在区间内部的，缩小区间长度只会使答案更优。那么我们尝试将最大/小值放到区间的边界上，则美观度可以变为$\dfrac{\left|a[r]-a[l]\right|}{r-l+k}$，但不过这样可能满足不了$r-l+1\ge L$的限制。我们可以先将小于$L$处理掉，再处理大于的。

对于一组最大最小值距离小于$L$的，我们将长度直接扩展到$L$是最优的，那么分母就确定为$L-1+k$，问题就变为求$L$个连续的数中的最大值和最小值，是[单调队列的模板题](https://www.luogu.com.cn/problem/P1886)。

对于长度大于$L$的区间，我们通过$01$分数规划，二分一个答案$mid$，对式子$\dfrac{\left|a[r]-a[l]\right|}{r-l+k}\ge mid$进行推导。

当$a[r]>a[l]$，$(a[r]-r*mid)-(a[l]-l*mid)\ge k*mid$

当$a[r]<a[l]$，$(a[l]+l*mid)-(a[r]+r*mid)\ge k*mid$

由区间长度小于$L$的方法，我们可以想到用单调队列来处理。

当$a[r]>a[l]$，$l$从1开始，$r$从$L$开始，维护$(a[l]-l*mid)$单调递减，当队头距离$i$大于$R$时弹出，每次从队尾加入$a[i-L+1]$，当$(a[i]-i*mid)-(a[q[h]]-q[h]*mid)\ge k*mid$成立时，当前$mid$可以。

当$a[r]<a[l]$，维护$(a[l]-l*mid)$单调递增，当$(a[q[h]]-q[h]*mid)-(a[i]-q[i]*mid)\ge k*mid$成立时，当前$mid$可以。

```cpp
#include<bits/stdc++.h>
#define N 50010
using namespace std;
inline int read(){
	int w=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch<='9'&&ch>='0'){
		w=(w<<3)+(w<<1)+(ch^48);
		ch=getchar();
	}
	return w;
}
int t,n,L,R;
double a[N],k;
inline double pre(){
	double res=0;
	int he1=1,he2=1,ta1=0,ta2=0,q1[N],q2[N];
	for(int i=1;i<L;i++){
		while(he1<=ta1&&a[i]>=a[q1[ta1]]) ta1--; 
		while(he2<=ta2&&a[i]<=a[q2[ta2]]) ta2--;
		q1[++ta1]=i;q2[++ta2]=i;
	}
	for(int i=L;i<=n;i++){
		while(he1<=ta1&&a[i]>=a[q1[ta1]]) ta1--; 
		while(he2<=ta2&&a[i]<=a[q2[ta2]]) ta2--;
		q1[++ta1]=i;q2[++ta2]=i;
		while(he1<=ta1&&i-q1[he1]>=L) he1++;
		while(he2<=ta2&&i-q2[he2]>=L) he2++;
		res=max(res,(a[q1[he1]]-a[q2[he2]])/(double)(L-1+k));
	}
	return res;
}
inline bool check(double x){
	double c[N];
	int he=1,ta=0,q[N];
	memset(q,0,sizeof(q));
	for(int i=1;i<=n;i++) c[i]=a[i]-x*(double)i;
	for(int i=L;i<=n;i++){
		while(he<=ta&&i-q[he]>=R) he++;
		while(he<=ta&&c[i-L+1]<=c[q[ta]]) ta--;
		q[++ta]=i-L+1;
		if(c[i]-c[q[he]]>=x*k) return 1;
	}
	he=1;ta=0;
	memset(q,0,sizeof(q));
	for(int i=1;i<=n;i++) c[i]=a[i]+x*(double)i;
	for(int i=L;i<=n;i++){
		while(he<=ta&&i-q[he]>=R) he++;
		while(he<=ta&&c[i-L+1]>=c[q[ta]]) ta--;
		q[++ta]=i-L+1;
		if(c[q[he]]-c[i]>=x*k) return 1;
	}
	return 0;
}
inline double work(){
	double l=0,r=1e3,mid,eps=1e-7;
	while(r-l>eps){
		mid=(l+r)/2.0;
		if(check(mid)) l=mid;
		else r=mid;
	}
	return max(l,pre());
}
int main(){
	t=read();
	while (t--){
		n=read();k=read();L=read();R=read();
		for(int i=1;i<=n;i++) a[i]=read();
		printf("%.4lf\n",work());
	}
	return 0;
}

```


---

## 作者：王鲲鹏 (赞：8)

对于这种分式求最值，可以考虑用 01分数规划。

设
$$
\frac{\max\{i,j\}-\min\{i,j\}}{i-j+k} \leq V \qquad (L \leq i-j+1\leq R)
$$
这里因为我们一般外层枚举的变量为 $i$，所以我把原题中$i$ $j$交换了。
$$
\max\{i,j\}-\min\{i,j\} -iV +jV\leq kV
$$
区间中取最值，不太好处理，考虑如何做一个替换。

分讨，

1. 最大最小值距离不超过 $L$ ，可以考虑取出每一段$L$区间中的最值，直接计算出值$\frac{\max-\min}{L-1+k}$。

2. 距离大于$L$。$\max \min$仍然不好在不枚举 $j$ 的情况下确定。。考虑直接认为 $a_i$, $a_j$ 是最大值和最小值，这样就可以方便地用单调队列维护。显然这样会有很多值是错误的。但是我们可以想一想，这些错解和正确的值是不是存在某种关系？

3. 
$$
a_i-a_j-iV+jV\leq kV \qquad a_i\text{为最大值}

$$

$$
a_j-a_i-iV+jV\leq kV \qquad a_j\text{为最大值}
$$

稍加思考发现，当$a_i$ $a_j$ 并不是最大值和最小值时，左边的值只会小于正确的值，用单调队列维护的过程中，两端均为最值的情况都能取到（指距离大于 $L$ 的）。  

因此得出结论，这样虽然过程中会有错解，但不影响取到正确答案。


回过去思考，发现其实第一种情况也能用这样方式处理，无疑方便了求解。


代码：
```cpp
#include <cstdio>
inline double max(double a, double b) { return a < b ? b : a; }
int n = 0, k = 0, L = 0, R = 0;
int a[50003];
double dl[50003];
int id[50003], l = 1, r = 0;
inline void push(int pos, double val) { //最大值
	while (l <= r && dl[r] <= val)
		--r;
	++r;
	dl[r] = val;
	id[r] = pos;
}
inline void push2(int pos, double val) { //最小值
	while (l <= r && dl[r] >= val)
		--r;
	++r;
	dl[r] = val;
	id[r] = pos;
}
inline void pop(int limit) {
	while (l <= r && id[l] <= limit)
		++l;
}
bool check(double V) {
	// Max{i,j} - jV - Min{i,j} + vi - kv >= 0 ?
	double ans = -1e5;
	// a[i] 为最大值
	l = 1;
	r = 0;
	for (int i = L; i <= n; ++i) {
		push(i - L + 1, -a[i - L + 1] + (i - L + 1) * V);
		pop(i - R);
		if (l <= r) ans = max(ans, dl[l] + a[i] - i * V);
	}
	// a[i] 为最小值
	l = 1;
	r = 0;
	for (int i = L; i <= n; ++i) {
		push(i - L + 1, +a[i - L + 1] + (i - L + 1) * V);
		pop(i - R);
		if (l <= r) ans = max(ans, dl[l] - a[i] - i * V);
	}
	return ans >= V * k;
}
double inRangeAnswer() {
	double ans = -1e5;
	l = 1; r = 0;
	for (int i = 1; i <= n; ++i) {
		push(i, a[i]);
		pop(i - L);
		ans = max(ans, (dl[l] - a[i]) / (L - 1 + k));
	}
	l = 1; r = 0;
	for (int i = 1; i <= n; ++i) {
		push2(i, a[i]);
		pop(i - L);
		ans = max(ans, (a[i] - dl[l]) / (L - 1 + k));
	}
	return ans;
}
int main() {
	int T = 0;
	scanf("%d", &T);
	for (int t = 1; t <= T; ++t) {
		scanf("%d%d%d%d", &n, &k, &L, &R);
		for (int i = 1; i <= n; ++i)
			scanf("%d", a + i);
		double l = 0.0, r = 1000.0, mid = 0.0;
		while (r - l > 0.000001) {
			mid = 0.5 * (l + r);
			if (check(mid))
				l = mid;
			else
				r = mid;
		}
		printf("%.4lf\n", max(l,inRangeAnswer()));
	}
	return 0;
}
```

---

## 作者：ImmortalWatcher (赞：6)

二分答案。

原式 
$=(M(i,j)-mid\times j)-(m(i,j)-mid\times i)\geq k\times mid\;\;(j\geq i)$

然后强制 $j$ 为区间最大值，$i$ 为最小值，如果 $j$ 不是最大值或 $i$ 不是最小值，左式的答案都会更大，所以如果原式成立就成立，然后枚举 $j$，维护最小的 $(a_i-mid\times i)$ 即可。

这里我们枚举的情况是最小值在左最大值在右的情况，另一种情况同理处理即可。

然后有一个特殊情况，就是 $i$ 为 $j$ 的最优左端点时，但区间最小值不是 $i$ ，最小值不在 $j$ 的合法范围内。

因为最小值不在j的合法范围，但是取完 $i$~$j$ 是合法的，所以我们可能会把这种情况弄成不合法。这时我们可以算出所有长度为L-1的方案的答案，然后与总答案比较即可。

```cpp
#include<cstdio>
#define max(x,y) (x>y?x:y)
using namespace std;
int t,L,R,n,k,a[50001],head,tail,q[50001],heada,headb,taila,tailb,qa[50001];
int qb[50001];
double l,r,mid,ans1,ans;
double pd(double mid)
{
	head=1;tail=0;ans=-0x3FFFFFFF;
	for (int i=1;i<=n;i++)
	{
		if (i>=L)
		{
			int t=i-L+1;
			while (head<=tail&&a[t]-mid*t<=a[q[tail]]-mid*q[tail]) tail--;
			q[++tail]=t;
		}
		if (head<=tail&&q[head]<i-R+1) head++;
		if (head<=tail) ans=max(ans,a[i]-i*mid-(a[q[head]]-mid*q[head]));
	}
	for (int i=1;i<=n;i++)
		a[i]=-a[i];
	head=1;tail=0;
	for (int i=1;i<=n;i++)
	{
		if (i>=L)
		{
			int t=i-L+1;
			while (head<=tail&&a[t]-mid*t<=a[q[tail]]-mid*q[tail]) tail--;
			q[++tail]=t;
		}
		if (head<=tail&&q[head]<i-R+1) head++;
		if (head<=tail) ans=max(ans,a[i]-i*mid-(a[q[head]]-mid*q[head]));
	}
	for (int i=1;i<=n;i++)
		a[i]=-a[i];
	return ans;
}
int main()
{
	scanf("%d",&t);
	while (t--)
	{
		scanf("%d%d%d%d",&n,&k,&L,&R);
		for (int i=1;i<=n;i++)
			scanf("%d",&a[i]);
		ans1=0;heada=1;taila=0;headb=1;tailb=0;
		for (int i=1;i<=n;i++)
		{
			while (heada<=taila&&a[i]>=a[qa[taila]]) taila--;
			qa[++taila]=i;
			while (headb<=tailb&&a[i]<=a[qb[tailb]]) tailb--;
			qb[++tailb]=i;
			if (heada<=taila&&i-qa[heada]>=L-1) heada++;
			if (headb<=tailb&&i-qb[headb]>=L-1) headb++;
			ans1=max(ans1,(double)(a[qa[heada]]-a[qb[headb]])/(L-1+k));
		}
		l=0;r=1e3;
		while (l+0.000001<r)
		{
			mid=(l+r)/2;
			if (pd(mid)>=k*mid) l=mid;
			else r=mid;
		}
		printf("%.4lf\n",max(l,ans1));
	}
	return 0;
}
```


---

## 作者：hegm (赞：4)

### [P6087 [JSOI2015]送礼物](https://www.luogu.com.cn/problem/P6087)

二分 $mid$，列出式子 $M(i,j)-m(i,j)-(j-i+K)\times mid<0$

那么问题就是如何求解最大的 

$M(i,j)-m(i,j)-(j-i+K)\times mid$

发现不太好解决，我们拆解一下。

$M(i,j)-m(i,j)-j\times mid+i\times mid-K\times mid$

我们先假设没有长度在 $L\sim R$ 的限制，考虑一个显然的事实，最大值和最小值一定在区间的最左边和最右边，否则不是最优的。

我们分情况讨论：

-  最小值在右边，最大值在左边：

题目转化为求 $a_l+l\times mid-a_r-r\times mid$ 最大，$K$ 为常数，暂时忽略。

那么我们就可以把 $i$ 的代价视为 $a_i+i\times mid$ 找到最小和最大的权值即可。

可是他有 $L\sim R$ 的范围哎，不好搞。

我们考虑枚举一个左端点为 $i$，那么我们只要求出 $i+L-1\sim i+R-1$ 范围内的最小值就行。如何求这个？当然可以线段树，但是我们注意到我们是求固定长度的最大值，并且要求 $n$ 次，每次向左移动一位，这是什么？**单调队列！**

问题就简单了，单调队列直接求解即可。

- 最小值和最大值交换位置同理，可以算出 $i$ 的权值应该为 $a_i-i\times mid$。

还要注意一个细节，当我们要找的 $j$ 和 $i$ 的距离小于 $L$ 就一定不行吗？

这是我们可以多选几个凑数到 $L$ 个，所以对于这种情况，我们也单独用单调队列求解。

细节蛮多的，可以看看代码。

### $\text{CODE}$
```cpp
#include<bits/stdc++.h>
#define N 1000006
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const double eps=1e-6;
const int inf=1e9;
int t,n,k,L,R,len;
double val[N],a[N];
deque<int> q,p;
double solve1()
{
	double ans=-inf;len=R-L+1;
	while(q.size())q.pop_back();
	for(int i=L;i<=R;i++)
	{
		while(q.size()&&val[q.back()]>val[i])q.pop_back();
		q.push_back(i);
	}
	for(int i=1;i<=n;i++)
	{
		while(q.size()&&q.front()-i<L-1)q.pop_front();
		ans=max(ans,val[i]-val[q.front()]);
		while(q.size()&&val[q.back()]>val[R+i])q.pop_back();
		q.push_back(R+i);
	}
	return ans;
}
double solve2()
{
	double ans=-inf;len=R-L+1;
	while(q.size())q.pop_back();
	for(int i=L;i<=R;i++)
	{
		while(q.size()&&val[q.back()]<val[i])q.pop_back();
		q.push_back(i);
	}
	for(int i=1;i<=n;i++)
	{
		while(q.size()&&q.front()-i<L-1)q.pop_front();
		ans=max(ans,val[q.front()]-val[i]);
		while(q.size()&&val[q.back()]<val[R+i])q.pop_back();
		q.push_back(R+i);
	}
	return ans;
}
double solve3(double mid)
{
	double ans=-inf;len=L-1;
	while(q.size())q.pop_back();
	while(p.size())p.pop_back(); 
	for(int i=1;i<len;i++)
	{
		while(q.size()&&val[q.back()]<val[i])q.pop_back();
		q.push_back(i);
		while(p.size()&&val[p.back()]>val[i])p.pop_back();
		p.push_back(i);
	}
	for(int i=len;i<=n;i++)
	{
		while(q.size()&&val[q.back()]<val[i])q.pop_back();
		if(q.size()&&i-q.front()>=len)q.pop_front();
		q.push_back(i);
		while(p.size()&&val[p.back()]>val[i])p.pop_back();
		if(p.size()&&i-p.front()>=len)p.pop_front();
		p.push_back(i);
		ans=max(ans,val[q.front()]-val[p.front()]);
	}
	return ans-mid*(L-1);
}
bool check(double mid)
{
	double ans=-inf;
	for(int i=1;i<=n;i++)val[i]=a[i]+mid*i;
	for(int i=1;i<=n;i++)val[i+n]=inf;
	ans=max(ans,solve1());
	for(int i=1;i<=n;i++)val[i]=a[i]-mid*i;
	for(int i=1;i<=n;i++)val[i+n]=-inf;
	ans=max(ans,solve2());
	for(int i=1;i<=n;i++)val[i]=a[i];
	ans=max(ans,solve3(mid));
	return ans-mid*k>0;
}
int main()
{
	t=read();
	while(t--)
	{
		n=read();k=read();L=read();R=read();
		for(int i=1;i<=n;i++)a[i]=read();
		double l=0,r=1e3,mid;
		while(r-l>eps)
		{
			mid=(l+r)/2.0;
			if(check(mid))l=mid;
			else r=mid;
		}
		printf("%.4f\n",r);
	}
	return 0;
}
```

容易 `TLE` ，开 $O_2$ 能过。

---

## 作者：Gao_yc (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P6087)

大概题意：找出一个区间，$len \in [L,R]$，使得区间内极值差与 $len+1+k$ 比值最大，输出最大比值。

**答案有两种可能，一种是极值为区间左右端点；另一种是极值之间距离小于 $L$，需要在左右侧加入其他端点来保证区间合法。**

主函数：对 $E$ 二分答案，将二分出的答案与计算当 $r-l+1=L$ 的情况下的答案取最大值。


------------

### check：

贪心计算当极值在左右端点的区间。

推式子：

$a_{max} -a_{min} \ge x(r-l+k)$

$a_{max} -a_{min} -xr +xl \ge xk$

代码中 $ans$ 维护的即为 $a_{max} -a_{min} -xr +xl$ 的最大值。

把更新 $ans$ 的数值拆成两段，左端点用单调队列维护，右端点枚举。对于区间长度的限制，通过单调队列实现。

再说单调队列加入的权值。维护的权值，以左端点为最大值为例，单调队列维护的是 $a_{min}+xr$ 的最小值。接下来答案的处理就直接看代码吧，相信都能看懂了。

值得一提的是单调队列设定 $len$ 数值，应为 $R-L+1$，因为当确定左端点  $i$，通过单调队列寻找最优右端点并更新答案时，右端点的值域为 $[i+L-1,i+R-1]$，故要设单调队列维护的长度为 $R-L+1$。

------------

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5;
int n,k,L,R,a[N];
pair<int,double> q[N];
int head,tail,len,now;
void init(int x){head=0,tail=-1,len=x,now=0;}
void outq()
{
	if(head<=tail&&q[head].first==++now-len) head++;
}
void inq(double x)
{
	outq();
	while(tail>=head&&q[tail].second>=x) --tail;
	q[++tail]=make_pair(now,x);
}
bool check(double x)
{
	double ans=-1e18;
	init(R-L+1);
	for(int i=L;i<R;++i) inq(a[i]+x*i);
	for(int i=R;i<=n;++i) 
	{
		inq(a[i]+x*i);
		ans=max(ans,a[i-R+1]+x*(i-R+1)-q[head].second);
	}
	for(int i=n-R+2;i<=n-L+1;++i) 
	{
		outq();
		ans=max(ans,a[i]+x*i-q[head].second);
	}
	//以上处理左端点为最大值，以下处理左端点为最小值 
	init(R-L+1);
	for(int i=1;i+L-1<=n;++i) 
	{
		inq(a[i]-x*i);
		ans=max(ans,a[i+L-1]-x*(i+L-1)-q[head].second);
	}
	return ans>x*k;
}
double getmin()
{
	double ans=-1e18;
	init(L*2-1);
	for(int i=1;i<=L-1;++i) inq(a[i]);
	for(int i=L;i<=n;++i)
	{
		inq(a[i]);
		ans=max(ans,a[i-L+1]-q[head].second);
	}
	for(int i=n-L+2;i<=n;++i) 
	{
		outq();
		ans=max(ans,a[i]-q[head].second);
	}
	return ans/(L+k-1);
}
int main()
{
//	freopen("extreme.in","r",stdin);
//	freopen("extreme.out","w",stdout);
	int t;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d%d%d",&n,&k,&L,&R);
		for(int i=1;i<=n;++i) scanf("%d",a+i);
		double l=0,r=1e9,mid;
		for(int i=1;i<=60;++i)
		{
			mid=(l+r)/2;
			if(check(mid)) l=mid;
			else r=mid;
		}
		mid=max(mid,getmin());
		printf("%.4lf\n",mid);
	}
    return 0;
}

```


---

## 作者：kradcigam (赞：2)

# 分析

先考虑如果没有 $L$ 和 $R$ 的长度限制，我们发现最优解中对于区间 $l\sim r$，$A_l$ 和 $A_r$ 应该分别为 $A_l,A_{l+1},\cdots,A_r$ 中的最大值和最小值。

考虑加上 $L$ 和 $R$ 的长度限制，若原来的区间为 $l\sim r$，则会分如下 3 种情况进行讨论：

1. 如果 $r-l+1< L$，那么我们可以考虑把它的长度补成 $L$。

2. 如果 $L\le r-l+1\le R$，那么这直接可以作为答案。

3. 如果 $R<r-l+1$，那么它坏了。

综上所述，只有情况 $1,2$ 是需要考虑的。

## 对于第一种情况

区间长度固定为 $L$，分 $A_r$ 为最大值和最小值跑一下单调队列就好了。

## 对于第二中情况

我们再回来看那个式子，发现是个分数规划，非常常规地转换成判断性问题：

$$
\begin{aligned}
\frac{M(l,r)-m(l,r)}{r-l+K}&\ge mid\\
M(l,r)-m(l,r)&\ge mid\times(r-l+K)\\
M(l,r)-m(l,r)-mid\times r+mid\times l&\ge mid\times K
\end{aligned}
$$

不妨另 $A_r$ 为区间 $l\sim r$ 的最大值，$A_l$ 为区间 $l\sim r$ 的最小值。

$$
\begin{aligned}
A_r-A_l-mid\times r+mid\times l&\ge mid\times K\\
(A_r-mid\times r)-(A_l-mid\times l)&\ge mid\times K
\end{aligned}
$$

用单调队列实现一下就可以了。

$A_r$ 为区间 $l\sim r$ 的最小值，$A_l$ 为区间 $l\sim r$ 的最大值同理。

## 实现细节

就是极为有用的小 trick——弱化最大值，最小值。

你会发现用上述方法实现非常困难，因为你要强制取最大或取最小。

但是稍作思考，你会发现，如果不取最大值最小值答案一定不会更优，所以写代码的时候完全不需要考虑。

```cpp
#include<bits/stdc++.h>
#define log(a) cerr<<"\033[32m[DEBUG] "<<#a<<'='<<(a)<<" @ line "<<__LINE__<<"\033[0m"<<endl
#define LL long long
#define SZ(x) ((int)x.size()-1)
#define ms(a,b) memset(a,b,sizeof a)
#define F(i,a,b) for(int i=(a);i<=(b);++i)
#define DF(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
inline int read(){char ch=getchar(); int w=1,c=0;
	for(;!isdigit(ch);ch=getchar()) if (ch=='-') w=-1;
	for(;isdigit(ch);ch=getchar()) c=(c<<1)+(c<<3)+(ch^48);
	return w*c;
}
const int N=5e4+10;
const double eps=1e-6;
int a[N],n,k,L,R,q[N],s,t;
double b[N],c[N];
inline double situation1(){
	double ans=0;
	s=1,t=0;
	F(i,1,n){
		while(s<=t&&i-q[s]>=L)s++;
		if(s<=t)ans=max(ans,(a[i]-a[q[s]])/((double)(L+k-1)));
		while(s<=t&&a[q[t]]>a[i])t--;
		q[++t]=i;
	}
	s=1,t=0;
	F(i,1,n){
		while(s<=t&&i-q[s]>=L)s++;
		if(s<=t)ans=max(ans,(a[q[s]]-a[i])/((double)(L+k-1)));
		while(s<=t&&a[q[t]]<a[i])t--;
		q[++t]=i;
	}return ans;
}
inline bool check(double x){
	F(i,1,n)b[i]=a[i]-x*i,c[i]=a[i]+x*i;
	s=1,t=0;
	F(i,1,n){
		while(s<=t&&i-q[s]+1>R)s++;
		if(s<=t&&b[i]-b[q[s]]>=x*k)return true;
		if(i>=L){
			while(s<=t&&b[q[t]]>b[i-L+1])t--;
			q[++t]=i-L+1;
		}
	}
	s=1,t=0;
	F(i,1,n){
		while(s<=t&&i-q[s]+1>R)s++;
		if(s<=t&&c[q[s]]-c[i]>=x*k)return true;
		if(i>=L){
			while(s<=t&&c[q[t]]<c[i-L+1])t--;
			q[++t]=i-L+1;
		}
	}
	return false;
}
inline double situation2(){
	double l=0,r=10001;
	while(l+eps<r){
		double mid=(l+r)/2.0;
		if(check(mid))l=mid;
		else r=mid;
	}return l;
}
signed main(){
	int _=read();
	while(_--){
		n=read(),k=read(),L=read(),R=read();
		F(i,1,n)a[i]=read();
		cout<<fixed<<setprecision(4)<<max(situation1(),situation2())<<endl;
	}
	return 0;
}
```






---

## 作者：hzoi_liuchang (赞：1)

## 分析

看到这一个式子，显然是 $01$ 分数规划

但是一般的 $01$ 分数规划都是上面一个求和公式比下面一个求和公式

而这一道题则是最大值减去最小值比区间长度加一个定值的形式

我们手玩一下会发现，一个区间的左右两端一定是该区间的最大值或最小值

因为如果你在最大值或者最小值的基础上继续扩展的话，分母会变大，结果会变小，肯定不利于我们求解

但是有可能最大值和最小值之间的元素个数小于最小的区间长度 $l$ ，此时我们就必须向两边扩展

因此，我们分两种情况讨论：

$1$ 、 区间的长度大于 $l$ 

此时，我们像正常的 $01$ 分数规划一样二分枚举即可

我们设此时枚举到的价值为 $mids$

那么如果 $\frac{M(i,j)-m(i,j)}{j-i+K} \geq mids$

则有 $\ M(i,j)-m(i,j) \geq mids \times (j-i+K)$

根据之前推导的结论，两边的元素只能是最大值或者最小值

因此我们分类讨论

如果区间左边的元素大于区间右边的元素

则有 $a[i]-a[j] \geq mids \times (j-i+K)$

我们展开移一下项，就有 

$a[i]-a[j] \geq mids \times j- mids \times i +mids \times K$

$a[i]+i \times mids - a[j] - j \times mids \geq mids \times K$

我们令 $val[i]=a[i]+i \times mids$

则就有 $val[i]-val[j] \geq mids \times K$

其中右边是一个常数

于是我们惊喜地发现这玩意可以用单调队列去搞一下

同理，如果区间左边的元素大于区间右边的元素

则有 $a[j]-a[i] \geq mids \times (j-i+K)$

$a[j]-a[i] \geq mids \times j- mids \times i +mids \times K$

$a[j]- j \times mids - a[i] + i \times mids \geq mids \times K$

我们令 $val[i]=a[i]-i \times mids$

则就有 $val[j]-val[i] \geq mids \times K$

也可以用单调队列去维护

$2$ 、区间的长度等于 $l$

此时我们用 $ST$ 表预处理出区间最大最小值

每次从左到右扫一边枚举左端点即可

## 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
const double eqs=1e-6;
int zdz[maxn][20],zxz[maxn][20],a[maxn],n,k,l,r;
double ans=0;
void solve1(){
	int cd=log2(l);
	for(int i=1;i<=n-l+1;i++){
		int j=i+l-1;
		double mmax=max(zdz[i][cd],zdz[j-(1<<cd)+1][cd]);
		double mmin=min(zxz[i][cd],zxz[j-(1<<cd)+1][cd]);
		ans=max(ans,(mmax-mmin)/((double)l-1+(double)k));
	}
}
//枚举区间等于l的情况，直接暴扫
int ql[maxn],qr[maxn],headl,headr,taill,tailr;
double val[maxn];
bool jud(double mids){
	double res=mids*k;
	memset(ql,0,sizeof(ql));
	memset(qr,0,sizeof(qr));
	headl=1,taill=0,headr=1,tailr=0;
	for(int i=1;i<=n;i++){
		val[i]=(double)a[i]-i*mids;
	}
	for(int i=l;i<=n;i++){
		while(headl<=taill && i-ql[headl]+1>r) headl++;
		if(headl<=taill && val[i]-val[ql[headl]]>=res) return 1;
		while(headl<=taill && val[i-l+1]<=val[ql[headl]]) taill--;
		ql[++taill]=i-l+1;
	}
	for(int i=1;i<=n;i++){
		val[i]=(double)a[i]+i*mids;
	}
	for(int i=l;i<=n;i++){
		while(headr<=tailr && i-qr[headr]+1>r) headr++;
		if(headr<=tailr && val[qr[headr]]-val[i]>=res) return 1;
		while(headr<=tailr && val[qr[tailr]]<=val[i-l+1]) tailr--;
		qr[++tailr]=i-l+1;
	}
	return 0;
}
//单调队列分别搞一下
void solve2(){
	double ml=0,mr=1000,mmids;
	while(mr-ml>eqs){
		mmids=(ml+mr)/2;
		if(jud(mmids)) ml=mmids;
		else mr=mmids;
	}
	ans=max(ans,ml);
}//01分数规划
int main(){
	int t;
	scanf("%d",&t);
	while(t--){
		scanf("%d%d%d%d",&n,&k,&l,&r);
		ans=0;
		for(int i=1;i<=n;i++){
			for(int j=0;j<20;j++){
				zxz[i][j]=0x3f3f3f3f,zdz[i][j]=-0x3f3f3f3f;
			}
		}
		for(int i=1;i<=n;i++){
			scanf("%d",&a[i]);
			zxz[i][0]=a[i];
			zdz[i][0]=a[i];
		}
		for(int j=1;j<=18;j++){
			for(int i=1;i+(1<<j)-1<=n;i++){
				zxz[i][j]=min(zxz[i][j-1],zxz[i+(1<<(j-1))][j-1]);
				zdz[i][j]=max(zdz[i][j-1],zdz[i+(1<<(j-1))][j-1]);
			}
		}
		//ST表预处理
		solve1();
		//情况一
		solve2();
		//情况二
		printf("%.4lf\n",ans);
	}
	return 0;
}
```

---


# [JSOI2015] 圈地

## 题目背景

JYY 在火星买了一大块矩形的地皮做房地产开发。由于地皮实在是太大了，JYY 把这块地皮划分成了 $N$ 行 $M$ 列的小方格，并在每一格中建造一栋房子。历时若干年，开发终于宣告结束，JYY 也可以把这些房子挂牌出售了。现在他找到了两位非同寻常的土豪买家：南南和强强。

麻烦的是，南南和强强是水火不容的。为了保证他们俩不发生矛盾，JYY 需要把卖给他们俩的房子用墙隔开。不过造墙是需要钱的，JYY 作为倒卖地皮的专家，自然想挣尽可能多的钱，因此他邀请到你帮他设计最优的出售方案。

## 题目描述

JYY 把这块地皮划分成了 $N$ 行 $M$ 列的矩形，且矩形的每一格中建造一栋房子。现在，南南和强强已经将他们的购买意见提交给了 JYY。对于每一栋房子，南南和强强已经给定了他们的出价（不想购买，或愿意以一定价格购买），并且由于他们已经协商好了各自的势力范围，因此不存在两个人同时想买一栋房子的情况。JYY 可以选择每一栋房子是否出售（因为不存在两个人同时想买一栋房子的情况，若 JYY 选择出售一栋房子，它的买家就是确定的）。房子卖给强强和南南以后，JYY 就能获得卖出房子出价的总和。

不过，作为售后服务，JYY 需要通过造墙（将两栋相邻的房子用一堵墙隔开）把两个人的房子完全隔开。所谓完全隔开，就是指造出的墙以及四周的边界将整个区域划分成若干个不连通的部分，每个部分里面只有一个人的房子。当然，造墙也是需要钱的，而且价格不菲。不过 JYY 当初在宣传时声称造墙完全免费，所以这部分钱只好由 JYY 自己出了。

JYY 请你为他规划每幢房子是否要卖出以及建造哪些围墙，才能使得卖房子的收益减去造围墙的花费最大。另外一个好消息是整个地皮的四周已经建好了墙，因此 JYY 可以利用这些建好的墙达到目的。下图就是用墙将区域划分成 $3$ 个不连通的部分的例子。格子中的数字代表出价（数字的含义参考输入格式），边上的数值代表造墙的价格。四周的墙（边界）本来就有，不需要 JYY 花额外的代价去建造。

![](https://cdn.luogu.com.cn/upload/image_hosting/t57031da.png)

## 说明/提示

对于 $100\%$ 的数据，$1\leq N,M\leq 200$，任何价格都不超过 $1000$。

## 样例 #1

### 输入

```
5 5
-3 7 0 0 0
8 0 7 -10 0
0 7 0 1 0
0 0 0 0 0
-8 0 0 2 10
4 50 50 1 50
50 50 1 9 50
50 50 1 1 50
2 50 50 50 50
2 50 50 50
50 50 1 1
50 1 8 1
50 50 50 50
1 50 50 50```

### 输出

```
48```

# 题解

## 作者：Rusalka (赞：4)

原题链接：[P6094 [JSOI2015]圈地](https://www.luogu.com.cn/problem/P6094)

## 题意简述

- 把一块 $n \times m$ 的地分给两个人，选择分出第 $i$ 行第 $j$ 列的地可以获得 $a_{i,j}$ 的收益。

- 要在两个人分到的地中间建墙，使得两个人分到的地完全隔离，建两个格子之间的墙需要花费一定代价。

- 最大化总收益与总代价的差

- $1 \le n, m \le 200$

- ~~细节还是见原题吧QAQ~~

## 思路与解答

- ~~你看它数据范围这么小肯定是个图论建模，而且大概率网络流~~

- 你看这题相当于要把地分成两块，并且代价最小。

- 那就是一个最小割嘛

- 然后考虑怎么建图

- 你在建图时需要保证能选或不选一块地，并且要能够“割”开两块属于不同的人的地

- 假设两个人分别为 A 和 B，那么首先把相邻两块地之间连边，流量为建墙的花费，表示如果要“割”开这两块地就要砍掉这条边，当然要不要砍再说；注意这里无法保证你要怎么“割”，所以两块地要**分别**向对方连边。

- 那么之后建一个超级源点 $S$，把 $S$ 和所有 A 想要的地连边，流量为这块地的收益，如果在权衡之后不选，就把这条边“割”掉；同理，把所有 B 想要的地和超级汇点 $T$ 连边，流量也为这块地的收益。

- 那么你在这张图中跑一遍最小割，得到的结果就是你需要**付出的最小代价**，这里是包括了选或者不选一块地。

- 所以你只需要把总收益，即**所有结点的收益和减去最小割**即可。

- 最后，你只需要知道最小割等于最大流，就可以愉快的切题了

## Code 

```cpp
#include <cstdio>
#include <queue>
#include <iostream>
#include <cstring>
#define abs(x) (x<0?-x:x)

using namespace std;

const int MAXN = 80010;
const int INF = 0x3f3f3f3f; 

int n, m;

inline int id(int i, int j){return (i-1)*m+j;}

struct edge{
	int ne, to, fl;
	edge(int N=0,int T=0,int F=0):ne(N),to(T),fl(F){}
}e[MAXN*6];
int fir[MAXN], num = 1;
int s, t;
inline void adde(int a, int b, int c)
{
	e[++num] = edge(fir[a], b, c);
	fir[a] = num;
}
inline void join(int a, int b, int c)
{
	adde(a, b, c);
	adde(b, a, 0);
}

int dep[MAXN], cur[MAXN];
queue<int> q;
bool bfs(int s, int t)
{
	for(int i=0;i<=n*m+1;i++)
		dep[i] = 0, cur[i] = fir[i];
	while(!q.empty()) q.pop();
	q.push(s);
	dep[s] = 1;
	while(!q.empty())
	{
		int u = q.front();
		q.pop();
		for(int i=fir[u];i;i=e[i].ne)
		{
			int v = e[i].to;
			if(dep[v] || !e[i].fl) continue;
			dep[v] = dep[u] + 1;
			q.push(v);
		}
	}
	return dep[t];
}
int dfs(int u, int fln)
{
	if(u == t) return fln;
	int res = 0;
	for(int& i=cur[u];i;i=e[i].ne)
	{
		int v = e[i].to;
		if(!e[i].fl || dep[v] != dep[u]+1) continue;
		int sum = dfs(v, min(fln, e[i].fl));
		e[i].fl -= sum;
		e[i^1].fl += sum;
		fln -= sum;
		res += sum;
		if(!fln) break;
	}
	if(!res) dep[u] = 0;
	return res;
}
inline int dinic()
{
	int res = 0;
	while(bfs(s, t)) res += dfs(s, INF);
	return res;
}

int main()
{
	scanf("%d%d",&n,&m);
	s = 0; t = n*m+1;
	int sum = 0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			int a;
			scanf("%d",&a);
			if(a > 0) join(s, id(i, j), a);
			if(a < 0) join(id(i, j), t, -a);
			sum += abs(a);
		}
	}
	for(int i=1;i<n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			int a;
			scanf("%d",&a);
			join(id(i, j), id(i+1, j), a);
			join(id(i+1, j), id(i, j), a);
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<m;j++)
		{
			int a;
			scanf("%d",&a);
			join(id(i, j), id(i, j+1), a);
			join(id(i, j+1), id(i, j), a);
		}
	}
	printf("%d\n",sum-dinic());
	return 0;
}
```

---

## 作者：JohnJoeZhu (赞：2)

题解这么少啊qwq

~~先膜 @辰星凌 大佬~~

[传送门](https://www.luogu.com.cn/problem/P6094)

## Solution

[思路源（弱化版）](https://www.luogu.com.cn/problem/P2598)

##### 算法

这就是网络流没跑了吧

那我就跑最大流

咦？发现没办法选啊

那我就来最小割了，反正 正难则反 嘛

##### 建边

怎么建边？

- $a>0$ $add(s,i,a)$
- $a<0$ $add(i,t,-a)$
- $a=0$ 啥都不干

然后把所有围墙都建起来，即

- $add(id(i,j),id(i,j+1),w)$ $add(id(i,j+1),id(i,j),w)$
- $add(id(i,j),id(i+1,j),w)$ $add(id(i+1,j),id(i,j),w)$

注意围墙上下或左右一定要双向建边，因为割的时候肯定要两边都割掉

##### 割边的含义

- 向源汇点的边

割掉了就是不买了嘛，留下了的就是对答案产生贡献的嘛

- 表示墙的边

割掉了就是建墙嘛，因为建墙两家人就不连通了嘛（最小割的目标就是源汇断开来嘛）

##### 答案的统计

怎么计算总流量（就是拿去减最小割的总和的值）呢？

我就把所有边权就加起来不就可以了

咦？怎么又不对啊

因为我们割掉的墙都是要建的，留下了的都是不建的墙，所以最小割中墙的部分是不能先加起来的，建墙只会花钱不会赚钱啊

也就是这个总流量就是所有房子卖价的绝对值的和

然后就AC了

## code

```cpp
#include<cstdio>
#include<cmath>
#include<queue>
#define maxn 160010
#define inf 1e9
#define min(A,B) A<B?A:B
using namespace std;
struct edge{
    int nex,v,w;
}edge[maxn<<4];
int head[maxn],top=1,cur[maxn];
int n,m,s,t,ans=0,maxflow=0;
bool vs=0;
int vis[maxn],deep[maxn];
void addedge(int u,int v,int w)
{
    edge[++top].v=v;
    edge[top].w=w;
    edge[top].nex=head[u];
    head[u]=top;
}
void add(int u,int v,int w){addedge(u,v,w),addedge(v,u,0);}
bool bfs()
{
    for(int i=0;i<=t;i++) cur[i]=head[i],deep[i]=inf,vis[i]=0;
    deep[s]=0;
    queue<int> q;
    q.push(s);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(int i=cur[u];i;i=edge[i].nex)
        {
        	cur[u]=i;
            int v=edge[i].v;
            if(deep[u]+1<deep[v]&&edge[i].w)
            {
                deep[v]=deep[u]+1;
                if(!vis[v])
                {
                    q.push(v);
                    vis[v]=1;
                }
            }
        }
    }
    if(deep[t]!=inf) return 1;
    return 0;
}
int dfs(int u,int lowest)
{
    int rlow=0;
    if(u==t)
	{
		vs=1;
		maxflow+=lowest;
		return lowest;
	 } 
	int used=0;
    for(int i=head[u];i;i=edge[i].nex)
    {
        int v=edge[i].v;
        if(edge[i].w&&deep[u]+1==deep[v])
        {
            if((rlow=dfs(v,min(lowest-used,edge[i].w))))
            {
            	used+=rlow;
                edge[i].w-=rlow;
                edge[i^1].w+=rlow;
                if(used==lowest) break;
            }
            
        }
    }
    return used;
 } 
void Dinic(){maxflow=0;while(bfs()) dfs(s,inf);}//模板来的
int gid(int x,int y){return m*(x-1)+y;}
int main()
{
    scanf("%d%d",&n,&m);
    s=0,t=n*m+1;
    for(int i=1,w;i<=n;i++)
    	for(int j=1;j<=m;j++)
    	{
    		scanf("%d",&w);
    		if(w>0) add(s,gid(i,j),w);
    		if(w<0) add(gid(i,j),t,-w);
    		ans+=w>0?w:-w; 	//ans为总流量
		}
        //以下是建墙的边
	for(int i=1,w;i<n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&w),add(gid(i,j),gid(i+1,j),w),add(gid(i+1,j),gid(i,j),w);
	for(int i=1,w;i<=n;i++)
		for(int j=1;j<m;j++)
			scanf("%d",&w),add(gid(i,j),gid(i,j+1),w),add(gid(i,j+1),gid(i,j),w);
    Dinic();
    printf("%d",ans-maxflow);//总流量-最小割
    return 0;
 } 
```
~~这就可以溜了~~

---

## 作者：mqmhaaaa1 (赞：1)

~~很明显是大水题啊...~~

主要考验对最小割的理解。

在看完题后，我们要对题目有个基本的理解，那便是**我们的目标**，这是解决所有网络流问题的基本，你解不出来的网络流题都是没有明确目标，目标是建图之本。

本题的目标为：**以最小代价使南南（下称 $S$ 集合）与强强（下称 $T$ 集合）买的房子隔开**。

在这里，我们很容易想到把**隔开**这一目的变为**割断**，也觉是说，我们有一个基本的想法：**把这个网格图建成图，每个房子为点，相邻点之间连容量为在那建墙的代价的边，在图上把 $S$ 集合与 $T$ 集合的点全隔开，就是跑最小割**。

这个基本思想有了事实上就很简单了，剩下的就是对最小割的基本理解了。

我们把每个房子分成在 $S$ 集合或在 $T$ 集合中，如果南南能买的的房子在 $T$ 集合，相当于没买，对于强强能买的房子也一样。

我们由源点（下称 $s$）向南南能买的房子连容量为房子价格的边，相当于划分在 $S$ 集合内就能获得相应贡献。一样的，我们把强强能买的的房子向汇点（下称$t$）连容量为房子价格的边，表示划分到 $T$ 集合能获得相应贡献。

这时候再跑最小割，相当于比较割三种东西的优劣性。

1. 割掉 $S$ 集合里房子与 $s$ 的连边，划分到 $T$ 集合，相当于不买。

2. 割掉 $T$ 集合里房子与 $t$ 的连边，也相当于不买。

3. 割掉 $S$ 集合的点与 $T$ 集合的点之间的边，相当于建墙.

很明显，只要对最小割理解到位，肯定能想明白。

在这里，最小割就是比较贡献的一种手段。

看代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll int
#define i8 __int128
void write(ll x) {static ll sta[35];ll top = 0;do {sta[top++] = x % 10, x /= 10;} while (x);while (top) putchar(sta[--top] + 48);}
ll read() {ll x = 0, w = 1;char ch = 0;while (ch < '0' || ch > '9') {  if (ch == '-') w = -1;ch = getchar();}while (ch >= '0' && ch <= '9') {x = x * 10 + (ch - '0'); ch = getchar(); }return x * w; }
const ll N=5e4+10,M=2e6+10,inf=0x3f3f3f3f;
ll to[M<<1],nxt[M<<1],w[M<<1],bh[N],tot=1;
ll from[M<<1];
ll bj[M<<1];
ll head[N],st[N];
bool vis[N];
inline void add(ll u,ll v,ll z){
	to[++tot]=v;
	nxt[tot]=bh[u];
	w[tot]=z;
	bh[u]=tot;
	bj[tot]=1;
	from[tot]=u;
//	cout<<u<<" "<<v<<" "<<z<<'\n';
	to[++tot]=u;
	nxt[tot]=bh[v];
	w[tot]=0;
	bh[v]=tot;
	bj[tot]=0;
	from[tot]=v;
}
ll s,t;
inline bool bfs(){
	for(ll i=s;i<=t;i++){
		head[i]=bh[i];
		vis[i]=0;
		st[i]=0;
	}
	queue<ll>q;
	q.push(s);
	st[s]=0;vis[s]=1;
	while(q.size()){
		ll u=q.front();q.pop();
//		cout<<u<<'\n';
		vis[u]=0;
		for(ll i=bh[u];i;i=nxt[i]){
			ll v=to[i];
			if(w[i]&&!st[v]&&v!=s){
				st[v]=st[u]+1;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	return st[t];
}
ll mxf=0;
ll dic(ll u,ll flow){
//	cout<<u<<" "<<flow<<'\n';
	vis[u]=1;
	if(u==t){
		mxf+=flow;return flow;
	}
	ll zy=0;
	for(ll i=head[u];i&&flow;i=nxt[i]){
		ll v=to[i];head[u]=i;
		if(w[i]&&(!vis[v]||v==t)&&st[v]==st[u]+1){
			ll jb=dic(v,min(w[i],flow));
			w[i]-=jb,w[i^1]+=jb;
			zy+=jb;flow-=jb;
			if(!flow)break;
		}
	}
	vis[u]=0;
	return zy;
}
//dinic板子 
ll n,m;
ll id(ll i,ll j){
	return (i-1)*m+j;
}
ll sum=0;
int main(){
	n=read();m=read();
	s=0;t=n*m+1;
	for(ll i=1;i<=n;i++){
		for(ll j=1;j<=m;j++){
			ll u=id(i,j);
			ll val=read();
			if(val>0)add(s,u,val),sum+=val;
			if(val<0)add(u,t,-val),sum+=-val;//记得取反 
		}
	}
	for(ll i=1;i<n;i++){
		for(ll j=1;j<=m;j++){
			ll val=read();
			ll u=id(i,j),v=id(i+1,j);
			add(u,v,val);add(v,u,val);//双向边 
		}
	}
	for(ll i=1;i<=n;i++){
		for(ll j=1;j<m;j++){
			ll val=read();
			ll u=id(i,j),v=id(i,j+1);
			add(u,v,val);add(v,u,val);//双向边 
		}
	}
	while(bfs()){
		vis[t]=1;
		while(vis[t]){
			memset(vis,0,sizeof vis);
			dic(s,inf);
		}
	}
	write(sum-mxf);
	return 0;
	//水水水 
}
```

---

## 作者：辰星凌 (赞：1)

# **【题解】圈地 [JSOI2015] [P6094] [Bzoj4485]**

[$\mathcal{My}\ \mathcal{Blog}$](https://www.cnblogs.com/Xing-Ling/p/12713249.html)

传送门：[圈地 $\text{[JSOI2015] [P6094]}$](https://www.luogu.com.cn/problem/P6094) [$\text{[Bzoj4485]}$](http://www.lydsy.com/JudgeOnline/problem.php?id=4485)

## **【分析】**

一道灰常简单的网络流。

设立超源和超汇，对于每个位置 $(i,j)$：

- 若 $a>0$，超源向 $(i,j)$ 连一条容量为 $a$ 的边

- 若 $a<0$，$(i,j)$ 向超汇连一条容量为 $-a$ 的边

对于每个墙，在被它隔离的两个位置之间分别向对方连一条容量为造墙价格的边。

最后答案为 $\sum |a|$ 减去 最小割。

这题 $Dinic$ 可以稳过，写 $EK$ 会被卡到 $70pts$。

## **【Code】**

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#define LL long long
#define Re register int
using namespace std;
const int N=160010,M=N*5,inf=2e9;
int n,m,x,st,ed,ans;
inline void in(Re &x){
    int f=0;x=0;char c=getchar();
    while(c<'0'||c>'9')f|=c=='-',c=getchar();
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    x=f?-x:x;
}
struct Dinic{
    int o,h,t,maxflow,Q[N],dis[N],cur[N],head[N];
    Dinic(){o=1;}
    struct QAQ{int to,next,flow;}a[M<<1];
    inline void add_(Re x,Re y,Re flow){a[++o].to=y,a[o].flow=flow,a[o].next=head[x],head[x]=o;}
    inline void add(Re x,Re y,Re flow){add_(x,y,flow),add_(y,x,0);}
    inline int bfs(Re st,Re ed){
        for(Re i=0;i<=ed;++i)dis[i]=0,cur[i]=head[i];
        h=1,t=0,Q[++t]=st,dis[st]=1;
        while(h<=t){
            Re x=Q[h++];
            for(Re i=head[x],to;i;i=a[i].next)
                if(a[i].flow&&!dis[to=a[i].to]){
                    dis[to]=dis[x]+1,Q[++t]=to;
                    if(to==ed)return 1;
                }
        }
        return 0;
    }
    inline int dfs(Re x,Re flow){
        if(x==ed||!flow)return flow;
        Re tmp=0,to,f;
        for(Re i=cur[x];i;i=a[i].next){
            cur[x]=i;
            if(dis[to=a[i].to]==dis[x]+1&&(f=dfs(to,min(flow-tmp,a[i].flow)))){
                a[i].flow-=f,a[i^1].flow+=f,tmp+=f;
                if(flow==tmp)break;
            }
        }
        return tmp;
    }
    inline void dinic(Re st,Re ed){while(bfs(st,ed))maxflow+=dfs(st,inf);}
}T1;
inline int Poi(Re i,Re j){return (i-1)*m+j;}
int main(){
//    freopen("123.txt","r",stdin);
    in(n),in(m),st=n*m+1,ed=st+1;
    for(Re i=1;i<=n;++i)
        for(Re j=1;j<=m;++j){
            in(x),ans+=(x>0?x:-x);
            if(x>0)T1.add(st,Poi(i,j),x);
            if(x<0)T1.add(Poi(i,j),ed,-x);
        }
    for(Re i=1;i<n;++i)
        for(Re j=1;j<=m;++j)
            in(x),T1.add(Poi(i,j),Poi(i+1,j),x),T1.add(Poi(i+1,j),Poi(i,j),x);
    for(Re i=1;i<=n;++i)
        for(Re j=1;j<m;++j)
            in(x),T1.add(Poi(i,j),Poi(i,j+1),x),T1.add(Poi(i,j+1),Poi(i,j),x);
    T1.dinic(st,ed),printf("%d\n",ans-T1.maxflow);
}
```


---

## 作者：vanueber (赞：0)

# 题目大意

选择一些位置获得收益，并建造一些墙，并且不同类型的收益在不同的联通块中。

# 题目分析

 如果有做过关于最小割建模的题，如 [AT_arc107_f [ARC107F] Sum of Abs](https://www.luogu.com.cn/problem/AT_arc107_f) ，那么不难看出此题的最小割建模。

 建立超级源点 $s$，超级汇点 $t$。如果 $(i,j)$ 位置上的房子 $a_{i,j}>0$ 则与 $s$ 连边，如果 $a_{i,j} < 0$ 则与 $t$ 连边，容量都为 $|a_{i,j}|$。

 对于围墙，那么将隔开的两个位置连 **双向边**，容量为建造围墙的费用。

 答案为 $\sum |a_{i,j}| - c(S,T)_{min}$。由最大流最小割定理，跑最大流算法即可。

正确性：
 
 首先要满足连通性的约束，由于最终给一个人的房子一定与 $s$ 相连，另一个人与 $t$ 相连，这等价于 $s,t$ 不在一个集合中，所以一个合法的划分一定是一个割。

同时考虑一个最小割中的割边的意义：

1. 如果与 $s$ 相连，那么代表没有选这个房子。
2. 与 $t$ 相连，同理，只不过属于另一个人。
3. 其他情况，这些边割掉相当于建墙。

感性理解一个割一定是一个合法方案：

由于这个图建出来十分完全，代表如果一个点不给它划分出一个联通块区域，它一定可以通过一条路径找到另一个人的房子，这样就表明了 $S,T$ 集合被这一条路径连通了，与割的定义矛盾。

# 代码


```cpp
#include <bits/stdc++.h>
#ifndef ONLINE_JUDGE
#include <debug.h>
#endif
#define pii pair<int,int>
#define all(x) x.begin(),x.end()
#define ull unsigned long long
#define uint unsigned int
#define rg register
#define il inline
#define rep(i,a,b) for(rg int i=(a);i<=(b);++i)
#define sqr(x) ((x)*(x))
using namespace std;
const int INF=0x3f3f3f3f;
inline int read()
{
    int w=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        w=(w<<1)+(w<<3)+(ch^48);
        ch=getchar();
    }
    return w*f;
}
inline void write(int x)
{
    if(x<0)
    {
        putchar('-');
        x=-x;
    }
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

const int N=2e5+10,M=2e5+10;
int s,t,n,m;
int cur[N],dep[N],vis[N];
int tot=1,head[N],cnt;
struct edge
{
    int u,v,w,nxt;
}e[M<<1];
il void add(int u,int v,int w)
{
    e[++tot]={u,v,w,head[u]},head[u]=tot;
    e[++tot]={v,u,0,head[v]},head[v]=tot;
}
il bool bfs()
{
    for(int i=1;i<=cnt;++i)
    {
        dep[i]=vis[i]=0;cur[i]=head[i];
    }
    queue<int> Q;
    Q.push(s);dep[s]=vis[s]=1;
    while(!Q.empty())
    {
        int u=Q.front();
        Q.pop();
        for(int i=head[u],v,w;i;i=e[i].nxt)
        {
            v=e[i].v,w=e[i].w;
            if(!vis[v]&&w)
            {
                vis[v]=1,dep[v]=dep[u]+1;
                Q.push(v);
            }
        }
    }
    return dep[t];
}
int dfs(int u,int flow)
{
    int res=0;
    if(u==t)
    {
        return flow;
    } 
    int used=0;
    for(int i=cur[u];i;i=e[i].nxt)
    {
        cur[u]=i;
        int v=e[i].v;
        if(e[i].w&&dep[v]==dep[u]+1)
        {
            res=dfs(v,min(flow-used,e[i].w));
            used+=res;
            e[i].w-=res;e[i^1].w+=res;
            if(!res) dep[v]=-1;
            if(used==flow) break;
        }
    }
    return used;
}
il int dinic()
{
    int maxflow=0;
    while(bfs())
    {
        maxflow+=dfs(s,INF);
    }
    return maxflow;
}
int ans;
int id(int x,int y)
{
	return (x-1)*m+y;
}
int main()
{
    #ifndef ONLINE_JUDGE
    //freopen("in.txt","r",stdin);
    #endif
    cin>>n>>m;
    s=n*m+1,cnt=t=s+1;
    for(int i=1,a;i<=n;++i)
    {
		for(int j=1;j<=m;++j)
		{
			a=read();
			ans+=abs(a);
			if(a>0) add(s,id(i,j),a);
			if(a<0) add(id(i,j),t,-a);
		}
	}
	for(int i=1,x;i<n;++i)
	{
		for(int j=1;j<=m;++j)
		{
			x=read();
			add(id(i,j),id(i+1,j),x);
			add(id(i+1,j),id(i,j),x);
		}
	}
	for(int i=1,x;i<=n;++i)
	{
		for(int j=1;j<m;++j)
		{
			x=read();
			add(id(i,j),id(i,j+1),x);
			add(id(i,j+1),id(i,j),x);
		}
	}
	cout<<ans-dinic()<<endl;
    return 0;
}

```

# 总结

关于划分成两个有一定性质集合的问题，可以将一种类型与 $s$ 连边，另一种类型与 $t$ 连边。

开始时默认都选上，将不满足条件需要删除的代价简称边，利用最小割模型，使得最终得到的解满足条件且代价最小。

---

## 作者：Eazin_star (赞：0)

### 思路
首先看到题面以及数据范围 ~~当然还有标签~~ 可以想到网络流，这道题让我们分割土地，那很自然地想到最小割。

那建图又如何建呢？不难想到，对于 $a$ 大于零的情况，将地于源点连边；对于 $a$ 小于零的情况，将地于汇点连边；等于零的情况就啥也不做。~~毕竟也做不了啥~~

至于围墙，就直接把两块地相连，权值为墙的造价。

接下来跑一遍最小割，得到的答案就是我们所需要付出的最小代价，所以只需要将总收益减去付出的最小代价就可以得到答案啦！

### 代码
```cpp
#include <bits/stdc++.h>
#define int long long
#define INF 0x3f3f3f3f
using namespace std;

struct JZ {
	int to, nxt, val;
}edge[10000005];
queue <int> q;
int n, m, s, t, cnt = 1, sum, ans;
int head[200005], dep[200005], now[200005];
void add(int u, int v, int w) { //最小割模板
	edge[++cnt] = {v, head[u], w};
	head[u] = cnt;
}
void add_edge(int u, int v, int w) {
	add(u, v, w), add(v, u, 0);
}
bool bfs() {
	while (!q.empty()) q.pop();
	memset(dep, -1, sizeof dep);
	dep[s] = 1, q.push(s), now[s] = head[s];
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		for (int i = head[u]; i; i = edge[i].nxt) {
			int v = edge[i].to, w = edge[i].val;
			if (w && dep[v] == -1) dep[v] = dep[u]+1, q.push(v), now[v] = head[v];
		}
	}
	return ~dep[t];
}
int dfs(int u, int val) {
	if (u == t || !val) return val;
	int res = 0;
	for (int i = now[u]; i; i = edge[i].nxt) {
		int v = edge[i].to, w = edge[i].val;
		now[u] = i;
		if (w && dep[v] == dep[u]+1) {
			int flow = dfs(v, min(val, w));
			if (!flow) dep[v] = INF;
			val -= flow, res += flow;
			edge[i].val -= flow, edge[i^1].val += flow;
			if (!val) break;
		}
	}
	if (!res) dep[u] = -1;
	return res;
}
void dinic() {
	while (bfs()) ans += dfs(s, INF);
}
signed main() {
	scanf("%lld %lld", &n, &m);
	s = 0, t = n*m+1;
	for (int i = 1; i <= n; i++) {
		for (int j = 1, x; j <= m; j++) {
			scanf("%lld", &x); sum += abs(x); //将单个点的收益加起来得到总收益
			if (x > 0) add_edge(s, (i-1)*m+j, x); //建边
			if (x < 0) add_edge((i-1)*m+j, t, -x);
		}
	}
  //建围墙的边，注意是双向边！！！因为割边的时候要割两边
	for (int i = 1; i < n; i++) {
		for (int j = 1, x; j <= m; j++) {
			scanf("%lld", &x);
			add_edge((i-1)*m+j, i*m+j, x), add_edge(i*m+j, (i-1)*m+j, x); 
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1, x; j < m; j++) {
			scanf("%lld", &x);
			add_edge((i-1)*m+j, (i-1)*m+j+1, x), add_edge((i-1)*m+j+1, (i-1)*m+j, x);
		}
	}
	dinic(); //跑最小割
	printf("%lld\n", sum-ans); //输出答案
	return 0;
} 
```

---

## 作者：Kaenbyou_Rin (赞：0)

###  1. 算法分析：

  题目要求我们把图分为两个部分，再加上数据范围，我们可以想到最小割。

而根据~~我不会的~~证明可知，最小割用最大流跑就行了。



------------


### 2.建图：

  对于第一组 $n*m$ 的输入，我们想到可以建立超级源点和超级汇点，分别与两位买家连一条流量为 $a$ 的边，并用 $sum$ 记录 $a$ 的**绝对值**之和。
  
  对于第二组 $(n-1)*m$ 个输入，我们将第 $i$ 个点与第 $i+1$ 个点连一条流量为 $a[i][j]$ 的边，对于对于第三组 $n*(m-1)$ 个输入，我们将第 $j$ 个点与第 $j+1$ 个点也连一条流量为 $a[i][j]$ 的边。
  
  很显然，最大流（即为JYY出的冤枉钱）由于连接源汇点的边的流量限制，会小于他卖出房子恰的钱，最后将 $sum$ 减去 $ans$ 输出即为最终的答案。
  
### 3.Code:

  这里用的是 **Dinic**。
  
```
#include<bits/stdc++.h>
const int N=5e5+10;
const int inf=0x3f3f3f3f;
inline int read(){
	int x=0,w=1;
	char ch=getchar();
	for(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') w=-1;
	for(;ch<='9'&&ch>='0';ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';
	return x*w;
}
int n,m,tot=1,head[N],s,t;
int dep[N],ans,sum;
struct node{
	int nxt,to,val;
}e[N];
inline void add(int u,int v,int w){
	e[++tot].to=v;
	e[tot].val=w;
	e[tot].nxt=head[u];
	head[u]=tot;
	e[++tot].to=u;
	e[tot].val=0;
	e[tot].nxt=head[v];
	head[v]=tot;
}
inline bool bfs(){
	memset(dep,0,sizeof(dep));
	std::queue<int> Q;
	dep[s]=1;
	Q.push(s);
	while(!Q.empty()){
		int u=Q.front();Q.pop();
		for(register int i=head[u];i;i=e[i].nxt){
			int v=e[i].to;
			if(e[i].val&&!dep[v]){
				dep[v]=dep[u]+1;
				Q.push(v);
			}
		}
	}
	return dep[t];
}
int dfs(int u,int in){
	if(u==t) return in;
	int out=0;
	for(register int i=head[u];i&&in;i=e[i].nxt){
		int v=e[i].to;
		if(e[i].val&&dep[v]==dep[u]+1){
			int res=dfs(v,std::min(e[i].val,in));
			e[i].val-=res;e[i^1].val+=res;
			in-=res;out+=res;
		}
	}
	if(!out) dep[u]=0;
	return out;
}
void dinic(){
	while(bfs()) ans+=dfs(s,inf);
}
inline int p(int x,int y){
	return (x-1)*m+y;
}
signed main(){
	n=read(),m=read();
	s=n*m+1,t=s+1;
	for(register int i=1,x;i<=n;i++){
		for(register int j=1;j<=m;j++){
			x=read();
			int v=p(i,j);
			if(x<0) add(s,v,-x);
			else if(x>0) add(v,t,x);
			sum+=abs(x);
		}
	}
	for(register int i=1,x;i<n;i++){
		for(register int j=1;j<=m;j++){
			x=read();
			int u=p(i,j),v=p(i+1,j);
			add(u,v,x);
			add(v,u,x);
		}
	}
	for(register int i=1,x;i<=n;i++){
		for(register int j=1;j<m;j++){
			x=read();
			int u=p(i,j),v=p(i,j+1);
			add(u,v,x);
			add(v,u,x);
		}
	}
	dinic();
	printf("%d\n",sum-ans);
	return 0;
}
```


---


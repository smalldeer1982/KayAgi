# [JSOI2012] 始祖鸟

## 题目描述

最近，进香河地带出现了一家“始祖鸟专卖店”，然而这并不只是一时的心血来潮。         
                         
早在远古时期，进香河地带就以其秀美的环境和适宜的温度吸引了成群的始祖鸟。始祖鸟是一种团结的鸟类，它们总是通过各种方式来增强种群内部的交流，聚会则是其中之一。因为聚会不但可以增强朋友之间的友谊，而且可以认识新的朋友。        
                             
现在有 $N$ 只始祖鸟，我们从 $1$ 开始编号。对于第 $i$ 只始祖鸟，有 $M_i$ 个认识的朋友，它们的编号分别是 $F_{i,1}，F_{i,2}，…，F_{i,M_i}$。朋友的认识关系是单向的，也就是说如果第$s$只始祖鸟认识第 $t$ 只始祖鸟，那么第 $t$ 只始祖鸟不一定认识第 $s$ 只始祖鸟。        
   
聚会的地点分为两处，一处在上游，一处在下游。对于每一处聚会场所，都必须满足对于在这个聚会场所中的始祖鸟，有恰好有偶数个自己认识的朋友与之在同一个聚会场所中。当然，每一只始祖鸟都必须在两处聚会场所之一。         
       
现在需要你给出一种安排方式。你只需要给出在上游的始祖鸟编号，如果有多组解，请输出任何一组解。 

## 说明/提示

#### 数据规模与约定

- 对于$100\%$的数据，$1 \le N \le 2000$。

## 样例 #1

### 输入

```
5
3 2 3 4
2 1 3
4 2 1 4 5
2 1 3
1 3```

### 输出

```
3
1 2 3```

# 题解

## 作者：lenlen (赞：11)

### 前言

本蒟蒻刚刚学完高斯消元，~~拿这个题试试水~~。

推荐一下个人博客：[高斯消元学习笔记](https://www.luogu.com.cn/blog/HL523260/gao-si-xiao-yuan-xue-xi-bi-ji)。

### Problem

题目大意：每一只始祖鸟要么在上游，要么在下游，而每一只始祖鸟认识一些始祖鸟，要求他在的地方他所认识的始祖鸟的个数为偶数。

数据范围： $n \leq 2000$。

### Solution

我们考虑要满足第 $i$ 只始祖鸟需要满足什么条件，我们可以把每一只始祖鸟分为奇数个朋友和偶数个朋友 2 类，并且定义 $x_i=1$ 表示第 $i$ 只始祖鸟去了上游， $x_i=0$ 表示第 $i$ 只始祖鸟去了下游，并定义 $i$ 的朋友分别为 $a_{i,1},a_{i,2},\cdots,a_{i,k}$。

- 当第 $i$ 只始祖鸟的朋友数为偶数时，显然我们必须保证 $x_{a_{i,1}} \oplus x_{a_{i,2}} \oplus \cdots \oplus x_{a_{i,k}}=1$，这样无论 $i$ 去哪里都能满足条件。

- 当第 $i$ 只始祖鸟的朋友数为偶数时，显然我们必须保证 $x_{a_{i,1}} \oplus x_{a_{i,2}} \oplus \cdots \oplus x_{a_{i,k}}=1$ 且 $x_i=0$ **或者** $x_{a_{i,1}} \oplus x_{a_{i,2}} \oplus \cdots \oplus x_{a_{i,k}}=0$ 且 $x_i=1$，显然可以综合一下即 $x_{a_{i,1}} \oplus x_{a_{i,2}} \oplus \cdots \oplus x_{a_{i,k}} \oplus x_i=1$。

然后就是异或高斯消元的模板题了。

当然本题还有一些注意事项（~~也可能是只有我掉坑里了~~）：

1. 存这 $n$ 个线性异或函数的时候最好用 bitset，我用结构体和数组处理异或的时候超时了（记录：[优化前](https://www.luogu.com.cn/record/92375707) [优化后](https://www.luogu.com.cn/record/92379832)）。

2. 这个题的话因为若有不唯一解也是可以随便输出一个解的，所以当遇到一个主元系数都为 0 时是跳过而非退出，并且假设前面已经处理了 $cnt$ 个主元，而现在正在处理第 $i$ 个主元，那么要从 $cnt+1$ 开始寻找是否有第 $i$ 位为 1 的方程。

对于第二点，在这个题里面，好像不考虑也能过，我提供一组 hack 数据：

```
6
3 4 5 6
2 1 6
0
2 3 6
0
0
```

貌似题解区的几位公布了全部源码的几篇题解都被 hack 了，大家可以自己去推一下，看看自己输出的答案满不满足：
$$\begin{cases}
	& x_1 \oplus x_4 \oplus x_5 \oplus x_6=1\\
    & x_1 \oplus x_6=0\\
    & x_3 \oplus x_6=0
\end{cases}$$

### Code

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2732;
int n,m,x,ans;
bitset<N>a[N];
void gauss()
{
    int cnt=0;
    for(int i=1;i<=n;i++)
    {
        int maax=cnt+1;//就是我所说的第二个点，如果写法不同说不定这个问题就自动考虑进去了
        for(int j=i+1;j<=n;j++) 
        if(a[j][i]>a[maax][i]) maax=j;
        swap(a[cnt+1],a[maax]);
        if(!a[i][i]) continue;
        cnt++;
        for(int j=1;j<=n;j++)
        if(a[j][i]==1&&i!=j)a[j]=a[j]^a[i];
    }
    if(cnt<n)
    {
        for(int i=1;i<=n;i++) 
        if(!a[i][i]&&a[i][n+1]) 
        {
            printf("Impossible\n");
            exit(0);
        }
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&m);
        if(m&1) a[i][n+1]=1,a[i][i]=1;
        while(m--) scanf("%d",&x),a[i][x]=1;
    }
    gauss();
    for(int i=1;i<=n;i++) if(a[i][n+1]) ans++;
    printf("%d\n",ans);
    for(int i=1;i<=n;i++) if(a[i][n+1]) printf("%d ",i);
}
```


---

## 作者：hgzxwzf (赞：3)

## 解题思路：
题意很简单，有 $n$ 只鸟，每只鸟有一些朋友，有一条分为上游和下游的河，每只鸟都会选择上游或下游，要求满足每只鸟都有偶数个朋友和它在同一区域是偶数，求合法方案。

有两种情况，如果一只鸟有偶数个朋友，那么只需要保证有偶数个朋友在上游，就会有偶数个朋友在下游，这只鸟去哪里都可以。

如果这只鸟有奇数个朋友，那么就要保证这只鸟去有偶数个朋友的区域。

用 $x_i=1$ 代表 $i$ 去上游，$x_i=0$ 代表 $i$ 去下游。

对于一只鸟 $i$，他的朋友为 $a_j$，我们可以列出方程：$x_{a_1} \oplus x_{a_2}\ldots \oplus x_{a_m}=0$，这样就可以保证有偶数个朋友在上游。

那么朋友数为偶数的情况就解决了，对于朋友数为奇数的情况，我们要让它去上游，可以将方程改为 $x_{a_1} \oplus x_{a_2}\ldots \oplus x_{a_m}\oplus x_i=1$，因为 $1\oplus0=1$，所以当方程成立就保证了 $x_i=1$，即这只鸟去上游。

**总结一下**：

对于有偶数朋友的鸟：$x_{a_1} \oplus x_{a_2}\ldots \oplus x_{a_m}=0$。

对于有奇数朋友的鸟：$x_{a_1} \oplus x_{a_2}\ldots \oplus x_{a_m}\oplus x_i=1$。

可以用高斯消元解决。

## 代码：
```
#include<cstdio>
#include<algorithm>
#include<bitset>
#define rep(x,y,z) for(int x=y;x<=z;x++)
#define per(x,y,z) for(int x=z;x>=y;x--)
using namespace std;
const int N=2010;
int n;
bitset<N>a[N];
void gauss()
{
	int r=1;
	rep(c,1,n)
	{
		int t=r;
		rep(i,r,n) if(a[i][c]) {t=i;break;}
		if(!a[t][c]) continue;
		swap(a[t],a[r]);
		rep(i,r+1,n)
			if(a[i][c])
				a[i]^=a[r];
		r++;
	}
	if(r<=n)
	{
		rep(i,r,n)
			if(a[i][n+1])
				{puts("Impossible");exit(0);}
	}
	per(i,1,n-1)
		rep(j,i+1,n)
			a[i][n+1]=a[i][n+1]^(a[i][j]&a[j][n+1]);
}
int main()
{
	scanf("%d",&n);
	rep(i,1,n)
	{
		int m;
		scanf("%d",&m);
		if (m&1) a[i][i]=a[i][n+1]=1;
		rep(j,1,m)
		{
			int f;
			scanf("%d",&f);
			a[i][f]=1;
		}
	}
	gauss();
	int ans=0;
	rep(i,1,n)
		if(a[i][n+1])
			ans++;
	printf("%d\n",ans);
	rep(i,1,n)
		if(a[i][n+1])
			printf("%d ",i);
	return 0;
}
```

---

## 作者：quest_2 (赞：2)



推蒟蒻 [$\color{salmon}{blog}$](https://quest233.github.io/) ！

[原题链接~](https://www.luogu.com.cn/problem/P6126)

---

有趣的高斯消元解异或方程组题，难点在建模。

这里默认读者都会高消（（（

题意稍加转化：每只鸟取值 0/1 ，需要有偶数个朋友和他取值相同。

偶数且01，这不由得转化到异或的方向。

这样我们就有了一个森破的想法：（设 $pos[i]$ 为 $i$ 号鸟的取值，上游为 1 ，下游为 0；设 $A[i][j]$ 代表 $j$ 是否（0/1）是 $i$ 的朋友）
$$
(A[i][1]\cdot pos[1])\oplus (A[i][2]\cdot pos[2])\oplus \cdots\oplus (A[i][n]\cdot pos[n])=0
$$
但是很显然这是错的，因为我们其实只是做到了让上游有偶数个朋友，要是这只鸟本身就在下游呢？

我们改一改思路：

- 如果一只鸟有偶数个朋友，则只需满足上游有偶数个，下游必然也会有偶数个。
- 如果一只鸟有奇数个朋友，若当前为上游，则需要偶数个在上游；若当前为下游，则需要奇数个在上游，这样一来下游就有偶数个。

然后把每只鸟对应的方程都列出来，高消解异或方程组即可。

**代码实现：**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
const int MAX = 2e3 + 7;
const int MOD = 1e9 + 7;
void print(bool a)
{
	cout << (a ? "YES" : "NO") << endl;
}
int N;
int n;
struct matrix
{
	bitset<MAX> num[MAX];
	bitset<MAX> &operator[](int id)
	{
		return num[id];
	}
	void SWAP(int x, int y)
	{
		swap(num[x], num[y]);
	}
	void XOR(int x, int y) //xor y to x
	{
		num[x] = num[x] ^ num[y];
	}
} ORZ, RBQ;
void gauss()
{
	for (int i = 1; i <= N; i++)
	{
		int k = i;
		for (int j = i; j <= N; j++)
		{
			if (ORZ[j][i])
			{
				k = j;
				break;
			}
		}
		if (ORZ[k][i] == 0)
		{
			continue;
		}
		ORZ.SWAP(k, i);
		for (int j = 1; j <= N; j++)
		{
			if (ORZ[j][i] && j != i)
			{
				ORZ.XOR(j, i);
			}
		}
	}
}
vector<int> v;
signed main()
{
	cin >> N;
	n = N;
	memset(ORZ.num, 0, sizeof(ORZ.num));
	for (int i = 1; i <= N; i++)
	{
		int tot = 0;
		cin >> tot;
		for (int j = 1; j <= tot; j++)
		{
			int k;
			cin >> k;
			ORZ[i][k] = 1;
		}
		if (tot & 1)
		{
			ORZ[i][i] = 1;
			ORZ[i][N + 1] = 1;
		}
	}
	gauss();
	for (int i = N; i >= 1; i--)
	{
		if (ORZ[i][i])
		{
			if (ORZ[i][N + 1])
				v.push_back(i);
		}
		else if (ORZ[i][N + 1])
		{
			cout << "Impossible\n";
			return 0;
		}
	}
	cout << v.size();
	cout << endl;
	for (int i : v)
	{
		cout << i << ' ';
	}
}
```



---

## 作者：JustPureH2O (赞：1)

[更好的阅读体验](https://justpureh2o.cn/articles/6126)

题目地址：[P6126](https://www.luogu.com.cn/problem/P6126)

> 有 $N$ 只始祖鸟，我们从 $1$ 开始编号。对于第 $i$ 只始祖鸟，有 $M_i$ 个认识的朋友，它们的编号分别是 $F_{i,1},F_{i,2},\dots,F_{i,M_i}$。朋友的认识关系是单向的，也就是说如果第$s$只始祖鸟认识第 $t$ 只始祖鸟，那么第 $t$ 只始祖鸟不一定认识第 $s$ 只始祖鸟。
> 
> 聚会的地点分为两处，一处在上游，一处在下游。对于每一处聚会场所，都必须满足对于在这个聚会场所中的始祖鸟，有恰好有偶数个自己认识的朋友与之在同一个聚会场所中。当然，每一只始祖鸟都必须在两处聚会场所之一。
> 
> 现在需要你给出一种安排方式。你只需要给出在上游的始祖鸟编号，如果有多组解，请输出任何一组解。如果无法满足要求，只输出一行 `Impossible`。
> 
> 对于 ${100\%}$ 的数据，${1 \le N \le 2000}$。

为所有始祖鸟按朋友数的奇偶性分类。对于朋友数是偶数的始祖鸟，只要在上游/下游出现偶数个朋友，那么另一方也肯定存在偶数个朋友，此时当前的始祖鸟就可以在上下游中任意选择去向；如果这只始祖鸟有奇数个朋友，那么上游/下游一定是一边奇数一边偶数，此时这只鸟只能去偶数那侧。

若当前始祖鸟在上游，我们令 $x_i=1$，否则 $x_i=0$。对于朋友数是偶数的始祖鸟，把它的所有朋友代表的数异或起来，那就相当于偶数个 $1$ 与偶数个 $0$ 异或，结果为 $0$；对于朋友数是奇数的始祖鸟，把自己和它的朋友代表的数异或起来，相当于偶数个 $0/1$ 和奇数个 $1/0$ 异或，结果一定是 $1$。因此对于某只有 $k$ 个朋友的始祖鸟 $x_1$，一定有如下关系：

$$
\begin{cases}
x_1\oplus x_2\oplus x_3\oplus\dots\oplus x_k=1&k\bmod2=1
\\x_2\oplus x_3\oplus x_4\oplus\dots\oplus x_k=0&k\bmod2=0
\end{cases}
$$

然后对每只始祖鸟建立关系，再使用异或高斯消元即可。这里介绍一种能方便解决“无数组解特解求解”问题的消元法。

一般的高斯消元会把矩阵消元成一个上/下三角矩阵，矩阵的同一列可能存在多个非零的系数，也就代表着方程之间的未知数还存在相互依赖关系，求解时只能老老实实向上回代，遇到存在自由元的情况时会较难处理。

我们认为这样的矩阵是“未完全化简的”，事实上，如果在减法/异或消元时让每一行都重新消元一次，而不是只对 $r+1\sim n$ 行消元，那么最终你会得到一个同一列只存在一个非零系数的增广矩阵。特别地，对于存在唯一解的情况，它是一个对角矩阵，此时每个未知数的解就是对应常数项的值；如果是存在无数组解的情况，找到主元也非常简单：只需找到每一行的第一个非零系数，然后直接将它赋值为常数项。对于主元右侧的所有非零系数，一律当自由元赋值为 $0$ 即可。

```cpp
#include <bits/stdc++.h>
#define N 2010
using namespace std;

bitset<N> matrix[N];
bitset<N> ans;
int n;

void out() {
    cerr << "-----------------" << endl;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n + 1; j++) {
            cerr << setw(5) << matrix[i][j];
        }
        cerr << endl;
    }
    cerr << "-----------------" << endl;
}

int gauss() {
    int rank = 0; // 矩阵的秩
    for (int c = 1, r = 1; c <= n; c++) {
        int t = r;
        for (int i = r; i <= n; i++) {
            if (matrix[i].test(c)) {
                // 找到绝对值最大的行（只要第一个系数是 1 即可）
                t = i;
                break;
            }
        }
        if (!matrix[t].test(c)) continue; // 跳过零行
        if (t ^ r) swap(matrix[r], matrix[t]); // 交换到第一行

        for (int i = 1; i <= n; i++) {
            // 与普通高斯消元的不同之处，对 1~n 行全部消元
            if (matrix[i].test(c) && i ^ r) {
                // 当前行不消，零行不消
                matrix[i] ^= matrix[r]; // 异或代替减法进行消元
            }
        }
        r++;
        rank++;
    }
    if (rank < n) {
        // 秩小于 n，可能是无数组解、有可能无解
        for (int i = rank + 1; i <= n; i++) {
            if (matrix[i].test(n + 1)) return 0; // 存在类似于 0=k 的矛盾情况，无解
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n + 1; j++) {
                if (matrix[i].test(j)) {
                    // 无数组解，找到主元并赋值
                    ans[j] = matrix[i][n + 1];
                    break;
                }
            }
        }
        return 1;
    }
    for (int i = 1; i <= n; i++) ans[i] = matrix[i][n + 1]; // 有唯一解，对角矩阵每个未知数的解就是常数项的值
    return 2;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    cin >> n;
    for (int i = 1; i <= n; i++) {
        int k;
        cin >> k;
        if (k & 1) matrix[i].flip(i); // 奇数个朋友建立方程组时要算上自己
        matrix[i][n + 1] = k & 1;
        while (k--) {
            int x;
            cin >> x;
            matrix[i].flip(x);
        }
    }
    int res = gauss();
    if (res) {
        cout << ans.count() << endl;
        for (int i = 1; i <= n; i++) {
            if (ans.test(i)) cout << i << ' ';
        }
    } else cout << "Impossible" << endl;
    return 0;
}
```

[Hack 数据](https://www.luogu.com.cn/problem/U382588)也过了，这是[记录](https://www.luogu.com.cn/record/180600794)。你可以调用函数 `out()` 来输出矩阵的项。

$\texttt{The End}$

---

## 作者：wbs200 (赞：1)

大致思考题意，很容易发现此题使用异或方程组解决，本质上就是一个高斯消元的操作。为了优化，我们可以使用 bitset（不熟悉 bitset 的可以去[这里](https://baike.baidu.com/item/BitSet/5816051)）。

$A[i][1] \times x[1]$ $\operatorname{xor}$ $A[i][2] \times x[2]$ $\operatorname{xor}$ $...A[i][n] \times x[n] = 0$，其中 $0$ 表示下游，$1$ 表示上游。

这样可能会出现两个问题：

1. 只能让上游的成立，下游的不清楚。（试想过重新定义 $\operatorname{xor}$，即 $1$，$2$，$0$ 三个，发现不满足结合律，没有办法消元，所以此办法行不通。）
1. 要考虑当前点放在上游或下游（如果下游那么这个方程就无意义）。

稍加思考，我们就可以找到解决办法：在原来的方程上，分类讨论当前点选择上游或下游的成立条件。如果当前出边为偶数，无论上游还是下游，都要有偶数个朋友选择上游。如果当前出边为奇数，若当前为 $1$，要偶数个朋友为 $1$；若当前为 $0$，要奇数个朋友为 $1$。这样将原来的方程稍微修改一下系数即可。
```cpp
#include <iostream>
#include <bitset>
#include <cmath>
using namespace std;

const int maxn = 2e3 + 10;
bitset<maxn> a[maxn];
int ans[maxn], amt = 0, n;

void work()
{
    for (int k = 1; k <= n; k++)
    {
        bool f = false;
        for (int i = k; i <= n; i++)
            if (a[i][k])
            {
                swap(a[i], a[k]);
                f = true;
                break;
            }
        if (!f) continue;

        for (int i = 1; i <= n; i++)
        {
            if (a[i][k] && k != i) a[i] ^= a[k];
        }
    }
    for (int i = n; i > 0; i--)
    {
        if (a[i][i])
        {
            ans[i] = a[i][n + 1];
            amt += ans[i];
        }
        else if (a[i][n + 1])
        {
            cout << "Impossible" << endl;
            exit(0);
        }
    }
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        int m;
        cin >> m;
        if (m & 1) a[i][i] = a[i][n + 1] = 1;
        while (m--)
        {
            int f;
            cin >> f;
            a[i][f] = 1;
        }
    }
    work();
    cout << amt << endl;

    for (int i = 1; i <= n; i++)
    {
        if (ans[i]) cout << i << " ";
    }
    cout << endl;
    return 0;
}
```


---

## 作者：Melo_qwq (赞：0)

挺有意思的题！

发现一只鸟只有在上游或者下游两种状态，考虑分别设成 $1$ 和 $0$。

仅仅说有偶数的朋友在一起是不好做的，把一只鸟的朋友个数按照奇偶分类：

- 如果有奇数个朋友，讨论一下他和其中偶数个在上游还是下游，可以发现，不管是那种情况，他所有朋友的答案**加上他自己的答案**都是奇数。
- 如果有偶数个朋友，那么不难看出他所有朋友的答案加起来是偶数。

现在我们得到了有关奇偶性的一些方程组，显然可以用高斯消元解异或方程组！

无解直接用高斯消元判就可以了，无解的条件是等式左边的系数全为零且右边非零。

高斯消元中会出现全行异或的情况，可以用 ``std :: bitset``。

Code


```cpp
#include <bits/stdc++.h>
#define f(i ,m ,n ,x) for (int i = (m) ; i <= (n) ; i += (x))

template < typename T > inline void read ( T &x ) {
	x = 0 ;
	bool flag (0) ; char ch = getchar () ;
	while (! isdigit (ch)) {
		flag = ch == '-' ;
		ch = getchar () ;
	} while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48) ;
		ch = getchar () ;
	} flag ? x = - x : 0 ;
}

const int N = 2007 ;
int n ,ans[N] ,tot ;
bool use[N] ;
std :: bitset < N > x[N] ;

inline void gauss () {
	f (i ,1 ,n ,1) {
		int cur = 1 ;
		for ( ; cur <= n && (x[cur][i] != 1 || use[cur]) ; cur ++) ;
		if (cur == n + 1) continue ;
		use[i] = true ;
		std :: swap (x[cur] ,x[i]) ; 
		f (j ,1 ,n ,1) 
			if (x[j][i] && j != i) x[j] ^= x[i] ;
	}
}

int main () {
	read (n) ;
	f (i ,1 ,n ,1) {
		int m ; read (m) ;
		if (m & 1) {
			f (j ,1 ,m ,1) {
				int a ; read (a) ;
				x[i][a] = true ;
			} x[i][i] = true ;
			x[i][n + 1] = true ;
		} else {
			f (j ,1 ,m ,1) {
				int a ; read (a) ;
				x[i][a] = true ;
			}
		}
	} gauss () ;
	f (i ,1 ,n ,1) {
		int cur = 1 ;
		for ( ; cur <= n + 1 && x[i][cur] == 0 ; cur ++) ;
		if (cur == n + 1) return puts ("Impossible") ,0 ;
	} f (i ,1 ,n ,1) {
		if (! use[i]) continue ;
		if (x[i][n + 1]) ans[++ tot] = i ;
	} std :: cout << tot << '\n' ;
	f (i ,1 ,tot ,1) std :: cout << ans[i] << ' ' ; puts ("") ;
	return 0 ;
}
```

---

## 作者：Diaоsi (赞：0)

[[JSOI2012] 始祖鸟](https://www.luogu.com.cn/problem/P6126)

思路其他题解已经讲得很清楚了，本篇题解主要补充如何处理无穷多解的情况。

首先我们根据第 $i$ 只始祖鸟的朋友个数 $M_i$ 的奇偶性列出如下方程：

- 当 $M_i$ 为偶数时，$x_{F_{i,1}}\oplus x_{F_{i,2}}\oplus\cdots\oplus x_{F_{i,M_i}}=0$
- 当 $M_i$ 为奇数时，$x_i\oplus x_{F_{i,1}}\oplus x_{F_{i,2}}\oplus\cdots\oplus x_{F_{i,M_i}}=1$

其中 $x_i=0/1$ 表示第 $i$ 只始祖鸟在下 $/$ 上游，由于异或运算可以视作 $\mathbb{Z}_2$ 内的加法，所以这些方程可以视作线性方程组，于是可以用高斯消元求解。

无解的情况很平凡，接下来讲讲怎么构造解。

由于矩阵不一定是满秩的，比如这份[数据](https://www.luogu.com.cn/paste/vz9y5vsi)，消元之后会出现自由元：

$$
\left(   \begin{array}{ccccc|c}   
1 &1 &1 &0 &1  &1 \\   
0 &0 &1 &0 &1  &1 \\   
0 &0 &0 &1 &1  &0 \\    
0 &0 &0 &0 &0  &0 \\ 
0 &0 &0 &0 &0  &0 \\ 
\end{array} \right) \\
$$

处理起来很简单，题目可以输出任意解，所以只需要将自由元钦定为 $0$，然后重新求解线性方程组即可。可以添加方程重新跑高斯消元，也可以直接在当前矩阵上消除，代码中采用的是第二种方法。

在构造解的时候，由于矩阵不一定满秩，所以主元的位置不一定是 $a_{ii}$，需要手动找到第一个不为 $0$ 的位置 $p$ 作为主元。若 $a_{ip}=b_i=1$，则计入答案。

可以用 ```std::bitset``` 优化至 $\mathcal{O}\left(\dfrac{n^3}{w}\right)$。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef long double ld;
using namespace std;
const int N=2010,M=20010,INF=0x3f3f3f3f;
inline int max(int x,int y){return x>y?x:y;}
inline int min(int x,int y){return x<y?x:y;}
inline void swap(int &x,int &y){x^=y^=x^=y;}
int n,m,cnt,ans[N];
bitset<N> a[N];
void xor_gauss(){
	for(int i=1,j=1;i<=n&&j<=n;j++){
		int i1=i;
		while(!a[i1][j]&&i1<=n)i1++;
		if(!a[i1][j])continue;
		std::swap(a[i1],a[i]);
		for(int k=i+1;k<=n;k++)
			if(a[k][j]!=0)a[k]^=a[i];
		i++;
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&m);
		for(int j=1,k;j<=m;j++)
			scanf("%d",&k),a[i][k]=1;
		if(m&1)a[i][n+1]=a[i][i]=1;
	}
	xor_gauss();
	for(int i=n;i>=1;i--){
		int k=0;
		for(int j=1;j<=n;j++)
			if(a[i][j]){k=j;break;}//find pivot
		if(!k&&a[i][n+1]){//no solution
			puts("Impossible");
			return 0;
		}
		else if(!k)continue;
		for(int j=i-1;j>=1;j--)
			if(a[j][k])a[j]^=a[i];
		if(a[i][k]&&a[i][n+1])ans[++cnt]=k;
	}
	printf("%d\n",cnt);
	for(int i=1;i<=cnt;i++)
		printf("%d ",ans[i]);
	return 0;
}
```

---

## 作者：cmk666 (赞：0)

[题目传送门](/problem/P6126) | [双倍经验](/problem/P3429)

题目大意：给出一个有向图，把点分成两部分，使「每个点的出边指向的，且与它同一部分的点」的数量为偶数。给出一种方案。

看到偶数，考虑异或。下文中 $\oplus$ 代表异或运算。

设 $a_{i}$ 表示 $i$ 的出边所指向的点构成的序列，$x_i$ 表示 $i$ 号点在哪个部分（$0$ 或 $1$）。

根据出度 $d_i$ 的奇偶性进行分类讨论：

- 若 $d_i$ 为偶数，那么无论如何，在两个部分的点都应当是偶数，异或和为 $0$，因此有 $x_{a_{i,1}}\oplus x_{a_{i,2}}\oplus\cdots\oplus x_{a_{i,\lvert a\rvert}}=0$；
- 若 $d_i$ 为奇数，我们假设加入一条 $i\to i$ 的自环，则在两个部分的点都应当是奇数，异或和为 $1$，那么有 $x_{a_{i,1}}\oplus x_{a_{i,2}}\oplus\cdots\oplus x_{a_{i,\lvert a\rvert}}\oplus x_i=1$。

这样就可以列出 $n$ 条异或方程。高斯消元即可。

用 bitset 进行优化，时间复杂度 $O\left(\dfrac {n^3}\omega\right)$。核心代码如下：
```cpp
int n, m, x, cnt; bitset < 2009 > a[2009]; bool ans[2009], f;
inline void calc()  // 高斯消元
{
	For(k, 1, n)
	{
		f = false;
		For(i, k, n) if ( a[i][k] ) { swap(a[i], a[k]), f = true; break; }
		if ( f ) For(i, 1, n) if ( a[i][k] && k != i ) a[i] ^= a[k];
	}
	Fol(i, n, 1)
		if ( a[i][i] ) cnt += ans[i] = a[i][n + 1];
		else if ( a[i][n + 1] ) puts("Impossible"), exit(0);
}
int main()
{
	read(n);
	For(i, 1, n)
	{
		read(m); if ( m & 1 ) a[i][i] = a[i][n + 1] = true;
		For(j, 1, m) read(x), a[i][x] = true;
	}
	calc(), printf("%d\n", cnt);
	For(i, 1, n) if ( ans[i] ) printf("%d%c", i, --cnt ? ' ' : '\n');
	return 0;
}
```

---


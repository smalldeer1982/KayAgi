# [JSOI2015] 最小表示

## 题目背景

还记得去年 JYY 所研究的强连通分量的问题吗？去年的题目里，JYY 研究了对于有向图的“加边”问题。对于图论有着强烈兴趣的 JYY，今年又琢磨起了“删边”的问题。

## 题目描述

对于一个 $N$ 个点（每个点从 $1$ 到 $N$ 编号），$M$ 条边的有向图，JYY 发现，如果从图中删去一些边，那么原图的连通性会发生改变；而也有一些边，删去之后图的连通性并不会发生改变。

JYY 想知道，如果想要使得原图任意两点的连通性保持不变，我们最多能删掉多少条边呢？


为了简化一下大家的工作量，这次 JYY 保证他给定的有向图一定是一个有向无环图（JYY：大家经过去年的问题，都知道对于给任意有向图的问题，最后都能转化为有向无环图上的问题，所以今年 JYY 就干脆简化一下大家的工作）。

## 说明/提示

### 样例解释

一种合法方案为删去 $1\rightarrow 5$ 和 $1\rightarrow 3$。容易证明没有比 $2$ 更优的答案。

### 数据范围

对于 $100\%$ 的数据，$1 \leq N\leq 3\times 10^4$，$0 \leq M\leq 10^5$。

## 样例 #1

### 输入

```
5 6
1 2
2 3
3 5
4 5
1 5
1 3```

### 输出

```
2```

# 题解

## 作者：james1BadCreeper (赞：10)

注意到图是一个 DAG，因此对于一条边 $(u,v)$，如果删了这条边依然存在 $u\rightarrow v$ 的间接路径，那么这条边必定被删去。

对于每个点求出它能到达的点和能到达它的点（不含自己）。如果 $u$ 能到达的点和能到 $v$ 的点有交集，那么这条边可以被删去。

前者每个点维护一个 `bitset`，按照拓扑序从大到小转移即可。后者建反图后跟前者一样。时间复杂度 $O\left(\frac{nm}{\omega}\right)$。

```cpp
#include <bits/stdc++.h>
using namespace std; 

int n, m; 
int u[100005], v[100005], in[30005], a[30005]; 
vector<int> G[30005], E[30005]; 
bitset<30005> to[30005], fr[30005]; 

void Kahn(void) {
    queue<int> q; int tot = 0; 
    for (int i = 1; i <= n; ++i) if (!in[i]) q.push(i); 
    while (!q.empty()) {
        int u = q.front(); q.pop(); a[++tot] = u; 
        for (int v : G[u]) if (--in[v] == 0) q.push(v); 
    }
}

int main(void) {
    ios::sync_with_stdio(0); 
    cin >> n >> m; 
    for (int i = 1; i <= m; ++i) {
        cin >> u[i] >> v[i]; 
        G[u[i]].emplace_back(v[i]); E[v[i]].emplace_back(u[i]); 
        ++in[v[i]]; 
    } Kahn(); 
    for (int i = n; i >= 1; --i) {
        int u = a[i]; 
        for (int v : G[u]) to[u][v] = 1, to[u] |= to[v]; 
    }
    for (int i = 1; i <= n; ++i) {
        int u = a[i]; 
        for (int v : E[u]) fr[u][v] = 1, fr[u] |= fr[v]; 
    }
    int ans = 0; 
    for (int i = 1; i <= m; ++i) ans += (to[u[i]] & fr[v[i]]).any(); 
    cout << ans << "\n";
    return 0; 
}
```

---

## 作者：YEMIYZ (赞：7)

对于每一条边 $(u,v)$，如果从 $u$ 到 $v$ 仅存在这条路径，那么这条边一定要保存，否则一定可以删除，因为若存在另一条从 $u$ 到 $v$ 的路线，那么一定存在一个不同于 $u,v$ 的点 $x$ ，可以使 $u$ 到 $x$, $x$ 到 $v$，那么显然边 $(u,v)$ 是可以删除的。

那么接下来就要想办法对每条边判断是否存在点 $x$ ，我们可以对每个点，处理出这个点可以到的点，以及有哪些点可以到这个点，那么就是[可达性统计](https://www.acwing.com/problem/content/166/)了。

接下来就是对 $u$ 和 $v$，看 $u$ 可到达的点和可以到 $v$ 的点是否有相同的就可以了。



```cpp
#include<bits/stdc++.h>
using namespace std;
inline void read(int &x)
{
	x=0;bool t=false;char c=getchar();
	while(c<'0'||c>'9')c=='-'?t=1:0,c=getchar();
	while(c>='0'&&c<='9')x=x*10+(c&15),c=getchar();
	t?x=-x:x;
}
const int N=3e4+10,M=1e5+10;
vector<int>e[N];
vector<int>back[N];
int in[N],u[M],v[M];
bitset<N>to[N],cm[N];//两个点集to和come
int tupo[N],cnt=0,n,m;
void topsort()
{
	queue<int>q;
	for(int i=1;i<=n;++i)
		if(!in[i])
			q.push(i);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		tupo[++cnt]=x;
		for(int y:e[x])
		{
			in[y]--;
			if(!in[y])
				q.push(y);
		}
	}
}
int main()
{
 	read(n);read(m);
 	for(int i=1;i<=m;++i)
 	{
 		read(u[i]);read(v[i]);
 		e[u[i]].push_back(v[i]);
 		back[v[i]].push_back(u[i]);
 		in[v[i]]++;
	}
	topsort();
	for(int i=n;i;--i)
	{
		int x=tupo[i];
		for(int y:e[x])
		{
			to[x][y]=1;
			to[x]|=to[y];
		}
	}
	for(int i=1;i<=n;++i)
	{
		int x=tupo[i];
		for(int y:back[x])
		{
			cm[x][y]=1;
			cm[x]|=cm[y];
		}
	}
	int ans=0;
	for(int i=1;i<=m;++i)	
		if((to[u[i]]&cm[v[i]])!=0)
			ans++;
	printf("%d",ans);
	return 0;
}
```


---

## 作者：laiyouming (赞：6)

这道题和[可达性统计](https://www.acwing.com/problem/content/166/)的方法差不多，如果有一条边 $(u,v)$，$u$ 可到达点的集合与可以到 $v$ 点的集合有相同。那么这条边就可以删掉，所以可以用 bitset 实现，如果不太明白可以看代码里的注释。时间复杂度 $O(\frac{nm}{w})$ **因为既要记录 $u$ 可到达的点，又要记录可到达 $v$ 的点，所以要建反边**。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,b[100001],e[100001],ans;
vector<int>a[100001],d[100001];
bitset<30001>c[30001],f[30001];
void dfs(int i){
	if(b[i]){
		return;
	}
	b[i]=1;
	for(auto j:a[i]){
		dfs(j);
		c[i]|=c[j];
	}
}
void dfs2(int i){
	if(e[i]){
		return;
	}
	e[i]=1;
	for(auto j:d[i]){
		dfs2(j);
		f[i]|=f[j];
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(;m--;){
		int x,y;
		scanf("%d%d",&x,&y);
		a[x].push_back(y);//建正边
		d[y].push_back(x);//建反边
		c[x][y]=f[y][x]=1;
	}
	for(int i=1;i<=n;i++){
			dfs(i);
			dfs2(i);
	}
	for(int i=1;i<=n;i++){
		for(auto j:a[i]){
			bitset<30001>s=(c[i]&f[j]);
			if(s.count()){//如果两个集合有重复
				ans++;//记录答案
			}
		}
	}
	printf("%d",ans);
}
```

---

## 作者：FutaRimeWoawaSete (赞：5)

比较讲究技巧的一道题。           

我们考虑~~手玩样例~~，玩出来发现删的边好像都是拓扑排序后那些不是连向下一个拓扑序的边，感觉得从这方面下手。             

于是我们首先拓扑排序一下，然后遍历每条边看它是不是可以贡献进答案，如果可以贡献进答案就意味着：     

- 令这条边为 $(u , v)$ 。其中 $u$ 的拓扑序小于 $v$ 的拓扑序；       

- $v$ 没有拓扑序比它小的点 $x$ ，保证 $x$ 既指向 $v$ 且 $u$ 又指向 $x$ 。             

于是这两条性质启发我们可以贪心地从拓扑序由大到小遍历所有点，遍历每个点的时候将连向的点拓扑序由小到大排序，然后把每个点可以跑到哪里的信息给存储下来，就可以维护上面的操作了，这里显然 $bitset$ 优化后走人。                  

这里有一个很经典的错法：还是从底向上考虑，每次遍历点的时候只考虑当前连向拓扑序 + 1 的点拿出来算贡献，其余点直接 $bitset$ 合起来就好了。                  

实际上这个会重复计算，毕竟这不是一棵树，画个平行四边形其实就可以叉掉了。         

所以说有时候思路简单点也不是坏事。

```cpp
//rnm，有向无环图DAG
//如果在拓扑图上，x指向的点为z，那么x能到达的点也就为所有z能到达的点加上所有z
//考虑直接在拓扑图上从底向上做DP一样的转移，用bitset优化即可
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#include<queue>
#include<bitset>
using namespace std;
const int Len = 1e5 + 5 , N = 3e4 + 5;
bitset<N> bs[N],to[N]; 
int n,m,IN[N],Num[N],ans;
vector<int> v[N],P[N];
void TOP_Sort()
{
	queue<int> q;
	for(int i = 1 ; i <= n ; i ++) 
	{
		if(!IN[i]) 
		{
			q.push(i) , Num[i] = 1; 
			P[1].push_back(i);
		}
	}
	while(!q.empty())
	{
		int p = q.front();q.pop();
		for(int j = 0 ; j < v[p].size() ; j ++)
		{
			int to = v[p][j];
			IN[to] --;
			if(!IN[to]) 
			{
				q.push(to) , Num[to] = Num[p] + 1;
				P[Num[to]].push_back(to);
			}
		}
	}
}
bool cmp(int x,int y){return Num[x] < Num[y];}
signed main()
{
	scanf("%d %d",&n,&m);
	for(int i = 1 ; i <= m ; i ++)
	{
		int x,y;scanf("%d %d",&x,&y);
		v[x].push_back(y) , IN[y] ++ , to[x].set(y , 1);
	} 
	TOP_Sort();
	for(int i = n ; i >= 1 ; i --)
	{
		for(int j = 0 ; j < P[i].size() ; j ++)
		{
			int now = P[i][j];
			sort(v[now].begin() , v[now].end() , cmp);
			for(int k = 0 ; k < v[now].size() ; k ++) 
			{
				int to = v[now][k];
				if(bs[now].test(v[now][k])) ans ++;
				else bs[now] = bs[now] | bs[v[now][k]];
			}
			bs[now].set(now , 1);
		}
	}
	printf("%d\n",ans);
	return 0;
} 
```

---

## 作者：是个汉子 (赞：5)

[洛谷传送门](https://www.luogu.com.cn/problem/P6134)

### Solution

显然可以看出来的一点是：一条边 $u\rightarrow v$ 如果删除，仍然能从 $u$ 走到 $v$ 

那我们可以贪心的去考虑，对于每一对点对 $u,v$ ，保留其最长的路径，其余的都删了

具体实现可以对原图进行一遍拓扑排序，在过程中记录入队的时间。

对每个点，因为最长路径上一定包含先访问的点，所以把和它直接连接的点按照时间戳排序，维护连通性，统计答案即可。

但是，如果正序去考虑，我们是不知道点之间联通性的，所以倒序处理。

此时时间复杂度是 $O(nm)$ 是通不过本题的，需要用 $bitset$ 维护联通性来优化复杂度。

现在复杂度是 $O(\frac {nm}{32})$ 

小细节：因为无环，所以删一条边和别的边没有关联，也就是相互独立

### Code

```c++
#include<cmath>
#include<queue>
#include<bitset>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>

using namespace std;
const int N=30010;
struct edge{
    int to,nxt;
}e[N*10];
int head[N],cnt,n,m;
int vis[N],in[N],ind[N];
bitset<N>rd[N];//联通性
int topu[N];

inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)){x=x*10+(ch^48);ch=getchar();}
    return x*f;
}

inline void add(int u,int v){
    e[++cnt].to=v;
    e[cnt].nxt=head[u];
    head[u]=cnt;
}

inline bool cmp(const int &a,const int &b){
    return vis[a]<vis[b];
}

inline void topsort(){
    queue<int> q;
    for(int i=1;i<=n;i++)
        if(ind[i]==0) q.push(i);
    int tim=0;
    while(!q.empty()){
        int u=q.front();q.pop();
        in[++tim]=u;
        vis[u]=tim;
        for(int i=head[u];i;i=e[i].nxt){
            int v=e[i].to;
            ind[v]--;
            if(ind[v]==0) q.push(v);
        }
    }
    int ans=0;
    for(int i=n;i>=1;i--){
        int x=in[i],tot=0;
        rd[x][x]=1;
        for(int j=head[x];j;j=e[j].nxt)
            topu[++tot]=e[j].to;
        sort(topu+1,topu+tot+1,cmp);
        for(int j=1;j<=tot;j++){
            if(rd[x][topu[j]]) ans++;
            else rd[x]|=rd[topu[j]];
        }
    }
    printf("%d\n",ans);
}

int main(){
    n=read();m=read();
    for(int i=1;i<=m;i++){
        int u=read(),v=read();
        add(u,v);
        ind[v]++;
    }
    topsort();
    return 0;
}
```



---

## 作者：FBW2010 (赞：3)

[传送门](https://www.luogu.com.cn/problem/P6134)

# 思路

我们单独考虑每一个点：它连向的那些边可以删呢？我们发现，一个 DAG 中要保证连通性不变，设一条边为从 $x$ 到 $y$，那这条边能删掉当且仅当 $x$ 所连向的其他点中有一个能到达 $y$。于是我们可以预处理出这个图的连通性，再挨个点枚举判断即可。

可问题来了，怎么求 DAG 中的连通性呢？我们可以按拓扑序 dp，用一个 `bitset` 来存这个点能到达哪些点，转移时可以用位或实现，复杂度为 $O(\frac {n^2}w)$。数据只有 $3\times 10^4$，可以通过。

实际上实现时可以用记忆化 DFS，不用拓扑。

**警示后人：数据有重边，要特判。**

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e4+5,M=1e5+5;
int n,m,cnt,ans,h[N];
bitset<N> vis[N]; //记录连通性 
struct node{
	int next,to;
}a[M];
void add(int x,int y){
	a[++cnt].next=h[x];
	a[cnt].to=y;
	h[x]=cnt;
}
void DFS(int x){
	vis[x][0]=1;
	for(int i=h[x];i;i=a[i].next){
		if(vis[a[i].to]==0)DFS(a[i].to);
		vis[x][a[i].to]=1;
		vis[x]|=vis[a[i].to]; //转移 
	}
}
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++){
		int x,y;
		scanf("%d %d",&x,&y);
		add(x,y);
	}
	for(int i=1;i<=n;i++){
		if(vis[i]==0)DFS(i);
	}
	for(int i=1;i<=n;i++){
		bitset<N> t; //统计答案 
		for(int j=h[i];j;j=a[j].next){
			t|=vis[a[j].to];
		}
		for(int j=h[i];j;j=a[j].next){
			if(t[a[j].to])ans++;
			t[a[j].to]=1; //判重边 
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：_Kenma_ (赞：2)

# P6134 解题报告

## 前言

非常好题目，使我的大脑旋转。

不支持任何降贴。

## 思路分析

考虑什么样的边是可以被删去的。

直觉上，对于一条边 $x\to y$，如果存在 $x\to z$ 和 $z\to y$ 的两条路径，那么这条边是可删除的。

考虑证明。

~~还是比较感性。~~

因为没有重边，所以对于每一条 $x\to y$ 的路径，贪心地想，我们按这样的顺序选择是最优的：

1. 选择当前 $x\to y$ 的路径的最长的一条；

2. 删去所有被这条路径包含的路径；

对于**包含**，我们是这样定义的：如果路径 $A$ 的节点遍历顺序为 $A_1,A_2,\cdots,A_n$，路径 $B$ 的节点遍历顺序为 $B_1,B_2,\cdots,B_m$，并且 $B$ 是 $A$ 的子序列，则称 $A$ 包含 $B$。

这个选择顺序的正确性很好证明。对于当前最长的路径，没有其他路径可以取代它，所以不得不选，然后删除不必须选的路径，剩下的最长路径又是必须选的了。

发现对于 $B$ 中的每一条边，都满足我们最开始说的的结论。

然后就可以理解为什么结论是对的了。

## 代码实现

实现上，可以建出正图和反图，做两次传递闭包。

总体复杂度为 $O(\frac{nm}{w})$。

```cpp

#include<bits/stdc++.h>
using namespace std;
int n,m,x[100005],y[100005],cnt1[30005],cnt2[30005],ans;
bitset<30005> f[30005],g[30005];
vector<int> v[30005],t[30005];
queue<int> q;
void topo1(){
	for(int i=1;i<=n;i++){
		if(!cnt1[i]) q.push(i);
	}
	while(q.size()){
		int x=q.front();
		q.pop();
		for(int i=0;i<v[x].size();i++){
			int y=v[x][i];
			g[y]|=g[x];
			g[y].set(x);
			cnt1[y]--;
			if(!cnt1[y]) q.push(y);
		} 
	}
}
void topo2(){
	for(int i=1;i<=n;i++){
		if(!cnt2[i]) q.push(i);
	}
	while(q.size()){
		int x=q.front();
		q.pop();
		for(int i=0;i<t[x].size();i++){
			int y=t[x][i];
			f[y]|=f[x];
			f[y].set(x);
			cnt2[y]--;
			if(!cnt2[y]) q.push(y);
		} 
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0); 
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>x[i]>>y[i];
		v[x[i]].push_back(y[i]);
		cnt1[y[i]]++;
		t[y[i]].push_back(x[i]);
		cnt2[x[i]]++;
	}
	topo1();
	topo2();
	for(int i=1;i<=m;i++){
		if((f[x[i]]&g[y[i]]).any()) ans++;
	}
	cout<<ans;
	return 0;
}

```

## 后记

祝点赞的各位 NOIP2024 RP++！

---

## 作者：zhouhuanyi (赞：2)

链接：https://www.luogu.com.cn/problem/P6134

题目描述：给定一个$DAG$，求最多删多条边能使任意两点的连通性不会发生改变。

题解：手玩几组数据可以发现答案就是图中去掉边$(u,v)$后$u,v$仍能连通的边的条数。然后这道题就变成了求对于每一条边，$(u,v)$的路径条数是否大于等于$2$。

我们可以发现，如果将这道题稍微弱化以下，就变成了在$DAG$上给定$q$组点对$(u,v)$，求$u$是否能到达$v$。我们知道这道题就是有向图可达性统计那一套，所以这道题至少要用到$bitset$。

判断大于$2$不怎么好直接做，那我们可以考虑维护两个$bitset$:$A$与$B$，其中$A$维护路径条数大于等于$1$的,$B$维护路径条数大于等于$2$的，更新$B$时与$A$做一下与运算就可以求出$B$了。

```
#include<iostream>
#include<bitset>
#include<queue>
using namespace std;
struct node
{
	int v,nxt;
};
node edge[100001];
int n,m,cnt,len,in[100001],head[100001];
bitset<30001>A[30001];
bitset<30001>B[30001]; 
void add(int x,int y)
{
	edge[++len].v=y;
	edge[len].nxt=head[x];
	head[x]=len;
	return;
}
void top_sort()
{
	queue<int>q;
	for (int i=1;i<=n;++i)
		if (in[i]==0)
			q.push(i);
	int top;
	while (!q.empty())
	{
		top=q.front();
		q.pop();
		for (int i=head[top];i>0;i=edge[i].nxt)
		{
			in[edge[i].v]--;
			B[edge[i].v]|=(A[edge[i].v]&A[top]);
			A[edge[i].v]|=A[top];
			if (in[edge[i].v]==0)
				q.push(edge[i].v);
		}
	}
	return;
}
int main()
{
	int x,y;
	cin>>n>>m;
	for (int i=1;i<=m;++i)
	{
		cin>>x>>y;
		add(x,y);
		in[y]++;
	}
	for (int i=1;i<=n;++i)
		A[i][i]=1;
	top_sort();
	for (int i=1;i<=n;++i)
		for (int j=head[i];j>0;j=edge[j].nxt)
			if (B[edge[j].v][i]==1)
				cnt++;
	cout<<cnt<<endl;
	return 0; 
}

---

## 作者：abs20187 (赞：1)

难度还挺高，主要是看观察。

容易发现，如果有一条边连接 $(u,v)$ 且存在点 $t$ 且 $u$ 能到 $t$，$t$ 能到 $v$。也就是所有 $u$ 能到达的点的集合与所有能到达 $v$ 的点的集合有交集。则这条边可以删除。

难度在如何求联通性。一看数据范围：
  $$1\le N \le 3\times10^4$$
$O(n^2)$ 做法肯定过不了，但题目里说保证图是 DAG（有向无环图）。于是便可以用拓补排序求连通性。

实现也不难，对正反图都求一次连通性。对于任意点 $x$ 在反图中所有能到的点的集合就是在正图中所有能到达 $x$ 的点的集合。

接下来枚举每条边，对于边 $(u,v)$，如果 $u$ 在正图能到达的点的集合与 $v$ 在反图能到达的边的点的集合存在交集就记录答案。（**注意：任意点都不能到达其自身**）

```cpp
#include<bits/stdc++.h>
using namespace std;
bitset<30005>a[30005],b[30005];
vector<int>eg[30005],eg2[30005];//正图、反图
int r[30005];//入度（正图）
vector<pair<int,int> >edge;//记录所有边
int n,m;
int ta[30005],cnt;//拓补序
void topsort()//拓补排序
{
	queue<int>q;
	for(int i=1;i<=n;i++)
	{
		if(r[i]==0)
		{
			q.push(i);
		}
	}
	while(!q.empty())
	{
		int p=q.front();
		ta[++cnt]=p;
		q.pop();
		for(auto i:eg[p])
		{
			r[i]--;
			if(r[i]==0)	q.push(i);
		}
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		cin>>x>>y;
		edge.push_back({x,y});
		eg[x].push_back(y);
		r[y]++;
		eg2[y].push_back(x);
	}
	topsort();
	for(int i=cnt;i>=1;i--)
	{
		for(auto j:eg[ta[i]])
		{
			a[ta[i]][j]=1;
			a[ta[i]]|=a[j];
		}
	}
	for(int i=1;i<=cnt;i++)
	{
		for(auto j:eg2[ta[i]])
		{
			b[ta[i]][j]=1;
			b[ta[i]]|=b[j];
		}
	}
	int ans=0;
	for(int i=0;i<m;i++)
	{
		if((a[edge[i].first]&b[edge[i].second]).count())//存在交集
		{
			ans++;//记录答案
		}
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：Acc_Robin (赞：1)

## 「JSOI2015」最小表示 题解

[传送门](https://www.luogu.com.cn/problem/P6134)

[更高更妙的阅读体验](https://accrobin.github.io/2021/08/12/solver/%E3%80%8CJSOI2015%E3%80%8D%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E9%A2%98%E8%A7%A3/)

### 题意

对于一个 $N$ 个点（每个点从 $1$ 到 $N$ 编号），$M$ 条边的有向无环图而也有一些边，最多能删掉多少条边之后图上任意两点间的连通性并会发生改变。

$N\le 3\times 10^4,M\le 10^5$

### 题解

我们需要给出一个更易于实现的方案来判断一条边是否可以删去：

对于一条从 $x$​​​ 到 $y$​​​ 的边 $(x,y)$​​​，这条边可以被删去当且仅当存在另一个点 $z$​​​ 使得有一条 $x$​​​ 到 $z$​​​ 的路径和一条 $z$​​​ 到 $y$​​​ 的路径。换句话说，就是存在一条从 $x$ 到 $y$ 长度大于 $1$ 的路径。

~~感性理解~~就是保留 $x\to y$  的最长的那条路径，其余都删掉（由贪心可证）。

现在要做的就是在访问 $x$ 时看是否有另一个后继 $z$ 能够到达 $y$，如果存在这么一个 $z$ ，说明 $(x,y)$ 这条边就可以删掉了。

对每个点维护一个 `bitset`，记作 $h_x$ 表示点 $x$ 能够到达的点的集合，每个节点可达集合是各个后继集合的并再并上自己，那么使用 $h$ 可以很轻松地完成此题。

但是注意有一个很重要的细节：需要给遍历后继一个顺序，来消除先后遍历顺序对可达关系造成的影响。

我们发现，遍历顺序能够造成影响当且仅当 $x$ 的一对后继 $y,z$ 存在 $z$ 到 $y$ 的路径，但是我们先遍历了$y$ ，因而无法发现可以删去 $(x,y)$，由此我们需要引入 $d_i$ 表示 $i$ 向后走最多能走多远（也就是到终点（出度为 $0$​ 的点）的最长路）。

实现上，只需要逆拓扑序求出 $d_i$​ ，对每一个点 $x$​ 按照 $d_i$​ 降序访问各个后继，同时给点 $x$​ 的 `bitset` 按位或上各个后继的 `bitset` 。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace Acc{
	const int N=3e4+9,M=1e5+9;
	int d[N],r;
	basic_string<int>G[N],v;
	queue<int>q;
	pair<int,int>e[M];
	bitset<N>h[N];
	void work(){
		int n,m,i,x,y;
		for(cin>>n>>m,i=1;i<=m;++i)cin>>x>>y,e[i]={x,y},G[x]+=y,++d[y];
		for(i=1;i<=n;++i)if(!d[i])q.push(i);
		while(q.size()){
			v+=(x=q.front()),q.pop();
			for(int y:G[x])if(!--d[y])q.push(y);
		}
		for(i=v.size()-1;~i;--i){
			x=v[i],h[x].set(x);
			sort(G[x].begin(),G[x].end(),[](int x,int y){return d[x]>d[y];});
			for(int y:G[x]){
				if(h[x].test(y))++r;
				d[x]=max(d[x],d[y]+1),h[x]|=h[y];
			}
		}
		cout<<r<<'\n';
	}
}
int main(){return Acc::work(),0;}
```



---

## 作者：NuoCarter (赞：1)

[P6134 [JSOI2015]最小表示](https://www.luogu.com.cn/problem/P6134)

首先有向无环图，考虑拓扑排序，接下来按照 $BFS$ 来理解整个拓扑排序。

相当于把所有的点分成了若干层，（每一层中的点互不联通）。

那么保留最少的边一定是将每一层形成一个类似链的关系，也就是应该优先保留  $u$  能够到达的更浅的层的边。

于是对于当前的点 $u$ ，每一条边按照出点 $v$ 的时间戳排序。

因为是最优策略，所以按照上面的次序访问边 $u->v$ 如果说 $u,v$ 已经联通，这个边可以删去，连通性和最优性都可以保证，用一个 `bitset` 维护连通性就好了。


`Code:`
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=3e4+2,M=1e5+3;
template <typename T>
inline void read(T &x){
	x=0;char ch=getchar();bool f=false;
	while(!isdigit(ch))	f|=ch=='-',ch=getchar();
	while(isdigit(ch))	x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	x=f?-x:x;
}
template <typename T>
inline void print(T x){
	if(x<0)	putchar('-'),x=-x;
	if(x>9)	print(x/10);
	putchar(x%10^48);
}
bitset<N> bis[N];
int n,m;
int head[N],Next[M],to[M],dfn[N],tot,in[N],tim,rev[N];

int ju[N];

inline void Addedge(int u,int v){to[++tot]=v,Next[tot]=head[u],head[u]=tot;return;}

inline bool Cmp(int x,int y){return dfn[x]<dfn[y];}

inline void Topo(){
	queue<int> q;
	for(register int i=1;i<=n;++i)	if(!in[i])		q.push(i);		
	while(!q.empty()){
		int x=q.front();q.pop();
		dfn[x]=++tim;rev[tim]=x;
		for(register int i=head[x];i;i=Next[i]){
			int y=to[i];
			if(!(--in[y])) q.push(y);
		}
	}
	int ans=0;
	for(register int i=n;i;--i){
		int x=rev[i];
		bis[x][x]=1;
		int siz=0;
		for(register int j=head[x];j;j=Next[j])
			ju[++siz]=to[j];
		sort(ju+1,ju+siz+1,Cmp);
		for(register int j=1;j<=siz;++j){
			if(bis[x][ju[j]])	ans++;
			else bis[x]|=bis[ju[j]];
		}
	}
	print(ans);
	return ;
}

int main(){
	read(n),read(m);
	for(register int i=1;i<=m;++i){
		int u,v;read(u),read(v);
		Addedge(u,v);in[v]++;
	}
	Topo();
	return 0;
}	
```

---

## 作者：封禁用户 (赞：0)

## **思路**
注意到是有向无环图，先进行拓扑排序，得到节点的线性序列。     
然后利用拓扑序计算每个节点的可达节点集合。  
反向利用拓扑序计算每个节点的前驱节点集合。  
因此对于一条边，判断可达节点集合与前驱节点集合的交集是否非空，若是则计数。   



```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX_NODE = 30005;
const int MAX_EDGE = 100005;
int n, m;
int f[MAX_EDGE], t[MAX_EDGE];
int in[MAX_NODE];
int ord[MAX_NODE];
vector<int> g[MAX_NODE];
vector<int> rg[MAX_NODE];
bitset<MAX_NODE> to[MAX_NODE];
bitset<MAX_NODE> fr[MAX_NODE];

// 拓扑排序函数
void topoSort() {
    queue<int> q;
    int cnt = 0;
    
    for (int i = 1; i <= n; ++i) {
        if (!in[i]) {
            q.push(i);
        }
    }
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        ord[++cnt] = u;
        
        for (int v : g[u]) {
            if (--in[v] == 0) {
                q.push(v);
            }
        }
    }
}

// 计算每个节点的可达节点集合
void calcReachable() {
    for (int i = n; i >= 1; --i) {
        int u = ord[i];
        for (int v : g[u]) {
            to[u][v] = 1;
            to[u] |= to[v];
        }
    }
}

// 计算每个节点的前驱节点集合
void calcAncestors() {
    for (int i = 1; i <= n; ++i) {
        int u = ord[i];
        for (int v : rg[u]) {
            fr[u][v] = 1;
            fr[u] |= fr[v];
        }
    }
}

// 统计满足条件的边数量
int countValidEdges() {
    int res = 0;
    for (int i = 1; i <= m; ++i) {
        res += (to[f[i]] & fr[t[i]]).any();
    }
    return res;
}

int main() {
    ios::sync_with_stdio(0);
    cin >> n >> m;
    
    for (int i = 1; i <= m; ++i) {
        cin >> f[i] >> t[i];
        g[f[i]].emplace_back(t[i]);
        rg[t[i]].emplace_back(f[i]);
        ++in[t[i]];
    }
    
    topoSort();
    
    // 计算可达节点和前驱节点
    calcReachable();
    calcAncestors();
    cout << countValidEdges() << "\n";
    
    return 0;
}
    
```

---

## 作者：Shellchen (赞：0)

首先容易看出一个结论：对于每条边，如果存在间接路径连接两个端点，那么这条边就要被删掉。

我们会发现，$n$ 相对较小，只有 $3 \times 10^4$。于是我们可以开两个个由大小 $n$ 的 bitset 构成的数组，其中 $to_{u,v}=1$ 表示从 $u$ 可以到 $v$，$fr_{u,v}=1$ 表示从 $v$ 可以到 $u$，如果是 $0$ 即无法到达。我们会发现，如果对于一条边 $u \rightarrow v$，可以找到一个结点 $t$，使得 $to_{u,t}=fr_{v,t}=1$，那么就意味着 $u$ 到 $v$ 存在间接路径 $u \rightarrow t \rightarrow v$，那么 $u \rightarrow v$ 这条边就可以被删掉。这个问题可以用 bitset 的按位与运算解决。于是考虑如何预处理 $to$ 和 $fr$。

容易发现，这个图是一个 DAG，可以拓扑排序求出访问顺序，再用 bitset 的或来更新。但是 $fr$ 的顺序是反的，于是可以建一个反图来维护。

然后，就没有然后了。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
//#pragma GCC optimize(3,"Ofast","inline")
const int N=3e4+10,mod=1e9+7;
int n,m;   
int u[100010],v[100010],ind[N],a[N]; 
vector<int>adj[N],adj2[N]; 
bitset<N>to[N],fr[N];
void topo()
{
	queue<int>q;
	int cur=0; 
	for(int i=1;i<=n;i++) if (!ind[i]) q.push(i);
	while(q.size())
	{
		int p=q.front();q.pop();
		a[++cur]=p; 
		for(auto v:adj[p])
		{
			ind[v]--;
			if(!ind[v]) q.push(v);
		}
	}
}
signed main()
{
	cin>>n>>m; 
	for(int i=1;i<=m;i++)
	{
		cin>>u[i]>>v[i]; 
		adj[u[i]].push_back(v[i]);
		adj2[v[i]].push_back(u[i]); 
		ind[v[i]]++; 
	}
	topo(); 
	for(int i=n;i>=1;i--)
	{
		int u=a[i];
		for(auto v:adj[u]) to[u][v]=1,to[u]|=to[v]; 
	}
	for(int i=1;i<=n;i++)
	{
		int u=a[i];
		for(auto v:adj2[u]) fr[u][v]=1,fr[u]|=fr[v]; 
	}
	int ans=0; 
	for(int i=1;i<=m;i++) ans+=(to[u[i]]&fr[v[i]]).any();
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：cjh20090318 (赞：0)

## 题意

$N$ 个点 $M$ 条边的有向图，请问最多能够删去多少条边，使得任意两点连通性不变。

## 分析

前置知识：[AcWing164. 可达性统计](https://www.acwing.com/problem/content/166/)。

考虑 $(u,v)$ 这条边在什么情况下会被删除：当存在一个异于 $u,v$ 的点 $x$，同时拥有 $(u,x)$ 和 $(x,v)$ 的路径。那么这条边就不再需要了，可以删去。

现在的问题就在于判断这个条件。先建出反图，结合 `std::bitset` 求出每个点能够到达的点集和能到达这个点的点集。

设 $S_u$ 表示点 $u$ 能够到达的所有点，$T_u$ 表示能够到达点 $u$ 的所有点。

对于边 $(u,v)$，$S_u \cap T_v \neq \{u,v\}$，说明就存在一个点 $x$ 符合上述条件。

对原图进行拓扑排序，正序通过反图求出 $T$，逆序通过原图求出 $S$，最后逆序统计每一条边 $(u,v)$ 即可。

时间复杂度 $O\left(\dfrac{nm}{w}\right)$，空间复杂度 $O\left(\dfrac{n^2}{w}\right)$，其中 $w$ 表示 `std::bitset` 的常数，可以通过此题。

## 代码

```cpp
//the code is from chenjh
#include<cstdio>
#include<bitset>
#include<queue>
#define MAXN 30003
using namespace std;
int n,m,t=0,in[MAXN],a[MAXN];//入度，拓扑序。
vector<int> G[MAXN],E[MAXN];//原图，反图。
bitset<MAXN> S[MAXN],T[MAXN];//见分析定义。
void topo(){//拓扑排序。
	queue<int> Q;
	for(int i=1;i<=n;i++)if(!in[i]) Q.push(i);
	for(int u;!Q.empty();){
		u=Q.front(),Q.pop();
		a[++t]=u;
		for(const int v:G[u])if(!--in[v]) Q.push(v);
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,u,v;i<=m;i++) scanf("%d%d",&u,&v),G[u].push_back(v),E[v].push_back(u),++in[v];
	topo();
	for(int i=1,u;i<=n;i++){
		u=a[i],T[u][u]=1;
		for(const int v:E[u]) T[u]|=T[v];
	}
	int ans=0;
	for(int i=n,u;i>0;--i){
		u=a[i],S[u][u]=1;
		for(const int v:G[u]) S[u]|=S[v];
		for(const int v:G[u]) ans+=(S[u]&T[v]).count()>2;//不止含有 u,v 两个点，即可删掉这条边。
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：luckydrawbox (赞：0)

[$\text{Link}$](https://www.luogu.com.cn/problem/P6134)

## 题意

给定一个有向无环图，节点编号为 $1\sim N$，有 $M$ 条边，你可以删除其中的某些边，使其中**任意两点的连通性**保持不变（若原图中点 $i$ 到 $j$ 有一条路径，那么新图中 $i$ 到 $j$ 也有一条路径，反之亦然），求最多能删除几条边？

## 分析

先分析一下样例：

![](https://cdn.luogu.com.cn/upload/image_hosting/pfiver53.png)

由样例解释得，边 $1\Rightarrow 3$ 和 $1\Rightarrow 5$ 是可以删去的，因为 $1\Rightarrow 3$ 可以用 $1\Rightarrow 2\Rightarrow 3$ 代替；$1\Rightarrow 5$ 可以用 $1\Rightarrow 3\Rightarrow 5$ 代替，进而可以代替为 $1\Rightarrow 2\Rightarrow 3\Rightarrow 5$。

所以，一条边 $i\Rightarrow j$ 可以被删去，仅当存在另一条路径可以替代它，题目中又保证任意两点之间至多只有一条边，所以另一条路径的长度必然大于等于 $2$，即存在一条路径 $i\Rightarrow …\Rightarrow j$，于是问题转化为求 $\sum_{i=1}^n\sum_{j=1}^n[i\Rightarrow j]\land[i\Rightarrow …\Rightarrow j]$。

设边集为 $E$，式子可进一步转化为 $\sum_{e\in E}[e.u\Rightarrow …\Rightarrow e.v]$。

设 $w_{i,j}$ 表示存在一条边 $j\Rightarrow i$，$d_{i,j}$ 表示存在一条路径 $j\Rightarrow …\Rightarrow i$，即这条路径的边数大于等于 $2$，则答案为 $\sum_{e\in E}d_{e.v,e.u}$。

我们对图进行拓补排序，遍历每条边 $x\Rightarrow y$，我们要用 $d_{x,k}$ 和 $w_{x,k}$ 更新 $d_{y,k}$，若 $k$ 到 $x$ 存在边数大于等于 $1$ 的路径，那么经过 $x\Rightarrow y$ 后，就存在边数大于等于 $2$ 的路径了，即 $d_{y,k}=d_{y,k}\lor d_{x,k}\lor w_{x,k}$。

这样做的时间复杂度是 $O(nm)$，$nm$ 最大可能为 $3\times 10^4\times 10^5=3\times10^9$，不能通过此题，不过 $d_{y,k}=d_{y,k}\lor d_{x,k}\lor w_{x,k}$ 部分可以使用 $\text{bitset}$ 优化，复杂度为 $O(\frac{nm}{32})$，可以通过此题。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
long long read(){
	long long x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void write(long long x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int N=3e4+10;
int n,m,in[N],ans;
vector<int>e[N];
bitset<N>d[N],w[N];
void topu(){
	queue<int>q;
	for(int i=1;i<=n;i++)
		if(!in[i])
			q.push(i);
	while(q.size()){
		int x=q.front();q.pop();
		for(int i=0,y;i<e[x].size();i++){
			in[y=e[x][i]]--;
			d[y]|=d[x]|w[x];
			if(!in[y])
				q.push(y);
		}
	}
}
int main(){
	n=read();m=read();
	for(int i=1,x,y;i<=m;i++){
		x=read();y=read();
		e[x].push_back(y);
		in[y]++;
		w[y][x]=1;
	}
	topu();
	for(int i=1;i<=n;i++)
		for(int j=0;j<e[i].size();j++)
			ans+=d[e[i][j]][i];
	write(ans);
	return 0;
}
```


---

## 作者：Skies (赞：0)

~~第一篇紫题题解，管理员求过审~~

# solution

这个题是贪心+bitset来做，还是挺简单的

### bitset的用法
1.定义bitset:（N为元素个数）
$$ bitset<N>name $$

2.使用
  
  和平常的bool 一样，name[i]可取出和赋值
  
3.优点
  
是bool 空间，时间32分之一

这里用来储存
  #### 每个点能到达的点的编号
  
  e.g.  a[i][j]==1则i可以走到j
  
### 贪心
首先考虑拓扑排序，然后倒序遍历，因为后面的点是走不到前面的点的，所以消除了后效性
  
  然后扫描每个点的出边，这里就需要贪心先遍历哪一个出边了
  
  **请读者自行思考一分钟，以什么样的顺序遍历最佳**
  
————————————————————————————————————分割线
  ### 拓扑序小的先遍历！
  
  因为拓扑序小的点有可能可以走到拓扑序大的点，
  
  拓扑序大的点不可能走到拓扑序小的点
  
  
  所以拓扑序小的先遍历！
  # code
 ```cpp
#include<bits/stdc++.h>
#include<bitset>
using namespace std;
const int N=31000,M=1e5+10;
bitset<N>a[N];
int in[N];
struct node{
	int to,fr,nex;
}ed[M<<1];
int head[N],idx;
void add(int x,int y)
{
	ed[++idx].to=y,ed[idx].fr=x,ed[idx].nex=head[x],head[x]=idx,in[y]++;
}
int n,m;
int st[M],id,xu[N];
void topu()
{
	queue<int>q;
	for(int i=1;i<=n;i++)
	{
		if(!in[i])q.push(i);
	}
	while(!q.empty())
	{
		int x=q.front();q.pop();st[++id]=x;
		xu[x]=id;
		for(int i=head[x];i;i=ed[i].nex)
		{
			int y=ed[i].to;
			in[y]--;
			if(!in[y])
			q.push(y);
		}
	}
}
bool vis[N];
int ans=0;
bool cmp(int x,int y)
{
	return xu[x]<xu[y];
}
void dfs(int x)
{
	a[x][x]=1;
	int p[N],idx=0;
	for(int i=head[x];i;i=ed[i].nex)
	{
		int y=ed[i].to;
		p[++idx]=y;
	}
	sort(p+1,p+idx+1,cmp);//按拓扑序排序 
	for(int i=1;i<=idx;i++)
	{
		int y=p[i];//取出元素 
		if(a[x][y]) 
		{
			ans++;
		}else{;
			a[x][y]=1,a[x]|=a[y];
		}
		
	}
}
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	topu();
	for(int i=n;i>=1;i--)
	{
		dfs(st[i]);//按拓扑序倒着枚举 
	}
	cout<<ans;
	return 0;
}  
```


---

## 作者：wsk_1202 (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P6134)

题意：给定一个 $DAG$，删去最多的边，使得原图任意两点的连通性保持不变。

对于一个 $DAG$ 的一条边 $(u,v)$，若删去它可以保持连通性不变，意味着存在另一条路径可以从 $u$ 到 $v$。

我们对原图作拓扑排序，逆序处理，对于每一个点，把它们的子节点按到出度为 $0$ 的点的最长路排序处理，这样可以保证能删去的边最多。

具体的做法是拓扑排序后按照入队的逆序考虑每个点，把它直接相连的点弄出来按照时间戳排个序，然后就可以直接维护连通性、统计答案了。连通性可以用 $bitset$ 搞，$3\times 10^4$ 的数据是绝对跑得过的。

代码如下：

```cpp
#include <cstdio>
#include <algorithm>
#include <queue> 
#include <bitset>
typedef long long ll;
inline int rd(){
	int x=0,p=1;
	char a=getchar();
	while((a<48||a>57)&&a!='-')a=getchar();
	if(a=='-')p=-p,a=getchar();
	while(a>47&&a<58)x=(x<<1)+(x<<3)+(a&15),a=getchar();
	return x*p;
}
const int N=30002,S=100002;
struct Edge{
	int to,next;
}edge[S];
int head[N],cnt;
int n,m,in[N],ans;
int x[N],ti,vis[N];
int st[N],top;
std::bitset<N>b[N];
std::queue<int> q;
bool comp(const int &x,const int &y){
	return vis[x]<vis[y];
}
inline void add(int f,int t){
	edge[++cnt].next=head[f];
	edge[cnt].to=t;
	head[f]=cnt;
}
int main(){
	n=rd(),m=rd();
	for(int i=1;i<=m;i++){
		int u=rd(),v=rd();
		add(u,v),in[v]++;
	}
	for(int i=1;i<=n;i++)
		if(!in[i])q.push(i);
	while(!q.empty()){
		int u=q.front();q.pop();
		x[++ti]=u,vis[u]=ti;
		for(int i=head[u];i;i=edge[i].next){
			int v=edge[i].to;
			in[v]--;
			if(!in[v])q.push(v);
		}
	}
	for(int i=n;i;i--){
		int u=x[i];
		b[u][u]=1,top=0;
		for(int i=head[u];i;i=edge[i].next)
			st[++top]=edge[i].to;
		std::sort(st+1,st+top+1,comp);
		for(int i=1;i<=top;i++){
			if(b[u][st[i]])ans++;
			else b[u]|=b[st[i]];
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---


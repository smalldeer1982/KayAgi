# [JSOI2013] 公交系统

## 题目背景

几年前南京因为修地铁的缘故，很多公交车线路都被迫改变了。

JYY 为此很苦恼：试想一下，当你坐上一辆公交车，却发现这辆公交车驶向了与你记忆完全不同的方向。

于是 JYY 打算开发一套可以利用手机进行实时更新的公交信息应用， 所有安装了这款应用的手机都可以向数据库发送最新的公交线路更改情况，同时也可以通过应用向数据库查询自己所需要的信息。

## 题目描述

南京一共有 $n$ 个公交站点，分别从 $1$ 到 $n$ 编号。两个不同的站点 $x$ 和 $y$ 之间可能会有公交车直接运营（不经过别的站点直接从 $x$ 开到 $y$） ，我们将这种关系看作一条无向边（公交线路显然是双向的，我们既可以从 $x$ 坐公交车到 $y$，也可以从 $y$ 坐车到 $x$）。

任意时刻任何公交站点都至多只会连有 $2$ 条边，并且所有这些边是不会形成
环的（公交车很少会出现环线，所以这些公交线路应该形成一些不相交的链，链
的两端分别对应两个终点站）。

JYY 的 IOS 应用按照时间顺序一共收到了 $q$ 条交互信息，每一条交互信息
都是下列五种信息之一：

- `add x y z`，表示当前时刻，站点 $x$ 到站点 $y$ 之间有新增了一班公交车直接运营，并且在当前路况下，公交车所需要的运营时间为 $z$。
- `del x y`，表示由于某种原因，原本在站点 $x$ 和站点 $y$ 之间直接运营的公交车停运了。
- `change x y z`，表示由于路况情况改变，站点 $x$ 到站点 $y$ 之间直接运营的公交车当前的运营时间为 $z$。
- `reach x y`，表示某个用户询问从站点 $x$ 坐车能不能坐到站点 $y$。
- `dest x y`，表示某个用户从站点 $x$ 上车，坐上了当前正开往站点 $y$ 的公交车。该用户想知道，他到达 $y$ 后继续乘坐可乘坐的线路(已经乘坐过的线路不能重复乘坐)，最终能够到达的终点站是哪一站？从站点 $x$ 开始需要多久才能
开到终点站？

**在收到第一条信息之前，没有任何公交车在运营**。

由于用户难免会提交错误的信息，所以 JYY 希望他的软件对于错误的信息也
要能够做出合理的反应：

- 对于 `add` 信息，如果加入边 $(x,y)$ 之后，任何站点连接的边数均不超过 $2$ 并且图中没有环，JYY 则认为这个信息是正确的，并根据这个信息更新
数据库中的公交线路数据，否则JYY会无视这个错误信息。
- 对于 `del` 和 `change` 信息，如果站点 $x$ 和站点 $y$ 之间有公交车直接运营， JYY 则认为这条信息是正确的，并更新数据库，否则 JYY 则会无视这个错误
信息。
- 对于 `dest` 信息，如果站点 $x$ 不能到达站点 $y$，JYY 也会认为这一条询问信
息是错误的。

JYY 希望你能够帮助他完成这一个公交信息应用。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $2 \leq n \leq 10^5$，$2 \leq q \leq2×10^5$。
- $1 \leq x, y \leq n$，$x \neq y$，$1\leq z \leq10^4$。

---

#### 提示

请注意数据读入对程序效率造成的影响。

## 样例 #1

### 输入

```
6 10
add 1 2 1
add 2 1 1
add 3 2 1
add 4 5 2
reach 4 6
dest 1 5
del 5 6
add 1 4 2
dest 2 3
dest 3 2```

### 输出

```
OK
ERROR
OK
OK
NO
ERROR
ERROR
OK
3 1
5 6```

# 题解

## 作者：Jr_Zlw (赞：5)

# 平衡树板子

题目要求维护很多条链，不难想到用平衡树，个人用的是 fhq treap 。

将边化成点，每一棵 treap 都以点边点的顺序存了一条链，代表边的点权值为边权，代表点的点权值为  $0$  。

## 操作一

加边操作，合法的条件是：

- 不在同一棵子树。

- 两个点都在链头或链尾，即中序遍历最大或最小。

如果  $x,y$  同时在链头或同时在链尾还要翻转一下 treap 。

然后把  $x$  放最后，  $y$  放最前，两棵树之间插入边权为  $z$  的一个代表边的点，合起来就行。

## 操作二

删边操作，合法的条件是：

- 在同一棵子树

- 两个点之间只隔了一个代表边的点。

满足条件就直接把那个代表边的点拆掉就行。

## 操作三

本质上与上面两个一样，读者自行理解。

## 操作四

判断一下根是否相等就好。

## 操作五

首先还是判断  $x,y$  是否同根，不同根直接返回。

然后比较一下  $x,y$  在 treap 中排名的大小，不妨设为  $rx,ry$  。

- 如果  $rx<ry$  ，要往右边走，于是终点就是最右端的点，时间为  $x$  节点后的边权和。


- 如果  $rx>ry$  ，要往左边走，于是终点就是最左端的点，时间为  $x$  节点前的边权和。

## 实现细节

有几个坑点提一下：

- 查询根和排名需要维护节点父亲，然后从当前节点往上跳统计答案。

- 查询排名时一定要释放从根到它的所有翻转标记。

## 代码

```
#include<cstdio>
#include<cstdlib>
#define rep(a,b,c) for(int c=(a);c<=(b);++c)
#define drep(a,b,c) for(int c=(a);c>=(b);--c)
inline int read()
{
	int res=0;char ch=getchar();while(ch<'0'||ch>'9')ch=getchar();
	while(ch<='9'&&ch>='0')res=res*10+(ch^48),ch=getchar();return res;
}
inline int Get()
{
	char ch;do ch=getchar();while(ch<'a'||ch>'z');switch(ch)
	{
		case 'a': return 1;case 'c': return 3;case 'r': return 4;
		case 'd': getchar();return getchar()=='l'?2:5;
	}return 0;
}
inline void print(const int &p){if(p>9)print(p/10);putchar(p%10+'0');}
inline void pt(const int &p,const char &ch='\n'){print(p<0?putchar('-'),-p:p);putchar(ch);}
template<typename T> inline void Swap(T&x,T&y){T tmp=x;x=y;y=tmp;}
const int N=1e5+10;int T1,T2,T3,n,cgt;
struct FHQ{int l,r,siz,vl,sm,fa;bool tg;short key;inline FHQ(){key=rand();siz=1;}}t[N<<2];
inline void Rev(int x){Swap(t[x].l,t[x].r);t[x].tg^=1;}
inline void pushdown(int x){if(t[x].tg)Rev(t[x].l),Rev(t[x].r),t[x].tg=false;}
inline void update(int x)
{
	t[x].siz=t[t[x].l].siz+t[t[x].r].siz+1;
	t[x].sm=t[t[x].l].sm+t[t[x].r].sm+t[x].vl;
	t[t[x].l].fa=t[t[x].r].fa=x;t[x].fa=0;
}
inline void split(int cur,int k,int &x,int &y)
{
	if(!cur){x=y=0;return;}pushdown(cur);
	if(t[t[cur].l].siz>=k){y=cur;split(t[cur].l,k,x,t[cur].l);update(y);return;}
	x=cur;split(t[cur].r,k-t[t[cur].l].siz-1,t[cur].r,y),update(x);
}
inline int merge(int x,int y)
{
	if(!x||!y)return x|y;pushdown(x);pushdown(y);
	if(t[x].key<t[y].key){t[x].r=merge(t[x].r,y);update(x);return x;}
	t[y].l=merge(x,t[y].l);update(y);return y;
}
inline int fnd(int x){while(t[x].fa)x=t[x].fa;return x;}
inline void pushall(int x){if(t[x].fa)pushall(t[x].fa);pushdown(x);}
inline int rnk(int k){pushall(k);int r=t[t[k].l].siz;while(t[k].fa){r+=(k==t[t[k].fa].r)?t[t[t[k].fa].l].siz+1:0;k=t[k].fa;}return r+1;}
inline void add(int x,int y,int z)
{
	int fx=fnd(x),fy=fnd(y);
	if(fx==fy)return puts("ERROR"),void();
	int rx=rnk(x),ry=rnk(y);
	if((rx==1||rx==t[fx].siz)&&(ry==1||ry==t[fy].siz))
	{
		if(rx==1)Swap(x,y),Swap(fx,fy),Swap(rx,ry);
		if(rx==1)Rev(fx);if(ry==t[fy].siz)Rev(fy);
		t[++cgt].siz=1;t[cgt].vl=t[cgt].sm=z;merge(merge(fx,cgt),fy);puts("OK");
	}
	else puts("ERROR");
}
inline void del(int x,int y)
{
	int fx=fnd(x),fy=fnd(y);if(fx!=fy)return puts("ERROR"),void();
	int rx=rnk(x),ry=rnk(y);if(rx>ry)Swap(rx,ry),Swap(fx,fy),Swap(x,y);
	if(ry!=rx+2)puts("ERROR");else{split(fx,rx,T1,T2);split(T2,1,T1,T3);puts("OK");}
}
inline void chg(int x,int y,int z)
{
	int fx=fnd(x),fy=fnd(y);if(fx!=fy)return puts("ERROR"),void();
	int rx=rnk(x),ry=rnk(y);if(rx>ry)Swap(rx,ry),Swap(fx,fy),Swap(x,y);
	if(ry!=rx+2)return puts("ERROR"),void();
	split(fx,rx,T1,T2);split(T2,1,T2,T3);t[T2].sm=t[T2].vl=z;
	merge(merge(T1,T2),T3);puts("OK");
}
inline void qry(int x,int y)
{
	int fx=fnd(x),fy=fnd(y);if(fx!=fy)return puts("ERROR"),void();
	int rx=rnk(x),ry=rnk(y);if(rx<ry)
	{
		int c=fx;while(t[c].r)pushdown(c),c=t[c].r,pushdown(c);pt(c,' ');
		split(fx,rx,T1,T2);pt(t[T2].sm);merge(T1,T2);
	}
	else
	{
		int c=fx;while(t[c].l)pushdown(c),c=t[c].l,pushdown(c);pt(c,' ');
		split(fx,rx,T1,T2);pt(t[T1].sm);merge(T1,T2);
	}
}
int main()
{
	t[0].siz=0;cgt=n=read();int Q=read();rep(1,Q,i)
	{
		int opt=Get(),x=read(),y=read();
		switch(opt)
		{
			case 4: puts(fnd(x)==fnd(y)?"YES":"NO");break;
			case 1: add(x,y,read());break;case 2: del(x,y);break;
			case 3: chg(x,y,read());break;case 5: qry(x,y);break; 
		}
	}
}
```

---


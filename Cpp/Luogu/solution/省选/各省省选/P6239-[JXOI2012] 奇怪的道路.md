# [JXOI2012] 奇怪的道路

## 题目描述

小宇从历史书上了解到一个古老的文明。这个文明在各个方面高度发达，交通方面也不例外。考古学家已经知道，这个文明在全盛时期有 $n$ 座城市，编号为 $1,2,...,n$。$m$ 条道路连接在这些城市之间，每条道路将两个城市连接起来，使得两地的居民可以方便地来往。一对城市之间可能存在多条道路。

据史料记载，这个文明的交通网络满足两个奇怪的特征。

1. 这个文明崇拜数字 $k$，对于任何一条道路，设它连接的两个城市分别为 $u$ 和 $v$，则必定满足 $1 \le \left\vert {u-v}\right\vert \le k$。
2. 任何一个城市都与恰好偶数条道路相连（ $0$ 也被认为是偶数）。

不过，由于时间过于久远，具体的交通网络我们已经无法得知了。小宇很好奇这 $n$ 个城市之间究竟有多少种可能的连接方法，于是她向你求助。

两种可能的连接方法不同当且仅当存在一对城市，它们间的道路数在两种方法中不同。

在交通网络中，有可能存在两个城市无法互相到达。

方法数可能很大，你只需要输出方法数模 $10^9 + 7$ 后的结果。

## 说明/提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，满足 $1 \le n,m \le 30$，$1 \le k \le 8$。

## 样例 #1

### 输入

```
3 4 1```

### 输出

```
3```

## 样例 #2

### 输入

```
4 3 3```

### 输出

```
4```

# 题解

## 作者：封禁用户 (赞：27)

[题目链接](https://www.luogu.com.cn/problem/P6239)

## 简要题面：

有一个无向图（可能不连通），$n$ 个点，$m$ 条边。两个不同点的编号之差不大于 $K$。任意一个点的度数都为偶数（有无度数的点）。对这个无向图的形态进行计数，模 $10^9 + 7$。

$1 \le n,m \le 30$，$1 \le K \le 8$。

## 思路：

状压 $\texttt{DP}$，计数。很好想的。这一类题的难点其实在不重不漏。

$\texttt{DP}$ 题都是要看性质的。题面其实提示的很清楚了：“任意一个点的度数都为偶数”。显然，出题人希望你通过点的度数的奇偶来推无向图的形态。所以无脑设这题的状态是 $f_{i,j,k}$ 表示 $i$ 个点，$j$ 条边，$k$ 是每个点度数的奇偶（$1$ 是奇数，$0$ 是偶数）。

边界呢？因为当 $i=1$ 时是没有意义的，所以 $i$ 是要从 $2$ 开始的，$1 \to f_{2,0,0}$。

枚举范围呢？“两个不同点的编号之差不大于 $K$”，这句话启示我们让$i-K \sim i-1$ 号点转移到 $i$ 号点。

第 $i$ 位是当前结点，所以每一加一条边度数都会改变，所以 $k \oplus 1 \to k$（状态正着存）。然后改变另一个点的奇偶，即 $k \oplus (2^{i-c}) \to k$（$c$ 为与 $i$ 连边的点）。

可以发现，这样的转移是有序的，每次都由编号大的结点指向编号小的结点。

于是有转移方程：

$f_{i,j,k} = \sum^{i-1}_{c = i-K} {\sum^{2^{K+1}-1}_{a=0}}f_{i,j-1,k \oplus 1 \oplus 2^{i-c}}$

于是某个大聪明打出了这样的代码：

```cpp
signed main() {
	cin >> n >> m >> k;
	dp[2][0][0] = 1;
	for (int i = 2; i <= n; i++) {
		for (int change = max(1, i - k); change <= i - 1; change++) {
			for (int j = 1; j <= m; j++) {
				for (int now_state = 0; now_state < (1 << (k + 1)); now_state++) {
					dp[i][j][now_state] = (dp[i][j][now_state] + dp[i][j - 1][now_state ^ 1 ^ (1 << i - change)]) % mod;
				}
			}
		}
	}
	cout<<dp[n][m][0]<<'\n';
	return 0;
}
```

诶，怎么不对呢？怎么都输出 ``0`` 啊。形如这样的情况，说明漏了转移。

我们观察到，每一次多一个点的情况都要转移过去，这也是没有讨论全面的一个错误。

添加一个发送式转移至下个阶段：

$f_{i+1,j,k \times 2^{1}} = \sum ^{m}_{j=0} \sum^{2^K-1}_{k = 0}f_{i,j,k}$

坑点：位运算要打括号！取模要小心！

## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 1e9 + 7;
const int Data_Range_Of_N = 30 + 5;
const int Data_Range_Of_K = 10 + 5;
int n, m, k;
int dp[Data_Range_Of_N][Data_Range_Of_N][1 << Data_Range_Of_K];
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m >> k;
	dp[2][0][0] = 1;
	for (int i = 2; i <= n; i++) {
		for (int change = max(1, i - k); change <= i - 1; change++) {
			for (int j = 1; j <= m; j++) {
				for (int now_state = 0; now_state < (1 << (k + 1)); now_state++) {
					dp[i][j][now_state] = (dp[i][j][now_state] + dp[i][j - 1][now_state ^ 1 ^ (1 << i - change)]) % mod;
				}
			}
		}
		for(int j = 0;j<=m;j++) {
			for(int now_state = 0;now_state < (1 << k);now_state++) {
				dp[i+1][j][now_state << 1] = (dp[i][j][now_state] + dp[i+1][j][now_state << 1]) % mod;
			}
		}
	}
	cout<<dp[n][m][0]<<'\n';
	return 0;
}
```

---

## 作者：一扶苏一 (赞：26)

## 【计数dp】【P6239】 [JXOI2012]奇怪的道路

### Solution

首先图是无向的，这样对于每条边，不妨认为它是从编号较大的点指向编号较小的点的，来方便枚举点的编号。另外 $k$ 非常小，这提示我们可以把后 $k$ 个点的度数奇偶性状压成二进制。

一个 naive 的想法是 $f_{i, j, S}$ 是考虑前 $i$ 个点，$j$ 条边，后 $k$ 个点的奇偶性二进制表示为 $S$ 的方案数。但是写出来会有各种各样的问题，原因是转移有一部分是无序的，会重复计数。

考虑用状态对转移加以限制。设 $f_{i, j, S, t}$ 是考虑前 $i$ 个点，$j$ 条边，后 $k$ 个点奇偶性二进制表示为 $S$，且前 $(i-1)$ 个点向前连的边都连完了，$i$ 只连了 $(i- k)\sim (i - t - 1)$ 的点的方案数。

具体对 $S$ 的定义是，对于节点 $i$ 的状态，若节点 $(i - k)$ 的度数为奇数，则 $S$ 二进制第 $k$ 位为 $1$，否则为 $0$。

考虑转移，在该状态首先可以再连一条 $i \to i - t - 1$ 的边，即

$$f_{i, j + 1, S', t} += f_{i, j, S, t}$$

其中 $S'$ 是 $S$ 状态对 $2^0$ 和 $2^{t-1}$ 取异或的结果。

另外该状态也可以是 $i \to i - t - 1$ 的最后一条边，即

$$f_{i, j, S, k - 1} += f_{i, j, S, k}$$

表示从下一条边开始考虑连向 $i - t$。

对于已经连完了 $i\to i - 1$ 的边的状态，如果节点 $i - k$ 的度数是偶数，那么就可以考虑 $i + 1$ 节点怎么连边了，否则由于 $i + 1$ 无法连向 $i - k$，这个状态是不合法的。

$$f_{i + 1,j,S',\min(i, t)} += f_{i, j, S, 0}$$

其中 $S'$ 代表 $S$ 左移一位后的结果。

边界条件当然是 $f_{1, 0, 0, 0} = 1$，输出 $f_{n, m, 0, 0}$ 即可。

### Code

代码里 $t$ 和 $k$ 是反的。

```cpp
const int maxn = 32;
const int maxt = 1025;
const int p = 1000000007;

int n, m, t;
int f[maxn][maxn][maxt][maxn];

int main() {
  freopen("1.in", "r", stdin);
  qr(n); qr(m); qr(t);
  int upc = (1 << (t + 1)) - 1, fir = 1 << t;
  f[1][0][0][0] = 1;
  for (int i = 1, di = i + 1; i <= n; i = di++) {
    for (int j = 0, dj = j + 1; j <= m; j = dj++) {
      for (int s = 0; s <= upc; ++s) {
        for (int k = std::min(i - 1, t); k; --k) {
          (f[i][j][s][k - 1] += f[i][j][s][k]) %= p;
          if (i > k) (f[i][dj][s ^ 1 ^ (1 << k)][k] += f[i][j][s][k]) %= p;
        }
        if ((s & fir) == 0) {
          (f[di][j][s << 1][std::min(i, t)] += f[i][j][s][0]) %= p;
        }
      }
    }
  }
  qw(f[n][m][0][0], '\n');
  return 0;
}
```



---

## 作者：_OMA_ (赞：8)

[奇怪的道路](https://www.luogu.com.cn/problem/P6239)

~~我看不出来是状压的状压~~

好吧，其实看到k的范围应该去往状压方面想的。

然后，题目中说“任何一个城市都与恰好偶数条道路相连（0也被认为是偶数）”。

所以，奇偶，两种状态可以用0,1来表示，那就妥妥的状压了。

设 $dp_{i,j,sta}$ 表示当前已经考虑了i座城市，j条道路，当前状态为sta的方案数。

用0表示奇数，1表示偶数，为了防止转移时出现问题，所以只转移第i个城市的前k个城市，通过异或能够将连边的两个城市由奇变偶，由偶变奇。

则有
$$
dp_{i,j,sta}=\sum_{l=i-k}^{i-1}\sum_{sta=0}^{2^{k+1}-1}dp_{i,j-1,sta^{\wedge}1^{\wedge}2^{i-1}}
$$
因为在转移的时候，sta表示的范围在发生变化，所以对于每一个i都要再单独处理一下
$$
dp_{i+1,j,sta\times 2}=\sum_{j=0}^{m}\sum_{sta=0}^{2^{k}-1}dp_{i,j,sta}
$$
*Code：*
``` cpp
#include<cstdio>
#define top 10
#define MAX 32
#define re register
namespace OMA
{
   int n,m,k;
   int dp[MAX][MAX][1<<top];
   const int p=1000000007;
   inline int max(int a,int b)
   { return a>b?a:b; }
   signed main()
   {
     scanf("%d%d%d",&n,&m,&k);
     dp[2][0][0] = 1;
     for(re int i=2; i<=n; i++)
     {
       for(re int l=max(i-k,1); l<=i-1; l++)
       {
         for(re int j=1; j<=m; j++)
         {
           for(re int temp=0; temp<(1<<k+1); temp++)
           { dp[i][j][temp] = (dp[i][j][temp]+dp[i][j-1][temp^1^(1<<(i-l))])%p;  }
         }
       }
       for(re int j=0; j<=m; j++)
       {
         for(re int temp=0; temp<(1<<k); temp++)
         { dp[i+1][j][temp<<1] = (dp[i][j][temp]+dp[i+1][j][temp<<1])%p;  }
       }
     }
     printf("%d\n",dp[n][m][0]);
     return 0;
   }
}
signed main()
{ return OMA::main(); }
```


---

## 作者：Coros_Trusds (赞：4)

# 题目大意

小宇从历史书上了解到一个古老的文明。这个文明在各个方面高度发达，交通方面也不例外。考古学家已经知道，这个文明在全盛时期有 $n$ 座城市，编号为 $1,2,...,n$。$m$ 条道路连接在这些城市之间，每条道路将两个城市连接起来，使得两地的居民可以方便地来往。一对城市之间可能存在多条道路。

据史料记载，这个文明的交通网络满足两个奇怪的特征。

1. 这个文明崇拜数字 $k$，对于任何一条道路，设它连接的两个城市分别为 $u$ 和 $v$，则必定满足 $1 \le \left\vert {u-v}\right\vert \le k$。

2. 任何一个城市都与恰好偶数条道路相连（ $0$ 也被认为是偶数）。

不过，由于时间过于久远，具体的交通网络我们已经无法得知了。小宇很好奇这 $n$ 个城市之间究竟有多少种可能的连接方法，于是她向你求助。

两种可能的连接方法不同当且仅当存在一对城市，它们间的道路数在两种方法中不同。

在交通网络中，有可能存在两个城市无法互相到达。

方法数可能很大，你只需要输出方法数模 $10^9 + 7$ 后的结果。

# 题目分析

为方便枚举，对于每条边，我们都将其变成有向边且由编号较大的边连向较小的边。

因此我们可以令 $dp[i][j][s]$ 表示前 $i$ 个点，总共连了 $j$ 条边，后 $k$ 个点度数的奇偶性状态为集合 $s$ 时的方案总数。具体地，对于节点 $i$ 的状态，若节点 $i-h$ 的度数为奇数，则 $s$ 二进制从右往左数（最右边是第 $0$ 位）第 $h$ 位为 $1$，否则为 $0$。

可是，这个状态太过模糊了，对于我们确定一个图的要求还不够，可能会计算重复。

改进一下：

$dp[i][j][s][v]$ 表示前 $i$ 个点，总共连了 $j$ 条边，后 $k$ 个点度数的奇偶性状态为集合 $s$，前 $i-1$ 个点向前连的边都连完了，点 $i$ 只考虑了从 $i$ 连接 $i-k\sim i-v-1$ （不一定都要连）时的方案总数。

这个时候就要分析接下来会出现什么。

+ 再连一条 $i\to i-v-1$ 的边，那么我们点 $i$ 和点 $i-v-1$ 的度数的奇偶性就会变化。状态转移方程：$dp[i][j+1][s'][v]+dp[i][j][s][v]$。

其中 $s'=s\operatorname{xor}1\operatorname{xor}(1<<(v-1))$。

+ 现在连的是 $i\to i-v-1$ 的最后一条边了，下一条需要考虑的边就是 $i\to i-v$ 了。转移方程为：$dp[i][j][s][v-1]+dp[i][j][s][v]$。我们还不确定是否要连这条边，这不是这个状态需要考虑的事。

+ 考虑完了 $i\to nxt,nxt\in[i-k,i-1]$ 的所有连边，加入一个新的点 $i+1$，这时就不能选 $i-k$ 了，因为此时两点距离为 $i+1-(i-k)=k+1$，不满足小于等于 $k$ 的条件。这意味着之后 $i-k$ 的度数不会再变了，如果此时还是度数还是奇数，那么永远不可能合法了。

所以是当 $i-k$ 的度数是偶数时，才能转移更新：$dp[i+1][j][s''][\min(i,t)]+dp[i][j][s][0]$。

$\min(i,t)$ 的原因：$v=\min(0,i-t)=\min(i+1-i-1,i+1-t-1)$。

其中 $s''=s<<1$。

答案就是 $dp[n][m][0][0]$。

# 代码

```cpp
// Problem: P6239 [JXOI2012]奇怪的道路
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P6239
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// Date:2022-05-23 13:44
// 
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	inline int read() {
		int ret = 0,f = 0;char ch = getchar();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getchar();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getchar();
		}
		return f ? -ret : ret;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;

const int N = 35,M = 9;
int dp[N][N][1 << M][N];
//dp[i][j][s][v]:前 i 个点总共连了 j 条边,后 k 个点度数的奇偶性状态为集合 s,前 i - 1 个点向前连的边都连完了,点 i 只考虑了从 i 连接 i - k ~ i - v - 1 (不一定都要连)时的方案总数
int n,m,k;
int main(void) {
	n = read(),m = read(),k = read();
	dp[1][0][0][0] = 1;
	for (register int i = 1;i <= n; ++ i) {
		for (register int j = 0;j <= m; ++ j) {
			for (register int s = 0;s < (1 << (k + 1)); ++ s) {
				for (register int v = std::min(i,k);v >= 1; -- v) {
					if (i > v) {
						dp[i][j + 1][s ^ 1 ^ (1 << v)][v] = MOD(dp[i][j + 1][s ^ 1 ^ (1 << v)][v] + dp[i][j][s][v]);
					}
					dp[i][j][s][v - 1] = MOD(dp[i][j][s][v - 1] + dp[i][j][s][v]);
				}
				if (!(s & (1 << k))) {
					dp[i + 1][j][s << 1][std::min(i,k)] = MOD(dp[i + 1][j][s << 1][std::min(i,k)] + dp[i][j][s][0]);
				}
			}
		}
	}
	printf("%d\n",dp[n][m][0][0]);
	
	return 0;
}
```

---

## 作者：Stinger (赞：4)

[博客使用更好吃（bushi)](https://zqs2020.gitee.io/2021/01/06/luogu-P6239/)

[传送门](https://www.luogu.com.cn/problem/P6239)

状压DP好题。自己太弱没想出来好不容易才把咕咕的题解看懂QAQ。所以特地来对咕咕的题解一些省略了的地方做补充

咕咕说的一个naive想法：$f_{i,j,s}$ 表示前 $i$ 个点，连了 $j$ 条边，后 $k$ 个点的度数奇偶二进制表示为 $s$ 的方案数。显然转移起来有重复计算，因为我们根本不知道哪些点、边连了那些没有连。

I am too naive。还真就只想到了这个naive想法，而正解的状态应该是：$f_{i,j,s,t}$ 表示前 $i$ 个点，$j$ 条边，后 $k$ 个点的度数奇偶二进制表示为 $s$，当前点 $i$ 只考虑到了和 $i-k\sim i-t-1$ 个点连边（**注意，不一定和这些点连了边，但是 $i$ 和 $i-t-1$ 后的点一定没有连边**）的方案数。

具体的，第 $x$ 个点对应的二进制位为 $i-x$。如果点 $i$ 度数为奇数，第 $i$ 位为 $1$，反之为 $0$。

转移的情况，首先最容易想到的是直接跳过 $i-t-1$ 这个点，在今后不再 $i$ 考虑和 $i-t-1$ 连边，考虑 $i$ 与 下一个点 $i-t-2$ 的连边情况，说白了也就是什么也不干，不加点也不加边,对应的式子为（这个东西不叫转移方程，因为是刷表法，它只是一个更新公式）：

$$f_{i,j,s,t-1}+=f_{i,j,s,t}$$

其次，还可以再与 $i-t-1$ 这个点连一条边。边数加一，并且此时点 $i$ 与点 $i-t-1$ 度数的奇偶性发生改变，所以 $s^{\prime}$ 是 $s$ 与这两个点对应的二进制位取异或的结果：

$$f_{i,j+1,s^{\prime},t}+=f_{i,j,s,t}$$

$s^{\prime}$ 为 $s$ 对 $2^0$ （第 $i$ 个点对应的二进制位）与 $2^{t-1}$ （第 $i-t-1$ 个点对应的二进制位）取异或的结果。

如果当前已经把 $i$ 与 $i-k\sim i-1$ 的所有连边都考虑完了，就可以加入新的点 $i+1$ 了。但是注意，这个时候 $i+1$ 由于题目规定不能往 $i-k$ 连，而题目要求每一个点的度数都是偶数，所以 $i-k$ 的度数必须为偶数才能转移。

$$f_{i+1,j,s^{\prime},min(i,t)}+=f_{i,j,s,0}$$

$s^{\prime}$ 为 $s$ 左移一位的结果。

输出 $f_{n,m,0,0}$。

虽然思路来自咕咕，但是看在我这么认真写题解的份上~~点个赞再走吧QAQ~~

# $Code:$
```cpp
#include <cstdio>

const int MOD = 1e9 + 7, N = 32;
inline int min(const int x, const int y) {return x < y ? x : y;}
inline void upd(int &x, const int y) {if ((x += y) >= MOD) x -= MOD;}
int f[N][N][1025][N];

int main() {
	int n, m, k;
	scanf("%d%d%d", &n, &m, &k);
	f[1][0][0][0] = 1;
	for (int i(1); i <= n; ++ i) {
		for (int j(0); j <= m; ++ j)
		for (int S(0); S < 1 << k + 1; ++ S) {
			for (int t(min(i - 1, k)); t; -- t) {
				upd(f[i][j][S][t - 1], f[i][j][S][t]);
				if (i > t) upd(f[i][j + 1][S ^ 1 ^ 1 << t][t], f[i][j][S][t]);
			}
			if (!(S & (1 << k))) upd(f[i + 1][j][S << 1][min(i, k)], f[i][j][S][0]);
		}
	}
	printf("%d", f[n][m][0][0]);
	return 0;
}
```

---

## 作者：Infinity_Fantasy (赞：1)

状压 dp 定义：通常将以一个集合内的元素信息作为状态且状态总数为指数级别的动态规划称为状态压缩动态规划。
## 首先考虑设置状态
我们令 $f_{i,j,s,l}$ 表示在考虑到第 $i$ 个点，已经连了 $j$ 条边，枚举到了第 $i-s$ 个点 $\left( \left|\ u-v \right| \le k \right)$，状态压缩为 $l$ 的时候的方案数。
## 然后考虑转移方程
个人认为转移方程挺好理解，分别考虑不连边、与之前的且在范围内的点相连、连新点，详见代码。
## 初始化
**一切 DP 都要考虑初始化！！！** 因为方程转移是从小到大转移的，所以 $f_{2,0,0,0}$ 其实才是连完第一个点的情况，然后把他初始化成 1，同理最后的答案就是 $f_{n+1,m,0,0}$。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,m,k,f[41][41][41][550];
int main(){
	cin>>n>>m>>k;
	f[2][0][0][0]=1;
	for(int i=2;i<=n;i++)
		for(int j=0;j<=m;j++)
			for(int l=0;l<(1<<(k+1));l++)
                for(int s=0;s<=k;s++){
                    if(s!=min(i-1,k)){
                        f[i][j][s+1][l]=(f[i][j][s+1][l]+f[i][j][s][l])%mod; //什么都不做
                        f[i][j+1][s][l^(1<<k)^(1<<(s+k-min(i-1,k)))]=(f[i][j+1][s][l^(1<<k)^(1<<(s+k-min(i-1,k)))]+f[i][j][s][l])%mod; //之前的点
                    }
                    if(s==min(i-1,k)&&(!(l&1))) //位运算判奇偶
                        f[i+1][j][0][l>>1]=(f[i+1][j][0][l>>1]+f[i][j][s][l])%mod; //下一个点
                }
	cout<<f[n+1][m][0][0];
	return 0;
}
```


---

## 作者：Loser_Syx (赞：1)

## 思路

考虑状压 dp。

设 $f_{i,j,k,l}$ 为前 $i$ 个点，连 $j$ 个边，$k$ 表示后面的 $K$ 个点每个点的度数的模 $2$ 后二进制转十进制的数，$i$ 此处只**可能**连了 $i - k \sim i - t - 1$ 这么多条边（因为此处只能连接差值 $\leq K$ 的边）。

由于此时对于 $i$ 而言，$i$ 还没有连向 $i - t - 1$ 的边，所以 $f_{i,j+1,k\oplus (1 \oplus 2^{t-1}),l}$ 可以被 $f_{i,j,k,l}$ 转移而来，然后因为改变了 $i - t - 1$ 这个点的度数，所以 $k$ 也需要改变。

$f_{i,j,k,l}$ 这个状态也可能会跳过连接 $i$ 到 $i - t - 1$ 的状态，所以我们也可以 $i - t - 1$ 这条边不连了，所以 $f_{i,j,k,l-1}$ 是可以被 $f_{i,j,k,l}$ 转移来的。

然后，因为题面要求对于每个点的度数都得是偶数，所以当且仅当 $i - K$ 的度数是偶数时，$i+1$ 这个点才能去考虑如何转移，此时 $f_{i,j,k,l}$ 可以转移到 $f_{i+1,j,k \div 2, l}$。

初始时令合法方案 $f_{1,0,0,0} = 1$。

答案就是 $f_{n,m,0,0}$。

注意本题空间限制要卡着开。

## 代码

```cpp
#include <iostream>
using namespace std;
const int mod = 1e9 + 7, N = 32, M = 12;
int f[N][N][1 << M][N];
int main() {
	int n, m, k;
	scanf("%d%d%d", &n, &m, &k);
	f[1][0][0][0] = 1;
	for (int i = 1; i <= n; ++i) for (int j = 0; j <= m; ++j) for (int s = 0; s < 1 << (k + 1); ++s) {
				for (int t = min(i - 1, k); t > 0; --t) {
					f[i][j][s][t - 1] = (f[i][j][s][t - 1] + f[i][j][s][t]) % mod;
					if (i > t) f[i][j + 1][s ^ 1 ^ (1 << t)][t] = (f[i][j + 1][s ^ 1 ^ (1 << t)][t] + f[i][j][s][t]) % mod;
				}
				if (!(s & (1 << k))) f[i + 1][j][s << 1][min(i, k)] = (f[i + 1][j][s << 1][min(i, k)] + f[i][j][s][0]) % mod;
			}
	printf("%d\n", f[n][m][0][0]);
	return 0;
}
```

---

## 作者：AlexandreLea (赞：1)

# 题意简述
求构造 $n$ 个点和 $m$ 条边，边所连接的节点编号之差小于等于 $k$ ，点的度数都为偶数的图的方案数取余 $10^9+7$。

# 题目思路
本题是一个状态压缩动态规划。经过简单的思考，确定 dp 数组的前两维 $i$ 和 $j$ 为 点数和边数；由于我们需要存储度数的奇偶值（众所周知，多个数的奇偶值可以被压位）和前 $k$ 个点的边数。

在最初的思考中，我采用「到哪里去」的方式，考虑每个状态可以拓展到哪里。因此，我们设计动态规划的状态为

$$f_{ijls}$$

表示枚举到第 $i$ 个点，用了 $j$ 条边，在 $i\sim\min(i-1,k)$ 个点，点 $i\sim i-k$ 的奇偶状态时的方案总数。

现在，我们对于每一步，有两种选项，连边和不连边。不连边时，就是这样：

$$f_{ijls}\to f_{ij(l+1)s}$$

连边时，就是这样：

$$f_{ijls}\to f_{i(j+1)(l+1)(s\oplus 2^l\oplus 2^k)}$$

现在，当我们枚举完了这些边并且 $i-k$ 号点的度数为偶数时（即 $l=\min(i-1,k)$ 并且 $s\bmod 2=0$ 时），就是这样：

$$f_{ijls}\to f_{(i+1)j(0)\lfloor s/2\rfloor}$$

此处的状态转移方程并非正确。根据以上思路，我写出了一份代码，然后甚至连样例都没有通过。于是，参考[这](https://www.luogu.com.cn/blog/fzk2009/solution-p6239)篇题解，我们这样改了下枚举范围：把 $s$ 改到内层第二层循环，$l$ 到第一层，于是……就对了。所以，某种意义上，这篇题解是便参考边改出来的。

最后附上初值：$f_{(2)(0)(0)(0)}=1$。

```cpp
#include <iostream>
using namespace std;
const int size=33,mod=1e9+7;
int main(){
    int n,m,k,f[size][size][size][(1<<9)]={};
    cin>>n>>m>>k;
    //f[2][0][0][0]=1;
    for(int i=2;i<=n;i++){
        for(int j=0;j<=m;j++){
            for(int s=0;s<(1<<(k+1));s++){
                for(int l=0;l<=k;l++){
                    if(l!=min(i-1,k)){
                        f[i][j][l+1][s]=(f[i][j][l+1][s]+f[i][j][l][s])%mod;
                        f[i][j+1][l][s^(1<<k)^(1<<(l+k-min(i-1,k)))]=(f[i][j+1][l][s^(1<<k)^(1<<(l+k-min(i-1,k)))]+f[i][j][l][s])%mod;
                    }
                    if(l==min(i-1,k)&&(!(s&1))){
                        f[i+1][j][0][s>>1]=(f[i+1][j][0][s>>1]+f[i][j][l][s])%mod;
                    }
                }
            }
        }
    }
    cout<<f[n+1][m][0][0]<<endl;
    return 0;
}
```

本题代码经过部分修改，防止抄袭。

**EOF**

---

## 作者：Expert_Dream (赞：1)


[P6239 [JXOI2012] 奇怪的道路](https://www.luogu.com.cn/problem/P6239)

首先，拿到题面，$n \le 30$，$k \le 8$，~~这不就暴搜吗~~。再想想，紫题会给你暴搜的机会吗？所以进一步思考，发现这其实是一道 DP，而且数据这么小，肯定是给状压 DP 的样子。

经过一定思考，发现我们可以直接线性枚举 $[1,n]$。

为什么呢？因为每一个点只能和前 $k$ 个点连边，而且每一个点只能有偶数条连边。那么我们枚举到 $i$，它可以改变的点最前面是 $i-k$，它下一个就是 $i+1$，那么枚举到 $i+1$ 时肯定没办法再改变 $i-k$，所以，到了 $i$ 是改变 $i-k$ 最后一次机会，所以再此时必须改变 $i-k$ 变成偶数。

于是，我们可以设计 dp 状态 $dp_{i,j,l,z}$ 代表枚举点数 $i$，枚举边 $j$，前 $k$ 个点中的第 $l$ 个，$z$ 为状态压缩，代表着每一个点的奇偶性。

因此我们可以推出转移方程（见代码）。

注意事项：状压 DP 用到位运算，因为位运算的优先级复杂，建议勤快的加括号，~~我就是因为这个括号的问题调了很久~~。

**AC CODE:**


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,k;
int dp[40][40][20][550];
const int p=1e9+7;
//定义：dp[i][j][l][z]
//表示枚举到第i个点，第j条边，z为i个点与前k个点的状压连边状态，已经连了l条边
signed main(){
	cin >> n >> m >> k;
	dp[2][0][0][0]=1;
	for(int i = 2;i <= n;i++){
		//枚举每一个点
		for(int j = 0 ;j <= m;j++){	
			//枚举每一条边
			for(int z=0;z<(1<<(k+1));z++){
				//枚举状态
				for(int l = 0;l <= k;l++){
					//枚举已经连的边数
					if(l!=min(i-1,k)){
						dp[i][j][l+1][z]=(dp[i][j][l+1][z] + dp[i][j][l][z])%p;
						dp[i][j+1][l][z^(1<<(l+k-min(k,i-1)))^(1<<k)] = (dp[i][j+1][l][z^(1<<(l+k-min(k,i-1)))^(1<<k)] + dp[i][j][l][z]) % p;
					}
					if(l==min(i-1,k) && !(z & 1))
						dp[i+1][j][0][z>>1]=(dp[i+1][j][0][z>>1]+dp[i][j][l][z])%p;
					
				}
			}
		}
	}
	cout<<dp[n+1][m][0][0] % p;
	return 0;
}

```

---


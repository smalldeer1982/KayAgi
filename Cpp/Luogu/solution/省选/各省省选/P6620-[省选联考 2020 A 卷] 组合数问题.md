# [省选联考 2020 A 卷] 组合数问题

## 题目背景

1s 512M

## 题目描述

众所周知，小葱同学擅长计算，尤其擅长计算组合数。小葱现在希望你计算 
$$\left(\sum_{k=0}^{n}f(k)\times x^k\times \binom{n}{k}\right)\bmod p$$ 
的值。其中 $n$, $x$, $p$ 为给定的整数，$f(k)$ 为给定的一个 $m$ 次多项式 $f(k) = a_0 + a_1k + a_2k^2 + \cdots + a_mk^m$。$\binom{n}{k}$ 为组合数，其值为 $\binom{n}{k} = \frac{n!}{k!(n-k)!}$。

## 说明/提示

#### 样例 1 解释

$f(0) = 0，f(1) = 1，f(2) = 4，f(3) = 9，f(4) = 16，f(5) = 25$。

$x = 1$，故 $x^k$ 恒为 $1$，乘积中的该项可以忽略。

$\binom 5 0 = 1, \binom 5 1 = 5, \binom 5 2 = 10, \binom 5 3 = 10, \binom 5 4 = 5, \binom 5 5 = 1$。

#### 样例 3

见附加文件中 `problem3.in` 与 `problem3.ans`。

#### 数据范围与提示

对于所有测试数据：$1\le n, x, p \le 10^9, 0\le a_i\le 10^9, 0\le m \le \min(n,1000)$。

每个测试点的具体限制见下表：

| 测试点编号  | $n\le $ | $m\le $ | 其他特殊限制 |
| :---------: | :-----: | :-----: | :----------: |
|  $1\sim 3$  | $1000$  | $1000$  |              |
|  $4\sim 6$  | $10^5$  |   $0$   |  $p$ 是质数  |
|  $7\sim 8$  | $10^9$  |   $0$   |              |
| $9\sim 12$  | $10^9$  |   $5$   |              |
| $13\sim 16$ | $10^9$  | $1000$  |    $x=1$     |
| $17\sim 20$ | $10^9$  | $1000$  |              |

## 样例 #1

### 输入

```
5 1 10007 2
0 0 1```

### 输出

```
240```

## 样例 #2

### 输入

```
996 233 998244353 5
5 4 13 16 20 15```

### 输出

```
869469289```

# 题解

## 作者：yurzhang (赞：193)

# 前言

这也许是我写的最后一篇题解了。

虽然想说这是道送我退役的题，但归根结底还是我菜，跟题目没多大关系。

之前模拟赛还考过那道[如何优雅地求和](http://uoj.ac/problem/269)，今天出考场 [Fuyuki](https://www.luogu.com.cn/user/109236) 跟我讲以前考过我还完全没想起来，过了半天才记起当时我也没想到拆成下降幂，这不是完全没有任何进步吗...

---

# 正文

直接来看题目给的式子：

$$\sum_{k=0}^{n}{f(k)\times x^k\times\binom{n}{k}}$$

这个 $f(k)$ 我们肯定是要拆开来算的，但如果你把它拆成单项式，就会像我一样在考场里浪费光阴，因为这个单项式和组合数不是很搭。

但是如果你组合数学学得好或者能把混凝土数学倒着背，亦或做过前言里提到的那道题，就会想到一个叫做下降幂的玩意儿，它有着非常优秀的性质。

具体来说，假如我们有一个这样的下降幂单项式：

$$k^{\underline{m}}=\prod_{i=k-m+1}^{k}{i}$$

你会发现它和组合数相乘有非常漂亮的结果：

$$\binom{n}{k}\times k^{\underline{m}}=\binom{n-m}{k-m}\times n^{\underline{m}}$$

证明的话把组合数拆成阶乘随便消下就能得证。

于是我们考虑把题目中所给的 $f(k)=\sum_{i=0}^{m}{a_ik^i}$ 转化成下降幂多项式 $f(k)=\sum_{i=0}^{m}{b_ik^{\underline{i}}}$

$$\sum_{k=0}^{n}{\sum_{i=0}^{m}{b_ik^{\underline{i}}}\times x^k\times\binom{n}{k}}=\sum_{i=0}^{m}{b_in^{\underline{i}}\sum_{k=0}^{n}{\binom{n-i}{k-i}x^k}}$$

发现当 $i>k$ 时里头值直接为 $0$ 了可以扔掉，于是内层改成枚举 $k-i$，式子就变成了这样：

$$\sum_{i=0}^{m}{b_in^{\underline i}\sum_{k=0}^{n-i}{\binom{n-i}{k}x^{k+i}}}=\sum_{i=0}^{m}{b_in^{\underline i}x^i\sum_{k=0}^{n-i}{\binom{n-i}{k}x^k}}$$

这时我们发现里头直接变成了 $m=0$ 的部分分，随便套一下我们在小学二年级就学习过的二项式定理可以知道：

$$\sum_{k=0}^{n-i}{\binom{n-i}{k}x^k1^{n-i-k}}=(x+1)^{n-i}$$

于是题目的式子最终可以变成这样：

$$\sum_{i=0}^{m}{b_in^{\underline i}x^i(x+1)^{n-i}}$$

如果我们知道所有的 $b_i$ 就可以在 $O(m)$ 的复杂度内计算出结果，于是最后问题落在了普通多项式转下降幂多项式上。

而我们又知道：

$$x^n=\sum_{i=0}^{n}{\begin{Bmatrix}n\\i\end{Bmatrix}}x^{\underline i}$$

因此有：

$$\begin{aligned}\sum_{i=0}^{m}{a_ik^i}&=\sum_{i=0}^{m}{a_i\sum_{j=0}^{i}{\begin{Bmatrix}i\\j\end{Bmatrix}k^{\underline j}}}\\&=\sum_{i=0}^{m}{k^{\underline i}\sum_{j=i}^{m}{\begin{Bmatrix}j\\i\end{Bmatrix}a_j}}\end{aligned}$$

也就是说：

$$b_i=\sum_{j=i}^{m}{\begin{Bmatrix}j\\i\end{Bmatrix}a_j}$$

直接 $O(m^2)$ 暴力递推第二类斯特林数即可，总时间复杂度 $O(m^2)$，可以通过本题。

---

# 最后

今天的分已经是明天 AK 都救不回的样子了，更何况我也没那个水平 AK Day2，想说的话着实有很多，但在题解里说太多也很奇怪就不多讲了，就祝愿这次进队的同学能走得更远吧。

转眼间 OI 也伴我走过了两年，我大概这一生都会记得这段闪烁着光辉的时光吧。所有看着我以及陪伴我走完这一程的人，真的非常非常感谢你们，希望你们也能在自己的道路上更进一步。

$$\textcolor{#20C1DD}{唯有那份眩目——未曾忘却...}$$

---

## 作者：ix35 (赞：75)

之前不会一些斯特林数和下降幂多项式的知识，考场上现推了很多东西，出发点基本只用到了如下组合恒等式：

$$k\times \binom n k=n\times \binom {n-1}{k-1}$$

以及二项式定理：

$$(1+x)^n=\sum\limits_{i=0}^n\binom n i x^i$$

在这里和大家分享一下如果不会任何特殊的奇技淫巧，该怎么推出各种所需结论&做出本题，也还原了一下考场的思维过程。

首先题目中的多项式 $f(k)$ 显然可以拆成 $m+1$ 个单项式之和，我们只讨论单项式的结果，即：

$$\sum\limits_{k=1}^n k^p\times x^k\times \binom n k$$

首先我们看到了 $k^p\times \binom n k$，就想到了最上面的那个组合恒等式，我们尝试将它扩展到 $k$ 的更高次幂的形式：

$$k\times \binom n k=n\times \binom{n-1}{k-1}$$

$$k^2\times \binom n k=k\times\Big(n\times \binom {n-1}{k-1}\Big)$$

$$=(k-1)\times n\times \binom {n-1}{k-1}+n\times \binom {n-1}{k-1}$$

$$=n\times (n-1)\times \binom {n-2}{k-2}+n\times \binom{n-1}{k-1}$$

好像还不能看出很多规律，我们再推一个 $p=3$：

$$k^3\times \binom n k =k\times \Big(n\times (n-1)\times \binom {n-2}{k-2}+n\times \binom {n-1}{k-1}\Big)$$

$$=n(n-1)(n-2)\binom{n-3}{k-3}+2n(n-1)\binom{n-2}{k-2}+n(n-1)\binom{n-2}{k-2}+n\binom{n-1}{k-1}$$

$$=n(n-1)(n-2)\binom{n-3}{k-3}+3n(n-1)\binom{n-2}{k-2}+n\binom{n-1}{k-1}$$

于是我们发现，似乎 $k^p\times \binom n k$ 可以拆成很多形如 $n(n-1)\ldots (n-l+1)\times \binom {n-l}{k-l}$ 的式子的和。

而前面这个东西就是所谓的下降幂了，我们记为 $n^{\underline l}$。

我们可以得到：

$$k^p\times \binom n k=\sum\limits_{i=1}^p S(p,i)\times n^{\underline i}\times \binom {n-i}{k-i}$$

其中 $S(p,i)$ 是待定的系数，但是根据上面的计算过程，我们可以得到关于 $S(p,i)$ 的恒等式：

$$S(p,i)=i\times S(p-1,i)+S(p-1,i-1)$$

前面的 $i\times S(p-1,i)$ 表示从 $k^{p-1}\times \binom n k$ 中继承过来的 $n^{\underline i}\times \binom {n-i}{k-i}$ 项（我们将 $k$ 拆成 $k-i+i$ 中后面的 $+i$ 就在这里体现），后面的 $S(p-1,i-1)$ 表示原先的下一项，在乘上一个 $k-i$ 之后变成了 $i$ 这一项的系数。

这个系数实际上就是第二类斯特林数，不过知不知道都不影响，有这个递推式就够了。

接下来推原来的式子：

$$\sum\limits_{k=1}^n k^p\times x^k\times \binom n k=\sum\limits_{j=1}^p S(p,j)\times n^{\underline j}\times \Big(\sum\limits_{k=j}^n x^k\times \binom {n-j}{k-j}\Big)$$

这一步只是套用了上面的结论，接下来大括号里面的式子用二项式定理打开：

$$\sum\limits_{k=j}^nx^k\times \binom {n-j}{k-j}=x^j\times\sum\limits_{k=0}^{n-j}\binom {n-j}{k}x^k=x^j\times (1+x)^{n-j}$$

这样里面的式子就做完了，再把原来的多项式 $f(k)$ 放进来：

$$Ans=a_0(1+x)^n+\sum\limits_{i=1}^m a_i\times \Big(\sum\limits_{j=1}^i S(i,j)\times n^{\underline j}\times x^j\times (1+x)^{n-j}\Big)$$

注意前面 $a_0$ 要特殊处理，因为 $p=0$ 时上面我们推出来的式子不成立（是以 $1$ 为起始条件的）。

这样已经可以在 $O(m^2\log m)$ 的时间中计算了，想要得到 $O(m^2)$ 做法也很容易，交换一下求和号即可：

$$Ans=a_0(1+x)^n+\sum\limits_{j=1}^m n^{\underline j}\times x^j\times (1+x)^{n-j}\times \Big(\sum\limits_{i=j}^m a_i\times S(i,j)\Big)$$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1010;
int n,x,p,m,ans,a[MAXN],trans[MAXN][MAXN];
int qpow (int a,int b) {
	int res=1;
	while (b) {
		if (b&1) {res=(1ll*res*a)%p;}
		a=(1ll*a*a)%p,b>>=1;
	}
	return res;
}
int main () {
	freopen("problem.in","r",stdin);
	freopen("problem.out","w",stdout);
	scanf("%d%d%d%d",&n,&x,&p,&m);
	for (int i=0;i<=m;i++) {
		scanf("%d",&a[i]);
	}
	trans[1][1]=1;
	for (int i=2;i<=m;i++) {
		for (int j=1;j<=i;j++) {
			trans[i][j]=((1ll*trans[i-1][j]*j)%p+trans[i-1][j-1])%p;
		}
	}
	ans=(1ll*a[0]*qpow((x+1)%p,n))%p;
	for (int i=1;i<=m;i++) {
		int tmp=(1ll*qpow(x%p,i)*qpow((x+1)%p,n-i))%p,val=0;
		for (int j=0;j<=i-1;j++) {tmp=(1ll*tmp*(n-j))%p;}
		for (int j=i;j<=m;j++) {
			val=(val+(1ll*trans[j][i]*a[j])%p)%p;
		}
		ans=(ans+(1ll*val*tmp)%p)%p;
	}
	printf("%d\n",ans);
	return 0;
}
```


























---

## 作者：xgzc (赞：68)

写个不太一样的做法~

设 $F(n, m) = \sum_{k=0}^n k^mx^k\binom nk$，于是答案就是 $\sum_i a_iF(n, i)$。

那么有：
$$
\begin{aligned}
F(n, m) &= \sum_{k=0}^n k^m x^k \binom nk\\
&= n\sum_{k=0}^n k^{m-1}x^k\binom {n-1}{k-1}
\end{aligned}
$$
然后：
$$
\begin{aligned}
F(n, m) &= \sum_{k=0}^n k^mx^k\binom nk\\
&= \sum_{k=0}^n k^mx^k\left(\binom {n-1}k + \binom{n-1}{k-1} \right)\\
&= F(n-1,m) + \frac 1n F(n, m + 1)
\end{aligned}
$$
也就是说：$F(n, m) = n(F(n, m - 1) - F(n - 1, m - 1))$。

边界为 $F(n, 0) = (x + 1)^n$。

代码见我的 [$\texttt{blog}$](https://www.cnblogs.com/cj-xxz/p/13198301.html)

---

## 作者：Fuyuki (赞：29)

$$\sum_{k=0}^n \binom{n}{k}x^ki^{\underline{p}}=n^{\underline{p}}x^p\sum_{k=0}^{n-p}\binom{n-p}{k}x^k$$

$$=n^{\underline{p}}x^p(x+1)^{n-p}$$

将 $f(x)$ 转成下降幂多项式之后就可以 $O(mlogm)$ 计算上式。

转下降幂多项式（我所知范围内）最简单的做法是依次将 $x^k$ 替换成 $x^{\underline{k}}$，然后调整较低项的系数。计算 $x^{\underline{k}}$ 可以递推。

那么就可以在 $O(m^2)$ 的时间内解决本题了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define I inline int
#define V inline void
#define ll long long int
#define ROF(i,a,b) for(int i=a;i>=b;i--)
#define FOR(i,a,b) for(int i=a;i<=b;i++)
const int N=1e3+1;
int n,x,m,s,mod,ans,a[N],f[N][N];
V check(int&x){x-=mod,x+=x>>31&mod;}
I Pow(ll t,int x,ll s=1){
	for(;x;x>>=1,t=t*t%mod)if(x&1)s=s*t%mod;
	return s;
}
int main(){
	scanf("%d%d%d%d",&n,&x,&mod,&m),f[0][0]=s=1;
	FOR(i,0,m)scanf("%d",a+i);
	FOR(i,1,m)FOR(j,0,i){
		if(j)f[i][j]=f[i-1][j-1];
		check(f[i][j]+=1ll*(1-i%mod+mod)*f[i-1][j]%mod);
	}
	ROF(i,m,1)FOR(j,0,i-1)check(a[j]+=mod-1ll*f[i][j]*a[i]%mod);
	FOR(i,0,m)check(ans+=1ll*Pow(x,i,s)*Pow(x+1,n-i,a[i])%mod),s=1ll*s*(n-i)%mod;
	return cout<<ans,0;
} 
```

（考场上 5min 写完）

---

## 作者：BJpers2 (赞：27)

本题入手角度很多，可以强行上组合意义，也可以组合恒等式推导。这些方法基本上殊途同归，本质上都是一般多项式转下降幂多项式，然后$O(m)$计算答案。（好像如果$p$是质数还能多项式快速幂，但这不重要）

但综观洛谷上所有本题题解，似乎没有从组合数行生成函数角度来分析的。因此我这列提供一种基于此比较快捷的打通思路方法。

### 1. 普通多项式转下降幂多项式

由于本题可以接受$O(m^2)$的算法，我们可以直接利用第二类斯特林数的性质:
$$
n^k=\sum_{i=0}^k n^{\underline i}\begin{Bmatrix}k \\ i \end{Bmatrix}
$$
设多项式$a$转化成的下降幂多项式为$b$，即如果$t$为自变量时
$$
\sum_{i=0}^m a_i t^i=\sum_{i=0}^m b_i t^{\underline i}
$$
通过第一个式子展开$t^i$可以得到
$$
b_k=\sum_{i=0}^k \begin{Bmatrix}k \\ i \end{Bmatrix}a_i
$$
利用递推式
$$
\begin{Bmatrix}i \\ j \end{Bmatrix}=\begin{Bmatrix}i-1 \\ j-1 \end{Bmatrix}+j\begin{Bmatrix}i-1 \\ j \end{Bmatrix}
$$
可以轻松$O(m^2)$预处理第二类斯特林数。然后可以直接利用第三个式子计算$b$。

现在我们的任务变为计算
$$
\sum_{k=0}^n \sum_{i=0}^m b_ix^kk^{\underline i}\binom n k=\sum_{i=0}^m b_i\sum_{k=0}^n x^kk^{\underline i}\binom n k
$$

### 2. 推导$O(m)$表达式

令$x$为自变量，设幂级数$G_i(x)=\sum_{k=0}^n x^kk^{\underline i}\binom n k$，也就是$b$乘上的后面那一坨。如果能列出其封闭形式，我们的问题就解决了。

其实做第一步时，我们会有一个显而易见的疑问：为什么要转化成下降幂？换句话说，为什么要转为下降幂，这一步的合理性在哪里?

让我们先抛开本题，来考虑一个更一般的多项式（准确地来说应该叫幂级数）：
$$
F(x)=\sum_{k\ge 0} f_kx^k
$$
可以发现，如果两边求$i$阶导，下降幂很自然地出现在了求和的式子当中：
$$
\left(\frac {\text{d}} {\text{d}x}\right)^iF(x)=\sum_{k\ge 0} f_kx^{k-i}k^{\underline i}
$$
我们原封不动地把这个操作套到二项式上，那么根据常识：
$$
(1+x)^n=\sum_{k=0}^n x^k\binom nk
$$
两边求$i$阶导后得到：
$$
n^{\underline i}(1+x)^{n-i}=\sum_{k=0}^n x^{k-i}k^{\underline i}\binom nk
$$
其实做到这一步答案已经非常明显，给这个式子两边同时乘以$x^i$即可得到$G_i(x)$的封闭形式。
$$
G_i(x)=x^in^{\underline i}(1+x)^{n-i}
$$

这一步的复杂度是$O(m\log n)$。虽然很容易优化到$O(m)$，但鉴于这不是瓶颈所在，这样做并没有多大意义。

总复杂度是$O(m^2)$。

现在来回答开始那个问题。不难发现，下降幂的引入使得我们目标生成函数的不定积分变得具有封闭形式了（本题中是$(1+x)^n$）。于是自然而然地，我们可以通过对这个封闭形式求导来求得目标生成函数的封闭形式。

值得一提的是，这个操作的普适性非常强。你甚至可以把组合数$\binom n k$换成各种**你喜欢的系数**，只要选取的这些系数的OGF具有比较好的封闭形式，那么就可以用上述方法求解。

```cpp
#include<iostream>
#include<cstdio>
#define FOR(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
const int N=1010;
int n,w,P,m,t,ans,a[N],b[N],s[N][N];
int qpw(int x,int y){int z=1;for(;y;y>>=1,x=1ll*x*x%P)if(y&1) z=1ll*z*x%P;return z;}
int main(){
	scanf("%d%d%d%d",&n,&w,&P,&m);
	FOR(i,0,m) scanf("%d",&a[i]);
	s[0][0]=1;t=1;
	FOR(i,1,m)FOR(j,1,i) s[i][j]=(s[i-1][j-1]+1ll*s[i-1][j]*j)%P;
	FOR(i,0,m)FOR(j,0,i) (b[j]+=1ll*a[i]*s[i][j]%P)%=P;
	FOR(i,0,m) (ans+=1ll*qpw(w,i)*qpw(w+1,n-i)%P*t%P*b[i]%P)%=P,t=1ll*t*(n-i)%P;
	cout<<ans<<'\n';
}
```

### 后记

这题大概本人在考场上做得最顺的一道题了，从开始推式子到过所有样例花费不到$20$分钟。

如果不是这道暖心送分题的存在（对我来说）——考虑到我在其它几道题上的糟糕表现——大概有八成的可能性，我现在已经告别了OI这份事业。

谨以这篇题解，给这道题的出题人点赞。（好像是一年来的第一篇题解）



---

## 作者：Y25t (赞：22)

~~组合题怎么能没有组合意义的证法呢（~~

首先还是常规地把$f(k)$拆开：

$$\sum_{k=0}^nf(k)x^k\binom{n}{k}=\sum_{i=0}^ma_i\sum_{k=0}^nk^ix^k\binom{n}{k}$$

然后证明一个组合恒等式：

$$\sum_{k=0}^nk^ix^k\binom{n}{k}=\sum_{j=0}^in^{\underline{j}}x^j(1+x)^{n-j}\begin{Bmatrix}i\\j\end{Bmatrix}$$

$\square$ 考虑它的组合意义：有$n$个不同的盒子，每个盒子可以染成$x$种不同的颜色，也可以不染。将$i$个不同的球放入这些盒子中有颜色的盒子里，不同的方案个数。

考虑从两个方面计数：

- 先枚举有$k$个盒子被染色（$\binom{n}{k}$），每个盒子有$x$种选择（$x^k$），每个球只能放进这$k$个有色的盒子里（$k^i$），于是总共为：

$$\sum_{k=0}^n\binom{n}{k}x^kk^i=LHS$$

- 先枚举有$j$个盒子放了球（$\binom{n}{j}$），那么这些盒子一定要被染成$x$种颜色之一（$x^j$），剩下$n-j$个不放球盒子可染可不染（$(1+x)^{n-j}$），最后别忘了乘上将$i$个球放入这些盒子的方案数（$S(i,j)j!$，乘上$j!$是因为第二类斯特林数只考虑了盒子之间无序的情况），总共为：

$$\sum_{j=0}^i\binom{n}{j}x^j(i+x)^{n-j}\begin{Bmatrix}i\\j\end{Bmatrix}j=\sum_{j=0}^in^{\underline{j}}x^j(1+x)^{n-j}\begin{Bmatrix}i\\j\end{Bmatrix}=RHS$$

因为这两种是对同一个组合问题的计数，于是$LHS=RHS$。$\blacksquare$

那么原式就变成了：

$$\sum_{k=0}^nf(k)x^k\binom{n}{k}=\sum_{i=0}^ma_i\sum_{j=0}^in^{\underline{j}}x^j(1+x)^{n-j}\begin{Bmatrix}i\\j\end{Bmatrix}$$

把该预处理的预处理一下就能做到$O(m^2)$了。

代码：

```cpp
#include<cstdio>
#define N 1005

int n,x,P,m,a[N];

int s[N][N];

inline int fpow(int y,int k){
	int res=1;
	for(;k;k>>=1,y=1ll*y*y%P)
		if(k&1)
			res=1ll*res*y%P;
	return res;
}

int tmp[N]; 

int ans;

int main(){
	scanf("%d%d%d%d",&n,&x,&P,&m);
	for(int i=0;i<=m;i++)
		scanf("%d",&a[i]);
	s[0][0]=1;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=i;j++)
			s[i][j]=(s[i-1][j-1]+1ll*j*s[i-1][j]%P)%P;
	for(int i=0;i<=m;i++){
		tmp[i]=fpow(x+1,n-i);
		for(int j=i-1;j>=0;j--)
			tmp[j]=1ll*tmp[j+1]*(x+1)%P;
		for(int j=0,t1=1,t2=1;j<=i;j++,t1=1ll*t1*(n-j+1)%P,t2=1ll*t2*x%P)
			ans=(ans+1ll*a[i]*s[i][j]%P*t1%P*t2%P*tmp[j]%P)%P;
	}
	printf("%d",ans);
	
    #define w 0
    return ~~('0')?(0^w^0):(0*w*0);
}
```


---

## 作者：NaCly_Fish (赞：18)

> 组合意义天地灭，代数推导保平安。 

—— tiger0133

提供一种纯代数推导的、时间复杂度 $\Theta(m \log m)$ 的做法（模质数）
    

$$\sum_{k=0}^n \binom nk x^k\sum_{i=0}^ma_ik^i$$
$$=\sum_{i=0}^ma_i\sum_{k=0}^n \binom nk x^kk^i$$
设 $f_i$ 为后面那个和式的值，将常幂展开为下降幂
$$f_i=\sum_{k=0}^n \binom nk x^k\sum_{j=0}^i \begin{Bmatrix} i \\ j \end{Bmatrix}k^{\underline j}$$
$$=\sum_{j=0}^i \begin{Bmatrix} i \\ j \end{Bmatrix}j!\sum_{k=0}^n \binom nk \binom kj x^k$$
$$=\sum_{j=0}^i \begin{Bmatrix} i \\ j \end{Bmatrix} \binom nj j!\sum_{k=0}^n \binom{n-j}{k-j}x^k$$
$$=\sum_{j=0}^i \begin{Bmatrix} i \\ j \end{Bmatrix} n^{\underline j}x^j\sum_{k=0}^{n-j}\binom{n-j}{k}x^{k}$$
$$=\sum_{j=0}^i \begin{Bmatrix} i \\ j \end{Bmatrix}n^{\underline j}x^j(x+1)^{n-j}$$
暴力递推第二类 Stirling 数，可以做到 $\Theta(m^2)$ 的复杂度；若 $p$ 为质数，则可以进一步优化：

设

$$g_j=n^{\underline j}x^j(x+1)^{-j}$$
那么它和 $f_i$ 的关系就是一个 Stirling 变换的形式：

$$f_i=(x+1)^n\sum_{j=0}^i \begin{Bmatrix} i \\ j \end{Bmatrix}g_j$$
设 $f(z)$，$g(z)$ 分别是它们的 EGF，不难得到关系式：
$$f(z)=(x+1)^ng(\text e^z-1)$$
乍一看没法算，但 $g(z)$ 其实是有封闭形式的：
$$g(z)=\sum_{j=0}^\infty n^{\underline j}x^j(x+1)^{-j}\frac{z^j}{j!}$$
$$=\sum_{j=0}^n \binom nj (x(x+1)^{-1}z)^j$$
$$=(x(x+1)^{-1}z+1)^n$$
由此也就得到 $f(z)$：
$$f(z)=(x+1)^n(x(x+1)^{-1}(\text e^z-1)+1)^n$$
$$=(x(\text e^z-1)+x+1)^n$$
$$=(x\text e^z+1)^n$$
多项式快速幂即可，时间复杂度 $\Theta(m \log m)$。  

upd：我 sb 了，根本没必要在 $\Theta(m^2)$ 的基础上推导，可以在原式上直接列出 $f(z)$：
$$f(z)=\sum_{i=0}^\infty\frac{z^i}{i!}\sum_{k=0}^n \binom nk x^kk^i$$
$$=\sum_{k=0}^n \binom nk x^k\sum_{i=0}^\infty \frac{(zk)^i}{i!}$$
$$=\sum_{k=0}^n \binom nk x^k \text e^{zk}$$
$$=\sum_{k=0}^n \binom nk (x\text e^z)^k$$
$$=(x\text e^z+1)^n$$
参考代码：(答案模 $998244353$)
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#define N 262147
#define ll long long
#define reg register
#define p 998244353
using namespace std;

inline int add(const int& x,const int& y){ return x+y>=p?x+y-p:x+y; }
inline int dec(const int& x,const int& y){ return x<y?x-y+p:x-y; }

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

int siz;
int rev[N],rt[N],inv[N],fac[N],ifac[N];

void init(int n){
    int lim = 1;
    while(lim<=n) lim <<= 1,++siz;
    for(reg int i=0;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
    int w = power(3,(p-1)>>siz);
    fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = rt[lim>>1] = 1;
    for(reg int i=(lim>>1)+1;i!=lim;++i) rt[i] = (ll)rt[i-1]*w%p;
    for(reg int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];
    for(reg int i=2;i<=n;++i) fac[i] = (ll)fac[i-1]*i%p;
    ifac[n] = power(fac[n],p-2);
    for(reg int i=n-1;i;--i){
        ifac[i] = (ll)ifac[i+1]*(i+1)%p;
        inv[i] = (ll)fac[i-1]*ifac[i]%p;
    }
}

inline void dft(int *f,int n){
    static unsigned long long a[N];
    reg int x,shift = siz-__builtin_ctz(n);
    for(reg int i=0;i!=n;++i) a[rev[i]>>shift] = f[i];
    for(reg int mid=1;mid!=n;mid<<=1)
    for(reg int j=0;j!=n;j+=(mid<<1))
    for(reg int k=0;k!=mid;++k){
        x = a[j|k|mid]*rt[mid|k]%p;
        a[j|k|mid] = a[j|k]+p-x;
        a[j|k] += x;
    }
    for(reg int i=0;i!=n;++i) f[i] = a[i]%p;
}

inline void idft(int *f,int n){
    reverse(f+1,f+n);
    dft(f,n);
    int x = p-((p-1)>>__builtin_ctz(n));
    for(reg int i=0;i!=n;++i) f[i] = (ll)f[i]*x%p;
}

inline int getlen(int n){
    return 1<<(32-__builtin_clz(n));
}

inline void inverse(const int *f,int n,int *r){
    static int g[N],h[N],st[30];
    memset(g,0,getlen(n<<1)<<2);
    int lim = 1,top = 0;
    while(n){
        st[++top] = n;
        n >>= 1;
    }
    g[0] = 1;
    while(top--){
        n = st[top+1];
        while(lim<=(n<<1)) lim <<= 1;
        memcpy(h,f,(n+1)<<2);
        memset(h+n+1,0,(lim-n)<<2);
        dft(g,lim),dft(h,lim);
        for(reg int i=0;i!=lim;++i) g[i] = g[i]*(2-(ll)g[i]*h[i]%p+p)%p;
        idft(g,lim);
        memset(g+n+1,0,(lim-n)<<2);
    }
    memcpy(r,g,(n+1)<<2);
}

inline void log(const int *f,int n,int *r){
    static int g[N],h[N];
    inverse(f,n,g);
    for(reg int i=0;i!=n;++i) h[i] = (ll)f[i+1]*(i+1)%p;
    h[n] = 0;
    int lim = getlen(n<<1);
    memset(g+n+1,0,(lim-n)<<2);
    memset(h+n+1,0,(lim-n)<<2);
    dft(g,lim),dft(h,lim);
    for(reg int i=0;i!=lim;++i) g[i] = (ll)g[i]*h[i]%p;
    idft(g,lim);
    for(reg int i=1;i<=n;++i) r[i] = (ll)g[i-1]*inv[i]%p;
    r[0] = 0;
}

inline void exp(const int *f,int n,int *r){
    static int g[N],h[N],st[30];
    memset(g,0,getlen(n<<1)<<2);
    int lim = 1,top = 0;
    while(n){
        st[++top] = n;
        n >>= 1;
    }
    g[0] = 1;
    while(top--){
        n = st[top+1];
        while(lim<=(n<<1)) lim <<= 1;
        memcpy(h,g,(n+1)<<2);
        memset(h+n+1,0,(lim-n)<<2);
        log(g,n,g);
        for(reg int i=0;i<=n;++i) g[i] = dec(f[i],g[i]);
        g[0] = add(g[0],1);
        dft(g,lim),dft(h,lim);
        for(reg int i=0;i!=lim;++i) g[i] = (ll)g[i]*h[i]%p;
        idft(g,lim);
        memset(g+n+1,0,(lim-n)<<2);
    }
    memcpy(r,g,(n+1)<<2);
}

inline void power(const int *f,int n,int k,int *r){
    static int g[N];
    memcpy(g,f,(n+1)<<2);
    int u = power(f[0],p-2),v = power(f[0],k);
    for(reg int i=0;i<=n;++i) g[i] = (ll)g[i]*u%p;
    log(g,n,g);
    for(reg int i=1;i<=n;++i) g[i] = (ll)g[i]*k%p;
    exp(g,n,g);
    for(reg int i=0;i<=n;++i) r[i] = (ll)g[i]*v%p;
}

int f[N],a[N];
int n,x,m,ans;

int main(){
    read(n),read(x),read(m);
    for(reg int i=0;i<=m;++i) read(a[i]);
    init(m<<1);
    for(reg int i=0;i<=m;++i) f[i] = (ll)x*ifac[i]%p;
    f[0]++;
    power(f,m,n,f);
    for(reg int i=0;i<=m;++i) ans = (ans+(ll)f[i]*fac[i]%p*a[i])%p;
    printf("%d",ans);
    return 0;   
}
```

---

## 作者：拓拓 (赞：12)

不会下降幂，不会斯特林数，说一个另类的做法。

题目要求求如下内容：

$$ \sum_{k = 0}^nf(k)x^kC_n^k $$

带着 $f(k)$ 不好处理，先把 $f(k)$ 展开为如下内容。

$$ \sum_{k = 0}^n\sum_{i = 0}^ma_ik^ix^kC_n^k $$

$$ = \sum_{i = 0}^ma_i\sum_{k = 0}^nk^ix^kC_n^k $$

那么问题就是求后边那一坨 $\sum$ 了。

直接设 
$$ g_i(x) = \sum_{k = 0}^nk^ix^kC_n^k = \sum_{k = 1}^nk^ix^kC_n^k $$

那么

$$ g_0(x) = (x + 1)^n $$

接下来考虑求 $g_i(x)$ 的递推式，直接对上面第一个式子两边同时求导。

$$ g_i(x)' = \sum_{k = 1}^nk^{i+1}x^{k - 1}C_n^k $$

不难求出递推式：

$$ xg_i(x)' = \sum_{k = 0}^nk^{i+1}x^{k}C_n^k = g_{i+1}(x) $$

设

$$ g^{(n)}_{t}(x) = F[n][t] $$

对递推式求 $n$ 次导可以得到 $F[n][t]$ 的递推式。

$$ F[n][t+1] = xF[n+1][t] + nF[n][t] $$

另外边界为

$$ F[i][0] = \frac{n!}{(n-i)!}(x + 1)^{n-i} $$

$O(m^2)$ 计算就好了。

```cpp
#include <bits/stdc++.h>

const int MAXN = 1e3 + 5;

int n, x, p, m;
int F[MAXN][MAXN];
int a[MAXN];

int FastPow(int a, int b) {
    int res = 1;
    for(; b; b >>= 1, a = 1LL * a * a % p)
        if(b & 1) res = 1LL * res * a % p;
    return res;
}

int main() {
    int res = 0;
    scanf("%d%d%d%d", &n, &x, &p, &m);
    for(int i = 0; i <= m; i++) scanf("%d", a + i);
    for(int i = 0; i <= m; i++) {
        int s = 1;
        for(int j = n - i + 1; j <= n; j++) s = 1LL * s * j % p;
        F[i][0] = 1LL * s * FastPow(x + 1, n - i) % p;
    }
    for(int i = 1; i <= m; i++) {
        for(int j = 0; j <= m - i; j++) {
            F[j][i] = (1LL * x * F[j + 1][i - 1] % p + 1LL * j * F[j][i - 1] % p) % p;
        }
    }
    for(int i = 0; i <= m; i++) res = (res + 1LL * a[i] * F[0][i]) % p;
    printf("%d\n", res);
    return 0;
}
```

---

## 作者：syksykCCC (赞：11)

借鉴了一下 ix35 哥哥的题解 /kel

前置知识：

1. 最基本的组合恒等式

   $$ k \times \binom{n}{k} = n \times \binom{n-1}{k-1} $$
   
   证明：
   
> 两边展开：
> 
> $$ k \times \frac{n!}{k!(n-k)!} = n \times \frac{(n-1)!}{(k-1)!(n-k)!} $$
> 两边同时除以 $k$，同时把右边的 $n$ 移到分子上：
> $$ \frac{n!}{k!(n-k)!} = \frac{n(n-1)!}{k(k-1)!(n-k)!} $$
> 然后发现 $n(n-1)!$ 就是 $n!$，$k(k-1)!$ 就是 $k!$，于是两边就相等了。

2. 二项式定理的特例（即一个数为 $1$）

   $$ (x+1)^n = \sum_{i=0}^{n} \binom{n}{i}\times  x^i $$

   这个过于普及就不证明了……

3. 下降幂的定义:

   $$ n^{\underline{l}} = n(n-1)(n-2) \cdots (n-l+1) $$

首先观察一下题目给的式子，把 $f(k)$ 拆开成若干个单项式之和：

$$ \sum_{k=0}^{n} f(k) \times x^k \times \binom{n}{k}  = a_0 \times \sum_{k=0}^{m} x^k \times \binom{n}{k} + \sum_{i=1}^{m} \left( a_i \times \sum_{k=0}^{n} k^i \times x^k \times \binom{n}{k} \right)$$

这里为啥要把 $a_0$ 单独拉出来后面解释。

现在我们姑且不管外面，来推一下里面这个 $\sum_{k=0}^{n} k^i \times x^k \times \binom{n}{k}$（打个书签，叫做 A）：

首先看到了 $k^i \times \binom{n}{k}$，可以想到组合恒等式，但是这里 $k$ 的指数是 $i$ 而不是 $1$ 就非常棘手，所以考虑把组合恒等式推广一下。

$i=1$ 的时候就是普通的式子，$k \times \binom{n}{k} = n \times \binom{n-1}{k-1}$。

$i=2$ 的时候，可以写作 $k \times \left(k \times \binom{n}{k} \right)$，括号里面这个东西就是 $i=1$ 的情况，带入进来，就是 $k \times \left(n \times \binom{n-1}{k-1}\right)$。

然后……就不会了？

其实发现 $k$ 和 $\binom{n-1}{k-1}$ 没有任何关系，但 $k-1$ 和它是有的（可以重新调用组合恒等式），所以把 $k$ 给拆成 $1+(k-1)$：

$$ (1 + (k-1)) \times n \times \binom{n-1}{k-1} = n \times \binom{n-1}{k-1} + (k-1) \times \left(n \times \binom{n-1}{k-1}\right) $$

上面这一步是小学生都会的乘法结合律。

然后左边那一项没法推了，右边重新使用组合恒等式：

$$ = n \times \binom{n-1}{k-1} + n(n-1) \times \binom{n-2}{k-2} $$

那么 $i=2$ 的情况就推完了，现在瞎猜一个结论，$k^i \times \binom{n}{k} = \sum_{j=1}^{i} n^{\underline{j}} \times \binom{n-j}{k-j}$。

于是……就猜错了（

问题出在 $i=1$ 或 $2$ 时，每一项的系数都为 $1$，而最终的式子每一项肯定是有系数的。

所以再来一遍 $i=3$：

$$ k \left( n \times \binom{n-1}{k-1} + n(n-1) \times \binom{n-2}{k-2} \right) $$

$$ = \left( k \times n \times \binom{n-1}{k-1} + k\times n(n-1) \times \binom{n-2}{k-2} \right) $$

左半边又是和 $i=2$ 的情况一样，代进去：

$$ = \left(\left( n \times \binom{n-1}{k-1} + n(n-1) \times \binom{n-2}{k-2} \right)+ k\times n(n-1) \times \binom{n-2}{k-2} \right) $$

右边类比一下 $i=2$ 的思路，把 $k$ 拆成 $2+(k-2)$：

$$ = \left(\left( n \times \binom{n-1}{k-1} + n(n-1) \times \binom{n-2}{k-2} \right)+ \left(2\times n(n-1) \times \binom{n-2}{k-2} + (k-2) \times n(n-1) \times \binom{n-2}{k-2} \right)\right) $$

然后又可以用一次新的组合恒等式了：

$$ = \left(\left( n \times \binom{n-1}{k-1} + n(n-1) \times \binom{n-2}{k-2} \right)+ \left(2\times n(n-1) \times \binom{n-2}{k-2} + n(n-1)(n-2) \times \binom{n-3}{k-3} \right)\right) $$

推完了，合并同类项，得到：

$$ = n \times \binom{n-1}{k-1} + 3 \times n(n-1) \times \binom{n-2}{k-2} + n(n-1)(n-2) \times \binom{n-3}{k-3}  $$

三项的系数分别为 $1, 3, 1$，印证了我们的猜想。

比方说我们现在把正确的式子写作 $k^i \times \binom{n}{k} = \sum_{j=1}^{i} S(i, j)\times n^{\underline{j}} \times \binom{n-j}{k-j}$，$S(i, j)$ 表示系数，来思考一下 $S(i, j)$ 和什么有关，也就是说，$S(i, j)$ 由哪里来。

回顾 $i=3$ 时候的推导过程，发现对于 $S(i, j)$，它对应的 $n^{\underline{j}} \times \binom{n-j}{k-j}$ 只有两个来源（可以使用举例法，盯着上面式子的 $n(n-1)\times \binom{n-2}{k-2}$看就好了）：

1. 一个是 $S(i-1, j-1)$，这个对应着上面的左半边，会提供倍率为 $1$ 的系数，因为左半边直接展开成 $i-1$ 的样子。

2. 另一个是 $S(i-1, j)$，这个对应着上面的右半边，会提供倍率为 $j$ 的系数，因为右半边是把 $k$ 拆成 $(k-j) + j$，$(k-j)$ 拿去生成新的组合恒等式了，$j$ 乘给老的项。


所以，有：

$$ S(i, j ) = S(i-1, j-1) + j \times S(i-1, j) $$

边界条件为 $S(1, 1) = 1$。

这时，我们也理解了要把 $a_0$ 拉出来的原因：$i=0$ 时根本不成立。

那么，得到 $S(i,j)$ 的递推式后，这部分终于推完了！

现在我们回到 A，可以改写这个式子了：

$$\sum_{k=0}^{n} k^i \times x^k \times \binom{n}{k} = \sum_{j=1}^{i} S(i, j) \times n^{\underline j} \times \sum_{k=j}^{n} x^k \binom{n-j}{k-j}$$

后面这个 $\sum$ 里面的东西可以用一用二项式定理：

$$ \sum_{k=j}^{n} x^k \binom{n-j}{k-j} = x^j \sum_{k=0}^{n-j} x^{k} \binom{n-j}{k} = x^j(x+1)^{n-j} $$

带回原式：

$$ a_0 \times \sum_{k=0}^{n} x^k \times \binom{n}{k} + \sum_{i=1}^{m} \left( a_i \times \sum_{k=0}^{n} k^i \times x^k \times \binom{n}{k} \right)$$

$$ = a_0 \times (x+1)^n + \sum_{i=1}^{m}a_i \times \left(\sum_{j=1}^{i} S(i, j) \times n^{\underline j} \times x^j(x+1)^{n-j}\right) $$

于是就可以做到 $\mathcal O(m^2 \log m)$ 了。

```cpp
#include <cstdio>
using namespace std;
typedef long long LL;
inline LL read()
{
	LL val = 0; char c = getchar();
	while(c < '0' || c > '9') c = getchar();
	while(c >= '0' && c <= '9') { val = val * 10 + (c ^ 48); c = getchar(); }
	return val;
}
const int M = 1005;
LL a[M], n, x, p, m, S[M][M], ans;
inline LL Qpow(LL b, LL c)
{
	LL res = 1;
	while(c)
	{
		if(c & 1) res = res * b % p;
		b = b * b % p;
		c >>= 1;
	}
	return res;
}
int main()
{
	n = read(); x = read(); p = read(); m = read();
	for(int i = 0; i <= m; i++) a[i] = read();
	S[1][1] = 1;
	for(int i = 2; i <= m; i++)
		for(int j = 1; j <= i; j++)
			S[i][j] = ((S[i - 1][j] * j) % p + S[i - 1][j - 1]) % p;
	ans = a[0] * Qpow(x + 1, n) % p;
	for(int i = 1; i <= m; i++)
	{
		LL sum = 0, tmp = n;
		for(int j = 1; j <= i; j++)
		{
			sum = (sum + (S[i][j] * tmp % p * Qpow(x, j) % p * Qpow(x + 1, n - j) % p)) % p;
			tmp = tmp * (n - j) % p;
		}
		ans = (ans + a[i] * sum % p) % p;
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：s_r_f (赞：7)

考场上代码贼长,因为拼了暴力..

这个题需要我们变形一下式子$:$

$ \large \sum_{k=1}^{n} f(k) \times x^k \times \binom{n}{k} $

$ \large = \sum_{i=0}^{m} a_i \sum_{k=0}^{n} k^i \times x^k \times \binom{n}{k} $

我们考虑 $ \large \sum_{k=0}^{n} k^i \times x^k \times \binom{n}{k} $ 是什么东西$.$

考虑组合意义$,$就是在 $n$ 个人中挑选若干个人 $,$ 每选一个人就乘上 $x$ 的权值 $,$ 然后在我选出来的人当中随机打 $i$ 次的所有方案的权值的和 $.$

那么我们就有一个显然的 $dp:$

记$dp_{n,m}$表示有 $n$ 个人 $,$ 我已经打了 $m$ 下的答案$.$

如果我们不选这个人$,$那么对于$dp_{1,0}$有$1$的贡献$.$

如果我们选这个人$,$不论我们打这个人多少次都只有一种方案$,$权值为$x$

所以我们得到了一个式子$:$

$dp_{1,i}=x+[i=0]$

然后我们发现可以把 $dp_n$记成一个 $m$ 次多项式$,$转移就是$dp_{x+y}=$ $dp_{x}$和$dp_y$进行$EGF$卷积的结果$.$

那么我们要求的东西就是 $dp_1$的$n$次幂了$.$

在$P$是质数$($ 可以求逆 $)$ 的情况下可以做到 $O(mlogm),$

在不能求逆的时候只能$O(m^2)$卷积做,复杂度是 $O(m^2logn).$

-----

## $upd$ $on$ $2020.6.23:$

因为鱼鱼在讨论区问了，那我就解释一下 $O(mlogm)$ 的做法$.$

首先$dp_{1,i}=x+[i=0],$然后我们把 $dp_x$ 看成一个多项式

因为人是有区别的$,$所以是$EGF.$

然后就是求 $1+$ 读入的$x$ $\times$ $\sum_{i=0}^{m} x^i$ 的快速幂了$.$

记卷积出来的结果为 $\sum_{i=0}^{m}b_ix^i,$则答案为 $\sum_{i=0}^{m}a_ib_i.$

## $upd2:$

$O(mlogm)$的做法是多项式 $Exp$ 求 $n$ 次幂 $.$

----

$O(m^2logn)$代码 $:$ $($ 写的比较丑$,$常数很大$,$勿喷 $)$

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
inline int read(){
	static int x,f; static char c; x = 0,f = 1,c = getchar();
	while (!isdigit(c)){ if (c == '-') f = -1; c = getchar(); }
	while (isdigit(c)) x = x * 10 + c - '0',c = getchar();
	return x * f;
}
int P;
inline int power(int x,LL y){
	static int r; r = 1; while (y){ if (y&1) r = (LL)r * x % P; x = (LL)x * x % P,y>>=1; } return r;
}
int n,x,m,a[1050],C[1050][1050];
struct FF{
	int A[1050];
};
FF operator * (FF A,FF B){
	static FF tmp;
	int i,j;
	for (i = 0; i <= m; ++i) tmp.A[i] = 0;
	for (i = 0; i <= m; ++i)
	for (j = 0; j <= i; ++j) tmp.A[i] = (tmp.A[i] + 1ll * A.A[j] * B.A[i-j] % P * C[i][j]) % P;
	return tmp;
}

FF data[40];
FF F1;
FF A0,A1,A2,B0,B1,B2;
FF an;
int main(){
	int i,j;
	freopen("problem.in","r",stdin); freopen("problem.out","w",stdout);
	n = read(),x = read(),P = read(),m = read();
	for (i = 0; i <= m; ++i) a[i] = read();
	for (i = 0; i <= 1000; ++i) for (j = 0; j <= i; ++j) C[i][j] = (!i || !j) ? (1%P) : ((C[i-1][j-1]+C[i-1][j])%P);
	for (i = 0; i <= m; ++i) F1.A[i] = (x + (i==0?1:0)) % P;
	A0 = F1,A1 = A0 * F1,A2 = A1 * F1;
	data[0] = F1;
	for (i = 1; i <= 32; ++i){
		data[i] = A1;
		B0 = A0 * A1,B1 = A1 * A1,B2 = A1 * A2;
		A0 = B0,A1 = B1,A2 = B2;
	}
	an = F1,--n;
	for (i = 0; i <= 32; ++i){
		if (n % 2 == 1) an = an * data[i];
		n >>= 1;
	}
	int ans = 0;
	for (i = 0; i <= m; ++i) ans = (ans + (LL)a[i] * an.A[i]) % P;
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：Karry5307 (赞：7)

### 题意

给定 $n,x,p,m$，和 $m$ 次多项式 $f$，求

$$\sum\limits_{k=0}^{n}f(k)x^k\binom{n}{k}$$

答案对 $p$ 取模，**不保证 $p$ 是质数**。

$\texttt{Data Range:}1\leq n,x,p\leq 10^9,0\leq a_i\leq 10^9,0\leq m\leq \min(n,10^3)$

### 题解

场外选手来写个题解。

定位是一道送分题。

首先考虑展开多项式

$$\sum\limits_{k=0}^{n}\sum\limits_{i=0}^{m}a_ik^ix^k\binom{n}{k}$$

然后提出一些无关的项

$$\sum\limits_{i=0}^{m}a_i\sum\limits_{k=0}^{n}k^ix^k\binom{n}{k}$$

现在的瓶颈就在于后面那个和式。

考虑生成函数

$$(1+x)^n=\sum\limits_{k=0}^{n}x^k\binom{n}{k}$$

长得很像，但是为了凑 $k^i$ 我们对这个式子进行降维打击，也就是求 $i$ 阶导然后再乘个 $x^i$

$$x^in^{\underline{i}}(1+x)^{n-i}=\sum\limits_{k=0}^{n}k^{\underline{i}}x^k\binom{n}{k}$$

注意到等式右侧是下降幂多项式，然而我们有一个结论可以把普通单项式转为下降幂多项式：

$$x^n=\sum\limits_{k=0}^{n}\begin{Bmatrix}n\\k\end{Bmatrix}x^{\underline{k}}$$

然后暴力带入上述式子

$$\sum\limits_{k=0}^{n}k^{i}x^k\binom{n}{k}=\sum\limits_{k=0}^{n}\sum\limits_{j=0}^{i}\begin{Bmatrix}i\\j\end{Bmatrix}k^{\underline{j}}x^k\binom{n}{k}$$

把一堆无关东西提出来后套之前推的式子

$$\sum\limits_{k=0}^{n}k^{i}x^k\binom{n}{k}=\sum\limits_{j=0}^{i}\begin{Bmatrix}i\\j\end{Bmatrix}x^jn^{\underline{j}}(1+x)^{n-j}$$

然后拆下降幂

$$\sum\limits_{k=0}^{n}k^{i}x^k\binom{n}{k}=\sum\limits_{j=0}^{i}\begin{Bmatrix}i\\j\end{Bmatrix}j!\binom{n}{j}x^j(1+x)^{n-j}$$

所以答案为

$$\sum\limits_{i=0}^{m}a_i\sum\limits_{j=0}^{i}\begin{Bmatrix}i\\j\end{Bmatrix}j!\binom{n}{j}x^j(1+x)^{n-j}$$

由于 $m\leq 10^3$，所以可以预处理斯特林数，组合数边枚举 $j$ 边处理，并且处理一下阶乘，$x$ 和 $1+x$ 的幂即可 $O(m^2)$。

代码到时候再放，拍了几万组数据感觉是稳的。



---

## 作者：Werner_Yin (赞：5)

## 题目

计算 $\left(\sum\limits_{k=0}^n f(k) \times x^k \times \dbinom{n}{k}\right)\bmod p$ ， $f(k) = \sum\limits_{i=0}^m a_i \times k^i$  , $n,k,p,m,a_i$ 给定。

## 前言

[更好的阅读体验](https://www.cnblogs.com/werner-yin/p/solution-P6620.html)

前几天考了一道类似的题目，当时本蒟蒻考场自闭，考后，听说有此题，便做了一下，因为我比较菜，所以这篇题解主要以一个不会多项式（虽然此题不要）、没怎么推过式子的蒟蒻角度做题。

### 前置基础

1.会组合数的定义，**知道**其性质，怎么求

2.**了解**斯特林数，会它的通项公式，一些小性质就行了

3.知道二项式定理（认得长什么样就行了）

（这些东西具体性质后面会讲，会解释，只要了解就可以继续看下去了）

## 思路

先合并成一个式子：

$\left(\sum\limits_{k=0}^n \sum\limits_{i=0}^m a_i \times k^i\times x^k \times \dbinom{n}{k}\right)\bmod p$ 。

我们再看一下数据范围

> $n \in [1,10^9],k \in[0,n], m \in [0,min(n,1000)]$ 

那么，我们**一定**不能去暴力算 $k$ ，我们要想办法将有关 $k$ 的项全部变成 与 $m$ （或和 $m$ 一样小的） 有关的项。

> $p$ 不一定是质数

~~这题很可能不是多项式~~

因为 $n$ 很大，我们只能处理出 $k!\bmod p$ 和 $k!$ 在 $p$ 下的逆元（这是一种组合数的求法）。但 $p$ 不是质数，有的数没有逆元，我们就要想办法除去组合数。（这里可能有点不严谨，但反正很难求出这个组合数）

综上，

我们有两个目标：

##### 目标一

将有关 $k$ 的项全部变成 与 $m$ （或和 $m$ 一样小的） 有关的项。

##### 目标二

除去组合数

## 具体步骤

$\left(\sum\limits_{k=0}^n \sum\limits_{i=0}^m a_i \times k^i\times x^k \times \dbinom{n}{k}\right)\bmod p$ 

##### 对于目标一

$k^i$ 最难搞，我们先消去 $k^i$ ，这里要用第二类斯特林数，$\left\{_m^n \right\}$ 代表 $n$ 个球放入 $m$ 个集合中的方案数。

$k^i = \sum\limits_{j = 0}^k \left\{^i_j\right\} \dbinom{k}{j}j!$

考虑组合意义： $k^i$ 代表将$i$ 个球放入$k$ 个互不相同盒子中（可以为空），

我们这个展开就是先讨论要将这些球放入$j$ 个相同盒子中（不能为空），即选盒子的方案数乘上将球放入这些盒子的方案数： $\left\{^i_j\right\} \dbinom{k}{j}$ ，

又因为我们要求的是不同的盒子中，我们再乘上一个 $j!$。

值得注意的是，当 $j > i$ 时， $\left\{^i_j\right\}$  没有意义，为了~~不择手段地~~ 消去 $k$ ,我们可以将求和上界改为 $i$ ：

$k^i = \sum\limits_{j = 0}^i \left\{^i_j\right\} \dbinom{k}{j}j!$

至于 $x^k$ 这样展开复杂了，我们先放到一边。

##### 对于目标二

我们的式子已经变成了：

$\left(\sum\limits_{k=0}^n \sum\limits_{i=0}^m a_i \times \sum\limits_{j = 0}^i \left\{^i_j\right\} \dbinom{k}{j}j!\times x^k \times \dbinom{n}{k}\right)\bmod p$

我们可以看到有两个组合数：

$\dbinom{k}{j} \times \dbinom{n}{k}$ 

再次考虑组合意义：

先从 $n$ 个球中选出 $k$ 个球，再从中选出 $j$ 个球，

这就等价于 

先选出 $j$ 个球作为最后的方案，再从选 $n-j$ 个球中选出 $k-j$ 个球作为第一次还要选的球，

所以，

$\dbinom{k}{j} \times \dbinom{n}{k} = \dbinom{n-j}{k-j} \times \dbinom{n}{j}$ 

但是组合数还是没有消失，我们的式子变成了：

$\left(\sum\limits_{k=0}^n \sum\limits_{i=0}^m a_i \times \sum\limits_{j = 0}^i \left\{^i_j\right\}  \dbinom{n-j}{k-j} \times \dbinom{n}{j}j!\times x^k \right)\bmod p$

调一下顺序：

$\left( \sum\limits_{i=0}^m a_i\sum\limits_{j=0}^i\left\{^i_j\right\}\times\dbinom{n}{j}j!\times \sum\limits_{k=0}^n\dbinom{n-j}{k-j}x^k \right)\bmod p$

接下来，非常重要，

观察到

$\dbinom{n-j}{k-j}x^k$

我们知道二项式定理：

$(x+y)^n = \sum\limits_{i =0}^n \dbinom{n}{i}\times x^i y^{n-i}$ ,那么，我们可以尽量让上面的式子变为二项式定理，

如果是这样就好了：

$\sum\limits_{k=0}^n\dbinom{n-j}{k-j}x^{k-j} = (x+1)^{n-j}$ (二项式定理)

那我们就强行补一下：

$\sum\limits_{k=0}^n\dbinom{n-j}{k-j}x^{k} = \sum\limits_{k=0}^n\dbinom{n-j}{k-j}x^{k-j}\times x^j = (x+1)^{n-j}\times x^j$

原式简单多了：

$\left( \sum\limits_{i=0}^m a_i\sum\limits_{j=0}^i\left\{^i_j\right\}\times\dbinom{n}{j}j!\times (x+1)^{n-j}\times x^j \right)\bmod p$ 

离目标最后一步！

$\dbinom{n}{j}j! = \frac{n!}{j!\times(n-j)!}\times j! = \frac{n!}{(n-j)!} = n \times (n-1) \times \dots\times(n-j+1)$ 

因为 $j$ 十分小，我们就可以再循环的时候一边计算这个式子就行了。

答案：

$\left( \sum\limits_{i=0}^m a_i\sum\limits_{j=0}^i\left\{^i_j\right\}\times\frac{n!}{(n-j)!}\times (x+1)^{n-j}\times x^j \right)\bmod p$ ，

我们只要 $O(k^2)$ 推斯特林数就行了，其他项在循环时可以算出来。

代码

```cpp
const int MAXN = 5010;

typedef long long ll;

ll a[MAXN],strling[MAXN][MAXN],n,x,p,m,x1j[MAXN];

ll qp(ll x,ll t){
    ll res = 1;
    for(;t;t >>=  1,x = x*x%p){
	if(t&1) res = res * x % p;
    }
    return res;
}

int main (){
    scanf("%lld %lld %lld %lld",&n,&x,&p,&m);
    for(int i = 0;i <= m;i++) scanf("%lld",&a[i]);
    strling[0][0] =  1;
    for(int i = 1;i <= m;i++)
	for(int j = 1;j <= i;j++)
	    strling[i][j] = (strling[i-1][j-1] + strling[i-1][j] * j %p)%p;
    //斯特林数
    ll ans = 0;
    for(int i = 0;i <= m;i++){
		ll tot = 0;
		ll fac = 1ll,xj = 1ll;
		x1j[i] = qp(x+1,n-i);
		for(int j = i-1;j >= 0;j--){
		    x1j[j] = x1j[j+1] * (x+1) % p;
		}//循环时处理 (x+1)^{n-j},n * (n-1) *...*(n-j+1)
		for(int j = 0;j <= i;j++){
		    tot = (tot + strling[i][j] * fac % p* xj % p*x1j[j]%p)%p;
		    fac = fac * (n-j)%p;
		    xj = xj*x%p;
		}
		tot = tot * a[i]%p;
		ans = (ans + tot)%p;
    }
    printf("%lld\n",ans);
    return 0;
}
```



---

## 作者：81179332_ (赞：5)

不知道为什么，考场上压根没想到斯特林数

我们单独考虑 $f(k)$ 的每一个单项式

$a_0$ 项：$a_0\sum\limits_{k=0}^n x^k\dbinom{n}{k}=(x+1)^n$

$a_1$ 项：
$a_1\sum\limits_{k=0}^nk\cdot x^k\dbinom{n}{k}$

$\ \ \ \ \ \ \ \ =a_1\sum\limits_{k=1}^nk\cdot x^k\dbinom{n}{k}$

$\ \ \ \ \ \ \ \ =a_1x\sum\limits_{k=1}^nk\cdot x^{k-1}\dbinom{n}{k}$

发现什么了嘛？设 $g(i)=\sum\limits_{k=0}^n k^i\cdot x^k\dbinom{n}{k}$，则 $g(i)=x\cdot g'(i-1)$

则 $g(1)=x\cdot g'(0)=x\cdot [(x+1)^n]'=xn(x+1)^{n-1}$

但是我们接着求 $g(2)$ 就会出问题，因为 $g(1)$ 长得并不像很好求导的样子

所以我们改写一下，$g(1)=(x+1)n(x+1)^{n-1}-n(x+1)^{n-1}=n(x+1)^n-n(x+1)^{n-1}$

虽然还是没有什么规律可以直接得出 $g(i)$，但这种形式中只存在 $(x+1)^?$ 的形式，而这个是可以直接模拟求导过程的

最后答案为：$\sum\limits_{i=0}^m a_0\cdot g(i)$

具体实现中，我用 $c_i$ 表示 $(x+1)^{n-i}$ 的系数，由于只有 $m$ 次求导，所以 $0\le i\le m$，预处理 $t_i$ 表示 $(x+1)^{n-i}$，可以做到 $O(m^2)$

```cpp
const int M = 1010;
int n,x,m;
ll a[M],c[M],t[M];
int main()
{
	n = read(),x = read(),mod = read(),m = read();
	for(int i = 0;i <= m;i++) a[i] = read();
	ll ans = 0;
	c[0] = 1;//(x+1)^n系数为1
	for(int i = 0;i <= m;i++) t[i] = qpow(x + 1,n - i);
	for(int i = 0;i <= m;i++)
	{
		for(int j = 0;j <= m;j++)
			ans = (ans + a[i] * t[j] % mod * c[j]) % mod;//计算答案
		for(int j = m;j;j--)
			c[j] = c[j - 1] * (n - j + 1) % mod;//就是普通的求导
		c[0] = 0;//上面为了防止越界没有处理c[0]
		for(int j = 1;j <= m;j++)
			c[j - 1] = Mod(c[j - 1] + c[j]),c[j] = mod - c[j];//乘 x
    }
    fprint(ans);
}
```

---

## 作者：orecic (赞：5)

我们只需要对$\ y,y \in [0,m]$求出$\ \sum\limits_{k=0}^{n}k^{y} x^{k} \binom{n}{k} $


我们设：
$$
g(n,y,t)=\sum_{k=0}^{n} (k+t)^{y} x^{k} \binom{n}{k}
$$
显然：

$$
\begin{array}{rcl}
g(n,y,t) & = & \sum\limits_{k=0}^{n} (k+t)^{y} x^{k} \binom{n}{k}\\
& = & \sum\limits_{k=0} k \cdot (k+t)^{y-1} x^{k} \binom{n}{k} + t\sum\limits_{k=0}^{n}(k+t)^{(y-1)} x^{k} \binom{n}{k} \\
& = & n \sum\limits_{k=1}^{n}  (k+t)^{y-1} x^{k} \binom{n-1}{k-1} + t \cdot g(n,y-1,t) \\
& = & n \cdot x \sum\limits_{k=0}^{n-1}(k+1+t)^{y-1} x^{k} \binom{n-1}{k} +t \cdot g(n,y-1,t) \\
& = & n \cdot x \cdot g(n-1,y-1,t+1) + t \cdot g(n,y-1,t)
\end{array}
$$
$\ y=0$时：
$$
g(n,y,t)=(x+1)^{n}
$$


容易发现状态只有$\ m^{2}$级别，记忆化即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
	int x=0,f=1;
	char ch;
	ch=getchar();
	while((ch<'0')||(ch>'9'))
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while((ch>='0')&&(ch<='9'))
	{
		x=((x<<3)+(x<<1))+(ch-'0');
		ch=getchar();
	}
	return x*f;
}
int mod,n,x,m;
int a[1010];
inline int poww(int a,int b)
{
	int res=1;
	while(b)
	{
		if(b&1) res=res*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return res;
}
namespace part4
{
	int g[1010][1010],vis[1010][1010];
	inline int gg(int n,int y,int k)
	{
		if(vis[y][k]) return g[y][k];
		if(y==0)
		{
			int res=poww((x+1)%mod,n);
			g[y][k]=res;
			vis[y][k]=1;
			return res;
		}
		int res=0;
		res+=n*x%mod*gg(n-1,y-1,k+1)%mod;
		res%=mod;
		if(k>0) res+=k*gg(n,y-1,k)%mod;
		res%=mod;
		vis[y][k]=1;
		g[y][k]=res;
		return res;
	}
	inline void solve()
	{
		memset(vis,0,sizeof(vis));
		memset(g,0,sizeof(g));
		int i=0,ans=0;
		while(i<=m)
		{
			ans+=a[i]*gg(n,i,0)%mod;
			ans%=mod;
			++i;
		}
		printf("%lld\n",ans);
	}
}
signed main()
{
//	freopen("problem.in","r",stdin);
//	freopen("problem.out","w",stdout);
	n=read();
	x=read();
	mod=read();
	m=read();
	int i=0;
	while(i<=m)
	{
		a[i]=read();
		++i;
	}
	part4::solve();
	return 0;
} 
```


---

## 作者：Tony102 (赞：4)

# Luogu6620 [省选联考 2020 A 卷] 组合数问题

[Link](https://www.luogu.com.cn/problem/P6620)

一道题目=解锁$inf$知识点

**[更好的阅读体验](https://tony102.xyz/index.php/2020/10/15/luogu6620-%e7%9c%81%e9%80%89%e8%81%94%e8%80%83-2020-a-%e5%8d%b7-%e7%bb%84%e5%90%88%e6%95%b0%e9%97%ae%e9%a2%98/)**

### 前置知识

**下降幂**:

$$n^{\underline k} = \binom{n}{k}*k!$$



**二项式定理**：

$$(x+y)^{n} = \sum_{k=0}^{n} \binom{n}{k} x^{x-k}y^{k}$$

并且我们注意到当$y=1$时，$(x+1)^n = \sum_{k=0}^{n} \binom{n}{k} a^{n-k} $



**第二类斯特林数**：$S(n,k) = S(n - 1,k-1) + k * S(n-1,k)$



**重要等式**

$$\binom{n}{m} = \binom{n}{n - m}$$

$$x^k = \sum_{i=0}^{k} \binom{x}{i} * S(k,i) * i!$$

解释：$x^k$相当于把$k$个小球放进$x$个盒子里（允许空盒），那么方案就是枚举不空的盒子个数 × 小球放进去的方案数 × 盒子标号不同（不懂就私聊



### Sol

解决完以上前置知识，我就花了小半小时（菜

看题目要我们解决的式子：

$$\sum_{k = 0}^{n} f(k)*x^k*\binom{n}{k}$$

$f(k)$是一个$m$次多项式，我们可以写成：

$$\sum_{k=0}^{n} \sum_{i=0}^{m} a_{i} * k^{i}  * \binom{n}{k} * x^{k}$$

把$k^i$用上面的恒等式替换

$$\sum_{k=0}^{n} \sum_{i=0}^{m} a_{i} * \sum_{p=0}^{i} S(i,p) * \binom{k}{p} * p! * \binom{n}{k} * x^k$$

观察到$\binom{k}{p}$和$\binom{n}{k}$两项拆成阶乘形式：

$$\frac{k!}{p!(k-p)!} * \frac{n!}{k!(n-k)!}$$  

同时消去$k!$，再同乘$\frac{(n-p)!}{(n-p)!} = 1$等式仍然成立：

$$\frac{n! (n-p)!}{p!(n-p)!(n-k)!(n-p)!} = \binom{n}{p}*\binom{n-p}{k-p}$$

所以此时式子变成了：

$$\sum_{k=0}^{n} \sum_{i=0}^{m} a_{i} * \sum_{p=0}^{i} S(i,p) * \binom{n}{p} * \binom{n-p}{k-p} * p! * x^k$$

我们将所有的求和限制提前，并且对每一项的顺序稍作改变：

$$\sum_{k=0}^{n} \sum_{i=0}^{m} \sum_{p=0}^{i} \binom{n-p}{n-k} * x^k * a_i * S(i,p) * p! * \binom{n}{p}$$

对二项式定理上面那个等式熟悉的话，我们感觉$\binom{n-p}{n-k}$和$x^k$可以合并。我们需要将$x$的指数稍作修改

$$\sum_{k=0}^{n} \sum_{i=0}^{m} \sum_{p=0}^{i} \binom{n-p}{n-k} * x^{k-p} * x^p * a_i * S(i,p) * p! * \binom{n}{p}$$

此时可以合并

$$\sum_{i=0}^{m} \sum_{p=0}^{i} (x+1)^{n-p} * x^p * a_i * S(i,p) * p! * \binom{n}{p}$$

至此，$(x+1)^{n-p}$和$x^p$两项均可通过快速幂计算，第二类斯特林数通过$O(m^2)$打表，$p!$和$\binom{n}{p}$可以一起计算

没了



### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int SIZE = 1e3 + 5;

int n, x, p, m;
int a[SIZE], frac[SIZE], s[SIZE][SIZE];

inline int read()
{
	char ch = getchar();
	int f = 1, x = 0;
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + ch - '0'; ch = getchar(); }
	return x * f;
}

inline int qPow(int a, int b)
{
	int ans = 1;
	while (b) {
		if (b & 1) ans = ans * a % p;
		a = a * a % p;
		b >>= 1;
	}
	return ans % p;
}

signed main()
{
	n = read(), x = read(), p = read(), m = read();
	for (int i = 0; i <= m; ++ i) a[i] = read();
	s[0][0] = 1;
	for (register int i = 1; i <= m; ++ i) {
		for (register int j = 1; j <= i; ++ j) 
			s[i][j] = (s[i - 1][j - 1] + 1ll * j * s[i - 1][j] % p) % p;
	}
	int ans = 0;
	for (register int i = 0; i <= m; ++ i) {
		frac[i] = qPow(x + 1, n - i);
		for (register int j = i - 1; j >= 0; -- j)
			frac[j] = frac[j + 1] * (x + 1) % p;
		for(register int j = 0, val1 = 1, val2 = 1; j <= i; ++ j, val1 = 1ll * val1 * (n - j + 1) % p, val2 = 1ll * val2 * x % p)
			ans = (ans + 1ll * a[i] * s[i][j] % p * val1 % p * val2 % p * frac[j] % p) % p;
	}
	printf("%lld\n", ans % p);
	return 0;
}
```




---

## 作者：1saunoya (赞：4)

$f(k) = \sum_{i=0}^m a_ik^i$。

$\sum_{k=0}^n \sum_{i=0}^{m}a_i \times k^i\times \binom{n}{k} \times x^k$

$=\sum_{k=0}^n x^k\sum_{i=0}^m a_i \times \sum_{j=0}^{i} \begin{Bmatrix}i\\j\end{Bmatrix} j! \binom{k}{j} \times \binom{n}{k}$

$=\sum_{k=0}^n x^k\sum_{i=0}^m a_i \times \sum_{j=0}^{i} \begin{Bmatrix}i\\j\end{Bmatrix} j! \binom{n}{j} \times \binom{n-j}{k-j}$

$=\sum_{i=0}^m a_i \times \sum_{j=0}^{i} \begin{Bmatrix}i\\j\end{Bmatrix} j! \binom{n}{j} \times \sum_{k=0}^{n-j} x^{k+j} \binom{n-j}{k}$

$=\sum_{i=0}^m a_i \times \sum_{j=0}^{i} \begin{Bmatrix}i\\j\end{Bmatrix} j! \binom{n}{j} \times x^j \sum_{k=0}^{n-j} x^{k} \binom{n-j}{k}$

$=\sum_{i=0}^m a_i \times \sum_{j=0}^{i} \begin{Bmatrix}i\\j\end{Bmatrix} j! \binom{n}{j} \times x^j (1+x)^{n-j}$

$=\sum_{i=0}^{m} a_i \times \sum_{j=0}^{i} \begin{Bmatrix}i\\j\end{Bmatrix} n^{\underline{j}} \times x^j (1+x)^{n-j}$

处理出来斯特林数然后暴力做即可。

以下是上面一些结论的证明。

$x^k = \sum_{i}^k\begin{Bmatrix}k\\i\end{Bmatrix} i! \binom{x}{i}$。

证明:$x^k$ 的组合意义是有 $k$ 可以放进 $x$ 个集合里（允许集合为空），方案数。

右边的斯特林数表示的是 $k$ 划分成 $i$ 个非空集合的方案数，但是没有注意到集合之间的顺序，所以乘上一个 $i!$，因为 $i$ 个集合是可以从 $x$ 里面选的，那么是可以直接乘上 $\binom{x}{i}$ 的。

$\binom{n}{m} \times \binom{m}{k} = \binom{n}{k} \times \binom{n-k}{m-k}$

证明:

$\binom{n}{m}$ 表示的是 $n$ 选 $m$ 个。

$\binom{m}{k}$ 表示的是 $m$ 选 $k$ 个。

那么 $\binom{n}{m}$  $\binom{m}{k}$ 等价于先从$n$个里面选出$m$个，然后从这$m$个选$k$个。
考虑每个大小为$k$的子集被计算的个数，这个对于每个大小为$k$的子集都是相同的。
考虑钦定这个大小为$k$的子集，那你可以任选的部分是 $\binom{n-k}{m-k}$，由于可以钦定大小为$k$的子集，那么乘上$\binom{n}{k}$。

二项式定理: $(x+y)^n = \sum_{i}^{n} x^i y^{n-i} \binom{n}{i}$ 懒得证明了。


---

## 作者：StudyingFather (赞：4)

本题要求我们求出：

$$
\sum_{k=0}^{n}f(k)\times x^k\times \binom{n}{k}
$$

其中 $f(k)$ 为一个次数为 $m$ 的普通多项式 $\sum_{i=0}^m a_ix^i$。

在介绍解法之前，我们先给出若干定义和引理（熟悉的同学可直接跳过这些内容）：

**定义 $1$**：定义 $x$ 的 $k$ 次**下降幂** $x^{\underline{k}}=\dfrac{x!}{(x-k)!}$，这也被称为一个关于 $x$ 的**下降幂单项式**。

**定义 $2$**：定义**下降幂多项式**为有限多下降幂单项式的和，形如 $\sum_{i=0}^k a_ix^{\underline{i}}$。与之相对应的是，形如 $\sum_{i=0}^k a_ix^i$ 的多项式，我们称为**普通多项式**。

**定义 $3$**：我们定义**第二类斯特林数** $\begin{Bmatrix}n\\m\end{Bmatrix}$ 为将 $n$ 个完全相同的元素，不重不漏地划分成 $m$ 个集合的方案数。

说完了定义，我们接下来给出若干引理和定理：

**定理 $0$**（二项式定理）：$(x+y)^k=\sum_{i=0}^k \binom{k}{i}x^iy^{k-i}$。

考虑组合意义即可得证。

**定理 $1.1$**：$m \times \binom{n}{m}=n \times \binom{n-1}{m-1}$。

高中学过组合数学的同学可能都熟悉这个性质。只需将两边的组合数全部展开为阶乘形式即可得证。

事实上上面这个定理可以进一步推广到下降幂的情形（也就是下面的 **定理 $1.2$**）：

**定理 $1.2$**：$m^{\underline{k}} \times \binom{n}{m}=n^{\underline{k}} \times \binom{n-k}{m-k}$。

证明仍然是直接展开等式两边，这里略去。

**引理 $1$**：$x^k=\sum_{i=0}^k \begin{Bmatrix}k\\i\end{Bmatrix} x^{\underline{i}}$。

证明从略。

利用这个引理，我们可以给出普通多项式转化为下降幂多项式的方法（也就是下面的 **定理 $2$**）：

**定理 $2$**：记普通多项式 $f(x)=\sum_{i=0}^k a_ix^{i}$，下降幂多项式 $g(x)=\sum_{i=0}^k b_ix^{\underline{i}}$，且 $f(x)=g(x)$，则有 $b_i=\sum_{j=i}^k \begin{Bmatrix}j\\i\end{Bmatrix}a_j$。

证明考虑根据 **引理 $1$** 将普通多项式展开：

$$
\begin{aligned}
\sum_{i=0}^k a_ix^i &= \sum_{i=0}^k a_i \sum_{j=0}^i \begin{Bmatrix}i\\j\end{Bmatrix} x^{\underline{j}}\\ 
 &= \sum_{i=0}^k x^{\underline{i}}\sum_{j=i}^k \begin{Bmatrix}j\\i\end{Bmatrix} a_j
\end{aligned}
$$

**定理 $3$**（第二类斯特林数递推公式）：$\begin{Bmatrix}n\\m\end{Bmatrix}=m\times \begin{Bmatrix}n-1\\m\end{Bmatrix}+\begin{Bmatrix}n-1\\m-1\end{Bmatrix}$

还是考虑组合意义：对于每个新增的元素，我们可以将其放在原有的集合中，或者是单独安排一个集合。

利用该定理，我们可以在 $O(n^2)$ 时间内递推出我们需要的第二类斯特林数的值。

接下来进入正题。

我们发现一个普通多项式与组合数相乘并没有什么显然的性质，而定理 $1.2$ 则告诉了我们下降幂多项式与组合数相乘的性质。因此考虑根据 **定理 $2$**，将普通多项式 $f(x)=\sum_{i=0}^k a_ix^{i}$ 转化为下降幂多项式 $g(x)=\sum_{i=0}^k b_ix^{\underline{i}}$。

也就是说我们所求变成了：

$$
\sum_{k=0}^{n}g(k)\times x^k\times \binom{n}{k}
$$

现在利用 **定理 $1.2$** 改写上式：

$$
\begin{aligned}
\sum_{k=0}^{n}g(k)\times x^k\times \binom{n}{k} &= \sum_{k=0}^{n}\sum_{i=0}^m b_i \times k^{\underline{i}}\times x^k\times \binom{n}{k}\\
 &= \sum_{k=0}^{n}x^k\sum_{i=0}^m b_i \times n^{\underline{i}} \times \binom{n-i}{k-i}\\
 &= \sum_{i=0}^{m}b_i \times n^{\underline{i}} \sum_{k=0}^n \binom{n-i}{k-i} x^k\\
\end{aligned}
$$

注意到只有 $k-i \geq 0$ 的时候才会对答案产生贡献，考虑枚举 $k-i$ 的值，为了避免混淆，令 $k'=k-i$：

$$
\begin{aligned}
\sum_{i=0}^{m}b_i \times n^{\underline{i}} \sum_{k'=0}^{n-i} \binom{n-i}{k'} x^{k'+i} &= \sum_{i=0}^{m}b_i \times n^{\underline{i}} \times x^i \sum_{k'=0}^{n-i} \binom{n-i}{k'} x^{k'}\\
 &= \sum_{i=0}^{m}b_i \times n^{\underline{i}} \times x^i \times (x+1)^{n-i}
\end{aligned}
$$

最后一步推导实际上就是二项式定理的逆用。

到这里本题就做完了。

上式可以 $O(m)$ 来计算，而本题时间瓶颈主要在递推求第二类斯特林数上，这部分的时间复杂度为 $O(m^2)$。

代码这里就不给了。

---

## 作者：Mr_Wu (赞：4)

场外选手来胡一个？代码只验证了大样例。。

### 题意

给定 $m$ 次多项式 $f(x)$，求
$$
\left(\sum_{k=0}^n f(k)\times x^k\times \binom{n}{k} \right) \bmod p
$$
数据范围：$1\le n,x,p\le 10^9, 0\le a_i\le 10^9, 0\le m\le \min(n,1000)$。

### 闲话

这题如果 $p=998244353$ 实际上我们有一个 $O(m\log m)$ 的做法：

$$\sum_{k=0}^n \sum_{i=0}^m a_ik^i x^k \binom{n}{k}=\sum_{i=0}^m a_i \sum_{k=0}^n k^ix^k\binom{n}{k}$$

考虑后面一串的指数生成函数

$$ \sum_{i\ge 0} \frac{x^i}{i!} \sum_{k=0}^n k^iX^k\binom{n}{k}
= \sum_{k=0}^n (e^xX)^k\binom{n}{k} = (Xe^x+1)^n $$

但现在 $p$ 甚至质数都不是，所以只能 $O(m^2\log n)$ 求这玩意咯（当然如果你用快速幂+任意模数ntt。。）

### 题解

事实上我们采用的是通常幂转下降幂：

$$
\begin{aligned}
\sum_{k\ge 0} \sum_{i=0}^m a_ik^ix^k\binom{n}{k}&=\sum_{i=0}^m a_i \sum_{k\ge 0} \sum_{j\ge 0} S(i,j) k^{\underline{j}} x^k \binom{n}{k} \\
&= \sum_{i=0}^m a_i \sum_{j\ge 0} S(i,j) j! \sum_{k\ge 0} \binom{n}{k} \binom{k}{j} x^k \\
&= \sum_{i=0}^m a_i \sum_{j\ge 0} S(i,j) j! \binom{n}{j} \sum_{k\ge 0} \binom{n-j}{k-j} x^k \\
&= \sum_{i=0}^m a_i \sum_{j=0}^i S(i,j) n^{\underline{j}} x^j (x+1)^{n-j} \\
\end{aligned}
$$

$O(m^2)$ 解决。

注意事项：$p$ 不是质数，所以处理 $(x+1)^{n-j}$ 时要小心。不过大样例会提醒你的。。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAXN = 1005;
ll q_pow(ll a, ll b, ll p) {
	ll ret = 1;
	for (; b; a = a * a % p, b >>= 1) if (b & 1) ret = ret * a % p;
	return ret;
}
ll inv(ll x, ll p) { return q_pow(x, p - 2, p); }

int M, N, X, P, pwX[MAXN], pwX1[MAXN], S[MAXN][MAXN], a[MAXN], ans;
int main() {
	scanf("%d%d%d%d", &N, &X, &P, &M);
	for (int i = 0; i <= M; ++i) scanf("%d", &a[i]);
	S[0][0] = 1, pwX[0] = 1;
	for (int i = 1; i <= M; ++i) {
		S[i][1] = 1;
		for (int j = 2; j <= i; ++j) {
			S[i][j] = (S[i - 1][j - 1] + 1ll * j * S[i - 1][j]) % P;
		}
		pwX[i] = 1ll * pwX[i - 1] * X % P;
	}
	pwX1[M] = q_pow(X + 1, N - M, P);
	for (int i = M - 1; i >= 0; --i) pwX1[i] = 1ll * pwX1[i + 1] * (X + 1) % P;
	for (int i = 0; i <= M; ++i) {
		int ret = 0, owo = 1, qwq = N;
		for (int j = 0; j <= i; ++j) {
			ret = (ret + 1ll * S[i][j] * owo % P * pwX[j] % P * pwX1[j] % P) % P;
			owo = 1ll * owo * qwq % P, qwq = (qwq - 1) % P;
		}
		ans = (ans + 1ll * a[i] * ret) % P;
	}
	printf("%d\n", ans);
	return 0;
}
```



---

## 作者：RainAir (赞：3)

退役了。这估计是我退役前写的最后一篇题解吧。

看下题目是让求：
$$
\sum_{k=0}^n f(k)x^k \binom n k
$$

看起来有点像二项分布 所以我们搞一个正面概率为 $x$ 的硬币，设离散随机变量 $X=k$ 表示扔 $n$ 次**至少**有 $k$ 枚硬币是正面的事件。这个随机变量的分布列显然是 $\binom n k x^k$，而我们现在要求的是 $f(X)$ 的期望。

首先我们根据期望的线性性，可得：
$$
\mathbb{E}[F(X)] = \mathbb{E}[\sum_{i=0}^m a_iX^i] = \sum_{i=0}^m a_i\mathbb{E}[X^i]
$$

考虑我们有

$$
x^n = \sum_{k=0}^n \left\{^n_k\right\}x^{\underline k}
$$

其中 $\left\{^n_k\right\}$ 是第二类斯特林数，$x^{\underline k}$ 是 $x$ 的降 $k$ 次幂。

所以我们实际上要解决 $O(k)$ 求 $\mathbb{E}[X^{\underline k}]$ 即可，所以我们自然地想到概率生成函数。

列出这个事件的概率生成函数 $P(s)$：
$$
P(s) = \sum_{k \geq 0} \binom n k x^k s^k
$$
可以发现上式等于：
$$
(xs+1)^n
$$
那么根据概率生成函数的性质可以轻松得到
$$
\mathbb{E}[X^{\underline k}] = P^{(k)}(1) = n^{\underline k}x^k(x+1)^{n-k}
$$
其中 $f^{(i)}$ 表示对函数 $f$ 求 $i$ 阶导。

所以我们可以得到这题的答案是：

$$
\sum_{i=0}^m a_i\sum_{j=0}^i \left\{^i_j\right\}n^{\underline j}x^j(x+1)^{n-j}
$$

UPD: 代码好像CCF过了 
```cpp
#include <bits/stdc++.h>

#define fi first
#define se second
#define pb push_back
#define LL long long
#define MP std::make_pair
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
#define DEBUG(x) std::cerr << #x << '=' << x << std::endl

const int MAXN = 1000+5;
int S[MAXN][MAXN],ha;

inline void prework(){
	S[0][0] = 1;
	FOR(i,1,MAXN-1){
//		S[i][1] = 
		S[i][0] = 0;
		FOR(j,1,i){
//			S[i][j] = (S[i-1][j-1]+1ll*(i-1)*S[i-1][j]%ha)%ha;
			S[i][j] = (S[i-1][j-1]+1ll*j*S[i-1][j]%ha)%ha;
		}
	}
}

int n,x,m;
int a[MAXN];
int down[MAXN],pw[MAXN];

inline int qpow(int a,int n=ha-2){
	int res = 1;a %= ha;
	while(n){
		if(n & 1) res = 1ll*res*a%ha;
		a = 1ll*a*a%ha;
		n >>= 1;
	}
	return res;
}

int main(){
	freopen("problem.in","r",stdin);
	freopen("problem.out","w",stdout);
	scanf("%d%d%d%d",&n,&x,&ha,&m);
	prework();
	down[0] = 1;
	FOR(i,1,std::min(n+2,MAXN-1)) down[i] = 1ll*down[i-1]*(n-i+1)%ha;
	pw[0] = 1;FOR(i,1,MAXN-1) pw[i] = 1ll*pw[i-1]*x%ha;
	FOR(i,0,m) scanf("%d",a+i);
	int ans = 0;
	FOR(i,0,m){
		int t = 0;
		FOR(j,0,i){
			(t += 1ll*S[i][j]*pw[j]%ha*down[j]%ha*qpow(x+1,n-j)%ha) %= ha;
		}
		t  = 1ll*t*a[i]%ha;
		(ans += t) %= ha;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Rorschachindark (赞：3)

# 组合数问题
[题目传送门](https://www.luogu.com.cn/problem/P6620)
# 题目大意
给出一个$m$次多项式，$a_0x+a_1x+...+a_mx^m$，再给出$n,x,m,p$，请求出:

$$\sum_{k=0}^{n} f(k)x^k \binom{n}{k}$$

$n,x,p\le 10^9,m\le 10^3$
# 思路
考场sb了，式子推出来没看到$j!\times \binom{n}{j}$，然后就炸了。

言归正传，我们显然应该将多项式系数展开，因为不展开就一定时间复杂度与$n$有关系，于是就可以得到答案为:

$$\sum_{i=0}^{m} a_i \sum_{k=0}^{n} k^i x^k \binom{n}{k}$$

很显然，这个时候我们应该将$k^i$用第二类斯特林数展开，于是得到:

$$=\sum_{i=0}^{m} a_i\sum_{k=0}^{n} x^k \binom{n}{k} \sum_{j=0}^{k} \begin{Bmatrix} i\\j\end{Bmatrix}\binom{k}{j}j!$$

调换求和顺序又利用:

$$\binom{n}{m}\binom{m}{k}=\binom{n}{k}\binom{n-k}{m-k}$$

可以得到:

$$=\sum_{i=0}^{m} a_i\sum_{j=0}^{i} \begin{Bmatrix} i\\j\end{Bmatrix}j!\binom{n}{j}\sum_{k=0}^{n-j}x^{k+j} \binom{n-j}{k}$$

又因为:

$$(1+x)^n=\sum_{i=0}^{n} x^i \binom{n}{i}$$

所以得到:

$$=\sum_{i=0}^{m} a_i\sum_{j=0}^{i} \begin{Bmatrix} i\\j\end{Bmatrix}j!\binom{n}{j} x^j(1+x)^{n-j}$$

考试的时候sb了，没看到$\binom{n}{j}j!$。于是可以得到:

$$=\sum_{i=0}^{m} a_i \sum_{j=0}^{i} \begin{Bmatrix} i\\j\end{Bmatrix}x^j(1+x)^{n-j}n^{\underline{j}}$$

因为第二类斯特林数有一个递推公式:

$$\begin{Bmatrix} n\\m\end{Bmatrix}=\begin{Bmatrix} n-1\\m-1\end{Bmatrix}+m\begin{Bmatrix} n-1\\m\end{Bmatrix}$$

所以我们就可以$\Theta(m^2)$预处理出$\begin{Bmatrix} i\\j\end{Bmatrix}$。

至此，我们可以$\Theta(m^2)$解决这个问题，做完了可以去看一下[这道题](https://www.luogu.com.cn/problem/CF932E)。两道题是差不多的。

---

## 作者：hwk0518 (赞：2)

### 利益无关：2019年参加十二省联考被吊打的FJ选手
#### 前置知识：斯特林反演
第二类斯特林数$\{\frac{n}{m}\}$表示将$n$个数划分为$m$个集合的方案数。

有递推公式：$\{\frac{n}{m}\}=\{\frac{n-1}{m-1}\}+k*\{\frac{n-1}{m}\}$

斯特林反演：$k^m=\sum_{i=0}^{m}\{\frac{m}{i}\}*(\frac{k}{i})*i!$

#### 题解
$\sum_{k=0}^{n}f(k)*x^k*(\frac{n}{k})$

$=\sum_{k=0}^{n}\sum_{i=0}^{m}a_i*k^i*x^k*(\frac{n}{k})$

$=\sum_{i=0}^{m}a_i*\sum_{k=0}^{n}k^i*x^k*(\frac{n}{k})$

若令$g(n,m,x)=\sum_{k=0}^{n}k^m*x^k*(\frac{n}{k})$，则

$\sum_{k=0}^{n}f(k)*x^k*(\frac{n}{k})$

$=\sum_{i=0}^{m}a_i*g(n,i,x)$

接下来我们讨论如何计算$g(n,m,x)$。

$g(n,m,x)=\sum_{k=0}^{n}k^m*x^k*(\frac{n}{k})$

$=\sum_{k=0}^{n}\sum_{i=0}^{m}\{\frac{m}{i}\}*(\frac{k}{i})*i!*x^k*(\frac{n}{k})$（应用反演公式）

$=\sum_{k=0}^{n}\sum_{i=0}^{m}\{\frac{m}{i}\}*\frac{k!}{(k-i)!}*x^k*(\frac{n}{k})$

$=\sum_{i=0}^{m}\{\frac{m}{i}\}\sum_{k=0}^{n}\frac{k!}{(k-i)!}*x^k*(\frac{n}{k})$

$=\sum_{i=0}^{m}\{\frac{m}{i}\}\sum_{k=0}^{n}\frac{k!}{(k-i)!}*x^k*\frac{n!}{k!(n-k)!}$

$=\sum_{i=0}^{m}\{\frac{m}{i}\}\sum_{k=0}^{n}\frac{n!}{(k-i)!(n-k)!}*x^k$

$=n!\sum_{i=0}^{m}\{\frac{m}{i}\}\frac{1}{(n-i)!}\sum_{k=0}^{n}\frac{(n-i)!}{(k-i)!(n-k)!}*x^k$

$=n!\sum_{i=0}^{m}\{\frac{m}{i}\}\frac{1}{(n-i)!}\sum_{k=0}^{n}(\frac{n-i}{n-k})*x^k$

$=n!\sum_{i=0}^{m}\{\frac{m}{i}\}\frac{1}{(n-i)!}\sum_{k=i}^{n}(\frac{n-i}{n-k})*x^k$（$n<m$时，$(\frac{n}{m})$无意义)

$=n!\sum_{i=0}^{m}\{\frac{m}{i}\}\frac{1}{(n-i)!}\sum_{k=i}^{n}(\frac{n-i}{k-i})*x^k$

$=n!\sum_{i=0}^{m}\{\frac{m}{i}\}\frac{1}{(n-i)!}\sum_{k=0}^{n-i}(\frac{n-i}{k})*x^{k+i}$

$=n!\sum_{i=0}^{m}\{\frac{m}{i}\}\frac{1}{(n-i)!}*x^i*\sum_{k=0}^{n-i}(\frac{n-i}{k})*x^{k}$

$=n!\sum_{i=0}^{m}\{\frac{m}{i}\}\frac{1}{(n-i)!}*x^i*(x+1)^{n-i}$


用快速幂即可做到复杂度$O(mlogn)$。

实现的时候有个小技巧，我们发现$n!$不好计算，但$h(i)=\frac{n!}{(n-i)!}=\pi_{x=n-i+1}^{n}x$，而$h(i)=h(i-1)*(n-i+1)$，实时维护$h(i)$即可。

总时间复杂度：$O(m^2logn)$

```

#include <bits/stdc++.h>
using namespace std;

const int M = 1005;
int n, x, mod, m, a[M], s[M][M];

namespace MATHEMATICS {
	int add(int x, int y) {
		int ret = x + y;
		if (ret >= mod) ret -= mod;
		return ret;
	}
	int mi(int x, int y) {
		int ret = x - y;
		if (ret < 0) ret += mod;
		return ret;
	}
	
	void inc(int &x, int y) {
		x += y;
		if (x >= mod) x -= mod;
	}
	void dec(int &x, int y) {
		x -= y;
		if (x < 0) x += mod;
	}
	
	int mul(int x, int y) {
		return 1LL * x * y % mod;
	}
	int F_p(int x, int y) {
		int bas = x, ret = 1;
		while (y) {
			if (y & 1) ret = mul(ret, bas);
			bas = mul(bas, bas);
			y >>= 1;
		}
		return ret;
	}
}
using namespace MATHEMATICS;

void prework() {
	s[0][0] = 1;
	for (int i = 1; i <= m; ++i)
		for (int j = 1; j <= i; ++j)
			s[i][j] = add(s[i - 1][j - 1], mul(j, s[i - 1][j]));
}

int calc(int n, int m, int x) {
	int ret = 0, nw = 1;
	for (int i = 0; i <= m; ++i) {
		inc(ret, mul(nw, mul(s[m][i], mul(F_p(x + 1, n - i), F_p(x, i)))));
		nw = mul(nw, n - i);
	}
	return ret;
}

void work() {
	for (int i = 0; i <= m; ++i) scanf("%d", &a[i]), a[i] %= mod;
	int ans = 0;
	for (int i = 0; i <= m; ++i) inc(ans, mul(a[i], calc(n, i, x)));
	printf("%d\n", ans);
}

int main() {
	scanf("%d%d%d%d", &n, &x, &mod, &m); x %= mod;
	prework(); work();
	return 0;
}

```

---

## 作者：青葱 (赞：2)

再推导一页式子，作为我退场前的最后一歌。


------------
令题面中的$x$为$d$，
$$\sum_{k=0}^{n}{f(k)*d^k*C_{n}^{k}}$$

其中，
$$f(x)=\sum_{i=0}^{m}a_i*x^i$$

考虑将$f(x)$转化为下降幂多项式，即:
$$f(x)=\sum^{m}_{i=0}{b_i*x^{\underline{\text{i}}}}=\sum^{m}_{i=0}b_i*\frac{x!}{(x-i)!}$$

则原式：
$$\sum_{k=0}^{n}{d^k*C_{n}^{k}*\sum^{m}_{i=0}b_i*\frac{k!}{(k-i)!}}$$

交换求和项，拆出组合数：
$$\sum_{i=0}^{m}{b_i*n!*\sum_{k=0}^n \frac{d^k}{(k-i)!}*\frac{1}{(n-k)!}}$$
发现后面是卷积，给前者除去$d^i$恰为$e^{dx}$的形式:
$$\sum_{i=0}^{m}{b_i*n!*[x^{n-i}](e^{dx}*e^x)*(dx)^i}$$
$$\sum_{i=0}^{m}{b_i*n!*\frac{(d+1)^{n-i}}{(n-i)!}}*d^i$$
$$\sum_{i=0}^{m}{b_id^i*(d+1)^{n-i}n^{ \underline{\text{i}}}}$$
这部分能够做到$O(m)$。

------------
对于多项式转下降幂多项式，~~有第二类斯特林数展开幂为下降幂:~~，不会写第二类斯特林符号，左转板子。


------------


对于$p$是质数的情况，可以做到$O(mlog^2m)$。

对于$p$不是质数的情况，可以做到$O(m^2)$。

---

## 作者：yijan (赞：2)

更新了一下代码和 $p$ 为质数时的 $O(m\log m)$ 的做法。

大力推式子：
$$
\begin{aligned}
& \sum_{i=0}^m a_i \sum_{k=0}^n x^k \binom n k k^i\\
&= \sum_{i=0}^m a_i \sum_{k=0}^n x^k \binom n k \sum_{j=0}^i k^{\underline j} \begin{Bmatrix}i\\j\end{Bmatrix}\\
&= \sum_{i=0}^m a_i \sum_{j=0}^i \begin{Bmatrix}i\\j\end{Bmatrix} \sum_{k=0}^n x^k \binom n k j! \binom k j\\
&= \sum_{i=0}^m a_i \sum_{j=0}^i \begin{Bmatrix}i\\j\end{Bmatrix} j! \sum_{k=0}^n x^k \binom n j \binom {n-j} {k - j}\\
&= \sum_{i=0}^m a_i \sum_{j=0}^i \begin{Bmatrix}i\\j\end{Bmatrix} j!\binom n j \sum_{k=0}^n x^k  \binom {n-j} {k - j}\\
&= \sum_{i=0}^m a_i \sum_{j=0}^i \begin{Bmatrix}i\\j\end{Bmatrix} j!\binom n j \sum_{k=0}^{n-j} x^{k + j}  \binom {n-j} {k}\\
&= \sum_{i=0}^m a_i \sum_{j=0}^i \begin{Bmatrix}i\\j\end{Bmatrix} j!\binom n j x^j(x+1)^{n-j}\\

\end{aligned}
$$
中间用到了组合恒等式
$$
\binom{n}{k} \binom k j = \binom n j \binom{n - j}{k - j}
$$
考虑 $n$ 个球拿 $k$ 个球，再从 $k$ 个中拿 $j$ 个的方案数量，就是从 $n$ 个中拿 $j$ 个，再从剩下的拿 $k - j$ 个的方案数量。

考虑模数不为质数怎么求前面那个组合数。我们可以把 $j! \binom n j$ 放一起，然后就是 $\frac{n!}{(n-j)!}$ 。这个可以直接从 $n$ 向下乘 $j$ 次就好。预处理出来即可。
$$
\sum_{i=0}^m a_i \sum_{j=0}^i \begin{Bmatrix}i\\j\end{Bmatrix} \frac{n!}{(n-j)!} x^j(x+1)^{n-j}
$$
复杂度可以做到 $O(m^2)$。

如果 $p$ 是质数可以做到 $O(m\log n)$ 。（$p$ 不是质数可以做到请教教yijan）

大概胡一下 $p$ 质数的情况吧：
$$
\sum_{k=0}^{n} k^{i} \times x^{k} \times\left(\begin{array}{l}n \\k\end{array}\right)
$$
直接考虑这个式子的组合意义，相当于有 $n$ 个盒子，从中选择 $k$ 个盒子，每选择一个盒子便乘 $x$ 的权值，最后把 $i$ 个球放进去的方案数量（可以为空）。

考虑每个盒子球的数量，由于可空且无序，一个盒子的 `EGF`  是 $f(k)=1+xe^k$ ，对这个做快速幂即可，可以做到 $O(m\log m)$。

```cpp
#include "iostream"
#include "algorithm"
using namespace std;
#define MAXN 1006
int n , x , P , m;
int A[MAXN] , s[MAXN][MAXN] , pw[MAXN] , ppw[MAXN] , J[MAXN];

int Pow( int x , int a ) {
	if( a < 0 ) return 0;
	int ret = 1;
	while( a ) {
		if( a & 1 ) ret = ret * 1ll * x % P;
		x = x * 1ll * x % P , a >>= 1;
	}
	return ret;
}

int main() {
//	freopen("problem1.in","r",stdin);
	cin >> n >> x >> P >> m;
	for( int i = 0 ; i <= m ; ++ i ) scanf("%d",A + i);
	s[0][0] = 1;
	for( int i = 1 ; i <= m ; ++ i ) {
		for( int j = 1 ; j <= i ; ++ j )
			s[i][j] = ( s[i - 1][j - 1] + j * 1ll * s[i - 1][j] % P ) % P;
	}
	for( int i = 0 ; i <= m ; ++ i )
		pw[i] = Pow( x + 1 , n - i ) , ppw[i] = Pow( x , i );
	J[0] = 1;
	for( int i = 1 ; i <= m ; ++ i )
		J[i] = J[i - 1] * 1ll * ( n - i + 1 ) % P;
	int ans = 0;
	for( int i = 0 ; i <= m ; ++ i ) {
		int re = 0;
		for( int j = 0 ; j <= i ; ++ j )
			re = ( re + s[i][j] * 1ll * J[j] % P * ppw[j] % P * pw[j] ) % P;
		ans = ( ans + re * 1ll * A[i] ) % P;
	}
	cout << ans << endl;
}
```



---

## 作者：An_Account (赞：2)

这里给出一种由组合意义得出的$O(m\log m)$的做法（需要保证$p$是$998244353$）。

将$f(x)$展开

$$
\begin{aligned}
\sum_{k=0}^nf(k)x^k{n\choose k}&= \sum_{k=0}^n\sum_{i=0}^ma_ik^ix^k{n\choose k}\\
&=\sum_{i=0}^ma_i\sum_{k=0}^nk^ix^k{n\choose k}
\end{aligned}
$$

考虑第二个$\sum$的组合意义：有$n$个不同的盒子，先从这些盒子中选出$k$个盒子，然后给这$k$个盒子染上$x$种颜色，最后将$i$个有标号的球放入$k$个盒子中。

那么对于一个盒子来说，有三种情况：没有被选中；选中并且染色了，但是没有放入任何球；选中并且染色了，并且放入了若干个球。

写出一个盒子的$EGF$

$$
\begin{aligned}
F(t)&=1+x+x\sum_{i\geq 1}\frac{t^i}{i!}\\
&=1+xe^t
\end{aligned}
$$

代入原式，可以得到

$$
\begin{aligned}
\sum_{i=0}^ma_i\sum_{k=0}^nk^ix^k{n\choose k}&=\sum_{i=0}^ma_i(1+xe^t)^n[t^i]i!
\end{aligned}
$$

这里$[t^i]$表示取$t^i$项系数。

最后只需要做一遍$\ln,\exp$即可。


---


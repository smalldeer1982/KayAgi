# [省选联考 2020 A/B 卷] 信号传递

## 题目描述

一条道路上从左至右排列着 $m$ 个信号站，初始时从左至右依次编号为 $1,2,\dots,m$，相邻信号站之间相隔 $1$ 单位长度。每个信号站只能往它右侧的任意信号站传输信号（称为普通传递），每单位长度距离需要消耗 $1$ 单位时间。道路的最左侧有一个控制塔，它在最左侧信号站的左侧，与其相隔 $1$ 单位长度。控制塔能与任意信号站进行双向信号传递（称为特殊传递），但每单位长度距离需要消耗 $k$ 个单位时间。对于给定的长度为 $n$ 的信号传递序列 $S$，传递规则如下：

1. 共 $n-1$ 次信号传递，第 $i$ 次信号传递将把信号从 $S_i$ 号信号站传递给 $S_{i+1}$ 号。
2. 若 $S_{i+1}$ 号信号站在 $S_i$ 号右侧，则将使用普通传递方式，从 $S_i$ 号直接传递给 $S_{i+1}$ 号。
3. 若 $S_{i+1}$ 号信号站在 $S_i$ 号左侧，则将使用特殊传递方式，信号将从 $S_i$ 号传递给控制塔，再由控制塔传递给 $S_{i+1}$ 号。
4. 若 $S_i=S_{i+1}$，则信号无须传递。

阿基作为大工程师，他能够任意多次交换任意两个信号站的位置，即他能够重排信号站的顺序，这样会使得 $S$ 消耗的传递时间改变。现在阿基想知道，在他重排信号站顺序后，$S$ 所消耗的传递时间最小能是多少。

## 说明/提示

【样例解释 $1$】

信号站顺序保持不变，两次使用普通传递方式，时间消耗为 $1+1=2$。

【样例解释 $2$】

对于排列 $1,2,3$，传递时间为 $1+1+(3\times 1+1\times 1)=6$。

对于排列 $1,3,2$，传递时间为 $2+(3\times 1+2\times 1)+(2\times 1+1\times 1)=10$。

对于排列 $2,1,3$，传递时间为 $(2\times 1+1\times 1)+2+(3\times 1+2\times 1)=10$。

对于排列 $2,3,1$，传递时间为 $(3\times 1+1\times 1)+1+1=6$。

对于排列 $3,1,2$，传递时间为 $1+(3\times 1+1\times 1)+1=6$。

对于排列 $3,2,1$，传递时间为 $(3\times 1+2\times 1)+(2\times 1+1\times 1)+2=10$。

【数据范围】

$30\%$ 的数据：$m\leq 8, n\leq 100$。

$60\%$ 的数据：$m\leq 20$。

$70\%$ 的数据：$m\leq 21$。

$80\%$ 的数据：$m\leq 22$。

$100\%$ 的数据：$2\leq m\leq 23$，$2\leq n\leq 10^5$，$1\leq k\leq 100$，$1\leq S_i\leq m$。

## 样例 #1

### 输入

```
3 3 1
1 2 3```

### 输出

```
2```

## 样例 #2

### 输入

```
4 3 1
1 2 3 1```

### 输出

```
6```

# 题解

## 作者：BJpers2 (赞：99)

为表述方便，以下称信号站为点，传输序列中相邻两个点之间连一条从前往后的有向边。

### 一个显而易见的结论

设边$x\rightarrow y$的代价为（$x,y$是坐标）
$$
\begin{cases}
y-x & x\le y \\
kx+ky & x>y
\end{cases}
$$
显然可以将此代价分到各个点上来累加。具体来说，对于最终在坐标为$x$的点，序列中每有一条$x\rightarrow y$的边，若$x\le y$则付出$k$的代价，否则付出$-1$的代价。同理对于$y\rightarrow x$的边分别付出$1$和$k$的代价。最终总代价等于每个点的代价分别乘其坐标再求和。

~~然而我考场上并没有想到这个显而易见的结论，只拿了30分，我太菜了。~~

### 一个基本的做法

容易发现在上述转化下，一个点的贡献只与坐标在其前面的点集有关，只序预处理出$g(i,S)$表示$i$号点前面的点集为$S$时$i$对答案的贡献，即可用以下转移求出答案：
$$
f(S)+g(i,S)\rightarrow f(S\cup\{i\})
$$
如果暴力计算$g(i,S)$（枚举$i,S$以及$S$中的元素$j$），时间复杂度为$O(m^22^m)$。

但显然可以从小到大枚举$S$递推$g$，此时时间复杂度优化为$O(m2^m)$，但空间复杂度也为$O(m2^m)$，如果开$23\times 2^{23}=192,937,984$的$\text{int}$数组，将花费$736\text{M}$的空间，不可承受。（因为主要的空间瓶颈是$g$数组，为方便计算，以下都只计算$g$的空间开销）

### 优化

接下来就是大家喜闻乐见的卡空间环节。其实到了这一步基本上就是各凭本事了，做法也不是唯一的。就我所知大概有七种做法，本质不同的有四种。

#### 方法一：强行折半

注意到$g$数组的递推具有比较强的拓扑性，即$g(i,S)$值会转移到某个大小恰比$S$大$1$的集合$T$。$f$同理。

于是我们可以分两步走，先求出$|S|\le 11$的所有$g(i,S)$，并求出所有相应$|S|\le 12$的$f(S)$；然后清空$g$数组（但保留$|S|$恰为$11$的），把空间腾出来存储所有$|S|>12$的$g$。

这样每时每刻我们只需存储大约一半的$g$，空间大概是$23\times 2^{22}\times 4\text{B}=368\text{M}$，可以承受。

本方法在任何角度都有完全优于它的算法存在，只是作为一个引入。

#### 方法二：滚动数组

原理与方法一相似，但分层更为细致。我们严格按照$|S|$单调不降处理所有的$f$和$g$，用滚动数组实现$g$的递推。

那么我们同一时刻最多需要存储的$g(i,S)$状态个数取决于哪个大小的集合最多，根据常识可知有分别有$\binom{23}{12}$个集合大小为$11$和$12$，是最多的。

因此空间开销为$2\times 23\times \binom{23}{12}\times 4\text{B}\approx 237\text{M}$。

缺点是滚动数组是三维的，寻址十分缓慢。优势在于空间**比较**小。详见[Fuyuki队长的题解。](https://www.luogu.com.cn/blog/fuyuki/solution-p6622)

#### 方法三：巧妙折半

注意到，我们没有必要考虑$i\in S$的$g(i,S)$。这样对于每个$i$而言只有$2^{22}$种$S$需要计算，总量减少了一半。

空间开销与方法一致，为$368\text{M}$。这个方法实现非常优美，而且思路直接，是本人第二喜欢的算法。

```cpp
#include<iostream>
#include<cstdio>
#define gmi(a,b) a=a<b?a:b
#define FOF(i,a,b) for(int i=a;i< b;i++)
using namespace std;
const int M=23,N=1<<M,INF=1e9;
int n,m,K,x=-1,y,z,w,L,R;
int lg[N],sz[N],f[N],g[M][M],h[M][N>>1];
int main(){
	scanf("%d%d%d",&n,&m,&K);L=1<<m;R=L>>1;lg[0]=-1;
	while(n--) scanf("%d",&y),~x?++g[x][--y]:--y,x=y;
	FOF(i,1,L) lg[i]=lg[i>>1]+1,sz[i]=sz[i>>1]+(i&1);
	FOF(i,0,m){
		FOF(j,0,m)if(i^j) h[i][0]+=g[j][i]*K-g[i][j];
		FOF(j,1,R) y=j&-j,z=lg[y],z+=z>=i,h[i][j]=h[i][j^y]+g[i][z]*(1+K)+g[z][i]*(1-K);
	}
	FOF(i,1,L)for(f[i]=INF,x=i;y=x&-x;x^=y)
		z=lg[y],w=i^y,gmi(f[i],f[i^y]+h[z][w&y-1|w>>z+1<<z]*sz[i]);
	cout<<f[L-1]<<'\n';
}
```

#### 方法四：经典结论

> 二进制从$0$数到$n$，所有比特位变化的总次数为$O(n)$。

我们直接去掉$g$的$S$那一维。然后按二进制数大小（而不是集合大小）顺序枚举$S$，并按照$S+1$相对$S$的变化暴力修改$g$。

根据上述结论，我们对每个比特位的变化，修改$g$的代价是$O(m)$。那么总修改代价就为$O(m2^m)$，时间复杂度正确。

更强悍的是，这种做法只需要$O(2^m)$的空间，每多开一个数组只消耗$32\text{M}$的空间，总空间可以限制在$100\text{M}$以内。

缺点不是很明显，硬要说的话就是跑得还不够快（洛谷上不吸氧至多$85$分）。优点在于，不但空间优秀，而且实现十分无脑，是本人最喜欢的算法。

```cpp
#include<iostream>
#include<cstdio>
#define gmi(a,b) a=a-b>>31?a:b
#define FOF(i,a,b) for(int i=a;i<b;i++)
using namespace std;
const int M=23,N=1<<M;
int n,m,K,x,y,z,w,s,L,R;
int f[N],g[M][M],h[M],c[M][M],lg[N],sz[N];
int main(){
	scanf("%d%d%d",&n,&m,&K),x=-1;
	while(n--) scanf("%d",&y),~x?++g[x][--y]:--y,x=y;
	FOF(i,0,m)FOF(j,0,m)if(i^j)
		h[i]+=g[j][i]*K-g[i][j],c[i][j]=g[i][j]*(1+K)+g[j][i]*(1-K);
	R=1<<m;L=R-1;lg[0]=-1;
	FOF(i,1,R) sz[i]=sz[i>>1]+(i&1),lg[i]=lg[i>>1]+1,f[i]=1e9;
	FOF(i,0,L){
		s=sz[i]+1;
		for(x=L^i  ;y=x&-x;x^=y) w=f[i]+h[lg[y]]*s,gmi(f[i|y],w);
		for(x=i^i+1;y=x&-x;x^=y){
			w=lg[y];
			if(y&i) FOF(j,0,m) h[j]-=c[j][w];
			else	FOF(j,0,m) h[j]+=c[j][w];
		}
	}
	cout<<f[L]<<'\n';
}
```

#### 方法五：巧妙递推

依旧是沿着方法四的思路，二进制顺序枚举$S$，考虑$w(i,j)$表示$j$的前面是「最近的被枚举的大小为$i$的集合」时，$j$对答案的贡献。

容易证明，枚举到$S$时，$w(|S|-1,j)$恰好存的是$g(j,S-\text{lowbit}(S))$。因此可以直接转移得到$w(|S|,j)$。

这样时空复杂度不变，但常数得到了很大优化，洛谷不吸氧可过。

```cpp
#include<iostream>
#include<cstdio>
#define gmi(a,b) a=a-b>>31?a:b
#define FOF(i,a,b) for(int i=a;i<b;i++)
using namespace std;
const int M=23,N=1<<M;
int n,m,K,x,y,z,s,L,R;
int f[N],g[M][M],w[M][M],c[M][M],lg[N],sz[N];
int main(){
	scanf("%d%d%d",&n,&m,&K),x=-1;
	while(n--) scanf("%d",&y),~x?++g[x][--y]:--y,x=y;
	FOF(i,0,m)FOF(j,0,m)if(i^j)
		w[0][i]+=g[j][i]*K-g[i][j],c[i][j]=g[i][j]*(1+K)+g[j][i]*(1-K);
	R=1<<m;L=R-1;lg[0]=-1;
	FOF(i,1,R) sz[i]=sz[i>>1]+(i&1),lg[i]=lg[i>>1]+1,f[i]=1e9;
	FOF(i,0,L){
		z=lg[i&-i];
		if(s=sz[i]) FOF(j,0,m) w[s][j]=w[s-1][j]+c[j][z];//只有这里和方法四不同
		for(x=L^i;y=x&-x;x^=y) z=f[i]+w[s][lg[y]]*(s+1),gmi(f[i|y],z);
	}
	cout<<f[L]<<'\n';
}
```

#### 方法六：登峰造极

注意到，方法四、五的空间可以利用方法二的思想进一步优化，可以将$f$个数组进行滚动。这样一来$sz$数组就没有了存在的意义，而$lg$数组只会调用$2$的幂，可以不用开那么大的空间。

此时$f$是空间的唯一瓶颈，滚动优化之，空间达到了$2\times \binom{23}{12}\times 4\text{B}\approx 10\text{M}$。

可能有人觉得出题人卡空间，但殊不知出题人给我们$512\text{M}$已经是最大的宽容。（估计来个$16\text{M}$就真成经典了

本方法没有经过实现，但理论分析表明，本算法受滚动数组和$\log_2$被阉割的影响，运行效率很可能不如方法四。(当然你用ctz我也没话说)

#### 方法七：分块

又是一个很粗暴的思路，既然难以一次性存储$i$对所有集合的代价，那就把集合$S$拆成前$12$位和后$11$位两部分，即
$$
g(i,S)=g_1(i,S\cap[0,11])+g_2(i,S\cap[12,22])
$$
这样$g_1$和$g_2$的空间都得到了开根级别的优化，空间开销相对于$f$来说已经可以忽略不计。其余部分照做即可。

缺点是代码难度（相对方法四、五来说）比较高，优点在于常数非常小，现在luogu和LOJ的最优解都是这种做法（应该是同一个人）。



---

## 作者：duyi (赞：30)

[更好的阅读体验](https://www.cnblogs.com/dysyn1314/p/13201569.html)

# 强烈推荐更好的的阅读体验↑

[题目链接](https://loj.ac/problem/3302)


### 初步转化

按题意，我们暴力枚举这$m$个信号站的排列顺序，时间复杂度$O((m!)\cdot n)$。

容易发现，题目给出的这个长度为$n$的序列$S$具体是什么不重要，重要的是，每一对信号站$i,j$，在$S$里作为**相邻的位置**，出现了多少次。也就是有多少个位置$p$ ($1\leq p<n$)满足$S_p=i,S_{p+1}=j$。我们记这个数量为$\text{cnt}[i][j]$。

对于任意$i\neq j$，$\text{cnt}[i][j]$就表示要从信号站$i$，向信号站$j$，进行多少次传递。设两个信号站的位置，分别为$\text{pos}[i],\text{pos}[j]$，则它们会对答案产生的代价就是：
$$
\begin{cases}
\text{pos}[j]-\text{pos}[i]&&(\text{pos}[i]<\text{pos}[j])\\
k\cdot(\text{pos}[i]+\text{pos}[j])&&(\text{pos[i]}>\text{pos}[j])
\end{cases}
$$
做了这步转化后，如果还是暴力枚举这$m$个信号站的排列顺序，时间复杂度优化为$O(n+(m!)\cdot m^2)$。至此我们复杂度的瓶颈与$n$无关了。

### 朴素DP

接下来，结合$m$的大小，容易想到状压DP。此处就有两种状态设计的思路：

- 设$dp[s]$表示考虑了前$|s|$个数，放在了$s$里的这些位置上。
- 设$dp[s]$表示考虑了前$|s|$个位置，填了$s$里的这些数。

发现，第一种状态设计是无法转移的。所以我们选择第二种。事实上，考试时我就一直在想第一种，把自己搞自闭了。其实，按位置考虑、按数值考虑，这都是常见的方法，所以要学会灵活变通，一个不行就想想另一个。

我们选择了第二种状态设计：设$dp[s]$表示考虑了前$|s|$个位置，填了$s$里的这些数。

那考虑转移。首先要枚举在新加入的位置，也就是在第$\text{pos}=|s|+1$个位置，填哪个数。假设我们填$i$。考虑填$i$会新增哪些代价。它会分别和：前面的数（也就是$s$里的数）、后面的数（也就是不在$s$里，但也不等于$i$的数）产生代价。而且每种代价都有两个方向。具体来说：

- 对于一个前面的数$j$，从$i$到$j$产生的代价是：$\text{pos}\cdot k\cdot \text{cnt}[i][j]$。
- 对于一个前面的数$j$，从$j$到$i$产生的代价是：$\text{pos}\cdot\text{cnt}[j][i]$。
- 对于一个后面的数$j$，从$i$到$j$产生的代价是：$-\text{pos}\cdot \text{cnt}[i][j]$。
- 对于一个后面的数$j$，从$j$到$i$产生的代价是：$\text{pos}\cdot k\cdot \text{cnt}[j][i]$。

所以我们也可以写出式子：
$$
dp[s+i]\leftarrow dp[s]+\text{pos}\cdot \sum_{j\in s}(k\cdot\text{cnt}[i][j]+\text{cnt}[j][i])+\text{pos}\cdot\sum_{j\notin(s+i)}(-\text{cnt}[i][j]+k\cdot \text{cnt}[j][i])
$$
如果枚举$i$，再枚举$j$，DP的时间复杂度$O(2^mm^2)$。期望得70分。

### 优化时间

我们继续优化。考虑只枚举$i$。把$\text{pos}$前的系数（也就是所有$j$的贡献之和），预处理出来，不妨记为：$\text{cost}(s,i)$。那么上述的转移式，也可以改写为：$dp[s+i]\leftarrow dp[s]+\text{pos}\cdot \text{cost}(s,i)$。

考虑预处理$\text{cost}(s,i)$。首先，根据定义，$i\notin s$。

我们考虑，$\text{cost}(s,i)$，可以从“$s$去掉某个数”的状态，转移过来。我们不妨就去掉$j=\text{lowbit}(s)$（也就是二进制下最低的，为$1$的位）。那么，$\text{cost}(s,i)=\text{cost}(s-j,i)+(k\cdot \text{cnt}[i][j]+\text{cnt}[j][i])-(-\text{cnt}[i][j]+k\cdot \text{cnt}[j][i])$。

这样转移是$O(1)$的。所以预处理的时间复杂度为$O(2^mm)$，DP的时间复杂度也降为$O(2^mm)$。总时间复杂度$O(n+2^mm)$。但是$\text{cost}$数组会占用$O(2^mm)$的空间，这无法承受。所以还要继续优化空间。

### 优化空间

这题优化空间的方法很多。我讲一种比较好想的。想了解更多方法，可以阅读[这篇文章](https://www.luogu.com.cn/blog/BJpers2/solution-p6622)。

发现$\text{cost}$和$\text{dp}$的转移，都是按集合从小到大进行的。所以我们就不妨一边DP，一边求$\text{cost}$。

对每个$s$，我们把$\text{cost}(s,\dots)$视为一个大小为$m$的数组。当前的$s$，我们先做DP转移，再拿$\text{cost}(s\dots)$数组去更新所有$\text{cost}(s'\dots )$。发现更新完之后，$\text{cost}(s,\dots)$这个大小为$m$的数组，就可以不要了！

如果能及时地把$\text{cost}(s,\dots)$这个数组，以某种方式“删除”掉（不再占用空间）。那么，在整个DP的过程中，同一时刻，我们存储的**最多只有两种大小**的$s$。因为$\text{cost}(s,\dots)$只会转移到比它恰好大$1$的$s'$。那么空间的极限，就是${23\choose 12}+{23\choose 11}$个大小为$m$的数组，约等于$237\text{MB}$，完全可以了。

那么怎么实现这个“删除”呢？一种方法是用滚动数组。按大小枚举所有集合。每处理完一种大小，就把数组“滚一次”。另一种方法，是直接利用$\texttt{stl}$里的$\texttt{queue}$，向BFS一样，每次取出队首的$s$，$\texttt{pop}$掉就行。

空间复杂度，$\displaystyle O\left(2^m+m\cdot{m\choose\frac{m}{2}}\right)$。前面分析过，大约$237\text{MB}$，可以通过本题。

参考代码（[在LOJ查看](https://loj.ac/submission/848010)）：

```cpp
//problem:LOJ3302
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mk make_pair
#define lob lower_bound
#define upb upper_bound
#define fi first
#define se second
#define SZ(x) ((int)(x).size())

typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;

inline void ckmin(int& x,int y){x=(x<y?x:y);}

const int MAXN=1e5,MAXM=23;
const int INF=1e9;
int n,m,K,arr[MAXN+5],cnt[MAXM][MAXM];
int id[1<<MAXM],bitcnt[1<<MAXM];
int dp[1<<MAXM];

struct State{
	int s;
	int v[MAXM];
};

int main() {
	//freopen("transfer.in","r",stdin);
	//freopen("transfer.out","w",stdout);
	cin>>n>>m>>K;
	for(int i=1;i<=n;++i){
		cin>>arr[i];
		arr[i]--;
	}
	for(int i=1;i<n;++i){
		cnt[arr[i]][arr[i+1]]++;
	}
	
	queue<State>q;
	State s;
	s.s=0;
	for(int i=0;i<m;++i){
		s.v[i]=0;
		for(int j=0;j<m;++j)if(j!=i){
			s.v[i]-=cnt[i][j];
			s.v[i]+=K*cnt[j][i];
		}
	}
	q.push(s);
	
	int S=(1<<m)-1;
	for(int i=0;i<m;++i)id[1<<i]=i;
	for(int i=1;i<=S;++i){
		bitcnt[i]=bitcnt[i>>1]+(i&1);
		dp[i]=INF;
	}
	while(!q.empty()){
		State curs=q.front();q.pop();
		assert(dp[curs.s]<INF);
		int p=bitcnt[curs.s]+1;
		for(int t=S^curs.s;t;t-=(t&(-t))){
			//枚举curs.s的补集里的一个点i
			int i=id[t&(-t)];
			int new_dp=dp[curs.s];
			int new_s=(curs.s|(1<<i));
			new_dp+=p*curs.v[i];
			
			ckmin(dp[new_s],new_dp);
		}
		for(int i=0;i<m;++i){
			if((curs.s>>i)&1)break;
			State new_state;
			new_state.s=(curs.s|(1<<i));
			for(int t=S^new_state.s;t;t-=(t&(-t))){
				//枚举new_state.s的补集里的一个点j 
				int j=id[t&(-t)];
				new_state.v[j]=curs.v[j]
					+(K*cnt[j][i]+cnt[i][j])
					-(-cnt[j][i]+K*cnt[i][j]);
			}
			q.push(new_state);
		}
	}
	cout<<dp[S]<<endl;
	return 0;
}
```


---

## 作者：Fuyuki (赞：28)

#### upd: 补充代码

设 $x$ 所在的位置为 $p_x$，那么如果存在一次信号传递为：$x\rightarrow y$，花费代价为：

$$\begin{cases}p_y-p_x&p_x<p_y\\k(p_x+p_y)&p_x>p_y\end{cases}$$

设 $f_S$ 表示当前已经用 $S$ 中的信号站填上了 $1\sim|S|$ 这些位置，那么转移时已知当前信号站的位置和这个信号站与其他信号站的相对大小关系。

预处理 $e_{x,y}$ 表示 $x$ 到 $y$ 的信号传递次数后，就可以 $O(m)$ 地计算新加入的信号站对答案的贡献：

$$f_{S}=\min_{x\in S}\{{f_{S-x}+|S|\sum_{i\in S-x}(ke_{x,i}+e_{i,x})+|S|\sum_{i\notin S}(ke_{i,x}-e_{x,i})\}}$$

因为转移共有 $m2^m$ 次，所以时间复杂度为 $O(m^22^m)$。

进一步观察转移的式子，可以发现转移中 $p_x$（在上式中等于 $|S|$） 的系数取决于 $S$ 与 $x$ 间入边和出边的数量。

因此，设 $to_{S,x}$ 表示在转移 $f_{S}\rightarrow f_{S+x}$ 中 $p_x$ 的系数，则 $to_{S+x,y}$ 可以在已知 $to_{S,y}$ 的情况下 $O(1)$ 计算出来：

$$ to_{S+x,y}=to_{S,y}+(1-k)e_{x,y}+(1+k)e_{y,x}$$

这样就得到了一个时空复杂度均为 $O(m2^m)$ 的算法。

但是空间复杂度过高，需要继续优化。

观察到转移的时候只会从 $1$ 个数较少的状态转移到较大的状态，因此可以按 $1$ 的个数进行滚动数组优化，空间复杂度就降至 $O(2^m+m\binom{m}{m/2})$，可以通过本题。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define V inline void
#define FOR(i,a,b) for(int i=a;i<=b;i++)
const int N=23,M=14e5,INF=0x7fffffff;
int n,m,k,S,cnt,tot,f[1<<N];
int e[N][N],to[2][M][N],w[2][M];
V add_edge(int x,int y){if(x!=y&&x)e[x-1][y-1]++;}
V input(){
	scanf("%d%d%d",&n,&m,&k),(S=1<<m)--;
	for(int x=0,y;n--;add_edge(x,y),x=y)scanf("%d",&y);
}
V init(){
	FOR(i,1,S)f[i]=INF;
	FOR(i,0,m-1)FOR(j,0,m-1)to[0][0][j]+=e[i][j]*k-e[j][i];
}
V cmin(int&x,int y){if(y-x>>31)x=y;}
V ins(int*a,int x,int*b){FOR(i,0,m-1)b[i]=a[i]+e[x][i]*(1-k)+e[i][x]*(k+1);}
V work(){
	int p=0,q;
	FOR(x,1,m){
		tot=-1,q=p^1;
		FOR(i,0,cnt)FOR(j,0,m-1)if(!(w[p][i]>>j))
			w[q][++tot]=1<<j|w[p][i],ins(to[p][i],j,to[q][tot]);
		FOR(i,0,cnt)FOR(j,0,m-1)if(~w[p][i]>>j&1)
			cmin(f[1<<j|w[p][i]],f[w[p][i]]+to[p][i][j]*x);
		p=q,cnt=tot;
	}
	cout<<f[S];
}
int main(){
//	freopen("test.in","r",stdin);
	input();
	init();
	work();
	return 0;
}
```

这份代码在 LOJ 上可以通过，但是在洛谷上无法通过...

如果有人知道什么高妙的卡常方法，请务必告诉我。

---

## 作者：chenxia25 (赞：10)

没啥营养的状压DP。

>### [洛谷题目页面传送门](https://www.luogu.com.cn/problem/P6622)

>题意见洛谷。（以下用$s$表示题目中的$k$）

先预处理出$cnt_{i,j}=\sum\limits_{k=1}^{n-1}[S_k=i][S_{k+1}=j]$。然后设位置$i$是$id_i$号信号站，推一波$\sum$算出每个位置对答案的贡献：

$$\begin{aligned}ans&=\sum_{i=1}^m\sum_{j=i+1}^mcnt_{id_i,id_j}(j-i)+\sum_{i=1}^m\sum_{j=1}^{i-1}cnt_{id_i,id_j}s(i+j)\\&=\sum_{i=1}^m-i\sum_{j=i+1}^mcnt_{id_i,id_j}+\sum_{i=1}^mi\sum_{j=1}^{i-1}cnt_{id_j,id_i}+s\sum_{i=1}^mi\sum_{j=1}^{i-1}cnt_{id_i,id_j}+s\sum_{i=1}^mi\sum_{j=i+1}^mcnt_{id_j,id_i}\\&=\sum_{i=1}^mi\left(\sum_{j=i+1}^m\left(s\cdot cnt_{id_j,id_i}-cnt_{id_i,id_j}\right)+\sum_{j=1}^{i-1}\left(s\cdot cnt_{id_i,id_j}+cnt_{id_j,id_i}\right)\right)\end{aligned}$$

然后就有一个很显然的基于位置的状压DP了。设$dp_{i}$表示考虑到第$|i|$位，前$|i|$位的信号站编号集合为$i$时的最小总贡献。边界：$dp_{\varnothing}=0$，目标：$dp_{[1,m]\cap\mathbb Z}$。

令

$$val_{i,j}=\sum_{k\notin j,k\neq i}\left(s\cdot cnt_{id_k,id_i}-cnt_{id_i,id_k}\right)+\sum_{k\in j}\left(s\cdot cnt_{id_i,id_k}+cnt_{id_k,id_i}\right)$$

它可以通过先预处理$\forall i\in[1,m],val_{i,\varnothing}$，剩下的拎出来一个$\mathrm{lowbit}$来$\mathrm O(1)$转移来求出，时间复杂度$\mathrm O(2^mm)$。

那么状态转移方程：

$$dp_{i}=\min_{j\in i}\!\left\{dp_{i-\{j\}}+|i|val_{j,i-\{j\}}\right\}$$

如此，总时空复杂度皆为$\mathrm O(2^mm)$。

至此是我在考场上的做法，$80\mathrm{pts}$，因为空间会爆炸，一个$val$数组大概是$700$多$\mathrm{MB}$。考虑优化。

注意到转移方程里的$val_{j,i-\{j\}}$，不难发现若$x\in y$，那么$val_{x,y}$是不可能被用到的。这样一来，若只存会被用到的，空间立刻减半，能过。可转移性也很显然。实现也很简单，只需要让每个$j$的末$i-1$位原封不动，其他的位拆出来右移$1$位，再拼起来即可。

关于卡空间，还有很多的奇技淫巧可以把空间卡的很小很小，不过研究这个也没啥意义了（

代码（开洛谷自带O2才能过（似乎洛谷机+O2=CCF机？））：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=INT_MAX;
int lowbit(int x){return x&-x;}
const int M=23;
int n,m,s;
int cnt[M][M];
int val[M][1<<M-1];//卡空间 
int dp[1<<M];
int main(){
	cin>>n>>m>>s;
	int las;
	for(int i=1;i<=n;i++){
		int x;
		scanf("%d",&x);
		x--;
		if(i>1)cnt[las][x]++;//预处理cnt 
		las=x;
	}
	for(int i=0;i<m;i++){
		for(int k=0;k<m;k++)if(k!=i)val[i][0]+=s*cnt[k][i]-cnt[i][k];//预处理j=0的情况 
		for(int j=1;j<1<<m;j++)if(!(j&1<<i)){
			int x=j^lowbit(j),y=__builtin_ffs(j)-1; 
			val[i][(j&(1<<i)-1)+((j^j&(1<<i)-1)>>1)]=val[i][(x&(1<<i)-1)+((x^x&(1<<i)-1)>>1)]+(s*cnt[i][y]+cnt[y][i])-(s*cnt[y][i]-cnt[i][y]);//递推 
		}
	}
	for(int i=1;i<1<<m;i++){
		dp[i]=inf;
		int ppc=__builtin_popcount(i);
		for(int j=0;j<m;j++)if(i&1<<j){
			int x=i^1<<j;
			dp[i]=min(dp[i],dp[i^1<<j]+ppc*val[j][(x&(1<<j)-1)+((x^x&(1<<j)-1)>>1)]);//转移方程 
		}
	}
	cout<<dp[(1<<m)-1];
	return 0;
}
```

---

## 作者：Krystallos (赞：9)

考点：状态压缩动态规划

首先看一眼数据范围，$2 \leq M \leq 23$，$2 \leq N \leq 10^5$，$1 \leq k \leq 100$，可以考虑一下对 $M$ 进行状态压缩。动态规划时从左往右依次讨论这个位置放置几号信号站，状态 $S$ 的第 $i - 1$ 位为 $1$ 则说明第 $i$ 个信号站已经被决定了，$f[S]$ 记录一下已有集合 $S$ 时可决定的最小传递，每次递推时讨论将一个不属于 $S$ 的信号站放在右侧。最终答案为 $f[(1 << m) - 1]$。

接下来讲述如何将 $f[S]$ 递推至 $f[S \cup p]$。

当在第 $|S| + 1$ 位安排信号站 $p$ 时，需要加上 $S$ 中需要向 $p$ 发送信号的信号站产生的代价，还需要加上 $p$ 需要向 $S$ 中的信号站发送信号产生的代价（当然这种传递是需要经过控制塔中转的）。然而我们并没有记录 $S$ 中各个信号站的具体位置。

这时我们可以考虑拆分每一次发送信号，$p$ 向右发送信号到 $q$ 用的时间可以视作一个虚构的左侧信号站（以下假设这个虚构的信号站处于控制塔的位置，即 $0$）向 $q$ 发信号的时间减去这个虚构信号站向 $p$ 发信号的时间；向左发信号则更好理解，可以视作先向左发信号到控制塔再由控制塔向右发信号到目标信号站。~~题目不是本来就这个意思吗~~

因此我们将信号站 $p$ 加入集合 $S$ 时可以这样操作：先减去 $p$ 向右发信号的数量乘以 $p$ 到虚拟信号站的距离，再加上 $p$ 从左接受信号的数量乘以 $p$ 到虚拟信号站的距离，再加上由 $p$ 发出或接收的向左信号数量乘以 $p$ 到控制塔的距离再乘上 $k$。

于是我们可以写出动规代码如下：

```cpp
for (int now = 0; now < (1 << m); now++) {//当前状态为now
    int w = init(now) + 1;//init的作用是求出now的二进制位里有多少个1，w为下一个信号站该放的位置
    long long step = 0;
    for (int p = 1; p <= m; p++) {//依次讨论这里放哪个信号站
        if (now & (1 << p - 1))//如果已经被now包含直接过
            continue;
        step = 0;
        for (int q = 1; q <= m; q++) {
            if (((now & (1 << q - 1)) == 0) && q != p) {//q不属于now，即q在p右侧
                step -= nxt[p][q] * w;//减去 p 向右发信号的数量乘以 p 到虚拟信号站的距离
                step += nxt[q][p] * w * k;//加上由 q 向左发信号的数量乘上 p 到控制塔的距离再乘上 k
            }
        }
        for (int q = 1; q <= m; q++) {
            if ((now & (1 << q - 1)) && q != p) {//q属于now，即q在p左侧
                step += nxt[q][p] * w;//加上 p 从左接受信号的数量乘以 p 到虚拟信号站的距离
                step += nxt[p][q] * w * k;//加上 p 从右侧接收信号的数量乘上 p 到控制塔的距离再乘上 k
            }
        }
        if (f[now | (1 << p - 1)] > f[now] + step)//如果更优则更新答案
            f[now | (1 << p - 1)] = f[now] + step;
    }
}
```

写出来一交，TLE30。

稍微数一下循环就可以得知，这个动归时间复杂度为 $O(m ^2 2 ^ m)$，只能过30%的数据。

怎么办呢？我们可以考虑预处理每个 p 对于之前的状态 S 递推时需要增减的数量，但是预处理时间复杂度依然是 $O(m ^2 2 ^ m)$。这时将状态 S 拆成前后两段预处理存在两个数组里，这时就只需要 $O(m ^ 2 2 ^ {\frac{m}{2}})$ 的时间就好了。

$pro[t][S_t][p]$ 存储的是 $p$ 对于之前的状态 $S_t$ 递推时需要增减的数量， $t$ 为 $0$ 则表示存的是前半段，$1$ 就是后半段，调用时只需要将 $pro[0][S_0][p]$ 和 $pro[1][S_1][p]$ 加起来乘上 $p$ 被放的位置 $w$ 即可替换掉上面那份代码的枚举 $q$ 的两个循环。

预处理代码如下：
```cpp
int len = m >> 1;//后半段长度
for (int p = 1; p <= m; p++)
    for (int S = 0; S < (1 << len); S++)
        for (int q = 1; q <= len; q++) {
            if (((S & (1 << q - 1)) == 0) && q != p)//把先前动规的枚举循环放到这就好，w 动规的时候再去乘
                pro[0][S][p] += nxt[q][p] * k - nxt[p][q];
            if ((S & (1 << q - 1)) && q != p)
                pro[0][S][p] += nxt[q][p] + nxt[p][q] * k;
        }
for (int p = 1; p <= m; p++)
    for (int S = 0; S < (1 << n); S += 1 << len)
        for (int q = len + 1; q <= m; q++) {
            if (((S & (1 << q - 1)) == 0) && q != p)
                pro[1][S >> len][p] += nxt[q][p] * k - nxt[p][q];
            if ((S & (1 << q - 1)) && q != p)
                pro[1][S >> len][p] += nxt[q][p] + nxt[p][q] * k;
        }
```

动规代码如下：
```cpp
memset(f, 0x3f, sizeof(f));
f[0] = 0;
for (int now = 0; now < (1 << n); now++) {
    int w = init(now) + 1;
    long long step = 0;
    for (int p = 1; p <= n; p++) {
        if (now & (1 << p - 1))
            continue;
        step = (pro[0][now & ((1 << len) - 1)][p] + pro[1][now >> len][p]) * w;//替换掉那两个循环就好，w拿到这里来乘
        if (f[now | (1 << p - 1)] > f[now] + step)
            f[now | (1 << p - 1)] = f[now] + step;
    }
}
```

~~我太菜了没去打省选，这题硬是在机房想了大半天~~

---

## 作者：GK0328 (赞：8)

#### [Luogu6622 [省选联考 2020 A/B 卷] 信号传递](https://www.luogu.com.cn/problem/P6622)

蒟蒻用**模拟退火**$A$了此题。

我们先把给出的$S$序列拆开，就可以转化成$m^2$个二元组$(x,y)$（指从$x$向$y$的传递），对于一组排列，我们只需要计算这些二元组之间的贡献即可。

容易发现本题中$m$很小，然而题目需要的是排列，很难维护。

同时我们看到，当我们交换排列中两个数时，更改答案的时间复杂度是$O(m)$的。

具体来说，我们交换$x,y$的位置，需要先取消$x,y$的影响，也就是把从$x,y$出发的贡献和到达$x,y$的贡献删去。

需要注意的是，$x,y$之间的贡献会被减去两次，所以最后需要加回来。

重新添加$x,y$并加入贡献，原理与上面相同。

具有这样良好的性质，我们就可以**模拟退火**啦！

由于本人是随机化蒟蒻，调参调了半天。

交代一下蒟蒻在调参时的经验：

一开始蒟蒻调参一直调到$85$分，就再也上不去了，得分开始降低。

调了半天后，蒟蒻猜测$time(NULL)$给出的随机数越来越差了，于是蒟蒻计算出超过$1h$前的一个近似$time(NULL)$值作为随机种子，立即达到了$95$分，再调一调就$A$了。

$Code:$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#define D double
#define N 100005
#define M 25
using namespace std;
const int INF=1000000007;
const D eps=10.0;
int n,m,k,s[N],c[M],R[M][M];
int nans=0,ans=INF;
int dis(int x,int y)
{
    return (x<y)?(y-x):(x+y)*k;
}
void Del(int x)
{
    for (int i=1;i<=m;++i)
        if (i!=x)
        {
            nans-=R[x][i]*dis(c[x],c[i]);
            nans-=R[i][x]*dis(c[i],c[x]);
        }
}
void Ins(int x)
{
    for (int i=1;i<=m;++i)
        if (i!=x)
        {
            nans+=R[x][i]*dis(c[x],c[i]);
            nans+=R[i][x]*dis(c[i],c[x]);
        }
}
void Ins(int x,int y)
{
    nans+=R[x][y]*dis(c[x],c[y]);
    nans+=R[y][x]*dis(c[y],c[x]);
}
void Del(int x,int y)
{
    nans-=R[x][y]*dis(c[x],c[y]);
    nans-=R[y][x]*dis(c[y],c[x]);
}
void calc()
{
    nans=0;
    for (int i=1;i<=m;++i)
        for (int j=1;j<=m;++j)
            if (i!=j)
                nans+=R[i][j]*dis(c[i],c[j]);
    ans=min(ans,nans);
}
void SA()
{
    calc();
    D T=1014919.1919191919191,Jw=0.99992919191;
    while (T>eps)
    {
        int x=rand()%m+1,y=rand()%m+1;
        while (x==y)
            x=rand()%m+1,y=rand()%m+1;
        int rans=nans;
        Del(x),Del(y),Ins(x,y);
        swap(c[x],c[y]);
        Ins(x),Ins(y),Del(x,y);
        int del=nans-rans;
        if (del<0)
            ans=min(ans,nans); else
        if (exp(-del/T)*RAND_MAX<=rand())
            nans=rans,swap(c[x],c[y]);
        T*=Jw;
    }
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    if (n==1)
    {
        puts("0");
        return 0;
    }
    for (int i=1;i<=n;++i)
        scanf("%d",&s[i]);
    for (int i=1;i<n;++i)
        ++R[s[i]][s[i+1]];
    for (int i=1;i<=m;++i)
        c[i]=i;
    if (m==22)
        srand(1609745218); else
        srand(1609745220);
    for (int i=1;i<=60;++i)
        SA();
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：_虹_ (赞：6)

一道奇特的状压dp。

分享一个$O(m^22^{m/2+1}+m2^m)$的做法。

首先m<=23，考虑做状压dp。

对于x前往y：

1. x在左侧，提供$-p_x$的代价，在右侧，提供$p_x*k$的代价。

2. y在左侧，提供$p_y*k$的代价，在右侧，提供$p_y$代价。

可以发现，每种移动中，两端点提供的代价只和方向和端点位置有关，与距离无关。对于点x，贡献为$p_x*(-1*a+1*b+k*c)$，abc为三类代价产生次数

显然的，有朴素dp：f(i,s)表示放了前i个位置，放置集合为s。转移为(i,s)=min(f(i-1,s^bit(x)+cost(x,s^bit(x)*i)(bit(x)&s!=0)。时间复杂度$O(m^32^m)$

依靠想象力，我们可以意识到，对于某一点x，其他点之间的位置关系不影响x产生的代价。

我们考虑预处理节点x与所有s产生的贡献，令cost函数变为常数时间。
那么我们有预处理$O(m^22^m)$，dp$O(m^22^m)$.

然后你算一下就发现他卡内存，你根本开不下$m2^m$的数组（dp你可以滚动数组）。

？？？？？

那么我们退而求其次，考虑分组预处理，设每组有k个节点，则有t=m/k（上取整）组。
我们有预处理$O(tm^22^k)$+dp$O(tm^22^m)$，

显然复杂度瓶颈是dp，那么t取2最佳，此时k取12。

这也不行啊这不是连20都跑不过去吗？

~~努力全部木大~~ 不要停下来啊。

每次转移已经非常优秀($O(m)$)，考虑优化dp状态数。

显然大量的状态是冗余的，只有那些i==count(s)的状态才有意义。

那我们可以直接去掉i这一维，因为他其实可以被s表达出来。

那我们有转移方程f(s)=min(f(s^bit(x)+cost(x,s^bit(x)*count(s))(bit(x)&s!=0).

时间复杂度为$O(tm2^m)==O(m2^{m+1})$，预处理count(s)可以卡常，方法同预处理cost。

对于x不属于s，我们考虑跳过x。

预处理2^i对应的i，对于枚举的状态s，直接lowbit后查表得到对应的i；

我们有复杂度$O(tm\sum\limits_{s=1}^{2^m}count(s))$.

即$O(tm2^{m-1})==O(m2^m)$

考场降智想到最后的优化没算清楚就没有写。

放一个$O(m2^m)$代码（其实和$O(m2^{m+1})$就差几行）

```cpp
#include <iostream>
using namespace std;
const int kmaxs=1<<23;
const int kmaxb=13;
const int kmaxbs=1<<kmaxb;
const int kmaxn=24;
const int kmaxm=100000+5;
const int s2b=12;
const int s1b=0;
const int inf=1e9;
int dp[kmaxs+10];
int t1[kmaxbs][kmaxn];
int t2[kmaxbs][kmaxn];
int a[kmaxm];
int cnt[kmaxn][kmaxn];
int valyx[kmaxn][kmaxn];
int valxy[kmaxn][kmaxn];
int pos[kmaxbs];
char hsh[kmaxs]; 
int n,m;
int K;
int s1,s2;
#define bit(x) (1<<((x)-1))
#define cal_yx(x,y) (valyx[(x)][(y)])
#define cal_xy(x,y) (valxy[(x)][(y)])
/*
int cal_yx(int x,int y)
{
	return cnt[y][x]+cnt[x][y]*K;
}
int cal_xy(int x,int y)
{
	return cnt[x][y]*-1+cnt[y][x]*K;
}*/
int cal(int s,int x,int ts,int bs)
{
	int r=0;
	int y=0;
	for(int i=1;i<=ts;++i)
	{
		y=bs+i;
		if(x==y)continue;
		if(bit(i)&s)//got
		{
			r+=cal_yx(x,y);
		}
		else
		{
			r+=cal_xy(x,y);
		}
	}
	return r;
}
inline int cost2(int x,int s)
{
	int st1=s&((1<<s1)-1);
	s>>=s1;
	int st2=s&((1<<s2)-1);
	return t1[st1][x]+t2[st2][x];
}
inline int my_count(int s)
{
	int st1=s&((1<<s1)-1);
	s>>=s1;
	int st2=s&((1<<s2)-1);
	return pos[st1]+pos[st2];
}
#define lowbit(x) ((x)&(-(x)))
void solve2()
{
	s1=s2b;
	s2=n-s1;
	int c=0;
	for(int s=0;s<(1<<s1);++s)
	{
		c=0;
		for(int k=1;k<=n;++k)
		{
			if(bit(k)&s)
			{
				++c;
				continue;
			}
			t1[s][k]=cal(s,k,s1,s1b);
		}
		pos[s]=c;
	}
	for(int s=0;s<(1<<s2);++s)
	{
		for(int k=1;k<=n;++k)
		{
			if((k>s2b)&&(bit(k-s2b)&s))
				continue;
			t2[s][k]=cal(s,k,s2,s2b);
		}
	}
	int p=0,i;
	for(int s=1;s<(1<<n);++s)
	{
		dp[s]=inf;
		p=my_count(s);
		for(int j=s;j;j-=lowbit(j))
		{
			i=hsh[lowbit(j)];
			dp[s]=min(dp[s],dp[s^bit(i)]+(p)*cost2(i,s^bit(i)));
		}
	}
}
int cost1(int x,int s)
{
	int r=0;
	for(int y=1;y<=n;++y)
	{
		if(y==x)continue;
		if(s&bit(y))//yx
		{
			r+=cal_yx(x,y);
		}
		else
		{
			r+=cal_xy(x,y);
		}
	}
	return r;
}
void solve1()
{
	int p=0;
	for(int s=1;s<(1<<n);++s)
	{
		dp[s]=inf;
		p=0;
		for(int i=1;i<=n;++i)
		{
			if(s&bit(i))
				++p;
		}
		for(int i=1;i<=n;++i)
		{
			if(s&bit(i))
			{
				dp[s]=min(dp[s],dp[s^bit(i)]+p*cost1(i,s^bit(i)));
			}
		}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin>>m>>n>>K;
	for(int i=1;i<=m;++i)
	{
		cin>>a[i];
		if(i>1)
			cnt[a[i-1]][a[i]]++;
	}
	for(int x=1;x<=n;++x)
	{
		hsh[bit(x)]=x;
		for(int y=1;y<=n;++y)
		{
			if(x==y)continue;
			valyx[x][y]=cnt[y][x]+cnt[x][y]*K;
			valxy[x][y]=(-cnt[x][y])+cnt[y][x]*K;
		}
	}
	if(n<=12)
	{
		solve1();
	}
	else
	{
		solve2();
	}
	cout<<dp[(1<<n)-1]<<'\n';
	return 0;
}
```
在luogu上不吸氧也只能跑80，但吸氧之后最慢点0.6s。。。

可能是写丑了常数太大。

//之前睿智了把题解交到d1t1了，靴靴管理员给移动过来。。。。

---

## 作者：Varuxn (赞：5)

## [洛谷 P6622 [省选联考 2020 A/B 卷] 信号传递](https://www.luogu.com.cn/problem/P6622)

## 背景

某次模拟赛的T2，考场上懒得想正解 ~~（其实是不会QAQ）~~，
打了个暴力就骗了30pts 就火速溜了，参考了一下[某位强者的题解](https://www.luogu.com.cn/blog/Chenxiao-Yan/Luogu-P6622) 
大概懂了一点思路，有**亿**点毒瘤。。。

数据范围是m<=23	的 明显是个**状压**么！！！

## 题解

### 数组代表意义

1. 令f[i]表示，当已经确定的信号站集合为i时，此时已确定花费的最小值是多少。

	此时考虑两个转移:

	* 将左向右方向中继变换为先由初始节点中继到0号节点，再由0号节点中继到目标节点

	*  将从右向左的中继变换为初始节点以−1的花费中继到0号节点，再由0号节点中继到目标节点

2. $cnt_{i,j}=x$表示有x个需要从i转移到j

3. val的含义在下文中给出,这里需要注意一下val的空间$M*(2^{M-1})$刚刚好，不要开太大，否则会MLE

4. las表示上一个的坐标，用来更新cnt值

### 初始化
*	拿cnt[i][j]存一下从i到j的总数，也就是下面这个式子：

	$cnt_{i,j}= \sum_{k=1}^{n-1} [S_k=i][S_{k+1}=j] $

### 算法主体

1. ####  式子推算
	对于题面推算一下每个位置对于最终答案的加值,如下：

	$\begin{aligned}ans&=\sum_{i=1}^m\sum_{j=i+1}^mcnt_{id_i,id_j}(j-i)+\sum_{i=1}^m\sum_{j=1}^{i-1}cnt_{id_i,id_j}K*(i+j)\\&=\sum_{i=1}^m-i\sum_{j=i+1}^mcnt_{id_i,id_j}+\sum_{i=1}^mi\sum_{j=1}^{i-1}cnt_{id_j,id_i}+K*\sum_{i=1}^mi\sum_{j=1}^{i-1}cnt_{id_i,id_j}+K*\sum_{i=1}^mi\sum_{j=i+1}^mcnt_{id_j,id_i}\\&=\sum_{i=1}^mi\left(\sum_{j=i+1}^m\left(K\cdot cnt_{id_j,id_i}-cnt_{id_i,id_j}\right)+\sum_{j=1}^{i-1}\left(K\cdot cnt_{id_i,id_j}+cnt_{id_j,id_i}\right)\right)\end{aligned}$

2. #### 时空简化
	然后，用val[i][j]简化一下上面的式子

	$vaj_{i,j}=\sum_{k\notin,k!=i}(K*cnt_{id_k,id_i}-cnt_{id_i,id_k})+\sum_{k\in j}(K*cnt_{id_i,id_k}+cnt_{id_k,id_i})$

	* ##### 注意
		在处理val数组时可以发现对于1～i-1状态的是没有必要变动的，
		因此只需要将i之后的更改可以了
3. #### 状压二进制表示
	(j& ( (1<<i)-1)
	表示前1～i-1状态不变

	((j^(j&((1<<i)-1)))>>1)
	表示对于i+1～n状态更新，向右移一位

	更改时要从j状态除去一个lowbit转移过来原因见上，
	剩下的就是关于上面公式的使用了

## $code$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=23;
int n,m,K,las,cnt[M+5][M+5],val[M+5][1<<(M-1)],f[1<<M];
int lowbit(int x)
{
	return x&(-x);
}
int main()
{
	scanf("%d%d%d",&n,&m,&K);
	for(int i=1,x;i<=n;i++)
	{
		scanf("%d",&x);
		x--;
		if(i>1)
			cnt[las][x]++;
		las=x;
	}
	for(int i=0;i<m;i++)
	{
		for(int j=0;j<m;j++)//对于0状态进行初始化
			if(j!=i)
				val[i][0]+=K*cnt[j][i]-cnt[i][j];
		for(int j=1;j<(1<<m);j++)//更新后面状态
			if(!(j&(1<<i)))
			{
				int x=j^lowbit(j),y=__builtin_ffs(j)-1;//求最后一位1
				val[i][(j&((1<<i)-1))+((j^(j&((1<<i)-1)))>>1)]=val[i][(x&((1<<i)-1))+((x^(x&((1<<i)-1)))>>1)]+K*cnt[i][y]+cnt[y][i]+cnt[i][y]-K*cnt[y][i];
			}
	}
	for(int i=1;i<(1<<m);i++)
	{
		f[i]=INT_MAX;//初始化赋最大值
		int sum=__builtin_popcount(i);//求i状态中1的数量
		for(int j=0;j<m;j++)
			if(i&(1<<j))
			{
				int x=i^(1<<j);
				f[i]=min(f[i],f[x]+sum*val[j][(x&(1<<j)-1)+((x^x&(1<<j)-1)>>1)]);
			}
	}
	printf("%d",f[(1<<m)-1]);
	return 0;
}
```
完结撒花QAQ,为体贴的管理大大点赞。

被拒绝题解原因是“未按规定排版”的同学，可以参考[**公告**](https://studyingfather.blog.luogu.org/blog-written-guide)

~~**鬼知道我因为这事调了多长时间**~~

---

## 作者：ztyqwq (赞：4)

首先考虑$30$%数据。  
直接$O(m!)$暴力枚举每一个可能的排序方式，然后对于每一种排序方式$O(n)$计算所需时间，总复杂度$O(m!\cdot n)$。一个小优化是如果先$O(n)$将序列转换为$m\times m$的矩阵，$mp[i][j]$表示有多少次从$i$传输到$j$，那么每次计算复杂度降为$O(m!\cdot m^2)$，尽管这个优化无法获得更多得分，但是我们发现，算法的复杂度至此瓶颈已与$n$无关。

------------

对于$60$%到$70$%的数据。  
我们依据数据可以猜测到这道题是$2^m$有关的算法，考虑状态压缩和动态规划。经过上面的变换以后，可以想到一下的转移方程。  
令$f[S]$表示，当已经确定的信号站集合为$S$时，此时已确定花费的最小值是多少。此时考虑两个变换方式，将左向右方向中继变换为先由初始节点中继到$0$号节点，再由$0$号节点中继到目标节点；将从右向左的中继变换为初始节点以$-1$的花费中继到$0$号节点，再由$0$号节点中继到目标节点，转移方程如下：
$$
f[S+i]=f[S]+\left|S+i\right|\sum_{j\in S}\left(mp[j][i]+k\cdot mp[i][j]\right)+\left|S+i\right|\sum_{j\notin \{S+i\}}\left(-mp[i][j]+k\cdot mp[j][i]\right)
$$
直接进行状态压缩$dp$，复杂度为$O(2^m\cdot m^2)$，预计得分波动在$60%$~$70%$左右。

------------

对于$100$%的数据。  
复杂度需要扔掉一个$O(m)$，考虑预处理
$$
\left|S+i\right|\sum_{j\in S}\left(mp[j][i]+k\cdot mp[i][j]\right)+\left|S+i\right|\sum_{j\notin \{S+i\}}\left(-mp[i][j]+k\cdot mp[j][i]\right)
$$
将其记录在$cst[S][i]$中，每次转移复杂度变为$O(1)$，预处理复杂度可以做到$O(2^m\cdot m)$，整体复杂度$O(2^m\cdot m)$。  
$cst$预处理初始值方程：
$$
cst[0][i]=\sum_{j\in \complement_U\{i\}}\left(k\cdot mp[j][i]-mp[i][j]\right)
$$
$cst$预处理转移方程为：
$$
cst[S+p][i]=cst[S][i]+mp[p][i]+k\cdot mp[i][p]+mp[i][p]-k\cdot mp[p][i]
$$
至此，我们可以写出$O(2^m\cdot m)$的算法，但是如果就这样提交的话，我们会发现  
$$
MLE
$$
$cst$的理论最高复杂度为$O(2^m\cdot m)$明显超过512M的内存限制，但是我们发现，cst[S][i]中，一般的状态为废弃状态，$i\notin S$的$cst$才有意义，所以我们可以扔掉一半状态，最终$2^{22}\times 23$约为$320M$可以满足内存限制。  
此时，可以AC此题，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 100100;
const int MAXM = 23;
const int MAX_PWR = 1 << 23;
const int MIN_PWR = 1 << 22;
const int INF = 0x3f3f3f3f;

int n, m, kx, arr[MAXN], mp[MAXM][MAXM];
int lgx[MAX_PWR], cnt[MAX_PWR];
int cst[MIN_PWR][MAXM], f[MAX_PWR];

inline int lowbit(int x){return x & (-x);}
inline void init(){
	memset(cst, 0, sizeof(cst));
	for(int i = 0; i < m; i++)
		for(int j = 0; j < m; j++)
			if(i != j) cst[0][i] += kx * mp[j][i] - mp[i][j];
	for(int i = 0; i < m; i++)
		for(int j = 1; j < (1 << (m - 1)); j++){
			int lb = lowbit(j), pos = lgx[lb] + (lgx[lb] >= i);
			cst[j][i] = cst[j ^ lb][i] + (1 - kx) * mp[pos][i] + (kx + 1) * mp[i][pos];
		}
}

int main(){
	scanf("%d %d %d", &n, &m, &kx);
	for(int i = 1; i <= n; i++) scanf("%d", &arr[i]);
	memset(mp, 0, sizeof(mp));
	for(int i = 2; i <= n; i++) mp[arr[i - 1] - 1][arr[i] - 1]++;
	lgx[0] = -1; for(int i = 1; i < (1 << m); i++) lgx[i] = lgx[i >> 1] + 1;
	cnt[0] = 0; for(int i = 1; i < (1 << m); i++) cnt[i] = cnt[i >> 1] + (i & 1);
	init();
	
	f[0] = 0;
	for(int i = 1; i < (1 << m); i++){
		f[i] = INF;
		for(int tmps = i, j; j = lowbit(tmps); tmps ^= j){
			int pos = lgx[j], siz = cnt[i], ori = i ^ j;
			f[i] = min(f[i], f[ori] + siz * cst[((ori >> (pos + 1)) << pos) | (ori & (j - 1))][pos]);
		}
	}
	printf("%d\n", f[(1 << m) - 1]);
	return 0;
}
```

---

## 作者：suyue1098765432 (赞：4)

根据题意，可以知道从信号从x传递到y的代价为：
$$
f(x)=\left\{
\begin{aligned}
y-x &\space\space\space\space (x<y)    \\
(x+y)*k & \space\space\space\space(x>y)    \\
0 & \space\space\space\space(x=y) \\
\end{aligned}
\right.
$$
这样只用开一个数组$js[x,y]$表示从x到y有几次传递。


然后状压dp求出答案。但如果每次转移都计算代价的话时间复杂度是$O(n^2*2^n)$,只能拿到$60$-$70$的分数。

- 时间优化1：

可以考虑预处理数组$sl[S,j,p]$代表从集合$S$有p个数，转移到集合$S\cup j$的代价。

那么枚举每一位$h(h<>j)$，代价应加上，
$$
g(x)=\left\{\begin{aligned}js[h,j]*p+js[j,h]*k*p &\space\space\space\space (j\in S)    \\js[h,j]*k*p-js[j,h]*p & \space\space\space\space(j\notin S)    \\\end{aligned}\right.
$$

但这样空间复杂度是$O(n^2*2^n)$，明显会超空间，考虑空间优化。

- 空间优化1：

考虑到$g(x)$的每一项里都有一个$p$，那么可以将$p$提出来，只预处理$sl[S,j]$每次用的时候在乘$p$。

这样空间复杂度是$O(n*2^n)$，能拿80分。

- 空间优化2：

可以折半保存数据，即把这$n$个数拆成前后个$n/2$数，用$s1[S,j]$表示前$n/2$个数的代价，$s2[S,j]$代表后$n/2$个数的代价，转移时计算这两部分和，虽然这样会增加常数，但可以减少空间。

这样空间复杂度是$O(2*n*2^{n/2}+2^n)$，时间复杂度是$O(n^2*2^{n/2}+n*2^n)$，可以通过此题。

(好像这样就不用空间优化1也能过)

code：

Pascal：

```pascal

program transfer; 
const
    maxn1=16777216;
    maxn2=8192;
var
    js:array[0..25,0..25]of longint;
    dp:array[0..maxn1]of int64;
    s1,s2:array[0..maxn2,0..23]of int64;
    sk:int64;
    n,len1,len2:integer;
    m:longint;
function minn(x,y:int64):int64;
begin
    if x<y then exit(x)
    else exit(y);
end;
var
    j,p1,p2,js1,h:integer;
    i:longint;
begin
    read(m,n,sk);
    if n=1 then begin writeln(0);exit;end;
    len2:=n div 2;len1:=n-len2;
    read(p1);
    p1:=p1-1;
    for i:=1 to m-1 do begin
      read(p2);
      p2:=p2-1;
      js[p1,p2]:=js[p1,p2]+1;
      p1:=p2;
    end;
    for j:=0 to n-1 do
        for i:=0 to ((longint(1) shl len1)-1) do
            if(j<len2)or(((longint(1) shl (j-len2))and i)=0)then
                for h:=0 to len1-1 do if h+len2<>j then begin
                    if ((longint(1) shl h)and i)<>0 then
                        s1[i,j]:=s1[i,j]+js[h+len2,j]+js[j,h+len2]*sk
                   else s1[i,j]:=s1[i,j]+js[h+len2,j]*sk-js[j,h+len2];
                end;
    for j:=0 to n-1 do
        for i:=0 to ((longint(1) shl len2)-1) do
            if(j>=len2)or(((longint(1) shl j)and i)=0)then
                for h:=0 to len2-1 do if h<>j then begin
                    if ((longint(1) shl h)and i)<>0 then
                        s2[i,j]:=s2[i,j]+js[h,j]+js[j,h]*sk
                   else s2[i,j]:=s2[i,j]+js[h,j]*sk-js[j,h];
                end;
    for i:=1 to (longint(1) shl n)-1 do dp[i]:=9223372036854775807;
    for i:=0 to (longint(1) shl n)-1 do begin
        js1:=0;
        for j:=0 to n do if ((longint(1) shl j)and i)<>0 then js1:=js1+1;
        for j:=0 to n do if ((longint(1) shl j)and i)=0 then
            dp[i or (longint(1) shl j)]:=minn(dp[i or (longint(1) shl j)],(dp[i]+
            int64(s1[(i shr len2),j]+s2[i and((longint(1) shl len2)-1),j])*int64(js1+1)));
    end;
    writeln(dp[(longint(1) shl n)-1]);
end.

```

C：

```c
#include<stdio.h>
int js[25][25];
long long dp[1<<23],s1[1<<12][23],s2[1<<12][23],sk;
int m,n,len1,len2;
int read(){
	int res=0,zf=1;char ch;
	while((ch=getchar())<48||ch>57)if(ch=='-')zf=!zf;res=(ch^48);
	while((ch=getchar())>=48&&ch<=57)res=(res<<3)+(res<<1)+(ch^48);
	return zf?res:(-res);   
}
long long minn(long long x,long long y){return x<y?x:y;} 
int main(){
	m=read();n=read();sk=read();
	if(n==1){printf("0\n");return 0;} 
	int p1=read()-1;
	len2=n/2;len1=n-len2;
	for(int i=1;i<m;i++){
		int p2=read()-1;
		js[p1][p2]++;
		p1=p2;
	}
	for(int j=0;j<n;j++)
		for(int i=0;i<(1<<len1);i++)if(j<len2||((1<<(j-len2))&i)==0){
			for(int h=0;h<len1;h++)if(h+len2!=j) 
				if((1<<h)&i)s1[i][j]+=js[h+len2][j]+js[j][h+len2]*sk;
				else s1[i][j]+=js[h+len2][j]*sk-js[j][h+len2];
		}
	for(int j=0;j<n;j++)
		for(int i=0;i<(1<<len2);i++)if(j>=len2||((1<<j)&i)==0){
			for(int h=0;h<len2;h++)if(h!=j) 
				if((1<<h)&i)s2[i][j]+=js[h][j]+js[j][h]*sk;
				else s2[i][j]+=js[h][j]*sk-js[j][h];
			}
	for(int i=1;i<(1<<n);i++)dp[i]=0x7fffffffffffffffll;			
	for(int i=0;i<(1<<n);i++){ 
		int js1=0;
		for(int j=0;j<n;j++)if((1<<j)&i)js1++;
		for(int j=0;j<n;j++)if(!((1<<j)&i))
			dp[i|(1<<j)]=minn(dp[i|(1<<j)],dp[i]+(s1[i>>len2][j]+s2[i&((1<<len2)-1)][j])*(js1+1));
		}
	printf("%lld",dp[(1<<n)-1]);
	return 0;
}

```

由于个人水平有限，如果有问题还请各位dalao不吝赐教，感谢dalao支持。

---

## 作者：SDNetFriend (赞：2)

## P6622 [省选联考 2020 A/B 卷] 信号传递

[题面在这里](https://www.luogu.com.cn/problem/P6622)

由于 $n\leq 23$ 考虑状压，重点在于类似的题可以写出贡献表达式后可以单独考虑贡献

对于本题，对于一次传递 $u\to v$ ，产生代价有两种情况

1. $pos_u<pos_v$  $C=pos_u-pos_v$
2. $pos_u>pos_v$  $C=k\times (pos_u+pos_v)$

并且，为了进行状压，我们需要对每个点确定一种 $0-1$ 状态来确定贡献

思考过后我们发现对于一个点的贡献只与坐标比它小与比它大的点分别是什么唯一确定

这样我们可以设 $S$ 表示在当前考虑点前面的点的集合，设 $g(i,S)$ 表示点 $i$ 前面点的集合是 $S$ 时的贡献，设 $f(S)$ 表示考虑了 $S$ 的答案

就可以有转移
$$
f(S+\{i\})=f(S)+g(i,S)
$$
如此一来预处理 $g$ 即可，具体处理为从小到大枚举集合  $S$ ，转移相当于不断把后面的点挪到前面去，初始贡献为所有点都在后头时的贡献

注意这里计算 $g$ 时是不考虑当前这个点的位置的，因为每个点最终的贡献都要乘上自己的位置，这样我们在计算 $f$ 的时候乘上就可以了

另外这里的集合是不包含当前点的，这样可以少开一倍的空间，只是写状态稍微有点麻烦

关于位运算的相关解释写在了代码注释里

### 注意

写这种表达式可能并不能达到期望效果

```cpp
x=pos[S&-S]+(x>=i);
```

所以改成了

```cpp
x=pos[S&-S];
if(x>=i)++x;
```

（蒟蒻调这东西调了一个多小时）

### 贴代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <vector>
#define lint long long
#define rint register int
using namespace std;
inline int read(){
	char c;int f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const int N=1e5+5,M=25;
int mp[M][M]={0},g[M][1<<23],f[1<<24],cnt[1<<24],pos[1<<24];
int n,m,k,s[N];
/*
g:预处理的贡献 
f:考虑指定集合的答案 
cnt:每个状态有几个1 
pos:存储对于某个2^k的k是多少 
mp:相当于邻接表 

预计时空间复杂度：O(m*2^m) 
*/
int main(){
	n=read();
	m=read();
	k=read();
	for(rint i=1;i<=n;++i)
		s[i]=read();
	for(rint i=1;i<=n-1;++i)
		++mp[s[i]][s[i+1]];
	for(rint i=0;i<=m;++i)
		pos[1<<i]=i+1;
	for(rint i=1;i<=m;++i){
		for(rint j=1;j<=m;++j)//状态全0表示所有的点都在当前点后面 
			if(i!=j)g[i][0]+=-mp[i][j]+mp[j][i]*k;
		for(rint S=1;S<=(1<<(m-1))-1;++S){
			int T=S-(S&-S),x;
			//为了转移当前的状态，由于当前状态去掉最低位之前算过了，所以从去掉最低位的T转移 
			g[i][S]=g[i][T];
			x=pos[S&-S];
			//存一下最低位对应的是哪个数 
			if(x>=i)++x;
			//这里集合是在原序列里面去掉i之后的，所以如果x>=i就加一下补空位 
			g[i][S]-=-mp[i][x]+mp[x][i]*k;
			g[i][S]+=mp[x][i]+mp[i][x]*k;
			//这两步相当于把最低位对应的数从i后面挪到i前面 
		}
	}
	memset(f,0x3f,sizeof f);
	f[0]=0;
	cnt[0]=0;
	for(rint S=1;S<=(1<<m)-1;++S)
		cnt[S]=cnt[S-(S&-S)]+1;
	//这里存每个状态有多少个1 
	for(rint S=1;S<=(1<<m)-1;++S){
		int rm=S,T,x;
		//rm 即remain，用来在S中取一位 
		while(rm){
			x=pos[rm&-rm];
			T=S&((1<<(x-1))-1);
			//这里T是去掉x对应元素后的集合
			//所以分成两截，先取x前面的，然后把x后面的挪过来 
			T+=(S-(rm&-rm)-T)>>1;
			f[S]=min(f[S],g[x][T]*cnt[S]+f[S-(rm&-rm)]);
			//比较正常的转移 
			rm-=rm&-rm;
			//去掉rm最低位 
		}
	}
	printf("%d",f[(1<<m)-1]);
	return 0;
}
```


---

## 作者：Imakf (赞：1)

因为众所周知的原因，图床炸掉了，所以 [cnblog](https://www.cnblogs.com/imakf/p/13641197.html) 食用更佳。



## Editorial

作为 联合省选2020 的第四题，是一道良心送温暖题，这个套路我在冲刺 $\textrm{TG}$ 组的时候就有所耳闻，让我们一起为出题人点赞。

### fake solution

$m$ 出乎意料的小，于是考虑状压。

一种很 $\textrm{naive}$ 的想法是设 $dp_{st}$ 表示从左到右 $\textrm{bitcount(st)}$ 个信号站已经放了 $st$ 集合里的所有信号站。转移直接枚举一个新信号站，加上别人到他的贡献（第一种传输）和他到前面的贡献（第二种传输）。

但你发现这两种贡献不好保存计算，因为你必须知道他们之间的距离，而在这个数据范围下是不可以状压的。

这意味着**不能加入一个信号站的时候计算所有与它相关的贡献**，以上 $\textrm{dp}$ 转移假了。

山重水复疑无路。

### real solution

#### part 1

不妨我们只考虑第一种传输，即只有从左往右的。

![](https://images.cnblogs.com/cnblogs_com/imakf/1844551/o_200909112230trans.png)

假设我们有 $黑 \to 绿$ 的一条传输，那么只要 $绿$ 没有出现，$黑$ 出现了，就一直会造成贡献。也就是**每放一个新信号塔，只要 $绿$ 没出现，那么就会造成 $1$ 的贡献**，造成的总贡献就是它们之间的距离。

那么就说明每一对 $($出现过的，没出现的$)$，且有传输要求的都会在放置一个新的信号塔后产生 $1$ 的贡献。

![](https://images.cnblogs.com/cnblogs_com/imakf/1844551/o_200909112356trans.png)

由上图来看，我们就根本不需要记录他们的出现位置了。

#### part 2

再考虑从第二种传输方法。我们把它拆成两部分：

![](https://images.cnblogs.com/cnblogs_com/imakf/1844551/o_200909113810trans2.png)

右半部分紫色的贡献可以直接与 $\textrm{part 1}$ 同时计算。

左半部分蓝色的贡献直接在加入新信号塔的时候计算。

## Code

代码不算太难，主要要预处理以下东西：

- $cb_{st}$ 表示当前放了 $st$ 集合的信号塔，如果放一个新的，造成的 $\textrm{part 1}$ 代价与 $\textrm{part 2}$ 蓝色部分线路代价之和。
  - 枚举当前选了哪一个即可以转移求出，复杂度 $O(2^mm)$。
- $cf_{i,st}$ 表示当前放了 $st$ 集合的信号塔，如果下一个放 $i$ 信号塔，造成的 $\textrm{part 2}$ 蓝色线路有多少次单程路线。
  - 为什么要这么记呢，因为我们没有办法记录总长度。但因为左半部分蓝色的贡献直接在加入新信号塔的时候计算，这个时候蓝色单程的长度是确定的，所以乘上 $k$ 和路线长度就可以了。
  - 容易发现 $cf$ 数组直接开是开不下的。$st$ 的集合相互之间没有影响，所以可以把集合拆成两个小集合，变成 $cf1_{i,st}$ 和 $cf2_{i,st}$，分开算贡献。
  - 复杂度 $O(2^{\frac{m}{2}}m^2)$。

$dp$ 复杂度是 $O(2^mm)$，所以总复杂度 $O(2^mm)$，可以稳稳当当通过此题。

空间复杂度 $O(2^m+m^2)$，可以稳稳当当通过此题。

```cpp
// Author : Imakf
#include <bits/stdc++.h>

#define int unsigned

int read(){
	char k = getchar(); int x = 0;
	while(k < '0' || k > '9') k = getchar();
	while(k >= '0' && k <= '9')
		x = x * 10 + k - '0' ,k = getchar();
	return x;
}

void cm(int &a ,int b){a = a < b ? a : b;}

const int MX = 23;
int cnt[MX][MX];
int lg2[1 << MX];
int dp[1 << MX];

int cb[1 << MX];
// 考虑以这个状态新放一个，消耗的普通传递代价以及特殊传递的前半段代价
int cf1[23][1 << 12] ,cf2[23][1 << 12];
// 考虑以这个状态新放一个 i，i 要造成多少次特殊传递
const int base = (1 << 12) - 1;

signed main(){
	int n = read() ,m = read() ,k = read();
	for(int i = 0 ,last = -1 ,now ; i < n ; ++i ,last = now){
		now = read() - 1;
		if(~last) ++cnt[last][now];
	}
	for(int i = 0 ; i < m ; ++i) cnt[i][i] = 0 ,lg2[1 << i] = i;

	for(int i = 1 ; i < 1u << m ; ++i){
		int add = lg2[i & -i];
		cb[i] = cb[i ^ (i & -i)];
		for(int j = 0 ; j < m ; ++j){
			if((i >> j) & 1) cb[i] -= cnt[j][add] + k * cnt[add][j];
			else cb[i] += cnt[add][j] + k * cnt[j][add];
		}
	}
	for(int i = 0 ; i < 1 << 12 ; ++i){
		for(int j = 0 ; j < m ; ++j){
			for(int s = 0 ; s < 12 ; ++s){
				if((i >> s) & 1) continue;
				cf1[j][i] += cnt[s][j];
			}
			for(int s = 12 ; s < m ; ++s){
				if((i >> (s - 12)) & 1) continue;
				cf2[j][i] += cnt[s][j];
			}
		}
	}
	
	for(int i = 1 ; i < 1u << m ; ++i){
		int cnt1 = 0 ,cpi = i;
		while(cpi) cpi -= cpi & -cpi ,++cnt1;
		dp[i] = UINT_MAX;
		for(int j = 0 ; j < m ; ++j){
			if(((i >> j) & 1) ^ 1) continue;
			cm(dp[i] ,dp[i ^ (1 << j)]
					+ cb[i ^ (1 << j)] 
					+ (cf1[j][i & base] + cf2[j][i >> 12]) * cnt1 * 2 * k);

	}
	printf("%d\n" ,dp[(1 << m) - 1]);
	return 0;
}
```



---


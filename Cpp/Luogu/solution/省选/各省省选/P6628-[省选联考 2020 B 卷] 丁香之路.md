# [省选联考 2020 B 卷] 丁香之路

## 题目描述

春暖花开，万物复苏，随着疫情的逐渐过去，Yazid 带着他的 $n$ 个好朋友来到 T 大校园参观游览。方便起见，我们将他们从 $1$ 至 $n$ 编号。

T 大校园的版图可以抽象成一张 $n$ 个顶点的无向图（顶点编号从 $1$ 至 $n$）。且对于任意两个不同顶点，设它们的编号分别为 $i, j(i\neq j)$，则它们之间有一条需要花费 $|i - j|$ 单位时间通过的无向边。

丁香花是 T 大的校花之一。时下正值丁香花盛开之际，校园内的 $m$ 条道路上都开有丁香花。Yazid 的朋友们对丁香花十分感兴趣，因此他们都希望遍历**所有**开有丁香花的 $m$ 条道路。

Yazid 的朋友们从顶点 $s$ 出发。其中，第 $i$ 个朋友希望以顶点 $i$ 为终点终止他的参观。与此同时，如上面所述，每个朋友都必须经过开着丁香花的 $m$ 条道路各至少一次。

Yazid 的朋友不想太过疲累，因此他们希望花尽可能少的时间来完成他们的目标。

请你计算 Yazid 的朋友们分别需要花费多少单位时间完成他们的目标。

## 说明/提示

**样例解释 1**

第 $1$ 个朋友的一种最优路线是从 $1$ 出发依次途径 $2, 4, 3$，最终回到 $1$，消耗 $|1-2|+|2-4|+|4-3|+|3-1| = 6$ 单位时间。

第 $2$ 个朋友的一种最优路线是从 $1$ 出发依次途径 $2, 4, 3, 1$，最终来到 $2$，消耗 $7$ 单位时间。

第 $3$ 个朋友的一种最优路线是从 $1$ 出发依次途径 $2, 4, 1$，最终来到 $3$，消耗 $8$ 单位时间。

第 $4$ 个朋友的一种最优路线是从 $1$ 出发依次途径 $3, 1, 2$，最终来到 $4$，消耗 $7$ 单位时间。

**样例解释 2**

由于 $m = 0$，没有必经之路，因此每个朋友直接通过一条边直达目的地即可。


**数据范围与约定**

| 测试点编号  |  $n=$  | 其他特殊限制 |
| --------- | ---- | ---------- |
|  $1\sim 3$  |  $50$  |    $m=9$     |
|  $4\sim 6$  |  $50$  |    $m=15$    |
|  $7\sim 8$  |  $50$  |              |
| $9\sim 10$  | $300$  |              |
|    $11$     | $1600$ |    $m=0$     |
| $12\sim 14$ | $1600$ |    $m=1$     |
| $15\sim 17$ | $1600$ |              |
| $18\sim 20$ | $2500$ |              |

## 样例 #1

### 输入

```
4 3 1
1 2
4 2
3 1```

### 输出

```
6 7 8 7```

## 样例 #2

### 输入

```
6 0 2```

### 输出

```
1 0 1 2 3 4```

## 样例 #3

### 输入

```
5 4 1
1 2
3 4
4 5
3 5```

### 输出

```
8 7 6 7 8```

# 题解

## 作者：ethan_zhou (赞：46)

> 2024.10.14 更新： 修复格式

感觉这题的思路非常奇妙，就算会做了也完全不知道为啥要这么想。。。

## 题意

有一个 $n$ 个点的**无向**完全图，边 $i\leftrightarrow j$ 的边权为 $|i-j|$，强制经过指定的 $m$ 条边，求起点为 $s$，终点为 $i\in[1,n]$ 的最短路径。$n\le 2500,m\le \frac{n(n-1)}2$。

## 思路

考虑在一个**可重无向**边集 $E$，如果：

- $\text{必须经过的}\ m\ \text{条边}\subseteq E$
- 存在一条 $s\leftrightsquigarrow i$ 的欧拉路径

那么就有符合题目要求的一条路径存在。答案即为符合条件的 $\sum_{i\in E} w_i$ 的最小值。

---

一开始，我们就先把题目要求的 $m$ 条边加到 $E$ 里面，这样 $E$ 就天然满足第一个条件。

欧拉路径不太方便搞，我们一开始就往 $E$ 中加一个 $s\leftrightarrow i$，这样第二个条件就变成了“存在一条欧拉回路”。

---

存在欧拉回路的条件：

- $2\mid\deg(i),\forall i\in[1,n]$
- 图联通

下面说如何向 $E$ 中添加若干条边，使得 $E$ 满足上面两个条件，并且让这些边的边权和最小（先说做法，再写证明）

### 恢复度数奇偶性

把所有 $2\nmid\deg(i)$ 的 $i$ 拿出来，按编号排序。然后把相邻的奇度点两两配对（第 $2k$ 小的和第 $2k-1$ 小的配对）连边（图中红色为奇度点，蓝色为加的边）：

![](https://pic.imgdb.cn/item/6221b6955baa1a80ab63abeb.jpg)

> 注：做法中所说的连边并不是说直接连 $u\leftrightarrow v$。而是连（这样连边显然更优）：
> $$
> \begin{aligned}
> u&\leftrightarrow u+1\cr
> u+1&\leftrightarrow u+2\cr
> u+2&\leftrightarrow u+3\cr
> \vdots \cr
> v-1&\leftrightarrow v
> \end{aligned}
> $$

### 联通性

建完前文所述的边之后，图缩成若干连通块。只要再加一些边，把这些联通块联通起来即可，可以看出，这是一个类似最小生成树的东西：

![](https://pic.imgdb.cn/item/6221bb2c5baa1a80ab6775a2.jpg)

把所有 $\deg(i)\neq0$ 的 $i$ 拿出来按编号排序（度数为 0 的点不需要被联通），把相邻的两个点之间的的边拿去做 Kruskal 即可。所有在最小生成树上的边都会被经过两次。

复杂度 $O(n^2 \log n+m)$。

## 证明

下证任何一组最优解 $E^{\prime}$ 必定可以转化成贪心方法得到的解 $E$。

首先，我们把初始加的边（题目要求的 $m$ 条边和 $s\leftrightarrow i$）称为黑边，其余的边叫白边。

### 引理

有且仅有一个 $E$ 满足：

- $E$ 包含指定的 $m+1$ 条黑边
- $E$ 中的白边边权都为 $1$
- $E$ 中没有白色重边
- 在只考虑 $E$ 中的边时，满足 $2\mid\deg(i)$

比较显然，证明略。

### 原结论证明

- 首先，把 $E^{\prime}$ 所有白边 $u\leftrightarrow v$ 都拆成若干 $i\leftrightarrow i+1$ 的边，显然不劣（详见前文）。
- 然后，重复以下过程，直到 $E^{\prime}$ 中不剩下任何一对白色重边：
  - 从 $E^{\prime}$ 找到一对白色重边
  - 把这对边从 $E^{\prime}$ 中删除
  - 把这条边加入 $G$ 中（只加一次即可）
  
> 感性理解：
>
> - $E$ 中的白边对应**恢复度数奇偶性过程**中加的边
> - $G$ 中的边对应做**最小生成树过程**中加的边

此时，如果只考虑 $E^{\prime}$ 中的边，必然满足 $2\mid\deg(i)$。

由引理，此时 $E^{\prime}$ 中的边，必定与**恢复完度数奇偶性**之后，$E$ 中的边相同。

$G$ 中的边的目的就是把 $E^{\prime}$ 形成的连通块缩到一起，与贪心做法中的 MST 是等价的。

证毕。

---

## 作者：木xx木大 (赞：43)

[P6628 [省选联考 2020 B 卷] 丁香之路](https://www.luogu.com.cn/problem/P6628) 

容易发现，按照题目要求走出的路径满足：给定 $m$ 条边所连的点 $deg \mod 2=0$ ，起点和终点 $deg\mod 2=1$。这个性质让我们联想到欧拉回路。

首先建出题目中给的 $m$ 条边和起点到终点的边，然后贪心地把度数为奇数的点和它的下一个点相连；如果这会使下一个点变成奇点，就继续把下一个点和下下一个点相连，以此类推。这样建边的代价一定是最小的，因为新建出的边边权都为1且互不相交。这样就满足了上面提到的度数限制。

但还有一个问题：这样建边后图可能会不连通。那么我们把已有的连通块用并查集缩点，然后求最小生成树，让图连通的最小代价就是最小生成树大小的两倍。总复杂度 $O((m+n^2)\log n)$

因为以上做法只与每个点的度数有关，所以在具体实现时，我们并不需要真的建出题目给定的边，只需记录这些边给点带来的度数即可。



```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
namespace FGF
{
	int n,m,s;
	const int N=2505;
	struct edg{
		int u,v,w;
		edg(){};
		edg(int _u,int _v,int _w):u(_u),v(_v),w(_w){};
	};
	bool operator <(edg a,edg b)
	{
		return a.w<b.w;
	}
	int fa[N],bel[N],sum,du[N];
	int find(int x)
	{
		return x==fa[x]? x:fa[x]=find(fa[x]);
	}
	void work()
	{
		scanf("%d%d%d",&n,&m,&s);
		for(int i=1;i<=n;i++)fa[i]=i;
		for(int i=1;i<=m;i++)
		{
			int u,v;
			scanf("%d%d",&u,&v);
			du[u]++,du[v]++;
			sum+=abs(u-v);
			fa[find(u)]=find(v);
		}
		for(int i=1;i<=n;i++)bel[i]=find(i);
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)fa[j]=j;
			du[s]++,du[i]++;
			fa[find(bel[s])]=find(bel[i]);
			ll ans=sum,pre=0;
			for(int j=1;j<=n;j++)
				if(du[j]&1)
				{
					if(pre)
					{
						ans+=j-pre;
						for(int k=pre;k<j;k++)
							fa[find(bel[k])]=fa[find(bel[j])];
						pre=0;
					}
					else pre=j;
				}
			vector<edg> g;
			for(int j=1;j<=n;j++)
				if(du[j])
				{
					if(pre&&find(bel[j])!=find(bel[pre]))
						g.push_back(edg(bel[j],bel[pre],abs(j-pre)));
					pre=j;
				 } 
			sort(g.begin(),g.end());
			for(int sz=g.size(),j=0;j<sz;j++)
				if(find(g[j].u)!=find(g[j].v))
					fa[find(g[j].u)]=find(g[j].v),ans+=g[j].w*2;
			du[s]--,du[i]--;
			printf("%lld ",ans);
		}
	}
}
int main()
{
	FGF::work();
	return 0;
}
```


---

## 作者：鏡音リン (赞：40)

[P6628原题链接](https://www.luogu.com.cn/problem/P6628)

神仙题，抢个第一篇题解

题目大意：一条链上有 $n$ 个点，有 $m$ 条连接两个点的管道，所有管道必须钻一遍，求 $s$ 到其他点的最短路

定义一条路径中，不走管道的那部分路径叫做自由路径。由于所有管道的长度和是固定的，那么我们要求的就是让自由路径长度最少

如果没有管道，路径肯定是从 $s$ 到 $t$ 的一条自由路径。假设现在有一条自由路径从 $A$ 到 $B$（$A<B$），有一条管道从 $C$ 到 $D$（$C<D$），考虑以下几种情况：

- $A<C<B<D$，我们可以把路径变成 $A→C-D→B$，最终的自由路径变成 $A$ 到 $C$ 和 $B$ 到 $D$。$C<A<D<B$ 的情况同理。

- $A<C<D<B$，还是把路径变成 $A→C-D→B$，最终的自由路径还是 $A$ 到 $C$ 和 $B$ 到 $D$

- $A<B<C<D$，直接在 $C-D$ 上加一条自由路径让它变成一个环（这里先不考虑图的连通性问题，一个环暂时可以认为是独立于其他部分存在的。连通性会在后面处理）

注意：因为是无向边，而且一条路径也可以翻转，所以方向并不重要

根据上面几种情况找规律，发现在原有的自由路径上加一条管道，相当于把管道那段区间反转。当然这只是找规律，实际上这样做是正确的，下面是证明：

可以发现每次添加管道并反转自由路径后，所有管道边和自由边维持了一个从 $s$ 到 $t$ 的欧拉路，因此这条路径一定可行。同时它一定是最短的，因为所有的自由边都没有交叉。

只不过剩下一个很严重的问题：上面所说的“欧拉路”不是真正意义上的欧拉路，因为这些路径可能还没连通呢，只是满足了欧拉路对点度数的需求。

想让这张图连通，需要把现有的已经连通的部分缩成一个点，然后在上面求最小生成树。易得让图连通需要的最小代价就是最小生成树长度和的两倍。

具体实现时，我们先处理所有管道，包括它们形成的连通块和需要的自由路径，然后枚举每个终点单独处理。求最小生成树的时候只需要加入所有必经的节点，而因为这张图中两点的距离就是数轴上距离，因此只需要加入相邻的必经点构成的边就一定能求出最小生成树。

时间复杂度 $O((m+n^2)\log)$（$\log$ 来自并查集和求 mst 时给边排序）。代码太丑了，就不放了。

---

## 作者：yzhang (赞：16)

考虑每次走的路线，应该是必走的边和自己添加的一些边的"欧拉路"，起点和终点为奇点，其他点为偶点（先这样理解，此处欧拉路只是个广义的理解，不是真正的欧拉路）

程序中把起点和终点度数加一，再按顺序匹配相邻的奇点，给答案加上这条边，这样就结束了？

还没完，这个图只是定义上满足欧拉路，但不保证连通。用并查集维护连通块，之前连接的两奇点与之间偶点能合并成一个连通块。我们对有的连通块之间求距离，找出最小生成树，给答案加上边权和的两倍，显然这里能成为最小生成树的边是编号相邻两点间的

这样我们就在$O((m+n^2) \log n)$的时间内解决了问题

Upd on 2020.9.7 代码贴错

```cpp
//μ's forever
#include <bits/stdc++.h>
#define ll long long
#define N 2505
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register ll x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
int n,m,s,fa[N],in[N];
vector<int> v[N];
inline int find(register int x)
{
    return x==fa[x]?x:fa[x]=find(fa[x]);
}
struct node{
    int u,v,w;
    bool operator < (const node &a) const{
        return w<a.w;
    }
};
int main()
{
    n=read(),m=read(),s=read();
    ll sum=0;
    for(register int i=1;i<=n;++i)
        fa[i]=i;
    for(register int i=1;i<=m;++i)
    {
        int s=read(),t=read();
        v[s].push_back(t),v[t].push_back(s);
        sum+=fabs(s-t);
        fa[find(s)]=find(t);
    }
    for(register int i=1;i<=n;++i)
        in[i]=find(i);
    for(register int i=1;i<=n;++i)
    {
        for(register int j=1;j<=n;++j)
            fa[j]=j;
        v[s].push_back(i),v[i].push_back(s);
        fa[find(in[s])]=find(in[i]);
        int pre=0;ll ans=sum;
        for(register int j=1;j<=n;++j)
            if(v[j].size()&1)
            {
                if(pre)
                {
                    ans+=j-pre;
                    for(register int k=pre;k<j;++k)
                        fa[find(in[k])]=find(in[j]);
                    pre=0;
                }
                else
                    pre=j;
            }
        vector<node> e;
        for(register int j=1;j<=n;++j)
            if(v[j].size())
            {
                if(pre&&find(in[j])!=find(in[pre]))
                    e.push_back((node){in[j],in[pre],j-pre});
                pre=j;
            }
        sort(e.begin(),e.end());
        for(register int j=0;j<e.size();++j)
            if(find(e[j].u)!=find(e[j].v))
                fa[find(e[j].u)]=find(e[j].v),ans+=2*e[j].w;
        write(ans),putchar(' ');
        v[s].pop_back(),v[i].pop_back();
    }
	return 0;
}
```

---

## 作者：Cry_For_theMoon (赞：13)

[传送门](https://www.luogu.com.cn/problem/P6628)
 
这个题竟然是 B 卷 Day2T3（~~让我们看看今年的滚榜~~）

感谢 鏡音リン 和 Forward_ 两位神仙解答了蒟蒻的疑惑。

进入正题。

看到经过 $m$ 条边**至少一次**会很熟悉，因为众所周知如果是**恰好一次**那就是个欧拉路题。然后我们不难发现它其实还是欧拉路问题。只要把这个问题看成至少要添加多少条边才会出欧拉路就行了。这样的话一条关键边走了三次相当于原基础添加两条边。

所以我们枚举终点 $i$. 然后构造一个最小的图使得存在 $s->i$ 的欧拉路。这似乎就可以直接针对性质搞了。但是欧拉路并不好搞因为最后要剩下两个奇点，不妨考虑 $i->s$ 连虚边，这样的话原来的回路其实就变成了 **$s$ 为起点的欧拉回路**。又因为如果有欧拉回路那么任何一个点都可以作为起点，实质上就是让这个图（当然孤立点排除）的每个点度数都为偶数且**连通**。这个题似乎大家都很熟悉了（

顺口说一句，一般图上这个问题似乎不是很可做。但是注意到题目给的边权 $\mid i-j \mid$ 这个东西（尤其是在图上，比如似乎优化建图最短路里）一般都有很奇特的性质，也是本题的关键。

根据构造欧拉图的大众套路（详见）。我们一般后考虑连通性问题。这个时候我们会发现一个很奇特的性质：如果我们连了 $(i,j)\,,i<=j$ 那么它不优于连 $(i,i+1),(i+1,i+2),...,(j-1,j)$. 这样，再原有长度，还有 $(i,j)$ 连通的基础上还让更多点连通了起来，同时中间那些点因为连两条边奇偶性不改变。相当于在**没有任何影响**的情况下减少了连通块数目减轻了最后连通块之间连边的难度。那么考虑若干个奇点 $a_1,a_2,...,a_n(2\mid n)$, 显然满足度数要求的最优策略就是 $[a_1,a_2]$ 像刚才那样连出一条链，$[a_3,a_4]$ 连一条链.... （当然这里 $a$ 是排序过的）。

然后你会发现我们没有保证其连通性。我们需要一颗生成树，然后保证度数为偶数所以乘二。这个生成树的求解看似是 $O(n^2)$ 往上的（边数）。但是已经说明了只连相邻两个点就一定可以搞出一个最优解所以其实只有 $n-1$ 条边，即 $a$ 中相邻两点。

所以总复杂度大概是 $O(n^2 \log n)$ 的。

总结一下 trick：

- “至少走一次” 依旧可以转换成构造欧拉图

- 欧拉回路转欧拉路的技巧

（剩下的都是题目里的独特性质了）

有些细节还是得好好处理，比如 $m$ 条边的并查集合并不需要每次算答案都做不然 T 飞。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(ll i=(a);i<=(b);i++)
#define per(i,a,b) for(ll i=(a);i>=(b);i--)
#define op(x) ((x&1)?x+1:x-1)
#define odd(x) (x&1)
#define even(x) (!odd(x))
#define lc(x) (x<<1)
#define rc(x) (lc(x)|1)
#define lowbit(x) (x&-x)
#define Max(a,b) (a>b?a:b)
#define Min(a,b) (a<b?a:b)
#define next Cry_For_theMoon
#define il inline
#define pb(x) push_back(x)
#define is(x) insert(x)
#define sit set<int>::iterator
#define mapit map<int,int>::iterator
#define pi pair<int,int>
#define ppi pair<int,pi>
#define pp pair<pi,pi>
#define fr first
#define se second
#define vit vector<int>::iterator
#define mp(x,y) make_pair(x,y)
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int uint;
typedef double db;
using namespace std;
const ll MAXN=3010,INF=1e18;
int n,m,s,u,v;
int fa[MAXN],sz[MAXN],vis[MAXN],fa2[MAXN];
ll sum;
il ll getdis(int x,int y){return abs(x-y);}
int Find(int fa[],int x){if(fa[x]==x)return x;return fa[x]=Find(fa,fa[x]);}
void Merge(int fa[],int x,int y){fa[Find(fa,x)]=Find(fa,y);}
set<int>S;
int V[MAXN],size[MAXN],tot;
struct Edge{
	int u,v,w;
	bool operator<(const Edge& e2)const{return w<e2.w;}
}e[MAXN];
ll solve(set<int> s,int start,int end){
	//图(s)中，start->end的欧拉路存在的最短贡献
	tot=0;for(sit it=s.begin();it!=s.end();it++){V[++tot]=*it;}
	rep(i,1,n)fa2[i]=Find(fa,i),size[i]=sz[i];
	ll ret=0,pre=0;
	size[start]++;size[end]++;Merge(fa2,start,end);
	rep(i,1,tot){
		if(even(size[V[i]]))continue;
		if(!pre)pre=i;
		else{
			//V[pre]和V[i]连边 
			ret+=getdis(V[pre],V[i]);
			rep(k,pre,i)Merge(fa2,V[k],V[i]);
			pre=0;
		}
	}
	//求连通块mst 
	rep(i,1,tot-1){e[i]=(Edge){V[i],V[i+1],getdis(V[i],V[i+1])};}
	sort(e+1,e+tot);
	rep(i,1,tot-1){
		int u=e[i].u,v=e[i].v,w=e[i].w;
		if(Find(fa2,u)!=Find(fa2,v)){
			ret+=w*2;
			Merge(fa2,u,v);
		}
	}
	return ret; 
}
int main(){
	scanf("%d%d%d",&n,&m,&s);vis[s]=1;S.is(s);
	rep(i,1,n)fa[i]=i;
	rep(i,1,m){
		scanf("%d%d",&u,&v);
		sz[u]++;sz[v]++;vis[u]=vis[v]=1;S.is(u);S.is(v);
		Merge(fa,u,v);sum+=getdis(u,v);
	}
	rep(i,1,n){
		S.is(i);
		//s->i的最短距离
		printf("%lld ",sum+solve(S,s,i));
		if(!vis[i])S.erase(i);
	}
	return 0;
}

```


---

## 作者：Leasier (赞：9)

[0htoAi](https://www.luogu.com.cn/user/335366) 的至理名言：看到图论题不会做就想想能不能**欧拉回路**。

------------

首先可以注意到一个性质：

- $u, v$ 间的最短路就是 $|u - v|$。

证明：在中间经过点不影响，但在两边经过点会让路径变长。

~~于是有一个 $O(n^2 2^m)$ 的状压 dp，但是只能获得高贵的 $50$ 分（~~

接下来还可以注意到一个性质：

- 当 $i = s$，我们相当于需要求出一条从 $s$ 出发且包含所有必经边的欧拉回路。
- 当 $i \neq s$，我们相当于需要求出一条从 $s$ 出发、在倒数第二步到达 $i$ 且包含所有必经边的欧拉回路（当然这里因为不需要走 $i \to s$ 所以这一步的贡献得扔掉）。

需要注意的是**这里的欧拉回路事实上是允许重边的**。

考虑在 $i \neq s$ 时将边 $(s, i)$ 暂时加入必经边，则原问题变为：

- 有若干条必经边，求一条从 $s$ 出发的最短欧拉回路。

如果只加入必经边的情况下，所有点度数均为偶数，则我们只需要先抓出所有必经边构成的连通块，然后抓出两两连通块之间的最短路径，最后把最小生成树边权和乘 $2$ 加入答案即可。

- 这里用到了一个小结论：**遍历完一张图的最小代价就是其最小生成树的边权和乘 $2$**，因为每条树边你会遍历两遍。

那两两连通块之间的最短路径怎么快速计算呢？考虑将编号相邻的连通块连边，则两两之间的最短距离一定会被取到，同时边数降为 $O(n)$。注意这里“编号相邻”指的是**在与必经边有关的前提下编号相邻**，因为其他点有可能根本就不会出现在任何一条最优路径上（参考样例 2）。

接下来考虑有点度数为奇数的情况。由于这是无向图，显然只会有偶数个这样的点。贪心地，考虑将编号相邻且度数均为奇数的点抓出来两两配对，并一路连上中间所有的点，这样路径总长不变但能涉及到更多的点显然不劣。

Kruskal 求最小生成树即可。时间复杂度为 $O(m \log n + n^2 \log n)$。

代码：
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>

using namespace std;

typedef long long ll;

typedef struct {
	int root[2507];
	
	inline void init(int n){
		for (register int i = 1; i <= n; i++){
			root[i] = i;
		}
	}
	
	int get_root(int x){
		if (root[x] == x) return x;
		return root[x] = get_root(root[x]);
	}
	
	inline void merge(int x, int y){
		int root_x = get_root(x), root_y = get_root(y);
		if (root_x != root_y) root[root_x] = root_y;
	}
} DSU;

typedef struct Edge_tag {
	int start;
	int end;
	int dis;
	Edge_tag(){}
	Edge_tag(int start_, int end_, int dis_){
		start = start_;
		end = end_;
		dis = dis_;
	}
} Edge;

DSU dsu1, dsu2;
int deg[2507];
Edge edge[2507];

bool operator <(const Edge a, const Edge b){
	return a.dis < b.dis;
}

inline int read(){
	int ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return ans;
}

inline int kruskal(int n, int m){
	int ans = 0;
	for (register int i = 1; i <= m; i++){
		int x_root = dsu2.get_root(edge[i].start), y_root = dsu2.get_root(edge[i].end);
		if (x_root != y_root){
			dsu2.root[x_root] = y_root;
			ans += edge[i].dis;
		}
	}
	return ans;
}

int main(){
	int n = read(), m = read(), s = read();
	ll sum = 0;
	dsu1.init(n);
	for (register int i = 1; i <= m; i++){
		int u = read(), v = read();
		deg[u]++;
		deg[v]++;
		sum += abs(u - v);
		dsu1.merge(u, v);
	}
	for (register int i = 1; i <= n; i++){
		int val = 0, cnt = 0;
		dsu2.init(n);
		deg[s]++;
		deg[i]++;
		dsu2.merge(dsu1.get_root(s), dsu1.get_root(i));
		for (register int j = 1, k = 0; j <= n; j++){
			if (deg[j] % 2 == 1){
				if (k == 0){
					k = j;
				} else {
					val += j - k;
					for (register int l = k; l < j; l++){
						dsu2.merge(dsu1.get_root(l), dsu1.get_root(l + 1));
					}
					k = 0;
				}
			}
		}
		for (register int j = 1, k = 0; j <= n; j++){
			if (deg[j] > 0){
				if (k != 0) edge[++cnt] = Edge(dsu1.get_root(j), dsu1.get_root(k), abs(j - k));
				k = j;
			}
		}
		sort(edge + 1, edge + cnt + 1);
		cout << sum + val + kruskal(n, cnt) * 2 << " ";
		deg[s]--;
		deg[i]--;
	}
	return 0;
}
```

---

## 作者：云浅知处 (赞：4)

考虑对 $m$ 条特殊边建图，考虑对于一个连通块，从连通块内某个点开始走遍连通块内所有边的最小代价。显然，如果图中存在欧拉回路，那么最优方案就是沿着欧拉回路走一遍。

如果没有欧拉路径呢？我们发现此时相当于有 $2k$ 个度数为奇数的点，其中 $k>1$。尽管此时不存在欧拉路径，但是我们可以在两个点 $i,j$ 之间进行 “ 跳跃 “，需要花费 $|i-j|$ 的代价。那么我们只需跳跃 $k$ 次，即可得到一条欧拉回路。

现在我们要用 $k$ 条边连上 $2k$ 个点，不过图不是二分图。把这 $2k$ 个点按照编号排序，那么最优方案一定是将 $(x_1,x_2),(x_3,x_4),\cdots,(x_{2k-1},x_{2k})$ 这样两两配对。

似乎漏掉了什么！为什么不可能从某个点不进行跳跃，而是沿着某些别的路径直接遍历剩下的边呢？我们注意到这张图的性质非常好，它满足**任意两个点之间的所有简单路径上边权和相等**！因此，感性理解一下，不管是什么方案，其实和我们的方案基本是等价的。

现在图中可能有多个连通块，还有从 $s$ 开始，到 $i$ 结束的限制，怎么做呢？简单思考一下，发现相当于要加若干边，使得 $s,i$ 的度数都变成奇数，其他的均为偶数；我们只需检查 $s,i$ 的度数的奇偶性，据此判断是否要将 $s,i$ 加入序列一起排序，即可。

加完边之后可能原图仍然不连通，首先如果我们新加了一条边 $(x,y)$，那么我们完全可以在从 $x\to y$  的时候跳到某个中间点，从这里遍历它的连通块，再返回 $y$ 点；因此 $(x,x+1),(x+1,x+2),\cdots,(y-1,y)$ 这些边都被我们加上了；如果此时原图仍然不连通，考虑求个最小生成树使图联通，即可。注意到最小生成树的可行边只在相邻的连通块之间，因此复杂度仍然有保证。

但有一个问题，为什么不可能是在先前满足每个点的度数约束的时候，改变一些方案，使其满足连通性的限制呢？考虑四个点 $a<b<c<d$，一开始的方案是连边 $(a,b),(c,d)$，如果不连通，我们还会补上边 $(b,c)$，代价是 $b-a+d-c+2(c-b)=d-a+c-b$；如果改变方案为 $(a,d),(b,c)$，发现此时的代价仍然是 $d-a+c-b$。感性理解一下，这两种方案本质是相同的。

至此本题得到完全解决，时间复杂度显然可以做到 $O(n^2\log n+m)$，注意到最小生成树的边权不超过 $n$，因此可以在线性时间内排序，做到 $O(n^2+m)$。

```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

const int mod=998244353;
int ksm(int x,int y,int p=mod){
	int ans=1;
	for(int i=y;i;i>>=1,x=1ll*x*x%p)if(i&1)ans=1ll*ans*x%p;
	return ans%p;
}
int inv(int x,int p=mod){return ksm(x,p-2,p)%p;}
int randint(int l,int r){return rand()*rand()%(r-l+1)+l;}

const int N=2505;
const int M=N*(N-1)/2;

int n,m,fa[N],sz[N],p[N],cnt,Tf[N],Ts[N];
bool vis[N],In[N];
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
void adde(int x,int y){
	x=find(x),y=find(y);
	if(x==y)return ;
	if(sz[x]>sz[y])swap(x,y);sz[y]+=sz[x],fa[x]=y;
}

int d[N],Mx[N],Mn[N],Now=0,s;

pair<int,pair<int,int> >E[M];
#define fi first
#define se second
#define mk make_pair
bool tmp[N];
int t[N];

void solve(int tar){
	int res=Now;
	cnt=0;memset(Mx,0,sizeof(Mx)),memset(Mn,63,sizeof(Mn)),memset(d,0,sizeof(d));
	memcpy(Tf,fa,sizeof(Tf)),memcpy(Ts,sz,sizeof(Ts));memset(tmp,0,sizeof(tmp));
	for(int i=1;i<=n;i++)if(vis[i])p[++cnt]=i;assert(cnt%2==0);
	int tot=0;
	for(int i=1;i<=cnt;i+=2)res+=p[i+1]-p[i],adde(p[i],p[i+1]),d[p[i]]++,d[p[i+1]]--;
	for(int i=1;i<n;i++)d[i]+=d[i-1];
	for(int i=1;i<n;i++)if(d[i]>0)adde(i,i+1);
	for(int i=1,lst=0;i<=n;i++){
		if((!In[i])&&(!vis[i])&&(i!=s))continue;
		if(lst&&find(lst)!=find(i))E[++tot]=mk(i-lst,mk(find(i),find(lst)));
		lst=i;
	}
	sort(E+1,E+tot+1);
	for(int i=1;i<=tot;i++){
		int u=find(E[i].se.fi),v=find(E[i].se.se);
		if(u==v)continue;
		res+=E[i].fi+E[i].fi,adde(u,v);
	}
	cout<<res<<' ';
	memcpy(fa,Tf,sizeof(fa)),memcpy(sz,Ts,sizeof(sz));
	memset(d,0,sizeof(d));
}

signed main(void){

#ifndef ONLINE_JUDGE
	freopen("in.in","r",stdin);
	freopen("out.out","w",stdout);
#endif

	n=read(),m=read(),s=read();
	for(int i=1;i<=n;i++)fa[i]=i,sz[i]=1;
	for(int i=1;i<=m;i++){
		int u=read(),v=read();In[u]=In[v]=1;
		vis[u]^=1,vis[v]^=1,adde(u,v);
		Now+=max(u,v)-min(u,v);
	}
	for(int i=1;i<=n;i++)vis[s]^=1,vis[i]^=1,solve(i),vis[s]^=1,vis[i]^=1;
	puts("");

	return 0;
}


```

---

## 作者：Milmon (赞：4)

[in Blog](//milk-lemon.blog.luogu.org/notes-EulerPath) & [Problem](//www.luogu.com.cn/problem/P6628)

## 题目大意

- 给定一个有 $n$ 个点，$m$ 条边的无向图以及一个起点 $s$。

- 对于任意一个点，找出最短的一条从 $s$ 到这个点的路径经过这 $m$ 条边，路径中可以从任意一个点 $i$ 走到另一个点 $j$，无论是否在给定的 $m$ 条边中，边权均为 $|i-j|$。

- $50\leq n\leq 2500,\ 0\leq m\leq\dbinom n2$

## 解题思路

本题中要求求出相同起点，不同终点的结果。不妨将起点和终点连一条边，这样就变成了求一条欧拉回路。

为了存在欧拉回路，图中必须全为偶点。我们考虑将奇点两两配对连边。由于此题边权设置的特殊性，可以优先考虑将相邻的奇点连边。即按编号从小到大，第 $1$ 个奇点与第 $2$ 个奇点配对，第 $3$ 个奇点与第 $4$ 个奇点配对，以此类推。考虑到欧拉回路的另一个存在条件为图是连通图，尽可能在连边的时候多连通几个点，所以可以在为 $u$ 和 $v$ 连边时转化成编号相邻的点连边（不妨设 $u<v$，即 $u$ 与 $u+1$ 连边，$u+1$ 与 $u+2$ 连边，以此类推直到 $v-1$ 与 $v$ 连边。

下面处理依然未被连通的块。不妨将每个连通块视为一个点，两个连通块之间的边权为连通这两个连通块所需的最小边权，接着需要求出一种连边方式，使得图连通且边权总和尽可能小，也就转化成了求最小生成树的问题。

事实上，整个计算过程中都无需使用给定的 $m$ 条边的具体数据，于是我们可以不记录边的信息，只记录每个点的度数，再用并查集维护连通块的情况。

算法中为奇点配对时间复杂度 $\Theta(n)$，连边时虽然要一个一个点连，但是至多连 $n-1$ 条边，时间复杂度也为 $\Theta(n)$；连通块之间连至多 $n$ 条边，按边权从小到大排序时间复杂度 $\Theta(n\log n)$，求最小生成树时间复杂度也为 $\Theta(n)$。上述过程要对每个终点都求一遍，时间复杂度为 $\Theta(n^2\log n)$。在输入 $m$ 条边统计信息时还有 $\Theta(m)$ 的时间复杂度。综上，总时间复杂度为 $\Theta(n^2\log n+m)$。

## AC 代码

```c++
#include<bits/stdc++.h>
using namespace std;

int n,m,s;

struct Edge{
	int u,v,w;
	inline bool operator<(Edge tmp)const{
		return w<tmp.w;
	}
};
vector<Edge>edge;

int deg[2501];

struct{
	int f[2501];
	void init(int N){
		for(int i=1;i<=N;i++)f[i]=i;
	}
	int find(int id){
		if(f[id]!=id)f[id]=find(f[id]);
		return f[id];
	}
	void merge(int u,int v){
		f[find(u)]=find(v);
	} 
}a,b;

long long sum;

int main(){
	scanf("%d%d%d",&n,&m,&s);
	a.init(n);
	for(int i=1;i<=m;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		deg[u]++,deg[v]++;
		a.merge(u,v);
		sum+=abs(u-v);
	}
	for(int i=1;i<=n;i++)
		a.f[i]=a.find(i);
	for(int i=1;i<=n;i++){
		b.init(n);
		deg[s]++,deg[i]++;
		b.merge(a.f[s],a.f[i]); // 起点和终点连边 
		long long answer=sum;
		// 将奇点两连配对连边 
		int Last=0;
		for(int j=1;j<=n;j++)
			if(deg[j]&1)
				if(Last==0)Last=j;
				else{
					answer+=abs(j-Last);
					for(int k=Last;k<j;k++)
						b.merge(a.f[k],a.f[k+1]);
					Last=0;
				}
		// 连通块之间连边 
		edge.clear();
		Last=0;
		for(int j=1;j<=n;j++)
			if(deg[j]){
				if(Last&&b.find(a.f[Last])!=b.find(a.f[j]))
					edge.push_back({a.f[Last],a.f[j],abs(j-Last)});
				Last=j;
			}
		// 求最小生成树 
		sort(edge.begin(),edge.end());
		for(Edge e:edge)
			if(b.find(e.u)!=b.find(e.v)){
				b.merge(e.u,e.v);
				answer+=e.w*2;
			}
		printf("%lld ",answer);
		deg[s]--,deg[i]--; 
	}
	return 0;
}
```

---

## 作者：翼德天尊 (赞：1)

先考虑把最简化的图建出来，即，一条从 $1$ 到 $n$、边权全为 $1$ 的链，和 $m$ 条链外的边。

题目在让我们求什么呢？其实是一条从 $s$ 到 $t$、经过所有 $m$ 条链外边的“一笔画”（欧拉路径）。

所以我们可以进一步抽象，从度数角度直接地思考这个问题。

欧拉路径就要求，$s,t$ 的度数为奇数，其余点的度数为偶数。不妨将特殊点化为一般，先将 $s,t$ 的度数取反，相当于连一条虚拟边，使得要求变为所有点度数均为偶数。

现在我们有一张残缺不全的，包含 $m$ 条边的图，需要加入若干 $1$ 到 $n$ 链上的边，使得图满足条件且连通（注意这里的连通指的是被 $m$ 条边所连的点和起点终点连通）。

不妨先不考虑连通。注意到任意 $x$ 到 $y$ 的代价拆成若干代价为 $1$ 的小边显然不劣。所以不妨从 $1$ 到 $n$ 扫一遍，若当前节点度数为奇数，则向下一节点连一条边。扫完后我们就可以用最小代价将所有节点度数变为偶数了。

于是就得到了若干欧拉回路连通块。由于任意两个连通块中的任意两个点相互连两条边后，就可以将这两个连通块合成一个欧拉回路连通块，所以求个最小生成树即可。正确性建立在附加边的序列性（即附加边是特殊的链而非平凡的图），也正因为此，每次最小生成树上至多有 $n$ 条边，故枚举 $t$ 后总复杂度 $O(n^2\log n+m)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2505;
const int M=N*N;
int n,m,s,ans,d[N],fa[N],jl[N],jl2[N],ptot;
bool vis[N],jl3[N];
struct Edge{
	int u,v,w;
}p[M];
ll read(){
	ll w=0,f=1;
	char c=getchar();
	while (c>'9'||c<'0'){
		if (c=='-') f=-1;
		c=getchar();
	}
	while (c>='0'&&c<='9'){
		w=(w<<3)+(w<<1)+(c^48);
		c=getchar();
	}
	return w*f;
}
int find(int x){
	if (fa[x]==x) return x;
	return fa[x]=find(fa[x]);
}
void merge(int x,int y){
	x=find(x),y=find(y);
	if (x==y) return;
	fa[y]=x;
}
bool cmp(Edge x,Edge y){
	return x.w<y.w;
}
int main(){
#ifndef ONLINE_JUDGE
	freopen("in.in","r",stdin);
	// freopen("out.out","w",stdout);
#endif
	n=read(),m=read(),s=read(),vis[s]=1;
	for (int i=1;i<=n;i++) fa[i]=i;
	for (int i=1;i<=m;i++){
		int u=read(),v=read();
		d[u]^=1,d[v]^=1;
		merge(u,v),ans+=abs(u-v);
		vis[u]=1,vis[v]=1;
	}
	for (int i=1;i<=n;i++) jl[i]=fa[i],jl2[i]=d[i],jl3[i]=vis[i];
	for (int t=1;t<=n;t++){
		int now=ans;ptot=0;
		for (int i=1;i<=n;i++) fa[i]=jl[i],d[i]=jl2[i],vis[i]=jl3[i];
		d[s]^=1,d[t]^=1,vis[t]=1,vis[s]=1;
		for (int i=1;i<=n;i++)
			if (d[i]&1) ++now,d[i]^=1,d[i+1]^=1,merge(i,i+1),vis[i]=1,vis[i+1]=1;
		for (int i=2,la=1;i<=n;i++){
			if (vis[i]&&vis[la]&&find(i)!=find(la)) 
				p[++ptot].u=find(la),p[ptot].v=find(i),p[ptot].w=i-la,la=i;//cout<<t<<" "<<p[ptot].u<<" "<<p[ptot].v<<"\n";
			else if (find(i)==find(la)&&vis[i]||!vis[la]) la=i;
		}
		sort(p+1,p+1+ptot,cmp);		
		for (int i=1;i<=ptot;i++){
			int u=find(p[i].u),v=find(p[i].v);
			if (u!=v) merge(u,v),now+=p[i].w*2;
		}
		cout<<now<<" ";
	}
	return 0;
}
```

---

## 作者：EZ_XHX (赞：1)

### 题外话
这个题就是非常毒瘤，我想了一下午，写了一晚上终于将其 A 掉。
### 题意
给定源点，求源点至每个点必须经过 $m$ 条边，这 $m$ 条边是给定的，求它们的最短路。
### 思路
因为这 $m$ 条边是必须选的，所以说一开始就可以将其加入并查集内，然后你就可以继续进行操作。 

然后我们来分析一下这个问题，就是你最后一定是从 $s$ 向 $t$ 的一条欧拉路径，然后你就是说将 $s$ 向 $i$ 去连边，这无疑就形成了欧拉回路了，然后我们就是去要构造最小的欧拉回路，那我们先将奇点给消掉，整个图内我们将相邻的奇点进行连边肯定是优的，顺便把中间的点给连上，这样你合并到了一个连通块内，然后我们再对不同的连通块内进行连边就行，然后也非常好做，跑个最小生成树就行。

### 细节
这题细节很多，也无愧能放到联合省选最后一题。第一个细节，为什么最后要加进最小生成树内的边权乘 2，因为是这样子的只有这样才能构成欧拉回路，否则是构不成的（奇点必须没有，若有的话，就必须构造出环，然后你发现构成环其实跟我这种情况是一样的，对不）。

注意的是，最后只要尽量不选连通块之外的无意义的边，所以说我就统计一下所有的连通块内合并答案就行 。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=25e2+5;
struct node{int from,to,weight;};
vector<node>G;
int f[maxn],degree[maxn],n,m,s,u,v,sum,ff[maxn];
vector<int>edge[maxn],V;
void init(int n){for(int i=1;i<=n;++i) f[i]=i;}
int findf(int i){return f[i]==i?f[i]:f[i]=findf(f[i]);}
void merge(int i,int j){f[findf(i)]=findf(j);}
bool cmp(node a,node b){return a.weight<b.weight;}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>m>>s;init(n);
    for(int i=1;i<=m;++i){
        cin>>u>>v;
        degree[u]++,degree[v]++;
        sum+=abs(u-v);//加入答案
        merge(u,v);
    }
    degree[s]++;       
    for(int i=1;i<=n;++i) ff[i]=f[i];//备份 
    for(int i=1;i<=n;++i){
        for(int j=1;j<=n;++j) f[j]=ff[j];
        degree[i]++;
        int ans=sum,pre=0;V.clear();
        for(int j=1;j<=n;++j){
            if(degree[j]) V.push_back(j);//你最后被计算的肯定是一开始就有的
        }
        for(int j=1;j<=n;++j){
            if(degree[j]&1){
                if(!pre) pre=j;
                else{
                    ans+=(j-pre);//我要对它们进行合并 
                    for(int k=pre+1;k<=j;++k) merge(k,k-1);
                    pre=0;
                }
            }
        }
        G.clear();
        for(int j=0;j+1<V.size();++j){
            if(findf(V[j])!=findf(V[j+1])) {
                G.push_back((node){V[j],V[j+1],V[j+1]-V[j]});
            }
        }
        sort(G.begin(),G.end(),cmp);
        for(auto [x,y,z]:G){
            if(findf(x)!=findf(y)){
                merge(x,y);ans+=2*z;
            }
        }
        degree[i]--;
        printf("%lld ",ans);
    }
    return 0;
}
```

---

## 作者：Yansuan_HCl (赞：1)

拆边题。

给定的边要走至少一次。~~我们~~钦点走的所有边都只走一次，走多次的看作建重边。这样，原题转化为 $s \rightsquigarrow t$ 的最小欧拉路径。欧拉路径的性质不是很好，考虑加入 $s \to t$ 的边转为**欧拉回路**。

欧拉回路满足图连通，且每个点度数为偶数。

直接匹配奇点很困难，但是本题有一个优美的性质：$\left| s \to t \right|=|s-t|$。**推论：$\forall x < y < z,|x\to z|=|x\to y| + |y\to z|$**。 这样，任意一条长度 $\gt 1$ 的边都可以拆成多条长度为 $1$ 的边。通过调整，可以把答案调为任意长度为 $1$ 的边不相交、不包含，这样一定更优。

于是把奇点从前往后两两匹配即可。

但是此时连通性并未保证。直观的想法是，建出最小生成树，每条树边建两次。感性理解：每个连通块都有欧拉回路，因此一定可以回到原点，一定从原点返回更优，否则不如一开始就换一个桥走。

然而连通块之间的边数仍然是巨大的。好在可以继续拆边：根据上方推论，$\forall u < v < w, u\to w$ 可以拆成 $u\to v$ 和 $v \to w$，这样边数就是 $O(n)$ 级别，可以直接 Kruskal.

总复杂度 $O(m + n(n \log n))$。

```cpp
const int N = 2505;
int n, m, s, deg[N];

struct DSU {
	array<int, N> fa;
	int getFa(int p) { return fa[p] == p ? p : fa[p] = getFa(fa[p]); }
	void merge(int u, int v) {
		u = getFa(u); v = getFa(v);
		fa[u] = v;
	}
	DSU() { U (i, 1, n) fa[i] = i; }
};

int solve(set<int> &p, DSU &d) {
	set<int> q = p;
	for (auto it = q.begin(); it != q.end(); )
		if (deg[*it] & 1) ++it;
		else q.erase(it++);
	
	int ans = 0;
	for (auto it = q.begin(); it != q.end(); ++it, ++it) {
		int u = *it, v = *next(it);
		ans += abs(u - v);
		U (i, u + 1, v)
			d.merge(i - 1, i);
	}
	
	vector<pair<int, int>> eg;
	for (auto it = ++p.begin(); it != p.end(); ++it) {
		int u = *prev(it), v = *it;
		eg.emplace_back(u, v);
	}
	sort(eg.begin(), eg.end(),
		[](pair<int, int> x, pair<int, int> y)
			{ return abs(x.first - x.second) < abs(y.first - y.second); });
		
	for (auto [u, v] : eg) {
		int dis = abs(u - v);
		u = d.getFa(u); v = d.getFa(v);
		if (u != v) {
			ans += dis * 2;
			d.merge(u, v);
		}
	}
	return ans;
}

int main() {	
	rd(n, m, s);
	
	set<int> pt; // 有用的点
	DSU d;
	int sum = 0;
	while (m--) {
		int u, v; rd(u, v);
		++deg[u]; ++deg[v];
		pt.insert(u); pt.insert(v);
		d.merge(u, v);
		sum += abs(v - u);
	}
	
	++deg[s]; pt.insert(s);
	U (i, 1, n) {
		set<int> p = pt; p.insert(i);
		++deg[i];
		DSU t = d; t.merge(s, i);
		
		int ans = solve(p, t);
		
		printf("%d ", ans + sum);
		--deg[i];
	}
}
```

---

## 作者：BFSDFS123 (赞：1)

神奇的图论题，看了半天题解，想了半天才会。

----

首先由绝对值的性质可知，$u,v$ 两点直接通过一条边到达，一定小于等于 $u$ 到 $k$，$k$ 再到 $v$ 的距离和。

题目中要求经过给定的 $m$ 条边至少一次。只能经过一次时，这个问题便变成了欧拉路径问题。

每条边可以经过至少一次，可以视为给这几条给定边加上一定数量的重边，使这张图满足有一条从起点 $s$ 到终点 $t$ 的欧拉路径。

欧拉路径求的时候不太方便，我们考虑将起点 $s$ 和终点 $t$ 连上一条边，这样就变成了求一个欧拉回路。

大家都知道，存在欧拉回路要求所有点的度数都是偶数。

很明显，我们的图不一定满足这个条件，所以我们考虑贪心地将所有的度数为奇数的点连上一条边。

怎么贪心？

注意到开始的绝对值的性质。当有三个点 $u,v,w$ 且满足 $u<v<w$ 的时候，有 $|u-v|+|v-w|=|u-w|$ 此时 $u$ 连 $v$，$v$ 连 $w$ 与 $u$ 连 $w$ 的代价是相同的。更重要的是，此时我们联通了三个点，比两个点更优。

所以我们将所有度数为奇数的点，将编号相邻的点连边即可。

如果不太好理解，可以结合样例和下面这张图来看。

![](https://cdn.luogu.com.cn/upload/image_hosting/1m4wwhd5.png)

黑边是给定的 $m$ 条必须经过的边，红边是我们连上的边。绿色的数字是给定的边的边权，棕色的数字是我们连上的边的边权。

容易发现，在给定的必须经过的一张图中，图不一定是联通的。

我们使用并查集记录下每个点所在的连通块。我们要求所有的不同的连通块相联通。

对于两个不同的连通块，它们相连的长度，是两个连通块内点的最近距离。大家可以结合下面这张图进行理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/tz63k1ar.png)

在上面这个例子中，两个连通块之间相连的代价就是节点 3 与节点 4 之间边的边权 1。

在实际的操作中，我们可以将两个连通块之间相连的**所有代价**作为两个连通块之间的边进行存储。

但是这样操作，存储的边数会很大。这时候又要用到我们开始的绝对值性质了。我们不需要将所有的连通块都连上边，只要将编号相邻的连通块连上边即可。

大家都知道，最小生成树的定义是图连通需要的最小代价。所以建完图后，我们只需要跑一边最小生成树即可。此时边数是 $O(n)$ 的，写一个 kruskal 就可以了。

同时注意到，由于边权等于两边点的编号相减，所以图所有边权的最大值是 $n-1$，我们不需要用 sort，直接 $O(n)$ 桶排即可。

时间复杂度是 $O(n^2)$。但是实际上写的时候，$O(n^2)$ 的桶排写法比 $O(n^2\log n)$ 的快排写法还慢，严重怀疑是 vector 的锅。

[代码](https://www.luogu.com.cn/paste/2ifrnvtp)。

---


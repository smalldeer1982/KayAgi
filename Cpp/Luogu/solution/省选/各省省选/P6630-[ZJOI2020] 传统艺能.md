# [ZJOI2020] 传统艺能

## 题目背景

4s，512MB

## 题目描述

Bob 喜欢线段树。

众所周知，ZJOI 的第二题有很多线段树。

Bob 有一棵根为 $[1, n]$ 的广义线段树。Bob 需要在这个线段树上执行 $k$ 次区间懒标记操作，每次操作会等概率地从 $[1, n]$ 的所有 $\dfrac{n(n+1)}{2}$ 个子区间中随机选择一个。对于所有在该次操作中被访问到的非叶子节点，Bob 会将这个点上的标记下推；而对于所有叶子节点（即没有继续递归的节点），Bob 会给这个点打上标记。

Bob 想知道，$k$ 次操作之后，有标记的节点的期望数量是多少。

【具体定义】

线段树：线段树是一棵每个节点上都记录了一个线段的二叉树。根节点记录的线段是 $[1, n]$。对于每个节点，若它记录的线段是 $[l, r]$ 且 $l \neq r$，取 $m = \lfloor \dfrac{l+r}{2} \rfloor$，则它的左右儿子节点记录的线段分别是 $[l, m]$ 和 $[m + 1, r]$；若 $l = r$，则它是叶子节点。

广义线段树：在广义的线段树中，$m$ 不要求恰好等于区间的中点，但是 $m$ 还是必须满足 $l \leq m < r$ 的。不难发现在广义的线段树中，树的深度可以达到 $O(n)$ 级别。

线段树的核心是懒标记，下面是一个带懒标记的广义线段树的伪代码，其中 `tag` 数组为懒标记：

![](https://cdn.luogu.com.cn/upload/image_hosting/3230chjw.png)

注意，在处理叶子节点时，一旦他获得了一个标记，那么这个标记会一直存在。

你也可以这么理解题意：有一棵广义线段树，每个节点有一个 $m$ 值。一开始 `tag` 数组均为 $0$，Bob 会执行 $k$ 次操作，每次操作等概率随机选择区间 $[l, r]$ 并执行 `MODIFY(root,1,n,l,r);`。
最后所有 `Node` 中满足 `tag[Node]=1` 的期望数量就是需要求的值。


## 说明/提示

样例输入输出 $3$ 见下发文件。

样例解释 $1$

输入的线段树为 $[1, 3], [1, 1], [2, 3], [2, 2], [3, 3]$。

若操作为 $[1, 1]/[2, 2]/[3, 3]/[2, 3]/[1, 3]$，标记个数为 $1$。若操作为 $[1, 2]$，标记个数为 $2$。故答案为 $\dfrac{7}{6}$。

| 测试点 | $n$ | $k$ | 其他约定 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $\leq 10$ | $\leq 4$ | 无 |
| $2$ | $\leq 10$ | $\leq 100$ | 无 |
| $3$ | $\leq 5$ | 无 | 无 |
| $4$ | 无 | $=1$ | 无 |
| $5$ | $=32$ | 无 | 输入的线段树为完全二叉树 |
| $6$ | $=64$ | 无 | 输入的线段树为完全二叉树 |
| $7$ | $=4096$ | 无 | 输入的线段树为完全二叉树 |
| $8$ | $\leq 5000$ | 无 | 每个 $m$ 均在 $[l, r - 1]$ 内均匀随机 |
| $9$ | $\leq 100000$ | 无 | 无 |
| $10$ | 无 | 无 | 无 |

对于 $100\%$ 的数据，$1 \leq n \leq 200000, 1 \leq k \leq 10^9$。

## 样例 #1

### 输入

```
3 1
1 2
```

### 输出

```
166374060
```

## 样例 #2

### 输入

```
5 4
2 1 3 4```

### 输出

```
320443836```

# 题解

## 作者：Werner_Yin (赞：24)

同步于[我的 Blog](https://www.cnblogs.com/werner-yin/p/15862977.html)


**2023.6.10 UPD: 3 \* 3 的式子原来有笔误，感谢 [灰鹤在此](https://www.luogu.com.cn/user/241114) 和 [llzer](https://www.luogu.com.cn/user/85429) 的指出。**

> 有一棵广义线段树，每个节点有一个 $m$ 值。一开始 `tag` 数组均为 $0$，Bob 会执行 $k$ 次操作，每次操作等概率随机选择区间 $[l, r]$ 并执行 `MODIFY(root,1,n,l,r);`。
> 最后所有 `Node` 中满足 `tag[Node]=1` 的期望数量。
> $n \le 2\times 10^5$

---

　　看着题解想锤人的题。。。

　　很多题解都不讲清状态的设计，以及为什么只要一个 $3\times3$ 的矩阵，为什么状态可以这么设计，于是自行研究了一个 $4\times 4$ 的矩阵的做法才明白原因。于是这个题解讲一个比较好理解的方式。

　　首先，考虑根据期望的线性性计算答案，计算**每个节点最后有 tag 的概率**，比较显然的事情就是 tag 只有两种：祖先的 tag（是否存在一个祖先的 tag = 1） 和自己的 tag。接着我们可以只记录这两种 tag，并将每次操作的节点分类：

* A. 父亲区间和操作区间没有交集：什么也不会发生变化。
* B. 父亲区间被操作区间包含：祖先的 tag = 1，自己的 tag 不变。
* 父亲区间和操作区间**有交**（但是不被包含）

  * C. 自己与操作区间没有交集：自己的 tag |= 祖先的 tag， 祖先的 tag = 0。
  * D. 自己区间被操作区间包含：祖先的 tag = 0， 自己的 tag = 1。
  * E. 自己区间和操作区间有交：祖先的 tag = 自己的 tag = 0。

　　然后按照编号 ABCDE 计算方案数。

> 关于方案数的计算，我们可以发现，单个节点与操作区间 没有交集/被包含/没有被包含但是有交集 的概率是比较好计算的。
> 那么 $A,B$ 可以从父亲节点继承过来，$C$ 就是自己的没有交集的概率-父亲没有交集的概率，$D$ 就是自己被包含的概率-父亲被包含的概率，最后一个，$E =1-A-B-C-D$ 即可。

　　之后魔幻的事情就来了，大部分题解都直接说维护一个 $3\times3$ 的矩阵然后搞搞搞搞搞，甚至有的没有讲清状态的定义，令人一脸蒙 B，看了半年（尤其是式子比较复杂，还不如自己推一推，于是我就推了大半天才明白）。

　　最朴素直接的想法应该是设 $f_0, f_1, f_2, f_3$ 表示 祖先和自己 tag 都为 0 、只有自己的 tag = 1、存在一个祖先 tag = 1、自己 tag = 1 并且存在一个祖先 tag = 1 的概率，转移的话可以根据定义以及变化列出以下式子：

$$
\left\{
\begin{aligned}
f'_0 &= Af_0 + Cf_0 + E(f_0 + f_1 + f_2 + f_3)\\
f'_1 &= Af_1 + C(f_1+f_2+f_3)+D(f_0+f_1+f_2+f_3)\\
f'_2 &= Af_2 + B(f_0 + f_2)\\
f'_3 &= Af_3 + B(f_1 + f_3)
\end{aligned}
\right.
$$

　　这个可以直接使用 $4\times 4$ 的矩阵维护，最后的答案就是 $f_1+f_3$。


　　但是为什么很多题解都拿的 $3\times 3$ 的矩阵呢？

　　我们可以注意到，最后的答案就是 $f_1+f_3$，然后再自己观察一下两个的转移的式子，就可以发现可以将两个式子合并到一起，于是可以直接维护一个 $3 \times 3$ 的矩阵了。

　　具体地，将 $f_1$ 状态设为 **自己的 tag=1，祖先的 tag 任意的概率**，其余不变，然后式子大概长这样：

$$
\left\{
\begin{aligned}
f'_0 &= Af_0 + Cf_0 + E(f_0 + f_1 + f_2)\\
f'_1 &= Af_1 + Bf_1 + C(f_1+f_2)+D(f_0+f_1+f_2)\\
f'_2 &= Af_2 + B(f_0 + f_2)\\
\end{aligned}
\right.
$$

　　然后可以使用 $3\times3$ 的矩阵维护了，也可以根据 $f_0 + f_1+f_2 = 1$ ，在矩阵中维护两个状态 + 一个单位元。

　　因为 $4\times4$ 的可以直接过，于是 $3\times 3$ 代码没写，下面的是 $4\times 4$ 的代码，所以如果 $3\times3$ 的式子有问题可以与我联系。
  
　　[代码(gitee)](https://gitee.com/yinjinrun/code-public-2/blob/master/Luogu/P6630.cpp)
  
 ```cpp
 #include <bits/stdc++.h>

#define eb emplace_back
#define ep emplace
#define fi first
#define se second
#define in read<int>()
#define lin read<ll>()
#define rep(i, x, y) for(int i = (x); i <= (y); i++)
#define per(i, x, y) for(int i = (x); i >= (y); i--)

using namespace std;

using ll = long long;
using db = double;
using pii = pair < int, int >;
using vec = vector < int >;
using veg = vector < pii >;

template < typename T > T read() {
	T x = 0; bool f = 0; char ch = getchar();
	while(!isdigit(ch)) f |= ch == '-', ch = getchar();
	while(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();
	return f ? -x : x;
}

template < typename T > void chkmax(T &x, const T &y) { x = x > y ? x : y; }
template < typename T > void chkmin(T &x, const T &y) { x = x < y ? x : y; }

const int N = 2e5 + 10;
const int mod = 998244353;
const int inv2 = (mod + 1) >> 1;

int n, K, iv, ans;

ll qp(ll x, int t) { ll res = 1; for(; t; t >>= 1, x = x * x % mod) if(t & 1) res = res * x % mod; return res; }

struct node {
	int a, b, c; // a : 不交, b : 被包含, c : 不被包含但是有交
	node(int l, int r) {
		a = (1ll * l * (l - 1) / 2 % mod * iv % mod + 1ll * (n - r + 1) * (n - r) / 2 % mod * iv % mod) % mod;
		b = 1ll * l * (n - r + 1) % mod * iv % mod;
		c = (mod * 2 - a - b + 1) % mod;
	} node(int _a, int _b, int _c) : a(_a), b(_b), c(_c) { }
	node() { a = b = c = 0; }
};

struct mat {
	int a[4][4];
	mat() { memset(a, 0, sizeof a); }
	int* operator [](int x) { return a[x]; }
	friend mat operator * (mat a, mat b) {
		mat c;
		rep(i, 0, 3) rep(j, 0, 3) if(a[i][j])
			rep(k, 0, 3) c[i][k] = (c[i][k] + 1ll * a[i][j] * b[j][k] % mod) % mod;
		return c;
	}
} t;
	
void solve(int l, int r, const node &lst) {
	t = mat(); node c(l, r);
	ll A = lst.a, B = lst.b, C = (c.a - lst.a + mod) % mod, D = (c.b - lst.b + mod) % mod, E = (1ll - A - B - C - D + mod * 4ll) % mod;
	
	
	t[0][0] = (A + C + E) % mod; t[0][1] = D;                 t[0][2] = B;
	t[1][0] = E;                 t[1][1] = (A + C + D) % mod;                              t[1][3] = B;
	t[2][0] = E;                 t[2][1] = (C + D) % mod;     t[2][2] = (A + B) % mod; 
	t[3][0] = E;                 t[3][1] = (C + D) % mod;     t[3][2] = 0;                 t[3][3] = (A + B) % mod;
	
	mat res = t; for(int v = K - 1; v; v >>= 1, t = t * t) if(v & 1) res = res * t;
	ans = (ans + res[0][1]) % mod; ans = (ans + res[0][3]) % mod;
	if(l == r) return; int mid = in; solve(l, mid, c); solve(mid + 1, r, c);
}

int main() {
#ifndef ONLINE_JUDGE
	freopen("1.in", "r", stdin);
#endif
	n = in, K = in; iv = qp(1ll * n * (n + 1) / 2 % mod, mod - 2);
	solve(1, n, node(0, 0, 1)); printf("%d\n", ans); return 0;
}

 ```

---

## 作者：Fuyuki (赞：14)

根据期望的线性性展开，分别求每个节点最后存在标记的概率。

一个节点分三个状态，祖先和自己都没有标记，自己有标记，祖先有标记。

如果祖先有标记，那么在访问到兄弟节点的时候自己会得到标记。

如果自己有标记，在访问到自己的子树内节点时标记会失去。

如果覆盖的情况下访问到当前节点，那么无论什么情况，自己都会得到标记。

类似讨论一下，分别计算出 访问自己，访问祖先，访问儿子，访问兄弟，询问不交 的概率，然后三种状态之间的转移就可以用这些概率进行表示。

发现这些转移可以写成矩阵的形式，那么就可以矩阵快速幂求解了。

时间复杂度为 $O(n3^3logk)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define I inline int
#define V inline void
#define ll long long int
#define isnum(ch) ('0'<=ch&&ch<='9')
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)
char _buf[100000],*_op(_buf),*_ed(_buf);
I getint(){
	int _s=0;char _ch=gc;
	while(!isnum(_ch))_ch=gc;
	while(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;
	return _s;
}
const int N=5e5,mod=998244353;
int n,m,rt,tot,ans,bas;
int mid[N],len[N],ls[N],rs[N],f[N],s[N],g[N],h[N];
V check(int&x){x-=mod,x+=x>>31&mod;}
I calc(int x){return 1ll*x*(x+1)/2%mod;}
I calc(int l,int r){return(calc(r)+mod-calc(l-1))%mod;}
I Pow(ll t,int x,ll s=1){for(;x;x>>=1,t=t*t%mod)if(x&1)s=s*t%mod;return s;}
#define lc ls[p]
#define rc rs[p]
#define root rt,1,n
#define lson lc,L,mid[p]
#define rson rc,mid[p]+1,R
#define mul(a,b,c){\
		FOR(i,0,2)FOR(j,0,2)FOR(k,0,2)tmp[i][j]+=1ll*a[i][k]*b[k][j];\
		FOR(i,0,2)FOR(j,0,2)c[i][j]=tmp[i][j]%mod,tmp[i][j]=0;}
V init(int&p,int L,int R){
	if(len[p=++tot]=R-L+1,L==R)return;
	mid[p]=getint(),init(lson),init(rson);
}
V work(int p,int L,int R,int fa=0){
	static ll tmp[3][3],S[3][3],T[3][3];
	h[p]=1ll*(calc(L-1)+calc(n-R))*bas%mod;
	f[p]=(1ll*L*(n+1-R)%mod*bas+mod-s[fa])%mod,check(s[p]=s[fa]+f[p]);
	ll p1=f[p],p2=s[fa],p3=g[p],p4=(1ll*(R-L)*(n-R+L-1)+calc(R-L+1)-1)%mod*bas%mod,p5=h[fa];
	FOR(i,0,2)FOR(j,0,2)S[i][j]=i==j;
	T[0][0]=(p3+p4+p5)%mod,T[0][1]=p2,T[0][2]=p1;
	T[1][0]=p4,T[1][1]=(p2+p5)%mod,T[1][2]=(p1+p3)%mod;
	T[2][0]=p4,T[2][1]=0,T[2][2]=(p1+p2+p3+p5)%mod;
	for(int x=m;x;x>>=1){if(x&1)mul(S,T,S);mul(T,T,T);}
	if(check(ans+=S[0][2]),L==R)return;
	g[lc]=(1ll*(R-mid[p])*(n-R)+calc(R-mid[p]))%mod*bas%mod;
	g[rc]=(1ll*(mid[p]-L+1)*(L-1)+calc(mid[p]-L+1))%mod*bas%mod;
	work(lson,p),work(rson,p);
}
int main(){
	n=getint(),m=getint(),bas=Pow(calc(n),mod-2);
	init(root),work(root),cout<<ans;
	return 0;
}
```


---

## 作者：dead_X (赞：10)

## 前言
这题和 [ZJOI2019]线段树 完全一致！！1
## Section 1
我们直接把总期望套路地拆成每个节点有 tag 的期望。由于只有 $O(n)$ 个节点，每个节点的复杂度还是比较充裕的。

我们依旧延续前一题的思路，将线段树上的节点分为 $5$ 类：

![](https://i.loli.net/2019/04/02/5ca2b0fce8b8c.png)

（图是 Sooke 的）

这张图上的白，深灰，橙，浅灰，黄分别对应了这五类节点的位置。
## Section 2
那么显然每次操作的时候，一个节点各有 $p_1,p_2,p_3,p_4,p_5$ 的概率成为这五类节点。

我们考虑怎么算这些概率。

下文中，令查询的区间为 $A$，节点代表的区间为 $B$，节点父亲代表的区间为 $F$。

第一类：白色

$$A\cap B\neq\varnothing,B\not\subseteq A$$

第二类：深灰色

$$B\subseteq A,F\not\subseteq A$$

第三类：橙色

$$A\cap B=\varnothing,F\cap B\neq\varnothing$$

第四类：浅灰色

$$F\subseteq A$$

第五类：黄色

$$F\cap B=\varnothing$$

然后你发现这些东西都可以 $O(1)$ 算。
## Section 3
然后我们沿用上一题的套路，记 $f$ 为这个节点有 tag 的期望，$g$ 为这个节点所有祖先都没有 tag 的期望。

于是五类点的 $f,g$ 转移就能求出来了，具体可以看看那题的题解。

将每个点的转移乘上对应的概率 $p$，我们就可以得到总转移方程。这个方程显然可以化成一个 $3\times 3$ 的矩阵然后快速幂，于是这题就做完了。

时间复杂度：$O(n\log k)$，要乘上矩阵快速幂的 $27$ 倍常数。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
const int p=998244353;
struct mat
{
	int a[3][3];
	mat operator*(const mat&t)const
	{
		mat r;
		for(int i=0; i<3; ++i) for(int j=0; j<3; ++j) r.a[i][j]=0;
		for(int i=0; i<3; ++i) for(int j=0; j<3; ++j) for(int k=0; k<3; ++k) (r.a[i][k]+=a[i][j]*t.a[j][k])%=p;
		return r;
	}
};
mat qp(mat x,int y)
{
	mat res=x;
	--y;
	for(mat t=x; y; y>>=1,t=t*t) if(y&1) res=res*t;
	return res;
}
int qp(int x,int y)
{
	int res=1;
	for(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;
	return res;
}
int n=read(),k=read(),g=qp(((n*(n+1))>>1)%p,p-2),ans,qwq[200003];
int calc(int l,int r,int fl,int fr)
{
	mat m;
	for(int i=0; i<3; ++i) for(int j=0; j<3; ++j) m.a[i][j]=0;
	m.a[2][2]=1;//f=0 g=1 1=1
	int A=(p*3+qwq[n]-(l*(n+1-r)%p)-qwq[l-1]-qwq[n-r])%p*g%p,
	    B=(l*(n-r+1)-fl*(n-fr+1))%p*g%p,
		C=(p*2+qwq[l-1]+qwq[n-r]-qwq[max(fl-1,0ll)]-qwq[n-fr])%p*g%p,
		D=fl*(n-fr+1)%p*g%p,
		E=(qwq[max(fl-1,0ll)]+qwq[n-fr])%p*g%p;
	assert((A+B+C+D+E)%p==1);
	(m.a[2][1]+=A)%=p,
	(m.a[2][0]+=B)%=p,
	(m.a[2][0]+=C)%=p,
	(m.a[1][0]+=p-C)%=p,
	(m.a[1][1]+=C)%=p,
	(m.a[0][0]+=D)%=p,
	(m.a[0][0]+=E)%=p,
	(m.a[1][1]+=E)%=p,
	m=qp(m,k);
	return (m.a[1][0]+m.a[2][0])%p;
}
void dfs(int l,int r,int fl,int fr)
{
	(ans+=calc(l,r,fl,fr))%=p;
	if(l==r) return ;
	int mid=read();
	dfs(l,mid,l,r),dfs(mid+1,r,l,r);
	return ;
}
signed main()
{
	for(int i=1; i<=n; ++i) qwq[i]=((i*(i+1))>>1)%p;
	dfs(1,n,0,n),printf("%lld\n",ans);
    return 0;
}


```

---

## 作者：Thinking (赞：9)

首先，每个结点都是独立的，所以不妨分开计算贡献。

按照[P5280](https://www.luogu.com.cn/problem/P5280)的套路，我们定义 $P_o$ 为 $o$ 上有标记的概率，$P_f$ 为 $o$ 及其祖先上有标记的概率，同时记 $o$ 控制的区间为 $[L,R]$，$o$ 的父亲的为 $[l,r]$（可以避免对左/右儿子的分类讨论），修改区间为 $[x,y]$。

考虑以下五种情况：

1. 修改不会进入 $o$ 的父亲。则 $1\le x\le y<l$ 或 $r<x\le y\le n$，此时 $P_o'=P_o,P_f'=P_f$。
2. 修改进入 $o$ 的父亲，并在 $o$ 上打了标记。则 $1\le x\le L,R\le y<r$ 或 $l<x\le L,R\le y\le n$，此时 $P_o'=P_f'=1$。
3. 修改标记了 $o$ 的祖先。则 $1\le x\le l,r\le y\le n$，此时 $P_o'=P_o,P_f'=1$。
4. 修改下推了 $o$ 的父亲的标记，但没有进入 $o$。则 $l\le y<L,1\le x\le y$ 或 $R<x\le r,x\le y\le n$，此时 $P_o'=P_f'=P_f$。
5. 修改进入了 $o$。则 $P_o'=P_f'=0$。

显然每次转移的系数都不变，因此可以用矩阵加速。同时，有一个可以大大减小常数的 trick：可以注意到 $3\times 3$ 矩阵中在变化的值只有 5 个，因此只需要计算这 5 个值就可以了，可以将乘法次数减小到 7 次，取模次数减小到 5 次。

code:

```cpp
#include<cstdio>
typedef long long ll;
const int mod=998244353;
const int BUF=1<<21;
char rB[BUF],*rS,*rT;
inline char gc(){return rS==rT&&(rT=(rS=rB)+fread(rB,1,BUF,stdin),rS==rT)?EOF:*rS++;}
inline int rd(){
    char c=gc();
    while(c<48||c>57)c=gc();
    int x=c&15;
    for(c=gc();c>=48&&c<=57;c=gc())x=x*10+(c&15);
    return x;
}
int n,k,div,ans;
inline void inc(int&a,int b){a+=b;if(a>=mod)a-=mod;}
void exgcd(int a,int b,int&x,int&y){
	if(!b){x=1;y=0;}
	else{
		exgcd(b,a%b,y,x);
		y-=a/b*x;
	}
}
inline int inv(int a){
	int x,y;
	exgcd(a,mod,x,y);
	return x+((x>>31)&mod);
}
struct mat{
	int a11,a12,a13,a22,a23;
	mat(int a,int b,int c,int d,int e):a11(a),a12(b),a13(c),a22(d),a23(e){}
	inline mat operator*(const mat&b)const{return mat((ll)a11*b.a11%mod,((ll)a11*b.a12+(ll)a12*b.a22)%mod,((ll)a11*b.a13+(ll)a12*b.a23+a13)%mod,(ll)a22*b.a22%mod,((ll)a22*b.a23+a23)%mod);}
};
inline int fp(mat a){
	mat s(1,0,0,1,0);
	for(int p=k;p;p>>=1){
		if(p&1)s=s*a;
		a=a*a;
	}
	return s.a13;
}
void solve(int L,int R,int l,int r){
	if(L<R){
		int M=rd();
		solve(L,M,L,R);solve(M+1,R,L,R);
	}
	if(!l)inc(ans,div);  //o 为根节点
	else{
		int a=((ll)l*(l-1)+(ll)(n-r)*(n-r+1)>>1)%mod,b=((ll)L*(r-R)+(ll)(n-R+1)*(L-l))%mod,c=(ll)l*(n-r+1)%mod,d=((ll)(l+L-1)*(L-l)+(ll)(n*2-R-r+1)*(r-R)>>1)%mod;
//a,b,c,d 对应情况 1,2,3,4
		inc(ans,fp(mat((ll)(a+c)*div%mod,(ll)d*div%mod,(ll)b*div%mod,(ll)(a+d)*div%mod,(ll)(b+c)*div%mod)));
	}
}
int main(){
	n=rd();k=rd();div=inv(((ll)n*(n+1)>>1)%mod);
	solve(1,n,0,0);
	printf("%d",ans);
	return 0;
}
```


---

## 作者：littleKtian (赞：5)

考虑对于线段树的每个节点，有多少种方案使这个节点有标记。

记 $t=\dfrac{n(n+1)}{2}$，设 $a_i,b_i,c_i,d_i,e_i$ 分别表示 **能直接给第 $i$ 个节点打上标记的区间操作数，能直接将第 $i$ 个节点的标记拆掉的区间操作数，不能直接给第 $i$ 个节点打上标记但能将其祖先的标记传给该节点的区间操作数，不会对该节点标记情况有影响的区间操作数，能给第 $i$ 个节点或其祖先打上标记的区间操作数**。

那么根据样例一我们能列出这样的表格：

![](https://cdn.luogu.com.cn/upload/image_hosting/yy0ga2qf.png)

| $i$ | $a_i$ | $b_i$ | $c_i$ | $d_i$ | $e_i$ |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| $1$ | $1$ | $5$ | $0$ | $0$ | $1$ |
| $2$ | $2$ | $0$ | $3$ | $1$ | $3$ |
| $3$ | $1$ | $3$ | $1$ | $1$ | $2$ |
| $4$ | $2$ | $0$ | $1$ | $3$ | $4$ |
| $5$ | $1$ | $0$ | $2$ | $3$ | $3$ |

比如对于 $3$ 号节点，区间 $(2,3)$ 可以直接给它打上标记；区间 $(1,2),(2,2),(3,3)$ 能将它的标记拆掉；区间 $(1,1)$ 不能直接给它打上标记，但如果它的祖先（$1$ 号点）有标记，那么它祖先的标记会被传给它；区间 $(1,3)$ 在本次操作时不会改变它的标记情况；区间 $(1,3),(2,3)$ 可以将其或其祖先打上标记。

可以得到：

$\begin{cases}a_i+b_i+c_i+d_i=t\\a_i=e_i-e_{fa_i}\\d_i=e_{fa_i}+\dfrac{l_{fa_i}(l_{fa_i}-1)}{2}+\dfrac{(n-r_{fa_i})(n-r_{fa_i}+1)}{2}\\e_i=l_i\times(n-r_i+1)\end{cases}$

其中 $l_i,r_i$ 分别为该节点所记录线段的 $l,r$，$fa_i$ 为该节点父亲的编号。

（特别的，$a_1=e_1=1,b_1=t-1,c_1=d_1=0$）

问题就在于如何计算 $b_i$ 和 $c_i$ 了。

发现如果一个区间满足 不能直接给第 $i$ 个节点打上标记但能将其祖先的标记传给该节点，一定有某个端点在第 $i$ 个节点的兄弟表示的线段内，并且两个端点在第 $i$ 的节点的同侧。于是就可以求出 $c_i$ 了。

利用 $b_i=t-a_i-c_i-d_i$ 就可以求出 $b_i$ 了。

简(fu)单(za)来讲就是：
```cpp
//ca,cb,na,nc,cfa依次对应上面的a,b,c,d,e
void csh(int &w,ll L,ll R)
{
	w=++tot,cfa[w]=L*(n-R+1)%p;
	if(L==R)return;
	ll m=dr();
	csh(ls[w],L,m),csh(rs[w],m+1,R);
	ca[ls[w]]=L*(R-m)%p,ca[rs[w]]=(m+1-L)*(n-R+1)%p;
	nc[ls[w]]=nc[rs[w]]=(cfa[w]+((L*(L-1))>>1)+(((n-R)*(n-R+1))>>1))%p;
	na[ls[w]]=((((n<<1)-m-R+1)*(R-m))>>1)%p,na[rs[w]]=(((L+m)*(m-L+1))>>1)%p;
	cb[ls[w]]=(t-ca[ls[w]]-nc[ls[w]]-na[ls[w]]+p*3)%p,cb[rs[w]]=(t-ca[rs[w]]-nc[rs[w]]-na[rs[w]]+p*3)%p;
}
int main()
{
	/* 代码 */
	csh(rt,1,n);
	ca[rt]=cfa[rt]=1,cb[rt]=(t-1+p)%p;
}
```


记 $f_{i,j},g_{i,j}$ 分别为第 $i$ 个节点在 $j$ 次操作后 自己/自己或其某个祖先 有标记的方案数。

可得：

$\begin{cases}f_{i,j}=t^{j-1}\times a_i+g_{i,j-1}\times c_i+f_{i,j-1}\times d_i\\g_{i,j}=t^{i-1}\times e_i+g_{i,j-1}\times(t-b_i-e_i)\end{cases}$

（$g_{i,j}$ 中最后 $-e_i$ 是因为和上面有重复所以减去，其他由定义可得）

特别的，$f_{i,1}=a_i,g_{i,1}=e_i$。

然后就容易想到用矩乘做了。

复杂度 $O(27n\log k)$。

---

## 作者：xzCyanBrad (赞：3)

根据期望的线性性质，我们只需要知道每个点最后有 tag 的**概率**就行了。

记录每个节点 $u$ 的 $[L_u,R_u]$ 代表管辖区间，下面设 $u$ 的父亲叫 $p$，兄弟叫 $v$，$\textbf Q(x)=1+2+\cdots+x=\frac12x(x+1)$。我们讨论覆盖的区间与树上该节点附近区间的关系的所有可能的情况：

1. 跟父亲无关，方案数 $W_1=\textbf Q(L_p-1)+\textbf Q(n-R_p)$；
2. 覆盖父亲，方案数 $W_2=L_p(n-R_p+1)$；
3. 覆盖自己但是并不覆盖父亲，方案数 $W_3=L_u(n-R_u+1)-L_p(n-R_p+1)$；
4. 跟自己无关，跟兄弟有关：
   - $u$ 是左儿子：方案数 $W_4=\textbf Q(n-L_v+1)-\textbf Q(n-R_v)$；
   - $u$ 是右儿子：方案数 $W_4=\textbf Q(R_v)-\textbf Q(L_v-1)$；
5. 进入了自己：$W_5=(L_u-1)(R_u-L_u)+(n-R_u)(R_u-L_u)+\textbf Q(R_u-L_u+1)-1$。

设 $F(i,0/1/2)$ 表示现在的时刻为 $i$，状态是（祖先到自己无标记 或 仅祖先有标记 或 自己有标记）。那么有转移：
$$
\small\begin{aligned}
&F(i,0)=&(W_1+W_4+W_5)F(i-1,0)&+&W_5F(i-1,1)&+&W_5F(i-1,2)\\
&F(i,1)=&W_2F(i-1,0)&+&(W_1+W_2)F(i-1,1)&+&0F(i-1,2)\\
&F(i,2)=&W_3F(i-1,0)&+&(W_3+W_4)F(i-1,1)&+&(W_1+W_2+W_3+W_4)F(i-1,2)\\
\end{aligned}
$$
直接做是 $\Theta(nkB^2)$（其中 $B=3$）的，过不了。显然的优化是写成矩阵形式：
$$
\begin{bmatrix}F(i,0)\\F(i,1)\\F(i,2)\end{bmatrix}=\begin{bmatrix}W_1+W_4+W_5&W_5&W_5\\W_2&W_1+W_2&0\\W_3&W_3+W_4&W_1+W_2+W_3+W_4\end{bmatrix}\begin{bmatrix}F(i-1,0)\\F(i-1,1)\\F(i-1,2)\end{bmatrix}
$$
我们把 $3\times 3$ 的转移矩阵 $A$ 进行 $n$ 次幂，则需要求的概率即为 $\dfrac{(A^k)_{2,0}}{\textbf Q(n)^k}$。把所有概率加起来就好了。

复杂度 $\Theta(nB^3\log k)$，跑得飞快，$600\ \mathrm{ms}$。一遍过，好耶！

---

## 作者：KingPowers (赞：2)

显然地，根据期望线性性，我们要求的其实是每个点最终有标记的概率之和。

看到 $k\le 10^9$ 的数据范围其实已经能大致猜出本题做法了：猜测每次操作对每个点有标记的概率的影响一定是线性变换，描述出这种线性变换之后就可以直接矩阵快速幂推了。

同时可以观察到每次操作对每个点的概率影响是很独立的，因此我们可以尝试每个点分别计算。

不妨用类似 dp 的方式来描述这种线性变换，因为祖先的标记可以下放到自己，所以可以设 $f_{i,0/1}$ 表示 $i$ 自己是标记点的概率/自己和祖先中存在标记点的概率。

设 $i$ 的区间为 $[l,r]$，$i$ 的父亲的区间为 $[fl,fr]$，操作选择的区间为 $[x,y]$，转移需要考虑我们选择了哪种区间，分以下五种情况：

- 如果选择的区间和父亲区间没有交集，也就是 $[x,y]\cap[fl,fr]=\empty$，那么打标记的点和 $i$ 没有任何关系，$f'_{i,0}=f_{i,0}$，$f'_{i,1}=f_{i,1}$，这种的方案数为 $C_{fl}^2+C_{n-fr}^2$。

- 如果选择的区间给自己打了标记，此时有 $f'_{i,0}=1$，$f'_{i,1}=1$，这种的方案数为 $l(fr-r)+(l-fl)(n-r+1)$。

- 如果选择的区间给祖先打了标记且并不影响自己，此时有 $f'_{i,0}=f_{i,0}$，$f'_{i,1}=1$，这种的方案数为 $fl(n-fr+1)$。

- 如果把父亲的标记下传给了自己，此时有 $f'_{i,0}=f_{i,1}$，$f'_{i,1}=f_{i,1}$，这种的方案数为 $(fl + l - 1)(l - fl) + (2n - r - fr + 1)(fr - r)$。

- 当然还有一种情况是访问到了子树内的点，这时候 $f_{i,0/1}$ 都会被清零，没有贡献。

每种情况的方案数除以 $C_n^2$ 就是其对应的概率，我们分别记四种情况的概率为 $a,b,c,d$，那么转移显然可以写成下面这种形式：

$$
\begin{bmatrix}f_{i,0}&f_{i,1}&1\end{bmatrix}
\times 
\begin{bmatrix}a+c&0&0\\d&a+d&0\\b&b+c&1\end{bmatrix}
=
\begin{bmatrix}f'_{i,0}&f'_{i,1}&1\end{bmatrix}
$$

矩阵快速幂优化即可，时间复杂度 $O(nt^3\log n)$，其中 $t=3$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define For(i, a, b) for(int i = (a); i <= (b); i++)
#define Rof(i, a, b) for(int i = (a); i >= (b); i--)
#define deb(x) cerr << #x"=" << x << '\n';
using namespace std;
const int N = 5e5 + 5, mod = 998244353;
struct matrix{
	int v[4][4];
	matrix(){memset(v, 0, sizeof v);}
    friend matrix operator*(const matrix &a, const matrix &b){
        matrix c;
        For(k, 1, 3) For(i, 1, 3) For(j, 1, 3)
            c.v[i][j] += a.v[i][k] * b.v[k][j] % mod,
            c.v[i][j] %= mod;
        return c;
    }
}G;
int qpow(int x, int y){
	int res = 1;
	for(; y; x = x * x % mod, y >>= 1)
		if(y & 1) res = res * x % mod;
	return res;
}
matrix qpow(matrix a, int b){
    matrix res;
    For(i, 1, 3) res.v[i][i] = 1; 
    while(b){
        if(b & 1) res = res * a;
        a = a * a; b >>= 1;
    }
    return res;
}
int n, k, ans, inv;
void calc(int l, int r, int fl, int fr){
	int a = (fl * (fl - 1) + (n - fr) * (n - fr + 1)) / 2 %mod;
	int b = (l * (fr - r) + (n - r + 1) * (l - fl)) % mod;
	int c = fl * (n - fr + 1) % mod;
	int d = ((fl + l - 1) * (l - fl) + (2 * n - r - fr + 1) * (fr - r)) / 2 % mod;
	G = matrix(); G.v[3][3] = 1;
	a = a * inv % mod; b = b * inv % mod; c = c * inv % mod; d = d * inv % mod;
	//第一种：没有交集，不影响
	G.v[1][1] += a; G.v[2][2] += a;
	//第二种：访问到了自己
	G.v[3][1] += b; G.v[3][2] += b;
	//第三种：访问到了祖先
	G.v[1][1] += c; G.v[3][2] += c;
	//第四种：祖先下传到自己
	G.v[2][1] += d; G.v[2][2] += d;
	For(i, 1, 3) For(j, 1, 3) if(G.v[i][j]) G.v[i][j] %= mod; 
	G = qpow(G, k); ans = (ans + G.v[3][1]) % mod; 
}
void solve(int l, int r, int fl, int fr){
	if(l == 1 && r == n) ans = (ans + inv) % mod;
	else calc(l, r, fl, fr);
	if(l == r) return;
	int mid; cin >> mid;
	solve(l, mid, l, r); solve(mid + 1, r, l, r);
}
void Solve(){
	cin >> n >> k; 
	inv = qpow(n * (n + 1) / 2 % mod, mod - 2);
	solve(1, n, 1, n);
	cout << ans << '\n';
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	int T = 1; //cin >> T;
	while(T--) Solve();
	return 0;
}
```

---

## 作者：BelowHorizon (赞：1)

设 $f_i$ 表示节点有标记， $g_i$ 表示当前节点没有标记，但祖先有标记， $h_i$ 表示当前节点和祖先节点都没有标记。

这里总共有 $3\times 3$ 种转移的情况。

设总方案数为 $A=n\times(n+1)/2$，和当前无交的区间方案数为 $B=l\times(l-1)/2+(n-r)\times(n-r+1)/2$ ，包含当前区间的方案数为 $C=l\times(n-r+2)$ ，与当前区间有交的方案数为 $D=A-B-C$。

1.$f\rightarrow f$ 只有经过当前节点才会不满足。即有交的被排除。答案为 B+C 。

2.$f\rightarrow g$ 不可能，答案为 0。

3.$f\rightarrow h$ 即和当前区间有交，答案为 A-B-C 。

4.$g\rightarrow f$ 即和父亲相交，并且父亲不能被包含，并且不能与当前节点相交，答案为 B+C-FB-FC 。

5.$g\rightarrow g$ 即包含父亲或与父亲无交，答案为 FB+FC。

6.$g\rightarrow h$ 即经过当前节点，答案为 A-B-C 。

7.$h\rightarrow f$ 即当前节点被包含，且与父亲相交，答案为 C-FC 。

8.$h\rightarrow g$ 即当前父亲节点被包含，答案为 FC 。

9.$h\rightarrow h$ 即不包含当前节点，答案为 A-C 。

把每个答案乘 A 的逆就是概率了。把每个转移综合起来就得到了转移方程。因为每次转移都一样所以可以用矩阵优化。时间复杂度是 $O(27n\log k)$ 。


---

## 作者：lupengheyyds (赞：0)

# P6630 [ZJOI2020] 传统艺能 题解

巧妙的状态设计。

首先根据期望线性对线段树上每个节点考虑最后被覆盖的概率。

设这个节点为 $[L_x,R_x]$，其父亲节点的区间为 $[L_f,R_f]$，考虑一次区间操作 $[l,r]$ 可能对这个节点造成的影响。

1. $[L_f,R_f]\subseteq [l,r]$：覆盖了父亲，那肯定跟 $[L_x,R_x]$ 没有关系，$tag_x$ 不会变化。
2. $[L_x,R_x]\subseteq [l,r]\land [L_f,R_f]\not \subseteq[l,r]$：包含自己但是不包含父亲， $tag_x$一定变为 $1$。
3. $[L_x,R_x]\cap [l,r]=\emptyset\land [L_f,R_f]\cap[l,r]\ne\emptyset$：父亲会下放 $tag$，此时 $tag_x$ 会变成自己及所有祖先的 $tag$ 的并。
4. $[L_x,R_x]\not\subseteq [l,r]\land [L_f,R_f]\cap[l,r]\ne\emptyset$：自己的 $tag_x$ 会被下放此时 $tag_x=0$。
5. $[L_f,R_f]\cap[l,r]=\emptyset$：与父亲无交集，对  $tag_x$不影响。

可以证明只有上述 $5$ 种情况，发现第 $3$ 种情况需要知道上一次所有祖先的 $tag$ 状态，于是朴素的想到将所有 $n$ 个节点的状态存成一个 $n$ 维向量，用一个 $n\times n$ 的矩阵结合矩阵快速幂解决，复杂度 $\mathcal O(n^3\log k)$。不能接受。

巧妙的设计：由于仅关注祖先的 $tag$ 并，我们可以额外存一枚状态来表示。

具体的，设 $f_{a\in \{0,1\},b\in \{0,1\}}$ 表示祖先的 $tag$ 并为 $a$，$tag_x=b$ 的概率。

设上面 $5$ 状态的概率分别为 $A,B,C,D,E$，那么一次转移可以写作：
$$
\begin{aligned}
&f_{0,0}\gets Cf_{0,0}+D(f_{1,0}+f_{1,1}+f_{0,1}+f_{0,0})+Ef_{0,0}\\
&f_{0,1}\gets B(f_{1,0}+f_{1,1}+f_{0,1}+f_{0,0})+C(f_{1,0}+f_{1,1}+f_{0,1})+Ef_{0,1}\\
&f_{1,0}\gets A(f_{0,0}+f_{1,0})+Ef_{1,0}\\
&f_{1,1}\gets A(f_{0,1}+f_{1,1})+Ef_{1,1}
\end{aligned}
$$
 然后最终的答案就是 $f_{0,1}+f_{1,1}$，可以设 $f_0=f_{0,0},f_1=f_{1,0},f_2=f_{0,1}+f_{1,1}$，这样即可将转移写作：
$$
\begin{bmatrix}
C+D+E&D&D\\A&A+E&0\\B&B+C&A+B+C+E
\end{bmatrix}
$$
对每个点矩阵快速幂即可。

注意特判区间 $[1,n]$，它的状态仅取决于最后一次操作。

---

## 作者：Purslane (赞：0)

# Solution

根据期望的线性性，我们只需要计算最后每个位置有标记的概率。

分类讨论区间 $[l,r]$，其父区间 $[L,R]$，以及修改区间 $[x,y]$ 产生的影响。

1. 如果 $[x,y] \cap [L,R] = \varnothing$ 或 $[L,R] \subseteq[x,y]$则不会有任何影响。
2. 如果 $[l,r] \subseteq [x,y]$，且 $[L,R] \not \subseteq [x,y]$，那么 $[l,r]$ 所有父区间的标记全部被清空，且 $[l,r]$ 被打上标记。
3. 如果 $[l,r] \cap [x,y] \neq \varnothing$，且 $[l,r] \not \subseteq [x,y]$，那么 $[l,r]$ 和所有父区间的标记全部被清空。
4. 如果 $[l,r] \cap [x,y] = \varnothing$，且 $[x,y] \cap [L,R] \neq \varnothing$，则 $[l,r]$ 所有父节点的标记被全部清空，并且 $[l,r]$ 被下传标记（如果存在）。

因此我们眼中状态很少：都没标记，$[l,r]$ 有标记，$[l,r]$ 没有标记但是某个祖先有标记。

这样得到了一个 $3 \times 3$ 的矩阵，可以使用矩阵快速幂优化。

```cpp
#include<bits/stdc++.h>
#define int long long 
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2e5+10,MOD=998244353;
int n,k,ans,inv;
int qpow(int base,int p) {
	int ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;	
	}
	return ans;
}
struct Matrix {
	int v[3][3];	
};
Matrix operator *(Matrix A,Matrix B) {
	Matrix res;
	memset(res.v,0,sizeof(res.v));
	ffor(i,0,2) ffor(j,0,2) ffor(k,0,2) res.v[i][k]=(res.v[i][k]+A.v[i][j]*B.v[j][k])%MOD;
	return res;	
}
Matrix operator ^(Matrix A,int p) {
	Matrix res;
	ffor(i,0,2) ffor(j,0,2) res.v[i][j]=(i==j);
	while(p) {
		if(p&1) res=res*A;
		A=A*A,p>>=1;
	}
	return res;
}
void build(int l,int r,int L,int R) {
	Matrix trans;
	ffor(i,0,2) ffor(j,0,2) trans.v[i][j]=0;
	int cnt=((L-1)*L/2+(n-R)*(n-R+1)/2)%MOD;
	ffor(i,0,2) trans.v[i][i]=cnt*inv%MOD;
	cnt=(l*(n-r+1)-L*(n-R+1))%MOD;
	ffor(j,0,2) trans.v[j][1]=(trans.v[j][1]+cnt*inv)%MOD;
	cnt=(n*(n+1)/2-(l-1)*l/2-(n-r)*(n-r+1)/2-l*(n-r+1))%MOD;
	ffor(j,0,2) trans.v[j][0]=(trans.v[j][0]+cnt*inv)%MOD;
	cnt=L*(n-R+1)%MOD;
	trans.v[0][2]=(trans.v[0][2]+cnt*inv)%MOD,trans.v[1][1]=(trans.v[1][1]+cnt*inv)%MOD,trans.v[2][2]=(trans.v[2][2]+cnt*inv)%MOD;
	cnt=((l-1)*l/2+(n-r)*(n-r+1)/2-(L-1)*L/2-(n-R)*(n-R+1)/2)%MOD;
	trans.v[0][0]=(trans.v[0][0]+cnt*inv)%MOD,trans.v[1][1]=(trans.v[1][1]+cnt*inv)%MOD,trans.v[2][1]=(trans.v[2][1]+cnt*inv)%MOD;
	trans=trans^k;
	ans=(ans+trans.v[0][1])%MOD;
	if(l==r) return ;	
	int p;
	cin>>p;
	build(l,p,l,r),build(p+1,r,l,r); 
	return ;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>k,inv=qpow(n*(n+1)/2%MOD,MOD-2);
	build(1,n,1,n+1);
	cout<<(ans%MOD+MOD)%MOD;
	return 0;
}
``

---


# [BJOI2020] 封印

## 题目背景

注：NOI 2020 北京队选拔赛因不可抗力因素取消，改为按前一年 CSP-S 第二轮成绩选出省队。因为出现同分，为决定最终 A 队名单，举办了加试。本题即为加试题。

## 题目描述

给出只包含小写字母 $a,b$ 的两个字符串 $s, t$，$q$ 次询问，每次询问 $s[l \dots r]$ 和 $t$ 的最长公共子串长度。

## 说明/提示

| 测试点编号 | $\vert s\vert , \vert t\vert \le $ |     $q\le$     |
| :--------: | :------------: | :------------: |
|    $1$     |      $50$      |      $50$      |
|   $2,3$    | $2\times 10^3$ | $2\times 10^3$ |
|   $4,5$    | $2\times 10^5$ |      $10$      |
| $6\sim 10$ | $2\times 10^5$ | $2\times 10^5$ |

## 样例 #1

### 输入

```
aaba
aaaabbbaa
3
1 4
1 3
2 4```

### 输出

```
3
3
2```

# 题解

## 作者：lhm_ (赞：13)

设$lenth_i$为$s$在$i$位置的前缀的后缀为$t$的一个子串的最长长度，即为从$i$位置开始往前和$t$的最长公共子串长度。其可以通过对$t$建后缀自动机，然后让$s$在自动机上匹配来求出。

求出$lenth_i$后，对于区间$[l,r]$的一个询问，其答案即为：

$$
	\max_{i=l}^r \lbrace\ \min(lenth_i,i-l+1)\ \rbrace
$$

发现内层的$\min$不好处理，考虑将其去掉：

当$lenth_i \leqslant i-l+1$时，其值为$lenth_i$，转化得$i-lenth_i+1 \geqslant l$，发现$i-lenth_i+1$的值是单调不降的，因为每到下一个位置，$i$都会加一，而$lenth_i$可能加一，可能清零，所以该值是单调不降的。

那么对于区间$[l,r]$，一定存在一个位置$pos$，满足所有$i \geqslant pos$，都有$i-lenth_i+1 \geqslant l$。那么在区间$[pos,r]$中，$\min$取到了$lenth_i$，在区间$[l,pos-1]$中，$\min$取到了$i-l+1$。

$pos$可以通过二分求得，然后答案即为区间$[pos,r]$内$lenth_i$的最大值和$pos-l$取$\max$。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 400010
using namespace std;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int l1,l2,q,root=1,las=1,tot=1;
int len[maxn],fa[maxn],ch[maxn][2],lenth[maxn],f[maxn][25],lg[maxn];
char s[maxn],t[maxn];
void insert(int c)
{
    int p=las,np=las=++tot;
    len[np]=len[p]+1;
    while(p&&!ch[p][c]) ch[p][c]=np,p=fa[p];
    if(!p) fa[np]=root;
    else
    {
        int q=ch[p][c];
        if(len[q]==len[p]+1) fa[np]=q;
        else
        {
            int nq=++tot;
            ch[nq][0]=ch[q][0],ch[nq][1]=ch[q][1];
            len[nq]=len[p]+1,fa[nq]=fa[q],fa[q]=fa[np]=nq;
            while(ch[p][c]==q) ch[p][c]=nq,p=fa[p];
        }
    }
}
void init()
{
    lg[0]=-1;
    for(int i=1;i<=l1;++i) lg[i]=lg[i>>1]+1;
    for(int i=1;i<=l1;++i) f[i][0]=lenth[i];
    for(int j=1;j<=20;++j)
        for(int i=1;i+(1<<j)-1<=l1;++i)
            f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);
}
int query(int l,int r)
{
    if(l>r) return 0;
    int len=lg[r-l+1];
    return max(f[l][len],f[r-(1<<len)+1][len]);
}
int find(int l,int r)
{
    int pos=r+1,L=l;
    while(l<=r)
    {
        int mid=(l+r)>>1;
        if(mid-lenth[mid]+1>=L) pos=mid,r=mid-1;
        else l=mid+1;
    }
    return pos;
}
void work()
{
    int p=root;
    for(int i=1;i<=l1;++i)
    {
        int c=s[i]-'a';
        if(ch[p][c]) lenth[i]=lenth[i-1]+1,p=ch[p][c];
        else
        {
            while(p&&!ch[p][c]) p=fa[p];
            if(!p) p=root;
            else lenth[i]=len[p]+1,p=ch[p][c];
        }
    }
}
int main()
{
    scanf("%s%s",s+1,t+1);
    l1=strlen(s+1),l2=strlen(t+1);
    for(int i=1;i<=l2;++i) insert(t[i]-'a');
    work(),init(),read(q);
    while(q--)
    {
        int l,r,pos;
        read(l),read(r),pos=find(l,r);
        printf("%d\n",max(query(pos,r),pos-l));
    }
    return 0;
}
```

---

## 作者：Sol1 (赞：10)

~~我正写着这题，教练跑过来说：“写啥呢？”然后看了一眼题说：“SAM？”然而我根本不会 SAM……~~

所以这里给一个 SA 做法。

其实很套路，首先把两个字符串接在一起，$t$ 接在 $s$ 前面，中间随便放个分隔符，变成一个字符串，然后搞出这个字符串的 SA。

现在我们的目标是对于每一个 $s$ 的后缀，在 $t$ 中求一个点，使得这个点对应的后缀与这个 $s$ 的后缀的 LCP 最大。

由 SA 的性质，这个点要么是后缀数组中 $s$ 的这个后缀对应的位置前面的最后一个属于 $t$ 的后缀，要么是这个位置后面的第一个属于 $t$ 的后缀。

所以直接在后缀数组上搞出这两个点，随便求个 LCP 然后取 max 即可。

那么现在我们就知道了对于每一个 $s$ 的后缀，与 $t$ 中每一个后缀的 LCP 的最大值，设其为 $v_{[1,n]}$。

现在对于查询 $[l,r]$，只需要二分答案 $x$，当 $[l,r-x+1]$ 中 $v$ 的最大值大于等于 $x$ 的时候就判定合法，否则判定不合法。

二分到最后一个合法值即可。

使用 ST 做 RMQ，复杂度为 $O((n+q)\log n)$。

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline int Abs(const int& x) {return (x > 0 ? x : -x);}
inline int Max(const int& x, const int& y) {return (x > y ? x : y);}
inline int Min(const int& x, const int& y) {return (x < y ? x : y);}

char s[400005], strs[400005];
int n, q, m, st[22][400005], h[400005], suf[400005], cnt[400005], suftmp[400005], a[400005], b[400005], rnk[400005];

inline void Read() {
	scanf("%s", strs + 1);
	n = strlen(strs + 1);
	scanf("%s", s + 1);
	m = strlen(s + 1);
	s[m + 1] = '1';
	for (int i = 1;i <= n;i++) s[m + 1 + i] = strs[i];
	n += m + 1;
}

inline bool cmp1(int i, int j) {
	return s[i] < s[j];
}

inline void Prefix() {
	for (int i = 1;i <= n;i++) suf[i] = i;
	sort(suf + 1, suf + n + 1, cmp1);
	for (int i = 1;i <= n;) {
		int l = i;
		while (i <= n && s[suf[l]] == s[suf[i]]) rnk[suf[i++]] = l;
	}
	//for (int i = 1;i <= n;i++) cout << suf[i] << " "; cout << endl;
	for (int k = 1;k <= 19;k++) {
		for (int i = 1;i <= n;i++) b[i] = (i + (1 << k - 1) <= n ? rnk[i + (1 << k - 1)] : 0);
		memset(cnt, 0, sizeof(cnt));
		for (int i = 1;i <= n;i++) cnt[b[i]]++;
		for (int i = 1;i <= n;i++) cnt[i] += cnt[i - 1];
		for (int i = n;i >= 1;i--) suftmp[cnt[b[i]]--] = i;
		for (int i = 1;i <= n;i++) a[i] = rnk[i];
		memset(cnt, 0, sizeof(cnt));
		for (int i = 1;i <= n;i++) cnt[a[i]]++;
		for (int i = 1;i <= n;i++) cnt[i] += cnt[i - 1];
		for (int i = n;i >= 1;i--) suf[cnt[a[suftmp[i]]]--] = suftmp[i];
		for (int i = 1;i <= n;) {
			int l = i;
			while (i <= n && a[suf[l]] == a[suf[i]] && b[suf[l]] == b[suf[i]]) rnk[suf[i++]] = l;
		}
	}
	for (int i = 1;i <= n;i++) {
		h[rnk[i]] = Max(h[rnk[i - 1]] - 1, 0);
		while (s[i + h[rnk[i]]] == s[suf[rnk[i] - 1] + h[rnk[i]]]) h[rnk[i]]++;
	}
	//cout << s + 1 << endl;
	//for (int i = 1;i <= n;i++) cout << suf[i] << " "; cout << endl;
	//for (int i = 1;i <= n;i++) cout << h[i] << " "; cout << endl;
	int lcp = 0x3f3f3f3f;
	for (int i = 2;i <= n;i++) {
		lcp = Min(lcp, h[i]);
		if (suf[i] > m + 1) {
			st[0][suf[i] - 1 - m] = lcp;
			//printf("lcp=%d\n", lcp);
		}
		else lcp = h[i + 1];
	}
	lcp = 0x3f3f3f3f;
	for (int i = n;i >= 1;i--) {
		lcp = Min(lcp, h[i + 1]);
		if(suf[i] > m + 1) {
			st[0][suf[i] - 1 - m] = Max(st[0][suf[i] - 1 - m], lcp);
			//printf("lcp=%d\n", lcp);
		}
		else lcp = h[i];
	}
	for (int i = 1;i <= 20;i++) {
		for (int j = 1;j <= n;j++) {
			if (j + (1 << i - 1) > n) break;
			st[i][j] = Max(st[i - 1][j], st[i - 1][j + (1 << i - 1)]);
		}
	}
}

inline int Maxlen(int l, int r) {
	if (l > r) return 0;
	int k = 31 - __builtin_clz(r - l + 1);
	return Max(st[k][l], st[k][r - (1 << k) + 1]);
}

inline int Query(int ll, int rr) {
	int l = 0, r = rr - ll + 2;
	while (l < r - 1) {
		int mid = l + r >> 1;
		if (Maxlen(ll, rr - mid + 1) >= mid) l = mid;
		else r = mid;
	}
	return l;
}

inline void Solve() {
	scanf("%d", &q);
	while (q--) {
		int l, r;
		scanf("%d%d", &l, &r);
		printf("%d\n", Query(l, r));
	}
}

int main() {
	Read();
	Prefix();
	Solve();
	#ifdef CFA_44
	while (1);
	#endif
	return 0;
}

```

---

## 作者：周子衡 (赞：10)

知识点：SAM（或者其他子串数据结构）+ 简单分类讨论

首先明显的思路是：对于每个 $i$，维护一个最小的 $l_i$ 使得 $s[l_i...i]$ 是 $t$ 的子串。这一部分可以用后缀自动机（SAM）轻松实现，对 $t$ 建立 SAM 然后不断枚举 $s$ 的下一个字符即可。

计算一个 $len_i=i-l_i+1$。那么对于每一个询问 $[l,r]$，相当于求 $\max_{l\leq i\leq r}\{\min\{len_i,i-l+1\}\}$。令 $f(i)=i-l+1$，观察到 $len_i-f(i)$ 不增，二分其零点即可。

时间复杂度 $O(n\log n)$。当然也可离线然后单调栈处理，做到线性 $O(n)$。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

struct SAM
{
	struct nd
	{
		int ch[2],fail,len;
	}t[500000];int used,last;
	void init(){memset(t,0,sizeof(t));used=last=1;}
	int new_node(int len){used++;t[used].len=len;return used;}
	void ins(int x)
	{
		int p=last,cur=new_node(t[p].len+1);
		while(p&&!t[p].ch[x]){t[p].ch[x]=cur;p=t[p].fail;}
		if(!p){t[cur].fail=1;}
		else
		{
			int q=t[p].ch[x];
			if(t[q].len==t[p].len+1)t[cur].fail=q;
			else
			{
				int clone=new_node(t[p].len+1);t[clone].fail=t[q].fail;for(int i=0;i<2;i++)t[clone].ch[i]=t[q].ch[i];
				while(p&&t[p].ch[x]==q){t[p].ch[x]=clone;p=t[p].fail;}
				t[q].fail=t[cur].fail=clone;
			}
		}
		last=cur;
	}
	void output()
	{
		for(int i=1;i<=used;i++)printf("%d: %d %d %d %d\n",i,t[i].fail,t[i].len,t[i].ch[0],t[i].ch[1]);
	}
}T;

char ss[300000],tt[300000];int s[300000],t[300000];

int L[300000],len[300000];

struct ST
{
	int maxn[300000][20],n,lg[300000];
	void init(int *a,int nn)
	{
		n=nn;lg[0]=-1;for(int i=1;i<=n;i++)lg[i]=lg[i>>1]+1;
		for(int i=1;i<=n;i++)maxn[i][0]=a[i];
		for(int j=1;(1<<j)<=n;j++)
		{
			for(int i=1;i+(1<<j)-1<=n;i++)
			{
				maxn[i][j]=max(maxn[i][j-1],maxn[i+(1<<(j-1))][j-1]);
			}
		}
	}
	int query(int l,int r)
	{
		int len=lg[r-l+1];
		return max(maxn[l][len],maxn[r-(1<<len)+1][len]);
	}
}M;

int main()
{
	scanf("%s%s",ss+1,tt+1);int n=strlen(ss+1),m=strlen(tt+1);
	for(int i=1;i<=n;i++)s[i]=ss[i]-'a';for(int i=1;i<=m;i++)t[i]=tt[i]-'a';
	T.init();for(int i=1;i<=m;i++)T.ins(t[i]);//T.output();
	int p=1,ln=0;
	for(int i=1;i<=n;i++)
	{
		while(p!=1&&!T.t[p].ch[s[i]])p=T.t[p].fail,ln=T.t[p].len;
		if(T.t[p].ch[s[i]])p=T.t[p].ch[s[i]],ln++;
		len[i]=ln;L[i]=i-len[i]+1;//printf("%d %d %d\n",p,len[i],L[i]);
	}
	M.init(len,n);
	int q=0;scanf("%d",&q);
	while(q--)
	{
		int l=0,r=0;scanf("%d%d",&l,&r);
		if(L[l]>=l){printf("%d\n",M.query(l,r));}
		else if(L[r]<=l){printf("%d\n",r-l+1);}
		else
		{
			int p=lower_bound(L+l,L+r+1,l)-L;
			printf("%d\n",max(p-l,M.query(p,r)));
		}
	}
	return 0;
}
```

---

## 作者：Mr_Wu (赞：7)

场外选手来胡一下。。

首先我们不妨写出数组 $c_i (1\le i\le |s|)$ 表示从 $i$ 往后最多扩展多少仍然是 $t$ 的一个子串，也就是 $c_i=\max\{j | s[i,j]\subseteq t\}$。我们可以用各种方法将其求出，这里我用的是后缀数组。

那么现在我们每次要问的是 $\max_{l\le i\le r} \min(s_i,r-i+1) $，min 限定了串不能超过右端点。

这是很好做的，我们只需要对所有 $i$ 按照 $\min$ 取 $s_i$ 还是取 $r-i+1$ 进行分类，在查询的时候查一次区间最大值和一次区间最小值即可。

那什么时候 $\min$ 取谁发生变化呢，我们发现 $s_i\le r-i+1\Leftrightarrow s_i+i\le r+1$，所以整体 $\min$ 变化的次数是线性的。按 $r$ 离线排所有询问后即可只使用线段树进行维护。

复杂度 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAXN = 4e5 + 5, INF = 1e9;

int N, Q, c[MAXN];
namespace p1 {
	char S[MAXN]; int L, M;
	int sa[MAXN], rk[MAXN], buc[MAXN], tp[MAXN], height[MAXN];
	void Qsort() {
		for (int i = 1; i <= M; ++i) buc[i] = 0;
		for (int i = 1; i <= L; ++i) ++buc[rk[i]];
		for (int i = 1; i <= M; ++i) buc[i] += buc[i - 1];
		for (int i = L; i >= 1; --i) sa[buc[rk[tp[i]]]--] = tp[i];
	}
	void getSA() {
		for (int i = 1; i <= L; ++i) rk[i] = S[i] - 'a' + 1, tp[i] = i;
		M = 100, Qsort();
		for (int l = 1; l <= L; l <<= 1) {
			int cnt = 0;
			for (int i = L - l + 1; i <= L; ++i) tp[++cnt] = i;
			for (int i = 1; i <= L; ++i) if (sa[i] > l) tp[++cnt] = sa[i] - l;
			M = rk[sa[L]], Qsort();
			for (int i = 1; i <= L; ++i) tp[i] = rk[i];
			for (int i = 1; i <= L; ++i) {
				rk[sa[i]] = rk[sa[i-1]] + !(tp[sa[i]]==tp[sa[i-1]]&&tp[sa[i]+l]==tp[sa[i-1]+l]);
			}
			if (rk[sa[L]] == L) break;
		}
		for (int i = 1, j = 0; i <= L; ++i) {
			if (j) --j;
			while (S[i + j] == S[sa[rk[i] - 1] + j]) ++j;
			height[rk[i]] = j;
		}
	}
	int main() {
		scanf("%s", S + 1), N = strlen(S + 1);
		S[N + 1] = 'z' + 1, scanf("%s", S + N + 2), L = strlen(S + 1);
		getSA();
		int tmp = INF;
		for (int i = 1; i <= L; ++i) {
			tmp = min(tmp, height[i]);
			if (sa[i] > N) tmp = INF;
			else c[sa[i]] = max(c[sa[i]], tmp);
		}
		tmp = INF;
		for (int i = L; i >= 1; --i) {
			tmp = min(tmp, height[i + 1]);
			if (sa[i] > N) tmp = INF;
			else c[sa[i]] = max(c[sa[i]], tmp);
		}
		return 0;
	}
};

namespace p2 {
	int Q, id[MAXN], ans[MAXN];
	struct query { int l, r, id; } a[MAXN];
	bool cmp(query q1, query q2) { return q1.r < q2.r; }
	bool cmpid(int x, int y) { return c[x] + x < c[y] + y; }

	struct data {
		int mx1, mx2;
		data (int mx1 = 0, int mx2 = 0) : mx1(mx1), mx2(mx2) {}
		friend data operator+ (const data& l, const data& r) {
			return data(min(l.mx1, r.mx1), max(l.mx2, r.mx2));
		}
	} T[MAXN << 2];

	#define mid ((l + r) >> 1)
	#define ls (o << 1)
	#define rs (o << 1 | 1)
	void pushup(int o) { T[o] = T[ls] + T[rs]; }
	void build(int o, int l, int r) {
		if (l == r) T[o].mx1 = l;
		else build(ls, l, mid), build(rs, mid + 1, r), pushup(o);
	}
	void insert(int o, int l, int r, int pos) {
		if (l == r) T[o].mx1 = INF, T[o].mx2 = c[l];
		else {
			if (pos <= mid) insert(ls, l, mid, pos);
			else insert(rs, mid + 1, r, pos);
			pushup(o);
		}
	}
	data query(int o, int l, int r, int L, int R) {
		if (l == L && r == R) return T[o];
		else {
			if (R <= mid) return query(ls, l, mid, L, R);
			else if (L > mid) return query(rs, mid + 1, r, L, R);
			else return query(ls, l, mid, L, mid) + query(rs, mid + 1, r, mid + 1, R);
		}
	}
	#undef mid
	#undef ls
	#undef rs

	int main() {
		scanf("%d", &Q);
		for (int i = 1; i <= Q; ++i) scanf("%d%d", &a[i].l, &a[i].r), a[i].id = i;
		sort(a + 1, a + Q + 1, cmp);
		for (int i = 1; i <= N; ++i) id[i] = i;
		sort(id + 1, id + N + 1, cmpid);
		build(1, 1, N);
		for (int i = 1, j = 1, k = 1; i <= N; ++i) {
			for (; k <= N && c[id[k]] + id[k] <= i + 1; ++k) insert(1, 1, N, id[k]);
			for (; j <= Q && a[j].r == i; ++j) {
				data p = query(1, 1, N, a[j].l, a[j].r);
				ans[a[j].id] = p.mx1 != INF ? max(i - p.mx1 + 1, p.mx2) : p.mx2;
			}
		}
		for (int i = 1; i <= Q; ++i) printf("%d\n", ans[i]);
		return 0;
	}
}

int main() {
	p1::main(), p2::main();
	return 0;
}
```

---

## 作者：AzusaCat (赞：6)

给出只包含小写字母 $a,b$ 的字符串 $s,t$，$q$ 次询问，每次询问 $s[l,r]$ 和 $t$ 的最长公共子串长度。$|s|,|t|,q\leqslant 2\times 10^5$。



首先，我们有一个很经典的套路就是用SA或者SAM求出 $s$ 每个位置最多能向前扩展多长，使得这个子串是 $t$ 的子串。

说一下用SAM实现的做法：先把 $t$ 的自动机建出来，然后让 $s$ 在 $t$ 的自动机上匹配。我们设每一位的答案为 $ans_i$ ，再开一个变量 $now$ 表示当前在哪个节点。

我们一位一位添加进 $s$ ，假设本次添加的字符为 $c$，当 $now$ 有 $c$ 的出边时，让 $ans_i=ans_{i-1}+1$ （注意这里并不是 $len_{now}+1$ ，因为当前匹配上的串不一定是 $now$ 节点代表的最长串），然后 $now=ch[now][c]$；

如果没有，我们沿着后缀链接向上跳 $fa$ ，直到跳到虚拟节点或者找到了一个有 $c$ 的出边的节点。

如果跳到了虚拟节点，即 $t$ 根本就不含 $c$ 这个字符，那么使 $ans[i]=0,now=0$ （$0$ 为根节点，$-1$ 为虚拟节点）；

如果找到了 $c$ 的出边，则 $ans_i=len_{now}+1,now=ch[now][c]$ （此处的 $now$ 是你跳到的那个点）。这里为什么是 $len_{now}+ 1$ 呢？因为我们是从某一个儿子节点跳到这里的，而儿子节点代表的子串都严格比父节点的子串长，所以只要跳一次开始，就包含了这个节点的所有串。这样的总复杂度是线性的，因为匹配长度最多只增加 $|s|$ 次，所以跳 $fa$ 的总复杂度也是 $O(|s|)$ 的。



现在我们有了 $ans$ 数组，怎么求出真正的答案呢？不难发现答案就是 $\max\limits_{i=l}^r\min(ans_i,i-l+1)$ ，我们把所有位置按取得 $\min$ 的是哪一种分成两类，我们发现随着 $l$ 的增加，会由 $ans_i$ 取得 $\min$ 变为 $i-l+1$ 取得 $\min$ ，而这个位置为 $i-ans_i+1$ ，所以我们可以按 $l$ 离线下来所有询问，开两棵线段树维护两种的答案（单点修改和查询区间 $\max$），再给每个位置开个桶，把 $k-ans_k+1=i$ 的都扔进去，然后当 $l$ 扫到这个位置就更改就好了。当然你也可以用可持久化线段树来在线处理询问，就是空间多了个 $\log$ ，代码采用的是离线方法。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct query{int l,r,id;}c[200005];
bool cmp(query x,query y){return x.l<y.l;}
string s,t;
namespace Suffix_Automaton
{
    int ch[400005][2],len[400005],fa[400005],tot,last,ans[200005];
    void extend(int c)
    {
        int np=++tot,p=last;
        last=tot,len[np]=len[p]+1;
        for(;p!=-1&&(!ch[p][c]);p=fa[p])ch[p][c]=np;
        if(p==-1)return;
        int q=ch[p][c];
        if(len[q]==len[p]+1){fa[np]=q;return;}
        int nq=++tot;
        ch[nq][0]=ch[q][0],ch[nq][1]=ch[q][1];
        fa[nq]=fa[q];
        len[nq]=len[p]+1;
        fa[q]=fa[np]=nq;
        for(;p!=-1&&ch[p][c]==q;p=fa[p])ch[p][c]=nq;
    }
    void get_ans()
    {
        int now=0;
        for(int i=0;i<s.size();i++)
        {
            int c=s[i]-'a';
            if(ch[now][c])now=ch[now][c],ans[i+1]=ans[i]+1;
            else
            {
                while(now&&(!ch[now][c]))now=fa[now];
                if(!ch[now][c])ans[i+1]=0;
                else ans[i+1]=len[now]+1,now=ch[now][c];
            }
        }
    }
}
struct Segment_Tree
{
    int tree[800005];
    void modify(int l,int r,int x,int a,int b)
    {
        if(l==r){tree[x]=b;return;}
        int mid=(l+r)>>1;
        if(a<=mid)modify(l,mid,x*2,a,b);
        else modify(mid+1,r,x*2+1,a,b);
        tree[x]=max(tree[x*2],tree[x*2+1]);
    }
    int query(int l,int r,int x,int a,int b)
    {
        if(l>=a&&r<=b)return tree[x];
        int mid=(l+r)>>1,ans=0;
        if(a<=mid)ans=query(l,mid,x*2,a,b);
        if(b>mid)ans=max(ans,query(mid+1,r,x*2+1,a,b));
        return ans;
    }
}t1,t2;
using namespace Suffix_Automaton;
vector<int>v[200005];
int anss[200005];
int main()
{
    fa[0]=-1;
    cin>>s>>t;
    int n=s.size();
    for(int i=0;i<t.size();i++)extend(t[i]-'a');
    get_ans();
    for(int i=1;i<=n;i++)v[i-ans[i]+1].push_back(i),t1.modify(1,n,1,i,ans[i]);
    int q;
    scanf("%d",&q);
    for(int i=1;i<=q;i++)scanf("%d%d",&c[i].l,&c[i].r),c[i].id=i;
    sort(c+1,c+q+1,cmp);
    int nowl=1;
    for(int i=1;i<=q;i++)
    {
        while(nowl<=c[i].l)
        {
            for(int j=0;j<v[nowl].size();j++)
                t1.modify(1,n,1,v[nowl][j],0),t2.modify(1,n,1,v[nowl][j],v[nowl][j]);
            nowl++;
        }
        anss[c[i].id]=max(t2.query(1,n,1,c[i].l,c[i].r)-c[i].l+1,t1.query(1,n,1,c[i].l,c[i].r));
    }
    for(int i=1;i<=q;i++)printf("%d\n",anss[i]);
    return 0;
}
```

---

## 作者：封禁用户 (赞：5)

~~正经人谁写SA啊~~

因为我们知道一个字符串的子串可以看成原字符串的前缀的后缀，比如说 ```ababa``` 的子串 ```bab``` 可以看成其前缀 ```abab``` 的后缀 ```bab``` 。受此启发，我们设 $f_i$ 代表 $s$ 中以 $i$ 结尾的前缀中的最长后缀的长度，并满足该后缀是 $t$ 的子串。( $f_i$ 的求法见下文)

在本题中 $s[l \dots r]$ 与 $t$ 的最长公共子串可以看成 $\max\{ \min_{l \le i \le r}\{ i-l+1,f_i \} \}$ ，即枚举所有子串的结束位置，然后考虑其最长可以向左延伸多远，取一个 $\max$。 (对 $i-l+1$ 取 $\min$ 是保证其向左延伸不出区间 $[l,r]$ 内 )

但是直接算这个单组询问是 $O(n)$ 的，无法通过本题。我们发现主要是这个对 $i-l+1$ 取 $\min$ 不好处理，否则可以ST表或线段树优化。

既然如此，那么可以分别计算取 $\min$ 是 $i-l+1$ 和 $f_i$ 的情况，最后再合并起来，这样就把 $\min$ 消掉了。

问题是， $[l,r]$ 中哪部分取 $\min$ 是 $i-l+1$ ，那部分是 $f_i$ 呢？这就要我们探究 $f_i$ 的性质了。 令 $F(i)=i-f_i+1$ ，即满足 $f_i$ 要求的最长后缀的起始点。 $F(i)$ 有一个重要的性质： $F(i)$ 是单调不降的 (即 $\forall_{1 \le i < n} F(i) \le F(i+1)$ ) ，证明可以反证，若 $\exists_{1 \le i < n}  F(i)>F(i+1)$ ，那么子串 $s[F(i+1) \dots i]$ 显然也是 $t$ 的子串 ( $s[F(i+1) \dots i+1]$是 $t$ 的子串 )，且长度比 $s[F(i) \dots i]$ 更长，矛盾。

那么我们可以 **二分** 找到区间 $[l,r]$ 内第一个 $F(i) \geq l$ 的位置，设其(位置)为 $pos$ 。那么对于区间 $[l,pos-1]$ ，其 $\min \{i-l+1,f_i \}$ (上文所说的式子)即为 $i-l+1$ ，而对于区间 $[pos,r]$ ， 其 $\min \{i-l+1,f_i \}$ 即为 $f_i$ 。$i-l+1$ 在 $[l,pos-1]$ 中的最大值即为 $(pos-1)-l+1=pos-l$ ，在 $[pos,r]$ 中 $f_i$ 的最大值可以ST表或线段树求区间最大值(我用的线段树)。

最后，如何求 $f_i$ 呢？从头到尾遍历 $s$ ，并把**SAM当成AC自动机** 。 具体来说，对 $t$ 建SAM，我们知道SAM可以视为 **对所有子串建立AC自动机** ，因为AC自动机的 $\texttt{fail}$ 指针，指向的是以前出现过的最长的后缀，与SAM的 $\texttt{fa}$ (一个节点的 $\texttt{fa}$ 也是他的后缀) 指针有异曲同工之妙。那我们用一个指针 $p$ ，指向的是 $t$ 的SAM中的节点。然后从头到尾遍历 $s$ ，假如遍历到第 $i$ 位，而 $s_i=c$ ，如果 $p$ 存在 $ch_c$  ( $c$ 的出边)，那么直接走到 $ch_{p\ c}$ 。如果没有 $ch_c$ ，那么不断跳 $\texttt{fa}$ (遍历所有的后缀，与 $f_i$ 定义相符)，直到有 $ch_{p\ c}$ 。如果 $p$ 中有一个祖先存在 $ch_c$ ，那么 $p$ 变成该祖先的 $ch_c$ 。如果到根节点都没有节点有 $ch_c$ ，那么 $p$ 变为根节点( $1$ )。当然，这个过程中我们还要维护目前的最长与 $t$ 的匹配长度，作为目前 $i$ 的 $f_i$ 。维护最长匹配长度的细节可以参考代码及注释。

最后证明一下复杂度，建 SAM $O(n)$ ，线段树预处理 $O(n)$ ，单次二分 $O(\log n)$ ，单次线段树询问 $O(\log n)$ 。SAM上匹配时往下走 $ch_c$ 的次数 $O(n)$ ，那么往上跳 $\texttt{fa}$ 次数也为 $O(n)$ 。总复杂度 $O(q \log n)$ 。

```cpp
#include <cmath>
#include <stdio.h>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

inline char gc () {
	static char buf[1048576], *p1 = buf, *p2 = buf;
	return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1048576, stdin), p1 == p2) ? EOF : *p1 ++;
}

inline int idx (char &ch) { return ch - 'a'; } // idx是每个字符在SAM中对应的编号(如'a'对应0)
inline bool islower (char &ch) { return ch >= 'a' && ch <= 'z'; }
inline bool isdigit (char &ch) { return ch >= '0' && ch <= '9'; }

int reads (char *S) {
	int p = 0; char ch = gc();
	while(!islower(ch)) ch = gc();
	while(islower(ch)) S[++ p] = ch, ch = gc();
	S[p + 1] = 0; return p;
}

void readi (int &v) {
	int ans = 0, f = 1; char ch = gc();
	while(!isdigit(ch)) { if(!(ch ^ '-')) f = -1; ch = gc(); }
	while(isdigit(ch)) ans = ans * 10 + ch - '0', ch = gc();
	v = ans * f;
}

//以上全是快读

const int N = 200005;
const int Q = 200005;

struct SAM { // 封装的SAM
	int ch[N << 1][26], fa[N << 1], len[N << 1]; // 记得开2倍
	int cnt, lst;
	SAM () { cnt = lst = 1; }

	void insert (int c) { // 标准SAM构建
		int p = lst, np = ++ cnt; lst = np;
		len[np] = len[p] + 1; 
		
		for(; p && !ch[p][c]; p = fa[p])
			ch[p][c] = np;
		
		if(!p) fa[np] = 1;
		else {
			int q = ch[p][c];
			
			if(len[q] == len[p] + 1) fa[np] = q;
			else {
				int nq = ++ cnt;
				memcpy(ch[nq], ch[q], sizeof ch[q]);
				fa[nq] = fa[q];
				len[nq] = len[p] + 1;
				fa[np] = fa[q] = nq;
				
				for(; p && ch[p][c] == q; p = fa[p])
					ch[p][c] = nq;
			}
		}
	}

	void build (char *S) {
		for(int i = 1; S[i]; ++ i)
			insert(idx(S[i]));
	}
	
	int calc (int c) { // 模拟AC自动机匹配，计算加入c后的最长匹配长度
		static int p = 1, cur = 0;
		//p是匹配到的节点，cur是目前的最大匹配长度
        //注意static，即调用函数时沿用上次的值

		if(ch[p][c]) ++ cur, p = ch[p][c]; // 已经存在ch[c]，那么最长匹配长度+1即可
		else {
			for(; p && !ch[p][c]; p = fa[p]); // 不断跳fa，直到有ch[c]
			
			if(p) cur = len[p] + 1, p = ch[p][c]; // 祖先中存在一个节点拥有ch[c]
            //最长匹配长度为什么是len[p]+1而不是len[ch[p][c]]可以自己思考以下
			else cur = 0, p = 1; // 从根节点从新开始匹配，最长匹配长度归0
		}
		
		return cur;
	}
} sam;

char S[N], T[N];
int f[N]; /*文中所说的f[i]*/ int q;

struct SegmentTree { // 线段树，区间最大值
	int mx[N << 2];
	
	void build (int u, int l, int r) {
		if(l == r) { mx[u] = f[l]; return; }
		
		int mid = l + r >> 1;
		build(u << 1, l, mid);
		build(u << 1 | 1, mid + 1, r);
		mx[u] = max(mx[u << 1], mx[u << 1 | 1]);
	}
	
	int query (int u, int ul, int ur, int l, int r) {
		if(l >= ul && r <= ur) return mx[u];
		
		int mid = l + r >> 1, ret = 0;
		if(mid >= ul) ret = max(ret, query(u << 1, ul, ur, l, mid));
		if(mid < ur) ret = max(ret, query(u << 1 | 1, ul, ur, mid + 1, r));
		return ret;
	}
} seg;

int search (int l, int r) { // 二分找到第一个F(i)不小于l的位置
	int L = l, R = r, mid;

	while(L < R) {
		mid = L + R >> 1;

		if(mid - f[mid] + 1 < l) L = mid + 1;
		else R = mid;
	}

	if(L - f[L] + 1 < l) ++ L; // 这个特判是为了整个区间[l,r]的F(i)都小于l的情况，这种情况的返回值为r+1(因为二分出来时L为r)
	return L;
}

int main () {

	int ls = reads(S); reads(T); // 读入
	sam.build(T); // 对t建SAM
	
	for(int i = 1; i <= ls; ++ i) 
		f[i] = sam.calc(idx(S[i])); // 计算加入S[i]之后与t的最长匹配长度，作为f[i]
	
	seg.build(1, 1, ls); // 线段树预处理
	
	readi(q);
	while(q -- ) {
		int l, r; readi(l); readi(r);
		int pos = search(l, r); // pos即为文中定义,F(i)第一个不小于l的位置
		
		int ans = pos - l; // 本应是 (pos - 1) - l + 1，文中所说的
		if(pos <= r) // 判断pos <= r是为了防止整个区间[l,r]的F(i)都小于l (整个区间[l,r]的F(i)都小于l时返回的是r + 1)
        	ans = max(ans, seg.query(1, pos, r, 1, ls)); 
		printf("%d\n", ans);
	}

	return 0;
}
```

后：把SAM看成AC自动机的题目还有 [CF235C Cyclical Quest](https://www.luogu.com.cn/problem/CF235C)  。与本题类似，也是每次在末端加入一个字符，然后失配就不断缩小后缀，只不过多了一个删掉开头字符的操作，但是也可以通过跳 $\texttt{fa}$ 解决，因为在开头删掉一个字符可以看成其一个后缀。具体细节可以看题解。

---

## 作者：辰星凌 (赞：4)

# **【题解】封印 [BJOI2020] [P6640] [Loj3298]**

[$\mathcal{My}\ \mathcal{Blog}$](https://www.cnblogs.com/Xing-Ling/p/13203551.html)

传送门：[封印 $\text{[BJOI2020] [P6640]}$](https://www.luogu.com.cn/problem/P6640) [$\text{[Loj3298]}$](https://loj.ac/problem/3298)

## **【分析】**

$\text{CF}$ 上有一堆这种类似的题。

按照套路，先求出 $s$ 中以每个 $i$ 作为右端点与 $t$ 能匹配到的最长子串长度，记为 $len(i)$（用$\text{SA}$ 和 $\text{SAM}$ 均可）。

那么对于一次询问，答案为 $\max_{i=l}^{r}\{i-\max(l,i-len(i)+1)+1\}$，似乎不太好维护，但注意到 $i-len(i)+1$ 是有单调性的（单调不减），也就是说我们可以把 $[l,r]$ 中的所有 $i$ 分为两半，左边为 $\max_{i=l}^{mid-1}\{i-l+1\}=mid-1-l+1$，右边为 $\max_{i=mid}^{r}\{len(i)\}$，套个静态查询区间最大值的数据结构进行维护。求 $mid$ 也很简单，把询问离线按 $l$ 排序，一个指针扫过去就完了。如果强制在线就二分求 $mid$ 。

写了个两只 $\log$ 的树状数组跑得飞快（雾）。

## **【Code】**

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#define LL long long
#define Re register int
using namespace std;
const int N=2e5+3;
int n,T,len[N],Ans[N];char s[N],t[N];
struct QAQ{int l,r,id;inline bool operator<(const QAQ &O)const{return l<O.l;}}Q[N];
inline void in(Re &x){
    int f=0;x=0;char c=getchar();
    while(c<'0'||c>'9')f|=c=='-',c=getchar();
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    x=f?-x:x;
}
struct Suffix_Automaton{
    int O,last,link[N<<1],maxlen[N<<1],trans[N<<1][2];
    Suffix_Automaton(){last=O=1;}
    inline void insert(Re ch){
        Re z=++O,p=last;maxlen[z]=maxlen[p]+1;
        while(p&&!trans[p][ch])trans[p][ch]=z,p=link[p];
        if(!p)link[z]=1;
        else{
            Re x=trans[p][ch];
            if(maxlen[x]==maxlen[p]+1)link[z]=x;
            else{
                Re y=++O;maxlen[y]=maxlen[p]+1;
                for(Re i=0;i<2;++i)trans[y][i]=trans[x][i];
                while(p&&trans[p][ch]==x)trans[p][ch]=y,p=link[p];
                link[y]=link[x],link[x]=link[z]=y;
            }
        }
        last=z;
    }
    inline void build(){
        for(Re i=1;t[i];++i)insert(t[i]-'a');
        for(Re i=1,p=1,Len=0;i<=n;++i){
            Re a=s[i]-'a';
            while(p&&!trans[p][a])p=link[p],Len=maxlen[p];
            if(!p)p=1,Len=0;
            else p=trans[p][a],++Len;
            len[i]=min(Len,i);
        }
    }
}SAM;
struct BIT{
    int C[N];
    inline void add(Re x,Re v){while(x<=n)C[x]=max(C[x],v),x+=x&-x;}
    inline int ask(Re l,Re r){
        Re ans=0;
        while(l<=r){
            while(r-(r&-r)>=l)ans=max(ans,C[r]),r-=r&-r;
            ans=max(ans,len[r--]);
        }
        return ans;
    }
}TR;
int main(){
//    freopen("123.txt","r",stdin);
    scanf("%s%s",s+1,t+1),n=strlen(s+1);
    in(T),SAM.build();
    for(Re i=1;i<=n;++i)TR.add(i,len[i]);
    for(Re i=1;i<=T;++i)in(Q[i].l),in(Q[i].r),Q[i].id=i;
    sort(Q+1,Q+T+1);
    for(Re l=1,i=1,o=1;l<=n&&o<=T;++l){
        while(i<=n&&i-len[i]+1<l)++i;//找到第一个满足i-len[i]+1>=l的位置
        while(o<=T&&Q[o].l==l){
            if(i-1>=l)Ans[Q[o].id]=min(i-1,Q[o].r)-l+1;
            if(i<=Q[o].r)Ans[Q[o].id]=max(Ans[Q[o].id],TR.ask(max(i,l),Q[o].r));
            ++o;
        }
    }
    for(Re i=1;i<=T;++i)printf("%d\n",Ans[i]);
}
```


---

## 作者：JoaoFelix (赞：1)

大概想了一个比较好像好理解，比较好写的算法，用sa维护，可能有点码量但是没有细节

我们考虑S串以i结尾最长的和T串匹配的长度，知道了这个对于每组询问我们可以把它们都离线下来，然后按右端点一次询问

无非就是两种情况

一种是完全包含的情况就是可能i结尾的最长匹配的长度被询问区间完全覆盖，另外一种是没有被完全覆盖。

我们考虑当前右端点的询问的左端点为L

那么>=L的我们只需要用线段树维护其最长长度就可以了
<L的我们只需要维护它所在右端点的最右端的位置，因为固定的询问，肯定右端点越靠右，答案越大！

然后以上需要两个线段树维护！

然后我们关于求最长匹配我们可以用sam也可以用sa，作者写的是sa，只需要翻转原串，然后两个串用个#隔开，求出height，对于两边最相邻的求lcp即可

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> pr;

inline int read() {
	char c = getchar(); int x = 0, f = 1;
	while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * f;
}

const int N = 500005, D = 233;

int n, m, nn, a[N], rec[N], ans[N];
char strS[N >> 1], strT[N >> 1];
vector<pr> vq[N];

struct SuffixArray {
	int buc[N], sa[N], rk[N], fir[N], sec[N];
	int hei[N], lg[N], mn[N][21];
	
	int LCP(int x, int y) {
		if (x == y) return nn - sa[x] + 1;
		if (x > y) swap(x, y); y--;
		int tt = lg[y - x + 1];
		return min(mn[x][tt], mn[y - (1 << tt) + 1][tt]);
	} 
	void suffix_sort() {
		memset(buc, 0, sizeof(buc));
		for (int i = 1; i <= nn; i++) buc[a[i]]++;
		for (int i = 1; i < N; i++) buc[i] += buc[i - 1];
		for (int i = 1; i <= nn; i++) sa[buc[a[i]]--] = i;
		rk[sa[1]] = 1; for (int i = 2; i <= nn; i++) rk[sa[i]] = rk[sa[i - 1]] + (a[sa[i]] != a[sa[i - 1]]);
		for (int k = 1; k <= nn; k <<= 1) {
			for (int i = 1; i <= nn; i++) fir[i] = rk[i], sec[i] = i + k <= nn ? rk[i + k] : 0;
			memset(buc, 0, sizeof(buc));
			for (int i = 1; i <= nn; i++) buc[sec[i]]++;
			for (int i = 1; i <= nn; i++) buc[i] += buc[i - 1];
			for (int i = nn; i >= 1; i--) rk[buc[sec[i]]--] = i;
			memset(buc, 0, sizeof(buc));
			for (int i = 1; i <= nn; i++) buc[fir[i]]++;
			for (int i = 1; i <= nn; i++) buc[i] += buc[i - 1];
			for (int i = nn; i >= 1; i--) sa[buc[fir[rk[i]]]--] = rk[i];
			rk[sa[1]] = 1;
			for (int i = 2; i <= nn; i++) rk[sa[i]] = rk[sa[i - 1]] + (fir[sa[i]] != fir[sa[i - 1]] || sec[sa[i]] != sec[sa[i - 1]]);
		}
	}
	void sol() {
		int len = 0;
		for (int i = 1; i <= nn; i++) {
			int pos = sa[rk[i] + 1]; if (len) len--;
			if (rk[i] == nn) hei[i] = 0;
			else {
				while (a[i + len] == a[pos + len]) len++;
				hei[rk[i]] = len;
			}
		}
		lg[0] = -1; for (int i = 1; i <= nn; i++) lg[i] = lg[i >> 1] + 1;
		for (int i = 1; i < nn; i++) mn[i][0] = hei[i];
		for (int k = 1; k <= 20; k++)
			for (int i = 1; i + (1 << k) - 1 <= nn; i++) mn[i][k] = min(mn[i][k - 1], mn[i + (1 << k - 1)][k - 1]); 
	}
} SA;
struct SegmentTree {
	int mx[N << 2];
	
	void modify(int rt, int l, int r, int ql, int qr, int x) {
		if (ql <= l && r <= qr) { mx[rt] = max(mx[rt], x); return; }
		int mid = (l + r) >> 1;
		if (ql <= mid) modify(rt << 1, l, mid, ql, qr, x);
		if (qr > mid) modify(rt << 1 | 1, mid + 1, r, ql, qr, x);
	}
	int ask(int rt, int l, int r, int x) {
		if (l == r) return mx[rt];
		int mid = (l + r) >> 1;
		return x <= mid ? max(mx[rt], ask(rt << 1, l, mid, x)) : max(mx[rt], ask(rt << 1 | 1, mid + 1, r, x));
	}
} sgt1, sgt2;

void getLCP() {
	int lst = 0;
	for (int i = 1; i <= nn; i++) {
		if (SA.sa[i] > n + 1) lst = i;
		if (SA.sa[i] <= n) {
			if (lst) rec[SA.sa[i]] = max(rec[SA.sa[i]], SA.LCP(lst, i));
		}
	}
	lst = 0;
	for (int i = nn; i >= 1; i--) {
		if (SA.sa[i] > n + 1) lst = i;
		if (SA.sa[i] <= n) {
			if (lst) rec[SA.sa[i]] = max(rec[SA.sa[i]], SA.LCP(i, lst));
		}
	}
	reverse(rec + 1, rec + n + 1);
}

int main() {
	scanf("%s", strS + 1); scanf("%s", strT + 1);
	n = strlen(strS + 1), m = strlen(strT + 1);
	for (int i = 1; i <= n; i++) a[++nn] = strS[n - i + 1] - 'a' + 1;
	a[++nn] = D;
	for (int i = 1; i <= m; i++) a[++nn] = strT[m - i + 1] - 'a' + 1;
	SA.suffix_sort(), SA.sol(); getLCP();
	int qq = read();
	for (int i = 1; i <= qq; i++) {
		int l = read(), r = read();
		vq[r].push_back(pr(l, i));
	}
	for (int i = 1; i <= n; i++) {
		int p = i - rec[i] + 1;
		sgt1.modify(1, 1, n, 1, p, rec[i]), sgt2.modify(1, 1, n, p, i, i);
		for (auto x : vq[i]) {
			int tt = x.first, ret = max(sgt1.ask(1, 1, n, tt), sgt2.ask(1, 1, n, tt) - tt + 1);
			ans[x.second] = ret;
		}
	}
	for (int i = 1; i <= qq; i++) printf("%d\n", ans[i]);
	return 0;
}

```


---

## 作者：duyi (赞：1)

[更好的阅读体验](https://www.cnblogs.com/dysyn1314/p/13158865.html)

## 题目大意

[题目链接](https://loj.ac/problem/3298)

给出只包含小写字母$\text{a},\text{b}$的两个字符串$s,t$，$q$次询问，每次询问$s[l\dots r]$和$t$的最长公共子串长度。

数据范围：$1\leq|s|,|t|,q\leq 2\times10^5$。

## 本题题解

考虑预处理$s$的每个子串是不是$t$的子串。发现对于一个左端点$i$ ($1\leq i\leq |s|$)，一定存在一个$R[i]$，使得$\forall j\in[i,R[i]]:s[i\dots j]$都是$t$的子串，$\forall k\in[R[i]+1,n]:s[i\dots k]$都不是$t$的子串。也就是说，使得$s[i\dots r]$是$t$子串的$r$，一定是从$i$开始的一段连续的区间，而$R[i]$就是其中最大的$r$。我们考虑把所有$R[i]$预处理出来。

从小到大枚举$i$。我们已经知道了$s[i-1\dots R[i-1]]$是$t$的子串。那么，$s[i\dots R[i-1]]$一定也是$t$的子串，也就是说，$R[i]\geq R[i-1]$。那么我们从$R[i-1]+1$开始，一位一位向后枚举，判断是否是$t$的子串。可以对$t$建一个SAM，这个“向后枚举”，就相当于在SAM上走**转移边**。同时，我们还要支持把前面的第$i-1$位删掉，这就相当于在SAM上跳**父亲边**。因为$R[i]$是单调的，所以时间复杂度$O(|s|)$（$|s|,|t|$同阶）。

预处理出$R$数组后，考虑回答询问。对于一个询问$l,r$。我们相当于要求出，$\max_{i=l}^{r}\{\min(r,R[i])-i+1\}$。对于$\min(r,R[i])$，我们分类讨论：

- 对于$R[i]\leq r$的$i$，相当于询问$\max_{l\leq i\leq r}\{R[i]-i+1\}$。
- 对于$R[i]>r$的$i$，相当于询问$r+\max_{l\leq i\leq r}\{-i\}+1$。

如果把$R[i]$和$r$的关系看做一维，$i$和$l,r$的关系看做一维，那相当于是一个二维的区间最大值查询。可以考虑离线，把询问按右端点排序，这样$R[i]$和$r$的这一维就不存在了，我们只要做一维的区间最大值查询，可以用（两棵）线段树维护。

时间复杂度$O(|s|+q\log |s|)$。

参考代码（[在LOJ查看](https://loj.ac/submission/840465)）：

```cpp
//problem:LOJ3298
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mk make_pair
#define lob lower_bound
#define upb upper_bound
#define fi first
#define se second
#define SZ(x) ((int)(x).size())

typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;

const int MAXN=2e5;
const int INF=1e9;

int n,m,q,R[MAXN+5];
char s[MAXN+5],t[MAXN+5];
struct SAM{
	int cnt,ed,mp[MAXN*2+5][2],fa[MAXN*2+5],len[MAXN*2+5];
	void ins(int c){
		int p=ed;ed=++cnt;len[ed]=len[p]+1;
		for(;p && !mp[p][c];p=fa[p])mp[p][c]=ed;
		if(!p)fa[ed]=1;
		else{
			int q=mp[p][c];
			if(len[q]==len[p]+1)fa[ed]=q;
			else{
				len[++cnt]=len[p]+1;
				for(int i=0;i<2;++i)mp[cnt][i]=mp[q][i];
				fa[cnt]=fa[q];fa[q]=fa[ed]=cnt;
				for(;mp[p][c]==q;p=fa[p])mp[p][c]=cnt;
			}
		}
	}
	SAM(){cnt=ed=1;}
}sam_t;

int cnt_ev,ans[MAXN+5];
struct Event{
	int l,r,id;
	Event(){}
	Event(int _l,int _r,int _id){
		l=_l;r=_r;id=_id;
	}
}ev[MAXN*2+5];
bool cmp(Event x,Event y){
	if(x.r==y.r)return x.id<y.id;
	return x.r<y.r;
}

struct SegmentTree{
	int mx[MAXN*4+5];
	void push_up(int p){
		mx[p]=max(mx[p<<1],mx[p<<1|1]);
	}
	void build(int p,int l,int r,int* arr){
		if(l==r){
			mx[p]=arr[l];
			return;
		}
		int mid=(l+r)>>1;
		build(p<<1,l,mid,arr);
		build(p<<1|1,mid+1,r,arr);
		push_up(p);
	}
	void modify(int p,int l,int r,int pos,int x){
		if(l==r){
			mx[p]=x;
			return;
		}
		int mid=(l+r)>>1;
		if(pos<=mid)modify(p<<1,l,mid,pos,x);
		else modify(p<<1|1,mid+1,r,pos,x);
		push_up(p);
	}
	int query(int p,int l,int r,int ql,int qr){
		if(ql<=l && qr>=r)return mx[p];
		int mid=(l+r)>>1;
		int res=-INF;
		if(ql<=mid)res=query(p<<1,l,mid,ql,qr);
		if(qr>mid)res=max(res,query(p<<1|1,mid+1,r,ql,qr));
		return res;
	}
	SegmentTree(){}
}T1,T2;

int main() {
	cin>>(s+1);n=strlen(s+1);
	cin>>(t+1);m=strlen(t+1);
	for(int i=1;i<=m;++i){
		sam_t.ins(t[i]-'a');
	}
	int p=1;
	for(int i=1;i<=n;++i){
		int r=max(i-1,R[i-1]);
		if(r==i-1)p=1;
		while(p!=1 && sam_t.len[sam_t.fa[p]]+1>r-i+1)p=sam_t.fa[p];
		while(r+1<=n && sam_t.mp[p][s[r+1]-'a']!=0){
			p=sam_t.mp[p][s[r+1]-'a'];
			r++;
		}
		R[i]=r;
		ev[++cnt_ev]=Event(i,R[i],0);
		//cout<<R[i]<<" ";
	}
	//cout<<endl;
	static int tmp[MAXN+5];
	for(int i=1;i<=n;++i)tmp[i]=-INF;
	T1.build(1,1,n,tmp);
	for(int i=1;i<=n;++i)tmp[i]=-i;
	T2.build(1,1,n,tmp);
	
	cin>>q;
	for(int i=1;i<=q;++i){
		int l,r;cin>>l>>r;
		ev[++cnt_ev]=Event(l,r,i);
	}
	sort(ev+1,ev+cnt_ev+1,cmp);
	for(int i=1;i<=cnt_ev;++i){
		if(ev[i].id==0){
			T1.modify(1,1,n,ev[i].l,ev[i].r-ev[i].l+1);
			T2.modify(1,1,n,ev[i].l,-INF);
		}
		else{
			int x=T1.query(1,1,n,ev[i].l,ev[i].r);
			int y=ev[i].r+T2.query(1,1,n,ev[i].l,ev[i].r)+1;
			ans[ev[i].id]=max(x,y);
		}
	}
	for(int i=1;i<=q;++i)cout<<ans[i]<<endl;
	return 0;
}
```


---

## 作者：lory1608 (赞：0)

本题可以用SAM+线段树

对于子串$T$,可以先对他建立SAM,然后将子串$S$放在上面跑，这样就得到了所有以$i$结尾的字符串与$T$的最长公共子串，设为$ans_i$。

那么就只用求出$s[l,r]$中结尾在$[l,r]$且开头$\geq l$的所有串。

显然$i-ans_i+1$单调递增。

只用二分出第一个$i-ans_i+1 \geq l$的位置$pos$即可。

用线段树维护$ans_i$,然后答案是$\max \{pos-l,\max\limits_{pos\leq i \leq r}\{ans_i \} \}$。

复杂度$ \Theta(n\log n)$。

应该来说比较简单。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <set>
#include <vector>
#define ll long long
using namespace std;
inline int getint() {
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = (x << 3) + (x << 1) + (ch ^ 48);
        ch = getchar();
    }
    return (f == 1) ? x : -x;
}
inline int max(int a, int b) { return a > b ? a : b; }
inline int min(int a, int b) { return a < b ? a : b; }
const int maxn = 4e5 + 5;
int dp[maxn], tot = 1, last = 1, fa[maxn], pre[maxn], dep[maxn], sz, len[maxn], ans[maxn];
char s[maxn], t[maxn];
int q, l, r;
struct SAM {
    int son[maxn][2];
    inline void insert(int c) {
        int np = ++tot, p = last;
        last = np, len[np] = len[p] + 1;
        while (p && !son[p][c]) son[p][c] = np, p = fa[p];
        if (!p)
            fa[np] = 1;
        else {
            int q = son[p][c];
            if (len[q] == len[p] + 1)
                fa[np] = q;
            else {
                int nq = ++tot;
                len[nq] = len[p] + 1;
                memcpy(son[nq], son[q], sizeof(son[q]));
                fa[nq] = fa[q];
                fa[np] = fa[q] = nq;
                while (son[p][c] == q && p) son[p][c] = nq, p = fa[p];
            }
        }
    }
} sam;
/// i-len[i]µ¥µ÷²»¼õ
struct segmentree {
#define ls u << 1
#define rs u << 1 | 1
    int maxv[maxn << 2];
    inline void pushup(int u) { maxv[u] = max(maxv[ls], maxv[rs]); }
    inline void build(int u, int l, int r) {
        if (l == r) {
            maxv[u] = ans[r];
            return;
        } else {
            int mid = (l + r) >> 1;
            build(ls, l, mid);
            build(rs, mid + 1, r);
            pushup(u);
        }
    }
    inline int query(int u, int l, int r, int x, int y) {
        if (x > y)
            return 0;
        if (x <= l && y >= r) {
            return maxv[u];
        } else {
            int mid = (l + r) >> 1;
            int ret = 0;
            if (x <= mid)
                ret = max(ret, query(ls, l, mid, x, y));
            if (y > mid)
                ret = max(ret, query(rs, mid + 1, r, x, y));
            return ret;
        }
    }
} tree;
inline int erfen(int l, int r) {
    int ret = r + 1;
    int tag = l;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (mid - ans[mid] + 1 >= tag) {
            ret = mid;
            r = mid - 1;
        } else
            l = mid + 1;
    }
    return ret;
}
int main() {
    scanf("%s%s%d", s + 1, t + 1, &q);
    int lens = strlen(t + 1);
    for (int i = 1; i <= lens; ++i) sam.insert(t[i] - 'a');
    lens = strlen(s + 1);
    int p = 1;
    int n = lens, nowlen = 0;
    for (int i = 1; i <= lens; ++i) {
        while (!sam.son[p][s[i] - 'a'] && p) {
            p = fa[p];
            nowlen = len[p];
        }
        if (p != 0)
            nowlen++;
        else
            nowlen = 0;
        p = sam.son[p][s[i] - 'a'];
        if (p == 0)
            p = 1;
        ans[i] = nowlen;
    }
    tree.build(1, 1, n);
    for (int i = 1; i <= q; ++i) {
        scanf("%d%d", &l, &r);
        int pos = erfen(l, r);
        printf("%d\n", max(pos - l, tree.query(1, 1, n, pos, r)));
    }
    return 0;
}
```

---


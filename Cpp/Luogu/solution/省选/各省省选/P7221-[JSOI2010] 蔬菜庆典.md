# [JSOI2010] 蔬菜庆典

## 题目描述

JYY 在火星上找到一片埋有宝藏的岛，并且带走了一些宝藏。之后 JYY 被火星人发现偷宝藏，抓了起来。火星人打算吃掉 JYY，除非 JYY 能在火星年度蔬菜庆典的游戏中赢得足够多的火星币来支付他带走宝藏的费用。

游戏在蔬菜广场上进行。首先放进广场的是一个巨大的转基因南瓜，接着各种其他巨大的蔬菜被陆续拖进广场，连同大南瓜一共 $n$ 个，第 $i$ 个放入的蔬菜会用一根绳子和先前放入的某个蔬菜连接起来。按照火星人的说法，蔬菜 $i$ 是蔬菜 $p_i$ 的 Dlihc，蔬菜 $p_i$ 是蔬菜 $i$ 的 Tnerap。JYY 立即看出，一开始的大南瓜没有 Tnerap，后来的每个蔬菜都恰好有一个 Tnerap；每个蔬菜可能有一个或多个的 Dlihc，也可能没有。$n$ 个蔬菜全部在广场上安置好后，火星人在每个蔬菜上贴一张纸条，蔬菜 $i$ 的纸条上写着一个整数 $v_i$，表示这个蔬菜的价钱。

游戏一个接一个地进行着。在整个晚会将要结束时，JYY 终于等到了适合自己的那一个。（你不能指望有恐高症的 JYY 会在蔬菜间玩走钢丝，尽管那样能有丰厚的报酬）。游戏规则是：游戏者（也就是 JYY）每次可以选择任意一个既有 Dlihc 又有 Tnerap 的蔬菜 $i$，将它的价钱 $v_i$ 改成 $v_p+v_c-v_i$，其中 $p$ 代表蔬菜 $i$ 的 Tnerap 的编号，$c$ 代表蔬菜 $i$ 的任意一个 Dlihc 的编号。火星人给的时间比较宽裕，足够 JYY 进行任意多次操作。当 JYY 决定不再操作时，游戏结束。之后所有巨型蔬菜将被火星政府按蔬菜上的标价收购。买菜所得的钱归 JYY 所有，用以支付他的债务。

JYY 想知道，他最多能把这些蔬菜卖出多少钱，或者他能通过一系列操作使得蔬菜的总价无限制地增大。请你帮助 JYY 解决这个问题。

## 说明/提示

### 样例解释 1

共有两组数据。

对于第一组数据，我们只能对蔬菜 $3$ 进行操作，它的值只能是 $1$ 或 $4$，所以答案为 $3+2+4+2+2=13$。

对于第二组数据，可以按照如下方法使得所有蔬菜的价钱无限制地增大：

$$\begin{matrix}1\to 3+3-1=5\\5\to 3+2-5=0\\0\to 3+3-0=6\\6\to 3+2-6=-1\\-1\to 3+3-(-1)=7\\\cdots\end{matrix}$$

### 数据范围

对于 $100\%$ 的数据，$n\leq 2\times 10^5,-10^7\leq v_i\leq 10^7$。

## 样例 #1

### 输入

```
5
-1 3
1 2
1 1
3 2
3 2
5
-1 3
1 2
1 1
3 2
3 3
0```

### 输出

```
13
+inf
```

# 题解

## 作者：XUAN— (赞：11)

# 蔬菜庆典

[题目](https://www.luogu.com.cn/problem/P7221)

打个广告 [XUAN](https://www.luogu.com.cn/blog/XUAN-q/)

据说数据很水，所以蒟蒻也不知道自己写对没，欢迎指正（小声）

------------

**题目大意** ： 给定一棵带点权的树，可修改 节点 $w_x=w_1+w_2-w_x$ ($w_1$ 为 $x$ 父节点的值，$w_2$ 为$x$任意子节点的值 )——修改操作可任意进行，问最终最大点权和（可为正无穷）

分类思考：

## +inf


到底什么情况下才是正无穷呢？根据样例不难发现，如果一个可操作节点拥有两个值不相同的儿子，那么反复操作，答案就会不断累加，可以达到正无穷。显然地，一条链是无法变成+inf的，尝试手动模拟一下就会发现，点权值只能随修改反复横跳。

那么，儿子的值都相同就一定不是正无穷了嘛？显然不是的，因为，若其中一个儿子的可以被改变(即$2 * w_x！=w_1+w_2$ )那么就等同有两个不同的儿子，这也是成立的。

![](https://cdn.luogu.com.cn/upload/image_hosting/18hwhjdx.png)


## 求最大值

接下来就是求最大值，显然，我们只需要考虑链的情况，因为对于有分叉的情况，既然它无法构成 +inf 的情况，一定是所有儿子值相同且不能改变，（不算根节点处的分叉） 那么直接统计其初值就好了（我维护了子树和）

现在来思考一下链的情况，按正常人的思路——可以贪心吗？
怎么贪心？——让我们来把规律进行一个找

![](https://cdn.luogu.com.cn/upload/image_hosting/6fhosvco.png)

好吧，虽然有点奇妙 ~~（确实不是人能想出来的）~~ ，但显然，最终答案是一个固定的序列——以儿子减父亲的值作为一项，各项系数分别为 $1$ 至 $n$ ,贪心地把较大项的系数给到更大即可。（显然和大佬们的差分是等价der）

------------
最后给到代码，感谢同机房的巨们帮忙改了一下，虽然很丑，但至少还是能看懂（前方大佬给的码太时尚了，我痛苦了好久）


### Code
```cpp
#define M 200005//author : XUAN
#define LL long long
#define inf 0x3f3f3f
using namespace std;
int h[M],to[M],pre[M],d,son[M],n,fa[M],Root;
LL w[M],sum[M],ans;
void add(int a,int b)
{d++;pre[d]=h[a];h[a]=d;to[d]=b;}
bool flag1,flag4,flag2,flag3,Flag;
LL yezi;
void dfs(int x)
{ 
     if(flag1||(flag2&&flag3))return;
     sum[x]+=w[x];
     LL Pre=inf; // 前个儿子的值 
    if(son[x]==0){yezi+=w[x]; return ;} //叶子 
    if(fa[x]!=Root && son[x]!=0 && son[fa[x]]>1) flag3=1; // 前分叉  
    if(son[x]>1) flag4=1;// 分叉  
    for(int i=h[x];i;i=pre[i])
    {
        if(w[fa[x]]+w[to[i]]!=2*w[x]) flag2=1; // x 点值可改 
        if(Pre!=inf && w[to[i]]!=Pre) flag1=1; //两个不一样的儿子 
        Pre=w[to[i]];
        dfs(to[i]);
        sum[x]+=sum[to[i]]; //子树和 
    }  
    return ;
}
LL cf[M],top; //答案数组 
bool cmp(int x,int y)
{return x>y;}
LL find(int x)
{ 
    flag1=flag4=flag2=flag3=0;yezi=0;
    dfs(x);
    if(flag1||(flag2&&flag3))return 0; // x 有两个不一样的儿子 || fa[x] 有两个不一样的儿子（x可以变） 
    if(flag4&&flag3)return sum[x]; // 分叉点 （直接统计答案) 
    top=0;//留下的就是链了 
    for(int i=x;;i=to[h[i]])
    {
        cf[++top]=w[i]-w[fa[i]];
        if(h[i]==0)break; // 链尾 
    }
    sort(cf+1,cf+top+1,cmp);
    LL now=w[Root];
    LL sum=0;
    for(int i=1;i<top;i++)  //注意尾巴（叶子）不要重复加
    {
        now+=cf[i];
        sum+=now;
    }
    return sum+yezi;
}
void cl()
{	
	d=0;ans=0;Flag=0;yezi=0;
	memset(h,0,sizeof(h));
	memset(son,0,sizeof(son));
	memset(sum,0,sizeof(sum));
}
int main()
{
    while(1)
    {
    	cl();
		scanf("%lld",&n); 
        if(n==0)break;
        for(int i=1;i<=n;i++)
        {
            scanf("%d%lld",&fa[i],&w[i]);
            if(fa[i]!=-1) add(fa[i],i),son[fa[i]]++;
            else Root=i;
        }
        for(int i=h[Root];i;i=pre[i])
        {
            LL temp=find(to[i]);//遍历所有根节点的儿子
            if(flag1||(flag2&&flag3)){Flag=1;break;} 
            ans+=temp;
        }
        if(Flag)printf("+inf\n");
        else printf("%lld\n",ans+w[Root]);    
    }
    return 0;
}
```

---

## 作者：KaisuoShutong (赞：7)

# P7221 [JSOI2010] 蔬菜庆典
[题目链接](https://www.luogu.com.cn/problem/P7221)。

## 题意

给定一棵树，点有点权，允许进行若干次操作，使得某点 $x$ 的权值 $v_x$ 变为 $v_{fa} + v_{son} - v_x$，$son$ 可以是任意 $x$ 的任意儿子，求总权值最大为多少，无限大输出 `+inf`。

## 题解

首先发现这个 `+inf` 十分奇怪，仔细观察后会发现，若某点有父亲，有两个儿子且它们点权不同，则 $x$ 可以无限增大。  
至于为什么：  
一次操作后权值为：$v_{fa}+v_{sonI}-v_x$。  
两次操作后权值为：$v_{fa}+v_{sonII}-(v_{fa}+v_{sonI}-v_x)=v_{sonII}-v_{sonI}+v_x$。

但这不太对劲啊，万一我操作操作，两个儿子就不同了呢，那不也可以 `+inf`？  
所以，要保持儿子们都相同，我们要保证儿子的儿子们都不能操作，也就是 $v_{fa}+v_{son} = v_x\times 2$。  
所以整合整合，不为 `+inf` 的条件如下：
1. 所有 $dep$ 相同的点，权值必须相同。
2. 所有点必须不可操作。

这几条规则要求在根以下的第一个“分叉点”的子树内满足。

等等，新的问题出现了，如果我们从根开始到“分叉点”的中间某个点可以动，不就可以一直动到最下面，使得某点两儿子不同吗？

那么条件再加上一个。注意，此时要求分叉点必须有一个儿子有儿子。

如果你不太理解，可以看看这张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/2m759wtc.png)

你会发现现在只有链可以操作了。
怎么求链？
考察式子的意义。如果我们将链拍成序列然后差分，会发现其相当于交换两个相邻的数。

原来：$A,B,C,D,E$  
差分：$A,B-A,C-B,D-C,E-D$  
交换：$A,C-B,B-A,D-C,E-D$  
还原：$A,A+C-B,C,D,E$

差分，排序，然后还原即可。

还有一个小细节，因为根没有父亲所以不能算贡献，所以我们用根将树分成若干连通块，分别求。

注意这题数据极水，过了都不一定是真过了。

点个赞吧。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 200010;
int read() {
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
int n,d[maxn],pa[maxn],vis[maxn],dfx,val[maxn],vl[maxn],son[maxn],Q[maxn],T[maxn];vector<int>G[maxn];
char Dfs(int x) {
	d[x]=d[pa[x]]+1;
	if(vis[d[x]]!=dfx) vis[d[x]]=dfx,val[d[x]]=vl[x];
	else if(val[d[x]]!=vl[x]) return 1;
	for(auto y:G[x]) if(Dfs(y)) return 1;
	return 0;
}
char dfs(int x) {
	if(!son[x]) return 0;
	if(vl[pa[x]]+vl[G[x][0]]!=vl[x]*2) return 1;
	for(auto y:G[x]) if(dfs(y)) return 1;
	return 0;
}
char Sv(int rt) {
	int x=rt;Q[0]=T[0]=0;Q[++Q[0]]=pa[x];char fl=0;
	while(son[x]==1) fl|=vl[pa[x]]+vl[G[x][0]]!=vl[x]*2,Q[++Q[0]]=x,x=G[x][0];
	if(son[x]) fl|=vl[pa[x]]+vl[G[x][0]]!=vl[x]*2;
	++dfx,Q[++Q[0]]=x;if(son[x]) Q[++Q[0]]=G[x][0];
	for(auto y:G[x]) if(Dfs(y)||dfs(y)) return 1;
	if(fl) for(auto y:G[x]) {if(son[y]) fl|=2;break;}
	if(fl==3) return 1;
	for(int i=1;i<Q[0];i++) T[++T[0]]=vl[Q[i+1]]-vl[Q[i]];
	sort(T+1,T+1+T[0],greater<int>());
	for(int i=2;i<=Q[0];i++) vl[Q[i]]=vl[Q[i-1]]+T[i-1];
	return 0;
}
signed main() {
	while(n=read()) {
		for(int i=1;i<=n;i++) d[i]=0,son[i]=0,G[i].clear();
		read(),vl[1]=read();int ans=0;
		for(int i=2;i<=n;i++) ++son[pa[i]=read()],vl[i]=read(),G[pa[i]].push_back(i);
		for(auto y:G[1]) if(Sv(y)) {cout<<"+inf\n";goto ED;}
		for(int i=1;i<=n;i++) ans+=vl[i];cout<<ans<<'\n';ED:;
	}
	return 0;
}
```

---

## 作者：一念之间、、 (赞：6)

### 题意简述：

多组数据。

给定一棵树，每个有儿子且有父亲的点x都可以改变自身的权值为

$v[f[x]]+v[son[x]]-v[x]$

求改变后权值和最大（可能变成`+inf`）。

### 求+inf情况

首先看到第二组数据，发现在什么情况一个点会无限调整成为`+inf`呢？

我们发现只要一个点有两个权值不同的儿子，则他可以一直调整

第一次：

$v[f[x]]+v[son0[x]]-v[x]$

第二次：

$v[f[x]]+v[son1[x]]-(v[f[x]]+v[son0[x]]-v[x])=v[x]+v[son1[x]]-v[son0[x]]$

我们可以一直加差值下去，那么我们考虑什么点是可以这样变化的呢，首先这个点不是根节点（有父亲）分多个叉（有不同儿子）考虑当儿子节点权值相等的时候，发现只要有一个儿子权值会发生改变，则答案都为`+inf`，换句话说

![](https://cdn.luogu.com.cn/upload/image_hosting/j2n80da1.png)

从绿色节点开始，下面儿子每一层的点权是固定的，且下面每个点点权不能改变，即满足$v[f[x]]+v[son[x]]-v[x]=v[x]$

同时我们要保证绿色节点和绿色节点到根的任何一个点权值不能改变，因为绿色节点以上的权值改变会一个一个传下来导致儿子节点权值改变，而变成`+inf`（虽然数据很水，只需要判断绿色节点这一个会不会改变就可以了）

至此，我们完成了判断`+inf`的过程，考虑在不是`+inf`的时候如果求答案。

### 求其他答案

我们发现剩下答案是抽出来一些链求贡献，（因为只要有分叉，儿子节点权值必不能变，所以直接累加即可）

考虑一条链的情况，将其差分一下

我们可以发现将一个点的权值改变时相当于交换两边的差值，

$swap (v[x]-v[f[x]],v[son[x]]-v[x])$

所以我们对于一条链来说可以贪心的把差值求出来，大的放在前面，还原的时候大的尽量多计算贡献。

至此我们解决了这道题。

### 框架

考虑整体框架，

首先从根的各个儿子进行dfs，向下找到第一个分叉的点，考虑这个点和子树能否变更权值，同时判断子树是否满足每层相同（判断输出`+inf`）

第二次从根的各个儿子进行dfs，向下找到第一个分叉的点，求出根到这个点的链的权值，下面的子树直接求和即可。

下面是代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int read()
{
	char c;
	int w=1;
	while((c=getchar())>'9'||c<'0')if(c=='-')w=-1;
	int ans=c-'0';
	while((c=getchar())>='0'&&c<='9')ans=(ans<<1)+(ans<<3)+c-'0';
	return ans*w;
}
const int xx=2e5+5;
struct node
{
	int next,to;
}e[xx];
int cnt;
int h[xx];
void add(int x,int y)
{
	cnt++;
	e[cnt].next=h[x];
	h[x]=cnt;
	e[cnt].to=y;
}
int v[xx],n,f[xx];
int root=0;
int Dcheck[xx];//每层的是否相等 
int dvis[xx];//用于清空 
int now;
bool check(int x,int d)
{
	if(dvis[d]!=now)
	{
		dvis[d]=now;
		Dcheck[d]=v[x];
	}
	else 
	{
		if(Dcheck[d]!=v[x])return 0;
	}
	int vis=1;
	int sval=-2147483647;
	for(int i=h[x];i;i=e[i].next)
	{
		vis&=check(e[i].to,d+1);
		if(!vis)return 0;
		sval=v[e[i].to];
	}
	if(sval!=-2147483647)
	{
		if(sval+v[f[x]]!=v[x]+v[x])return 0;
	}
	return vis;
}
bool ck(int x){return v[x]*2!=(v[f[x]]+v[e[h[x]].to]);}
bool dfs(int x,int c)//这一次判断儿子是否合法 
{
	int tot=0;
	for(int i=h[x];i;i=e[i].next)tot++;
	if(tot>1)
	{
		now++;
		int maxx=0;
		for(int i=h[x];i;i=e[i].next)
		{
			maxx=max(maxx,h[e[i].to]);
			if(!check(e[i].to,1))return 0;
		}
		if(!maxx)return 1;
		else 
		{
			if((c|ck(x))==1)return 0;
			return 1;
		}
	}
	for(int i=h[x];i;i=e[i].next)
	{
		if(!dfs(e[i].to,c|ck(x)))return 0;
	}
	return 1;
}
vector<ll>V;
ll getsum(int x)
{
	ll ans=v[x];
	for(int i=h[x];i;i=e[i].next)ans+=getsum(e[i].to);
	return ans;
}
ll js()
{
	for(int i=V.size()-1;i>0;i--)V[i]-=V[i-1];
	sort(V.begin()+1,V.end());
	reverse(V.begin()+1,V.end());
	ll res=0;
	for(int i=0;i<V.size();i++)
	{
		res+=1ll*V[i]*(V.size()-i);
	}
	return res;
}
ll getans(int x)
{
	int tot=0;
	V.push_back(v[x]);
	for(int i=h[x];i;i=e[i].next)tot++;
	if(tot>1||tot==0)
	{
		if(tot!=0)V.push_back(v[e[h[x]].to]);
		ll ans=js();//处理vector 
		if(tot!=0)ans-=v[e[h[x]].to];
		for(int i=h[x];i;i=e[i].next)ans+=getsum(e[i].to);
		return ans;
	}
	for(int i=h[x];i;i=e[i].next)return getans(e[i].to);
}
signed main(){
	while(1)
	{
		n=read();
		for(int i=1;i<=n;i++)h[i]=0;
		memset(e,0,sizeof(e[0])*(cnt+1));
		if(!n)return 0;
		for(int i=1;i<=n;i++)
		{
			int a=read();
			f[i]=a;
			if(a==-1)root=i;
			else add(a,i);
			v[i]=read();
		}
		int res=1;
		for(int i=h[root];i;i=e[i].next)
		{
			res&=dfs(e[i].to,0);
			if(!res)break;
		}
		if(!res)
		{
			puts("+inf");
			continue;
		}
		ll ans=0;
		int tot=0;
		for(int i=h[root];i;i=e[i].next)
		{
			tot++;
			V.clear();
			V.push_back(v[root]);
			ans+=getans(e[i].to);
		}
		cout<<ans-1ll*v[root]*(tot-1)<<'\n';
	}
	return 0;
}
```




---

## 作者：Gmt丶FFF (赞：1)

本题解在求无解的情况下优化了下。

通过分析样例，我们可以发现如果一个节点有多个 Dlihc，那么这些 Dlihc 对应的权值必须一样，否则可以无限延伸下去。

因为一号节点没有 Tnerap，所以一号节点一定不能更新，加上关系成树型结构那我们可以看成一个根节点把一棵树分成了几个子任务。

若子树不为链，就一定有一个节点有多个 Dlihc，设这个节点为 $x$。

那如果要判断无解：

1、$x$ 的子节点有权值不相同。

2、$x$ 的子节点相同，且子节点有子节点，并且此子任务中有节点可以更新。

证明：第一个易证，第二个若 $x$ 的子节点有子节点，代表 $x$ 的子节点可以更新。若子节点的子节点的权值与 $x$ 节点权值加起来为子节点权值相同，才有可能有解。若此时 $x$ 节点和子节点的子节点更新，那么必定无解。若不能更新，那可能有解，但若 $x$ 的父节点与子节点的子节点的子节点可以更新，那无解。综上，只要这个字任务的树中有节点可以更新，那么就无解。

然后就是求答案，首先如果一个子任务不为链且 $x$ 的子节点有子节点，那么无法更新，直接累加即可。

若不为链但 $x$ 的子节点无子节点，由于 $x$ 的子节点无法更新，可以取任意一个子节点即可，化作为链求解。

求解过程与其他人差不多，对链上的数进行查分，将差分后的数从大到小排序后，求所有的差分前缀和即可。

程序中先将所有点的初始值加起来，如果要进行差分加排序操作，再减去。



```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#define int long long
using namespace std;
const int N=2e5+5;
int n,pre[N],num[N],ans,sum[N],pef[N];
vector<int>suf[N];
bool flag,lim,flag2;
//flag 代表是否为不是链的情况，
//lim 代表这棵树是否能更新，
//flag2 代表x的子节点是否有子节点。
bool dfs(int x,int step)
{
	sum[step]=num[x]-num[pre[x]];
	pef[step]=x;
	int len=suf[x].size();
	if(len==0&&!flag)
	{
		sort(sum+1,sum+1+step);
		int tac=num[1];
		for(int i=step;i>0;i--)tac+=sum[i],ans+=tac-num[pef[i]];
		return true;
	}
	if(flag==1&&len!=0)flag2=1;
	if(flag2==1&&lim==1)return false;
	if(len>1)flag=1;
	bool ss=1;
	for(int i=0;i<len;i++)
	{
		if(num[pre[x]]+num[suf[x][i]]!=2*num[x])lim=1;
		ss&=dfs(suf[x][i],step+1);
		if(num[suf[x][0]]!=num[suf[x][i]])return false;
	}
	if(len>1&&!flag2)
	{
		sort(sum+1,sum+1+step+1);
		int tac=num[1];
		for(int i=step+1;i>0;i--)tac+=sum[i],ans+=tac-num[pef[i]];
	}
	return ss;
}
signed main()
{
	while(1)
	{
		scanf("%lld",&n);
		if(n==0)break;
		ans=0;
		for(int i=1;i<=n;i++)suf[i].clear(),scanf("%lld%lld",&pre[i],&num[i]),suf[pre[i]].push_back(i),ans+=num[i];
		int len=suf[1].size();
		bool st=1;
		for(int i=0;i<len;i++)
		{
			flag=flag2=lim=0;
			if(!dfs(suf[1][i],1))st=0;
		}
		if(!st)printf("+inf\n");
		else printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：Acc_Robin (赞：0)

## 题意

给定一棵 $n$ 个节点的树，每个点有点权。你可以做任意次操作，每次操作可以让一个点的点权 $v_x\to v_{fa_x}+v_{c_x}-v_x$，其中 $fa_x$ 表示 $x$ 的父亲，$c_x$ 表示 $x$ 的任意一个儿子。

问最后所有节点的点权和最大为多少，若可以无限大则输出 `+inf`。

## 题解

首先发现一个结论：对于一个可以操作的节点，如果它有两个儿子权值不同，则可以让这个点无限增长，具体就是轮流使用两个儿子进行操作。

再考虑部分分中的链：对于一条链，这个操作的意义就是交换差分数组中相邻的两项。那么只需要求出差分数组并排序即可。

至此，这道题的做法已经清晰可见了，对于根的每棵子树都做一遍如下操作即可：

- 从根向下找到第一个有多个儿子的节点，设为 $x$。
- 对于 $x$ 的子树进行遍历。
  - 若一个点可以操作且有两个儿子权值不同，输出 `+inf`。
  - 若一个点 $i$ 可以操作使得 $v_i$ 改变（即 $v_{fa_i}+v_{c_i}\neq 2v_i$），并且 $fa_i$ 有多个儿子，在修改 $i$ 之后 $fa_i$ 就会有两个儿子权值不同，因此这种情况输出 `+inf`。
- 若 $x$ 有一个儿子有儿子，并且从根到 $x$ 的这条链上存在一个点 $i$ 的点权可以改变（即 $v_{fa_i}+v_{c_i}\neq 2v_i$），那么就可以从 $i$ 一路修改到 $x$ 的这个儿子，然后输出 `+inf`。

## 代码

最低版本要求为 C++17

```cpp
// Problem: [JSOI2010] 蔬菜庆典
// Made by: Acc_Robin
#include<vector>
#include<numeric>
#include<iostream>
#include<algorithm>
using namespace std;
enum{N=200009};
vector<int>G[N];
using ll=long long;
auto wk=[](){
 int n,i,x,u,*h,*t,p;
 if(cin>>n,!n)exit(0);
 vector<ll>v(n+1);
 vector<int>f(n+1),q(n+1);
 for(i=0;i<=n;++i)G[i].clear();
 for(i=1;i<=n;++i){
  cin>>x>>v[i],f[i]=~x?x:0;
  G[f[i]].emplace_back(i);
 }
 for(int&s:G[1]){
  vector w={1};
  for(p=0,x=s;G[x].size()==1;){
   p|=v[f[x]]+v[G[x][0]]!=v[x]*2;
   w.emplace_back(x),x=G[x][0];
  }
  if(w.emplace_back(x),G[x].size()){
   p|=v[f[x]]+v[G[x][0]]!=v[x]*2;
   w.emplace_back(G[x][0]);
  }
  for(h=q.data(),*(t=h+1)=x;h<t;){
   for(u=*++h;int&v:G[u])*++t=v;
   for(i=1;i<G[u].size();++i)
    if(v[G[u][i]]!=v[G[u][i-1]])
     return cout<<"+inf\n",0;
   if(u==x)continue;
   if(G[u].size())
    if(p||v[f[u]]+v[G[u][0]]!=2*v[u])
     return cout<<"+inf\n",0;
  }
  vector g(w.size(),0ll);
  for(g[0]=v[1],i=1;i<w.size();++i)
   g[i]=v[w[i]]-v[w[i-1]];
  sort(begin(g)+1,end(g),greater<>());
  partial_sum(begin(g),end(g),begin(g));
  for(i=0;i<g.size();++i)v[w[i]]=g[i];
 }
 cout<<accumulate(begin(v),end(v),0ll)<<'\n';
 return 0;
};
int main(){
 for(;;)wk();
}
```

---


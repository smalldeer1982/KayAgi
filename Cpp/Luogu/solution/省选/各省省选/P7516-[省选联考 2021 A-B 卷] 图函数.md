# [省选联考 2021 A/B 卷] 图函数

## 题目描述

对于一张 $n$ 个点 $m$ 条边的有向图 $G$（顶点从 $1 \sim n$ 编号），定义函数 $f(u, G)$：

1. 初始化返回值 $cnt = 0$，图 $G' = G$。
2. 从 $1$ 至 $n$ 按顺序枚举顶点 $v$，如果当前的图 $G'$ 中，从 $u$ 到 $v$ 与从 $v$ 到 $u$ 的路径都存在，则将 $cnt + 1$，并在图 $G'$ 中删去顶点 $v$ 以及与它相关的边。
3. 第 $2$ 步结束后，返回值 $cnt$ 即为函数值。

现在给定一张有向图 $G$，请你求出 $h(G) = f(1, G) + f(2, G) + \cdots + f(n, G)$ 的值。

更进一步地，记删除（按输入顺序给出的）第 $1$ 到 $i$ 条边后的图为 $G_i$（$1 \le i \le m$），请你求出所有 $h(G_i)$ 的值。

## 说明/提示

**【样例 #1 解释】**

对于给出的完整图 $G$：

1. $f(1, G) = 1$，过程中删除了顶点 $1$。
2. $f(2, G) = 1$，过程中删除了顶点 $2$。
3. $f(3, G) = 2$，过程中删除了顶点 $2, 3$。
4. $f(4, G) = 2$，过程中删除了顶点 $1, 4$。

---

**【数据范围】**

对于所有测试数据：$2 \le n \le {10}^3$，$1 \le m \le 2 \times {10}^5$，$1 \le x_i, y_i \le n$。

每个测试点的具体限制见下表：

| 测试点编号 | $n \le$ | $m\le$ |
|:-:|:-:|:-:|
| $1 \sim 4$ | $10$ | $10$ |
| $5 \sim 11$ | $100$ | $2 \times {10}^3$ |
| $12 \sim 20$ | ${10}^3$ | $5 \times {10}^3$ |
| $21 \sim 25$ | ${10}^3$ | $2 \times {10}^5$ |

## 样例 #1

### 输入

```
4 6
2 3
3 2
4 1
1 4
2 1
3 1
```

### 输出

```
6 5 5 4 4 4 4
```

## 样例 #2

### 输入

```
见附件中的 graph/graph2.in。```

### 输出

```
见附件中的 graph/graph2.ans。```

# 题解

## 作者：zjjws (赞：70)

### Solution


考虑 $f(i,G)$ 的实际含义：

在 $[1,i]$ 这段范围内的点 $x$（在 $i$ 之后的点就一定没贡献了，因为 $i$ 自己以及连出的边都删除了），我们用 $g(i,x)$ 表示循环到它的时候它满足条件 $i\to x$ 和 $x\to i$，也就是两点连通。

那么按照题意，按顺序考虑每个点的时候，若满足 $[g(i,x)]$，那么就会将这个点删去。

会注意到我们不需要真的执行删除这一操作，因为实际上 $g(i,x)$ 等价于：同时存在路径 $i \to x$ 和 $x \to i$ 满足不经过点 $[1,x)$。

---

关于这里的等价转化，实际是需要分讨的，我们考虑一个点 $y\in [1,x)$：

- $y$ 做了贡献，使 $cut+1$ 并且被删除。那么此时显然成立。

- $y$ 没做贡献，那么此时 $i,y$ 之间至少有一条某方向的路径不连通。如果 $x\to i$ 或者 $i\to x$ 的某一条路径一定要经过 $y$ 点，那么就出现了一个矛盾的情况：**$y,i$ 有且仅一个方向的通路，$x,i$ 可互相到达，并且其中一条通路中，$y$ 是必经点。**

第二种情况会有四种情况，手枚一下便会发现是矛盾的 case。


---

我们定义两个点 $y,x(y<x)$ **贴贴** 当且仅当当前的边集 $G$ 使得 $[g(i,x)]$ 成立。会注意到对于每个边集，我们要求的就是 **贴贴** 的点对数。特殊的，每个点一定和自己贴贴，和边集无关。

将时间轴倒过来，变成加边，那么随着边的增加，贴贴的对数不可能减少。于是我们只要可以求出每一对点 **最早的贴贴时间**，就可以通过一个差分来实现 $\operatorname O(m)$ 求得所有答案。

回顾一下 $g(y,x),y<x$ 的定义：从 $x/y$ 出发，只经过 $[y,n]$ 范围内的点，能够到达 $y/x$。

看到这个东西是不是非常熟悉？没错，这就是 Floyd。

只要从大到小枚举中间转移点，然后按正常的做法跑 Floyd，就可以得到前面提到的差分数组。

于是就有了优秀的 $\operatorname O(n^3+m)$ 的做法。

---

### 考场 Code

除了把乱码注释删去以外，没做更改。

```cpp
#include <stdio.h>
#define LL long long
using namespace std;
const int Rea=1e5+3;
struct Rin
{
	char c;
	inline char gc()
	{
		static char rea[Rea];
		static char *head,*tail;
		return head==tail&&(tail=(head=rea)+fread(rea,1,Rea,stdin),head==tail)?EOF:*head++;
	}
	inline Rin&operator >>(int &x)
	{
		x=0;
		bool tag=false;
		for(c=gc();c>'9'||c<'0';c=gc())if(c=='-'){c=gc();tag=true;break;}
		for(;c>='0'&&c<='9';c=gc())x=(x<<1)+(x<<3)+(c^'0');
		if(tag)x=-x;return *this;
	}
}rin;
inline void jh(int &x,int &y){if(x^y)x^=y^=x^=y;return;}
inline int min(int x,int y){return x<y?x:y;}
inline int max(int x,int y){return x>y?x:y;}

const int N=1e3+3;
const int M=2e5+3;
int n,m;
int u[N];
int v[N];
int f[N][N];

int g[M];
int ans[M];
int main()
{
	freopen("graph.in","r",stdin);
	freopen("graph.out","w",stdout);
	rin>>n>>m;for(int i=1;i<=m;i++)rin>>u[i]>>v[i],f[u[i]][v[i]]=i; 
	for(int k=n;k>=1;k--)
	{
		for(int i=k+1;i<=n;i++)g[min(f[k][i],f[i][k])]++;
		for(int i=1;i<=n;i++)
		{
			if(!f[i][k])continue;int nows=f[i][k];
			if(i>k)for(int j=1;j<k;j++)f[i][j]=max(f[i][j],min(nows,f[k][j]));
			else for(int j=1;j<=n;j++)f[i][j]=max(f[i][j],min(nows,f[k][j]));
		}
	}
	ans[m+1]=n;for(int i=m;i>=1;i--)ans[i]=ans[i+1]+g[i];
	for(int i=1;i<=m+1;i++)printf("%d ",ans[i]);puts("");
	return 0;
}
```



---

## 作者：Lice (赞：30)

这里有一个靠谱复杂度的做法 qwq

### Description & Hint

原题意够形式化了吧 [qwq](https://www.luogu.com.cn/problem/P7516)

### Solution

原来打爆我的不是最短路，而是 Bfs。参考了 @Grice 的 [做法](https://www.cnblogs.com/Grice/p/14645327.html)，不过这位大佬写的过于简洁，好久才悟 /dk，写篇题解理理思路，作为复盘。

首先还是一些常规的转化。我们自然不考虑求出每个 $f(u,G)$ 的值，而尝试直接算出有多少顶点对 $(u,v)$ 会对 $h(G_i)$ 产生贡献，毕竟需要我们细化分别求出的是 $h$ 而不是 $f$。

其次，考虑一个点 $v$ 对 $f(G,u)$ 的何时会产生贡献：存在 $u\to v$、$v\to u$ 两条路径，其上只存在编号 $\ge v$ 的点。可不可能通过一个 $<v$ 的点 $k$ 找到这两条路径呢？考虑 $u\to v\to u$ 这已经形成一个环了，那其上的 $k$ 势必会在之前被删掉，任何这样的 $k$ 都不能被这两条路径利用，一旦可以被利用你会发现它们在之前就莫得了。

现在问题转化为：对于每个图 $G,G_1, G_2, \cdots, G_m$，分别求有多少顶点对 $(u, v)$（$u\ge v$），存在两条不经过编号 $<v$ 的顶点的路径 $u\to v$、$v\to u$（下面简称这样的路径为“合法路径”）。

我们再换个角度，从顶点对的方向突破。很显然一个点对会对一个答案的前缀产生贡献。设合法路径 $u\to v$、$v\to u$ 上经过的边的编号最小值最大化为 $x$，其中最小值是产生贡献前缀的大小，而最大化是因为我们希望它产生最大的贡献。最后可以求出答案的差分数组，一波后缀和即可出解。

这时已经有一个最短路的模型了，可以用经典的 Floyd 或 Dijkstra 解决，复杂度为 $O(n^3+m)$ 或 $O(nm\log n)$，但都很卡（全世界就我跑不动 $1000$ 的 Floyd）。

接下来是一个高明的 $O(n(n+m))$ 的做法（为什么我都想不到/kk）。对每个点 $v$，考虑其对 $f(u,G)$ 产生的贡献。那么我们只要保留 $[v, n]$ 的点，对 $O(m)$ 张图分别求出其能到的点数，一次 Bfs $O(m)$。这样复杂度很高，是 $O(nm^2)$ 的。

于是考虑一个优化：我们不对 $O(m)$ 张图都求一遍，而是每次倒着加边。对于一条新边 $(a,b)$，如果 $a$ 被遍历过而 $b$ 没有，那么现在这条边将派上用场，之前到达过 $a$，现在直接从 $b$ 开始 Bfs 即可。如果 $a,b$ 都没遍历过，那么它可能会在以后起作用，先加到图中。其他情况，那这边就一点用没有。注意正反图都要这么操作。而在 Bfs 时，我们会把用过的边删去，不难发现这些边在之后不会被用到，所以不影响正确性。由于每条边只会用一次，过河拆桥，于是总复杂度为 $O(n(n+m))$ 的（由于是根据我自己的理解写的，可能没点到重点，有疑问敬请指出）。

### Code

```cpp
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <vector>
#include <queue>

const int N = 1e3 + 5;
const int M = 2e5 + 5;

int n, m;
int U[M], V[M];
int ans[M]; // h(G_i)

int vis[2][N];
std::vector<int> adj[2][N];

void Bfs(int g, int s, int t) {
  std::queue<int> que;
  vis[g][s] = t, que.push(s);

  while (!que.empty()) {
    int x = que.front(); que.pop();
    for (auto y : adj[g][x]) if (!vis[g][y])
      vis[g][y] = t, que.push(y);
    adj[g][x].clear();
  }
}

signed main() {
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= m; i++)
    scanf("%d%d", U + i, V + i);
  
  for (int i = 1; i <= n; i++) { // i -> f(j, G), j >= i
    for (int g = 0; g < 2; g++)
      for (int j = 1; j <= n; j++)
        adj[g][j].clear(), vis[g][j] = 0;
    vis[0][i] = vis[1][i] = m + 1;

    for (int j = m; j >= 1; j--) {
      if (std::min(U[j], V[j]) < i) continue;
      for (int g = 0; g < 2; g++, std::swap(U[j], V[j]))
        if (vis[g][U[j]] && !vis[g][V[j]])
          Bfs(g, V[j], j);
        else if (!vis[g][U[j]] && !vis[g][V[j]])
          adj[g][U[j]].push_back(V[j]);
    }

    for (int j = i; j <= n; j++) if (vis[0][j] && vis[1][j])
      ans[std::min(vis[0][j], vis[1][j]) - 1]++;
  }

  for (int i = m; i >= 0; i--)
    ans[i] += ans[i + 1];
  for (int i = 0; i <= m; i++)
    printf("%d ", ans[i]);
  return 0;
}
```

---

## 作者：dengyaotriangle (赞：24)

$\mathcal{O}(n^3/\omega)$  的做法。

首先，观察删除点的过程，发现，若一个点 $v$ 本来不需要被删除（即 $u\to v$ 和 $v\to u$ 的路径有一个不存在）时，我们反而将其删除，对接下来的过程无影响。

这是因为，$v$ 不在 $u$ 所在的强连通分量里，而之后但凡需要删除的点均在 $u$ 所在的强连通分量里中，所以删除它不影响这个分量里的强连通性。

所以，$v$ 对答案有贡献，当且仅当删除 $v$ 前面的所有的点后依然合法，所以一对 $(u,v)$ 对 $h(G)$ 有 $1$ 的贡献当且仅当 $u$ 可以只经过 $\geq u$ 的点到 $v$，且 $v$ 可以只经过 $\geq u$ 的点到 $u$。

考虑倒过来做，动态加边动态维护答案。

维护一个数组 $vis_{0,i,j}$ ，代表 $i$ 开始只经过 $\geq j$ 的点是否可以到 $j$。以及 $vis_{1,i,j}$ ，代表反图上，$i$ 开始只经过 $\geq j$ 的点是否可以到 $j$（这等价于，原图上 $j$ 开始只经过 $\geq i$ 的点是否可以到 $i$）。

答案就是 $\sum\limits_{i,j} [ vis_{0,i,j} \land vis_{1,i,j}]$

先考虑 $vis_{0,i,j}$ 如何维护。考虑最暴力的 dfs，加入一条边 $s\to t$，对于一个 $i$，若 $vis_{0,i,s}=1,vis_{0,i,t}=0$，则 $vis_{0,i}$ 会发生变化，我们将 $vis_{0,i,t}$ 设成 $1$，然后从 $t$ 开始 dfs，只 dfs $vis_{0,i,j}=0$ 的点 $j$，dfs 的同时将经过的点的 vis 置  $1$。

考虑复杂度。$m$ 次加边，每次需要看 $n$ 个  $i$，复杂度 $\mathcal{O}(nm)$。dfs部分，由于对于每个 $i$，每个点只会被访问一次（$vis_{0,i,j}=1$ 后就不会访问了），而每访问一次，需要遍历 $n$ 条出边，所以复杂度 $\mathcal{O}(n^3)$。

$vis_{1,i,j}$ 同理，只不过加的边反过来。

而求答案，我们维护了 $vis_0,vis_1$，因为每次 $vis$ 只会从 $0$ 变成 $1$，每次 dfs 修改 $vis_{0,i,j}=1$ 时，若此时 $vis_{1,i,j}=1$，则答案 $+1$，否则答案不变，修改 $vis_{1,i,j}=1$ 同理。

所以我们有了 $\mathcal{O}(n^3)$ 的做法，该上 bitset 了。

考虑把 $vis_{t,i,1}\sim vis_{t,i,n}$ 放到一个 bitset 里，称之为 $A_{t,i}$，$vis_{t,1,j}\sim vis_{t,n,j}$ 放到一个 bitset 里，称之为 $B_{t,j}$，图的邻接矩阵 $adj_{t,i,1}\sim adj_{t,i,n}$ 也放到 bitset 里，称之为 $C_{t,i}$

dfs 时，枚举 $j$ 的合法出边的过程可以直接枚举 $C_{t,j} \operatorname{and} \operatorname{not}A_{t,i}$ 里面所有位置 $\geq i$ 的 $1$，可以每次 dfs 最小的那个 $1$ 的位置直到空。

加 $u\to v$ 一条边，看哪些地方需要 dfs，可以考虑枚举 $B_{t,u}\operatorname{and} \operatorname{not} B_{t,v}$ 里面所有位置 $\leq v$ 的 $1$。

找到一个bitset 中最小的 $1$ 可以使用 `_Find_first` 和 `_Find_next` 函数，或者枚举 bitset 中每个块，找到最小一个非零的块，然后使用 `__builtin_ctz` `__builtin_ctzll` 或者 `deBrujin` 序列求出最小的那个 $1$ 的位置。复杂度 $\mathcal{O}(n/\omega)$

综上，总复杂度  $\mathcal{O}((n^3+nm)/\omega)$

代码（手写 bitset）
```cpp
#include<bits/stdc++.h>
using namespace std;
//dengyaotriangle!

const int maxn=1005;
const int pz=64;
const int lpz=6;
const int psz=maxn/pz+3;
typedef unsigned long long bt;

bt vis[2][maxn][psz],vist[2][maxn][psz];
bt edg[2][maxn][psz];
int n,m;
int ans[maxn*maxn];

struct edg{
    int u,v;
}e[maxn*maxn];
int cur;

void dfs(int id,int t,int u){
    //cerr<<id<<' '<<t<<' '<<u<<endl;
    vis[id][t][u>>lpz]|=(bt)1<<(u&(pz-1));
    vist[id][u][t>>lpz]|=(bt)1<<(t&(pz-1));
    cur+=(vis[!id][t][u>>lpz]>>(u&(pz-1)))&1;

    int i=t>>lpz;
    while(1){
        bt fi=edg[id][u][i]&~vis[id][t][i]&~(((bt)1<<(t&(pz-1)))-1);
        if(!fi)break;
        int v0=__builtin_ctzll(fi);
        dfs(id,t,v0+(i<<lpz));
    }
    for(int i=(t>>lpz)+1;i<=(n>>lpz);i++){
        while(1){
            bt fi=edg[id][u][i]&~vis[id][t][i];
            if(!fi)break;
            int v0=__builtin_ctzll(fi);
            dfs(id,t,v0+(i<<lpz));
        }
    }
}
bt fi[psz];
void adde(int id,int u,int v){
    edg[id][u][v>>lpz]|=(bt)1<<(v&(pz-1));
    for(int i=0;i<=(n>>lpz);i++)fi[i]=vist[id][u][i]&~vist[id][v][i];
    for(int i=0;i<=(n>>lpz);i++){
        while(fi[i]){
            int v0=__builtin_ctzll(fi[i]);
            fi[i]-=(bt)1<<v0;
            if(v0+(i<<lpz)>=v)return;
            dfs(id,v0+(i<<lpz),v);
        }
    }
}
int main(){
    ios::sync_with_stdio(0);cin.tie(0);
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>e[i].u>>e[i].v;
    }
    ans[m+1]=cur=n;
    for(int t=0;t<2;t++)for(int i=1;i<=n;i++){
        vis[t][i][i>>lpz]|=(bt)1<<(i&(pz-1));
        vist[t][i][i>>lpz]|=(bt)1<<(i&(pz-1));
    }
    for(int i=m;i>=1;i--){
        adde(0,e[i].u,e[i].v);
        adde(1,e[i].v,e[i].u);
        ans[i]=cur;
        //cerr<<endl;
    }
    for(int i=1;i<=m+1;i++)cout<<ans[i]<<' ';
    return 0;
}
```

---

## 作者：Alex_Wei (赞：13)

[P7516 [省选联考 2021 A/B 卷] 图函数](https://www.luogu.com.cn/problem/P7516)

设一条边的边权为它的编号。

题面描述花里胡哨，我们先推些性质。

- 将 $h$ 的值摊到每个点对 $(i, j)$ 上。
- 点对 $(i, j)(i \leq j)$ 最多只会贡献一次，因为计算 $f(i, G)$ 时，枚举 $v = j$ 时 $i$ 已经被删掉了，所以只可能在计算 $f(j, G)$ 且枚举 $v = i$ 时产生贡献。
- 模拟图函数的计算过程，点对 $(i, j)(i \leq j)$ 产生贡献当且仅当存在 $i\to j$ 的路径 $P$ 和 $j\to i$ 的路径 $Q$ 使得路径上所有点的编号不小于 $i$。
- 设 $T(i, j)$ 表示所有这样的路径 $P$ 和 $Q$ 中，边权最小值的最大值。注意是 $P$ 和 $Q$ 的边权最小值而不是 $P$ 或 $Q$。若 $i = j$ 则 $T(i, j) = m$。则 $(i, j)$ 会对所有 $h(G_t)(0\leq t < T(i, j))$ 产生贡献。

至此，存在 $n ^ 3$ 的 Floyd 做法。从大到小枚举中转点 $k$，枚举 $i, j\in [1, n]$，令 $d_{i, j}$ 和 $\min(d_{i, k}, d_{k, j})$ 取 $\max$，初始值 $d_{i, i} = m + 1$，$d_{i, j}(i\neq j)$ 为 $i\to j$ 的编号，若不存在则为 $0$。则 $d_{i, j}$ 表示仅考虑编号不小于 $k$ 的节点时（不包括两端），$i\to j$ 的边权最小值的最大值。因此，在转移 $k$ 之前（或之后），先枚举一遍 $j\in [k, n]$，则 $T(k, j) = \min(d_{k, j}, d_{j, k})$。

这个做法严重卡常，需要加一些优化：若 $d_{i, k} = 0$ 则不用再枚举 $j$，若 $i \geq k$ 则不用再枚举。[代码](https://loj.ac/s/1620382)。

考虑对每个 $i$ 求出所有 $T(i, j)(i < j)$。将所有边按权值从大到小加入，并跳过至少一个端点编号小于 $i$ 的边。在加入权为 $w$ 的边时，若 $i\rightsquigarrow j$ 且 $j\rightsquigarrow i$，说明 $T(i, j) = w$。

$j\rightsquigarrow i$ 说明 $i$ 在反图上可达 $j$。往当前图加入边 $u\to v$ 时，若 $u$ 可达且 $v$ 不可达，则从 $v$ 出发开始 bfs，将经过的点标记为可达。否则若 $v$ 可达，则 $u\to v$ 对连通性没有帮助，直接忽略。否则 $u, v$ 均不可达，这条边在 $u$ 可达时起作用，但当前没有用，所以我们保留它，将其加入 $u$ 的出边集合。对于反图同理，加入边 $v\to u$。若 $j$ 在加入边权为 $w$ 的边时第一次同时在原图和反图上可达，则 $T(i, j) = w$。每条边只会被遍历一次，时间复杂度 $\mathcal{O}(nm)$。[代码](https://loj.ac/s/1620435)。

类似 [ARC092F](https://www.luogu.com.cn/problem/AT_arc092_d)，考虑 bitset 优化。

肯定不能先枚举 $i$ 再枚举 $(u, v)$，这样已经 $\mathcal{O}(nm)$ 了。考虑按权值 $w$ 大到小添加每条边 $u\to v$，并 **批量处理每个 $i$**。设 $a_{i, j}$ 表示当前 $i$ 是否可达 $j$。若某个 $i$ 需要从 $v$ 开始 bfs，易知有 $a_{i, u} = 1$，$a_{i, v} = 0$ 且 $i\leq \min(u, v - 1)$。因此，还要维护 $r_{j, i}$ 表示 $i$ 是否可达 $j$，则 $r_u \land \lnot r_v$ 即可找到所有 $i$。

此外，维护图的邻接矩阵 $e_{i, j}$ 表示当前 $i\to j$ 是否有边。设 bfs 到 $(i, j)$，则需要更新 $i$ 可达 $to$ 当且仅当 $a_{i, to} = 0$ 且 $e_{j, to} = 1$。$\lnot a_i\land e_j$ 即可找到所有 $to$。反图类似处理。

用 `_Find_first` 和 `_Find_next` 找 bitset 中第一个 $1$ 和下一个 $1$，时间复杂度 $\mathcal{O}(n ^ 3 / w)$，是在稠密图上表现最优秀的算法。[代码](https://loj.ac/s/1620461)。

---

## 作者：ImmortalWatcher (赞：11)

算是一道比较简单的题目吧，但是考场上仍然没想出来。

$n^3$ 能过掉也是奇迹。

假设我们现在要判断 $x<i$，x 到 i 和 i 到 x 的路径是否存在，可以发现，由于 1 ~ x-1 的点我们已经删掉了，所以在后面的图上是不可能走到这些点的，也就是说我们没有必要删点，只需要限制不要走这些点就可以了。

然后把题目乱七八糟的函数嵌套展开一下，就可以发现，其实就是要你求有多少对 x 和 y （$x<y$）在不走 1 ~ x-1 这些点的情况下，x 和 y 能相互到达。

我们记录一下 $x$ 到 $y$ 联通的时间，然后取一个最小值就能知道这对点是什么时候造成贡献的，最后做一个后缀和就行了。

计算联通的时间的方式可以采用 floyd，只要控制中间点 k 满足条件，换句话说，只枚举在 i,k 确定的情况下合法的 j 来转移即可。

```cpp
#include<cstdio>
using namespace std;
int n,m,x,y,f[1010][1010],g[200010],ans[200010];
inline int min(int x,int y){return x<y?x:y;}
inline int max(int x,int y){return x>y?x:y;}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++) 
		scanf("%d%d",&x,&y),f[x][y]=i; 
	for(int k=n;k>=1;k--)
		for(int i=1;i<=n;i++)
			if(f[i][k])
			{
				if (i>k)
				{
					for(int j=1;j<k;j++)
						f[i][j]=max(f[i][j],min(f[i][k],f[k][j]));
				}
				else
				{
					for(int j=1;j<=n;j++) 
						f[i][j]=max(f[i][j],min(f[i][k],f[k][j]));
				}
			}
	for (int i=1;i<=n;i++)
		for (int j=i+1;j<=n;j++)
			g[min(f[i][j],f[j][i])]++;
	ans[m+1]=n;
	for(int i=m;i>=1;i--)
		ans[i]=ans[i+1]+g[i];
	for(int i=1;i<=m+1;i++)
		printf("%d ",ans[i]);
	return 0;
}
```


---

## 作者：C　C　A (赞：5)

首先考虑分析 $f(u, G)$，可以观察出一些性质 ：

- 会产生贡献的 $v$ 必须满足 $v < u.$

- $v$ 与 $u$ 会产生贡献当且仅当 $u$ 和 $v$ 可以仅通过大于 $v$ 的点互达。

> $\rm Proof ：$
>
> - 当 $v > u$ 时 $u$ 自己都已经删掉了，肯定不能产生贡献。
> - ![](https://s1.ax1x.com/2022/03/06/bDTc79.png)
>
> 如上图所示，我们不妨设 $u \to v$ 的路径上必须经过 $x(x < u)$，那么 $x$ 和 $u$ 一定相互可达，$x$ 会在统计 $v$ 的答案之前被删掉。

于是我们可以发现，若定义两点 $(u, v)$ 有贡献当且仅当 $u > v$ 且 $u$ 和 $v$ 之间可以通过大于 $v$ 的点相互到达，则 $h(G)$ 就是在求解 $G$ 中所有点对的贡献之和。

我们考虑 $\rm Floyd$ 算法的过程，实际上就是在不断求解如果只经过当前已经枚举的这些中转点 $k$，有哪些 $u$ 可以走到 $v.$ 于是求解 $h(G)$ 只需要从大到小枚举中转点 $k$，并在 $\rm Floyd$ 的过程中记录下当前 $v = k - 1$ 的答案即可。

进一步观察发现，如果我们按照编号从大到小将边加入图 $G$，那么必然可以找到一个分界点，使得 $u$ 和 $v$ 恰好变为有贡献的点对。容易发现，这个分界点就是 $u$ 和 $v$ 可以相互到达的路径上编号最小的边的最大值。求解这个最大值是简单的，只需要将初始矩阵修改成边的编号，方程改写为 $f_{u, v} = \max\{f_{u, v}, \min\{f_{u, k}, f_{k, v}\}\}$ 即可。

最后用差分维护一下就可以得到最终答案。

时间复杂度 $\Theta(n ^ 3 + m)$，常数很小，写得好的话可以通过。

---

为了进一步优化复杂度，我们摈弃之前使用 $\rm Floyd$ 的想法。

考虑按编号从大到小枚举所有的边，可以发现每对点 $(u, v)(u > v)$ 都会有一个成为有贡献的点对的分界点。

首先计算 $v$ 可以到达 $u$ 的分界点， $u$ 到 $v$ 的分界点可以通过在反图上进行同样的操作来计算。

有两个显然的性质 ：

- 有贡献的点对数量最多 $n ^ 2$ 量级。
- 在加边的过程中有贡献的点对数量不减。

于是考虑计算每条边加入后有贡献的点对的增量。

![brP9Ds.png](https://s1.ax1x.com/2022/03/06/brP9Ds.png)

如上图所示，设当前加入的边为 $x \to y$，$u_1, u_2, u_3, \cdots $ 和 $v_1, v_2, v_3, \cdots$ 分别为能到达 $x$ 的点和 $y$ 能到的点。

考虑用 $\rm bitset$ 记录某个点能直接到达的所有点，能到达的所有点和能到达这个点的所有点，不妨分别设它们为 $E_u, S_u$ 和 $T_u.$

可以发现，若点对 $(u, v)$ 因 $x \to y$ 而增加，需要满足 ：

- $u$ 在加入 $x \to y$ 之前不能到达 $y.$
- $u$ 在加入 $x \to y$ 之前要能到达 $x.$
- 路径上所有点的编号都不小于 $u.$

首先前两个条件可以通过 $T_x \cap (U - T_y)$ 简单地得到，考虑枚举集合中的所有点作为 $u$ 从 $y$ 开始遍历。遍历的过程中，每一步要将 $E_v \cap (U - S_u)$ 中所有编号大于 $u$ 的点作为下一个遍历的点。另外，还要记得随时更新 $S_u.$

考虑这样做的复杂度为什么是对的。因为每一步都会走到一个合法的 $v$，所以答案每一步会增加 $1.$ 并且每走一步都需要计算 $E_v \cap (U - S_u)$，其时间复杂度为 $\Theta(\frac{n}{\omega}).$ 另外，每加入一条边都需要计算 $T_x \cap (U - T_y)$，其时间复杂度也为 $\Theta(\frac{n}{\omega}).$ 于是总时间复杂度为 $\Theta(\frac{n ^ 3 + nm}{\omega}).$

---

## 作者：whiteqwq (赞：5)

[P7516 [省选联考 2021 A/B 卷] 图函数](https://www.luogu.com.cn/problem/P7516)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1791148)

## 题意

给定一张$n$个点$m$条边的有向图$G$，定义函数$f(u,G)$的值为下列操作的返回值：

设$cnt=0,G'=G$，然后按$1$到$n$的顺序枚举点$v$，如果$G'$中$v$与$u$能双向到达，那么$cnt++$，并删去结点$v$，最后返回$cnt$。

定义$h(G)=\sum_{i=1}^n f(i,G)$，并定义$G_i$为图$G$删除边$1\cdots i$后的图，求出$h(G_{0\cdots n})$。

$1\leqslant n\leqslant 10^3,1\leqslant m\leqslant 2\times 10^5$。

## 分析

定义$g_{x,y}(x\leqslant y)$为$x$经过$[x,n]$的点能否到达$y$，同样设$g_{x,y}(x>y)$为$x$经过$[y,n]$的点能否到达$y$，那么对于图$G$，求的其实就是$\sum_{i\ne j}g_{i,j}\text{and}\ g_{j,i}$。

发现如果图改变需要重新处理值，这肯定会超时，因此将$g_{x,y}$中是否能到达改为删除最多的边使得能让其到达的边数（无法到达则为$0$）。

那么如果我们处理出$g_{x,y}$，我们可以求出答案的差分数组，然后前缀和就好了。

考虑类似Floyd的做法，从大到小枚举中转点$k$（这样做可以让循环到$k$时经过的点全部大于等于$k$，便于统计答案），然后对路径进行合并。

具体地，我们对于$\leqslant k$且可以经过$>k$的结点到达$k$（其实就是判断当时的$g_{i,k}$是否非零）的点$i$，枚举终点$j$，那么会存在一条$i\rightarrow k\rightarrow j$的路径，且不难发现这条路径删除的边数为$\min\{g_{i,k},g_{k,j}\}$，用这个权值更新$g_{i,j}$就好了。

同理对于$>k$且可以经过$>k$的结点到达$k$的点$i$，枚举终点$j$（这里的$j$要小于$k$，否则答案会算重。但其实算重也没关系，因为这一部分的答案已经在之前更新过了），按上面同样的方式更新答案就好了。

时间复杂度：$O(n^3+m)$。

## 代码
```
#include<stdio.h>
const int maxn=1005,maxm=200005;
int n,m;
int g[maxn][maxn],sum[maxm],ans[maxm];
inline int min(int a,int b){
	return a<b? a:b;
}
inline int max(int a,int b){
	return a>b? a:b;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		g[i][i]=m+1;
	for(int i=1;i<=m;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		g[x][y]=i;
	}
	for(int k=n;k>=1;k--){
		for(int i=k;i<=n;i++)
			sum[min(g[i][k],g[k][i])]++;
		for(int i=1;i<=k;i++)
			if(g[i][k])
				for(int j=1;j<=n;j++)
					g[i][j]=max(g[i][j],min(g[i][k],g[k][j]));
		for(int i=k+1;i<=n;i++)
			if(g[i][k])
				for(int j=1;j<k;j++)
					g[i][j]=max(g[i][j],min(g[i][k],g[k][j]));
	}
	for(int i=m;i>=1;i--)
		sum[i]+=sum[i+1];
	for(int i=1;i<=m+1;i++)
		printf("%d%c",sum[i],i==m+1? '\n':' ');
	return 0;
}
```

省选联考A卷全部题解可见：[2021省选联考A卷解题报告](https://zybuluo.com/xiaoziyao/note/1791034)

---

## 作者：SDNetFriend (赞：4)

## P7516 [省选联考 2021 A/B 卷] 图函数 题解

### 题意这里不再赘述

[P7516 [省选联考 2021 A/B 卷] 图函数](https://www.luogu.com.cn/problem/P7516)

### 性质分析

这个一大堆限制看起来相当不好搞……丢考场上去大概率 $44$ 直接走人~~然而还是比我去年省选分加起来都多~~。

简化这个问题的一个最重要的性质，即我们不需要真的去删点。举个例子，加入我们要判断 $j<i$ 时 $j$ 是否对 $i$ 产生贡献（显然 $j>i$ 的情况因为 $i$ 被删掉故不可能有贡献），我们只需判断 $j$ 只经过 $[j,n]$ 范围内的点能否和 $i$ 互通即可。

对于证明，两种情况，考虑路径中间点 $x<j$，我们要证明它一定不必须经过。

- 若 $x$ 对 $i$ 产生了贡献并删去那么显然无法经过。

- 否则 $x$ 与 $i$ 必有一个方向不连通，那假设 $j$ 会与 $i$ 互通，并且必然经过 $x$，也就是说 $x-j-i$ 会形成一个环，那么 $x$ 和 $i$ 必然互通，矛盾。

于是得证。

### 实现思路

每次都删边重跑复杂度会高到起飞，但发现了这个性质建正反图跑 BFS 似乎是 $O(nm)$ 左右的复杂度，好像很可行的样子。

但我们这里用 Floyd 来处理，我们可以发现，既然不考虑删点问题，如果把问题转化为倒着加边，那么边多的有贡献的点对集合一定包含了变少的集合。那我们可以求每一对点最早产生贡献的时刻，然后差分即可。

### 实现细节/捋一捋

我们设 $f_{i,j}$ 表示 $i$ 能够不经过编号 $<\min(i,j)$ 到达 $j$ 的最早时刻，然后直接 Floyd 即可。

可能转移时范围看起来有点迷惑，实际上那是在保证 $i,j$ 至少有一个小于 $k$。

注意 $k$ 要从大到小枚举，不同于一般的 Floyd，因为这里 $k$ 越大的可更新的范围就越大。

实现复杂度 $O(n^3+m)$

### 贴代码

```cpp
#include <bits/stdc++.h>
#define lint long long
using namespace std;
inline int read(){
	char c;int f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f=-f;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const int N=1e3+5,M=2e5+5;
int f[N][N],n,m,d[M];
int main(){
	n=read();m=read();
	for(int i=1;i<=m;++i){
		int u=read();
		f[u][read()]=i;
	}
	for(int i=1;i<=n;++i)
		f[i][i]=m+1;
	d[m+1]=n;
	for(int k=n;k>=1;--k)
		for(int i=1;i<=n;++i)if(f[i][k])
			for(int j=1;j<=(i<k?n:k-1);++j)
				f[i][j]=max(f[i][j],min(f[i][k],f[k][j]));
	for(int i=1;i<=n;++i)
		for(int j=1;j<i;++j)
			++d[min(f[i][j],f[j][i])];
	for(int i=m;i>=1;--i)
		d[i]+=d[i+1];
	for(int i=1;i<=m+1;++i)
		printf("%d ",d[i]);
	return 0;
}

```


---

## 作者：Daidly (赞：2)

先对 $h(G)$ 考虑，发现对于 $u$，只有 $v\leq u$ 能对结果造成贡献。

考虑所有数对 $(u,v)$，有贡献的条件是：

1. $v\leq u$
2. $u\to v$ 和 $v\to u$ 的路径上点都不小于 $v$

考虑反证法证明 2：若 $u,v$ 有贡献，即遍历了 $1\sim v-1$ 仍有 $u\to v$ 和 $v\to u$ 的路径，并且路径上有小于 $v$ 的点，记为 $p$。此时 $u\to p,p\to u$ 的通路存在，与之前操作不符。

即对于数对 $u\ge v$，若 $u,v$ 能通过大于 $v$ 的点互相连通，则算贡献。使用 Floyd 倒序枚举 $k$ 处理。

具体的，记 $f[i][j]$ 表示是否能从 $i$ 经过不小于 $j$ 的点到达 $j$，$g[i][j]$ 表示是否能从 $i$ 经过不小于 $i$ 的点到达 $j$。转移条件需要判断 $k$ 与 $i,j$ 的大小关系。

对于数对 $i,j$ 若 $f[i][j],g[j][i]$ 都为 $1$，则对 $h(G)$ 造成贡献。

----

对于删去一段前缀的边，我们倒序加边，还是对每一个数对考虑对 $h(G_i)$ 的贡献。

可以发现 $(i,j)$ 对 $h(G_i)$ 的贡献是一段前缀，我们只需要找到它第一次对图做贡献的位置，然后从后往前做前缀和即可。

魔改上面求 $h(G)$ 的做法，我们给每条边赋权，权值为标号，对每一对数对找出他们满足条件的路径中最小值最大的边权，这组数对在这之前的一段前缀起了贡献。

然后就做完了，时间复杂度 $O(n^3)$，但是被卡常了。

可以将 $f,g$ 两个数组改成一个，定义 $f[i][j]$ 表示 $i\to j$ 路径上只经过不小于 $\min(i,j)$ 的点。

转移时，我们固定 $k,i$ 对 $j$ 的范围进行分类讨论，若 $k\ge i$ 则无论 $i$ 是大于 $j$ 还是小于 $j$ 都可以更新，$j$ 取 $1\sim n$；否则 $j$ 只能更新到 $k$，保证 $k\ge \min(i,j)=j$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar(); 
	}
	while(c<='9'&&c>='0'){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}

void print(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)print(x/10);
	putchar(x%10^48);
}

const int N=1e3+5,M=2e5+5;
int n,m,f[N][N],g[N][N],ans[M],u,v;

inline int Min(int x,int y){return (x<y)?x:y;}
inline int Max(int x,int y){return (x>y)?x:y;}

int main(){
    n=read(),m=read();
    for(int i=1;i<=m;++i){
        u=read(),v=read();
        f[u][v]=i;
    }
    for(int i=1;i<=n;++i)f[i][i]=m+1;
    for(int k=n;k>=1;--k){
        for(int i=1;i<=n;++i){
            if(k>=i)for(int j=1;j<=n;++j)f[i][j]=Max(f[i][j],Min(f[i][k],f[k][j]));
            else for(int j=1;j<=k;++j)f[i][j]=Max(f[i][j],Min(f[i][k],f[k][j]));
        }
    }
    for(int i=1;i<=n;++i){
        for(int j=1;j<=i;++j){
            if(Min(f[i][j],f[j][i]))ans[Min(f[i][j],f[j][i])]++;
        }
    }
    for(int i=m;i>=1;--i)ans[i]+=ans[i+1];
    for(int i=1;i<=m+1;++i)cout<<ans[i]<<" ";puts("");
	return 0;
}
```

---

## 作者：pengyule (赞：2)

直接想没有思路的时候看怎么转化题意。
先手动模拟一次，发现当函数执行到 $v=u$ 时，$u$ 自己就被删掉了，所以 $cnt$ 不会变化了。同时，到 $v$ 的时候，$1\sim v-1$ 都被删了，所以只能经过 $\ge v$ 的点。所以翻译下 $f(u)$ 就是图中满足 $[u\leftrightarrow v](v),v\le u$ 的 $v$ 的个数，其中定义 $[u\leftrightarrow v]$ 表示 $u,v$ 可以通过 $\ge v$ 的点互达。（$[u\leftrightarrow u]=1$）
而所有时候我们需要的都是 $\sum f(u)$，因此 $v\le u$ 的条件可以去掉，转为求 $\sum f=\sum_{u,v} [u\leftrightarrow v](\min(u,v))$。
先考虑第一问（图完整）。观察到 $[]$ 为一种连通性关系，floyd 是用来求解此类问题的，再考虑如何解决所经点限制，floyd 有专门的一个循环来枚举所经点，当外层 `k` 从大到小枚举并在内层两个循环中加一些 `if` 就容易满足。
再考虑求出每个图，由于是边的有无影响了连通性，重要一点在于想到转化为（用 floyd）维护 **一个点能到另一个点的最早时间，即最大的 $i$ 使加入第 $[i,m]$ 条边后一个点可以到达另一个点**。

启示：
1. 有关连通性的题目可以想 floyd
2. 每次只改动一条边或类似情况，有时间轴思想、整体处理
3. 图中类似于函数的叙述，力求破译其本质

轻微卡常即可写出代码。复杂度 $O(n^3)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1005,M=2e5+5;
int n,m,f[N][N],ans[M];
inline int read(){
	register char ch=getchar();register int x=0;
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x;
}
void print(int x){
	if(x/10)print(x/10);
	putchar(x%10+48);
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++)f[i][i]=m+1;
	for(int i=1,u,v;i<=m;i++)u=read(),v=read(),f[u][v]=i;
	for(int k=n;k;k--){
		for(int i=1;i<=k;i++)
			for(int j=1;j<=n;j++){
				if(f[i][k]&&f[k][j])f[i][j]=max(f[i][j],min(f[i][k],f[k][j]));
			}
		for(int i=k+1;i<=n;i++)
			for(int j=1;j<=k;j++){
				if(f[i][k]&&f[k][j])f[i][j]=max(f[i][j],min(f[i][k],f[k][j]));
			}
	}
	for(int i=1;i<=n;i++)for(int j=i;j<=n;j++)ans[min(f[i][j],f[j][i])]++;
	for(int i=m;i;i--)ans[i]+=ans[i+1];
	for(int i=1;i<=m+1;i++)print(ans[i]),putchar(' ');
}
```

---

## 作者：intel_core (赞：2)

可能拯救我 $\text{Day1}$ 的题目，写篇题解纪念一下    
首先考虑分析题目：    
*  对答案产生贡献的 $(u,v)$ 必须满足 $v\le u$    
*  $\text{Lemma }\alpha$ 若 $(u,v)$ 对答案产生了贡献，那么 $u\to v $ 和 $v \to u$ 上的点编号都大于 $u$   

简单证一下 $\alpha$ :    
如果 $(u,v)$ 之间互相可达，那么很容易在 $G'$ 上发现包含 $u,v$ 点的环  
若环上有 $<u$ 的点，那么在考虑 $u$ 之前，这个环就将从中间断开    

所以在考虑固定的 $v$ 对答案的贡献时就可以假定编号 $<v$ 的点不存在了  

-------------------
回到原题      
明显应该离线，并把删除变成插入    
考虑点对 $(u,v)$ 在插入第几条边时能对答案产生 $+1$ 的贡献    
以 $v$ 为源点在正向图和反向图上分别跑 $\text{dijkstra}$    
处理 $u \to v$ 和 $v \to u$ 上边的编号的最小值 的最大值     
复杂度是 $O(nm\times logn)$ 的，不过我硬是手写堆卡过去了

---

## 作者：丛雨 (赞：1)

这里提供一个不同的方法

首先我们转换题意，发现若对于点v,点u可以产生贡献，则需要存在一个包含点u,v的环满足其中编号最小的点不小于点u

所以我们不难想到一个$O(nm(n+m)\log_2 m)$的算法，定义$len(V)=\sum_{x\in V}x$,即编号最小值，对于每个阶段我们算出以n个为起点的$len$的最长路，再对于两两点通过计算出的距离数组计算贡献

但是我们发现每次只会修改一条边，所以我们可以离线下来，倒着加边。

这时如果我们使用$\tt dijskra$便有些浪费，因为我们无故的使用了堆，多了个$\log$,且时间复杂度没有变化

所以这时我们使用$\tt spfa$,对于加入的边，我们直接考虑加入的边是否能松弛最长路，进行一个修改版的$\tt spfa$

由于对于以$n$个点为起点的图，总共最多松弛$n^2$次，所以总最坏时间复杂度为$O(n^3+nm)$,但实际效率好像还行，加了$\tt SLF$后勉强能过

```cpp
#include<bits/stdc++.h>
using namespace std;
# define ll long long
# define read read1<ll>()
# define Type template<typename T>
Type T read1(){
	T t=0;
	char k;
	bool v=0;
	do (k=getchar())=='-'&&(v=1);while('0'>k||k>'9');
	while('0'<=k&&k<='9')t=(t<<3)+(t<<1)+(k^'0'),k=getchar();
	return v?-t:t;
}
# define fre(k) freopen(k".in","r",stdin);freopen(k".out","w",stdout)
int s,m,ans[200005],dis[1005][1005],tot,X;
bool vis[1005][1005],vis1[1005][1005];
bool in[1005];
pair<int,int>E[200005];
vector<int>G[1005];
deque<int>q;
void dij(int n,int *d){
	q.push_back(n);
	in[n]=1;
	while(q.size()){
		int w=q.front();
		q.pop_front();in[w]=0;
		for(int i=0;i<G[w].size();++i)
			if(d[G[w][i]]<min(d[w],G[w][i])){
				d[G[w][i]]=min(d[w],G[w][i]);
				tot-=vis[X][G[w][i]]&&vis1[G[w][i]][X];
				tot-=vis1[X][G[w][i]]&&vis[G[w][i]][X];
				vis[X][G[w][i]]=d[G[w][i]]>=G[w][i];
				vis1[X][G[w][i]]=d[G[w][i]]>=X;
				tot+=vis[X][G[w][i]]&&vis1[G[w][i]][X];
				tot+=vis1[X][G[w][i]]&&vis[G[w][i]][X];
				if(!in[G[w][i]]){
					if(q.size()&&d[q.front()]<d[G[w][i]])q.push_front(G[w][i]);
					else q.push_back(G[w][i]);
					in[G[w][i]]=1;
				}
			}
	}
}
int main(){
//	fre("graph");
	s=read,m=read;
	for(int i=1;i<=m;++i){
		int u=read,v=read;
		E[i]=make_pair(u,v);
	}
	for(int T=m;~T;--T){
		if(T==m){	
			for(int i=1;i<=s;++i)
				memset(dis[i],-0x7f,sizeof(dis[i]));
			for(int i=1;i<=s;++i)dis[i][i]=i,vis[i][i]=vis1[i][i]=1;
			ans[T]=tot=s;
		}
		else ans[T]=tot;
		G[E[T].first].push_back(E[T].second);
		for(int i=1;i<=s;++i){
			if(dis[i][E[T].second]<min(dis[i][E[T].first],E[T].second)){
				X=i;int *d=dis[i];
				d[E[T].second]=min(d[E[T].first],E[T].second);
				tot-=vis[i][E[T].second]&&vis1[E[T].second][X];
				tot-=vis1[X][E[T].second]&&vis[E[T].second][X];
				vis[X][E[T].second]=d[E[T].second]>=E[T].second;
				vis1[X][E[T].second]=d[E[T].second]>=X;
				tot+=vis[X][E[T].second]&&vis1[E[T].second][X];
				tot+=vis1[X][E[T].second]&&vis[E[T].second][X];
				dij(E[T].second,dis[i]);
			}
		}
	}for(int i=0;i<=m;++i)printf("%d ",ans[i]);
	return 0;
}

```

---

## 作者：ncwzdlsd (赞：0)

DP。

函数 $f(u,G)$ 也可表示为对于 $[1,u]$ 范围内的点，满足与 $u$ 双联通的点对数。

一个点对 $(u,v)$ 对答案有贡献，当且仅当路径 $u\rightarrow v$ 和 $v\rightarrow u$ 不经过区间 $[1,v)$ 范围内的点。

> 证明：如果存在 $[1,v)$ 范围内的点 $p$，那么 $p$ 一定与 $u$ 双联通，那么一定会被删去，矛盾。

删边操作不易进行，考虑倒序枚举。加边操作之后，有贡献的点对数不减。

设计状态 $f(i,j)$ 表示 $i$ 能不经过 $[1,i)$ 内的点到达 $j$ 的最早时刻。

按照编号从大到小加入边，一定可以找到一个分界点使得 $(u,v)$ 恰好变为有贡献的点对，分界点即为 $u,v$ 中所有互联边中编号最小的边的最大值。

状态转移：
$$
f(i,j)=\max(f(i,j),\min(f(i,k),f(k,j)))
$$
答案差分维护即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int maxn=1005,maxm=2e5+5;
ll f[maxn][maxn],g[maxm],ans[maxm];

inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}


signed main()
{
	int n=read(),m=read();
	for(int i=1,u,v;i<=m;++i) u=read(),v=read(),f[u][v]=i;
	for(int k=n;k>=1;--k)
	{
		for(int i=k+1;i<=n;++i) g[min(f[i][k],f[k][i])]++;
		for(int i=1;i<=k;++i)
			for(int j=i;j<=n;++j)
				f[i][j]=max(f[i][j],min(f[i][k],f[k][j])),f[j][i]=max(f[j][i],min(f[j][k],f[k][i]));
	}
	ans[m+1]=n;
	for(int i=m;i>=1;i--) ans[i]=ans[i+1]+g[i];
	for(int i=1;i<=m+1;i++) cout<<ans[i]<<' ';
	return 0;
}
```



---

## 作者：dAniel_lele (赞：0)

考虑计算整个图的。

对于一对点对 $(i,j)$，最多有给 $h$ 函数有 $1$ 的贡献，不妨设 $i<j$。

考虑何时才会有贡献，不难发现经过当且仅当在 $i\leq u,v\leq n$ 之间的边 $i,j$ 可以互相到达时才能有贡献。这样就可以 $O(n^3)$ 计算全局的。

需要对每个边集后缀计算答案。维护 $i,j$ 在运用目前的边能到达情况下最小边的最大值，维护之后后缀和计算即可。复杂度 $O(n^3+m)$。

```cpp
#include <bits/stdc++.h>
#define max(i,j) ((i>j)?i:j)
#define min(i,j) ((i<j)?i:j)
using namespace std;
int f[1005][1005],ans[1000005];
signed main(){
    ios::sync_with_stdio(false);
	memset(f,-1,sizeof(f));
	int n,m; cin>>n>>m;
	for(int i=1;i<=n;i++) f[i][i]=m+1;
	for(int i=1;i<=m;i++){
		int u,v; cin>>u>>v;
		f[u][v]=i;
	}
	for(int i=n;i>=1;i--){
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++){
				f[j][k]=max(f[j][k],min(f[j][i],f[i][k]));
			}
		}
		for(int j=i;j<=n;j++){
			int p=min(f[i][j],f[j][i]);
			if(p>=1){
				ans[p-1]++;
			}
		}
	}
	for(int i=m;i>=0;i--) ans[i]+=ans[i+1];
	for(int i=0;i<=m;i++) cout<<ans[i]<<" ";
	return 0;
}

```

---


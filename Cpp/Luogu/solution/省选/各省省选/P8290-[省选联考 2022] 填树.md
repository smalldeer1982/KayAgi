# [省选联考 2022] 填树

## 题目背景

原题时限为 2s。

## 题目描述

有一棵 $n$ 个节点的无根树，刚开始树上每个节点的权值均为 $0$。KK 想对这棵树进行一些修改，他会任选一个节点作为初始的当前节点，然后重复以下动作：

1. 将当前节点 $i$ 的权值修改为一个**正整数** $x$，需满足 $l_i \leq x \leq r_i$。其中 $l_i, r_i$ 是输入中给出的两个正整数。
2. 结束修改过程，或移动到一个与当前节点相邻的权值为 $0$ 的节点（如果不存在这样的节点，则必须结束修改过程）。

现在 KK 有两个问题：

1. 在修改结束后，可以得到多少棵不同的树，满足树上**非零权值**的最大值和最小值的差小于等于 $K$？其中 $K$ 是输入中给出的一个正整数。

2. 这些满足条件的树的权值之和为多少？（树的权值定义为这棵树上所有节点的权值之和）

你需要输出这两个问题的答案模 $10^9 + 7$。我们认为两棵树不同当且仅当至少存在一个节点的权值不同。

温馨提示：

1. KK 至少会修改一个节点（初始节点）。
2. 实质上 KK 会修改树上的任意一条路径，最后需要满足这条路径上的点的权值最大值和最小值之差小于等于 $K$。

## 说明/提示

**【样例解释 #1】**

| | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ | $9$ | $10$ | $11$ | $12$ | $13$ | $14$ |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 节点 $1$ | $2$ | $3$ | $2$ | $3$ | $3$ | $3$ | $3$ | $3$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |
| 节点 $2$ | $0$ | $0$ | $3$ | $3$ | $4$ | $0$ | $4$ | $3$ | $3$ | $4$ | $5$ | $0$ | $0$ | $0$ |
| 节点 $3$ | $0$ | $0$ | $0$ | $0$ | $0$ | $4$ | $4$ | $4$ | $0$ | $0$ | $0$ | $4$ | $5$ | $6$ |

表格中列出了全部 $14$ 棵满足条件的树，将这些树的权值加起来为 $78$。

**【数据范围】**

对于 $100\%$ 的数据，$1 \leq n \leq 200$，$1 \leq l_i \leq r_i \leq {10}^9$，$1 \leq K \leq {10}^9$。

| 测试点 | $n \leq $ | $r_i, K \leq$ | 其他限制 |
|:-:|:-:|:-:|:-:|
| $1$ | $5$ | $10$ | 无 |
| $2$ | $30$ | $10^9$ | 无 |
| $3$ | $30$ | $10^9$ | 无 |
| $4$ | $30$ | $500$ | 无 |
| $5$ | $200$ | $200000$ | 无 |
| $6$ | $200$ | $200000$ | 无 |
| $7$ | $200$ | $10^9$ | A |
| $8$ | $200$ | $10^9$ | A |
| $9$ | $200$ | $10^9$ | 无 |
| $10$ | $200$ | $10^9$ | 无 |

特殊限制 A：所有点构成一条链, 编号为 $i$ 的点和编号为 $i + 1$ 的点之间有连边

**【评分方式】**

本题共 $10$ 个测试点，每个测试点 $10$ 分。其中回答正确第一问可得 $7$ 分，回答正确第二问可得 $3$ 分。

## 样例 #1

### 输入

```
3 1
2 3
3 5
4 6
1 2
1 3
```

### 输出

```
14
78
```

## 样例 #2

### 输入

```
见附件中的 tree/tree2.in```

### 输出

```
见附件中的 tree/tree2.ans```

## 样例 #3

### 输入

```
见附件中的 tree/tree3.in```

### 输出

```
见附件中的 tree/tree3.ans```

# 题解

## 作者：WeLikeStudying (赞：49)

- 对自身的问题有了新的体会。
- 我应该做纯粹的学习者，不要总想着他人具有的优势，应该真诚地热爱，享受学习。
- 感谢[大佬](https://www.luogu.com.cn/user/52881)的指导，祝愿其信息学之路光芒璀璨。

**题意**
- [题目链接](https://www.luogu.com.cn/problem/P8290)。
- 给你一棵树，每个点要么权值为 $0$，要么权值是 $[l_u,r_u]$ 之间的正整数，你可以选择上面的任意一条链使得它的权值不为 $0$。
- 求所有可能的，满足内部非 $0$ 权值极差不超过 $k$ 的树的方案数和权值和。

**暴力**
- 嗯……先想简单的暴力……然后发现只有枚举的暴力，瞬间意识到了事情的严重性。
- 我们尝试枚举非 $0$ 的节点的最小值，然后对应有一个较大值的上限，但存在一个问题：我们需要让至少一个非 $0$ 节点取到最小值。
- 尝试容斥，我们可以快速地解决求非 $0$ 点权在 $[l,r]$ 之间的方案数（此时每个节点能取的范围就是 $[l_u,r_u]$ 与 $[l,r]$ 的交），所以我们用 $[l,r]$ 的方案数减去 $[l+1,r]$ 的方案数，就可以得到取到最小值的情况，然后设值域为 $w$，我们（如果不换根采用最朴素的树上动态规划）得到了 $O(n^2w)$ 的优秀（？）复杂度，[代码](https://www.luogu.com.cn/paste/rcillic2)，容易将这个相当暴力的算法优化成 $O(nw)$，[代码](https://www.luogu.com.cn/paste/3hjat8do)。
- 你当时会觉得这很有前途吗，反正我当时并不觉得，但是实在没有其它东西可以推了啊，硬着头皮想下去吧。

**分析**
- 嗯……根据数据范围猜测复杂度是个好习惯，我们合理猜测最后的复杂度是 $O(n^3)$ 或者 $O(n^4)$。
- 接下来怎么做呢？我们先把问题进行一些简化与归纳。
- 我们计算的是这样一些 $[l,l+K]$ 的问题，需要树取到最小值 $l$ 而且非 $0$ 权值在这个区间内。
- 匀速滑动这个窗口，设 $x$ 为区间的某个左右端点位置，我们发现当 $l_i=x,l_i+1=x,l_i+K=x$ 三者都不发生的时候，所有点的权值都在做均匀连续的变化，要么减一，要么不变，要么加一，更确切地，有 $O(n)$ 段这样连续的变化。
- 让我们考虑最简单的情况：一条链的第一问，将区间长度抽象成点，我们要求所有子区间的点权乘积和，将点权表示成一次函数的形式，我们猛然发现我们要求的就是一个 $n$ 次多项式，可以插值求它的前缀和（别笑，我卡在这里了）。
- 那么对于一般的情况呢？我们发现它也是一个多项式，对于第一问，它的次数最高为 $n+1$，对于第二问，它的次数最高可能达到 $2n+1$，但这最多只是常数有点大而已，我们只需要使用拉格朗日插值即可在 $O(n^3)$ 的复杂度内计算了。
- 我一开始想偏了，想要直接通过动态规划求出这个多项式，但是显然不好做，这个插值应该才是简洁的实现。

**实现**
- 你知道作者推到这一步忽然发现自己忘记拉格朗日插值的形式的痛苦吗！所以作者进行了手推拉格朗日插值的尝试：
- 构造 $n$ 个 $n-1$ 次多项式，让第 $i$ 个多项式 $f_i(x)$ 当 $x=x_i$ 的时候为 $y_i$，$x=x_j$ 且 $j\ne i$ 时为 $0$，显然：
$$f_i(x)=y_i\prod_{j\ne i}\frac{x-x_j}{x_i-x_j}$$
- 所以最终我们就得到了多项式的表达式（这下应该不会忘记了）：
$$f(x)=\sum_{i}y_i\prod_{j\ne i}\frac{x-x_j}{x_i-x_j}$$
- 最后：多项式的最高次数其实是 $n+2$，因为第一个问题总是不超过 $n$ 个式子的乘积和，是 $n$ 次式，第二个式子，单独考虑某个节点的出现次数，是二次式乘上不超过 $n-1$ 个式子的一次式，由于最终表示成前缀和的形式，所以次数要高一次，即 $n+2$ 次，可以利用它卡常。
- [代码实现](https://www.luogu.com.cn/paste/yg5eyspt)。
- 最后，稍微提一下一种做法：其实可以不用拉格朗日插值的，虽然代码会稍微长一点，但是可以用树上背包来求出这个多项式具体的值然后用第二类斯特林数求其前缀和，它的复杂度也是 $O(n^3)$ 的，但不论是树上高复杂度动态规划自带最多 $1/2$ 的常数，还是几乎卡不满的多项式次数，都会使得这个做法的常数比拉格朗日插值小很多，而且由于反着想并不容易，它才是考场上大多数人能够写出来的做法。

---

## 作者：Renshey (赞：23)

#### 题解

发现无论如何都绕不开值域的限制，因此考虑钦定范围 $[w,w+K]$，注意到 $[w+1,w+K]$ 范围内的会多算一次，多做一遍去重即可。考虑 $[w,w+K]$ 范围内的答案如何计算，发现需要计算的即为树上所有链的权值之和，不难通过树形 dp $O(n)$ 计算得出。

钦定范围后，每个点可选的值域区间为 $[\max(l_i,w),\min(r_i,w+K)]$，不难想到拆 $\min/\max$。根据 $w,w+K,l_i,r_i$ 的大小关系可以拆成 $O(n)$ 段，考虑每段内每个点取值的形式。

方案数显然是关于 $w$ 的一次多项式，权值是关于 $w$ 的二次多项式。求和后链方案数是 $n$ 次多项式，权值和是 $n+1$ 次的。

直接分段维护多项式/拉格朗日插值即可。

时间复杂度 $O(n^3)$，空间复杂度 $O(n)$。

#### 代码

```cpp
#include <bits/stdc++.h>
const int mod = 1000000007;
int n, K, l[300], r[300], f[300], g[300], a[1000], m, d1[300], d2[300];
int pre[600], suf[600], Y1[600], Y2[600], inv[600], sgn[2], ans1, ans2;
std::vector<int> e[300];
inline void dp (int u, int fr, int L, int R)
{
	f[u] = g[u] = d1[u] = d2[u] = 0;
	int ql = std::max(L, l[u]), qr = std::min(R, r[u]);
	int cntu = (ql <= qr) ? (qr - ql + 1) : 0;
	int sumu = (ql <= qr) ? 1LL * (ql + qr) * (qr - ql + 1) / 2 % mod : 0;
	f[u] = d1[u] = cntu; g[u] = d2[u] = sumu;
	for (int v : e[u]) if (v != fr)
	{
		dp(v, u, L, R); (f[u] += f[v]) %= mod; (g[u] += g[v]) %= mod;
		g[u] = (g[u] + 1LL * d2[u] * d1[v] + 1LL * d1[u] * d2[v]) % mod;
		d2[u] = (d2[u] + 1LL * d2[v] * cntu + 1LL * d1[v] * sumu) % mod;
		f[u] = (f[u] + 1LL * d1[u] * d1[v]) % mod;
		d1[u] = (d1[u] + 1LL * d1[v] * cntu) % mod;
	}
}
inline int Inv (int x) {return x < 0 ? mod - inv[-x] : inv[x];}
signed main ()
{
	scanf("%d%d", &n, &K);
	for (int i = 1; i <= n; i++) scanf("%d%d", &l[i], &r[i]);
	for (int i = 1, u, v; i < n; i++) scanf("%d%d", &u, &v), e[u].push_back(v), e[v].push_back(u);
	inv[0] = inv[1] = sgn[0] = 1; sgn[1] = mod - 1;
	for (int i = 2; i <= n + 5; i++) inv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod;
	for (int i = 3; i <= n + 5; i++) inv[i] = 1LL * inv[i - 1] * inv[i] % mod;
	for (int i = 1; i <= n; i++)
	{
		a[++m] = l[i]; a[++m] = r[i];
		if (l[i] > K) a[++m] = l[i] - K;
		if (r[i] > K) a[++m] = r[i] - K;
	}
	a[++m] = 1; a[++m] = 1000000001;
	std::sort(a + 1, a + m + 1); m = std::unique(a + 1, a + m + 1) - a - 1;
	for (int i = 1; i < m; i++)
	{
		int k = std::min(a[i + 1] - a[i], n + 5);
		for (int j = 1; j <= k; j++) dp(1, 0, a[i] + j - 1, a[i] + j + K - 1), Y1[j] = f[1], Y2[j] = g[1];
		for (int j = 1; j <= k; j++) (Y1[j] += Y1[j - 1]) %= mod, (Y2[j] += Y2[j - 1]) %= mod;
		int x = a[i + 1] - a[i]; pre[0] = suf[k + 1] = 1;
		for (int j = 1; j <= k; j++) pre[j] = 1LL * pre[j - 1] * (x - j + mod) % mod;
		for (int j = k; j >= 1; j--) suf[j] = 1LL * suf[j + 1] * (x - j + mod) % mod;
		for (int j = 1; j <= k; j++)
		{
			int res = 1LL * pre[j - 1] * suf[j + 1] % mod * inv[j - 1] % mod * inv[k - j] % mod * sgn[(k - j) & 1] % mod;
			ans1 = (ans1 + 1LL * res * Y1[j]) % mod; ans2 = (ans2 + 1LL * res * Y2[j]) % mod;
		}
	}
	m = 0;
	for (int i = 1; i <= n; i++)
	{
		if (l[i] > 1) a[++m] = l[i];
		if (r[i] > 1) a[++m] = r[i];
		if (l[i] > K) a[++m] = l[i] - K + 1;
		if (r[i] > K) a[++m] = r[i] - K + 1;
	}
	a[++m] = 2; a[++m] = 1000000001;
	std::sort(a + 1, a + m + 1); m = std::unique(a + 1, a + m + 1) - a - 1;
	for (int i = 1; i < m; i++)
	{
		int k = std::min(a[i + 1] - a[i], n + 5);
		for (int j = 1; j <= k; j++) dp(1, 0, a[i] + j - 1, a[i] + j + K - 2), Y1[j] = f[1], Y2[j] = g[1];
		for (int j = 1; j <= k; j++) (Y1[j] += Y1[j - 1]) %= mod, (Y2[j] += Y2[j - 1]) %= mod;
		int x = a[i + 1] - a[i]; pre[0] = suf[k + 1] = 1;
		for (int j = 1; j <= k; j++) pre[j] = 1LL * pre[j - 1] * (x - j + mod) % mod;
		for (int j = k; j >= 1; j--) suf[j] = 1LL * suf[j + 1] * (x - j + mod) % mod;
		for (int j = 1; j <= k; j++)
		{
			int res = 1LL * pre[j - 1] * suf[j + 1] % mod * inv[j - 1] % mod * inv[k - j] % mod * sgn[(k - j) & 1] % mod;
			ans1 = (ans1 - 1LL * res * Y1[j] % mod + mod) % mod; ans2 = (ans2 - 1LL * res * Y2[j] % mod + mod) % mod;
		}
	}
	return !printf("%d\n%d\n", ans1, ans2);
}
```

---

## 作者：小木虫 (赞：14)

### Preface  
希望这篇题解能够帮助和我一样的计数蒟蒻。  
### Problem  
给你一棵 $n$ 个节点的树，每个点 $i$ 可以填一个 $[l_i,r_i]$ 以内的权值，也可以不填，现在我们要填一条树上路径，要求这条路径上的权值极差在 $k$ 以内，问有多少种方案以及所有方案的权值和为多少。  
$1\leq n \leq 200,1\leq l_i\leq r_i,k,r_i\leq 10^9$。  

### Solution  

**算法1（10pts）：**  

我们发现我们可以爆枚每一个节点的权值，然后判断合法，这样可以通过第一个测试点，期望得分 10 分。  

**算法2（20pts）**  

我们发现这个问题应当是可以 dp 的，但是无法绕开权值的限制，那我们就先依赖权值写一个 dp，我们暴力枚举我们要选的路径的最小值 $x$，那么每个点的合法点权就在 $[x,x+k]$ 内，然后进行树上 dp，发现我们还需要钦定某些点为最小值，不然会算出某些最小值大于 $x$ 的答案，但如果直接钦定的话我们的复杂度又会退化为爆搜，正难则反，考虑删掉最小值大于 $x$ 的答案，即合法点权在 $[x+1,x+k]$ 内的方案，这部分直接动规掉就好，然后我们获得了一个复杂度 $O(nV)$ 的算法，期望得分 20 分。  

这部分的动规可能要进行一些介绍，我认为还是不算送分的。  
设 $dp1_u$ 为 $u$ 子树内的总方案数，$cdp1_u$ 为 $u$ 子树内，且填的数形成一条以 $u$ 为一个端点的链的总方案数，$dp2_u$ 为 $u$ 子树内的总权值和，$cdp2_u$ 同理。  

先来写较为简单的部分：  

设 $w$ 为节点 $u$ 上的合法区间大小，$left$ 为合法区间的左端点，$right$ 为右端点，依照上文可知 $[left,right]=[x,x+k]\cap [l_u,r_u]$。


$$cdp1_u=w+\sum_{v\in son_u}cdp1_v\times w$$  
$$
\begin{array}{rcl}
cdp2_u&=&(\frac{w\times(w+1)}{w}+(left-1)\times w)\\
&+&\sum_{v\in son_u}cdp2_v\times w\\
&+&(\frac{w\times(w+1)}{2}+(left-1)\times w)\times cdp1_v
\end{array}
$$

其中第一个柿子较好理解，第二个柿子就是把点 $u$ 的贡献与 $v$ 子树的贡献分开计算了，前面都要加一个柿子是因为可以从该点开始。  

接下来我们来看较难的部分：  

$$dp1_u=w+\sum_{v\in son_u}(1+\sum_{pre} cdp1_{pre})\times cdp1_v \times w$$  

$$
\begin{array}{rcl}
dp2_u&=&(\frac{w\times(w+1)}{2}+(left-1)\times w)\\
&+&\sum_{v\in son_u}(1+\sum_{pre} cdp1_{pre})(cdp2_v\cdot w+ (\frac{w(w+1)}{2}+w(left-1))\cdot cdp1_v)\\
&+&(\sum_{pre} cdp2_{pre})\times cdp1_v \times w
\end{array}
$$

$pre$ 代表之前枚举过的 $v$。  

第一个柿子同样较好理解，就是将两个链的贡献拼在了一起，乘上了节点本身的贡献。  

第二个柿子要分成三部分理解，第一部分为计算 $v$ 子树内向上的贡献，第二部分计算 $u$ 本身的贡献，第三部分计算之前的 $v$ 对现在 $v$ 的贡献。  

容易发现内层求和符号可以被前缀和优化，然后单次 dp 即为线性。

**算法3（100pts）**  
发现这个问题中的权值不能采用常规手段简单地消去，于是我们转而关注这个问题本身的性质。  

经过手玩 $[x,x+k]$ 的滑动窗口，我们发现大部分时候所有的 $[left,right]$ 都在平滑地移动，即左端点或右端点变化 1，而在 $O(n)$ 个关键点处会有一些转折和改变，即变化的端点变化，变化的正负性变化。  

这意味着什么？  

段数很少，所以我们首先关注一下段内的情况。  
树上问题不好分析，所以我们先简化问题，只关注选一条链的情况。 


算法 2 中的 dp 在一个链上，如果强制去选这个链的全部的话其实计算出方案数的就是：  

$$\prod_{i=1}^{n}(right-left+1)$$  
而权值和即为：  
$$\sum_{i=1}^n (\frac{w\times(w+1)}{2}+(left-1)\times w)\times (\prod_{j\neq i}^n (right-left+1))$$  

发现 $x$ 在段内滑动时，$(right-left+1)$ 为关于 $x$ 的一次函数，$(\frac{w\times(w+1)}{2}+(left-1)\times w)$ 为关于 $x$ 的二次函数。  

那么前面两个柿子即为关于 $x$ 的 $n$ 次多项式和关于 $x$ 的 $n+1$ 次多项式。  

推广回树上，由于是累加起来的，所以不影响次数，故两个答案依旧分别为对应次数的多项式。  

我们发现在每一段内答案都是多项式，我们想求的是每一段内答案的总和，即前缀和的最后一个，而 $m$ 次多项式的前缀和为 $m+1$ 次多项式，那么我们先在每一段内找前 $n+3$ 个点进行暴力 dp 的计算，把他们做前缀和，我们就获得了在一段内答案的前缀和函数的 $n+3$ 个点值，应用拉格朗日插值法我们可以获得这个函数在任意点的取值，也就能获得段内答案总和，复杂度 $O(n)$。  

最终总体复杂度 $O(n^3)$，瓶颈在于暴力求点值。  

code：  
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=205;
const int mod=1e9+7;
int n,l[N],r[N],k,num[N*4],tot;
int f[N],g[N],u,v;
vector <int> edge[N];
namespace DP{
	int dp1[N],cdp1[N],dp2[N],cdp2[N],vis[N];
	bool dfs(int u,int fa,int L,int R){
		int left=max(L,l[u]);
		int right=min(R,r[u]);
		if(left>right)return false;
		vis[u]=1;int w=right-left+1;
		dp1[u]=cdp1[u]=w;
		dp2[u]=cdp2[u]=(w*(w+1)/2+(left-1)*w)%mod;
		int sum1=1,sum2=0;
		for(auto v:edge[u]){
			if(v==fa)continue;
			if(!dfs(v,u,L,R))continue;
			cdp1[u]+=cdp1[v]*w;
			cdp2[u]+=cdp2[v]*w%mod+(w*(w+1)/2+(left-1)*w)%mod*cdp1[v]%mod;
			cdp1[u]%=mod;cdp2[u]%=mod;
			dp1[u]+=(sum1*cdp1[v]%mod)*w%mod;
			dp2[u]+=(cdp2[v]*sum1%mod*w%mod+(w*(w+1)/2+(left-1)*w)%mod*sum1%mod*cdp1[v]%mod+sum2*w%mod*cdp1[v]%mod)%mod;
			sum1+=cdp1[v];sum1%=mod;
			sum2+=cdp2[v];sum2%=mod;
			dp1[u]+=dp1[v];dp2[u]+=dp2[v];
			dp1[u]%=mod;dp2[u]%=mod;
		}
		return true;
	}
	pair <int,int> solve(int L,int R){
		memset(vis,0,sizeof(vis));
		int tmp1=0,tmp2=0;
		for(int i=1;i<=n;i++){
			if(!vis[i]&&(dfs(i,0,L+1,R))){
				tmp1+=dp1[i];tmp2+=dp2[i];
				tmp1%=mod;tmp2%=mod;
			}
		}
		memset(vis,0,sizeof(vis));
		int sum1=0,sum2=0;
		for(int i=1;i<=n;i++){
			if(!vis[i]&&(dfs(i,0,L,R))){
				sum1+=dp1[i];sum2+=dp2[i];
				sum1%=mod;sum2%=mod;
			}
		}
		return make_pair((sum1-tmp1+mod)%mod,(sum2-tmp2+mod)%mod);
	}
}
int pre[N],suf[N],fac[N],inv[N];
int qpow(int a,int b){
	a%=mod;int res=1;
	while(b){
		if(b&1)res=(1ll*res*a)%mod;
		b>>=1;a=(1ll*a*a)%mod;
	}return res;
}
int Lag(vector <int> &y,int k){
	int res=0,sz=y.size()-1;
	if(k<=sz)return y[k];
	fac[0]=1;pre[0]=k,suf[sz]=(k-sz+mod)%mod;
	for(int i=1;i<=sz;i++){
		fac[i]=fac[i-1]*i%mod;
		pre[i]=(pre[i-1]*(k-i)%mod+mod)%mod;
	}
	inv[sz]=qpow(fac[sz],mod-2);
	for(int i=sz-1;i>=0;i--)
		inv[i]=(inv[i+1]*(i+1))%mod;
	for(int i=sz-1;i>=0;i--)
		suf[i]=(suf[i+1]*(k-i)%mod+mod)%mod;
	int neg=0;
	for(int i=0;i<=sz;i++){
		int t=y[i];
		t*=((i>0?pre[i-1]:1)*(i<sz?suf[i+1]:1)%mod);t%=mod;
		t*=(inv[i]*inv[sz-i]%mod);t%=mod;
		if((sz-i)&1)res+=mod-t,res%=mod;
		else res+=t,res%=mod;
	}
	return res;
}
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	//freopen("tree3.in","r",stdin);
	cin>>n>>k;int maxV=0;
	for(int i=1;i<=n;i++)
		cin>>l[i]>>r[i],maxV=max(maxV,r[i]);
	for(int i=1;i<n;i++){
		cin>>u>>v;
		edge[u].push_back(v);
		edge[v].push_back(u);
	}
	num[++tot]=1;
	num[++tot]=maxV+1;
	for(int i=1;i<=n;i++){
		num[++tot]=l[i];
		if(r[i]<1e9)num[++tot]=r[i]+1;
		if(l[i]>k)
			num[++tot]=l[i]-k;
		if(r[i]>=k)
			num[++tot]=r[i]-k+1;
	}
	sort(num+1,num+1+tot);
	int sz=unique(num+1,num+1+tot)-num-1;
	int res1=0,res2=0;
	for(int i=1;i<sz;i++){
		for(int x=num[i];x<num[i]+n+3;x++){
			pair <int,int> val=DP::solve(x,x+k);
			f[x-num[i]]=val.first;
			g[x-num[i]]=val.second;
		}
		for(int j=1;j<n+3;j++)
			f[j]=(f[j]+f[j-1])%mod,g[j]=(g[j]+g[j-1])%mod;
		vector <int> y;
		for(int j=0;j<n+3;j++)
			y.push_back(f[j]);
		res1+=Lag(y,num[i+1]-1-num[i]);
		res1%=mod;y.clear();
		for(int j=0;j<n+3;j++)
			y.push_back(g[j]);
		res2+=Lag(y,num[i+1]-1-num[i]);
		res2%=mod;y.clear();
	}
	cout<<res1<<"\n"<<res2<<"\n"; 
	return 0;
}


```

---

## 作者：HikariS (赞：11)

> Q：这个高三菜鸡怎么又在摸鱼啊  
> ~~A：我保证这是我高考前最后一次摸鱼了，一定是的（flag）~~

看到学弟在暴切D2T3，深感技不如人。。  
说来也巧，我在省选前几天睡觉时忽然梦到自己在考NOI，而且有一道题正是 [NOI2019] 机器人的改编题，然后。。  
它出现在了2022年的省选！  
善良的出题人在题面中已经告诉我们修改的其实是一条路径了。  
我们考虑一种简单粗暴的做法：先枚举路径里的最大值 $x$ ，那么值域就限定在了 $[x-K,x]$ ，然后就可以使用 $O(n)$ 树形 DP 解决。  
我的做法是设 $f_{u,0/1,x}$ 表示从$u$节点往下延伸的链，钦定的最大值为 $x$，是否有数字达到 $x$ 的链的个数，这样就可以在 DP 的过程中顺便统计答案。第二问的话也只需要多设一个 $g_{u,0/1,x}$ 表示链上的数字和借助 $f$ 转移。于是我们得到了 $O(n \times \max r_i)$的~~优秀~~做法。  
不妨考虑 $l_i=1,r_i=10^9$ 的情形（怎么没有这个部分分啊喂），我们发现如果令 $f_{u,0/1,x}=f_{u,0/1}(x)$ 的话发现 $f_{u,0/1}(x)$ 是一个次数为 $O(n)$ 的多项式，具体证明的话可以看到 DP 过程中每次添加一个节点相当于乘入一个次数为 $O(1)$ 的多项式。  
类似树上背包，我们可以直接暴力多项式卷积就可以做到 $O(n^2)$ ，而不必使用拉格朗日插值。最后求出答案的多项式并利用自然数幂和来解出答案~~（这不还是得用拉格朗日插值吗）~~。  
考虑 $l_i,r_i$ 任意的一般情形，我们可以借助 [APIO2016]划艇 的思路，每次将值域分段为 $[L,R]$ 使得 $[L,R]$ 与 $[L-K,R-K]$ 都是所有 $[l_i,r_i]$ 的子区间，避免转移方程在这段区间内发生变化，然后在这段值域内应用上述算法即可。显然值域段只有 $O(n)$ 个。  
时间复杂度 $O(n^3)$ 。  
那么此题可否参考 loj6289 的思路做到 $O(n^2 \log^3 n)$ 呢，我猜想是可以的（也可能是我在胡说八道），~~我们是理论计算机科学家，我们不关心常数~~。  
参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define fp(i,l,r) for(register int (i)=(l);(i)<=(r);++(i))
#define fd(i,l,r) for(register int (i)=(l);(i)>=(r);--(i))
#define fe(i,u) for(register int (i)=front[(u)];(i);(i)=e[(i)].next)
#define mem(a) memset((a),0,sizeof (a))
#define O(x) cerr<<#x<<':'<<x<<endl
#define int long long
#define poly vector<int>
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    return x*f;
}
void wr(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)wr(x/10);
	putchar('0'+x%10);
}
const int MAXN=206,mod=1e9+7,inv2=(mod+1)/2;
inline void tmod(int &x){x%=mod;}
inline void rmod(int &x){x+=x>>31&mod;}
inline int qpow(int a,int b){
	tmod(a);int res=1;
	for(;b;b>>=1,tmod(a*=a))
	if(b&1)tmod(res*=a);
	return res;
}
inline int ginv(int x){return qpow(x,mod-2);}
int front[MAXN],tcnt,n,K,A[MAXN],B[MAXN],sta[MAXN*2],top;
poly f[MAXN][2],g[MAXN][2],fw,gw;
int L,R,ans1,ans2;
struct tEdge{
	int v,next;
}e[MAXN<<1];
inline void adde(int u,int v){
	e[++tcnt]={v,front[u]};front[u]=tcnt;
}
inline void init(poly &a){a.resize(1);a[0]=0;}
inline poly operator*(const poly &a,const poly &b){
	poly tmp;tmp.resize(a.size()+b.size()-1);
	fp(i,0,a.size()-1)fp(j,0,b.size()-1)tmod(tmp[i+j]+=a[i]*b[j]);
	return tmp;
}
inline poly operator+(poly a,const poly &b){
	if(b.size()>a.size())a.resize(b.size());
	fp(i,0,b.size()-1)rmod(a[i]+=b[i]-mod);
	return a;
}
inline poly operator-(poly a,const poly &b){
	if(b.size()>a.size())a.resize(b.size());
	fp(i,0,b.size()-1)rmod(a[i]-=b[i]);
	return a;
}
inline void operator+=(poly &a,const poly &b){
	if(b.size()>a.size())a.resize(b.size());
	fp(i,0,b.size()-1)rmod(a[i]+=b[i]-mod);
}
struct sumpower{
	int f[2010],g[2010],n,K,a[2010];
	bool np[2010];int p[2010],pcnt,L[2010],R[2010];
	inline void sieve(){
		mem(np);np[0]=np[1]=1;a[1]=1;pcnt=0;
		fp(i,2,K+2){
			if(!np[i])p[++pcnt]=i,a[i]=qpow(i,K);
			for(signed j=1;j<=pcnt&&p[j]*i<=K+2;++j){
				signed t=i*p[j];np[t]=1;a[t]=a[i]*a[p[j]]%mod;
				if(i%p[j]==0)break;
			}
		}
		fp(i,1,K+2)rmod(a[i]+=a[i-1]-mod);
	}
	inline int gval(int nn,int kk){
		n=nn;K=kk;sieve();
		if(n<=K+2)return a[n];
		int fs=1,gs=1,ans=0;
		fp(i,1,K+2)tmod(fs*=i),tmod(gs*=-i);
		f[K+2]=qpow(fs,mod-2);g[K+2]=qpow(gs,mod-2);
		fd(i,K+1,0)tmod(f[i]=f[i+1]*(i+1)),tmod(g[i]=g[i+1]*(-i-1));
		L[0]=R[K+3]=1;
		fp(i,1,K+2)tmod(L[i]=L[i-1]*(n-i));fd(i,K+2,1)tmod(R[i]=R[i+1]*(n-i));
		fp(i,1,K+2)tmod(ans+=a[i]*L[i-1]%mod*R[i+1]%mod*f[i-1]%mod*g[K+2-i]);
		return (ans+mod)%mod;
	}
}S;
void dfs(int u,int fa){
	init(f[u][0]);init(f[u][1]);init(g[u][0]);init(g[u][1]);
	fe(kk,u){
		int v=e[kk].v;if(v==fa)continue;
		dfs(v,u);
	}
	if(B[u]<R-K||A[u]>R)return;
	if(B[u]>=R&&A[u]<=R-K){
		f[u][0][0]=K;f[u][1][0]=1;
		g[u][0].resize(2);g[u][0][0]=(mod-K-1)*K%mod*inv2%mod;g[u][0][1]=K;
		g[u][1].resize(2);g[u][1][1]=1;
	}
	else if(B[u]<R&&A[u]<=R-K){
		f[u][0].resize(2);f[u][0][0]=(B[u]+K+1)%mod;f[u][0][1]=mod-1;
		g[u][0].resize(2);g[u][0][0]=(B[u]-K+mod)*inv2%mod;g[u][0][1]=inv2;g[u][0]=g[u][0]*f[u][0];
	}
	else if(B[u]>=R&&A[u]>R-K){
		f[u][0].resize(2);f[u][0][0]=mod-A[u];f[u][0][1]=1;f[u][1][0]=1;
		g[u][0].resize(2);g[u][0][0]=(A[u]-1)*inv2%mod;g[u][0][1]=inv2;g[u][0]=g[u][0]*f[u][0];
		g[u][1].resize(2);g[u][1][1]=1;
	}
	else{
		f[u][0][0]=(B[u]-A[u]+1)%mod;g[u][0][0]=(B[u]-A[u]+1)*(B[u]+A[u])%mod*inv2%mod;
	}
	fw+=f[u][1];gw+=g[u][1];poly f0,f1,g0,g1;f0=f[u][0];f1=f[u][1];g0=g[u][0];g1=g[u][1];
	fe(kk,u){
		int v=e[kk].v;if(v==fa)continue;
		fw+=(f0+f1)*(f[v][0]+f[v][1])-f0*f[v][0];gw+=(g0+g1)*(f[v][0]+f[v][1])-g0*f[v][0]+(f0+f1)*(g[v][0]+g[v][1])-f0*g[v][0];
		poly t1=f[u][0]*f[v][0];f0+=t1;f1+=(f[u][0]+f[u][1])*(f[v][0]+f[v][1])-t1;
		t1=g[u][0]*f[v][0];g0+=t1;g1+=(g[u][0]+g[u][1])*(f[v][0]+f[v][1])-t1;
		t1=f[u][0]*g[v][0];g0+=t1;g1+=(f[u][0]+f[u][1])*(g[v][0]+g[v][1])-t1;
	}
	f[u][0]=f0;f[u][1]=f1;g[u][0]=g0;g[u][1]=g1;
}
inline void solve(){
	init(fw);init(gw);
	dfs(1,0);
	fp(i,0,fw.size()-1)tmod(ans1+=(S.gval(R,i)-S.gval(L-1,i)+mod)*fw[i]);
	fp(i,0,gw.size()-1)tmod(ans2+=(S.gval(R,i)-S.gval(L-1,i)+mod)*gw[i]);
}
main(){
	n=read();K=read();
	fp(i,1,n){
		A[i]=read();B[i]=read();
		sta[++top]=A[i];sta[++top]=B[i]+1;
	}
	fp(i,1,n-1){
		int x=read(),y=read();
		adde(x,y);adde(y,x);
	}
	sort(sta+1,sta+1+top);top=unique(sta+1,sta+1+top)-sta-1;
	int p1=0,p2=1;R=sta[1]-1;
	while(R<sta[top]-1){
		int r1=sta[p1+1]-1+K,r2=sta[p2+1]-1;
		if(r1<r2){
			++p1;L=R+1;R=r1;
		}
		else if(r1>r2){
			++p2;L=R+1;R=r2;
		}
		else{
			++p1;++p2;L=R+1;R=r2;
		}
		assert(L<=R);solve();
	}
	printf("%lld\n%lld\n",ans1,ans2);//是换行！不是空格！这都能错！我真的退化成弱智了！
	return 0;
}
```
> 悟已往之不谏，知来者之可追。



---

## 作者：Autre (赞：9)

这题有无聊 $O(n^2\log n)$ 做法，并且拿到了最优解。

首先将原问题弱化为，对于某个 $x$ 求所有值都在 $[x,x+K]$ 中的方案数和所有方案的权值和。这个问题可以用树 DP 在 $O(n^2)$ 的时间复杂度内简单地解决。

然后不难发现，每个点的方案数是一个关于 $x$ 的有常数段的一次分段函数。所以整棵树的方案数、权值和分别是关于 $x$ 的有 $O(n)$ 段的不超过 $n+1$ 和 $n+2$ 次的分段函数。

那么朴素的做法就是对每个段分别求出多项式在 $0,1,2,\cdots,n+1$ 处的点值表示，做前缀和（升为 $n+2$ 次），然后进行拉格朗日插值，即可求得 $x$ 取在该段内的答案。

---

如何优化到 $O(n^2\log n)$ 呢？

每个点的方案数函数只有 $O(1)$ 段，所以在计算 $x$ 在不同段中的答案时，所有点的方案数函数一共会改变 $O(n)$ 次。

所以我们用 top tree 维护答案，问题就变成 $O(n)$ 次单点修改信息，$O(n)$ 次全局查询。

具体地，我们对于每个簇维护：

- 簇路径（不包含上界点）的方案数
- 一个端点为上界点，另一个端点在簇内（不包含上界点）的所有路径的方案数之和（不算上界点的贡献）
- 一个端点为下界点，另一个端点在簇内（不包含上界点）的所有路径的方案数之和
- 一个端点为下界点，另一个端点在簇内（不包含上界点），经过上界点的所有路径的方案数之和（不算上界点的贡献）
- 两个端点在簇内（均不包含上界点），经过上界点的所有路径的方案数之和（不算上界点的贡献）
- 两个端点在簇内，不经过上界点的所有路径的方案数之和

上文中“不算上界点的贡献”意为设上界点的方案数为 $1$ 计算答案。这样可以最大限度地规避重复统计。

注意，上述六个信息均为关于 $x$ 的函数的点值表示。这样可以 $O(n)$ 地做加法和乘法。

于是两个簇可以 $O(n)$ 地 compress 或 rake。

两种合并的具体方式见代码。

```cpp
#include<algorithm>
#include<iostream>
#include<vector>
#include<queue>

const int N = 200, P = 1e9+7, T = N*2;
int n, l[N], r[N], s[N], sn[N], id[N], fc[N+2], ifc[N+2], deg, rt;
int ls[T], rs[T], f[T], w[T], bu[T], bv[T], tp[T], tt = 1;
std::vector<std::pair<int, bool>>g[N];
std::vector<std::tuple<int, int, int>>a;
void inline gm(int&x) { if (x >= P) x -= P; }
int sm(int l, int r) { return (l+r)*(r-l+P*2ll+1)/2%P; }
struct poly {
    std::vector<int>a, b;
    void init(int c=0) { a.resize(deg+1, c), b.resize(deg+1, c); }
    void fill(int x=0, int y=0) {
        std::fill_n(a.begin(), deg+1, x);
        std::fill_n(b.begin(), deg+1, y);
    }
    poly operator+(const poly&o)const{
        poly res; res.init();
        for (int i=0; i<=deg; i++) {
            gm(res.a[i] = a[i] + o.a[i]),
            gm(res.b[i] = b[i] + o.b[i]);
        }
        return res;
    }
    poly operator*(const poly&o)const{
        poly res; res.init();
        for (int i=0; i<=deg; i++)
            res.a[i] = 1ll*a[i]*o.a[i]%P,
            res.b[i] = (1ll*a[i]*o.b[i]+1ll*b[i]*o.a[i])%P;
        return res;
    }
} fp[T], fa[T], fb[T], fx[T], fy[T], fo[T];
int calc(const std::vector<int>&a, int x) {
    static int pr[N+2], sf[N+2];
    int sm = 0; *pr = sf[deg] = 1;
    for (int i=0; i<deg; i++)
        pr[i+1] = 1ll*pr[i]*(x-i+P)%P;
    for (int i=deg; i; i--)
        sf[i-1] = 1ll*sf[i]*(i-x+P)%P;
    for (int i=0; i<=deg; i++)
        sm = (sm+1ll*a[i]*pr[i]%P*sf[i]%P
            *ifc[i]%P*ifc[deg-i])%P;
    return sm;
}
void dfs(int u, int f=-1) { s[u] = 1, sn[u] = -1;
    for (auto&[v, fl] : g[u]) if (v != f) {
        dfs(v, u), fl = 1, s[u] += s[v];
        if (!~sn[u] || s[v] > s[sn[u]]) sn[u] = v;
    }
}
void inline cp(int f) {
    int u = ls[f], v = rs[f];
    fp[f] = fp[u] * fp[v];
    fa[f] = fa[u] + fp[u] * fa[v];
    fb[f] = fb[v] + fp[v] * fb[u] + fp[id[bv[u]]] * fx[v];
    fx[f] = fx[u] * fp[v];
    fy[f] = fy[u] + fx[u] * fa[v];
    fo[f] = fo[u] + fo[v] + fb[u] * fa[v] + fp[id[bv[u]]] * fy[v];
}
void inline rk(int f) {
    int u = ls[f], v = rs[f];
    fp[f] = fp[u], fb[f] = fb[u];
    fa[f] = fa[u] + fa[v];
    fx[f] = fx[u] + fp[u] * fa[v];
    fy[f] = fy[u] + fy[v] + fa[u] * fa[v];
    fo[f] = fo[u] + fo[v];
}
int mg(int u, int v, int op=0) {
    f[ls[tt] = u] = f[rs[tt] = v] = tt;
    bu[tt] = bu[u], bv[tt] = bv[op?u:v];
    tp[tt] = op, w[tt] = w[u] + w[v];
    fp[tt].init(), fa[tt].init(), fb[tt].init();
    fx[tt].init(), fy[tt].init(), fo[tt].init();
    return tt++;
}
int nw(int u, int v) {
    bu[tt] = u, bv[tt] = v, w[tt] = 1, tp[tt] = -1;
    fp[tt].init(), fa[tt].init(), fb[tt].init();
    fx[tt].init(), fy[tt].init(), fo[tt].init();
    return id[v] = tt++;
}
namespace Build {
    struct cmp{bool operator()(int x, int y){return w[x]>w[y];}};
    int o[T], p[T+1], t[T], ct;
    int dc(int l=0, int r=ct) {
        if (r - l == 1) return o[l];
        for (int i=l, k=p[l]+p[r]>>1; i<r; i++)
            if (p[i] > k) return mg(dc(l, i), dc(i, r));
        return mg(dc(l, r-1), o[r-1]);
    }
    int bd(int rt) {
        if (!~sn[rt]) return -1;
        std::priority_queue<int, std::vector<int>, cmp>q;
        for (int u=rt, x, y; ~sn[u]; u=sn[u]) {
            for (auto[v, fl] : g[u]) if (fl && v != sn[u])
                x = nw(u, v), y = bd(v), q.push(~y?mg(x, y):x);
            for (; q.size() > 1; q.push(mg(x, y, 1)))
                x = q.top(), q.pop(), y = q.top(), q.pop();
            if (t[u] = nw(u, sn[u]), q.size())
                t[u] = mg(t[u], q.top(), 1), q.pop();
        }
        for (ct=0; ~sn[rt]; rt=sn[rt], ct++)
            p[ct+1] = p[ct] + w[o[ct]=t[rt]];
        return dc();
    }
}
void sv(int k, int&sma, int&smb) {
    int lst = -1e9; sma = smb = 0;
    for (int u=0; u<tt; u++) if (~tp[u]) tp[u] ? rk(u) : cp(u);
        else fp[u].fill(), fa[u].fill(), fb[u].fill(),
            fx[u].fill(), fy[u].fill(), fo[u].fill();
    for (auto[t, p, op] : a) { int u = id[p];
        auto res = fo[rt] + (fa[rt] + fy[rt]) * *fp + *fp;
        for (int i=1; i<=deg; i++)
            gm(res.a[i] += res.a[i-1]), gm(res.b[i] += res.b[i-1]);
        sma = ((sma+calc(res.a, t))%P-calc(res.a, lst)+P)%P;
        smb = ((smb+calc(res.b, t))%P-calc(res.b, lst)+P)%P;
        if (!op) fp[u].fill();
        else if (op == 1) for (int i=0; i<=deg; i++)
            fp[u].a[i] = (i+k-l[p]+1+P)%P, fp[u].b[i] = sm(l[p], i+k);
        else if (op == 2) for (int i=0; i<=deg; i++)
            fp[u].a[i] = k+1, fp[u].b[i] = sm(i, i+k);
        else if (op == 3) fp[u].fill(r[p]-l[p]+1, sm(l[p], r[p]));
        else for (int i=0; i<=deg; i++)
            fp[u].a[i] = (r[p]-i+1+P)%P, fp[u].b[i] = sm(i, r[p]);
        fa[u] = fb[u] = fo[u] = fp[u];
        for (lst=t; u=f[u], ~u;) tp[u] ? rk(u) : cp(u);
    }
}
int main() {
    int k, sma1, sma2, smb1, smb2;
    std::cin >> n >> k, *fc = ifc[deg=n+1] = 1;
    for (int i=1; i<=deg; i++) fc[i] = 1ll*fc[i-1]*i%P;
    for (int a=fc[deg], b=P-2; b; a=1ll*a*a%P, b/=2)
        if (b & 1) ifc[deg] = 1ll*ifc[deg]*a%P;
    for (int i=deg; i; i--) ifc[i-1] = 1ll*ifc[i]*i%P;
    for (int i=0; i<n; i++)
        if (std::cin >> l[i] >> r[i], r[i] - l[i] > k)
            a.emplace_back(l[i]-k-1, i, 1), a.emplace_back(l[i], i, 2),
            a.emplace_back(r[i]-k, i, 4), a.emplace_back(r[i], i, 0);
        else if (r[i] - l[i] == k) a.emplace_back(l[i]-k-1, i, 1),
            a.emplace_back(l[i], i, 4), a.emplace_back(r[i], i, 0);
        else a.emplace_back(l[i]-k-1, i, 1), a.emplace_back(r[i]-k, i, 3),
            a.emplace_back(l[i], i, 4), a.emplace_back(r[i], i, 0);
    for (int i=1, u, v; i<n; i++) std::cin >> u >> v,
        g[--u].emplace_back(--v, 0), g[v].emplace_back(u, 0);
    std::sort(a.begin(), a.end(), [](auto x, auto y)
        {return std::get<0>(x)<std::get<0>(y);});
    dfs(0), f[rt = Build::bd(0)] = *tp = *f = -1;
    fp->init(), fa->init(), fb->init(), fx->init(), fy->init(), fo->init();
    sv(k, sma1, smb1), sv(k-1, sma2, smb2);
    printf("%d\n%d", (sma1-sma2+P)%P, (smb1-smb2+P)%P);
}
```

---

## 作者：pengyule (赞：6)

[[省选联考 2022] 填树](https://www.luogu.com.cn/problem/P8290)
同样也是对列 dp 转移式加了难度，同时代码难度因多个知识点复合、有第二问、dp 数组繁多等多重因素而显著提升。另外，取模优化不可或缺。
同样从与值域相关的 dp 状态入手。这个题很特别，它在树上，那就要树形 dp，我们的想法是对于每个点求出所有从它出发的长非零路径的答案，将它跟所有长为零路径（点）的答案相加除以二显然就是答案。现在我们随便找一个根，设 $f[u][x]$ 表示 $u$ 的子树中，从 $u$ 出发的路径、最小值为 $x$ 的方案数（先解决第一问，第二问基本上可以说是同理了）。
发现并不好做。是不是要记录一下最大值？怎么处理这个极差限制？其实这是一类经典问题，可用简单的容斥思想解决。具体固定一端（如最小值），如果最小值固定且在 $[l,r]$ 中选数的答案是 $p_1$，在 $(l,r]$ 中选数的答案是 $p_2$，那么最小值等于 $l$ 的答案显然是 $p_1-p_2$，有如下转移：
$$
p_1[u][x]=\max(0,\min(r[u],x+K)-\max(x,l[u])+1)\sum_{v\in Son(u)}p_1[v][x]\\
p_2[u][x]=\max(0,\min(r[u],x+K-1)-\max(x,l[u])+1)\sum_{v\in Son(u)}p_2[v][x]\\
f[u][x]=p_1[u][x]-p_2[u][x+1]
$$
然后进行一次换根，就有了暴力做法。$q_1,q_2$ 也很简单（第二问），告诉你就是
$$
q_1[u][x]=\sum_{v\in Son(u)}q_1[v][x]\cdot \max(0,\min(r[u],x+K)-\max(x,l[u])+1)+\sum_{v\in Son(u)}p_1[v][x]\cdot S(\max(x,l[u]),\min(r[u],x+K))\\
q2[u][x]=\sum_{v\in Son(u)}q_2[v][x]\cdot \max(0,\min(r[u],x+K-1)-\max(x,l[u])+1)+\sum_{v\in Son(u)}p_2[v][x]\cdot S(\max(x,l[u]),\min(r[u],x+K-1))\\
g[u][x]=q_1[u][x]-q_2[u][x+1]
$$
其中 $S(l,r)=\frac {(l+r)(r-l+1)}2$。

接下来分析，发现 $\min,\max$ 不是多项式，而是分段函数，手算出每个 $u$ 的 6 个断点，按照常规拉插。那么最终指数的求法：容易悟出 $p_1,p_2$ 的指数等于离他最远的点的距离+1（也是用归纳法，不同在于叶子是一次的，所以+1），拉插当中求点值前缀和又+1，所以 $f[u][x](i)$ 的次数是 $(n-1)+1+1=n+1$ 的，观察转移式可以看出 $q$ 的指数每次就是比 $p$ +1了（因为乘的是等差数列求和），那就是 $n+2$ 次，所以都维护 $n+3$ 个点值就好了呗。


```cpp
#include <bits/stdc++.h>
#define int long long
const int N=650,mod=1e9+7;
const int _12=mod+1>>1;
#define S(l,r) (max(0ll,r-l+1ll)*(l+r)%mod*_12%mod)
using namespace std;
inline int read(){
	register char ch=getchar();register int x=0;
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x;
}
int n,K,tot,_,__,x,t,sum,suM,l[N],r[N],arr[N*2],jc[N],ijc[N],pre[N],suf[N],
	s1[N][N],s2[N][N],p1[N][N],p2[N][N],yf[N][N],
	r1[N][N],r2[N][N],q1[N][N],q2[N][N],yg[N][N],
	S1[N][N],S2[N][N],P1[N][N],P2[N][N],yF[N][N],
	R1[N][N],R2[N][N],Q1[N][N],Q2[N][N],yG[N][N];
vector<int>gg[N],gr[N];
inline int qp(int a,int b){
	int c=1;
	for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)c=1ll*c*a%mod;
	return c;
}
inline void ade(int&x,int y){x+=y,x>=mod&&(x-=mod);}
inline int add(int x,int y){return x+y>=mod?x+y-mod:x+y;}
void dfs1(int u){
	for(int v:gr[u])dfs1(v);
	for(int i=t+1;i;i--){
		s1[u][i]=s2[u][i]=1,r1[u][i]=r2[u][i]=0;
		const long long tmp1=max(0ll,min(r[u],arr[x]+i-1+K)-max(arr[x]+i-1,l[u])+1),tmp2=max(0ll,min(r[u],arr[x]+i-1+K-1)-max(arr[x]+i-1,l[u])+1),tmp3=S(max(arr[x]+i-1,l[u]),min(r[u],arr[x]+i-1+K)),tmp4=S(max(arr[x]+i-1,l[u]),min(r[u],arr[x]+i-1+K-1));
		for(int v:gr[u]){
			ade(s1[u][i],p1[v][i]),
			ade(s2[u][i],p2[v][i]),
			ade(r1[u][i],q1[v][i]),
			ade(r2[u][i],q2[v][i]);
		}
		q1[u][i]=add(r1[u][i]*tmp1%mod,s1[u][i]*tmp3%mod);
		q2[u][i]=add(r2[u][i]*tmp2%mod,s2[u][i]*tmp4%mod);
		p1[u][i]=s1[u][i]*tmp1%mod;
		p2[u][i]=s2[u][i]*tmp2%mod;
		if(i==t+1)continue;
		yg[u][i]=add(q1[u][i]-q2[u][i+1],mod);
		yf[u][i]=add(p1[u][i]-p2[u][i+1],mod);
	//	printf("[%d][%d] p1=%d, p2=%d, yf=%d\n",u,i,p1[u][i],p2[u][i],yf[u][i]);
	}
}//checked
inline void Lagrange(int t,int m){
	for(int u=1;u<=n;u++)
		for(int i=2;i<=t;i++)
			ade(yF[u][i],yF[u][i-1]),ade(yG[u][i],yG[u][i-1]);
	if(t>=m){
		for(int u=1;u<=n;u++)ade(sum,yF[u][m]),ade(suM,yG[u][m]);
		return;
	}
	pre[0]=suf[t+1]=1;
	for(int i=1;i<=t;i++)pre[i]=1ll*pre[i-1]*(m-i)%mod;
	for(int i=t;i;i--)suf[i]=1ll*suf[i+1]*(m-i)%mod;
	for(int i=1;i<=t;i++){
		int tmp=(1ll*pre[i-1]*suf[i+1]%mod*ijc[i-1]%mod*ijc[t-i]*((t-i&1)?-1:1)%mod+mod)%mod;
		for(int u=1;u<=n;u++){
			ade(sum,1ll*tmp*yF[u][i]%mod);
			ade(suM,1ll*tmp*yG[u][i]%mod);
		}
	}
}
void dfs0(int u,int p){
	for(int v:gg[u])if(v^p)dfs0(v,u),gr[u].push_back(v);
}
void dfs2(int u){
	if(u==1){
		for(int i=t+1;i;i--){
			const long long tmp1=max(0ll,min(r[u],arr[x]+i-1+K)-max(arr[x]+i-1,l[u])+1),tmp2=max(0ll,min(r[u],arr[x]+i-1+K-1)-max(arr[x]+i-1,l[u])+1),tmp3=S(max(arr[x]+i-1,l[u]),min(r[u],arr[x]+i-1+K)),tmp4=S(max(arr[x]+i-1,l[u]),min(r[u],arr[x]+i-1+K-1));
			for(int v:gr[u]){
				S1[v][i]=(s1[v][i]+(s1[u][i]-p1[v][i]+mod)%mod*tmp1%mod)%mod,
				S2[v][i]=(s2[v][i]+(s2[u][i]-p2[v][i]+mod)%mod*tmp2%mod)%mod,
				R1[v][i]=(r1[v][i]+((r1[u][i]-q1[v][i]+mod)%mod*tmp1%mod+(s1[u][i]-p1[v][i]+mod)%mod*tmp3%mod)%mod)%mod,
				R2[v][i]=(r2[v][i]+(r2[u][i]-q2[v][i]+mod)%mod*tmp2%mod+(s2[u][i]-p2[v][i]+mod)%mod*tmp4%mod)%mod;
			}
			Q1[u][i]=add(r1[u][i]*tmp1%mod,s1[u][i]*tmp3%mod);
			Q2[u][i]=add(r2[u][i]*tmp2%mod,s2[u][i]*tmp4%mod);
			P1[u][i]=s1[u][i]*tmp1%mod;
			P2[u][i]=s2[u][i]*tmp2%mod;
		}for(int i=t;i;i--){
			yG[u][i]=add(Q1[u][i]-Q2[u][i+1],mod);
			yF[u][i]=add(P1[u][i]-P2[u][i+1],mod);
		//	printf("[%d][%d] P1=%d, P2=%d, yF=%d\n",u,i,P1[u][i],P2[u][i],yF[u][i]);
		}
		for(int v:gr[u])dfs2(v);
		return;
	}
	for(int i=t+1;i;i--){
		const long long tmp1=max(0ll,min(r[u],arr[x]+i-1+K)-max(arr[x]+i-1,l[u])+1),tmp2=max(0ll,min(r[u],arr[x]+i-1+K-1)-max(arr[x]+i-1,l[u])+1),tmp3=S(max(arr[x]+i-1,l[u]),min(r[u],arr[x]+i-1+K)),tmp4=S(max(arr[x]+i-1,l[u]),min(r[u],arr[x]+i-1+K-1));
		for(int v:gr[u]){
			S1[v][i]=add(s1[v][i],(S1[u][i]-p1[v][i]+mod)*tmp1%mod),
			S2[v][i]=add(s2[v][i],(S2[u][i]-p2[v][i]+mod)*tmp2%mod),
			R1[v][i]=(r1[v][i]+((R1[u][i]-q1[v][i]+mod)*tmp1%mod+(S1[u][i]-p1[v][i]+mod)*tmp3%mod)%mod)%mod,
			R2[v][i]=(r2[v][i]+(R2[u][i]-q2[v][i]+mod)*tmp2%mod+(S2[u][i]-p2[v][i]+mod)*tmp4%mod)%mod;
		}
		Q1[u][i]=add(R1[u][i]*tmp1%mod,S1[u][i]*tmp3%mod);
		Q2[u][i]=add(R2[u][i]*tmp2%mod,S2[u][i]*tmp4%mod);
		P1[u][i]=S1[u][i]*tmp1%mod;
		P2[u][i]=S2[u][i]*tmp2%mod;
	}for(int i=t;i;i--){
		yG[u][i]=add(Q1[u][i]-Q2[u][i+1],mod);
		yF[u][i]=add(P1[u][i]-P2[u][i+1],mod);
	//	printf("[%d][%d] P1=%d, P2=%d, yF=%d\n",u,i,P1[u][i],P2[u][i],yF[u][i]);
	}
	for(int v:gr[u])dfs2(v);
}
signed main(){
	double tim1=clock();
	n=read(),K=read();
	const int U=n+3;
	jc[0]=ijc[0]=1;
	for(int i=1;i<=U;i++)jc[i]=1ll*jc[i-1]*i%mod;
	ijc[U]=qp(jc[U],mod-2);
	for(int i=U-1;i;i--)ijc[i]=(i+1ll)*ijc[i+1]%mod;//print(n+1,ijc);puts("|||");
	for(int i=1;i<=n;i++){
		l[i]=read(),r[i]=read();
		(_+=r[i]-l[i]+1)%=mod,(__+=S(l[i],r[i]))%=mod;
		arr[++tot]=r[i]-K,arr[++tot]=l[i],arr[++tot]=r[i]+1,arr[++tot]=l[i]-K-1,arr[++tot]=l[i]-K,arr[++tot]=r[i]-K+1;
	}
	sum=_,suM=__;
	sort(arr+1,arr+tot+1),tot=unique(arr+1,arr+tot+1)-arr-1;
	for(int i=1,u,v;i<n;i++)u=read(),v=read(),gg[u].push_back(v),gg[v].push_back(u);
	dfs0(1,0);
	double tim2=clock();
	for(x=1,t=min(U,arr[2]-arr[1]);x<tot;x++,t=min(U,arr[x+1]-arr[x])/*,puts("---")*/)
		dfs1(1),dfs2(1),Lagrange(t,arr[x+1]-arr[x]);
	printf("%lld\n%lld\n",1ll*sum*_12%mod,1ll*suM*_12%mod);
	double tim3=clock();
//	printf("%.0lf %.0lf",tim2-tim1,tim3-tim2);
}
```

---

## 作者：WrongAnswer_90 (赞：4)

# [My Blogs](https://www.cnblogs.com/WrongAnswer90/p/18139126)

[P8290 [省选联考 2022] 填树](https://www.luogu.com.cn/problem/P8290)

很有意思的拉插优化 DP。

首先可以枚举 $L$ 来限制选的数的值域在 $L,L+k$ 中。然后进行树上 DP：设 $v_i$ 表示当前点 $i$ 能填多少种数，$w_i$ 表示当前点 $i$ 能填的数的和。

$f_i$ 表示当前 $i$ 子树内的所有合法根链数量，$g_i$ 表示 $i$ 子树内所有根链的权值之和。假设在合并子树 $to$，转移方程：

$$
\begin{aligned}
v_i&=\max(0,\min(r_i,L+k)-\max(l_i,L)+1)\\
w_i&=\max(0,\frac{(\min(r_i,L+k)+\max(l_i,L))v_i}2)\\
ans1&\rightarrow ans1+f_if_{to}\\
ans2&\rightarrow ans2+f_ig_{to}+f_{to}g_i\\
f_i&\rightarrow f_i+v_if_{to}\\
g_i&\rightarrow g_i+v_ig_{to}+f_{to}w_i
\end{aligned}
$$

但是这样会算重，比如一个最小值为 $3$，最大值为 $5$ 的方案，在 $k=3$ 的时候会被算两次（$L=2,R=5$ 时被算一次，$L=3,R=6$ 时被算一次）。可以在 DP 中多开一维记录最小值是否取到了 $L$，但是略显繁琐，常数也并不优秀。

所以考虑容斥，算 $2V$ 遍，每次用 $(L,L+k)$ 的答案减去 $(L+1,L+k)$ 的答案，这样得到的就是最小值恰好为 $L$ 的答案。

一次 DP 复杂度是 $\mathcal O(n)$，总复杂度 $\mathcal O(nV)$。但是还不够。

观察 $ans1$ 和 $ans2$，如果用分段法把 $\min$ 和 $\max$ 拆开，则他们在同一段下一定都是关于 $V$ 的不超过 $n+1$ 次的多项式。

对于 $ans1$，其是由若干个 $v$ 乘起来的，而 $v$ 要么是常数，要么是关于 $L$ 的单项式，所以次数不会超过 $n$。

对于 $ans2$，是由一个 $w$ 和多个 $v$ 乘起来的，而 $w$ 可能是一个关于 $L$ 的二次多项式，所以最高次数是 $n+1$。下面只考虑处理 $ans2$，$ans1$ 同理。

这样考虑设一个连续段 $l,r$，设 $ans_i$ 为 $L=i+l-1$ 时的 $ans2$。有结论：把 $ans_i$ 做一遍前缀和，得到的 $ans_i$ 是关于 $L$ 的不超过 $n+2$ 次的多项式。

考虑设 $F(x)=\sum_{i=0}^na_ix^i$，则做一遍前缀和之后 $S'(x)=\sum_{i=0}^na_i\sum_{j=1}^xx^j$，最高次项是一个 $n+1$ 次的自然数幂和，所以得到的前缀和最高次不超过 $n+2$。

所以可以只求 $n+3$ 个点值，用拉插公式求出在 $L=r$ 时前缀和的点值。连续段个数是 $\mathcal O(n)$ 的，每次需要做 $\mathcal O(n)$ 次 DP（来确定前 $n+3$ 个点值），每次 DP 复杂度是 $\mathcal O(n)$，拉插复杂度不是瓶颈，总复杂度 $\mathcal O(n^3)$。注意常数优化。

另一种做法：可以考虑枚举了连续段之后不暴力拉插，而是 DP 的时候直接多项式。因为次数不会超过 $siz_i$，所以暴力做复杂度是树上背包的 $\mathcal O(n^2)$。然后得到了一个 $\mathcal O(n)$ 次的多项式，想办法求出它的前缀和应该也能做，但是感觉不如拉插简洁和直接。

```cpp
int n,m,ans1,ans2,sum1,sum2,cnt,len,L,R,v[210],v2[210],fr[210];
int a[210],b[210],f[210],g[210],head[210],to[210],nex[210],numa[810];
vi T[210];
inline void add(int x,int y){to[++cnt]=y,nex[cnt]=head[x],head[x]=cnt;}
void dfs0(int x,int fa){for(auto to:T[x])if(to!=fa)add(x,to),dfs0(to,x);}
void dfs(int x)
{
	int v1=0,v2=0;
	if(min(R,b[x])<max(L,a[x]))f[x]=g[x]=0;
	else
	f[x]=v1=max(0,min(R,b[x])-max(L,a[x])+1),
	g[x]=v2=Cmul(min(R,b[x])+max(L,a[x]),f[x],(MOD+1)>>1);
	Madd(sum1,f[x]),Madd(sum2,g[x]);
	for(int i=head[x];i;i=nex[i])
	{
		dfs(to[i]);
		if(!v1)continue;
		Madd(sum1,Cmul(f[x],f[to[i]])),Madd(sum2,Cmul(f[x],g[to[i]]),Cmul(g[x],f[to[i]]));
		Madd(g[x],Cadd(Cmul(f[to[i]],v2),Cmul(v1,g[to[i]]))),Madd(f[x],Cmul(v1,f[to[i]]));
	}
}
inline void mian()
{
	read(n,m),fr[0]=1;int x,y,rr=-inf;L=inf;
	for(int i=1;i<=204;++i)fr[i]=Cmul(fr[i-1],i);
	for(int i=1;i<=n;++i)read(a[i],b[i]),Mmin(L,a[i]),Mmax(rr,b[i]);
	for(int i=1;i<n;++i)read(x,y),T[x].eb(y),T[y].eb(x);
	dfs0(1,0),R=L+m-1;
	for(int i=1;i<=n;++i)numa[++len]=a[i],numa[++len]=b[i]-m+1,numa[++len]=b[i]+1,numa[++len]=a[i]-m;
	sort(numa+1,numa+1+len),len=unique(numa+1,numa+1+len)-numa-1;
	for(int i=1;i<len;++i)
	{
		if(numa[i+1]-numa[i]<=n+3)
		{
			L=numa[i],R=L+m;
			while(L<numa[i+1])sum1=sum2=0,dfs(1),Madd(ans1,sum1),Madd(ans2,sum2),++L,++R;
			continue;
		}
		for(int j=1;j<=n+3;++j)
		{
			L=numa[i]-1+j,R=numa[i]-1+j+m,sum1=sum2=0,dfs(1);
			v[j]=Cadd(v[j-1],sum1),v2[j]=Cadd(v2[j-1],sum2);
		}
		int tmp=1,X=numa[i+1]-1;
		for(int j=1;j<=n+3;++j)Mmul(tmp,X-(numa[i]+j-1));
		for(int j=1;j<=n+3;++j)
		{
			int va=fr[j-1];
			if((n+3-j)&1)Mmul(va,Cdel(0,fr[n+3-j]));
			else Mmul(va,fr[n+3-j]);
			Madd(ans1,Cmul(v[j],tmp,power(Cmul(va,X-(numa[i]+j-1)),MOD-2)));
			Madd(ans2,Cmul(v2[j],tmp,power(Cmul(va,X-(numa[i]+j-1)),MOD-2)));
		}
	}
	--m;
	for(int i=1;i<len;++i)
	{
		if(numa[i+1]-numa[i]<=n+3)
		{
			L=numa[i],R=L+m;
			while(L<numa[i+1])sum1=sum2=0,dfs(1),Mdel(ans1,sum1),Mdel(ans2,sum2),++L,++R;
			continue;
		}
		for(int j=1;j<=n+3;++j)
		{
			L=numa[i]-1+j,R=numa[i]-1+j+m,sum1=sum2=0,dfs(1);
			v[j]=Cadd(v[j-1],sum1),v2[j]=Cadd(v2[j-1],sum2);
		}
		int tmp=1,X=numa[i+1]-1;
		for(int j=1;j<=n+3;++j)Mmul(tmp,X-(numa[i]+j-1));
		for(int j=1;j<=n+3;++j)
		{
			int va=fr[j-1];
			if((n+3-j)&1)Mmul(va,Cdel(0,fr[n+3-j]));
			else Mmul(va,fr[n+3-j]);
			Mdel(ans1,Cmul(v[j],tmp,power(Cmul(va,X-(numa[i]+j-1)),MOD-2)));
			Mdel(ans2,Cmul(v2[j],tmp,power(Cmul(va,X-(numa[i]+j-1)),MOD-2)));
		}
	}
	write(ans1,'\n',ans2);
}
```

---

## 作者：orz_z (赞：4)

钦定最小值 $l$。

方案数就是 $[l,r]-[l+1,r]$，就是容斥掉没有最小值的情况。

现在就是树上的链的乘积，容易想到树形 `DP`。

发现值域上端点之间的区间每个点的一次函数不变。

对每一段，拉格朗日插值算前缀和就行了。

---

## 作者：lottle1212__ (赞：3)

# [[省选联考 2022] 填树](https://www.luogu.com.cn/problem/P8290)

如果不知道拉格朗日插值，其实很难有勇气做下去。因此，本篇题解认为读者已经熟悉拉格朗日插值，并从此角度去考虑问题。

首先，想着复杂度关于 $n$ 的动态规划手足无措时，就会发现这个问题非常依赖值域。说到值域，应当脑中一闪而过拉格朗日插值的想法，在这个方面想下去。

接着会想到枚举一下最小值，就知道了最大值，范围确定下来，是容易 $O(n)$ 动态规划求方案数及和的。不过不久会注意到一个问题，举个例子，$[l, r]$ 和 $[l+1, r+1]$ 两个范围的贡献中，值的范围在 $[l+1, r]$ 中的贡献重复计算两次。不过这个是好处理的，分别计算 $[l, r]$ 和 $[l+1, r]$ 的贡献，从前者中减去后者，就变成了值在 $[l, r]$，且最小值恰好取到 $l$，不重不漏。代码参考[此](https://www.luogu.com.cn/record/213684430)。

做了以上的工作，复杂度就是 $O(nV)$ 的了，然后对于一步步枚举最小值计算贡献的操作，就拿拉格朗日插值去优化他。回顾动态规划的过程，当范围连续变化的时候，一个点的单独的方案数是一次函数和常数线段拼起来的，和则是二次函数和常数线段拼起来。这时去找从函数到常数线段的分界点，发现是在当目前枚举到的范围和点的权值范围的边界刚好相交时。因此只需要在这些位置分个段，然后连续的区间做拉格朗日插值就可以了。由于段的个数是 $O(n)$ 的，而单次拉格朗日插值也是 $O(n)$ 的，所以总复杂度 $O(n^3)$。

Code
```cpp
#include <iostream>
#include <algorithm>
#include <string.h>
#include <iomanip>
#include <bitset>
#include <math.h>
#include <string>
#include <vector>
#include <queue>
#include <set>
#include <map>
#define fst first
#define scd second
#define db double
#define ll long long
#define mp make_pair
#define pb push_back
#define eb emplace_back
#define vi vector <int>
#define pii pair <int, int>
#define sz(x) ((int)x.size())
#define ms(f, x) memset(f, x, sizeof(f))
#define L(i, j, k) for (int i=(j); i<=(k); ++i)
#define R(i, j, k) for (int i=(j); i>=(k); --i)
#define ACN(i, H_u) for (int i=H_u; i; i=E[i].nxt)
using namespace std;
template <typename INT> void rd(INT &res) {
	res=0; bool f=false; char ch=getchar();
	while (ch<'0'||ch>'9') f|=ch=='-', ch=getchar();
	while (ch>='0'&&ch<='9') res=(res<<1)+(res<<3)+(ch^48), ch=getchar();
	res=(f?-res:res);
}
template <typename INT, typename...Args>
void rd(INT &x, Args &...y) { rd(x), rd(y...); }
//dfs
const int mod=1e9+7;
const int inf=0x3f3f3f3f;
const int maxn=200;
const int N=maxn+10;
int H[N], edge_cnt, n, m, kn, sum[N], cnt[N], lb, rb, fac[N], inv[N], pre[N], suf[N], d[N<<2], t1[N], t2[N], res1, res2;
//wmr
int moda(int x) { return x>=mod?x-mod:x; }
int mods(int x) { return x<0?x+mod:x; }
struct Edge { int nxt, to; } E[N<<1];
void add(int u, int v) { E[++edge_cnt]={H[u], v}; H[u]=edge_cnt; }
struct node { int l, r; } a[N];
int quick_power(int x, int y) {
	int res=1;
	while (y) {
		if (y&1) res=(ll)res*x%mod;
		x=(ll)x*x%mod, y>>=1;
	}
	return res;
}
//incra
void dfs(int u, int pre) {
	int r=min(rb, a[u].r), l=max(lb, a[u].l);
	if (l>r) l=1, r=0;
	int c0=r-l+1, s0=((ll)(l+r)*(r-l+1)>>1)%mod;
	cnt[u]=c0, sum[u]=s0; res1=moda(res1+c0), res2=moda(res2+s0);
	ACN(i, H[u]) {
		int v=E[i].to;
		if (v==pre) continue;
		dfs(v, u);
		res1=(res1+(ll)cnt[u]*cnt[v])%mod, res2=(res2+(ll)cnt[u]*sum[v]+(ll)cnt[v]*sum[u])%mod;
		cnt[u]=(cnt[u]+(ll)c0*cnt[v])%mod, sum[u]=(sum[u]+(ll)cnt[v]*s0+(ll)c0*sum[v])%mod;
	}
}
int lag(int a[], int m) {
	int ans=0;
	pre[0]=1; L(i, 1, n+2) pre[i]=(ll)pre[i-1]*(m-i)%mod;
	suf[n+3]=1; R(i, n+2, 1) suf[i]=(ll)suf[i+1]*(m-i)%mod;
	L(i, 1, n+2) ans=((ll)a[i]*pre[i-1]%mod*suf[i+1]%mod*inv[i-1]%mod*inv[n+2-i]%mod*(((n+2-i)&1)?mod-1:1)+ans)%mod;
	return ans;
}
//lottle
signed main() {
//	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
//	freopen(".in", "r", stdin);
//	freopen(".out", "w", stdout);
	fac[0]=1; L(i, 1, maxn+2) fac[i]=(ll)fac[i-1]*i%mod;
	inv[maxn+2]=quick_power(fac[maxn+2], mod-2); R(i, maxn+1, 0) inv[i]=(ll)inv[i+1]*(i+1)%mod;
	rd(n, kn);
	L(i, 1, n) {
		rd(a[i].l, a[i].r);
		d[i*4-3]=a[i].l, d[i*4-2]=max(a[i].l-kn, 0);
		d[i*4-1]=a[i].r, d[i*4]=max(a[i].r-kn, 0);
		d[n*4+1]=max(d[n*4+1], a[i].r+1);
	}
	sort(d+1, d+n*4+2); m=unique(d+1, d+n*4+2)-d-1;
	L(i, 1, n-1) { int u, v; rd(u, v); add(u, v), add(v, u); }
	int ans1=0, ans2=0;
	L(i, 1, m-1) {
		int rc=d[i+1]-d[i], cnt=min(n+2, rc);
		L(j, 1, cnt) {
			lb=d[i]+j, rb=d[i]+j+kn-1; res1=res2=0;
			dfs(1, 0);
			res1=mods(-res1), res2=mods(-res2);
			--lb; dfs(1, 0);
			ans1=moda(ans1+res1), ans2=moda(ans2+res2);
			t1[j]=ans1, t2[j]=ans2;
		}
		if (rc<=n+2) continue;
		ans1=lag(t1, rc), ans2=lag(t2, rc);
	}
	printf("%d\n%d\n", ans1, ans2);
	return 0;
}
```

---

## 作者：lupengheyyds (赞：3)

首先不难想到一个 $\mathcal O(nk)$ 的树形 DP。

首先枚举最小值 $w$，设 $f_{x,0/1}$ 表示在 $x$ 子树中，不存在/存在权值为 $w$ 的点，且所有点的权值都在 $[w,w+K]$ 中时，$x$ 向下的合法链个数，$g_{x,0/1}$ 为这些合法链的权值和。转移是简单的，代码如下：

```cpp
bool Inc(int l,int r){return l<=mn&&mn<=r;}
int Inter(int l,int r){return max(0ll,min(r,mn+K)-max(l,mn)+1);}
int InterSum(int l,int r){
    l=max(l,mn),r=min(r,mn+K);
    if(l>r)return 0;
    return (l+r)*(r-l+1)/2%MOD;
}
void DP(int x,int fa){
    f[x][1]=Inc(l[x],r[x]);
    g[x][1]=Inc(l[x],r[x])*mn;
    f[x][0]=Inter(l[x],r[x])-f[x][1];
    g[x][0]=InterSum(l[x],r[x])-g[x][1];
    int v1=f[x][1],v0=f[x][0],g1=g[x][1],g0=g[x][0];
    (ans1+=f[x][1])%=MOD;
    (ans2+=g[x][1])%=MOD;
    for(int y:ed[x]){
        if(y==fa)continue;
        DP(y,x);
        (ans1+=f[x][1]*f[y][0]+f[x][1]*f[y][1]+f[x][0]*f[y][1])%=MOD;
        (ans2+=g[x][1]*f[y][0]+g[x][1]*f[y][1]+g[x][0]*f[y][1]+
               f[x][1]*g[y][0]+f[x][1]*g[y][1]+f[x][0]*g[y][1])%=MOD;
        (g[x][1]+=v1*g[y][0]+v1*g[y][1]+v0*g[y][1]+
                  g1*f[y][0]+g1*f[y][1]+g0*f[y][1])%=MOD;
        (g[x][0]+=v0*g[y][0]+g0*f[y][0])%=MOD;
        (f[x][1]+=v1*f[y][0]+v1*f[y][1]+v0*f[y][1])%=MOD;
        (f[x][0]+=v0*f[y][0])%=MOD;
    }
    return;
}
```

虽然这样会做 $\mathcal O(K)$ 次 DP，但这些 DP 的转移是不变的，变化的是一些点的初始状态，我们去探究其规律。

将 $\min(r,w+K),\max(l,w)$ 中的 $\min,\max$ 拆开，我们发现每个点 $f,g$ 的初始状态分别是关于 $w$ 的一次和二次函数，所以最终乘起来后，$ans1,ans2$ 分别是关于 $w$ 的 $n$ 次与 $n+1$ 次函数。我们要求的是函数取到 $[1,K]$ 的和，而 $k$ 次多项式的和为  $k+1$ 次多项式，注意到多项式函数定义域大，次数小，我们可以直接拉格朗日插值解决！

最终复杂度 $\mathcal O(n^3)$。

完整代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int NN=805,MOD=1e9+7;
int n,K;
int f[NN][2],l[NN],r[NN],mn,ans1,ans2,mxr,fans,g[NN][2];
vector<int> ed[NN];
bool Inc(int l,int r){return l<=mn&&mn<=r;}
int Inter(int l,int r){return max(0ll,min(r,mn+K)-max(l,mn)+1);}
int InterSum(int l,int r){
    l=max(l,mn),r=min(r,mn+K);
    if(l>r)return 0;
    return (l+r)*(r-l+1)/2%MOD;
}
int QP(int a,int b){
    int c=1;
    for(;b;b>>=1){
        if(b&1)c=1ll*c*a%MOD;
        a=1ll*a*a%MOD;
    }
    return c;
}
void DP(int x,int fa){
    f[x][1]=Inc(l[x],r[x]);
    g[x][1]=Inc(l[x],r[x])*mn;
    f[x][0]=Inter(l[x],r[x])-f[x][1];
    g[x][0]=InterSum(l[x],r[x])-g[x][1];
    int v1=f[x][1],v0=f[x][0],g1=g[x][1],g0=g[x][0];
    (ans1+=f[x][1])%=MOD;
    (ans2+=g[x][1])%=MOD;
    for(int y:ed[x]){
        if(y==fa)continue;
        DP(y,x);
        (ans1+=f[x][1]*f[y][0]+f[x][1]*f[y][1]+f[x][0]*f[y][1])%=MOD;
        (ans2+=g[x][1]*f[y][0]+g[x][1]*f[y][1]+g[x][0]*f[y][1]+
               f[x][1]*g[y][0]+f[x][1]*g[y][1]+f[x][0]*g[y][1])%=MOD;
        (g[x][1]+=v1*g[y][0]+v1*g[y][1]+v0*g[y][1]+
                  g1*f[y][0]+g1*f[y][1]+g0*f[y][1])%=MOD;
        (g[x][0]+=v0*g[y][0]+g0*f[y][0])%=MOD;
        (f[x][1]+=v1*f[y][0]+v1*f[y][1]+v0*f[y][1])%=MOD;
        (f[x][0]+=v0*f[y][0])%=MOD;
    }
    return;
}
int lsh[NN];
typedef pair<int,int> pa;
#define x first
#define y second
vector<pa> v1,v2;
int F(int X,vector<pa>&v){
    int val=0;
    for(int i=0;i<v.size();i++){
        int prod1=1,prod2=1;
        for(int j=0;j<v.size();j++){
            if(i==j)continue;
            (prod1*=X-v[j].x)%=MOD;
            (prod2*=v[i].x-v[j].x)%=MOD;
        }
        (val+=v[i].y*prod1%MOD*QP(prod2,MOD-2))%=MOD;
    }
    return val;
}
signed main(){
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    cin>>n>>K;
    for(int i=1;i<=n;i++){
        cin>>l[i]>>r[i];
        mxr=max(mxr,r[i]);
        lsh[++lsh[0]]=l[i],lsh[++lsh[0]]=max(1ll,r[i]-K);
        lsh[++lsh[0]]=r[i],lsh[++lsh[0]]=max(1ll,l[i]-K);
    }
    lsh[++lsh[0]]=mxr+1;lsh[++lsh[0]]=1;
    sort(lsh+1,lsh+1+lsh[0]);
    lsh[0]=unique(lsh+1,lsh+1+lsh[0])-lsh-1;
    for(int i=1;i<n;i++){
        int l,r;cin>>l>>r;
        ed[l].push_back(r);
        ed[r].push_back(l);
    }
    for(int i=1;i<lsh[0];i++){
        v1.clear();v2.clear();
        for(mn=lsh[i];mn<=min(lsh[i]+n+4,lsh[i+1]-1);mn++){
            DP(1,1);
            v1.push_back({mn,ans1});
            v2.push_back({mn,ans2});
        }
        ans1=F(lsh[i+1]-1,v1);
        ans2=F(lsh[i+1]-1,v2);
    }
    cout<<ans1<<"\n"<<ans2%MOD;
    return 0;
}
```

---

## 作者：nullqtr_pwp (赞：3)

对于极差 $\leq k$ 的限制，而每个点都限定了权值的取值范围，所以我们考虑枚举区间的最小值 $l$，此时最大值为 $l+k$。如果直接去计算最小值**恰好等于**的情况，情况过多，时间复杂度也可能退化。我们可以用类似 Dirichlet 差分的思想，转化为每个数都 $\ge l$ 的方案数去减去每个数 $>l$ 的方案数，就是容斥掉不存在最小值为 $l$ 的方案。

下称原来 $i$ 的区间是输入给定的 $[l_i,r_i]$。

先考虑子问题每个数都在 $[l,r]$ 内怎么解决。每个点有一个权值的选取范围 $[l_{1,i},r_{1,i}]$（由给定区间与原来 $i$ 的区间取交集），要选取一个链（上面所有），第一问要计算：所有赋权值的方案，选合法链的方案数，第二问要计算：所有赋权值的方案，所有合法链的和。

第一问，相当于每个点可选的数量为 $r_{1,i}-l_{1,i}+1$，第二问相当于每个点的贡献是 $\dfrac{(l_{1,i}+r_{1,i})(r_{1,i}-l_{1,i}+1)}{2}$。原因是等差数列求和，然后所有的和是加算。

这种牵扯到树上算总数，总贡献的问题，自然想到 dp。钦定一个根 $rt$，跑 $n$ 次，就可以令 $f_{u,0/1}$ 表示以 $u$ 为根的子树两问分别的答案。此时**单次**复杂度为 $O(n^2)$，换根一下可以做到 $O(n)$。

你对每个最小值跑一遍这个，那直接就炸了。时间复杂度高达 $O(nW)$，可以拿到 $40$ 分的好成绩。类似于 [[NOIP2023-T4] 天天爱打卡](https://uoj.ac/problem/837)，你发现这个你钦定的区间相差不大时，答案的变化不会太大。

深入思考，你发现根本没有必要对于每个最小值重新跑一遍 dp。钦定极差区间时，对于每个点的取值区间 $[l_{1,i},r_{1,i}]$，记录第一问权值为 $a_i=r_{1,i}-l_{1,i}+1$，第二问权值为 $b_i=\dfrac{(l_{1,i}+r_{1,i})(r_{1,i}-l_{1,i}+1)}{2}$，上文已经叙述原因。滑动这个极差区间的窗口 $[l,l+k]$，分类讨论与原来 $i$ 的区间的相交，包含的情况。会发现，在两个区间的相对关系不变时，你得出来的 $a_i$ 每次只会 $\pm 1$，同理 $b_i$ 变化也不大。

于是，两段区间的相对关系不变时，因为每次加减的量都是 $1$ 或者不变，所以 $a_i$ 可以表示为一次函数，$b_i$ 可以表示为二次函数。发现了什么？对于一个定义域使得所有点的贡献都会表示为一次函数和二次函数时，**答案可以表示为一个 $\textbf{\textit{n} + 1}$ 次多项式。此时可以考虑答案前缀和的多项式。**

于是你再考虑把这堆定义域拆出来，把使得所有点断成不同函数的点摘出来，断点就是使得每个点两个区间相对关系改变的所有 $i$（作为极差区间的起点），为所有的 $l_i,r_i,\max(0,l_i-k),\max(0,r_i-k)$。考虑分段维护多项式，分成的段数是 $O(n)$ 的。

枚举定义域的时候，考虑答案前缀和的 $n+1$ 次多项式。**用拉格朗日插值，可以求出一个变量的函数值**。你可以暴力计算 $n+2$ 个点的值，用 dp 计算答案前缀和。然后再插值求出下一个点的答案前缀和（计算下一组定义域起点 $-1$）。

时间复杂度 $O(n^3)$。

```cpp

// Problem: P8290 [省选联考 2022] 填树
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P8290
// Memory Limit: 512 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
#define int long long
#define ll long long
#define pb push_back
#define fi first
#define se second
#define inf 1e9
#define pii pair<int,int>
#define F(i,a,b) for(int i=a;i<=(b);i++)
#define dF(i,a,b) for(int i=a;i>=(b);i--)
#define wh(lzm) while(lzm--)
#define lowbit(x) (x&(-x))
#define HH printf("\n")
#define eb emplace_back
using namespace std;
int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}
const int mod=1e9+7,maxn=1145;
void fre(){
	freopen("tree.in","r",stdin);
	freopen("tree.out","w",stdout);
}
void add(int &x,int y){
	if(y>=mod) y%=mod;
	x+=y;
	if(x>=mod) x-=mod;
}
void mul(int &x,int y){
	if(y>=mod) y%=mod;
	x*=y;
	if(x>=mod) x%=mod;
}
void sub(int &x,int y){
	if(y>=mod) y%=mod;
	y=mod-y;
	x+=y;
	if(x>=mod) x-=mod;
}
void chkmin(int &x,int y){
	x=min(x,y);
}
void chkmax(int &x,int y){
	x=max(x,y);
}
int qpow(int x,int y){
	int rt=1; if(x>=mod) x%=mod;
	for(;y;y>>=1,x=x*x%mod) if(y&1) rt=rt*x%mod;
	return rt;
}
int lagrange(int n,int *x,int *y,int k){
	int ans=0;
	F(i,0,n){
		int s1=1,s2=1;
		F(j,0,n) if(i^j){
			s1*=(k-x[j]);
			s2*=(x[i]-x[j]);
			s1%=mod; s2%=mod;
		}
		ans+=(y[i]*s1%mod*qpow(s2,mod-2)%mod);
		ans%=mod;
	}
	if(ans<0) ans+=mod;
	return ans;
}
int sum(int l,int r){
	return 1ll*(r-l+1)*(l+r)/2%mod;
}
vector<int>g[maxn];
int a[maxn],b[maxn],n,k,p[maxn],tot,m,ans1,ans2,mx;
int dp[maxn],cnt[maxn],vis[maxn],f[maxn];
void dfs(int u,int fa,int L,int R){//dp 计算极差区间为 [L,R] 的方案数
	int l=max(L,a[u]),r=min(R,b[u]); 
	int tot1=r-l+1,tot2=sum(l,r);
	if(l>r) tot1=tot2=0;
	dp[u]=cnt[u]=tot1;
	vis[u]=f[u]=tot2;
	for(int v:g[u]) if(v^fa){
		dfs(v,u,L,R);
		add(cnt[u],dp[u]*dp[v]);
		add(vis[u],f[u]*dp[v]+dp[u]*f[v]);
		add(dp[u],dp[v]*tot1);
		add(f[u],f[v]*tot1+dp[v]*tot2);
	}
}
int ay[maxn],by[maxn],px[maxn]; 
signed main(){
	//fre();
	n=read(),k=read();
	F(i,1,n) a[i]=read(),b[i]=read(),chkmax(mx,b[i]);
	F(i,1,n-1){
		int u=read(),v=read();
		g[u].push_back(v);
		g[v].push_back(u);
	}
	p[m=1]=mx+1;
	F(i,1,n){
		p[++m]=a[i],p[++m]=b[i];
		p[++m]=max(a[i]-k,0ll),p[++m]=max(b[i]-k,0ll);
	}
	sort(p+1,p+m+1);
	m=unique(p+1,p+m+1)-p-1;
	F(i,1,m-1){
		F(j,0,n+1){
			dfs(1,0,p[i]+j,p[i]+j+k);
			F(i,1,n){
				add(ans1,cnt[i]);
				add(ans2,vis[i]);
			} 
			dfs(1,0,p[i]+j+1,p[i]+j+k);
			F(i,1,n){
				sub(ans1,cnt[i]);
				sub(ans2,vis[i]);	
			} 
			px[j]=p[i]+j;
			ay[j]=ans1;
			by[j]=ans2;
			if(p[i]+j==p[i+1]-1) break;
		}
		if(p[i]+n+2>=p[i+1]) continue;
		ans1=lagrange(n+1,px,ay,p[i+1]-1);
		ans2=lagrange(n+1,px,by,p[i+1]-1);
	}
	printf("%lld\n%lld",ans1,ans2);
}
```

---

## 作者：_Ch1F4N_ (赞：1)

考虑枚举一下点权最小值 $L$，限制转化为链上点权在 $[L,L+k]$ 内，为了防止计重我们需要强制钦定此时最小值取到了 $L$，具体做法只需要减去在区间 $[L+1,L+k]$ 内的方案即可。

限制区间后一个点的取值为 $[\max(L,l_i),\min(L+k,r_i)]$ 和 $[\max(L+1,l_i),\min(L+k,r_i)]$，由于 $\max,\min$ 比较恶心，你考虑把他拆掉，你发现 $max(x,C)$ 可以拆为 $[1,C]$ 内的 $C$ 与 $[C+1,\infty]$ 内的 $x$ 或者是 $[1,C-1]$ 内的 $C$ 与 $[C,\infty]$ 内的 $x$，你发现断点可以是 $x$ 或者 $x-1$，于是上面两个区间只需要四个断点 $l_i,l_i - k,r_i,r_i - k$。

在每一段内你发现每个点的取值方案是一个关于 $L$ 的一次多项式，每个点的所有取值之和是一个关于 $L$ 的二次多项式，所有取值方案就是所有链的链上点多项式乘积也就是一个关于 $L$ 的 $n$ 次多项式，所有取值方案和是一个关于 $L$ 的 $n+1$ 次多项式，因此虽然每一段的取值可能很大，但是一段 $L$ 的贡献是一个关于 $L$ 的 $n+2$ 次多项式，如果你能 $O(n)$ 地计算一个 $L$ 的贡献的话，对每一段前 $n+2$ 个点暴力求解再插值即可做到 $O(n^3)$。

怎么 $O(n)$ 地计算一个 $L$ 的贡献呢？不妨 $dp_{i,0/1},g_{i,0/1}$ 分别表示链的一个端点是 $i$，另一个端点在其子树内或者子树外，链数量与所有链权值和，于是在树上 $O(n)$ 地做一次换根 dp 即可计算。


```cpp
#include<bits/stdc++.h>
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
using namespace std;
const int mod = 1e9+7;
const int inv = (mod+1)/2;
const int maxn = 204;
int l[maxn],r[maxn];
int L[maxn],R[maxn]; 
int n,k;
long long ch[maxn],sum[maxn];
long long dp[maxn],g[maxn];//另一个端点在子树内 另一个端点在子树外 
long long DP[maxn],G[maxn];
vector<int> E[maxn];
int dfn[maxn],dfncnt;
int fa[maxn];
void dfs(int u){
	dfn[++dfncnt]=u;
	for(int v:E[u]){
		if(v!=fa[u]){
			fa[v]=u;
			dfs(v);
		}
	}
}
long long f;
inline long long F(int x){
	long long ans=0;
	f=0;
	for(int i=1;i<=n;i++) L[i]=max(x,l[i]),R[i]=min(x+k,r[i]),ch[i]=max(0,R[i]-L[i]+1),sum[i]=1ll*(L[i]+R[i])%mod*ch[i]%mod*inv%mod;
	for(int i=1;i<=n;i++) dp[i]=DP[i]=0;
	for(int i=n;i>=1;i--){
		int u=dfn[i];
		dp[u]=(dp[u]+ch[u])%mod;
		DP[u]=(DP[u]+sum[u])%mod;
		if(fa[u]==0) break;
		dp[fa[u]]=(dp[fa[u]]+ch[fa[u]]*dp[u]%mod)%mod;
		DP[fa[u]]=(DP[fa[u]]+sum[fa[u]]*dp[u]%mod+ch[fa[u]]*DP[u]%mod)%mod;
	}
	for(int i=2;i<=n;i++){
		int u=dfn[i];
		g[u]=(dp[fa[u]]+g[fa[u]]+mod-ch[fa[u]]*dp[u]%mod)%mod*ch[u]%mod;
		G[u]=(sum[u]*((dp[fa[u]]+g[fa[u]]+mod-ch[fa[u]]*dp[u]%mod)%mod)%mod+ch[u]*((DP[fa[u]]+G[fa[u]]+mod+mod-sum[fa[u]]*dp[u]%mod-ch[fa[u]]*DP[u]%mod)%mod)%mod)%mod;
	}
	for(int i=1;i<=n;i++) ans=(ans+DP[i]+G[i]+sum[i])%mod,f=(f+dp[i]+g[i]+ch[i])%mod;//每条路径均被算两次
	for(int i=1;i<=n;i++) L[i]=max(x+1,l[i]),R[i]=min(x+k,r[i]),ch[i]=max(0,R[i]-L[i]+1),sum[i]=1ll*(L[i]+R[i])%mod*ch[i]%mod*inv%mod;
	for(int i=1;i<=n;i++) dp[i]=DP[i]=0;
	for(int i=n;i>=1;i--){
		int u=dfn[i];
		dp[u]=(dp[u]+ch[u])%mod;
		DP[u]=(DP[u]+sum[u])%mod;
		if(fa[u]==0) break;
		dp[fa[u]]=(dp[fa[u]]+ch[fa[u]]*dp[u]%mod)%mod;
		DP[fa[u]]=(DP[fa[u]]+sum[fa[u]]*dp[u]%mod+ch[fa[u]]*DP[u]%mod)%mod;
	}
	for(int i=2;i<=n;i++){
		int u=dfn[i];
		g[u]=(dp[fa[u]]+g[fa[u]]+mod-ch[fa[u]]*dp[u]%mod)%mod*ch[u]%mod;
		G[u]=(sum[u]*((dp[fa[u]]+g[fa[u]]+mod-ch[fa[u]]*dp[u]%mod)%mod)%mod+ch[u]*((DP[fa[u]]+G[fa[u]]+mod+mod-sum[fa[u]]*dp[u]%mod-ch[fa[u]]*DP[u]%mod)%mod)%mod)%mod;
	}
	for(int i=1;i<=n;i++) ans=(ans+1ll*mod*3-DP[i]-G[i]-sum[i])%mod,f=(f+1ll*mod*3-dp[i]-g[i]-ch[i])%mod;//每条路径均被算两次
	f=f*inv%mod;
	return ans*inv%mod;	
}
long long ans1,ans2;
inline long long qpow(long long a,int b){
	long long res=1;
	for(int i=0;i<=30;i++){
		if((1<<i)&b){
			res=res*a%mod;
		}
		a=a*a%mod;
	}
	return res;
}
const int warma = 202;
void solve(){
	vector<int> X;
	for(int i=1;i<=n;i++) X.push_back(l[i]),X.push_back(max(1,r[i]-k)),X.push_back(max(1,l[i]-k)),X.push_back(max(1,r[i]));
	X.push_back(1);
	X.push_back(mod-1);
	sort(X.begin(),X.end());
	for(int i=0;i+1<X.size();i++){
		int lt=X[i],rt=X[i+1]-1;
		if(lt>rt) continue;
		if(rt-lt+1<=warma){
			for(int j=lt;j<=rt;j++) ans2=(ans2+F(j))%mod,ans1=(ans1+f)%mod;
		}else{
			vector<long long> px,py,pX,pY;
			int sum1=0,sum2=0;
			for(int j=lt;j<=lt+warma-1;j++){
				sum2=(sum2+F(j))%mod;
				sum1=(sum1+f)%mod;
				px.push_back(j%mod);
				py.push_back(sum1);
				pX.push_back(j%mod);
				pY.push_back(sum2);
			}
    		for(int p1=0;p1<warma;p1++){
        		long long res=py[p1];
        		long long mul1=1,mul2=1;
        		for(int p2=0;p2<warma;p2++){
            		if(p1==p2) continue;
           			mul2=mul2*((px[p1]+mod-px[p2])%mod)%mod;
            		mul1=mul1*((rt+mod-px[p2])%mod)%mod;
        		}
        		res=res*mul1%mod*qpow(mul2,mod-2)%mod;
        		ans1=(ans1+res)%mod;
    		}
    		for(int p1=0;p1<warma;p1++){
        		long long res=pY[p1];
        		long long mul1=1,mul2=1;
        		for(int p2=0;p2<warma;p2++){
            		if(p1==p2) continue;
           			mul2=mul2*((pX[p1]+mod-pX[p2])%mod)%mod;
            		mul1=mul1*((rt+mod-pX[p2])%mod)%mod;
        		}
        		res=res*mul1%mod*qpow(mul2,mod-2)%mod;
        		ans2=(ans2+res)%mod;
    		}
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>l[i]>>r[i];
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		E[u].push_back(v);
		E[v].push_back(u);
	}
	dfs(1);
	solve();
	cout<<ans1<<' '<<ans2<<'\n';
	return 0;
}
/*
5 1
3 6
5 6
1 8
1 4
3 6
2 1
3 2
4 1
5 2
*/
```

---

## 作者：Fzrcy (赞：1)

> 简要题意：我们可以对树上的任意一条链上的点赋值，对于在链上的点 $i$，满足 $val_i\in [L_i,R_i]$，且 $\max\{val_i\}-\min\{val_i\}\le K$（$val_i$ 表示点 $i$ 的权值），求其赋值的方案数及其权值之和。

首先，求权值之和和求方案数的过程类似，所以这里只讨论如何求方案数。

设 $f_{L,R}$ 表示链上的点的权值要满足简要题意中的要求以外还要满足 $val_i\in [L,R]$ 的方案数，我们可以 $O(n)$ 的复杂度内计算 $f_{L,R}$。

可以发现 $f_{L,R}-f_{L+1,R}$ 表示使得 $\min\{val_i\}=L$ 的方案数，所以答案为 $\sum_{w}f_{w,w+K}-f_{w+1,w+K}$。

然而 $w$ 的范围很大，达到了 $10^9$ 级别，所以我们要尽量减少对 $w$ 的枚举次数，当 $w,w+K,L_i,R_i$ 的相对顺序不变时，函数 $G(w)=f_{w,w+K}$ 可以表示为一个 $n$ 项的多项式，可以用拉格朗日算法快速计算其连续和，而 $w,w+K,L_i,R_i$ 的相对顺序只会变化 $O(n)$ 次，所以总时间复杂度为 $O(n^3)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
constexpr ll p=1e9+7,N=2e4+11;
vector<ll> e[N];
ll L[N],R[N],f[N],g[N],F[N],G[N];
void link(ll u,ll v){e[u].push_back(v),e[v].push_back(u);}
ll J(ll l,ll r,ll x,ll y){return max(0ll,min(r,y)-max(l,x));}
ll JJJ(ll x){return ((x)*(x+1)/2)%p;}
ll JJ(ll l,ll r){return (JJJ(r)-JJJ(l-1)+p)%p;}
void dp1(ll u,ll fa,ll l,ll r,ll &Ans1,ll &Ans2){
  ll LL=max(l,L[u]),RR=min(r,R[u]);
  if(LL>RR) LL=1,RR=0;
  ll sum=JJ(LL,RR),len=RR-LL+1;
  f[u]=F[u]=len, g[u]=G[u]=sum;
  for(ll v:e[u]){
    if(v==fa)continue;
    dp1(v,u,l,r,Ans1,Ans2);
    F[u]+=f[u]*f[v]%p;
    G[u]+=(f[u]*g[v]+g[u]*f[v])%p;
    f[u]=(f[u]+len*f[v])%p;
    g[u]=(g[u]+sum*f[v]+len*g[v])%p;
  }
  F[u]%=p;G[u]%=p;
  Ans1+=F[u],Ans2+=G[u];
  Ans1%=p,Ans2%=p;
}
ll n,K,pos[N];
void js(ll l,ll r,ll opt,ll &a1,ll &a2){
  ll a,b; a=b=0;
  dp1(1,0,l,r,a,b);
  a1+=a*opt,a2+=b*opt;
  a1%=p,a2%=p;
}
ll ksm(ll x,ll y){
  ll cur=1;
  for(;y;y>>=1,x=x*x%p)if(y&1)cur=cur*x%p;
  return cur;
}
ll lglr(ll total,ll pos,ll *x,ll *y){
  ll ans=0;
  for(ll i=0; i<total; i++){
    ll c1=1,c2=1;
    for(ll j=0; j<total; j++){
      if(i==j)continue;
      c1=c1*(pos-x[j])%p;
      c2=c2*(x[i]-x[j])%p;
    }
    c1=y[i]*c1%p*ksm(c2,p-2)%p;
    ans+=c1;
  }
  ans%=p;
  return ans;
}
ll a[N],b[N],c[N];
int main(){
  ll ans1=0,ans2=0;
  cin>>n>>K;
  ll m=1;
  for(ll i=1; i<=n; i++){
    cin>>L[i]>>R[i];
    pos[++m]=L[i];
    pos[++m]=R[i];
    pos[++m]=max(L[i]-K,0ll);
    pos[++m]=max(R[i]-K,0ll);
    pos[1]=max(pos[1],R[i]+1);
  }
  for(ll i=1; i<n; i++){
    ll u,v;
    cin>>u>>v;
    link(u,v);
  }
  sort(pos+1,pos+m+1);
  m=unique(pos+1,pos+m+1)-pos-1;
  for(ll i=1,j; i+1<=m; i++){
    ll l=pos[i],r=pos[i]+K;
    for(j=0; j<n+2; j++,r++){
      if(pos[i]+j==pos[i+1])break;
      js(l,r,1,ans1,ans2);
      l++;
      js(l,r,-1,ans1,ans2);
      a[j]=pos[i]+j,b[j]=ans1,c[j]=ans2;
    }
    if(pos[i]+j<pos[i+1]){
      ans1=lglr(j,pos[i+1]-1,a,b);
      ans2=lglr(j,pos[i+1]-1,a,c);
    }
  }
  cout<<(ans1%p+p)%p<<endl<<(ans2%p+p)%p<<endl;
  return 0;
}
```



---

## 作者：EuphoricStar (赞：1)

这题做得真艰难。

先考虑第一问。

一眼看上去并没有什么复杂度脱离值域的办法。考虑枚举一个 $x$ 表示最小值，那么点权只能在 $[x, x + K]$ 中。

点权最小值不一定为 $x$，减去点权在 $[x + 1, x + K]$ 中的答案即可，也就是把 $K$ 减 $1$ 后再算一遍。

那么可以得出每个点权的取值范围为 $[\max(x, l_i), \min(x + K, r_i)]$。

设第 $i$ 个点有 $a_u$ 种取值。答案就是树上所有简单路径的 $a_u$ 乘积之和。

那么很容易做一个 dp，可以算出 $f_u$ 表示 $u$ 子树内延伸到 $u$ 的路径中，每条路径的取值之和。

合并儿子时有 $f_u \gets a_u \times f_v$。

然后考虑所有 $\text{LCA}$ 为 $u$ 的点对的贡献，相当于选 $v_1 \in son_u, v_2 \in son_u, v1 \ne v2$，能产生 $f_{v_1} \times f_{v_2} \times a_u$ 的贡献。

我们发现，$[\max(x, l_i), \min(x + K, r_i)]$ 只能组合出来 $4$ 种取值范围：$[x, x + K], [x, r_i], [l_i, x + K], [l_i, r_i]$，并且只和 $x$ 和 $l_i - K, l_i, r_i - K, r_i$ 的大小关系有关。

所以我们有 $O(n)$ 个断点，在每相邻两个断点组成的左开右闭区间 $[L, R)$ 内，$a_u$ 可以表示成关于 $x$ 的至多一次项式 $Ax + B$。

我们现在希望计算树上所有简单路径的多项式 $a_u$ 的乘积之和，可以使用上述的 dp 做法求出，多项式乘法暴力就行。

设我们最后求出来的树上所有简单路径的多项式 $a_u$ 的乘积之和为 $\sum\limits_{i = 0}^n A_i x^i$。答案就是 $\sum\limits_{i = 0}^n A_i \sum\limits_{x = L}^{R - 1} x^i$。也就是说要快速算 $\sum\limits_{x = 0}^N x^M$。

这就是 [CF622F The Sum of the k-th Powers](https://www.luogu.com.cn/problem/CF622F)。这个和就是一个 $M + 1$ 次多项式，直接拉格朗日插值即可。注意讨论 $L, R$ 中有负数的情况。

然后考虑第二问。

仍然先考虑暴力。设第 $u$ 个点所有取值之和为 $b_u$，那么对于树上一条简单路径 $p_1, p_2, \ldots, p_k$，我们希望求 $\sum\limits_{i = 1}^k b_{p_i} \prod\limits_{j \ne i} a_{p_j}$。

这个也可以 dp 求出。设 $f_{u, 0/1}$ 表示一条从 $u$ 子树内延伸到 $u$ 的路径，中间是否有一个点乘的是 $b_i$ 而不是 $a_i$。

合并儿子时有转移 $f_{u, 1} \gets a_u f_{v, 1} + b_u f_{v, 0}$。

然后仍然考虑所有 $\text{LCA}$ 为 $u$ 的点对的贡献，相当于选 $v_1 \in son_u, v_2 \in son_u, v1 \ne v2$，能产生 $f_{v_1, 0} \times f_{v_2, 0} \times b_u + f_{v_1, 1} \times f_{v_2, 0} \times a_u + f_{v_1, 0} \times f_{v_2, 1} \times a_u$ 的贡献。

然后也可以像第一问一样，先分段，然后把 $b_u$ 表示成关于 $x$ 的至多二次项式，dp 后拉格朗日插值算 $\sum\limits_{x = 0}^N x^M$ 解决。

时间复杂度 $O(n^3)$，但是好像跑得比大多数做法都快？

[code](https://loj.ac/s/1922139)

---

## 作者：Leasier (赞：1)

首先有一个显然的暴力：枚举路径和值域区间 $[l, r]$（**两端都要取到**）。时间复杂度为 $O(n^2 w^2)$（其中 $w$ 为值域），只能通过测试点 $1, (4)$。

枚举路径端点是没有前途的。考虑枚举区间 $[l, r]$（**两端都要取到**）且 $r - l \leq k$，将所得区间与之求交再换根 dp 计算。但这样显然会算重，于是我们稍微容斥一下即可。时间复杂度为 $O(nw^2)$，只能通过测试点 $1, 4$。

但事实上枚举 $r$ 是有大病的。因为我们的限制是 $\leq k$，所以我们枚举 $[l, l + k]$（**只有左端点被钦定为要取到**）。但这样显然会算重，于是我们再稍微容斥一下即可。时间复杂度为 $O(nw)$，只能通过测试点 $1, 4 \sim 6$。

注意到区间求交的长度随着 $l$ 的变化，在某一个值域区间内一定是一个关于 $l$ 的 $0/1$ 次多项式，则我们对第一问 dp 的结果就是把至多 $n$ 个一次多项式乘起来，于是当前值域区间内的第一问答案一定是一个关于当前区间右端点的不超过 $n + 1$ 次的多项式，于是我们算出区间内的前 $n + 2$ 个点值后拉格朗日插值即可。第二问同理，但多项式次数变成了 $\leq n + 2$。时间复杂度为 $O(n^3)$。

可能需要一些常数优化。

代码：
```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

typedef long long ll;

typedef struct {
	int nxt;
	int end;
} Edge;

typedef struct Pair_tag {
	int first;
	int second;
	Pair_tag(){}
	Pair_tag(int first_, int second_){
		first = first_;
		second = second_;
	}
} Pair;

const int mod = 1e9 + 7, inv2 = 500000004;
int cnt = 0;
int fac[207], inv_fac[207], l[207], r[207], head[207], a[807], len[207], sum[207], x[207], y1[207], y2[207], pre[207], suf[207];
bool vis[207];
Edge edge[407];
Pair dp1[207], dp2[207];
vector<int> v[207];

inline int add1(int x, int y){
	return x + y >= mod ? x + y - mod : x + y;
}

inline Pair operator +(const Pair a, const Pair b){
	return Pair(add1(a.first, b.first), add1(a.second, b.second));
}

inline void add2(int &x, int y){
	if ((x += y) >= mod) x -= mod;
}

void operator +=(Pair &a, const Pair b){
	add2(a.first, b.first);
	add2(a.second, b.second);
}

inline int sub1(int x, int y){
	return x - y < 0 ? x - y + mod : x - y;
}

inline Pair operator -(const Pair a, const Pair b){
	return Pair(sub1(a.first, b.first), sub1(a.second, b.second));
}

inline int quick_pow(int x, int p){
	int ans = 1;
	while (p){
		if (p & 1) ans = 1ll * ans * x % mod;
		x = 1ll * x * x % mod;
		p >>= 1;
	}
	return ans;
}

inline void init(int n){
	fac[0] = 1;
	for (register int i = 1; i <= n; i++){
		fac[i] = 1ll * fac[i - 1] * i % mod;
	}
	inv_fac[n] = quick_pow(fac[n], mod - 2);
	for (register int i = n - 1; i >= 0; i--){
		inv_fac[i] = 1ll * inv_fac[i + 1] * (i + 1) % mod;
	}
}

inline void add_edge(int start, int end){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
}

void dfs1(int u, int father){
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (x != father){
			v[u].push_back(x);
			dfs1(x, u);
		}
	}
}

inline int sum1(int n){
	return 1ll * n * (n + 1) / 2 % mod;
}

int get_max_power(int u, int father){
	int ans = 0;
	for (register int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		if (x != father) ans = max(ans, get_max_power(x, u));
	}
	return ans + (vis[u] ? 1 : 0);
}

void dfs2(int u){
	int size = v[u].size();
	ll sum1 = 1, sum2 = 0;
	for (register int i = 0; i < size; i++){
		int x = v[u][i];
		dfs2(x);
		sum1 += dp1[x].first;
		sum2 += dp1[x].second;
	}
	sum1 %= mod;
	sum2 %= mod;
	dp1[u].first = sum1 * len[u] % mod;
	dp1[u].second = (sum1 * sum[u] + sum2 * len[u]) % mod;
}

void dfs3(int u){
	int size = v[u].size();
	for (register int i = 0; i < size; i++){
		int x = v[u][i];
		ll p = dp2[u].first - 1ll * len[u] * dp1[x].first % mod, q, r;
		if (p < 0) p += mod;
		q = (dp1[x].first + p * len[x]) % mod;
		r = (dp1[x].second + p * sum[x] + len[x] * ((dp2[u].second - 1ll * len[u] * dp1[x].second - 1ll * sum[u] * dp1[x].first) % mod)) % mod;
		if (r < 0) r += mod;
		dp2[x].first = q;
		dp2[x].second = r;
		dfs3(x);
	}
}

inline Pair divide2(Pair pr){
	return Pair(1ll * pr.first * inv2 % mod, 1ll * pr.second * inv2 % mod);
}

inline Pair f(int n, int L, int R){
	Pair ans(0, 0);
	for (register int i = 1; i <= n; i++){
		int l_ = max(l[i], L), r_ = min(r[i], R);
		if (l_ > r_){
			len[i] = sum[i] = 0;
		} else {
			len[i] = r_ - l_ + 1;
			sum[i] = sub1(sum1(r_), sum1(l_ - 1));
		}
	}
	dfs2(1);
	dp2[1] = dp1[1];
	dfs3(1);
	for (register int i = 1; i <= n; i++){
		ans += dp2[i];
		add2(ans.first, len[i]);
		add2(ans.second, sum[i]);
	}
	return divide2(ans);
}

inline void sub2(int &x, int y){
	if ((x -= y) < 0) x += mod;
}

inline int lagrange(int n, int x[], int y[], int k){
	int ans = 0;
	pre[0] = 1;
	for (register int i = 1; i <= n; i++){
		pre[i] = 1ll * pre[i - 1] * sub1(k, x[i]) % mod;
	}
	suf[n + 1] = 1;
	for (register int i = n; i >= 1; i--){
		suf[i] = 1ll * suf[i + 1] * sub1(k, x[i]) % mod;
	}
	for (register int i = 1; i <= n; i++){
		if (!((n - i) & 1)){
			add2(ans, 1ll * y[i] * pre[i - 1] % mod * suf[i + 1] % mod * inv_fac[i - 1] % mod * inv_fac[n - i] % mod);
		} else {
			sub2(ans, 1ll * y[i] * pre[i - 1] % mod * suf[i + 1] % mod * inv_fac[i - 1] % mod * inv_fac[n - i] % mod);
		}
	}
	return ans;
}

inline Pair solve(int n, int k, int L){
	int m = 0;
	Pair ans(0, 0);
	a[++m] = L;
	for (register int i = 1; i <= n; i++){
		if (l[i] > L){
			int t = l[i] - k;
			a[++m] = l[i];
			if (t > L) a[++m] = t;
		}
		if (r[i] >= L){
			int t = r[i] - k + 1;
			a[++m] = r[i] + 1;
			if (t > L) a[++m] = t;
		}
	}
	sort(a + 1, a + m + 1);
	m = unique(a + 1, a + m + 1) - a - 1;
	for (register int i = 1; i < m; i++){
		int r_ = a[i] + k, up = a[i + 1] - 1, p = 0, q;
		for (register int j = 1; j <= n; j++){
			vis[j] = max(l[j], a[i]) <= min(r[j], r_);
		}
		for (register int j = 1; j <= n; j++){
			p = max(p, get_max_power(j, 0));
		}
		p += 2;
		q = p + 1;
		if (up - a[i] + 1 <= q){
			for (register int j = a[i]; j <= up; j++){
				ans += f(n, j, j + k);
			}
		} else {
			for (register int j = 1; j <= q; j++){
				Pair pr;
				x[j] = a[i] + j - 1;
				pr = f(n, x[j], x[j] + k);
				y1[j] = add1(y1[j - 1], pr.first);
				y2[j] = add1(y2[j - 1], pr.second);
			}
			add2(ans.first, lagrange(p, x, y1, up));
			add2(ans.second, lagrange(q, x, y2, up));
		}
	}
	return ans;
}

int main(){
	int n, k;
	Pair ans;
	cin >> n >> k;
	init(n + 2);
	for (register int i = 1; i <= n; i++){
		cin >> l[i] >> r[i];
	}
	for (register int i = 1; i < n; i++){
		int u, v;
		cin >> u >> v;
		add_edge(u, v);
		add_edge(v, u);
	}
	dfs1(1, 0);
	ans = solve(n, k, 1) - solve(n, k - 1, 2);
	cout << ans.first << endl;
	cout << ans.second;
	return 0;
}
```

---

## 作者：Purslane (赞：0)

# Solution

AH 貌似没有参加这次省选联考。下文中我把 $S=\{x|a \le x \le b,x \in \mathbb{Z}\}$ 简写为 $[a,b]$。

首先，考虑钦定最大值为 $v$，那我们只能填 $[v-k,v]$ 这一段区间内的数。但是你发现，如果实际之差为 $t \le k$，它会被计算 $k-t+1$ 次。然而 $1=(k-t+1)-(k-1-t+1)$，因此我们可以把 $k$ 和 $k-1$ 分别做一遍之后作差。所以不妨使用**树形 DP**，很容易做到 $O(nK)$，可以获得 $30$ 分（怎么这么少）。

考虑如果只有一个节点怎么做。实际上我们只需要分类讨论 $[l,r]$ 和 $[v-k,v]$ 的关系。不难发现，当 $k$ 确定的时候，$|[l,r] \cap [v-k,v]|$ 是关于 $v$ 的**分段一次函数**，而 $\sum_{x \in [l,r] \cap [v-k,v]} x$ 是关于 $v$ 的**分段二次函数**，且断点恰好是 $[l,r]$ 和 $[v-k,v]$ 的相对位置关系发生改变（相对位置关系包括相交，包含。本质上就是四个端点之间相对大小关系）处，最多有 $4$ 个端点。于是考虑把整个 $[0,10^9]$ 按这些端点分成最多 $4n$ 个区间，每个区间内每个节点上都是简单的一次函数和二次函数。

那么很容易想到，找出一条长度为 $l$ 的链，在单个的区间内，方案总数是一个关于 $v$ 的 $l$ 次多项式，权值和是关于 $v$ 的 $l+1$ 次多项式。那么整棵树的答案是所有链的答案的和，次数不变。$v$ 求和（从这个区间的下界求到上界），是一个关于上界的 $n+2$ 次多项式（两问都是，或者更少。）这启发我们可以拉格朗日插值。

所以现在问题直接转化为：给你 $v$，求这个状态下的两问的答案。化归为我们最开始的 $30$ 分做法。

这样复杂度就是 $O(n^3)$（你要预处理逆元，防止被卡常）。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=200+10,MOD=1e9+7;
int n,k,l[MAXN],r[MAXN],dp1[MAXN],dp2[MAXN],inv[MAXN],ans1,ans2,tot,lsh[MAXN*5];
int L[MAXN],R[MAXN],len[MAXN];
int cnt,x1[MAXN],y1145[MAXN],x2[MAXN],y2[MAXN],sum[MAXN];
vector<int> G[MAXN];
int qpow(int base,int p) {
	int ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;	
	}
	return ans;
}
void dfs1(int u,int f) {
	ans1=(ans1+len[u])%MOD,dp1[u]=len[u];
	for(auto v:G[u]) {
		if(v==f) continue;
		dfs1(v,u);
		ans1=(ans1+sum[u]*dp1[v]%MOD*len[u])%MOD;
		ans1=(ans1+dp1[v]*len[u])%MOD;
		dp1[u]=(dp1[u]+len[u]*dp1[v])%MOD;
		sum[u]=(sum[u]+dp1[v])%MOD;
	}
	return ;
}
void dfs2(int u,int f) {
	if(len[u]) {
		int v=((L[u]+R[u])*len[u]/2)%MOD,cnt=1,sum=1;
		for(auto v:G[u]) {
			if(v==f) cnt=(cnt+dp2[u]*sum)%MOD,sum=(sum+dp2[u])%MOD;
			else cnt=(cnt+dp1[v]*sum)%MOD,sum=(sum+dp1[v])%MOD;
		}
		ans2=(ans2+v*cnt)%MOD;
	}
	for(auto v:G[u]) if(v!=f) dp2[v]=(1+dp2[u]+sum[u]-dp1[v])*len[u]%MOD;
	for(auto v:G[u]) if(v!=f) dfs2(v,u);
	return ;
}
pair<int,int> calc(int k,int v) {
	memset(sum,0,sizeof(sum)),memset(dp1,0,sizeof(dp1)),memset(dp2,0,sizeof(dp2));	
	ans1=ans2=0;
	ffor(i,1,n) L[i]=max(l[i],v-k),R[i]=min(r[i],v),len[i]=max(0ll,R[i]-L[i]+1);
	dfs1(1,0),dfs2(1,0);
	return {ans1,ans2};
}
pair<int,int> lagrange(int pos) {
	int ans1=0,ans2=0;
	ffor(i,1,cnt) {
		int mul1=y1145[i],mul2=y2[i];
		ffor(j,1,cnt) if(i!=j) {
			if(i>j) mul1=mul1*(pos-x1[j])%MOD*inv[i-j]%MOD,mul2=mul2*(pos-x2[j])%MOD*inv[i-j]%MOD;
			else mul1=mul1*(-pos+x1[j])%MOD*inv[j-i]%MOD,mul2=mul2*(-pos+x2[j])%MOD*inv[j-i]%MOD;
		}
		ans1=(ans1+mul1)%MOD,ans2=(ans2+mul2)%MOD;
	}
	return {ans1,ans2};
}
pair<int,int> solve(int k) {
	tot=0; int ans1=0,ans2=0;
	ffor(i,1,n) lsh[++tot]=r[i]+1,lsh[++tot]=r[i]+k+1,lsh[++tot]=l[i],lsh[++tot]=l[i]+k+1;
	sort(lsh+1,lsh+tot+1),tot=unique(lsh+1,lsh+tot+1)-lsh-1;
	ffor(i,1,tot-1) {
		cnt=0; int pre1=0,pre2=0;
		ffor(j,lsh[i],min(lsh[i+1]-1,lsh[i]+n+1)) {
			auto pr=calc(k,j);
			x1[++cnt]=j,pre1=(pre1+pr.first)%MOD,y1145[cnt]=pre1;
			x2[cnt]=j,pre2=(pre2+pr.second)%MOD,y2[cnt]=pre2;
		}
		auto pr=lagrange(lsh[i+1]-1);
		ans1=(ans1+pr.first)%MOD,ans2=(ans2+pr.second)%MOD;
	}
	return {ans1,ans2};
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>k;
	ffor(i,1,n+1) inv[i]=qpow(i,MOD-2);
	ffor(i,1,n) cin>>l[i]>>r[i];
	ffor(i,1,n-1) {
		int u,v; cin>>u>>v;
		G[u].push_back(v),G[v].push_back(u);	
	}
	auto pr1=solve(k),pr2=solve(k-1);
	cout<<((pr1.first-pr2.first)%MOD+MOD)%MOD<<'\n';
	cout<<((pr1.second-pr2.second)%MOD+MOD)%MOD<<'\n';
	return 0;
}
```

---


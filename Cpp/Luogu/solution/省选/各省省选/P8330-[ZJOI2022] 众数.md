# [ZJOI2022] 众数

## 题目描述

九条可怜是一个有超能力的女孩子，但她的超能力只能作用于一些奇怪的事情上。

有一天，可怜得到了一个序列 $a_1, a_2, \ldots, a_n$，她可以对这个序列使用一次超能力: 选择一个区
间 $[l, r]$（$1 \le l \le r \le n$）和一个整数 $k \in [-{10}^9, {10}^9]$，将区间内的所有数 $a_l, a_{l + 1}, \ldots, a_r$ 加上 $k$。

九条可怜很喜欢长得比较一致的序列，因此她希望最终的序列众数的出现次数尽可能多。给出序列 $a$，你需要输出最终序列的众数出现次数的最大值，并输出这个众数的所有可能取值。注意对于一个序列，众数的取值可能不止一个。

## 说明/提示

对于所有测试点：$1 \le T \le 20$，$2 \le n \le 2 \times {10}^5$，$1 \le a_i \le {10}^9$，保证 $\sum n \le 5 \times {10}^5$，且 $a_i$ 不全相等。

每个测试点的具体限制见下表：

| 测试点编号 | $\sum n \le$ | $n \le$ | 特殊限制 |
|:-:|:-:|:-:|:-:|
| $1 \sim 4$ | $3000$ | $300$ | 无 |
| $5 \sim 8$ | $5 \times {10}^5$ | $2 \times {10}^5$ | $a_i$ 只有 $5$ 种取值 |
| $9 \sim 10$ | $2 \times {10}^5$ | $50000$ | 无 |
| $11 \sim 20$ | $5 \times {10}^5$ | $2 \times {10}^5$ | 无 |

## 样例 #1

### 输入

```
4
5
1 2 3 2 1
5
1 1 3 1 1
6
2 4 2 4 8 8
5
1 2 3 4 5
```

### 输出

```
4
1
5
1
4
2
4
8
2
1
2
3
4
5
```

## 样例 #2

### 输入

```
见附件中的 mode/mode_ex2.in```

### 输出

```
见附件中的 mode/mode_ex2.ans```

# 题解

## 作者：Alex_Wei (赞：24)

> [P8330 [ZJOI2022] 众数](https://www.luogu.com.cn/problem/P8330)

转化一下题意，求出将循环序列切成两段，每段区间众数出现次数之和的最大值。

一般 “**出现次数**” 都与 **根号分治** 挂钩，因为出现次数少的数可以直接考虑出现次数，出现次数多的数可以直接考虑每个数，这样就出现了根号。

将出现次数 $\geq B$ 的数成为大数，反之成为小数。

考虑大数在外侧的情况。枚举每个大数 $x$，先把所有 $x$ 选上，再考虑枚举内层的数 $y$，那么一段区间 $[l, r]$ 的贡献就是 $[l, r]$ 内 $y$ 的个数减去 $x$ 的个数。这是一个最大子段和问题。区间右端点必然可以调整至仅在 $y$ 出现的位置取到。

大数在内侧同理，只要先把所有 $y$ 选上，贡献取相反数即可。同理，此时区间右端点在 $y$ 出现的前一个位置取到。预处理 $[a_i = x]$ 的前缀和，这样对每个 $x$ 枚举所有 $y$ 的总复杂度就是线性，这部分是 $\dfrac {n ^ 2} B$。

接下来我们只关心小数配对小数的情况。如果确定了某个小数 $x$ 在外侧，那么容易证明内侧区间 $[l, r]$ 可以调整至满足 $l = 1$ 或 $a_{l - 1} = x$，且 $r = n$ 或 $a_{r + 1} = x$。这样一来，可能的内侧区间个数只有出现次数平方个。

这样我们只需求出区间 $[l, r]$ 的众数出现次数（甚至不需要具体值，因为最终内侧会变成外侧，也就是外侧的值才有用）。

普通地求 $q$ 次众数的时间复杂度是莫队或者分块的 $q\sqrt n$，放在本题肯定不行。

实际上还有一个性质没有用到，就是只需要众数出现次数 $\leq B$。我们对每个位置 $i$ 预处理出来使得 $[i, r]$ 的众数出现次数等于 $j$ 最小的 $r$（注意循环序列），记作 $p_{i, j}$。这个枚举出现次数然后 two-pointers。

这样查询区间 $[l, r]$ 的众数的时候只需要二分出现次数并判断是否有 $p_{l, mid} \leq r$ 即可在对数时间内求众数。可以通过 50pts。

更进一步地，考虑左端点 $l$ 固定，右端点右移的过程，$[l, r]$ 众数的出现次数一定不断增加。根据单调性用指针维护即可。对于每个左端点最多右移 $B$ 次右端点，而指针的移动次数均摊也是 $B$ 次，所以这部分时间复杂度 $\mathcal{O}(nB)$。

取 $B = \sqrt n$ 得到时空复杂度 $\mathcal{O}(n\sqrt n)$。注意大小为根号的那一维要放在前面，防止过多 cache miss（卡车丢失，大雾）导致 TLE。

- 一种空间复杂度线性的做法：考虑从左往右扫描线枚举右端点 $r$，时刻维护 $S_i$ 表示 $[i, r - 1]$ 的众数出现次数。跳过出现次数大于等于 $B$ 的 $a_r$。接下来讨论的 $a_r$ 的出现次数均小于 $B$。

  首先对于 $a_r$ 的所有出现位置 $l$，用 $l$ 之前 $a_r$ 的出现次数，加上 $r$ 之后 $a_r$ 的出现次数，加上 $S_{l + 1}$ 更新 $a_r$ 的答案。

  全部更新完毕后再将 $S_i$ 从 $[i, r - 1]$ 更新为 $[i, r]$，这部分可以再枚举 $a_r$ 的所有出现位置 $l$，用 $[l, r]$ 内 $a_r$ 的出现次数 $c$ 更新所有 $S_{1\sim l - 1}$。注意到 $S$ 的单调不增性，所以从 $l - 1$ 到 $1$ 枚举 $p$，一旦 $S_p\geq c$ 那么说明再往前更新也是无用的，可以 break 掉。

  由于每次 $p$ 向前移动都会使 $S$ 的总和至少增加 $1$，而 $S$ 的总和最终不超过 $nB$，所以总复杂度是线性根号。

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read() {
	int x = 0;
	char s = getchar();
	while(!isdigit(s)) s = getchar();
	while(isdigit(s)) x = x * 10 + s - '0', s = getchar();
	return x;
}
const int B = 200;
const int N = 2e5 + 5;
int n, a[N], d[N], ans[N], pointer[B][N];
vector <int> pos[N];
void solve() {
	cin >> n;
	for(int i = 1; i <= n; i++) pos[i].clear(), ans[i] = 0;
	for(int i = 1; i <= n; i++) scanf("%d", &a[i]), d[i] = a[i];
	sort(d + 1, d + n + 1);
	for(int i = 1; i <= n; i++) pos[a[i] = lower_bound(d + 1, d + n + 1, a[i]) - d].push_back(i);
	for(int i = 1; i <= n; i++) {
		if(pos[i].size() < B) continue;
		static int pre[N];
		memset(pre, 0, sizeof(pre));
		for(int it : pos[i]) pre[it] = 1;
		for(int p = 1; p <= n; p++) pre[p] += pre[p - 1];
		for(int j = 1; j <= n; j++) {
			if(i == j) continue;
			int mx = 1, cur = 1;
			for(int ind = 1; ind < pos[j].size(); ind++) mx = max(mx, cur = max(1, cur - (pre[pos[j][ind]] - pre[pos[j][ind - 1]]) + 1));
			ans[i] = max(ans[i], mx + (int) pos[i].size());
			mx = cur = 0;
			for(int ind = 1; ind < pos[j].size(); ind++) {
				mx = max(mx, cur += pre[pos[j][ind]] - pre[pos[j][ind - 1]]);
				cur = max(0, cur - 1);
			}
			ans[j] = max(ans[j], mx + (int) pos[j].size());
		}
	}
	int limit = 0;
	for(int i = 1; i <= n; i++) limit = max(limit, (int) pos[i].size());
	limit = min(limit, B - 1);
	for(int i = 1; i <= limit; i++) {
		static int buc[N], mode;
		memset(buc, mode = 0, sizeof(buc));
		for(int l = 1, r = 0; l <= n; buc[a[l++]]--) {
			while(buc[mode] < i) {
				buc[a[r = r < n ? r + 1 : 1]]++;
				if(buc[a[r]] > buc[mode]) mode = a[r];
			}
			pointer[i][l] = r;
		}
	}
	for(int i = 1; i <= n; i++) {
		if(pos[i].size() > limit) continue;
		for(int j = 0; j < pos[i].size(); j++) { // 枚举左端点 l.
			for(int k = 1; k <= limit; k++) if(pointer[k][1] < pos[i][j]) ans[i] = max(ans[i], (int) pos[i].size() - j + k); // 先处理一下 l = 1 的情况.
			int pt = j, p = pos[i][j] + 1;
			if(p > n) continue;
			for(int k = 1; k <= limit; k++) { // 这里不同于题解的是, 我从小到大枚举出现次数, 用指针维护最小的合法右端点, 本质没有太大差别.
				if(pointer[k][p] < p) break; // 如果要绕过去变成外侧就不行了.
				while(pt < pos[i].size() && pos[i][pt] <= pointer[k][p]) pt++; // 出现次数增大使得右端点右移.
				ans[i] = max(ans[i], j + k + 1 + (int) pos[i].size() - pt);
			}
		}
	}
	int mx = 0;
	for(int i = 1; i <= n; i++) mx = max(mx, ans[i]);
	cout << mx << endl;
	for(int i = 1; i <= n; i++) if(ans[i] == mx) printf("%d\n", d[i]);
}
int main() {
	int T;
	cin >> T;
	while(T--) solve();
	return cerr << clock() << endl, 0;
}
/*
2022/5/8
start thinking at ??:??
高妙根号分治题.
先处理大块与大块和小块.
再处理小块之间的情况.
写一个 sqrt log 试试看.
又 T 又 WA, 我不理解.
start coding at 14:42
交换 N, B 两维跑得飞快啊.
实际上将 B 开小一点效率会比较高, 因为对于小数的处理用了巨大的二维数组, 实在是太慢了.
finish debugging at 16:21
*/
```

---

## 作者：JoshAlMan (赞：24)

都有众数了，，，感觉就不能 polylog！

就是选一段区间，算出他里面的众数 + 外面的众数最大值，然后这个贡献是外面众数颜色的。

考虑对每种颜色大小根号分治，暂且以 $\sqrt{n}$ 为界。

对于 $> \sqrt{n}$ 的颜色，可以 $O(n)$ 暴力做，先预处理关于这个颜色的前缀和，可以快速求出一段区间有多少这个颜色，可以枚举每种另外一个颜色，然后用 $O(这个颜色大小)$ 的复杂度算出他在两边或者在中间的贡献。复杂度 $O(n \sqrt{n})$

于是我们只剩下了两两都是 $\le \sqrt{n}$  的。

考虑我们可以暴力枚举选的区间左右端点了，因为如果两边都有数，两边外面都是这个颜色一定不劣。考虑扫描线，枚举选的右端点，然后暴力枚举这个颜色前面所有出现的位置当左端点。

然后我们要快速算这之间的众数，似乎不太能做，但其实我们只用考虑出现次数 $\le \sqrt{n}$ 的颜色就行，答案也肯定不超过根号。

于是我们可以开个数组 $S_i$ 表示现以 $i$ 为左端点的众数（只管次数小于根号的），考虑更新的时候也是暴力枚举他的之前所有颜色的位置 $j$，考虑之间有 $k$ 个这个颜色的，需要做的就是对 $S_{1 \sim j}$ 对 $k$ 进行 $\text{chkMax}$，我们发现 $S$ 数组是不增的，并且值域不超过根号，那其实能 $\text{chkMax}$ 就往前跳，不能就停就好了，考虑每次 chkMax 至少使 $S$ 总和 $+1$，而最终 $S$ 总和不会超过 $n \sqrt {n}$，那么复杂度就是对的。

综上，因为两侧都达到了上届，所以分块界是合适的（这范围也不太可能有 $\log$ 了。。

还要注意一些细节，例如两边可能只有一边有这个颜色，还得正反扫一遍？

总复杂度 $O(n \sqrt {n})$

```cpp
// Skyqwq
#include <bits/stdc++.h>

#define pb push_back
#define fi first
#define se second
#define mp make_pair

using namespace std;

typedef pair<int, int> PII;
typedef long long LL;

template <typename T> bool chkMax(T &x, T y) { return (y > x) ? x = y, 1 : 0; }
template <typename T> bool chkMin(T &x, T y) { return (y < x) ? x = y, 1 : 0; }

template <typename T> void inline read(T &x) {
    int f = 1; x = 0; char s = getchar();
    while (s < '0' || s > '9') { if (s == '-') f = -1; s = getchar(); }
    while (s <= '9' && s >= '0') x = x * 10 + (s ^ 48), s = getchar();
    x *= f;
}

const int N = 2e5 + 5;

int n, a[N], b[N], len, d[N], t, ans, w[N], B, s[N], pos[N], L[N], R[N], loc[N], cnt[N];

int S[N];

int inline get(int x) {
    return lower_bound(b + 1, b + 1 + len, x) - b;
}

vector<int> c[N];

void inline pr() {
    for (int i = 1; i <= n; i++) b[i] = a[i];
    len = n;
    sort(b + 1, b + 1 + len);
    len = unique(b + 1, b + 1 + len) - b - 1;
    for (int i = 1; i <= len; i++) w[i] = 0;
    for (int i = 1; i <= n; i++) a[i] = get(a[i]);
    for (int i = 1; i <= n; i++) loc[i] = c[a[i]].size(), c[a[i]].pb(i);
    B = sqrt(n);
    // B = 1;
    for (int i = 1; i <= n; i++) {
        pos[i] = (i - 1) / B + 1;
        if (!L[pos[i]]) L[pos[i]] = i;
        R[pos[i]] = i;
    }
}

// x 在两边，x 前缀和 s，y 在中间

void inline wk1(int x, int y) {
    int v = -1e9, ret = 0;
    for (int A = 0; A < (int)c[y].size(); A++) {
        chkMax(v, -A + s[c[y][A] - 1]);
        chkMax(ret, v + A + 1 + s[n] - s[c[y][A]]);
    }
    chkMax(w[x], ret);
}

// y 在两边，x 在中间，x 前缀和 s

void inline wk2(int x, int y) {
    int v = -1e9, ret = 0;
    for (int A = 0; A < (int)c[y].size(); A++) {
        chkMax(ret, v + s[c[y][A] - 1] + (int)c[y].size() - A + 1);
        chkMax(v, A + -s[c[y][A]]);
        chkMax(ret, s[c[y][A] - 1] + (int)c[y].size() - A);
        chkMax(ret, A + 1 + s[n] - s[c[y][A]]);
    }
    chkMax(w[y], ret);
}

void inline big() {
    for (int i = 1; i <= len; i++) {
        if ((int)c[i].size() > B) {
            for (int j = 1; j <= n; j++) s[j] = 0;
            for (int v: c[i]) s[v] = 1;
            for (int j = 1; j <= n; j++) s[j] += s[j - 1];
            for (int j = 1; j <= len; j++)
                if (i != j) wk1(i, j);
            for (int j = 1; j <= len; j++)
                if ((int)c[j].size() <= B) wk2(i, j);
        }
    }
}

void inline upd(int x, int y) {
    while (x && S[x] < y) {
        S[x] = y;
        --x;
    }
}

void inline small() {
    for (int i = 1; i <= n; i++) {
        if ((int)c[a[i]].size() <= B) {
            // do calc
            int val = (int)c[a[i]].size() - loc[i] + S[1];
            for (int j = loc[i] - 1; j >= 0; j--) {
                int p = c[a[i]][j];
                chkMax(val, j + 1 + (int)c[a[i]].size() - loc[i] + S[p + 1]);
            }
            chkMax(w[a[i]], val);
            // do upd
            for (int j = loc[i]; j >= 0; j--)
                upd(c[a[i]][j], loc[i] - j + 1);
        }
    }
    int mx = 0;
    for (int i = n; i; i--) {
        chkMax(w[a[i]], mx + loc[i] + 1);
        cnt[a[i]]++;
        chkMax(mx, cnt[a[i]]);
    }
}

void inline out() {
    ans = 0;
    for (int i = 1; i <= len; i++)
        chkMax(ans, w[i]);
    for (int i = 1; i <= len; i++)
        if (w[i] == ans) d[++t] = b[i];
    printf("%d\n", ans);
    sort(d + 1, d + 1 + t);
    t = unique(d + 1, d + 1 + t) - d - 1;
    for (int i = 1; i <= t; i++) printf("%d\n", d[i]);
}

void inline clr() {
    for (int i = 1; i <= len; i++) c[i].clear();
    for (int i = 1; i <= n; i++) cnt[i] = 0, S[i] = 0, pos[i] = L[i] = R[i] = w[i] = 0;
    ans = 0;
    t = 0;
    len = 0;
}

int main() {
    //freopen("mode.in", "r", stdin);
    //freopen("mode.out", "w", stdout);
    int T; read(T);
    while (T--) {
        read(n); 
        for (int i = 1; i <= n; i++) read(a[i]);
        pr();
        big();
        small();
        out();
        clr();
    }
    return 0;
}


```

---

## 作者：dead_X (赞：19)

## 前言
这哪有黑啊……
## 思路
显然一定是在不在子区间里的选出现次数最多的，在子区间里选出现次数最多的，然后转过去。

暴力 A：扫所有区间判断，时间复杂度 $O(\frac{n^3}{w})$，因为要储存出现 $x$ 次的数的集合。

暴力 B：枚举从 $x$ 变成 $y$的答案，可以双指针扫一遍，复杂度 $O(cn)$，$c$ 为颜色数。

根号分治：对于出现次数大于 $B$ 的跑暴力 B，不然跑暴力 A。

然而暴力 A 还是没法处理小区间，我们要再改一下。

注意到暴力 B 可以处理大大之间和大小之间，所以暴力 A 中两个区间的出现次数都小于等于 $B$。

我们可以处理对于每个左端点，使得一个数出现 $d=1,2,\cdots,B$ 次的最小右端点，时间复杂度 $O(nB)$。

这样我们只需要枚举每种数，去掉哪一个区间，去掉这一个区间后能多出几个数即可，时间复杂度 $O(nB)$。

暴力 B 时间复杂度 $O(\frac{n^2}{B})$，所以总复杂度 $O(n\sqrt n)$。

具体实现可以看看代码。
## 代码
```cpp
//Take me with you Miss Diana
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline int read()
{
	int r=0;
	char c=getchar();
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') r=r*10+c-48,c=getchar();
	return r;
}
int a[200003],lsh[200003],ans[200003],pre[200003],cnt[200003];
int g[200003][449];
vector<int> c[200003];
const int B=449;
signed main()
{
	for(int T=read(); T--;)
	{
		int n=read();
		for(int i=1; i<=n; ++i) lsh[i]=a[i]=read();
		sort(lsh+1,lsh+n+1);
		int m=unique(lsh+1,lsh+n+1)-lsh-1;
		for(int i=1; i<=n; ++i) a[i]=lower_bound(lsh+1,lsh+m+1,a[i])-lsh;
		for(int i=1; i<=m; ++i) c[i].clear(),ans[i]=0;
		for(int i=1; i<=n; ++i) c[a[i]].push_back(i);
		for(int i=1; i<=m; ++i) if(c[i].size()>=B)
		{
			for(int j=1; j<=n; ++j) pre[j]=pre[j-1]+(a[j]==i);
			for(int j=1; j<=m; ++j) if(i!=j)
			{
				int mx=-1,mn=0,idx=0;
				for(int k:c[j]) 
					--idx,ans[i]=max(ans[i],mx-pre[k]-idx+1),ans[j]=max(ans[j],pre[k]+idx-mn+1),
					mx=max(mx,pre[k]+idx),mn=min(mn,pre[k]+idx);
				ans[i]=max(ans[i],mx-pre[n]-idx+1),--idx,ans[j]=max(ans[j],pre[n]+idx-mn+1);
			}
		}
		for(int i=1; i<=n+1; ++i)
			for(int j=1; j<B; ++j)
				g[i][j]=0x3f3f3f3f;
		for(int i=1; i<=m; ++i) if(c[i].size()<B)
		{
			int sz=c[i].size();
			for(int j=0; j<sz; ++j)
				for(int k=j; k<sz; ++k)
					g[c[i][j]][k-j+1]=min(g[c[i][j]][k-j+1],c[i][k]);
		}
		for(int i=n; i>=1; --i)
			for(int j=1; j<B; ++j)
				g[i][j]=min(g[i][j],g[i+1][j]);
		for(int i=1; i<=m; ++i) if(c[i].size()<B)
		{
			int sz=c[i].size();
			for(int k=1,o=0; k<B&&g[1][k]!=0x3f3f3f3f; ++k)
			{
				while(o<sz&&g[1][k]>=c[i][o]) ++o;
				ans[i]=max(ans[i],k-o);
			}
			for(int j=0; j<sz; ++j) //after the i-th element
				for(int A=c[i][j]+1,k=1,o=j+1; k<B&&g[A][k]!=0x3f3f3f3f; ++k)
				{
					while(o<sz&&g[A][k]>=c[i][o]) ++o;
					ans[i]=max(ans[i],k-o+j+1);
				}
		}
		for(int i=1; i<=m; ++i) ans[i]+=(int)c[i].size();
		int mx=0;
		for(int i=1; i<=m; ++i) if(ans[i]>mx) mx=ans[i];
		printf("%d\n",mx); 
		for(int i=1; i<=m; ++i) if(ans[i]==mx) printf("%d\n",lsh[i]);
	}
	return 0;
}
```

---

## 作者：FjswYuzu (赞：11)

大家好，我不会根号实锤了。

因为跟众数有关并且看起来就要对所有种类的数求一个答案，可以直接考虑根号算法。

没有什么好的分块思路，不妨根号分治。按数的种类处理，按大小分治：

- 出现次数大于 $\sqrt n$：这种数最多 $O(\sqrt n)$ 个，颜色是 $O(n)$ 个的，每种颜色处理一下就是 $O(n \sqrt n)$ 的；   
- 出现次数小于等于 $\sqrt n$：记其出现位置为 $p_0=0,p_1,p_2,\cdots ,p_k,p_{k+1}=n+1$，那么改 $(p_i, p_j)$ 对这种数来说最优，枚举 $i,j$，总时间复杂度分析后可知是 $O(n \sqrt n)$ 的。

然后先处理出现次数大于 $\sqrt n$ 的。假设这种颜色为 $p$，我们试图把 $p$ 改成 $q$ 更新 $q$，或是把 $q$ 改成 $p$ 更新 $p$。维护 $p$ 出现次数的前缀和直接处理，这是简单的。

然后再处理出现次数不大于 $\sqrt n$ 的数。注意到一点是在上面的处理中我们处理了一个出现次数大于 $\sqrt n$ 的数 $p$ 改成出现次数不大于 $\sqrt n$ 的数 $q$，所以在这里只考虑两个数出现次数都不大于 $\sqrt n$ 的。

那么相当于做 $O(n \sqrt n)$ 次区间众数。但是有一点是每个数出现次数都是不大于 $O(\sqrt n)$ 的。那么记 $s_i$ 为 $[i,n]$ 的众数出现次数，容易发现 $\sum s_i = O(n \sqrt n)$ 的，其支持暴力维护。

暴力枚举 $[l,r]$。现在已经枚举了 $r$，再枚举 $l$。容易发现我们可以根据上面分讨得出的一个简单小结论优化枚举过程，也就是保证 $l-1$ 和 $r$ 颜色一样，或者 $l=1$ 即可。显然 $s_i \geq s_{i-1}$，我们可以暴力更新 $[i,r]$ 的区间众数，更新次数不大于 $O(n \sqrt n)$，可以保证复杂度。

代码比题解清楚。

```cpp
void SmChunk()
{
    for(int i=1;i<=n;++i)   sum[i]=0;
    for(int i=1;i<=n;++i)
    {
        if(app[a[i]]<=Sqr)
        {
            int p=lower_bound(Pos[a[i]].begin(),Pos[a[i]].end(),i)-Pos[a[i]].begin();
            for(int j=p;~j;--j)
            {
                int l=j?Pos[a[i]][j-1]+1:1,r=Pos[a[i]][j];
                maxn[a[i]]=max(maxn[a[i]],sum[l]-(p-j));
                while(l<=r && sum[r]<p-j+1) sum[r--]=p-j+1;
            }
        }
    }
}
void Solve()
{
    n=read();
    for(int i=1;i<=n;++i)   a[i]=b[i]=read();
    sort(b+1,b+1+n);
    len=unique(b+1,b+1+n)-b-1;
    for(int i=1;i<=n;++i)   a[i]=lower_bound(b+1,b+1+len,a[i])-b;
    for(int i=1;i<=len;++i) app[i]=0,Pos[i].clear(),maxn[i]=0;
    for(int i=1;i<=n;++i)   ++app[a[i]],Pos[a[i]].push_back(i);
    for(int p=1;p<=len;++p)
    {
        if(app[p]>Sqr)
        {
            for(int i=1;i<=n;++i)   sum[i]=sum[i-1]+int(a[i]==p);
            for(int q=1;q<=len;++q)
            {
                int N=app[q],l,s;
                l=s=0;
                for(int i=0;i<N;++i)
                {
                    int r=Pos[q][i];
                    s=max(0,s-(sum[r]-sum[l]))+1;
                    maxn[p]=max(maxn[p],s);
                    l=r;
                }
                l=s=0;
                for(int i=0;i<N;++i)
                {
                    int r=Pos[q][i];
                    s=max(0,s)+sum[r]-sum[l];
                    maxn[q]=max(maxn[q],s--);
                    l=r;
                }
            }
        }
    }
    SmChunk();
    reverse(a+1,a+1+n);
    for(int i=1;i<=len;++i)
    {
        reverse(Pos[i].begin(),Pos[i].end());
        for(auto &st:Pos[i])    st=n-st+1;
    }
    SmChunk();
    for(int i=1;i<=len;++i) maxn[i]+=app[i];
    int ans=0;
    for(int i=1;i<=len;++i) ans=max(ans,maxn[i]);
    write(ans),puts("");
    for(int i=1;i<=len;++i) if(maxn[i]==ans)    write(b[i]),puts("");
}
```

---

## 作者：whiteqwq (赞：8)

[P8330 [ZJOI2022] 众数](https://www.luogu.com.cn/problem/P8330) 解题报告：

[更好的阅读体验](https://www.cnblogs.com/xiaoziyao/p/16219543.html)

## 题意

给定一个长度为 $n$ 的序列，你能对它进行一次区间加，最大化众数出现次数。

$1\leqslant n\leqslant 2\times 10^5$。

## 分析

ZJOI T2，传统签到题！场外选手来口胡一下。

显然答案的形态就是 aaabbbaaa，考虑对颜色出现次数根号分治：

- a/b 存在一个是大颜色：枚举每一个大颜色，扫一遍序列，对每种颜色维护一个极长的 aaabbb 段以及一个 bbbaaa 段即可。
- a/b 均为小颜色：枚举处于外面的颜色，那么问题转化为 $O(n\sqrt n)$ 次区间众数。但此时众数大小不超过根号，我们将询问有序地挂在右端点，枚举众数出现次数，移动右端点并维护符合条件最靠后的左端点，弹符合要求的询问就好了。

这样就做到了 $O(n\sqrt n)$。

## 代码

咕了。

---

## 作者：Little09 (赞：7)

众所周知，ZJOI 的签到题一般在 D1T2。

没去 ZJOI，在家口胡的。想了一会似乎就会根号做法了。真难受没得去省选，本来可能会是考场上做出的第一个黑吧。

------------


原题是选择一段区间 $[l,r]$，使得 $[l,r]$ 内的众数次数与除去此段区间外的众数次数的和最大，此时众数答案是 $[l,r]$ 外的任何一个众数。

根号分治。设 $B=\sqrt n$。考虑颜色出现次数不超过 $B$ 的是 A 类，否则是 B 类。我们枚举一下 $[l,r]$ 外的众数是 $x$。

1. 内部的众数是 A 类。此时内部的众数次数必然不超过 $B$。

枚举内部众数出现次数 $k$，此时只要让 $[l,r]$ 内答案是 $k$ 且 $x$ 的出现次数最小就行了。对于每个 $k$，预处理好位置 $i$ 的颜色的之前第 $k$ 个出现位置 $pre_{i}$。考虑所有相邻 $x$ 的位置之间的间隔，找到这里 $pre$ 的最大值就行了。然后用双指针找一下当前 $pre$ 的最大值位于哪个间隔，就可以计算。


2. 内部的众数是 B 类。此时内部的众数种类不超过 $B$。

枚举当前内部众数是 $y$。假设每个 $x$ 是 $+1$，每个 $y$ 是 $-1$，目标是找到 $l,r$ 使得 $[1,l]+[r,n]$ 最大。所以 $l,r$ 必然落在 $+1$ 上，前缀和一下可以用 $x$ 的次数次检查完成。

总复杂度 $O(n\sqrt n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
const int N=2e5+5,B=447;
struct point
{
	int x,id;
}b[N];
int a[N],ans[N],c[N],col[N],pre[N],d[N];
int A[N],C[N],cnta,cntc,sum[N];
vector<int>g[N];
bool cmp(point x,point y)
{
	return x.x<y.x;
}
inline int read()
{
	char C=getchar();
	int F=1,ANS=0;
	while (C<'0'||C>'9')
	{
		if (C=='-') F=-1;
		C=getchar();
	}
	while (C>='0'&&C<='9')
	{
		ANS=ANS*10+C-'0';
		C=getchar();
	}
	return F*ANS;
}
void work()
{
	n=read();
	for (int i=1;i<=n;i++) b[i].id=i,b[i].x=read();
	sort(b+1,b+n+1,cmp);
	m=0;
	int gp=0; 
	for (int i=1;i<=n;i++)
	{
		if (i==1||b[i].x!=b[i-1].x) c[++m]=b[i].x;
		a[b[i].id]=m;
	}
	for (int i=1;i<=m;i++) ans[i]=0,col[i]=0;
	for (int i=1;i<=m;i++) g[i].clear();
	for (int i=1;i<=n;i++) col[a[i]]++,g[a[i]].push_back(i),d[i]=col[a[i]];
	cnta=0,cntc=0;
	int b=0;
	for (int i=1;i<=m;i++)
	{
		gp=max(gp,col[i]);
		if (col[i]>B) A[++cnta]=i;
		else C[++cntc]=i,b=max(b,col[i]);
	}
	for (int j=1;j<=cnta;j++)
	{
		int v=A[j];
		for (int i=1;i<=n;i++) sum[i]=0;
		for (int i:g[v]) sum[i]=-1;
		for (int i=1;i<=n;i++) sum[i]+=sum[i-1];
		for (int u=1;u<=m;u++)
		{
			int res=0,tot=0;
			for (int i:g[u])
			{
				ans[u]=max(ans[u],col[v]+col[u]-res+sum[n]-sum[i-1]+tot);
				res++;
				tot=max(tot,res+sum[i]);
			}
			ans[u]=max(ans[u],tot+col[v]);
		}
	}
	int res=0;
	for (int i=1;i<=m;i++) res=max(res,ans[i]);
	for (int k=1;k<=b;k++)
	{
		if (k+gp<res) continue;
		pre[0]=-1;
		for (int i=1;i<=n;i++)
		{
			if (d[i]-k<=-1) pre[i]=-1;
			else pre[i]=g[a[i]][d[i]-k];
		}
		for (int i=2;i<=n;i++) pre[i]=max(pre[i-1],pre[i]);
		for (int u=1;u<=m;u++)
		{
			int res=0,tot=0;
			for (int i:g[u])
			{
				int p=pre[i-1];
				if (p==-1)
				{
					res++;
					continue;
				}
				while (tot<col[u]&&p>g[u][tot]) tot++;
				ans[u]=max(ans[u],k+col[u]-(res-tot));
				res++;
			}
			if (pre[n]!=-1) 
			{
				int p=pre[n];
				while (tot<col[u]&&p>g[u][tot]) tot++;
				ans[u]=max(ans[u],k+col[u]-(res-tot));
			}
		}
	}
	for (int i=1;i<=m;i++) res=max(res,ans[i]);
	printf("%d\n",res);
	for (int i=1;i<=m;i++)
	{
		if (ans[i]==res) printf("%d\n",c[i]);
	}
}
int main()
{
	int T=read();
	while (T--) work();
	return 0;
}
```


---

## 作者：xyf007 (赞：6)

考场上 $O(n^{5/3})$ 的暴力做法，但是他过了。

看到众数，考虑根号分治。我们的操作肯定是选一个值 $x$，选一个区间 $[l,r]$，然后把区间众数改成 $x$，区间内的 $x$ 改成其他值。  
对于出现次数 $\ge B$ 的数 $x$，可以考虑枚举区间众数的取值 $y$，然后把一个区间中的 $y$ 全部改成 $x$。注意到最优方案两端肯定都是 $y$，不然区间向里缩，增量不变而内部 $x$ 可能减少。同时也可以不强制是区间众数，直接考虑所有两端相同的区间，对于每一种数开桶存前缀和即可做到单次 $O(n)$，总复杂度 $O\left(\dfrac{n^2}{B}\right)$。  
对于出现次数 $<B$ 的数，考虑枚举修改的区间。这时候只有包含 $x$ 数量不同的区间才有区别，出现次数相同的区间肯定是越长越好，这样区间众数出现次数会变多。于是直接使用莫队求区间众数。根据均值不等式，最多有 $O(nB)$ 个区间，时间复杂度 $O(n\sqrt{nB})$。取 $B=O(n^{1/3})$，时间复杂度 $O(n^{5/3})$。

考场代码
```cpp
#include <algorithm>
#include <cmath>
#include <cstring>
#include <fstream>
#include <iostream>
#include <vector>
void checkmax(int &x, int y) {
  if (x < y) x = y;
}
void checkmin(int &x, int y) {
  if (x > y) x = y;
}
std::ifstream fin("mode.in");
std::ofstream fout("mode.out");
int n, a[200001], b[200001], c[200001], ans, c1[200001], mn[200001], c2[200001];
std::vector<int> pos[200001];
int CalcBig(int x) {
  for (int i = 1; i <= n; i++) c2[i] = c2[i - 1] + (a[i] == x);
  std::memset(mn, 0x3f, 4 * n);
  int maxd = 0;
  for (int i = 1; i <= n; i++) {
    if (a[i] == x) continue;
    c1[a[i]]++;
    checkmin(mn[a[i]], c1[a[i]] - 1 - c2[i - 1]);
    checkmax(maxd, c1[a[i]] - c2[i] - mn[a[i]]);
  }
  return c[x] + maxd;
}
struct Node {
  int l, r, d;
} d[3000001];
int tot, bel[200001], ct[200001], cc[200001], maxc, dt[200001];
void CalcSmall(int x) {
  for (std::size_t i = 0; i < pos[x].size(); i++) {
    if (pos[x][i] > 1) d[++tot] = {1, pos[x][i] - 1, (int)i};
    for (std::size_t j = 0; j < i; j++)
      if (pos[x][j] + 1 < pos[x][i])
        d[++tot] = {pos[x][j] + 1, pos[x][i] - 1, (int)(i - j - 1)};
    if (pos[x][i] < n)
      d[++tot] = {pos[x][i] + 1, n, (int)(pos[x].size() - i - 1)};
  }
}
inline void Add(int x) {
  cc[ct[x]++]--, cc[ct[x]]++;
  checkmax(maxc, ct[x]);
}
inline void Del(int x) {
  cc[ct[x]--]--, cc[ct[x]]++;
  if (cc[maxc] == 0) maxc--;
}
void Mo() {
  int MoB = n / std::sqrt(tot + 1) + 1;
  for (int i = 1; i <= n; i++) bel[i] = (i - 1) / MoB + 1;
  std::sort(d + 1, d + tot + 1, [](const Node &lhs, const Node &rhs) {
    return bel[lhs.l] == bel[rhs.l]
               ? bel[lhs.l] & 1 ? lhs.r < rhs.r : lhs.r > rhs.r
               : bel[lhs.l] < bel[rhs.l];
  });
  std::memset(ct + 1, 0, 4 * n);
  std::memset(cc + 1, 0, 4 * n);
  maxc = 0;
  for (int l = 1, r = 0, i = 1; i <= tot; i++) {
    while (r < d[i].r) Add(a[++r]);
    while (l > d[i].l) Add(a[--l]);
    while (r > d[i].r) Del(a[r--]);
    while (l < d[i].l) Del(a[l++]);
    int id = r < n ? a[r + 1] : a[l - 1];
    checkmax(dt[id], maxc - d[i].d);
  }
}
void Solve() {
  std::cin >> n;
  for (int i = 1; i <= n; i++) std::cin >> a[i];
  std::memcpy(b + 1, a + 1, 4 * n);
  std::sort(b + 1, b + n + 1);
  int nn = std::unique(b + 1, b + n + 1) - b - 1;
  for (int i = 1; i <= n; i++)
    a[i] = std::lower_bound(b + 1, b + nn + 1, a[i]) - b;
  std::memset(c + 1, 0, 4 * nn);
  for (int i = 1; i <= n; i++) c[a[i]]++;
  int B = std::pow(n, 1.0 / 3.0) + 1;
  for (int i = 1; i <= nn; i++) pos[i].clear();
  for (int i = 1; i <= nn; i++)
    if (c[i] < B) pos[i].reserve(c[i]);
  for (int i = 1; i <= n; i++)
    if (c[a[i]] < B) pos[a[i]].emplace_back(i);
  ans = tot = 0;
  std::vector<int> sol;
  for (int i = 1; i <= nn; i++)
    if (c[i] >= B) {
      int cnt = CalcBig(i);
      if (cnt > ans) {
        ans = cnt;
        std::vector<int>(1, i).swap(sol);
      } else if (cnt == ans) {
        sol.emplace_back(i);
      }
    } else {
      CalcSmall(i);
    }
  std::memset(dt + 1, 0, 4 * nn);
  Mo();
  for (int i = 1; i <= nn; i++)
    if (c[i] < B) {
      if (c[i] + dt[i] > ans) {
        ans = c[i] + dt[i];
        std::vector<int>(1, i).swap(sol);
      } else if (c[i] + dt[i] == ans) {
        sol.emplace_back(i);
      }
    }
  std::sort(sol.begin(), sol.end());
  std::cout << ans << '\n';
  for (const auto x : sol) std::cout << b[x] << '\n';
}
int main(int argc, char const *argv[]) {
  std::cin.rdbuf(fin.rdbuf()), std::cout.rdbuf(fout.rdbuf());
  int T;
  std::cin >> T;
  while (T--) Solve();
  return 0;
}
```

---

## 作者：Eraine (赞：4)

来源：浙江省选 2022

编号：P8330

tag：根号分治

难度：紫

没怎么理解题解区大佬的题解，若有重复请见谅。

考虑最终答案的形态。$x$ 为最终众数的答案必然为 $x\dots x,x-k\dots x-k,x\dots x$。前后两段 $x$ 不一定要同时出现，但是至少要出现一段（不然就变成一些数变成左右段序列没有出现过的数就不会更优，容易证明一定有比完全更优的解）。

wjz 学长说的很有道理，**出现次数** 一般和 **根号分治** 挂钩。所以我们考虑对用一种颜色出现次数进行根号分治。设阈值为 $B$。

当 $cnt_p\gt B$ 时，把这些颜色单独拎出来做。具体地，处理颜色 $p$ 的前后缀出现次数，然后对于每一种其他颜色 $i$，处理出类似 $i\dots i,p\dots p,i\dots i$ 和 $p\dots p,i\dots i,p\dots p$ 形态的的答案并分别对 $ans_i,ans_p$ 进行贡献。这很好处理，对于 $i\dots i,p\dots p,i\dots i$，处理出每个 $i$ 作为左段右端点和右端左端点对答案产生的影响 $sum_i-sum_p$。处理前后缀 $\max$ 很容易做到线性。故这部分总时间复杂度为 $\Theta(\frac{n^2}{B})$。

当 $cnt_p\le B$ 时，考虑到此时只剩左右段和中间段出现次数均 $\le B$ 的情况。固定中间段的右端点发现最优中间段仅有 $B$ 种，即其他颜色分别出现 $1\sim B$ 次。接下来只要考虑如何统计颜色 $p$ 作为左右段颜色的贡献和颜色 $p$ 作为中间段颜色的贡献。右端点扫描线，$f_i$ 表示当前节点作为右端点，其他颜色作为中间段出现 $i$ 次的最大左端点，每遍历到一个颜色就对这个大小为 $B$ 的数组进行遍历更新。考虑 $p$ 作为左右段颜色产生贡献，只需枚举 $p$ 位置集合元素作为左端点时最大的 $i$ 满足 $f_i\ge L$。由于 $f_i$ 单调递减，所以在倒序遍历颜色 $p$ 集合的同时放一个指针在 $f$ 数组上跑，类似双指针的思想。可以发现每个元素最多贡献 $\Theta(\max(B,cnt_p))$。故总时间复杂度为 $\Theta(nB)$。

注意有可能区间不恰好包含在两个同颜色元素之间，所以单独前后缀处理一下即可。

当 $B$ 取 $\sqrt{n}$ 有最优复杂度。

$\Theta(n\sqrt{n})$。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
const int K=455;
const int inf=1e9;
int n,a[N],num,B;
int cnt[N];
int m,tmp[N];
vector<int>lnk[N];
int ans[N];
void init(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        lnk[i].clear();
        ans[i]=0;
        cnt[i]=0;
    }
    m=n;
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        tmp[i]=a[i];
    }
    sort(tmp+1,tmp+m+1);
    m=unique(tmp+1,tmp+m+1)-tmp-1;
    for(int i=1;i<=n;i++){
        a[i]=lower_bound(tmp+1,tmp+m+1,a[i])-tmp;
        lnk[a[i]].push_back(i);
        ++cnt[a[i]];
    }
    B=sqrt(n*1.0);
}
int f[N],g[N],F[N],G[N];
void big(int p){
    for(int i=0;i<=n+1;i++){
        f[i]=g[i]=0;
    }
    for(auto x:lnk[p]){
        ++f[x];
        ++g[x];
    }
    for(int i=1;i<=n;i++){
        f[i]=f[i]+f[i-1];
    }
    for(int i=n;i;i--){
        g[i]=g[i]+g[i+1];
    }
    int val=cnt[p];
    for(int i=1;i<=m;i++){
        if(i==p){
            continue;
        }
        int k=cnt[i];
        int res=-inf;
        F[0]=G[k+1]=0;
        for(int j=0;j<k;j++){
            F[j+1]=max(F[j],(j+1)-f[lnk[i][j]]);
            res=max(res,F[j+1]+val);
        }
        for(int j=k-1;~j;j--){
            G[j+1]=max(G[j+2],(k-(j+1)+1)-g[lnk[i][j]]);
            res=max(res,G[j+1]+val);
        }
        for(int j=1;j<=k;j++){
            res=max(res,F[j]+G[j]+val);
        }
        ans[i]=max(ans[i],res);
        res=-inf;
        F[0]=G[k+1]=0;
        for(int j=0;j<k;j++){
            F[j+1]=max(F[j],f[lnk[i][j]]-j);
            res=max(res,F[j+1]+k);
        }
        for(int j=k-1;~j;j--){
            G[j+1]=max(G[j+2],g[lnk[i][j]]-(k-(j+1)));
            res=max(res,G[j+1]+k);
        }
        for(int j=1;j<=k;j++){
            res=max(res,F[j]+G[j]+k);
        }
        ans[p]=max(ans[p],res);
    }
}
int h[K];
void small(){
    for(int i=1;i<=B;i++){
        h[i]=0;
    }
    for(int i=1;i<=n;i++){
        if(cnt[a[i]]>B){
            continue;
        }
        int k=cnt[a[i]],sz=k,p=0;
        for(int j=k-1;~j;j--){
            if(lnk[a[i]][j]>=i){
                continue;
            }
            while(p+1<=B&&h[p+1]>lnk[a[i]][j]){
                ++p;
            }
            ans[a[i]]=max(ans[a[i]],sz+p);
            --sz;
        }
        sz=0;
        for(int j=k-1;~j;j--){
            if(lnk[a[i]][j]>i){
                continue;
            }
            ++sz;
            h[sz]=max(h[sz],lnk[a[i]][j]);
        }
    }
}
int buc[N],id[N],pre[N],suf[N];
void spc(){
    for(int i=1;i<=n;i++){
        buc[i]=0;
    }
    for(int i=1;i<=n;i++){
        pre[i]=id[i]=++buc[a[i]];
        suf[i]=cnt[a[i]]-buc[a[i]]+1;
    }
    pre[0]=suf[n+1]=0;
    for(int i=1;i<=n;i++){
        pre[i]=max(pre[i],pre[i-1]);
    }
    for(int i=n;i;i--){
        suf[i]=max(suf[i],suf[i+1]);
    }
    for(int i=1;i<=n;i++){
        ans[a[i]]=max(ans[a[i]],id[i]+suf[i+1]);
        ans[a[i]]=max(ans[a[i]],(cnt[a[i]]-id[i]+1)+pre[i-1]);
    }
}
void print(){
    int val=0;
    for(int i=1;i<=m;i++){
        val=max(val,ans[i]);
    }
    printf("%d\n",val);
    for(int i=1;i<=m;i++){
        if(ans[i]==val){
            printf("%d\n",tmp[i]);
        }
    }
}
void solve(){
    init();
    for(int i=1;i<=m;i++){
        if(cnt[i]>B){
            big(i);
        }
    }
    small();
    spc();
    print();
}
int main(){
    int T;
    scanf("%d",&T);
    while(T--){
        solve();
    }
    return 0;
}
```

若有疑问或错误请指出，虚心接受您的意见。

---

## 作者：StayAlone (赞：3)

题意等价于，求一个区间 $[l, r]$，使得区间外众数出现次数加区间内众数出现次数最大。

考虑根号分治，设定阈值 $B$。称区间内部为内层，外部为外层。

  1. 外层的数出现次数大于 $B$，枚举外层的数 $x$。枚举内层的数 $y$。先将 $x$ 全选上，再将 $x$ 的位置设为 $-1$，$y$ 的位置设为 $1$，其余位置设为 $0$，那么就是求一个最大子段和。考虑到 $[l, r]$ 一定满足 $a_l=y$ 且 $a_r=y$，则对于每个 $y$ 的时间复杂度可以做到 $\mathcal O(cnt_y)$，则对于每个 $x$ 的复杂度就是 $\mathcal O(n)$。总时间复杂度 $\mathcal O(\frac{n^2}{B})$。

2. 内层的数出现次数大于 $B$，枚举内层的数 $x$。同理，枚举外层的数 $y$，将 $x$ 的位置设为 $1$，$y$ 的位置设为 $-1$。考虑到 $[l, r]$ 一定满足 $l=1$ 或 $a_{l-1}=-1$，且 $r=n$ 或 $a_{r+1}=-1$，则对于每个 $y$ 的时间复杂度同样可以做到 $\mathcal O(cnt_y)$，总时间复杂度 $\mathcal O(\frac{n^2}{B})$。

3. 剩余情况就是内外层的数出现次数均小于等于 $B$。枚举外层的数 $x$，考虑到 $[l, r]$ 一定满足 $l=1$ 或 $a_{l-1}=-1$，且 $r=n$ 或 $a_{r+1}=-1$，那么可能的 $[l, r]$ 只有 $nB$ 个：

> 排除掉 $l=1$ 或 $r=n$ 的情况，$r$ 合法，当且仅当 $cnt_{a_{r+1}}\leq B$。对于合法的 $r$，合法的 $l$ 满足 $a_{l-1} = a_{r+1}$，则 $l$ 只有 $cnt_{a_{r+1}}\leq B$ 个。

注意下面的讨论只考虑 $cnt\leq B$ 的数。

于是对于这 $nB$ 个区间，答案就是 $[l, r]$ 内的众数出现次数加 $[l, r]$ 外 $a_{r+1}$ 的出现次数。难做的是查询 $[l, r]$ 内的众数出现次数。

考虑从小到大枚举 $r$，维护 $S_i$ 表示 $[i, r]$ 的众数出现次数。当 $r\gets r+1$，$S_i$ 的修改形如：对于每个 $a_k=a_{r}$，设 $a_{k\sim r}$ 内有 $p$ 个 $a_{r}$，则 $S_{1\sim k}$ 对 $p$ 取 $\max$。

可以发现，每次从 $k$ 开始从右往左用 $p$ 更新 $S_i$，直到 $S_i\geq p$ 时退出时间复杂度就是对的。

> 当 $r=n$ 时，由于考虑的数都满足 $cnt\leq B$，所以 $\sum {S_i}\leq nB$。又因为 $S_i\geq S_{i+1}$，每次更新的都是一段区间。每次枚举，$S_i$ 的和至少增大 $1$，则枚举次数不超过最终 $S_i$ 的和。

这部分的时间复杂度就是 $\mathcal O(nB)$。

取 $B=\sqrt n$ 即可，时间复杂度 $\mathcal O(n\sqrt n)$。

[AC record](https://www.luogu.com.cn/record/201552527)

```cpp
int n, m, ans, len, a[MAXN], cnt[MAXN], to[MAXN];
int sum[MAXN], S[MAXN];
vector <int> opt, B, pos[MAXN];

int main() {
	for (int T = read(); T--; ) {
		memset(a, 0, sizeof a); memset(S, 0, sizeof S);
		read(n); ans = 0; rer(i, 1, n, a);
		len = sqrt(n); B.clear(); memset(cnt, 0, sizeof cnt);
		rep1(i, 1, n) B.eb(a[i]), pos[i].clear();
		sort(begin(B), end(B)); B.resize(m = unique(begin(B), end(B)) - begin(B));
		rep1(i, 1, n) ++cnt[a[i] = lower_bound(begin(B), end(B), a[i]) - begin(B) + 1], pos[a[i]].eb(i);
		rep1(i, 0, m - 1) to[i + 1] = B[i];
		rep1(x, 1, m) if (cnt[x] > len) {
			rep1(i, 1, n) sum[i] = sum[i - 1] - (a[i] == x);
			rep1(y, 1, m) {
				int now = 0, pre = 0, q = 0;
				for (auto p : pos[y]) gmin(pre, sum[p - 1] + q++), gmax(now, sum[p] + q - pre);
				// gmax(ans, now + cnt[x]);
				if (ans == now + cnt[x]) opt.eb(x);
				else if (ans < now + cnt[x]) ans = now + cnt[x], opt.clear(), opt.eb(x);
			}
			//
			rep1(i, 1, n) sum[i] = sum[i - 1] + (a[i] == x);
			rep1(y, 1, m) {
				int now = 0, pre = 0, q = 0;
				for (auto p : pos[y]) gmax(now, sum[p] - q - pre), gmin(pre, sum[p] - ++q);
				// gmax(ans, now + cnt[y]);
				if (ans == now + cnt[y]) opt.eb(y);
				else if (ans < now + cnt[y]) ans = now + cnt[y], opt.clear(), opt.eb(y);
			}
			//
		}
		rep1(i, 1, m) pos[i].insert(begin(pos[i]), 0);
		rep1(r, 1, n) if (cnt[a[r]] <= len) {
			int p = lower_bound(begin(pos[a[r]]), end(pos[a[r]]), r) - begin(pos[a[r]]);
			int g = p - 1;
			for (auto l : pos[a[r]]) if (l++ < r) {
				int q = cnt[a[r]] + S[l] - g--;
				// gmax(ans, cnt[a[r]] + S[l]);
				if (q == ans) opt.eb(a[r]);
				else if (q > ans) ans = q, opt.clear(), opt.eb(a[r]);
			}
			rep1(i, 0, p) {
				int k = p - i + 1, f = pos[a[r]][i];
				while (f && S[f] < k) S[f--] = k;
			}
		}
		rep1(i, 1, m) {
			int g = pos[i].size() - 1;
			for (auto l : pos[i]) {
				int q = cnt[i] + S[++l] - g--;
				// gmax(ans, cnt[a[r]] + S[l]);
				if (q == ans) opt.eb(i);
				else if (q > ans) ans = q, opt.clear(), opt.eb(i);
			}
		} printf("%d\n", ans);
		sort(begin(opt), end(opt)); opt.resize(unique(begin(opt), end(opt)) - begin(opt));
		for (auto v : opt) printf("%d\n", to[v]);
	}
	return 0;
}
```

---

## 作者：Cherished (赞：3)

为了象征性的证明自己没有摆烂，所以来写题解了。感觉这还算是一道比较传统的题目吧，虽然我可能想了一个半小时才做出来，但是做出来之后又感觉好像不是很难。

### 简要题意

给你一个长度为 $n$ 的数列，你可以给其中的任意一个连续段加上任意大的一个数，问修改完之后数列的众数最多出现了多少次，并输出哪些数可以达到这个出现次数。

### 数据范围

多测！！！

$n \leq 2\times10^5$，保证一个数列中的数不全相等（要不然就有无限个解了）。

### 解题思路

首先可以发现我们完全可以暴力枚举两个数，计算更改其中一个数之后，另一个数最多出现多少次。那么我们在这个说这个叫做被更改的数对统计答案的数的贡献。

显然我们只需要暴力计算出任意两个数的贡献就可以得到一个多项式的做法。

我们具体思考一下应该怎么做：假如是 $1$ 对 $2$ 做贡献，我们定义两个数组 $s1,s2$ 分别表示 $1$ 和 $2$ 个数的前缀和。此时可以发现我们的答案就是 $max_{r=1}^{n}{max_{l=1}^{r}{(s2_n-s2_r+s2_{l-1}+s1_r-s1_{l-1})}}$。

对于上面的式子我们显然可以把它变成 $s2_n+max_{r=1}^{n}{max_{l=1}^{r}{((-s2_r+s1_r)+(s2_{l-1}-s1_{l-1}))}}$，这样我们只需要对 $s2_{l-1}-s1_{l-1}$ 记录一个前缀 $min$ 就可以 $O(n)$ 的计算两个数的贡献了。

这样的时间复杂度是 $O(n^3)$，但是我们可以发现其实 $2$ 这个数是谁是完全无关紧要的，我们完全可以利用 $O(n)$ 的时间计算出来一个数对于所有数的贡献，这样我们的时间复杂度就变成了 $O(n^2)$。

毕竟是数据结构题而且还是众数，我们肯定会往根号的方向上去想的（接下来我们用 $B$ 代表 $\sqrt{n}$），可以发现大于 $B$ 的数只有 $\frac{n}{B}$ 种，完全可以解决一个大数对其他数的贡献。（我们之后管大于 $B$ 的数叫大数，小于等于 $B$ 的数叫小数）。

显然之后只需要思考一个小数对其他数的贡献就行了。

之后我的做法可能就略微有一点麻烦了：

先考虑一个小数对一个小数的贡献：

我们从左往右扫，把当前点叫做 $i$。以 $i$ 为右端点，对于所有的点记录以这个点为左端的的众数出现次数。这样每次查询 $i$ 的贡献的时候，我们暴力枚举和 $i$ 权值相同的点 $j$。那么如果我们修改 $j$ 到 $i$ 中间的一段贡献就是 $i$ 之后和 $j$ 之前和 $i$ 相同的点的个数加上 $j$ 到 $i$ 这一段的众数出现次数，因为每个数最多只有 $B$ 个所以每次最多只会枚举 $B$ 次，这样枚举的时间复杂度就是 $nB$ 的了。

但是现在还有一个问题就是如何维护以每个点为左端点的众数个数，可以发现我们的每一次修改也是找到所有的 $j$，然后区间给一个前缀取 $max$，显然如果直接取 $max$ 我们就会多一个 $\log$ 这样是不能接受的。那么我们可以考虑，这里面维护的每一个众数个数的大小最多只有 $B$，而且它一定是从左到右递减的，这样的话我们每次修改其实可以直接暴力改，如果上一个点可以改就跳到上一个点，如果再上一个点还可以改，就继续跳。可以发现总修改次数是 $n$ 乘每个左端点众数次数最大值的也就是 $B$，这样我们的修改次数也是 $nB$ 的了。

之后我们再考虑一个小数对一个大数的贡献：

显然这回我们统计答案的时候就不能暴力的找到每一个 $j$ 了，但是我们可以发现你以这个点为右端点，所有左端点的众数出现次数最大只有 $B$，所以我们可以只维护当众数出现次数是 $B$ 的时候，左端点的最大值可以是多少。这样我们只需要对于每一个大数记录一个前缀和然后枚举中间修改的数的个数。这样查贡献的时间复杂度就是 $O(nB)$ 的了。至于如何维护这个左端点的最大值就非常的简单了。还是可以考虑暴力枚举 $j$ 直接修改就行了。

这样总时间复杂度就可以做到 $O(n\sqrt{n})$ 了。

### 关于代码

身为一道数据结构题没有卡常还是非常的良心的。

代码不是特别长，也比较好写，我写出来都没有调就过了（或许是数据太水了）。

下面是代码：

```cpp
const int N = 2e5 + 10;

int n, a[N], b[N], c, ct[N], B, ans[N], mx[N], s[N], lst[N], fir[N], k[N], rk[N];
int pre[500][N];

void calc1(int col) {
	for (int i = 1; i <= n; i++) mx[i] = s[i] = 0;
	int nw = 0;
	for (int i = 1; i <= n; i++) {
		if (a[i] == col) nw++;
		else {
			ckmax(ans[a[i]], ct[a[i]] - s[a[i]] + nw + mx[a[i]]);
			s[a[i]]++, ckmax(mx[a[i]], s[a[i]] - nw);
		}
	}
	for (int i = 1; i <= c; i++) ckmax(ans[i], nw + mx[i]);
}

void solve() {
	scanf("%d", &n), c = 0;
	for (int i = 1; i <= n; i++)
		scanf("%d", &a[i]), b[++c] = a[i];
	sort (b + 1, b + c + 1);
	c = unique (b + 1, b + c + 1) - b - 1;
	for (int i = 1; i <= n; i++)
		a[i] = lower_bound(b + 1, b + c + 1, a[i]) - b;
	B = sqrt(n); int mxc = 0, crk = 0;
	for (int i = 1; i <= c; i++) ct[i] = 0;
	for (int i = 1; i <= n; i++) ckmax(mxc, ++ct[a[i]]);
	for (int i = 1; i <= c; i++) ans[i] = mxc, rk[i] = 0;
	for (int i = 1; i <= c; i++)
		if (ct[i] > B) calc1(i), rk[i] = ++crk;
	for (int i = 1; i <= crk; i++)
		for (int j = 1; j <= n; j++)
			pre[i][j] = pre[i][j - 1] + (rk[a[j]] == i);
	for (int i = 1; i <= n; i++) lst[i] = fir[i] = k[i] = 0;
	for (int i = 1; i <= n; i++) {
		if (ct[a[i]] <= B) {
			lst[i] = fir[a[i]], fir[a[i]] = i;
			for (int o = 1, j = fir[a[i]]; j; o++, j = lst[j])
				ckmax(k[o], j);
		}
		else {
			for (int o = 1; k[o] && o <= B; o++)
				ckmax(ans[a[i]], ct[a[i]] - pre[rk[a[i]]][i - 1] + o + pre[rk[a[i]]][k[o] - 1]);
		}
	}
	for (int i = 1; i <= c; i++) if (ct[i] > B)
		for (int o = 1; k[o] && o <= B; o++)
			ckmax(ans[i], o + pre[rk[i]][k[o] - 1]);
	for (int i = 1; i <= n; i++) lst[i] = fir[i] = k[i] = s[i] = 0;
	for (int i = 1; i <= n; i++) {
		if (ct[a[i]] <= B) {
			s[i] = s[fir[a[i]]] + 1;
			for (int j = fir[a[i]]; j; j = lst[j])
				ckmax(ans[a[i]], ct[a[i]] - s[i] + 1 + s[j] + k[j + 1]);
			ckmax(ans[a[i]], ct[a[i]] - s[i] + 1 + k[1]);
			lst[i] = fir[a[i]], fir[a[i]] = i;
			for (int o = 1, j = fir[a[i]]; j; o++, j = lst[j]) {
				int tmp = j;
				while (tmp > 0 && k[tmp] < o) k[tmp--] = o;
			}
		}
	}
	for (int i = 1; i <= c; i++) if (ct[i] <= B)
		for (int j = fir[i]; j; j = lst[j]) {
			if (j == n) continue;
			ckmax(ans[i], s[j] + k[j + 1]);
		}
	int as = 0; vector<int> out;
	for (int i = 1; i <= c; i++) {
		if (as < ans[i]) out.clear(), out.push_back(b[i]), as = ans[i];
		else if (as == ans[i]) out.push_back(b[i]);
	}
	printf("%d\n", as);
	sort (out.begin(), out.end());
	for (int x : out) printf("%d\n", x);
}

int T;

int main() {
	for (scanf("%d", &T); T; T--) solve();
	return 0;
}
```

---

## 作者：Anita_Hailey (赞：3)

## 众数

### 题意

给你一个长度为 $n$ 的序列，然后第 $i$ 个元素是 $a_i$，你可以对于序列进行一次操作，使得 $[l,r]$ 这个区间内所有数字加上 $k$。你希望操作之后众数的出现次数尽量多，你需要输出最终序列的众数出现次数的最大值，并输出这个众数的所有可能取值。注意对于一个序列，众数的取值可能不止一个。

$n\le 2\times 10^5,a_i\le 10^9$

### 题解

众数的题，看起来就不能polylog，考虑怎么根号能做。

考虑怎么根号的做。

首先对于这种东西，都有一个非常好的性质，就是说，出现次数大于 $\sqrt n$ 的颜色，不超过 $O(\sqrt n)$ 个，于是可以每种颜色 $O(n)$ 做，然后在考虑小的颜色互相的答案即可。

首先先做一点准备工作，比如先把数字离散化，然后令 $pos_i$ 表示 $i$ 颜色出现的下标数组。

对于一种大于 $O(\sqrt n)$ 的颜色，令 $s$ 为他的前缀和数组，然后合法的方案肯定是 ``xxxyyyyxxx` 或者是 `yyyyxxxyyy`，于是我们单独考虑现在的颜色 $x$ 和一种颜色 $y$，从前向后扫一遍同时记录一些值就可以得到答案。

于是我们只剩下了两两都是 $\le \sqrt n$ 的颜色，怎么办呢。考虑对于每个颜色，暴力枚举颜色的左右端点，然后中间就是求这一段区间内哪个颜色出现次数最多，考虑扫描线，然后令 $s_i$ 表示 $i$ 为左端点的情况下，当前众数最多是多少。我们考虑这玩意其实不好维护，但是注意到 $s_i$ 不增，然而以 $i$ 为左端点的众数最多是  $\sqrt n$，然后总共 $s_i$ 数组的总和不超过 $n\sqrt n$，于是可以暴力更新，复杂度是对的。

然后注意到我们可能会算漏一种就是对于 $x$ 的 `xxyyy` 的贡献。

```cpp
// Siriqwq
#include <bits/stdc++.h>
using std::cin;
using std::cout;
using std::vector;
using std::copy;
using std::reverse;
using std::sort;
using std::get;
using std::unique;
using std::swap;
using std::array;
using std::cerr;
using std::function;
using std::map;
using std::set;
using std::pair;
using std::mt19937;
using std::make_pair;
using std::tuple;
using std::make_tuple;
using std::uniform_int_distribution;
using ll = long long;
namespace qwq {
	mt19937 eng;
	void init(int Seed) {return eng.seed(Seed);}
	int rnd(int l = 1, int r = 1000000000) {return uniform_int_distribution<int> (l, r)(eng);}
}
template <typename T>
inline T min(const T &x, const T &y) {return x < y ? x : y;}
template<typename T>
inline T max(const T &x, const T &y) {return x > y ? x : y;}
template<typename T>
inline void read(T &x) {
	x = 0;
	bool f = 0;
	char ch = getchar();
	while (!isdigit(ch)) f = ch == '-', ch = getchar();
	while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();
	if (f) x = -x;
}
template<typename T, typename ...Arg>
inline void read(T &x, Arg &... y) {
	read(x);
	read(y...);
}
template<typename T>
inline void chkmin(T &x, const T &y) {if (x > y) x = y;}
template<typename T>
inline void chkmax(T &x, const T &y) {if (x < y) x = y;}
#define O(x) cerr << #x << " : " << x << '\n'
const double Pi = acos(-1);
const int MAXN = 262144, MOD = 998244353, inv2 = (MOD + 1) / 2, I32_INF = 0x3f3f3f3f;
const long long I64_INF = 0x3f3f3f3f3f3f3f3f;
auto Ksm = [] (int x, int y) -> int {
	if (y < 0) {
		y %= MOD - 1;
		y += MOD - 1;
	}
	int ret = 1;
	for (; y; y /= 2, x = (long long) x * x % MOD) if (y & 1) ret = (long long) ret * x % MOD;
	return ret;
};
auto Mod = [] (int x) -> int {
	if (x >= MOD) return x - MOD;
	else if (x < 0) return x + MOD;
	else return x;
};
inline int ls(int k) {return k << 1;}
inline int rs(int k) {return k << 1 | 1;}
int N, A[MAXN], B[MAXN], w[MAXN], pos[MAXN], blk_sz, s[MAXN];
vector<int> vec[MAXN];
// xxxyyyxxx
void wk_1(int x, int y) {
	int tmp = -I32_INF, ret = 0;
	for (int j = 0; j < vec[y].size(); ++j) {
		chkmax(tmp, s[vec[y][j]] - j);
		chkmax(ret, tmp + j + 1 + s[N] - s[vec[y][j]]);
	}
	chkmax(w[x], ret);
}
// yyyyxxxyyy
void wk_2(int x, int y) {
	int tmp = -I32_INF, ret = 0;
	for (int j = 0; j < vec[y].size(); ++j) {
		chkmax(ret, tmp + s[vec[y][j]] + (int)vec[y].size() - j);
		chkmax(tmp, j - s[vec[y][j]] + 1);
		chkmax(ret, (int)vec[y].size() - j + s[vec[y][j]]);
		chkmax(ret, j + 1 + s[N] - s[vec[y][j]]);
	}
	chkmax(w[y], ret);
}
void wk_big() {
	for (int i = 1; i <= *B; ++i) {
		if (vec[i].size() > blk_sz) {
			for (int j = 1; j <= N; ++j) s[j] = 0;
			for (auto &j: vec[i]) s[j] = 1;
			for (int j = 2; j <= N; ++j) s[j] += s[j - 1];
			for (int j = 1; j <= *B; ++j) if (j != i) wk_1(i, j);
			for (int j = 1; j <= *B; ++j) if (vec[j].size() <= blk_sz) wk_2(i, j);
		}
	}
}
inline void mfy(int x, int y) {while (x && s[x] < y) s[x--] = y;}
void wk_small() {
	for (int i = 1; i <= N; ++i) s[i] = 0;
	for (int i = 1; i <= N; ++i) if (vec[A[i]].size() <= blk_sz) {
		int tmp = vec[A[i]].size() - pos[i] + s[1];
		for (int j = pos[i] - 1; j >= 0; --j) {
			int cyc = vec[A[i]][j];
			chkmax(tmp, j + 1 + (int)vec[A[i]].size() - pos[i] + s[cyc + 1]);
		}
		chkmax(w[A[i]], tmp);
		for (int j = pos[i]; j >= 0; --j) mfy(vec[A[i]][j], pos[i] - j + 1);
	}
	for (int i = 1; i <= N; ++i) s[i] = 0;
	int mx = 0;
	for (int i = N; i; --i) {
		chkmax(w[A[i]], pos[i] + 1 + mx);
		chkmax(mx, ++s[A[i]]);
	}
}
int main() {
	// std::ios::sync_with_stdio(0);
	// cout << std::fixed << std::setprecision(8);
	// cin.tie(0);
	// cout.tie(0);
// 	freopen("1.in", "r", stdin);
// 	freopen("1.out", "w", stdout);
	qwq::init(20050112);
	int T;
	for (read(T); T--; ) {
		// prepare work
		read(N);
		for (int i = 1; i <= N; ++i) read(A[i]), B[i] = A[i];
		sort(B + 1, B + 1 + N);
		*B = unique(B + 1, B + 1 + N) - B - 1;
		for (int i = 1; i <= N; ++i) vec[A[i] = std::lower_bound(B + 1, B + 1 + *B, A[i]) - B].push_back(i), pos[i] = vec[A[i]].size() - 1;
		blk_sz = sqrt(N);
		// work class
		wk_big();
		wk_small();
		int ans = 0;
		for (int i = 1; i <= *B; ++i) chkmax(ans, w[i]);
		printf("%d\n", ans);
		for (int i = 1; i <= *B; ++i) if (w[i] == ans) printf("%d\n", B[i]);
		for (int i = 1; i <= *B; ++i) vec[i].clear(), w[i] = 0;
	}
	// cout << (-3 / 2);
	cerr << ((double) clock() / CLOCKS_PER_SEC) << '\n';
	return (0-0);
}
```


---

## 作者：dyc2022 (赞：1)

[更好的阅读体验](https://www.cnblogs.com/dyc2022/p/19005365)
***
感觉这题真的很难（写）吧！
***
问题可以认为是：选定一个区间 $[l,r]$，求 $[l,r]$ 的众数和 $[l,r]$ 外的众数出现次数和的最大值。

众数和出现次数密切相关，而所有数字出现次数之和恰好为 $n$，因此我们能够想到根号分治。

取 $B = \sqrt{n}$，由此，我们可以把数字按照出现次数 $\ge B$ 和 $< B$ 分成两类，前者的数字至多有 $\sqrt{n}$ 个，后者每个数的出现次数至多为 $\sqrt{n}$。

因此可以衍生出两个做法。

枚举区间众数 $x$。

- 当 $x$ 出现次数 $\ge B$，那么枚举区间外众数 $y$。构造序列 $s$，钦定 $a_i=x$ 的位置是 $s_i=1$，$a_i= y$ 的位置是 $s_i=-1$，求出该序列抠掉一个区间后的和的最大值。显然我们把左右端点设置在 $s_i=1$ 的位置一定不劣。所以可以枚举右端点，对左端点尺取。由于对于所有的数字，满足条件的右端点数量之和为 $O(n)$，而尺取的两端点的总位移为 $O(n)$，因此这部分的复杂度为 $O(n \sqrt{n})$。
- 当 $x$ 出现次数 $<B$，那么枚举 $x$ 的出现次数 $k$，同时预处理出 $i$ 前面第 $k$ 个和 $i$ 值一样的位置 $\text{pre}_i$，这时直接枚举右端点，用类似第一种情况的尺取法取左端点即可完成。出现次数最多 $O(n\sqrt{n})$，左右端点都是 $O(n)$ 次移动，因此这部分复杂度为 $O(n \sqrt{n})$。

这样综合起来，总复杂度就是 $O(n \sqrt{n})$。

::::info[代码]
```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
#define N 200006
using namespace std;
void chkmax(int &x,int y){x=x<y?y:x;}
int T,n,B,bn,maxn,maxcur,o;
int a[N],b[N],cnt[N],sum[N],ans[N],rk[N],pre[N];
vector<int> vec[N],va,vb;
void solve_a()
{
    for(int v:va)
    {
        for(int i=1;i<=n;i++)sum[i]=0;
        for(int i:vec[v])sum[i]=-1;
        for(int i=1;i<=n;i++)
            sum[i]+=sum[i-1];
        for(int u=1;u<=bn;u++)
        {
            int c=0,mx=0;
            for(int i:vec[u])
            {
                chkmax(ans[u],cnt[u]+cnt[v]-c+sum[n]-sum[i-1]+mx);
                c++,chkmax(mx,c+sum[i]);
            }
            chkmax(ans[u],mx+cnt[v]);
        }
    }
}
void solve_b()
{
    maxcur=0;
    for(int i:vb)chkmax(maxcur,cnt[i]);
    for(int k=1;k<=maxcur;k++)
    {
        pre[0]=-1;
        for(int i=1;i<=n;i++)
            pre[i]=(rk[i]-k<0?-1:vec[a[i]][rk[i]-k]);
        for(int i=2;i<=n;i++)chkmax(pre[i],pre[i-1]);
        for(int u=1;u<=bn;u++)
        {
            int res=0,tot=0;
            for(int i:vec[u])
            {
                if(!~pre[i-1]){res++;continue;}
                while(tot<cnt[u]&&vec[u][tot]<pre[i-1])tot++;
                chkmax(ans[u],k+cnt[u]-res+tot),res++;
            }
            if(~pre[n])
            {
                while(tot<cnt[u]&&vec[u][tot]<pre[n])tot++;
                chkmax(ans[u],k+cnt[u]-res+tot);
            }
        }
    }
}
void solve()
{
    scanf("%lld",&n),B=pow(n,0.5),bn=o=0;
    for(int i=1;i<=n;i++)
        scanf("%lld",&a[i]),b[++bn]=a[i];
    sort(b+1,b+1+bn),bn=unique(b+1,b+1+bn)-b-1;
    for(int i=1;i<=bn;i++)
        cnt[i]=ans[i]=0,vec[i].clear();
    for(int i=1;i<=n;i++)
        a[i]=lower_bound(b+1,b+1+bn,a[i])-b;
    maxn=0,va.clear(),vb.clear();
    for(int i=1;i<=n;i++)
        maxn=max(maxn,++cnt[a[i]]),vec[a[i]].push_back(i),rk[i]=cnt[a[i]];
    for(int i=1;i<=bn;i++)
        cnt[i]>B?va.push_back(i):vb.push_back(i);
    solve_a(),solve_b();
    for(int i=1;i<=bn;i++)chkmax(o,ans[i]);
    printf("%lld\n",o);
    for(int i=1;i<=bn;i++)
        if(ans[i]==o)printf("%lld\n",b[i]);
}
main()
{
    scanf("%lld",&T);
    while(T--)solve();
    return 0;
}
```
::::

---

## 作者：MrcFrst (赞：1)

### Solution

区间加这个操作看起来很阴间，实际上区间加不会改变区间内元素值的相对关系，所以答案就是区间内的众数出现次数加上区间外的众数出现次数。

操作区间两边如果都有值，那么这两个值相等一定是不劣的，因为如果我们希望 $x$ 为操作区间之外的众数，那么相邻两个 $x$ 之间的一段要么不选要么全选一定是最优的。

也就是说，当操作区间的左端点 $l$ 固定之后，右端点的 $a_r$ 也固定了，于是右端点就有 $O(siz_{a_l})$ 个取值，其中 $siz_x$ 表示 $x$ 在整个序列中的出现次数。

我们发现如果这样暴力枚举右端点，枚举次数仅与 $siz$ 相关，而对于出现次数，有很经典的根号分治：所有数的出现次数之和为 $n$，所以出现次数 $\gt T$ 的数不超过 $O(\frac{n}{T})$ 个。所以考虑根号分治，设定阈值为 $T$。

对于 $siz_x\gt T$，我们先钦定 $x$ 为操作区间外的答案，然后选择一个 $y$ $(y\neq x)$ 令其为操作区间内的答案，此时操作区间的两端都是 $y$ 一定最优，所以只需记录 $O(siz_y)$ 枚举即可。答案的计算显然是区间内 $y$ 的出现次数加上区间外 $x$ 的出现次数，记录 $x$ 在序列中出现次数的前缀和即可计算。

对于 $siz_y\le T$，我们交换 $x,y$ 再算一遍，对于每个 $x$，枚举其他所有的 $y$ 的位置是 $O(n)$ 的，所以此部分总时间复杂度为 $O(\frac{n^2}{T})$。

于是就只剩下了 $siz_x\le T\land siz_y\le T$ 的情况：我们可以用上文提到的方法暴力枚举右端点 $O(nT)$ 次，然后每次求出区间内的众数即可统计答案，总共需要求 $O(nT)$ 次区间众数，需要做到单次复杂度近似 $O(1)$，直接做区间众数显然是不太容易做到的，考虑再次利用 $siz\le T$：我们只需要考虑 $siz_\le T$ 的数，所以众数出现次数也 $\le T$，于是可以处理出 $R_{i,j}$ 表示左端点为 $j$，最小使得众数出现次数为 $i$ $(i\le T)$ 的右端点（没有即为 $n+1$），对于每个 $i$ 用双指针处理，时间复杂度 $O(nT)$。然后我们在暴力枚举右端点的时候就可以双指针找答案了，对于每个左端点，复杂度为 $O(T)$，故此部分总时间复杂度为 $O(nT)$。

总时间复杂度为 $O(nT+\frac{n^2}{T})$，取 $T=\sqrt n$ 时达到平衡：$O(n\sqrt n)$。

-----------------------

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
#define re register
namespace IO{
    const int sz=1<<20;
    char a[sz+5],b[sz+5],*p1=a,*p2=a,*t=b,p[105];
    inline char gc(){
        return p1==p2?(p2=(p1=a)+fread(a,1,sz,stdin),p1==p2?
        EOF:*p1++):*p1++;
    }
    il int read(){
        int f=1,x=0; char c=gc();
        for(;c<'0'||c>'9';c=gc())if(c=='-') f*=-1;
        for(;c>='0'&&c<='9';c=gc())x=x*10+(c-'0');
        return x*f;
    }
    inline void flush(){fwrite(b,1,t-b,stdout),t=b; }
    inline void pc(char x){*t++=x; if(t-b==sz) flush(); }
    template<class T> void write(T x,char c='\n'){
        if(x==0) pc('0'); int t=0;
        if(x<0) pc('-'),x*=-1;
        for(;x;x/=10) p[++t]=x%10+'0';
        for(;t;--t) pc(p[t]); pc(c);
    }
    struct F{~F(){flush();}}f;
}
using IO::read;
using IO::write;
const int N=2e5+10,T=450;
int Tc,n,a[N],b[N],V;
int R[T+5][N],sum[N],mn[N];
int ans[N],siz[N],cnt[N],pos[N];
vector<int>v[N];
#define pb emplace_back
il void Solve_1(int x,int y){
    re int mn=0,res=-n;
    for(re int i=0;i<siz[y];i++)
        mn=min(mn,i-sum[v[y][i]]),res=max(res,i+1-sum[v[y][i]]-mn);
    ans[x]=max(ans[x],siz[x]+res);
}
il void Solve_2(int x,int y){
    re int mn=0,res=-n;
    for(re int i=0;i<siz[y];i++)
        res=max(res,sum[v[y][i]]-i-mn),mn=min(mn,sum[v[y][i]]-i-1);
    res=max(res,siz[x]-siz[y]-mn);
    ans[y]=max(ans[y],siz[y]+res);
}
il void Solve_gt(int i){
    for(re int j=1;j<=n;j++)sum[j]=sum[j-1]+(a[j]==i);
    for(re int j=1;j<=V;j++)if(i^j)Solve_1(i,j);
    for(re int j=1;j<=V;j++)if(siz[j]<=T)Solve_2(i,j);
}
il void Init_le(int x){
    for(re int i=1;i<=V;i++)cnt[i]=0;
    re int mx=0;
    for(re int i=1;i<=n;i++){
        if(i^1)cnt[a[i-1]]--,mx-=(a[i-1]==a[R[x][i-1]]);
        R[x][i]=R[x][i-1];
        while(R[x][i]<=n&&mx^x)mx=max(mx,++cnt[a[++R[x][i]]]);
    }
}
il void Solve_le(){
    for(re int i=1;i<=V;i++)if(siz[i]<=T)v[i].pb(n+1);
    re int l=0,mx=0;
    for(re int i=1;i<=V;i++)cnt[i]=0;
    for(re int r=2;r<=n;r++)
        ans[a[r]]=max(ans[a[r]],siz[a[r]]-pos[r]+(mx=max(mx,++cnt[a[r-1]])));
    for(l=1;l<n;l++){
        if(siz[a[l]]>T)continue;
        re int res=0;
        for(re int i=pos[l]+1;i<=siz[a[l]];i++){
            re int r=v[a[l]][i];
            while(res<T&&R[res+1][l+1]<r)res++;
            ans[a[l]]=max(ans[a[l]],res+siz[a[l]]-i+pos[l]+1);
        }
    }
}
il void MrcFrst(){
    n=read();
    for(re int i=1;i<=n;i++)b[i]=a[i]=read();
    sort(b+1,b+1+n),V=unique(b+1,b+1+n)-b-1;
    for(re int i=1;i<=V;i++)v[i].clear();
    for(re int i=1;i<=n;i++)
        a[i]=lower_bound(b+1,b+1+V,a[i])-b,pos[i]=v[a[i]].size(),v[a[i]].pb(i);
    for(re int i=1;i<=V;i++)ans[i]=siz[i]=v[i].size();
    for(re int i=1;i<=V;i++)if(siz[i]>T)Solve_gt(i);
    for(re int i=1;i<=T;i++)Init_le(i);
    Solve_le();
    re int res=0;
    for(re int i=1;i<=V;i++)res=max(res,ans[i]);
    write(res);
    for(re int i=1;i<=V;i++)if(ans[i]==res)write(b[i]);
}
int main(){
    // freopen("my.in","r",stdin);
    // freopen("my.out","w",stdout);
    Tc=read();
    while(Tc--)MrcFrst();
    return 0;
}
```

---

## 作者：Danslapiscine (赞：0)

根号分治大成题。蒟蒻不看题解想了一天。

题目意思就是在序列中删掉一区间，分别取剩下的段和删掉的段中的众数的个数，问他们的和最大能为多少，还有能取到最大和的剩下那段众数的方案。

直接做是不行的，用根号分治的方法创造条件。

#### 1. 处理小于 $$ \sqrt{n} $$ 个数字。
这种情况容易想到对每个数字分开处理，花费 $$O(n)$$ 的时间。

设处理到的数字是 $$i$$。可以想到对于该数在区间内的情况，若外面选的数字是 $$j$$，我们把数组中 $$i$$ 看作 $$+1$$，$$j$$ 看作 $$-1$$，发现答案就是一段区间的和加上数组中 $$j$$ 的个数。做前缀和，需要查询历史最小值，发现可以维护。

对于该数在区间外面的情况，可设 $$f_j$$ 表示当前区间内选 $$j$$ 最大取到多少个数，发现也可以维护。

这样我们可以处理较大的 $$\sqrt{n}$$ 个数，剩下的数就出现次数只小于等于 $$\sqrt{n}$$。

#### 2. 每个数字出现次数小于等于 $$\sqrt{n}$$。
发现区间内和区间外的众数个数均小于等于 $$\sqrt{n}$$ ，对每个点去求若作为左端点，那么右端点至少是几，区间内众数为 $s$。然后显然可以用双指针求解。

因为众数个数随区间长度增加单调递增，所以可以从后往前求解，设当前点为 $$i$$，那么用大于 $$i$$ 的点 $$j$$ ，且 $$a_i=a_j$$ 的点更新即可。

时间复杂度 $$O(n \sqrt{n} )$$。我的写法细节巨多。

```cpp
#include <bits/stdc++.h>
using namespace std;

int TAT;
int n, parter, a[500002], nn, aa[500002], cnt[500002];
int Ans, haveAns[500002];
void update(int s,int num){
	if(s > Ans) Ans = s, haveAns[num] = Ans;
	else if(s == Ans) haveAns[num] = Ans;
}

int adder, have[500002], Max[500002];
int f[500002];
void solve1(){
	for(int i=1;i<=nn;i++){
		if(cnt[i] <= parter) continue;
		
		// 把i看成1，把a[j]看成-1，前缀和have[a[j]]
		// 全局加1   单点-1   查询单点历史最小值 
		for(int j=1;j<=nn;j++) have[j] = 0, Max[j] = 0;
		adder = 0;
		for(int j=1;j<=n-1;j++){
			if(a[j] == i) adder++;
			have[a[j]]--, Max[a[j]] = max(Max[a[j]], -have[a[j]]-adder);
			update(cnt[a[j+1]]+have[a[j+1]]+adder+Max[a[j+1]], a[j+1]);
		}// 在内
		
		adder = 0;
		for(int j=1;j<=nn;j++) f[j] = 0;
		for(int j=1;j<=n;j++){
			if(a[j] == i) adder++;
			f[a[j]] = max(f[a[j]] + 1, adder + 1);
			update(f[a[j]] + cnt[i] - adder, i);
		}// 在外 
	}
}

int head[500002], nxt[500002], zhong[500002];
void solve2(){
	for(int i=1;i<=nn;i++) head[i] = n+1;
	nxt[n+1] = 0;
	for(int i=1;i<=n;i++) zhong[i] = n+1;
	for(int i=n;i>=1;i--){
		if(cnt[a[i]] <= parter) {
			nxt[i] = head[a[i]], head[a[i]] = i;
		}
	}
	for(int i=n;i>=1;i--){
		if(cnt[a[i]] > parter) continue;
		
		int cnt2 = 0;
		for(int pos1=nxt[i],cnt1=0;pos1;pos1=nxt[pos1],cnt1--){
			while(cnt2 + 1 <= parter && zhong[cnt2+1] < pos1) cnt2++;
			update(cnt[a[i]]+cnt1+cnt2,a[i]);
		}
		
		for(int j=i,k=1;j!=n+1;j=nxt[j],k++){
			zhong[k] = min(zhong[k], j);
		}
	}
}

int main(){
	//freopen("mode_ex2.in","r",stdin);
	//freopen("zzz.out","w",stdout);
	
	scanf("%d",&TAT);
	
	while(TAT--){
		Ans = 0;
		for(int i=1;i<=n;i++) haveAns[i] = 0;
		
		scanf("%d",&n);
		for(int i=1;i<=n;i++) scanf("%d",&a[i]), aa[i] = a[i];
		sort(aa+1,aa+n+1), nn = unique(aa+1,aa+n+1)-aa-1;
		for(int i=1;i<=nn;i++) cnt[i] = 0;
		for(int i=1;i<=n;i++) a[i] = lower_bound(aa+1,aa+nn+1,a[i])-aa, cnt[a[i]]++;
		
		parter = sqrt(n);
		solve1();
		reverse(a+1,a+n+1);
		solve1();
		
		solve2();
		reverse(a+1,a+n+1);
		solve2();
		
		printf("%d\n",Ans);
		for(int i=1;i<=nn;i++) {
			if(haveAns[i] == Ans) printf("%d\n",aa[i]);
		}
	}
	
	return 0;
}

/*
1
6
2 4 2 4 8 8

8 8 4 2 4 2
*/
```

---

## 作者：Purslane (赞：0)

# Solution

这种题不比迷宫守卫要好太多了 /fn

将问题转化为：选定 $l \le r$，最大化 $\text{Modecnt}(a_1,\cdots,a_{l-1},a_{r+1},\cdots,a_n) + \text{Modecnt}(a_l,a_{l+1},\cdots,a_r)$。

考虑根号分治。如果这两个众数中，有一种数出现的次数多于 $\sqrt n$。枚举所有出现次数 $\ge \sqrt n$ 的数，容易发现可以对另一种数用前缀和优化，做到 $O(n)$ 算出钦定一个数是某一段众数的最大值。

对于剩下的情况，发现 $\text{Modecnt} \le \sqrt n$，因此很容易计算出 $f_{r,k}$ 表示最大的 $l$，使得 $\text{Modecnt}(a_l,a_{l+1},\cdots,a_r) \ge k$。

这样对于每种颜色和每个 $k$，使用尺取法算出 $\text{Modecnt}(a_l,a_{l+1},\cdots,a_r)=k$ 时，该颜色在 $[1,l) \cup (r,n]$ 中最多出现多少次。

复杂度 $O(n \sqrt n)$。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2e5+10;
int T,n,m,a[MAXN],lsh[MAXN],mx[MAXN],cnt[MAXN],B,f[405][MAXN];
int occ[MAXN],lst[MAXN],pre[MAXN],Pre[MAXN],rnk[MAXN];
vector<int> pos[MAXN];
void solve(int col) {
	ffor(i,1,m) pre[i]=Pre[i]=-0x3f3f3f3f;
	int p=0;
	ffor(i,1,n) {
		if(a[i]==col) p++;
		else {
			pre[a[i]]=max(pre[a[i]],-rnk[i]+1+p),mx[col]=max(mx[col],rnk[i]+pre[a[i]]+cnt[col]-p);
			mx[a[i]]=max(mx[a[i]],cnt[a[i]]-rnk[i]+1+p+Pre[a[i]]),Pre[a[i]]=max(Pre[a[i]],rnk[i]-p);
			mx[a[i]]=max(mx[a[i]],p+cnt[a[i]]-rnk[i]+1);
			mx[a[i]]=max(mx[a[i]],cnt[col]-p+rnk[i]);
		}
	}
	return ;
}
void Solve(int col) {
	rnk[n+1]=cnt[col]+1;
	ffor(i,1,B) {
		if(f[i][pos[col][pos[col].size()-1]-1]==-1) break ;
		int p=-1;
		for(auto id:pos[col]) {
			while(p+1<pos[col].size()&&pos[col][p+1]<f[i][id-1]) p++;
			if(p!=-1) mx[col]=max(mx[col],cnt[col]-rnk[id]+1+p+i);	
		}
	}
	return ;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>T;
	while(T--) {
		cin>>n,m=0,B=400;
		ffor(i,1,n) cin>>a[i],lsh[++m]=a[i];
		sort(lsh+1,lsh+m+1),m=unique(lsh+1,lsh+m+1)-lsh-1;
		ffor(i,1,m) mx[i]=cnt[i]=occ[i]=0,pos[i].clear();
		ffor(i,1,n) a[i]=lower_bound(lsh+1,lsh+m+1,a[i])-lsh,cnt[a[i]]++,lst[i]=occ[a[i]],occ[a[i]]=i,rnk[i]=rnk[lst[i]]+1;	
		ffor(i,0,n) ffor(j,0,B) f[j][i]=-1;
		ffor(i,1,n) {
			ffor(j,0,B) f[j][i]=f[j][i-1];
			int p=i;
			ffor(j,1,B) {
				f[j][i]=max(f[j][i],p),p=lst[p];
				if(!p) break ;
			}
		}
		ffor(i,1,m) pos[i].push_back(0);
		ffor(i,1,n) if(cnt[a[i]]<B) pos[a[i]].push_back(i);
		ffor(i,1,m) pos[i].push_back(n+1);
		ffor(i,1,m) if(cnt[i]>=B) solve(i);
		else Solve(i);
		int mx_val=*max_element(mx+1,mx+m+1);
		cout<<mx_val<<'\n';
		ffor(i,1,m) if(mx[i]==mx_val) cout<<lsh[i]<<'\n';
	}
	return 0;
}
```

---

## 作者：nullqtr_pwp (赞：0)

先转化题意，$[l,r]$ 中操作必然是将区间内的某种数转化成新序列的众数。内外无关，所以会把区间内的众数转化成外面的众数。因此题意是在问选取区间 $[l,r]$，最大化区间内众数和外面的众数各自的出现次数之和。

不太好直接用数据结构维护，但是考虑到出现次数，通常可以与颜色段，根号分治相关联。考虑对每种颜色大小根号分治，设阈值为 $B$。

考虑新的序列的众数是 $x$，考虑 $x$ 的出现次数。
		
先讨论 $x$ 的出现次数是 $\ge B$ 的，那么这样的 $x$ 的出现次数一定 $\leq \dfrac{n}{B}$。


先考虑 $x$ 被转化的情况。
		
可以枚举区间内的众数颜色 $y$。记录 $cnt_i$ 表示颜色 $i$ 的出现次数。那么问题转化成，枚举 $y$ 的位置，在这里面选取左右端点 $l,r$，要将 $y$ 转化成 $x$，贡献就是 $l,r$ 内 $y$ 的个数减去区间内 $x$ 的个数，再加上 $cnt_x$。

这个可以直接 DP 来做。就是枚举 $y$ 的每个位置 $i$，$dp_i$ 表示 $r=i$ 的贡献最大值，分类讨论 $l\ge i-1$ 和 $l=r$ 来转移，然后记录下前缀和可以 $O(1)$ 转移。事实上就是最大子段和。对于 $x$ 转化成 $y$ 的情况，同理，就是取个相反数就行。
		
这一部分对于给定的 $x$，均摊时间复杂度 $O(n)$。算上跑的次数，时间复杂度是 $O(\dfrac{n^2}{B})$ 的。
		
现在我们已经解决了，出现次数大的与出现次数小的相互转化的情况。

考虑出现次数小的与另一个出现次数小的转化的情况。设当前考虑的是 $x$ 被转化的情况，可以暴力找所有的区间，因为我们只关心 $x$ 出现的位置所截取出来的 $O(B)$ 个关键段，作为这个段的关键点。

然后 $[l,r]$ 的变化量显然就是 $[l,r]$ 的众数减去 $[l,r]$ 中 $x$ 的个数。$[l,r]$ 都暴力枚举了，$x$ 的个数当然好求。但是 $[l,r]$ 的众数并不是好求。注意到我们只关心出现次数 $<B$ 的颜色，所以众数的量级也是 $O(B)$ 的。

我们并没有必要去对于每种颜色独立求这个众数，我们可以放在一起，从左到右扫描线。不考虑出现次数 $>B$ 的颜色。设当前扫到了 $p$，可以令 $s_i$ 表示 $[i,p]$ 的众数个数，然后钦定转化的右端点是 $p$，枚举与 $p$ 的相同颜色的位置 $l$，然后暴力更新这里面的众数个数，此时对于答案贡献是好算的。

注意到 $\sum s_i\le nB$，所以暴力跳更新的复杂度是对的。两个转化的次数小于 $B$ 部分的复杂度是 $O(nB)$。

总复杂度 $O(nB+\dfrac{n^2}{B})$，取 $B=\sqrt n$，总复杂度 $O(n\sqrt n)$。

[参考代码](https://loj.ac/s/2001679)

---

## 作者：Xy_top (赞：0)

口胡半小时，代码五小时。。。

因为是众数，容易想到根号分治，如果一个数的出现次数 $\geq450$ 在后文中称其为大数，反之称其为小数。

题意是从这个区间中截出一段（可以碰到边界），使得两段的众数出现次数之和尽可能大。

先来考虑区间外侧是大数 $x$ 的情况，首先需要将所有的数字离散化，然后显然要去枚举截出一段的数字 $y$。

然后来看怎么办，如果截出了 $[l,r]$ 这个区间，那么这个区间内的 $x$ 就无法贡献给答案了，但同时会收获这个区间内所有的 $y$。

综上，一个区间 $[l,r]$ 的贡献等于这个区间内 $y$ 出现的次数减去 $x$ 出现的次数。

又有一个显然的结论，就是左右端点 $l$ $r$ 一定是在 $y$ 出现的位置，否则可以左右移动不影响答案。

那么这种情况就有办法了，我们对于所有 $i$ 满足 $a_i=x$ 和所有 $i$ 满足 $a_i=y$ 的数拎出来做一个最大子段和，然后还要加上 $\operatorname{occ}(x)$。

这样对一个数做的时间复杂度就是 $\operatorname{occ}(y)+\operatorname{occ}(x)$，对于所有数做再乘上 $n$，显然无法接受。

可以预处理 $s_i$，表示 $1\cdots i$ 中出现了几个 $x$，这样两个相减就能得到区间内出现了几个 $x$，然后只需要扫一遍所有 $y$ 出现的位置即可了。

对于每个大数做这个操作时间复杂度是 $\sum\limits_{i=1}^n \operatorname{occ}(i)=n$，而大数最多 $\sqrt{n}$ 个，所以时间复杂度为 $n\sqrt{n}$。

如果大数在外侧也是同理的，最大子段和处略有修改，详见代码。

紧接着就只剩下小数配对小数的情况了，小数的弱点是出现的次数很少，所以可以考虑它的出现次数。

对于每个小数，仅考虑它在外侧的情况就够了。（内侧的话会被外侧的统计）考虑枚举每两个该小数出现的位置，这样是平方的，不会超。

然后求一下这两个位置中的众数再加上外面出现当前枚举的这个小数的次数即可。

现在的问题就是怎么求得两个区间内的众数，注意到需要求 $n\sqrt{n}$，所以每次必须做到常数时间。

因为内侧也是小数，所以还有个性质就是内侧众数出现次数是不会超过 $\sqrt{n}$ 的，否则就是大数了。

此时可以预处理一个 $pre_{i,j}$ 意思是从 $i$ 向后，第一个 $r$ 使得 $[i,r]$ 这个区间内众数出现的次数达到了 $j$ 次，至于它的预处理，可以考虑枚举 $j$ 然后类似双指针。

对于每个小数出现的位置将其作为左端点，不断向右扩展，$[i,j]$ 中众数出现的次数一定是不降的，那么再搞一个 $r$ 存当前这个区间内众数出现的次数，然后每次右端点移到下一个小数出现的位置后判断这个区间内众数出现的次数能否再多加一点，能加则加。

貌似这个问题便解决了，但是上面的方法处理的仅是小数包小数的情况，内侧小数不能取到左右端点，所以还得扫一遍。

至此这道题就解决了，另外借用 Alex_wei 大佬的优化方法，将根号一维放在前面进行快速访问减少时间，然后块长再开小一点。

代码：

```cpp
#include <bits/stdc++.h>
#define For(i, a, b) for (int i = (a); i <= (b); i ++)
#define foR(i, a, b) for (int i = (a); i >= (b); i --)
#define re return
#define mp make_pair
#define pb push_back
#define pf push_front
#define pi pair <int, int>
using namespace std;
int n, ans[200005], cnt;
int a[200005], s[200005], bin[200005], row[200005], pre[451][200005];
int t[200005], pre1[200005], pre2[200005];
vector <int> G[200005], d;
const int b = 250;
map <int, int> m;
void work1 () {//大数配对其他的数（大数在外侧）
	For (i, 1, cnt) {
		if (G[i].size () < b) continue;
		For (i, 1, n) s[i] = 0;
		for (int j : G[i]) s[j] ++;
		For (j, 1, n) s[j] += s[j - 1];
		For (j, 1, cnt) {
			if (i == j) continue;
			int f = 1;
			For (k, 1, G[j].size () - 1) {
				f -= s[G[j][k] ] - s[G[j][k - 1] ];
				f = max (f, 0);
				++ f;
				if (f + G[i].size () > ans[i]) ans[i] = f + G[i].size ();
			}
		}
	}
}
void work3 () {//大数在内侧 
	For (i, 1, cnt) {
		if (G[i].size () < b) continue;
		For (i, 1, n) s[i] = 0;
		for (int j : G[i]) s[j] ++;
		For (j, 1, n) s[j] += s[j - 1];
		For (j, 1, cnt) {
			if (i == j) continue;
			int f = s[G[j][0] ];
			For (k, 0, G[j].size () - 1) {
				if (k) f += s[G[j][k] ] - s[G[j][k - 1] ];
				if (f + G[j].size () > ans[j]) ans[j] = f + G[j].size ();
				-- f;
				f = max (f, 0);
			}
		}
	}
}
void work2 () {//小数配对小数
	For (i, 1, cnt) {
		if (G[i].size () >= b) continue;
		int cur = G[i].size () + pre1[G[i][0] - 1];
		if (cur > ans[i]) ans[i] = cur;
		cur = G[i].size () + pre2[G[i].back () + 1];
		if (cur > ans[i]) ans[i] = cur;
		For (j, 0, G[i].size () - 1) {
			ans[i] = max (ans[i], j + 1 + pre2[G[i][j] + 1]);
			int r = 0;
			For (k, j, G[i].size () - 1) {
				while (r != b && pre[r + 1][G[i][j] + 1] && pre[r + 1][G[i][j] + 1] < G[i][k]) ++ r;
				int cur = j + 1 + G[i].size () - k + r;
				if (cur > ans[i]) ans[i] = cur;
			}
		}
		foR (j, G[i].size () - 1, 0) ans[i] = max (ans[i], pre1[G[i][j] - 1] + (int) (G[i].size () ) - j);
	}
}
void solve () {
	cnt = 0;
	scanf ("%d", &n);
	For (i, 1, n) {
		scanf ("%d", &a[i]);
		if (!m[a[i] ]) {
			m[a[i] ] = ++ cnt;
			row[cnt] = a[i];
		}
		t[i] = m[a[i] ];
		G[m[a[i] ] ].push_back (i);
	}
	For (j, 1, b) {
		For (i, 1, n) bin[i] = 0;
		int r = 1;
		For (i, 1, n) {
			if (i - 1) bin[t[i - 1] ] --;
			while (r <= n && bin[t[r] ] < j - 1) {
				bin[t[r] ] ++;
				++ r;
			}
			if (r > n) break;
			pre[j][i] = r;
		}
	}
	int mx = 0;
	For (i, 1, n) bin[i] = 0;
	For (i, 1, n) {
		bin[t[i] ] ++;
		mx = max (mx, bin[t[i] ]);
		pre1[i] = mx;
	}
	mx = 0;
	For (i, 1, n) bin[i] = 0;
	foR (i, n, 1) {
		bin[t[i] ] ++;
		mx = max (mx, bin[t[i] ]);
		pre2[i] = mx;
	}
	work1 ();
	work2 ();
	work3 ();
	mx = 0;
	For (i, 1, n) mx = max (mx, ans[i]);
	printf ("%d\n", mx);
	For (i, 1, cnt) if (ans[i] == mx) d.push_back (row[i]);
	sort (d.begin (), d.end () );
	For (i, 0, d.size () - 1) printf ("%d\n", d[i]);
	For (i, 1, cnt) G[i].clear ();
	d.clear ();
	For (i, 1, n) For (j, 1, min (n, b) ) pre[j][i] = 0;
	For (i, 1, n) pre1[i] = pre2[i] = 0;
	For (i, 1, cnt) ans[i] = 0;
	m.clear ();
}
signed main () {
	int _ = 1;
	scanf ("%d", &_);
	while (_ --) solve ();
	return 0;
}
```


---

## 作者：yzy1 (赞：0)

注意到题目等同于选择一个子区间，最大化子区间内的众数的出现次数加上子区间外的众数的出现次数．转化后的题目就和加法没啥关系了，可以将序列离散化．

考虑根号分治，设定阈值 $B$，将序列中出现的所有数分为出现次数 $\ge B$ 和 $<B$ 的两类．则答案的贡献一定可以被归类为以下三种中的至少一种：

- 子区间外众数属于第一类．
- 子区间内众数属于第一类．
- 内外众数均属于第二类．

先考虑处理前两种情况．以第一种情况举例，枚举第一类数字 $c$ 和第二类数字 $d$．设 $c$ 在 $a$ 数组中第 $i$ 次出现的下标为 $C_i$，$d$ 在 $a$ 数组中第 $i$ 次出现的下标为 $D_i$．则选择一个形如 $[D_{l-1}, D_{r+1}]$ 的区间一定不劣．我们设 $\mathit{cntc}$ 代表 $c$ 在这个区间 $[D_{l-1}, D_{r+1}]$ 出现的次数，则选这个区间比起不选会让答案多 $\mathit{cntc} - (r-l+1)$，我们只需要选出一个这个值最大的区间即可．先预处理前缀和以快速计算 $\mathit{cntc}$，然后在枚举 $r$ 的过程中贪心维护 $l$ 即可．由于第一类数字最多有 $O(\frac n B)$ 个．故该部分时间复杂度 $O(\frac{n^2}B)$．

第二种情况和第一种情况处理起来类似，这里不再过多叙述．

对于第三种情况，考虑枚举一个第二类数字 $d$ 作为区间外的众数．设 $d$ 在 $a$ 数组中第 $i$ 次出现的下标为 $D_i$．则最优区间要么以 $D_i+1$ 作为左端点，要么整个区间都在 $D_1$ 前面．对于后者，我们可以枚举一个区间内众数的出现次数 $c$，然后贪心地选择一个最短的区间更新答案．而对于前者，直接把 $a$ 数组 reverse 一下再去跑这个做法就行．直接去求右端点有些麻烦．考虑交换枚举顺序，先枚举 $c$，再枚举 $d$ 和左端点．此时可以通过双指针快速维护右端点，过程中顺便维护左右两侧 $d$ 的出现次数和区间内众数出现次数即可．注意到区间内众数出现次数不超过 $B$，故该部分时间复杂度 $O(n B)$．

当我们取 $B=O(\sqrt{n})$ 时，时间复杂度达到最优 $O(n\sqrt{n})$，空间复杂度为 $O(n)$．可以通过本题．

代码参考见 [原始 OJ 提交](https://uoj.ac/submission/652376)．


---

## 作者：无名之雾 (赞：0)

## 前言

这道题目大概是我在上周二找到的，大概想出思路加写出代码 AC 花了 $5$ 天左右 （~~我还是太菜了~~）在此感谢期间为我调试代码的大佬 [$\textcolor{#000000}{\textbf{x}}\textcolor{#ff0000}{\textbf{iaoming007}}$](https://www.luogu.com.cn/user/938449) 与我的好朋友 [$\textcolor{#000000}{\textbf{H}}\textcolor{#ff0000}{\textbf{exiuqi}}$](https://www.luogu.com.cn/user/636987)。（我还是~~在信息课水过的呢~~）。


## 思路


### 转换

如果我们对某个区间进行操作过，那么区间内只有一种值是有用的，即成为众数的那个，所以，我们就把操作就可以简单的把操作转换为 将某个区间 $[l,r]$ 中的所有 $x$ 变为 $y$。

### 思考
如果有一个数 $x$ 成为了众数，那么一定存在一个 $[l,r]$  满足有 $k$ 在 $[l,r]$ 之间的个数与 $[1,l)$ $(r,n]$ 内 $x$ 的个数相加等于众数出现次数的最大值。所以我们只需要对于出现次数根号分治即可。

### 实现

由于在区间中出现次数超过 $\sqrt{n}$ 的数，最多出现 $\sqrt{n}$ 个。所以对于 $k$ 直接枚举，时间复杂度 $O(\sqrt{n})$。

而区间众数，我们同样采用枚举，检查 $\sqrt{n}$ 个 $k$ 但是显然直接检查时间复杂度直接爆炸。所以思考，发现可以采用类似最大字段和的思想。若为假定的区间众数则处理。时间复杂度 $O(n)$。

而出现次数较少的 $k$ 则同样采用上面的思想进行枚举，时间复杂度 $O(n\sqrt{n})$

而最后我们维护等值段即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
inline void out(int x){
    if(x==0){putchar('0');return;}
	int len=0,k1=x,c[1000005];
	if(k1<0)k1=-k1,putchar('-');
	while(k1)c[len++]=k1%10+'0',k1/=10;
	while(len--)putchar(c[len]);
	puts("");
}
const int N=3e5+5;
int a[N],b[N],s[N],maj[N],cnt[N],ans;
bool flag[N];
vector<int>v[N],can; 
inline void upd(int v, int c){
	if(ans<v){
	    can.resize(1); 
		ans=v,can[0]=c;
	}
	else if(ans==v)can.push_back(c);
}
inline void add(const int &col){
	if(v[col].size()>470)return;
	for(int i=cnt[col]-1,j=1;~i;i--,j++){
		for(int k=v[col][i];k>0&&maj[k]<j;k--){
			maj[k]=j;
		}
	}
}
inline void check(const int &col){
	if(v[col].size()>470)return;
	for(int i=cnt[col]-1,k=0;~i;i--,k++){
		const int vv=maj[v[col][i]+1]-k;
		upd(v[col].size()+vv,col);
	}
}
signed main(){
	int T=read();
	while(T--){
		int n=read();ans=0;
		can.resize(0); 
		for(int i=1;i<=n;i++)a[i]=b[i]=read();
		sort(b+1,b+n+1);
		int num=unique(b+1,b+n+1)-b-1;
		for(int i=1;i<=n;i++)v[i].clear();
		for(int i=1;i<=n;i++)a[i]=lower_bound(b+1,b+num+1,a[i])-b;
		for(int i=1;i<=n;i++)v[a[i]].push_back(i);
		for(int k=1;k<=num;k++){
			if(v[k].size()>470){
				memset(s+1,0,n<<2);
				for(const int &i:v[k])s[i]++;
				for(int i=2;i<=n;i++)s[i]+=s[i-1];
				int now=1;
				for(int i=1;i<=num;i++){
					if(i!=k){
						int len=v[i].size(),m=0,m2=0,t=1;
						for(int j=0;j<len;j++){
							if(m>=j-s[v[i][j]])m=j-s[v[i][j]];
							else now=max(now,j+1-s[v[i][j]]-m);
							if(m2>=s[v[i][j]]-j)m2=s[v[i][j]]-j-1;
							else t=max(t,s[v[i][j]]-j-m2);
						}
						t=max(t,s[n]-len-m2);
						upd(t+len,i);
					}
					upd(now+s[n],k);
				} 
			}
		}
		memset(maj+1,0,n<<2);
		memset(cnt+1,0,n<<2);
		for(int r=1;r<=n;r++){
			cnt[a[r]]++;
			add(a[r]);
			if(a[r]==a[r+1])continue;
			check(a[r+1]);
			upd(maj[1]-cnt[a[r+1]]+v[a[r+1]].size(),a[r+1]);
		}
		for(int i=1;i<=num;i++){
			if(i!=a[n])check(i);
		}
		out(ans);
		memset(flag,0,n<<2);
		for(const int &i:can)flag[i]=1;
		for(int i=1;i<=num;i++){
			if(flag[i])out(b[i]);
		}
	} 
	return 0;
}
```

（本人写法常数巨大无比，勿喷）。

---

## 作者：Cocoly1990 (赞：0)

ZJOI 2022 众数。

和出现次数，众数挂钩的大概很容易联想到 sqrt.

考虑平衡规划，套路的，对出现次数分治。记 $cnt_i$ 表示 $i$ 在序列中出现的次数。

- $cnt_i>B$，
  - 这样的 $i$ 的个数不超过 $\frac{n}{B}$ 个，我们考虑枚举这个数的具体是什么，并枚举他是否作为区间内的数。
  - 注意到区间内和区间外本质上是等价的，故只分析区间内的情况。
  - 我们同时枚举区间外的数 $j$ 是什么，并且把原序列中等于 $i$ 的数设做 $-1$，等于 $j$  的数字设做 $1$，那么原问题等价于求一个最大子段和的。
  - 但是这样的时间复杂度还是太高了，不难发现，我们选择区间的左右端点必然是顶着 $j$ 的，则最大子段和的有效转移点为 $cnt_j$。
  - 这部分的时间复杂度 $\mathcal{O}(\frac{n}{B}\times \sum cnt_j)=\mathcal{O}(\frac{n^2}{B})$。
- $cnt_i\leq B$
  - 此时我们只需要解决区间内外的数**都**小于等于 $B$ 的情况。
  - 仍然枚举外层的数，但是这次我们直接枚举内层的众数**大小**，这个东西显然是有单调性的，可以预处理。
  - 然后同样的，区间端点也一定是顶着 $i$ 的。
  - 具体的细节上大概需要先枚举 $i$ 和起始位置，然后枚举内层答案，这样就能保证时间复杂度控制在 $\mathcal{O}(nB)$。

然后平衡一下取 $B=\sqrt n$，时间复杂度就是严格单根了。

~~这种题真的一不小心就复杂度退化了啊。~~



---


# [AHOI2022] 排列

## 题目描述

对于一个长度为 $n$ 的排列 $P = (p_1, p_2, \ldots, p_n)$ 和整数 $k \ge 0$，定义 $P$ 的 $k$ 次幂

$$P^{(k)} = \left( p^{(k)}_1, p^{(k)}_2, \ldots, p^{(k)}_n \right),$$

该排列的第 $i$ 项为

$$p^{(k)}_i = \begin{cases} i, & k = 0, \\ p^{(k - 1)}_{p_i}, & k > 0. \end{cases}$$

容易证明任意排列的任意次幂都是一个排列。

定义排列 $P$ 的**循环值** $v(P)$ 为最小的**正整数** $k$ 使得 $P^{(k + 1)} = P$。

给出一个长度为 $n$ 的排列 $A = (a_1, a_2, \ldots, a_n)$，对于整数 $1 \le i, j \le n$，定义 $f(i, j)$：若存在 $k \ge 0$ 使得 $a^{(k)}_i = j$，则 $f(i, j) = 0$，否则设排列 $A_{i j}$ 为将排列 $A$ 的第 $i$ 项 $a_i$ 和第 $j$ 项 $a_j$ 交换后得到的排列，则 $f(i, j) = v(A_{i j})$。

求 $\sum_{i = 1}^{n} \sum_{j = 1}^{n} f(i, j)$ 的值。答案可能很大，你只需要输出其对 $({10}^9 + 7)$ 取模的结果。

## 说明/提示

**【样例解释 #1】**

对于第一组测试数据，$f(1, 2) = f(2, 1) = f(2, 3) = f(3, 2) = f(1, 3) = f(3, 1) = 2$，其余的 $f(i, j)$ 均为 $0$。

对于第二组测试数据，所有的 $f(i, j)$ 均为 $0$。

**【样例 #2】**

见附件中的 `perm/perm2.in` 与 `perm/perm2.ans`。

该组样例中，第一个测试数据满足 $n \le 35$，前四个测试数据满足 $n \le 200$，所有测试数据满足 $n \le 2500$。

**【样例 #3】**

见附件中的 `perm/perm3.in` 与 `perm/perm3.ans`。

该组样例中，第一个测试数据满足特殊性质 A，第二个测试数据满足特殊性质 B，第三个测试数据满足特殊性质 C，前四个测试数据满足 $n \le {10}^5$，第五个测试数据满足 $n \le 5 \times {10}^5$。

特殊性质的具体内容参见数据范围部分。

**【数据范围】**

对于 $100 \%$ 的测试数据，$1 \le T \le 5$，$1 \le n \le 5 \times {10}^5$，$1 \le a_i \le n$。

| 测试点编号 | $n \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1 \sim 2$ | ${10}^5$ | A |
| $3$ | $35$ | 无 |
| $4$ | $200$ | 无 |
| $5$ | $2500$ | 无 |
| $6$ | ${10}^5$ | B |
| $7$ | ${10}^5$ | C |
| $8$ | ${10}^5$ | 无 |
| $9 \sim 10$ | $5 \times {10}^5$ | 无 |

特殊性质 A：$a_i = (i \bmod n) + 1$。  
特殊性质 B：对于任意 $1 \le i \le n$，存在 $1 \le k \le 20$，$a^{(k)}_i = i$。  
特殊性质 C：存在大小不超过 $10$ 的集合 $S$，使得对于任意 $1 \le i \le n$，存在 $x \in S, k \ge 0$，$a^{(k)}_x = i$。

**【提示】**

输入数据规模较大，请使用较为快速的输入方式。

## 样例 #1

### 输入

```
2
3
1 2 3
3
2 3 1
```

### 输出

```
12
0
```

# 题解

## 作者：DeaphetS (赞：36)

本题涉及了关于线性筛、质因数分解、置换、分析数据范围特性等多种技巧，是一道难得的好题，为出题人点赞！

### Hint 1 

可以把每个 $p_i$ 看成从 $i$ 连向 $p_i$ 的一条有向边，这样整个图会由若干个互不相交的简单环构成（所有点的入度出度均为 $1$ ）。

可以通过分析得出， $P^k$ 的意义就相当于每个人一开始都在初始的 $i$ 号结点， $k$ 每次 $+1$ 就变成所有人在图上走一步。

于是我们得出了 $f(i,j)=0$ 的充要条件： $i,j$ 在同一个环上。

### Hint 2

考虑对一个排列 $P$ 如何计算 $v(P)$ ，设 $i$ 号结点所在的环长为 $r_i$ ，则可以得出 $v(P)=\operatorname{lcm}\{r_1,r_2,\cdots,r_n\}$ ，这是因为所有点都同时回到原点需要保证每个人的步数都为 $r_i$ 的倍数。

接着考虑 $v(A_{ij})$ 的值，草稿纸上画一画就可以发现，把两个不同环上的点的出边进行交换，就会把两个环合并，因此 $v(A_{ij})$ 的值就为 $r_i+r_j$ 与其他环长取 $\operatorname{lcm}$ 的值。

到这一步实际上我们发现如果枚举 $i,j$ 并暴力计算 $\operatorname{lcm}$ ，那么可以得到一个看上去是 $O(n^3\log n)$ 的做法。

### Hint 3

对上一步的暴力做法进行些许优化，对每个相同的 $r_i$ 其实是不用重复计算的，所以设环长的种类数为 $m$ ，能做到 $O(m^3\log n)$ 的复杂度。

这里需要进行对数据范围分析，注意到这里是 $m$ 个互不相同的数相加不超过 $n$ ，所以一定有 $\sum_{i=1}^m\le n$ ，计算得出 $m$ 是 $O(\sqrt n)$ 级别的，所以时间复杂度**貌似**可以优化到 $O(n\sqrt n\log n)$ 。

### Hint 4

但是我们会发现 $\operatorname{lcm}$ 的值可能会很大并不能直接计算，所以需要对每个 $r_i$ 进行质因数分解，最后在每个质因子上计算指数的最大值得出结果，这样单次计算 $\operatorname{lcm}$ 的时间复杂度为 $O(m\sqrt n+cnt_{prime}\cdot\log\log n)$ 。

这里可以利用线性筛的性质来加速质因数分解的过程，注意到每次线性筛筛到一个数时，一定是被他的最小质因子筛到，于是可以预处理记录下每个数字对应的最小质因子，这样单次质因数分解的时间复杂度可以优化到 $O(\log n)$ 。

除此之外，我们还可以在每次分解质因数时直接质因子判断对应指数的值，并判断是否乘上去，如果采用 `map` 或 `set` 来记录，这样单次计算 $\operatorname{lcm}$ 的复杂度变成了 $O(m\log^2 m)$ ，总时间复杂度为 $O(n\sqrt n\log^2 n)$ 。

如果在判断每个质因子对应的最大指数时做到 $O(1)$ 的维护，那么就是 $O(n\sqrt n\log n)$ 的时间复杂度，期望得分 80 ，如果能做到常数优秀且熟练掌握卡常技巧是完全有机会通过此题的。

### Hint 5

继续优化求 $\operatorname{lcm}$ 的方法，我们可以预先求出所有数字的 $\operatorname{lcm}$ ，然后记录每个质因子对应的三个最大指数（因为后面要删掉两个数），这样每次删数的时候就可以现场质因数分解 $O(\log^2 n)$ 维护 $\operatorname{lcm}$ ，添加一个数字的时候也能够当场维护。

另外，也可以直接用 `multiset` 记录每个质因子对应的指数集合，同样也是 $O(\log^2 n)$ 的维护复杂度。

总时间复杂度 $O(n\log^2n)$ ，已经足够通过此题。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 500050
#define LL long long
#define MOD 1000000007
int T,n,a[N],r[N],vis[N];
int cnt,cntR,p[N],v[N],LCM,m,ans;
vector<pair<int,int>>d;
multiset<int>s[N];
LL qow(LL x,LL y){return y?(y&1?x*qow(x,y-1)%MOD:qow(x*x%MOD,y/2)):1;}
void add(int x)
{
	while(x>1){
		int p=v[x],c=0,k=(*s[p].rbegin());
		while(v[x]==p)x/=v[x],c++;
		if(c>k)LCM=1ll*LCM*qow(p,c-k)%MOD;
		s[p].insert(c);
	}
}
void del(int x)
{
	while(x>1){
		int p=v[x],c=0,k;
		while(v[x]==p)x/=v[x],c++;
		s[p].erase(s[p].find(c));
		k=(*s[p].rbegin());
		if(k<c)LCM=1ll*LCM*qow(p,MOD-1+k-c)%MOD;
	}
}
void init()
{
	LCM=1;
	cntR=0;
	d.clear();
	for(int i=1;i<=cnt;i++)s[p[i]].clear(),s[p[i]].insert(0);
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		r[i]=vis[i]=0;
	}
	for(int i=1;i<=n;i++)if(!vis[i]){
		int x=i,c=1;
		while(a[x]!=i)vis[x]=1,c++,x=a[x];
		add(c);
		vis[x]=1;
		r[++cntR]=c;
	}
	sort(r+1,r+cntR+1);
	for(int i=1;i<=cntR;i++){
		if(d.empty() || r[i]!=d.back().first)
			d.push_back(make_pair(r[i],1));
		else d[d.size()-1].second++;
	}
	m=d.size(),ans=0;
	for(int i=0;i<m;i++){
		del(d[i].first);
			for(int j=i+1;j<m;j++){
			int res=2ll*(1ll*d[i].first*d[i].second%MOD)*(1ll*d[j].first*d[j].second%MOD)%MOD;
			int x=d[i].first+d[j].first;
			del(d[j].first);
			add(x);
			ans=(1ll*res*LCM+ans)%MOD;
			del(x);
			add(d[j].first);
		}
		if(d[i].second>1){
			int res=1ll*(1ll*d[i].first*d[i].second%MOD)*(1ll*d[i].first*(d[i].second-1))%MOD;
			int x=d[i].first+d[i].first;
			del(d[i].first);
			add(x);
			ans=(1ll*res*LCM+ans)%MOD;
			del(x);
			add(d[i].first);
		}
		add(d[i].first);
	}
	printf("%d\n",ans);
}
int main()
{
	v[1]=1;
	for(int i=2;i<N;i++){
		if(!v[i])v[i]=i,p[++cnt]=i;
		for(int j=1;j<=cnt && i*p[j]<N;j++){
			v[i*p[j]]=p[j];
			if(i%p[j]==0)break;
		}
	}
	scanf("%d",&T);
	while(T--)init();
}
```



---

## 作者：dbxxx (赞：13)



[P8338 [AHOI2022] 排列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P8338)


$T$ 组数据。

对于一个长度为 $n$ 的排列 $P = (p_1, p_2, \ldots, p_n)$ 和整数 $k \ge 0$，定义 $P$ 的 $k$ 次幂

$$
P^{(k)} = \left( p^{(k)}_1, p^{(k)}_2, \ldots, p^{(k)}_n \right),
$$

该排列的第 $i$ 项为

$$
p^{(k)}_i = \begin{cases} i, & k = 0, \\ p^{(k - 1)}_{p_i}, & k > 0. \end{cases}
$$

容易证明任意排列的任意次幂都是一个排列。

定义排列 $P$ 的**循环值** $v(P)$ 为最小的**正整数** $k$ 使得 $P^{(k + 1)} = P$。

给出一个长度为 $n$ 的排列 $A = (a_1, a_2, \ldots, a_n)$，对于整数 $1 \le i, j \le n$，定义 $f(i, j)$：若存在 $k \ge 0$ 使得 $a^{(k)}_i = j$，则 $f(i, j) = 0$，否则设排列 $A_{i, j}$ 为将排列 $A$ 的第 $i$ 项 $a_i$ 和第 $j$ 项 $a_j$ 交换后得到的排列，则 $f(i, j) = v(A_{i, j})$。

求 $\sum_{i = 1}^{n} \sum_{j = 1}^{n} f(i, j)$ 的值。答案可能很大，你只需要输出其对 $({10}^9 + 7)$ 取模的结果。

- $1 \le T \le 5$；

- $1 \le a_i \le n \le 5 \times 10^5$。


首先明确一下排列的基本定义：长度为 $n$ 的排列指的是一个 $n$ 元组（可以理解为长度为 $n$ 的数组），满足 $1$ 到 $n$ 这 $n$ 个数，每个数都恰好在这个 $n$ 元组中出现 $1$ 次。

---

观察题目中排列的幂的定义，从 $P^{(k)}$ 到 $P^{(k + 1)}$，是通过将 $P^{(k)}$ 中每一个数 $v$ 更改为 $p_v$ 得到的，也就是一种类似于 $i \to p_i$ 的迭代。

考虑对于长度为 $n$ 的排列 $P$ ，构造一个有向图 $G$，图 $G$ 中恰有 $n$ 个编号从 $1$ 到 $n$ 的点和 $n$ 条边，第 $i$ 条边为 $i \to p_i$。

发现这个图会是一堆简单环构成的（可以有自环），这是因为图 $G$ 经过上述连边方式，每个点的入度一定恰好为 $1$（注意到排列的性质），出度也一定恰好为 $1$，如此以来一定会形成一堆简单环的集合。

这么建图我们的目的在于将 $i \to p_i$ 的迭代具体化——一开始有 $n$ 个小人，第 $i$ 个小人在节点 $i$，每个小人顺着所在的环走 $k$ 步后，第 $i$ 个小人所在的节点就是 $P^{(k)}$ 的第 $i$ 个元素。

举个例子：$P = (3, 1, 2)$。对排列 $P$ 建图得到：

![](https://cdn.luogu.com.cn/upload/image_hosting/dcvnhxb8.png)

第 $1$ 个小人一开始在 $1$，第 $2$ 个小人一开始在 $2$，第 $3$ 个小人一开始在 $3$。$P^0 = (1, 2, 3)$。

现在所有小人顺着走一步。第 $1$ 个小人此时在 $3$，第 $2$ 个小人此时在 $1$，第 $3$ 个小人此时在 $2$，因此 $P^1 = (3, 1, 2)$。

另外很显然 $P^1 = P$。

然后所有小人再顺着走一步，第 $1$ 个小人此时在 $2$，……就可以得到 $P^2 = (2, 3, 1)$。

然后再走一步，得到 $P^3 = (1, 2, 3)$。发现：这等于 $P^0$！

那么接下来肯定又会有 $P^4 = P^1$，$P^5 = P^2$，$P^6 = P^3=P^0$，如此循环下去……发现循环节是 $3$。

事实上所有排列的幂都一定会出现循环，而循环节的长度正是 $v(P)$ 的定义。

---

定义排列 $P$ 的**循环值** $v(P)$ 为最小的**正整数** $k$ 使得 $P^{(k + 1)} = P$。

我们知道，$P^ {(k +1)}$ 代表第 $i$ 个小人在节点 $p_i$，每个人顺着走 $k$ 步后的结果。

那么 $P^{(k + 1)} = P$ 是什么意思？ 也就是说，每个小人一开始在 $p_i$，能满足所有人挨个顺着走 $k$ 步后还能回到 $p_i$。$v(P)$ 描述了 $k$ 的最小值。

设总共有 $m’$ 个环，第 $i$ 个环的环长是 $r_i$，于是有 $v(P) = \operatorname{lcm}(r_1, r_2, \cdots, r_{m'})$。原因：每个人在 $p_i$，走 $k$ 步还能回来，充要条件就是 $k$ 是所有环长的倍数，那最小的 $k$ 就是所有环长的最小公倍数。

举个例子，我们对 $P = (4, 6, 8, 9, 2, 5, 10, 7, 1, 3)$ 进行循环值分析。首先画个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/tirtxpmf.png)

发现总共有 $3$ 个环，长度分别为 $4, 3, 3$，于是 $v(P)$ 就应该等于 $ \operatorname{lcm}(4, 3, 3) = 12$。因为所有小人都至少走 $12$ 步后，才能保证所有小人回到原位置。

---

现在来把视线转移到排列 $A$ 上。

> 对于整数 $1 \le i, j \le n$，定义 $f(i, j)$：若存在 $k \ge 0$ 使得 $a^{(k)}_i = j$，则 $f(i, j) = 0$，否则设排列 $A_{i, j}$ 为将排列 $A$ 的第 $i$ 项 $a_i$ 和第 $j$ 项 $a_j$ 交换后得到的排列，则 $f(i, j) = v(A_{i, j})$。 

分别考虑。

---

什么时候存在 $k \ge 0$ 使得 $a^{(k)}_i = j$？

先来看 $a_i^{(k)}$ 是个什么东西。阅读题目我们发现，它其实是 $A^k$ 的第 $i$ 项。

考虑在 $A$ 的图上，发现所有的 $a_i^{(k)}$ 其实也就是在说图上的 $a_i$ 这个点走 $k$ 步。由于 $k$ 的取值是任意的，那么只要 $a_i$ 和 $j$ 在同一个环上，那么 $a_i$ 就可以走 $k$ 步到达 $j$。

也就是说：$a_i$ 和 $j$ 在同一个环上，是存在 $k \ge 0$ 使得 $a^{(k)}_i = j$ 的充要条件。

---

否则，怎么求 $v(A_{i, j})$？

考虑交换 $a_i$ 和 $a_j$ 会有什么影响。

由于我们现在知道，$a_i$ 和 $j$ 不在同一个环上（否则会走上面那个分支），然后 $j$ 在 $a_j$ 在同一个环上，因此 $a_i$ 和 $a_j$ 不在同一个环上。

交换 $a_i$ 和 $a_j$，相当于在 $A$ 对应的图基础上，将 $i \to a_i$ 和 $j \to a_j$ 这两条边分别改为 $i \to a_j$ 和 $j \to a_i$，其他的边都不变，形成的新图就是 $A_{i, j}$ 的图。

发现这样修改，相当于将 $a_i$ 和 $a_j$ 所在的两个环合并成一个大环，环长是原来两个小环长的和。

证明：假设 $pre_i$ 是 $i$ 的前驱（$a_i$ 是 $i$ 的后继），假设原来是 $pre_i \to i \to a_i \to \cdots \to pre_i$ 和 $pre_j \to j \to a_j \to \cdots \to pre_j$ 两个小环，那么 $A_{i, j}$ 的图里面就会变成 $pre_i \to i \to a_j \to \cdots \to pre_j \to j \to a_i \to \cdots \to pre_i$ 这样一个大环。

举个例子，假设 $A = (4, 6, 8, 9, 2, 5, 10, 7, 1, 3)$（没错还是那个熟悉的排列）。把图再放一遍：

![](https://cdn.luogu.com.cn/upload/image_hosting/tirtxpmf.png)

现在考虑从 $A$ 扩展到 $A_{5, 3}$。$a_5 = 2, a_3 = 8$，那么我们应该把 $5 \to 2$ 和 $3 \to 8$ 这两条边分别改为 $5 \to 8$ 和 $3 \to 2$。

然后就会变成这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/aq3m7vgk.png)

可以看到确实是 $a_i$ 和 $a_j$ 所在的两个环合并了。

所以 $v(A_{i, j})$ 其实就是把 $a_i$ 和 $a_j$ 所在的两个环加和，和其他的所有环长取 $\operatorname{lcm}$ 的结果。

上面这个例子中就是 $v(A_{5, 3}) = \operatorname{lcm}(4 + 3, 3) = 21$。

---

到这里已经理论可做了，我们已经大体完成了翻译题目的工作。现在考虑加速最后结果的计算。

还是上面那个图，再放一次：

![](https://cdn.luogu.com.cn/upload/image_hosting/tirtxpmf.png)

我们把目标锁定在上面那个环和左下角那个环。会发现，从上面那个环随便选一个点，从左下角那个环随便选一个点，交换，结果肯定是 $21$。比如：$v(A_{5, 8}) = v(A_{2, 7}) = v(A_{6, 10}) = v(A_{2, 3}) = 21$。

再把目标锁定在上面那个环和右下角那个环，发现随便选之后答案仍然是 $21$。$v(A_{8, 9}) = v(A_{7, 1}) = v(A_{3, 4}) = v(A_{9, 3}) = 21$。

那有不是 $21$ 的吗？如果我们把目标锁定在下面这两个环，那么答案就会恒为 $\operatorname{lcm}(4, 3 + 3) = 12$。

为什么会这样呢？发现他跟我们选取两个点所在的环的长度有关系。选取两个点所在环长度分别是 $3, 4$，那答案就是 $21$；选取的两个点所在环长度分别是 $3, 3$，那么答案就是 $12$。那为啥没有 $4, 4$ 呢，因为没有两个长度为 $4$ 的环，选不出来。

如果两个环的长度相同，我们可以认为他们的本质是相同的，设本质不同的环总共有 $m$ 个，这个 $m$ 最多可能有多少个？

我们知道，环长总和不能超过 $n$，因此最坏的情况就是环长分别为 $1, 2, 3, \cdots, m$ 的情况，即使这样 $m$ 也是 $\sqrt n$ 量级的。

> 这是一个经典结论：如果 $\Sigma w_i = n$，那么值不同的 $w_i$ 的种类是 $\sqrt n$ 量级的（而且不满）。

因此只要枚举本质不同的环长，进行计算。

我们设 $v(i, j)$ 表示将长度为 $i$ 的环和长度为 $j$ 的环合并后排列的循环值，考虑它会对最后的答案产生多少个贡献。我们再设 $c_i$ 表示长度为 $i$ 的环的数量。

需要分两种情况讨论：

- $i \ne j$，根据乘法原理，贡献量应该是长度为 $i$ 的所有环里的所有点的数量（数目为 $c_i \times i$，环数量乘环长），乘上长度为 $j$ 的所有环里所有点的数量（数目为 $c_j \times j$），也就是 $c_i \times i \times c_j \times j$。
- $i = j$，即 $v(i, i)$ 的贡献。首先肯定需要满足 $c_i > 1$，因为至少有 $2$ 个长度为 $i$ 的环才能实现交换。同样根据乘法原理能得到贡献是 $c_i \times i \times (c_i - 1) \times i$。

根据对称性，上面的第一种情况中，也可以直接把 $j$ 从 $i + 1$ 开始枚举，给贡献乘个 $2$ 就行了。 

由于枚举的开销是 $m \times m= n$ 的，直接从 $n^2$ 优化到线性。

到这里复杂度是 $\mathcal{O}(n \times m \log n) = \mathcal{O}(n \sqrt{n} \log n)$。虽然拿不到满分也能拿到一个高分了。（这个复杂度似乎是 $80$ 分）

---

我们发现原题实际上就是想维护一个可重集合的 $\operatorname{lcm}$，支持询问删除 $2$ 个数，增加 $1$ 个数之后新的 $\operatorname{lcm}$ 的操作。询问之间互相独立（一次询问不会真的增删数）

但是发现 $\operatorname{lcm}$ 有可能非常大，很有可能不能直接算。

于是有了这样的启发：考虑对每个 $r_i$ 质因数分解，然后取每个质因子的幂次最大值计算结果。不过事实上我们后面还要获取两个环合并后长度的质因数分解，他可能不在 $r_i$ 中，所以我们需要把 $n$ 以内的数都预处理质因数分解好。

注意这里有一个小技巧：将 $2$ 到 $n$ 所有数质因数分解，可以先对 $2$ 到 $n$ 跑线性筛，同时记录每个数的最小质因子。然后再对 $2$ 到 $n$ 每个数枚举，对于一个数，不断除以它的最小质因子，直到除尽，再把除尽后剩下的数接着不断除以它的最小质因子……直到分解到剩下 $1$ 为止。这样因式分解的复杂度可以从 $\mathcal{O}(n \sqrt n)$ 优化到 $\mathcal{O}(n \log n)$。

那么就可以转化为维护若干个质数幂（所有环长的质因数分解出来的所有质因子幂的并集，同样，是可重集），支持询问删除 $2$ 个数对应的质因子幂，增加 $1$ 个数对应的质因子幂的情况下，每一个质因子的最大幂的乘积（就是 $\operatorname{lcm}$）。询问互相独立。

然后发现一开始那个集合只用记录下所有质因子幂中，每个质数对应最大的 $3$ 个幂，因为后面的不可能影响到  $\operatorname{lcm}$。比如如果集合里有 $2^2, 2^3, 2^4, 2^7$，那么 $2^2$ 就是没有用的。因为删掉两个数后，$2^3, 2^4, 2^7$ 会至少剩下一个，轮不到 $2^2$ 头上，因此它可以直接放弃统计。

所以询问直接暴力删暴力加暴力获取最大值即可，一次询问中，每个质因数的暴力都是小常数级别的，所以单次询问是 $\mathcal{O}(\log n)$ 的。

总复杂度 $\mathcal{O}(n \log n)$。小常数可以和跑不太满的 $\log n$ 抵消抵消。 

另外，实际上不需要建图，只需要写一个维护大小的并查集即可。


单组数据 $\mathcal{O}(n \log n)$。


```cpp
#include <bits/stdc++.h>

#define int long long

inline int read() {
    int x = 0;
    bool flag = true;
    char ch = getchar();
    while (!isdigit(ch)) {
        if (ch == '-')
            flag = false;
        ch = getchar();
    }
    while (isdigit(ch)) {
        x = (x << 1) + (x << 3) + ch - '0';
        ch = getchar();
    }
    if(flag)
        return x;
    return ~(x - 1);
}

inline bool updmax(int &x, int y) {
    return y > x ? x = y, true : false;
}

const int maxn = 500005;
const int maxm = 805; // sqrt(maxn)
const int mod = (int)1e9 + 7;

int a[maxn];
int inv[maxn], pfmin[maxn]; // prime factor min，存放了一个数的最小质因子。
int pr[maxn], pcnt = 0;
bool isp[maxn];

int lcm = 1;

std :: vector <std :: pair <int, int> > pfs[maxn];
// pfs[i] 存的是 i 的质因数分解，为一个 pair <int, int> 数组。
// pair 的第一个元素是质因子，第二个元素是质因子对应的幂（不是指数，因为在这个题里没必要）。
// 具体看代码，代码比这些文字好懂。

inline void pre(int n = maxn - 5) {
    inv[1] = pfmin[1] = 1;

    for (int i = 2; i <= n; ++i)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
    
    std :: memset(isp, true, sizeof(isp));
    for (int i = 2; i <= n; ++i) {
        if (isp[i]) {
            pr[++pcnt] = i;
            pfmin[i] = i;
        }

        for (int j = 1; j <= pcnt && i * pr[j] <= n; ++j) {
            isp[i * pr[j]] = false;
            pfmin[i * pr[j]] = pr[j];
            if (i % pr[j] == 0)
                break;
        }
    }

    for (int i = 2; i <= n; ++i) {
        int t = i;
        while (t != 1) {
            int p = pfmin[t], q = 1;
            while (t % p == 0) {
                q *= p;
                t /= p;
            }
            pfs[i].emplace_back(p, q);
            // printf("%lld %lld %lld\n", i, p, q);
        }
    }
}

int siz[maxn], fa[maxn];

inline int find(int x) {
    while (x != fa[x])
        x = fa[x] = fa[fa[x]];
    return x;
}

inline void uni(int x, int y) {
    x = find(x);
    y = find(y);

    if (x == y)
        return ;
    if (siz[x] > siz[y])
        x ^= y ^= x ^= y;
    fa[x] = y;
    siz[y] += siz[x];
}

int cnt[maxn];
std :: vector <int> f[maxn];

inline void insert(int x) {
    // printf("%lld\n", x);
    for (auto v : pfs[x]) {
        int p = v.first, q = v.second;
        // printf("%lld %lld\n", p, q);
        f[p].push_back(q);
        std :: sort(f[p].begin(), f[p].end(), std :: greater <int> ());
        // 这里 sort 可以看做常数级别，因为 f[p] 始终大小不超过 3
        if (f[p].size() > 3)
            f[p].pop_back();
    }
    return ;
}

int s[maxm], m;

std :: vector <std :: pair <int, int> > g[maxn];
// g[p][i] 表示第 i 个关于质数 p 的幂的修改，first 表示幂的值，second 表示修改量。
// 这个是我们的修改实现，举例说明：
// 删除 12 这个数，先质因数分解 2 ^ 2 * 3
// 然后转化成删掉两个质因子幂，一个 2 ^ 2，一个 3。
// 相当于我们把 2 ^ 2 和 3 的出现次数在集合中分别削了 1，所以 -1 就是两个修改的修改量
// 具体看代码。

int tcnt[maxn];

inline int getv(int p) {   
    int z = 1;
    for (int q : f[p])
        ++tcnt[q];
    for (auto v : g[p])
        tcnt[v.first] += v.second;
    
    for (int q : f[p]) {
        if (tcnt[q] != 0) {
            // 注意！！为什么这里要写成 ！= 0 而不能是 > 0！！！
            // 首先，我们想：tcnt[q] 有可能小于 0 吗？
            // 其实是可以构造的，只需要让 f[p][2] 这个质因子幂被删两次就可以了。
            // （也就是说 f[p][2] 和 f[p][3]（事实上没有）这两个质因子幂相同，而且恰好都被删，
            // 但是因为 f[p][3] 因为只存前三个的原则并没有记录，所以 f[p][2] 会被记录一次删除两次。
            // 所以 tcnt[q] < 0 是有可能的。
            // 由于我们 tcnt[q] 是边扫边清零的（看下面第二行），为了清零成功，我们需要把 < 0 的也清零。

            // updmax(z, q) 会被影响吗？
            // 我们一次最多删两个数，那么 f[p][2] 被删了两次，f[p][0] 和 f[p][1] 肯定没被删过。
            // 那么这一轮的 z 肯定会成功识别出 f[p][0]，所以没有影响。
            updmax(z, q);
            tcnt[q] = 0;
        }
    }

    for (auto v : g[p]) {
        int q = v.first;
        if (tcnt[q] != 0) {
            // 这里同上，不能写 > 0。
            // 这里 < 0 是因为可能会有删掉的质因子幂因为不是前三大没记录在 f 中。
            updmax(z, q);
            tcnt[q] = 0;
        }
    }

    return z;
}

inline void modify(int x, int val) {
    for (auto v : pfs[x]) {
        int p = v.first, q = v.second;
        (lcm *= inv[getv(p)]) %= mod;
        g[p].push_back(std :: make_pair(q, val));
        (lcm *= getv(p)) %= mod;
        // 把 lcm 暴力除以原来 p 这里的贡献，修改之后再暴力乘回去。
    }
}

inline void rec(int x) {
    for (auto v : pfs[x])
        g[v.first].clear();
    // 清空修改
}

inline void init(int n = maxn - 5) {
    std :: fill(siz + 1, siz + 1 + n, 1);
    std :: iota(fa + 1, fa + 1 + n, 1);
    
    std :: memset(cnt, 0, sizeof(cnt));
    std :: memset(s, 0, sizeof(s));
    m = 0;
    for (int i = 1; i <= n; ++i)
        f[i].clear();
    lcm = 1;
}

signed main() {
    int T = read();
    pre();
    while (T--) {
        init();
        int n = read();
        for (int i = 1; i <= n; ++i) {
            a[i] = read();
            uni(i, a[i]);
        }
        
        for (int i = 1; i <= n; ++i) {
            if (find(i) == i) {
                ++cnt[siz[i]];
                insert(siz[i]);
                // printf("%lld ", siz[i]);
            }
        }

        for (int i = 1; i <= n; ++i)
            if (cnt[i] > 0)
                s[++m] = i;
        
        for (int i = 1; i <= n; ++i) {
            if (!f[i].empty())
                (lcm *= f[i][0]) %= mod;
            // 初始 lcm
        }

        // printf("%lld\n", lcm);
        int ans = 0;

        for (int i = 1; i <= m; ++i) {
            int u = s[i];

            if (cnt[u] >= 2) {
                // puts("meitain");
                int org = lcm;
                modify(u << 1, 1);
                modify(u, -2);
                // printf("%lld\n", lcm);
                (ans += lcm * cnt[u] % mod * u % mod * (cnt[u] - 1) % mod * u % mod) %= mod;
                rec(u << 1);
                lcm = org;
            }

            for (int j = i + 1; j <= m; ++j) {
                int v = s[j], org = lcm;
                modify(u + v, 1);
                modify(u, -1);
                modify(v, -1);
                (ans += 2 * lcm % mod * cnt[u] % mod * u % mod * cnt[v] % mod * v % mod) %= mod;
                rec(u + v);
                rec(u);
                rec(v);
                lcm = org;
            }
        }

        printf("%lld\n", ans);
    }
    return 0;
}
```


---

## 作者：JoshAlMan (赞：10)

考虑把排列看成置换，有边 $i \rightarrow p_i$， $p_i^{k}$ 事实上往后走 $k$ 的编号。考虑每个环独立，那每个环限制就是 $k$ 得是环大小的倍数，那 $v$ 自然是 LCM 了。

考虑 $f(i, j) = 0$ 就是他们在一个环里，只有不在一个环里有贡献，这个 swap 相当于是把这两个环合起来，变化的 v 只跟选择的俩环大小有关系，跟具体编号没关系。

一个经典结论是，$\sum a_i = n$ 的形式，值不同的 $a_i$ 只有 $\sqrt{n}$ 量级。 那环本质不同只有根号种，那就可以暴力枚举两个环大小是啥，这样消耗也是 $O(n)$ 的，然后我们相当于要支持维护一个集合的 LCM，支持删除两个数，加入一个数，新的 LCM。考虑质因数分解每个单独考虑后相当于加入删除，维护 max。因为质因数已经有个 log 了，为了规避掉 log，我们发现最多删两个数，那么只要预先处理最大的三个就好了，新的 max 肯定在这三个后后添加中产生。

$O(n \log n)$

```cpp
// Skyqwq
#include <bits/stdc++.h>

using namespace std;

#define fi first
#define se second
#define pb push_back
#define mp make_pair

typedef long long LL;
typedef pair<int, int> PII;

template <typename T> void inline read(T &x) {
	x = 0; char s = getchar(); int f = 1;
	while (s < '0' || s > '9') { if (s == '-') { f = -1; } s = getchar(); }
	while (s <= '9' && s >= '0') x = x * 10 + (s ^ 48), s = getchar();
	x *= f;
}

template <typename T> bool inline chkMax(T &x, T y) { return y > x ? x = y, 1 : 0; }
template <typename T> bool inline chkMin(T &x, T y) { return y < x ? x = y, 1 : 0; }

const int P = 1e9 + 7, N = 5e5 + 5;

int n, a[N], f[N], sz[N], c[N], d[N], t, inv[N];

int find(int x) {
	return x == f[x] ? x : f[x] = find(f[x]);
}

void inline merge(int x, int y) {
	x = find(x), y = find(y);
	if (x == y) return;
	if (sz[x] > sz[y]) swap(x, y);
	f[x] = y, sz[y] += sz[x];
}


vector<int> g[N];
vector<PII> e[N];


bool st[N];

int pr[N], tot, p0[N];

vector<PII> fc[N];

void inline clr() {
	t = 0;
	for (int i = 1; i <= n; i++) c[i] = d[i] = 0, g[i].clear();
}

int now, cnt[N];

int inline get(int x) {
	int mx = 1;
	for (int v: g[x]) cnt[v]++;
	for (PII v: e[x]) cnt[v.fi] += v.se;
	for (int v: g[x])
		if (cnt[v]) chkMax(mx, v), cnt[v] = 0;
	for (PII v: e[x])
		if (cnt[v.fi]) chkMax(mx, v.fi), cnt[v.fi] = 0;
	return mx;
}

void inline chg(int x, int d) {
	for (PII o: fc[x]) {
		now = 1ll * now * inv[get(o.fi)] % P;
		e[o.fi].pb(mp(o.se, d));
		now = 1ll * now * get(o.fi) % P;
	}
}

void inline del(int x) {
	for (PII o: fc[x])
		e[o.fi].clear();
}

void inline add(int &x, int y) {
	x += y;
	if (x >= P) x -= P;
}

void inline work() {
	now = 1;
	for (int i = 1; i <= n; i++) {
		if (g[i].size()) {
			sort(g[i].begin(), g[i].end(), greater<int>() );
			while (g[i].size() > 3) g[i].pop_back();
			now = 1ll * now * g[i][0] % P;
		}
	}
	int ans = 0;
	for (int i = 1; i <= t; i++) {
		int u = d[i];
		if (c[u] > 1) {
			int la = now;
			chg(u + u, 1);
			chg(u, -1);
			chg(u, -1);
			del(u + u); del(u);
			add(ans, 1ll * now * c[u] % P * (c[u] - 1) % P * u % P * u % P);
			now = la;
		}
		for (int j = i + 1; j <= t; j++) {
			int v = d[j];
			int la = now;
			chg(u + v, 1), chg(u, -1), chg(v, -1);
			add(ans, 2ll * now * c[u] % P * c[v] % P * u % P * v % P);
			del(u + v), del(u), del(v);
			now = la;
		}
	}
	printf("%d\n", ans);
}


void inline apd(int x) {
	for (PII o: fc[x])
		g[o.fi].pb(o.se);
}


void inline prw(int n) {
	p0[1] = 1;
	inv[1] = 1;
	for (int i = 2; i <= n; i++) {
		inv[i] = ((LL)P - P / i) * inv[P % i] % P;
	}
	for (int i = 2; i <= n; i++) {
		if (!st[i]) pr[++tot] = i, p0[i] = i;
		for (int j = 1; pr[j] * i <= n; j++) {
			st[i * pr[j]] = 1;
			p0[i * pr[j]] = pr[j];
			if (i % pr[j] == 0) break;
		}
	}
	for (int i = 1; i <= n; i++) {
		int x = i;
		while (x != 1) {
			int p = p0[x], v = 1;
			while (x % p == 0) v *= p, x /= p;
			fc[i].pb(mp(p, v));
		}
	}
}

int main() {
	//freopen("perm.in", "r", stdin);
	//freopen("perm.out", "w", stdout);
	prw(5e5);
	int T; read(T);
	while (T--) {
		read(n);
		for (int i = 1; i <= n; i++) read(a[i]), f[i] = i, sz[i] = 1;
		for (int i = 1; i <= n; i++) merge(i, a[i]);
		for (int i = 1; i <= n; i++) {
			if (find(i) == i) {
				c[sz[i]]++;
				apd(sz[i]);
			}
		}
		for (int i = 1; i <= n; i++)
			if (c[i]) d[++t] = i;
		work();
		clr();
	}
}
```

# 

---

## 作者：FjswYuzu (赞：8)

把奇形怪状的操作看成置换，那么循环节就是所有置换长度的 $\operatorname{lcm}$。

那么如果一个 $f(i,j)=0$，说明 $i,j$ 在一个置换环内；不在一个置换环内，就相当于去掉先前的两个置换环，合并成一个新的置换环，长度为先前的两个相加，再求所有的 $\operatorname{lcm}$。

因为编号并不影响，我们只关心环的长度，合并之后就只有系数区别。并且有一个今年用的特别多的结论是，和为 $n$ 的数放入一个集合 $S$ 满足 $|S| \leq \sqrt n$，那么可以直接暴力枚举，这部分时间复杂度是 $O(n)$ 的。

接下来就是撤销两个数，加入一个数，求所有数的 $\operatorname{lcm}$，可以看作 $\prod p_i^{\max(a_{1}^{(p)},a_2^{(p),\cdots})}$，其中 $a^{(p)}$ 表示 $a$ 可以整除多少个 $p$ 的乘积。我们对所有因子保留所有数中幂次最大的三个，然后只看这次发生了变动的因子，这样一定能找到最大的幂次。

因为时间复杂度比较难表达，那就不写了吧！

```cpp
int n,a[500005],cnt,siz[500005],lseq[500005];
bool vis[500005];
int maxn[500005][3],rcv[500005][3];
int pcnt[2005];
pair<int,int> fct[2005][2005];
#define mp make_pair
inline void add(int w,int c)
{
    if(maxn[w][0]<=c)    maxn[w][2]=maxn[w][1],maxn[w][1]=maxn[w][0],maxn[w][0]=c;
    else if(maxn[w][1]<=c)  maxn[w][2]=maxn[w][1],maxn[w][1]=c;
    else if(maxn[w][2]<=c)  maxn[w][2]=c;
}
inline void sub(int w,int c)
{
    if(maxn[w][0]==c)   maxn[w][0]=0;
    else if(maxn[w][1]==c)  maxn[w][1]=0;
    else if(maxn[w][2]==c)  maxn[w][2]=0;
}
int pt[500005];
int stk[500005];
bool nrc[500005];
void Solve()
{
    n=read();
    for(int i=1;i<=n;++i)   a[i]=read();
    for(int i=1;i<=n;++i)   siz[i]=0,vis[i]=false;
    for(int i=1;i<=n;++i)
    {
        if(vis[i])  continue;
        int s=0,u=i;
        while(!vis[u])  ++s,vis[u]=true,u=a[u];
        if(!siz[s]) lseq[++cnt]=s;
        int tmp=s;
        for(int j=2;j*j<=tmp;++j)
        {
            if(tmp%j==0)
            {
                int c=0;
                while(tmp%j==0) tmp/=j,++c;
                add(j,c);
                if(!siz[s]) fct[cnt][++pcnt[cnt]]=mp(j,c);
            }
        }
        if(tmp>1)
        {
            add(tmp,1);
            if(!siz[s]) fct[cnt][++pcnt[cnt]]=mp(tmp,1);
        }
        siz[s]+=s;
    }
    LL ans=0,mlt=1;
    for(int i=1;i<=n;++i)
    {
        memcpy(rcv[i],maxn[i],sizeof maxn[i]);
        pt[i]=QuickPow(i,maxn[i][0]);
        mlt=Mul(mlt,pt[i]);
    }
    for(int i=1;i<=cnt;++i)
    {
        int s1=lseq[i];
        for(int j=i;j<=cnt;++j)
        {
            int s2=lseq[j];
            int top=0;
            for(int k=1;k<=pcnt[i];++k)
            {
                int f=fct[i][k].first;
                sub(f,fct[i][k].second);
                if(!nrc[f]) stk[++top]=f,nrc[f]=true;
            }
            for(int k=1;k<=pcnt[j];++k)
            {
                int f=fct[j][k].first;
                sub(f,fct[j][k].second);
                if(!nrc[f]) stk[++top]=f,nrc[f]=true;
            }
            int len=s1+s2;
            for(int k=2;k*k<=len;++k)
            {
                if(len%k==0)
                {
                    int c=0;
                    while(len%k==0) len/=k,++c;
                    if(!maxn[k][0]) maxn[k][0]=c;
                    else if(!maxn[k][1])    maxn[k][1]=c;
                    else if(!maxn[k][2])    maxn[k][2]=c;
                    else    add(k,c);
                    if(!nrc[k]) stk[++top]=k,nrc[k]=true;
                }
            }
            if(len>1)
            {
                if(!maxn[len][0])   maxn[len][0]=1;
                else if(!maxn[len][1])  maxn[len][1]=1;
                else if(!maxn[len][2])  maxn[len][2]=1;
                else    add(len,1);
                if(!nrc[len])   stk[++top]=len,nrc[len]=true;
            }
            LL lcm=mlt;
            for(int k=1;k<=top;++k)
            {
                int base=stk[k],pw=max({maxn[base][0],maxn[base][1],maxn[base][2]});
                lcm=Mul(lcm,Mul(QuickPow(pt[base]),QuickPow(base,pw)));
            }
            LL gx=(i==j?Mul(siz[s1],siz[s1]-s1):Mul(Mul(siz[s1],siz[s2]),2));
            ans=Add(ans,Mul(gx,lcm));
            for(int k=1;k<=top;++k)
            {
                int bs=stk[k];
                memcpy(maxn[bs],rcv[bs],sizeof rcv[bs]);
                nrc[bs]=false;
            }
        }
    }
    write(ans),puts("");
    for(int i=1;i<=n;++i) pcnt[i]=maxn[i][0]=maxn[i][1]=maxn[i][2]=0;
    cnt=0;
}
```

---

## 作者：ix35 (赞：6)

如果 $i$ 所在圈大小为 $a$，$j$ 所在圈大小为 $b$，那么 $f(i,j)=\operatorname{lcm}(a+b,c)$，$c$ 是其他所有循环圈的 LCM。

因为所有圈加起来等于 $n$，所以不同的只有 $O(\sqrt n)$ 种，然后暴力一下就行了，暴力部分留做习题，需要预处理的是对于每个素数，包含它的幂次最大和次大的圈长。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=500010,P=1e9+7;
vector < pair<int,int> > v[MAXN];
int t,n,jc,tot,ans,a[MAXN],vis[MAXN],c[MAXN],p[MAXN],q[MAXN];
int len[MAXN],mx[MAXN],smx[MAXN],inv[MAXN],val[MAXN],cnt[MAXN];
int read () {
	int res=0;
	char c=getchar();
	while (c<'0'||c>'9') {c=getchar();}
	while (c>='0'&&c<='9') {
		res=res*10+c-'0';
		c=getchar();
	}
	return res;
}
int qpow (int a,int b) {
	int res=1;
	while (b) {
		if (b&1) {res=(1ll*res*a)%P;}
		a=(1ll*a*a)%P,b>>=1;
	}
	return res;
}
void sieve (int x) {
	for (int i=2;i<=x;i++) {
		if (!q[i]) {p[++tot]=i;}
		for (int j=1;j<=tot&&i*p[j]<=x;j++) {
			q[i*p[j]]=1;
			if (i%p[j]==0) {break;}
		}
	}
	return;
}
int main () {
	sieve(MAXN-10);
	for (int i=1;i<=tot;i++) {
		inv[i]=qpow(p[i],P-2);
		for (int j=p[i];j<=MAXN-10;j+=p[i]) {
			int tmp=0,nw=j;
			while (nw%p[i]==0) {tmp++,nw/=p[i];}
			v[j].push_back(make_pair(i,tmp));
		}
	}
	for (int i=1;i<=MAXN-10;i++) {len[i]=v[i].size();}
	t=read();
	for (int ii=1;ii<=t;ii++) {
		n=read();
		jc=ans=0;
		for (int i=1;i<=n;i++) {a[i]=read();vis[i]=cnt[i]=mx[i]=smx[i]=0;}
		for (int i=1;i<=n;i++) {
			if (vis[i]) {continue;}
			int tmp=0,nw=i;
			while (!vis[nw]) {vis[nw]=1;tmp++,nw=a[nw];}
			cnt[tmp]++;
		}
		for (int i=1;i<=n;i++) {
			if (cnt[i]) {val[++jc]=i;}
		}
		for (int i=1;i<=jc;i++) {
			for (int j=0;j<len[val[i]];j++) {
				if (v[val[i]][j].second>mx[v[val[i]][j].first]) {
					smx[v[val[i]][j].first]=mx[v[val[i]][j].first];
					mx[v[val[i]][j].first]=v[val[i]][j].second;
					if (cnt[val[i]]>1) {smx[v[val[i]][j].first]=v[val[i]][j].second;}
				} else if (v[val[i]][j].second>smx[v[val[i]][j].first]) {
					smx[v[val[i]][j].first]=v[val[i]][j].second;
				}
			}
		}
		for (int i=1;i<=jc;i++) {
			for (int j=i;j<=jc;j++) {
				if (i==j&&cnt[val[i]]==1) {continue;}
				int sum=val[i]+val[j];
				int cntt=(i==j?(1ll*cnt[val[i]]*(cnt[val[i]]-1))%P:
								(2ll*cnt[val[i]]*cnt[val[j]])%P);
				cntt=(1ll*cntt*val[i])%P;
				cntt=(1ll*cntt*val[j])%P;
				for (int k=0;k<len[val[i]];k++) {
					int tmp=v[val[i]][k].first;
					if (v[val[i]][k].second==mx[tmp]) {
						for (int l=mx[tmp]-smx[tmp];l>=1;l--) {
							cntt=(1ll*cntt*inv[tmp])%P;
						}
					}
				}
				for (int k=0;k<len[val[j]];k++) {
					int tmp=v[val[j]][k].first;
					if (v[val[j]][k].second==mx[tmp]) {
						for (int l=mx[tmp]-smx[tmp];l>=1;l--) {
							cntt=(1ll*cntt*inv[tmp])%P;
						}
					}
				}
				for (int k=0;k<len[sum];k++) {
					int tmp=v[sum][k].first;
					if (v[sum][k].second>mx[tmp]) {
						for (int l=v[sum][k].second-mx[tmp];l>=1;l--) {
							cntt=(1ll*cntt*p[tmp])%P;
						}
					}
				}
				ans=(ans+cntt)%P;
			}
		}
		for (int i=1;i<=tot;i++) {
			for (int j=1;j<=mx[i];j++) {ans=(1ll*ans*p[i])%P;}
		}
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：Renshey (赞：5)

#### 题解

考虑设所有的环长分别为 $a_1,a_2,\dots,a_m$，当 $i,j$ 分别位于第 $x,y(x<y)$ 个环上时，显然有 $f(i,j)=\operatorname{lcm}(a_1,a_2,\dots,a_{x-1},a_{x+1},\dots,a_{y-1},a_{y+1},\dots,a_m,a_x+a_y)$。

考虑如何快速计算上式，首先需要注意到，长度不同的环最多只有 $O(\sqrt n)$ 种，因此可以考虑枚举两种长度 $u, v$。

对于计算 $\operatorname{lcm}$，显然只能按素数幂进行考虑。于是在枚举之前需要先预处理出 $\operatorname{lcm}(a_1,a_2,\dots,a_n)$，考虑将 $u,v$ 合并时会产生的影响，不难发现只会对 $p\mid u$ 或 $p\mid v$ 或 $p\mid u + v$ 的素数 $p$ 产生影响，因此可以直接枚举 $u,v,u+v$ 的素因子，重新计算一遍这些位置的贡献。具体实现可以用 `multiset` 维护每个素数 $p$ 在 $a_1\sim a_m$ 中的出现情况，每次可以暴力修改。

时间复杂度和空间复杂度均为 $O(n\log n)$。

#### 代码

```cpp
#include <bits/stdc++.h>
#define Getchar() p1 == p2 and (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++
char buf[1 << 21], *p1, *p2;
inline int read (void)
{
	int x = 0; char c = Getchar();
	while (c < '0' or c > '9') c = Getchar();
	while (c >= '0' and c <= '9') x = x * 10 + c - 48, c = Getchar();
	return x;
}
const int mod = 1000000007;
const int maxn = 500000 + 10;
int n, m, a[maxn], p[maxn], cnt[maxn], ans, lcm;
int pr[maxn], tot, inv[maxn]; bool flag[maxn], vis[maxn];
std::vector<std::pair<int, int>> d[maxn]; std::multiset<int> max[maxn];
inline void solve (void)
{
	n = read(); m = 0; ans = 0; lcm = 1;
	for (int i = 1; i <= n; i++) p[i] = read();
	for (int i = 1; i <= n; i++) if (!vis[i])
	{
		int w = 0;
		for (int j = i; !vis[j]; j = p[j]) w++, vis[j] = true;
		cnt[w]++;
	}
	for (int i = 1; i <= n; i++) if (cnt[i])
	{
		a[++m] = i;
		for (int j = 1; j <= cnt[i]; j++) for (auto [p, v]: d[i]) max[p].insert(v);
	}
	for (int i = 1; i <= tot and pr[i] <= n; i++) max[pr[i]].insert(1);
	for (int i = 1; i <= tot and pr[i] <= n; i++) lcm = 1LL * lcm * (*max[pr[i]].rbegin()) % mod;
	for (int i = 1; i <= m; i++) for (int j = i; j <= m; j++)
	{
		if (i == j and cnt[a[i]] == 1) continue;
		int res = lcm, val = (i == j) ? 1LL * cnt[a[i]] * (cnt[a[i]] - 1) % mod : 2LL * cnt[a[i]] * cnt[a[j]] % mod;
		auto add = [&] (int w, int r)
		{
			for (auto [p, v]: d[w])
				res = 1LL * res * inv[*max[p].rbegin()] % mod,
				~r ? max[p].insert(v) : max[p].erase(max[p].find(v)),
				res = 1LL * res * (*max[p].rbegin()) % mod;
		} ;
		add(a[i] + a[j], 1); add(a[i], -1); add(a[j], -1);
		ans = (ans + 1LL * a[i] * a[j] % mod * val % mod * res) % mod;
		add(a[i] + a[j], -1); add(a[i], 1); add(a[j], 1);
	}
	printf("%d\n", ans);
	for (int i = 1; i <= n; i++) vis[i] = false, cnt[i] = 0;
	for (int i = 1; i <= tot and pr[i] <= n; i++) std::multiset<int>().swap(max[pr[i]]);
}
signed main ()
{
	inv[0] = inv[1] = 1;
	for (int i = 2; i <= 500000; i++) inv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod;
	for (int i = 2; i <= 500000; i++) if (!flag[i])
	{
		pr[++tot] = i;
		for (int j = i; j <= 500000; j += i) flag[j] = true, d[j].push_back({i, i});
		for (int j = i; j <= 500000 / i; j *= i) for (int k = j * i; k <= 500000; k += j * i) d[k].pop_back(), d[k].push_back({i, j * i});
	}
	for (int T = read(); T--; ) solve();
	return 0;
}
```

---

## 作者：RyexAwl (赞：5)

对于排列 $P=(p_1,p_2,...,p_n)$，连有向边 $i\to p_i$，可以得到若干个不相交的环。$P^{(k)}$ 可以有更直观的刻画：在环上放 $n$ 枚棋子，初始时第 $i$ 枚棋子放在编号为 $i$ 的点上，$P^{(k)}$ 相当于将所有棋子沿着有向边移动恰好 $k$ 步。并且不难得到以下两个结论：

* $f(i,j)=0$ 当且仅当 $i$ 与 $j$ 在同一个环上。

* 如果 $f(i,j)\ne 0$，那么交换 $i,j$ 后相当于将 $i$ 所在的环与 $j$ 所在的环合并成一个环。（这里可以自己举例子画图理解一下）

* $v(P)$ 等价于最小的正整数 $k$，使得任意的棋子 $i$ 沿有向边移动恰好 $k$ 步回到 $i$。如果 $P$ 有 $m$ 个不相交的环大小为 $b_1,b_2,...,b_m$，那么有 $v(P)=\mathrm{lcm}(b_1,b_2,...,b_m)$，因为如果 $i$ 所在的环的大小是 $s$，那么 $i$ 沿着有向边移动 $k$ 步能回到 $i$ 的充要条件是 $s\mid k$。

接下来考虑如何枚举点对，注意到我们只在意 $i,j$ 所在的环的大小，因此考虑枚举环长点对。并且因为环长的总和为 $n$，所以不同的环长至多有 $O(\sqrt{n})$ 种，这里枚举点对的复杂度是 $O(n)$ 的。

考虑维护一个多重集 $S$ 初始时为图中所有环的大小。

如果枚举的环长对为 $(i,j),i<j$，那么将 $i,j$ 移除 $S$，$i+j$ 加入到 $S$ 中。令 $sz[i]$ 表示所有大小为 $i$ 的环的点数和（即大小为 $i$ 的环的个数乘上 $i$），$\mathrm{lcm}(S)$ 表示 $S$ 内数的最小公倍数，那么点对 $(i,j)$ 产生的贡献为 $sz[i]\times sz[j]\times 2\times \mathrm{lcm(S)}$。计算完贡献后再还原 $S$。

对于大小相同的环对也用类似的方法计算即可。 

问题转化为维护一个多重集动态增减元素维护多重集内数的最小公倍数。考虑 $\mathrm{lcm}$ 的质因数分解，使用 `std::multiset` 维护每个质数的次数即可动态维护每个质数贡献的次数。

```cpp
#include <bits/stdc++.h>

#define rep(i,l,r) for (int i = l; i <= r; i++)
#define per(i,r,l) for (int i = r; i >= l; i--)
#define fi first
#define se second
#define prt std::cout
#define gin std::cin
#define edl std::endl

namespace wxy{

const int N = 5e5 + 50,mod = 1e9 + 7,base = 5e5;

typedef long long ll;

std::multiset<int> S[N];

int lcm,primes[N],minv[N],cnt_p;

bool vis[N];

int n,m,fa[N],cnt[N],sz[N];

std::vector<int> nums;

int fpow(int a,int b) {
    int res = 1;
    for ( ; b ; b >>= 1) {
        if (b & 1) res = 1ll * res * a % mod;
        a = 1ll * a * a % mod;
    }
    return res;
} 

inline void insert_prime(int p,int t) {
    auto it = S[p].begin(); int v = -1 * (*it); lcm = 1ll * lcm * fpow(fpow(p,v),mod-2) % mod;
    S[p].insert(-1 * t);  it = S[p].begin(),v = -1 * (*it); lcm = 1ll * lcm * fpow(p,v) % mod;
}

inline void delet_prime(int p,int t) {
    auto it = S[p].begin(); int v = -1 * (*it); lcm = 1ll * lcm * fpow(fpow(p,v),mod-2) % mod;
    S[p].erase(S[p].lower_bound(-1 * t));  it = S[p].begin(),v = -1 * (*it); lcm = 1ll * lcm * fpow(p,v) % mod;
}

inline void delet(int x) {
    while (x > 1) {
        int t = minv[x],c = 0;
        while (x % t == 0) {
            ++ c; x /= t;
        }
        delet_prime(t,c);
    }
}

inline void insert(int x) {
    while (x > 1) {
        int t = minv[x],c = 0;
        while (x % t == 0) {
            ++ c; x /= t;
        }
        insert_prime(t,c);
    }
}

inline void init(){
    for (int i = 2; i <= base; ++ i) {
        if (!vis[i]) {
            primes[++ cnt_p] = i; minv[i] = i; S[i].insert(0);
        }
        for (int j = 1; j <= cnt_p; ++ j) {
            if (i * primes[j] > base) break;
            vis[i * primes[j]] = 1;
            minv[i * primes[j]] = primes[j];
            if (i % primes[j] == 0) break;
        }
    }

}

template <class T> void fr(T &a, bool f = 0, char ch = getchar()) {
    for (a = 0; ch < '0' || ch > '9'; ch = getchar()) ch == '-' ? f = 1 : 0;
    for (; ch >= '0' && ch <= '9'; ch = getchar()) a = a * 10 + (ch - '0');
    a = f ? -a : a;
}
template <class T, class... Y> void fr(T &t, Y &... a) { fr(t), fr(a...); }
int fr() { int a; return fr(a), a; }

int get(int x) {return fa[x] == x ? x : fa[x] = get(fa[x]);}

void merge(int x,int y) {
    x = get(x); y = get(y); sz[y] += sz[x]; fa[x] = y;
}

int qry(int x) {
    return std::lower_bound(nums.begin(),nums.end(),x) - nums.begin();
}

inline void solve(){
    nums.clear(); fr(n); rep(i,1,n) fa[i] = i,sz[i] = 1;
    rep(i,1,n) {
        int x; fr(x); if (get(i) == get(x)) continue;
        merge(i,x);
    }
    rep(i,1,n) {
        if (get(i) != i) continue;
        nums.push_back(sz[i]);
    } std::sort(nums.begin(),nums.end()); nums.erase(std::unique(nums.begin(),nums.end()),nums.end());
    int m = nums.size() - 1; lcm = 1; 
    rep(i,0,m) cnt[i] = 0;
    rep(i,1,n) {
        if (get(i) == i) cnt[qry(sz[i])] ++;
    }
    rep(i,1,n) if (get(i) == i) insert(sz[i]);
    int ans = 0;
    
    rep(i,0,m) {
        delet(nums[i]);
        rep(j,i+1,m) {
            delet(nums[j]); insert(nums[i]+nums[j]);
            int sum = 1ll * nums[i] * cnt[i] % mod * nums[j] % mod * cnt[j] % mod * 2 % mod;
            ans = (1ll * ans + 1ll * sum * lcm % mod) % mod;
            delet(nums[i]+nums[j]); insert(nums[j]);
        }
        insert(nums[i]);
    }
    
    rep(i,0,m) {
        if (cnt[i] < 2) continue;
        delet(nums[i]); delet(nums[i]); insert(2*nums[i]);
        int sum = 1ll * nums[i] * cnt[i] % mod * (cnt[i] - 1) % mod * nums[i] % mod;
        ans = (1ll * ans + 1ll * sum * lcm % mod) % mod;
        insert(nums[i]); insert(nums[i]); delet(2*nums[i]);
    } prt << ans << edl;
    rep(i,1,n) if (get(i) == i) delet(sz[i]);
}

inline void main(){
    #ifndef ONLINE_JUDGE
        freopen("perm3.in","r",stdin);
        freopen("out.out","w",stdout);
    #endif
    init(); int t; fr(t); while (t --) solve();
}

}signed main(){wxy::main(); return 0;}
```


---

## 作者：CodingJellyfish (赞：5)

Virtual Paticipate AHOI2022，就会这一道题。

发现每个排列可以对应一个图，这个图由几个互不连通的环组成。V(p) 对应的是所有环长度的最小公倍数（小学奥数，Asta a 秒跑 1 圈，KH b 秒跑 1 圈，Asta 和 KH 同时同地起跑，下一次相遇的时间是 lcm(a, b)）。

然后发现交换两个不同环内的 pi 就是合并两个环（想象以下，两个 0 合成了 一个 8）。

然后暴力求出每个环的长度，发现环的长度最多只有 $\sqrt{n}$ 种。

那么枚举合并的两个环的长度，总共 $O(n)$ 种。每种求合并之后的最小公倍数(lcm)。lcm 求法采用将每个长度质因数分解，最后的 lcm 就是所有因数个数取最大值再乘起来。复杂度 $ O(\sqrt{n}log_n) $。

总复杂度$ O(n\sqrt{n}log_n) $，但是常数小又跑不满，直接通过了这道题的数据。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define RN 1000005
#define MOD 1000000007

typedef int I;
typedef char C;
typedef double F;

#define MAX(a, b) ((a) > (b) ? (a) : (b))

// Main

I pi[RN], vis[RN], buc[RN], ai[RN];
I mx[RN], stk[RN];
I pr[10005][35], cnt[10005][35], len[10005];

static inline I qpow(I base, I fac)
{
    I ret = 1;
    while (fac)
    {
        if (fac & 1) ret = 1ll * ret * base % MOD;
        base = 1ll * base * base % MOD;
        fac >>= 1;
    }
    return ret;
}

I lcm(I l)
{
    I ans = 1, top = 0;
    for (I i = 1; i <= l; i++)
    {
        if (!buc[ai[i]])
            continue;
        for (I j = 1; j <= len[i]; j++)
        {
            if (!mx[pr[i][j]])
            {
                stk[++top] = pr[i][j];
                mx[pr[i][j]] = cnt[i][j];
            }
            else mx[pr[i][j]] = MAX(mx[pr[i][j]], cnt[i][j]);
        }
    }
    while (top)
    {
        ans = 1ll * ans * qpow(stk[top], mx[stk[top]]) % MOD;
        mx[stk[top]] = 0;
        top--;
    }
    return ans;
}

void process(I x)
{
    len[x] = 0;
    I y = ai[x];
    for (I i = 2; i * i <= y; i++)
    {
        if (y % i == 0)
        {
            len[x]++;
            pr[x][len[x]] = i;
            cnt[x][len[x]] = 1;
            y /= i;
            while (y % i == 0)
            {
                cnt[x][len[x]]++;
                y /= i;
            }
        }
    }
    if (y > 1)
    {
        len[x]++;
        pr[x][len[x]] = y;
        cnt[x][len[x]] = 1;
    }
}

void solve(void)
{
    I n;
    scanf("%d", &n);
    memset(vis, 0, sizeof(I) * (n + 2));
    memset(buc, 0, sizeof(I) * (n + 2));
    for (I i = 1; i <= n; i++)
    {
        scanf("%d", &pi[i]);
    }
    I l = 0, ans = 0;
    for (I i = 1; i <= n; i++)
    {
        if (!vis[i])
        {
            I x = i, cnt = 0;
            while (!vis[x])
                vis[x] = 1, cnt++, x = pi[x];
            if (!buc[cnt]) ai[++l] = cnt, process(l);
            buc[cnt]++;
        }
    }
    for (I i = 1; i <= l; i++)
    {
        buc[ai[i]]--;
        for (I j = i; j <= l; j++)
        {
            if (!buc[ai[j]])
                continue;
            buc[ai[j]]--;
            ai[l + 1] = ai[i] + ai[j];
            buc[ai[l + 1]]++;
            process(l + 1);
            I res = lcm(l + (buc[ai[l + 1]] <= 1));
            I fac = i == j ? 1ll * (buc[ai[i]] + 2) * (buc[ai[i]] + 1) / 2 % MOD
                           : 1ll * (buc[ai[i]] + 1) * (buc[ai[j]] + 1) % MOD;
            fac = 1ll * fac * ai[i] % MOD * ai[j] % MOD;
            ans = (1ll * res * fac + ans) % MOD;
            buc[ai[l + 1]]--;
            buc[ai[j]]++;
        }
        buc[ai[i]]++;
    }
    printf("%d\n", ans * 2 % MOD);
}

int main(void)
{
    I t;
    scanf("%d", &t);
    while (t--)
    {
        solve();
    }
    return 0;
}
```


---

## 作者：itisover (赞：1)

什么题都不会做，只能水题解了。作为已死去的JXOI2022的签到题，我还是要会做的，虽然把题面的第二个公式的第二个 $p$ 看成了 $P$ 推了半天样例。

首先看到排列、换来换去的元素、可以互相表示的元素不计贡献，很快能猜出结论：环内没有贡献，环外元素交换大概是相加。

接下来就可以小证一下了：

首先 $i \to a_i$，构建出一张图。

因为 $p_i^k=p_{p_{p_{p_{p_i}}}}$（$k+1$ 个 $p$），不难发现周期是图上的环长。

所以有： $V(P)=lcm(\text{P中所有环的长度})$

$a_i^k=j$ 等价于 $i,j$ 在一个环上。

交换不在同一个环上的 $a_i,a_j$ 时，令 $pre_i \to i \to a_i \to^{若干条边} pre_i$，$pre_j \to j \to a_j \to^{若干条边} pre_j$，交换后就是 $pre_i \to i \to a_j \to^{若干条边} pre_j \to j \to a_i \to^{若干条边} pre_i$，成了一个环，且新环的环长为原两环长的和。

发现：环长相同的环和其他环贡献相同，所以把环长相同的环合并到一起。

一个结论：设有 $x$ 个不同长度的环，最坏情况是 $1,2,3\dots x$，于是 $\dfrac{(x+1)x}{2}=n$，$x\approx\sqrt n$，所以枚举两两环长是 $O(n)$ 的。

考虑怎么计算贡献：（令 $cnt(i)$ 为 环长为 $i$ 的个数，$lcm$ 为交换之后的所有环长的 $lcm$）

+ 长度为 $i<j$ 的两个环：$2\times i\times cnt(i) \times j \times cnt(j) \times lcm$

+ 多个长度为 $i$ 之间：$2\times i \times i \times \binom{cnt(i)}{2}\times lcm=i\times i \times cnt(i) \times (cnt(i)-1)$

至此，问题转化为了有一个集合，每次询问两个环长 $i,j$，删除集合中的 $i,j$，加入 $i+j$ 后的整个集合的 $lcm$，每次询问独立。

怎么快速维护 $lcm$ 呢？可以考虑质因子，$lcm$ 等价于所有数的每个质因子选次数最大的乘起来。发现一个元素最多删除两次，所以我们只用维护每个质因子的前三大，就可以维护出每个质因子当前的最大次数，从而就可以维护出 $lcm$。

因为一个数的不同质因子是 $log$ 级别的，删除和插入都可以枚举这个数的所有质因子来实现，使用线性筛辅助分解质因数是 $log$ 的，所以总复杂度为 $O(\sqrt n \times \sqrt n \times log n=nlogn)$，但是我的实现~~貌似~~有点烂（还带了个逆元的 $log$，但是懒得改了）。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int _=1e6+5,mod=1e9+7;
int n,a[_],ff[_],sz[_],Fmax[_],smax[_],tmax[_],lcm;
int minp[_],pr[_],pn;
bool vis[_];
int find(int x){return ff[x]==x?x:ff[x]=find(ff[x]);}
int qpow(int x,int y,int r=1){
    for(;y;y>>=1){
        if(y&1) r=r*x%mod;
        x=x*x%mod;
    }
    return r;
}
void init(int n){
    for(int i=2;i<=n;++i){
        if(!vis[i]) pr[++pn]=i,minp[i]=i;
        for(int j=1;j<=pn&&pr[j]*i<=n;++j){
            vis[pr[j]*i]=1;
            minp[pr[j]*i]=pr[j];
            if(i%pr[j]==0) break;
        }
    }
}
void chkmax(int x,int y){
    if(Fmax[x]>=y){
        if(smax[x]>=y) tmax[x]=max(tmax[x],y);
        else tmax[x]=smax[x],smax[x]=y;
    }
    else tmax[x]=smax[x],smax[x]=Fmax[x],Fmax[x]=y;
}
void chkban(int x,int y){
    if(Fmax[x]>0){
        if(Fmax[x]==y){
            lcm=lcm*qpow(qpow(x,y),mod-2)%mod;
            if(smax[x]>0) lcm=lcm*qpow(x,smax[x])%mod;
            else lcm=lcm*qpow(x,tmax[x])%mod;
            Fmax[x]=-y;
        }
        else if(smax[x]==y) smax[x]=-y;
    }
    else{
        if(smax[x]>0){
            if(smax[x]==y) lcm=lcm*qpow(qpow(x,y),mod-2)%mod,lcm=lcm*qpow(x,tmax[x])%mod,smax[x]=-y;
        }
        else cout<<"ERROR!",exit(0);
    }
}
void chkunban(int x,int y){
    if(smax[x]==-y) smax[x]=-smax[x];
    else if(Fmax[x]==-y) Fmax[x]=-Fmax[x];
}
void chkupd(int x,int y){
    if(Fmax[x]>=0){
        if(Fmax[x]<y) lcm=lcm*qpow(qpow(x,Fmax[x]),mod-2)%mod,lcm=lcm*qpow(x,y)%mod;
    }
    else{
        if(smax[x]>=0){
            if(smax[x]<y) lcm=lcm*qpow(qpow(x,smax[x]),mod-2)%mod,lcm=lcm*qpow(x,y)%mod;
        }
        else{
            if(tmax[x]<y) lcm=lcm*qpow(qpow(x,tmax[x]),mod-2)%mod,lcm=lcm*qpow(x,y)%mod;
        }
    }
}
void solve(){
    cin>>n;
    memset(Fmax,0,sizeof Fmax),memset(smax,0,sizeof smax),memset(tmax,0,sizeof tmax);
    lcm=1;
    for(int i=1;i<=n;++i) cin>>a[i],ff[i]=i,sz[i]=1;
    for(int i=1;i<=n;++i){//找环
        int x=find(a[i]),y=find(i);
        if(x^y) ff[x]=find(y),sz[y]+=sz[x];
    }
    vector<int> V;
    for(int i=1;i<=n;++i) if(ff[i]==i) V.push_back(sz[i]);
    sort(V.begin(),V.end());
    vector<pair<int,int>> V2,VV[V.size()];;//V2为合并去重环长，VV[i]为V2[i]这个环的质因子
    int lst=0;
    for(auto x:V){//去重合并
        if(lst==x) ++V2[V2.size()-1].second;
        else V2.push_back({x,1});
        lst=x;
    }
    // assert(V2.size()<=sqrt(n)+1);
    for(int i=0;i<V.size();++i){//质因子插入集合中
        int x=V[i];
        while(x^1){
            int p=minp[x],res=0;
            while(minp[x]==p) x/=p,++res;
            chkmax(p,res);
        }
    }
    for(int i=0;i<V2.size();++i){//质因子存起来
        int x=V2[i].first;
        while(x^1){
            int p=minp[x],res=0;
            while(minp[x]==p) x/=p,++res;
            VV[i].push_back({p,res});
        }
    }
    for(int i=2;i<=pr[pn];++i) if(Fmax[i]) lcm=lcm*qpow(i,Fmax[i])%mod;//求lcm
    int Blcm=lcm,ans=0;
    for(int i=0;i<V2.size();++i){
        for(auto x:VV[i]) chkban(x.first,x.second);//删数
        int BBlcm=lcm;
        for(int j=i;j<V2.size();++j){
            if(i==j&&V2[i].second<2) continue;//没有2个长度相同的环
            for(auto x:VV[j]) chkban(x.first,x.second);
            int y=V2[i].first+V2[j].first;
            while(y^1){
                int p=minp[y],res=0;
                while(p==minp[y]) y/=p,++res;
                chkupd(p,res);//算插入后的lcm
            }
            if(i==j) ans=(ans+1ll*V2[i].first%mod*V2[i].first%mod*(V2[i].second*(V2[i].second-1)%mod)%mod*lcm%mod)%mod;
            else ans=(ans+1ll*2*V2[i].second%mod*V2[i].first%mod*V2[j].second%mod*V2[j].first%mod*lcm%mod)%mod;
            for(auto x:VV[j]) chkunban(x.first,x.second);//恢复
            lcm=BBlcm;
        }
        for(auto x:VV[i]) chkunban(x.first,x.second);
        lcm=Blcm;
    }
    cout<<ans<<'\n';
}
signed main(){
    init(1000000);
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t; cin>>t;
    while(t--) solve();
    return 0;
}
```



---


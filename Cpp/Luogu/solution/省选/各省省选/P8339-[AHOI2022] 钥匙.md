# [AHOI2022] 钥匙

## 题目描述

有 $n$ 座城市，编号为 $1, 2, \ldots, n$。这些城市由 $n - 1$ 条无向道路相连，每条无向道路连接两座城市，保证任意两个城市连通。即这 $n$ 座城市构成一棵树。

每座城市都有一件宝物。宝物分为两种：钥匙和宝箱。在一座城市里，要么有一把钥匙，要么有一个宝箱。钥匙和宝箱有不同的颜色，颜色为 $i$ 的钥匙只能打开颜色为 $i$ 的宝箱，打开宝箱后可以获得一枚金币，同时这把钥匙会损坏。

**由于某种特殊的原因，同一种的钥匙最多只有 $\bm{5}$ 把（同一种颜色的宝箱数量不限）。**

现在小 R 规划了 $m$ 次旅行，第 $i$ 次旅行的起点为 $s_i$，终点为 $e_i$。小 R 从 $s_i$ 沿最短路径走到 $e_i$。当他走到一座有钥匙的城市时，他可以将钥匙放入背包。当他走到一座有宝箱的城市时，如果他有相应颜色的钥匙，那么他就会打开这个宝箱并获得一个金币；如果他没有相应颜色的钥匙，那么他什么都不做（宝箱不能带走）。问每次旅行能获得多少枚金币。

**注意：旅行相互独立，即一次旅行完之后所有的钥匙和宝箱都会恢复到初始状态。**

## 说明/提示

**【样例 \#4】**

见附件中的 `keys/keys4.in` 与 `keys/keys4.ans`。

该组样例满足 $n, m \le {10}^5$ 和特殊性质 A。

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le 5 \times {10}^5$，$1 \le m \le {10}^6$，$1 \le t_i \le 2$，$1 \le c_i, u_i, v_i, s_i, e_i \le n$，每种颜色的钥匙都不超过 $5$ 把。

| 测试点编号 | $n \le$ | $m \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| $1$ | $100$ | $100$ | 无 |
| $2 \sim 3$ | $5000$ | $5000$ | 无 |
| $4 \sim 5$ | ${10}^5$ | ${10}^5$ | 无 |
| $6 \sim 8$ | $5 \times {10}^5$ | ${10}^6$ | A |
| $9 \sim 10$ | $5 \times {10}^5$ | ${10}^6$ | 无 |

特殊性质 A：对于每种出现过的颜色，恰有一把钥匙和一个宝箱对应该颜色。

**【提示】**

输入输出数据较大，请使用较为快速的输入输出方式。

## 样例 #1

### 输入

```
5 3
1 2
2 2
1 3
2 3
2 2
1 2
1 3
3 4
3 5
2 4
2 5
4 2
```

### 输出

```
1
1
1
```

## 样例 #2

### 输入

```
见附件中的 keys/keys2.in```

### 输出

```
见附件中的 keys/keys2.ans```

## 样例 #3

### 输入

```
见附件中的 keys/keys3.in```

### 输出

```
见附件中的 keys/keys3.ans```

# 题解

## 作者：Forge_Unique (赞：26)

## 思路
首先考虑处理出二元组 $(key,box)$ 
表示从带有钥匙的点 $key$ 
到达带有同色宝箱的点 $box$ 
的路径，且该路径满足：是用 $key$ 
处的钥匙开 $box$ 
处的宝箱。

处理方法：

由于每个颜色之间互不影响，所以我们枚举颜色 $color$，建立以颜色为 $color$ 
的点为关键点的虚树。

路径要满足用 $key$ 
处的钥匙开 $box$ 
处的宝箱，也就是该路径上到达 $box$ 
时钥匙和宝箱数第一次相等。

所以我们枚举颜色为 $color$ 
的钥匙点 $key$ 
作为虚树的根节点开始遍历虚树，过程中记录钥匙数，遇到同色钥匙点 $+1$，遇到同色宝箱点 $-1$。

如果过程中到 $box$ 
点钥匙数变为$0$，那么记录下该路径 $(key,box)$ 
后返回。

由于钥匙数不超过 $5$ 所以所有满足条件的路径不超过 $5n$。

显然如果旅行 $(s,e)$ 
包含路径 $(key,box)$ 
那么路径 $(key,box)$ 
就会对该旅行有贡献，那么考虑将旅行离线下来后，路径 $(key,box)$ 
会对哪些旅行 $(s,e)$ 
做贡献。

当 $key,box$ 
中不存在一个点是另一个点的祖先时：

显然，当 $s$ 
位于 $key$ 
的子树中且 $e$ 
位于 $box$ 
的子树中时会有贡献。

当 $key$ 
是 $box$ 
的祖先时：

记路径 $(key,box)$ 
的第二个点为 $u$ 
(即 $key$ 
向 $box$ 
方向走一条边到达的点)。

显然，当 $s$ 
不位于 $u$ 
的子树中且 $e$ 
位于 $box$ 
的子树中时会有贡献。

当 $box$ 
是 $key$ 
的祖先时同理。

由于一个点的子树内所有点的 $dfs$ 
序构成一段连续的区间。

将旅行 $(s,e)$ 
以 $s,e$ 
的 $dfs$ 
序分别作为横，纵坐标从而看成点，则上述在子树内的条件可以看成在平面上的一个矩形(一点是另一点祖先的情况可以看成一个大矩形减一个小矩形)。

所以问题转化为查询一个点位于多少个矩形中，这在平面上用扫描线做，并进行单点查询即可完成。

总时间复杂度：$O((n+m) \log n)$。

## 代码
[code](https://www.luogu.com.cn/paste/aw31968w)

---

## 作者：JoshAlMan (赞：16)

这里称 $1$ 是钥匙，$2$ 是宝箱。

考虑必须用到最多 $5$ 个 $1$ 这个信息，一个大概框架是，你可以预先对于每个 $2$，枚举所有可能的 $1$，然后考虑何种路径可以被这对贡献到。

考虑对于每个颜色单独考虑，假设一次经过的长这样 $11222112$。考虑把 $+1$ 的贡献记在 $(1, 4)$ （表示第一位和第四位），$(2, 3)，(7, 8)$，这样，这个过程可以把 $1$ 看成左括号，$2$ 看成右括号，做括号匹配的过程。

那这样考虑枚举这样的 $1, 2$ 点对，他能产生贡献的充要条件是：

* 它在询问路径上
* 中间部分是正好括号匹配的：（将 $1$ 看做 $1$，$2$ 看做 $-1$，前缀和 $\ge 0$，并且和 $= 0$）

这样设计的贡献是好的，因为已经让互相匹配的尽可能进，而且不重不漏。

在路径上的限制可以通过是否是祖先形式分讨变为询问 $s, e$ 要分别在 $dfn$ 的一个区间这种形式，就是所有矩形加，最后单点查，那么离线差分下来树状数组就好了。

枚举 $1, 2$ 点对的过程比较好的实现方式是，建虚树，然后 dfs？（我能想到的？

$O(5 n \log n + m\log n)$

```cpp
// Skyqwq
#include <bits/stdc++.h>

using namespace std;

#define fi first
#define se second
#define pb push_back
#define mp make_pair

typedef long long LL;
typedef pair<int, int> PII;

template <typename T> void inline read(T &x) {
	x = 0; char s = getchar(); int f = 1;
	while (s < '0' || s > '9') { if (s == '-') { f = -1; } s = getchar(); }
	while (s <= '9' && s >= '0') x = x * 10 + (s ^ 48), s = getchar();
	x *= f;
}

template <typename T> bool inline chkMax(T &x, T y) { return y > x ? x = y, 1 : 0; }
template <typename T> bool inline chkMin(T &x, T y) { return y < x ? x = y, 1 : 0; }

const int N = 5e5 + 5, M = 1e6 + 5;

int n, m, T[N], C[N], tp[N], dfn[N], dfncnt, sz[N], fa[N], son[N], d[N], pre[N];

vector<int> g[N];

void dfs1(int u) {
	sz[u] = 1;
	for (int v: g[u]) {
		if (v == fa[u]) continue;
		fa[v] = u;
		d[v] = d[u] + 1;
		dfs1(v);
		sz[u] += sz[v];
		if (sz[v] > sz[son[u]]) son[u] = v;
	}
}

void dfs2(int u, int top) {
	tp[u] = top, dfn[u] = ++dfncnt;
	pre[dfn[u]] = u;
	if (son[u]) dfs2(son[u], top);
	for (int v: g[u]) {
		if (v == fa[u] || v == son[u]) continue;
		dfs2(v, v);
	}
}

int inline lca(int x, int y) {
	while (tp[x] != tp[y]) {
		if (d[tp[x]] < d[tp[y]]) swap(x, y);
		x = fa[tp[x]];
	}
	return d[x] < d[y] ? x : y;
}

vector<int> b[N];

int inline cmp(int x, int y) {
	return dfn[x] < dfn[y];
}

int s[N], top, ans[M];

vector<int> e[N];

void inline addE(int x, int y) {
	//cout << x << " " << y << " bd?\n";
	e[x].pb(y), e[y].pb(x);
}

vector<int> z;

void inline ins(int x) {
	z.pb(x);
	if (!top)  { s[++top] = x; return; }
	int p = lca(s[top], x);
	while (top > 1 && d[s[top - 1]] >= d[p]) {
		addE(s[top - 1], s[top]);
		top--;
	}
	if (s[top] != p) {
		addE(s[top], p);
		s[top] = p;
		z.pb(p);
	}
	s[++top] = x;
}

int S, nc;

// x is y ancestor?

int inline isA(int x, int y) {
	return dfn[x] <= dfn[y] && dfn[y] < dfn[x] + sz[x];
}

// x -> y subpath cont.

int jp(int x, int y) {
	int la = 0;
	while (tp[y] != tp[x])
		la = tp[x], x = fa[tp[x]];
	if (x == y) return la;
	return pre[dfn[y] + 1];
}

// dfn[s] in [A, B], dfn[e] in [C, D]: +1

vector<PII> t[N];

void inline join(int A, int B, int C, int D) {
	if (A > B || C > D) return;
	t[A].pb(mp(C, 1));
	t[A].pb(mp(D + 1, -1));
	t[B + 1].pb(mp(C, -1));
	t[B + 1].pb(mp(D + 1, 1));
}

void inline insert(int x, int y) {
	if (isA(x, y)) {
		int z = jp(y, x);
		join(1, dfn[z] - 1, dfn[y], dfn[y] + sz[y] - 1);
		join(dfn[z] + sz[z], n, dfn[y], dfn[y] + sz[y] - 1);
	} else if (isA(y, x)) {
		int z = jp(x, y);
		join(dfn[x], dfn[x] + sz[x] - 1, 1, dfn[z] - 1);
		join(dfn[x], dfn[x] + sz[x] - 1, dfn[z] + sz[z], n);
	} else {
		join(dfn[x], dfn[x] + sz[x] - 1, dfn[y], dfn[y] + sz[y] - 1);
	}
}

void dfs(int u, int la, int w) {
	if (w < 0) return;
	for (int v: e[u]) {
		if (v == la) continue;
		if (!w && C[v] == nc && T[v] == 2) {
			insert(S, v);
			continue ;
		}
		int nv = 0;
		if (C[v] == nc) {
			if (T[v] == 2) nv--;
			else nv++;
		}
		dfs(v, u, w + nv);
	}
}

vector<PII> a[N];

int c[N];

void inline add(int x, int y) {
	for (; x <= n; x += x & -x) c[x] += y;
}

int inline ask(int x) {
	int ret = 0;
	for (; x; x -= x & -x) ret += c[x];
	return ret;
}

int main() {
//	freopen("keys.in", "r", stdin);
//	freopen("keys.out", "w", stdout);
	read(n), read(m);
	for (int i = 1; i <= n; i++) read(T[i]), read(C[i]), b[C[i]].pb(i);
	for (int i = 1, u, v; i < n; i++) {
		read(u), read(v);
		g[u].pb(v), g[v].pb(u);
	}	
	dfs1(1);
	dfs2(1, 1);
	for (int i = 1; i <= n; i++) {
		if (!b[i].size()) continue;
		nc = i;
		sort(b[i].begin(), b[i].end(), cmp);
		for (int v: b[i]) ins(v);
		while (top > 1) addE(s[top - 1], s[top]), --top;

		for (int v: b[i])
			if (C[v] == i && T[v] == 1)
				S = v, dfs(v, 0, 0);

		for (int v: z) e[v].clear();
		z.clear();
		top = 0;
	}
	for (int i = 1; i <= m; i++) {
		int u, v; read(u), read(v);
		a[dfn[u]].pb(mp(dfn[v], i));
	}
	for (int i = 1; i <= n; i++) {
		for (PII o: t[i])
			add(o.fi, o.se);
		for (PII o: a[i])
			ans[o.se] = ask(o.fi);
	}
	for (int i = 1; i <= m; i++) printf("%d\n", ans[i]);
}
```


---

## 作者：myyes (赞：16)

摘自我的博客文章：[钥匙题专项训练](https://www.luogu.com.cn/blog/666666new/keys-tm)。

这个安徽的师傅些出的题那是相当的规范！非常珍贵的既有思维难度又有代码难度的高质量好题！

### 题意

一个相当经典的钥匙-锁模型：给定一个树形结构的迷宫，每个节点上有一串钥匙或者一个锁。钥匙和锁有颜色，一种颜色的钥匙开一种颜色的锁。有 $Q$ 个师傅，第 $i$ 个师傅要开车沿最短路从 $s_i$ 到 $t_i$，遇到一串钥匙就可以把它撇在皮带上面，遇到一个锁就可以拿皮带上撇起的对应颜色的钥匙来开锁，然后这个钥匙会被挂烂。问你最多能开好多个锁。保证同种颜色的钥匙最多只有 $5$ 串。

### 题解

每种颜色的贡献是独立的，那么对每种有颜色我们把这些钥匙和锁嗲出来建一棵虚树。利用每种钥匙的钥匙不超过 $5$ 串的条件，我们枚举钥匙 $yo$ 和锁 $so$，看看哪些会对哪些路径产生贡献（即获得 $yo$ 并使用它来开 $so$）？可以发现充要就是从 $yo$ 到 $so$ 的简单路径上任何一个前缀钥匙都比锁多（除了 $so$），且钥匙和锁一样多。从每个 $yo$ 开始 DFS 找到所有合法的数对 $(yo,so)$。这些可以贡献到所有包含 $(yo,so)$ 的路径上。转到 DFS 序上做二维数点，分三种情况，一种是 $yo$ 是 $so$ 的祖先，一种是 $so$ 是 $yo$ 的祖先，或者没有祖孙关系。就是个二维加矩形加单点查，离线下来用树状数组做就可以了得咩。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int cnt,en,fa[1000010][20],dfn[1000010],tim=0,ord[1000010<<1],te=0,dep[1000010],n,siz[1000010],col[1000010],key[1000010],m,vis[1000010],inq[1000010],stk[1000010],top,ans[2000010],tree[1000010];
struct edge{int head,to,nxt;}ed[2000010];
void addedge(int from,int to)
 {
  ed[++en].to=to;ed[en].nxt=ed[from].head;ed[from].head=en;}
  void dfs(int now,int f){
      dfn[now]=++tim;ord[now]=++te;fa[now][0]=f;dep[now]=dep[f]+1;siz[now]=1;
   for(int i=1;i<20;i++)fa[now][i]=fa[fa[now][i-1]][i-1];
       for(int i=ed[now].head;i;i=ed[i].nxt){
           int v=ed[i].to;
    if(v==f)continue;dfs(v,now);siz[now]+=siz[v];}
   ord[now+n]=++te;}
  int LCA(int a,int b)
 {
int u=a,v=b;if(dep[u]<dep[v])
swap(u,v);int k=dep[u]-dep[v];
for(int i=0;i<20;i++)if((k>>i)&1)u=fa[u][i];if(u==v)return u;
  for(int i=19;~i;--i)if(fa[u][i]!=fa[v][i])
      {u=fa[u][i],v=fa[v][i];}return fa[u][0];}
  int zu(int x,int k){
      for(int i=0;i<20;i++)if((k>>i)&1)x=fa[x][i];return x;}
 vector<int>nxt[1000010],C[1000010],b;
void dfs1(int now,int fa,int c,int cnt){
if(col[now]==c&&key[now])cnt++;
 if(col[now]==c&&!key[now])
     {
  --cnt;
   if(!cnt){b.push_back(now);return;}}
    for(int i:nxt[now])
   {if(i==fa)continue;dfs1(i,now,c,cnt);}return;
 }
  struct ADD
 {int x,l,r;ADD()
 {}
  ADD(int X,int L,int R):x(X),l(L),r(R){

  }bool operator<(const ADD&b)
 const{return abs(x)<abs(b.x);}
  bool operator>(const ADD&b)const
  {
 return abs(x)>abs(b.x);}}add[20000010];
struct Query{int id,x,y;}q[2000010];
 bool cmp(Query a,Query b)
 {return a.x<b.x;}
  bool cmp2(int a,int b){return dfn[a]<dfn[b];}
bool cmp3(int a,int b){return ord[a]<ord[b];
}
void calc(int c){
 vector<int>S=C[c];
  if(S.size()==1)return;
 sort(S.begin(),S.end(),cmp2);
 int p=S.size(),r=1;
 for(int i=0;i<p;i++)vis[S[i]]=inq[S[i]]=1,S.push_back(S[i]+n);
for(int i=1;i<p;i++)
 {int q=LCA(S[i],S[i-1]);if(vis[q])continue;
vis[q]=1;S.push_back(q);S.push_back(n+q);}
 if(!vis[1])vis[1]=1,S.push_back(1),S.push_back(1+n);
   sort(S.begin(),S.end(),cmp3);
 p=S.size();
  top=0;
 for(int i=0;i<p;i++){
     if(S[i]<=n) stk[++top]=S[i];
     else
       {int x=stk[top--];
  int y=stk[top];
   if(y){nxt[y].push_back(x);nxt[x].push_back(y);r=y;}}
}
  for(int i:S)
       {if(i>n)
      continue;
   if(col[i]==c&&key[i]){
       b.clear();dfs1(i,0,c,0);
     for(int j:b)
          {
              int x=i,y=j,lca=LCA(i,j);
     if(lca==x)
    {
     int q=zu(y,dep[y]-dep[x]-1);
      if(dfn[q]!=1){
          add[++cnt]=ADD(1,dfn[y],dfn[y]+siz[y]-1);
           add[++cnt]=ADD(-dfn[q],dfn[y],dfn[y]+siz[y]-1);}
      if(dfn[q]+siz[q]-1!=n)
          add[++cnt]=ADD(dfn[q]+siz[q],dfn[y],dfn[y]+siz[y]-1);}
        else if(lca==y){int q=zu(x,dep[x]-dep[y]-1);
        if(dfn[q]!=1)
      {add[++cnt]=ADD(dfn[x],1,dfn[q]-1);
  if(dfn[x]+siz[x]-1!=n)add[++cnt]=ADD(-(dfn[x]+siz[x]),1,dfn[q]-1);
}
   if(dfn[q]+siz[q]-1!=n){
         add[++cnt]=ADD(dfn[x],dfn[q]+siz[q],n);
       if(dfn[x]+siz[x]-1!=n)
           add[++cnt]=ADD(-(dfn[x]+siz[x]),dfn[q]+siz[q],n);}}
        else
       {add[++cnt]=ADD(dfn[x],dfn[y],dfn[y]+siz[y]-1);
   if(dfn[x]+siz[x]-1!=n)add[++cnt]=ADD(-(dfn[x]+siz[x]),dfn[y],dfn[y]+siz[y]-1);}
  }
   }
}
   for(int i=0;i<p;i++)
  {int x=S[i];
 if(x>n)x-=n;vis[x]=inq[x]=0;nxt[x].clear();}
}
void Add(int x,int y)
{
    for(int i=x;i<=n;i+=i&-i)tree[i]+=y;}
 int sum(int x)
{int res=0;for(int i=x;i;i-=i&-i)res+=tree[i];
return res;}
int main()
 {
     scanf("%d%d",&n,&m);
 for(int i=1,t;i<=n;i++){
     scanf("%d%d",&t,&col[i]);
      if(t==1)key[i]=1;else key[i]=0;
 C[col[i]].push_back(i);}
 for(int i=1,u,v;i<n;i++)
     {
     scanf("%d%d",&u,&v);addedge(u,v);addedge(v,u);}dfs(1,0);
 for(int i=1;i<=n;i++)
     if(C[i].size())calc(i);
 for(int i=1;i<=m;i++)
{int x,y;
 scanf("%d%d",&x,&y);q[i].x=dfn[x];q[i].y=dfn[y];q[i].id=i;
}
  sort(q+1,q+m+1,cmp);sort(add+1,add+cnt+1);
 int t=1;for(int i=1;i<=cnt;i++){
     int x=add[i].x,y=1;if(abs(x)!=abs(add[i-1].x))
  {while(t<=m&&q[t].x<abs(x))ans[q[t].id]=sum(q[t].y),++t;}
   if(x<0)y=-1,x=-x;Add(add[i].l,y);
 if(add[i].r!=n)Add(add[i].r+1,-y);}while(t<=m)ans[q[t].id]=sum(q[t].y),
 ++t;
   for(int i=1;i<=m;i++)
  printf("%d\n",ans[i]);
 return 0;
}
```

---

## 作者：EnofTaiPeople (赞：12)

校内 pkusc 模拟一个小时想到了正解，两个小时没调出来，下午调出来了，做一些反思。

1. 上次写虚树已经过去很久了，十分生疏，出了许多毛病，所以要经常练习常用算法；
2. 想到正解直接写，高估了自己的码力和实力（一年前，我还只会基础语言）；
3. 没有先写暴力，无论是为了得分还是对拍，都应当写一个暴力，这并不需要很多时间（下午写暴力对拍只用了十分钟）。

**以下是解题方法**

考虑使用就近原则将钥匙与箱子配对，对于每一种颜色，可以将钥匙和箱子建虚树，从每个钥匙出发深搜，找到所有与自己配对的箱子，时间复杂度 $O(n\log_2n+kn)$ 此题中 $k\le5$，可以接受。

于是任意一条路径只要覆盖了一组配对的钥匙和箱子，就可以得到一个金币。问题转换为给定多条原路径（从钥匙到箱子），以及多次询问一条路径，问覆盖了多少条原路径。

对于原路径分三种情况讨论：

1. $lca=s$：

![](https://cdn.luogu.com.cn/upload/image_hosting/lqpbd0if.png)

这时候等价于一条起点不在 $S_x$ 而终点在 $S_e$ 的路径；

2. $lca=e$：与上类似；
3. $lca\ne s,lca\ne e$：

![](https://cdn.luogu.com.cn/upload/image_hosting/vcbx43rh.png)

这时候等价于一条起点在 $S_s$ 且终点在 $S_e$ 的路径。

是否在子树内可以用 $dfn$ 转化为不等式，问题转化成了静态二维数点。

$\text{K-D Tree}$？不怕炸就试试！$O(n\sqrt{m})$ 怎么可能通过！

不过由于是静态的，我们可以学习 $\text{CDQ}$ 分治解决三维偏序的思路，排序后离线掉一维，于是就将其转换为动态一维数点了，使用树状数组即可解决。总时间复杂度 $O(kn+(n+m)\log_2n)$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+6,M=998244353;
#define ST static
#define stl static inline
stl char gc(){
    ST char bf[N+5];
    ST int it,ed;
    return (it==ed&&(ed=(it=0)+fread(bf,1,N,stdin),it==ed))?EOF:bf[it++];
}
template<typename _Tp>
stl void read(_Tp &x){
    char c,f=0;for(c=gc();c<48;c=gc())if(c=='-')f=!f;
    for(x=0;c>47;x=x*10+(48^c),c=gc());if(f)x=-x;
}
template<typename _Tp,typename..._tps>
stl void read(_Tp &x,_tps&...y){
    read(x),read(y...);
}
using ll=long long;
using ul=unsigned long long;
using pr=pair<int,int>;
int tp[N],cl[N],n,m,dfn[N],rev[N],dlt,f[N],ncl,nrt,qn[N];
vector<int>lk[N],had[N],gt,bf,rg[N];
void dfs(int x=1){
    rev[dfn[x]=++dlt]=x;
    for(int y:lk[x])
        if(y!=f[x])f[y]=x,dfs(y);
    rev[dfn[x+n]=++dlt]=x+n;
    // printf("%d %d %d\n",x,dfn[x],dfn[x+n]);
}
stl bool cmpD(const int &x,const int &y){return dfn[x]<dfn[y];}
struct CG{int s,e,d;CG(){};CG(int a,int b,int c){
    // cout<<a<<" "<<b<<" "<<c<<endl;
    s=a,e=b,d=c;}
inline bool operator<(const CG &z)
const{return s<z.s;}}q[N];
stl bool cmpC(const int &x,const int &y){return q[x].s<q[y].s;}
vector<CG>qc;
#define qp qc.emplace_back
namespace lct{
    int t[N][2],f[N];
    #define Tp(x) (t[f[x]][1]==x)
    #define In(x) (t[f[x]][Tp(x)]==x)
    #define ls t[x][0]
    #define rs t[x][1]
    stl void rot(int x){
        int y=f[x],k=Tp(x),w=t[x][!k];
        f[t[y][k]=w]=t[x][!k]=y;if(In(y))t[f[y]][Tp(y)]=x;
        f[x]=f[y],f[y]=x;
    }
    stl void splay(int x){
        for(int y=f[x];In(x);rot(x),y=f[x])
            if(In(y))rot(Tp(x)^Tp(y)?x:y);
    }
    stl int access(int x){
        int y=0;while(x){
            splay(x),rs=y,x=f[y=x];
        }return y;
    }
    stl int lca(int x,int y){return access(x),access(y);}
    stl int fmin(int x){splay(x);while(ls)x=ls;splay(x);return x;}
    stl void solve(int s,int e){
        int x,y,z=lca(s,e);
        // cout<<"solve:"<<s<<" "<<e<<" "<<z<<endl;
        if(z==s){
            splay(s),t[s][1]=0,x=fmin(e);
            // cout<<"lead:"<<x<<endl;
            qp(dfn[x]-1,dfn[e+n],1),qp(dfn[x+n],dfn[e+n],-1),qp(dfn[n+1],dfn[e+n],1);
            qp(dfn[x]-1,dfn[e]-1,-1),qp(dfn[x+n],dfn[e]-1,1),qp(dfn[n+1],dfn[e]-1,-1);
        }else if(z==e){
            splay(e),t[e][1]=0,x=fmin(s);
            // cout<<"lead:"<<x<<endl;
            qp(dfn[s+n],dfn[x]-1,1),qp(dfn[s+n],dfn[x+n],-1),qp(dfn[s+n],dfn[n+1],1);
            qp(dfn[s]-1,dfn[x]-1,-1),qp(dfn[s]-1,dfn[x+n],1),qp(dfn[s]-1,dfn[n+1],-1);
        }else{
            qp(dfn[s+n],dfn[e+n],1),qp(dfn[s+n],dfn[e]-1,-1);
            qp(dfn[s]-1,dfn[e+n],-1),qp(dfn[s]-1,dfn[e]-1,1);
        }
    }
}
using lct::lca;
void dfs2(int x,int pre,int nw){
    // cout<<x<<" pre "<<pre<<" "<<nw<<endl;
    if(tp[x]==1)nw+=(cl[x]==ncl);
    else if(cl[x]==ncl)if(!--nw){lct::solve(nrt,x);return;}
    for(int y:rg[x])if(y!=pre)dfs2(y,x,nw);
}
bitset<N>vs;
int ct[N],n2;
void cg(int x,int d){
    // cout<<"cg:"<<x<<" d:"<<d<<endl;
    for(;x>0;x-=x&-x)ct[x]+=d;
}
int qry(int x){
    // cout<<"qry:"<<x<<endl;
    int d=0;for(;x<=n2;x+=x&-x)d+=ct[x];
    // cout<<" res::"<<d<<endl;
    return d;
}
int main(){
    freopen("keys.in","r",stdin);
    freopen("keys.out","w",stdout);
    read(n,m);int i,x,y,sz,p;n2=n<<1;
    for(x=1;x<=n;read(tp[x],cl[x]),had[cl[x]].push_back(x),++x);
    for(i=1;i<n;++i){
        read(x,y);lk[x].push_back(y);
        lk[y].push_back(x);
    }
    dfs();for(x=1;x<=n;++x)lct::f[x]=f[x];
    for(i=1;i<=m;++i){
        read(q[i].s,q[i].e);
        qn[i]=i,q[i].s=dfn[q[i].s],q[i].e=dfn[q[i].e];
    }
    for(p=1;p<=n;++p)
        if(sz=had[p].size()){
            // printf("color:%d\n",p);
            sort(had[p].begin(),had[p].end(),cmpD);
            gt=had[p],bf.clear();
            // for(int x:gt)printf("had:%d\n",x);
            for(i=1;i<sz;++i)
                gt.push_back(lca(had[p][i-1],had[p][i]));
            for(int x:gt)bf.push_back(x);
            for(int x:bf)gt.push_back(x+n);
            sort(gt.begin(),gt.end(),cmpD),bf.clear();
            unique(gt.begin(),gt.end());
            for(int x:gt){if(x<=n)rg[x].clear();vs[x]=1;}
            for(i=0,sz=gt.size();i<sz;++i){
                if(!vs[x=gt[i]])continue;
                else vs[x]=0;//printf("vt:%d\n",x);
                if(x<=n)bf.push_back(x);
                else{
                    while(bf.size()&&dfn[y=bf.back()]>dfn[x-n]){
                        rg[x-n].push_back(y),rg[y].push_back(x-n);
                        // printf("link:%d %d\n",x-n,y);
                        bf.pop_back();
                    }
                }
            }ncl=p;for(int x:gt)vs[x]=1;
            for(int x:gt)
                if(vs[x]){
                    vs[x]=0;
                    if(x<=n&&cl[x]==p&&tp[x]==1)dfs2(nrt=x,0,0);
                }
                
        }
    int t1=1,t2=0;sort(qc.begin(),qc.end());
    sort(qn+1,qn+m+1,cmpC);
    for(p=0;p<=n2;++p){
        while(t1<=m&&q[qn[t1]].s==p)
            q[qn[t1]].d=qry(q[qn[t1]].e),++t1;
        while(t2<qc.size()&&qc[t2].s==p)
            cg(qc[t2].e,qc[t2].d),++t2;
    }
    for(x=1;x<=m;++x)
        printf("%d\n",qry(q[x].e)-q[x].d);
    return 0;
}
```

---

## 作者：do_while_true (赞：11)

暴力：走 $u\to v$ 路径时，遇到一个钥匙，将其压入对应颜色的栈，遇到一个宝箱，将栈顶的钥匙和其匹配，弹出这个钥匙。

特殊性质 A：考虑一个钥匙 $x$ 及其对应的宝箱 $y$，会对所有包含 $x\to y$ 的路径（这里的包含要求和 $x\to y$ 是一个方向），都会产生 $1$ 的贡献。那么考虑在 $dfn\times dfn$ 平面上，$(x,y)$ 代表的是 $x\to y$ 对应的答案，每一个钥匙及其宝箱所对应的路径 $x\to y$，根据 $x,y$ 是否为祖先关系的不同，包含其的路径是子树补 $\times$ 子树的矩形，或者子树 $\times$ 子树补的矩形，或者子树 $\times$ 子树的矩形。那么问题就变成了矩形 $+1$，单点求值问题，用树状数组扫描线即可。

正解考虑借鉴上面两个做法的思想。

考虑一次暴力的贪心匹配的过程，一个钥匙和哪个宝箱匹配，和这个钥匙之前遇到的钥匙以及它们的匹配情况是无关的。所以对每个钥匙考虑，其贪心匹配过程中，往各个方向走，匹配到的宝箱集合是一定的。

暴力找出这个集合的过程就是，以这个钥匙 $x$ 为根 dfs，维护一个栈，只存与根颜色相同的钥匙，然后匹配。直到有宝箱 $y$ 和根代表的钥匙匹配成功了，那么 $x\to y$ 会对所有包含 $x\to y$ 的路径产生一个 $1$ 的贡献，这里用特殊性质 A 的扫描线解决即可。

由于 dfs 的过程中只和同一颜色有关，所以把同一颜色的拉出来，在虚树上 dfs 找宝箱即可。

时间复杂度 $\mathcal{O}(n\log n)$．

```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<ctime>
#define pb emplace_back
#define mp std::make_pair
#define fi first
#define se second
#define dbg(x) cerr<<"In Line "<< __LINE__<<" the "<<#x<<" = "<<x<<'\n';
#define dpi(x,y) cerr<<"In Line "<<__LINE__<<" the "<<#x<<" = "<<x<<" ; "<<"the "<<#y<<" = "<<y<<'\n';
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int>pii;
typedef pair<ll,int>pli;
typedef pair<ll,ll>pll;
typedef vector<int>vi;
typedef vector<ll>vll;
typedef vector<pii>vpii;
template<typename T>T cmax(T &x, T y){return x=x>y?x:y;}
template<typename T>T cmin(T &x, T y){return x=x<y?x:y;}
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
template<typename T>
T &read(T &r){
	r=0;bool w=0;char ch=getchar();
	while(ch<'0'||ch>'9')w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9')r=r*10+(ch^48),ch=getchar();
	return r=w?-r:r;
}
template<typename T1,typename... T2>
void read(T1 &x, T2& ...y){ read(x); read(y...); }
inline int lowbit(int x){return x&(-x);}
const int N=1000010;
int n,m,ct[N];
int t[N],c[N];
int ctc[N][3];
int fa[N],dep[N];
vi eg[N];
namespace ac{
	int dfn[N],ofn[N],fi[N],ed[N],oft,dft,dep[N],fa[N][21],lg[N],siz[N];
	int st[21][N],nowc;
	int top,stk[N];
	vi vec[N],et[N];
	void dfs1(int x,int f){
		fa[x][0]=f;dep[x]=dep[f]+1;siz[x]=1;
		dfn[x]=++dft;fi[x]=++oft;ofn[oft]=x;
		for(int i=1;i<=20;i++)fa[x][i]=fa[fa[x][i-1]][i-1];
		for(auto v:eg[x])if(v!=f){
			dfs1(v,x);
			siz[x]+=siz[v];
			ed[v]=++oft;
			ofn[oft]=x;
		}
	}
	int LCA(int x,int y){
		x=fi[x];y=fi[y];
		int l=min(x,y),r=max(x,y);
		int k=lg[r-l+1];
		return dep[st[k][l]]<dep[st[k][r-(1<<k)+1]] ? st[k][l] : st[k][r-(1<<k)+1];
	}
	void merge(int x,int y){
		et[x].pb(y);et[y].pb(x);
	}
	int Findsbt(int x,int y){
		for(int i=20;~i;i--)
			if(dep[fa[y][i]]>dep[x])
				y=fa[y][i];
		return y;
	}
	int lct;
	struct Line{
		int l,r,h,v;
	}li[N*10];
	struct Que{
		int x,y,i;
	}q[N];
	int ans[N];
	int tree[N];
	void modify(int x,int v){
		for(;x<=n;x+=lowbit(x))tree[x]+=v;
	}
	void modify(int l,int r,int v){
		modify(l,v);
		if(r<n)modify(r+1,-v);
	}
	int query(int x){
		int s=0;
		for(;x;x-=lowbit(x))s+=tree[x];
		return s;
	}
	void Push(int l1,int r1,int l2,int r2){
		if(l1>r1||l2>r2)return ;
//		cout << l1 << ' ' << r1 << ' ' << l2 << ' ' << r2 << '\n';
		li[++lct]={l2,r2,l1,1};
		if(r1<n)li[++lct]={l2,r2,r1+1,-1};
	}
	void dfs2(int x,int f,int h,int aci){
		if(x!=aci&&c[x]==nowc){
			if(t[x]==1)++h;
			else{
				if(!h){
					if(fi[aci]<=fi[x]&&ed[x]<=ed[aci]){
						int y=Findsbt(aci,x);
						int l=dfn[x],r=dfn[x]+siz[x]-1;
						Push(1,dfn[y]-1,l,r);
						Push(dfn[y]+siz[y],n,l,r);
					}
					else{
						if(fi[x]<=fi[aci]&&ed[aci]<=ed[x]){
							swap(x,aci);
							int y=Findsbt(aci,x);
							int l=dfn[x],r=dfn[x]+siz[x]-1;
							Push(l,r,1,dfn[y]-1);
							Push(l,r,dfn[y]+siz[y],n);
						}
						else{
							Push(dfn[aci],dfn[aci]+siz[aci]-1,dfn[x],dfn[x]+siz[x]-1);
						}
					}
					return ;
				}
				--h;
			}
		}
		for(auto v:et[x])if(v!=f){
			dfs2(v,x,h,aci);
		}
	}
	void init(){
		dfs1(1,0);
		ed[1]=++oft;ofn[oft]=1;
		for(int i=1;i<=oft;i++)st[0][i]=ofn[i];
		for(int i=2;i<=oft;i++)lg[i]=lg[i>>1]+1;
		for(int i=1;i<=20;i++)
			for(int j=1;j+(1<<i)-1<=oft;j++)
				st[i][j]=dep[st[i-1][j]]<dep[st[i-1][j+(1<<(i-1))]] ? st[i-1][j] : st[i-1][j+(1<<(i-1))];
		for(int i=1;i<=m;i++){
			int x,y;read(x,y);
			q[i]={dfn[x],dfn[y],i};
		}
	}
	void JiTangLaiLe(){
		for(int i=1;i<=n;i++)vec[c[i]].pb(i);
		for(int o=1;o<=n;o++){
			nowc=o;
			stk[top=1]=1;
			sort(vec[o].begin(),vec[o].end(),[](const int &x,const int &y){return dfn[x]<dfn[y];});
			vi po;
			for(auto x:vec[o]){
				if(x==1)continue;
				int t=LCA(x,stk[top]);
				while(top>1&&dep[t]<dep[stk[top-1]]){
					merge(stk[top-1],stk[top]);
					po.pb(stk[top]);--top;
					t=LCA(x,stk[top]);
				}
				if(dep[t]<dep[stk[top]]){
					merge(t,stk[top]);
					po.pb(stk[top]);--top;
					if(t!=stk[top])stk[++top]=t;
					stk[++top]=x;
				}
				else stk[++top]=x;
			}
			while(top>1){
				merge(stk[top],stk[top-1]);
				po.pb(stk[top]);--top;
			}
			po.pb(1);
			for(auto x:vec[o]){
				if(t[x]==1){
					dfs2(x,0,0,x);
				}
			}
			for(auto x:po){
				vi().swap(et[x]);
			}
		}		
	}
	void Sao(){
		sort(li+1,li+lct+1,[](const Line &x,const Line &y){return x.h<y.h;});
		sort(q+1,q+m+1,[](const Que &x,const Que &y){return x.x<y.x;});
		int pos=1;
		for(int i=1;i<=m;i++){
			while(pos<=lct&&li[pos].h<=q[i].x){
				modify(li[pos].l,li[pos].r,li[pos].v);
				++pos;
			}
			ans[q[i].i]=query(q[i].y);
		}
	}
	void main(){
		init();
		JiTangLaiLe();
		Sao();
		for(int i=1;i<=m;i++)cout << ans[i] << '\n';
	}
}
signed main(){
	read(n,m);
	for(int i=1;i<=n;i++){
		read(t[i],c[i]);
		ctc[c[i]][t[i]]++;
	}
	for(int i=1;i<n;i++){
		int x,y;read(x,y);
		eg[x].pb(y);eg[y].pb(x);
	}
	ac::main();
    #ifdef do_while_true
		cerr<<'\n'<<"Time:"<<clock()<<" ms"<<'\n';
	#endif
	return 0;
}
```

---

## 作者：7KByte (赞：5)

提供一个简单树剖/差分的做法。

我们先考虑 $A$ 性质怎么做，令每种颜色的钥匙和箱子分别为 $(x,y)$，那么会对起点在 $x$ 一端，终点在 $y$ 一端的询问产生贡献。所以我们对询问离线，问题转化为矩阵加单点查询，直接扫描线即可。

没有特殊性质，但我们延续上面的思路，考虑对同颜色的钥匙和箱子 $(x,y)$ 计算贡献。由于钥匙 $\le 5$，所以所有 $(x,y)$ 最多是 $5n$。

我们依次考虑每种颜色。但并不是所有的 $(x,y)$ 都满足条件，观察一下不难发现，如果我们将钥匙记为 $+1$，箱子记为 $-1$，其余记为 $0$，那么树链 $x\to y$ 的和为 $0$ 是产生贡献的必要条件。

但是这样连样例都过不去，答案会偏大，显然有贡献重复统计了。比如 $1,-1,1,-1$，其中 $(1,2)$ 和 $(1,4)$ 被计算了两次。 

如果数对 $(x,y)$ 在路径 $x\to y$ 上有 $z$ 使得 $(x,z)$ 产生贡献，那么 $y$ 就不产生贡献。那么我们固定 $x$，将所有可能的 $y$ 按到 $x$ 的距离排序，依次考虑，如果产生贡献就在 $y$ 单点加，每次统计 $(x,y)$ 时先判断一下是否路径和为 $0$。

可以直接用两个树链剖分维护，时间复杂度 $\mathcal{O}(5n\log^2 n + m\log m)$，由于树剖和树状数组的常数都很小，可以无压力通过。

事实上，我们维护的是单点加，树链查询，直接树上差分树状数组维护，时间复杂度 $\mathcal{O}((n+m)\log n)$。

树剖写的习惯，下面是树剖代码。

```cpp
#define N 500005
int n, m, c[N], d[N], dfn[N], fa[N], top[N], sz[N], son[N], mat[N], ds[N], idx, w[N];
inline void add(int x,int y){for(; x <= n; x += x & -x)c[x] += y;}
inline int ask(int x){int sum = 0; for(; x; x -= x & -x)sum += c[x]; return sum;}
inline void Add(int x,int y){for(; x <= n; x += x & -x)w[x] += y;}
inline int Ask(int x){int sum = 0; for(; x; x -= x & -x)sum += w[x]; return sum;}
inline int get(int l,int r){return ask(r) - ask(l - 1);}
inline int Get(int l,int r){return Ask(r) - Ask(l - 1);}
vector<int>a[N], b[N], e[N]; vector<Pr> u[N], v[N];
void dfs(int x,int f){
	d[x] = d[fa[x] = f] + (sz[x] = 1);
	go(y, e[x])if(y != f){
		dfs(y, x), sz[x] += sz[y];
		if(sz[y] > sz[son[x]])son[x] = y;
	}
}
void dfs2(int x,int tp){
	top[x] = tp, mat[dfn[x] = ++idx] = x;
	if(!son[x])return;
	dfs2(son[x], tp);
	go(y, e[x])if(y != fa[x] && y != son[x])dfs2(y, y);
}
inline int lca(int x,int y){
	while(top[x] != top[y]){
		if(d[top[x]] < d[top[y]])swap(x, y);
		x = fa[top[x]];
	}
	return d[x] < d[y] ? x : y;
}
inline int dis(int x,int y){return d[x] + d[y] - d[lca(x, y)] * 2;}
int query(int x,int y){
	int sum = 0;
	while(top[x] != top[y]){
		if(d[top[x]] < d[top[y]])swap(x, y);
		sum += get(dfn[top[x]], dfn[x]), x = fa[top[x]];
	}
	if(d[x] > d[y])swap(x, y);
	sum += get(dfn[x], dfn[y]);
	return sum;
}
int Query(int x,int y){
	int sum = 0;
	while(top[x] != top[y]){
		if(d[top[x]] < d[top[y]])swap(x, y);
		sum += Get(dfn[top[x]], dfn[x]), x = fa[top[x]];
	}
	if(d[x] > d[y])swap(x, y);
	sum += Get(dfn[x], dfn[y]);
	return sum;
}
int calc(int x,int k){
	while(d[top[x]] > k)x = fa[top[x]];
	return mat[dfn[x] - d[x] + k];
}
#define ck(x, y) (dfn[x] <= dfn[y] && dfn[x] + sz[x] > dfn[y])
inline void ins(int l,int r,int L,int R){
	if(l > r || L > R)return;
	u[l].pb(mp(L, R)), v[r + 1].pb(mp(L, R));
}
void ins(int x,int y){  //  x  to  y
	if(ck(x, y)){
		int z = calc(y, d[x] + 1);
		ins(1, dfn[z] - 1, dfn[y], dfn[y] + sz[y] - 1);
		ins(dfn[z] + sz[z], n, dfn[y], dfn[y] + sz[y] - 1);
	}
	else if(ck(y, x)){
		int z = calc(x, d[y] + 1);
		ins(dfn[x], dfn[x] + sz[x] - 1, 1, dfn[z] - 1);
		ins(dfn[x], dfn[x] + sz[x] - 1, dfn[z] + sz[z], n);
	}
	else ins(dfn[x], dfn[x] + sz[x] - 1, dfn[y], dfn[y] + sz[y] - 1);
}
struct node{
	int l, r, id;
	bool operator<(const node o)const{return l < o.l;}
}q[N << 1];
int ed[N << 1];
int main() {
	read(n, m);
	rp(i, n){
		int x, y; read(x, y);
		if(1 == x)a[y].pb(i);
		else b[y].pb(i);
	}
	rp(i, n - 1){
		int x, y;
		read(x, y);
		e[x].pb(y), e[y].pb(x);
	}
	dfs(1, 0), dfs2(1, 1);
	rp(i, n)if(si(a[i]) && si(b[i])){
		go(x, a[i])add(dfn[x], 1);
		go(x, b[i])add(dfn[x], -1);
		go(x, a[i]){
			go(y, b[i])ds[y] = dis(x, y);
			sort(b[i].begin(), b[i].end(), [&](int x,int y){return ds[x] < ds[y];});
			vector<int>dl;
			go(y, b[i]){
				if(0 == query(x, y) && !Query(x, y)){
					Add(dfn[y], 1), dl.pb(y), ins(x, y);
				}
			}
			go(y, dl)Add(dfn[y], -1);
		}
		go(x, a[i])add(dfn[x], -1);
		go(x, b[i])add(dfn[x], 1);
	}
	memset(c, 0, sizeof(c));
	rp(i, m)read(q[i].l, q[i].r), q[i].id = i, q[i].l = dfn[q[i].l], q[i].r = dfn[q[i].r];
	sort(q + 1, q + m + 1);
	int j = 1;
	rp(i, n){
		go(x, u[i])add(x.fi, 1), add(x.se + 1, -1);
		go(x, v[i])add(x.fi, -1), add(x.se + 1, 1);
		while(j <= m && q[j].l == i)ed[q[j].id] = ask(q[j].r), j++;
	}
	rp(i, m)printf("%d\n", ed[i]);
	return 0;
}
```



---

## 作者：ix35 (赞：5)

对每个颜色求一下虚树，然后从每个钥匙出发对虚树 DFS，设当前从 $x$ 开始 DFS。

在使用钥匙时我们遵循后进先出原则，设 $dp(i)$ 表示从 $x$ 走到 $i$，手上还剩几个钥匙，那么如果 $i$ 是钥匙就 $dp(i)=dp(fa)+1$，如果 $i$ 是宝箱那么 $dp(i)=\max(0,dp(fa)-1)$。如果 DFS 到某个 $i$ 发现它是宝箱而且 $dp(i)=0$，就说明开它是用的 $x$ 那把钥匙（因为我们后进先出，到这里栈正好空了），也就是钥匙 $x$ 和宝箱 $i$ 匹配，如果路径 $a\to b$ 覆盖了路径 $x\to i$，那么其答案就要 +1。

然后就是个矩形加单点求值，树状数组解决。

复杂度为 $O((n+m)\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=500010,MAXT=11000010;
struct P {
	int tim,l,r,typ;
	P (int a=0,int b=0,int c=0,int d=0) {tim=a,l=b,r=c,typ=d;}
}p[MAXT];
int n,m,x,y,tot,cnt,nc,hd,typ[MAXN],col[MAXN],dfn[MAXN],ed[MAXN],f[MAXN][22];
int dt[MAXN],dep[MAXN],ans[MAXN*2],fw[MAXN],dp[MAXN],st[MAXN];
vector <int> v[MAXN],w[MAXN],v2[MAXN];
bool cmp (P a,P b) {return (a.tim==b.tim?a.typ<b.typ:a.tim<b.tim);}
bool cmp2 (int x,int y) {return dfn[x]<dfn[y];}
int read () {
	int res=0;
	char c=getchar();
	while (c<'0'||c>'9') {c=getchar();}
	while (c>='0'&&c<='9') {
		res=res*10+c-'0';
		c=getchar();
	}
	return res;
}
void write (int x) {
	if (x>9) {write(x/10);}
	putchar(x%10+'0');
}
void dfs (int x,int fa) {
	f[x][0]=fa,dep[x]=dep[fa]+1,dfn[x]=ed[x]=++tot;
	for (int i=1;i<=20;i++) {f[x][i]=f[f[x][i-1]][i-1];}
	int len=v[x].size();
	for (int i=0;i<len;i++) {
		if (v[x][i]==fa) {continue;}
		dfs(v[x][i],x);
		ed[x]=ed[v[x][i]];
	}
	return;
}
void modify (int x,int v) {
	for (int i=x;i<=n;i+=(i&(-i))) {fw[i]+=v;}
}
int query (int x) {
	int res=0;
	for (int i=x;i;i-=(i&(-i))) {res+=fw[i];}
	return res;
}
int querylca (int x,int y) {
	if (dep[x]<dep[y]) {swap(x,y);}
	for (int i=20;i>=0;i--) {
		if (dep[x]-(1<<i)>=dep[y]) {x=f[x][i];}
	}
	if (x==y) {return x;}
	for (int i=20;i>=0;i--) {
		if (f[x][i]!=f[y][i]) {x=f[x][i],y=f[y][i];}
	}
	return f[x][0];
}
int querylas (int x,int y) {
	for (int i=20;i>=0;i--) {
		if (dep[x]-(1<<i)>dep[y]) {x=f[x][i];}
	}
	return x;
}
int anc (int x,int y) {return (dfn[x]<=dfn[y]&&ed[y]<=ed[x]);}
void add (int x,int y) {
	if (anc(x,y)) {
		int tmp=querylas(y,x);
		p[++cnt]=P(1,dfn[y],ed[y],0);
		p[++cnt]=P(dfn[tmp],dfn[y],ed[y],-1);
		p[++cnt]=P(ed[tmp]+1,dfn[y],ed[y],0);
	} else if (anc(y,x)) {
		int tmp=querylas(x,y);
		p[++cnt]=P(dfn[x],1,dfn[tmp]-1,0);
		p[++cnt]=P(dfn[x],ed[tmp]+1,n,0);
		p[++cnt]=P(ed[x]+1,1,dfn[tmp]-1,-1);
		p[++cnt]=P(ed[x]+1,ed[tmp]+1,n,-1);
	} else {
		p[++cnt]=P(dfn[x],dfn[y],ed[y],0);
		p[++cnt]=P(ed[x]+1,dfn[y],ed[y],-1);
	}
	return;
}
void dfs2 (int x,int fa,int rt) {
	dp[x]=dp[fa]+(col[x]==nc?(typ[x]==1?1:-1):0);
	if (col[x]==nc&&typ[x]==2&&dp[x]==0) {add(rt,x);return;}
	int len=v2[x].size();
	for (int i=0;i<len;i++) {
		if (v2[x][i]==fa) {continue;}
		dfs2(v2[x][i],x,rt);
	}
	return;
}
void dfs3 (int x,int fa) {
	int len=v2[x].size();
	for (int i=0;i<len;i++) {
		if (v2[x][i]==fa) {continue;}
		dfs3(v2[x][i],x);
	}
	v2[x].clear();
	return;
}
void proc (int x) {
	nc=x;
	int len=w[x].size(),ncnt=0;
	for (int i=0;i<len;i++) {dt[++ncnt]=w[x][i];}
	sort(dt+1,dt+ncnt+1,cmp2);
	st[hd=1]=1;
	for (int i=(dt[1]==1?2:1);i<=ncnt;i++) {
		while (hd>=2&&!anc(st[hd-1],dt[i])) {
			v2[st[hd]].push_back(st[hd-1]);
			v2[st[hd-1]].push_back(st[hd]);
			hd--;
		}
		if (hd==1) {st[++hd]=dt[i];continue;}
		int tmp=querylca(dt[i],st[hd]);
		if (tmp==st[hd-1]) {
			v2[st[hd]].push_back(st[hd-1]);
			v2[st[hd-1]].push_back(st[hd]);
			hd--;
		} else if (tmp!=st[hd]) {
			v2[st[hd]].push_back(tmp);
			v2[tmp].push_back(st[hd]);
			hd--;
			st[++hd]=tmp;
		}
		st[++hd]=dt[i];
	}
	while (hd>=2) {
		v2[st[hd]].push_back(st[hd-1]);
		v2[st[hd-1]].push_back(st[hd]);
		hd--;
	}
	for (int i=1;i<=ncnt;i++) {
		if (typ[dt[i]]==1) {dfs2(dt[i],0,dt[i]);}
	}
	dfs3(dt[1],0);
	return;
}
int main () {
	//freopen("keys4.in","r",stdin);
	//freopen("keys.out","w",stdout);
	n=read(),m=read();
	for (int i=1;i<=n;i++) {
		x=read(),y=read();
		typ[i]=x,col[i]=y,w[y].push_back(i);
	}
	for (int i=1;i<=n-1;i++) {
		x=read(),y=read();
		v[x].push_back(y),v[y].push_back(x);
	}
	dfs(1,0);
	for (int i=1;i<=m;i++) {
		x=read(),y=read();
		p[++cnt]=P(dfn[x],dfn[y],0,i);
	}
	for (int i=1;i<=n;i++) {
		if (w[i].empty()) {continue;}
		proc(i);
	}
	sort(p+1,p+cnt+1,cmp);
	for (int i=1;i<=cnt;i++) {
		if (p[i].typ==0) {
			modify(p[i].l,1);
			modify(p[i].r+1,-1);
		} else if (p[i].typ==-1) {
			modify(p[i].l,-1);
			modify(p[i].r+1,1);
		} else {
			ans[p[i].typ]=query(p[i].l);
		}
	}
	for (int i=1;i<=m;i++) {
		write(ans[i]);
		putchar('\n');
	}
	return 0;
}
```


---

## 作者：PosVII (赞：5)

## 前言

upd: bitset 做法假了，改成根号分治了。

[[AHOI2022] 钥匙](https://www.luogu.com.cn/problem/P8339)

有朋友说看不懂，那我修改下文风。这个新文风我是煮了又煮，希望大家喜欢喵喵！！

AHOI 的大师出的题，果然是相当的规范！我很喜欢哈！好题难得！大家一定要珍惜咩！

嘴巴一个不需要对钥匙数量限制的做法咩。需要使用到根号分治咩。

## 做法

为了表达方便，我们设每种钥匙数量的最大值为 $c$ 咩。

考虑到此类信息的合并是困难的，抛弃常规的 $O(\log n)$ 或 $O(\sqrt{n})$ 次合并的做法。使用点分治或启发式合并将最终的路径划成两半咩。

每次询问 $(x,y)$ 变成了 $(x,rt)$ 与 $(rt,y)$ 的过程，考虑这种括号合并的问题在序列上分治的时候是怎么处理的咩：

记录 $(x,rt)$ 的答案及剩下的钥匙数量，记录 $(rt,y)$ 的答案及剩下的胸数量，对于每种颜色，取剩下的钥匙和胸的较小值计入答案即可咩。

那么如此，考虑如何维护两者的较小值。一种比较显然的方法是，直接对于每种颜色算贡献。

但是这样的话复杂度仍然是 $O(n^2 \log n)$ 的咩！

考虑优化，可以使用经典的根号分治套路，设阈值为 $B$ 咩：

- $i \leq B$，使用标算方法做/特判，复杂度 $O(Bn \log n)$ 咩。
- $i \ge B$，使用上述方法做，复杂度 $O(\frac{n^2}{B} \log n)$ 咩。

$B = \sqrt{n}$ 时最优，复杂度为 $O(n \sqrt{n} \log n)$，很抽象吧咩咩咩咩咩咩咩咩咩咩！

## 代码

代码就不放到这里了咩！大家自己咩一咩咩！

咩咩咩咩咩咩咩咩咩咩！咩咩咩咩咩咩咩咩咩咩！咩咩咩咩咩咩咩咩咩咩！咩咩咩咩咩咩咩咩咩咩！咩咩咩咩咩咩咩咩咩咩！咩咩咩咩咩咩咩咩咩咩！

---

## 作者：Purslane (赞：4)

# Solution

AH 题欸。如果这题做不出来是不是进不了省队。

很明显，这道题应该是比较严的 $O(n \log n)$ 或类似的解法，而且不同颜色之间的贡献是独立的。因此我们考虑对于每个颜色分别统计答案。

然后考虑把同一种颜色的点（包括钥匙和箱子）的虚树建出来。

每条路径必然有经过的第一个钥匙和最后一个钥匙，我们枚举第一个钥匙。以这个钥匙为根先 DFS 一遍这个虚树。

然后考虑用类似栈的操作，每次箱子和最近的钥匙匹配。然后我们就可以知道哪些箱子是可以和当前的钥匙匹配的。这样可以给答案加一。

其实你发现这个东西就是把所有按顺序经过两个点的路径给加上一个权值。反正最多只有 $2$ 个二维数点的矩形。所以你一共大概是 $10n$ 个修改。

当今 $O(n \log n)$ 大抵能过 $5\times 10^6$ 了吧。我用树状数组。而且感觉跑不满。

好像卡输入输出。但是并不卡常。

代码：

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=5e5+10,MAXM=1e6+10;
int n,m,ans[MAXM],t[MAXN],c[MAXN],tr[MAXN];
vector<pair<int,int>> upd[MAXN],qr[MAXN],ky[MAXN];
void update(int pos,int v) {
	while(pos<=n) tr[pos]+=v,pos+=pos&(-pos);
	return ;
}
int query(int pos) {
	int ans=0;
	while(pos) ans+=tr[pos],pos-=pos&(-pos);
	return ans;	
}
namespace TREE {
	vector<int> G[MAXN],T[MAXN];
	int tot,fa[MAXN][21],dep[MAXN],sze[MAXN],dfn[MAXN];
	void dfs(int u,int f) {
		dfn[u]=++tot,dep[u]=dep[f]+1,sze[u]=1,fa[u][0]=f;
		ffor(i,1,19) fa[u][i]=fa[fa[u][i-1]][i-1];
		for(auto v:G[u]) if(v!=f) dfs(v,u),sze[u]+=sze[v];
	}
	int lca(int u,int v) {
		if(dep[u]<dep[v]) swap(u,v);
		int dt=dep[u]-dep[v],id=0;
		while(dt) {
			if(dt&1) u=fa[u][id];
			id++,dt>>=1;
		}
		if(u==v) return u;
		roff(i,19,0) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];
		return fa[u][0];
	}
	int lsh[MAXN],cnt;
	void build_vir(vector<int> vc) {
		sort(vc.begin(),vc.end(),[](int A,int B) {return dfn[A]<dfn[B];});
		cnt=0; for(auto id:vc) lsh[++cnt]=id;
		ffor(i,0,(int)vc.size()-2) lsh[++cnt]=lca(vc[i],vc[i+1]);	
		sort(lsh+1,lsh+cnt+1),cnt=unique(lsh+1,lsh+cnt+1)-lsh-1;
		sort(lsh+1,lsh+cnt+1,[](int A,int B) {return dfn[A]<dfn[B];});
		ffor(i,1,cnt) T[lsh[i]].clear();
		ffor(i,1,cnt-1) {
			int x=lsh[i],y=lsh[i+1],pos=lca(x,y);
			if(pos!=y) T[pos].push_back(y),T[y].push_back(pos);
		}
		return ;
	}
	void add_single_rec(int l1,int r1,int l2,int r2) {
		if(l1>r1||l2>r2) return ;
		upd[l1].push_back({l2,1}),upd[l1].push_back({r2+1,-1}),upd[r1+1].push_back({l2,-1}),upd[r1+1].push_back({r2+1,1});
		return ;
	}
	int jmp(int u,int dt) {
		int id=0;
		while(dt) {
			if(dt&1) u=fa[u][id];
			dt>>=1,id++;
		}
		return u;
	}
	void add_rec(int u,int v) {
		int t=lca(u,v);
		if(t==u) {
			int t=jmp(v,dep[v]-dep[u]-1);
			int X=dfn[t]-1,Y=dfn[t]+sze[t];
			add_single_rec(1,X,dfn[v],dfn[v]+sze[v]-1),add_single_rec(Y,n,dfn[v],dfn[v]+sze[v]-1);
		}
		else if(t==v) {
			int t=jmp(u,dep[u]-dep[v]-1);
			int X=dfn[t]-1,Y=dfn[t]+sze[t];
			add_single_rec(dfn[u],dfn[u]+sze[u]-1,1,X),add_single_rec(dfn[u],dfn[u]+sze[u]-1,Y,n);	
		}
		else add_single_rec(dfn[u],dfn[u]+sze[u]-1,dfn[v],dfn[v]+sze[v]-1);	
		return ;
	}
	void DFS(int u,int f,int cnt,int col,int ori) {
		if(t[u]==1&&c[u]==col) cnt++;
		if(t[u]==2&&c[u]==col&&cnt) cnt--;
		if(cnt==0) return add_rec(ori,u),void();
		for(auto v:T[u]) if(v!=f) DFS(v,u,cnt,col,ori);
		return ;
	}
	void add_qr(int u) {return DFS(u,0,0,c[u],u),void();}
}using namespace TREE;
int read() {
	int s=0;char ch=getchar();	
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
	return s;
}
signed main() {
	n=read(),m=read();
	ffor(i,1,n) t[i]=read(),c[i]=read(),ky[c[i]].push_back({t[i],i});
	ffor(i,1,n-1) {int u=read(),v=read();G[u].push_back(v),G[v].push_back(u);}
	dfs(1,0);
	ffor(i,1,n) if(ky[i].size()) {
		vector<int> pos;
		for(auto pr:ky[i]) pos.push_back(pr.second);
		build_vir(pos);
		for(auto pr:ky[i]) if(pr.first==1) add_qr(pr.second);
	}
	ffor(i,1,m) {
		int x=read(),y=read();
		qr[dfn[x]].push_back({dfn[y],i});	
	}
	ffor(i,1,n) {
		for(auto pr:upd[i]) update(pr.first,pr.second);	
		for(auto pr:qr[i]) ans[pr.second]=query(pr.first);
	}
	ffor(i,1,m) printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：Rubyonly (赞：4)

这是一个简单的点分治做法。

树上路径问题当然想到点分治，这个题询问的其实是括号匹配数，我们把询问拆成从下到上和从上到下两部分，只需要合并两部分的答案，合并方法是，两边已经匹配的数量加上失配括号的匹配数。用 $a$ 数组表示从下到上某种颜色的失配数量，$b$ 数组表示从上到下。可以一遍 dfs 求出每条路径的匹配数量和这两个数组，我们只需要快速查询 $\min(a_i,b_i)$ 之和。

考虑扫描路径的结束点，动态维护每个开始点的答案。结束点移动一步最多给 $b$ 数组的某个位置带来一的变化，假设 $b_i$ 加一，那么所有 $a_i\geq b_i$ 的结点答案也要加一。因为每种钥匙出现次数不超过5次，这些位置肯定是不超过5棵子树。用树状数组维护即可，时间复杂度 $O(5n\log^2n+m\log n)$。

``` cpp
const int mxn=5e5+3;
VI g[mxn];int n,qn,ty[mxn],co[mxn],jg[mxn*2];
struct thr{int x,y,k;};
vector<thr>xw;

int sz[mxn],d1[mxn],d2[mxn],dn,vs[mxn],fa[mxn],ee[mxn*2],N,be[mxn];
VI ad[mxn][6];bool sp[mxn];
vector<thr>wh[mxn];
void dfs0(int x,int f=0){sz[x]=1;for(int y:g[x])if(y!=f&&!vs[y])dfs0(y,x),sz[x]+=sz[y];}
int zx(int x,int f,int S){for(int y:g[x])if(y!=f&&!vs[y]&&sz[y]*2>S)return zx(y,x,S);return x;}
void dfs1(int x,int f=0){d1[x]=++dn,fa[x]=f,ee[++N]=x;for(int y:g[x])if(y!=f&&!vs[y])dfs1(y,x);d2[x]=dn;ee[++N]=-x;}
struct arrrrr{int a[mxn];void add(int x,int v){for(;x<=n;x+=x&-x)a[x]+=v;}void add(int l,int r,int v){add(l,v),add(r+1,-v);}int ask(int x){int r=0;for(;x;x&=x-1)r+=a[x];return r;}}ar;
void dfs(int rt=1,vector<thr>ve=xw){
    wh[rt].clear();if(!ve.size())return;
    if(rt!=1)dfs0(rt),rt=zx(rt,0,sz[rt]);
    dn=N=0;dfs1(rt);
    static int c1[mxn],c2[mxn],vl[mxn];
    static vector<pii>hd[mxn],dl;
    vl[rt]=0;
    for(int T=2;T<N;++T){
        int x=ee[T];if(x>0){
            int k=co[x];be[x]=fa[x]==rt?x:be[fa[x]];vl[x]=vl[fa[x]];
            if(ty[x]==1){if(c2[k])--c2[k],++vl[x];else ad[k][++c1[k]].push_back(x),sp[x]=1,dl.emplace_back(k,c1[k]);}
            else ++c2[k];
            wh[x].clear();
        }else{
            x=-x;int k=co[x];if(ty[x]==2)--c2[k];else if(sp[x])sp[x]=0,--c1[k];else ++c2[k];
        }
    }
    for(auto k:ve)if(k.x==rt||k.y==rt||be[k.x]!=be[k.y])hd[k.y].emplace_back(k.x,k.k);else wh[be[k.x]].push_back(k);
    for(int T=1,v=0;T<=N;++T){
        int x=ee[T];if(x>0){
            int k=co[x];if(ty[x]==1)++c1[k];else if(c1[k])--c1[k],++v;else{
                ++c2[k];if(c2[k]<=5)for(int x:ad[k][c2[k]])ar.add(d1[x],d2[x],1);sp[x]=1;
            }
            for(auto k:hd[x])jg[k.second]=v+ar.ask(d1[k.first])+vl[k.first];
            hd[x].clear();
        }else{
            x=-x;int k=co[x];if(ty[x]==1)--c1[k];else if(!sp[x])++c1[k],--v;else{
                sp[x]=0;if(c2[k]<=5)for(int x:ad[k][c2[k]])ar.add(d1[x],d2[x],-1);--c2[k];
            }
        }
    }
    for(auto k:dl)ad[k.first][k.second].clear();dl.clear();
    vs[rt]=1;for(int y:g[rt])if(!vs[y])dfs(y,wh[y]);
}

int main(){
    cin>>n>>qn;for(int i=1;i<=n;++i)scanf("%d%d",ty+i,co+i);for(int i=1,x,y;i<n;++i)scanf("%d%d",&x,&y),g[x].push_back(y),g[y].push_back(x);
    for(int i=1,x,y;i<=qn;++i)scanf("%d%d",&x,&y),xw.push_back({x,y,i});
    dfs();for(int i=1;i<=qn;++i)printf("%d\n",jg[i]);
    return 0;
}

```

---

## 作者：Renshey (赞：3)

#### 题解

考虑如何统计答案，不难想到对每种颜色计算贡献。

考虑颜色 $k$，用 `(` 表示钥匙，`)` 表示宝箱，那么一条路径上最多能开启的宝箱个数即为最大的括号匹配数。用括号匹配的优势在于，它保证了钥匙满足先进后出的结构，这样总是会优先匹配最近的一对，也就是说，无论路径如何，配对的钥匙和宝箱总是确定的。因此只需要预处理出所有配对的钥匙和宝箱，然后就转化为了一个路径覆盖问题。路径覆盖可以转化到 dfs 序上用二维数点计算。

考虑如何处理配对，首先对每种颜色建出虚树。由于钥匙只有 $5$ 个，因此可以从每个钥匙开始 dfs 一次，记录下当前剩余的钥匙个数，当刚好配对完最后一个钥匙时加入这一点对的贡献。容易证明，同一个钥匙能够匹配的所有宝箱一定不会贡献到同一条路径上。

效率 $O(5n\log n+q\log n)$。

#### 代码

```cpp
#include <bits/stdc++.h>
#define Getchar() p1 == p2 and (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++
char buf[1 << 21], *p1, *p2;
inline int read (void)
{
	int x = 0; char c = Getchar();
	while (c < '0' or c > '9') c = Getchar();
	while (c >= '0' and c <= '9') x = x * 10 + c - 48, c = Getchar();
	return x;
}
const int maxn = 500000 + 10;
int n, m, times, t[maxn], c[maxn], a[maxn], st[maxn], tp; bool vis[maxn];
int dep[maxn], fa[maxn], siz[maxn], son[maxn], top[maxn], dfn[maxn], pos[maxn];
std::vector<int> e[maxn], g[maxn], E[maxn]; int tr[maxn], ans[1 << 20];
std::vector<std::array<int, 3>> A[maxn]; std::vector<std::pair<int, int>> Q[maxn];
inline void dfs1 (int u, int fr)
{
	dep[u] = dep[fa[u] = fr] + 1; siz[u] = 1;
	for (int v: e[u]) if (v != fr)
	{
		dfs1(v, u); siz[u] += siz[v];
		if (siz[v] > siz[son[u]]) son[u] = v;
	}
}
inline void dfs2 (int u)
{
	pos[dfn[u] = ++times] = u;
	if (son[u]) top[son[u]] = top[u], dfs2(son[u]);
	for (int v: e[u]) if (v != fa[u] and v != son[u]) top[v] = v, dfs2(v);
}
inline int lca (int u, int v)
{
	while (top[u] != top[v]) dep[top[u]] < dep[top[v]] ? v = fa[top[v]] : u = fa[top[u]];
	return dep[u] < dep[v] ? u : v;
}
inline bool subtree (int u, int v) {return dfn[u] <= dfn[v] and dfn[v] < dfn[u] + siz[u];}
inline void add (int l, int r, int d, int u) {A[l].push_back({d, u, 1}); A[r + 1].push_back({d, u, -1});}
inline int up (int x, int k)
{
	while (dep[x] - dep[top[x]] < k) k -= dep[x] - dep[fa[top[x]]], x = fa[top[x]];
	return pos[dfn[x] - k];
}
inline void add (int x, int y)
{
	int l = lca(x, y);
	if (l == x)
	{
		x = up(y, dep[y] - dep[x] - 1);
		if (dfn[x] > 1) add(1, dfn[x] - 1, dfn[y], dfn[y] + siz[y] - 1);
		if (dfn[x] + siz[x] - 1 < n) add(dfn[x] + siz[x], n, dfn[y], dfn[y] + siz[y] - 1);
		return;
	}
	if (l == y)
	{
		y = up(x, dep[x] - dep[y] - 1);
		if (dfn[y] > 1) add(dfn[x], dfn[x] + siz[x] - 1, 1, dfn[y] - 1);
		if (dfn[y] + siz[y] - 1 < n) add(dfn[x], dfn[x] + siz[x] - 1, dfn[y] + siz[y], n);
		return;
	}
	add(dfn[x], dfn[x] + siz[x] - 1, dfn[y], dfn[y] + siz[y] - 1);
}
inline void dfs (int u, int fr, int w, int col, int r)
{
	if (c[u] == col)
	{
		w += (t[u] == 1) ? 1 : -1;
		if (w == 0) {add(r, u); return;}
	}
	for (int v: E[u]) if (v != fr) dfs(v, u, w, col, r);
}
signed main ()
{
	n = read(); m = read();
	for (int i = 1; i <= n; i++) t[i] = read(), g[c[i] = read()].push_back(i);
	for (int i = 1, u, v; i < n; i++) u = read(), v = read(), e[u].push_back(v), e[v].push_back(u);
	dfs1(1, 0); top[1] = 1; dfs2(1);
	for (int i = 1; i <= n; i++)
	{
		int k1 = 0, k2 = 0;
		for (int x: g[i]) vis[a[++k1] = x] = true;
		std::sort(a + 1, a + k1 + 1, [&](const int &x, const int &y){return dfn[x] < dfn[y];}); k2 = k1;
		for (int i = 2, l; i <= k1; i++) if (!vis[l = lca(a[i - 1], a[i])]) vis[a[++k2] = l] = true;
		if (!vis[1]) vis[a[++k2] = 1] = true;
		std::sort(a + 1, a + k2 + 1, [&](const int &x, const int &y){return dfn[x] < dfn[y];}); st[tp = 1] = 1;
		for (int i = 2; i <= k2; i++)
		{
			while (!subtree(st[tp], a[i])) tp--;
			E[st[tp]].push_back(a[i]); E[a[i]].push_back(st[tp]); st[++tp] = a[i];
		}
		for (int x: g[i]) if (t[x] == 1) dfs(x, 0, 0, i, x);
		for (int i = 1; i <= k2; i++) vis[a[i]] = false, E[a[i]].clear();
	}
	for (int i = 1, u, v; i <= m; i++) u = read(), v = read(), Q[dfn[u]].push_back({dfn[v], i});
	for (int i = 1; i <= n; i++)
	{
		auto add = [&] (int x, int y) {for (int i = x; i <= n; i += i & (-i)) tr[i] += y;};
		auto ask = [&] (int x) {int res = 0; for (int i = x; i; i -= i & (-i)) res += tr[i]; return res;};
		for (auto [l, r, w]: A[i]) add(l, w), add(r + 1, -w);
		for (auto [p, id]: Q[i]) ans[id] = ask(p);
	}
	for (int i = 1; i <= m; i++) printf("%d\n", ans[i]);
	return 0;
}
```

---

## 作者：Acerkaio (赞：1)

## 题解：P8339 [AHOI2022] 钥匙

考虑让钥匙和宝箱配对，发现这就是个括号匹配类物，但是直接做肯定会爆，大概是 $O(n^2)$ 的，我们考虑建出虚树，那么再去做就是 $O(n)$ 级别的，建树过程是 $O(n \log n)$ 的。

要去配对，因为考虑每次题目只给定一段路径，配对后就可以直接计算贡献。你考虑怎么才会发生贡献。

1. 二者无祖先关系

![](https://cdn.luogu.com.cn/upload/image_hosting/0ooum3pe.png)

可以发现 $s_i$ 在钥匙的子树，$e_i$ 在宝箱的子树的时候会产生贡献。

2. 钥匙是宝箱的祖先

![](https://cdn.luogu.com.cn/upload/image_hosting/cotaivny.png)

图丑轻喷，红色是钥匙，蓝色是宝箱，则 $s_i$ 在绿色处，$e_i$ 在黄色处才有贡献。

即：$s_i$ 在钥匙在 钥匙到宝箱的路径上的儿子 的子树 之外的点，$e_i$ 在宝箱的子树。

同义来说，那个点也可表述成钥匙到宝箱的路径上除钥匙外离钥匙最近的点。怎么怎么找到这个点呢，考虑我们是让宝箱树剖跳链，在跳到同一个重链时分类讨论，若直接跳到了钥匙则是前一轮跳链时宝箱的 `top` 节点，否则则是钥匙的重儿子。

代码如下：

```cpp
int fd(int x,int y){
  if(dep[x]>dep[y])swap(x,y);
  int las;
  while(top[x]!=top[y])las=top[y],y=fa[top[y]];
  if(x==y)return las;
  else return hs[x];
}
```

3. 宝箱是钥匙的祖先

与 2 大致类似。

容易知道一个点的子树的 `dfs` 序在数轴上是连续的，所以每次考虑一个点是不是在一个子树内显然是容易的。

现在我们的问题就是判断两个点分别是不是在两个节点的子树内。我们将数轴扩展成平面，`x` 轴考虑钥匙，`y` 轴考虑宝箱，则这就是一个二位数点问题，每找到一对配对就会把一个矩形或者一个大矩形减一个小矩形内的二位点对贡献加一，树状数组统计之。

```
#include<bits/stdc++.h>
#define pb push_back
using namespace std;
const int N=5e5+10,M=1e6+10;
vector<int>e[N],xv[N];
vector<int>jb;
void add(int x,int y){
	e[x].pb(y),e[y].pb(x);
}
void XDD(int x,int y){
	// cout<<x<<' '<<y<<'\n';
	jb.pb(x);jb.pb(y);
	xv[x].pb(y),xv[y].pb(x);
}
int n,m,fa[N],dfn[N],hs[N],sz[N],dep[N],top[N],nod,col[N],nd[N],ans[M];
vector<int>bx[N],ky[N];
vector<pair<int,int>>q[N];
namespace LCA{
	void pdfs1(int x,int F){
		fa[x]=F,dep[x]=dep[F]+1,sz[x]=1;
		for(auto to:e[x]){
			if(to==F)continue;pdfs1(to,x);
			sz[x]+=sz[to];if(sz[hs[x]]<sz[to])hs[x]=to;
		}
	}
	void pdfs2(int x,int T){
		top[x]=T,dfn[x]=++nod;if(hs[x])pdfs2(hs[x],T);
		for(auto to:e[x]){if(to==fa[x]||to==hs[x])continue;pdfs2(to,to);}
	}
	int LCA(int x,int y){
		while(top[x]!=top[y])if(dep[top[x]]>dep[top[y]])x=fa[top[x]];else y=fa[top[y]];
		return dep[x]<dep[y]?x:y;
	}
	int fd(int x,int y){
		if(dep[x]>dep[y])swap(x,y);
		int las;
		while(top[x]!=top[y])las=top[y],y=fa[top[y]];
		if(x==y)return las;
		else return hs[x];
	}
}
namespace VirtualTree{
	int key[N],m,a[N],len;
	vector<int>fin;
	void clear(){
		key[1]=1,m=1,len=0;
		// for(int i=0;i<=::n;i++)xv[i].clear();
		while(!jb.empty()){
			xv[jb.back()].clear();
			jb.pop_back();
		}
	}
	bool cmp(int x,int y){return dfn[x]<dfn[y];}
	void ins(int x){
		key[++m]=x;
	}
	void Build(){
		sort(key+1,key+m+1,cmp);
		for(int i=1;i<m;i++){
			a[++len]=key[i];
			a[++len]=LCA::LCA(key[i],key[i+1]);
		}
		a[++len]=key[m];
		sort(a+1,a+len+1,cmp);
		len=unique(a+1,a+len+1)-a-1;
		for(int i=1;i<len;i++){
			int lc=LCA::LCA(a[i],a[i+1]);
			XDD(lc,a[i+1]);
		}
	}
	void dfs(int x,int fa,int now,int o){
		if(now<0)return ;
		for(auto to:xv[x]){
			if(to==fa)continue;
			if(!now&&col[to]==o&&nd[to]==2){
				fin.pb(to);
				continue;
			}
			int f=now;
			if(col[to]==o&&nd[to]==2)f--;
			if(col[to]==o&&nd[to]==1)f++;
			dfs(to,x,f,o);
		}
	}
}
struct BIT{
	int c[N];
	int lowbit(int x){return (x&(-x));}
	void clear(){for(int i=1;i<=::n;i++)c[i]=0;}
	void add(int x,int val){
		for(int i=x;i<N;i+=lowbit(i))c[i]+=val;
	}
	int qry(int x){
		int res=0;
		for(int i=x;i;i-=lowbit(i))res+=c[i];
		return res;
	}
}c;
vector<pair<int,int>>raw[N];
void ins(int x1,int x2,int y1,int y2){
	if(x1>x2||y1>y2)return ;
	raw[x1].pb({  y1,   1});
	raw[x1].pb({  y2+1,-1});
	raw[x2+1].pb({y1  ,-1});
	raw[x2+1].pb({y2+1, 1});
}
void rd(int u,int v){
	int lc=LCA::LCA(u,v);
	if(lc==u){
		int w=LCA::fd(u,v);
		ins(1,dfn[w]-1,    dfn[v],dfn[v]+sz[v]-1);
		ins(dfn[w]+sz[w],n,dfn[v],dfn[v]+sz[v]-1);
	}else if(lc==v){
		int w=LCA::fd(u,v);
		ins(dfn[u],dfn[u]+sz[u]-1,    1,dfn[w]-1);
		ins(dfn[u],dfn[u]+sz[u]-1,dfn[w]+sz[w],n);
	}else{
		ins(dfn[u],dfn[u]+sz[u]-1,dfn[v],dfn[v]+sz[v]-1);
	}
}
signed main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	// cerr<<clock()-st<<'\n';
	for(int i=1;i<=n;i++){
		int op,c;cin>>op>>c;
		col[i]=c,nd[i]=op;
		if(!(op^1))ky[c].pb(i);
		else bx[c].pb(i);
	}
	for(int i=1;i<n;i++){
		int u,v;cin>>u>>v;add(u,v);
	}
	// cerr<<clock()-st<<'\n';
	LCA::pdfs1(1,1);LCA::pdfs2(1,1);
	for(int i=1;i<=m;i++){
		int s,t;cin>>s>>t;
		q[dfn[s]].pb({dfn[t],i});
	}
	for(int i=1;i<=n;i++){
		if(!ky[i].empty()&&!bx[i].empty()){
			double fk=clock();
			VirtualTree::clear();
			for(auto it:ky[i])VirtualTree::ins(it);
			for(auto it:bx[i])VirtualTree::ins(it);
			
			VirtualTree::Build();
			for(auto it:ky[i]){
				VirtualTree::fin.clear();
				VirtualTree::dfs(it,it,0,i);
				for(auto boxes:VirtualTree::fin)rd(it,boxes);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(auto it:raw[i])c.add(it.first,it.second);
		for(auto it:q[i])ans[it.second]=c.qry(it.first);
	}
	for(int i=1;i<=m;i++)cout<<ans[i]<<'\n';
	return 0;
} 
```

---

## 作者：Otomachi_Una_ (赞：1)

## B. 钥匙（keys）

码量题。

我们首先考虑只有一种颜色的情况。我们考虑这样的一个过程：

> 维护一个初始为空的栈 $S$，每次访问到一个节点：
>
> - 当前为宝藏：如果栈中还有钥匙，则用栈顶钥匙开锁。
> - 否则，把钥匙加入栈。

我们发现一个钥匙 $u$ 和一个宝藏 $v$ 是相配的，当且仅当满足下面条件：

- $u\to v$ 的路径上宝藏与钥匙数目相等。
- $u\to v$ 的路径上除了 $v$ 没有与 $u$ 相配的宝藏。

于是这个问题是简单的，我们只需要对每个钥匙 $u$ 进行 dfs，找到所有相配的宝藏 $v$。那么一个路径如果依次经过 $u,v$ 那么答案加一。

原问题变成了有 $\mathcal O(n)$ 的点对 $(u,v)$，问 $s\to t$ 路径上依次经过的点对的数目。我们考虑每个 $u,v$ 的贡献：

- 如果 $u,v$ 没有祖先关系，则 $s,t$ 必须依次为 $u,v$ 的子孙。
- 如果 $u$ 是 $v$ 的祖先，假设 $v$ 在 $u$ 儿子 $p$ 的子树内。则 $s$ 不能在 $p$ 子树内，$t$ 必须在 $v$ 子树内。
- 如果 $v$ 是 $u$ 的祖先，假设 $u$ 在 $v$ 儿子 $p$ 子树内。则 $s$ 必须在 $u$ 子树内，$t$ 不需不在 $p$ 子树内。

实现是简单的，拍成 dfs 序变成区间加了。

现在有多个颜色，只要建虚树就好了。

时间复杂度 $\mathcal O(n\log n)$，常数巨大。下面这份代码很慢。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
mt19937 rnd(time(0));
const int MAXN=5e5+5;
int n,m;
int le[MAXN<<1],ri[MAXN<<1],ans[MAXN<<1];
vector<int> edg[MAXN],nd[MAXN],tre[MAXN],que[MAXN];
struct node{int l,r,d;};
vector<node> cot[MAXN]; 
int op[MAXN],col[MAXN];
int fa[20][MAXN],in[MAXN],out[MAXN],dep[MAXN],cnt[MAXN],tot=0;
int st[MAXN],top=0;
bool vis[MAXN];
bool insub(int x,int y){
	// return y is in x's subtree
	return in[x]<=in[y]&&out[y]<=out[x];
}
void ymh(int l,int r,int L,int R,int x){
	cot[l].push_back({L,R,x});
	cot[r+1].push_back({L,R,-x});
}
int findanc(int u,int v){
	for(int i=19;i>=0;i--) if((dep[u]-dep[v]-1)>>i&1) u=fa[i][u];
	return u;
}
void Add(int x,int y){
	// from x to y answer will add 1
	if(insub(x,y)){
		ymh(1,n,in[y],out[y],1);
		int p=findanc(y,x);
		ymh(in[p],out[p],in[y],out[y],-1);
	}else if(insub(y,x)){
		ymh(in[x],out[x],1,n,1);
		int p=findanc(x,y);
		ymh(in[x],out[x],in[p],out[p],-1);
	}else{
		ymh(in[x],out[x],in[y],out[y],1);
	}
} 
void dfs(int u,int f){
	in[u]=++tot;fa[0][u]=f;
	for(int i=1;i<20;i++) fa[i][u]=fa[i-1][fa[i-1][u]];
	for(int v:edg[u]) if(v!=f){
		dep[v]=dep[u]+1;
		dfs(v,u);
	}
	out[u]=tot;
}
void dfs1(int rt,int u,int f,int i){
	if(cnt[u]==0){
		Add(rt,u);
		return;
	}
	for(int v:tre[u]) if(v!=f){
		cnt[v]=cnt[u]+(col[v]==i)*(op[v]==1?1:-1);
		dfs1(rt,v,u,i);
	}
	return;
}
int LCA(int u,int v){
	if(dep[u]<dep[v]) swap(u,v);
	for(int i=19;i>=0;i--) if((dep[u]-dep[v])>>i&1) u=fa[i][u];
	if(u==v) return u;
	for(int i=19;i>=0;i--) if(fa[i][u]!=fa[i][v]) u=fa[i][u],v=fa[i][v];
	return fa[0][u];
}
struct BIT{
int a[MAXN];
void add(int x,int d){while(x<=n){a[x]+=d;x+=(x&-x);}}
int ask(int x){int r=0;while(x){r+=a[x];x-=(x&-x);}return r;}
}T;
int main(){
	ios::sync_with_stdio(false);
//	freopen("keys4.in","r",stdin);
//	freopen("keys.out","w",stdout);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>op[i]>>col[i];
		nd[col[i]].push_back(i);
	}
	for(int i=1;i<n;i++){
		int u,v;cin>>u>>v;
		edg[u].push_back(v);
		edg[v].push_back(u); 
	}
	dep[1]=1;dfs(1,0);
	for(int i=1;i<=n;i++) if(!nd[i].empty()) {
		vector<int> vir;
		auto add=[&](int x,int y){
			tre[x].push_back(y);
			tre[y].push_back(x);
			vir.push_back(x);vir.push_back(y);
		};
		sort(nd[i].begin(),nd[i].end(),[&](int x,int y){return in[x]<in[y];});
		st[top=1]=1;
		for(int j:nd[i]) if(j!=1) {
			vir.push_back(j); 
			int p=LCA(st[top],j);
			if(p==st[top]){
				st[++top]=j;
			}else{
				while(dep[st[top-1]]>=dep[p]){
					add(st[top],st[top-1]);
					top--;
				} 
				if(st[top]==p){
					st[++top]=j;
				}else{
					add(st[top],p);
					st[top]=p;
					st[++top]=j;
				}
			}
		}
		while(top>1){
			add(st[top],st[top-1]);
			top--;
		}
		for(int j:nd[i]) if(!vis[j]&&op[j]==1){
			vis[j]=true;
			cnt[j]=1;dfs1(j,j,0,i);
		}
		for(int j:vir) tre[j].clear();
	}
	for(int i=1;i<=m;i++){
		cin>>le[i]>>ri[i];
		que[in[le[i]]].push_back(i);
	}
	for(int i=1;i<=n;i++){
		for(auto j:cot[i]){
			T.add(j.l,j.d);
			T.add(j.r+1,-j.d);
		}
		for(int id:que[i]){
			ans[id]=T.ask(in[ri[id]]);
		}
	}
	for(int i=1;i<=m;i++) cout<<ans[i]<<endl;
	return 0;
}
```

---

## 作者：Felix72 (赞：1)

思考一条路径怎么计算，发现每种颜色能拆开考虑。那么对一种特定颜色怎样计算呢？我们把路径上遇到的钥匙和箱子依次看成括号，这贡献就是最大匹配数量。

如果能把每个钥匙的贡献也拆开，那么颜色独立、结点独立，扫描线就可以解决。我们略加思索后发现，要枚举一把钥匙和一个箱子，还要判断一条路径依次经过他们会不会产生贡献。

枚举是 $O(n)$ 级别的，我们试用 $O(\log n)$ 的复杂度做判断。首先思考充要条件，就是这把钥匙开的刚好是这个箱子。那么可以拆成两个条件：

- 这钥匙在走到箱子之前是没有被其他箱子用掉；
- 走到这箱子时钥匙恰好剩一把；

想想用栈做括号子序列匹配的过程，就能知道只要满足这两个条件，一条经过他们的路径必然产生贡献。

不难把这两个条件挂到各种神奇数据结构上维护（我这里用树状数组和 $O(1) \operatorname{LCA}$ 做），那么判断完有贡献的路径就能扫描线了。

```cpp
/* Good Game, Well Play. */
#include <bits/stdc++.h>
#define lowbit(x) ((x) & (-(x)))
using namespace std;

const int N = 500010;
int n, m; vector < int > key[N], box[N], tr[N];

struct BIT
{
	long long c[N];
	inline void add(int pos, long long num)
	{for(int i = pos; i <= n; i += lowbit(i)) c[i] += num;}
	inline void insert(int l, int r, long long num)
	{add(l, num), add(r + 1, -num);}
	inline long long query(int l, int r)
	{
		assert(l == r); long long res = 0;
		for(int i = l; i; i -= lowbit(i)) res += c[i]; return res;
	}
}; BIT bit;

int dfn[N], ps[N], sign, siz[N], fa[N][21]; int seq[N * 2][21], sn, dep[N], lft[N];
inline int LCA(int x, int y)
{
	if(lft[x] > lft[y]) swap(x, y);
	int k = log2(lft[y] - lft[x] + 1);
	if(dep[seq[lft[x]][k]] <= dep[seq[lft[y] - (1 << k) + 1][k]])
		return seq[lft[x]][k];
	else return seq[lft[y] - (1 << k) + 1][k];
}
inline void init(int now, int prt)
{
	seq[++sn][0] = now, dep[now] = dep[prt] + 1;
	dfn[now] = ++sign, ps[sign] = now; siz[now] = 1;
	fa[now][0] = prt;
	for(int i = 1; ; ++i)
	{
		if(fa[fa[now][i - 1]][i - 1]) fa[now][i] = fa[fa[now][i - 1]][i - 1];
		else break;
	}
	for(int to : tr[now])
	{
		if(to == prt) continue;
		init(to, now); seq[++sn][0] = now;
		siz[now] += siz[to];
	}
}
inline void init_LCA()
{
	for(int i = 1; (1 << i) <= sn; ++i)
	{
		for(int j = 1; j + (1 << i) - 1 <= sn; ++j)
		{
			if(dep[seq[j][i - 1]] <= dep[seq[j + (1 << (i - 1))][i - 1]])
				seq[j][i] = seq[j][i - 1];
			else seq[j][i] = seq[j + (1 << (i - 1))][i - 1];
		}
	}
	for(int i = sn; i >= 1; --i) lft[seq[i][0]] = i;
}

bool ban[N];
inline int get_dist(int x, int y)
{return dep[x] + dep[y] - 2 * dep[LCA(x, y)];}
inline int get_path(int x, int y)
{return bit.query(dfn[x], dfn[x]) + bit.query(dfn[y], dfn[y]) - bit.query(dfn[LCA(x, y)], dfn[LCA(x, y)]) - bit.query(dfn[fa[LCA(x, y)][0]], dfn[fa[LCA(x, y)][0]]);}
inline bool on_path(int x, int y, int p)
{return (get_dist(x, p) + get_dist(y, p) == get_dist(x, y));}
inline int jump(int x, int dist)
{
	while(dist)
	{
		int k = __lg(lowbit(dist));
		x = fa[x][k], dist -= lowbit(dist);
	}
	return x;
}
struct Line {int l, r, val;}; vector < Line > line[N];
struct Query {int pos, id;}; vector < Query > q[N]; int res[1000010];
inline void work(int lx, int rx, int ly, int ry)
{
//	cerr << lx << " " << rx << " " << ly << " " << ry << '\n';
	line[lx].push_back({ly, ry, 1});
	line[rx + 1].push_back({ly, ry, -1});
}

int main()
{
//	freopen("keys.in", "r", stdin);
//	freopen("keys.out", "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= n; ++i)
	{
		int op, c; cin >> op >> c;
		if(op == 1) key[c].push_back(i);
		else box[c].push_back(i);
	}
	for(int i = 1, x, y; i < n; ++i)
	{
		cin >> x >> y;
		tr[x].push_back(y);
		tr[y].push_back(x);
	}
	init(1, 0), init_LCA();
	for(int i = 1, x, y; i <= m; ++i)
	{
		cin >> x >> y;
		q[dfn[x]].push_back({dfn[y], i});
	}
	for(int c = 1; c <= n; ++c)
	{
		for(int x : key[c]) bit.insert(dfn[x], dfn[x] + siz[x] - 1, 1);
		for(int x : box[c]) bit.insert(dfn[x], dfn[x] + siz[x] - 1, -1);
		for(int px : key[c])
		{
			for(int py : key[c])
			{
				if(px != py && get_path(px, py) <= 1) ban[py] = true;
				else ban[py] = false;
			}
			for(int py : box[c])
			{
				if(get_path(px, py) == 0)
				{
					bool flag = true;
					for(int chk : key[c])
						if(ban[chk] && on_path(px, py, chk))
							flag = false;
					if(!flag) continue;
//					cerr << "! " << px << " " << py << '\n';
					if(LCA(px, py) == px)
					{
						int p = jump(py, dep[py] - dep[px] - 1);
						if(1 < dfn[p]) work(1, dfn[p] - 1, dfn[py], dfn[py] + siz[py] - 1);
						if(dfn[p] + siz[p] <= n) work(dfn[p] + siz[p], n, dfn[py], dfn[py] + siz[py] - 1);
					}
					else if(LCA(px, py) == py)
					{
						int p = jump(px, dep[px] - dep[py] - 1);
						if(1 < dfn[p]) work(dfn[px], dfn[px] + siz[px] - 1, 1, dfn[p] - 1);
						if(dfn[p] + siz[p] <= n) work(dfn[px], dfn[px] + siz[px] - 1, dfn[p] + siz[p], n);
					}
					else work(dfn[px], dfn[px] + siz[px] - 1, dfn[py], dfn[py] + siz[py] - 1);
				}
			}
		}
		for(int x : key[c]) bit.insert(dfn[x], dfn[x] + siz[x] - 1, -1);
		for(int x : box[c]) bit.insert(dfn[x], dfn[x] + siz[x] - 1, 1);
	}
	for(int i = 1; i <= n; ++i)
	{
		for(Line li : line[i]) bit.insert(li.l, li.r, li.val);
		for(Query qy : q[i]) res[qy.id] = bit.query(qy.pos, qy.pos);
	}
	for(int i = 1; i <= m; ++i) cout << res[i] << '\n';
	return 0;
}
/*
5 5
1 1  2 1  2 1  1 1  2 1
1 2
2 3
3 4
4 5
1 2  1 3  1 4  1 5  5 1
*/
```

---

## 作者：strcmp (赞：1)

注意到同种颜色钥匙数 $\le 5$ 是一个非常强的性质。

对每个钥匙，求出其配对到的所有宝箱，这显然可以直接建虚树然后维护一个括号序列求。

那么，只要 $(s_i,\,t_i)$ 覆盖了一对配对的钥匙和箱子，就会产生 $1$ 的贡献。

分类讨论，设 $(u,\,v)$ 是一对配对的钥匙和箱子，考虑在满足什么条件时会被 $(s,\,t)$ 覆盖。设 $d_u$ 为 $u$ 在 dfs 序上排的编号，$r$ 为 $u$ 在 $v$ 方向子树上的儿子。

$\text{lca}(u,\,v) = u$，显然 $s$ 不能在 $r$ 子树内，且 $t$ 必须在 $v$ 的子树内。于是当且仅当 $1\le d_s < d_r \wedge d_v \le d_t < d_v + \text{siz}(v)$ 或者 $d_r + \text{siz}(r) \le d_s \le n \wedge d_v \le d_t < d_v + \text{siz}(v)$。（$s$ 可以为 $u$）

$\text{lca}(u,\,v) = v$，显然 $s$ 必须在 $u$ 的子树内，且 $t$ 不能在 $v$ 的 $u$ 子树内。与上一个讨论同理。

$\text{lca}(u,\,v) \ne u,\,\text{lca}(u,\,v) \ne v$，显然 $s$ 必须在 $u$ 子树内，$v$ 必须在 $t$ 子树内，同理。

经过上述转化后就变成了经典矩阵加，单点查的二维数点问题，离线下来树状数组即可。

时间复杂度 $\Theta(k n \log n + m \log n)$，其中 $k = 5$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const int maxn = 1e6 + 10;
const ll mod = 1000000007LL;
const ll inf = 1145141919810LL;
struct edge {
	int to, nxt;
}node[maxn << 1], vn[maxn << 1]; int head[maxn], vh[maxn], ty[maxn], vc = 0, cnt = 0, n;
inline void addE(int u, int v) {
	node[cnt].nxt = head[u];
	node[cnt].to = v;
	head[u] = cnt++;
}
inline void con(int u, int v) {
	vn[vc].nxt = vh[u];
	vn[vc].to = v;
	vh[u] = vc++;
}
int fa[maxn][21], dfn[maxn], siz[maxn], dep[maxn], dct = 0;
namespace LCA {
	void dfs(int u, int f) {
		fa[u][0] = f; dfn[u] = ++dct; siz[u] = 1; dep[u] = dep[f] + 1;
		for (int i = 1; i <= 20; i++) fa[u][i] = fa[fa[u][i - 1]][i - 1];
		for (int i = head[u]; ~i; i = node[i].nxt) {
			int v = node[i].to;
			if (v != f) dfs(v, u), siz[u] += siz[v];
		}
	}
	inline int lca(int u, int v) {
		if (dep[u] < dep[v]) swap(u, v);
		int d = dep[u] - dep[v];
		for (int i = 0; i <= 20; i++) if ((1 << i) & d) u = fa[u][i];
		if (u == v) return u;
		for (int i = 20; i >= 0; i--) {
			if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
		}
		return fa[u][0];
	}
}
using LCA::lca;
vector<int>vec[maxn]; int col[maxn];
vector<int>cv[maxn], ck[maxn];
//颜色为 i 的所有点集合
//颜色为 i 的钥匙点集合
namespace vtree {
	int key[maxn], num[7]; int S = 0, nc = 0, p = 0;
	void build() {
		vc = 0;
		auto cmp = [=](int x, int y) { return dfn[x] < dfn[y]; };
		sort(key + 1, key + p + 1, cmp); int now = p;
		for (int i = 1; i < now; i++) key[++p] = lca(key[i], key[i + 1]);
		sort(key + 1, key + p + 1);
		int len = unique(key + 1, key + p + 1) - key - 1;
		sort(key + 1, key + len + 1, cmp);
		for (int i = 1; i <= len; i++) vh[key[i]] = -1;
		for (int i = 1, lc; i < len; i++) {
			lc = lca(key[i], key[i + 1]); 
			con(lc, key[i + 1]); con(key[i + 1], lc);
		}
	}
	void getp(int u, int f, int now) {
		if (now < 0) return;
		for (int i = vh[u]; ~i; i = vn[i].nxt) {
			int v = vn[i].to;
			if (v == f) continue;
			if (!now && col[v] == nc && ty[v] == 2) { vec[S].push_back(v); continue; }
			int ct = 0;
			if (col[v] == nc) {
				if (ty[v] == 2) --ct;
				else ++ct;
			}
			getp(v, u, now + ct);
		}
	}
}
using vtree::key;
using vtree::p;
ll c[maxn];
inline int found(int x, int y) {
	if (dep[x] > dep[y]) swap(x, y);
	for (int i = 20; i >= 0; i--) {
		if (dep[fa[y][i]] > dep[x]) y = fa[y][i];
	}
	return y;
}
inline void add(int x, ll d) {
	while (x <= n) c[x] += d, x += x & (-x);
}
inline ll query(int x) {
	ll sum = 0;
	while (x) sum += c[x], x -= x & (-x);
	return sum;
}
vector<pair<int, int>> cz[maxn], a[maxn];
inline void ins(int x1, int x2, int y1, int y2) {
	if (x1 > x2 || y1 > y2) return;
	cz[x1].push_back({ y1, 1 });
	cz[x1].push_back({ y2 + 1, -1 });
	cz[x2 + 1].push_back({ y1, -1 });
	cz[x2 + 1].push_back({ y2 + 1, 1 });
}
inline void road(int u, int v) {
	if (lca(u, v) == u) {
		int w = found(u, v);
		ins(1, dfn[w] - 1, dfn[v], dfn[v] + siz[v] - 1);
		ins(dfn[w] + siz[w], n, dfn[v], dfn[v] + siz[v] - 1);
	}
	else if (lca(u, v) == v) {
		int w = found(u, v);
		ins(dfn[u], dfn[u] + siz[u] - 1, 1, dfn[w] - 1);
		ins(dfn[u], dfn[u] + siz[u] - 1, dfn[w] + siz[w], n);
	}
	else {
		ins(dfn[u], dfn[u] + siz[u] - 1, dfn[v], dfn[v] + siz[v] - 1);
	}
}
ll ans[maxn]; int m;
int main() {
	//freopen("keys4.in", "r", stdin);
	//freopen("keys4.out", "w", stdout);
	memset(head, -1, sizeof(head));
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		scanf("%d%d", &ty[i], &col[i]), cv[col[i]].push_back(i);
		if (ty[i] == 1) ck[col[i]].push_back(i);
	}
	for (int i = 1; i < n; i++) {
		int x, y;
		scanf("%d%d", &x, &y);
		addE(x, y); addE(y, x);
	}
	LCA::dfs(1, 0);
	for (int i = 1; i <= m; i++) {
		int x, y;
		scanf("%d%d", &x, &y);
		a[dfn[x]].push_back({ dfn[y], i });
	}
	for (int i = 1; i <= n; i++) {
		key[++p] = 1;
		for (int j = 0; j < cv[i].size(); j++) key[++p] = cv[i][j];
		sort(key + 1, key + p + 1);
		p = unique(key + 1, key + p + 1) - key - 1;
		vtree::build(); vtree::nc = i;
		for (int j = 0; j < ck[i].size(); j++)
			vtree::S = ck[i][j], vtree::getp(ck[i][j], 0, 0);
		p = 0;
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j < vec[i].size(); j++) road(i, vec[i][j]);//, cout << "(" << i << ", " << vec[i][j] << ")\n";
	}
	for (int i = 1; i <= n; i++) {
		for (pair<int, int>o : cz[i]) add(o.first, o.second);
		for (pair<int, int>o : a[i]) ans[o.second] = query(o.first);
	}
	for (int i = 1; i <= m; i++) printf("%lld\n", ans[i]);
	return 0;
}
```

---

## 作者：bamboo12345 (赞：0)

题意：很简单了，不再赘述。

做法：

首先我们注意到每种颜色之间的贡献是相互独立的，我们可以分别拉出来虚树处理。

因为每种钥匙只有 $5$ 把，那么我们考虑一个钥匙怎么做贡献，那么肯定是从某个点到这个钥匙再向别的方向走到一个宝箱，这个事情其实类似于括号序列。

所以我们可以从每个钥匙开始搜索虚树，类似括号序列的方法去找到配对的宝箱并记录这些贡献对，对于询问，那么就是要看这条路径 $(u,v)$ 覆盖的贡献对的价值之和。

这个是经典的二维数点问题，这里讲细一点。

我们考虑讨论一下一个贡献对的形态：

1. $(u,v)$ 中其中一个是另一个的祖先，这里假设 $u$ 是 $v$ 的祖先，那么就要求这个路径的一个起点在 $u$ 除了 $v$ 这一侧的子树外，且终点在 $v$ 内。假设 $v$ 一直向上跳直到父亲是 $u$ 跳到的节点是 $p$，那么我们把树拍到 dfs 序上，就要求询问起点在 $[1, dfn_p - 1]\bigcup[out_p, n]$，终点在 $[dfn_v, out_v]$ 中。其中 $dfn$ 是 dfs 序的编号，$out$ 是节点 $u$ 子树中 dfs 序最大的编号。

2. 没有祖先关系，那么要求起点在 $[dfn_u, out_u]$，终点在 $[dfn_v,out_v]$ 中。

直接二维数点即可。

代码：

```
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2.5e6 + 5;
int n, m, t[maxn / 5], c[maxn / 5], dfn[maxn / 5], out[maxn / 5], st[maxn / 5 * 2][21], lg[maxn / 5  * 2], cnt, dep[maxn / 5];
vector<int> v[maxn / 5], e[maxn / 5], g[maxn / 5];
void dfs(int u, int fa) {
	st[++cnt][0] = u; dfn[u] = cnt;
	dep[u] = dep[fa] + 1;
	for (int i = 0; i < e[u].size(); i++) {
		int v = e[u][i];
		if(v == fa)
			continue;
		dfs(v, u);
		st[++cnt][0] = u;
	}
	out[u] = cnt;
}
int getmin(int x, int y) {
	return (dep[x] < dep[y] ? x : y);
}
void prepare() {
	lg[0] = -1;
	for (int i = 1; i <= cnt; i++)
		lg[i] = lg[i >> 1] + 1;
	for (int j = 1; (1 << j) <= cnt; j++)
		for (int i = 1; i + (1 << j) - 1 <= cnt; i++)
			st[i][j] = getmin(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);
}
int lca(int x, int y) {
	x = dfn[x], y = dfn[y];
	if(x > y)
		swap(x, y);
	int k = lg[y - x + 1];
	return getmin(st[x][k], st[y - (1 << k) + 1][k]);
}
bool cmp(int x, int y) {
	return dfn[x] < dfn[y] ? 1 : 0; 
}
struct node {
	int st, ed;
} x[maxn];
int tot, nw;
void dfs_c(int u, int col, int cnt, int fa, int rt) {
//	cout << u << " " << cnt << endl;
	if(c[u] == col)
		(t[u] == 1 ? cnt++ : cnt--);
	if(!cnt) {
		x[++tot] = {rt, u};
		return ;
	}
	for (int i = 0; i < g[u].size(); i++) {
		int v = g[u][i];
		if(v == fa)
			continue;
		dfs_c(v, col, cnt, u, rt);
	}
}
void build(int col) {
	if(!v[col].size())
		return ;
	sort(v[col].begin(), v[col].end(), cmp);
	int len = v[col].size();
	for (int i = 0; i < len - 1; i++)
		v[col].push_back(lca(v[col][i], v[col][i + 1]));
	sort(v[col].begin(), v[col].end(), cmp);
	len = unique(v[col].begin(), v[col].end()) - v[col].begin();
//	cout << col << " asd" << len << endl;
	while(v[col].size() > len)
		v[col].pop_back();
	for (int i = 0; i < v[col].size() - 1; i++) {
		int x = v[col][i], y = v[col][i + 1];
		int d = lca(x, y);
		g[d].push_back(y), g[y].push_back(d);
	}
	for (int i = 0; i < len; i++)
		if(col == c[v[col][i]] && t[v[col][i]] == 1) {
	//		cout << v[col][i] << endl;
			dfs_c(v[col][i], col, 0, 0, v[col][i]);
		}
	for (int i = 0; i < v[col].size(); i++)
		g[v[col][i]].clear();
}
#define lowbit(x) (x & (-x))
struct Tree_array {
	int tr[maxn], n;
	void add(int x, int val) {
		while(x <= n)
			tr[x] += val, x += lowbit(x);
	}
	int query(int x) {
		int ans = 0;
		while(x)
			ans += tr[x], x -= lowbit(x);
		return ans;
	}
} tree;
struct node1 {
	int sy, ey, h, id;
	friend bool operator<(node1 x, node1 y) {
		return x.h < y.h;
	}
} y[maxn * 4];
int totn;
void prepare_mat() {
	for (int i = 1; i <= tot; i++) {
		int u = x[i].st, v = x[i].ed;
		int d = lca(u, v);
	//	cout << u << " " << v << " asdf" << d << endl;
		if(u == d) {
			for (int j = 0; j < e[u].size(); j++) {
				int p = e[u][j];
				if(dfn[p] <= dfn[v] && out[p] >= dfn[v] && dep[p] > dep[u]) {
					u = p;
					y[++totn] = {1, dfn[u] - 1, dfn[v], 1};
					y[++totn] = {out[u] + 1, cnt, dfn[v], 1};
					y[++totn] = {1, dfn[u] - 1, out[v] + 1, -1};
					y[++totn] = {out[u] + 1, cnt, out[v] + 1, -1};
			//		cout << dfn[u] << " " << dfn[v] << endl;
					break;
				}
			}
		}
		else if(v == d) {
			for (int j = 0; j < e[v].size(); j++) {
				int p = e[v][j];
				if(dfn[p] <= dfn[u] && out[p] >= dfn[u] && dep[p] > dep[v]) {
					v = p;
					y[++totn] = {dfn[u], out[u], 1, 1};
					y[++totn] = {dfn[u], out[u], dfn[v], -1};
					y[++totn] = {dfn[u], out[u], out[v] + 1, 1} ;
					y[++totn] = {dfn[u], out[u], cnt + 1, -1};
					break;
				}
			}
		}
		else {
			y[++totn] = {dfn[u], out[u], dfn[v], 1};
			y[++totn] = {dfn[u], out[u], out[v] + 1, -1};
		}
	}
	y[++totn] = {1, cnt, cnt + 1, 0};
	sort(y + 1, y + totn + 1);
}
struct query {
	int x, y, id;
	friend bool operator<(query x, query y) {
		return x.y < y.y;
	}
} q[maxn];
int totq, ans[maxn];
int main() {
	ios::sync_with_stdio(false);
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		cin >> t[i] >> c[i], v[c[i]].push_back(i);
	for (int i = 1; i < n; i++) {
		int x, y;
		cin >> x >> y;
		e[x].push_back(y);
		e[y].push_back(x);	
	}
	dfs(1, 0);
	prepare();
	for (int i = 1; i <= n; i++)
		build(i);
	prepare_mat();
	for (int i = 1; i <= m; i++) {
		int x, y; cin >> x >> y;
		x = dfn[x], y = dfn[y];
		q[++totq] = {x, y, i};
	}
	sort(q + 1, q + m + 1);
	tree.n = cnt;
	int pos = 1;
	for (int i = 1; i <= totn; i++) {
		while(pos <= m && q[pos].y < y[i].h) {
		//	cout << pos << " " << " " << q[pos].id << endl; 
			ans[q[pos].id] = tree.query(q[pos].x);
			pos++;
		}
		tree.add(y[i].sy, y[i].id);
		tree.add(y[i].ey + 1, -y[i].id);
	//	cout << y[i].sy << " " << y[i].ey << " " << y[i].h << " " << y[i].id << endl; 
	}
	for (int i = 1; i <= m; i++)
		cout << ans[i] << endl;
	return 0;
}
```

---

## 作者：A2ure_Sky (赞：0)

# [P8339 [AHOI2022] 钥匙](https://www.luogu.com.cn/problem/P8339)

## 题意

给定一颗树，树上每个节点都有一把钥匙 $key$ 或者一个宝箱 $box$，对应颜色的钥匙才能打开对应的宝箱，钥匙只能使用一次，**相同颜色的钥匙最多只有 $5$ 把**。

现在有若干次询问，每次询问给定一组 $(s,e)$，求从 $s$ 走到 $e$ 能打开多少个宝箱。

## 题解

精简一下题目，这个问题可以理解为树上的括号匹配问题，**下面称 $(key,box)$ 为一组匹配**，即用这个 $key$ 可以沿着某个路径打开这个 $box$。

乍一看很难做，这个时候就得揪着很特殊的条件分析。

没错，特殊条件就是相同颜色的钥匙最多只有 $5$ 把，所以匹配数量是 $O(n)$ 的，可以将所有的匹配**预处理**出来。
  
> 实现方法：将相同颜色地节点提取出来单独处理，使用了[虚树](https://oi-wiki.org/graph/virtual-tree/)，分离出来后由于同种颜色地钥匙最多只有 $5$ 把，所以我们可以分别以这几把钥匙为根进行 $\text{dfs}$ 搜索，找到匹配的条件可以直接理解为**括号匹配**，想必这样子就不必多说了。

这样一来每次询问就等价于统计一段路径上的匹配数量。

首先如果路径 $(key,box)$ 只有被路径 $(s,e)$ 覆盖了，才会对其产生贡献。

由于很难直接针对每个询问分别统计，于是考虑一个匹配会对哪些询问 $(s,e)$ 产生贡献，分三种情况：

1. $box$ 是 $key$ 的祖先：
	$s$ 要在 $key$ 的子树中，$e$ 不能在路径 $(key,box)$ 上与 $box$ 相邻的节点的子树中。

2. $key$ 是 $box$ 的祖先：
	跟 1. 同理。

3. $key$ 和 $box$ 没有祖先关系：
	$s$ 要在 $key$ 的子树中，$e$ 要在 $box$ 的子树中。

很自然的想到区间的概念，我们需要把这抽象的条件转换为区间，从子树得到灵感，无非就是转化为 $\text{dfn}$ 序，**因为** $\text{dfn}$ **序在子树内是连续的。**

所以我们得到了这个信息，对于一对匹配 $(key,box)$，想要得到其贡献，$s$ 和 $e$ 的 $\text{dfn}$ 序必须在某个区间内。

我们以 $s$ 的 $\text{dfn}$ 序为横轴，$e$ 的 $\text{dfn}$ 序为竖轴，那么问题就转化为用矩形覆盖坐标系，再单点查询被覆盖了几次，用**区间修改，单点查询**的方法解决。（代码第 $223$ 行到第 $234$ 行）

> 实现方法：由于是平面上，所以我们使用**差分+树状数组+二位偏序**实现，具体地，将询问离线，再用下标的形式降掉一维，再用权值树状数组维护另外一维统计答案。

最后，由于要算 $\text{dfn}$ 序和 $\text{LCA}$（虚树中要用），所以可以直接打一个重链剖分。

总结：由特殊条件想到预处理可能产生的贡献 $(key,box)$，再根据每对 $(key,box)$ 的作用范围进行区间覆盖，单点查询。全程保证了总时间复杂度为 $O((n+m) \log n)$。

## 代码

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb emplace_back

using namespace std;
using pii = pair<int,int>;

const int N=5e5+5;
const int M=1e6+5;

int n,m;
int t[N],c[N];
vector<int> e[N],E[N],col[N];
vector<pii> q[N];

//树链剖分
int fa[N],dep[N],siz[N],son[N];
void dfs1(int u){
	siz[u]=1;
	for(auto v:e[u]){
		if(v==fa[u]) continue;
		fa[v]=u;
		dep[v]=dep[u]+1;
		dfs1(v);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]]) son[u]=v;
	}
}

int dfn[N],top[N],tot;
void dfs2(int u,int t){
	top[u]=t;
	dfn[u]=++tot;
	if(!son[u]) return;
	dfs2(son[u],t);
	for(auto v:e[u]) if(v!=fa[u]&&v!=son[u])  dfs2(v,v);
}

void slpf() {dfs1(1),dfs2(1,1);}
/*------*/

//LCA
int LCA(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);		
		x=fa[top[x]]; 
	}
	return dep[x]<dep[y]?x:y;
}

//求路径上的次端点（对的可以这样理解）
int find(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	int lst;
	while(top[x]!=top[y]) lst=top[x],x=fa[top[x]];
	if(x==y) return lst;
	return son[y];
}

//平面差分
// dfn[s] in [a, b], dfn[e] in [c, d]: +1
vector<pii> row[N];
void add(int a,int b,int c,int d){
	if(a>b||c>d) return;
	row[a].eb    (c,1);
	row[a].eb  (d+1,-1);
	row[b+1].eb  (c,-1);
	row[b+1].eb(d+1,1);
}

//将 (key,box) 插入dfn平面
void insert(int x,int y){
	int l=LCA(x,y);
	if(l==x){
		int z=find(x,y);
		//警示后人：这种很多逗号的地方一定要对齐，要不然你调半天都看不出来这里打错了。
		add(1            ,dfn[z]-1,dfn[y],dfn[y]+siz[y]-1);
		add(dfn[z]+siz[z],n       ,dfn[y],dfn[y]+siz[y]-1);
	}else if(l==y){
		int z=find(x,y);
		add(dfn[x],dfn[x]+siz[x]-1,1            ,dfn[z]-1);
		add(dfn[x],dfn[x]+siz[x]-1,dfn[z]+siz[z],n);
	}else add(dfn[x],dfn[x]+siz[x]-1,dfn[y],dfn[y]+siz[y]-1);
}


//有关 找出 (key,box) 配对的 函数。
namespace keybox{
	//Virtual_Tree：虚树
	vector<int> id;
	int a[N],m,b[N<<1],len;
	bool cmp (int x,int y) {return dfn[x]<dfn[y];}
	void clear(){
		m=len=0;
		while(!id.empty()){
			E[id.back()].clear();
			id.pop_back();
		}
	}
	//建虚树（二次排序 + LCA 连边）
	void build_VT(int c){
		clear();
		for(int x:col[c]) a[++m]=x;
		sort(a+1,a+m+1,cmp);
		for(int i=1;i<m;i++){
			b[++len]=a[i];
			b[++len]=LCA(a[i],a[i+1]);
		}
		b[++len]=a[m];
		sort(b+1,b+len+1,cmp);
		len=unique(b+1,b+len+1)-b-1;
		for(int i=1;i<len;i++){
			int l=LCA(b[i],b[i+1]);
			id.eb(l),id.eb(b[i+1]);
			E[l].eb(b[i+1]),E[b[i+1]].eb(l);
		}
	}
	//以key为起点找与其配对的box，dfs最多被调用5次
	void dfs(int u,int fa,int w,int col,int rt){
		if(c[u]==col){
			if(t[u]==1) w++;
			else{
				w--;
				if(!w){
					insert(rt,u);
					return;
				}
			}
		}
		for(auto v:E[u]) if(v!=fa) dfs(v,u,w,col,rt);
	}
	void search(int col){
        for(int i=1;i<=m;i++) 
            if(c[a[i]]==col&&t[a[i]]==1) 
                dfs(a[i],a[i],0,col,a[i]);
    }
}

//树状数组
namespace BIT{
	int t[N];
	void upd(int x,int y){
		for(;x<N;x+=x&-x) t[x]+=y;
	}
	int qry(int x){
		int res=0;
		for(;x;x-=x&-x) res+=t[x];
		return res;
	}
}

int ans[M];

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>t[i]>>c[i],col[c[i]].eb(i);
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		e[u].eb(v),e[v].eb(u);
	}

	slpf();

	for(int i=1;i<=n;i++){
		if(col[i].empty()) continue;
		keybox::build_VT(i);
		keybox::search(i);
	}

    //将询问离线
	for(int i=1;i<=m;i++){
		int s,e;
		cin>>s>>e;
		q[dfn[s]].eb(dfn[e],i);
	}

    //树状数组+二维偏序
	for(int i=1;i<=n;i++){
		for(auto it:row[i]) BIT::upd(it.fi,it.se);
		for(auto it:q[i]) ans[it.se]=BIT::qry(it.fi);
	}

	for(int i=1;i<=m;i++) cout<<ans[i]<<"\n";
    return 0;
}
```

---

## 作者：Albert_Wei (赞：0)

考虑枚举同色的（钥匙，宝箱）对进行贡献计算。我们可以用类似括号序列匹配的方式进行钥匙与宝箱的匹配。具体地，我们认为一个（钥匙，宝箱）对合法当且仅当该钥匙到宝箱的路径上将该颜色的钥匙看作 `(`，该颜色的宝箱看作 `)`，形成一个合法括号序列，且该钥匙与该宝箱匹配。容易发现，这样将钥匙与宝箱匹配后，一个路径上能开的宝箱个数恰好是与遍历顺序同方向且被该路径包含的合法（钥匙，宝箱）对的钥匙到宝箱的路径的个数。这是因为我们遍历路径，用栈贪心匹配宝箱的结果恰好与我们的匹配方式等价，所以，在我们预处理出所有合法（钥匙，宝箱）对后可以在 dfs 序上二位数点做到 $\mathcal{O}((n + m) \log n)$ 的复杂度。

考虑如何预处理，我们考虑对每种颜色建立虚树。我们将钥匙定为根进行搜索。搜索过程中，我们考虑用 dp 模拟括号匹配的过程。将钥匙视为 $+1$，宝箱视为 $-1$，搜索时遇到 dp 值为 $0$ 的结点即可与根节点匹配，并立即返回即可（根据括号序列的匹配方式，只能与第一个 dp 值为 $0$ 的宝箱匹配）。由于每种颜色的钥匙不超过 $5$ 把，预处理复杂度为 $\mathcal{O}(n \log n)$，瓶颈在建立虚树。

---

## 作者：hoko (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P8339)

## 题意

给出一棵树，树上每个节点有一把钥匙或宝箱，钥匙和宝箱都有颜色，颜色要一一对应才能打开宝箱。现在给出 $m$ 趟旅程，每次给定 $s$ 和 $t$ 求一路上最多能开多少宝箱。

## 思路


注意到每种颜色之间互不干扰，所以可以分开考虑。用单调栈构建不同颜色的虚树，然后对于每种颜色的虚树，我们考虑求出可能成为贡献的几对节点，我们假设钥匙是 $k$，宝箱是 $b$，那么用 $k_i$ 开的 $b_j$ 就可以作为贡献记录下来，记为 $(b_i,k_j)$。

这里简单提一下怎么建虚树（实际是笔者才刚学会），对于每种颜色的钥匙和宝箱，我们用单调栈维护，将相同颜色的点与栈顶判断 $lca$，如果 $lca$ 是栈顶，那么直接入栈，否则将栈顶弹出，直到栈顶的深度与 $lca$ 的相同，如果这时栈顶不是 $lca$ 的话，要让 $lca$ 入栈。注意弹出的时候不要忘记连边。

具体情况见代码：
```cpp
void inline ins(ll x){
    vir.push_back(x);
    if(!top){
        s[++top]=x;
        return ;
    }
    ll p=lca(s[top],x);
    while(top>1&&dep[s[top-1]]>=dep[p]){
        e[s[top-1]].push_back(s[top]);
        e[s[top]].push_back(s[top-1]);
        top--;
    }
    if(s[top]!=p){
        e[s[top]].push_back(p);
        e[p].push_back(s[top]);
        s[top]=p;
        vir.push_back(p);
    }
    s[++top]=x;
}
```

这里顺便提一嘴 $lca$。这里的 $lca$ 是用重链剖分，不是倍增，倍增会超时。中联剖分的 $lca$ 每次就判断是否已经在一条链上，如果是就返回深度较小的那个点，否则就继续跳。

代码：
```cpp
ll lca(ll x,ll y){
    while(tp[x]!=tp[y]){
        if(dep[tp[x]]<dep[tp[y]])swap(x,y);
        x=fa[tp[x]];
    }
    return dep[x]<dep[y]?x:y;
}
```

现在我们考虑这个有什么用，如果想让一段旅程包含 $(b_i,k_j)$ 这个贡献，那么对 $s$ 和 $t$ 便有限制。

这里需要分类讨论一下：

如果 $b_i$ 和 $k_j$ 互不是对方的祖先，那么只需要 $s$ 在 $b_j$ 的子树内，$t$ 在 $k_i$ 的子树内即可。

如果 $b_i$ 是 $k_j$ 的祖先，那么只需要 $s$ 在 $b_i$ 的子树内，$t$ 不在 $k_j$ 的子树内，但是也可以在  $k_j$ 这个点上。我们令 $u$ 为 $k_j$ 到 $b_i$ 路径上的 $k_j$ 的儿子，那么 $s$ 只需要在 $b_i$ 的子树内，$t$ 只需要在 $u$ 的子树外即可。

如果 $k_j$ 是 $b_i$ 的祖先同理。

详细情况见代码：
```cpp
void pushup(ll l,ll r,ll x,ll y){
    if(l>r||x>y)return;
    sum[l].push_back({x,1});
    sum[l].push_back({y+1,-1});
    sum[r+1].push_back({x,-1});
    sum[r+1].push_back({y+1,1});
}
void insert(ll x,ll y){
    if(check(x,y)){
        ll z=js(y,x);
        pushup(1,dfn[z]-1,dfn[y],dfn[y]+siz[y]-1);
        pushup(dfn[z]+siz[z],n,dfn[y],dfn[y]+siz[y]-1);
    }
    else if(check(y,x)){
        ll z=js(x,y);
        pushup(dfn[x],dfn[x]+siz[x]-1,1,dfn[z]-1);
        pushup(dfn[x],dfn[x]+siz[x]-1,dfn[z]+siz[z],n);
    }
    else{
        pushup(dfn[x],dfn[x]+siz[x]-1,dfn[y],dfn[y]+siz[y]-1);
    }
}
```
这里的 $sum$ 数组是为了后面计算的差分数组。

那么要怎么判断是否在子树内呢。可以用 $dfs$ 序，在子树内的话 $dfs$ 序一定是连续的，所以只需要判断 $dfs$ 序是否在对应区间内即可。

那么具体该怎么计算呢？我们想到可以用树状数组维护区间差分。由于这里有两个区间的限制，所以我们用下标来维护一个区间，用值来维护另一个区间。

这里直接讲可能不太好懂，所以借助代码一起。

代码：
```cpp
for(int i=1;i<=m;i++){
    ll u,v;
    cin>>u>>v;
    num[dfn[u]].push_back({dfn[v],i});
}
for(int i=1;i<=n;i++){
    for(auto v:sum[i])add(v.first,v.second);
    for(auto v:num[i])ans[v.second]=query(v.first);
}
```

在这里面 $num$ 记录的是起点和终点以及编号，因为要离线处理。$sum$ 数组中存贮的是要差分的位置和值，因为每段旅程想要包含这段贡献的话，就要起点和终点都在对应的区间内，而我们用树状数组的下标和前缀和来维护第一个区间，保障当到这个起点时，所有能包含该起点的区间都被放入了树状数组，而第二个区间我们用树状数组的值，也就是用差分来维护，只要被包含在这段区间内的话，值就会 $+1$。

最后给一下完整代码：

```cpp
#include<bits/stdc++.h>
#define ll int
using namespace std;
const int M=1010101;
const int N=501010;
ll n,m,ans[M],siz[N],dep[N],fa[N],son[N],tp[N],dfn[N],tot,cnt,pre[N],top,S,col;
ll c[N],t[N],s[N],tree[N];
vector<ll>g[N];
void dfs1(ll u){
    siz[u]=1;
    for(auto v:g[u]){
        if(v==fa[u])continue;
        fa[v]=u;
        dep[v]=dep[u]+1;
        dfs1(v);
        siz[u]+=siz[v];
        if(siz[v]>siz[son[u]])son[u]=v;
    }
}
void dfs2(ll u,ll top){
    tp[u]=top,dfn[u]=++cnt;
    pre[dfn[u]]=u;
    if(son[u])dfs2(son[u],top);
    for(auto v:g[u]){
        if(v==fa[u]||v==son[u])continue;
        dfs2(v,v);
    }
}
ll lca(ll x,ll y){
    while(tp[x]!=tp[y]){
        if(dep[tp[x]]<dep[tp[y]])swap(x,y);
        x=fa[tp[x]];
    }
    return dep[x]<dep[y]?x:y;
}
vector<ll>vir,e[N];
void inline ins(ll x){
    vir.push_back(x);
    if(!top){
        s[++top]=x;
        return ;
    }
    ll p=lca(s[top],x);
    while(top>1&&dep[s[top-1]]>=dep[p]){
        e[s[top-1]].push_back(s[top]);
        e[s[top]].push_back(s[top-1]);
        top--;
    }
    if(s[top]!=p){
        e[s[top]].push_back(p);
        e[p].push_back(s[top]);
        s[top]=p;
        vir.push_back(p);
    }
    s[++top]=x;
}
bool check(ll x,ll y){return dfn[x]<=dfn[y]&&dfn[x]+siz[x]>dfn[y];}
ll js(ll x,ll y){
    ll res=0;
    while(tp[x]!=tp[y]){
        res=tp[x];
        x=fa[tp[x]];
    }
    if(x==y)return res;
    return pre[dfn[y]+1];
}
vector<pair<ll,ll> >sum[N];
void pushup(ll l,ll r,ll x,ll y){
    if(l>r||x>y)return;
    sum[l].push_back({x,1});
    sum[l].push_back({y+1,-1});
    sum[r+1].push_back({x,-1});
    sum[r+1].push_back({y+1,1});
}
void insert(ll x,ll y){
    if(check(x,y)){
        ll z=js(y,x);
        pushup(1,dfn[z]-1,dfn[y],dfn[y]+siz[y]-1);
        pushup(dfn[z]+siz[z],n,dfn[y],dfn[y]+siz[y]-1);
    }
    else if(check(y,x)){
        ll z=js(x,y);
        pushup(dfn[x],dfn[x]+siz[x]-1,1,dfn[z]-1);
        pushup(dfn[x],dfn[x]+siz[x]-1,dfn[z]+siz[z],n);
    }
    else{
        pushup(dfn[x],dfn[x]+siz[x]-1,dfn[y],dfn[y]+siz[y]-1);
    }
}
void dfs(ll u,ll fa,ll w){
    if(w<0)return;
    for(auto v:e[u]){
        if(v==fa)continue;
        if(!w&&c[v]==col&&t[v]==2){
            insert(S,v);
            continue;
        }
        ll k=0;
        if(c[v]==col&&t[v]==1)k++;
        if(c[v]==col&&t[v]==2)k--;
        dfs(v,u,w+k);
    }
}
ll lowbit(ll x){return x&(-x);}
void add(ll x,ll y){
    while(x<=n){
        tree[x]+=y;
        x+=lowbit(x);
    }
}
ll query(ll x){
    ll res=0;
    while(x){
        res+=tree[x];
        x-=lowbit(x);
    }
    return res;
}
vector<ll>b[N];
vector<pair<ll,ll> >num[N];
bool cmp(ll a,ll b){return dfn[a]<dfn[b];}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n>>m; 
    for(int i=1;i<=n;i++)cin>>t[i]>>c[i],b[c[i]].push_back(i);
    for(int i=1;i<n;i++){
        ll u,v;
        cin>>u>>v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs1(1);
    dfs2(1,1);
    top=0;
    for(int i=1;i<=n;i++){
    	col=i;
        if(!b[i].size())continue;
        sort(b[i].begin(),b[i].end(),cmp);
        for(auto v:b[i])ins(v);
        while(top>1){
            e[s[top-1]].push_back(s[top]);
            e[s[top]].push_back(s[top-1]);
            top--;
        }
        for(auto v:b[i]){
            if(t[v]==1&&c[v]==i){
            	S=v;
                dfs(v,0,0);
            }
        }
        for(auto v:vir)e[v].clear();
        vir.clear();
        top=0;
    }
    for(int i=1;i<=m;i++){
        ll u,v;
        cin>>u>>v;
        num[dfn[u]].push_back({dfn[v],i});
    }
    for(int i=1;i<=n;i++){
        for(auto v:sum[i])add(v.first,v.second);
        for(auto v:num[i])ans[v.second]=query(v.first);
    }
    for(int i=1;i<=m;i++)cout<<ans[i]<<'\n';
    return 0;
}
```

完结撒花！

---

## 作者：Dovish (赞：0)

## 思路
下文中记 $k$ 为同一个颜色的钥匙数量。

考虑从换根的角度来做这道题。

首先，考虑一个暴力的做法，扫一遍询问的路径，对于每个颜色单独考虑，将钥匙视为 `(`，宝藏视为 `)`，那么所有颜色括号匹配的总和就是答案。

我们钦定宝藏总是和栈顶的钥匙匹配，这样方便后边的思考。

考虑我们如果能快速地求出所有点到根的路径的答案，那么大概率我们也可以据此来换根求出任意两点间的答案。

那么考虑向上做合并：此时我们知道了 $u$ 的真子树内所有点到 $u$ 的某个直系儿子 $v$ 答案，考虑拓展到到 $u$ 的路径的答案。

如果 $u$ 是钥匙节点，直接不用管。否则考虑枚举每一个同颜色的钥匙，看看其是否在 $u$ 子树内且能匹配上。由于题目中限制 $k\le 5$，所以这么做就是对的了。

判定匹配可以先判定两点间路径上该颜色的钥匙数量和宝藏数量是否相等，若相等再判定括号匹配是否合法，这样保证了每次 check 一对节点的复杂度是 $O(k)$ 的。这些信息在合并以及后边的换根时都是可以简单地维护的。

发现上述过程直接搬到换根上是非常可行的，无非就是多一点分讨，本质上还是在讨论加入一个点对一个子树的影响。

具体实现的一些细节可以看代码注释。

复杂度 $O((n+m)\log n)$，常数会比较大，不过加上快读也可以在 1s 内跑出来的。
## code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define per(i,a,b) for(register int i=(a);i>=(b);--i)
#define edge(i,u) for(int i=head[u];i;i=e[i].next)
#define lc(u) tre[u].ls
#define rc(u) tre[u].rs
#define pii pair<int,int>
#define mp make_pair
#define pb push_back
#define fst first
#define sed second
#define Max(a,b) (a=max(a,b))
#define Min(a,b) (a=min(a,b))
using namespace std;
const int N=5e5+10,M=1e6+10,inf=1e9,mod=1e9+7;
bool MS;int used;
namespace Fast_IO{
	const int iosize=(1<<20);
	char ibuf[iosize+1],*p1=ibuf,*p2=ibuf;
	#define getchar() ((p1==p2)&&(p2=(p1=ibuf)+fread(ibuf+1,1,iosize,stdin),p1==p2)?EOF:*++p1)
	template<typename T>
	inline T read(T&x)
	{
		x=0;int f=1;
		char c=getchar();
		while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
		while(isdigit(c)){x=x*10+c-48;c=getchar();}
		x*=f;
		return x;
	}
}using Fast_IO::read;
int n;
namespace BIT
{
	int tre[N];
	inline int lowbit(int x){return x&(-x);}
	void update(int u,int k)
	{
		while(u<=n)
		{
			tre[u]+=k;
			u+=lowbit(u);
		}
	}
	void add(int l,int r,int k)
	{
		update(l,k);
		update(r+1,-k);
	}
	int query(int u)
	{
		int res=0;
		while(u)
		{
			res+=tre[u];
			u-=lowbit(u);
		}
		return res;
	}
}using namespace BIT;
int ans[M];
vector<int>pos[N];
vector<int>edge[N];
vector<pii>que[N];
int m;
int sign[N],c[N];
int res,dfn[N],rev[N],sz[N];
int wson[N],st[N],f[N];
int dis[N];//当前状态下，到关键点的路径上（和关键点颜色一致）的宝藏-钥匙个数
vector<bool>Dis[N];//当前状态下，到关键点的路径上（和关键点颜色一致）的 宝藏/钥匙 组成的序列。
void dfs(int u,int fa)
{
	f[u]=fa;
	dfn[u]=++res;
	rev[res]=u;
	sz[u]=1;
	for(auto v:edge[u])
	if(v!=fa)
	{
		dfs(v,u);
		sz[u]+=sz[v];
		if(sz[v]>sz[wson[u]])
		wson[u]=v;
	}
}
void df5(int u,int fa,int st)
{
	::st[u]=st;
	if(wson[u])
	df5(wson[u],u,st);
	for(auto v:edge[u])
	if(v!=fa&&v!=wson[u])
	df5(v,u,v);
}
int getson(int u,int v)
{
	while(1)
	{
		if(st[u]==st[v])
		return wson[v];
		u=st[u];
		if(f[u]==v)return u;
		u=f[u];
	}
}
bool chkson(int u,int v){return dfn[v]<=dfn[u]&&dfn[u]<dfn[v]+sz[v];}//u是v的儿子？ 
inline bool check(int x)
{
	int res=0;
	rep(i,1,Dis[x].size()-2)//因为我们希望x和now匹配，所有要求不含这两点的中间的点构成合法括号串
	{
		if(Dis[x][i]==0)res--;
		else res++;
		if(res>0)return 0;
	}
	return res==0;
}//检查x到当前节点路径上是否是合法括号串
void dfs1(int u,int fa)
{
	for(auto v:edge[u])
	if(v!=fa)dfs1(v,u);
	
	for(auto v:pos[c[u]])
	if(chkson(v,u))
	{
		if(sign[u]==1)dis[v]--,Dis[v].pb(0);
		if(sign[u]==2)dis[v]++,Dis[v].pb(1);
	}//更新dis信息
	
	if(sign[u]==2)
	for(auto v:pos[c[u]])
	if(chkson(v,u)&&dis[v]==0&&check(v)) 
	add(dfn[v],dfn[v]+sz[v]-1,1);
}
void dfs2(int u,int fa)
{
	for(auto s:que[u])
	ans[s.sed]=query(dfn[s.fst]);
	for(auto v:edge[u])
	if(v!=fa)
	{
		if(sign[u]==2)
		for(auto to:pos[c[u]])
		if(chkson(to,v)&&dis[to]==0&&check(to)) 
		add(dfn[to],dfn[to]+sz[to]-1,-1);//删去节点的贡献
		for(auto to:pos[c[u]])
		if(chkson(to,v))//在要去的子树内 
		{
			if(sign[u]==1)dis[to]++;
			if(sign[u]==2)dis[to]--;//考虑删除这个节点的贡献 
			Dis[to].pop_back();
		}
		for(auto to:pos[c[v]])
		if(!chkson(to,v))//不在要去的子树内 
		{
			if(sign[v]==1)dis[to]--,Dis[to].pb(0);
			if(sign[v]==2)dis[to]++,Dis[to].pb(1);//考虑加上这个节点的贡献 
		}
		if(sign[v]==2)
		for(auto to:pos[c[v]])
		if(!chkson(to,v)&&dis[to]==0&&check(to))
		{
			if(!chkson(v,to))
			add(dfn[to],dfn[to]+sz[to]-1,1);
			else
			{
				int k=getson(v,to);//v是to的哪个儿子？ 
				add(1,n,1);
				add(dfn[k],dfn[k]+sz[k]-1,-1);
			}
		}//新增节点的贡献
		
		dfs2(v,u);
		
		
		if(sign[v]==2)
		for(auto to:pos[c[v]])
		if(!chkson(to,v)&&dis[to]==0&&check(to))
		{
			if(!chkson(v,to))
			add(dfn[to],dfn[to]+sz[to]-1,-1);
			else
			{
				int k=getson(v,to);
				add(1,n,-1);
				add(dfn[k],dfn[k]+sz[k]-1,1);
			}
		}
		
		
		for(auto to:pos[c[u]])
		if(chkson(to,v))
		{
			if(sign[u]==1)dis[to]--,Dis[to].pb(0);
			if(sign[u]==2)dis[to]++,Dis[to].pb(1); 
		}
		for(auto to:pos[c[v]])
		if(!chkson(to,v))
		{
			if(sign[v]==1)dis[to]++;
			if(sign[v]==2)dis[to]--;
			Dis[to].pop_back();
		}
		if(sign[u]==2)
		for(auto to:pos[c[u]])
		if(chkson(to,v)&&dis[to]==0&&check(to))
		add(dfn[to],dfn[to]+sz[to]-1,1);//回退操作
	}
}
bool MT;
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	read(n);read(m); 
	rep(i,1,n)
	{
		read(sign[i]);
		read(c[i]);
		if(sign[i]==1)
		pos[c[i]].pb(i);
	}
	rep(i,2,n)
	{
		int u,v;
		read(u);
		read(v);
		edge[u].pb(v);
		edge[v].pb(u);
	}
	rep(i,1,m)
	{
		int u,v;
		read(u);
		read(v);
		que[v].pb(mp(u,i));
	}
	dfs(1,0);
	df5(1,0,1);
	dfs1(1,0);
	dfs2(1,0);
	rep(i,1,m)
	cout<<ans[i]<<"\n";
	cerr<<"Memory:"<<(&MS-&MT)/1048576.0<<"MB Time:"<<clock()/1000.0<<"s\n";
}
```

---

## 作者：鲤鱼江 (赞：0)

笑点解析：倍增被卡常了，三分钟紧急拼了个树剖。

VP 往年各省省选时做到了这个题，但是各种降智了。

先考虑特殊性质怎么做，发现一种颜色产生贡献当且仅当 $s$ 到 $t$ 的路径上**先后**包括了该颜色的钥匙与宝箱。

这是一个二元限制，把其看成矩形，直接扫描线二维数点即可解决。

思考怎么拓展到一般情况，考虑对每一种颜色建一个虚树，把每一个钥匙作为起点在虚树上遍历，考察一把钥匙产生贡献的充要条件。

我们换一种方式思考，把**当前颜色**的钥匙看成 $1$，箱子看成 $-1$，则同一颜色的钥匙 $x$ 和箱子 $y$ 产生贡献当且仅当路径 $(x,y)$ 的权值为 $0$ 且 $(x,y)$ 路径上不存在其它点使得权值为 $0$，当然还有一个平凡的条件就是 $s$ 到 $t$ 的路径上先后经过了 $x$ 和 $y$。

由于路径是有向的，所以不难证明贡献不重，而贡献明显不漏，所以正确性很有保障。

问题就转化到了特殊性质上，类似地做即可。

```cpp
#include<bits/stdc++.h>

using namespace std;

namespace Fread {
	const int SIZE=1<<21;char buf[SIZE],*S,*T;
	inline char getchar() {if(S==T){T=(S=buf)+fread(buf,1,SIZE,stdin);if(S==T)return '\n';}return *S++;}
}
namespace Fwrite {
	const int SIZE=1<<21;
	char buf[SIZE],*S=buf,*T=buf+SIZE;
	inline void flush(){fwrite(buf,1,S-buf,stdout);S=buf;}
	inline void putchar(char c){*S++=c;if(S==T)flush();}
	struct POPOSSIBLE{~POPOSSIBLE(){flush();}}ztr;
}
#define getchar Fread :: getchar
#define putchar Fwrite :: putchar
namespace Fastio{
	struct Reader{
	    template<typename T>
    	Reader& operator >> (T& x) {
        	char c=getchar();T f=1;
        	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}x=0;
        	while(c>='0'&&c<='9'){x=x*10+(c-'0');c=getchar();}x*=f;
	        return *this;
    	}
	    Reader(){}
	}cin;
	struct Writer{
	    template<typename T>
	    Writer& operator << (T x) {
	        if(x==0){putchar('0');return *this;}
	        if(x<0){putchar('-');x=-x;}
	        static int sta[45];int top=0;
	        while(x){sta[++top]=x%10;x/=10;}
	        while(top){putchar(sta[top]+'0');--top;}
	        return *this;
    	}
    	Writer& operator << (char c) {putchar(c);return *this;}
    	Writer(){}
	}cout;
}
#define fi first
#define endl '\n'
#define sec second
#define mk make_pair
#define cin Fastio :: cin
#define cout Fastio :: cout
typedef pair<int,int> pii;

const int B=20;
const int N=1e6+10;
int n,m,opt[N],c[N];
struct TreeArray{
	int tr[N];inline int lowbit(const int &x){return x&(-x);}
	inline void add(int i,int x){for(;i<=n;i+=lowbit(i)) tr[i]+=x;}
	inline int ask(int i){int res=0;for(;i;i-=lowbit(i)) res+=tr[i];return res;}
	inline int ask(int l,int r){return ask(r)-ask(l-1);}
}t;
int rev[N],f[N][B+1],dep[N],id[N],idx,ans[N],siz[N],son[N],top[N],father[N];
vector < int > v[N],g[N],d[N];
vector < pii > p[N],Q[N];

inline void push(int x,int y,int z){//dfn[s]>=x,dfn[y]>=y,res+=z
	if(x&&y&&x<=n&&y<=n) p[y].emplace_back(x,z);
}
inline void push(int xl,int xr,int yl,int yr){
	if(xl>xr||yl>yr) return ;
	push(xl,yl,1);push(xr+1,yl,-1);push(xl,yr+1,-1);push(xr+1,yr+1,1);
}
void dfs(int x,int y){
	dep[x]=dep[father[x]=f[x][0]=y]+1;id[x]=++idx;siz[x]=1;
	for(int i=1;i<=B;++i) f[x][i]=f[f[x][i-1]][i-1];
	for(int i:v[x]) if(i!=y){dfs(i,x),siz[x]+=siz[i];(siz[son[x]]<siz[i])&&(son[x]=i);}
} 
void dfs2(int x,int topf){
	top[x]=topf;if(son[x]) dfs2(son[x],topf);
	for(int i:v[x]) if(!top[i]) dfs2(i,i);
}
inline void Add(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	int now=x;
	for(int i=B;~i;--i) if(dep[f[now][i]]>dep[y]) now=f[now][i];
	if(f[now][0]!=y){
		if(opt[x]==1) push(id[x],id[x]+siz[x]-1,id[y],id[y]+siz[y]-1);
		else push(id[y],id[y]+siz[y]-1,id[x],id[x]+siz[x]-1);
	}else {
		if(opt[x]==1){
			push(id[x],id[x]+siz[x]-1,1,id[now]-1);
			push(id[x],id[x]+siz[x]-1,id[now]+siz[now],n);
		}else {
			push(1,id[now]-1,id[x],id[x]+siz[x]-1);
			push(id[now]+siz[now],n,id[x],id[x]+siz[x]-1);
		}
	}
}
inline int LCA(int x,int y){
	while(top[x]!=top[y]) dep[top[x]]>dep[top[y]]?x=father[top[x]]:y=father[top[y]];
	return dep[x]<dep[y]?x:y;
}
void dfs(int x,int y,int st,int val){
	if(c[x]==c[st]&&x!=st){
		if(opt[x]==1) ++val;
		else if(val) --val;
		else return Add(st,x);
	}
	for(auto i:g[x]) if(i!=y) dfs(i,x,st,val);
}
inline void addedge(int x,int y){g[x].emplace_back(y);g[y].emplace_back(x);}
inline void build(vector<int>& d,int ix){
	sort(d.begin(),d.end(),[](const int x,const int y){return id[x]<id[y];});
	int len=d.size();for(int i=1;i<len;++i) d.emplace_back(LCA(d[i],d[i-1]));
	sort(d.begin(),d.end(),[](const int x,const int y){return id[x]<id[y];});
	d.erase(unique(d.begin(),d.end()),d.end());len=d.size();
	for(int i=1;i<len;++i) addedge(LCA(d[i],d[i-1]),d[i]);
	for(auto x:d) if(opt[x]==1&&c[x]==ix) dfs(x,0,x,0);
	for(auto x:d) g[x].clear();
}
void Solve(){
	dfs(1,0);dfs2(1,1);
	for(int i=1;i<=n;++i) d[c[i]].emplace_back(i);
	for(int i=1;i<=n;++i) build(d[i],i);
	for(int i=1,s,t;i<=m;++i){
		cin>>s>>t;Q[id[t]].emplace_back(id[s],i);
	}
	for(int i=1;i<=n;++i){
		for(auto x:p[i]) t.add(x.fi,x.sec);
		for(auto x:Q[i]) ans[x.sec]=t.ask(x.fi);
	}
	for(int i=1;i<=m;++i) cout<<ans[i]<<'\n';
}

int main(){
	cin>>n>>m;for(int i=1;i<=n;++i) cin>>opt[i]>>c[i];
	for(int i=1,x,y;i<n;++i){cin>>x>>y;v[x].emplace_back(y);v[y].emplace_back(x);}
	Solve();
	return 0;
} 
```

---

## 作者：XZhuRen (赞：0)

**虚树**和**二维数点**板子。

每个钥匙不超过 $5$ 个是个
好性质。

考虑可以对每种颜色统计答案，有用的点个数不超过 $5n$，考虑虚树，有用点不超过 $10n$。

但是颜色数没有上限，且一次询问不止一个答案，没办法像 [P5526](https://www.luogu.com.cn/problem/P5526) 一样，直接枚举颜色统计。

贡献独立，考虑一次贡献对哪些询问有用，容易发现：虚树上钥匙和点在一条路径上呈括号式配对，所以每个钥匙开始在虚树上 DFS，然后遇到匹配的宝箱就有一个贡献了。

由于这限定了 $u,v$ 各自范围在哪里，所以考虑二维数点，树状数组扫一遍。

代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll1;
#define mkp make_pair
template<typename T>
void in(T &n){
	n=0;char c=getchar();bool flag=0;
	for(;c<'0'||c>'9';c=getchar()) if (c=='-') flag=1;
	for(;c>='0'&&c<='9';c=getchar()) (n*=10)+=(c^48);
	if (flag) n=-n;
}
const int N=5e6+5;
struct Gra{
	struct edge{
		int u,v,nxt;
	}g[N*2];
	int head[N]={0},tote=0;
	void ae(int u,int v){
		g[++tote]=(edge){u,v,head[u]};
		head[u]=tote;
	}
}g,gt;
int dfn[N],mxd[N],tdfn=0;
int d[N],fa[N];
int dfns[20][N];
int n,q;
void dfs(int u,int Fa,int dep){
	fa[u]=Fa;d[u]=dep;dfn[u]=++tdfn;
	dfns[0][tdfn]=u;
	for(int e=g.head[u],v;e;e=g.g[e].nxt){
		v=g.g[e].v;if(v==Fa)continue;
		dfs(v,u,dep+1);
	}
	mxd[u]=tdfn;
}
int tp[N];
int C[N];
int cmpr(int x,int y){return (d[x]==d[y]?dfn[x]>dfn[y]:d[x]<d[y])?x:y;}
vector<pair<int,int> >stt;
vector<int>cp[N];
struct Point{
	int x,y,id;
	bool operator <(const Point &o)const{return y<o.y;}
}ask[N];
struct Seg{
	int y,l,r,op;
	bool operator <(const Seg&o)const{
		return y<o.y;
	}
}sg[N];
int tots=0;
void init(){
	int u,v;
	in(n),in(q);
	for(int i=1;i<=n;i++){
		in(tp[i]),in(C[i]);
		cp[C[i]].push_back(i);
	}
	for(int i=1;i<n;i++){
		in(u),in(v);
		g.ae(u,v);
		g.ae(v,u);
	}
	dfs(1,0,0);
	for(int len=2,k=1;len<=n;k++,len<<=1)
	for(int i=1;i+len-1<=n;i++)
	dfns[k][i]=cmpr(dfns[k-1][i],dfns[k-1][i+len/2]);
	for(int i=1;i<=q;i++){
		in(u),in(v);
		ask[i].x=dfn[u],ask[i].y=dfn[v];
		ask[i].id=i;
	}
}
int Lca(int u,int v){
	if(u==v)return u;
	int l=dfn[u],r=dfn[v];
	if(l>r)swap(l,r);
	l++;int k=log2(r-l+1),len=1<<k;
	return fa[cmpr(dfns[k][l],dfns[k][r-len+1])];
}
int upto(int u,int v){
	if(u==v)return u;
	int l=dfn[u],r=dfn[v];
	if(l>r)swap(l,r);
	l++;int k=log2(r-l+1),len=1<<k;
	return cmpr(dfns[k][l],dfns[k][r-len+1]);//找dfn最靠近v的深度最小，相当于找u到v的下一个
}
int totv=0;
int pnt[N];
bool Cmp(int x,int y){return dfn[x]<dfn[y];}
void build_tree(){
	sort(pnt+1,pnt+1+totv,Cmp);
	int tv=totv;
	for(int i=2;i<=tv;i++)
		pnt[++totv]=Lca(pnt[i-1],pnt[i]);
	sort(pnt+1,pnt+1+totv,Cmp);
	totv=unique(pnt+1,pnt+1+totv)-pnt-1;
	gt.tote=0;
	for(int i=1;i<=totv;i++)gt.head[pnt[i]]=0;
	for(int i=2;i<=totv;i++)
		gt.ae(Lca(pnt[i-1],pnt[i]),pnt[i]),
		gt.ae(pnt[i],Lca(pnt[i-1],pnt[i]));
}
void Add(int u,int v){
	int lca=Lca(u,v);
	if(lca==u){//从上到下
		int tu=upto(u,v);
		sg[++tots]=(Seg){dfn[v],1,n,1};
		sg[++tots]=(Seg){mxd[v]+1,1,n,-1};
		sg[++tots]=(Seg){dfn[v],dfn[tu],mxd[tu],-1};
		sg[++tots]=(Seg){mxd[v]+1,dfn[tu],mxd[tu],1};
	}else if(lca==v){//从下到上
		int tv=upto(u,v);
		sg[++tots]=(Seg){1,dfn[u],mxd[u],1};
		sg[++tots]=(Seg){dfn[tv],dfn[u],mxd[u],-1};
		sg[++tots]=(Seg){mxd[tv]+1,dfn[u],mxd[u],1};
	}else{//各自子树
		sg[++tots]=(Seg){dfn[v],dfn[u],mxd[u],1};
		sg[++tots]=(Seg){mxd[v]+1,dfn[u],mxd[u],-1};
	}
}
void solve(int u,int Fa,int now,int c,int Stt){
	if(C[u]==c)now+=tp[u]==1?1:-1;
	if(now<0)return;
	if(now==0){Add(Stt,u);return;}
	for(int e=gt.head[u],v;e;e=gt.g[e].nxt){
		v=gt.g[e].v;if(v==Fa)continue;
		solve(v,u,now,c,Stt);
	}
}
int Ans[N];
int ys[N];
int toty=0;
#define lowbit(x) (x&-x)
int bit[N];
void Adt(int x,int y){for(;x<=n;x+=lowbit(x))bit[x]+=y;}
int Qry(int x){int res=0;for(;x>0;x-=lowbit(x))res+=bit[x];return res;}
void Add(int l,int r,int x){Adt(l,x),Adt(r+1,-x);}
void work(){
	for(int c=1;c<=n;c++){
		totv=0;
		for(auto u:cp[c])pnt[++totv]=u;
		build_tree();
		for(auto u:cp[c])if(tp[u]==1)solve(u,0,0,c,u);
	}
	sort(ask+1,ask+1+q);
	sort(sg+1,sg+1+tots);
	for(int i=1;i<=tots;i++)ys[++toty]=sg[i].y;
	for(int i=1;i<=q;i++)ys[++toty]=ask[i].y;
	sort(ys+1,ys+1+toty);
	toty=unique(ys+1,ys+1+toty)-ys-1;
	int ps=1,pa=1;
	for(int i=1;i<=toty;i++){
		int y=ys[i];
		while(ps<=tots&&sg[ps].y<=y){Add(sg[ps].l,sg[ps].r,sg[ps].op);ps++;}
		while(pa<=q&&ask[pa].y<=y){Ans[ask[pa].id]=Qry(ask[pa].x);pa++;}
	}
	for(int i=1;i<=q;i++)printf("%d\n",Ans[i]);
}
int main(){
	init();work();
	return 0;
}
```

---

## 作者：Fzrcy (赞：0)

对于每个宝箱，我们采用贪心策略：若存在钥匙可以打开宝箱，则我们一定用钥匙打开它，若有多个钥匙，则用最近拿到的钥匙打开宝箱，这样做显然不劣。

对于一个钥匙 $x$，其在贪心策略下和宝箱的匹配方式只和到达 $x$ 后行走的路线有关，所有我们预处理出所有的**有序**二元组 $(x,y)$，表示若路径 $s\to t$ 包含路径 $x\to y$，则 $(x,y)$ 一定会对 $s\to t$ 产生贡献。

具体地，我们从钥匙 $x$ 处 dfs，若遇到颜色相同的宝箱则打开、遇到颜色相同的钥匙则收起来，若在到达颜色相同的宝箱 $y$ 时钥匙 $x$ 被使用，则我们找到了一个有序二元组 $(x,y)$。显然我们遇到颜色相同的宝箱或钥匙时才会操作，所以我们对所有颜色相同的宝箱和钥匙建立虚树，在虚树上 dfs，因为同一种的钥匙最多只有 $5$ 把，所以暴力 dfs 预处理有序二元组的复杂度是正确的。

然后考虑有序二元组 $(x,y)$ 对询问 $s\to t$ 的贡献，我们把问题放在二维平面上，点 $(s,t)$ 的权值表示路径 $s\to t$ 的答案，则有序二元组 $(x,y)$ 对路径 $s\to t$ 的贡献可以看成矩阵加一，把询问离线，扫描线加树状数组维护即可。

总时间复杂度为 $O(n\log n)$。

```cpp
// qwq
#include <bits/stdc++.h>
#define gc getchar()
using namespace std;
inline int in(){
	char c; int x=0,bo=0;
	while(!isdigit(c=gc))if(c=='-')bo=1;
	while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=gc;
	return bo?-x:x;
}
inline void wr(int x){
	if(x>=10)wr(x/10);
	putchar(x%10+'0');
}
constexpr int N=1e6+9;
struct Node{int a,b,c;};
int n,m,dep[N],dfn[N],dft,ans[N];
int ti[N],ci[N],sz[N];
vector<int>e[N],arr[N];
vector<Node>A[N];
vector<pair<int,int>>qt[N];

void Mat(int x,int y,int ox,int oy){
	//cout<<x<<' '<<y<<' '<<ox<<' '<<oy<<'\n';
	A[x].push_back({ox,oy,1});
	A[y+1].push_back({ox,oy,-1});
}

struct Tree1{
	int st[N][21];
	void dfs(int u,int fa){
		st[u][0]=fa,sz[u]=1,dep[u]=dep[fa]+1,dfn[u]=++dft;
		for(int i=1;i<20;i++)st[u][i]=st[st[u][i-1]][i-1];
		for(int v:e[u])if(v^fa)dfs(v,u),sz[u]+=sz[v];
	}
	int lca(int x,int y){
		if(dep[x]<=dep[y])swap(x,y);
		for(int i=19;~i;i--)
			if(dep[st[x][i]]>=dep[y])
				x=st[x][i];
		if(x==y)return x;
		for(int i=19;~i;i--)
			if(st[x][i]^st[y][i])
				x=st[x][i],y=st[y][i];
		return st[x][0];
	}
	int jp(int x,int to){
		for(int i=19;~i;i--)
			if(dep[st[x][i]]>dep[to])
				x=st[x][i];
		return x;
	}
}Tr1;

bool In(int x,int y){
	return dfn[y]>=dfn[x]&&dfn[y]<=dfn[x]+sz[x]-1;
}
void chn(int x,int y){
	//cout<<x<<"->"<<y<<'\n';
	if(In(x,y)){
		int t=Tr1.jp(y,x);
		if(dfn[t]+sz[t]<=n)Mat(dfn[t]+sz[t],n,dfn[y],dfn[y]+sz[y]-1);
		if(dfn[t]>1)Mat(1,dfn[t]-1,dfn[y],dfn[y]+sz[y]-1);
		return;
	}
	if(In(y,x)){
		int t=Tr1.jp(x,y);
		if(dfn[t]+sz[t]<=n)Mat(dfn[x],dfn[x]+sz[x]-1,dfn[t]+sz[t],n);
		if(dfn[t]>1)Mat(dfn[x],dfn[x]+sz[x]-1,1,dfn[t]-1);
		return;
	}
	Mat(dfn[x],dfn[x]+sz[x]-1,dfn[y],dfn[y]+sz[y]-1);
}

struct Tree2{
	vector<int>g[N];
	int st[N],top;
	void Add(int x,int y){
		g[x].push_back(y),g[y].push_back(x);
	}
	void cls(int x,int fa){
		for(int v:g[x])if(v!=fa)cls(v,x);
		g[x].clear();
	}
	void ins(int x){
		if(!top){st[++top]=x;return;}
		int t=Tr1.lca(x,st[top]);
		if(t==st[top]){st[++top]=x;return;}
		int tmp=top;
		while(top&&dfn[st[top]]>dfn[t])top--;
		for(int i=top+1;i<tmp;i++)
			Add(st[i],st[i+1]);
		if(st[top]==t){
			Add(st[top],st[top+1]);
			st[++top]=x;
		}
		else{
			Add(t,st[top+1]);
			st[++top]=t,st[++top]=x;
		}
	}
	void dp(int u,int fa,int c,int st){
		if(ci[u]==ci[st])c+=(ti[u]==1?1:-1);
		if(!c)return chn(st,u);
		for(int v:g[u])if(v!=fa)dp(v,u,c,st);
	}
	void init(vector<int>&ar){
		sort(ar.begin(),ar.end(),[=](int x,int y){
			return dfn[x]<dfn[y];
		});
		top=0; for(int i:ar)ins(i); int RT=st[1];
		//puts("/*******************************************/");
		//puts("ok");
		while(top>1)Add(st[top-1],st[top]),top--;
		for(auto i:ar)if(ti[i]==1)dp(i,0,0,i);
		//puts("finish");
		//cout<<RT<<' '<<ar[0]<<'\n';
		cls(ar[0],0); top=0;
	}
}Tr2;

struct Tree{
	int c[N];
	void Add(int x,int v){
		for(;x<=n;x+=x&-x)
			c[x]+=v;
	}
	void Add(int x,int y,int z){
		Add(x,z),Add(y+1,-z);
	}
	int Q(int x){
		int res=0;
		for(;x;x-=x&-x)
			res+=c[x];
		return res;
	}
}Tr;

int main(){
	//freopen("a.in","r",stdin);
	//freopen("a.out","w",stdout);
	n=in(),m=in();
	for(int i=1;i<=n;i++)
		ti[i]=in(),ci[i]=in(),
		arr[ci[i]].push_back(i);
	for(int i=1,x,y;i<n;i++)
		e[x=in()].push_back(y=in()),
		e[y].push_back(x);
	Tr1.dfs(1,0);
	for(int i=1,x,y;i<=m;i++)cin>>x>>y,
		qt[dfn[x]].push_back({i,dfn[y]});
		//cout<<"? "<<dfn[x]<<' '<<dfn[y]<<'\n';
	//puts("ok");
	for(int i=1;i<=n;i++)
		if(arr[i].size()>1ull)
			Tr2.init(arr[i]);
	//puts("ok");
	for(int i=1;i<=n;i++){
		for(auto j:A[i]) Tr.Add(j.a,j.b,j.c);
		for(auto j:qt[i]){
			ans[j.first]=Tr.Q(j.second);
			//cout<<i<<' '<<j.second<<' '<<ans[j.first]<<'\n';
		}
	}
	for(int i=1;i<=m;i++)
		wr(ans[i]),putchar('\n');
	return 0;
}
```



---


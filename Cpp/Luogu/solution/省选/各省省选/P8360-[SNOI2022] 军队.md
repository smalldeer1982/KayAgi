# [SNOI2022] 军队

## 题目描述

R 国的历史非常悠久。

R 国有 $n$ 个城市，国内有 $C$ 个党派，分别记为 $1,2,\dots,C$。由于 R 国的版图非常长，这 $n$ 个城市的位置可以近似为坐标轴上的 $n$ 个点。在历史的最初，记载了第 $i$ 个城市归属党派 $c_i$，城中有数量为 $a_i$ 的军队。

R 国的历史上，经常发生以下三种事件：

1. 党派 $y$ 进行了一次游说，使城市 $l$ 到城市 $r$ 的所有归属党派 $x$ 的城市全部归属了 $y$。

2. 党派 $x$ 进行了一次征兵，使城市 $l$ 到城市 $r$ 的所有归属党派 $x$ 的城市中的军队数量增加了 $v$。

3. 城市 $l$ 到城市 $r$ 之间的所有城市爆发了战争。这场战争的规模可以描述为两地之间的所有城市中的军队数量之和。注意战争不一定发生在不同党派之间，归属同一个党派的一些城市内部也可能发生内战。由于 R 国的医护系统足够先进，战争不会造成军队数量的减少。

小 N 是一个喜欢历史的女孩子，最近她想整理一下 R 国的战争史，特别是每场战争的规模。但是由于 R 国的历史实在太长了，她用纸和笔进行运算实在力不从心。于是她找到了你，希望你写一个程序，统计出 R 国历史上所有战争的规模。

## 说明/提示

**【样例 1 解释】**

最初，五个城市的军队数量分别为 $1, 2, 4, 8, 16$，归属的党派分别为 $1, 2, 3, 2, 3$。

发生的事件依次为：
- 党派 $2$ 尝试在城市 $2, 3, 4$ 征兵，归属党派 $2$ 的城市 $2, 4$ 各增加了 $32$ 军队。
- 城市 $1$ 和 $4$ 之间的所有城市爆发了战争，规模为 $1 + 34 + 4 + 40 = 79$。
- 党派 $1$ 在城市 $1, 2, 3, 4, 5$ 进行了一次游说，使得原本归属党派 $3$ 的城市 $3, 5$ 归属了党派 $1$。
- 党派 $1$ 尝试在城市 $2, 3, 4, 5$ 征兵，归属党派 $1$ 的城市 $3, 5$ 各增加了 $64$ 军队。
- 城市 $2$ 和 $4$ 之间的所有城市爆发了战争，规模为 $34 + 68 + 40 = 142$。
- 党派 $3$ 尝试在城市 $1, 2, 3$ 征兵，但是党派 $3$ 现在不拥有任何城市，因此并没有成功征兵。
- 城市 $3$ 和 $5$ 之间的所有城市爆发了战争，规模为 $68 + 40 + 80 = 188$。

因此你的程序应该依次输出 $79, 142, 188$。

**【数据规模与约定】**

对于全部数据，$1 \leq n, q\leq 2.5 \times 10^5$，$1 \leq a_i, v \leq 10^8$，$1 \leq c_i, x, y \leq C$。

具体的数据规模与约定见下表。

| 测试点编号 |    $n,q\leq $     |     $C\leq $      |               特殊约定               |
| :--------: | :---------------: | :---------------: | :----------------------------------: |
|    $1$     |       $20$        |       $20$        |                                      |
|    $2$     |       $50$        |       $50$        |                                      |
|    $3$     |       $300$       |       $300$       |                                      |
|    $4$     |      $5000$       |      $5000$       |                                      |
|    $5$     |      $10^5$       |       $10$        |                                      |
|    $6$     | $1.5 \times 10^5$ |       $10$        |                                      |
|    $7$     |  $2 \times 10^5$  |       $10$        |                                      |
|    $8$     | $2.5 \times 10^5$ |       $10$        |                                      |
|    $9$     | $1.5 \times 10^5$ | $1.5 \times 10^5$ |    对于所有操作，保证 $l=1,r=n$。    |
|    $10$    | $2.5 \times 10^5$ | $2.5 \times 10^5$ |    对于所有操作，保证 $l=1,r=n$。    |
|    $11$    | $1.5 \times 10^5$ | $1.5 \times 10^5$ | 对于所有操作 $1,2$，保证 $l=1,r=n$。 |
|    $12$    |  $2 \times 10^5$  |  $2 \times 10^5$  | 对于所有操作 $1,2$，保证 $l=1,r=n$。 |
|    $13$    | $2.5 \times 10^5$ | $2.5 \times 10^5$ | 对于所有操作 $1,2$，保证 $l=1,r=n$。 |
|    $14$    | $1.5 \times 10^5$ | $1.5 \times 10^5$ |         保证不存在操作 $1$。         |
|    $15$    | $2.5 \times 10^5$ | $2.5 \times 10^5$ |         保证不存在操作 $1$。         |
|    $16$    |      $10^5$       |      $10^5$       |                                      |
|    $17$    | $1.5 \times 10^5$ | $1.5 \times 10^5$ |                                      |
|    $18$    |  $2 \times 10^5$  |  $2\times 10^5$   |                                      |
|    $19$    | $2.5 \times 10^5$ | $2.5 \times 10^5$ |                                      |
|    $20$    | $2.5 \times 10^5$ | $2.5 \times 10^5$ |                                      |

## 样例 #1

### 输入

```
5 7 3
1 2 4 8 16
1 2 3 2 3
2 2 4 2 32
3 1 4
1 1 5 3 1
2 2 5 1 64
3 2 4
2 1 3 3 128
3 3 5
```

### 输出

```
79
142
188
```

## 样例 #2

### 输入

```
样例 2 见附件 military2.in
本组数据满足测试点 4 的限制。```

### 输出

```
样例 2 见附件 military2.ans```

## 样例 #3

### 输入

```
样例 3 见附件 military3.in
本组数据满足测试点 14 的限制。```

### 输出

```
样例 3 见附件 military3.ans```

## 样例 #4

### 输入

```
样例 4 见附件 military4.in
本组数据满足测试点 18 的限制。```

### 输出

```
样例 4 见附件 military4.ans```

# 题解

## 作者：gxy001 (赞：15)

看到这题首先考虑分块，考虑如何维护这些操作。

先考虑整块操作如何处理，考虑对每块维护出一个多叉森林结构，叶子节点既是每个位置，初始时同种颜色的位置拥有同一个父节点。

合并两种颜色时，如果一种颜色原本不存在于该块内，则不用新建节点；否则新建一个节点，并将这两种颜色节点的父亲设置为新建的节点，这个新节点就代表合并后的颜色。这样维护出的森林，每个非叶子节点都有至少 $2$ 个儿子，节点个数不会超过二倍的叶子节点数。

加 $v$ 的时候只要在对应颜色的节点上打标记就好，顺便根据这个颜色的数量维护整块的答案。

对于散块，我们可以直接暴力下放标记，然后暴力维护操作，统计答案，重构森林。

时间复杂度 $O(n+q(B+\frac nB))=O(n+q\sqrt n)$。

```cpp
#include<fstream>
#include<algorithm>
std::ifstream cin("military.in");
std::ofstream cout("military.out");
int const B=500;
int n,q,m,a[250010],c[250010],op[250010],ql[250010],qr[250010],qx[250010],qy[250010];
int fa[250010],f[1010],sz[1010],col[1010];
long long v[1010],sum,ans[250010];
int main(){
	cin>>n>>q>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>c[i];
	for(int i=1;i<=q;i++){
		cin>>op[i]>>ql[i]>>qr[i];
		if(op[i]!=3) cin>>qx[i]>>qy[i];
	}
	int cnt=0;
	for(int l=1,r;l<=n;l=r+1){
		r=std::min(n,l+B-1);
		for(int i=1;i<=m;i++) fa[i]=0;
		for(int i=l;i<=r;i++) v[i-l+1]=a[i],col[i-l+1]=c[i];
		sum=0;
		int len=r-l+1;
		for(int i=len+1;i<=cnt;i++) f[i]=v[i]=0;
		cnt=len;
		for(int i=1;i<=len;i++) f[i]=0,sum+=v[i],sz[i]=1;
		for(int i=1;i<=len;i++) if(!fa[col[i]]) fa[col[i]]=i;
		else{
			int u=fa[col[i]];
			if(u<=len) f[u]=fa[col[i]]=++cnt,u=f[u],sz[u]=1,col[u]=col[i];
			f[i]=u,++sz[u];
		}
		for(int i=1;i<=q;i++)
			if(ql[i]<=l&&r<=qr[i]){
				if(op[i]==1){
					if(qx[i]==qy[i]||!fa[qx[i]]);
					else if(!fa[qy[i]]){
						col[fa[qy[i]]=fa[qx[i]]]=qy[i];
						fa[qx[i]]=0;
					}else{
						int u=++cnt;
						f[fa[qy[i]]]=f[fa[qx[i]]]=u,col[u]=qy[i];
						sz[u]=sz[fa[qy[i]]]+sz[fa[qx[i]]];
						fa[qy[i]]=u,fa[qx[i]]=0;
					}
				}else if(op[i]==2){
					if(fa[qx[i]]) v[fa[qx[i]]]+=qy[i],sum+=1ll*sz[fa[qx[i]]]*qy[i];
				}else{
					ans[i]+=sum;
				}
			}else if(std::max(ql[i],l)<=std::min(qr[i],r)){
				for(int j=cnt;j;j--) if(f[j]) v[j]+=v[f[j]],col[j]=col[f[j]];
				for(int j=len+1;j<=cnt;j++) f[j]=v[j]=0;
				cnt=len;
				for(int j=1;j<=len;j++) fa[col[j]]=0,f[j]=0;
				int pl=std::max(ql[i],l)-l+1,pr=std::min(qr[i],r)-l+1;
				if(op[i]==1){
					for(int o=pl;o<=pr;o++) if(col[o]==qx[i]) col[o]=qy[i];
				}else if(op[i]==2){
					for(int o=pl;o<=pr;o++) if(col[o]==qx[i]) v[o]+=qy[i],sum+=qy[i];
				}else{
					for(int o=pl;o<=pr;o++) ans[i]+=v[o];
				}
				for(int j=1;j<=len;j++) if(!fa[col[j]]) fa[col[j]]=j;
				else{
					int u=fa[col[j]];
					if(u<=len) f[u]=fa[col[j]]=++cnt,u=f[u],sz[u]=1,col[u]=col[j];
					f[j]=u,++sz[u];
				}
			}
	}
	for(int i=1;i<=q;i++) if(op[i]==3) cout<<ans[i]<<'\n';
	return 0;
}

```



---

## 作者：EnofTaiPeople (赞：14)

### Part1 前言

序列分块与并查集结合已经是平凡的做法了。

这道题放在省选里就是签到题。

如果不会一定不是能力不行，因为只要学过就会。

前置知识是[第二分块](/problem/P4117)，当然这只是因为我是学完第二分块之后过了很久才做这道题，这道题比第二分块简单很多。

为什么这种题我要写题解？

因为有同学被数据范围误导了，还需要卡空间常数？

这道题 $50$ 倍空间（$\dfrac{1G}{18M}\approx56$）都给你了还要卡空间常数，就算卡过了我把空间开到 $64M$ 你就没了。

当然不排除这道题的空间限制本身具有误导性。

### Part2 两种解法的比较

首先是进行序列分块，每一个块维护颜色。

每一种颜色记录一个 $fr_c$ 表示该颜色在块内的第一次出现，其余的每一次出现都可以将父亲置为他，于是可以用并查集路径压缩快速的找到根。

记录 $tg_c$ 表示某种颜色的整体标记，$sz_c$ 表示颜色为 $c$ 的个数。

对于操作 $1$，在所有整块中：

1. $fr_x=0$，这种情况直接退出，没有修改的位置；
2. $fr_y=0$，则交换 $x,y$ 的 $ft,sz,tg$，因为 $y$ 的全为 $0$，同时 $c_{fr_x}=y$，因为求颜色求的是 `gf(x)` 的颜色；
3. $fr_x,fr_y\ne0$，则块内颜色数会减少 $1$，这时直接暴力重构整块。

考虑一种不同的颜色代表 $\sqrt n$ 块钱，初始赋给每个块不超过 $n$ 块钱，整块减少颜色就取了 $\sqrt n$ 块钱，散块修改可能会增加 $1$ 种颜色，就给他 $\sqrt n$ 块钱，总共最多会给 $(n+q)\sqrt n$ 块钱，即时间复杂度为 $O((n+q+C)\sqrt n)$。

如果每一个块同时维护这些数组，那么空间复杂度为 $(n+C)\sqrt n$，支持在线，但显然对于一个不强制在线的题目这么做平白增大空间开销是没必要的。

发现这道题查询具有可加性，所以只要对于每一个块，扫描每一个查询，算出这个块的答案，再加起来即可，时间复杂度 $O((n+q+C)\sqrt n)$，空间 $O(n+q+C)$。

注意本题的并查集只会在重构时全体 `gf`，所以并不存在 $\alpha(n)$。

### Part3 后记

不要寄希望于省选时出这种模板套路题，但真的出了不会是致命的。

代码如下：
```cpp
int n,m,C,f[N],c[N],fr[N],kk,L,R,sz[N];
struct Q{int op,l,r,x,y;}q[N];
ul a[N],ans[N],sm,tg[N];
int gf(int x){return x==f[x]?x:f[x]=gf(f[x]);}
int main(){
    read(n,m,C),kk=1+sqrt(1+n);
    int i,x,y,l,r,X,Y;
    for(x=1;x<=n;++x)read(a[x]);
    for(x=1;x<=n;++x)read(c[x]);
    for(i=1;i<=m;++i){
        read(q[i].op,q[i].l,q[i].r);
        if(q[i].op<3)read(q[i].x,q[i].y);
    }
    for(L=1;L<=n;L=R+1){
        R=min(L+kk,n),sm=0;
        for(x=1;x<=C;++x)fr[x]=tg[x]=sz[x]=0;
        for(x=L;x<=R;++x){
            f[x]=fr[c[x]]?fr[c[x]]:(fr[c[x]]=x);
            sm+=a[x],++sz[c[x]];
        }
        for(i=1;i<=m;++i){
            if(q[i].l>R||q[i].r<L)continue;
            l=max(q[i].l,L),r=min(q[i].r,R);
            X=q[i].x,Y=q[i].y;
            if(l==L&&r==R){
                if(q[i].op==1){
                    if(!fr[X])continue;
                    if(!fr[Y]){
                        c[fr[X]]=Y;
                        swap(fr[X],fr[Y]);
                        swap(tg[X],tg[Y]);
                        swap(sz[X],sz[Y]);
                        continue;
                    }sz[Y]+=sz[X],sz[X]=0;
                    for(x=L;x<=R;++x)c[x]=c[gf(x)];
                    for(x=L;x<=R;++x)
                        if(c[x]==X)
                            a[x]-=tg[Y]-tg[X],c[x]=Y;
                    f[fr[X]]=fr[Y],tg[X]=fr[X]=0;    
                }else if(q[i].op==2){
                    if(!sz[X])continue;
                    sm+=ul(Y)*sz[X];
                    tg[X]+=Y;
                }else ans[i]+=sm;
            }else{
                if(q[i].op==1){
                    for(x=L;x<=R;++x){
                        c[x]=c[gf(x)];
                        if(c[x]==X||c[x]==Y)
                            a[x]+=tg[c[x]];
                    }for(x=l;x<=r;++x)if(c[x]==X)c[x]=Y;
                    sz[X]=sz[Y]=fr[X]=fr[Y]=tg[X]=tg[Y]=0;
                    for(x=L;x<=R;++x)
                        if(c[x]==X||c[x]==Y){
                            f[x]=fr[c[x]]?fr[c[x]]:(fr[c[x]]=x);
                            ++sz[c[x]];
                        }
                }else if(q[i].op==2){
                    for(x=l;x<=r;++x)
                        if(c[gf(x)]==X)a[x]+=Y,sm+=Y;
                }else{
                    for(x=l;x<=r;++x)
                        ans[i]+=tg[c[gf(x)]]+a[x];
                }
            }
        }
    }
    for(i=1;i<=m;++i)if(q[i].op==3)write(ans[i]);
    return 0;
}
```

---

## 作者：冥麟 (赞：6)

# P8360 [SNOI2022] 军队

### [Link](https://www.luogu.com.cn/problem/P8360)

## 题意简述

> $ n $ 个点排成一行，每个点有权值 $ a_i $ 与颜色 $ c_i $ ，有 $ q $ 次操作，分为三种：
>
> 1. 将某一区间中颜色为 $ x $ 的点染成 $ y $ 。
> 2. 将某一区间中颜色为 $ x $ 的点的权值加上 $ y $ 。
> 3. 求区间权值和。
>
> $ n , q , c_i \leq 2.5 \times 10^5 \space \space 1\leq a_i , y \leq 10^8 $ 

## solution

看到这个**将某种颜色全部染成另一种颜色**时脑中闪过无数数据结构，一开始觉得平衡树应该能很好地解决这个问题，但是发现将 $ x $ 在区间 $ [l,r] $ 中的子树剖下来后，并不好与 $ y $ 合并，其他不少数据结构也是一样。

将大部分的思路假掉后，最终留下了的还是咱们的最强——**分块**。

对原序列分块后，比较显然的思路是用并查集维护每个点的颜色，我们只需要给一个块中的每一种颜色都开一个节点即可。

第一个操作用并查集很好搞，第二个操作可以直接在并查集的颜色节点上打懒标记，但是这会带来一些问题：

1. 懒标记下传。如果我们直接在查询的时候调用并查集根节点的懒标记，那么它曾经的祖先对他产生的贡献就木有了。

   比如 $ i $ 号节点的颜色原本是 $ x $ ，懒标记有 $ val $ 的贡献，但是 $ x $ 直接合并到 $ y $ 上了，后面 $ i $ 再查并查集查到的就是 $ y $ 了，而 $ x $ 还欠着它 $ val $ 。

   但是注意到此时 $ x $ 仍然在 $ i $ 到根节点的路径上，我们可以再查询并查集的时候直接一路贡献加上去，将图中经过的点的懒标记都加给自己。

   这样子的正确性在于路径压缩后 $ x $ 就不会是 $ i $ 的祖先了，不会重复造成贡献，注意这个操作中不能将并查集的根也考虑进来。

   但是还要注意一点：路径压缩后，整棵并查集的形态就变了，后面的节点再访问时，祖先序列已经发生改变，所以不光是非颜色节点要累加懒标记，颜色节点同样要将祖先中非根节点的懒标记加在自己身上。

   ![](https://cdn.luogu.com.cn/upload/image_hosting/u96ufehd.png)

   这样轮到这个未访问节点的时候贡献才是对的。

   考试时就因为这一点死活调不出来 $ \cdots $ 

2. 将两个颜色合并的时候，我本来想将 $ x $ 的父亲直接赋为 $ y $ ，但是显然这会出问题：懒标记表示并查集子树中每个非颜色节点的权值增加量，而 $ y $ 的懒标记并不能对原先在 $ x $ 子树中的节点产生贡献。

   ![](https://cdn.luogu.com.cn/upload/image_hosting/4smpayfl.png)

   解决方法是，我们新建一个节点 $ z $ ，将 $ x $ 和 $ y $ 的父亲赋为 $ z $ ，再以 $ z $ 来代表这个块的颜色 $ y $ ，这样 $ x $ 子树到根的路径上就不会有 $ y $ 。

3. 还有一点，我在考场上以为新建节点的个数是 $ O(n \sqrt{n} ) $ 的，因为每一次 $ 1 $ 操作好像都有可能增加 $ O(\sqrt{n}) $ 个节点。

   事实上，我们只有在散块修改和将整块中一种颜色合并到另一种存在的颜色上的时候才会新建节点，前者是 $ O(q) $ 的，后者是 $ O(n) $ 的(合并一次少一种颜色)。

   于是我们并不需要担心这里的空间问题。

这种写法比较坑的地方就讲完了，剩下的部分就是普通的分块，虽说带个并查集的 $ O(\log n) $ ，但是跑得贼快。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
namespace code{
	inline int read(){
		int a=0,b=1;char s=getchar();
		while(s<48||s>57){if(s=='-'){b=-1;}s=getchar();}
		while(s>=48&&s<=57)a=(a<<1)+(a<<3)+s-48,s=getchar();
		return a*b;
	}
	int n,q,C;
	#define R register
	const int maxn=2.5e5,B=500;
	long long a[maxn+5];int c[maxn+5];
	int bel[maxn+5],lc[maxn/B+5],rc[maxn/B+5],block;
	int id[maxn/B+5][maxn+5],num,fa[10*maxn+5],siz[10*maxn+5];
	long long sum[maxn/B+5],tag[10*maxn+5];
	int find(int x){//查询并查集时顺便下放懒标记
		if(fa[x]==x)return x;
		int a=find(fa[x]);
		if(fa[x]!=a)tag[x]+=tag[fa[x]];
		return fa[x]=a;
	}
	__int128 ans;//答案的值域似乎大得离谱
	void write(__int128 x){
		if(x<0)putchar('-'),x=~x+1;
		if(x>9)write(x/10);
		putchar(x%10+48);
	}
	inline void print(__int128 x,char c){write(x),putchar(c);}
	inline void main(){
		n=read(),q=read(),C=read();
		for(R int i=1;i<=n;i=-~i)a[i]=read();
		for(R int i=1;i<=n;i=-~i)c[i]=read();
		block=sqrt(n);
		for(R int i=1;i<=n;i=-~i)bel[i]=(i-1)/block+1;
		for(R int i=1,l=1,r;l<=n;i=-~i,l=r+1)r=min(l+block-1,n),lc[i]=l,rc[i]=r;
		num=n;
		for(R int i=1;i<=bel[n];i=-~i){
			for(R int j=lc[i];j<=rc[i];j=-~j)sum[i]+=a[j];
			for(R int j=lc[i];j<=rc[i];j=-~j){
				if(!id[i][c[j]])id[i][c[j]]=++num,fa[num]=num;
				fa[j]=id[i][c[j]],++siz[id[i][c[j]]];
			}
		}
		while(q--){
			int opt=read();
			switch(opt){
				case 1:{//合并颜色
					int l=read(),r=read(),x=read(),y=read();
					if(x==y)break;//这里主要是为了对拍方便，不知道数据里有没有这种情况
					if(bel[l]==bel[r]){
						if(!id[bel[l]][x]||fa[id[bel[l]][x]]!=id[bel[l]][x])break;
						++num,fa[num]=num;
						if(id[bel[l]][y]&&fa[id[bel[l]][y]]==id[bel[l]][y])
							fa[id[bel[l]][y]]=num,siz[num]+=siz[id[bel[l]][y]];//维护子树中颜色节点的个数，便于更新答案
						id[bel[l]][y]=num;
						for(R int i=l;i<=r;i=-~i){
							int f=find(i);a[i]+=tag[i],tag[i]=0;
							if(f==id[bel[i]][x])a[i]+=tag[f],fa[i]=num,++siz[num],--siz[f];
						}
					}
					else{//为什么不将这么多重复冗长的部分用函数代替呢。。。
						if(id[bel[l]][x]&&fa[id[bel[l]][x]]==id[bel[l]][x]){
							++num,fa[num]=num;
							if(id[bel[l]][y]&&fa[id[bel[l]][y]]==id[bel[l]][y])
								fa[id[bel[l]][y]]=num,siz[num]+=siz[id[bel[l]][y]];
							id[bel[l]][y]=num;
							for(R int i=l;i<=rc[bel[l]];i=-~i){
								int f=find(i);a[i]+=tag[i],tag[i]=0;
								if(f==id[bel[i]][x])a[i]+=tag[f],fa[i]=num,++siz[num],--siz[f];
							}
						}
						if(id[bel[r]][x]&&fa[id[bel[r]][x]]==id[bel[r]][x]){
							++num,fa[num]=num;
							if(id[bel[r]][y]&&fa[id[bel[r]][y]]==id[bel[r]][y])
								fa[id[bel[r]][y]]=num,siz[num]+=siz[id[bel[r]][y]];
							id[bel[r]][y]=num;
							for(R int i=lc[bel[r]];i<=r;i=-~i){
								int f=find(i);a[i]+=tag[i],tag[i]=0;
								if(f==id[bel[i]][x])a[i]+=tag[f],fa[i]=num,++siz[num],--siz[f];
							}
						}
						for(R int i=bel[l]+1;i<bel[r];i=-~i){
							if(!id[i][x]||fa[id[i][x]]!=id[i][x])continue;
							if(id[i][y]&&fa[id[i][y]]==id[i][y]){
								++num,fa[num]=num;
								fa[id[i][y]]=num,fa[id[i][x]]=num;
								siz[num]+=siz[id[i][y]],siz[num]+=siz[id[i][x]];
								id[i][y]=num;
							}
							else id[i][y]=id[i][x],id[i][x]=0;//如果y不存在，直接将x修改成y即可
						}
					}
					break;
				}
				case 2:{
					int l=read(),r=read(),x=read(),v=read();
					if(bel[l]==bel[r]){
						if(!id[bel[l]][x]||fa[id[bel[l]][x]]!=id[bel[l]][x])break;
						for(R int i=l;i<=r;i=-~i){
							int f=find(i);a[i]+=tag[i],tag[i]=0;
							if(f==id[bel[i]][x])a[i]+=v,sum[bel[i]]+=v;
						}
					}
					else{
						if(id[bel[l]][x]&&fa[id[bel[l]][x]]==id[bel[l]][x])
							for(R int i=l;i<=rc[bel[l]];i=-~i){
								int f=find(i);a[i]+=tag[i],tag[i]=0;
								if(f==id[bel[i]][x])a[i]+=v,sum[bel[i]]+=v;
							}
						if(id[bel[r]][x]&&fa[id[bel[r]][x]]==id[bel[r]][x])
							for(R int i=lc[bel[r]];i<=r;i=-~i){
								int f=find(i);a[i]+=tag[i],tag[i]=0;
								if(f==id[bel[i]][x])a[i]+=v,sum[bel[i]]+=v;
							}
						for(R int i=bel[l]+1;i<bel[r];i=-~i)
							if(id[i][x]&&fa[id[i][x]]==id[i][x])tag[id[i][x]]+=v,sum[i]+=1LL*siz[id[i][x]]*v;//这里我们直接将懒标记对整块的答案处理完了
					}
					break;
				}
				case 3:{
					int l=read(),r=read();ans=0;
					if(bel[l]==bel[r])
						for(R int i=l;i<=r;i=-~i){
							int f=find(i);a[i]+=tag[i],tag[i]=0;
							ans+=a[i]+tag[f];//前面只处理的懒标记对整块的贡献
						}
					else{
						for(R int i=l;i<=rc[bel[l]];i=-~i){
							int f=find(i);a[i]+=tag[i],tag[i]=0;
							ans+=a[i]+tag[f];
						}
						for(R int i=lc[bel[r]];i<=r;i=-~i){
							int f=find(i);a[i]+=tag[i],tag[i]=0;
							ans+=a[i]+tag[f];
						}
						for(R int i=bel[l]+1;i<bel[r];i=-~i)ans+=sum[i];
					}
					print(ans,'\n');
				}
			}
		}
	}
}
int main(){return code::main(),0;}
```



---

## 作者：bsTiat (赞：5)

## 思路

分块维护并查集


- 首先对于整块，每块内用并查集维护每种颜色的数量以及该种颜色的加法标记

- 对于整块的操作一，若 $ y $ 颜色存在，将 $ x $ 颜色的父亲设置为 $ y $ 颜色，$ x $ 颜色节点上的加法标记减去 $ y $ 颜色的加法标记；若 $ y $ 颜色之前不存在，则将 $ x $ 颜色直接变为 $ y $ 颜色，节点是不变的，只是更改了这个节点的颜色，这样就保证了复杂度。

- 对于零散块的操作一，直接暴力修改

- 对于整块的操作二，将颜色 $ x $ 的加法标记加上 $ v $ 

- 对于零散块的操作二，直接暴力修改

- 对于询问，维护每块内的权值和，询问时直接累加即可

- 对于重构，并查集跳原始颜色的父亲，跳的时候记得路径压缩，跳的时候还要再加上路径上的所有加法标记，返回的父亲就是新的颜色，累加的标记就是加上的值

- 注意，如果在整块操作中， $ y $ 颜色不存在的时候直接新建节点 $ y $ ，而不是修改颜色x所映射的颜色，其复杂度是错的

- 注意，零散块的操作，不需要重构，重构的话常数太大了只有75分

## 复杂度分析

每个块内最多只有 $ \sqrt{n} $ 个节点，所有操作均不会增加节点数量，只是修改节点的颜色或节点之间的关系，单次整块操作的复杂度是 $ O(1) $ ，单次零散块操作的复杂度是 $ O(\log\sqrt{n}) $ ，总时间复杂度为 $ O(m\sqrt{n}+m\sqrt{n}\log\sqrt{n}) $。

```cpp
#include<bits/stdc++.h>
# define fi first
# define se second
# define pii pair<int,ll>
# define mp(x,y) make_pair(x,y)
using namespace std;
const int N = 250005, M = 505;
typedef long long ll;
inline int rd(){
	int s=0;char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c<='9'&&c>='0'){s=(s<<3)+(s<<1)+(c^48);c=getchar();}
	return s;
}
ll sum[M],a[N];
struct node{int col,fa,size;ll tag;}t[N<<5];
int c[N],id[N],len,n,q,C,cnt,poi[N],L[M],R[M],rev[M][N];
pii find(int x){
	if(!t[x].fa) return mp(x,0);
	pii res=find(t[x].fa); res.se+=t[x].tag;
	t[x].fa=res.fi; t[x].tag=res.se;
	return res;
}
void build(int p){
	sum[p]=0;
	for(int i=L[p];i<=R[p];++i){
		sum[p]+=a[i];
		if(rev[p][c[i]]) {
			poi[i]=rev[p][c[i]];
			++t[poi[i]].size;
		}
		else {
			rev[p][c[i]]=++cnt;
			poi[i]=cnt;
			t[cnt].fa=t[cnt].tag=0;
			t[cnt].size=1; t[cnt].col=c[i];
		}
	}
}
signed main(){
	ll op,l,r,x,y; ll ans; pii res; 
	tin>>n>>q>>C; len=sqrt(n); 
	for(int i=1;i<=n;++i) tin>>a[i];
	for(int i=1;i<=n;++i) tin>>c[i],id[i]=(i-1)/len+1;
	for(int i=1;i<=id[n];++i) L[i]=(i-1)*len+1,R[i]=i*len; R[id[n]]=n;
	for(int i=1;i<=id[n];++i) build(i);
	while(q--){
		tin>>op>>l>>r; 
		if(op==1){
			tin>>x>>y;
			if(x==y)continue;
			if(id[l]==id[r]) {
				for(int i=l;i<=r;++i){
					res=find(poi[i]);
					if(t[res.fi].col!=x)continue;
					--t[res.fi].size;
					if(!t[res.fi].size)
						rev[id[l]][t[res.fi].col]=0;
					a[i]+=res.se+t[res.fi].tag;
					if(!rev[id[l]][y]){
						rev[id[l]][y]=++cnt;
						poi[i]=cnt;
						t[cnt].fa=t[cnt].tag=0;
						t[cnt].size=1; t[cnt].col=y;
					}else {
						poi[i]=rev[id[l]][y];
						a[i]-=t[rev[id[l]][y]].tag;
						++t[rev[id[l]][y]].size;
					}
				}
				continue;	
			}	
			for(int i=l;i<=R[id[l]];++i){
				res=find(poi[i]);
				if(t[res.fi].col!=x)continue;
				--t[res.fi].size;
				if(!t[res.fi].size)
					rev[id[l]][t[res.fi].col]=0;
				a[i]+=res.se+t[res.fi].tag;
				if(!rev[id[l]][y]){
					rev[id[l]][y]=++cnt;
					poi[i]=cnt;
					t[cnt].fa=t[cnt].tag=0;
					t[cnt].size=1; t[cnt].col=y;
				}else {
					poi[i]=rev[id[l]][y];
					a[i]-=t[rev[id[l]][y]].tag;
					++t[rev[id[l]][y]].size;
				}
			}
			for(int i=id[l]+1;i<id[r];++i){
				if(!rev[i][x])continue;
				if(!rev[i][y]){
					t[rev[i][x]].col=y;
					swap(rev[i][x],rev[i][y]);
				}else{
					t[rev[i][x]].tag-=t[rev[i][y]].tag;
					t[rev[i][y]].size+=t[rev[i][x]].size;
					t[rev[i][x]].fa=rev[i][y];
					rev[i][x]=0;
				}
			}
			for(int i=r;i>=L[id[r]];--i){
				res=find(poi[i]);
				if(t[res.fi].col!=x)continue;
				--t[res.fi].size;
				if(!t[res.fi].size)
					rev[id[r]][t[res.fi].col]=0;
				a[i]+=res.se+t[res.fi].tag;
				if(!rev[id[r]][y]){
					rev[id[r]][y]=++cnt;
					poi[i]=cnt;
					t[cnt].fa=t[cnt].tag=0;
					t[cnt].size=1; t[cnt].col=y;
				}else {
					poi[i]=rev[id[r]][y];
					a[i]-=t[rev[id[r]][y]].tag;
					++t[rev[id[r]][y]].size;
				}
			}
		} 
		if(op==2){
			tin>>x>>y;
			if(id[l]==id[r]){
				for(int i=l;i<=r;++i){
					res=find(poi[i]);
					if(t[res.fi].col==x) a[i]+=y,sum[id[l]]+=y;
				}
				continue;
			}
			for(int i=l;i<=R[id[l]];++i){
				res=find(poi[i]);
				if(t[res.fi].col==x) a[i]+=y,sum[id[l]]+=y;
			}
			for(int i=id[l]+1;i<id[r];++i){
				if(!rev[i][x])continue;
				t[rev[i][x]].tag+=y;
				sum[i]+=t[rev[i][x]].size*y;
			}
			for(int i=r;i>=L[id[r]];--i){
				res=find(poi[i]);
				if(t[res.fi].col==x) a[i]+=y,sum[id[r]]+=y;
			}
		}
		if(op==3){
			ans=0;
			if(id[l]==id[r]){
				for(int i=l;i<=r;++i){
					res=find(poi[i]);
					ans+=a[i]+res.se+t[res.fi].tag;
				}
				tout<<ans<<'\n'; 
				continue;
			}
			for(int i=l;i<=R[id[l]];++i){
				res=find(poi[i]);
				ans+=a[i]+res.se+t[res.fi].tag;
			}
			for(int i=id[l]+1;i<id[r];++i)ans+=sum[i];
			for(int i=r;i>=L[id[r]];--i){
				res=find(poi[i]);
				ans+=a[i]+res.se+t[res.fi].tag;
			}
			tout<<ans<<'\n'; 
		}
	}
	return 0;
}
```



---

## 作者：x7103 (赞：5)

一眼分块，然后想怎么分块。

设块长为 $B$。

对于 $1,2$ 操作，将其两端的块暴力重构，中间的块打标记，能够 $O(1)$ 维护出区间各种颜色的数量以及区间和。

暴力重构，具体地就是，对于每个块，把其作为中间块的操作都存下来；当其作为两端的块时，可以用并查集，从而维护出每个点的颜色与数量。

对于查询，如果其作为中间块，可以通过维护出的区间和直接求出答案，两端仍然可以重构。

不考虑重构的单次操作复杂度为 $O(B+\frac nB)$；重构共有 $\frac{qn}b$ 个标记，总共重构 $O(q)$ 次，复杂度是 $O\left(\big(qB+\frac{qn}B\big)\log\right)$。

这样做是 $O\left(q\sqrt n\log\right)$。

考虑怎么去掉 $\log$，即不使用并查集。

注意不到，将序列倒置，从后向前操作，就可以不用并查集了。

最终复杂度为 $O(q\sqrt n)$。

---

## 作者：小柯 (赞：4)

怎么会这样...

$O(n\sqrt{n})$ 竟被我 $O(n\sqrt{n}\log{n})$ 爆踩（大雾）

这里提供一种好想好写的 DS 做法。

首先，我们看到有多种颜色，容易联想到类似于树的虚树，那我们可以考虑对每种颜色开一颗动态开点线段树，然后一操作就是简单的 split 和 merge 了。

对于二操作，我们只需要在线段树上区间加就好了。

然而，三操作，我们的复杂度一下就崩到了缓慢的 $O(c\log n)$，这启发我们可以对个数根号分治。

如果一种颜色的个数不小于 $B$，那么就像上述一样维护；如果小于 $B$，那么暴力。（下文称两者为大树和小树）

具体到操作上，我们还是维护 $C$ 棵线段树，序列用树状数组维护，线段树只维护区间增量。如果修改操作打到了小树上，那直接 pia 地一下下放到底层直接打到序列上（就直接打到树状数组上）；否则如果是大树，就把标记留到线段树上。这里瓶颈是小树的 $O(B \log{n})$。

对于询问，我们 Q 一下树状数组，再把所有大树上的增量询问一遍求和就是答案。这一步复杂度是 $O(\frac{n}{B}\log{n})$。

(P.S.大树的集合用一个 set 维护就行。)

那么把 $\log{n}$ 提出来，就可以知道 $B$ 取 $\sqrt{n}$ 时复杂度最优。

本来的话，就应该到代码环节了，可是悲惨的笔者不会线段树分裂（

所以就用的是之前的一个小柯基（[科技](https://www.luogu.com.cn/blog/hello--world/ti-xie-p2697-mu-ban-xian-duan-shu-fen-lie-post)）就是 treap 值域可交分裂合并。理论上复杂度崩成了 $O(n\sqrt{n}\log^{1.5}{n})$，但是离谱的是跑得飞快，只跑了 10s 多一点点，最慢的点也就 1.79s。（建议时限缩到 2s。（bushi

而且没调 $B$ 的系数还是目前最优解就离谱。

这里放一下 [代码](https://www.luogu.com.cn/paste/bn7p92pa):

[代码](https://www.bilibili.com/video/BV1GJ411x7h7)

不要看看上去代码很长，但是如果手熟的话，打起来其实很顺很爽的。（但是 debug 很难受（

---

## 作者：Daidly (赞：2)

我们称 $val_i$ 为下标为 $i$ 的值，$col_i$ 为类别。

1. 区间 $[l,r]$ 内，若 $col_i=x$，则 $col_i\gets y$；

2. 区间 $[l,r]$ 内，若 $col_i=x$，则 $val_i\gets val_i+y$；

3. 询问 $\sum_{i=l}^rval_i$。

考虑分块。

对于操作 1，散块直接暴力修改重构，显然整块内可以按照 $col_i$ 分成若干个集合，我们设立一个位置来代表这个集合，记 $fir[k][x]$ 为第 $k$ 块第一个 $col_i=x$ 的下标，不妨设代表位置为 $n+fir[k][x]$。

对于整块内集合的合并，假设 $x\to y$：

- 若 $x$ 集合为空，则结束；

- 若 $y$ 集合为空，则令 $x$ 代表的 $col$ 为 $y$，并更新第一个 $y$ 的值（更新为第一个 $x$，因为此时块内所有 $x$ 全变成了 $y$ 并且原来没有 $y$） ；

- 若 $y$ 集合不为空，则新建节点为根以避免打的标记产生互相影响。

显然新建节点数不超过 $n$（一个新建点至少两个儿子），这样我们在长度为 $3n$ 的序列上建立了对应关系。

来看操作 2，可以想到对集合的代表打下标记，然后形成树形关系，一个点的权值便是该点到根的权值和。另外开个桶方便实时集合 $sum$ 的更新。

对于每一个集合的代表 $n+fir[k][x]$，不妨让 $val_{n+fir[k][x]}$ 初始为 $0$，$col_{n+fir[k][x]}$ 初始为 $x$。

对于整体加，我们在 $val_{n+fir[k][x]}$ 上加贡献，并用并查集维护。

具体地说，并查集可以一次性统计该点到根节点的权值和，并且返回祖先，这正是我们所需要的。这里有细节需要注意，路径压缩的过程中，无法将一条链压缩成一个点，若一个点 $x$ 满足 $x\ne f_x$，则下次再求祖先时会重复计数，所以我们只在压缩的过程中统计该点到祖先的儿子权值和。

```cpp
inline int find(int x){
	if(x==f[x])return x;
	int fa=f[x];
	f[x]=find(f[x]);
	if(fa!=f[x])val[x]+=val[fa];
	return f[x];
}
```
在路径压缩后，真实值如下：

```cpp
int get_value(int x){
	if(x==f[x])return val[x];
	return val[x]+val[f[x]];
}
```
对于操作 3，我们维护块内 $sum$ 值即可。

**注意：**

- 码量不小，注意细节。该更新的别漏，不该更新的更新会增大常数。比如 $sum$ 代表的是实时值，所以重构时不必要更新（更新了也没啥）。

- 这题有点卡空间时间，特别是上述空间时间 $n\sqrt{n}$ 甚至时间还多个并查集平均常数的，所以要注意特判，特判整块内若没有 $x$ 就直接跳过，能省下很多时间。

代码如下，可以根据代码理解：

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
#define int unsigned int

inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c<='9'&&c>='0'){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}

inline void print(ll x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)print(x/10);
	putchar(x%10^48);
}

const int N=2.5e5+5,S=500;
int n,q,maxn,bel[N],f[N<<2],R[N/S+2],fir[N/S+2][N],t[N/S+2][N],cnt,col[N<<2];
ll val[N<<2],sum[N/S+2];

inline void init(int k){
	for(int i=R[k-1]+1;i<=R[k];++i){
		t[k][col[i]]++;
		if(t[k][col[i]]==1){
			fir[k][col[i]]=i;
			f[i]=i+n,f[i+n]=i+n,val[i+n]=0,col[i+n]=col[i];
		}else f[i]=f[fir[k][col[i]]];
	}
}

inline int find(int x){
	if(x==f[x])return x;
	int fa=f[x];
	f[x]=find(f[x]);
	if(fa!=f[x])val[x]+=val[fa];
	return f[x];
}

inline void modify1(int l,int r,int x,int y){
	if(bel[l]==bel[r]){
		if(!t[bel[l]][x])return;
		for(int i=R[bel[l]-1]+1;i<=R[bel[l]];++i){
			col[i]=col[find(i)];
			val[i]=val[i]+(i==f[i]?0:val[f[i]]);
			t[bel[l]][col[i]]=fir[bel[l]][col[i]]=0;//注意这里t,fir都是实时值，所以要先更新完col再清空。 
		}
		for(int i=l;i<=r;++i)if(col[i]==x)col[i]=y;
		init(bel[l]);
		return;
	}
	if(l!=R[bel[l]-1]+1){
		if(t[bel[l]][x]){
			for(int i=R[bel[l]-1]+1;i<=R[bel[l]];++i){
				col[i]=col[find(i)];
				val[i]=val[i]+(i==f[i]?0:val[f[i]]);
				t[bel[l]][col[i]]=fir[bel[l]][col[i]]=0;
			}
			for(int i=l;i<=R[bel[l]];++i)if(col[i]==x)col[i]=y;
			init(bel[l]);
		}
		l=R[bel[l]]+1;
	}
	if(r!=R[bel[r]]){
		if(t[bel[r]][x]){
			for(int i=R[bel[r]-1]+1;i<=R[bel[r]];++i){
				col[i]=col[find(i)];
				val[i]=val[i]+(i==f[i]?0:val[f[i]]);
				t[bel[r]][col[i]]=fir[bel[r]][col[i]]=0;
			}
			for(int i=R[bel[r]-1]+1;i<=r;++i)if(col[i]==x)col[i]=y;
			init(bel[r]);
		}
		r=R[bel[r]-1];
	}
	for(int i=bel[l];i<=bel[r];++i){
		if(t[i][x]){
			if(t[i][y]){
				f[find(fir[i][x])]=++cnt,f[find(fir[i][y])]=cnt,f[cnt]=cnt;
				val[cnt]=0,col[cnt]=y;
			}else{
				fir[i][y]=fir[i][x];
				col[find(fir[i][x])]=y;
			}
			t[i][y]+=t[i][x],t[i][x]=fir[i][x]=0;
		}
	}
}

inline void modify2(int l,int r,int x,int y){
	if(bel[l]==bel[r]){
		if(!t[bel[l]][x])return;
		for(int i=R[bel[l]-1]+1;i<=R[bel[l]];++i)col[i]=col[find(i)];
		for(int i=l;i<=r;++i)if(col[i]==x)val[i]+=y,sum[bel[l]]+=y;
		return;
	}
	if(l!=R[bel[l]-1]+1){
		if(t[bel[l]][x]){
			for(int i=R[bel[l]-1]+1;i<=R[bel[l]];++i)col[i]=col[find(i)];
			for(int i=l;i<=R[bel[l]];++i)if(col[i]==x)val[i]+=y,sum[bel[l]]+=y;
		}
		l=R[bel[l]]+1;
	}
	if(r!=R[bel[r]]){
		if(t[bel[r]][x]){
			for(int i=R[bel[r]-1]+1;i<=R[bel[r]];++i)col[i]=col[find(i)];
			for(int i=R[bel[r]-1]+1;i<=r;++i)if(col[i]==x)val[i]+=y,sum[bel[r]]+=y;
		}
		r=R[bel[r]-1];
	}
	for(int i=bel[l];i<=bel[r];++i){
		if(t[i][x]){
			val[find(fir[i][x])]+=y;
			sum[i]+=1ll*t[i][x]*y;
		}
	}
}

inline ll qry(int l,int r){
	ll Sum=0;
	if(bel[l]==bel[r]){
		for(int i=R[bel[l]-1]+1;i<=R[bel[l]];++i)col[i]=col[find(i)];
		for(int i=l;i<=r;++i)Sum+=val[i]+(i==f[i]?0:val[f[i]]);
		return Sum;
	}
	if(l!=R[bel[l]-1]+1){
		for(int i=R[bel[l]-1]+1;i<=R[bel[l]];++i)col[i]=col[find(i)];
		for(int i=l;i<=R[bel[l]];++i)Sum+=val[i]+(i==f[i]?0:val[f[i]]);
		l=R[bel[l]]+1;
	}
	if(r!=R[bel[r]]){
		for(int i=R[bel[r]-1]+1;i<=R[bel[r]];++i)col[i]=col[find(i)];
		for(int i=R[bel[r]-1]+1;i<=r;++i)Sum+=val[i]+(i==f[i]?0:val[f[i]]);
		r=R[bel[r]-1];
	}
	for(int i=bel[l];i<=bel[r];++i)Sum+=sum[i];
	return Sum;
}

signed main(){
	n=read(),q=read(),maxn=read(),cnt=(n<<1);
	for(int i=1;i<=n;++i)val[i]=read();
	for(int i=1;i<=n;++i)col[i]=read();
	for(int i=1;i<=n;++i)bel[i]=(i+S-1)/S;
	for(int i=1;i<=bel[n];++i)R[i]=S*i;R[bel[n]]=min(R[bel[n]],n);
	for(int i=1;i<=bel[n];++i){
		for(int j=R[i-1]+1;j<=R[i];++j){
			t[i][col[j]]++;
			if(t[i][col[j]]==1){
				fir[i][col[j]]=j;
				f[j]=j+n,f[j+n]=j+n,val[j+n]=0,col[j+n]=col[j];
			}else f[j]=f[fir[i][col[j]]];
			sum[i]+=val[j];
		}
	} 
	int opt,l,r,x,y;
	while(q--){
		opt=read(),l=read(),r=read();
		if(opt==1){
			x=read(),y=read();
			if(x==y)continue;
			modify1(l,r,x,y);
		}else if(opt==2){
			x=read(),y=read();
			modify2(l,r,x,y);
		}else{
			print(qry(l,r)),putchar('\n');
		}
	}
	return 0;
}
```

如果觉得有帮助可以点个赞。

---

## 作者：yspm (赞：2)

不是很优秀的 $\Theta(n\sqrt n\log n)$ 做法，但是可以通过本题。

使用线段树之类的数据结构维护需要记录每个区间的所有颜色的变化信息，下传上传复杂度都很大，不划算。

那么用分块来做，每个块维护每种颜色的出现位置以及在 $2$ 操作中被加的权值总和。

此时对于 “散块重构” 的问题可以使用每种颜色的出现位置还原块内元素的真实 $a,c$ 值，进行完 $c_i$ 修改 或者 $a_i$ 增加以及求和操作之后再重新进行统计即可

对于 $1$ 操作，可以使用启发式合并来实现对位置信息的维护，由于交换 `std::vector` 的复杂度是 $\Theta(1)$ 所以也可以简单实现。

注意这里因为大小关系交换两个颜色的位置之后对应的加法标记也要交换，而从一个颜色被扔到另一个颜色的 `vector` 中时需要先加自己的标记再减去目标颜色的标记来保证后续调用 $a_i+tag_{c_i}$ 得到的信息正确。

直接使用 `__gnu_pbds::gp_hash_table` 来维护块内颜色的在线做法只能得到 $55$ 分，但是这题可以离线。

所以对于每个块处理它对于每个询问的贡献即可，想找当前在块里面的出现颜色可以另维护一个 `set` ，不想这里的 $\log$ 可以使用 `vector`，不要求元素不重复，扫描的时候不重复扫描就行了。


```cpp
const int N=2.5e5+10;
int n,Q,C,c[N],a[N];
int block;
int ql[N],qr[N],qx[N],qy[N],ans[N],opt[N];
int tag[N];
vector<int> pos[N];
bool vis[N];
signed main(){
	n=read(); Q=read(); C=read();
	for(int i=1;i<=n;++i) a[i]=read();
	for(int i=1;i<=n;++i) c[i]=read();
	block=sqrt(n);
	for(int i=1;i<=Q;++i){
		opt[i]=read(); ql[i]=read(); qr[i]=read();
		if(opt[i]!=3) qx[i]=read(),qy[i]=read();
	}
	for(int l=1,r;l<=n;l=r+1){
		r=min(l+block-1,n);
		for(int i=1;i<=C;++i){
			tag[i]=0;
			pos[i].clear();
		}
		int sum=0;
		vector<int> cols;
		for(int i=l;i<=r;++i){
			pos[c[i]].emplace_back(i);
			if(!vis[c[i]]){
				cols.emplace_back(c[i]);
				vis[c[i]]=1;
			}
			sum+=a[i];
		}
		for(int i=l;i<=r;++i) vis[c[i]]=0;
		for(int id=1;id<=Q;++id){
			if(qr[id]<l||ql[id]>r) continue;
			int x=qx[id],y=qy[id];
			if(ql[id]<=l&&qr[id]>=r){
				if(opt[id]==1){
					if(pos[x].empty()) continue;
					cols.emplace_back(y);
					if(pos[x].size()>pos[y].size()){
						swap(pos[x],pos[y]);
						swap(tag[x],tag[y]);
					}
					while(pos[x].size()){
						int t=pos[x].back(); pos[x].pop_back();
						a[t]+=tag[x];
						a[t]-=tag[y];
						pos[y].emplace_back(t);
					}
					tag[x]=0;
				}else if(opt[id]==2){
					if(pos[x].size()){
						tag[x]+=y;
						sum+=pos[x].size()*y;
					}
				}else ans[id]+=sum;
			}else{
				for(auto col:cols) if(!vis[col]){
					for(auto i:pos[col]) a[i]+=tag[c[i]=col];
					tag[col]=0;
					vis[col]=1;
					pos[col].clear();
				}
				for(auto col:cols) vis[col]=0;
				cols.clear();
				int L=max(l,ql[id]),R=min(r,qr[id]);
				for(int i=L;i<=R;++i){
					if(opt[id]==1){
						if(c[i]==x) c[i]=y;
					}else if(opt[id]==2){
						if(c[i]==x) a[i]+=y;
					}else if(opt[id]==3){
						ans[id]+=a[i];
					}
				}
				sum=0;
				for(int i=l;i<=r;++i){
					sum+=a[i];
					pos[c[i]].emplace_back(i);
					if(!vis[c[i]]){
						cols.emplace_back(c[i]);
						vis[c[i]]=1;
					}
				}
				for(int i=l;i<=r;++i) vis[c[i]]=0;
			}
		}
	}
	for(int i=1;i<=Q;++i) if(opt[i]==3) print(ans[i]);
	return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：1)

不难发现是套路题。

首先序列上分块，块内维护每个每个党派的城市数量。

操作 $1$ 散块原地暴力重构，整块当未来日记做：不存在 $x$ 直接跳过，存在 $x$ 不存在 $y$ 直接将两者交换，都存在的话依然是重构整块。每当我们 $O(\sqrt n)$ 地重构时块内颜色数减少 $1$ 且一次操作最多让总共的块内颜色数增加 $2$，故总复杂度为 $O((n+q) \sqrt n)$。当然，针对交换的情况为了重构方便我们还是要知道每个颜色变成了什么，不妨直接用并查集维护，直接整一个 $O(1)$ 修改 $O(h)$ 爬一次的暴力并查集即可。当然爬完记得路径压缩保证每条边真的只被爬一次，由于一次修改最多在 $O(\sqrt n)$ 个块内新增 $O(\sqrt n)$ 条边又因为每条边只会被爬一次所以这里还是 $O(q \sqrt n)$ 的。不过为了应对把 $x$ 变成 $y$ 后又把 $z$ 变成 $x$ 的情况，我们需要维护一开始颜色编号，现在的颜色编号，每个编号对应的颜色。 

操作 $2$ 整块给块内党派打标记并根据其拥有的城市数量维护整块的军队数。

操作 $3$ 整块已经处理出来了，散块暴力数完事。

时间 $O((n+q) \sqrt n)$ 空间因为答案具有可加性所以逐块处理可以做 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 3e5;
const int B = 500;
long long a[maxn],n,q,C;
int c[maxn];
stack<int> cl;
long long tag[maxn];
int cnt[maxn],fa[maxn],f[maxn],now[maxn],last[maxn];//编号对应的真实颜色 当前某个颜色对应的编号 最初某个颜色对应的编号
int tot;
long long sum;
int found(int u){
	return fa[u]=(fa[u]==u?u:found(fa[u]));
}
void Clear(){
    while(cl.size()>0){
        now[cl.top()]=last[cl.top()]=tag[cl.top()]=cnt[cl.top()]=0;
        cl.pop();
    }
    for(int i=0;i<=tot;i++) fa[i]=f[i]=0;
    tot=sum=0;
}
void remove(int pos){
	int lt=(pos-1)*B+1;
    int rt=pos*B;
    for(int i=lt;i<=rt;i++) c[i]=f[found(last[c[i]])];
    for(int i=lt;i<=rt;i++) a[i]+=tag[c[i]];
    return ;
}
void build(int pos){
    Clear();
    int lt=(pos-1)*B+1;
    int rt=pos*B;
    for(int i=lt;i<=rt;i++) if(now[c[i]]==0) now[c[i]]=last[c[i]]=++tot,f[tot]=c[i],cl.push(c[i]);
	for(int i=lt;i<=rt;i++) fa[now[c[i]]]=now[c[i]],cnt[c[i]]++,sum+=a[i];
    return ;
}
void change(int pos,int x,int y){
	if(cnt[x]==0) return ;
    if(cnt[y]==0){
		swap(cnt[x],cnt[y]);
        swap(tag[x],tag[y]);
        now[y]=++tot;
        f[tot]=y;
        fa[now[x]]=fa[now[y]]=now[y];
        now[x]=0;
        cl.push(y);
        return ;
    }
    remove(pos);
    int lt=(pos-1)*B+1;
    int rt=pos*B;
    for(int i=lt;i<=rt;i++) if(c[i]==x) c[i]=y;
    build(pos);
    return ;
}
struct Query{
    int opt,l,r,x,y,v;
}Q[maxn];
long long answer[maxn];
void work(int pos){
    int Lt=B*(pos-1)+1,Rt=B*pos;
    build(pos);
    for(int i=1;i<=q;i++){
        if(Q[i].r<Lt||Q[i].l>Rt) continue;
        else if(Q[i].l<=Lt&&Rt<=Q[i].r){
            if(Q[i].opt==1){
                change(pos,Q[i].x,Q[i].y);
            }
            else if(Q[i].opt==2){
                if(cnt[Q[i].x]!=0){
                    tag[Q[i].x]+=Q[i].v;
                    sum+=1ll*cnt[Q[i].x]*Q[i].v;
                    cl.push(Q[i].x);
                }
            }else{
                answer[i]+=sum;
            }
        }else{
            remove(pos);//直到下次 build 前整块的预处理失效
            for(int j=max(Lt,Q[i].l);j<=min(Rt,Q[i].r);j++){
                if(Q[i].opt==1){
                    if(c[j]==Q[i].x) c[j]=Q[i].y;
                }else if(Q[i].opt==2){
                    if(c[j]==Q[i].x) a[j]+=Q[i].v;
                }else{
                    answer[i]+=a[j];
                }
            }
            build(pos);
        }
    }
    remove(pos);
}
int main(){
	//freopen("1.in","r",stdin);
	//freopen("1.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
	cin>>n>>q>>C;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++) cin>>c[i];
    for(int i=1;i<=q;i++){
        cin>>Q[i].opt>>Q[i].l>>Q[i].r;
        if(Q[i].opt==1) cin>>Q[i].x>>Q[i].y;
        else if(Q[i].opt==2) cin>>Q[i].x>>Q[i].v;
    }
    for(int i=1;i<=n/B+1;i++) work(i);
    for(int i=1;i<=q;i++) if(Q[i].opt==3) cout<<answer[i]<<"\n";
    return 0;
}
/*
3 5 3
1 2 3
1 2 3
1 1 3 3 2
1 1 3 1 3
1 1 3 2 1
2 1 3 1 4
3 2 3
*/
```


---

## 作者：St_john (赞：1)

类似 [P8576](https://www.luogu.com.cn/blog/St-John/p8576-dtoi-2-xing-zhi-jie) 的一道题，但是更难。  
这道题需要维护操作一，必然是分块。  
接下来的操作二则是需要思考的了。  
操作三平凡。  

操作一可以用并查集来维护。  
但是操作二是需要打标记的。  
在操作一时，标记是无法维护的。  
所以考虑转移标记，对于每次找父亲，都将标记下传。  
所以在操作一时，要新建一个节点，使得它的信息包含 $x,y$ ，党派是 $y$ ，这样不会有标记重复的情况。  

```cpp
#include<cstdio>
#define _for(i,a,b) for(register int i=(a);i<=(b);++i)
#define __for(i,a,b) for(register int i=(a);i>=(b);--i)
#define Re register int
#define il inline
#define pc putchar
using namespace std;
typedef long long ll;
const int N=2.5e5+10,M=N*10+10,inf=2147483647;
il int re(){
	int x=0;
	bool f=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
		f|=ch=='-',ch=getchar();
	while(ch>='0'&&ch<='9')
		x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return f?-x:x;
}
void pr(ll x){
	if(x<0) x=-x,pc('-');
	if(x>9) pr(x/10);
	pc(x%10|48);
}

const int B=500,L=B+10;
int n,m;
int fa[M];
ll add[M];
int find(int x){
//查询时推标记，根节点会被用很多次，所以不推根节点的标记
//因此根节点一定是新点
	if(x==fa[x]) return x;
	int f=find(fa[x]);
	if(f!=fa[x]) add[x]+=add[fa[x]];
	return fa[x]=f;
}
int pos[N],bl[L],br[L],cnt;
ll a[N],sum[L];int b[N];
struct node{
	int head,num;
}e[L][N];

il void init(int x){
	_for(i,bl[x],br[x]){
		sum[x]+=a[i];
		if(!e[x][b[i]].head){
			e[x][b[i]].head=++cnt;
			fa[cnt]=cnt;
		}
		fa[i]=e[x][b[i]].head;
		++e[x][b[i]].num;
	}
}

il void calc1(int now,int l,int r,int x,int y){
	if(!e[now][x].head) return ;
	++cnt;fa[cnt]=cnt;
	if(e[now][y].head)
		fa[e[now][y].head]=cnt;
	e[now][y].head=cnt;
	_for(i,l,r){
		int f=find(i);
		a[i]+=add[i];
		add[i]=0;
		if(f==e[now][x].head){
			a[i]+=add[f];
			fa[i]=cnt;
			++e[now][y].num;
			--e[now][x].num;
		}
	}
}
il void calc2(int now,int x,int y){
	if(!e[now][x].head) return ;
	if(!e[now][y].head){
		e[now][y].head=e[now][x].head;
		e[now][y].num=e[now][x].num;
		e[now][x].head=e[now][x].num=0;
	}
	else{
		++cnt;
		fa[cnt]=cnt;
		fa[e[now][x].head]=cnt;
		fa[e[now][y].head]=cnt;
		e[now][y].num+=e[now][x].num;
		e[now][x].head=e[now][x].num=0;
		e[now][y].head=cnt;
	}
}
il void calc3(int now,int l,int r,int x,ll v){
	if(!e[now][x].head) return ;
	_for(i,l,r){
		int f=find(i);
		a[i]+=add[i];add[i]=0;
		if(f==e[now][x].head){
			a[i]+=v;
			sum[now]+=v;
		}
	}
}
il void calc4(int now,int x,ll v){
	if(!e[now][x].head) return ;
	add[e[now][x].head]+=v;
	sum[now]+=v*e[now][x].num;
}
il ll calc5(int l,int r){
	ll s=0;
	_for(i,l,r){
		int f=find(i);
		a[i]+=add[i];
		add[i]=0;
		s+=a[i]+add[f];
	}
	return s;
}

signed main(){
	n=cnt=re();
	int q=re();
	m=re();
	_for(i,1,n){
		a[i]=re();
		pos[i]=i/B+1;
		if(pos[i]!=pos[i-1]){
			bl[pos[i]]=i;
			br[pos[i-1]]=i-1;
		}
	}
	br[pos[n]]=n;
	_for(i,1,n) b[i]=re();
	_for(i,1,pos[n]) init(i);
	
	while(q--){
		int op=re();
		if(op==1){
			int l=re(),r=re(),x=re(),y=re();
			if(x==y) continue;
			if(pos[l]==pos[r]){
				calc1(pos[l],l,r,x,y);
			}
			else{
				int L,R;
				if(l!=bl[pos[l]]){
					calc1(pos[l],l,br[pos[l]],x,y);
					L=pos[l]+1;
				}
				else L=pos[l];
				if(r!=br[pos[r]]){
					calc1(pos[r],bl[pos[r]],r,x,y);
					R=pos[r]-1;
				}
				else R=pos[r];
				_for(i,L,R)
					calc2(i,x,y);
			}
		}
		else if(op==2){
			int l=re(),r=re(),x=re();ll v=re();
			if(pos[l]==pos[r]){
				calc3(pos[l],l,r,x,v);
			}
			else{
				int L,R;
				if(l!=bl[pos[l]]){
					calc3(pos[l],l,br[pos[l]],x,v);
					L=pos[l]+1;
				}
				else L=pos[l];
				if(r!=br[pos[r]]){
					calc3(pos[r],bl[pos[r]],r,x,v);
					R=pos[r]-1;
				}
				else R=pos[r];
				_for(i,L,R)
					calc4(i,x,v);
			}
		}
		else{
			int l=re(),r=re();
			ll ans=0;
			if(pos[l]==pos[r]){
				ans=calc5(l,r);
			}
			else{
				int L,R;
				if(l!=bl[pos[l]]){
					ans+=calc5(l,br[pos[l]]);
					L=pos[l]+1;
				}
				else L=pos[l];
				if(r!=br[pos[r]]){
					ans+=calc5(bl[pos[r]],r);
					R=pos[r]-1;
				}
				else R=pos[r];
				_for(i,L,R)
					ans+=sum[i];
			}
			pr(ans),pc('\n');
		}
	}
	return 0;
}
```



---

## 作者：I_am_Accepted (赞：0)

一眼看题发现 polylog 不可做（若可以请以任何方式通知我），考虑分块。

对于 1 操作想到 dsu，但是 2 操作否认了这一个想法。

我们可以将 dsu 转成二叉树，然后 2 操作打懒标记。

对于两边的散块，我们暴力拆解重构。

拆解时遍历每一棵树，下传懒标记，转成 $\{a\},\{c\}$ 两个序列的形式。

实现要达到 $O(\sqrt n)$ 需要深思。

对于 3 询问，我们记录每一个整块的和，散块暴力拆解 $\to$ 询问 $\to$ 重构。

总复杂度 $O(n\sqrt n)$（$n,q$ 同阶）。

对于空间，发现出题人卡 $O(n\sqrt n)$，导致我这个空间卡了一下午无法通过。

既然在线空间不行则转为离线，对于每一个块分别计算答案，统计在一起即可。

空间 $O(n)$，这代码非常难调（我菜），可把我写吐血了，下次不轻易写毒瘤分块题了。

```cpp
/*
* Author: ShaoJia
* Last Modified time: 2022-09-09 22:14:25
* Motto: We'll be counting stars.
*/
#include<bits/stdc++.h>
using namespace std;
#define For(i,j,k) for(int i=(j);i<=(k);i++)
#define Rof(i,j,k) for(int i=(j);i>=(k);i--)
#define ll long long
char buf[1<<21],*p1,*p2;
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline int read() {
	int x=0,f=1;
	char c=gc();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=gc();}
	return x*f;
}
const int N=250002,gap=500;
struct Que{
	int opt,l,r,x,y;
}Q[N];
struct node{
	int ls,rs,sz,pos;
	ll val;
	node(){}
	node(int k1,int k2,int k3,int k4,ll k5){ ls=k1,rs=k2,sz=k3,pos=k4,val=k5; }
}t[gap<<1];
int n,q,C,c[N],lim,L,R,tot,root[N],s[N],st;
ll a[N],ans[N],sum;
bool vis[N];
inline int merge(int x,int y){
	if(!x || !y) return x^y;
	t[++tot]=node(x,y,t[x].sz+t[y].sz,0,0);
	return tot;
}
void build(){
	sum=0;
	For(i,L,R){
		t[++tot]=node(0,0,1,i,a[i]);
		if(!vis[c[i]]){
			vis[c[i]]=true;
			s[++st]=c[i];
			root[c[i]]=tot;
		}else{
			root[c[i]]=merge(tot,root[c[i]]);
		}
		sum+=a[i];
	}
}
inline void dfs(int rt,int col){
	if(!t[rt].ls){
		a[t[rt].pos]=t[rt].val;
		c[t[rt].pos]=col;
		return ;
	}
	int ls=t[rt].ls,rs=t[rt].rs;
	t[ls].val+=t[rt].val;
	t[rs].val+=t[rt].val;
	dfs(ls,col);
	dfs(rs,col);
}
void ruin(){
	For(i,1,st){
		if(root[s[i]]){
			dfs(root[s[i]],s[i]);
			root[s[i]]=0;
		}
	}
	For(i,1,st) 
		vis[s[i]]=false;
	st=tot=0;
}
void Chan(int x,int y){
	if(!root[x] || x==y) return ;
	root[y]=merge(root[y],root[x]);
	root[x]=0;
	if(!vis[y]){//!!!
		s[++st]=y;
		vis[y]=true;
	}
}
void chan(int l,int r,int x,int y){
	ruin();
	For(i,l,r) if(c[i]==x) c[i]=y;
	build();
}
void Add(int x,ll y){
	if(root[x]){
		t[root[x]].val+=y;
		sum+=t[root[x]].sz*y;
	}
}
void add(int l,int r,int x,ll y){
	ruin();
	For(i,l,r) if(c[i]==x) a[i]+=y;
	build();
}
ll que(int l,int r){
	ruin();
	ll res=0;
	For(i,l,r) res+=a[i];
	build();
	return res;
}
void solve(){
	tot=0;
	build();
	int l,r;
	For(i,1,q){
		l=max(Q[i].l,L);
		r=min(Q[i].r,R);
		if(l>r) continue;
		if(L==l && R==r){//all
			if(Q[i].opt==1) Chan(Q[i].x,Q[i].y);
			else if(Q[i].opt==2) Add(Q[i].x,Q[i].y);
			else ans[i]+=sum;
		}else{//some
			if(Q[i].opt==1) chan(l,r,Q[i].x,Q[i].y);
			else if(Q[i].opt==2) add(l,r,Q[i].x,Q[i].y);
			else ans[i]+=que(l,r);
		}
	}
	ruin();
}
signed main(){
	n=read(),q=read(),C=read();
	For(i,1,n) a[i]=read();
	For(i,1,n) c[i]=read();
	lim=(n-1)/gap+1;
	For(i,1,q){
		Q[i].opt=read(),Q[i].l=read(),Q[i].r=read();
		if(Q[i].opt!=3) Q[i].x=read(),Q[i].y=read();
	}
	For(i,1,lim) L=1+(i-1)*gap,R=min(i*gap,n),solve();
	For(i,1,q) if(Q[i].opt==3) printf("%lld\n",ans[i]);
return 0;}
```

---


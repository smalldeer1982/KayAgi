# [省选联考 2023] 过河卒

## 题目背景

棋盘上有一个过河卒，需要走到底线。卒行走的规则是可以向左移动一格，向右移动一格或者向前移动一格。同时在棋盘上有两个另一方的棋子，需要拦截这个卒走到底线。这两个棋子的走法和帅一致，可以走到前后左右四个方向上相邻的格子。因此本题可以称为“帅拦过河卒”。

## 题目描述

有一个 $n$ 行 $m$ 列的棋盘。我们用 $(i,j)$ 表示第 $i$ 行第 $j$ 列的位置。棋盘上有一些 障碍，还有一个黑棋子和两个红棋子。

游戏的规则是这样的: 红方先走，黑方后走，双方轮流走棋。红方每次可以选择一个红棋子，向棋盘的相邻一格走一步。具体而言，假设红方选择的这个棋子位置在 $(i,j)$，那么它可以走到 $(i-1,j),(i+1,j),(i,j-1),(i,j+1)$ 中的一个，只要这个目的地在棋盘内且没有障碍且没有红方的另一个棋子。

黑方每次可以将自己的棋子向三个方向之一移动一格。具体地，假设这个黑棋子位置在 $(i,j)$，那么它可以走到 $(i-1,j),(i,j-1),(i,j+1)$ 这三个格子中的一个，只要这个目的地在棋盘内且没有障碍。

在一方行动之前，如果发生以下情况之一，则立即结束游戏，按照如下的规则判断胜负（列在前面的优先）：

- 黑棋子位于第一行。此时黑方胜。

- 黑棋子和其中一个红棋子在同一个位置上。此时进行上一步移动的玩家胜。

- 当前玩家不能进行任何合法操作。此时对方胜。

现在假设双方采用最优策略，不会进行不利于自己的移动。也就是说:

- 若存在必胜策略，则会选择所有必胜策略中，不论对方如何操作，本方后续获胜所需步数最大值最少的操作。
- 若不存在必胜策略，但存在不论对方如何行动，自己都不会落败的策略，则会选择任意一种不败策略。
- 若不存在不败策略，则会选择在所有策略中，不论对方如何操作，对方后续获胜所需步数最小值最大的操作。

如果在 $100^{100^{100}}$ 个回合之后仍不能分出胜负，则认为游戏平局。请求出游戏结束时双方一共移动了多少步，或者判断游戏平局。

## 说明/提示

**【样例 1 解释】**

第一组数据，红方第一步没有可行的移动，所以黑方胜。

第二组数据，无论第一步红方怎么移动，黑方都可以在下一步让黑棋子与红棋子在同一个位置。

第三组数据，无论第一步红方怎么移动，黑方都可以将自己的棋子往上移动一枚来达成胜利。

第四组数据，有一个红棋子不能动。另一个红棋子可以在第三行移动来防止黑棋子进入第一行。黑棋子也可以一直在第五行移动。如果红棋子到达第五行，黑棋子可以选择从另一边逃走。

第五组数据，在最后一行的那个红棋子可以从左边绕一圈抓住黑棋子。注意另一个红棋子可以移动。

**【样例 2 解释】**

这个样例中的每一组数据都满足测试点 $5$ 到 $13$ 中某一个测试点的限制。

**【子任务】**

对于所有的数据，保证：$1 \leq T \leq 10$，$2 \leq n \leq 10$，$1 \leq m \leq 10$，$\text{id}$ 等于测试点编号。

对于每组数据保证：棋盘上的黑棋恰好有一个，红棋恰好有两个，且黑棋不在第一 行。

- 测试点 $1 \sim 4$：保证要么平局，要么红方在开始时无法移动。

- 测试点 $5 \sim 6$：保证 $n \geq 4$ 。保证棋盘上第 $n-1$ 行的每一个格子都是障碍物，且 棋盘上其他行没有障碍物。保证黑棋在前 $n-2$ 行，有一个红棋在前 $n-2$ 行，另一个红棋在第 $n$ 行。

- 测试点 $7 \sim 9$：保证 $m=1$。

- 测试点 $10 \sim 13$：保证要么平局，要么存在策略可以在 $9$ 步之内结束游戏。

- 测试点 $14 \sim 20$：无特殊限制。

## 样例 #1

### 输入

```
0 5
4 5
...#O
.#..#
#O#..
.#..X
3 3
#.#
O.O
.X.
3 3
O..
.#X
.O.
5 5
.....
.....
..O..
#..#.
O#.X.
9 9
...######
.#.......
.#######.
.#.#.....
.#O#.####
.#.#.....
.#######.
.#X......
.O.......
```

### 输出

```
Black 0
Black 2
Black 2
Tie
Red 75
```

## 样例 #2

### 输入

```
见附件中的 zu/zu2.in```

### 输出

```
见附件中的 zu/zu2.ans```

# 题解

## 作者：yllcm (赞：45)

本题是经典的有向图博弈问题。注意到 $n,m\leq 10$，所以本题三个棋子的位置 $(x_1,y_1),(x_2,y_2),(x_3,y_3)$ 以及先后手情况的总状态数约为 $2(nm)^3=2\times 10^6$ 级别。所以我们不妨解决一个更强的问题：对于一张有向图，初始位于状态 $s$，每次可以移动一步，不能移动者输，规则和原题相同，求胜负情况和对应的移动步数。

先考虑解决胜负情况的问题：

> 观察 $1$：一个状态为必胜态当且仅当其后继状态存在必败态，一个状态为必败态当且仅当其所有后继都是必胜态，否则为平局。

据此可以设计出一个基于 BFS 的算法：每次仅把非平局状态压进队列，若当前状态为必败态，则将它的所有前驱都标记为必胜态，并加入队列。若当前状态为必胜态，则检查它的某个前驱的所有后继是否全部被访问且为必胜态，若是，则把这个前驱标记为必败态，并加入队列。BFS 完成后，所有没有被访问过的结点为平局。容易得到一个 $\mathcal{O}((nm)^3)$ 的实现。

接下来考虑操作步数的问题，观察上述 BFS 过程可以发现：

> 观察 $2$：一个状态若为必胜态，则它一定被它在队列中首次出现的后继更新步数。一个状态若为必败态，则它一定被它在队列中最后一次出现的后继更新步数。

证明很简单，因为 BFS 过程中在队列中越晚出现的结点步数越大。

回到原问题，可以发现原题已经被完全割裂成建图和 BFS 两部分，模拟即可。

下面是考场代码。笔者在考场上在 $30\min$ 以内实现了这个思路，效率应该还是很高的。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define db double
#define ull unsigned long long
#define pb push_back
#define mp make_pair
#define pii pair<int, int>
#define FR first
#define SE second
#define il inline
#define re register
using namespace std;
inline int read() {
    int x = 0; bool op = false;
    char c = getchar();
    while(!isdigit(c))op |= (c == '-'), c = getchar();
    while(isdigit(c))x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
    return op ? -x : x;
}
const int N = 15;
const int MAXN = 2e6 + 10;
const int dx[4] = {-1, 0, 0, 1};
const int dy[4] = {0, -1, 1, 0};
int SID, n, m, tot, etot;
char s[N][N];
int id[N][N][N][N][N][N][2];
int vis[MAXN], f[MAXN], g[MAXN], in[MAXN];
int head[MAXN], to[MAXN << 3], nxt[MAXN << 3];
void addedge(int u, int v) {to[++etot] = v; nxt[etot] = head[u]; head[u] = etot;}
il bool chk(int a, int b, int x, int y, int z, int w) {
    if(a < 1 || a > n || b < 1 || b > m)return false;
    if(x < 1 || x > n || y < 1 || y > m)return false;
    if(z < 1 || z > n || w < 1 || w > m)return false;
    if(s[a][b] == '#' || s[x][y] == '#' || s[z][w] == '#')return false;
    if(x == z && y == w)return false;
    return true;
}
int st;
il void bfs() {
    queue<int> q;
    for(re int i = 0; i < tot; i++)if(vis[i])q.push(i);
    while(q.empty() == false) {
        int u = q.front(); q.pop();
        if(u == st)return ;
        for(int i = head[u]; i; i = nxt[i]) {
            int v = to[i];
            if(vis[v] == false) {
                in[v]--;
                if(g[u] == 0) {
                    g[v] = 1; f[v] = f[u] + 1;
                    vis[v] = true; q.push(v);
                }
                else if(in[v] == 0) {
                    g[v] = 0; f[v] = f[u] + 1; 
                    vis[v] = true; q.push(v);
                }
            }
        }
    }
    return ;
}
il void clr() {
    for(re int i = 0; i < tot; i++) {
        vis[i] = in[i] = f[i] = g[i] = head[i] = 0;
    }
    tot = etot = 0;
    return ;
}
il void solve() {
    queue<int> q;
    n = read(); m = read();
    for(re int i = 1; i <= n; i++)scanf("%s", s[i] + 1);
    int sa = 0, sb = 0, sx = 0, sy = 0, sz = 0, sw = 0;
    for(re int i = 1; i <= n; i++)for(re int j = 1; j <= m; j++) {
        if(s[i][j] == 'X')sa = i, sb = j;
        if(s[i][j] == 'O') {
            if(sx == 0 && sy == 0)sx = i, sy = j;
            else sz = i, sw = j;
        }
    }
    for(re int a = 1; a <= n; a++)for(re int b = 1; b <= m; b++) {
        for(re int x = 1; x <= n; x++)for(re int y = 1; y <= m; y++) {
            for(re int z = 1; z <= n; z++)for(re int w = 1; w <= m; w++) {
                if(chk(a, b, x, y, z, w) == false)continue;
                id[a][b][x][y][z][w][0] = tot++;
                id[a][b][x][y][z][w][1] = tot++;
            }
        }
    }
    st = id[sa][sb][sx][sy][sz][sw][0];
    for(re int a = 1; a <= n; a++)for(re int b = 1; b <= m; b++) {
        for(re int x = 1; x <= n; x++)for(re int y = 1; y <= m; y++) {
            for(re int z = 1; z <= n; z++)for(re int w = 1; w <= m; w++) {
                if(chk(a, b, x, y, z, w) == false)continue;
                int cur = id[a][b][x][y][z][w][0];
                for(int i = 0; i < 4; i++) {
                    int nx = x + dx[i], ny = y + dy[i];
                    if(chk(a, b, nx, ny, z, w)) {
                        addedge(id[a][b][nx][ny][z][w][1], cur);
                        in[cur]++;
                    }
                    nx = z + dx[i]; ny = w + dy[i];
                    if(chk(a, b, x, y, nx, ny)) {
                        addedge(id[a][b][x][y][nx][ny][1], cur);
                        in[cur]++;
                    }
                }
                for(int i = 0; i < 3; i++) {
                    int nx = a + dx[i], ny = b + dy[i];
                    if(chk(nx, ny, x, y, z, w)) {
                        addedge(id[nx][ny][x][y][z][w][0], cur ^ 1);
                        in[cur ^ 1]++;
                    }
                }
                if(a == 1) {
                    vis[cur] = vis[cur ^ 1] = true;
                    g[cur] = 0; g[cur ^ 1] = 1;
                    f[cur] = f[cur ^ 1] = 0;
                }
                else if((a == x && b == y) || (a == z && b == w)) {
                    vis[cur] = vis[cur ^ 1] = true;
                    g[cur] = g[cur ^ 1] = 0;
                    f[cur] = f[cur ^ 1] = 0;
                }
                else {
                    if(in[cur] == 0)vis[cur] = true, g[cur] = f[cur] = 0;
                    if(in[cur ^ 1] == 0)vis[cur ^ 1] = true, g[cur ^ 1] = f[cur ^ 1] = 0;
                }
            }
        }
    }
    bfs();
    if(vis[st] == false)puts("Tie");
    else if(g[st] == 1)printf("Red %d\n", f[st]);
    else printf("Black %d\n", f[st]);
    return clr(), void();
}
int main() {
    freopen("zu.in", "r", stdin);
    freopen("zu.out", "w", stdout);
    SID = read(); int test = read();
    while(test--)solve();
    return 0;
}
```

但是 luogu TLE 一个点是怎么回事呢（



---

## 作者：樱雪喵 (赞：26)

题如其名，考场上把我送卒了。

### 前置知识

- bfs
- 足够的码力和耐心。


### Solution
观察到 $1\le n,m\le 10$，可以用一个两位整数表示一个棋子的坐标。将三个棋子全部加入状态，状态数最多只有 $10^6$，时间上允许我们暴力搜索。

注意到状态间的转移可能成环，而在环上的状态并不一定都为平局。dfs 难以处理，我们把状态建图后使用 bfs 转移答案。

具体地，由于终止状态的胜负已知，可以从终止状态倒序转移。反过来建图，考虑类似拓扑排序的转移方式，一个点 $u$ 可以被加入队列，当且仅当满足以下条件之一：

- 点 $u$ 可以到达一个已确定的必败态，即 $u$ 必胜；
- 点 $u$ 所有可达的点状态均已确定，且全部必胜，则 $u$ 必败。

若最后起始点的状态仍未被更新，则平局。

### Tips

- 注意判两个红子不能相撞。
- 可以证明若棋子状态给定，当前局面的行动方也唯一确定。可以在第一轮 bfs 建图中记录每个局面的先后手情况，从而压掉第七维状态。
- 设两枚红子为 $(a,b),(c,d)$，显然它们等价，可以钦定 $a\le c$ 以减小一倍常数。
- 似乎直接写并不卡常，所以代码没加上述第三条优化（
- 一定要全部想清楚再开始写。

### Code

```cpp
#include<bits/stdc++.h>
#define il inline
using namespace std;
il int read()
{
    int xr=0,F=1; char cr=getchar();
    while(cr<'0'||cr>'9') {if(cr=='-') F=-1;cr=getchar();}
    while(cr>='0'&&cr<='9')
        xr=(xr<<3)+(xr<<1)+(cr^48),cr=getchar();
    return xr*F;
}
const int N=3e6+5,M=15;
int id,T,n,m;
int hsh(int a,int b,int c,int d,int x,int y) {return y+x*10+d*100+c*1000+b*10000+a*100000;}
struct edge{
    int nxt,to;
}e[N<<2];
int head[N],cnt;
il void add(int u,int v) {e[++cnt]={head[u],v};head[u]=cnt;}
int bel[N],vis[N],in[N];
struct qwq{
    int w,stp;
}ans[N];
struct node{
    int op,a,b,c,d,x,y;
};
char mp[M][M];
int dx[4]={-1,0,0,1};
int dy[4]={0,1,-1,0};
void bfs(node s,int h) //搜出所有可达状态，建图
{
    memset(vis,0,sizeof(vis)),memset(in,0,sizeof(in));
    memset(head,0,sizeof(head)),cnt=0;
    queue<node> q;
    q.push(s); vis[h]=1;
    while(!q.empty())
    {
        node nw=q.front(); q.pop();
        int op=nw.op,a=nw.a,b=nw.b,c=nw.c,d=nw.d,x=nw.x,y=nw.y;
        if(x==0||(a==x&&b==y)||(c==x&&d==y)) continue;
        int qwq=hsh(a,b,c,d,x,y);
        bel[qwq]=op;
        if(op)
        {
            for(int w=0;w<4;w++) //红棋 1 移动
            {
                int na=a+dx[w],nb=b+dy[w];
                if(na<0||na>=n||nb<0||nb>=m) continue;
                if(mp[na][nb]=='#'||(na==c&&nb==d)) continue;
                int pwp=hsh(na,nb,c,d,x,y);
                add(pwp,qwq); in[qwq]++;
                if(!vis[pwp]) vis[pwp]=1,q.push({op^1,na,nb,c,d,x,y});
            }
            for(int w=0;w<4;w++) //红棋 2 移动
            {
                int nc=c+dx[w],nd=d+dy[w];
                if(nc<0||nc>=n||nd<0||nd>=m) continue;
                if(mp[nc][nd]=='#'||(nc==a&&nd==b)) continue;
                int pwp=hsh(a,b,nc,nd,x,y);
                add(pwp,qwq); in[qwq]++;
                if(!vis[pwp]) vis[pwp]=1,q.push({op^1,a,b,nc,nd,x,y});
            }
        }
        else
        {
            for(int w=0;w<3;w++) //黑棋移动
            {
                int nx=x+dx[w],ny=y+dy[w];
                if(nx<0||nx>=n||ny<0||ny>=m||mp[nx][ny]=='#') continue;
                int pwp=hsh(a,b,c,d,nx,ny);
                add(pwp,qwq); in[qwq]++;
                if(!vis[pwp]) vis[pwp]=1,q.push({op^1,a,b,c,d,nx,ny});
            }
        }
    }
}
bool vs[N];
void solve()//拓扑转移答案
{
    memset(vs,0,sizeof(vs)),memset(ans,0,sizeof(ans));
    queue<int> q;
    for(int i=0;i<1e6;i++) 
    {
        if(vis[i]&&!in[i]) 
        {
            ans[i]={0,0},q.push(i);
            vs[i]=1;
        }
    }
    while(!q.empty())
    {
        int now=q.front(); q.pop();
        for(int i=head[now];i;i=e[i].nxt)
        {
            int v=e[i].to;
            if(ans[now].w==0)
            {
                if(!ans[v].w) ans[v].w=1,ans[v].stp=ans[now].stp+1;
                else ans[v].stp=min(ans[v].stp,ans[now].stp+1);
                if(!vs[v]) vs[v]=1,q.push(v);
            }
            else 
            {
                in[v]--;
                if(!ans[v].w) ans[v].stp=max(ans[v].stp,ans[now].stp+1);
                if(!in[v]&&!vs[v]) {vs[v]=1,q.push(v);}
            }
        }
    }
}
int main()
{
    id=read(),T=read();
    while(T--)
    {
        n=read(),m=read();
        int a=-1,b=0,c=0,d=0,x=0,y=0;
        for(int i=0;i<n;i++)
            for(int j=0;j<m;j++)
            {
                cin>>mp[i][j];
                if(mp[i][j]=='X') x=i,y=j;
                else if(mp[i][j]=='O')
                {
                    if(a==-1) a=i,b=j;
                    else c=i,d=j;
                }
            }
        bfs({1,a,b,c,d,x,y},hsh(a,b,c,d,x,y));
        solve();
        qwq res=ans[hsh(a,b,c,d,x,y)];
        if(res.w) printf("Red %d\n",res.stp);
        else if(vs[hsh(a,b,c,d,x,y)]) printf("Black %d\n",res.stp);
        else printf("Tie\n");
    }
    return 0;
}
```

---

## 作者：AlicX (赞：23)

### 前言

[弱化版](https://www.luogu.com.cn/problem/P6560)

教练讲的题，据说是很好的码力题和博弈论题，于是就来写一下题解加深印象。

前置知识：

- `bfs`
- 拓扑排序
- 博弈论

------------

## Solution

博弈论正常思路：定义动态规划数组表示这个点能否完成某个目标。

于是来套一下定义：定义 $f_{a,b,c,d,e,f}$ 表示黑子在 $(a,b)$ 处，第一个红子在 $(c,d)$ 处，第二个红子在 $(e,f)$ 时的状态。看空间限制：$n,m \leq 10$，不会超空间。但是这里有一个小细节，可以优化我们枚举的状态数，我们发现 $f_{1,2,3,4,5,6}$ 和 $f_{1,2,5,6,3,4}$ 其实是同一种状态，于是我们减少枚举数量，强行让第一个红子的坐标在第二个红子的上方，这样就会减少状态冗余。

我们再定义一个 `pair` 类型的 $wp$ 数组，$wp.x=1$ 代表在 $i$ 状态下黑子为必胜态，$wp.x=0$ 代表在 $i$ 状态下红子为必胜态，最后定义 $wp.x=+\infty$ 代表 $i$ 这个状态还没被遍历过。$wp.y$ 则代表到达 $i$ 这个状态需要的步数。于是我们的答案就可以知道，定义 $ans$ 为目标状态，当 $wp_{ans}$ 的第一关键字为 $+\infty$ 时，说明是平局。当 $wp_{ans}$ 的第一关键字为 $1$ 时，说明黑子胜。否则红子胜。

定义完成后，我们便开始 bfs，找到递推起点（黑子必胜的点），有三种情况：要么到达了底线，要么吃掉了红子，要么红子无路可走。然后求出每一个状态被哪一个状态更新，这里建立反向边，保存下来备用。

接下来进行拓扑排序和博弈论的部分，假如我们取出来的点为 $u$，并且 $u$ 是必胜态，设 $u$ 能到达 $v$，说明 $v$ 一定为必败态。

证明：因为我们建立的是反向边，所以其实是 $v$ 去更新 $u$，只有 $v$ 为必败态时，$u$ 才是必胜，所以当 $u$ 必胜时，$v$ 必败。

注意，当 $v$ 为 $+\infty$ 时，我们需要把 $v$ 定义为必胜态。

具体细节参考代码。

 [Code](https://www.luogu.com.cn/paste/pln30uv1)




---

## 作者：EnofTaiPeople (赞：15)

### 前言

2023 年 4 月 2 日，我在考场上写了两个小时暴力转移因为没判红棋重合，获得了 20 分的好成绩！

后来因为洛谷评测机效率不如官方评测机，所以改完之后依旧会被卡常，看着那么多七维数组，想尝试卡常却无能为力。

2023 年 8 月 26 日，我只用了半个小时，依旧是暴力转移，曾经的七维数组只剩下三维，终于以极其精简的暴力通过了此题。

E_space，你还好吗？

### 解法

众所周知，这类有向图博弈问题有一种能避免大多数分类讨论的方法：最短路快速算法！

考虑进行松弛操作，具体地，你只要会做 DAG 的情况就可以，你需要能够根据一个节点所有后继的状态来转移到这个节点的状态。

由于每一个节点的后继的行动方都与自己相反，我们设 $f(S)$ 表示状态 $S$ 的胜负情况，当这是一个胜态时，$f(S)=minstep-M$，负态时 $f(S)=M-maxstep$，平态时 $f(S)=0$。

首先将一定的负态的 $f(S)\leftarrow M$ 并放入队列，然后不断枚举队头的后继，转移之后看其状态是否改变，若改变则插入队列反复更新。

注意需要剪枝，从起始状态开始记搜，同时连边，保证红棋编号偏序关系一定这样的话有效状态不到 $5\times10^5$，即使显式建图也完全可以接受。

于是时间复杂度为 $O(k(nm)^3)$，其中 $k$ 是一个较小的常数，可以通过。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=105,M=5e5+12;
using ll=long long;
int T,n,m,ct,d[N][N][N],et,f[M];
int hd[M],ed[M*10],to[M*10];
int Hd[M],Ed[M*10],To[M*10];
int q[M*20],L,R;
void ag(int x,int y){
    ed[++et]=y,to[et]=hd[x],hd[x]=et;
    Ed[et]=x,To[et]=Hd[y],Hd[y]=et;
}
vector<int>_O,_X;
bitset<M>vr,Iq;
char s[N*10];
int dfs(int x,int y,int z,int p){
    if(x==y||s[x]||s[y]||s[z])return 0;
    if(x>y)swap(x,y);
    if(d[x][y][z])return d[x][y][z];
    int k=++ct,g;
    f[d[x][y][z]=k]=hd[k]=Hd[k]=0;
    if(vr[k]=p){
        if(x==z||y==z)f[q[++R]=k]=M,Iq[k]=1;
        else{
            if(z%m&&(g=dfs(x,y,z-1,0)))ag(k,g);
            if(z%m<m-1&&(g=dfs(x,y,z+1,0)))ag(k,g);
            if(z/m&&(g=dfs(x,y,z-m,0)))ag(k,g);
            if(!hd[k])f[q[++R]=k]=M,Iq[k]=1;
        }
    }else{
        if(x==z||y==z||!(z/m))f[q[++R]=k]=M,Iq[k]=1;
        else{
            if(x%m&&(g=dfs(x-1,y,z,1)))ag(k,g);
            if(x%m<m-1&&(g=dfs(x+1,y,z,1)))ag(k,g);
            if(x/m&&(g=dfs(x-m,y,z,1)))ag(k,g);
            if(x/m<n-1&&(g=dfs(x+m,y,z,1)))ag(k,g);
            swap(x,y);
            if(x%m&&(g=dfs(x-1,y,z,1)))ag(k,g);
            if(x%m<m-1&&(g=dfs(x+1,y,z,1)))ag(k,g);
            if(x/m&&(g=dfs(x-m,y,z,1)))ag(k,g);
            if(x/m<n-1&&(g=dfs(x+m,y,z,1)))ag(k,g);
            if(!hd[k])f[q[++R]=k]=M,Iq[k]=1;
        }
    }return k;
}
void calc(int x){
    int k=-1e9,rp=f[x];
    for(int i=hd[x];i;i=to[i])
        k<f[ed[i]]&&(k=f[ed[i]]);
    f[x]=k<0?-k-1:k>0?-k+1:0;
    if(f[x]!=rp&&!Iq[x])Iq[q[++R]=x]=1;
}
int main(){
    ios::sync_with_stdio(false);
    int i,j,k,l,r,x,y;
    cin>>k>>T;
    while(T--){
        memset(d,0,sizeof(d));
        memset(f,0,sizeof(f));
        cin>>n>>m,_O.clear(),_X.clear();
        Iq.reset();
        string _s;ct=et=R=0,L=1;
        for(i=0;i<n;++i)
            for(j=0,cin>>_s;j<m;++j){
                s[i*m+j]=(_s[j]=='#');
                if(_s[j]=='O')_O.push_back(i*m+j);
                if(_s[j]=='X')_X.push_back(i*m+j);
            }
        dfs(_O[0],_O[1],_X[0],0);
        while(L<=R){
            x=q[L++];
            for(i=Hd[x];i;i=To[i])calc(Ed[i]);
        }
        if(f[1]<0)printf("Red %d\n",f[1]+M);
        else if(f[1]>0)printf("Black %d\n",M-f[1]);
        else puts("Tie");
    }
    return 0;
}
```

---

## 作者：cymrain07 (赞：9)

细节很多的博弈论毒瘤。

感谢考场上这题没写挂，~~而且 CCF 数据极强~~

一个 ~~笨拙的~~ 设状态方法：设 $(a,b,c,d,e,f,I)$ 表示黑棋的坐标是 $(a,b)$，红棋 $1$ 的坐标是 $(c,d)$，红棋 $2$ 的坐标是 $(e,f)$，当前走棋人是 $I$。

这种方法会设出 $2\times 10^6$ 个状态，常数升天。

设状态 $(a,b,c,d,e,f)$ 表示黑棋的坐标是 $(a,b)$，红棋的坐标是 $(c,d)$ 与 $(e,f)$。

注意这里因为两个红棋本质相同，$(a,b,c,d,e,f)$ 与 $(a,b,e,f,c,d)$ 其实是一种状态，所以我们强制规定 $c<e$ 或 $(c=e,d<f)$。

这样可以把状态数缩小两倍。

状态里为什么没有当前走棋人呢？因为棋子确定的时候，走棋人也就确定了。

> 证明：
>
> 因为走一步就会改变一次曼哈顿距离的奇偶性，所以一个棋子要走到另一个坐标（假如能走到），走的步数的奇偶性一定等于曼哈顿距离的奇偶性。
>
> 所以，现在的状态到初始状态的步数的奇偶性一定等于**三个曼哈顿距离之和**的奇偶性。
>
> 三个曼哈顿距离其实有两种：开始的红棋 $1$ 走到了现在的红棋 $1$，开始的红棋 $2$ 走到了现在的红棋 $2$， 或者开始的红棋 $1$ 走到了现在的红棋 $2$，开始的红棋 $2$ 走到了现在的红棋 $1$。
>
> 而这两种情况的曼哈顿距离之和的奇偶性也是相同的——第二种情况我们让开始的红棋 $1$ 走到开始的红棋 $2$ 的地方，开始的红棋 $2$ 走到开始的红棋 $1$ 的地方，走过的曼哈顿距离相同，所以总曼哈顿距离 $+2d$，奇偶性不变。 
>
> 确定了奇偶性，走棋人也就确定了。

当然，你也可以记录走棋人，状态数本质不会增加，只是清空数组的时候常数变大了一倍。

于是我们成功把状态数压缩到了 $5\times 10^5$。

接下来就是博弈论的内容了。

我们先用 BFS 搜出所有可能到达的状态，没有出度的点一定是必败态，我们将其加入队列。

然后按照队列中的顺序，设队头为 $u$，更新每一个可以到达 $u$ 状态的点 $v$（通过建反图实现）。

- 若 $u$ 为必败态，则 $v$ 一定是必胜态，而且走的步数最少的情况一定是移到状态 $u$（步数的路径：必败态先进入队列 $\to$ 必胜态的最劣解先进入队列 $\to$ 必败态的最优解先进入队列 $\to\cdots\to$ 先到达初始状态），所以更新 $v$，并把 $v$ 加入队列。
- 若 $v$ 能到达的所有状态都是必胜态，则 $v$ 为必败态，取需要获胜步数最多的 $u$ 来更新，并把 $v$ 加入队列。

全部更新完之后，会有一些点没被更新到，则这些点是平局（必定成环）。

最后输出起点的值即可。

注意：

- 黑棋只能走三个方向
- 红棋不能重叠

[参考代码](https://www.luogu.com.cn/paste/bry9cotk)


---

## 作者：船酱魔王 (赞：8)

# 破除心魔记 &P9169 [省选联考 2023] 过河卒 题解

## 前情提要

2023 年 4 月 2 日，联合省选 Day2，死磕 T1 一整场，没调出来，爆零，省选总分全省 rk125。

自从知道出题人是小 E 之后，在 LA 群里频繁地攻击小 E，在别人 NOI 前造谣小 E 被 npy 甩，被群友痛斥“爆零了说明你菜”“小 E 允许你这样说他了吗”。破防了，发了一些颠，也认识到了自己行为的恶劣和菜鸡之处，因此决定补掉这个题。

## 题意回顾

* 一个棋盘尺寸为 $ n \times m $。

* 上面有一些障碍物，两个红棋，一个黑棋。黑棋能向上左右三个方向走，红棋能向上下左右四个方向走。

* 红子先走棋，任何棋子只要吃掉对方中至少一个即可胜利，黑棋到达最上面一行即可胜利，哪一方无路可走即为失败。

* 每方会按照最优策略来，胜利则最小化步数，失败则最大化步数。

* 判断游戏结果（胜利/失败/平局），不平局的话输出步数。

* 多测，$ T $ 组数据。

* $ n,m \le 10 $，$ T \le 10 $，1s，1GB。

## 分析

首先，注意到 $ n,m $ 不大，考虑暴力定义状态，状态有七维，分别是一维 0 或 1 表示这一步轮到谁，三个两维表示三个棋子的位置坐标。

不难发现，棋子们离初始点的距离为奇数时，显然应该黑子走棋，否则红子走棋，因此可以省略一维。

接下来我们考虑哪些状态是合法状态，合法状态中哪些状态是红子已胜态、黑子已胜态、状态未知态。

我们对于每个状态考虑这一步所有的走棋方案，建反向边，即由这个状态的所有走棋可能的下一步状态向它连边。

此时，我们得到了一个有向图，可能带环。

我们把已经决出胜负的状态入队，每次从队列里取出一个结点：

* 如果被取出的结点是当前走棋人必败态，则它在这个图中的所有出边指向的点更新为必胜态并更新最小步数，若没入过队则入队，入度记为负无穷。

* 如果被取出的结点是当前走棋人必胜态，则它在这个图中的所有出边指向的点入度减一，如果不是已经必胜就更新最大步数，如果入度为 $ 0 $ 就入队。

之后输出初始态的胜负情况和步数（如果不是平局的话）即可。

## 注意事项

* 把每个状态编号成一个自然数，减少六维的壮观数组的使用。

* 很多重复出现的东西算一次后存下来。

* 不要弄混胜败，也注意状态的定义是“红子/黑子必胜”还是“当前走棋人必胜/必败”。

* 本题**极其卡常**，请不要使用 ```vector```，每个点最多只有 $ 8 $ 条出边，内存很大，直接用静态二维数组存就行。

* 代码建议注释，这里删去注释是为了本人看着更舒服，实际上在写代码的时候注释挺多的。

* 特判红子重合，及时剪枝非法状态。

* 一个显然的剪枝是当已经从队列里取出初始状态的时候就可以结束循环了。

* 多测必须清空。

* 考试不要死磕 T1，不要对于自己的代码能力过于自信，不要因为你的偏执毁了你整个赛季甚至 OI 生涯。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 12;
const int S = 1111115;
int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};
int qwq, T;
int n, m;
char ch[N][N];
inline int id(int h1x, int h1y, int h2x, int h2y, int b1x, int b1y) {
	return h1x * 100000 + h1y * 10000 + h2x * 1000 + h2y * 100 + b1x * 10 + b1y;
}
int pre[S];
int xhs[S];
inline bool in(int x, int y) {
	return 1 <= x && x <= n && 1 <= y && y <= m;
}
int rd[S];
int stp[S];
bool te[S];
int st, ed;
int num[S];
inline void clear() {
	st = 1;
	ed = 0;
}
inline void push(int x) {
	num[++ed] = x;
}
inline void pop() {
	st++;
}
inline bool empty() {
	return st > ed;
}
inline int front() {
	return num[st];
}
inline int Min(int x, int y) {
	if(x < y) {
		return x;
	}
	return y;
}
inline int Max(int x, int y) {
	if(x > y) {
		return x;
	}
	return y;
}
int dc[N][N][N][N][N][N];
int bian[S][9];
int bs[S];
void link(int x, int y) {
	bs[x]++;
	bian[x][bs[x]] = y;
}
int main() {
	cin >> qwq >> T;
	int awa, tx, ty, tid;
	for(int d1 = 1; d1 <= 10; d1++) {
		for(int d2 = 1; d2 <= 10; d2++) {
			for(int d3 = 1; d3 <= 10; d3++) {
				for(int d4 = 1; d4 <= 10; d4++) {
					for(int d5 = 1; d5 <= 10; d5++) {
						for(int d6 = 1; d6 <= 10; d6++) {
							dc[d1][d2][d3][d4][d5][d6] = id(d1, d2, d3, d4, d5, d6);
						}
					}
				}
			}
		} 
	}
	for(int ti = 1; ti <= T; ti++) {
		cin >> n >> m;
		int hx = 0, hy = 0, rx = 0, ry = 0, sx = 0, sy = 0;
		for(int i = 0; i <= 1111110; i++) {
			pre[i] = xhs[i] = -5;
			rd[i] = 0;
			bs[i] = 0;
			stp[i] = 0;
			te[i] = 0;
		}
		clear();
		for(int i = 1; i <= n; i++) {
			for(int j = 1; j <= m; j++) {
				cin >> ch[i][j];
				if(ch[i][j] == 'O') {
					if(rx + ry == 0) {
						rx = i, ry = j;
					} else {
						sx = i, sy = j;
					}
				} else if(ch[i][j] == 'X') {
					hx = i, hy = j;
				}
			}
		}
		for(int r1x = 1; r1x <= n; r1x++) {
			for(int r1y = 1; r1y <= m; r1y++) {
				if(ch[r1x][r1y] == '#') {
					continue;
				}
				for(int r2x = 1; r2x <= n; r2x++) {
					for(int r2y = 1; r2y <= m; r2y++) {
						if(ch[r2x][r2y] == '#' || (r2x == r1x && r2y == r1y)) {
							continue;
						}
						for(int b1x = 1; b1x <= n; b1x++) {
							for(int b1y = 1; b1y <= m; b1y++) {
								if(ch[b1x][b1y] == '#') {
									continue;
								}
								tid = dc[r1x][r1y][r2x][r2y][b1x][b1y];
								xhs[tid] = (r1x - rx) + (r1y - ry) + (r2x - sx) + (r2y - sy) + (b1x - hx) + (b1y - hy);
								xhs[tid] = (xhs[tid] % 2 + 2) % 2;
								if(b1x == 1) {
									pre[tid] = -1;
									push(tid);
								} else if((r1x == b1x && r1y == b1y) || (r2x == b1x && r2y == b1y)) {
									pre[tid] = xhs[tid] * 2 - 1;
									push(tid);
								} else {
									pre[tid] = 0;
								}
							}
						}
					}
				}
			} 
		}
		for(int r1x = 1; r1x <= n; r1x++) {
			for(int r1y = 1; r1y <= m; r1y++) {
				if(ch[r1x][r1y] == '#') {
					continue;
				}
				for(int r2x = 1; r2x <= n; r2x++) {
					for(int r2y = 1; r2y <= m; r2y++) {
						if(ch[r2x][r2y] == '#' || (r2x == r1x && r2y == r1y)) {
							continue;
						}
						for(int b1x = 1; b1x <= n; b1x++) {
							for(int b1y = 1; b1y <= m; b1y++) {
								if(ch[b1x][b1y] == '#') {
									continue;
								}
								tid = dc[r1x][r1y][r2x][r2y][b1x][b1y];
								if(pre[tid] != 0) {
									continue;
								}
								if(xhs[tid] == 0) {
									for(int k = 0; k < 4; k++) {
										tx = r1x + dir[k][0];
										ty = r1y + dir[k][1];
										if(in(tx, ty) && ch[tx][ty] != '#') {
											awa = dc[tx][ty][r2x][r2y][b1x][b1y];
											if(pre[awa] != -5) {
												link(awa, tid);
												rd[tid]++;
											}
										}
										tx = r2x + dir[k][0];
										ty = r2y + dir[k][1];
										if(in(tx, ty) && ch[tx][ty] != '#') {
											awa = dc[r1x][r1y][tx][ty][b1x][b1y];
											if(pre[awa] != -5) {
												link(awa, tid);
												rd[tid]++;
											}
										}
									}
								} else {
									for(int k = 0; k < 3; k++) {
										tx = b1x + dir[k][0];
										ty = b1y + dir[k][1];
										if(in(tx, ty) && ch[tx][ty] != '#') {
											awa = dc[r1x][r1y][r2x][r2y][tx][ty];
											if(pre[awa] != -5) {
												link(awa, tid);
												rd[tid]++;
											}
										}
									}
								}
								if(rd[tid] == 0) {
									pre[tid] = xhs[tid] * 2 - 1;
									push(tid);
								}
							}
						}
					}
				}
			} 
		}
		int nxt, now;
		int sd = dc[rx][ry][sx][sy][hx][hy];
		while(!empty()) {
			now = front();
			pop();
			if(now == sd) {
				break;
			}
			if(pre[now] == 1 && xhs[now] == 1) {
				for(int i = 1; i <= bs[now]; i++) {
					nxt = bian[now][i];
					if(pre[nxt] != 1) {
						stp[nxt] = stp[now] + 1;
						pre[nxt] = 1;
						push(nxt);
						rd[nxt] = -1;
					} else {
						stp[nxt] = Min(stp[nxt], stp[now] + 1);
					}
				}
			} else if(pre[now] == -1 && xhs[now] == 0) {
				for(int i = 1; i <= bs[now]; i++) {
					nxt = bian[now][i];
					if(pre[nxt] != -1) {
						stp[nxt] = stp[now] + 1;
						pre[nxt] = -1;
						push(nxt);
						rd[nxt] = -1;
					} else {
						stp[nxt] = Min(stp[nxt], stp[now] + 1);
					}
				}
			} else {
				for(int i = 1; i <= bs[now]; i++) {
					nxt = bian[now][i];
					if(pre[nxt] == 0) {
						rd[nxt]--;
						if(rd[nxt] == 0) {
							push(nxt);
							pre[nxt] = pre[now];
							if(te[nxt]) {
								pre[nxt] = 0;
							}
						}
						stp[nxt] = Max(stp[nxt], stp[now] + 1);
					}
				}
			}
		}
		if(pre[sd] == 1) {
			cout << "Red " << stp[sd] << endl;
		} else if(pre[sd] == -1) {
			cout << "Black " << stp[sd] << endl;
		} else {
			cout << "Tie" << endl;
		}
	}
	return 0;
}
```

## 结语

11 个小时，24 发提交，终于过了这个题。

比赛结束后三个月，用了一整天补完了这道 d2t1。

我代码的能力得到了锻炼，多过了一道紫题。同时，我也填补了省选赛场上没调出来这个题的遗憾，破除了缠绕已久的心魔。

愿写这篇题解的人和看到这篇题解的人的 OI 之路上，不要再因为任何原因发挥出远低于自己水平的成绩。

后面几年省选，让我们一起加油。

另外，表白毒瘤卡常大模拟出题人 E_Space。

就说这么多吧。

（本文完）

---

## 作者：ckain (赞：8)

有向图博弈问题。

考虑用六元组 $(x_{r1},y_{r1},x_{r2},y_{r2},x_b,y_b)$ 描述一个局面中三个棋子的坐标。易得知，六元组个数不超过 $1e6$，可以枚举出来。

因为每次操作都会移动某一颗棋子，进而使其与其初始位置的曼哈顿距离的奇偶性改变；所以通过当前局面三个坐标和初始局面三个坐标曼哈顿距离的和的奇偶性可以判断出下一步是红方还是黑方操作，而不用加另外的标记。

考虑将六元组视作点，向后继（即后文的 后继状态，表示对当前局面操作后的下一个局面）的转移视作边（对于黑子已经到达第一行的状态，不向后继连边），建出博弈图，问题就转化为经典的有向图博弈问题（两人交替移动有向图中的一点，无法移动的人输）。

具体做法：  
反向建图，然后使用类似拓扑排序的思路用队列更新以每个点开始的输赢状态。  
规定必败状态为 $P$ 态，必胜状态为 $N$ 态。先将入度为 $0$ 的 $P$ 态点加入队列。每次取出队首的点 $u$，若 $u$ 连向的点 $v$ 的后继状态中存在 $P$ 态，则 $v$ 为 $N$ 态；若 $v$ 的后继状态都为 $N$ 态，则 $v$ 为 $P$ 态，若 $v$ 确定了状态，把 $v$ 加入队列。对于最终未能确定 $N$ 或 $P$ 态的点，它平局。  
接下来考虑更新步数的方法：$N$ 态点的步数是在队列中第一个后继 $P$ 态点的步数 $+1$，$P$ 态点的步数是在队列中最后一个后继 $N$ 态点的步数 $+1$。  
以下是我个人的一些理解：
在已知状态的点的队列中从前往后，$N$ 态点的步数不减，$P$ 态点的步数不减。可以这样想：对于在队列中步数不减的 $N$ 态点，依次扫描它们得到的新的 $P$ 态点步数不减，且按照顺序插入队列中，扫描 $P$ 态点得到新的 $N$ 态点也是同理。

题目到这里，算法基本完成。但需要一些常数优化。在枚举两个红子时，注意到顺序无影响，于是强行令 $x_{r1} \le x_{r2}$。状态数减少许多，可以通过。

code:
```cpp
#include<bits/stdc++.h>
#define pii pair<int, int>
#define fr first
#define sc second
#define For(i, sta, ed) for(i=sta; i<=ed; i++)
using namespace std;
inline int rd(void){
	int s=0, f=1; char c=getchar();
	while(c<'0' || c>'9') {if(c=='-') f=0; c=getchar();}
	while(c>='0' && c<='9') {s=s*10+c-'0'; c=getchar();}
	return f? s:-s;
}
const int N=1e6+5;
const int dx[]={0, 0, -1, 1}, dy[]={1, -1, 0, 0};
int id, T, n, m;
char mp[11][11];
pii sr1, sr2, sb;

int Num[11][11][11][11][11][11], tot;
#define num(r1, r2, b) (Num[r1.fr][r1.sc][r2.fr][r2.sc][b.fr][b.sc])
struct Node{pii r1, r2, b;}  pos[N];

inline bool inthe(pii x){return x.fr>0 && x.fr<=n && x.sc>0 && x.sc<=m;}
inline bool check(pii r1, pii r2, pii b){return inthe(r1) && inthe(r2) && inthe(b) && mp[r1.fr][r1.sc]!='#' && mp[r2.fr][r2.sc]!='#' && mp[b.fr][b.sc]!='#' && r1!=r2;}

vector<int> e[N]; int in[N];
int q[N], hd, tl;
int fwn[N], stp[N];

inline void topo(){
	memset(stp, 63, sizeof(stp));
	hd=1, tl=0;
	for(int i=1; i<=tot; i++) if(!in[i]) fwn[i]=-1, stp[i]=0, q[++tl]=i;
	while(tl>=hd){
		int u=q[hd++];
		for(int v:e[u]){
			if(fwn[u]==-1 && !fwn[v]) fwn[v]=1, stp[v]=stp[u]+1, q[++tl]=v;
			else if(fwn[u]==1 && !fwn[v] && !--in[v]) fwn[v]=-1, stp[v]=stp[u]+1, q[++tl]=v;
		}
	}
}

signed main(){
	id=rd(); T=rd();
	while(T--){
		n=rd(), m=rd();
		for(int i=1; i<=n; i++){
			scanf("%s", mp[i]+1);
			for(int j=1; j<=m; j++){
				if(mp[i][j]=='X') sb={i, j};
				else if(mp[i][j]=='O') sr1.fr? sr2={i, j}:sr1={i, j};
			}
		}
		pii r1, r2, b;
		For(r1.fr, 1, n) For(r1.sc, 1, m){
			For(r2.fr, r1.fr, n) For(r2.sc, 1, m){
				For(b.fr, 1, n) For(b.sc, 1, m){
					if(check(r1, r2, b)) num(r1, r2, b)=++tot, pos[tot]={r1, r2, b};
				}
			}
		}
		for(int i=1; i<=tot; i++){
			r1=pos[i].r1, r2=pos[i].r2, b=pos[i].b;
			if(r1==b || r2==b || b.fr==1) continue;
			if((abs(r1.fr-sr1.fr)+abs(r1.sc-sr1.sc)+abs(r2.fr-sr2.fr)+abs(r2.sc-sr2.sc)+abs(b.fr-sb.fr)+abs(b.sc-sb.sc))&1){
				for(int j=0; j<3; j++){
					pii nb={b.fr+dx[j], b.sc+dy[j]};
					if(check(r1, r2, nb)) e[num(r1, r2, nb)].push_back(i), in[i]++;
				}
			}
			else for(int j=0; j<4; j++){
				pii nr={r1.fr+dx[j], r1.sc+dy[j]};
				if(check(nr, r2, b)) e[nr.fr>r2.fr? num(r2, nr, b):num(nr, r2, b)].push_back(i), in[i]++;
				nr={r2.fr+dx[j], r2.sc+dy[j]};
				if(check(r1, nr, b)) e[nr.fr>r1.fr? num(r1, nr, b):num(nr, r1, b)].push_back(i), in[i]++;
			}
		}
		topo();
		int s=num(sr1, sr2, sb);
		if(fwn[s]==1) printf("Red %d\n", stp[s]);
		else if(fwn[s]==-1) printf("Black %d\n", stp[s]);
		else puts("Tie");
		
		memset(in, 0, sizeof(in));
		memset(fwn, 0, sizeof(fwn));
		for(int i=1; i<=tot; i++) e[i].clear();
		tot=0;
		sr1.fr=0;
	}
	return 0;
}
```

---

## 作者：cyffff (赞：4)

[$\text{Link}$](https://www.luogu.com.cn/problem/P9169)

十分考验代码实现能力。
## 题意
一个 $n\times m$ 的棋盘，有的位置有障碍物。有两个红子和一个黑子。对于一个红子 $(x,y)$，移动一次可以走到 $(x±1,y)$ 或 $(x,y±1)$，对于一个黑子，移动一次可以走到 $(x-1,y)$ 或 $(x,y±1)$。需要保证移动后还在地图内且不在障碍物上。两个红子不能重叠。双方轮流执子，红方为先手，红方每次可挑一个棋子进行移动。

在一次移动前，按照以下顺序判定胜负：
- 黑子处在 $x=1$，黑方胜；
- 一个红子和黑子在同一位置上，本次移动方负；
- 本次移动方无棋子可移动，本次移动方负；
- 都不满足则由本次移动方执行本次移动。

假设双方均采用最优策略，在可获胜时希望总移动步数最少，否则希望总移动步数最多。如果游戏无法结束则判定平局。

$T$ 组数据，给出地图，求获胜方、总移动步数或判定平局。

$1\le T,n,m\le 10$。

## 思路

对于三个棋子，分别记作 $r_1,r_2,b$。求出三个棋子所在连通块的所有点，列出所有可能存在的局面（包含三个点的位置和先手，显然上限是 $O(n^3m^3)$ 种），在局面内建边 $t\to s$ **表示 $s$ 局面一次移动后可以转移到 $t$ 局面**。建反向边的原因是 $s$ 会决策走到哪个局面更好，当 $t$ 决策完了可以更好地更新 $s$ 的决策。

考虑求出所有点最优方案，考虑一个 bfs 和拓扑排序的融合东西，维护一个队列，存当前决策完了的所有点。初始时队列里的点是所有的结束结点（在这个局面移动之前已经判定胜负）。维护每个点获胜方和结束步数 $p_i$。

考虑一个点 $t$ 去更新点 $s$：
- 如果 $s$ 目前没有使得 $s$ 先手胜利的方案：
	- 如果 $t$ 中获胜的是 $s$ 的后手：$p_s\gets p_t+1$，因为是 bfs，所以此时 $p_t+1$ 肯定不小于 $p_s$；
   - 否则：$p_s\gets p_t+1$，并标记 $s$ 已经找到使得先手胜利的方案；
- 否则：由于是 bfs，即使 $t$ 中获胜的是 $s$ 的先手，此时的 $p_t+1$ 也更新不了 $p_s$。

所以当一个点被决策完毕当且仅当满足两条件之一：
- 入度为 $0$；
- 第一次找到使得先手胜利的方案。

满足两条件之一时将其加入队列即可。

如果初始局面的结点没有被决策完毕，则必定平局，否则根据获胜方判断即可。时间复杂度 $O(Tn^3m^3)$。

注意些卡常手段：
- `vector` 开 $2\times 10^6$ 比较难接受，建议使用链式前向星。
- 不要使用 `map` 使复杂度退化，局面最多只有 $2\times 10^6$，可以直接存。
- 要求 $r_1$ 横坐标比 $r_2$ 横坐标小可以减少状态数。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
//read(),getc()
const int N=10+2,M=1e6+10,INF=1e9;
int id,T,n,m,cnt;
bool ok[N][N],vis[N][N];
struct Point{
	int x,y;
	Point(){x=y=0;}
	Point(int a,int b){x=a,y=b;}
	inline friend bool operator==(const Point &a,const Point &b){
		return a.x==b.x&&a.y==b.y;
	}
	inline friend bool operator<(const Point &a,const Point &b){
		return a.x<b.x||a.x==b.x&&a.y<b.y;
	}
}stk[3][N*N];
int top[3];
inline bool checkR(int x,int y){
	return ok[x-1][y]|ok[x][y+1]|ok[x][y-1]|ok[x+1][y];
}
inline bool checkB(int x,int y){
	return ok[x-1][y]|ok[x][y+1]|ok[x][y-1];
}
inline bool checkR(Point tmp1,Point tmp2){
	ok[tmp1.x][tmp1.y]=ok[tmp2.x][tmp2.y]=0;
	bool tmp=checkR(tmp1.x,tmp1.y)||checkR(tmp2.x,tmp2.y);
	ok[tmp1.x][tmp1.y]=ok[tmp2.x][tmp2.y]=1;
	return tmp;
}
inline bool checkB(Point tmp){
	return checkB(tmp.x,tmp.y);
}
int DX[]={1,0,0,-1},DY[]={0,-1,1,0};
inline void bfs(Point st,int ty){
	for(int i=0;i<=n+1;i++)
		for(int j=0;j<=m+1;j++)
			vis[i][j]=!ok[i][j];
	queue<Point>q;
	q.push(st);
	vis[st.x][st.y]=1;
	top[ty]=0;
	while(!q.empty()){
		Point tmp=q.front();
		stk[ty][++top[ty]]=tmp;
		q.pop();
		int px=tmp.x,py=tmp.y;
		for(int i=!ty;i<=3;i++){
			int nx=px+DX[i],ny=py+DY[i];
			if(vis[nx][ny]) continue;
			vis[nx][ny]=1;
			q.push(Point(nx,ny));
		}
	}
}
int fr[M*2];
struct Edge{
	int to,nxt;
}a[M*14];
int head[M*2],ent;
int deg[M*2];
short edn[M*2],stp[M*2];
bool vi2[M*2],fin[M*2],vi3[M*2];
int ind[2][M*2];
inline void upd(short &x,int y){
	if(!x) x=y;
}
inline void add(int u,int v){
	if(!u||!v) return ;
	ent++;
	a[ent].to=u;
	a[ent].nxt=head[v];
	head[v]=ent;
	deg[u]++;
}
inline int cng(int a,int b,int c,int d,int e,int f){
	return f+11*(e+11*(d+11*(c+11*(b+11*a))));
}
inline int get(Point a,Point b,Point c,int fr){
	if(b<a) swap(a,b);
	return ind[fr-1][cng(a.x,a.y,b.x,b.y,c.x,c.y)];
}
inline void upd(Point a,Point b,Point c,int fr,int cnt){
	if(b<a) swap(a,b);
	ind[fr-1][cng(a.x,a.y,b.x,b.y,c.x,c.y)]=cnt;
}
inline int get2(Point a,Point b,Point c){
	return vi3[cng(a.x,a.y,b.x,b.y,c.x,c.y)];
}
inline void upd2(Point a,Point b,Point c,int cnt){
	vi3[cng(a.x,a.y,b.x,b.y,c.x,c.y)]=cnt;
}
int main(){
//	freopen("P9169_14.in","r",stdin);
//	freopen("zu.out","w",stdout);
	id=read(),T=read();
	while(T--){
		n=read(),m=read();
		for(int i=0;i<=n+1;i++)
			for(int j=0;j<=m+1;j++)
				ok[i][j]=0;
		Point r1,r2,b;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++){
				char ch=getc();
				if(ch!='#') ok[i][j]=1;
				if(ch=='X') b.x=i,b.y=j;
				if(ch=='O'){
					Point tmp(i,j);
					if(r1.x) r2=tmp;
					else r1=tmp;
				}
			}
		bfs(r1,1),bfs(r2,2),bfs(b,0);
		cnt=0;
		for(int i=1;i<=top[1];i++)
			for(int j=1;j<=top[2];j++){
				Point R1=stk[1][i],R2=stk[2][j];
				if(R1==R2) continue;
				if(R2<R1) swap(R1,R2);
				for(int k=1;k<=top[0];k++){
					Point B=stk[0][k];
					if(get(R1,R2,B,1)) continue;
//					Statu tmp0(R1,R2,B,1),tmp1(R1,R2,B,2);
					fr[++cnt]=1,upd(R1,R2,B,1,cnt),upd2(R1,R2,B,0);
					fr[++cnt]=2,upd(R1,R2,B,2,cnt);
					edn[cnt]=edn[cnt-1]=deg[cnt]=deg[cnt-1]=vi2[cnt-1]=vi2[cnt]=fin[cnt-1]=fin[cnt]=0;
					if(B.x==1) upd(edn[cnt-1],2),upd(edn[cnt],2),fin[cnt-1]=fin[cnt]=1;
					if(R1==B||R2==B) upd(edn[cnt-1],2),upd(edn[cnt],1),fin[cnt-1]=fin[cnt]=1;
					if(!checkR(R1,R2)) upd(edn[cnt-1],2),fin[cnt]=1;
					if(!checkB(B)) upd(edn[cnt],1),fin[cnt]=1;
					upd(edn[cnt-1],2),upd(edn[cnt],1);
				}
			}
		ent=0;
		for(int i=1;i<=cnt;i++)
			head[i]=0;
		int i=0;
		for(int i0=1;i0<=top[1];i0++)
			for(int j=1;j<=top[2];j++){
				Point r1=stk[1][i0],r2=stk[2][j];
				if(r1==r2) continue;
				if(r2<r1) swap(r1,r2);
				for(int k=1;k<=top[0];k++){
					Point b=stk[0][k];
					if(get2(r1,r2,b)) continue;
					upd2(r1,r2,b,1);
					i++;
					if(!fin[i]){
						int px=r1.x,py=r1.y;
						for(int j=0;j<4;j++){
							int nx=px+DX[j],ny=py+DY[j];
							add(i,get(Point(nx,ny),r2,b,2));
						}
						px=r2.x,py=r2.y;
						for(int j=0;j<4;j++){
							int nx=px+DX[j],ny=py+DY[j];
							add(i,get(r1,Point(nx,ny),b,2));
						}
					}
					i++;
					if(!fin[i]){
						int px=b.x,py=b.y;
						for(int j=1;j<4;j++){
							int nx=px+DX[j],ny=py+DY[j];
							add(i,get(r1,r2,Point(nx,ny),1));
						}
					}
				}
			}
		memset(ind,0,sizeof(ind));
		queue<int>q;
		for(int i=1;i<=cnt;i++)
			stp[i]=0,vi2[i]=0;
		for(int i=1;i<=cnt;i++)
			if(!deg[i]) q.push(i),vi2[i]=1;
		while(!q.empty()&&!vi2[1]){
			int P=q.front();q.pop();
			short x=stp[P]+1;
			for(int i=head[P];i;i=a[i].nxt){
				int tmp=a[i].to;
				if(vi2[tmp]) continue;
				if(fr[tmp]==2){
					if(edn[tmp]==1){
						if(edn[P]!=2) stp[tmp]=x;
						else{
							stp[tmp]=x,edn[tmp]=2;
							if(!vi2[tmp]) vi2[tmp]=1,q.push(tmp);
						}
					}
				}else{
					if(edn[tmp]==2){
						if(edn[P]!=1) stp[tmp]=x;
						else{
							stp[tmp]=x,edn[tmp]=1;
							if(!vi2[tmp]) vi2[tmp]=1,q.push(tmp);
						}
					}
				}
				deg[tmp]--;
				if(deg[tmp]==0&&!vi2[tmp]) vi2[tmp]=1,q.push(tmp);
			}
		}
		if(vi2[1]){
			if(edn[1]==1) printf("Red %d\n",stp[1]);
			else printf("Black %d\n",stp[1]);
		}else puts("Tie");
	}
}
```


---

## 作者：Shapy_UI_Tools (赞：4)

## 前言
要理解本题，最好掌握拓扑排序。

需要比较高的代码调试能力。
## 题意
两个人下棋，一个人有俩红棋，另一个人有一个黑棋，红棋先走。每次红棋**任选一个**移动，黑棋只有一个所以只能移动这一个；红棋可以往四个方向移动，但是两个红棋不能移到一起；黑棋可以往上、左、右移动，**不能往下**，移到最上面一排就赢了。一个棋可以移动到对方的棋的身上把它吃掉，只要吃掉别人**一次**就直接获胜，或者说只要被吃掉**一次**就直接输（也就是说如果红棋之一被吃了也是直接输而不是用另外一个棋继续移动）。

特别地，如果轮到某一方的时候这一方动不了了，另一方赢。

如果每一方都无法通过任何策略把对方逼死，即双方会一直僵持，则判定为平局。
## 解法
典型的博弈论 dp 题。

先求出**黑棋**、**一颗红棋**，**另一颗红棋**分别的初始的 $x$、$y$ 坐标，分别为 $(stx_1,sty_1),(stx_2,sty_2),(stx_3,sty_3)$。

我们注意到 $n,m\le10$，所以可以开六维状态，分别存储**黑棋**、**一颗红棋**，**另一颗红棋**的 $x$、$y$ 坐标，分别为 $(x_1,y_1),(x_2,y_2),(x_3,y_3)$，总空间 $O(n^3m^3)$。
```cpp
bool f[N][N][N][N][N][N];//三个点的坐标分别为此时，是否先手（红棋）必胜。
```
 _**注意：$f$ 存储的是是否先手（红棋）必胜，而不是是否当前操作者必胜。**_ 

 _**注意：一定不要把三个坐标搞混，下标为1的为黑棋，另外两个是红棋。**_ 

显然我们需要知道在一个状态是轮到谁走了，不过我们并不需要新开一维状态去存储，因为我们可以通过前六维来计算出是轮到谁走了。具体地，我们计算一个值 $x=\left|\sum\limits_{i=1}\limits^{3}(x_i-stx_i)+(y_i-sty_i)\right|$，**容易证明，每次有某颗棋子移动，$x$ 的奇偶性都会变化**，恰好每次都是一个人将一颗棋子移动一次，所以设 $cur=x\bmod2$，于是，如果 $cur=0$，则表示轮到红棋走了；如果 $cur=1$，则表示轮到黑棋走了。

 _**注意：轮到 $a$ 走是指在当前状态时，应该由 $a$ 走以转移到下一个状态，而不是由 $a$ 走转移到当前状态。**_ 

根据 $cur$ 的定义，再进行举例分析，易得：
1. 如果 $f_{x_1,y_1,x_2,y_2,x_3,y_3}=cur$，则当前进行操作的人必败。
2. 如果 $f_{x_1,y_1,x_2,y_2,x_3,y_3}\ne cur$，则当前进行操作的人必胜。

所以可以得出所有游戏结束的局面是谁胜谁负：
1. 有一个黑棋和一个红棋重叠，则 $cur\to f_{x_1,y_1,x_2,y_2,x_3,y_3}$。（因为可以推出最后一步是谁走的，换句话说，是谁把谁吃掉的）。
2. 有一个黑棋在第一行，则 $f_{x_1,y_1,x_2,y_2,x_3,y_3}$ 为先手必败。（因为黑棋已经赢了，红棋不用走就已经输了，红棋显然必败）。
![](https://i.postimg.cc/nV07kVs7/image.png)
3. 如图所示，黑棋上、左、右均为障碍或场地边缘，则 $f_{x_1,y_1,x_2,y_2,x_3,y_3}$ 为先手必胜。（因为黑棋已经无法操作了，而题目说无法操作的玩家输，所以红棋必赢）。

而博弈论有一个显然的结论：
1. 如果操作者可以从局面 $X$ 走到一个自己的必胜局面，则 $X$ 为该操作者必胜局面。
2. 如果操作者从局面 $X$ 可以走到的任何一个局面均为自己的必败局面，则 $X$ 为该操作者必败局面。

所以可以得出状态转移方程：

$f_{x_1,y_1,x_2,y_2,x_3,y_3}=\sum\limits_{tx_1,ty_1,tx_2,ty_2,tx_3,ty_3}[f_{tx_1,ty_1,tx_2,ty_2,tx_3,ty_3}=cur_2]\oplus cur_1$。

这里的 $\sum$ 表示求或和。

 _**注意：此处的 $cur_1$ 通过 $x$ 和 $y$ 计算，$cur_2$ 通过 $tx$ 和 $ty$ 计算。**_ 

这个转移方程非常不好用，实际代码中，我们一旦一个状态 $f_{x_1,y_1,x_2,y_2,x_3,y_3}=cur$ 就将这个状态能转移到的所有状态的答案赋值为 $f_{x_1,y_1,x_2,y_2,x_3,y_3}$。

但是有一个问题，这个 dp 的转移顺序不是简单的，当要求某一个状态的答案，从其他状态转移到这个状态时，其他状态并不能保证均已处理完毕。**所以我们利用拓扑排序的思想，我们计算每一个状态能由多少个状态转移到**，这个值相当于图论中的「入度」。每次一个状态的答案被计算出了，我们就把这个状态能转移到的所有状态的「入度」减一。那么，如果一个状态的「入度」被减为 $0$ 了，就相当于能转移到这个状态的所有状态的答案全部计算完毕了，这个状态的答案也就可以计算出来了。至于实现，同样类似拓扑排序，我们把「入度」为 $0$ 的状态加入队列，每次弹出队首元素计算答案即可。

如果队列已经空了，$f_{stx_1,sty_1,stx_2,sty_2,stx_3,sty_3}$ 仍然没有转移到，即「入度」仍然没有减为 $0$，根据拓扑排序的性质，转移出现了环，也就是双方最优策略是反复横跳僵持，谁先进攻谁死。

至此，我们已经解决了计算一场游戏是谁赢的问题。但是这道题很毒瘤，它甚至要求你求出双方按照 _“能赢就快点赢，必输就慢点输”_ 的策略进行游戏的回合数。那我们就在 dp 过程中同时维护一个 $dis$ 数组。
```cpp
int dis[N][N][N][N][N][N];//从此局面一直进行到游戏结束，进行的回合数。
```
对于每一种游戏结束的局面，我们都可以求出 $dis$。
1. 有一个黑棋和一个红棋重叠，$dis_{x_1,y_1,x_2,y_2,x_3,y_3}\gets0$。
2. 有一个黑棋在第一行，$dis_{x_1,y_1,x_2,y_2,x_3,y_3}\gets0$。
3. 黑棋上、左、右均为障碍或场地边缘，$dis_{x_1,y_1,x_2,y_2,x_3,y_3}\gets cur\oplus1$。(这种情况要使用 $cur$ 判断现在该谁走了，如果该红棋走了还能走一步，如果该黑棋走了因为走不动就直接游戏结束了)。

对于每一个状态：
1. 如果此时应该行动的人必败：$dis_{x_1,y_1,x_2,y_2,x_3,y_3}\gets\max dis_{tx_1,ty_1,tx_2,ty_2,tx_3,ty_3}+1$。
2. 如果此时应该行动的人必胜：$dis_{x_1,y_1,x_2,y_2,x_3,y_3}\gets\min dis_{tx_1,ty_1,tx_2,ty_2,tx_3,ty_3}+1$。(对于这种情况，$tx$、$ty$ 所对应的局面应当是操作者必胜局面)

通俗来讲，如果一个人在这里必败，那么在能走到的所有必败局面中选择一个回合数最多的必败局面；如果一个人在这里必胜，那么在能走到的所有必胜局面中选择一个回合数最少的必胜局面。

至于转移顺序，与 $f$ 相同，不再赘述。

然后这道题就写完了，总时间复杂度 $O(n^3m^3)$（~~真的有这么简单吗~~）。
## 代码
首先我强烈建议代码自己写，因为我的代码又臭又长，各种地方乱七八糟根本不具有可读性。在我看来，只要思路理解了，代码总可以自己写出来的。这份代码仅供参考。

[云剪贴板](https://www.luogu.com.cn/paste/pupdr5es)

---

## 作者：Mine_King (赞：3)

## Problem

[P9169 [省选联考 2023] 过河卒](https://www.luogu.com.cn/problem/P9169)

**题目大意：**

有一个 $n \times m$ 的棋盘，每个格子是空地或障碍，棋盘上有两个红子和一个黑子。红子每次可以向上下左右移动一格，前提是目标格子不是障碍或另一个红子。黑子每次可以向上左右移动一格，前提是目标格子不是障碍。    
红方和黑方轮流决策，红方先走。

游戏结束判定为：

- 若当前黑子在第一行，则黑方胜利。
- 若黑子与某个红子在同一个格子，则上一步移动的玩家胜利。
- 若当前玩家无法进行任何操作，则另一方胜利。

双方决策相同，均为：

- 若有必胜策略，则选择步数最少的策略。
- 若没有必胜策略，但存在无论对方无法移动，自己都不会败的策略，则选择这个策略。
- 若不满足上面两种条件，则选择不数最多的策略。

求最终获胜方和总步数。

若永远无法结束游戏，则输出 `Tie`。

## Solution

虽然不是公平组合游戏，但也能用类似于 $\verb|SG|$ 函数的做法来解决。

发现棋盘状态只与当前每个棋子的位置有关，且棋盘很小，故考虑用 $(rx_1, ry_1, rx_2, ry_2, bx, by)$ 表示当前局面三个棋子的位置。  
由于不是公平博弈，故还要增加一维表示当前先手是哪一方。故状态为 $(rx_1, ry_1, rx_2, ry_2, bx, by, 0 / 1)$。其中最后一维 $0$ 表示先手是红方，$1$ 表示先手是黑方。其意义为当前局面到游戏结束所需的步数。

然后建出博弈图。

考虑由最终状态推出其他状态。然而图不是 $\verb|DAG|$，所以要考虑环上的点怎么处理。  
这是一个经典的问题。若环上的点是必败的，则可以用他来更新别的点。否则，不能用他更新别的点。

对于状态之间的更新：

- 若被更新状态为必胜状态，则取最小值，并且在第一次更新时即可入队列。
- 若被更新状态为必败状态，则取最大值，并且在最后一次更新时才能入队列。

对于必胜和必败的判定：若步数为奇数，则为必胜状态。若步数为偶数，则为必败状态。

对于无法被推出状态的点，其结果为 `Tie`。

复杂度为 $O(|V| + |E|)$，其中 $V$ 为博弈图的点集，$E$ 为博弈图的边集。

然而随手一算发现极限情况要跑很多遍，加上各种各样的常数，直接来绝对过不去。于是考虑卡常。

首先可以省略建博弈图的过程，用隐式建图。  
然后发现两个红子本质相同，所以可以减去一半的状态。  
$\verb|bfs|$ 时若当前状态为题目询问的初始状态则立即停止。  
事实证明开七维数组比压到一维的寻址更快。

另外发现游戏结束除了第三种情况，另外两种都有连向其他状态的边，所以实现时需要标记结束状态的点保证其不会被更新。

## Code

代码略丑。

```cpp
// Think twice, code once.
#include <cmath>
#include <queue>
#include <cstdio>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
#define SG(x) sg[x.rx1][x.ry1][x.rx2][x.ry2][x.bx][x.by][x.f]
#define IN(x) in[x.rx1][x.ry1][x.rx2][x.ry2][x.bx][x.by][x.f]
#define VIS(x) vis[x.rx1][x.ry1][x.rx2][x.ry2][x.bx][x.by][x.f]
// 这样可以避免写一长串状态。
// 但是注意不要写成函数的形式（如 int &SG(x) {return ...;}），因为调用函数常数较大，而宏定义则在编译时完成替换，不影响常数。
using namespace std;

const int grx[] = {1, -1, 0, 0}, gry[] = {0, 0, -1, 1};
const int gbx[] = {-1, 0, 0}, gby[] = {0, -1, 1};
// 这些数组分别表示红子和黑子的移动。

int ID, T, n, m, srx1, sry1, srx2, sry2, sbx, sby;
int sg[11][11][11][11][11][11][2], in[11][11][11][11][11][11][2], vis[11][11][11][11][11][11][2];
// 三个数组分别存结果、度数、是否为结束状态。
char ch[15][15];
struct node { // 将状态用结构体存起来可以使代码更简洁。
	int rx1, ry1, rx2, ry2, bx, by, f;

	node() = default;
	node(int _rx1, int _ry1, int _rx2, int _ry2, int _bx, int _by, int _f): rx1(_rx1), ry1(_ry1), rx2(_rx2), ry2(_ry2), bx(_bx), by(_by), f(_f) {}
	bool operator==(const node &x) const {
		return rx1 == x.rx1 && ry1 == x.ry1 && rx2 == x.rx2 && ry2 == x.ry2 && bx == x.bx && by == x.by && f == x.f;
	}
};

int check(int xx, int yy) {
	return 1 <= xx && xx <= n && 1 <= yy && yy <= m && ch[xx][yy] !='#';
}

int main() {
	// freopen("zu.in", "r", stdin);
	// freopen("zu.out", "w", stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> ID >> T;
	while (T--) {
		cin >> n >> m;
		srx1 = 0;
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= m; j++) {
				cin >> ch[i][j];
				if (ch[i][j] == 'O') {
					if (!srx1) srx1 = i, sry1 = j;
					else srx2 = i, sry2 = j;
				} else if (ch[i][j] == 'X') sbx = i, sby = j;
			}
		queue<node> q;
		for (int rx1 = 1; rx1 <= n; rx1++) // 预处理出每个点的度数和结束状态。
			for (int ry1 = 1; ry1 <= m; ry1++) if (ch[rx1][ry1] != '#')
				for (int rx2 = rx1; rx2 <= n; rx2++)
					for (int ry2 = (rx2 == rx1 ? ry1 + 1 : 1); ry2 <= m; ry2++) if (ch[rx2][ry2] != '#')
						for (int bx = 1; bx <= n; bx++)
							for (int by = 1; by <= m; by++) if (ch[bx][by] != '#')
								for (int f = 0; f < 2; f++) {
									sg[rx1][ry1][rx2][ry2][bx][by][f] = 0;
									in[rx1][ry1][rx2][ry2][bx][by][f] = 0;
									vis[rx1][ry1][rx2][ry2][bx][by][f] = 0;
                                    // 初始化。
									if (f == 0) { // 红方先。
										if (bx == 1) { // 黑子在第一行
											q.emplace(rx1, ry1, rx2, ry2, bx, by, f);
											VIS(node(rx1, ry1, rx2, ry2, bx, by, f)) = 1;
											continue;
										}
										if ((rx1 == bx && ry1 == by) || (rx2 == bx && ry2 == by)) { // 红子与黑子在同一个格子，且上一步是黑子。
											q.emplace(rx1, ry1, rx2, ry2, bx, by, f);
											VIS(node(rx1, ry1, rx2, ry2, bx, by, f)) = 1;
											continue;
										}
										for (int i = 0; i < 4; i++) { // 移动第一个红子
											int xx = rx1 + grx[i], yy = ry1 + gry[i];
											if (!check(xx, yy)) continue;
											if (xx == rx2 && yy == ry2) continue; // 注意两个红子不能在同一个格子上！
											in[rx1][ry1][rx2][ry2][bx][by][f]++;
										}
										for (int i = 0; i < 4; i++) { // 移动第二个红子
											int xx = rx2 + grx[i], yy = ry2 + gry[i];
											if (!check(xx, yy)) continue;
											if (xx == rx1 && yy == ry1) continue;
											in[rx1][ry1][rx2][ry2][bx][by][f]++;
										}
										if (in[rx1][ry1][rx2][ry2][bx][by][f] == 0) { // 红方无法移动
											q.emplace(rx1, ry1, rx2, ry2, bx, by, f);
											VIS(node(rx1, ry1, rx2, ry2, bx, by, f)) = 1;
										}
									} else {
										if ((rx1 == bx && ry1 == by) || (rx2 == bx && ry2 == by)) { // 红子与黑子在同一个格子，且上一步是红子。
											q.emplace(rx1, ry1, rx2, ry2, bx, by, f);
											VIS(node(rx1, ry1, rx2, ry2, bx, by, f)) = 1;
											continue;
										}
										for (int i = 0; i < 3; i++) { // 移动黑子
											int xx = bx + gbx[i], yy = by + gby[i];
											if (!check(xx, yy)) continue;
											in[rx1][ry1][rx2][ry2][bx][by][f]++;
										}
										if (in[rx1][ry1][rx2][ry2][bx][by][f] == 0) { // 黑方无法移动
											q.emplace(rx1, ry1, rx2, ry2, bx, by, f);
											VIS(node(rx1, ry1, rx2, ry2, bx, by, f)) = 1;
										}
									}
								}
		int flag = 0; // flag 表示结果是否为 Tie。
		while (!q.empty()) {
			node now = q.front();
			q.pop();
			if (now == node(srx1, sry1, srx2, sry2, sbx, sby, 0)) {
				if (SG(now) % 2 == 1) cout << "Red " << SG(now) << '\n';
				else cout << "Black " << SG(now) << '\n';
				flag = 1;
				break;
			}
			if (now.f == 0) { // 当前为红方先走，则上一步为黑方。
				for (int i = 0; i < 3; i++) {
					int xx = now.bx - gbx[i], yy = now.by - gby[i];
					if (!check(xx, yy)) continue;
					node to = now;
					to.bx = xx, to.by = yy;
					to.f ^= 1;
					if (VIS(to)) continue;
					if (SG(now) % 2 == 0) { // 当前为必败状态，则被更新状态为必胜状态。
						if (SG(to) % 2 == 0) { // 原本没有必胜状态，直接更新。
							SG(to) = SG(now) + 1;
							IN(to) = 0;
							q.push(to);
						} else SG(to) = min(SG(to), SG(now) + 1); // 原本就是必胜状态，取最小值。
					} else if(SG(to) % 2 == 0) SG(to) = max(SG(to), SG(now) + 1); // 当前为必胜状态，则被更新状态为必败状态。若被更新状态原本即为必败状态则取最大值。
					if (!--IN(to)) q.push(to);
				}
			} else { // 当前为黑方先走，则上一步为红方。
				for (int i = 0; i < 4; i++) { // 上一步移动第一个红子。
					int xx = now.rx1 - grx[i], yy = now.ry1 - gry[i];
					if (!check(xx, yy)) continue;
					node to = now;
					to.rx1 = xx, to.ry1 = yy;
					to.f ^= 1;
					if (to.rx1 > to.rx2 || (to.rx1 == to.rx2 && to.ry1 > to.ry2))
						swap(to.rx1, to.rx2), swap(to.ry1, to.ry2); // 一半状态的剪枝。
					if (to.rx1 == to.rx2 && to.ry1 == to.ry2) continue;
					if (VIS(to)) continue;
					if (SG(now) % 2 == 0) {
						if (SG(to) % 2 == 0) {
							SG(to) = SG(now) + 1;
							IN(to) = 0;
							q.push(to);
						} else SG(to) = min(SG(to), SG(now) + 1);
					} else if(SG(to) % 2 == 0) SG(to) = max(SG(to), SG(now) + 1);
					if (!--IN(to)) q.push(to);
                    // 这里与上面相同。
				}
				for (int i = 0; i < 4; i++) { // 上一步移动第二个红子。
					int xx = now.rx2 - grx[i], yy = now.ry2 - gry[i];
					if (!check(xx, yy)) continue;
					node to = now;
					to.rx2 = xx, to.ry2 = yy;
					to.f ^= 1;
					if (to.rx1 > to.rx2 || (to.rx1 == to.rx2 && to.ry1 > to.ry2))
						swap(to.rx1, to.rx2), swap(to.ry1, to.ry2);
					if (to.rx1 == to.rx2 && to.ry1 == to.ry2) continue;
					if (VIS(to)) continue;
					if (SG(now) % 2 == 0) {
						if (SG(to) % 2 == 0) {
							SG(to) = SG(now) + 1;
							IN(to) = 0;
							q.push(to);
						} else SG(to) = min(SG(to), SG(now) + 1);
					} else if(SG(to) % 2 == 0) SG(to) = max(SG(to), SG(now) + 1);
					if (!--IN(to)) q.push(to);
				}
                // 这里与上面相同。
			}
		}
		if (!flag) cout << "Tie\n";
	}
	return 0;
}
```

---


# [SCOI2012] 喵星球上的点名

## 题目描述

a180285 幸运地被选做了地球到喵星球的留学生。他发现喵星人在上课前的点名现象非常有趣。

假设课堂上有 $n$ 个喵星人，每个喵星人的名字由**姓**和**名**构成。喵星球上的老师会选择 $m$ 个串来点名，每次读出一个串的时候，如果这个串是一个喵星人的姓或名的**子串**，那么这个喵星人就必须答到。

然而，由于喵星人的字码如此古怪，以至于不能用 ASCII 码来表示。为了方便描述，a180285 决定用数串来表示喵星人的名字。



现在你能帮助 a180285 统计每次点名的时候有多少喵星人答到，以及 $m$ 次点名结束后每个喵星人答到多少次吗？


## 说明/提示

#### 样例 1 解释

事实上样例给出的数据如果翻译成地球上的语言可以这样来看

```plain
2 3
izayoi sakuya
orihara izaya
izay
hara
raiz
```

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n, m \le 10^3$，喵星人的名字总长不超过 $4\times10^3$，点名串的总长不超过 $2\times10^3$。
- 对于$100\%$ 的数据，保证 $1 \leq n\le 5 \times 10^4$，$1 \leq m \le 10^5$，喵星人的名字总长和点名串的总长分别不超过 $10^5$，保证喵星人的字符串中作为字符存在的数不超过 $10^4$ 。

## 样例 #1

### 输入

```
2 3
6 8 25 0 24 14 8 6 18 0 10 20 24 0
7 14 17 8 7 0 17 0 5 8 25 0 24 0
4 8 25 0 24
4 7 0 17 0
4 17 0 8 25
```

### 输出

```
2
1
0
1 2```

# 题解

## 作者：Lskkkno1 (赞：38)

- [P2336 [SCOI2012]喵星球上的点名](https://www.luogu.com.cn/problem/P2336)

### 题目描述

有 $N$ 只喵，每只喵有一个名和一个姓（两个字符串）。

还有 $M$ 次点名（也是一个字符串），如果一只喵的名或姓中包含这个字符串，这只喵就会喊“到”。

有两问 :

1. 对于每次点名询问有多少只喵喊“到”。

2. 对于每一只喵问询她喊了多少次“到”。

字符集 $|\Sigma| \le 10^4$, 总字符串长不超过 $2 \times 10^5$。

### 正解

#### 简单分析

先可以把一只喵的名和姓合并在一起，中间插入一个不存在的字符，这样就不需要考虑两个串了。

询问是类似于字符串 $x$ 在字符串 $y$ 中是否出现过。

如果字符串出现多次算多次的话，这里有一道用 AC 自动机 [经典的例题](https://www.luogu.com.cn/problem/P2414)。

考虑 AC 自动机 $\text{fail}$ 树的性质，$\text{fail}$ 指针指向的是最长相同后缀。

如果字符串 $A$ 是字符串 $B$ 的后缀, 那么在 AC 自动机上面，从 $B$ 开始跳 $\text{fail}$ 树，一定可以跳到 $A$。

也就是说，$B$ 在 $A$ 的子树内，$A$ 是 $B$ 的祖先。（在 $\text{fail}$ 树上）

判断 $A$ 是否在 $B$ 中出现过，就可以对于 $B$ 的每一个前缀（子串一定是一个前缀的后缀），在 $\text{fail}$ 树上暴力往上跳进行修改或者查询即可。

但是暴力跳 $\text{fail}$ 复杂度可能不太对，~~但是好像也可以通过此题~~，这里给出一个复杂度为 $O(n \log n)$ 的做法。

#### 第一问

对于一个名字串的每一个前缀（总前缀个数不超过字符串总长），覆盖它到根的路径（覆盖表示加多次算一次）。

对每一个名字串都这么做，看点名串总共被多少个名字串给覆盖。

树上链修改，单点查询的问题先转化成树上单点修改，子树查询的问题j。

由于覆盖多次算只算一次，就要把覆盖多的部分减掉。

这里有一个小 trick。

对名字串的前缀按 $\text{dfs}$ 序排序，减掉的部分就是每相邻节点的 $\text{lca}$。

这样就可以做覆盖多次算一次了。

#### 第二问

对于一个名字串的所有一个前缀，看它们总共覆盖了多少点名串。

树上单点修改，链查询的问题先转化串树上子树修改, 单点查询的问题。

同样利用上面的 trick，减掉 $\text{dfs}$ 序相邻节点 $\text{lca}$ 的贡献即可。

#### 复杂度分析

询问都只需要用到排序和树状数组，这一部分复杂度为 $O(n \log n)$。

但是有一部分的复杂度很迷，就是 $\text{trie}$ 树求 $\text{fail}$ 的那一部分，求 $\text{fail}$ 是暴力跳的（但好像复杂度均摊？），复杂度我也不敢下定论。

求哪位大佬帮忙证明一下复杂度，或者直接 hack 掉这种做法。 

#### update :

字符集比较大的时候确实这样写确实不对的，无论是普通写法（将不存在的 $\text{to}$ 指针设为 $\text{fail}$ 的 $\text{to}$ 指针），还是临时跳 $\text{fail}$ 并且记忆化，最坏复杂度是 $O(|\Sigma| \times N)$ 的，但是第二种写法可能远远达不到这个最坏复杂度，而且貌似最坏也就 $10^9$ ？，所以可以通过此题。

### 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 5e4 + 5;
const int M = 1e5 + 5;
const int S = (N + M) << 1;

int n, m;
int namePos[N], queryPos[M];

int last, vcnt = 0;
struct node {
    int fa, fail; // 此处的 fa 为 trie 树上的 fa
    map<int, int> to;
} a[S];

int que[S];
int siz[S], dep[S], son[S], fa[S]; // 此处的 fa 相当于 ac 自动机上的 fail
int dfn[S], top[S], dfc; 
vector<int> g[S];

namespace BIT {
#define lowbit(x) (x & -x)
    int c[S];
    void clear() { memset(c, 0, sizeof c); }
    void update(int p, int v) {
        for(int i = p; i <= dfc; i += lowbit(i))
            c[i] += v;
    }
    int sum(int p) {
        int res = 0;
        for(int i = p; i; i -= lowbit(i))
            res += c[i];
        return res;
    }
    int query(int l, int r) { return sum(r) - sum(l - 1); }
#undef lowbit
} // namespace BIT

inline int read() {
    int x = 0; char ch = getchar();
    while(!isdigit(ch)) ch = getchar();
    while(isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();
    return x;
}

void extend(int c) {
    int &v = a[last].to[c];
    if(!v) v = ++vcnt, a[v].fa = last;
    last = v;
}

int getFail(int u, int c) {
    if(a[u].to.count(c)) return a[u].to[c];
    else if(!u) return u;
    return a[u].to[c] = getFail(a[u].fail, c);
}

void buildFailTree() {
    int hd = 1, tl = 0;
    for(auto pr : a[0].to)
        que[++tl] = pr.second;
    while(hd <= tl) {
        int u = que[hd++];
        for(auto pr : a[u].to) {
            a[pr.second].fail = getFail(a[u].fail, pr.first);
            que[++tl] = pr.second;
        }
    }
    for(int i = 1; i <= vcnt; ++i)
        g[a[i].fail].push_back(i);
}

void preDfs(int u) {
    siz[u] = 1;
    dfn[u] = ++dfc;
    dep[u] = dep[fa[u]] + 1;
    for(int v : g[u]) if(v != fa[u]) {
        fa[v] = u, preDfs(v);
        siz[u] += siz[v];
        if(!son[u] || siz[v] > siz[son[u]])
            son[u] = v;
    }
}
void getTop(int u, int tp) {
    top[u] = tp;
    if(son[u]) getTop(son[u], tp);
    for(int v : g[u]) if(v != fa[u] && v != son[u]) {
        getTop(v, v); 
    }
}

inline int lca(int u, int v) {
    while(top[u] != top[v]) {
        if(dep[top[u]] < dep[top[v]]) swap(u, v);
        u = fa[top[u]];
    }
    return dep[u] < dep[v] ? u : v;
}

int arr[N], tot;
bool cmp(const int &u, const int &v) { return dfn[u] < dfn[v]; }

void solve1() {
    BIT::clear();
    for(int i = 1, u; i <= n; ++i) {
        u = namePos[i], tot = 0;
        while(u) {
            arr[++tot] = u;
            BIT::update(dfn[u], 1);
            u = a[u].fa;
        }
        sort(arr + 1, arr + tot + 1, cmp);
        for(int j = 1; j < tot; ++j)
            BIT::update(dfn[lca(arr[j], arr[j + 1])], -1);
    }
    for(int i = 1, u; i <= m; ++i) {
        u = queryPos[i];
        printf("%d\n", BIT::query(dfn[u], dfn[u] + siz[u] - 1));
    }
}
void solve2() {
    BIT::clear();
    for(int i = 1, u; i <= m; ++i) {
        u = queryPos[i];
        BIT::update(dfn[u], 1);
        BIT::update(dfn[u] + siz[u], -1);
    }
    for(int i = 1, u, res; i <= n; ++i) {
        u = namePos[i], tot = 0, res = 0;
        while(u) {
            arr[++tot] = u;
            res += BIT::sum(dfn[u]);
            u = a[u].fa;
        }
        sort(arr + 1, arr + tot + 1, cmp);
        for(int j = 1; j < tot; ++j)
            res -= BIT::sum(dfn[lca(arr[j], arr[j + 1])]);
        printf("%d%c", res, " \n"[i == n]);
    }
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("P2336.in", "r", stdin);
    freopen("P2336.out", "w", stdout);
#endif
    n = read(), m = read();
    for(int i = 1, l, c; i <= n; ++i) {
        last = 0;
        l = read();
        for(int j = 1; j <= l; ++j) {
            c = read();
            extend(c);
        } extend(-1);
        l = read();
        for(int j = 1; j <= l; ++j) {
            c = read();
            extend(c);
        }
        namePos[i] = last;
    }
    for(int i = 1, l, c; i <= m; ++i) {
        last = 0;
        l = read();
        for(int j = 1; j <= l; ++j) {
            c = read();
            extend(c);
        }
        queryPos[i] = last;
    }

    buildFailTree();
    
    preDfs(0);
    getTop(0, 0);
    
    solve1();
    solve2();
    return 0;
}
```


---

## 作者：hl666 (赞：29)

一道比较不错**字符串**好题，貌似有很多做法可以艹过去。

比较主流的有两大类，一种是用各种**自动机**：**AC自动机**暴力搞或者是神仙的**后缀自动机**做，相比之下对于我来说不是很会。

另一种就是用**后缀数组**预处理一下，然后可以用各种数据结构（如**树状数组**）来维护，但是由于我比较菜而且数据范围不是很大所以我们可以用**莫队**来暴力的搞。

下面我们主要分析一下**SA+莫队**的算法。

首先我们考虑将所有猫的姓和名拼接在一起（注意中间还是要用特殊字符连接一下），并记录每一个位置上的字符是哪只猫的，记为$id_i$。

然后考虑对于询问，由于后缀数组的$sa$数组表示的是**排名为$i$的后缀的位置**，因此我们可以根据排名**二分**出每一个询问在$sa$数组上对应的**区间**。

再回头看这个问题，先考虑算询问的答案，首先转化为区间之后若左端点大于右端点那么这个串显然是找不到的，那么可以直接跳过。

如果是合法的区间，那么我们相当于统计这段区间中的所有$sa_i$的$id$的种类数（因为每只猫出现多次也只统计一次）

这个就直接开一个**桶**用莫队算一下即可。

然后是考虑每只猫的答案，这个我们莫队更新区间的时候判断一下，如果这只猫是第一次出现那么先将答案加上**最大的可能出现次数**，然后在删除的时候减掉即可。

时间复杂度$O(n\log n+m\sqrt n)$，可以轻松跑过。

CODE

```cpp
#include<cstdio>
#include<cctype>
#include<cmath>
#include<iostream>
#include<algorithm>
#define RI register int
using namespace std;
const int N=50005,M=100005;
int blk[M+(N<<1)]; struct ques
{
    int l,r,id;
    inline friend bool operator <(ques A,ques B)
    {
        return blk[A.l]^blk[B.l]?blk[A.l]<blk[B.l]:(blk[A.l]&1?A.r<B.r:A.r>B.r);
    }
}q[M]; int n,m,len,tot,a[M+(N<<1)],sa[M+(N<<1)],x,size,ans[M],id[M+(N<<1)],cnt,t[N],bkt[N],lim=10000,L,R,ret;
class FileInputOutput
{
    private:
        #define S 1<<21
        #define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,S,stdin),A==B)?EOF:*A++)
        #define pc(ch) (Ftop<S?Fout[Ftop++]=ch:(fwrite(Fout,1,S,stdout),Fout[(Ftop=0)++]=ch))
        char Fin[S],Fout[S],*A,*B; int Ftop,pt[15];
    public:
        inline void read(int &x)
        {
            x=0; char ch; while (!isdigit(ch=tc()));
            while (x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));
        }
        inline void write(int x,char ch)
        {
            if (!x) return (void)(pc('0'),pc(ch)); RI ptop=0;
            while (x) pt[++ptop]=x%10,x/=10; while (ptop) pc(pt[ptop--]+48); pc(ch);
        }
        inline void Fend(void)
        {
            fwrite(Fout,1,Ftop,stdout);
        }
        #undef S
        #undef tc
        #undef pc
}F;
class Suffix_Array
{
    private:
        int rk[M+(N<<1)],t[M+(N<<1)],cnt[M+(N<<1)],size;
        inline void Radix_sort(int n)
        {
            RI i; for (i=0;i<=size;++i) cnt[i]=0;
            for (i=1;i<=n;++i) ++cnt[rk[i]];
            for (i=1;i<=size;++i) cnt[i]+=cnt[i-1];
            for (i=n;i;--i) sa[cnt[rk[t[i]]]--]=t[i];
        }
    public:
        inline void build(int *a,int n)
        {
            RI i; size=a[n]; for (i=1;i<=n;++i) rk[i]=a[i],t[i]=i;
            Radix_sort(n); for (RI p=0,w=1;p<n;size=p,w<<=1)
            {
                for (p=0,i=n-w+1;i<=n;++i) t[++p]=i;
                for (i=1;i<=n;++i) if (sa[i]>w) t[++p]=sa[i]-w;
                Radix_sort(n); swap(rk,t); rk[sa[1]]=p=1;
                for (i=2;i<=n;++i) rk[sa[i]]=(t[sa[i-1]]==t[sa[i]]&&t[sa[i-1]+w]==t[sa[i]+w])?p:++p;
            }
        }
}SA;
inline void add(int x,int cur)
{
    if (++bkt[id[x]]==1) ++ret,t[id[x]]+=cnt-cur+1;
}
inline void del(int x,int cur)
{
    if (--bkt[id[x]]==0) --ret,t[id[x]]-=cnt-cur+1;
}
int main()
{
    //freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
    RI i,j; for (F.read(n),F.read(m),i=1;i<=n;++i) for (RI k=0;k<=1;++k)
    {
        for (F.read(len),j=1;j<=len;++j) F.read(a[++tot]),id[tot]=i; a[++tot]=++lim;
    }
    for (size=(int)sqrt(tot),i=1;i<=tot;++i) blk[i]=(i-1)/size+1;
    for (SA.build(a,tot),i=1;i<=m;++i)
    {
        for (F.read(len),L=j=1,R=tot;j<=len;++j)
        {
            F.read(x); int l=L,r=R,mid; while (l<=r)
            if (a[sa[mid=l+r>>1]+j-1]<x) l=mid+1; else r=mid-1;
            int temp=l; l=L; r=R; while (l<=r)
            if (a[sa[mid=l+r>>1]+j-1]<=x) l=mid+1; else r=mid-1;
            L=temp; R=r;
        }
        if (L<=R) q[++cnt]=(ques){L,R,i};
    }
    for (sort(q+1,q+cnt+1),i=L=1,R=0;i<=cnt;++i)
    {
        while (L>q[i].l) add(sa[--L],i); while (R<q[i].r) add(sa[++R],i);
        while (L<q[i].l) del(sa[L++],i); while (R>q[i].r) del(sa[R--],i);
        ans[q[i].id]=ret;
    }
    for (i=1;i<=m;++i) F.write(ans[i],'\n');
    for (i=1;i<=n;++i) F.write(t[i],' ');
    return F.Fend(),0;
}
```

---

## 作者：kczno1 (赞：28)

表示看不懂题解。。

我只能想到后缀数组+莫队

s2是s1的子串，就是s1存在后缀和s2的最长公共前缀=length(s2)

所有串放到一起，处理出height后，我们可以线性得到每个点前后

第一个比他小的点

于是得到了每个点名串对应的区间

现在就是问，每个区间里有多少类数，以及每类数被多少区间包括。

第一问就是莫队的模板题。

第二问考虑差分。每新遇到一类数，我们给他+剩余询问个数

每去掉一类数，我们给他-剩余询问个数。

时间((m+总长)\*根号(总长))，竟然还是最快的(在洛谷)。

upd:
看懂了ac自动机的做法。。orz Delicious

我在他的基础上进行了优化。

我们对询问串建ac自动机，之后建出只包含代表整个串的节点的fail树。

把两个串放在上面跑，跑过的点在fail树上建虚树，每个叶子的贡献是与前一个叶子的lca之间那段。

所以可以统计个数(第一问)。通过打delta标记，就是在自己这儿打个+1，lca那里打个-1，最后统计，可以解决第二问。

注意到我们不用真的建出虚树，只用排序，之后判断前一个点是不是后一个点的祖先来得到叶子。

由于dfs序值域是O(n)，可以离线做到O(n)排序。求lca也可以离线用tarjan做到O(N)。

所以除了建ac自动机要nlogn，其他都是O(n)的。

ac自动机存储儿子也可以优化一下常数，当儿子<=12时，用数组存；否则用线段树存。

遍历儿子时用数组或者记录头儿子和后兄弟的方法。

(当然，这些优化我都懒得打，加了估计就有200行了。。)

```cpp
#include<bits/stdc++.h>
using namespace std;
 
#define U 10000
#define N 100100
#define M 100100
int *s[N][2];
int n,m,k,i,len;

void init(int* &q)
{
    scanf("%d",&len);
    q=new int [len+1];
    q[0]=len;
    for (i=1;i<=len;++i) scanf("%d",q+i);
}

#define TOT 500100 
typedef map<int,int> tree;//颜色，点 
tree son[TOT];
int fail[TOT],f[TOT],tot=1;
int dy[M],num[TOT];
void ins()
{
    scanf("%d",&len);
    int i=1;
    while (len--)
    {
        int c;
        scanf("%d",&c);
        int &p=son[i][c];
        if (!p) p=++tot;
        i=p;
    }
    dy[k]=i;++num[i];
}

int t[TOT],Next[TOT];
int fa[TOT],top[TOT],deep[TOT],in[TOT],out[TOT];
void dfs(int x,int dep)
{
    static int cnt=-1,sz[TOT],son[TOT];
    sz[x]=1;deep[x]=(dep+=num[x]);in[x]=++cnt;
    int &c=son[x],i;
    for (i=t[x];i;i=Next[i]) 
    {
        fa[i]=x;
        dfs(i,dep);
        sz[x]+=sz[i];
        if (sz[i]>sz[c]) c=i;
    }
    for (i=t[x];i;i=Next[i]) 
    if (i!=c)
     for (int y=i;y;y=son[y]) top[y]=i; 
    out[x]=cnt;
}
int q[TOT],head,tail;
void build_f()
{
    head=0;tail=1;q[1]=1;
    while (head!=tail)
    {
        int x=q[++head];
        for (tree::iterator it=son[x].begin();it!=son[x].end();++it)
        {
            int col=it->first,j=it->second;
            q[++tail]=j;
            int fa=fail[x],p;
            for (;fa&&!(p=son[fa][col]);fa=fail[fa]);
            if (!fa)  p=1;
            fail[j]=p;
            f[j]=fa=num[p]?p:f[p];
            if (num[j])
            {
               Next[j]=t[fa];t[fa]=j;
            }
        }
    }
    dfs(0,0);
}

int get_lca(int x,int y)
{
    int fx=top[x],fy=top[y];
    while (fx!=fy)
    if (deep[fx]>=deep[fy]) { x=fa[fx];fx=top[x]; }
    else { y=fa[fy];fy=top[y]; }
    return deep[x]<deep[y]?x:y;
}

void go(int *s)
{
    int x=1;
    for (int i=1;i<=s[0];++i)
    {
        int c=s[i],p;
        while (x&&!(p=son[x][c])) x=fail[x];
        if (!x) x=1;
        else 
        {
            x=p;
            if (num[x]) q[++tail]=x;
            else if (num[f[x]]) q[++tail]=f[x];
        }
    }
}

bool xiao(int x,int y)
{
   return in[x]<in[y];
}

int del[M]; 
void calc(int x)
{
    for (int i=t[x];i;i=Next[i])
    {
        calc(i);del[x]+=del[i];
    }
}

int Ans[N];

int main()
{
    freopen("1.in","r",stdin);freopen("3.out","w",stdout);
    scanf("%d%d",&n,&m);
    for (k=1;k<=n;++k) 
    {
     init(s[k][0]);
     init(s[k][1]);
    }
    for (k=1;k<=m;++k) ins();
    build_f();
    
    for (k=1;k<=n;++k)
    {
        tail=0;
        go(s[k][0]);
        go(s[k][1]);
        if (!tail) continue; 
        
        sort(q+1,q+tail+1,xiao);
        int top=1;
        for (i=2;i<=tail;++i)
        {
          top+=(in[q[i]]>out[q[top]]); 
          q[top]=q[i];
        }
        int ans=deep[q[1]];
        ++del[q[1]];
        for (i=2;i<=top;++i) 
        { 
          int lca=get_lca(q[i],q[i-1]);
          --del[lca];++del[q[i]];
          ans+=deep[q[i]]-deep[lca];
        }
        Ans[k]=ans;
    }
    calc(0);
    for (i=1;i<=m;++i) printf("%d\n",del[dy[i]]);
    for (i=1;i<=n;++i) printf("%d ",Ans[i]);
}
```

---

## 作者：zesqwq (赞：22)

最优解，乐。

题解区全是很厉害的做法啊，可惜我只能领略一二。

有一种很亲民的做法：哈希，代码巨短无比（当然我的 record 带一个很长的头罢了）。

我们发现一个事实：$\sum_{i=1}^x i = O(x^2)$，所以说这 $n$ 个串的长度种类数是 $O(\sqrt {\sum len})$ 的。

我们现在考虑第二问应该怎么做？

我们先处理出这 $O(\sqrt {\sum len})$ 种长度，然后对于这 $n$ 个双模式串，每个串对这每种长度扫一边。同时记录一个 $\text{cnt}$ 数组，$\text{cnt}_x$ 表示哈希值为 $x$ 的字符串是否已经被记录过，这步的原因是根据题意每个模式串被每个文本串最多点到一次。然后最后输出 $\text{cnt}$ 中有值的位置的个数即可，可以用哈希表来实现。

然后再考虑到第一问：

我们现在已经记录了 $\text{cnt}$ 数组了，可以再记录一个数组 $\text{cnt2}$，然后每次做完之后让 $\text{cnt2}$ 的每一位加上 $ \text{cnt}$，这样我们就可以统计出 $n$ 个双模式串中每个哈希值出现的次数，然后再遍历那 $m$ 个字符串求哈希之后在 $\text{cnt2}$ 中统计一下即可。

注意你的哈希不要让 $\text{hash}(03)=\text{hash}(3)$。

时间复杂度 $O(m + \sum{len} + n\sqrt {\sum len})$。

可以参考一下我的答辩代码：

```cpp
ull h[N], g[N];
inline ull hsh(int l, int r) {
    if (!l) return h[r];
    return h[r] - h[l - 1] * g[r - l + 1];
}
hash_map vis, mp;
unordered_map<ull, int> mp_;
int n, m, ans[N];
int main() {
    read(n), read(m), g[0] = 1;
    for (int i = 1; i < N; i++) g[i] = g[i - 1] * P;
    for (int i = 1; i <= n; i++) {
        int x, y;
        read(x); while (x--) read(y), ++y, str[i].push_back(y);
        read(x); while (x--) read(y), ++y, str2[i].push_back(y);
    }
    vector<int> v;
    for (int i = 1; i <= m; i++) {
        int x, y;
        read(x), v.emplace_back(x); ull ans = 0;
        while (x--) read(y), ++y, ans = ans * P + y; 
        f[i] = ans, ++vis[ans];
    }
    sort(v.begin(), v.end()), v.erase(unique(v.begin(), v.end()), v.end());
    for (int i = 1; i <= n; i++) {
        clear(mp_), h[0] = str[i][0];
        int res = 0;
        for (int j = 1; j < str[i].size(); j++) h[j] = h[j - 1] * P + str[i][j];
        for (int len : v)
            for (int j = len - 1; j < str[i].size(); j++) {
                ull tmp = hsh(j - len + 1, j);
                if (vis.count(tmp) && !mp_.count(tmp)) ++mp_[tmp], res += vis[tmp];
            }
        h[0] = str2[i][0];
        for (int j = 1; j < str2[i].size(); j++)
            h[j] = h[j - 1] * P + str2[i][j];
        for (int len : v)
            for (int j = len - 1; j < str2[i].size(); j++) {
                ull tmp = hsh(j - len + 1, j);
                if (vis.count(tmp) && !mp_.count(tmp)) ++mp_[tmp], res += vis[tmp];
            }
        ans[i] = res;
        for (auto [u, v] : mp_) ++mp[u];
    }
    for (int i = 1; i <= m; i++) write(mp[f[i]]), putc('\n');
    for (int i = 1; i <= n; i++) write(ans[i]), putc(' ');
    do_flush();
    return 0;
}
```

---

## 作者：蹲在丛中笑 (赞：19)

一种后缀数组＋树状数组的做法

把所有串串起来建后缀数组，对于每个询问串首向左向右二分找合法区间，

问题就转化成求每个区间包含多少种颜色，和每种颜色被多少区间包含

都可以用树状数组做

对于第一问，可以参考*P1972 HH的项链*https://www.luogu.org/problemnew/solution/P1972

对于第二问，跟第一问的思路差不多，都是对序列遍历一遍，在区间的左右端点L,R，以及当前点和与当前点同色的上一个点pre[i],i的操作．

第二问是访问到L处给树状数组bit[L]++,到R时bit[L]--,到i时查询sum(i)-sum(pre[i])，
和第一问相反


网上有也一篇博客是这样的做法，讲得更清楚https://blog.csdn.net/kscla/article/details/73176183


总复杂度是O(nlogn)的

代码很丑

```
#include<bits/stdc++.h>
using namespace std;
const int N=501005,INF=1e9+7;
int nn,q,n,m=N-1000,sa[N],ra[N],h[N],t[N],t1[N],t2[N];
int st[19][N],lg[N];
int s[N],col[N],hd[N],len[N],bu[N];
int pre[N],bit1[N],bit2[N],ans1[N],ans2[N];
int lp[N];//询问区间的左端点
struct P { int id,l,r; } p[N];
bool Cmp(const P &A,const P &B) { return A.r<B.r; }
//后缀数组是之前写的板子，连缩进都不一样
void Getsa() {
  int *x=t1,*y=t2;
  for (int i=1;i<=n;++i) ++t[x[i]=s[i]];
  for (int i=1;i<=m;++i) t[i]+=t[i-1];
  for (int i=n;i;--i) sa[t[x[i]]--]=i;
  for (int k=1;k<=n;k<<=1) {
    int p=0; memset(t,0,m+1<<2);
    for (int i=n-k+1;i<=n;++i) y[++p]=i;
    for (int i=1;i<=n;++i) if (sa[i]>k) y[++p]=sa[i]-k;
    for (int i=1;i<=n;++i) ++t[x[y[i]]];
    for (int i=1;i<=m;++i) t[i]+=t[i-1];
    for (int i=n;i;--i) sa[t[x[y[i]]]--]=y[i];
    swap(x,y); x[sa[1]]=1;
    for (int i=2;i<=n;++i) x[sa[i]]=x[sa[i-1]]+
        (y[sa[i]]!=y[sa[i-1]]||y[sa[i]+k]!=y[sa[i-1]+k]);
    if ((m=x[sa[n]])>=n) break;
  }
}
void Geth() {
  for (int i=1;i<=n;++i) ra[sa[i]]=i;
  for (int i=1,k=0;i<=n;++i) {
    if (k) --k;
    int j=sa[ra[i]-1];
    while (s[i+k]==s[j+k]) ++k;
    h[ra[i]]=k;
  }
}
void Init() {
  for (int i=1;i<=n;++i) st[0][i]=h[i];
  for (int i=1;i<19;++i)
    for (int j=1;j+(1<<i)-1<=n;++j)
      st[i][j]=min(st[i-1][j],st[i-1][j+(1<<i-1)]);
  for (int i=1;(1<<i)<=n;++i) lg[1<<i]=i;
  for (int i=1;i<=n;++i) if (!lg[i]) lg[i]=lg[i-1];
}
int Getmin(int a,int b) {
  if (a==b) return INF;
  if (a>b) swap(a,b);
  int d=lg[b-(a++)];
  return min(st[d][a],st[d][b-(1<<d)+1]);
}
void Upd(int *A,int i,int v) {
    if (i) for (;i<=n;i+=i&-i) A[i]+=v;
}
int Query(int *A,int i) {
    int res=0;
    for (;i;i-=i&-i) res+=A[i];
    return res;
}
void Input() {
    int x,c=1e4;
    scanf("%d%d",&nn,&q);
    for (int i=1;i<=nn;++i) {
        for (int j=0;j<2;++j) {
            scanf("%d",&x);
            while (x--) col[++n]=i,scanf("%d",s+n);
            s[++n]=++c;
        }
    }
    for (int i=1;i<=q;++i) {
        scanf("%d",&len[n+1]); hd[n+1]=i;
        for (int j=len[n+1];j--;) col[++n]=-i,scanf("%d",s+n);
        s[++n]=++c;
    }
}
//同时求出pre[]和询问区间
void Getpre() {
    for (int i=1;i<=n;++i) {
        if (col[sa[i]]>0) {
            pre[i]=bu[col[sa[i]]];
            bu[col[sa[i]]]=i;
        }
        if (hd[i]) {
            p[hd[i]].id=hd[i];
            int l=1,r=ra[i];
            while (l<r) { int mi=l+r>>1; if (Getmin(mi,ra[i])>=len[i]) r=mi; else l=mi+1; }
            p[hd[i]].l=lp[hd[i]]=l;
            l=ra[i],r=n;
            while (l<r) { int mi=l+r+1>>1; if (Getmin(ra[i],mi)>=len[i]) l=mi; else r=mi-1; }
            p[hd[i]].r=r;
        }
    }
    sort(p+1,p+q+1,Cmp);
    sort(lp+1,lp+q+1);
}
//两个询问放到一起做了
void Getans() {
    for (int i=1,j=1,k=1;i<=n;++i) {
        for (;j<=q&&lp[j]==i;++j) Upd(bit2,i,1);
        if (col[sa[i]]>0) {
            ans2[col[sa[i]]]+=Query(bit2,i)-Query(bit2,pre[i]);
            Upd(bit1,i,1); Upd(bit1,pre[i],-1);
        }
        for (;k<=q&&p[k].r==i;++k) {
            ans1[p[k].id]=Query(bit1,p[k].r)-Query(bit1,p[k].l-1);
            Upd(bit2,p[k].l,-1);
        }
    }
}
int main() {
    Input(),Getsa(),Geth(),Init(),Getpre(),Getans();
    for (int i=1;i<=q;++i) printf("%d\n",ans1[i]);
    for (int i=1;i<=nn;++i) printf("%d ",ans2[i]);
}
```

---

## 作者：FZzzz (赞：14)

这里是一种不一样的方法……求管理员给过（

表示看不懂其他题解的说（

首先我们把每个人的姓和名中间加一个字符变成一个串，于是这个题就变成了：

给一堆文本串和一堆模板串，求每个模板串在多少个文本串中出现过，以及每个文本串里有多少个模板串。

无脑把文本串加分隔符建 SAM，然后把模板串放上去匹配。

对于一个模板串，如果大串的一个前缀满足：它在这个模板串对应的节点的子树内，并且它的结尾字符在某个文本串内，那么我们可以发现这个模板串就一定在这个文本串里出现过。

那么我们给所有前缀节点按照它最后一个字符所在的文本串染色，我们发现我们要解决的就是子树数颜色和数每个颜色被多少个子树包含了。

压扁到 dfs 序上，就是区间数颜色，以及问每个颜色被多少个区间包含。

这两问都是经典问题，讲一下做法：

第一问就是从左到右扫描线，扫到一个点就把它加一，把它的前缀减一，然后扫到一个区间的右端点就查询区间和。

第二问也是从左到右扫描线，假设一个区间是 $[l,r]$，扫到 $l$ 的时候把 $[l,n]$ 加一，扫到 $r+1$ 把 $[l,n]$ 减一，一个点对于它的颜色的贡献就是它的值减去它前驱的值。

然后就做完了。
```cpp
#include<map>
#include<vector>
#include<cstring>
#include<cstdio>
#include<cctype>
using namespace std;
inline int readint(){
	int x=0;
	char c=getchar();
	bool f=0;
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-'){
		f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=5e4+5,maxm=1e5+5,maxl=2e5+5;
int n,m;
int sz,last,len[maxl*2],link[maxl*2];
map<int,int> nxt[maxl*2];
vector<int> ch[maxl*2];
void init(){
	sz=1;
	last=0;
	len[0]=0;
	link[0]=-1;
}
void extend(int c){
	int cur=sz++;
	len[cur]=len[last]+1;
	int p=last;
	while(p>=0&&!nxt[p].count(c)){
		nxt[p][c]=cur;
		p=link[p];
	}
	if(p<0) link[cur]=0;
	else{
		int q=nxt[p][c];
		if(len[p]+1==len[q]) link[cur]=q;
		else{
			int clone=sz++;
			len[clone]=len[p]+1;
			link[clone]=link[q];
			nxt[clone]=nxt[q];
			while(p>=0&&nxt[p][c]==q){
				nxt[p][c]=clone;
				p=link[p];
			}
			link[cur]=link[q]=clone;
		}
	}
	last=cur;
}
int c[maxl*2];
int pos[maxl*2],size[maxl*2];
vector<int> f;
void dfs(int u){
	pos[u]=f.size();
	f.push_back(u);
	size[u]=1;
	for(int i=0;i<(int)ch[u].size();i++){
		int v=ch[u][i];
		dfs(v);
		size[u]+=size[v];
	}
}
int lst[maxl*2],pre[maxl*2];
typedef pair<int,int> pii;
vector<pii> q1[maxl*2];
vector<int> q2[maxl*2];
int t[maxl*2];
inline int lowbit(int x){
	return x&-x;
}
void modify(int x,int k){
	while(x<=sz){
		t[x]+=k;
		x+=lowbit(x);
	}
}
int query(int x){
	int s=0;
	while(x>0){
		s+=t[x];
		x-=lowbit(x);
	}
	return s;
}
int ans[maxm];
int main(){
	#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
	#endif
	n=readint();
	m=readint();
	init();
	for(int i=1;i<=n;i++){
		int l=readint();
		while(l--){
			extend(readint());
			c[last]=i;
		}
		extend(-1);
		l=readint();
		while(l--){
			extend(readint());
			c[last]=i;
		}
		extend(-1);
	}
	for(int i=1;i<sz;i++) ch[link[i]].push_back(i);
	f.push_back(0);
	dfs(0);
	for(int i=1;i<=sz;i++){
		pre[i]=lst[c[f[i]]];
		lst[c[f[i]]]=i;
	}
	for(int i=0;i<m;i++){
		int l=readint(),u=0;
		bool flag=1;
		while(l--){
			int c=readint();
			if(!nxt[u].count(c)) flag=0;
			else u=nxt[u][c];
            //注意这里如果不写 else 就会出锅……因为如果访问了 nxt[u][c] 就会自动给他一个值为 0
		}
		if(!flag) continue;
		q1[pos[u]+size[u]-1].push_back(pii(i,pos[u]));
		q2[pos[u]].push_back(pos[u]);
		q2[pos[u]+size[u]].push_back(-pos[u]);
	}
	for(int i=1;i<=sz;i++){
		if(c[f[i]]){
			modify(i,1);
			if(pre[i]) modify(pre[i],-1);
		}
		for(int j=0;j<(int)q1[i].size();j++)
			ans[q1[i][j].first]=query(i)-query(q1[i][j].second-1);
	}
	for(int i=0;i<m;i++) printf("%d\n",ans[i]);
	memset(ans,0,sizeof(ans));
	memset(t,0,sizeof(t));
	for(int i=1;i<=sz;i++){
		for(int j=0;j<(int)q2[i].size();j++)
			if(q2[i][j]>0) modify(q2[i][j],1);
			else modify(-q2[i][j],-1);
		ans[c[f[i]]]+=query(i)-query(pre[i]);
	}
	for(int i=1;i<=n;i++) printf("%d ",ans[i]);
	printf("\n");
	return 0;
}
```

---

## 作者：ywy_c_asm (赞：13)

看大部分题解都是拿后缀数组做的，这里来一个后缀自动机+莫队的做法，而且跑的特别快233

首先看到多个串内出现过的子串能想到广义SAM，那么我们就先把每个姓和名插到后缀自动机里，并且在SAM的新建的节点上标记一下当前是哪个喵喵喵的字符串，这样当我们询问子串的时候，我们把这个子串放到SAM上跑，然后显然由后缀自动机的性质可得，跑到的节点的$Parent$子树内的所有咱们做过的标记就是被点到的喵喵喵了。

然后子树我们可以用$Parent$树上的$dfs$序维护区间，于是我们可以把这两个问题作如下的转化：

1.这次点名点到了多少个喵喵喵$-->$区间数颜色种类

2.每个喵喵喵被点了多少次名$-->$每种颜色被多少个区间数到了

问题1比较好做，离线下来可以大力莫队，也可以扫描线+树状数组，但是问题2该怎么做呢？其实我们可以考虑区间数颜色的莫队过程，我们从上一个区间转移到下一个区间的时候端点要移动对吧，这其中势必会有一些颜色移进来或者移出去，我们不妨给当前区间内包含的颜色规定一个**存在时间**，即这个颜色的最后一个被弹出的时间-这个颜色开始出现在这个区间的时间，显然，一个颜色会被划分为好几段存在时间，我们就维护$lst_i$表示当前在这个区间内的颜色$i$是啥时候进来的，如果我们要把一个颜色的最后一个移出去，就把当前时间-$lst_i$即这个颜色的这段存在时间统计到这个颜色的答案里，然后就行啦。

哦对了，鉴于这题字符集不那么正常，我们的后缀自动机可以拿map存边！

上代码~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
#define blo 447
using namespace std;
namespace ywy{
	inline int get(){
		int n=0;char c;
		while((c=getchar())||23333){
			if(c>='0'&&c<='9')break;if(c=='-')goto s;
		}
		n=c-'0';
		while((c=getchar())||23333){
			if(c>='0'&&c<='9')n=n*10+c-'0';else return(n);
		}
		s:while((c=getchar())||23333){
			if(c>='0'&&c<='9')n=n*10-c+'0';else return(n);
		}
	}
	void print(int num){
		if(num>=10)print(num/10);putchar(num%10+'0');
	}
	typedef struct _n{
		int l;int r;int id;
		friend bool operator <(const _n &a,const _n &b){
			if(a.l/blo==b.l/blo)return(a.r<b.r);
			return(a.l/blo<b.l/blo);
		}
	}node;
	node memchi[100001];
	map<int,int> sam[200001];
	int len[400001],fa[400001],dfn[400001],heads[400001];
	int gn=2,gnn=1,col[400001],gdfn=1,size[400001],ints[400001];
	typedef struct _b{
		int dest;int nxt;
	}bian;
	bian bians[400011];
	inline void add(int s,int t){
		bians[gnn].dest=t;
		bians[gnn].nxt=heads[s];
		heads[s]=gnn;gnn++;
	}
	inline int zhuanyi(int p,int x,int c){
		int me=gn;gn++;
		col[me]=c;len[me]=len[p]+1;
		while(p&&!sam[p].count(x))sam[p][x]=me,p=fa[p];
		if(!p){
			fa[me]=1;return(me);
		}
		int q=sam[p][x];
		if(len[q]==len[p]+1){
			fa[me]=q;return(me);
		}
		int nq=gn;gn++;
		len[nq]=len[p]+1;
		sam[nq]=sam[q];
		fa[nq]=fa[q];
		fa[q]=fa[me]=nq;
		while(p&&sam[p][x]==q)sam[p][x]=nq,p=fa[p];
		return(me);
	}
	void dfs(int pt){
		size[pt]=1;
		dfn[pt]=gdfn;
		ints[gdfn]=col[pt];gdfn++;
		for(register int i=heads[pt];i;i=bians[i].nxt){
			dfs(bians[i].dest);
			size[pt]+=size[bians[i].dest];
		}
	}
	int cnt[100001],lst[100001],ans1[100001],ans2[100001];
	void ywymain(){
		int n=get(),m=get();
		for(register int i=1;i<=n;i++){
			int p=1;
			int l=get();
			while(l)l--,p=zhuanyi(p,get(),i);
			p=1;l=get();
			while(l)l--,p=zhuanyi(p,get(),i);
		}
		for(register int i=2;i<gn;i++)add(fa[i],i);dfs(1);
		int ptr=1;
		for(register int i=1;i<=m;i++){
			int cur=1;
			int l=get();
			while(l)cur=sam[cur][get()],l--;
			if(!cur)continue;
			memchi[ptr].l=dfn[cur];
			memchi[ptr].r=dfn[cur]+size[cur]-1;
			memchi[ptr].id=i；ptr++;
		}
		ptr--;sort(memchi+1,memchi+1+ptr);
		if(ptr){
			int l=memchi[1].l,r=memchi[1].r,tot=0;
			for(register int i=l;i<=r;i++){
				if(!cnt[ints[i]]&&ints[i])tot++;
				cnt[ints[i]]++;lst[ints[i]]=1;
			}
			ans1[memchi[1].id]=tot;
			for(register int i=2;i<=ptr;i++){
				while(l>memchi[i].l){
					l--;if(!cnt[ints[l]]&&ints[l])tot++,lst[ints[l]]=i;cnt[ints[l]]++;
				}
				while(r<memchi[i].r){
					r++;if(!cnt[ints[r]]&&ints[r])tot++,lst[ints[r]]=i;cnt[ints[r]]++;
				}
				while(l<memchi[i].l){
					cnt[ints[l]]--;if(!cnt[ints[l]]&&ints[l])tot--,ans2[ints[l]]+=(i-lst[ints[l]]);l++；
				}
				while(r>memchi[i].r){
					cnt[ints[r]]--;if(!cnt[ints[r]]&&ints[r])tot--,ans2[ints[r]]+=(i-lst[ints[r]]);r--;
				}
				ans1[memchi[i].id]=tot;
			}
		}
		for(register int i=1;i<=n;i++){
			if(!cnt[i])continue;ans2[i]+=(ptr+1-lst[i]);
		}
		for(register int i=1;i<=m;i++)print(ans1[i]),putchar('\n');
		for(register int i=1;i<=n;i++)print(ans2[i]),putchar(' ')；
	}
}
int main(){
	ywy::ywymain();return(0);//再见程序
} 
```

---

## 作者：Delicious (赞：13)

于是大家不要因为数据不卡就都写玄学复杂度的代码呀=w=

要努力地写比较对的代码才可以 嗯


来说一下我的看起来很正确的乱搞做法，复杂度稳定O(nlogn)

考虑对点名串建AC自动机，然后离线解决第一个问题

显然每个喵星人都会对他两个名字分别在AC自动机上匹配到的点和这些点在fail树上的祖先的那些点名串末端产生贡献，每个点名串查询末端被多少个喵星人覆盖就是答案。

嗯 这处理起来非常简单 就像虚树那样，把点集按dfs序排序，然后用树状数组维护一下路径并就好了。

（求路径并可以保证一个喵星人的两个名字不被算两次）

求LCA的话随便乱搞就行，比如树剖…

然而点到根路径修改，单点查询不太好，因为不太能一个log解决，所以只要等价转化成单点修改，子树查询就好啦

于是第一个问题就完美解决了


然后看第二个问题…其实就是反过来，求每个喵星人覆盖了多少点名串。

做法也是类似的，点名串单点修改，每个喵星人查询两个名字在AC自动机上匹配路径的点在fail树上到根的路径的并上的点名串末端数。

同样求出路径并，单点修改，点到根查询转成子树修改，单点查询。


时间复杂度：AC自动机用map存转移所以是一个log，排序一个log，求路径并时lca一个log，树状数组一个log，这些都是分开的所以总时间复杂度还是O(nlogn)的，只是常数看起来比较大…

实测常数也不小（当然我写的时候有一些地方显然写挫了（但是整体上常数的瓶颈不在这里所以不用在意

（顺便我写指针只是一时好玩(写这题前写了一些简易openGL项目于是突然想写指针了)，其实写指针还是不太方便查错和调试的

（所以一次写对就好了（雾


>#include <cstdio>
```cpp
#include <cstring>
#include <algorithm>
#include <map>
#include <assert.h>
#define lb(x) ((x)&(-(x)))
using std::sort;
using std::map; 
int buf[200010],*bf;
inline int read()
{
    int s = 0; char c; while((c=getchar())<'0'||c>'9');
    do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');
    return s;
}
const int N = 100010;
struct eg;
struct tn
{
    tn *fail,*f,*top,*hs;
    map<int,tn*> son;
    int id,c,d,iw,ow; eg *h;
}pool[N],*pl,*rt,*qu[N],**qh,**qt,*nd[N];
struct eg{ eg *nx; tn *dt; }e[N],*eh;
int r[N];
int n,m,tim,iw[N],ow[N],tr[N],tr2[N],curd,tot,ans[N];
void add(int p,int v){ while(p<=tot) tr[p] += v, p += lb(p); }
int sum(int p){ int s = 0; while(p) s += tr[p], p -= lb(p); return s; }
void add2(int p,int v){ while(p) tr2[p] += v, p -= lb(p); }
int sum2(int p){ int s = 0; while(p<=tot) s += tr2[p], p += lb(p); return s; }
inline void link(tn *aa,tn *bb){ eh++; eh->dt = bb; eh->nx = aa->h; aa->h = eh; }
inline void insert(int id)
{
    int i; tn *p = rt; int len = read();
    for(i=1;i<=len;i++)
    {
        int c = read();
        if(!p->son[c]) 
            p->son[c] = pl++, p->son[c]->f = p, p->son[c]->c = c;
        p = p->son[c];
    }
    p->id = id;
    nd[id] = p;
}
void buildFail()
{
    qh = qt = &qu[0]; qt++; qu[0] = rt;
    while(qh!=qt)
    {
        tn *q = (*qh)->f->fail; int c = (*qh)->c; 
        while(q!=rt&&!q->son[c]) q = q->fail;
        if((*qh)!=rt&&q->son[c]&&q->son[c]!=(*qh)) (*qh)->fail = q->son[c]; else (*qh)->fail = rt;
        if((*qh)->fail!=*qh) link((*qh)->fail,*qh);
        for(map<int,tn*>::iterator it=(*qh)->son.begin();it!=(*qh)->son.end();it++) 
            (*qt++) = it->second;
        qh++;
    }
}
int dfs(tn *p)
{
    p->iw = ++tim; p->d = ++curd;
    int sz = 1, mx = 0, t;
    for(eg *pt=p->h;pt;pt=pt->nx)
    {
        sz += (t=dfs(pt->dt));
        if(t>mx) mx = t, p->hs = pt->dt;
    }
    p->ow = tim; curd--;
    return sz;
}
void pou(tn *p,tn *tp)
{
    p->top = tp;
    if(p->hs) pou(p->hs,tp);
    for(eg *pt=p->h;pt;pt=pt->nx) if(pt->dt!=p->hs) pou(pt->dt,pt->dt);
}
tn* getlca(tn *a,tn *b)
{
    while(a->top!=b->top)
    {
        if(a->top->d>b->top->d) a = a->top->fail;
        else b = b->top->fail;
    }
    return a->d<b->d?a:b;
}
bool cmp(const tn *a,const tn *b){ return a->iw<b->iw; }
void query(int k)
{
    int len = *bf++;
    tn *p = rt; qh = qt = &qu[0];
    int i,c;
    for(i=1;i<=len;i++)
    {
        c = *bf++;
        while(p!=rt&&!p->son[c]) p = p->fail;
        if(p->son[c]) p = p->son[c];
        *qt = p, qt++;
    }
    p = rt; len = *bf++;
    for(i=1;i<=len;i++)
    {
        c = *bf++;
        while(p!=rt&&!p->son[c]) p = p->fail;
        if(p->son[c]) p = p->son[c];
        *qt = p, qt++;
    }
    sort(qh,qt,cmp);
    add((*qh)->iw,1); tn *lst = *qh;
    for(qh++;qh!=qt;qh++)
    {
        if((*qh)==lst) continue;
        add((*qh)->iw,1);
        add(getlca(*qh,lst)->iw,-1); lst = *qh;
    }
    qh = &qu[0];
    ans[k] += sum2((*qh)->iw); lst = *qh;
    for(qh++;qh!=qt;qh++)
    {
        if((*qh)==lst) continue;
        ans[k] += sum2((*qh)->iw);
        ans[k] -= sum2(getlca(*qh,lst)->iw); lst = *qh;
    }
}
int main()
{
    int i;
    n = read(); m = read(); bf = buf;
    pl = &pool[0]; rt = pl++; rt->f = rt->fail = rt; eh = &e[0];
    for(i=1;i<=n;i++)
    {
        int x = read(); *bf++ = x;
        while(x--) *bf++ = read();
        x = read(); *bf++ = x;
        while(x--) *bf++ = read();
    }
    for(i=1;i<=m;i++) insert(i); tot = pl-pool;
    buildFail(); dfs(rt); pou(rt,rt);
    for(i=1;i<=m;i++) add2(nd[i]->iw-1,-1), add2(nd[i]->ow,1);
    bf = buf;
    for(i=1;i<=n;i++) query(i);
    for(i=1;i<=m;i++) printf("%d\n",sum(nd[i]->ow)-sum(nd[i]->iw-1));
    for(i=1;i<=n;i++) printf(i==n?"%d":"%d ",ans[i]);
    return 0;
}
```

---

## 作者：fighter_OI (赞：12)

题意：给定若干串对，求询问串作为几个串的子串出现过（若在同一串对里只算一次），并对每一串对，有多少个询问串是它的子串。

裸的广义SAM（用于多串匹配）。

普通SAM处理多串问题时，常在中间加分隔符，其实可以直接在处理完一个串后，把last=1就ok了。其他的一样。
计算时沿parent树往上跑，对沿途更新答案。

然后？

然后就没有了……

代码：
```cpp
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<cstring>
#include<memory.h>
#include<map>
#include<set>
#include<queue>
using namespace std; 
int len1[20005],len2[20005],ans[50005];
const int maxn=300005;
int str[maxn],n,m;
struct SAM
{
	int last,cnt,k,l[maxn<<1],fa[maxn<<1],siz[maxn<<1],las[maxn<<1];
	int marked[maxn<<1];//作为询问串的终点出现过几次
	map<int,int>ch[maxn<<1];
	inline void ins(int c)
	{
		int p=last,np=++cnt;
		last=np;
		l[np]=l[p]+1;
		for(;p&&!ch[p].count(c);p=fa[p])ch[p][c]=np;
		if(!p)fa[np]=1;else
		{
			int q=ch[p][c];
			if(l[p]+1==l[q])fa[np]=q;else
			{
				int nq=++cnt;
				l[nq]=l[p]+1;
				ch[nq]=ch[q];
				fa[nq]=fa[q];fa[q]=fa[np]=nq;
				for(;ch[p][c]==q;p=fa[p])ch[p][c]=nq;
			}
		}
	}
	inline void updata1(int x,int y)//对于第一问
	{
		for(;x&&las[x]!=y;x=fa[x])
		{
			siz[x]++;las[x]=y;
		}
	}
	inline void updata2(int x,int y)//对于第二问
	{
		for(;x&&las[x]!=y;x=fa[x])
		{
			las[x]=y;
			ans[y]+=marked[x];
		}
	}
	inline void build()
	{
		scanf("%d%d",&n,&m);
		int tot=0;
		cnt=1;
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&len1[i]);
			last=1;
			for(int j=1;j<=len1[i];j++)
			{
				scanf("%d",&str[++tot]);
				ins(str[tot]);
			}
			scanf("%d",&len2[i]);
			last=1;
			for(int j=1;j<=len2[i];j++)
			{
				scanf("%d",&str[++tot]);
				ins(str[tot]);
			}
		}
		tot=0;
		for(int i=1;i<=n;i++)
		{
			for(int j=1,x=1;j<=len1[i];j++)updata1(x=ch[x][str[++tot]],i);
			for(int j=1,x=1;j<=len2[i];j++)updata1(x=ch[x][str[++tot]],i);
		}
	}
	inline void solve()
	{
		while(m--)
		{
			int len;
			scanf("%d",&len);
			bool flag=0;
			int x=1;
			for(int i=1;i<=len;i++)
			{	
				int d;
				scanf("%d",&d);
				if(!flag)
				{
					if(ch[x].count(d))x=ch[x][d];else flag=1;
				}
			}
			if(!flag)marked[x]++,printf("%d\n",siz[x]);else puts("0");
		}
		int tot=0;
		for(int i=1;i<=cnt;i++)las[i]=0;
		for(int i=1;i<=n;i++)
		{
			for(int j=1,x=1;j<=len1[i];j++)updata2(x=ch[x][str[++tot]],i);
			for(int j=1,x=1;j<=len2[i];j++)updata2(x=ch[x][str[++tot]],i);
		}
		for(int i=1;i<=n;i++)printf("%d ",ans[i]);
	}
}sam;
int main(){sam.build();sam.solve();}
```

---

## 作者：Accoty_AM (赞：11)

我来放个可以优化到近似 $O(n)$ 的 $SAM$ 题解

### 第一问：询问一个串是多少个串的子串

首先对所有猫的名字建 **广义 $SAM$**，点名时，将字符串放到 $SAM$ 里面跑，最终到达节点 $x$。

这时考虑暴力，前面猫名字的贡献怎样才能统计到节点 $x$ ，就是对每个名字的所有前缀的后缀，暴力跳 $fail$ 边，对每个首次跳到的节点权值 ```++sum[p]```，最后直接输出 $sum[x]$

考虑到上面的过程就是对点 $x$ 到根的链+1，但是不能重复，对所有要跳 $fail$ 边的节点，按照 $dfs$ 序排序，用树上差分，每次对 $x$ 到根 +1， 对 $lca(x, x -1)$ 到根 -1，这样就不重不漏的加完了。

### 第二问：询问一个串包含多少个给定串
每次在后缀自动机中跑到 $x$，就对 $x$ 点+1

暴力：对名字的每个前缀的后缀，跳 $fail$ 边，每次遇到一个新的 $x$ 就把 $x$ 的贡献加进来

考虑一个点 $x$ 从多少个节点跳 $fail$ 可以统计到 $x$, 那就是 $x$ 的子树，那一个 $x$ 就可以转化为区间加, 用 $dfs$ 序可以优化到 $O(n)$

同理，对（名字）所有前缀的后缀节点按照 $dfs$ 序排序，把贡献加一加就行了

这个算法的复杂度瓶颈在于 $SAM$ 的节点访问 (用的 $map$)，排序和求 $lca$，排序可以用基数排序，$lca$ 可以离线 $tarjan$, $SAM$ 访问节点接近 $O(1)$

至此，我们获得了一个近似 $O(n)$ 的算法

由于那几个优化太恶心我实现是 $n\ log\ n$ 的

$code$ 并不优美的实现 $O2$ 跑了 $400+ms$

```cpp
#include <bits/stdc++.h>
using namespace std;
char ss[1 << 17], *A = ss, *B = ss;
inline char gc(){ if(A == B){ B = (A = ss) + fread(ss, 1, 1 << 17, stdin); if(A == B) return EOF; } return *A++; }
#define rg register
inline int read(){
    rg char ch = gc();
    rg int x = 0, f = 0;
    while(!isdigit(ch)) f |= (ch == '-'), ch = gc();
    while(isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = gc();
    return f ? -x : x;
}
#define rep(i, a, b) for(int i = a; i <= b; ++i)
const int N = 1e5 + 5;
namespace SAM{
        
    int len[N], link[N], cnt = 1, sum[N], last;
    map<int, int> tr[N];
    inline int insert(int c){
        int p = last;
        if(tr[p].count(c)){
            int q = tr[p][c];
            ++sum[q];
            if(len[q] == len[p] + 1) return q;
            int clone = ++cnt;
            len[clone] = len[p] + 1;
            tr[clone] = tr[q];
            link[clone] = link[q];
            while(p && tr[p][c] == q) tr[p][c] = clone, p = link[p];
            link[q] = clone;
            return clone;
        }
        int cur = ++cnt;
        len[cur] = len[last] + 1;
        while(p && !tr[p].count(c)) tr[p][c] = cur, p = link[p];
        if(!p){
            link[cur] = 1;
        }else{
            int q = tr[p][c];
            if(len[q] == len[p] + 1){
                link[cur] = q;
            }else{
                int clone = ++cnt;
                tr[clone] = tr[q];
                link[clone] = link[q];
                while(p && tr[p][c] == q) tr[p][c] = clone, p = link[p];
                link[cur] = link[q] = clone;
            }
        }
        return cur;
    }
    int head[N], nxt[N << 1], ver[N << 1], tot, dfn[N];
    inline void add(int x, int y){
        ver[++tot] = y;
        nxt[tot] = head[x];
        head[x] = tot;
    }
    int sz[N], son[N], top[N], dep[N], dfncnt, f[N];
    void dfs1(int x){
        sz[x] = 1;
        dfn[x] = ++dfncnt;
        for(int i = head[x]; i; i = nxt[i]){
            int y = ver[i];
            if(y == link[x]) continue;
            dep[y] = dep[x] + 1;
            dfs1(y);
            if(sz[y] > sz[son[x]]) son[x] = y;
            sz[x] += sz[y];
        }
    }
    void dfs2(int x, int f){
        top[x] = f;
        if(son[x]) dfs2(son[x], f);
        for(int i = head[x]; i; i = nxt[i]){
            int y = ver[i];
            if(y == link[x] || y == son[x]) continue;
            dfs2(y, y);
        }
    }
    inline int LCA(int x, int y){
        while(top[x] ^ top[y]) dep[top[x]] > dep[top[y]] ? x = link[top[x]] : y = link[top[y]];
        return dep[x] < dep[y] ? x : y;
    }
}
int n, m;
int len1[N], len2[N];
int s[N << 1], str[N], ans[N], g[N];
struct node{
    int x, val;
    inline bool operator < (const node &rhs) const {
        return val < rhs.val;
    }
}data[N];
void dfs(int x){
    for(int i = SAM :: head[x]; i; i = SAM :: nxt[i]){
        int y = SAM :: ver[i];
        if(y == SAM :: link[x]) continue;
        dfs(y);
        SAM :: f[x] += SAM :: f[y];
    }
}
int dcnt;
inline void init(){
    n = read(), m = read();
    int tot = 0;
    rep(i, 1, n){
        len1[i] = read();
        SAM :: last = 1;
        for(int j = 0; j < len1[i]; ++j){
            s[++tot] = read();
            SAM :: last = SAM :: insert(s[tot]);
        }
        len2[i] = read();
        SAM :: last = 1;
        for(int j = 0; j < len2[i]; ++j){
            s[++tot] = read();
            SAM :: last = SAM :: insert(s[tot]);
        }
    }
    rep(i, 2, SAM :: cnt) SAM :: add(SAM :: link[i], i);
    SAM :: dfs1(1); SAM :: dfs2(1, 1);
    tot = 0;
    rep(i, 1, n){
        dcnt = 0;
        for(int x = 1, j = 0; j < len1[i]; ++j) x = SAM :: tr[x][s[++tot]], data[++dcnt] = (node){x, SAM :: dfn[x]};
        for(int x = 1, j = 0; j < len2[i]; ++j) x = SAM :: tr[x][s[++tot]], data[++dcnt] = (node){x, SAM :: dfn[x]};
        sort(data + 1, data + dcnt + 1);
        ++SAM :: f[data[1].x];
        rep(i, 2, dcnt){
            int lca = SAM :: LCA(data[i - 1].x, data[i].x);
            ++SAM :: f[data[i].x]; --SAM :: f[lca];
        }
    }
    dfs(1);
    while(m--){
        int len = read();
        int x = 1, flag = 0;
        rep(i, 1, len){
            int c = read();
            if(!flag){
                if(!SAM :: tr[x].count(c)) flag = 1;
                else x = SAM :: tr[x][c];
            }
        }
        if(!flag){
            printf("%d\n", SAM :: f[x]);
            // cout<<" dfn "<<SAM :: dfn[x]<<" "<<SAM :: dfn[x] + SAM :: sz[x]<<endl;
            ++g[SAM :: dfn[x]]; --g[SAM :: dfn[x] + SAM :: sz[x]];
        }else puts("0");
    }
}
inline void work(){
    rep(i, 1, SAM :: cnt) g[i] += g[i - 1];
    int tot = 0;
    rep(i, 1, n){
        dcnt = 0;
        for(int x = 1, j = 0; j < len1[i]; ++j) x = SAM :: tr[x][s[++tot]], data[++dcnt] = (node){x, SAM :: dfn[x]};
        for(int x = 1, j = 0; j < len2[i]; ++j) x = SAM :: tr[x][s[++tot]], data[++dcnt] = (node){x, SAM :: dfn[x]};
        sort(data + 1, data + dcnt + 1);
        ans[i] += g[SAM :: dfn[data[1].x]];
        rep(j, 2, dcnt){
            int lca = SAM :: LCA(data[j - 1].x, data[j].x);
            ans[i] += g[SAM :: dfn[data[j].x]]; ans[i] -= g[SAM :: dfn[lca]];
        }
    }
    rep(i, 1, n) printf("%d ", ans[i]);
}
signed main(){
    init(); work();
    gc(), gc(); //end
    return 0;
}
```


---

## 作者：Fading (赞：11)

恐怖如斯

我这题昨天晚上开的，想了$30$分钟不会，周神想了$30$分钟做出来了和我讲，打了$30$分钟模板，今天写了$30$分钟，调了$1$个半小时终于$AC$了！

$217$行（含调试代码）舒服啊！

这真的是一道~~毒瘤~~好题！

好吧，讲正解：$SA+ST+\text{二分}+\text{线段树}$

我们把每一个姓和名用一个没有出现过的字符连起来。

然后把所有喵星人的名字以及点名串连成一个大字符串（中间用一些没有出现过的字符连起来）
```
N=read(),Q=read();
//N是有多少个人，id是这个位置属于哪一个人（中间字符为0）
//Q是询问个数，whtpos记录每一个询问的初始位置
for (int i=1;i<=N;i++){
    int x1=read();
    for (int j=1;j<=x1;j++){
        a[++cnt]=read()+1;id[cnt]=i;
    }
    a[++cnt]=10000+2*i-1;//没出现过的字符
    int x2=read();
    for (int j=1;j<=x2;j++){
        a[++cnt]=read()+1;id[cnt]=i;
    }
    a[++cnt]=10000+2*i;//没出现过的字符
}
for (int i=1;i<=Q;i++){
    Len[i]=read();
    whtpos[i]=cnt+1;
    for (int j=1;j<=Len[i];j++){
        a[++cnt]=read()+1;id[cnt]=0;
    }
    a[++cnt]=100000+2*N+i;//没出现过的字符
}
```

~~很丑是不是~~

求$SA,$以及$Height$数组。

然后我们找到每一个点名串开头的字符位置，即$whtpos[i],$

我们把答案位置转换到后缀上，注意到我们要找的后缀位置$x$满足

$LCP(whtpos[i],x)\geq Len[i]$

$Len[i]$就是本次询问的串的长度

也就是说，第$i$次询问的答案就是

$\sum_{j=1}^{cnt}[LCP(whtpos[i],j)\geq Len[i]]$

$cnt$就是总的字符串的长度

我们就可以想到对$Height$数组进行二分！因为根据$Height$的定义，可知$LCP(sa[x],sa[y])=min_{i=x+1}^{y}Height[i]$

所以二分一个左端点$l,$满足

$LCP(sa[l],ra[whtpos[i])\geq Len[i]$且$l$最小

同理二分一个右端点$r$且$r$最大
```
int lb=1,rb=ra[whtpos[i]],ansl=ra[whtpos[i]];
while (lb<=rb){
    int mid=lb+rb>>1;
    if (ST_query(mid,ra[whtpos[i]])>=Len[i]){
        rb=mid-1;ansl=mid;
    }else{
        lb=mid+1;
    }
}
int ansr=ra[whtpos[i]]-1;lb=ra[whtpos[i]],rb=cnt;
while (lb<=rb){
    int mid=lb+rb>>1;
    if (ST_query(ra[whtpos[i]],mid)>=Len[i]){
        lb=mid+1;ansr=mid;
    }else{
        rb=mid-1;
    }
}
```
问题就转化成了排名$l,l+1,...,r$有多少个不同的人！

这不就是$\text{P1972 [SDOI2009]HH的项链}$吗？

那就做完啦！

等等第二问？？？？？

$------------$

问题：
```
给定一个序列，每次询问求一个区间有多少个颜色，

最后输出每一个颜色被多少个询问区间覆盖过？
```

考虑使用线段树，和一个$pre$数组记录上一个出现的颜色位置（不会左转[$\text{P1972 [SDOI2009]HH的项链}$](https://www.luogu.org/blog/user3432/solution-p1972)）

上面的题解虽然是用树状数组的但其实一样。

我们对线段树的叶子节点打一个颜色标记，对于出现了一个颜色，给这个位置的叶子节点打上颜色标记，把$pre$数组指向的位置删去颜色标记，然后给这个颜色的答案加上$pre$数组指向的位置对应的叶子节点被区间覆盖过的次数。

每一次询问完了就给询问区间的所有节点覆盖次数加上$1$

这道题就好了！

还是看看代码加强理解好了，如果还是不会就私信问我$qwq$

最后的时候要遍历线段树，把所有的叶子节点的颜色标记都删掉，然后更新答案。

不要忘记$pushdown$!

```
#include <bits/stdc++.h>
#define ll long long
using namespace std;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();};
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-48;ch=getchar();};
    return x*f; 
}
int N,Q,cnt,maxx,a[500101],Id[500101];
int hi[500101],c[500101],wht[500101],id[500101],sa[500101],ra[500101],hei[500101],pos[500101];
inline void qsort(int n,int m){
    for (register int i=0;i<=m;i++) c[i]=0;
    for (register int i=1;i<=n;i++) c[ra[i]]++;
    for (register int i=1;i<=m;i++) c[i]+=c[i-1];
    for (register int i=n;i;i--) sa[c[ra[pos[i]]]--]=pos[i];
}
inline void GetSA(int n){
    for (register int i=1;i<=n;i++) ra[i]=a[i],pos[i]=i;
    int m=400000;
    //cout<<m<<endl;
    qsort(n,m);
    for (register int w=1,p=0;p<n;m=p,w<<=1){
        p=0;
        for (register int i=1;i<=w;i++) pos[++p]=n-w+i;
    	for (register int i=1;i<=n;i++){     
        	if (sa[i]>w) pos[++p]=sa[i]-w;
        }
        //cout<<"2";
        qsort(n,m);
        swap(pos,ra);
        ra[sa[1]]=p=1;
        for (register int i=2;i<=n;i++){
            //cout<<"1";
            if (pos[sa[i-1]]==pos[sa[i]]&&pos[sa[i-1]+w]==pos[sa[i]+w]){
                ra[sa[i]]=p;
            }else ra[sa[i]]=++p;
        }
    }
}
inline void GetHeight(int n){
    register int ans=0;
    for (register int i=1;i<=n;i++){
        if (ans) ans--;
        register int j=sa[ra[i]-1];
        while (a[j+ans]==a[i+ans]) ans++;
        hei[ra[i]]=ans;
    }
}
int F[500101][24];
inline void GetST(int n){
    for (int i=1;i<=n;i++) F[i][0]=hei[i];
    for (int j=1;j<=22;j++){
        for (int i=1;i+(1<<j)<=n+1;i++){
            F[i][j]=min(F[i][j-1],F[i+(1<<(j-1))][j-1]);
        }
    }
}
inline int ST_query(int l,int r){
    if (l==r) return 999999999;
    if (l>r) swap(l,r);
    l++;
    int k=log2(r-l+1);
    return min(F[l][k],F[r-(1<<k)+1][k]);
}
namespace XDS{
    struct node{
        int tot=0,col,lazy=0,coltot=0;
    }g[2000001];
    int ans[100001],MMM;
    inline void pushup(int rt){
        g[rt].tot=g[rt*2].tot+g[rt*2+1].tot;
        g[rt].coltot=g[rt*2].coltot+g[rt*2+1].coltot;
    }
    inline void pushdown(int rt,int l,int r){
        if (g[rt].lazy!=0){
            int mid=(l+r)>>1,lson=rt*2,rson=rt*2+1;
            g[lson].lazy+=g[rt].lazy;g[rson].lazy+=g[rt].lazy;
            g[lson].tot+=(mid-l+1)*g[rt].lazy;g[rson].tot+=(r-mid)*g[rt].lazy;
            g[rt].lazy=0;
        }
    }
    inline void delcol(int rt,int lb,int rb,int pos,int x){
        if (lb==rb){
            if (x==-1) ans[g[rt].col]+=g[rt].tot,g[rt].col=g[rt].coltot=0,g[rt].tot=0;
            else g[rt].col=x,g[rt].coltot=1;
            MMM=max(MMM,rt);
            return;
        }
        int mid=lb+rb>>1;pushdown(rt,lb,rb);
        if (mid>=pos) delcol(rt<<1,lb,mid,pos,x);
        else delcol(rt<<1|1,mid+1,rb,pos,x);
        pushup(rt);
    }
    inline void change(int rt,int l,int r,int lb,int rb,ll xx){
   		if (l>rb||r<lb) return;
    	if (l>=lb&&r<=rb){g[rt].lazy+=xx;g[rt].tot+=(r-l+1)*xx;return;}
    	pushdown(rt,l,r);int mid=(l+r)>>1;
    	change(rt*2,l,mid,lb,rb,xx);change(rt*2+1,mid+1,r,lb,rb,xx);
    	pushup(rt);
    }
    inline ll query(int rt,int l,int r,int lb,int rb){
        if (l>rb||r<lb) return 0;
        if (l>=lb&&r<=rb) return g[rt].coltot;
        pushdown(rt,l,r);
        int mid=(l+r)>>1;
        return (query(rt*2,l,mid,lb,rb)+query(rt*2+1,mid+1,r,lb,rb));
    }
    inline void sbhy(int rt,int l,int r){
   		if (g[rt].col) ans[g[rt].col]+=g[rt].tot;
   		if (l==r) return;
   		pushdown(rt,l,r);
   		int mid=l+r>>1;
   		sbhy(rt<<1,l,mid);sbhy(rt<<1|1,mid+1,r);
    }
}
int pre[400101],AnS[400101],whtpos[400101],Len[400101];
struct aque{
    int id,ans,l,r;
}que[1000101];
inline bool Cmp(aque a,aque b){
    return a.r<b.r;
}
int main(){
    int cnt=0;
    N=read(),Q=read();
    for (int i=1;i<=N;i++){
        int x1=read();
        for (int j=1;j<=x1;j++){
            a[++cnt]=read()+1;id[cnt]=i;
        }
        a[++cnt]=10000+2*i-1;
        int x2=read();
        for (int j=1;j<=x2;j++){
            a[++cnt]=read()+1;id[cnt]=i;
        }
        a[++cnt]=10000+2*i;
    }
    for (int i=1;i<=Q;i++){
        Len[i]=read();
        whtpos[i]=cnt+1;
        for (int j=1;j<=Len[i];j++){
            a[++cnt]=read()+1;id[cnt]=0;
        }
        a[++cnt]=100000+2*N+i;
    }
    //for (int i=1;i<=cnt;i++) cout<<a[i]<<" ";
    GetSA(cnt);
    GetHeight(cnt);
    GetST(cnt);
    //for (int i=1;i<=cnt;i++){
        //printf("%c:%d->%d ",a[sa[i]]+'a'-1,i,sa[i]);
    //}
    //printf("\n");
    //printf("\n");
    for (int i=1;i<=cnt;i++) Id[i]=id[sa[i]];
    for (int i=1;i<=Q;i++){
        int lb=1,rb=ra[whtpos[i]],ansl=ra[whtpos[i]];
        //cout<<"Start"<<rb<<":";
        while (lb<=rb){
            int mid=lb+rb>>1;//cout<<mid<<" ";
            if (ST_query(mid,ra[whtpos[i]])>=Len[i]){
                rb=mid-1;ansl=mid;
            }else{
                lb=mid+1;
            }
        }
        //cout<<"|";
        int ansr=ra[whtpos[i]]-1;lb=ra[whtpos[i]],rb=cnt;
        //cout<<"Start"<<lb<<":";
        while (lb<=rb){
            int mid=lb+rb>>1;//cout<<mid<<" ";
            if (ST_query(ra[whtpos[i]],mid)>=Len[i]){
                lb=mid+1;ansr=mid;
            }else{
                rb=mid-1;
            }
        }
        que[i].id=i,que[i].l=ansl,que[i].r=ansr;
        //cout<<endl<<ansl<<" "<<ansr<<":"<<endl;
        //for (int i=ansl;i<=ansr;i++){
            //printf("%d ",Id[i]);
        //}
    }
    //cout<<endl;
    sort(que+1,que+1+Q,Cmp);
    int pos=1;
    for (int i=1;i<=Q;i++){
        while (pos<=que[i].r){
            if (!pre[Id[pos]]){
                pre[Id[pos]]=pos;
                if (Id[pos]){
                    XDS::delcol(1,1,cnt,pos,Id[pos]);
                    //cout<<"Add:"<<pos<<","<<Id[pos]<<endl;
                }
            }else{
                if (Id[pos]) XDS::delcol(1,1,cnt,pre[Id[pos]],-1);
                    //cout<<"Del:"<<pre[Id[pos]]<<","<<Id[pos]<<endl;
                pre[Id[pos]]=pos;
                if (Id[pos]){
                    XDS::delcol(1,1,cnt,pos,Id[pos]);
                    //cout<<"Add:"<<pos<<","<<Id[pos]<<endl;
                }
            }
            pos++;
        }
        AnS[que[i].id]=XDS::query(1,1,cnt,que[i].l,que[i].r);
        XDS::change(1,1,cnt,que[i].l,que[i].r,1);
    }
    XDS::sbhy(1,1,cnt);
    for (int i=1;i<=Q;i++){
        printf("%d\n",AnS[i]);
    }
    for (int i=1;i<=N;i++){
        printf("%d ",XDS::ans[i]);
    }
}

```



---

## 作者：Flandre_495 (赞：8)

一道好题

萌新刚学sa，这题做了好久~，额，~~菜死了~~。

写篇题解纪念一下，对跟我一样的萌新可能稍友好一些， **后缀数组+树状数组** 做法。

#### 这题到底想让我们干啥？

如果我们将所有人的名字和询问拼起来，排好序后再求height数组，一个询问和名字中某段相同就是指这个字符串与询问字符串之间的height值都大于等于询问长度。不懂为什么可以看这题：[牛奶模式](https://www.luogu.com.cn/problem/P2852)。

那么对于第一问，每一个询问字符串，我们可以向左向右找到一个区间，这个区间内所有的sa就代表了匹配成功的字符串的位置。

那么问题来了，这些位置可能是来自同一个人的（为了防止姓和名连起来，我们也给中间加一字符隔开），也可能来自不同人，所以我们现在的任务是找每一个询问区间，包含多少不同的人。即给每一个位置染色，多组询问区间内有多少不同颜色，很熟悉吧~：[HH的项链](https://www.luogu.com.cn/problem/P1972)。

第二问：如果会了第一问的话理解起来应该也不难，你需要统计每一种颜色在多少区间内出现过。我们仍然把区间按右端排序，还是尽量将同种颜色的判定点位置往右移。我们将所有区间左端点+1，每到一个右端点，让它对应的左端点-1，表示这个区间结束，那些左端点没被减掉的，说明到当前位置，这个区间仍然存在。然后对于每一个点，我们考虑它的贡献，就是考虑有多少区间包含它，为了防止一个区间包含很多这种颜色的点而重复计算，我们只统计它和同颜色的上一个点之间，有多少区间左端点存在。其实是将每个点的贡献记成它在多少个区间中是第一个出现的。嗯，这样实现起来跟第一问差不多了。

所以这题的步骤和复杂度分析：

```
1.拼接字符   O(n)
2.后缀排序   O(nlogn)
3.求出height O(n)
4.求出每个询问的左右区间 O(n)
5.两次树状数组求出答案 O(nlogn)

```

至于怎么在O(n)时间内求出询问区间，这算是个基本功吧。。。我们搞个单调栈记录height，就可以求此位置前第一个小于它的数和后面第一个小于它的数（不懂的可以想想）。这题只需要求左边就可了，与询问相同的串，sa排好序后肯定在它前面，因为询问串后面接的是一个特别大的分隔符啊，如果有跟它相同且在它右边的，也只能是其他的询问了~

代码的话，我写的可能比较丑。。。其他题解也有相同思路的，可以康他们代码，我象征性地放一下：

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#define QWQ cout<<"QwQ"<<endl;
#define ll unsigned long long
#include <vector>
#include <queue>
#include <stack>
#include <map>
using namespace std;
const int N=601010;
const int qwq=303030;
const int inf=0x3f3f3f3f;

int n,m,Q;
int a[N],cl[N],tot,obgg=11111;           //“ob给给”是分隔符，cl表示颜色
int chang[N];                            //询问长度
int sa[N],rk[N],tp[N],c[N],h[N];         //后缀数组的那些
int pre[N],wei[N];                       //求同颜色上一个位置
bool xun[N];                             //是否为询问串第一个位置
int q[N],now;                            //单调栈
struct E{ int id,l,r; } qu[N];           //询问区间
inline bool cmp(E aa,E bb) { return aa.r < bb.r; }
int tree[N],ans1[N],ans2[N];             //树状数组及答案 

inline int read() {
	int sum = 0, f = 1; char c = getchar();
	while(c<'0' || c>'9') { if(c=='-') f = -1; c = getchar(); }
	while(c>='0'&&c<='9') { sum = sum * 10 + c - '0'; c = getchar(); }
	return sum * f;
}

void Qsort() {                         //鸡排
	memset(c,0,sizeof(c));
	for(int i=1;i<=n;i++) c[rk[i]]++;
	for(int i=1;i<=m;i++) c[i] += c[i-1];
	for(int i=n;i>=1;i--) sa[ c[rk[tp[i]]]-- ] = tp[i];
}

void SA() {                            //sa
	int p, l = 0;
	m = obgg;
	for(int i=1;i<=n;i++) rk[i] = a[i], tp[i] = i;
	Qsort();
	for(int k=1; ;k<<=1) {
		p = 0;
		for(int i=1;i<=k;i++) tp[++p] = n-k+i;
		for(int i=1;i<=n;i++) if(sa[i]>k) tp[++p] = sa[i]-k;
		Qsort(); swap(tp,rk);
		rk[ sa[1] ] = p = 1;
		for(int i=2;i<=n;i++) {
			if(tp[sa[i-1]]==tp[sa[i]] && tp[sa[i-1]+k]==tp[sa[i]+k])
				rk[sa[i]] = p;
			else
				rk[sa[i]] = ++p;
		}
		m = p; if(p==n) break;
	}
	for(int i=1; i<=n; h[rk[i++]]=l)
		for(l=(l?l-1:0),p=sa[rk[i]-1]; a[i+l]==a[p+l]; ++l);
}

//树状数组我给压成两行了
inline void add(int we,int g) { if(!we) return; for(int i=we;i<=n;i+=(i&-i)) tree[i]+=g; }
inline int ask(int we) { int res = 0; for(int i=we;i;i-=(i&-i)) res+=tree[i]; return res; }

void Kochiya() {           //求出询问左右区间
	h[0] = h[n+1] = -inf; now = 0;
	for(int i=1;i<=n;i++) {
		int col = cl[ sa[i] ];
		if(col>0) pre[i] = wei[col], wei[col] = i;
		while(h[i]<=h[q[now]]) now--; q[++now] = i;
		if(xun[ sa[i] ]) {
			while(chang[-col]<=h[q[now]]) now--;
			qu[-col].l = q[now];
			qu[-col].r = i-1;
			qu[-col].id = -col;
			if(q[now]<=i-1) add(q[now],1);
		}
	}
	sort(qu+1,qu+Q,cmp);    //然后排序
}

void Sanae() {              //求答案
	now = 0;
	for(int i=1;i<=Q;i++) {
		if(qu[i].l > qu[i].r) continue;
		while(now!=qu[i].r) {
			now++; int col = cl[ sa[now] ];
			if(col>0) ans2[col] += ask(now) - ask(pre[now]);
		}
		add(qu[i].l,-1);
	}
	now = 0;
	for(int i=1;i<=Q;i++) {
		if(qu[i].l > qu[i].r) continue;
		while(now!=qu[i].r) {
			now++; int col = cl[ sa[now] ];
			if(col>0) add(now,1), add(pre[now],-1);
		}
		ans1[qu[i].id] = ask(qu[i].r)-ask(qu[i].l-1);
	}
}

int main() {
	int x,num;
	num = read(); Q = read();
	for(int i=1;i<=num;i++) {
		x = read();
		while(x--) a[++tot] = read(), cl[tot] = i;
		a[++tot] = ++obgg;
		x = read();
		while(x--) a[++tot] = read(), cl[tot] = i;
		a[++tot] = ++obgg;
	}
	for(int i=1;i<=Q;i++) {
		chang[i] = read(); xun[tot+1] = 1;
		for(int j=1;j<=chang[i];j++) a[++tot] = read(), cl[tot] = -i;   //询问的颜色设成负数，便于分辨。
		a[++tot] = ++obgg;
	}
	a[0] = inf;     //因为排好序后前面有一堆0，应当把0号位置改成别的，否则求height时会出错。
	n = tot;
	SA();
	Kochiya();
	Sanae();
	for(int i=1;i<=Q;i++) cout<<ans1[i]<<"\n";
	for(int i=1;i<=num;i++) cout<<ans2[i]<<" ";
	return 0;
}

```

这是CSP爆炸后写的第一篇题解哎~，最近太颓废了。

---

## 作者：Xiaojian_xiang (赞：6)

楼下的题解都好吓人……

其实这题就是个AC自动机的板子题啊……

明明不用楼下大家的方法这么麻烦【不针对个人只针对这道题目】

首先我们对每个节点进行hash一下看这个节点有没有被用过……然后AC自动机可以很轻松的搞掉两个问……

将老师点名的串插到自动机里然后拿姓和名字去AC自动机里面变匹配边维护就好了……

然后又一个小细节……不能使用memset清零数组……这样就会退化到\_O(n^2)\_在找的过程中记录修改的点之后改回来就好了……yy一下玄学复杂度QAQ……

上代码吧：












```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=20010;
const int MAXM=50010;
const int MAXC=100010;
int read(){
    int a(0);char c=getchar();
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9') a=(a<<3)+(a<<1)+c-'0',c=getchar();
    return a;
}
vector<int> x[MAXN],na[MAXN];
int tot(0);
int fail[MAXC];
vector<int> en[MAXC];
map<int,int> to[MAXC];
int n,m;
vector<int > V;
vector<int > M;
int vis[MAXC],mark[MAXM];
int ans1[MAXM],ans2[MAXN];
void insert(int id){
    int L=read();
    int now(0);
    for(int i=0;i<L;i++){
        int u=read();
        if(!to[now][u]) to[now][u]=++tot;
        now=to[now][u];
    }
    en[now].push_back(id);
}
queue<int > q;
void build(){
    fail[0]=0;
    for(map<int,int>::iterator i=to[0].begin();i!=to[0].end();++i) {q.push(i->second);fail[i->second]=0;}
    while(!q.empty()){
        int now=q.front();q.pop();
        for(map<int,int>::iterator i=to[now].begin();i!=to[now].end();++i){
            int t=i->first,k=fail[now];
            while(k&&!to[k][t]) k=fail[k];
            fail[i->second]=to[k][t];
            q.push(i->second);
        }
    }
}
void solx(int id){
    int now(0),beg(0);
    while(beg<x[id].size()){
        int index=x[id][beg];
        while(now&&!to[now][index]) now=fail[now];
        now=to[now][index];
        int tmp(now);
        while(tmp){
            if(vis[tmp]) {tmp=fail[tmp];continue;}
            vis[tmp]=1;V.push_back(tmp);
            for(int i=0;i<en[tmp].size();i++){
                if(mark[en[tmp][i]]) continue;
                mark[en[tmp][i]]=1;M.push_back(en[tmp][i]);
                ++ans1[en[tmp][i]];++ans2[id];
            }
            tmp=fail[tmp];
        }
        ++beg;
    }
}
void solna(int id){
    int now(0),beg(0);
    while(beg<na[id].size()){
        int index=na[id][beg];
        while(now&&!to[now][index]) now=fail[now];
        now=to[now][index];
        int tmp=now;
        while(tmp){
            if(vis[tmp]) {tmp=fail[tmp];continue;}
            vis[tmp]=1;V.push_back(tmp);
            for(int i=0;i<en[tmp].size();i++){
                if(mark[en[tmp][i]]) continue;
                mark[en[tmp][i]]=1;M.push_back(en[tmp][i]);
                ++ans1[en[tmp][i]];++ans2[id];
            }
            tmp=fail[tmp];
        }
        ++beg;
    }
}
void input(){
    n=read();m=read();
    for(int i=0;i<n;i++){
        int u=read();
        for(int j=0;j<u;j++){
            int v=read();
            x[i].push_back(v);
        }
        u=read();
        for(int j=0;j<u;j++){
            int v=read();
            na[i].push_back(v);
        }
    }
    for(int i=0;i<m;i++) insert(i);
    build();
}
void xxj(){
    for(int i=0;i<n;i++){
        solx(i);
        solna(i);
        for(int i=0;i<V.size();i++) vis[V[i]]=0;
        for(int i=0;i<M.size();i++) mark[M[i]]=0;
        V.clear();M.clear();
    }
}
void output(){
    for(int i=0;i<m;i++) cout<<ans1[i]<<"\n";
    for(int i=0;i<n;i++) {cout<<ans2[i];if(i!=n-1) cout<<' ';}
    cout<<"\n";
}
int main(){
    input();
    xxj();
    output();
    return 0;
}
```

---

## 作者：nofind (赞：5)

## [题意](https://www.luogu.com.cn/problem/P2336)

我们将所有姓名串和点名串拼在一起，中间用原串中不会出现的数隔开，对每个点记录它是哪个串的。

先考虑第一问：

考虑如果点名串$s1$是某个姓名串$s2$的子串，则$s1$必定和$s2$的一个后缀$s2'$的$lcp$为$s1$的长度，即：$lcp(s1,s2')=len(s1)$。

对于一个点名串，以它作为前缀的后缀在后缀排序后必定是一个区间，我们可以二分得出，设为$[l,r]$，我们接下来就要统计$[l,r]$内出现的不同的姓名的个数，这是个经典问题，可以用$HH$的项链的的方法离线解决。

再考虑第二问：

我们可以算出每个点被多少询问区间覆盖，但这样会计重。

我们从$1$到$n$（$n$是串长）扫描所有位置，同时维护可以对这个位置产生贡献的区间。具体说就是对于$[l,r]$，我们在扫到$l$时它开始产生贡献，我们对$[l,r]$区间$+1$，在扫到$r+1$时，它不再产生贡献，我们对$[l,r]$区间$-1$，这个可以用差分实现。

现在考虑怎么算出当前位置$i$真正的贡献，即算出只包含$i$，而不包含$i$所在的原串的其他点的区间。我们找到$last_{pos_i}$，其中$pos_i$表示$i$所在原串，$last_{pos_i}$表示上一个属于$pos_i$这个原串的位置，那么答案就是$sum_i-sum_{last_{pos_i}}$。

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxm=5*1e4+10;
const int maxQ=1e5+10;
const int maxl=1e6+10;
int n,m,Q,num;
int a[maxl],len[maxl],firpos[maxl],pos[maxl],last[maxm],ans1[maxQ],ans2[maxm];
int sa[maxl],rk[maxl],oldrk[maxl],id[maxl],tmpid[maxl],cnt[maxl],lg[maxl];
int height[maxl][20];
struct Query{int l,r,id;}qr[maxQ];
inline void reads(int now)
{
	firpos[now]=n+1;
	scanf("%d",&len[now]);
	for(int i=1;i<=len[now];i++)scanf("%d",&a[++n]),pos[n]=now;
	a[++n]=now+10000;
}
inline bool cmp(Query x,Query y){return x.r<y.r;}
inline bool check(int x,int y,int k){return oldrk[x]==oldrk[y]&&oldrk[x+k]==oldrk[y+k];}
inline void SA_build()
{
	num=500000;
	for(int i=1;i<=n;i++)cnt[rk[i]=a[i]]++;
	for(int i=1;i<=num;i++)cnt[i]+=cnt[i-1];
	for(int i=n;i;i--)sa[cnt[rk[i]]--]=i;
	for(int t=1;t<=n;t<<=1)
	{
		int tot=0;
		for(int i=n-t+1;i<=n;i++)id[++tot]=i;
		for(int i=1;i<=n;i++)if(sa[i]>t)id[++tot]=sa[i]-t;
		tot=0;
		memset(cnt,0,sizeof(cnt));
		for(int i=1;i<=n;i++)cnt[tmpid[i]=rk[id[i]]]++;
		for(int i=1;i<=num;i++)cnt[i]+=cnt[i-1];
		for(int i=n;i;i--)sa[cnt[tmpid[i]]--]=id[i];
		memcpy(oldrk,rk,sizeof(rk));
		for(int i=1;i<=n;i++)rk[sa[i]]=check(sa[i-1],sa[i],t)?tot:++tot;
		num=tot;
	}
	for(int i=1,j=0;i<=n;i++)
	{
		if(j)j--;
		while(a[i+j]==a[sa[rk[i]-1]+j])j++;
		height[rk[i]][0]=j;
	}
	for(int j=1;j<=18;j++)
		for(int i=1;i+(1<<j)-1<=n;i++)
			height[i][j]=min(height[i][j-1],height[i+(1<<(j-1))][j-1]);
}
inline int query(int l,int r)
{
	l++;
	int t=lg[r-l+1];
	return min(height[l][t],height[r-(1<<t)+1][t]);
}
inline int findl(int id)
{
	int l=1,r=rk[firpos[id]]-1,res=rk[firpos[id]];
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(query(mid,rk[firpos[id]])<len[id])l=mid+1;
		else res=mid,r=mid-1;
	}
	return res;
}
inline int findr(int id)
{
	int l=rk[firpos[id]]+1,r=n,res=rk[firpos[id]];
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(query(rk[firpos[id]],mid)<len[id])r=mid-1;
		else res=mid,l=mid+1;
	}
	return res;
}
struct Tree_arry
{
	#define lowbit(x) (x&-x)
	int a[maxl];
	inline void clear(){memset(a,0,sizeof(a));}
	inline void add(int x,int k){for(int i=x;i<=n;i+=lowbit(i))a[i]+=k;}
	inline int query(int x){int res=0;for(int i=x;i;i-=lowbit(i))res+=a[i];return res;}
}tr;
int main()
{
	lg[0]=-1;
	for(int i=1;i<=1e6;i++)lg[i]=lg[i>>1]+1;
	scanf("%d%d",&m,&Q);
	for(int i=1;i<=m;i++)reads(2*i-1),reads(2*i);
	for(int i=1;i<=Q;i++)reads(2*m+i);
	SA_build();
	for(int i=1;i<=Q;i++)qr[i].l=findl(2*m+i),qr[i].r=findr(2*m+i),qr[i].id=i;
	sort(qr+1,qr+Q+1,cmp);
	for(int i=1,j=1;i<=Q;i++)
	{
		while(j<=qr[i].r)
		{
			if(pos[sa[j]]<=2*m)
			{
				if(last[(pos[sa[j]]+1)>>1])tr.add(last[(pos[sa[j]]+1)>>1],-1);
				last[(pos[sa[j]]+1)>>1]=j;
				tr.add(j,1);
			}
			j++;
		}
		ans1[qr[i].id]=tr.query(qr[i].r)-tr.query(qr[i].l-1);
	}
	for(int i=1;i<=m;i++)last[i]=0;
	tr.clear();
	for(int i=1;i<=Q;i++)tr.add(qr[i].l,1);
	for(int i=1,j=1;i<=n;i++)
	{
		while(j<=Q&&qr[j].r<i)tr.add(qr[j].l,-1),j++;
		if(pos[sa[i]]<=2*m)
		{
			ans2[(pos[sa[i]]+1)>>1]+=tr.query(i)-tr.query(last[(pos[sa[i]]+1)>>1]);
			last[(pos[sa[i]]+1)>>1]=i;	
		}
	} 
	for(int i=1;i<=Q;i++)printf("%d\n",ans1[i]);
	for(int i=1;i<=m;i++)printf("%d ",ans2[i]);
	return 0;
}
```


---

## 作者：ZlycerQan (赞：5)

/\*
BZOJ 2754: [SCOI2012]喵星球上的点名

 
此题有N种做法。。。

见到众dalao用各种奇怪的姿势AC此题。。


具体有 后缀数组 + 莫队

后缀数组 + 优化暴力

AC自动机 抽离Fail树

AC自动机 乱搞。。

AC自动机 + hash。。。


跪烂。。



bakabaka


我当然是开心的写了AC自动机 + 暴力转移啦。。

    
每次沿着fail指针跳，然后计算， 注意判断是否计算过

    
输入太恶心。。用map存Trie树的儿子节点即可

\*/
 
 
 
 
 
     
 
 
 
 
 
     
```cpp
#include <cstdio>
#include <map>
#include <vector>
#include <queue>
#define Max 80090
void read (int &now)
{
    now = 0;
    register char word = getchar ();
    while (word < '0' || word > '9')
        word = getchar ();
    while (word >= '0' && word <= '9')
    {
        now = now * 10 + word - '0';
        word = getchar ();
    }
}
int N, M;
struct T_D 
{
    int Flandre;
    int Id;
    T_D *Fail;
    std :: map <int, T_D *> child;
    T_D ()
    {
        child.clear ();
        Flandre = 0;
        Id = 0;
        Fail = NULL;
    }
};
std :: map <int, bool> visit;
std :: vector <int> name[Max];
std :: vector <int> count[Max * 3];
int Answer_1[Max];
int Answer_2[Max];
class AC_Type
{
```
private :
 
 
 
        T\_D \*Root ;

        int Count;

        int Insert\_Count;

public :

 
 
 
 
 
             
 
 
 
 
 







 

 
 
```cpp
        AC_Type ()
        {
            Count = 0;
            Root = new T_D ;
            Root->Id = ++ Count;
            Insert_Count = 0;
        }
        void Insert (int Len)
        {
            T_D *now = Root;
            int Id;
            for (int i = 1; i <= Len; i ++)
            {
                read (Id);  
                if (now->child[Id] == NULL)
                {
                    now->child[Id] = new T_D;
                    now->child[Id]->Id = ++ Count;
                }
                now = now->child[Id];
            }
            now->Flandre ++;
            count[now->Id].push_back (++ Insert_Count);
        }
        void Build_AC ()
        {
            std :: queue <T_D *> Queue;
            Queue.push (Root);
            T_D *now, *pos;
            while (!Queue.empty ())
            {
                now = Queue.front ();
                Queue.pop ();
                pos = NULL;
                for (std :: map <int, T_D *> :: iterator i = now->child.begin (); i != now->child.end (); i ++)
                {
                    if (now == Root)
                        i->second->Fail = Root;
                    else
                    {
                        for (pos = now->Fail; pos; pos = pos->Fail)
                            if (pos->child[i->first])
                            {
                                i->second->Fail = pos->child[i->first];
                                break;
                            }
                        if (pos == NULL)
                            i->second->Fail = Root;
                    }
                    Queue.push (i->second);
                }
            }
        }
        T_D *Get_Root ()
        {
            return Root;
        }
};
AC_Type Make;
void Calculate (T_D *now, int i)
{
    if (now->Flandre)
    {
        Answer_2[i] += now->Flandre;
        for (int k = 0; k < count[now->Id].size (); k ++)
            Answer_1[count[now->Id][k]] ++;
    }
}
int main (int argc, char *argv[])
{   
    read (N);
    read (M);
    for (int i = 1, x, y; i <= N; i ++)
    {
        read (x);
        for (int j = 1; j <= x; j ++)
        {
            read (y);
            name[i].push_back (y);
        }
        name[i].push_back (-1);
        read (x);
        for (int j = 1; j <= x; j ++)
        {
            read (y);
            name[i].push_back (y);
        }
        name[i].push_back (-2);
    }
    for (int i = 1, x; i <= M; i ++)
    {
        read (x);
        Make.Insert (x);
    }
    Make.Build_AC ();
    int Len;
    T_D *now , *pos;
    for (int i = 1; i <= N; i ++)
    {
        Len = name[i].size ();
        visit.clear ();
        now = Make.Get_Root ();
        pos = NULL;
        for (int j = 0; j < Len; j ++)
        {
            if (!visit[now->Id])
            {
                visit[now->Id] = true;
                Calculate (now, i);
                for (pos = now->Fail; pos; pos = pos->Fail)
                    if (!visit[pos->Id])
                    {
                        visit[pos->Id] = true;
                        Calculate (pos, i);
                    }
            }
            if (now->child[name[i][j]])
                now = now->child[name[i][j]];
            else
            {
                for (pos = now->Fail; pos; pos = pos->Fail)
                {
                    if (!visit[pos->Id])
                    {
                        visit[pos->Id] = true;
                        Calculate (pos, i);
                    }
                    if (pos->child[name[i][j]])
                    {
                        now = pos->child[name[i][j]];
                        for (T_D *Saber = pos->Fail; Saber; Saber = Saber->Fail)
                            if (!visit[Saber->Id])
                            {
                                visit[Saber->Id] = true;
                                Calculate (Saber, i);
                            }
                        break;
                    }
                }
                if (pos == NULL)
                    now = Make.Get_Root ();
            }
        }
    }
    for (int i = 1; i <= M; i ++)
        printf ("%d\n", Answer_1[i]);
    printf ("%d", Answer_2[1]);
    for (int i = 2; i <= N; i ++)
        printf (" %d", Answer_2[i]);
    return 0;
}
```

---

## 作者：六楼溜刘 (赞：4)

首先容易想到这道题能用 AC 自动机做，现在最高赞题解就是用的 AC 自动机。建出 $\mathrm{fail}$ 树后的操作可以参考已有题解，我就不多赘述了。但是现在的所有 AC 自动机题解构建 $\mathrm{fail}$ 指针都是暴力跳的，虽然很难卡，但是复杂度是假的。

这里提供一种 $O(N\log |\Sigma|)$ 的 AC 自动机建法，其中 $N$ 是字符串总长度，$\Sigma$ 是字符集。

众所周知，无论你是用通常写法每次把不存在的 $son_{u,c}$ 指向 $son_{fail_u,c}$，还是暴力跳 $\mathrm{fail}$ 并且记忆化，构建 AC 自动机 $\mathrm{fail}$ 指针的复杂度都是 $N|\Sigma|$。

怎么办呢，考虑通常写法中，对于一个 $u$，它的 $son_{u,c}$ 由两部分构成，一部分是 Trie 树上的儿子，另一部分是从 $fail_u$ 继承过来的儿子。

容易想到这个可以用一个类似于**可持久化线段树**和**线段树合并**生的孩子的东西来维护。

具体来说，最初在 Trie 中插入字符串的时候，用一棵动态开点线段树代替数组来维护每个结点的儿子。然后在初始化 AC 自动机的时候，将 $u$ 对应的线段树和 $fail_u$ 进行一个类似于线段树合并的操作。

具体来说，从初始化 AC 自动机的通常写法开始考虑。

```cpp
//这是我平时用的板子
void Build(){
	queue<int> q;
	forup(i,0,25){
		if(son[0][i]) q.push(son[0][i]);
	}
	while(q.size()){
		int u=q.front();q.pop();
		forup(i,0,25){
			if(son[u][i]){
				fail[son[u][i]]=son[fail[u]][i];//1
				q.push(son[u][i]);
			}else{
				son[u][i]=son[fail[u]][i];//2
			}
		}
	}
}
```

递归时，若线段树上 $u$ 的一个结点没有左儿子，那么这整个儿子都要进行上面代码中的操作 $2$，可以直接继承 $fail_u$ 对应结点的左儿子。

![](https://cdn.luogu.com.cn/upload/image_hosting/jmq3ows4.png)

比如像这样，假如 Trie 上 $u$ 只有这三个儿子，那么剩余儿子都能直接连向 $fail_u$ 的对应子树。

对于 $u$ 上已有的叶子结点，要进行上面代码中的操作 $1$，这个在叶子结点操作即可。

然后剩余操作都和 AC 自动机一样了，那么分析一下上面操作的复杂度。

容易发现，每插入一个字符串 $t$，会新建 $O(|t|\log |\Sigma|)$ 个结点，那么结点总数就是 $O(N\log |\Sigma|)$ 的。而线段树合并时，每个结点只会访问一次，故时间空间复杂度均是 $O(N\log|\Sigma|)$。

然后建出 $\mathrm{fail}$ 树后，每次插入一个文本串的复杂度是 $O(n\log |\Sigma|)$，其中 $n$ 是文本串的长度。带 $\log$ 是因为每次找下一个状态需要在线段树上查询叶子。显然这个 $\log$ 和每个结点维护单点加/单点求值是加算关系，所以数据结构维护树上信息的时间复杂度仍然是 $O(N\log N)$，不会变成双 $\log$，实测总共只跑了 350ms 左右（但是跑不过 $O(N\sqrt{N})$ 小常数做法 o(╥﹏╥)o）。

## 完整代码

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
#define forup(i,s,e) for(int i=(s);i<=(e);i++)
#define fordown(i,s,e) for(int i=(s);i>=(e);i--)
#ifdef DEBUG
#define msg(args...) fprintf(stderr,args)
#else
#define msg(...) void()
#endif
using namespace std;
#define gc getchar()
inline int read(){
    int x=0,f=1;char c;
    while(!isdigit(c=gc)) if(c=='-') f=-1;
    while(isdigit(c)){x=(x<<3)+(x<<1)+(c^48);c=gc;}
    return x*f;
}
#undef gc
const int N=1e5+5,M=1e4;
int n,m;
vector<int> name[2][50005];//很蠢的写法，分别存姓和名
vector<int> pth[50005];//每个文本串对应路径，总点数是 O(N) 的
int str[N];
int Ed[N];//每个模式串的结束状态
vector<int> e[N];
int st[N],ed[N],Tm;//子树内 dfn 序开头和结尾
int ST[20][N];
void dfs(int x,int fa){
	st[x]=++Tm;
	ST[0][Tm]=st[fa];
	for(auto i:e[x]){
		dfs(i,x);
	}
	ed[x]=Tm;
}
void initlca(){
	forup(i,0,18){
		forup(j,1,Tm-(1<<(i+1))+1){
			ST[i+1][j]=min(ST[i][j],ST[i][j+(1<<i)]);
		}
	}
}
int lca(int u,int v){//O(nlogn)-O(1) lca，主要是懒得写倍增
	if(u==v) return st[u];
	u=st[u],v=st[v];
	if(u>v) swap(u,v);
	++u;
	int len=31^__builtin_clz(v-u+1);
	return min(ST[len][u],ST[len][v-(1<<len)+1]);
}
struct BIT{//树状数组
	int c[N];
	void upd(int x,int k){for(;x<=Tm;x+=x&-x)c[x]+=k;}
	int sum(int x){int res=0;for(;x>0;x-=x&-x)res+=c[x];return res;}
	int query(int x){return sum(ed[x])-sum(st[x]-1);}
}mt;
struct AC_Automaton_with_SegTree{
	#define mid ((l+r)>>1)
	#define lson l,mid,ls[id]
	#define rson mid+1,r,rs[id]
	int ls[N*20],rs[N*20],num[N*20],cntt;//num 只在叶子结点有用，是这个指针所指向的 Trie 上的结点
	void Update(int P,int X,int l,int r,int &id){//插入一个儿子
		if(!id) id=++cntt;
		if(l==r){
			num[id]=X;
			return;
		}
		if(P<=mid) Update(P,X,lson);
		else       Update(P,X,rson);
	}
	int Ask(int P,int l,int r,int id){//询问指针 P 指向的 Trie 上的结点
		if(!id) return 0;
		if(l==r){
			return num[id];
		}
		if(P<=mid) return Ask(P,lson);
		else       return Ask(P,rson);
	}
	int root[N],fail[N],cntn;//root 是 Trie 上结点对应线段树的根
	int Insert(int len){//插入字符串
		int p=0;
		forup(i,1,len){
			int c=str[i];
			if(!Ask(c,0,M,root[p])) Update(c,++cntn,0,M,root[p]);
			p=Ask(c,0,M,root[p]);
		}
		return p;
	}
	queue<int> q;
	void Merge(int l,int r,int u,int &v){//将 v 合并到 u 上
		if(!v){v=u;return;}//如果没有这个儿子，就执行上文操作 2
		if(l==r){//到了叶子，执行操作 1
			fail[num[v]]=num[u];
			q.push(num[v]);
			return;
		}
		Merge(l,mid,ls[u],ls[v]);
		Merge(mid+1,r,rs[u],rs[v]);
	}
	void Build(){
		Merge(0,M,0,root[0]);//注意对于不存在的指针默认指向 0，线段树合并时通常也有类似的预定义
		while(q.size()){
			int u=q.front();q.pop();
			e[fail[u]].push_back(u);//这个加边是为了树上操作做的
			Merge(0,M,root[fail[u]],root[u]);
		}
	}
	void work1(){//求出每个文本串占用的所有状态，并且顺带解决问题 1 的单点加
		forup(q,1,n){
			vector<int> &vec=pth[q];
			forup(p,0,1){
				int u=0;
				vec.push_back(u);
				mt.upd(st[u],1);
				for(auto i:name[p][q]){
					u=Ask(i,0,M,root[u]);
					vec.push_back(u);
					mt.upd(st[u],1);
				}
			}
			sort(vec.begin(),vec.end(),[&](int a,int b){
				return st[a]<st[b];
			});
			int sz=vec.size();
			forup(i,0,sz-2){
				mt.upd(lca(vec[i],vec[i+1]),-1);
			}
		}
	}
	int work2(int q){//问题 2 的单点求和
		int res=0;
		vector<int> &vec=pth[q];
		for(auto u:vec){
			res+=mt.sum(st[u]);
		}
		int sz=vec.size();
		forup(i,0,sz-2){
			res-=mt.sum(lca(vec[i],vec[i+1]));
		}
		return res;
	}
}mac;
signed main(){
	n=read();m=read();
	forup(i,1,n){
		int l=read();
		forup(j,1,l){
			int a=read();
			name[0][i].push_back(a);
		}
		l=read();
		forup(j,1,l){
			int a=read();
			name[1][i].push_back(a);
		}
	}
	forup(i,1,m){
		int l=read();
		forup(j,1,l){
			str[j]=read();
		}
		Ed[i]=mac.Insert(l);
	}
	mac.Build();
	dfs(0,0);
	initlca();
	mac.work1();
	forup(i,1,m){
		printf("%d\n",mt.query(Ed[i]));
	}
	mem(mt.c,0);
	forup(i,1,m){
		mt.upd(st[Ed[i]],1);mt.upd(ed[Ed[i]]+1,-1);
	}
	forup(i,1,n){
		printf("%d ",mac.work2(i));
	}
}
```

---

## 作者：攀岩高手 (赞：3)

## 题目链接 ##

[BZOJ2754](https://www.lydsy.com/JudgeOnline/problem.php?id=2754)

[Luogu2336](https://www.luogu.org/problemnew/show/P2336)

## 概述 ##

本题解法众多，比如：

- AC 自动机

- 广义后缀自动机

- 后缀数组 + 莫队

- ......

这里我介绍一种新的解法：后缀数组 + ST 表 + 二分 + 主席树 + 树状数组。

## 算法分析 ##

以下是预处理的过程：

- 把所有的姓/名/询问字符串拼接在一起，之间用一个大数作为分隔符隔开，得到新的字符串 $a$ ；

- 记录 $a$ 的第 $i$ 个字符属于猫 $b[i]$ 的名字，若这个字符是分隔符或询问字符串则 $b[i]=0$ ；再记录第 $i$ 个询问字符串的长度 $len[i]$ ，它的第一个字符在 $a$ 中的位置为 $fir[i]$ ；

- 对 $a$ 进行后缀排序，得到 $sa$ 数组和 $rank$ 数组，并求出 $a$ 的 $height$ 数组， $height[i]$ 表示排名第 $i$ 的后缀与排名第 $i-1$ 的后缀的最长公共前缀的长度（LCP）；

- 根据 $height$ 数组建立 *ST表* ，这样可以 $O(1)$ 求出任意两个后缀的 LCP （*LCP Theorem* ： $LCP(i, j)=\underset{ rank[i]<k \leq rank[j] }{ min } \; height[k]$）；

- 这样，所以与询问 $i$ 的最长公共前缀大于等于 $len[i]$ 的后缀就一定分布在 $rank[fir[i]]$ 的前后，我们需要在前后各二分一次，求出这个范围 $[lef[i], righ[i]]$ ，则在这个范围内的后缀都能满足询问 $i$ 。

下面进入求解过程：

- 对于第一问，把每一个 $b[sa[i]]$ 视为一种颜色，可以将其转化为求一个区间内不同颜色种数的问题，这个问题可以用 *主席树* 解决：插入第 $i$ 个数时，把第 $i$ 个版本的主席树的第 $i$ 个位置在第 $i-1$ 个版本的基础上 $+1$ ，在上一次出现的同种颜色的位置（这里记作 $pre[b[sa[i]]]$）上 $-1$ ，以保证只统计每种颜色的最后一次出现；最后处理询问 $i$ 时查询第 $righ[i]$ 个版本的主席树的 $[lef[i], righ[i]]$ 的权值和即可。

- 对于第二问，相当于求每一个颜色被多少个不同的区间覆盖，也就是求每个颜色在区间内第一次出现的次数之和，转换成数学公式就是求满足 $l \leq i \leq r, l > pre[b[sa[i]]]$ 的区间个数（这里解释一下， $l>pre[b[sa[i]]]$ 就表示这个颜色上一次出现的位置在此区间之外，也就是说这个颜色在此区间内是第一次出现），以上条件也可转化为 $pre[b[sa[i]]] < l \leq i,r \geqslant i $ ，可以用解二维偏序的方法求解，简单地对区间右端点进行排序，一边扫描线一边用树状数组记录区间左端点即可。

## 代码实现 ##

```
#include <cstdio>
#include <cstring>
#include <algorithm>
using std::min;
using std::sort;
const int MAXN=440000;
const int MAXB=20;
const int MAXS=1E4;
int n, m, l;
int a[MAXN], b[MAXN];
int len[MAXN], fir[MAXN];
int sa[MAXN], rank[MAXN*2], rank1[MAXN];
int count[MAXN], tmp[MAXN], height[MAXN];
int lef[MAXN], righ[MAXN];
int root[MAXN], pre[MAXN], ans[MAXN];
struct Interval
{
	int l, r;
	bool operator < (const Interval& rhs) const
	{
		return r<rhs.r;
	}
} d[MAXN];
struct RMQ
{
	int lg[MAXN], st[MAXN][MAXB];
	void build(int* a)
	{
		for (int i=1, k=0; i<=l; i++) lg[i]=1<<k+1==i?++k:k;
		for (int i=1; i<=l; i++) st[i][0]=a[i];
		for (int j=1; 1<<j<=l; j++)
			for (int i=1; i+(1<<j)-1<=l; i++)
				st[i][j]=min(st[i][j-1], st[i+(1<<j-1)][j-1]);
	}
	int lcp(int l, int r)
	{
		int k=lg[r-l];
		return min(st[l+1][k], st[r-(1<<k)+1][k]);
	}
} st;
struct PersistableSegmentTree
{
	struct Node
	{
		int val, lc, rc;
	} tr[MAXN<<5];
	int cnt;
	void pushup(int x)
	{
		tr[x].val=tr[tr[x].lc].val+tr[tr[x].rc].val;
	}
	void insert(int& x, int y)
	{
		tr[x=++cnt]=tr[y];
	}
	void update(int& x, int y, int l, int r, int p, int k)
	{
		insert(x, y);
		if (l==r) { tr[x].val+=k; return; }
		int mid=l+r>>1;
		if (p<=mid) update(tr[x].lc, tr[y].lc, l, mid, p, k);
		else update(tr[x].rc, tr[y].rc, mid+1, r, p, k);
		pushup(x);
	}
	int query(int x, int l, int r, int ql, int qr)
	{
		if (l>qr||r<ql) return 0;
		if (ql<=l&&r<=qr) return tr[x].val;
		int mid=l+r>>1;
		return query(tr[x].lc, l, mid, ql, qr)
		      +query(tr[x].rc, mid+1, r, ql, qr);
	}
} pst;
struct BinaryIndexedTree
{
	#define lb(x) (x&-(x))
	int s[MAXN];
	void add(int x, int k)
	{
		while (x<=l) s[x]+=k, x+=lb(x);
	}
	int sum(int x)
	{
		int res=0;
		while (x>0) res+=s[x], x-=lb(x);
		return res;
	}
	#undef lb
} bit;
int getstr(int id)
{
	static int cnt=0;
	int k; scanf("%d", &k);
	for (int i=1; i<=k; i++)
		scanf("%d", &a[++l]), b[l]=id;
	a[++l]=MAXS+(++cnt);
	return k;
}
int main()
{
//	freopen("bzoj2754.in", "r", stdin);
//	freopen("bzoj2754.out", "w", stdout);
	scanf("%d%d", &n, &m);
	for (int i=1; i<=n; i++) getstr(i), getstr(i);
	// 当前询问字符串末尾的分隔符位置为 l ，则此字符串的起始位置就是 l-len[i]
	for (int i=1; i<=m; i++) len[i]=getstr(0), fir[i]=l-len[i];
	// 以下是后缀排序
	memset(count, 0, sizeof count);
	memset(rank, 0, sizeof rank);
	for (int i=1; i<=l; i++) count[a[i]]=1;
	for (int i=1; i<MAXN; i++) count[i]+=count[i-1];
	for (int i=1; i<=l; i++) rank[i]=count[a[i]];
	for (int p=1, k=0; k!=l; p<<=1)
	{
		memset(count, 0, sizeof count);
		for (int i=1; i<=l; i++) count[rank[i+p]]++;
		for (int i=1; i<=l; i++) count[i]+=count[i-1];
		for (int i=l; i>=1; i--) tmp[count[rank[i+p]]--]=i;
		memset(count, 0, sizeof count);
		for (int i=1; i<=l; i++) count[rank[i]]++;
		for (int i=1; i<=l; i++) count[i]+=count[i-1];
		for (int i=l; i>=1; i--) sa[count[rank[tmp[i]]]--]=tmp[i];
		memcpy(rank1, rank, sizeof rank1);
		rank[sa[1]]=k=1;
		for (int i=2; i<=l; i++)
		{
			if (rank1[sa[i]]!=rank1[sa[i-1]]
			  ||rank1[sa[i]+p]!=rank1[sa[i-1]+p]) k++;
			rank[sa[i]]=k;
		}
	}
	// 求 height 数组
	for (int i=1, k=0; i<=l; i++)
	{
		if (rank[i]==1)
		{
			height[rank[i]]=k=1;
			continue;
		}
		if (--k<0) k=0;
		while (a[i+k]==a[sa[rank[i]-1]+k]) k++;
		height[rank[i]]=k;
	}
	// 建立 st 表
	st.build(height);
	for (int i=1; i<=m; i++)
	{
		lef[i]=righ[i]=rank[fir[i]];
		for (int j=MAXB-1; j>=0; j--)
			if (lef[i]-(1<<j)>=1&&st.lcp(lef[i]-(1<<j), rank[fir[i]])>=len[i])
				lef[i]-=1<<j;
		for (int j=MAXB-1; j>=0; j--)
			if (righ[i]+(1<<j)<=l&&st.lcp(rank[fir[i]], righ[i]+(1<<j))>=len[i])
				righ[i]+=1<<j;
		d[i].l=lef[i]; d[i].r=righ[i];
	}
	// 做了一份所有区间的备份数组 d ，并对 d 按右端点从小到大排序
	sort(d+1, d+m+1);
	// 先把树状数组中所有的左端点的权值都赋为 +1
	for (int i=1; i<=m; i++) bit.add(d[i].l, 1);
	memset(pre, 0, sizeof pre);
	for (int i=1, j=1; i<=l; i++)
		// 如果这个位置是分隔符或询问字符串，直接复制一个和上个版本一样的主席树
		if (b[sa[i]]==0) pst.insert(root[i], root[i-1]);
		else
		{
			if (!pre[b[sa[i]]]) pst.update(root[i], root[i-1], 1, l, i, 1);
			else
			{
				int temp;
				// 先在该颜色上一次出现的位置上 -1
				pst.update(temp, root[i-1], 1, l, pre[b[sa[i]]], -1);
				// 然后在当前位置上 +1
				pst.update(root[i], temp, 1, l, i, 1);
			}
			// 所有右端点小于 i 的区间都不符合要求了，从将其左端点在树状数组中 -1
			while (j<=m&&d[j].r<i) bit.add(d[j++].l, -1);
			// 左端点属于 [pre[b[sa[i]]]+1, i] 的计入答案
			ans[b[sa[i]]]+=bit.sum(i)-bit.sum(pre[b[sa[i]]]);
			// 更新 pre
			pre[b[sa[i]]]=i;
		}
	// 在主席树中查询
	for (int i=1; i<=m; i++)
		printf("%d\n", pst.query(root[righ[i]], 1, l, lef[i], righ[i]));
	for (int i=1; i<=n; i++) printf("%d ", ans[i]); putchar('\n');
	return 0;
}
```

---

## 作者：zhaoyifan (赞：3)

我也贡献一种做法

后缀数组+hash

对于每次询问，在height周围找符合条件的，并且统计入内，为了防止mn复杂度的产生，所以使用hash保证每次的询问都不同，最后一块统计一下即可。

最坏情况的复杂度应该是n(n-1)/2，在本题中为9*10^5

但在随机数据的情况下复杂度还是很不错的。
```c
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
using namespace std;
const int maxn=2e5+7;vector<int>b[maxn/2];int vis[maxn],ans2[maxn];
int n,m,a[maxn],pos[maxn],bel[maxn],hasht[8000009],head[8000009],
nxt[8000009],ansto[maxn],re[maxn],num,t[maxn],cnt=1,M,rank[maxn],
tp[maxn],sa[maxn],p,height[maxn],flc[maxn],sum[maxn];
void solve(int x,int y)
{
	ansto[y]=x;re[x]++;
}
int hashit(int x)
{
	int ans=0;
	for(int i=1;i<=b[x][0];++i)
	ans=(b[x][i]%19+ans*17+127)%8000009;
	int u=head[ans];
	while(u)
	{
		int k=hasht[u];
		if(b[k][0]==b[x][0])
		 for(int i=1;i<=b[k][0];++i)
		  if(b[k][i]!=b[x][i]) break;
		  else if(i==b[k][0]) {solve(k,x);return 1;}
		u=nxt[u];
	}
	nxt[++cnt]=head[ans];head[ans]=cnt;hasht[cnt]=x;
	return 0;
}
void Qsort()
{
	for(int i=0;i<=M;++i) t[i]=0;
	for(int i=1;i<=pos[num];++i) t[rank[i]]++;
	for(int i=1;i<=M;++i) t[i]+=t[i-1];
	for(int i=pos[num];i>=1;--i) sa[t[rank[tp[i]]]--]=tp[i];
}
void ji_pai()
{
	M=1e4+1;
	for(int i=1;i<=pos[num];++i)
	{
		rank[i]=a[i];tp[i]=i;
	}
	Qsort();
	for(int w=1;p<pos[num],w<=pos[num];w<<=1,M=p)
	{
		p=0;
		for(int i=1;i<=w;++i) tp[++p]=pos[num]-w+i;
		for(int i=1;i<=pos[num];++i)
		if(sa[i]>w) tp[++p]=sa[i]-w;
		Qsort();swap(rank,tp);
		rank[sa[1]]=p=1;
		for(int i=2;i<=pos[num];++i)
		rank[sa[i]]=(tp[sa[i]]==tp[sa[i-1]]&&tp[sa[i]+w]==tp[sa[i-1]+w])?
		p:++p;
	}
}
void get_lcp()
{
	int h=0;
	for(int i=1;i<=pos[num];++i)
	{
		if(rank[i]==1) h=0;
		else 
		{
			int k=sa[rank[i]-1];
			if(--h<0) h=0;
			while(a[k+h]==a[i+h]) h++;
		}
		height[rank[i]]=h;
	}
}
void add_ans(int x)
{
	int l=pos[flc[x]-1]+1,k=rank[l];
	for(int i=k;i>1;--i)
	if(height[i]<b[x][0]) break;
	else
	{
		int p1=sa[i-1],p2=bel[p1],p3=bel[p1+b[x][0]-1];
		if(p1>pos[2*n]||vis[(p2+1)/2]==x||p2!=p3) continue;
		vis[(p2+1)/2]=x;sum[x]++;ans2[(p2+1)/2]+=re[x]+1;
	}
	for(int i=k+1;i<=pos[num];++i)
	if(height[i]<b[x][0]) break;
	else
	{
		int p1=sa[i],p2=bel[p1],p3=bel[p1+b[x][0]-1];
		if(p1>pos[2*n]||vis[(p2+1)/2]==x||p2!=p3) continue;
		vis[(p2+1)/2]=x;sum[x]++;ans2[(p2+1)/2]+=re[x]+1;
	}
}
int main()
{
	scanf("%d%d",&n,&m);num=2*n;
	for(int i=1;i<=n*2;++i)
	{
		int x;scanf("%d",&x);pos[i]=pos[i-1]+x;
		for(int j=1;j<=x;++j) scanf("%d",&a[pos[i-1]+j]);
		for(int j=1;j<=x;++j) bel[pos[i-1]+j]=i;
	}
	for(int i=1;i<=m;++i)
	{
		int x,y;scanf("%d",&x);b[i].push_back(x);
		for(int j=1;j<=x;++j) 
		{	
			scanf("%d",&y);b[i].push_back(y);
		}
		hashit(i);
	}
	for(int i=1;i<=m;++i)
	if(!ansto[i]) 
	{
		pos[num+1]=pos[num]+b[i][0];num++;flc[i]=num;
		for(int j=1;j<=b[i][0];++j)
		a[pos[num-1]+j]=b[i][j];
	} 
	ji_pai();
	get_lcp();
	for(int i=1;i<=m;++i)
	if(!ansto[i]) add_ans(i);
	else sum[i]=sum[ansto[i]];
	for(int i=1;i<=m;++i) printf("%d\n",sum[i]);
	for(int i=1;i<=n;++i) printf("%d ",ans2[i]);
	return 0;
}
```

---

## 作者：Taduro (赞：2)

首先，把所有的姓名串中间插上不同的字符建出后缀数组，求出每个排名$i$对应的串$sa[i]$。

如果一个串是某些后缀的前缀，那么这些后缀的排名一定是连续的，也就是在sa数组上是个连续的区间。

那么我们可以对每个询问二分出这个区间。看看这个区间中有多少颜色，莫队解决。

求每个颜色出现次数？可以"在时间轴上差分"。（以下第i个询问表示莫队将询问排序前的顺序）

当莫队在处理第j个询问中发现一个新出现的颜色i时，$num[i]+=cnt-j+1$，cnt是总询问数。

当莫队在处理第j个询问中发现少了一个颜色i时，$num[i]-=cnt-j+1$。

这样做的意义：在询问的时间轴上，如果在一个点i发现一个新颜色，假设这个颜色不会再消失，那么它出现了cnt-i+1也就是i到终点的距离次。如果之后这个颜色在第j个询问时消失了，那么就减去多算的cnt-j+1次。

犯的一些智障错误：

```c++
for (int i=1; i<=n; i++) bl[i]=(i/blo)+1;	//就这有91分，本机还测不出来
```

```c++
for (int i=1; i<=maxn; i++) o[i]=0;		// o是基数排序的桶，o[0]安详的存在着
```

还有ch[n+1]默认是0，然而应该是-1。

以及很多没脸放出来的错误。。。

```c++
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define SIZE 210012
#define re register
using namespace std;
inline char gc(){
	static char buf[100000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int init(){
	re char c=gc();re int a=0,w=1;
	while((c<'0'||c>'9')&&c-'-')c=gc();
	if(c=='-')w=-w,c=gc();
	while(c>='0'&&c<='9')a=(a<<3)+(a<<1)+(c^48),c=gc();
	return a*w;
}
inline void pc(re char c,re int p=0){
	static char buf[100000],*p1=buf;
	if(p){fwrite(buf,1,p1-buf,stdout);return ;}
	*p1++=c;
	if(p1==buf+100000)fwrite(buf,1,100000,stdout),p1=buf;
}
void print(re int x){
	if(x>9)print(x/10);
	pc(x%10+'0');
}
inline char getc(){
	char c=gc();
	while(!isupper(c)) c=gc();
	return c;
}
struct node{
	int l,r,h;
}q[SIZE];
struct suffix{
	int a,b,h;
}a[SIZE],tmp[SIZE];
int bl[SIZE],sa[SIZE],o[SIZE],n,m,t,ch[SIZE],blo,num[50001];
int c[SIZE],maxn,sum,ans[100010],cnt,b[50001],rk[SIZE];
inline bool cmp(node c,node d){
	if (bl[c.l]!=bl[d.r]) return c.l<d.l;
	if (bl[c.l]&1) return c.r<d.r;
	return c.r>d.r;
}
inline void jsort(){
	for (int i=0; i<=maxn; i++) o[i]=0;
	for (int i=1; i<=n; i++) o[a[i].b]++;
	for (int i=1; i<=maxn; i++) o[i]+=o[i-1];
	for (int i=1; i<=n; i++) tmp[o[a[i].b]--]=a[i];
	for (int i=1; i<=n; i++) a[i]=tmp[i];
	for (int i=0; i<=maxn; i++) o[i]=0;
	for (int i=1; i<=n; i++) o[a[i].a]++;
	for (int i=1; i<=maxn; i++) o[i]+=o[i-1];
	for (int i=n; i>=1; i--) tmp[o[a[i].a]--]=a[i];
	for (int i=1; i<=n; i++) a[i]=tmp[i];
}
inline void add(int x,int y){if (!o[c[sa[x]]]) sum++,num[c[sa[x]]]+=cnt-y+1;o[c[sa[x]]]++;}
inline void del(int x,int y){o[c[sa[x]]]--;if (!o[c[sa[x]]]) sum--,num[c[sa[x]]]-=cnt-y+1;}
int main(){
	// freopen("0a.in","r",stdin);
	// freopen("0a.out","w",stdout);
	int x,y;
	t=init(),m=init();
	for (int i=1; i<=t; i++){
		x=init(); ch[++n]=1e4+i*2-1;
		for (int j=1; j<=x; j++) ch[++n]=init();
		x=init(); ch[++n]=1e4+i*2;
		for (int j=1; j<=x; j++) ch[++n]=init();
		b[i]=n;
	}//ch[++n]=1e4+t*2+1;
	ch[n+1]=-1;
	for (int i=1; i<=t; i++)
		for (int j=b[i-1]+1; j<=b[i]; j++)
			c[j]=i,a[j].a=ch[j],a[j].h=j;
	maxn=1e4+2*t;
	jsort(); a[0].a=-1;
	for (int i=1; i<=n; i++){
		rk[a[i].h]=rk[a[i-1].h];
		if (a[i].a!=a[i-1].a||a[i].b!=a[i-1].b) rk[a[i].h]++;
	}
	maxn=rk[a[n].h];
	for (int i=1; i<=n; i++) a[i].a=rk[i],a[i].h=i,rk[i]=a[i].b=0;
	for (int w=1; w<=n; w<<=1){
		for (int i=1; i+w<=n; i++) a[i].b=a[i+w].a;
		jsort();
		for (int i=1; i<=n; i++){
			rk[a[i].h]=rk[a[i-1].h];
			if (a[i].a!=a[i-1].a||a[i].b!=a[i-1].b) rk[a[i].h]++;
		}
		maxn=rk[a[n].h];
		for (int i=1; i<=n; i++) a[i].a=rk[i],a[i].h=i,rk[i]=a[i].b=0;
		if (maxn==n) break;
	}
	for (int i=1; i<=n; i++) sa[a[i].a]=i,rk[i]=a[i].a,a[i].a=0;
	// puts("sa:"); for (int i=1; i<=n; i++) printf("%d ",sa[i]); puts("");
	// puts("ch:"); for (int i=1; i<=n; i++) printf("%d ",ch[i]); puts("");
	// puts("rk:"); for (int i=1; i<=n; i++) printf("%d ",rk[i]); puts("");
	int l,r,mid,ls,rs;
	for (int i=1; i<=m; i++){
		y=init(); ls=1,rs=n;
		for (int j=1; j<=y; j++){
			x=init();
			l=ls,r=rs;
			while (l<=r){
				mid=(l+r)>>1;
				if (ch[sa[mid]+j-1]<x) l=mid+1;
				else r=mid-1;
			}
			ls=l; r=rs;
			while (l<=r){
				mid=(l+r)>>1;
				if (ch[sa[mid]+j-1]>x) r=mid-1;
				else l=mid+1;
			}
			rs=r;
		}
		if (ls<=rs) q[++cnt].l=ls,q[cnt].r=rs,q[cnt].h=i;
		// printf("%d %d\n",ls,rs);
	}
	blo=sqrt(n); memset(o,0,sizeof(o));
	for (int i=1; i<=n; i++) bl[i]=(i-1)/blo+1;
	sort(q+1,q+cnt+1,cmp); l=1,r=0;
	for (int i=1; i<=m; i++){
		while (l<q[i].l) del(l,i),l++;
		while (l>q[i].l) l--,add(l,i);
		while (r<q[i].r) r++,add(r,i);
		while (r>q[i].r) del(r,i),r--;
		ans[q[i].h]=sum;
	}
	for (int i=1; i<=m; i++) print(ans[i]),pc('\n');
	for (int i=1; i<=t; i++){
		print(num[i]),pc(' ');
		// if (i==t) puts(""); else printf(" ");
	}
	pc(' ',1);
	return 0;
}
```



---

## 作者：maomao9173 (赞：2)

#### [题目链接 $Click  Here$](https://www.luogu.org/problemnew/show/P2336)_

#### $200$行纯干货的代码，一发$WA$掉真的是让人窒息，幸好最后找到了锅在哪。（差点就要弃掉了$QAQ$）

#### 【调出来的时候真的是要高兴到哭出来了$TwT$】

#### 这个题有很多种写法，但是大多数都是强行水过去的，正解的话应该是$SA$或者$SAM$搞一些数据结构维护。我在这里选择的是线段树维护$RMQ$，第一问就变成了区间颜色个数，第二问把第一问的答案差分对应到每个颜色上。放$SA+$莫队的人好像很少，这里我给一发~~清新脱俗~~又臭又长的代码供大家参考。

#### 说句实话，如果我会$SAM$的话绝对不会用这种毒瘤写法。太$TM$难调了。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 600010;
const int INF = 0x7fffffff;

#define ls (p << 1)
#define rs (p << 1 | 1)

int n, m, l, len, s[N], id[N], height[N];
int sa[N], tp[N], rk[N], _rk[N], bin[N], qry[N], lenq[N];

void base_sort (int n, int m) {
	for (int i = 1; i <= m; ++i) bin[i] = 0;
	for (int i = 1; i <= n; ++i) bin[rk[tp[i]]]++;
	for (int i = 1; i <= m; ++i) bin[i] += bin[i - 1];
	for (int i = n; i >= 1; --i) sa[bin[rk[tp[i]]]--] = tp[i];
}

void suffix_sort (int n, int m) {
	for (int i = 1; i <= n; ++i) {
		rk[i] = s[i], tp[i] = i;
	}
	base_sort (n, m);
	for (int w = 1; w <= n; w <<= 1) {
		int cnt = 0;
		for (int i = n - w + 1; i <= n; ++i) {
			tp[++cnt] = i;
		}
		for (int i = 1; i <= n; ++i) {
			if (sa[i] > w) {
				tp[++cnt] = sa[i] - w;
			}
		}
		base_sort (n, m);
		memcpy (_rk, rk, sizeof (rk));
		rk[sa[1]] = cnt = 1;
		for (int i = 2; i <= n; ++i) {
			rk[sa[i]] = _rk[sa[i]] == _rk[sa[i - 1]] && _rk[sa[i] + w] == _rk[sa[i - 1] + w] ? cnt : ++cnt;
		}
		if (cnt == n) return;
		m = cnt;
	}
}

void get_height (int n) {
	int k = 0;
	for (int i = 1; i <= n; ++i) {
		if (k) --k;
		int j = sa[rk[i] - 1];
		while (s[i + k] == s[j + k]) ++k;
		height[rk[i]] = k;
	}
}

struct Segment_Tree {
	//维护height数组最小值的线段树
	int a[N << 2];

	void push_up (int p) {
		a[p] = min (a[ls], a[rs]);
	}
	
	void build (int l, int r, int p) {
		if (l == r) {
			a[p] = height[l];
			return;
		}
		int mid = (l + r) >> 1;
		build (l, mid, ls);
		build (mid + 1, r, rs);
		push_up (p);
	}

	int query (int l, int r, int nl, int nr, int p) {
		if (nl <= l && r <= nr) {
			return a[p];
		}
		int mid = (l + r) >> 1, res = INF;
		if (nl <= mid) res = min (res, query (l, mid, nl, nr, ls));
		if (mid + 1 <= nr)  res = min (res, query (mid + 1, r, nl, nr, rs));
		return res;
	}
}tr;

struct Query {
	int l, r, id, blo;
}q[N];

bool cmp (Query lhs, Query rhs) {
	return lhs.blo == rhs.blo ? lhs.r < rhs.r : lhs.blo < rhs.blo;
}

bool can_use (int l, int r, int lcp) {
	return tr.query (1, len, l, r, 1) >= lcp;
}

int have[N], ans1[N], ans2[N];

int main () {
	cin >> n >> m;
	int ban = 10001;
	s[len = 0] = -1;
	for (int i = 1; i <= n; ++i) {
		for (int k = 0; k <= 1; ++k) {
			cin >> l;
			for (int j = 1; j <= l; ++j) {
				cin >> s[++len];
				id[len] = i;
			}
			s[++len] = ++ban;
		}
	} 
	for (int i = 1; i <= m; ++i) {
		cin >> l;
		lenq[i] = l;
		qry[i] = len + 1;
		for (int j = 1; j <= l; ++j) {
			cin >> s[++len];
		}
		s[++len] = ++ban;
	}
	suffix_sort (len, ban);
	get_height (len);
	tr.build (1, len, 1);
	int maxn = sqrt (len);
	for (int i = 1; i <= m; ++i) {
		q[i].id = i;
		int l = 1, r = rk[qry[i]];
		while (l < r) {
			int mid = (l + r) >> 1;
			if (can_use (mid, r, lenq[i])) {
				r = mid;
			} else {
				l = mid + 1;
			}
		}
		if (height[r] < lenq[i]) r++;
		q[i].l = r - 1;
		//确认左边界
		l = rk[qry[i]], r = len;
		while (l < r) {
			int mid = (l + r + 1) >> 1;
			if (can_use (l, mid, lenq[i])) {
				l = mid;
			} else {
				r = mid - 1;
			}
		}
		if (height[l] < lenq[i]) l--;
		q[i].r = l;
		//确认右边界
		q[i].blo = (q[i].l - 1) / maxn + 1;
		//分块
	}
	sort (q + 1, q + 1 + m, cmp);
	int l = 1, r = 0, tot = 0;
	for (int i = 1; i <= m; ++i) {
		while (l < q[i].l) {
 			--have[id[sa[l]]];
			if (id[sa[l]] != 0 && have[id[sa[l]]] == 0) {
				--tot;
				ans2[id[sa[l]]] -= (m - i + 1);
			}
			++l;
		}
		while (l > q[i].l) {
			--l;
			if (id[sa[l]] != 0 && have[id[sa[l]]] == 0) {
				++tot;
				ans2[id[sa[l]]] += (m - i + 1);
			}
			++have[id[sa[l]]];
		}
		while (r > q[i].r) {
			--have[id[sa[r]]];
			if (id[sa[r]] != 0 && have[id[sa[r]]] == 0) {
				--tot;
				ans2[id[sa[r]]] -= (m - i + 1);
			}
			--r;
		}
		while (r < q[i].r) {
			++r;
			if (id[sa[r]] != 0 && have[id[sa[r]]] == 0) {
				++tot;
				ans2[id[sa[r]]] += (m - i + 1);
			}
			++have[id[sa[r]]];
		}
		ans1[q[i].id] = tot;
	}
	for (int i = 1; i <= m; ++i) printf ("%d\n", ans1[i]);
	for (int i = 1; i <= n; ++i) printf ("%d ", ans2[i]);
}

```



---

## 作者：elijahqi (赞：2)

有了之前的经历，二分的速度似乎还不如暴力搞搞速度快呢

这里相比上一个tjoi2013需要限制一下不要查到问询的字符串里去 并且假如是属于同一块那么tmp记录的答案只统计一次

(http://www.elijahqi.win/2017/08/27/bzoj-3172/) 蒟蒻在blog中写的x

```cpp
#include<cstdio>
#include<cstring>
#define N 2020010
inline int read(){
    int x=0;char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch<='9'&&ch>='0') {x=x*10+ch-'0';ch=getchar();}
    return x;
}
int n,m,a[N],n1,m1,bl[N],count[N],rank[N<<1],rank1[N],sa[N],height[N],k,tmp[N],visit[N],ans[N];
struct node{
    int st,len;
}data[55000];
int main(){
//    freopen("2336.in","r",stdin);
    n1=read();m1=read();n=1;m=10000;
    for (int i=1;i<=n1;++i){
        int tmp=read();
        for (int j=0;j<tmp;++j) a[n+j]=read(),bl[n+j]=i;n+=tmp;a[n++]=++m;
        tmp=read();
        for (int j=0;j<tmp;++j) a[n+j]=read(),bl[n+j]=i;n+=tmp;a[n++]=++m;
    }int last=n-1;
    for (int i=1;i<=m1;++i){
        int tmp=read();
        data[i].st=n;data[i].len=tmp;
        for (int j=0;j<tmp;++j) a[n+j]=read();n+=tmp;a[n++]=++m;
    }n-=1;
//    printf("%d\n",n);
    //for (int i=1;i<=n;++i) printf("%d\n",a[i]);
    for (int i=1;i<=n;++i) count[a[i]]=1;
    for (int i=1;i<=m;++i) count[i]+=count[i-1];
    for (int i=1;i<=n;++i) rank[i]=count[a[i]];
    k=0;count[0]=0;
    for (int p=1;k!=n;p<<=1,m=k){
        for (int i=1;i<=m;++i) count[i]=0;
        for (int i=1;i<=n;++i) count[rank[i+p]]++;
        for (int i=1;i<=m;++i) count[i]+=count[i-1];
        for (int i=n;i>=1;--i) tmp[count[rank[i+p]]--]=i;
        for (int i=1;i<=m;++i) count[i]=0;
        for (int i=1;i<=n;++i) count[rank[i]]++;
        for (int i=1;i<=m;++i) count[i]+=count[i-1];
        for (int i=n;i>=1;--i) sa[count[rank[tmp[i]]]--]=tmp[i];
        memcpy(rank1,rank,sizeof(rank)>>1);
        rank[sa[1]]=k=1;
        for (int i=2;i<=n;++i){
            if (rank1[sa[i]]!=rank1[sa[i-1]]||rank1[sa[i]+p]!=rank1[sa[i-1]+p]) ++k;
            rank[sa[i]]=k;
        }
    }
    k=0;
    for (int i=1;i<=n;++i){
        if (rank[i]==1) continue;
        k=k==0?0:k-1;
        while (a[i+k]==a[sa[rank[i]-1]+k]) ++k;
        height[rank[i]]=k;
    }
//    for (int i=1;i<=n;++i) printf("%d ",sa[i]);printf("\n");
//    for (int i=1;i<=n;++i) printf("%d ",height[i]);
    for (int i=1;i<=m1;++i){
        int l=rank[data[i].st],r=rank[data[i].st]+1;
        while (height[l]>=data[i].len) --l;
        while (height[r]>=data[i].len) ++r;--r;
        int tmp=0;
        for (int j=l;j<=r;++j){
            if (sa[j]>last) continue;//超过了答案寻找的范围
            if (visit[bl[sa[j]]]==i) continue; 
            tmp++;ans[bl[sa[j]]]++;visit[bl[sa[j]]]=i;
        }
        printf("%d\n",tmp);
    }
    for (int i=1;i<=n1;++i) printf("%d ",ans[i]);
    return 0;
}
```
二分查找 速度更慢x

```cpp
#include<cstdio>
#include<cstring>
#define N 2020010
inline int read(){
    int x=0;char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch<='9'&&ch>='0') {x=x*10+ch-'0';ch=getchar();}
    return x;
}
int n,m,a[N],n1,m1,bl[N],count[N],rank[N<<1],rank1[N],sa[N],height[N],k,tmp[N],visit[N],ans[N],l,r,fmin[N][20],Log[N];
struct node{
    int st,len;
}data[55000];
inline int min(int x,int y){return x<y?x:y;}
inline int lcp(int x,int y){
    x++;int t=Log[y-x+1];
    return min(fmin[x][t],fmin[y-(1<<t)+1][t]);
}
void check(int st,int len){
    int l1,r1;
    if (height[st]<len) l1=st;else{
        int ll=1,rr=st-1;
        while (ll<=rr){
            int mid=(ll+rr)>>1;
            if(lcp(mid,st)>=len) rr=mid-1;else ll=mid+1;
        }
        l1=ll;
    }
    if (height[st+1]<len) r1=st;else{
        int ll=st+1,rr=n;
        while (ll<=rr){
            int mid=(ll+rr)>>1;
            if (lcp(st,mid)>=len) ll=mid+1;else rr=mid-1;
        }
        r1=rr;
    }
    l=l1;r=r1;
}
int main(){
    freopen("2336.in","r",stdin);
    n1=read();m1=read();n=1;m=10000;
    for (int i=1;i<=n1;++i){
        int tmp=read();
        for (int j=0;j<tmp;++j) a[n+j]=read(),bl[n+j]=i;n+=tmp;a[n++]=++m;
        tmp=read();
        for (int j=0;j<tmp;++j) a[n+j]=read(),bl[n+j]=i;n+=tmp;a[n++]=++m;
    }int last=n-1;
    for (int i=1;i<=m1;++i){
        int tmp=read();
        data[i].st=n;data[i].len=tmp;
        for (int j=0;j<tmp;++j) a[n+j]=read();n+=tmp;a[n++]=++m;
    }n-=1;
//    printf("%d\n",n);
    //for (int i=1;i<=n;++i) printf("%d\n",a[i]);
    for (int i=1;i<=n;++i) count[a[i]]=1;
    for (int i=1;i<=m;++i) count[i]+=count[i-1];
    for (int i=1;i<=n;++i) rank[i]=count[a[i]];
    k=0;count[0]=0;
    for (int p=1;k!=n;p<<=1,m=k){
        for (int i=1;i<=m;++i) count[i]=0;
        for (int i=1;i<=n;++i) count[rank[i+p]]++;
        for (int i=1;i<=m;++i) count[i]+=count[i-1];
        for (int i=n;i>=1;--i) tmp[count[rank[i+p]]--]=i;
        for (int i=1;i<=m;++i) count[i]=0;
        for (int i=1;i<=n;++i) count[rank[i]]++;
        for (int i=1;i<=m;++i) count[i]+=count[i-1];
        for (int i=n;i>=1;--i) sa[count[rank[tmp[i]]]--]=tmp[i];
        memcpy(rank1,rank,sizeof(rank)>>1);
        rank[sa[1]]=k=1;
        for (int i=2;i<=n;++i){
            if (rank1[sa[i]]!=rank1[sa[i-1]]||rank1[sa[i]+p]!=rank1[sa[i-1]+p]) ++k;
            rank[sa[i]]=k;
        }
    }
    k=0;
    Log[0]=-1;
    for (int i=1;i<=n;++i) Log[i]=Log[i>>1]+1;
    for (int i=1;i<=n;++i){
        if (rank[i]==1) continue;
        k=k==0?0:k-1;
        while (a[i+k]==a[sa[rank[i]-1]+k]) ++k;
        height[rank[i]]=k;
    }
    for (int i=1;i<=n;++i) fmin[i][0]=height[i];
    for (int j=1;j<=Log[n];++j){
        for (int i=1;i<=n-(1<<j)+1;++i){
            fmin[i][j]=min(fmin[i][j-1],fmin[i+(1<<(j-1))][j-1]);
        }
    }
//    for (int i=1;i<=n;++i) printf("%d ",sa[i]);printf("\n");
//    for (int i=1;i<=n;++i) printf("%d ",height[i]);
    for (int i=1;i<=m1;++i){
        check(rank[data[i].st],data[i].len);
        int tmp=0;
        for (int j=l;j<=r;++j){
            if (sa[j]>last) continue;//超过了答案寻找的范围
            if (visit[bl[sa[j]]]==i) continue; 
            tmp++;ans[bl[sa[j]]]++;visit[bl[sa[j]]]=i;
        }
        printf("%d\n",tmp);
    }
    for (int i=1;i<=n1;++i) printf("%d ",ans[i]);
    return 0;
}
```

---

## 作者：KokiNiwa (赞：1)

这是一个广义后缀树可以解决的问题。

## 题目叙述

有$n$个人，每个人有一个姓和一个名。老师会点名，每次点名给出一个字符串，每个人的姓或者名的子串中有老师这个字符串那么必须起立。请问一次点名会点起几个人，最终每个人会起来几次。

## 题解

首先把所有的姓和名连起来，中间放好分隔符（分隔符必须不一样），然后发现这个树其实就是把所有串的后缀合起来建立了一个压缩的Trie树，就是一个广义后缀树。对于每一个点名串，匹配到这个树上，匹配的最终节点的子树是由哪些人的姓/名组成，人的数量就是答案。对于第二问，每个人在一个点的子树中被统计多少次答案就是多少。可以把询问的编号挂在每个点上，线段树合并从下向上，然后就搞定了。第二问可以线段树的每个点打一个标记，然后合并的时候下穿标记（线段树的每个叶子节点代表一个人，存两个信息，一是有没有出现过，二是出现了多少次，每个非叶子的节点存储当前区间内有多少个人）。

## 一些想法

开始想的时候是想可持久化线段树合并，统计每个节点下面有多少种人，但发现这样最后那个问题并不能把所有的点合并起来（就是从头每个点都合并一下，这样是不行的，因为总点数不是$O(n\log_2 n)$级别的了，所以复杂度不对）。于是就没再想过离线下来的想法了。

## 代码
~~后缀树总是能把一道题变成码农题~~
```cpp
#include <cstdio>
#include <map>
#include <vector>

using namespace std;

const int maxLen = 2e5 + 5, maxNode = 2e5 + 5, inf = 1e8, maxChar = 1e4,
          maxRen = 2e5 + 5, maxQue = 2e5 + 5; //maxRen莫名设成 1e4
struct SuffixTree {
	int curLen, now, actLen, tail;
	int start[maxNode], len[maxNode], link[maxNode], curStr[maxLen], tag[maxNode];
	map<int, int> ch[maxNode];
	SuffixTree() {
		now = tail = 1;
		actLen = curLen = 0;
		len[0] = inf;
	}
	inline int NewNode(int st, int le, int col) {
		link[++tail] = 1;
		start[tail] = st;
		len[tail] = le;
		if (col)
			tag[tail] = col;
		return tail;
	}
	void Extend(int ins, int belong) {
		curStr[++curLen] = ins;
		++actLen;
		for (int last = 1; actLen; ) {
			while (actLen > len[ch[now][curStr[curLen - actLen + 1]]])
				actLen -= len[now = ch[now][curStr[curLen - actLen + 1]]];
			int &son = ch[now][curStr[curLen - actLen + 1]],
			     val = curStr[start[son] + actLen - 1];
			if (!son || val == ins) {
				link[last] = now;
				last = now;
				if (!son)
					son = NewNode(curLen - actLen + 1, inf, belong);
				else
					break ;
			} else {
				int split = NewNode(start[son], actLen - 1, 0);
				ch[split][val] = son;
				ch[split][ins] = NewNode(curLen, inf, belong);
				start[son] += actLen - 1;
				len[son] -= actLen - 1;
				link[last] = son = split;
				last = split;
			}
			if (now == 1)
				--actLen;
			else
				now = link[now];
		}
	}
	void Check() {
		for (int pos = 1; pos <= curLen; ++pos)
			printf("%d ", curStr[pos]);
		printf("\n");
		for (int NId = 1; NId <= tail; ++NId) {
			printf("id : %d len : %d start : %d\n", NId, len[NId], start[NId]);
			for (map<int, int>::iterator it = ch[NId].begin(); it != ch[NId].end();
			        ++it) {
				printf("	son : %d\n", it->second);
			}
		}
	}
} sft;
struct SegmentTree {
	int tail, ch[maxNode << 6][2], kind[maxNode << 6], tag[maxNode << 6];
	SegmentTree() {
		ch[0][0] = ch[0][1] = kind[0] = tag[0] = 0;
	}
	void PushUp(int now) {
		kind[now] = kind[ch[now][0]] + kind[ch[now][1]];
	}
	void PushDown(int now) {
		if (ch[now][0])
			tag[ch[now][0]] += tag[now];
		if (ch[now][1])
			tag[ch[now][1]] += tag[now];
		tag[now] = 0;
	}
	void Insert(int &now, int lEP, int rEP, int pos) {
		if (!now)
			now = ++tail;
		if (lEP == rEP)
			return kind[now] = 1, void();
		int mid = (lEP + rEP) >> 1;
		if (pos <= mid)
			Insert(ch[now][0], lEP, mid, pos);
		else
			Insert(ch[now][1], mid + 1, rEP, pos);
		PushUp(now);
	}
	int Query(int now, int lEP, int rEP, int askL, int askR) {
		if ((!now) || lEP > askR || rEP < askL)
			return 0;
		if (lEP <= askL && askR <= rEP)
			return kind[now];
		int mid = (lEP + rEP) >> 1;
		return Query(ch[now][0], lEP, mid, askL, askR) +
		       Query(ch[now][1], mid + 1, rEP, askL, askR);
	}
	void Merge(int &uNd, int vNd, int lEP, int rEP) {
		if (!uNd || !vNd) {
			uNd |= vNd;
			return ;
		}
		if (lEP == rEP) {
			tag[uNd] += tag[vNd];
			//这里需要更新 tag
			return ;
		}
		int mid = (lEP + rEP) >> 1;
		PushDown(uNd), PushDown(vNd);
		Merge(ch[uNd][0], ch[vNd][0], lEP, mid);
		Merge(ch[uNd][1], ch[vNd][1], mid + 1, rEP);
		PushUp(uNd);
	}
} seg;
int renN, callM, fa[maxNode], rt[maxNode], depth[maxLen],
    aCall[maxLen], ans1[maxQue], ans2[maxRen];
vector<int> qry[maxNode];
void dfs1(int now, int from, int dep) {
	dep += min(sft.len[now], sft.curLen - sft.start[now] + 1);
	depth[now] = dep;
	fa[now] = from;
	for (map<int, int>::iterator it = sft.ch[now].begin(); it != sft.ch[now].end(); ++it)
		dfs1(it -> second, now, dep);
}
void run(int *call, int len, int qId) {
	int now = 1, pt = 0;
	while (pt < len && ((pt + 1 <= depth[now]
	                     && call[pt + 1] == sft.curStr[sft.start[now] + pt - depth[fa[now]]])
	                    || (pt + 1 > depth[now] && sft.ch[now][call[pt + 1]]))) {
		if (pt + 1 > depth[now])
			now = sft.ch[now][call[pt + 1]];
		++pt;
	}
	if (pt == len)
		qry[now].push_back(qId);
}
void dfs2(int now, int dep) {
	dep += min(sft.len[now], sft.curLen - sft.start[now] + 1);
	if (sft.tag[now])
		seg.Insert(rt[now], 1, renN, sft.tag[now]);
	bool isLeaf = 1;
	for (map<int, int>::iterator it = sft.ch[now].begin(); it != sft.ch[now].end(); ++it) {
		dfs2(it->second, dep);
		seg.Merge(rt[now], rt[it->second], 1, renN);
		isLeaf = 0;
	}
	for (vector<int>::iterator it = qry[now].begin(); it != qry[now].end(); ++it)
		ans1[*it] = seg.kind[rt[now]],
		            ++seg.tag[rt[now]]; //这里都是 rt[now]，因为实在线段树上的根节点加
}
void dfsSeg(int now, int lEP, int rEP) {
	if (lEP == rEP) {
		ans2[lEP] = seg.tag[now];
		return ;
	}
	seg.PushDown(now);
	int mid = (lEP + rEP) >> 1;
	dfsSeg(seg.ch[now][0], lEP, mid);
	dfsSeg(seg.ch[now][1], mid + 1, rEP);
}

int main() {
	freopen("name.in", "r", stdin);
	freopen("name.out", "w", stdout);
	scanf("%d%d", &renN, &callM);
	for (int rId = 1; rId <= renN; ++rId) {
		int len;
		scanf("%d", &len);
		for (int pos = 1; pos <= len; ++pos) {
			int ch;
			scanf("%d", &ch);
			sft.Extend(ch, rId);
		}
		sft.Extend(maxChar + 2 * rId, rId);

		scanf("%d", &len);
		for (int pos = 1; pos <= len; ++pos) {
			int ch;
			scanf("%d", &ch);
			sft.Extend(ch, rId);
		}
		sft.Extend(maxChar + 2 * rId + 1, rId);
		//这里的分隔符不能和上面的一样
	}
	dfs1(1, 0, 0);
	for (int clId = 1; clId <= callM; ++clId) {
		int len;
		scanf("%d", &len);
		for (int pos = 1; pos <= len; ++pos)
			scanf("%d", &aCall[pos]);
		run(aCall, len, clId);
	}
	dfs2(1, 0);
	for (int qId = 1; qId <= callM; ++qId)
		printf("%d\n", ans1[qId]);
	dfsSeg(rt[1], 1, renN);
	for (int rId = 1; rId <= renN; ++rId)
		printf("%d ", ans2[rId]);
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

但有一些要注意的地方：

+ 首先这道题的每个数的值域是人，而不是字符串的长度（以前写值域为字符串长度的写多了。。。）
+ 广义后缀树的时候要在插入的时候直接给每一个节点打上标记，不要最终找到一个后缀后再按起始位置判断这个后缀属于的字符串。因为这样会导致莫名错误，放个[提交记录](https://loj.ac/submission/734744)。如果知道这个问题的原因私信我。update : 好像是用 map 存储儿子的时候需要注意，儿子是不是0，不判的话容易出现玄学问题。
+ 写匹配的时候记录一个变量now，每次看再匹配以为会不会超出这条边，分两种情况讨论。

## 知识点

+ 广义后缀树，处理多个串往多个串上匹配的问题。
+ 离线的想法，把询问挂在点上。

---


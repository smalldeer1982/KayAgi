# 【模板】后缀排序

## 题目背景

这是一道模板题。


## 题目描述

读入一个长度为 $ n $ 的由大小写英文字母或数字组成的字符串，请把这个字符串的所有非空后缀按字典序（用 ASCII 数值比较）从小到大排序，然后按顺序输出后缀的第一个字符在原串中的位置。位置编号为 $ 1 $ 到 $ n $。


## 说明/提示

$1\le n \le 10^6$。


## 样例 #1

### 输入

```
ababa```

### 输出

```
5 3 1 4 2```

# 题解

## 作者：xMinh (赞：405)

# 后缀数组 最详细(maybe)讲解
# 更详细请前往[蒟蒻的博客](https://xminh.github.io/)

后缀数组这个东西真的是神仙操作……

但是这个比较神仙的东西在网上的讲解一般都仅限于思想而不是代码，而且这个东西开一堆数组，很多初学者写代码的时候很容易发生歧义理解，所以这里给出一个比较详细的讲解。笔者自己也是和后缀数组硬刚了一个上午外加一个中午才理解的板子。

本人版权意识薄弱，如有侵权现象请联系博主邮箱xmzl200201@126.com

参考文献：

[百度百科_后缀数组](https://baike.baidu.com/item/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/8989867?fr=aladdin)

[%%%曲神学长的blog%%%](http://www.yhzq-blog.cc/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/)

以下是不认识的dalao们：

[wsy的cnblog](https://www.cnblogs.com/wsy01/p/6935135.html)

[soda的cnblog](https://www.cnblogs.com/thmyl/p/6296648.html)

[I'MJACKY的cnblog](https://www.cnblogs.com/shanchuan04/p/5324009.html)

[董雨的cnblog](https://www.cnblogs.com/jackdong/archive/2012/10/15/2724034.html)

特别感谢以下的两位dalao，写的特别好，打call

[J.K.的cnblog](https://www.cnblogs.com/jinkun113/p/4743694.html)

[J_Sure的csdn](http://blog.csdn.net/j_sure/article/details/41777097)

## 什么是后缀数组

我们先看几条定义：

### 子串

在字符串s中，取任意i<=j，那么在s中截取从i到j的这一段就叫做s的一个子串

### 后缀

后缀就是从字符串的某个位置i到字符串末尾的子串，我们定义**以s的第i个字符为第一个元素的后缀为suff(i)**

### 后缀数组

把s的每个后缀按照字典序排序，

后缀数组sa[i]就表示**排名为i的后缀**的起始位置的下标

而它的映射数组rk[i]就表示**起始位置的下标为i的后缀**的排名

简单来说，sa表示排名为i的是啥，rk表示第i个的排名是啥

一定要记牢这些数组的意思，后面看代码的时候如果记不牢的话就绝对看不懂

## 后缀数组的思想

先说最暴力的情况，快排(n log n)每个后缀，但是这是字符串，所以比较任意两个后缀的复杂度其实是O(n)，这样一来就是接近O(n^2 log n)的复杂度，数据大了肯定是不行的，所以我们这里有两个优化。

ps：本文中的^表示平方而不是异或

### 倍增

首先读入字符串之后我们现根据单个字符排序，当然也可以理解为先按照每个后缀的第一个字符排序。对于每个字符，我们按照字典序给一个排名(当然可以并列)，这里称作关键字。

![havana1](https://github.com/xMinh/xMinh.github.io/blob/master/pic/havana1.png?raw=true)

接下来我们再把相邻的两个关键字合并到一起，就相当于根据每一个后缀的前两个字符进行排序。想想看，这样就是以第一个字符(也就是自己本身)的排名为第一关键字，以第二个字符的排名为第二关键字，把组成的新数排完序之后再次标号。没有第二关键字的补零。

![havana2](https://github.com/xMinh/xMinh.github.io/blob/master/pic/havana2.png?raw=true)



既然是倍增，就要有点倍增的样子。接下来我们对于一个在第i位上的关键字，它的第二关键字就是第(i+2)位置上的，联想一下，因为现在第i位上的关键字是suff(i)的前两个字符的排名，第i+2位置上的关键字是suff(i+2)的前两个字符的排名，这两个一合并，不就是suff(i)的前四个字符的排名吗？方法同上，排序之后重新标号，没有第二关键字的补零。同理我们可以证明，下一次我们要合并的是第i位和第i+4位，以此类推即可……

ps：本文中的“第i位”表示下标而不是排名。排名的话我会说“排名为i”

![havana3](https://github.com/xMinh/xMinh.github.io/blob/master/pic/havana3.png?raw=true)

那么我们什么时候结束呢？很简单，当所有的排名都不同的时候我们直接退出就可以了，因为已经排好了。

显然这样排序的速度稳定在(log n)

###  基数排序

如果我们用快排的话，复杂度就是(n log^2 n) 还是太大。

这里我们用一波基数排序优化一下。在这里我们可以注意到，每一次排序都是排两位数，所以基数排序可以将它优化到O(n)级别，总复杂度就是(n log n)。

介绍一下什么是基数排序，这里就拿两位数举例

我们要建两个桶，一个装个位，一个装十位，我们先把数加到个位桶里面，再加到十位桶里面，这样就能保证对于每个十位桶，桶内的顺序肯定是按个位升序的，很好理解。

## 最长公共前缀——后缀数组的辅助工具

话说这个费了我好长时间，就为了证明几条定理……懒得证明的话背过就行了，不过笔者还是觉得知道证明用起来更踏实一些，话说我的证明过程应该比较好懂，适合初学者理解……

### 什么是LCP？

我们定义LCP(i,j)为suff(sa[i])与suff(sa[i])的最长公共前缀

### 为什么要求LCP？

后缀数组这个东西，不可能只让你排个序就完事了……大多数情况下我们都需要用到这个辅助工具LCP来做题的

### 关于LCP的几条性质 

#### 显而易见的

1. LCP(i,j)=LCP(j,i);
2. LCP(i,i)=len(sa[i])=n-sa[i]+1;

这两条性质有什么用呢？对于i>j的情况，我们可以把它转化成i<j，对于i==j的情况，我们可以直接算长度，所以我们直接讨论i<j的情况就可以了。

我们每次依次比较字符肯定是不行的，单次复杂度为O(n)，太高了，所以我们要做一定的预处理才行。

#### LCP Lemma

**LCP(i,k)=min(LCP(i,j),LCP(j,k)) 对于任意1<=i<=j<=k<=n**

证明：设p=min{LCP(i,j),LCP(j,k)}，则有LCP(i,j)≥p,LCP(j,k)≥p。

设suff(sa[i])=u,suff(sa[j])=v,suff(sa[k])=w;

所以u和v的前p个字符相等，v和w的前p个字符相等

所以u和w的前p的字符相等，LCP(i,k)>=p

设LCP(i,k)=q>p 那么q>=p+1

因为p=min{LCP(i,j),LCP(j,k)}，所以u[p+1]!=v[p+1] 或者 v[p+1]!=w[p+1]

但是u[p+1]=w[p+1] 这不就自相矛盾了吗

所以LCP(i,k)<=p

综上所述LCP(i,k)=p=min{LCP(i,j),LCP(j,k)}

#### LCP Theorem

**LCP(i,k)=min(LCP(j,j-1)) 对于任意1<i<=j<=k<=n**

这个结合LCP Lemma就很好理解了

我们可以把i~k拆成两部分i~(i+1)以及(i+1)~k

那么LCP(i,k)=min(LCP(i,i+1),LCP(i+1,k))

我们可以把(i+1)~k再拆，这样就像一个DP，正确性显然

### 怎么求LCP？

我们设height[i]为LCP(i,i-1)，1<i<=n，显然height[1]=0;

由LCP Theorem可得，LCP(i,k)=min(height[j]) i+1<=j<=k

那么height怎么求，枚举吗？NONONO，我们要利用这些后缀之间的联系

设h[i]=height[rk[i]]，同样的，height[i]=h[sa[i]];

那么现在来证明最关键的一条定理：

**h[i]>=h[i-1]-1;**

证明过程来自[曲神学长的blog](http://www.yhzq-blog.cc/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/)，我做了一点改动方便初学者理解：

首先我们不妨设第i-1个字符串按排名来的前面的那个字符串是第k个字符串，注意k不一定是i-2，因为第k个字符串是按字典序排名来的i-1前面那个，并不是指在原字符串中位置在i-1前面的那个第i-2个字符串。

这时，依据height[]的定义，第k个字符串和第i-1个字符串的公共前缀自然是height[rk[i-1]]，现在先讨论一下第k+1个字符串和第i个字符串的关系。

第一种情况，第k个字符串和第i-1个字符串的首字符不同，那么第k+1个字符串的排名既可能在i的前面，也可能在i的后面，但没有关系，因为height[rk[i-1]]就是0了呀，那么无论height[rk[i]]是多少都会有height[rk[i]]>=height[rk[i-1]]-1，也就是h[i]>=h[i-1]-1。

第二种情况，第k个字符串和第i-1个字符串的首字符相同，那么由于第k+1个字符串就是第k个字符串去掉首字符得到的，第i个字符串也是第i-1个字符串去掉首字符得到的，那么显然第k+1个字符串要排在第i个字符串前面。同时，第k个字符串和第i-1个字符串的最长公共前缀是height[rk[i-1]]，

那么自然第k+1个字符串和第i个字符串的最长公共前缀就是height[rk[i-1]]-1。

到此为止，第二种情况的证明还没有完，我们可以试想一下，对于比第i个字符串的排名更靠前的那些字符串，谁和第i个字符串的相似度最高（这里说的相似度是指最长公共前缀的长度）？显然是排名紧邻第i个字符串的那个字符串了呀，即sa[rank[i]-1]。但是我们前面求得，有一个排在i前面的字符串k+1，LCP(rk[i],rk[k+1])=height[rk[i-1]]-1;

又因为height[rk[i]]=LCP(i,i-1)>=LCP(i,k+1)

所以height[rk[i]]>=height[rk[i-1]]-1，也即h[i]>=h[i-1]-1。

## 代码(详细注释)

例题：[luogu3809 后缀排序](https://www.luogu.org/problemnew/show/P3809)

注意上面那个题不用求lcp……看代码建议先大略扫一遍，因为的确有点绕

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define rint register int
#define inv inline void
#define ini inline int
#define maxn 1000050
using namespace std;
char s[maxn];
int y[maxn],x[maxn],c[maxn],sa[maxn],rk[maxn],height[maxn],wt[30];
int n,m;
inv putout(int x)
{
    if(!x) {putchar(48);return;}
    rint l=0;
    while(x) wt[++l]=x%10,x/=10;
    while(l) putchar(wt[l--]+48);
}
inv get_SA()
{
	for (rint i=1;i<=n;++i) ++c[x[i]=s[i]];
	//c数组是桶 
	//x[i]是第i个元素的第一关键字 
    for (rint i=2;i<=m;++i) c[i]+=c[i-1]; 
    //做c的前缀和，我们就可以得出每个关键字最多是在第几名 
    for (rint i=n;i>=1;--i) sa[c[x[i]]--]=i; 
    for (rint k=1;k<=n;k<<=1)
    {
        rint num=0;
        for (rint i=n-k+1;i<=n;++i) y[++num]=i;
        //y[i]表示第二关键字排名为i的数，第一关键字的位置 
		//第n-k+1到第n位是没有第二关键字的 所以排名在最前面 
        for (rint i=1;i<=n;++i) if (sa[i]>k) y[++num]=sa[i]-k;
        //排名为i的数 在数组中是否在第k位以后
		//如果满足(sa[i]>k) 那么它可以作为别人的第二关键字，就把它的第一关键字的位置添加进y就行了
		//所以i枚举的是第二关键字的排名，第二关键字靠前的先入队 
        for (rint i=1;i<=m;++i) c[i]=0;
        //初始化c桶 
        for (rint i=1;i<=n;++i) ++c[x[i]];
        //因为上一次循环已经算出了这次的第一关键字 所以直接加就行了 
        for (rint i=2;i<=m;++i) c[i]+=c[i-1];//第一关键字排名为1~i的数有多少个 
        for (rint i=n;i>=1;--i) sa[c[x[y[i]]]--]=y[i],y[i]=0;
        //因为y的顺序是按照第二关键字的顺序来排的 
        //第二关键字靠后的，在同一个第一关键字桶中排名越靠后 
        //基数排序 
        swap(x,y);
		//这里不用想太多，因为要生成新的x时要用到旧的，就把旧的复制下来，没别的意思 
        x[sa[1]]=1;num=1;
        for (rint i=2;i<=n;++i)
            x[sa[i]]=(y[sa[i]]==y[sa[i-1]] && y[sa[i]+k]==y[sa[i-1]+k]) ? num : ++num;
        //因为sa[i]已经排好序了，所以可以按排名枚举，生成下一次的第一关键字 
        if (num==n) break;
        m=num;
        //这里就不用那个122了，因为都有新的编号了 
    }
    for (rint i=1;i<=n;++i) putout(sa[i]),putchar(' ');
}
inv get_height()
{
    rint k=0;
    for (rint i=1;i<=n;++i) rk[sa[i]]=i;
    for (rint i=1;i<=n;++i)  
    {
        if (rk[i]==1) continue;//第一名height为0 
        if (k) --k;//h[i]>=h[i-1]+1;
        rint j=sa[rk[i]-1];
        while (j+k<=n && i+k<=n && s[i+k]==s[j+k]) ++k;
        height[rk[i]]=k;//h[i]=height[rk[i]];
    }
    putchar(10);for (rint i=1;i<=n;++i) putout(height[i]),putchar(' ');
}
int main()
{
    gets(s+1);
    n=strlen(s+1);m=122;
	//因为这个题不读入n和m所以要自己设
	//n表示原字符串长度，m表示字符个数，ascll('z')=122 
	//我们第一次读入字符直接不用转化，按原来的ascll码来就可以了 
	//因为转化数字和大小写字母还得分类讨论，怪麻烦的 
    get_SA();
    //get_height();
}
```





---

## 作者：Rainy7 (赞：370)

- **前言**
  
  >upd 2021/08/28：感谢@[Fее_cle6418](https://www.luogu.com.cn/user/390770)指出的一个错误。
  
  **求赞QWQ**
  
  **主要参考文章：[这个](https://xminh.github.io/2018/02/27/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84-%E6%9C%80%E8%AF%A6%E7%BB%86(maybe)%E8%AE%B2%E8%A7%A3.html)和[这个](https://www.cnblogs.com/zwfymqz/p/8413523.html)**
  
  **若仍然有侵权，请私信我，我会马上标明上去qaq。（毕竟这东西太毒瘤我一直在翻资料）**
  
  所以..到底是啥神仙脑洞这么大想到这种~~神奇~~毒瘤的东西？
  
  

------------

  
- **求什么**

  就比如洛谷的 [P3809 【模板】后缀排序 (SA)](https://www.luogu.com.cn/problem/P3809)
  
  读入一个长度为 $n$ 的由大小写英文字母或数字组成的字符串，请把这个字符串的**所有非空后缀**按**字典序从小到大排序**，然后按顺序输出**后缀的第一个字符在原串中的位置**。位置编号为 $1$ 到 $n$ 。
  
  其中 $n \le 10^6$ 。
  
  直接排序的复杂度为 $O(n^2 \log n)$
  
  所以SA肯定比这快嘛..为 $O(n \log n)$
  
  然后补充一下，这题不用求**LCP（最长公共前缀）**，但是好像这东西很有用..（
  

------------

- **后缀排序思想**

  用了基数排序的思想呐。
  
  >基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用
  >----百度百科
  
  ~~其实上面那个定义不重要~~，后缀排序就是利用了基数排序的思想。
  
  
  按照字典序排列，若一一比较，肯定**先从第一位**开始比。所以我们可以按照**每个后缀的第一个字符**排个序，这个操作相当于把**这个字符串的每个字符排个序**。
  
  除非正好每个字符不一样，否则肯定有部分的字符是**排名是一样**的，按照排序，接下来要比较**这些排名一样的字符的第二位！**
  
  ~~然后复杂度就上去了。~~
  
  其实，第二位我们已经比较过了！
  
  因为要**排序的是后缀**，所以**第 $i$ 个后缀的第二个字符就是第 $i+1$ 个字符**，也就是已经排序好了，而第一位是**第一关键字**，第二位是**第二关键字**。
  
  那么就可以得到第二位的排序。
  
  以此类推，可以利用**倍增**的思想，再利用已知去得出第四位的排序。
  
  不难得出，**当所有后缀的排名都两两不同时**，就完成了本题。
  
  直接理解确实十分硬核，所以下面结合图再做说明。
  
  每个**后缀的编号**如题目，为**第一个字母所在的位置**。
  
  $s$ 表示这个字符串。
  
  $sa_i$ 表示**排名为 $i$ 的后缀编号是什么**。
  
  ![无标题.png](https://i.loli.net/2021/08/28/Fg3r7uxqKLpXcSI.png)
  
  ~~那么接下来更毒瘤的来了~~


------------

- **后缀排序代码理解**

  打算一块一块讲，算上输出我总共写了**12个for**。
  
  首先，我们要先**根据第一位排序**，确定最初的 $sa$ 。
  
  我们用 $x_i$ **表示第一关键字**。
  
  ```cpp
   for(int i=1;i<=n;i++){x[i]=s[i];++c[x[i]];}
	for(int i=2;i<=m;i++)c[i]+=c[i-1];
	for(int i=n;i>=1;i--)sa[c[x[i]]--]=i;
  ```
  
  先直接把 $s_i$ 给上 $x_i$ ，而 $c$ 数组是桶，这里用到的就是**桶排序**的思想，来**统计每种字符有多少种**。
  
  为了方便标号，就先做一个**前缀和**。这样**字典序越大，所对应的的 $c$ 越大**。
  
  接下来就是排序确定最初 $sa$ 了。再次强调： $sa_i$ 表示**排名为i的后缀编号是什么**。
  
  至于为什么 $c_{x_i}$ 要减一，是为了当出现 $c_{x_i}>1$ ，即**有重复**时，**保证排序不一样**。
  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/emnntk11.png)
  
  下一块，就是要一步一步确定第二位，第四位..
  
  也就是**利用倍增**的思想：
  
  ```cpp
  for(int k=1;k<=n;k=k<<1)
  ```
  ~~然后就在这循环里瞎搞就好了。~~
  
  首先，定义 $y_i$ 表示**排名为第 $i$ 的第二关键字 ,也就是确定 $x$ 的排列的东西**。
  
  然后根据上次排序的 $sa$ 来确定 $y$ 。
  
  ```cpp
  int num=0;
  for (int i=n-k+1;i<=n;++i) y[++num]=i;
  for(int i=1;i<=n;i++)
		if(sa[i]>k)y[++num]=sa[i]-k;
  ```
  
  $num$ 只是一个指针而已。
  
  首先**后 $k$ 位，也就是第 $n-k+1$ 位到第 $n$ 位**，他们其实已经排序完了，因为**他们后面的第 $k$ 位不存在**。那么先直接存在 $y$ 中。
  
  若第 $i$ 位**可作其他位置的第二关键字**，即 $sa_i>k$ 时，要把他**放在对应的第一关键字( $x_{sa_i-k}$ )中**。
  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/emnntk11.png)
  
  确定完第一关键字和第二关键字，就可以**更新 $sa$ 了**。而且更新方法和开头很像。
  
  ```cpp
	for(int i=1;i<=m;i++)c[i]=0;
	for(int i=1;i<=n;i++)c[x[i]]++;
	for(int i=2;i<=m;i++)c[i]+=c[i-1];
	for(int i=n;i>=1;i--){sa[c[x[y[i]]]--]=y[i];y[i]=0;}
  ```
  
  首先清空，然后用桶统计，然后前缀和。
  
  唯一改的就是把`sa[c[x[i]]--]=i;`改成`sa[c[x[y[i]]]--]=y[i];`
  
  原因也很简单，就是因为开头 $x$ 排序就是 $1$ 到 $n$ ，而**这边排序变成了 $y_1$ 到 $y_n$ 。**
  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/emnntk11.png)
  
  接下来就是要**更新 $x$ 了**，然后很明显，要用到**未更新的 $x$ 和 $sa$ 。**
  
  然后又懒得开新变量存，所以先用暂时没用的 $y$ 来存此时的 $x$ 。
  
  ```cpp
  swap(x,y);
  ```
  
  然后更新。
  
  ```cpp
	num=1;x[sa[1]]=1;
	for(int i=2;i<=n;i++)
	{	
		if(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k])x[sa[i]]=num;
		else x[sa[i]]=++num;
	}
	if(num==n)break;
	m=num;//m是指不同字母的数量
  ```
  
  **此时 $i$ 代表的是排名**，所以编号都要用 $sa_i$ 代替。
  
  然后当两个字符一样的时候，$x$ **是一样的**，也就是**第一个if判断**。
  
  否则的话排名更新，因为是**按照排名枚举的**，所以**直接 $num+1$ 。**
  
  **当 $x_i$ 各不相同时，即 $num=n$ 时**，这个排序也就做完了。
  
  然后这部分就做完了..
  

------------

  
- **后缀排序完整代码(即[P3809 【模板】后缀排序 (SA)](https://www.luogu.com.cn/problem/P3809)完整代码)**

  ```cpp
  #include<iostream>
  #include<cstdio>
  #include<cstring>
  #include<cmath>
  using namespace std;
  const int Maxn=1e6+5;
  char s[Maxn];
  int n,m,x[Maxn],y[Maxn],c[Maxn],sa[Maxn];
  int height[Maxn],rk[Maxn];
  void SA()
  {	
      for(int i=1;i<=n;i++){x[i]=s[i];++c[x[i]];}
      for(int i=2;i<=m;i++)c[i]+=c[i-1];
      for(int i=n;i>=1;i--)sa[c[x[i]]--]=i;
      for(int k=1;k<=n;k=k<<1)
      {	
          int num=0;
          for (int i=n-k+1;i<=n;++i) y[++num]=i;
          for(int i=1;i<=n;i++)
              if(sa[i]>k)y[++num]=sa[i]-k;
          for(int i=1;i<=m;i++)c[i]=0;
          for(int i=1;i<=n;i++)c[x[i]]++;
          for(int i=2;i<=m;i++)c[i]+=c[i-1];
          for(int i=n;i>=1;i--){sa[c[x[y[i]]]--]=y[i];y[i]=0;}
          swap(x,y);
          num=1;x[sa[1]]=1;
          for(int i=2;i<=n;i++)
          {	
              if(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k])x[sa[i]]=num;
              else x[sa[i]]=++num;
          }
          if(num==n)break;
          m=num;
      }
      for(int i=1;i<=n;i++)
          printf("%d ",sa[i]);
      printf("\n");
  }
  int main()
  {	
      scanf("%s",s+1);
      n=strlen(s+1);
      m=122;
      SA();
      //LCP(); 
      return 0;
  }
  ```
 

------------

- **LCP**

  这个~~据说~~好用的东西就顺带讲了吧。
  
  LCP：最长公共前缀。然后就是求，要用到后缀排序。
  
  定义 $LCP(i,j)$ **表示第 $sa_i$ 个和第 $sa_j$ 个的两个后缀的最长公共前缀。**
  
  然后就是一堆定理：
  
  1. $LCP(i,j)=LCP(j,i)$
  2. $LCP(i,i)=len(sa_i)=n-sa_i+1$
  3. **LCP Lemma** $LCP(i,j)=\min(LCP(i,k),LCP(k,j))(1 \le i \le k \le j \le n)$
  4. **LCP Theorem** $LCP(i,j)=\min(LCP(k,k-1))(1<i \le k \le j \le n)$
  
  那么如何证明呢？
  
  首先定理 $1$ 和定理 $2$ 是显然的。
  
  然后**LCP Lemma**和**LCP Theorem**开始~~抄别人文章。~~
  
  1. **LCP Lemma**
  
     设 $p=\min(LCP(i,k),LCP(k,j))$ ,**则 $LCP(i,k) \ge p$ ， $LCP(k,j) \ge p$。**
     
     设第 $sa_i$ 后缀为 $u$ ，第 $sa_j$ 后缀为 $v$ ，第 $sa_k$ 后缀为 $w$ 。
     
     所以 $u$ 和 $w$ 的前 $p$ 个字符相等，$v$ 和 $w$ 的前 $p$ 个字符相等。
     
     **所以 $u$ 和 $v$ 的前 $p$ 个字符相等。**
     
     设 $LCP(i,j)=q$，且 $q > p$ 。
     
     **则 $q \ge p+1$ ,且 $u_{p+1} = v_{p+1}$**
     
     因为 $p=\min(LCP(i,k),LCP(k,j))$ ,所以 $u_{p+1} \ne w_{p+1} $ 或者 $v_{p+1} \ne w_{p+1}$
     
     **所以 $u_{p+1} \ne v_{p+1}$ 与前面矛盾。**
     
     所以 $LCP(i,j) \le p$
     
     综上所述， $LCP(i,j)=p=\min(LCP(i,k),LCP(k,j))(1 \le i \le k \le j \le n)$
   
  2. **LCP Theorem**
     
     把 $i$ ~$j$ 拆成 $i$~$i+1$ 和 $i+1$~$j$
     
     那么根据LCP Lemma，则 $LCP(i,j)=\min(LCP(i,i+1),LCP(i+1,j))$
     
     然后我们依然可以把 $i+1$ 到 $j$ 继续拆，明显正确。
   
   好的那么接下来的问题就是怎么求了。
   
   我们**设 $rk_i$ 表示编号为 $i$ 的后缀的排名。**
   
   **请注意和前面的 $sa_i$ 区分,他们是这个关系：$sa_{rk_i}=i$。**
   
   设 $height(i)=LCP(i,i-1)(1<i\le n)$ ，$height(1)=0$ 。
   
   因为 $LCP(i,j)=\min(LCP(k,k-1))(1<i \le k \le j \le n)$ 
   
   所以 $LCP(i,j)=\min(height(k))(i < k \le j)$
   
  设 $h_i=height(rk_i)$
  
  因为 $sa_{rk_i}=i$
  
  所以 $height(i)=h_{sa_i}$
  
  **然后这里其实是有一个定理的 $h_i \ge h_{i-1}-1$ 。**
  
  ~~但是我并不会证明。~~
  
  然后就可以用这条定理来求 $height$ ，然后再求LCP。
  
  ```cpp
  void LCP()
  {	
      int k=0; //用k代表h[i]
      for(int i=1;i<=n;i++)rk[sa[i]]=i; //初始化rk[i]
      for(int i=1;i<=n;i++)//这里其实是枚举rk[i]
      {	
          if(rk[i]==1)continue; //height[1]=0
          if(k)k--; //h[i]>=h[i-1]-1,更新k然后一位位枚举
          int j=sa[rk[i]-1];//前一位字符串
          while(i+k<=n&&j+k<=n&&s[i+k]==s[j+k])k++;//一位位枚举
          height[rk[i]]=k;//h[i]=height[rk[i]]
      }
      for(int i=1;i<=n;i++)
          printf("%d ",height[i]);
      printf("\n");
  }
  ```
  
  然后就可以求 LCP 了。
  
  根据 $LCP(i,j)=\min(height(k))(i < k \le j)$ 
  
  ```cpp
	int ans=inf;//求LCP(x,y)
	for(int i=x+1;i<=y;i++)
		ans=min(ans,height(i));
   printf("%d\n",ans);
  ```


------------

$$\text{既然都看到这里了为何不点个赞呢(小声}$$

$$\text{写死我了awsl}$$

$$\text{by Rainy7}$$

---

## 作者：Flying2018 (赞：48)

# Hash是万能的
假如我们用暴力比较两个字符串的大小，显然我们需要逐位比较，直到比较到一个不同的字符。

按照这个思路，我们只需要求出两个字符串的LCP，然后比较其下一位即可。（~~假设我们并不知道后缀数组是蛤~~）

我们知道Hash可以在O(1)时间判断两个子串是否相等，所以我们直接暴力二分答案，然后用Hash判断即可。

由于比后缀数组多一个log，需要吸氧才能过。

**~~不过，为什么stable_sort能卡过而sort会T？~~**

毕竟是暴力，效率略低，请大佬手下留情。
```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#include<cstring>
#define base 233
#define ull unsigned long long
using namespace std;
ull bases[1000010],hashs[1000010];
char str[1000010];
int n;
inline ull get(int l,int r){return hashs[r]-hashs[l-1]*bases[r-l+1];}
bool cmp(int l1,int l2)
{
    int l=-1,r=min(n-l1,n-l2);
    while(l<r)
    {
        int mid=(l+r+1)>>1;
        if(get(l1,l1+mid)==get(l2,l2+mid)) l=mid;
        else r=mid-1;
    }
    if(l>min(n-l1,n-l2)) return l1>l2;
    else return str[l1+l+1]<str[l2+l+1];
}
int a[1000010];
int main()
{
    scanf("%s",str+1);
    n=strlen(str+1);
    bases[0]=1;
    for(int i=1;i<=n;i++)
    {
        bases[i]=bases[i-1]*base;
        hashs[i]=hashs[i-1]*base+str[i];
        a[i]=i;
    }
    stable_sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++) printf("%d ",a[i]);
    return 0;
}
```

---

## 作者：鏡音リン (赞：32)

2021/02/22 更新：修改了排版使其符合题解规范。

CSP 之前写篇题解加加 RP

## DC3 算法构造后缀数组

题目：[P3809 【模板】后缀排序](https://www.luogu.org/problem/P3809)

看这篇题解之前建议学习一下倍增法求后缀数组，不然可能有点难以理解。

切入正题，DC3 是一种 $O(n)$ 时空复杂度构造后缀数组的算法，然而因为它常数大（相较于 SA-IS），而且比倍增法难打，所以几乎没人打。

算法主要流程如下：

1. 把所有的后缀分成两部分，记后缀起始的下标为 $i$，第一部分为 $i\bmod 3=0$ 的后缀（以下称为 **A 类后缀**），第二部分为 $i\bmod 3\neq0$ 的后缀（以下称为 **B 类后缀**）。

2. 利用基数排序，对所有 **B 类后缀**按照**前三个字符**排序。

3. 如果前三个字符无法将所有 B 类后缀排好序，把每三个相邻的字符看作一个字符，构造新的字符串，**递归**对 B 类后缀排序。

4. 利用 B 类后缀的顺序可以利用基数排序很快的求出 **A 类后缀**的顺序。

5. 对 A 类后缀和 B 类后缀进行**归并排序**，然后 SA 数组就求出来了。

下面用一组样例演示一下 DC3 算法的执行过程。

这里我们要排序的字符串是 ```aaababaaca```，下面这张图标注出了所有 B 类后缀的前三个字符。

![](https://cdn.luogu.com.cn/upload/image_hosting/jyd79u0l.png)

对这些前三个字符进行排序，方法是三次基数排序，从后往前每次排一个字符，用上一次排序的结果做第二关键字。图中的数字表示排序后的排名。

![](https://cdn.luogu.com.cn/upload/image_hosting/2d86bn5s.png)

发现前三个字符不能确定 B 类后缀的顺序（有两个 ```aba```，排名都是 $2$），于是构造新字符串，递归执行 DC3 算法，如图，构造出的新串是 ```1230245```，下一行表示新串每个后缀的排名。

![](https://cdn.luogu.com.cn/upload/image_hosting/eieyp7lj.png)

从图中可以看出，新串的构造方式为：所有 $i\bmod 3=1$ 的后缀按顺序排列在左侧，$i\bmod 3=2$ 的后缀按顺序排列在右侧，中间用一个 0 字符（就是一个空的 A 类后缀）分隔。这样构造可以保证**新串中相邻两个字符在原串中表示相邻六个字符**。同时中间用 0 字符分隔，可以保证两类后缀的排序相互独立，不会互相干扰。（代码中可以看到，其实只有 $n\bmod 3=1$ 的时候需要加这个 0 字符，因为如果不是这样，代表最后一个 A 类后缀的三个字符末尾本来就是 0 字符）。于是，我们可以从新串后缀的排序中得到所有 B 类后缀的顺序。

无论是仅排序三个字符还是递归排序，我们现在已经得到所有 B 类后缀的排名了（下图中第三行）。注意到对于所有 A 类后缀，都相当于一个字符加上一个 B 类后缀，而 B 类后缀的顺序已经求出。所以用第一个字符做第一关键字，其后的 B 类后缀排名做第二关键字，一次基数排序即可求出 A 类后缀的排名（图中第四行）。图中第五、六行写出了按顺序排列的 A 类后缀和 B 类后缀起始下标。

![](https://cdn.luogu.com.cn/upload/image_hosting/24cvne6l.png)

现在两类后缀都已经有序，只需要一次归并就能将两类后缀的顺序合并。归并就需要比较两类后缀的大小。记需要比较大小的 A 类后缀起始下标为 $i$，A 类后缀起始下标为 $j$：

如果位置 $i,j$ 上的字符不同，直接比较这两个字符即可。否则需要比较后缀 $i+1$ 和 $j+1$，有两种情况：

1. $j\bmod 3=1$，此时后缀 $i+1$ 和 $j+1$ 都是 B 类后缀，而我们已经求过 B 类后缀的顺序了。

2. $j\bmod 3=2$，此时后缀 $i+1$ 是 B 类后缀且 $i+1\bmod 3=1$，后缀 $j+1$ 是 A 类后缀，问题转化为第一种情况。

然后就可以求出最终答案了。

![](https://cdn.luogu.com.cn/upload/image_hosting/u3e5ulv2.png)

由于本题下标是从 $1$ 开始计算，所以程序输出 ```10 1 2 7 5 3 8 6 4 9```。

代码实现细节非常多，全都写在注释里了。

[无注释版代码](https://www.luogu.org/paste/iknn199c)

```cpp
#include <cstdio>
#define N 1000001
int rk[3*N+100], sa[3*N], bu[N], x[N], y[N];
void sort(int *rk, int *a, int *b, int n, int m) {
	//rk是要排序的串，a是要排序的字符的下标，其顺序是第二关键字
	for (int i = 0; i <= m; i++) bu[i] = 0;
	for (int i = 0; i < n; i++) bu[rk[a[i]]]++;
	for (int i = 1; i <= m; i++) bu[i] += bu[i-1];
	for (int i = n-1; i >= 0; i--) b[--bu[rk[a[i]]]] = a[i];
}
bool cmp3(int *r, int x, int y) {
	return r[x] == r[y] && r[x+1] == r[y+1] && r[x+2] == r[y+2];
}
bool cmpt(int* r, int x, int y) { //比较两类后缀的大小
	if (r[x] != r[y]) return r[x] < r[y];
	if (x%3 == 1) return bu[x+1] < bu[y+1];
	else return !cmpt(r, y+1, x+1);
}
void DC3(int *rk, int *sa, int n, int m) {
	bool h = (n%3 == 1); if (h) rk[n++] = 0;
	//如果n%3==1，在原串末尾增加一个空的A类后缀，以防递归排序越界
	int *rn = rk+n+2, *san = sa+n, ln = 0, p;
	//ln: B类后缀的数量
	for (int i = 0; i < n; i++)
		if (i % 3) x[ln++] = i;
	rk[n] = rk[n+1] = 0; //在原串后增加两个空字符，方便处理
	sort(rk+2, x, y, ln, m);
	sort(rk+1, y, x, ln, m);
	sort(rk, x, y, ln, m);
	int ta = 0, td = (n+1)/3;
	//ta: A类后缀的数量
	//td: i%3==1的后缀的数量
	#define F(x) (x/3)+(x%3==1?0:td)
	//利用三个字符构造新串
	//F(x): 原串的后缀x在新串中的位置
	rn[F(y[0])] = p = 1;
	for (int i = 1; i < ln; i++) {
		if (!cmp3(rk, y[i], y[i-1])) p++;
		rn[F(y[i])] = p;
	}
	if (p < ln) DC3(rn, san, ln, p); //递归对B类后缀进行排序
	else for (int i = 0; i < ln; i++)
		if (rn[i]) san[rn[i]-1] = i;
	for (int i = 0; i < ln; i++)
		if (san[i] < td) y[ta++] = san[i]*3;
	//对于所有i%3==1的后缀，其排名是之前一个A类后缀排序用的第二关键字
	sort(rk, y, x, ta, m);
	#define G(x) (x>=td?(x-td)*3+2:x*3+1)
	//G(x): 新串的后缀x在原串中的位置
	for (int i = 0; i < ln; i++)
		bu[y[i] = G(san[i])] = i; //这里的bu[x]就是B类后缀x的排名
	bu[n] = -1;
	int i = 0, j = h; p = 0; //如果h等于1，则第一个A类后缀是为了防止越界加入的，归并时去除
	while (i < ta && j < ln) {
		if (cmpt(rk, y[j], x[i])) sa[p++] = y[j++];
		else sa[p++] = x[i++];
	}
	while (i < ta) sa[p++] = x[i++];
	while (j < ln) sa[p++] = y[j++];
}
char s[N]; int n;
int main() {
	scanf("%s", s);
	for (n = 0; s[n]; n++)
		rk[n] = s[n]-'0'+1;
	//初始的rank是字符的ascii码
	//注意0是保留的，普通字符从1开始
	DC3(rk, sa, n, 75);
	for (int i = 0; i < n; i++)
		printf("%d ", sa[i]+1);
	puts("");
}
```

### 其他的问题

因为存在递归，时空复杂度 $f(n)=\Theta(n)+f(\frac{2}{3}n)=\Theta(n)$。（不知道怎么推的可以看一下[这个](https://www.luogu.org/blog/nederland/guan-yu-di-gui-di-shi-jian-fu-za-du-fen-xi)）

又因为 $n+(\frac{2}{3})n+(\frac{2}{3})^2n+(\frac{2}{3})^3n+...=3n$，所以数组开三倍大小。

---

## 作者：VCode (赞：28)

安利我的博客https://vcode28629.coding.me/SA-IS/

常见的后缀数组求法为$\Theta(nlogn)$的倍增求法，也有DC3或后缀自动机$\Theta(n)$构造的。我们今天要讲的也是一种$\Theta(n)$构造后缀数组的算法，**SA-IS(SuffixArray-InducedSort)**。

在讲解SA-IS之前，我们需要知道一些概念、定义、以及性质。

# 后缀数组

对于后缀数组和字符串的定义与概念在此不做过于复杂的讲解，只简要说明以下几点：

1. 任意可比较大小的元素构成的序列叫做字符串，记为$str$。
2. $str$从下标$i$开始到结束的子串叫$str$的后缀，记为$suffix(i)$。一个长度为$len$的字符串有$len$个后缀。
3. 后缀数组$sa[i]$表示将$str$的所有后缀排序后，第$i$小的后缀在原串中的下标。
4. 名次数组$rank[]$与高度数组$height[]$不是本次讲解重点。

为了方便起见，我们对字符串结尾增加一个空字符（即将末尾的$'\backslash0'$看作字符串的一部分，下文用$\#$表示空字符），所以令$len = strlen(str) + 1;$

# 后缀类型

## $L-type$与$S-type$

我们将后缀分为两个类型，$L$型和$S$型。$L$型表示此后缀$suffix(i)$比$suffix(i+1)$大，$S$型表示此后缀$suffix(i)$比$suffix(i+1)$小。特殊的，末尾的空后缀`'\0'`为$S$型。

举个例子：

对于字符串`AGATGAGATACGCGGT`，后缀类型是这样的：

| 下标 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 字符 | A | G | A | T | G | A | G | A | T | A | C | G | C | G | G | T | # |
| 后缀类型 | S | L | S | L | L | S | L | S | L | S | S | L | S | S | S | L | S |

对于一个字符串，我们可以用如下方法$\Theta(n)$时间内求出它的所有后缀的后缀类型：

```cpp
type[len - 1] = S;
for(int i = len - 2; i >= 0; --i) {
  if(str[i] > str[i + 1]) type[i] = L;
  if(str[i] < str[i + 1]) type[i] = S;
  if(str[i] == str[i + 1]) type[i] = type[i + 1];
}
```

对于$str[i]$与$str[i+1]$不一致的地方，正确性显然。对于$str[i]==str[i+1]$的时候，证明如下：

- 设$suffix(i)$为$aaX$，则$suffix(i+1)$为$aX$。
- $a=a$，所以比较$aX$与$X$，$aX$与$X$大小关系即为$type[i+1]$。

**引理1：对于两个后缀$A$与$B$，若$A[0]=B[0]$且$A$是$L$型，$B$是$S$型，则$A<B$**

证明：设$A=abX$，$B=acY$。

若$a\not=b$且$a\not=c$，则$b<a<c$，所以$A<B$。

若$a=b$且$a\not=c$，则比较$aX$与$cY$，$a<c$，所以$A<B$。

若$a\not=b$且$a=c$，则比较$bX$与$aY$，$b<a$，所以$A<B$。

若$a=b$且$a=c$，则比较$aX$与$aY$，转化为前三种情况。

## $LMS-type$

$LMS$类型（LeftMostS-type，下简称$*$型）是一种特殊的$S$型，它的要求是它的左边必须是$L$型（所以$\#$一定会是$LMS$类型）。

| 下标 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 字符 | A | G | A | T | G | A | G | A | T | A | C | G | C | G | G | T | # |
| 后缀类型 | S | L | S | L | L | S | L | S | L | S | S | L | S | S | S | L | S |
| LMS |   |   | * |   |   | * |   | * |   | * |   |   | * |   |   |   | * |

我们可以$\Theta(n)$时间内求出所有$*$型：

```cpp
bool isLMS(int loc) {
  if(loc <= 0) return false;
  if(type[loc] != S) return false;
  if(type[loc - 1] != L) return false;
  return true;
}

int LMSSize = 0;
for(int i = 0; i < len; ++i) {
  if(!isLMS(type, i)) continue;
  LMS[LMSSize++] = i;
}
```

一个类型为$*$的字符叫$LMS$字符，两个相邻$LMS$字符所夹的子串（包含这两个字符）叫$LMS$子串，一个$LMS$字符开始的后缀叫$LMS$后缀。特殊的，$\#$也是$LMS$子串。

对于$LMS$子串的比较有特殊约定，不应该只比较字符大小，也需要比较类型。只有当每一个字符与其后缀类型都相同时，这两个$LMS$子串才被称为是相同的。

# 诱导排序(induced sort)

SA-IS的主要思想是利用排序好的$LMS$后缀进行诱导排序，得出后缀数组。关$LMS$后缀的排序我们一会再讲，现在假设我们已经对其排好序了，存在数组$LMS$里：

| 下标 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 字符 | A | G | A | T | G | A | G | A | T | A | C | G | C | G | G | T | # |
| |   |   | * |   |   | * |   | * |   | * |   |   | * |   |   |   | * |
| LMS | 16 | 9 | 5 | 7 | 2 | 12 |

诱导排序利用了桶排序的思想，记录每种字符出现的次数，然后放到对应的位置。

显然，后缀数组中首字母相同的后缀在同一段区域。

根据引理1，同种首字母开头的后缀，类型相同的在同一段区域，且$L$型在$S$型前面，如下表所示：

| 下标 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 桶 | # | A | A | A | A | A | C | C | G | G | G | G | G | G | T | T | T |
| type | S | S | S | S | S | S | S | S | L | L | L | L | S | S | L | L | L |

诱导排序大致分为以下几步：

1. 用桶排序的思想记录每种字符出现的次数，并为每种字符在sa中分配相应的空间（如上表），初始化为$-1$。
2. 逆序扫描$LMS$，把$LMS$后缀逆序依次放入$sa$中对应的$S$型桶末尾。
3. 正序扫描$sa$，若$type[sa[i]-1]=L$，则将$sa[i]-1$放入对应的$L$型桶中。
4. 逆序扫描$sa$，若$type[sa[i]-1]=S$，则将$sa[i]-1$放入对应的$S$型桶中。

代码：

```cpp
/*
str 字符串
len 字符串长度
sigma 字符集大小
type 类型数组
LMS LMS数组
LMSSize LMS数组大小
全局数组sa 后缀数组
*/
template<typename T>
void inducedSort(T str, int len, int sigma, type_t *type, int *LMS, int LMSSize) {
  int *bucket = new int[sigma];
  //bucket 用于统计每个字符出现的次数
  int *buf = new int[sigma];
  //buf 用于分配sa中的内存
  memset(sa, -1, sizeof(sa[0]) * len);
  memset(bucket, 0, sizeof(bucket[0]) * sigma);
  for(int i = 0; i < len; ++i) {
    ++bucket[str[i]];
  }
  buf[0] = bucket[0];
  for(int i = 1; i < sigma; ++i) {
    buf[i] = buf[i - 1] + bucket[i];
  }
  //此时buf[c]表示字符c在sa中对应内存区的最后一位的下标+1

  //把LMS后缀逆序依次放入sa中对应的S型桶末尾
  for(int i = LMSSize - 1; i >= 0; --i) {
    sa[--buf[str[LMS[i]]]] = LMS[i];
  }

  //重置内存区域
  buf[0] = 0;
  for(int i = 1; i < sigma; ++i) {
    buf[i] = buf[i - 1] + bucket[i - 1];
  }
  //此时buf[c]表示字符c在sa中对应内存区的第一位的下标

  //正序扫描sa
  for(int i = 0; i < len; ++i) {
    if(sa[i] <= 0) continue;
    if(type[sa[i] - 1] != L) continue;
    //将sa[i]-1放入对应的L型桶中
    sa[buf[str[sa[i] - 1]]++] = sa[i] - 1;
  }
  
  //重置内存区域
  buf[0] = bucket[0];
  for(int i = 1; i < sigma; ++i) {
    buf[i] = buf[i - 1] + bucket[i];
  } 
  //此时buf[c]表示字符c在sa中对应内存区的最后一位的下标+1

  //逆序扫描sa
  for(int i = len - 1; i >= 0; --i) {
    if(sa[i] <= 0) continue;
    if(type[sa[i] - 1] != S) continue;
    //将sa[i]-1放入对应的S型桶中
    sa[--buf[str[sa[i] - 1]]] = sa[i] - 1;
  }

  //内存回收
  delete[] bucket;
  delete[] buf;
  return;
}
```

让我们分析一下这样做的正确性：

首先逆序扫描$LMS$，把$LMS$后缀逆序依次放入$sa$中对应的$S$型桶末尾。这样做可以保证$LMS$**后缀在后缀数组中也是有序的**。

正序扫描$sa$，若$type[sa[i]-1]=L$，则将$sa[i]-1$放入对应的$L$型桶中。

让我们回忆$LMS$的意义：$LeftMostS-type$，也就是说$LMS$的左侧一定是连续的$L$型，并且所有连续的$L$型字符右侧都有一个$LMS$。

然后，由于只查看$L$型，而$L$型的后缀必定比下一位要大，所以放入$sa$中的位置一定在当前位置$i$之后。

由此可知，$L$型后缀不重不漏放入了$sa$数组里。

那么L型后缀是否正确放入了应在的位置呢？我们简单证明一下：

假设两个已知大小关系的后缀$X<Y$，讨论$aX$与$bY$的大小关系：

1. 当$a\not=b$时，由于$aX$与$bY$各自放入相应的桶里，互不干扰，所以正确排序。
2. 当$a=b$时，$X<Y$，所以$aX<bY$。由于从左向右扫描$sa$数组，先扫描到$X$，所以先置入$aX$，正确排序。

对于$S$型的证明与$L$型类似。额外说一句在于此时$LMS$的意义已经消失，可以看作普通的$S$型进行排序。

于是，我们得到了该字符串的后缀数组。

但是我们发现还有一个问题刚才被我们跳过去了：LMS后缀的排序。

# $LMS$后缀排序

在给所有$LMS$后缀排序之前，我们为所有$LMS$子串按大小离散化，并存入$s1$中。

| 下标 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 字符 | A | G | A | T | G | A | G | A | T | A | C | G | C | G | G | T | # |
| |   |   | * |   |   | * |   | * |   | * |   |   | * |   |   |   | * |
| LMS子串 | ATGA | AGA | ATA | ACGC | CGGT# | # |
| s1 | 4 | 2 | 3 | 1 | 5 | 0 |

**引理2：$s1$中两个后缀的大小关系，就是$str$中对应的$*$型后缀的大小关系。**

证明：~~显然。~~ 我们可以将$s1$视为是将$*$后缀中不重合的部分进行切割，所以$s1$的后缀就意味着$LMS$后缀，$s1$中两个后缀的大小关系，就是$str$中对应的$*$型后缀的大小关系。

如果向本例这样$s1$中无相同的数值，那么$s1$中后缀大小关系是显然的，可以直接表示出来。

如果$s1$中有相同数值（即存在相同的$LMS$子串），则可递归计算$s1$的后缀大小。

那么我们现在的问题转化成了如何为$LMS$子串离散化（排序）：

# $LMS$子串的排序

我们依然使用诱导排序，不过往里传的LMS数组并不是排好序的，而是随机的（任意顺序）。

待算法完成，我们获得的$sa$数组中，$LMS$子串之间是排好了序的。

证明：

对于任意后缀$suffix(i)$，本次诱导排序只考虑下标$i$开始到下一个$LMS$字符的部分（称为$LMS$前缀）。显然对于任意$LMS$后缀，有效部分只有第一个字符，所以放入桶中后自然有序。由此，之后的$L$与$S$型排序虽然整体后缀无序，但只考虑$LMS$前缀则有序，最终的$LMS$子串也是有序的。

# 复杂度分析

至此，SA-IS已经讲完了，让我们分析下它为什么是$\Theta(n)$的时空复杂度：

由于LMS字符个数不会超过字符串长度的一半，所以对于每层SA-IS，时间复杂度为$T(n)$，则有

$$
T(n)=\Theta(n)+T(n/2)
\\T(n)=\Theta(n)
$$

空间复杂度同理。

代码：https://paste.ubuntu.com/p/dP5B57mXHM/

> 参考资料：

> [后缀数组及SA-IS算法学习笔记](https://blog.xehoth.cc/SA-IS/)

> [后缀数组 SA-IS 算法学习心得](https://zhuanlan.zhihu.com/p/39876310)

> [A walk through the SA-IS Suffix Array Construction Algorithm](http://zork.net/~st/jottings/sais.html)


---

## 作者：一Iris一 (赞：20)

本文采用的是使用 SAM 求 SA。

若您对 SAM 感兴趣，这里安利这篇[文章](https://www.luogu.com.cn/blog/Wild-Donkey/hou-zhui-zi-dong-ji-suffix-automaton)。

虽然该题题解中确实有几篇提到过如何使用 SAM 求 SA，但是均不能在 $128MB$ 的限制下通过此题。

所以本文着重介绍两点：

$1$° 使用 SAM 求后缀排序

$2$° **空 间 压 缩**

其中，第二点无论是在 SA 的题解中，还是在 SAM 的题解中，均没有详细地讲过空间压缩这一问题。

#Part 1
----

根据 SAM 的性质，我们建出来的自动机的 fa 边构成一颗 parents 树，这棵树的叶子节点即为字符串前缀。

所以很自然地，我们可以倒着插入字符串，这样可构造 parents 树即为后缀树。

所以求后缀排序已经被转化为了在后缀树上求按字典序遍历顺序后叶子节点访问顺序。

但是我们又发现一个问题，我们在后缀树上遍历节点的时候，最多有 $26$ 个子节点连向它，那么我们如何知道走哪条边才是按字典序遍历呢

我们可以在建 SAM 时对每个节点记一个 Right，即在原串的位置。那么通过 Right 与其父节点的 maxlen 就能求出该节点由父亲指向自己的首字符。

然后按照类似拓扑序那样的套路，开个桶然后丢进去排序即可。

贴一下求首字符的函数
```cpp
for(int i=1;i<=cnt;i++) g[i] = Get(c[n + 1 - Right[i] + node[node[i].fa].len]);
```
然后在 SAM 上 dfs 时，对叶子的遍历顺序即为后缀排序。

# Part 2
-------
从理论上来说

SAM 的状态数最多有 $2n -1$ 个， 而转移数则有 $3n-4$ 个

均是 $O(n)$ 级别

但实际空间真有这么优吗？按上面的思路交上去 MLE。

仔细算一波空间

$$2\times \left \vert \sum \right \vert  \times10^6 \approx 473MB $$

很明显爆空间了。

于是我们现在有 2 种解决方案

$1$° 使用 STL

$2$° 不使用 STL

------

对于使用STL的方案，有三种容器供我们挑选。

map、unordered_map、set

其中经过我的实验发现：

map、unordered_map 都不能通过该题，在空间与时间方面均被卡死。另外，unordered_map 常数大的离谱……

set 我并没有试过，但想到其与 map 内部实现本质相同，应该也难以通过此题。

所以，如果在空间较紧的情况下，不推荐使用 STL。

------

对于不使用 STL 的方案，我们又有 2 种子方案

第一种是手写一棵支持插入、删除、查询、查询是存在等操作的平衡树（应该不会有人真的手写一棵平衡树吧

时间复杂度 $O(n\log\left\vert\sum\right\vert)$

第二种是手写哈希表

相比第一种来说哈希更加好写，时间上更有保证（受不同哈希方法的影响

这里展示两种哈希表，一种是借鉴duyi的随机探测哈希表，另一种是我手写的哈希挂链。


时间上，前者明显优于后者。从空间上，后者比前者更优。



```cpp
namespace Hash{//随机探测
//不过这个方法好像要调用__builtin_ctz()这个函数来卡常 ， 双下划线函数
	const unsigned MOD = 19260817;
	const unsigned STP = 9000011;
	struct Node{
		unsigned val;
		unsigned rea;
	}hs[MOD + 10];
	inline unsigned &mk(int x,int y)
	{
		register unsigned real(26 * x + y), i(x) , stp(((real%STP) * 2) ^ 1);
		for(;hs[i].rea&&hs[i].rea!=real;i = i + stp, i -= (i >= MOD) ? MOD : 0)
		if(hs[i].rea == real) return hs[i].val;
		hs[i].rea = real;
		return hs[i].val;
	} 
}
```
单次查询接近 $O(1)$。

```cpp
namespace Hash{//挂链法
	unsigned head[np * 2];
	unsigned Nxt[np*3];
	unsigned val[np*3];
	unsigned rea[np*3];
	int Tit;
	
	inline unsigned &mk(unsigned x,unsigned y)
	{
		for(int i=head[x];i;i = Nxt[i])
		{
			if(rea[i] == y)
			{
				return val[i];
			 } 
		}
		Tit++;
		Nxt[Tit] = head[x];
		head[x] = Tit;
		rea[Tit] = y;
		return val[Tit];		
	}
	
	inline void Memcpy(int x,int y)//这样复制常数更小
	{
		for(int i=head[x] ;i ;i=Nxt[i])
		{
			++Tit;
			Nxt[Tit] = head[y];
			head[y] = Tit;
			val[Tit] = val[i];
			rea[Tit] = rea[i];
		}
	}
}
```
单次查询为 $O(\left\vert\sum\right\vert)$。

综上所述，若空间压得紧，推荐使用哈希挂链法。

这里还有个卡常小技巧，对于在 SAM 上跳 fa 边检查 $son[x]$ 是否存在时，没必要每次都访问你所维护的数据结构，而是在该节点开一个 $64$ 位变量，用二进制压缩的方法用位运算查看每种转移边是否存在。

# Code
```cpp
#include<bits/stdc++.h>

using namespace std;

#define INF 1ll<<30
#define ill long long
#define sto set<node>::iterator
#define ri register int

template<typename _T>
inline void read(_T &x)
{
	x=0;char s=getchar();int f=1;
	while(s<'0'||s>'9') {f=1;if(s=='-')f=-1;s=getchar();}
	while('0'<=s&&s<='9'){x=(x<<3)+(x<<1)+s-'0';s=getchar();}
	x*=f;
}

int Get(char ch)
{
    if (ch<='9' && ch>='0') return ch-'0';
    if (ch<='Z' && ch>='A') return ch-'A'+10;
    if (ch<='z' && ch>='a') return ch-'a'+36;
    return ch;
}
const int np = 1e6+5;

namespace Hash{ /* 这里有一个卡常小技巧 ， 链表的访问内存不连续，对Cache极不友好，常数会变得巨大
如果TLE了请试试vector，可能更快
*/
	unsigned head[np * 2];
	unsigned Nxt[np*3];
	unsigned val[np*3];
	unsigned rea[np*3];
	int Tit;
	
	inline unsigned &mk(unsigned x,unsigned y) // 传址函数 ， 在函数外可直接修改该地址上的值
	{
		for(int i=head[x];i;i = Nxt[i])
		{
			if(rea[i] == y)
			{
				return val[i];
			 } 
		}
		Tit++;
		Nxt[Tit] = head[x];
		head[x] = Tit;
		rea[Tit] = y;
		return val[Tit];		
	}
	
	inline void Memcpy(int x,int y)
	{
		for(int i=head[x] ;i ;i=Nxt[i])
		{
			++Tit;
			Nxt[Tit] = head[y];
			head[y] = Tit;
			val[Tit] = val[i];
			rea[Tit] = rea[i];
		}
	}
}

struct SAM{
	int fa;
	int len;
	int pos;
}node[np * 2];

int cnt = 1 , la = 1,n;
int Right[np << 1];
ill g[np << 1];//压缩是否存在

inline void add(int x,int i)
{
	ri k,p,q,now;
	p = la , now = la = ++cnt ;
	Right[now] = node[now].len = node[p].len + 1,node[now].pos = i;
	for( ;p &&!((g[p]>>x)&1ll);g[p] += (1ll<<x),Hash::mk(p,x)=now, p = node[p].fa );
	if(!p) return (void)(node[now].fa = 1);
	if(node[p].len + 1 == node[q = Hash::mk(p,x)].len) return (void)(node[now].fa = q);
	node[k = ++cnt].len = node[p].len + 1, node[k].fa = node[q].fa , node[q].fa = node[now].fa = k ,g[k] = g[q] ;
	Right[k] = Right[q];
	Hash::Memcpy(q,k);
	for(;p && !(Hash::mk(p,x)^q) ;Hash::mk(p,x) = k , p = node[p].fa);	
}

int bac[256 + 10];
int tit;
char c[np];

inline void Add(int a,int b)
{
	Hash::rea[++tit] = b;
	Hash::Nxt[tit] = Hash::head[a];
	Hash::head[a] = tit;
}

inline void solve()
{
	for(int i=1;i<=cnt;i++) g[i] = Get(c[n + 1 - Right[i] + node[node[i].fa].len]) , bac[g[i]]++;
	for(int i=1;i<=256;i++) bac[i]+= bac[i-1];
	for(int i=1;i<=cnt;i++) Right[bac[g[i]]--] = i;
	for(int i=cnt;i>=1;i--) Add(node[Right[i]].fa , Right[i]);
}

inline void dfs(int x)
{
	if(node[x].pos)	printf("%d " , node[x].pos);
	for(int i=Hash::head[x];i;i=Hash::Nxt[i])
	dfs(Hash::rea[i]);
}

signed  main()
{
	scanf("%s",c+1);
	n = strlen(c+1);
	for(int i=n;i>=1;i--) add(Get(c[i]) , i);
	for(int i=1;i<=cnt;i++) Hash::head[i] = 0;
	solve();
	dfs(1);
	
 }
```
可以看见即使是写了哈希表，还是需要利用重复数组才勉强卡过 $128MB$，并且在苟过 $128MB$ 之后，可扩展性几乎为 $0$。

所以在 $128MB$ 下，请慎用 SAM 。当然了，空间为 $256MB$ 时还是可以随便用的。

时间复杂度 $O(n\left\vert\sum\right\vert)$

# $End$

虽然这是 SA 板子的题解，但为了展示压缩空间的重要性和优越性，我还是选择了在这里讲解 SAM 压缩空间技巧。

在 SAM 题解中，几乎所有题解都认为开 map 是可以将 SAM 大量冗余空间优化掉的，所以并没有人认真讲有关空间压缩的问题……

所以才有了这篇题解。
### 参考资料：
[远航之曲博客](https://www.luogu.com.cn/blog/yhzq/solution-p3809)

duyi的 AC 自动机（二次加强版）提交记录（不贴链接了，如果没过的话也看不了


---

## 作者：一扶苏一 (赞：12)

# 后缀排序

[更好的阅读体验](https://www.cnblogs.com/yifusuyi/p/11739881.html)

## Task

### Description

给定一个字符串，要求按字典序升序输出它的所有后缀子串的第一个字符所在位置。

### Requirements & Limitations

字符集大小为常数，要求时间复杂度 $O(n \log n)$，其中 $n$ 为字符串长度

## Algorithm

这就是大(ren)名(lei)鼎(zhi)鼎(hui)的后缀排序了。这里记录倍增法。

定义后缀 $i$ 为首字符所在原字符串位置为 $i$ 的后缀子串。

定义 $sa_i$ 为排名为 $i$ 的后缀的首字符所在位置，$rnk_i$ 为后缀 $i$ 的排名。也即对 $sa_i$ 做排序相当于对原字符串做排序。

注意到 $sa$ 和 $rnk$ 是可以在 $O(n)$ 时间内互相推出的，因为 排名为 (后缀 $i$ 的排名) 的后缀为 $i$，形式化的说，$sa_{rnk_i} = i$，

考虑进行多次排序，每次排序固定一个长度，对所有后缀子串的该长度的前缀排序(长度不足补 $0$)。我们倍增这个长度。

首先，我们对所有后缀子串的第一位进行排序，当字符相同时，我们要求首字符所在位置小的在前面，例如对于字符串 $ababa$ 的所有后缀子串

```
1 ababa
2 baba
3 aba
4 ba
5 a
```

进行一次排序的结果为

```
1 ababa
3 aba
5 a
2 baba
4 ba
```

即我们 $sa$ 数组当前的值为 $\{1,~3,~5,~2,~4\}$，然后计算 $rnk$ 数组，但是需要注意的是，两字符串第一位相同时，他们的 $rnk$ 也应该相同。例如，$rnk_1 = rnk_3 = 1$。类似的得到 $rnk$ 数组当前的值为 $\{1,~2,~1,~2,~1\}$。

然后进行下一次排序。

由于第一次排序的长度为 $1$，所以本次排序的长度为 $1 \times 2 = 2$

对于上次的排序结果，我们它们的前两位进行排序。但是注意到一个性质：我们已经排好了第一位，现在对第二位进行大小比较，我们发现后缀 $i$ 的第 $2$ 位正是后缀 $(i + 1)$ 的第 $1$ 位，因此第二位的字符的相对大小关系我们也是知道的，具体的，比较 $(sa_i,~sa_j)$，若 $rnk_{sa_i} \neq rnk_{sa_j}$，则他们的大小关系为 $rnk_{sa_i}$ 和 $rnk_{sa_j}$ 的大小关系。否则则说明它们的第一位是相同的，那么比较第二位，则它们的大小关系是 $rnk_{sa_i + 1}$ 与 $rnk_{sa_j + 1}$ 的大小关系。

排序以后的结果为

```
5 a
1 ababa
3 aba
4 ba
2 baba
```

即 $sa$ 数组当前的值为 $\{5,~1,~3,~4,~2\}$，而 $rnk$ 当前的值为 $\{2,~3,~2,~3, ~1\}$

然后进行下一次排序。

由于上次的排序长度为 $2$，所以本次排序的长度为 $2 \times 2 = 4$

类似于上次的排序，我们已经知道了前两位的相对大小关系，现在要求前四位的相对大小关系，而后缀 $i$ 的后两位正是后缀 $(i + 2)$ 的前两位，在上次排序已经被排好了。于是他们后两位字符的相对大小关系也是知道的。

类似的，得到排序的结果为

```
5 a
3 aba
1 ababa
4 ba
2 baba
```

即 $sa = \{5,~3,~1,~4,~2\}$，$rnk = \{3,~5,~2,~4,~1\}$

至此， $rnk$ 数组已经是一个 $1 \sim n$ 的排列，这意味着所有的后缀已经都排好了序，输出即可。

形式化的，我们倍增所排序的长度，设当前需要排序的长度为 $2len$，已经对 $len$ 长度排好了序，且 $sa$ 和 $rnk$ 存储的是长度为 $len$ 时的排序信息，那么对于两个后缀 $(i, j)$，他们的前半部分大小关系为 $(rnk_i, rnk_j)$，而注意到他们后半部分即为后缀 $(i + len)$ （或后缀 $(j + len)$）的前半部分，因此他们后半部分的大小关系为 $(rnk_{i + len}, rnk_{j + len})$。根据字符串比较规则，如果前半部分大小不同，则大小关系为前半部分大小关系，否则为后半部分大小关系。也就相当于对 $(rnk_i, rnk_{i + len})$ 这个二元组进行排序。一直到所倍增的长度大于 $n$ 时，则所有后缀的大小已被排好。

### Algorithm $1$

#### Solution

我会 ``std::sort``！

我们倍增长度，对二元组 $(rnk_i, rnk_{i + len})$ 排序时，直接使用 ``std::sort``。注意到我们倍增了 $O(\log n)$ 次，每次需要进行一次 $O(n \log n)$ 的排序，因此总时间复杂度 $O(n \log^2 n)$。但是依然能跑过你谷的模板题。

这个做法非常易于理解，因为这只是翻译了上面推导过程，代码也好记好写。

#### Code

```cpp
#include <cstdio>
#include <algorithm>

const int maxn = 2000005;

int n;
char S[maxn];
int rnk[maxn], sa[maxn];
std::pair<int, int> MU[maxn];

int ReadStr(char *p);
bool cmp(const int &a, const int &b);

int main() {
  freopen("1.in", "r", stdin);
  n = ReadStr(S);
  for (int i = 1; i <= n; ++i) {
    rnk[i] = 1;
    sa[i] = i;
    MU[i].second = S[i];
  }
  for (int len = 1; len <= n; len <<= 1) {
    std::sort(sa + 1, sa + 1 + n, cmp);
    for (int i = 1; i <= n; ++i) {
      if (MU[sa[i]] == MU[sa[i - 1]]) {
        rnk[sa[i]] = rnk[sa[i - 1]];
      } else  {
        rnk[sa[i]] = i;
      }
    }
    for (int i = 1; i <= n; ++i) {
      MU[i].first = rnk[i];
      MU[i].second = rnk[i + len];
    }
  }
  for (int i = 1; i <= n; ++i) {
    qw(sa[i], ' ', true);
  }
  putchar('\n');
  return 0;
}

int ReadStr(char *p) {
  auto beg = p;
  do *(++p) = IPT::GetChar(); while (((*p >= 'a') && (*p <= 'z')) || ((*p >= '0') && (*p <= '9')) || ((*p >= 'A') && (*p <= 'z')));
  *p = 0;
  return p - beg - 1;
}

inline bool cmp(const int &a, const int &b) {
  if (MU[a] != MU[b]) {
    return MU[a] < MU[b];
  } else {
    return a < b;
  }
}
```

### Algorithm $2$

考虑是对双关键字进行排序，因此我们可以先对第二关键字做桶排序，然后对第一关键字做桶排序，在排序时，记录每个桶所压入的序号序列，取出是按照序列的顺序取出每个下标，作为排好序的序列。由于桶排序是稳定的排序，这样在第一关键字相同的时候先取出的是第二关键字较小的下标。这样我们得到了一个 $O(n)$ 的基数排序，但是由于 ``std::vector`` 常数太大，这样的写法甚至比 $O(n \log^2 n)$ 的做法还要慢一倍，在你谷的板板题上会T三个点。

这个做法只是用这个大常数基数排序替换上面的 ``std::sort``，虽然很慢但是他的复杂度已经正确了。

#### Code

其余部分相同，只是将 ``std::sort`` 换成 ``RadixSort``，排序部分代码如下

```cpp
std::vector<int>bk[maxn];

void RadixSort(int *const beg, int *const ed) {
  for (auto it = beg; it != ed; ++it) {
    bk[MU[*it].second].push_back(*it);
  }
  auto p = beg;
  for (int i = 0; i <= n; ++i) {
    for (auto u : bk[i]) {
      *(p++) = u;
    }
    bk[i].clear();
  }
  for (auto it = beg; it != ed; ++it) {
    bk[MU[*it].first].push_back(*it);
  }
  p = beg;
  for (int i = 0; i <= n; ++i) {
    for (auto u : bk[i]) {
      *(p++) = u;
    }
    bk[i].clear();
  }
}
```

### Algorithm $3$

考虑使用人类智慧优化我们的基数排序部分。

我们再定义一个数组 $tp$，$tp_i$ 代表 **第二关键字** 为 $i$ 时字符串的位置。

**（注意我们下方的假设为已经对 $len$ 做好了排序，现在要排序 $2len$）**

例如，$len = 2,~rnk_3 = 2$，则有 $tp_2 = 1$，因为后缀 $1$ 的第二关键字为 $rnk_{1 + 2 = 3} = 2$，因此 $tp_2 = 1$。

形式化的，当 $i + len \leq n$ 时，$tp_{rnk_{i + len}} = i$。

而当 $i + len > n$ 时，我们发现这一部分的 $i$ 对应的第二关键字都是 $0$（因为后半部分是空串），比不是零的都要小，考虑到要求字典序相同时序号小的在前，我们只需要令 $tp_{i + len - n} = i$ 即可。

当然，赋值时我们考虑枚举 $sa$ 的值而不是 $rnk$ 的（因为初始 $rnk$ 的赋值会是字符集，需要一些额外处理），于是有

$\forall i \leq len,~tp_i = n - len + 1$，这一部分是对应第二关键字为 $0$ 的部分。

$\forall sa_i > len,~~tp_{++pos} = sa_i - len$。其中 $pos$ 为计数器，初值为 $len$。注意我们是从小到大枚举 $i$ 而不是枚举 $sa_i$。

现在用另一种方法解释第二个式子：

我们从小到大枚举了 $sa_i$ ，即我们按照排名从小到大枚举了每个字符串，那么他们作为第二关键字的值当然是从小到大的（因为第二关键也是排名），所以我们按顺序记录这些位置，而这些位置作为第二关键字，对应第一关键字的位置是 $sa_i - len$，因为当前需要排序的长度为 $2len$，所以第一关键字与第二关键字的位置相差 $len$。

上面两句求 $tp$ 的方法，是人类智慧基数排序的关键前提条件。

现在考虑进行基数排序。

基数排序的代码如下

```cpp
void RadixSort() {
  for (int i = 0; i <= m; ++i) tax[i] = 0;
  for (int i = 1; i <= n; ++i) ++tax[rnk[i]];
  for (int i = 1; i <= m; ++i) tax[i] += tax[i - 1];
  for (int i = n; i; --i) sa[ tax[rnk[tp[i]]]-- ] = tp[i];
}
```

$tax$ 代表桶，首先将桶清零，然后枚举**每个字符串**，将**字符串的排名**放入桶内。

然后对桶做一个前缀和。我们发现我们现在放入桶内的是第一关键字，这意味着从这个桶 $tax_i$ 里出来的字符串所在的排名定大于 $\sum_{x = 1}^{i - 1} tax_x$，因为这部分的第一关键字小于 $i$，他们的排名一定小于第一关键字为 $i$ 的字符串。同理，他们的排名一定不大于 $\sum_{x = 1}^i tax_x$。

然后进入第四行，我们倒序枚举第二关键字的值，用 $tp$ 来确定这个第二关键字是哪个字符串的，然后用 $rnk$ 找到这个字符串对应哪个桶。这个桶即为 $tax_{rnk_{tp_i}}$。然后我们注意到从这个桶里出来的元素下标上界为当前的前缀和值，而我们是倒序枚举的第二关键字，所以它的排名应该是桶里剩下字符串中第二关键字最大也即排名最大的，因此它的排名就是  $tax_{rnk_{tp_i}}$。完成后，将这个桶的值自减 $1$，代表将它的上界减一。这么做下去就可以完成基数排序。

好人类智慧啊QAQ

#### Code

```cpp
#include <ctime>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>

int n, m;
char S[maxn];
int rnk[maxn], sa[maxn], tp[maxn], tax[maxn];

void RadixSort();
int ReadStr(char *p);
bool cmp(const int &a, const int &b);

int main() {
  freopen("1.in", "r", stdin);
  n = ReadStr(S);
  for (int i = 1; i <= n; ++i) {
    rnk[i] = S[i];
    tp[i] = i;
  }
  m = 1000;
  RadixSort();
  for (int len = 1, p = 0; p < n; len <<= 1, m = p) {
    p = 0;
    for (int i = 1; i <= len; ++i) tp[++p] = n - len + i;
    for (int i = 1; i <= n; ++i) if (sa[i] > len) tp[++p] = sa[i] - len;
    RadixSort();
    std::swap(tp, rnk);
    rnk[sa[1]] = p = 1;
    for (int i = 2; i <= n; ++i) {
      rnk[sa[i]] = ((tp[sa[i - 1]] == tp[sa[i]]) && (tp[sa[i - 1] + len] == tp[sa[i] + len])) ? p : ++p;
    }
  }
  for (int i = 1; i <= n; ++i) {
    qw(sa[i], ' ', true);
  }
  putchar('\n');
  return 0;
}

int ReadStr(char *p) {
  auto beg = p;
  do *(++p) = IPT::GetChar(); while (((*p >= 'a') && (*p <= 'z')) || ((*p >= '0') && (*p <= '9')) || ((*p >= 'A') && (*p <= 'z')));
  *p = 0;
  return p - beg - 1;
}

void RadixSort() {
  for (int i = 0; i <= m; ++i) tax[i] = 0;
  for (int i = 1; i <= n; ++i) ++tax[rnk[i]];
  for (int i = 1; i <= m; ++i) tax[i] += tax[i - 1];
  for (int i = n; i; --i) sa[ tax[rnk[tp[i]]]-- ] = tp[i];
}
```

## Appreciation

$Algorithm~~3$ 的代码参考于 @[自为风月马前卒](https://www.cnblogs.com/zwfymqz/) 的 [blog](https://www.cnblogs.com/zwfymqz/p/8413523.html)。

 

---

## 作者：PM250 (赞：8)

一说到排序，就想起~~今年下半年~~平衡树

### 前置技能

0.重量平衡树（替罪羊树）

1.给定一个序列，比较两个元素的先后

**排名比较** $O(1)$

2.给定一个带插入的链表，比较两个元素的先后

**顺序查找？** $O(n)$

**比较排名？**

插入时以前驱和后继的排名的平均数作为自己的排名

添加0和正无穷两个虚拟节点

排名为**实数**类型

$O(1)$

3.给定一个后缀数组，比较两个后缀的先后

同2. $O(1)$

### 概念
后缀平衡树是**动态的后缀数组**

支持的操作：

1.在字符串前插入字符c

2.询问一个后缀在平衡树中的排名

3.询问一个字符串在平衡树中的排名
### 操作1

我们用$S_i$ 代表原串$S$从第$i$个字符开始的后缀

假设我们已经有了串$S$的后缀平衡树 

插入一个字母 $c$ 

则后缀 $cS$ 与任意一个后缀 $S_i$ 的大小关系可以用 $c$ 与 $S_i$ 的第一个字母的大小关系以及后缀 $S_1$ 与后缀 $S_{i+1}$ 的大小关系来表示 

前面是两个字符的比较 $O(1)$ 

后面原串后缀的大小关系可以在平衡树上维护排名 $O(1)$ 比较

tips：插入过程中维护前驱后继的排名

### 操作2

平衡树基本操作 $O(logn)$

### 操作3

平衡树基本操作，比较改为字典序比较 $O(logn|Q|)$

### 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
typedef unsigned long long ll;
const int maxn=1000005;
const ll inf=0x4000000000000000;
int siz[maxn],c[maxn][2],rt;
ll val[maxn];//每个位置的值，用于O(1)比较两个后缀的先后
char s[maxn];
int n;
int sa[maxn];//假装是SA
bool cmp(int x,int y)
{
    return s[x]<s[y]||s[x]==s[y]&&val[x+1]<val[y+1];
}
/****替罪羊重建****/
int st[maxn],top;
void dfs(int &x)
{
    if(x)dfs(c[x][0]),st[++top]=x,dfs(c[x][1]),x=0;
}
int reb(int l,int r,ll L,ll R)
{
    int mid=l+r>>1;
    int x=st[mid];
    siz[x]=r-l+1;
    val[x]=L+R>>1;
    if(l<mid)c[x][0]=reb(l,mid-1,L,val[x]);
    if(mid<r)c[x][1]=reb(mid+1,r,val[x],R);
    return x;
}
/****替罪羊插入****/
void ins(int &x,int y,ll L=0,ll R=inf,bool d=1)
{
    if(!x)
        x=y,siz[x]=1,val[x]=L+R>>1,c[x][0]=c[x][1]=0;
    else
    {
        siz[x]++;
        bool w=cmp(x,y);
        bool bad=siz[c[x][w]]>siz[x]*0.7+5&&d;
        ins(c[x][w],y,w?val[x]:L,w?R:val[x],d&&!bad);
        if(bad)top=0,dfs(x),x=reb(1,top,L,R);
    }
}
int cnt;
void tosa(int x)//假装是SA
{
    if(x)tosa(c[x][0]),sa[++cnt]=x,tosa(c[x][1]);
}
int main()
{
    scanf("%s",s+1);
    n=strlen(s+1);
    for(int i=n;i;--i)
        ins(rt,i);
    tosa(rt);
    for(int i=1;i<=n;++i)
        printf("%d ",sa[i]);
    return 0;
}
```

参考资料：

[后缀平衡树学习笔记](https://blog.csdn.net/liutian429073576/article/details/53056038)

---

## 作者：Polaris_Dane (赞：3)

竟然没有后缀树的题解

 后缀树讲解请看[EternalAlexander的讲解](https://www.luogu.com.cn/blog/EternalAlexander/xuan-ku-hou-zhui-shu-mo-shu)
 
 或者[我的菜鸡讲解](https://www.luogu.com.cn/blog/Polarisluogu/hou-zhui-shuo-ju-jie-gou-mo-shu-zong-jie)
 
 非常明显构造出后缀树后，他的$dfs$序就是后缀排序的结果
 
 由于字符集较大，所以后缀树的效率不高
 
 可以用一些奇技淫巧优化一下，本人不会
 
 于是有代码
 
 ```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cctype>
#include<set>
#include<map>
#define LL long long
#define M 2000005
#define N 50010
using namespace std;
const int inf=0x3f3f3f3f;
const int mod=1e9+7;
const double eps=1e-6;
inline int read(){
	int f=1,x=0;char s=getchar();
	while(!isdigit(s)){if (s=='-')f=-1;s=getchar();}
	while(isdigit(s)){x=(x<<1)+(x<<3)+(s^48);s=getchar();}
	return x*f;
}
map<char,int>st;
int tot,n,ranks[M],rk,t,num;
struct Suffix_Tree{
	int link[M],s[M],len[M],start[M],ch[M][71],rem,now,last;
	Suffix_Tree(){tot=1,n=rem=0,now=1,len[0]=inf;}
	inline int New(int st,int le){link[++tot]=1,start[tot]=st,len[tot]=le;return tot;}
	inline void extend(int x){
		s[++n]=x,rem++;
		for (int last=1;rem;){
			while (rem>len[ch[now][s[n-rem+1]]])
				rem-=len[now=ch[now][s[n-rem+1]]];
			int &v=ch[now][s[n-rem+1]],c=s[start[v]+rem-1];
			if (!v||x==c){
				link[last]=now,last=now;
				if (!v) v=New(n,inf);
				else break;
			}
			else{
				int u=New(start[v],rem-1);
				ch[u][c]=v,ch[u][x]=New(n,inf);
				start[v]+=rem-1,len[v]-=rem-1;
				link[last]=v=u;last=u;
			}
			if (now==1) rem--;
			else now=link[now];
		}
	}
	inline void adjust(int x,int dep){
		int cnt=0;
		for (int i=0;i<=num;i++)
			if (ch[x][i]) ++cnt,adjust(ch[x][i],dep+len[ch[x][i]]);
		if (!cnt) len[x]=t-start[x];
	}
	inline void dfs(int x,int dep){
		int cnt=0;
		for (int i=0;i<=num;i++) 
			if (ch[x][i]) ++cnt,dfs(ch[x][i],dep+len[ch[x][i]]);
		if (!cnt) ranks[++rk]=t-dep;
	}
}tree;
char str[M],tmp[M];
signed main(void){
	scanf("%s",str+1);
	t=strlen(str+1);
	for (int i=1;i<=t;i++) tmp[i]=str[i];
	sort(tmp+1,tmp+t+1);
	for (int i=1;i<=t;i++){
		if (tmp[i]!=tmp[i-1]) ++num;
		st[tmp[i]]=num;
	}
	for (int i=1;i<=t;i++) tree.extend(st[str[i]]);
	tree.extend(0);rk=-1;
	tree.adjust(1,0);
	tree.dfs(1,0);
	for (int i=1;i<=t;i++) printf("%d ",ranks[i]);
	return 0;
}
										
```


---


# [AHOI2013] 差异

## 题目描述

给定一个长度为 $n$ 的字符串 $S$，令 $T_i$ 表示它从第 $i$ 个字符开始的后缀。求

$$\displaystyle \sum_{1\leqslant i<j\leqslant n}\operatorname{len}(T_i)+\operatorname{len}(T_j)-2\times\operatorname{lcp}(T_i,T_j)$$

其中，$\text{len}(a)$ 表示字符串 $a$ 的长度，$\text{lcp}(a,b)$ 表示字符串 $a$ 和字符串 $b$ 的最长公共前缀。

## 说明/提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $2\le n\le 500000$，且 $S$ 中均为小写字母。

## 样例 #1

### 输入

```
cacao```

### 输出

```
54```

# 题解

## 作者：小粉兔 (赞：52)

### 题意简述：

定义两个字符串 $S$ 和 $T$ 的差异 $\operatorname{diff}(S,T)$ 为这两个串的长度之和减去两倍的这两个串的最长公共前缀的长度。

给定一个字符串，定义从第 $i$ 个字符开始的后缀为 $Suf_i$。

求 $\sum_{1\le i<j\le n}\operatorname{diff}(Suf_i,Suf_j)$。

### 题解：

化简式子，原式等于

$$\begin{aligned}&\left(\sum_{1\le i<j\le n}i+j\right)-2\times\sum_{1\le i<j\le n}\operatorname{lcp}(Suf_i,Suf_j)\\=&\frac{n(n-1)(n+1)}{2}-2\times\sum_{1\le i<j\le n}\operatorname{lcp}(Suf_i,Suf_j)\end{aligned}$$

所以只要求出后半部分即可。

建立字符串的后缀数组。

考虑 Height 数组的贡献：Height 数组中 \[2, n\] 内的每一个区间都给答案贡献区间最小值。

套路：每个区间的区间最小值之和，使用单调栈解决。

```cpp
#include <cstdio>
#include <cstring>

typedef long long LL;
const int MN = 500005;

int N;
char str[MN];

int M;
int rk[MN], rk2[MN], SA[MN], SA2[MN];
int buk[MN], cnt;
int Height[MN];

void GetHeight() {
	int k = 0;
	for (int i = 1; i <= N; ++i) {
		if (rk[i] == 1) { k = Height[1] = 0; continue; }
		if (k) --k;
		int j = SA[rk[i] - 1];
		while (i + k <= N && j + k <= N && str[i + k] == str[j + k]) ++k;
		Height[rk[i]] = k;
	}
}

void Rsort() {
	for (int i = 1; i <= M; ++i) buk[i] = 0;
	for (int i = 1; i <= N; ++i) ++buk[rk[i]];
	for (int i = 1; i <= M; ++i) buk[i] += buk[i - 1];
	for (int i = N; i >= 1; --i) SA[buk[rk[SA2[i]]]--] = SA2[i];
}

void GetSA() {
	M = 26;
	for (int i = 1; i <= N; ++i) rk[i] = str[i] - 'a' + 1, SA2[i] = i;
	Rsort();
	for (int j = 1; j < N; j <<= 1) {
		int P = 0;
		for (int i = N - j + 1; i <= N; ++i) SA2[++P] = i;
		for (int i = 1; i <= N; ++i) if (SA[i] > j) SA2[++P] = SA[i] - j;
		Rsort();
		rk2[SA[1]] = P = 1;
		for (int i = 2; i <= N; ++i) {
			if (rk[SA[i]] != rk[SA[i - 1]] || rk[SA[i] + j] != rk[SA[i - 1] + j]) ++P;
			rk2[SA[i]] = P;
		}
		for (int i = 1; i <= N; ++i) rk[i] = rk2[i];
		M = P;
		if (M == N) break;
	}
	GetHeight();
}

int st[MN], t;
int L[MN], R[MN];

int main() {
	scanf("%s", str + 1);
	N = strlen(str + 1);
	GetSA();
	st[t = 1] = 1;
	for (int i = 2; i <= N; ++i) {
		while (t && Height[st[t]] > Height[i]) R[st[t--]] = i;
		L[i] = st[t];
		st[++t] = i;
	} while (t) R[st[t--]] = N + 1;
	LL Ans = (LL)(N - 1) * N * (N + 1) / 2;
	for (int i = 2; i <= N; ++i)
		Ans -= 2ll * (R[i] - i) * (i - L[i]) * Height[i];
	printf("%lld\n", Ans);
	return 0;
}
```

---

## 作者：leozhang (赞：17)

后缀数组+单调栈的应用

首先我们研究一下这个表达式，可以发现前半部分与串的情况并没有关系，而只是跟串的长度有关，所以我们先把前半部分算出来。

于是我们只需计算出吗每个lcp即可

那么可以发现，对于排名分别为i，j的两个串，他们的lcp应当是：min(height[i]~height[j])

但是这里的时间复杂度仍然很大

我们换一个角度来思考：如果设min(height[i]~height[j])=height[k]，那么我们认为height[k]产生了一个贡献

所以我们可以从每一个height[k]产生了多少贡献的角度来思考，这样就可以把时间复杂度降到O（n）

不难发现，一个k会对一个区间产生贡献的条件就是height[k]是所在区间的最小值

这就可以用单调栈维护了！！

但是要注意，为了防止重复计算，我们对单调栈的两端点的取等条件设成不一样的（即左侧算到第一个height小于等于height[k],右侧算到第一个height小于height[k]的位置）

这样找到每个点向左和向右能延伸的位置lx,rx这样他所占的区间个数就是（i-lx）*(rx-i)

这样去更新就可以了

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
#define ll long long
using namespace std;
char s[500005];
int sa[500005];
int rank[500005];
int temprank[500005];
int height[500005];
int has[500005];
int v[500005];
int lx[500005],rx[500005];
int l;
bool be_same(int x,int y,int len)
{
    return x+len>l||y+len>l||rank[x]!=rank[y]||rank[x+len]!=rank[y+len];
}
void get_sa()
{
    int cnt=0;
    for(int i=1;i<=l;i++)v[i]=s[i];
    for(int i=1;i<=l;i++)has[v[i]]++;
    for(int i=0;i<128;i++)if(has[i])temprank[i]=++cnt;
    for(int i=1;i<128;i++)has[i]+=has[i-1];
    for(int i=1;i<=l;i++)
    {
        rank[i]=temprank[v[i]];
        sa[has[v[i]]--]=i;
    }
    for(int k=1;cnt!=l;k<<=1)
    {
        cnt=0;
        for(int i=1;i<=l;i++)has[i]=0;
        for(int i=1;i<=l;i++)has[rank[i]]++;
        for(int i=1;i<=l;i++)has[i]+=has[i-1];
        for(int i=l;i;i--)if(sa[i]>k)temprank[sa[i]-k]=has[rank[sa[i]-k]]--;
        for(int i=1;i<=k;i++)temprank[l-i+1]=has[rank[l-i+1]]--;
        for(int i=1;i<=l;i++)sa[temprank[i]]=i;
        for(int i=1;i<=l;i++)temprank[sa[i]]=be_same(sa[i],sa[i-1],k)?++cnt:cnt;
        for(int i=1;i<=l;i++)rank[i]=temprank[i];
    }
    for(int i=1;i<=l;i++)
    {
        if(rank[i]==1)continue;
        int j=max(1,height[rank[i-1]]-1);
        while(s[i+j-1]==s[sa[rank[i]-1]+j-1])height[rank[i]]=j++;
    }
}
void init()
{
    height[0]=height[l+1]=-0x3f3f3f3f;
    ll ret=0;
    for(int i=1;i<=l;i++)lx[i]=i-1,rx[i]=i+1;
    for(int i=2;i<=l;i++)while(height[lx[i]]>height[i])lx[i]=lx[lx[i]];
    for(int i=l;i>=2;i--)while(height[rx[i]]>=height[i])rx[i]=rx[rx[i]];
    for(int i=2;i<=l;i++)ret+=2*height[i]*(ll)((ll)(rx[i]-i)*(ll)(i-lx[i]));
    ll ans=1ll*(l-1)*l/2ll*(l+1);
    printf("%lld\n",ans-ret);
}
int main()
{
    scanf("%s",s+1);
    l=strlen(s+1);
    get_sa();
    init();
    return 0;
}

```


---

## 作者：Kelin (赞：16)

### 题意

求一个定值$-2\times$所有后缀的公共前缀

---

### 题解

前面那个定值是$$\sum_{i=1}^{n-1}\sum_{j=i+1}^ni+j=(n-1)\times\sum_{i=1}^ni=\frac{(n-1)*n*(n+1)}2$$

考虑把原串翻转过来,那么要求的就是所有前缀公共后缀了

两个前缀的最长公共后缀的答案就是这两个前缀所代表的点在后缀树上$lca$的长度

题目就转化为求树上某一个点是多少点对的$lca$再乘上$len[lca]$

上面这个问题可以直接记录一下子树$sz,$然后$DP$求出

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
const int N=5e5+5,M=2*N;
typedef int arr[M];
typedef long long ll;
struct SAM{
    int las,T,ch[M][26];arr fa,sz,len;
    inline void init(){las=T=1;}
    inline void ins(int c){
        int p=las,np;fa[las=np=++T]=1,len[T]=len[p]+1;sz[T]=1;
        for(;p&&!ch[p][c];p=fa[p])ch[p][c]=np;
        if(p){
            int q=ch[p][c],nq;
            if(len[p]+1==len[q])fa[np]=q;
            else{
                fa[nq=++T]=fa[q],len[T]=len[p]+1;memcpy(ch[nq],ch[q],4*26);
                for(fa[q]=fa[np]=nq;ch[p][c]==q;p=fa[p])ch[p][c]=nq;
            }
        }
    }arr b,c;ll sum[M];
    inline ll calc(){
        ll tp=0;
        fp(i,1,T)++c[len[i]];
        fp(i,1,T)c[i]+=c[i-1];
        fp(i,1,T)b[c[len[i]]--]=i;
        fd(i,T,1){int u=b[i];
            tp+=(ll)sz[fa[u]]*sz[u]*len[fa[u]],sz[fa[u]]+=sz[u];
        }
        return tp;
    }
}p;
int n;char s[N];
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    scanf("%s",s);n=strlen(s);p.init();
    fp(i,0,n-1)p.ins(s[i]-'a');
    printf("%lld\n",(ll)(n-1)*n*(n+1)/2-2*p.calc());
return 0;   
}
```

---

## 作者：JZYshuraK (赞：12)

# 差异

题解：

两个后缀之间的$LCP$和显然不好求。

我们先构建后缀数组。

那么任意两个后缀之间的$LCP$之和就是所有$sa$数组上所有区间

的$ht$最小值。

换言之，我们有一个$a$数组。

显然让你求所有区间的权值和。

一个区间的权值为这个区间内所有$a_i$的最小值。

这个过程我们可以用单调栈实现。

Code：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define N 500010 
using namespace std; typedef long long ll;
int wv[N],wa[N],wb[N],Ws[N],x[N],y[N],sa[N],rk[N],ht[N],n,m,S[N],top;
ll f[N]; int r[N]; char s[N];
void build_sa()
{
	m=129;
	int i,j,p,*x=wa,*y=wb,*t;
	for(i=0;i<m;i++) Ws[i]=0;
	for(i=0;i<n;i++) Ws[x[i]=r[i]]++;
	for(i=1;i<m;i++) Ws[i]+=Ws[i-1];
	for(i=n-1;~i;i--) sa[--Ws[x[i]]]=i;
	for(p=j=1;p<n;j<<=1,m=p)
	{
		for(p=0,i=n-j;i<n;i++) y[p++]=i;
		for(i=0;i<n;i++) if(sa[i]-j>=0) y[p++]=sa[i]-j;
		for(i=0;i<n;i++) wv[i]=x[y[i]];
		for(i=0;i<m;i++) Ws[i]=0;
		for(i=0;i<n;i++) Ws[wv[i]]++;
		for(i=1;i<m;i++) Ws[i]+=Ws[i-1];
		for(i=n-1;~i;i--) sa[--Ws[wv[i]]]=y[i];
		for(t=x,x=y,y=t,i=p=1,x[sa[0]]=0;i<n;i++)
		{
			if(y[sa[i]]==y[sa[i-1]]&&y[sa[i-1]+j]==y[sa[i]+j]) x[sa[i]]=p-1;
			else x[sa[i]]=p++;
		}
	}
	for(i=1;i<n;i++) rk[sa[i]]=i;
	for(i=p=0;i<n-1;ht[rk[i++]]=p)
	for(p?p--:0,j=sa[rk[i]-1];r[i+p]==r[j+p];p++);
}
int main()
{
    scanf("%s",s);
    n=strlen(s);
    ll sum=1ll*n*(n+1)*(n-1)/2;
    for(int i=0;i<n;i++) r[i]=s[i];
    r[n++]=0;
    build_sa();
    for(int i=0;i<n;i++)
	{
        while(top&&ht[i]<ht[S[top]]) top--;
        int j=S[top];
        f[i]=f[j]+1ll*(i-j)*ht[i]; sum-=2*f[i];
        S[++top]=i;
    }
    printf("%lld\n",sum);
	return 0;
}
```
推销个人blog [JZYshuraK](https://www.cnblogs.com/ShuraK/p/10132090.html)

---

## 作者：Memory_of_winter (赞：10)

[我的博客](https://www.cnblogs.com/Memory-of-winter/p/10161164.html)

**题目大意：**给一个长度为$n$的字符串，求：

$$\sum\limits_{1\leqslant i<j\leqslant n}|suf_i|+|suf_j|-2\times lcp(suf_i,suf_j)$$

**题解：**建一棵后缀树，这个式子就成了后缀树上所有后缀之间的距离（后缀树可以把字符串反着加入后缀自动机得到的$fail$数组而来），然后有两种做法：

1. 把$\sum\limits_{1\leqslant i<j\leqslant n}|suf_i|+|suf_j|$直接求出来
$$\sum\limits_{1\leqslant i<j\leqslant n}|suf_i|+|suf_j|$$
$$=\sum\limits_{1\leqslant i<j\leqslant n}i+j$$
$$=\dfrac{n(n+1)(n-1)} 2$$
然后对每个点考虑它作为$lca$的贡献

2. 直接考虑每条边的贡献（这种比较简单一点）



**C++ Code：**（方法一）

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define maxn 500010

namespace SAM {
#define N (maxn << 1)
	int head[N], cnt;
	struct Edge {
		int to, nxt;
	} e[N];
	inline void addedge(int a, int b) {
		e[++cnt] = (Edge) {b, head[a]}; head[a] = cnt;
	}

	int R[N], fail[N], nxt[N][26];
	int lst = 1, idx = 1;
	int sz[N];
	void append(char __ch) {
		int ch = __ch - 'a';
		int p = lst, np = lst = ++idx;
		R[np] = R[p] + 1; sz[np] = 1;
		for (; p && !nxt[p][ch]; p = fail[p]) nxt[p][ch] = np;
		if (!p) fail[np] = 1;
		else {
			int q = nxt[p][ch];
			if (R[q] == R[p] + 1) fail[np] = q;
			else {
				int nq = ++idx;
				std::copy(nxt[q], nxt[q] + 26, nxt[nq]);
				fail[nq] = fail[q], R[nq] = R[p] + 1, fail[np] = fail[q] = nq;
				for (; p && nxt[p][ch] == q; p = fail[p]) nxt[p][ch] = nq;
			}
		}
	}

	long long ans;
	void dfs(int u) {
		long long tmp = 0;
		for (int i = head[u]; i; i = e[i].nxt) {
			int v = e[i].to;
			dfs(v);
			tmp += static_cast<long long> (sz[u]) * sz[v];
			sz[u] += sz[v];
		}
		ans += 2 * tmp * R[u];
	}
	long long work() {
		for (int i = 2; i <= idx; i++) addedge(fail[i], i);
		dfs(1);
		return ans;
	}
#undef N
}

int n;
char s[maxn];
long long ans;
int main() {
	scanf("%s", s + 1);
	n = strlen(s + 1);
	for (int i = n; i; i--) SAM::append(s[i]);
	ans = static_cast<long long> (n - 1) * n * (n + 1) / 2;
	ans -= SAM::work();
	printf("%lld\n", ans);
	return 0;
}

```



**C++ Code：**（方法二）

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define maxn 500010

long long ans;
int n;
namespace SAM {
#define N (maxn << 1)
	int head[N], cnt;
	struct Edge {
		int to, nxt;
	} e[N];
	inline void addedge(int a, int b) {
		e[++cnt] = (Edge) {b, head[a]}; head[a] = cnt;
	}

	int R[N], fail[N], nxt[N][26];
	int lst = 1, idx = 1;
	int sz[N];
	void append(char __ch) {
		int ch = __ch - 'a';
		int p = lst, np = lst = ++idx;
		R[np] = R[p] + 1; sz[np] = 1;
		for (; p && !nxt[p][ch]; p = fail[p]) nxt[p][ch] = np;
		if (!p) fail[np] = 1;
		else {
			int q = nxt[p][ch];
			if (R[q] == R[p] + 1) fail[np] = q;
			else {
				int nq = ++idx;
				std::copy(nxt[q], nxt[q] + 26, nxt[nq]);
				fail[nq] = fail[q], R[nq] = R[p] + 1, fail[np] = fail[q] = nq;
				for (; p && nxt[p][ch] == q; p = fail[p]) nxt[p][ch] = nq;
			}
		}
	}

	void dfs(int u) {
		for (int i = head[u]; i; i = e[i].nxt) {
			int v = e[i].to;
			dfs(v);
			sz[u] += sz[v];
			ans += static_cast<long long> (n - sz[v]) * (sz[v]) * (R[v] - R[u]);
		}
	}
	void work() {
		for (int i = 2; i <= idx; i++) addedge(fail[i], i);
		dfs(1);
	}
#undef N
}

char s[maxn];
int main() {
	scanf("%s", s + 1);
	n = strlen(s + 1);
	for (int i = n; i; i--) SAM::append(s[i]);
	SAM::work();
	printf("%lld\n", ans);
	return 0;
}

```



---

## 作者：maomao9173 (赞：8)

#### [题目链接 $Click$  $Here$](https://www.luogu.org/problemnew/show/P4248)

神仙题。或者可能我太菜了没见过后缀数组的骚操作，然后就被秀了一脸$hhhhh$

$$\sum\limits_{1<=i < j <= n} len(T_i) + len(T_j) - 2 * lcp (T_i, T_j)$$

这个式子我们显然可以把前面拆出来当常数算（${(n - 1) * n * (n + 1) }/ 2$），剩下的就是怎么计算每个区间的$lcp$之和了。

这个问题，我们转化成后缀数组的$height$来进行计算。仔细思考会发现，原字符串的每对$i$和$j$事实上和$height$数组的每一段区间$[rk[i], rk[j]]$一一对应。至此，我们的问题又转化成了求$height$数组上的每一个区间的最小值之和。

暴力求显然是$O(N^2)$的，承受不住。根据$lcp$具有可合并性$ min(lcp (T_i,T_ j), lcp (T_{j + 1}, T_{k})) = lcp (T_i, T_k)$，而$height$数组又代表了$lcp(T_i, T_{sa[rk[i ] - 1]})$，那么我们就可以这么做：

- 设$dp[i]$为$height$数组中前缀$i$的每一个后缀贡献出的答案。
- 对于任意$i > p$，当$height[i] >= height[p]$时，我们可以在所有$height[p]$统治的答案里，在后面缀上一个$[p-1,i]$的区间，所以可以认为是：前缀$i$的贡献中，还要包含一个前缀$p$的总贡献。
- 所以只要计算最近的一个$p$就可以囊括$[1,p]$内的所有答案，维护最近的小于$height[i]$的$p$的位置即可。
- 所以有$f[i] = f[p] + (i - p) * height[i];$
- 如果$i$的前面不存在$p$，满足$height[p] <= height[i]$，那么前缀$[1,i]$的所有后缀$height$的最小值都是$height[i]$（被$i$统治），即贡献为$i * height[i]$。

为了维护前一个比$height[i]$小的$height$值的相关信息，我们需要开一个递增的单调栈，遍历到$i$时弹出所有$height$值小于$height[i]$的元素，结束时再插入该$height$。



```cpp
#include <bits/stdc++.h>
using namespace std;

#define LL long long
const int N = 500010;

char s[N];
int n, m = 255, sa[N], tp[N];
int rk[N], _rk[N], bin[N], height[N];

void base_sort () {
	for (int i = 0; i <= m; ++i) bin[i] = 0;
	for (int i = 1; i <= n; ++i) bin[rk[tp[i]]]++;
	for (int i = 1; i <= m; ++i) bin[i] += bin[i - 1];
	for (int i = n; i >= 1; --i) sa[bin[rk[tp[i]]]--] = tp[i];
}

void suffix_sort () {
	for (int i = 1; i <= n; ++i) {
		tp[i] = i;
		rk[i] = s[i - 1];
	}
	base_sort ();
	for (int w = 1; w <= n; w <<= 1) {
		int cnt = 0;
		for (int i = n - w + 1; i <= n; ++i) {
			tp[++cnt] = i;
		}
		for (int i = 1; i <= n; ++i) {
			if (sa[i] > w) {
				tp[++cnt] = sa[i] - w;
			}
		}
		base_sort ();
		memcpy (_rk, rk, sizeof (rk));
		rk[sa[1]] = cnt = 1;
		for (int i = 2; i <= n; ++i) {
			rk[sa[i]] = _rk[sa[i]] == _rk[sa[i - 1]] && _rk[sa[i] + w] == _rk[sa[i - 1] + w] ? cnt : ++cnt;
		}
		if (cnt == n) break;
		m = cnt;
	}
	// printf ("sa : ");for (int i = 1; i <= n; ++i) printf ("%d ", sa[i]); printf ("\n");
}

void get_height () {
	int  k = 0;
	for (int i = 1; i <= n; ++i) {
		if (k) k--;
		int j = sa[rk[i] - 1];
		while (s[i + k - 1] == s[j + k - 1]) ++k;
		height[rk[i]] = k; 
	}
	// printf ("height : ");
	// for (int i = 1; i <= n; ++i) {
	// 	printf ("%d ", height[i]);
	// }
	// printf ("\n");
}

struct node {
	int pos, val;
	node (int ppos = 0, int vval = 0) {pos = ppos, val = vval;}
};

node sta[N]; int top;
LL f[N];

int main () {
	scanf ("%s", s);
	n = strlen (s);
	suffix_sort ();
	get_height ();
	for (int i = 1; i <= n; ++i) {
		while (top > 0 && sta[top].val > height[i]) --top;
		//使sta[top].val <= height[i];
		if (top > 0) {
			int p = sta[top].pos; //p记录控制范围
			f[i] = f[p] + (i - p) * height[i];
		} else {
			f[i] = i * height[i];
		}
		sta[++top] = node (i, height[i]);
	}
	LL ans = 1LL * (n - 1) * n * (n + 1) / 2;
	for (int i = 1; i <= n; ++i) {
		ans -= 2 * f[i];
	}
	cout << ans << endl;
} 

```



---

## 作者：Milky_Way (赞：7)

其实不用那么麻烦，计算出 _sa_ 和 _height_ 后，用一个 _stack_ 就解决了。

对于每一个 _height[ i ]_ ，若 _height[ i - 1 ]_ <= _height[ i ]_ ，那么 _height[ i - 1 ]_ 能取到的值 _height[ i ]_ 都能取到；若 _height[ i - 1 ]_ > _height[ i ]_ ，这部分的 _LCP_ 长度就是 _height[ i ]_。

用一个栈维护前面距 _i_ 最近且小于等于 _height[ i ]_ 的元素，记为 _p_ ，则转移方程为：

```
	f[i] = f[p] + (i - p) * height[i];
```

------------

```
#include <cstdio>
#include <string>
#include <stack>
#include <cstring>

const int N = 500010;
int n, m = 130, x[N], y[N], c[N], sa[N], rank[N], height[N];
char s[N];

void get_sa() {
	for (int i = 0; i < m; ++ i) c[i] = 0;
	for (int i = 0; i < n; ++ i) ++c[x[i] = s[i]];
	for (int i = 1; i < m; ++ i) c[i] += c[i-1];
	for (int i = n - 1; i >= 0; -- i) sa[--c[x[i]]] = i;
	for (int k = 1; k <= n; k <<= 1) {
		int p = 0;
		for (int i = n - k; i < n; ++ i) y[p++] = i;
		for (int i = 0; i < n; ++ i) if (sa[i] >= k) y[p++] = sa[i] - k;
		for (int i = 0; i < m; ++ i) c[i] = 0;
		for (int i = 0; i < n; ++ i) ++c[x[y[i]]];
		for (int i = 1; i < m; ++ i) c[i] += c[i-1];
		for (int i = n - 1; i >= 0; -- i) sa[--c[x[y[i]]]] = y[i];
		for (int i = 0; i < n; ++ i) x[i] ^= y[i], y[i] ^= x[i], x[i] ^= y[i];
		p = 1, x[sa[0]] = 0;
		for (int i = 1; i < n; ++ i)
			x[sa[i]] = y[sa[i]] == y[sa[i-1]] && (sa[i]+k<n ? y[sa[i]+k] : -1) == (sa[i-1]+k<n ? y[sa[i-1]+k] : -1) ? p-1 : p++;
		if (p >= n) break;
		m = p;
	}
}
void get_height() {
	int k = 0;
	for (int i = 0; i < n; ++ i) rank[sa[i]] = i;
	for (int i = 0; i < n; ++ i) {
		if (!rank[i]) continue;
		if (k) --k;
		int j = sa[rank[i]-1];
		while (j+k < n && i+k < n && s[j+k] == s[i+k]) ++k;
		height[rank[i]] = k;
	}
}

struct Pair {
	int val, pos;
};
std::stack<Pair> sta;
long long f[N];

int main() {
	scanf("%s", s), n = strlen(s);
	get_sa(), get_height();
	long long res = 0; int pos = 0;
	for (int i = 0; i < n; ++ i) {
		int p = pos;
		while (!sta.empty() && sta.top().val > height[i]) sta.pop();
		if (!sta.empty()) p = sta.top().pos;
		f[i] = f[p] + (i - p) * height[i], res += f[i];
		if (height[i] == 0) pos = i;
		sta.push((Pair){height[i], i});
	}
	printf("%lld\n", (1LL) * (n - 1) * n * (n + 1) / 2 - res * 2);
	return 0;
}
```

---

## 作者：Jμdge (赞：6)

板子题，争取一遍过（好吧没那么裸？）

代码倒是挺好打的，关键就是看出题目让你求的东西了

我们可以考虑题目中就是要求   s  任意两个子串的长度减去 lcp 长度的**两倍**


这个玩意儿...好像很像求树上 dis ？

然后我们考虑后缀自动机中的 parent 树恰好就是两个子串的 lca 为他们的 lcp 的...并且一个节点到根的 dis 就是它的长度...

慢着！错了吧？两个子串在 parent 树上的 lca 是他们的 lcs 啊！

...

我们再考虑一下（好像第一篇题解说的是错的？）

我们考虑到： **任意两个子串的 lcp 长度之和  等于任意两个子串 lcs 的后缀长度之和**

（所以说可以转化一下问题，变得更加简便）

于是问题转化为了任意两个子串在 parent 树上的距离之和

答案也就是：

$$ANS=\sum_{u=1}^{cnt} \sum_{v∈son_u} siz[v]·(n-siz[v])·(len[v]-len[u])$$

（其中 n 为原串的长度， cnt 为 SAM 中的节点数）

这里为什么用 n 来减我还是感觉有点玄学（大概可以理解原串 n 个点，所以 n 个点有 siz ，我们算的是这些点之间的 dis ？ ）

那么通常说的是树形 dp 其实打是可以打的，但是可以转化为 SA 的模型，逆序求一下后缀排序后的点对应边的贡献就好了


```
//by Judge
#include<map>
#include<cstdio>
#include<cstring>
#include<iostream>
#define fp(i,a,b) for(int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(int i=(a),I=(b)-1;i>I;--i)
#define ll long long
using namespace std;
const int M=1e6+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline void reads(string& s){ char c=getchar();
	for(;!isalpha(c);c=getchar());
	for(;isalpha(c);c=getchar()) s+=c;
} int n; string s; ll ans;
struct SAM{ int las,cnt; SAM(){las=cnt=1;}
	map<char,int> to[M]; arr c,sa,fa,len,siz;
	inline void insert(char c){ int p=las,np=++cnt;
		las=np,len[np]=len[p]+1,siz[np]=1;
		for(;p&&!to[p].count(c);p=fa[p]) to[p][c]=np;
		if(!p) return fa[np]=1,void(); int q=to[p][c];
		if(len[q]==len[p]+1) return fa[np]=q,void();
		int nq=++cnt; len[nq]=len[p]+1,fa[nq]=fa[q],fa[q]=fa[np]=nq;
		to[nq]=to[q]; for(;to[p][c]==q;p=fa[p]) to[p][c]=nq;
	}
	inline void calc(){ fp(i,1,cnt) ++c[len[i]];
		fp(i,2,cnt) c[i]+=c[i-1]; fp(i,1,cnt) sa[c[len[i]]--]=i;
		fd(i,cnt,1){ int p=sa[i]; siz[fa[p]]+=siz[p];
			ans+=1ll*siz[p]*(n-siz[p])*(len[p]-len[fa[p]]);
		}
	}
}p;
int main(){ reads(s),n=s.length();
	fd(i,n-1,0) p.insert(s[i]);
	return p.calc(),!printf("%lld\n",ans);
}
```



---

## 作者：Styx (赞：6)

一个用SAM但是不翻转建后缀树的蠢办法

首先所有后缀都在最后一个np节点，然后他们都是从1号点出发沿一些字符边到达这个点的，所以下文称1号点为根节点，我们思考一下什么时候会产生lcp，显然是当他们从根节点开始一直跳相同节点的时候，所以思路就是先找出每个节点被几个后缀经过，这显然把边反转倒着找就可以了，然后他会被出现次数sz个串经过。

出现次数等于parent树子树中np类节点的个数，这跑个dfs就好了，一个相同前缀产生的贡献是sz*(sz-1)/2

然后思考一个点可能代表多个子串，但是他们的出现次数都是相同的，所以单个点的贡献为上面的单个贡献再乘上一个有几个子串

子串的个数为parent树父亲节点的最大长度减去该节点的最大长度

这样子在从根开始dfs，如果经过某个点只有一个后缀经过，就说明lcp结束了，就不用再搜该点了。

上面就求出了lcp的和

至于前面那个式子，只需要打个表找个规律发现是(n-1)*n*(n+1)/2就可以了

虽然常数大点但是还是后缀自动机复杂度的

代码因为没用链式前向星存边所以不开o2会t，但还是贴一下吧

```cpp
#include<bits/stdc++.h>
#define N 1000010
using namespace std;

int n;
int gg=0;

struct SAM
{
	struct point
	{
		int son[26],fa,len,mx;
	}t[N];
	
	int cnt=1,last=1;
	int f[N],sz[N];
	bool vis[N];
	vector<int> g[N],e[N];
	long long lcp=0ll; 
	
	void add(int c)
	{
		int p=last;
		int np=++cnt;
		t[np].len=t[p].len+1;
		sz[np]=1;
		while(p&&(!t[p].son[c]))
		{
			t[p].son[c]=np;
			p=t[p].fa;
		}
		if(!p) t[np].fa=1;
		else
		{
			int q=t[p].son[c],nq;
			if(t[p].len+1==t[q].len)
			{
				t[np].fa=q;
			}
			else
			{
				nq=++cnt;
				t[nq]=t[q];
				t[nq].len=t[p].len+1;
				t[q].fa=t[np].fa=nq;
				while(p&&(t[p].son[c]==q))
				{
					t[p].son[c]=nq;
					p=t[p].fa; 
				}
			}
		}
		last=np;
	}
	
	void dfs(int now)
	{
		t[now].mx=t[now].len-t[t[now].fa].len;
		for(int i=0;i<26;i++)
		{
			if(t[now].son[i]) e[t[now].son[i]].push_back(now);
		}
		for(int i=0;i<g[now].size();i++)
		{
			dfs(g[now][i]);
			sz[now]+=sz[g[now][i]];
		}
	}
	
	void dfs1(int now)
	{
		vis[now]=1;
		for(int i=0;i<e[now].size();i++)
		{
			f[e[now][i]]++;
			if(!vis[e[now][i]])
			{
				dfs1(e[now][i]);
			}
		}
	}
	
	void dfs3(int now)
	{
		vis[now]=1;
		if(f[now]) lcp+=t[now].mx*(1ll*sz[now]*(sz[now]-1)/2);
		for(int i=0;i<26;i++)
		{
			if(f[t[now].son[i]]&&sz[t[now].son[i]]>1&&(!vis[t[now].son[i]]))
			{
				dfs3(t[now].son[i]);
			}
		}
	}
	
	void solve()
	{
		for(int i=1;i<=cnt;i++) g[t[i].fa].push_back(i);
		dfs(1);
		sz[1]=0;
		memset(vis,0,sizeof(vis));
		dfs1(last);
		memset(vis,0,sizeof(vis)); 
		dfs3(1);
		long long len=1ll*n*(n-1)*(n+1)/2;
		printf("%lld\n",len-2*lcp);
	}
	
}sam;

char s[500050];

int main()
{
	scanf("%s",s);
	n=strlen(s);
	for(int i=0;i<n;i++)
	{
		sam.add(s[i]-'a');
	}
	sam.solve(); 
} 
```

---

## 作者：何俞均 (赞：5)

广告：食用[$blog$](https://www.cnblogs.com/heyujun/p/10305797.html)体验更佳
## 题面
给定字符串$S$,令$T_i$表示以它从第$i$个字符开始的后缀。
求

$$\sum_{1\leq i<j\leq n}len(T_i)+len(T_j)-2*lcp(T_i,T_j)$$

其中$len(a)$表示串$a$的长度，$lcp(a,b)$表示串$a,b$的最长公共前缀
## 题解
把这个式子看作两边分开求：
### $Part1:$

$$\sum_{1\leq i<j\leq n}len(T_i)+len(T_j)$$

$$\Leftrightarrow\sum_{i=1}^{n-1}\sum_{j=i+1}^ni+j$$

$$=\sum_{i=1}^{n-1}i*(n-i)+\frac{(i+1+n)*(n-i)}2$$

其实现在你就可以$O(n)$地求了，但是因为我出(kan)于(le)美(ti)观(jie)

发现它其实可以化成这样：
$$\frac {(n-1)*n*(n+1)}2$$
### $Part2:$
一看到后缀当然是$sa$啦

由后缀数组的性质，排名为分别为$i,j$的后缀，$lcp_{i,j}=\min\limits_{k=i+1}^jheight_k$

我们将所有高度数组排成一排,

假设中间的第$i$个数是$l-r$中最小的

则它的贡献就是$(i-l+1)*(r-i+1)$

我们处理出来对$i$所有的$l,r$是不是就做出来了呢

这不就是一个单调栈的经典应用吗？

而这个题目中因为一些细节问题我的$l$表示小于$i$的第一个，$r$表示小于等于$i$的第一个

详见代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring> 
#include <cmath> 
#include <algorithm>
using namespace std; 
inline int gi() {
	register int data = 0, w = 1;
	register char ch = 0;
	while (!isdigit(ch) && ch != '-') ch = getchar(); 
	if (ch == '-') w = -1, ch = getchar();
	while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar();
	return w * data; 
}
const int MAX_N = 5e5 + 5; 
int N; char a[MAX_N]; 
int sa[MAX_N], lcp[MAX_N], rnk[MAX_N]; 
void GetSA() { 
#define cmp(i, j, k) (y[i] == y[j] && y[i + k] == y[j + k]) 
	static int x[MAX_N], y[MAX_N], bln[MAX_N]; 
	int M = 122; 
	for (int i = 1; i <= N; i++) bln[x[i] = a[i]]++; 
	for (int i = 1; i <= M; i++) bln[i] += bln[i - 1]; 
	for (int i = N; i >= 1; i--) sa[bln[x[i]]--] = i; 
	for (int k = 1; k <= N; k <<= 1) { 
		int p = 0; 
		for (int i = 0; i <= M; i++) y[i] = 0; 
		for (int i = N - k + 1; i <= N; i++) y[++p] = i; 
		for (int i = 1; i <= N; i++) if (sa[i] > k) y[++p] = sa[i] - k; 
		for (int i = 0; i <= M; i++) bln[i] = 0; 
		for (int i = 1; i <= N; i++) bln[x[y[i]]]++; 
		for (int i = 1; i <= M; i++) bln[i] += bln[i - 1]; 
		for (int i = N; i >= 1; i--) sa[bln[x[y[i]]]--] = y[i]; 
		swap(x, y); x[sa[1]] = p = 1; 
		for (int i = 2; i <= N; i++) x[sa[i]] = cmp(sa[i], sa[i - 1], k) ? p : ++p; 
		if (p >= N) break; 
		M = p; 
	} 
}
void GetLcp() { 
	for (int i = 1; i <= N; i++) rnk[sa[i]] = i; 
	for (int i = 1, j = 0; i <= N; i++) { 
		if (j) --j; 
		while (a[i + j] == a[sa[rnk[i] - 1] + j]) ++j; 
		lcp[rnk[i]] = j; 
	} 
}
typedef long long ll; 
int lp[MAX_N], rp[MAX_N], stk[MAX_N], top; 
int main () {
	scanf("%s", a + 1); N = strlen(a + 1); 
	GetSA(); GetLcp(); 
	ll ans = 0; 
	//for (int i = 1; i < N; i++) ans += 1ll * i * (N - i) + 1ll * (i + 1 + N) * (N - i) / 2ll; 
	ans = 1ll * N * (N + 1) * (N - 1) / 2ll; 
	stk[0] = 1; 
	for (int i = 2; i <= N; i++) {
		while (top > 0 && lcp[stk[top]] >= lcp[i]) --top; 
		lp[i] = i - stk[top], stk[++top] = i; 
	} 
	top = 0, stk[0] = N + 1; 
	for (int i = N; i >= 2; i--) { 
		while (top > 0 && lcp[stk[top]] > lcp[i]) --top; 
		rp[i] = stk[top] - i, stk[++top] = i; 
	}
	for (int i = 2; i <= N; i++) ans -= 2ll * lcp[i] * lp[i] * rp[i]; 
	printf("%lld\n", ans); 
	return 0; 
} 
```

---

## 作者：asuldb (赞：3)

这个题一看就是为后缀家族设计的

我们看到我们要求的这个柿子

$$\sum_{i=1}^n\sum_{j=i+1}^nT_i+T_j-2\times lcp(T_i,T_j)$$

显然的是前面的那些东西是个定值

就是保证每一个长度都会被其他长度算到，也就是算到$n-1$次

于是把前面那些东西拿出来就是

$$\frac{(n+1)(n-1)n}{2}$$

之后再看后面那些东西

所有后缀的$lcp$的长度？

先来考虑一下如何求两个后缀的$lcp$

~~哈希+二分啊~~$SA$啊

对于后缀$i,j$，他们的$lcp$长度就是$min(heighht[rk[i]+1]...height[rk[j]])$

于是现在的问题转化为求出$height$数组所有子区间的最小值的和

我们可以考虑一个动态往序列末尾加数的过程

也就是我们往末尾加一个数都会和之前所有的数形成一个新的区间

考虑快速算出这些区间的最小值的和

我们可以对每一个数存储一个$a_i$，表示$i$到当前序列末尾的最小值是多少

我们每次加入一个数可以对更新一下所有的$a_i$，把所有比当前加入的数大的$a_i$变成当前数就好了

这不就$T$了吗

我们发现我们只需要求出所有$a_i$的和，并不需要关心这个$i$来自哪里，于是我们可以把相等的$a_i$放在一起计算，也就是每次新加入一个数就暴力扫一遍把那些比当前加入数大的合并到一个$a_i$里

看起来复杂度并不科学，但是最坏情况下就相当于是一个线段树的复杂度了，$O(n)$的，跑的还挺快的

代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define re register
#define maxn 500005
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define pt putchar(1)
inline int read()
{
	char c=getchar();int x=0;
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
int n,m,top;
LL ans=0,sum=0;
char S[maxn];
int tax[maxn],sa[maxn],rk[maxn],tp[maxn],height[maxn];
int L[maxn],R[maxn],st[maxn];
int a[maxn],cnt[maxn];
LL pre[maxn];
inline void qsort()
{
	for(re int i=0;i<=m;i++) tax[i]=0;
	for(re int i=1;i<=n;i++) tax[rk[i]]++;
	for(re int i=1;i<=m;i++) tax[i]+=tax[i-1];
	for(re int i=n;i;--i) sa[tax[rk[tp[i]]]--]=tp[i];
}
int main()
{
	scanf("%s",S+1);
	n=strlen(S+1);
	m=75;
	for(re int i=1;i<=n;i++) rk[i]=S[i]-'a'+1,tp[i]=i;
	qsort();
	for(re int w=1,p=0;p<n;m=p,w<<=1)
	{
		p=0;
		for(re int i=1;i<=w;i++) tp[++p]=n-w+i;
		for(re int i=1;i<=n;i++) if(sa[i]>w) tp[++p]=sa[i]-w;
		qsort();
		for(re int i=1;i<=n;i++) std::swap(tp[i],rk[i]);
		rk[sa[1]]=p=1;
		for(re int i=2;i<=n;i++) rk[sa[i]]=(tp[sa[i-1]]==tp[sa[i]]&&tp[sa[i-1]+w]==tp[sa[i]+w])?p:++p;
	}
	int k=0;
	for(re int i=1;i<=n;i++)
	{
		if(k) --k;
		int j=sa[rk[i]-1];
		while(S[i+k]==S[j+k]) ++k;
		height[rk[i]]=k;
	}
	ans+=height[2];
	a[1]=ans;cnt[1]=1,sum=ans;
	top=1;
	for(re int i=3;i<=n;i++)  
	{
		int now=1;
		while(top&&height[i]<=a[top]) 
			now+=cnt[top],sum-=a[top]*cnt[top],top--;
		cnt[++top]=now;
		a[top]=height[i];
		sum+=cnt[top]*a[top];
		ans+=sum;
	}
	printf("%lld\n",(LL)(n-1)*(LL)(n+1)*(LL)n/2ll-2ll*ans);
	return 0;
}
```

---

## 作者：花里心爱 (赞：2)

[题目链接](https://www.luogu.org/problemnew/show/P4248)

题意让我们求出

$\displaystyle \sum_{1\leqslant i<j\leqslant n}\text{len}(T_i)+\text{len}(T_j)-2\times\text{lcp}(T_i,T_j)$

其中，$\displaystyle \sum_{1\leqslant i<j\leqslant n}\text{len}(T_i)+\text{len}(T_j)$是一个定值。考虑每一个无序对$(i, j)$被算了一次，那么上式等于$\displaystyle (n-1)\sum_{i=1}^{n}i = \frac{(n-1)n(n+1)}{2}$。

然后我们考虑$\displaystyle \sum_{1\leqslant i<j\leqslant n}\text{lcp}(T_i,T_j)$怎么求。

因为这里的$T$是后缀，我们首先求出后缀数组。然后我们考虑枚举$\text{lcp}$，看有多少对$(T_i,T_j)$满足$\text{lcp}(T_i,T_j)$为我们当前枚举的值。

注意到$\text{lcp}(T_i,T_j) = \min_{i<k\leq j}\{height[k]\}$，我们考虑以下做法。

考虑倒序枚举$\text{lcp}$。设想我们有一些连续的区间表示每个后缀，每个连续区间的含义是：这个区间中所有的$height$均大于我们当前枚举到的$\text{lcp}$。设每个区间的大小为$size[i]$。初始时它们分别是一个连通块。这样就可以在合并区间的同时更新答案。

然后我们按$height[i]$从大到小的顺序来枚举$i$。对于枚举到的$i$，我们可以选出$size[i-1] \times size[i]$个不同的组合，使这些组合的$\text{lcp}$均为我们当前枚举的值（$height[i]$）。于是它们对答案的贡献为$height[i] \times size[i-1] \times size[i]$。

然后合并区间可以用并查集实现。

然后我们算出它们的和为$sum$，最后答案为$\displaystyle \frac{(n-1)n(n+1)}{2} - 2 \times sum$

实际上，利用同样的思路还可以做[\[NOI2015\]品酒大会](https://www.luogu.org/problemnew/show/P2178)。

下面放代码：
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define maxn 500005
typedef long long ll;

int n;
char s[maxn];
int sa[maxn], rk[maxn], tp[maxn], tax[maxn];
int h[maxn];
int m;

inline void rsort() {
	for(int i = 1; i <= m; ++i) tax[i] = 0;
	for(int i = 1; i <= n; ++i) ++tax[rk[i]];
	for(int i = 1; i <= m; ++i) tax[i] += tax[i-1];
	for(int i = n; i >= 1; --i) sa[tax[rk[tp[i]]]--] = tp[i];
}

void getsa() {
	m = 127;
	for(int i = 1; i <= n; ++i) rk[i] = s[i], tp[i] = i;
	rsort();
	for(int w = 1, p = 0; p < n && w <= n; m = p, w <<= 1) {
		p = 0;
		for(int i = n-w+1; i <= n; ++i) tp[++p] = i;
		for(int i = 1; i <= n; ++i)
			if(sa[i] > w) tp[++p] = sa[i]-w;
		rsort();
		std::swap(rk, tp);
		rk[sa[1]] = p = 1;
		for(int i = 2; i <= n; ++i)
			rk[sa[i]] = (tp[sa[i]] == tp[sa[i-1]] && (sa[i]+w > n ? -1 : tp[sa[i]+w]) == (sa[i-1]+w > n ? -1 : tp[sa[i-1]+w])) ? p : ++p;
	}
}

void geth() {
	int j, k = 0;
	for(int i = 1; i <= n; ++i) {
		if(k) --k;
		j = sa[rk[i]-1];
		while(i+k <= n && j+k <= n && s[i+k] == s[j+k]) ++k;
		h[rk[i]] = k;
	}
}

// 以上是sa板子

int fa[maxn], sz[maxn];

int getf(int x) {
	return x == fa[x] ? x : fa[x] = getf(fa[x]);
}

ll merge(int x, int y) {
	x = getf(x), y = getf(y);
	if(x == y) return 0;
	if(sz[x] > sz[y]) std::swap(x, y);
	ll res = 1ll*sz[y]*sz[x];
	fa[x] = y, sz[y] += sz[x];
	return res;
}

// 以上是并查集板子

int tn[maxn], g[maxn];
ll ans;

int main() {
	scanf("%s", s+1);
	n = strlen(s+1);
	getsa(), geth();
	for(int i = 1; i <= n; ++i) fa[i] = i, sz[i] = 1;
	for(int i = 1; i <= n; ++i) ++tn[h[i]];
	for(int i = 1; i <= n; ++i) tn[i] += tn[i-1];
	for(int i = n; i >= 1; --i) g[tn[h[i]]--] = i;
	// 按h[i]为关键字排序，排序的结果为g[i]
	for(int i = n; i >= 1; --i) ans += h[g[i]]*merge(g[i], g[i]-1); // 统计答案
	printf("%lld", 1ll*(n-1)*n*(n+1)/2-2ll*ans);
	return 0;
}
```

---

## 作者：斯茂 (赞：1)

# 这里给出一种不是很优秀的做法

首先SA是没得说的

有引理：height数组上的一段的最小值为原串的两个后缀的lcp

然后观察要求的式子，前两项是简单的数学推导，第三项等价于h数组所有区间min之和

这个东西怎么做呢？

一种方法是暴力递归，每次找出最小值，再往两边计算

这么做在随机下是O(nlogn)的，但显然能被卡成O(n^2)，卡的原理和卡快排差不多，只有65分

注意到有一种数据结构叫做笛卡尔树，可以用单调栈方便地维护这个东西

这个东西不想写怎么办

用最暴力的方式思考，我们构建出st表，并且记一下最小值出现的位置，然后用之前的思想，可以保证是O(nlogn)的

代码给出的是暴力递归的，但st表应该也不难写，主要代码量是在SA上

```
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
int n, m, sa[500005], rk[500005], tp[500005], tax[500005], h[500005];
long long ans;
char s[500005];
void Sort()
{
	for(int i = 0; i <= m; i++) tax[i] = 0;
	for(int i = 1; i <= n; i++) tax[rk[i]]++;
	for(int i = 1; i <= m; i++) tax[i] += tax[i - 1];
	for(int i = n; i >= 1; i--) sa[tax[rk[tp[i]]]--] = tp[i];
}
void SA()
{
	int i, j, p;
	for(i = 1; i <= n; i++) rk[i] = s[i], tp[i] = i;
	m = 10000; Sort();
	for(i = 1; p < n; m = p, i <<= 1)
	{
		p = 0;
		for(j = 1; j <= i; j++) tp[++p] = n - i + j;
		for(j = 1; j <= n; j++) if(sa[j] > i) tp[++p] = sa[j] - i;
		Sort(); swap(rk, tp);
		p = rk[sa[1]] = 1;
		for(j = 2; j <= n; j++)
			rk[sa[j]] = (tp[sa[j]] == tp[sa[j - 1]] && tp[sa[j] + i] == tp[sa[j - 1] + i]) ? p : ++p;
	}
	p = 0;
	for(i = 1; i <= n; i++)
	{
		if(p) p--;
		while(s[i + p] == s[sa[rk[i] - 1] + p]) p++;
		h[rk[i]] = p;
	}
}
void dfs(int l, int r)
{
	if(l > r) return ;
	int i, mn = 1e9, p;
	for(i = l; i <= r; i++) if(h[i] < mn) mn = h[i], p = i;
	ans -= 2ll * mn * (p - l + 1) * (r - p + 1);
	dfs(l, p - 1); dfs(p + 1, r);
}
void work()
{
	for(int i = 1; i <= n; i++) ans += 3ll * i * (i - 1) / 2;
}
int main(int argc, char **argv)
{
	scanf("%s", s + 1); n = strlen(s + 1);
	SA(); dfs(1, n); work();
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P4248)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;应该是后缀数组的模板题。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先求出$sa$和$height$数组。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后考虑，对于所有后缀扫一遍，然后中途求出答案。当我们扫描到后缀$i$（也就是$s[sa[i]...]$，后缀已经按照字典序排好了），我们只需要求出：  
$$\sum_{1\le j<i}len(T_j)+len(T_i)-2\times lcp(T_i,T_j)$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次就把答案累加起来就可以了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;变形：  
$$=(i-1)\times len(T_i)+\sum_{1\le j<i}len(T_j)-2\sum_{1\le j<i}lcp(T_i,T_j)$$
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑如何快速求出以上的东西。显然，最重要的是求出后面的那一堆东西。根据$lcp$的定理（$lcp(T_i,T_j)=\min_{i<k\le j}\{height[k]\}$，后缀已经按照字典序排列好并且$i<j$），我们可以想到用一个单调栈来维护一个递增的$height$的序列，另外用一个变量来存计算出来的$2\sum_{1\le j<i}lcp(T_i,T_j)$，这样就可以成功地维护出来这一堆东西了。其他部分维护起来比较简单。时间是$O(n\log_2n)$，也就是建后缀数组的时间。~~大佬们可以尝试DC3或者SA-IS......就变成O(n)了......~~  
# 代码
```cpp
#include <cstdio>
#include <cstring>

typedef long long LL;

const int MAXN = 500005, MAXSIZ = 30;

template<typename _T>
void read( _T &x )
{
	x = 0; char s = getchar();int f = 1;
	while( s < '0' || '9' < s ) { f = 1; if( s == '-' ) f = -1; s = getchar(); }
	while( '0' <= s && s <= '9' ) { x = ( x << 3 ) + ( x << 1 ) + s - '0', s = getchar(); }
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ) { putchar( '-' ), x = -x; }
	if( 9 < x ) { write( x / 10 ); }
	putchar( x % 10 + '0' );
}

int sta[MAXN], top;
int height[MAXN];
int sa[MAXN << 2], rnk[MAXN << 2], cnt[MAXN], tmp[MAXN];
char s[MAXN];
int N;

bool cmp( const int a, const int b, const int st ) { return rnk[a] == rnk[b] && rnk[a + st] == rnk[b + st]; }

int main()
{
	scanf( "%s", s + 1 ); N = strlen( s + 1 );
	for( int i = 1 ; i <= N ; i ++ ) cnt[s[i] - 'a' + 1] = 1;
	for( int i = 1 ; i <= 26 ; i ++ ) cnt[i] += cnt[i - 1];
	for( int i = 1 ; i <= N ; i ++ ) rnk[i] = cnt[s[i] - 'a' + 1];
	int lst = cnt[26];
	for( int k = 1, p = 0 ; p < N ; k <<= 1, p = lst )
	{
		for( int i = 1 ; i <= N ; i ++ ) cnt[i] = 0;
		for( int i = 1 ; i <= N ; i ++ ) cnt[rnk[i + k]] ++;
		for( int i = 1 ; i <= N ; i ++ ) cnt[i] += cnt[i - 1];
		for( int i = N ; i ; i -- ) tmp[cnt[rnk[i + k]] --] = i;
		for( int i = 1 ; i <= N ; i ++ ) cnt[i] = 0;
		for( int i = 1 ; i <= N ; i ++ ) cnt[rnk[tmp[i]]] ++;
		for( int i = 1 ; i <= N ; i ++ ) cnt[i] += cnt[i - 1];
		for( int i = N ; i ; i -- ) sa[cnt[rnk[tmp[i]]] --] = tmp[i];
		lst = 0;
		for( int i = 1 ; i <= N ; i ++ )
		{
			if( ! cmp( sa[i], sa[i - 1], k ) ) lst ++;
			tmp[sa[i]] = lst;
		}
		for( int i = 1 ; i <= N ; i ++ ) rnk[i] = tmp[i];
	}
	int r = 0;
	for( int i = 1, j ; i <= N ; i ++ )
	{
		if( rnk[i] == 1 ) continue;
		if( r ) r --;
		j = sa[rnk[i] - 1];
		while( j + r <= N && i + r <= N && s[i + r] == s[j + r] ) r ++;
		height[rnk[i]] = r;
	}
	top = 0;
	LL res = 0, ps = N - sa[1] + 1, dif = 0; sta[top] = 1;
	for( int i = 2 ; i <= N ; i ++ )
	{
		while( top && height[sta[top]] >= height[i] ) 
			dif -= 1ll * height[sta[top]] * ( sta[top] - sta[top - 1] ), top --;
		dif += 1ll * ( i - sta[top] ) * height[i], sta[++ top] = i;
        //维护减的那一部分
		res += 1ll * ( N - sa[i] + 1 ) * ( i - 1 ) + ps - 2 * dif; 
		ps += N - sa[i] + 1;
	}
	write( res ), putchar( '\n' );
	return 0;
}
```

---


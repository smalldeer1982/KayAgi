# [SNOI2020] 字符串

## 题目描述

有两个长度为 $n$ 的由小写字母组成的字符串 $a,b$，取出他们所有长为 $k$ 的子串（各有 $n-k+1$ 个），这些子串分别组成集合 $A,B$。现在要修改 $A$ 中的串，使得 $A$ 和 $B$ 完全相同。可以任意次选择修改 $A$ 中一个串的一段后缀，花费为这段后缀的长度。总花费为每次修改花费之和，求总花费的最小值。

## 说明/提示

#### 样例说明

对于样例 $1$，所有子串为：$A = \{aab,aba,baa\}, B = \{aba, bab, aba\}$。可以看出有一对 $aba$ 是相同的，另外要把 $aab$ 改成 $aba$（花费 $2$），$baa$ 改成 $bab$（花费 $1$），总花费为 $3$。

#### 数据规模与约定

对于所有数据，$1\le k\le n\le 1.5\times 10^5$。

- 对于 $10\%$ 的数据，$n \le 11$；
- 对于另外 $20\%$ 的数据，$n \le 200$；
- 对于另外 $20\%$ 的数据，$n \le 2000$；
- 对于另外 $10\%$ 的数据，字符串的每一位在小写字母中均匀随机；
- 对于余下 $40\%$ 的数据，无特殊限制。

## 样例 #1

### 输入

```
5 3
aabaa
ababa```

### 输出

```
3```

# 题解

## 作者：panyf (赞：22)

提供一个简单的后缀数组做法。

考虑贪心地每次匹配两个 lcp 最长的子串。

求出 height 数组，和[P2178 [NOI2015] 品酒大会](https://www.luogu.com.cn/problem/P2178)一样从大到小排序，用并查集维护即可。

只需要记录当前集合还未匹配的 $a$ 串子串和 $b$ 串子串数量。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+3;
char s[N];
int sa[N],u[N],v[N],h[N],t[N],f[N],id[N],p[N],q[N];
long long ans;
int gf(int x){return f[x]==x?x:f[x]=gf(f[x]);}
void mg(int x,int y,int w){
	p[y]+=p[x],q[y]+=q[x],f[x]=y;
	if(p[y]<q[y])return ans+=w*1ll*p[y],q[y]-=p[y],p[y]=0,void();
	ans+=w*1ll*q[y],p[y]-=q[y],q[y]=0;
}//合并两个集合，pq分别表示还未匹配的a串子串和b串子串数量
int main(){
	int*rk=u,*b=v,n,n2,o,m=131,i,j,k=0,x,y;
	scanf("%d%d",&n2,&o),scanf("%s",s+1),s[n2+1]='z'+1,scanf("%s",s+n2+2),n=n2*2+1;
	for(i=1;i<=n;++i)++t[s[i]];
	for(i=1;i<=m;++i)t[i]+=t[i-1];
	for(i=n;i;--i)sa[t[rk[i]=s[i]]--]=i;
	for(i=1;k<n;i*=2,m=k){
		for(j=n-i+1,k=0,memset(t,0,m*4+4);j<=n;++j)b[++k]=j;
		for(j=1;j<=n;++j)if(++t[rk[j]],sa[j]>i)b[++k]=sa[j]-i;
		for(j=1;j<=m;++j)t[j]+=t[j-1];
		for(j=n;j;--j)sa[t[rk[b[j]]]--]=b[j];
		for(j=1,swap(rk,b),k=y=0;j<=n;++j,y=x)x=sa[j],rk[x]=b[x]==b[y]&&b[x+i]==b[y+i]?k:++k;
	}
	for(i=1,k=0;i<=n;h[rk[i++]]=k)if(rk[i]>1)for(j=sa[rk[i]-1],k=max(0,k-1);s[i+k]==s[j+k];++k);//以上为后缀数组板子
	for(i=1;i<=n;++i)if(f[i]=id[i]=i,i<=n2-o+1)p[i]=1;else if(i>n2+1&&i<=n2*2-o+2)q[i]=1;
	sort(id+2,id+n,[](int x,int y){return h[x]>h[y];});
	for(i=2;i<n;++i)mg(gf(sa[id[i]]),gf(sa[id[i]-1]),max(0,o-h[id[i]]));
	cout<<ans;
	return 0;
}
```

---

## 作者：_Ezreal (赞：17)

## $\mathsf {Solution\space to \space P6793}$

一篇混在 $SAM$ 题解里的 $SA$ 题解 $qwq$ 。

前置知识：[后缀数组](https://oi-wiki.org/string/sa/)，[求 height 数组](https://oi-wiki.org/string/sa/#height) ，$RMQ$ 。

很显然，$A$ 和 $B$ 各有 $n-k+1$ 个长为 $k$ 的子串，而题目所求即为 $A$ 中子串与 $B$ 中子串两两匹配的最小权匹配，其中两个子串匹配的权值为 $k-lcp(A_i,B_j)$ 。  

可以先把字符串 $a$ ，$b$ 中间隔一个非小写字母字符然后接在一起求 $sa$ 数组和 $height$ 数组。  

然后将 $sa[i]$ 看作从 $sa[i]$ 开始的长为 $k$ 的子串，这些子串中，一部分来自 $a$ ，一部分来自 $b$ ，一部分跨过了间隔符或者后缀长度不及 $k$ 。将这三部分分别看为 $1$ 类，$2$ 类 ，$0$ 类点，需要做的就是将 $1$ 类点与 $2$ 类点匹配，对于 $sa[l]$ 表示的子串与 $sa[r]$ 表示的子串匹配的权值即为 $k-\min\limits_{i=l+1}^{r} min(ht[i],k)$ 。  

由于 $0$ 类点不需要匹配，所以可以直接删掉 ，然后将两边的 $ht$ 合并（取最小值）就行了。  



于是将原问题转为另一个新问题 ， 有一个 $2n$ 的序列 $p$ ，其中有 $n$ 个为 $1$ 类，$n$ 个为 $2$ 类，$p[i]$ 与 $p[i+1]$ 之间有一个权值 $w_i$ ，$1$ 类点与 $2$ 类点匹配的权值为两点之间所有 $w$ 中的最小值，求最大权匹配，原题目所求即为 $(n-k+1)\times k-$ 最大权匹配。

对于这个新问题，可以用分治解决，我们找到这个序列中最小的权值 $w_i$ ，我们肯定不想让一个匹配的区间包含这个最小的权值 $w_i$，于是尽可能的让匹配的两个点在 $i$ 的同侧 ，然后 $i$ 左侧和右侧各会留下一些没有匹配完的点，将这两侧的点匹配 。具体的 ：

1. $solve(l,r)$ 表示在 $l,r$ 这些点中进行匹配，剩下来多少个点（实现时需要标识为哪类点，这篇题解代码中用正数表示 $1$ 类点，负数表示 $2$ 类点）；
2. $l==r$ 直接返回当前位置的点；
3. 否则，找到 $[l,r]$ 最小的权值 $w_{mid}$  ，查找过程需要用到 $RMQ$ ，然后调用 $solve(l,mid),solve(mid+1,r)$ ，将 $solve(l,mid)$ 返回的点与 $solve(mid+1,r)$ 返回的点匹配，同时维护最后答案 $ans$，然后返回剩下的点 。可以证明 $solve(1,2n)$ 的返回值为 $0$ ，即全部匹配。

```cpp
int solve(int l,int r){
	if(l==r) return op[l];//只有一个点 
	int mid=Query(l,r-1);//找到权值最小的 w 
	int L=solve(l,mid);//L表示左边剩下的点 
	int R=solve(mid+1,r);//R表示右边剩下的点 
	if(1ll*L*R>=0) return L+R;//同类点无法匹配，直接加起来返回 
	if(L<0&&R>0) std::swap(L,R);//下面写的是默认  L>0 R<0 ,我们只关心两侧各有多少点，不关心哪些点来自那一边，所以 swap 后不影响答案 
	int k=std::min(L,-R);//最多能匹配多少点 
	ans-=1ll*k*w[mid];//维护答案 
	L-=k;R+=k;//减去匹配了的点 
	if(L==0) return R;
	return L;
}
```


实现过程中可能会有一些细节，这里不一一列举，代码里有注释。

```cpp
# include <cstdio>
# include <algorithm>
# include <cstring>
const int N=1e6+5;int M,n,len;char c[N];
//----------求sa与height----------
//就不写注释了，这部分依个人写法 
int sa[N],bt[N],rk[N],tp[N],ht[N];
void Sort(){
	for(int i=1;i<=M;i++) bt[i]=0;
	for(int i=1;i<=len;i++) bt[rk[i]]++;
	for(int i=1;i<=M;i++) bt[i]+=bt[i-1];
	for(int i=len;i>=1;i--) sa[bt[rk[tp[i]]]--]=tp[i];
	return ;
}
void getsa(){
	M=1000;for(int i=1;i<=len;i++) rk[i]=c[i],tp[i]=i;Sort();
	for(int w=1,cnt=0;cnt<len;M=cnt,w<<=1){
		cnt=0;
		for(int i=1;i<=w;i++) tp[++cnt]=len-w+i;
		for(int i=1;i<=len;i++) if(sa[i]>w) tp[++cnt]=sa[i]-w;
		Sort();std::swap(tp,rk);
		rk[sa[1]]=cnt=1;
		for(int i=2;i<=len;i++)
		rk[sa[i]]=(tp[sa[i]]==tp[sa[i-1]]&&tp[sa[i]+w]==tp[sa[i-1]+w])?cnt:++cnt;
	}return ;
}void getht(){
	for(int i=1,k=0;i<=len;i++){
		if(k) k--;
		while(c[sa[rk[i]]+k]==c[sa[rk[i]-1]+k])
		++k;
		ht[rk[i]]=k;
	}return ;
}
//----------求sa与height----------

int op[N],w[N];//构造 p 数组 , op 表示哪一类 , w 意义与题解中描述意义一致 

//----------RMQ-----------
const int bit=19;
int Min[N][21];
long long ans=0;
int lg[N];
int Query(int l,int r){
	int len=r-l+1;
	int k=lg[len];
	if(w[Min[l][k]]<=w[Min[r-(1<<k)+1][k]]) return Min[l][k];
	return Min[r-(1<<k)+1][k];
}
//----------RMQ-----------

//----------分治求解最大权匹配----------
int solve(int l,int r){
	if(l==r) return op[l];//只有一个点 
	int mid=Query(l,r-1);//找到权值最小的 w 
	int L=solve(l,mid);//L表示左边剩下的点 
	int R=solve(mid+1,r);//R表示右边剩下的点 
	if(1ll*L*R>=0) return L+R;//同类点无法匹配，直接加起来返回 
	if(L<0&&R>0) std::swap(L,R);//下面写的是默认  L>0 R<0 ,我们只关心两侧各有多少点，不关心哪些点来自那一边，所以 swap 后不影响答案 
	int k=std::min(L,-R);//最多能匹配多少点 
	ans-=1ll*k*w[mid];//维护答案 
	L-=k;R+=k;//减去匹配了的点 
	if(L==0) return R;
	return L;
}
//----------分治求解最大权匹配----------

int main(){
	int k;scanf("%d %d",&n,&k);
	scanf("%s",c+1);c[1+n]='*',
	scanf("%s",c+2+n);//接字符串  
	len=strlen(c+1);
	getsa();getht();//求 sa 与 height  
	
	for(int i=1;i<=n-k+1;i++) op[rk[i]]=1,op[rk[i+n+1]]=-1;// op 表示哪一类  
	for(int i=1;i<=len;i++)
	w[i]=std::min(ht[i+1],k);// w 意义与题解中描述意义一致 
	
	int cnt=0;
	for(int i=1;i<=len;i++)//删去标号为 0 的点 
	if(op[i]) op[++cnt]=op[i],w[cnt]=w[i];
	else w[cnt]=std::min(w[cnt],w[i]);
	
	//----------st表初始化-----------
	for(int i=1;i<=cnt;i++) Min[i][0]=i;
	for(int i=1;i<=bit;i++) lg[1<<i]=1;
	for(int i=1;i<=(1<<bit);i++) lg[i]+=lg[i-1];
	for(int j=1;j<=bit;j++){
		for(int i=1;i<=cnt;i++)
		if(w[Min[i][j-1]]<=w[Min[i+(1<<j-1)][j-1]]) Min[i][j]=Min[i][j-1];
		else Min[i][j]=Min[i+(1<<j-1)][j-1];
	}
	//----------st表初始化-----------
	ans=1ll*(n-k+1)*k;
	if(solve(1,cnt)!=0) printf("wdnmd");//qwq
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：FjswYuzu (赞：13)

给出一个只需要普通 SAM 的做法。

首先读题发现一个显然的贪心，也就是在 $n-k+1$ 个子串经过顺序排列之后，使 $\sum \operatorname{lcp} (a_i',b_i)$ 最大时答案更优秀。

考虑使用反证法，假设存在一种方案 $a''$，使得只存在一对数 $(p,q)$，使得当 $i \neq p,q$ 时，有 $a_i'' = a_i$，并且 $a_p' = a_q'',a_q' = a_p''$ 更优秀。发现贡献的变化只有 $p,q$ 两个位置。可以发现这次的交换一定不会使答案更优秀，假设不成立。

那么既然是公共前缀的问题，放到 Trie 树上肯定有助于思考。根到 Trie 树上两个点的 $\operatorname{LCA}$ 形成的字符串的意义即是两个串的 $\operatorname{lcp}$。如果将 SAM 考虑成合并的 Trie 树，SAM 也会具有这个性质。

首先因为 SAM 是「后缀自动机」，做前缀问题的时候要将串反转。

然后，将两个反转后的串 $a^R,b^R$ 拼接构建后缀自动机，并用类似 Trie 树结束结点的思想，分「属于 $a$」和「属于 $b$」进行标记，标记的条件是这个字符可以作为一个被拎出来的子串的第一个字符。

根据我们之前的一次分析，发现在 $\operatorname{parent}$ 树上面两个节点的 $\operatorname{LCA}$ 表示的**最长的**字符串是这两个结点最长的公共**后缀**（因为我们进行了反转所以现在是 $\operatorname{lcp}$）。然后再考虑我们发现的那个显然的贪心在这个后缀自动机上面的意义，即是在 $\operatorname{parent}$ 树内，能够匹配的尽量匹配，不能匹配的再上传继续匹配。根据这个贪心及其转化写一个树上贪心即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL Sigma=26;
LL n,k;
char s[300005],a[150005],b[150005];
struct SAM{
	LL las,cnt,ch[600005][Sigma],len[600005],fa[600005],epd[600005][2];
	SAM(){las=cnt=1;}
	void extend(LL c,LL cpt,LL type)
	{
		LL p=las,cur=++cnt;
		len[cur]=len[las]+1;
		las=cur;
		epd[cur][type]+=cpt;
		while(p && !ch[p][c])	ch[p][c]=cur,p=fa[p];
		if(!p)	fa[cur]=1;
		else
		{
			LL q=ch[p][c];
			if(len[p]+1==len[q])	fa[cur]=q;
			else
			{
				LL clone=++cnt;
				len[clone]=len[p]+1;
				memcpy(ch[clone],ch[q],sizeof ch[q]);
				fa[clone]=fa[q];
				fa[q]=fa[cur]=clone;
				while(ch[p][c]==q)	ch[p][c]=clone,p=fa[p];
			}
		}
	}
	LL bkt[600005],rev[600005];
	void topSort()
	{
		for(LL i=1;i<=cnt;++i)	++bkt[len[i]];
		for(LL i=1;i<=cnt;++i)	bkt[i]+=bkt[i-1];
		for(LL i=1;i<=cnt;++i)	rev[bkt[len[i]]--]=i;
	}
	LL calcAnswer()
	{
		LL ans=0;
		for(LL i=cnt;i;--i)
		{
			LL minn=min(epd[rev[i]][0],epd[rev[i]][1]);
			ans+=minn*min(len[rev[i]],k);
			epd[rev[i]][0]-=minn;
			epd[rev[i]][1]-=minn;
			epd[fa[rev[i]]][0]+=epd[rev[i]][0],epd[fa[rev[i]]][1]+=epd[rev[i]][1];
		}
		return ans;
	}
}sam;
int main(){
	scanf("%lld %lld",&n,&k);
	scanf("%s %s",a+1,b+1);
	for(LL i=n;i;--i)	sam.extend(a[i]-'a',LL(i+k-1<=n),0);
	for(LL i=n;i;--i)	sam.extend(b[i]-'a',LL(i+k-1<=n),1);
	sam.topSort();
	printf("%lld",k*(n-k+1)-sam.calcAnswer());
	return 0;
}
```

---

## 作者：StaroForgin (赞：8)

个人感觉其它题解的广义后缀自动机建的都有些问题，具体的可以参考[cxl大佬的博客](https://www.cnblogs.com/Xing-Ling/p/12038349.html)

当然，这里就不会展开讲广义后缀自动机怎么建了。

其实只需要先将所有的字符串先建成一棵trie树，将每个节点插入时的$las$值改为它trie树上父亲的$las$值即可。

对于这道题，我们都很容易想到一个贪心做法：

先将所有的串提取出来，建成一棵trie树，每个串就匹配到预期在trie树上距离最近的没有被匹配到的字符串即可。

这样做可以保证每个串在trie树上匹配到的串构成的路径都是不存在交集的，于是肯定是最小的匹配方法。

可很明显，如果直接将trie树建出来明显会T掉。
~~$O(n(n-k+1))$你不T谁T。~~

我们需要找到一个可以代替它的东西。

由于$2n$个字符串真正不同的地方差不多只有$4n$个的样子。

于是，我们就想到了前缀自动机。

前缀自动机的parent树是可以完成这个操作的，它有效的节省了空间与时间。差不多是$O(n)$级别的。

可我们该怎么建出这个前缀自动机呢？

只需要将原串反过来建后缀自动机即可。
我们之后只需要在其parent树上跑树形dp就可以解决问题了。
此时两个串变化所需要的代价就是它们的lca的$len$与$k$之间的差值。

我们将两个串在一起建成一棵广义后缀自动机，更据其来源对其进行染色，匹配两个不同颜色的节点。~~树形dp板题~~

## 源码
```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
#include<map>
#include<set>
using namespace std;
#define MAXN 600005
typedef long long LL;
const LL INF=0x7f7f7f7f;
typedef unsigned long long uLL;
typedef pair<int,int> pii;
template<typename _T>
_T Fabs(_T x){return x>0?x:-x;}
template<typename _T>
void read(_T &x){
	_T f=1;x=0;char s=getchar();
	while('0'>s||'9'<s){if(s=='-')f=-1;s=getchar();}
	while('0'<=s&&s<='9'){x=(x<<3)+(x<<1)+(s^48);s=getchar();}
	x*=f;
} 
int n,k,len;LL ans; 
char str[MAXN];
struct trie{int ch[30],cnt;};
struct ming{int ch[30],len,fa,cnt;};
struct SAM{
	private:
		int tot,dp[MAXN];
		vector<int>G[MAXN];
	public:
		ming a[MAXN];
		void init(){tot=1;}
		int extend(int x,int w,int las){
			int p=las,np=las=++tot;a[np].len=a[p].len+1;a[np].cnt=w;
			for(;p&&!a[p].ch[x];p=a[p].fa)a[p].ch[x]=np;
			if(!p){a[np].fa=1;return np;}int q=a[p].ch[x];
			if(a[q].len==a[p].len+1){a[np].fa=q;return np;}
			int nq=++tot;a[nq]=a[q];a[nq].len=a[p].len+1;a[q].fa=a[np].fa=nq;
			a[nq].cnt=0;for(;p&&a[p].ch[x]==q;p=a[p].fa)a[p].ch[x]=nq;
			return np;
		}
		void dfs(int x){
			dp[x]=a[x].cnt;int siz=G[x].size();
			for(int i=0;i<siz;i++){int v=G[x][i];dfs(v);dp[x]+=dp[v];}
			if(a[a[x].fa].len<k&&dp[x]>0)ans+=1ll*dp[x]*(min(a[x].len,k)-a[a[x].fa].len);
		}//树dp
		void solve(){for(int i=1;i<=tot;i++)G[a[i].fa].push_back(i);dfs(1);}
}S;//广义后缀自动机
class Trie{
	private:
		int tot,pos[MAXN];
		queue<int> q;bool vis[MAXN];
	public:
		trie a[MAXN];int root;
		void init(){tot=root=1;} 
		void insert(int &x,int pos,int w,int dep){
			if(!x)x=++tot;a[x].cnt+=w*(dep>=k);if(pos>len)return ;
			insert(a[x].ch[str[pos]-'a'],pos+1,w,dep+1);
		}
		void bfs(){
			while(!q.empty())q.pop();pos[root]=vis[root]=1;q.push(root);
			while(!q.empty()){
				int t=q.front();q.pop();
				for(int i=0;i<26;i++){
					int v=a[t].ch[i];if(!v&&!vis[v])continue;
					pos[v]=S.extend(i,a[v].cnt,pos[t]);
					q.push(v);vis[v]=1;
				}
			}
		}//建自动机
}T;//字典树
signed main(){
	read(n);read(k);T.init();S.init();
	scanf("%s",str+1);len=n;
	reverse(str+1,str+n+1);T.insert(T.root,1,1,0);
	scanf("%s",str+1);len=n;
	reverse(str+1,str+n+1);T.insert(T.root,1,-1,0);
	T.bfs();S.solve();
	printf("%lld\n",ans);
	return 0;
}

```


---

## 作者：MuelsyseU (赞：3)

这是一个对 $O(n)$ 个串的最小匹配问题，其中 $A_i,B_j$ 匹配的代价为长度减去两者的最长公共前缀。

考虑此类问题肯定没有小于 $O(n^2)$ 的一般解法，所以应当挖掘 LCP 作为边权的性质，也就是说，

$$\operatorname{lcp}(A_i,B_j)\ge \min(\operatorname{lcp}(A_i,B_u),\operatorname{lcp}(B_u,B_v),\operatorname{lcp}(B_v,B_j))$$

这意味着我们有一种贪心的策略：每次取 LCP 最大的两端点都未匹配的边 $(A_i,B_j)$ 匹配。结合上式及邻项交换可证。

利用 SA，从大到小枚举 LCP 的值并且高度数组上合并即可。


```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 600010;
int k, tn, n, qn, lt[maxn], sa[maxn], rk[maxn], ht[maxn];
char ts[maxn];
int str[maxn];
vector<int> v[maxn];
namespace Sa {
	int m, ans, c[maxn], x[maxn], y[maxn];
	void init() {
		m = 112;
		for (int i = 1; i <= n; ++i) ++c[x[i] = str[i]];
		for (int i = 2; i <= m; ++i) c[i] += c[i - 1];
		for (int i = n; i >= 1; --i) sa[c[x[i]]--] = i;
		for (int k = 1; k <= n; k <<= 1) {
			int num = 0;
			for (int i = n - k + 1; i <= n; ++i) y[++num] = i;
			for (int i = 1; i <= n; ++i)
				if (sa[i] > k) y[++num] = sa[i] - k;
			for (int i = 1; i <= m; ++i) c[i] = 0;
			for (int i = 1; i <= n; ++i) ++c[x[i]];
			for (int i = 2; i <= m; ++i) c[i] += c[i - 1];
			for (int i = n; i >= 1; --i) sa[c[x[y[i]]]--] = y[i], y[i] = 0;
			swap(x, y);
			x[sa[1]] = 1;
			num = 1;
			for (int i = 2; i <= n; ++i)
				x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]) ? num : ++num;
			if (num == n) break;
			m = num;
		}
		int z = 0;
		for (int i = 1; i <= n; ++i) rk[sa[i]] = i;
		for (int i = 1; i <= n; ++i) {
			if (rk[i] == 1) continue;
			if (z) --z;
			int j = sa[rk[i] - 1];
			while (j + z <= n && i + z <= n && str[i + z] == str[j + z]) ++z;
			ht[rk[i]] = z, v[z].push_back(rk[i]);
		}
	}
}
int f[maxn], as[maxn], bs[maxn];
long long ans;
int find(int x) {
	if (x != f[x]) return f[x] = find(f[x]);
	return x;
}
inline void merge(int x, int y, int i) {
	x = find(x), y = find(y);
	if (x == y) return;
	int tmp = min(as[x], bs[y]);
	ans += max(0, k - i) * tmp, as[x] -= tmp, bs[y] -= tmp;
	tmp = min(bs[x], as[y]);
	ans += max(0, k - i) * tmp, bs[x] -= tmp, as[y] -= tmp;
	as[y] = as[x] + as[y], bs[y] = bs[x] + bs[y], f[x] = y;
}
signed main() {
	int c;
	scanf("%d%d", &tn, &k);
	scanf("%s", ts + 1), n = tn * 2 + 1;
	for (int i = 1; i <= tn; ++i)
		f[i] = i, as[i] = (i + k - 1 <= tn), str[i] = ts[i] - 'a' + 1;
	str[tn + 1] = 100, f[tn + 1] = tn + 1, scanf("%s", ts + 1);
	for (int i = tn + 2; i <= n; ++i)
		f[i] = i, bs[i] = (i - tn - 1 + k - 1 <= tn), str[i] = ts[i - tn - 1] - 'a' + 1;
	Sa::init();
	for (int i = tn; i >= 0; --i) {
		int ln = v[i].size();
		for (int j = 0; j < ln; ++j) merge(sa[v[i][j]], sa[v[i][j] - 1], i);
	}
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：zyp123456 (赞：3)

### 一、前置芝士

+ [广义后缀自动机](https://www.luogu.com.cn/problem/P6139)

### 二、题目分析

+ 首先，考虑暴力怎么做。

+ 由题意不难知，我们可以将 $A$ 串中长度为 $k$ 的字符串染为 $0$，$B$ 串中的染为 $1$ ，然后全部放进 $trie$ 树中去。最后自叶子节点向根节点逐层匹配，不难发现这样做可以尽可能的让所加入的串尽可能的匹配上，从而得到正确答案

+ 由于暴力的时空复杂度都是 $O(n(n-k+1))$ 故而我们想到了用 $parents$ 树来代替之。

### 三、代码

+ 由于下面有巨神使用 $bfs$ 离线建立广义后缀自动机，那么在此蒟蒻就提供一个在线建立的 $SAM$ 吧。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
template<typename T>inline void rd(T&x){
	x=0;T f=1;char ch=getchar();
	while(!isdigit(ch))f=(ch=='-')?-1:1,ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	x*=f;
}
const int M=1000100;
int ch[M][26],node=1,len[M],fa[M],siz[M][2],n,k;
char s[M];
ll ans=0,b[M],A[M];
inline int extend(int las,int c,int w,int id){
	if(ch[las][c]){
		int p=las,q=ch[p][c];
		if(len[p]+1==len[q]){siz[q][id]+=w;return q;}
		int nq=++node;
		len[nq]=len[p]+1;
		siz[nq][id]+=w;
		fa[nq]=fa[q],fa[q]=nq;
		memcpy(ch[nq],ch[q],sizeof ch[nq]);
		while(p&&ch[p][c]==q)ch[p][c]=nq,p=fa[p];
		return nq;
	}
	int p=las,np=++node;
	len[np]=len[p]+1;
	siz[np][id]+=w;
	
	while(p&&!ch[p][c])ch[p][c]=np,p=fa[p];
	if(!p){fa[np]=1;return np;}
	
	int q=ch[p][c];
	if(len[q]==len[p]+1){fa[np]=q;return np;}
	
	int nq=++node;
	len[nq]=len[p]+1;
	fa[nq]=fa[q],fa[q]=fa[np]=nq;
	while(p&&ch[p][c]==q)ch[p][c]=nq,p=fa[p];
	memcpy(ch[nq],ch[q],sizeof ch[nq]);
	return np;
}
int main(){
	rd(n),rd(k);
	scanf("%s",s+1);
	int las=1;
	for(int i=n;i>=1;i--)las=extend(las,s[i]-'a',int(i+k-1<=n),0);
	scanf("%s",s+1);
	las=1;
	for(int i=n;i>=1;i--)las=extend(las,s[i]-'a',int(i+k-1<=n),1);
	
	for(int i=1;i<=node;i++)b[len[i]]++;
	for(int i=1;i<=node;i++)b[i]+=b[i-1];
	for(int i=1;i<=node;i++)A[b[len[i]]--]=i;
	ll ans=0;
	for(int i=node;i>=1;i--){
		int x=A[i];
		int minn=min(siz[x][0],siz[x][1]);
		ans+=(ll)minn*min(len[x],k);
		siz[x][0]-=minn;
		siz[x][1]-=minn;
		siz[fa[x]][0]+=siz[x][0],siz[fa[x]][1]+=siz[x][1]; 
	} 
	printf("%lld\n",((ll)k*(n-k+1)-ans));
	return 0;
}

```


---

## 作者：Fuyuki (赞：2)

可以直接理解成将后缀之间匹配，$A[i,n]$ 匹配 $B[j,n]$ 的代价为 $k-\min\{k,lcp(A[i,n],B[j,n])\}$，那么建棵广义后缀树，在后缀树上合并后缀，在深度较深处合并一定更优，所以直接贪心即可。

复杂度 $O(n\sum)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define I inline int
#define V inline void
#define ll long long int
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define ROF(i,a,b) for(int i=a;i>=b;i--)
const int N=1e6+1;
ll ans;
char a[N],b[N];
vector<int>e[N];
int n,k,top,tot=1,last=1;
int fa[N],len[N],ch[N][26],d[N],sta[N],dp[N],A[N],B[N];
V cpy(int x,int y){FOR(i,0,25)ch[x][i]=ch[y][i];}
V ins(int x){
	int p=last,np,q,nq;
	if(len[ch[p][x]]==len[p]+1)return void(last=ch[p][x]);
	len[np=last=++tot]=len[p]+1;
	while(p&&ch[p][x]==0)ch[p][x]=np,p=fa[p];
	if(!p)return void(fa[np]=1);
	if(len[q=ch[p][x]]==len[p]+1)return void(fa[np]=q);
	cpy(nq=++tot,q),fa[nq]=fa[q],fa[q]=fa[np]=nq,len[nq]=len[p]+1;
	while(p&&ch[p][x]==q)ch[p][x]=nq,p=fa[p];
}
int main(){
	scanf("%d%d%s%s",&n,&k,a+1,b+1);
	ROF(i,n,1)ins(a[i]-'a'),A[last]+=i<=n-k+1;
	last=1;
	ROF(i,n,1)ins(b[i]-'a'),B[last]+=i<=n-k+1;
	FOR(i,2,tot)d[fa[i]]++,ans+=1ll*max(k-len[i],0)*min(A[i],B[i]),dp[i]=A[i]-B[i];
	FOR(i,1,tot)if(!d[i])sta[++top]=i;
	while(int u=sta[top--]){
		if((dp[u]^dp[fa[u]])>>31)
			ans+=1ll*max(k-len[fa[u]],0)*min(abs(dp[u]),abs(dp[fa[u]]));
		if(dp[fa[u]]+=dp[u],!--d[fa[u]])sta[++top]=fa[u];
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：lory1608 (赞：1)

这一题求是对于 $s$ 的所有长度为 $k$ 的子串和 $t$ 的所有长度为 $k$ 的子串一一配对后，最小后缀编辑距离。

显然，对于这种题目，我们可以直接建立广义后缀自动机，然后在自动机上dp即可。

这里有一个很显然的贪心：把两个编辑距离最近的先配对。

复杂度 $O(n)$ 。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define FOR(i,a,b) for(int i=a;i<=b;++i)
#define REP(u) for(int i=p[u];i!=-1;i=e[i].nxt)
#define ll long long
#define gc getchar()
using namespace std;
inline int getint()
{
	char ch=gc;int x=0,f=1;
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=gc;}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=gc;}
	return (f==1)?x:-x;
}
const int maxn=6e5+5;
int fa[maxn];
char s[maxn],t[maxn];
int tot=1,last=1;
int son[maxn][26],n,k,len[maxn],typ[maxn],cnt[3][maxn],sz,p[maxn];
ll ans;
struct edge
{
	int v,nxt;
	edge(int vv=0,int nn=0){v=vv,nxt=nn;}
}e[maxn<<1];
inline void add(int u,int v)
{
	e[++sz]=edge(v,p[u]);
	p[u]=sz;
}
struct SAM
{
	inline void insert(int c,int x,int now)
	{
		int np=++tot,p=last;
		last=np,len[np]=len[p]+1;
		while(p&&!son[p][c])son[p][c]=np,p=fa[p];
		if(!p)fa[np]=1;
		else
		{
			int q=son[p][c];
			if(len[q]==len[p]+1)fa[np]=q;
			else
			{
				int nq=++tot;
				fa[nq]=fa[q];
				fa[q]=fa[np]=nq;
				memcpy(son[nq],son[q],sizeof(son[nq]));
				len[nq]=len[p]+1;
				while(son[p][c]==q&&p)son[p][c]=nq,p=fa[p];
			}
		}
		if(now>=k)typ[np]=x;
	}
}sam;
inline void dfs(int u)
{
	cnt[typ[u]][u]++;
	REP(u)
	{
		int v=e[i].v;
		dfs(v);
		cnt[2][u]+=cnt[2][v];
		cnt[1][u]+=cnt[1][v];
	}
	if(cnt[2][u]>=cnt[1][u])
	{
		int delta=(len[u]>=k)?0:(k-len[u]);
		ans+=1LL*cnt[1][u]*delta;
		cnt[2][u]-=cnt[1][u];cnt[1][u]=0;
	}
	else
	{
		int delta=(len[u]>=k)?0:(k-len[u]);
		ans+=1LL*cnt[2][u]*delta;
		cnt[1][u]-=cnt[2][u];cnt[2][u]=0;
	}
}
int main()
{
	memset(p,-1,sizeof(p));
	n=getint(),k=getint();
	scanf("%s",s+1),scanf("%s",t+1);
	reverse(s+1,s+n+1),reverse(t+1,t+n+1);
	FOR(i,1,n)sam.insert(s[i]-'a',1,i);last=1;
	FOR(i,1,n)sam.insert(t[i]-'a',2,i);
	int now=1,lens=0;
	FOR(i,2,tot)add(fa[i],i);
	dfs(1);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Kevin090228 (赞：0)

### P6793 [SNOI2020] 字符串

> 给定 $n,k$，对于一个长度为 $n$ 的串 $s$，设他的子串集合 $S(s)$ 表示 $S$ 所有长度为 $k$ 的子串的可重集合。输出 $a,b$，每次可以将 $S(a)$ 中一个串的某个后缀修改为任意长度相同的串，代价是后缀长度，求使 $S(a)=S(b)$ 的最小代价。

转化一下题意，你需要给 $S(a)$ 和 $S(b)$ 中的串两两匹配，$s$ 和 $t$ 匹配的贡献是它们的最长公共前缀，要求最大化贡献和。

贡献和的最大值有一个显然的上界，对于每个前缀 $s$，求出 $S(a),S(b)$ 中以 $s$ 为前缀的串个数 $c_1,c_2$，则 $s$ 的贡献就是 $\min(c_1,c_2)$，贡献的总和就是上界，且这个上界是存在构造的，建出 Trie 树然后从叶子到根每次尽量匹配子树中的点即可。

但是由于 $S(a),S(b)$ 中的串长总和是 $O(n^2)$ 级别的，所以我们无法直接构造出整个 Trie。我们考虑尽量节省的去保存子串信息，这就需要用到后缀自动机了。但是注意到可以作为前缀的串需要满足起始点在 $[1,n-k+1]$ 内，这是不好使用 SAM 记录的，我们可以将整个串反转，这样就变成 endpos 在 $[k,n]$ 内，就容易查询 $c_1,c_2$ 的值了。

时间复杂度 $O(n)$。

---


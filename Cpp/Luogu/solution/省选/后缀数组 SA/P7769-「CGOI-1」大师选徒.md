# 「CGOI-1」大师选徒

## 题目背景

最近有好多人来丑国学习 bc。bc 大师 ac 和 mc 要从所有学生选出一些来传授 bc 技艺。

###### 2021.8.29：添加了一组 hack

## 题目描述

有 $n$ 个学生站成一排，每个学生有一个丑值 $a_i$。现在 ac 和 mc 要**各自**从学生中选取**连续**的一段传授 bc。

由于 ac 和 mc 关系很♂好，所以两人选出的学生必须人数相同，并且**对应位置**上的学生丑值之和均为 $s$。

（比方说，如果 ac 选第 $1$、$2$、$3$ 号学生，mc 选 $3$、$4$、$5$ 号学生，必须满足 $a_1+a_3=a_2+a_4=a_3+a_5=s$）

但 ac 并不知道 mc 所选的学生以及 $s$ 是多少，所以他会给出若干个询问。对于每个询问，你需要回答对于特定的 $s$ 以及 mc 选出的一段学生，ac 是否可以选出另一段学生满足上述要求。

**简化版题意：**

给出 $n$ 及 $n$ 个整数 $a_1,\,a_2,\,\dots,\,a_n$；

$q$ 次询问，每次给出 $s,l,r$，问是否存在 $b$，满足 $\forall k \in [0, r-l]$，$a_{l+k}+a_{b+k}=s$。

## 说明/提示

#### 样例说明：

对于样例 1：

第一个询问，mc 选择的是第三个学生，ac 可以选择第一个学生。

第二个询问，mc 选择的第二个学生丑值为 $1$，而总和也为 $1$，但不存在丑值为 $0$ 的学生，故不能满足条件。

第三个询问，mc 选择的是第四个到第六个，那么 ac 选择第二个到第四个，对应位置的学生丑值之和 $a_2+a_4=a_3+a_5=a_4+a_6=5$，满足条件。

第四个询问，mc 选择第一个和第二个，那么 ac 也选择第一个和第二个，满足条件。

---

#### 数据范围：

**本题采用捆绑测试。**

对于全部数据，有 $1\le n,\,q\le 4\times10^5$，$1\le a_i \le n$，$1\le s\le 2n$，$1\le l\le r\le n$。
* Subtask 0（10 points）：$n,\,q\le 500$。
* Subtask 1（20 points）：$n,\,q\le 8\times10^3$。
* Subtask 2（20 points）：保证所有 $s$ 相同。
* Subtask 3（50 points）：无特殊限制。

## 样例 #1

### 输入

```
6 4
1 1 3 4 2 1
4 3 3
1 2 2
5 4 6
2 1 2```

### 输出

```
Yes
No
Yes
Yes```

## 样例 #2

### 输入

```
6 4
4 2 2 2 2 1
6 1 1
5 5 6
4 3 5
5 2 2```

### 输出

```
Yes
No
Yes
No```

# 题解

## 作者：阿丑 (赞：6)

[传送门](https://www.luogu.com.cn/problem/P7769)

#### 前置知识：

SA 数组。

#### 题意：

- 给出 $n$ 个在 $[1,n]$ 内的数 $a_i$。

- $q$ 次询问，每次给出 $s,l,r$，问是否 $\exists b\in[1,n]$ 使 $\forall k\in[0,r-l]$，$a_{l+k}+a_{b+k}=s$。

- $n,q\le4\times10^5$。

为叙述方便，设以 $s$ 的第 $i$ 个元素为首个元素的后缀为 $\operatorname{suff}(s,i)$。

#### 分析：

- Subtask 0：$n,q\le500$。

暴力枚举每一个 $b$ 进行判断。

---

- Subtask 1：$n,q\le8\times10^3$。

是 $O(nq)$ 的 KMP 写法，并不是正解。

对于每一个询问，设 $c_k=s-a_{l+k}$（$k\in[0,r-l]$），那么如果存在 $b$ 满足 $a_{b+k}=c_k$，就满足条件，否则不满足。

原问题转换成了能否在 $a$ 中找到一个子串和 $c$ 相同，可以用 KMP 解决。这个过程是 $O(n)$ 的，$q$ 次询问就是 $O(nq)$。

这个 Subtask 虽然和正解使用的算法不同，但对思路有一定帮助。

---

- Subtask 2：$s$ 相同。

若 $s$ 相同，就说明 $s-a_i$ 相同。所以每次得出的 $c$ 是另一个串 $d$（$d_i=s-a_i$） 的子串。问题转换成求 $d$ 的一个子串是否在 $a$ 中出现过。

对 $d$ 和 $a$ 一起求 SA，假设询问的 $d$ 的子串是 $d_l,d_{l+1},\dots,d_r$，那么只需要判断 $\operatorname{suff}(d,l)$ 与 $a$ 的所有后缀的 lcp 的最大值是否不小于 $r-l+1$ 即可。

可以二分求 $\operatorname{suff}(d,l)$ 在 $\operatorname{suff}(a,i)$ 中的前驱和后继，复杂度 $O((n+q)\log n)$，已经能过了。

---

- Subtask 3：无限制。

注意到 $a_{l+k}+a_{b+k}=s$，$a_{l+k+1}+a_{b+k+1}=s$ 可以推出 $(a_{l+k+1}-a_{l+k})+(a_{b+k+1}-a_{b+k})=0$，即差分数组对应位置上的数互为相反数。

求出差分数组 $a'$ 以及差分的相反数数组 $d'$。问题等价于求所有满足 $a_b+a_l=s$ 的 $\operatorname{suff}(d',b)$ 和 $\operatorname{suff}(a',l)$ 的最长公共前缀的最大值是否不小于 $r-l$。

以样例为例，各数组如下表：

|$i$|1|2|3|4|5|6|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$a$|1|1|3|4|2|1|
|$a'$|0|2|1|-2|-1|/|
|$d'$|0|-2|-1|2|1|/|

对于询问三，$\operatorname{suff}(a',l)=\{-2,-1\}$。

满足 $a_b+a_l=s$ 的 $b$ 有 $1$，$2$，$6$。所有 $\operatorname{suff}(d',b)$ 为：$\operatorname{suff}(d',1)=\{0,-2,-1,2,1\}$，$\operatorname{suff}(d',2)=\{-2,-1,2,1\}$，$\operatorname{suff}(d',6)=\{\}$。

其中 $\operatorname{suff}(d',2)$ 与 $\operatorname{suff}(a',4)$ 的公共前缀长度为 $2$。这意味着 $a'_2+a'_4=0$，$a'_3+a'_5=0$，并且由于因为已经保证了 $a_2+a_4=s$，所以：

$a_3+a_5=(a_2+a'_2)+(a_4+a'_4)=s$，$a_4+a_6=(a_3+a'_3)+(a_5+a'_5)=s$，满足条件。

注意到所有 $a_b+a_l=s$ 的 $a_b$ 是相同的~~废话~~，所以可以对于每一个 $v$，将所有 $a_b=v$ 的 $b$ 放在一个数组里，按 rank 排序，询问时二分 $\operatorname{suff}(a',l)$ 的 rank 在哪个位置即可。

---

#### 思路：

- 求出差分数组与差分的相反数数组。

- 对于每一个询问，求出 $\max\limits_{a_b+a_l=s}\{\operatorname{lcp}(\operatorname{suff}(a',l),\operatorname{suff}(d',b))\}$ 是否不小于 $r-l$。

---

```cpp
#include <bits/stdc++.h>
#define rep(i, l, r) for(int i=l; i<=r; ++i)
#define rrep(i, r, l) for(int i=r; i>=l; --i)
#define ll long long
#define il inline
#pragma GCC diagnostic ignored "-Wparentheses"
using namespace std;
const int mN=4e5+100, mM=2*mN, mD=21;
il int read() {
	int res=0; char c=getchar(); while(c<'0' || c>'9') c=getchar();
	while(c>='0' && c<='9') res=(res<<1)+(res<<3)+(c^48), c=getchar(); return res;
}
il int max_(int a, int b) {return a>b? a: b;}
il int min_(int a, int b) {return a<b? a: b;}
int n, q, m, a[mN], lg[mM], mn[mD][mM], f[mN], fl[mN], fr[mN];
int c[mM];
il int cal_min(int l, int r) {return min(mn[lg[r-l+1]][l], mn[lg[r-l+1]][r-(1<<lg[r-l+1])+1]);}

//begin 板子
int ork, rk[2][mM*2], rak[mM], sa[mM], lcp[mM], buc[mM], tmp1[mM], tmp2[mM]; 
il void get_buc(int *a) {
	rep(i, 0, ork) buc[i]=0;
	rep(i, 1, m) ++buc[a[i]];
	rep(i, 1, ork) buc[i]+=buc[i-1];
}
void get_sa() {
	rep(i, 1, m) rk[0][i]=c[i];
	int t=0; ork=m;
	for(; t<=lg[m]; ++t) {
		get_buc(rk[t&1]+(1<<t));
		rep(i, 1, m) tmp1[buc[rk[t&1][i+(1<<t)]]--]=i;
		get_buc(rk[t&1]);
		rrep(i, m, 1) tmp2[buc[rk[t&1][tmp1[i]]]--]=tmp1[i];
		ork=0;
		rep(i, 1, m) {
			if(rk[t&1][tmp2[i]]!=rk[t&1][tmp2[i-1]] || rk[t&1][tmp2[i]+(1<<t)]!=rk[t&1][tmp2[i-1]+(1<<t)]) ++ork;
			rk[t&1^1][tmp2[i]]=ork;
		}
		if(ork==m) {++t; break;}
	}
	rep(i, 1, m) sa[rak[i]=rk[t&1][i]]=i;
}
#define j lcp[rak[i]]
il void get_lcp() {rep(i, 1, m) for(j=max_(lcp[rak[i-1]]-1, 0); c[i+j]==c[sa[rak[i]+1]+j]; ++j);}
#undef j
//end 板子 

il bool sol(int s, int l, int r) {	//处理询问 (s,l,r) 
	int v=s-a[l], L=fl[v], R=fr[v];
	if(v<=0 || v>n || fl[v]>fr[v]) return 0;	//没有 a[i]=v, 直接返回 
	while(L<=R) if(f[L+R>>1]<rak[l]) L=(L+R>>1)+1; else R=(L+R>>1)-1;	//二分 rak[l] 的位置 
	//二分的结果满足 f[R]<rak[l]<f[L] 
	return max_(fl[v]<=R? cal_min(f[R], rak[l]-1): 0, L<=fr[v]? cal_min(rak[l], f[L]-1): 0)>=r-l;
	//如果在范围内就求 lcp，否则为 0 
}
int main() {
	n=read(), q=read(), m=2*n-1;
	rep(i, 2, m) lg[i]=lg[i>>1]+1;
	rep(i, 1, n) a[i]=read();
	rep(i, 1, n-1) c[i]=a[i+1]-a[i]+n+1, c[i+n]=a[i]-a[i+1]+n+1;	//c[1]~c[n] 为 a', c[n+1]~c[2n] 为 d' 
	c[n]=1;
	get_sa(), get_lcp();	//SA
	rep(i, 1, m) mn[0][i]=lcp[i];
	rep(t, 1, lg[m]) rep(i, 1, m-(1<<t)+1) mn[t][i]=min_(mn[t-1][i], mn[t-1][i+(1<<t-1)]);	//ST

	rep(i, 0, n) buc[i]=0;
	rep(i, 1, n) ++buc[a[i]];
	rep(i, 1, n) buc[i]+=buc[i-1];
	rep(i, 1, n) fl[i]=buc[i-1]+1, fr[i]=buc[i];	//值为 v 的 a[i] 在 fl[v] 到 fr[v] 的范围内 
	rep(i, 1, n) f[buc[a[i]]--]=rak[i+n];	//把 a[i]=v 的 rank[d'[i]] 放进 f[fl[v]~fr[v]] 
	rep(i, 1, n) if(fl[i]<=fr[i]) sort(f+fl[i], f+fr[i]+1);
	int s, l, r;
	do s=read(), l=read(), r=read(), puts(sol(s, l, r)? "Yes": "No"); while(--q);
	return 0;
}
```

---

## 作者：Alex_Wei (赞：4)

Upd on 2022.6.25：修改表述，更正代码。

> [P7769 丑国传说 · 大师选徒（Selecting Apprentices）](https://www.luogu.com.cn/problem/P7769)

考虑 $a_{l+k} + a_{b + k} = s$ 的充要条件：设 $d_i = a_{i + 1} - a_i$，$d_n$ 未定义，需满足 $a_l + a_b = s$ 且 $d_{l\sim r - 1}$ 与 $d_{b\sim b + (r - l) - 1}$ 互为相反数。

这启发我们把 $d$ 以及 $d$ 的相反数 $d'$ 拼接在一起得到序列 $D$。求出其后缀数组，问题转化为检查是否存在 $D$ 的后缀 $D[i, 2n - 1]$ 满足 $i > n$ 且 $a_{i - n} = s - a_l$ 且 $|lcp(D[i, 2n - 1], D[l, 2n - 1])| \geq r - l$。

容易处理第三条限制：符合条件的后缀的排名是一段包含 $rk_l$ 的区间 $[x, y](x\leq rk_l\leq y)$。预处理 $ht$ 的倍增数组，二分 + RMQ 求出。

对于前两条限制，对每个值 $c$ 开桶 $buc_c$ 记录 $i > n$ 且 $a_{i - n} = c$ 的所有 $i$ 后缀的排名。询问即检查 $buc_{s - a_l}$ 中是否存在 $[x, y]$ 之间的数，排序后二分查找即可。注意特判 $l = r$ 的情况。

时空复杂度均为线性对数。

```cpp
#include <bits/stdc++.h>
using namespace std;
bool Mbe;
constexpr int K = 20;
constexpr int N = 8e5 + 5;
int n, q, a[N], lg[N];
int d[N], ht[N], mi[K][N];
int sa[N], rk[N], ork[N], buc[N], id[N];
bool cmp(int a, int b, int w) {return ork[a] == ork[b] && ork[a + w] == ork[b + w];}
void build(int n) {
  d[n + 1] = -1e9;
  int m = N - 1, p = 0;
  for(int i = 1; i <= n; i++) buc[rk[i] = d[i] + ::n]++;
  for(int i = 1; i <= m; i++) buc[i] += buc[i - 1];
  for(int i = n; i; i--) sa[buc[rk[i]]--] = i;
  for(int w = 1; ; w <<= 1, m = p, p = 0) {
    for(int i = n - w + 1; i <= n; i++) id[++p] = i;
    for(int i = 1; i <= n; i++) if(sa[i] > w) id[++p] = sa[i] - w;
    memset(buc, 0, sizeof(buc));
    memcpy(ork, rk, sizeof(rk));
    p = 0;
    for(int i = 1; i <= n; i++) buc[rk[i]]++;
    for(int i = 1; i <= m; i++) buc[i] += buc[i - 1];
    for(int i = n; i; i--) sa[buc[rk[id[i]]]--] = id[i];
    for(int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i - 1], sa[i], w) ? p : ++p;
    if(p == n) break;
  }
  for(int i = 1, k = 0; i <= n; i++) {
    if(k) k--;
    while(d[i + k] == d[sa[rk[i] - 1] + k]) k++;
    mi[0][rk[i]] = ht[rk[i]] = k;
  }
  for(int i = 1; i <= lg[n]; i++)
    for(int j = 1; j + (1 << i) - 1 <= n; j++)
      mi[i][j] = min(mi[i - 1][j], mi[i - 1][j + (1 << i - 1)]);
}
int lcp(int i, int j) {
  assert(i != j);
  if((i = rk[i]) > (j = rk[j])) swap(i, j);
  int d = lg[j - i++];
  return min(mi[d][i], mi[d][j - (1 << d) + 1]);
}
vector<int> rbuc[N];
bool Med;
int main() {
  fprintf(stderr, "%.4lf\n", (&Mbe - &Med) / 1048576.0);
#ifdef ALEX_WEI
  freopen("1.in", "r", stdin);
  freopen("1.out", "w", stdout);
#endif
  for(int i = 2; i < N; i++) lg[i] = lg[i >> 1] + 1;
  cin >> n >> q;
  for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
  for(int i = 2; i <= n; i++) d[i - 1] = a[i] - a[i - 1];
  d[n] = -n;
  for(int i = 2; i <= n; i++) d[i - 1 + n] = a[i - 1] - a[i];
  build(n * 2 - 1);
  for(int i = 1; i <= n * 2 - 1; i++) if(sa[i] > n) rbuc[a[sa[i] - n]].push_back(i);
  for(int i = 1; i <= q; i++) {
    int s, l, r;
    scanf("%d%d%d", &s, &l, &r);
    int dt = s - a[l], len = r - l;
    if(dt <= 0 || dt > n) {puts("No"); continue;}
    if(l == r && a[n] == dt) {puts("Yes"); continue;}
    if(rbuc[dt].empty()) {puts("No"); continue;}
    if(l == r) {puts("Yes"); continue;}
    int pl = 1, pr = rk[l], ql, qr;
    while(pl < pr) {
      int m = pl + pr >> 1;
      if(lcp(sa[m], l) < len) pl = m + 1;
      else pr = m;
    }
    ql = pl;
    pl = rk[l], pr = n * 2 - 1;
    while(pl < pr) {
      int m = pl + pr + 2 >> 1;
      if(lcp(sa[m], l) < len) pr = m - 1;
      else pl = m;
    }
    qr = pl;
    ql = lower_bound(rbuc[dt].begin(), rbuc[dt].end(), ql) - rbuc[dt].begin();
    qr = upper_bound(rbuc[dt].begin(), rbuc[dt].end(), qr) - rbuc[dt].begin();
    if(ql == qr) puts("No");
    else puts("Yes");
  }
  return cerr << "Time: " << clock() << "\n", 0;
}
```

---

## 作者：Jerrywang09 (赞：0)

很不套路的字符串题。

如何转化题目中的限制条件？抽出相邻两项，
$$
a_i+a_{i+k}=s\\
a_{i+1}+a_{i+k+1}=s\\
$$

两式做差得：
$$
a_{i+1}-a_i=-(a_{i+k+1}-a_{i+k})
$$
另外还需要满足的条件：
$$
a_{i+k}=s-a_{i}
$$

因此，只需要把差分数组 $d$ 及其相反数 $d'=-d$ 看成字符串拼在一起，求其后缀数组。对于每个询问 $(s,l,r)$，找到开头为 $s-a_l$ 且与后缀 $d_l$ 公共前缀最长的后缀 $d'_{ans}$。只需要找后缀数组上前后离得最近的即可。

```cpp
// P7769 「CGOI-1」大师选徒
#include <cstdio>
#include <iostream>
#include <vector>
#define ll long long
#define rep(i, s, t) for(int i=s; i<=t; ++i)
#define debug(x) cerr<<#x<<":"<<x<<endl;
const int N=1600010; int B=400010;
using namespace std;

int n, m, T, a[N], b[N];
int sa[N], rnk[N], cnt[N], tmp[N], last[N], ht[N], mn[20][N], lg[N];
void init()
{
    rep(i, 1, n) sa[i]=i, rnk[i]=a[i], sa[n+i]=rnk[n+i]=0;
    int mx=B;
    for(int len=2; len/2<=n; len<<=1)
    {
        rep(i, 0, mx) cnt[i]=0;
        rep(i, 1, n) cnt[rnk[i+len/2]]++;
        rep(i, 1, mx) cnt[i]+=cnt[i-1];
        rep(i, 1, n) tmp[cnt[rnk[i+len/2]]--]=i;
        rep(i, 0, mx) cnt[i]=0;
        rep(i, 1, n) cnt[rnk[i]]++;
        rep(i, 1, mx) cnt[i]+=cnt[i-1];
        for(int i=n; i; i--)
        {
            int x=tmp[i]; sa[cnt[rnk[x]]--]=x;
        }
        rep(i, 1, n) last[i]=rnk[i];
        mx=1, rnk[sa[1]]=1;
        rep(i, 2, n)
        {
            if(!(last[sa[i-1]]==last[sa[i]] && last[sa[i-1]+len/2]==last[sa[i]+len/2]))
                mx++;
            rnk[sa[i]]=mx;
        }
        if(mx==n) break;
    }
    int h=0;
    rep(i, 1, n) if(rnk[i]!=1)
    {
        if(h) h--;
        int j=sa[rnk[i]-1];
        while(i+h<=n && j+h<=n && a[i+h]==a[j+h]) h++;
        ht[rnk[i]]=h;
    }
    rep(i, 2, n) mn[0][i]=ht[i];
    rep(j, 1, lg[n]) rep(i, 2, n-(1<<j)+1)
        mn[j][i]=min(mn[j-1][i], mn[j-1][i+(1<<j-1)]);
}
inline int lcp(int l, int r)
{
    if(!l || !r) return 0;
    l++; int k=lg[r-l+1];
    return min(mn[k][l], mn[k][r-(1<<k)+1]);
}
int pre[N], val[N]; bool ans[N];
struct Query {int x, len, id;};
vector<Query> q[N];

int main()
{
#ifdef Jerrywang
    freopen("E:/OI/in.txt", "r", stdin);
#endif
    rep(i, 2, N-1) lg[i]=lg[i>>1]+1;
    scanf("%d%d", &m, &T);
    rep(i, 1, m) scanf("%d", b+i);
    rep(i, 2, m) a[++n]=b[i]-b[i-1];
    a[++n]=B;
    rep(i, 2, m) a[++n]=b[i-1]-b[i], val[n]=b[i-1];
    rep(i, 1, n) a[i]+=n;
    B+=n; init();
    rep(i, 1, T)
    {
        int s, l, r; scanf("%d%d%d", &s, &l, &r);
        q[rnk[l]].push_back({s-b[l], r-l, i});
    }
    rep(i, 1, n)
    {
        for(auto [x,len,id]:q[i])
        {
            if(pre[x] && lcp(pre[x], i)>=len) ans[id]=1;
        }
        int x=val[sa[i]];
        if(x) pre[x]=i;
    }
    rep(i, 1, n) pre[i]=0;
    for(int i=n; i; i--)
    {
        for(auto [x,len,id]:q[i])
        {
            if(pre[x] && lcp(i, pre[x])>=len) ans[id]=1;
        }
        int x=val[sa[i]];
        if(x) pre[x]=i;
    }
    rep(i, 1, T) puts(ans[i]?"Yes":"No");

    return 0;
}
```

---


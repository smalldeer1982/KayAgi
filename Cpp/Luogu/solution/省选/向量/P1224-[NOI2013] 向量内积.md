# [NOI2013] 向量内积

## 题目描述

两个 $d$ 维向量 $A=[a_1,a_2,\ldots,a_d]$ 与 $B=[b_1,b_2,\ldots,b_d]$ 的内积为其相对应维度的权值的乘积和，即：

$$(A,B)=\sum_{i=1}^d a_ib_i=a_1b_1+a_2b_2+\ldots+a_db_d$$

现有 $n$ 个 $d$ 维向量 $x_1,\ldots,x_n$ ，小喵喵想知道是否存在两个向量的内积为 $k$ 的倍数。请帮助她解决这个问题。


## 说明/提示

### 数据范围

::cute-table{tuack}

| 测试点编号 | $n$ | $d$ | $k$ | $x_{i,j}$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $2$ | $20$ | $2$ | $\leq 10$ |
| $2$ | $5$ | ^ | ^ | ^ |
| $3$ | $10$ | $20$ | $3$ | ^ |
| $4$ | $20$ | $20$ | $2$ | $\leq 100$ |
| $5$ | $50$ | $20$ | $3$ | ^ |
| $6$ | $50$ | $50$ | $2$ | $\leq 10^3$ |
| $7$ | $50$ | $50$ | $3$ | $\leq 3\times 10^6 $ |
| $8$ | $80$ | $80$ | $2$ | $\leq 2\times 10^6 $ |
| $9$ | $100$ | $100$ | $3$ | $\leq 3\times 10^6 $ |
| $10$ | $500$ | ^ | ^ | ^ |
| $11$ | $10^3$ | ^ | $2$ | $\leq 2\times 10^6$ |
| $12$ | $10^3$ | ^ | $3$ | $\leq 3\times 10^6$ |
| $13$ | $10^4$ | ^ | $2$ | $<10$ |
| $14$ | $10^4$ | ^ | $3$ | ^ |
| $15$ | $1.5\times 10^4$ | ^ | $2$ | ^ |
| $16$ | $1.8\times 10^4$ | ^ | ^ | ^ |
| $17$ | $2\times 10^4$ | ^ | ^ | ^ |
| $18$ | $5\times 10^4$ | $30$ | $3$ | ^ |
| $19$ | $8\times 10^4$ | ^ | ^ | ^ |
| $20$ | $10^5$ | ^ | ^ | ^ |

## 样例 #1

### 输入

```
3 5 2 
1 0 1 0 1 
1 1 0 1 0 
0 1 0 1 1
```

### 输出

```
2 3
```

# 题解

## 作者：xzzduang (赞：46)

[传送门](https://www.luogu.com.cn/problem/P1224)

感谢 wzy 提供的思路，这可能是一个比较数学且困难的做法，和其他题解不太一样。

## $k=2$

考虑把这些向量排成一个 $n\times d$ 的矩阵 $A$，考虑把 $A$ 和 $A$ 的转置 $A^T$ 相乘得到 $B$，发现如果有解就是 $B$ 不是一个全 1 矩阵，且如果 $B_{i,j}=0$，答案就是 $i,j$。

思考如何 check 一个全 1 矩阵，随机构造一个 $n$ 行列向量 $R$。如果 $B$ 是一个全 1 矩阵，那么 $B\times R$ 得到的列向量的每个元素都应该是 $R$ 中的所有元素和，且如果第 $i$ 行不满足，那么肯定存在一组 $i,j$ 是答案。

计算 $B\times R$ 也很简单，$B\times R=(A\times(A^T\times R))$，时间复杂度 $\mathcal{O}(nd)$。

## $k=3$

因为模 $3$ 意义下 $1$ 和 $2$ 的平方都是 $1$，考虑 check 矩阵 $B$ 的每个值平方后是否是全 1 矩阵，随机生成一个数组 $r[]$，我们要 check 的就是对于每个 $i$，$\sum_jB_{i,j}^2r_j$ 是否等于 $\sum_j r_j$。

考虑构造出矩乘的形式，$\sum_jB_{i,j}^2r_j=\sum_{j}B_{i,j}R_{j,j}B^T_{j,i}$。其中 $R$ 是一个只有对角线有值的矩阵，且 $R_{j,j}=r_j$。现在要 check 的是最终得到的矩阵中对角线的值是否都是 $\sum_j r_j$。如果可以得到最终这个矩阵，构造方案的方法与 $k=2$ 类似。
$$
\begin{aligned}
&B\times R\times B^T\\
=&A\times (A^T\times (R \times A))\times A^T\\
\end{aligned}
$$
其中 $B^T=(A\times A^T)^T=(A^T)^T\times A^T=A\times A^T$。

因为 $R$ 只有对角线有值，所以 $R\times A$ 可以快速处理，中间三项乘出来得时间复杂度是 $\mathcal{O}(nd^2)$。因为我们只关心答案矩阵对角线上的值，左右两个矩阵不用暴力乘上去，考虑答案矩阵的 $Ans_{i,i}$，这时只用取出第一项的第 $i$ 行以及最后一项的第 $i$ 列来乘就好，总的时间复杂度 $\mathcal{O}(nd^2)$。

## 实现

- 一次随机可能不够，要来多几次。

- ~~因为模数较小，可以 bitset 优化，所以数据范围可以继续开大。~~

```cpp
#include<iostream>
#include<stdio.h>
#include<ctype.h>
#include<bitset>
#include<random>
#include<stdlib.h>
using namespace std;
inline int read(){
	int x=0,f=0; char ch=getchar();
	while(!isdigit(ch)) f|=(ch==45),ch=getchar();
	while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return f?-x:x;
}
int n,m,k;
struct matrix{
	vector<vector<int> > a;
	int n,m;
	inline void build(){
		a.resize(n+1);
		for(int i=1;i<=n;++i) a[i].resize(m+1);
	}
	matrix operator * (matrix B){
		matrix A=*this,C;
		C.n=A.n,C.m=B.m;
		C.a.resize(C.n+1);
		for(int i=1;i<=C.n;++i) C.a[i].resize(C.m+1);
		for(int i=1;i<=C.n;++i)
			for(int j=1;j<=C.m;++j){
				C.a[i][j]=0;
				for(int k=1;k<=A.m;++k){
					C.a[i][j]+=A.a[i][k]*B.a[k][j];
				}
				C.a[i][j]%=k;
			}
		return C;
	}
};
namespace sub2{
	inline void main(){
		mt19937 rnd(114514);
		matrix A,B;
		A.n=n,A.m=m,A.build();
		B.n=m,B.m=n,B.build();
		for(int i=1;i<=n;++i){
			for(int j=1;j<=m;++j){
				B.a[j][i]=A.a[i][j]=read()%k;
			}
		}
		for(int fick=1;fick<=10;++fick){
			matrix R;
			R.n=n,R.m=1,R.build();
			int sum=0;
			for(int i=1;i<=n;++i) R.a[i][1]=(rnd()&1),(sum+=R.a[i][1])%=2;
			R=B*R;
			R=A*R;
			for(int i=1;i<=n;++i){
				if(R.a[i][1]!=sum){
					for(int j=1;j<=n;++j){
						if(i==j) continue;
						int s=0;
						for(int k=1;k<=m;++k){
							(s+=A.a[i][k]*A.a[j][k])%=2;
						}
						if(s==0){
							printf("%d %d\n",min(i,j),max(i,j));
							return;
						}
					}
				}
			}
		}
		puts("-1 -1");
	}
}
namespace sub3{
	inline void main(){
		mt19937 rnd(114514);
		matrix A,B,C,D;
		A.n=n,A.m=m,A.build();
		B.n=m,B.m=n,B.build();
		for(int i=1;i<=n;++i){
			for(int j=1;j<=m;++j){
				B.a[j][i]=A.a[i][j]=read()%k;
			}
		}
		C=A,D=B;
		for(int fick=1;fick<=10;++fick){
			int sum=0;
			matrix R=C;
			for(int i=1;i<=n;++i){
				int x=rnd()%3;
				(sum+=x)%=3;
				for(int j=1;j<=m;++j){
					(R.a[i][j]*=x)%=3;
				}
			}
			R=B*R;
			for(int i=1;i<=n;++i){
				int s=0;
				for(int j=1;j<=m;++j){
					for(int k=1;k<=m;++k){
						s+=A.a[i][j]*R.a[j][k]*D.a[k][i];
					}
				}
				if(s%3!=sum){
					for(int j=1;j<=n;++j){
						if(i==j) continue;
						int tmp=0;
						for(int k=1;k<=m;++k){
							(tmp+=A.a[i][k]*A.a[j][k])%=3;
						}
						if(tmp==0){
							printf("%d %d\n",min(i,j),max(i,j));
							return;
						}
					}
				}
			}
		}
		puts("-1 -1");
	}
}
int main(){
	n=read(),m=read(),k=read();
	if(k==2) sub2::main();
	else sub3::main();
	return 0;
}

```



---

## 作者：Maniac丶坚果 (赞：33)

//orz lych。 看了他的博客我才懂。

题目见洛谷P1224.

1.【60分做法】
暴力枚举每两对向量求解其乘积。

由于这部分暴力比较好写，代码略。

2.【70分做法】

加入较为naive的随机技巧。

首先枚举每个向量，对于每个向量随机500次找另外一个序号在其后面的向量判断是否合法。 实测能且只能多通过点13,14. 

代码。

```
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int maxn = 100010;
int n,d,K;
struct node{int d[105];}a[maxn];
inline int read()
{
    int x = 0, f = 1;
    char ch = 0;
    while (!isdigit(ch)) {ch = getchar(); if (ch == '-') f =-1;}
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    return x * f;
    
}
int main()
{
//	freopen("testd.in","r",stdin);
    n = read(), d = read(),K = read();
    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= d; ++j) a[i].d[j] = read(),a[i].d[j] %= K;
    }
    
    if (n <= 1000)
    {
        int ans = 0;
        for (int i = 1; i <= n; ++i)
        for (int j = i + 1; j <= n; ++j)
        {
            ans = 0;
            for (int k = 1; k <= d; ++k)
            ans += a[i].d[k] * a[j].d[k];
            if (ans % K == 0) {printf("%d %d\n",i,j); return 0;}
        }
        puts("-1 -1"); return 0;
    }
    else
    {
        int ans = 0;
        int now = 1;
        for (int i = 1; i < n - 100; ++i)
        {
            for (int j = 1; j <= min(250,n - i +1); ++j)
            {
                ans = 0;
                for(int k = 1; k <= d; ++k)
                ans += a[i].d[k] * a[i + now].d[k];
                if (ans % K == 0) {printf("%d %d\n",i,i + now); return 0;}
                now = (now * 7 + 13) % (n - i - 1) + 1;
                
            }
        }
        puts("-1 -1"); return 0;
    }
}
```

3. 【100分做法】

高超的姿势。

注意到k只能为2,3. 

试维护一个前缀。对于每个向量，我们试让他乘一次他前面所有向量的和。

当k = 2时，如果这个向量和前面所有向量的乘积都是1，那么这个和显然应该是等于(i - 1) & 1的。
注意这一步我们可以一边做一边枚举前缀和。复杂度是$O(nd)$的。

否则，一定在前面有一个向量和他乘积不是1. 一样可以使用$O(nd)$的时间找到和其配对的向量。

而当k = 3时，注意到当乘积不是0时只能为1,2（废话） 而1,2都可以在一次平方后对3去模为1. 

因此可以维护前缀平方和做一样的事情。复杂度是$O(nd^2)$的。

为了防止得到所有的和都等于(i - 1) & 1, 我们应该用random_shuffle对序列进行随机排列后做上述操作。~~（但实际上好像不用这么做也能AC这个题）~~

代码：
```
#include <bits/stdc++.h>
using namespace std;
const int maxn = 100010;
const int maxm = 105;
int n,m,mo,rand_now = maxn * 10, a[maxn][maxm],c[maxn][maxm],q[maxn];
int id[maxn],b[maxm];
inline int read()
{
	int x = 0,f = 1; char ch = getchar();
	for (; ch < 48 || ch > 57; ch = getchar()) if (ch == '-') f = -1;
	while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
	return x * f;
}
bool check(int x,int y)
{
	int tmp = 0;
	for (int i = 1; i <= m; ++i) tmp += a[x][i]*a[y][i];
	return (tmp%mo == 0);
}
int solve(int x)
{
	int ans = 0;
	if (mo == 2)
	for (int i = 1; i <= m; b[i] ^= a[x][i],i++) ans ^= b[i]&a[x][i];
	else
	for (int i = 1; i <= m; ++i)
	for (int j = 1; j <= m;c[i][j] += a[x][i] * a[x][j], j++)
	ans += c[i][j] * a[x][i] * a[x][j];
	return ans % mo;
}
int main()
{
	n = read(); m = read(), mo = read();
	for (int i = 1; i <= n; ++i)
	for (int j = 1; j <= m; ++j) a[i][j] = read() % mo;
	for (int i = 1; i <= n; ++i) id[i] = i;
	for (int kase = 1; kase <= 6; ++kase)
	{
		memset(b,0,sizeof(b));
		memset(c,0,sizeof(c));
		random_shuffle(id+1,id+n+1);
		for (int i = 1; i <= n; ++i)
		if (solve(id[i]) != (i - 1) % mo)
		for (int j = 1; j < i; ++j)
		if (check(id[i],id[j]))
		{
			if (id[i] > id[j]) swap(i,j);
			printf("%d %d\n",id[i],id[j]); return 0;
		}
	}
	puts("-1 -1");
}
```



---

## 作者：JasonL (赞：17)

### $NOI2013$ 向量内积

[题目链接](https://www.luogu.com.cn/problem/P1224)

#### 分析

对于前12个数据点我们可以直接暴力枚举。期望分数为60分.下面考虑数据点13~20.

首先，$n$个$d$维向量可以组成一个矩阵$A=\begin{Bmatrix}\vec a_1\\\vec a_2\\\cdots\\\vec a_n\end{Bmatrix}$.那么根据矩阵的性质，有

$AA^T=C$
,$C_{ij}=\vec a_i \vec a^T_j$

首先考虑模数为2的情况.
假若$A$中的向量任二的内积不为0，且$C_{ij}=\vec a_i \vec a^T_j \mod 2$,那么有
$C=E=\begin{Bmatrix}1&\dots &1\\\vdots&\ddots&\vdots\\1&\dots&1\end{Bmatrix}$

因而对于$k=2$的情况，我们只需要观察我们构造的矩阵$C$中是否存在$C_{ij}=0$即可.

然而问题在于数据量很大的情况下显然不可能使用$O(n^2d)$的矩阵乘法.因而我们考虑抽出一部分来进行检验。

首先我们打乱矩阵$A$中行向量的排列顺序。之后我们求出第$i$个行向量与前$i-1$个行向量的内积之和.显然有

$\sum\limits_{j=0}^{i-1} \vec a_i \vec a_j^T=\sum\limits_{j=0}^{i-1}\sum\limits_k a_{ik} a_{jk}=\sum\limits_k a_{ik}\sum\limits_{j=0}^{i-1} a_{jk}$ 

如果该行向量与前$i-1$个行向量的内积对2取余均不为0，那么内积对2取余后求和之值应为$i-1$.

我们令向量$\vec u=[\sum a_{i1} \sum a_{i2} \dots \sum a_{id} ]$，那么我们需要求出$\vec a_i$与$\vec u$的内积.

在取模意义下，当$\vec a_i \cdot \vec u \equiv i-1 \mod 2$时，有概率没有向量能与$\vec a_i$匹配.同时，当$\vec a_i \cdot \vec u \not\equiv i-1 \mod 2$时，必然存在一个行向量与$\vec a_i$匹配.此时我们逐一计算内积查找即可.

通过多次随机调整行向量的顺序，我们判定失败的概率就会大大减小.同时由于我们在计算时可以同时更新$\vec u$，因而总判定的时间复杂度为$O(nd)$.

对于模数为$3$的情况，我们考虑如何将内积的结果化为$01$形式（这样方便我们进行判定）。

我们发现，在取模意义下有
$1^2 \equiv 2^2 \mod 3$.因而我们只要计算内积的平方之和即可进行判定.此时有

$\sum\limits_{j=0}^{i-1} (\vec a_i \vec a_j^T)^2=\sum\limits_{j=0}^{i-1}\sum\limits_x\sum\limits_y a_{ix}a_{jx}a_{iy} a_{jy}=\sum\limits_x\sum\limits_y a_{ix}a_{iy}\sum\limits_{j=0}^{i-1} a_{jx}a_{jy}$ 

我们构造矩阵$S=\begin{Bmatrix}\sum a_{i1}a_{i1}&\dots&\sum a_{i1}a_{jd}\\\vdots&\ddots&\vdots\\\sum a_{id}a_{i1}&\dots&\sum a_{id}a_{id}\end{Bmatrix}$，逐项对应，做乘法即可.同样我们边乘边更新，时间复杂度为$O(nd^2)$.

（如此巧妙的判定~~我琢磨了好几个小时~~）

下面给出代码.其中每个变量的意义与题面及上方所述的变量一一对应.

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=101000,maxd=111;
int n,d,k;
int A[maxn][maxd],u[maxd],S[maxd][maxd],id[maxn];
inline int read(){
	int res=0;
	char ch=getchar(),ch1=ch;
	while(!isdigit(ch))ch1=ch,ch=getchar();
	while(isdigit(ch))
		res=(res<<3)+(res<<1)+ch-'0',ch=getchar();
	return ch1=='-'?-res:res;
}
bool check(int x,int y){
	int ans=0;
	for(register int i=1;i<=d;i++)
		ans+=A[x][i]*A[y][i];
	return ans%k;
}
int workadd(int x){
	int ans=0;
	if(k==2)
		for(register int i=1;i<=d;u[i]^=A[x][i],++i)
			ans^=A[x][i]&u[i];//模2时可以用位运算代替乘法与加法
	else
		for(register int i=1;i<=d;++i)
			for(register int j=1;j<=d;S[i][j]+=A[x][i]*A[x][j],++j)
				ans+=A[x][i]*A[x][j]*S[i][j]%k;
	return ans%k;
}
int main()
{
	n=read();d=read();k=read();
	for(register int i=1;i<=n;++i){
		id[i]=i;
		for(register int j=1;j<=d;++j)
			A[i][j]=read()%k;
	}
	for(register int T=0;T<6;++T){
		k==2?memset(u,0,sizeof(u)):memset(S,0,sizeof(S));
		random_shuffle(id+1,id+1+n);//调整行向量顺序
		for(register int i=1;i<=n;++i)
			if(workadd(id[i])!=(i-1)%k)
				for(register int j=1;j<i;++j)
					if(!check(id[i],id[j])){
						if(id[i]>id[j])swap(i,j);
						printf("%d %d\n",id[i],id[j]);
						return 0;
					}
	}
	puts("-1 -1");
	return 0;
}

```

---

## 作者：S1nner (赞：10)

总体来讲就是硬核模拟加各种优化，时间复杂度 $\Theta\left(\frac{n^2d}{\omega}\right)$

极限数据时间复杂度为 `1e10` 左右，所有点加起来 `5.67s` ，最后一个点 `3.70s`

如果仅仅是单纯的从前向后枚举，那么一定会被出题人卡的很惨，所以我们选择和出题人在心理上斗智斗勇，反着枚举，就可以较快的得到答案，然后 `return` 即可。

[提交记录](https://www.luogu.com.cn/record/31752821)


```cpp
#pragma GCC optimize("Ofast,inline,unroll-loops")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,avx,avx2,abm,mmx,popcnt,tune=native")
#include <bits/stdc++.h>

typedef long long i64;

namespace IO {
#ifdef LOCAL
#define gc getchar()
#else
#define gc pa == pb && (pb = (pa = buf) + fread(buf, 1, 1000000, stdin), pa == pb) ? EOF : *pa++
#endif
	char buf[1000000], *pa = buf, *pb = buf;
	template < typename T >
	inline void read(T &x) {
		x = 0; char c = gc;
		while (c != '-' && !isdigit(c)) c = gc;
		bool f = c == '-' ? c = gc, 1 : 0;
		while (isdigit(c)) x = x * 10 + c - 48, c = gc;
		if (f) x = -x;
	}
} using namespace IO;

int N, D, K;

namespace Subtask2 {
	const int MAXN = 2e4, MAXD = 100;
    std::bitset < MAXD > bits[MAXN];

    void solve() {
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < D; ++j) {
            	int x; read(x);
                bits[i][j] = x & 1;
            }
        }
        for (int i = N - 1; ~i; --i)
            for (int j = i + 1; j < N; ++j)
                if (!((bits[i] & bits[j]).count() & 1)) {
                    std::cout << i + 1 << ' ' << j + 1 << '\n';
                    return;
                }
        std::cout << -1 << ' ' << -1 << '\n';
    }
}

namespace Subtask3 {
	const int MAXN = 1e4, MAXD = 100, MAXV = 3e6;
	int val[MAXV + 1];
	int a[3], b[3];

    std::bitset < MAXD > bits1[MAXN], bits2[MAXN];

    void solve() {
    	for (int i = 1; i <= MAXV; ++i)
    		val[i] = val[i - 1] + 1, val[i] == 3 ? val[i] = 0 : 1;
    	a[0] = 0, a[1] = 1, a[2] = 1;
    	b[0] = 0, b[1] = 0, b[2] = 1;
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < D; ++j) {
                int x; read(x); x = val[x];
                bits1[i][j] = a[x], bits2[i][j] = b[x];
            }
        }
        for (int i = N - 1; ~i; --i)
            for (int j = i + 1; j < N; ++j)
                if(((bits1[i] & bits1[j]).count() + ((bits1[i] & bits1[j]) & (bits2[i] ^ bits2[j])).count()) % 3 == 0) {
                    std::cout << i + 1 << ' ' << j + 1 << '\n';
                    return;
                }
        std::cout << -1 << ' ' << -1 << '\n';
    }
}

namespace Subtask4 {
	const int MAXN = 1e5, MAXD = 30, MAXV = 10;
	int val[MAXV + 1];
	int a[3], b[3];

    std::bitset < MAXD > bits1[MAXN], bits2[MAXN];

    void solve() {
    	for (int i = 1; i <= MAXV; ++i)
    		val[i] = val[i - 1] + 1, val[i] == 3 ? val[i] = 0 : 1;
    	a[0] = 0, a[1] = 1, a[2] = 1;
    	b[0] = 0, b[1] = 0, b[2] = 1;
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < D; ++j) {
                int x; read(x); x = val[x];
                bits1[i][j] = a[x], bits2[i][j] = b[x];
            }
        }
        for (int i = N - 1; ~i; --i)
            for (int j = i + 1; j < N; ++j)
                if(((bits1[i] & bits1[j]).count() + ((bits1[i] & bits1[j]) & (bits2[i] ^ bits2[j])).count()) % 3 == 0) {
                    std::cout << i + 1 << ' ' << j + 1 << '\n';
                    return;
                }
        std::cout << -1 << ' ' << -1 << '\n';
    }
}

void input() {
    read(N), read(D), read(K);
}

void solve() {
    if (K == 2) Subtask2::solve();
    else if (N <= 1e4) Subtask3::solve();
    else Subtask4::solve();
}

void Main() {
    input();
    solve();
}

int main() {
    Main();
    return 0;
}
```


如果你认为你足够欧的话，也可以试下随机打乱，效果还不错 .

[随机4000ms跑满](https://www.luogu.org/recordnew/show/17923952)

[随机95分](https://www.luogu.org/recordnew/show/17927922)




---

## 作者：blng (赞：9)

## 题目：
### 题目链接：[向量内积](https://www.luogu.org/problemnew/show/P1224)


### 题解：
在源神的大力相助以及题解的帮助之下，我这个菜鸡终于懂了，太不容易了，想思路想了将近两个小时，太菜了(〃＞＿＜;〃)

还是想先手推一下样例：

1 0 1 0 1

1 1 0 1 0

0 1 0 1 1

则內积就为：

$1×0 + 1×1 + 0×0 + 1×1 + 0×1=2$ % $2=0$

所以，我们就需要从所有行中找到某二或三行中找到內积 $\%k=0$ 即可。

这样的话，由题意可知，$A·A^T$是一个01矩阵，我们就设一个全1的矩阵$C$，则$A\times A^T=C$，我们再设一个$1\times n$的矩阵（一行矩阵）$S$，则，$S\times(A\times A^T)=S \times C$ ,这样的话，我们就可以很容易的算出来$S\times C$，再对$S\times (A\times A^T)$进行展开优化即可。

但是，当$k=3$时该怎么办呢？

当$k=3$，的时候，这就不在是一个 $01$ 矩阵了，这就是一个 $012$ 的矩阵了，但是我们只需要记录下来0的可能就行，所以这该怎么办呢？

可以考虑一下，$2^x\equiv1(mod 3)$，那么x就肯定是2了，所以，我们就可以把情况转化为：将 $A$ ，$A^T$两者相乘之后再平方一下再$\%3$，这样的话就可以完全避免掉 $012$ 的矩阵，从而将$012$矩阵转化为$01$矩阵。这样就转化成了上面的形式。

说一下平方后的通项公式：
$$A×A^T=S_1=\sum_{k=1}^da_{ik}·a_{jk}$$
$$S_1^2=\sum_{k_1=1}^d\sum_{k_2=1}^da_{ik_1}·a_{jk_1}·a_{ik_2}·a_{jk_2}$$


这样就好了。

## 代码：
```c
#include<bits/stdc++.h>
using namespace std;
const int sea=100020;
int a[sea][110],n,m,k;
int S1[sea],S2[sea][110],id[sea];
inline int read()
{
	int s=0,w=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1; ch=getchar();}
	while(ch<='9'&&ch>='0')s=s*10+ch-'0',ch=getchar();
	return s*w;
}
int judge(int x,int y)//匹配 
{
	int s=0;
	for(int i=1;i<=m;i++) s+=a[x][i]*a[y][i];
	return (s%k==0);
}
int work(int x)
{
	int ans=0;
	if(k==2) //O（d）的匹配 
	for(int i=1;i<=m;S1[i]^=a[x][i],i++) ans^=(S1[i]&a[x][i]);
	else //O（d^2）的匹配 
		for(int i=1;i<=m;i++)
		for(int j=1;j<=m;S2[i][j]+=a[x][i]*a[x][j],j++)
		ans+=S2[i][j]*a[x][i]*a[x][j];//自己求通项 
	return ans%k;
}
int main()
{
	n=read(); m=read(); k=read();
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) a[i][j]=read()%k;
	for(int i=1;i<=n;i++) id[i]=i;
	int T=7;
	while(T--)
	{
		memset(S1,0,sizeof(S1));  memset(S2,0,sizeof(S2)); 
		random_shuffle(id+1,id+n+1);//随机数
		for(int i=1;i<=n;i++)  if(work(id[i])!=(i-1)%k)
		for(int j=1;j<i;j++)
		if(judge(id[i],id[j]))
		{
			if(id[i]>id[j]) swap(i,j);
			printf("%d %d\n",id[i],id[j]);
			return 0; 
		}
	}
	puts("-1 -1");
	return 0;
}
```

---

## 作者：louhao088 (赞：6)

一道非常巧妙的题。

判断一堆向量中两个向量点积是否是 2 或 3 的倍数，可以采用一个向量乘之前向量的平方的和。如果没有两个向量点积是否是 2 或 3 的倍数，那必然这个数模 k 必然等于 $(i-1)\mod k$ 。

证明如下：

若 $k=2$

因为其不为 k 的倍数。所以  $x \mod i=1$。

所以 $x^2 \mod i=1$。

若 $k=3$

因为其不为 k 的倍数。所以  $x \mod i=1$ 或 $2$。

所以 $x^2 \mod i=1$。

平方加和取模即为 $(i-1)\mod k$。

得证。

于是可以判断 $O(nd^2)$ 是否有。

若发现有可暴力求解 。


------------
代码如下


```cpp
#include<bits/stdc++.h>
using namespace std;
//static char buf[1000000],*p1=buf,*p2=buf;
//#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++
#define pi pair<int,int>
#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define ls (rt<<1)
#define rs (rt<<1|1)
#define mid (l+r>>1)
#define lowbit (x&-x)
const int maxn=1e5+5,M=34005;
inline int read()
{
	char ch=getchar();bool f=0;int x=0;
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	if(f==1)x=-x;return x;
}
inline void print(int x)
{
    static int a[55];int top=0;
    if(x<0) putchar('-'),x=-x;
    do{a[top++]=x%10,x/=10;}while(x);
    while(top) putchar(a[--top]+48);
}
int n,m,d,k,x,b[maxn][105],a[maxn][105],id[maxn],ans;
int get(int x)
{
	int ans=0;
	for(int i=1;i<=d;i++)
		for(int j=1;j<=d;b[i][j]+=a[x][i]*a[x][j],j++)
			ans+=a[x][i]*a[x][j]*b[i][j]%k;
	return ans%k;
}
int check(int x,int y)
{
	int res=0;
	for(int i=1;i<=d;i++)res+=a[x][i]*a[y][i]%k;
	return res%k;
}
signed main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	srand(time(0));
	n=read(),d=read(),k=read();
	for(int i=1;i<=n;i++)for(int j=1;j<=d;j++)a[i][j]=read()%k;
	for(int i=1;i<=n;i++)id[i]=i;
	for(int g=1;g<=7;g++)
	{
		memset(b,0,sizeof b);random_shuffle(id+1,id+n+1);
		for(int i=1;i<=n;i++)
		{
			int h=get(id[i]);
			if(h==((i-1)%k))continue;
			else
			{
				for(int j=1;j<i;j++)
					if(!check(id[i],id[j]))
						cout<<min(id[i],id[j])<<" "<<max(id[i],id[j])<<endl，exit(0);
			}
		}
	}
	puts("-1 -1");
 	return 0;
}


/*********************************************************************
    作者:louhao088
    日期: 2022-01-26 08:29
*********************************************************************/

```


---

## 作者：墨舞灵纯 (赞：4)

观察发现暴力很足，可以直接 $O(n^2d)$。

然后发现 $K=2$ 或 $K=3$ ，$K=2$ 可以用 $bitset$ 无脑草过去，复杂度 $O(\frac{n^2d}{w})$。

其实 $K=3$ 也可以解决。我们考虑 $\mod 3=0$ 的设为 $0$ 其余为 $1$ ，剩下的应该是 $1\times 2,2\times 1,1\times 1,2 \times 2 ,\mod 3=2,2,1,1$，就相当于我们少算了 $1\times 2,2\times 1$ ，那我们只要按照 $\mod 3==2$ 来分类就可以算出来有多少个没算的，补上就可以了。

直接枚举可能不太行，我们考虑随机打乱排列之类搞一搞就可以了。（这题貌似没有无解，因为我一开始看错题了，无解情况只输出了一个 `-1` ，也能过）

```cpp

#include <bits/stdc++.h>
using namespace std;
const int N = 100005;
int n, m, K, ans;
vector<int> a[N];
bitset<101> B[N];
bitset<31> B1[N], B2[N];
int main() {
    scanf("%d%d%d", &n, &m, &K);int i, j;
    for (i = 1; i <= n; ++i)
        for (j = 1, a[i].resize(m + 1); j <= m; ++j)
            scanf("%d", &a[i][j]);
    if (n <= 10000) {
        for (i = 1; i <= n; ++i)
            for (j = i + 1; j <= n; ++j) {
                register long long now = 0;
                for (int k = 1; k <= m; ++k)
                    now += (0ll + a[i][k]) * a[j][k];
                if (!(now % K))
                    return printf("%d %d", i, j), 0;
            }
        puts("-1 -1");
        return 0;
    }
    if (K == 2) {
        for (i = 1; i <= n; ++i)
            for (j = 1; j <= m; ++j)
                B[i][j] = (a[i][j] & 1);
        for (i = 1; i <= n; ++i)
            for (j = i + 1; j <= n; ++j)
                if (!((B[i]&B[j]).count() & 1))
                    return printf("%d %d", i, j), 0;
        puts("-1 -1");
        return 0;
    }
    if (K == 3) {
        static int id[N];
        for (i = 1; i <= n; ++i)
            id[i] = i;
        random_shuffle(id + 1, id + 1 + n);
        random_shuffle(id + 1, id + 1 + n);
        if (n == 100000)
            std::reverse(id + 1, id + 1 + n);
        for (i = 1; i <= n; ++i)
            for (j = 1; j <= m; ++j)
                a[i][j] %= 3, B1[i][j] = (a[i][j] != 0), B2[i][j] = (a[i][j] == 2);
        for (int ii = 1, jj; ii <= n; ++ii)
            for (jj = ii + 1; jj <= n; ++jj) {
                i = id[ii], j = id[jj];
                if ((((B1[i]&B1[j]).count()) + ((B1[i]&B1[j]) & (B2[i]^B2[j])).count()) % 3 == 0)
                    return printf("%d %d", i, j), 0;
            }
        puts("-1 -1");
        return 0;
    }
    return 0;
}

```



---

## 作者：封禁用户 (赞：4)

/\*
将n个向量写在一个n\*d的矩阵A中与它的转置矩阵相乘，得到A\*AT = B

这样矩阵B中任一元素Bi,j就是向量i与向量j的内积了，可以直接检查是否符合题意

但是这样做复杂度仍然是O(n^2\*d)，，无法通过

对于矩阵乘法操作的时候，顺便%k

那么，对于B中任一元素Bi,j，若其等于0，则说明i,j的内积符合题意

先考虑k == 2的时候怎么做

假设B是个全1矩阵，如果左右相等，那么不存在符合题意的i,j

否则如果Bi,j不为0，那么对于向量i，我们可以暴力O(n\*d)找出j

因为判断左右是否相等是可以O(n\*d)的，出错概率不超过1/2

做法是两边同时乘以一个1\*n的随机矩阵C，直接判结果是否相等

不过这样做要注意，Bi,i的值，这样的东西是不符合的，因此我们要强制让i,i的内积为1

这样只需左边做完特殊处理即可


如果k == 3，B不能用全1矩阵了，因为结果可能有2

但是2 ≡ -1(mod 3)

因此，如果我们将所有结果平方，那么B就能用全1矩阵了

不过此时是n\*(d^2)的矩阵与(d^2)\*n的矩阵相乘

因为


bzoj上该题题面有误，，比如存在n = 10000,d = 100的数据啦= =

然后就是时限略紧，原题每个点5s，但是bzoj18个点一共10s。。。。

苟蒻用剪枝 + 卡常3s过了

剪枝的话，左边的矩阵乘法一共要两次，进行到第二次的时候边做边判断，找到不合法马上跳到输出步骤

卡常的话，首先尽量减少%运算，因为这玩意略慢，然后用指针将二维数组变为一维，寻址快.

\*/
    
    
    
    
    
    
    
    
        
```cpp
//不要复制，这道题在洛谷上面只有90分！
#include<iostream>  
#include<cstdio>  
#include<cstring>  
#include<cstdlib>  
using namespace std;  
const int N = 1E5 + 10;  
int n,d,k,pos,g[N],Z[N],W[N],a[N][111],T[N],A[N],B[N];  
int Mul_Vector (int x,int y)  
{  
    int ret = 0,*nx = a[x],*ny = a[y];  
    for (int i = 1; i <= d; i++)  
        ret += nx[i]*ny[i];
    return ret%k;  
} 
void Print()  
{  
    for (int i = 1; i <= n; i++)  
        if (i != pos && Mul_Vector(pos,i) == 0)  
            {printf("%d %d\n",min(i,pos),max(i,pos)); return;}  
}  
void Solve2()  
{    
    for (int I = 1; I <= 10; I++)  
    {
        int tot = 0;  
        for (int i = 1; i <= n; i++)  
            T[i] = rand()%k,tot += T[i];  
        tot %= k;  
        for (int i = 1; i <= d; i++) W[i] = 0;  
        for (int i = 1; i <= n; i++) Z[i] = 0;
        for (int j = 1; j <= n; j++)
        {
            int *na = a[j];
            for (int i = 1; i <= d; i++) W[i] += T[j]*na[i];
        }  
        for (int i = 1; i <= d; i++) W[i] %= k;
        for (int i = 1; i <= n; i++)  
        {  
            int *na = a[i];
            for (int j = 1; j <= d; j++) Z[i] += W[j]*na[j];  
            Z[i] += (1-g[i])*T[i]; Z[i] %= k; Z[i] += k;  
            if (Z[i] % k != tot) {pos = i; Print(); return;}  
        }  
    }
    puts("-1 -1");  
}  
void Solve3()  
{  
    for (int i = 1; i <= n; i++) g[i] = g[i]*g[i]%k;
    int D = d*d;
    for (int i = 1; i <= D; i++)
    {
        int t = (i % d == 0)?i/d:i/d+1;
        A[i] = t; B[i] = i-(t-1)*d;
    }
    for (int I = 1; I <= 10; I++) 
    {
        int tot = 0;  
        for (int i = 1; i <= n; i++)  
            T[i] = rand()%k,tot += T[i];  
        tot %= k;  
        for (int i = 1; i <= D; i++) W[i] = 0;  
        for (int i = 1; i <= n; i++) Z[i] = 0;  
        for (int j = 1; j <= n; j++)
        {
            int *na = a[j];
            for (int i = 1; i <= D; i++) W[i] += T[j]*na[A[i]]*na[B[i]];
        }
        for (int i = 1; i <= D; i++) W[i] %= k;
        for (int i = 1; i <= n; i++)  
        {  
            int *na = a[i];
            for (int j = 1; j <= D; j++) Z[i] += W[j]*na[A[j]]*na[B[j]]; 
            Z[i] += (1-g[i])*T[i]; Z[i] %= k; Z[i] += k;  
            if (Z[i] % k != tot) {pos = i; Print(); return;}  
        }  
    }
    puts("-1 -1");  
}  
int getint()  
{  
    char ch = getchar();  
    int ret = 0;  
    while (ch < '0' || '9' < ch) ch = getchar();  
    while ('0' <= ch && ch <= '9')  
        ret = ret*10 + ch - '0',ch = getchar();  
    return ret;  
}  
int main()  
{  
    #ifdef DMC  
        freopen("DMC.txt","r",stdin);
    #endif  
    n = getint(); d = getint(); k = getint();
    for (int i = 1; i <= n; i++)  
        for (int j = 1; j <= d; j++)  
            a[i][j] = getint() % k;  
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= d; j++)
            g[i] += a[i][j]*a[i][j];
    for (int i = 1; i <= n; i++) g[i] %= k;
    if (k == 2) Solve2();  
    else Solve3();  
    return 0;  
}  

```

---

## 作者：serverkiller (赞：1)

**如果markdown裂开请进入blog食用**

我们知道两个向量的点乘就是一个向量乘另一个向量的转置矩阵

$$
x_i\cdot x_j=x_i^Tx_j
$$

那么整个矩阵$A$的情况 我们让他乘自己的转置矩阵 得到:

$$
B=AA^T
$$

大眼观察这个$B$ 我们发现对于这个$k=2$的情况 他本质是要求你$B$的每一个元素都是$1$

那我们大力乘出矩阵$B$来观察 复杂度$O(n^2d)$

~~于是我们有了一个和暴力复杂度相当的做法~~

因为本质上 矩阵$B$中的每一个元素就是你向量两两的点乘值

这不优秀的原因 在于我们的矩阵的大小是$n\times d$的 导致我们矩阵乘法的复杂度里面有个$n^2$ 但是我们注意到这个$d$非常的小

注意到 每两个向量的点乘是$O(d)$的

考虑这样一个东西:

$$
\sum_{i=1}^{t-1}x_i\cdot x_t=\sum_{i=1}^{t-1}\sum_{j=1}^da_{i,j}a_{t,j}=\sum_{i=1}^da_{t,i}\sum_{j=1}^{t-1}a_{i,j}
$$

我们维护每一维的前缀和 就可以在$O(nd)$的复杂度内得到某个向量和前面向量的点乘和

这个和如果不是$i - 1$ 那么必然有一个和这个向量点乘为$0$ 所以暴力跑一遍就好了

对于$k=2$ 我们得到了一个$O(nd)$的优秀算法

但是这个做法很难直接扩展到$k=3$ 因为我们有两个值$1,2$作为不符合的特征值

这个$2$恰恰是$1$在模$3$意义下的非平凡平方根 所以我们可以计算点乘的平方来进行判断

类似于一次的处理 把平方展开后 可以得到一个$O(nd^2)$的优秀做法

$$
\sum_{i=1}^{t-1}\sum_{j=1}^d(x_i \cdot x_j)^2=\sum_{i=1}^{d}\sum_{j=1}^da_{t,i}a_{t,j}\sum_{i=1}^{t-1}\sum_{j=1}^d\sum_{k=1}^da_{i,j}a_{i,k}
$$

我们要求的事实上是这两个:

$$
\sum_{i=1}^{t-1}(x_i\cdot x_t\%\ k)
$$

$$
\sum_{i=1}^{t-1}\sum_{j=1}^d((x_i \cdot x_j)^2 \%\ k)
$$

但是我们能求的是:

$$
\sum_{i=1}^{t-1}x_i\cdot x_t\%\ k
$$

$$
\sum_{i=1}^{t-1}\sum_{j=1}^d(x_i \cdot x_j)^2 \%\ k
$$

这就类似于一种Hash 比较%k意义下的$i - 1$和上面两式的值 当这两个值不同时一定有解 但当相等是不一定没有解 这就是这个做法的问题所在

有一个解决方法是选择random_shuffle 估算一下这个期望非常优秀 所以我们可以略多几次地随机化 得到答案 总复杂度$O(nd^2)$

代码有点丑 为了方便对拍贴一下:

```cpp
#include <bits/stdc++.h>
#define N 100005
#define M 105
using namespace std;

template <typename T>

void read(T &a)
{
	T x = 0,f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9')
	{
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	a = x * f;
}

template <typename T>

void write(T x)
{
	if (x < 0) putchar('-'),x = -x;
	if (x < 10) return (void) putchar(x + '0');
	write(x / 10);
	putchar(x % 10 + '0');
}

template <typename T>

void writeln(T x)
{
	write(x);
	putchar('\n');
}

template <typename T>

void writes(T x)
{
	write(x);
	putchar(' ');
}

template <typename T,typename... Args> 

void read(T &maxx,Args &... args)
{
	read(maxx);
	read(args...);
}

template <typename T,typename... Args>

void writes(T maxx,Args ... args)
{
	writes(maxx);
	writes(args...);
}

template <typename T,typename... Args>

void writeln(T maxx,Args ... args)
{
	writes(maxx);
	writes(args...);
	putchar('\n');
}

int n,d,k,a[N][M],id[N];

namespace sub1
{
	int sum[M];
	int clac(int x)
	{
		int ans = 0;
		for (int i = 1; i <= d; i++)
			ans += sum[i] * a[x][i];
		return ans % k;
	}
	int check(int x,int y)
	{
		int ans = 0;
		for (int i = 1; i <= d; i++)
			ans += a[x][i] * a[y][i] % k,ans %= k;
		return ans;
	}
	signed main()
	{
		for (int i = 1; i <= d; i++)
			sum[i] = a[1][i];
		for (int i = 2; i <= n; i++)
		{
			if (clac(i) == (i - 1) % k)
			{
				for (int j = 1; j <= d; j++)
					sum[j] = sum[j] + a[i][j];
				continue;
			}
			for (int j = 1; j < i; j++)
			{
				if (!check(i,j))
				{
					writeln(j,i);
					return 0;
				}
			}
		}
		puts("-1 -1");
		return 0;
	}
}

namespace sub2
{
	int sum[M][M];
	int clac(int x)
	{
		int ans = 0;
		for (int i = 1; i <= d; i++)
			for (int j = 1; j <= d; j++)
				ans = (ans + sum[i][j] * a[id[x]][i] % k * a[id[x]][j] % k) % k;
		return ans;
	}
	int check(int x,int y)
	{
		int ans = 0;
		for (int i = 1; i <= d; i++)
			ans += a[id[x]][i] * a[id[y]][i] % k,ans %= k;
		return ans;
	}
	signed main()
	{
		for (int i = 1; i <= d; i++)
			for (int j = 1; j <= d; j++)
				sum[i][j] = a[id[1]][i] * a[id[1]][j] % k;
		for (int i = 2; i <= n; i++)
		{
			if (clac(i) == (i - 1) % k)
			{
				for (int j = 1; j <= d; j++)
					for (int kk = 1; kk <= d; kk++)
						sum[j][kk] += a[id[i]][j] * a[id[i]][kk] % k,sum[j][kk] %= k;
				continue;
			}
			for (int j = 1; j < i; j++)
			{
				if (!check(i,j))
				{
					if (id[i] > id[j]) swap(id[i],id[j]);
					writeln(id[i],id[j]);
					exit(0);
				}
			}
			assert(0);
		}
		return 0;
	}
}

signed main()
{
	read(n,d,k);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= d; j++)
			read(a[i][j]),a[i][j] %= k;
	if (k == 2) sub1::main();
	else
	{
		for (int i = 1; i <= n; i++)
			id[i] = i;
		for (int i = 1; i <= 20; i++)
		{
			random_shuffle(id + 1,id + n + 1);
			sub2::main();
		}
		puts("-1 -1");
	}
	return 0;
}
```

---

## 作者：Mihari (赞：0)

注：本文代码在 Luogu 上只有最多九十分......但是在 LOJ 上可过 :)

# 壹、题目描述 &para;

[传送门 to LOJ](https://loj.ac/p/2664).

# 贰、题解 &para;

## ◆ 前言...

没想到这辈子还会这样大力分类讨论。（然后打了一个极长极冗杂的代码）

-----

## ◆ 从简单想起。

我们进行分类讨论，先看看 $k=2$ 的情况。

如果我们要大力判断两个向量相乘，记 $X$ 为原向量的堆叠矩阵，那么向量两两相乘的结果就是 $X\times X^T$. 但是暴力计算这个东西，时间复杂度达到惊人的 $\mathcal O(n^2)$.

但是，从另外一个方面想，如果不存在任意两个向量相乘在 $\bmod 2$ 下为 $0$，那么最后得到的 $XX^T$  势必等于 $11^T$，那么，我们可以从这方面入手。

我们可以随机向量 $\alpha$，判断 $\alpha XX^T$ 与 $\alpha 11^T$ 是否相同，如果存在某一位 $i$ 不同，那么一定是 $v_i$ 与某个向量相乘不为 $1$，再暴力判断即可。

计算 $\alpha XX^T$ 复杂度为 $\mathcal O(nd^2)$，而 $\alpha 11^T$ 怎么算不必我多说了吧，而暴力判断 $i$ 的部分复杂度为 $\mathcal O(nd)$，这样是可行的。

-----

## ◆ 归一！

但是，使用相同的方法在 $k=3$ 似乎就走不动了，因为余数不只是 $1$，还可能是 $2$.

但是，我们发现一个东西 —— $1^2\equiv2^2\equiv 1\pmod 3$，那么，继承相似的思路，我们得到 $XX^T$，然后将每一个位置上的数字取平方（注意，并不是 $(XX^T)^2$，是每个**位置**上的数自己的平方），然后再使用类似的思路计算。

-----

## ◆ 额外的问题？

但是，如何计算 $\alpha (XX^T)'$ 呢？我们考虑得到的是 $\beta$ 向量，那么
$$
\begin{aligned}
\beta_{j}&=\sum_i\alpha_i\times \left(\sum_{k}X_{i,k}X^T_{k,j}\right)^2 \\
&=\sum_i\alpha_i\times \left(\sum_{k}X_{i,k}X^T_{k,j}\right)\left(\sum_{k}X_{i,k}X^T_{k,j}\right) \\
&=\sum_i\alpha_i\times \sum_{k_1}\sum_{k_2}X_{i,k_1}X^T_{k_1,j}X_{i,k_2}X^T_{k_2,j} \\
&=\sum_i\sum_{k_1}\sum_{k_2}\alpha_iX_{i,k_1}X^T_{k_1,j}X_{i,k_2}X^T_{k_2,j} \\
&=\sum_{k_1}\sum_{k_2}X^T_{k_1,j}X^T_{k_2,j}\sum_i \alpha_iX_{i,k_1}X_{i,k_2} \\
\textbf{if }f(k_1,k_2)&\overset\Delta=\sum_i \alpha_iX_{i,k_1}X_{i,k_2}\quad\textbf{then } \\
\beta_j&=\sum_{k_1}\sum_{k_2}X^T_{k_1,j}X^T_{k_2,j}f(k_1,k_2)
\end{aligned}
$$
预处理 $f(k_1,k_2)$ 复杂度为 $\mathcal O(nd^2)$ 的，那么计算 $\beta_j$ 就是 $\mathcal O(d^2)$ 的，计算整个 $\beta$ 就是 $\mathcal O(nd^2)$ 的了。

# 叁、参考代码 &para;

```cpp
#pragma GCC optimize(2)
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
#include<ctime>
using namespace std;

// #define NDEBUG
#include<cassert>

namespace Elaina{
    #define rep(i, l, r) for(int i=(l), i##_end_=(r); i<=i##_end_; ++i)
    #define drep(i, l, r) for(int i=(l), i##_end_=(r); i>=i##_end_; --i)
    #define fi first
    #define se second
    #define mp(a, b) make_pair(a, b)
    #define Endl putchar('\n')
    #define mmset(a, b) memset(a, b, sizeof a)
    // #define int long long
    typedef long long ll;
    typedef unsigned long long ull;
    typedef pair<int, int> pii;
    typedef pair<ll, ll> pll;
    template<class T>inline T fab(T x){ return x<0? -x: x; }
    template<class T>inline void getmin(T& x, const T rhs){ x=min(x, rhs); }
    template<class T>inline void getmax(T& x, const T rhs){ x=max(x, rhs); }
    template<class T>inline T readin(T x){
        x=0; int f=0; char c;
        while((c=getchar())<'0' || '9'<c) if(c=='-') f=1;
        for(x=(c^48); '0'<=(c=getchar()) && c<='9'; x=(x<<1)+(x<<3)+(c^48));
        return f? -x: x;
    }
    template<class T>inline void writc(T x, char s='\n'){
        static int fwri_sta[1005], fwri_ed=0;
        if(x<0) putchar('-'), x=-x;
        do fwri_sta[++fwri_ed]=x%10, x/=10; while(x);
        while(putchar(fwri_sta[fwri_ed--]^48), fwri_ed);
        putchar(s);
    }
}
using namespace Elaina;

const int maxn=1e5;
const int maxd=1e2;

template<class T>struct matrix{
    int n, m;
    vector< vector<T> >a;
    inline matrix(){ n=m=0; a.clear(); }
    inline matrix(const int N, const int M): n(N), m(M){
        a=vector< vector<T> >(n);
        for(int i=0; i<n; ++i)
            a[i]=vector<T>(m, 0);
    }
    inline matrix epsilon(const int N){
        (*this)=matrix(N, N);
        for(int i=0; i<n; ++i) a[i][i]=1;
        return (*this);
    }
    inline matrix I(const int N){
        n=m=N;
        a=vector< vector<T> >(n);
        for(int i=0; i<n; ++i) a[i]=vector<T>(m, 1);
        return (*this);
    }
    inline matrix operator *(const matrix rhs) const{
        assert(m==rhs.n); matrix ret(n, rhs.m);
        for(int i=0; i<n; ++i) for(int j=0; j<m; ++j) if(a[i][j])
            for(int k=0; k<rhs.m; ++k)
                ret.a[i][k]+=a[i][j]*rhs.a[j][k];
        return ret;
    }
    inline bool operator ==(const matrix rhs) const{
        if(n!=rhs.n || m!=rhs.m) return false;
        for(int i=0; i<n; ++i) for(int j=0; j<m; ++j)
            if(a[i][j]!=rhs.a[i][j])
                return false;
        return true;
    }
    inline bool operator !=(const matrix rhs) const{
        return !((*this)==rhs);
    }
    inline void print() const{
        printf("N == %d, M == %d\n", n, m);
        for(int i=0; i<n; ++i){
            for(int j=0; j<m; ++j)
                writc(a[i][j], ' ');
            Endl;
        }
    }
};

matrix<int>A, B;
vector<int>x[maxn+5];

int n, d, k;

inline void input(){
    n=readin(1), d=readin(1), k=readin(1);
    for(int i=0; i<n; ++i){
        x[i].resize(d);
        for(int j=0; j<d; ++j)
            x[i][j]=readin(1)%k;
    }
    A=matrix<int>(n, d), B=matrix<int>(d, n);
    for(int i=0; i<n; ++i) A.a[i]=x[i];
    for(int j=0; j<n; ++j) for(int i=0; i<d; ++i)
        B.a[i][j]=x[j][i];
}

inline int getrnd(const int Mod){
    return (1ll*rand()*rand())%Mod;
}

inline matrix<int> randVec(){
    matrix<int>vec=matrix<int>(1, n);
    for(int i=0; i<n; ++i)
        vec.a[0][i]=getrnd(100);
    return vec;
}

namespace moduleEqualTwo{
    matrix<int>vec, H, G;
    inline void launch(){
        int p=-1;
        auto check=[&](){
            for(int i=0; i<n; ++i)
                if(H.a[0][i]%2!=G.a[0][i]%2){ p=i; return false; }
            return true;
        };
        auto mulI=[&](){
            int sum=0;
            for(int i=0; i<n; ++i)
                sum+=vec.a[0][i];
            matrix<int>ret(1, n);
            for(int i=0; i<n; ++i)
                ret.a[0][i]=sum;
            return ret;
        };
        rep(_, 1, 20){
            vec=randVec();
            H=vec*A*B, G=mulI();
            if(!check()) break;
        }
        if(p==-1) printf("-1 -1\n");
        else{
            auto vecMul=[](const int a, const int b){
                int ret=0;
                for(int i=0; i<d; ++i) ret+=x[a][i]*x[b][i]%k;
                return ret;
            };
            for(int i=0; i<n; ++i) if(i!=p && vecMul(p, i)%2==0){
                printf("%d %d\n", min(p+1, i+1), max(p+1, i+1)); return;
            }
        }
    }
}

namespace moduleEqualThree{
    matrix<int>vec, H, G;
    int F[maxd+5][maxd+5];
    inline void launch(){
        auto mulI=[&](){
            int sum=0;
            for(int i=0; i<n; ++i)
                sum=(sum+vec.a[0][i])%k;
            matrix<int>ret(1, n);
            for(int i=0; i<n; ++i)
                ret.a[0][i]=sum;
            return ret;
        };
        int p=-1;
        auto check=[&](){
            for(int i=0; i<n; ++i)
                if(H.a[0][i]%3!=G.a[0][i]%3){ p=i; return false; }
            return true;
        };
        rep(_, 1, 20){
            vec=randVec();
            G=mulI();
            for(int k1=0; k1<d; ++k1) for(int k2=0; k2<d; ++k2)
                for(int j=0; j<n; ++j)
                    F[k1][k2]=(F[k1][k2]+1ll*vec.a[0][j]*x[j][k1]%k*x[j][k2]%k)%k;
            H=matrix<int>(1, n);
            for(int i=0; i<n; ++i){
                for(int k1=0; k1<d; ++k1) for(int k2=0; k2<d; ++k2)
                    H.a[0][i]=(H.a[0][i]+1ll*x[i][k1]*x[i][k2]%k*F[k1][k2]%k)%k;
            }
            if(!check()) break;
        }
        if(p==-1) printf("-1 -1\n");
        else{
            auto vecMul=[](const int a, const int b){
                int ret=0;
                for(int i=0; i<d; ++i) ret=(ret+1ll*x[a][i]*x[b][i])%k;
                return ret;
            };
            // printf("p == %d\n", p);
            for(int i=0; i<n; ++i) if(vecMul(p, i)%3==0){
                printf("%d %d\n", min(p+1, i+1), max(p+1, i+1)); return;
            }
        }
    }
}

signed main(){
    // freopen("meow9.in", "r", stdin);
    srand((unsigned)time(NULL));
    // srand(114514);
    input();
    if(k==2) moduleEqualTwo::launch();
    else moduleEqualThree::launch();
    return 0;
}
```

# 肆、关键之处 &para;

在 $\bmod 3$ 下的一个特性 $1^2\equiv2^2\equiv 1\pmod 3$；

另外，从 $k=2$ 的简单想起也很重要，还有就是考察无解时的情形，对求解或许有必要的帮助。

---


# [ZJOI2008] 无序运动

## 题目描述

D 博士对物理有着深入的研究，经典物理、天体物理、量子物理都有着以他的名字命名的定理。最近 D 博士着迷于研究粒子运动的无规则性。对圣经深信不疑的他相信，上帝创造的任何事物必然是有序的、有理可循的，而不是无规则的、混沌的。

经过长时间的研究，D 博士找到了很多出现相当频繁的轨迹片断，他把这些轨迹片断储存在一个很大的数据库内。他需要你帮助他写一个程序，对于一个给出的粒子运动轨迹，统计数据库中每个轨迹片断的出现的次数。

为清楚起见，我们定义一个粒子的轨迹为二维平面上的一个点列 $(P_1, P_2, \dots, P_N)$。点列 $P$ 的一个子列 $[i, j]$ 定义为 $P$ 中一段连续的子序列 $(P_i, P_{i + 1}, \dots, P_j)$。点列 $P$ 的一个子列 $[u, v]$ 被称为点列 $Q = (Q_1, Q_2, \dots, Q_{v - u + 1})$ 在 $P$ 中的一次出现，当且仅当 $Q$ 经过有限次的平移、旋转、翻转、放缩之后得到 $Q'$ 满足 $\forall 1 \le k \le u - v + 1$，$ Q'_k = P_{u + k - 1}$。

对点列进行四种操作的解释：
|操作名称|解释|
|:-:|:-:|
|平移|设平移向量为 $(d_x, d_y)$，则任意点 $(x, y)$ 平移后的结果为 $(x + d_x, y + d_y)$|
|旋转|设旋转角为 $t$，则任意点 $(x, y)$ 旋转后的结果为 $(x \cos t - y \sin t, x \sin t + y \cos t)$|
|翻转|任意点 $(x, y)$ 翻转后的结果为 $(x, -y)$
|放缩|设放缩比例为 $p(p \ne 0)$，则任意点 $(x, y)$ 放缩后的结果为 $(px, py)$|

## 说明/提示

记片段总长度为 $L$。

对于 $30\%$ 的测试数据，满足 $N, M, K \le 100$，$L \le 500$;

对于 $50\%$ 的测试数据，满足 $N, M, K \le 1000$，$L \le 5000$;

对于 $100\%$ 的测试数据，满足 $N, K \le 2 \times 10 ^ 5$，$L \le 2 \times 10 ^ 6$，保证输入中给出所有点坐标绝对值均不大于 $10 ^ 4$。

## 样例 #1

### 输入

```
3 2
2 17 0 10 1
3 0 0 1 0 1 -1
0 0 1 0 1 1
```

### 输出

```
2
1
```

# 题解

## 作者：Hoks (赞：3)

## 前言
挺有意思的一道题，但是因为我不会向量而止步。

建议先自己画图思考一二。
## 思路分析
~~看到题意的时候就感觉很烦。~~

下面简称题目中所说的 $Q$ 经过有限次的平移、旋转、翻转、放缩之后得到 $Q'$ 为 $Q$ 与 $Q'$ **相似**。

首先关注到的事操作里有个翻转，也就是沿 $x$ 轴对称。

先考虑把这个操作拆出去，直接把轨迹根据 $x$ 轴对称一次。

但这样可能会产生重复，暂且先不考虑，合并入如何判断两段轨迹**相似**。

不难发现，不管如何旋转，平移，**线段的长度**和**线段间的夹角大小**是不会改变的。

所以考虑通过**线段长度**和**线段间夹角大小**来判断**相似**。

又因为题目中还有**缩放**操作，所以我们用于比较的应该是**线段长度间的比例**而不是其**长度**。

这里就已经发现了一个比较难处理的东西：如何求**线段间的夹角大小**。

考虑**向量**：使用向量间的**点积**和**叉积**来等效替换**线段间的夹角大小**。

因为我们只考虑是否相等，所以直接表示判断即可，还可以避免精度问题。

而长度间比例如果考虑用浮点数存，可能也会有精度误差。

类似于上面的原因，因为只判重所以直接平方转化为分数即可（记得化为最简分数）。

接着考虑怎么找出现次数。

因为**线段长度间的比例**和**线段间的夹角大小**都是存在于线段之间的，所以若我们把一条线段看做一个点，上述两个东西便是存在于两点之间的边。

那这玩意又会联想到什么？

**ACAM！**

考虑把每一种轨迹都扔进 ACAM 里去，**线段长度间的比例**和**线段间的夹角大小**便成了 ACAM 里的转移状态函数。

考虑用 map 把这玩意存一下建出 ACAM。

又因为其中的字符集非常大，所以不能用正常的建 Fail 指针方法，只能采取暴力跳。

然后对于查询串一路在 ACAM 上跳查询即可。

而对于最前面的重复贡献问题，我们只需要在计算**线段间的夹角大小**时判断下与 $x$ 轴对称后的轨迹是否**相似**即可。

实现的时候注意细节。~~笔者打错个数组名挂 $70$ 好久。~~
## 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+10,INF=0x3f3f3f3f3f3f3f3f,mod=998244353;
struct node{int a,b,c,d;bool operator<(const node&x) const{return (x.a^a)?a<x.a:(x.b^b)?b<x.b:(x.c^c)?c<x.c:d<x.d;}}a[N];
struct Point
{
	int x,y;
	inline Point operator-(const Point&a){return (Point){x-a.x,y-a.y};}
	inline int operator*(const Point&a){return x*a.y-y*a.x;}
	inline int operator^(const Point&a){return x*a.x+y*a.y;}
}s[N];
int n,m,inv[N],tag[N],ans[N];
struct ACAM
{
	map<node,int>t[N];int tot=0,nxt[N],lst[N],cnt[N];vector<int>ed[N];
	inline void insert(node s[],int n,int id)
	{
		int u=0;
		for(int i=1;i<=n;i++)
		{
			auto v=t[u].find(s[i]);
			if(v==t[u].end()) t[u][s[i]]=++tot,u=tot;
			else u=v->second;
		}
		ed[u].emplace_back(id);
	}
	inline void build()
	{
		queue<int>q;for(auto v:t[0]) q.push(v.second);
		while(!q.empty())
		{
			int u=q.front();q.pop();
			for(auto [x,v]:t[u])
			{
				int f=nxt[u];
				for(;f&&t[f].find(x)==t[f].end();f=nxt[f]);
				if(t[f].find(x)!=t[f].end()) f=t[f][x];nxt[v]=f;
				lst[v]=ed[f].empty()?lst[f]:f;q.push(v);
			}
		}
	}
	inline void solve()
	{
		int u=0;
		for(int i=1;i<n-1;i++)
		{
			int v=u;
			for(;v&&t[v].find(a[i])==t[v].end();v=nxt[v]);
			if(t[v].find(a[i])!=t[v].end()) v=t[v][a[i]];u=v;
			for(;v;v=lst[v]) cnt[v]++;
		}
	}
}ac;
namespace fast_IO
{
	static char buf[1000000],*paa=buf,*pd=buf;
	#define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
	inline int read()
	{
		int x(0),t(1);char fc(getchar());
		while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
		while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
		return x*t;
	}
	inline void print(int x)
	{
		if(x<0) putchar('-'),x=-x;
		if(x>9) print(x/10);
		putchar(x%10+'0');
	}
	inline bool chk(char c) { return !(c>='A'&&c<='Z'); }
	inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1&&c!=' '; }
	inline void rd(char s[],int&n)
	{
		s[++n]=getchar();
		while(chk(s[n])) s[n]=getchar();
		while(ck(s[n])) s[++n]=getchar();
		n--;
	}
}using namespace fast_IO;
inline node tran(Point a,Point b,Point c)
{
	node res;res.a=(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);
	res.b=(b.x-c.x)*(b.x-c.x)+(c.y-b.y)*(c.y-b.y);
	res.c=(c-b)*(b-a);res.d=(c-b)^(b-a);
	int gcd=__gcd(res.a,res.b);res.a/=gcd,res.b/=gcd;
	gcd=__gcd(abs(res.c),abs(res.d));res.c/=gcd;res.d/=gcd;return res;
}
signed main()
{
	n=read(),m=read();
	for(int i=1,k,f;i<=m;i++)
	{
		k=read();f=0;for(int j=1;j<=k;j++) s[j].x=read(),s[j].y=read();
		for(int j=2;j<k;j++) a[j-1]=tran(s[j-1],s[j],s[j+1]),f|=bool(a[j-1].c);inv[i]=(!f)+1;
		if(k<3) tag[i]=k;else ac.insert(a,k-2,i);
	}ac.build();
	for(int i=1;i<=n;i++) s[i].x=read(),s[i].y=read();
	for(int i=2;i<n;i++) a[i-1]=tran(s[i-1],s[i],s[i+1]);
	ac.solve();for(int i=1;i<=n;i++) s[i].x*=-1;
	for(int i=2;i<n;i++) a[i-1]=tran(s[i-1],s[i],s[i+1]);ac.solve();
	for(int i=1;i<=ac.tot;i++) for(auto v:ac.ed[i]) ans[v]+=ac.cnt[i]/inv[v];
	for(int i=1;i<=m;i++) print(tag[i]?n-tag[i]+1:ans[i]),puts("");
	return 0;
}
```

---

## 作者：Hyscere (赞：3)

考虑如果能匹配上，那么两个图形必定相似。

所以一个很简单的想法就是：记录相邻两条边的边长之比和夹角。

但是这样显然由于精度过低，不可行。所以修改一下记录的东西就变成了：

记录两边的边长平方的最简比和带符号的两边向量点积叉积最简比，一共四个整数。

注意这里先不管翻转操作，如果带上翻转操作的话，把匹配串翻一下再做一遍就好了。

然后建$AC$自动机，用$map$存边，把串丢上去跑就行了。

由于这里字符集过大只能暴力跳$fail$指针。

看起来能过就行了（逃。

```c++
#include<bits/stdc++.h>
using namespace std;
 
void read(int &x) {
    x=0;int f=1;char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;
}
 
void print(int x) {
    if(x<0) putchar('-'),x=-x;
    if(!x) return ;print(x/10),putchar(x%10+48);
}
void write(int x) {if(!x) putchar('0');else print(x);putchar('\n');}

const int maxn = 2e5+10;

#define sqr(x) ((x)*(x))

int n,m,spj[maxn],tot,fail[maxn],cnt[maxn],lst[maxn],ans[maxn],tp[maxn];

struct point {
	int x,y;
	point operator - (const point &rhs) const {return (point){x-rhs.x,y-rhs.y};}
	int operator * (const point &rhs) const {return x*rhs.y-y*rhs.x;}
	int operator ^ (const point &rhs) const {return x*rhs.x+y*rhs.y;}
}s[maxn];

struct node {
	int a,b,c,d;
	bool operator < (const node &rhs) const {
		if(a!=rhs.a) return a<rhs.a;
		if(b!=rhs.b) return b<rhs.b;
		if(c!=rhs.c) return c<rhs.c;
		return d<rhs.d;
	}
}r[maxn];

map<node,int > e[maxn];
vector <int > ed[maxn];

#define iter map<node,int > :: iterator 

void ins(int w,int rs) {
	int now=0;
	for(int i=1;i<=w;i++) {
		iter it=e[now].find(r[i]);
		if(it==e[now].end()) now=(e[now][r[i]]=++tot);
		else now=it -> second;
	}ed[now].push_back(rs);
}

void build() {
	queue<int > q;
	for(iter i=e[0].begin();i!=e[0].end();i++) q.push(i -> second);
	while(!q.empty()) {
		int now=q.front();q.pop();
		for(iter i=e[now].begin();i!=e[now].end();i++) {
			node a=i -> first;int b=i -> second,c=fail[now];
			for(;c&&e[c].find(a)==e[c].end();c=fail[c]);
			if(e[c].find(a)!=e[c].end()) c=e[c][a];fail[b]=c;
			lst[b]=ed[c].empty()?lst[c]:c;q.push(b);
		}
	}
}

node trans(point A,point B,point C) {
	int a=sqr(B.x-A.x)+sqr(B.y-A.y);
	int b=sqr(C.x-B.x)+sqr(C.y-B.y);
	int c=(C-B)*(B-A),d=(C-B)^(B-A);
	int t=__gcd(a,b);a/=t,b/=t;t=__gcd(abs(c),abs(d)),c/=t,d/=t;
	return (node){a,b,c,d};
}

void solve() {
	int now=0;
	for(int i=1;i<=n-2;i++) {
		int x=now;
		for(;x&&e[x].find(r[i])==e[x].end();x=fail[x]);
		if(e[x].find(r[i])!=e[x].end()) x=e[x][r[i]];now=x;
		for(;x;x=lst[x]) cnt[x]++;
	}
}

int main() {
	read(n),read(m);
	for(int i=1;i<=m;i++) {
		int k,flag=1;read(k);
		for(int j=1;j<=k;j++) read(s[j].x),read(s[j].y);
		for(int j=2;j<k;j++) {
			r[j-1]=trans(s[j-1],s[j],s[j+1]);
			if(r[j-1].c) flag=0;
		}
		if(flag) spj[i]=1;
		if(k-2>0) ins(k-2,i),tp[i]=-1;else tp[i]=k;
	}
	build();
	for(int i=1;i<=n;i++) read(s[i].x),read(s[i].y);
	for(int i=2;i<n;i++) r[i-1]=trans(s[i-1],s[i],s[i+1]);
	solve();
	for(int i=1;i<=n;i++) s[i].x=-s[i].x;
	for(int i=2;i<n;i++) r[i-1]=trans(s[i-1],s[i],s[i+1]);
	solve();
	for(int i=1;i<=tot;i++)
		for(int j=0;j<(int)ed[i].size();j++) ans[ed[i][j]]+=cnt[i]/(spj[ed[i][j]]+1);
	for(int i=1;i<=m;i++) write(tp[i]>=0?n-tp[i]+1:ans[i]);
	return 0;
}
```

---

## 作者：Alex_Wei (赞：2)

> [P2603 [ZJOI2008] 无序运动](https://www.luogu.com.cn/problem/P2603)

这道题的关键在于如何处理两个粒子片段相似。设两粒子片段分别为 $(a_1, \cdots, a_k)$ 和 $(b_1, \cdots, b_k)$，设 $A_i = \overrightarrow{a_ia_{i + 1}}$，记 $f(a) = A$，$B_i$ 同理，得到两个向量序列 $A, B$。

容易得知，**不考虑翻转时**，$a$ 相似于 $b$ 当且仅当对于任意 $i\in [1, k - 2]$，有序对 $(A_i, A_{i + 1})$ 和 $(B_i, B_{i + 1})$ 相似，体现为它们的长度比相等 $\dfrac {|A_i|}{|A_{i + 1}|} = \dfrac {|B_i|}{|B_{i + 1}|}$，且 **有向** 夹角相等 $\lang A_i, A_{i + 1}\rang = \lang B_i, B_{i + 1}\rangle$。

用浮点数记录上述信息丢失精度，考虑记录向量长度的平方比，以及向量叉积与点积的比。一个细节，就是叉积比点积得到夹角正切值，但 $\tan$ 的周期是 $\pi$，无法唯一对应一个 $2\pi$ 范围内的角度。此时我们需要保留叉积的符号，即约分时最大公约数取绝对值。

考虑翻转只需将 $a_i$ 关于 $x$ 或 $y$ 轴对称，再做一遍上述判定即可。

因此，我们得到如下算法：用相邻向量之间的信息描述所有片段和粒子运动轨迹。类似字符串匹配，将信息离散化后容易使用 SA 或 AC 自动机求出每个片段在粒子运动轨迹和粒子运动轨迹关于 $y$ 轴对称得到的轨迹中出现次数之和。

注意点：

- 特判 $k = 2$。
- 当某个片段翻转后与它本身不考虑翻转相似时，它在原粒子运动轨迹中每出现一次均会在翻转后的粒子运动轨迹的对应位置出现，被重复计算。因此要除以 $2$。

时间复杂度 $\mathcal{O}((N + L) \log (n + L))$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
using ll = long long;
using pii = pair<int, int>;
inline int read() {
  int x = 0, sgn = 0;
  char s = getchar();
  while(!isdigit(s)) sgn |= s == '-', s = getchar();
  while(isdigit(s)) x = x * 10 + s - '0', s = getchar();
  return sgn ? -x : x;
}
bool Mbe;
constexpr int N = 1e5 + 5;
constexpr int L = 2e6 + 5;
int len, s[L];
int sa[L], rk[L], ork[L], buc[L], id[L], ht[L];
bool cmp(int a, int b, int w) {return ork[a] == ork[b] && ork[a + w] == ork[b + w];}
void build(int n) {
  int m = N - 1, p = 0;
  for(int i = 1; i <= n; i++) buc[rk[i] = s[i]]++;
  for(int i = 1; i <= m; i++) buc[i] += buc[i - 1];
  for(int i = n; i; i--) sa[buc[rk[i]]--] = i;
  for(int w = 1; ; w <<= 1, m = p, p = 0) {
    for(int i = n - w + 1; i <= n; i++) id[++p] = i;
    for(int i = 1; i <= n; i++) if(sa[i] > w) id[++p] = sa[i] - w;
    memset(buc, 0, sizeof(buc));
    memcpy(ork, rk, sizeof(rk));
    p = 0;
    for(int i = 1; i <= n; i++) buc[rk[i]]++;
    for(int i = 1; i <= m; i++) buc[i] += buc[i - 1];
    for(int i = n; i; i--) sa[buc[rk[id[i]]]--] = id[i];
    for(int i = 1; i <= n; i++) rk[sa[i]] = cmp(sa[i - 1], sa[i], w) ? p : ++p;
    if(p == n) break;
  }
  for(int i = 1, k = 0; i <= n; i++) {
    if(k) k--;
    while(s[i + k] == s[sa[rk[i] - 1] + k]) k++;
    ht[rk[i]] = k;
  }
}
struct dat {
  int L1, L2;
  ll cross, dot;
  void form(pii a, pii b) {
    int ax = a.fi, ay = a.se, bx = b.fi, by = b.se;
    L1 = ax * ax + ay * ay;
    L2 = bx * bx + by * by;
    cross = ax * by - ay * bx;
    dot = ax * bx + ay * by;
    ll d = __gcd(L1, L2);
    L1 /= d, L2 /= d;
    d = abs(__gcd(cross, dot));
    cross /= d, dot /= d;
  }
  bool operator < (const dat &rhs) const {
    if(L1 != rhs.L1) return L1 < rhs.L1;
    if(L2 != rhs.L2) return L2 < rhs.L2;
    if(cross != rhs.cross) return cross < rhs.cross;
    return dot < rhs.dot;
  }
  bool operator == (const dat &rhs) const {
    return L1 == rhs.L1 && L2 == rhs.L2 && cross == rhs.cross && dot == rhs.dot;
  }
} d[L];
int n, m, cnt;
int fa[L], val[L];
int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);}
void merge(int u, int v) {val[u = find(u)] += val[v = find(v)], fa[v] = u;}
int pos[N], ans[N], sym[N];
vector<dat> seq[N];
bool Med;
int main() {
  fprintf(stderr, "%.4lf MB\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    freopen("1.in", "r", stdin);
    freopen("1.out", "w", stdout);
  #endif
  cin >> n >> m;
  assert(n > 2);
  for(int i = 1; i <= m + 1; i++) {
    int k = i <= m ? read() : n;
    assert(k > 1);
    vector<pii> pt;
    pt.reserve(k);
    int lx = read(), ly = read();
    for(int j = 1; j < k; j++) {
      int cx = read(), cy = read();
      pt.push_back((pii) {cx - lx, cy - ly});
      lx = cx, ly = cy;
    }
    if(k == 2 && i <= m) {
      ans[i] = n - 1;
      continue;
    }
    vector<dat> norm, refl;
    for(int p = 1; p < pt.size(); p++) {
      dat res;
      res.form(pt[p - 1], pt[p]);
      norm.push_back(d[++cnt] = res);
    }
    for(pii &it : pt) it.fi = -it.fi;
    for(int p = 1; p < pt.size(); p++) {
      dat res;
      res.form(pt[p - 1], pt[p]);
      refl.push_back(res);
    }
    seq[i] = norm, sym[i] = norm == refl;
    if(i == m + 1) {
      for(dat it : refl) d[++cnt] = it;
      seq[i + 1] = refl;
    }
  }
  sort(d + 1, d + cnt + 1);
  cnt = unique(d + 1, d + cnt + 1) - d - 1;
  for(int i = 1; i <= m + 2; i++) {
    pos[i] = len + 1;
    for(dat it : seq[i]) s[++len] = lower_bound(d + 1, d + cnt + 1, it) - d;
    s[++len] = cnt + i;
  }
  build(len);
  static int p[L], q[N];
  for(int i = 1; i <= m; i++) q[i] = i;
  for(int i = 1; i <= len; i++) val[i] = sa[i] >= pos[m + 1], fa[i] = p[i] = i;
  sort(p + 1, p + len + 1, [&](int u, int v) {return ht[u] > ht[v];});
  sort(q + 1, q + m + 1, [&](int u, int v) {return seq[u].size() > seq[v].size();});
  for(int i = N - 1, ppt = 1, qpt = 1; i; i--) {
    while(ppt <= len && ht[p[ppt]] == i) merge(p[ppt], p[ppt] - 1), ppt++;
    while(qpt <= m && seq[q[qpt]].size() == i) ans[q[qpt]] = val[find(rk[pos[q[qpt]]])], qpt++;
  }
  for(int i = 1; i <= m; i++) printf("%d\n", ans[i] / (sym[i] ? 2 : 1));
  return cerr << "Time: " << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n", 0;
}
/*
2022/7/13
start coding at 13:13
finish debugging at 20:02
*/
```

---

## 作者：a326820068122c (赞：0)

通过数据
$N \le200 000,\Sigma K \le 200 000$。

猜想：这是一道 AC 自动机。

不难发现，两个图形“相似”就可以被互相平移、旋转、翻转、放缩到，否则就不能被平移、旋转、翻转、放缩到。

相似具体来说就是现将相邻点连成向量，如果两个相邻两个向量比例相同并且每个夹角相等或者每个夹角相反。

所以一个很简单的想法就是：直接记录相邻两条边的边长之比和夹角。

然而这样 AC 自动机的 `map` 里要开一个 `pair<double,double>` 不太舒服，可以考虑把它们 hash 成一个数。

但是这样 `double` 容易爆精度，所以开 `long double` 就可以了。

注意细节

一，`map` 查找浮点数要用 `lower_bound(x-eps)` 的方法，直接查询容易掉精度。

二，如果一个图形要翻转后和原来不同，代价为 AC 自动机两个的出现次数之和，否则就是原来那一个。

其他就是 AC 自动机的板子了，大概这题差不多。

https://www.luogu.com.cn/problem/P5357

放一下代码：

```cpp
#include <bits/stdc++.h>
#define for1(i,n) for(i=1;i<=(n);i++)
using namespace std;
const int N=400005;
typedef long double db;
const db pi=acosl(-1),eps=1e-10;
int n,m,ans[N],w1[N],w2[N],xx[N],yy[N],dp[N],cp,q[N],f[N],lq,rq;
db s[N],e[N];
map<db,int> a[N];
bool dy(db x,db y){
	return abs(x-y)<eps;
}
bool cz(int p,db x){
	return !a[p].empty()&&dy(a[p].lower_bound(x-eps)->first,x);
}
db g(db x){
	if(dy(x,2*pi)) return 0;
	if(x<-eps) return x+2*pi;
	return x;
}
db h(db x){
	if(dy(x,2*pi)) return 0;
	return x;
}
int gt(int p,db x){
	if(!cz(p,x)) a[p][x]=++cp;
	return a[p].lower_bound(x-eps)->second;
}
int main(){
	int i,j,z,p;
	bool b;
	scanf("%d%d",&n,&m);
	for1(i,m){
		scanf("%d",&z);
		for1(j,z) scanf("%d%d",&xx[j],&yy[j]);
		if(z<=2){
			ans[i]=n-z+1;
			continue;
		}
		for1(j,z-1){
			xx[j]=xx[j+1]-xx[j],yy[j]=yy[j+1]-yy[j];
			e[j]=xx[j]*xx[j]+yy[j]*yy[j],s[j]=atan2l(yy[j],xx[j]);
		}
		p=0;b=0;
		for1(j,z-2){
			s[j]=g(s[j+1]-s[j]),e[j]=e[j+1]/e[j];
			p=gt(p,e[j]*10+s[j]);b|=!dy(s[j],0)&&!dy(s[j],pi);
		}
		w1[i]=p;
		if(b){
			p=0;
			for1(j,z-2) p=gt(p,e[j]*10+h(2*pi-s[j]));
			w2[i]=p;
		}
	}
	while(lq<=rq){
		p=q[lq++];
		for(auto v:a[p]){
			if(p){
				z=f[p];
				while(z&&!cz(z,v.first)) z=f[z];
				if(cz(z,v.first)) f[v.second]=gt(z,v.first);
			}
			q[++rq]=v.second;
		}
	}
	for1(i,n) scanf("%d%d",&xx[i],&yy[i]);
	for1(j,n-1){
		xx[j]=xx[j+1]-xx[j],yy[j]=yy[j+1]-yy[j];
		e[j]=xx[j]*xx[j]+yy[j]*yy[j],s[j]=atan2l(yy[j],xx[j]);
	}
	p=0;
	for1(j,n-2){
		s[j]=g(s[j+1]-s[j]),e[j]=e[j+1]/e[j]*10+s[j];
		while(p&&!cz(p,e[j])) p=f[p];
		if(cz(p,e[j])) p=gt(p,e[j]);
		else p=0;
		dp[p]++;
	}
	for(i=rq;i;i--) dp[f[q[i]]]+=dp[q[i]];
	dp[0]=0;
	for1(i,m) printf("%d\n",ans[i]+dp[w1[i]]+dp[w2[i]]);
	return 0;
}
```

---

## 作者：老莽莽穿一切 (赞：0)

[更好的阅读体验](https://www.cnblogs.com/LaoMang-no-blog/p/16496538.html)

---

[**你谷 link**](https://www.luogu.com.cn/problem/P2603)

一道蛮模版的字符串题，只需要一步非常显然的转化。

首先思考如果无视四种操作该怎么做，如果将每一个点看成是一个**字符**，那么就是给定一个文本串，多个模式串，求每个模式串在文本串里出现几次，这显然是一个字符串的模板题，可以使用 AC 自动机，也可以使用诸如后缀数组、后缀树、后缀自动机之类的后缀数据结构维护，这里不多做赘述，可以转到你谷模板题自行学习。

那么就是转化四种操作，考虑平移和旋转就是无视了绝对位置，缩放就是不关心绝对距离，翻转我们最后处理。

既然不关心绝对距离和绝对位置，我们就可以考虑现将相邻两点连线，然后存向量，转化为向量，发现再绝对的数值失去作用后，我们只能将相邻两向量的关系存下来，显然我们需要存长度的比值和夹角，如果用 `double` 存精度肯定没有保证，我们可以选择使用整数存下来，长度的比值我们可以直接以分数形式记录，夹角我们知道任意一个角都可以用**一组正弦和余弦值**唯一确定，而再向量中，我们知道点积和叉积是与正余弦相关的，但是我们只关心夹角，同理我们将正弦和余弦约分，即同时除以它们的最大公因数，正确性证明显然。

那么我们对于相邻的三个点求出两个向量，再对两个向量求出长度的比值和点叉积的比值，以四元组形式存下来作为“字符”，可以用 c++ 内置的 `tuple` 存储，各种自动机的转移边可以利用 `map` 来实现。

这里我选择用符合思维惯性的后缀自动机实现，在翻转方面，直接将**给定的模式串原串**翻转后重新求四元组序列，如果和原串的四元组序列相同（这种情况即给定的所有点共线），则不需要再管翻转，否则再跑一边，将两次的答案加起来，显然不会有重，注意特判只给了两个点的情况。

[c++ 代码](https://www.cnblogs.com/LaoMang-no-blog/p/16496538.html)

---


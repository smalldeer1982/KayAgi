# [USACO23OPEN] Good Bitstrings P

## 题目描述

对于任意两个正整数 $a$ 和 $b$，定义函数 `gen_string(a,b)` 如下 Python 代码所示：

```python
def gen_string(a: int, b: int):
	res = ""
	ia, ib = 0, 0
	while ia + ib < a + b:
		if ia * b <= ib * a:
			res += '0'
			ia += 1
		else:
			res += '1'
			ib += 1
	return res
```

等效的 C++ 代码如下：

```cpp
string gen_string(int64_t a, int64_t b) {
	string res;
	int ia = 0, ib = 0;
	while (ia + ib < a + b) {
		if ((__int128)ia * b <= (__int128)ib * a) {
			res += '0';
			ia++;
		} else {
			res += '1';
			ib++;
		}
	}
	return res;
}
```

当循环结束时，$ia$ 将等于 $a$，$ib$ 将等于 $b$，因此该函数返回一个长度为 $a+b$ 的比特串，其中恰好包含 $a$ 个零和 $b$ 个一。例如，`gen_string(4,10)=01110110111011`。

称一个 $0/1$ 串 $s$ 是**好的**，如果存在正整数 $x$ 和 $y$，使得 $s = \text{gen\_string}(x,y)$。给定两个正整数 $A$ 和 $B$ $(1 \le A, B \le 10^{18})$，你的任务是计算 `gen_string(A,B)` 的所有好前缀的数量。例如，`gen_string(4,10)` 有 $6$ 个好前缀：

```
x = 1 | y = 1 | gen_string(x, y) = 01
x = 1 | y = 2 | gen_string(x, y) = 011
x = 1 | y = 3 | gen_string(x, y) = 0111
x = 2 | y = 5 | gen_string(x, y) = 0111011
x = 3 | y = 7 | gen_string(x, y) = 0111011011
x = 4 | y = 10 | gen_string(x, y) = 01110110111011
```

## 说明/提示

输入 $2$：$A, B \le 100$；\
输入 $3$：$A, B \le 1000$；\
输入 $4-7$：$A, B \le 10^6$；\
输入 $8-13$：所有答案不超过 $10^5$；\
输入 $14-21$：没有额外限制。

## 样例 #1

### 输入

```
6
1 1
3 5
4 7
8 20
4 10
27 21
```

### 输出

```
1
5
7
10
6
13```

# 题解

## 作者：wishapig (赞：11)

upd on 2023.8.16

感谢 @[VictorChen](https://www.luogu.com.cn/user/131047) 指出，**$f(n,n)$ 应为 $2n-1$**，但是修改大量图片实在是不方便~~（退役人比较懒）~~，只好在这里额外说明，见谅。

---

这是一篇纯粹找规律的题解，思路源自 @[YeahPotato](https://www.luogu.com.cn/user/94976) orz。

---

坐稳了！

注意到题目的输入输出量都是 $O(1)$ 的，于是考虑打表。

暴力就随便写，只要能正确跑出 $1\le n,m\le 30$ 即可。

然后对于所有的 $n,m$ 组合打出第一张表（行为 $n$，列为 $m$，下同）：

![](https://cdn.luogu.com.cn/upload/image_hosting/9ox9uya9.png)

瞄了一眼，很乱啊，啥都看不出来，不过还是有几条（~~没啥用的性质~~）

- $f(n,1)=f(1,n)=n$

- $f(n,n)=n$

考虑到这个题看起来是个数论问题，因此可以尝试打出 $f(n,m)$ 与 $f(n/g,m/g)$（其中 $g=\gcd(n,m)$），比如对每组互质的 $n,m$ 打出 $f(kn,km)$，得到下面这个表：

```
   1    1:    1   2   3   4   5   6   7   8   9  10
   1    2:    2   4   6   8  10  12  14  16  18  20
   1    3:    3   5   7   9  11  13  15  17  19  21
   1    4:    4   6   8  10  12  14  16  18  20  22
   1    5:    5   7   9  11  13  15  17  19  21  23
   1    6:    6   8  10  12  14  16  18  20  22  24
   1    7:    7   9  11  13  15  17  19  21  23  25
   1    8:    8  10  12  14  16  18  20  22  24  26
   1    9:    9  11  13  15  17  19  21  23  25  27
   1   10:   10  12  14  16  18  20  22  24  26  28

   2    1:    2   4   6   8  10  12  14  16  18  20
   2    3:    3   5   7   9  11  13  15  17  19  21
   2    5:    4   6   8  10  12  14  16  18  20  22
   2    7:    5   7   9  11  13  15  17  19  21  23
   2    9:    6   8  10  12  14  16  18  20  22  24

   3    1:    3   5   7   9  11  13  15  17  19  21
   3    2:    4   6   8  10  12  14  16  18  20  22
   3    4:    4   6   8  10  12  14  16  18  20  22
   3    5:    5   7   9  11  13  15  17  19  21  23
   3    7:    5   7   9  11  13  15  17  19  21  23
   3    8:    6   8  10  12  14  16  18  20  22  24
   3   10:    6   8  10  12  14  16  18  20  22  24

   4    1:    4   6   8  10  12  14  16  18  20  22
   4    3:    6   8  10  12  14  16  18  20  22  24
   4    5:    5   7   9  11  13  15  17  19  21  23
   4    7:    7   9  11  13  15  17  19  21  23  25
   4    9:    6   8  10  12  14  16  18  20  22  24

   5    1:    5   7   9  11  13  15  17  19  21  23
   5    2:    5   7   9  11  13  15  17  19  21  23
   5    3:    5   7   9  11  13  15  17  19  21  23
   5    4:    8  10  12  14  16  18  20  22  24  26
   5    6:    6   8  10  12  14  16  18  20  22  24
   5    7:    6   8  10  12  14  16  18  20  22  24
   5    8:    6   8  10  12  14  16  18  20  22  24
   5    9:    9  11  13  15  17  19  21  23  25  27

   6    1:    6   8  10  12  14  16  18  20  22  24
   6    5:   10  12  14  16  18  20  22  24  26  28
   6    7:    7   9  11  13  15  17  19  21  23  25

   7    1:    7   9  11  13  15  17  19  21  23  25
   7    2:    6   8  10  12  14  16  18  20  22  24
   7    3:    7   9  11  13  15  17  19  21  23  25
   7    4:    6   8  10  12  14  16  18  20  22  24
   7    5:    7   9  11  13  15  17  19  21  23  25
   7    6:   12  14  16  18  20  22  24  26  28  30
   7    8:    8  10  12  14  16  18  20  22  24  26
   7    9:    7   9  11  13  15  17  19  21  23  25
   7   10:    8  10  12  14  16  18  20  22  24  26

   8    1:    8  10  12  14  16  18  20  22  24  26
   8    3:    6   8  10  12  14  16  18  20  22  24
   8    5:    7   9  11  13  15  17  19  21  23  25
   8    7:   14  16  18  20  22  24  26  28  30  32
   8    9:    9  11  13  15  17  19  21  23  25  27

   9    1:    9  11  13  15  17  19  21  23  25  27
   9    2:    7   9  11  13  15  17  19  21  23  25
   9    4:    9  11  13  15  17  19  21  23  25  27
   9    5:    7   9  11  13  15  17  19  21  23  25
   9    7:    9  11  13  15  17  19  21  23  25  27
   9    8:   16  18  20  22  24  26  28  30  32  34
   9   10:   10  12  14  16  18  20  22  24  26  28

  10    1:   10  12  14  16  18  20  22  24  26  28
  10    3:    8  10  12  14  16  18  20  22  24  26
  10    7:    8  10  12  14  16  18  20  22  24  26
  10    9:   18  20  22  24  26  28  30  32  34  36
```

第一行 $n=m$ 的不看，对其他的，可以发现均形成一个公差为 $2$ 的等差数列，于是我们又找到一条性质：

- $f(n,m)=f(n/g,m/g)+2g$，其中 $g=\gcd(n,m)$

~~虽然这个性质并没有什么用，因为它被包含在下面的规律里了~~

于是我们只用关心两维互质的位置了，再打出一张表：

![](https://cdn.luogu.com.cn/upload/image_hosting/e56gmziv.png)

我们发现了一些奇怪的事情！

![](https://cdn.luogu.com.cn/upload/image_hosting/z7y896gw.png)

仔细端详一下，每一行每一列，在对角线上下的部分都有递推关系，于是我们得到：

- $f(n,m)=f(n-m,m)+1$，对 $n-m\ge 2m$

- $f(n,m)=f(n,m-n)+1$，对 $m-n\ge 2n$

于是问题变为关心 $n<2m \cap m<2n$ 的情况了，打出这部分点值继续观察：

![](https://cdn.luogu.com.cn/upload/image_hosting/juwch0ew.png)

然后我们又发现了一些奇怪的事情！

![](https://cdn.luogu.com.cn/upload/image_hosting/lfbv7ge5.png)

仔细观察每一对横竖的方框，可以发现一个离谱的关系：

![](https://cdn.luogu.com.cn/upload/image_hosting/gb5tl3n5.png)

每一对横竖的方框，横着的最右边等于竖着的最上面减一，横着的右边第二个等于竖着的上面第二个减一，依次类推。

这个规律用数学语言写出来就是：

- $f(n,m)=f(3n-m,n)-1$，对 $n<m<2n$

- $f(n,m)=f(m,3m-n)+1$，对 $m<n<2m$

好吧看起来很厉害但是似乎没法递推问题啊？

那就继续观察啊！

![](https://cdn.luogu.com.cn/upload/image_hosting/6e9y2w9b.png)

可以发现，对角线上面的部分是 $\pm1$，对角线下面的部分是 $\pm2$，这也是一个递推关系，写成数学语言就是：

- $f(n,m)=f(n-d,m-d)+1$，对 $n<m<2n$，其中 $d=m-n$

- $f(n,m)=f(n-d,m-d)+2$，对 $m<n<2m$，其中 $d=n-m$

**注意，这里只有当 $n-d,m-d$ 仍然满足 $n'<2m',m'<2n'$ 时才能递推**，如果不满足的话，可以先用一手用上面 $f(n,m)=f(3n-m,n)-1$ 或 $f(n,m)=f(m,3m-n)+1$ 的式子，然后递推。

找规律部分到此结束，来总结一下

---

- $f(n,m)=f(n-m,m)+1$，对 $n-m\ge 2m$

- $f(n,m)=f(n,m-n)+1$，对 $m-n\ge 2n$

这两条是用于递推 $n,m$ 其中一个相对另一个特别大的。

- $f(n,m)=f(3n-m,n)-1$，对 $n<m<2n$

- $f(n,m)=f(m,3m-n)+1$，对 $m<n<2m$

- $f(n,m)=f(n-d,m-d)+1$，对 $n<m<2n$，其中 $d=m-n$

- $f(n,m)=f(n-d,m-d)+2$，对 $m<n<2m$，其中 $d=n-m$

这四条合起来，可以对 $n<2m \cap m<2n$ 的情况进行递推，具体的使用方式就是：

- 如果下面的两条不能直接用，那么先用一下上面的两条

- 然后用下面两条。注意到 $d$ 可能很小，不能暴力递归，但是 $n-m$ 的值始终是不变的，因此可以算出 $-d$ 的次数一次性做完。

base case 是 $f(n,n)=n$ 以及 $f(n,2n)=f(2n,n)=2n$ 的情况。

~~上面 $6$ 个性质全部不会证明~~

最后，来两个例子直观感受一下递推过程：

![](https://cdn.luogu.com.cn/upload/image_hosting/lq4rizsq.png)

代码非常短

```c++
typedef long long ll;
ll x,y; int T;
ll solve(ll x, ll y){
	if (x==y) return x;
	if (x==y*2) return x;
	if (y==x*2) return y;
	if (x>y*2){
		ll d=(x/y)+(x%y==0?0:1)-2;
		return solve(x-d*y,y)+d;
	}
	if (y>x*2){
		ll d=(y/x)+(y%x==0?0:1)-2;
		return solve(x,y-d*x)+d;
	}
	if (x<y){
		ll d=y-x,k=(2*x-y)/d;
		if (k) return solve(x-d*k,y-d*k)+k;
		else return solve(3*x-y,x)-1;
	} else {
		ll d=x-y,k=(2*y-x)/d;
		if (k) return solve(x-d*k,y-d*k)+k*2;
		else return solve(y,3*y-x)+1;
	}
}
int main(){
	for (cin>>T; T; T--){
		scanf("%lld%lld",&x,&y);
		printf("%lld\n",solve(x,y));
	}
}
/*
6
3 5
8 20
1 1
4 7
4 10
27 21
*/
```

---

## 作者：UltiMadow (赞：10)

upd: 修正了一些错误（

考虑把 `gen_string` 的过程画到平面上，即画成一条从 $(0,0)$ 到 $(a,b)$ 的折线，折线上的所有点即可表示 `gen_string` 的所有前缀。

称折线上一个点合法当且仅当它所代表的的前缀合法。

下文中所有射线 $(x,y)$ 为以原点为端点，经过 $(x,y)$ 的射线。

性质 1：点 $(x,y)$ 合法当且仅当对于任意满足 $0\le x_0\le x\land 0\le y_0\le y$ 的点 $(x_0,y_0)$ 都有它在射线 $(x,y)$ 和 $(a,b)$ 同侧（在射线上的点定义为位于射线左上方）。

证明：考虑反证，假设存在点 $(x_0,y_0)$ 不在射线 $(x,y)$ 和 $(a,b)$ 同侧，不妨假设 $(x,y)\times (a,b)>0$。

取 $x_0$ 最小的满足条件的点（如果有多个则取 $y_0$ 最大的），容易证明 $(a,b)$ 的折线经过 $(x_0,y_0)$。

由于要求 $(a,b)$ 的折线和 $(x,y)$ 的折线重合，所以 $(x,y)$ 的折线也经过 $(x_0,y_0)$，而在这之后一步 $(a,b)$ 的折线会向上走，$(x,y)$ 的折线会向右走，矛盾。

性质 2：对于满足 $f_1\times f_2=1$ 的整点 $f_1,f_2$，任意满足 $f_1\times f>0\land f\times f_2>0$ 的整点 $f$ 都有 $f=k_1f_1+k_2f_2$，其中 $k_1,k_2$ 为正整数。

证明：充分性显然，下证必要性。

构造 $k_2=f_1\times f,k_1=f\times f_2$，容易证明 $f_1\times f=f_1\times(k_1f_1+k_2f_2)\land f\times f_2=(k_1f_1+k_2f_2)\times f_2$，从而 $f=(f_1\times f)f_2+(f\times f_2)f_1$，由于 $f_1,f_2,f$ 均为整点，可得 $k_1,k_2$ 均为正整数。

又一个向量分解为两个线性无关的向量的分解方式唯一，所以必要性得证。

由性质 2，可得 $f_1+f_2$ 是 $f_1$ 与 $f_2$ 之间最小的整点。

考虑如下算法：

1. 初始令 $f_1=(0,1),f_2=(1,0)$，满足 $f_1\times f_2=1$，过程中保证射线 $f_1$ 右下方及射线 $f_2$ 左上方（不含射线 $f_2$ 上的点）都被统计过了，且 $f_1$ 和 $f_2$ 均为合法点。
2. 记 $f=f_1+f_2$，则 $f$ 为合法点（由 $f$ 是 $f_1$ 与 $f_2$ 之间的最小整点保证），接下来按照 $f$ 对于 $(a,b)$ 的位置决定令 $f_1=f$ 或 $f_2=f$，继续向下递归。
3. 若 $f_2\times f=0$，则结束算法

但是这个算法漏统计了若干个形如 $kf_2$ 的点，考虑完善一下。

性质 3：若当前的 $f$ 满足 $f\times (a,b)>0$，记在此之前 $f_1$ 已经连续变化了 $k$ 次，则 $(k+2)f_2$ 合法。

证明：发现 $(k+2)f_2$ 在 $f+f_2$ 的平行四边形内，而 $f+f_2$ 为 $f$ 与 $f_2$ 之间的最小点，所以不存在横纵坐标都比 $(k+2)f_2$ 小的点满足它在 $f$ 与 $(a,b)$ 之间（这个画一下图应该会比较清楚）。

性质 4：算法结束时一定有 $f_2=(\frac a{\gcd(a,b)},\frac b{\gcd(a,b)})$ 且 $f_1\times (a,b)=\gcd(a,b)$。

证明：考虑在算法执行过程中维护 $x_1=f_1\times(a,b),x_2=(a,b)\times f_2$，则每一轮 $f_1=f$ 或 $f_2=f$ 会使 $x_1,x_2$ 中较大值减去较小值，即辗转相减，最后剩余的数即为 $\gcd(a,b)$。

由于 $f_2=k(a,b)$ 且 $f_1\times f_2=1$，可以推得 $f_2=(\frac a{\gcd(a,b)},\frac b{\gcd(a,b)})$。

不难发现算法结束时 $kf_2$ 和 $kf_2+f_1$ 均合法，所以答案还要加上 $2(\gcd(a,b)-1)$。

根据性质 4，这个算法是一个辗转相减的形式，将这个过程变为辗转相除即可做到单次询问 $\mathcal O(\log(a+b))$。

code:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,a,b;
int solve(int a,int b){
	int f1=b,f2=a,ret=0,co=1;
	while(f2){
		if(f1>f2)ret+=co*((f1-1)/f2),f1=(f1-1)%f2+1;
		else ret+=f2/f1,f2%=f1,co=2;
	}
	return ret+2*(f1-1);
}
signed main(){
	scanf("%lld",&T);
	while(T--){
		scanf("%lld%lld",&a,&b);
		printf("%lld\n",solve(a,b));
	}
	return 0;
}
```

---


# [LSOT-2] 笼中鸟

## 题目背景

> 「笼中鸟，笼中鸟」
>
> 「笼中有只小小鸟」
>
> 「何时才能出囚笼」
>
> 「黎明时分的夜晚」
>
> 「仙鹤灵龟都滑倒」
>
> 「猜猜身后是何人」

## 题目描述

榎本在 SPHIA 的小黑屋内实验神秘转移装置。

实验体是 $m$ 个长度为 $n$ 的数列，他要在这些数列上验证转移装置是否能够正常运行。

这个转移装置的主要功能是将两个序列的部分交换，也就是说他会选择 $(i,j),[l,r]$，然后将序列 $i$ 的 $[l,r]$ 与序列 $j$ 的 $[l,r]$ 交换。

当然了，为了验证是否成功交换，他会查询某个序列的某个区间的和与预期值是否相同，并且为了避免偶然现象，他会给某个序列的某个区间加上一个值。

榎本知道 self 非常喜欢斐波那契数列，于是为了更好的困住 self，他还加了一个功能，就是判断数列 $f$ 的某个区间是不是满足 $f_i\equiv\sum_{j=1}^kf_{i-j}\pmod p$ 的特殊数列。

形式化题面：

1. 给定 $x,l,r$，求 $\sum_{i=l}^ra_{x,i}\bmod p$。

2. 给定 $x,l,r,f$，询问命题 $\forall i\in[l+f,r],a_{x,i}\equiv \sum_{j=1}^fa_{x,i-j}\pmod p$ 是否是真命题。
3. 给定 $x,l,r,k$，$\forall i\in[l,r],a_{x,i}← a_{x,i}+k$。
4. 给定 $x,y,l,r$，$\forall i\in[l,r],\text{swap}(a_{x,i},a_{y,i})$。


## 说明/提示

**「本题采用捆绑测试」**

$\texttt{Subtask 1(20pts)：}n,q\le100$。

$\texttt{Subtask 2(25pts)：}n,q\le10^5$。

$\texttt{Subtask 3(25pts)：}$不存在 $2$ 操作。

$\texttt{Subtask 4(30pts)：}$无特殊性质。

对于所有数据，$1\le n,q\le5\times10^5$，$1\le m\le10$，$0\le a_{i,j},k< p$，$1\le l\le r\le n$，$1\le f\le n$，$1\le x,y\le m$，$x\not=y$。保证 $p$ 是 $10^{9}$ 到 $2\times 10^9$ 中随机生成的质数。



------------
2024/2/13 本题赛后添加两组 hack 数据（Subtask #5）

## 样例 #1

### 输入

```
5 2 6 1000000007
1 1 2 3 5
0 0 0 0 0
1 1 2 3
1 2 2 3
2 1 1 5 2
4 1 2 2 3
1 1 1 4
1 2 1 4```

### 输出

```
3
0
where is self?
4
3```

# 题解

## 作者：yzy1 (赞：6)

随机化做法，欢迎 Hack．

只有 1、3、4 操作的情况过于简单，这里不再过多讲述．

考虑 2 操作中对于 $[l,r]$ 的命题是真命题的一个必要条件：

$$
\sum_{i=l+k}^r a_j \equiv \sum_{i=l+k}^r \sum_{j=i-k}^{i-1} a_j \pmod p.
$$

同余号两边的式子均可以通过线段树维护区间和及区间编号乘权值和的方式快速得出．

注意到这个条件并不充分．考虑随机化．约定常数 $D$，每次 2 操作时，把 $[l+k,r]$ 区间划分成 $D$ 个互不相交的子区间，然后分别进行上述必要条件的检验．若所有子区间均通过检验，则认为原命题成立．

发现有一种简单的构造可 Hack 上述做法：另每次 2 操作 $k=1$，且 $[l,r]$ 区间内只有一个数和其他数不同．此时若这个不同的数字没有单独被划分到一个区间内，则上述做法会得到错误的结果．考虑通过特判 $k=1$ 的方式来规避该 Hack．

在 $k>1$ 的情况下，笔者尝试过多种方式，均无法 Hack 掉该做法．欢迎各位读者尝试 Hack．

经测试取 $D=8$ 时可以稳定通过本题目前的所有数据．

代码参考见 [外部剪贴板](https://paste.debian.net/1307204/)．

---

## 作者：sidekick257 (赞：5)

安利一下 Remember11，非常神作，值得一玩。

观察到 $\forall i\in_{l+k,r},f_i=\sum_{j=1}^kf_{i-j}\Leftrightarrow \forall i\in_{l+k+1,r},f_i-f_{i-1}=f_{i-1}-f_{i-k-1}$。

因为 $i,i-1,i-k-1$ 体现在 $[l+k,r]$ 上都是连续段，直接线段树维护模 $p$ 意义下的哈希暴力判断是否两段区间相等即可。

然后要注意 $r=l+k$ 的情况特判一下就行。

交换不同数列的区间容易想到可以写平衡树轻易的维护，但是平衡树太答辩了，在线段树上交换对应区间编号就可以了。

出题人代码写的太丑就不放了。

（PS：这题本来是 $k=2$ 的，但是多亏了 [良心 WA 题人](https://www.luogu.com.cn/user/132424) 发现了 $k=2$ 可以直接合并。）


---

## 作者：Redshift_Shine (赞：1)

# [LSOT-2](https://www.luogu.com.cn/problem/P10158) 笼中鸟

## 题面

题面已经很底层了，真的。信我。

## 思路

显然操作 $1$ 和 $3$ 都是基本线段树操作，不会的请出门右转[线段树模板题1](https://www.luogu.com.cn/problem/P3372) 。

此处重点讲操作 $4$ ，因为出题人十分好心地允许第二个操作 $O(\sum (r-l) n\log n)$ 暴力（（（

实际上，我们可以将操作四的区间裁剪交换看作是交换**线段树上的几个节点**。

这个结论可以感性理解，因为在懒标记不存在的情况下，每一个线段树节点及其子树所存信息是相互独立的，可以进行方便的裁剪/连接。

显然，为了实现这个操作，我们不能使用 $2k(+1)$ 式静态线段树，需要动态开点以方便操作，具体如下：

```c++
struct st{
    ll val,tag;
    int lft,rgt;
}tr[N*20];
```

`lft` 和 `rgt` 分别代表该节点的左右节点。

如果一个节点**完全**处在在我们想要切换的区间内，直接利用引用切换两节点编号即可。

否则，**下传懒标记**，因为结论建立在我们所裁剪的节点的任何一个父亲都没有懒标记的条件之下。

核心代码如下。

```c++
void split(int& x,int& y,int l,int r,int lb,int rb){
    if(l>=lb and r<=rb){
        swp(x,y);
        return;
    }
    psh(x,l,r),psh(y,l,r);
    int mid=(l+r)>>1;
    if(lb<=mid)split(tr[x].lft,tr[y].lft,l,mid,lb,rb);
    if(rb>mid)split(tr[x].rgt,tr[y].rgt,mid+1,r,lb,rb);
    grb(x),grb(y);
}
```

~~这代码早在首 A 者半个小时前写完，结果因为懒标记下传多写了个 $1$ 痛失首A。呜呜呜~~

---

## 作者：Federico2903 (赞：0)

## 思路

操作 $1, 3, 4$ 都是平凡的，用平衡树简单维护即可。

考虑操作 $2$，观察一下要满足什么条件。

设 $f = 3$，那么可以发现如下式子：

$$
\begin{cases}
x_4 \equiv x_1 + x_2 + x_3 \pmod p\\
x_5 \equiv x_2 + x_3 + x_4 \pmod p\\
x_6 \equiv x_3 + x_4 + x_5 \pmod p\\
x_7 \equiv x_4 + x_5 + x_6 \pmod p\\
\cdots
\end{cases}
$$

发现相邻的式子有很多重复项，相减一下：

$$
\begin{cases}
x_5 - x_4 \equiv x_4 - x_1 \pmod p\\
x_6 - x_5 \equiv x_5 - x_2 \pmod p\\
x_7 - x_6 \equiv x_6 - x_3 \pmod p\\
\cdots
\end{cases}
$$

移项合并：

$$
\begin{cases}
x_5 \equiv 2 \times x_4 - x_1 \pmod p\\
x_6 \equiv 2 \times x_5 - x_2 \pmod p\\
x_7 \equiv 2 \times x_6 - x_3 \pmod p\\
\cdots
\end{cases}
$$

发现可以代入化简：

$$
\begin{cases}
x_5 \equiv 2 \times x_4 - x_1 \pmod p\\
x_6 \equiv 4 \times x_4 - 2 \times x_1 - x_2 \pmod p\\
x_7 \equiv 8 \times x_4 - 4 \times x_1 - 2 \times x_2 - x_3 \pmod p\\
\cdots
\end{cases}
$$

不难发现一些规律，系数为负数的项有点类似一个哈希的形式。

具体的，操作 $2$ 为真时应满足如下条件：

$$2^{r - f - l} \times x_{l + f} - \sum_{i = l}^{r - f - 1}2^{r - f - i - 1} \times x_i \equiv x_r \pmod p$$

这个哈希可以方便的用平衡树维护，不过平衡树常数较大，可能会需要卡常。

## AC 代码

```cpp
#include <bits/stdc++.h>

#define rep(i, a, b) for(int i = (a), i##end = (b); i <= i##end; i++)
#define _rep(i, a, b) for(int i = (a), i##end = (b); i >= i##end; i--)
#define ec first
#define fb second
#define dl make_pair
#define dk(...) make_tuple(__VA_ARGS__)


using namespace std;

typedef long long ll;
typedef __int128 i128;
typedef pair <int, int> pii;

bool stmer;

namespace fastio {
    const int bufl=1<<20;
    const double base1[16]={1,1e-1,1e-2,1e-3,1e-4,1e-5,1e-6,1e-7,1e-8,1e-9,1e-10,1e-11,1e-12,1e-13,1e-14,1e-15};
    const double base2[16]={1,1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13,1e14,1e15};
    struct IN{
        FILE *IT;char ibuf[bufl],*is=ibuf,*it=ibuf;
        IN(){IT=stdin;}IN(char *a){IT=fopen(a,"r");}
        inline char getChar(){if(is==it){it=(is=ibuf)+fread(ibuf,1,bufl,IT);if(is==it)return EOF;}return *is++;}
        template<typename Temp>inline void getInt(Temp &a){a=0;int b=0,c=getChar();while(c<48||c>57)b^=(c==45),c=getChar();while(c>=48&&c<=57)a=(a<<1)+(a<<3)+c-48,c=getChar();if(b)a=-a;}
        template<typename Temp>inline void getDouble(Temp &a){a=0;int b=0,c=getChar(),d=0;__int128 e=0,f=0;while(c<48||c>57)b^=(c==45),c=getChar();while(c>=48&&c<=57)e=(e<<1)+(e<<3)+c-48,c=getChar();if(c==46){c=getChar();while(c>=48&&c<=57)d++,f=(f<<1)+(f<<3)+c-48,c=getChar();}a=e+base1[d]*f;if(b)a=-a;}
        IN& operator>>(char &a){a=getChar();return *this;}
        IN& operator>>(char *a){do{*a=getChar();}while(*a<=32);while(*a>32)*++a=getChar();*a=0;return *this;}
        IN& operator>>(string &a){char b=getChar();while(b<=32)b=getChar();while(b>32)a+=b,b=getChar();return *this;}
        IN& operator>>(int &a){getInt(a);return *this;}
        IN& operator>>(long long &a){getInt(a);return *this;}
        IN& operator>>(__int128 &a){getInt(a);return *this;}
        IN& operator>>(float &a){getDouble(a);return *this;}
        IN& operator>>(double &a){getDouble(a);return *this;}
        IN& operator>>(long double &a){getDouble(a);return *this;}
    };
}
using fastio::IN;
IN fin;

template <typename _Tp>
void print(_Tp x) {
	if (x < 0) x = (~x + 1), putchar('-');
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}

const int MAXN = 5e5 + 5;

int mod, n, m, q;
int pw[MAXN], pre[MAXN];
i128 mu;

inline int reduce(i128 x) {
	i128 r = x - (mu * x >> 64) * mod;
	return r;
}

mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());

#define ls(x) p[x].ls
#define rs(x) p[x].rs

struct node { int val, key, siz, ls, rs, sum, lazy, h; } p[MAXN * 11];
int cnt = 0, root[15], sub;

namespace Treap {

	inline int newNode(int val) {
		int x = ++cnt;
		p[x].val = p[x].sum = val, p[x].key = rnd(), p[x].siz = 1;
		p[x].ls = p[x].rs = p[x].lazy = 0;
		if (sub) p[x].h = val;
		return x;
	}

	void pushup(int x) {
		p[x].sum = reduce(1ll * p[ls(x)].sum + p[rs(x)].sum + p[x].val);
		p[x].siz = p[ls(x)].siz + p[rs(x)].siz + 1;
		if (sub) {
			p[x].h = reduce(1ll * p[ls(x)].h * pw[1] + p[x].val);
			p[x].h = reduce(1ll * p[x].h * pw[p[rs(x)].siz] + p[rs(x)].h);
		}
	}

	void add(int x, int val) {
		p[x].val = reduce(1ll * p[x].val + val);
		p[x].sum = reduce(1ll * p[x].sum + reduce(1ll * val * p[x].siz));
		p[x].lazy = reduce(1ll * p[x].lazy + val);
		if (sub) p[x].h = reduce(1ll * pre[p[x].siz - 1] * val + p[x].h);
	}

	void pushdown(int x) {
		if (!x) return;
		if (p[x].lazy) {
			if (ls(x)) add(ls(x), p[x].lazy);
			if (rs(x)) add(rs(x), p[x].lazy);
			p[x].lazy = 0;
		}
	}

	void split(int cur, int k, int &x, int &y) {
		if (!cur) return x = y = 0, void();
		pushdown(cur);
		if (p[ls(cur)].siz < k) x = cur, split(rs(cur), k - p[ls(cur)].siz - 1, rs(cur), y);
		else y = cur, split(ls(cur), k, x, ls(cur));
		pushup(cur);
	}

	int merge(int x, int y) {
		if (!x || !y) return x + y;
		if (p[x].key < p[y].key) return pushdown(x), rs(x) = merge(rs(x), y), pushup(x), x;
		else return pushdown(y), ls(y) = merge(x, ls(y)), pushup(y), y;
	}

	void build(int &root, vector <int> v) {
		for (auto i : v) root = merge(root, newNode(i));
	}

	void add(int &root, int L, int R, int val) {
		int x = 0, y = 0, z = 0;
		split(root, L - 1, x, y);
		split(y, R - L + 1, y, z);
		add(y, val);
		root = merge(merge(x, y), z);
	}

	int sum(int &root, int L, int R) {
		int x = 0, y = 0, z = 0;
		split(root, L - 1, x, y);
		split(y, R - L + 1, y, z);
		int res = p[y].sum;
		root = merge(merge(x, y), z);
		return res;
	}

	void swap(int &x, int &y, int L, int R) {
		if (x == y) return;
		int X0 = 0, Y0 = 0, Z0 = 0;
		split(x, L - 1, X0, Y0);
		split(Y0, R - L + 1, Y0, Z0);
		int X1 = 0, Y1 = 0, Z1 = 0;
		split(y, L - 1, X1, Y1);
		split(Y1, R - L + 1, Y1, Z1);
		x = merge(merge(X0, Y1), Z0);
		y = merge(merge(X1, Y0), Z1);
	}

	int qh(int &root, int L, int R) {
		int x = 0, y = 0, z = 0;
		split(root, L - 1, x, y);
		split(y, R - L + 1, y, z);
		int res = p[y].h;
		root = merge(merge(x, y), z);
		return res;
	}
}

struct querys {
	int op, x, y, l, r, k, f;
} ques[MAXN];

bool edmer;

signed main() {
	fin >> n >> m >> q >> mod;
	mu = (i128) (((i128) 1) << 64) / mod;
	pw[0] = pre[0] = 1;
	rep (i, 1, n) pw[i] = reduce(1ll * pw[i - 1] * 2);
	rep (i, 1, n) pre[i] = reduce(1ll * pre[i - 1] + pw[i]);
	vector <int> v[11];
	rep (i, 1, m) {
		int x;
		rep (j, 1, n) fin >> x, v[i].push_back(x);
	}
	rep (i, 1, q) {
		fin >> ques[i].op;
		if (ques[i].op == 1) {
			fin >> ques[i].x >> ques[i].l >> ques[i].r;
		}
		else if (ques[i].op == 2) {
	        sub = 1;
			fin >> ques[i].x >> ques[i].l >> ques[i].r >> ques[i].f;
		}
		else if (ques[i].op == 3) {
			fin >> ques[i].x >> ques[i].l >> ques[i].r >> ques[i].k;
		}
		else {
			fin >> ques[i].x >> ques[i].y >> ques[i].l >> ques[i].r;
		}
	}
	rep (i, 1, m) Treap::build(root[i], v[i]);
	rep (i, 1, q) {
		int op = ques[i].op;
		int x = ques[i].x, y = ques[i].y;
		int l = ques[i].l, r = ques[i].r;
		int f = ques[i].f, k = ques[i].k;
		if (op == 1) {
			print(Treap::sum(root[x], l, r)), puts("");
		}
		else if (op == 2) {
			if (r - l + 1 <= f) {
				puts("infinity loop!");
				continue;
			}
			bool flg = 0;
			const int pt = Treap::qh(root[x], l + f, l + f);
			if (Treap::sum(root[x], l, l + f - 1) != pt) {
				flg = 1;
				puts("infinity loop!");
			}
			if (!flg && r - l + 1 > f + 1) {
				int val = Treap::qh(root[x], l, r - f - 1);
				int len = reduce(1ll * pw[r - f - l] * pt);
				if (reduce(1ll * reduce(len - val) + mod) != Treap::qh(root[x], r, r)) {
					flg = 1;
					puts("infinity loop!");
				}
			}
			if (flg) continue;
			puts("where is self?");
		}
		else if (op == 3) Treap::add(root[x], l, r, k);
		else Treap::swap(root[x], root[y], l, r);
	}
	return 0;
}
```

---

## 作者：small_john (赞：0)

## 前言

模拟赛遇到了这道题精神一百分但是没写出来，写篇题解纪念一下。

## 思路

考虑用动态开点线段树维护矩阵。$1$ 操作和 $3$ 操作都是板中板，$4$ 操作直接交换对应的儿子即可。

考虑如何做 $2$ 操作。发现原来的条件可以转化为：$\forall i\in[l+f+1,r],a_{x,i}-a_{x,i-1}\equiv a_{x,i-1}-a_{x,i-f-1}\pmod p$，并且 $a_{x,l+f}\equiv \displaystyle\sum_{i=l}^{l+f-1} a_{x,i}$。

第二个条件直接判，就不说了。

第一个条件使用哈希判断。众所周知哈希是具有可减性的（就是两个序列相减得到的哈希值与两个序列的哈希值之差相等）。用线段树维护一下即可。

时间复杂度 $O(n\log n)$，注意特判 $l+f=r$ 的情况。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

template<typename T> inline void read(T &x)
{
	x = 0;
	T f = 1;char ch = getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		{
			f = -1,ch = getchar();
			break;
		}
		ch = getchar();
	}
	while(ch>='0'&&ch<='9')
		x = (x<<3)+(x<<1)+ch-48,ch = getchar();
	x*=f;
}
template<typename T = int> inline T read()
{
	T x;read(x);return x;
}
template<typename T> void write(T x)
{
    if(x<0) x = -x,putchar('-');
    if(x>9) write(x/10);
    putchar(x%10+48);
}
template<typename T> inline void writen(T x)
{
    write(x);
    putchar(10);
}
const int N = 5e5+5,base = 1145141;
int n,m,mod,a[N],q;
int pw[N],s[N];
struct node{
	int sum,hs,ls,rs,tag;
}t[N*10*4];
inline void pushup(int k,int len)
{
	t[k].sum = (t[t[k].ls].sum+t[t[k].rs].sum)%mod;
	t[k].hs = (t[t[k].ls].hs+pw[len]*t[t[k].rs].hs)%mod;
}
inline void add(int k,int l,int r,int v)
{
	int len = r-l+1;
	(t[k].sum+=len*v)%=mod;
	(t[k].hs+=s[len-1]*v)%=mod;
	(t[k].tag+=v)%=mod;
}
inline void down(int k,int l,int r,int mid)
{
	if(!t[k].tag) return;
	add(t[k].ls,l,mid,t[k].tag),add(t[k].rs,mid+1,r,t[k].tag);
	t[k].tag = 0;
}
int cnt,rt[11];
void build(int &k,int l,int r)
{
	k = ++cnt;
	if(l==r) return t[k].sum = t[k].hs = a[l],void();
	int mid = (l+r)/2;
	build(t[k].ls,l,mid),build(t[k].rs,mid+1,r);
	pushup(k,mid-l+1);
}
void change(int k,int l,int r,int x,int y,int v)
{
	if(l>y||r<x) return;
	if(l>=x&&r<=y) return add(k,l,r,v);
	int mid = (l+r)/2;
	down(k,l,r,mid);
	change(t[k].ls,l,mid,x,y,v),change(t[k].rs,mid+1,r,x,y,v);
	pushup(k,mid-l+1);
}
void swap(int &rt1,int &rt2,int l,int r,int x,int y)
{
	if(l>y||r<x) return;
	if(l>=x&&r<=y) return swap(rt1,rt2);
	int mid = (l+r)/2;
	down(rt1,l,r,mid),down(rt2,l,r,mid);
	swap(t[rt1].ls,t[rt2].ls,l,mid,x,y),swap(t[rt1].rs,t[rt2].rs,mid+1,r,x,y);
	pushup(rt1,mid-l+1),pushup(rt2,mid-l+1);
}
int asksum(int k,int l,int r,int x,int y)
{
	if(l>y||r<x) return 0;
	if(l>=x&&r<=y) return t[k].sum;
	int mid = (l+r)/2;
	down(k,l,r,mid);
	return (asksum(t[k].ls,l,mid,x,y)+asksum(t[k].rs,mid+1,r,x,y))%mod;
}
int askhs(int k,int l,int r,int x,int y)
{
	if(l>=x&&r<=y) return t[k].hs;
	int mid = (l+r)/2;
	down(k,l,r,mid);
	if(x<=mid&&mid<y) return (askhs(t[k].ls,l,mid,x,y)+pw[mid-max(l,x)+1]*askhs(t[k].rs,mid+1,r,x,y))%mod;
	if(x<=mid) return askhs(t[k].ls,l,mid,x,y);
	return askhs(t[k].rs,mid+1,r,x,y);
}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),read(m),read(q),read(mod);
	pw[0] = s[0] = 1;
	for(int i = 1;i<=n;i++)
		pw[i] = pw[i-1]*base%mod,s[i] = (s[i-1]+pw[i])%mod;
	for(int i = 1;i<=m;i++)
	{
		for(int j = 1;j<=n;j++)
			read(a[j]);
		build(rt[i],1,n);
	}
	while(q--)
	{
		int op,x,y,l,r,v;
		read(op),read(x);
		if(op==1) read(l),read(r),writen(asksum(rt[x],1,n,l,r));
		else if(op==2)
		{
			read(l),read(r),read(v);
            bool ans = (asksum(rt[x],1,n,l+v,l+v)==asksum(rt[x],1,n,l,l+v-1));
            if(ans&&l+v<r)
			{
                int s1 = askhs(rt[x],1,n,l+v+1,r),s2 = askhs(rt[x],1,n,l+v,r-1),s3 = askhs(rt[x],1,n,l,r-v-1);
                if((s1+mod-s2)%mod!=(s2+mod-s3)%mod) ans = 0;
            }
            if(ans) puts("where is self?");
            else puts("infinity loop!");
		}
		else if(op==3) read(l),read(r),read(v),change(rt[x],1,n,l,r,v);
		else read(y),read(l),read(r),swap(rt[x],rt[y],1,n,l,r);
	}
	return 0;
}
```

---


# [国家集训队] 等差子序列

## 题目描述

给一个 $1$ 到 $N$ 的排列 $\{A_i\}$，询问是否存在

$$1 \le p_1<p_2<p_3<p_4<p_5<…<p_{Len} \le N (Len \ge 3)$$

使得 $Ap_1,Ap_2,Ap_3,\cdots,Ap_{Len}$ 是一个等差序列。


## 说明/提示

对于后 $20$ 个测试点的数据，$1 \leq N \leq10000,T\leq 7$，时限 2s。

对于前 $5$ 个测试点的数据，$1 \leq N \leq 5\times 10^5,T \leq 5$，时限 5s。

## 样例 #1

### 输入

```
2
3
1 3 2
3
3 2 1```

### 输出

```
N
Y```

# 题解

## 作者：MeowScore (赞：28)

线段树+哈希好题。qwaszx 学长讲字符串哈希的时候用了这个题，于是拿来练手。

先考虑一件事情，题目问存不存在一个长度不小于 $3$ 的等差子序列，实际上我们只需要计算是否存在一个长度**等于** $3$ 的等差子序列即可，正确性显然。问题从而得到大大简化。

每次考虑三个数，那么中项就十分特殊了，因为和另外两项的差的绝对值相等。这时候还有一条重要性质：给出的序列是 $1$ 到 $n$ 的排列。所以对于位置 $i$，如果一个数（非 $a_i$）不在它左边，那么就一定在它的右边（废话）。这时候我们得到一个很好的做法，我们从左到右扫一遍序列，枚举中项，对于当前枚举到的中项下标 $i$，如果存在一个 $k$，使得 $a_i-k$ 和 $a_i+k$ 这两个数一个已经出现过，一个还没出现过（“出现过”指已经扫过，也就是说这个数在 $i$ 左边），我们就能判定答案为存在。

接下来优化这一过程。我们假设建立了一个数组，初始全为 $0$，扫过一个数 $a_i$ 后就把数组下标 $a_i$ 的位置标为 $1$，如果我们以 $a_i$ 为中心“对折”这个数组，若对于所有重合的位置，重合的两个数相等，则说明对于所有合法的 $k$，$a_i-k$ 和 $a_i+k$ 必然在 $a_i$ 同侧（也就是对于当前的中心答案不存在）。其实是一个判断回文的过程。考虑用字符串哈希做这件事，把重合部分提取出来，如果中心位置左半边序列的哈希值等于右半边序列的反序列的哈希值，那么就回文，我们用线段树维护区间哈希和反序列哈希，这样对于一个 $a_i$ 就能快速查询了，扫完 $a_i$ 后也能快速修改。区间合并就是字符串哈希的基本操作了，不必多说。

upd：线段树上一个区间的“反序列哈希”指的是把原序列中这一段数取出，翻转后求得的哈希值。这里的哈希采用字符串哈希的维护方式。据某些同学的私信，这里似乎有点表意不清。

更多细节看代码吧，有不理解的地方或是有写错的地方欢迎私信。

```
#include<bits/stdc++.h>
using namespace std;
const int N=500010,mod=1e9+7,P=13331;
typedef long long ll;
int read(){
	int ss=0,ww=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')
			ww=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		ss=ss*10+ch-'0';
		ch=getchar();
	}
	return ss*ww;
}
int T,n;
ll p[N];
ll hash1[N*4],hash2[N*4];
int a[N];
int min(int x,int y){
	return x<y?x:y;
}
void upd(int root,int l,int r){
	int mid=(l+r)/2;
	hash1[root]=(hash1[root*2+1]+hash1[root*2]*p[r-mid]%mod)%mod;
	hash2[root]=(hash2[root*2]+hash2[root*2+1]*p[mid-l+1]%mod)%mod;
}
void add(int root,int l,int r,int x){
	if(l==r){
		hash1[root]=hash2[root]=1;
		return;
	}
	int mid=(l+r)/2;
	if(mid>=x)
		add(root*2,l,mid,x);
	else
		add(root*2+1,mid+1,r,x);
	upd(root,l,r);
}
ll res1,res2,nw;
void ask1(int root,int l,int r,int x,int y){
	if(l>=x&&r<=y){
		res1=(res1+hash1[root]*p[nw]%mod)%mod;
		nw+=(r-l+1);
		return;
	}
	int mid=(l+r)/2;
	if(mid+1<=y)
		ask1(root*2+1,mid+1,r,x,y);
	if(mid>=x)
		ask1(root*2,l,mid,x,y);	
}
void ask2(int root,int l,int r,int x,int y){
	if(l>=x&&r<=y){
		res2=(res2+hash2[root]*p[nw]%mod)%mod;
		nw+=(r-l+1);
		return;
	}
	int mid=(l+r)/2;
	if(mid>=x)
		ask2(root*2,l,mid,x,y);
	if(mid+1<=y)
		ask2(root*2+1,mid+1,r,x,y);
}
int main(){
	T=read();
	p[0]=1;
	for(int i=1;i<=5e5;i++)
		p[i]=p[i-1]*P%mod;
	while(T--){
		memset(hash1,0,sizeof(hash1));//多测记得清空
		memset(hash2,0,sizeof(hash2));
		n=read();
		for(int i=1;i<=n;i++)
			a[i]=read();
		bool flag=0;
		for(int i=1;i<=n;i++){
			add(1,1,n,a[i]);
			int len=min(a[i],n-a[i]+1);
			res1=res2=nw=0;
			ask1(1,1,n,a[i]-len+1,a[i]+len-1);
			nw=0;
			ask2(1,1,n,a[i]-len+1,a[i]+len-1);
			if(res1!=res2){
				flag=1;
				break;
			}
		}
		if(flag)
			cout<<"Y\n";
		else
			cout<<"N\n";
	}
	return 0;
}
```

---

## 作者：Eziotao (赞：25)

  ## 线段树~~好~~题 ##
  ### ~~可能只有我这种蒟蒻需要打这么久~~ ###
	首先看题目，len>=3,好说，只要找到为3的就行了对吧(len>3的等差子序列里面也有长为3的啊)[手动滑稽]。
    因为给的数列是1~n的排列,并且合法条件为a[j]-a[i]=a[k]-a[j],(假设i<j<k),那么，对于每个a[j],如果它前面的某个a[i],在j的前面没有a[k]=2*a[j]-a[i](要保证2*a[j]-a[i]<=n啊，不然要找的a[k]值不在序列里了),那么满足条件的a[k]必定在它后面(某FYJdalao:废话，这是1~n的排列好不好，用你说?)
    好嘛,如果我们枚举j,问题就变成求有没有两个数i,k都在j前且a[i]+a[k]=2*a[j]了，如果每个i都能在j前找到这样一个k，很明显这个j是不满足的。开个桶存下来对比？我们就得到了一个优秀的n²做法了[手动滑稽](盗个图)
    ![我过去就是一脚](https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1680736846,2262936555&fm=27&gp=0.jpg)
    怎么log(n)做到查询有无重复呢？是时候使用hash神技了。怎么动态维护hash值？线段树啊。我线段树里存的是值是表示值在某个区间的数存不存在,二进制压一下就好了,开两颗线段树维护两个hash值，一个正向(从1到n)存这个值是否存在(0和1嘛)，一个逆向(从n到1)存这个值(逆向干嘛？保持对应关系，查询的时候直接判断hash值是否相等就行了)，不就log(n)了嘛。设a[j]-a[i]=m,如果a[j]+m>n,那肯定没有数满足题目条件(所有数)，且a[i]要>=1,那么m=min(n-a[j],a[j]-1)。我们要找的a[i]区间就是[a[j]-m,a[j]-1],对应的a[k]区间就是[a[j]+1,a[j]+m](反向存就很好满足对应关系了,如果都是正向,同一个位置代表的都是第i小的，并不能对应(如果有反转这类操作当我没说))
    最后注意多组数据，记得清空hash数组
```cpp

#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<queue>
#include<deque>
#include<iostream>
#define ll long long
#define re register
#define inf 0x7f7f7f7f
#define inl inline
//#define eps 1e-8
#define debug printf("debug\n");
//#pragma comment(linker, "/STACK:1024000000,1024000000")
//#pragma GCC optimize (2)
//#pragma G++ optimize (2)
using namespace std;
const ll mod=2147483647;//模数是int最大值，一般不会重,,,吧？ 
inl ll read() {
    re ll x = 0; re int f = 1;
    char ch = getchar();
    while(ch<'0'||ch>'9') { if(ch== '-' ) f = -1; ch = getchar(); }
    while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    return x * f;
}
inl void write(ll x){
    if(x>=10)write(x/10);
    putchar(x%10+'0');
}
inl void writeln(ll x){
    if(x<0) {x=-x;putchar('-');}
    write(x); puts("");
}//日常一堆头文件+读优,输出优化 
ll ssw[10005];ll Pow[10005];
ll hash1[10005<<2],hash2[10005<<2];
void pushup(ll x,ll m){
    ll t=m>>1;
    hash1[x]=(hash1[x<<1]*Pow[t]+hash1[x<<1|1])%mod;//hash1是正向的 
    hash2[x]=(hash2[x<<1|1]*Pow[m-t]+hash2[x<<1])%mod;//hash2反向存
}
void update(ll val,ll l,ll r,ll x){//x号节点，区间为l到r，这次插入的值为val 
    if(l==r){hash1[x]=hash2[x]=1;return;}
    ll mid=(l+r)>>1;
    if(val<=mid) update(val,l,mid,x<<1);
    else update(val,mid+1,r,x<<1|1);
    pushup(x,r-l+1);
}
ll query1(ll L,ll R,ll l,ll r,ll x){
    if(L>R) return 0;
    if(L==l&&r==R){return hash1[x];}
    ll mid=(l+r)>>1;
    if(R<=mid) return query1(L,R,l,mid,x<<1);
    else if(L>mid) return query1(L,R,mid+1,r,x<<1|1);
    else return (query1(L,mid,l,mid,x<<1)*Pow[R-mid]+query1(mid+1,R,mid+1,r,x<<1|1))%mod;//正向找 
}
ll query2(ll L,ll R,ll l,ll r,ll x){
    if(L>R) return 0;
    if(L==l&&r==R){return hash2[x];}
    ll mid=(l+r)>>1;
    if(R<=mid) return query2(L,R,l,mid,x<<1);
    else if(L>mid) return query2(L,R,mid+1,r,x<<1|1);
    else return (query2(L,mid,l,mid,x<<1)+query2(mid+1,R,mid+1,r,x<<1|1)*Pow[mid-L+1])%mod;//反向找 
}//线段树常规操作，需要注意的只是hash2是反向存储的 
int main(){
    re ll T=read();Pow[1]=3;
    for(re ll i=2;i<=10000;i++) Pow[i]=(3*Pow[i-1])%mod;//pow会重名...然后听说不预处理会T 
    while(T--){
        memset(hash1,0,sizeof(hash1));
        memset(hash2,0,sizeof(hash2));//记得清空 
        re ll n=read();
        for(re ll i=1;i<=n;i++) ssw[i]=read();
        bool flag=0;
        for(ll i=1;i<=n;i++){
            ll len=min(ssw[i]-1,n-ssw[i]);//确保我们要找的数在1~n的范围内 
            if(query1(ssw[i]-len,ssw[i]-1,1,n,1)!=query2(ssw[i]+1,ssw[i]+len,1,n,1)){//找到的位置相互是对应的，直接判断是否相等 
                flag=1;break;//不相等了，a[j]前某一个a[i]没有对应的a[k]在a[j]前面，那这个a[k]肯定在a[j]后面，找到长度为3的了 
            }
            update(ssw[i],1,n,1);//把这次的值加入线段树 
        }
        puts(flag?"Y":"N");
    }
    return 0;
}
```
    

---

## 作者：cjlak1o1 (赞：9)

这道题目蒟蒻做了整整 $4$ 个小时才做出来，所以特意写一篇题解记录并警示后人。

[题目链接](https://www.luogu.com.cn/problem/P2757)

[双倍经验好评](https://www.luogu.com.cn/problem/CF452F)

[博客食用更佳哦](https://www.cnblogs.com/windseekerblog/p/16545871.html)

### 核心做法

~~这个做法不是蒟蒻想到的，蒟蒻还是太菜。~~

思路主要是枚举一个中间数 $a[i]$ 然后判断 $a[i]+k$ 和 $a[i]-k$ 是否在 $a[i]$ 的异侧。

由于枚举 $a[i]$ 很难优化，所以我们优化判断 $a[i]+k$ 和 $a[i]-k$ 。

具体做法是在原数列上标记在 $a[i]$ 左边的为 $1$，$a[i]$ 右边的为 $0$。

然后我们想，如果这里新建一个 $1$ 到 $n$ 的 $01$ 串记录每一个数字的 $01$ 状态，那么当所有的 $a[i]+k$ 和 $a[i]-k$ 都在 $a[i]$ 的同侧的话（不满足时），也就意味着 $a[i]+k$ 和 $a[i]-k$ 是同一个 $01$ 状态，那么以 $a[i]$ 为中心，两端不超过边界的 $01$ 串是不是就变成了一个**回文串**了呢。

考虑如何维护这一个回文串，从其他题解大家也可知道。

线段树维护 hash 值，左边正 hash 值等于右边反 hash 值时，其为回文串。

### 实际操作

1. 更新 $01$ 串。  
我们每次枚举到 $a[i]$ 的时候将 $a[i-1]$ 赋值为 $1$。

2. 线段树维护。  
我们每一个节点维护它所子孙中的所有叶子节点(叶子结点记录的就是数列上的数)的正反 hash 值，和它子孙中的叶子节点个数，记录为长度。每次上传将其与另一个它父亲的儿子进行合并操作。

3. 具体合并操作。  
蒟蒻和机房另一个蒟蒻想到，既然是 $01$ 串，为什么不直接采用二进制，合并的时候左移和右移即可，后来调了很久没有做出来，数据一大全都挂了，是因为**直接左移和右移过大**，所以要进行**预处理操作**。

4. 正 hash 值和反 hash 值。  
- 算正 hash 值时，左儿子正 hash 值左移右儿子的长度后，与右儿子的正 hash 值相加。
- 算反 hash 值时，右儿子反 hash 值左移左儿子的长度后，与左儿子的反 hash 值相加。
- 直接 push_up 时左/右移长度为另一儿子记录的长度，但是 query 的时候可能并没有访问某一节点子孙的所有叶子结点，所以我们要进行取 $\min$ 操作后左/右移。

5. 判断是否存在。 
左边取正 hash 值和右边取反 hash 值相等的时候为回文串，当前中心的等差数列不存在，一旦出现不相等，则存在。

6. 一些小坑点（可能只有本蒟蒻会错）。
- 每次一定要重新 build，每一个节点的每一个值都需要清空后重新赋值。
- 记得先预处理左移操作和右移操作。
- 遇到 $a[i]=1$ 或 $a[i]=n$ 时直接跳过。
- 一定记得要开 longlong。

### code
```cpp
#include<bits/stdc++.h>
#define int long long
#define ls rt<<1
#define rs rt<<1|1
#define lson ls,l,mid
#define rson rs,mid+1,r
using namespace std;
const int N=5e5+10,mod=1e9+7;
int T,n,maxn,minn,a[N],base[N];
struct node{
	int sum[2],len;//sum[0]记录正hash值，sum[1]记录反hash值
}t[N<<2];
bool flag=false;
inline int read(){
	char ch=getchar();int res=0,f=1;
	while(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}
	while('0'<=ch&&ch<='9') res=res*10+ch-'0',ch=getchar();
	return res*f;
}
void init(){
	base[0]=1;
	for(int i=1;i<=N-10+1;i++)
		base[i]=base[i-1]*2ll%mod;
}
void pushup(int rt){
	t[rt].sum[0]=((t[ls].sum[0]*base[t[rs].len])%mod+t[rs].sum[0])%mod;
	t[rt].sum[1]=((t[rs].sum[1]*base[t[ls].len])%mod+t[ls].sum[1])%mod;
}
void build(int rt,int l,int r){
	if(l==r){t[rt].len=1,t[rt].sum[0]=t[rt].sum[1]=0;return;}
	int mid=(l+r)>>1;
	build(lson),build(rson);
	t[rt].len=t[ls].len+t[rs].len;
	t[rt].sum[0]=t[rt].sum[1]=0;
}
void update(int rt,int l,int r,int x){
	if(l==r){t[rt].sum[0]=t[rt].sum[1]=1;return;}
	int mid=(l+r)>>1;
	if(x<=mid) update(lson,x);
	else update(rson,x);
	pushup(rt);
}
inline int query(int rt,int l,int r,int ql,int qr,int k){//k为0是求正hash值，1是求反hash值
	if(ql<=l&&r<=qr) return t[rt].sum[k];
	int mid=(l+r)>>1,Llen=max(mid-max(l,ql)+1,0ll),Rlen=max(min(r,qr)-mid,0ll),res=0;
	if(!k){
		if(ql<=mid) res+=(query(lson,ql,qr,k)*base[Rlen])%mod;//左正hash移右儿子长度
		if(mid<qr) res+=query(rson,ql,qr,k)%mod;
	}
	else{
		if(ql<=mid) res+=query(lson,ql,qr,k)%mod;
		if(mid<qr) res+=(query(rson,ql,qr,k)*base[Llen])%mod;//右反hash移左儿子长度
	}
	return res%mod;
}
signed main(){
	T=read();init();//预处理左移右移操作
	while(T--){
		n=read(),flag=false;build(1,1,n);//预处理
		for(int i=1;i<=n;i++) a[i]=read();
		for(int i=2;i<n;i++){
			update(1,1,n,a[i-1]);//更新上一位为1
			if(a[i]==1||a[i]==n) continue;//1,n直接跳过
			int L=min(a[i]-1,n-a[i]);
			if(query(1,1,n,a[i]-L,a[i]-1,0)!=query(1,1,n,a[i]+1,a[i]+L,1)){//不相等，不为回文串
				puts("Y"),flag=true;
				break;
			}
		}
		if(!flag) puts("N");
	}
	return 0;
}
//一组no的数据
/*
1
10
1 9 5 3 7 2 10 6 4 8 
*/
/*
N
*/
```

---

## 作者：Martian148 (赞：9)

# Link
[P2757 [国家集训队]等差子序列](https://www.luogu.com.cn/problem/P2757)

# Solve

先转化一下题意，对于一个$a[i]$我们判断如果存在一个$a[i]+k$和$a[i]-k$在$a[i]$的异侧，那么就存在一个解，输出$yes$，如果对于每个$a[i]$都不存在，就输出$no$。

如何判断是否存在$a[i]+k$和$a[i]-k$的位置，我们想到了回文，处理每个$a[i]$时，我们把$a[i]$这个位置打上$1$，如果此时的序列不是以$a[i]$为中心的回文，那么肯定有一个对应的$a[i]+k$或者$a[i]-k$在$a[i]$后面，就存在解了，如果是回文，那么对于这个$a[i]$每一个k，$a[i]+k$和$a[i]-k$都在$a[i]$同侧了。

如何维护回文，很容易的想到**线段树+哈希**，一个回文串，正着哈希和反过来哈希的结果是一样的，我们就建两棵线段树，一棵表示正着哈希，一棵表示反着哈希，反着哈希的树统计时就把左儿子和右儿子交换就好了，相当于把线段树做了一次对称(这么说也不够严谨，感性理解一下就好了)。

多组数据注意一下细节

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=3e5+5,TT=1e9+7,bas=27;
typedef long long LL;
int N,a[maxn],T,flg;
LL pw[maxn];
struct node{
	LL val;
	int len;
	node(const LL v=0,const int l=0){val=v;len=1;}
}ta[maxn<<2],tb[maxn<<2];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch<='9'&&ch>='0')ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
node merge(node l,node r){
	node ret;
	ret.val=(l.val*pw[r.len]%TT+r.val)%TT;
	ret.len=l.len+r.len;
	return ret;
}

void pushup(int k){
	ta[k]=merge(ta[k<<1],ta[k<<1|1]);
	tb[k]=merge(tb[k<<1|1],tb[k<<1]);
}

void update(int k,int l,int r,int x){
	if(l==r){
		ta[k]=tb[k]=node(1,1);
		return ;
	}
	int mid=l+r>>1;
	if(x<=mid)update(k<<1,l,mid,x);
	else update(k<<1|1,mid+1,r,x);
	pushup(k);
}

node query1(int k,int l,int r,int x,int y){
	if(x<=l&&r<=y)return ta[k];
	int mid=r+l>>1;
	if(y<=mid)return query1(k<<1,l,mid,x,y);
	if(mid<x)return query1(k<<1|1,mid+1,r,x,y);
	return merge(query1(k<<1,l,mid,x,mid),query1(k<<1|1,mid+1,r,mid+1,y));
}

node query2(int k,int l,int r,int x,int y){
	if(x<=l&&r<=y)return tb[k];
	int mid=r+l>>1;
	if(y<=mid)return query2(k<<1,l,mid,x,y);
	if(mid<x)return query2(k<<1|1,mid+1,r,x,y);
	return merge(query2(k<<1|1,mid+1,r,mid+1,y),query2(k<<1,l,mid,x,mid));
}

void build(int k,int l,int r){
	if(l==r){
		ta[k]=tb[k]=node(0,1);
		return ;
	}
	int mid=r+l>>1;
	build(k<<1,l,mid);build(k<<1|1,mid+1,r);
	pushup(k);
}

int main(){
	freopen("P2757.in","r",stdin);
	freopen("P2757.out","w",stdout);
	T=read();
	while(T--){
		int flg=0;
		N=read();
		pw[0]=1;
		for(int i=1;i<=N;i++)pw[i]=pw[i-1]*bas%TT;
		build(1,1,N);
		for(int i=1;i<=N;i++){
			int x=read();
			if(flg)continue;
			update(1,1,N,x);
			int k=min(x-1,N-x);
			if(k<=0) continue;
			if(query1(1,1,N,x-k,x-1).val!=
			query2(1,1,N,x+1,x+k).val){
				printf("Y\n");
				flg=1;
			}
		}
		if(!flg)printf("N\n");	
	}
	return 0;
}
```

---

## 作者：星梦空想 (赞：6)

### 思路
简化题意，找到一个三个数的等差数列就行了

因此我们可以去枚举中间数值，判断另外两个数值是否都在左侧

动态维护存在性01序列，看看有哪些数字已经在左边出现过，如果这个序列是回文序列，说明加减公差后的数值都在这个中点的一端，因此无解。反之则有解
### 解法
~~没有难的题目，只有难的数据结构~~

如何快速判断回文？Hash

如何动态更新区间的Hash？线段树

完事了，代码如下
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long  ull;
const ull N=600005;
const ull B=13331;
int n,T;
ull p[N];
int x[N];
struct Segment{
	int l;
	int r;
	ull h1;
	ull h2;//注意类型
	
}tr[4*N];//线段树里记录正哈希和反哈希
void input(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&x[i]); 
}
void init(){//多组数据记得初始化
	for(int i=1;i<=4*500001;i++){
		tr[i]=(Segment){0,0,0,0};
	}
}
void build(int p,int l,int r){//建树
	tr[p].l=l,tr[p].r=r;
	if(l==r) return;
	int mid=(l+r)/2;
	tr[p].h1=tr[p].h2=0;//别忘了初始化，因为有多组数据
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
}
void add(int u,int v){
	if(tr[u].l==tr[u].r){
		tr[u].h1=tr[u].h2=1;
		return;
	}
	if(v<=tr[u*2].r)
		add(u*2,v);
	else
		add(u*2+1,v);
	tr[u].h1+=p[tr[u].r-v];
	tr[u].h2+=p[v-tr[u].l];//正反hash累加 
}
//利用Hash的性质从子区间里拼凑目标区间Hash值
ull H1(int u,int l,int r){//正哈希求值
	if(r<tr[u].l||tr[u].r<l) return 0;
	if(l<=tr[u].l&&tr[u].r<=r)
		return tr[u].h1*p[r-tr[u].r];
	return H1(u*2,l,r)+H1(u*2+1,l,r);
} 
ull H2(int u,int l,int r){//反哈希求值
	if(r<tr[u].l||tr[u].r<l) return 0;
	if(l<=tr[u].l&&tr[u].r<=r)
		return tr[u].h2*p[tr[u].l-l];
	return H2(u*2,l,r)+H2(u*2+1,l,r);
}
void solve(){
	init();
	build(1,1,n);
	for(int i=1;i<=n;i++){//按顺序枚举
		int v=x[i];
		int len=min(v-1,n-v);
		if(H1(1,v-len,v+len)!=H2(1,v-len,v+len)){//如果不回文说明有解
			cout<<"Y"<<endl;
			return;
		}
		add(1,v);//将其在01串中的状态更新
	}
	cout<<"N"<<endl;//都枚举完了还没找到的话就没有了
}
int main(){
	p[0]=1;
	for(int i=1;i<=500001;i++) p[i]=p[i-1]*B;//初始p值数组
	cin>>T;
	while(T--){
		input();
		solve(); 
	}
	return 0;
}
```


---

## 作者：yzy1 (赞：5)

- 神奇的 trick。
- 观察到 $a$ 是排列，这是个很有用的性质。
- 我们从左到右遍历 $a$ 数组。维护一个 $01$ 串，初始全是 $0$，扫到 $a_i$ 就把 $01$ 串的第 $i$ 位设置为 $1$。我们发现，设一整数 $j$ 满足 $a_i-j \in [1,n], a_i+j \in [1,n], a_i-j=1, a_i+j=0$，即 $a_i-j$、$a_i$、$a_i+j$ 三个数在 $a$ 中正好顺序排列，则这三个数就形成了一个长度为 $3$ 的等差子序列。
- 考虑如何在加入一个数的时候快速检查上面的判断。可以发现，上面的形式可以转化成检查 $01$ 串是否关于 $a_i$ 为中心对称。检查回文串的方式可以用字符串哈希。于是我们可以用一个线段树来维护子串的 hash 值和把字符串前后翻转时子串的 hash 值，判断这两个值是否相等来判定是否回文。
- 时间复杂度 $O(Tn\log n)$，可以通过此题。

```cpp
const int N = 2e6 + 9;
const int mo = 1000000021;
int n, pw[N];
struct Seg {
  struct T {
    int ha, har;
  } d[N];

  void Up(int u, int l, int r) {
    int mid = (l + r) >> 1;
    d[u].ha = 1ll * d[u << 1].ha * pw[r - mid] % mo;
    d[u].ha += 1ll * d[u << 1 | 1].ha, umod(d[u].ha);
    d[u].har = 1ll * d[u << 1 | 1].har * pw[mid - l + 1] % mo;
    d[u].har += 1ll * d[u << 1].har, umod(d[u].har);
  }

  void Cha(int p, int x, int u, int l, int r) {
    if (l == r) return d[u].ha = d[u].har = x, void();
    int mid = (l + r) >> 1;
    if (p <= mid)
      Cha(p, x, u << 1, l, mid);
    else
      Cha(p, x, u << 1 | 1, mid + 1, r);
    Up(u, l, r);
  }

  int Ha(int L, int R, int u, int l, int r) {
    if (L <= l && r <= R) return d[u].ha;
    int mid = (l + r) >> 1;
    if (R <= mid) return Ha(L, R, u << 1, l, mid);
    if (mid + 1 <= L) return Ha(L, R, u << 1 | 1, mid + 1, r);
    return (1ll * Ha(L, R, u << 1, l, mid) * pw[min(r, R) - mid] % mo +
            Ha(L, R, u << 1 | 1, mid + 1, r)) %
           mo;
  }

  int Har(int L, int R, int u, int l, int r) {
    if (L <= l && r <= R) return d[u].har;
    int mid = (l + r) >> 1;
    if (R <= mid) return Har(L, R, u << 1, l, mid);
    if (mid + 1 <= L) return Har(L, R, u << 1 | 1, mid + 1, r);
    return (1ll * Har(L, R, u << 1 | 1, mid + 1, r) * pw[mid + 1 - max(l, L)] % mo +
            Har(L, R, u << 1, l, mid)) %
           mo;
  }
} seg;

void Work() {
  cin >> n;
  memset(seg.d, 0, sizeof(*seg.d) * (n * 4 + 1));
  bool fl = 0;
  re (i, n) {
    int x;
    cin >> x;
    if (fl) continue;
    seg.Cha(x, 1, 1, 1, n);
    int len = min(n - x, x - 1), ha = seg.Ha(x, x + len, 1, 1, n),
        har = seg.Har(x - len, x, 1, 1, n);
    if (ha != har) cout << "Y\n", fl = 1;
  }
  if (!fl) cout << "N\n";
}
```

---

## 作者：Chthologist7507 (赞：4)

双倍经验：CF452F Permutation

**线段树+哈希**

~~我菜死了调了好久然后搞了半天才 AC，~~ 所以在代码中会提到一些坑点


## 分析

显然的，只要找到三元等差数列即可，因为

- 题目要求 $len\geq3$，所以只用满足最低条件
- 更多元的都是在三元的基础上的 ~~三生万物（~~

对于三元等差数列，有一个常见技巧就是枚举中值 $b=a_i$，然后找 $b-k,b+k$ 是否在同侧，如果在同侧就寄了，不在就赢了

如果暴力枚举 $b,k$ 那就是平方级别了，妥妥 TLE

考虑优化，对于枚举 $b$，无法优化，只能考虑优化 $k$ 的寻找

动态维护存在性 01 串，表示每一个数是否在左边出现，在右边是否出现，如果是回文串，那就寄了，因为一大一小全部集中在左侧或右侧，否则就赢了

如何快速判断回文？字符串哈希，如果正着的哈希等于反着的哈希，那么就回文

那么就是搞一个 $\log$ 级的动态维护哈希值的数据结构，考虑使用线段树，每个节点记录长度和正反哈希值

没了，思路就这么简单

## 代码

如果没有深入理解的话坑点会比较多，所以结合注释食用

```cpp
#include <bits/stdc++.h>
#define ll unsigned long long
#define inl inline
#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;++i)
#define pre(i,a,b) for(int i=(a),i##end=(b);i>=i##end;--i)
using namespace std;
const int N=5e5+10,mod=1e9+7,B=27;
struct Node{
	ll h1,h2;int l1,l2;
	Node(const ll v=0,const int l=0){h1=h2=v;l1=l2=1;}
}t[N<<2];//这里用了一个大结构体，h1,h2 是正反哈希值，l1,l2表示长度
int n,a[N],T;
ll p[N];
bool flag;
Node comp(Node x,Node y){
	Node tmp;
	tmp.h1=(x.h1*p[y.l1]%mod+y.h1)%mod;
	tmp.h2=(y.h2*p[x.l2]%mod+x.h2)%mod;//请注意 h2 表示反哈希，所以要相对于正哈希反着操作，要不然就 WA 16 pts
	tmp.l1=x.l1+y.l1;tmp.l2=x.l2+y.l2;
	return tmp;
}//合并操作，用于上传
namespace Tree{
	#define ls k<<1
	#define rs k<<1|1
	#define mid (l+r>>1)
	#define pushup(k) t[k]=comp(t[ls],t[rs])
	inl void update(int k,int l,int r,int x){
		if(x<l||x>r)return ;
		if(l==r){
			Node tmp;tmp.h1=tmp.h2=1;tmp.l1=tmp.l2=1;
			t[k]=tmp;
			return ;
		}
		update(ls,l,mid,x);update(rs,mid+1,r,x);pushup(k);
	}
	inl void build(int k,int l,int r){
		if(l==r){
			Node tmp;tmp.h1=tmp.h2=0;tmp.l1=tmp.l2=1;
			t[k]=tmp;
			return ;
		}
		build(ls,l,mid);build(rs,mid+1,r);pushup(k);
	}
	Node query(int k,int l,int r,int x,int y){
		if(x<=l&&y>=r)return t[k];
		if(y<=mid)return query(ls,l,mid,x,y);
		if(mid<x)return query(rs,mid+1,r,x,y);
		return comp(query(ls,l,mid,x,mid),query(rs,mid+1,r,mid+1,y));
	}
}
using namespace Tree;
signed main(void){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	int T;cin>>T;
	while(T--){
		// rep(i,1,N<<2)t[i].h1=t[i].h2=t[i].l1=t[i].l2=0;
		p[0]=1;flag=0;
		cin>>n;
		rep(i,1,n)p[i]=p[i-1]*B%mod;
		build(1,1,n);
		rep(i,1,n){
			int x;cin>>x;//不论是否找到了三元等差数列，都要读完（一上来因为这个寄了一发）
			if(flag)continue;
			update(1,1,n,x);
			int len=min(x-1,n-x);
			if(len<=0)continue;//不合法特判
			if(query(1,1,n,x-len,x-1).h1!=query(1,1,n,x+1,x+len).h2){//如果正哈希不等于反哈希，找到了
				cout<<"Y\n";flag=1;
			}
		}
		if(!flag)cout<<"N\n";
	}
}
```

完结撒花！

---

## 作者：QZJ666 (赞：0)

## 题意：

给定长度为 $n$ 的排列 $a$，判断其中是否存在等差数列。

## 做法：

首先因为这个题是判断是否存在等差数列。如果存在长度为 $x(x>3)$ 的子序列，那么这个序列中任意相邻 $3$ 项都是等差序列，所以只需要判断是否存在长度为 $3$ 的等差序列。

对于这种 $3$ 个数的问题，我们考虑枚举中间的那个数，设我们枚举位置为 $i$，设公差为 $v$，只要我们可以在 $1$ 到 $i-1$ 中找到 $a_i-v$，在 $i+1$ 到 $n$ 中找到 $a_i+v$（或者反过来）就满足条件。

直接思考不是很好想，考虑将过程转化成 $01$ 序列，在我们枚举到第 $i$ 个点时，已经出现的数为 $1$，没有出现过的数为 $0$，相当于在序列的第 $a_i$ 个位置，若 $a_i-v$ 出现过且 $a_i+v$ 也出现过，或者都没有出现过时，因为 $a$ 是一个排列，所以 $a_i-v$ 和 $a_i+v$ 一定在 $i$ 的同侧，对于选的这一个 $v$ 无解。那么如果这个对于任意一个 $v$ 都无解的话，这个序列一定是以 $a_i$ 为中心对称的，也就是左边从左往右的序列和右边从右往左的序列相等。

判断序列相等？hash！

于是我们只需要维护从左往右和从右往左的哈希值，还要支持修改，于是用一个线段树来维护。时间复杂度$\mathcal{O}(T n\log n)$


## 代码
```cpp
#include<bits/stdc++.h>
typedef unsigned long long ull;
using namespace std;
const ull seed=233;
int n;
char a[500005];
ull ksm[500005];
struct node{
	int l,r;
	ull vl,vr;
}Tree[2000005];
void ztree(int p,int l,int r){
	Tree[p].l=l,Tree[p].r=r;
	if(l==r){
		Tree[p].vl=Tree[p].vr=(unsigned long long)a[l];
		return;
	}
	int mid=l+r>>1;
	ztree(p*2,l,mid);
	ztree(p*2+1,mid+1,r);
	Tree[p].vl=Tree[p*2].vl*ksm[r-mid]+Tree[p*2+1].vl;
	Tree[p].vr=Tree[p*2+1].vr*ksm[mid-l+1]+Tree[p*2].vr;
}
ull Getl(int p,int l,int r){
	if(l<=Tree[p].l&&Tree[p].r<=r)return Tree[p].vl;
	int mid=Tree[p].l+Tree[p].r>>1;
	ull vl=0,vr=0;
	if(l<=mid)vl=Getl(p*2,l,r);
	if(r>mid)vr=Getl(p*2+1,l,r);
	if(!vl)return vr;
	if(!vr)return vl;
	return vl*ksm[min(Tree[p*2+1].r,r)-mid]+vr;
}
ull Getr(int p,int l,int r){
	if(l<=Tree[p].l&&Tree[p].r<=r)return Tree[p].vr;
	int mid=Tree[p].l+Tree[p].r>>1;
	ull vl=0,vr=0;
	if(l<=mid)vl=Getr(p*2,l,r);
	if(r>mid)vr=Getr(p*2+1,l,r);
	if(!vl)return vr;
	if(!vr)return vl;
	return vr*ksm[mid+1-max(Tree[p*2].l,l)]+vl;
}
void update(int p,int l){
	if(Tree[p].l==Tree[p].r){
		Tree[p].vl=Tree[p].vr=(unsigned long long)a[l];
		return;
	}
	int mid=Tree[p].l+Tree[p].r>>1;
	if(l<=mid)update(p*2,l);
	else update(p*2+1,l);
	Tree[p].vl=Tree[p*2].vl*ksm[Tree[p].r-mid]+Tree[p*2+1].vl;
	Tree[p].vr=Tree[p*2+1].vr*ksm[mid-Tree[p].l+1]+Tree[p*2].vr;
}
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		ksm[0]=1;
		for(int i=1;i<=n;i++)a[i]='0',ksm[i]=ksm[i-1]*seed;
		ztree(1,1,n);
		bool fl=0;
		for(int i=1;i<=n;i++){
			int x;
			scanf("%d",&x);
			if(fl)continue;
			if(x==1||x==n){
				a[x]='1';
				update(1,x);
				continue;
			}
			int lenl=x-1,lenr=n-x;
			if(lenl<lenr)lenr=lenl;
			else lenl=lenr;
			ull vl=Getl(1,x-lenl,x-1);
			ull vr=Getr(1,x+1,x+lenr);
			a[x]='1';
			update(1,x);
			if(vl!=vr)fl=1;
		}
		if(!fl)puts("N");
		else puts("Y");
	}
	return 0;
}
```


---


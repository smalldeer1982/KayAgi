# [SDOI2013] 泉

## 题目描述

作为光荣的济南泉历史研究小组中的一员，铭铭收集了历史上x个不同年份时不同泉区的水流指数，这个指数是一个小于. 2^30的非负整数。第i个年份时六个泉区的泉水流量指数分别为 A(i,l)，A(i,2)，A(i,3)，A(i,4)， A(i,5)与 A(i,6)。

现在铭铭希望知道有多少对不同的年份：i和j,满足这两年恰好有K个泉区的泉水流S指数对应相同。


## 说明/提示

对于 100%的数据, 0<=K <=6, 且所有数据中K是等概率出现的, 即对于任意的 0<=x都有大约 1/7 的数据中 K=x.
N<=100000

## 样例 #1

### 输入

```
3 3
1 2 3 4 5 6
1 2 3 0 0 0
0 0 0 4 5 6```

### 输出

```
2```

# 题解

## 作者：Imakf (赞：28)

~~怎么题解都是用哈希的啊，怎么容斥都看不懂啊~~

我们设```f[i]```为**至少**有$i$个泉区的水流指数对应相同

再设```g[i]```为**恰好**有$i$个泉区的水流指数对应相同（也就是答案数组）

```f[i]```可以直接暴力选中$i$个位置，把那些位置上的泉水指数单独拿出来，排个序（懒得写哈希）然后就能直接求了

想想怎么求```g[i]```

对于$i<j$发现其实```g[j]```在```f[i]```里面算了$C(j,i)$遍

那么我们就能得到```f[i],g[i]```的关系

$$g[i]=f[i]-\sum\limits_{j=i+1}^{6}g[j]*C_j^i$$

直接按这个式子dp就行了

数组记得稍微开大点，不然就是91分

复杂度$O(2^6n \log n)=O(n\log n)$

```cpp
#include<cstdio>
#include<cstring>
#include<ctime>
#include<cstdlib>
#include<algorithm>

#define rg register
#define il inline
#define MX (100000 + 500)
#define ll long long

il int read(){
	rg char k = getchar();
	while(k < '0' || k > '9')	k = getchar();
	int x = 0;
	while(k >= '0' && k <= '9'){
		x = x * 10 + k - '0';
		k = getchar();
	}
	return x;
}

ll C(int n ,int m){
	if(n < m)	return 0;
	ll s1 = 1 ,s2 = 1;
	for(rg int i = 0 ; i < m ; ++i)
		s1 *= (ll)n - i ,s2 *= (ll)i + 1;
	return s1 / s2;
}

int tot;
struct data{
	int a[6];
	il bool operator <(const data b)const{
		for(rg int i = 0 ; i < tot ; ++i)
			if(a[i] != b.a[i])	return a[i] < b.a[i];
		return false;
	}
	il bool operator ==(const data b)const{
		for(rg int i = 0 ; i < tot ; ++i)
			if(a[i] != b.a[i])	return false;
		return true;
	}
}org[MX] ,tmp[MX];

ll ans[7];
int use[MX] ,n ,k;
void solve(){
	for(rg int i = 0 ; i < n ; ++i)
		for(rg int j = 0 ; j < tot ; ++j)
			tmp[i].a[j] = org[i].a[use[j]];
	std::sort(tmp ,tmp + n);
	ll _ans = 0 ,tmpsum = 1;
	//tmpsum表示当前有几个连续相同的
	for(rg int i = 1 ; i < n ; ++i){
		if(tmp[i] == tmp[i - 1])	++tmpsum;
		else _ans += tmpsum * (tmpsum - 1) / 2 ,tmpsum = 1;
	}
	_ans += tmpsum * (tmpsum - 1) / 2;
	ans[tot] += _ans;
}
void dfs(int now ,int num){
	if(now == 6){
		if(tot == num)
			solve();
		return ;
	}
	use[tot++] = now;
	dfs(now + 1 ,num);
	--tot;
	dfs(now + 1 ,num);
}

int main(){
	scanf("%d%d" ,&n ,&k);
	for(rg int i = 0 ; i < n ; ++i)
		for(rg int j = 0 ; j < 6 ; ++j)
			org[i].a[j] = read();
			
	for(rg int i = 6 ; i >= k ; --i){
		dfs(0 ,i);
		for(rg int j = i + 1 ; j <= 6 ; ++j){
			ans[i] -= ans[j] * C(j ,i);
		}
	}
	printf("%lld\n" ,ans[k]);
	return 0;
}
```



---

## 作者：一念之间、、 (赞：7)

这里提供一个与其他题解不同的做法（不会被卡/xyx）

首先我们设`res`表示至少有`i`个相同泉水的方案，`ans`表示恰好`i`个相同泉水的方案，我们可以发现这个式子(和其他题解差不多)

$ans[i]=res[i]-\sum_{j=i+1}^{6}\binom{j}{i}\times ans[j]$

然后我们考虑求`res`，发现我们枚举每一个$2^{k}$按照关键字来排序后连续的一段相同的可以计入答案，这样明显跑不过去。

这时候有人可能要说用`hash`了，但是**不**，我们可以直接排序

发现一共就$6*n$个数，所以我们可以把数离散化一下，值域范围很小，考虑基数排序。

按照每个关键字排序+查找，常数优化小技巧：多用`memset`和`memcpy`

让我们计算一下复杂度$O(64\times n \times 6)$最后那个6还跑不满（但是基数排序要4个循环）复杂度还是把别人的`log`+大常数吊起来大

目前是`rank2`（没有专门卡常，不知道rank1是怎么写的/kk）

下面是代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
char gc()
{
	static char buf[1<<16],*s,*t;
	if(s==t)
	{
		t=(s=buf)+fread(buf,1,1<<16,stdin);
		if(s==t)return EOF;
	}
	return *s++;
}
#define getchar gc
int read()
{
	char c;
	int w=1;
	while((c=getchar())>'9'||c<'0')if(c=='-')w=-1;
	int ans=c-'0';
	while((c=getchar())>='0'&&c<='9')ans=(ans<<1)+(ans<<3)+c-'0';
	return ans*w;
}
int n,m;
const int xx=1e5+5;
int a[xx][7];
int lsh[xx*6],c[100];
ll ans[xx];
int C[8][8];
vector<int>v[100];
int T[xx*6],id[xx],nid[xx];
signed main(){
//	freopen("a.in","r",stdin);
//	freopen("a.out","w",stdout);
	for(int i=0;i<64;i++)
		for(int j=0;j<6;j++)if((i>>j&1))c[i]+=1,v[i].push_back(j+1);
	for(int i=0;i<=7;i++)C[i][0]=1;
	for(int i=1;i<=7;i++)
		for(int j=1;j<=i;j++)C[i][j]=C[i-1][j]+C[i-1][j-1];
	n=read();
	m=read();
	int tot=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=6;j++)a[i][j]=lsh[++tot]=read();
	sort(lsh+1,lsh+tot+1);
	tot=unique(lsh+1,lsh+tot+1)-lsh-1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=6;j++)a[i][j]=lower_bound(lsh+1,lsh+tot+1,a[i][j])-lsh;
	for(int t=6;t>=0;t--)
	{
		for(int j=0;j<64;j++)//这两个加在一起一共64 
		{
			if(c[j]==t)
			{
				for(int i=1;i<=n;i++)id[i]=i;//排名为i的是哪个 
				for(int k=0;k<t;k++)
				{
					int w=v[j][k];
					memset(T,0,sizeof(T[0])*(tot+1));
					for(int i=1;i<=n;i++)T[a[i][w]]++;
					for(int i=1;i<=tot;i++)T[i]+=T[i-1];
					for(int i=n;i>=1;i--)nid[T[a[id[i]][w]]--]=id[i];
					memcpy(id,nid,sizeof(id[0])*(n+1));//绝对跑过，也最多就只有153600000 
				}
				for(int i=1;i<=n;i++)
				{
					int tot=1;
					while(1)
					{
						if(i==n)break;
						int vs=1;
						for(int k=0;k<t;k++)
						{
							int w=v[j][k];
							if(a[id[i]][w]!=a[id[i+1]][w]){vs=0;break;}
						}
						if(vs)tot++,i++;
						else break;
					}
					ans[t]+=(1ll*tot*(tot-1))/2;
				}
			}
		}
		for(int k=t+1;k<=6;k++)ans[t]-=ans[k]*C[k][t];
		if(t==m)return cout<<ans[t]<<"\n",0;
	}
	return 0;
}
```


---

## 作者：Shikita (赞：6)

# 哈希&&容斥
因为题目里面的 恰好有K个泉区的泉水流S指数对应相同
恰好两字暗示我们此题需要用容斥原理来做

## 思路~~（参考网上部分博客）~~
由于先处理再哈希会TLE，所以这里我们直接先处理出状态然后再拿一个哈希搞一搞
关于容斥原理 （~~不会的自行百度~~），其实就是我们计算出大于等于k个的组别，然后再减去k+1，再加上k+2……这样一直下去，然后再拿个组合数搞一搞就出来了

```
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
const int N=100010,mod1=233,mod2=1e7+33;
int n,m,cnt,a[N][7],c[7][7],head[mod2+10],to[N],nxt[N];
ll ans,sm[N];
inline int read()
{
    int x=0;
    char c=getchar();
    bool flag=0;
    while(c<'0'||c>'9') {if(c=='-')flag=1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x+(x<<2)<<1)+ c-'0';c=getchar();}
    return flag?-x:x;
}
inline bool check(int x,int y,int k)
{
    for(int i=1;i<=6;++i) if (k&(1<<(i-1)) && a[x][i]!=a[y][i]) return 0;
    return 1;
}
inline ll calc(int k)
{
    ll res=0,cnt=0,p;
    memset(head,0,sizeof(head));
    for(int i=1;i<=n;++i)
	{
        ll x=0;
        for(int j=1;j<=6;++j) if (k&(1<<(j-1))) x=(x*mod1+a[i][j])%mod2;
        for (p=head[x];p;p=nxt[p]) if(check(to[p],i,k)) {res+=sm[p]++;break;}
        if (!p) to[++cnt]=i,sm[cnt]=1,nxt[cnt]=head[x],head[x]=cnt;
    }
    return res;
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;++i) for(int j=1;j<=6;++j) a[i][j]=read();
    c[0][0]=1; for(int i=1;i<=6;++i){c[i][0]=1;for(int j=1;j<=6;++j) c[i][j]=c[i-1][j-1]+c[i-1][j]; }
    for(int S=0;S<=63;++S)
	{
        int cnt=0;
        for(int i=0;i<=5;++i) if(S&(1<<i)) cnt++;
        if(cnt<m) continue;
        ll t=calc(S)*c[cnt][m];
        ans+=(cnt-m)&1?-t:t;
    }
    printf("%lld\n",ans);
}
```
另外，这题有一个神奇的坑点，就是关于mod2

~~为什么我用19260817就会T6个点啊~~
~~一定是这题不允许膜蛤~~

---

## 作者：劉子颺 (赞：5)

给一个容斥系数的证明

设$F_{i}$为第i项的容斥系数

$G_{i}$为$[i==K]$


考虑基于DP写出容斥系数

$F_{i}=[i==K]-\sum_{j=1}^{i-1}\binom{i}{j}F_{j}$

换一下就是：

$\sum_{j=1}^{i}\binom{j}{i}F_{j}=[i==K]$

二项式反演

$F_{i}=\sum_{j=1}^{i}\binom{j}{i}[j==K](-1)^{i-j}$

为$F_{i}=\binom{i}{k}(-1)^{j-i}$

---

## 作者：AlanSP (赞：3)

### Description

> 给你 $n$ 个六元组，问其中有 $K$ 个元素对应相同的六元组对 $(i,j)$ 的个数



### Solution

哈希+容斥。

如果能求出至少有 $i$ 对的个数 $f(i)$，那么我们可以通过二项式反演得到答案，即：
$$
\mathrm{ans}=\sum_{i=K}^6(-1)^{i-K}f(i)\binom i K
$$
那么现在问题就转化为了求 $f(i)$ 。

考虑到元素个数为 $6$，我们可以状压 $S$  表示强制让 $S$ 里面的这些元素相同的对数。

为了快速判断相等，我们可以每次构建哈希表，每次把必选的元素哈希起来。

在插入的过程中维护一下元素个数就好了。记得每次要清空。

---

### Code

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define int long long 
const int N=200009,base=131111,mod=1e5+9;
int n,a[N][10],K,C[10][10],pw[10],ans;

struct Hash
{
	int ver[N],nxt[N],h[N],s[N],tot=0,mp[N];

	void add(int x,int y)
	{
		ver[++tot]=y,nxt[tot]=h[x],h[x]=tot,s[tot]=1;
	}

	int ask(int x,int y)
	{
		for(int i=h[x];i;i=nxt[i])
		{
			int v=ver[i];
			if(v==y){s[i]++;return s[i]-1;}
		}
		add(x,y);
		return 0;
	}
	void clear(){tot=0;}
} H;

inline void Init()
{
	C[0][0]=1;
	for(int i=1;i<=6;i++)
		for(int j=0;j<=i;j++)
			if(!j) C[i][j]=1;
			else C[i][j]=C[i-1][j-1]+C[i-1][j];
}

inline int get(int x)
{
	int res=0;H.clear();//!
	for(int i=1;i<=n;i++)
	{
		int hsh=0;
		for(int j=0;j<6;j++)
			if(x&(1<<j)) hsh=hsh*base+a[i][j+1];
		int pos=(hsh%mod+mod)%mod;
		if(H.mp[pos]!=x) H.mp[pos]=x,H.h[pos]=0;//在冲突时更换为当前元素
		res+=H.ask(pos,hsh);
	}
	return res;
}

signed main()
{
	Init();
	scanf("%lld%lld",&n,&K);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=6;j++)
			scanf("%lld",&a[i][j]);
	for(int i=0;i<(1<<6);i++)
	{
		int cnt=0;
		for(int j=0;j<6;j++)
			if(i&(1<<j)) ++cnt;
		if(cnt<K) continue;
		int sign=(cnt-K)&1?-1:1;
		ans+=sign*get(i)*C[cnt][K];
	}
	printf("%lld",ans);
	return 0;
}
```



---

## 作者：zac2010 (赞：2)

考虑容斥。

我们记至少有 $i$ 个指标相同的年份对数为 $f_i$，那么最终答案为：

$$
\sum_{i=k}^n (-1)^{i-k}\times C_{i}^{k}\times f_i
$$

$f_i$ 可以通过枚举状态，之后通过字符串哈希来计数得到（注意指标只有 $6$ 个）。字符串哈希可以把 `base` 设为 $10^9+7$，模数设为 $2^{64}$（也即 `unsigned long long`）。

```cpp
#include <bits/stdc++.h>
#define FL(i, a, b) for(int i = (a); i <= (b); ++i)
#define FR(i, a, b) for(int i = (a); i >= (b); --i)
using namespace std;
typedef unsigned long long ull;
const int N = 1e5 + 10;
const ull base = 1e9 + 7;
int n, k, a[N][6], C[7][7];
unordered_map<ull, int> m;
long long ans;
int main(){
	scanf("%d%d", &n, &k);
	FL(i, 0, 6){
		C[i][0] = 1;
		FL(j, 1, i){
			C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
		}
	}
	FL(i, 1, n) FL(j, 0, 5) scanf("%d", &a[i][j]);
	FL(s, 0, 63){
		int b = __builtin_popcount(s);
		unordered_map<ull, int>().swap(m);
		if(b >= k){
			FL(i, 1, n){
				ull v = 0;
				FL(j, 0, 5) if(s >> j & 1)
					v = v * base + a[i][j];
				ans += (((b - k) & 1)? -1ll : 1ll) * (m[v]++) * C[b][k];
			}
		}
	}
	printf("%lld\n", ans);
	return 0;
}
```


---

## 作者：野生林登万 (赞：2)

# [SDOI2013]泉

~~这道题对咱来说算是有buff，咱看到这道题的名字就啪一下点进来了~~

~~泉宝，咱的泉宝，嘿嘿~~(不要在意这个发电的人)

## 思路

首先仔细读题：有多少对不同的年份**恰好**有 $K$ 个泉区。这种统计题的基本套路就是容斥(如果你不知道的话，现在就知道啦)，因为**刚好** $K$ 个指数相同的年份对(以下简称”元素") 是不好统计的——因为要刚好 $K$ 个元素相同的统计方法应该就是对于每个元素判断其合法性(也许有更优的方法？既然各位Dalao都没提出来咱就当没有啦)，因为是基于枚举方案的统计所以说复杂度为元素数量 $O(n^{2})$，不可接受......

我们转换思路，如果是统计**至少** $K$ 个元素相同的话，我们可以先枚举到底**必须**哪 $K$ 个指数相同(当然，其他指数相同我们是不介意的)，这种情况下我们只需要用桶装下这 $K$ 个指数，对于有相同的这 $K$ 个指数的年份的数量 $Q$ (~~泉!~~)，肯定为答案贡献了 $\frac {Q \times (Q-1) }{2}$ (因为一共有这么多对年份对嘛)。从根本上来看，这是统计方式从 枚举方案 变成了 用桶统计同类方案，那么复杂度 $O(n^{2}) \rightarrow O(n)$ (这也是统计题的常见套路啦)

最后的最后，**刚好** $K$ 个元素相同和至少 $K$ 个元素相同肯定是不一样的，我们列出两者的关系。为了方便，我们表示前者为 $f(x)$，$g(x)$，那么有：(由基本逻辑得)

$$
g(x) = \sum ^{6} _ {i=x+1}f(i)
$$

这是不是有点像前缀和呢，总之对于 $f(x)$ 我们只需要用 $g(x)$ 减去 $f(y) (y > x)$ 就可以了......个鬼啊！这是咱的第一个思路，是错误的......考虑对于三个指数 $A,B,C$，它对于两个指数 $g(2)$ 的贡献方案有 $(A,B) + C$，$A+(B,C)$，$B+(A,C)$。相当于 $g(x)$ 对 $f(y)$ 的额外非法贡献为 $\binom{x}{y} \times f(x)$。总的来说，我们有：

$$
f(i) = g(i) - \sum ^{6} _{j=i+1} f(j) \times \binom {i} {j}
$$

所以，我们先枚举本回合内只关注哪几个指数，用一个 `unordered_map` 当作桶，来装下每一个年份的指数哈希值(当然只对关注的指数进行哈希)，由此统计出 $g(x)$，最后用上面的转移式得出 $f(x)$，$f(K)$ 即为答案。

于是我们就A了这道题，可喜可贺可喜可贺，~~完结撒泉宝~~

## 代码

```cpp
#include<bits/stdc++.h>
#define debug(x) cout<<#x<<":"<<x<<endl;
#define ull unsigned long long
using namespace std;//泉~咱的泉(bushi 
const int MAXN = 1e5 + 6;
const int myBase = 1e9 + 7;
int n,k,w[MAXN][7];
const vector<int> del = {1,2,3,4,5,6};//deleted
const int MAXU = 1e7;
bool vis[MAXU],sel[7];//selected
inline int Execute(){
	unordered_map<ull,int> mp;
	for(int i = 1;i <= n;i++){
		ull hashval = 0;
		for(int j = 1;j <= 6;j++){
			if(sel[j]){
				hashval ^= w[i][j];
			}
			hashval *= myBase;
		}
		mp[hashval]++;
	}
	int ret = 0;
	for(auto i : mp){
		ret += i.second * (i.second-1) / 2;
	}
	return ret;
}
inline int Solve(int k){//枚举关心的指数 
	vector<int> d = del;//因为很懒所以用了next_permutation()和Hash_vis[],大家可以dfs 
	memset(vis,0,sizeof(vis));
	int ans = 0;
	do{
		memset(sel,0,sizeof(sel));
		for(int i = 0;i < k;i++){
			sel[d[i]] = 1;
		}
		int now = 1,val = 0;
		for(int i = 1;i <= 6;i++){
			if(sel[i])val += now;
			now *= 10;
		}
		if(vis[val])continue;
		vis[val] = 1;
		ans += Execute();
	}while(next_permutation(d.begin(),d.end()));
	return ans;
}
int l[7],only[7],C[9][9];
inline void Pre(){//预处理C 
	for(int i = 0;i <= 7;i++)C[i][0] = 1;
	for(int i = 1;i <= 7;i++){
		for(int j = 1;j <= 7;j++){
			C[i][j] = C[i-1][j-1] + C[i-1][j];
		}
	}
	return ;
}
int main(){
	ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
	Pre();
	cin>>n>>k;
	for(int i = 1;i <= n;i++){
		for(int j = 1;j <= 6;j++){
			cin>>w[i][j];
		}
	}
	for(int i = 1;i <= 6;i++){
		l[i] = Solve(i);
	}
	l[0] = n * (n-1) / 2;
	for(int i = 6;i >= 0;i--){
		only[i] = l[i];
		for(int j = i+1;j <= 6;j++){
			only[i] -= only[j] * C[j][i];
		}
	}
	cout<<only[k];
	return 0;
}
```

因为咱非常懒，用了很多低效率的 STL 和算法，所以时间耗时大。如果手写哈希或者排序之类的效率会高的多

## 总结

本题主要有以下几个思路：

1. 转换统计方式，枚举方案判断是否合法，不如元素分类计算方案数，因为前者基于方案数的复杂度无法接受
2. 容斥原理的运用，考虑**至少**和**仅有**之间的关系
3. 用桶维护同类元素的个数

---

## 作者：lhm_ (赞：2)

考虑到年份数很小，只有 $6$，所以可以 $2^6$ 来枚举子集，确定流量指数对应相同的位置，然后通过哈希和排序来计算相同的方案数。

但是这样计算出的是大于等于子集元素个数的方案数，所以还需要通过容斥来得到恰好为 $k$ 的方案数。设子集元素个数为 $i$，相同个数恰好为 $i$ 的方案数对相同个数大于等于 $k$ 的方案数的贡献为 $\binom{i}{k}$，由二项式反演得容斥系数为 $(-1)^{i-k}\binom{i}{k}$。

为了防止被卡，我这里用了双哈希来实现。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 100010
#define p1 998244353
#define p2 1000000007
#define b1 131
#define b2 137
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
ll n,k,ans;
ll a[maxn][10],C[10][10];
bool tag[6];
struct node
{
    ll h1,h2;
}t[maxn];
bool cmp(const node &a,const node &b)
{
    if(a.h1==b.h1) return a.h2<b.h2;
    return a.h1<b.h1;
}
void init()
{
    for(int i=0;i<=6;++i) C[i][0]=1;
    for(int i=1;i<=6;++i)
        for(int j=1;j<=i;++j)
            C[i][j]=C[i-1][j]+C[i-1][j-1];
}
ll calc(int s)
{
    for(int i=1;i<=n;++i) t[i].h1=t[i].h2=0;
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=6;++j)
        {   
            t[i].h1=(t[i].h1*b1%p1+a[i][j]*tag[j])%p1;
            t[i].h2=(t[i].h2*b2%p2+a[i][j]*tag[j])%p2;
        }
    }
    sort(t+1,t+n+1,cmp);
    ll cnt=0,sum=0;
    for(int i=2;i<=n;++i)
    {
        if(t[i].h1==t[i-1].h1&&t[i].h2==t[i-1].h2) cnt++,sum+=cnt;
        else cnt=0;
    }
    return sum;
}
int main()
{
    read(n),read(k),init();
    for(int i=1;i<=n;++i)
        for(int j=1;j<=6;++j)
            read(a[i][j]);
    for(int s=0;s<=63;++s)
    {
        int num=0;
        for(int i=1;i<=6;++i)
        {
            if(s&(1<<(i-1))) num++,tag[i]=true;
            else tag[i]=false;
        }
        if(num<k) continue;
        ll val=calc(s)*C[num][k];
        if((num-k)&1) ans-=val;
        else ans+=val;
    }
    printf("%lld",ans);   
    return 0;
}
```

---

## 作者：wsyhb (赞：1)

## 前言

Q：不会写/不想写 Hash，Hash 表或基数排序，有其他办法能解决这道题 TLE 的问题吗？

A：有的。本篇题解就将介绍一种**只用 sort，不加快读和 register，不开 O2 也能轻松 AC** 的解法。

## 题解

设 $f(k)$ 表示**至少** $k$ 个区的泉水流量指数对应相同的年份对数，$g(k)$ 表示**恰好**……（与前一句相同，故省略）

注意这里的至少，是通过指定某 $k$ 个区的泉水流量指数相同得到的，因此存在重复计算的部分，即：

$$f(k)=\sum_{i=k}^{6}\binom{i}{k}g(i)$$

由**二项式反演**可得：

$$g(k)=\sum_{i=k}^{6}(-1)^{i-k}\binom{i}{k}f(i)$$

题目所求即为 $g(K)$，则需计算 $x \ge K$ 的 $f(k)$。

计算 $f(k)$ 需要枚举集合 $\{1,2,3,4,5,6\}$ 的大小为 $k$ 的子集，统计：在只考虑这 $k$ 个区的泉水流量指数的情况下，完全相同的年份对数。

要统计相同的对数，需要进行排序。若直接比较这 $k$ 个区的泉水流量指数，以此为比较方式对年份进行 sort，时间复杂度为 $O(2^{6} \cdot 6 \cdot N\log{N})$，是会 TLE 的。（当然开 O2 能 AC，不开 O2 的话得分应该在 $45$ 至 $91$ 分之间）

设当前所求的是集合 $S$ 的排序结果，即需要比较泉水流量指数的泉区的编号组成集合 $S$。不妨假设对于任意集合 $T \subsetneqq S$，其排序结果已求得。（这样的顺序很容易实现，比如从小到大枚举二进制数，计算每个二进制数对应集合的结果）

取任意 $T \subset S$ 使得 $|T|+1=|S|$， 那么 $S$ 的排序结果可以由 $T$ 的排序结果以及满足 $x \in S \setminus T$ 的 $x$ 号泉区的泉水流量指数，进行双关键字排序得到。

具体实现时，可以用一个 bool 标记，记录每个年份当前是否与上一年份相同（“相同”指当前考虑的几个泉区的泉水流量指数对应相等）。则无需使用双关键字排序，只需把每一段原本相同的年份进行排序，并更新标记即可。

总时间复杂度 $O(2^6 \cdot N\log{N})$，可以通过。

## 代码

结构体中的 `val` 记录当前新加入的泉区的泉水流量指数，`id` 记录该年份原编号，`mark` 记录当前年份是否与上一年份相同。

记录 `id` 的原因：若 $6$ 个泉区的信息都记录，不仅影响复制结构体的效率，还会 MLE。于是要记录原编号，用于每次查询新加入泉区的泉水流量指数。

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int C[7][7]={{1},{1,1},{1,2,1},{1,3,3,1},{1,4,6,4,1},{1,5,10,10,5,1},{1,6,15,20,15,6,1}};
const int max_N=1e5+5;
int A[6][max_N];
long long C2[max_N];
const int max_s=64+5;
int cnt_bits[max_s],Log[max_s];
struct Node
{
	int val,id;
	bool mark;
}now[max_s][max_N];
inline bool operator < (const Node &a,const Node &b)
{
	return a.val<b.val;
}
int main()
{
	int N,K;
	scanf("%d%d",&N,&K);
	for(int i=1;i<=N;++i)
		for(int j=0;j<6;++j)
			scanf("%d",&A[j][i]);
	for(int i=1;i<=N;++i)
	{
		C2[i]=C2[i-1]+(i-1);
		now[0][i].id=i,now[0][i].mark=i>1;
	}
	Log[0]=-1;
	for(int s=1;s<64;++s)
	{
		cnt_bits[s]=cnt_bits[s>>1]+(s&1);
		Log[s]=Log[s>>1]+1;
	}
	long long ans=K?0:C2[N];
	for(int s=1;s<64;++s)
	{
		int t=s^(s&(-s)),k=Log[s&(-s)];
		for(int j=1;j<=N;++j)
		{
			now[s][j]=now[t][j];
			now[s][j].val=A[k][now[s][j].id];
		}
		for(int j=1;j<=N;++j)
		{
			int p=j+1;
			while(p<=N&&now[s][p].mark)
				++p;
			sort(now[s]+j,now[s]+p);
			now[s][j].mark=false;
			for(int x=j+1;x<p;++x)
				now[s][x].mark=now[s][x].val==now[s][x-1].val;
			j=p-1;
		}
		if(cnt_bits[s]>=K)
		{
			long long res=0;
			for(int j=1;j<=N;++j)
			{
				int p=j+1;
				while(p<=N&&now[s][p].mark)
					++p;
				res+=C2[p-j];
				j=p-1;
			}
			if((cnt_bits[s]^K)&1)
				ans-=res*C[cnt_bits[s]][K];
			else
				ans+=res*C[cnt_bits[s]][K];
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

【分析】仔细一想，没什么不对的地方啊。唯一不满的是，我的双关键字哈希可能会被卡！！出于好奇，我就把它挂链了。话说这个数据是什么心态。。。还有，我自己了一个哈希挂链的方法，就是类似于边表的形式（因为以前不怎么写哈希，求神犇轻喷）。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 100005
using namespace std;
int n,k,num,i,j,p,x[N][6],C[7][7],status,flag,pre,cnt,t;
typedef long long ll;ll ans,h,Time,del;
const ll hash=99997;const ll base=97;
struct arr{int num,s,next;}a[100005];
int end[hash],temp[7],f[100005][7],data[100005];
ll doit(int k)
{
  int j;
  for (int i=end[k];i;i=a[i].next)
  {
    j=0;
    if (a[i].num==t)
    for (j=1;j<=t;j++)
      if (temp[j]!=f[i][j]) break;
    if (j==t+1) return ++a[i].s;
  }
  if (!end[k]) data[++pre]=k;
  cnt++;a[cnt].num=t;a[cnt].s=0;a[cnt].next=end[k];end[k]=cnt;
  for (j=1;j<=t;j++) f[cnt][j]=temp[j];return 0;
}
inline int Read()
{
  int x=0;char ch=getchar();bool positive=1;
  for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') positive=0;
  for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';
  return positive?x:-x;
}
int main()
{
  scanf("%d%d",&n,&k);
  for (i=1;i<=n;i++)
    for (j=0;j<6;j++)
      x[i][j]=Read();
  C[0][0]=1;  
  for (i=1;i<=6;i++)  
  {  
    C[i][0]=1;  
    for (j=1;j<=i;j++) C[i][j]=C[i-1][j]+C[i-1][j-1];  
  }  
  for (status=0;status<64;status++)
  {
    flag=0;pre=0;
    for (j=0;j<6;j++)
      flag+=(status&(1<<j))?1:0;
    if (flag<k) continue;
    Time=0ll;
    for (i=1;i<=n;i++)
    {
      h=0ll;t=0;
      for (j=0;j<6;j++)
        if (status&(1<<j))
          h=(h*base+ll(x[i][j]))%hash,temp[++t]=x[i][j];
      Time+=doit(h);
    }
    cnt=0;for (i=1;i<=pre;i++) end[data[i]]=0;
    del=((flag-k)&1)?-1ll:1ll;
    ans+=(ll)(Time*del*C[flag][k]);
  }
  printf("%lld",ans);
  return 0;
}
```

---


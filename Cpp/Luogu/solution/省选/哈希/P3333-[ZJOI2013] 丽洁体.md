# [ZJOI2013] 丽洁体

## 题目描述

平时的练习和考试中，我们经常会碰上这样的题：命题人给出一个例句，要我们类比着写句子。这种往往被称为仿写的题，不单单出现在小学生的考试中，也有时会出现在中考中。许多同学都喜欢做这种题，因为较其它题显得有趣。仿写的句子往往具有“A\_\_B\_\_C”的形式，其中A，B，C是给定的由一个或多个单词组成的短句，空的部分需要学生填写。当然，考试的时候空在那里也是可以的。例如，“其实天不暗阴云终要散，其实 ，其实 ，其实路不远一切会如愿，艰难困苦的日子里我为你祈祷，请你保重每一天”。再比如，“见了大海的汹涌，没见过大山的巍峨，真是遗憾；见了大山的巍峨，没见过 ，还是遗憾。出发吧，永远出发。 ，人有不老的心情。”

由于现在是网络时代，我们不再只能仿写命题人命的题，我们可以仿写网上各种句子和段落。2011年3月26日，某人在博客上发布了的消息就惹来了很多人的仿写。


很难过吧。。。考得完爆了。。。

。。。。。。其实也没什么可以说的。。。都是蒟蒻的借口罢了。。。

。。。自己果然还只是半吊子水平呢。。。。

。。。祝大家都能进省队。。。其实只要不要有遗憾就好了呢。。。

虽然我很遗憾或许不能走下去了。。。。。

886

在网络上广泛流传的仿写，因为在某些地方有独到之处，大都被命名为“某某体”。打开人人，刷新微博，你也能发现这样和那样的体，比如，对不起体，**说明他爱你体等等。金先生注意到了这一现象，他敏锐地认为这是一个很有价值的研究课题，于是就其展开研究，打算发一篇paper。由于在网上发消息，人们有了更大的灵活度，人们有时因为表达的需要，还往原本固定的A, B, C中添加一些修饰的词语。这就给辨别一个句子或段落是否是另一个句子或段落的仿写增加了困难。

金先生现在研究一种形如“A\*B\*C”的体作品，其中A, B, C分别是某个由若干单词组成的短句，\*代表0个或多个单词。他在网上找了大量的体作品，不过很多体作品不太合乎原作者的格式，也就是相当于在正规的体作品中插入了0个或多个单词。

由于数据量太大，金先生无法一个一个看过去，于是想请你帮忙，去掉尽量少的单词，使它成为指定的体。


## 说明/提示

【样例说明】

在上述样例中，不规范的体作品为：“想要一直爱着某物的话，以妖怪之死来说太长了；想要实现一切梦想的话，以人类之生来说太短了”。

规范的体形如：“要\*太长了要\*太短了”。

修改后的规范的体为：“要一直爱着某物的话，以妖怪之死来说太长了；要实现一切梦想的话，以人类之生来说太短了”。


【数据规模与约定】

对于20%的数据，1≤|T|, |A|, |B|, |C|≤10。 
对于40%的数据，1≤|T|, |A|, |B|, |C|≤100。 
对于70%的数据，1≤|T|, |A|, |B|, |C|≤1000。 
对于100%的数据，1≤|T|, |A|, |B|, |C|≤50000；所有单词长度不超过5，出现次数不超过500；数据保证答案总存在。


## 样例 #1

### 输入

```
xiang yao yi zhi ai zhe mou wu de hua yi yao guai zhi si lai shuo tai chang le xiang yao shi xian yi qie meng xiang de hua yi ren lei zhi sheng lai shuo tai duan le
yao
tai chang le yao
tai duan le```

### 输出

```
2```

# 题解

## 作者：a___ (赞：13)

题意：给定字符串序列 $\mathtt{T,A,B,C}$ ，求在 $\mathtt T$ 中最少删几个字符串可以得到序列 $\mathtt{A...B...C}$ 。保证有解。   

首先，由于要得到的串开头和结尾要是 $\mathtt A$ 和 $\mathtt C$，显然在原序列上从前往后匹配第一个包含 $\mathtt A$ 的子序列作为新串开头；以原序列上从后往前匹配第一个包含 $\mathtt C$ 的子序列作为新串结尾一定最优。   

于是现在我们将问题变成了如何在开头和结尾之间这一段找一个跨度最小的包含 $\mathtt B$ 的子序列。   

按照常规思路我们应该考虑 $\mathbf O(n^2)$ dp，设 $f_{i,j}$ 表示匹配到原序列第 $i$ 个串，匹配了 $\mathtt B$ 中的 $j$ 个串的最小长度，$f_{i,j}=1+\begin{cases}\min\{f_{i-1,j},f_{i-1,j-1}\}&T_i=B_j\\f_{i-1,j}&T_i\not=B_j\end{cases}$。   

然后我们就发现 $n\leq50000$ 直接凉凉。  

仔细观察一下数据范围，发现有一句“所有单词长度不超过 $5$，出现次数不超过 $500$”。由于每个单词出现次数不超过 $500$，所以 $\mathtt B$ 的开头最多在原串里出现 $500$ 次，所以我们可以暴力枚举这个串从哪儿开头，复杂度仅有 $500\cdot|\mathtt T|$，能过。   

有由于“单词长度不超过 $5$”，所以我们可以暴力匹配两个串是否相等，不用哈希。（直接用 `string` 暴力匹配）   

于是这题就彻底沦为了普及组的序列暴力匹配练习题。。。   

```cpp
#include<cstdio>
#include<string>
const int N=50010;
int n,a,b,c,ans,mn;
std::string sn[N],sa[N],sb[N],sc[N];
void read(int &n,std::string sn[])
{
	char ch;
	do ch=getchar();while(ch<=32);
	for(n=1;;n++)
	{
		do sn[n]+=ch,ch=getchar(); while(ch>32);
		while(ch<=32){if(ch=='\n'||ch==EOF)break;ch=getchar();}
		if(ch=='\n'||ch==EOF)break;//读到换行符就停止
	}
}
int main()
{
	int i,j;
	read(n,sn);read(a,sa);read(b,sb);read(c,sc);//读入
	for(i=j=1;j<=a;i++)
	if(sn[i]==sa[j])++j;//暴力匹配
	ans+=i-1-a;int l=i;
	for(i=n,j=c;j>=1;i--)
	if(sn[i]==sc[j])--j;//暴力匹配
	ans+=n-i-c;int r=i;
	for(;l<=r;l++)
	if(sn[l]==sb[1])
	{
		for(i=l,j=1;j<=b;i++)
		if(sn[i]==sb[j])++j;//暴力匹配
		if(i-1<=r&&mn>i-l-b)mn=i-l-b;
	}
	ans+=mn;
	printf("%d\n",ans);//完
	return 0;
}
```

ps:各位不要再尝试抄题解了，也建议管理员查一下这题大部分AC代码都一模一样的现象。    

---

## 作者：灵乌路空 (赞：8)

>想要一直爱着某物的话，以妖怪之生来说太长了；  
>想要实现一切梦想的话，以人类之生来说太短了。  

写这题的动机只是这两句话= =  

## 简述

原题面：[Luogu](https://www.luogu.com.cn/problem/P3333)

>给定字符串 $T,A,B,C$，每个字符串都由一些由空格分隔的单词构成。  
>求至少需要在 $T$ 中删除多少单词，使得 $T$ 呈现 $A\cdots B\cdots C$ 的形式。  
>保证有解。  
>$1\le |T|,|A|,|B|,|C|\le 5\times 10^4$，所有单词长度 $\le 5$，每种单词出现次数 $\le 500$。  
>1S，512MB。  

## 分析

先把所有字符串中的所有单词 Hash 一下。  

显然，对于最后保留串中的 $A$ 和 $C$，在 $T$ 中距离越远越好，贪心从 $T$ 两侧找即可，时间复杂度 $O(|T|)$。  
再从找到的 $AC$ 中间找 $B$，每种单词出现次数 $\le 500$，暴力枚举 $B$ 的第一个位置，再贪心的找即可，时间复杂度上界 $O(500|T|)$。  

总时间复杂度上界是 $O(500|T|)$，可过。

## 实现

```cpp
//知识点：哈希，暴力，贪心 
/*
By:Luckyblock
*/
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstring>
#define LL long long
const int kN = 3e5 + 10;
//=============================================================
char t[kN], a[kN], b[kN], c[kN];
int ans, lt, la, lb, lc;
int hast[kN], hasa[kN], hasb[kN], hasc[kN];
//=============================================================
inline int read() {
  int f = 1, w = 0;
  char ch = getchar();
  for (; !isdigit(ch); ch = getchar())
    if (ch == '-') f = -1;
  for (; isdigit(ch); ch = getchar()) {
    w = (w << 3) + (w << 1) + (ch ^ '0');
  }
  return f * w;
}
void Chkmax(int &fir_, int sec_) {
  if (sec_ > fir_) fir_ = sec_;
}
void Chkmin(int &fir_, int sec_) {
  if (sec_ < fir_) fir_ = sec_;
}
void Has(char *s_, int *has_, int &l_) {
  int lth = strlen(s_);
  for (int i = 0; i < lth; ++ i) {
    if (s_[i] < 'a' || s_[i] > 'z') continue ;
    if (i == 0 || s_[i - 1] < 'a' || s_[i - 1] > 'z') has_[++ l_] = 0;
    has_[l_] = 27 * has_[l_] + s_[i] - 'a' + 1;
  }
}
void Prepare() {
  gets(t), gets(a), gets(b), gets(c);
  Has(t, hast, lt); 
  Has(a, hasa, la);
  Has(b, hasb, lb); 
  Has(c, hasc, lc);
}
//=============================================================
int main() {
  Prepare();
  int l = 0, r = 0, lth;
  for (l = 1, lth = 1; l <= lt; ++ l) {
    if (hast[l] == hasa[lth]) {
      if (lth == la) {
        ++ l;
        break;
      }
      ++ lth;
      continue;
    }
    ++ ans;
  }
  
  for (r = lt, lth = lc; r >= 1; -- r) {
    if (hast[r] == hasc[lth]) {
      if (lth == 1) {
        -- r;
        break;
      }
      -- lth;
      continue;
    }
    ++ ans;
  }
  
  int mincost = lt;
  for (int i = l; i <= r; ++ i) {
    if (hast[i] != hasb[1]) continue;
    int l = 0, cost = 0;
    for (int j = i; j <= r; ++ j) {
      if (hast[j] == hasb[l + 1]) {
        ++ l;
        if (l == lb) break;
        continue ;
      }
      ++ cost;
    }
    if (l == lb) Chkmin(mincost, cost);
  }
  printf("%d\n", ans + mincost);
  return 0;
}
```

---

## 作者：硫代硫酸钠 (赞：4)

很难过吧...估计后天省选考得完爆了...

......其实也没什么可以说的...都是蒟蒻的借口罢了...

...自己果然还只是菜鸡水平呢...

...祝大家都能进省队...其实只要不要有遗憾就好了呢...

虽然我很遗憾或许不能走下去了......


这就是2011年ZJOI的WJMZBMR神犇的故事,第一天差点跌出省队线,烦恼中他写下了上述话,~~结果Day2AK了~~

STO OTZ

======================正文==============

预备知识:

1.将一个字符串视为一个26进制的整数,则可以快速比较两个字符串是否相同,这个方法被称为 Hash(哈希).

"所有单词长度不超过5".

这个条件下的哈希甚至可以不写模数

(极限条件zzzzz也不过1000万).

对于本题,我们可以先将原串,A,B,C哈希处理.

通过维护一个双指针,我们可以维护满足A,C的条件,注意用哈希判断单词是否相等.

那么如何维护满足B的条件呢?考虑动态规划.

令 $hav[i]$表示第i个单词最后出现的位置, $del[i]$表示考虑到第i位,删除的单词数.

转移时分类讨论.

1.如果x是第一个单词,

$hav[x]=i$

$del[i]=0$

2.如果x不是第一个单词,

$hav[x]=i$

$del[i]=(i-hav[i-1]+1)+del[i-1]$

最后$del[lb]$即为答案.

后记:

1.时间复杂度

算起来应该是$O(|T|\cdot n)$,

但是本蒟蒻实现的太差结果很多个点差点T过去.

2.O2优化

开O2以后速度快了好多,想想也是,那个vector占了很多时间.



3."14900000"??

这个指的是最大的单词,也就是上文的"一千多万"

蒟蒻的代码

```cpp
#include<bits/stdc++.h>
#define Size 500010
#define gc getchar()
#define rep(i,s,n) for (register int i=s;i<=n;++i)
#define drep(i,n,s) for (register int i=n;i>=s;--i)

using namespace std;

int a[Size],b[Size],c[Size],H[Size];
int hav[Size],del[Size],n,la,lb,lc,de1,de2=1e8;
vector<int> word[14900000];

void Hash(int &len,int h[])
{
	int x=0; char c=gc;
	for (;c!='\n';c=gc) 
		if(c>='a'&&c<='z') x=(x*27+c-'a'+1); 
			else if (x) h[++len]=x,x=0;
	if (x) h[++len]=x;
}

int main()
{
	Hash(n,H); Hash(la,a); Hash(lb,b); Hash(lc,c);
	int l=0,r=n+1;
	rep(i,1,la) 
	{
		l++; while (a[i]^H[l]) ++l,++de1;
	}
	drep(i,lc,1)
	{
		r--; while (c[i]^H[r]) --r,++de1;
	}
	++l,--r;
	rep(i,1,lb) word[b[i]].push_back(i); rep(i,0,lb) del[i]=de2;
	rep(i,l,r)
	{
		int t=word[H[i]].size(),now;
		drep(j,t-1,0)
		{
			now=word[H[i]][j];
			if (!now) continue;
			if (now==1) hav[now]=i,del[now]=0; 
			else if (hav[now-1]) hav[now]=i,del[now]=del[now-1]+i-hav[now-1]-1;
			de2=min(de2,del[lb]);
		}
	}
	printf("%d",de1+de2); return 0;
}
```

---

## 作者：Justin0779 (赞：1)

~~纪念校内模拟赛场切紫（虽然是水紫）~~

# Solution

我们先考虑一些必要的操作。由于我们并不好操作单词的匹配，所以想到把单词映射处理，这里哈希完全可以用 map 来代替。处理时只需要把每个单词加进 map 里即可。

现在我们把问题转化为了：

> 给定某四个个正整数序列 $T$、$A$、$B$、$C$，删除 $T$ 中的一些数，使 $T$ 变为 $A^{*}B^{*}C$ 的形式，也就是 $A$、$B$、$C$ 与某些字符串 $S$ 按顺序拼接而成的 $T^{'}$，求删除的最小次数，保证答案一定存在。

这样，我们把问题转化成了三个子问题：

1. 将 $T$ 的左边变成 $A$ 的最小操作次数。
2. 将 $T$ 的右边变成 $C$ 的最小操作次数。
3. 将 1、2 操作完后的 $T^{'}$ 中间删出一个 $B$ 的最小操作次数。

对于 1、2，我们很容易得到**能删尽量删，能匹配尽量匹配为最优**的结论，因为 $A$ 或 $C$ 的某一个字符出现在前面或者后面的影响是一样的，都是得确保 $T^{'}$ 的最左和最右一定是 $A$ 和 $C$。

但是对于 3，我们的策略便失效了。因为很可能利用现在的左端点 $l$ 不如接下来的某个左端点 $l^{'}$ 优。一个很好的例子是这样：

```
I can love you as love myself forever
I
love myself
forever
```

这样答案是 $0$，但是**能删尽量删，能匹配尽量匹配**得到的答案是 $3$。

所以我们考虑更换策略。

值得注意的是，当存在端点 $l < r$ 使得 $B \subset T_{l\sim r}$，那么答案可以用 $r - l + 1 - |B|$ 来更新，而无需考虑具体的删除情况，所以我们将问题 2 转化为寻求最优的左、右端点 $l$、$r$。

一个很好的想法是双指针，这样复杂度能做到绝妙的 $O(n)$。但是很遗憾，我们不能很好的、简单的去维护 $T_{l\sim r}$ 中 $B$ 的出现情况。所以，我们退而求其次，转而只枚举左端点 $l$ 并每次扫描最近的、合法的 $r$。这样我们的理论复杂度变为了 $O(n^2)$，这里 $n$ 为单词数。

看到数据范围 $|T| \le 50000$，我们很慌啊！但是我们看下很重要的**每个单词出现的次数不超过 $500$**。也就是合法的左端点不超过 $500$ 个，所以实际的复杂度应为 $O(n)$，常数只有很小的 $500$，可以通过本题。

于是我们就这样通过了本题。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 1e5 + 514;

namespace Otakus
{
    string T, A, B, C, str;
    unordered_map<string, int> dict;

    int a[N], b[N], c[N], t[N], cnt;
    int atp, btp, ctp, ttp;
    int vis[N], minn, Justin = N;
    vector<int> nxt[N];

    void solve()
    {
        int len, ans = 0, i = 1, j = ttp; // and i is the left, j is the right

        // for A
        len = 0;
        while (len < atp)
        {
            if (t[i] == a[len + 1])
                len++;
            else
                ans++;
            i++;
        }

        // for C
        len = ctp;
        while (len)
        {
            if (t[j] == c[len])
                len--;
            else
                ans++;
            j--;
        }

        // now, i ~ j to find B

        for (int l = i, r = i; (l <= j - btp + 1 && r <= j); l++) {
            if (t[l] != b[1])
                continue;
            len = 0, r = l;
            while (len < btp && r <= j)
            {
                if (t[r] == b[len + 1])
                    len++;
                r++;
            }
            if (len == btp)
                Justin = min(Justin, r - l - btp);
            else
                break;
        }

        cout << ans + Justin;
    }

    void init()
    {
        getline(cin, T);
        getline(cin, A);
        getline(cin, B);
        getline(cin, C);

        str = "";
        for (int i = 0; i < T.length(); i++)
        {
            if (T[i] == ' ') {
                if (!dict.count(str))
                    dict[str] = ++cnt;
                t[++ttp] = dict[str];
                str = "";
            }
            else if (T[i] - 'a' >= 0 && T[i] - 'a' < 26)
                str += T[i];
        }
        if (!dict.count(str))
            dict[str] = ++cnt;
        t[++ttp] = dict[str];

        str = "";
        for (int i = 0; i < A.length(); i++)
        {
            if (A[i] == ' ')
                a[++atp] = dict[str], str = "";
            else if (A[i] - 'a' >= 0 && A[i] - 'a' < 26)
                str += A[i];
        }
        a[++atp] = dict[str];

        str = "";
        for (int i = 0; i < B.length(); i++)
        {
            if (B[i] == ' ')
                b[++btp] = dict[str], str = "";
            else if (B[i] - 'a' >= 0 && B[i] - 'a' < 26)
                str += B[i];
        }
        b[++btp] = dict[str];

        str = "";
        for (int i = 0; i < C.length(); i++)
        {
            if (C[i] == ' ')
                c[++ctp] = dict[str], str = "";
            else if (C[i] - 'a' >= 0 && C[i] - 'a' < 26)
                str += C[i];
        }
        c[++ctp] = dict[str];

        solve();
    }
} // namespace Otakus

int main()
{

    // freopen("main.in", "r", stdin);
    // freopen("main.out", "w", stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    Otakus::init();
    return 0;
}
```

最后，我认为降绿，理由如下：

1.此题的难度仅在于 STL 的运用以及字符串的读入。

2.数据不够强。如果真的卡到适当的、只允许双指针的精妙做法过那么紫就无可置疑。

---

## 作者：creation_hy (赞：0)

~~再不写要掉橙啦，水一篇题解~~

首先对于 $A/C$ 来讲显然应该对应的是第一个/最后一个，因为如果多个开头一个结尾的话，结尾已经固定了，要减的单词数也是固定的。

然后对于 $B$ 来讲直接暴力，由于题目限制，最多只有 $500$ 个开头，那对于每个开头爆搜一串最优的子序列就行了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 5;
const int base = 131;
const int mod = 1e8 + 7;
inline void getln(string &s)
{
    string tmp;
    do
    {
        cin >> tmp, s += tmp + ' ';
    } while (getchar() == ' ');
    s.pop_back();
}
struct Hash
{
    string s;
    int sz, tot;
    ll hs[N];
    inline void init()
    {
        getln(s), sz = s.size(), s = ' ' + s, tot = 1;
        for (int i = 1; i <= sz; i++)
            if (s[i] == ' ')
                tot++;
            else
                hs[tot] = (hs[tot] * base + s[i] - 'a') % mod;
    }
} t, a, b, c;
int main()
{
    t.init(), a.init(), b.init(), c.init();
    int l, r, p, tp;
    for (l = tp = 1; tp <= a.tot; l++)
        if (t.hs[l] == a.hs[tp])
            tp++;
    int ans = l - a.tot - 1;
    for (r = t.tot, tp = c.tot; tp; r--)
        if (t.hs[r] == c.hs[tp])
            tp--;
    ans += t.tot - r - c.tot;
    int mi = 1e9;
    for (int i = l; i <= r; i++)
        if (t.hs[i] == b.hs[1])
        {
            bool flag = 1;
            for (p = i, tp = 1; tp <= b.tot; p++)
            {
                if (t.hs[p] == b.hs[tp])
                    tp++;
                if (p == r && tp <= b.tot)
                {
                    flag = 0;
                    break;
                }
            }
            if (flag)
                mi = min(mi, p - i - b.tot);
        }
    cout << ans + mi << '\n';
    return 0;
}
```

---

## 作者：ttq012 (赞：0)

首先 $A$ 和 $C$ 两个部分很显然，直接贪心，暴力从两边找就可以了。

之后考虑找 $B$。

发现每一个单词出现的次数都不超过 $500$。所以直接在 $A$ 和 $C$ 之间暴力枚举 $B$ 的首字母坐标，判断一下是不是正确的，然后直接暴力判断剩下的位置匹配就可以了。

感觉这个题没有紫？~~好像有紫了，原因是读入~~

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 300010;
using ull = unsigned long long;
struct HashTable
{
    ull h[N];
    int cnt;
    const ull base = 13331;
    void GetHash(string s[N], int tot)
    {
        cnt = tot;
        for (int i = 1; i <= tot; i++)
        {
            ull th = 1;
            for (int j = 0; j < s[i].size(); j++)
                th = th * base + s[i][j];
            h[i] = th;
        }
    }
} s, a, b, c;
string t[N];
void ghash(string &s, HashTable &ht)
{
    int tot = 1, cnt = 0;
    for (auto &j : s)
    {
        if (!isalpha(j))
        {
            if (cnt)
                tot++, cnt = 0;
        }
        else
        {
            t[tot] += j;
            cnt++;
        }
    }
    ht.GetHash(t, tot);
    for (int i = 1; i <= tot; i++)
        t[i] = "";
}
string S[N], A[N], B[N], C[N];
void read(string s[N], int &l)
{
    do
        cin >> s[++l];
    while (getchar() == ' ');
}
signed main()
{
    string ss, aa, bb, cc;
    int ls = 0, la = 0, lb = 0, lc = 0;
    read(S, ls);
    read(A, la);
    read(B, lb);
    read(C, lc);
    // ghash(ss, s);
    // ghash(aa, a);
    // ghash(bb, b);
    // ghash(cc, c);
    a.GetHash(A, la);
    b.GetHash(B, lb);
    c.GetHash(C, lc);
    s.GetHash(S, ls);
    int l = s.cnt, l1 = a.cnt, l2 = b.cnt, l3 = c.cnt;
    int cnt = 0;
    int p1 = 1, p2 = 1;
    while (p1 <= l && p2 <= l1)
    {
        if (s.h[p1] == a.h[p2])
            p1++, p2++;
        else
            p1++, cnt++;
    }
    int L = p1;
    p1 = l, p2 = l3;
    while (p1 && p2)
    {
        if (s.h[p1] == c.h[p2])
            p1--, p2--;
        else
            p1--, cnt++;
    }
    int R = p1;
    int min_value = 1e18;
    for (int i = L; i <= R; i++)
        if (s.h[i] == b.h[1])
        {
            int in_cnt = 0;
            p1 = i + 1, p2 = 2;
            while (p1 <= R && p2 <= l2)
            {
                if (s.h[p1] == b.h[p2])
                    p1++, p2++;
                else
                    p1++, in_cnt++;
            }
            if (p2 > l2)
                min_value = min(min_value, in_cnt);
        }
    cout << cnt + min_value << '\n';
    return 0;
}

```

---


# [POI 2015] POD

## 题目描述

长度为 $n$ 的一串项链，每颗珠子是 $k$ 种颜色之一。第 $i$ 颗与第 $i-1,i+1$ 颗珠子相邻，第 $n$ 颗与第 $1$ 颗也相邻。

切两刀，把项链断成两条链。要求每种颜色的珠子只能出现在其中一条链中。

求方案数量（保证至少存在一种），以及切成的两段长度之差绝对值的最小值。

## 说明/提示

**【样例解释】**

四种方法中较短的一条分别是 $(5),(4),(1,1),(4,1,1)$。相差最小值 $6-3=3$。 

----

原题名称：Podział naszyjnika。 

## 样例 #1

### 输入

```
9 5
2 5 3 2 2 4 1 1 3```

### 输出

```
4 3```

# 题解

## 作者：浅色调 (赞：23)

### Solution：

　　本题思维题，ZYYS。

　　还记得前面HRZ学长讲的一道判断相似字符串的题目（那题做法是处理出26个字母分别为关键字的01hash值，排序后判断相等），本题做法类似，先将原数列的断点按每种颜色的出现次数求环形前缀和，因为是环形，所以最后一个该颜色的后面的断点前缀和为0，我们以样例为例：

　　![](http://img2018.cnblogs.com/blog/1240891/201809/1240891-20180904131426927-757097226.jpg)
~~留图带画~~（手绘勿喷）。

　　不难发现能切两刀的位置所对应的$k$元组一定相等，证明很简单：若这两个位置对应的$k$元组相等，那么同一颜色的环形前缀和是相等的，这就说明在这两位置切出的两段中有一段一定不包含该颜色，于是另一段一定包含所有的该颜色咯。

　　那么我们将每个位置的$k$元组处理出来，由于$k\leq 10^6$又要比较相等，所以还得hash。

　　于是第一问就迎刃而解了，只需要对hash值排序，然后组合计数。

　　第二问要求分出的两段的差的最小值，设断点为$l,r$，那么差值$=|n-2*(r-l)|$（注意$(r-l)$不用+1，因为l、r为断点标号，之间有r-l个颜色），显然要使的差值最小，就得使$r-l$尽可能接近$n/2$，满足单调性，于是直接单调队列，实现时在第一问的过程中对于hash值相等的一段处理并更新答案就好了。

　　（坑点：卡单hash，所以得双hash，然后$k$很大，所以基数也得选大，分别选两组孪生素数就OK啦！>.^_^.<）

$\quad\;\;$**欢迎来踩博客**：[five20](https://www.cnblogs.com/five20/p/9581552.html)（蒟蒻写题解不易，转载请注明出处，万分感谢～！）

### 代码：
```cpp
    /*Code by 520 -- 9.3*/
    #include<bits/stdc++.h>
    #define il inline
    #define ll long long
    #define RE register
    #define For(i,a,b) for(RE int (i)=(a);(i)<=(b);(i)++)
    #define Bor(i,a,b) for(RE int (i)=(b);(i)>=(a);(i)--)
    using namespace std;
    const int N=1000005,P1=200019,P2=200011,mod1=1e9+7,mod2=1e9+9;
    ll s1[N],s2[N],h1[N],h2[N];
    int n,k,a[N],b[N],c[N];
    struct node{
        int id;
        ll sum1,sum2;
        bool operator <(const node &a)const {
            if(sum1!=a.sum1)return sum1<a.sum1;
            if(sum2!=a.sum2)return sum2<a.sum2;
            return id<a.id;    
        }
    }t[N];
    int gi(){
        int a=0;char x=getchar();
        while(x<'0'||x>'9')x=getchar();
        while(x>='0'&&x<='9')a=(a<<3)+(a<<1)+(x^48),x=getchar();
        return a;
    }
    int main(){
        n=gi(),k=gi();
        For(i,1,n) a[i]=gi();
        s1[0]=s2[0]=1;
        For(i,1,k) s1[i]=s1[i-1]*P1%mod1,s2[i]=s2[i-1]*P2%mod2;
        Bor(i,1,n) if(!b[a[i]]) b[a[i]]=i;
        ll sum1=0,sum2=0;
        For(i,1,n) {
            c[a[i]]++;
            sum1=(sum1+s1[a[i]])%mod1,sum2=(sum2+s2[a[i]])%mod2;
            if(b[a[i]]==i) 
                sum1=(sum1-s1[a[i]]*c[a[i]]%mod1+mod1)%mod1,
                sum2=(sum2-s2[a[i]]*c[a[i]]%mod2+mod2)%mod2;
            t[i]=node{i,sum1,sum2};
        }
        sort(t+1,t+n+1);
        int mid=n+1>>1,ans=n;
        ll cnt=0;
        for(RE int i=1;i<=n;){
            RE int nxt=i;
            while(nxt<=n&&t[nxt].sum1==t[i].sum1&&t[nxt].sum2==t[i].sum2) nxt++;
            cnt+=1ll*(nxt-i)*(nxt-i-1)/2;
            for(int l=i,r=i;r<nxt;r++){
                while(l<r&&t[r].id-t[l].id>=mid)l++;
                int tp1=abs(n-2*(t[r].id-t[l].id));
                if(l>i){
                    int tp2=abs(n-2*(t[r].id-t[l-1].id));
                    if(tp2<tp1)tp1=tp2;
                }
                if(tp1<ans)ans=tp1;
            }
            i=nxt;
        }
        printf("%lld %d\n",cnt,ans);
        return 0;    
    }
```

---

## 作者：Nekora_Nyaru (赞：18)

[P3587](https://www.luogu.com.cn/problem/P3587)

容易发现，拉珠环是个烟雾弹，如果切两刀断成两段，一定有一段是原序列上的一段区间，所以你当一条拉珠上找合法区间就行了。

什么是合法区间呢？颜色为 $col$ 的点要么全在这里面要么全不在这里面。

我们考虑怎么做这个，你首先枚举一个右端点 $rt$，然后看哪些左端点满足条件。

对于一种颜色 $i$，假设他的最左在 $st_i$，最右在 $ed_i$，那么有两种情况：

1. $ed_i>rt$，那么第 $i$ 种颜色不要碰，因为不管怎么选左端点区间都没办法包含所有这种颜色，这个可以用栈维护距离 $rt$ 最近的编号，设为 $lt$，那么 $[lt+1,rt]$ 是本限制下备选区间。
2. $ed_i\leqslant rt$，那么对于第 $i$ 种颜色，左端点不可以放在 $[st_i+1,ed_i]$ 的位置，原因显然，如果这样的话就一定包住了最后一个没包住第一个，然后就不合法了，你考虑开一棵区间赋值区间求和的线段树，每次遇到这种情况就区间打个不能走的标记。

然后这两个限制加起来，我们就能求出第一问的答案，那就是在区间 $[lt+1,rt]$ 中找到线段树中没有标记的点的数量。

第二问怎么求？首先把最优的左节点找出来，直接把长度拉到 $\frac{n}{2}$ 就可以了，然后考虑线段树二分出离那个点最近的可用点，把那个记入答案即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k;
int a[1000005];
int st[1000005];
int ed[1000005];
bool vis[1000005];
stack<int> stk;
bool tag[1000005];
class SegTree{
    public:
    int Tree[1000005<<2];
    int Tag[1000005<<2];
    void pushup(int cur){
        Tree[cur]=Tree[cur<<1]+Tree[cur<<1|1];
        return;
    }
    void addtag(int cur,int lt,int rt,int val){
        Tree[cur]=(rt-lt+1)*val;
        Tag[cur]=val;
        return;
    }
    void pushdown(int cur,int lt,int rt){
        if(!Tag[cur])return;
        int mid=lt+rt>>1;
        addtag(cur<<1,lt,mid,Tag[cur]);
        addtag(cur<<1|1,mid+1,rt,Tag[cur]);
        Tag[cur]=0;
        return;
    }
    void update(int cur,int lt,int rt,int qx,int qy,int val){
        if(lt>qy||rt<qx){
            return;
        }
        if(lt>=qx&&rt<=qy){
            addtag(cur,lt,rt,val);
            return;
        }
        pushdown(cur,lt,rt);
        int mid=lt+rt>>1;
        update(cur<<1,lt,mid,qx,qy,val);
        update(cur<<1|1,mid+1,rt,qx,qy,val);
        pushup(cur);
        return;
    }
    int query(int cur,int lt,int rt,int qx,int qy){
        if(lt>qy||rt<qx)return 0;
        if(lt>=qx&&rt<=qy)return Tree[cur];
        pushdown(cur,lt,rt);
        int mid=lt+rt>>1;
        return query(cur<<1,lt,mid,qx,qy)+query(cur<<1|1,mid+1,rt,qx,qy);
    }
    int find(int cur,int lt,int rt,int qx,int qy,int need){
        if(Tree[cur]==(rt-lt+1))return -1;
        if(lt==rt)return lt;
        pushdown(cur,lt,rt);
        int mid=lt+rt>>1;
        if(mid>=qy)return find(cur<<1,lt,mid,qx,qy,need);
        if(mid<qx)return find(cur<<1|1,mid+1,rt,qx,qy,need);
        if(mid+1<=need){
            int tmp=find(cur<<1|1,mid+1,rt,qx,qy,need);
            if(tmp!=-1)return tmp;
            return find(cur<<1,lt,mid,qx,qy,need);
        }
        else{
            int tmp=find(cur<<1,lt,mid,qx,qy,need);
            if(tmp!=-1)return tmp;
            return find(cur<<1|1,mid+1,rt,qx,qy,need);
        }
    }
}P;
signed main(){
    scanf("%lld%lld",&n,&k);
    for(int i=1;i<=n;i++){
        scanf("%lld",&a[i]);
    }
    for(int i=1;i<=n;i++)ed[a[i]]=i;
    for(int i=n;i>=1;i--)st[a[i]]=i;
    int cnt=0,ans=2e9;
    stk.push(0);
    for(int i=1;i<n;i++){
        stk.push(i);
        int col=a[i];
        if(i==ed[col]){
            vis[col]=true;
            if(st[col]<ed[col])P.update(1,1,n,st[col]+1,ed[col],1);
        }
        while(vis[a[stk.top()]])stk.pop();
        int lt=stk.top()+1;
        if(lt>i)continue;
        int tmp=P.query(1,1,n,lt,i);
        cnt+=(i-lt+1)-(tmp);
        int need=max(i-(n/2),1ll);//
        int S=P.find(1,1,n,lt,i,need);
        if(S==-1)continue;
        ans=min(ans,abs((i-S+1)-(n-(i-S+1))));
    }
    printf("%lld %lld",cnt,ans);
    return 0;
}
```

---

## 作者：xtx1092515503 (赞：14)

线性做法。

类似于 `ABAB` 这样的串如果出现，则显然合法的切割方案中 `AB` 两种颜色必然在同侧，进而其可被看作相同颜色加以合并。

全部合并之后，我们考虑一种颜色 `A`，其在环上的出现形如 `...A...A...A...A...`，则其余所有颜色都仅会在相邻两个 `A` 间出现。

考虑截取一段。则被截出的部分定存在于某段 `A...A` 间。也即，我们考虑枚举截出部分归属的段，即可讨论所有情形。

考虑某段内的情形。其是形如 `AB..B..BC..C..CD..D..DA` 的情形，其中 `B..B..B` 段与其它段一样，都是此种颜色出现的所有位置。

考虑继续讨论。对于颜色 `B`，截取要么发生在某段 `B...B` 中，要么发生在两端的 `B` 以外。对于前者，我们可以递归入子区间讨论，且这部分复杂度即为线性。对于后者，显然我们只需考虑所有极大 `(B...B)(C...C)(D...D)...` 等段。

用双针之类即可处理出极优答案。方案数亦可简单求出。复杂度可以做到线性。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,m,a[1001000],nex[1001000],las[1001000],buc[1001000],mn,dsu[1001000],stk[1001000],tp,A,B;
ll res;
int val(int x){return max(x,n-x)-min(x,n-x);}
void solve(int x){
//	printf("%d\n",x);
	for(int i=(x+1)%n;i!=nex[x];){
//		printf("%d:%d\n",x,i);
		for(int j=i;nex[j]!=i;j=nex[j])solve(j);
		i=(las[i]+1)%n;
	}
	int num=0;
	for(int i=(x+1)%n,j=(x+1)%n;i!=nex[x];i=(las[i]+1)%n){
		num++;
		while((las[i]+1+n-j)%n>(n>>1))j=(las[j]+1)%n;
		mn=min(mn,val((las[i]+1+n-j)%n));
		mn=min(mn,val((las[i]+1+n-nex[(j+n-1)%n])%n));
	}
	res+=1ll*num*(num+1)>>1;
}
int find(int x){return dsu[x]==x?x:dsu[x]=find(dsu[x]);}
void merge(int x,int y){x=find(x),y=find(y);if(x!=y)dsu[y]=x;}
void func(){
	memset(buc,-1,sizeof(buc)),memset(nex,-1,sizeof(nex));
	for(int i=0;i<n;i++){
		if(buc[a[i]]!=-1)nex[buc[a[i]]]=i;
		buc[a[i]]=i;
	}
	tp=0;for(int i=0;i<n;i++){
		if(nex[i]==-1)continue;
		while(tp&&nex[stk[tp]]<=i)tp--;
		while(tp&&nex[stk[tp]]<nex[i])merge(a[i],a[stk[tp--]]);
		stk[++tp]=i;
	}
	for(int i=0;i<n;i++)a[i]=find(a[i]);
}
int main(){
	scanf("%d%d",&n,&m),mn=n;
	for(int i=0;i<n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=m;i++)dsu[i]=i;
	func(),reverse(a,a+n),func();
	memset(buc,-1,sizeof(buc));
	for(int i=0;i<(n<<1);i++)nex[buc[a[i%n]]]=i%n,buc[a[i%n]]=i%n;
	for(int i=0;i<n;i++)las[nex[i]]=i;
//	for(int i=0;i<n;i++)printf("%d ",nex[i]);puts("");
	for(int i=0;;){solve(i),i=nex[i];if(i==0)break;}
	printf("%lld %d\n",res,mn);
	return 0;
}
```

---

## 作者：2018ljw (赞：12)

受 PKUSC D2T2 做法的启发，给大家带来一种完全不同的解法。

我们先**对每个珠子随机赋一个权值，满足所有相同颜色珠子异或和为** $0$。那么可以发现，当我们的权值域极大时，大概率地，每种颜色的珠子只能出现于一条链等价于每条链的异或和为 $0$。所以我们将异或赋值为 $[0,2^{63}-1]$ 中的随机权，然后断环为链，复制一遍，求异或前缀和。因为整个区间的异或和必定为 $0$，所以合法的切割一定满足位置 $x,y$ 使得 $1\le x-y < n$ 且 $sum_x=sum_y$。

右边不取等的充要原因是当 $x-y=n$ 时，根据求前缀和的方式可知此时得到的是整条链。

需要注意的是，由于复制一遍的存在，所以对于两刀 $x,y$，第一刀为 $x,y$ 的情况会分别统计一遍，所以求得的方案数需要减半。

第一问就解决了。求定长区间相同数的个数可以对异或和数组离散化后使用桶或队列存储对应数值的下标完成。

考虑第二问，求最小长度差。

发现对于第一刀确定的位置，第二刀切出最小长度差，一定是最后一个前一半不长于后一半，或者第一个前一半长于后一半的位置。所以我们对定长区间使用队列，**维护每种前缀和的取值中，最后一个前一半不长于后一半，及这个位置以后的位置**。然后每次移动时，取出的当前位置值所对应的队列的队首和队首的下一位，分别计算更新答案即可。

但正常的队列不支持找队首的下一位，所以我们直接使用桶模拟队列（或双端队列），具体而言就是对每个桶额外记录开头位置即可。

最后一个前一半长不大于后一半长的位置可以直接简单计算得出，它与序列尾的距离应不小于 $\lceil\frac n2\rceil$。

总复杂度 $O(n\log n)$，瓶颈在离散化，代码如下。

```cpp
#include<cstdio>
#include<cstdlib>
#include<vector>
#include<algorithm>
using namespace std;
int a[1000001],n,k;
long long val[2000001],lastpos[1000001],xorsum[1000001];
//lastpos 记录每种颜色最后出现的位置，xorsum 记录每种颜色的权值异或和。
//这样当遇到 lastpos 时，直接调用 xorsum 里对应的值即可。
long long sum[2000001],b[2000001];
// b单纯用来离散化的。
vector<int>g[1000001];
int minans,bgpos[1000001],pos[1000001];
//一桶两用，bgpos 负责维护第一问，pos 负责维护第二问。
long long ans;
int abs(int x){
	return x<0?-x:x;
}
int calc(int cut,int r){
	return abs((r-cut)-(cut-r+n));
}
int main(){
	srand(20060111);
	int i,j;
	scanf("%d%d",&n,&k);
	minans=n;
	int dis=(n+1)/2;
	for(i=1;i<=n;i++)scanf("%d",&a[i]),lastpos[a[i]]=i;
	for(i=1;i<=n;i++){
		if(lastpos[a[i]]!=i)val[i]=1ll*rand()*rand(),xorsum[a[i]]^=val[i];
		else val[i]=xorsum[a[i]];
	}
	for(i=n+1;i<=n+n;i++)val[i]=val[i-n];
	for(i=1;i<=n*2;i++)sum[i]=sum[i-1]^val[i],b[i]=sum[i];
	sort(b+1,b+n*2+1);
	int m=unique(b+1,b+n*2+1)-b-1;
	for(i=1;i<=n*2;i++)sum[i]=lower_bound(b+1,b+m+1,sum[i])-b;
	for(i=1;i<=n;i++)g[sum[i]].push_back(i);
	m=n*2; 
	for(i=n+1;i<=m;i++){
		int w=sum[i];
		while(bgpos[w]<g[w].size()){
			if(g[w][bgpos[w]]<=i-n)bgpos[w]++;
			else break;
		}
		pos[w]=max(pos[w],bgpos[w]);
		ans+=g[w].size()-bgpos[w];
		while(pos[w]<g[w].size()-1){
			if(g[w][pos[w]+1]<=i-dis)pos[w]++;
			else break;
		}
		minans=min(minans,calc(g[w][pos[w]],i));
		if(pos[w]<g[w].size()-1)minans=min(minans,calc(g[w][pos[w]+1],i));;
		//如果第二问的桶里还有第二个元素，那就是【第一个前>后】的位置。
		g[w].push_back(i);
	}
	printf("%lld %d",ans/2,minans);
}
```

---

## 作者：ecnerwaIa (赞：8)

## 我十分喜欢数据结构，于是我就用线段树+栈过了此题

[题目](https://www.luogu.org/problemnew/show/P3587)（关于题目意思我就不啰嗦了）

此题要求将一个环形序列分成两段。那么可以是$[1,L-1],[R+1,n]$和$[L,R](L>1,R<n)$或者是$[1,pos]$和$[pos+1,n]$这两种划分

![](https://cdn.luogu.com.cn/upload/pic/53405.png)

那么黄色的那块其实两种情况都是连续的，那么此题第一问就转化为了求所有合法区间的方案数。（合法区间是指不存在一个在$[L,R]$的颜色出现在$[1,L-1],[R+1,n]$中）（也许你会说 **"哇，为什么扯到这啊"** ，但是你看了下面就会明白了）

那么就是[P4065 [JXOI2017]颜色](https://www.luogu.org/problemnew/show/P4065) 这题了（[我的题解](https://www.luogu.org/blog/wjr5082/p4065-jxoi2017-yan-se)）

建议先看下那题，再看此题，会有种 **"哦，原来都是套路！"** 的感觉

为什么说这两题是一个套路呢？此题要求 **"每种颜色的珠子只能出现在其中一条链中"** 咦？我们看到颜色这题要求 **"每种颜色要么删去，要么不删"** ，不就是每种颜色只能都在删去颜色集合，或者是未被删去的颜色集合么?那不是一样的吗

再看此题要求 **"断成两条链"** ，而颜色此题要求 **"剩下的序列是连续的"** ？？剩下的序列是连续的，那么左右两边如果相连，那么删去的也是连续的喽，那不是又是一样的么？

但是假如你真的把代码照搬过来不考虑第二问你的第一问还是错的（但我试了下过了50pts）

为什么呢？因为此题有一点点不一样，假如划分成了$[L,R]$区间,那么和划分成$[1,L-1],[L+1,R]$是一样的,划分成$[1,pos]$和划分成$[pos+1,n]$又是一样的，分别对应上图两种情况

但是好在我们第一种是不会算重复的，我们在算的时候只是求 **区间** 合不合法，因为只要知道一条链的信息，就能知道另一条，而只有上图两种情况，总是能通过一个区间知道这样划分是否合法（只要一条链合法，另一条一定合法）

但是第二种呢？$[1,pos]$和$[pos+1,n]$是一样的啊，我们就会算两次，但是实际上此题只要求算一次...感觉上好像是没法处理，不好去重，实际上如果你~~足够聪明~~，你会发现**只要区间左端点永远不取到1**就行了（或者右端点永远不取到$n$也行），实际上刚好也满足了题目要求的不能不切条件！

因为右端点在$n$我们求出了左端点不在$1$的合法方案，那么取补集，也就是求出了左端点在$1$的所有右端点不为$n$的合法方案,这样子就不会重复了，因为只有$[1,pos]$可能和$[pos+1,n]$重复，结果被我们~~巧妙~~地分成了一种情况

关于第二问，其实很简单，如果我们知道了$[pos,R](\forall pos,1<=pos<=R)$的差值，要推出$[pos,R+1](\forall pos,1<=pos<=R+1)$

$n\&1==0 :$R-pos+1<(n>>1),R+1时差值就-2，$R-pos+1>=(n>>1),R+1$时差值+2

举个栗子,$n=8,pos=2,R=5$,那么$R-pos+1=4$,差值为$abs(4-4)，R=6$时，$R-pos+1=5$,差值为$abs(5-3)=2$就要$+2$或者是$abs(3-5)$变为$abs(4-4)$就要$-2$

而当$n&1==1$是也好办，$R-pos+1==(n>>1)$的不边，其余的都是一样的

所以不就是区间$+2,-2$么，只不过是取最小值的时候不能把合法区间的差值算进去罢了

下面上代码,不懂的可以看下代码

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define min_(a,b) (a<b?a:b)
#define max_(a,b) (a>b?a:b)
using namespace std;
inline void read(int &x){x=0;int f=1;char ch=getchar();while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}x=x*f;}
typedef long long LL;
const int N=1000010,M=N<<1,INF=1<<30;
int stc[N],sti[N],r;//stc,sti分别存的栈中的col颜色,id编号 
int a[N],fir[N],end[N],n,k;//fir,end分别是该颜色第一次,最后一次出现位置 
LL ans;//第一问答案 
int ss,p,ans_2,c,G;//因为一次更新两个答案,我就在全局定义了ss满足条件可以取的左端点数,p满足条件的最小差值
//c:n>>1,G=n&1,用来简化modify(更新区间差值)书写的 
struct Segment_tree{
    int l[M],r[M],minn[M],s[M],tag[M],rt,cnt;//tag:区间不能取标记。rev:第二问中的区间加减标记
    #define lc l[x]
    #define rc r[x]
    inline void pushup(int x){minn[x]=min_(minn[lc],minn[rc]);s[x]=s[lc]+s[rc];}//向上更新 
    inline void pushr(int x,int v){minn[x]+=v;tag[x]+=v;}
    inline void pushdown(int x){if(tag[x]){pushr(lc,tag[x]);pushr(rc,tag[x]);tag[x]=0;}}
  	inline void build(int &x,int L,int R){//初始化 
        x=++cnt;minn[x]=n;s[x]=R-L+1;
        if(L==R)return;
        int mid=(L+R)>>1;build(lc,L,mid);build(rc,mid+1,R);
    }inline void Insert(int &x,int L,int R,int ll,int rr){//如果不存在x,说明L到R已经是不能选的了 
    	if(!x)return;
        if(ll<=L&&R<=rr){x=0;return;}//将x标记为不能选,那么x的差值对答案不会有贡献,s[x]=0也不会有贡献,所以直接删掉就好 
        int mid=(L+R)>>1;
        if(ll<=mid)Insert(lc,L,mid,ll,rr);
        if(rr>mid)Insert(rc,mid+1,R,ll,rr);
        if(!lc&&!rc){x=0;return;}//小优化,左右儿子都没了,这个点自然没用了 
        pushup(x);
    }inline void upd(int x,int L,int R,int ll,int rr,int v){
        if(!x)return;//小优化
        if(ll<=L&&R<=rr){pushr(x,v);return;}
        int mid=(L+R)>>1;pushdown(x);
        if(ll<=mid)upd(lc,L,mid,ll,rr,v);
        if(rr>mid)upd(rc,mid+1,R,ll,rr,v);
        pushup(x);
    }inline void modify(int pos){//更新差值,此处在之前右端点是pos-1,现在右端点为pos,因为答案是绝对值,所以要分两种+2或者是-2 
        int L=max_(1,pos-c+1);upd(1,1,n,L,pos,-2);
        int R=L-G-1;
        if(R>=1)upd(1,1,n,1,R,2);//R<1了就不要执行了 
    }inline void query(int x,int L,int R,int ll,int rr){
        if(!x)return;//同上，小优化 
        if(ll<=L&&R<=rr){ss+=s[x];p=min_(p,minn[x]);return;}
        int mid=(L+R)>>1;pushdown(x);
        if(ll<=mid)query(lc,L,mid,ll,rr);
        if(rr>mid)query(rc,mid+1,R,ll,rr);
    }inline void get(int L,int R){ss=0;p=INF;query(rt,1,n,L,R);} //不解释 
}T;
int minn;
void slove(){
    read(n);read(k);for(int i=1;i<=n;++i){read(a[i]);fir[i]=0;}//初始化fir=0,懒得改了 
    for(int i=1;i<=n;++i){if(!fir[a[i]])fir[a[i]]=i;end[a[i]]=i;}
    T.minn[0]=INF;ans_2=n;T.build(T.rt,1,n);c=n>>1;G=n&1;//n的奇偶性是和我们的差值更新有关的,建议自己手推一下关系 
    int l;
    for(int i=1;i<=n;++i){
        if(!(i^end[a[i]])&&(end[a[i]]^fir[a[i]]))T.Insert(T.rt,1,n,fir[a[i]]+1,end[a[i]]); //这里写不下，写在下一行 
        else {stc[++r]=a[i];sti[r]=i;}//因为end<=i了,那么我们不能取[fir+1,end]的点,否则会把fir放到另一条链,是不合法的,所以打标记不能选 
        while(r&&end[stc[r]]<=i)r--;//end>i&&fir<=i那么会发现只能选[last+1,i](last:max(pos(end[pos]>i&&pos<=i))转下行 
        T.modify(i);//否则都会选到至少一个该颜色,而该颜色有至少一个在i右边,那么就不是合法的了 
        l=(r?sti[r]:0);if(!l)l++;//我们算的是[l+1,i]区间中合法的,不能算l+1==1的,!l的话l++就好了 
        if(i>l){T.get(l+1,i);ans+=ss;ans_2=min_(ans_2,p);}//l+1<=i才行,否则会出bug 
    }
    printf("%lld %d\n",ans,ans_2);
}
int main(){
    slove();
    return 0;
}

```

upd:本来以为这样就行了的，但是发现还可以优化，不用区间+2,-2了，直接取min,max就好了，<=n/2的最小的合法位置，>n/2的最大的合法位置

这是下面快了3倍的代码（不应该啊？应该速度最多快1倍的...）

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define min_(a,b) (a<b?a:b)
#define max_(a,b) (a>b?a:b)
using namespace std;
inline void read(int &x){x=0;int f=1;char ch=getchar();while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}x=x*f;}
typedef long long LL;
const int N=1000010,M=N<<1,INF=1<<30;
int stc[N],sti[N],r;//stc,sti分别存的栈中的col颜色,id编号 
int a[N],fir[N],end[N],n,k,p,tql;//fir,end分别是该颜色第一次,最后一次出现位置 
LL ans;//第一问答案 
int ss,ans_2;//因为一次更新两个答案,我就在全局定义了ss满足条件可以取的左端点数,p满足条件的最小差值
struct Segment_tree{
    int l[M],r[M],minn[M],maxn[M],s[M],rt,cnt;//tag:区间不能取标记。rev:第二问中的区间加减标记
    #define lc l[x]
    #define rc r[x]
    inline void pushup(int x){minn[x]=min_(minn[lc],minn[rc]);maxn[x]=max_(maxn[lc],maxn[rc]);s[x]=s[lc]+s[rc];}//向上更新 
    inline void build(int &x,int L,int R){//初始化 
        x=++cnt;s[x]=R-L+1;maxn[x]=R;minn[x]=L;
        if(L==R)return;
        int mid=(L+R)>>1;build(lc,L,mid);build(rc,mid+1,R);
    }inline void Insert(int &x,int L,int R,int ll,int rr){//如果不存在x,说明L到R已经是不能选的了 
        if(!x)return;
        if(ll<=L&&R<=rr){x=0;return;}//将x标记为不能选,那么x的差值对答案不会有贡献,s[x]=0也不会有贡献,所以直接删掉就好 
        int mid=(L+R)>>1;
        if(ll<=mid)Insert(lc,L,mid,ll,rr);
        if(rr>mid)Insert(rc,mid+1,R,ll,rr);
        if(!lc&&!rc){x=0;return;}//小优化,左右儿子都没了,这个点自然没用了 
        pushup(x);
    }inline void get_max(int x,int L,int R,int ll,int rr){
		if(!x)return;
		if(ll<=L&&R<=rr){p=max_(p,maxn[x]);return;}
		int mid=(L+R)>>1;
		if(ll<=mid)get_max(lc,L,mid,ll,rr);
		if(rr>mid)get_max(rc,mid+1,R,ll,rr);
	}inline void get_min(int x,int L,int R,int ll,int rr){
		if(!x)return;
		if(ll<=L&&R<=rr){p=min_(p,minn[x]);return;}
		int mid=(L+R)>>1;
		if(ll<=mid)get_min(lc,L,mid,ll,rr);
		if(rr>mid)get_min(rc,mid+1,R,ll,rr);
	}inline void query(int x,int L,int R,int ll,int rr){
		if(!x)return;
		if(ll<=L&&R<=rr){ss+=s[x];return;}
		int mid=(L+R)>>1;
		if(ll<=mid)query(lc,L,mid,ll,rr);
		if(rr>mid)query(rc,mid+1,R,ll,rr);
	}inline void work(int L,int R){
		int rr=max_(R-tql+1,L),ll=rr-1;
		ss=0;query(rt,1,n,L,R);ans+=ss;
		p=INF;get_min(rt,1,n,rr,R);if(p!=INF)ans_2=min_(ans_2,n-2*(R-p+1));
		if(ll>=L){p=-INF;get_max(rt,1,n,L,ll);if(p!=-INF)ans_2=min_(ans_2,2*(R-p+1)-n);}
	}
}T;
int minn;
void slove(){
    read(n);read(k);for(int i=1;i<=n;++i)read(a[i]);
    for(int i=1;i<=n;++i){if(!fir[a[i]])fir[a[i]]=i;end[a[i]]=i;}
    T.minn[0]=INF;ans_2=n;T.build(T.rt,1,n);
    int l;tql=n>>1;p=n;
    for(int i=1;i<=n;++i){
        if(!(i^end[a[i]])&&(end[a[i]]^fir[a[i]]))T.Insert(T.rt,1,n,fir[a[i]]+1,end[a[i]]); //这里写不下，写在下一行 
        else {stc[++r]=a[i];sti[r]=i;}//因为end<=i了,那么我们不能取[fir+1,end]的点,否则会把fir放到另一条链,是不合法的,所以打标记不能选 
        while(r&&end[stc[r]]<=i)r--;//end>i&&fir<=i那么会发现只能选[last+1,i](last:max(pos(end[pos]>i&&pos<=i))转下行 
        l=(r?sti[r]:0);if(!l)l++;//我们算的是[l+1,i]区间中合法的,不能算l+1==1的,!l的话l++就好了 
        if(i>l)T.work(l+1,i);
    }
    printf("%lld %d\n",ans,ans_2);
}
int main(){
    slove();
    return 0;
}
```



---

## 作者：MarSer020 (赞：4)

$\Large\text{Solution}$

考虑怎样判断一段内的数有没有在另一段内出现过。

这可以使用异或哈希解决：对每个位置 $i$ 上的数赋随机权值 $a_i$，微调后可以使得每一种颜色的所有权值异或起来为 $0$，那么一段区间 $\left[l,r\right]$ 内的颜色没有在另一段区间内出现过就等价于 $\oplus_{i=l}^{r}a_i=0$，容易发现**在 `long long` 范围内**取随机值时冲突概率很小，对权值数组求前缀和后将相同的位置放进同一个 `vector` 内，则 $ans=\sum \dfrac{s\times(s-1)}{2}$，其中 $s$ 为 `vector` 的大小。

再考虑第二问，我们在每个 `vector` 上跑一遍双指针即可。

时间复杂度 $\Theta(n)$。

**注意：请务必保证你的随机数是在 `long long` 范围内随机选取的，否则会得到 $70$ 分的好成绩。**

$\Large\text{Code}$

$\text{p.s.}$ 本题略卡空间。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,ansx=0x3f3f3f3f,tot,siz;
long long ans,a[1000005],tmp;
vector<int>v[1000005];
unordered_map<long long,int>mp;//使用 map<long long,vector<int>> 会爆空间
mt19937 rng(time(0));
uniform_int_distribution<long long>gen(1,0x3f3f3f3f3f3f3f3f);//随机数
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        v[a[i]].emplace_back(i);//将每一种颜色开一个 vector 存储
    }
    for(int i=1;i<=k;i++){
        tmp=0,siz=v[i].size();
        for(int j=0;j<=siz-2;j++)
            a[v[i][j]]=gen(rng),tmp^=a[v[i][j]];//随机赋权值
        a[v[i][siz-1]]=tmp;//保证同种颜色异或和为0
        v[i].clear();
    }
    for(int i=1;i<=n;i++){
        a[i]^=a[i-1];
        if(!mp.count(a[i]))
            mp[a[i]]=++tot;
        v[mp[a[i]]].emplace_back(i);
    }
    for(int i=1;i<=tot;i++){
        siz=v[i].size(),ans+=1ll*siz*(siz-1)/2;//统计个数
        for(int l=0,r=1;l<r&&r<siz;l++){//双指针，注意细节
            while(r<siz&&2*(v[i][r]-v[i][l])<=n)
                r++;
            if(l<r-1)
                ansx=min(ansx,n-2*(v[i][r-1]-v[i][l]));
            if(r<siz)
                ansx=min(ansx,2*(v[i][r]-v[i][l])-n);
        }
    }
    cout<<ans<<' '<<ansx;
    return 0;
}
```

---

## 作者：XuYueming (赞：1)

## 前言

题目链接：[洛谷](https://www.luogu.com.cn/problem/P3587)。

[更好的体验](https://www.cnblogs.com/XuYueming/p/18337390)。

## 题意简述

长度为 $n$ 的一串项链，每颗珠子是 $k$ 种颜色之一。第 $i$ 颗与第 $i-1, i+1$ 颗珠子相邻，第 $n$ 颗与第 $1$ 颗也相邻。切两刀，把项链断成两条链。要求每种颜色的珠子只能出现在其中一条链中。求方案数量（保证至少存在一种），以及切成的两段长度之差绝对值的最小值。

## 题目分析

据我所知，这道题有如下做法：

1. 线段树 + 增量法 + 最值 / 二分
1. 哈希 + 双指针
1. 分治 + 双指针

写一篇题解以总结并加深印象。

### 方法 $1$：线段树 + 增量法 + 最值 / 二分

分别对于每种颜色考虑。对于一种颜色，把这个环分成了若干段，我们要切一定是截取某一段的一部分，要不然就会跨过一个位置，不合法。暴力的想法是枚举一个端点，对每种颜色分别考虑，把合法的位置标记。最后被标记了 $k$ 次的位置就是合法的位置。

优化也很简单，对于两个相邻的位置，需要更改的地方并不多。考虑增量法，把端点 $i - 2 \sim i - 1$ 移动到 $i - 1 \sim i$，只会对 $i - 1$ 这个位置对应的颜色 $col_{i - 1}$ 造成影响。我们把上一次出现 $col_{i - 1}$ 的位置到 $i - 2 \sim i - 1$ 减 $1$，再把 $i - 1 \sim i$ 到下一次出现的位置之间加 $1$，就完成了更新。

这很线段树啊，先把边权右放，即用 $i$ 这个位置的值代表 $i - 1 \sim i$ 这条边，修改变成了区间加。第一个问题，即方案数是求区间最值和区间最值数量，很简单。

对于第二个问题，为了让答案尽量小，即让其中一段尽可能接近 $\cfrac{n}{2}$，我们先找到那个位置 $p$，这时候序列被 $p$ 和 $i$ 分成了三个部分，对于每个部分求区间最值出现的最靠近 $p$ 的位置，容易发现就是最左边或最右边的位置，计算下距离，对答案取个 $\min$ 即可。注意，那个部分的最值必须也要满足要求才能对答案有贡献。当然，也可以线段树上二分出最左边或最右边的位置。

此外，注意有些颜色可能在序列中只出现了一次，我们无论怎么切都不会使它们不合法，所以实现的时候特判一下就好了。以及环上的处理略为繁琐。

时间复杂度：$\Theta(n \log n)$，瓶颈在线段树，但逝大常数，要卡卡常。

### 方法 $2$：哈希 + 双指针

如果进一步分析问题很容易发现，环是一个幌子，我们只需要找到一段区间，对于每种颜色，要么全都在里面出现了，要么一次都没有出现，那么截取出来一定是合法的。因为对于另一半，每种颜色也可能是全都出现了或者一次都没有出现。

我们可以设计出一个哈希函数，对于每一种颜色全部出现和一次都没出现出现是等价的。

**异或哈希**：如果某种颜色出现了 $c$ 次，让前 $c - 1$ 出现的位置的权值设置成随机数，最后一位设置成前 $c - 1$ 位的权值异或和。这样，如果有一个区间完全包含或完全不包含所有的位置，对于这一种颜色，异或和均为 $0$。当然，对于一个区间里的每一个颜色异或和都为 $0$ 的话，这就是一个合法区间。哈希嘛，不需要考虑不同颜色之间的影响。于是问题变成了统计有多少区间异或和为 $0$。搞个前缀异或和，变成了前缀异或和相等的所有位置之间任意取构成的区间。如果某一种前缀和出现了 $x$ 次，那么方案数增加 $\cfrac{x(x - 1)}{2}$。第二个问题，就是最接近 $\cfrac{n}{2}$ 的两个位置，排序后双指针即可。

**和哈希**：设计一个哈希函数 $F(x)$，对于一个局面我们定义其权值为 $\sum \limits _ {i = 1} ^ {k} yzh[i] \cdot F(cnt[i])$，其中 $yzh[i]$ 为每一种颜色对应的随机权，$cnt[i]$ 为颜色 $i$ 在这个局面出现的次数。$F(x)$ 应满足对于 $x = 0$ 和 $x = $ 颜色 $i$ 在整个序列出现的总次数，返回值相同，对于其他 $x$ 返回个随机值即可。那么不就和异或哈希后续处理一样了吗？

时间复杂度：$\Theta(n \log n)$，瓶颈在排序，但挺快的。

### 方法 $3$：分治 + 双指针

首先来考虑简化模型。对于相互包含的颜色，如 $\texttt{A} \cdots \texttt{B} \cdots \texttt{A} \cdots \texttt{B}$，我们既要满足放在一段 $\texttt{A}$ 中，也要满足放在一段 $\texttt{B}$ 中，那么综合考虑，$\texttt{A}$ 和 $\texttt{B}$ 是没有区别的，那为什么不合并起来呢？发现简化后的模型，一种颜色只会出现在另一种颜色的某一段中。

不妨考虑一个颜色 $\texttt{A}$，它出现在序列上是形如 $\texttt{A} \cdots \texttt{A} \cdots \texttt{A}$ 的，不妨记作 $f(\texttt{A})$，那么我们选取的一段一定是在相邻的一段 $\texttt{A} \cdots \texttt{A}$ 中。我们分别考虑每一段。

每一段是形如 $\texttt{A} f(\texttt{B}) f(\texttt{C}) \cdots f(\texttt{K}) \texttt{A}$ 的。显然被分成了若干子问题，递归解决每一个 $f(\texttt{B} \cdots \texttt{K})$，接下来只用考虑选出的区间是完整的若干连续的子段，如 $f(\texttt{B})$，$f(\texttt{B}) f(\texttt{C})$ 等等。设 $f(\texttt{B}) f(\texttt{C}) \cdots f(\texttt{K})$ 有 $k$ 个子问题。那么对于当前对方案数的贡献是在 $k + 1$ 个点中选出两个，其中构成的连续段就是选出段，方案数是 $\cfrac{(k + 1) k}{2}$。第二个问题同之前解决方法一样，双指针即可。

分治部分很好处理，那来说说预处理合并颜色怎么搞。不妨设 $nxt_i$ 表示下一次出现 $i$ 这个位置的颜色的位置，如果没有则是 $0$。那么对于相交的两个颜色，这样一段：$j \cdots i \cdots nxt_j \cdots nxt_i$，即对于 $i$，$\exists j \in [1, i - 1] \land nxt_j \in (i, nxt_i)$。对于前一个条件，我们从左到右扫过来，对于当前的 $i$，只用考虑之前被扫过的 $j$。对于后一个条件，先考虑一个 $nxt$ 从顶到底递增的单调栈，每次先把 $nxt_j \leq i$ 的弹栈弹掉，对于剩下的元素，和 $< nxt_i$ 的每个合并一下，但是时间复杂度会假。如果要保证时间复杂度，即每个元素只被加进去一次，弹出去一次，我们在访问的时候就要弹掉。

对于 $i$ 之后的一个 $k$，如果 $i$ 和 $k$ 满足交叉，那么这么做没有什么问题。但是如果有 $nxt_k \leq nxt_i$ 并且存在一个被弹掉的 $j$，满足 $nxt_k > nxt_j$，就会出现问题，可见下图。

![图一：处理前](https://cdn.luogu.com.cn/upload/image_hosting/zyd22l5l.png)

当然，类似红绿关系的可以不止两种，可以继续套。我们用上述单调栈合并后的结果是下图。

![图二：处理一遍后](https://cdn.luogu.com.cn/upload/image_hosting/7i048zsi.png)

发现，合并后，如果还存在上述遗留情况的交叉，会越过处理后同一种颜色的相邻两段。而在处理前遗留情况是越过某一颜色的最后一次出现的位置。所以再用相同的算法处理一遍即可。

![图三：最终形态](https://cdn.luogu.com.cn/upload/image_hosting/0m9xfgsg.png)

至于颜色的合并，使用并查集即可。

至此，我们完成了本题的求解。时间复杂度 $\Theta(n \alpha (k))$。瓶颈在于并查集合并。

## 代码

均给出了详细注释，供大家参考。

### 方法 $1$：线段树 + 增量法 + 最值 / 二分

只写了最值版本的，[代码](https://www.luogu.com.cn/paste/xffu0w1p)，跑得[很慢](https://www.luogu.com.cn/record/170730768)。

### 方法 $2$：哈希 + 双指针

#### 异或哈希

[代码](https://www.luogu.com.cn/paste/bwsoi93f)，[$528$ 毫秒](https://www.luogu.com.cn/record/170732284)。

#### 和哈希

[代码](https://www.luogu.com.cn/paste/tbjuihri)，[$1.43$ 秒](https://www.luogu.com.cn/record/170733369)。

### 方法 $3$：分治 + 双指针

是[最优解](https://www.luogu.com.cn/record/170728093)，才 $200$ 毫秒左右。

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

const int MAX = 1 << 25;
char buf[MAX], *p = buf;

#define isdigit(x) ('0' <= x && x <= '9')
#define getchar() *p++
#define check(x) ans = min(ans, abs(n - ((x) << 1)))

inline void read(int &x) {
	char ch = 0; x = 0;
	for (; !isdigit(ch); ch = getchar());
	for (;  isdigit(ch); x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar());
}

const int N = 1e6 + 10;
const int inf = 0x3f3f3f3f;

int n, k, val[N], ans = inf;
long long cnt;

int fa[N], rk[N];
int get(int x) { return fa[x] == x ? x : fa[x] = get(fa[x]); }
void merge(int a, int b) {
	if ((a = get(a)) == (b = get(b))) return;
	if (rk[a] < rk[b]) swap(a, b);
	fa[b] = a;
	if (rk[a] == rk[b]) ++rk[a];
}
// 并查集 

int fir[N], lst[N], nxt[N], pre[N];

inline int trans(int x) { return x ^ n ? x + 1 : 1; }  // x 的下一个位置 
inline int snart(int x) { return x ^ 1 ? x - 1 : n; }  // x 的上一个位置 
inline int dis(int x, int y) { return x - y + 1; }     // y ~ x 这样一段的距离 

void solve(int x) {
	for (int i = trans(x); i != nxt[x]; i = trans(pre[i]))  // i 是这种颜色出现的第一个位置，pre[i] 就是最后一个位置 
	for (int j = i; nxt[j] != i; j = nxt[j])  // 把这种颜色每一段分治解决 
		solve(j);
	int cnt = 0;
	for (int i = trans(x), j = i; i != nxt[x]; ++cnt, i = trans(pre[i])) {  // 双指针找接近 n/2 的方案 
		while (j != nxt[x] && dis(pre[i], j) > n >> 1) j = trans(pre[j]);
		check(dis(pre[i], j));
		check(dis(pre[i], nxt[snart(j)]));
	}
	::cnt += 1ll * cnt * (cnt + 1);
}

int stack[N], top;
inline void init() {
	memset(lst, 0, sizeof (int) * (k + 1)), top = 0;
	for (int i = 1; i <= n; ++i) nxt[i] = 0, nxt[lst[val[i]]] = i, lst[val[i]] = i;
	for (int i = 1; i <= n; ++i) if (nxt[i]) {
		while (top && nxt[stack[top]] <= i) --top;
		while (top && nxt[stack[top]] <= nxt[i]) merge(val[i], val[stack[top--]]);
		stack[++top] = i;
	}  // 单调栈操作 
	for (int i = 1; i <= n; ++i) val[i] = get(val[i]);  // 直接设置成合并后的颜色 
}

signed main() {
	fread(buf, 1, MAX, stdin);
	read(n), read(k);
	for (int i = 1; i <= n; ++i) read(val[i]);
	for (int i = 1; i <= k; ++i) fa[i] = i;
	init(), init();  // 预处理两遍 
	memset(lst, 0, sizeof (int) * (k + 1));
	for (int i = 1; i <= n; ++i) {
		if (!fir[val[i]]) fir[val[i]] = i;
		else nxt[lst[val[i]]] = i;
		lst[val[i]] = i;
	}
	for (int i = 1; i <= n; ++i) {
		if (!nxt[i]) nxt[i] = fir[val[i]];
		pre[nxt[i]] = i;
	}  // 处理前驱后继 
	int i = 1; do solve(i), i = nxt[i]; while (i != 1);  // 最外层调用 
	printf("%lld %d", cnt >> 1, ans);
	return 0;
}
```

## 后记

希望本文能够帮助你熟悉每一种方法。也希望我以后遇到这种题别寄了啊！

---

## 作者：MatrixGroup (赞：1)

感觉随机化一向很神秘啊。

## 题意

给定一个长度为 $n$ 的环，环上每个点有颜色。对于切两刀把它分成两个非空的链的方案，使得每种颜色只在一条链上出现：求方案数和最小的两端链长度之差，保证存在方案。

$2\le n\le10^6$。

## 题解

首先环是诈骗的，本质上那个不包含 $n$ 号点的链就是 $[0,n-1]$ 的一个子区间。一个区间合法，当且仅当每个颜色要么都在它当中出现或者都不在。

考虑给每个点赋一个随机在 $2^{64}$ 以内的权值，使得同种颜色的异或和为 $0$。这样，合法的区间区间异或和一定为 $0$，而不合法的区间只有 $\dfrac{1}{2^{64}}$ 的概率异或和为 $0$，出错率最大可能大约是 $1-(1-\dfrac{1}{2^{64}})^{5\times10^{11}}\approx\dfrac{5\times10^{11}}{2^{64}}$，可以忽略不计。

因此题目转化成了求 $s_0,s_1,s_2,\cdots,s_{n-1}$（$s$ 是权值的前缀异或）中，选出两个同样的数的方案和离 $\dfrac{n}{2}$ 最近的距离。这个题就很简单了，随便排序或者双指针之类的统计一下即可。

复杂度依实现 $O(n)$ 或 $O(n\log n)$。

---

## 作者：Alex_Wei (赞：1)

> [P3587 [POI2015]POD](https://www.luogu.com.cn/problem/P3587)
>
> [POI 合集](https://www.cnblogs.com/alex-wei/p/POI.html)。

类似求子区间个数的题目可考虑使用增量法。将这种思想运用到本题，考虑对于切在 $i$ 的一刀从 $i$ 挪到 $i+1$ 的过程中合法的另一刀的位置 $p$ 如何变化。

首先，当 $i=0$ 时，$p$ 一定满足对于任意颜色 $c$ 都有 $1\sim p$ 要么包含所有颜色为 $c$ 的珠子，要么不包含任意一个。也就是说对于每一种颜色，将所有出现的珠子看成一个环，那么**合法的另一刀位置位于第一刀劈开的相邻两个珠子之间**。

根据这一性质我们已经有了一个非常直接的做法：线段树维护区间最小值，数量，以及取到最小值的位置的最小值和最大值（这两个为了第二问），还需要支持区间修改。对于每个断点，找到没有被覆盖 “不合法线段” 的位置之和，即 $[1,n]$ 等于 $0$ 的位置个数。由于断点处一定没有被任何不合法线段覆盖，所以就是 $[1,n]$ 取到区间最小值的位置数量 $-1$。第二问通过对应区间维护的最小值和最大值计算即可。时间复杂度线性对数，常数非常大。

```cpp
const int N = 1e6 + 5;
const int inf = 1e9 + 7;
int ql, qr, mnp[N << 2], mxp[N << 2], val[N << 2], cnt[N << 2], laz[N << 2];
void build(int l, int r, int x) {
	mnp[x] = l, mxp[x] = r, cnt[x] = r - l + 1;
	if(l == r) return;
	int m = l + r >> 1;
	build(l, m, x << 1), build(m + 1, r, x << 1 | 1); 
}
void push(int x) {
	val[x] = min(val[x << 1], val[x << 1 | 1]), cnt[x] = 0, mxp[x] = -inf, mnp[x] = inf;
	if(val[x << 1] == val[x]) cnt[x] += cnt[x << 1], mnp[x] = min(mnp[x], mnp[x << 1]), mxp[x] = max(mxp[x], mxp[x << 1]);
	if(val[x << 1 | 1] == val[x]) cnt[x] += cnt[x << 1 | 1], mnp[x] = min(mnp[x], mnp[x << 1 | 1]), mxp[x] = max(mxp[x], mxp[x << 1 | 1]);
}
void tag(int x, int v) {laz[x] += v, val[x] += v;}
void down(int x) {if(laz[x]) tag(x << 1, laz[x]), tag(x << 1 | 1, laz[x]), laz[x] = 0;}
void modify(int l, int r, int x, int v) {
	if(ql > qr) return;
	if(ql <= l && r <= qr) return tag(x, v), void();
	int m = l + r >> 1; down(x);
	if(ql <= m) modify(l, m, x << 1, v);
	if(m < qr) modify(m + 1, r, x << 1 | 1, v);
	push(x); 
}
int querymin(int l, int r, int x) {
	if(val[x] || ql > qr) return inf;
	if(ql <= l && r <= qr) return mnp[x];
	int m = l + r >> 1, ans = inf; down(x);
	if(ql <= m) cmin(ans, querymin(l, m, x << 1));
	if(m < qr) cmin(ans, querymin(m + 1, r, x << 1 | 1));
	return ans;
}
int querymax(int l, int r, int x) {
	if(val[x] || ql > qr) return -inf;
	if(ql <= l && r <= qr) return mxp[x];
	int m = l + r >> 1, ans = -inf; down(x);
	if(ql <= m) cmax(ans, querymax(l, m, x << 1));
	if(m < qr) cmax(ans, querymax(m + 1, r, x << 1 | 1));
	return ans;
}

int n, k, ans = N, col[N], pos[N], sz[N];
ll tot;
vint buc[N];
void update(int p) {
	tot += cnt[1] - 1;
	if(cnt[1] == 1) return;
	if(p <= n >> 1) {
		int q = p + (n >> 1); ql = p, qr = q;
		int res = querymax(1, n, 1);
		cmin(ans, n - (res - p << 1)), ql = q + 1, qr = n;
		res = querymin(1, n, 1);
		cmin(ans, (res - p << 1) - n), ql = 1, qr = p - 1;
		res = querymin(1, n, 1);
		cmin(ans, n - (p - res << 1));
	} else {
		int q = p - (n >> 1); ql = q, qr = p;
		int res = querymin(1, n, 1);
		cmin(ans, n - (p - res << 1)), ql = p + 1, qr = n;
		res = querymax(1, n, 1);
		cmin(ans, n - (res - p << 1)), ql = 1, qr = q - 1;
		res = querymax(1, n, 1);
		cmin(ans, (p - res << 1) - n);
	}
}
int main() {
	cin >> n >> k, build(1, n, 1);
	for(int i = 1; i <= n; i++) col[i] = read(), pos[i] = sz[col[i]]++;
	for(int i = 1; i <= k; i++) buc[i].resize(sz[i]), sz[i] = 0;
	for(int i = 1; i <= n; i++) buc[col[i]][sz[col[i]]++] = i;
	for(int i = 1; i <= k; i++) if(sz[i] > 1)
		ql = buc[i][0], qr = buc[i][sz[i] - 1] - 1, modify(1, n, 1, 1);
	update(n);
	for(int i = 1; i < n; i++) {
		if(sz[col[i]] > 1) {
			int p = pos[i];
			if(p) {
				if(p + 1 == sz[col[i]]) {
					ql = 1, qr = buc[col[i]][p - 1] - 1, modify(1, n, 1, -1);
					ql = i, qr = n, modify(1, n, 1, -1);
					ql = buc[col[i]][0], qr = i - 1, modify(1, n, 1, 1);
				} else {
					ql = buc[col[i]][p - 1], qr = i - 1, modify(1, n, 1, 1);
					ql = i, qr = buc[col[i]][p + 1] - 1, modify(1, n, 1, -1);
				}
			}
			else {
				ql = i, qr = buc[col[i]][sz[col[i]] - 1] - 1, modify(1, n, 1, -1);
				ql = 1, qr = i - 1, modify(1, n, 1, 1);
				ql = buc[col[i]][p + 1], qr = n, modify(1, n, 1, 1);
			}
		} update(i);
	}
	cout << tot / 2 << " " << ans << "\n";
	return cerr << "Time : " << clock() << " ms" << endl, flush(), 0;
}
```

---

## 作者：daniEl_lElE (赞：0)

考虑哈希，给每个位置赋值一个权值 $v_i$，使得同色 $\oplus$ 为 $0$。我们发现如果将项链断成两半，那么两边 $\oplus$ 均为 $0$。也就是说我们要找区间 $\oplus$ 为 $0$ 的区间个数。用 map 维护前缀 $\oplus$ 等于某个值 $p$ 的前缀个数即可。

考虑将所有前缀 $\oplus$ 等于某个值 $p$ 的前缀塞到一个桶中。找到其中距离 $\frac{n}{2}$ 最近的点对即为切成的两段长度之差绝对值的最小值的切法。可以用双指针做。

总复杂度 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
#define int unsigned long long
#define min(i,j) ((i<j)?i:j)
#define mid ((l+r)>>1)
using namespace std;
mt19937_64 rng(time(0));
int a[1000005],val[1000005],num[1000005],cnt,b[1000005],c[1000005];
vector<int> vc[1000005];
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
	int n,k; cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i],vc[a[i]].push_back(i);
	for(int i=1;i<=k;i++){
		if(vc[i].size()){
			int tot=0;
			for(int j=0;j+1<vc[i].size();j++){
				val[vc[i][j]]=rng();
				tot^=val[vc[i][j]];
			}
			val[vc[i][vc[i].size()-1]]=tot;
		}
	}
	for(int i=1;i<=k;i++) vc[i].clear();
	int ans=0,tmp=0;
	for(int i=1;i<=n;i++){
		tmp^=val[i];
		b[i]=c[i]=tmp;
	}
	sort(c+1,c+n+1);
	cnt=unique(c+1,c+n+1)-c-1;
	for(int i=1;i<=n;i++){
		b[i]=lower_bound(c+1,c+cnt+1,b[i])-c;
		vc[b[i]].push_back(i);
		ans+=num[b[i]];
		num[b[i]]++;
	}
	cout<<ans<<" ";
	int maxv=0;
	for(int i=1;i<=cnt;i++){
		int it=0;
		for(int j=1;j<vc[i].size();j++){
			while(min(vc[i][j]-vc[i][it],n-(vc[i][j]-vc[i][it]))<min(vc[i][j]-vc[i][it+1],n-(vc[i][j]-vc[i][it+1]))) it++;
			maxv=max(maxv,min(vc[i][j]-vc[i][it],n-(vc[i][j]-vc[i][it])));
		}
	}
	cout<<(n-maxv)-maxv;
	return 0;
}
```

---

## 作者：OrezTsim (赞：0)

~~太久没用过异或哈希导致忘记这玩意了是什么鬼。~~

判断一种颜色的珠子在一个区间中全部出现可以使用异或哈希。

即对于一类出现 $c$ 次的珠子，将前 $c-1$ 个珠子随机赋为 $v_1,v_2,\cdots,v_{c-1}$，最后一个珠子赋为 $\text{xor}_{i=1}^{c-1}v_i$。

那么判定一个区间合法的条件就是这个区间异或和为 $0$。

知道这个之后，就可以对于异或前缀和开桶直接计算。

注意如果划分环的方式为 $[1,i],[i+1,n]$ 就会导致重复计算方案。

但是开桶的时候不额外加进去一个 $0$ 表示空前缀，所以没事。

---

设最后有 $p$ 种不同的前缀异或和，每种和的个数为 $c_i$，则第一问答案为 $\sum\limits_{i=1}^p \dfrac{c_i(c_i-1)}{2}$。

第二问答案对于每一种前缀异或和单独二分，查询最接近 $\dfrac{n}{2}$ 的长度即可。

```cpp
#include<bits/stdc++.h>
using ll=long long;
using ull=unsigned long long;
using namespace std;

mt19937_64 rng(time(NULL));
const int N=1e6+10; ll res;
int n,k,to,len,ser=1e9,a[N],id[N]; ull val[N],buc[N];
vector<int>vec[N],pre[N];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n>>k,to=n>>1;
    for(int i=1;i<=n;++i) cin>>a[i],vec[a[i]].push_back(i);
    for(int i=1;i<=k;++i) {
        int siz=vec[i].size();
        if(siz==1) continue; ull all=0;
        for(int j=0;j<siz-1;++j) all^=(val[vec[i][j]]=rng());
        val[vec[i].back()]=all;
    }
    for(int i=1;i<=n;++i) val[i]^=val[i-1],buc[i]=val[i];
    sort(buc+1,buc+1+n),len=unique(buc+1,buc+1+n)-buc-1;
    for(int i=1;i<=n;++i) {
        id[i]=lower_bound(buc+1,buc+1+len,val[i])-buc;
        pre[id[i]].emplace_back(i);
    }
    for(int i=1;i<=len;++i) res+=1ll*pre[i].size()*(pre[i].size()-1)/2;
    for(int i=1;i<=len;++i) {
        int siz=pre[i].size();
        if(siz==1) continue;
        for(int j=0;j<siz-1;++j) {
            int pos=pre[i][j],l=j+1,r=siz-1,ret=siz;
            while(l<=r) {
                int mid=(l+r)>>1;
                if(pre[i][mid]-pos>=to) ret=mid,r=mid-1;
                else l=mid+1;
            }
            if(ret<siz) ser=min(ser,abs(n-2*(pre[i][ret]-pos)));
            if(--ret>j) ser=min(ser,abs(n-2*(pre[i][ret]-pos)));
        }
    }
    return cout<<res<<' '<<ser,0;
}
```

---

## 作者：serene_analysis (赞：0)

不需要任何思维的做法。

---

将左端点从左往右移，动态地有哪些右端点是合法的。考虑颜色给予了我们什么样的限制。设 $lef_c,rig_c$ 分别表示颜色 $c$ 出现的最靠左和最靠右的位置，当前左端点是 $l$，分类讨论（这里的符号使用可能不够规范，但是表达的就是那个意思）：

+ $l \gt rig_c$ 时颜色 $c$ 不会产生任何限制。
+ $l \leq lef_c$ 时右端点只能取 $[l,lef_c) \cup [rig_c,n]$。
+ $l \in (lef_c,rig_c]$ 时，右端点只能取 $l$ 到颜色 $c$ 下一个出现的位置减 $1$ 之间。

考虑用数据结构将这些限制表示出来，由于我们还要做第二问，优先选择常见数据结构。考虑线段树，那么第二条限制相当于 $[lef_c,rig_c)$ 区间覆盖。但是注意到我们要撤销，怎么办？观察到我们只需要查询合法的位置的个数，于是可以将一次 $[l,r]$ 的覆盖改为区间加 $1$，撤销改为区间减 $-1$，那么合法的位置的值一定是 $0$，于是只需要维护区间最小值和最小值的个数即可。

第三条可以直接动态维护每个颜色下次出现的位置区间修改，但是时限只有 $\text{1s}$，$n$ 又是 $10^6$ 量级，能不能换个常数小一点的维护？观察到第三条限制实际上只限制了右端点不能取一个后缀，那么所有限制实际上有用的只有一个，也就是下一次出现最早的颜色的限制，于是可以直接使用优先队列维护最小值（当然我自己写的时候脑抽了写了 $\texttt{std::multiset}$，但是无伤大雅），每次左端点和队首重合时取出队首删掉加入对应颜色下一个出现的位置，查询时直接把右端点设为队首减 $1$ 即可。那么第一问就做完了。

考虑第二问，这时我们要求的就是长度差的绝对值的最小值。稍微转化一下，也就是求最靠近左端点加 $\lfloor \frac{n}{2} \rfloor -1$ 的合法位置。那么分别找在其左边最靠右的和在其右边最靠左的合法位置求出答案取最小值即可，这个过程可以使用线段树二分完成。

接下来是几个小细节。

+ 为了实现方便，可以在最开始加入所有限制，在限制的左端点 $+1$ 处撤销。
+ 注意到当 $1$ 作为左端点时，无论右端点在哪里都只会拆成不超过两段。一段的情况肯定不合法，两端的情况还会被相应的右端点 $+1$ 处统计到，于是我们在 $1$ 处不计算答案就可以避免算多。
+ $\text{128MB}$ 的空间稍微有点卡，你的线段树不能把左右端点存下来，而只能即时计算。

时间复杂度 $\mathcal{O}(n \log n)$，空间复杂度大常数 $\mathcal{O}(n)$。

```
#include<algorithm>
#include<cstdio>
#include<vector>
#include<set>
typedef long long ll;
const int maxn=1e6+5;
struct node{
	int tag;
	int mcou,mi;
}tree[maxn*4];
void build(int i,int l,int r){
	tree[i].mcou=r-l+1;
	if(l==r)return;
	int mid=(l+r)>>1;
	build(i*2,l,mid),build(i*2+1,mid+1,r);
	return;
}
void update(int i){
	tree[i].mi=std::min(tree[i*2].mi,tree[i*2+1].mi);
	tree[i].mcou=0;
	if(tree[i].mi==tree[i*2].mi)tree[i].mcou+=tree[i*2].mcou;
	if(tree[i].mi==tree[i*2+1].mi)tree[i].mcou+=tree[i*2+1].mcou;
	return;
}
void pushdown(int i){
	if(!tree[i].tag)return;
	node &ls=tree[i*2],&rs=tree[i*2+1],&now=tree[i];
	ls.tag+=now.tag,ls.mi+=now.tag;
	rs.tag+=now.tag,rs.mi+=now.tag;
	now.tag=0;
	return;
}
void modify(int i,int nl,int nr,int l,int r,int k){
	if(nl>=l&&nr<=r){
		tree[i].tag+=k,tree[i].mi+=k;
		return;
	}
	pushdown(i);
	int mid=(nl+nr)>>1;
	if(mid>=l)modify(i*2,nl,mid,l,r,k);
	if(mid<r)modify(i*2+1,mid+1,nr,l,r,k);
	update(i);
	return;
}
int qsum(int i,int nl,int nr,int l,int r){
	if(nl>=l&&nr<=r)return tree[i].mi==0?tree[i].mcou:0;
	pushdown(i);
	int ret=0,mid=(nl+nr)>>1;
	if(mid>=l)ret+=qsum(i*2,nl,mid,l,r);
	if(mid<r)ret+=qsum(i*2+1,mid+1,nr,l,r);
	return ret;
}
int lef(int i,int nl,int nr,int l,int r){
	if(nr<l||nl>r||tree[i].mi!=0)return 4*maxn-2;
	if(nl==nr)return nl;
	pushdown(i);
	int mid=(nl+nr)>>1;
	if(tree[i*2].mi==0){
		int ret=lef(i*2,nl,mid,l,r);
		return ret==4*maxn-2?lef(i*2+1,mid+1,nr,l,r):ret;
	}
	else return lef(i*2+1,mid+1,nr,l,r);
}
int rig(int i,int nl,int nr,int l,int r){
	if(nr<l||nl>r||tree[i].mi!=0)return 4*maxn-2;
	if(nl==nr)return nl;
	pushdown(i);
	int mid=(nl+nr)>>1;
	if(tree[i*2+1].mi==0){
		int ret=rig(i*2+1,mid+1,nr,l,r);
		return ret==4*maxn-2?rig(i*2,nl,mid,l,r):ret;
	}
	else return rig(i*2,nl,mid,l,r);
}
struct pii{
	int val,id;
	friend bool operator<(pii now,pii oth){return now.val<oth.val;}
};
std::multiset<pii>lim;
int n,k;
int col[maxn],fir[maxn],fin[maxn];
std::vector<int>apr[maxn],dec[maxn];
int dt[maxn];
int abs(int x){return x<0?-x:x;}
int get(int x){return abs(n-2*x);}
signed main(){
//	freopen("9.in","r",stdin);
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%d",col+i);
		apr[col[i]].push_back(i),fin[col[i]]=i;
		if(!fir[col[i]])fir[col[i]]=i;
	}
	build(1,1,n);
	for(int i=1;i<=k;i++)if(fir[i]!=fin[i]){
		modify(1,1,n,fir[i],fin[i]-1,1);
		dec[fir[i]+1].push_back(fin[i]);
	}
	ll ans=0;
	int best=n;
	for(int i=1;i<=n;i++){
		for(int v:dec[i])modify(1,1,n,i-1,v-1,-1);
		if(lim.size()){
			pii now=*lim.begin();
			if(i!=1)ans+=qsum(1,1,n,i,now.val-1);
			int goal=std::min({n,i+n/2-1,now.val-1});
			if(i<=goal)best=std::min({best,get(rig(1,1,n,i,goal)-i+1),get(lef(1,1,n,goal,std::min(now.val-1,n))-i+1)});
		}
		else{
			if(i!=1)ans+=qsum(1,1,n,i,n);
			int goal=std::min(n,i+n/2-1);
			best=std::min({best,get(rig(1,1,n,i,goal)-i+1),get(lef(1,1,n,goal,n)-i+1)});
		}
		if(dt[col[i]]){
			lim.erase(lim.find((pii){apr[col[i]][dt[col[i]]],col[i]}));
			if(dt[col[i]]!=(int)apr[col[i]].size()-1)lim.insert((pii){apr[col[i]][++dt[col[i]]],col[i]});
		}
		else if(apr[col[i]].size()!=1)lim.insert((pii){apr[col[i]][++dt[col[i]]],col[i]});
	}
	printf("%lld %d",ans,best);
	return 0;
}
/*
6 3
1 2 3 2 3 1
*/
/*
9 5
2 5 3 2 2 4 1 1 3
Minus the sequence start from 1 because that will be calculated later.
*/
//namespace burningContract
```

感谢你的阅读。

---


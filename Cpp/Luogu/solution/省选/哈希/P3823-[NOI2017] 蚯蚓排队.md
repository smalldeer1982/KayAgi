# [NOI2017] 蚯蚓排队

## 题目描述

蚯蚓幼儿园有 $n$ 只蚯蚓。幼儿园园长神刀手为了管理方便，时常让这些蚯蚓们列队表演。

所有蚯蚓用从 $1$ 到 $n$ 的连续正整数编号。每只蚯蚓的长度可以用一个正整数表示，根据入园要求，所有蚯蚓的长度都不超过 $6$ 。神刀手希望这些蚯蚓排成若干个队伍，初始时，每只蚯蚓各自排成一个仅有一只蚯蚓的队伍，该蚯蚓既在队首，也在队尾。

神刀手将会依次进行 $m$ 次操作，每个操作都是以下三种操作中的一种：

1. 给出 $i$ 和 $j$ ，令 $i$ 号蚯蚓与 $j$ 号蚯蚓所在的两个队伍合并为一个队伍，具体来说，令 $j$ 号蚯蚓紧挨在 $i$ 号蚯蚓之后，其余蚯蚓保持队伍的前后关系不变。

2. 给出 $i$ ，令 $i$ 号蚯蚓与紧挨其后的一只蚯蚓分离为两个队伍，具体来说，在分离之后， $i$ 号蚯蚓在其中一个队伍的队尾，原本紧挨其后的那一只蚯蚓在另一个队伍的队首，其余蚯蚓保持队伍的前后关系不变。

3. 给出一个正整数 $k$ 和一个长度至少为 $k$ 的数字串 $s$ ，对于 $s$ 的每个长度为 $k$ 的连续子串 $t$ （这样的子串共有 $|s|-k+1$ 个，其中 $|s|$ 为 $s$ 的长度），定义函数 $f(t)$，询问所有这些 $f(t)$ 的**乘积**对 $998244353$ 取模后的结果。其中 $f(t)$ 的定义如下：

对于当前的蚯蚓队伍，定义某个蚯蚓的**向后 $k$ 数字串**为：从该蚯蚓出发，沿队伍的向后方向，寻找最近的 $k$ 只蚯蚓（包括其自身），将这些蚯蚓的长度视作字符连接而成的数字串；如果这样找到的蚯蚓不足 $k$ 只，则其没有**向后$k$数字串**。例如蚯蚓的队伍为 $10$ 号蚯蚓在队首，其后是 $22$ 号蚯蚓，其后是 $3$ 号蚯蚓（为队尾），这些蚯蚓的长度分别为 $4$ 、 $5$ 、 $6$ ，则 $10$ 号蚯蚓的**向后 $3$ 数字串**为 `456`， $22$ 号蚯蚓没有**向后 $3$ 数字串**，但其**向后 $2$ 数字串**为 `56`，其**向后 $1$ 数字串**为 `5`。

而 $f(t)$ 表示所有蚯蚓中，**向后 $k$ 数字串**恰好为 $t$ 的蚯蚓只数。

## 说明/提示

保证 $n \leq 2 \times 10^{5}$，$m \leq 5 \times 10^{5}$，$k \leq 50$ 。

设 $\sum |s|$ 为某个输入文件中所有询问的 $s$ 的长度总和，则 $\sum |s| \leq 10^{7}$  。

设 $c$ 为某个输入文件中形如 `2 i` 的操作的次数，则 $c \leq 10^{3}$ 。

每个测试点的详细信息见下表：

| 测试点编号 | $n$ | $m$ | $k$ | $\sum \|s\|$ | $c$ | 全为 $\texttt{1}$ |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 1 | $=1$ | $\leq 10^{3}$ | $=1$ | $\leq 10^{3}$ | $=0$ | No |
| 2 | $\leq 20$ | $\leq 40$ | $\leq 10$ | $\leq 10^{3}$ | $=0$ | No |
| 3 | $\leq 150$ | $\leq 2,000$ | $\leq 50$ | $\leq 10^{3}$ | $\leq 10^{3}$ | No |
| 4 | $\leq 500$ | $\leq 600$ | $\leq 50$ | $\leq 10^{3}$ | $=0$ | No |
| 5 | $\leq 10^{3}$ | $\leq 2,000$ | $\leq 50$ | $\leq 10^{3}$ | $\leq 10^{3}$ | No |
| 6 | $\leq 5 \times 10^{4}$ | $\leq 6 \times 10^{4}$ | $\leq 5$ | $\leq 5 \times 10^{4}$ | $\leq 10^{3}$ | No |
| 7 | $\leq 5 \times 10^{4}$ | $\leq 6 \times 10^{4}$ | $\leq 50$ | $\leq 5 \times 10^{4}$ | $=0$ | Yes |
| 8 | $\leq 5 \times 10^{4}$ | $\leq 6 \times 10^{4}$ | $\leq 50$ | $\leq 5 \times 10^{4}$ | $=0$ | No |
| 9 | $\leq 5 \times 10^{4}$ | $\leq 6 \times 10^{4}$ | $\leq 50$ | $\leq 5 \times 10^{4}$ | $\leq 10^{3}$ | No |
| 10 | $\leq 5 \times 10^{4}$ | $\leq 8 \times 10^{4}$ | $\leq 50$ | $\leq 2.5 \times 10^{6}$ | $=0$ | No |
| 11 | $\leq 5 \times 10^{4}$ | $\leq 8 \times 10^{4}$ | $\leq 50$ | $\leq 2.5 \times 10^{6}$ | $\leq 10^{3}$ | No |
| 12 | $\leq 10^{5}$ | $\leq 1.1 \times 10^{5}$ | $\leq 6$ | $\leq 10^{5}$ | $\leq 10^{3}$ | No |
| 13 | $\leq 10^{5}$ | $\leq 1.1 \times 10^{5}$ | $\leq 50$ | $\leq 10^{5}$ | $=0$ | Yes |
| 14 | $\leq 10^{5}$ | $\leq 1.1 \times 10^{5}$ | $\leq 50$ | $\leq 10^{5}$ | $=0$ | No |
| 15 | $\leq 10^{5}$ | $\leq 1.1 \times 10^{5}$ | $\leq 50$ | $\leq 10^{5}$ | $\leq 10^{3}$ | No |
| 16 | $\leq 10^{5}$ | $\leq 1.5 \times 10^{5}$ | $\leq 50$ | $\leq 5 \times 10^{6}$ | $=0$ | No |
| 17 | $\leq 10^{5}$ | $\leq 1.5 \times 10^{5}$ | $\leq 50$ | $\leq 5 \times 10^{6}$ | $\leq 10^{3}$ | No |
| 18 | $\leq 2 \times 10^{5}$ | $\leq 5 \times 10^{5}$ | $=1$ | $\leq 10^{7}$ | $=0$ | No |
| 19 | $\leq 2 \times 10^{5}$ | $\leq 5 \times 10^{5}$ | $=1$ | $\leq 10^{7}$ | $\leq 10^{3}$ | No |
| 20 | $\leq 2 \times 10^{5}$ | $\leq 2.5 \times 10^{5}$ | $\leq 7$ | $\leq 2 \times 10^{5}$ | $\leq 10^{3}$ | No |
| 21 | $\leq 2 \times 10^{5}$ | $\leq 2.5 \times 10^{5}$ | $\leq 50$ | $\leq 2 \times 10^{5}$ | $=0$ | Yes |
| 22 | $\leq 2 \times 10^{5}$ | $\leq 2.5 \times 10^{5}$ | $\leq 50$ | $\leq 2 \times 10^{5}$ | $=0$ | No |
| 23 | $\leq 2 \times 10^{5}$ | $\leq 2.5 \times 10^{5}$ | $\leq 50$ | $\leq 2 \times 10^{5}$ | $\leq 10^{3}$ | No |
| 24 | $\leq 2 \times 10^{5}$ | $\leq 3 \times 10^{5}$ | $\leq 50$ | $\leq 10^{7}$ | $=0$ | No |
| 25 | $\leq 2 \times 10^{5}$ | $\leq 3 \times 10^{5}$ | $\leq 50$ | $\leq 10^{7}$ | $\leq 10^{3}$ | No |

如果一个测试点的“全为`1`”的一列为“Yes”，表示该测试点的所有蚯蚓的长度均为 1，并且所有询问串 $s$ 的每一位也均为`1`。

## 样例 #1

### 输入

```
5 9
3 1 3 5 3
3 333135 2
3 333135 1
1 1 3
1 2 5
1 3 2
1 5 4
3 333135 2
3 333135 1
3 333135 3```

### 输出

```
0
81
1
81
0```

## 样例 #2

### 输入

```
2 10
6 6
3 666666 1
1 1 2
3 666666 2
3 666666 4
3 666666666666666666666666666666 1
2 1
1 2 1
3 666666 2
3 666666 4
3 666666666666666666666666666666 1```

### 输出

```
64
1
0
75497471
1
0
75497471```

# 题解

## 作者：FunnyCreatress (赞：21)

相当愚蠢的一道题......

我们发现 $k$ 很小，所以用哈希表在每次合并和分裂的时候维护每个 $k$ 的答案。

然后发现这个队伍是可以直接链表维护的，并且增量只与两端的 $k$ 个有关。于是每次合并把前面队伍的后 $k$ 个和后面队伍的前 $k$ 个拉出来哈希一下合并起来。分裂同理维护。

如果你以为这东西是 $O(nk^2+\sum|s|)$ 过不去的时候，你会看到那个 $c\le 1000$。于是我们重新分析一下复杂度。如果没有拆开操作的话，那么由于总共只有 $O(nk)$ 段有效子列，所以复杂度是 $O(nk)$，每次分裂只会增加 $O(k^2)$ 的复杂度和势能，所以总复杂度是 $O(nk+ck^2+\sum|s|)$，可以接受。

~~这么水的题是怎么进NOI的~~

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int N=3e5+5,K=55,P=1e7+7,P2=998244353;
int n,m,k,l[N],nxt[N],pre[N],bas1[K],hs1[K],hs2[K];char s[P];
int hd[P],Nxt[N*K],Len[N*K],tot,cnt[N*K];ull key[N*K],bas2[K],Hs1[K],Hs2[K];
void add(int L,int h1,ull h2,int v){
	for(int i=hd[h1];i;i=Nxt[i])if(key[i]==h2&&Len[i]==L){cnt[i]+=v;return;}
	Len[++tot]=L,key[tot]=h2,Nxt[tot]=hd[h1],hd[h1]=tot,cnt[tot]=1;
}
int query(int L,int h1,ull h2){
	for(int i=hd[h1];i;i=Nxt[i])if(key[i]==h2&&Len[i]==L)return cnt[i];
	return 0;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&l[i]),add(1,l[i],l[i],1);
	for(int i=bas1[0]=bas2[0]=1;i<=51;i++)bas1[i]=bas1[i-1]*13%P,bas2[i]=bas2[i-1]*137;
	for(int i=1,op,x,y;i<=m;i++){
		scanf("%d",&op);
		if(op==1){
			scanf("%d%d",&x,&y);int l1=0,l2=0;
			for(int j=1,t=x;j<=50&&t;l1++,j++,t=pre[t])hs1[j]=(hs1[j-1]+l[t]*bas1[j-1])%P,Hs1[j]=Hs1[j-1]+l[t]*bas2[j-1];
			for(int j=1,t=y;j<=50&&t;l2++,j++,t=nxt[t])hs2[j]=(hs2[j-1]*13+l[t])%P,Hs2[j]=Hs2[j-1]*137+l[t];
			for(int l=2;l<=50&&l<=l1+l2;l++)
				for(int j=1;j<l&&j<=l1;j++)if(l-j<=l2)
					add(l,(1ll*hs1[j]*bas1[l-j]+hs2[l-j])%P,Hs1[j]*bas2[l-j]+Hs2[l-j],1);
			nxt[x]=y,pre[y]=x;
		}
		else if(op==2){
			scanf("%d",&x);y=nxt[x];int l1=0,l2=0;
			for(int j=1,t=x;j<=50&&t;l1++,j++,t=pre[t])hs1[j]=(hs1[j-1]+l[t]*bas1[j-1])%P,Hs1[j]=Hs1[j-1]+l[t]*bas2[j-1];
			for(int j=1,t=y;j<=50&&t;l2++,j++,t=nxt[t])hs2[j]=(hs2[j-1]*13+l[t])%P,Hs2[j]=Hs2[j-1]*137+l[t];
			for(int l=2;l<=50&&l<=l1+l2;l++)
				for(int j=1;j<l&&j<=l1;j++)if(l-j<=l2)
					add(l,(1ll*hs1[j]*bas1[l-j]+hs2[l-j])%P,Hs1[j]*bas2[l-j]+Hs2[l-j],-1);
			nxt[x]=0,pre[y]=0;
		}
		else {
			scanf("%s %d",s+1,&k);int ans=1,h1=0,len=strlen(s+1);ull h2=0;
			for(int i=1;i<=k;i++)h1=(h1*13+s[i]-'0')%P,h2=h2*137+s[i]-'0';
			for(int i=k;i<=len;i++){
				ans=1ll*ans*query(k,h1,h2)%P2;
				if(ans==0)break;
				h1=((h1-1ll*(s[i-k+1]-'0')*bas1[k-1]%P+P)*13+(s[i+1]-'0'))%P;
				h2=(h2-(s[i-k+1]-'0')*bas2[k-1])*137+s[i+1]-'0';
			}
			printf("%d\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：Ameyax (赞：18)

用字符串哈希，链表暴力模拟字符串的拆分合并，因为询问的$k$很小，每次修改不会超过$k^2$个值，查询就很简单了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define LL long long
#define ULL unsigned long long
int read()
{
    int x = 0, f = 1; char ch = getchar();
    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
    while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}
const int MAX_N = 550000;
const int MAX_K = 51;
const int p = 19260817;
const int mod = 998244353;
int n, m, q, a[MAX_N], pre[MAX_N], nxt[MAX_N], cnt[MAX_N], f[MAX_K * 2 + 10];
ULL g[MAX_K * 2 + 10], bin[MAX_K * 2];
const int MOD = (1 << 24) - 1;
struct Hash
{
    struct edge
    {
        ULL x;
        int cnt, nxt;
    } e[21000000];
    int fir[MOD + 1], cnt_e;
    void add(ULL x, int d)
    {
        int u = (x & MOD);
        for (int i = fir[u]; i; i = e[i].nxt)
            if (e[i].x == x)
            {
                e[i].cnt += d;
                return ;
            }
        e[++cnt_e] = (edge) { x, d, fir[u] }; fir[u] = cnt_e;
    }
    int query(ULL x)
    {
        int u = (x & MOD);
        for (int i = fir[u]; i; i = e[i].nxt)
            if (e[i].x == x)
                return e[i].cnt;
        return 0;
    }
} hash;
void merge()
{
    int x = read(), y = read();
    memset(f, 0, sizeof f);
    int L = MAX_K, R = L - 1;
    for (int i = x; i && L > 1; i = pre[i])
        f[--L] = a[i];
    for (int i = y; i && R + 1 < MAX_K * 2; i = nxt[i])
        f[++R] = a[i];
    for (int i = 1; i <= R; i++)
        g[i] = g[i - 1] * p + f[i];
    for (int i = L; i < MAX_K; i++)
        for (int j = MAX_K; j <= min(R, i + 49); j++)
            hash.add(g[j] - g[i - 1] * bin[j - i + 1], 1);
    nxt[x] = y, pre[y] = x;
}
void split()
{
    int x = read(), y = nxt[x];
    memset(f, 0, sizeof f);
    int L = MAX_K, R = L - 1;
    for (int i = x; i && L > 1; i = pre[i])
        f[--L] = a[i];
    for (int i = y; i && R + 1 < MAX_K * 2; i = nxt[i])
        f[++R] = a[i];
    for (int i = 1; i <= R; i++)
        g[i] = g[i - 1] * p + f[i];
    for (int i = L; i < MAX_K; i++)
        for (int j = MAX_K; j <= min(R, i + 49); j++)
            hash.add(g[j] - g[i - 1] * bin[j - i + 1], -1);
    nxt[x] = pre[y] = 0;
}
char s[11000000];
int query()
{
    scanf("%s", s + 1);
    int k = read(), ans = 1, n = strlen(s + 1);
    ULL val = 0;
    if (k == 1)
        for (int i = 1; i <= n; i++)
            ans = ((LL)ans * cnt[s[i]]) % mod;
    else for (int i = 1; i <= n; i++)
    {
        val = val * p + s[i];
        if (i > k) val -= bin[k] * s[i - k];
        if (i >= k) ans = ((LL)ans * hash.query(val)) % mod;
    }
    return ans;
}
int main()
{
    int n = read(), q = read();
    bin[0] = 1;
    for (int i = 1; i < MAX_K; i++) bin[i] = bin[i - 1] * p;
    for (int i = 1; i <= n; i++) cnt[a[i] = read() + '0'] ++;
    while (q --)
    {
        int opt = read();
        if (opt == 1) merge();
        else if (opt == 2) split();
        else printf("%d\n", query());
    }
    return 0;
}
```

---

## 作者：xuyiyang (赞：9)

### Solution
考虑在每次操作实时维护 $f(t)$。发现 $k$ 很小，且字符串合并分裂只涉及到 $k^2$ 级别的字符串，于是可以在分裂合并时暴力遍历计算答案。

直接用字符串哈希维护即可。区间合并和分裂怎么维护？~~FHQ!~~ 最开始想到平衡树合并，后来发现只用链表就可以了。 

由于哈希值很大，于是外面的桶要手写哈希，`map` 带 $\log$ 会超时。查询时不能 $k \lvert S \rvert$，所以直接维护 $[1:i-k]$ 和 $[1:i]$ 的哈希减一下即可。由于 $c \le 1000$，如果只有一段，那么子串只有 $nk$ 个，所以合并总复杂度若不重复遍历则为 $O(nk)$。分裂是 $O(ck^2)$ 的，所以总时间复杂度 $O(nk+ck^2+\sum \lvert S \rvert)$，空间复杂度 $O(n +\lvert S \rvert)$，可以通过。但其实我的代码是 $O(nk^2+\sum \lvert S \rvert )$ 的，做到 $O(nk)$ 只要预处理下前 $k$ 个和后 $k$ 个的哈希接起来即可。~~但也 AC 了。~~
### Code
```cpp
#include <bits/stdc++.h>

using namespace std;

using LL = long long;
using PII = pair<int, int>;
using PLL = pair<LL, LL>;
using ULL = unsigned long long;

#define ppc(x) __builtin_popcount(x)
#define clz(x) __builtin_clz(x)

bool Mbe;

//template above

const int N = 2e5 + 10, M = 1e7 + 10, Size = 1e6 + 3, mod = 998244353;

inline void read(int &s)
{
	s = 0; char c = getchar();
	while (c < 48 || c > 57) c = getchar();
	while (c >= 48 && c <= 57) s = (s << 3) + (s << 1) + (c ^ 48), c = getchar(); 	
}

int n, m;
char s[M];
int l[N], r[N];
int a[N];

struct Hash
{
	struct Edge { ULL v; int w, nxt; } e[N * 55];
	int h[Size + 10], idx;
	int &operator [] (ULL v)
	{
		for (int i = h[v % Size]; i; i = e[i].nxt)
			if (e[i].v == v) return e[i].w;
		e[ ++ idx] = {v, 0, h[v % Size]}; h[v % Size] = idx;
		return e[idx].w;
	}
} S;

void solve()
{
	read(n), read(m);
	for (int i = 1; i <= n; i ++ ) read(a[i]);
	for (int i = 1; i <= n; i ++ ) l[i] = r[i] = -1, S[a[i]] ++ ;
	while (m -- )
	{
		int op, x, y; scanf("%d", &op);
		if (op == 1)
		{
			scanf("%d%d", &x, &y);
			r[x] = y, l[y] = x; 
			int w = x;
			for (int _ = 1; _ < 50; _ ++ ) if (~l[w]) w = l[w];
			while (w != y) // 暴力循环维护 f(t)
			{
				int len = 0, nw = w; ULL v = 0;
				bool f = 0;
				while (~nw)
				{
					v = v * 10 + a[nw]; len ++ ;
					if (len > 50) break ;
					if (nw == y) f = 1;
					if (f) S[v] ++ ; nw = r[nw];
				}
				w = r[w];
			}
		}
		else if (op == 2)
		{
			scanf("%d", &x); y = r[x];
			int w = x;
			for (int _ = 1; _ < 50; _ ++ ) if (~l[w]) w = l[w];
			while (w != y)
			{
				int len = 0, nw = w; ULL v = 0;
				bool f = 0;
				while (~nw)
				{
					v = v * 10 + a[nw]; len ++ ;
					if (len > 50) break ;
					if (nw == y) f = 1;
					if (f) S[v] -- ; nw = r[nw]; // 分裂减去贡献
				}
				w = r[w];
			}
			r[x] = -1, l[y] = -1;
		}
		else
		{
			int k; scanf("%s%d", s + 1, &k); int len = strlen(s + 1);
			int res = 1; ULL p = 1; for (int _ = 1; _ <= k; _ ++ ) p *= 10;
			ULL hl = 0, hr = 0;
			for (int i = 1; i <= k; i ++ ) hr = hr * 10 + (s[i] - '0');
			for (int i = k; i <= len; i ++ )
			{
				res = (LL)res * S[hr - hl * p] % mod;
				if (i < len) hr = hr * 10 + (s[i + 1] - '0');
				hl = hl * 10 + (s[i - k + 1] - '0'); // 前后滚动 Hash 计算答案
			}
			printf("%d\n", res);
		}
	}
}
 
bool Med;
int main()
{
	fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
	#ifdef xuyiyang
		freopen(".in", "r", stdin); freopen(".out", "w", stdout);
	#endif

	int T = 1;
	while (T -- ) solve();

	fprintf(stderr, "%.3lf ms\n", 1e3 * clock() / CLOCKS_PER_SEC);
	return 0;
}
```

---

## 作者：__Hacheylight__ (赞：7)

题目就是要求我们能够支持三个操作：

1.把两个字符串合并

2.把两个字符串分裂

3.询问有多少一些个串是这么多串中出现了多少次

我们发现数据范围中的$K$很小，于是我们就考虑出题人为什么$K$这么小

这样的话需要匹配的字符串的长度最长就只有$K$了

于是我们发现第3中操作可以通过哈希表解决，哈希表只需要存储长度$<=K$的子串的哈希值即可（哈希表就是挂链就行了）

我们思考，两个字符串$a,b$合并会增加哪些哈希值？ 其实就是那些即有$a$的部分又有$b$部分的子串。 这样的串有多少个？可能有很多，但是我们记录的最多有$K^2$个。

分裂？不也是一样的么，就是把那些即有$a$的部分又有$b$部分的子串的哈希值从哈希表中移除

对于第三种，只需要$O(|S|)$的枚举串一遍，然后滚动哈希一下不就行了么

有应为$\sum{|S}|<=10^7$，所以总时间复杂度大概就是$O(10^7+MK^2)=>O(MK^2)$

最好用读入优化，防止TLE

打代码的难度还是有的，大家加油吧

代码如下

```cpp
#include <bits/stdc++.h>
using namespace std ;
#define rep(i, a, b) for (int (i) = (a); (i) <= (b); (i)++)
#define per(i, a, b) for (int (i) = (a); (i) >= (b); (i)--)
#define clr(a) memset(a, 0, sizeof(a))
#define ass(a, sum) memset(a, sum, sizeof(a))
#define lowbit(x) (x & -x)
#define mp make_pair
#define pb push_back
#define fi first
#define se second
#define enter cout << endl
#define siz(x) ((int)x.size())
typedef long long ll ;
typedef unsigned long long ull ;
typedef vector <int> vi ;
typedef pair <int, int> pii ;
typedef map <int, int> mii ;
typedef map <string, int> msi ;
const int N = 200010 ;
const int M = 20000000 ;
const int P = 10000009 ;
const int K = 50 ;
const int INF = 0x3f3f3f3f ;
const int iinf = 1 << 30 ;
const ll linf = 2e18 ;
const int MOD = 998244353 ;
const ull bs = 7 ;
void print(int x) { cout << x << endl ; exit(0) ; }
void PRINT(string x) { cout << x << endl ; exit(0) ; }
void douout(double x){ printf("%lf\n", x + 0.0000000001) ; }

namespace io {
    const int BUFSIZE = 1 << 20 ;
    char ibuf[BUFSIZE], *is = ibuf, *it = ibuf ;
    char readc() {
        if (is == it) it = (is = ibuf) + fread(ibuf, 1, BUFSIZE, stdin) ;
        return *is++ ;
    }
    int readi() {
        int x = 0, f = 1 ;
        char c = readc() ;
        while (!isdigit(c)) {
            if (c == '-') f = -1 ;
            c = readc() ;
        }
        while (isdigit(c)) {
            x = x * 10 + c - '0' ;
            c = readc() ;
        }
        return x * f ;
    }
}

using io::readc ;
using io::readi ;

struct Hash_table {
    int tot, head[P], nxt[M], val[M] ; ull to[M] ;
    void modify(ull x, int sum) {
        int ind = x % P ;
        for (int i = head[ind]; i; i = nxt[i]) // link
        if (to[i] == x){ // appeared
            val[i] += sum ;
            return ;
        }
        to[++tot] = x ; // first appear, push into the hash table
        nxt[tot] = head[ind] ;
        val[tot] = sum ;
        head[ind] = tot ;
    }
    int query(ull x) {
        for (int i = head[x % P]; i; i = nxt[i]) if (to[i] == x) return val[i] ; // find
        return 0 ; // not find
    }
} Hash ;

int n, m ;
int pre[N], suf[N], str[N], s[M] ;
ull pw[N] ;

signed main(){
    n = readi() ; m = readi() ;
    for (int i = 1; i <= n; i++) {
        str[i] = readi() ;
        Hash.modify(str[i], 1) ;
    }
    pw[0] = 1 ; for (int i = 1; i <= K; i++) pw[i] = pw[i - 1] * bs ;
    while (m--) {
        int ty = readi(), k ;
        if (ty == 1) {
            int x = readi(), y = readi() ; 
            ull now = 0 ;
            pre[y] = x, suf[x] = y ; // change link
            for (int i = x, p = 1; i && p <= K; i = pre[i], p++) {
                ull hqg = now += pw[p - 1] * str[i] ;
                for (int j = y, q = p + 1; j && q <= K; j = suf[j], q++) {
                    hqg = hqg * bs + str[j] ;
                    Hash.modify(hqg, 1) ;
                }
            }
        } else
        if (ty == 2) {
            int x = readi(), y ; y = suf[x] ;
            ull now = 0 ;
            pre[y] = suf[x] = 0 ;
            for (int i = x, p = 1; i && p <= K; i = pre[i], p++) {
            	ull hqg = now += pw[p - 1] * str[i] ;
            	for (int j = y, q = p + 1; j && q <= K; j = suf[j], q++) {
                    hqg = hqg * bs + str[j] ;
                    Hash.modify(hqg, -1) ;
                }
            }
        } else {
            char c = readc() ;
            while (!isdigit(c)) c = readc() ;
            int len = 0 ;
            while (isdigit(c)) s[len++] = c - '0', c = readc() ;
            k = readi() ;
            ull now = 0, ans = 1 ;
            for (int i = 0; i < len; i++) {
                now = now * bs + s[i] ;
                if (i >= k - 1) {
                    ans = ans * Hash.query(now) % MOD ;
                    now -= pw[k - 1] * s[i - k + 1] ;
                }
            }
            printf("%llu\n", ans) ;
        }
    }
    return 0 ;
}

```

---

## 作者：seajupiter (赞：7)

看到题解不多蒟蒻就来凑个数~

**算法：哈希**（似乎真的就只用这个？）

做这道题，你至少应该会哈希或者是 trie 的一种（做 NOI 的题真的不会哈希？），下面讲哈希解法。

对于这种题面巨长无比，数据范围极为磅礴的题，我们应该这样去解……

# 一、理清题意

简单地说就是最开始有一些长度为一的字符串，需要支持三种操作：

- 拼接两段字符串

- 分裂两段字符串

- 给定字符串 $s$ 和整数 $k$ , 对于 $s$ 的每一个长度为 $k$ 的子串 $s'$，求所有的字符串的所有子串中与 $s'$ 相等的个数。

然后开始思考各种算法：SAM、AC自动机、trie……怎么好像都不行啊？！

# 二、观察数据范围

其实连那张表都不用看，这道题只要看总数据范围就好了。$k\leq 50$ ？？一个~~狡猾~~有效的方法：暴力。

直接维护出所有字符串的所有长度 50 以内的子串，链表暴力维护拼接和分裂，每一次计算拼接新产生的子串，或是分裂导致消失的子串。

对于子串的匹配我们可以想到用哈希，那么相当于要询问哈希值为某一个数的子串个数。值域太大开不了桶？在来一个哈希（~~哈希套哈希~~）。

# 三、写代码

那么可以开始写了，感觉代码也不是很难写，毕竟字符串滚动哈希和哈希表对于 NOI 选手来说应该算是很基础的东西了，即使是想笔者一样的蒟蒻也可以在 1h 内写出 88 分代码。

# 四、调整

然而交上去发现 TLE 了（如果是考场上就有点惨，没机会了），那么首先想到就是哈希表时间复杂度的问题。

一般来讲哈希表模数开大一点会更快，注意别MLE前提下开成大一点的质数就好。

那么我把模数改到 $5056577$ 的时候就AC了。

下面是代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef unsigned long long ull;

inline void read(int& x){
	char c=getchar();x=0;
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=x*10+c-'0',c=getchar();
}
inline int read(char *s){
	char c=getchar(); int len=0;
	while(!isdigit(c))c=getchar();
	while(isdigit(c))s[len++]=c,c=getchar();s[len]='\0';
	return len;
}

const int HASH_MOD=5056577, STA=1e7+5;
struct Hash_Table{
	int tot, hd[HASH_MOD+5], cnt[STA], nxt[STA];
	ull sta[STA];
	inline void mdf(ull _sta, int v){
		int res=_sta%HASH_MOD;
		for(int u=hd[res]; u; u=nxt[u]) if(sta[u]==_sta)
			return (void)(cnt[u]+=v);
		sta[++tot]=_sta, cnt[tot]=v;
		nxt[tot]=hd[res], hd[res]=tot;
	}
	inline int qry(ull _sta){
		int res=_sta%HASH_MOD;
		for(int u=hd[res]; u; u=nxt[u]) if(sta[u]==_sta)
			return cnt[u];
		return 0;
	}
}H;

const int N=2e5+5, K=55, LEN=1e7+5, Base=131, mod=998244353;

ull bin[K];
int n, m, a[N], lst[N], nxt[N], cnt[10];
char s[LEN];

inline void merge(int x, int y){
	nxt[x]=y, lst[y]=x;
	for(int k=2; k<=50; ++k){
		int l=0, r=0;
		for(int i=x; i&&l<k-1; i=lst[i]) ++l;
		for(int i=y; i&&l+r<k; i=nxt[i]) ++r;
		if(l+r<k) break;
		l=x;
		for(int i=1; i<=k-2&&lst[l]; ++i)
			l=lst[l];
		r=l;
		ull hash=0;
		for(int i=1; i<=k; ++i){
			hash=hash*Base+a[r];
			r=nxt[r];
		}
		while(true){
			H.mdf(hash, 1);
			if(l==x||!r) break;
			hash-=a[l]*bin[k-1];
			l=nxt[l];
			hash=hash*Base+a[r];
			r=nxt[r];
		}
	}
}
inline void split(int x, int y){
	for(int k=2; k<=50; ++k){
		int l=0, r=0;
		for(int i=x; i&&l<k-1; i=lst[i]) ++l;
		for(int i=y; i&&l+r<k; i=nxt[i]) ++r;
		if(l+r<k) break;
		l=x;
		for(int i=1; i<=k-2&&lst[l]; ++i)
			l=lst[l];
		r=l;
		ull hash=0;
		for(int i=1; i<=k; ++i){
			hash=hash*Base+a[r];
			r=nxt[r];
		}
		while(true){
			H.mdf(hash, -1);
			if(l==x||!r) break;
			hash-=a[l]*bin[k-1];
			l=nxt[l];
			hash=hash*Base+a[r];
			r=nxt[r];
		}
	}
	nxt[x]=lst[y]=0;
}
inline int query(char *s, int n, int k){
	int ans=1;
	if(k==1){
		for(int i=1; i<=n; ++i)
			ans=1ll*ans*cnt[s[i]-'0']%mod;
		return ans;
	}
	ull hash=0;
	for(int i=1; i<=k; ++i)
		hash=hash*Base+s[i]-'0';
	int l=1, r=k+1;
	while(true){
		ans=1ll*ans*H.qry(hash)%mod;
		if(r>n||!ans) break;
		hash-=(s[l++]-'0')*bin[k-1];
		hash=hash*Base+s[r++]-'0';
	}
	return ans;
}

int main(){
	bin[0]=1;
	for(int i=1; i<K; ++i)
		bin[i]=bin[i-1]*Base;

	read(n);read(m);
	for(int i=1; i<=n; ++i){
		read(a[i]);
		++cnt[a[i]];
	}

	while(m--){
		int op, x, y, k;
		read(op);
		if(op==1){
			read(x);read(y);
			merge(x, y);
		}
		else if(op==2){
			read(x);
			split(x, nxt[x]);
		}
		else{
			x=read(s+1);read(k);
			printf("%d\n", query(s, x, k));
		}
	}

	return 0;
}
```

那么这题就做完了，感觉难度有些虚高（~~我才不会告诉你们我写NOI2017 d1t1整数的时候因为一个沙雕的+1调了3h呢~~），比 d1t1整数 更像是NOI2017的签到题？。

---

## 作者：luobotianle (赞：4)

这道题的思路还是很显然的，由于 $k \le 50$，直接用链表暴力维护拆分合并，同时实时计算；而对于维护每种串的个数，用一个哈希表维护即可，最后乘起来就好了。由于 $c \le 1000$，总时间复杂度为 $O(nk + ck^2 + \sum |s|)$。

于是行云流水地用 1h 打完代码加调试，然后直接提交...

**TLE。**

嘶...复杂度没算错啊？

卡常！

于是又卡了半个小时常后，看着 92分 TLE on #24 #25 的代码，一个念头突然出现在我的脑海中：

**map** 模拟哈希表是 $O(logn)$ 的，**unordered_map** 极限情况甚至是 $O(n)$。

看了一圈题解，好像全是手写哈希表，蒟蒻之前一直用 map 水的啊怎么办...

上网找了一圈，发现了新的~~奇技淫巧~~STL：

**平板电视（pb_ds）**，里面自带哈希表和一堆别的数据结构，具体可以看[这里](https://oi-wiki.org//lang/pb-ds/)；

然后就把代码的 **unordered_map** 改成了 **gp_hash_table**，然后就成功~~水~~过了这道紫题。

附上本题中各 STL 的表现：
| STL | 结果 | 得分 |
| :-----------: | :-----------: | :-----------: |
| map | TLE | 60 |
| unordered_map | TLE | 92 |
| cc_hash_table | TLE | 96 |
| gp_hash_table | AC | 100 |

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
typedef unsigned long long ull;
const int N=1e6+5;
const int p=131;
const int mod=998244353;
char s[N][10],lson[105],ask[N];
ull n,m,op,x,y;
ull pp[N],hs[N],hs1[N];
ull nxt[N],pre[N];
gp_hash_table<ull,ull> cnt;
inline ull read(){
	ull x=0;
	char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x;
}
inline void workhash(char s[],ull hs[],int len){
	hs[0]=0;
	for(int i=1;i<=len;i++)hs[i]=hs[i-1]*p+s[i];
}
inline ull gethash(ull l,ull r,ull hs[]){
	return hs[r]-hs[l-1]*pp[r-l+1];
}
inline void merge(ull x,ull y){
	nxt[x]=y;
	pre[y]=x;
	memset(lson,0,sizeof(lson));
	ull l=49,r=50;
	for(register int i=x;i&&l>=1;i=pre[i],l--)lson[l]=s[i][1];
	l++;
	for(register int i=y;i&&r<=98;i=nxt[i],r++)lson[r]=s[i][1];
	r--;
	workhash(lson,hs1,r);
	for(register int i=l;i<=49;i++){
		for(register unsigned int len=51-i;len<=min(50ull,r-i+1);len++){
			cnt[gethash(i,i+len-1,hs1)]++;
		}
	}
}
inline void split(ull x){
	y=nxt[x];
	nxt[x]=pre[y]=0;
	ull l=49,r=50;
	for(register int i=x;i&&l>=1;i=pre[i],l--)lson[l]=s[i][1];
	l++;
	for(register int i=y;i&&r<=98;i=nxt[i],r++)lson[r]=s[i][1];
	r--;
	workhash(lson,hs1,r);
	for(register int i=l;i<=49;i++){
		for(register unsigned int len=51-i;len<=min(50ull,r-i+1);len++){
			cnt[gethash(i,i+len-1,hs1)]--;
		}
	}
}
int main(){
	n=read();m=read();
	pp[0]=1;
	for(register int i=1;i<=N-1;i++)pp[i]=pp[i-1]*p;
	for(register unsigned int i=1;i<=n;i++){
		scanf("%s",s[i]+1);
		int len=strlen(s[i]+1);
		workhash(s[i],hs,len);
		cnt[gethash(1,len,hs)]++;
	}
	while(m--){
		op=read();
		if(op==1){
			x=read();y=read();
			merge(x,y);
		}
		else if(op==2){
			x=read();
			split(x);
		}
		else{
			scanf("%s",ask+1);
			x=read();
			int len=strlen(ask+1);
			workhash(ask,hs1,len);
			ull ans=1;
			for(register int i=x;i<=len;i++)ans=ans*cnt[gethash(i-x+1,i,hs1)]%mod;
			printf("%lld\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：Nights_watcher (赞：3)

前置知识：[哈希表](https://blog.csdn.net/qq_44443986/article/details/117195803)\
注意到 $s$ 的长度很长，要用字符串输入，就可以想到字符串哈希

注意到 $k\le50$，我们就可以统计一下每个队伍里面长度不超过 $50$ 的字符串的哈希值，这样就可以用哈希表了。

我们只需要在两个队伍合并时用哈希表统计一下所有新增的哈希值，分开两个队伍时用哈希表统计一下所有减去的哈希值，每次通过哈希表查询一下这个哈希值出现了多少次，就可以了。可以用开散列解决哈希冲突。注意：要用快读。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ull unsigned long long
#define ll long long
const ull k = 131 , modhash = 10000019 , maxn = 1e7 + 5 , mod = 998244353;
int n , m , fa[200005] , son[200005];
ull jc[200005] = {1} , a[200005] , hashs[200005];
struct hash_table
{
	int cnt , head[modhash] , nxt[maxn];
	ull value[maxn];
	ll sl[maxn];
	inline void add (ull hashvalue , int v)
	{
		int tb = hashvalue % modhash;
		for (int i = head[tb];i;i = nxt[i])
			if(value[i] == hashvalue)
			{
				sl[i] = (sl[i] + v) % mod;
				return;
			}
		value[++ cnt] = hashvalue;
		sl[cnt] ++;
		nxt[cnt] = head[tb];
		head[tb] = cnt;
	}
	inline ll query (ull hashvalue)
	{
		int tb = hashvalue % modhash;
		for (int i = head[tb];i;i = nxt[i])
			if(value[i] == hashvalue) return sl[i];
		return 0ll;
	}
}Hash;
inline int read ()
{
	int x = 0;
	char c = getchar ();
	while (c < '0' || c > '9') c = getchar ();
	while ('0' <= c && c <= '9')
	{
		x = (x << 1) + (x << 3) + (c ^ 48);
		c = getchar ();
	}
	return x;
}
inline string readstr ()
{
	char c = getchar ();
	string ans = "";
	while (c == ' ' || c == '\n') c = getchar ();
	while (c != ' ' && c != '\n')
	{
		ans += c;
		c = getchar ();
	}
	return ans;
}
inline void write (ll s)
{
	if (s > 9) write (s / 10);
	putchar (s % 10 + '0');
}
inline void merge (int u , int v)
{
	son[u] = v;
	fa[v] = u;
	ull hashh = 0;
	for (int i = u , len = 1;i && len <= 50;i = fa[i] , len ++)
	{
		hashh += a[i] * jc[len - 1];
		ull hash2 = hashh;
		for (int j = v , len2 = len + 1;j && len2 <= 50;j = son[j] , len2 ++)
		{
			hash2 = hash2 * k + a[j];
			Hash.add (hash2 , 1);
		}
	}
}
inline void cut (int u , int v)
{
	son[u] = fa[v] = 0;
	ull hashh = 0;
	for (int i = u , len = 1;i && len <= 50;i = fa[i] , len ++)
	{
		hashh += a[i] * jc[len - 1];
		ull hash2 = hashh;
		for (int j = v , len2 = len + 1;j && len2 <= 50;j = son[j] , len2 ++)
		{
			hash2 = hash2 * k + a[j];
			Hash.add (hash2 , -1);
		}
	}
}
int main ()
{
	n = read ();
	m = read ();
	for (int i = 1;i <= n;i ++) a[i] = read ();
	for (int i = 1;i <= n;i ++) Hash.add (a[i] , 1);
	for (int i = 1;i <= 200000;i ++) jc[i] = jc[i - 1] * k;
	while (m --)
	{
		int opt = read ();
		if (opt == 1)
		{
			int u = read () , v = read ();
			merge (u , v);
		}
		else if (opt == 2)
		{
			int u = read ();
			cut (u , son[u]);
		}
		else
		{
			string s = readstr ();
			int kk = read () , len = s.size ();
			for (int i = 1;i <= len;i ++) hashs[i] = hashs[i - 1] * k + s[i - 1] - '0';
			ll ans = 1;
			for (int i = kk;i <= len;i ++) (ans *= Hash.query (hashs[i] - hashs[i - kk] * jc[kk])) %= mod;
			write (ans);
			putchar ('\n');
		}
	}
}
```
引用：CSDN博客

---

## 作者：cloud2764scallop_eve (赞：3)

## [题目传送门：P3823 [NOI2017] 蚯蚓排队](https://www.luogu.com.cn/problem/P3823)
## 题意 
操作一：使蚯蚓 $j$ 及其所在队伍后面的所有蚯蚓全部排在蚯蚓 $i$ 后，即蚯蚓 $j$ 在队伍中的位置变为 $i + 1$，后面的以此类推。  
操作二：使蚯蚓 $i + 1$ 变为新的一队，即蚯蚓 $i + 1$ 在队伍中的位置变为 $1$。  
操作三：给定字符串 $s$ 和一个整数 $k$，对于 $s$ 每个长度为 $k$ 的子串 $s'$，求所有字符串的所有子串中与 $s'$ 相等的子串的数量。  

## 思路
看完题，明显是哈希来求解，~~毕竟是哈希题单的题~~。此时注意数据范围，$k \le 50$。秉持着从小数据入手的原则，明显可以发现有可能可以暴力。  
那么暴力的思路应该为：用一个链表维护子串的合并/断裂操作，使用哈希做查询操作。  
由于每次的操作只会影响到 $k$ 只蚯蚓的哈希值，所以每次更新的时间复杂度应为 $O(k^2)$。  
鉴于 $k$ 较小的数据，直接建一张关键字为哈希值的哈希表，使用哈希表查询即可。  

## 代码
```cpp
#include <bits/stdc++.h>
#define ull unsigned long long
using namespace std;
const int maxn = 2e5 + 5, q = 131, mod = 998244353, Hash_mod = 19260817, maxs = 1e7 + 5;
ull p[maxn], a[maxn], nxt[maxn], pre[maxn];
char str[maxs];
inline int read() {
	int x = 0, f = 1;
	char c;
	c = getchar();
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
		x = x * 10 + c - '0', c = getchar();
	return x * f;
}
struct Hash_table {
	ull head[Hash_mod], nxt[maxs], len[maxs], val[maxs], tot = 0, s[maxs];
	void add(ull S, int l, int v) {
		int tmp = S % Hash_mod;
		for (int i = head[tmp]; i; i = nxt[i])
			if (len[i] == l && s[i] == S) {
				val[i] = (val[i] + v) % mod;
				return ;
			}
		len[++tot] = l, val[tot] = v, s[tot] = S, nxt[tot] = head[tmp], head[tmp] = tot;
	}
	int query(ull S, int l) {
		int tmp = S % Hash_mod ;
		for (int i = head[tmp]; i; i = nxt[i])
			if (len[i] == l && s[i] == S) return val[i];
		return 0;
	}
} Hash;
void link(int x, int y) {
	nxt[x] = y, pre[y] = x;
	ull pres = 0;
	int tot = 0, len = 49;
	for (int i = x; i && len; i = pre[i]) {
		pres += a[i] * p[tot++] ;
		ull s = pres, l = tot + 1;
		for (int j = y; j && l <= 50; j = nxt[j], l++) {
			s = s * q + a[j];
			Hash.add(s, l, 1);
		}
		len--;
	}
}
void cut(int x) {
	int y = nxt[x], tot = 0, len = 49;
	ull pres = 0;
	for (int i = x; i && len; i = pre[i]) {
		pres += a[i] * p[tot++];
		ull s = pres, l = tot + 1;
		for (int j = y; j && l <= 50; j = nxt[j], l++) {
			s = s * q + a[j];
			Hash.add(s, l, mod - 1);
		}
		len--;
	}
	nxt[x] = pre[y] = 0;
}
int query(int k) {
	ull s = 0;
	int len = strlen(str + 1), res = 1;
	str[0] = '0';
	for (int i = 1; i < k; i++)
		s = s * q + str[i] - '0';
	for (int i = k; i <= len; i++) {
		s = s * q + str[i] - '0' - p[k] * (str[i - k] - '0');
		res = 1ll * res * Hash.query(s, k) % mod;
	}
	return res;
}
int main() {
	int n = read(), m = read();
	for (int i = 1; i <= n; i++) {
		a[i] = read();
		Hash.add(a[i], 1, 1);
	}
	p[0] = 1;
	for (int i = 1; i <= n; i++)
		p[i] = p[i - 1] * q;
	while (m--) {
		int op = read();
		if (op == 1) {
			int x = read(), y = read();
			link(x, y);
		}
		if (op == 2) {
			int x = read();
			cut(x);
		}
		if (op == 3) {
			scanf("%s", str + 1);
			int k = read();
			printf("%d\n", query(k));
		}
	}
	return 0;
}
```
> 注意：一定要用 `usigned long long`

---

## 作者：WeLikeStudying (赞：2)

**哈希**
- 思路主要是把字符串当成数看待。
- 常用的编码是：
$$\sum_{i=0}^na_ib^i\bmod p$$
- 然后忽略可能的冲突。（？根据生日攻击，首次冲突的次数可能是 $\sqrt n$ 级别的）
- 如果愿意可以使用双哈希。
- 常见模数：
$$19260817$$
$$33333331$$
$$23252729$$
$$998244353$$
$$10^9+7$$
$$9223372036854775783(?$$

**哈希表**
- 与哈希的思想类似，但不同的是我们必须开一个跟模数 $p$ 同规模的表，冲突不可避免。
- 放一张以前写杜老师筛法时打的代码（最朴素的线性寻址，被证明在平均情况下接近 $O(n)$）。
![](https://cdn.luogu.com.cn/upload/image_hosting/0mdgs0fk.png)
- 其实还有很多做法，但作者这里就不介绍了，不过这样即使没有被针对还是有一定常数。
- 还有一个有趣的小问题：哈希表存字符串怎么办？
- 拿三个质数，规模大概分别在 $10^9,10^9,10^7$ 左右，先双哈希成长整型再放进哈希表（感觉很迷）。

**例题**
- 由于内容并不多居然在这里开例题了！
- [例题](https://www.luogu.com.cn/problem/P3823)。
- 题意简述：给定 $n$ 个字符，支持 $3$ 个操作：合并字符串，分离字符串，统计所有字符串中，与 $s$ 有相同的长度为 $k$ 字串的串的个数，$k\le 50$。
- 其实就是哈希表存字符串的实际应用了。
- 所以很水了，但作者发现自己并不会链表 QWQ。
- 时间复杂度毛估估大概是 $O(nk+ck^2+\sum|s|)$，卡常后可以通过此题。
- 然后并没有卡常就过了。。（但作者向左和向右延伸的 $l$ 和 $r$ 看错了，作者调试的时候脑袋需要转一下啊）。
- [代码实现](https://www.luogu.com.cn/paste/3lta6im2)。

---

## 作者：gongbangrui (赞：2)


题意
------------

给定n条长度不超过6的蚯蚓，初始各自在一个队伍。m次操作：1.将i号蚯蚓和j号蚯蚓的队伍合并（保证i为队尾，j为队首）。2.将i号蚯蚓和它后面的蚯蚓分离成两个队。3.询问：给定字符串S和正整数k，求f(每个长度为k的子串)的乘积。其中f(S)定义为蚯蚓在其队伍向后延伸k位组成的字符串等于S的蚯蚓个数。\(n \leq 2*10^5,m \leq 5*10^5,k \leq 50,\sum |s| \leq 10^7,c \leq 10^3\)，其中c为操作2的数量。


算法分析
------------

模拟+hash
暴力一点考虑，每个队伍维护一条链，合并和分裂时维护\(c_{x,i}\)表示第x号蚯蚓向后延伸i位的字符串hash值并更新长度为i的答案，查询的时候直接枚举子串访问长度为i的答案中hash值相同的。
容易知道这样最坏复杂度是\(O(mk^2+\sum |s|)\)，理论上依然无法通过。

继续分析。
考虑分离操作至多c次，复杂度为\(O(ck^2)\)。
考虑合并操作，因为每次合并其实显然是不需要枚举满的，是否有可能省去一个k的复杂度？合并的终串中每个子串只会被统计一次（分离只有1000次，不影响复杂度），而总共有nk个子串，所以复杂度为\(O(mk)\)。

总复杂度\(O(ck^2+mk+\sum |s|)\)。
注意：我用的hash方式是一个小哈希存邻接表，一个大哈希当成真实值来检验。


AC代码
------------

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
typedef long long ll;
const int mod=998244353;
const int P=19260817;
const int N=P+10;
const int M=2e5+5;
const int B=17;
int read()
{
  int ret=0,op=1,c=getchar();
  while(c>'9' || c<'0')
    {
      if(c=='-') op=-1;
      c=getchar();
    }
  while(c>='0' && c<='9')
    {
      ret=ret*10+c-'0';
      c=getchar();
    }
  return ret*op;
}
int ecnt=0,head[N];
int n,m;
int nxt[M],lst[M],val[M];//nxt和lst为维护蚯蚓位置的链表
ll powB[100],pow10[100],qwq[100];
char s[10000005];
struct edge
{
  int next,cnt,last;
  ll w;
}e[N];
void add(ll hash,ll q)//哈希表，如果有对于hash这个哈希值有q这个原值则cnt++，否则新开一个点
{
  //printf("add:%lld:%lld\n",hash,q);
  for(int i=head[hash];i;i=e[i].next)
    if(e[i].w==q)
      {
    e[i].cnt++;
    return ;
      }
  e[++ecnt].cnt=1;
  e[ecnt].w=q;
  e[ecnt].next=head[hash];
  head[hash]=ecnt;
}
void dlt(ll hash,ll q)//与add同理
{
  for(int i=head[hash];i;i=e[i].next)
    if(e[i].w==q)
      {
    e[i].cnt--;
    return ;
      }
}
int query(ll hash,ll q)//与add同理
{
  for(int i=head[hash];i;i=e[i].next) if(e[i].w==q) return e[i].cnt;
  return 0;
}
int s1[100],s2[100];
void link(int u,int v)
{
  int l1=0,l2=0;
  ll hsh=0,q=0,haxi=0,Q=0;
  nxt[u]=v;
  lst[v]=u;
  for(int i=u;i&&l1<49;i=lst[i])
    s1[++l1]=val[i],hsh=(hsh+val[i]*powB[l1-1])%P,q=q+val[i]*pow10[l1-1];//将u与u之前最长50的串取出来，注意在s1中的串是反着的
  for(int i=v;i&&l2<49;i=nxt[i]) s2[++l2]=val[i];
  for(int i=l1;i>=1;i--)//s1是反串，最前面的字符在l1的位置，所以倒序枚举
    {
      haxi=0;Q=0;
      for(int j=1;j<=l2&&i+j<=50;j++)
    {
      haxi=(haxi*B+s2[j])%P;
      Q=Q*10+s2[j];
      add((hsh*powB[j]%P+haxi)%P,q*pow10[j]+Q);
    }
      hsh=((hsh-powB[i-1]*s1[i])%P+P)%P;
      q=q-pow10[i-1]*s1[i];
    }
}
void cut(int u,int v)//与link同理
{
  int l1=0,l2=0;
  ll hsh=0,q=0,haxi=0,Q=0;
  nxt[u]=0;
  lst[v]=0;
  for(int i=u;i&&l1<49;i=lst[i])
    s1[++l1]=val[i],hsh=(hsh+val[i]*powB[l1-1])%P,q=q+val[i]*pow10[l1-1];
  for(int i=v;i&&l2<49;i=nxt[i]) s2[++l2]=val[i];
  for(int i=l1;i>=1;i--)
    {
      haxi=0;Q=0;
      for(int j=1;j<=l2&&i+j<=50;j++)
    {
      haxi=(haxi*B+s2[j])%P;
      Q=Q*10+s2[j];
      dlt((hsh*powB[j]%P+haxi)%P,q*pow10[j]+Q);
    }
      hsh=((hsh-powB[i-1]*s1[i])%P+P)%P;
      q=q-pow10[i-1]*s1[i];
    }
}
int main()
{
  n=read(),m=read();
  for(int i=1;i<=n;i++) val[i]=read(),qwq[val[i]]++;
  powB[0]=pow10[0]=1;
  for(int i=1;i<=50;i++) powB[i]=powB[i-1]*B%P,pow10[i]=pow10[i-1]*10;
  int op,x,y;
  while(m--)
    {
      op=read();
      if(op==1)
    {
      x=read(),y=read();
      link(x,y);
    }
      else if(op==2)
    {
      x=read();
      cut(x,nxt[x]);
    }
      else
    {
      int k;
      scanf("%s%d",s+1,&k);
      int len=strlen(s+1);
      ll hsh=0,q=0,ans=1;
      if(k==1)//特别的，如果询问长度为1的串，因为之前我也没有加过，所以在读入的时候开一个桶来统计答案
        {
          for(int i=1;i<=len;i++) ans=ans*qwq[s[i]-'0']%mod;
          printf("%lld\n",ans%mod);
          continue;
        }
      for(int i=1;i<=k;i++)
        {
          hsh=(hsh*B+s[i]-'0')%P;
          q=q*10+s[i]-'0';
        }
      // printf("(%lld)%lld->",hsh,q);
                  ans=query(hsh,q)%mod;
      for(int i=k+1;i<=len;i++)
        {
          hsh=(((hsh-(s[i-k]-'0')*powB[k-1])%P+P)%P*B+s[i]-'0')%P;
          q=((q-(s[i-k]-'0')*pow10[k-1]))*10+s[i]-'0';
          //    printf("(%lld)%lld->",hsh,q);
                ans=ans*query(hsh,q)%mod;
        }
      printf("%lld\n",ans);
    }
    }
  return 0;
}
```

---

## 作者：e_zhe (赞：1)

### 题目链接

<https://www.luogu.com.cn/problem/P3823>

### 分析

先解决队伍的合并与分离问题。使用链表结构，分别维护每只蚯蚓的前驱和后继即可。

然后考虑如何统计答案。可以对每只蚯蚓的“向后 $k$ 数字串”使用字符串哈希的方式获得哈希值，再用一个哈希表存储每个哈希值出现的次数。对于给定的数字串 $s$ 的每个长度为 $k$ 的连续子串 $t$，$f(t)$ 即为 $t$ 的哈希值在哈希表中出现的次数。

最后考虑维护每只蚯蚓的“向后 $k$ 数字串”。

- 当 $k=1$ 时，每只蚯蚓的“向后 $k$ 数字串”是它的长度。
- 当 $k \ge 2$ 时，每只蚯蚓的“向后 $k$ 数字串”只有经历蚯蚓队伍的合并才会形成，只有经历蚯蚓队伍的分离才会消失（即队伍合并是数字串产生的**必要不充分条件**，队伍分离是数字串消失的**必要不充分条件**）。具体地，当进行队伍的合并操作时，对于前方队伍中的任何一只蚯蚓，若它的“向后 $k$ 数字串”跨越了两个队伍，则这条数字串因此次合并而产生，将这个数字串的哈希值在哈希表中的出现次数 $+1$ 即可。队伍的分离操作同理。

细节内容见代码注释。

### Code

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define i64 long long
#define uns unsigned

using namespace std;
using namespace __gnu_pbds;

constexpr int N=2e5+5;
int n,m;
char s[int(1e7)+5];

namespace Solve{
	//unordered_map 太慢，使用 pbds 的哈希表 
	gp_hash_table<uns i64,int>ght;
	
	//字符串哈希 
	constexpr uns i64 p=131;
	uns i64 pw[int(1e7+5)],hsh[int(1e7+5)];
	//预处理 
	void init_pw(int n){
		pw[0]=1;
		for(int i=1;i<=n;++i)pw[i]=pw[i-1]*p;
		return;
	}
	//对整个数字串进行哈希 
	void make_hash(int n,char *s,uns i64 *hash_table){
		for(int i=1;i<=n;++i)
			hash_table[i]=hash_table[i-1]*p+s[i]-48;
		return;
	}
	//获取子串的哈希值 
	uns i64 ask_hash(int l,int r,uns i64 *hash_table){
		if(l>r)return 0;
		return hash_table[r]-hash_table[l-1]*pw[r-l+1];
	}
	
	//链表 
	struct Node{
		int pre,nxt;//指针域，前驱和后继 
		int dat;//数据域，蚯蚓的长度 
	}L[N];
	//合并 
	void Union(int p1,int p2){
		//更新指针 
		L[p1].nxt=p2,L[p2].pre=p1;
		
		//由于题目中 k<=50，拥有跨越两个队伍的数字串的蚯蚓一定不超过 50 个 
		for(int i=p1,cnt_i=50;(~i)&&(cnt_i)!=0;i=L[i].pre,--cnt_i){
			uns i64 num_str=0ull;
			bool flg=false;
			//数字串长度不超过 50 
			for(int j=i,cnt_j=50;(~j)&&(cnt_j)!=0;j=L[j].nxt,--cnt_j){
				num_str=num_str*p+L[j].dat;
				
				if(j==p2)flg=true;//开始跨越两个队伍 
				if(flg)++ght[num_str];
			}
		}
		return;
	}
	//分离 
	void Cut(int p1){
		int p2=L[p1].nxt;
		
		for(int i=p1,cnt_i=50;(~i)&&(cnt_i)!=0;i=L[i].pre,--cnt_i){
			uns i64 num_str=0ull;
			bool flg=false;
			
			for(int j=i,cnt_j=50;(~j)&&(cnt_j)!=0;j=L[j].nxt,--cnt_j){
				num_str=num_str*p+L[j].dat;
				
				if(j==p2)flg=true;
				if(flg)--ght[num_str];
			}
		}
		
		//注意，由于要更新跨越两队伍的数字串的信息，指针的更新要放在后面 
		L[p1].nxt=L[p2].pre=-1;
		return;
	}
	
	//统计答案 
	constexpr i64 mod=998244353;
	i64 ask_ans(int k,char *s){
		int len=strlen(s+1);
		make_hash(len,s,hsh);
		
		i64 ans=1;
		for(int i=k;i<=len;++i){
			ans=ans*ght[ask_hash(i-k+1,i,hsh)]%mod;
			if(ans==0)break;
		}
		
		return ans;
	}
}

using namespace Solve;

int main(){
	ios::sync_with_stdio(false),
	cin.tie(nullptr),cout.tie(nullptr);
	
	init_pw(int(1e7));
	
	cin>>n>>m;
	
	//初始化 
	for(int i=1;i<=n;++i){
		cin>>L[i].dat;
		L[i].pre=L[i].nxt=-1,++ght[L[i].dat];
	}
	
	int op,x1,x2;
	for(int id_op=1;id_op<=m;++id_op){
		cin>>op;
		
		if(op==1){
			cin>>x1>>x2;
			Union(x1,x2);
		}
		else if(op==2){
			cin>>x1;
			Cut(x1);
		}
		else{
			cin>>(s+1)>>x1;
			cout<<ask_ans(x1,s)<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：ZLCT (赞：1)

#  [NOI2017] 蚯蚓排队
## 题目描述
给定 $n$ 个数，初始各自成序列。现在给定 $n$ 次操作，每次操作可能为以下三种：
- `1 i j` 表示将 $j$ 接在 $i$ 之后，保证 $i$ 是序列结尾并且 $j$ 是序列开头。
- `2 i` 表示将 $i$ 所在序列分成从开头到 $i$ 与从 $i$ 的下一位置到结尾两个序列，保证 $i$ 不是序列结尾。
- `3 s k` 其中 $s$ 是字符串，$k$ 是不大于 $50$ 的正整数。表示求出 $s$ 中所有长度为 $k$ 的子串 $t$ 的 $f(t)$ 之积模 $998244353$ 的结果。\
$f(t)$ 表示把所有序列都看作中间无空格的字符串，序列中 $t$ 出现的次数，注意必须在同一序列内。

数据范围：$n\le 2\times 10^5,m\le 5\times 10^5,k\le 50$。\
$s$ 的总长度 $\le 10^7$。\
操作 $2$ 的数量 $\le 10^3$。
## 一个好题
这个题是一个十分优质的好题，它的每一步推导都是十分自然的，但是需要仔细阅读题目并且有一定的观察力，下面我们来一步步解决。
### 如何处理合并分离
这个题第一眼的入手条件应该是这个合并与分离，按照往常的经验，我们通常都是利用平衡树去维护序列的操作，但是我们注意这个题对于序列的操作与原编号有关，那我们就不好去利用平衡树维护了。\
如果我们做过一些数据结构，那我们又会联想到“银河英雄传说V2”这个题，那就自然想到可以利用不分虚子树的 LCT 去维护序列。\
不错，我们的确是可以利用 LCT 维护这个序列，并且复杂度肯定十分富裕，但是接下来怎么办？\
我们发现我们维护了这个序列之后无法求出答案啊。\
在经过一系列的思考过后，我们最终确定了这个方法是不可行的。\
此时如果你还停留在想用数据结构解决 `1,2` 操作中，那你大概率已经陷入数据结构的泥沼。\
实际上我们对于这种序列拆分合并问题有一个最简单的方法：链表。\
我们直接将每个 $1$ 操作的两个点用链表练起来，将每个 $2$ 操作的两个点在链表上断开不就好了吗？\
那解决完这个以后我们又回到了那个问题：如何求出答案。
### 如何求出答案
做题最关键的就是找出一切有用信息，我们观察到 $k\le 50,\sum|s|\le 10^7,\text{操作}2\text{的数量}\le 10^3$。\
俗话说事出反常必有妖，这三个独特的范围一定有什么神奇的作用。\
我们从 $k\le 50$ 看起，这就代表我们一个点最多影响前后 $50$ 个数，再换一个视角，我们一个元素为起点的子串，只取决于后面最多 $50$ 个元素。\
那这不就简单了吗？\
我们设 $f_{i,j}$ 表示以 $i$ 为起点，长度为 $j$ 的子串是什么。\
我们可以在每次 $1,2$ 操作时暴力去重新求前面 $50$ 个元素的 $f$ 值。\
那如何统计答案呢？\
注意到 $\sum|s|\le 10^7$，那我们可以直接暴力枚举 $s$ 中每个长度为 $k$ 的子串 $t$，那么 $t$ 的贡献就是 $f$ 中 $t$ 出现的次数。这个我们用个桶就可以维护。\
但是如果仅仅这样这就不是一个 NOI 题目了。\
虽然这个 $50$ 的确不大，但是那也是一个 $10^{50}$ 级别的数了，我们根本无法用常见的类型去储存。\
注意到我们每个数的值域是 $[1,6]$ 那我们可不可以利用一个 `__int128` 去把子串转化为一个六进制的数呢？\
想法很美好，可现实是 $\log_2(6^{50})=129.248…$，正好把这种做法卡掉了。\
我们注意到虽然可能的子串数量有 $6^{50}$ 种，但是我们一组测试数据里顶多只有 $50n=10^7$ 种不同子串。\
这就告诉我们可以把子串当作一个字符串，维护每个子串的 hash 值来代表该串。\
那如何求一个 hash 值出现的次数呢？这时候就不能用桶了，就要用 map 存。\
但是 map 会有一个 $\log$ 的复杂度，肯定会炸怎么办？\
我们可以用 unordered_map，其本质是一个 hash 表，所以期望复杂度是 $O(1)$ 的。
### 看似完美的解决了这个问题，但是。。。
你提交上去大概率只有四十多分，你会发现有很多点 WA 了，这是为什么呢？\
这就来自于对 hash 的认识不够准确，hash 能保证一个 hash 值对应一个字符串的根本就在于总共的字符串数比较少，而 hash 值的可能范围是在模数以内的所有数，所以才不会重复。\
但是这个题可能的子串个数刚才计算了是 $10^7$ 个，所以如果模数不大的话 hash 碰撞的概率就非常大。\
可能有人说可以双 hash，但是那样你的 unordered_map 如何存呢？unordered_map 可是无法存 `pair` 的。\
实际上我们只需要把模数开大一些就行了，例如在这题中自然溢出就是个不错的选择。\
于是我们就完成了这道题。。吗？\
你会发现交上去不 WA 了，但是 TLE 了。\
但是复杂度也没有问题啊？\
经常打 Codeforces 的同学知道，unordered_map 是可以被卡成 $O(n)$ 的，所以复杂度有时候不一定有保障。\
事情仿佛陷入了瓶颈。\
这时我突然想起前两天在讲 NOI Linux 的使用时有人提了一句 pb_ds 中有个叫 `gp_hash_table` 的东西可以上位替代 unordered_map，那抱着试一试的态度改了以后，的确可以 AC 了，并且剩余时间还比较宽裕。
### 正解写法
考虑到这是个 2017 年的题，当时还不让用 pb_ds，于是我们来介绍一下另一种解法。\
我们考虑 unordered_map 为什么会被卡，本质在于它是个 hash 表，所以当冲突次数足够多时，它的效率会极大降低。\
那么我们可以自己手写一个 hash 表，自己控制它的各种参数使得冲突概率尽可能的低，但是由于我不会手写 hash 表，所以也不清楚如何去调整参数。
### code
```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define int long long
#define ull unsigned long long
using namespace std;
using namespace __gnu_pbds;
const int N=2e5+666;
const int MOD=998244353;
int n,m,a[N];
ull f[N][52];
int L[N],R[N];
gp_hash_table<ull,int>mp;
const ull base=131;
ull pwb[55];
int st[55];
void link(int x,int y){
    int i,j;
    for(i=1,j=x;i<49&&j;++i){
        if(!L[j])break;
        j=L[j];
    }
    int top=0;
    while(j!=x){
        st[++top]=j;
        j=R[j];
    }
    st[++top]=x;
    R[x]=y;L[y]=x;
    for(i=1;i<=top;++i){
        int w=top+2-i;j=st[i];
        for(int iu=1;iu<w;++iu)j=R[j];
        for(int k=w;k<=50&&j;++k){
            if(f[st[i]][k])mp[f[st[i]][k]]--;
            f[st[i]][k]=(f[st[i]][k-1]*base+a[j]);
            mp[f[st[i]][k]]++;
            j=R[j];
        }
    }
}
void cut(int x){
    int y=R[x];
    int i,j;
    for(i=1,j=x;i<49&&j;++i){
        if(!L[j])break;
        j=L[j];
    }
    int top=0;
    while(j!=x){
        st[++top]=j;
        j=R[j];
    }
    st[++top]=x;
    for(i=1;i<=top;++i){
        int w=top+2-i;
        for(j=w;j<=50;++j){
            if(f[st[i]][j])mp[f[st[i]][j]]--;
            f[st[i]][j]=0;
        }
    }
    R[x]=L[y]=0;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    pwb[0]=1;
    for(int i=1;i<=50;++i){
        pwb[i]=pwb[i-1]*base;
    }
    cin>>n>>m;
    for(int i=1;i<=n;++i){
        cin>>a[i];
        f[i][1]=a[i];
        mp[a[i]]++;
        L[i]=R[i]=0;
    }
    while(m--){
        int op;cin>>op;
        if(op==1){
            int x,y;cin>>x>>y;
            link(x,y);
        }else if(op==2){
            int x;cin>>x;
            cut(x);
        }else{
            string s;cin>>s;
            int k;cin>>k;
            if(k>s.size()){
                cout<<"0\n";
                continue;
            }
            int now=0;
            for(int i=0;i<k;++i){
                now=(now*base+(s[i]-'0'));
            }
            int ans=mp[now];
            if(!ans){
                cout<<"0\n";
                continue;
            }
            for(int i=k;i<s.size();++i){
                now=(now-(s[i-k]-'0')*pwb[k-1])*base+(s[i]-'0');
                ans=ans*mp[now]%MOD;
                if(!ans){
                    cout<<"0\n";
                    break;
                }
            }
            if(ans){
                cout<<ans<<'\n';
            }
        }
    }
}
```

---

## 作者：yuanruiqi (赞：1)

考虑记录每一次合并新造成的长度不超过 $50$ 的子串的哈希值，并在分裂时删除。注意到若没有删除，复杂度为 $O(kn)$，每一次分裂只会造成 $O(k^2)$ 个串的删除和再次加入。所以总复杂度为 $O(kn+ck^2)$。下面考虑 $O(1)$ 维护，对于合并和分裂可以维护链表，哈希值可以使用哈希表存储。

---

## 作者：lgswdn_SA (赞：1)

[此处似乎大概可能体验更佳。](https://www.cnblogs.com/TetrisCandy/p/15382569.html)

发现自己哈希的无数个问题……

首先蚯蚓可以用链表维护这个序列。

然后发现 $k$ 很少，意味着每次合并或删除所动的子串数量非常少。这启发我们可以把所有出现的长度 $\le k$ 的子串全部通过哈希塞进一个桶里面，然后查询的时候我们直接再桶中查询。

对于如何维护这个桶，我们可以用一个散列表。

具体一点的操作。对于合并，我们找到第一个队伍靠近尾巴的 $k$ 个和第二个队伍的靠近头的 $k$ 个，然后找到所有由两边合并所得到的子串，哈希值丢进散列。

对于删除，我们同样的这样操作，把两边合并得到的子串给从散列中扔出来。也就是合并的逆操作。

对于查询，对于每一个长 $k$ 的子串，在散列表中查询即可。

分享一个关于我的哈希的故事：我一开始用了一个单模数的哈希，被卡了；然后用了一个双模的，TLE 了；然后发现哈希应该把哈希和长度当成一个 pair 去比较，然后被卡了；然后我换成自然溢出，AC 了。。

实际上这样是正常的。自然溢出比 32 位整型模数的容量大一倍，然后哈希的值存成一个由哈希值和长度组成的 pair 的话也可以大大降低被卡率。至于双模 TLE 的问题，多半是我人傻常熟大 /qd。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
typedef pair<int,int> pii;
typedef vector<int> vi;
typedef unsigned long long ull;
typedef pair<ull,int> pui;

long long read() {
	long long res=0, w=1; char c=getchar();
	while(!isdigit(c)) {if(c=='-') w=-1; c=getchar();}
	while(isdigit(c)) {res=res*10+c-48, c=getchar();}
	return res*w;
}

const int N=2e5+9,mod=20070720+20061019+5250,base=131,dom=998244353;

int n,m,len[N],a[10000001],cnt[9];
char s[10000001];
ull b[N];


int pre[N],nxt[N];
void cut(int x) {pre[nxt[x]]=0,nxt[x]=0;}
void unite(int x,int y) {nxt[x]=y,pre[y]=x;}

namespace HT {
	int hd[mod],nxt[mod],c[mod],tot;
	pui vp[mod];
	void add(pui x) {
		int val=x.fi%mod,u=hd[val];
		while(u&&vp[u]!=x) u=nxt[u];
		if(!u) {vp[++tot]=x,c[tot]=1,nxt[tot]=hd[val],hd[val]=tot;}
		else c[u]++;
	}
	void del(pui x) {
		int val=x.fi%mod,u=hd[val];
		while(u&&vp[u]!=x) u=nxt[u];
		if(!u) throw 404;
		else c[u]--;
	}
	int qry(pui x) {
		int val=x.fi%mod,u=hd[val];
		while(u&&vp[u]!=x) u=nxt[u];
		return c[u];
	}
}

int main() {
	n=read(), m=read();
	rep(i,1,n) len[i]=read(), cnt[len[i]]++;
	b[0]=1; rep(i,1,100) b[i]=b[i-1]*base;
	rep(i,1,m) {
		int opt=read();
		if(opt==1) {
			int x=read(), y=read();
			vi f(101); vector<ull> g(101);
			for(int u=x,c=50;c;u=pre[u]) f[c--]=u;
			for(int u=y,c=50;c<=100;u=nxt[u]) f[++c]=u;
			rep(i,1,100) g[i]=g[i-1]*base+len[f[i]];
			rep(l,1,50) if(f[l]) rep(r,51,100) if(f[r]&&r-l+1<=50) {
				ull res=g[r]-g[l-1]*b[r-l+1];
				HT::add(pui(res,r-l+1));
			}
			unite(x,y);
		} else if(opt==2) {
			int x=read(), y=nxt[x];
			cut(x);
			vi f(101); vector<ull> g(101);
			for(int u=x,c=50;c;u=pre[u]) f[c--]=u;
			for(int u=y,c=50;c<=100;u=nxt[u]) f[++c]=u;
			rep(i,1,100) g[i]=g[i-1]*base+len[f[i]];
			rep(l,1,50) if(f[l]) rep(r,51,100) if(f[r]&&r-l+1<=50) {
				ull res=g[r]-g[l-1]*b[r-l+1];
				HT::del(pui(res,r-l+1));
			}

		} else {
			scanf("%s",s+1); int m=strlen(s+1), k=read();
			rep(i,1,m) a[i]=s[i]-'0';
			int ans=1;
			if(k==1) {
				rep(i,1,m) ans=1ll*ans*cnt[a[i]]%dom;
				printf("%d\n",ans);
				continue;
			}
			vector<ull> g(m+1);
			rep(i,1,m) g[i]=g[i-1]*base+a[i];
			rep(l,1,m-k+1) {
				int r=l+k-1; ull res=g[r]-g[l-1]*b[r-l+1];
				ans=1ll*ans*HT::qry(pui(res,k))%dom;
			}
			printf("%d\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：Pursuing_OIer (赞：0)

### Problem
[原题链接](https://www.luogu.com.cn/problem/P3823)

### Meaning  
给定一些数字，对它们进行首尾相接和断开两种操作。对于每次询问，求对于每个数字，其后长度一定的数字串在给定数字串中出现的次数，并给出这些次数之积。  

### Soultion  
对于每次首尾相接或断开的操作，如果直接对断点或合点两侧的整个数字串进行操作，时间复杂度不可接受。由于每次查询只有向后 $k$ 数字串会产生贡献，所以假设 $k$ 一定，则只需要对断点或合点左侧 $k-1$ 个数字进行操作。这道题的向后 $k$ 数字串的长度极为有限，所以当断点或合点左侧最靠近断点或合点的数字是需要修改的数字的第 $i$ 个后继时，我们即使在每次操作时对每一个需要修改的数字修改它的向后 $i+2$ 到 $50$（ $k$ 的上界）数字串，也不会产生过大的时间开销。  
在具体的操作过程中，我们可以取出以断点或合点为圆心，以 $50$ 为半径的圆内的点，对断点或合点左侧的数字枚举向后数字串的长度记录这个数字串并累加它的出现次数即可。  
为了方便取出这些圆上的点，我们可以使用链表对每个数字的前驱与后继进行记录，在对数字串进行操作的时候一并操作。  

> ##### 只需要取以断点或合点为圆心，以 $50$ 为半径的圆内的点的原因  
> 
> 当左侧一个数字的第 $i-1$ 个后继在断点或合点右侧时这个数字的向后 $i$ 数字串才会改变，所以左侧只需取 $49$ 个点。  
> 而即使是断点或合点左侧最靠近断点或合点的数字，也只需要最多 $49$ 个右侧的数为它做出贡献，所以只需要取圆内的点，而不需要圆上与圆外的点。  

由于在查询操作中需要求出数字串的子串，我们将所有对数字串的操作变为字符串操作。为了避免使用一些常数较大的 STL，考虑用数字代表每个字符串，将每个向后数字串哈希起来代表这个数字串，并使用哈希表记录每个数字串的出现次数，在查询操作时查询每个长度为 $k$ 的子串的哈希值与对应出现次数并进行求积，即可得到答案。  

### Code  

```cpp
#include<bits/stdc++.h>
using namespace std;
const unsigned long long mdr=998244353,pp=33557999;
#define numhash(x) (x%pp)
unsigned long long n,m,a[200010],pre[200010],nxt[200010],t[200010];
struct node{
	unsigned long long val;
	unsigned long long hashv;
	int next;
};
struct table{
	node data[35000000];
	int cnt,head[35000000];
	inline unsigned long long& operator [] (unsigned long long x){
		int temh=numhash(x);
		for(int i=head[temh];i;i=data[i].next){
			if(data[i].val==x) return data[i].hashv;
		}
		data[++cnt]={x,0,head[temh]};
		head[temh]=cnt;
		return data[cnt].hashv;
	}
}mp,str;
int opt,o,p,pos;
string s;
int main(){
	scanf("%llu%llu",&n,&m);
	t[0]=1;
	for(int i=1;i<=n;++i) t[i]=t[i-1]*11;
	for(int i=1;i<=n;++i){
		scanf("%llu",&a[i]);
		++mp[a[i]];
	}
	for(;m>0;--m){
		scanf("%d",&opt);
		if(opt==1){
			scanf("%d%d",&o,&p);
			int lft=49,rgt=50;
			unsigned long long tem[150],hs[150];
			for(int i=o;i&&lft;i=pre[i],--lft) tem[lft]=a[i];
			++lft;
			for(int i=p;i&&rgt<99;i=nxt[i],++rgt) tem[rgt]=a[i];
			--rgt;
			for(int i=lft;i<=rgt;++i) hs[i]=hs[i-1]*11+tem[i];
			for(int i=lft;i<50;++i){
				for(int len=51-i;len<=min(50,rgt-i+1);++len){
					int j=i+len-1;
					++mp[hs[j]-hs[i-1]*t[len]];
				}
			}
			nxt[o]=p,pre[p]=o;
		}else if(opt==2){
			scanf("%d",&o);
			p=nxt[o];
			int lft=49,rgt=50;
			unsigned long long hs[150],tem[150];
			for(int i=o;i&&lft;i=pre[i],--lft) tem[lft]=a[i];
			++lft;
			for(int i=p;i&&rgt<99;i=nxt[i],++rgt) tem[rgt]=a[i];
			--rgt;
			for(int i=lft;i<=rgt;++i) hs[i]=hs[i-1]*11+tem[i];
			for(int i=lft;i<50;++i){
				for(int len=51-i;len<=min(50,rgt-i+1);++len){
					int j=i+len-1;
					--mp[hs[j]-hs[i-1]*t[len]];
				}
			}
			nxt[o]=pre[p]=0;
		}else{
			cin>>s;
			scanf("%d",&o);
			int tem=s.length();
			for(int i=0;i<tem;++i) str[i+1]=str[i]*11+s[i]-'0';
			unsigned long long ans=mp[str[o]]%mdr;
			for(int i=o+1;i<=tem;++i) ans=ans*mp[str[i]-str[i-o]*t[o]]%mdr;
			printf("%llu\n",ans);
		}
	}
	return 0;
}
```

---


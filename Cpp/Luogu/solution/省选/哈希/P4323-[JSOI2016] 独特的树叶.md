# [JSOI2016] 独特的树叶

## 题目描述

JYY有两棵树 $A$ 和 $B$ ：树 $A$ 有 $N$ 个点，编号为 $1$ 到 $N$ ；树 $B$ 有$N+1$ 个节点，编号为 $1$ 到$N+1$

JYY 知道树 $B$ 恰好是由树 $A$ 加上一个叶节点，然后将节点的编号打乱后得到的。他想知道，这个多余的叶子到底是树 $B$ 中的哪一个叶节点呢？

## 说明/提示

对于所有数据，$1 \leq n \leq 10 ^ 5$

## 样例 #1

### 输入

```
5
1 2
2 3
1 4
1 5
1 2
2 3
3 4
4 5
3 6```

### 输出

```
1
```

# 题解

## 作者：Diaоsi (赞：27)

## 题目链接：[传送门](https://www.luogu.com.cn/problem/P4323)
### Update1:更新了$\LaTeX$
## 思路：
思路参考了这篇[博客](https://www.cnblogs.com/huyufeifei/p/10817673.html)的代码。

我选择的哈希方式是使用质数表进行哈希，即：

$$f(x)=\sum\limits_{y\in Son_x}f(y)\times\text{P}(Size(y))\mod M$$

其中 $P(x)$ 表示质数表中的第 $x$ 项， $Size(x)$ 表示以 $x$ 为根的子树的大小， $f(x)$ 初始化为 1 ，$M$ 为模数。

对于一棵有根树来说，这种方法可以在 $\mathcal{O(n)}$ 的时间内处理出该树的哈希值。

而题目是一颗有根树，可以想到一种朴素做法，即以每个节点为根跑一边哈希，时间复杂度为 $\mathcal{O(n^2)}$ 无法满足题目的数据范围。

以题目样例给的图为例：

![1](https://cdn.luogu.com.cn/upload/image_hosting/6ilq82xj.png)

可以先求出以 $x$ 为根的树的哈希值，记为 $f(x)$ ，同时被一并求出的还有以 $y$ 为根的子树的哈希值，记为 $f(y)$ 。

根据上面的定义我们可以推导出以 $y$ 为根的哈希值 $g(y)$ 为 $f(y)+h(x)$ 

 $h(x)$ 为以 $x$ 为根时整棵树除去以 $y$ 为根的子树的哈希值。

根据定义可得:

$$h(x)=(f(x)-f(y)\times\text{P}(Size(y))\times\text{P}(n-Size(y))\mod M$$

对于任意的 $y$ ，有：

$$g(y)=f(y)+(f(x)-f(y)\times\text{P}(Size(y))\times\text{P}(n-Size(y))\mod M$$

这样就可以通过一次 DFS 来求出以任意节点为根的树的哈希值了，时间复杂度降为 $\mathcal{O(n)}$ 

我们可以使用 std::set 来维护第一颗树的哈希值。

而对于第二棵树，我们可以先记录下该树的叶子节点，并且通过同样的方式计算出每个节点为根的哈希值。

再通过枚举计算删除一个叶子节点后该树的哈希值并将该值与先前 std::set 中的值进行比较就可判断删除叶子节点后的树是否与第一颗树同构。

特别的，由于叶子节点的大小为 1 ，所以删除一个叶子节点后的哈希值为以该叶子结点的父亲作为根的哈希值减去 $\text{P}(1)$ ，可以自己思考一下为什么。

### 时间复杂度分析：

哈希预处理的复杂度为 $\mathcal{O(n)}$ 。

处理质数表时间复杂度为线性，即 $\mathcal{O(n)}$ 。

 std::set 的本质是一颗红黑树，单次查询的时间复杂度为 $\mathcal{O(\log n)}$ 。

总的时间复杂度为 $\mathcal{O(n \log n)}$

## 代 码 放 送：

既然你能找到这题，我相信你能瞬间做出来的。

$Code:$

```cpp
#include<bits/stdc++.h>
#define Max(x,y) (x>y?x:y)
#define Min(x,y) (x<y?x:y)
using namespace std;
const long long N=100010,M=1000010,lpw=1e9+7;
long long head[N],ver[M],Next[M],tot;
long long n,P[M<<1],v[M<<1],cnt;
long long f[N],g[N],Size[N];
long long ind[N],fa[N];
set<long long> st;
void add(long long x,long long y){
	ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
}
void init(){
	memset(head,0,sizeof(head)),tot=0,n++;
}
void Hash1(long long x,long long fa){
	Size[x]=f[x]=1;
	for(long long i=head[x];i;i=Next[i]){
		long long y=ver[i];
		if(y==fa)continue;
		Hash1(y,x);
		Size[x]+=Size[y];
		f[x]=(f[x]+f[y]*P[Size[y]]%lpw)%lpw;
	}
}
void Hash2(long long x,long long fa,long long L){
	g[x]=(f[x]+L*P[n-Size[x]]%lpw)%lpw;
	for(long long i=head[x];i;i=Next[i]){
		long long y=ver[i];
		if(y==fa)continue;
		Hash2(y,x,(g[x]-f[y]*P[Size[y]]%lpw+lpw)%lpw);
	}
}
void GetP(long long x){
	for(long long i=2;i<=x;i++){
		if(!v[i])P[++cnt]=i;
		for(long long j=1;j<=cnt&&i*P[j]<=x;j++){
			v[i*P[j]]=1;
			if(!(i%P[j]))break;
		}
	}
}
int main(){
	GetP((M<<1)-1);
	scanf("%lld",&n);
	for(long long i=1;i<n;i++){
		long long x,y;
		scanf("%lld%lld",&x,&y);
		add(x,y),add(y,x);
	}
	Hash1(1,0);
	Hash2(1,0,0);
	for(long long i=1;i<=n;i++)
		st.insert(g[i]);
	init();
	for(long long i=1;i<n;i++){
		long long x,y;
		scanf("%lld%lld",&x,&y);
		add(x,y),add(y,x);
		ind[x]++,ind[y]++;
		fa[x]=y,fa[y]=x;
	}
	Hash1(1,0);
	Hash2(1,0,0);
	for(long long i=1;i<=n;i++){
		if(ind[i]>1)continue;
		int x=(g[fa[i]]-P[1]+lpw)%lpw;
		if(st.find(x)!=st.end()){
			printf("%lld\n",i);
			return 0;
		}
	}
	return 0;
}
```


---

## 作者：RabbitHu (赞：19)

> 本文同步发布于[胡小兔的博客](https://www.cnblogs.com/RabbitHu/p/9165770.html)，欢迎交流 >v<

这道题是一道判断无根树同构的模板题，判断同构主要的思路就是哈希。

一遇到哈希题，一百个人能有一百零一种哈希方式，这篇题解随便选用了一种——类似[杨弋《Hash在信息学竞赛中的一类应用》](https://wenku.baidu.com/view/72d3d14f852458fb770b560d.html)中的这种，可能不是最简洁好写的，但是能用。

我的哈希规则：子树$u$的哈希值由它的每一个子树$v_i$的哈希值得来，首先将所有$f(v)$排个序（防止顺序不同造成影响），然后$f(u) = size(u) * \sum_i f(v_i)W^{i - 1} \bmod P$，$W$是事先选取的一个位权，$P$是模数，$size(u)$是子树$u$的大小。

这样DFS一遍可求出以$1$号节点为根时，所有子树的哈希值$f(u)$。

但是这是无根树，我们想求出以任意节点为根时整棵树的哈希值。

设$fa_u$为以$1$为根时$u$的父亲，则上面的$f(u)$也是以$fa_u$为根时子树$u$的哈希值。

再求一个$g(u)$表示以$u$为根时子树$fa_u$的哈希值。这个$g(u)$怎么求呢？再DFS一遍，对于每个节点，$g(u)$由$g(fa_u)$以及$u$的每个兄弟$v_i$的$f(v_i)$得来。但是直接暴力枚举的话在菊花图上是$O(n^2)$的，那怎么办呢？

对于每个节点$u$维护一个数组，存储它所有儿子的哈希值$f(v)$，如果有父亲，则$g(u)$也在里面，把这个数组排好序，求出每个前缀的哈希值和每个后缀的哈希值。这时，以$u$为根时整棵树的哈希值就是整个数组的哈希值（再乘上子树大小$n$）。

此时求每个儿子$v$的$g(v)$，就是从那个数组中间去掉$f(v)$后的哈希值，二分查找后把前缀哈希值和后缀哈希值拼起来就可以得到。记得乘上$v$为根时$u$的$size$即$n - size(v)$。

这样就求出以每个节点为根的哈希值了。

把A的所有哈希值存到一个set里，然后枚举B的每个度为1的点$u$，求出以$u$为根它的唯一子树$v$的哈希值，如果set里有这个值，$u$就是所求的点之一。

代码比较丑，见谅 ><

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
#include <set>
#define space putchar(' ')
#define enter putchar('\n')
typedef long long ll;
using namespace std;
template <class T>
void read(T &x){
    char c;
    bool op = 0;
    while(c = getchar(), c < '0' || c > '9')
        if(c == '-') op = 1;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
        x = x * 10 + c - '0';
    if(op) x = -x;
}
template <class T>
void write(T x){
    if(x < 0) putchar('-'), x = -x;
    if(x >= 10) write(x / 10);
    putchar('0' + x % 10);
}

const int N = 100005, W = 1000000021, P = 999999137;
int n, m, fa[N], f[N], g[N], pw[N], Sze[N], deg[N], ans = P;
int ecnt, adj[N], nxt[2*N], go[2*N];
vector <int> son[N], sl[N], sr[N];
set <int> vis;
bool isB;

void add(int u, int v){
    if(isB) deg[u]++;
    go[++ecnt] = v;
    nxt[ecnt] = adj[u];
    adj[u] = ecnt;
}
int dfs1(int u, int pre){
    Sze[u] = 1;
    fa[u] = pre;
    son[u].clear();
    for(int e = adj[u], v; e; e = nxt[e])
	if((v = go[e]) != pre){
	    son[u].push_back(dfs1(v, u));
	    Sze[u] += Sze[v];
	}
    if(son[u].empty()) return f[u] = 1;
    sort(son[u].begin(), son[u].end());
    ll ret = 0;
    for(int i = 0; i < (int)son[u].size(); i++)
	ret = (ret * W + son[u][i]) % P;
    return f[u] = Sze[u] * ret % P;
}

void dfs2(int u){
    if(fa[u]){
	son[u].push_back(g[u]);
	sort(son[u].begin(), son[u].end());
    }
    int sze = son[u].size();
    sl[u].resize(sze);
    sl[u][0] = son[u][0];
    for(int i = 1; i < sze; i++)
	sl[u][i] = ((ll)sl[u][i - 1] * W + son[u][i]) % P;
    sr[u].resize(sze);
    sr[u][sze - 1] = son[u][sze - 1];
    for(int i = sze - 2; i >= 0; i--)
	sr[u][i] = (sr[u][i + 1] + (ll)son[u][i] * pw[sze - i - 1]) % P;
    for(int e = adj[u], v; e; e = nxt[e])
	if((v = go[e]) != fa[u]){
	    if(sze == 1){
		g[v] = 1;
		dfs2(v);
		break;
	    }
	    int p = lower_bound(son[u].begin(), son[u].end(), f[v]) - son[u].begin();
	    g[v] = 0;
	    if(p + 1 < sze) g[v] = sr[u][p + 1];
	    if(p - 1 >= 0) g[v] = (g[v] + (ll)sl[u][p - 1] * pw[sze - 1 - p]) % P;
	    g[v] = (ll)g[v] * (n - Sze[v]) % P;
	    if(isB && deg[v] == 1 && vis.find(g[v]) != vis.end()) ans = min(ans, v);
	    dfs2(v);
	}
    if(!isB) vis.insert((ll)sl[u][sze - 1] * n % P);
}

int main(){

    pw[0] = 1;
    for(int i = 1; i < N; i++)
	pw[i] = (ll)pw[i - 1] * W % P;
    read(n);
    for(int i = 1, u, v; i < n; i++)
	read(u), read(v), add(u, v), add(v, u);
    dfs1(1, 0);
    dfs2(1);
    ecnt = 0, isB = 1, n++;
    memset(adj, 0, sizeof(adj));
    for(int i = 1, u, v; i < n; i++)
	read(u), read(v), add(u, v), add(v, u);
    dfs1(1, 0);
    if(deg[1] == 1 && vis.find(f[go[adj[1]]]) != vis.end())
	ans = 1;
    dfs2(1);
    write(ans), enter;

    return 0;
}
```

---

## 作者：orpg (赞：7)

## [题目传送门](https://www.luogu.com.cn/problem/P4323)
### 题目梗概
在 $B$ 树上寻找一个叶子节点，使得 $B$ 树在删除这个叶子后与 $A$ 树一样。
### 题意分析
题目要求我们对比两颗树是否一样，暴力算法 $O(n^2)$ 过不了。所以我们想到了树上哈希。

对于一个节点 $u$ 我们维护一个数组 $f_u$ 表示以 $u$ 为根的子树的哈希值。因为编号打乱，所以如果只以 $u$ 为根，那么有可能找不到。我们再通过换根 dp 维护一个 $g_u$ 数组，就可以找到叶子节点了。

为了方便找到，我们先维护以变 $A$ 树的 $f_u$ 和 $g_u$ 然后将 $g_u$ 丢进一个 set 中(可以在  $O(n \log n)$ 的时间找到) 最后将 $B$ 树的哈希 $g_u$ 减掉一个叶子节点。判断是否和 $A$ 树一样。
### 上代码
```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
#define int ull
using namespace std;
const int maxn=2e6+5;
struct node{
    int to,nxt;
}ed[maxn];
int head[maxn<<1];
int n,tot,siz[maxn];
ull f[maxn],g[maxn];
int prime[maxn];
int io[maxn];
int fa[maxn];
bool isprime[maxn];
set<int> st;
void add(int u,int v){
	ed[++tot].to=v;
	ed[tot].nxt=head[u];
	head[u]=tot;
}
void er(int n){
	memset(isprime,true,sizeof(isprime));
	prime[0]=0;
	for(int i=2;i<=n;i++){
		if (isprime[i])prime[++prime[0]]=i;
		for(int j=1;j<=prime[0] && i*prime[j]<=n;j++){
			isprime[i*prime[j]]=false;
			if (i%prime[j]==0) break;
		}
	}
}
void dfs(int u,int fa){
    siz[u]=1;
    f[u]=1;
    for(int i=head[u];i;i=ed[i].nxt){
        int to=ed[i].to;
        if(to==fa) continue;
        dfs(to,u);
        siz[u]+=siz[to];
        f[u]+=f[to]*prime[siz[to]];
    }
}
void dfs1(int u,int fa,int tmp){
    g[u]=f[u]+tmp*prime[n-siz[u]];
    for(int i=head[u];i;i=ed[i].nxt){
        int to=ed[i].to;
        if(to==fa) continue;
        int temp=g[u]-f[to]*prime[siz[to]];
        dfs1(to,u,temp);
    }
}
void init(){
    tot=0;
    memset(head,0,sizeof head);
    memset(g,0,sizeof(g));
    memset(f,0,sizeof f);
    memset(siz,0,sizeof siz);
}
main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n;
    er(1299710);
    for(int a,b,i=1;i<n;i++){
        cin>>a>>b;
        add(a,b);add(b,a);
    }
    dfs(1,0);
    dfs1(1,0,0);
    for(int i=1;i<n;i++){
        st.insert(g[i]);
    }
    init();
    n++;//本人代码在此挂了3次
    //因为dfs 和 dfs1会用到n,所以n必须更新为当前节点数
    for(int a,b,i=1;i<n;i++){
        cin>>a>>b;
        add(a,b);add(b,a);
        io[a]++,io[b]++;
    }
    dfs(1,0);
    dfs1(1,0,0);
    for(int i=1;i<=n;i++){
        if(io[i]!=1) continue;
        int fo=(g[ed[head[i]].to]-2);
        if(st.find(fo)!=st.end()){
            cout<<i<<'\n';
            return 0;
        }
    }
    return 0;
}
```


---

## 作者：orangewang (赞：6)

## [逝世传送门](https://www.luogu.com.cn/problem/P4323)

前置知识：输入输出，树上哈希

### 题意
$B$ 树为 $A$ 树打乱编号后,加上一个点,现在要你求出那个多加的点（即减掉 $B$ 树的个点后，$A$ 树与 $B$ 树**同构**）。
### 思路
先考虑暴力算法：枚举要删掉的点 $i$，每次删点后 $O(n ^ 2)$ 比较两树，时间复杂度 $O(n ^ 3)$，这显然会 TLE。 ~~于是我们选择换道题写~~。于是我们选择优化，我们先算出两树的 hash 值，因为节点的编号被打乱，所以我们还要求出以每个节点为根的 hash 值并用 set 维护，以 $O(\log n)$ 的复杂度比较两树，时间复杂度 $O(n \log n)$。
### 代码

```cpp

#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;
const int MAXN=1e5+10,MAXP=2e6+12;
int n;
int father[MAXN],siz[MAXN],In[MAXN];
int p[MAXP];
bool Isprime[MAXP];
ull dp[MAXN],g[MAXN];
vector<int>vec[MAXN];
set<ull>st;
void Euler_sieve(int x){
	memset(Isprime,true,sizeof(Isprime));
	p[0]=0;
	for(int i=2;i<=x;i++){
		if(Isprime[i]) p[++p[0]]=i;
		for(int j=1;j<=p[0] && i*p[j]<=x;j++){
			Isprime[i*p[j]]=0;
			if(i%p[j]==0) break;
		}
	}
}
void dfs_hash(int u,int fa){
	siz[u]=1;
	dp[u]=1;
	for(int i=0;i<vec[u].size();i++){
		int v=vec[u][i];
		if(v==fa) continue;
		dfs_hash(v,u);
		dp[u]+=dp[v]*p[siz[v]];//计算hash值
		siz[u]+=siz[v];//统计子树大小
	}
}
//换根DP
void dfs_g(int u,int fa,ull fv){
	g[u]=dp[u]+p[n-siz[u]]*fv;
	for(int i=0;i<vec[u].size();i++){
		int v=vec[u][i];
		if(v==fa) continue;
		ull tmp=g[u]-dp[v]*p[siz[v]];
		dfs_g(v,u,tmp);
	}
}
void init(){
	for(int i=1;i<=n;i++){
		st.insert(g[i]);
		vec[i].clear();
	}
	memset(dp,0,sizeof(dp));
	memset(g,0,sizeof(g));
	memset(siz,0,sizeof(siz));
}
int main(){
	Euler_sieve(1299710);
	scanf("%d",&n);
	for(int i=1,x,y;i<n;i++){
		scanf("%d%d",&x,&y);
		vec[x].push_back(y);
		vec[y].push_back(x);
	} 
	dfs_hash(1,0);
	dfs_g(1,0,0);
	init();
	n++;
	for(int i=1,x,y;i<n;i++){
		scanf("%d%d",&x,&y);
		vec[x].push_back(y);
		vec[y].push_back(x);
		In[x]++;In[y]++;
	} 
	dfs_hash(1,0);
	dfs_g(1,0,0);
	for(int i=1;i<=n;i++){
		if(In[i]==1){
			ull res=g[vec[i][0]]-(ull)2;
			if(st.find(res)!=st.end()){
				printf("%d\n",i);
				return 0;
			}
		}
	} 

	return 0;
}

```


---

## 作者：GFyyx (赞：5)

## 题目大意
有两棵树 $A$ 和 $B$。树 $A$ 有 $N$ 个点，编号为 $1$ 到 $N$；树 $B$ 有 $N+1$ 个节点，编号为 $1$ 到 $N+1$。

树 $B$ 恰好是由树 $A$ 加上一个叶子节点，然后将节点的编号打乱后得到的。

求这个多余的叶子的编号。

## 解题思路
树哈希 + 换根 DP + set。

### 树哈希
根据题意，判断一些树是否同构的时，我们常常把这些树转成哈希值储存起来，以降低复杂度。

树哈希是很灵活的，可以设计出各种各样的哈希方式；但是如果随意设计，很有可能是错误的，容易被卡。

树哈希的方法有很多种，可以参考 [OI WIKI 上的博客。](https://oi.wiki/graph/tree-hash/)

以下介绍一类国家集训队奆老发明的容易实现且（目前）没有被卡掉的哈希编码方式。

定义哈希数组 $Hash1_u$ 求出以 $u$ 为根的子树的哈希值，编码方式为：

$Hash1_u=\sum\limits Hash1_v \times P_{siz_v}$

$v$ 为 $u$ 的子节点，$P_i$ 表示第 $i$ 大的质数。

但以每个节点为根跑一遍 ```DFS``` 求哈希，时间复杂度为 $\Theta(n^2)$ 会超时。

### 换根 DP
定义以 $v$ 为根时整棵树的哈希值为 $Hash2_v$。

显然的，我们可以通过 $Hash1$ 推导 $Hash2$ 的值：

```hash2[u]=hash1[u]+tmp*prm[n-siz[u]];```

这样将求哈希的过程优化到 $\Theta(n)$。

具体实现看代码。

## AC 代码（附有注释）
```cpp
#include <iostream>
#include <string.h>
#include <set>
#define int unsigned long long
//哈希自然溢出 
using namespace std;
struct node{int to,nxt;}e[114514<<1];
int head[114514<<1],tot;//双向边 
void add(int x,int y){
	e[++tot]={y,head[x]};
	head[x]=tot;
}
int prm[1919810<<1];
bool isp[1919810<<1];
void init(int x){
	memset(isp,1,sizeof isp);
	prm[0]=0;
	for(register int i=2; i<=x; i++){
		if (isp[i])prm[++prm[0]]=i;
		for(int j=1; j<=prm[0]&&i*prm[j]<=x; j++){
			isp[i*prm[j]]=0;
			if (!(i%prm[j])) break;
		}
	}//初始化筛质数 
}
int n,siz[114514],deg[114514];
int hash1[114514],hash2[114514];
void dfs1(int u,int fa){
    siz[u]=hash1[u]=1;
    for(register int i=head[u]; i; i=e[i].nxt){
        int to=e[i].to;
        if(to==fa) continue;
        dfs1(to,u);
        siz[u]+=siz[to];
        hash1[u]+=hash1[to]*prm[siz[to]];
    }
}//dfs1求Hash1 
void dfs2(int u,int fa,int tmp){
    hash2[u]=hash1[u]+tmp*prm[n-siz[u]];
    for(int i=head[u]; i; i=e[i].nxt){
        int to=e[i].to;
        if(to==fa) continue;
        dfs2(to,u,hash2[u]-hash1[to]*prm[siz[to]]);
    }
}//dfs2求Hash2 
set<int> s;
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin >> n;
    init(1299710);//第 1e5 个质数 
    int jj,fq;
    for(register int i=1; i<n; i++){
        cin >> jj >> fq;
        add(jj,fq);add(fq,jj);
    }//建树A 
    dfs1(1,0);dfs2(1,0,0); 
    for(register int i=1; i<n; i++)
        s.insert(hash2[i]);//用set记录A的哈希值，以便logn查询。 
    memset(head,0,sizeof head);tot=0;
	n++;//B节点数为n+1 
    for(register int i=1;i<n;i++){
        cin >> jj >> fq;
        add(jj,fq);add(fq,jj);//建树B 
        deg[jj]++,deg[fq]++;//记录节点度数 
    }
    dfs1(1,0);dfs2(1,0,0);
    for(register int i=1; i<=n; i++){
        if(deg[i]!=1) continue;//不是叶子 
        if(s.find(hash2[e[head[i]].to]-2)!=s.end()){
            cout << i << endl;//与A同构 
            return 0;
        }
    }
}
```


---

## 作者：Morax2022 (赞：4)

# Solution
题目要求从 $B$ 树中删一个节点，使其与 $A$ 树一样，求此节点编号最小值。

要求删一个点后两棵树同构，使用树哈希。若从暴力思路想，枚举 $B$ 的叶节点，再从中计算删一个节点后 $B$ 树的哈希值，若与 $A$ 的哈希值一样，则输出。

但其实可以进行优化，可以把求删点后 $B$ 树哈希值挪到外面，先算整棵树哈希值，再减掉叶子节点的哈希值，即剩下的哈希值。

具体的细节就是先计算在原树中以每个点为根其子树的哈希值，再算出以当前节点为根时整棵树的哈希值，哈希用质数表就行了，具体看代码。
# AC Code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 2 * 1e6 + 5; 
const int maxm = 2e6 + 5;
const int mod = 1e9 + 7;//这里使用mod 
struct nd{
	int to, nxt;
}e[maxn];
int head[maxn], tot = 0, n, siz[maxn], ppap[maxm], in[maxn] = {0}, father[maxn], f[maxn], g[maxn];
//f[u]为以1为根时u往下的哈希值 ，g[u]为以u为根时整棵树的哈希值 
set<int> s;//用来查找A与B是否相同（find） 
bool v[maxm] = {0};
void add(int u, int v)
{
	e[++tot].to = v;
	e[tot].nxt = head[u];
	head[u] = tot;
}//链式前向星 
void prime(int x)  
{
	int cnt = 0;
	for(long long i = 2;i <= x; i++)
	{
		if(!v[i]) ppap[++cnt] = i;
		for(long long j = 1; j <= cnt && i * ppap[j] <= x; j++)
		{
			v[i * ppap[j]] = 1;
			if(!(i % ppap[j]))break;
		}
	}
}//质数 
void dfs1(int u, int fa)
{
	f[u] = siz[u] = 1;//初值为1 
	for (int i = head[u]; i; i = e[i].nxt)
	{
		int v = e[i].to;
		if (v == fa) continue;
		dfs1(v, u);
		siz[u] += siz[v]; 
		f[u] = (f[u] + f[v] * ppap[siz[v]] % mod) % mod;//哈希 
	}
}
void dfs2(int u, int fa, int ff)
{
	//ff为以u为根时的右子树的大小，左子树的哈希值为f[u] 
	g[u] = (f[u] + ff * (ppap[n - siz[u]]) % mod) %mod;
	for (int i = head[u]; i; i = e[i].nxt)
	{
		int v = e[i].to;
		if (v == fa) continue;
		//右子树的哈希值为整棵树减去左子树的哈希值 
		dfs2(v, u, (g[u] - f[v] * ppap[siz[v]] % mod + mod) % mod);
	}
}
main()
{
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	prime(2e6);//预处理 
	cin >> n;
	int a, b;
	for (int i = 1; i < n; i++)
	{
		cin >> a >> b;
		add(a, b), add(b, a);
	}
	dfs1(1, 0);
	dfs2(1, 0, 0);//对A树跑树哈希 
	for (int i = 1; i <= n; i++) s.insert(g[i]);//丢进set里 
	//init---------------
	memset(head, 0, sizeof(head));
	tot = 0;
	memset(siz, 0, sizeof(siz));
	memset(g, 0, sizeof(g));
	memset(f, 0, sizeof(f));
	for (int i = 1; i <= n; i++) e[i].to = 0;
	//init---------------
	n++;//后面的树多个点，一定要加！（惨痛的教训） 
	for (int i = 1; i < n; i++)
	{
		cin >> a >> b;
		add(a, b), add(b, a);
		in[a]++, in[b]++;//入度 
		father[a] = b, father[b] = a;//父亲 
	} 
	dfs1(1, 0);
	dfs2(1, 0, 0);//对B树跑树哈希 
	for (int i = 1; i <= n; i++)
	{
		if (in[i] > 1) continue;//判叶节点 
		int x = (g[father[i]] - 2 + mod) % mod;//从B树中去掉其中一个叶节点 
		if (s.find(x) != s.end())//查找 
		{
			cout << i;
			return 0;
		}
	}
}
```
希望本题解能给大家带来帮助！

---

## 作者：MarchKid_J0e (赞：4)

# [P4323](https://www.luogu.com.cn/problem/P4323)

## 前言

之前在 BDFS 树哈希时发现了 UOJ 的一篇文章 [一种好写且卡不掉的树哈希](https://peehs-moorhsum.blog.uoj.ac/blog/7891)，现在的 [OI-Wiki 树哈希](https://oi-wiki.org/graph/tree-hash/) 也更新为了这个简单易写且正确性高的做法。

具体做法是定义随机函数，原文章里函数为：

```cpp
ull G(ull x) {return x*x*x*1237123+19260817;}
ull F(ull x) {return G(x&UINT_MAX)+G(x>>31);}

```

状态转移方程也很简单，以 $u$ 为根的子树的 $hash$ 值 $f_u$ 为：

$$
f_u=1+\sum_{v\in{son_u}} F(f_v)
$$

这个做法的最诱人的优点：

- 树形 dp 好转移
- 代码量小

## 题意

给定含有 $n$ 个节点的树 $A$ 和还有 $n+1$ 个节点的树 $B$。其中树 $A$ 是由树 $B$ 删除一个叶子节点得到的，求树 $B$ 中**编号最小**的符合条件的叶子节点。

## Solution

算法：树哈希。设 $f_u$ 为以 $1$ 为根时子树 $u$ 的 $hash$ 值， $g_u$ 为以 $u$ 为根时整棵树的 $hash$ 值。

根据前言里的做法和换根 dp 得到状态转移方程：

$$
\begin{aligned}
    f_u&=1+\sum_{v\in{son_u}} F(f_v)\\
    g_u&=
    \begin{cases}
        f_1&{u=1}\\
        f_u+F(g_{fa}-F(f_u))&{u\not=1}
    \end{cases}
\end{aligned}
$$

得到 $f,g$ 后，枚举树 $B$ 的 $n+1$ 个节点，若度数为 $1$ 则为叶子节点，此时**以这个叶子唯一连向的那个节点 $x$ 为根**，容易得到以 $x$ 为根删去这个叶子后的 $hash$ 值为 $g_x-F(1)$，然后去树 $A$ 的 $g$ 中判断是否存在即可。

预处理 $f,g$ 时间复杂度 $O(n)$，瓶颈在查询时间复杂度 $O(n\log n)$。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
typedef unsigned long long ull;
inline ull G(const ull &x) {return x*x*x*1237123+19260817;}
inline ull F(const ull &x) {return G(x&UINT_MAX)+G(x>>31);}
struct tree
{
    vector<int> e[N];
    ull f[N], g[N];
    void init(int n)
    {
        for (int i = 1, u, v; i < n; i++)
        {
            cin >> u >> v;
            e[u].emplace_back(v);
            e[v].emplace_back(u);
        }
        dp(1, 0);
    }
    ull dfs(int u, int fa)
    {
        f[u] = 1;
        for (const int &v : e[u])
            if (v != fa)
                f[u] += F(dfs(v, u));
        return f[u];
    }
    void dp(int u, int fa)
    {
        g[u] = (u == 1) ? dfs(1, 0) : (f[u] + F(g[fa] - F(f[u])));
        for (const int &v : e[u])
            if (v != fa)
                dp(v, u);
    }
    
} A, B;
int n;
unordered_map<ull,bool> vis;
signed main()
{
    cin >> n;
    A.init(n + 0);
    B.init(n + 1);
    for (int i = 1; i <= n; i++) vis[A.g[i]];
    for (int i = 1; i <= n + 1; i++)
        if (B.e[i].size() == 1 && vis.count(B.g[*B.e[i].begin()] - F(1)))
            return cout << i, 0;
    return 0;
}
```

---

## 作者：hl666 (赞：4)

一道比较好的**树Hash**的题目，提供一种不一样的Hash方法。

首先无根树的**同构**判断一般的做法只有树Hash，所以不会的同学可以做了[Luogu P5043 【模板】树同构（[BJOI2015]树的同构）](https://www.luogu.org/problemnew/show/P5043)再来。

首先我们直接考虑一种朴素的想法，暴力求出$A$树中以每一个点为根时的Hash值

然后扔到一个```set```（你要再写个Hash也没事）里，再在$B$树中枚举叶子节点，判断去掉这个叶子节点后的Hash值是否在```set```里即可。

发现这样算法的复杂度瓶颈在求$A$树Hash值时的$O(n^2)$，那么考虑优化。

由于树Hash的原理就是不要让节点编号去影响Hash值，所以可行的Hash方式不止一种。

那么我们考虑一下用**异或+子树大小**的方式结合Hash的进制规则来做。

具体的说就是定义Hash值$H_i=\bigoplus_{j\in son_i}H_j \times seed+size_j$，其中$\bigoplus$表示异或和。

那么我们只要先求出以某个点为根时的Hash值，然后在递推到每一个点为根的情况即可，这个直接用异或的性质异或回去抵消即可。

那么问题解决，复杂度为$O(n\log n)$（别忘了```set```的复杂度），如果用Hash代替的花是$O(n)$的。

CODE

```cpp
#include<cstdio>
#include<cctype>
#include<set>
#define RI register int
#define CI const int&
#define Tp template <typename T>
using namespace std;
typedef unsigned long long ull;
const int N=100005; const ull seed=1e9+7;
int n; set <ull> s;
class FileInputOutput
{
    private:
        static const int S=1<<21;
        #define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,S,stdin),A==B)?EOF:*A++)
        char Fin[S],*A,*B;
    public:
        Tp inline void read(T& x)
        {
            x=0; char ch; while (!isdigit(ch=tc()));
            while (x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));
        }
        #undef tc
}F;
inline ull updata(CI x,CI y)
{
    return x*seed+y;
}
class Tree_Hash_Solver
{
    private:
        struct edge
        {
            int to,nxt;
        }e[N<<1]; int head[N],cnt,deg[N],size[N],g[N],x,y;
    public:
        int n,f[N]; //g only in subtree,f include all tree
        inline void add(CI x,CI y)
        {
            e[++cnt]=(edge){y,head[x]}; head[x]=cnt; ++deg[x];
        }
        inline void init(void)
        {
            for (RI i=1;i<n;++i) F.read(x),F.read(y),add(x,y),add(y,x);
        }
        #define to e[i].to
        inline void DFS1(CI now,CI fa)
        {
            size[now]=g[now]=1; for (RI i=head[now];i;i=e[i].nxt)
            if (to!=fa) DFS1(to,now),size[now]+=size[to],g[now]^=updata(g[to],size[to]);
        }
        inline void DFS2(CI now,CI fa)
        {
            if (!fa) f[now]=g[now]; else f[now]=g[now]^updata(f[fa]^updata(g[now],size[now]),n-size[now]);
            for (RI i=head[now];i;i=e[i].nxt) if (to!=fa) DFS2(to,now);
        }
        #undef to
        inline bool isleaf(CI now)
        {
            return deg[now]==1;
        }
        inline bool check(CI now)
        {
            return s.count(f[e[head[now]].to]^updata(g[now],1));
        }
}A,B;
int main()
{
    //freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
    RI i; for (F.read(n),A.n=n,A.init(),A.DFS1(1,0),A.DFS2(1,0),i=1;i<=n;++i) s.insert(A.f[i]);
    for (B.n=n+1,B.init(),i=1;i<=B.n;++i) if (!B.isleaf(i)) { B.DFS1(i,0); B.DFS2(i,0); break; }
    for (i=1;i<=B.n;++i) if (B.isleaf(i)&&B.check(i)) return printf("%d",i),0; return 0;
}
```



---

## 作者：寒鸽儿 (赞：2)

采用如下技术对树进行hash: 
$$
f(x) = 1 + \sum_{y \in son(x)} f(y) \times prime(y)
$$
这样子碰撞概率极低 , hash值相同的树被认为同构。  
运用树形DP + 换根思想可以很方便地求出无根树中以所有点为根时各自的hash值。    
在树 $B$ 中枚举每一个叶子节点 , 检查去掉这个叶子节点之后是否能够使两棵树同构。具体地 , 在给 $A$ 节点加上一个叶子之后 , 所有其余节点为根的树的hash值均发生变化 , 我们在枚举去掉树 $B$ 的某个叶子时可以很快地求出与该叶子相邻的点的hash值的变化 , 如果去掉的正是多出来的叶子 , 它应当在树 $A$ 中出现过一次。  
```cpp
#include <cstdio>
#include <cstring>
#include <map>

using namespace std;

const int N = 100010;

const int Mod = 998244353;
inline int Inc(int a, int b) { return (a += b) >= Mod ? a - Mod : a; }
inline int Dec(int a, int b) { return (a -= b) < 0 ? a + Mod : a; }
inline int Mul(int a, int b) { return 1ll * a * b % Mod; }

int Prime[N], vp[15 * N], top;
void seive(int n) {
	for(int i = 2; top < n; ++i) {
		if(!vp[i]) Prime[++top] = i;
		for(int j = 1; j <= top && i * Prime[j] <= 14 * N; ++j) {
			vp[i * Prime[j]] = 1;			
			if(!(i % Prime[j])) break;
		}
	}
}

int head[N], ver[N << 1], nex[N << 1], deg[N], tot;
inline void graphInit() {
	memset(head, -1, sizeof(head));
	tot = 0;
}
inline void addedge(int u, int v) {
	ver[tot] = v; nex[tot] = head[u]; head[u] = tot++;	
}
map<int, bool> hsh;
int f[N], siz[N], n;
void dfs1(int cur, int pre) {
	siz[cur] = f[cur] = 1;
	for(int i = head[cur]; ~i; i = nex[i])
		if(ver[i] != pre) {
			dfs1(ver[i], cur);
			siz[cur] += siz[ver[i]];
			f[cur] = Inc(f[cur], Mul(f[ver[i]], Prime[siz[ver[i]]]));
		}
}

void dfs2(int cur, int pre) {
	for(int i = head[cur]; ~i; i = nex[i])
		if(ver[i] != pre) {
			f[ver[i]] = Inc(f[ver[i]], Mul(Dec(f[cur], Mul(f[ver[i]], Prime[siz[ver[i]]])), Prime[n - siz[ver[i]]]));
			dfs2(ver[i], cur);
		}
}
int main() {
	int u, v;
	scanf("%d", &n);
	seive(n + 1);
	graphInit();
	for(int i = 1; i < n; ++i) {
		scanf("%d %d", &u, &v);
		addedge(u, v);
		addedge(v, u);
	}
	dfs1(1, 0);
	dfs2(1, 0);
	for(int i = 1; i <= n; ++i) hsh.insert(pair<int, bool>(f[i], true));
	++n;
	graphInit();
	for(int i = 1; i < n; ++i) {
		scanf("%d %d", &u, &v);
		addedge(u, v);
		addedge(v, u);
		++deg[u]; ++deg[v];
	}
	dfs1(1, 0);
	dfs2(1, 0);
	for(int i = 1; i <= n; ++i) {
		if(deg[i] == 1 && hsh.find(f[ver[head[i]]] - 2) != hsh.end()) {
			printf("%d\n", i);
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：happybob (赞：1)

这里介绍 Xor-Hash 的树哈希换根做法。

令 $f_i$ 为设树根为 $1$，以 $i$ 为根的子树的哈希值，有 $f_i = 1 + \sum \limits_{j \in son_u} F(f_j)$，$F$ 是哈希函数。

令 $r_i$ 表示以 $i$ 为根整棵树的哈希值。我们先通过暴力 $O(n)$ 求出 $r_1$ 和 $f_1, f_2, \cdots, f_n$。我们的目标是 $O(n)$ 求出 $r_2, r_3, \cdots,r_n$。

我们从 $1$ 开始深搜，假设当前节点为 $u$，父亲为 $fa$。$r_u$ 的值为以 $fa$ 为根的树减去 $u$ 这一部分的剩下部分的哈希值，加上 $f_u$。用式子表达，就是 $r_u = F(r_{fa}-F(f_u)) + f_u$。

接着对于这道题，我们对两棵树都求出其 $f$ 和 $r$。枚举树 $B$ 的每一个叶子节点 $u$，其父亲为 $fa$，则删去这个叶子节点得到的哈希值应该是 $r_{fa} - F(f_u) = r_{fa} - F(1)$。求到后判断是否有 $A$ 中有某个点为根的哈希值和其相等。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
#include <set>
using namespace std;

const int N = 1e5 + 5;

using ull = unsigned long long;
const ull P = 1930841;

int n, ff[N];
vector<int> G[N], G2[N];
ull hashing[N], hash2[N], hashing2[N], hash22[N];
set<ull> st;

ull shift(ull x)
{
	x ^= P;
	x ^= (x << 7);
	x ^= (x >> 11);
	x ^= (x << 13);
	x ^= P;
	return x;
}

void tree_hash1(int u, int f)
{
	hashing[u] = 1;
	for (int& j : G[u])
	{
		if (j != f)
		{
			tree_hash1(j, u);
			hashing[u] += shift(hashing[j]);
		}
	}
}

void DP_HASH1(int u, int f)
{
	if (u != 1) hash2[u] = shift(hash2[f] - shift(hashing[u])) + hashing[u];
	for (int& j : G[u])
	{
		if (j != f) DP_HASH1(j, u);
	}
}

void tree_hash2(int u, int f)
{
	ff[u] = f;
	hashing2[u] = 1;
	for (int& j : G2[u])
	{
		if (j != f)
		{
			tree_hash2(j, u);
			hashing2[u] += shift(hashing2[j]);
		}
	}
}

void DP_HASH2(int u, int f)
{
	if (u != 1) hash22[u] = shift(hash22[f] - shift(hashing2[u])) + hashing2[u];
	for (int& j : G2[u])
	{
		if (j != f) DP_HASH2(j, u);
	}
}

int main()
{
	scanf("%d", &n);
	for (int i = 1; i < n; i++)
	{
		int u, v;
		scanf("%d%d", &u, &v);
		G[u].emplace_back(v);
		G[v].emplace_back(u);
	}
	for (int i = 1; i <= n; i++)
	{
		int u, v;
		scanf("%d%d", &u, &v);
		G2[u].emplace_back(v);
		G2[v].emplace_back(u);
	}
	tree_hash1(1, 1);
	hash2[1] = hashing[1];
	DP_HASH1(1, 1);
	for (int i = 1; i <= n; i++)
	{
		st.insert(hash2[i]);
	}
	
	tree_hash2(1, 1);
	hash22[1] = hashing2[1];
	DP_HASH2(1, 1);
	for (int i = 1; i <= n + 1; i++)
	{
		if (G2[i].size() == 1)
		{
			int fa = G2[i][0];
			ull ns = hash22[fa] - shift(1);
			if (st.count(ns))
			{
				printf("%d\n", i);
				return 0;
			}
		}
	}
	return 0;
}
```


---


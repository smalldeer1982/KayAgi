# 秩序魔咒

## 题目描述

现代魔法师小L和小K正在研究魔咒。

“你知道如何使用魔咒吗？”

“当然知道，这是一个现代魔法师最基本的修养。”

“那你对魔咒的发展史了解多少？”

“课上讲的我还记得一点。那是在很久很久之前了。当时，世界上还没有人会使用魔咒，而混沌魔法成为了魔法界当时的主流魔法。这是一种邪恶的法术，不需要技巧，不需要规则，内心越黑暗，力量越强。于是，邪恶的魔法师们自相残杀，弄得天昏地暗，血流成河。其中，以自称‘混沌恶魔’的魔法师为首的魔法师集团通过极其肮脏的手段控制了几乎整个魔法界，让那些向往秩序与和平的魔法师难以生存。就在这个时候，世界救星的救星出现了。名为莱赫穆拉和肯埋多卡的两名魔法师勇敢地站了出来，仅凭两个人的力量就与混沌恶魔集团展开了决战，可终究寡不敌众，被逼到了绝境。就在混沌恶魔的最后一击打中他们的身体时，莱赫穆拉和肯埋多卡利用这一击的巨大魔力，将两人余下的全部魔法与意志升格成了概念，创造了秩序魔咒体系，扭转了世界理论，使得混沌魔法被永远封印。而混沌恶魔也在这强烈的扭曲中灰飞烟灭。从此，魔法界由混沌纪元进入了秩序纪元，人们遵循莱赫穆拉和肯埋多卡这两位圣人的遗志，在秩序魔咒体系下使用魔咒，直到现在。”

“原来是这样。我们如今需要遵循一系列原则来使用魔咒，是这个原因啊。”

“是啊，这正是两位圣人为维持现在这个世界不退回混沌纪元而做的努力。话说，你是上个星期才刚刚上了第一堂魔法课，你还记得使用魔咒的几个原则吗？”

“我想想。第一，必须出现在秩序序列中。当时二位圣人留下来的体系，经过后代魔法师不懈的努力，被翻译成了名为秩序序列的存在。为了方便现代魔法师使用，**秩序序列只由英文小写字母组成**。由于体系的力量过于强大而不能仅仅限制在一个序列中，**魔法师们分别将两位圣人的遗志转移到了两个秩序序列里**。魔咒必须受到秩序序列的限制。**具体来说，是必须出现在秩序序列里（是秩序序列的子串）**。由于二位圣人的遗志不可分割，**魔咒必须同时出现在两个秩序序列里**。第二，为了让魔咒稳定而精确，秩序体系规定了魔咒的形态。**具体来说，魔咒的第一个字符需要与魔咒的倒数第一个字符相同，魔咒的第二个字符需要与魔咒的倒数第二个字符相同，以此类推**。这样就可以使魔咒对称而有秩序了。还有的话，让我看看……”

“别看了别看了，最重要的就是这些了。还有，你说不定还不知道，魔咒越长，力量越强大。”

“是这样的吗？难怪那天老师演示的魔咒魔力比我的大那么多。”

“是的是的。你是不是已经发现了，魔咒的力量是有最高限制的？”

“啊，好像没错。但老师那天说，最强魔咒的使用者还没出现？”

“对。使用者自身必须要有与魔咒同样程度的能力，才可能顺利地使用这个魔咒。我们这些初学者，不知道何年何月才能达到这个程度呢……”

“唉……不如，我们来数一数力量最强的魔咒的长度，和它们有多少个吧。”

“嗯，反正没事可做，我们就来干一干这种力所能及的事吧。”

于是，小L和小K就开始数最强魔咒的长度和个数。可过了不一会儿，它们就坚持不住了，因为秩序序列实在太长太长了。

现在，你作为一个资深魔法师，有必要告诉他们这种基本的常识。你当然已经知道两个秩序序列的形态，请你帮小L和小K算出最强魔咒的长度和个数。

## 说明/提示

**样例解释**

样例1：符合规定的魔咒有$a,b,aa,aaa,aba,bab$，其中最强的有$aaa,aba,bab$，长度为$3$，共$3$个。

样例2：符合规定的魔咒有$a,b,aa,aaa,aaaa,bb,baab,aba,aabaa,c$，其中最强的有$aabaa$，长度为$5$，共$1$个。

**数据范围**

由于某些原因，本题需要使用$Subtask$。为取得一个$Subtask$的得分，你需要通过此$Subtask$中的所有数据点。
|  | 分值 | $n,m$取值范围 | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $Subtask1$ | $0$ | $1\le n,m\le260817$ | 是样例 |
| $Subtask2$ | $5$ | $1\le n,m\le260817$ | 两个秩序序列由同一字符组成 |
| $Subtask3$ | $5$ | $1\le n,m\le10$ | 无 |
| $Subtask4$ | $10$ | $1\le n,m\le300$ | 无 |
| $Subtask5$ | $10$ | $1\le n,m\le2000$ | 无 |
| $Subtask6$ | $30$ | $1\le n,m\le260817$ | 两个秩序序列相同 |
| $Subtask7$ | $40$ | $1\le n,m\le260817$ | 无 |

显然，相同的魔咒数量只计一次。保证至少存在一个长度不小于$1$的符合规定的魔咒。

注意时限为$3s$。

## 样例 #1

### 输入

```
6 7
aaabab
ababaaa```

### 输出

```
3 3```

## 样例 #2

### 输入

```
10 10
bbaabaaaac
bbaabaaaac```

### 输出

```
5 1```

# 题解

## 作者：mrsrz (赞：25)

~~为啥知道有回文自动机还要写带log的std啊~~

~~为啥放那么小范围放那么大时限啊~~

~~我记得我前几天刚刚放了PAM板子啊~~

前置芝士：回文自动机。不懂的可以去窝的模板那儿看看。

这个题问你最长公共回文子串长度和个数。

我们对两个字符串分别建回文自动机。回文自动机中的转移边形成了一个树形结构。

走相同的转移边，得到的回文串显然是相同的。

那么我们同时对两棵树进行dfs，每次都走相同的转移边，那么走到的每个节点代表的回文串一定是公共的。

这样就可以统计最长长度了。又由于回文自动机中每个节点代表的回文串不同，所以也可以同时统计出不同最长公共回文子串个数。

回文自动机的点数是$O(n)$，所以总时间复杂度$O(n)$。

~~比std短，比std快，还比std好写。~~

## Code：
```cpp
#include<cstdio>
const int N=3e5+5;
char s[N],ss[N];
int mx=0,tot=0,n,m;
struct pam{
    int len[N],fail[N],ch[N][26],tot,lst,num[N];
    char s[N];
    void init(char*ss){
        tot=lst=1;
        len[1]=-1,len[0]=0,fail[0]=1;
        for(int i=1;ss[i];++i)s[i]=ss[i];
    }
    int insert(char cr,int ed){
        int c=cr-'a';
        int p=lst;
        while(s[ed]!=s[ed-len[p]-1])
        p=fail[p];
        if(!ch[p][c]){
            int np=++tot;
            len[np]=len[p]+2;
            int q;
            for(q=fail[p];s[ed]!=s[ed-len[q]-1];q=fail[q]);
            fail[np]=ch[q][c];
            num[np]=num[fail[np]]+1;
            ch[p][c]=np;
        }
        lst=ch[p][c];
        return num[lst];
    }
}p1,p2;
void dfs(int nl,int nr){
    if(mx<p1.len[nl])mx=p1.len[nl],tot=1;else
    if(mx==p1.len[nl])++tot;
    for(int i=0;i<26;++i)
    if(p1.ch[nl][i]&&p2.ch[nr][i])dfs(p1.ch[nl][i],p2.ch[nr][i]);
}
int main(){
    scanf("%d%d",&n,&m);
    scanf("%s%s",s+1,ss+1);
    p1.init(s),p2.init(ss);
    for(int i=1;s[i];++i)
    p1.insert(s[i],i);
    for(int i=1;ss[i];++i)
    p2.insert(ss[i],i);
    dfs(0,0);
    dfs(1,1);
    printf("%d %d\n",mx,tot);
    return 0;
}

```

---

## 作者：Liuxizai (赞：8)

[$\huge\color{skyblue}{\mathcal{My\ Blog}}$](https://liuxizai.ac.cn/post/solution-p5555-zhi-xu-mo-zhou/)

## $Description$

给出两个字符串，求最长公共回文子串的长度和数量。

## $Solution$

方法是 PAM，但是重点在于，我们不需要建两个 PAM 然后最后再跑 dfs（当然这样也可做）。

考虑 PAM 的每个结点，其代表的都是一个回文串，所以我们将两个字符串在同一棵 PAM 上分别跑一遍，那些在两次 $solve$ 过程中都被访问过的结点就是两个字符串的公共回文子串。

于是我们用 $flag_{0/1}$ 记录第 $1/2$ 次 $solve$ 中被访问的结点，就能够找出两个字符串的所有公共回文子串，最后再找最大长度并计数即可。

## $AC\ Code$

需要注意的是，这种做法 $PAM$ 的空间复杂度是 $O(n+m)$，空间要开到 $600000$。

```cpp
#include<bits/stdc++.h>
#define Int inline int
#define Void inline void
#define ri register int
using namespace std;
int n, m, mx, ans;
bool flag[2][600005];
LL read(){
    ll n = 0; int f = 1; char ch = getchar();
    while('0' > ch || ch > '9'){
        if(ch == '-') f *= -1;
        ch = getchar();
    }
    while('0' <= ch && ch <= '9'){
        n = (n << 1) + (n << 3) + ch-'0';
        ch = getchar();
    }
    return f * n;
}
Void input() {}
template<typename Type, typename... Types>
Void input(Type& arg, Types&... args){
    arg = read();
    input(args...);
}
namespace PAM{
    const int SIZE = 6e5;
    struct node{
        int num, len, fail, ch[26];
    }nd[SIZE];
    char s[SIZE];
    int cnt, last, n;
    Void init(){
        nd[0].len = 0, nd[0].fail = 1;
        nd[1].len = -1, nd[1].fail = 0;
        cnt = 1;
        last = 0;
    }
    Int getfail(int p, int k){
        while(k - nd[p].len - 1 < 0 || s[k-nd[p].len-1] != s[k]) p = nd[p].fail;
        return p;
    }
    Void solve(int T){
        for(ri i = 0; i < n; i++){
            int pos = getfail(last, i);
            if(!nd[pos].ch[s[i]-'a']){
                cnt++;
                nd[cnt].fail = nd[getfail(nd[pos].fail, i)].ch[s[i]-'a'];
                nd[cnt].len = nd[pos].len + 2;
                nd[cnt].num = nd[nd[cnt].fail].num + 1;
                nd[pos].ch[s[i]-'a'] = cnt;
            }
            last = nd[pos].ch[s[i]-'a'];
            flag[T][last] = true;
        }
    }
}
int main(){
    PAM::init();
    input(n, m);
    scanf("%s", PAM::s);
    PAM::n = n;
    PAM::solve(0);
    scanf("%s", PAM::s);
    PAM::n = m;
    PAM::solve(1);
    for(ri i = 0; i <= PAM::cnt; i++){
        if(flag[0][i] && flag[1][i]){
            if(PAM::nd[i].len > mx){
                mx = PAM::nd[i].len;
                ans = 1;
            }
            else if(PAM::nd[i].len == mx) ans++;
        }
    }
    printf("%d %d", mx, ans);
    return 0;
}
```

---

## 作者：zzy2333 (赞：7)

题意：给你两个字符串，有一种串同时是这两个字符串的字串，并且它是回文串。求所有这种串的长度最大值和长度取到最大值的这种字符串有多少个。


------------
官方题解告诉我们正解是SAM，不过这题并没有卡哈希，于是我们就可以愉快的用哈希水过去了。

很多人第一想法可能是二分长度，但是这么做是不对的，反例很容易举,比如下面这个串：
$$ aba$$
它有长度为3的回文子串，却没有长度为2的回文子串。

不过如果我们把两边的a删掉，只剩一个b，它依然是一个回文串。

也就是说，如果一个字符串存在长度为n的回文子串，那么它一定存在长度为n-2的回文子串（把长度为n的回文子串两头的字符删掉即可）。

于是就可以分别对奇数和偶数二分了。
```cpp
int maxn=0,tot=0;
	int l=0,r=n/2+1;
	while(l<r){
		int mid=(l+r)/2;
		int now=check(mid*2);
	//	cout<<mid*2<<" "<<now<<endl; 
		if(now>0){
			maxn=mid*2;
			tot=now;
			l=mid+1;
		}
		else r=mid;
	}
	l=0,r=n/2+1;
	while(l<r){
		int mid=(l+r)/2;
		int now=check(mid*2+1);
	//	cout<<(mid*2+1)<<" "<<now<<endl;
		if(now>0){
			l=mid+1;
			if(mid*2+1>maxn){
				maxn=mid*2+1;
				tot=now;
			}
		}
		else r=mid;
	}
```
在check的时候，把第二个串中长度为mid的字符串哈希值都加入哈希表里面，然后对于第一个串所有长度为mid的子串，判断它是否是回文串以及是否在第二个串中出现过就行了,注意：同样的串只算一次
```cpp
int check(int len){
	if(len>min(n,m))return 0;
	memset(vis,0,sizeof(vis));
	memset(hash,0,sizeof(hash));
	int tot=0;
	for(int i=1;i+len-1<=m;i++){
		int to=i+len-1;
		long long nowhash=(hash2[to]-(hash2[i-1]*power[len])%mod+mod)%mod;//提取子串方法：hash[r]-hash[l-1]*base^(r-l+1);
	//	cout<<nowhash<<" ";
		if(!ask(nowhash))insert(nowhash);
	}
//	cout<<endl;
	for(int i=1;i+len-1<=n;i++){
		int to=i+len-1;
		long long nowhash=(hash1[to]-(hash1[i-1]*power[len])%mod+mod)%mod;
	//	cout<<nowhash<<" ";
		if(ask(nowhash)==1&&is(i,to)){//is是判断回文串的函数
			tot++;
			insert(nowhash);
		}
	}
//	cout<<endl;
	return tot;
}
```
至于怎么判断回文串，我们可以反着弄一遍哈希，然后判断正反两部分的哈希值是否相等就可以了，~~我的写法比较麻烦，还判断奇偶性算一半的哈希值，其实完全没必要所以我就不放代码了~~

别忘了取模，另外如果hash被卡了，可以试试双哈希

---

## 作者：Boxxxxxx (赞：4)

      
    
   其实我是看题解都是建两颗PAM和BFS感觉没必要就来发个题解，首先我们知道PAM上的节点就是一个回文串对不对，然后题目要求的是两个串都出现过的回文串。                
       那么我们完全可以这么做，在PAM的时候记录当前节点的回文串出现的次数，在一个串中这个次数只能出现一次，最后我们遍历PAM所有节点，去记录所有的出现次数为两次的节点，这个节点就是代表的一个回文串，然后PAM路上我们又已经知道了所有节点的LEN，那么就只需要记录最长的LEN就是答案。      
      然后我们遍历所有PAM上节点的时候就可以算出每种长度的串的数量。其实就是PAM的板子然后额外开一个vis数组去判断下遇见一个新的位置的回文串需不需要次数+1（在之前有没有出现过）,然后就是套板子，遍历PAM所有节点统计答案就好了，完全可以在一个PAM上解决问题，不需要两颗还再去BFS。
      


```cpp

int tt,N,M;
int Len, Tire[max_][30], len[max_], Fair[max_],cnt[max_];
char S[max_];
il int getfail(int cur, int i) {
	while (S[i] != S[i- len[cur] - 1]){
		cur = Fair[cur];
	}return cur;
}
bool vis[max_];
il void getPam() {
	memset(vis, 0, sizeof(vis));
	int fa = 0;
	for (re int i = 1; i <= Len; i++) {
		int now = getfail(fa, i);
		if (!Tire[now][S[i] - 'a']) {
			tt++;
			Fair[tt] = Tire[getfail(Fair[now], i)][S[i] - 'a'];
			len[tt] = len[now] + 2;
			Tire[now][S[i] - 'a'] = tt;
		}
		fa = Tire[now][S[i] - 'a'];
		if (!vis[fa]) {
			vis[fa] = 1; cnt[fa]++;
		}
	}
}
int nn[max_];
signed main() {
	len[1] = -1;
	Fair[0] = 1;
	tt = 1;
	N = read(),  M = read();
	scanf("%s", (S + 1));
	Len = N;
	getPam();
	scanf("%s", (S + 1));
	Len = M;
	getPam();

	int anslen = -1, num;
	for (re int i = 2; i <= tt; i++) {
		if (cnt[i] == 2) {
			nn[len[i]]++;
			anslen = max(anslen, len[i]);
		}
	}
	cout << anslen << " " << nn[anslen];
	return 0;
}
```


      
      

---

## 作者：creation_hy (赞：3)

## 题意

给定两个字符串，求最长共同回文子串的长度，以及有多少并列最长的子串。

## 思路

很显然的一种做法就是，给两个子串分别建 PAM，然后 dfs 一遍，求出最长的串的长度是多少以及有多少个并列最长。

正确性证明：PAM 中，下面的节点代表的串一定包含上面的节点代表的串。所以如果一个自动机拥有某节点，但另一个没有，那么再往下找显然也不会出现新的共同拥有的回文串。

注意一个（不知道算不算坑）的点：dfs 过程中，虽然两个 PAM 的节点在外观（所代表的字符串）上是相等的，但是由于遍历顺序原因，编号并不一定相等……

所以只用一个 $x$ 去同时代表两个 PAM 当前节点的编号是不对的，需要用两个指针。

我一开始就因为这个导致35pts……

可以参考这组数据：

输入：
```
6 6
aaabab
babaaa
```

输出：`3 3`

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 5;
int n, m, mxlen, mxnum;
struct PAM
{
    int len[N], fail[N], t[N][26], tot = 1;
    string s;
    inline int getFail(int x, int i)
    {
        while (i - len[x] - 1 < 0 || s[i] != s[i - len[x] - 1])
            x = fail[x];
        return x;
    }
    inline void build()
    {
        int cur = 0;
        fail[0] = 1, len[1] = -1;
        for (int i = 0; i < s.size(); i++)
        {
            s[i] -= 'a';
            int pos = getFail(cur, i);
            if (!t[pos][s[i]])
            {
                fail[++tot] = t[getFail(fail[pos], i)][s[i]];
                t[pos][s[i]] = tot;
                len[tot] = len[pos] + 2;
            }
            cur = t[pos][s[i]];
        }
    }
} A, B;
inline void dfs(int l, int r)
{
    if (A.len[l] > mxlen)
        mxlen = A.len[l], mxnum = 1;
    else if (A.len[l] == mxlen)
        mxnum++;
    for (int i = 0; i < 26; i++)
        if (A.t[l][i] && B.t[r][i])
            dfs(A.t[l][i], B.t[r][i]);
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    cin >> A.s >> B.s;
    A.build(), B.build();
    dfs(0, 0), dfs(1, 1);
    cout << mxlen << ' ' << mxnum;
    return 0;
}
```

---

## 作者：xiayucc (赞：3)

回文自动机：

可以求出一个串中所有本质不同（长得不一样的）回文串的 每一个对应的①长度②出现次数③以这个点为结束位置的回文串个数④每一个串的样子（“abba”） 等等 详细的再代码中给出了注释。

这道题再写的过程中遇到了MLE和TLE的问题

一开始超时，然后空间换时间又爆内存，最后实在是没办法，只能折中一下（在经过不停的WA以后终于找到了平衡点AC过了）

思路：

第一步：用回文自动机求出第一个串中出现过的回文串的长度，并把每个对应长度的起始位置压入到Vector中（知道了长度和起始位置相当于就确定了这个本质不同的回文串），把出现过的长度放在map中标记为1

第二步：再用一次回文自动机求出第二个串每一个回文串的长度，如果该长度在第一个串中出现过（及map[len]==1）那么久压入另一个Vector中

第三步：从大到小遍历在同时在第一个和第二个回文串中公共出现过的长度（比如：第一个串回文串长度有 1 3 5，第二个有1 4 5，那么我们只需要遍历5 1就好了，因为4 和 3只出现在了一个串里面所以肯定不可能同时出现在两个串中），如果这个长度中同时出现的回文串个数不为0，就输出答案就 OK 啦。不然，就继续往下遍历，直到出现了回文串个数不为0的长度为止。如果遍历完所有的都不存在，就输出 0 0 就结束了

AC代码：

```c
// 小猪哈奇
//因为很容易超内存和时间所以我把回文自动机中用不到的变量全都注释掉了
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int N = 3e5 + 10;
char s[N],s1[N];
int maxx[N],flag,maxx2; //record记录了节点回文串的结束位置
vector <int> v[2][260820];
struct Palindrome_tree{
	int nxt[N][26];
	int fail[N]; // 当前节点最长回文后缀的节点
	int len[N]; // 当前节点表示的回文串的长度
//	int cnt[N]; // 当前节点回文串的个数， 在getcnt后可得到全部
//	int sed[N]; // 以当前节点为后缀的回文串的个数（表示以i结尾的回文串的种类数）
	int tot; // 节点个数
	int last; // 上一个节点
	int record[N];
	void init()
	{
		tot = 0;
		memset(fail, 0, sizeof fail);
//		memset(cnt, 0, sizeof cnt);
//		memset(sed, 0, sizeof sed);
		memset(len, 0, sizeof len);
		memset(nxt, 0, sizeof nxt);
	}
	void build()
	{
		len[0] = 0, len[1] = -1; // 0为偶数长度根， 1为奇数长度根
		tot = 1, last = 0;
		fail[0] = 1;
	}
	int getfail(char *s, int x, int n)
	{
		while (s[n - len[x] - 1] != s[n]) // 比较x节点回文串新建两端是否相等
			x = fail[x]; // 若不同， 再比较x后缀回文串两端
		return x;
	}
	void insert(char* s, int n)
	{
		for (int i = 0; i < n; i++)
		{
			int c = s[i] - 'a';
			int p = getfail(s, last, i);// 得到第i个字符可以加到哪个节点的两端形成回文串
			if (!nxt[p][c])
			{
				tot++;
				len[tot] = len[p] + 2;  // 在p节点两端添加两个字符
				fail[tot] = nxt[getfail(s, fail[p], i)][c]; //tot点的后缀回文，可以由上一个节点的后缀回文尝试得到
//				sed[tot] = sed[fail[tot]] + 1; // 以当前节点为结尾的回文串个数
				nxt[p][c] = tot; // 新建节点
			}
			last = nxt[p][c]; // 当前节点成为上一个节点
//			cnt[last]++; //当前节点回文串++
			record[last] = i;
		}
	}
//	void get_cnt()
//	{
//		for (int i = tot; i > 0; i--)
//			cnt[fail[i]] += cnt[i];
//		//fail[i] 的节点 为 i 节点的后缀回文串， 所以个数相加
//	}
}pdt,pdt1;
 map <string,int> mapp;
 map <int,int> mapp1,mapp2;
 string a;
 int sum;
 bool cmp1(int s1,int s2)
{
        return s1>s2;
}
int main()
{
    int n,n1;
    cin>>n>>n1;
	scanf("%s",s);
	scanf("%s",s1);
	pdt.build();
	pdt.insert(s, n);//在建回文树
    pdt1.build();
	pdt1.insert(s1,n1);//在建回文树
    for(int i=2;i<=pdt.tot;i++)
    {
        mapp1[pdt.len[i]]=1;
    }
    for(int i=2;i<=pdt1.tot;i++)
    {
        if(mapp1[pdt1.len[i]]==1&&mapp2[pdt1.len[i]]==0)
            {maxx[++flag]=pdt1.len[i];
            mapp2[pdt1.len[i]]=1;
            }
            if(mapp2[pdt1.len[i]]==1)
            v[1][pdt1.len[i]].push_back(i);
    }
      for(int i=2;i<=pdt.tot;i++)
    {
       if(mapp2[pdt.len[i]]==1)
            v[0][pdt.len[i]].push_back(i);
    }
    sort(maxx,maxx+flag+1,cmp1);

    for(int k=0;k<=flag;k++)
    {
        maxx2=maxx[k];
        //cout<<"max:"<<maxx2<<endl;
        for (int i=0; i<v[0][maxx2].size(); i++) //第一个是无效的 从第二个开始是有效的回文串
        {
            int     j=v[0][maxx2][i];
//            if(pdt.len[i]>maxx2)
//                continue;
            int R = pdt.record[j]; //record记录了第i个类型的回文串的结束位置
            int L = pdt.record[j] - pdt.len[j] + 1;
            a="";
            for(int i=L;i<=R;i++)
                a+=s[i];
          // cout<<a<<endl;
            mapp[a]=1;
        }
        for ( int i=0; i<v[1][maxx2].size(); i++)
        {
            int   j=v[1][maxx2][i];
            int R = pdt1.record[j]; //record记录了第i个类型的回文串的结束位置
            int L = pdt1.record[j] - pdt1.len[j] + 1;
            a="";
            for(int i=L;i<=R;i++)
                a+=s1[i];
             //   cout<<"a1:"<<a<<endl;
            if(mapp[a]==1)
                sum++;
        }


    if(sum!=0)
        {
                cout<<maxx2<<" "<<sum<<endl;
                return 0;
        }
        if(k%3==1)
        mapp.clear();
    }
	cout<<0<<" "<<0<<endl;
	return 0;
}

```





---

## 作者：2018LZY (赞：2)

题意:
给你两个串,求两个串最长回文公共子串及其种数.

方法:
1. 建俩回文自动机,然后bfs/dfs.时空复杂度均$O(n)$.
2. $SAM+Manacher+$倍增.空间复杂度$O(n*26)$.时间复杂度$O(n*(\log(n)+26))$.

由于第二种又长又慢,本人就没写啦~~.

对于第一种做法,建好回文自动机后,两个相同状态跑相同的边得到相同的串,所以我们dfs/bfs就能求出最长回文子串啦.

具体地,bfs时队列把奇根/偶根丢入即可.

回文自动机你值得拥有
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define mk make_pair
using namespace std;
const int N=260822;

int ans,cnt;
char s[N];
struct PAM {//后缀自动机模板
	int last=1,tot=1,tr[N][26],len[N],fail[N];
	int Find(int x,int n) {
		while(s[n]^s[n-len[x]-1]) x=fail[x];
		return x;
	}
	void bt() {
		len[0]=0; len[1]=-1;
		fail[0]=1; 
		for(int i=1,c,p,x;s[i];i++) {
			c=(s[i]-='a');p=Find(last,i);
			if(!tr[p][c]) {
				len[x=++tot]=len[p]+2;
				fail[x]=tr[Find(fail[p],i)][c];
				tr[p][c]=x;
			}
			last=tr[p][c];
		}
	}
}p[2];

pair<int,int> q[N];

void bfs() {
	int l=1,r=2;
	q[1]=mk(0,0);
	q[2]=mk(1,1);
	ans=cnt=0;
	while(l<=r) {
		int a=q[l].first,b=q[l].second; l++;
		for(int c=0,x,y,len;c<26;c++)
			if((x=p[0].tr[a][c])&&(y=p[1].tr[b][c])) {//都能加相同字符
				len=p[0].len[x];
				if(len>ans) ans=len,cnt=1;
				else if(len==ans) cnt++;
				q[++r]=mk(x,y);
			}
	}
}

int main() {
	s[0]=-1;gets(s+1);
	for(int i=0;i<2;i++) 
		scanf("%s",s+1),p[i].bt();//建PAM
	bfs();printf("%d %d\n",ans,cnt);
	return 0;
}


```


---

## 作者：bakapiano (赞：2)

考虑类似于 SAM 求两串最长公共子串的做法，对 $S$ 串构造回文自动机，对于 $T$ 串的每个前缀 $P_{i}$，求出其最长的后缀 $suf$ 满足 $suf$ 是一个回文串并且是 $S$ 串的一个子串。

不同的地方在于 $PAM$ 上的一条转移边相当于在首尾各加一个字符，由 $P_{i}$ 转移到 $P_{i+1}$ 的时候要注意判断匹配长度不能大于 $P_{i+1}$ 的长度，并且要满足 $T[i+1] = T[i-len]$，即新的回文串是 $T$ 的一个子串。

匹配部分核心代码：
```cpp
int L=-1,cur=root1; t[0]='#';
for(int i=1;i<=m;i++)
{   
    int c=t[i]-'a';
    while(cur!=root1&&((!nx[cur][c])||L+2>i||t[i]!=t[i-L-1]))
        cur=fail[cur],L=len[cur];
    if(nx[cur][c]&&L+2<=i&&t[i]==t[i-L-1])cur=nx[cur][c],L+=2;
    mx=max(mx,L),match[cur]=1;
}
```

同时提供一组样例供调试：

```
8 5
aabaabab
aabaa
```

在 $T$ 串每个前缀上的匹配长度应该为：

```
i = 1, L = 1
i = 2, L = 2
i = 3, L = 1
i = 4, L = 3
i = 5, L = 5
5 1
```

即 $i=3$ 的时候不能由 $a$ 在两边加 $b$ 得到 $bab$，因为 $bab$ 实际不存在于 $T$ 串中。

完整代码：
```cpp
const int K = 26;
int cnt,root1,root2,last=0;
int nx[MAXN*2][K],len[MAXN*2],fail[MAXN*2],sum[MAXN*2];
string str;
void newnode(int &x)
{
    x=++cnt;
    fp(i,0,K-1) nx[x][i]=0;
    len[x]=fail[x]=0;
}
void init()
{
    cnt=0,str.clear(),str.pb('$');
    newnode(root1),len[root1]=-1;
    newnode(root2),len[root2]= 0;
    fail[root2]=root1,last=root1;
}
void extend(int pos)
{
    int c=str[pos]-'a',p=last,np;
    while(str[pos-len[p]-1]!=str[pos]) p=fail[p];
    if(nx[p][c]) np=nx[p][c];
    else
    {
        newnode(np);
        nx[p][c]=np;
        len[np]=len[p]+2;
        if(p==root1) fail[np]=root2;
        else
        {
            p=fail[p];
            while(str[pos-len[p]-1]!=str[pos]) p=fail[p];
            fail[np]=nx[p][c];
        }
    }
    last=np,sum[last]++;
}
void build(char s[])
{
    int n=strlen(s+1);
    fp(i,1,n) str.pb(s[i]),extend(i);
}

int n,m;
char s[MAXN],t[MAXN];
int mx=0,ans=0;
int match[MAXN*2];
int work()
{
    scanf("%d%d",&n,&m);
    scanf("%s",s+1),scanf("%s",t+1);
    init(),build(s);
    int L=-1,cur=root1; t[0]='#';
    for(int i=1;i<=m;i++)
    {   
        int c=t[i]-'a';
        while(cur!=root1&&((!nx[cur][c])||L+2>i||t[i]!=t[i-L-1]))
            cur=fail[cur],L=len[cur];
        if(nx[cur][c]&&L+2<=i&&t[i]==t[i-L-1])cur=nx[cur][c],L+=2;
        mx=max(mx,L),match[cur]=1;
    }
    ans=0;
    fp(i,1,cnt)
        if(match[i]&&len[i]==mx)
            ans++;
    return printf("%d %d\n",mx,ans);
}
```



---


# 「Wdsr-2」白泽教育

## 题目背景

上白泽慧音在给雾之湖的妖精们讲课。

某天，慧音在上数学课时，提到了一种非常有趣的记号：**高德纳箭号表示法**。它可以用来描述非常巨大的数字。~~比如紫的年龄。~~

对于非负整数 $a, b$ 和正整数 $n$，高德纳箭号表示法的定义为：

$$a \uparrow^n b = \begin{cases}
1\ (b = 0) \\
a^b\ (n = 1\ \operatorname{and}\ b > 0) \\
a \uparrow^{n - 1} (a \uparrow^n (b - 1))\ (n > 1\ \operatorname{and}\ b > 0)
\end{cases}$$

一些简单的例子：

- $2 \uparrow 31 = 2^{31} = 2147483648$

- $2 \uparrow \uparrow 4 = 2^{2^{2^2}} = 2^{2^4} = 2^{16} = 65536$

注：
1. $a \uparrow b$ 与 $a \uparrow^1 b$ 相同；

2. $a \uparrow \uparrow b$ 与 $a \uparrow^2 b$ 相同；

3. 请注意幂运算的顺序。

## 题目描述

慧音希望琪露诺解决以下关于 $x$ 的方程：

$$a \uparrow^n x \equiv b \pmod p$$

其中，$a, n, b, p$ 为已知的常数，$x$ 为未知数。

琪露诺被高德纳箭号表示法搞得云里雾里的，但是她不想被头槌。你能帮帮她吗？

## 说明/提示

**本题开启捆绑测试。**

| Subtask | $n$ | $p$ | $T$ | 分值 | 时限 |
| :------: | :------: | :------: | :------: | :------: | :------: |
| $1$ | $n = 1$ | $2 \leq p \leq 10^9$ 且 $p$ 为质数 | $1 \leq T \leq 100$ | $15 \operatorname{pts}$ | $2.00 \operatorname{s}$ |
| $2$ | $n = 2$ | 无特殊限制 | $1 \leq T \leq 5 \times 10^3$ | $25 \operatorname{pts}$ | $1.00 \operatorname{s}$ |
| $3$ | $n = 3$ | 无特殊限制 | 无特殊限制 | $60 \operatorname{pts}$ | $2.00 \operatorname{s}$ |

对于 $100\%$ 的数据，$1 \leq a \leq 10^9$，$1 \leq n \leq 3$，$0 \leq b < p \leq 10^9$，$1 \leq T \leq 2 \times 10^4$。

## 样例 #1

### 输入

```
3
2 1 1 3
3 1 2 7
7 1 2 4```

### 输出

```
0
2
-1```

## 样例 #2

### 输入

```
3
2 2 4 7
3 2 4 6
5 2 1 3```

### 输出

```
2
-1
0```

## 样例 #3

### 输入

```
3
4 3 5 8
2 3 9 11
6 3 1 5```

### 输出

```
-1
3
0```

# 题解

## 作者：Leasier (赞：9)

### Subtask $1$
前置芝士：[大步小步算法（BSGS）](https://www.luogu.com.cn/blog/ButterflyDew/solution-p4195)

由高德纳箭号表示法的定义可得：$a \uparrow b = a^b$。又由于 Subtask $1$ 的保证 $p$ 为质数，所以我们使用 BSGS 求解原方程即可。时间复杂度为 $O(T \sqrt{p} \log p)$。
### Subtask $2$
前置芝士：[扩展欧拉定理（exEuler）](https://www.cnblogs.com/yifusuyi/p/9997009.html)

我们首先来化简 $a \uparrow \uparrow b$。

$a \uparrow \uparrow b = a \uparrow (a \uparrow \uparrow (b - 1))$

$ = a^{a \uparrow \uparrow (b - 1)}$

$ = a^{a^{a \uparrow \uparrow (b - 2)}}$

$ = \cdots$

$ = a^{a^{.^{.^{.^a}}}}$（共 $b$ 个 $a$）

预处理欧拉函数的值，然后从 $0$ 开始枚举 $x$ 的值并判断即可。设 $k_1$ 表示使欧拉函数变为 $1$ 的最少嵌套层数 $+ 1$，则 $x$ 的枚举上界为 $k_1$。

这里计算 $a \uparrow \uparrow b$ 时需要用到扩展欧拉定理。但是，由于我们在计算 $a^b \bmod p$ 之类的式子时，需要判断 $b$ 与 $\varphi(p)$ 之间的大小关系，所以我使用了一个名为 Node 的结构体来保存运算结果取模后的值和这个结果取模前是否大于 $\varphi(p)$。时间复杂度为 $O(T \sqrt{p} \log p)$。
### Subtask $3$
我们首先来化简 $a \uparrow^3 b$。

$a \uparrow^3 b = a \uparrow \uparrow (a \uparrow^3 (b - 1))$

由于欧拉函数嵌套多层后其值会变为 $1$，所以如果我们要算出 $a \uparrow^3 b \bmod p$ 的值，只要算出 $a \uparrow \uparrow \min(a \uparrow^3 (b - 1), k_1) \bmod p$ 即可。因此，$a \uparrow^3 b$ 可以递归计算。

预处理欧拉函数的值，然后从 $0$ 开始枚举 $x$ 的值并判断即可。$x$ 的枚举上界为满足 $a \uparrow \uparrow (k_2 - 1) \geq k_1$ 的最小 $k_2$。时间复杂度为 $O(T \sqrt{p} \log p)$。

具体细节见代码注释。

代码：
```cpp
#include <iostream>
#include <map>
#include <cmath>

using namespace std;

typedef long long ll;

typedef struct {
	ll val;
	bool flag;
} Node;

int phi[37];
map<ll, int> mp;

inline Node new_node(ll val, bool flag){
	Node ans;
	ans.val = val;
	ans.flag = flag;
	return ans;
}

inline Node quick_pow(ll x, ll p, ll mod){
	Node ans;
	ans.val = 1;
	ans.flag = false;
	while (p){
		if (p & 1){
			ans.val *= x;
			if (ans.val >= mod){
				ans.val %= mod;
				ans.flag = true;
			}
		}
		p >>= 1;
		if (p == 0) break;
		x *= x;
		if (x >= mod){
			x %= mod;
			ans.flag = true;
		}
	}
	return ans;
}

inline int bsgs(int a, int b, int p){
	if (p == 1) return 0;
	a %= p;
	b %= p;
	if (b == 1) return 0;
	int m = ceil(sqrt(p)), i = 0;
	ll t = quick_pow(a, m, p).val;
	mp.clear();
	for (register ll j = b; i < m; i++, j = j * a % p){
		mp[j] = i;
	}
	i = 1;
	for (register ll j = t; i <= m; i++, j = j * t % p){
		if (mp.count(j)) return i * m - mp[j];
	}
	return -1;
}

inline int euler(int n){
	int ans = n;
	for (register int i = 2; i * i <= n; i++){
		if (n % i == 0){
			ans -= ans / i;
			while (n % i == 0){
				n /= i;
			}
		}
	}
	if (n > 1) ans -= ans / n;
	return ans;
}

Node tetration(int a, int n, int index){
	if (phi[index] == 1) return new_node(0, true);
	if (n == 0) return new_node(1, false);
	int next_index = index + 1;
	Node x = tetration(a, n - 1, next_index);
	if (x.flag) x.val += phi[next_index];
	return quick_pow(a, x.val, phi[index]);
}

inline int f(int a){
	if (a == 1) return 0;
	for (register int i = 0; ; i++){
		if (tetration(a, i, 0).flag) return i + 1;
	}
}

inline ll quick_pow_with_max_val(ll x, ll p, ll max_val){
	ll ans = 1;
	while (p){
		if (x >= max_val){
			return max_val;
		}
		if (p & 1){
			ans *= x;
			if (ans >= max_val){
				return max_val;
			}
		}
		x *= x;
		p >>= 1;
	}
	return ans;
}

ll tetration_with_max_val(ll a, ll n, int max_val){
	if (n == 0 || a == 1) return 1;
	ll x = tetration_with_max_val(a, n - 1, max_val);
	if (x == max_val) return max_val;
	return quick_pow_with_max_val(a, x, max_val);
}

ll pentation_with_max_val(ll a, ll n, int max_val){
	if (n == 0 || a == 1) return 1;
	ll x = pentation_with_max_val(a, n - 1, max_val);
	if (x == max_val) return max_val;
	return tetration_with_max_val(a, x, max_val);
}

inline ll pentation(ll a, ll n, int max_val, ll mod){
	if (mod == 1) return 0;
	if (n == 0) return 1;
	return tetration(a, pentation_with_max_val(a, n - 1, max_val), 0).val % mod;
}

int main(){
	int t;
	cin >> t;
	for (register int i = 1; i <= t; i++){
		int a, n, b, p;
		cin >> a >> n >> b >> p;
		if (n == 1){
			cout << bsgs(a, b, p) << endl;
		} else {
			int maxx_2 = 0, ans = -1;
			for (register int j = p; j != 1; j = euler(j)){
				phi[maxx_2++] = j;
			}
			phi[maxx_2] = 1;
			if (n == 2){
				for (register int j = 0; j <= maxx_2; j++){
					if (tetration(a, j, 0).val == b){
						ans = j;
						break;
					}
				}
			} else {
				int maxx_3 = f(a);
				for (register int j = 0; j <= maxx_3; j++){
					if (pentation(a, j, maxx_2, p) == b){
						ans = j;
						break;
					}
				}
			}
			cout << ans << endl;
		}
	}
	return 0;
}
```

---

## 作者：LightningUZ (赞：5)

这题的难度大，且细节很多，导致有足足5页的红色提交，都是0分/15分

~~导致我一开始还怀疑是否是数据的问题~~ 

本题的数据是没有问题的qwq

本篇题解会稍微讲一下有哪些需要注意的细节

## Subtask 1

模板 BSGS （别写挂了）

复杂度：$O(\sqrt{p})$（哈希表）/ $O(\sqrt{p}\log(p))$ （map）

## Subtask 2

这是一个幂塔。我们知道，每层的幂要模一个 $p,\varphi(p),\varphi(\varphi(p))...$。对一个数不断的取 $\varphi$，差不多 $2\log x$ 步就取到 $1$ 了。

因此，层数大于 $O(\log(p))$ 之后，答案都一样了。所以我们暴力枚举层数，计算出幂塔，就可以了。

有一点需要注意，欧拉降幂公式如下：

$$
a^b\equiv
\begin{cases} % euler power
a^b (b\le \varphi(p))\\
a^{b\mod \varphi(p)+\varphi(p)} (b>\varphi(p))\\
\end{cases}
$$

因此我们需要判断 $b$ 与 $\varphi(p)$ 的大小关系。可以参考标程的实现，用一个 `struct`，里面一个int一个bool表示值，以及它是否超过了它对应的模数。然后如果发现上一层超过模数了，就模一个 $\varphi(p)$，然后再加一个 $\varphi(p)$。

> 有些同学可能有疑问：会不会有这种情况就是，上一层没超过mod，但是这一层超过了mod？
> 
> 还真有！但是仅仅发生在 $mod=2,4,6$，且 $a=2$ 的时候。首先，如果 $a>2$，那么很容易就会超过 $mod$，因此可以验证，甚至证明， $a>2$ 不会有这个情况；而 $a=2$ 的时候，确实在 $2,4,6$ 上会有这个反例，但可以证明，它们全都不会影响。
> 
> 综上，这个做法没问题。

复杂度：$O(\log(p)\sqrt{p}+\log^2(p))$ （前者是求每一层phi的复杂度）

如果您选择先筛质数，那可以 $O(\dfrac{\sqrt{p}}{\ln(p)})$ 的分解质因数，从而做到 $O(\sqrt{p}+\log^2(p))$

## subtask 3

出题人写的比较复杂，写了好几个函数。

这里提供一个稍微简洁的办法。但有个观察是必要的，注意到 $a\uparrow^2 x$，当 $x$ 非常大的时候，都是一样的 （上一个subtask的结论）

我们特判 $a=2$。然后我们发现：$3\uparrow^3 2=3\uparrow^2 3=3^{3^{3}}=3^{27}$，是一个巨大的数字。而 $a>3$ 的时候，$a\uparrow^3 2$ 就更加巨大了。

然后，$a\uparrow^3 3=a\uparrow^2 (a\uparrow^3 2)$。后面的那个 $(a\uparrow^3 2)$ 巨大无比，根据 $\uparrow^2$ 的性质，直接把它当成 $100$ 算就好了，因为 $100$ 已经远大于 $\log(mod)$ 了。

也就是说，当 $a>2$ 的时候，判一下 $a\uparrow^3 2$ 和 $a\uparrow^3 3$ 就行了。其中 $a\uparrow^3 2=a\uparrow^2 a$，$a\uparrow^3 3=a\uparrow^2 100$。

复杂度同上。

## 坑点&注意

- 可以首先处理一些 $mod=1,b=1,b=a$ 之类的 trivial 情况。这些有些是不必要的，但处理了总归没问题。

- 读进来的 $a$ 千万不要先模一个 $p$。因为算幂塔的时候, 上面模的可不是 $p$，是 $\varphi(p)$。

- 如果您写的丑, 那phi那边可能会有点卡；可以选择使用更优的那个复杂度。

## 代码

其实不长，因为我的某些习惯，所以看起来行多。

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Flandre_Scarlet
{
    #define int long long
    #define N 1000006
    #define F(i,l,r) for(int i=l;i<=r;++i)
    #define D(i,r,l) for(int i=r;i>=l;--i)
    #define Tra(i,u) for(int i=G.h[u],v=G.to(i);~i;i=G.nx(i),v=G.to(i)) if (i>=0)
    #define MEM(a,x) memset(a,x,sizeof(a))
    #define FK(a) MEM(a,0)
    #define sz(x) ((int)x.size())
    #define all(x) x.begin(),x.end()
    #define p_b push_back
    #define pii pair<int,int>
    #define fir first
    #define sec second
    int I() {char c=getchar(); int x=0; int f=1; while(c<'0' or c>'9') f=(c=='-')?-1:1,c=getchar(); while(c>='0' and c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar(); return ((f==1)?x:-x);}
    template <typename T> void Rd(T& arg){arg=I();}
    template <typename T,typename...Types> void Rd(T& arg,Types&...args){arg=I(); Rd(args...);}
    void RA(int *p,int n) {F(i,1,n) *p=I(),++p;}
    int pr[N]; bool notp[N];
    int phi[N];
    void Init()
    {
        int n=1000000; int&c=pr[0]; notp[1]=1;
        phi[1]=1;
        F(i,2,n)
        {
            if (!notp[i])
            {
                pr[++c]=i;
                phi[i]=i-1;
            }
            for(int j=1;j<=c and i*pr[j]<=n;++j)
            {
                notp[i*pr[j]]=1;
                if (i%pr[j]==0)
                {
                    phi[i*pr[j]]=phi[i]*pr[j];
                    break;
                }
                else
                {
                    phi[i*pr[j]]=phi[i]*(pr[j]-1);
                }
            }
        }
    }
    int a,n,b,p;
    void Input()
    {
        Rd(a,n,b,p);
    }

    struct node{int x;bool o;};
    map<int,int>rec;
    int qpow(int a,int b,int m) {a=(a%m+m)%m; int r=1; while(b) {if (b&1) r=r*a%m; a=a*a%m,b>>=1;} return r;}
    int BSGS(int a,int b,int p)
    {
        rec.clear();
        int sn=sqrt(p)+1;
        int pw=1;
        F(i,0,sn-1)
        {
            rec[pw]=i;
            pw=(pw*a)%p;
        }
        if (rec.count(b)) {return rec[b];}
        int a_sn=pw; // a_sn=a^sn
        F(i,1,sn)
        {
            int iv=qpow(pw,p-2,p);
            int tmp=b*iv%p; 
            if (rec.count(tmp))
            {
                return rec[tmp]+i*sn;
            }
            pw=pw*a_sn%p;
        }
        return -1;
    }
    // n=1

    int gphi(int x) // sqrt/log 的分解质因数求phi
    {
        int ans=x,u;
        for(int i=1;(u=pr[i])<=x/u and i<=pr[0];++i) if (x%u==0)
        {
            ans-=ans/u;
            while(x%u==0) x/=u;
        }
        if (x>1) ans-=ans/x;
        return ans;
    }
    node rqpow(int a,int b,int m) // 记录是否溢出的qpow
    {
        int r=1; bool o=0;
        if (a>=m) {o=1; a%=m;}
        while(b)
        {
            if (b&1)
            {
                r=r*a; if (r>=m) o=1,r%=m;
            }
            b>>=1; if (!b) break;
            a=a*a; if (a>=m) o=1,a%=m;
        }
        return (node){r,o};
    }
    int mods[200];
    node ptower(int a,int n,int id) // 幂塔
    {
        int m=mods[id],pm=mods[id+1];
        if (m==1) return (node){0,1};
        if (n==0) return (node){1,0};
        node tmp=ptower(a,n-1,id+1);
        if (tmp.o) tmp.x+=pm;
        node ans=rqpow(a,tmp.x,m);
        return ans;
    }
    void Sakuya()
    {
        if (b==1 or p==1)
        {
            puts("0");
            return;
        }
        b%=p; // 注意不能a%=p
        if (n==1)
        {
            printf("%lld\n",BSGS(a,b,p));
            return;
        }
        mods[1]=p; int tot=1;
        while(1)
        {
            ++tot;
            mods[tot]=gphi(mods[tot-1]);
            if (mods[tot]==1) {break;}
        }
        if (n==2)
        {
            F(x,0,tot+1)
            {
                int pt=ptower(a,x,1).x;
                if (pt==b)
                {
                    printf("%lld\n",x);
                    return;
                }
            }
            puts("-1");
        }
        if (n==3)
        {
            if (a==1) {puts("-1"); return;}
            if (b==a%p) {puts("1"); return;} 
            if (a==2)
            {
                if (b==4%p) {puts("2");}
                else if (b==65536%p) {puts("3");}
                else if (b==ptower(a,100,1).x%p) {puts("4");}
                else puts("-1");
                return;
            }
            // 当a>=3时, a^^^2=a^^a 就是天文数字了, 因此 a^^(a^^(a^^...))，直接看做 a^^100 处理
            if (b==ptower(a,a,1).x) {puts("2");}
            else if (b==ptower(a,100,1).x) {puts("3");}
            else puts("-1");
        }
    }
    void IsMyWife()
    {
        Init();
        int t=I();
        while(t-->0)
        {
            Input();
            Sakuya();
        }
    }
}
#undef int //long long
int main()
{
    Flandre_Scarlet::IsMyWife();
    return 0;
}
```

---

## 作者：_Fontainebleau_ (赞：4)

### Subtask 1

$a\uparrow{b}=a^b$，而模数是质数，所以就是裸的 [BSGS](https://www.luogu.com.cn/problem/P3846)。

时间复杂度是 $O\left(T\sqrt{p}\right)$ 或 $O\left(T\sqrt{p}\log{p}\right)$，有没有 $\log$ 取决于用的是哈希表或 map。

### Subtask 2

我们先试着推一下式子：

$$\begin{aligned}a\uparrow^2{b}&=a^{a\uparrow^2{(b-1)}}\\&=a^{a^{a\uparrow^2(b-2)}}\\&=\cdots\\&=a^{a^{\cdot^{\cdot^{\cdot^{a}}}}}&\color{pink}\text{共 }b\text{ 个 }a\end{aligned}$$

这是什么？幂塔！

这令我们想起了 **扩展欧拉定理**。

根据扩展欧拉定理，我们知道每一层的幂要 $\bmod$ 一个 $p,\varphi\left(p\right),\varphi\left(\varphi\left(p\right)\right),\ldots$ ，这是一个 $\varphi$ 套一个 $\varphi$ 的东西。

根据  [P3747 相逢是问候](https://www.luogu.com.cn/problem/P3747) 的结论，$O\left(\log{p}\right)$ 层以后它的值就是 $1$ 了。

> 证明：若 $p$ 是偶数，则 $p\gets\varphi(p)$ 至少会少一个质因数 $2$，也就是少了 $\dfrac12$。若 $p$ 是奇数且为质数，则 $\varphi(p)=\dfrac{q-1}{q}\cdot{p}$，其中 $q$ 是 $p$ 的最小质因数，则 $2\mid{q-1}$，$\varphi(p)$ 成了偶数。所以最多 $2\log_2p$ 次后变成 $1$。

显然，我们直接枚举 $b$ 就可以了。

### Subtask 3

我们还是试着推一下式子：

$$\begin{aligned}a\uparrow^3b&=a\uparrow^2\left(a\uparrow^3\left(b-1\right)\right)\end{aligned}$$

怎么办，好大啊！

这就启示我们看小一点的情况。

当 $a=3,b=3$ 时，$3\uparrow^33=3\uparrow^2\left(3\uparrow^32\right)=3\uparrow^2\left(3\uparrow^2\left(3\uparrow^31\right)\right)=3\uparrow^2\left(3\uparrow^23\right)=3\uparrow^23^{27}$。注意到 $2\log_210^9+7<100$，而 $3^{27}$ 则巨大无比，是一个 $13$ 位数，可想而知，$a,b$ 更大会怎么样。

所以我们只需要特判 $a=2$ 的情况，然后 $a>2$ 时，算 $a\uparrow^32,a\uparrow^33$ 就可以了，其中 $a\uparrow^33=a\uparrow^2\left(a\uparrow^3{2}\right)$ 里的 $a\uparrow^32$ 根据前面的讨论，可以直接当作一个大于 $2\log_2{p}$ 的数就可以了。

### 代码

```cpp
//Sparks Fly.
//I don't think you should wait.
//i think u should SpeakNow. 
#include<bits/stdc++.h>
#define int long long
using namespace std;
int prime[10005],phi[50005],cnt;
bitset<50005> used;
inline void sieve(int n)
{
	phi[1]=1;
	for(int i=2;i<=n;i++)
	{
		if(!used[i])	prime[++cnt]=i,phi[i]=i-1;
		for(int j=1;j<=cnt&&i*prime[j]<=n;j++)
		{
			used[i*prime[j]]=1;
			phi[i*prime[j]]=phi[i]*(prime[j]-1);
			if(i%prime[j]==0){phi[i*prime[j]]=phi[i]*prime[j];break;}
		}
	}
}
int a,n,b,p;
inline int BSGS(int a,int b,int mod)
{
	if(b==1)	return 0;
	int t=ceil(sqrt(mod));
	unordered_map<int,int> mp;
	int z=1;
	for(int i=0;i<t;i++)
		mp[1ll*b*z%mod]=i,z=1ll*z*a%mod;
	int p=1;
	for(int i=1;i<=t;i++)
	{
		p=1ll*z*p%mod;
		if(mp.count(p))	return i*t-mp[p];
	}
	return -1;
}
int getphi(int x)//
{
    int vl=x;
    for(int i=1;i<=cnt&&1ll*prime[i]*prime[i]<=x;i++)
		if(x%prime[i]==0)
	    {
	        vl-=vl/prime[i];
	        while(x%prime[i]==0) x/=prime[i];
	    }
    if(x>1) vl-=vl/x;
    return vl;
}
struct point{
	int x;bool ov;
};
point qp(int a,int b,int mod)
{
    int res=1;bool flg=false;
    if(a>=mod)	flg=true,a%=mod;
    while(b)
    {
        if(b&1){res=res*a;if(res>=mod) flg=true,res%=mod;}
        b>>=1;if(!b)	break;
        a=a*a;if(a>=mod)	flg=true,a%=mod;
    }
    return (point){res,flg};
}
int Phi[202];
point ptower(int a,int n,int id)
{
    int m=Phi[id],pm=Phi[id+1];
    if(m==1)	return(point){0,true};
    if(n==0)	return(point){1,false};
    point tmp=ptower(a,n-1,id+1);
    if(tmp.ov)	tmp.x+=pm;
    point ans=qp(a,tmp.x,m);
    return ans;
}
void solve()
{
    if(b==1||p==1){puts("0");return;}
    b%=p;
    if(n==1){printf("%lld\n",BSGS(a,b,p));return;}
    Phi[1]=p;int tot=1;
    while(true)//
    {
        tot++;
        if(Phi[tot-1]>50000)Phi[tot]=getphi(Phi[tot-1]);
        else    Phi[tot]=phi[Phi[tot-1]];
        if(Phi[tot]==1)	break;
    }
    if(n==2)
    {
        for(int i=1;i<=tot;i++)
        {
            int pt=ptower(a,i,1).x;
            if(pt==b){printf("%lld\n",i);return;}
        }
        puts("-1");
    }
    if(n==3)
    {
        if(a==1){puts("-1");return;}
        if(b==a%p){puts("1");return;} 
        if(a==2)
        {
            if(b==4%p)	puts("2");
            else if(b==65536%p)	puts("3");
            else if(b==ptower(a,60,1).x%p)	puts("4");
            else puts("-1");
            return;
        }
        if(b==ptower(a,a,1).x)puts("2");
        else if(b==ptower(a,60,1).x)puts("3");
        else puts("-1");
    }
}
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
signed main()
{
	sieve(50000);
    int tc=read();
    while(tc--)
    {
    	a=read(),n=read(),b=read(),p=read();
    	solve();
	}
    return 0;
}//Yuki
```

---

## 作者：Mars_Dingdang (赞：0)

数论题，不知道和根号分治有什么关系。

手玩发现，高德纳箭头 $a\uparrow^1b=a, a\uparrow^2b=\text{TREE}(a,b)$ 表示 $b$ 个 $a$ 的幂塔，$a\uparrow^3 b=a\uparrow\uparrow (a\uparrow^3 (b-1))$ 是一个很大的数。

对于 $n=1$，求解 $a^x\equiv b\bmod p$ 是离散对数问题，用 BSGS 即可。思路是记 $mod=M$，$x=A\lceil\sqrt M\rceil-B,0\le A,B\le \lceil\sqrt M\rceil$。然后转化为 $a^{A\lceil\sqrt M\rceil}\equiv ba^B \bmod p$。$O(\sqrt M)$ 枚举 $B$ 然后把右边所有可能取值用 unordered_map 存储，再枚举左边即可。

对于 $n=2$，我们知道 $\varphi(p)$ 连续迭代 $O(\log p)$ 次之后会得到 $1$。证明是奇数 $\varphi$ 为偶数，偶数的 $\varphi(x)\le \dfrac x 2$。所以我们枚举 $x$ 的个数就是 $O(\log p)$ 的。

对于 $n=3$，高德纳箭头表示出来的数是 $a$ 的幂塔，并且幂塔的层数也是一个高德纳箭头。这个层数可想而知地远超过 $O(\log p)$，除了一些边界条件如 $a=1,a=2,b\equiv a\pmod p$ 就只需要枚举 $x=2$ 和 $x=3$ 的情况即可。

[代码](https://www.luogu.com.cn/record/144176869)。

---

## 作者：IdnadRev (赞：0)

好像挺简单的。

$n=1$ 就是萌萌 BSGS。

$n=2$ 你手动画出来就是一个幂塔 $a^{a^{a^{a^{\cdots}}}}$（共 $n$ 个 $a$），你解一层之后哦 BSGS 模数就会变为它的欧拉函数值，也就是嵌套层数不超过 $O(\log n)$。

实际上只需要暴力枚举答案然后判断即可。

$n=3$ 的做法是类似的，你解一层幂塔之后模数也会变成欧拉函数，所以暴力枚举答案随便算算就好了。

还有一种做法，就是因为幂塔的高度高于 $2\log p$ 就没有意义了，而暴力展开一层可以发现后面的数字巨大，所以对于 $b>3$ 都满足 $a\uparrow^3 b=a \uparrow^3 3$。

暴力算 $a\uparrow^3 2$ 与 $a\uparrow^3 3$ 即可。

不太想写代码啊 QAQ。

复杂度 $O(T\sqrt p\log p)$。

---


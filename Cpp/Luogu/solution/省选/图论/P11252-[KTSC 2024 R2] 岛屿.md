# [KTSC 2024 R2] 岛屿

## 题目背景

**请使用 C++17 或 C++20 提交本题**

你需要在程序开头加入如下代码：

```cpp
#include<vector>
#include<array>
void construct_two_trees(int N, std::vector<int> U, std::vector<int> V);
int add_vertex(int a, int b, int c);
void report(std::vector<std::array<int, 2>> tree);
```

## 题目描述

**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T1 「[섬](https://assets.ioikorea.kr/ioitst/2024/2/island/island_statement.pdf)」**

IOI 国建立在一个正 $N$ 边形的岛屿上。每个顶点代表一个区域，这些区域按顺时针方向依次编号为 $0, 1, \cdots, N-1$。IOI 国的道路网络由以下两种道路组成：

- **海滨道路**：海滨道路连接正 $N$ 边形相邻顶点对应的区域，共有 $N$ 条道路。也就是说，对于所有 $i$ $(0 \leq i \leq N-2)$，存在连接 $i$ 区域和 $i+1$ 区域的道路，并且存在连接 $N-1$ 区域和 0 区域的道路。
- **内陆道路**：内陆道路连接不直接相邻的两个区域，共有 $N-3$ 条道路。这些道路除了端点外不相交，即它们对应于正 $N$ 边形中不相交的 $N-3$ 条对角线。

对于连接 $K$ 个区域的道路网络，如果道路集合 $T$ 满足以下条件，则称 $T$ 为一棵树：

- $|T|=K-1$
- 仅使用 $T$ 中的道路可以在所有区域之间通行。

树在连接所有区域的运输中起着重要作用。如果在一棵树的道路无法使用时，仍有另一棵树可以使用，这将大大提高稳定性。因此，如果道路网络中存在两棵树 $T_1$ 和 $T_2$，且 $T_1 \cap T_2 = \emptyset$，即没有任何道路重叠，则称该道路网络为良好道路网络。

IOI 国计划通过以下方式建设新的区域和道路，以构建良好道路网络：

- **区域建设**：对于区域 $a, b, c$，如果存在连接 $a$ 和 $b$、$b$ 和 $c$、$c$ 和 $a$ 的道路，则在这三个区域形成的三角形的内心处建立一个新区域 $d$，并连接 $a$ 和 $d$、$b$ 和 $d$、$c$ 和 $d$。新区域 $d$ 的编号从 $N$ 开始依次递增。对于相同的三个区域，不能进行多次区域建设，即每次建设使用的区域集合 $\{a, b, c\}$ 必须不同。

IOI 国可以进行多次区域建设，但希望通过尽可能少的建设次数，构建出没有重叠道路的两棵树的良好道路网络。请注意，良好道路网络不仅包括原有的 $N$ 个区域，还包括新建的区域。你需要帮助 IOI 国解决这个道路网络问题。即使没有最小化建设次数，也可以获得部分分数。

你需要实现以下函数：

```cpp
void construct_two_trees(int N, std::vector<int> U, std::vector<int> V);
```

- `U, V`：大小为 $N-3$ 的整数数组。对于所有 $i$ $(0 \leq i \leq N-4)$，存在连接 $U[i]$ 和 $V[i]$ 的内陆道路。
- 该函数只会被调用一次，你需要在该函数内调用后续定义的 `add_vertex` 函数进行区域建设，并找到不共享道路的两棵树，然后调用 `report` 函数报告结果。

```cpp
int add_vertex(int a, int b, int c);
```

- 该函数表示在区域 $a, b, c$ 之间进行区域建设。
- 在调用该函数之前，区域 $a, b, c$ 中任意两个区域必须直接相连。
- 对于相同的三个区域，不能多次调用该函数，即每次建设使用的区域集合 $\{a, b, c\}$ 必须不同。
- 该函数返回新建区域的编号。即，当该函数第 $j$ 次执行时，返回 $N-1+j$。
- 在调用 `report` 函数后，不应再调用该函数。

```cpp
void report(std::vector<std::array<int, 2>> tree);
```

- 该函数用于报告找到的树。
- 在 `construct_two_trees` 函数中，所有 `add_vertex` 函数调用结束后，必须准确调用两次该函数。
- 参数 `tree` 的每个元素是一个包含两区域编号的数组 `std::array<int, 2>`。区域编号的顺序无关紧要。
- 两次调用 `report(T1), report(T2)` 时，$T_1$ 和 $T_2$ 不应共享道路，并且每棵树的道路应能连接所有区域，包括新建区域。


## 说明/提示

对于所有输入数据，满足：

- $3 \leq N \leq 2\cdot 10^5$
- 对于所有 $i$ $(0 \leq i \leq N-4)$：
  - $0 \leq U[i], V[i] \leq N-1$
  - $U[i] \neq V[i]$
- 给定的 $U$ 和 $V$ 满足内陆道路的条件。

详细子任务附加限制及分值如下表所示。

| 子任务 | 分值 | 附加限制 |
| :-: | :-: | :-: |
| $1$ | $6$ | $N \leq 5$ |
| $2$ | $8$ | 存在一个区域与除自己外的所有区域直接相连 |
| $3$ | $14$ | 初始状态下，对于所有可能的区域对 $(a, b, c)$，连接这三个区域的三条道路中至少有一条是海滨道路 |
| $4$ | $21$ | $N \leq 5000$ |
| $5$ | $51$ | 无附加限制 |

当 `construct_two_trees` 函数正确解决了问题时，如果 `add_vertex` 的调用次数大于最小值但不超过 $N$，则可以获得 $40\%$ 的分数。如果 `add_vertex` 的调用次数超过 $N$，则无法获得分数。可以证明，在给定限制条件下，可以通过不超过 $N$ 次调用 `add_vertex` 构建良好道路网络。

## 样例 #1

### 输入

```
4
0 2```

### 输出

```
1
4
0 1
0 2
0 3
4 2
2
4
4 0
3 4
2 3
2 1
1
0 2 3```

# 题解

## 作者：Lavaloon (赞：1)

首先，题目要求最小化答案，那么我们不妨**先计算答案的下界**以考虑其可行性。

设加了 $K$ 个新点，那么边数变为 $N+N-3+3K$，点数变为 $N+K$。

能构造出来两棵树，这给出 $2N+3K-3\ge 2(N+K-1)$，解得 $K\ge 1$，即**至少进行一次建设。**

随便画一张图尝试进行”一次建设“的构造，**注意现在图有 $(N+1)$ 个点。**

既然是构造两棵树，那么对于任意一个点，都要和两种颜色的边相连。

假如删去一个点，问题规模变小且与原问题“**同构**”，这启示我们进行**递归构造：**

**一个点在什么条件下可以直接删去**，从而获得子问题？

- 假如一个点**恰与两条**不同色的边相连，那么这个点就可删去；

**是否始终存在可以被删去的点？**

- 若不存在任何一点可以删去，则每个点的度数 $\ge 3$，故总边数  $\ge \dfrac{3(N+1)}{2}$，而事实上总边数 $= 2N-2$；因此需要满足 $N+1\le 4$；即当剩余点数多于 $4$ 时，这个过程始终可以进行下去。

而对于恰有 $4$ 个点的图（其应是一个四阶完全图）的构造是容易的。

**故递归构造的可行性得证。**

![](https://cdn.luogu.com.cn/upload/image_hosting/lemddj4i.png)

**代码实现方面：**

**建图**：找到一个三元环（三角形）是容易的，比如你可以找一条在图形内部连接点 $i-1,i+1$（对 $N$ 取模意义下） 的边。这种边显然一定存在。**注意 $n=3$ 时特判。**

**递归**：维护每个点的度数，假如度数为 $2$ 即可将其删去进行递归。对度数的维护是简单的，比如你暴力地可以使用 set 实现。

**终止**：假如不满足上述条件，拿出剩下的那 $4$ 个点直接构造即可。

时间复杂度 $\mathcal{O}(N \log N)$。
```cpp
#include"island.h"
#include<bits/stdc++.h>
using namespace std;
#define pii pair<int,int>
#define mkp make_pair
#define fi first
#define se second
const int Mx=500005,p=998244353;
map<array<int,2>,bool>ed;
int deg[Mx];
set<int>e[Mx];
void construct_two_trees(int n,vector<int>U,vector<int>V){
	if(n==3){
		add_vertex(0,1,2);
		report({{0,1},{1,3},{3,2}});
   		report({{0,2},{0,3},{1,2}});
   		return;
	}
	set<pii>s;
	for(int i=0;i<n-3;i++){
		ed[{U[i],V[i]}]=ed[{V[i],U[i]}]=1;
		e[U[i]].insert(V[i]),e[V[i]].insert(U[i]);
		deg[U[i]]++,deg[V[i]]++;
	}
	for(int i=0;i<n;i++){
		deg[i]+=2;
		int u=(i+n-1)%n,v=(i+1)%n;
		e[u].insert(i),e[v].insert(i);
		e[i].insert(u),e[i].insert(v);
	}
	for(int i=0;i<n;i++){
		int u=(i+n-1)%n,v=(i+1)%n;
		if(ed[{u,v}]){
			add_vertex(u,i,v);
			e[u].insert(n),e[v].insert(n),e[i].insert(n);
			e[n].insert(u),e[n].insert(v),e[n].insert(i);
			deg[u]++,deg[v]++,deg[i]++,deg[n]+=3;
			break;
		}
	}
	for(int i=0;i<=n;i++) s.insert({deg[i],i});
	vector<array<int,2> >Red,Blue;
    while(!s.empty()&&(s.begin()->fi)==2){
    	int u=s.begin()->se;
    	s.erase(s.begin());
    	for(int v:e[u]) e[v].erase(u);
    	int x=*e[u].begin(),y=*e[u].rbegin();
    	Red.push_back({u,x}),Blue.push_back({u,y});
    	s.erase({deg[x],x}),s.erase({deg[y],y});
    	deg[x]--,deg[y]--;
    	s.insert({deg[x],x}),s.insert({deg[y],y});
    	e[u].clear();
	}
	int rem[4]={0},tot=0;
	for(pii _:s) rem[tot++]=_.se;
	Red.push_back({rem[0],rem[1]}),Red.push_back({rem[1],rem[3]}),Red.push_back({rem[3],rem[2]});
	Blue.push_back({rem[0],rem[2]}),Blue.push_back({rem[0],rem[3]}),Blue.push_back({rem[1],rem[2]});
    report(Red);
    report(Blue);
}
```

---

## 作者：McIron233 (赞：1)

设你造了 $A$ 个新点，那么原图就多了 $3A$ 个新边。

让条件更严一点：两棵树恰好覆盖了所有的边，包括新边。

那么有等式

$$
2(A+N-1)=N+(N-3)+3A
$$

解得 $A=1$。完全可以只造一个点。

考虑将这个点放在哪里。

注意到原图本质上是被分割成了 $N-2$ 个小三角形，根据这一性质我们可以在最边上的小三角形造新点。那么在组装第一棵树时，考虑 BFS。设造新点时用的原有点是 $a,b,c$，造出来的新点是 $d$。初始时加入三个点：$d,a,b$。然后正常 BFS 就行了。这就是第一棵树。余下的边组成第二棵树。

---

## 作者：Mr_罗 (赞：1)

~~讨论区已经有大佬提供 SPJ 了，为啥你谷还是暂无 SPJ 啊~~

**题意** 给定一个 $n$ 边形及其一个三角剖分，每次可以将其中一个三角形通过在中间插入一个点再剖成三个三角形，要求通过最少的操作次数使得可以在新图形中找到两棵没有重边的生成树。$n\le 2\times 10^5$ 。

**思路** 首先看到初始有 $n$ 个点 $2n-3$ 条边，操作一次变成 $n+1$ 个点 $2n$ 条边，至少在边的数量上足够支撑两棵生成树。

于是提出猜想：最少操作次数一定是一次。

考虑怎么构造。注意到不考虑无穷面的原图（未操作）的对偶图是一棵二叉树（根：有一条边是边界；因为当且仅当共享边才在对偶图中有连边，因此每个点度数不超过 $3$），那么自然想到把三角形排成二叉树的形状（不妨把 $0\sim n-1$ 对应的三角形当作根）：

![](https://pic.imgdb.cn/item/67602d7dd0e0a243d4e4f5b5.png)

对于每一个三角形，把左下那条边分给第一棵生成树，右下给第二棵，注意到这样一定都是连通的。

现在第一棵树没有 $n-1$ ，第二棵没有 $0$ 。考虑操作根，得到新点 $n$ ，把 $0\sim n-1,m\sim n$ 分给第一棵树，把 $0\sim n,n\sim n-1$ 分给第二棵，这样就做完了。

[QOJ 提交记录](https://qoj.ac/submission/817283)。

---

## 作者：EuphoricStar (赞：0)

被诈骗了。

首先原来有 $n$ 个点和 $2n - 3$ 条边，而构造出两棵不交的树需要 $2n - 2$ 条边，所以不操作肯定不行。

操作一次后有 $n + 1$ 个点和 $2n$ 条边，边数恰好足够，所以我们思考只操作一次是否可行。

答案是可以。我们可以选一个边上的小三角形进行操作。然后构造可以每次删除度数为 $2$ 的点，其恰好有一条边属于 $T_1$，恰好有一条边属于 $T_2$。直到只剩 $4$ 个点时特殊构造。

可以证明点数 $> 4$ 时一定存在度数为 $2$ 的点。考虑初始的边构成了正 $n$ 边形的一个三角剖分，所以边缘的小三角形对应一个度数为 $2$ 的点。所以删度数为 $2$ 的点等价于删除最外面的小三角形。

时间复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<int, int> pii;

int add_vertex(int, int, int);
void report(vector< array<int, 2> >);

const int maxn = 200100;

int n, deg[maxn];
bool vis[maxn];
vector<int> G[maxn];

void construct_two_trees(int _n, vector<int> _u, vector<int> _v) {
	n = _n;
	for (int i = 0; i < n; ++i) {
		G[i].pb((i + 1) % n);
		G[(i + 1) % n].pb(i);
	}
	for (int i = 0; i < n - 3; ++i) {
		int u = _u[i], v = _v[i];
		G[u].pb(v);
		G[v].pb(u);
	}
	for (int i = 0; i < n; ++i) {
		deg[i] = (int)G[i].size();
	}
	vector< array<int, 2> > A, B;
	for (int u = 0; u < n; ++u) {
		if (deg[u] == 2) {
			int v = (u + n - 1) % n, w = (u + 1) % n;
			add_vertex(u, v, w);
			G[u].pb(n);
			G[n].pb(u);
			G[v].pb(n);
			G[n].pb(v);
			G[w].pb(n);
			G[n].pb(w);
			A.pb(array<int, 2>{u, v});
			A.pb(array<int, 2>{v, w});
			A.pb(array<int, 2>{w, n});
			B.pb(array<int, 2>{u, w});
			B.pb(array<int, 2>{u, n});
			B.pb(array<int, 2>{v, n});
			break;
		}
	}
	queue<int> q;
	for (int i = 0; i < n; ++i) {
		deg[i] = (int)G[i].size();
		if (deg[i] == 2) {
			q.push(i);
		}
	}
	while (q.size()) {
		int u = q.front();
		q.pop();
		if (vis[u]) {
			continue;
		}
		vis[u] = 1;
		int v = 0, w = 0;
		for (int x : G[u]) {
			if (!vis[x]) {
				(v ? w : v) = x;
				if ((--deg[x]) == 2) {
					q.push(x);
				}
			}
		}
		A.pb(array<int, 2>{u, v});
		B.pb(array<int, 2>{u, w});
	}
	report(A);
	report(B);
}
```

---

## 作者：Lijiangjun4 (赞：0)

# P11252 题解
发现题解区的代码有点抽象啊，那就自己写一篇吧。

## 解题思路

设需要进行 $x$ 次区域建设，由于每次区域建设会增加 $1$ 个点和 $3$ 条边，则最终会有 $n+(n-3)+3x=2n+3x-3$ 条边，$n+x$ 个点。需要拆成两棵树，则需要 $2(n+x-1)=2n+2x-2$ 条边，有式子：
$$
2n+3x-3 \geq 2n+2x-2
$$
解得:
$$
x \geq 1
$$
所以，我们至少进行 $1$ 次区域建设即可。

考虑如何只进行一次区域建设就满足条件。假设将第一棵树的边染成红色，将第二棵树的边染成蓝色。由于每一棵树都要覆盖到所有的点，所有点连出去的边都必须包含红蓝两种颜色。那么，对于度数为 $2$ 的点，连出去的边必为一红一蓝，我们应当优先处理这些点。

我们可以这样处理多少次呢？当所有点度数都 $\geq 3$ 时，我们就不能继续这样处理了（注意此时我们区域建设新增的点和边已经加入到图里了）。设此时有 $n'$ 个点，那么总边数 $\geq\dfrac{3n'}{2}$，而拆成两棵树需要 $2(n'-1)$ 条边，所以有：
$$
\dfrac{3n'}{2}\geq 2(n'-1)
$$
解得：
$$
n' \leq 4
$$
所以，在点数 $>4$ 时，我们一定能找到一个度为 $2$ 的点。当点数 $=4$ 时，进行特殊构造即可。如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/qdk5iag9.png)

**综上，我们解决问题的全过程为：建图，找到所有度数为 $2$ 的点并将两条边染成红色和蓝色，最后剩三个点区域建设并特殊构造即可。**

## 代码实现
建图：
用 `set<int> e[maxN]` 来保存每个点与哪些点相连，用 `int deg[maxN]` 来保存每个点的度数。
```cpp
set<int> e[maxN];
int deg[maxN];
void construct_two_trees(int n, std::vector<int> U, std::vector<int> V)
{
    for(int i=0;i<=n-2;i++)
	{
		e[i].insert(i+1);
		e[i+1].insert(i);
		deg[i]++;
		deg[i+1]++;
	}
	e[0].insert(n-1);
	e[n-1].insert(0);
	deg[0]++;
	deg[n-1]++;
	for(int i=0,j=0;i<U.size();i++,j++)
	{
		e[U[i]].insert(V[i]);
		e[V[i]].insert(U[i]);
		deg[U[i]]++;
		deg[V[i]]++;
	}
    /**/
}
```
处理度数为 $2$ 的点：

类似于拓扑排序，用 `queue<int> q` 来保存每个度数为 $2$ 的点，每次取出队头，对队头进行操作，并将与之相连的两个点度数减一，如果又出现了度数为 $2$ 的点，加入队尾。最后剩三个点。

```cpp
queue<int> q;
void construct_two_trees(int n, std::vector<int> U, std::vector<int> V)
{
    /**/
    for(int i=0;i<n;i++)
	{
		if(deg[i]==2)
		{
			q.push(i);
		}
	}
	for(int i=0;i<n-3;i++)
	{
		int now=q.front();
		q.pop();
		int l=*e[now].begin();
		int r=*e[now].rbegin();
		red.push_back({now,l});
		blue.push_back({now,r});
		e[l].erase(now);
		e[r].erase(now);
		deg[l]--;
		deg[r]--;
		if(deg[l]==2) q.push(l);
		if(deg[r]==2) q.push(r);
	}
    /**/
}
```
区域建设：
```cpp
queue<int> q;
void construct_two_trees(int n, std::vector<int> U, std::vector<int> V)
{
    /**/
    int a=q.front();q.pop();
	int b=q.front();q.pop();
	int c=q.front();q.pop();
	int d=add_vertex(a,b,c);
	red.push_back({a,b});red.push_back({b,d});red.push_back({d,c});
	blue.push_back({a,c});blue.push_back({a,d});blue.push_back({b,c});
	report(red);
	report(blue);
	return;
}
```
时间复杂度 $O(n \log n)$，完整代码如下：
```cpp
#include<bits/stdc++.h>
#include"island.h"//提交时这句话千万别加！！！
using namespace std;
int add_vertex(int a, int b, int c);
void report(std::vector<std::array<int, 2>> tree);
const int maxN=200005;
vector<array<int,2>> red,blue;
set<int> e[maxN];
int deg[maxN];
queue<int> q;
void construct_two_trees(int n, std::vector<int> U, std::vector<int> V)
{
	for(int i=0;i<=n-2;i++)
	{
		e[i].insert(i+1);
		e[i+1].insert(i);
		deg[i]++;
		deg[i+1]++;
	}
	e[0].insert(n-1);
	e[n-1].insert(0);
	deg[0]++;
	deg[n-1]++;
	for(int i=0,j=0;i<U.size();i++,j++)
	{
		e[U[i]].insert(V[i]);
		e[V[i]].insert(U[i]);
		deg[U[i]]++;
		deg[V[i]]++;
	}
	for(int i=0;i<n;i++)
	{
		if(deg[i]==2)
		{
			q.push(i);
		}
	}
	for(int i=0;i<n-3;i++)
	{
		int now=q.front();
		q.pop();
		int l=*e[now].begin();
		int r=*e[now].rbegin();
		red.push_back({now,l});
		blue.push_back({now,r});
		e[l].erase(now);
		e[r].erase(now);
		deg[l]--;
		deg[r]--;
		if(deg[l]==2) q.push(l);
		if(deg[r]==2) q.push(r);
	}
	int a=q.front();q.pop();
	int b=q.front();q.pop();
	int c=q.front();q.pop();
	int d=add_vertex(a,b,c);
	red.push_back({a,b});red.push_back({b,d});red.push_back({d,c});
	blue.push_back({a,c});blue.push_back({a,d});blue.push_back({b,c});
	report(red);
	report(blue);
	return;
}
```

---


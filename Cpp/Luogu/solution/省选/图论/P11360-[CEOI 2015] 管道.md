# [CEOI 2015] 管道

## 题目描述

**简要题意**：$\,$ 给出一个 $N$ 点 $M$ 边的无向图，不保证连通。将每个联通块视为子图，请求出每一个子图中的桥。**你只有 16 MB 的内存空间**。

---

在 Cahoots 的国度里，Lomikel 是掌管管道的神。他管理水管、排水沟、下水道，甚至地铁隧道。人们在许许多多的圣泉旁敬拜他，这些圣泉由一个巨大的管道网络连接起来。每个管道直接连接两泓圣泉。

每个假期，Supreme Plumber（Lomikel 的最高祭司）会进行一场十分复杂的仪式，包括以管道运送圣水。

有时，Lomikel 的愤怒会导致管道破裂，所以 Plumber 不得不使用其他路径，使得圣水在破裂的管道周围流动。然而凡事总有不尽人意之处，对于某些管道，不存在不同的路径。这些管道被称为“关键管道”，Plumber 必须特别注意。您可以在下图中看到用粗线标出的关键管道。

![](https://i.loli.net/2018/08/12/5b6f9bfa600d8.png)

你的任务是为 Plumber 找到所有关键管道。然而，网络错综复杂，而你只有非常有限的内存。**空间限制仅为 16 MB**。

## 说明/提示

$N$ 和 $M$ 的上限如下表所示：

|数据点|1|2|3|4|5|6|7|8|9|10|
|-|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$N\le$|$100$|$5000$|$4000$|$10^5$|$3\times 10^4$|$7\times 10^4$|$8\times 10^4$|$10^5$|$10^5$|$10^5$|
|$M\le$|$200$|$1.5\times 10^4$|$6\times 10^5$|$1.2\times 10^6$|$1.5\times 10^6$|$2\times 10^6$|$3\times 10^6$|$4\times 10^6$|$5\times 10^6$|$6\times 10^6$|

## 样例 #1

### 输入

```
10 11
1 7
1 8
1 6
2 8
6 7
5 8
2 5
2 3
2 4
3 4
10 9```

### 输出

```
1 8
9 10```

# 题解

## 作者：WorldMachine (赞：12)

小水题，之前想过这样的东西，碰巧看到了这道题就做一下吧。

这个题 tarjan 肯定是做不了的，因为 $\mathcal O(m)$ 的空间开不下。

割边一定在生成树上，那我们弄出原图的一棵生成树，现在就是要求有哪些树边没有被覆盖。对每条非树边 $(u,v)$，我们随机一个权值 $w$，将 $a_u$ 加上 $w$，$a_v$ 减去 $w$。这样 $(u,v)$ 这条边的影响刚好会在 $\text{lca}(u,v)$ 处被消去，随机权值下如果 $v$ 子树内的 $a_i$ 之和为 $0$，那么 $(\text{fa}_v,v)$ 有很大概率是一条割边。

时间复杂度 $\mathcal O(n\alpha(n)+m)$，瓶颈在于并查集，所以通常情况下没啥优势。

代码已省去快读。

```cpp
#include <bits/stdc++.h>
using namespace std;
// namespace IO
#define cin io
#define cout io
typedef long long ll;
const int N = 100005, M = 6e6 + 5;
int n, m, fa[N], siz[N];
ll a[N];
vector<int> G[N];
mt19937 rnd(time(0));
int get(int x) { return x == fa[x] ? x : fa[x] = get(fa[x]); }
void dfs(int u, int f) {
	for (int v : G[u]) {
		if (v == f) continue;
		dfs(v, u), a[u] += a[v];
		if (!a[v]) cout << u << ' ' << v << '\n';
	}
}
int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) fa[i] = i, siz[i] = 1;
	int u, v, fu, fv;
	ll w;
	while (m--) {
		cin >> u >> v;
		fu = get(u), fv = get(v);
		if (fu != fv) {
			if (siz[fu] > siz[fv]) swap(fu, fv);
			fa[fu] = fv, siz[fv] += siz[fu];
			G[u].emplace_back(v), G[v].emplace_back(u);
		} else w = rnd(), a[u] += w, a[v] -= w;
	}
	for (int i = 1; i <= n; i++) if (i == fa[i]) dfs(i, 0);
}
```

---

## 作者：RAYMOND_7 (赞：6)

首先 $O(m)$ 的空间开不下。

其次，实测 $10^5$ 大小空 ```vector<int>``` 需要消耗 $2.5 MB$ 内存，非常不牛。

------------------------

## 做法

拉出一个生成树，在此基础上对于每个连通块，找出 $O(siz)$ 条有效路径覆盖树边，容易发现这些非树边应该不构成环，否则必然可以删去一条边并保持覆盖情况不变。

这样用两个并查集维护一下，只需要保留至多 $2n$ 条边，由于需要树上差分，稍微劣一些的实现是倍增求 $\text{LCA}$，空间复杂度 $O(n \log n)$，可以轻松通过。

代码供参考。

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
#include <vector>
#include <queue>
#include <cassert>

using namespace std;

#define PII pair<int,int>
#define x first
#define y second
#define For(i, l, r) for(int i = l; i <= r; i ++)
#define Rep(i, l, r) for(int i = l; i >= r; i --)

bool START;

void in(int &x)
{
	char c = getchar(); int op = 1;
	while(c > '9' || c < '0') op *= (c == '-' ? -1 : 1), c = getchar();
	for(x = 0; c >= '0' && c <= '9'; c = getchar()) x = x * 10 + c - '0'; x *= op;
}

const int N = 1e5 + 50;

int n, m, ff[N], tot, Fa[N], fa[18][N], dep[N], cf[N];
PII e[N];
int cnt, ee[N];
vector<int> G[N];

int find(int x) {return x == ff[x] ? x : ff[x] = find(ff[x]);}
int Find(int x) {return x == Fa[x] ? x : Fa[x] = Find(Fa[x]);}

void dfs(int u, int pa)
{
	for(int v : G[u]) if(v != pa)
	{
		fa[0][v] = u;
		dep[v] = dep[u] + 1;
		dfs(v, u);
	}
}

int lca(int u, int v)
{
	if(dep[u] < dep[v]) swap(u, v);
	int d = dep[u] - dep[v];
	For(i, 0, 17) if(d >> i & 1) u = fa[i][u];
	if(u == v) return u;
	Rep(i, 17, 0) if(fa[i][u] != fa[i][v]) u = fa[i][u], v = fa[i][v];
	return fa[0][u];
}

void Dfs(int u, int pa)
{
	for(int v : G[u]) if(v != pa)
	{
		Dfs(v, u);
		cf[u] += cf[v];
	}
	if(pa && !cf[u]) ee[++ cnt] = u;
}

bool ENDPOS = 0;
int main()
{
	in(n); in(m);
	For(i, 1,  n) ff[i] = Fa[i] = i;
	while(m --)
	{
		int u, v; in(u); in(v);
		if(find(u) != find(v))
		{
			G[u].push_back(v); G[v].push_back(u);
			ff[find(u)] = find(v);
		}
		else if(Find(u) != Find(v))
		{
			Fa[Find(u)] = Find(v);
			e[++ tot] = {u, v};
		}
	}
	For(i, 1, n) if(find(i) == i) dfs(i, 0);
	For(i, 1, 17) For(u, 1, n) fa[i][u] = fa[i - 1][fa[i - 1][u]];
	For(i, 1, tot)
	{
		int u = e[i].x, v = e[i].y;
		cf[u] ++; cf[v] ++; cf[lca(u, v)] -= 2;
	}
	For(i, 1, n) if(find(i) == i) Dfs(i, 0);
	For(i, 1, cnt) printf("%d %d\n", fa[0][ee[i]], ee[i]);
	cerr << (&ENDPOS - &START) * 1.0 / 1024 / 1024 << endl;
	return 0;
}
```

---

## 作者：Starriverlight (赞：4)

## 思路

求无向图的桥，但是卡空间，不可以直接 tarjan。

容易想到 LCT 动态维护边双连通分量。因为我们需要输出边具体是什么，所以我们把边同样化作点放入 LCT 中维护，每次加边时若两点未联通就让两点与对应边的点连边，联通就把动态树上两点之间的路径合成一个边双连通分量。因为要和并多个点，就再套一个并查集即可。

时间复杂度 $\mathcal{O(m\log n+n\alpha(n))}$。

## AC code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define f(i,j,n) for(int i=j;i<=n;i++)
#define F(i,n,j) for(int i=n;i>=j;i--)
#define updmax(a,b) a=max(a,b)
#define updmin(a,b) a=min(a,b)
#define pb push_back
using namespace std;
namespace fsd{
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,MAXSIZE,stdin),p1==p2)?EOF:*p1++)
	const int MAXSIZE=1<<20;
	char buf[MAXSIZE],*p1,*p2;
	inline int read(){
		int ak=0,ioi=1;char c=gc();
		while(!isdigit(c)){if(c=='-')ioi=-1;c=gc();}
		while(isdigit(c))ak=ak*10+(c^48),c=gc();
		return ak*ioi;
	}
	inline char readc(){
		char p=gc();
		while(!((p<='z'&&p>='a')||(p<='Z'&&p>='A'))){p=gc();}
		return p;
	}
}
using namespace fsd;
const int N=1e5+10;
int n,m;
struct LCT{
	int fath[N*2];
	int getfa(int k){return k==fath[k]?k:fath[k]=getfa(fath[k]);}
	struct abc{
		int son[2];
		int fp,fq;
		int tg_revs,fath;
		void reverse(){
			tg_revs^=1,swap(son[0],son[1]);
		}
	}Tree[N*2];
#define lx(k) Tree[k].son[0]
#define rx(k) Tree[k].son[1]
#define Gt(k) (Tree[Tree[k].fath].son[1]==k)
#define isroot(k) (Tree[Tree[k].fath].son[0]!=k&&Tree[Tree[k].fath].son[1]!=k)
	int del[N*2],dl=0,cnt=0;
	int nwid(){return dl?del[dl--]:++cnt;}
	int nwnode(int fp,int fq){
		int T=nwid();
		fath[T]=T;
		Tree[T]={0,0,fp,fq,0,0};
		return T;
	}
	void pushdown(int k){if(Tree[k].tg_revs)Tree[lx(k)].reverse(),Tree[rx(k)].reverse(),Tree[k].tg_revs=0;}
	void update(int k){
		if(!isroot(k))update(Tree[k].fath=getfa(Tree[k].fath));
		pushdown(k);
	}
	void rotate(int k){
		int y=Tree[k].fath,z=Tree[y].fath,c=Gt(k);
		if(!isroot(y))Tree[z].son[Gt(y)]=k;
		Tree[y].son[c]=Tree[k].son[c^1],Tree[Tree[k].son[c^1]].fath=y;
		Tree[k].son[c^1]=y,Tree[y].fath=k,Tree[k].fath=z;
	}
	void splay(int k){
		update(k);
		for(;!isroot(k);rotate(k)){
			if(!isroot(Tree[k].fath))rotate(Gt(k)==Gt(Tree[k].fath)?Tree[k].fath:k);
		}
	}
	void access(int k){
		for(int ls=0;k;k=(Tree[k].fath=getfa(Tree[k].fath))){
			splay(k),rx(k)=ls,ls=k;
		}
	}
	void make_root(int k){
		access(k),splay(k),Tree[k].reverse();
	}
	int find_root(int k){
		access(k),splay(k),pushdown(k);
		while(lx(k))k=lx(k),pushdown(k);
		splay(k);
		return k;
	}
	void PUT(int k,int T){
		if(!k)return;
		if(k>n)del[++dl]=k,Tree[k].fp=Tree[k].fq=0;
		else fath[k]=T;
		PUT(lx(k),T),PUT(rx(k),T);
	}
}_lct;
void gs(){
	n=read(),m=read();
	f(i,1,n)_lct.nwnode(0,0);
	f(i,1,m){
		int l=read(),r=read();
		int ls=l,rs=r;
		l=_lct.getfa(l),r=_lct.getfa(r);
		if(_lct.make_root(l),_lct.find_root(r)!=l){
			int T=_lct.nwnode(ls,rs);
			_lct.Tree[l].fath=T,_lct.Tree[T].fath=r;
		}else{
			_lct.PUT(l,l);
			_lct.Tree[l].son[0]=_lct.Tree[l].son[1]=0;
		}
	}
	f(i,1,_lct.cnt)if(_lct.Tree[i].fp)printf("%lld %lld\n",_lct.Tree[i].fp,_lct.Tree[i].fq);
}
signed main(){
//	freopen("p_jx.out","r",stdin);
//	freopen("pipe.out","w",stdout);
#ifndef XQZ
	freopen("pipe.in","r",stdin);
	freopen("pipe.out","w",stdout);
#endif
#ifdef NXD
	int t=0;cin>>t;while(t--)
#endif
		gs();
	return 0;
}
//sample ok
//big data ok
```

---

## 作者：xzf_200906 (赞：3)

我们有高超的卡空间技巧。

首先这题肯定是不能存下所有边的，于是考虑用并查集找出所有树边，再考虑所有其它的非树边，把它所覆盖的所有树边全部标记，最后没有标记的边就是桥边。但是这样就要在动态加边的情况下求出两个点的 LCA，而这是我们绝对不想看到的。于是我们考虑有什么方法来规避掉 LCA 的计算。我们可以发现对于一条非树边 $(u,v)$，如果将其的两个端点 $u,v$ 同时异或上一个值，那么不管它们的 LCA 是什么，它们总会在那里互相抵消。联想到异或哈希，我们可以设计出如下算法：
+ 对于读进来的一条边 $(u,v)$，如果 $u,v$ 不在一个连通块中，那么将它们所在的连通块合并，并将其加入到边集中。否则设一个数组 $w$，初值为 $0$，将 $w_u$ 和 $w_v$ 异或上一个随机值。
+ 在所有的边处理完之后，对整张图（此时是一个森林）进行 DFS，对于一个点 $u$，其父亲为 $fa$，边 $(fa,u)$ 为桥边当且仅当 $u$ 子树内的 $w$ 的异或和为 $0$。

这个算法只会存储不超过 $n-1$ 条边，足以通过。但是对整棵树进行 DFS 还是太愚蠢了。我们有更好的科技可以在更优的时空开销内进行子树信息的统计。使用[这篇文章](https://www.luogu.com.cn/article/8bmucjk8)中的算法（以及不带按秩合并的并查集）可以在 1.7MB 内通过该题，喜提本题公开代码中的空间开销最优解。

代码：
```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
bool _st;
int fa[100005],xsum[100005],deg[100005];
int find(int p){
	if(fa[p]) return fa[p]=find(fa[p]);
	return p;
}
bool merge(int u,int v){
	u=find(u),v=find(v);
	if(u==v) return 0;
	fa[u]=v;
	return 1;
}
unsigned w[100005];
bool _ed;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int n,m;
	cin>>n>>m;
	mt19937 random(time(0));
	while(m--){
		int u,v;
		cin>>u>>v;
		if(merge(u,v)){
			xsum[u]^=v;
			xsum[v]^=u;
			deg[u]++;
			deg[v]++;
		}
		else{
			unsigned val=random();
			w[u]^=val;
			w[v]^=val;
		}
	}
	for(int i=1;i<=n;i++){
		int p=i;
		while(deg[p]==1){
			deg[p]=0;
			if(w[p]==0) cout<<xsum[p]<<' '<<p<<'\n';
			w[xsum[p]]^=w[p];
			xsum[xsum[p]]^=p;
			deg[xsum[p]]--;
			p=xsum[p];
		}
	}
	cerr<<(&_st-&_ed)/1048576.0<<'\n';
	return 0;
}
```

---

## 作者：CaiZi (赞：3)

很好玩的题！

可以容易发现，割边只有可能在图的生成树上，所以先使用并查集得到任意一棵生成树。然后对于每条非树边 $(u,v)$，在这颗树上 $u$ 到 $v$ 的路径上的边，都不可能为割边。

然而我们大量的 $(u,v)$ 是无用的，不难发现我们可以对每条非树边再求一棵生成树，这样剩下有用的 $(u,v)$ 个数就最多只有 $n-1$ 个了。

使用倍增维护 LCA，树上差分判断一条边是否被覆盖。

时间复杂度 $O(n\log n+m)$，空间复杂度 $O(n\log n)$，稍劣，如果将倍增维护 LCA 换为树剖，可以做到空间复杂度 $O(n)$。

代码展示：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,u,v,x[100001],y[100001],c,p1[100001],p2[100001],fa[18][100001],dep[100001],val[100001];
bool vis[100001];
vector<int>g[100001];
inline int find1(int i){
	return p1[i]==i?i:p1[i]=find1(p1[i]);
}
inline int find2(int i){
	return p2[i]==i?i:p2[i]=find2(p2[i]);
}
inline void dfs(int i,int j){
	fa[0][i]=j;
	dep[i]=dep[j]+1;
	for(int k=1;k<=17;k++){
		fa[k][i]=fa[k-1][fa[k-1][i]];
	}
	for(int k:g[i]){
		if(k!=j){
			dfs(k,i);
		}
	}
}
inline int lca(int i,int j){
	if(dep[i]<=dep[j]){
		swap(i,j);
	}
	for(int k=17;k>=0;k--){
		if(dep[fa[k][i]]>=dep[j]){
			i=fa[k][i];
		}
	}
	if(i==j){
		return i;
	}
	for(int k=17;k>=0;k--){
		if(fa[k][i]!=fa[k][j]){
			i=fa[k][i];
			j=fa[k][j];
		}
	}
	return fa[0][i];
}
inline void calc(int i){
	vis[i]=true;
	for(int k:g[i]){
		if(!vis[k]){
			calc(k);
			val[i]+=val[k];
			if(val[k]==0){
				cout<<i<<' '<<k<<'\n';
			}
		}
	}
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		p1[i]=p2[i]=i;
	}
	while(m--){
		cin>>u>>v;
		if(find1(u)!=find1(v)){
			p1[find1(u)]=find1(v);
			g[u].push_back(v);
			g[v].push_back(u);
		}
		else if(find2(u)!=find2(v)){
			p2[find2(u)]=find2(v);
			c++;
			x[c]=u;
			y[c]=v;
		}
	}
	for(int i=1;i<=n;i++){
		if(dep[i]==0){
			dfs(i,0);
		}
	}
	for(int i=1;i<=c;i++){
		val[x[i]]++;
		val[y[i]]++;
		val[lca(x[i],y[i])]-=2;
	}
	for(int i=1;i<=n;i++){
		if(!vis[i]){
			calc(i);
		}
	}
	return 0;
}
```

---

## 作者：MoonCake2011 (赞：3)

求割边，但是 16 MB。

我们不能将图建出用 Tarjan 算法了。

那怎么办呢。

首先，求割边不建生成树就是找~~粑粑~~。

就连 $O(m)$ 空间的 Tarjan 也是变相的有个生成树。

建树空间是 $O(n)$ 的。

接着对于每条非树边 $(u,v)$，我们发现在原树上路径 $(u,v)$ 上的边一定不是割边，可以标记舍去。

那怎么维护这个操作呢，现在分为了三种方法。

## 法一，读入查找，树上差分

我们建好树后，对标准输入进行查找，就可以二次读入。

这样直接树上差分即可。

但我并不会对标准输入进行查找，并且这样有点卡常。

只能用在线 LCA。

时间复杂度 $O(n+m\log n)$。

## 法二，排除状态，树上差分

我们建好树后，发现我们对非树边，也只有任意生成树的非树边有用。

具体可以这样解释。

可以证明一个有 $k$ 条边环上的 $k-1$ 条边的贡献能够覆盖剩下 $1$ 条边的贡献。

于是代码就简单了。

可以用离线 LCA。

用树剖 LCA，时间复杂度 $O(n\log n+m)$。

用离线的 Tarjan LCA，时间复杂度 $O(n+m)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int head[100010],to[200010],nxt[200010],tot;
inline void add(int u,int v){
	to[++tot]=v;
	nxt[tot]=head[u];
	head[u]=tot;
}
int fa[100010];
inline int find(int x){
	if(fa[x]==x) return x;
	return fa[x]=find(fa[x]);
}
int Fa[100010];
inline int Find(int x){
	if(Fa[x]==x) return x;
	return Fa[x]=Find(Fa[x]);
}
pair<int,int>t[100010];
int tt;
int c[100010];
int fA[100010],son[100010],siz[100010],dep[100010];
void dfs(int x,int f){
	fA[x]=f,siz[x]=1;
	for(int i=head[x];i;i=nxt[i]){
		if(to[i]==f) continue;
		dep[to[i]]=dep[x]+1;
		dfs(to[i],x);
		siz[x]+=siz[to[i]];
		if(siz[son[x]]<siz[to[i]]) son[x]=to[i];
	}
}
int top[100010];
void dfs2(int x,int t){
	top[x]=t;
	if(!son[x]) return;
	dfs2(son[x],t);
	for(int i=head[x];i;i=nxt[i]){
		if(to[i]==son[x] || to[i]==fA[x]) continue;
		dfs2(to[i],to[i]);
	}
}
inline int lca(int u,int v){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		u=fA[top[u]];
	}
	return dep[u]<dep[v] ? u : v;
}
void dfs3(int x,int fa){
	for(int i=head[x];i;i=nxt[i]){
		if(to[i]==fa) continue;
		dfs3(to[i],x);
		c[x]+=c[to[i]];
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) fa[i]=Fa[i]=i;
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		if(find(u)==find(v)){if(Find(u)!=Find(v)) Fa[Find(u)]=Find(v),t[++tt]={u,v};}
		else add(u,v),add(v,u),fa[find(u)]=find(v);
	}
	for(int i=1;i<=n;i++) if(find(i)==i) dfs(i,0),dfs2(i,i);
	for(int i=1;i<=tt;i++) c[t[i].first]++,c[t[i].second]++,c[lca(t[i].first,t[i].second)]-=2;
	for(int i=1;i<=n;i++) if(find(i)==i) dfs3(i,0);
	for(int i=1;i<=n;i++) if(fA[i] && !c[i]) cout<<i<<" "<<fA[i]<<"\n";
	return 0;
}
```

## 法三，随机化

我们建好树后，还是在树上标记。

平常就得用树上差分，但是这边直接尝试**和哈希**。

建立一个权值数组 $w$。

对于非树边 $(u,v)$，我们随机一个值 $R$，使 $w_u$ 加上 $R$，$w_v$ 减去 $R$。

这样，这条边的贡献会在 $(u,v)$ 的 LCA 的地方变为 $0$。

并且因为用了随机化，所以在 $(u,v)$ 的 LCA 的子树里，只要被作多次贡献的权值基本不会为 $0$。

所以说最后将每个节点的 $w$ 的子树和统计。

如果 $x$ 子树和为 $0$，说明没有作用于 $(x,fa_x)$ 这条边的非树边，所以可以直接统计。

时间复杂度 $O(n+m)$ 与 Tarjan 求割边一样。

代码也比前两种短了很多。

代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int head[100010],to[200010],nxt[200010],tot;
inline void add(int u,int v){
	to[++tot]=v;
	nxt[tot]=head[u];
	head[u]=tot;
}
int fa[100010];
inline int find(int x){
	if(fa[x]==x) return x;
	return fa[x]=find(fa[x]);
}
long long c[100010];
int f[100010];
void dfs3(int x,int fa){
	f[x]=fa;
	for(int i=head[x];i;i=nxt[i]){
		if(to[i]==fa) continue;
		dfs3(to[i],x);
		c[x]+=c[to[i]];
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1;i<=m;i++){
		int u,v,w=rand();
		cin>>u>>v;
		if(find(u)==find(v)) c[u]+=w,c[v]-=w;
		else add(u,v),add(v,u),fa[find(u)]=find(v);
	}
	for(int i=1;i<=n;i++) if(find(i)==i) dfs3(i,0);
	for(int i=1;i<=n;i++) if(f[i] && !c[i]) cout<<i<<" "<<f[i]<<"\n";
	return 0;
}
```

---

## 作者：cike_bilibili (赞：1)

## LG 11360 [CEOI 2015] 管道

此题要求我们的空间只能和点数而不能和边数有关，考虑一些其他的方法求出割边。

无向图问题转化成生成树上讨论返祖边，很显然割边只会在树边上，经典结论是割边就是没有被返祖边跨越的边。

进而考虑树上差分，但我们发现如果我们在处理完生成树之后打上标记，还是需要存下每一条边，空间又爆了，考虑这种树上差分的特殊性，我们只需要知道有没有被覆盖而不需要知道有几条。

**异或哈希**：在 LCA 处会自动抵消掉，判断子树异或值是否为 $0$ 即可。

---

## 作者：Felix72 (赞：1)

趣味题目，值得一做。

可以建出生成树，并作树上差分以区间标记（标记不可能是割边的边）。但是这样需要多次读取输入。

我们灵机一动，把树上标记换成异或哈希，这样到 $\operatorname{LCA}$ 时标记自己就会清除，也就不用存输入了。

```cpp
/* Good Game, Well Play. */
#include <bits/stdc++.h>
#define lowbit(x) ((x) & (-(x)))
using namespace std;

const int N = 100010;
mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
int n, m; vector < int > tr[N];
unsigned long long f[N];
struct DSU
{
	int prt[N], siz[N];
	inline void init(int n) {for(int i = 1; i <= n; ++i) prt[i] = i, siz[i] = 1;}
	inline int find(int x) {return ((prt[x] == x) ? x : (prt[x] = find(prt[x])));}
	inline void merge(int x, int y)
	{
		x = find(x), y = find(y);
		if(x != y)
		{
			if(siz[x] > siz[y]) swap(x, y);
			prt[x] = y, siz[y] += siz[x];
		}
	}
}; DSU dsu;
bitset < N > vis;
inline void work(int now, int prt)
{
	vis[now] = true;
	for(int to : tr[now])
	{
		if(to == prt) continue;
		work(to, now); f[now] ^= f[to];
	}
	if(!f[now] && prt) cout << now << " " << prt << '\n';
}

int main()
{
//	freopen("text.in", "r", stdin);
//	freopen("prog.out", "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n >> m; dsu.init(n);
	for(int i = 1; i <= m; ++i)
	{
		int x, y; cin >> x >> y;
		if(dsu.find(x) != dsu.find(y))
		{
			tr[x].push_back(y);
			tr[y].push_back(x);
			dsu.merge(x, y);
		}
		else
		{
			unsigned long long w = rnd();
			f[x] ^= w; f[y] ^= w;
		}
	}
	for(int i = 1; i <= n; ++i) if(!vis[i]) work(i, 0);
	return 0;
}
/*

*/
```

---

## 作者：wangyishan (赞：1)

摘自我的 [Xor Hashing 学习笔记](https://www.luogu.com.cn/article/vlaoj9ee)。虽然没写完。

这里我们只讨论图连通时的情况，不连通的话对每个连通块跑一遍就好。

首先这个数据范围明显就不想让我们把图全部存下来。

所以直接跑 Tarjan 是不行的。

现在让我们分析一下日常的 Tarjan 算法求桥到底是在干什么。

Tarjan 算法流程是，首先跑出一颗 DFS 生成树，然后注意到生成树上只有树边和返祖边。我们记录只通过返祖边所能返回的深度最浅的祖先是什么，然后如果一个儿子能通过返祖边返回的最浅的祖先比自己还深，那么这条边就一定是割边（桥）。

路人甲：。。。这好像不能优化啊？

作者：。。。。谔谔确实。不过你的生成树不一定必须是 DFS 生成树啊！

考虑对原图任意建一颗生成树。不难发现割边只可能是生成树上的边。

观察一条非树边对答案贡献了什么。容易发现，一条非树边 $(u,v)$ 就是把树上从 $u$ 到 $v$ 的路径全部设为非割边。就像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/zf6zfdna.png)

下面我们的问题就变成了如何快速覆盖一条树上的路径。

考虑 xor hashing:

对于每一条非树边，我们在这条非树边的两个端点的点权同时异或上一个随机值。

输入完成后我们 DFS 一遍这棵生成树，让节点的点权变成这棵子树内点权的异或和。如果 DFS 时发现儿子的点权是 0，那么这条边我们就认为是割边。

为什么呢？

注意到我们异或运算的第一个性质：$x\oplus x = 0$。这意味着如果一个数在区间内出现了 2 次（或者说偶数次），那么它对异或和的贡献一定为 $0$。那么对于一个子树，如果它的异或和等于 0，那么我们就可以认为每条边都出现了偶数次。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int fa[100010],d[100010];
vector<int>e[100010];
int find(int x){
    if(x==fa[x])return x;
    return fa[x]=find(fa[x]);
}
void dfs(int x,int pre){
    for(auto i:e[x]){
        if(i==pre)continue;
        dfs(i,x);
        if(!d[i])cout<<x<<" "<<i<<endl;
        d[x]^=d[i];
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>n>>m;
    for(int i=1;i<=n;i++)fa[i]=i;
    for(int i=1;i<=m;i++){
        int u,v;
        cin>>u>>v;
        if(find(u)==find(v)){
            int r=rand();
            d[u]^=r,d[v]^=r;
        }else{
            fa[find(u)]=find(v);
            e[u].push_back(v);
            e[v].push_back(u);
        }
    }
    for(int i=1;i<=n;i++){
        if(find(i)==i)dfs(i,i);
    }
    return 0;
}
```

---

## 作者：729hao (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11360)

来一发题解区暂时没有的做法。

---

## 思路
首先，求割边有如下两种方法：

+ 把图存下来，跑 tarjan。

时间复杂度 $O(N+M)$，空间复杂度 $O(N+M)$，后者因为题目限制会 MLE。

+ 在线维护一棵生成树（其实是森林，但为了方便表述称作生成树，后同理），如果新加入的边与树边构成了环就把环上的点缩成一个点，否则就是一条树边。所有边加完之后还在生成树上的边就是割边。

时间复杂度 $O(NM+N\alpha(N))$，空间复杂度 $O(N)$，前者因为题目限制会 TLE。

观察这两种做法，一种空间需求过高，一种时间需求过高，这启发我们**把两者结合一下**。

具体地，我们仍然考虑维护生成树，只不过我们并不每加一条边就更新树，而是设定一个阈值 $B$，每新加 $B$ 次边再更新这棵树。更新的时候，先把新的树边放到生成树上，然后对于每条新的非树边，用并查集合并环上的点。

这样，我们的时间复杂度变成了 $O(\frac{M}{B}\times N+N\alpha(N))$，空间复杂度变成了 $O(N+B)$。

容易发现 $B=N$ 时满足题目要求，于是最终时间复杂度 $O(M+N\alpha(N))$，空间复杂度 $O(N)$。

## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace cs{
	#define LL long long
	#define fir first
	#define sec second
	typedef pair<int,int> PII;
	const int N=1e5;
	const int INF=2e9;
	int n,m,B,bcnt;
	int bln[N+5],bcc[N+5];
	int Getfa(int x){return bln[x]==x?x:bln[x]=Getfa(bln[x]);}
	int Getbcc(int x){return bcc[x]==x?x:bcc[x]=Getbcc(bcc[x]);}
	int ecnt,pcnt;
	PII e[N+5],p[N+5];
	vector<int> v[N+5];
	int fa[N+5],dep[N+5];
	void dfs(int rt,int prt,int depth){
		fa[rt]=prt;
		dep[rt]=depth;
		for(auto u:v[rt]){
			if(u==prt) continue;
			dfs(u,rt,depth+1);
		}
	}
	void Merge(int x,int y){
		while(x!=y){
			if(dep[x]>dep[y]){
				bcc[x]=Getbcc(fa[x]);
				x=bcc[x];
			}
			else{
				bcc[y]=Getbcc(fa[y]);
				y=bcc[y];
			}
		}
	}
	void Update(){
		for(int i=1;i<=n;i++){
			v[i].clear();
			fa[i]=dep[i]=0;
			bcc[i]=Getbcc(i);
		}
		for(int i=1;i<=ecnt;i++){
			if(bcc[e[i].fir]==bcc[e[i].sec]) continue;
			v[bcc[e[i].fir]].push_back(bcc[e[i].sec]);
			v[bcc[e[i].sec]].push_back(bcc[e[i].fir]);
		}
		for(int i=1;i<=n;i++){
			if(!dep[bcc[i]]) dfs(bcc[i],0,1);
		}
		for(int i=1;i<=pcnt;i++){
			Merge(Getbcc(p[i].fir),Getbcc(p[i].sec));
		}
		pcnt=0;
	}
	int main(){
		ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
//		freopen("pipes.02b.in","r",stdin);
		cin>>n>>m;
		for(int i=1;i<=n;i++){
			bln[i]=i;
			bcc[i]=i;
		}
		B=n;
		bcnt=B;
		int x,y;
		while(m--){
			cin>>x>>y;
			if(Getfa(x)!=Getfa(y)){
				bln[Getfa(x)]=Getfa(y);
				e[++ecnt]={x,y};
			}
			else p[++pcnt]={x,y};
			bcnt--;
			if(bcnt==0){
				Update();
				bcnt=B;
			}
		}
		if(bcnt!=B) Update();
		for(int i=1;i<=ecnt;i++){
			if(Getbcc(e[i].fir)!=Getbcc(e[i].sec)) cout<<e[i].fir<<" "<<e[i].sec<<"\n";
		}
		return 0;
	}
}
int main(){
	cs::main();
	return 0;
}
```

---

## 作者：strcmp (赞：0)

好题。

简单来讲就是求割边，但是空间限制极小导致你无法建图。

众所周知，求割边有一种差分的做法，这是我们解法的基石。

但是我不准备直接写树上倍增或者树剖直接做 LCA，因为这个做法过于不动脑子而且复杂度还带个 $\log$（$\Theta(n)/\Theta(1)$ LCA 也太麻烦，不过重点是没啥启发性）。

对于这个普通的树上覆盖问题，有一个很有趣的 Xor Hashing 做法。

简单来说我们每次令**非树边** $u,\,v$ 都异或上一个随机值，然后求子树的异或和，结点 $x$ 的值为 $0$ 那么 $(\text{fa}_x,\,x)$ 是割边。

原因：如果 $x,\,y \in \text{subtree}(u)$ 那么显然 $x,\,y$ 没对 $(\text{fa}_u,\,u)$ 产生贡献，都不在 $\text{subtree}(u)$ 的时候也同理。有贡献当且仅当一个在 $u$ 子树内一个在 $u$ 子树外，那么显然 $(\text{fa}_u,\,u)$ 不会是割边。否则一定是割边。

事实上将 $u$ 设置为 $w$ 且 $v$ 设置为 $-w$ 跑和哈希有同样效果。

时间复杂度 $\Theta(n \alpha(n) + m)$，瓶颈在并查集。

```cpp
#include <bits/stdc++.h>
#define X first
#define Y second
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define per(i, a, b) for (int i = a; i >= b; i--)
#define pb push_back
#define mp make_pair
#define mid (l + r >> 1)
using namespace std;
typedef long long int ll;
using ull = unsigned long long int;
using pii = pair<int, int>;
constexpr int maxn = 1e5 + 10, mod = 998244353;
struct edge { int to, nxt; } nd[maxn << 1]; int h[maxn], cnt = 0;
inline void add(int u, int v) { nd[cnt].nxt = h[u], nd[cnt].to = v, h[u] = cnt++; }
int n, m, sz[maxn], fa[maxn]; mt19937_64 rd(114514); ull w[maxn];
int fd(int x) { return fa[x] == x ? x : fa[x] = fd(fa[fa[x]]); }
inline int read() {
	int x = 0; char c = 0;
	while (!isdigit(c)) c = getchar();
	while (isdigit(c)) x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
	return x;
}
void dfs(int u, int f) {
	for (int i = h[u]; ~i; i = nd[i].nxt) {
		int v = nd[i].to;
		if (v != f) {
			dfs(v, u), w[u] ^= w[v];
			if (!w[v]) printf("%d %d\n", u, v);
		}
	}
}
int main() {
	memset(h, -1, sizeof(h));
	n = read(), m = read();
	rep(i, 1, n) fa[i] = i, sz[i] = 1;
	for (int i = 1, u, v; i <= m; i++) { 
		int x = fd(u = read()), y = fd(v = read());
		if (x != y) {
			if (sz[x] > sz[y]) swap(x, y);
			fa[x] = y; sz[y] += sz[x]; add(u, v), add(v, u);
		}
		else {
			ull k = rd();
			w[u] ^= k, w[v] ^= k;
		}
	}
	rep(i, 1, n) if (fd(i) == i) dfs(i, 0);
	return 0;
}
```

---

## 作者：qnqfff (赞：0)

### 思路

首先完整的图是存不了的，所以不能直接 tarjan，考虑一些别的算法，桥不存在于任意一个环，于是可以考虑拉出一棵生成树，对于每条非树边，则树上两点间的所有边都不能选，可以直接上树上差分，但有个问题，非树边还是有很多条，容易发现对于非树边我们也只用保留一棵生成树上的边即可。

### 思路

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,fa[100010],_fa[100010],f[100010],dep[100010],siz[100010],top[100010],son[100010],tag[100010],vis[100010];vector<int>e[100010];
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
int _find(int x){return _fa[x]==x?x:_fa[x]=_find(_fa[x]);}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m;iota(fa+1,fa+1+n,1);iota(_fa+1,_fa+1+n,1);vector<array<int,2>>_e;
	for(int i=1;i<=m;i++){
		int u,v;cin>>u>>v;
		if(find(u)^find(v)){e[u].push_back(v);e[v].push_back(u);fa[find(u)]=find(v);}
		else if(_find(u)^_find(v)){_fa[_find(u)]=_find(v);_e.push_back({u,v});}
	}function<void(int,int)>dfs=[&](int u,int fa){
		f[u]=fa;siz[u]=1;dep[u]=dep[fa]+1;
		for(auto v:e[u]) if(v^fa){dfs(v,u);siz[u]+=siz[v];if(siz[v]>siz[son[u]]) son[u]=v;}	
	};for(int i=1;i<=n;i++) if(!dep[i]) dfs(i,0);
	function<void(int,int)>_dfs=[&](int u,int tp){
		top[u]=tp;if(son[u]) _dfs(son[u],tp);
		for(auto v:e[u]) if(v^f[u]&&v^son[u]) _dfs(v,v);
	};for(int i=1;i<=n;i++) if(!top[i]) _dfs(i,i);
	auto lca=[&](int u,int v){
		while(top[u]^top[v]){
			if(dep[top[u]]<dep[top[v]]) swap(u,v);
			u=f[top[u]];
		}return dep[u]<dep[v]?u:v;
	};for(auto i:_e) tag[i[0]]++,tag[i[1]]++,tag[lca(i[0],i[1])]-=2;
	function<void(int)>upd=[&](int u){
		vis[u]=1;for(auto v:e[u]) if(v^f[u]) upd(v),tag[u]+=tag[v];
		if(!tag[u]&&f[u]) cout<<u<<' '<<f[u]<<'\n';
	};for(int i=1;i<=n;i++) if(!vis[i]) upd(i);
	return 0;
}
```

---

## 作者：未来姚班zyl (赞：0)

## 题目大意

求无向图割边。

## 题目分析

~~这不是 tarjan 板子题吗。~~

我们的空间需要只和 $n$ 挂钩，因为我们的空间连存边都存不下。

考虑求出原图的生成树，然后没被非树边覆盖的树边就是割边。

容易发现非树边也只需要求出生成树。

生成树边数是 $O(n)$，所以空间存的下。

树上差分即可做到覆盖效果，复杂度 $O(n\log n+m)$。

瓶颈在读入，只需要简单的快读就可以通过。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define L x<<1
#define R L|1
#define mid (l+r>>1)
#define lc L,l,mid
#define rc R,mid+1,r
#define OK Ll<=l&&r<=Rr
#define Root 1,1,n-1
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define repn(x) rep(x,1,n)
#define repm(x) rep(x,1,m)
#define pb push_back
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define E(x) for(auto y:p[x])
#define Pi pair<ll,ll>
#define ui unsigned ll
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(int x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
using namespace std;
const int N=1e5+5,M=4e6+5,inf=(1LL<<31)-1,mod=998244353;
const ll llf=1e18;
int n,m,f[N],F[N];
int h[N],to[N<<1],nxt[N<<1],cnt;
inline void add_(int a,int b){
	to[++cnt]=b,nxt[cnt]=h[a],h[a]=cnt;
}
int son[N],dep[N],siz[N],top[N];
inline void dfs(int x,int fa){
	f[x]=fa,dep[x]=dep[fa]+1,siz[x]=1;
	e(x)if(y^fa)dfs(y,x),siz[x]+=siz[y],son[x]=siz[y]>siz[son[x]]?y:son[x];
}
inline void Dfs(int x,int low){
	top[x]=low;
	if(son[x])Dfs(son[x],low);
	e(x)if(y^f[x]&&y^son[x])Dfs(y,y);
}
inline int lca(int x,int y){
	while(top[x]^top[y])dep[top[x]]>dep[top[y]]?x=f[top[x]]:y=f[top[y]];
	return dep[x]<dep[y]?x:y;
}
inline int find(int x){
	return f[x]==x?x:f[x]=find(f[x]);
}
inline int Find(int x){
	return F[x]==x?x:F[x]=Find(F[x]);
}
struct node{
	int x,y;
}b[N];
int tp,c[N];
inline void dfs_(int x){
	e(x)if(y^f[x]){
		dfs_(y),c[x]+=c[y];
		if(!c[y])cout <<x<<' '<<y<<'\n';
	}
}
inline void Main(){
	n=read(),m=read();
	repn(i)f[i]=F[i]=i;
	while(m--){
		int x=read(),y=read();
		if(find(x)!=find(y)){
			f[find(x)]=find(y);
			add_(x,y),add_(y,x);
		}else if(Find(x)!=Find(y)){
			F[Find(x)]=Find(y);
			b[++tp]={x,y};
		}
	}
	repn(x)if(!dep[x])dfs(x,0),Dfs(x,x);
	rep(i,1,tp){
		int x=b[i].x,y=b[i].y,la=lca(x,y);
		c[x]++,c[y]++,c[lca(x,y)]-=2;
	}
	repn(x)if(!f[x])dfs_(x);
}
signed main(){
	int T=1;
	while(T--)Main();
	return 0;
}	
```

---


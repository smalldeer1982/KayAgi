# 服务器储存信息问题

## 题目描述

Byteland 王国准备在各服务器间建立大型网络并提供多种服务。

网络由 $n$ 台服务器组成，用双向的线连接。两台服务器之间最多只能有一条线直接连接，同时，每台服务器最多只能和 $10$ 台服务器直接连接，但是任意两台服务器间必然存在一条路径将它们连接在一起。

每条传输线都有一个固定传输的速度。$\delta(v,w)$ 表示服务器 $v$ 和 $w$ 之间的最短路径长度，且对任意的 $v$ 有 $\delta(v,v)=0$。

有些服务器比别的服务器提供更多的服务，它们的重要程度要高一些。我们用 $r(v)$ 表示服务器 $v$ 的重要程度 $\texttt{rank}$。$\texttt{rank}$ 越高的服务器越重要。

每台服务器都会存储它附近的服务器的信息。当然，不是所有服务器的信息都存，只有感兴趣的服务器信息才会被存储。服务器 $v$ 对服务器 $w$ 感兴趣是指，不存在服务器 $u$ 满足，$r(u)>r(w)$ 且 $\delta(v,u)\le\delta(v, w)$。

举个例子来说，所有具有最高 $\texttt{rank}$ 的服务器都会被别的服务器感兴趣。如果 $v$ 是一台具有最高 $\texttt{rank}$ 的服务器，由于 $\delta(v,v)=0$，所以 $v$ 只对具有最高 $\texttt{rank}$ 的服务器感兴趣。

我们定义 $B(v)$ 为 **$v$ 感兴趣**的服务器的集合。我们希望计算所有服务器储存的信息量，即所有服务器的 $|B(v)|$ 之和。Byteland 王国并不希望存储大量的数据，所以所有服务器存储的数据量 （$|B(v)|$ 之和）不会超过 $30n$。

你的任务是写一个程序，读入 Byteland 王国的网络分布，计算所有服务器存储的数据量。


## 说明/提示

#### 输出解释

$B(1)=\{1,2\},B(2)=\{2\},B(3)=\{2,3\},B(4)=\{1,2,3,4\}$。

#### 数据规模

$1\le n\le30000,1\le m\le5n$

$1\le r(i)\le 10$

$1\le t\le 1000,1\le a,b\le n,a\neq b$

## 样例 #1

### 输入

```
4 3
2
3
1
1
1 4 30
2 3 20
3 4 20```

### 输出

```
9
```

# 题解

## 作者：lonlyn (赞：18)

暴力做法就是n遍spfa，然后按照rank怼一遍就完事了。

不过能得多少分我就不知道了。。。。。。

有兴趣的同学可以试一下orz，我就不作了。


正解当然要对这个求解方案进行优化了啊。

怎么优化呢？orz

注意到rank似乎非常小，那就对rank搞点事情。

一般都能想到记录点x到rank为i的点集的最短路径，但我们为了以后方便可以扩展一下为 x到rank大于等于i的点集的最短路径 ，设为F[i][x]。

这样每次比较u，v就只要看一看dis(u,v)<F[rank[v]+1][u]。

我们对他优化一下orz。

以起点s开始找到一个点v，设v不关心s，则dis(s,v)>=F[rank[s]+1][v]；

若我们尝试把v扔进队列，假设松弛到u，

则dis(s,u)=dis(s,v)+dis(v,u);

But dis(s,v)>=F[rank[s]+1][v];

So dis(s,u)=dis(s,v)+dis(v,u)>=F[rank[s]+1][v]+dis(u,v)>=F[rank[s]+1][u];

所以此时u也是不对w感兴趣的点，我们还给他扔进去干嘛。。

答案不超过30n，复杂度不算高。


这道题告诉我们：spfa到一个不满足条件的点就不要把它扔到队列里面去了嘛。

（真理：暴力出奇迹）


```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
struct node{
    int to;
    int v;
};
vector<node> edge;
vector<int> G[30010];
vector<int> o_edge[20];
int n,m;
int r[30010];
int u,v,t;
int far[20][30010];
int dis[30010];
bool vis[30010];
bool ok[30010];
int ans;

void add_edge(int from,int to,int v){
    edge.push_back((node){to,v});
    edge.push_back((node){from,v});
    int m=edge.size();
    G[from].push_back(m-2);
    G[to].push_back(m-1);
}

void o_spfa(int x){
    memset(vis,false,sizeof(vis));
    memset(far[x],0x3f,sizeof(far[x]));
    queue<int> q;
    for (int i=0;i<o_edge[x].size();++i){
        far[x][o_edge[x][i]]=0;
        q.push(o_edge[x][i]);
    }
    while (!q.empty()){
        int now=q.front();
        q.pop();
        vis[now]=false;
        for (int i=0;i<G[now].size();++i){
            node nxt=edge[G[now][i]];
            if (far[x][now]+nxt.v<far[x][nxt.to]){
                far[x][nxt.to]=far[x][now]+nxt.v;
                if (!vis[nxt.to]){
                    vis[nxt.to]=true;
                    q.push(nxt.to);
                }
            }
        }
    }
}

void wk(int x){
    for (int i=1;i<=n;++i){
        if (far[x][i]>far[x+1][i])
          far[x][i]=far[x+1][i];
    }
}

void spfa(int x){
    memset(vis,false,sizeof(vis));
    memset(dis,0x3f,sizeof(dis));
    memset(ok,false,sizeof(ok));
    dis[x]=0;
    vis[x]=1;
    queue<int> q; q.push(x);
    while (!q.empty()){
        int now=q.front();
        q.pop();
        vis[now]=false;
        if (!ok[now]){
            ans++;
            ok[now]=true;
        }
        for (int i=0;i<G[now].size();++i){
            node nxt=edge[G[now][i]];
            if (dis[nxt.to]>dis[now]+nxt.v){
                dis[nxt.to]=dis[now]+nxt.v;
                if (!vis[nxt.to]&&dis[nxt.to]<far[r[x]+1][nxt.to]){
                    q.push(nxt.to);
                    vis[nxt.to]=true;
                }
            }
        }
    }
}

int main(){
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;++i){
        scanf("%d",&r[i]);
        o_edge[r[i]].push_back(i);
    }
    for (int i=1;i<=m;++i){
        scanf("%d%d%d",&u,&v,&t);
        add_edge(u,v,t);
    }
    for (int i=1;i<=10;++i) o_spfa(i);    
    for (int i=9;i>=1;--i) wk(i); 
    for (int i=1;i<=n;++i) spfa(i);
    cout<<ans;
    return 0;
}
```
从此你可以向别人炫耀说我用n遍spfa这种大暴力还能a题233


---

## 作者：GalwayGirl (赞：5)

## 闲话
看到这种紫色图论题，先别着急思考，~~直接暴力。~~

先贴上我的 $n$ 遍 Dijkstra 的暴力。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e4+100,M=3e5+100;
int n,m,r[N],head[N],dis[N],ans,c;
bool vis[N];
vector<int>G[21];
struct xzh{
    int next,to,w;
}edge[M];
struct hh{
    int id,val;
    bool operator <(const hh&a)const {
        return a.val<val;
    }
};
void add(int u,int v,int w){
    c++;
    edge[c].next=head[u];
    edge[c].to=v;
    edge[c].w=w;
    head[u]=c;
}
void spfa(int s){
    for(int i=1;i<=n;i++)dis[i]=1e9,vis[i]=false;
    priority_queue<hh>q;
    q.push({s,0});
    dis[s]=0;
    while(!q.empty()){
        int now=q.top().id;
        q.pop();
        if(vis[now])continue;
        vis[now]=true;
        for(int i=head[now];i;i=edge[i].next){
            int v=edge[i].to;
            if(dis[now]+edge[i].w<dis[v]){
                dis[v]=dis[now]+edge[i].w;
                q.push({v,dis[v]});
            }
        }
    }
    int min_=1e9;
    for(int i=10;i>=1;i--){
        for(int j=0;j<G[i].size();j++){
            int now=G[i][j];
            if(min_>dis[now])ans++;
        }
        for(int j=0;j<G[i].size();j++){
            int now=G[i][j];
            min_=min(min_,dis[now]);
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d",&r[i]);
        G[r[i]].push_back(i);
    }
    for(int i=1;i<=m;i++){
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        add(u,v,w);add(v,u,w);
    }
    for(int i=1;i<=n;i++)spfa(i);
    printf("%d",ans);
    return 0;
}
```
竟然有 $50pts$，~~以后就打暴力算了。~~
## Solution
参考了一下其他 dalao 的题解，设 $f_{rank,s}$ 表示 $s$ 到 重要程度大于等于 $rank$ 的点集的最短路径，如果 $dis_{s,u}\geq f_{rank_s+1,u}$ 就不合法， 再往后面推，假设 $u$ 要对 $v$ 进行松弛，那么 $dis_{s,v}=dis_{s,u}+dis_{u,v}\geq f_{rank_s+1,u}+dis_{u,v}\geq f_{rank_s+1,v}$ 被推了出来，所以 $u$ 不合法，那么它要松弛的点也不合法，那就没有必要将 $u$ 放入队列里了。

可以先把 $f$ 数组预处理出来，反正 $rank$ 最多为 $10$，再跑一遍 Dijkstra 统计答案。

最后贴上代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e4+100,M=3e5+100,R=21;
int n,m,r[N],head[N],dis[N],ans,c,f[N][R];
bool vis[N];
vector<int>G[R];
struct xzh{
    int next,to,w;
}edge[M];
struct hh{
    int id,val;
    bool operator <(const hh&a)const {
        return a.val<val;
    }
};
void add(int u,int v,int w){
    c++;
    edge[c].next=head[u];
    edge[c].to=v;
    edge[c].w=w;
    head[u]=c;
}
void predij(int r){
    for(int i=1;i<=n;i++)vis[i]=false;
    priority_queue<hh>q;
    for(int i=0;i<G[r].size();i++){
        int now=G[r][i];
        f[now][r]=0;
        q.push({now,0});
    }
    while(!q.empty()){
        int now=q.top().id;
        q.pop();
        if(vis[now])continue;
        vis[now]=true;
        for(int i=head[now];i;i=edge[i].next){
            int v=edge[i].to;
            if(f[now][r]+edge[i].w<f[v][r]){
                f[v][r]=f[now][r]+edge[i].w;
                q.push({v,f[v][r]});
            }
        }
    }
}
void dij(int s){
    for(int i=1;i<=n;i++)dis[i]=1e9,vis[i]=false;
    priority_queue<hh>q;
    q.push({s,0});
    dis[s]=0;
    while(!q.empty()){
        int now=q.top().id;
        q.pop();
        if(vis[now])continue;
        ans++;
        vis[now]=true;
        for(int i=head[now];i;i=edge[i].next){
            int v=edge[i].to;
            if(dis[now]+edge[i].w<dis[v]){
                dis[v]=dis[now]+edge[i].w;
                if(dis[now]+edge[i].w<f[v][r[s]+1]&&dis[now]+edge[i].w<f[v][r[s]+1]){
                    dis[v]=dis[now]+edge[i].w;
                    f[v][r[s]]=min(f[v][r[s]],dis[now]+edge[i].w);
                    q.push({v,dis[v]});
                }
                
            }
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d",&r[i]);
        G[r[i]].push_back(i);
    }
    for(int i=11;i>=1;i--)
        for(int j=1;j<=n;j++)
            f[j][i]=1e9;  
    for(int i=1;i<=m;i++){
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        add(u,v,w);add(v,u,w);
    }
    for(int i=10;i>=1;i--){
        predij(i);
        if(i!=10)for(int j=1;j<=n;j++)f[j][i]=min(f[j][i],f[j][i+1]);
    }
    for(int i=1;i<=n;i++)dij(i);
    printf("%d",ans);
    return 0;
}
```


---

## 作者：wuzhaoxin (赞：5)

# 服务器储存信息问题

### 先想暴力

设**d[i, x]**表示**rank>=i**的所有点到**x**的距离最小值

按照**rank**从大到小对每个点跑最短路，如果**dis[y]<d[r[s]+1,y]**则可以统计进答案，用**dis[y]**更新**d[r[s],y]**

### 优化

最容易想到的优化就是去除不必要的更新

设存在一条边**x y v**，正在用**x**节点更新其它节点且**dis[x]>=d[r[s]+1,x]**，那么**dis[x]+v>=d[r[s]+1,y]**一定成立，因为在**rank>r[s]**的某次更新中**dis[y]**可以从**dis[x]+v**更新**d[r[s]+1,y]+v<=d[r[s]+1,x]**

所以我们不需要更新**dis[x]>=d[r[s]+1,x]**的节点，最后答案就是每次更新的节点数之和

### 代码（没有使用滚动数组，跑得比较慢，空间比较大）

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int gi() {
    register int x=0,op=1,c;
    while(c=getchar(),c<'0'||c>'9')if(c=='-')op=-op;
    x=c^48;
    while(c=getchar(),c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48);
    return x*op;
}
int head[30001], nxt[300001], ver[300001], val[300001], tot = 1;
void add(int x, int y, int z) {
	ver[++ tot] = y, val[tot] = z, nxt[tot] = head[x], head[x] = tot;
	ver[++ tot] = x, val[tot] = z, nxt[tot] = head[y], head[y] = tot;
}
int n, m;
int r[30001];
int d[12][30001];
priority_queue<pair<int, int> >q;
int dis[30001];
bool v[30001];
int ans = 0;
void dij(int s) {
	memset(dis, 0x7f, sizeof(dis));
	memset(v, 0, sizeof(v));
	dis[s] = 0;
	q.push(make_pair(0, s));
	int x;
	while(! q.empty()) {
		x = q.top().second;
		q.pop();
		if(v[x])continue;
		ans ++ ;
		v[x] = 1;
		for(int i = head[x], y; i; i = nxt[i])
			if(! v[ver[i]] && dis[y = ver[i]] > dis[x] + val[i] && dis[x] + val[i] < d[r[s] + 1][ver[i]]) {
				dis[y] = dis[x] + val[i];
				d[r[s]][y] = min(dis[y], d[r[s]][y]);
				q.push(make_pair(- dis[y], y));
			}
	}
}
int main() {
	n = gi(), m = gi();
	for(int i = 1; i <= n; i ++)
		r[i] = gi();
	for(int i = 1, x, y; i <= m; i ++)
		x = gi(), y = gi(), add(x, y, gi());
	memset(d, 0x7f, sizeof(d));
	for(int i = 10; i; i --) {
		for(int j = 1; j <= n; j ++)
			if(i == r[j])d[i][j] = 0;
		for(int j = 1; j <= n; j ++)
			if(r[j] == i)dij(j);
		memcpy(d[i-1], d[i], sizeof(d[i]));
	}
	printf("%d\n", ans);
	return 0;
}

```



---

## 作者：chenzida (赞：4)

题意简述：一个计算机 $s$ 是否关注另一个计算机 $t$ 规则如下，当且仅当不存在计算机 $x$ 的等级 $rank[x] > rand[t]$ 且 $s$ 到 $t$ 的距离小于 $s$ 到 $x$ 的距离，即 $dis_{s,t} < dis_{s,x}$,其中 $d$ 表示两点之间的最短距离。如果一个计算机关注另一个计算机，则这个计算机的储存量就会 $+1$，设第 $i$ 个计算机储存量为 $num[i]$ ，问所有计算机的存储量总和，即 $\sum_{i=1}^{n}num[i]$ 是多少。

思路解析：这道题暴力肯定谁都能想出来，就是 $n$ 遍 $spfa$ 硬来即可。虽然这样的复杂度是肯定会凉凉的，但是正解永远是将优化后的暴力，所以我们还是把暴力的思路解释一下。

暴力解法：可以 $n$ 遍 $spfa$ 暴力初始化出来任意两点间的距离 $dis_{x,y}$，然后枚举两个计算机 $A,B$，看看是否有关注关系，如果有，就将统计的答案加上 $1$，最后的答案就是统计的答案。

优化暴力(正解)：观察这道题，唯一不对劲的地方就是等级数，即 $rank[x]$ 是非常小的。所以正解肯定要对 $rank$ 进行处理。所以我们引入一个数组 $d$,$d[rank][x]$ 表示离点 $x$ 最近并且的其等级大于等于 $rank$ 的点距离 $x$ 的距离。这样的话我们每次判断两个点 $x,y$ 是否有关注的关系就只要判断是否满足 $dis[x][y] < d[rand[y]+1][x]$ 就行了。然而怎么优化呢？之前的 $spfa$ 可以给我们一些启示，之前的 $spfa$ 如果不满足条件就不会入队，这道题我们能否也试一试让不符合要求的就不入队了呢？我们设目前的起点是 $s$ ,现在已经遍历到了点 $x$,且点 $x$ 并不关注 $s$，而我们正要松弛 $y$，则我们能够得到一个不等式，现在看一看这个不等式能推出什么：

$$\begin{cases}
dis[s][y]=dis[s][x]+dis[x][y] \\
dis[s][x] \geq d[rank[s]+1][x]
\end{cases}$$

$$\because dis[s][y]=dis[s][x]+dis[x][y] $$
$$\because dis[s][x] \geq d[rank[s]+1][x]$$
$$\therefore dis[s][y] \geq d[rank[s]+1][x]+dis[x][y]$$
$$\therefore dis[s][y] \geq d[rank[s]+1][y]$$

所以可以得出当一个计算机 $x$ 不关注 $s$ 时，就不用从 $x$ 再扩展了，因为扩展完了也不会关注。所以我们就有了一个优化，那就是如果一个点 $x$ 不关注起点 $s$ 那么它就不用进队列了。

所以正解就有了以下步骤：

$1.$读入建图

$2.$先进行 $10$ 遍 $spfa$ 初始化出来 $d$ 数组。

$3.$再跑一遍用 $10\times n$ 跑一遍将 $d$ 数组顺延下来。

$4.$然后再跑 $n$ 遍优化后的 $spfa$ ,约用时 $10\times n$。

$5.$最后输出答案

完整代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NR=3e4+10;
const int MR=NR*5;
int n,m;
int a[NR];
int ans;
int to[MR<<1],nxt[MR<<1],val[MR<<1];
int head[NR];
int tot=1;
void add(int x,int y,int z)
{
	to[tot]=y;
	val[tot]=z;
	nxt[tot]=head[x];
	head[x]=tot++;	
}
int d[15][MR];
bool vis[NR];
void spfa1(int x)
{
	memset(vis,0,sizeof(vis));
	memset(d[x],0x3f,sizeof(d[x]));
	queue<int> q;
	for(int i=1;i<=n;i++)
	{
		if(a[i]==x)
		{
			d[x][i]=0;
			q.push(i);
		}
	}
	while(!q.empty())
	{
		int now=q.front();
		q.pop();vis[now]=0;
		for(int i=head[now];i;i=nxt[i])
		{
			int y=to[i];
			if(d[x][now]+val[i]<d[x][y])
			{
				d[x][y]=d[x][now]+val[i];
				if(!vis[y])
				{
					vis[y]=1;
					q.push(y);
				}
			}
		}
	}
}
bool suc[NR];
int dis[NR];
void spfa2(int s)
{
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	memset(suc,0,sizeof(suc));
	queue<int> q;vis[s]=1;
	dis[s]=0;q.push(s);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();vis[x]=0;
		if(!suc[x])
		{
			suc[x]=1;
			ans++;
		}
		for(int i=head[x];i;i=nxt[i])
		{
			int y=to[i];
			if(dis[y]>dis[x]+val[i])
			{
				
				dis[y]=dis[x]+val[i];
				if(!vis[y]&&dis[y]<d[a[s]+1][y])
				{
					q.push(y);
					vis[y]=1;
				}
			}
		}
	}
}
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=m;i++)//步骤1 
	{
		int x=read(),y=read(),z=read();
		add(x,y,z);add(y,x,z);
	}
	for(int i=1;i<=10;i++) spfa1(i);//步骤2 
	for(int i=9;i>=1;i--)//步骤3 
	{
		for(int j=1;j<=n;j++)
		{
			d[i][j]=min(d[i][j],d[i+1][j]);
		}
	}
	for(int i=1;i<=n;i++) spfa2(i);//步骤4 
	printf("%d",ans);//步骤5
	return 0;
}

```


---

## 作者：Inui_Sana (赞：1)

~~甚至还可以写题解。~~

暴力的 $O(n^2\log n)$ 做法自然是以每个点为起点跑一遍最短路，看哪些点对它感兴趣。因为保证 $ans\le 30n$，所以如果我们能保证跑最短路时（Dijkstra），每一次走到一个点，都能使 $ans\to ans+1$，则复杂度就有保证了。怎么做到这一点呢？

> Lemma：对一个点 $x$ 感兴趣的点集 $S$ 在图中是一个连通块。

Proof：从最短路树的角度考虑。如果有一个点 $y$ 对 $x$ 不感兴趣，则 $\exist z,r(z)>r(x),\delta(z,y)\le \delta(x,y)$，则在以 $x$ 为最短路树根的树中，$y$ 的子树内的任意一个点 $u$ 都有 $\delta(x,u)=\delta(x,y)+\delta(y,u)\ge\delta(z,y)+\delta(y,u)\ge\delta(z,u)$。则 $r(z)>r(x),\delta(z,u)\le \delta(x,u)$，则对 $x$ 感兴趣的点集 $S$ 一定是一个包含 $x$ 的最短路树上的一段连通块，得证。

所以就以 $r(s)$ 从大往小，以 $s$ 为起点跑最短路，只松弛对 $s$ 感兴趣的点，总复杂度就是 $O(ans\log n)$ 的了。

但是做的时候遇到一个小问题，就是想如果是个菊花的话，每次都会访问 $O(m)$ 条边，但是这题限制了 $deg_u\le10$ 所以不会有问题……

code：

```cpp
int n,m,ans,dis[N],c[N],f[N],g[N];
bool vis[N];
priority_queue<pii> q;
vector<int> S;
int tot,head[N];
struct node{int to,nxt,cw;}e[M<<1];
il void add(int u,int v,int w){e[++tot]={v,head[u],w},head[u]=tot;}
void solve(int s){
	while(q.size())q.pop();
	f[s]=0,q.push(Mp(0,s));
	while(q.size()){
		int u=q.top().se;q.pop();
		if(vis[u])continue;
		vis[u]=1,S.eb(u),ans++;
		go(i,u){
			int v=e[i].to;
			if(vis[v]||dis[v]<=f[u]+e[i].cw||f[v]<=f[u]+e[i].cw)continue;
			f[v]=f[u]+e[i].cw,q.push(Mp(-f[v],v));
		}
	}
	for(int i:S)g[i]=min(g[i],f[i]),f[i]=inf,vis[i]=0;
	S.clear();
}
void Yorushika(){
	scanf("%d%d",&n,&m);
	rep(i,1,n)scanf("%d",&c[i]);
	rep(i,1,m){
		int u,v,w;scanf("%d%d%d",&u,&v,&w);
		add(u,v,w),add(v,u,w);
	}
	mems(dis,0x3f),mems(f,0x3f);
	drep(j,10,1){
		mems(g,0x3f);
		rep(i,1,n)if(c[i]==j)solve(i);
		rep(i,1,n)dis[i]=min(dis[i],g[i]);
	}
	printf("%d\n",ans);
}
signed main(){
	int t=1;
	//	scanf("%d",&t);
	while(t--)
		Yorushika();
}
```

---

## 作者：龚祖豪曾用号 (赞：1)

### 题目大意：
题目链接：[https://www.luogu.org/problemnew/show/P1261](https://www.luogu.org/problemnew/show/P1261)

`Byteland`王国准备在各服务器间建立大型网络并提供多种服务。

网络由$n$台服务器组成，用双向的线连接。两台服务器之间最多只能有一条线直接连接，同时，每台服务器最多只能和10台服务器直接连接，但是任意两台服务器间必然存在一条路径将它们连接在一起。每条传输线都有一个固定传输的速度。δ(V, W)表示服务器$V$和$W$之间的最短路径长度，且对任意的$V$有:$δ$ $(V, V)$ $＝$ $0$。

有些服务器比别的服务器提供更多的服务，它们的重要程度要高一些。我们用$r(V)$表示服务器V的重要程度$(rank)$。$rank$越高的服务器越重要。

每台服务器都会存储它附近的服务器的信息。当然，不是所有服务器的信息都存，只有感兴趣的服务器信息才会被存储。服务器$V$对服务器$W$感兴趣是指，不存在服务器$U$满足:
$r(U)>r(W)$且$δ(V, U)<=δ(V, W)$。

举个例子来说，所有具有最高$rank$的服务器都会被别的服务器感兴趣。如果V是一台具有最高$rank$的服务器，由于$δ$ $(V, V)$ $＝$ $0$，所以V只对具有最高$rank$的服务器感兴趣。我们定义$B(V)$为$V$感兴趣的服务器的集合。

我们希望计算所有服务器储存的信息量，即所有服务器的$|B(V)|$之和。Byteland王国并不希望存储大量的数据，所以所有服务器存储的数据量$(|B(V)|$之和$)$不会超过$30n$。
你的任务是写一个程序，读入`Byteland`王国的网络分布，计算所有服务器存储的数据量。

### 思路：
显然暴力做法就是跑$n $遍单元最短路。

考虑到答案不会太大（所有服务器存储的数据量$(∣ B ( V ) ∣ |B(V)|∣B(V)∣$之和$)$不会超过$30 n$ )，所以可以考虑对暴力算法优化。

设$f [ x ] [ i ]$ $f[x][i]f[x][i]$表示距离点$x$最近的$r a n k ≥ i$ 的点的距离。

那么如果我们在跑点$S$的最短路时，最短路跑到点$u$，接下来要转移到点$v$ ，但是有$d i s $ $[ S ]$ $[ v ]$ &lt;$ f [ v ]$ $[ r a n k [ S ] + 1 ]$ $dis$ $[S]$ $[v]$ &lt;$f[v]$ $[rank[S]+1]$ $dis[S][v]$ $<$ $f[v][rank[S]+1]$，那么就有:

$d i s [ S , v ]$ = $d i s [ S , u ]$ $+$ $d i s [ v , u ] $ $≥$ $ f [ r a n k [ S ] + 1 ]$ $[ v ]$ $+$ $d i s [ u , v ] $ $≥$ $ f [ r a n k [ S ] + 1 ]$ $ [ u ] $

所以这样显然不会更新答案。

所以我们根本不必把$v$扔进（优先）队列里。

这样就可以过了。

### 代码：
```
#include <queue>
#include <cstdio>
#include <cstring>
#define mp make_pair
using namespace std;

const int N=30010;
int n,m,tot,ans,rank[N],f[N][15],dis[N],head[N];
bool vis[N],flag[N];
queue<int> r[15];

struct edge
{
    int next,to,dis;
}e[N*10];

void add(int from,int to,int dis)
{
    e[++tot].to=to;
    e[tot].dis=dis;
    e[tot].next=head[from];
    head[from]=tot;
}

void dij_rank(int rk)
{
    memset(vis,0,sizeof(vis));
    priority_queue<pair<int,int> > q;
    while (r[rk].size())
    {
        int x=r[rk].front();
        f[x][rk]=0;
        q.push(mp(0,x));
        r[rk].pop();
    }
    while (q.size())
    {
        int u=q.top().second,v;
        q.pop();
        if (vis[u]) continue;
        vis[u]=1;
        for (int i=head[u];~i;i=e[i].next)
        {
            v=e[i].to;
            if (f[v][rk]>f[u][rk]+e[i].dis)
            {
                f[v][rk]=f[u][rk]+e[i].dis;
                q.push(mp(-f[v][rk],v));
            }
        }
    }
}

void dij(int S)
{
    memset(vis,0,sizeof(vis));
    memset(dis,0x3f3f3f3f,sizeof(dis));
    memset(flag,0,sizeof(flag));
    priority_queue<pair<int,int> > q;
    q.push(mp(0,S));
    dis[S]=0;
    while (q.size())
    {
        int u=q.top().second,v;
        if (!flag[u])
        {
            flag[u]=1;
            ans++;
        }
        q.pop();
        if (vis[u]) continue;
        vis[u]=1;
        for (int i=head[u];~i;i=e[i].next)
        {
            v=e[i].to;
            if (dis[v]>dis[u]+e[i].dis)
            {
                dis[v]=dis[u]+e[i].dis;
                if (dis[v]<f[v][rank[S]+1])
                    q.push(mp(-dis[v],v));
            }
        }
    }
}

int main()
{
    memset(head,-1,sizeof(head));
    memset(f,0x3f3f3f3f,sizeof(f));
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
    {
        scanf("%d",&rank[i]);
        r[rank[i]].push(i);
    } 
    for (int i=1;i<=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
        add(y,x,z);
    }
    for (int i=10;i>=1;i--)
    {
        dij_rank(i);
        if (i<10)	
            for (int j=1;j<=n;j++)
                if (f[j][i]>f[j][i+1]) f[j][i]=f[j][i+1];
    }
    for (int i=1;i<=n;++i)
    	dij(i);
    printf("%d",ans);
    return 0;
}
```

---


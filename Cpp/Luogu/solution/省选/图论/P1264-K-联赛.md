# K-联赛

## 题目描述

K-联赛职业足球俱乐部的球迷们都是有组织的训练有素的啦啦队员，就像红魔啦啦队一样（2002 年韩日世界杯上韩国队的啦啦队）。

这个赛季，经过很多场比赛以后，球迷们希望知道他们支持的球队是否还有机会赢得最后的联赛冠军。换句话说，球队是否可以通过某种特定的比赛结果最终取得最高的积分（获胜场次最多），允许出现多支队并列第一的情况。

现在，有 $n$ 支球队，每支队伍已经胜负的场次分别是 $w_i$ 和 $d_i$。同时还有些比赛没有进行，第 $i$ 支球队和第 $j$ 支球队之间还剩 $a_{ij}$ 场比赛要进行。

你需要找出所有可能获得冠军的球队。

所有队参加的比赛数是相同的，并且为了简化问题，你可以认为不存在平局，即比赛结果只有胜或负两种。

## 说明/提示

对于 $100\%$ 的数据满足，$n\le 25$，$w_i,d_i\le 100$，$a_{ij}\le 10$，$a_{ij}=a_{ji}$，$a_{ii}=0$。

## 样例 #1

### 输入

```
3
2 0 1 1 0 2
0 2 2 2 0 2 2 2 0
```

### 输出

```
1 2 3
```

## 样例 #2

### 输入

```
3
4 0 2 2 0 4
0 1 1 1 0 1 1 1 0
```

### 输出

```
1 2
```

## 样例 #3

### 输入

```
4
0 3 3 1 1 3 3 0
0 0 0 2 0 0 1 0 0 1 0 0 2 0 0 0
```

### 输出

```
2 4
```

# 题解

## 作者：PrimoPan (赞：15)

看一个队是否有希望夺冠，即这个队伍将所有能赢的比赛都赢下来，算出这个队最多拿多少分，再判断其他队的积分是否有可能都低于这个最高分。

将所有球队作为图中结点，每两队比赛也作为图中结点。从S引一条边到比赛结点，容量为两队还剩的比赛数，从每队结点连一条边到T，容量为这个队和当前最高分的差，如果一个比赛结点代表的是A和B的比赛，那么从这个结点连两条边分别到A的结点和B的结点 容量为INF

如果这个网络的最大流等于所有未进行的比赛场次之和，则当前球队可以成为冠军

把每个队枚举一遍即可
















```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 700;
const int INF = 1000000000;
struct Edge {
  int from, to, cap, flow;
};
bool operator < (const Edge& a, const Edge& b) {
  return a.from < b.from || (a.from == b.from && a.to < b.to);
}
struct Dinic {
  int n, m, s, t;
  vector<Edge> edges;    // 边数的两倍
  vector<int> G[maxn];   // 邻接表，G[i][j]表示结点i的第j条边在e数组中的序号
  bool vis[maxn];        // BFS使用
  int d[maxn];           // 从起点到i的距离
  int cur[maxn];         // 当前弧指针
  void init(int n) {
    for(int i = 0; i < n; i++) G[i].clear();
    edges.clear();
  }
  void AddEdge(int from, int to, int cap) {
    edges.push_back((Edge){from, to, cap, 0});
    edges.push_back((Edge){to, from, 0, 0});
    m = edges.size();
    G[from].push_back(m-2);
    G[to].push_back(m-1);
  }
  bool BFS() {
    memset(vis, 0, sizeof(vis));
    queue<int> Q;
    Q.push(s);
    vis[s] = 1;
    d[s] = 0;
    while(!Q.empty()) {
      int x = Q.front(); Q.pop();
      for(int i = 0; i < G[x].size(); i++) {
        Edge& e = edges[G[x][i]];
        if(!vis[e.to] && e.cap > e.flow) {
          vis[e.to] = 1;
          d[e.to] = d[x] + 1;
          Q.push(e.to);
        }
      }
    }
    return vis[t];
  }
  int DFS(int x, int a) {
    if(x == t || a == 0) return a;
    int flow = 0, f;
    for(int& i = cur[x]; i < G[x].size(); i++) {
      Edge& e = edges[G[x][i]];
      if(d[x] + 1 == d[e.to] && (f = DFS(e.to, min(a, e.cap-e.flow))) > 0) {
        e.flow += f;
        edges[G[x][i]^1].flow -= f;
        flow += f;
        a -= f;
        if(a == 0) break;
      }
    }
    return flow;
  }
  int Maxflow(int s, int t) {
    this->s = s; this->t = t;
    int flow = 0;
    while(BFS()) {
      memset(cur, 0, sizeof(cur));
      flow += DFS(s, INF);
    }
    return flow;
  }
};
Dinic g;
const int maxt = 25 + 5;
int n, w[maxt], d[maxt], a[maxt][maxt];
inline int ID(int u, int v) { return u*n+v+1; }
inline int ID(int u) { return n*n+u+1; }
bool canWin(int team) {
  // 计算team全胜后的总胜利场数
  int total = w[team];
  for(int i = 0; i < n; i++)
    total += a[team][i];
  for(int i = 0; i < n; i++)
    if(w[i] > total) return false;
  // 构图。s=0, 结点(u,v)的编号为u*n+v+1, 结点u的编号为n^2+u+1, t=n^2+n+1
  g.init(n*n+n+2);
  int full = 0;
  int s = 0, t = n*n+n+1;
  for(int u = 0; u < n; u++) {
    for(int v = u+1; v < n; v++) {
      if(a[u][v] > 0) g.AddEdge(s, ID(u,v), a[u][v]); // S到(u,v)的弧
      full += a[u][v];
      g.AddEdge(ID(u,v), ID(u), INF); // (u,v)到u的弧
      g.AddEdge(ID(u,v), ID(v), INF); // (u,v)到v的弧
    }
    if(w[u] < total) g.AddEdge(ID(u), t, total-w[u]); // u到T的弧
  }
  return g.Maxflow(s, t) == full;
}
int main() {
    scanf("%d", &n);
    for(int i = 0; i < n; i++) scanf("%d%d", &w[i], &d[i]);
    for(int i = 0; i < n; i++)
      for(int j = 0; j < n; j++)
        scanf("%d", &a[i][j]);
     bool first = true;
    for(int i = 0; i < n; i++)
      if(canWin(i)) {
        if(first) first = false; else printf(" ");
        printf("%d", i+1);
      }
    printf("\n");
    return 0;
}
```

---

## 作者：Kinandra (赞：4)

标签:网络流.

枚举每个队伍, 判断这个队伍是否可以成为冠军.

贪心地让这个队伍赢得所有之后参加的比赛, 记赢得之后的比赛的获胜总场数为 $x$ , 则我们希望构造一个方案, 使得其他队伍的胜场最大值不大于 $x$ .

这个问题可以很简单的通过网络流来解决: 因为其他队伍的胜场最大不大于 $x$ , 则其之后能赢的场数不大于 $y_i=x-w_i$ 场, 由于每一场比赛会使参赛的双方中的恰好一支队伍胜场 $+1$ , 那么实际上我们需要构造的是一个比赛与队伍的带权二分图匹配(实际上似乎可以使用匈牙利算法解决), 判断比赛是否可以完全被匹配即可.

时间复杂度 $\mathcal O(n^3)$ .

```cpp
#include <bits/stdc++.h>
using namespace std;
int read();

int n, s, t, vcnt;
int w[51], a[51][51], id[51][51];

int hd[3003], nx[6003], to[6003], c[6003], cnt;
void add(int f, int t, int cap) {
    nx[++cnt] = hd[f], hd[f] = cnt, to[cnt] = t, c[cnt] = cap;
}
void add_E(int f, int t, int cap) { add(f, t, cap), add(t, f, 0); }

int dep[3003];
queue<int> q;
bool bfs() {
    for (int i = 1; i <= vcnt; ++i) dep[i] = 0;
    dep[s] = 1, q.push(s);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int i = hd[u], v; i; i = nx[i])
            if (!dep[v = to[i]] && c[i]) dep[v] = dep[u] + 1, q.push(v);
    }
    return dep[t];
}
int iter[3003];

int dfs(int u, int dist) {
    if (u == t) return dist;
    for (int &i = iter[u], v; i; i = nx[i]) {
        if (!c[i] || dep[v = to[i]] != dep[u] + 1) continue;
        int d = dfs(v, min(dist, c[i]));
        if (d) return c[i] -= d, c[i ^ 1] += d, d;
    }
    return 0;
}

int Dinic() {
    int rt = 0, d;
    while (bfs()) {
        for (int i = 1; i <= vcnt; ++i) iter[i] = hd[i];
        while (d = dfs(s, 10000000)) rt += d;
    }
    return rt;
}
void solve(int p) {
    cnt = 1;
    for (int i = 1; i <= vcnt; ++i) hd[i] = 0;
    int lim = w[p], rt = 0;
    for (int i = 1; i <= n; ++i) lim += a[p][i];
    for (int i = 1; i <= n; ++i) {
        if (i == p) continue;
        if (w[i] > lim) return;
        add_E(i, t, lim - w[i]);
        for (int j = 1; j < i; ++j)
            if (j != p && a[i][j]) {
                add_E(s, id[i][j], a[i][j]), rt += a[i][j];
                add_E(id[i][j], i, a[i][j]), add_E(id[i][j], j, a[i][j]);
            }
    }
    if (Dinic() == rt) printf("%d ", p);
}

int main() {
    n = read(), s = n + 1, t = n + 2, vcnt = n + 2;
    for (int i = 1; i <= n; ++i) w[i] = read(), read();
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j) a[i][j] = read();
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j < i; ++j) id[i][j] = ++vcnt;
    for (int i = 1; i <= n; ++i) solve(i);
    puts("");
    return 0;
}

int read() {
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();
    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}

```


---

## 作者：KEBrantily (赞：3)

比较好的网络流题。

## Description

给出每个队目前的胜场，已经还未进行的比赛情况，问有哪些队伍可能会成为全场胜场最多的队伍。

## Solution

这个建图有最小权闭合子图的感觉。

首先，考虑什么时候可以胜场最多，显然是如果一个队伍剩下的所有比赛都赢了，然后获胜的场次是全场最多时，他才有可能是全场胜场最多的。

所以我们就可以遍历每个队伍，依次让他们取得所有的胜利，然后判断一下他们是否可以成为胜场最多的队伍。

因为每两个队伍进行一场比赛，所以我们可以将比赛和队伍分别作为点来建图。

具体方法如下，对于每个队伍：

- 首先统计当前队伍的最大胜场（已胜和可能胜的）；

- 源点向对于每组比赛连容量为比赛场次的边；

- 每组比赛向参加的两支队伍分别连容量无穷大的边；

- 每支队伍向汇点连容量为自己的当前胜场数与当前的最大胜场差值的边。


然后跑出的每组最大流，如果等于当前还未进行的总场次，那么说明当前这支队伍可能成为全场胜场最多的队伍。

然后有几个地方：

1. 如果统计完一个队伍的胜场之后仍比另一个队伍的已胜场次少，那么就不用跑网络流了；

1. 如果当前边的容量是 0 的话可以不用建这条边，否则会出奇奇怪怪的错误，比如超时等等；

1. 总场次如果在输入中处理，记得除以二；

1. 每次循环记得初始化。

```cpp
#include<cmath>
#include<queue>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#define rr register 
#define maxn 5010
#define INF 0x3f3f3f3f
//#define int long long
using namespace std;

int n,tot=1,s,t,cnt,all;
int a[maxn][maxn],id[maxn][maxn];
int Dis[maxn],head[maxn],cur[maxn];
struct node{int win,defeat;}b[maxn];
struct edge{int fr,to,dis,nxt;}e[maxn*maxn];

inline int read(){
    rr int s=0,w=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+ch-'0',ch=getchar();
    return s*w;
}

void add(int fr,int to,int dis){
    e[++tot]=(edge){fr,to,dis,head[fr]};head[fr]=tot;
    e[++tot]=(edge){to,fr,0,head[to]};head[to]=tot;
}

bool bfs(){
    memset(Dis,-1,sizeof Dis);
    queue<int> q;q.push(s);
    Dis[s]=0;cur[s]=head[s];
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=head[u];i;i=e[i].nxt){
            int to=e[i].to;
            if(e[i].dis&&Dis[to]==-1){
                q.push(to);
                Dis[to]=Dis[u]+1;
                cur[to]=head[to];
                if(to==t) return true;
            }
        }
    }
    return false;
}

int dfs(int u,int limit){
    if(u==t) return limit;int flow=0;
    for(int i=cur[u];i&&flow<limit;i=e[i].nxt){
        int to=e[i].to;cur[u]=i;
        if(e[i].dis&&Dis[to]==Dis[u]+1){
            int f=dfs(to,min(e[i].dis,limit-flow));
            if(!f)Dis[to]=-1;e[i].dis-=f;e[i^1].dis+=f;
            flow+=f;
        }
    }
    return flow;
}

int dinic(){
    int Maxflow=0,flow=0;
    while(bfs())
        while(flow=dfs(s,INF))
            Maxflow+=flow;
    return Maxflow;
}

void clear(){
    tot=1;
    memset(cur,0,sizeof cur);
    memset(head,0,sizeof head);
}

int main(){
    n=read();s=n*(n+3);t=s+1;
    for(rr int i=1;i<=n;i++)
        b[i].win=read(),b[i].defeat=read();
    for(rr int i=1;i<=n;i++)for(rr int j=1;j<=n;j++)
        all+=(a[i][j]=read()),id[i][j]=++cnt;
    for(rr int i=1,tMxs;i<=n;i++){
        tMxs=b[i].win;bool flag=0;
        for(rr int j=1;j<=n;j++) tMxs+=a[i][j];
        for(rr int j=1;j<=n;j++) if(tMxs<b[j].win){flag=1;break;}
        if(flag) continue;
        for(rr int j=1;j<=n;j++){
            for(rr int k=j+1;k<=n;k++){
                if(a[k][j]) add(s,id[j][k]+n,a[k][j]);
                add(id[j][k]+n,j,INF),add(id[j][k]+n,k,INF);
            }   
            if(tMxs-b[j].win>=0) add(j,t,tMxs-b[j].win);
        }
        int ans=dinic();
        if(ans==all/2) printf("%d ",i);clear();
    }
    return 0;
}
```


---

## 作者：mjsdnz (赞：1)

+ [原题连接](https://www.luogu.com.cn/problem/P1264)

## 题目大意
给你一个球队现在的胜利场次（失败场次屁用没有），以及没有进行的比赛 $a_{i,j}$，找出可能成为胜利次数最多的球队。

## 建模
很明显，一个队跑一次最大流，当前队（现在跑网络流的队伍）能夺冠的条件就是其他队的胜利数都小于等于当前队的最大胜利数（废话）。

我们将当前队的最大胜利数表示为 $mx$，第 $i$ 队的胜利上限为 $lim_{i}$，则 $lim_{i}=mx-w_{i}$。

将每场比赛离散化一下，从源点向每个比赛连边，每个比赛向两个队连边，流量都为这两个队比赛的次数 $a_{i,j}$。

每个队向汇点连边，流量为当前队（设当前队为 $x$）的最大胜利次数减去其他队的胜利数 $w_{x}-w_{i}+\sum_{i=1}^{n}a_{x,i}$。

最后只要判断最大流是不是当前队的最大胜利次数即可。

注意：
- 不要自己打自己。
- 不要连负流量的边。
- 不要忘记当前弧优化。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int inf = 0x3f3f3f3f;
const int N = 1e4 + 10;
const int M = 2e4 + 10;
struct edge {
	int u, v, c, val, nxt;
	edge(int u = 0, int v = 0, int c = 0, int val = 0, int nxt = 0): u(u), v(v), c(c), val(val), nxt(nxt) {}
} e[M];
int cnt = 1;
int head[N];
void ADD(int u, int v, int c, int val = 0) {
	cnt++;
	e[cnt] = edge(u, v, c, val, head[u]);
	head[u] = cnt;
}
void add_edge(int u, int v, int c, int val = 0) {
	ADD(u, v, c, val);
	ADD(v, u, 0, -val);
}
int dep[N];
int n;
int s, t, tot;
int now[N];
int a[100][100];
int loc[100][100];
int w[N];
bool bfs() {
	memset(dep, 0, sizeof dep);
	memcpy(now, head, sizeof head);
	dep[s] = 1;
	queue<int>q;
	q.push(s);
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		for (int i = head[u]; i; i = e[i].nxt) {
			int v = e[i].v;
			int c = e[i].c;
			if (!c || dep[v] != 0)continue;
			dep[v] = dep[u] + 1;
			q.push(v);
		}
	}
	return dep[t];
}
int dfs(int u, int t, int flow) {
	if (u == t) return flow;
	for (int i = now[u]; i; i = e[i].nxt) {
		now[u] = i;
		int v = e[i].v;
		int c = e[i].c;
		if (!c || dep[v] != dep[u] + 1) continue;
		int ff = dfs(v, t, min(flow, c));
		if (ff) return e[i].c -= ff, e[i ^ 1].c += ff, ff;
	}
	return 0;
}
int maxflow() {
	int ans = 0;
	while (bfs()) {
		int nowflow;
		while ((nowflow = dfs(s, t, inf))) ans += nowflow;
	}
	return ans;
}
void work(int x) {
	cnt = 1;
	memset(head, 0, sizeof head);
	int mx = w[x];
	int ans = 0;
	for (int i = 1; i <= n; i++) mx += a[x][i];
	for (int i = 1; i <= n; i++) {
		if (i == x) continue;
		if (w[i] > mx) return;
		add_edge(i, t, mx - w[i]);
		for (int j = 1; j < i; j++) {
			if (j != x && a[i][j]) {
				add_edge(s, loc[i][j], a[i][j]);
				add_edge(loc[i][j], i, a[i][j]);
				add_edge(loc[i][j], j, a[i][j]);
				ans += a[i][j];
			}
		}
	}
	if (maxflow() == ans) cout << x << " ";
}
int main() {
	cin >> n;
	s = n + 1;
	t = n + 2;
	tot = t;
	for (int i = 1; i <= n; i++) {
		cin >> w[i];
		int sb;
		cin >> sb;
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> a[i][j];
		}
	}
	for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) loc[i][j] = ++tot;
	for (int i = 1; i <= n; i++) work(i);
}
```

---

## 作者：有趣的问题 (赞：1)

### 题目大意

已知每支队伍的胜场和待比赛的情况，求可能成为胜场最多的队伍个数（并列也算最多）。

### 解题思路

贪心：对于每支队伍，要想胜场最多，显然未参与的所有比赛都应获胜。

判断：枚举每支队伍，判断其他队伍的胜场能否不超过该队伍。

### 建图

考虑对比赛和队伍分别建点。

因为要保证所有其他队伍的胜场不超过当前枚举的队伍 $i$，所以从其他队伍向汇点连一条容量为该队伍还能获胜的最多场次，即 $W_i-w_j$ 的边（其中 $W_i$ 为队伍 $i$ 赢得所有比赛获得的胜场数，预处理出来）。

同时，对于每场比赛，向参与比赛的两支队伍分别连上容量为比赛场数，即 $a_{ij}$ 的边，再从源点向每场比赛连上相同容量的边。

此时的网络最大流表示在所有队伍胜场不超过队伍 $i$ 的前提下，能匹配的比赛场数。因此将网络最大流与队伍 $i$ **不**参与的比赛场数进行比较，若相等则说明队伍 $i$ 可能获胜，输出即可。

### 处理细节

+ 建点连边时，要跳过当前枚举的队伍及其参加的比赛。

+ 连边时，每两个队伍间的比赛只连一条边。

+ 对于一支队伍 $i$，若存在另一支队伍 $j$ 使得 $w_j>W_i$，则显然队伍 $i$ 不可能成为胜场最多的队伍，此时不用跑网络流。

+ 若两支队伍之间已经没有比赛，则不需要连边。

+ 每次枚举要初始化。

### 丑陋的代码

```cpp

#include <bits/stdc++.h>
using namespace std;
int n,sh[30],fu[30],maxm[30],sai[30][30],cnt=1,lst[100005],s,t,sum,pre,mid,dep[100005],now[100005],inf=0x3f3f3f3f;
struct edge{
	int f,t,val,lst;
	edge(int f=0,int t=0,int val=0,int lst=0):
		f(f),t(t),val(val),lst(lst){};
}e[100005];
void add(int u,int v,int val){
	e[++cnt]=edge(u,v,val,lst[u]);
	lst[u]=cnt;
	e[++cnt]=edge(v,u,0,lst[v]);
	lst[v]=cnt;
}
bool bfs(){
	memset(dep,-1,sizeof(dep));
	queue<int> q;
	q.push(s),dep[s]=0;
	while(!q.empty()){
		int u=q.front();
		now[u]=lst[u];
		q.pop();
		for(int i=lst[u];i;i=e[i].lst){
			int v=e[i].t;
			if(e[i].val&&dep[v]==-1){
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}
	return dep[t]!=-1;
}
int dfs(int u,int in){
	if(u==t)return in;
	int out=0;
	for(int i=now[u];i;i=e[i].lst){
		now[u]=i;
		int v=e[i].t;
		if(e[i].val&&dep[v]==dep[u]+1){
			int go=dfs(v,min(in,e[i].val));
			e[i].val-=go;
			e[i^1].val+=go;
			in-=go,out+=go;
			if(go==0)dep[v]=-1;
			if(in==0)break;
		}
	}
	if(out==0)dep[u]=-1;
	return out;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>sh[i]>>fu[i];
	for(int i=1;i<=n;i++){
		maxm[i]=sh[i];
		for(int j=1;j<=n;j++){
			cin>>sai[i][j];
			maxm[i]+=sai[i][j];
			sum+=sai[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		bool fl=0;
		for(int j=1;j<=n;j++){
			if(i==j)continue;
			if(sh[j]>maxm[i]){
				fl=1;
				break;
			}
		}
		if(fl)continue;
		s=0,t=(n-1)*(n-2)/2+n+1,mid=(n-1)*(n-2)/2;
		for(int j=0;j<=cnt;j++)e[j].f=e[j].t=e[j].val=lst[j]=e[j].lst=0;
		cnt=1,pre=0;
		for(int j=1;j<=n;j++){
			if(j==i)continue;
			add(mid+j,t,maxm[i]-sh[j]);
			for(int k=j+1;k<=n;k++){
				if(k==i)continue;
				add(0,++pre,sai[j][k]);
				add(pre,mid+j,inf);
				add(pre,mid+k,inf);
			}
		}
		int ans=0;
		while(bfs()){
			ans+=dfs(s,inf);
		}
		if(ans==sum/2-maxm[i]+sh[i])cout<<i<<' ';
	}
	return 0;
}

```

---

## 作者：羊羊君的幻想 (赞：0)

## 题意

[P1264 K-联赛](https://www.luogu.com.cn/problem/P1264)

题目说得很简洁了。

## 题解

发现 $n$ 很小，所以考虑枚举最终会获胜的队伍 $i$，然后跑一些算法去检验是否可以获胜。

首先贪心的想，$i$ 要获胜一定把能赢的比赛全部都赢下来。然后考虑判断其他队伍胜利数是否超过 $i$。

发现失败数对决出冠军没有影响，所以我们就相当于在剩下的和 $i$ 无关的比赛中选出胜利的即可。

所以就是相当于分配胜利的数目。

考虑网络流。

对于每场比赛：

- 对每个比赛 $(i,j)$ 建点；

- 源点向这个点连流量为 $a_{i,j}$ 的边；

- 这个点分别向 $i,j$ 连一条流量为 $+\infty$ 的边。

对于每个队伍：

- 不用考虑 $i$，因为默认全部获胜；

- 对于剩下的每个点，计算出其最多能获胜的场次 $w$，朝汇点连一条流量为 $w$ 的边，代表这个点最多能分配的胜利数。

容易发现只要跑满流，那么最终 $i$ 一定可以获胜。

## 代码
```
#include<bits/stdc++.h>
#define int long long
namespace IO{
	inline int read()
	{
		int x=0,f=1;char ch=getchar();
		while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
		while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
		return x*f;
	}
}
using namespace IO;
using namespace std;
const int N=1e3;
const int M=5e5;
const int INF=1e18;
int w[N],sum[N];
int a[N][N];
int n;
struct node{
	int v,nxt,w;
}e[M];
int p[N],eid=1;
int now[N];
void add(int u,int v,int w){
	e[++eid].v=v;
	e[eid].nxt=p[u];
	e[eid].w=w;
	p[u]=eid;
}
void ins(int u,int v,int w){
	add(u,v,w);
	add(v,u,0);
}
int s,t,cnt;
int dis[N];
queue<int> q;
bool bfs(){	
	while(!q.empty()) q.pop();
	for(int i=1;i<=cnt;i++){
		dis[i]=INF;
	}
	dis[s]=0;
	q.push(s);
	now[s]=p[s];
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=p[u];i;i=e[i].nxt){
			int v=e[i].v;
			if(dis[v]==INF&&e[i].w>0){
				q.push(v);
				now[v]=p[v];
				dis[v]=dis[u]+1;
				if(v==t) return 1;
			}
		}
	}
	return 0;
}
int dfs(int u,int sum){
	if(u==t) return sum;
	int minn,ret=0;
	for(int i=now[u];i&&sum;i=e[i].nxt){
		now[u]=i;
		int v=e[i].v;
		int w=e[i].w;
		if(w>0&&(dis[v]==dis[u]+1)){
			minn=dfs(v,min(sum,w));
			if(minn==0) dis[v]=INF;
			e[i].w-=minn;
			e[i^1].w+=minn;
			ret+=minn;
			sum-=minn;
		}
	}
	return ret;
}
int dinic(){
	int ret=0;
	while(bfs()){
		ret+=dfs(s,INF);
	}
	return ret;
}
signed main(){
	n=read();
	int tot=0;
	for(int i=1;i<=n;i++){
		w[i]=read();read();
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			a[i][j]=read();
			sum[i]+=a[i][j];
		}
		tot+=sum[i];
	}
	tot/=2;
	for(int i=1;i<=n;i++){
		memset(e,0,sizeof(e));
		memset(p,0,sizeof(p));
		memset(now,0,sizeof(now));
		eid=1;
		cnt=n;
		s=++cnt;t=++cnt;
		bool flag=1;
		for(int j=1;j<=n;j++){
			if(i==j) continue;
			if(sum[i]+w[i]-w[j]<0){
				flag=0;break;
			}
			ins(j,t,sum[i]+w[i]-w[j]);
		}
		if(!flag) continue;
		for(int j=1;j<=n;j++){
			if(j==i) continue;
			for(int k=j+1;k<=n;k++){
				if(k==i) continue;
				++cnt;
				ins(s,cnt,a[j][k]);
				ins(cnt,j,INF);
				ins(cnt,k,INF);
			}
		}
		if(dinic()==tot-sum[i]) cout<<i<<' ';
	}
return 0;
}

```

---

## 作者：闭电脑沉思 (赞：0)

# P1264 【K-联赛】
## Solution
考虑一个事情：每一个队伍的输局是没有用的

贪心一下，让每个队伍把剩下的比赛赢下来的时候，最有可能夺冠

设最终当前队赢得的场数的 $maxx$ 

然后我们建图

每一场比赛都会让胜者的胜利场次加$1$ ,把 比赛的场次当成一个点，队伍当成一个点

每场比赛向队伍分别连边，边权为 $1$ ，源点向 比赛场次连，然后队伍向汇点连

跑网络流就行了

## $code$
```
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define cl(x) memset(x, 0, sizeof(x))
namespace yspm {
inline int read() {
    int res = 0, f = 1;
    char k;
    while (!isdigit(k = getchar()))
        if (k == '-')
            f = -1;
    while (isdigit(k)) res = res * 10 + k - '0', k = getchar();
    return res * f;
}
int n, s, t, tot;
const int N = 1e4 + 10;
int head[N], w[N], a[N][N], id[N][N], dep[N], cnt = 1;
struct node {
    int nxt, to, lim;
} e[N << 1];
inline void add2(int u, int v, int w) {
    e[++cnt].lim = w;
    e[cnt].nxt = head[u];
    e[cnt].to = v;
    return head[u] = cnt, void();
}
inline void add1(int u, int v, int w) {
    add2(u, v, w);
    add2(v, u, 0);
    return;
}
queue<int> q;
inline bool bfs() {
    cl(dep);
    dep[s] = 1;
    q.push(s);
    while (q.size()) {
        int fr = q.front();
        q.pop();
        for (int i = head[fr]; i; i = e[i].nxt) {
            int t = e[i].to;
            if (!dep[t] && e[i].lim)
                dep[t] = dep[fr] + 1, q.push(t);
        }
    }
    return dep[t];
}
inline int dfs(int now, int in) {
    if (now == t)
        return in;
    for (int i = head[now]; i && in; i = e[i].nxt) {
        int t = e[i].to;
        if (!e[i].lim || dep[t] != dep[now] + 1)
            continue;
        int res = dfs(t, min(e[i].lim, in));
        e[i].lim -= res;
        e[i ^ 1].lim += res;
        if (res)
            return res;
    }
    return 0;
}
inline void solve(int x) {
    cl(head);
    cnt = 1;
    cl(e);
    int maxx = w[x], tmp = 0;
    for (int i = 1; i <= n; ++i) maxx += a[x][i];
    for (int i = 1; i <= n; ++i) {
        if (i == x)
            continue;
        if (w[i] > maxx)
            return;
        add1(i, t, maxx - w[i]);
        for (int j = 1; j < i; ++j) {
            if (j != x && a[i][j]) {
                add1(s, id[i][j], a[i][j]), tmp += a[i][j];
                add1(id[i][j], i, a[i][j]);
                add1(id[i][j], j, a[i][j]);
            }
        }
    }
    int sum = 0, d;
    while (bfs()) {
        while (d = dfs(s, 1e15 + 10)) sum += d;
    }
    if (sum == tmp)
        printf("%lld ", x);
    return;
}
signed main() {
    n = read();
    s = n + 1, t = n + 2, tot = n + 2;
    for (int i = 1, k; i <= n; ++i) w[i] = read(), k = read();
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j) a[i][j] = read();
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j < i; ++j) id[i][j] = ++tot;
    for (int i = 1; i <= n; ++i) solve(i);
    puts("");
    return 0;
}
}
```

节选自[https://www.cnblogs.com/yspm/p/12361174.html](https://www.cnblogs.com/yspm/p/12361174.html)



---


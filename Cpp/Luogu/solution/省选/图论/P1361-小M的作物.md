# 小M的作物

## 题目描述

小 M 在 MC 里开辟了两块巨大的耕地 $A$ 和 $B$（你可以认为容量是无穷），现在，小 P 有 $n$ 种作物的种子，每种作物的种子有 $1$ 个（就是可以种一棵作物），编号为 $1$ 到 $n$。

现在，第 $i$ 种作物种植在 $A$ 中种植可以获得 $a_i$ 的收益，在 $B$ 中种植可以获得 $b_i$ 的收益，而且，现在还有这么一种神奇的现象，就是某些作物共同种在一块耕地中可以获得额外的收益，小 M 找到了规则中共有 $m$ 种作物组合，第 $i$ 个组合中的作物共同种在 $A$ 中可以获得 $c_{1,i}$ 的额外收益，共同种在 $B$ 中可以获得 $c_{2,i}$ 的额外收益。

小 M 很快的算出了种植的最大收益，但是他想要考考你，你能回答他这个问题么？

## 说明/提示

### 样例解释

 $A$ 耕地种作物 $1,2$，$B$ 耕地种作物 $3$，收益： $4+2+3+2=11$。

### 数据范围

对于 $100\%$ 的数据，$1 \le k < n \le 10^3$，$1 \le m \le 10^3$。题目当中出现的所有权值均为不大于 $1000$ 的非负整数。

## 样例 #1

### 输入

```
3
4 2 1
2 3 2
1
2 3 2 1 2```

### 输出

```
11```

# 题解

## 作者：jun头吉吉 (赞：81)

## 题意
给定一些物品，可以放在$A$或$B$中，取得不同收益。
某些物品同时放在$A$或$B$中，可以获得额外收益。
求收益的最大值。
## 题解
看到二者选其一，我们不禁联想到了**最小割**模型

很明显，这道题主要的问题在于建模。若是不考虑额外收益，图是很容易建出来的 ：
- 由源点$S$向它连一条边权为其种在$A$中的价值的边，表示将其种在$A$中；
- 由它向汇点$T$连一条边权为其种在$B$中的价值的边，表示将其种在$B$中；
- 把一条边割掉，则表示不这么种。

这样的图，要使其不连通，每个点都不能同时连接源点$S$和汇点$T$，也就是说，保证**其只属于一个集合**

这时跑一遍最小割，是删去的最小，留下的就是最大的了
~~假装不能直接取最大值~~

但是现在加入了额外收益，应该如何改进上述的图呢？

通过对题意的了解，我们知道：

![example](https://cdn.luogu.com.cn/upload/image_hosting/mdst9ac1.png)


1. 如果割掉了$1$、$2$，那么把边权为$c_{1}$的边也要割掉
1. 如果割掉了$3$、$4$，那么把边权为$c_{2}$的边也要割掉
1. 如果割掉了$1$、$4$或者$2$、$3$，那么两条边都要割掉

此时，我们已经大致想到此图的构图方法了。由$1$、$2$我们了解到，$c_1\ \  c_2$应该分别与$1\text{、}2$，$3\text{、}4$并联 ~~电学乱入~~，于是我们~~瞎搞~~思考出了下图：
![乱搞成果](https://cdn.luogu.com.cn/upload/image_hosting/ximtf967.png)

其中$\color{SkyBlue}{\text{蓝色}}$
的边边权是$+\infty$，是不能删除的

我们发现，此图非常符合题目的限制。于是我们建个图套个板子就A了

```cpp
#pragma GCC optimize(3,"Ofast","inline")
#include<bits/stdc++.h>
namespace in{
	char buf[1<<21],*p1=buf,*p2=buf;
	inline int getc(){
	    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;
	}
	template <typename T>inline void read(T& t){
	    t=0;int f=0;char ch=getc();
	    while (!isdigit(ch)){
	        if(ch=='-')f = 1;
	        ch=getc();
	    }
	    while(isdigit(ch)){
   	    	t=t*10+ch-48;
   	    	ch = getc();
   		}
		if(f)t=-t;
	}
	template <typename T,typename... Args> inline void read(T& t, Args&... args){
	    read(t);read(args...);
	}
}
namespace out{
	char buffer[1<<21];
	int p1=-1;
	const int p2 = (1<<21)-1;
	inline void flush() {
		fwrite(buffer,1,p1+1,stdout),
		p1=-1;
	}
	inline void putc(const char &x) {
		if(p1==p2)flush();
		buffer[++p1]=x;
	}
	template <typename T>void write(T x) {
		static char buf[15];
		static int len=-1;
		if(x>=0){
			do{
    			buf[++len]=x%10+48,x/=10;
    		}while (x);
		}else{
    		putc('-');
			do {
    			buf[++len]=-(x%10)+48,x/=10;
			}while(x);
		}
		while (len>=0)
			putc(buf[len]),--len;
	}
}
using namespace std;
const int maxn=40010,maxe=1000010*2;
struct Graph{
	struct node{
		int v,w,nxt;
	}e[maxe<<1];
	int head[maxn],cur[maxn],tot;
	int dis[maxn];
	int s,t;
	void init(int _s,int _t){s=_s,t=_t;tot=1;memset(head,0,sizeof head);}
	Graph(int _s=0,int _t=0){init(_s,_t);}
	void add(int u,int v,int w){
		//printf("%d %d %d\n",u,v,w);
		e[++tot]=(node){v,w,head[u]},head[u]=tot;
		e[++tot]=(node){u,0,head[v]},head[v]=tot;
	}
	#define v e[i].v
	inline bool bfs(){
		queue<int>q;
		memset(dis,0,sizeof dis);
		memcpy(cur,head,sizeof head);
		dis[s]=1;q.push(s);
		while(q.size()){
			int u=q.front();q.pop();
			for(int i=head[u];i;i=e[i].nxt)
				if(!dis[v]&&e[i].w){
					dis[v]=dis[u]+1,q.push(v);
					if(v==t)return true;
				}
		}
		return  false;
	}
	int dfs(int u,int flow){
		if(u==t)return flow;
		int rest=flow;
		for(int i=cur[u];i&&rest;i=e[i].nxt){
			if(dis[v]==dis[u]+1&&e[i].w){
				int tmp=dfs(v,min(rest,e[i].w));
				rest-=tmp,e[i].w-=tmp,e[i^1].w+=tmp;
			}
			cur[u]=i;
		}
		if(rest==0)dis[u]=-1;
		return flow-rest;
	}
	#undef v
	int dinic(){
		int ans=0;
		while(bfs())
			while(int sth=dfs(s,2e9))
				ans+=sth;
		return ans;
	}
}G;
int n,m,c[1000],tot;
int sum=0;
signed main(){
	//freopen("1.in","r",stdin);
	G.init(1000+1000*4+100,1000+1000*4+101); 
	in::read(n);tot=n;
	for(int i=1;i<=n;i++){
		int tmp;in::read(tmp);
		G.add(G.s,i,tmp);
		sum+=tmp;
	}
	for(int i=1;i<=n;i++){
		int tmp;in::read(tmp);
		G.add(i,G.t,tmp);
		sum+=tmp;
	}
	in::read(m);
	for(int i=1;i<=m;i++){
		int k,c1,c2,tmp;
		in::read(k,c1,c2);
		G.add(G.s,tot+1,c1);
		G.add(tot+2,G.t,c2);
		sum+=c1+c2;
		for(int j=1;j<=k;j++){
			in::read(tmp);
			G.add(tot+1,tmp,2e9);
			G.add(tmp,tot+2,2e9);
		}
		tot+=2;
	}
	out::write(sum-G.dinic());
	out::flush();
	return 0;
}
```

---

## 作者：ButterflyDew (赞：76)

题目很棒。

从我个人的角度来说，可能有那么不太准确的一句话加深了我的理解。

最小割在数值上与最大流相等，但在本身性质上与网络流无任何关系。

它的不那么准确的定义是：**在一个图中，割去权值和最小的边集，使这个图分成两个部分，切下来的那一刀叫做最小割。最小割并不唯一，但它在数值上是等于最大流的**。

对于这个题的模型来说，它有一个名字叫做**二者取一式问题**，在具体题目中的体现即为把点集一分为二。

类似的题目有[善意的投票](https://www.luogu.org/problemnew/show/P2057)

虽然说了最小割与网络流无关系，但只是在定义或者说是意义上，真正要到建模时，还需要将两者综合考虑。

先考虑没有额外收益情况下的建图。

![](http://m.qpic.cn/psb?/V14VFGnz4fbJRr/hj1ajou0Rsm281kSiFj7z6*UXkaX0Uboq17fnL.ahB0!/b/dFYBAAAAAAAA&bo=pgJnAaYCZwEDCSw!&rf=viewer_4)

设源点S属于集合A,汇点T属于集合B，则显然点与源点所连的有向边为这个点归属于集合A所产生的收益，与汇点相连则同理。则原图边权之和-最小割就是本题的答案了。

在这个图的基础上，考虑如何把点集给加入。

首先明确一点，点集的贡献有三种情况，对集合A贡献，对集合B贡献或者不贡献。这意味着只划分出一种状态是无法描述的，至少要把A与B的情况分开描述。

讨论一个对$A$有贡献的点集$\{c,d\}$。

依据题目，我们对这个点集的要求是，只要$c,d$有一个点被割到了集合$T$，这个点集都无法产生贡献。换而言之，只要$c$或$d$在集合$B$，代表点集贡献的边必须要断开。

先尝试着连接这条贡献边，因为这条边不可能直接连到图中代表作物的点上，所以连接一个虚点上去。

![](http://m.qpic.cn/psb?/V14VFGnz4fbJRr/NNAGO3JptVlvEnKYZvkHHtQp6bXKTuZT9s.3xX2zgRM!/b/dDABAAAAAAAA&bo=fgJUAX4CVAEDGTw!&rf=viewer_4)

X为点集所产生的虚点。

如果$c$被割到了集合$B$，则所有从$S$到$c$的路径都得被断开（具体只路径的一条边断掉），如果我们想要黄边断掉，那么虚点$X$连$c$的那条路径不能被断掉。而容量为正无穷的边不可能被断掉，于是我们这样建图。

![](http://m.qpic.cn/psb?/V14VFGnz4fbJRr/ua*Uh62JYJMw246lyEHMygXlJLY2NhT3K5ZsGKq6NwQ!/b/dC0BAAAAAAAA&bo=fQJFAX0CRQEDGTw!&rf=viewer_4)
两条蓝色的边的边权为$inf$

对待贡献$B$集合的点，同理

![](http://m.qpic.cn/psb?/V14VFGnz4fbJRr/E8sYvzooansm*Ys3MhIvwFMJPcm4teMjJSPqoE8UE0U!/b/dDABAAAAAAAA&bo=cAJTAXACUwEDGTw!&rf=viewer_4)

建图跑网络流即可。

要注意的一点是，这题卡常，~~吸氧才水过去的~~

[露迭月喵~](http://www.cnblogs.com/ppprseter/)

------------
**Code**
```
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int N=3010;
const int M=2000100;
const int inf=0x3f3f3f3f;
int head[N],edge[M],to[M],next[M],cnt=1;
void add(int u,int v,int w)
{
    to[++cnt]=v;next[cnt]=head[u];edge[cnt]=w;head[u]=cnt;
    to[++cnt]=u;next[cnt]=head[v];edge[cnt]=0;head[v]=cnt;
}
int dep[N],used[N],pre[N],tot,s[N],ans,m,n,sum;
queue <int > q;
bool bfs()
{
    while(!q.empty()) q.pop();
    q.push(0);
    memset(dep,0,sizeof(dep));
    dep[0]=1;
    while(!q.empty()&&q.front()!=n+1)
    {
        int u=q.front();
        q.pop();
        for(int i=head[u];i;i=next[i])
        {
            int v=to[i],w=edge[i];
            if(!dep[v]&&w)
            {
                dep[v]=dep[u]+1;
                q.push(v);
            }
        }
    }
    return !q.empty();
}
int main()
{
    scanf("%d",&n);
    int w,v,k,c1,c2;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&w);
        sum+=w;
        add(0,i,w);
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&w);
        sum+=w;
        add(i,n+1,w);
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&k,&c1,&c2);
        add(0,i+n+1,c1);sum+=c1;
        add(i+n+m+1,n+1,c2);sum+=c2;
        for(int j=1;j<=k;j++)
        {
            scanf("%d",&v);
            add(i+n+1,v,inf);
            add(v,i+n+m+1,inf);
        }
    }
    while(bfs())
    {
        memset(used,0,sizeof(used));
        s[++tot]=0;
        while(tot)
        {
            int u=s[tot];
            if(u==n+1)
            {
                int mi=inf,id;
                for(int i=tot;i>1;i--)
                    if(mi>=edge[pre[s[i]]])
                    {
                        mi=edge[pre[s[i]]];
                        id=i;
                    }
                ans+=mi;
                for(int i=tot;i>1;i--)
                {
                    edge[pre[s[i]]]-=mi;
                    edge[pre[s[i]]^1]+=mi;
                }
                tot=id-1;
                used[n+1]=0;
            }
            else
            {
                for(int i=head[u];i;i=next[i])
                {
                    int v=to[i],w=edge[i];
                    if(!used[v]&&dep[v]==dep[u]+1&&w)
                    {
                        used[v]=1;
                        s[++tot]=v;
                        pre[v]=i;
                        break;
                    }
                }
                if(u==s[tot]) tot--;
            }
        }
    }
    printf("%d\n",sum-ans);
    return 0;
}

```


---

## 作者：YoungNeal (赞：27)

题解在博客[食用](http://www.cnblogs.com/YoungNeal/p/8858838.html)效果更佳哦~

好题~

最开始想的费用流结果会答案会变大，看了题解才知道跟最小割有关

我们把源点当做 A 田地，汇点当做 B 田地。

对于作物 i，如果种在 A 的价值是 a[i]，种在 B 的价值是 b[i]，那么就从它向 A 连一条容量为 a[i] 的边，同理，向 B 连一条容量为 b[i] 的边。

为什么要这么做呢？考虑最后的答案，一个点向外连出的两条边必定会有一条被割掉，不然这个点连着两边，相当于两边都种，不符合题意，所以这种情况不符合题意。

必定有一条会被割掉...咦这不是最小割么？

那么我们已经初步转化问题了，即已经把问题转化到最小割上了。

接下来考虑组合的问题。

其实组合也一样，就是让这个组合也分成向 A，B 连边两部分。

先把这个组合拆点。然后其中一个点的入边连上 A，容量是组合种在 A 的额外价值，出边连上这个组合里所有的点，容量是 INF。 B 也是同理。

那么我们就彻底把问题转化了最小割了。但是这题要让 ans 最大，怎么办呢？

好说，把总收益加起来，减去最小割就好了。

```
// By YoungNeal
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#define N 10005
#define inf 0x3f3f3f3f-1

int tot;
int d[N];
int cnt=1;
int dis[N];
int head[N];
int n,m,s,t;

struct Edge{
    int to,nxt,flow;
}edge[4400000];

void add(int x,int y,int z){
    edge[++cnt].to=y;
    edge[cnt].nxt=head[x];
    edge[cnt].flow=z;
    head[x]=cnt;
}

bool bfs(){
    memset(d,0,sizeof d); d[s]=1;
    std::queue<int> q; q.push(s);
    while(q.size()){
        int u=q.front();q.pop();
        for(int i=head[u];i;i=edge[i].nxt){
            int to=edge[i].to;
            if(!edge[i].flow) continue;
            if(d[to]) continue;
            d[to]=d[u]+1;
            q.push(to);
            if(to==t) return 1;
        }
    }
    return 0;
}

int dinic(int now,int flow){
    if(now==t) return flow;
    int rest=flow;
    for(int i=head[now];i;i=edge[i].nxt){
        if(!rest) return flow;
        int to=edge[i].to;
        if(!edge[i].flow) continue;
        if(d[to]!=d[now]+1) continue;
        int k=dinic(to,std::min(rest,edge[i].flow));
        if(!k) d[to]=0;
        rest-=k;
        edge[i].flow-=k;
        edge[i^1].flow+=k;
    }
    return flow-rest;
}

signed main(){
    scanf("%d",&n); s=n+1; t=s+1;
    for(int x,i=1;i<=n;i++) scanf("%d",&x),tot+=x,add(s,i,x),add(i,s,0);
    for(int x,i=1;i<=n;i++) scanf("%d",&x),tot+=x,add(i,t,x),add(t,i,0);
    scanf("%d",&m);
    for(int i=1;i<=m;i++){
        int T,tota,totb;
        scanf("%d%d%d",&T,&tota,&totb);
        tot+=tota+totb;
        add(s,n+2+i,tota); add(n+2+i,s,0);
        add(n+2+i+m,t,totb); add(t,n+2+i+m,0);
        for(int x,j=1;j<=T;j++){
            scanf("%d",&x);
            add(n+2+i,x,inf);
            add(x,n+2+i,0);
            add(x,n+2+i+m,inf);
            add(n+2+i+m,x,0);
        }
    }
    int maxflow=0,flow=0;
    while(bfs()) 
        while(flow=dinic(s,0x3f3f3f3f)) maxflow+=flow;
    printf("%d\n",tot-maxflow);
    return 0;
}
```

---

## 作者：Siyuan (赞：21)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/)

---

> 题目链接：[Luogu 1361](https://www.luogu.org/problemnew/show/P1361)

小 M 在开辟了两块巨大的耕地 $A$ 和 $B$（你可以认为容量无穷），现在他有 $n$ 种作物的种子各 $1$ 个，编号为 $1$ 到 $n$。第 $i$ 种作物在 $A$ 中种植可以获得 $a_i$ 的收益，在 $B$ 中种植可以获得 $b_i$ 的收益。某些作物种在同一块耕地中可以获得额外的收益，小 M 找到 $m$ 种作物的组合，每个组合用 $c_1,c_2,k $ 和一个序列 $p_1,p_2,\cdots.p_k$ 表示，代表这 $k$ 种作物共同种在 $A$ 和 $B$ 耕地中可以分别获得 $c_1$ 和 $c_2$ 的额外收益。求收益的最大值。

数据范围：$1\le n,m\le 1000$

------

## Solution

通过[「算法笔记」网络流 - 最小割](https://hydingsy.github.io/articles/algorithm-Network-Flow-Minimum-Cut/) 中**问题模型**的分析，我们可以发现这题每种作物只能选择一个耕地，满足**二者选其一**的性质，所以我们可以考虑用最小割来解决。

对于单独的作物直接从源点 $s$ 连边或向 $t$ 连边即可，难点在如何处理组合的关系。

首先明确一点，一个组合就是一个点集，它的贡献有三种情况：对集合 $A$ 有贡献；对集合 $B$ 有贡献；没有任何贡献。这意味着只划分出一种状态是无法描述的，我们需要把 $A$ 和 $B$ 集合分开考虑。

接下来讨论点集 $\{u,v,w\}$ 对集合 $A$ 的贡献。

按照题意，我们的要求是：只要 $u,v,w$ 其中一者被割进了集合 $B$（连向 $t$），那么这个点集都没有贡献。换言之，只要其中一个点在集合 $B$，那么代表点集和集合 $A$ 的连边必须断开！

我们先用一个虚点 $x$ 从 $s$ 连一条代表贡献的边（显然点集必须用一个虚点代替）。如果其中一个点被割进了集合 $B$，那么这条代表贡献的边就要被断开，而 $x$ 到 $u,v,w$ 的边不能被断开。所以我们可以得到：边 $(s,x)$ 的容量为 $c_1$，边 $(x,u),(x,v),(x,w)$ 的容量均为 $\texttt{INF}$（因为只有容量为正无穷的边不可能被断开）。

这个点集对集合 $B$ 的贡献同理。经过检验，我们发现这样的连边方式是完全正确的！直接建图跑最小割即可。

**注意**：答案为总的收益减去最小割！

**时间复杂度**：$O(n^2m)$

------

## Code 

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

const int N=3e3+5,M=5e6+5;
int n,m,tot=1,a[N],b[N],lnk[N],ter[M],nxt[M],val[M],dep[N],cnr[N];

int id(int p,int x) {
    switch(p) {
        case 1: return x;
        case 2: return m+x;
        case 3: return m+n+x;
    }
}
void add(int u,int v,int w) {
    ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,val[tot]=w;
}
void addedge(int u,int v,int w) {
    add(u,v,w),add(v,u,0);
}
int bfs(int s,int t) {
    memset(dep,0,sizeof(dep));
    memcpy(cnr,lnk,sizeof(lnk));
    std::queue<int> q;
    q.push(s),dep[s]=1;
    while(!q.empty()) {
        int u=q.front(); q.pop();
        for(int i=lnk[u];i;i=nxt[i]) {
            int v=ter[i];
            if(val[i]&&!dep[v]) q.push(v),dep[v]=dep[u]+1;
        }
    }
    return dep[t];
}
int dfs(int u,int t,int flow) {
    if(u==t) return flow;
    int ans=0;
    for(int i=cnr[u];i&&ans<flow;i=nxt[i]) {
        cnr[u]=i;
        int v=ter[i];
        if(val[i]&&dep[v]==dep[u]+1) {
            int x=dfs(v,t,std::min(val[i],flow-ans));
            if(x) val[i]-=x,val[i^1]+=x,ans+=x;
        }
    }
    if(ans<flow) dep[u]=-1;
    return ans;
}
int dinic(int s,int t) {
    int ans=0;
    while(bfs(s,t)) {
        int x;
        while((x=dfs(s,t,1<<30))) ans+=x;
    }
    return ans;
}
int main() {
    scanf("%d",&n);
    int ans=0;
    for(int i=1;i<=n;++i) scanf("%d",&a[i]),ans+=a[i];
    for(int i=1;i<=n;++i) scanf("%d",&b[i]),ans+=b[i];
    scanf("%d",&m);
    int S=0,T=m+n+m+1;
    for(int i=1;i<=n;++i) addedge(S,id(2,i),a[i]),addedge(id(2,i),T,b[i]);
    for(int i=1;i<=m;++i) {
        int k,c1,c2;
        for(scanf("%d%d%d",&k,&c1,&c2);k--;) {
            int x;
            scanf("%d",&x);
            addedge(id(1,i),id(2,x),1<<30);
            addedge(id(2,x),id(3,i),1<<30);
        }
        addedge(S,id(1,i),c1);
        addedge(id(3,i),T,c2);
        ans+=c1+c2;
    }
    printf("%d\n",ans-dinic(S,T));
    return 0;
}
```



---

## 作者：BlueDone (赞：10)

# [P1361](https://www.luogu.com.cn/problem/P1361)

> 小P有 $ n $ 中作物的种子，每种作物的种子有 $ 1 $ 个（就是可以种一棵作物）。
>
> 第i种作物种植在A中种植可以获得 $ a_i $ 的收益，在B中种植可以获得 $ b_i $ 的收益。

由这里可以看出，**对于每一株作物，仅能种在 A/B 的一块田地里**，也就是**二选一**。

那么我们想一想最小割的做法，通俗点来说就是：**对于每条路径，切去最小的那条边，以达到路径断裂且代价最小**，也就是**多选一**。

那么可否理解为：**对于 $ S->plant->T $ 的一条路径，选择其中的一条边，拆掉，接着另一个就是我答案中的边**。

![P1361-solution-1](https://cdn.luogu.com.cn/upload/image_hosting/r3p9bwmy.png)

那么原题的基本部分就转换成最小割了。

> 而且，现在还有这么一种神奇的现象，就是某些作物共同种在一块耕地中可以获得额外的收益，小M找到了规则中共有 $ m $ 种作物组合，第i个组合中的作物共同种在A中可以获得 $ {c_1}_i $ 的额外收益，共同总在B中可以获得 $ {c_2}_i $ 的额外收益。

对于这种情况，我们可以将这个点集打包。

建立一个新的点 $ X $ ，用 $ X $ 代表这一点集。

![P1361-solution-2](https://cdn.luogu.com.cn/upload/image_hosting/z3vufj10.png)

那么用 **$ S->X $** 来表示 **$ S->\{1,2\} $** 。

所以有：

![P1361-solution-3](https://cdn.luogu.com.cn/upload/image_hosting/8y1h7ctc.png)

同样，建立一个 **$ X' $** ，用于 $ {c_2}_i $ 的打包：

![P1361-solution-4](https://cdn.luogu.com.cn/upload/image_hosting/893ej3lq.png)

所以割边时怎么保证**只割 $ S->X $  和 $ S->X' $** 呢？

当然是让我们**无法割去不想割的边**啦！

让不想割的边变成 $ INF $ ，算法就能过滤掉它~~（它绝不会傻到以 $ INF $ 的代价割边的）~~

![P1361-solution-5](https://cdn.luogu.com.cn/upload/image_hosting/kc13m2xw.png)

所以**建图**就完成了！

接下来**跑一边 Dinic** 就完事儿啦！

可是我们是最小割（最大流）啊，这**不是答案**啊？

对，这确实不是答案。但是 Dinic 完之后我们已经“割去了”一些边，“完成了”最小割，也就是**完成了对于所有方案的不优解法的去除，剩下的自然就是最优方案。**~~（不信的话可以推一下样例）~~

那么**答案就是 总边权和 减去 最小割（最大流）**。

于是完成！

~~码风邪教勿喷~~

```cpp
/*
■■■  ■    ■  ■ ■■■■ ■■■   ■■  ■  ■ ■■■■
■  ■ ■    ■  ■ ■    ■  ■ ■  ■ ■■ ■ ■
■■■  ■    ■  ■ ■■■■ ■  ■ ■  ■ ■■ ■ ■■■■
■  ■ ■    ■  ■ ■    ■  ■ ■  ■ ■ ■■ ■
■■■  ■■■■  ■■  ■■■■ ■■■   ■■  ■ ■■ ■■■■
*/
# include <iostream>
# include <cstring>
# include <cstdio>
# include <queue>

using namespace std ; 

typedef long long lint ; 
typedef long double ntrl ; 

# define MAXN 1000010
# define MAXM 1000010
# define INF 0x3f3f3f3f

///globle varible///
int n , m ; 
int sumval ; 
/////*/

///basic function///
inline lint min ( lint x , lint y ) { return x < y ? x : y ; }
inline lint max ( lint x , lint y ) { return x > y ? x : y ; }
inline bool isltr ( char x ) { return ( 'A' <= x && x <= 'Z' ) || ( 'a' <= x && x <= 'z' ) ; }
inline bool isnum ( char x ) { return ( '0' <= x && x <= '9') ; }
/////*/

///fast read///
inline lint readlint ( )
{
	lint val = 0 , sign = 1 ; char tmp = getchar ( ) ; 
	while ( ! isnum ( tmp ) ) { if ( tmp == '-' ) { sign = - sign ; } tmp = getchar ( ) ;  } 
	while ( isnum ( tmp ) ) { val = ( val << 1 ) + ( val << 3 ) + tmp - 48 ; tmp = getchar ( ) ; } 
	return val * sign ; 
}
inline char readlter ( ) 
{
	char tmp = getchar ( ) ; 
	while ( ! isltr ( tmp ) )
		tmp = getchar ( ) ; 
	return tmp ; 
}
/////*/

///adjacency list///
struct edge
{
	int to ; 
	int last ; 
	int cap ; 
} e [ MAXM * 2 ] ; 
int list [ MAXN ] , edgecnt = 1 ; 
inline void addedge ( int u , int v , int c )
{
	e [ ++ edgecnt ] . to = v ; 
	e [ edgecnt ] . last = list [ u ] ; 
	e [ edgecnt ] . cap = c ; 
	list [ u ] = edgecnt ; 
}
/////*/

///dinic///
int s , t ; 
int depth [ MAXN ] ; 
deque < int > que ; 
int cur [ MAXN ] ; 
inline void dinic_addedge ( int u , int v , int c )
{
	addedge ( u , v , c ) ; 
	addedge ( v , u , 0 ) ; 
}
inline int dinic_bfs ( )
{
	memset ( depth , 0 , sizeof ( depth ) ) ; 
	que . clear ( ) ; 
	depth [ s ] = 1 ; 
	que . push_back ( s ) ; 
	while ( ! que . empty ( ) ) 
	{
		for ( int i = list [ que . front ( ) ] ; i ; i = e [ i ] . last )
		{
			if ( ! depth [ e [ i ] . to ] && e [ i ] . cap )
			{
				depth [ e [ i ] . to ] = depth [ que . front ( ) ] + 1 ; 
				que . push_back ( e [ i ] . to ) ; 
			}
		}
		que . pop_front ( ) ; 
	}
	return depth [ t ] ;
}
inline int dinic_dfs ( int now , int mxflow )
{
	if ( now == t )
	{
		return mxflow ;
	}
	int flow = 0 ; 
	for ( int &i = cur [ now ] ; i ; i = e [ i ] . last )
	{
		int v = e [ i ] . to ; 
		if ( depth [ v ] == depth [ now ] + 1 && e [ i ] . cap )
		{
			int f = dinic_dfs ( v , min ( e [ i ] . cap , mxflow ) ) ; 
			if ( f )
			{
				e [ i ] . cap -= f ; 
				e [ i ^ 1 ] . cap += f ; 
				mxflow -= f ; 
				flow += f ; 
				if ( ! mxflow )
				{
					return flow ; 
				}
			}
		}
	}
	return flow ; 
}
inline int dinic ( )
{
	int allflow = 0 ;
	while ( dinic_bfs ( ) )
	{
		memcpy ( cur , list , sizeof ( cur ) ) ; 
		int f ; 
		while ( ( f = dinic_dfs ( s , INF ) ) ) 
		{
			allflow += f ; 
		}
	}
	return allflow ; 
}
/////*/

int main ( )
{
	n = readlint ( ) ; 
	s = 0 ; 
	t = n + 1 ; 
	for ( int i = 1 , w ; i <= n ; i ++ )
	{
		w = readlint ( ) ; 
		dinic_addedge ( s , i , w ) ; 
		sumval += w ; 
	}
	for ( int i = 1 , w ; i <= n ; i ++ )
	{
		w = readlint ( ) ; 
		dinic_addedge ( i , t , w ) ; 
		sumval += w ; 
	}
	m = readlint ( ) ; 
	for ( int i = 1 , cnt , tmp , val1 , val2 ; i <= m ; i ++ )
	{
		cnt = readlint ( ) ; 
		val1 = readlint ( ) ; 
		val2 = readlint ( ) ; 
		sumval += val1 + val2 ; 
		dinic_addedge ( s , t + ( i * 2 - 1 ) , val1 ) ; 
		dinic_addedge ( t + ( i * 2 ) , t , val2 ) ; 
		while ( cnt -- )
		{
			tmp = readlint ( ) ; 
			dinic_addedge ( t + ( i * 2 - 1 ) , tmp , INF ) ; 
			dinic_addedge ( tmp , t + ( i * 2 ) , INF ) ;
		}
	}

	// Answer = SumEdgeWeight - MinimumCut

	return 0 ; 
}
```



---

## 作者：Foreverxxx (赞：4)

### 前言

一定不要因为在数值上最小割与最大流相等，就把最小割和最大流混为一谈。**最大流和最小割除了数值相等外基本没有任何联系。**

### 思路

第一篇题解说得和清楚，我想说说自己对这道题的一些理解。

有很多同学想不明白，为什么这道题可以用最小割做。

所以我们来想一想最小割的定义：

> 最小割是边权值和最小的割。一个图或网络的割表示一个切面或切线，将图或网络分为分别包含源点和汇点的两个子集，该切线或切面与网络相交的楞或边的集合，称为图像的割。

那么我们再来看一张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/rx0m8um5.png)

图中红色的线即表示图的**割**，这样的一个割会把图分为两个集合 $S,T$，其中**源点所在的部分是集合 $S$，汇点所在的部分是集合 $T$。** 最小割，即求的是图中所有的割中，**被切割的边的边权的和**的最小值。

那么我们再回到这道题。首先我们将源点连出的边表示为种植在 $A$ 的收入，将连入汇点的边表示为种植在 $B$ 中的收入。我们仔细回顾最小割的定义，发现此时连入一个点 $i$ 的两条边（一条从源点连入的入边，一条连向汇点的出边）只会有一条边会被算入最小割中（否则源点和汇点在同一集合），那么总收益减去最小割的值便是此时的答案。

现在我们思考，如何将一个点集加入图中。

这个点集一共有三种情况：全种在 $A$ 中，全种在 $B$ 中，或由于种在不同的地中而没有贡献。

所以我们考虑建立一个虚点表示这个集合。对于种到哪块地中，则从源点连向这个点，边权为 $C_1$，反之从这个点连向汇点，边权为 $C_2$。

那么我们又如何表示集合必须全体选择同一块土地才能生效呢？

既然我们要使这个虚点和集合产生联系，我们考虑将虚点和集合中的点进行连边，具体的说，对于土地 $A$，我们从虚点向集合中的点连一条边权为 $inf$ 的边，对于土地 $B$，我们从集合中的每个点均向虚点连一条边权 $inf$ 的边。而这个操作的正确性，是由最小割的“最小”得出的，那些 $inf$ 的边不会被算进去，真正个这个集合起作用的只有边权为 $C_1,C_2$ 的边。

如果边权为 $C_1$ 或者 $C_2$ 的边没有被割去，则说明这个点集中的所有点和虚点是在同一个集合（再次体会 $inf$ 边不会被算进去的道理）。如果被删去了就不用考虑了。

Code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sss=0;
	char chh=getchar();
	while(chh<'0'||chh>'9') chh=getchar();
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss;
}
int n,m,cnt,s=0,t=4e3;
int sum=0,k,c1,c2;
int depth[4005];
int head[4005],to[2000005],val[2000005],nxt[2000005],tot=1;
void add(int u,int v,int w){
	to[++tot]=v;
	val[tot]=w;
	nxt[tot]=head[u];
	head[u]=tot;
}
bool bfs(){
	memset(depth,0,sizeof depth); depth[s]=1;
	queue<int> q; q.push(s);
	while(!q.empty()){
		int x=q.front(); q.pop();
		for(register int i=head[x];i;i=nxt[i]){
			int u=to[i];
			if(val[i]&&!depth[u]){
				depth[u]=depth[x]+1;
				q.push(u);
			}
		}
	}
	return depth[t];
}
int dfs(int now,int flow){
	if(now==t) return flow;
	int out_flow=0;
	for(register int i=head[now];i&&flow;i=nxt[i]){
		int u=to[i];
		if(val[i]&&depth[u]==depth[now]+1){
			int tmp=dfs(u,min(val[i],flow));
			val[i]-=tmp; val[i^1]+=tmp;
			flow-=tmp; out_flow+=tmp;
		}
	}
	if(out_flow==0) depth[now]=0;
	return out_flow;
}
int Dinic(){
	int ans=0;
	while(bfs()) ans+=dfs(s,1e9);
	return ans;
}
int main(){
	memset(head,-1,sizeof head);
	cnt=n=read();
	int value,x;
	for(register int i=1;i<=n;i++){
		value=read(); sum+=value;
		add(s,i,value); add(i,s,0);
	}
	for(register int i=1;i<=n;i++){
		value=read(); sum+=value;
		add(i,t,value); add(t,i,0);
	}
	m=read();
	for(register int i=1;i<=m;i++){
		k=read(),c1=read(),c2=read();
		sum+=c1+c2;
		add(s,++cnt,c1); add(cnt,s,0);
		add(++cnt,t,c2); add(t,cnt,0);
		for(register int j=1;j<=k;j++){
			x=read();
			add(cnt-1,x,1e9); add(x,cnt-1,0);
			add(x,cnt,1e9); add(cnt,x,0);
		}
	}
	printf("%d",sum-Dinic());
	return 0;
}
```
再次提醒，**最大流和最小割无关！**

---

## 作者：lemonfor (赞：4)

 ### 提供一种 “活在梦里的HLPP” 写法QAQ
 -----------------------
 题目解法即最小割 + 虚点，不再赘述。主要是给某一部分写HLPP的人一些借鉴
 
 说明在代码中（逃
 ```
 #include<cstdio>
#include<algorithm>
#include<vector>
#include<queue>
#include<stack>
#include<cstring>
#define M 5000000
#define N 2000000 
#define INF 0x3f3f3f3f
#define re register
#define int long long//邪教宏定义
#define _ 0
#define drep(k ,l ,r) for(re int k = r ; k >= l ; -- k )
#define rep(k ,l ,r) for(re int k = l ; k <= r ; ++ k)
using namespace std;
int n ,m ,u ,v ,w ,head[N] ,tot = 1 ,s ,t;
int cap ,cnt ,c1 ,c2 ,numb ,pax1 ,pax2 ,tmp;
int high[N] ,gap[N] ,extra[N];//三个数组分别是高度，超额流量，gap优化
bool vis[N];
queue<int> que;
stack<int> sta;
struct edge {
    int next ,to ,w;
} e[M];
int read() {
    char cc = getchar() ; int cn = 0 ,flus = 1;
    while(cc < '0' || cc > '9') {if(cc == '-') flus = - flus ; cc = getchar() ; }
    while(cc >= '0' && cc <= '9') cn = cn * 10 + cc - '0' ,cc = getchar();
    return flus * cn;
}
void add_sapr(int u ,int v ,int w) {
    e[++tot].next = head[u];
    head[u] = tot;
    e[tot].to = v;
    e[tot].w = w;
}
void add(int u ,int v ,int w) {
	add_sapr(u ,v ,w) ,add_sapr(v ,u ,0);//建边
}
bool bfs() {//注意这里的bfs是反向bfs，但同样也是判断图的连通性
    rep(i ,0 ,N - 1) high[i] = INF;
    que.push(t) ,high[t] = 0;
    while(!que.empty()) {
        u = que.front() ,que.pop();
        for(int i = head[u] ; i ; i = e[i].next) 
            if(e[i ^ 1].w && high[e[i].to] > high[u] + 1) high[e[i].to] = high[u] + 1 ,que.push(e[i].to) ;
    }
    return high[s] != INF;
}
struct cmp {
    bool operator()(int a ,int b) const { return high[a] < high[b]; }
};//重载运算符
priority_queue<int ,vector<int> ,cmp> pri_que;
bool push(int u) {//尽可能多推送超额流
    for(int i = head[u] ; i ; i = e[i].next) {
        const int wi = e[i].w;
        if(!wi || high[u] != high[e[i].to] + 1) continue;
        int minn = min(wi ,extra[u]);
        extra[u] -= minn ,extra[e[i].to] += minn ,e[i].w -= minn ,e[i ^ 1].w += minn;
        if(e[i].to != s && e[i].to != t && !vis[e[i].to]) pri_que.push(e[i].to) ,vis[e[i].to] = 1;// 推送之后，v 必然溢出，则入堆，等待被推送
        if(!extra[u]) return 0;//没了就返回
    }
    return 1;
}
void relabel(int u) {//重新贴高度标签
    high[u] = INF;
    for(int i = head[u] ; i ; i = e[i].next) 
        if(e[i].w) high[u] = min(high[u] ,high[e[i].to]);
    ++high[u];
}
int hlpp() {
    if(!bfs()) return 0;
    high[s] = n;
    rep(i ,0 ,N - 1) if(high[i] != INF) ++gap[high[i]];//gap优化
    for(int i = head[s] ; i ; i = e[i].next) {
        const int wi = e[i].w;
        if(!wi) continue;
        extra[s] -= wi ,extra[e[i].to] += wi ,e[i].w -= wi ,e[i ^ 1].w += wi;
        if(e[i].to != s && e[i].to != v && !vis[e[i].to]) pri_que.push(e[i].to) ,vis[e[i].to] = 1;
    }
    while(!pri_que.empty()) {
        int u = pri_que.top();
		pri_que.pop() ,vis[u] = 0;
        while(push(u)) {
            if(!(--gap[high[u]])) //gap优化（如果 u 结点原来所在的高度没有结点了，相当于出现断层）
				rep(i ,1 ,n) 
					if(i != s && i != t && high[i] > high[u] && high[i] < n + 1) high[i] = n + 1;
            relabel(u);
            ++gap[high[u]];
        }
    }
    return extra[t];//返回超额流
}
signed main() {
    n = read();t = n + 1;
    rep(i ,1 ,n) cap = read() ,add(s ,i ,cap) ,cnt += cap;
    rep(i ,1 ,n) cap = read() ,add(i ,t ,cap) ,cnt += cap;
    m = read();pax1 = n + 2 ,pax2 = n + 3;
    rep(i ,1 ,m) {
        numb = read() ,c1 = read() ,c2 = read();
        cnt = cnt + c1 + c2;
        add(s ,pax1 ,c1) ,add(pax2 ,t ,c2);
        rep(i ,1 ,numb) tmp = read() ,add(pax1 ,tmp ,INF) ,add(tmp ,pax2 ,INF);
        pax1 += 2 ,pax2 += 2;//虚点更新
    }
    printf("%lld" ,cnt - hlpp());//答案即为总和减去最小割
    return ~~(0^_^0);
}
 ```
 但是似乎跑的比Dinic还慢。。。不推荐这种写法，大家好好写Dinic或ISAP吧。。。

---

## 作者：RicardoShips (赞：3)

最近学习网络流，感觉代码都巨长

网络流的题目无非都是一个套路

就是首先建模，然后随便~~套套模板~~

但是这题显然没有这么简单

一开始各种乱想，反正没想到最小割

然后随手点了一发题解，借鉴学习一下大神的思路

然后就~~TM~~恍然大悟，原来就是求最小割

**最小割** $=$ **最大流**

按照大神的思路，把$A$田地当做源点

$B$田地当做汇点，把$n$种植物当做中间点

没有最大收益的时候就直接连接源点、汇点和中间点

加上最大收益后，有些点就像是被捆绑在了一起

我们可以在这$m$个点集和源点、汇点之间，

再设置$2m$个中间点，把这些点和源点、汇点和中间点连接在一起

最大流量就是增加的收益

听起来真的很绕，但是真的是这样

题目要求最大收益，其实就是总收益 $-$ 最小割

剩下的部分，似乎直接~~上模板就差不多了~~

然而我~~$TM$~~直接$TLE$直接飞起

这题好像要优化一点点，至少朴素的$Dinic$模板不行

又是一位大神告诉我一个玄学优化

真$TM$一手骚操作，瞬间就切掉

这个不是我的东西我就先不讲了哈

~~自我感觉码风美好~~

```cpp
#include<bits/stdc++.h>
#define INF 99999999
using namespace std;
struct XM
{
    int to;
    int dis;
    int from;
}
edge[4000004];
int cur[40004];
int deep[40004];
int head[40004];
int m,n,s,k,t,x,y,z,ans,num=-1;
inline void add(int from,int to,int dis)
{
    edge[++num].from=head[from];
    edge[num].to=to;
    edge[num].dis=dis;
    head[from]=num;
}
inline bool Bfs()
{
    memset(deep,0,sizeof(deep));
    queue < int > Q;
    while(!Q.empty()) Q.pop();
    Q.push(s);deep[s]=1;
    while(!Q.empty())
    {
        int u=Q.front();
        Q.pop();
        for(register int i=head[u];i!=-1;i=edge[i].from)
        {
            int v=edge[i].to;
            if(deep[v]==0&&edge[i].dis>0)
            {
                deep[v]=deep[u]+1;
                Q.push(v);
            }

        }
    }
    if(deep[t]!=0) return true;
    else return false;
}
inline int Dfs(int u,int f)
{
    if(u==t) return f;
    int sum=0;
    for(register int &i=cur[u];i!=-1;i=edge[i].from)
    {
        int v=edge[i].to;
        if(deep[v]==deep[u]+1&&edge[i].dis>0)
        {
            int d=Dfs(v,min(f,edge[i].dis));
            if(d>0)
            {	
            	sum+=d;f-=d;
                edge[i].dis-=d;
                edge[i^1].dis+=d;
                if(!f) break;
            }
        }
    }
    return sum;
}
int main()
{
    scanf("%d",&n);
    s=n+1;t=s+1;
    memset(head,-1,sizeof(head));
    for(register int i=1;i<=n;++i)
    {
        scanf("%d",&x);
        ans+=x;
        add(s,i,x);
        add(i,s,0);
    }
    for(register int i=1;i<=n;++i)
    {
        scanf("%d",&x);
        ans+=x;
        add(i,t,x);
        add(t,i,0);
    }
    scanf("%d",&m);
    for(register int i=1;i<=m;++i)
    {
        scanf("%d%d%d",&k,&x,&y);
        ans+=x;ans+=y;
        add(s,n+i+2,x);
        add(n+i+2,s,0);
        add(n+m+i+2,t,y);
        add(t,n+m+i+2,0);
        for(register int j=1;j<=k;++j)
        {
            scanf("%d",&z);
            add(n+i+2,z,INF);
            add(z,n+i+2,0);
            add(z,n+m+i+2,INF);
            add(n+m+i+2,z,0);
        }
    }
    while(Bfs())
    {
    	memcpy(cur,head,sizeof(cur));
    	ans-=Dfs(s,INF);
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：ker_xyxyxyx_xxs (赞：2)

[P1361 小M的作物](https://www.luogu.com.cn/problem/P1361)

题意：算最大价值。

这个题告诉我们，可以单独种，但是有些组合种在一起有额外收益。

从标签看，这道题是最小割。

由于每种种子只有一个，所以要么种在 $ A $，要么种在 $ B $，这就很熟悉了，不就是最小割的本质吗？归属集合问题。所以理所当然，源点向每个种子连一条边，边权为当前这个种子种在 $ A $ 田地里的收益，即 $ a_i $。每个种子向汇点连一条边，边权为当前这个种子种在 $ B $ 田地里的收益，即 $ b_i $。

现在考虑好了单个的，但是还有一些组合怎么办？这也是最小割建图的经典模型。

由于这些组合必须种在一起，所有如果要加入这些收益代表他们不可分开。考虑对于每一个组合建立虚拟点，每个组合建立两个，如下图，我再来讲解。
![](https://cdn.luogu.com.cn/upload/image_hosting/crvi11oo.png)

红色点是我们建立的虚拟点，每个组合建立两个。每个左边的虚拟点向组合的点连边，边权为 $ \infty $，并且源点向左边的虚拟点连一条边，边权为这个组合的收益，即 $ c_1,i $。**思考原理？**因为这些组合不可分开，所以如果的到收益，就连为 $ \infty $ 表示不可分割，其实也是套路。

每个组合中的点向右边的虚拟点连边，边权为 $ \infty $，每个右边的虚拟点向汇点连当前这个组合的收益，即 $ c_2,i $。

举个例子，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/3vcmpguc.png)

接下来利用最小割最大流定理求出最小割即可。

Code
```cpp
# include <iostream>
# include <cstdio>
# include <queue>
# include <cstring>

using namespace std;

const int N = 2e6 + 5;
const int M = 1e7 + 5;
const int inf = 0x3f3f3f3f;
int S , T;

typedef struct {
	int x , y , z , next;
} Edge;
Edge edge[M];

int E = 1 , elast[N];
int n , m;

void add(int x , int y , int z) {
	E ++;
	edge[E].x = x;
	edge[E].y = y;
	edge[E].z = z;
	edge[E].next = elast[x];
	elast[x] = E;
}
int x;
int dis[N] , cnt[N];
void bfs(int start) {
	queue<int> q;
	q.push(start);
	dis[start] = 0;
	cnt[S] = 1;
	while (!q.empty()) {
		int cur = q.front();
		q.pop();
		for (int i = elast[cur] ; i ; i = edge[i].next) {
			int v = edge[i].y;
			if (dis[v] != -1) continue;
			dis[v] = dis[cur] + 1;
			q.push(v);
			cnt[dis[v]] ++;
		}
	}
}
int cur[N];
int dfs(int u , int flow) {
	if (u == T) return flow;
	int temp , delta = 0;
	for (int i = cur[u] ; i ; i = edge[i].next) {
		cur[u] = i;
		int v = edge[i].y;
		if (edge[i].z > 0 && dis[u] == dis[v] + 1) {
			temp = dfs(v , min(flow - delta , edge[i].z));
			edge[i].z -= temp;
			edge[i ^ 1].z += temp;
			delta += temp;
			if (delta == flow) return delta;
		}
	}
	if (dis[S] >= T) return delta;
	cur[u] = elast[u];
	if (-- cnt[dis[u]] == 0) dis[S] = T;
	cnt[++ dis[u]] ++;
	return delta;
}
int a[N] , b[N];
int Isap() {
	int ans = 0;
	memset(cnt , 0 , sizeof cnt);
	memset(dis , -1 , sizeof dis);
	bfs(T);
	for (int i = 0 ; i <= T ; i ++) {
		cur[i] = elast[i];
	}
	while (dis[S] < T) ans += dfs(S , inf);
	return ans;
}
int sum = 0;
int k , K , cnt1 , cnt2;
int main() {
	cin >> n;
	for (int i = 1 ; i <= n ; i ++) {
		scanf("%d" , &a[i]);
		sum += a[i];
	}
	for (int i = 1 ; i <= n ; i ++) {
		scanf("%d" , &b[i]);
		sum += b[i];
	}
	cin >> m;
	S = 0 , T = n + (m << 1) + 1;
	for (int i = 1 ; i <= n ; i ++) {
		add(S , i , a[i]);
		add(i , S , 0);
		add(i , T , b[i]);
		add(T , i , 0);
	}
	for (int i = 1 ; i <= m ; i ++) {
		scanf("%d%d%d" , &k , &cnt1 , &cnt2);
		sum += cnt1 + cnt2;
		add(S , n + i , cnt1);
		add(n + i , S , 0);
		add(n + m + i , T , cnt2);
		add(T , n + m + i , 0);
		for (int j = 1 ; j <= k ; j ++) {
			scanf("%d" , &K);
			add(n + i , K , inf);
			add(K , n + i , 0);
			add(K , n + m + i , inf);
			add(n + m + i , K , 0);
		}
	}

	printf("%d\n" , sum - Isap());
	return 0;
} 
```

---

## 作者：elijahqi (赞：2)

 http://www.elijahqi.win/2018/01/20/bzoj3438/

 http://blog.csdn.net/elijahqi/article/details/79111850

Description

小M在MC里开辟了两块巨大的耕地A和B（你可以认为容量是无穷），现在，小P有n中作物的种子，每种作物的种子

有1个（就是可以种一棵作物）（用1...n编号），现在，第i种作物种植在A中种植可以获得ai的收益，在B中种植

可以获得bi的收益，而且，现在还有这么一种神奇的现象，就是某些作物共同种在一块耕地中可以获得额外的收益

，小M找到了规则中共有m种作物组合，第i个组合中的作物共同种在A中可以获得c1i的额外收益，共同总在B中可以

获得c2i的额外收益，所以，小M很快的算出了种植的最大收益，但是他想要考考你，你能回答他这个问题么？

Input
第一行包括一个整数n

第二行包括n个整数，表示ai第三行包括n个整数，表示bi第四行包括一个整数m接下来m行，

对于接下来的第i行：第一个整数ki，表示第i个作物组合中共有ki种作物，

接下来两个整数c1i，c2i，接下来ki个整数，表示该组合中的作物编号。输出格式

Output

只有一行，包括一个整数，表示最大收益

Sample Input

3
4 2 1
2 3 2
1
2 3 2 1 2

Sample Output

11
样例解释A耕地种1，2，B耕地种3，收益4+2+3+2=11。

1<=k< n<= 1000,0 < m < = 1000 保证所有数据及结果不超过2\*10^9。

最小割 建立两个新点  源向每个点连不选他获得的代价 每个点向汇连不选他付出的代价 然后针对每个子集建立两个点 一个是都选A 一个是都选B那么A向相应的点连INF  B向相应的点连INF最小割即可

S向每个点建边，容量为种在A的收益，每个点向T建边，容量为种在B的收益，对于每一个点，我们必然要割掉连向S或T的一条且仅一条边。对于割之后的图，S集的点均选择了种在A，T集的点均选择了种在B。那对于共同种在A地有额外收益的点怎么办呢？，我们新建一个点x，S向x连边，容量为收益，x向所有需要共同种在A的点连边，容量为inf，则如果这些点有一个点没有割掉向T的连边，我们势必要割掉收益这条边。如果收益这条边没被割掉，则说明他所需要的点最后都割了向T的连边，也就是都在S集中，也就是都种在了A，符合题意。对于共同种在B的有额外收益的也同理，新建一个点x，x向T连边，容量为收益，所有需要共同种在B的点向x连边，容量为inf。则最后答案就是总收益-最小割。

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define inf 0x3f3f3f3f
#define N 3300
using namespace std;
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
} 
inline int read(){
    int x=0;char ch=gc();
    while(ch<'0'||ch>'9') ch=gc();
    while(ch<='9'&&ch>='0') x=x*10+ch-'0',ch=gc();
    return x;
}
int n,h[N],T,level[N],b[N],num=1,cur[N];
struct node{
    int y,z,next;
}data[4400000];
inline void insert1(int x,int y,int z){
    data[++num].y=y;data[num].z=z;data[num].next=h[x];h[x]=num;
    data[++num].y=x;data[num].z=0;data[num].next=h[y];h[y]=num;
}
inline bool bfs(){
    queue<int>q;memset(level,0,sizeof(level));level[0]=1;q.push(0);
    while(!q.empty()){
        int x=q.front();q.pop();
        for (int i=h[x];i;i=data[i].next){
            int y=data[i].y,z=data[i].z;
            if (level[y]||!z) continue;level[y]=level[x]+1;if (y==T) return 1;q.push(y);
        }
    }return 0;
}
inline int dfs(int x,int s){
    if (x==T) return s;int ss=s;
    for (int &i=cur[x];i;i=data[i].next){
        int y=data[i].y,z=data[i].z;
        if (level[x]+1==level[y]&&z){
            int xx=dfs(y,min(z,s));if (!xx) level[y]=0;
            s-=xx;data[i].z-=xx;data[i^1].z+=xx;if (!s) return ss;
        }
    }return ss-s;
}
int main(){
//    freopen("bzoj3438.in","r",stdin);
    n=read();int sum=0;int x=0;
    for (int i=1;i<=n;++i) insert1(0,i,x=read()),sum+=x;
    for (int i=1;i<=n;++i) b[i]=read(),sum+=b[i];int m=read();T=n;T+=m<<1;++T;
    for (int i=1;i<=n;++i) insert1(i,T,b[i]);
    for (int i=1;i<=m;++i){
        int k=read();insert1(0,n+i,x=read());sum+=x;insert1(n+m+i,T,x=read());sum+=x;
        for (int j=1;j<=k;++j){
            insert1(i+n,x=read(),inf);insert1(x,i+n+m,inf);
        }
    }int ans=0;while(bfs()) memcpy(cur,h,sizeof(h)),ans+=dfs(0,inf);
    printf("%d",sum-ans);
    return 0;
}

```

---

## 作者：云浅知处 (赞：1)

建图：新建源点、汇点 $s,t$。我们从 $s$ 向每个点 $i$ 连边，边权为 $a_i$。每个点 $i$ 向 $t$ 连边，边权为 $b_i$。

这样一来，要使 $s,t$ 不连通，就必须割掉其中的一条边。这正好符合了「每个物品只能放在一个集合内」的约束。

此时还需要处理「同时选取某一组就会获得收益」的信息。

我们对于每一组新建一个点 $s$，从 $s$ 到 $x$ 连边，边权为同时选这一组获得的收益。

转化一下就是，只要割掉了 $s$ 到这一组内点的任意一条边，那么 $s\to x$ 的边也必须断掉。

如何达到这个要求？只需要从 $x$ 向组里的每个点都连一条边权为 $\infty$ 的边即可。

这样一来，如果断掉了 $s$ 到该组内一个点 $u$ 的边，而 $s\to x$ 的边没有被断掉，那么依然可以通过 $s\to x\to u$ 到达 $u$。也就是说，$s\to u$ 的边白断了......而最小割肯定不会干出这种事。

因此，如果断掉了 $s\to u$ 的边，$s\to x\to u$ 这条路径上肯定要断一条。

$x\to u$ 边权为 $\infty$，肯定不会断；因此，必然会断掉 $s\to x$ 的边，也就是说得不到这个收益了。

于是就做完了。

注意边数最多可以达到 $10^3\times 10^3\times 2\times 2+2\times 1000$ ，保险起见最好开到 $5\times 10^6$。

```cpp
#include<bits/stdc++.h>

using namespace std;

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

const int MN=5e3+5;
const int MM=5e6+5;
int n,s=0,t;
int head[MN],nxt[MM],ver[MM],edge[MM],tot=1;

void adde(int x,int y,int z){
	edge[++tot]=z,ver[tot]=y,nxt[tot]=head[x],head[x]=tot;
	edge[++tot]=0,ver[tot]=x,nxt[tot]=head[y],head[y]=tot;
}

int d[MN],now[MN];
queue<int>q;

bool bfs(){
	memset(d,0,sizeof(d));
	while(q.size())q.pop();
	q.push(s),d[s]=1,now[s]=head[s];
	while(q.size()){
		int x=q.front();q.pop();
		for(int i=head[x];i;i=nxt[i]){
			if((!edge[i])||d[ver[i]])continue;
			d[ver[i]]=d[x]+1,q.push(ver[i]),now[ver[i]]=head[ver[i]];
			if(ver[i]==t)return 1;
		}
	}
	return 0;
}

int dinic(int x,int flow){
	if(x==t)return flow;
	int rest=flow;
	for(int i=now[x];i&&rest;i=nxt[i]){
		now[x]=i;int y=ver[i];
		if((!edge[i])||d[y]!=d[x]+1)continue;
		int k=dinic(y,min(rest,edge[i]));
		rest-=k,edge[i]-=k,edge[i^1]+=k;
	}
	return flow-rest;
}

const int INF=1e9;

#define OK puts("OK")

signed main(void){

#ifndef ONLINE_JUDGE
	freopen("in.in","r",stdin);
#endif		

	n=read();int ans=0;t=n+2000+1;
	for(int i=1;i<=n;i++){
		int x=read();ans+=x;
		adde(s,i,x);
	}
	for(int i=1;i<=n;i++){
		int x=read();ans+=x;
		adde(i,t,x);
	}
	int m=read();
	for(int i=1;i<=m;i++){
		int k=read(),cx=read(),cy=read();
		adde(s,n+i,cx),adde(n+m+i,t,cy),ans+=cx+cy;
		for(int j=1;j<=k;j++){
			int x=read();
			adde(n+i,x,INF),adde(x,n+m+i,INF);
		}
	}

	int flow=0;
	while(bfs()){
		while(flow=dinic(s,INF))ans-=flow;
	}

	cout<<ans<<endl;

	return 0;
}
```

---

## 作者：chenxia25 (赞：1)

这是一个挺有意思的最小割题。

我们考虑一个经典的最小割集合划分模型（在 xht 博客里也有）：每个点有两个点可以选择去属于，那就源点代表第一个集合，汇点代表第二个，规定一个合法的选择方案满足源点和汇点不连通且每个点恰与一个集合相连，并且属于该集合。那么在没有附加条件下，删掉 $b_i$ 就是选了第一个集合，删了 $a_i$ 就是选了第二个集合，这样每个点和源汇连一波然后最小割即可求出最小收益。

但这题要求最大收益，~~众所周知~~最大割是不可做的。我们考虑这样一种策略，先算出所有方案的总代价，然后将每种选择所不满足的方案的代价给减掉，这样就能 max -> min。

回到这题。单个的贡献就反过来随便连即可。多个的贡献，考虑转化成 min，有选 $a$ 的 $c2$ 就废了，有选 $b$ 的 $c1$ 就废了。于是我们需要在图中设置这样一个机关，使得如果在特定点集中有点与源连通，那么必须要割掉这个机关才能使得与汇不连通。这个非常自然了吧，就设个虚拟节点连向点们（边权 $+\infty$），然后虚拟节点连向源 / 汇，边权为对应 $c$ 值。

然后求个最小割作为减数即可。大概 $|V|\ 10^3\ |E|\ 10^6$，dinic 不慌。

---

## 作者：_maze (赞：1)

这道题是一道很好的网络流入门题，所以对于思维部分，我会讲的尽量详细


------------


我们思考这样一个问题：假如没有收益机制，我们将所有的点连到一个虚点S，再连到虚点T（方向为S->点->T）。这时我们跑最小割，那我们求出来的是什么？

我们最小割，要求的是图S与T不连通。那么我们对于每一条S->点->T的路径，都要切掉一条最小边。在这个过程中，就是a,b两个变量二选一了。

![](https://cdn.luogu.com.cn/upload/image_hosting/dlgsnr4k.png)

最小割是什么？她求的是最小值。那么我们将图的所有边权加起来，减去最小割，就是二选一的最大值了。

考虑加上收益条件。

显而易见，我们是不能用原来的点连边的。所以我们新开一个虚点

“怎么建边呢？”

最小割的目的是将S与T变得不连通。所以我们最终要得到的目标是：要么虚点与1，2两点在S，要么在T

>虚点与1,2两点的连线不可断开，因为如果一边断开那么我们可以通过切掉另一边达到不连通的效果

我们经过思考可以得出连边：将S->虚点（长度为c1），虚点->1（极大值），虚点->2（极大值）连边，可以达到上述效果。

可以自己思考一下如何连两点都种在B点时的奖励机制。


------------
有了建边，其他地方都是网络流板子。但这里要用当前弧优化，并且还要加两个小优化。已经在代码中标出。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,s,t;
int to[4000005],nx[4000005],st[4000005],zhi[4000005],tot=1;
int num;
void add(int u,int v,int w){
    to[++tot]=v;
    zhi[tot]=w;
    nx[tot]=st[u];
    st[u]=tot;
}
int c[4000005],ceng[4000005];
bool bfs(int s){
    for(int i=0;i<=num;i++)ceng[i]=-1;
    ceng[s]=0;
    for(int i=0;i<=num;i++) c[i]=st[i];
    queue<int> q;
    q.push(s);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int i=c[u];i;i=nx[i]){
            int v=to[i];
            if(zhi[i]>0&&ceng[v]==-1){
                ceng[v]=ceng[u]+1;
                if(v==t) return 1;//如果可以搜到终点，提前退出 
                q.push(v);
            }
        }
    }
    if(ceng[t]==-1) return 0;
    return 1;
}
int dfs(int u,int ans){
    if(u==t||ans==0){//优化之二，如果ans小于0就没必要接着搜了。反正也增加不了答案 
        return ans;
    }
    int d=ans;
    for(int i=c[u];i;i=nx[i]){
        int v=to[i],w=zhi[i];
        c[u]=i;
        if(w>0&&ceng[v]==ceng[u]+1){
            int p=dfs(v,min(w,d));
            d-=p;
            if(d<0) break;
            zhi[i]-=p;
            zhi[i^1]+=p;
        }
    }
    return ans-d;
}
int maxx;
void jian(int u,int v,int w){
    add(u,v,w);
    add(v,u,0);
} 
inline int read()
{
    register int x=0,f=1;register char c=getchar();
    while(c<'0'||c>'9') {if(c=='-') f=-1;c=getchar();}
    while (c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*f;
}
signed main(){
    n=read();
    num=n+1;
    s=0;
    t=n+1;
    int u,v,w;
    for(int i=1;i<=n;i++){
        int a;
        a=read();
        maxx+=a;
        jian(s,i,a);
    }   
    for(int i=1;i<=n;i++){
        int b;
        b=read();
        maxx+=b;
        jian(i,t,b);
    }

    m=read();
    for(int i=1;i<=m;i++){
        int k,c1,c2,p;
        int n1=++num,n2=++num; 
        k=read();
        c1=read();
        c2=read();
        maxx+=c1;
        maxx+=c2;
        for(int j=1;j<=k;j++){
            p=read();
            jian(n1,p,2147483647);
            jian(p,n2,2147483647);
        }
        jian(s,n1,c1);
        jian(n2,t,c2);
    }
    int c,ans=0;
    while(bfs(s)){
        c=dfs(s,2147483647);
        if(c==-1) break;
        ans+=c; 
    }
    printf("%lld",maxx-ans);
    return 0;
}
```

我们可以看到，这道题我们先思考我们要干什么，再想我们应该怎么干。

建模的题，例如二分图或网络流，一般都是这个套路

看起来简单，但要是想轻车熟路地达到这个效果，需要长时间的练习。


---

## 作者：bztMinamoto (赞：1)

打广告->[这里](https://www.cnblogs.com/bztMinamoto/p/9574610.html)

为什么大爷们一眼就能看出这题是最小割，我却要仔细思考（并看了眼题解）才能发现……

首先把$S$当做$A$，$T$当做$B$，然后$S$向对应的点连边容量为种在$A$的获利，连$T$同理。这样只要用全部收益减去最小割就是答案

然后考虑一下组合。我们对于每一个组合拆点，从$S$向入点连边容量为收益，然后入点向对应的所有点连边，容量$inf$，所有点向出点连边，容量$inf$，出点向$T$连边，容量为种在$B$的收益。然后还是用总收益减去最小割

为什么？我抄的你问我为什么……

先假设有这么个图，$A,B$是一个组合，$X,Y$是组合拆出来的点，标红的边因为容量为$inf$不可能被割

![](https://i.loli.net/2018/09/02/5b8bb4f6e6e35.png)

那么我们割的方法有三种

1.两个都在$B$，割$S->X,S->A,S->B$，就代表所有的都与$S$断开，也就是所有都与$T$相连，即种在$B$里，那么总收益减去最小割就是都在$B$的答案

2.两个都在$A$，割$Y->T,A->T,B->T$，与上面同理

3.一个$A$一个$B$，我们设$A$种在$S$，$B$种在$T$，那么割掉$S->X,S->B,A->T,Y->T$，那么就是$A$与$S$连，$B$与$T$连，然后总收益减去最小割就是答案

不难发现，每一个割都代表了一种选择，然后基本就是跑一个最小割了

ps：这题注意，空间要开的很大
```
//minamoto
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define inf 0x3f3f3f3f
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
const int N=10005,M=4000005;
int head[N],Next[M],ver[M],edge[M],tot=1;
int cur[N],dep[N],n,m,S,T,num;
queue<int> q;
inline void add(int u,int v,int e){
	ver[++tot]=v,Next[tot]=head[u],head[u]=tot,edge[tot]=e;
	ver[++tot]=u,Next[tot]=head[v],head[v]=tot,edge[tot]=0;
}
bool bfs(){
    while(!q.empty()) q.pop();
    for(int i=0;i<=num;++i) cur[i]=head[i];
    memset(dep,-1,sizeof(dep));
    q.push(S),dep[S]=0;
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=head[u];i;i=Next[i]){
            int v=ver[i];
            if(dep[v]<0&&edge[i]){
                dep[v]=dep[u]+1,q.push(v);
                if(v==T) return true;
            }
        }
    }
    return false;
}
int dfs(int u,int limit){
    if(u==T||!limit) return limit;
    int flow=0,f;
    for(int i=cur[u];i;i=cur[u]=Next[i]){
        int v=ver[i];
        if(dep[v]==dep[u]+1&&(f=dfs(v,min(limit,edge[i])))){
            flow+=f,limit-=f;
            edge[i]-=f,edge[i^1]+=f;
            if(!limit) break;
        }
    }
    if(!flow) dep[u]=-1;
    return flow;
}
int dinic(){
    int flow=0;
    while(bfs()) flow+=dfs(S,inf);
    return flow;
}
int sum;
int main(){
	//freopen("testdata.in","r",stdin);
	n=read(),S=0,T=n+1;
	for(int i=1,x;i<=n;++i) x=read(),sum+=x,add(S,i,x);
	for(int i=1,x;i<=n;++i) x=read(),sum+=x,add(i,T,x);
	m=read(),num=n+2*m+1;
	for(int i=1;i<=m;++i){
		int k=read(),x=read(),y=read();
		sum+=x+y;
		add(S,n+1+i,x),add(n+m+1+i,T,y);
		while(k--){
			int t=read();
			add(n+i+1,t,inf),add(t,n+m+i+1,inf);
		}
	}
	printf("%d\n",sum-dinic());
	return 0;
}
```

---

## 作者：UperFicial (赞：1)

[传送门](https://www.luogu.com.cn/problem/P1361)

同步发表于我的 [$\text{cnblog}$](https://www.cnblogs.com/UperFicial/p/16033311.html)。

### $\texttt{Description}$

$n$ 种作物，第 $i$ 种作物在 $A$ 区种植可获得 $a_i$ 的效益，在 $B$ 区种植可获得 $b_i$ 的效益。$m$ 种搭配。指定的作物全部种植于 $A$ 区，可获得 $c_{1,i}$ 的效益，全部种植于 $B$ 区，可获得 $c_{2,i}$ 的效益。求最大获益。

### $\texttt{Solution}$

重点讲一下建图原理。

首先发现这是一个二选一的模型，考虑最小割。

假设我们所有方案都取，并且每一种作物在两个耕地都种植了，那么可以获得 $\sum (a_i+b_i)+\sum (c_{1,j}+c_{2,j})$ 的效益，但这样是不合法的，所以使用最小割来割去矛盾的边。最大化价值就是最小化割去的边。

先不考虑搭配。光考虑单在 $A$ 区种植或在 $B$ 区种植。


我们建立源点 $s$，和汇点 $t$，令 $s$ 向每一个 $i$ 连一条容量 $a_i$ 的边，同理，$i$ 向 $t$ 连一条容量 $b_i$ 的边。

那么我们求的最小割肯定会在每一个 $i$ 中选择一个 $a_i$ 或 $b_i$。

现在考虑搭配的方案。

我们把每一个搭配标志成一个点，其中第 $i$ 个搭配标记的点为 $i+n$。

我们发现一个搭配要么在 $A$ 种植要么在 $B$ 种植，所以我们可以将一个搭配裂成两个点 $i+n$ 和 $i+n+m$，分别表示种植在 $A$ 和种植在 $B$。

若种植在 $A$，则其可以获得 $c_{1,i}$ 的效益，我们令 $s$ 连向 $i+n$，流量为 $c_{1,i}$，同理，令 $i+n+m$ 连向 $t$，容量为 $c_{2,i}$。

这样的话最小割肯定会割去 $c_{1,i}$ 或 $c_{2,i}$ 中的一个。

我们将 $i+n$ 连向每一个搭配的作物，每一个搭配的作物再连向 $i+n+m$。

注意到选择一个方案必须选择这里面搭配的所有作物，所以每一个作物都是不可分割的。那么我们将流量设为 $\infty$，最小割不会割去容量为 $\infty$ 的边。

做完了，根据最大流 $=$ 最小割，跑一遍最大流后，用总价值减去最大流即可。

贴一下代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<ctime>
#include<cstdlib>
#include<climits>
#include<queue>
#include<vector>
using namespace std;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0' or ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' and ch<='9')s=s*10+(ch-'0'),ch=getchar();
	return s*w;
}
const int INF=1e9+10;
inline int Max(int x,int y){return x>y?x:y;}
inline int Min(int x,int y){return x<y?x:y;}
inline void Swap(int&x,int&y){x^=y;y^=x;x^=y;}
inline int Abs(int x){return x>0?x:-x;}
const int MAXN(3e3+10);
int n,m,a[MAXN],b[MAXN];
struct E{int to,nxt,flow;};
E edge[MAXN*MAXN];
int head[MAXN],tot(1);
inline void add(int u,int v,int f)
{
	edge[++tot].nxt=head[u];
	head[u]=tot;
	edge[tot].to=v;
	edge[tot].flow=f;
	return;
}
inline void add_edge(int u,int v,int f)
{
	add(u,v,f);
	add(v,u,0);
	return;
}
int dep[MAXN];
queue<int>q;
int s,t;
int ans;
inline bool bfs()
{
	memset(dep,0,sizeof(dep));
	q.push(s);
	dep[s]=1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(register int i=head[u];i;i=edge[i].nxt)
		{
			E e=edge[i];
			if(e.flow&&!dep[e.to])
			{
				dep[e.to]=dep[u]+1;
				q.push(e.to);
			}
		}
	}
	return dep[t];
}
inline int dfs(int u,int in)
{
	if(u==t) return in;
//	printf("%d\n",u);
	int out(0);
	for(register int i=head[u];i&&in;i=edge[i].nxt)
	{
		E e=edge[i];
		if(e.flow&&dep[e.to]==dep[u]+1)
		{
			int now=dfs(e.to,Min(e.flow,in));
			edge[i].flow-=now;
			edge[i^1].flow+=now;
			in-=now;
			out+=now;
		}
	}
	if(out==0) dep[u]=0;
	return out;
}
int main()
{
	n=read();
	
	for(register int i=1;i<=n;i++) a[i]=read();
	for(register int i=1;i<=n;i++) b[i]=read();
	m=read();
	s=0,t=n+m+m+1;
	for(register int i=1;i<=n;i++)
	{
		add_edge(s,i,a[i]);
		add_edge(i,t,b[i]);
		ans+=a[i]+b[i];
	}
	for(register int i=1;i<=m;i++)
	{
		int k=read();
		int c1=read(),c2=read();
		ans+=c1+c2;
		add_edge(s,n+i,c1);
		add_edge(n+i+m,t,c2);
		while(k--)
		{
			int p=read();
			add_edge(n+i,p,INF);
			add_edge(p,n+i+m,INF);
		}
	}
	while(bfs()) ans-=dfs(s,INF);
	printf("%d\n",ans);
	return 0;
}
```
$$\texttt{The End.by UF}$$

---

## 作者：封禁用户 (赞：0)

### 作为一个 _MC_ 党，这道题无疑是一道好题。

------------

_Step1_ : 

网络中，最大流=最小割。

每一个农作物只能出现在一个田地里，要么在 $A$ ， 要么在 $B$ 。

定义两个超级节点 $s$ , $t$ 。

农作物 $i$ 在 $A$ 种植获取利益 $a_i$ ，那么 $s$ 就与这种作物 $i$ 连一条容量为 $a_i$ 的边；在 $B$ 种植获利 $b_1$ ，就将作物 $i$ 与 $t$ 连一条容量为b的边；

先将题目简化，也就是没有说有一些作物在同一块田地中有额外利益：

每割掉一条边，就等于选择另一条边。而最大流就是最小割，那么记录所有路径价值总和 $sum$ ，跑个最大流得到了最小割，用 $sum$ 减去最小割就是所有路径的最大价值。

-----------

_Step2_ : （虚点建立）

考虑多个农作物出现在某个耕地所产生了额外的价值。

在这种情况下，我们可以建立辅助点（也叫虚点）$X$ 。

让 $s$ 与 $X$ 连一条容量为 $c_{1, i}$ 的边，代表有这么一种情况，会获利 $c_{1, i}$ 元；让 $X$ 与 $t$ 连一条容量为 $c_{2, i}$ 的边，代表有这么一种情况，会获利 $c_{2, i}$ 元。

再将X与这些能够额外获利的作物连一条容量为 $INF$ 的边

容量为 $INF$ ，意味这它永远不会被割掉。

这样这个问题就迎刃而解了。虽然作为一道较为基础的建立虚点的题，不过还是有许多细节需要注意。

参考代码如下：

```
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n, m, tot = 1, s, t;
struct edge {
	int to, nxt, val;
} e[2000005];
int head[1000005];
void net_add(int u, int v, int w) {
	e[++tot] = edge{v, head[u], w};
	head[u] = tot;
	e[++tot] = edge{u, head[v], 0};
	head[v] = tot;
}
int dep[1000005];
bool bfs() {
	queue<int> q;
	q.push(s);
	memset(dep, -1, sizeof dep);
	dep[s] = 0;
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		for (int i = head[u]; i != -1; i = e[i].nxt) {
			int v = e[i].to;
			if (dep[v] == -1 && e[i].val) {
				q.push(v);
				dep[v] = dep[u] + 1;
			}
		}
	}
	return dep[t] != -1;
}
int dfs(int u, int left) {
	if (u == t) {
		return left;
	}
	int data = left;
	for (int i = head[u]; i != -1; i = e[i].nxt) {
		int v = e[i].to;
		if (dep[v] == dep[u] + 1 && e[i].val) {
			int d = dfs(v, min(e[i].val, data));
			e[i].val -= d;
			e[i ^ 1].val += d;
			data -= d;
			if (!data) {
				break;
			}
		}
	}
	if (data == left) {
		dep[u] = -1;
	}
	return left - data;
}

signed main() {
	scanf("%lld", &n);
	s = 0, t = n + 1;
	int sum = 0;
	memset(head, -1, sizeof head);
	for (int i = 1, ai; i <= n; i++) {
		scanf("%lld", &ai);
		net_add(s, i, ai);
		sum += ai;
	}
	for (int i = 1, bi; i <= n; i++) {
		scanf("%lld", &bi);
		net_add(i, t, bi);
		sum += bi;
	}
	scanf("%lld", &m);
	for (int i = 1, k, ci1, ci2; i <= m; i++) {
		scanf("%lld %lld %lld", &k, &ci1, &ci2);
		net_add(s, i + n + 1, ci1);
		net_add(i + n + m + 1, t, ci2);
		sum += ci1 + ci2;
		for (int j = 1, x; j <= k; j++) {
			scanf("%lld", &x);
			net_add(i + n + 1, x, 0x3f3f3f3f);
            net_add(x, i + n + m + 1, 0x3f3f3f3f);
		}
	}
	int ans = 0;
	while (bfs()) {
		ans += dfs(s, 0x3f3f3f3f);
	}
	printf("%lld", sum - ans);
	return 0;
}
```
因为没有信仰，所以开了 _long long_ ......

本人蒟蒻



---

## 作者：Rubyonly (赞：0)

# 思路

跟P1646很相似，如果你做过P1646，这个题就迎刃而解了。

还是挺套路的，如果会了这个思路，不少同类型的网络流差不多就都会了。

显然，对于每个种子，只会有两种状态，要么放到 A 农田里，要么放到 B 农田里。

## 单个种子

对于单个的种子，我们可以将 $S$ 向当前点 $x$ 建一条流量为 $a_i$ 的边，从 $x$ 向 $T$ 建一条边权为 $b_i$ 的边。

如下图：

![](https://images.cnblogs.com/cnblogs_com/Rubyonly233/1814954/o_201211085235asd.png)

跟据最小割的定义，$a,b$ 两条边会断掉任意一个，正好符合我们的两种决策：放到 A 农田里、放到 B 农田里。

## 多个种子

假设两个种子 $x,y$ 放到农田里会有额外的收益，我们新建两个点 $S',T'$，$S'$ 向 $x,y$ 连 $INF$ 边，$x,y$ 向 $T'$ 连 $INF$ 边。

如下图：

![](https://images.cnblogs.com/cnblogs_com/Rubyonly233/1814954/o_201211091105bcd.png)

求最小割有 4 种决策：

* 断 $b_1,c_2,b_2$ 三条边：留下了 $a_1,c_1,a_2$ 的贡献，相当于 $x$ 放到 A 中，$y$ 放到 A 中。

* 断 $b_1,c_1,a_2,c_2$ 四条边：留下了 $a_1,b_2$ 的贡献，相当于 $x$ 放到 A 中，$y$放到 B 中。

* 断 $a_1,c_1,b_2,c_2$ 四条边：留下了 $b_1,a_2$ 的贡献，相当于 $x$ 放到 B 中，$y$放到 A 中。

* 断 $a_1,c_1,a_2$ 三条边：留下了 $b_1,c_2,b_2$ 的贡献，相当于 $x$ 放到 B 中，$y$ 放到 B 中。

而且有且仅有这 4 种较优决策（只留一条边不作考虑），2 个以上的种子同样如此。

所以可以证明我们这样建图是正确的。

然后最后跑一边 Dinic 即可。

## 代码

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int maxn = 6e5 + 50, INF = 0x3f3f3f3f;

inline int read () {
	register int x = 0, w = 1;
	register char ch = getchar ();
	for (; ch < '0' || ch > '9'; ch = getchar ()) if (ch == '-') w = -1;
	for (; ch >= '0' && ch <= '9'; ch = getchar ()) x = x * 10 + ch - '0';
	return x * w;
}

int n, m, s, t, sum, ans;
int a[maxn], b[maxn];

struct Edge {
	int to, next, w;
} e[maxn << 1];

int tot, head[maxn], cur[maxn];

inline void Add (register int u, register int v, register int w) {
	e[++ tot].to = v;
	e[tot].w = w;
	e[tot].next = head[u];
	head[u] = tot;
}

inline void Build () {
	for (register int i = 1; i <= n; i ++) 
		Add (s, i, a[i]), Add (i, s, 0), Add (i, t, b[i]), Add (t, i, 0);
	for (register int i = 1; i <= m; i ++) {
		register int k = read(), c1 = read(), c2 = read();
		sum += c1, sum += c2;
		Add (s, i + n, c1), Add (i + n, s, 0), Add (i + n + m, t, c2), Add (t, i + n + m, 0);
		for (register int j = 1; j <= k; j ++) {
			register int x = read();
			Add (i + n, x, INF), Add (x, i + n, 0);
			Add (x, i + n + m, INF), Add (i + n + m, x, 0);
		}
	}
}

int deep[maxn], que[maxn];
bool inque[maxn];

inline bool BFS (register int x) {
	register int front = 1, tail = 0;
	for (register int i = 0; i <= t; i ++) 
		cur[i] = head[i], deep[i] = INF, inque[i] = 0;
	que[++ tail] = x, deep[x] = 0;
	while (front <= tail) {
		register int u = que[front ++]; inque[u] = 0;
		for (register int i = head[u]; i; i = e[i].next) {
			register int v = e[i].to;
			if (deep[v] > deep[u] + 1 && e[i].w) {
				deep[v] = deep[u] + 1;
				if (! inque[v]) inque[v] = 1, que[++ tail] = v;
			}
		}		
	}
	return deep[t] != INF;
}

inline int DFS (register int u, register int flow) {
	if (u == t) return ans += flow, flow;
	register int used = 0, tmp = 0;
	for (register int i = cur[u]; i; i = e[i].next) {
		register int v = e[i].to; cur[u] = i;
		if (deep[v] == deep[u] + 1 && e[i].w) {
			if (tmp = DFS (v, min (e[i].w, flow - used))) {
				used += tmp, e[i].w -= tmp, e[i % 2 ? i + 1 : i - 1].w += tmp;
				if (used >= flow) break;
			}
		}
	}
	return used;
}

inline void Dinic () {
	while (BFS (s)) DFS (s, INF);
	printf ("%d\n", sum - ans);
}

int main () {
	n = read();
	for (register int i = 1; i <= n; i ++) a[i] = read(), sum += a[i];
	for (register int i = 1; i <= n; i ++) b[i] = read(), sum += b[i];
	m = read(), s = 0, t = n + 2 * m + 1, Build (), Dinic ();
	return 0;
}
```

---


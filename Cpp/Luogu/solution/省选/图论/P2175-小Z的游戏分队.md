# 小Z的游戏分队

## 题目描述

小 Z 受不了寂寞，准备举办一次 DOTA 比赛，为了能让 ACM 班全部都参加比赛，他还特制了一张 DOTA 地图能够支持任意多人打任意多人。

现在问题来了，怎么把这么多人分成两队？小 Z 的想法是，每个人报上自己愿意同队的同学，接着小 Z 会按如下要求将所有人分为两队：

对任意同学甲，和同学甲同队的人，必须都是同学甲愿意同队的同学。

小 Z 希望两队的人数差尽量小，如果这种分组不存在，那么输出 `No solution`。

## 说明/提示

对于 $30\%$ 的数据，$N \leq 10$；

对于 $100\%$ 的数据，$N \leq 2000$。

## 样例 #1

### 输入

```
5
3 4 5 0
1 3 5 0
2 1 4 5 0
2 3 5 0
1 2 3 4 0```

### 输出

```
No solution```

## 样例 #2

### 输入

```
5
2 3 5 0
1 4 5 3 0
1 2 5 0
1 2 3 0
4 3 2 1 0```

### 输出

```
2 3```

# 题解

## 作者：超级范范 (赞：9)

以不信任关系建图

二分图判定染色

cnt[i][0/1]表示第i个连通块染1/0颜色的个数

f[i][j]表示前i个连通块第一个集合点的个数减第二个集合点的个数等于j是否可以达到（注意j可能为负 #define f(i,j) dp[i][j+2000]）

f(i,j)|=f(i-1,j-cnt[i][0]+cnt[i][1])| f(i-1,j+cnt[i][0]-cnt[i][1])
对于第i个连通块两种情况：

（1）    颜色为1 的点放入第1个集合，颜色为2 的点放入第2个集合

（2）    颜色为1 的点放入第2个集合，颜色为2 的点放入第1个集合

PS:这里解释一下为什么这道题不能用Tarjan强连通分量，因为信任关系不具有传递性。






```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int N=2005;
int n,x,m,color[N],cnt[N][3],f[N][N+N];
bool flag[N][N];
int tot,head[N],next[N*N],adj[N*N];
inline int read(int &x){
    char c=getchar();int num=0;
    for(;c<'0'||c>'9';c=getchar());
    for(;c>='0'&&c<='9';c=getchar()) num=(num<<1)+(num<<3)+c-'0';
    x=num;
}
void addedge(int u,int v){
    ++tot;
    next[tot]=head[u];
    head[u]=tot;
    adj[tot]=v;
}
bool dfs(int u){//二分图染色
    if(color[u]==1) cnt[m][1]++;
    else cnt[m][2]++;
    int e,v;
    for(e=head[u];e;e=next[e]){
        v=adj[e];
        if(!color[v]){
            color[v]=3-color[u];
            dfs(v);
        }
        else if(color[v]!=3-color[u]) return false;
    }
    return true;
}
int main(){
    read(n);
    for(int i=1;i<=n;i++)
        while(1){
            read(x);
            if(x==0) break;
            flag[i][x]=true;
        }
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n;j++)
            if(!flag[i][j]||!flag[j][i]){
                addedge(i,j);
                addedge(j,i);
            }
    for(int i=1;i<=n;i++)
        if(!color[i]){
            ++m;
            color[i]=1;
            if(!dfs(i)){
                printf("No solution");
                return 0;
            }
        }
    f[0][0]=1;
    for(int i=1;i<=m;i++)
        for(int j=-2000;j<=2000;j++)//枚举第一个集合点的个数与第二个集合点的差值
            f[i][j+2000]|=f[i-1][j-cnt[i][1]+cnt[i][2]+2000]|f[i-1][j+cnt[i][1]-cnt[i][2]+2000];
    int x,y;
    for(int j=0;j<=2000;j++)
        if(f[m][j+2000]||f[m][j]){ //枚举第一个集合点的个数与第二个集合点的差的绝对值
            x=(n+j)/2;
            y=n-x;
            if(x>y) swap(x,y);
            printf("%d %d\n",x,y);
            return 0;
        }
    printf("No solution");
    return 0;
}

```

---

## 作者：DefFrancis (赞：5)

首先我楼下的思路应该和我差不多（废话，一块做的）（坐在我旁边的毛线鬼maoxiangui）

他发题解扔个思路然后再扔个代码不讲就跑了很不厚道

而且他代码蜜汁写错了一些变量名..代码还贼拉拉长（逃）

所以我来大概说一下代码部分

这道题应该是一个二分图染色+背包问题

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int X=0,w=1; char ch=0;
    while(ch<'0' || ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0' && ch<='9') X=(X<<3)+(X<<1)+ch-'0',ch=getchar();
    return X*w;
```
}/\*快读\*/
```cpp
int tu[2050][2050],sum1,sum,num,sum2,delta[2050],f[2050];
vector<int>lb[2050];/*我们用邻接矩阵存一下初始的图，然后用vector存一下补图*/
int n,col[2050],v[2050];
void dfs(int x,int cols){/*他把dfs写成dfn了233*/
    if(v[x]&&col[x]!=cols){
        cout<<"No solution";
        exit(0);
```
}/\*如果访问过，并且这个点，即将染的颜色与他上回染的不一样，说明染糊了GG\*/
```cpp
    if(v[x])return;
    v[x]=1;/*标记*/
    col[x]=cols;/*染色*/
    if(col[x]==1)sum1++;
    else sum2++;/*计数*/
    for(int i=0;i<lb[x].size();i++){
        int u=lb[x][i];
        int colss=cols==1?2:1;/*不用解释了吧...*/
        dfs(u,colss);/*遍历与x连接的点，并染成colss*/
    }
}
int main(){
    n=read();
    for(int i=1;i<=n;i++){
        tu[i][i]=1;
        int x;
        do{
            x=read();
            if(x!=0)
                tu[i][x]=1;
        }while(x!=0);
```
}/\*中规中矩的读入\*/
```cpp
    for(int i=1;i<=n;i++){
        for(int j=i;j>=1;j--){
            if(!(tu[i][j]*tu[j][i])){
                lb[i].push_back(j);
                lb[j].push_back(i);
            }
        }
```
}/\*如果i到j，j到i中只有一条以下的路联通的话说明他们不能在同一组，加入补图当中\*/
```cpp
    for(int i=1;i<=n;i++){
        if(!col[i]){
        num++;/*如果该点没有染过色，就染*/
        sum1=0;/*注意计数清零*/
        sum2=0;
        dfs(i,1);
        delta[num]=max(sum1,sum2)-min(sum1,sum2);
        sum+=delta[num];/*"补图会有若干个连通块，可以把每个连通块当做一个物品，它的权值就表示两种颜色之差。"这句话的实现*/
        }
```
}/\*这里把问题转化成一个简单的背包问题\*/
```cpp
    int t=sum/2;
    for(int i=1;i<=num;i++){
        for(int j=t;j>=delta[i];j--){
            f[j]=max(f[j],f[j-delta[i]]+delta[i]);
        }
    }
    int ans=max(sum-f[t],f[t])-min(sum-f[t],f[t]);
    cout<<((n-ans)/2)<<" "<<((n+ans)/2);
}

```

---

## 作者：ykzzldz (赞：2)

看了一下这题的题解都比较古老哇，所以我就来写一下题解。

这题分为两个部分，我们先考虑一个问题，给出 $n$ 对数 $(a_i,b_i)$，$n\le 2000,\sum_{i=1}^na_i+b_i \le2000$，你需要将每对数的其中一个变为 $0$，求 $\min |\sum_{i=1}^na_i-\sum_{i=1}^nb_i|$。对于这个问题，我们可以进行 dp，设 $f_{i,j}=0/1$ 表示前 $i$ 对数差值为 $j$ 是否可行（注意，这里的差值定义为 $\sum_{j=1}^ia_j-\sum_{j=1}^ib_j$，所以可能出现负数），$f_{i,j}$ 从 $f_{i-1,j-a_i+b_i}$ 和 $f_{i-1,j+a_i-b_i}$ 转移来，其实就是枚举将哪个置为 $0$，初始化 $f_{0,0}=1$。

知道上面这个东西后，这题就比较简单了。首先，我们要对题目给出的条件建反图，也就是将两个不能在一起的人连边。然后可能二分图染色，无解的情况就是两个连边的人染了相同的颜色。染色的过程中，记录每个连通块染成黑色和白色的点的个数（也就是上面的 $a_i,b_i$），跑一遍上面的 dp 即可。

---

## 作者：dreamnotfounddd (赞：1)

#### 这是本蒟蒻第一篇题解，如有问题请指出，感谢。

首先观察题目，发现想要在图上考虑这种关系比较复杂。

所以，可以建反图试一下。

此时发现，有连边的就一定不能在同一队。

由此想到二分图，如果染色之后有相邻两边颜色相同，那么一定 `No solution`。

但是，此时的图在变成反图之后会变成多个图。

所以，我们考虑使用一个简单的 $dp$ ，这里就不过多解释了，具体请看代码。

$f_{i,j}$ 表示前 $i$ 个联通块中差为 $j$ 能否达成。

转移式： $f_{i,j} = f_{i-1,j-cnt_{i,1}+cnt_{i,0}} | f_{i-1,i-cnt_{i,0}+cnt_{i,1}}$

其中 $cnt_{i,0/1}$ 表示第 $i$ 个联通块两种颜色的点 / 人数。

```cpp
#include<bits/stdc++.h>
#define f(i,j) dp[i][j+4000]
typedef long long ll;
using namespace std;
const int maxn = 2007;
int n,g[maxn][maxn],hv[maxn],col[maxn],a[maxn][2],cnt=0,vis[maxn];
bool dp[maxn][maxn*4];
void colorful(int u,int color,int id){
	col[u]=color;
	a[id][color]++;
	for(int v = 1;v<=n;v++){
		if(!g[u][v])continue;
		if(!vis[v]){
			if(col[v]==color){//同色且相邻则一定无解
				cout << "No solution\n";
				exit(0);
			}
			if(col[v]==-1)colorful(v,color^1,id);//没有染色就去染
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	memset(col,-1,sizeof col);
	for(int x,i = 1;i<=n;i++){//建反图
		memset(hv,0,sizeof hv);
		hv[i]=1;
		while(1){
			cin >> x;
			if(x==0)break;
			hv[x]=1;
		}
		for(int j = 1;j<=n;j++){
			if(hv[j])continue;
			g[i][j]=g[j][i]=1;
		}
	}
	for(int i = 1;i<=n;i++)//染色
		if(col[i]==-1)
			colorful(i,0,++cnt);
	f(0,0)=1;
	for(int i = 1;i<=cnt;i++){//dp
		for(int j = -2000;j<=2000;j++){
			f(i,j)=f(i-1,j-a[i][1]+a[i][0])|f(i-1,j-a[i][0]+a[i][1]);
		}
	}
	int ans1,ans2;
	for(int i = 0;i<=2000;i++){//答案
		if(f(cnt,i) | dp[cnt][i]){
			ans1=min((n-i)/2,n-(n-i)/2),ans2=max((n-i)/2,n-(n-i)/2);
			cout << ans1 << " " << ans2 << "\n";
			return 0;
		}
	}
	cout << "No solution\n";
	return 0;
}
```

---

## 作者：ChengZe (赞：1)

我们JSOI的B班的搜索基础上机第三题，当时没想出来，听老师讲一遍好像还不算太难，就是个DP+二分图染色，具体的解释在代码中
```cpp
#define maxn 2001
int n,flag,tot;
int G[maxn][maxn],col[maxn],cnt[maxn];
void make_col(int u,int f){
	col[u]=(f^1);
	if(f==3)cnt[tot]++;else cnt[tot]--;
	for(int v=1;v<=n;v++){
		if(G[u][v])continue;
		if(col[u]==col[v]){//无法染色，有冲突 
			flag=1;return;
		}
		if(!flag&&!col[v]){
			make_col(v,f^1);
		}
	} 
}
int dp[2000+10][2000+10];
void solve(){
	//n个人被分成tot个二分图 ,第i个二分图元素差值为cnt[i]
	//每个二分图中2、3可以互换
	//dp[i][j]表示前i个二分图能够产生的差值情况，由于有对称性，不需要算负数部分
	dp[0][0]=1;
	for(int i=1;i<=tot;i++)
		for(int j=0;j<=n;j++)
			if(dp[i-1][j]){
				if(j-cnt[i]>=0)dp[i][j-cnt[i]]=1;
				if(j+cnt[i]>=0)dp[i][j+cnt[i]]=1;
			}
	int x,y;
	for(int i=0;i<=n;i++)if(dp[tot][i]){
		x=(n+i)/2,y=n-x;
		if(x>y)swap(x,y);
		printf("%d %d\n",x,y);
		return;
	}
}
int main(){
	int v;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		while(scanf("%d",&v)&&v)//i喜欢v
			G[i][v]=1; 
	}
	for(int i=1;i<=n;i++){
		G[i][i]=1;//自己肯定喜欢自己 
		for(int j=1;j<=n;j++)//单方喜欢也不能放一组 
			if(!G[i][j])G[j][i]=0;
	}
	
	for(int i=1;i<n;i++){//对不喜欢的2、3染色成tot个二分图 ,cnt记录色2与色3的差值 
		if(!col[i]&&!flag){
			tot++;
			make_col(i,2);
		}
		if(flag){printf("No solution\n");return 0;} 
	}
	solve();
	return 0;
}

```

---

## 作者：nekko (赞：1)

构造反图（既如果两个人不能在一个组就连一条边），如果构造出的图不是二分图则无解，因为此时会存在某个人在两个组的时候都会有不能在一个组的人。

然后对于每一个编号（dfs的时候对于在同一条内部链的人的编号）的人可以看作一左一右两个value，每次的选择就相当于把左右的value互换，然后这就是一个背包dp了。

注意是No solution而不是No Solution

```cpp
// 动态规划 判定性dp 背包dp 二分图染色

%:pragma GCC optimize(2)

#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <vector>

using namespace std;

const int N = 2010;

int n, color[N], like[N][N], val[N][3], cnt;

bool f[N][N * 8];

vector<int> G[N];

void dfs(int u, int c, int dfn) {
    color[u] = c;
    ++ val[dfn][c];
    for(int i = 0 ; i < G[u].size() ; ++ i) {
        int v = G[u][i];
        if(!color[v]) {
            dfs(v, 3 - c, dfn);
        } else if(color[u] == color[v]) {
            puts("No solution");
            exit(0);
        }
    }
}

int main() {
    scanf("%d", &n);
    for(int i = 1, x ; i <= n ; ++ i) {
        while(scanf("%d", &x), x) {
            like[i][x] = 1;
        }
    }
    for(int i = 1 ; i <= n ; ++ i) {
        for(int j = 1 ; j < i ; ++ j) {
            if(!(like[i][j] && like[j][i])) {
                G[i].push_back(j);
                G[j].push_back(i);
            }
        }
    }
    for(int i = 1 ; i <= n ; ++ i) {
        if(!color[i]) {
            dfs(i, 1, ++ cnt);
        }
    }
    memset(f, 0, sizeof(f));
    #define dp(i, j) f[i][j + 4000]
    dp(0, 0) = 1;
    for(int i = 1 ; i <= cnt ; ++ i) {
        for(int j = -2000 ; j <= 2000 ; ++ j) {
            dp(i, j) |= dp(i - 1, j - val[i][1] + val[i][2]) | dp(i - 1, j - val[i][2] + val[i][1]);
        }
    }
    for(int i = 0 ; i <= 2000 ; ++ i) {
        if(dp(cnt, i)) {
            int x = (n + i) / 2, y = n - x;
            if(x > y) swap(x, y);
            printf("%d %d\n", x, y);
            return 0;
        } else if(dp(cnt, -i)) {
            int x = (n - i) / 2, y = n - x;
            if(x > y) swap(x, y);
            printf("%d %d\n", x, y);
            return 0;
        }
    }
    puts("No solution");
}
```

---

## 作者：pldzy (赞：0)

二分图 + 背包 dp。

~~（一眼题~~

## Solution

### 题意

对于两个人 $x$ 和 $y$，如果两个人都相信对方，我们就给点 $x$ 和点 $y$ 连一条无向边。

此时题意转化为：给一张图，$N$ 个点，$M$ 条边，要求将图分成两个团，使得两个团的顶点数量差值最小，求两个团分别的点数。（团是一个两两之间有边的顶点集合。）

### 1

发现把所有节点分层两个团的本质就是对这些点进行黑白染色。设最后染成黑色的节点数为 $a$，白色的节点数为 $b$。

发现直接对原图上手太复杂了，那些边也很难处理。所以考虑对原图建它的[**补图**](https://oi-wiki.org/graph/concept/#_12)。根据补图的定义，知道在补图中有一条边连接的两个节点在原图中不直接联通。所以，这样一来就把题目中“团是一个两两之间有边的顶点集合”转化为“集合内的节点两两不直接联通”。说到这里，显然，就变成将补图转化为一个二分图了。

需要注意的是，在对原图建了补图之后，可能会出现若干个连通块，即**连通块（二分图）的数量大于等于** $1$。

在一个二分图内，试将其某一部点都染成白色，另一部点都染成黑色。而这两部点就是答案所求的两个团各自的**一部分**。但是，原图的补图**会有多个二分图**，即不止一个连通块。那如何确定每一个二分图左右部点各自所染的颜色呢？

### 2

我们的目标是让 $a$ 和 $b$ 的差尽可能小。

因此，在遍历一个连通块将其转化为一二分图的过程中，记录下每个二分图它的左右部点数量的差值，并全部相加，记为 $sum$。接着要做的就是适当分配这些差值（分成两部分 $x$ 和 $y$），使这两部分的和，它们两的差尽可能小。绕这么多，就是为了 $a$ 和 $b$ 的差尽可能小。

显然，我们想要 $x$ 和 $y$ 都尽可能接近 $\frac{sum}{2}$。这里运用到**最优性转可行性**的方法——背包 dp。

### 3

通过简单背包，可以求得 $x$ 和 $y$ 的最小差值，即 $a$ 和 $b$ 的最小差值。同时，已知 $a$ 与 $b$ 的和（即 $n$），组合起来，~~就又是一个小学数学知识~~，就成为了一个简单的和差问题。往下的解和差问题就不多说了。

至此，此题已被解决，吸氧可过。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i, a, b) for(int i = a; i <= b; ++i)
#define per(i, a, b) for(int i = a; i >= b; --i)
const int maxn = 2005;
int n, vis[maxn], c[5], flg;
int st[maxn * 2], tot, sum, f[maxn], df;
set <int> e[maxn];
bool g[maxn][maxn];

inline void dfs(int x){
	if(flg) return;
	for(int v : e[x]) if(vis[v])
		if(vis[v] == vis[x]) return flg = 1, void();
		else continue;
	else vis[v] = 3 - vis[x], c[vis[v]] += 1, dfs(v);
}

int main(){
	scanf("%d", &n);
	rep(i, 1, n){ g[i][i] = 1;
		while(true){ int x; 
			scanf("%d", &x); if(!x) break;
			g[i][x] = 1;//i可以和 x同队 
		}
	} rep(i, 1, n) rep(j, 1, i) if(!g[i][j] or !g[j][i]) 
		e[i].insert(j), e[j].insert(i);
	rep(i, 1, n) if(!vis[i]){
		c[1] = 1, c[2] = 0; vis[i] = 1, dfs(i); 
		if(flg) return printf("No solution"), 0;
		st[++tot] = abs(c[1] - c[2]), sum += abs(c[1] - c[2]);
	} f[0] = 1;
	rep(i, 1, tot) per(j, sum / 2, st[i])
		f[j] |= f[j - st[i]];
	per(i, sum / 2, 0) if(f[i]){ df = i; break;}
	df = abs(sum - df * 2);
	printf("%d %d\n", (n - df) / 2, (n + df) / 2);
	return 0;
}
```


------------
辛苦审核。

---

## 作者：lichenxi (赞：0)

二分图染色判断，然后背包

先以不信任的关系建图

然后可能有多个二分图（因为图不一定联通）

背包可以看成每次从一个只有2个元素的集合中选一个，可以组成的值有哪些

之后再扫一遍，假设当前是枚举的可以组成的值$x$，取$abs((n-x)-x)$最小的那一对就好了

代码：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
void read(int &x) {
    char ch; bool ok;
    for(ok=0,ch=getchar(); !isdigit(ch); ch=getchar()) if(ch=='-') ok=1;
    for(x=0; isdigit(ch); x=x*10+ch-'0',ch=getchar()); if(ok) x=-x;
}
#define rg register
const int maxn=2e3+10;
int n,tot,f[maxn][maxn],g[maxn][maxn],sum[maxn][2],pre[maxn*maxn],ans,ans1,cnt,nxt[maxn*maxn],h[maxn],col[maxn];bool vis[maxn],flag;
void add(int x,int y){pre[++cnt]=y,nxt[cnt]=h[x],h[x]=cnt;pre[++cnt]=x,nxt[cnt]=h[y],h[y]=cnt;}
void dfs(int x)
{
	sum[tot][col[x]]++;
	for(rg int i=h[x];i;i=nxt[i])
	{
		if(col[pre[i]]==-1)col[pre[i]]=col[x]^1,dfs(pre[i]);
		else if(col[pre[i]]==col[x]){flag=1;return ;}
		if(flag)return ;
	}
}
int main()
{
	read(n),memset(col,-1,sizeof col);
	for(rg int i=1,y;i<=n;i++)
	{
		while(1){read(y);if(!y)break;vis[y]=1;}
		for(rg int j=1;j<=n;j++){if(!vis[j]&&i!=j)add(i,j);vis[j]=0;}
	}
	for(rg int i=1;i<=n;i++)
	{
		if(col[i]==-1)col[i]=0,tot++,dfs(i);
		if(flag){printf("No solution\n");return 0;}
	}
	f[0][0]=1;
	for(rg int i=1;i<=tot;i++)
	{
		for(rg int j=n;j>=sum[i][0];j--)
			if(f[i-1][j-sum[i][0]]||g[i-1][j-sum[i][0]])f[i][j]=1;
		for(rg int j=n;j>=sum[i][1];j--)
			if(f[i-1][j-sum[i][1]]||g[i-1][j-sum[i][1]])g[i][j]=1;
	}
	ans=0,ans1=1e9;
	for(rg int i=0;i<=n;i++)
		if(f[tot][i]||g[tot][i])if(abs(i-(n-i))<ans1-ans)ans=min(i,n-i),ans1=max(i,n-i);
	printf("%d %d\n",ans,ans1);
}
```


---


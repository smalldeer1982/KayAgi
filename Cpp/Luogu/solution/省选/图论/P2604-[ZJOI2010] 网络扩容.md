# [ZJOI2010] 网络扩容

## 题目描述

给定一张有向图，每条边都有一个容量 $c$ 和一个扩容费用 $w$。这里扩容费用是指将容量扩大 $1$ 所需的费用。求： 

1. 在不扩容的情况下，$1$ 到 $n$ 的最大流；

2. 将 $1$ 到 $n$ 的最大流增加 $k$ 所需的最小扩容费用。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\le 100$。
- 对于 $100\%$ 的数据，保证 $1\le n\le 10^3$，$1\le m\le 5\times 10^3$，$1\le k\le 10$，$1 \leq u, v \leq n$，$1\le c,w\le 100$。

## 样例 #1

### 输入

```
5 8 2
1 2 5 8
2 5 9 9
5 1 6 2
5 1 1 8
1 2 8 7
2 5 4 9
1 2 1 1
1 4 2 1```

### 输出

```
13 19
```

# 题解

## 作者：bztMinamoto (赞：35)

话说其实不用新建图的……我看到楼下几位大佬的做法都是0.5倍经验+码量巨大的……

实际上只要直接跑一个费用流就行了。对于第一问，我们直接连边，然后令费用为$0$，跑一遍，输出最大流即可

对于第二问，只要在原来的每条边上再连一条边，容$inf$费为扩边费用，然后$k$的限制只要再建一个源点往$1$连容$k$费$0$的边。在残量网络上再跑一遍，输出最小费用即可

考虑为什么这样做是对的。因为要跑最小费用最大流，而原图是无花费的最大流，那么只要在此残量网络上继续增广，就可以保证跑出最小费用了
```
//minamoto
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define inf 0x3f3f3f3f
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
const int N=1005,M=50005;
struct node{
	int u,v,f,e;
	node(){}
	node(int u,int v,int f,int e):u(u),v(v),f(f),e(e){}
}E[M];
int ver[M],Next[M],head[N],edge[M],flow[M],tot=1;
int dis[N],disf[N],vis[N],Pre[N],last[N];
int n,m,k,s,t,maxflow,mincost;
queue<int> q;
inline void add(int u,int v,int f,int e){
	ver[++tot]=v,Next[tot]=head[u],head[u]=tot,flow[tot]=f,edge[tot]=e;
	ver[++tot]=u,Next[tot]=head[v],head[v]=tot,flow[tot]=0,edge[tot]=-e;
}
bool spfa(){
	memset(dis,0x3f,sizeof(dis));
	q.push(s),dis[s]=0,disf[s]=inf,Pre[t]=-1;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=head[u];i;i=Next[i]){
			int v=ver[i];
			if(flow[i]&&dis[v]>dis[u]+edge[i]){
				dis[v]=dis[u]+edge[i],Pre[v]=u,last[v]=i;
				disf[v]=min(disf[u],flow[i]);
				if(!vis[v]) vis[v]=1,q.push(v);
			}
		}
	}
	return ~Pre[t];
}
void dinic(){
	while(spfa()){
		int u=t;maxflow+=disf[t],mincost+=disf[t]*dis[t];
		while(u!=s){
			flow[last[u]]-=disf[t];
			flow[last[u]^1]+=disf[t];
			u=Pre[u];
		}
	}
}
int main(){
	n=read(),m=read(),k=read();
	s=1,t=n;
	for(int i=1;i<=m;++i){
		int u=read(),v=read(),f=read(),e=read();
		E[i]=node(u,v,f,e);
		add(u,v,f,0);
	}
	dinic();
	printf("%d ",maxflow);
	for(int i=1;i<=m;++i){
		int u=E[i].u,v=E[i].v,e=E[i].e;
		add(u,v,inf,e);
	}
	s=0;
	add(s,1,k,0);
	dinic();
	printf("%d\n",mincost);
	return 0;
}
```

---

## 作者：Orion545 (赞：11)

# 广告

[蒟蒻的blog](http://www.cnblogs.com/dedicatus545/p/8732901.html)

# 正文

第一问：无脑网络流跑一波

第二问：

先考虑一个贪心的结论：扩容出来的扩容流量一定要跑满

证明显然

因此我们可以把扩容费用可以换个角度思考，变成增加一点流量，花费W的费用

这样，我们就得到了一个最小费用流的模型

只要在原图基础上，对于每个原图边，加一条费用为W，无限容量的边，而原图中的所有边费用为0，就可以模拟原题需要的情况了

最后一个问题：流量增加限制K怎么处理？

我们虽然可以用spfa的费用流，一次一次增加，直到K，但是这样也太慢chou了吧？

不怕，我们加一个n+1号点，作为第二问的费用流汇点，在n到n+1之间连一条边，费用为0，流量为第一问的最大流流量加上K

注意：上述算法是对于第二问建一个新图来跑的，对于在残量网络上瞎搞的方法，由于本人水平有限，并无法很好地证明正确性

我的算法，时间复杂度大概会多一个$O\left(m\right)$，再加上一点常数

同时因为我是zkw费用流实现的最大流，所以大概稍慢....?

其实应该是一样的吧！

Code：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define inf 1e9
using namespace std;
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
int n,m,cnt=-1,ans,K,first[1010],dis[1010],vis[1010];
struct edge{
    int to,next,w,cap;
}a[25010];
inline void add(int u,int v,int w,int cap){
    a[++cnt]=(edge){v,first[u],w,cap};first[u]=cnt;
    a[++cnt]=(edge){u,first[v],-w,0};first[v]=cnt;
}
bool spfa(int s,int t){
    int q[5010],head=0,tail=1,u,v,w,i;
    memset(dis,-1,sizeof(dis));memset(vis,0,sizeof(vis));
    q[0]=t;dis[t]=0;vis[t]=1;
    while(head<tail){
        u=q[head++];vis[u]=0;
        for(i=first[u];~i;i=a[i].next){
            v=a[i].to;w=a[i].w;
            if(a[i^1].cap&&((dis[v]==-1)||(dis[v]>dis[u]-w))){
                dis[v]=dis[u]-w;
                if(!vis[v]) q[tail++]=v,vis[v]=1;
            }
        }
    }
    return ~dis[s];
}
int dfs(int u,int t,int limit){
    if(u==t){vis[t]=1;return limit;}
    if(!limit){vis[u]=1;return 0;}
    int i,v,f,flow=0,w;vis[u]=1;
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;w=a[i].w;
        if((dis[v]==dis[u]-w)&&(!vis[v])&&a[i].cap){
            f=dfs(v,t,min(limit,a[i].cap));if(!f) continue;
            a[i].cap-=f;a[i^1].cap+=f;
            flow+=f;limit-=f;ans+=a[i].w*f;
            if(!limit) return flow;
        }
    }
    return flow;
}
int zkw(int s,int t){//zkw费用流
    int re=0;
    while(spfa(s,t)){
        vis[t]=1;
        while(vis[t]){
            memset(vis,0,sizeof(vis));
            re+=dfs(s,t,inf);
            //cout<<"cur re="<<re<<"\n";
        }
    }
    return re;
}
int cost[5010],u[5010],v[5010],cap[5010];
int main(){
    memset(first,-1,sizeof(first));
    int i,maxflow;
    n=read();m=read();K=read();
    for(i=1;i<=m;i++){
        u[i]=read();v[i]=read();cap[i]=read();cost[i]=read();
        add(u[i],v[i],0,cap[i]);
    }
    printf("%d ",maxflow=zkw(1,n));//maxflow要记录下来，后面有用
    memset(first,-1,sizeof(first));memset(a,0,sizeof(a));cnt=-1;//清理原图，重新建图
    for(i=1;i<=m;i++){
        add(u[i],v[i],0,cap[i]);
        add(u[i],v[i],cost[i],inf);
    }
    add(n,n+1,0,maxflow+K);
    zkw(1,n+1);
    printf("%d",ans);
}
```

---

## 作者：ezoiHY (赞：10)

# 我的[博客](https://www.cnblogs.com/ezoihy/p/9417308.html)啊啊啊啊
### 题目大意：
给你一幅n个点的网络，先求出其1到n的最大流，每条弧还会有个属性$cost_i$，表示没扩容一个单位的费用，现在我们要求的就是扩容K个单位的最小费用
### 思路：
这是一道比较裸的网络流，第一问直接dinic就是了，重点就在于第二问。我们把第一问的残量网络继续利用，其中的每条弧的费用都是0，此时我们再在第$i$条弧的两端之间在建一条弧，弧的容量是$INF$，费用就是$cost_i$。这样我们固然可以保证费用正确，可是我们保证不了扩容了K，我们就可以建一个超级源点，连向1号点，容量为K，费用为0。在这个网络中最大流一定是满流，也就是K啊，此时的最小费用就是我们所要求的。
### 具体实现：
这就很简单了，一遍$dinic$，再一遍$MCMF$我们就可以了
代码如下
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
 
using namespace std;
 
const int maxn=10001,maxm=50001,inf=0x7f7f7f7f;
int n,m,k,tot,next[maxm<<1],beg[maxm<<1],head[maxn],flow[maxm<<1],fflow[maxm<<1],last[maxn],pre[maxn],fl[maxn],nxt[maxm<<1],to[maxm<<1],ccost[maxm<<1],cost[maxm<<1],d[maxn],dep[maxn];
bool vis[maxn];
 
void addedge(int x,int y,int z,int co,int type){
    nxt[++tot]=head[x];
    head[x]=tot;
    to[tot]=y;
    beg[tot]=x;
    flow[tot]=z;
    fflow[tot]=type?z:0;
    cost[tot]=type?co:0;
    ccost[tot]=co;
}
 
bool bfs(){
    memset(dep,0,sizeof(dep));
    queue<int> q;
    q.push(1);
    dep[1]=1;
    while(!q.empty()){
        int x=q.front();
        q.pop();
        for(int i=head[x];i;i=nxt[i]){
            int u=flow[i],v=to[i];
            if(u>0 and !dep[v]){
                dep[v]=dep[x]+1;
                q.push(v);
            }
        }
    }
    return dep[n];
}
 
int dfs(int x,int mini){
    if(x==n)return mini;
    for(int i=head[x];i;i=nxt[i]){
        int u=flow[i],v=to[i];
        if(u>0 and dep[v]==dep[x]+1){
            int dd=dfs(v,min(mini,u));
            if(dd>0){
                flow[i]-=dd;
                flow[i^1]+=dd;
                return dd;
            }
        }
    }
    return 0;
}
         
int dinic(){
    int ret=0;
    while(bfs()){
        int tmp=dfs(1,inf);
        while(tmp){
            ret+=tmp;
            tmp=dfs(1,inf);
        }
    }
    return ret;
}
 
bool spfa() {
    memset(d,0x7f,sizeof(d));
    memset(fl,0x7f,sizeof(fl));
    memset(vis,0,sizeof(vis));
    queue<int> q;
    q.push(n+1);
    vis[n+1]=1;
    d[n+1]=0;
    pre[n]=-1;
    while(!q.empty()) {
        int now=q.front();
        q.pop();
        for(int i=head[now];i;i=nxt[i]){
            int v=to[i];
            if(fflow[i]>0 and d[v]>d[now]+cost[i]){ 
                d[v]=d[now]+cost[i];
                pre[v]=now;
                last[v]=i;
                fl[v]=min(fl[now],fflow[i]);
                if(!vis[v]){
                    vis[v]=1;
                    q.push(v);
                }
            }
        }
        vis[now]=0;
    }
    return pre[n]!=-1;
}
 
int mcmf(){
    int ret=0;
    while (spfa()){
        int now=n;ret+=fl[n]*d[n];
        while (now!=n+1){
            fflow[last[now]]-=fl[n]; 
            fflow[last[now]^1]+=fl[n];
            now=pre[now];
        }
    }
    return ret;
}
 
void rebuild(){
	int cnt=tot;
	for(int i=2;i<=cnt;i+=2){
		fflow[i]=flow[i];
		fflow[i+1]=flow[i+1];
		addedge(beg[i],to[i],inf,ccost[i],1);
		addedge(to[i],beg[i],0,-ccost[i],1);
	}
}

int main(){
    scanf("%d%d%d",&n,&m,&k);
    addedge(n+1,1,k,0,1);
    for(int i=1;i<=m;i++){
        int a,b,c,d;
        scanf("%d%d%d%d",&a,&b,&c,&d);
        addedge(a,b,c,d,0);
        addedge(b,a,0,-d,0);
    }
    int ans1=dinic();
    rebuild();
    int ans2=mcmf();
    printf("%d %d\n",ans1,ans2);
    return 0;
}
```

---

## 作者：沉辰 (赞：5)

说一下大致思路。
对于第一问，很简单就是求个最大流F。但是第二问呢？
我们可以这样想，第一问建的边相当于是花费为0，（流量该是多少就是多少）的边
对于有扩容费用的边，就相当于是花费为扩容费用，流量为？的边。
题目中要求将1-n的流量增加k,即限制1-n的最大流为F+k。
那么我们就想办法找一条边来限制F+k这个流量，也就是说其他的边不能够成为限制。
我令S=1,T=n+1,从n到T建一条花费为0,流量为F+k的边。
上文中的？就相当于inf.
那么第二问的答案就是新建图的最大流的情况下的最小费用
代码见blog(我的最大流套的费用流板子，本质一样，所以不要介意的啦）
[安然流香](http://www.cnblogs.com/adelalove/p/8488370.html)

---

## 作者：Npse_D (赞：3)

我用两种方法做了这个题，恰巧都是题解里出现过的方法……


第一问需要你考虑这个问题：
	这是一道网络流题目还是一道费用流题目。
    显然这是一道费用流题目，因为它第一问是裸的最大流。所以无论如何都要跑费用流，第二问的图还比第一问多一倍的边。
    嗯……
    所以本着O（cn）==O（n）的原则，拿w==0的EK跑最大流就可以……
    更何况第二问的图比第一问复杂，c可能是小于等于2的……
    再写一遍Dinic的都是老实人。
    
第二问。。。
	作为费用流题目，最重要的当然是建图。不过这个题建图思路非常显然，本蒟蒻都能瞬间想到。。。。
	两个显然的思路：
    ①增加源流
    ②限制汇流
    。。。。。。。
    大概可以想象一下，如果要给自己家的水流扩流一个准确的值k，最暴力的方法就是把所有的管子都加粗到无限粗，保证水都能流过来，然后两个途径，一是让自来水厂给自己maxf+k的水（把它看成是新的一个水流），这样顶多也就maxf+k的水。但管子除了k管儿，其它管子又是无限粗的，所以带费用的最大流又至少是maxf+k，因此最大流就是准确的maxf+k了。二是装一个maxf（扩流前的最大流）+k大的水龙头，这样就刚好能扩k的水了。
    可能有点瑕疵，大体意思差不多。。。
    
    所以经过思考后，交上程序成功WA掉。。。
    后来想了想，是因为没有重置每一个流的容量。
    因为不重置容量的话，就是已经流过maxf。再流maxf，它相当于流了2maxf+k的流。
    所以这里就有两个办法了，一是复制一份新图，一份拿来做最大流，一份拿来做最小费用流。下面的神犇可能是用这种方法做的，所以用了maxf+k。二是干脆把所有的maxf+k都当成k。。。。
    虽然不怎么会证明，但可以想一下，扩容前和扩容后的流的状态f(x)是可减的…那么最优的免费流的状态是不会因扩容而影响到的，那么这个maxf在扩容前和扩容后都是免费的，而k则都一定会被收费。那么刚刚跑完的最大流，在新图里免费流量的状态是完全重合的。所以我们直接用原来的图，假装自己已经跑过maxf了，然后直接加个k就可以了。
    
    实现：
    实现就简单炸了……
    ①的实现就是让0到1连一个顶多流k的流。
    ②就是让n到n+1连一个流k的流。。。。
    
    代码：
    ①
  ```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf = 123599857;
struct node{
    int to;
    int cap;
    int cost;
    int coc;
    bool type;
};
vector<node>data[1005];
int pre1[1005],pre2[1005],dx[1005],incf[1005],costed[1005][1005],n,m,k,maxf,ans,s;
bool inq[1005];
inline void add(int u,int v,int w,int f){
    data[u].push_back((node){v,w,f,data[v].size(),1});
    data[v].push_back((node){u,0,-f,data[v].size()-1,0});
}
inline bool spfa(){
    fill(dx+1,dx+n+1,inf);
    queue<int>q;
    memset(inq,0,sizeof(inq));
    q.push(s);
    inq[s]=1;
    dx[s]=0;
    incf[s]=inf;
    while(!q.empty()){
        int now=q.front();
        q.pop();
        inq[now]=0;
        for(int j=0;j<data[now].size();j++){
            node &tmp=data[now][j];
            if(tmp.cap>0&&dx[tmp.to]>dx[now]+tmp.cost){
                dx[tmp.to]=dx[now]+tmp.cost;
                pre1[tmp.to]=now;
                pre2[tmp.to]=j;
                incf[tmp.to]=min(tmp.cap,incf[now]);
                if(!inq[tmp.to]){
                    q.push(tmp.to);			
                    inq[tmp.to]=1;
                }
            }
        }
    }
	return dx[n]!=inf;
}
inline void updata(){
    int x=n;
    while(x!=s){
        int y=pre1[x],i=pre2[x];
        node &tmp=data[y][i];
        tmp.cap-=incf[n];
        data[tmp.to][tmp.coc].cap+=incf[n];
        x=y;
    }
    maxf+=incf[n],ans+=dx[n]*incf[n];
}
void solve(){while(spfa())updata();}
int main(){
    cin>>n>>m>>k;
    s=1;
    for(int i=1;i<=m;i++){
        int u,v,c,w;
        cin>>u>>v>>c>>w;
        costed[u][v]=w;
        add(u,v,c,0);
    }
    solve();
    cout<<maxf<<" ";
    for(int i=1;i<=n;i++){
    	int coc=data[i].size();
    	for(int j=0;j<coc;j++){
            if(data[i][j].type)add(i,data[i][j].to,100000000,costed[i][data[i][j].to]);
    	}
    }
    s=0;
    add(0,1,k,0);
    solve();
    cout<<ans;
}
```
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   ②
   
   
   
   
   
   
   
   
   
   
   
   
   
  
  ```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf = 123599857;
struct node{
    int to;
    int cap;
    int cost;
    int coc;
    bool type;
};
vector<node>data[1005];
int pre1[1005],pre2[1005],dx[1005],incf[1005],costed[1005][1005],n,m,k,t,maxf,ans;
bool inq[1005];
inline void add(int u,int v,int w,int f){
    data[u].push_back((node){v,w,f,data[v].size(),1});
    data[v].push_back((node){u,0,-f,data[v].size()-1,0});
}
inline bool spfa(){
    fill(dx+1,dx+n+1,inf);
    queue<int>q;
    memset(inq,0,sizeof(inq));
    q.push(1);
    inq[1]=1;
    dx[1]=0;
    incf[1]=inf;
    while(!q.empty()){
        int now=q.front();
        q.pop();
        inq[now]=0;
        for(int j=0;j<data[now].size();j++){
            node &tmp=data[now][j];
            if(tmp.cap>0&&dx[tmp.to]>dx[now]+tmp.cost){
                dx[tmp.to]=dx[now]+tmp.cost;
                pre1[tmp.to]=now;
                pre2[tmp.to]=j;
                incf[tmp.to]=min(tmp.cap,incf[now]);
                if(!inq[tmp.to]){
                    q.push(tmp.to);			
                    inq[tmp.to]=1;
                }
            }
        }
    }
    return dx[n]!=inf;
}
inline void updata(){
    int x=n;
    while(x!=1){
        int y=pre1[x],i=pre2[x];
        node &tmp=data[y][i];
        tmp.cap-=incf[n];
        data[tmp.to][tmp.coc].cap+=incf[n];
        x=y;
    }
    maxf+=incf[n],ans+=dx[n]*incf[n];
}
void solve(){while(spfa())updata();}
int main(){
    cin>>n>>m>>k;
    for(int i=1;i<=m;i++){
        int u,v,c,w;
        cin>>u>>v>>c>>w;
        costed[u][v]=w;
        add(u,v,c,0);
    }
    t=0;
    solve();
    cout<<maxf<<" ";
    for(int i=1;i<=n;i++){
    	int coc=data[i].size();
    	for(int j=0;j<coc;j++){
            if(data[i][j].type)add(i,data[i][j].to,k,costed[i][data[i][j].to]);
    	}
    }
    n++;
    add(n-1,n,k,0);
    solve();
    cout<<ans;
}
```
    
    
    

---

## 作者：mohei0 (赞：2)

## 题意

求一个网络的最大流

每条边有一个扩容费用 $W$ ，表示将这条边扩大 $1$ 容量的费用

求原图最大流 $+k$ 所需的扩容费用

$k\le 10!!!$

## 分析

首先当然是求出最大流

显然扩容后的最大流是在原图最大流基础上的

所以我们可以直接在残量网络上考虑扩容

这时我们发现 $k$ 的范围极小

所以我考虑一次增加 $1$ 的最大流

考虑哪些边要扩容

显然只增加 $1$ 的最大流时，残量网络中仍有容量的边是不用扩容的

那么只剩下容量为 $0$ 的边了

所以我将残量网络中容量为 $0$ 的边容量加 $1$ ，费用设为该边的 $W$

但这样没法限定只增加 $1$ 的流量啊

可能跑费用流时会跑出多条增流路径

其实我们的费用流根本不用跑完，只需要一次spfa+增流就好了，也就是限定只增流一条路径

增流了 $1$ 之后，重复上述操作增流 $k$ 次即可

具体流程：

1. 最大流
2. 残量网络中容量为 $0$ 的边容量 $++$ ，费用设为该边 $W$
3. 找到费用最小的一条增流路径进行增流
4. 重复 $2,3$ 操作 $k$ 次

## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int MAXN=5007,MAXM=100007;
int n,m,s=MAXN-3,t=MAXN-2;

struct side {
	int siz,val,from,to,nex;
	side(){nex=0;}
}ed[MAXM];
int cntn=0,cntm=1;
int head[MAXN]={0};

void link(int from,int to,int siz,int val)
{
	ed[++cntm].from=from;ed[cntm].to=to;
	ed[cntm].siz=siz;ed[cntm].val=val;
	ed[cntm].nex=head[from];head[from]=cntm;
	ed[++cntm].from=to;ed[cntm].to=from;
	ed[cntm].siz=0;ed[cntm].val=-val;
	ed[cntm].nex=head[to];head[to]=cntm;
}
int ss=0,vs=0;
int dis[MAXN],now,fa[MAXN];
bool inq[MAXN]={0};
deque<int> qu;
bool spfa()
{
	memset(dis,0x3f,sizeof(dis));
	memset(inq,0,sizeof(inq));
	qu.push_back(s);
	dis[s]=1;
	while(qu.size())
	{
		now=qu.front();qu.pop_front();
		inq[now]=0;
		for(int i=head[now];i;i=ed[i].nex)
			if(ed[i].siz&&dis[ed[i].to]>ed[i].val+dis[now])
			{
				dis[ed[i].to]=ed[i].val+dis[now];
				fa[ed[i].to]=i;
				if(!inq[ed[i].to]) qu.push_back(ed[i].to);
				inq[ed[i].to]=1;
			}
	}
	return dis[t]!=0x3f3f3f3f;
}
void add()
{
	int minn=1e9;
	for(int i=t;i!=s;i=ed[fa[i]].from)
		minn=min(minn,ed[fa[i]].siz);
	for(int i=t;i!=s;i=ed[fa[i]].from)
	{
		ed[fa[i]].siz-=minn;
		ed[fa[i]^1].siz+=minn;
		vs+=ed[fa[i]].val*minn;
	}
	ss+=minn;
}
void MCMF()
{
	vs=0;ss=0;
	while(spfa()) add();
}

int k;

int U[MAXM],V[MAXM],C[MAXN],W[MAXM];
int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++)
		cin>>U[i]>>V[i]>>C[i]>>W[i];
	for(int i=1;i<=m;i++) link(U[i],V[i],C[i],0);
	link(s,1,1e9,0);
	link(n,t,1e9,0);
	MCMF();
	cout<<ss<<" ";
	int cost=0;
	for(int i=0;i<k;i)
	{
		ss=vs=0;
		for(int i=1,i2;i<=m;i++)
		{
			i2=i*2;
			if(ed[i2].siz==0)
			{
				ed[i2].siz++;
				ed[i2].val=W[i];
			}
		}
		spfa();add();
		i+=ss;
		cost+=vs;
	}
	cout<<cost;
}
```

---

## 作者：丽尔巴茨 (赞：1)

这是一道结合了最大流和费用流的好题目。\
第一问就是跑一遍最大流，第2问有些新颖，不过也是对费用流的理解的一种考察吧,假如没有第一问就是从源点连一条容量为k，费用为0的边，再跑一遍spfa就可以找出最大流了，那结合第一问，第一问对第2问有什么影响呢，没有第一问就是，原来正向边的容量上限是w，反向边容量上限是0，费用是f和-f，结合第2问就是 容量无限，不过在某些范围内是费用“免费的”，某些是为f的，因为是增加了，才需要收费，可以理解为原来是无穷的，超过了原来的残余网络，才需要收费，那么这道题就可以做完了；

因为网络流的题目难点在建图，所以给出建图思路，关于dinic算法求最大流和spfa求最小费就去模板题哪里看吧，有很多很好的题解，本篇给出这题的建图思路；

以下给出ac代码；
```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <queue>

using namespace std;
const int maxn=2010,maxm=3e4+7,inf=0x3f3f3f3f;
int h[maxn],e[maxm],ne[maxm],w[maxm],f[maxm],idx;
int dep[maxn];
int pre[maxn],last[maxn],flow[maxn],dis[maxn];
bool vis[maxn];
int n,m,s,t,dk;
int x[maxm],y[maxm],z[maxm],r[maxm];
int min_cost;

void add(int a,int b,int c,int d){
    e[idx]=b,w[idx]=c,f[idx]=d,ne[idx]=h[a],h[a]=idx++;
}
bool bfs(int s,int t){
    memset(dep,0,sizeof dep);
    queue<int>q;q.push(s);dep[s]=1;
    while(q.size()){
        int x=q.front();q.pop();
        for(int i=h[x];~i;i=ne[i]){
            int j=e[i];
            if(!dep[j]&&w[i])q.push(j),dep[j]=dep[x]+1;
        }
    }
    return dep[t];
}
int dfs(int x,int v){
    if(x==t||v==0)return v;
    int res=0,f;
    for(int i=h[x];~i;i=ne[i]){
        int j=e[i];
        if(dep[j]==dep[x]+1&&w[i]){
            f=dfs(j,min(v,w[i]));
            w[i]-=f,w[i^1]+=f,res+=f,v-=f;
            if(v==0)break;
        }
    }
    return res;
}
bool spfa(int s,int t){
    memset(dis,0x3f,sizeof dis);dis[s]=0;
    memset(vis,0,sizeof vis);
    memset(flow,0x3f,sizeof flow);pre[t]=-1;
    queue<int>q;q.push(s);vis[s]=1;
    while(q.size()){
        int x=q.front();q.pop();vis[x]=0;
        for(int i=h[x];~i;i=ne[i]){
            int j=e[i];
            if(dis[j]>dis[x]+f[i]&&w[i]){
                dis[j]=dis[x]+f[i],flow[j]=min(flow[x],w[i]);
                pre[j]=x,last[j]=i;
                if(!vis[j])q.push(j),vis[j]=1;
            }
        }
    }
    return pre[t]!=-1;
}
void mcmf(){
    while(spfa(s,t)){
        min_cost+=dis[t]*flow[t];
        int p=t;
        while(p!=s){
            w[last[p]]-=flow[t];
            w[last[p]^1]+=flow[t];
            p=pre[p];
        }
    }
}
int main()
{
    scanf("%d%d%d",&n,&m,&dk);
    memset(h,-1,sizeof h);s=1,t=n;
    for(int i=1;i<=m;i++)scanf("%d%d%d%d",&x[i],&y[i],&z[i],&r[i]),add(x[i],y[i],z[i],0),add(y[i],x[i],0,0);
    int ans=0;
    while(bfs(s,t))ans+=dfs(s,inf);
    s=0;add(s,1,dk,0),add(1,s,0,0);
    for(int i=1;i<=m;i++)add(x[i],y[i],1000000,r[i]),add(y[i],x[i],0,-r[i]);
    mcmf();
    printf("%d %d\n",ans,min_cost);
    return 0;
}

```

---

## 作者：suyiheng (赞：1)

```c++
建图：每一条边输入四个数a,b,c,d。
再建四条边：
a到b,容量为c,费用为0。
b到a,容量为0,费用为0。
a到b,容量为无限,费用为d。
b到a,容量为0,费用为-d。
思路：先根据0费用的边跑一次最大流，再用全图跑一边最大流。
最后贴一下蒟蒻的代码：
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
using namespace std;
struct data{
	int a,b,c,cost;
	data(int a=0,int b=0,int c=0,int cost=0){
		this->a=a;
		this->b=b;
		this->c=c;
		this->cost=cost;
	}
};
vector<data> v;
vector<int> u[1002];
int n,m,f[1002],x,y,z,w,s,ans1,ans2,fa[1002][2],co[1002];
bool r[1002];
void add(int a,int b,int c,int d){
	v.push_back(data(a,b,c,0));
	u[a].push_back(v.size()-1);
	v.push_back(data(b,a,0,0));
	u[b].push_back(v.size()-1);
	v.push_back(data(a,b,10000000,d));
	u[a].push_back(v.size()-1);
	v.push_back(data(b,a,0,-d));
	u[b].push_back(v.size()-1);
}
void bfs(){
	queue<int> q;
	while(1){
		for(int i=0;i<=1001;i++)f[i]=0;
		f[1]=1000000;
	    q.push(1);
		while(!q.empty()){
			x=q.front();
			q.pop();
			for(int i=0;i<u[x].size();i++){
				y=u[x][i];
				data da=v[y];
				if(f[da.b]==0&&da.c>0&&da.cost==0){
					f[da.b]=min(da.c,f[x]);
					q.push(da.b);
					fa[da.b][0]=x;
					fa[da.b][1]=y;
				}
			}
		}
		if(f[n]==0)break;
		for(int i=n;i!=1;i=fa[i][0]){
			v[fa[i][1]].c-=f[n];
			v[fa[i][1]^1].c+=f[n];
		}
		ans1+=f[n];
	}
}
void spfa(){
	queue<int> q;
	q.push(1);
	while(!q.empty()){
		x=q.front();
		q.pop();
		r[x]=false;
		for(int i=0;i<u[x].size();i++){
			y=u[x][i];
			data da=v[y];
			if(co[da.b]>co[x]+da.cost&&da.c){
				f[da.b]=min(da.c,f[x]);
				co[da.b]=co[x]+da.cost;
				fa[da.b][0]=x;
				fa[da.b][1]=y;
				if(!r[da.b]){
					r[da.b]=true;
					q.push(da.b);
				}
			}
		}
	}
}
void dfs(){
	while(1){
		for(int i=0;i<=1001;i++){
			f[i]=0;
			r[i]=false;	
			co[i]=10000000;
		}
		f[1]=10000000;
		co[1]=0;
		spfa();
		if(f[n+1]==0)break;
		for(int i=n+1;i!=1;i=fa[i][0]){
			v[fa[i][1]].c-=f[n+1];
			v[fa[i][1]^1].c+=f[n+1];
		}
		ans2=ans2+f[n+1]*co[n+1];
	}
}
int main(){
	scanf("%d %d %d",&n,&m,&s);
	for(int i=1;i<=m;i++){
		scanf("%d %d %d %d",&x,&y,&z,&w);
		add(x,y,z,w);
	}
	bfs();
	v.push_back(data(n,n+1,s,0));
	u[n].push_back(v.size()-1);
	v.push_back(data(n+1,n,0,0));
	u[n+1].push_back(v.size()-1);
	dfs();
	printf("%d %d",ans1,ans2);
}
```

---

## 作者：MikukuOvO (赞：0)

网路流的建模题，大致思想就是通过拆点，增设虚点和附加边来将题目中的限制条件转换为流量平衡。

第一问无脑最大流，不加赘述。

第二问中提到了费用，不难想到费用流，考虑扩容可以增设附加边来实现，我们将原图中的边复制一遍，容量为$INF$，费用为$w_i$，但是我们仍需满足最终流量为$last+k$这一限制，因此考虑增设超级源点$s$，向一号点连一条流量为$last+k$的边，费用为$0$，这样我们直接套用$MCMF$即可。

给出主函数代码：

```cpp
int main()
{
    fio();
    gi(n),gi(m),gi(k);
    for(int i=1;i<=m;++i)
    {
        gi(x[i]),gi(y[i]),gi(w[i]),gi(c[i]);
        link(x[i],y[i],w[i],0);
    }
    s=1,t=n;
    int res=EK();
    print(res),putchar(' ');
    ms(head);
    s=0,cnt=1,link(s,1,res+k,0);
    for(int i=1;i<=m;++i) link(x[i],y[i],w[i],0),link(x[i],y[i],INF,c[i]);
    MCMF(),print(cost);
    end();
}
```

---

## 作者：吾王美如画 (赞：0)

# 唔姆
这个题可能是我见过的最毒瘤的网络流，乍一看以为是道板子，实际上是两个板子拼起来233333


------------
# 题解
- 第一问，大家直接网络流模板就好了[P3376 【模板】网络最大流](https://www.luogu.org/problemnew/show/P3376)~~放个链接方便大家直接回去看~~
- 第二问，许多大佬一眼就看出来了这就是个费用流~~题目里都明示了~~，但是具体怎么设费用和流量呢？这时我们就可以用到之前求最大流的残余网络。如果我们要扩充k个流量，那我们肯定尽量利用之前剩下的流量，因为这些流量不耗钱(~~啥？流量不要钱？？~~)。所以在第一问是我们在连边时就应该把原有边的费用置为0、
- 接下来，我们在所以原有边的基础上加上一条容量为INF（其实用k也没毛病）费用为w[i]的边，用于扩充。
- 最后，别忘了设个超源，向1号点连个容量为k费用为0的边，用于限制扩充数量。

最后上代码咯！~~我真的是把两个模板拼起来的，所以代码巨丑~~
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
#define MAXN 10005
#define MAXM 15000
using namespace std;
int head[MAXN],next[MAXM*2],to[MAXM*2],w[MAXM*2],cost[MAXM*2],cur[MAXN];
int n,m,S,T,K;
int cnt=-1;
int deep[MAXN];
int pre1[MAXN],pre2[MAXN],low[MAXN],dis[MAXN],ansc=0;
void link(int a,int b,int c,int d){
     cnt++;
     next[cnt]=head[a];
     w[cnt]=c;
     cost[cnt]=d;
     to[cnt]=b;
     head[a]=cnt;
     cnt++;
     next[cnt]=head[b];
     w[cnt]=0;
     cost[cnt]=-d;
     to[cnt]=a;
     head[b]=cnt;
}
bool bfs(){
     memset(deep,0,sizeof(deep));
     queue<int> q;
     while(!q.empty())q.pop();
     q.push(S);
     deep[S]=1;
     while(!q.empty()){
                       int now=q.front();
                       q.pop();
                       for(int i=head[now];i!=-1;i=next[i]){
                               if (w[i]&&!deep[to[i]]){
                                                       deep[to[i]]=deep[now]+1;
                                                       q.push(to[i]);
                               }
                       }
     }
     if (deep[T])return 1;else return 0;
}
int dinic(int now,int last){
    if (now==T||!last)return last;
    int ret=0;
    for(int i=cur[now];i!=-1;i=next[i]){
            if(deep[to[i]]-1==deep[now]&&w[i]){
                                               int zgl=dinic(to[i],min(w[i],last-ret));
                                               if (zgl){
                                                        w[i]-=zgl;
                                                        w[i^1]+=zgl;     
                                                        ret+=zgl;
                                               }
            }
            cur[now]=i;
    }
    return ret;
}
bool spfa(){
     queue<int>q;
     fill(dis,dis+MAXN-1,66666666);
     int vis[MAXN];
     memset(vis,0,sizeof(vis));
     q.push(S);
     dis[S]=0;
     vis[S]=1;
     low[S]=66666666;
     while(!q.empty()){
                       int now=q.front();
                       vis[now]=0;
                       q.pop();
                       for(int i=head[now];i!=-1;i=next[i]){
                               if (w[i]>0&&cost[i]+dis[now]<dis[to[i]]){
                                                                        dis[to[i]]=dis[now]+cost[i];
                                                                        low[to[i]]=min(low[now],w[i]);
                                                                        pre1[to[i]]=now;
                                                                        pre2[to[i]]=i;
                                                                        if (!vis[to[i]]){
                                                                                         vis[to[i]]=1;
                                                                                         q.push(to[i]);
                                                                        }
                               }
                       }
     }
     return dis[T]!=66666666;
}
void work(){
     while(spfa()){
                   int now=T;
                   while(now!=S){
                                 int y=pre2[now];
                                 w[y]-=low[T];
                                 w[y^1]+=low[T];
                                 now=pre1[now];
                   }
                   ansc+=low[T]*dis[T];
     }
}
int main(){
    cin>>n>>m>>K;
    S=1;T=n;
    memset(head,-1,sizeof(head));
    int a[MAXM],b[MAXM],c[MAXM],d[MAXM];
    for(int i=1;i<=m;i++){
            scanf("%d%d%d%d",&a[i],&b[i],&c[i],&d[i]);
            link(a[i],b[i],c[i],0);
    }
    int ans=0;
    while(bfs()){
                 memcpy(cur,head,sizeof(cur));
                 ans+=dinic(S,9999999);
    }
    cout<<ans<<" ";
    for(int i=1;i<=m;i++){
            link(a[i],b[i],K,d[i]);
    }
    S=0;link(S,1,K,0);
    work();
    cout<<ansc;
    return 0;
}

```

---

## 作者：arfa (赞：0)

实话说:

这题是 $ZJOI$ 的很不正常


此题是贼容易想的,第一问无脑的跑一遍最大流或者费用流,随便你。第二问要求我们把流量变为 $k+\max flow$ (其中 $\max flow$ 为上一次的最大流)。我们可以搞一个这样的机制:

- 我原本有流量 $flow[i]$,这些流量是不用钱的
- 我现在要扩充一些,最多扩充到 $\max longint$,这些流量每一个流需要 $cost[i]$

连两次边就好啦...

- $add(l[i],r[i],f[i],0);$
- $add(l[i],r[i],maxlongint,c[i]);$

最后你建立一个第二汇点,让汇点连第二汇点,流量为 $k+\max flow$ 就好啦。

```pascal
// luogu-judger-enable-o2
Uses math;

var
    from,reach,next,value,cost:array[-1..50010] of longint;
    dis,pre,last,flow:array[-1..50010] of int64;
    queue:array[-1..50010] of longint;
    cnt:array[-1..8100] of longint;
    vis:array[-1..8100] of boolean;
    l,r,c,f:array[-1..51000] of longint;
    n,m,i,j,k,tot,now,sink,source:longint;
    maxflow,mincost:int64;

procedure add(x,y,sum_1,sum_2:longint);
begin
    inc(tot); from[tot]:=x; reach[tot]:=y; value[tot]:=sum_1; cost[tot]:= sum_2; next[tot]:=cnt[x]; cnt[x]:=tot;
    inc(tot); from[tot]:=y; reach[tot]:=x; value[tot]:=0    ; cost[tot]:=-sum_2; next[tot]:=cnt[y]; cnt[y]:=tot;
end;

function spfa:boolean;
var head,tail,now,i:longint;
begin
    filldword(dis,sizeof(dis) div 4,maxlongint);
    filldword(flow,sizeof(flow) div 4,maxlongint);
    filldword(vis,sizeof(vis) div 4,0);
    head:=1; tail:=1; queue[1]:=source; vis[source]:=True; dis[source]:=0; pre[sink]:=-1;
    while head<=tail do
    begin
        now:=queue[head]; vis[now]:=False; inc(head);
        i:=cnt[now];
        while i<>-1 do
        begin
            if (value[i]>0)and(dis[reach[i]]>dis[now]+cost[i]) then
            begin
                dis[reach[i]]:=dis[now]+cost[i];
                pre[reach[i]]:=now;
                last[reach[i]]:=i;
                flow[reach[i]]:=min(flow[now],value[i]);
                if vis[reach[i]]=False then
                begin
                    vis[reach[i]]:=True;
                    inc(tail); queue[tail]:=reach[i];
                end;
            end;
            i:=next[i];
        end;
    end;
    if pre[sink]=-1 then exit(False); exit(True);
end;

procedure MincostMaxflow;
begin
    maxflow:=0; mincost:=0; now:=0;
    while (spfa) do
    begin
        now:=sink;
        inc(maxflow,flow[sink]);
        inc(mincost,flow[sink]*dis[sink]);
        while now<>source do
        begin
            dec(value[last[now]],flow[sink]);
            inc(value[last[now] xor 1],flow[sink]);
            now:=pre[now];
        end;
    end;
end;

procedure Construction_I;
begin
    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1); tot:=1;
    fillchar(value,sizeof(value),0);
    fillchar(reach,sizeof(reach),0);
    fillchar(cost,sizeof(cost),0);
    fillchar(next,sizeof(next),0);
    read(n,m,k); source:=1; sink:=n;
    for i:=1 to m do begin read(l[i],r[i],f[i],c[i]); add(l[i],r[i],f[i],0); end;
    MincostMaxflow; write(maxflow,' ');

    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1); tot:=1;
    fillchar(value,sizeof(value),0);
    fillchar(reach,sizeof(reach),0);
    fillchar(cost,sizeof(cost),0);
    fillchar(next,sizeof(next),0);
   	for i:=1 to m do
    begin
    	add(l[i],r[i],f[i],0);
        add(l[i],r[i],maxlongint,c[i]);
    end;
   	inc(sink); add(sink-1,sink,maxflow+k,0);
   	MincostMaxflow; write(mincost);
end;


begin
    Construction_I;
end.
```

---

## 作者：ddwqwq (赞：0)

好久没写题解了，刚好在本题发明了一个歪门邪道的蹩脚解法，就来发一个。  
我的思路：首先按输入建图，求最大流F。接着推倒重建，把原图的每一条边建为两条，分别是{u,v,c,0}和{u,v,INF,w}。这样一来，从s到t的最大流会变为INF。然后写一个函数，每次沿着最短路增广一条边。只要把该函数运行（F+K）次，费用之和即为第二问答案。  
理论上来说，这个办法既蠢且慢，与其他题解的办法不在一个档次上。但是，由于数据比较水，还是可以非常安全的通过本题。  
下面是代码，同样是四不像的蹩脚货色：spfa寻路的EK，混乱的建图等等，惨不忍睹。
```
#include <cstdlib>
#include <iostream>
#include <cstdio>
#include <math.h>
#include <cstring>
#include <time.h>
#include <utility>

#pragma warning(disable:4996)
#define INF 2000000005//2 * 10^9
#define lowbit(a) ((a)&-(a))
inline long long max(long long a, long long b)
{
	return a>b ? a : b;
}
inline long long min(long long a, long long b)
{
	return a<b ? a : b;
}

const int MAXN = 1005;

struct node {
	int to;
	int cp;
	int w;
	node *next;
};

int c[100000], bak[100000], cs;

void add(node *&head, int to, int C, int w)
{
	node *p = new(node);
	p->to = to;
	p->cp = cs;
	c[cs++] = C;
	p->w = w;
	p->next = head;
	head = p;
}

node *edge[MAXN];
int d[MAXN], f[MAXN];
node *path[MAXN];

void addedge(int u, int v, int c, int w)
{
	add(edge[u], v, c, w);
	add(edge[v], u, 0, -w);
}

bool relax(int v, node *p)
{
	if (c[p->cp] && d[p->to] > d[v] + p->w)
	{
		d[p->to] = d[v] + p->w;
		f[p->to] = v;
		path[p->to] = p;
		return true;
	}
	return false;
}

int q[100000], k;
bool inq[MAXN];

void prepare(int s)
{
	k = 0;
	for (int i = 0; i < MAXN; i++)
		d[i] = INF;
	memset(inq, 0, sizeof(inq));
	d[s] = 0;
	q[k++] = s;
	inq[s] = true;
}

void spfa(int s)
{
	int i;

	prepare(s);
	for (i = 0; i < k; i++)
	{
		int v = q[i];
		inq[v] = false;
		for (node *p = edge[v]; p; p = p->next)
			if (relax(v, p) && !inq[p->to])
			{
				q[k++] = p->to;
				inq[p->to] = true;
			}
	}
}

int flow(int s, int v, int lim)
{
	if (s == v)
		return lim;
	int t = flow(s, f[v], min(lim, c[path[v]->cp]));
	c[path[v]->cp] -= t;
	c[path[v]->cp ^ 1] += t;
	return t;
}

int max_flow(int s, int t)//古怪的EK
{
	int ans = 0;
	while (1)
	{
		spfa(s);
		if (d[t] == INF)
			break;
		ans += flow(s, t, INF);
	}
	return ans;
}

int get_cost(int s, int v)
{
	if (v == s)
		return 0;
	c[path[v]->cp] -= 1;
	c[path[v]->cp ^ 1] += 1;
	return get_cost(s, f[v]) + path[v]->w;
}

int expand(int s, int t)//増广一单位的路径
{
	spfa(s);
	return get_cost(s, t);
}

int M, N, K;
node *edge2[MAXN];

int main()
{
	int i, j, u, v, C, w;

	scanf("%d %d %d", &N, &M, &K);

	for (i = 0; i < M; i++)
	{
		scanf("%d %d %d %d", &u, &v, &C, &w);
		addedge(u, v, C, w);
	}
	memcpy(bak, c, sizeof(bak));

	int cost = 0;
	int fl = max_flow(1, N);//第一问
	memcpy(c, bak, sizeof(c));

	for (i = 1; i <= N; i++)
		for (node *p = edge[i]; p; p = p->next)
			if (p->w > 0)
			{
				addedge(i, p->to, INF, p->w);
				addedge(i, p->to, c[p->cp], 0);
			}

	for (i = 0; i < fl + K; i++)
		cost += expand(1, N);//第二问

	printf("%d %d", fl, cost);

	system("pause");
	return 0;
}
```

---

## 作者：秋日私语 (赞：0)

题目
=

[传送门](https://www.luogu.org/problemnew/show/P2604)

题解
=

第一问最大流，在建图的过程中把费用设为0
第二问把边重新再原图上连一遍，容量为inf（实际上为k就可以），费用为输入，设置新的源点向原来的源点之间连边，容量为k、费用为0；这样再跑最小费用最大流的时候就会优先经过残留网络的边（因为其费用为0）因此求出来的就是最小扩容费用。

代码
=

点[这里](http://blog.csdn.net/A_Comme_Amour/article/details/79642929)

总结
=

注意逆向思维；
总结残余网络的应用，可以搞一些事情——输出方案，在原图中加边、求最小扩容费用等

---

## 作者：magolor (赞：0)

网络流加费用流，楼下神犇题解（SAP）说明很清楚。

补充两点：新边容量不用INF，K就够了；其实不需要把ABCW存下来，只存W就够了，具体建图见代码main函数。

代码中使用Dinic和SPFAMCMF，各自三个函数。


哦，实测，**点数是5000而不是1000！点数是5000！！！**









    


        



        


```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 5000
#define MAXM 80000
#define MEMINF 0x3f
#define INF 0x3f3f3f3f 
struct Edge
{
    int to,nex,c,w;
    Edge(){}
    Edge(int _to, int _nex, int _c, int _w):to(_to),nex(_nex),c(_c),w(_w){}    
};
Edge e[MAXM+5];
int first[MAXN+5], q[MAXN+5], dis[MAXN+5], pre[MAXN+5], level[MAXN+5], cur[MAXN+5], W[MAXN+5], tot, S, T, N, M, K, ANSF, ANSC;
bool book[MAXN+5];
inline void Add(int a, int b, int c, int w)
{
    e[tot] = Edge(b,first[a],c,w);
    first[a] = tot++;
    e[tot] = Edge(a,first[b],0,-w);
    first[b] = tot++;
    return; 
}
// Dinic
inline bool BFS()
{
    memset(level,0,sizeof(level));
    q[0] = S, level[S] = 1;
    for(register int head = 0, tail = 1, t, u; head != tail; )
        for(t = q[head++], head %= MAXN, u = first[t]; u+1; u = e[u].nex)
            if(e[u].c > 0 && !level[e[u].to])
            {
                level[e[u].to] = level[t] + 1;
                q[tail++] = e[u].to, tail %= MAXN;
                if(e[u].to == T)
                    return true;
            }
    return false;
}
int DFS(int p, int f)
{
    if(p == T)
        return f;
    int tag = 0;
    for(int &u = cur[p], del; u+1; u = e[u].nex)
        if(e[u].c > 0 && level[e[u].to] == level[p]+1)
        {
            del = DFS(e[u].to,min(e[u].c,f-tag));
            e[u].c -= del, e[u^1].c += del, tag += del;
            if(tag == f)
                return tag; 
        }
    return tag;
}
void Dinic()
{
    for(register int i; BFS(); ANSF += DFS(S,INF))
        for(i = 0; i <= N; i++)
            cur[i] = first[i];
    return;
}
// MCMF
inline bool SPFA()
{
    memset(dis,MEMINF,sizeof(dis));    
    q[0] = S, dis[S] = 0, book[S] = true;
    for(register int head = 0, tail = 1, t, u; head != tail; book[t] = false)
        for(t = q[head++], head %= MAXN, u = first[t]; u+1; u = e[u].nex)
            if(e[u].c > 0 && dis[e[u].to] > dis[t] + e[u].w)
            {
                dis[e[u].to] = dis[t] + e[u].w, pre[e[u].to] = u;
                if(!book[e[u].to])
                    book[e[u].to] = true, q[tail++] = e[u].to, tail %= MAXN; 
            }
    return dis[T] != INF;
}
inline void CALC()
{
    int del = INF, cost = 0;
    for(register int p = T, u = pre[p]; p != S; p = e[u^1].to, u = pre[p])
        del = min(del,e[u].c);
    for(register int p = T, u = pre[p]; p != S; p = e[u^1].to, u = pre[p])
        e[u].c -= del, e[u^1].c += del, cost += del*e[u].w;
    ANSC += cost;
    return;
}
inline void MCMF()
{
    for(; SPFA(); CALC());
    return;
}
int main()
{
    scanf("%d%d%d",&N,&M,&K), S = 1, T = N, memset(first,-1,sizeof(first));
    for(int i = 1, a, b, c; i <= M; i++)
        scanf("%d%d%d%d",&a,&b,&c,W+i), Add(a,b,c,0);
    Dinic(), printf("%d ",ANSF);
    for(register int i = 0, j = 1; j <= M; i += 2, j++)
        Add(e[i^1].to,e[i].to,K,W[j]);
    S = 0, Add(0,1,K,0), MCMF(), printf("%d\n",ANSC);
     return 0;
}
```

---

## 作者：Jason_Yvan (赞：0)

最小费用最大流

我用的是dinic + MCMF

ISAP快一些，但一般dinic就足够了

下面看c++代码：

/*************************************************************************

    > Author: wzw-cnyali
    > Created Time: 2017/2/11 14:44:28
************************************************************************/



















```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
#define REP(i, a, b) for(register int i = (a), i##_end_ = (b); i <= i##_end_; ++ i)
#define DREP(i, a, b) for(register int i = (a), i##_end_ = (b); i >= i##_end_; -- i)
#define mem(a, b) memset((a), b, sizeof(a))
const int Size = 100010;
const int inf = 0x3f3f3f3f;
int read()
{
    int sum = 0, fg = 1; char c = getchar();
    while(c < '0' || c > '9') { if (c == '-') fg = -1; c = getchar(); }
    while(c >= '0' && c <= '9') { sum = sum * 10 + c - '0'; c = getchar(); }
    return sum * fg;
}
int to[Size], be[Size], nxt[Size], c[Size], w[Size], e;
struct node{
    int x, y, c, w;
}edge[Size];
void add(int x, int y, int z, int v)
{
    to[e] = y;
    nxt[e] = be[x];
    be[x] = e;
    c[e] = z;
    w[e] = v;
    e++;
}
int dis[Size];
int Start, End;
int bfs()
{
    queue <int> q;
    mem(dis, -1);
    dis[End] = 0;
    q.push(End);
    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        for(int i = be[u]; ~i; i = nxt[i])
        {
            int v = to[i];
            if(dis[v] == -1 && c[i ^ 1])
            {
                dis[v] = dis[u] + 1;
                q.push(v);
            }
        }
    }
    return ~dis[Start];
}
int find_max_flow(int x, int low)
{
    if(x == End) return low;
    int k;
    for(int i = be[x]; ~i; i = nxt[i])
    {
        int y = to[i];
        if(dis[y] == dis[x] - 1 && c[i] && (k = find_max_flow(y, min(low, c[i]))))
        {
            c[i] -= k;
            c[i ^ 1] += k;
            return k;
        }
    }
    return 0;
}
int dinic()
{
    int k, ans = 0;
    while(bfs())
    {
        while((k = find_max_flow(Start, inf)))
        {
            ans += k;
        }
    }
    return ans;
}
int pre[Size];
int vis[Size], num[Size];
int spfa()
{
    queue <int> q;
    mem(dis, inf);
    mem(pre, -1);
    mem(vis, 0);
    q.push(Start);
    vis[Start] = 1;
    dis[Start] = 0;
    while(!q.empty())
    {
        int x = q.front();
        vis[x] = 0;
        q.pop();
        for(int i = be[x]; ~i; i = nxt[i])
        {
            int y = to[i];
            if(c[i])
            {
                if(dis[y] > dis[x] + w[i])
                {
                    dis[y] = dis[x] + w[i];
                    pre[y] = x;
                    num[y] = i;
                    if(!vis[y])
                    {
                        q.push(y);
                        vis[y] = 1;
                    }
                }
            }
        }
    }
    return dis[End] < inf;
}
int calc(int k)
{
    int sum = 0, flow = k;
    for(int i = End; ~pre[i]; i = pre[i])
    {
        flow = min(flow, c[num[i]]);
    }
    for(int i = End; ~pre[i]; i = pre[i])
    {
        sum += w[num[i]] * flow;
        c[num[i]] -= flow;
        c[num[i] ^ 1] += flow;
    }
    return sum;
}
int min_flow(int k)
{
    int ans = 0;
    while(spfa())
    {
        ans += calc(k);
    }
    return ans;
}
void init()
{
    mem(be, -1);
    e = 0;
}
int main()
{
    init();
    int n = read(), m = read(), k = read();
    Start = 1, End = n;
    REP(i, 1, m)
    {
        edge[i].x = read(), edge[i].y = read(), edge[i].c = read(), edge[i].w = read();
        add(edge[i].x, edge[i].y, edge[i].c, 0);
        add(edge[i].y, edge[i].x, 0, 0);
    }
    printf("%d ", dinic());
    REP(i, 1, m)
    {
        add(edge[i].x, edge[i].y, inf, edge[i].w);
        add(edge[i].y, edge[i].x, 0, -edge[i].w);
    }
    Start = n + 1;
    add(Start, 1, k, 0);
    printf("%d\n", min_flow(k));
    return 0;
}

```

---


# [NOI2009] 植物大战僵尸

## 题目背景

Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和 Zombies（僵尸）是游戏的主角，其中 Plants 防守，而 Zombies 进攻。该款游戏包含多种不同的挑战系列，比如 Protect Your Brain、Bowling 等等。其中最为经典的，莫过于玩家通过控制 Plants 来防守 Zombies 的进攻，或者相反地由玩家通过控制 Zombies 对 Plants 发起进攻。



## 题目描述

现在，我们将要考虑的问题是游戏中 Zombies 对 Plants 的进攻，请注意，本题中规则与实际游戏**有所不同**。游戏中有两种角色，Plants 和 Zombies，每个 Plant 有一个攻击位置集合，它可以对这些位置进行保护；而 Zombie 进攻植物的方式是走到植物所在的位置上并将其吃掉。

游戏的地图可以抽象为一个 $N$ 行 $M$ 列的矩阵，行从上到下用 $0$ 到 $N–1$ 编号，列从左到右用 $0$ 到 $M–1$ 编号；在地图的每个位置上都放有一个 $Plant$，为简单起见，我们把位于第 $r$ 行第 $c$ 列的植物记为 $P_{r, c}$。

Plants 分很多种，有「攻击类」「防守类」和「经济类」等等。为了简单的描述每个 Plant，定义 $\operatorname{Score}$ 和 $\operatorname{Attack}$ 如下：

* $\operatorname{Score}(P_{r, c})$ — Zombie 击溃植物 $P_{r, c}$ 可获得的能源。   
若 $\operatorname{Score}(P_{r, c})$ 为非负整数，则表示击溃植物 $P_{r, c}$ 可获得能源 $\operatorname{Score}(P_{r, c})$，若为负数表示击溃 $P_{r, c}$ 需要付出能源 $-\operatorname{Score}(P_{r, c})$。

* $\operatorname{Attack}(P_{r, c})$ — 植物 $P_{r, c}$ 能够对 Zombie 进行攻击的位置集合。

Zombies 必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies 攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此 Zombies 的进攻总是从地图的右侧开始。也就是说，对于第 $r$ 行的进攻，Zombies 必须首先攻击 $P_{r, M-1}$；若需要对 $P_{r, c}$（$0 \le c < m - 1$）攻击，必须将 $P_{r,M-1}, P_{r, M-2} \cdots P_{r, c+1}$ 先击溃，并移动到位置 $(r, c)$ 才可进行攻击。

在本题的设定中，Plants 的攻击力是无穷大的，一旦 Zombie 进入某个 Plant 的攻击位置，该 Zombie 会被瞬间消灭，而该 Zombie 没有时间进行任何攻击操作。因此，即便 Zombie 进入了一个 Plant 所在的位置，但该位置属于其他植物的攻击位置集合，则 Zombie 会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant 的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。

Zombies 的目标是对 Plants 的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套 Zombies 的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。

## 说明/提示

#### 数据规模与约定
- 对于 $20\%$ 的数据，保证 $ N, M \le 5$。
- 对于 $40\%$ 的数据，保证 $ N, M \le 10$。
- 对于 $100\%$ 的数据，保证 $1 \le N \le 20$，$1 \le M \le 30$，$-10^4 ≤ \operatorname{Score} \le 10^4$。

#### 说明
题面由 @syksykCCC 修改。

## 样例 #1

### 输入

```
3 2
10 0
20 0
-10 0
-5 1 0 0
100 1 2 1
100 0```

### 输出

```
25```

# 题解

## 作者：longlongzhu123 (赞：97)

# 解法：网络流 - 最大权闭合子图 $\times$ 拓扑排序

感觉大家的题解都没有讲得很清楚呢。

鉴于大家可能会以这道题作为 **最大权闭合子图** 的入门题，我就在这里给大家讲一些有关的概念，帮助大家快速入门吧！

- 如果你早就知道最大权闭合子图是什么，请直接翻到**题目分析** QwQ
- 如果你是很强很强的大佬，请直接翻到下一篇题解 QwQ

# 最大权闭合子图::概念

什么是 **闭合子图** ？

1. 它是一种子图 （逃
2. 它还是有向图的子图。。
3. 它还可以一路走到底，不撞南墙不回头。。。

具体来说，就是：对于每个点，从它出发，**能够走到的所有点都属于闭合子图中**

举个栗子，对于下面这张图， $\{b, c, d\}$ 、 $\{b, d\}$ 都是它的闭合子图。但是 $\{a, b, d\}$ 却不是，因为从 a 可以走到 c ， c 却不在 $\{a, b, d\}$ 中。

![](https://cdn.luogu.com.cn/upload/pic/47002.png)

> $\text{形式化地（如果你想看的话），若} G'(V', E') \text{是} G(V, E) \text{的一个闭合子图，那么：}$

> 1. $V' \in V, E' \in E$

> 1. $\forall (u, v) \in E, \text{都有} u \in V' \text{ 且 } v \in V'$

最大权闭合子图就是原图中点权和最大的闭合子图。

这个模型有什么用呢？待我慢慢道来。

# 最大权闭合子图::实现

最大权闭合子图问题可以使用**最小割**解决OVO！。

#### 连边方式

- 对于所有原图中的边 $(u, v)$ ，连边 $u \rightarrow v$ ，容量为 $INF$ 。
- 对于每个原图中的点 $u$ ，设 $u$ 的权值为 $val[u]$ ：
  1. 若 $val[u] > 0$ （正权点），连边 $S \rightarrow u$ ，容量为 $val[u]$ 。
  2. 若 $val[u] < 0$ （负权点），连边 $u \rightarrow T$ ，容量为 $-val[u]$ 。

至于 $val[u] = 0$ （零权点）的情况，向 $S$ 还是 $T$ 连边对答案并没有影响（见下解释），所以可以不做特判。

如图所示，右边是原图，网络流连边如左图所示。

![](https://cdn.luogu.com.cn/upload/pic/47103.png)

直接在图上跑最小割即可，最大权 = 正点权和 - 最小割 ，而最大权闭合子图的节点就是与 $S$ 联通的部分。

为什么这样建模是正确的呢？让我们分析一下：

> 首先，所有不连向 $S$ 或 $T$ 的边容量都是 $INF$ ，不可能被割掉。

> 这样，能被割掉的边只有连向 $S$ 或 $T$ 的边（这样的割被称为 **简单割** ）。

> 设与 $S$ 联通的节点集为 $X$ ，与 $T$ 联通的节点集为 $Y$ ，那么最大权闭合子图的节点就是 $X$ 集。

> 一开始假设所有正权点都在（最大权）闭合子图中，

> 对于某一个正权点 $u$ ，如果割掉它与 $S$ 的连边，意味着将它分到 $Y$ 集合中，不选它作为闭合子图的节点，故闭合子图权值应减去 $val[u]$ 。

> 对于某一个负权点 $u$ ，如果割掉它与 $T$ 的连边，意味着将它分到 $X$ 集合中，那么闭合子图权值应加上 $val[u]$ ，即减去 $-val[u]$。

如下图所示，假设这是网络图中的一条路径：

![](https://cdn.luogu.com.cn/upload/pic/47138.png)

这个图有两种割法，其中割掉蓝色的边花费最小，需要付出 1 的费用。

故这个图中闭合子图的最大权值是 $2 - 1 = 1$ 。

![](https://cdn.luogu.com.cn/upload/pic/47139.png)

这题跟 **最大权闭合子图** 有什么关系呢？想必大家已经能够发现一些规律了！

# 题目分析

#### 规律：

我们看一下题目描述：

```
对于第r行的进攻，Zombies必须首先攻击Pr, M-1；若需要对Pr, c（0≤c<M-1）攻击，必须将Pr,M-1, Pr, M-2 … Pr, c+1先击溃，并移动到位置(r, c)才可进行攻击。
```

```
即便Zombie进入了一个Plant所在的位置，但该位置属于其他植物的攻击位置集合，则Zombie会被瞬间消灭而所在位置的植物则安然无恙
```

题目描述暗示着： **如果你要攻击植物 $i$ ，那么你就必须把 $i$ 的右边一棵植物、以及保护着它的所有植物都一起攻击掉** 。

这与最大权闭合子图中 **对于每个点，从它出发，能够走到的所有点都属于闭合子图中** 刚好契合。

我们可以这样建图：

1. 植物 $i$ 的点权设为 $val[i]$
2. 所有植物 $i$ 向它的右边连边
3. 如果一个植物 $j$ 保护着 $i$ ， $i$ 向 $j$ 连边

在这个图上求出最大权闭合子图，答案就是最大收益，也就是问题的答案。

# 一个问题

等等，如果你直接写出代码，你会发现你只能拿到可怜的分数（甚至连样例都过不了）

我们漏了一种情况，如果两棵植物互相保护（环），那么僵尸无论如何都无法攻击到它们。

![](https://cdn.luogu.com.cn/upload/pic/47142.png)

（上面这个图展示的是节点之间的保护关系，事实上在网络图中，边刚好相反）

同理，被环所保护的节点也无法被攻击到。

所有出现在环中以及被环保护的节点都应该被去除。我们可以先建一个反向图（这里是指相对于网络图的反向图），并进行拓扑排序，能够被拓扑排序遍历到的节点才能用来建图。

讲到这里，问题终于解决了！

# 代码

激动人心的代码时刻！（假的，写得超丑 2333 ）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define POINT(X, Y)  ((X) * 31 + (Y))
const int MAXN = POINT(30, 30) + 10;
const int INF = 2000000000;
const int MAXM = MAXN * MAXN + 10;
struct Graph {
	struct Node {
		int to, cap;
		int next;
	} node[MAXM * 2];
	int top, head[MAXN];
	Graph() {
		top = 1;
	}
	void add(int u, int v, int cap) {
		top ++;
		node[top].to = v;
		node[top].cap = cap;
		node[top].next = head[u];
		head[u] = top;
		top ++;
		node[top].to = u;
		node[top].cap = 0;
		node[top].next = head[v];
		head[v] = top;
	}
	queue<int> Q;
	int dis[MAXN];
	int s, t;
	bool bfs() {
		memset(dis, -1, sizeof(dis));
		dis[s] = 0;
		Q.push(s);
		while(!Q.empty()) {
			int u = Q.front();
			Q.pop();
			for(int i = head[u]; i; i = node[i].next) {
				int v = node[i].to;
				if(dis[v] == -1 && node[i].cap) {
					dis[v] = dis[u] + 1;
					Q.push(v);
				}
			}
		}
		return dis[t] != -1;
	}
	int dfs(int u, int flow) {
		if(u == t)
			return flow;
		else {
			int ret = flow;
			for(int i = head[u]; i && ret; i = node[i].next) {
				int v = node[i].to;
				if(dis[v] == dis[u] + 1 && node[i].cap) {
					int k = dfs(v, min(ret, node[i].cap));
					node[i].cap -= k;
					node[i ^ 1].cap += k;
					ret -= k;
				}
			}
			if(ret == flow)
				dis[u] = -1;
			return flow - ret;
		}
	}
	int dinic() {
		int ans = 0;
		while(bfs())
			ans += dfs(s, INF);
		return ans;
	}
} G;
int n, m;
int score[MAXN];
vector<int> out[MAXN];
int in[MAXN];
bool vis[MAXN];
queue<int> Q;
void toposort() {
	for(int i = 1; i <= n; i ++) {
		for(int j = 1; j <= m; j ++) {
			if(!in[POINT(i, j)]) {
				Q.push(POINT(i, j));
				vis[POINT(i, j)] = true;
			}
		}
	}
	while(!Q.empty()) {
		int u = Q.front();
		Q.pop();
		for(int i = 0; i < out[u].size(); i ++) {
			int v = out[u][i];
			in[v] --;
			if(!vis[v] && !in[v]) {
				Q.push(v);
				vis[v] = true;
			}
		}
	}
}
int main() {
	cin>>n>>m;
	for(int i = 1; i <= n; i ++) {
		for(int j = 1; j <= m; j ++) {
			int cnt;  //  保护植物的棵数
			cin>>score[POINT(i, j)]>>cnt;
			for(int k = 1; k <= cnt; k ++) {
				int x, y;
				cin>>x>>y;
				//  POINT(i, j) <- POINT(x, y)
				x ++;
				y ++;
				out[POINT(i, j)].push_back(POINT(x, y));
				in[POINT(x, y)] ++;
			}
			if(j < m) {
				out[POINT(i, j + 1)].push_back(POINT(i, j));
				in[POINT(i, j)] ++;
			}
		}
	}
	toposort();
	G.s = MAXN - 1;
	G.t = MAXN - 2;
	int sum = 0;
	for(int i = 1; i <= n; i ++) {
		for(int j = 1; j <= m; j ++) {
			int u = POINT(i, j);
			if(!vis[u])
				continue;
			if(score[u] >= 0) {
				G.add(G.s, u, score[u]);
				sum += score[u];
				// printf("S -> [%d, %d] : %d\n", i, j, score[u]);
			}
			else {
				G.add(u, G.t, -score[u]);
				// printf("[%d, %d] -> T : %d\n", i, j, -score[u]);
			}
			for(int k = 0; k < out[u].size(); k ++) {
				int v = out[u][k];
				if(vis[v]) {
					G.add(v, u, INF);
					// printf("[%d, %d] -> [%d, %d] : INF\n", v / 31, v % 31, i, j);
				}
			}
		}
	}
	cout<<sum - G.dinic()<<endl;
	return 0;
}
```

内容会陆续搬运到博客里......

---

## 作者：Freddie (赞：19)

# 算法思想概述

本题是一道最大权闭合子图模型，应用的算法为最大流(BFS增广即可)，定理为最大流最小割定理，辅助算法为拓扑排序。


------------

# 问题初始建模

首先我们我建立图论模型，把每个植物当做一个顶点，植物携带的资源数目为顶点的权值。如果一个植物b在另一个植物a的攻击范围内，连接一条有向边<a,b>，表示a可以保护b。由于僵尸从右向左进攻，可以认为每个植物都被它右边相邻的植物保护，对于每个植物a（除最左边一列），向其左边的相邻植物b，连接一条有向边<a,b>。



###   1.使用拓扑排序去除图中的环，从而使图得到简化。
由本题样例就可以发现，有一些植物是相互依赖的，于是我们可以进行算法实现的第一步：

- 1.就是搜一遍入度为零的加入队列。
- 2.把队列中的植物取出来，找到这个植物保护的点入度减一，减到零就入列。重复这一步。最后访问到的就是没有在环内的。

 ###  2.对第一步中得到的图进行转置操作(把所有边反向)，从而得到最大子权闭合图。


![](http://www.lydshy.com:3389/wordpress/wp-content/uploads/2016/08/e462b012986ea203f819b8b9.png)

   其中最大权闭合子图为(1,2,4) 

下面进行算法实现的第3、4步：

### 3.最大权闭合子图的网络流建模：

- 1.建立附加源S和附加汇T。

- 2.图中原有的转置后的边容量设为∞。

- 3.从S向每个权值为正的点连接一条容量为该点权值的有向边。

- 4.从每个权值不为正的点向T连接一条容量为该点权值绝对值的有向边。

####    建边后图如下：

![](http://www.lydshy.com:3389/wordpress/wp-content/uploads/2016/08/fe0e3951d56c944a367abeb9-130x300.png)

### 4.求解：
   求S到T的最大流Maxflow，最大权闭合子图的权值就是(所有正权点权值之和 – Maxflow)，也就是需要输出的答案。因为我们要吃一个植物，就要吃掉保护它的植物，而在最大流中的意义就是你要流过**s->一个植物**，就要流过**保护它的植物->t**。
    
我们可以这样想，当我们**从s到t的一条路**上 得到了**Ws** 花费了**min(Ws,Wt）**,如果**Wt>Ws** 得到收益为 **Ws - Ws = 0**（相当于不走）;如果**Wt<Ws**,收益为**Ws - Wt**。

   而**所有正权点权值之和**就是
   $\begin{matrix}\underbrace{Ws1+Ws2+\cdots+Wsn}\\n\end{matrix}=\sum\limits_{i=1}^nW_i$    ，
   而**S到T的最大流Maxflow**就是
  $\begin{matrix}\underbrace{min(Wt1,Ws1)+min(Wt2,Ws2)+\cdots+min(Wtn,Wsn)}\\n\end{matrix}=\sum\limits_{i=1}^nmin(Wti,Wsi)$    
$ $
 也就是答案    $  \sum\limits_{i=1}^nW_i-\sum\limits_{i=1}^nmin(Wti,Wsi) =$  sum-dinic()
 
 
   

------------

   
# Coding
   
```cpp
#include<bits/stdc++.h>
#define POINT(X, Y)  ((X) * 31 + (Y))
using namespace std;
const int MAXN = POINT(30,30)+10;
const int INF = 1<<28;

int read(){
    int flag=1,sum=0;char c;
    for(;c>'9'||c<'0';c=getchar())if(c=='-')flag=-1;
    for(;c<='9'&&c>='0';c=getchar())sum=(sum<<3)+(sum<<1)+c-'0';
    return flag*sum;
}

struct node{
    int to, val;
    int next=-1;
}edge[MAXN*MAXN*2];int top=1, head[MAXN];
vector<int> out[MAXN];int vis[MAXN],in[MAXN],score[MAXN];
int dep[MAXN],s=MAXN-1,t=MAXN-2;int n,m;

void add(int u, int v, int val) 
{
    top++;edge[top].to = v;edge[top].val = val;edge[top].next = head[u];head[u] = top;
    top++;edge[top].to = u;edge[top].val = 0;edge[top].next = head[v];head[v] = top;
}
// dinic部分
int bfs()
{
	memset(dep,0,sizeof(dep));
	queue<int> q;
	while(!q.empty()) 
		q.pop();
	q.push(s);
	dep[s]=1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=head[u];i!=-1;i=edge[i].next)
		{
			int v=edge[i].to;
			if(dep[v]==0&&edge[i].val>0)
			{
				dep[v]=dep[u]+1;
				q.push(v);
				if(v==t)return 1;
			}
		}
	}
    return 0;
}
int dfs(int u,int flow)
{
	if(u==t)
		return flow;
	for(int i=head[u];i!=-1;i=edge[i].next)
	{
		int v=edge[i].to;
		if(dep[v]==dep[u]+1&&edge[i].val>0)
		{
			int k=dfs(v,min(edge[i].val,flow));
			if(k==0)
			{
				dep[v]=0;
			} 
			else
			{
				edge[i].val-=k;
				edge[i^1].val+=k;
				return k;		
			}
		}
	}
	return 0;
}
int dinic()
{
	int flow,maxflow=0;
	while(bfs())
	{
		while(flow=dfs(s,INF))
		{
			maxflow+=flow;
		}
	}
	return maxflow;
}

// 构造图部分
void topsort()
{
    queue<int> q;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            if(in[POINT(i,j)]==0)
            {
                q.push(POINT(i,j));
                vis[POINT(i,j)]=1;
            }
        }
    while(!q.empty())
    {
        int u=q.front();q.pop();
        int len=out[u].size();
        for(int i=0;i<len;i++)
        {
            int v=out[u][i];
            in[v]--;
            if(vis[v]==0&&in[v]==0)
            {
                q.push(v);
                vis[v]=1;
            }
        }    
    }
}
int main(){
//	freopen("B.in","r",stdin);
//	freopen("B.out","w",stdout);
    n=read();m=read();
    for(int i=1;i<=n;i++){
        int flag,x,y;
        for(int j=1;j<=m;j++)
        {
            score[POINT(i,j)]=read();
            flag=read();
            while(flag--)
            {
                x=read();y=read();x++,y++;
                out[POINT(i,j)].push_back(POINT(x,y));
                in[POINT(x,y)]++;
            }
            if(j < m) 
            {
                out[POINT(i, j + 1)].push_back(POINT(i, j));
                in[POINT(i, j)] ++;
            }
        }
    }
    topsort();
    int sum=0;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(in[POINT(i,j)]==0)
            {
                int u = POINT(i, j);
                if(!vis[u])
                    continue;
                if(score[u] >= 0) {
                    add(s,u,score[u]);
                    sum += score[u];//cout<<sum<<" ";
                } else 
                	add(u,t,-score[u]);   
                for(int k = 0; k < out[u].size(); k ++)
                {
                    int v = out[u][k];
                    if(vis[v]) 
                        add(v, u, INF);
                    
                }
            }
        }
    }
    cout<<sum-dinic();
    return 0;
}
```
怎么就拍板不整齐了QAQ...

---

## 作者：BJpers2 (赞：12)

看很多大佬都说的是“最大权闭合子图”，蒟蒻不是很懂，这里用一种比较通俗的方法见一下这道题。

不用tarjan,不用扫环。

玩过原游戏中“我是僵尸”模式的人应该都有经验，我们每次都让僵尸去吃没有保护的植物即可。因此我们直观的让保护者向被保护者连边，在任意时刻，假如某株植物没有连向它的边了，那么它就可以成为我们攻击的对象。我们从一开始入度为0的点开始搜索，对它的所有处边上的点入度减一，如果减到零就把它入队。

这十分类似于我们所学过的拓扑排序，而且这样做巧妙地把可能被我们攻击的植物都筛出来了。最后下图中橙色的椎体就是我们筛出来的可行点。

![](https://cdn.luogu.com.cn/upload/pic/27216.png )

接下来就是套路了，我们还是将正权连源点，负权连汇点，拓扑序小的连上拓扑序大，跑一遍dinic或isap就行了。

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define REP1(u) for(int   i=hd[u],v=e[i].v,c=e[i].c;i;i=e[i].n,v=e[i].v,c=e[i].c)
#define REP2(u) for(int &i=cur[u],v=e[i].v,c=e[i].c;i;i=e[i].n,v=e[i].v,c=e[i].c)
#define REPTP(u) for(int i=hd1[u],v=ed[i].v;i;i=ed[i].n,v=ed[i].v)
using namespace std;
const int N=300,TO=100100,M=1000100,INF=1000010000;
struct edge{int n,v,c;}e[M];
struct tpeg{int n,v;}ed[M];
int n,m,ans,x,y,u,S,T,fl=1,cnt,tot,id[TO],tp[TO],su,fl1,sum;
int hd[TO],dep[TO],cur[TO],a[N][N],b[N][N],pt[TO],d[TO],hd1[TO];
queue<int>q;
void add(int u,int v,int c){e[++fl]=(edge){hd[u],v,c};hd[u]=fl;}
void adde(int u,int v,int c){add(u,v,c),add(v,u,0);}
void addTP(int u,int v){ed[++fl1]=(tpeg){hd1[u],v};hd1[u]=fl1;d[v]++;}
bool bfs(){
    while(!q.empty()) q.pop();
    FOR(i,S,T) dep[i]=-1,cur[i]=hd[i];
    q.push(S),dep[S]=0;
    while(!q.empty()){
        int u=q.front();q.pop();
        REP1(u)if(dep[v]==-1 && c>0){
            q.push(v),dep[v]=dep[u]+1;
            if(v==T) return 1;
        }
    }return dep[T]!=-1;
}
int dfs(int u,int exp){
    if(u==T) return exp;
    int flw=0,tmp;
    REP2(u)if(dep[v]==dep[u]+1 && c>0){
        tmp=dfs(v,min(exp,c));
        if(!tmp) continue;
        e[i].c-=tmp;e[i^1].c+=tmp;
        flw+=tmp,exp-=tmp;
        if(!exp) break;
    }return flw;
}
void dinic(){while(bfs()) ans+=dfs(S,INF);}
int main(){
    scanf("%d%d",&n,&m);
    FOR(i,1,n)FOR(j,1,m) a[i][j]=++tot;
    FOR(i,1,n)FOR(j,1,m){
        u=a[i][j];
        if(j>1) addTP(u,a[i][j-1]);
        scanf("%d%d",&pt[u],&su);
        while(su--) scanf("%d%d",&x,&y),addTP(u,a[x+1][y+1]);
    }
    FOR(i,1,tot) if(!d[i]) q.push(i);
    S=++cnt;
    while(!q.empty()){
        u=q.front();q.pop();
        id[u]=++cnt,tp[cnt]=u;
        REPTP(u)if(!--d[v]) q.push(v);
    }
	T=++cnt;
    FOR(p,2,cnt-1){
        u=tp[p];
        if(pt[u]>0) adde(S,p,pt[u]),sum+=pt[u];
        if(pt[u]<0) adde(p,T,-pt[u]);
        REPTP(u) adde(id[v],p,INF); 
    }
    dinic();
    printf("%d",sum-ans);
}
```

---

## 作者：fighter_OI (赞：12)

就是一个最大权闭合子图的模型。首先由源点向所有正权点连一条容量为其权值的边，有所有负权点向汇连一条容量为-（权值）的边，然后由被保护点向保护点连一条∞的边。这样一来，求最小割S集就是所攻击到的点，用（sum（总正权点值）-最小割）就是答案。因为（1）、∞不可能被选入最小割，所以如果一个植物的分数在S集一定也会把保护他的植物选进S集，这样确保解是可行的。（2）、此时最小割的数值为sum（未选的正权点值）+sum（已选的负权点值）=（sum（总正权点值）-sum（已选正权点值））+sum（已选负权点值），所以sum（总正权点值）-最小割=sum（总正权点值）-[（sum（总正权点值）-sum（已选正权点值））+sum（已选负权点值）]=sum（已选正权点值）-sum（已选负权点值）=题目所求，又因为sum（总正权点值）不变，要想最后的值最大，就要让割最小即最小割。在本题中还有一个问题，就是有可能出现“无敌节点”——在构造的网络中出现环，此时环内所有节点都不可能取到，同时被环内节点保护的所有节点也不可取所以要先去掉这些点。方法是：把网络中所有边反向进行拓扑，拓扑到的点就是要保留的点。至于为什么反向，因为如果不反向那删掉的点是环内的点和保护环的点，但明显保护环的点是可以取到的，而真正因该去掉的被环保护的点却还存在，所以必须反向。

```cpp
  1 #include<iostream>
  2 #include<cstdio>
  3 #include<cstdlib>
  4 #include<cstring>
  5 #include<algorithm>
  6 #include<queue>
  7 #define INF 10000000
  8 using namespace std;
```
9
```cpp
 10 struct edge
 11 {
 12        int y,d,next,op;
 13 } e[1000000],e2[1000000];
 14 int now=0,tot=0,tot2=0,n,m,s,t,N=0,sum=0;
 15 int map[200][200],sc[1000],r[1000],first[1000],first2[1000];
 16 int h[1000],num[1000];
 17 bool v[1000];
```
18
```cpp
 19 int inss(int x,int y)
 20 {
 21     tot++;
 22     e[tot].y=y;
 23     e[tot].next=first[x];
 24     first[x]=tot;
 25     return 0;
 26 }
```
27
```cpp
 28 int add(int x,int y,int d)
 29 {
 30     tot2++;
 31     e2[tot2].y=y;
 32     e2[tot2].d=d;
 33     e2[tot2].next=first2[x];
 34     e2[tot2].op=tot2+1;
 35     first2[x]=tot2;
 36     tot2++;
 37     e2[tot2].y=x;
 38     e2[tot2].d=0;
 39     e2[tot2].next=first2[y];
 40     e2[tot2].op=tot2-1;
 41     first2[y]=tot2;
 42     return 0;
 43 }
```
44
```cpp
 45 int init()
 46 {
 47     scanf("%d%d",&n,&m);
 48     for (int i=0;i<n;i++)
 49         for (int j=0;j<m;j++) map[i][j]=++now; 
 50     for (int i=0;i<n;i++)
 51         for (int j=0;j<m;j++)
 52         {
 53             int num,x,y;
 54             scanf("%d%d",&sc[map[i][j]],&num);
 55             for (int k=0;k<num;k++)
 56             {
 57                 scanf("%d%d",&x,&y);
 58                 r[map[x][y]]++;
 59                 inss(map[i][j],map[x][y]);             
 60             }
 61         }        
 62     for (int i=0;i<n;i++)
 63         for (int j=0;j<m-1;j++) 
 64         {
 65             r[map[i][j]]++;
 66             inss(map[i][j+1],map[i][j]);
 67         }
 68     return 0;
 69 }
```
70
```cpp
 71 int SSSP()
 72 {
 73     queue<int> q;
 74     memset(v,0,sizeof(v));
 75     for (int i=1;i<=now;i++) 
 76         if (r[i]==0)
 77         {
 78                     q.push(i);
 79                     v[i]=1;
 80         }
 81     while (!q.empty())
 82     {
 83           int u=q.front();
 84           q.pop();
 85           for (int p=first[u];p;p=e[p].next)
 86           {
 87               r[e[p].y]--;
 88               if (r[e[p].y]==0) 
 89                  {q.push(e[p].y); v[e[p].y]=1;}
 90           }
 91     }
 92     return 0;
 93 }
```
94
```cpp
 95 int find(int u,int flow)
 96 {
 97     if (u==t) return flow;
 98     int temp=flow,pos=N-1;
 99     for (int p=first2[u];p;p=e2[p].next)
100     {
101         if (h[u]==h[e2[p].y]+1 && e2[p].d>0)
102         {
103                               int f=find(e2[p].y,min(e2[p].d,temp));
104                               temp-=f;
105                               e2[p].d-=f;
106                               e2[e2[p].op].d+=f;
107                               if (temp==0 || h[s]==N) return flow-temp;
108         }
109         if (e2[p].d>0 && pos>h[e2[p].y]) pos=h[e2[p].y];
110     }
111     if (temp==flow)
112     {
113                    num[h[u]]--;
114                    if (num[h[u]]==0) h[s]=N;
115                    else
116                    {
117                        h[u]=pos+1;
118                        num[h[u]]++;
119                    }
120     }
121     return flow-temp;
122 }
```
123
```cpp
124 int solve()
125 {
126     s=0;
127     t=n*m+1;
128     for (int i=1;i<=now;i++)
129     {
130         if (v[i] && sc[i]>0) {add(s,i,sc[i]); sum+=sc[i];}
131         if (v[i] && sc[i]<0) add(i,t,-sc[i]);
132     }
133     for (int i=1;i<=now;i++)
134         if (v[i]) 
135            for (int p=first[i];p;p=e[p].next)
136                if (v[e[p].y])
137                   add(e[p].y,i,INF);
138     for (int i=1;i<=now;i++) N++;
139     N+=2;
140     memset(h,0,sizeof(h));
141     memset(num,0,sizeof(num));   
142     num[0]=N;
143     int ans=0;
144     while (h[s]<N) ans+=find(s,INF);
145     return ans;
146 }
```
147
```cpp
148 int main()
149 {    
150     freopen("pvz.in","r",stdin); 
151     freopen("pvz.out","w",stdout);
152     init();
153     SSSP();
154     printf("%d",max(sum-solve(),0));
155     //system("pause");
156     fclose(stdin);fclose(stdout);
157     return 0;
158 }
```

---

## 作者：CYJian (赞：8)

这道题。。大家好像都是用最大权闭合子图做的啊。。

蒟蒻不会，所以自己yy出了一个不用最大权闭合子图的奇怪的做法(跑得有点慢)。。虽然本质上还是一个最小割。

先拿样例开个刀。。

首先，我们可以建出一个如下图的网格图：

![](https://i.loli.net/2019/01/10/5c372990a04d3.png)

然后我们令割完边后属于S集合的点代表被吃了的植物，T集合表示没有被吃的植物的话，那么我们可以想到用前缀和来代表一条边的流量，这样的话割掉一条边就是把前面的植物都吃掉的代价。就像这样。

![](https://i.loli.net/2019/01/10/5c372e8e7382d.png)

显然这个图有几个大bug：

1. 有负权边。

2. 就算能跑出来，最小割也还是最小的价值。本题要求的是最大的价值。

解决的方案也很简单：

1. 在求前缀和前加上一个非常大的正整数。

2. 把原来的所有权值乘上-1。

这样的话跑出来的最小割只要减去 原图的行数 * 那个非常大的正整数 ，然后乘回-1就是最大价值了。

改进后的图长这样：

![](https://i.loli.net/2019/01/10/5c372e8e71acd.png)

然后如果没有攻击的限制，那么这道题到这也就完了。

但是这道题并不是。

对于攻击的限制，我们可以考虑用这样一种方式维护：

由被保护点向保护点连一条容量为INF的边。

这个的含义就是：如果你割了被保护点的前面的边，那就并没有什么影响。如果割了后面的边，那么你就需要在保护点那一行一直吃到保护点之后。

如果是这样的话，我们就可以建出下面的图：

![](https://i.loli.net/2019/01/10/5c372e8e63d98.png)

(这里的(2,1)到(2,0)连了一条容量为INF的边(保护关系)后容量就变成INF了。)

然后你就发现了一个更大的bug：第三行会割掉(2,0)到T的边！！

显然你是没有办法先吃掉(2,1)再吃掉(2,0)的。因为你要吃掉(2,1)，首先先得击溃(2,0)来去掉(2,1)的防护，但是如果没有吃掉(2,1)你就吃不掉(2,0)。

然后。。你就注意到了这里是环的关系。。

果断拓扑排序，找出所有在环中的点，一行中一旦有一个点在环中，那么它就肯定不能被吃掉了。

至于连边，就是按照吃的顺序，从一行的前面的点连向后面的点，保护点连向被保护点就好了。

然后我们注意到如果一个点在环上，那么它后面的点就肯定不能被吃掉。这样我们就可以从第一个在环中的点向T连一条容量为INF的边，然后由于最小割的性质，它就不得不割前面的边了。

然后我们就可以得到下面这样一张图：

![](https://i.loli.net/2019/01/10/5c372e8e75a60.png)

然后你可以试着手动割边，发现割掉的是(0,0)到T的边、(1,1)到(1,0)的边，S到(2,1)的边。结果是3e9-((1e9-30)+(1e9+5)+1e9)=25，非常正确。

然后就是码的事情了。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define reg register
#define ge getchar()
#define Re read()
#define id(x, y) ((x - 1) * m + y)//点的编号转化
#define FI "Network.in"
#define FO "Network.out"
#define MAXN 1010
#define MAXM 363636
#define Inf 2147483647
#define Add 50000000 //一个非常大的数，这么大足够了。

inline int read();
inline void Link(reg int, reg int, reg int);
inline void check();
inline int solve(reg int, reg int);
inline int DFS(reg int, reg int, reg int);
inline int BFS(reg int, reg int);

int n;
int m;
int tot;
int fi[MAXN + 1];
int la[MAXN + 1];
int V[MAXM + 1];
int to[MAXM + 1];
int ne[MAXM + 1];
int Arrive[MAXN + 1];

queue<int>q;
bitset<MAXN + 1>OK; //一个点是不是在环上
vector<int>To[MAXN + 1];
int in[MAXN + 1];
int val[MAXN + 1];

int main() {
#ifndef ONLINE_JUDGE
	freopen(FI, "r", stdin);
	freopen(FO, "w", stdout);
#endif
	n = Re, m = Re;
	reg int S = n * m + 1;
	reg int T = n * m + 2;
	for(reg int i = 1; i <= n; i++) {//这一个部分建的边是为了跑拓扑排序。
		for(reg int j = m; j >= 1; j--) {//从m开始是为了按照每一行吃植物的顺序。
			if(j > 1) { //如果不是最开头的点，就需要先吃完前面的再吃后面的。
				Link(id(i, j - 1), id(i, j), 0);
				in[id(i, j)]++;
			}
			val[id(i, j)] = Re;
			reg int k = Re;
			while(k--) {
				reg int x = Re + 1, y = m - Re;//上面的顺序改了，这里也要改位置。
				Link(id(i, j), id(x, y), 0);
				in[id(x, y)]++;
				To[id(i, j)].push_back(id(x, y));//存下保护的点。
			}
		}
	}
	for(reg int i = 1; i <= n; i++)
		for(reg int j = 1; j <= m; j++)
			if(!in[id(i, j)])
				q.push(id(i, j));//如果入度不为零就插入。
	check();
	tot = 1;
	memset(fi, 0, sizeof(fi));//清空邻接链表
	for(reg int i = 1; i <= n; i++) {
		reg int sum = Add;//一开始从源点S连出一条非常大的正整数的边。
		Link(S, id(i, 1), sum);
		Link(id(i, 1), S, 0);
		for(reg int j = 1; j <= m; j++) {
			if(OK[id(i, j)]) {//如果这个点在环上，那么后面的边就可以不用连了，反正没有什么意义。
				Link(id(i, j), T, Inf);
				Link(T, id(i, j), 0);
				break;
			}
			sum -= val[id(i, j)];
			reg int to = j == m ? T : id(i, j + 1);
			Link(id(i, j), to, sum);
			Link(to, id(i, j), 0);
			reg int si = To[id(i, j)].size();
			for(reg int k = 0; k < si; k++) {//连保护点和被保护点。
				Link(To[id(i, j)][k], id(i, j), Inf);
				Link(id(i, j), To[id(i, j)][k], 0);
			}
		}
	}
	printf("%d\n", Add * n - solve(S, T));//最小割。
	return 0;
}

inline int read() {
	reg int x = 0, t = 0, ch;
	while(!isdigit(ch = ge)) t |= ch == '-';
	while(isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = ge;
	return t ? -x : x;
}

inline void Link(reg int u, reg int v, reg int w) {
	tot++;
	V[tot] = w;
	to[tot] = v;
	ne[tot] = fi[u];
	fi[u] = tot;
}

inline void check() {
	OK.set();
	while(!q.empty()) {
		reg int x = q.front(); q.pop();
		OK[x] = 0;
		for(reg int i = fi[x]; i; i = ne[i]) {
			reg int u = to[i];
			in[u]--;
			if(!in[u]) q.push(u);
		}
	}
}

inline int solve(reg int S, reg int T) {
	reg int res = 0;
	while(BFS(S, T)) res += DFS(S, T, Inf);
	return res;
}

inline int BFS(reg int S, reg int T) {
	memset(Arrive, 0, sizeof(Arrive));
	memcpy(la, fi, sizeof(la));
	q.push(S);
	Arrive[S] = 1;
	while(!q.empty()) {
		reg int x = q.front(); q.pop();
		for(reg int i = fi[x]; i; i = ne[i]) {
			reg int u = to[i];
			if(!Arrive[u] && V[i]) {
				Arrive[u] = Arrive[x] + 1;
				q.push(u);
			}
		}
	}
	return Arrive[T];
}

inline int DFS(reg int x, reg int T, reg int Max) {
	if(x == T) return Max;
	reg int sum = 0;
	for(reg int &i = la[x]; i; i = ne[i]) {
		reg int u = to[i];
		if(Arrive[u] == Arrive[x] + 1 && V[i]) {
			reg int k = DFS(u, T, min(Max - sum, V[i]));
			V[i] -= k;
			V[i ^ 1] += k;
			sum += k;
			if(sum == Max) return sum;
		}
	}
	return sum;
}
```

---

## 作者：SBS苏 (赞：7)

这道题第一眼看到就认为是最大权闭合子图。

于是建图，从一个植物向保护它的植物连边。

之后用DINIC跑最大流来求最小割。

然而写完后发现连样例都过不去。

原因是：**有环**！**有环**！**有环**！（\_这是坑\_）

（想像一下一个无冷却的食人花前放一个坚果）

所以先拓扑排序求环，把环删掉。

（这题好像不能用tarjan，不知为何。）

还有最后的坑点：虽然点只有600个，但边足有8\*(10^5)条。用邻接表的同志们记得把数组开够。

贴上代码：


【code/c】

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cstdlib>
#include<iomanip>
#include<cassert>
#include<climits>
#include<functional>
#include<bitset>
#include<vector>
#include<list>
#define F(i,j,k) for(int i=j;i<=k;++i)
#define M(a,b) memset(a,b,sizeof(a))
#define FF(i,j,k) for(int i=j;i>=k;i--)
#define inf 0x3f3f3f3f
#define maxm 1001
#define mod 998244353
//#define LOCAL
using namespace std;
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,m;
int mp[2000];
struct EDGE
{
    int from;
    int to;
    int value;
    int next;
}e[800005];
int head[4001];
int v[4001],in[4001],out[4001];
int tot=1;
inline void addedge(int u,int v,int w)
{
    e[++tot].from=u;
    e[tot].to=v;
    e[tot].value=w;
    e[tot].next=head[u];
    head[u]=tot;
}
int ans=0;
inline void add(int u,int v,int w)
{
    addedge(u,v,w);
    addedge(v,u,0);
    ++in[u];
    return;
}
int map[4001];
int S,T;
bool ok()
{  
    F(i,S,T) if(map[i]!=-2) map[i]=-1;
    int que[4001];  
    int hd=0,tl=0;  
    que[tl++]=S;  
    map[S]=1;  
    while (hd<tl){  
        int u=que[hd++];  
        for(int i=head[u];i;i=e[i].next)
        {  
            if(map[e[i].to]==-1&&e[i].value)
            {  
                map[e[i].to]=map[u]+1;  
                que[tl++]=e[i].to;  
            }  
        }  
    }  
    return map[T]>0;
}  
int cur[4000];
int zeng(int k,int now)
{  
    if (k==T) return now;  
    int r=0;  
    for (int i=cur[k];i&&now>r;i=e[i].next)
    {  
        if (map[k]+1==map[e[i].to]&&e[i].value)
        {  
            int t=zeng(e[i].to,min(now-r,e[i].value));  
            e[i].value-=t;e[i^1].value+=t;r+=t;  
            if(e[i].value) cur[k]=i;
//            cout<<e[i].from<<" ---> "<<e[i].to<<" $ "<<t<<endl;
        }  
    }  
    if (!r) map[k]=-1;  
    return r;  
}  
int dinic()  
{  
    int r=0,t;  
    M(cur,0);
    while (ok()){
        for(int i=S;i<=T;++i) cur[i]=head[i];
        r+=zeng(S,inf);
    }
    return r;   
}
int main()
{
    std::ios::sync_with_stdio(false);//cout<<setiosflags(ios::fixed)<<setprecision(1)<<y;
    #ifdef LOCAL
    freopen("111.in","r",stdin);
    freopen("data.out","w",stdout);
    #endif
    cin>>n>>m;
    S=0;T=m*n+1;
    M(mp,0);M(head,0);
    F(i,1,n*m){
        int temp;
        cin>>mp[i];
        if(mp[i]>0) add(S,i,mp[i]);
        else add(i,T,-mp[i]);
        cin>>temp;
        while(temp--){
            int x,y;
            cin>>x>>y;
            add(x*m+y+1,i,inf);
        }
        if(i%m) add(i,i+1,inf);
    }
    int q[4000];M(q,0);
    int cur1=0,cur2=0;
    for(int i=S;i<=T;++i){
        if(!in[i]) q[cur2++]=i;
        map[i]=-2;
    } 
    int sum=0; 
    while(cur1<cur2){
        int cnt=q[cur1++];map[cnt]=0;
        if(mp[cnt]>0) sum+=mp[cnt];
        for(int i=head[cnt];i;i=e[i].next)
        {
            if(i&1) if(!--in[e[i].to]) q[cur2++]=e[i].to;
        }
    }
    cout<<sum-dinic()<<endl;
    return 0;
}
```

---

## 作者：xht (赞：5)

题目地址：[P2805 [NOI2009]植物大战僵尸](https://www.luogu.org/problemnew/show/P2805)

### 最大权闭合子图

若有向图 $G$ 的子图 $V$ 满足： $V$ 中顶点的所有出边均指向 $V$ 内部的顶点，则称 $V$ 是 $G$ 的一个**闭合子图**。

若 $G$ 中的点有点权，则**点权和最大**的闭合子图称为有向图 $G$ 的**最大权闭合子图**。

#### 构图方法

建立源点 $S$ 和汇点 $T$ ，源点 $S$ 连所有点权为正的点，容量为该点点权；其余点连汇点 $T$ ，容量为该点点权的相反数，对于原图中的边 $(x,y)$ ，连边 $(x,y,+inf)$。

#### 定理

* 最大权闭合图的点权和 $=$ 所有正权点权值和 $–$ 最小割。
* 上述图的最小割包含 $S$ 到**不在最大权闭合图内的正权节点**的边和**在最大权闭合图内的负权节点**到 $T$ 的边。

#### 推论（最大权闭合图方案）

在**残量网络**中由源点 $S$ 能够访问到的点，就构成一个**点数最少**的最大权闭合图。

#### 本题题解

把每个植物当做一个顶点，植物携带的能源数目为顶点的权值。

如果植物 $b$ 在植物 $a$ 的攻击范围内，连接一条有向边 $(a,b)$ ，表示 $a$ 可以保护 $b$ 。

由于僵尸从右向左进攻，可以认为每个植物都被它右边相邻的植物保护，对于每个植物 $a$ （除最左边一列），向其左边的相邻植物 $b$ ，连接一条有向边 $(a,b)$ 。

**此时可能有一些植物是互相保护的，都不能被吃掉，这样的点（和与其相连的边）应该全部删掉，拓扑排序一遍即可。**

如果要吃掉一个植物，就应该把所有保护它的植物全部吃掉。

对应在图中，如果我们将图**转置**（即所有边转成其反向边），那么可以吃掉的植物应该构成一个闭合子图，而最优解就是最大权闭合子图。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4 + 6, M = 1e6 + 6, inf = 1e9;
int n, m, s, t, a[N], ans, d[N], deg[N], v[N];
int Head[N], Edge[M], Leng[M], Next[M], tot = 1;
queue<int> q;
vector<int> e[N];

inline void add(int x, int y, int z) {
    Edge[++tot] = y;
    Leng[tot] = z;
    Next[tot] = Head[x];
    Head[x] = tot;
}

inline bool bfs() {
    memset(d, 0, sizeof(d));
    queue<int> q;
    q.push(s);
    d[s] = 1;
    while (q.size()) {
        int x = q.front();
        q.pop();
        for (int i = Head[x]; i; i = Next[i]) {
            int y = Edge[i], z = Leng[i];
            if (deg[y] || d[y] || !z) continue;
            q.push(y);
            d[y] = d[x] + 1;
            if (y == t) return 1;
        }
    }
    return 0;
}

int dinic(int x, int flow) {
    if (x == t) return flow;
    int rest = flow;
    for (int i = Head[x]; i && rest; i = Next[i]) {
        int y = Edge[i], z = Leng[i];
        if (d[y] != d[x] + 1 || !z) continue;
        int k = dinic(y, min(rest, z));
        if (!k) d[y] = 0;
        else {
            Leng[i] -= k;
            Leng[i^1] += k;
            rest -= k;
        }
    }
    return flow - rest;
}

int main() {
    cin >> n >> m;
    s = n * m, t = s + 1;
    for (int i = 0; i < s; i++) {
        scanf("%d", &a[i]);
        int k;
        scanf("%d", &k);
        while (k--) {
            int x, y;
            scanf("%d %d", &x, &y);
            e[i].push_back(x * m + y);
            ++deg[x*m+y];
        }
    }
    for (int i = 0; i < n; i++)
        for (int j = 1; j < m; j++) {
            e[i*m+j].push_back(i * m + j - 1);
            ++deg[i*m+j-1];
        }
    for (int i = 0; i < s; i++)
        if (!deg[i]) q.push(i), v[i] = 1;
    while (q.size()) {
        int x = q.front();
        q.pop();
        for (unsigned int i = 0; i < e[x].size(); i++) {
            int y = e[x][i];
            if (!v[y] && !--deg[y]) q.push(y), v[y] = 1;
        }
    }
    for (int x = 0; x < s; x++) {
    	if (!v[x]) continue;
        for (unsigned int i = 0; i < e[x].size(); i++) {
            int y = e[x][i];
            if (!v[y]) continue;
            add(y, x, inf);
            add(x, y, 0);
        }
        if (a[x] > 0) add(s, x, a[x]), add(x, s, 0), ans += a[x];
        if (a[x] < 0) add(x, t, -a[x]), add(t, x, 0);
	}
    int now = 0;
    while (bfs())
        while ((now = dinic(s, inf)))
            ans -= now;
    cout << ans << endl;
    return 0;
}
```

---

## 作者：APJifengc (赞：3)

想到了一种不使用普通的求最大权闭合子图的方法，貌似也可以推广到求最大权闭合子图上，~~不过就是建模更复杂计算更麻烦然后也没有什么优势罢了。~~

> 本题的目标为，制定一套 Zombies 的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。

考虑构建最小割模型，将所有正数和负数分开考虑，如果一个正数不选就会造成损失，如果选一个负数就会造成其绝对值的损失，这样求最小损失，再用所有正数之和减去最小损失就是最大收入了。

~~接下来就是我的奇怪建模了~~

因为发现，如果要击溃一个位置的 Plant，那么在它右面的所有 Plant 都要被击溃，所以我们可以考虑每一行上被击溃了的 Plant 的区间左端点。那么这一行的损失，就是这个左端点向右（包括左端点）的所有负数的绝对值之和加上左端点向左（不包括左端点）的所有正数之和。

发现这个权值很容易就可以利用前缀和和后缀和处理出来，于是我们就可以构建这样一个模型：

设 $r_{i,j}$ 为从 $(i,j)$ 开始向右的所有负数的绝对值之和，$l_{i,j}$ 为从 $(i,j)$ 开始向左的正数之和，则可以连边：

$$
(i,j)\xrightarrow{\normalsize r_{i,j}+l_{i,j-1}}(i,j-1)
$$

$$
S\xrightarrow{\normalsize l_{i,m}}(i,m)
$$

$$
(i,1)\xrightarrow{\normalsize r_{i,1}}T
$$

然后考虑如何解决 Plant 攻击的问题。

Plant 攻击的本质是什么？实际上就是如果 $(i,j)$ 保护 $(x,y)$，那么如果 $(i,j)$ 这个植物不被击溃，$(x,y)$ 及向左的所有植物就也都不能被击溃。

放到我们的最小割模型上呢？我们将 $(x,y)$ 向 $(i,j)$ 连一条边，其实就是：如果 $(x,y)$ 向右的边 $A$ 被割，那么 $(i,j)$ 向左的边 $D$ 就没必要割；反之，如果 $(x,y)$ 向左边的边 $B$ 被割，那么 $(i,j)$ 向左的边 $D$ 就也必须割掉。

![](https://s2.loli.net/2022/02/12/zIZogRhFsPk8yjS.png)

（若还不明白，可以转向 [[HNOI2013]切糕](https://www.luogu.com.cn/problem/P3227)，这道题题的距离限制与本题的 Plant 攻击比较相似。）

这样，就实现了 Plant 攻击的限制。

可是这样连样例都过不了。为什么？

样例中，$(3,1)$ 能攻击到 $(3,2)$，这导致第三行的 Plant 不可能被攻击到，但是如果用上图的限制方式，那么他只需要将 $(3,1)\rightarrow T$ 的边割掉就好了，而这显然是不合法的。~~你不能先跳过去把植物鲨了然后再跳回来嘛~~

~~然后我就傻乎乎的去特判了下这种情况，然后拿到了 90 分的好成绩~~

这种情况的本质是什么？实际上是**出现了一个环**。除了样例中这种情况，还可能有这样的情况：

![](https://s2.loli.net/2022/02/12/uHXEdUfnyOL4Akc.png)

（这里箭头是指 Plant 能攻击到的位置）

那么这显然就是一个环了。如果出现了一个环，我们就将环中所有的点都向 $T$ 连一条 $\infty$ 的边，就可以保证它不被割掉了。

判环我使用的是 Tarjan，于是这题就做完了。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1209, MAXM = 1000005;
const int inf = INT_MAX / 2;
struct Graph { // 网络流板子
    int fst[MAXN], to[MAXM], f[MAXM], now[MAXN], d[MAXN], nxt[MAXM], tot;
    Graph() : tot(1) {}
    void add(int u, int v, int w) {
        to[++tot] = v, nxt[tot] = fst[u], f[tot] = w, fst[u] = tot;
        to[++tot] = u, nxt[tot] = fst[v], f[tot] = 0, fst[v] = tot;
    }
    int s, t;
    bool bfs() {
        memset(d, 0, sizeof d);
        queue<int> q; q.push(s); d[s] = 1, now[s] = fst[s];
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int i = fst[u], v = to[i]; i; i = nxt[i], v = to[i]) {
                if (f[i] && !d[v]) {
                    q.push(v);
                    d[v] = d[u] + 1;
                    now[v] = fst[v];
                    if (v == t) return true;
                }
            }
        }
        return false;
    }
    int dinic(int u, int flow) {
        if (u == t) return flow;
        int rest = flow;
        for (int &i = now[u], v = to[i]; i; i = nxt[i], v = to[i]) {
            if (f[i] && d[v] == d[u] + 1) {
                int k = dinic(v, min(f[i], rest));
                if (!k) d[v] = 0;
                f[i] -= k;
                f[i ^ 1] += k;
                rest -= k;
            }
            if (!rest) break;
        }
        return flow - rest;
    }
    int solve() {
        int flow, maxflow = 0;
        while (bfs())
            while (flow = dinic(s, inf)) maxflow += flow;
        return maxflow;
    }
}g;
int n, m;
int s[55][55], a[55][55][55];
int l[55][55], r[55][55], sum;
int ids(int x, int y) { // 点 ID
    return (x - 1) * m + y;
}
int ide(int x, int y) { // 点的左边一个点的 ID
    if (y == 1) return g.t;
    return ids(x, y - 1);
}
struct Graph2 {
    int fst[MAXN], nxt[MAXM], to[MAXM], tot;
    int degree[MAXN];
    void add(int u, int v) {
        to[++tot] = v;
        nxt[tot] = fst[u];
        fst[u] = tot;
        degree[v]++;
    }
    int dfn[MAXN], low[MAXN], dcnt;
    bool inStack[MAXN], vis[MAXN];
    stack<int> st;
    void tarjan(int u) {
        vis[u] = 1;
        dfn[u] = low[u] = ++dcnt;
        inStack[u] = 1;
        st.push(u);
        for (int i = fst[u], v = to[i]; i; i = nxt[i], v = to[i]) {
            if (!dfn[v]) {
                tarjan(v);
                low[u] = min(low[u], low[v]);
            } else if (inStack[v]) {
                low[u] = min(low[u], dfn[v]);
            }
        }
        if (dfn[u] == low[u]) {
            int cnt = 0;
            vector<int> pts;
            while (1) {
                int t = st.top(); st.pop();
                inStack[t] = 0;
                cnt++;
                pts.push_back(t);
                if (t == u) break;
            }
            if (cnt > 1) {
                for (int t : pts) 
                    g.add(t, g.t, inf);
            }
        }
    }
}g2;
int main() {
    scanf("%d%d", &n, &m);
    g.s = 2 * n * m + 1, g.t = 2 * n * m + 2;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            int w;
            scanf("%d%d", &s[i][j], &w);
            if (s[i][j] > 0) sum += s[i][j], l[i][j] = s[i][j];
            else r[i][j] = -s[i][j];
            while (w--) {
                int x, y; scanf("%d%d", &x, &y); x++, y++;
                g2.add(ids(i, j), ids(x, y));
                a[i][j][x] = max(a[i][j][x], y);
            }
        }
    }
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            l[i][j] += l[i][j - 1];
    for (int i = 1; i <= n; i++)
        for (int j = m; j >= 1; j--)
            r[i][j] += r[i][j + 1];
    for (int i = 1; i <= n; i++)
        g.add(g.s, ids(i, m), l[i][m]);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            g.add(ids(i, j), ide(i, j), r[i][j] + l[i][j - 1]);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            for (int k = 1; k <= n; k++) {
                int p = a[i][j][k];
                if (p) {
                    g.add(ids(k, p), ids(i, j), inf);
                }
            }
    for (int i = 1; i <= n; i++)
        for (int j = 1; j < m; j++) g2.add(ids(i, j + 1), ids(i, j));
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (!g2.vis[ids(i, j)]) g2.tarjan(ids(i, j));
    printf("%d\n", sum - g.solve());
    return 0;
}
```

---

## 作者：eros1on (赞：2)

[博客食用更佳](https://tle666.github.io/2019/11/28/[NOI2009]%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/)

# **Description**

游戏的地图可以抽象为一个 $N$ 行 $M$ 列的矩阵，行从上到下用 $0$ 到 $N - 1$ 编号，列从左到右用 $0$ 到 $M - 1$ 编号；在地图的每个位置上都放有一个 $\text{Plant}$ ，为简单起见，我们把位于第 $r$ 行第 $c$ 列的植物记为 $P_{r, c}$ 。

$\text{Plants}$ 分很多种，有攻击类、防守类和经济类等等。为了简单的描述每个 $\text{Plant}$ ，定义 $\text{Score}$ 和 $\text{Attack}$ 如下：

$\text{Score} [P_{r, c}]$

$\text{Zombie}$ 击溃植物 $P_{r, c}$ 可获得的能源。若 $\text{Score} [P_{r, c}]$ 为非负整数，则表示击溃植物 $P_{r, c}$ 可获得能源 $\text{Score} [P_{r, c}]$ ，若为负数表示击溃 $P_{r, c}$ 需要付出能源 $- \text{Score} [P_{r, c}]$ 。

$\text{Attack} [P_{r, c}]$

植物 $P_{r, c}$ 能够对 $\text{Zombie}$ 进行攻击的位置集合。

$\text{Zombies}$ 必须从地图的右侧进入，且只能沿着水平方向进行移动。 $\text{Zombies}$ 攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此 $\text{Zombies}$ 的进攻总是从地图的右侧开始。也就是说，对于第r行的进攻， $\text{Zombies}$ 必须首先攻击Pr, M-1；若需要对 $P_{r, c}$ （ $0 \leq c < M - 1$ ）攻击，必须将 $P_{r, M - 1}, P_{r, M - 2} \cdots P_{r, c + 1}$ 先击溃，并移动到位置 $(r, c)$ 才可进行攻击。

在本题的设定中， $\text{Plants}$ 的攻击力是无穷大的，一旦 $\text{Zombie}$ 进入某个 $\text{Plant}$ 的攻击位置，该 $\text{Zombie}$ 会被瞬间消灭，而该 $\text{Zombie}$ 没有时间进行任何攻击操作。因此，即便 $\text{Zombie}$ 进入了一个 $\text{Plant}$ 所在的位置，但该位置属于其他植物的攻击位置集合，则 $\text{Zombie}$ 会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中， $\text{Plant}$ 的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。

$\text{Zombies}$ 的目标是对 $\text{Plants}$ 的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套 $\text{Zombies}$ 的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。

对于 $100 \%$ 的数据，有 $1 \leq N \leq 20,\ 1 \leq M \leq 30,\ -10^4 \leq \text{Score} \leq 10^4$

[题目链接戳这里](https://www.luogu.com.cn/problem/P2805)

# **Solution**

可以通过建图来表示限制条件，即当且仅当「一个 $\text{Plant}$ 右侧所有的 $\text{Plants}$ 都被消灭」且「所有能够保护这个 $\text{Plant}$ 的 $\text{Plants}$ 都被消灭」时，该 $\text{Plant}$ 才能够被消灭。

将每个 $\text{Plant}$ 向它所有能够保护的 $\text{Plants}$ 连单向边。

这样，只有在一个 $\text{Plant}$ 的入度为 $0$ 时才能被消灭。

这样避免了两个 $\text{Plants}$ 互相保护，永远无法被消灭的情况。

不难想到用拓扑排序选出那些能被消灭的 $\text{Plants}$ 。

接下来只需判断怎么消灭的利益最大即可。

通过 $\text{Plants}$ 能被消灭的性质，可以想到闭合子图：有向图的一个子图中，对于每个点，从它出发，能够走到的所有点都在这个子图中，那么这个子图就是一个闭合子图。

考虑按照以下规则建图：

- 一个 $\text{Plant}$ 的点权是它的 $\text{Score}$ ；

- 每个 $\text{Plant}$ 都向其右侧的 $\text{Plant}$ 连边；

- 每个 $\text{Plant}$ 都向保护自己的 $\text{Plants}$ 连边。

那么以上这个图求出最大权闭合子图的收益即可。

# **Code**

（这里的缩进变成了 4 格，但我原来是 2 格，所以看起来可能有点怪异， [博客](https://tle666.github.io/2019/11/28/[NOI2009]%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/) 食用更佳）

```cpp
#include <bits/stdc++.h>

using namespace std;

#define rep(i, a, b) for (int i = (a); i <= (b); i++)
#define trv(p, u) for (edg *p = h[u]; p; p = p->nxt)
#define id(x, y) ((x - 1) * m + y)
const int N = 1e6 + 100;
const int inf = 0x3f3f3f3f;

int n, m, s, t, ind[N], lev[N], sco[N];
bool inGra[N];
vector <int> e[N];

struct edg {
	int v, c;
	edg *nxt, *rev;
} pol[N << 1], *h[N], *cur = pol;

void add(int u, int v, int c) {
	edg *p = ++cur, *q = ++cur;
	p->rev = q, q->rev = p;
	p->v = v, p->c = c, p->nxt = h[u], h[u] = p;
	q->v = u, q->c = 0, q->nxt = h[v], h[v] = q;
}

void topo() {
	queue <int> Q;
	rep(i, 1, n) {
		rep(j, 1, m) {
			if (ind[id(i, j)]) continue ;
			inGra[id(i, j)] = true;
			Q.push(id(i, j));
		}
	}
	while (!Q.empty()) {
		int u = Q.front();
		Q.pop();
		rep(i, 0, (int) e[u].size() - 1) {
			int v = e[u][i];
			ind[v]--;
			if (!ind[v] && !inGra[v]) {
				Q.push(v);
				inGra[v] = true;
			}
		}
	}
}

bool makelev() {
	queue <int> Q;
	memset(lev, -1, sizeof(lev));
	lev[s] = 1;
	Q.push(s);
	while (!Q.empty()) {
		int u = Q.front();
		Q.pop();
		trv(p, u) {
			int v = p->v;
			if (p->c && lev[v] == -1) {
				lev[v] = lev[u] + 1;
				Q.push(v);
			}
		}
	}
	return lev[t] != -1;
}

int dfs(int u, int flo) {
	int res = 0;
	if (u == t) return flo;
	trv(p, u) {
		int v = p->v;
		if (p->c && lev[v] == lev[u] + 1) {
			int f = dfs(v, min(flo, p->c));
			p->c -= f, p->rev->c += f;
			flo -= f, res += f;
			if (!flo) break ;
		}
	}
	if (!res) lev[u] = -1;
	return res;
}

int dinic() {
	int res = 0;
	while (makelev()) res += dfs(s, inf);
	return res;
}

int main() {
	scanf("%d %d", &n, &m);
	s = 0, t = n * m + 1;
	rep(i, 1, n) {
		rep(j, 1, m) {
			int tot, u = id(i, j);
			scanf("%d %d", &sco[u], &tot);
			rep(k, 1, tot) {
				int x, y;
				scanf("%d %d", &x, &y);
				x++, y++;
				e[u].push_back(id(x, y));
				ind[id(x, y)]++;
			}
			if (j < m) {
				e[id(i, j + 1)].push_back(u);
				ind[u]++;
			}
		}
	}
	topo();
	int sum = 0;
	rep(i, 1, n) {
		rep(j, 1, m) {
			int u = id(i, j);
			if (!inGra[u]) continue ;
			if (sco[u] >= 0) {
				add(s, u, sco[u]);
				sum += sco[u];
			}
			else {
				add(u, t, -sco[u]);
			}
			rep(k, 0, (int) e[u].size() - 1) {
				int v = e[u][k];
				if (inGra[v]) add(v, u, inf);
			}
		}
	}
	printf("%d\n", sum - dinic());
	return 0;
}
```

---

## 作者：orz_z (赞：1)

给定一个 $n$ 行 $m$ 列的图，每个点可以保护一些点。

每个点有一个权值（可以为负数）。

如果要选取一个点则必须选取保护它的点以及它右边的点。

试求最大权值和（可以一个点也不选）。

$1 \leq n \leq 20,1\leq m\leq 30$，时限 $1\text{s}$，空限 $125\text{MB}$。

#### sol

容易发现这其实是一道最大权闭合子图的题。

但是需要注意：图可能有环。

也就是说如果你遇到一些植物相互保护的话，是无解的。

所以我们可以用拓扑排序来找出所有的环，在拓扑排序过程中访问到的点才有实际意义。

最后跑一遍最大权闭合子图即可。

```cpp
#include <bits/stdc++.h>

using namespace std;

inline int read()
{
	int x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-')
			f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

inline void write(int x)
{
	if (x < 0)
	{
		putchar('-');
		x = -x;
	}
	if (x > 9)
		write(x / 10);
	putchar(x % 10 + '0');
}

typedef int tp;

const int _ = 5e5 + 10;

int n, m, s, t, lv[_], cur[_];

int tot = 1, head[_], to[_ << 1], nxt[_ << 1];

tp w[_ << 1];

inline void add(int u, int v, tp dis)
{
	to[++tot] = v;
	nxt[tot] = head[u];
	w[tot] = dis;
	head[u] = tot;
}

inline void Add(int u, int v, tp dis)
{
	add(u, v, dis);
	add(v, u, 0);
}

inline bool bfs()
{
	memset(lv, -1, sizeof(lv));
	lv[s] = 0;
	memcpy(cur, head, sizeof(head));
	queue<int> q;
	q.push(s);
	while (!q.empty())
	{
		int p = q.front();
		q.pop();
		for (int eg = head[p]; eg; eg = nxt[eg])
		{
			int v = to[eg];
			tp vol = w[eg];
			if (vol > 0 && lv[v] == -1)
				lv[v] = lv[p] + 1, q.push(v);
		}
	}
	return lv[t] != -1;
}

tp dfs(int p = s, tp flow = 2e9)
{
	if (p == t)
		return flow;
	tp rmn = flow;
	for (int eg = cur[p]; eg && rmn; eg = nxt[eg])
	{
		cur[p] = eg;
		int v = to[eg];
		tp vol = w[eg];
		if (vol > 0 && lv[v] == lv[p] + 1)
		{
			tp c = dfs(v, min(vol, rmn));
			rmn -= c;
			w[eg] -= c;
			w[eg ^ 1] += c;
		}
	}
	return flow - rmn;
}

inline tp dinic()
{
	tp ans = 0;
	while (bfs())
		ans += dfs();
	return ans;
}

int id(int x, int y)
{
	return (x - 1) * m + y;
}

bool vis[_];

int in[_], score[_];

vector<int> out[_];

void toposort()
{
	queue<int> Q;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if (!in[id(i, j)])
			{
				Q.push(id(i, j));
				vis[id(i, j)] = 1;
			}
	while (!Q.empty())
	{
		int u = Q.front();
		Q.pop();
		for (int i = 0; i < out[u].size(); i++)
		{
			int v = out[u][i];
			in[v]--;
			if (!vis[v] && !in[v])
			{
				Q.push(v);
				vis[v] = true;
			}
		}
	}
}

signed main()
{
	int x, y, z;
	n = read(), m = read();
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
		{
			score[id(i, j)] = read(), z = read();
			for (int k = 1; k <= z; k++)
			{
				int x = read() + 1, y = read() + 1;
				out[id(i, j)].push_back(id(x, y));
				in[id(x, y)]++;
			}
			if (j < m)
			{
				out[id(i, j + 1)].push_back(id(i, j));
				in[id(i, j)]++;
			}
		}
	toposort();
	s = 0, t = _ - 1;
	int sum = 0;
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			int u = id(i, j);
			if (!vis[u])
				continue;
			if (score[u] >= 0)
			{
				Add(s, u, score[u]);
				sum += score[u];
			}
			else
				Add(u, t, -score[u]);
			for (int k = 0; k < out[u].size(); k++)
			{
				int v = out[u][k];
				if (vis[v])
					Add(v, u, 2e9);
			}
		}
	}
	write(sum - dinic());
	return 0;
}
```



---

## 作者：Plozia (赞：1)

宣传博客 $\to$ [link](https://blog.csdn.net/BWzhuzehao/article/details/117524734)

这道题是一道好题目，考察了建模能力。

~~但是因为数据过水导致建模建错都能有 80 分~~

首先我们需要了解一个概念：最大权闭合子图。

---------

什么是最大权闭合子图？

对于一张有向图 $G=<V,E>$，我们从中选出一些点，如果这些点满足以下条件，就称这些点组成的图为闭合子图：

- 对于每一个被选出来的点，其在图 $G$ 中能够到达的点都已经被选出来了。

比如说下面这张图，$(a,b,c,d),(b,c,d)$ 是闭合子图，但是 $(a,c,d)$ 不是，因为 $a$ 能到 $b$，但是 $b$ 并没有被选出来。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210603153930601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JXemh1emVoYW8=,size_16,color_FFFFFF,t_70)

那么最大权闭合子图，就是所有闭合子图中点权最大的闭合子图。

---------

所以最大权闭合子图要怎么求呢？采用最小割模型。

设点 $i$ 的权值为 $val_i$，$s,t$ 是超源超汇。

- 对于每一个点 $u$：
	- 如果 $val_u>0$，那么 $s$ 向 $u$ 连一条流量为 $val_u$ 的边。
	- 如果 $val_u<0$，那么 $u$ 向 $t$ 连一条流量为 $-val_u$ 的边。
	- 如果 $val_u=0$，上述两种连边方式随意选择一种即可。
- 对于原图中存在的每条边 $u \to v$，从 $u$ 向 $v$ 连一条流量为 $INF$ 的边。

在该图上跑最小割即可。

该算法的正确性证明可以参见洛谷用户 @[longlongzhu123](https://www.luogu.com.cn/user/57525) 的[题解](https://www.luogu.com.cn/blog/longlongzhu123/solution-p2805)，这篇题解给出了详细的证明过程。

那么最后最大权闭合子图的点权和就是所有 $val_i>0$ 的和减去最小割。

---------

那么最大权闭合子图跟这道题有什么关系呢？

- 规定 $(i,j)$ 表示第 $i$ 行第 $j$ 列的植物。

分析题意可以发现，要吃掉一株植物，当且仅当这株植物右边的所有植物都被吃掉并且保护它的植物也被吃掉才行。

而我们需要从中选出点权和最大的植物们吃掉，这刚好与最大权闭合子图吻合。

因此我们的建模方式出来了：

- 对于 $(u,v)$，向 $(u,v+1)$ 连边，流量为 $INF$，其中 $1 \leq u \leq n,1 \leq v < m$。
- 如果 $(u,v)$ 保护着 $(x,y)$，那么 $(x,y)$ 向 $(u,v)$ 连边，流量为 $INF$。
- 对于每一个点 $(u,v)$，按照其点权的正负，从超源连边/向超汇连边，流量为 $|val_{(u,v)}|$。

为什么是 $(u,v) \to (u,v+1)$ 而不是 $(u,v+1) \to (u,v)$？因为如果要到 $(u,v)$ 就必须到 $(u,v+1)$。

在建图完毕后，求出最大权闭合子图即可。

---------

但是如果你看到这里就已经开始写代码了，那么你会发现你连样例都过不去。

需要注意的是，如果两个植物互相保护，那么这两个植物是需要踢出我们建的图的，因为我们根本不可能吃掉这两个植物。

同理，成环的植物我们吃不掉，被环上的点保护我们也吃不掉。

~~比如几个无 CD 玉米加农炮互相对准对方不断开炮~~

因此我们首先需要一遍拓扑排序去除这些点。

---------

Code：

```cpp
/*
========= Plozia =========
    Author:Plozia
    Problem:P2805 [NOI2009] 植物大战僵尸
    Date:2021/6/1
========= Plozia =========
*/

#include <bits/stdc++.h>
using std::queue;

typedef long long LL;
const int MAXM = 1000000 + 10, MAXN = 10000 + 10, INF = 0x7f7f7f7f;
int n, m, val[MAXN], cnt_Edge = 1, Head[MAXN], cnt_tp = 1, tp_Head[MAXN], cnt[MAXN], s, t, cur[MAXN];
int dep[MAXN], gap[MAXN];
struct node { int to, val, Next; } tp[MAXM], Edge[MAXM];
bool book[MAXN];
//超源：n * m + 1, 超汇：n * m + 2

int Read()
{
    int sum = 0, fh = 1; char ch = getchar();
    for (; ch < '0' || ch > '9'; ch = getchar()) fh -= (ch == '-') << 1;
    for (; ch >= '0' && ch <= '9'; ch = getchar()) sum = (sum << 3) + (sum << 1) + (ch ^ 48);
    return sum * fh;
}
int Max(int fir, int sec) { return (fir > sec) ? fir : sec; }
int Min(int fir, int sec) { return (fir < sec) ? fir : sec; }
void add_Edge(int x, int y, int z) { ++cnt_Edge; Edge[cnt_Edge] = (node){y, z, Head[x]}; Head[x] = cnt_Edge; }
void tp_add(int x, int y, int z) { ++cnt_tp; tp[cnt_tp] = (node){y, z, tp_Head[x]}; tp_Head[x] = cnt_tp; }
int Change(int x, int y) { return (x - 1) * m + y; }

void Top_sort()
{
    queue <int> q;
    for (int i = 1; i <= n * m; ++i)
        if (cnt[i] == 0) { q.push(i); book[i] = 1; }
    while (!q.empty())
    {
        int x = q.front(); q.pop();
        for (int i = tp_Head[x]; i; i = tp[i].Next)
        {
            int u = tp[i].to; --cnt[u];
            if (cnt[u] == 0) { q.push(u); book[u] = 1; }
        }
    }
}

void bfs()
{
    queue <int> q;
    memset(dep, -1, sizeof(dep));
    q.push(t); dep[t] = 0; ++gap[0];
    while (!q.empty())
    {
        int x = q.front(); q.pop();
        for (int i = Head[x]; i; i = Edge[i].Next)
        {
            int u = Edge[i].to;
            if (dep[u] != -1) continue ;
            dep[u] = dep[x] + 1; ++gap[dep[u]]; q.push(u);
        }
    }
}

int dfs(int now, int Flow)
{
    if (now == t) return Flow;
    int used = 0;
    for (int i = cur[now]; i; i = Edge[i].Next)
    {
        cur[now] = i; int u = Edge[i].to;
        if (Edge[i].val && dep[now] == dep[u] + 1)
        {
            int Minn = dfs(u, Min(Flow - used, Edge[i].val));
            if (Minn)
            {
                Edge[i].val -= Minn; Edge[i ^ 1].val += Minn; used += Minn;
                if (used == Flow) return used;
            }
        }
    }
    --gap[dep[now]];
    if (gap[dep[now]] == 0) dep[s] = n * m + 3;
    ++dep[now]; ++gap[dep[now]];
    return used;
}

int ISAP()
{
    int ans = 0; bfs();
    while (dep[s] < n * m + 2) { for (int i = 1; i <= n * m + 5; ++i) cur[i] = Head[i]; ans += dfs(s, INF); }
    return ans;
}

int main()
{
    n = Read(), m = Read(); s = n * m + 1, t = n * m + 2;
    int sum = 0;
    for (int i = 1; i <= n * m; ++i)
    {
        val[i] = Read();
        int w = Read();
        while (w--)
        {
            int x = Read() + 1, y = Read() + 1;
            tp_add(i, Change(x, y), 0); ++cnt[Change(x, y)];
        }
    }
    for (int i = 1; i <= n; ++i)
        for (int j = m; j > 1; --j)
            { tp_add(Change(i, j), Change(i, j - 1), 0); ++cnt[Change(i, j - 1)]; }
    Top_sort();
    for (int i = 1; i <= n * m; ++i)
    {
        if (val[i] > 0 && book[i]) { add_Edge(s, i, val[i]); add_Edge(i, s, 0); }
        else if (book[i]) { add_Edge(i, t, -val[i]); add_Edge(t, i, 0); }
    }
    for (int i = 1; i <= n * m; ++i)
        if (book[i] && val[i] > 0) sum += val[i];
    for (int i = 1; i <= n * m; ++i)
    {
        if (book[i] == 0) continue ;
        for (int j = tp_Head[i]; j; j = tp[j].Next)
        {
            int u = tp[j].to;
            if (book[u] == 0) continue ;
            add_Edge(u, i, INF); add_Edge(i, u, 0);
        }
    }
    printf("%d\n", sum - ISAP());
    return 0;
}
```

---

## 作者：chenzida (赞：1)

比较简单的网络流题

这题分为两步：拓扑排序和最大权闭合子图。

首先这题会发现是非常像一个最大权闭合子图的板子的，但是有一个地方有区别：这个题如果有循环保护，这些都不能选，而不像最大权闭合子图一样（最大权闭合子图的话可以一起选了）。

所以我们考虑拓扑排序一下，将所有不在环上的点找到，只有这些点是可以被取的。然后直接套最大权闭合子图就好了。

注意一下：拓扑和网络流这两步的建图是有区别的，假设 $A$ 保护 $B$，那么在拓扑的时候要 $A\rightarrow B$，而网络流的时候要 $B\rightarrow A$。

代码如下：
```
#include<bits/stdc++.h>
using namespace std;
const int NR=1005;
const int MR=NR*NR;
const int INF=0x3f3f3f3f;
void Min(int& x,int y){x=min(x,y);}
void Max(int& x,int y){x=max(x,y);}
int n,m,S,T,ans;
int to[MR<<1],nxt[MR<<1],val[MR<<1];
int head[NR];
int tot=1;
void add(int x,int y,int z)
{
	to[tot]=y;
	val[tot]=z;
	nxt[tot]=head[x];
	head[x]=tot++;
}
int Num(int x,int y){return (x-1)*m+y;}
int va[NR];
bool d[NR][NR];
bool flag[NR];
int rd[NR];
int dep[NR],now[NR];
bool bfs()
{
	memset(dep,0,sizeof(dep));
	dep[S]=1;now[S]=head[S];
	queue<int>q;q.push(S);
	while(!q.empty())
	{
		int x=q.front();q.pop();
		for(int i=head[x];i;i=nxt[i])
		{
			int y=to[i];
			if(val[i]&&!dep[y])
			{
				dep[y]=dep[x]+1;
				now[y]=head[y];q.push(y);
				if(y==T)return 1; 
			}
		}
	}
	return 0;
}
int dinic(int x,int flow)
{
	if(x==T)return flow;
	int mxflow=0;
	for(int i=head[x];i;i=nxt[i])
	{
		int y=to[i];now[x]=nxt[i];
		if(flow==mxflow)return flow;
		if(val[i]&&dep[y]==dep[x]+1)
		{
			int num=dinic(y,min(val[i],flow-mxflow));
			mxflow+=num;val[i]-=num;val[i*2-(i^1)]+=num;
			if(!num)dep[y]=0;
		}
	}
	return mxflow;
}
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	n=read(),m=read();S=0,T=n*m+1;
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)
	{
		va[Num(i,j)]=read();int k=read();if(j>1)d[Num(i,j)][Num(i,j-1)]=1;
		while(k--){int x=read()+1,y=read()+1;d[Num(i,j)][Num(x,y)]=1;}
	}
	for(int i=1;i<=n*m;i++)for(int j=1;j<=n*m;j++)rd[j]+=d[i][j];
	queue<int>q;for(int i=1;i<=n*m;i++)if(!rd[i])q.push(i);
	while(!q.empty())
	{
		int x=q.front();q.pop();flag[x]=1;
		for(int i=1;i<=n*m;i++)if(d[x][i])
			if(!(--rd[i]))q.push(i);
	}
	for(int i=1;i<=n*m;i++)for(int j=1;j<=n*m;j++)
		if(flag[i]&&flag[j]&&d[i][j])add(j,i,INF),add(i,j,0);
	for(int i=1;i<=n*m;i++)if(flag[i])
	{
		ans+=max(va[i],0);
		if(va[i]>=0)add(S,i,va[i]),add(i,S,0);
		else add(i,T,-va[i]),add(T,i,0);
	}
	while(bfs())ans-=dinic(S,INF);printf("%d\n",ans);
	return 0;
}
/*
1 3
10 1 0 1
10 0
10 0
*/

---

## 作者：SoyTony (赞：0)

本题有两个限制：攻击与同一行的左右位置关系。

将必须先吃掉的植物向后吃掉的连边，得到一个有向图，跑拓扑排序能得到那些位置是有可能计入贡献的（若某个闭合子图没有入度为 $0$ 的点，则这些位置都无法产生贡献）。

这样一来就是求一个最大权闭合子图了。

先假定选择全部的正权，得到一个和 $sum$。正权点与源点连边，负权点与汇点连边，之后考虑每对攻击关系。当且仅当被限制的点是正权时，才需要最小割的判断，于是应当是被限制点向限制点连无限大容量的边，这样如果被限制为正，限制为负，就产生了一条增广路而需要被割掉。

```cpp
int n,m;
int a[maxn];
#define x first
#define y second
pii p[maxn];
int sum;
struct Graph{
    vector<int> E[maxn];
    int now[25],deg[maxn];
    bool vis[maxn];
    bool chk[maxn];
    int S,T;
    struct edge{
        int to,nxt,lim;
    }e[maxm<<1];
    int head[maxn],cnt=1;
    inline void add_edge(int u,int v,int w){
        // printf("%d %d %d\n",u,v,w);
        e[++cnt].to=v,e[cnt].nxt=head[u];e[cnt].lim=w,head[u]=cnt;
        e[++cnt].to=u,e[cnt].nxt=head[v],e[cnt].lim=0,head[v]=cnt;
    }
    inline void build_graph(){
        for(int i=1;i<=n*m;++i){
            a[i]=read();
            p[i].x=(i-1)/m+1,p[i].y=i-(p[i].x-1)*m;
            if(p[i].y>1){
                E[i].push_back(i-1);
                ++deg[i-1];
            }
            int siz=read();
            for(int j=1;j<=siz;++j){
                int vx=read(),vy=read();
                E[i].push_back(vx*m+vy+1);
                ++deg[vx*m+vy+1];
            }
        }
        for(int i=1;i<=n;++i) now[i]=m;
        queue<int> q;
        for(int i=1;i<=n*m;++i){
            if(!deg[i]) q.push(i);
        }
        while(!q.empty()){
            int u=q.front();
            q.pop();
            chk[u]=1;
            for(int v:E[u]){
                --deg[v];
                if(!deg[v]){
                    q.push(v);
                }
            }
        }
        S=n*m+1,T=n*m+2;
        for(int u=1;u<=n*m;++u){
            // if(!chk[u]) printf("***%d***\n",u);
            if(!chk[u]) continue;
            if(a[u]>0){
                sum+=a[u];
                add_edge(S,u,a[u]);
            }
            else add_edge(u,T,-a[u]);
            for(int v:E[u]){
                if(!chk[v]) continue;
                add_edge(v,u,1e9);
            }
        }
        // printf("\n");
    }
    int cur[maxn],dis[maxn];
    int dfs(int u,int rest){
        if(u==T) return rest;
        int flow=0;
        for(int i=cur[u];i&&rest;i=e[i].nxt){
            cur[u]=i;
            int v=e[i].to,C=min(rest,e[i].lim);
            if(dis[u]+1==dis[v]&&C){
                int k=dfs(v,C);
                flow+=k,rest-=k;
                e[i].lim-=k,e[i^1].lim+=k;
            }
        }
        if(!flow) dis[u]=-1;
        return flow;
    }
    inline int max_flow(){
        int flow=0;
        while(1){
            queue<int> q;
            memcpy(cur,head,sizeof(head));
            memset(dis,-1,sizeof(dis));
            dis[S]=0;
            q.push(S);
            while(!q.empty()){
                int u=q.front();
                q.pop();
                for(int i=head[u];i;i=e[i].nxt){
                    int v=e[i].to;
                    if(dis[v]==-1&&e[i].lim){
                        dis[v]=dis[u]+1;
                        q.push(v);
                    }
                }
            }
            if(dis[T]==-1) return flow;
            flow+=dfs(S,1e9);
        }
    }
}G;
int main(){
    n=read(),m=read();
    G.build_graph();
    printf("%d\n",max(sum-G.max_flow(),0));
    return 0;
}

```

---

## 作者：AIskeleton (赞：0)

[博客园查看](https://www.cnblogs.com/AIskeleton/p/16496473.html)
#### 前置知识：$\text{tarjan}$ 缩点或拓扑排序判环
至少要有一种方法判环。
#### 前置知识：最大权闭合子图
可以看第一篇题解的讲述或者先写一下[模板题](https://www.luogu.com.cn/problem/P3410)。

### 题意：
> [P2805 [NOI2009] 植物大战僵尸](https://www.luogu.com.cn/problem/P2805)

> 在大小为 $N\times M$ 的网格图上，每个点都有一株植物。
> 每株植物都有一个能源值，以及其防御位置集合，能源不保证非负。
> 可以从地图右侧开始攻击，不能经过未被消灭的植物的防御集合。
> 求问攻击最大收益。


> $1\le N\le 20,1\le M\le 30,\left|\text{Score}\right| \le 4000$。

### 题解：
最大权闭合子图的最小割建图可以引申到此题上。

设点 $i$ 权值为 $v_i$，源点和汇点 $s,t$。
- 对于每个点 $u$
  + 若 $v_u>0$，从源点向 $u$ 连一条容量为 $s_u$ 的边。$s \xrightarrow{v_u} u$。
  + 若 $v_u<0$，从 $u$ 向汇点连一条容量为 $s_u$ 的边。$u \xrightarrow{v_u} t$。
- 对于图中原有的边 $u \to v$，两点之间连一条容量无限大的边。$u \xrightarrow{\text{inf}} v$。

由此题的条件：攻击一株植物要先消灭其右边和保护此植物的所有植物，可以发现这和最大闭合子图类似。

所以，先将所有植物按其能源值正负分别向源点或汇点连容量为能源值绝对值的边。
再将每株植物向保护其的所有植物连容量无限大的边，跑最大权闭合子图即可。

最后的答案就是所有**正能源值之和减去最大流**。

但是可能会出现植物无敌的情况，比如两株植物互相保护。

所以要先在建出的图的**反图**上跑拓扑排序，或是 $\text{tarjan}$ 找环后从环上点出发跑 $\text{BFS}$，找到无敌的点。

在网络流建图时，除去无敌的点，而且**正能源值之和**中也不包括无敌点的能源值。

### 代码：
```cpp
#include <bits/stdc++.h>
#define id(x,y) ((x-1)*m+y)
#define V e[i].v
using namespace std;
int rd(){
  int w=0,v=1;
  char c=getchar();
  while(c<'0'||c>'9'){
    if(c=='-')
      v=-1;
    c=getchar();
  }while(c>='0'&&c<='9'){
    w=(w<<1)+(w<<3)+(c&15);
    c=getchar();
  }return w*v;
}const int N=2e5,INF=2e9;
int n,m,st,ed,ans;
int a[1001][1001];
struct E{int v,w,nt;}e[N];
int fir[N],c=1;
void I(int u,int v,int w){
  e[++c]=(E){v,w,fir[u]};
  fir[u]=c;
  e[++c]=(E){u,0,fir[v]};
  fir[v]=c;
}int cur[N],d[N];
queue <int>q;
vector <int>g[N];
bool bfs(){
  for(int i=0;i<=ed;i++){
    cur[i]=fir[i];
    d[i]=0;
  }q.push(st);
  d[st]=1;
  while(!q.empty()){
    int u=q.front();
    q.pop();
    for(int i=fir[u];i;i=e[i].nt)
      if(e[i].w&&!d[V]){
        q.push(V);
        d[V]=d[u]+1;
      }
  }return d[ed];
}int dfs(int u,int fl){
  if(u==ed) 
    return fl;
  int f,s=0;
  for(int i=cur[u];i;i=e[i].nt){
    cur[u]=i;
    if(e[i].w&&d[V]==d[u]+1){
      f=dfs(V,min(e[i].w,fl));
      e[i].w-=f;
      e[i^1].w+=f;
      fl-=f;s+=f;
      if(!fl) break;
    }
  }if(!s) d[u]=0;
  return s;
}int dinic(){
  int ans=0;
  while(bfs())
    ans+=dfs(st,INF);
  return ans;
}int dfn[N],low[N];
int tim,xs,si[N];
bool in[N],tag[N];
int sta[N],tp,now;
void tarjan(int u){
  dfn[u]=low[u]=++tim;
  in[sta[++tp]=u]=1;
  for(auto v:g[u])
    if(!dfn[v]){
      tarjan(v);
      low[u]=min(low[u],low[v]);
    }else if(in[v])
      low[u]=min(low[u],dfn[v]);
  if(dfn[u]==low[u]){
    xs++;now=tp;
    while(sta[tp+1]!=u){
      in[sta[tp--]]=0;
      si[xs]++;
    }if(si[xs]<=1) return ;
    for(int i=tp+1;i<=now;i++){
      tag[sta[i]]=1;
      q.push(sta[i]);
    }
  }
}int main(){
  freopen("test.in","r",stdin);
  n=rd(),m=rd();
  ed=n*m*2;
  for(int i=1;i<=n;i++)
    for(int j=2;j<=m;j++)
      g[id(i,j)].push_back(id(i,j-1));
  for(int i=1;i<=n;i++)
    for(int j=1,k,x,y;j<=m;j++){
      a[i][j]=rd();k=rd();
      while(k--){
        x=rd()+1,y=rd()+1;
        g[id(i,j)].push_back(id(x,y));
      }
    }
  for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
      if(!dfn[id(i,j)])
        tarjan(id(i,j));
  while(!q.empty()){
    int u=q.front();
    q.pop();
    for(auto i:g[u]){
      if(!tag[i]){
        tag[i]=1;
        q.push(i);
      }
    }
  }for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++){
      if(tag[id(i,j)])
        continue;
      if(a[i][j]>0)
        I(st,id(i,j),a[i][j]),ans+=a[i][j];
      if(a[i][j]<0)
        I(id(i,j),ed,-a[i][j]);
    }
  for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
      if(!tag[id(i,j)])
        for(int k:g[id(i,j)])
          if(!tag[k])
            I(k,id(i,j),INF);
  cout<<ans-dinic();
  return 0;
}
```

---

## 作者：Wind_Shear (赞：0)

判强连通环+最大点权闭合图。

我们将每个植物看做一个节点，其权值为score[p]。每个节点向其右侧的节点连边，若节点i保护节点j，则连边j->i，表示：如果选取节点j，就必须选取节点i。点权值有正有负、节点间存在依赖关系，这两个条件提示我们考虑最大权闭合图。于是跑一个最大流即可。

然而不能直接开始跑，有一个重要的预处理过程：假设存在两个节点u、v互相保护，那么我们永远不可能攻下u或v中的任何一个（因为攻击u需要先攻击v，而攻击v又需要先攻击u，显然做不到）。若攻不下u、v，则在u、v左边的节点也一定攻不下（僵尸不能越过u、v节点）；推而广之，对于任意一个点数>=2的强连通分量，及其左边的所有节点，我们都无法攻击，在求最大权闭合图时应将这些节点删除。
关于具体实现方法：为了删除不可达节点，我先反向建图gg：所有点对其左侧节点连边，若i保护j则连边i->j；然后用tarjan算法求出强连通分量；对于每个点数>=2的强连通分量，取出其中任意一点进行DFS，给所有到达的节点打上删除标记。然后，重新建图g：所有点向右连边，若i保护j则连j->i，当然如果i或j被删除了就不连。这些边容量均设为INF，之后的操作就和求最大权闭合图一样了.

DINIC算法我直接粘了模板，tarjan是第一次手写，写得很累。。。
code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int#include<bits/stdc++.h>
using namespace std;
const int maxn=20000;
const int INF=INT_MAX;
struct edge
{
	int from,to,flow,cap;
};
struct edge2 //原图
{
	int from,to;
};
vector<edge> edges;
vector<edge2> edges2;
vector<int> g[maxn],gg[maxn],scc[maxn];
int cur[maxn],d[maxn],w[maxn],p[maxn],sccno[maxn],scc_cnt=0,s=0,t,n,m;
bool vis[maxn],demark[maxn];
stack<int> stk;
int dfs_clock=0;
int dfn[maxn];

void addedge(int u,int v,int c)
{
	edges.push_back((edge){u,v,0,c});
	edges.push_back((edge){v,u,0,0});
	int m=edges.size();
	g[u].push_back(m-2);
	g[v].push_back(m-1);
}

bool bfs() //bfs构建层次图
{
	memset(vis,false,sizeof(vis));
	memset(d,-1,sizeof(d));
	queue<int> q;
	q.push(s);
	vis[s]=true;
	d[s]=0;
	while(!q.empty()){
		int x=q.front(); q.pop();
		for(int i=0;i<g[x].size();i++){
			edge& e=edges[g[x][i]];
				if((!vis[e.to]) && e.cap>e.flow){
					vis[e.to]=true;
					d[e.to]=d[x]+1;
					q.push(e.to);
				}
			}
		}
	return vis[t];
}

int dfs(int x,int a) //dfs沿阻塞流增广,返回可增广值
{
	if(x==t||a==0)
		return a;
	int flow=0,f;
	for(int& i=cur[x];i<g[x].size();i++){
		edge& e=edges[g[x][i]];
		if(d[x]+1==d[e.to]&&(f=dfs(e.to,min(a,e.cap-e.flow)))>0){
			e.flow+=f;
			edges[g[x][i]^1].flow-=f;
			flow+=f;
			a-=f;
			if(a==0) break;
			}
		}
	return flow;
}

int tarjan(int u)
{
int lowu=dfn[u]=++dfs_clock;
	stk.push(u);
	for(int i=0;i<gg[u].size();i++){
		edge2& e=edges2[gg[u][i]];
		if(!dfn[e.to]){
			int lowv=tarjan(e.to);
		lowu=min(lowu,lowv);
		}
		else if(!sccno[e.to]){
			lowu=min(lowu,dfn[e.to]);
	}
}
if(lowu==dfn[u]){
	scc_cnt++;
	int y;
	do{
		y=stk.top(); stk.pop();
		sccno[y]=scc_cnt;
		scc[scc_cnt].push_back(y);
	}while(y!=u);
	}
	return lowu;
}

void mark(int u)
{
	demark[u]=true;
	for(int i=0;i<gg[u].size();i++){
		edge2& e=edges2[gg[u][i]];
		if(!demark[e.to])
		mark(e.to);
	}
}

int main()
{
	cin>>n>>m;
	t=n*m+1;
	for(int i=1;i<=m*n;i++)
	{
		int num;
		scanf("%d%d",&w[i],&num);
		if((i-1)%m!=0){
			int x=edges2.size();
			gg[i].push_back(x);
			edges2.push_back((edge2){i,i-1}); //每个点向左边的点连边
		}
		for(int j=0;j<num;j++){
			int r,c,tmp,x=edges2.size();
			scanf("%d%d",&r,&c);
			tmp=r*m+c+1;
			gg[i].push_back(x);
			edges2.push_back((edge2){i,tmp});
		}
	}
	/*跑强连通分量*/
	for(int i=0;i<stk.size();i++)
		stk.pop();
	memset(dfn,0,sizeof(dfn));
	memset(sccno,0,sizeof(sccno));
	for(int i=0;i<maxn;i++)
		scc[i].clear();
	for(int i=1;i<=m*n;i++){
		if(!dfn[i]){
			tarjan(i);
		}
	}
	memset(demark,false,sizeof(demark));
	for(int i=1;i<=scc_cnt;i++){
		if(scc[i].size()==1)
			continue;
		int x=scc[i][0];
		mark(x);
	}
	/*建新图*/
	int tot=0;
	for(int i=1;i<=m*n;i++){
		if(demark[i])
			continue;
		if(w[i]>=0){
			addedge(s,i,w[i]);tot+=w[i];
		}
	else 
		addedge(i,t,-w[i]);
	for(int j=0;j<gg[i].size();j++){
		edge2& e=edges2[gg[i][j]];
		if(demark[e.to])
			continue;
		addedge(e.to,i,INF); //反连边
		}
	}
	int flow=0;
	while(bfs()){
		memset(cur,0,sizeof(cur));
		flow+=dfs(s,INF);
	}
	cout<<tot-flow<<endl;
	return 0;
} maxn=20000;
const int INF=INT_MAX;
struct edge
{
	int from,to,flow,cap;
};
struct edge2 //原图
{
	int from,to;
};
vector<edge> edges;
vector<edge2> edges2;
vector<int> g[maxn],gg[maxn],scc[maxn];
int cur[maxn],d[maxn],w[maxn],p[maxn],sccno[maxn],scc_cnt=0,s=0,t,n,m;
bool vis[maxn],demark[maxn];
stack<int> stk;
int dfs_clock=0;
int dfn[maxn];

void addedge(int u,int v,int c)
{
	edges.push_back((edge){u,v,0,c});
	edges.push_back((edge){v,u,0,0});
	int m=edges.size();
	g[u].push_back(m-2);
	g[v].push_back(m-1);
}

bool bfs() //bfs构建层次图
{
	memset(vis,false,sizeof(vis));
	memset(d,-1,sizeof(d));
	queue<int> q;
	q.push(s);
	vis[s]=true;
	d[s]=0;
	while(!q.empty()){
		int x=q.front(); q.pop();
		for(int i=0;i<g[x].size();i++){
			edge& e=edges[g[x][i]];
				if((!vis[e.to]) && e.cap>e.flow){
					vis[e.to]=true;
					d[e.to]=d[x]+1;
					q.push(e.to);
				}
			}
		}
	return vis[t];
}

int dfs(int x,int a) //dfs沿阻塞流增广,返回可增广值
{
	if(x==t||a==0)
		return a;
	int flow=0,f;
	for(int& i=cur[x];i<g[x].size();i++){
		edge& e=edges[g[x][i]];
		if(d[x]+1==d[e.to]&&(f=dfs(e.to,min(a,e.cap-e.flow)))>0){
			e.flow+=f;
			edges[g[x][i]^1].flow-=f;
			flow+=f;
			a-=f;
			if(a==0) break;
			}
		}
	return flow;
}

int tarjan(int u)
{
int lowu=dfn[u]=++dfs_clock;
	stk.push(u);
	for(int i=0;i<gg[u].size();i++){
		edge2& e=edges2[gg[u][i]];
		if(!dfn[e.to]){
			int lowv=tarjan(e.to);
		lowu=min(lowu,lowv);
		}
		else if(!sccno[e.to]){
			lowu=min(lowu,dfn[e.to]);
	}
}
if(lowu==dfn[u]){
	scc_cnt++;
	int y;
	do{
		y=stk.top(); stk.pop();
		sccno[y]=scc_cnt;
		scc[scc_cnt].push_back(y);
	}while(y!=u);
	}
	return lowu;
}

void mark(int u)
{
	demark[u]=true;
	for(int i=0;i<gg[u].size();i++){
		edge2& e=edges2[gg[u][i]];
		if(!demark[e.to])
		mark(e.to);
	}
}

int main()
{
	cin>>n>>m;
	t=n*m+1;
	for(int i=1;i<=m*n;i++){
	int num;
	scanf("%d%d",&w[i],&num);
	if((i-1)%m!=0){
	int x=edges2.size();
	gg[i].push_back(x);
	edges2.push_back((edge2){i,i-1}); //每个点向左边的点连边
	}
	for(int j=0;j<num;j++){
	int r,c,tmp,x=edges2.size();
	scanf("%d%d",&r,&c);
	tmp=r*m+c+1;
	gg[i].push_back(x);
	edges2.push_back((edge2){i,tmp});
	}
	}
	/*跑强连通分量*/
	for(int i=0;i<stk.size();i++)stk.pop();
	memset(dfn,0,sizeof(dfn));
	memset(sccno,0,sizeof(sccno));
	for(int i=0;i<maxn;i++)scc[i].clear();
	for(int i=1;i<=m*n;i++){
	if(!dfn[i]){
	tarjan(i);
	}
	}
	memset(demark,false,sizeof(demark));
	for(int i=1;i<=scc_cnt;i++){
	if(scc[i].size()==1)continue;
	int x=scc[i][0];
	mark(x);
	}
	/*建新图*/
	int tot=0;
	for(int i=1;i<=m*n;i++){
	if(demark[i])continue;
	if(w[i]>=0){addedge(s,i,w[i]);tot+=w[i];}
	else addedge(i,t,-w[i]);
	for(int j=0;j<gg[i].size();j++){
	edge2& e=edges2[gg[i][j]];
	if(demark[e.to])continue;
	addedge(e.to,i,INF); //反连边
	}
	}
	int flow=0;
	while(bfs()){
		memset(cur,0,sizeof(cur));
		flow+=dfs(s,INF);
	}
	cout<<tot-flow<<endl;
	return 0;
}

```

# 转自Lofter

---

## 作者：天泽龟 (赞：0)

## 分析：
撇开乱七八糟的操作，提供一份十分清爽的题解。

这题的难点，仅仅是**建图！建图！！建图！！！**

- ### 第一张图：

超源连向所有行的右手第一格，然后按顺序连接格子，由于不是最终建图所以没有边权，点权是当前的能源价值，最后连到超汇。

当然，可能点对之间存在保护关系，于是从保护方向被保护方连边。

- ### 第二张图：

我们发现这个DAG里出现本该没有的自环，我们可以知道原本子环内以及子环后可以到的点现在都到不了了，因为如果要到达就必须经过那个环，而环内植物可以两两保护。。

于是我们就可以缩点了，别惊讶，缩点是图论里的重要算法，这正体现了本题极高的综合性。

缩完点我们可以利用深搜来标记子环及子环后的点（除超汇），把他们通过打标记给删掉。

- ### 第三张图：

如果你要吃了某个植物，那首先你要把保护它的所有植物吃掉才行，这让你想到啥？

没错，最大权独立子图的定义即是如此。

于是我们把边全部反向，按照求最大权独立子图的方案建图（正点权连超源，负点权连超汇，原本边无限流），然后跑完直接正点权和-最小割即可。

值得一提的是，原来的超源和超汇作为点权为0的点，仍要作为原来图的一部分参与网络流。

然后就没啦，代码又臭又长就不放了。

---

## 作者：kkxhh (赞：0)

从 $s$ 向正权点连边，负权点向 $t$ 连边，容量为点权的绝对值。如果两个点间有依赖关系，则从拓扑序大的点连一条容量为 $INF$ 的边到拓扑序小的点

注意有的点是不可达到的，预先做一遍拓扑排序去掉这些点

跑一遍最大流，则答案为**所有可到达正权点权值和-最大流**

考虑为什么可以这样做

我们知道**最大流=最小割**

对于我们建出来的这张图，可以发现割掉正权点连 $s$ 的边相当于舍弃这个点的分数，割掉负权点连 $t$ 的边相当于付出这个点的代价。

同时我们从拓扑序大的点连了一条边到拓扑序小的边，这样做有什么用呢？我们可以这样考虑，如果在图中有 $s \longrightarrow t$ 的路径，那么这条路径上肯定有拓扑序大的正权点和拓扑序小的负权点，所以此时你要么放弃正权点的收益，要么付出负权点的代价~~（不然不给前面的钱还拿后面的分不就是白piao吗qwq）~~，于是可以发现一个合法的情况必然是没有从 $s$ 到 $t$ 的路径的，于是我们就可以把问题转化成求这张图的最小割

代码写的不太好看~~（不过明白了思路写起来也并不困难吧qwq）~~

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

typedef struct edge{
    int from,to,cap,next;
}edge;

typedef struct TP{
    int to,next;
}TP;

const int INF=1000000000;
edge e[1000010];
TP et[1000010];
int n,m,s,t,head[610],tot=1,thead[610],ttot,d[610],cur[610],q[610],hd,tl,w,id[30][40],a[30][40],cnt,in[610],tq[610],thd=1,ttl,tag[610],ans;

inline int read(){
    int num=0,k=1; char c=getchar();
    while(c>'9' || c<'0') k=(c=='-')?0:k,c=getchar();
    while(c>='0' && c<='9') num=num*10+c-'0',c=getchar();
    return k?num:-num;
}

void addedge(int u,int v,int cap){
    e[++tot].from=u; e[tot].to=v; e[tot].cap=cap; e[tot].next=head[u]; head[u]=tot;
    e[++tot].from=v; e[tot].to=u; e[tot].cap=0; e[tot].next=head[v]; head[v]=tot;
}

void addTP(int u,int v) {et[++ttot].to=v; et[ttot].next=thead[u]; thead[u]=ttot;}

int bfs(){
    for(int i=1;i<=n*m+2;i++) d[i]=0;
    d[s]=1; hd=1; tl=0;
    q[++tl]=s;
    while(hd<=tl){
        int x=q[hd++];
        for(int i=head[x],to;i;i=e[i].next){
            to=e[i].to;
            if(!e[i].cap || d[to]) continue;
            d[to]=d[x]+1; q[++tl]=to;
        }
    }
    return d[t];
}

int dfs(int x,int flow){
    if(x==t || !flow) return flow;
    int used=0;
    for(int i=cur[x],to,f;i;i=e[i].next){
        to=e[i].to;
        if(!e[i].cap || d[to]!=d[x]+1) continue;
        f=dfs(to,min(e[i].cap,flow-used));
        e[i].cap-=f; e[i^1].cap+=f; used+=f;
        if(used==flow) break;
        cur[x]=e[i].next;
    }
    return used;
}

int dinic(){
    int ans=0;
    while(bfs()){
        for(int i=1;i<=n*m+2;i++) cur[i]=head[i];
        ans+=dfs(s,INF);
    }
    return ans;
}

int main(){
    n=read(); m=read();
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) id[i][j]=++cnt;
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
        a[i][j]=read();
        int ds=read(),dx,dy;
        while(ds--) {dx=read(); dy=read(); addTP(id[i][j],id[dx+1][dy+1]); in[id[dx+1][dy+1]]++;}
        if(j<m) {addTP(id[i][j+1],id[i][j]); in[id[i][j]]++;}
    }
    for(int i=1;i<=cnt;i++) if(!in[i]) tq[++ttl]=i,tag[i]=1;
    while(thd<=ttl){
        int x=tq[thd++];
        for(int i=thead[x],to;i;i=et[i].next){
            to=et[i].to;
            in[to]--;
            if(!in[to]) tq[++ttl]=to,tag[to]=1;
        }
    }
    s=++cnt; t=++cnt;
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) if(tag[id[i][j]]){
        if(a[i][j]>=0) {addedge(s,id[i][j],a[i][j]); ans+=a[i][j];}
        else addedge(id[i][j],t,-a[i][j]);
        for(int k=thead[id[i][j]],to;k;k=et[k].next){
            to=et[k].to;
            addedge(to,id[i][j],INF);
        }
    }
    printf("%d",ans-dinic());
    return 0;
}
```

---

## 作者：Wings (赞：0)

# 题意
在$n \times m$的场地上放满了植物，每个植物有一个权值，有正有负。有些植物可以保护一些植物不被吃。僵尸只能从右边进入场地，要吃掉右边的才能吃左边的。求一个吃植物的方案，使得吃掉的植物的总权值最大。

# 头脑风暴
首先可以很明显地发现，“阻挡”和“保护”的性质一样，我们把“阻挡”也看做“保护”即可。这样一来从右边进入的条件就没用了。

再看看“保护”的实质：如果$u$保护$v$，那么要吃$v$，就一定要吃$u$。这样一来就可以转化到“最大权闭合子图”的模型上来。

但是还差一点。看样例就知道，可能出现“互相保护”的情况，即这些点无论如何都不能吃。而在最大权闭合子图的建图方式中，已经假设正权点选了，这样如果有一个正权点被“互相保护”，不能选它，和我们的建图矛盾了。下面有两种思考方法
1. 在建图之前把不能吃的点删去
2. 在建完图后，这些不能选的正权点一定要割掉，不能选的负权点一定不能割掉。

在分析这两种方法之前，先看看“互相保护”是什么情况：如果u不能选，那么他一定被v保护，v一定被另外一个点保护……这样一来如果都被保护了，就不能选。可以发现，保护关系构成了一个环，环中的点都不能选。

先看看删去。只要找到所有环上的的所有点，然后在建图的时候不考虑这些点即可。这样做的话要建两张图，第一张找环，第二张建图。

再来看看割掉和不割掉。怎么样才能把一个正权点割掉呢？根据最小割的性质，割掉一个边，当且仅当他是某一条s-t的路径上的最小边(这里只考虑一条路径)。那么我只要让他成为一条s-t的路径上最小的边就可以了。这很好办，这个点向t连一条容量为$∞$的边即可。那怎么样才能不把一个负权点割掉呢？还是根据最小割的性质，一条边不割掉，当且仅当他不是一条s-t的路径上的最小边(还是只考虑一条路径)。这也好办，把这条边的容量改为$∞$就行了。可以直接修改容量，也可以连一条边到t，容量为$∞$。用后一种方法的话可以和正权点的操作统一。这样一来，只要一个点不能被吃，就把他连一条到t的边，容量为$∞$。这样做我们只要在网络上找环，找到就修改就可以了。

由于第二种只用建一张图，所以这里用的是第二种方法。

# 做法总结

先建图，最大权闭合子图的建图方法。然后在图上跑Tarjan找环，把环中的所有点连一条向t的$∞$边。最后跑最大流。

注意在网络中，边是有反向边的，跑Tarjan时要用正向边，即下标为偶数的边。还要注意Tarjan求的是scc，scc中只有一个点，那么不是环。

# 方法挖掘
1. 转化成网络流模型
2. 一点一点分析，总会分析出来的(每次写总结时分析都比做题时好得多得多的多得多，如果写题时也可以做到这么分析就好了T_T)

# 代码实现
```
#include <bits/stdc++.h>
#define VI vector<int>
#define ALL(x) x.begin(), x.end()
#define PB push_back
#define PII pair<int, int>
#define ST first
#define ND second
#define MP make_pair
#define LL long long
#define LD long double
#define FOR(i, n, m) for (int i = n; i <= m; i++)
#define FORN(i, n, m) for (int i = n; i >= m; i--)
#define MEM(x, y) memset(x, y, sizeof(x))
using namespace std;

const int INF = 0x3f3f3f3f;
const int P = 1e9+7;
const int maxn = 610;
const int maxm = 4e5+10;

int n, m, s, t, sum = 0;

int read() {
	int ans = 0, neg = 1;
	char c = getchar();
	while (!isdigit(c) && c != '-') 
		c = getchar();
	if (c == '-') {
		neg = -1;
		c = getchar();
	}
	while (isdigit(c)) {
		ans = ans * 10 + c - '0';
		c = getchar();
	}
	return ans * neg;
}

struct Edge {
	int to, next, flow, cap;
} edges[maxm];
int first[maxn], mm = 0;

void AddEdge(int u, int v, int cap) {
	edges[mm] = Edge{v, first[u], 0, cap};
	first[u] = mm++;
}

void AddNet(int u, int v, int cap) {
	AddEdge(u, v, cap);
	AddEdge(v, u, 0);
}

void Init() {
	MEM(first, -1);
	s = 0, t = n*m+1;
}

int id(int r, int c) {
	return r * m + c + 1;
}

int dfn[maxn], low[maxn], ind = 0, ins[maxn];
stack<int> stk;
void Tarjan(int u) {
	dfn[u] = low[u] = ++ind;
	stk.push(u), ins[u] = 1;
	for (int i = first[u]; ~i; i = edges[i].next) if (!(i&1)) {
		Edge &e = edges[i];
		if (!dfn[e.to]) {
			Tarjan(e.to);
			low[u] = min(low[u], low[e.to]);
		}
		else if (ins[e.to])
			low[u] = min(low[u], low[e.to]);
	}
	if (low[u] == dfn[u]) {
		if (stk.top() != u) {
			AddNet(u, t, INF);
			while (!stk.empty() && stk.top() != u) {
				int v = stk.top();
				stk.pop(), ins[v] = 0;
				AddNet(v, t, INF);
			}
		}
		stk.pop();
		ins[u] = 0;
	}
}

int d[maxn];
bool bfs() {
	queue<int> Q;
	MEM(d, INF);
	d[s] = 0;
	Q.push(s);
	while (!Q.empty()) {
		int u = Q.front();
		Q.pop();
		for (int i = first[u]; ~i; i = edges[i].next) {
			Edge &e = edges[i];
			if (d[e.to] >= INF && e.cap > e.flow) {
				d[e.to] = d[u] + 1;
				Q.push(e.to);
			}
		}
	}
	return d[t] < INF;
}

int cur[maxn];
int dfs(int u, int a) {
	if (u == t || 0 == a)
		return a;
	int f = 0, flow = 0;
	for (int &i = cur[u]; ~i; i = edges[i].next) {
		Edge &e = edges[i];
		if (d[e.to] == d[u] + 1) {
			f = dfs(e.to, min(a, e.cap - e.flow));
			if (f > 0) {
				e.flow += f;
				edges[i^1].flow -= f;
				a -= f;
				flow += f;
				if (a <= 0)
					break;
			}
		}
	}
	if (a)
		d[u] = -1;
	return flow;
}

int Dinic() {
	int flow = 0;
	while (bfs()) {
		FOR (i, s, t) cur[i] = first[i];
		flow += dfs(s, INF);
	}
	return flow;
}

int main() {
	n = read(), m = read();
	Init();
	FOR (i, 0, n-1) FOR (j, 0, m-1) {
		int w = read(), p = read();
		if (w >= 0) {
			AddNet(s, id(i, j), w);
			sum += w;
		}
		else 
			AddNet(id(i, j), t, -w);
		FOR (k, 1, p) {
			int r = read(), c = read();
			AddNet(id(r, c), id(i, j), INF);
		}
		if (j < m-1) 
			AddNet(id(i, j), id(i, j+1), INF);
	}
	Tarjan(s);
	printf("%d", sum - Dinic());
	return 0;
}
```

---

## 作者：ysy20021208 (赞：0)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**分析与题解：**这道题目是一道经典的最大权闭合子图，对于每一个植物我们首先想到应该是向上一道题一样，正连$S$，负连$T$，植物之间互相连。现在讨论一下植物之间连边的情况。对于两个植物$x$和$y$，如果$x$保护$y$，则在吃掉$y$之前一定要吃掉$x$，所以我们要从$y$向$x$连一条边，边权为$inf$。题中说了，僵尸只能从右侧进入，并且吃能横着走，所以这相当于要吃掉当前的植物，就必须要吃掉当前植物右面的植物，所以我们还需要将当前植物向他右面的植物连上一条边，边权为$inf$。这样我们就可以在建完的图上跑最大权闭合子图。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这样建图有问题，现在有一种情况：$x$植物保护$y$植物，并且$y$植物还保护$x$植物。在这种情况下，$x$和$y$都是不能被吃掉的，并且他们保护的所有植物都不能被吃掉。但是在我们上述的建图中，这种情况是不能判断出来的，这个环和之后的点是能够被吃掉的，所以我们要更改一下建图。我们在建图之前应该先判断这个点是否有资格被吃掉。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于$x$保护$y$，我们从$x$向$y$连一条有向边。在连完所有的边之后，跑拓扑序，若当前点能进入到队列里，这个点才能被建到最大权闭合子图的全图中，反之则不能。这样更改后的图才是一个可以运用的图。

```c++
// luogu-judger-enable-o2
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define N 1010
#define inf 1000000000
int n,m,s,t,idx,num[N],belong[N],have[N][N],dis[N],ans;
int cur[N],head[N],to[N*N],nxt[N*N],val[N*N],in[N];bool is[N];
int pla(int a,int b) {return (a-1)*m+b;}
void add(int a,int b,int c)
    {nxt[++idx]=head[a],to[idx]=b,val[idx]=c,head[a]=idx;}
void build()
{
    queue <int> q;
    for(int i=1;i<=n*m;i++) for(int j=1;j<=belong[i];j++)
        add(i,have[i][j],0),in[have[i][j]]++;
    for(int i=1;i<=n*m;i++) if(!in[i]) q.push(i),is[i]=true;
    while(!q.empty())
    {
        int p=q.front();q.pop();
        for(int i=head[p];i;i=nxt[i])
            {in[to[i]]--; if(!in[to[i]]) q.push(to[i]),is[to[i]]=true;}
    } idx=1;
    memset(head,0,sizeof head),memset(to,0,sizeof to);
    memset(nxt,0,sizeof nxt),memset(val,0,sizeof val);
}
void init()
{
    for(int i=1;i<=n*m;i++)
    {
        if(!is[i]) continue;
        if(num[i]<0) add(i,t,-num[i]),add(t,i,0);
        else add(s,i,num[i]),add(i,s,0),ans+=num[i];
    }
    for(int i=1;i<=n*m;i++)
    {
        if(!is[i]) continue;
        for(int j=1;j<=belong[i];j++)
            if(is[have[i][j]]) add(i,have[i][j],0),add(have[i][j],i,inf);
    }
}
bool bfs()
{
    memset(dis,-1,sizeof dis);
    queue <int> q; q.push(s),dis[s]=0;
    while(!q.empty())
    {
        int p=q.front();q.pop();
        if(p==t) return true;
        for(int i=head[p];i;i=nxt[i])
            if(val[i]>0&&dis[to[i]]==-1)
                dis[to[i]]=dis[p]+1,q.push(to[i]);
    } return false;
}
int dfs(int p,int flow)
{
    int now,temp=flow;
    if(p==t) return flow;
    for(int i=cur[p];i;i=nxt[i])
        if(val[i]>0&&dis[to[i]]==dis[p]+1)
        {
            now=dfs(to[i],min(val[i],temp));
            if(!now) dis[to[i]]=-1;
            temp-=now,val[i]-=now,val[i^1]+=now;
            if(val[i]) cur[p]=i;
            if(!temp) break;
        } return flow-temp;
}
void dinic() {while(bfs()) memcpy(cur,head,sizeof cur),ans-=dfs(s,inf);}
int main()
{
    scanf("%d%d",&n,&m),s=n*m+1,t=n*m+2;
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)
    {
        scanf("%d%d",&num[pla(i,j)],&belong[pla(i,j)]);
        for(int k=1,a,b;k<=belong[pla(i,j)];k++)
            scanf("%d%d",&a,&b),have[pla(i,j)][k]=pla(a+1,b+1);
        if(j>1) have[pla(i,j)][++belong[pla(i,j)]]=pla(i,j-1);
    } build(),init(),dinic(),printf("%d\n",max(ans,0));
}
```

---

## 作者：AubRain (赞：0)

## 最大权闭合子图

首先植物之间是有保护关系的，我们要先把哪些植物能被吃找出来。

具体来说，每一列的植物会保护左边一列的植物，再加上题目输入的保护关系。如果植物 $A$ 保护植物 $B$ ，就代表必须先吃掉 $A$ 再吃 $B$ ，就让 $A$ 向 $B$ 连一条边。

然后保护是能成环的，所以有些植物是无敌的。现用 $Tarjan$ 缩一下环，如果强联通分量的 $size>1$ 那么这个强联通分量里的点都是无敌的，这些点能到达的所有点也是无敌的， $bfs$ 一下即可。 

然后就是最大权闭合子图的模板了，如果一个点要选，那么保护他的点必须选。直接网络流即可。

```cpp
#include<bits/stdc++.h>
#define s 601
#define t 602
#define N 605
#define pb push_back
#define num(i,j) ((i-1)*m+j)
#define INF 1<<29
using namespace std;

inline void rd(int &X){
    X=0;int w=0;char ch=0;
    while(!isdigit(ch))w|=ch=='-',ch=getchar();
    while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    X=w?-X:X;
}

queue<int> q;
vector<int> g[N];
int n,m,ans,f,k,tot;
struct nd{int nxt,to,v;}e[500000];
int dfn[N],low[N],stk[N],top,ok[N];
int head[N],cnt=1,d[N],val[N],in[N];
#define For(x) for(int y,i=head[x];(y=e[i].to);i=e[i].nxt)

void add(int x,int y,int w){
    e[++cnt]=(nd){head[x],y,w};head[x]=cnt;
    e[++cnt]=(nd){head[y],x,0};head[y]=cnt;
}
bool bfs()
{
    queue<int> q; q.push(s);
    memset(d,0,sizeof d); d[s]=1;
    while(!q.empty()){
        int x=q.front();q.pop();
        For(x) if(e[i].v&&!d[y]){
            q.push(y); d[y]=d[x]+1;
            if(y==t) return 1;
        }
    } return 0;
}

int dinic(int x,int flow)
{
    if(x==t) return flow; int re=flow;
    for(int y,i=head[x];(y=e[i].to)&&re;i=e[i].nxt)
        if(e[i].v&&d[y]==d[x]+1)
        {
            k=dinic(y,min(re,e[i].v));
            if(!k) d[y]=0;
            e[i].v-=k;e[i^1].v+=k;re-=k; 
        }
    return flow-re;
}
void tarjan(int x)
{
	low[x]=dfn[x]=++tot;
	stk[++top]=x;in[x]=1;
	for(int y:g[x]) 
		if(!dfn[y]) tarjan(y),low[x]=min(low[x],low[y]);
		else if(in[y]) low[x]=min(low[x],dfn[y]);
	if(low[x]==dfn[x]){
		int y,now=top,num=0;
		do{
			y=stk[top--];num++;in[y]=0;
		}while(x!=y);
		if(num==1) return ;
		for(int i=top+1;i<=now;i++)
			ok[stk[i]]=1,q.push(stk[i]);
	}
		
}
void build()
{
	rd(n);rd(m);
	for(int i=1;i<=n;i++)
		for(int j=2;j<=m;j++)
			g[num(i,j)].pb(num(i,j-1));
	n*=m;
	for(int x,y,l,i=1;i<=n;i++){
		rd(val[i]);rd(l);
		while(l--) rd(x),rd(y),x++,y++,g[i].pb(num(x,y));
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i]) tarjan(i);
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int y:g[x]) if(!ok[y])
			ok[y]=1,q.push(y);
	}
	for(int i=1;i<=n;i++)
		if(!ok[i]) {
			if(val[i]>0) add(s,i,val[i]),ans+=val[i];
			if(val[i]<0) add(i,t,-val[i]);
		}
	for(int x=1;x<=n;x++) if(!ok[x])
		for(int y:g[x]) if(!ok[y])
			add(y,x,INF);
			
}
int main()
{
    build();
    while(bfs())
        while(f=dinic(s,INF))
            ans-=f;
    cout<<ans;
}
```

---

## 作者：Сталин (赞：0)

~~蒟蒻第一篇题解~~


**思路借~~chao~~鉴~~xi~~**  **BJpers2** 巨佬[(原文)](https://www.luogu.org/blog/contributation/solution-p2805)
只是~~也许~~代码更易懂 dalao请跳过~~QAQ~~


看很多大佬都说的是“最大权闭合子图”，蒟蒻不是很懂，这里用一种比较通俗的方法见一下这道题,不用tarjan,不用扫环。

 玩过原游戏中“我是僵尸”模式的人应该都有经验，我们每次都让僵尸去吃没有保护的植物即可。
 - 因此我们直观的让**保护者**向**被保护者**连边，.
 - **在任意时刻**，假如某**株植物没有连向它的边**了(没有保护了)，那么它就**可以成为我们攻击的对象**。
 - 我们从一开始从**入度为0的点开始搜索**(因为边的方向是保护者-->被保护者)，对**它的所有处边上的点入度减一**，如果减到零就把它入队。

这十分类似于我们所学过的拓扑排序，而且这样做巧妙地把可能被我们攻击的植物都筛出来了。



接下来就是套路了，我们还是将正权连源点，负权连汇点，拓扑序小的连上拓扑序大，跑一遍dinic或isap就行了。


code:

```cpp
//蒟蒻不会最大闭合子图、拓扑排序。。。只能膜题解写了个。。。emm
//参(chao)考(xi)博客from:    BJpers2 
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m;
int ys[21][31],c[610];//将图转化成点 
struct edge//连接初始的边 (代替拓扑排序) 
{
	int to,next;
}e[1110000]; int elen,elast[610];//开大点总没坏处(雾)
int rd[610];//入度，相当于此植物被多少个植物保护着 
int list[610],head,tail;//队列,处理伪拓扑

void addTP(int from,int to)//(伪)拓扑 建边 
{//把当前植物连向被保护的植物，(伪)拓扑时要用 
	elen++; e[elen].to=to;
	e[elen].next=elast[from]; elast[from]=elen;
	rd[to]++;
}

int id[610];//储存每个点网络流的编号(若值为0可能是不在图内)
int tp[610];//记录网络流节点的原始编号 
struct node
{
	int x,y,c,next,other;
}a[1110000]; int alen,alast[610];
int st,ed;

void ins(int x,int y,int c)
{
	alen++; int len1=alen;
	a[alen].x=x; a[alen].y=y; a[alen].c=c;
	a[alen].next=alast[x]; alast[x]=alen;
	
	alen++; int len2=alen;
	a[alen].x=y; a[alen].y=x; a[alen].c=0;
	a[alen].next=alast[y]; alast[y]=alen;
	
	a[len1].other=len2;
	a[len2].other=len1;
}

int h[610];//层次，list已设 
bool bfs()
{
	head=tail=1; list[1]=st;
	memset(h,0,sizeof(h)); h[st]=1;
	while(head<=tail)
	{
		int x=list[head++];
		for(int k=alast[x];k;k=a[k].next)
		{
			int y=a[k].y;
			if(h[y]==0 && a[k].c>0)
			{
				h[y]=h[x]+1;
				list[++tail]=y;
			}
		}
	}
	if(h[ed])return true;
	else return false;
}

int dfs(int x,int f)//在x点携带着f的流量 
{
	if(x==ed)return f;
	int s=0,t;
	for(int k=alast[x];k;k=a[k].next)
	{
		int y=a[k].y;
		if(h[y]==h[x]+1 && a[k].c>0 && s<f)
		{
			s+=( t=dfs(y,min(a[k].c,f-s)) );
			a[k].c-=t; a[ a[k].other ].c+=t;
		}
		if(s==f)break; 
	}
	if(s==0)h[x]=0;//没流量，x从此不可走 
	return s;
}

int main()
{
	scanf("%d%d",&n,&m);
	int tot=0;
	for(int i=0;i<n;i++)
		for(int j=0;j<m;j++)
			ys[i][j]=++tot; //转化为点 
	
	int now,x,y,cnt; elen=0; memset(elast,0,sizeof(elast));
	for(int i=0;i<n;i++)
		for(int j=0;j<m;j++)
		{
			now=ys[i][j];
			if(j)addTP(now,ys[i][j-1]);
			scanf("%d%d",&c[now],&cnt);
			while(cnt--)
			{
				scanf("%d%d",&x,&y);
				addTP(now,ys[x][y]);
			}
		}
	
	head=1,tail=0; memset(id,0,sizeof(id)); cnt=0;//重复利用cnt,此处是网络流的编号 
	for(int i=1;i<=tot;i++)if(rd[i]==0)list[++tail]=i;//初始可以到达的点 
	while(head<=tail)//(伪)拓扑，找出(僵尸不择手段的进攻后)可以到达的点，避免处理环
	{
		now=list[head++];
		id[now]=++cnt; tp[cnt]=now;//处理编号，详见定义
		for(int k=elast[now];k;k=e[k].next)
		{
			int to=e[k].to;
			rd[to]--;//既然now植物可以被啃掉,to植物就少了一个屏障
			if(rd[to]==0)list[++tail]=to;//多了一个可以吃的植物 
		}
	}
	alen=0; memset(alast,0,sizeof(alast)); st=cnt+1,ed=cnt+2;//设立终极源点和终极汇点
	int sum=0;
	//注意一下编号(有点迷), ins建网络流要用上面(伪拓扑)找出的编号,c数组用的是原来的编号 
	for(int i=1;i<=cnt;i++)
	{
		now=tp[i];//找回原来的编号,因为c的下标存的还是原来的编号
		if(c[now]>0)
		{
			ins(st,i,c[now]);//正值点和源点连一条正值的边 
			sum+=c[now];//能到达的点 的正权值和 
		}
		else if(c[now]<0)ins(i,ed,-c[now]);//负权值c要取反，因为这是最小割(雾)
		/*
		只有c为负值才要付出代价 否则已被算在sum里 
		源点和正值点连一条边的目的之一是限制流量，相当于付出的代价大于得到的时避免亏本
		网络流跑出来的结果相当于要得到sum所付出的代价 
		*/
		for(int k=elast[now];k;k=e[k].next)//遍历now所保护的植物 
		{
			int to=e[k].to;
			ins(id[to],i,999999999);//在被保护的点和now之间建立一条值为INF的边 
		}
	}
	int js=0;//dicnic 
	while( bfs() )js+=dfs(st,999999999);
	
	printf("%d\n",sum-js);
	return 0;
}
```


---

## 作者：破壁人 (赞：0)

分析：

很容易想到把题目转化为图论模型：

首先把原n*m的网格的每一个格子都抽象成点

每个点有点权，被保护的点向保护它的点连边(有点像食物链)

(注意：(i,j)是要向(i,j+1)连边的)

然后我们要从中取一些点，使点权和最大。

我们取点的过程中，要保证子图中没有向外连的边。

这样才能保证，取到这些点的时候，保护它们的点都已经被消灭。

这就是典型的最大权闭合子图问题。

我们用网络流最小割解决它。

建立S和T，S向图中所有点权为非负的点连容量为点权的边。

图中所有点权为负的点向T连容量为点权的相反数的边。

对于图中原有的边，在网络流的图中也连相同的的边，容量为inf。

这样跑最小割的过程中，割掉S连出的边就表示不取这个点，

割掉连向T的边就表示取这个点，其他边因为容量为inf，不可能被割掉。

所以最后所有点权为正的点的点权和减去最小割就可以了。

但是注意到一个问题：原图中可能会有环，有环意味着这些点和他们保护的点都不能取。

这会导致我们原来建立的模型出错，怎么解决呢？

我们先跑一边tarjan，把所有的强连通分量求出来，

由于题目保证没有自环，我们把所有点数大于1的强连通分量缩成一个点，点权为-inf。

这样就可以保证取不到这些点和它们保护的点了。

至此，问题圆满解决。

代码

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>

using namespace std;

const int inf=1e9;

int dfn[1001],low[1001],cur[1001],d[1001],gap[1001],e1=0,queue[1001][2],bb[1001][1001];
int to[400001],w[400001],next[400001],first[1001],b[1001],n,m,S,T,sum=0,a1[1001][1001];
int stack[1001],head,times=0,a[1001][1001],kuai[1001],whkuai[1001],kuais=0,b1[601];
bool v[400001],f[400001];

void insert(int o,int p,int q)
{
    to[e1]=p;w[e1]=q;next[e1]=first[o];first[o]=e1++;
    to[e1]=o;w[e1]=0;next[e1]=first[p];first[p]=e1++;
}

void bfs()
{
    head=1;queue[1][0]=T;queue[1][1]=0;
    d[T]=0;gap[0]=1;e1=1;
    while(head<=e1)
    {
        for(int i=first[queue[head][0]];i!=-1;i=next[i])
            if((!d[to[i]])&&(to[i]!=T))
            {
                e1++;
                queue[e1][0]=to[i];
                queue[e1][1]=queue[head][1]+1;
                d[to[i]]=queue[e1][1];
                gap[d[to[i]]]++;
            }
        head++;
    }
}

void print(int o)
{
    kuais++;kuai[kuais]=0;
    while(stack[head]!=o) 
    {
        whkuai[stack[head]]=kuais;
        f[stack[head]]=0;
        kuai[kuais]++;
        head--;
    }
    whkuai[stack[head]]=kuais;
    f[stack[head]]=0;
    kuai[kuais]++;
    head--;
}

void tarjan(int o)
{
    times++;f[o]=1;
    dfn[o]=low[o]=times;
    stack[++head]=o;
    for(int i=1;i<=a[o][0];i++)
        if(!v[a[o][i]])
        {
            v[a[o][i]]=true;
            tarjan(a[o][i]);
            low[o]=min(low[o],low[a[o][i]]);
        }else
        if(f[a[o][i]]) low[o]=min(low[o],dfn[a[o][i]]);
    if(dfn[o]==low[o]) print(o);
}

int dfs(int o,int flow)
{
    if(o==T) return flow;
    int res=flow,ff;
    for(int i=cur[o];i!=-1;i=next[i])
        if((w[i]>0)&&(d[o]==(d[to[i]]+1)))
        {
            cur[o]=i;
            ff=dfs(to[i],min(res,w[i]));
            w[i]-=ff;w[i^1]+=ff;
            if(!(res-=ff)) return flow;
        }
    if(!(--gap[d[o]])) d[S]=T;
    cur[o]=first[o];
    ++gap[++d[o]];
    return flow-res;
}

int isap()
{
    int res=0;
    for(int i=0;i<=T;i++) cur[i]=first[i];
    while(d[S]<T) res+=dfs(S,inf);
    return res;
}

int main()
{
    memset(first,-1,sizeof(first));
    memset(bb,0,sizeof(bb));
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n*m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        b[i]=x;
        for(int j=1;j<=y;j++)
        {
            int x1,y1,ok;
            scanf("%d%d",&x1,&y1);
            ok=x1*m+y1+1;
            a[ok][++a[ok][0]]=i;
            bb[ok][i]=true;
        }
    }
    for(int i=1;i<=n*m;i++) if(i%m!=0) if(!bb[i][i+1]) a[i][++a[i][0]]=i+1;
    memset(v,0,sizeof(v));
    memset(f,0,sizeof(f));
    for(int i=1;i<=n*m;i++) if(!v[i]) {v[i]=true;tarjan(i);}
    memset(bb,0,sizeof(bb));
    for(int i=1;i<=n*m;i++)
    {
        if(kuai[whkuai[i]]>1) b1[whkuai[i]]=-inf;else b1[whkuai[i]]=b[i];
        for(int j=1;j<=a[i][0];j++)
            if(!bb[whkuai[i]][whkuai[a[i][j]]])
            {
                a1[whkuai[i]][++a1[whkuai[i]][0]]=whkuai[a[i][j]];
                bb[whkuai[i]][whkuai[a[i][j]]]=true;
            }
    }
    S=kuais+1;T=S+1;
    for(int i=1;i<=kuais;i++)
    {
        if(b1[i]>=0){sum+=b1[i];insert(S,i,b1[i]);}else insert(i,T,-b1[i]);
        for(int j=1;j<=a1[i][0];j++) insert(i,a1[i][j],inf);
    }
    memset(d,0,sizeof(d));
    memset(gap,0,sizeof(gap));
    bfs();
    cout<<sum-isap()<<endl;
    return 0;
}
```

---


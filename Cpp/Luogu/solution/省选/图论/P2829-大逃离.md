# 大逃离

## 题目背景

zrz走进了一个奇葩的迷宫，他发现自己迷路了，想逃出来，他好不容易数完了所有的路，累的快晕了，只好叫你帮忙咯。


## 题目描述

这是一棵有n个节点的图，有m条双向边，每一条路有w个单位距离，zrz在1的位置，出口在n的位置，不过zrz脑子出了点bug，于是不想走最短的路，想走第2短的路，第2短路径允许与最短路径有重边，然后也可以重复通过一些节点和路，注意如果有多条路径都是最短路径，那么他们都不能叫第2短路径。但是zrz觉得如果接下来进入的一个节点所直接连接的地方小于k个（起点和终点除外），那么他就不敢进去。


## 说明/提示

对于50%的数据：n<=10,m<=10

对于90%的数据：n<=1000,m<=20000

对于100%的数据：n<=5000，m<=100000

另外，k比较小

样例2最短路径是300（1-2-4）。因为从2无法走到3（3连接到的节点只有2个），所以可以1-2-1-2-4，第二短路为500。


## 样例 #1

### 输入

```
4 4 1
1 2 100
2 4 200
2 3 250
3 4 100```

### 输出

```
450```

## 样例 #2

### 输入

```
4 4 3
1 2 100
2 4 200
2 3 250
3 4 100```

### 输出

```
500```

# 题解

## 作者：中国飞鱼 (赞：16)

先对起点和终点分别跑一边SPFA,那么次短路一定是:

某一条边的w + 起点到该边一端点的最短路 + 终点到该边另一端点的最短路

(注意到反复经过的边必然只有一条并且反复过不超过3次,否则绝不是次短路,那么我们假设全图最短路是dist[S][i]+cost[i][j]+dsit[j][T],反复经过边的情况可以处理成:dist[S][j]+cost[i][j]+dist[i][T])

因此再枚举每一条边,计算次短路并把与全图最短路长度相等的筛掉即可

**比较坑的一点**:题目有重边,不能简单统计节点的出现次数来判断是否合法(>=k),具体见代码:


---
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
const int N=5002,M=100002,INF=1e9+7;
int n,m,k,cnt,u,v,w,mindist,secdist=INF;//mindist最短路,secdist次短路
int last[N],t[N],dist[2][N];//t是每个点的出边数
bool used[N],vis[N];
struct edg{
    int to,next,w;
}edge[2*M];//邻接表
void insert(int u,int v,int w)//连边
{
    edge[++cnt]=(edg){v,last[u],w};last[u]=cnt;
    edge[++cnt]=(edg){u,last[v],w};last[v]=cnt;
}
void SPFA(int S,int op)//op=0是起点的参数,op=1是终点的参数
{
    for(int i=1;i<=n;i++)dist[op][i]=INF,used[i]=0;//初始化
    queue<int> Q;
    Q.push(S);
    used[S]=1;
    dist[op][S]=0;
    while(!Q.empty())
    {
        int now=Q.front();Q.pop();
        used[now]=0;
        for(int i=last[now];i;i=edge[i].next)
        {
            int v=edge[i].to;
            if(dist[op][now]+edge[i].w<dist[op][v]&&t[v]>=k)//筛掉不合法的(即小于k的)
            {
                dist[op][v]=dist[op][now]+edge[i].w;
                if(!used[v]){Q.push(v);used[v]=1;}
            }
        }
    }
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&u,&v,&w);
        insert(u,v,w);
    }
    for(int i=2;i<n;i++)//全图扫一遍处理每个点的t值
    {
        memset(vis,0,sizeof(vis));
        for(int j=last[i];j;j=edge[j].next)
        {
            int v=edge[j].to;
            if(!vis[v]){vis[v]=1;t[i]++;}
        }
    }
    t[1]=INF;t[n]=INF;
    SPFA(1,0);
    SPFA(n,1);
    mindist=dist[0][n];
    for(int i=1;i<=n;i++)
    {
        if(t[i]<k)continue;
        for(int j=last[i];j;j=edge[j].next)//枚举每条边
        {
            int v=edge[j].to;
            int len=dist[0][i]+edge[j].w+dist[1][v];
            if(len>mindist&&t[v]>=k)secdist=min(secdist,len);
        }
    }
    printf("%d\n",secdist>=INF?-1:secdist);
    return 0;
}
```

---

## 作者：lemonfor (赞：10)

严格次短路，只不过比[智（划掉   路）障](https://www.luogu.com.cn/problem/P2865)多了一个判断连边的条数以及自环等问题。

应对次短路我开了两个dis，具体解决方法如下：

令dis[1]为最短路 ，第dis[2]为次短路

1.假如 $dis[1][v] > dis[1][u] + map[i].w$ 即说明当前的最短路被更新 ，所以次短路应被更新为之前的最短路；

2. 假如 $dis[2][v] > dis[1][u] + map[i].w$  即说明当前的最短路无须更新，但次短路可以从之前的最短路更新；

3. 假如 $dis[2][v] > dis[2][u] + map[i].w$ 即说明当前的次短路只能从之前的次短路更新；

另外还要判断自环等问题，便可以过了。
```cpp
#include<cstdio>
#include<algorithm>
#define INF 0x3f3f3f3f
#define N 5055
#define int long long
using namespace std;
int u ,v ,w ,n ,m ,head[N * 8] ,tot ,k;
int dis[3][N * 8] ,q[N * N] ,col[N * 8] ,link[N * 8];
bool vis[N * 8] ,yeah[N][N] , dog[N][N] ,yet;
struct edge
{
    int next ,to ,w;
} map[N * N];
void add(int u ,int v ,int w)
{
    map[++tot].next = head[u];
    head[u] = tot;
    map[tot].to = v;
    map[tot].w = w;  
}
void SPFA(int st)
{
    for(int i = 2 ; i <= n ; ++ i)
    dis[1][i] = dis[2][i] = INF ,vis[i] = false;
    int l = 1 , r = 0;
    q[++r] = st ,dis[2][st] = INF ,vis[st] = true;
    while(l <= r){
        int u = q[l++];
        vis[u] = false;
        for(int i = head[u] ; i ; i = map[i].next)
        if(link[map[i].to] >= k || map[i].to == n || map[i].to == 1){
            yet = false;
            v = map[i].to;
			if(dis[1][v] > dis[1][u] + map[i].w) 
                dis[2][v] = dis[1][v] ,dis[1][v] = dis[1][u] + map[i].w ,yet=true;
            if(dis[2][v] > dis[1][u] + map[i].w && dis[1][v] != dis[1][u] + map[i].w)
                dis[2][v] = dis[1][u] + map[i].w ,yet = true;
            if(dis[2][v] > dis[2][u] + map[i].w) 
            dis[2][v] = dis[2][u] + map[i].w ,yet = true;
            if(!vis[v] && yet) q[++r] = v ,vis[v] = true;
        }
    }
}
signed main()
{
    scanf("%lld%lld%lld" ,&n ,&m ,&k);
    for(int i = 1 ; i <= m ; ++ i){
        scanf("%lld%lld%lld" ,&u ,&v ,&w);
        add(u ,v ,w) ,add(v ,u ,w) ;
        if(dog[u][v] == true || dog[v][u] == true) --link[u] ,--link[v];//dog数组用来避免重复计算入度
        ++link[u] ,++link[v];
        dog[u][v] = dog[v][u] = true;
    }
    SPFA(1);
    if(dis[2][n] == INF)
    printf("-1");
    else printf("%lld" ,dis[2][n]);
    return 0;
}
```
在下码风不是很好，有什么写的不详细的可以指出或私信我（逃

---

## 作者：NewSjf (赞：6)

这道题的考点是次短路,这里有道裸题[ P2865 [USACO06NOV]路障Roadblocks](https://www.luogu.org/problem/P2865)  
这道题在求次短路的基础上新增了一些限制,就是非起点/终点的结点,如果和它有边相连的**不同**结点数小于k就不能访问  
这个很好处理,类似于记录出度入度degree  
当我们新增一条从x到y的边的时候,两个点的degree都加一  
不过题目比较坑爹的就是有重边和自环,但我们需要的是不同的点的数量  
我的做法是用一个5000*5000的bool数组来记录这两个点是否有边  
```cpp
bool book[5001][5001];
   ...
   ...
if(x==y)continue;
    if(!book[x][y])
    degree[x]++,
    degree[y]++,                           
    book[x][y]=book[y][x]=true;
    ...
    ...
```
然后这道题就和模板真没什么区别了,详细直接看代码就好
```cpp
/**************************************************************/
基本思路：
把求最短路时更新最短路的那部分改一下。
dis1，dis2数组分别记录到该点的最短路和次短路
分三种情况：
    1.若该点最短路+下一条边比到下个点的最短路短，则更新下个点的最短路，同时更新次短路为原最短路
    2.若该点次短路+下一条边比到下个点的次短路短，则更新下个点的次短路
    3.若该点最短路+下一条边比到下个点的最短路长同时比下个点的次短路短，则更新下个点的次短路

/*************************************************************/
#include<iostream>
#include<queue>
#define MAXN 2000000
#define INF 0x7f7f7f7f
struct node                                             
{
	int u,d;  //点编号,到起点长度 
	bool friend operator<(const node&a,const node&b){return a.d>b.d;}   
};
struct Edge
{
	int from,to,next,w;
}edge[MAXN];
int head[MAXN],dis1[MAXN],dis2[MAXN],degree[MAXN],len,n,m,KK;  //dis1 最短路 dis2 次短路 
bool book[5001][5001];    //标记x-y是否有边 
using namespace std;
void ins(int x,int y,int d)
{
	edge[++len]=(Edge){x,y,head[x],d};
	head[x]=len;
}
void Dijkstra(int st)
{
	priority_queue<node,vector<node>,less<node> >q;
	for(int i=1;i<=n;i++)dis1[i]=dis2[i]=INF;
	dis1[st]=0;q.push((node){st,0});                    //不能写dis2[2]=0,会出问题.
	while(q.size())                                     //我只是发现了这个问题,尚未解决,留给大佬出来 
	{
		node now=q.top();q.pop();
		if(dis2[now.u]<now.d)continue;
		for(int k=head[now.u];k;k=edge[k].next)
		{
			int dis=edge[k].w+now.d,to=edge[k].to;
			if(to!=1&&to!=n&&degree[to]<KK)continue;    //依题,当前访问点直接连接的点小于k且不是起点或重点 
			if(dis1[to]>dis)                            //更新最短路 
			{
				swap(dis1[to],dis);  
				q.push((node){to,dis1[to]});
			}
			if(dis1[to]<dis&&dis2[to]>dis)              //更新次短路.去掉swap实际上是有三种情况的 
			{
				dis2[to]=dis;
				q.push((node){to,dis2[to]});
			}
		}
	}
}
int main()
{
	cin>>n>>m>>KK;
	for(int i=1;i<=m;i++)
	{
		int x,y,d;cin>>x>>y>>d;
        if(x==y)continue;
		if(!book[x][y])                               //这里要排除重边和自环的情况
		{
		
            degree[x]++;                              //因为degree记录的是和该点有直接联系的点的个数 
			degree[y]++;                           
            book[x][y]=book[y][x]=true;               //这句话值20分 
			ins(x,y,d);
			ins(y,x,d);
		}
	}
	Dijkstra(1);
    cout<<(dis2[n]==INF?-1:dis2[n]);                  //这句话起码10分 
}



```
更新：2019/10/9   
很抱歉可能是我写题解时候的失误   
为了让代码可读性提高  (轻微压行)     
临时改动了代码    
导致这篇题解只有30分  
AC的代码在这里   
判重那里被我改挂了      
很抱歉让大家AC率--了   
--    
```cpp
#include<iostream>
#include<cstring>
#include<queue>
#define MAXN 2000000
#define INF 0x7f7f7f7f
struct node
{
	int u,d;
	bool friend operator<(const node&a,const node&b){return a.d>b.d;}
};
struct Edge{int from,to,next,w;}edge[MAXN];
int head[MAXN],dis1[MAXN],dis2[MAXN],degree[MAXN],len,n,m,KK;
bool book[5001][5001];
using namespace std;
void ins(int x,int y,int d){edge[++len]=(Edge){x,y,head[x],d};head[x]=len;}
void Dijkstra(int st)
{
	priority_queue<node,vector<node>,less<node> >q;
	for(int i=1;i<=n;i++)dis1[i]=dis2[i]=INF;
	dis1[st]=0;q.push((node){st,0});
	while(q.size())
	{
		node now=q.top();q.pop();
		if(dis2[now.u]<now.d)continue;
		for(int k=head[now.u];k;k=edge[k].next)
		{
			int dis=edge[k].w+now.d,to=edge[k].to;
			if(to!=1&&to!=n&&degree[to]<KK)continue;
			if(dis1[to]>dis)
			{
				swap(dis1[to],dis);
				q.push((node){to,dis1[to]});
			}
			if(dis1[to]<dis&&dis2[to]>dis)
			{
				dis2[to]=dis;
				q.push((node){to,dis2[to]});
			}
		}
	}
}
int main()
{
	cin>>n>>m>>KK;
	for(int i=1;i<=m;i++)
	{
		int x,y,d;cin>>x>>y>>d;
        if(x==y)continue;
		ins(x,y,d);ins(y,x,d);     //不知道什么时候把ins函数放到if里面去了,导致AC->30分
		if(!book[x][y])
        {
            degree[x]++;
			degree[y]++;
            book[x][y]=book[y][x]=true;
        }
	}
	Dijkstra(1);
    cout<<(dis2[n]==INF?-1:dis2[n]);
}
```  
再次向大家道歉  
祝大家AC率++


---

## 作者：1124828077ccj (赞：5)

spfa，如果x点的最短路能更新y点最短路，那么x点最短路更新y点最短路，x点次短路 企图更新y点最短路，如果x点的最短路不能更新y点最短路，那么就用x点的最短路更新y点次短路（想一想，为什么。这句话怎么好像哪里听过啊。。。）


代码如下

```cpp
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
using namespace std;
struct Edge{
    int from,to,dist;
    Edge(int u,int v,int d):from(u),to(v),dist(d){}
};
const int INF=1e9;
int inq[5002],d[5002],S[5002],n,m,hh[5002],hhh[5002],uu,k;
vector<int>g[5002];
vector<Edge>edges;
void spfa(int s){
    queue<int>q;
    for (int i=1;i<=n;i++)d[i]=S[i]=INF;
    d[s]=0;
    inq[s]=1;
    q.push(s);
    while(!q.empty())
    {
        int u=q.front();q.pop();
        inq[u]=0;
        for (int i=0;i<g[u].size();i++)
        {
            Edge& e=edges[g[u][i]];if (hh[e.to])continue;
            if (d[e.to]>=d[u]+e.dist)
            {
                S[e.to]=min(S[e.to],S[u]+e.dist);
                d[e.to]=d[u]+e.dist;
                if (!inq[e.to]){q.push(e.to);inq[e.to]=1;}
            }
            else if (S[e.to]>d[u]+e.dist)
            {S[e.to]=d[u]+e.dist;if (!inq[e.to]){q.push(e.to);inq[e.to]=1;}}
        }
    }
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for (int i=0;i<m;i++)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        edges.push_back(Edge(a,b,c));g[a].push_back(edges.size()-1);
        edges.push_back(Edge(b,a,c));g[b].push_back(edges.size()-1);
    }
    for (int i=2;i<n;i++)
    {
        memset(hhh,0,sizeof(hhh));hhh[i]=1;uu=0;
        for (int j=0;j<g[i].size();j++)
        {Edge& e=edges[g[i][j]];if (!hhh[e.to]){uu++;hhh[e.to]=1;}}
        if (uu<k)hh[i]=1;
    }
    spfa(1);
    if (S[n]<1e9)printf("%d",S[n]);else printf("-1");
    return 0;
}
```

---

## 作者：空の軌跡 (赞：3)

这道题要求找到严格次小的路径，刚开始我想用dijkstra，但是我发现dijkstra需要维护的顺序是不能保证正确性的。

dijkstra本质是贪心算法，但是显然这道题目需要维护两个值：最小值和次小值，对此，你无法定义一个先后顺序使它能够满足贪心。

本题可以重复走边，又不能用dijkstra，所以我使用了SPFA。

## 具体操作：

- 当前点 最短路 更新目标点 最短路和次短路。

- 当前点 次短路 更新目标点 次短路。

其他的就是SPFA的操作，当目标点被当前点更新后就加入队列，然后接着跑。

## 注意事项：

- 本题有重边，自环等坑点，所以你要手动处理度数，不能加边时就操作。（我被坑了7遍提交呜呜）

- 要求为严格最短路。

## 代码：
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<queue>
using namespace std;
struct road
{
    int to,val;
};
queue<int>que;
vector<road>side[5010];
bool used[5010];
int minn[5010],val[5010],du[5010],vis[5010];
inline void read(int &x)
{
	x=0;char c=getchar();
	for(;c>'9'||c<'0';)c=getchar();
	for(;c<='9'&&c>='0';)
	{
		x=x*10+c-'0';
		c=getchar();
	}
}
int main()
{
    int n,m,k,a,b,c;
    read(n);read(m);read(k);
    for(int i=1;i<=m;++i)
    {
        read(a);read(b);read(c);
        if(a!=b)
        {
			side[a].push_back((road){b,c});
        	side[b].push_back((road){a,c});
		}
		else side[a].push_back((road){b,c});
    }
    for(int i=2;i<n;++i)           //处理度数
    for(int j=0;j<side[i].size();++j)
    {
    	int to=side[i][j].to;
    	if(vis[to]==i)continue;
    	vis[to]=i;++du[i];
	}
	du[1]=du[n]=999999;
    memset(minn,0x3f,sizeof(minn));
    memset(val,0x3f,sizeof(val));
    minn[1]=0;val[1]=999999990;
    que.push(1);
    while(!que.empty())
    {
        int x=que.front();que.pop();used[x]=0;
        if(du[x]<k)continue;
        for(int i=0;i<side[x].size();++i)
        {
            int to=side[x][i].to;
            int cos=side[x][i].val;
            //各种更新
            if(val[x]+cos<val[to]&&val[x]+cos!=minn[to])
            {
                val[to]=val[x]+cos;
                if(!used[to])
                {
                    que.push(to);
                    used[to]=1;
                }
            }
            if(minn[x]+cos<minn[to])
            {
                val[to]=min(val[to],minn[to]);
                minn[to]=minn[x]+cos;
                if(!used[to])
                {
                    used[to]=1;
                    que.push(to);
                }
            }
            else if(minn[x]+cos!=minn[to])
            {
                if(val[to]>minn[x]+cos)
                {
                    val[to]=minn[x]+cos;
                    if(!used[to])
                    {
                        used[to]=1;
                        que.push(to);
                    }
                }
            }
        }
    }
    if(val[n]>=1000000000)cout<<"-1";
	else cout<<val[n];
}
```

---

## 作者：Priori_Incantatem (赞：2)

一道模板的次短路

设 $dis[x],dist[x]$ 分别为点 $1$ 到 $x$ 的最短路和次短路长度

我们只需在跑最短路时，顺带更新一下次短路  
由于每个点可以经过多次，我们只能使用 SPFA

对于每条边 $[x,y]$，考虑 $dist[y]$ 的转移：

1. 最无脑的一种，$dist[y]=dist[x]+w(x,y)$，其中 $w(x,y)$ 为当前边的长度
2. 在最短路中，进行松弛操作后，满足当前的 $dis[y]$ 小于松弛前的 $dis[y]$。那么，我们就可以用松弛前的 $dis[y]$ 去更新 $dist[y]$
3. 如果，$dis[y]<dis[x]+w(x,y)$，说明 $dis[x]+w(x,y)$ 是一条次短路，所以 $dist[y]=min(dist[y],dis[x]+w(x,y))$。注意：这里更新的时间是在松弛操作之后

关键代码

```cpp
for(int i=0;i<e[x].size();++i)
{
	int y=e[x][i].v;
	if(d[y]<k && y>1 && y<n)continue;
	int tmp=dis[x]+e[x][i].len;
	if(dis[y]>tmp) // 松弛
	{
		dist[y]=dis[y]; // 用老的 dis[y] 更新 dist[y]
		dis[y]=tmp;
		if(!vis[y])vis[y]=1,q.push(y);
	}
	else if(dist[y]>tmp && tmp!=dis[y]) // 如果 dis[x]+e[x][i].len 是一条次短路
	{
		dist[y]=tmp;
		if(!vis[y])vis[y]=1,q.push(y);
	}
	if(dist[y]>dist[x]+e[x][i].len)
	{
		dist[y]=dist[x]+e[x][i].len;
		if(!vis[y])vis[y]=1,q.push(y);
	}
}
```

这里说一下，题目中提到的：一个点所直接连接的地方数量  
这里的数量并不等于这个节点的度数（连边数），因为两个节点之间可能有多条边。这才是正确的打开方式：  
```cpp
for(int x=1;x<=n;++x)
{
	for(int i=0;i<e[x].size();++i)
	{
		int y=e[x][i].v;
		if(!vis[y])++d[x];
		vis[y]=1;
	}
	memset(vis,0,sizeof(vis));
}
```

完整代码

```cpp
#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
const int Maxn=10010,inf=0x3f3f3f3f;
struct edge{
	int v,len;
	edge(int x,int y)
	{
		v=x,len=y;
	}
};
int dis[Maxn],dist[Maxn],d[Maxn];
bool vis[Maxn];
int n,m,k;
vector <edge> e[Maxn];
void spfa()
{
	fill(dis,dis+2+n,inf);
	fill(dist,dist+2+n,inf);
	queue <int> q;
	q.push(1),vis[1]=1,dis[1]=0;
	while(q.size())
	{
		int x=q.front();
		vis[x]=0;
		q.pop();
		for(int i=0;i<e[x].size();++i)
		{
			int y=e[x][i].v;
			if(d[y]<k && y>1 && y<n)continue;
			int tmp=dis[x]+e[x][i].len;
			if(dis[y]>tmp)
			{
				dist[y]=dis[y];
				dis[y]=tmp;
				if(!vis[y])vis[y]=1,q.push(y);
			}
			else if(dist[y]>tmp && tmp!=dis[y])
			{
				dist[y]=tmp;
				if(!vis[y])vis[y]=1,q.push(y);
			}
			if(dist[y]>dist[x]+e[x][i].len)
			{
				dist[y]=dist[x]+e[x][i].len;
				if(!vis[y])vis[y]=1,q.push(y);
			}
		}
	}
}
int main()
{
//	freopen("in.txt","r",stdin);
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=m;++i)
	{
		int x,y,c;
		scanf("%d%d%d",&x,&y,&c);
		e[x].push_back(edge(y,c));
		e[y].push_back(edge(x,c));
	}
	for(int x=1;x<=n;++x)
	{
		for(int i=0;i<e[x].size();++i)
		{
			int y=e[x][i].v;
			if(!vis[y])++d[x];
			vis[y]=1;
		}
		memset(vis,0,sizeof(vis));
	}
	spfa();
	if(dist[n]==inf)puts("-1");
	else printf("%d\n",dist[n]);
	return 0;
}
```

---

## 作者：zc_li (赞：2)

## 这是一道标准的严格次短路问题。
本题解不用判断自环问题

##### 那严格次短路该怎么做呢，我用的是 SPFA 法，用了2个dp数组，分别用于记录从1点到现在点的最短路和严格次短路。
接下来说一下状态转移方程（状态转移方程号如代码中）：

1. 如果1到u的最短路加u到v的长度比原本1到v最短路短，则将1到v次短路更新为原本1到v最短路，把1到v最短路更新为1到u最短路加u到v距离。
2. 如果1到u的最短路加u到v的长度比原本1到v最短路长，而1到u的最短路加u到v的长度比原本1到v次短路短，则将1到v次短路更新为1到u最短路加u到v距离。
3. 如果1到u的次短路加u到v的长度比原本1到v次短路短，则将1到v次短路更新为1到u次短路加u到v距离。
4. （注意点）注意1到u的次短路不用和1到v最短路比较，因为如果1到u次短路加u到v距离比1到v最短路短则1到u最短路加u到v距离必定比这条最短路短，即满足第1点，所以重复不用操作。
```
for(int i=vex[u];i;i=zz[i].next){
	int v=zz[i].v;
    //1
	if(du[v]<k&&v!=1&&v!=n) continue;
	if(dis[v]>dis[u]+zz[i].w){
		dis2[v]=dis[v];
		dis[v]=dis[u]+zz[i].w;
		if(!vis[v]){
			vis[v]=1;
			q.push(v);
		}
	}
    //2.
	if(dis[v]<dis[u]+zz[i].w&&dis2[v]>dis[u]+zz[i].w){
		dis2[v]=dis[u]+zz[i].w;
		if(!vis[v]){
			vis[v]=1;
			q.push(v);
		}
	}
    //3.
	if(dis2[v]>dis2[u]+zz[i].w){
		dis2[v]=dis2[u]+zz[i].w;
		if(!vis[v]){
			vis[v]=1;
		    q.push(v);
		}
	}
}
```
##### 知道了状态转移方程后就好打了，不过下面还有需要注意的整体问题（dalao请跳过）：
1. 记住这是无向图，不要建成有向图~~百年不变的问题~~。
2. 这个房间如果没有通向足够房间就不能进入，所以要在输入时记录度，还不要忘记用一个二维数组记录是否记录过这两点的其中一条道路
3. 如果没有次短路到终点记住输出“-1”。
4. 注意初始化记录最短路和次短路的数组。
## 最后上成品代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,m,k,ans=1e9,g[5005][5005],du[50005],vex[50005],fx,dis[50005],dis2[50005],vis[50005];
struct dd{
	int u,v,w,next;
}zz[555555];
queue<int>q;
void push(int u,int v,int w){
	fx++;
	zz[fx].u=u;
	zz[fx].v=v;
	zz[fx].w=w;
	zz[fx].next=vex[u];
	vex[u]=fx;
	return;
}
void spfa(){
	q.push(1);
	for(int i=1;i<=n;i++) dis[i]=1e9;
	for(int i=1;i<=n;i++) dis2[i]=1e9;
	dis[1]=0;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=vex[u];i;i=zz[i].next){
			int v=zz[i].v;
			if(du[v]<k&&v!=1&&v!=n) continue;
			if(dis[v]>dis[u]+zz[i].w){
				dis2[v]=dis[v];
				dis[v]=dis[u]+zz[i].w;
				if(!vis[v]){
				    vis[v]=1;
				    q.push(v);
				}
			}
			if(dis[v]<dis[u]+zz[i].w&&dis2[v]>dis[u]+zz[i].w){
				dis2[v]=dis[u]+zz[i].w;
				if(!vis[v]){
				    vis[v]=1;
				    q.push(v);
				}
			}
			if(dis2[v]>dis2[u]+zz[i].w){
				dis2[v]=dis2[u]+zz[i].w;
				if(!vis[v]){
				    vis[v]=1;
				    q.push(v);
				}
			}
		}
	}
	return;
}
int main() {
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++){
		int q,h,z;
		cin>>q>>h>>z;
	    if(!g[q][h]&&!g[h][q]){
	    	du[q]++;
		    du[h]++;
		    g[q][h]=1;
		}
		push(q,h,z);
		push(h,q,z);
	}
	spfa();
	if(dis2[n]!=1e9)cout<<dis2[n];
	else cout<<"-1";
	return 0;
}
```



---

## 作者：rediserver (赞：2)

# P2829 大逃离
[原题地址](https://www.luogu.org/problemnew/show/P2829)

[Github题解](https://github.com/jerrykcode/luogu)

## 思路

A*求次短路，反向Dijkstra计算出的每个顶点到终点的最短距离为估价函数。

## 代码

```cpp
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <queue>
using namespace std;

typedef unsigned short Vertex; //顶点
#define NO_VALUE -1

//邻接点结构体
struct AdjNode {
    Vertex adj_v; //邻接点
    short adj_weight; //邻接边权重
    AdjNode(Vertex adj_v, short adj_weight) : adj_v(adj_v), adj_weight(adj_weight) {}
};

//计算无向图次短路的类
class SecondShortestPath {
public:
    /* 计算无向图次短路。
        @param graph 图
        @param nv 顶点数
        @param src 源
        @param des 终点
        @param num 数组，存储每个顶点的邻接点数（graph可能有重边）
        @param k 扩展邻接点时，若邻接点不是src和des，且其邻接点数小于k，则不扩展该邻接点
        @param p_second_shortest_dist 指针，传出次短路长度
        @return bool 若次短路存在则返回true
    */
    bool getSecondShortestPath(vector<AdjNode> *graph, int nv, int src, int des, int *num, int k, int *p_second_shortest_dist);
private:
    /* Dijkstra计算最短路。
        @param graph 图
        @param nv 顶点数
        @param src 源
        @param des 终点
        @param num 数组，存储每个顶点的邻接点数（graph可能有重边）
        @param k 扩展邻接点时，若邻接点不是src和des，且其邻接点数小于k，则不扩展该邻接点
        @param dist 数组，传出src到每一个顶点的最短距离
        @return bool 若src可达des则返回true
    */
    bool dijkstra(vector<AdjNode> *graph, int nv, int src, int des, int *num, int k, int *dist);

    /* A*计算次短路。
        @param graph 图
        @param h 数组 A*算法的估值函数
        @param nv 顶点数
        @param src 源
        @param des 终点
        @param num 数组，存储每个顶点的邻接点数（graph可能有重边）
        @param k 扩展邻接点时，若邻接点不是src和des，且其邻接点数小于k，则不扩展该邻接点
        @param p_second_shortest_dist 指针，传出次短路长度
        @return bool 若次短路存在则返回true
    */
    bool astar(vector<AdjNode> *graph, int *h, int nv, int src, int des, int *num, int k, int *p_second_shortest_dist);

    //Dijkstra优先队列使用的结构体
    struct PriorityNode {
        Vertex v;
        int dist;
        PriorityNode(Vertex v, int dist) : v(v), dist(dist) {}
    };

    //A*优先队列使用的结构体，继承了PriorityNode
    struct AstarNode : public PriorityNode {
        //f = dist
        int g;
        AstarNode(Vertex v, int g, int f) : PriorityNode(v, f), g(g) {}
    };

    //优先队列用于比较的结构体
    struct cmp {
        bool operator () (PriorityNode& a, PriorityNode& b) {
            return a.dist > b.dist;
        }
    };
};

bool SecondShortestPath::getSecondShortestPath(vector<AdjNode>* graph, int nv, int src, int des, int *num, int k, int *p_second_shortest_dist) {
    int *h = new int[nv];
    bool result;
    if (dijkstra(graph, nv, des, src, num, k, h)) { //反向计算最短路，作为A*的估值函数
        result = astar(graph, h, nv, src, des, num, k, p_second_shortest_dist); //A*
    }
    else result = false;
    free(h);
    return result;
}

bool SecondShortestPath::dijkstra(vector<AdjNode>* graph, int nv, int src, int des, int *num, int k, int * dist) {
    fill(dist, dist + nv, NO_VALUE);
    bool *collected = new bool[nv];
    fill(collected, collected + nv, false);
    dist[src] = 0;
    priority_queue<PriorityNode, vector<PriorityNode>, cmp> q;
    q.push(PriorityNode(src, 0));
    Vertex top_v, adj_v;
    int tmp_dist;
    while (!q.empty()) {
        top_v = q.top().v;
        q.pop();
        if (collected[top_v]) continue;
        collected[top_v] = true;
        for (auto it = graph[top_v].begin(); it != graph[top_v].end(); it++) { //遍历邻接点
            adj_v = it->adj_v;
            if ((num[adj_v] >= k || adj_v == des) && !collected[adj_v]) { //邻接点的邻接点数目需要>=k，或者邻接点就是des
                tmp_dist = dist[top_v] + (int)it->adj_weight;
                if (tmp_dist < dist[adj_v] || dist[adj_v] == NO_VALUE) {
                    dist[adj_v] = tmp_dist;
                    q.push(PriorityNode(adj_v, tmp_dist));
                }
            }
        } //for
    } //while
    free(collected);
    return dist[des] != NO_VALUE;
}

bool SecondShortestPath::astar(vector<AdjNode>* graph, int *h, int nv, int src, int des, int *num, int k, int * p_second_shortest_dist) {
    priority_queue<AstarNode, vector<AstarNode>, cmp> q;
    q.push(AstarNode(src, 0, h[src]));
    Vertex top_v, adj_v;
    int top_g, last_g = NO_VALUE, tmp_g, count = 0;
    while (!q.empty()) {
        top_v = q.top().v;
        top_g = q.top().g;
        q.pop();
        if (top_v == des && top_g != last_g) { //弹出des，且des的g值和上次弹出des的g值不同
            if (++count == 2) { //计数
                while (!q.empty()) q.pop();
                *p_second_shortest_dist = top_g;
                return true;
            }
            last_g = top_g; //更新last_g为这次弹出des的g值
        }
        for (auto it = graph[top_v].begin(); it != graph[top_v].end(); it++) { //遍历邻接点
            adj_v = it->adj_v;
            if (num[adj_v] >= k || adj_v == src || adj_v == des) { //邻接点需要>=k或者邻接点就是src或者des
                tmp_g = top_g + (int)it->adj_weight;
                q.push(AstarNode(adj_v, tmp_g, tmp_g + h[adj_v]));
            }
        }
    }
    return false;
}

int main() {
    int n, m, k;
    scanf("%d %d %d", &n, &m, &k);
    vector<AdjNode> *graph = new vector<AdjNode>[n];
    int *num = new int[n];
    fill(num, num + n, 0);
    for (int i = 0, u, v, w; i < m; i++) {
        scanf("%d %d %d", &u, &v, &w);
        u--; v--;
        graph[u].push_back(AdjNode(v, w));
        graph[v].push_back(AdjNode(u, w));
    }
    bool *appeared = new bool[n];	
    for (int i = 0; i < n; i++) {
        fill(appeared, appeared + n, false);
        for (auto it = graph[i].begin(); it != graph[i].end(); it++) {
            if (appeared[it->adj_v]) continue;
            else {
                num[i]++;
                appeared[it->adj_v] = true;
            }
        }
    }
    SecondShortestPath ssp;
    int second_shortest_dist;
    if (ssp.getSecondShortestPath(graph, n, 0, n - 1, num, k, &second_shortest_dist)) {
        printf("%d", second_shortest_dist);
    }
    else printf("-1");
    free(num);
    for (int i = 0; i < n; i++)
        vector<AdjNode>().swap(graph[i]);	
    return 0;
}

```

---

## 作者：༺請༒癌༻ (赞：2)

**先求s到t的最短路，把最短路上经过的边标记一下，每次枚举求最小的此短路，！！！！注意，k是指每个点所连的点数，并不是边数。**
```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
#define MAXX 1000100
using namespace std;
int n,m,k,x,y,z,du[MAXX],fa[MAXX],s1=1e9;
int vis[MAXX],dist[MAXX];
int head[MAXX],cnt;
int v[5010][5010];
struct E{
	int to,next,dis;
}e[MAXX*2];

void add(int from,int to,int dis){
	e[++cnt].to=to;
	e[cnt].dis=dis;
	e[cnt].next=head[from];
	head[from]=cnt;
}
priority_queue< pair<int,int> > q;
void dijk(){
	for(int i=1;i<=n;i++) dist[i]=MAXX;
	dist[1]=0;
	q.push(make_pair(0,1));
	while(!q.empty()){
		int u=q.top().second;q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=head[u];i;i=e[i].next){
			int v=e[i].to;
			if(dist[v]>dist[u]+e[i].dis&&du[v]>=k){
				dist[v]=dist[u]+e[i].dis;
				fa[v]=u;
				q.push(make_pair(-dist[v],v));
			}
		}
	}
}
int dis[MAXX],ins[MAXX],ans=1e9;
priority_queue<pair<int,int> > q1;
void dij(){
	for(int i=1;i<=n;i++) dis[i]=MAXX,vis[i]=0;
	dis[1]=0;
	q1.push(make_pair(0,1));
	while(!q1.empty()){
		int u=q1.top().second;q1.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=head[u];i;i=e[i].next){
			int v=e[i].to;
			if(dis[v]>dis[u]+e[i].dis&&!ins[i]&&du[v]>=k){
				dis[v]=dis[u]+e[i].dis;
				q1.push(make_pair(-dis[v],v));
			}
		}
	}
//	printf("%d\n",dis[n]);
	if(dis[n]!=dist[n]) ans=min(ans,dis[n]);
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&x,&y,&z);
		if(!v[x][y]&&!v[y][x]) du[x]++,du[y]++,v[x][y]=1,v[y][x]=1;
		add(x,y,z);add(y,x,z);
	}
	du[1]=du[n]=MAXX;
	dijk();
	
	int now=n,f,j;
	while(fa[now]){
		f=fa[now];
		for(j=head[f];j;j=e[j].next){
			int to=e[j].to;
			if(dist[f]+e[j].dis==dist[now]&&to==now) {
			   ins[j]=1;
			   break;
			}
		}
		dij();
		ins[j]=0;now=f;
	}
	
	now=n;
	while(fa[now]){
		f=fa[now];
		for(int i=head[f];i;i=e[i].next){
			int to=e[i].to;
			if(dist[f]+e[i].dis==dist[now]&&to==now) {
				s1=min(s1,e[i].dis);
				break;
			}
		}
		now=f;
	}
	ans=min(ans,dist[n]+s1*2);
	if(ans<1e9)printf("%d\n",ans);
	else printf("-1\n");
	return 0;
}
```


---

## 作者：panyf (赞：1)

次短路

A* 和跑两次最短路都不是最优解，最优解是跑一次最短路（参考P2865）

先考虑我们如何求数组中的次大值：
```cpp
int min1=inf,min2=inf+1;
for(int i=1;i<=n;i++){
	if(a[i]<min1)min2=min1,min1=a[i];
	else if(a[i]<min2)min2=a[i];
}
cout<<min2;
```
求次短路也是类似的想法：
```cpp
inline void spfa(){
	memset(d,62,sizeof(d)),memset(e,63,sizeof(e));//d数组存最短路，e数组存次短路
	d[1]=0,f[1]=1,q.push(1);//起点入队
	while(!q.empty()){
		a=q.front(),q.pop(),f[a]=0;//出队
		for(int i=he[a];i;i=ne[i]){
			b=to[i];
			if(ok[b])continue;
			c=len[i];
			if(d[b]>d[a]+c){//最短路可更新时，要先更新次短路
				e[b]=min(d[b],e[a]+c);
				d[b]=d[a]+c;
				if(!f[b])f[b]=1,q.push(b);//入队
			}else if(e[b]>d[a]+c&&d[b]<d[a]+c){//由于是严格次短路，d[b]不能与d[a]+c相等
				e[b]=d[a]+c;
				if(!f[b])f[b]=1,q.push(b);
			}else if(e[b]>e[a]+c){
				e[b]=e[a]+c;
				if(!f[b])f[b]=1,q.push(b);
			}
		}
	}
}
```
还要注意重边和自环，会影响度的统计：
```cpp
for(int i=2;i<n;i++){//不考虑起点和终点
		memset(v,0,sizeof(v)),s=0;//用一维数组v存储点i与点j是否直接连通，节约空间
		for(int j=he[i];j;j=ne[j]){
			if(!v[to[j]])v[to[j]]=1,s++;//重边只统计一次
		}
		if(s<k)f[i]=1;//标记
	}
```
此算法时间复杂度O（km），60ms内可ac

---

## 作者：加勒比·史努比 (赞：1)

## Solve

1.次短路问题+SPFA。

2.设起点为s,终点t。

3.设dis1[i]为s到节点i的最短路，dis2[i]为t到节点2的最短路。

4.设次短路ans。

5.ans即为min{dis1[u]+w+dis2[v]}(u,v,w表示每条边的两侧端点和权值)，ans!=dis1[t]。

## Tip

1.蒟蒻的我并不会证明该过程的正确性。

2.![](https://cdn.luogu.com.cn/upload/pic/63781.png )此处指的是点数。

## Code
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#define N 400010
using namespace std;  //标准开头
int n,m,k;  //同题
int e,r,dist;  //输入时的端点，权值
int ans=1e9;  //答案
int du[N];  //直接连接的点数
int dis1[N],dis2[N];  //同Solve
int first[N],next[N],len;  //邻接表，len表示边数
bool vis[N];
int f[5001][5001];  //f[i][j]>0,表示i与j直接相连
struct note{  //邻接表
	int u,v,w;
}d[N];
void add(int e,int r,int dist){  //邻接表
	d[++len].u=e;
	d[len].v=r;
	d[len].w=dist;
	next[len]=first[e];
	first[e]=len;
}
void spfa(int s,int *dis){  //标准SPFA
	memset(vis,false,sizeof(vis));
	dis[s]=0;
	queue<int> q;
	q.push(s);
	while(!q.empty()){
		int e=q.front();
		q.pop();
		vis[e]=false;
		for(int i=first[e];i!=-1;i=next[i]){
			if(du[d[i].v]<k&&d[i].v!=1&&d[i].v!=n) continue;  //排除度数小于k
			if(dis[d[i].v]>dis[e]+d[i].w){
				dis[d[i].v]=dis[e]+d[i].w;
				if(!vis[d[i].v]){
					vis[d[i].v]=true;
					q.push(d[i].v);
				}
			}
		}
	}
}
int main()
{
	memset(first,-1,sizeof(first));
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++) dis1[i]=dis2[i]=1e9;
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&e,&r,&dist);
		f[e][r]++;
		f[r][e]++;
		add(e,r,dist);
		add(r,e,dist);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++) if(f[i][j]) du[i]++;
	}
	spfa(1,dis1);
	spfa(n,dis2);
	for(int i=1;i<=len;i++){
		if(dis1[d[i].u]+d[i].w+dis2[d[i].v]!=dis1[n]&&ans>dis1[d[i].u]+d[i].w+dis2[d[i].v]) ans=dis1[d[i].u]+d[i].w+dis2[d[i].v]; 
	}
	if(ans==1e9) printf("-1");
	else printf("%d",ans);
	return 0; 
}
```


---


# [TJOI2013] 循环格

## 题目背景

一个循环格就是一个矩阵,其中所有元素为箭头,指向相邻四个格子。每个元素有一个坐标(行,列),其中左上角元素坐标为(0,0)。给定一个起始位(r,c),你可以沿着箭头方向在格子间行走。即:如果(r,c)是一个左箭头，那么走到(r,c-1);如果是一个右箭头,走到(r,c+1);如果是上箭头,走到(r-1,c);如果是下箭头,走到(r+1,c)。每一行和每一列都是循环的,即如果走出边界,你会出现在另一侧。比如在一个5\*5的循环格里,从(3,0)向左走会出现在(3,4)。


## 题目描述

一个完美的循环格是这样定义的:对于任意一个起始位置,你都可以沿着箭头最终回到起始位置。如果一个循环格不满足完美,你可以随意修改任意一个元素的箭头直到完美。例如下图,左边不是一个完美的循环格,因为只有从(1,1),(1,2),(2,0),(2,3)出发才会回到起始位置。通过修改其中两个箭头,可以得到右图,一个完美的循环格。

 ![](https://cdn.luogu.com.cn/upload/pic/10987.png) 

给定一个循环格,你需要计算最少需要修改多少个元素使其完美。


## 说明/提示

### 数据范围

30%的数据，1 ≤ R, C ≤ 7

100%的数据，1 ≤ R, C ≤ 15


## 样例 #1

### 输入

```
4 4
RRRD
URDD
UULD
ULLL```

### 输出

```
0```

## 样例 #2

### 输入

```
3 4
RRRD
URLL
LRRR```

### 输出

```
2```

# 题解

## 作者：w4p3r (赞：10)

## 思路：
其实其他题解思路讲的已经差不多了，我只是粗略的证明一下为什么每个点入度肯定必为1

首先我们证明：**若某个点入度大于1，这个图一定不是循环图**

显然，因为**每个点出度都为1**(由题意得)

如果某个点入度大于1，那至少有一个点的入度为0

入度为0的点肯定不符合条件，证毕。

然后我们证明：**若图中每个点入度都等于1，这个图一定是循环图**

其实也比较显然，因为**每个点出度都为1**(由题意得)，

若某个点从自己出发不能回到自己，那它就不能到**指向它的点**，同时也不能到**指向指向它的点的点**。。。

这样下去，它就不能到自己了，矛盾，证毕。

## 做法：
其他题解应该讲得够清楚了

## Code:
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#include<vector>
#include<stack>
#include<map>
#include<deque>
#define inf 0x7fffffff/2
#define eps 1e-6
#define N 100010
#define M 21
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
inline ll read()
{
	char ch=getchar();
	ll s=0,w=1;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
struct edge
{
	int next,to,fl,v;
}e[N<<1];
int head[N],dist[N],pre[N],minn[N],cnt=1;
int p[M][M],vis[N];
queue<int>Q;
int n,m,V;
int s,t;
int x[4]={0,0,1,-1},y[4]={1,-1,0,0};
inline int idx(int x,int y,int pos){return pos*V+(x-1)*m+y;}
inline void add_edge(int from,int to,int fl,int v){e[++cnt].to=to;e[cnt].next=head[from];e[cnt].fl=fl;e[cnt].v=v;head[from]=cnt;}
void update(int x,int flow)
{
	e[pre[x]].fl-=flow;
	e[pre[x]^1].fl+=flow;
	if(e[pre[x]^1].to)update(e[pre[x]^1].to,flow);
}
inline int spfa()
{
	memset(vis,0,sizeof(vis));while(!Q.empty())Q.pop();
	for(register int i=1;i<=t;i++)dist[i]=inf;
	minn[s]=inf;dist[s]=0;Q.push(s);vis[s]=1;
	while(!Q.empty())
	{
		int x=Q.front();vis[x]=0;Q.pop();
		for(register int i=head[x];i;i=e[i].next)
		{
			if(e[i].fl&&dist[e[i].to]>dist[x]+e[i].v)
			{
				dist[e[i].to]=dist[x]+e[i].v;
				minn[e[i].to]=min(minn[x],e[i].fl);
				pre[e[i].to]=i;
				if(!vis[e[i].to])
				{
					vis[e[i].to]=1;
					Q.push(e[i].to);
				}
			}
		}
	}
	if(dist[t]==inf)return inf;
	update(t,minn[t]);
	return dist[t]*minn[t];
}
inline int EK()
{
	int sum=0;
	while(1)
	{
		int x=spfa();
		if(x==inf)return sum;
		sum+=x;
	}
	return sum;
}//×îÐ¡·ÑÓÃ×î´óÁ÷ 
int main()
{
	n=read(),m=read();V=n*m+1;t=V*2+1;
	for(register int i=1;i<=n;i++)
	{
		char s[M];
		scanf("%s",s+1);
		for(register int j=1;j<=m;j++)
		{
			if(s[j]=='L'){p[i][j]=1;}
			if(s[j]=='R'){p[i][j]=0;}
			if(s[j]=='U'){p[i][j]=3;}
			if(s[j]=='D'){p[i][j]=2;}//ÅÐ¶Ï·½Ïò 
		}
	}
	for(register int i=1;i<=n;i++)
	{
		for(register int j=1;j<=m;j++)
		{
			for(register int k=0;k<4;k++)
			{
				int tox=i+x[k],toy=j+y[k];
				if(tox==0)tox=n;
				if(tox==n+1)tox=1;
				if(toy==0)toy=m;
				if(toy==m+1)toy=1;//×¢ÒâÔ½½çµÄÊ±ºòµÄ´¦Àí 
				int val=(!(p[i][j]==k));//¿´µ±Ç°·½ÏòÓë±¾À´µÄ·½ÏòÊÇ·ñÏàÍ¬ 
				add_edge(idx(i,j,0),idx(tox,toy,1),1,val);add_edge(idx(tox,toy,1),idx(i,j,0),0,-val);
			}
		}
	}
	for(register int i=1;i<=n;i++)
	{
		for(register int j=1;j<=m;j++)
		{
			add_edge(s,idx(i,j,0),1,0);add_edge(idx(i,j,0),s,0,0);
			add_edge(idx(i,j,1),t,1,0);add_edge(t,idx(i,j,1),0,0);
		}
	}
	printf("%d\n",EK());
	return 0;
}

```
**如果认为我这篇题解对你有帮助的可以给我点一下赞qwq。如果有任何疑问，或者认为我的题解有什么问题的话，请务必私信我，感激不尽！我会努力把我的题解写得最好的!**

---

## 作者：strcmp (赞：5)

**题目大意：** 给定一个 $n \times m$ 的字符串网格图，字符集为 $\{\texttt{L},\,\texttt{R},\,\texttt{U},\,\texttt{D}\}$，分别代表若进入当前网格，则需要分别向左，右，上，下方向走一格。求出一个修改网格图中字符的方案，使得**从任意初始网格出发，经过若干轮之后都会回到初始网**格，输出最小的修改次数。

### Solution

一般来说这种状压很难做的小范围的网格题，往网络流的方向想是没有错的。

- **结论 $1$：** 若将**答案的网格图**中网格所指向的方向连一条有向边，建出的有向图满足**所有结点的入度都为 $1$。**

**证明：** 

显然，所有结点的出度都为 $1$，图中结点的出度之和为 $n \times m$。

又，有向图中结点入度之和与出度之和相等，所以图中结点入度之和为 $n \times m$。

考虑反证法，设存在一个结点入度大于等于 $2$。则剩下 $n \times m - 1$ 个结点的入度之和必然小于或等于 $n \times m - 2$，根据抽屉原理，必然存在一个结点入度为 $0$。而从入度为 $0$ 的结点出发，必然不存在任何进入该结点的路径，所以没有结点的入度大于等于 $2$。结点入度为 $0$ 的情况同理。

证毕。

- **结论 $2$**：在任意合法方案中，若将任意结点所出发的回路视记录下来，**这些回路两两之间必然不相交。**

证明：假设存在两个回路相交，则在其中某一回路的某一结点上必然存在出边同时指向该回路的某个结点和另一个回路的某个结点，与结点出度都为 $1$ 矛盾，所以回路之间必然两两不相交。（这点很重要）

如果您做过 [P4003](https://www.luogu.com.cn/problem/P4003)，这道题就是一个弱化版。

由于要同时方案的合法性和修改的最优性，考虑费用流。

为了同时描述每个结点是出流还是入流，我们选择拆点，将 $u$ 拆为 $u'$ 和 $u''$，分别表示当前的流是要从 $u$ 出去还是直接从 $u$ 进去。

每个结点都可以出发，于是建立超级源点 $s$，从 $s$ 连向所有结点 $u$ 的入点 $u'$。容量为 $1$，费用为 $0$。

$u$ 可以无代价的走到当前方向所代表的位置，可以直接连对应方向的结点的**出点**，容量为 $1$，费用为 $0$。其他方向需要一次费用为 $1$ 的选择，容量仍然为 $1$，费用为 $1$。（这里可以使得容量为 $1$ 的原因就是引理 $2$ 的限制，每一个结点必然只被一个回路经过）

此时我们对每个结点的出点，直接连向超级汇点 $t$ 即可。

跑费用流，费用流即为答案。

#### 考虑为什么这样做是对的。

首先证明其**合法性。**

要证明合法性，首先有 $n,\,m \ge 2$ 时答案的**存在性**。

这本质上是网格图的多重回路覆盖问题计数，可以直接构造，略。

证明了存在性，则若要使得最大流最大，每个结点必然出去了一个流，进入了一个流，使得总和为 $n \times m$，按照流的方向构造方案。这点可以直接构造一个多重回路覆盖然后将环上的结点的流强制导向下一个结点，最大流已经是 $n \times m$ 了，该方案的合法性是显然的。

接下来证明其**最优性**，假设存在方案使得最小费用不优，则直接按照该方案，在环上将每个结点导向环上下一个结点的出点。该流是合法的，与最小费用矛盾。所以最小费用流的费用即为最优方案的答案。

参考代码：（远古代码，请见谅）

```cpp
#include <bits/stdc++.h>
using namespace std;
#define inf 1000000000000000
#define V 100100
#define E 500100
typedef long long int ll;
struct edge {
	int to, next;
	ll capa, cost;
};
int cnt = 0, head[V], n, m; edge node[E];
inline void add(int fir, int nxt, ll w, ll c) {
	node[cnt].to = nxt,
		node[cnt].capa = w,
		node[cnt].cost = c,
		node[cnt].next = head[fir],
		head[fir] = cnt++;
}
int s, t, cur[V]; deque<int>que; ll dep[V], sum = 0, cost = 0;
bool vis[V];
inline bool spfa() {
	for (register int i = 1; i <= t; ++i)dep[i] = inf;
	dep[s] = 0; que.push_back(s); int u, v;
	while (!que.empty()) {
		v = que.front(); que.pop_front();
		for (register int i = head[v]; i != -1; i = node[i].next) {
			u = node[i].to;
			if (dep[v] + node[i].cost < dep[u] && node[i].capa) {
				dep[u] = dep[v] + node[i].cost;
				if (!que.empty() && dep[u] < dep[que.front()])que.push_front(u);
				else que.push_back(u);
			}
		}
	}
	return (dep[t] != inf);
}
ll dfs(register int v, register ll flow) {
	if (flow == 0 || v == t)return flow; ll used = 0, wei = 0;
	vis[v] = true;
	for (register int i = cur[v]; i != -1; i = node[i].next) {
		cur[v] = i;
		if (!vis[node[i].to] && dep[node[i].to] == dep[v] + node[i].cost && node[i].capa) {
			wei = dfs(node[i].to, min(flow - used, node[i].capa));
			if (wei) {
				node[i].capa -= wei,
					node[i ^ 1].capa += wei,
					used += wei,
					cost += node[i].cost * wei;
			}
		}
		if (used == flow)break;
	}
	vis[v] = false;
	return used;
}
inline void Dinic() {
	while (spfa()) {
		memcpy(cur, head, (t + 1) * sizeof(int));
		sum += dfs(s, inf);
	}
}
inline void addE(int u, int v, ll w, ll c) {
	add(u, v, w, c);
	add(v, u, 0, -c);
}
inline int iid(int x, int y) {
	return (x - 1) * m + y;
}
inline int oid(int x, int y) {
	return iid(x, y) + n * m;
}
int mtx[205][205]; char c;
int dx[5] = { 0, 1, 0 ,-1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };
int main() {
	ios::sync_with_stdio(0);
	cin.tie(); cout.tie();
	memset(head, -1, V * sizeof(int));
	cin >> n >> m; s = 2 * n * m + 1, t = 2 * n * m + 2;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> c;
			if (c == 'D')mtx[i][j] = 1;
			else if (c == 'R')mtx[i][j] = 2;
			else if (c == 'U')mtx[i][j] = 3;
			else mtx[i][j] = 4;
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			addE(s, iid(i, j), 1, 0);
			addE(oid(i, j), t, 1, 0);
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			for (int k = 1; k <= 4; k++) {	
				int nx = i + dx[k], ny = j + dy[k];
				if (nx == 0)nx = n;
				else if (nx == n + 1)nx = 1;
				if (ny == 0)ny = m;
				else if (ny == m + 1)ny = 1;
				if (k != mtx[i][j])addE(iid(i, j), oid(nx, ny), 1, 1);
				else addE(iid(i, j), oid(nx, ny), 1, 0);
			}
		}
	}
	Dinic();
	cout << cost << "\n";
	return 0;
}
```


---

## 作者：破忆 (赞：4)

### 题目大意

在网格图中，每个点有一个方向，经过这个点之后要往这个方向走一格走到下一个点，如果走出网格图就从另一边进去，这些方向可以更改，要求从任意一点出发，经过若干步之后能重新回到此点


### 分析

每个点都有指向，那么边数就与点数相同，每个点的出度就是1

要求能重新回到这个点，这个点的入度也至少是1，显然，每个点的入度都是1

既然每个点的出、入度都是1，那么就会形成若干个环，每个点的出边连向另一个点，某个点的出边连向这个点

把一个点拆成2个点，整张图上每个出点与入点一一匹配

既然这些点都一一对应，那就可以跑带权二分图匹配了

### 做法

让每个点往4个方向连边，容量为1，费用为是否需要改变方向

建立超级源点与超级汇点，连上每个点，显然容量为1，费用为0

```cpp
int now=get(i,j);
ADD(S,now,1,0),ADD(now+k,T,1,0);
ADD(now,get(i-1,j)+k,1,c[j]!='U');
ADD(now,get(i+1,j)+k,1,c[j]!='D');
ADD(now,get(i,j-1)+k,1,c[j]!='L');
ADD(now,get(i,j+1)+k,1,c[j]!='R');
```
此处get(i,j)是把二维的矩阵转化为一维，在跑费用流的时候较方便

```cpp
int get(int x,int y){
	x=x<1?x+n:(x>n?x-n:x);
	y=y<1?y+m:(y>m?y-m:y);
	return (x-1)*m+y;
}
```
费用流打版子即可

具体细节请看代码

### 解法

带权二分图匹配，费用流

### 代码

```cpp
#include<bits/stdc++.h>
#define IN inline
using namespace std;
const int maxn=10005,maxe=maxn<<3,INF=1<<30;
int n,m,S,T,k,ans;
int tot=1,lnk[maxn];
int que[maxn],flow[maxn],dis[maxn],pre[maxn],lst[maxn];
bool vis[maxn];
char c[20];

struct edge{
	int to,nxt,flow,dis;
}e[maxe];

IN int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}


IN int get(int x,int y){
	x=x<1?x+n:(x>n?x-n:x);
	y=y<1?y+m:(y>m?y-m:y);
	return (x-1)*m+y;
}
/*以下是费用流板子*/
IN void add_e(int x,int y,int f,int d){
	e[++tot]=(edge){y,lnk[x],f,d};
	lnk[x]=tot;
}
void ADD(int x,int y,int f,int d){
	add_e(x,y,f,d),add_e(y,x,0,-d);
}

bool SPFA(int s,int t){
	for(int i=1;i<=T;i++) flow[i]=dis[i]=INF,pre[i]=-1;
	int hed=0,til=1;
	que[1]=s,vis[s]=1,dis[s]=0,pre[t]=-1;
	while(hed!=til){
		int x=que[hed=(++hed)%maxn];
		vis[x]=0;
		for(int j=lnk[x];j;j=e[j].nxt){
			int y=e[j].to;
			if(e[j].flow&&dis[y]>dis[x]+e[j].dis){
				dis[y]=dis[x]+e[j].dis;
				flow[y]=min(flow[x],e[j].flow);
				pre[y]=x;
				lst[y]=j;
				if(!vis[y]){
					vis[y]=1;
					que[til=(++til)%maxn]=y;
				}
			}
		}
	}
	return pre[t]!=-1;
}

void MCMF(int s,int t){
	while(SPFA(s,t)){
		ans+=(LL)flow[t]*dis[t];
		int now=t;
		while(now!=s){
			e[lst[now]].flow-=flow[t];
			e[lst[now]^1].flow+=flow[t];
			now=pre[now];
		}
	}
	return;
}
/*以上是费用流板子*/
int main(){
	freopen("P3965.in","r",stdin);
	freopen("P3965.out","w",stdout);
	n=read(),m=read(),k=n*m;//k是矩阵大小，把每个点拆成x（出点）与x+k（入点）
	S=2*n*m+1,T=2*n*m+2;
	for(int i=1;i<=n;i++){
		scanf("%s",c+1);
		for(int j=1;j<=m;j++){
			int now=get(i,j);
			ADD(S,now,1,0),ADD(now+k,T,1,0);
			ADD(now,get(i-1,j)+k,1,c[j]!='U');
			ADD(now,get(i+1,j)+k,1,c[j]!='D');
			ADD(now,get(i,j-1)+k,1,c[j]!='L');
			ADD(now,get(i,j+1)+k,1,c[j]!='R');
		}
	}
	MCMF(S,T);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：大菜鸡fks (赞：2)

总体来说这题每一步需要的思维含量都不大。

然而我并没想出来。

首先第一个比较容易yy的结论：每个点入度出度必须为1.

然后就可以建图，先拆点。

由于每个点出度为0，所以源点提供1的流量给每个点

由于每个点入度为0，所以每个点向汇点的边流量为1.

考虑如何分配一个点的出度（实际上就是给另外一个点增加入度）。采用费用流，若与当前方向不同，费用为1，否则为0，流量恒为1.

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=20,maxn=700,M=100005,mod=600;
struct edge{
	int link,next,w1,w2,opp;
}e[M];
int g[N][N],n,m,tot,S,T,head[maxn];
int xx[4]={0,0,-1,1},yy[4]={-1,1,0,0};
char s[N];
inline void add_edge(int u,int v,int w1,int w2){
	e[++tot]=(edge){v,head[u],w1,w2}; head[u]=tot;
}
inline void insert(int u,int v,int w1,int w2){
	add_edge(u,v,w1,w2); e[tot].opp=tot+1;
	add_edge(v,u,0,-w2); e[tot].opp=tot-1;
}
int id[200];
inline void init(){
	scanf("%d%d",&n,&m);
	id['L']=0; id['R']=1; id['U']=2; id['D']=3;
	for (int i=1;i<=n;i++){
		for (int j=1;j<=m;j++){
			g[i][j]=(i-1)*m+j;
		}
	}
	for (int i=1;i<=n;i++){
		scanf("%s",s+1);
		for (int j=1;j<=m;j++){
			for (int k=0;k<4;k++){
				int X=(i+xx[k]-1+n)%n+1,Y=(j+yy[k]-1+m)%m+1;
				if (k==id[s[j]]){
					insert(g[i][j],g[X][Y]+n*m,1,0);
				}else{
					insert(g[i][j],g[X][Y]+n*m,1,1);
				}
			}
		}
	}
}
const int inf=1e9;
bool vis[maxn];
int ans,flow[maxn],pre[maxn],pred[maxn],dis[maxn],q[maxn],h,t;
inline void back(int i,int w){e[i].w1-=w; e[e[i].opp].w1+=w;}
inline int spfa(){
	memset(dis,127/3,sizeof(dis));
	dis[S]=0; q[++t]=S; flow[S]=inf; flow[T]=0;
	while (h!=t){
		int u=q[h=h%mod+1];
		for (int i=head[u];i;i=e[i].next){
			int v=e[i].link;
			if (e[i].w1&&dis[v]>dis[u]+e[i].w2){
				dis[v]=dis[u]+e[i].w2; pre[v]=u; pred[v]=i;
				flow[v]=min(flow[u],e[i].w1);
				if (!vis[v]){
					q[t=t%mod+1]=v;
					vis[v]=1;
				}
			}
		}
		vis[u]=0;
	}
	if (flow[T]==0) return 0;
	int u=T;
	while (u!=S){
		back(pred[u],flow[T]);
		u=pre[u];
	}
	ans+=flow[T]*dis[T];
	return 1;
}
inline void solve(){
	T=n*m*2+1;
	for (int i=1;i<=n*m;i++){
		insert(S,i,1,0);
		insert(i+n*m,T,1,0);
	}
	while (spfa());
	printf("%d\n",ans);
}
int main(){
	init();
	solve();
	return 0;
}
```

---

## 作者：ZHR100102 (赞：1)

简单费用流，5min 秒了。

# 观察

考虑循环格的性质，不难发现我们可以把每个格子看做一个节点，那么每个节点便都有一个出度指向其他节点。这个就很像内向基环树的性质啊，如果循环格合法（从每个点出发能回到自己），那么就得满足每个点都在一个环中。问题就转化为我们要最小化操作次数，使得所有点都在一个环里。

继续考虑环的性质，显然形成环是需要每个点入度都是 $1$，出度也都是 $1$。出度的限制已经满足了，我们只要让每个点的入度都是 $1$ 即可。这应该是一个很典的 trick 了吧。

# 建模

到这里就是好做的了。你发现把每个点拆成入点和出点，把每个节点能旋转到的四个方向分别看做容量为 $1$ 的边，不用旋转的方向费用为 $0$，其余三个方向费用为 $1$，跑最小费用最大流即可。本质上就是个二分图匹配。

时间复杂度为 EK 或者 Dinic 的复杂度。

# 代码

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
#define lc(x) (tr[x].ls)
#define rc(x) (tr[x].rs)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair<int,int>;
const int N=1005,M=1000005;
const ll inf=0x3f3f3f3f3f3f3f3f;
int n,m,s,t;
void getpos(int &x,int &y,int twd)
{
    if(twd==0)x+=1;
    else if(twd==1)x-=1;
    else if(twd==2)y+=1;
    else if(twd==3)y-=1;
    if(x==0)x=n;
    else if(x==n+1)x=1;
    if(y==0)y=m;
    else if(y==m+1)y=1;
}
int getid(int x,int y,int tp)
{
    return ((x-1)*m+y+tp*n*m);
}
int h[N],cur[N],idx=1;
struct Edge{
    int v,ne;
    ll c,w;
}e[M];
void add(int u,int v,ll c,ll w)
{
    e[++idx]={v,h[u],c,w};
    h[u]=idx;
}
void addeg(int u,int v,ll c,ll w)
{
    add(u,v,c,w);
    add(v,u,0,-w);
}
ll dis[N],cost;
bitset<N>vis;
bool SPFA()
{
    memset(dis,0x3f,sizeof(dis));
    vis.reset();
    queue<int>q;
    dis[s]=0;
    q.push(s);
    vis[s]=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(int i=h[u];i;i=e[i].ne)
        {
            int v=e[i].v;ll c=e[i].c,w=e[i].w;
            if(dis[v]>dis[u]+w&&c)
            {
                dis[v]=dis[u]+w;
                if(vis[v]==0)
                {
                    vis[v]=1;
                    q.push(v);
                }
            }
        }
    }
    return (dis[t]<=inf/2);
}
ll dfs(int u,ll mf)
{
    if(u==t)return mf;
    ll sm=0;
    vis[u]=1;
    for(int i=cur[u];i;i=e[i].ne)
    {
        int v=e[i].v;ll c=e[i].c,w=e[i].w;
        if(vis[v]==0&&dis[v]==dis[u]+w&&c)
        {
            ll res=dfs(v,min(c,mf));
            cost+=w*res;
            e[i].c-=res;
            e[i^1].c+=res;
            mf-=res;
            sm+=res;
            if(mf==0)break;
        }
    }
    if(sm==0)dis[u]=inf;
    return sm;
}
void dinic()
{
    ll flow=0;
    while(SPFA())
    {
        memcpy(cur,h,sizeof(h));
        vis.reset();
        flow+=dfs(s,inf);
    }
}
int main()
{
    //freopen("sample.in","r",stdin);
    //freopen("sample.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    s=n*m*2+1,t=n*m*2+2;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            char c;
            cin>>c;
            for(int k=0;k<4;k++)
            {
                int w=1,tx=i,ty=j;
                getpos(tx,ty,k);
                if(c=='D'&&k==0)w=0;
                if(c=='U'&&k==1)w=0;
                if(c=='R'&&k==2)w=0;
                if(c=='L'&&k==3)w=0;  
                addeg(getid(i,j,0),getid(tx,ty,1),1,w);              
            }
            addeg(s,getid(i,j,0),1,0);
            addeg(getid(i,j,1),t,1,0);
        }
    }
    dinic();
    cout<<cost;
    return 0;
}
```

---

## 作者：mqmhaaaa1 (赞：1)

# 省流：弱化版[p4003](https://www.luogu.com.cn/problem/P4003)
# 思路
首先看到满足要求，费用最小，想到费用流（别问我为什么不是状压，因为我不会。

有看到四个方向网格图，想到 p4003（没错，那是我切的第一道黑题。

没想到（做过）也没关系，我们来看题

首先能发现规律：

1. 在一个符合标准的图中，所有格子出度入度都为 $1$。

出度为 $1$ 显然，入度我们来理解下。先假设有一条路径可以满足要求，那么如果这条路径的格子被这条路径外的格子指定时，在路径外的格子则永远无法在回到原位，因为它会在这条满足要求的路径上一直打转。当一个格子没有入度时，它则无法被其他格子到达，显然也不能绕一圈回到原位。所以在一个满足要求的图中每个格子入度都为 $1$。

2. 在一个符合标准的图中，所有路径不相交。

很明显不用细说了，性质一已经说明了。

所以说会有一个思路：把每个格子当做点，然后向四联通（注意，这题超界是从另一端出来）的格子匹配，用费用流，这样既保证了满足条件（最大流实用点），也满足了最优（最小费用。

# 具体做法
把每个格子拆成两个点，$u$ 和 $u1$。

以 $u$ 为出点，源点 $s$ 向它连容量 $1$，费用 $0$ 的边，接着它向四联通格子的出点 $v1$ 连容量为 $1$ 的边，费用则是看格子 $u$ 原本的方向，朝向原方向的格子连费用为 $0$ 的边，其他的连费用为 $1$ 的边，用来匹配。

以 $u1$ 为入点，向汇点 $t$ 连容量为 $1$，费用为 $0$ 的边。

这样建图相当于建了个带权的二分图，用最小费用最大流跑最大匹配，因为本题图的性质，会是一个完美匹配，满足题意，同时费用最小。

看看洒家的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll int
#define Gc() (iS==iT?(iT=(iS=ibuf)+fread(ibuf,1,__SIZE,stdin),(iS==iT?EOF:*iS++)):*iS++)
namespace io{const int __SIZE=(1<<21)+1;char ibuf[__SIZE],*iS,*iT,obuf[__SIZE],*oS=obuf,*oT=oS+__SIZE-1,__c,qu[55];int __f,qr,_eof;inline void flush(){fwrite(obuf,1,oS-obuf,stdout),oS=obuf;}inline void gc(char&x){x=Gc();}inline void pc(char x){*oS++=x;if(oS==oT)flush();}inline void pstr(const char*s){int __len=strlen(s);for(__f=0;__f<__len;++__f)pc(s[__f]);}inline void gstr(char *s){for(__c=Gc();__c<32||__c>126||__c==' ';)__c=Gc();for(;__c>31&&__c<127&&__c!=' '&&__c!='\n'&&__c!='\r';++s,__c=Gc())*s=__c;*s=0;}template<class I>inline bool gi(I&x){_eof=0;for(__f=1,__c=Gc();(__c<'0'||__c>'9')&&!_eof;__c=Gc()){if(__c=='-')__f=-1;_eof|=__c==EOF;}for(x=0;__c<='9'&&__c>='0'&&!_eof;__c=Gc())x=x*10+(__c&15),_eof|=__c==EOF;x*=__f;return!_eof;}template<class I>inline void print(I x){if(!x)pc('0');if(x<0)pc('-'),x=-x;while(x)qu[++qr]=x%10+'0',x/=10;while(qr)pc(qu[qr--]);}struct Flusher_{~Flusher_(){flush();}}io_flusher_;}using io::pc;using io::gc;using io::pstr;using io::gstr;using io::gi;using io::print;
ll read() {ll x = 0, w = 1;char ch = 0;while (ch < '0' || ch > '9') {  if (ch == '-') w = -1;ch = getchar();}while (ch >= '0' && ch <= '9') {x = x * 10 + (ch - '0'); ch = getchar(); }return x * w; }
void write(ll x) {static ll sta[35];ll top = 0;do {sta[top++] = x % 10, x /= 10;} while (x);while (top) putchar(sta[--top] + 48);}
const ll N=1e4+10,M=1e5+10,inf=0x3f3f3f3f;
const ll dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
ll to[M<<1],nxt[M<<1],w[M<<1],c[M<<1],bh[N];
ll head[N];
ll tot=1;
inline void add(ll u,ll v,ll z,ll cost){
	to[++tot]=v;
	nxt[tot]=bh[u];
	w[tot]=z;
	c[tot]=cost;
	bh[u]=tot;
	
    to[++tot]=u;
	nxt[tot]=bh[v];
	w[tot]=0;
	c[tot]=-cost;
	bh[v]=tot;
}
ll s,t;
ll d[N];bool vis[N];
inline bool spaf(){
	for(int i=s;i<=t;i++){
		d[i]=inf;vis[i]=0;head[i]=bh[i];
	}
	queue<ll>jb;
	jb.push(s);vis[s]=1;
	d[s]=0;
	while(!jb.empty()){
		ll u=jb.front();jb.pop();
		vis[u]=0;
		for(ll i=bh[u];i;i=nxt[i]){
			ll v=to[i];
			if(w[i]&&d[v]>d[u]+c[i]){
				d[v]=d[u]+c[i];
				if(!vis[v]){
					vis[v]=1;
					jb.push(v);
				}
			}
		}
	}
	return d[t]!=inf;
}
ll ans=0;
ll dinic(ll u,ll flow){
	ll zy=0;vis[u]=1;
	if(u==t)return flow;
	for(ll i=head[u];i&&zy<=flow;i=nxt[i]){
		ll v=to[i];head[u]=i;
		if(w[i]&&d[v]==d[u]+c[i]&&(!vis[v]||v==t)){
			ll jb=dinic(v,min(w[i],flow-zy));
			zy+=jb;w[i]-=jb;w[i^1]+=jb;
			ans+=jb*c[i];
		}
	}
    vis[u]=0;
	return zy;
}
//前面板子 
ll n,m;
ll id(ll i,ll j){
	return (i-1)*m+j;
}
ll mp[30][30];
void jt(ll i,ll j){//见图 
	ll u=id(i,j),u1=u+n*m;
	add(s,u,1,0);add(u1,t,1,0);
	for(ll k=0;k<4;k++){//0上1右2下3左 
		ll vx=i+dx[k],vy=j+dy[k];
		if(vx<1)vx=n;if(vx>n)vx=1;
		if(vy<1)vy=m;if(vy>m)vy=1;
		//判超界 
		ll v=id(vx,vy),v1=v+n*m;
		if(k==mp[i][j]){
			add(u,v1,1,0);
		}else add(u,v1,1,1);
		//看方向 
	}
}
int main(){
	n=read();m=read();
	s=0,t=n*m*2+1;
	for(ll i=1;i<=n;i++){
		string s;cin>>s;
		for(ll j=1;j<=m;j++){
			if(s[j-1]=='L')mp[i][j]=3;
			else if(s[j-1]=='D')mp[i][j]=2;
			else if(s[j-1]=='R')mp[i][j]=1;
			else mp[i][j]=0;
			//0上1右2下3左 
		}
	}
	for(ll i=1;i<=n;i++){
		for(ll j=1;j<=m;j++){
			jt(i,j);
		}
	}
	while(spaf()){
		vis[t]=1;
		while(vis[t]){
			memset(vis,0,sizeof vis);
			dinic(s,inf);
		}
	}
	cout<<ans;
	return 0;
}
```
感谢观看。

对了建议把 p4003 做了，很有意思的题，当做此题升级版即可。

---

## 作者：elijahqi (赞：1)

建图方法 好神 啊 自己yy一个错误做法 可惜最后还是看了题解的

针对原题的这个要求可以转化成 每个点的入度和出度恰好为1  保证这一点即可

那么我们把每个点拆成入度点和出度点 然后互相连边跑费用流即可

源点向每个点的入度连边 每个点出度向汇点连边   然后向四周连边 如果原来就是指向这个方向 那么显然 花费就是0否则我需要花费1才可以 为了满足原图的要求 我肯定是最大流就可以满足 这时候再看下费用即可

[辣鸡蒟蒻我的blog QWQ](http://www.elijahqi.win/2017/12/11/bzoj3171luogu3965-tjoi2013循环格/ "辣鸡蒟蒻我的blog QWQ")

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define inf 0x3f3f3f3f
#define N 500
using namespace std;
char s[N][N];
int dx[]={0,1,0,-1},dy[]={1,0,-1,0},num=1,r,c,T,nn;
inline int calc(int x,int y,int op){
    if (op==1) return (x-1)*c+y;else return (x-1)*c+y+nn;
}
int h[N],pre[N],path[N],flag[N],f[N];
struct node{
    int y,z,next,c;
}data[N<<4];
inline void insert1(int x,int y,int z,int c){
    data[++num].y=y;data[num].z=z;data[num].next=h[x];h[x]=num;data[num].c=c;
    data[++num].y=x;data[num].z=0;data[num].next=h[y];h[y]=num;data[num].c=-c;
}
inline bool spfa(){
    queue<int>q;memset(flag,0,sizeof(flag));memset(f,0x3f,sizeof(f));flag[0]=1;f[0]=0;memset(pre,-1,sizeof(pre));q.push(0);
    while(!q.empty()){
        int x=q.front();q.pop();flag[x]=0;
        for (int i=h[x];i;i=data[i].next){
            int y=data[i].y,z=data[i].z,c=data[i].c;
            if (f[x]+c<f[y]&&z){
                f[y]=f[x]+c;pre[y]=x;path[y]=i;
                if (!flag[y]) flag[y]=1,q.push(y);
            }
        }
    }if (pre[T]==-1) return 0;else return 1;
}
int main(){
    freopen("bzoj3171.in","r",stdin);
    scanf("%d%d",&r,&c);T=r*c*2+1;nn=r*c;
    for (int i=1;i<=r;++i) scanf("%s",s[i]+1);
    for (int i=1;i<=r;++i){
        for (int j=1;j<=c;++j){
            int tmp;if (s[i][j]=='R') tmp=0;insert1(0,calc(i,j,1),1,0);insert1(calc(i,j,2),T,1,0);
            if (s[i][j]=='D') tmp=1;if(s[i][j]=='L') tmp=2;if (s[i][j]=='U') tmp=3;
            for (int k=0;k<4;++k){
                int x1=i+dx[k],y1=j+dy[k];if (x1==0) x1=r;if (x1==r+1) x1=1;if (y1==0) y1=c;if (y1==c+1) y1=1;
                if(tmp==k){insert1(calc(i,j,1),calc(x1,y1,2),1,0);continue;}
                insert1(calc(i,j,1),calc(x1,y1,2),1,1);
            }
        }
    }int ans=0;
    while(spfa()){
        int now=T,minn=inf;
        while(now) minn=min(minn,data[path[now]].z),now=pre[now];now=T;
        while(now){ans+=minn*data[path[now]].c;data[path[now]].z-=minn;data[path[now]^1].z+=minn;now=pre[now];}
    }printf("%d",ans);
    return 0;
}
```

---

## 作者：撤云 (赞：1)

### [$$My\ blog$$](https://www.cnblogs.com/hbxblog/p/10262281.html)
---
### 题目链接
[戳我](https://www.luogu.org/problemnew/show/P3965)
### $Solution$
我们观察发现循环格要满足每个点的入度都为$1$

证明:
>我们假设每个点的入读不一定为$1$，那么必定有一个或多个点的入度为0，那么则不满足循环格的定义，所以假设错误。所以每个点的入度必然为1。  

所以这样我们就可以开始建图了。先进行拆点操作，将每个点拆成$x$和$x'$将$x$和$S$连接，流量为$1$，费用为$0$再将$x'$和$T$连接，流量为$1$，费用为$0$

最后对于每个点$x$将它和四周的$'$点相连接。流量为1,费用的话在判断一下方向和字符是否相同，如果相同为$0$，不同为$1$
$end.$

### $Code$
``` cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int read() {
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9')
        f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9')
        x=x*10+c-'0',c=getchar();
    return x*f;
}
struct node {
    int to,next,v,w;
} a[1000001];
int dis[10001],f[10001],pre[10001],fa[10001],s,t,n,m,head[10001],cnt,x,y,z,c;
void add(int x,int y,int c,int v) {
    a[++cnt].to=y;
    a[cnt].next=head[x];
    a[cnt].v=c;
    a[cnt].w=v;
    head[x]=cnt;
}
queue < int > q;
int spfa() {
    q.push(s);
    memset(dis,127,sizeof(dis));
    memset(f,0,sizeof(f));
    f[s]=1,dis[s]=0;
    int inf=dis[s+1];
    while(!q.empty()) {
        int now=q.front();
        q.pop();
        f[now]=0;
        for(int i=head[now]; i; i=a[i].next) {
            int v=a[i].to;
            if(dis[v]>dis[now]+a[i].w&&a[i].v) {
                dis[v]=dis[now]+a[i].w,pre[v]=i,fa[v]=now;
                if(!f[v])
                    f[v]=1,q.push(v);
            }
        }
    }
    if(dis[t]!=inf)
        return 1;
    return 0;
}
int ans1,ans;
void anser() {
    while(spfa()) {
        int minx=2147483647;
        for(int i=t; i!=s; i=fa[i])
            minx=min(minx,a[pre[i]].v);
        ans+=minx,ans1+=dis[t]*minx;
        for(int i=t; i!=s; i=fa[i])
            a[pre[i]].v-=minx,(pre[i]%2)?a[pre[i]+1].v+=minx:a[pre[i]-1].v+=minx;
    }
}
char hh[10]= {'0','D','U','L','R'};
int fx[10]= {0,1,-1,0,0};
int fy[10]= {0,0,0,-1,1};
char ss[101][101],l[1001];
int main() {
    int N=read(),M=read();
    s=0,t=N*M*10,n=N*M;
    for(int i=1; i<=n; i++)
        add(s,i,1,0),add(i,s,0,0);
    for(int i=1; i<=n; i++)
        add(i+n,t,1,0),add(t,i+n,0,0);
    for(int i=1; i<=N; i++) {
        cin>>l;
        for(int j=0; j<M; j++)
            ss[i][j+1]=l[j];
    }
    for(int i=1; i<=N; i++)
        for(int j=1; j<=M; j++) {
            char pp=ss[i][j];
            for(int k=1; k<=4; k++) {
                int X=(i+fx[k]+N-1)%N+1,Y=(j+fy[k]+M-1)%M+1;
                int now=(i-1)*M+j,nex=(X-1)*M+n+Y,o=(pp==hh[k])^1;
                add(now,nex,1,o),add(nex,now,0,-o);
            }
        }
    anser();
    printf("%d",ans1);
}

```

---

## 作者：__Aaaaaaaa (赞：0)

## Solution:

费用流。

我们可以发现一个比较~~显然~~套路的结论，就是如果存在循环，说明每个点的入度和出度都为 $1$ 才可以。

我们将所有格子进行拆点，相邻格子之间（由一个格子的出点连向另一个格子的入点）有一条容量为 $1$ 的边相连，表示相邻点之间的出度最大贡献。

表示度数限制：源点向所有出点的 $1$ 和 所有入点向汇点的 $1$ 分别限制出度和入度，当图满流时，所有点都在循环中。
![](https://cdn.luogu.com.cn/upload/image_hosting/9oacj01d.png)

现在考虑费用。

每个格子都有一个不需要变化就可以指向的点，其费用显然为 $0$，对于其相邻的另外三个格子都连 $1$，表示由此格子到相邻格子需要一次变化的代价。

![](https://cdn.luogu.com.cn/upload/image_hosting/7vp5oxw2.png)

---

## 作者：Mark_4396 (赞：0)

问题的本质为， 将一个n个点n条边的图改变最少的边，使得它的强连通分量的点数至少为2（为了方便起见，一个单独的点视作一个强连通分量）

问题当且仅当每个点的入度和出度等于1；

证明：
若存在入度等于0的点，该图不强连通
若粗在入度大于1的点，则不止n条边

性质：每个强连通分量都不会与另一个强连通分量有边（否则必然存在入度大于1）

不难想象题目的剩下建图方法


```
#include <bits/stdc++.h>
using namespace std;
 
const int INF = 0x3f3f3f3f;
const int maxn = 650;
const int maxm = 25000;
char ch[maxn][maxn];
int mp[maxn][maxn];
int xx[4]={0,0,-1,1},yy[4]={-1,1,0,0};
 
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
    while (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
 
struct Edge
{
    int to, next, cap, flow, cost;
}edge[maxm];
int head[maxn], tol;
int pre[maxn], dis[maxn];
bool vis[maxn];
int N ;//节点总个数，节点编号从0~N-1
void init(int n)
{
    N = n;
    tol = 0;
    memset(head, -1, sizeof(head));
}
void addedge(int u, int v, int cap, int cost)
{
    edge[tol].to = v;
    edge[tol].cap = cap;
    edge[tol].cost = cost;
    edge[tol].flow = 0;
    edge[tol].next = head[u];
    head[u] = tol++;
    edge[tol].to = u;
    edge[tol].cap = 0;
    edge[tol].cost = -cost;
    edge[tol].flow = 0;
    edge[tol].next = head[v];
    head[v] = tol++;
}
 
bool spfa(int s, int t)
{
    queue<int>q;
    for(int i = 0; i < N; i++)
    {
        dis[i] = INF;
        vis[i] = false;
        pre[i] = -1;
    }
    dis[s] = 0;
    vis[s] = true;
    q.push(s);
    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            int v = edge[i].to;
            if(edge[i].cap > edge[i].flow && dis[v] > dis[u] + edge[i].cost)
            {
                dis[v] = dis[u] + edge[i].cost;
                    pre[v] = i;
                if(!vis[v])
                {
                    vis[v] = true;
                    q.push(v);
                }
            }
        }
    }
    if(pre[t] == -1) return false;
    else return true;
}
 
int minCostMaxflow(int s, int t, int &cost)
{
    int flow = 0;
    cost = 0;
    while(spfa(s,t))
    {
        int Min = INF;
        for(int i = pre[t]; i != -1; i = pre[edge[i^1].to])
        {
            if(Min > edge[i].cap - edge[i].flow)
                Min = edge[i].cap - edge[i].flow;
        }
        for(int i = pre[t]; i != -1; i = pre[edge[i^1].to])
        {
            edge[i].flow += Min;
            edge[i^1].flow -= Min;
            cost +=  edge[i].cost*Min;
        }
        flow += Min;
    }
    return flow;
}
 
int main()
{
    int l, r;
    cin >> l >> r;
    for(int i = 1; i <= l; i++)
    {
        scanf("%s", ch[i]+1);
        for(int j = 1; j <= r; j++)
        {
            if(ch[i][j] == 'L') mp[i][j] = 0;
            else if(ch[i][j] == 'R') mp[i][j] = 1;
            else if(ch[i][j] == 'U') mp[i][j] = 2;
            else if(ch[i][j] == 'D') mp[i][j] = 3;
        }
    }
    int s = 0, t = l*r*2+1;
    init(t+1);
    for(int i = 1; i <= l; i++)
    {
        for(int j = 1; j <= r; j++)
        {
            for(int k = 0; k < 4; k++)
            {
                int nowx = i+xx[k], nowy = j+yy[k];
                if(nowx > l) nowx=1; if(nowx<1)nowx = l;
                if(nowy > r) nowy=1; if(nowy<1)nowy = r;
                if(k == mp[i][j])
                {
                    addedge((i-1)*r+j, (nowx-1)*r+nowy+l*r, 1, 0);
                }
                else
                {
                    addedge((i-1)*r+j, (nowx-1)*r+nowy+l*r, 1, 1);
                }
            }
        }
    }
    for(int i = 1; i <= l*r; i++)
    {
        addedge(s, i, 1, 0);
        addedge(i+l*r, t, 1, 0);
    }
    int c;
    minCostMaxflow(s,t,c);
    cout << c;
    return 0;
}
﻿
```


---

## 作者：wxwoo (赞：0)

[$$\color{#0e90d2}\huge{\texttt{my blog}}$$](https://wxwoo.github.io/2019/03/13/solution-p3965/)

******

[原题目链接](https://www.luogu.org/problemnew/show/P3965)

~~洛谷随机跳题跳到的~~

有指向，有修改，求最小：~~明显的~~最小费用最大流

我们将每个格子看成一个点，然后拆点，如下建边：

> 1. 源点向每个点连边，流量为1，费用为0
>
> 1. 每个点的拆点向汇点连边，流量为1，费用为0
>
> 1. 每个点向四周的点连边，流量为1，默认指向费用为0，其他为1

下面我们思考这样建边的正确性

根据最小费用最大流的性质，一定会优先费用为0的边（也就是默认指向）

由于每条边流量都是1，所以不存在一个点有两个指向这种情况

> ps：3，4数据点疑似在Windows下生成，使用getchar()要注意对\r的判断

代码如下

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
#define inf 1e9
const int N=3e5+1;
struct edge
{
    int from,to,next,cap,flow,cost;
}e[N];
bool vis[N];
int cnt,n,m,sour,sink,head[N],ans,cost,q[N],p[N],d[N],h,t;
const int move[4][2]={-1,0,1,0,0,-1,0,1};
inline void add(int u,int v,int l,int f)
{
    e[++cnt]=(edge){u,v,head[u],l,0,f};
    head[u]=cnt;
    e[++cnt]=(edge){v,u,head[v],0,0,-f};
    head[v]=cnt;
}
inline void augment()
{
    int detla=inf,c=0;
    for(int i=sink;i!=sour;i=e[p[i]].from)
    {
        detla=min(detla,e[p[i]].cap-e[p[i]].flow);
        c+=e[p[i]].cost;
    }
    for(int i=sink;i!=sour;i=e[p[i]].from)
    {
        e[p[i]].flow+=detla;
        e[((p[i]-1)^1)+1].flow-=detla;
    }
    ans+=detla;
    cost+=detla*c;
}
inline bool find()
{
    memset(d,127,sizeof(d));
    memset(vis,0,sizeof(vis));
    vis[sour]=true;
    d[sour]=0;
    q[h=t=1]=sour;
    while(h<=t)
    {
        int x=q[h++];
        vis[x]=false;
        for(int i=head[x];i;i=e[i].next)
        {
            if(e[i].cap>e[i].flow&&d[x]+e[i].cost<d[e[i].to])
            {
                if(!vis[e[i].to])
                {
                    vis[e[i].to]=true;
                    q[++t]=e[i].to;
                }
                d[e[i].to]=d[x]+e[i].cost;
                p[e[i].to]=i;
            }
        }
    }
    return d[sink]<inf;
}
inline void sap()
{
    while(find())
        augment();
}
inline void read(int &x)
{
    char ch;
    int f=1;
    x=0;
    do
    {
        if(ch=='-')
            f=-1;
        ch=getchar();
    }while(!('0'<=ch&&ch<='9'));
    do
    {
        x=(x<<3)+(x<<1)+ch-48;
        ch=getchar();
    }while('0'<=ch&&ch<='9');
    x*=f;
}
inline int get(int x,int y)
{
    return (x-1)*m+y;
}
int main()
{
    read(n);
    read(m);
    sour=0;
    sink=2*n*m+1;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
        	char c;
        	cin>>c;
        	int dir;
        	add(sour,get(i,j),1,0);
        	add(get(i,j)+n*m,sink,1,0);
        	if(c=='U')
        		dir=0;
        	else if(c=='D')
        		dir=1;
        	else if(c=='L')
        		dir=2;
        	else if(c=='R')
        		dir=3;
        	for(int k=0;k<4;k++)
        	{
        		int x=i+move[k][0],y=j+move[k][1];
        		if(x==n+1)
        			x=1;
        		else if(x==0)
        			x=n;
        		if(y==m+1)
        			y=1;
        		else if(y==0)
        			y=m;
        		if(dir==k)
        			add(get(i,j),get(x,y)+n*m,1,0);
        		else
        			add(get(i,j),get(x,y)+n*m,1,1);
        	}
        }
    }
    sap();
    printf("%d",cost);
    return 0;
}

```

---

## 作者：Huami360 (赞：0)


回路限制经典题。
每个点拆成入点和出点，源点连每个点的出点，流量1，费用0，每个点出点连汇点，流量1，费用0，入点和出点之间没有边。
也就是说每个点必须靠其他点流来的流量来流入汇点，同时自己的流量流出去，这时候就会形成环，只要把所有流量流满，就必定是题目要求的情形。
所以每个点向前后左右相邻点连边，如果本来就是这个方向，费用为0，否则费用为1，最小费用即为答案。
```cpp
#include <cstdio>
#include <queue>
#include <cstring>
#define INF 2147483647
using namespace std;
const int MAXN = 1010;
const int MAXM = 200010;
queue <int> q; 
int s, t, now, n, m;
struct Edge{
    int from, next, to, rest, cost;
}e[MAXM];
int head[MAXN], num = 1, dis[MAXN], vis[MAXN], Flow[MAXN], pre[MAXN];
inline void Add(int from, int to, int flow, int cost){
    e[++num] = (Edge){ from, head[from], to, flow, cost }; head[from] = num;
    e[++num] = (Edge){ to, head[to], from, 0, -cost }; head[to] = num;
}
int RoadsExist(){
    q.push(s);
    memset(dis, 127, sizeof dis);
    dis[s] = 0; Flow[s] = INF; pre[t] = 0;
    while(!q.empty()){
      now = q.front(); q.pop(); vis[now] = 0;
      for(int i = head[now]; i; i = e[i].next)
         if(e[i].rest && dis[e[i].to] > dis[now] + e[i].cost){
           dis[e[i].to] = dis[now] + e[i].cost;
           pre[e[i].to] = i;
           Flow[e[i].to] = min(Flow[now], e[i].rest);
           if(!vis[e[i].to]){
             vis[e[i].to] = 1;
             q.push(e[i].to);
           }
         }
    }
    return pre[t];
}
int a[20][20], mincost, l[] = {233, -1, 1, 0, 0}, r[] = {666, 0, 0, -1, 1};
int id(int i, int j, int k){
	return (i - 1) * m + j + k * 500;
}
char ch;
int main(){
    scanf("%d%d", &n, &m); s = 999; t = 1000;
    for(int i = 1; i <= n; ++i)
	   for(int j = 1; j <= m; ++j){
	       ch = getchar(); while(ch == '\n' || ch == '\r' || ch == ' ') ch = getchar();
	       if(ch == 'U') a[i][j] = 1;
	       if(ch == 'D') a[i][j] = 2;
	       if(ch == 'L') a[i][j] = 3;
	       if(ch == 'R') a[i][j] = 4;
	       Add(s, id(i, j, 0), 1, 0);
	       Add(id(i, j, 1), t, 1, 0);
	   }
	for(int i = 1; i <= n; ++i)
	   for(int j = 1; j <= m; ++j)
	      for(int k = 1; k <= 4; ++k){
	      	 int x = i + l[k], y = j + r[k];
	      	 if(!x) x = n; if(!y) y = m; if(x > n) x = 1; if(y > m) y = 1;
	      	 Add(id(i, j, 0), id(x, y, 1), 1, a[i][j] != k);
	      }
    while(RoadsExist()){
      mincost += Flow[t] * dis[t];
      for(int i = t; i != s; i = e[pre[i]].from){
         e[pre[i]].rest -= Flow[t];
         e[pre[i] ^ 1].rest += Flow[t];
      }
    }
    printf("%d\n", mincost);
    return 0;
}

```

---


# [NOI2008] 志愿者招募

## 题目描述

申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。经过估算，这个项目需要 $n$ 天才能完成，其中第 $i$ 天至少需要 $a_i$ 个人。布布通过了解得知，一共有 $m$ 类志愿者可以招募。其中第 $i$ 类可以从第 $s_i$ 天工作到第 $t_i$ 天，招募费用是每人 $c_i$ 元。新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。

## 说明/提示

$1\leq n\leq 1000$，$1\leq m\leq 10000$，题目中其他所涉及的数据均不超过 $2^{31}-1$。

## 样例 #1

### 输入

```
3 3
2 3 4
1 2 2
2 3 5
3 3 2```

### 输出

```
14```

# 题解

## 作者：Orion545 (赞：184)

# 广告

[蒟蒻的blog](http://www.cnblogs.com/dedicatus545/p/8777535.html)

由于本人水平有限，无法提供图片，各位dalao将就着看看吧

图片说明的话，楼下那位有哦（虽然也就是一张比较简略的【雾】）

# 正文

## 引入：网络流？

看到这道题，第一想法是用一个dp来完成决策

但是，显然这道题的数据并不允许我们进行dp，尤其是有10000种志愿者的情况下

那么我们就要想别的办法来解决：

贪心？这道题做的决策除了价值以外还有覆盖面问题，而且更致命的是每一天的人数需求还不一样

那么题目限制如此多元化的题目，我们就一定要想到用那个传说中的万能算法——网络流

想到网络流以后，一个直观的想法就是源点连人，人连可以被雇佣的日子，日子连汇点，然后跑最小费用最大流

但是这样有一个问题：本题中的雇佣不是可以一天用一天不用的，而是你花了那么多钱，他就一次性帮你从Si做到Ti，不能按天购买

而我们的这个网络流模型显然可以让流量从每个“人点”的一部分出边流出，并不正确

## “一面对多面”

这里的这个问题，我称之为“一面对多面”，也就是一个决策会影响到多个限制条件的改变，但是网络流中的流量是一对一的，也就是一点流量不能在某一个点“分”成很多流量，所以并不能解决这种“一面对多面”的问题

那我们就要考虑更换思路了

我们之前的想法是以“一个被雇佣的人”为“一点流量”，但是仔细思索，发现出现上述问题的本质在于：不同的日子可能会用同一个人，而代表同一个人的流量只有一

那我们就要想办法让这一个流量，去覆盖所有的Si到Ti的日子

这引导我们想到如下模型：

对于每一中志愿者(si,ti,ci)，我们建一条跨过si到ti的所有点的边，费用为ci，来表示“这一个流量一直流完了这些区域”

但是问题在于，只是这样建图的话，并没有把每天的人数限制ai放到图里，也就是这个图缺少信息

## 补全信息

此时我们需要想办法把人数限制放到图里

我们考虑最大流算法：它会求出最大的流量

那我们既然用一点流量表示一个人，那么为什么我们不把这个“需要用人”的限制，放到另外几条边上呢？

我们在点(i,i+1)之间建边，设流量为-a[i]，也就是负的当天需求数，费用自然是零的

然后，令上文中的志愿者(si,ti,ci)，建边(si,ti+1)，费用ci，流量无限

此时我们相当于是把第i天的决策放到了第i个点和第i+1个点之间的所有边上（就是把所有点排成一排，这两个点之间的那一条位置里的所有边，包括跨过这个区间的志愿者边）

需要志愿者？让它们从志愿者边上流过去，同时让人数限制边满流到-a[i]，这样求一个1-n+1的最大流，流量为0的最小费用就是雇佣人的最小费用了

为了让这个限制起效，又因为网络流中流量非负，所以我们建立点SS和TT，连边(SS,1)(n+1,TT)，限制为inf，费用为0

同时，我们把之前的人数限制边的流量改成(inf-a[i])，这样最终的SS-TT最大流一定是inf，而且限制依然成立

## 完成

# 总结

到这里，我们就完成了本题的建模，可以看到这个过程是复杂而十分深刻的，我们从最开始的暴力、dp，转化到网络流，又从“一面对多面”的问题中跳了出来，转化到了最后的方法，又增加了inf的流量来使整个图合法

可以看到，这道题里主要解决的就是两个矛盾：dp时间复杂度不够，以及“一面对多面”不可行

第一个矛盾是时间上的，我们发现无法进行优化以后，转换了算法

第二个矛盾在于建模之上，我们采取了研究算法本质、重新构建模型的方法，舍弃了常见的建图模型而建立了这道题的独有模型

由此可见，做题的时候思路一定要放开，要大胆；如果发现常用的“套路”不合适，就要果断放弃、选择新方法

同时，研究算法、建立模型要从算法本质出发；一定要先想好算法中的什么东西代表题目中的哪个东西，再放到算法框架中，针对性构建模型；不能生搬硬套旧套路

# Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define inf 1e9
using namespace std;
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
int n,m,cnt=-1,ans,first[10010],dis[10010],vis[10010];
struct edge{
    int to,next,w,cap;
}a[200010];
inline void add(int u,int v,int w,int cap){
    a[++cnt]=(edge){v,first[u],w,cap};first[u]=cnt;
    a[++cnt]=(edge){u,first[v],-w,0};first[v]=cnt;
}
int q[100010];
bool spfa(int s,int t){
    int head=0,tail=1,i,u,v,w;
    memset(dis,-1,sizeof(dis));memset(vis,0,sizeof(vis));
    q[0]=t;vis[t]=1;dis[t]=0;
    while(head<tail){
        u=q[head++];vis[u]=0;
        for(i=first[u];~i;i=a[i].next){
            v=a[i].to;w=a[i].w;
            if(a[i^1].cap&&((dis[v]==-1)||(dis[v]>dis[u]-w))){
                dis[v]=dis[u]-w;
                if(!vis[v]) q[tail++]=v,vis[v]=1;
            }
        }
    }
    return ~dis[s];
}
int dfs(int u,int t,int limit){
    if(u==t||!limit){vis[u]=1;return limit;}
    int i,v,f,flow=0,w;vis[u]=1;
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;w=a[i].w;
        if(!vis[v]&&(dis[v]==dis[u]-w)&&(a[i].cap)){
            if(!(f=dfs(v,t,min(limit,a[i].cap)))) continue;
            a[i].cap-=f;a[i^1].cap+=f;ans+=f*w;
            flow+=f;limit-=f;
            if(!limit) return flow;
        }
    }
    return flow;
}
int zkw(int s,int t){//zkw费用流
    int re=0;
    while(spfa(s,t)){
        vis[t]=1;
        while(vis[t]){
            memset(vis,0,sizeof(vis));
            re+=dfs(s,t,inf);
        }
    }
    return re;
}
int main(){
    int i,t1,t2,t3;memset(first,-1,sizeof(first));
    n=read();m=read();
    for(i=1;i<=n;i++) t1=read(),add(i,i+1,0,inf-t1);//构建“人数限制边”
    add(0,1,0,inf);add(n+1,n+2,0,inf);
    for(i=1;i<=m;i++){//构建“志愿者边”
        t1=read();t2=read();t3=read();
        add(t1,t2+1,t3,inf);
    }
    zkw(0,n+2);//最大流值一定是inf，费用就是答案
    cout<<ans<<endl;
}
```

---

## 作者：虞皓翔 (赞：82)

设第 $i$ 天需要 $x_i$ 个志愿者，记 $m_{ij}$ 表示第 $i$ 天第 $j$ 个志愿者是否能工作，则它们需要满足如下条件：

 ![](https://cdn.luogu.com.cn/upload/pic/11963.png) 

于是所需费用即 $C_1 x_1 + C_2 x_2 + \cdots + C_m x_m$，需要令它最小化。

可以看出，这是一个**线性规划**问题。

由于它是**最小化**型线性规划，不是标准形式的。因此，可以利用**线性规划对偶定理** (证明可以百度等，比如[这里](https://wenku.baidu.com/view/14e748bb49649b6648d747cb.html)) 将其转化为一个**最大化**型线性规划：

 ![](https://cdn.luogu.com.cn/upload/pic/11964.png) 

由于 $C_i$ 都是 $\geq 0$ 的整数，于是上面的线性规划就有基本解 (零解)。于是写个最单纯的单纯形法就可以了 (连 `init()` 都不用写~)。

具体地过程，就是寻找大于 $0$ 的非基 (自由) 变量转化成基变量，然后转轴 (注意代码实现时和 Gauss 消元的区别)，最后得到的就是最小花费。

(其实现在还有一个问题，就是线性规划的最优解会不会出现分数的问题，这个放到最后讲)。

代码：

```cpp
#include <bits/stdc++.h>
#define N 1034
#define E 10034
using namespace std;

const double eps = 1e-8;

int n, e, l, r;
int i, j;

int id[N + E];
double m[E][N], b[E], *c = m[0], ans[N + E];

void pivot(int r, int c){
    int i, j; double coe = 1.0 / m[r][c];
    swap(id[n + r], id[c]);
    m[r][c] = 1.0;
    for(j = 1; j <= n; ++j)
        m[r][j] *= coe;
    b[r] *= coe;
    for(i = 0; i <= e; ++i){
        if(i == r) continue;
        coe = m[i][c]; m[i][c] = 0.0;
        for(j = 1; j <= n; ++j)
            m[i][j] -= coe * m[r][j];
        b[i] -= coe * b[r];
    }
}

bool simplex(){
    int i, j, basic, free; double G;
    for(; ; ){
        basic = free = 0; G = INFINITY;
        for(i = 1; i <= n; ++i) // free (nonbasic) variable
            if(c[i] > c[free]) free = i;
        if(!free) return true;
        for(j = 1; j <= e; ++j) // basic variable
            if(m[j][free] > eps && b[j] < G * m[j][free]){
                G = b[j] / m[j][free]; basic = j;
            }
        if(!basic) return puts("Unbounded"), false;
        pivot(basic, free);
    }
}

int main(){
    scanf("%d%d", &n, &e);
    for(j = 1; j <= n; ++j) scanf("%lf", c + j);
    for(i = 1; i <= e; ++i){
        scanf("%d%d%lf", &l, &r, b + i);
        for(j = l; j <= r; ++j)
            m[i][j] = 1.0;
    }
    if(simplex())
        printf("%.lf\n", -*b);
    return 0;
}
```
~~(听说这题还可以用最小费用最大流做？等待楼上来填坑)~~

接下来一个小细节就是证明上述线性规划必有整数解。

我们知道，线性规划的问题的最优解为整数的一个**必要**条件是它的任意一个子方阵的行列式为 $-1, 0, 1$。

而这是一个 0/1 方阵，且每一行中的 $1$ 是连续的。我们接下来证明，这个方阵的行列式一定为 $-1, 0, 1$ 中之一。

我们先用第 $n-1$ 列乘上 $-1$ 加到第 $n$ 列，第 $n-2$ 列乘上 $-1$ 加到第 $n-1$ 列，……，第 $1$ 列乘上 $-1$ 加到第 $2$ 列，就得到了一个新方阵：

其中每一行有左边一个 $1$，右边 $1$ 个 $-1$ (也可能没有)，比如：

```plain
 1  0  0 -1  0  0  0
 1  0  0  0  0 -1  0
 0  1  0  0 -1  0  0
 0  1  0  0  0  0 -1
 0  0  1  0  0 -1  0
 0  0  0  1  0  0  0
 0  0  0  0  1 -1  0
```
我们将这些行按照 $1$ 的位置从左到右排序，相同的以 $-1$ 为第二关键字排序，如上面的矩阵 (已经排好序的)，可知它的行列式要么不变，要么变为它的相反数。

接下来，对于 $1$ 的位置相同的几行，把最上面一行乘以 $-1$，加到下面几行 (就像 Gauss 消元一样)，最后再排序，重复此过程，会得到 (类似) 如下的矩阵：

```plain
 1  0  0 -1  0  0  0
 0  1  0  0 -1  0  0
 0  0  1  0  0 -1  0
 0  0  0  1  0 -1  0
 0  0  0  0  1 -1  0
 0  0  0  0  0  1 -1
 0  0  0  0  0  0  1
```
最终情况下，它要么是一个**上三角矩阵**，则原行列式显然为 $\pm 1$，当然，像 Gauss 消元一样，可能出现中间某个时刻一行为 $0$，那么原行列式就为 $0$，证毕。


---

## 作者：Dispwnl (赞：71)

//排版有点问题重交一遍

鬼畜的建图方式。。。

本来我是想源点连志愿者、志愿者连控制的天（区间）、天连汇点

再跑最小费用最大流就行啦

然后连样例都没过

抱着~~人有多大胆地有多大产的~~侥幸心理

一交
果然爆0。。。

来解释一下建图方式~~毕竟我觉得楼下说的没看懂~~

源点连第一天

汇点连最后一天

容量为INF费用为0

这样跑网络流是沿时间流的（就是依次解决每一天的问题）

然后每一天向后一天连一条容量为INF-a[i]

费用为0的边

为什么容量为INF-a[i]

这就相当于少了a[i]

得用带权边补全INF

这就是志愿者连续干时沿这条边跑

因为连续干不花钱

所以优先选这种边

然后将每一类志愿者s[i]与t[i]+1连一条容量为

INF花费为c[i]的边

当连续干的人不够时

就得~~充钱~~使劲往里塞人

补全INF

如图
 ![](https://cdn.luogu.com.cn/upload/pic/12955.png) 

~~似乎~~就是这样

```cpp
# include<iostream>
# include<cstdio>
# include<cstring>
# include<queue>
using namespace std;
const int MAX=2e6+1,INF=1e7,t=2e6;
struct p{
    int x,y,dis,cn;
}c[MAX<<2];
int n,m,num,tot1;
int d[MAX],h[MAX],pre[MAX];
bool use[MAX];
void add(int x,int y,int dis,int cn)
{
    c[num].x=h[y],c[num].y=x,c[num].dis=0,c[num].cn=-cn,h[y]=num++;
    c[num].x=h[x],c[num].y=y,c[num].dis=dis,c[num].cn=cn,h[x]=num++;
}
void EK()
{
    while(1)
    {
        queue<int> qu;
        qu.push(0);
        memset(pre,0,sizeof(pre));
        memset(d,1,sizeof(d));
        d[0]=0;
        while(!qu.empty())
        {
            int tt=qu.front();
            qu.pop();
            use[tt]=0;
            for(int i=h[tt];i;i=c[i].x)
              if(c[i].dis&&d[c[i].y]>d[tt]+c[i].cn)
              {
                  d[c[i].y]=d[tt]+c[i].cn;
                  pre[c[i].y]=i;
                  if(!use[c[i].y])
                  {
                      use[c[i].y]=1;
                      qu.push(c[i].y);
                }
              }
        }
        if(d[t]>INF) return;
        int sum=INF,hh=t;
        while(pre[hh])
        {
            int l=pre[hh];
            sum=min(sum,c[l].dis);
            hh=c[l^1].y;
        }
        hh=t;
        while(pre[hh])
        {
            int l=pre[hh];
            c[l].dis-=sum;
            c[l^1].dis+=sum;
            tot1+=sum*c[l].cn;
            hh=c[l^1].y;
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
      {
          int x;
          scanf("%d",&x);
          add(i,i+1,INF-x,0);
      }
    add(0,1,INF,0);
    add(n+1,t,INF,0);
    for(int i=1;i<=m;i++)
      {
          int x,y,dis;
          scanf("%d%d%d",&x,&y,&dis);
          add(x,y+1,INF,dis);
      }
    EK();
    printf("%d",tot1);
    return 0;
}
```
打完题解后心力憔悴的我-> ![](https://cdn.luogu.com.cn/upload/pic/12343.png)

---

## 作者：Great_Influence (赞：53)

既然楼下提到填坑，那就填了吧。。。。。。

##费用流

连边方法(以下描述中，用二元组$(f,w)$表示容量为$f$费用为$w$的边):


对于每一天向后一天连边$(inf-a_i,0)$


对于每一种志愿者选择，$s_i$向$t_i+1$连边$(inf,c_i)$


从超级源向第一天连边$(inf,0)$


从最后一天+1向超级汇连边$(inf,0)$


然后从超级源向超级汇跑费用流。


为什么这样跑会正确呢？可以发现，第一次网络流后所有天数边的容量会被填至$max-a_i$($max$为需求最大天的需求量)，不会走带权边。然后因为有带权边存在，所以网络还可以扩容。因为保证一定存在可行解，所以容量一定可以扩成$inf$。那么每条天数边都可以视为填满(因为天数边权值为0,一定优于带权边，会优先被填满，出现前面填带权边覆盖本条边情况除外)。然后对于每天，不通过天数边经过的流量总和一定至少为$a_i$。换句话说，缺少的流量会从带权边流过，自动补齐inf。并且费用流算法会自动求出费用最小解，因此可以保证方案一定最优。


代码(Dinic)：

    
```cpp
    #include<bits/stdc++.h>
    #define For(i,a,b) for(i=(a);i<=(b);++i)
    #define Forward(i,a,b) for(i=(a);i>=(b);--i)
    #define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
    #define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
    using namespace std;
    template<typename T>inline void read(T &x)
    {
        T s=0,f=1;char k=getchar();
        while(!isdigit(k)&&(k^'-'))k=getchar();
        if(!isdigit(k)){f=-1;k=getchar();}
        while(isdigit(k)){s=s*10+(k^48);k=getchar();}
        x=s*f;
    }
    void file()
    {
        #ifndef ONLINE_JUDGE
            freopen("volunteer.in","r",stdin);
            freopen("volunteer.out","w",stdout);
        #endif
    }
    const int MAXN=2000;
    const int inf=2147483647;
    static struct edge
    {
        int v,next,w,f;
    }p[MAXN*100];
    static int fee,dis[MAXN],e=1,head[MAXN],gap[MAXN],n,m;
    static bool vis[MAXN];
    inline void add(int u,int v,int f,int w)
    {
        p[++e].v=v;p[e].w=w;p[e].f=f;
        p[e].next=head[u];head[u]=e;
    }
    static deque<int>G;
    inline bool spfa(int s,int t)
    {
        memset(dis,0x3f,sizeof dis);
        static int u,v;vis[s]=true;dis[s]=0;
        for(G.push_back(s);!G.empty();)
        {
            u=G.front();G.pop_front();
            for(v=head[u];v;v=p[v].next)if(p[v].f&&dis[p[v].v]>dis[u]+p[v].w)
            {
                dis[p[v].v]=dis[u]+p[v].w;
                if(!vis[p[v].v])
                {
                    vis[p[v].v]=true;
                    if(G.empty()||dis[p[v].v]>dis[G.front()])G.push_front(p[v].v);
                    else G.push_back(p[v].v);
                }
            }
            vis[u]=0;
        }
        return dis[t]^dis[0];
    }
    int dfs(int u,int t,int flow)
    {
        if(u==t||!flow)return flow;
        vis[u]=true;
        int sum=0;
        for(register int &v=gap[u];flow&&v;v=p[v].next)
            if(!vis[p[v].v]&&dis[p[v].v]==dis[u]+p[v].w&&p[v].f)
            {
                int f=dfs(p[v].v,t,min(flow,p[v].f));
                p[v].f-=f;p[v^1].f+=f;sum+=f;flow-=f;fee+=f*p[v].w;
            }
        vis[u]=false;
        return sum;
    }
    inline void Dinic(int s,int t){for(;spfa(s,t);memcpy(gap,head,sizeof gap),dfs(s,t,inf));}
    void init()
    {
        read(n);read(m);static int x;
        Rep(i,1,n)read(x),add(i,i+1,inf-x,0),add(i+1,i,0,0);
        add(n+2,1,inf,0);
        add(1,n+2,0,0);
        static int u,v,w;
        Rep(i,1,m)read(u),read(v),read(w),add(u,v+1,inf,w),add(v+1,u,0,-w);
    }
    void solve()
    {
        Dinic(n+2,n+1);
        printf("%d\n",fee);
    }
    int main()
    {
        file();
        init();
        solve();
        return 0;
    }

```

---

## 作者：uniqueharry (赞：30)

### 题解

首先给出一条链，表示时间轴。每天向下一天连边，表示可以把当天的志愿者传递给下一天。然后对于一种志愿者，考虑建立一个虚拟的“志愿者基地”，令为 $x$，它的作用区间是 $[l_x,r_x]$。那么 $x$ 向 $l_x$ 连边，表示从第 $l_x$ 天这种志愿者开始工作，从 $r_x$ 向 $x$ 连边，表示这种类型的志愿者完成工作回到志愿者基地。但是很容易会想到一个问题，这种志愿者似乎可能继续往下一天走。没关系，根据 $x$ 的流量平衡原理，$x \rightarrow l_x$ 和 $r_x \rightarrow x$ 的流量相同，那么这种志愿者去了几个就会回来几个。至于到底是不是那几个人，根本无所谓。因为计算费用只和人数相关。

进一步地，我们发现 $x$ 这个虚拟的“志愿者基地”实则没有任何意义，可以退出历史的舞台，直接 $r_x \rightarrow l_x$ 即可。

具体的连边：将每天拆成两个点 $\text{id}_{i,0},\text{id}_{i,1}$，

1. $\text{id}_{i,0} \rightarrow \text{id}_{i,1}$，容量下界为当天需要的志愿者人数，上界为 $+\infty$，费用为 $0$。

2. $\forall i < n,\text{id}_{i,1} \rightarrow \text{id}_{i + 1, 0}$，容量下界为 $0$，上界为 $+\infty$，费用为 $0$。

3. $\text{id}_{t_j, 1} \rightarrow \text{id}_{s_j, 0}$，容量下界为 $0$，上界为 $+\infty$，费用为 $c_j$。

在建出的图上跑最小费用可行流即可。

[code](https://www.luogu.com.cn/paste/uetbkunn)

---

## 作者：斯茂 (赞：28)

# 这里讲一下这道题做法的一种理解方式

首先建图大家应该都知道了，每个点向下一个点连(i, i + 1, Inf - a[i], 0)的边，每种人连(s[i], t[i] + 1, Inf, c[i])的边

至于为什么呢，可以这么理解

首先最大流的值明显是Inf

所以我们假设一开始有Inf位志愿者，即第0天不工作的志愿者有Inf

每一天会有一些志愿者去工作，所以那一天不工作的志愿者不能超过Inf - a[i]位

从s[i]连向t[i]+1表示这个志愿者在第s[i]到t[i]天一直在工作

然后到最后还要回来Inf位志愿者，即比赛结束后不工作的志愿者还是Inf个

这个当然不是很严谨，但可以感性理解一下

下面给出建图的代码
```
int n, m, l, r, t, i;
	scanf("%lld%lld", &n, &m);
	S = 0, T = n + 2;
	add(S, 1, inf, 0); add(n + 1, T, inf, 0);
	for(i = 1; i <= n; i++)
	{
		scanf("%lld", &t);
		add(i, i + 1, inf - t, 0);
	}
	for(i = 1; i <= m; i++)
	{
		scanf("%lld%lld%lld", &l, &r, &t);
		add(l, r + 1, 3e18, t);
	}
```

---

## 作者：wine (赞：20)

[代码太占篇幅，放这了](https://blog.csdn.net/qq_33831360/article/details/94151862)

## 分析与建模
设第 $i$ 天需要 $x_i$ 个志愿者，记 $a_{ij}$ 为第 $i$ 天第 $j$ 个志愿者是否能工作。
题目要求总费用最低，即求：$Min \, z = \sum_{i=1}^{n}{C_i * x_i}$。
它们需要满足要求：

$$\begin{cases}  a_{11}x_1+a_{12}x_2+a_{13}x_3...+a_{1m}x_m \geq A_1 \\a_{21}x_1+a_{22}x_2+a_{23}x_3...+a_{2m}x_m \geq A_2 \\ ...\\a_{n1}x_1+a_{n2}x_2+a_{n3}x_3...+a_{nm}x_m \geq A_n \\ x_1,x_2,x_3  ... x_m \geq 0 \end{cases}$$

这明显是一个的线性规划问题,但它不是标准形式,需要一些改造。
### 方法一 转化为对偶问题
观察它的对偶问题：$Max \, w = \sum_{i=1}^{m}A_i*y_i$。
设$b_{ij} = a_{ji}$, 为第 $i$ 个志愿者第 $j$ 天是否能工作,新的约束条件为：

$$\begin{cases}b_{11}y_1+b_{12}y_2+b_{13}y_3...+b_{1n}y_n \leq C_1 ;\\b_{21}y_1+b_{22}y_2+b_{23}y_3...+b_{2n}y_n \leq C_2 ;\\ ...;\\b_{m1}y_1+b_{m2}y_2+b_{m3}y_3...+b_{mn}y_n \leq C_n ;\\ y_1,y_2,y_3  ... y_n \geq 0;\end{cases}$$

添加松弛变量后为：

$$\begin{cases}b_{11}y_1+b_{12}y_2+b_{13}y_3...+b_{1n}y_n+y_{n+1} = C_1 \\b_{21}y_1+b_{22}y_2+b_{23}y_3...+b_{2n}y_n+y_{n+2} = C_2 \\ ...\\b_{m1}y_1+b_{m2}y_2+b_{m3}y_3...+b_{mn}y_n+y_{n+m} = C_n \\ y_1,y_2,y_3  ... y_{n+m} \geq 0\end{cases}$$

这是线性规划的标准形式，对偶问题可以使用原始单纯型法求解。
根据对偶定理，若原问题有最优解，那么对偶问题也有最优解，且目标函数值相等。题目要的只有目标函数值，所以可以直接求解对偶问题，但这种方法得到的解不是原问题的解，所以这种方法实际上不太合适，不过它只要最基本的单纯形法，故放第一位。

### 方法二 人工变量法
在加入剩余变量后，分别给每个约束方程加入人工变量$x_{m+n+1},...,x_{m+n+n}$,得到初始基可行解。

$$\begin{cases}a_{11}x_1+a_{12}x_2+a_{13}x_3...+a_{1m}x_m - x_{m+1} + x_{m+n+1} = A_1 \\ a_{21}x_1+a_{22}x_2+a_{23}x_3...+a_{2m}x_m - x_{m+2} + x_{m+n+2} = A_2 \\ ...\\a_{n1}x_1+a_{n2}x_2+a_{n3}x_3...+a_{nm}x_m - x_{m+n} + x_{m+n+n} = A_n \\ x_1,x_2,x_3  ... x_m+n+n \geq 0\end{cases}$$

#### 1. 大M法
人工变量不能影响目标函数取值，必须从基变量中换出来。为此，可以在目标函数中把人工变量的系数设成M(一个充分大的数/惩罚系数)，使得在求Min的过程中，人工变量变为非基变量可以大大减小目标函数值
$Min \, z = \sum_{i=1}^{n}{C_i * x_i}+\sum_{j=m+n+1}^{m+n+n}M*x_j$


#### 2. 两阶段法
两阶段法则更为直接，第一步，目标函数为$Min \, w = \sum_{i=m+1}^{m+n}{x_i}$，即尽量使人工变量取值为0，如果$w>0$，说明人工变量换不出去，即无解。若$w = 0$，说明有可行解，进行第二阶段，把矩阵中人工变量部分删掉，目标函数换回原问题的，即$Min \, z = \sum_{i=1}^{n}{C_i * x_i}$

### 方法三 对偶单纯形法

将所有式子同乘$-1$后得到类似标准形式，但是b列出现负数，不能用原始单纯形法。
整理一下式子：$Max \,z_{'} = \sum_{i=1}^{n}{-C_i * x_i}$

$$\begin{cases}-a_{11}x_1-a_{12}x_2-a_{13}x_3...-a_{1m}x_m + x_{m+1} = -A_1 \\ -a_{21}x_1-a_{22}x_2-a_{23}x_3...-a_{2m}x_m + x_{m+2} = -A_2 \\ ...\\-a_{n1}x_1-a_{n2}x_2-a_{n3}x_3...-a_{nm}x_m + x_{m+n} = -A_n \\ x_1,x_2,x_3  ... x_m \geq 0\end{cases}$$

这里只介绍一下步骤，正确性证明请百度。
 1) 对线性规划问题是所有检验数<=0,即对偶问题为基可行解。(本题初始既满足)。
 2) 检验：若b列都非负，检验数都非正，已达到最优解，停止计算。
 3) 按$min[(B^{-1}b)_i,|(B^{-1}b<0)_i]=(B^{-1}b)_l$对应的基变量$x_l$为换出变量
 4) 检查$x_l$行各系数$a_{lj}$，若所有$a_{lj}>=0$，说明无解。否则，计算$\theta = min_j(\frac{c_j-z_j}{a_{lj}} |a_{lj}<0) = \frac{c_k-z_k}{a_{lk}}$，以对应的$x_k$ 为换入变量($\theta$规则保证对偶问题的解仍为可行解)。
 5) 以$a_{lk}$为主元素，进行迭代，得到新表。
重复(2)～(5)。


---

## 作者：Adove (赞：17)

这题楼下的构图方式其实是对下图的一种变形↓

![](https://cdn.luogu.com.cn/upload/pic/15983.png)

此图中将每一天拆为两个点，每天的上午向下午连一条权为INF-a[i]的边，每天下午向第二天上午连一条权为INF的边，对于志愿者，从开始工作的上午向结束工作的下午连一条权INF费用为c[i]的边，跑最小费用最大流。

变形的核心思想是缩点，将INF边连接的两个点缩为一个，如下图↓

![](https://cdn.luogu.com.cn/upload/pic/15982.png)

两个图实际上是等效的。

下面给出方案一（原二分图）代码↓

```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int INF=2e9;

int n,m,x,y,z,np=1,s,t,mct;
int h[2005],ln[2005],q[55505];
bool vis[2005];
struct rpg{
	int li,nx,ln,ct;
}a[55505];

void add(int ls,int nx,int ln,int ct){
	a[++np]=(rpg){h[ls],nx,ln,ct};
	h[ls]=np;
	a[++np]=(rpg){h[nx],ls,0,-ct};
	h[nx]=np;
}

bool spfa(){
	memset(vis,0,sizeof(vis));
	for(int i=0;i<=t;++i) ln[i]=INF;
	int hd=1,tl=1;
	q[hd]=t;
	ln[t]=0;
	vis[t]=1;
	while(hd<=tl){
		int nw=q[hd++];
		vis[nw]=0;
		for(int i=h[nw];i;i=a[i].li){
			if(a[i^1].ln&&ln[a[i].nx]>ln[nw]-a[i].ct){
				ln[a[i].nx]=ln[nw]-a[i].ct;
				if(!vis[a[i].nx]){
					vis[a[i].nx]=1;
					q[++tl]=a[i].nx;
				}
			}
		}
	}return ln[s]<INF;
}

int dfs(int u,int maxn){
	if(u==t||!maxn) return maxn;
	vis[u]=1;
	int sum=0;
	for(int i=h[u];i;i=a[i].li){
		if(a[i].ln&&!vis[a[i].nx]&&ln[a[i].nx]==ln[u]-a[i].ct){
			int f=dfs(a[i].nx,min(maxn,a[i].ln));
			if(f){
				maxn-=f;
				sum+=f;
				a[i].ln-=f;
				a[i^1].ln+=f;
				if(!maxn) break;
			}
		}
	}return sum;
}

void dnc(){
	while(spfa()){
		vis[t]=1;
		while(vis[t]){
			memset(vis,0,sizeof(vis));
			int d=dfs(s,INF);
			mct+=d*ln[s];
		}
	}
}

int main(){
	scanf("%d%d",&n,&m);t=(n<<1)+1;
	for(int i=1;i<=n;++i){
		scanf("%d",&x);
		add(i,i+n,INF-x,0);
		if(i<n) add(i+n,i+1,INF,0);
	}for(int i=1;i<=m;++i){
		scanf("%d%d%d",&x,&y,&z);
		add(x,y+n,INF,z);
	}add(s,1,INF,0);
	add(n<<1,t,INF,0);
	dnc();
	printf("%d\n",mct);
	return 0;
}
```

然后是方案二（缩点后）代码↓

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int INF=2e9;

int n,m,x,y,z,np=1,s,t,mct;
int h[1005],ln[1005],q[25505];
bool vis[1005];
struct rpg{
	int li,nx,ln,ct;
}a[25505];

void add(int ls,int nx,int ln,int ct){
	a[++np]=(rpg){h[ls],nx,ln,ct};
	h[ls]=np;
	a[++np]=(rpg){h[nx],ls,0,-ct};
	h[nx]=np;
}

bool spfa(){
	memset(vis,0,sizeof(vis));
	for(int i=0;i<=t;++i) ln[i]=INF;
	int hd=1,tl=1;
	q[hd]=t;
	ln[t]=0;
	vis[t]=1;
	while(hd<=tl){
		int nw=q[hd++];
		vis[nw]=0;
		for(int i=h[nw];i;i=a[i].li){
			if(a[i^1].ln&&ln[a[i].nx]>ln[nw]-a[i].ct){
				ln[a[i].nx]=ln[nw]-a[i].ct;
				if(!vis[a[i].nx]){
					vis[a[i].nx]=1;
					q[++tl]=a[i].nx;
				}
			}
		}
	}return ln[s]<INF;
}

int dfs(int u,int maxn){
	if(u==t||!maxn) return maxn;
	vis[u]=1;
	int sum=0;
	for(int i=h[u];i;i=a[i].li){
		if(a[i].ln&&!vis[a[i].nx]&&ln[a[i].nx]==ln[u]-a[i].ct){
			int f=dfs(a[i].nx,min(maxn,a[i].ln));
			if(f){
				maxn-=f;
				sum+=f;
				a[i].ln-=f;
				a[i^1].ln+=f;
				if(!maxn) break;
			}
		}
	}return sum;
}

void dnc(){
	while(spfa()){
		vis[t]=1;
		while(vis[t]){
			memset(vis,0,sizeof(vis));
			int d=dfs(s,INF);
			mct+=d*ln[s];
		}
	}
}

int main(){
	scanf("%d%d",&n,&m);t=n+2;
	for(int i=1;i<=n;++i){
		scanf("%d",&x);
		add(i,i+1,INF-x,0);
	}for(int i=1;i<=m;++i){
		scanf("%d%d%d",&x,&y,&z);
		add(x,y+1,INF,z);
	}add(s,1,INF,0);
	add(n+1,t,INF,0);
	dnc();
	printf("%d\n",mct);
	return 0;
}
```

与缩点前相比，缩点后的程序无论是时间复杂度还是空间复杂度都得到了一定的优化，建议初学者使用第一种方式构图，有一定基础的同学可以尝试第二种。

[安利一发blog](https://www.luogu.org/blog/31293/)

---

## 作者：mgzc (赞：10)

# [题面](https://www.luogu.org/problemnew/show/P3980)
[惊喜](https://www.cnblogs.com/ztlztl/p/10574372.html)

​	又一次考试网络流爆零......

​	这一题一看就是网络流, 但是要怎么构图呢? 考虑到途中的一些因素, 首先, 每一种志愿者控制的区间范围为$S_{i}$到$T_{i}$, 所以, 我们要使得每种志愿者只能控制这段区间, 其他的不能够控制, 其次, 每个时间都有一个最小的值, 也就是这条边(我们将时间段看为一条边更加方便)有一个下界, 想到了什么, 上下界网络流, 每条边都要符合上界和下界的约束, 没有学过的可以[戳一下](https://www.cnblogs.com/ztlztl/p/10565775.html).

​	那么初始的构图也就出来了, 每个时间作为一条边, 那么由$i$向$i + 1$连一条边, 容量为$INF - lower(i)$, 费用为0(由于人是控制一段区间的, 他在这段区间中的任意两个点流费用都为0, 可以看做这个人继续做事, ~~已经付钱了, 你得给我做完事才能走~~)($lower(i)$代表时间$i$最少需要多少人, 其实这条边容量为$INF$没有问题, 假装上界为$INF + lower(i)$就可以了, 反正可以不停地流), 考虑到之前所说, 每个点只能约束自己的一段区间, 有点像循环流, 从$S_{i}$出发, 流到$T_{i}$就重新流, 但是这里由于$T_{i}$被看成了一条边, 所以我们需要在点$T_{i} + 1$往$S_{i}$连一条容量为$INF$, 费用为$c$的边, 代表当前类$i$的志愿者控制且只能控制$S_{i}$到$T_{i}$这段时间.

​	最终构图是这样的: 每个点$i$向$i + 1$连边, 每个$T_{i} + 1$向$S_{i}$连边, 注意在每个点$i$向$i + 1$连边时, 由于你是默认这条边流了一个下界的, 你每个点的流量不一定平衡, 记录一下每个点流入和流出的差, 对于一条下界为$x$的边i -> i + 1, 记$delta[i]$为点$i$流入与流出的差, 则$delta[i] -= x$, $delta[i + 1] += x$, 连完所有边后, 注意到每个点的$delta$不一定为0, 对于$delta$大于或者小于0的情况, 戳上面那个吧, 有详细的介绍, 最后跑一遍无源汇上下界最小费用可行流就可以了, 也就是在构出的有源汇的图中跑一遍最小费用最大流即可.

**具体代码**

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>
#define N 2005
#define INF 1e9
using namespace std;

int n, m, S, T, delta[N], head[N], cnt = 1, p[N], vis[N]; 
struct node
{
	int from, to, next;
	long long flow, cost; 
} edge[100005];
long long a[N], d[N]; 

inline int read()
{
	int x = 0, w = 1;
	char c = getchar();
	while(c < '0' || c > '9') { if (c == '-') w = -1; c = getchar(); }
	while(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }
	return x * w;
}

inline void add(int u, int v, long long w, long long cost)
{
	edge[++cnt] = { u, v, head[u], w, cost }; head[u] = cnt;
	edge[++cnt] = { v, u, head[v], 0, -cost }; head[v] = cnt; 
}

bool SPFA(long long &cost)
{
	memset(d, 0x3f, sizeof(d)); memset(a, 0x3f, sizeof(a)); 
	queue<int> q; q.push(S); d[S] = 0; vis[S] = 1; 
	while(!q.empty())
	{
		int u = q.front(); q.pop(); vis[u] = 0;
		for(int i = head[u]; i; i = edge[i].next)
		{
			int v = edge[i].to;
			if(d[v] > d[u] + edge[i].cost && edge[i].flow > 0)
			{
				d[v] = d[u] + edge[i].cost; a[v] = min(a[u], edge[i].flow);
				p[v] = i; if(!vis[v]) { vis[v] = 1; q.push(v); }
			}
		}
	} 
	if(d[T] == d[0]) return 0;
	cost += (a[T] * d[T]); 
	for(int i = T; i != S; i = edge[p[i]].from)
	{
		edge[p[i]].flow -= a[T]; edge[p[i] ^ 1].flow += a[T]; 
	}
	return 1; 
}

int main()
{
	n = read(); m = read();
	S = n + 2; T = S + 1; 
	for(int i = 1; i <= n; i++) { int x = read(); add(i, i + 1, INF, 0); delta[i] -= x; delta[i + 1] += x; }
	for(int i = 1; i <= m; i++)
	{
		int u = read(), v = read(), c = read();
		add(v + 1, u, INF, c); 
	}
	for(int i = 1; i <= n + 1; i++)
	{
		if(delta[i] < 0) add(i, T, -delta[i], 0);
		if(delta[i] > 0) add(S, i, delta[i], 0); 
	} 
	long long cost = 0;
	while(SPFA(cost));
	printf("%lld\n", cost); 
	return 0;
}

```



---

## 作者：玫葵之蝶 (赞：9)

我来说一下这个题的线性规划转费用流的做法吧

（首先膜那个线性规划的dalao）

（再来宣传一波blog：[我的blog](http://blog.csdn.net/stone41123/article/details/79185673)）

我们设第i类的志愿者的数量为Xi，工作区间为[Si,Ti]

设第i天的志愿者需求量为Ai，那么合法条件下就有以下几个不等式：

（以下均为样例）

```plain
P1 : X1>=A1
P2 : X1+X2>=A2
P3 : X2+X3>=A3
```
（其中Pi代表第i个不等式）

然后这个不等式非常不爽，我们可以添加n个辅助变量Yi，使它变为等式：

```plain
P1 : X1+Y1=A1
P2 : X1+X2+Y2=A2
P3 : X2+X3+Y3=A3
```
此时我们可以将等式看作每个点的流量平衡

但是因为有多个X1，无法用网络流处理这样的问题

所以我们可以对等式进行差分，这样就可以变成几个比较优美的式子：

```plain
Q1 : X1+Y1=A1
Q2 : X2+Y2=A2-A1
Q3 : -X1+X3+Y3=A3-A2
Q4 : -X2-X3+Y4=-A3
```
然后右边的那个就看作每个点的盈余量，和源点或汇点连边

左边的一堆Xi就看做Si和Ti+1之间的流量流动，然后连边跑费用流就好了

代码：

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
#define ll long long
#define max(a,b) a>b?a:b
#define min(a,b) a<b?a:b
using namespace std;
inline int read(){
    int x=0,f=1;char ch=' ';
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
    return x*f;
}
const int N=1010,M=N*30;
int n,m,s,t,tot=-1,k;
int head[N],d[N],q[M],cur[N],mark[N],inq[N],Next[M],to[M],flow[M],cost[M];
inline void addedge(int x,int y,int l,int c){
    to[++tot]=y;Next[tot]=head[x];head[x]=tot;flow[tot]=l;cost[tot]=c;
    to[++tot]=x;Next[tot]=head[y];head[y]=tot;flow[tot]=0;cost[tot]=-c;
}
inline bool spfa(){
    for(int i=s;i<=t;i++)d[i]=0x3f3f3f3f,inq[i]=0;
    int l=M/2,r=M/2;d[s]=0;q[l]=s;inq[s]=1;
    while(l<=r){
        int x=q[l++];
        for(int i=head[x];i!=-1;i=Next[i]){
            int u=to[i];
            if(flow[i]&&d[u]>d[x]+cost[i]){
                d[u]=d[x]+cost[i];
                if(!inq[u]){
                    inq[u]=1;
                    if(d[u]<d[q[l]])q[--l]=u;
                    else q[++r]=u;
                }
            }
        }
        inq[x]=0;
    }
    return d[t]!=0x3f3f3f3f;
}
inline int dfs(int x,int a){
    mark[x]=1;
    if(x==t||!a)return a;
    int F=0,f;
    for(int &i=cur[x];i!=-1;i=Next[i]){
        int u=to[i];
        if(!mark[u]&&flow[i]&&d[u]==d[x]+cost[i]&&(f=dfs(u,min(a,flow[i])))>0){
            flow[i]-=f;
            flow[i^1]+=f;
            F+=f;
            a-=f;
            if(!a)return F;
        }
    }
    return F;
}
int F,C;
inline void MCMF(){
    F=0;C=0;
    while(spfa()){
        mark[t]=1;
        while(mark[t]){
            for(int i=s;i<=t;i++)cur[i]=head[i],mark[i]=0;
            int f=dfs(s,0x3f3f3f3f);
            F+=f;
            C+=d[t]*f;
        }
    }
}
const int inf=0x3f3f3f3f;
int a[N],T[N];
int main(){
    memset(head,-1,sizeof(head));
    n=read();m=read();s=0;t=n+2;
    for(int i=1;i<=n;i++)a[i]=read();
    for(int i=1;i<=n+1;i++)T[i]=a[i]-a[i-1];
    for(int i=1;i<=n+1;i++){
        if(T[i]>=0)addedge(i,t,T[i],0);
        else addedge(s,i,-T[i],0);
        if(i<=n)addedge(i,i+1,inf,0);
    }
    for(int i=1;i<=m;i++){
        int si=read(),ti=read(),c=read();
        addedge(ti+1,si,inf,c);
    }
    MCMF();
    printf("%d",C);
    return 0;
}
```

---

## 作者：AubRain (赞：7)

算是有**上下界网络流**的模板了。
```

首先我们要保证每个点的流入流量等于流出流量  

如果存在一个可行流,那么一定满足每条边的流量都大于等于流量的下限.因此我们可以令每条边的流量等于流量下限,得到一个初始流,然后建出这个流的残量网络，每条边的流量等于上限减下限。

但现在可能流量不是守恒的，让t[i]=流入量-流出量

我们建出虚拟的源点和汇点，如果t[i]>0,源点向i连t[i]的边，否则i点向汇点连-t[i]的边

```
以上就是上下界网络流的基本做法了（转自课件ppt）。

本题中，把这 $n$ 天看成一条线，每天向下一天连下界为 $ai$ ，上界为 INF  的边，代表每天需要的人数。然后如果有志愿者要在 $[l,r]$ 天工作，就从 $r$ 向 $l$ 连一条下界为 $0$ ，上界 INF 的边，费用为 $ci$ 。

**为什么是对的？**

志愿者连边之后，每多一条循环流，就要花费 $ci$ 的代价，同时 $[l,r]$ 的流量就可以 $+1$ ，符合题意。

然后跑**无源汇点的最小费用流**就可以了。

```cpp
#include <bits/stdc++.h>
#define N 1005
#define M 1000005
#define INF 1e9
using namespace std;

inline void rd(int &X){
    X=0;int w=0;char ch=0;
    while(!isdigit(ch))w|=ch=='-',ch=getchar();
    while( isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    X=w?-X:X;
}

int n,m,s=N-3,t=N-2,ans;
int head[N],cnt=1,T[N];
int d[N],mn[N],v[N],pre[N];
struct nd{int nxt,to,v,c,l,r,pd;}e[M];
#define For(x) for(int y,i=head[x];(y=e[i].to);i=e[i].nxt)

inline void add(int x,int y,int v,int c=0,int l=0,int r=0){
	if(!v) v=r-l;
	e[++cnt]=(nd){head[x],y,v, c,l,r,-1};head[x]=cnt;
	e[++cnt]=(nd){head[y],x,0,-c,l,r, 1};head[y]=cnt;
}
bool SPFA()
{
    memset(d,0x3f,sizeof d);d[s]=0;
    queue<int> q;q.push(s);mn[s]=1<<29;
    while(!q.empty()){
        int x=q.front();q.pop();v[x]=0;
        For(x) if(e[i].v&&d[y]>d[x]+e[i].c)
        {
            pre[y]=i; d[y]=d[x]+e[i].c;
            mn[y]=min(mn[x],e[i].v);
            if(!v[y]) v[y]=1,q.push(y);
        }
    }
    return d[t]!=0x3f3f3f3f;
}
void up()
{
    ans+=d[t]*mn[t];
    for(int i,x=t;x!=s;x=e[i^1].to)
        i=pre[x],e[i].v-=mn[t],e[i^1].v+=mn[t];
}
void solve()
{
	for(int x=1;x<=n+1;x++)
		For(x) T[x]+=e[i].pd*e[i].l,ans+=e[i].l*e[i].c*(e[i].pd<0);
	for(int i=1;i<=n+1;i++)
		if(T[i]>0) add(s,i,T[i],0);
		else if(T[i]<0) add(i,t,-T[i],0);
	while(SPFA()) up();
}
signed main(){
	rd(n);rd(m);
	for(int x,i=1;i<=n;i++)
		rd(x),add(i,i+1,0,0,x,INF);
	for(int l,r,x,i=1;i<=m;i++)
		rd(l),rd(r),rd(x),add(r+1,l,0,x,0,INF);
	solve();cout<<ans;
}

```

---

## 作者：ycyaw (赞：6)

~~极其神仙的一道题~~

神仙就神仙在一个人可以对一段区间造成贡献

解题用到的主要是很神仙的建图方法$($看了题解$)$

我们以天数为点,然后第$i$天向第$i+1$天连$INF-w[i]$ $($第$i$天需要人数$)$容量，$0$价值的边

源点向第一天，第$n+1$天向汇点连$INF$容量，$0$价值的边

然后对于每个工作天数从$s-t$的志愿者，我们从第$s$天向第$t+1$天连$INF$容量，$c$价值的边

这张图怎么理解呢？

首先这张图的最大流肯定是$INF$

中间第$i$天向第$i+1$天连$INF-w[i]$容量的边，流量少了$w[i]$，就需要靠志愿者来补齐

一个志愿者可以给$s-t$路径上的所有边补上$1$的流量

我们要计算的就是获得最大流$INF$所需要的最小费用

即跑一遍最小费用最大流
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define ll long long
#define hh puts("")
#define time TTTT
using namespace std;
int n,m,st,ed,head[20005],vis[20005],time,dis[20005],w[1005];
int cnt=1,cost,ans;
struct Edge{
    int v,nx,val,s;
}e[2000005];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=ret*10+(ch^48);ch=getchar();}
    return ret*ff;
}
inline void add(int x,int y,int val,int s){
    e[++cnt].v=y;
    e[cnt].val=val;
    e[cnt].s=s;
    e[cnt].nx=head[x];
    head[x]=cnt;
}
inline bool spfa(){
    for(int i=0;i<=ed;i++) vis[i]=0,dis[i]=1e9;
    dis[st]=0;
    queue<int> q;
    q.push(st);
    while(!q.empty()){
        int now=q.front();
        q.pop();
        vis[now]=0;
        for(int i=head[now];i;i=e[i].nx){
            int v=e[i].v;
            if(dis[v]>dis[now]+e[i].val&&e[i].s){
                dis[v]=dis[now]+e[i].val;
                if(!vis[v]){
                    vis[v]=1;
                    q.push(v);
                }
            }
        }
    }
    return dis[ed]!=1e9;
}
int dfs(int now,int ma){
    if(now==ed) return ma;
    vis[now]=time;
    int used=0,t;
    for(int i=head[now];i;i=e[i].nx){
        int v=e[i].v;
        if((v==ed||vis[v]!=time)&&e[i].s&&dis[v]==dis[now]+e[i].val){
            if(t=dfs(v,min(ma-used,e[i].s))){
                e[i].s-=t;
                e[i^1].s+=t;
                cost+=e[i].val*t;
                used+=t;
                if(used==ma) break;
            }
        }
    }
    return used;
}
signed main(){
    n=read(),m=read();
    st=0,ed=n+2;
    for(int i=1;i<=n;i++){
        int t=read();
        add(i,i+1,0,1e9-t);
        add(i+1,i,0,0);
    }
    add(st,1,0,1e9);
    add(1,st,0,0);
    add(n+1,ed,0,1e9);
    add(ed,n+1,0,0);
    for(int i=1;i<=m;i++){
        int s=read(),t=read(),c=read();
        add(s,t+1,c,1e9);
        add(t+1,s,-c,0);
    }
    while(spfa()){
        do{
            time++;
            dfs(st,1e9);
        }while(vis[ed]==time);
    }
    printf("%d",cost);
    return 0;
}
```

---

## 作者：Sweetie_Liu (赞：2)

# 关于网络流解线性规划问题

以下皆为玄学，如有问题，私信（我也不会。

额，这个东西，不好解释。

- **引子**

	
    我们知道网络流有个叫流量守恒的东西（平常没人会在意他。

	我们在看一个等式 x1+x2-x3 = 0，如果我们把流入看做加，流出看做减的话，网络流中的点在某种意义上可以表示一个等式。

- **例题**
	
     [志愿者招募](https://www.luogu.com.cn/problem/P3980)

    我们如果设第$i$种志愿者使用数目为$x_i$，可以得到不等式

    $x_j+x_{j+1}+x_k...>a_i$,$a_i$为第i个位置至少需要的志愿者量。

    之后窝们把它变成等式 $x_j+x_{j+1}+x_k...-y_i-a_i = 0$

    我们于是得到了形如上面的n个式子，然后在前面和后面补充$0=0$,$0=0$之后，用着n+2个式子进行差分出n+1个式子。
    我们发现这里每个$x_i$只出现了一正一负，这里要引出我们用网络流解线规问题的一个条件，就是线规方程必须“连续”。

    - 例子：

        $x_1+x_2+x_3>a_1$

        $x_2+x_3>a_2$

        $x_3+x_4+x_5>a_3$

        $......$

    这样我们最后差分出的是式子才能保证$x_i$,只出现一正一负。

    至于为什么只能在$x_i$一正一负的时候动用网络流，是因为我们表达等式是用边的，但我们如果同时又多对$x_i$,那这几组边之间将无法进行约束。

    - **建图**


        等到差分等式之后，我们将$x_i$为负的位置连向$x_i$为正的位置，补充常数$y_i$类似，常数项若是负数，向T连边，否则S向i连边。
        满足条件就是讲S的出边流满。

**蒟蒻瞎掰一句，其实这类题就是让你列出式子后，尽可能的消元，构造出网络流可以进行有效约束的式子。**




---

## 作者：kkxhh (赞：2)

如果第 $i$ 天的需求为 $a_{i}$，那么我们就在 $i$ 与 $i+1$ 连一条容量为 $INF-a_{i}$，费用为 $0$ 的边。对于一个志愿者 $(s,t,c)$ 我们在 $s$ 和 $t+1$ 间连一条容量为 $INF$，费用为 $c$ 的边

为什么要这样建模呢？首先我们知道最小费用最大流求的是在流最大的前提下的最下费用，于是我们可以人为定一个最大流，然后花钱来达到这个最大流。对于这题来说，显然最大流就是 $INF$，第 $i$ 与第 $i+1$ 个节点间的边的容量为 $INF-a_{i}$，于是要达到最大流我们就还需要从志愿者的边上补上这 $a_{i}$ 的流量。而一个从 $s$ 工作到 $t$ 的志愿者可以为 $s$ 到 $t$ 之间的任何一个节点补充流量，于是我们就在 $s$ 和 $t+1$ 间连上一条费用为 $c$ 的边，表示每补 $1$ 流量需要花费 $c$ 的代价

代码如下：

```cpp
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;

typedef struct edge{
    int from,to,cap,cost,next;
}edge;

const int INF=100000000;
edge e[40010];
int n,m,k,s,t,head[1010],tot=1,c[1010],p[1010],f[1010],inque[1010],flow,cost,cnt;

inline int read(){
    int num=0,k=1; char c=getchar();
    while(c>'9' || c<'0') k=(c=='-')?0:k,c=getchar();
    while(c>='0' && c<='9') num=num*10+c-'0',c=getchar();
    return k?num:-num;
}

void addedge(int u,int v,int cap,int cost){
    e[++tot].from=u; e[tot].to=v; e[tot].cap=cap; e[tot].cost=cost; e[tot].next=head[u]; head[u]=tot;
    e[++tot].from=v; e[tot].to=u; e[tot].cap=0; e[tot].cost=-cost; e[tot].next=head[v]; head[v]=tot;
}

int spfa(){
    for(int i=1;i<=cnt;i++) p[i]=f[i]=0,c[i]=INF;
    queue<int> q;
    q.push(s); inque[s]=1; c[s]=0; f[s]=INF;
    while(!q.empty()){
        int x=q.front(); q.pop(); inque[x]=0;
        for(int i=head[x],to=e[i].to;i;i=e[i].next){
            to=e[i].to;
            if(e[i].cap && e[i].cost+c[x]<c[to]){
                c[to]=e[i].cost+c[x]; p[to]=i; f[to]=min(f[x],e[i].cap);
                if(!inque[to]) {q.push(to); inque[to]=1;}
            }
        }
    }
    return f[t];
}

void solve(){
    while(spfa()){
        flow+=f[t]; cost+=f[t]*c[t];
        for(int i=p[t];i;i=p[e[i].from]) e[i].cap-=f[t],e[i^1].cap+=f[t];
    }
    return;
}

int main(){
    n=read(); m=read(); s=n+2; t=n+3; cnt=n+3;
    for(int i=1;i<=n;i++) addedge(i,i+1,INF-read(),0);
    for(int i=1,ss,tt,c;i<=m;i++){
        ss=read(); tt=read(); c=read();
        addedge(ss,tt+1,INF,c);
    }
    addedge(s,1,INF,0); addedge(n+1,t,INF,0);
    solve();
    printf("%d",cost);
    return 0;
}

```

---

## 作者：秋日私语 (赞：1)

[更好的阅读体验点这里](https://blog.csdn.net/A_Comme_Amour/article/details/79772741)


题目
-

[传送门](https://www.lydsy.com/JudgeOnline/problem.php?id=1061)

题解
-

这道题可以说代表了一类题。这道题和[最长k可重区间集问题](https://blog.csdn.net/a_comme_amour/article/details/79605403)的建图方法是非常像的，并且这种问题都有两种建图方法，下面我来介绍一下；

我们暂且把这种问题叫做“选择区间问题”（口胡）吧；我考虑到当前点选择在某一个区间里面，会对“过去”产生影响，也会对“未来”造成影响（个人理解）

第一种建图方法：把每一天都拆点，点 i 到 i+n 容量为inf-a[i]，费用为0，i+n到i+1连容量为inf，费用为c[i]的边，对于志愿者的工作时间 < x , y >从x向y+n连一条权INF费用为c[i]的边，最小费用最大流;

我们可以发现我们多连了一些多余的边；

下一种建图方法我把它叫做”**在链上建图**“：每一天向下一天的容量为inf-a[i]，费用为0，可以理解为连续工作是不需要额外花钱的，每一个志愿者工作的天数（x，y），从x连边向y+1，容量为inf费用为c[i]; 

容量的妙处在于优先选择连续工作，减了a[i]那么程序会”使劲“使它达到满流，这样的话就需要额外花钱。

代码
-

```
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <queue>
using namespace std;
const int maxn=1e6;
const int inf=1e9;
int read(){
    char ch=getchar(); int now=0,f=1;
    while (ch<'0'||ch>'9') {if (ch=='-') f=-1; ch=getchar();}
    while (ch>='0'&&ch<='9') {now=(now<<1)+(now<<3)+ch-'0'; ch=getchar();}
    return now*f;}

queue <int> q;
int n,m,day[maxn],maxflow,mincost;
struct Poe{
    int s,t,c;
}a[maxn];
struct Edge{
    int next,to,flow,dis;
}edge[maxn<<1];
int num_edge=-1,head[maxn],dis[maxn],flow[maxn],last[maxn],pre[maxn];
bool vis[maxn];

void add_edge(int from,int to,int flow,int dis)
{
    edge[++num_edge].next=head[from];
    edge[num_edge].flow=flow;
    edge[num_edge].dis=dis;
    edge[num_edge].to=to;
    head[from]=num_edge;
}
void add(int x,int y,int z,int f) {add_edge(x,y,z,f); add_edge(y,x,0,-f);}

bool spfa(int s,int t)
{
    memset(dis,0x7f,sizeof(dis));
    memset(flow,0x7f,sizeof(flow));
    memset(vis,0,sizeof(vis));
    while (!q.empty()) q.pop();
    q.push(s); dis[s]=0; vis[s]=1; pre[t]=-1;
    while (!q.empty())
    {
        int now=q.front(); q.pop();
        vis[now]=0;
        for (int i=head[now]; i!=-1; i=edge[i].next)
        {
            int to=edge[i].to;
            if (edge[i].flow>0 && dis[to]>dis[now]+edge[i].dis)
            {
                dis[to]=dis[now]+edge[i].dis;
                flow[to]=min(flow[now],edge[i].flow);
                last[to]=i;
                pre[to]=now;
                if (!vis[to])
                {
                    vis[to]=1;
                    q.push(to);
                }
            }
        }
    }
    return pre[t]!=-1;
}

void MCMF(int s,int t)
{
    while (spfa(s,t))
    {
        int now=t;
        maxflow+=flow[t];
        mincost+=flow[t]*dis[t];
        while (now!=s)
        {
            edge[last[now]].flow-=flow[t];
            edge[last[now]^1].flow+=flow[t];
            now=pre[now];
        }
    }
}
void debug()
{
    for (int i=0; i<=num_edge; i++) printf("%d: %d %d %d %d\n",i,edge[i^1].to,edge[i].to,edge[i].flow,edge[i].dis);
    printf("\n");
}

int main()
{
    memset(head,-1,sizeof(head));
    n=read(); m=read();
    int S=0,T=n+2;
    for (int i=1; i<=n; i++)
    {
    	int x=read(); add(i,i+1,inf-x,0);
	}
    for (int i=1; i<=m; i++)
    {
        int s=read(); int t=read(); int c=read();
        add(s,t+1,inf,c);
    }
    add(S,1,inf,0); add(n+1,T,inf,0);
	MCMF(S,T);
    printf("%d\n",mincost);
    return 0;
}
```

总结
-

**链上建图**巧妙
容量减去一个值


---


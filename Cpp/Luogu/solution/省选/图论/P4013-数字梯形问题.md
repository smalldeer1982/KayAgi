# 数字梯形问题

## 题目描述

给定一个由 $n$ 行数字组成的数字梯形如下图所示。



 ![](https://cdn.luogu.com.cn/upload/pic/12216.png) 

梯形的第一行有 $m$ 个数字。从梯形的顶部的 $m$ 个数字开始，在每个数字处可以沿左下或右下方向移动，形成一条从梯形的顶至底的路径。


分别遵守以下规则：


1. 从梯形的顶至底的 $m$ 条路径互不相交；

1. 从梯形的顶至底的 $m$ 条路径仅在数字结点处相交；

1. 从梯形的顶至底的 $m$  条路径允许在数字结点相交或边相交。


## 说明/提示

$1\leq m,n \leq 20$


## 样例 #1

### 输入

```
2 5
2 3
3 4 5
9 10 9 1
1 1 10 1 1
1 1 10 12 1 1```

### 输出

```
66
75
77```

# 题解

## 作者：Iowa_BattleShip (赞：34)

很明显，这题是道**最大费用最大流**，只不过强行加上规则来导致你的码量轻松上天。

下面将三个规则一个一个解释如何建图
#### 规则一
~~其实我认为三个规则里第一个反而是相对最难的~~

$m$条路径皆不能相交，即点和边都不能相交。

首先，要使得路径上的点不相交(重合)，即每个点只能走一次，因此我们想到将每个点拆成两个点$X<i,j>$和$Y<i,j>$，并在$X<i,j>$和$Y<i,j>$之间连一条容量为$1$，费用为该点本身的数值的边，当选中这条边就表示某条路径经过点$<i,j>$，并将该点数值计入。

接下来是连边，其实很简单，将点$Y<i,j>$向$X<i+1,j>$和$X<i+1,j+1>$连上一条边，而根据下图，显然我们可以看出当点不相交时，边肯定是不会相交的，所以我们在添加边的时候容量是可以随便开的(当然要$≥1$)，费用则赋为$0$。
![](https://cdn.luogu.com.cn/upload/pic/16706.png)

最后按照惯例，给图加上一个超级源点$S$和超级汇点$T$，$S$向每个$X<1,i>$连一条容量为$1$，费用为$0$的边；每个$<n,i>$向$T$连一条容量为$1$，费用为$0$的边。

然后跑一波最大费用最大流即可。
#### 规则二
这下只要求边不相交(重合)了，所以可以不用拆点了。

直接连边，给每个点$<i,j>$向$<i+1,j>$和$<i+1,j+1>$连上一条边，容量为$1$(因为每条边只能走一次，而根据上图，边只会重合)，费用则赋为点$<i,j>$所表示的数值，即经过这条边表示选取了这个点的数(其实规则一中也可以这样连边，然后将拆点间的边的容量改为$0$即可)。

最后依旧定个超级源点$S$和超级汇点$T$，$S$依旧向每个$<1,i>$连一条容量为$1$，费用为$0$的边；而每个$<n,i>$向$T$连一条容量为$inf$的边(因为每个$<n,i>$都可以取$inf$次)，费用为$<n,i>$所表示的数值。

然后依旧一波最大费用最大流。
#### 规则三
~~其实就是没有规则~~

只需将规则二所连的边，除了与$S$连的边，其他边的容量全部改为$inf$就好，因为所有点和边都可以重复走了。

然后一波最大费用最大流带走$AC$~

$PS:$关于规则三我认为完全可以用$DP$跑过去，将这个梯形拆成$m$个三角形，然后直接$DP$，复杂度大概为$O(\frac{1}{2}n^2m)$，是可以跑过去的。

最后上~~冗长的~~代码

```cpp
#include<cstdio>//我用的是带SPFA的EK
#include<cstring>
using namespace std;
const int N=1e5+10;
int fi[N],di[N<<1],da[N<<1],ne[N<<1],co[N<<1],q[N],la[N],nm[N],dis[N],a[22][50],b[22][50],l,st=1e5+1,ed=1e5+2,s;
//fi,di,da,ne,co存边，q为队列，la,nm记录在SPFA中搜到的分层图，dis记录费用，a为原图，b为原图中每个数对应的编号，st是源点，ed是汇点
bool v[N];//在SPFA中记录该点有无在队列中
int re()//快读
{
	int x=0;
	char c=getchar();
	bool p=0;
	for(;c<'0'||c>'9';c=getchar())
		p=(c=='-'||p)?1:0;
	for(;c>='0'&&c<='9';c=getchar())
		x=x*10+(c-'0');
	return p?-x:x;
}
void add(int x,int y,int z,int c)//加边
{
	di[++l]=y;
	da[l]=z;
	co[l]=c;
	ne[l]=fi[x];
	fi[x]=l;
	di[++l]=x;
	da[l]=0;
	co[l]=-c;
	ne[l]=fi[y];
	fi[y]=l;
}
inline int minn(int x,int y)//手写min
{
	return x<y?x:y;
}
void cl()//每次跑完后重建图前的清空
{
	l=s=0;
	memset(fi,0,sizeof(fi));
	memset(di,0,sizeof(di));
	memset(da,0,sizeof(da));
	memset(ne,0,sizeof(ne));
	memset(co,0,sizeof(co));
}
bool spfa()//SPFA
{
	int head=0,tail=1,x,y,i;
	memset(dis,-50,sizeof(dis));//初始化为-inf
	memset(v,0,sizeof(v));
	q[1]=st;
	dis[st]=0;
	while(head!=tail)
	{
		head++;
		x=q[head];
		v[x]=0;
		for(i=fi[x];i;i=ne[i])//枚举边
		{
			y=di[i];
			if(da[i]>0&&dis[y]<dis[x]+co[i])//找到最大费用
			{
				dis[y]=dis[x]+co[i];
				la[y]=x;//记录分层图
				nm[y]=i;
				if(!v[y])//若不在队列则加入队列
				{
					tail++;
					q[tail]=y;
					v[y]=1;
				}
			}
		}
	}
	return dis[ed]>0;//判断ed有无走到
}
void ek()//EK
{
	int i,mi;
	while(spfa())
	{
		mi=1e9;
		for(i=ed;i!=st;i=la[i])//从分层图的ed枚举到st，找到最小的流量
			mi=minn(mi,da[nm[i]]);
		s+=mi*dis[ed];//累计每次的费用
		for(i=ed;i!=st;i=la[i])//修改容量
		{
			da[nm[i]]-=mi;
			da[((nm[i]+1)^1)-1]+=mi;
		}
	}
}
int main()
{
	int i,j,n,m,k,o,nu=0;
	k=m=re();
	n=re();
	o=(((m*n)<<1)+n*n-n)>>1;//等差数列求和公式+梯形面积公式，算出一共有多少数，拆点时区分编号用
	for(i=1;i<=n;i++,k++)
		for(j=1;j<=k;j++)
		{
			a[i][j]=re();
			b[i][j]=++nu;//输入的同时给点赋上编号
		}
	k=m;
	for(i=1;i<=k;i++)
		add(st,b[1][i],1,0);//连上源点
	for(i=1;i<n;i++,k++)
		for(j=1;j<=k;j++)
		{
			add(b[i][j],b[i][j]+o,1,a[i][j]);//给拆点间连边
			add(b[i][j]+o,b[i+1][j],1,0);//向左下和右下连边
			add(b[i][j]+o,b[i+1][j+1],1,0);
		}
	for(i=1;i<=k;i++)
	{
		add(b[n][i],b[n][i]+o,1,a[n][i]);//拆点间连边
		add(b[n][i]+o,ed,1,0);//向汇点连边
	}
	ek();//跑最大费用最大流
	printf("%d\n",s);
	cl();//清空重建
	k=m;
	for(i=1;i<=k;i++)
		add(st,b[1][i],1,0);//连源点
	for(i=1;i<n;i++,k++)
		for(j=1;j<=k;j++)
		{
			add(b[i][j],b[i+1][j],1,a[i][j]);//不需要拆点了，直接向左下右下连边
			add(b[i][j],b[i+1][j+1],1,a[i][j]);
		}
	for(i=1;i<=k;i++)
		add(b[n][i],ed,1e9,a[n][i]);//向汇点连边，容量为inf
	ek();//再来跑一遍
	printf("%d\n",s);
	cl();//同样清空
	k=m;
	for(i=1;i<=k;i++)
		add(st,b[1][i],1,0);//连汇点
	for(i=1;i<n;i++,k++)
		for(j=1;j<=k;j++)
		{
			add(b[i][j],b[i+1][j],1e9,a[i][j]);//向左下右下连边，容量为inf
			add(b[i][j],b[i+1][j+1],1e9,a[i][j]);
		}
	for(i=1;i<=k;i++)
		add(b[n][i],ed,1e9,a[n][i]);//向汇点连边，容量为inf
	ek();//最后一波带走~
	printf("%d\n",s);
	return 0;
}
```

---

## 作者：arfa (赞：6)

$$QEUES\ I$$

给的是点的容量,要拆点。我们记录一个 $id[i,j,1/2]$ 代表在 $[i,j]$ 方位上的入点和出点的编号。源点向每一个第一层的入点连一个流量为 $1$ 费用为 $0$ 的边。每一层的入点向出点连一个流量为 $1$ 费用为 $matrix[i,j]$ (代表这个位置的数值) 的边。每一层的出点往下一层的入点连流量为 $1$ 费用为 $0$ 的边。最后一层的出点向源点连一条流量为 $1$ 费用为 $0$ 的边。很显然,这样子保证了**点用过就用不了**的性质切且保证了**答案最小**。因为我们要**答案最大**,所以我们可以把所有边的费用变成负数,然后输出 $-\min cost$。

![](https://i.loli.net/2018/11/02/5bdc15e9e8960.png)


$$QEUES\ II$$

不能用的性质转化到了边上,我们可以直接把边的那些流量赋值为 $1$ 费用赋值为 $matrix[i,j]$。注意最后一层的点向汇点的边所是可以用很多次的,搞成 $inf$ 即可。

下面这个图有点错了,我把费用等于编号了。

![](https://i.loli.net/2018/11/03/5bdce4f26c742.png)

$$QEUES\ III$$

什么都可以用,直接把除了源点连向第一层的点的边的流量都赋值为 $inf$。由于只能有 $m$ 个路径跑过去所以第一层到源点的边是 $1$。

注意下面的代码 $sink$ 是汇点,$source$ 是用源点。 $n,m$ 是反的。 


```pascal
// 2018-11-07 一个矩阵最大的边长是 39 啊,所以开 20 会被我自己出的数据卡,所以来提醒大家
Uses math;

var
    from,reach,next,value,cost:array[-1..500010] of longint;
    dis,pre,last,flow:array[-1..50010] of longint;
    matrix:array[-1..41,-1..41] of longint;
    id:array[-1..41,-1..41,1..2] of longint;
    queue:array[-1..500010] of longint;
    cnt:array[-1..50010] of longint;
    vis:array[-1..50010] of boolean;
    n,m,i,j,l,r,x,y,tot,now,node,sink,source,maxflow,mincost:longint;

procedure add(x,y,sum_1,sum_2:longint);
begin
    inc(tot); from[tot]:=x; reach[tot]:=y; value[tot]:=sum_1; cost[tot]:= sum_2; next[tot]:=cnt[x]; cnt[x]:=tot;
    inc(tot); from[tot]:=y; reach[tot]:=x; value[tot]:=0    ; cost[tot]:=-sum_2; next[tot]:=cnt[y]; cnt[y]:=tot;
end;

function spfa:boolean;
var head,tail,now,i:longint;
begin
    filldword(dis,sizeof(dis) div 4,maxlongint);
    filldword(flow,sizeof(flow) div 4,maxlongint);
    filldword(vis,sizeof(vis) div 4,0);
    head:=1; tail:=1;  queue[1]:=source; vis[source]:=True; dis[source]:=0; pre[sink]:=-1;

    while head<=tail do
    begin
        now:=queue[head]; vis[now]:=False; inc(head);
        i:=cnt[now];
        while i<>-1 do
        begin
            if (value[i]>0)and(dis[reach[i]]>dis[now]+cost[i]) then
            begin
                dis[reach[i]]:=dis[now]+cost[i];
                pre[reach[i]]:=now;
                last[reach[i]]:=i;
                flow[reach[i]]:=min(flow[now],value[i]);
                if vis[reach[i]]=False then
                begin
                    vis[reach[i]]:=True;
                    inc(tail); queue[tail]:=reach[i];
                end;
            end;
            i:=next[i];
        end;
    end;
    if pre[sink]=-1 then exit(False); exit(True);
end;

procedure MincostMaxflow;
begin
    maxflow:=0; mincost:=0; now:=0;
    while (spfa) do
    begin
        now:=sink;
        inc(maxflow,flow[sink]);
        inc(mincost,flow[sink]*dis[sink]);
        while now<>source do
        begin
            dec(value[last[now]],flow[sink]);
            inc(value[last[now] xor 1],flow[sink]);
            now:=pre[now];
        end;
    end;
end;

procedure Clear;
begin
    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1); tot:=1;
    fillchar(value,sizeof(value),0);
    fillchar(reach,sizeof(reach),0);
    fillchar(cost,sizeof(cost),0);
    fillchar(next,sizeof(next),0);
end;

procedure Construction_I;
begin
    for i:=1 to n do add(source,id[1,i,1],1,0);
    for i:=1 to m do for j:=1 to n+i-1 do
        begin
            add(id[i,j,1],id[i,j,2],1,-matrix[i,j]);
            add(id[i,j,2],id[i+1,j,1],1,0);
            add(id[i,j,2],id[i+1,j+1,1],1,0);
        end;
    for i:=1 to n+m-1 do add(id[m,i,2],sink,1,0);
end;

procedure Construction_II;
begin
    for i:=1 to n do add(source,id[1,i,1],1,0);
    for i:=1 to m do for j:=1 to n+i-1 do
        begin
            add(id[i,j,1],id[i+1,j,1],1,-matrix[i,j]);
            add(id[i,j,1],id[i+1,j+1,1],1,-matrix[i,j]);
        end;
    for i:=1 to n+m-1 do add(id[m,i,1],sink,maxlongint div 843,-matrix[m,i]);
end;

procedure Construction_III;
begin
    for i:=1 to n do add(source,id[1,i,1],1,0);
    for i:=1 to m do for j:=1 to n+i-1 do
        begin
            add(id[i,j,1],id[i+1,j,1],maxlongint div 843,-matrix[i,j]);
            add(id[i,j,1],id[i+1,j+1,1],maxlongint div 843,-matrix[i,j]);
        end;
    for i:=1 to n+m-1 do add(id[m,i,1],sink,maxlongint div 843,-matrix[m,i]);
end;

begin
    read(n,m);
    for i:=1 to m do for j:=1 to n+i-1 do
        begin
            inc(node,2); id[i,j,1]:=node; id[i,j,2]:=node+1;
            read(matrix[i,j]);
        end;
    source:=1; sink:=node+2;
    Clear; Construction_I; MincostMaxflow; writeln(-mincost);
    Clear; Construction_II; MincostMaxflow; writeln(-mincost);
    Clear; Construction_III; MincostMaxflow; writeln(-mincost);
end.
```

---

## 作者：封禁用户 (赞：3)

## 感动，终于过了(由此我发现了自己是有多么的菜……)

~~其实其他几个发题解大佬都已经把思路讲的很清楚了，我就不细讲了，主要是提醒大家一下~~

#### 可能这一题的提交记录中也只有我交了这么多次，发了三篇讨论，连着改了一个星期吧……

大致的思路：

1. - 第一问要保证路径互不相交，也就是不能让一个点被经过多次

   - 是不是感觉很熟悉！是不是！没错，就是拆点大法！用拆点来保证只经过这个点一次即可QQwQ
   
2. - 第二问仅不允许在路径上相交，就没必要拆点啦QQwQ

   - 同样的，用流量为1来保证路径只经过一次
   
3. - 第三问一看……噢，这不相当于是没有限制么QQQQQwQ！

   - 激动的我们将流量开大并什么也不想管

以下是我主要出问题的几个点（求不要嘲讽）：

- memset赋负数时只能赋-1，赋其他的数会变成奇怪的负数，所以在判断时要看他是否<0，否则就会出错……

- 这一题不要看范围只有20就不开大数组范围，一定要开大！！，不然就会出现奇怪的错误，因为数组是连续的，所以一旦爆数组就会修改到其他几个数组然后就挂了……（像我就T到飞起……）

之前我改代码是发现……题解中没有一篇Dinic递归的代码！

~~于是给大家一个并手动普度众生~~

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int f=1,w=0;char x=0;
    while(x<'0'||x>'9') {if(x=='-') f=-1; x=getchar();}
    while(x!=EOF&&x>='0'&&x<='9') {w=(w<<3)+(w<<1)+(x^48);x=getchar();}
    return f*w;
}
int head[200020],cur[200020],num_edge=-1;
int a[1001][1001],b[1001][1001],cnt;
int n,m,s,t,ans;
struct Edge
{
    int next,to,dis,cos;
}edge[200020];
inline void add(int from,int to,int dis,int cos)
{
    edge[++num_edge].next=head[from];
    edge[num_edge].to=to;
    edge[num_edge].dis=dis;
    edge[num_edge].cos=cos;
    head[from]=num_edge;
}
inline void clear()
{
    num_edge=-1;
    memset(head,-1,sizeof(head));
    ans=0;
}
int d[200000],v[200000],flo[200000];
inline bool bfs()
{
    memset(d,-50,sizeof(d));
    memset(v,0,sizeof(v));
    memset(flo,0,sizeof(flo));
    queue<int> q;
    q.push(s);
    d[s]=0;
    v[s]=1;flo[s]=1;
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        v[x]=0;
        for(int i=head[x];i!=-1;i=edge[i].next)
        {
            int y=edge[i].to;
            if(edge[i].dis>0&&d[y]<d[x]+edge[i].cos)
            {
                d[y]=d[x]+edge[i].cos;
                flo[y]=flo[x]+1;
                if(!v[y]) { q.push(y); v[y]=1; }
            }
        }
    }
    if(d[t]<0) return 0;
    else return 1;
}
int dfs(int pos,int dis)
{
    if(pos==t) return dis;
    for(int i=cur[pos];i!=-1;i=edge[i].next)
        if(flo[edge[i].to]==flo[pos]+1&&edge[i].dis!=0&&d[edge[i].to]==d[pos]+edge[i].cos)
        {
            int data=dfs(edge[i].to,min(dis,edge[i].dis));
            if(data>0)
            {
                edge[i].dis-=data;
                edge[i^1].dis+=data;
                ans+=edge[i].cos;
                cur[pos]=i;
                return data; 
            }
        }
    return 0;
}
void  Dinic()
{
    while(bfs())
    {
        memcpy(cur,head,sizeof(head));
        while(dfs(s,0x3f3f3f3f));
    }
}
int main(){
    memset(head,-1,sizeof(head));
    m=read();
    n=read();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m+i-1;j++)
            a[i][j]=read(),b[i][j]=++cnt;
    s=0;
    t=cnt*2+3;
    for(int i=1;i<=m;i++)
        add(s,b[1][i],1,0),add(b[1][i],s,0,0);
    for(int i=1;i<n;i++)
        for(int j=1;j<=m+i-1;j++)
        {
            add(b[i][j],b[i][j]+cnt,1,a[i][j]);
            add(b[i][j]+cnt,b[i][j],0,-a[i][j]);
            add(b[i][j]+cnt,b[i+1][j],1,0);
            add(b[i+1][j],b[i][j]+cnt,0,0);
            add(b[i][j]+cnt,b[i+1][j+1],1,0);
            add(b[i+1][j+1],b[i][j]+cnt,0,0);
        }
    for(int i=1;i<=m+n-1;i++)
    {
        add(b[n][i],b[n][i]+cnt,1,a[n][i]);
        add(b[n][i]+cnt,b[n][i],0,-a[n][i]);
        add(b[n][i]+cnt,t,1,0);
        add(t,b[n][i]+cnt,0,0);
    }
    Dinic();
    printf("%d\n",ans);
    clear();
    for(int i=1;i<=m;i++)
        add(s,b[1][i],1,0),add(b[1][i],s,0,0);
    for(int i=1;i<n;i++)
        for(int j=1;j<=m+i-1;j++)
        {
            add(b[i][j],b[i+1][j],1,a[i][j]);
            add(b[i+1][j],b[i][j],0,-a[i][j]);
            add(b[i][j],b[i+1][j+1],1,a[i][j]);
            add(b[i+1][j+1],b[i][j],0,-a[i][j]);
        }
    for(int i=1;i<=m+n-1;i++)
    {
        add(b[n][i],t,0x3f3f3f3f,a[n][i]);
        add(t,b[n][i],0,-a[n][i]);
    }
    Dinic();
    printf("%d\n",ans);
    clear();
    for(int i=1;i<=m;i++)
        add(s,b[1][i],1,0),add(b[1][i],s,0,0);
    for(int i=1;i<n;i++)
        for(int j=1;j<=m+i-1;j++)
        {
            add(b[i][j],b[i+1][j],0x3f3f3f3f,a[i][j]);
            add(b[i+1][j],b[i][j],0,-a[i][j]);
            add(b[i][j],b[i+1][j+1],0x3f3f3f3f,a[i][j]);
            add(b[i+1][j+1],b[i][j],0,-a[i][j]);
        }
    for(int i=1;i<=m+n-1;i++)
    {
        add(b[n][i],t,0x3f3f3f3f,a[n][i]);
        add(t,b[n][i],0,-a[n][i]);
    }
    Dinic();
    printf("%d\n",ans);
}

```

---

## 作者：孑彧 (赞：3)

这个题

**太~~毒瘤~~好了！**

![_9PPSU6__N@GX_B_`RY4LNY.png](https://i.loli.net/2019/09/07/yIL3gp9iQ5FMYC8.png)

上面是我的提交记录

所以我认为我有必要来写一篇题解来~~祭奠~~提醒和我一样被前两个点卡掉的人

显而易见，这是一道关于最大费用流的题（~~话说我这几天见什么都像是网络流~~）

有三个子问题，所以显而意见我们要建三次图，跑三次Dinic（我是蒟蒻只会这个）

那么按照常理，第一个问题肯定是最难的（你从哪里听来的这个常理？）

第一个子问题，既不可以走相同的边，也不可以走相同的点

对于第一个条件，我们可以把每一条边的流量设置为1，即可解决

而对于第二个条件，我们就要思考一下（~~看一下题解~~）了

既然每个点只能通过一次，所以说通过每个点的流量最多是1

但是他有两条向下的边，我们总不能记录一个点两条边分别长什么样吧？

所以我们需要对这个点的流量进行限制，这里进行一个非常普遍的做法，把一个点拆分成两个，这样就可以把两个点之间的边的流量设置为一，费用设置为本身的数值，然后就满足限制条件了。

建边过程：
```cpp
	for(long long i=1;i<=k;i++){
		jian(S,m[1][i],1,0);
	}
	for(long long i=1;i<n;i++){
		for(long long j=1;j<=k+i-1;j++){
			jian(m[i][j],m[i][j]+tot+1,1,a[i][j]);
			jian(m[i][j]+tot+1,m[i+1][j],1,0);
			jian(m[i][j]+tot+1,m[i+1][j+1],1,0);
		}
	}
	for(long long j=1;j<=k+n-1;j++){
		jian(m[n][j],m[n][j]+tot+1,1,a[n][j]);
		jian(m[n][j]+tot+1,T,1,0);
	}
```
接下来思考下一个子问题

点可以重复用，边只能用一次

那这个不就是第一个子问题的阉割版么，我们就可以不需要拆点，在每个节点处向下面两个点连两条流量为1，费用为他自身的边就好了嘛！

建边过程：
```cpp
	for(long long i=1;i<=k;i++){
		jian(S,m[1][i],1,0);
	}
	for(long long i=1;i<n;i++){
		for(long long j=1;j<=k+i-1;j++){
			jian(m[i][j],m[i+1][j],1,a[i][j]);
			jian(m[i][j],m[i+1][j+1],1,a[i][j]);
		}
	}
	for(long long j=1;j<=k+n-1;j++){
		jian(m[n][j],T,inf,a[n][j]);
	}
```
这里有一个小地方需要注意，由于每一个点可以重复进入，所以我们需要把底部的点到总汇点的边流量设为无限大

第三个子问题就更简单了，我们只需要把每一条边的流量设为无限即可轻松解决

```cpp
	for(long long i=1;i<=k;i++){
		jian(S,m[1][i],1,0);
	}
	for(long long i=1;i<n;i++){
		for(long long j=1;j<=k+i-1;j++){
			jian(m[i][j],m[i+1][j],inf,a[i][j]);
			jian(m[i][j],m[i+1][j+1],inf,a[i][j]);
		}
	}
	for(long long j=1;j<=k+n-1;j++){
		jian(m[n][j],T,inf,a[n][j]);
	}
```
到这里建边过程就已经结束啦，但是我们要注意在每次建边之前需要把之前建的边给清空，防止发生某些不知明的错误

还有非常重要的一点！！！

数组一定要开够！！！

这个题最多有20*（20+20）*2=1600个点，所以我们开的数组一定要开够！

否则就会出现和我一样，后面的点能过，LOJ能过，但是前两个点怎么也过不了的情况！

望后人不要再犯和我这样的错误XD

附上完整代码：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
#define maxn 1000
#define maxm 100000
#define inf 22222222
using namespace std;
struct Edge{
	long long to,next,f,v;
}e[maxm];
long long ecnt=1,head[maxm];
void adde(long long x,long long y,long long f,long long v){
	e[++ecnt].to=y;
	e[ecnt].f=f;
	e[ecnt].v=v;
	e[ecnt].next=head[x];
	head[x]=ecnt;
}
void jian(long long x,long long y,long long f,long long v){
	adde(x,y,f,v);
	adde(y,x,0,-v);
}
long long n,k;
long long a[maxn][maxn];
long long m[maxn][maxn],tot=3;
long long dis[maxm],pre[maxm],last[maxm],flow[maxm];
long long vis[maxm];
long long S,T;
void clean(){
	memset(e,0,sizeof(e));
	ecnt=1;
	memset(head,0,sizeof(head));
}
bool spfa(){
	memset(dis,128,sizeof(dis));
	memset(flow,0x3f,sizeof(flow));
	memset(vis,0,sizeof(vis));
	queue<long long>q;
	q.push(S);
	vis[S]=1;
	dis[S]=0;
	pre[T]=-1;
	while(!q.empty()){
		long long now=q.front();
		q.pop();
		vis[now]=0;
		for(long long i=head[now];i;i=e[i].next){
			long long to=e[i].to;
			if(e[i].f>0&&dis[to]<dis[now]+e[i].v){
				dis[to]=dis[now]+e[i].v;
				pre[to]=now;
				last[to]=i;
				flow[to]=min(flow[now],e[i].f);
				if(!vis[to]){
					vis[to]=1;
					q.push(to);
				}
			}
		}
	}
	return pre[T]!=-1;
}
long long Dinic(){
	long long maxcost=0;
	while(spfa()){
		long long now=T;
		maxcost+=flow[T]*dis[T];
		while(now!=S){
			e[last[now]].f-=flow[T];
			e[last[now]^1].f+=flow[T];
			now=pre[now];
		}
	}
	return maxcost;
}
int main(){
	scanf("%lld %lld",&k,&n);
	for(long long i=1;i<=n;i++){
		for(long long j=1;j<=k+i-1;j++){
			scanf("%lld",&a[i][j]);
			m[i][j]=++tot;
		}
	}
	S=1;
	T=2;
	tot++;
	for(long long i=1;i<=k;i++){
		jian(S,m[1][i],1,0);
	}
	for(long long i=1;i<n;i++){
		for(long long j=1;j<=k+i-1;j++){
			jian(m[i][j],m[i][j]+tot+1,1,a[i][j]);
			jian(m[i][j]+tot+1,m[i+1][j],1,0);
			jian(m[i][j]+tot+1,m[i+1][j+1],1,0);
		}
	}
	for(long long j=1;j<=k+n-1;j++){
		jian(m[n][j],m[n][j]+tot+1,1,a[n][j]);
		jian(m[n][j]+tot+1,T,1,0);
	}
	printf("%lld\n",Dinic());
	clean();
	for(long long i=1;i<=k;i++){
		jian(S,m[1][i],1,0);
	}
	for(long long i=1;i<n;i++){
		for(long long j=1;j<=k+i-1;j++){
			jian(m[i][j],m[i+1][j],1,a[i][j]);
			jian(m[i][j],m[i+1][j+1],1,a[i][j]);
		}
	}
	for(long long j=1;j<=k+n-1;j++){
		jian(m[n][j],T,inf,a[n][j]);
	}
	printf("%lld\n",Dinic());
	clean();
	for(long long i=1;i<=k;i++){
		jian(S,m[1][i],1,0);
	}
	for(long long i=1;i<n;i++){
		for(long long j=1;j<=k+i-1;j++){
			jian(m[i][j],m[i+1][j],inf,a[i][j]);
			jian(m[i][j],m[i+1][j+1],inf,a[i][j]);
		}
	}
	for(long long j=1;j<=k+n-1;j++){
		jian(m[n][j],T,inf,a[n][j]);
	}
	printf("%lld\n",Dinic());
	return 0;
}
```
PS：点个赞再走吧QwQ！

---

## 作者：11D_Beyonder (赞：2)

## 分析   
&emsp;&emsp;$1\sim n$ 行的数字个数呈等差数列，共有 $num=\frac{n(2m+n-1)}{2}$ 个数字。不妨将数字看作一个点，第 $i$ 行 $j$ 列的点的编号为 $\frac{(i-1)(2m+i-2)}{2}+j$，记作 $ID(i,j)$。其值作为点权，一条路径自上而下覆盖 $m$ 个点，费用为点权和。可以考虑使用费用流解决问题。  
&emsp;&emsp;费用流的费用是边的单位费用，要将点权体现在边上，可进行拆点操作。对于编号为 $ID(i,j)$ 的点，将其拆成两个点 $X_{ID(i,j)},Y_{ID(i,j)}$，$X_{ID(i,j)}$ 编号为 $ID(i,j)$，$Y_{ID(i,j)}$ 编号为 $ID(i,j)+num$，边上的费用为其点权值。 设置源点 $s$，连接点 $ID(1,1)\sim ID(1,m)$，费用为 $0$；设置汇点 $t$，$ID(n,1)\sim ID(n,m+n-1)$ 向 $t$ 连边，费用为 $0$；对于 $i<n$ 的点，$Y_{ID(i,j)}$ 向 $X_{ID(i+1,j)}$ 和 $X_{ID(i+1,j+1)}$ 连边，容量为 $0$。对于三种不同的限制条件，要通过设置每条边的容量，使得利用 $\text{MCMF}$ 算法求出的最大费用最大流即为答案。  
&emsp;&emsp;首先看 $s$ 的出边和 $t$ 的入边。$m$ 条路径要从顶层 $m$ 个点出发，$s$ 的出边的容量应设为 $1$。由于最后要确定 $m$ 条路径，流入 $t$ 的流量必须为 $m$；$s$ 出边容量设置好后，网络最大流必然不超过 $m$，因此直接设 $t$ 的入边流量都为 $+\infty$ 即可。
&emsp;&emsp;第一种限制条件，从梯形的顶至底的 $m$ 条路径互不相交。可以将 $X_{ID(i,j)}$ 和 $Y_{ID(i,j)}$ 之间边的容量设为 $1$，表示每个数字只能使用一次，路径不能有相交的点；再将 $Y_{ID(i,j)}$ 向 $X_{ID(i+1,j)}$ 和 $X_{ID(i+1,j+1)}$ 连边的容量设为 $1$，表示路径不能有相交的边。实际上，“路径没有相交的点”是一个比“路径没有相交的边”更强的条件，将 $X_{ID(i,j)}$ 和 $Y_{ID(i,j)}$ 之间边的容量设为 $1$ 即可。  
&emsp;&emsp;第二种限制条件，从梯形的顶至底的 $m$ 条路径仅在数字结点处相交。可以将 $X_{ID(i,j)}$ 和 $Y_{ID(i,j)}$ 之间边的容量设为 $+\infty$，路径可以能有相交的点；再将 $Y_{ID(i,j)}$ 向 $X_{ID(i+1,j)}$ 和 $X_{ID(i+1,j+1)}$ 连边的容量设为 $1$，表示路径不能有相交的边。  
&emsp;&emsp;第三种限制条件，从梯形的顶至底的 $m$ 条路径允许在数字结点相交或边相交。可以将 $X_{ID(i,j)}$ 和 $Y_{ID(i,j)}$ 之间边的容量设为 $+\infty$，路径可以能有相交的点；再将 $Y_{ID(i,j)}$ 向 $X_{ID(i+1,j)}$ 和 $X_{ID(i+1,j+1)}$ 连边的容量设为 $+\infty$，表示路径能有相交的边。     
&emsp;&emsp;对三种条件各建一张图，求最大费用最大流即可。  

## 代码  
```cpp
/******************************************************************
Copyright: 11D_Beyonder All Rights Reserved
Author: 11D_Beyonder
Problem ID: 洛谷 P4013
Date: 8/5/2020
Description: Maximum-cost Flow
*******************************************************************/
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
const int inf=0x3f3f3f3f;
const int N=2003;
struct E
{
	int to;
	int cap;
	int cost;
	int Next;
};
E edge[N<<6];
int head[N],tot;
int incf[N],pre[N];
int dis[N];
bool inqueue[N];
int m,n,num;
int s,t;
int a[N][N];
void init();
int ID(int,int);
inline void add_edge(int,int,int,int);
bool SPFA();
int MCMF();
int main()
{
	cin>>m>>n;
	int i,j;
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m+i-1;j++)
		{
			scanf("%d",&a[i][j]);
		}
	}
	//第一类
	init();
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m+i-1;j++)
		{
			if(i==1) add_edge(s,ID(i,j),1,0);
			if(i==n) add_edge(ID(i,j)+num,t,inf,0);
			if(i<n)
			{
				add_edge(ID(i,j)+num,ID(i+1,j),1,0);
				add_edge(ID(i,j)+num,ID(i+1,j+1),1,0);
			}
			add_edge(ID(i,j),ID(i,j)+num,1,-a[i][j]);
		}
	}
	cout<<-MCMF()<<endl;
	//第二类
	init();
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m+i-1;j++)
		{
			if(i==1) add_edge(s,ID(i,j),1,0);
			if(i==n) add_edge(ID(i,j)+num,t,inf,0);
			if(i<n)
			{
				add_edge(ID(i,j)+num,ID(i+1,j),1,0);
				add_edge(ID(i,j)+num,ID(i+1,j+1),1,0);
			}
			add_edge(ID(i,j),ID(i,j)+num,inf,-a[i][j]);
		}
	}
	cout<<-MCMF()<<endl;
	//第三类
	init();
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m+i-1;j++)
		{
			if(i==1) add_edge(s,ID(i,j),1,0);
			if(i==n) add_edge(ID(i,j)+num,t,inf,0);
			if(i<n)
			{
				add_edge(ID(i,j)+num,ID(i+1,j),inf,0);
				add_edge(ID(i,j)+num,ID(i+1,j+1),inf,0);
			}
			add_edge(ID(i,j),ID(i,j)+num,inf,-a[i][j]);
		}
	}
	cout<<-MCMF()<<endl;
	return 0;
}
void init()
{
	tot=1;
	num=(2*m+n-1)*n/2;
	memset(head,-1,sizeof(head));
	s=0;
	t=num*2+1;
}
inline void add_edge(int u,int v,int cap,int cost)
{
	tot++;
	edge[tot].to=v;
	edge[tot].cap=cap;
	edge[tot].cost=cost;
	edge[tot].Next=head[u];
	head[u]=tot;
	tot++;
	edge[tot].to=u;
	edge[tot].cap=0;
	edge[tot].cost=-cost;
	edge[tot].Next=head[v];
	head[v]=tot;
}
bool SPFA()
{
	queue<int>q;
	memset(dis,inf,sizeof(dis));
	memset(inqueue,0,sizeof(inqueue));
	q.push(s);
	dis[s]=0;
	inqueue[s]=1;
	incf[s]=inf;
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		inqueue[x]=0;
		for(register int i=head[x];~i;i=edge[i].Next)
		{
			if(!edge[i].cap) continue;//剩余容量为0，不在残量网络中。
			int y=edge[i].to;
			if(dis[y]>dis[x]+edge[i].cost)
			{
				dis[y]=dis[x]+edge[i].cost;//松弛操作
				incf[y]=min(incf[x],edge[i].cap);//最小剩余容量
				pre[y]=i;//记录前驱
				if(!inqueue[y])
				{
					inqueue[y]=1;
					q.push(y);
				}
			}
		}
	}
	if(dis[t]==inf) return 0;//汇点不可达，已经求出最大流
	else return 1;
}
int MCMF()
{
	int maxflow,mincost;
	maxflow=mincost=0;
	while(SPFA())
	{
		int x=t;
		//沿着前驱倒着走增广路
		while(x!=s)
		{
			int y=pre[x];
			edge[y].cap-=incf[t];
			edge[y^1].cap+=incf[t];
			x=edge[y^1].to;
		}
		maxflow+=incf[t];
		mincost+=dis[t]*incf[t];
	}
	return mincost;
}
int ID(int x,int y) {return (2*m+x-2)*(x-1)/2+y;}
```
## 后记  
&emsp;&emsp;数组要开大些，若越界后动了其他地方的内存，就 $\text{TLE}$ 了。  

---

## 作者：一扶苏一 (赞：2)

## Description

给定一个由 $n$ 行数字组成的数字梯形如下图所示。

![img](https://cdn.luogu.com.cn/upload/pic/12216.png) 

梯形的第一行有 $m$ 个数字。从梯形的顶部的 $m$ 个数字开始，在每个数字处可以沿左下或右下方向移动，形成一条从梯形的顶至底的路径。

分别遵守以下规则：

1. 从梯形的顶至底的 $m$ 条路径互不相交；
2. 从梯形的顶至底的 $m$ 条路径仅在数字结点处相交；
3. 从梯形的顶至底的 $m$ 条路径允许在数字结点相交或边相交。

## Limitation

$1~\leq~n,~m~\leq~20$

## Solution

解释一下题意，边不相交指的是不能有两条路径同时经过 $u \rightarrow~v$ 的路径。

先考虑限制 $3$，也就是没有限制的情况，做法非常显然：

> 上一层向下一层的数字连边，容量为无穷代表这条边可以走无穷次，花费为 $0$；
>
> 每个数字都拆一下点，两个点之间连边容量为无穷，代表可以选这个点无数次，花费为这个点的权值代表经过他付出的代价；
>
> $s$ 向第一层连容量为 $1$ 费用为 $0$ 的边，最后一层向 $t$ 连容量为无穷费用为 $0$ 的边，跑最大费用最大流即可。

考虑限制 $2$，一条边只能经过一次，于是将边的容量置为 $1$ 即可。

考虑限制 $1$，同理将点的容量置成 $1$ 即可。

然后如果你Wa前两个点需要注意梯形的最下面会有 $n + m$ 个点而不是 $m$ 个

## Code

```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
#ifdef ONLINE_JUDGE
#define freopen(a, b, c)
#endif

typedef long long int ll;

namespace IPT {
  const int L = 1000000;
  char buf[L], *front=buf, *end=buf;
  char GetChar() {
    if (front == end) {
      end = buf + fread(front = buf, 1, L, stdin);
      if (front == end) return -1;
    }
    return *(front++);
  }
}

template <typename T>
inline void qr(T &x) {
  char ch = IPT::GetChar(), lst = ' ';
  while ((ch > '9') || (ch < '0')) lst = ch, ch=IPT::GetChar();
  while ((ch >= '0') && (ch <= '9')) x = (x << 1) + (x << 3) + (ch ^ 48), ch = IPT::GetChar();
  if (lst == '-') x = -x;
}

namespace OPT {
  char buf[120];
}

template <typename T>
inline void qw(T x, const char aft, const bool pt) {
  if (x < 0) {x = -x, putchar('-');}
  int top=0;
  do {OPT::buf[++top] = static_cast<char>(x % 10 + '0');} while (x /= 10);
  while (top) putchar(OPT::buf[top--]);
  if (pt) putchar(aft);
}

const int maxn = 5010;
const int INF = 0x3f3f3f3f;

struct Edge {
  int u, v, flow, fee;
  Edge *nxt, *bk;
  Edge(const int _u, const int _v, const int _flow, const int _fee, Edge* &h)
      : u(_u), v(_v), flow(_flow), fee(_fee), nxt(h) {
    h = this;
  }

  ~Edge() {
    if (this->nxt) delete this->nxt;
  }
};
Edge *hd[maxn], *pre[maxn];
inline void cont(const int _u, const int _v, const int _flow, const int _fee) {
  auto u = new Edge(_u, _v, _flow, _fee, hd[_u]), v = new Edge(_v, _u, 0, -_fee, hd[_v]);
  (u->bk = v)->bk = u;
}

int n, m, s, t, ans;
int MU[maxn][maxn], id[maxn][maxn][2], dist[maxn], canag[maxn];
bool inq[maxn];
std::queue<int>Q;

void EK();
bool spfa();
void argu();
void setedge(int x);
void setpoint(int x);

int main() {
  freopen("1.in", "r", stdin);
  qr(m); qr(n);
  for (int i = 1; i <= n; ++i) {
    for (int j = 1, k = m + i; j < k; ++j) {
      id[i][j][0] = ++t; id[i][j][1] = ++t;
      qr(MU[i][j]);
    }
  }
  s = ++t; ++t;
  setpoint(1);
  setedge(1);
  EK();
  setpoint(INF);
  setedge(1);
  EK();
  setpoint(INF);
  setedge(INF);
  EK();
  return 0;
}

void setpoint(int x) {
  for (int i = 1; i <= t; ++i) {
    delete hd[i];
    hd[i] = NULL;
  }
  for (int i = 1; i <= m; ++i) {
    cont(s, id[1][i][0], 1, 0);
  }
  for (int i = 1; i <= n; ++i) {
    for (int j = 1, k = i + m - 1; j <= k; ++j) {
      cont(id[i][j][0], id[i][j][1], x, MU[i][j]);
    }
  }
}

void setedge(int x) {
  for (int i = 1; i < n; ++i) {
    int di = i + 1;
    for (int j = 1, k = i + m - 1; j <= k; ++j) {
      cont(id[i][j][1], id[di][j][0], x, 0);
      cont(id[i][j][1], id[di][j + 1][0], x, 0);
    }
  }
  for (int j = 1, k = m + n - 1; j <= k; ++j) cont(id[n][j][1], t, INF, 0);
}

void EK() {
  ans = 0;
  while (spfa()) argu();
  qw(ans, '\n', true);
}

bool spfa() {
  memset(canag, 0, sizeof canag);
  for (int i = 1; i <= t; ++i) dist[i] = -INF;
  dist[s] = 0; Q.push(s); canag[s] = INF;
  while (!Q.empty()) {
    int u = Q.front(); Q.pop(); inq[u] = false;
    for (auto e = hd[u]; e; e = e->nxt) if (e->flow > 0) {
      int v = e->v;
      if (dist[v] < (dist[u] + e->fee)) {
        dist[v] = dist[u] + e->fee;
        if (!inq[v]) Q.push(v);
        inq[v] = true;
        canag[v] = std::min(canag[u], e->flow);
        pre[v] = e;
      }
    }
  }
  return dist[t] != -INF;
}

void argu() {
  ans += canag[t] * dist[t];
  for (auto e = pre[t]; e; e = pre[e->u]) {
    e->flow -= canag[t]; e->bk->flow += canag[t];
  }
}
```



---

## 作者：FREEH (赞：2)

 ### 【题目】
![题目](https://cdn.luogu.com.cn/upload/pic/26046.png)

### 【解题思路】
- 性质
	- 观察图像可以发现：路径不会“相交”，只会“重合”或部分“重合”。
- 问题一
	- 因为每条路径都不相交，但是因此每一个点只能经过一次，每条边只能经过一次。
    
	- 为了限制经过次数，可以把每一个点进行拆点，拆成点1和点2,
    - 所以把点1和点2连接一条容量为1，费用为点的价值的边。
    - 把点2与这个点斜下方的点1连接一条容量为1，费用为0的边。
    
    - 把源点与第一层的点1连接一条容量为1，费用为0的边。
    - 把最后一层的点2与汇点连接一条容量为1，费用为0的边。
- 问题二
	- 可以重复经过点，那么拆点的步骤也省了。要注意开始点不能重复选，只能选一次；结束点却可以选无数次。
    
    - 只要把每一个点与其斜下方的点连接一条容量为1，费用为无穷大的边。
    
	- 把源点与第一层的点连接一条容量为1，费用为0的边。
    
    - 把最后一层的点与汇点连接一条容量无穷大，费用为0的边。
- 问题三
	- 问题三就是无限制。
    
	- 构图方法与“问题二”相似
    - 只要把每一个点与其斜下方的点所连接的边的容量修改为无穷大即可。
- 问题一、二、三只要在构图后跑一波最大费用最大流即可。（参考程序用了取相反数的方法）

### 【解题反思】
- 网络流的题目一定要观察出性质才能更加方便地解题。

### 【参考程序】
```cpp
#include<cstdio>
#include<queue>
#include<iostream>
#include<cstring>
using namespace std;

#define INF 0x3f3f3f3f
int cur=1,n,m,s,t,mcost,mflow;
int head[5005],dis[5005],flow[5005],pre[5005];
struct EDGE{
    int t,next,w,f;
}e[100005];
void add(int a,int b,int w,int f)
{
    cur++;e[cur].t=b;e[cur].next=head[a];e[cur].w=w;e[cur].f=f;head[a]=cur;
    cur++;e[cur].t=a;e[cur].next=head[b];e[cur].w=0;e[cur].f=-f;head[b]=cur;
}

queue < int > q;
bool vis[5005];
bool SPFA(int s,int t)
{
    memset(dis,INF,sizeof dis);
    memset(vis,0,sizeof vis);
    dis[s]=0;
    vis[s]=1;
    flow[s]=INF;
    q.push(s);
    while (!q.empty())
    {
        int u=q.front();q.pop();
        vis[u]=false;
        for (int h=head[u];h!=-1;h=e[h].next)
        {
            int v=e[h].t,f=e[h].f;
            if (e[h].w&&dis[u]+f<dis[v])//????????????
            {
                dis[v]=dis[u]+f;//??????
                flow[v]=min(flow[u],e[h].w);//??????
                pre[v]=h;//????
                if (!vis[v])
                {
                    vis[v]=true;
                    q.push(v);
                }
            }
        }
    }
    return dis[t]!=INF;
}

void Update(int s,int t)
{
    int x=t;
    while (x!=s)
    {
        int i=pre[x];
        e[i].w-=flow[t];
        e[i^1].w+=flow[t];
        x=e[i^1].t;
    }//??????????????
    mflow+=flow[t];
    mcost+=flow[t]*dis[t];//????
}
void E_K(int s,int t)
{
    while (SPFA(s,t))//????????
        Update(s,t);
}

int p[105][105],Map[105][105];
int id;

void Init()
{
	cur=1;
	memset(head,-1,sizeof head);
	memset(e,0,sizeof e);
	memset(flow,0,sizeof flow);
	memset(pre,0,sizeof pre);
	mflow=0;mcost=0;
}

#define nxt(x) (x+id)
void P1()
{
	Init();
	s=0;t=id*2+1;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m+i-1;j++)
		{
			add(p[i][j],nxt(p[i][j]),1,-Map[i][j]);
			if (p[i+1][j+1])
				add(nxt(p[i][j]),p[i+1][j+1],1,0);
			if (p[i+1][j])
				add(nxt(p[i][j]),p[i+1][j],1,0);
		}
	for (int i=1;i<=m;i++)
		add(s,p[1][i],1,0);
	for (int i=1;i<=m+n-1;i++)
		add(nxt(p[n][i]),t,1,0);
	E_K(s,t);
	printf("%d\n",-mcost);
}
void P2()
{
	Init();
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m+i-1;j++)
		{
			if (p[i+1][j+1])
				add(p[i][j],p[i+1][j+1],1,-Map[i][j]);
			if (p[i+1][j])
				add(p[i][j],p[i+1][j],1,-Map[i][j]);
		}
	for (int i=1;i<=m;i++)
		add(s,p[1][i],1,0);
	for (int i=1;i<=m+n-1;i++)
		add(p[n][i],t,INF,-Map[n][i]);
	E_K(s,t);
	printf("%d\n",-mcost);
}
void P3()
{
	Init();
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m+i-1;j++)
		{
			if (p[i+1][j+1])
				add(p[i][j],p[i+1][j+1],INF,-Map[i][j]);
			if (p[i+1][j])
				add(p[i][j],p[i+1][j],INF,-Map[i][j]);
		}
	for (int i=1;i<=m;i++)
		add(s,p[1][i],1,0);
	for (int i=1;i<=m+n-1;i++)
		add(p[n][i],t,INF,-Map[n][i]);
	E_K(s,t);
	printf("%d\n",-mcost);
}
int main()
{
    scanf("%d%d",&m,&n);
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=m+i-1;j++)
        {
        	scanf("%d",&Map[i][j]);
        	p[i][j]=++id;
        }
    }
    P1();
    P2();
    P3();
    return 0;
} 
```

---

## 作者：MloVtry (赞：2)

费用流多合一....

emm....~~还好没让输出路径呢HHH~~

part.1
不知道泥萌做没做过蚯蚓，完全一样呢

编个号，拆个点，假设分为a、b部吧

然后建立s，t1，t2

s-->(1,i)[a]    <1,0>

（s向第一排的a部点建边,容量为1，长度为0，下同）


```cpp
(i,j)[b]-->(toi,toj)[a]  <1,a[i][j]>
(i,j)[a]-->(i,j)[b]<1,0>
(n,i)[b]-->t1    <1,a[n][i]>
t1-->t2     <m,0>
```
来一发最大费用就行了
part.2
点可以重了....

方便起见~~为了粘贴~~

(i,j)[a]-->(i,j)[b]<inf,0>

岚后啊，其实坠后一层每个点也不只能用一次了

所以：

(n,i)-->t1    <inf,a[n][i]>

噗噗个噗

这样就行了

其实也就是不用拆点了

part.3
就是不能完全重复别的全能干了是吧...

然后你发现要搞m条

开头是确定的

那么建立s，t1，t2

s-->(1,i)[a]    <1,0>

别的容量全换成inf吧

就酱
代码

    
    
    
    
    
    
    
    
    
    
```cpp
#include<iostream>
#include<cstring>
#define inf 1<<30
#include<cstdio>
#define M 300000
#include<queue>
#define N 500
using namespace std;
int s,t1,t,n,m,ma[110][110],id[110][110],TT;
int head[N],from[M],to[M],Next[M],len[M],cup[M],e=1;
void buid(int u,int v,int c,int l)
{
    l*=-1;
    Next[++e]=head[u];head[u]=e;to[e]=v;
    len[e]=l;cup[e]=c;from[e]=u;
    Next[++e]=head[v];head[v]=e;to[e]=u;
    len[e]=-l;cup[e]=0;from[e]=v;
}
int dis[N],init[N],pre[N],mflow,mcost;
queue<int> q;
bool bfs()
{
    for(int i=s;i<=t;++i) dis[i]=inf;
    dis[s]=0;init[s]=1;q.push(s);
    while(!q.empty())
    {
        int now=q.front();q.pop();init[now]=0;
        for(int i=head[now];i;i=Next[i])
        {
            if(!cup[i]) continue;
            int j=to[i];
            if(dis[j]>dis[now]+len[i])
            {
                dis[j]=dis[now]+len[i];
                pre[j]=i;
                if(!init[j]) init[j]=1,q.push(j); 
            }
        }
    }
    return dis[t]!=inf;
}
void doit()
{
    int now=t,get=inf;
    while(now!=s)
    {
        get=min(get,cup[pre[now]]);
        now=from[pre[now]];
    }
    mflow+=get;mcost+=get*dis[t];
    now=t;
    while(now!=s)
    {
        cup[pre[now]]-=get;
        cup[pre[now]^1]+=get;
        now=from[pre[now]];
    }
}
void max_min()
{
    mcost=0;
    while(bfs()) doit();
}
int main()
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m+i-1;++j) id[i][j]=++TT;
    t1=2*TT+1;t=t1+1;
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m+i-1;++j) scanf("%d",&ma[i][j]);
    for(int i=1;i<=m;++i) buid(s,id[1][i],1,0);
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m+i-1;++j) buid(id[i][j],id[i][j]+TT,1,0);
    for(int i=1;i<=n+m-1;++i) buid(id[n][i]+TT,t1,1,ma[n][i]);
    for(int i=1;i<n;++i)
    for(int j=1;j<=i+m-1;++j)
    {
        for(int y=0;y<=1;++y)
        {
            int X=i+1,Y=j+y;
            buid(id[i][j]+TT,id[X][Y],1,ma[i][j]);
        }
    }
    buid(t1,t,m,0);
    max_min();
    printf("%d\n",-mcost);
    memset(head,0,sizeof(head));e=1;
    for(int i=1;i<=m;++i) buid(s,id[1][i],1,0);
    for(int i=1;i<=n+m-1;++i) buid(id[n][i],t1,inf,ma[n][i]);
    for(int i=1;i<n;++i)
    for(int j=1;j<=m+i-1;++j)
    {
        for(int y=0;y<=1;++y)
        {
            int X=i+1,Y=j+y;
            buid(id[i][j],id[X][Y],1,ma[i][j]);
        }
    }
    buid(t1,t,m,0);
    max_min();
    printf("%d\n",-mcost);
    memset(head,0,sizeof(head));e=1;
    for(int i=1;i<=m;++i) buid(s,id[1][i],1,0);
    for(int i=1;i<=n+m-1;++i) buid(id[n][i],t1,inf,ma[n][i]);
    for(int i=1;i<n;++i)
    for(int j=1;j<=m+i-1;++j)
    {
        for(int y=0;y<=1;++y)
        {
            int X=i+1,Y=j+y;
            buid(id[i][j],id[X][Y],inf,ma[i][j]);
        }
    }
    buid(t1,t,m,0);
    max_min();
    printf("%d\n",-mcost);
    return 0;
}
```

---

## 作者：jun头吉吉 (赞：1)

# P4013 数字梯形问题
[$My \ Blog$](https://chen-jia-liang.gitee.io/blog/2020/07/16/%E9%A2%98%E8%A7%A3-P4013-%E3%80%90%E6%95%B0%E5%AD%97%E6%A2%AF%E5%BD%A2%E9%97%AE%E9%A2%98%E3%80%91/)
## 题意
有一个数字梯形，一共$n$行，第一行有$m$个，每一行比上一行多一个，每个数可以到**左下或右下**的数字，从顶层出发，给出以下限制：

1. 从梯形的顶至底的 $m$ 条路径互不相交；

2. 从梯形的顶至底的 $m$ 条路径仅在数字结点处相交；

3. 从梯形的顶至底的 $m$ 条路径允许在数字结点相交或边相交。

请求出三种限制下的**最大数字总和**
## 题解

![ZZY AK IOI](https://cdn.luogu.com.cn/upload/image_hosting/8a7fmo0q.png)
### 子问题$1$
我们先来看问题$ 1$，由于**路径互不相交**，也就是说，**每条路径只能经过一次，每个点只能经过一次**。这像什么？费用流中流量的限制呀！

所以，我们可以把所有的边的流量设置成一，所有的点都拆成两个**入点**和**出点**，入点和出点流量为$1$，费用为数字。如果有流流过，就意味着取这个数，并加上其费用。

然后我们建一个**超级源点**，与梯形顶部的点相连，梯形底部的点与**超级汇点**相连，跑最大费用最大流时，保证了流量一定是$m$的情况下，和最大。

### 子问题$2$
来思考问题$ 2$与$ 1$的区别。由于**路径仅在数字结点处相交**，也就等价于着**每个结点无访问次数的限制**，那么我们把问题$ 1$中拆点时的流量改成$+\infty$就行了

~~其实完全可以不拆点~~
### 子问题$3$
相比问题$2$，$3$的限制就更少了，把边上的流量也全部改成$+\infty$就行了

>
```plain
tip
跑费用流时可以套最小费用最大流的模板
把所有的费用乘以-1就行了
```

## 代码
```cpp
#pragma optimize(2)
#include<bits/stdc++.h>
using namespace std;
template<typename T>
inline void read(T &x){
	x=0;char c=getchar();bool f=false;
	for(;!isdigit(c);c=getchar())f!=c=='-';
	for(;isdigit(c);c=getchar())x=x*10+c-'0';
	if(f)x=-x;
}
template<typename T ,typename ...Arg>
inline void read(T &x,Arg &...args){
	read(x);read(args...);
}
template<typename T>
inline void write(T x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)write(x/10);
	putchar(x%10+'0');
}
const int maxn=100005;
const int maxe=100005;
struct Graph{
	int s,t;
	int dis[maxn],pre[maxn],lste[maxn],flow[maxn];
	bool inq[maxn];
	struct node{
		int v,w,cost,nxt;
		node(int _v=0,int _w=0,int _c=0,int _n=0){v=_v,w=_w,cost=_c,nxt=_n;}
	}e[maxe];
	int tot,head[maxn];
	void init(int _s,int _t){
		memset(head,0,sizeof head);
		tot=1;s=_s,t=_t;
	}
	inline void add(int u,int v,int w,int c){
		e[++tot]=node(v,w,c,head[u]);head[u]=tot;
		e[++tot]=node(u,0,-c,head[v]);head[v]=tot;
	}
	bool spfa(){
		queue<int>q;
		memset(dis,63,sizeof dis);
		memset(flow,63,sizeof flow);
		memset(inq,0,sizeof inq);
		dis[s]=0,pre[t]=-1;q.push(s);
		while(!q.empty()){
			int u=q.front();q.pop();inq[u]=0;
			#define v e[i].v
			for(int i=head[u];i;i=e[i].nxt){
				if(e[i].w>0&&dis[v]>dis[u]+e[i].cost){
					dis[v]=dis[u]+e[i].cost;
					pre[v]=u,lste[v]=i;//lste 表示顶点v是由哪条边过来的
					flow[v]=min(flow[u],e[i].w);
					if(!inq[v])inq[v]=1,q.push(v);
				}
			}
			#undef v
		}
		return pre[t]!=-1;
	}
	pair<int,int> mcmf(){
		int mincost=0,maxflow=0;
		while(spfa()){
			int u=t;
			maxflow+=flow[t],mincost+=flow[t]*dis[t];
			while(u!=s){
				int E=lste[u];
				e[E].w-=flow[t],e[E^1].w+=flow[t];
				u=pre[u];
			}
		}
		return make_pair(mincost,maxflow);
	}
}G;
int m,n,cnt=0;
int id[1000][1000];
int a[1000][1000];
signed main(){
	read(m,n);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m+i-1;j++){
			id[i][j]=++cnt;
			read(a[i][j]);
		}
	G.init(0,cnt*2+1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m+i-1;j++){
			G.add(id[i][j],id[i][j]+cnt,1,-a[i][j]);
			if(i!=n)G.add(id[i][j]+cnt,id[i+1][j],1,0),
			        G.add(id[i][j]+cnt,id[i+1][j+1],1,0);
			else G.add(id[i][j]+cnt,G.t,1,0);
		}
	for(int i=1;i<=m;i++)
		G.add(G.s,id[1][i],1,0);
	write(-G.mcmf().first);putchar('\n');
	
	
	G.init(0,cnt*2+1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m+i-1;j++){
			G.add(id[i][j],id[i][j]+cnt,1e9,-a[i][j]);
			if(i!=n)G.add(id[i][j]+cnt,id[i+1][j],1,0),
			        G.add(id[i][j]+cnt,id[i+1][j+1],1,0);
			else G.add(id[i][j]+cnt,G.t,1e9,0);
		}
	for(int i=1;i<=m;i++)
		G.add(G.s,id[1][i],1,0);
	write(-G.mcmf().first);putchar('\n');
	
	G.init(0,cnt*2+1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m+i-1;j++){
			G.add(id[i][j],id[i][j]+cnt,1e9,-a[i][j]);
			if(i!=n)G.add(id[i][j]+cnt,id[i+1][j],1e9,0),
			        G.add(id[i][j]+cnt,id[i+1][j+1],1e9,0);
			else G.add(id[i][j]+cnt,G.t,1e9,0);
		}
	for(int i=1;i<=m;i++)
		G.add(G.s,id[1][i],1,0);
	write(-G.mcmf().first);putchar('\n');
}
```

---

## 作者：盧鋅 (赞：0)

看到队长发了题解，萌新我也想写一篇。

对于次数限制的问题，我们通常考虑拆点，然后~~此题完~~

没错就是这么简单

一共有三问，都可以用拆点的思想（~~第三问好像没必要~~）

### 第一问：

我们把拆点和原点连接一条流量为1（表次数限制），费用为-点值（表示费用），然后按照题意连边即可。

### 第二问：

将第一问拆点和原点的连边流量改为inf（表无次数限制）。
同时需要注意最下边一行的点，连接汇点T的边流量也要改为inf。

### 第三问：

除了源点向第一行的点的连边流量为1外，其他的流量为inf（表无次数限制）

### 安利奇葩做法：
- 一个非常蠢的操作：对于任何拆点问题我们考虑这么个做法，直接给每个点打id。（这个题大家都在用，但有的题采用计算，其实没必要计算，空间换时间不香吗？）
- 我们考虑一个类似线段树的方法，用ls，rs来标记拆点。
- 上述方法的优越性，永远不用考虑计算过程，源点S和汇点T可以直接表示为ls(0),rs(0)。（此方法也适用于多个拆点的题）
- ~~网络流空间瞎开就行，只要不小不MLE~~

## 代码：

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cctype>
#include <cmath>
#include <queue>
using namespace std;
#define I inline
#define R register
#define inf 1073742823
#define FOR(i,begin,end) for(R int i=begin;i<=end;++i)
#define ROF(i,begin,end) for(R int i=begin;i>=end;--i)

namespace IO{
    char buf[1<<21],*pa=buf,*pb=buf;
    char buffer[1<<21];int p1=-1;const int p2=(1<<21)-1; 
    I char gc(){return pa==pb&&(pb=(pa=buf)+fread(buf,1,1<<21,stdin),pa==pb)?EOF:*pa++;}
    template<class T>I void read(T &x){
        x=0;R int y=0;R char ch=gc();
        for(;!isdigit(ch);ch=gc())y=ch=='-';
        for(;isdigit(ch);ch=gc())x=x*10+(ch^48);
        (y)&&(x=-x);return;}
    I void flush(){fwrite(buffer,1,p1+1,stdout);p1=-1;return;}
    I void pc(int ch){if(p1==p2)flush();buffer[++p1]=ch;return;}
    template<class T>I void write(T x){
        static char buf[20];static int len =-1;
        if(x>=0){do buf[++len]=(x%10)^48,x/=10;while(x);}
        else{pc('-');do buf[++len]=(-(x%10))^48,x/=10;while(x);}
        while(len>=0)pc(buf[len--]);
        return;}
}
using namespace IO;

const int maxn = 50000+500;
const int maxm = 2000000+2000;
#define ci const int &

struct edge{
    int u,v,f,w,n;
    I edge(ci uu=0,ci vv=0,ci ff=0,ci ww=0,ci nn=0):u(uu),v(vv),f(ff),w(ww),n(nn){}
}e[maxm];
int dis[maxn],vis[maxn],cur[maxn],head[maxn],cnt=1,n,m,s,t;
int cost=0,flow=0;
I void add(ci u,ci v,ci f,ci w){
    e[++cnt]=edge(u,v,f,w,head[u]),head[u]=cnt;
    e[++cnt]=edge(v,u,0,-w,head[v]),head[v]=cnt;
}
I bool spfa(ci s,ci t){
    memset(vis,0,sizeof vis);
    memset(dis,0x3f,sizeof dis);
    deque<int>q;q.push_front(t);
    vis[t]=1,dis[t]=0;
    while(!q.empty()){
        int u=q.front();q.pop_front();
        for(int ee=head[u],v;v=e[ee].v,ee;ee=e[ee].n)
            if(e[ee^1].f>0&&dis[v]>dis[u]-e[ee].w){
                dis[v]=dis[u]-e[ee].w;
                if(!vis[v])vis[v]=1,(!q.empty()&&dis[q.front()]>dis[v])?
                q.push_front(v):
                q.push_back(v);
            }
        vis[u]=0;
    }
    return dis[s]==0x3f3f3f3f?0:1;
}
int dfs(ci u,ci ff){
    if(u==t)return vis[t]=1,ff;
    int us=0,f;vis[u]=1;
    for(int ee=cur[u],v;cur[u]=ee,v=e[ee].v,ee;ee=e[ee].n)
        if(vis[v]==0&&e[ee].f>0&&dis[u]-e[ee].w==dis[v]){
            if((f=dfs(v,min(e[ee].f,ff-us)))>0)
                cost+=f*e[ee].w,e[ee].f-=f,e[ee^1].f+=f,us+=f;
            if(us==ff)break;
        }
    return us;
}
I void cost_flow(){
    while(spfa(s,t)){
        vis[t]=1;
        while(vis[t]){
            memcpy(cur,head,sizeof head);
            memset(vis,0,sizeof vis);
            flow+=dfs(s,inf);
        }
    }
}
I void clear(){
    memset(head,0,sizeof head);
    memset(e,0,sizeof e);
    cnt=1;cost=0,flow=0;
}
#define ls(o) (o<<1)
#define rs(o) (o<<1|1)
int a[50][50],id[50][50];
signed main(){
    s=ls(0),t=rs(0);
    int tot=0;
    read(m),read(n);
    FOR(i,m,m+n-1)
        FOR(j,1,i)
            read(a[i][j]),id[i][j]=++tot;
    // work 1
    FOR(i,1,m)
        add(s,ls(id[m][i]),1,0);
    FOR(i,m,m+n-1)
        FOR(j,1,i)
            add(ls(id[i][j]),rs(id[i][j]),1,-a[i][j]);
    FOR(i,m,m+n-2)
        FOR(j,1,i)
            add(rs(id[i][j]),ls(id[i+1][j]),1,0),
            add(rs(id[i][j]),ls(id[i+1][j+1]),1,0);
    FOR(i,1,m+n-1)
        add(rs(id[m+n-1][i]),t,1,0);
    cost_flow();
    write(-cost),pc('\n');
    // work 2
    clear();
    FOR(i,1,m)
        add(s,ls(id[m][i]),1,0);
    FOR(i,m,m+n-1)
        FOR(j,1,i)
            add(ls(id[i][j]),rs(id[i][j]),inf,-a[i][j]);
    FOR(i,m,m+n-2)
        FOR(j,1,i)
            add(rs(id[i][j]),ls(id[i+1][j]),1,0),
            add(rs(id[i][j]),ls(id[i+1][j+1]),1,0);
    FOR(i,1,m+n-1)
        add(rs(id[m+n-1][i]),t,1,0);
    cost_flow();
    write(-cost),pc('\n');
    // work 3
    clear();
    FOR(i,1,m)
        add(s,ls(id[m][i]),1,0);
    FOR(i,m,m+n-1)
        FOR(j,1,i)
            add(ls(id[i][j]),rs(id[i][j]),inf,-a[i][j]);
    FOR(i,m,m+n-2)
        FOR(j,1,i)
            add(rs(id[i][j]),ls(id[i+1][j]),inf,0),
            add(rs(id[i][j]),ls(id[i+1][j+1]),inf,0);
    FOR(i,1,m+n-1)
        add(rs(id[m+n-1][i]),t,inf,0);
    cost_flow();
    write(-cost),pc('\n');
    flush();
    return 0;
}
```


---

## 作者：zzw4257 (赞：0)

### 题意
>给出一个$n$层分别为$m,m+1,\cdots,m+n-1$个数的梯形,分别求

>- 从梯形的顶至底的$m$条路径互不相交。
- 从梯形的顶至底的$m$条路径仅在数字结点处相交。
- 从梯形的顶至底的$m$条路径允许在数字结点相交或边相交。
这些路径的最大和

### Solution
首先拆点$((x,y),(x,y)')$

$(S,(1,i),1,0)$从第一行出发

对点

$((x,y),(x,y)',$点可以被走多少次,$v_{x,y})$

对边

$((x,y)',(x+1,y),$边可以被走多少次$,0)$

$((x,y)',(x+1,y+1),$边可以被走多少次$,0)$

$((n,i)',T,INF,0)$结束


### Code
```cpp
inline void Build(re int x,re int y){
	re int i,j;cnt=1,memset(h,0,P<<2);
	for(i=1;i<=m;++i)AddEdge(S,(pos(1,i)<<1)-1,1,0);
	for(i=1;i<n;++i){
		for(j=1;j<=i+m-1;++j){
			AddEdge((pos(i,j)<<1)-1,pos(i,j)<<1,x,v[i][j]);
			AddEdge(pos(i,j)<<1,(pos(i+1,j)<<1)-1,y,0);
			AddEdge(pos(i,j)<<1,(pos(i+1,j+1)<<1)-1,y,0);
		}
	}
	for(i=1;i<=n+m-1;++i)AddEdge(pos(n,i)<<1,T,INF,0),AddEdge((pos(n,i)<<1)-1,pos(n,i)<<1,x,v[n][i]);
}
inline void Solve(void){
	Build(1,1),Dinic(),printf("%d\n",ansc);
	Build(INF,1),Dinic(),printf("%d\n",ansc);
	Build(INF,INF),Dinic(),printf("%d\n",ansc);
}
```

---

## 作者：吾王美如画 (赞：0)

# 唔姆
~~这应该算一道比较简单的费用流的题~~，只是有几个坑需要大家注意，且听我慢慢说来

------------
首先看题，有费用，还有限制，这应该就是费用流无疑了，接着我们考虑如何建图
- 题目说要找m条边，但注意，这m条边必须是**分别从第一层的m个点出发的**（~~我就是因为这个改了半天~~）根据这个我们从原点向第一层的点连一条容量为1费用为0的边，最后一层向汇点连一条容量为无限（当然，第一问的时候你可以把容量设为1）费用为0的边。
- 对于第一问，要求所有线不相交，我们可以很容易证明，只要点不相交，边更不会相交。所有把一个点拆成入点和出点，中间连一条容量为1费用为这个数的边。然后把上一层的出点向下一层的入点连上一条容量为1费用为0的边
- 对于第二问，要求只有点相交，我们只需把第一问的图中一个点的入点和出点之间的边的容量改成无限，但不用改费用，因为**题中并没说一个数只能取一次**（~~我因为这个又改了半天~~
- 对于第三问，只需把第二问的图中的层与层之间边的容量改为无限就好了

最后对于每一问，我们跑个最大费用最大流就好了

~~代码巨丑，请见谅~~

```cpp
#include<queue>
#include<cstdio>
#include<iostream>
#include<cstring>
#define MAXM 100010
#define MAXN 6010
using namespace std;
int to[MAXM],next[MAXM],w[MAXM],cost[MAXM],head[MAXN];
int n,m,S,T,ansl=0,ansc=0;
int cnt=-1;
int pre1[MAXN],pre2[MAXN],low[MAXN],dis[MAXN];
void link(int a,int b,int c,int d){
     cnt++;
     next[cnt]=head[a];
     w[cnt]=c;
     cost[cnt]=d;
     to[cnt]=b;
     head[a]=cnt;
     cnt++;
     next[cnt]=head[b];
     w[cnt]=0;
     cost[cnt]=-d;
     to[cnt]=a;
     head[b]=cnt;
}
bool spfa(){
     queue<int>q;
     fill(dis,dis+MAXN,-66666666);
     int vis[MAXN];
     memset(vis,0,sizeof(vis));
     q.push(S);
     dis[S]=0;
     vis[S]=1;
     low[S]=66666666;
     while(!q.empty()){
                       int now=q.front();
                       vis[now]=0;
                       q.pop();
                       for(int i=head[now];i!=-1;i=next[i]){
                               if (w[i]>0&&cost[i]+dis[now]>dis[to[i]]){
                                                                        dis[to[i]]=dis[now]+cost[i];
                                                                        low[to[i]]=min(low[now],w[i]);
                                                                        pre1[to[i]]=now;
                                                                        pre2[to[i]]=i;
                                                                        if (!vis[to[i]]){
                                                                                         vis[to[i]]=1;
                                                                                         q.push(to[i]);
                                                                        }
                               }
                       }
     }
     return dis[T]!=-66666666;
}
void work(){
     while(spfa()){
                   int now=T;
                   while(now!=S){
                                 int y=pre2[now];
                                 w[y]-=low[T];
                                 w[y^1]+=low[T];
                                 now=pre1[now];
                   }
                   ansl+=low[T];
                   ansc+=low[T]*dis[T];
     }
}
int tu[50][50];
int num(int a,int b){
    return (a-1)*50+b;
}
int main(){
    memset(head,-1,sizeof(head));
    cin>>m>>n;
    S=0;T=MAXN-1;
    for(int i=1;i<=n;i++){
            for(int j=1;j<m+i;j++){
                    scanf("%d",&tu[i][j]);
            }
    }
    for(int i=1;i<=n;i++){
            for(int j=1;j<i+m;j++){
                    if (i==1)link(S,num(i,j),1,0);
                    link(num(i,j),num(i,j)+3000,1,tu[i][j]);
                    if (i==n)link(num(i,j)+3000,T,1,0);
                    else {link(num(i,j)+3000,num(i+1,j),1,0);link(num(i,j)+3000,num(i+1,j+1),1,0);};
            }
    }
    work();
    cout<<ansc<<endl;
    ansc=0;
    memset(head,-1,sizeof(head));
    for(int i=1;i<=n;i++){
            for(int j=1;j<i+m;j++){
                    if (i==1)link(S,num(i,j),1,0);
                    link(num(i,j),num(i,j)+3000,MAXN,tu[i][j]);
                    if (i==n)link(num(i,j)+3000,T,m,0);
                    else {link(num(i,j)+3000,num(i+1,j),1,0);link(num(i,j)+3000,num(i+1,j+1),1,0);};
            }
    }
    work();
    cout<<ansc<<endl;
    ansc=0;
    memset(head,-1,sizeof(head));
    for(int i=1;i<=n;i++){
            for(int j=1;j<i+m;j++){
                    if (i==1)link(S,num(i,j),1,0);
                    link(num(i,j),num(i,j)+3000,MAXN,tu[i][j]);
                    if (i==n)link(num(i,j)+3000,T,m,0);
                    else {link(num(i,j)+3000,num(i+1,j),MAXN,0);link(num(i,j)+3000,num(i+1,j+1),MAXN,0);};
            }
    }
    work();
    cout<<ansc<<endl;
    return 0;
}

```

---


# 洞穴遇险

## 题目背景

**ZRQ**在洞穴中准备采集矿物的时候遇险了！洞穴**要塌了**！

题目来源：[zhoutb2333](https://www.luogu.org/space/show?uid=31564)


## 题目描述

整个洞穴是一个$N*N$的方格图，每个格子形如$(X,Y),1 \le X,Y \le N$。其中$X$表示从上到下的行数，$Y$表示从左到右的列数。$(1,1)$在左上角,$(1,N)$在右上角，$(N,1)$在左下角，$(N,N)$在右下角。


满足$X+Y$为奇数格子的有一个不稳定度$V_{X,Y},X+Y$为偶数的格子的不稳定度为$0$。


**ZRQ**现在手里恰巧有$M$个可以支撑洞穴的柱子，柱子的力量可以认为是无穷大。


只要支撑住了一个格子那么这个格子的不稳定度将降为$0$。


每个柱子是$L$型的，它除了要占据当前的格子外，还需要占据两个相邻的格子（这三个格子形成$L$型,可以选择任意方向放置，一共有$4$个方向）。



 ![](https://cdn.luogu.com.cn/upload/pic/13049.png) 

**柱子占据相邻的格子不会降低其不稳定度（换句话说就是柱子只有在拐角处有力量）**。


有些格子的顶已经塌下来了，无法在其位置放置柱子了，这些格子也不能被占据了。这样已经塌了的格子有$K$个（他们的不稳定度都为$0$,**即使$X+Y$为奇数，塌下来的格子的不稳定度也会为$0$**）。


**ZRQ**想问你，在放置一些柱子后 ，最小的不稳定度之和为多少（可以不将$M$个柱子都放完）。


## 说明/提示

共$10$个测试点，每个点$10$分，计$100$分。


对于测试点$1$~$3$，有$1 \le N \le 6$


对于测试点$4$~$7$，有$1 \le N \le 11$


对于测试点$8$~$10$，有$1 \le N \le 50$


对于所有测试点，$0 \le M \le \frac{N^2}{3}, 0 \le K \le N^2, 0 \le V_{X,Y} \le 10^6$


**样例#1解释：**

显然无法让任意两个不稳定的格子都被拐角覆盖，于是将$(2,1)$用拐角覆盖住即可。这样剩余的不稳定度为$V_{1,2}+V_{2,3}+V_{3,2}=1+1+1=3$。

**样例#2解释：**

一个都放不下，这样剩余的不稳定度为$V_{1,2}+V_{2,3}+V_{3,2}=2+4+3=9$。


## 样例 #1

### 输入

```
3 3 1
0 1 0
2 0 1
0 1 0
1 3```

### 输出

```
3```

## 样例 #2

### 输入

```
3 3 4
0 2 0
0 0 4
0 3 0
1 3
2 1
2 2
3 1```

### 输出

```
9```

# 题解

## 作者：zhoutb2333 (赞：13)

暴力搜索预期得分$30$分左右。

状压预期得分$70$分左右。

考虑费用流，将剩余不稳定度和最小转为消除不稳定度和最大。

首先**拐角处只能放在有不稳定度的格子上**：如果它的拐角处放在了$X+Y$为偶数的格子上，那么它不仅没有减少不稳定度，而且还占地。这个贪心显然正确。

那么黑白染色，$X+Y$为偶数的点分一类，为奇数的分一类。将$L$形柱子抽象成两个非拐角处的格子的路径（这两个格子的$X+Y$都为偶数，拐角处的第三个格子的$X+Y$为奇数）。**那么这两个格子肯定一个在奇数列一个在偶数列**，证明显然。

于是建图：

- 一共有四列点。

- X+Y为偶数的点再分为两类：奇数列的和偶数列的。

- 奇数列的点放在左边（第一列），源点向每个点连一条容量为1，费用为0的边。

- 偶数列的点放在右边（第四列），每个点向汇点连一条容量为1，费用为0的边。

- X+Y为奇数的点每个点拆开，一分为二，分别放在第二列和第三列。第二列的每个点向第三列的自己连一条容量为1，费用为负的该点的权值（不稳定度）。

- 如果第一列（X+Y为偶数，奇数列的点）和第二列的点相邻，连一条容量为1，费用为0的边，第三、四列同理。

- 当然塌了的格子不能连边。


跑一遍最小费用最大流即可。这样建图每次增广的流都肯定为$1$，所以可以在最大流为$M$的时候直接跳出。期望得分$40$分。

（？？？）

因为这样是错的，

``` plain
4 4 6
0 1 0 1000
0 0 0 0
0 1 0 1
0 0 0 0
1 1
2 1
2 3
4 1
4 3
4 4
```
就是一个构造的反例。**我们不能先保证总流量最大再保证总费用最小，而是要尽可能地让总费用最小。也就是说我们要把柱子用在刀刃上，而不是放越多越好**。于是想到如果本次增广源点到汇点的费用为正，直接跳出即可。（我的构造方式是连负费用边，如果连正权边跑最长路那么费用为负跳出即可）

**彩蛋：**

额，我不太会构造这样的数据，就把这一小片乘以1000贴在后面每个数据的左上角了。所以这么写也可以AC：printf("%d\n",sum+mincost-998000);

额我在说什么...


这样就可以$100$分，复杂度$O($费用流$)$。

``` cpp
#include<bits/stdc++.h>
#define maxn 105
#define maxe 100010
#define INF 1<<30
using namespace std;

int head[maxe],nxt[maxe],point[maxe],flow[maxe],val[maxe],tot=1;
int pre[maxe],preedge[maxe],tmpflow[maxe],dis[maxe],s=0,t=100000,E,ofs=25000;
int v[maxn][maxn],sum,n,m,k;
bool in[maxe];
queue<int> q;
int get(int x,int y,int lvl){
    return (x-1)*n+y+ofs*lvl;
}
bool chk(int num){
    num%=ofs;
    int x=(num-1)/n+1,y=(num-1)%n+1;
    if(x<1||y<1||x>n||y>n||v[x][y]==-1)
        return false;
    return true; 
}
void ADD(int x,int y,int f,int c){
    val[++tot]=c;
    flow[tot]=f;
    point[tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
}
void add(int x,int y,int f,int c){
    if((x!=s&&x!=t&&!chk(x))||(y!=s&&y!=t&&!chk(y)))
        return;
    ADD(x,y,f,c),ADD(y,x,0,-c);
}
bool bfs(){
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0,in[s]=true,q.push(s),tmpflow[s]=m;
    while(!q.empty()){
        int x=q.front();
        in[x]=false;
        q.pop();
        for(int j=head[x];j;j=nxt[j]){
            if(!flow[j]||dis[point[j]]<=dis[x]+val[j])
                continue;
            dis[point[j]]=dis[x]+val[j];
            pre[point[j]]=x;
            preedge[point[j]]=j;
            tmpflow[point[j]]=min(tmpflow[x],flow[j]);
            if(!in[point[j]])
                in[point[j]]=true,q.push(point[j]);
        }
    }
    return dis[t]!=0x3f3f3f3f;
}
int main(){
    int x,y,mincost=0;
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            scanf("%d",&v[i][j]),sum+=v[i][j];
    for(int i=1;i<=k;i++)
        scanf("%d%d",&x,&y),v[x][y]=-1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            if((i+j)%2)
                add(get(i,j,1),get(i,j,2),1,-v[i][j]);
            else{
                if(j%2){
                    add(s,get(i,j,0),1,0);
                    add(get(i,j,0),get(i,j-1,1),1,0);
                    add(get(i,j,0),get(i,j+1,1),1,0);
                    add(get(i,j,0),get(i-1,j,1),1,0);
                    add(get(i,j,0),get(i+1,j,1),1,0);
                }
                else{
                    add(get(i,j,3),t,1,0);
                    add(get(i,j-1,2),get(i,j,3),1,0);
                    add(get(i,j+1,2),get(i,j,3),1,0);
                    add(get(i-1,j,2),get(i,j,3),1,0);
                    add(get(i+1,j,2),get(i,j,3),1,0);
                }
            }
        }
    while(bfs()&&m){
        if(dis[t]>0)
            break;
        int k=t;
        while(k!=s){
            flow[preedge[k]]-=tmpflow[t];
            flow[preedge[k]^1]+=tmpflow[t];
            k=pre[k];
        }
        m-=tmpflow[t];
        mincost+=dis[t]*tmpflow[t];
    }
    printf("%d\n",sum+mincost);
    return 0; 
} 
```

---

## 作者：issue_is_fw (赞：1)

~~我太菜了,看完题完全没思路,还是抄的题解..~~

---

读完题发现拐角处一定放在$i+j$为奇数的地方

所以可以想办法转化为$3个格子凑成L形状权值的最大值$(因为要减去最多嘛)

然后就有一些性质了

当确定某个格子$(i,j)$作为拐角放置

为了构成$L$形状,还需要覆盖$2$个格子

可以是上左,上右,下左,下右

$发现这4个格子的i+j都是偶数$

$那我们可以根据二分图对i+j的奇偶性染色$

**但这样不够**

$构成L形,相当于有一条路径从L的一端出发经过拐点到达另一个格子$

$价值是拐点的点权$

$现在问题来了,L的两段i+j都是偶数,但他们又需要满足能彼此匹配$

$可以发现,L两段虽然i+j都是偶数,但所处的j一个是奇数,一个是偶数$

所以至此就把点分成了$3$类

$L$的构成可以看作从奇数列的偶数格子出发经过拐点到达偶数列的偶数格子

这样就可以构成一个三分图(也可以说四分图,因为拐点要被拆点了)

$i+j为奇数的拐点拆为i和i',i向i'连一条流量1,费用为点权的边$

$然后对于偶数格子,只能向部分相邻格子连边,比如$

$源点s连向奇数列的偶数格子,奇数列的偶数格子连向拐点的i$

$i'连向偶数列的偶数格子,偶数列的偶数格子连向汇点t$

(无特别说明,流量都是1,费用都是0)

```
#include <bits/stdc++.h>
using namespace std;
const int maxn=50009;
const int inf=1e9;
#define id(x,y) (x-1)*n+y
int a[509][509];
int n,m,s,t,k;
int maxflow,mincost;
int dis[maxn],head[maxn<<1],cnt=1,flow[maxn],pre[maxn],vis[maxn];
struct edge{
	int to,nxt,w,flow;//分别代表 
}d[maxn<<1];
void add(int u,int v,int flow,int w)//最大流量,单位费用
{
	d[++cnt]=(edge){v,head[u],w,flow},head[u]=cnt;
	d[++cnt]=(edge){u,head[v],-w,0},head[v]=cnt;
} 
bool spfa()
{
	queue<int>q;
	for(int i=0;i<=t;i++)	dis[i]=inf;
	memset(vis,0,sizeof(vis));
	q.push(s);
	dis[s]=0,vis[s]=1;
	flow[s] = inf;//初始流量无限大
	while( !q.empty() )
	{
		int u=q.front(); q.pop();
		vis[u]=0;//出队
		for(int i=head[u];i;i=d[i].nxt)
		{
			if( !d[i].flow )	continue;//无流量了	
			int v=d[i].to;
			if( dis[v]>dis[u]+d[i].w )
			{
				dis[v]=dis[u]+d[i].w;
				flow[v] = min(flow[u],d[i].flow);//更新当前流量
				pre[v]=i;//记录从哪条边过来的
				if( !vis[v] )	vis[v]=1,q.push(v); 
			}
		}	
	} 
	if( dis[t]==inf )	return 0;
	return 1;
}
int x[5]={0,0,1,-1},y[5]={1,-1,0,0};
int main()
{
	cin >> n >> m >> k;
	int sumn=0;
	s=0,t=n*n*2+1;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
		cin >> a[i][j],sumn+=a[i][j];
	for(int i=1;i<=k;i++)
	{
		int l,r; cin >> l >> r;
		a[l][r]=-1;
	}
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	{
		if( a[i][j]==-1 )	continue;
		if( (i+j)%2 )//奇数格子
			add( id(i,j),id(i,j)+n*n,1,-a[i][j] );
		else//偶数格子 
		{
			if( j%2==1 )//奇数列
			{
				add(s,id(i,j),1,0);
				for(int q=0;q<4;q++)
				{
					int nx=i+x[q],ny=j+y[q];
					if( nx<1||nx>n||ny<1||ny>n )	continue;
					if( a[nx][ny]==-1 )	continue;
					add(id(i,j),id(nx,ny),1,0);
				}
			}
			else
			{
				add(id(i,j),t,1,0);	
				for(int q=0;q<4;q++)
				{
					int nx=i+x[q],ny=j+y[q];
					if( nx<1||nx>n||ny<1||ny>n )	continue;
					if( a[nx][ny]==-1 )	continue;
					add(id(nx,ny)+n*n,id(i,j),1,0);
				}
			} 
		} 
	}
	while( spfa()&&m )
	{
		if( dis[t]>0 )	break;
		int i,x=t;
		while( x!=s )
		{
			i=pre[x];
			d[i].flow-=flow[t],d[i^1].flow+=flow[t];
			x=d[i^1].to;
		}
		m-=flow[t];
		mincost+=dis[t]*flow[t];
	}
	cout << sumn+mincost;
}
```

---

## 作者：Pwtking (赞：0)

[传送门](https://www.luogu.com.cn/problem/P4142)

主要思想：**拆点，黑白染色**。


首先能想到的是只在 $x+y$ 为奇数的格子上放柱子，原因显然。

接下来转化题意：求最小不稳定数不就是求放柱子能减少的最大不稳定数，于是我们现在着力**解决放柱子能减少的最大不稳定数**。

题目已经暗示我们要黑白染色，于是网格点被染为两类： $x+y$ 为奇数（我们称为黑点）和 $x+y$ 为偶数（我们称为白点）。

于是想到一个错误但能为正解提供思路的想法：

- 我们考虑类似二分图匹配的方式：因为每个偶数格子只能被选一次，所以将源点向每个黑点连边。在将每个能放柱子的黑点向每个与他相邻白点连边，再将每个白点向汇点连边。但是因为每个黑点上的柱子只会占用他相邻的两个柱子，所以将黑点拆点作为入点和出点，将黑点的入点与出点之间连容量为 $2$ 的边代表每个黑点只会占用他相邻的两个白点。

这个做法看似很对，但是有个很显然的问题：无法保证它占用的连个白点位置是否满足形状要求，于是这个做法陷入僵局了。

但我们只需要在此基础上满足最后图形形状限制就好了，怎么做呢？

既然我们将黑点拆点满足了黑点只能占两个白点的限制，那我们考虑用类似的方法也满足白点限制就行了。但显然拆点是无能为力了，**观察到每个黑点只会占用相邻的两个处于不同奇偶性列数的白点**，于是我们试试黑白染色：**我们再将处于奇数列白点染为灰色，否则仍为白点**。

这时我们可以将灰点连向黑点，再将黑点连向白点，容量为 $1$。只不过此时我们黑点入点与出点之间的边容量需要改为 $1$；将源点向汇点连边，将白点向汇点连边。

总结：

1. 将源点向每个灰点连费用 $0$ 容量 $1$ 的边代表每个灰点只能选一次。

2. 将灰点向他每个相邻的黑点的入点连费用 $0$ 容量 $1$ 的边代表每个灰点只能匹配一个黑点。

3. 将黑点的入点和出点之间连费用 $w_{x,y}$ 容量 $1$ 的边代表每个黑点只能选一次且费用为该点权值（$(x,y)$ 为该点坐标）。

4. 将黑点出点向他每个相邻的白点连费用 $0$ 容量 $1$ 的边代表每个黑点只会占用一个白点。

5. 最后将白点向汇点连费用 $0$ 容量 $1$ 的边代表每个白点只选一次。

以上连边均不包含已经坍塌的点。

---

## 作者：yizhiming (赞：0)

原来 $m$ 有限制的啊（

[Link](https://www.luogu.com.cn/problem/P4142)

## 题目大意

给定一个 $n\times n$ 的矩形，其中行列和为奇数的位置有点权 $V_{i,j}$，你可以放置 $m$ 个拐角型的柱子，柱子共占三个格子，并且会将拐角所在的格子的数变成 $0$，有 $k$ 个格子塌了，既不能放柱子也不能被其他柱子覆盖，问所有格子的总和最少是多少。

$1\leq n \leq 50,0\leq m \leq \frac{n^2}{3},0\leq k \leq n^2,0\leq V_{i,j}\leq 10^6$。

## 题目分析

看到数据范围，猜个网络流（

我们下述称行列和为奇数的格子为一类格子，反之称为二类格子。

不难发现对于一个一类格子想要消掉其点权，需要至少匹配两个二类格子，这很像一个匹配问题，所以大胆假设将这两类格子分开相互连边。

但是不难发现一个问题，若中间放一类格子，两边放二类格子，会出现一个经典的错误，就是某个二类格子在连源点的那边用过了，在汇点那边没有被用，以及有可能两个二类格子无法匹配。

怎么解决？我们考虑这个拐角有什么特殊性质，不难发现对于一个一类格子，只要有两个相邻格子的列数奇偶性不同，那么就存在一个关于其的匹配，所以这启发我们将二类格子按照列数奇偶性分成两部分，分别向一类格子连边即可，这样只要一个一类格子同时具有两个部分的二类格子就会存在增广路，从而扔掉其点权。

同时注意一类格子每个最多被删一次，所以要拆点中间连费用为点权的边。

最后两个问题，最多删 $m$ 个怎么办（作者做的时候忘记了这一点），建个虚拟源向源点连流量为 $m$ 的就行。

我们跑的是最小费用最大流，优先保证最大流怎么办？注意到每次增广到汇点的路径是单调的，所以只要当前增广的路径不会更优就停止增广即可。

## Code

一定要算明白空间要开多大啊。

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
using namespace std;
int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N = 2e4+5;
bool mp[100][100];int val[100][100];
int n,m,k,S,T,SS;
int head[N],tote=1;
struct aa{
	int nxt,to,val,w;
}edge[N*20];
void link(int u,int v,int x,int y){
	edge[++tote].nxt = head[u];edge[tote].to = v;head[u] = tote;edge[tote].val = x;edge[tote].w = y;
	edge[++tote].nxt = head[v];edge[tote].to = u;head[v] = tote;edge[tote].val = 0;edge[tote].w =-y;
}
int rk(int x,int y,int z){
	return (x-1)*n+y+z*n*n;
}
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
bool check(int x,int y){
	if(x<1||x>n||y<1||y>n||mp[x][y]){
		return false;
	}else{
		return true;
	}
} 
int sum,cost,flow,inf = 1e9;
queue<int>q;
int dis[N];
bool vis[N];
bool spfa(){
	memset(dis,0x3f,sizeof(dis));
	dis[SS] = 0;
	q.push(SS);
	while(!q.empty()){
		int u = q.front();
		q.pop();
		vis[u] = 0;
		for(int i=head[u];i;i=edge[i].nxt){
			int now = edge[i].to;
			if(dis[now]>dis[u]+edge[i].w&&edge[i].val){
				dis[now] = dis[u]+edge[i].w;
				if(!vis[now]){
					vis[now] = 1;
					q.push(now);
				}
			}
		}
	}
	return dis[T]<=0;
}
int dfs(int u,int f){
	if(u==T){
		return f;
	}
	int used = 0;
	vis[u] = 1;
	for(int i=head[u];i&&f;i=edge[i].nxt){
		int now = edge[i].to;
		if(dis[now]==dis[u]+edge[i].w&&!vis[now]&&edge[i].val){
			int w = dfs(now,min(f,edge[i].val));
			f-=w;used+=w;
			edge[i].val-=w;edge[i^1].val+=w;
			cost+=edge[i].w*w;
		}
	}
	vis[u] = 0;
	if(!used){
		dis[u] = inf;
	} 
	return used;
}
void mcmf(){
	while(spfa()){
		flow+=dfs(SS,inf);
	}
}
int main(){
	n = read();m = read();k = read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			val[i][j] = read();
			sum+=val[i][j];
		}
	}
	int x,y;
	for(int i=1;i<=k;i++){
		x = read();y = read();
		mp[x][y] = 1;
	}
	S = 0;T = 4*n*n+1;
	SS = T+1;
	link(SS,S,m,0);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if((i+j)&1){
				link(rk(i,j,2),rk(i,j,3),1,-val[i][j]);
				for(int s=0;s<4;s++){
					int x = i+dx[s],y = j+dy[s];
					if(check(x,y)){
						if(y&1){
							link(rk(x,y,1),rk(i,j,2),1,0);
						}else{
							link(rk(i,j,3),rk(x,y,4),1,0);
						}
					}
				}
			}else{
				if(j&1){
					link(S,rk(i,j,1),1,0);
				}else{
					link(rk(i,j,4),T,1,0);
				}
			}
		}
	}
	mcmf();
	cout<<sum+cost<<"\n";
	return 0;
}

```


---


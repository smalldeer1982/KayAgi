# [WC2011] 最大XOR和路径

## 题目描述

XOR（异或）是一种二元逻辑运算，其运算结果当且仅当两个输入的布尔值不相等时才为真，否则为假。 XOR 运算的真值表如下（$1$ 表示真， $0$ 表示假）：

| 输入 | 输入 | 输出 |
| :----------: | :----------: | :----------: |
| A | B | A XOR B |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |


而两个非负整数的 XOR 是指将它们表示成二进制数，再在对应的二进制位进行 XOR 运算。

譬如 $12$ XOR $9$ 的计算过程如下：

$$
12=(1100)_2\ \ \ 9=(1001)_2\\
\begin{matrix}
&1\ 1\ 0\ 0\\
\text{XOR}&1\ 0\ 0\ 1\\
\hline
&0\ 1\ 0\ 1\\
\end{matrix}\\
(0101)_2=5
$$

故 $12$ XOR $9 = 5$。

容易验证， XOR 运算满足交换律与结合律，故计算若干个数的 XOR 时，不同的计算顺序不会对运算结果造成影响。从而，可以定义 $K$ 个非负整数 $A_1$，$A_2$，……，$A_{K-1}$，$A_K$的 XOR 和为

$A_1$ XOR $A_2$ XOR …… XOR $A_{K-1}$ XOR $A_K$

考虑一个边权为非负整数的无向连通图，节点编号为 $1$ 到 $N$，试求出一条从 $1$ 号节点到 $N$ 号节点的路径，使得路径上经过的边的权值的 XOR 和最大。

路径可以重复经过某些点或边，当一条边在路径中出现了多次时，其权值在计算 XOR 和时也要被计算相应多的次数，具体见样例。


## 说明/提示

【样例说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/p6bf4fgf.png)

如图，路径$1 \rightarrow 2 \rightarrow 4 \rightarrow 3 \rightarrow 5 \rightarrow 2 \rightarrow 4 \rightarrow 5$对应的XOR和为

$2$ XOR $1$ XOR $2$ XOR $4$ XOR $1$ XOR $1$ XOR $3 = 6$

当然，一条边数更少的路径$1 \rightarrow 3 \rightarrow 5$对应的XOR和也是$2$ XOR $4 = 6$。

【数据规模】

对于 $20 \%$ 的数据，$N \leq 100$， $M \leq 1000$，$D_i \leq 10^{4}$；

对于 $50 \%$ 的数据，$N \leq 1000$， $M \leq 10000$，$D_i \leq 10^{18}$；

对于 $70 \%$ 的数据，$N \leq 5000$， $M \leq 50000$，$D_i \leq 10^{18}$；

对于 $100 \%$ 的数据，$N \leq 50000$， $M \leq 100000$，$D_i \leq 10^{18}$。




## 样例 #1

### 输入

```
5 7
1 2 2
1 3 2
2 4 1
2 5 1
4 5 3
5 3 4
4 3 2```

### 输出

```
6```

# 题解

## 作者：An_Account (赞：160)

[我的主页（阅读效果更好）打开即可$RP++$](https://www.luogu.org/space/show?uid=39914)

题目要求很多条边的最大异或和，从这一点我们可以想到线性基。这里归纳一下线性基的几点性质：

设$V$是某个神奇的向量空间，$B$是$V$的基，则$B$应满足以下条件：

> 1.$V$是$B$的极小生成集，就是说只有$B$能张成$V$，而它的任何真子集都不张成全部的向量空间。

> 2.$B$是$V$中线性无关向量的极大集合，就是说$B$在$V$中是线性无关集合，而且$V$中没有其他线性无关集合包含它作为真子集。

> 3.$V$中所有的向量都可以按唯一的方式表达为$B$中向量的线性组合。

这也就是说，我们可以用不超过$log_{2}{m}$个基就能表示所有的异或和，考虑题目中一句重要的话：

> 路径可以重复经过某些点或边，当一条边在路径中出现了多次时，其权值在计算 XOR 和时也要被计算相应多的次数

这句话给了我们一点启发，假设某条路$k$被重复走了两次，那么它的权值对答案的贡献就是$0$，但是通过这条路径$k$，我们可以到达它连接的另一个点。

显然我们没法枚举$1$~$N$的每一条路，但我们可以将路径拆成两部分，第一部分是环，第二部分是链。

假设我们选择了一条从$1$~$N$的链，当然，它不一定是最优秀的。但是别忘了，我们可以选择一些环来增广这条链。举个例子：

![](http://wx3.sinaimg.cn/mw690/0060lm7Tly1ft7x5h09fvj30ir090weg.jpg)

假设$k$是连接这条链和某个环的某条路径，那么显然，链和环都将走过一遍，而这条路径$k$会被走过两遍（从链到环一遍，从环到链一遍）。根据我们上面的推论，$k$对答案的贡献是$0$。于是我们发现，我们根本就没有必要算出这条路径$k$！（反正贡献是$0$）

于是我们枚举所有环，将环上异或和扔进线性基，然后用这条链作为初值，求线性基与这条链的最大异或和。

``` cpp
void dfs(int u,LL res) {//枚举所有环
    del[u]=res,vis[u]=1;
    for (int i=head[u];i;i=e[i].next)
        if (!vis[e[i].to]) dfs(e[i].to,res^e[i].w);
        else insert(res^e[i].w^del[e[i].to]);
}
LL query(LL x) {//最大异或和
    LL res=x;
    for (int i=63;i>=0;i--)
        if ((res^num[i])>res)
            res^=num[i];
    return res;
}
```

最后说一下怎么选最开始的这条链，其实**它可以随便选**。我们考虑以下这种情况：
![](http://wx4.sinaimg.cn/mw690/0060lm7Tly1ft7xo17vhuj30if09xmx5.jpg)

假设路径$A$比路径$B$优秀一些，而我们最开始选择了路径$B$。显然，$A$与$B$共同构成了一个环。如果我们发现路径$A$要优秀一些，那么我们用$B$异或上这个大环，就会得到我们想要的$A$！

所以这道题的算法是：找出所有环，扔进线性基，随便找一条链，以它作为初值求最大异或和就可以了。

附上AC代码：

``` cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define LL long long
LL num[70];
bool insert(LL x) {
    for (int i=63;i>=0;i--)
        if ((x>>i)&1) {
            if (!num[i]) {
                num[i]=x;
                return true;
            }
            x^=num[i];
        }
    return false;
}
LL query(LL x) {
    LL res=x;
    for (int i=63;i>=0;i--)
        if ((res^num[i])>res)
            res^=num[i];
    return res;
}
struct edge {
    int to,next;
    LL w;
}e[200010];
int head[50010],ecnt;
inline void adde(int from,int to,LL w) {
    e[++ecnt]=(edge){to,head[from],w},head[from]=ecnt;
    e[++ecnt]=(edge){from,head[to],w},head[to]=ecnt;
}
int vis[50010];LL del[50010];
void dfs(int u,LL res) {
    del[u]=res,vis[u]=1;
    for (int i=head[u];i;i=e[i].next)
        if (!vis[e[i].to]) dfs(e[i].to,res^e[i].w);
        else insert(res^e[i].w^del[e[i].to]);
}
int main() {
    int n,m,a,b;LL c;scanf("%d%d",&n,&m);
    for (int i=1;i<=m;i++) scanf("%d%d%lld",&a,&b,&c),adde(a,b,c);
    dfs(1,0);
    printf("%lld\n",query(del[n]));
}
```

---

## 作者：Mr_Wu (赞：66)

可能是其他人太强了认为这是显然的或者我太弱了，我并没有看到明确的解释为什么正确做法对环套环的处理方案是正确的。。

先讲一下这题的正确做法，首先考虑答案路径上的点的组成，一定是 $1$ 到 $n$ 的一条路径（称为“主路径”）与很多简单环组成。这是因为我们从主路径走到一个环上的路径会被恰好走两次，抵消掉。

而又可以证明主路径能随便选（考虑两条主路径会构成环），所以选一个主路径，并在 dfs 树上通过返祖边找到简单环，扔进线性基就可以了。

但是可能会出现这样的问题：

![](https://cdn.luogu.com.cn/upload/image_hosting/4wdqafv1.png)

可以看出来这个图可以有好几种不同的 dfs 树，在图中第一个 dfs 树能找到环 $\{2,3,4\}$ 和 $\{1,2,3,4\}$，而第二个 dfs 树却只能找到 $\{2,3,4\}$ 和 $\{1,2,4\}$。所以当我们计算的时候会漏掉一个简单环。让人惊讶的是，这两种 dfs 方式能得出相同的答案。

事实上，我们可以发现（这里用边集代替上面的点集） $\{(1,2),(2,3),(3,4),(4,1)\}$ 与 $\{(2,3),(3,4),(4,2)\}$ 进行“异或”能直接得到 $\{(1,2),(4,2),(4,1)\}$，因此我们猜想我们的算法找到的简单环能够通过异或操作得到所有的简单环。

证明的话可以考虑为什么线性基可以成为它所在线性空间的一组基底，大概就能证明这件事情。

用这种性质做的题也有 [CF19E Fairy](https://www.luogu.com.cn/problem/CF19E)，建议去看看。

---

## 作者：jun头吉吉 (赞：56)

# 一道线性基+图论的板子题
我们假设$dis_i$表示$1\to i$的简单路径的异或和
```
如果路径上的各顶点均不互相重复，称这样的路径为简单路径。
```
我们来考虑一下没有环的情况

![一张图](https://cdn.luogu.com.cn/upload/image_hosting/snd5poyr.png)


很显然，此时的答案为$dis_n$~~这不废话吗~~

但如果有环呢？

![一张图](https://cdn.luogu.com.cn/upload/image_hosting/l3eoh52u.png)


此时有两种情况：
1. 不经过这个环
2. 经过这个环

对于**情况1**，显然此时的值为$dis_n$

对于**情况2**，经过观察我们发现：
$$Ans=dis_n\oplus k\oplus c\oplus k=dis_n\oplus c$$
如果有3个环呢

![一张图](https://cdn.luogu.com.cn/upload/image_hosting/pqfn58q6.png)

经过这三个环的答案即为
$$Ans=dis_n\oplus c_1\oplus c_2\oplus c_3$$
因此我们得出结论:**答案可以由一条$1\to n$的路径异或若干个环得到**

那么问题由来了：如果从$1\to n$有多条路径呢？

![一张图](https://cdn.luogu.com.cn/upload/image_hosting/r1yxzb03.png)


很显然，

$\color{red}\text{红色的链}\color{black}\oplus \color{green}\text{绿色的链}\color{black}=\color{orange}\text{黄色的环}$

$\color{red}\text{红色的链}\color{black}\oplus \color{orange}\text{黄色的环}\color{black}=\color{green}\text{绿色的链}$


因此我们可以取任意一条链，通过异或环得到所有情况

于是我们把问题转换成了两个子问题：
- 求出所有的环
- 一个数异或若干个数的最大值

对于问题一，~~随便搞~~一个dfs就过了

问题二不会的话~~为什么来做这道题~~出门左转[【模板】线性基](https://www.luogu.com.cn/problem/P3812)谢谢

接下来我们就可以愉快地敲出正解了

```cpp//#pragma optimize(2)
#include<bits/stdc++.h>
using namespace std;
template<typename T>
inline void read(T &x){
	x=0;char c=getchar();bool f=false;
	for(;!isdigit(c);c=getchar())f!=c=='-';
	for(;isdigit(c);c=getchar())x=x*10+c-'0';
	if(f)x=-x;
}
template<typename T ,typename ...Arg>
inline void read(T &x,Arg &...args){
	read(x);read(args...);
}
template<typename T>
inline void write(T x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)write(x/10);
	putchar(x%10+'0');
}
typedef long long ll;
const ll maxn=50000+100;
const ll maxm=100000+100;
bool flag[maxn];
ll dis[maxn];
const ll maxn_wei=64;
struct XXJ{
	//线性基板子
	ll b[maxn_wei];
	void init(){memset(b,0,sizeof b);}
	void insert(ll x){
		for(ll i=maxn_wei-1;i>=0;i--){
			if(!(x&(1ll<<i)))continue;
			if(!b[i]){
				b[i]=x;
				return ;
			}
			x^=b[i];
		}
	}
}Base;
struct Graph{
	struct Edge{ll v,w,nxt;}e[maxm*2];
	ll cnt,head[maxn];
	void init(){memset(head,0,sizeof head);cnt=0;}
	void add(ll u,ll v,ll w){e[++cnt]=(Edge){v,w,head[u]};head[u]=cnt;}
	#define For(G,i) for(ll eee=(G).head[(i)];eee;eee=(G).e[eee].nxt)
	#define v(G) (G).e[eee].v
	#define w(G) (G).e[eee].w
}G;
void dfs(ll x,ll res){
	dis[x]=res;
	flag[x]=true;
	For(G,x){
		if(!flag[v(G)])dfs(v(G),res^w(G));
		else Base.insert(res^w(G)^dis[v(G)]);
	} 
}
ll n,m,u,v,w;
signed main(){
	read(n,m);
	for(ll i=1;i<=m;i++){
		read(u,v,w);
		G.add(u,v,w);
		G.add(v,u,w);
	}
	dfs(1,0);
	ll ans=dis[n];
	for(ll i=maxn_wei-1;i>=0;i--)
		if((ans^Base.b[i])>ans)
			ans^=Base.b[i];
	write(ans);
}
```


---

## 作者：caeious (赞：32)

其他题解已经将这个题的大体思路讲的很清楚了，这里补充两个证明。

设 $T$ 是原图 $G(V, E)$ 的任一生成树，$T$ 的根为 $1$；定义一条路径 $p$ 的权值 $w(p)$ 为它经过的边的权值的 XOR 和，$\bar p$ 为 $p$  的反向路径， $t(u)$ 为 $1$ 到 $u$ 树上路径，$\bar t(u)$ 为 $u$ 到 $1$ 的树上路径，$f(u)$ 为 $t(u)$ 权值。

**定理1：**从点 $1$ 出发回到 $1$ 的所有路径的权值构成的集合 $A$ 等于 $D: \{\bigoplus [ f(u) \oplus w(u,v) \oplus f(v)] \mid (u, v) \in E \setminus T\}$.

> 证：
>
> $\forall$ 路径 $(u_1, u_2, \dots, u_k) \in A$，由题意得：
>
> - $(u_i, u_{i + 1}) \in E(1 \leq i \leq k - 1)$
> - $u_1 = u_k = 1$
>
> $\begin{aligned} &\therefore w(u_1, u_2, \dots, u_k) \\ &= \bigoplus_{i = 1}^{n - 1}w(u_i, u_{i + 1}) \\ &= \bigoplus_{i = 1}^{n - 1}w(u_i, u_{i + 1}) \oplus f(u_1) \oplus f(u_2) \oplus f(u_2) \oplus \dots \oplus f(u_{k - 1}) \oplus f(u_{k - 1}) \oplus f(u_k) \\ &= \bigoplus_{i = 1}^{n - 1}[f(u_i) \oplus w(u_i, u_{i + 1}) \oplus f(u_{i + 1})] \end{aligned}$
>
> 若 $(u_i, u_{i + 1}) \in T(1 \leq i \leq k - 1)$，不妨设 $u_i$ 是 $u_{i + 1}$ 的父亲，则 $f(u_i) \oplus w(u_i, u_{i + 1}) \oplus f(u_{i + 1}) = f(u_{i + 1}) \oplus f(u_{i + 1}) = 0$，因此 $w(u_1, u_2, \dots, u_k) = \bigoplus[1 \leq i < n, (u_i, u_i + 1) \in E \setminus T][f(u_i) \oplus w(u_i, u_{i + 1}) \oplus f(u_{i + 1})] \in D$.
>
> $\forall s = \bigoplus_{i = 1}^k f(u_i) \oplus w(u_i, v_i) \oplus f(v_i) \in D$，有 $s = w[t(u_1), \bar t(v_1), t(u_2), \bar t(v_2), \dots, t(u_k), \bar t(v_k)] \in A$
>
> $\therefore A \subseteq D, D \subseteq A$，即 $A = D$.

**定理2：**记从点 $1$ 出发回到 $1$ 的所有路径的权值构成的集合为 $A$，则从点 $1$ 出发到点 $N$ 的所有路径的权值集合 $B$ 等于 $\{f(N) \oplus w \mid w \in A\}$.

> 证：
>
> 记原式右边为 $C$，
>
> $\begin{aligned} &w(p) \in A \\ &\implies w(p) \oplus f(N) = w[p, t(N)] \in B \\ &\implies C \subseteq B \end{aligned}$
>
>  $\begin{aligned} &\forall w(p) \in B, w(p) \oplus f(N) = w[p, \bar t(N)] \in A \\ &\implies w(p) \in C  \\ &\implies B \subseteq C \\ &\implies B = C \end{aligned}$

注意到 $\max B = \max\{f(N) \oplus w \mid w \in D\}$ 即为所求，对 $D$ 构造线性基即可。

代码与其他题解类似，这里略去。

我注意到许多题解的解释是对“环的权值构造线性基”，但代码里却“隐式地”使用了上述两个定理，这在逻辑上有所跳跃。同时，由上述分析可以看出，本题取任何一个生成树均可，无需强调“dfs 树”或“bfs 树”等。

---

## 作者：宁_缺 (赞：19)

## 祭罕见的做紫题一遍就过了样例
（但代码还是出了一个锅，不过很快就找出来了。~~不像昨天一道LCT的题目找bug找了三个小时……~~）

对于这种题目，我们先考虑是**仙人掌**的情况：

仙人掌必然是有几条链和几个简单环组成的，我们首先找一条从起点到终点的路径（下面称之为【主路径】），然后我们发现，如果异或一个环，要先从主路径走到环上，最后再走回来，于是主路径和环之间的路径走了两遍，由异或性质可知，这条路径等于没异或（异或两次变成0）。

于是我们可以得到这样一个思路：将每个环的异或值求出来，再找一条主路径，然后求这条主路径异或一些环的最大值即可

异或的最大值用线性基就可以了，但主路径怎么选呢？

仔细一想就会知道，其实主路径选哪条不影响最终结果，因为如果从起点到终点的路径有多条，那么这些路径之间一定构成了一些环，无论主路径怎么选，最终异或几个环总能得到所有的路径

到这里，很多题解就结束了，我也是看到楼下62308(id)巨佬的题解才想到：这题没说是仙人掌……

比如样例![](https://www.z4请更换图床a.net/images/2018/01/28/QQ20180128150132.png)

但样例有点复杂了，我们就看楼下那位巨佬的例子吧![](https://cdn.luogu.com.cn/upload/image_hosting/bw7vtpg7.png)

我们从①开始遍历，为了方便显示dfs的顺序（~~也是方便打字~~）我们用括号括起来一个点到的节点，同时，把括号去掉就是dfs依次到的节点

发现是这样的：①(②(③(④(①))(④))，从④到①，找到第一个环{1,2,3,4}，然后返回到②，再从②到④，找到第二个环{2,3,4},但由于④访问过了，因此我们无法找到{1,2,4}这个环了

但事实上，这不影响结果，因为分别异或{1,2,3,4}和{2,3,4}两个环上的边就能得到{1,2,4}这个环（~~所以其实这段文字就是一段废话~~）
#
最后，我看到很多题解dfs都是这样写的：
```cpp
void dfs(int u,LL res){
    xr[u]=res,vis[u]=1;
    for (int i=head[u];i;i=e[i].next)
        if (!vis[e[i].to]) dfs(e[i].to,res^e[i].w);
        else insert(res^e[i].w^del[e[i].to]);
}
```
这样就会把每条无向边都作为环加入，从定义上来说这样是更好，但事实上一条单独的边可以不加入(因为你跑过去再跑过来等于没跑)，所以我在dfs中加入了一个【上一个点】来剔除这种情况，应该可以提一点速。
#
```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(3)
#define LL long long
using namespace std;
const int N=5e4+9,M=N<<2;
int n,m,hd[N],to[M],nt[M],pn;
LL ans,xr[N],d[64],w[M];
bool vs[N];
void ins(LL x){
	for(int i=62;i>=0;--i)
		if(1&(x>>i))
			if(d[i])x^=d[i];
			else{d[i]=x;return;}
}
void dfs(int x,int fr,LL res){
	vs[x]=true,xr[x]=res;
	for(int i=hd[x],v;i;i=nt[i]){
		v=to[i];if(v==fr)continue;
		if(!vs[v])dfs(v,x,res^w[i]);
		else ins(res^w[i]^xr[v]);
	}
}
int main(){
	scanf("%d%d",&n,&m);LL z;
	for(int i=1,u,v;i<=m;++i)
		scanf("%d%d%lld",&u,&v,&z),
		pn++,to[pn]=v,w[pn]=z,
		nt[pn]=hd[u],hd[u]=pn,
		pn++,to[pn]=u,w[pn]=z,
		nt[pn]=hd[v],hd[v]=pn;
	dfs(1,0,0ll),ans=xr[n];
	for(int i=62;i>=0;--i)
		ans^=(ans^d[i])>ans?d[i]:0;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：George1123 (赞：17)

[$\Huge\texttt{In Cnblogs}$](https://www.cnblogs.com/Wendigo/p/12837570.html)

---
> [\[WC2011\]最大XOR和路径](https://www.luogu.com.cn/problem/P4151)

> 给一个 $n$ 个点 $m$ 条边（权值为 $d_i$）的无向有权图，可能有重边和子环。可以多次经过一条边，求 $1\to n$ 的路径的最大边权异或和。

> 数据范围：$1\le n\le 5\cdot 10^4$，$1\le m\le 10^5,0\le d_i\le 10^{18}$。

---
非常神的一题，令小蒟蒻大开眼界。

**一句话题解：通过 $\texttt{Dfs}$ 得到到每个点的一种路径答案，用线性基找到最优替换方案。**

---
先看这个奇奇怪怪的样例，样例解释中的最优路径等价于 $1\to2\to5\to3\to4\to5$：

![xxjt2.jpg](https://i.loli.net/2020/05/06/BfEzFpm1RIMnuLd.jpg)

答案为 $2\oplus1\oplus4\oplus2\oplus3=6$。

---
有一种非常野蛮的做法是**暴力 $\texttt{Dfs}$ 整张无向图对每种答案求值，正确但是太慢。**

但是考虑到**异或运算的交换律**，这是可以优化的，比如下图：

![xxjt3.jpg](https://i.loli.net/2020/05/06/vmyjuIqWTfCnewp.jpg)

> 为了更好地说明问题，蒟蒻改了改样例图。

两条路径：

$1\to4\to2\to3:3\oplus2\oplus4=5$

$1\to2\to4\to3\to5:2\oplus3\oplus2\oplus4=7$

它们在 $4$ 号点以后重合。根据**异或的交换律和 $x\oplus x=0$ 的性质**可以得出**两条路径的异或差（就是异或值）等于两条路径在 $4$ 号点前的异或差。**

即 $(3\oplus2\oplus4)\oplus(2\oplus3\oplus2\oplus4)=(3)\oplus(2\oplus3)=2$

所以可以**在 $4$ 号点上记录下这个异或差 $2$，然后选择一条路径继续走。等找到了其中一种到 $n$ 的路径的异或和为 $firstans$ 时，再看看 $firstans$ 和 $firstans\oplus2$ 谁大，如果 $firstans<firstans\oplus2$ 则表示选到 $4$ 号点的另一条路径更好。**

于是这样遍历图就**不需要遍历重复的点**了，但是会在 $\texttt{Dfs}$ 路径的交点处留下一堆**异或差**。

若留下了 $k$ 个异或差标记 $c_i$，则答案有 $2^k$ 种可能性。这时可以用一个**线性基**把所有异或差存起来，然后把 $firstans$ 带进去得到最优答案。

---
小蒟蒻讲不清楚，所以再拿样例来解释：

![xxjt4.jpg](https://i.loli.net/2020/05/06/2xDsozfqlwXiUa5.jpg)

> 蓝色路径为 $\texttt{Dfs}$ 树，正好是条链。

$firstans=2\oplus1\oplus3=0$，$c_1=3$，$c_2=5$，$c_3=6$。

丢进线性基：$lb_0=0,lb_1=3,lb_2=5$。

将 $firstans=0$ 带入跑一趟，答案为 $6$。

---
**时间复杂度 $\Theta(m\log d)$。**

---

小蒟蒻又成功地写出了没人懂的题解，还是放代码吧：

```cpp
#include <bits/stdc++.h>
using namespace std;

//Start
typedef long long ll;
typedef double db;
#define mp(a,b) make_pair(a,b)
#define x(a) a.first
#define y(a) a.second
#define b(a) a.begin()
#define e(a) a.end()
#define sz(a) int((a).size())
#define pb(a) push_back(a)
const int inf=0x3f3f3f3f;
const ll INF=0x3f3f3f3f3f3f3f3f;

//Data
const int N=5e4,M=2e5;
int n,m;
int E=-1;
vector<int> to;
vector<ll> w;
vector<int> e[N+7];
void add(int u,int v,ll d){
	e[u].pb(++E),to.pb(v),w.pb(d);
	e[v].pb(++E),to.pb(u),w.pb(d);
}

//LB
const int LOGA=60;
ll lb[N+7];
void add(ll x){ //logn
	for(int i=LOGA;i>=0;i--)if(x>>i){
		if(lb[i]) x^=lb[i];
		else return void(lb[i]=x);
	}
}
ll find(ll x){ //logn
	for(int i=LOGA;i>=0;i--)
		if((x^lb[i])>x) x^=lb[i];
	return x;
}

//Bfs
int vis[N+7];
ll firstans[N+7];
void Dfs(int u,ll x){
	vis[u]=1,firstans[u]=x;
	for(int i:e[u])
		if(!vis[to[i]]) Dfs(to[i],x^w[i]);
		else add(firstans[to[i]]^(x^w[i])); //遇到交点，记录异或差
}

//Main
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int u,v; ll d;
		scanf("%d%d%lld",&u,&v,&d);
		add(u,v,d);
	}
	Dfs(1,0);
	printf("%lld\n",find(firstans[n])); //得到一种路径异或和，替换寻优
	return 0;
}
```
---
**祝大家学习愉快！**

---

## 作者：chenxia25 (赞：11)

考虑 $1\to n$​ 所有路径的边权异或和集合长什么样。定义两个边集的异或和为恰好出现在一个边集里的边的集合。首先知道边集一般不考虑简单环还是复杂环。复杂环、甚至是若干个不连通的环的集合，都可以由简单环集合线性表出。所有这样的满足每个点度数为偶的边集的集合，不难发现它对唯一的线性运算——异或封闭，所以是一个线性空间，元素为边集（其实也可以看成 01 向量啦）。

然后不难想到，$1\to n$ 的所有路径，其实就是先随便选一条，然后把上述线性空间里所有元素依次异或上去，得到所有路径。证明一下？一个边集是 $1\to n$​ 的路径其实当且仅当除 $1,n$ 为奇度以外，其它点都是偶度。那得到的这些边集是 $1\to n$ 路径其实就显然了，反过来只有这些是 $1\to n$ 路径是不是也显然啊（）。所以 $1\to n$ 的所有路径的边集其实就是一个线性空间异或上一个平移量，线性空间是所有简单环的生成空间，平移量是 $1\to n$ 任意一条路径。

但是即使找到了这个生成空间的一个基的一个超集——简单环集合，但这还是太多了，简单环哪里能枚举的过来？考虑任意一棵生成树，一个结论是：非树边对应简单环的集合是基的一个超集。感觉上很对吧，就感觉生成树上的简单环能线性表出所有简单环，找不到反例对吧。但我们需要一个严谨的证明：每条非树边最多出现在一个树上简单环里对吧。对每个简单环的异或和，把所有非树边去掉，去掉的方式是异或上对应树上简单环，显然是可实现的。最后依然得到另一个简单环的异或和，而它没有非树边，只有树边，想仅由树边组成至少一个环是不可能的，所以必须是空集，那么原集合能被树上简单环线性表出就被证明了。

而且最后不需要真的求这个元素为边集的线性空间的一组基。最后要求的其实是，这个线性空间里每个元素的异或和得到的新线性空间（对边集取边权异或和显然是个线性变换）的一组基。那显然树上简单环的异或和集合是新线性空间的一组基，平移量也取对应异或和。可以选 dfs 树（其实其它生成树也可以，dfs 树只有返祖边比较舒服），树上简单环是 $\mathrm O(m-n)$​​​​ 个，维护树上前缀异或和即可得到每个树上简单环的异或和，扔进线性基即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define X first
#define Y second
#define pb push_back
#define mp make_pair
const int N=1000010;
int n,m;
vector<pair<int,int> > nei[N];
bool vis[N];
int xsm[N];
int b[N];
void insert(int x){
	for(int i=60;~i;i--)if(x>>i&1)
		if(b[i])x^=b[i];
		else{b[i]=x;break;}
}
void dfs(int x=1,int fa=0){
	vis[x]=true;
	for(int i=0;i<nei[x].size();i++){
		int y=nei[x][i].X,v=nei[x][i].Y;
		if(y==fa){fa=-1;continue;}
		if(!vis[y])xsm[y]=xsm[x]^v,dfs(y,x);
		else insert(xsm[x]^xsm[y]^v);
	}
}
signed main(){
	cin>>n>>m;
	while(m--){
		int x,y,v;
		scanf("%lld%lld%lld",&x,&y,&v);
		nei[x].pb(mp(y,v)),nei[y].pb(mp(x,v));
	}
	dfs();
	int res=xsm[n];
	for(int i=60;~i;i--)if(res>>i&1)res^=b[i];
	cout<<res;
	return 0;
}
```



---

## 作者：ccviolett (赞：6)

> 一句话题意：求图上从 1 到 N 的所有路径的最大异或和

发现答案肯定是由随便一条由 1 到 n 的路径异或上图中若干个环。

构造方案的话只需要从 1 号点走到环上任意一点，转完整个环，再回到 1 号点，会发现只有环上的值被取了，其他路径上的值都被异或抵消了。

从 1 到 n 路径的选择随意就好了，因为如果有另一条更优的路径的话，这两条路径就会构成一个环，最优解用这个环异或掉原来选择的路径，就会自动变为更优的路径。

若干个数异或最大值交给线性基去做就好了，这里面相当于指定了初始值，但是不影响，只是不需要优化线性基构造，因为优化了也不能保证和初始值之间互不影响。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long var;

const int N = 51004;
const int M = 110005;

namespace Basis {
  var basis[65];
  void insert(var t);
  var query(var t);
};

using namespace Basis;

int n, m;
int top, fi[N], ne[M << 1], to[M << 1];
var co[M << 1];
var dist[N];
bool mark[N];

void add(int u, int v, var w);
void dfs(int t, var s); 

int main() {
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= m; ++i) {
    var u, v, w;
    scanf("%lld%lld%lld", &u, &v, &w);
    add(u, v, w), add(v, u, w);
  }
  dfs(1, 0);
  printf("%lld\n", query(dist[n]));
  return 0;
}

void add(int u, int v, var w) {
  ne[++top] = fi[u], fi[u] = top, to[top] = v, co[top] = w;
}

void dfs(int t, var s) {
  dist[t] = s, mark[t] = true;
  for (int i = fi[t]; i; i = ne[i]) {
    if (!mark[to[i]]) dfs(to[i], s ^ co[i]);
    else insert(s ^ co[i] ^ dist[to[i]]);
  }
}

namespace Basis {
  void insert(var t) {
    for (int i = 63; i >= 0; --i) {
      if (!((t >> i) & 1)) continue;
      if (!basis[i]) {
        basis[i] = t;
        break;
      }
      t ^= basis[i];
    }
  }
  var query(var t) {
    for (int i = 63; i >= 0; --i) {
      if ((t ^ basis[i]) > t) t ^= basis[i];
    }
    return t;
  }
}
```

---

## 作者：Zhang_RQ (赞：4)

~~(贴一下[博客](https://zhang-rq.github.io/2018/03/17/BZOJ2115-WC2011-Xor/))~~

### 题目大意

你有一张$\text{N}$个点$\text{M}$条边的无向图，每条边上都有权值，现在请你求出来一条路径，使得这条路径上所有边权的异或和最大。

### 题解

**前置技能：线性基** (不会的戳这里[线性基学习笔记](https://zhang-rq.github.io/2018/03/17/%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/))

我们可以发现，这张图上会出现很多的环，而如果走一个环，就会**只**获得这个环的异或和。因为在非环路都走了两遍，所以我们就可以将所有环都求出来，然后随意找一条从$1$到$N$的路径，并使用线性基贪心地选，这样就可以选出最大的路径了。

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<vector>
#include<set>
#include<map>
#include<queue>
#include<stack>
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
const int MAXN=1E5+5;
const int MAXM=2E5+5;
struct node{
    int nxt,v;
    ll w;
}Edge[MAXM];
int n,m,u,v;
ll w;
int head[MAXN],cnt_e,cnt;
ll dis[MAXN],lop[MAXM],b[64];
bool vis[MAXN];
inline void add(int u,int v,ll w)
{
    Edge[++cnt_e].v=v;
    Edge[cnt_e].nxt=head[u];
    Edge[cnt_e].w=w;
    head[u]=cnt_e;
}
void dfs(int x,int fa)
{
    vis[x]=1;
    for(int i=head[x];i;i=Edge[i].nxt)
    {
        int v=Edge[i].v;
        if(v==fa) continue;
        if(vis[v]) {lop[++cnt]=dis[x]^dis[v]^Edge[i].w;continue;}
        dis[v]=dis[x]^Edge[i].w;
        dfs(v,x);
    }
}
void build()
{
    for(int i=1;i<=cnt;i++)
        for(int j=62;~j;j--)
            if(lop[i]>>j&1)
            {
                if(b[j]) lop[i]^=b[j];
                else
                {
                    b[j]=lop[i];
                    for(int k=j-1;k>=1;k--) if(b[k]&&b[j]>>k&1) b[j]^=b[k];
                    for(int k=j+1;k<=62;k++) if(b[k]>>j&1) b[k]^=b[j];
                    break;
                }
            }
}
ll solve(ll s)
{
    ll ret=s;
    for(int i=62;~i;i--)
        if((ret^b[i])>ret)
            ret^=b[i];
    return ret;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%lld",&u,&v,&w);
        add(u,v,w);add(v,u,w);
    }
    dfs(1,0);
    build();
    printf("%lld\n",solve(dis[n]));
}

```



---

## 作者：滑稽的小宫 (赞：3)


### 前言
翻这道题题解的时候看到了 @caeious 大佬的题解，别的题解都没有进行严格证明为什么不用找全部的环就可以表出全部的环，但这位大佬给出了详细的证明，但由于他的证明完全从数学角度出发，蒟蒻花了很久才明白，因此在这里从感性理解的角度来讲一讲 @caeious 大佬的方法

## 题意：
> 在无向图上找出一条不一定简单（简单指不重复经过一个节点）的路径，使得路径上值的异或和最大（多次经过一个节点在异或和中要多次计算这个节点的值）

## 一些约定与定义
为了方便叙述，有以下定义
- T：图的任意一棵生成树
- $t(u)$ ：生成树上从1到u的简单路径
- $w(p)$ ：某一条路径p的异或和（即答案）
- $f(u)$ ：生成树上从1到u的简单路径值的异或和，即 $f(u)=w(t(u))$

## 理论分析
**定理1：** 设一个集合 $A=\{f(u)\oplus w(u,v)\oplus f(v)|(u,v)\in E\}$（即从1到u再沿着一条边到v再到1的异或和），则**从1出发走一段路最后回到1的路径**的异或和就可以表示为**A集合中一些元素的异或和**。

![](https://cdn.luogu.com.cn/upload/image_hosting/lb74busl.png)

考虑一下如果有一条从1出发回到1的路径经过了 $1,p_1,p_2,p_3,1$ 节点（如上图），那么我们可以先算从1到 $p_1$ 到 $p_2$ 到1的路径，异或上从1到 $p_2$ 到 $p_3$ 到1的路径，由于异或的性质，这里面1到 $p_2$ 的路径就被抵消了，因此最终结果就是：从1到 $p_1$ 到 $p_2$ 到 $p_3$ 到1的路径

在上图中就是蓝色路径走了两次异或和抵消了，因此最后只剩下了外面一圈的路径异或和。

所以任何一条从1到1的路径都可以表示成A集合内某些元素的异或和。

**定理2：** 设集合B为所有从1到n的路径的异或和（即答案所求），集合C为所有从1到1路径的异或和异或上 $f(n)$ 的值构成的集合，即 $C=\{val*f(n)|val\in A\}$，那么有 $B=C$

$C\subseteq B$ ：这个很好理解，从1出发到1的回路异或上 $f(n)$ 就变成了从1出发到1再走到n的路径的异或和，满足B集合的定义。

$B\subseteq C$ ：如果一条路径 $p$ 是从1出发到n（属于B集合），那么 $w(p)\oplus f(n)\oplus f(n)=w(p)$ ，而 $w(p)\oplus f(n)$ 相当于一条从1到n再走到1的路径的异或和，因此就可以把这条从1出发到n的路径变为从1出发到n，再沿着生成树上边到1，再原路返回n的路径的异或和，而从1出发到n再到1显然是A集合的一条路径，因此任意一条B包含的路径都是C包含的一条路径


## 算法实现

综上，就可以得出一个这样的算法：

用 $A=\{f(u)\oplus w(u,v)\oplus f(v)|(u,v)\in E\}$ 这个集合里面的值组合得到一个异或和，使得和 $f(n)$ 异或的值最大，这个最大值就是答案。

显然可以用线性基进行计算，把所有 $f(u)\oplus w(u,v)\oplus f(v)$ 塞进线性基，算出线性基以后从高位到低位考虑异或 $f(n)$ 之后能不能变大即可。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#define N 50010
#define M 100010
#define ll long long
int tot,n,m,hd[N],to[2*M],nxt[2*M],cnt;
ll f[N],val[2*M],a[2*M];//f数组同上述解释，a数组储存A集合元素
bool vis[N],vi[N];
void newedge(int u,int v,ll w){
	nxt[++tot]=hd[u];
	to[tot]=v,val[tot]=w;
	hd[u]=tot;
	return;
}void dfs(int x){//求出f数组
	vis[x]=1;
	for(int i=hd[x];i;i=nxt[i]){
		int nex=to[i];
		if(vis[nex])continue;
		f[nex]=f[x]^val[i];
		dfs(nex);
	}return;
}void swap(ll &x,ll &y){
	ll tmp=x;
	x=y,y=tmp;
	return;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		ll u,v,w;
		scanf("%lld%lld%lld",&u,&v,&w);
		newedge(u,v,w);
		newedge(v,u,w);
	}dfs(1);
    /*将A集合元素加入，准备计算线性基
	for(int x=1;x<=n;x++)
		for(int i=hd[x];i;i=nxt[i])
			a[++cnt]=f[x]^val[i]^f[to[i]];
    /*线性基部分*/       
	for(int bit=62,i=1;bit>=0;bit--){
		bool flag=false;
		for(int j=i;j<=cnt;j++){
			if(a[j]&(1ll<<bit)){
				swap(a[i],a[j]),flag=true;
				break;
			}
		}if(!flag)continue;
		for(int j=1;j<=cnt;j++)if(j!=i&&(a[j]&(1ll<<bit)))a[j]^=a[i];
		i++;
	}
    /*寻找最大值*/
    for(int i=1;i<=62;i++)
		if((f[n]^a[i])>f[n])f[n]^=a[i];
	printf("%lld",f[n]);
	return 0;
}
```

**以上只是感性理解，建议大家去看看 @caeious 的理性证明的题解，非常有帮助！**

---

## 作者：Kinandra (赞：3)

.标签: 线性基.

.任意一条$1$到$n$的路径的异或和, 都可以由任意一条$1$到$n$简单路径的异或和与图中的一些环的异或和来组合得到.

. 为什么?假如我们已经有一条$1$到$n$的路径, 考虑在出发之前, 先走到图中任意一个环上面, 走一遍这个环, 然后原路返回, 这样我们既得到了这个环的异或值, 也返回了点$1$, 我们可以对任意的环这样做，从而获得这个环的异或值.

.所以我们用环的异或值来建立线性基, 用任意一条$1$到$n$的路径(不用在意那一条, 因为若有另一条, 则必有关于这两条路径的线性基, 因为它们总会有一部分围成一个环)的权值异或和贪心取最大就可以.

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

int read() {
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') {
        if (c == '-') f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * f;
}

int n, m;
long long r[200005], rc;
int head[100005], nxt[400005], to[400005], cnt;
long long w[400005];
void add(int f, int t, long long wei) {
    nxt[++cnt] = head[f];
    head[f] = cnt;
    to[cnt] = t;
    w[cnt] = wei;
    return ;
}

int vis[100005];
long long dis[100005];
void dfs(int u, int fa) {
    vis[u] = 1;
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        if (v == fa) continue;
        if (vis[v]) {
            r[++rc] = dis[v] ^ dis[u] ^ w[i];
            continue;
        }
        dis[v] = dis[u] ^ w[i];
        dfs(v, u);
    }
    return ;
}

long long b[102];
void mkbase() {
    for (int i = 1; i <= rc; ++i) {
        long long tmp = r[i];
        for (int j = 61; j >= 0; --j) {
            if (!((1ll << (long long)j) & tmp)) continue;
            if (!b[j]) {
                b[j] = tmp;
                for (int k = 0; k < j; ++k) {
                    if ((1 << (long long)k) & b[j]) b[j] ^= b[k];
                }
                for (int k = j + 1; k <= 61; ++k) {
                    if ((1 << (long long)j) & b[k]) b[k] ^= b[j];
                }
                break;
            }
            tmp ^= b[j];
        }
    }
    return ;
}

void solve() {
    long long res = dis[n];
    for (int i = 61; i >= 0; --i) {
        if ((res ^ b[i]) > res) {
            res ^= b[i];
        }
    }
    printf("%lld\n", res);
}

int main() {
    n = read(), m = read();
    for (int i = 1; i <= m; ++i) {
        int u = read(), v = read();
        long long w;
        scanf("%lld", &w);
        add(u, v, w);
        add(v, u, w);
    }
    dfs(1, 0);
    mkbase();
    solve();
    return 0;
}
```

---

## 作者：chenzida (赞：2)

题目大意：在一个图中求最大 $xor$ 和路径。

思路解析：这道题的关键在于如果重复经过一条边偶数次那么这条边对于答案的贡献为 $0$。这样的话就可以在到达任意一个结点 $x$ 之后随意绕一个环一圈然后再走回 $x$，这样新增长的贡献就是这个环的异或和。

再整理一下思路，首先枚举一条 $1$ 到 $n$ 的路径，然后再算这条路径与所有环中任选任意多个能达到的最大异或和。而求任意多个的最大异或和自然要用线性基啦。所以每枚举到提个环就尝试让它入线性基，最后再求最长 $xor$ 路径即可。注意，那个 $1$ 到 $n$ 的路径可以是任意一条，因为这条路径异或和 $xor$ 这条路径所在的环的异或和等于这个环的另一半的异或和。即若 $a\ xor\ b=x$ 则 $a\ xor\ x=b$。

所以就可以写出如下代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int NR=5e4+10;
const int MR=1e5+10;
int n,m;
ll d[65];
int to[MR<<1],nxt[MR<<1];
ll val[MR<<1];
int head[NR];
int tot=1;
void add(int x,int y,ll z)
{
	to[tot]=y;
	val[tot]=z;
	nxt[tot]=head[x];
	head[x]=tot++;
}
void addnum(ll x)
{
	for(int i=63;i>=0;i--)
	{
		if((x>>i)&1)
		{
			if(!d[i])
			{
				d[i]=x;
				break;
			}
			x^=d[i];
		}
	}
}
ll search(ll x)
{
	for(int i=63;i>=0;i--)
	{
		if((x^d[i])>x)
		{
			x^=d[i];
		}
	}
	return x;
}
bool vis[NR];
ll dis[NR];
void dfs(int x,ll num)
{
	dis[x]=num;vis[x]=1;
	for(int i=head[x];i;i=nxt[i])
	{
		int y=to[i];
		if(!vis[y]) dfs(y,num^val[i]);
		else addnum(num^dis[y]^val[i]);
	}
}
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
ll readl()
{
	ll x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=m;i++)
	{
		int x=read(),y=read();
		ll z=readl();
		add(x,y,z);
		add(y,x,z);
	}
	dfs(1,0);
	printf("%lld\n",search(dis[n]));
	return 0;
}

```

---

## 作者：Ebola (赞：2)

广告：[我的博客](http://ebola.blogwo.com/2018/06/20/%E3%80%90wc2011%E3%80%91%E6%9C%80%E5%A4%A7xor%E5%92%8C%E8%B7%AF%E5%BE%84-%E9%A2%98%E8%A7%A3/)

我们把选出的路径看做一条1到n的简单路径+一些环

简单路径可以任取一条，就算我们选出的这条不是最优解的路径，我们也可以认为，我们走这条路径到了n，又走最优解的路径回到1，然后再走这条路径到n，这样其实就是这条路径+一个环，异或一下就抵消了这条路径

那么对于一个不直接与这条路径联通的环，我们也可以认为这个环可以异或到答案里面。因为从这条路一条分岔出去到这个环，然后再原路返回，那从这条路到环的那段分岔异或一下就抵消掉了，所以可以直接异或这个环

那么解题思路就是，预处理出所有的环，将其加入线性基中。然后再计算出1到n的任意一条简单路径，长度记为d，我们在线性基中询问与d异或的最大值即可

预处理环与计算简单路径可以一并在dfs中完成

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

const int N=50010,M=100010;
struct Edge{int to,next;LL capa;} e[M<<1];
int h[N],sum=0,n,m;
bool vis[N];
LL dis[N],base[70];

void add_edge(int u,int v,LL w)
{
	e[++sum].to=v;
	e[sum].capa=w;
	e[sum].next=h[u];
	h[u]=sum;
}

void insert(LL x)
{
	for(int i=60;i>=0;i--)
		if(x&(1ll<<i))
		{
			if(base[i]) x^=base[i];
			else{base[i]=x;break;}
		}
}

void dfs(int u)
{
	vis[u]=1;
	for(int tmp=h[u];tmp;tmp=e[tmp].next)
	{
		int v=e[tmp].to;
		if(vis[v]) insert(dis[u]^dis[v]^e[tmp].capa);
		else dis[v]=dis[u]^e[tmp].capa,dfs(v);
	}
}

LL query(LL x)
{
	for(int i=60;i>=0;i--)
		if((x^base[i])>x) x^=base[i];
	return x;
}

int main()
{
	int u,v;LL w;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%lld",&u,&v,&w);
		add_edge(u,v,w);
		add_edge(v,u,w);
	}
	dfs(1);
	printf("%lld\n",query(dis[n]));
	return 0;
}

```

---

## 作者：nofind (赞：1)

## [题意](https://www.luogu.com.cn/problem/P4151)

这题有点神啊。

首先考虑注意这句话：
```
路径可以重复经过某些点或边，当一条边在路径中出现了多次时，其权值在计算 XOR 和时也要被计算相应多的次数
```
也就是说如果出现下面的情况：  
![](https://cdn.luogu.com.cn/upload/image_hosting/v8opx8dt.png)  
我们可以通过异或上这个环的权值而不异或上$w$，于是这启示我们答案必定是**一条链带上好几个环**。

现在考虑选哪条$1$到$n$链：  
其实任意选一条即可，见下图：  
![](https://cdn.luogu.com.cn/upload/image_hosting/ukumsh3d.png)
假设我们选了红的那条，而答案是选蓝色的那条，那么显然可以通过异或上这个环(都是$1->n$的路径，必然是环)使得当前值变为选蓝色那条。

dfs出一条链，将所有环插入线性基，求最大子集异或和。

code:
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=50010;
const int maxm=100010;
int n,m,cnt;
int head[maxn];
ll xord[65],sum[maxn];
bool vis[maxn];
struct edge{int to,nxt;ll dis;}e[maxm<<1];
inline ll read()
{
	char c=getchar();ll res=0,f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')res=res*10+c-'0',c=getchar();
	return res*f;
}
inline void add(int u,int v,ll w)
{
	e[++cnt].nxt=head[u];
	head[u]=cnt;
	e[cnt].to=v;
	e[cnt].dis=w;
}
inline void insert(ll x)
{
	for(int i=61;~i;i--)
	{
		if(!(x&(1ll<<i)))continue;
		if(!xord[i]){xord[i]=x;break;}
		else x^=xord[i];
	}
}
inline ll query(ll x)
{
	ll res=x;
	for(int i=61;~i;i--)if((res^xord[i])>res)res^=xord[i];
	return res;
}
void dfs(int x,ll res)
{
	vis[x]=1;sum[x]=res;
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(!vis[y])dfs(y,res^e[i].dis);
		else insert(res^sum[y]^e[i].dis);
	}
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read();ll w=read();
		add(u,v,w),add(v,u,w);
	}
	dfs(1,0);
	printf("%lld",query(sum[n]));
	return 0;
}
```


---

## 作者：ghj1222 (赞：1)

然后呢这道题其实很简单

我们先考虑一种简单的情况，从1直接走到n(不管怎么走的，反正就是走)  然后就能找到一个路径了  

这个走的过程用各种zmj算法都能过

然后呢我们发现如果直接走基本不会得到最优解，~~考虑模拟退火~~

考虑增广

一个增广方法是，从某一个点开始走到一个环，在环上走一圈，然后原路返回，如图

![wet.png](https://i.loli.net/2018/09/06/5b9107b76e651.png)

然后呢这个图画的有点丑了

我们发现，增广的路径就是环上的路径，往返的路径上两次xor就xor没了，对答案的贡献为0

然后所以我们枚举所有环，把这条环的xor扔进线性基，查询时候直接用1到n的一条路径去查询这个长度被线性基乱搞后的最大值

这题也就蓝题难度吧竟然是黑题

```cpp
#include <bits/stdc++.h>
using namespace std;

struct edge
{
    int v;
    long long w;
    int ne;
}a[200010];

int n, m, tmp;
int h[50010];
long long dis[50010];
bool vis[50010];
long long linear_basis[70];

void add(int u, int v, long long w)
{
    a[++tmp] = (edge){v, w, h[u]};
    h[u] = tmp;
}

bool insert(long long x)
{
    for (int i = 63; i >= 0; i--)
    {
        if (x & (1LL << i))
        { 
            if(linear_basis[i] == 0)
            {
                linear_basis[i] = x;
                return true;
            }
            x ^= linear_basis[i];
        }
    }
    return false;
}

long long query(long long x)
{
    for (int i = 63; i >= 0; i--)
        if ((x ^ linear_basis[i]) > x)
            x ^= linear_basis[i];
    return x;
}

void search(int x, long long y)
{
    dis[x] = y;
    vis[x] = 1;
    for (int i = h[x]; i != 0; i = a[i].ne)
        if (vis[a[i].v] == 0)
            search(a[i].v, y ^ a[i].w);
        else
            insert(y ^ a[i].w ^ dis[a[i].v]);
}

int main()
{
    scanf("%d%d", &n, &m);
    long long z;
    for (int x, y, i = 1; i <= m; i++)
    {
        scanf("%d%d%lld", &x, &y, &z);
        add(x, y, z);
        add(y, x, z);
    }
    search(1, 0);
    printf("%lld\n", query(dis[n]));
    return 0;
}
```

---

## 作者：CG__HeavenHealer (赞：0)


### 题意

给一张 $n$ 个点， $m$ 条边的图，可能有自环或重边，每条边上有一个权值，问从第 $1$ 号点到第 $n$ 号点的最大权值异或和是多少。

### 解法

看到异或和最大，第一反应就是线性基（不懂 [看这里](https://www.luogu.com.cn/problem/P3812) 和 [这里的例题](https://www.luogu.com.cn/problem/P4570) ）。

题目中有一句话很重要：

- 路径可以重复经过某些点或边，当一条边在路径中出现了多次时，其权值在计算 XOR 和时也要被计算相应多的次数

这句话告诉我们，**如果有一条边或相关联的几条边走了偶数次，那么就相当于没走，**计算答案时，这一部分对答案没有贡献。

由此可知，**如果图中有一部分在环上，可能走两次，那么它对答案的唯一作用就是到达其他未到达的点。**

如果从第 $1$ 号点到第 $n$ 号点没有环：显然直接从 $1$ 走到 $n$ 就可以了~~（要不也没别的走法）~~

如果有环：

![](https://cdn.luogu.com.cn/upload/image_hosting/dreosor3.png)

如图，从 $1$ 到 $n$ 有三条路径：

1. $1 - 3 - 7 - 6 - 8 - 9$
2. $1 - 2 - 5 - 6 - 7 - 3 - 4 - 5 - 6 - 8 - 9$ （$5,6$ 都走了两次）
3. $1 - 3 - 4 - 5 - 6 - 9$

由上可以看出，如果经过环的话，按照贪心思想，只要环中的点能放进线性基里，就从环里走一遍。

那如果一条边或互相关联的几条边经过了好几个环呢？

其实只要沿着这条边（或几条边）绕着环遍历就行了，原因就是两个环之间的那几条边一定会走两次，最后统计出的答案与它们无关，无需考虑减去它们。

![](https://cdn.luogu.com.cn/upload/image_hosting/wi0j32t4.png)

如图，标红的地方走了两次，最后统计到的是大圈上的异或和。

### Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define ri register int
const int N = 2e5 + 10;
inline int read() {
    int x = 0;
    char ch = getchar();
    bool f = 1;
    while (!isdigit(ch)) {
        if (ch == '-') f = 0;
        ch = getchar();
    }
    while (isdigit(ch)) {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    return f ? x : -x;
}
struct Edge {
    int to, nxt, w;
} e[N];
int head[N], cnt = 1;
inline void add(int u, int v, int w) {
    e[++cnt].to = v;
    e[cnt].w = w;
    e[cnt].nxt = head[u];
    head[u] = cnt;
}
struct Linear_Base {
    int base[70];
    inline void Add(int x) {
        for (ri i = 61; ~i; i--)
            if (x & (1ll << i)) {
                if (!base[i])
                    return base[i] = x, void();
                else x ^= base[i];
            }
        return;
    }
    inline int ask(int x) {
        int res = x;
        for (ri i = 61; ~i; i--)
            if (base[i]) res = max(res, res ^ base[i]);
    	return res;
	}
} B;
int dis[N];
bool vis[N];
void dfs(int u, int edge) {
    vis[u] = true;
    for (ri i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to, w = e[i].w;
        if (i == (edge ^ 1)) continue;//由于是无向边，这里运用到了异或的成对变换，例如，2 xor 1 = 3, 3 xor 1 = 2 等，方便存储。
        if (!vis[v]) {
            dis[v] = dis[u] ^ w;
            dfs(v, i);
        } else
            B.Add(dis[u] ^ dis[v] ^ w);
    }
}
signed main() {
    int n = read(), m = read();
    while (m--) {
        int u = read(), v = read(), w = read();
        add(u, v, w), add(v, u, w);
    }
    return dfs(1, -1), printf("%lld", B.ask(dis[n])), 0;
}
```









---

## 作者：huayucaiji (赞：0)

复习 WC2020 的时候看到了这道题：不会做。  
学完了线性基：~~水题~~

裸的线性基，只不过需要一些变化。

我们首先需要对图构建一颗随意的生成树。只要是颗树即可。比如说我们构造出了如下的一张图（其中边权为 `....` 的代表这之间可能省略了一些边）：

![1](http://image.qingtengbc.com/2021/03/07/5349fa2d65311.png)

我们可以通过一次 DFS 求出每个点到根节点，即 $2$ 号点，的距离 $dis_i$。**注意根节点不一定是 $2$，最好不要是 $1$ 或 $n$，没试过是否可以。**

显然我们还有一些不在生成树里的边，对于这些边，有一个废话一样的性质，就是他们加进图去后，至少会产生一个新的环。比如说我们加入一条边 $(k_2,k_3)$，得到图：

![2](http://image.qingtengbc.com/2021/03/07/c490d61115da2.png)

我们得到了一个环 $k_1,k_2,k_3,\cdots,k_n$，环的权值是 $val_c=val_1 \operatorname{xor} val_2\operatorname{xor} val_3\cdots\operatorname{xor} val_n$。我们的 $1->n$ 的路径上如果要经过这个环怎么办呢？我们可以这样想，其实我们遍历一下这个环得到的权值是 $dis_1 \operatorname{xor} dis_{k_1} \operatorname{xor} val_c \operatorname{xor} dis_{k_1} \operatorname{xor} dis_1=val_c$。因此只是把这个环的权值加了进去。

由于任意一个环都可以用几个环异或出来，我们只需要把每条新加入的边形成的环加到线性基里，求出最大值后，再异或上必须要有的 $dis_1$ 和 $dis_n$，就是答案。

时间复杂度 $O(n)$。

```cpp
//Don't act like a loser.
//This code is written by huayucaiji
//You can only use the code for studying or finding mistakes
//Or,you'll be punished by Sakyamuni!!!
#include<bits/stdc++.h>
#define int long long
using namespace std;

int read() {
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}

const int MAXN=5e4+10;

int n,m,cnt;
int p[100],h[MAXN],father[MAXN],dis[MAXN];

int find(int x) {
	if(x!=father[x]) {
		return father[x]=find(father[x]);
	}
	return father[x];
}

void insert(int x) {
	for(int i=63;i>=0;i--) {
		if(!(x&(1ll<<i))) {
			continue;
		}
		if(!p[i]) {
			p[i]=x;
			break;
		}
		x=p[i]^x;
	}
}

struct edge {
	int u,v,w,next;
	bool tree;
}e[MAXN<<2];

void addedge(int u,int v,int w) {
	e[++cnt].u=u;
	e[cnt].v=v;
	e[cnt].w=w;
	e[cnt].next=h[u];
	h[u]=cnt;
}

void generate_tree() {
	for(int i=1;i<=m;i++) {
		if(find(e[i].u)!=find(e[i].v)) {
			father[find(e[i].u)]=find(e[i].v);
			e[i].tree=1;
			e[i+1].tree=1;
		}
	}
}
void dfs(int u,int fa) {
	for(int i=h[u];i;i=e[i].next) {
		if(!e[i].tree) {
			continue;
		}
		int v=e[i].v;
		
		if(v!=fa) {
			dis[v]=dis[u]^e[i].w;
			dfs(v,u);
		}
	}
}

signed main() {
	cin>>n>>m;
	for(int i=1;i<=n;i++) {
		father[i]=i;
	}
	for(int i=1;i<=m;i++) {
		int u,v,w;
		u=read();
		v=read();
		w=read();
		addedge(u,v,w);
		addedge(v,u,w);
	}
	m<<=1;
	
	generate_tree();
	dfs(2,0);
	
	for(int i=1;i<=m;i++) {
		if(!e[i].tree) {
			insert(dis[e[i].u]^dis[e[i].v]^e[i].w);
		}
	}
	
	int ans=dis[1]^dis[n];
	for(int i=63;i>=0;i--) {
		ans=max(ans,ans^p[i]);
	}
	
	cout<<ans<<endl;
	return 0;
}

```

---

## 作者：Mihari (赞：0)

# 题目

[传送门](https://www.luogu.com.cn/problem/P4151)

# 题解

由于路径价值为异或和，显然一条路如果重复走就没有价值了。

我们可以考虑选取一条从 $1$ 到 $N$ 的简单路径，中间的路径用**环**进行拓展。

但是，我们从简单路径到环，中间还要经过一条路径，这条路径考虑会走几遍：首先，我们从简单路径到环会走一遍，然后我们从环再走到路径上，会走两遍，根据异或的特性，这条路径被异或两次，那么就没有贡献。

那么，我们所选取的路径价值就是：
$$
W_{简单路径}\oplus W_{拓展环}
$$
但是，简单路径的价值如果没有找到最优，会不会对我们的答案造成影响呢？

考虑这样一种形式：

![](https://i.postimg.cc/gjB9vsrH/ZAA-HI-AVU-UOX-H0-WZ4-G.png)

假设我们找到的任意一条简单路径是 $S-n_1-n_2-n_3-T$，但是我们从 $S-n_4-n_5-n_6-T$ 更优，那么，我们最后在枚举 $W_{简单路径}\oplus W_{拓展环}$ 时，我们会遇到 $W_{S-n_1-n_2-n_3-T}\oplus W_{环:S-n_1-n_2-n_3-T-n_6-n_5-n_4-S}$，那么，这条路径实际上就变成了 $W_{S-n_4-n_5-n_6-T}$。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i,__l,__r) for(signed i=(__l),i##_end_=(__r);i<=i##_end_;++i)
#define fep(i,__l,__r) for(signed i=(__l),i##_end_=(__r);i>=i##_end_;--i)
#define writc(a,b) fwrit(a),putchar(b)
#define mp(a,b) make_pair(a,b)
#define ft first
#define sd second
#define LL long long
#define ull unsigned long long
#define uint unsigned int
#define pii pair< int,int >
#define Endl putchar('\n')
// #define int long long
// #define int unsigned
// #define int unsigned long long

#define cg (c=getchar())
template<class T>inline void qread(T& x){
    char c;bool f=0;
    while(cg<'0'||'9'<c)f|=(c=='-');
    for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    if(f)x=-x;
}
inline int qread(){
//just for int(When the code defines int long long, the function is just for long long)
    int x=0;char c;bool f=0;
    while(cg<'0'||'9'<c)f|=(c=='-');
    for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    return f?-x:x;
}
#undef cg
// template<class T,class... Args>inline void qread(T& x,Args&... args){qread(x),qread(args...);}
template<class T>inline T Max(const T x,const T y){return x>y?x:y;}
template<class T>inline T Min(const T x,const T y){return x<y?x:y;}
template<class T>inline T fab(const T x){return x>0?x:-x;}
inline int gcd(const int a,const int b){return b?gcd(b,a%b):a;}
inline void getInv(int inv[],const int lim,const int MOD){
    inv[0]=inv[1]=1;for(int i=2;i<=lim;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
}
template<class T>void fwrit(const T x){//just short,int and long long
    if(x<0)return (void)(putchar('-'),fwrit(-x));
    if(x>9)fwrit(x/10);
    putchar(x%10^48);
}
inline LL mulMod(const LL a,const LL b,const LL mod){//long long multiplie_mod
    return ((a*b-(LL)((long double)a/mod*b+1e-8)*mod)%mod+mod)%mod;
}

const int MAXN=5e4;
const int MAXM=1e5;

struct edge{
    int to,nxt;
    LL w;
}e[(MAXM<<1)+5];
int tail[MAXN+5],ecnt;
inline void add_edge(const int u,const int v,const LL w){
    e[++ecnt]=edge{v,tail[u],w};tail[u]=ecnt;
    e[++ecnt]=edge{u,tail[v],w};tail[v]=ecnt;
}

template<class T>struct Basic{
    #define MAXSIZE 60
    LL f[MAXSIZE+5],flg;
    //flg 记录插入时是否有不能放入的数
    /*
    inline int high_pos(T num){
        int ret=-1;
        while(num>0)num>>=1,++ret;
        return ret;
    }
    inline void insert(T num){
        int t;
        while(num && f[t=high_pos(num)])num^=f[t];
        if(num)f[t]=num;
        else flg=true;
    }
    */
    inline void insert(T num){
        fep(i,MAXSIZE,0){
            if(!(num>>i))continue;
            if(!f[i]){f[i]=num;return;}
            num^=f[i];
        }
        flg=true;
    }
    inline T queryMax(T ret){
        fep(i,60,0)if((ret^f[i])>ret)
            ret^=f[i];
        return ret;
    }
    inline T queryMin(){
        if(flg)return 0;
        T ret=(1ll<<MAXSIZE);
        rep(i,0,60)ret=Min(ret,f[i]);
    }
};
Basic<LL>G;

int n,m;

LL ans;

bool vis[MAXN+5];

LL pw[MAXN+5];

void dfs(const int u,const LL w){
    if(u==n)ans=w;
    if(vis[u])return G.insert(w^pw[u]);
    vis[u]=true,pw[u]=w;
    for(int i=tail[u];~i;i=e[i].nxt)
        dfs(e[i].to,w^e[i].w);
}

signed main(){
    memset(tail,-1,sizeof tail);
    // cin>>n>>m;
    scanf("%d %d",&n,&m);
    int u,v;LL w;
    rep(i,1,m){
        // cin>>u>>v>>w;
        scanf("%d %d %lld",&u,&v,&w);
        add_edge(u,v,w);
    }
    dfs(1,0);
    cout<<G.queryMax(ans)<<'\n';
    return 0;
}
```



---

## 作者：vocaloid (赞：0)

线性基 + 搜索。

智推几度推到此题，奈何当时惧于题目难度没有细做，今日无意间又做此题，方才发现——

~~这 TM 不一 ** 题吗~~

说回这道题，要使路径的异或和最大，说到异或和，就想起线性基。~~再次两开花~~

题目说可以在环上走来走去，那么我们就考虑在每个环上走来走去产生的影响，显然，影响就相当于异或上这个环的异或和，所以我们考虑处理出每个环的异或和，把它丢到线性基里面去，最后计算一遍就可以带走这道题了。

~~感觉是黑题里最简单的那种了~~

```cpp
#include<bits/stdc++.h>
#define MAXN 50005
#define MAXM 100005
#define K 60
#define reg register
#define inl inline
#define stc static
#define ll long long
using namespace std;
stc int cnt,fst[MAXN],to[MAXM<<1],nxt[MAXM<<1];
stc int n,m;
stc ll dis[MAXN],w[MAXM<<1],p[K<<1];
stc bool vis[MAXN];
template <typename T> inl void Read(reg T &x)
{
	x=0;
	reg int fu=1;
	reg char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') fu=-1;
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch-48);
	x*=fu;
}
inl void AddEdge(reg int u,reg int v,reg ll c)
{
	to[++cnt]=v;
	nxt[cnt]=fst[u];
	fst[u]=cnt;
	w[cnt]=c;
}
inl void Modify(reg ll x)
{
	for(reg int i=K;i>=0;i--)
	{
		if(x&(1ll<<i))
		{
			if(p[i]) x^=p[i];
			else
			{
				p[i]=x;
				break;
			}
		}
	}
}
void Dfs(reg int u)
{
	vis[u]=1;
	for(reg int i=fst[u];i;i=nxt[i])
	{
		reg int v=to[i];
		if(vis[v]) Modify(dis[u]^dis[v]^w[i]);
		else
		{
			dis[v]=dis[u]^w[i];
			Dfs(v);
		}
	}
}
inl ll Query(reg ll x)
{
	reg ll res=x;
	for(reg int i=K;i>=0;i--) if((res^p[i])>res) res^=p[i];
	return res;
}
int main()
{
	Read(n);
	Read(m);
	for(reg int i=1;i<=m;i++)
	{
		reg int x,y;
		reg ll z;
		Read(x);
		Read(y);
		Read(z);
		AddEdge(x,y,z);
		AddEdge(y,x,z);
	}
	Dfs(1);
	ll ans=Query(dis[n]);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Linne (赞：0)

交了个黑题居然一发A了感天动地
讲真这个题十分的傻逼..
我们先随便求一条从1到n的路径，然后发现因为我们可以来回走，环可以对结果造成一定影响。具体来讲，如果我们在路径的基础上选了一个环，那么，我们相当于替换了路径的一段（这个是xor的性质）。显见我们只需要考虑xor上一些环。那么把每个环的xor和看作一个数，这个就变成一个linear_base裸题了，只要把路径xor和在lb中查询即可。
你甚至不需要管什么重边和自环。
附AC代码。
```

#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
#define RE register
#define clear(a) memset(a,0,sizeof a)

inline int read(){
    int date=0,w=1;char c=0;
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
    return date*w;
}

void chkmin(int &x,int y){
	x=min(x,y);
}
void chkmax(int &x,int y){
	x=max(x,y);
}
const int N=400000;
ll m,n,x,y,z,tot,nxt[N],ver[N],edge[N],head[N],dis[N],a[N]; 
void add(ll x,ll y,ll z){
	ver[++tot]=y;edge[tot]=z;nxt[tot]=head[x];head[x]=tot; 
}
void ins(ll x);
void dfs(ll x){
	for(ll i=head[x];i;i=nxt[i]){
		ll y=ver[i],z=edge[i];
		if(dis[y]){
			ins(dis[y]^dis[x]^z);
		}
		else {
			dis[y]=dis[x]^z;
			dfs(y);
		}
	}
}
void ins(ll x){
	for(int i=63;i>=0;--i){
		if(x&(1ll<<i)){
			if(!a[i]){
				a[i]=x;
				break;
			}
			else x^=a[i];
		}
	}
}
ll query(ll x){
	ll ret=x;
	for(int i=63;i>=0;--i){
		if((ret^a[i])>ret)ret^=a[i];
	}
	return ret;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>m;
    for(int i=1;i<=m;++i){
    	cin>>x>>y>>z;
		add(x,y,z);
		add(y,x,z); 
	}
	dfs(1);
	cout<<query(dis[n])<<endl; 
	return 0;
}

```


---


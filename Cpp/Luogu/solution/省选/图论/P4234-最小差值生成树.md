# 最小差值生成树

## 题目描述

给定一个点标号从 $1$ 到 $n$ 的、有 $m$ 条边的无向图，求边权最大值与最小值的差值最小的生成树。图可能存在自环。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 100$，$m \leq 10^3$。
- 对于 $97\%$ 的数据，保证 $n \leq 500$，$m \leq 10^5$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 5 \times 10^4$，$1 \leq m \leq 2 \times 10^5$，$1 \leq u, v \leq n$，$1 \leq w \leq 10^4$。

## 样例 #1

### 输入

```
4 6 
1 2 10 
1 3 100 
1 4 90 
2 3 20 
2 4 80 
3 4 40 
```

### 输出

```
20```

# 题解

## 作者：Soulist (赞：25)

首先要先想明白怎么用$LCT$求最小生成树

[~~于是我又不要脸$QWQ$的推荐了~~](https://www.luogu.org/blog/Soulist/solution-p3366)

然后我们考虑这道题怎么做

要保证边权差最小，不妨假设当前边权为$k$，则此时我们需要最小边权最大。

所以可以按照边权排序。

类似于求最小生成树的方法，我们每次加边后都需要判一下连通性，如果联通就减去边权中最小值。

至于如何求出所有边权中的最小值，因为已经排序，所以有下标小的点其点权一定小。

所以我们可以用 $book$ 数组来标记那些点已经被标记，然后类似与队列的一个一个弹$?$

当然，需要统计答案的时候，还要判断$Id_{num}$（合并次数）（当前联通块数量是否为1）是否为$n-1$

区别与最小生成树的模板，因为我们有编号小的点且为边的点其越小，所以我们可以这样写$pushup(x)$

```cpp
void pushup( int x ) {
	t[x].id = x;
	if( t[ls(x)].id > n && ( t[x].id <= n || t[x].id > t[ls(x)].id ) ) t[x].id = t[ls(x)].id;
	if( t[rs(x)].id > n && ( t[x].id <= n || t[x].id > t[rs(x)].id ) ) t[x].id = t[rs(x)].id; 
    //如果当前的点为点点，而儿子有边点，则复制儿子
    //如果当前点位边点，但编号大于儿子，也复制儿子
}
```

其他部分与最小生成树做法异斧同工

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
#define ls(x) t[x].son[0]
#define rs(x) t[x].son[1]
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define inf 99999999
const int M = 200000 + 5;
const int N = 50000 + 5;
struct E{
	int from, to, w;
}e[M * 2];
struct LCT {
	int son[2], fa, id;
	bool mark;
}t[2 * M];
int ans, Idnum, Idnex, st[M * 2], book[2 * N], n;
bool cmp( E x, E y ) {
	return x.w < y.w;
}
bool isroot( int x ) {
	return ( ls(t[x].fa) != x ) && ( rs(t[x].fa) != x );
}
void pushup( int x ) {
	t[x].id = x;
	if( t[ls(x)].id > n && ( t[x].id <= n || t[x].id > t[ls(x)].id ) ) t[x].id = t[ls(x)].id;
	if( t[rs(x)].id > n && ( t[x].id <= n || t[x].id > t[rs(x)].id ) ) t[x].id = t[rs(x)].id;
}
void pushmark( int x ) {
	if( t[x].mark ) {
		t[x].mark = 0, t[ls(x)].mark ^= 1, t[rs(x)].mark ^= 1;
		swap( ls(x), rs(x) );
	}
}
void rotate( int x ) {
	int f = t[x].fa, ff = t[f].fa, qwq = ( rs(f) == x );
	t[x].fa = ff;
	if( !isroot(f) ) t[ff].son[rs(ff) == f] = x;
	t[t[x].son[qwq ^ 1]].fa = f, t[f].son[qwq] = t[x].son[qwq ^ 1];
	t[f].fa = x, t[x].son[qwq ^ 1] = f;
	pushup(f), pushup(x); 
}
void Splay( int x ) {
	int top = 0, now = x; st[++top] = now;
	while( !isroot(now) ) st[++top] = ( now = t[now].fa );
	while( top ) pushmark( st[top--] );
	while( !isroot(x) ) {
		int f = t[x].fa, ff = t[f].fa;
		if( !isroot(f) ) ( ( rs(ff) == f ) ^ ( rs(f) == x ) ) ? rotate(x) : rotate(f);
		rotate(x);
	}
}
void access( int x ) {
	for( int y = 0; x; y = x, x = t[y].fa ) 
		Splay( x ), t[x].son[1] = y, pushup(x);
}
void makeroot( int x ) {
	access(x), Splay(x), t[x].mark ^= 1, pushmark( x );
}
int findroot( int x ) {
	access( x ), Splay( x ), pushmark(x);
	while( ls(x) ) pushmark( x = ls(x) );
	return x;
}
void split( int x, int y ) {
	makeroot( x ), access( y ), Splay( y );
}
bool check( int x, int y ) {
	makeroot( x );
	return findroot(y) != x;
}
void link( int x, int y ) {
	makeroot( x );
	t[x].fa = y;
} 
signed main()
{
	n = read(); int m = read(), ll = 0, x, y, now;
	
	rep( i, 1, m )  e[i].from = read(), e[i].to = read(), e[i].w = read();
	sort( e + 1, e + m + 1, cmp );
	
	Idnex = n, ll = 1, ans = inf;
	
	rep( i, 1, m ) {
		++Idnex;
		x = e[i].from, y = e[i].to;
		if( e[i].to == e[i].from ) { book[i] = 1; continue; }
		
		if( check( e[i].from, e[i].to ) )
			link( e[i].from, Idnex ), link( Idnex, e[i].to ), ++ Idnum;
		else {
			split( x, y ), now = t[y].id;
			book[now - n] = 1, Splay( now );
			t[ls(now)].fa = t[rs(now)].fa = 0;
			link( x, Idnex ), link( Idnex, y );
		}
		while( book[ll] && ll <= i ) ++ ll; 
		if( Idnum >= n - 1 ) ans = min( ans, e[i].w - e[ll].w );
	}
	printf("%d\n", ans);
	return 0;
}

```

```

---

## 作者：FlashHu (赞：17)

和魔法森林有点像，都是动态维护最小生成树（可参考一下[Blog的LCT总结](http://www.cnblogs.com/flashhu/p/8324551.html)相关部分）

至于从小到大还是从大到小当然无所谓啦，我是从小到大排序，每次枚举边，还没连通就连，已连通就替换环上最小的一条边，可以保证最优。如果已经构成了生成树，就可以更新答案，因为当前枚举到的一定是生成树里最大的，所以直接用当前减去最小更新答案。

至于最小的怎样维护，其实根本不需要什么别的set什么的数据结构。只要标记一下在生成树中的边，再搞一个指针指向在树中最小的边就好啦。当最小的边也被替换，就把指针后移，直到再找到一个在树中的边为止。

吐槽：注意了，有自环！！！我~~本来该1A却~~调试了2h，本地拿管理员的标程自造数据（没造自环）对拍几十万组无问题？！

卡常的地方挺多的，在LCT中应该算挺快的吧（比下面Niko巨佬的LCT代码快了$1 \over 3$左右，但是Niko巨佬写了个rank1的代码？！仔细看了下，是优化的暴力？貌似会被卡成$O(NM)$？！强烈建议再加强数据。。。。。。
```
#include<cstdio>
#include<algorithm>
using namespace std;
#define R register int
#define I inline void
#define lc c[x][0]
#define rc c[x][1]
#define in(z) ini=&z;\
    while(*++q<'-');\
    *ini=*q&15;\
    while(*++q>'-')*ini*=10,*ini+=*q&15//读入卡常
const int N=50001,M=200009,L=N+M;
int f[L],c[L][2],mn[L],ff[N];
unsigned short v[L];//short卡常
bool r[L],vis[M];
char str[M<<6];
struct EDGE{
    int u,v,l;
    inline bool operator<(EDGE x)const{
        return l<x.l;
    }
}e[M];
inline bool nroot(R x){return c[f[x]][0]==x||c[f[x]][1]==x;}
inline int get(R x,R y){return v[x]<v[y]?x:y;}
I pushup(R x){mn[x]=get(x,get(mn[lc],mn[rc]));}
I pushdown(R x){
    if(r[x]){
        R t=lc;
        r[lc=rc]^=1;r[rc=t]^=1;r[x]=0;
    }
}
I pushall(R x){
    if(nroot(x))pushall(f[x]);
    pushdown(x);
}
I rotate(R x){
    R y=f[x],z=f[y],k=c[y][1]==x,w=c[x][!k];
    if(nroot(y))c[z][c[z][1]==y]=x;c[x][!k]=y;c[y][k]=w;
    f[w]=y;f[y]=x;f[x]=z;
    pushup(y);
}
I splay(R x){
    R y=x;
    pushall(x);
    while(nroot(x)){
        if(nroot(y=f[x]))
            rotate((c[y][0]==x)^(c[f[y]][0]==y)?x:y);
        rotate(x);
    }
    pushup(x);
}
I access(R x){
    for(R y=0;x;x=f[y=x])
        splay(x),rc=y,pushup(x);
}
I mroot(R x){
    access(x);splay(x);
    r[x]^=1;
}
I link(R i){//卡常版写法
    mroot(e[i].u);
    f[f[e[i].u]=N+i]=e[i].v;
}
I cut(R x){//也是卡常版写法
    access(e[x-N].u);splay(x);
    lc=rc=f[lc]=f[rc]=0;
}
int getf(R x){//并查集卡常
    if(x==ff[x])return x;
    return ff[x]=getf(ff[x]);
}
int main(){
    fread(str,1,sizeof(str),stdin);//fread卡常
    R n,m,i,x,y,h,cnt,ans,*ini;
    register char*q=str-1;
    in(n);in(m);
    for(i=0;i<=n;++i)
        ff[i]=i,v[i]=-1;
//-1放在unsigned里等于是极大值，注意v[0]也改了
    for(i=1;i<=m;++i){
        in(e[i].u);in(e[i].v);in(e[i].l);
    }
    sort(e+1,e+m+1);
    for(cnt=h=i=1;i<=m;++i){
        v[i+N]=e[i].l;
        if(getf(x=e[i].u)!=getf(y=e[i].v))
        {
            vis[i]=1,link(i),ff[ff[x]]=ff[y],++cnt;
            if(cnt==n)ans=e[i].l-e[h].l;
//刚完全建好生成树要马上更新答案
        }
        else{
            if(x==y)continue;
            vis[i]=1;
            mroot(x);
            access(y);splay(y);
            vis[mn[y]-N]=0;while(!vis[h])++h;//维护好最小边
            cut(mn[y]);link(i);
            if(cnt==n)ans=min(ans,e[i].l-e[h].l);
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Flanksy (赞：6)

### 二分、线段树分治

一眼 LCT，然而由于我不会 LCT，这里是另一种做法。

-------

看到 LCT 容易想到动态图连通性从而想到线段树分治，本题中 LCT 能够配合双指针动态删边加边，线段树分治做不到。

我们充分发扬人类智慧，类比二分加单调栈 $O(n \log n)$ 替代单调队列 $O(n)$ 的传奇做法，首先二分答案，这样加边和删边的顺序可以提前得到，然后跑线段树分治判断在加边删边过程中是否出现生成树即可。

总体时间复杂度 $O(m \log m \log n \log V)$，其中 $V$ 为边权的值域。

不开 O2 也能过。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Edge{int x,y,w;}e[200'005];
int n,m,ans,mem,sum,f[50'005],h[50'005],tim[200'005];
vector<pair<int,int>> v[1'600'005];
vector<Edge> c[1'600'005];
pair<int,int> p[200'005];
inline int ask(int x){
    while(x!=f[x]) x=f[x];
    return x;
}
inline void combine(int x,int y){
    x=ask(x),y=ask(y);
    f[x]=y,h[y]+=h[x]==h[y];
}
void update(int u,int l,int r,int ql,int qr,pair<int,int> x){
    if(l>=ql&&r<=qr) return v[u].push_back({x});
    int mid=(l+r)>>1;
    if(ql<=mid) update(u*2,l,mid,ql,qr,x);
    if(qr>mid) update(u*2+1,mid+1,r,ql,qr,x);
}
void segsort(int u,int l,int r){
    for(auto [i,j]:v[u]){
        int x=ask(i),y=ask(j);
        if(h[x]>h[y]) swap(x,y);
        if(x!=y) c[u].push_back({x,y,h[x]==h[y]}),combine(x,y);
    }
    sum+=c[u].size(),mem=max(mem,sum);
    int mid=(l+r)>>1;
    if(l!=r) segsort(u*2,l,mid),segsort(u*2+1,mid+1,r);
    reverse(c[u].begin(),c[u].end());
    for(auto [x,y,w]:c[u]) f[x]=x,h[y]-=w;
    sum-=c[u].size(),c[u].clear(),v[u].clear();
    c[u].shrink_to_fit(),v[u].shrink_to_fit();
}
bool fail(int x){
    int l=1,r=1,now=0,maxlen=0;
    while(l<=m){
        while(r<=m&&e[r].w-e[l].w<=x) tim[r]=++now,++r;
        maxlen=max(maxlen,r-l),p[l]={tim[l],++now},++l;
    }
    if(maxlen<n-1) return 1;
    for(int i=1;i<=m;i++) update(1,1,now,p[i].first,p[i].second,{e[i].x,e[i].y});
    for(int i=1;i<=n;i++) f[i]=i,h[i]=1;
    mem=0,segsort(1,1,now);
    return mem!=n-1;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=m;i++) cin>>e[i].x>>e[i].y>>e[i].w;
    sort(e+1,e+m+1,[](auto x,auto y){return x.w<y.w;});
    int l=0,r=e[m].w-e[1].w;
    while(l<=r){
        int mid=(l+r)>>1;
        if(fail(mid)) l=mid+1;
        else ans=mid,r=mid-1;
    }
    cout<<ans<<'\n';
    return 0;
}
```

---

## 作者：水库中的水库 (赞：6)

[博客食用更佳哦](http://ljf-cnyali.cn/2019/08/20/LuoguP4234%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC%E7%94%9F%E6%88%90%E6%A0%91-LCT/)

题目大意:给定一个图，求边权最大值与最小值的差值最小的生成树

这种题很显然跟LCT有关，首先将边权按照从小到大排序，固定边权最大值，为了保证答案更优，只需要维护边权最小值最大即可

LCT维护最小值$Min$和点权值最小的位置$MinPos$，考虑当前添加$u,v,w$的一条边

-   如果$u,v$不连通，直接$Link$

-   $Split(u,v)$找到$MinPos$并删去，连上$u,v$这条边，可以保证边权最小值最大

这道题细节在于如何保证当前是一棵最小生成树，可以拿一个$num$计数，如果遇见第一种情况就$++num$，当$num=n-1$的时候就是一棵生成树

因为每条边只会被加入和删除一次，记录最小生成树的最小值可以直接给每条边记录一个$vis$，判断答案的时候暴力跳即可

注意有自环需要特判

```cpp
/***************************************************************
	File name: P4234.cpp
	Author: ljfcnyali
	Create time: 2019年08月18日 星期日 11时02分49秒
***************************************************************/
#include<bits/stdc++.h>

using namespace std;

#define REP(i, a, b) for ( int i = (a), _end_ = (b); i <= _end_; ++ i ) 
#define mem(a) memset ( (a), 0, sizeof ( a ) ) 
#define str(a) strlen ( a ) 
#define ls(x) Tree[x].son[0]
#define rs(x) Tree[x].son[1]
#define fa(x) Tree[x].fa
typedef long long LL;

const int maxn = 5000010;

struct node
{
    int son[2], Min, id, fa, lazy;
} Tree[maxn];

int n, m, w[maxn], num, Min, ans = 0x3f3f3f3f;
bool vis[maxn];

struct Node
{
    int u, v, w;
    bool operator < (const Node &a) const { return w < a.w; } 
} a[maxn];

inline bool IsRoot(int x) { return (ls(fa(x)) == x || rs(fa(x)) == x) ? false : true; }

inline void PushUp(int x)
{
    Tree[x].Min = w[x]; Tree[x].id = x;
    if ( ls(x) && Tree[ls(x)].Min < Tree[x].Min ) { Tree[x].Min = Tree[ls(x)].Min; Tree[x].id = Tree[ls(x)].id; }
    if ( rs(x) && Tree[rs(x)].Min < Tree[x].Min ) { Tree[x].Min = Tree[rs(x)].Min; Tree[x].id = Tree[rs(x)].id; }
}

inline void Update(int x) { Tree[x].lazy ^= 1; swap(ls(x), rs(x)); }

inline void PushDown(int x)
{
    if ( !Tree[x].lazy ) return ;
    if ( ls(x) ) Update(ls(x));
    if ( rs(x) ) Update(rs(x));
    Tree[x].lazy = 0;
}

inline void Rotate(int x)
{
    int y = fa(x), z = fa(y), k = rs(y) == x, w = Tree[x].son[!k];
    if ( !IsRoot(y) ) Tree[z].son[rs(z) == y] = x;
    fa(x) = z; fa(y) = x; if ( w ) fa(w) = y;
    Tree[x].son[!k] = y; Tree[y].son[k] = w;
    PushUp(y);
}

inline void Splay(int x)
{
    stack<int> Stack; int y = x, z; Stack.push(y);
    while ( !IsRoot(y) ) Stack.push(y = fa(y));
    while ( !Stack.empty() ) { PushDown(Stack.top()); Stack.pop(); }
    while ( !IsRoot(x) ) 
    {
        y = fa(x); z = fa(y);
        if ( !IsRoot(y) ) Rotate((ls(y) == x) ^ (ls(z) == y) ? x : y);
        Rotate(x);
    }
    PushUp(x);
}

inline void Access(int root) { for ( int x = 0; root; x = root, root = fa(root) ) { Splay(root); rs(root) = x; PushUp(root); } }

inline void MakeRoot(int x) { Access(x); Splay(x); Update(x); }

inline int FindRoot(int x) { Access(x); Splay(x); while ( ls(x) ) x = ls(x); Splay(x); return x; }

inline void Link(int u, int v) { MakeRoot(u); if ( FindRoot(v) != u ) fa(u) = v; }

inline void Cut(int u, int v) { MakeRoot(u); if ( FindRoot(v) != u || fa(v) != u || ls(v) ) return ; fa(v) = rs(u) = 0; }

inline void Split(int u, int v) { MakeRoot(u); Access(v); Splay(v); }

inline bool Check(int u, int v) { MakeRoot(u); return FindRoot(v) == u; }

int main()
{
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif
    scanf("%d%d", &n, &m);
    REP(i, 1, m) scanf("%d%d%d", &a[i].u, &a[i].v, &a[i].w);
    sort(a + 1, a + m + 1);
    REP(i, 1, n) w[i] = 0x3f3f3f3f; REP(i, n + 1, n + m) w[i] = a[i - n].w;
    REP(i, 1, m)
    {
        if ( a[i].u == a[i].v ) continue ;
        if ( !Check(a[i].u, a[i].v) ) 
        {
            Link(a[i].u, i + n); 
            Link(i + n, a[i].v);
            ++ num; vis[i] = true;
        }
        else
        {
            Split(a[i].u, a[i].v);
            int x = Tree[a[i].v].id; Splay(x); fa(ls(x)) = fa(rs(x)) = 0;
            vis[x - n] = false;
            Link(a[i].u, i + n); Link(i + n, a[i].v);
            vis[i] = true;
        }
        if ( num == n - 1 ) 
        {
            while ( !vis[Min] ) ++ Min;
            ans = min(ans, a[i].w - a[Min].w); 
        }
    }
    printf("%d\n", ans);
    return 0;
}
```



---

## 作者：_ctz (赞：4)

[更好的阅读体验$QwQ$](https://ctz45562.github.io/2019/02/28/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P4234-%E3%80%90%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC%E7%94%9F%E6%88%90%E6%A0%91%E3%80%91/)

[传送门](https://www.luogu.org/problemnew/show/P4234)

首先将边排序，依次尝试加边。两个点不连通就连，否则把这条边取代两点之间权值最小的边。可以用$LCT$拆边为点维护。

考虑这种做法的正确性：

从小到大排序可以理解为**枚举答案生成树的最大值**（比它大的都在后面还没有加）。同时最小值也要尽量大，因此用较大的边替换较小的边一定更优。同时之前枚举的边也是用较大的边替换较小的边，也就最大化了最小值。

这样只要当前已经构成了生成树，就可以开始更新答案了。最大边就是当前枚举的边，最小边可以用平衡树维护。（一开始用的$multiset$，啥都没想直接$erase$，没想到会把所有的元素都清除掉，调了半小时。。。后来还是写的$treap$）

细节上注意数据中有自环，要判断一下。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 300005
#define inf 0x3f3f3f3f
#define pn putchar('\n')
#define px(x) putchar(x)
#define ps putchar(' ')
#define pd puts("======================")
#define pj puts("++++++++++++++++++++++")

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
template<typename T>
inline T read(){
	T x=0;
	int y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
inline int ran(){
	static int seed=45562;
	return seed=(seed*48271LL%2147483647);
}//优化常数的随机数函数
int n,m;
struct edge{
	int from,to,l;
}e[maxn];
struct Link_Cut_Tree{
	int mi[maxn],dat[maxn],son[maxn][2],fa[maxn],rev[maxn],st[maxn];
    //dat是这个点（边）的权值，mi是权值最小的点的序号
    //边的序号+n为它拆成的点
#define son(x,y) son[x][y]
#define whson(x) (son[fa[x]][1]==x)
#define root(x) (son[fa[x]][0]!=x&&son[fa[x]][1]!=x)
	inline int MIN(int x,int y){
		return dat[x]<dat[y]?x:y;
	}
	inline void update(int node){
		mi[node]=MIN(node,MIN(mi[son(node,0)],mi[son(node,1)]));
	}
	inline void addedge(int s,int f,int wh){
		if(s)fa[s]=f;
		son(f,wh)=s;
	}
	inline void reverdown(int node){
		swap(son(node,0),son(node,1));
		rev[node]^=1;
	}
	inline void pushdown(int node){
		if(rev[node]){
			if(son(node,0))reverdown(son(node,0));
			if(son(node,1))reverdown(son(node,1));
			rev[node]=0;
		}
	}
	inline void zhuan(int x){
		int f=fa[x],gf=fa[f],wh=whson(x);
		fa[x]=gf;
		if(!root(f))son(gf,whson(f))=x;
		addedge(son(x,wh^1),f,wh);
		addedge(f,x,wh^1);
		update(f),update(x);
	}
	inline void splay(int x){
		int top=1,y=x;
		st[1]=x;
		while(!root(y))st[++top]=y=fa[y];
		while(top)pushdown(st[top--]);
		while(!root(x)){
			y=fa[x];
			if(!root(y))
				zhuan(whson(x)^whson(y)?x:y);
			zhuan(x);
		}
	}
	void access(int x){
		for(int y=0;x;y=x,x=fa[x])
			splay(x),son(x,1)=y,update(x);
	}
	void makeroot(int x){
		access(x),splay(x),reverdown(x);
	}
	void link(int x,int y){
		makeroot(x);
		fa[x]=y;
	}
	void cut(int x,int y){
		makeroot(x),access(y),splay(y);
		son(y,0)=fa[x]=0;
		update(y);
	}
	int findroot(int x){
		access(x),splay(x);
		while(son(x,0))pushdown(x),x=son(x,0);
		return x;
	}
	int Get(int x,int y){
		makeroot(x),access(y),splay(y);
		return mi[y];
	}
	Link_Cut_Tree(){
		memset(dat,0x3f,sizeof dat);
	}
}lct;
struct Treap{
	int dat[maxn],ls[maxn],rs[maxn],ra[maxn],root,cnt;
#define ls(x) ls[x]
#define rs(x) rs[x]
	void right(int &node){
		int rec=ls(node);
		ls(node)=rs(rec);
		rs(rec)=node;
		node=rec;
	}
	void left(int &node){
		int rec=rs(node);
		rs(node)=ls(rec);
		ls(rec)=node;
		node=rec;
	}
	void insert(int &node,int d){
		if(!node){
			node=++cnt;
			ra[node]=ran();
			dat[node]=d;
			return;
		}
		if(dat[node]<d){
			insert(rs(node),d);
			if(ra[rs(node)]>ra[node])left(node);
		}
		else {
			insert(ls(node),d);
			if(ra[ls(node)]>ra[node])right(node);
		}
	}
	void del(int &node,int d){
		if(dat[node]==d){
			if(ls(node)&&rs(node)){
				if(ra[ls(node)]>ra[rs(node)])right(node),del(rs(node),d);
				else left(node),del(ls(node),d);
			}
			else node=ls(node)+rs(node);
			return;
		}
		if(dat[node]<d)del(rs(node),d);
		else del(ls(node),d);
	}
	int getmin(){
		int node=root;
		while(ls(node))node=ls(node);
		return dat[node];
	}
}tr;
inline bool cmp(edge x,edge y){
	return x.l<y.l;
}
void solve(){
	int ans=inf,cnt=1;
	for(register int i=1;i<=n;++i)
		lct.mi[i]=i;
	for(register int i=n+1;i<=n+m;++i)
		lct.dat[i]=e[i-n].l,lct.mi[i]=i;
    //lct初始化
	for(register int i=1;i<=m;++i){
		int x=e[i].from,y=e[i].to;
		if(x==y)continue;//自环判断
		tr.insert(tr.root,e[i].l);
		if(lct.findroot(x)==lct.findroot(y)){
			int k=lct.Get(x,y);
			lct.cut(x,k),lct.cut(y,k);
			tr.del(tr.root,e[k-n].l);
		}
		else ++cnt;
		lct.link(x,i+n),lct.link(i+n,y);
		if(cnt==n)ans=min(ans,e[i].l-tr.getmin());
        //已经构成树，统计答案
	}
	printf("%d\n",ans);
}
int main(){
	n=read(),m=read();
	for(register int i=1;i<=m;++i)
		e[i].from=read(),e[i].to=read(),e[i].l=read();
	sort(e+1,e+1+m,cmp);
	solve();
}

```



---

## 作者：qwaszx (赞：3)

----

吐槽

第一眼：魔法森林，***题，秒了.

然后发现自己不会维护全局的最大值

----
首先可以按照魔法森林那个题直接做，令$a_i=w,b_i=-w$即可.

[~~无耻挂blog~~](https://www.luogu.org/blog/qwaszx/solution-p2387#)

按照$w$从大到小排序，然后依次加入边并且维护最小生成树，当前的边即最小值，我们需要求出最小的最大值，即最小瓶颈生成树.直接维护一个最小生成树即可.

关于最小生成树中最大边的处理emm

一个笨办法是按照维护子树那样，开一个$multiset$或者平衡树.

然而并不需要，因为边全都是之前的边，我们只需要标记哪些边被删除了即可.然后每次取第一个未被删除的边就好了.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define nroot(x) (ch[f[x]][0]==x||ch[f[x]][1]==x)
using namespace std;
const int N=5e5;
struct Edge{int u,v,w;}e[N];
int ch[N][2],f[N],rev[N],w[N],id[N],n,tot,m,ans=1e9,maxx=1,vis[N];
struct Node{int w,id;bool operator <(const Node &a)const{return w<a.w;}}s[N];
struct DSU
{
	int f[N];
	void clear(int n){for(int i=1;i<=n;i++)f[i]=i;}
	int find(int x){return f[x]==x?x:f[x]=find(f[x]);}
	void merge(int x,int y){x=find(x),y=find(y);f[x]=y;}
}bcj;
void reverse(int x){swap(ch[x][0],ch[x][1]);rev[x]^=1;}
void pushdown(int x){if(rev[x])reverse(ch[x][0]),reverse(ch[x][1]),rev[x]=0;}
void pushall(int x){if(nroot(x))pushall(f[x]);pushdown(x);}
void pushup(int x){s[x]=max((Node){w[x],x},max(s[ch[x][0]],s[ch[x][1]]));}
void rotate(int x)
{
	int y=f[x],z=f[y],wh=ch[y][1]==x,w=ch[x][wh^1];
	if(nroot(y))ch[z][ch[z][1]==y]=x;
	ch[x][wh^1]=y,ch[y][wh]=w;
	f[w]=y,f[y]=x,f[x]=z;pushup(y);
}
void splay(int x)
{
	pushall(x);
	while(nroot(x))
	{
		int y=f[x],z=f[y];
		if(nroot(y))rotate((ch[z][1]==y)^(ch[y][1]==x)?x:y);
		rotate(x);
	}
	pushup(x);
}
void access(int x){for(int y=0;x;y=x,x=f[x])splay(x),ch[x][1]=y,pushup(x);}
void makeroot(int x){access(x),splay(x),reverse(x);}
void split(int x,int y){makeroot(x),access(y),splay(y);}
void link(int x,int y){makeroot(x),f[x]=y;}
void cut(int x,int y){split(x,y),ch[y][0]=f[x]=0;pushup(y);}
void merge(int x,int y,int z)
{
	if(bcj.find(x)!=bcj.find(y))
	{
		++tot;bcj.merge(x,y);
		link(x,z),link(y,z);return;
	}
	split(x,y);
	if(w[z]<s[y].w)
	{
		int u=e[s[y].id-n].u,v=e[s[y].id-n].v,w=s[y].id;vis[w-n]=1;
		cut(u,w),cut(v,w),link(x,z),link(y,z);
	}
	else vis[z-n]=1;
}
int cmp(const Edge &a,const Edge &b){return a.w>b.w;}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		e[i]=(Edge){u,v,w};
	}
	sort(e+1,e+m+1,cmp);bcj.clear(n);
	for(int i=1;i<=m;i++)w[i+n]=e[i].w,s[i+n]=(Node){w[i+n],i+n};
	for(int i=1;i<=m;i++)
	{
		int u=e[i].u,v=e[i].v,w=e[i].w;
		if(u==v){vis[i]=1;continue;}//cout<<u<<" "<<v<<" "<<w<<" ";
		merge(u,v,i+n);
		if(tot==n-1)
		{
			while(vis[maxx])++maxx;//cout<<e[maxx].w<<" "<<w<<endl;
			ans=min(ans,e[maxx].w-w);
		}
	}
	printf("%d\n",ans);
}
```

---

## 作者：M_seа (赞：1)

##[更好的阅读体验](https://www.cnblogs.com/zzy2005/p/10313064.html)

##题解

LCT

[动态树Link-cut tree(LCT)总结](https://www.cnblogs.com/zzy2005/p/10312977.html)

考虑先按边权排序,从小到大加边

如果构成一颗树了,就更新答案

当加入一条边,会形成环.

贪心地想,我们要最大边权-最小边权最小

最大边权固定就是新加入的这条边,我们要让最小边权尽量地大

那么我们可以去掉原先路径上最小的那一条边,这样一定不会差

以上,可以用LCT维护
## Code

```cpp
#include<bits/stdc++.h>
#define mp make_pair
#define LL long long
#define RG register
const int inf = 2147483647;
using namespace std;
template<class T> inline void read(T &x) {
	x = 0; RG char c = getchar(); bool f = 0;
	while (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;
	while (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();
	x = f ? -x : x;
	return ;
}
template<class T> inline void write(T x) {
	if (!x) {putchar(48);return ;}
	if (x < 0) x = -x, putchar('-');
	int len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;
	for (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;
}

const int N = 250000 + 10;

struct node {
	int v, m, fa, ch[2], w;//m为最小值,w为位置
	bool rev;
}t[N];
int S[N], top, val[N];
set<pair<int, int> > Min;
void putrev(int x) {
	swap(t[x].ch[0], t[x].ch[1]);
	t[x].rev ^= 1;
}
void pushup(int x) {
	t[x].m = val[x], t[x].w = x;
	if (t[x].m > t[t[x].ch[0]].m && t[x].ch[0]) t[x].m = t[t[x].ch[0]].m, t[x].w = t[t[x].ch[0]].w;
	if (t[x].m > t[t[x].ch[1]].m && t[x].ch[1]) t[x].m = t[t[x].ch[1]].m, t[x].w = t[t[x].ch[1]].w;
}
#define get(x) (t[t[x].fa].ch[1] == x)
bool isroot(int x) {
	return (t[t[x].fa].ch[0] != x) && (t[t[x].fa].ch[1] != x);
}
void pushdown(int x) {
	if (t[x].rev) {
		t[x].rev = 0;
		if (t[x].ch[0]) putrev(t[x].ch[0]);
		if (t[x].ch[1]) putrev(t[x].ch[1]);
	}
}
void rotate(int x) {
	int k = get(x), y = t[x].fa, z = t[y].fa;
	if (!isroot(y)) t[z].ch[get(y)] = x;
	t[x].fa = z;
	t[t[x].ch[k^1]].fa = y; t[y].ch[k] = t[x].ch[k^1];
	t[y].fa = x; t[x].ch[k^1] = y;
	pushup(y);
}
void splay(int x) {
	S[top = 1] = x;
	for (RG int i = x; !isroot(i); i = t[i].fa) S[++top] = t[i].fa;
	for (RG int i = top; i; i--) pushdown(S[i]);
	while (!isroot(x)) {
		int y = t[x].fa;
		if (!isroot(y))
			(get(x) ^ get(y)) ? rotate(x) : rotate(y);
		rotate(x);
	}
	pushup(x);
}

void access(int x) {for (int y = 0; x; y = x, x = t[x].fa)splay(x), t[x].ch[1] = y, pushup(x);}

void makeroot(int x) {access(x); splay(x); putrev(x);}
void link(int x, int y) {
	makeroot(x);
	t[x].fa = y;
}
void cut(int x, int y) {
	makeroot(x);
	access(y);
	splay(y);
	t[x].fa = t[y].ch[0] = 0; pushup(y);
}
void split(int x, int y) {makeroot(x); access(y); splay(y);}

struct Node {
	int u, v, w;
	bool operator <(Node z) const {
		return w < z.w;
	}
}p[N];
int fa[N];
int find(int x) {
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}
int main() {
	int n, m, cnt = 0, ans = inf;

	read(n), read(m);
	for (int i = 1; i <= m; i++)
		read(p[i].u), read(p[i].v), read(p[i].w);
	sort(p+1, p+1+m);
	for (int i = 1; i <= n; i++) fa[i] = i, val[i] = inf;
	for (int i = 1; i <= m; i++) {
		int x = p[i].u, y = p[i].v;
		if (x == y) continue;
		val[i + n] = p[i].w;
		if (find(x) != find(y)) {
			cnt++; fa[find(y)] = find(x);
			link(i + n, x);	link(i + n, y);
			Min.insert(mp(p[i].w, i));
		} else {
			split(x, y);
			int wz = t[y].w;
			cut(wz, p[wz - n].u); cut(wz, p[wz - n].v);
			link(i + n, x); link(i + n, y);
			Min.erase(mp(p[wz - n].w, wz - n));
			Min.insert(mp(p[i].w, i));
		}
		if (cnt == n-1)
			ans = min(ans, p[i].w - (Min.begin()->first));
	}
	printf("%d\n", ans);
	return 0;
}

```



---

## 作者：Great_Influence (赞：1)

LCT。~~（虽然好像还有更好的解决方法）~~

直接将边从大到小排序，依次加入，在动态维护最小生成树即可。时间复杂度$O(nlog_2n)$。

代码:

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
using namespace std;
template<typename T>inline void read(T &x){
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&k^'-')k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
void file(void){
    #ifndef ONLINE_JUDGE
    freopen("water.in","r",stdin);
    freopen("water.out","w",stdout);
    #endif
}
static int n,m;
const int MAXN=8e5+7;
static struct edge
{
    int u,v,w;
    friend bool operator<(edge a,edge b)
    {return a.w>b.w;}
}q[MAXN];
inline void init()
{
    read(n);read(m);
    if(n==1){puts("0");exit(0);}
    for(register int i=1;i<=m;++i)
    {
        read(q[i].u),read(q[i].v),read(q[i].w);
        if(q[i].u==q[i].v)--i,--m;
    }
    sort(q+1,q+m+1);
}
namespace LCT
{
    int p[MAXN],son[MAXN][2],fa[MAXN],key[MAXN],rev[MAXN];
    
    inline bool isroot(int x)
    {return x!=son[fa[x]][0]&&x!=son[fa[x]][1];}
    
    inline void refresh(int x)
    {
        p[x]=p[son[x][key[p[son[x][0]]]>key[p[son[x][1]]]?0:1]];
        if(key[x]>key[p[x]])p[x]=x;
    }
   
    inline bool isl(int x){return x^son[fa[x]][0];}
    
    inline void rotate(int x)
    {
        static int f,ff,ke;f=fa[x];ff=fa[f];ke=isl(x);
        fa[x]=ff;if(!isroot(f))son[ff][isl(f)]=x;
        son[fa[son[x][ke^1]]=f][ke]=son[x][ke^1];
        son[fa[f]=x][ke^1]=f;
        refresh(f);refresh(x);
    }
    
    inline void pushdown(int x)
    {
        if(rev[x])swap(son[x][0],son[x][1])
        ,rev[son[x][0]]^=1,rev[son[x][1]]^=1
        ,rev[x]=0;
    }
    
    static int sta[MAXN];
    inline void splay(int x)
    {
        static int t,top,f;sta[top=1]=x;
        for(t=x;!isroot(t);t=fa[t])sta[++top]=fa[t];
        for(;top;--top)pushdown(sta[top]);
        for(f=fa[x];!isroot(x);rotate(x),f=fa[x])
            if(!isroot(f))rotate(isl(x)^isl(f)?x:f);
    }

    inline void access(int x)
    {
        static int t;
        for(t=0;x;t=x,x=fa[x])
            splay(x),son[x][1]=t,refresh(x);
    }

    inline void makeroot(int x)
    {access(x);splay(x);rev[x]^=1;}

    inline void link(int x,int y)
    {makeroot(x);fa[x]=y;}

    inline void cut(int x,int y)
    {
        makeroot(x),access(y),splay(y);
        son[y][0]=fa[x]=0;refresh(y);
    }

    inline int find(int x)
    {
        access(x);splay(x);
        while(son[x][0])x=son[x][0];
        return x;
    }
}
using namespace LCT;
multiset<int,greater<int> >G;
multiset<int,greater<int> >::iterator it;
#define Chkmin(a,b) a=a<b?a:b
inline void solve()
{
    static int ans=200000,cnt=0,poi;
    Rep(i,1,m)key[i+n]=q[i].w;
    Rep(i,1,m)
    {
        if(find(q[i].u)==find(q[i].v))
        {
            makeroot(q[i].u);access(q[i].v);splay(q[i].v);
            poi=p[q[i].v];
            cut(poi,q[poi-n].u);
            cut(poi,q[poi-n].v);
            key[poi]=0;
            it=G.lower_bound(q[poi-n].w);
            G.erase(it);
        }else ++cnt;
        link(q[i].u,i+n);
        link(q[i].v,i+n);
        G.insert(q[i].w);
        if(cnt==n-1)Chkmin(ans,*G.begin()-q[i].w);
        //Rep(j,1,n+m)cout<<j<<' '<<fa[j]<<' '<<son[j][0]<<' '<<son[j][1]<<endl;
        //cout<<endl;
    }
    printf("%d\n",ans);
}
int main(void){
    file();
    init();
    solve();
    return 0;
}

```

---

## 作者：lory1608 (赞：0)

很显然这类题有一种一般的做法，就是用lct动态维护生成树。

在本题中，考虑将边不断从大往小加，如果可以加那就直接加，否则就断掉权值最大的那一条边，维护一下那几条边被割掉了，在维护一下没被割掉的边的最大全职即可。

复杂度$\Theta(n\log n)$。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<set>
#include<vector>
#define ll long long
using namespace std;
inline int getint()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return (f==1)?x:-x;
}
inline int max(int a,int b)
{
	return a>b?a:b;
}
inline int min(int a,int b)
{
	return a<b?a:b;
}
const int maxn=3e5+5;
int n,m;
struct edge
{
	int u,v,w;
	inline bool operator <(const edge &rhs)const
	{
		return w>rhs.w;
	}
}e[maxn];
int val[maxn];
int maxv[maxn];
int fa[maxn],son[maxn][2],ans=2e9;
bool rev[maxn],is_cut[maxn];
inline bool nroot(int x)
{
	return son[fa[x]][0]==x||son[fa[x]][1]==x;
}
inline void pushup(int u)
{
	if(val[u]>val[maxv[son[u][0]]]&&val[u]>val[maxv[son[u][1]]])maxv[u]=u;
	else if(val[maxv[son[u][0]]]>val[maxv[son[u][1]]])maxv[u]=maxv[son[u][0]];
	else maxv[u]=maxv[son[u][1]];
}
inline void pushdown(int u)
{
	if(rev[u])
	{
		swap(son[u][0],son[u][1]);
		rev[son[u][0]]^=1,rev[son[u][1]]^=1;
		rev[u]=0;
	}
}
inline void rotate(int x)
{
	int y=fa[x],z=fa[y],k=son[y][1]==x;
	if(nroot(y))son[z][son[z][1]==y]=x;
	fa[x]=z;
	son[y][k]=son[x][k^1];
	fa[son[x][k^1]]=y;
	son[x][k^1]=y;
	fa[y]=x;
	pushup(y);
	pushup(x);
}
inline void pushall(int x)
{
	if(nroot(x))pushall(fa[x]);
	pushdown(x);
}
inline void splay(int x)
{
	pushall(x);
	while(nroot(x))
	{
		int y=fa[x],z=fa[y];
		if(nroot(y))
		{
			if((son[z][1]==y)^(son[y][1]==x))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
}
inline void access(int x)
{
	for(int y=0;x;y=x,x=fa[x])
	{
		splay(x);
		son[x][1]=y;
		pushup(x);
	}
}
inline void makeroot(int x)
{
	access(x);
	splay(x);
	rev[x]^=1;
}
inline int findroot(int x)
{
	access(x);
	splay(x);
	pushdown(x);
	while(son[x][0])x=son[x][0],pushdown(x);
	splay(x);
	return x;
}
inline void link(int x,int y)
{
	makeroot(x);
	if(findroot(y)!=x)
	{
		fa[x]=y;
	}
}
inline void cut(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	if(findroot(y)==x&&fa[y]==x&&!son[y][0])
	{
		fa[y]=0;
		son[x][1]=0;
		pushup(x);
	}
}
inline int query(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
	return findroot(y)==x;
}
inline void split(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
}
int main()
{
	n=getint(),m=getint();
	for(int i=1;i<=m;++i)
	{
		e[i].u=getint(),e[i].v=getint(),e[i].w=getint();
	}
	sort(e+1,e+m+1);
	for(int i=1;i<=m;++i)val[i+n]=e[i].w;
	int cnt=0,pos=1;
	for(int i=1;i<=m;++i)
	{
		int x=e[i].u,y=e[i].v;
		if(x==y)
		{
			is_cut[i]=true;
			continue;
		}
		if(query(x,y))
		{
			split(x,y);
			int now=maxv[y];
			cut(e[now-n].u,now);
			cut(e[now-n].v,now);
			is_cut[now-n]=true;
			link(e[i].u,i+n);
			link(e[i].v,i+n);
		}
		else
		{
			link(e[i].u,i+n);
			link(e[i].v,i+n);
			cnt++;
		}
		if(cnt==n-1)
		{
			while(is_cut[pos])pos++;
			ans=min(ans,e[pos].w-e[i].w);
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

配上一个数据生成器：

```cpp
#include<iostream>
#include<ctime>
#include<cstdlib>
#define ll long long
#define rd rand()*rand()
using namespace std;
char temp[30];
int main()
{
	srand(time(NULL));
	freopen("1.txt","w",stdout);
	int n=50000,m=100000;
	cout<<n<<' '<<m<<endl;
	for(int i=2;i<=n;++i)cout<<i<<' '<<rd%(i-1)+1<<' '<<rd%10000<<endl;
	for(int i=n;i<=m;++i)cout<<rd%n+1<<' '<<rd%n+1<<' '<<rd%10000<<endl;
	return 0;
}
```

---


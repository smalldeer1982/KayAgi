# [WC2016] 挑战NPC

## 题目描述

小 N 最近在研究 NP 完全问题，小 O 看小 N 研究得热火朝天，便给他出了一道这样的题目：

有 $n$ 个球，用整数 $1$ 到 $n$ 编号。还有 $m$ 个筐子，用整数 $1$ 到 $m$ 编号。每个筐子最多能装 $3$ 个球。

每个球只能放进特定的筐子中。 具体有 $e$ 个条件，第 $i$ 个条件用两个整数
$v_i$ 和 $u_i$ 描述，表示编号为 $v_i$ 的球可以放进编号为 $u_i$ 的筐子中。

每个球都必须放进一个筐子中。如果一个筐子内有不超过 $1$ 个球，那么我们称这样的筐子为半空的。

求半空的筐子最多有多少个，以及在最优方案中， 每个球分别放在哪个筐子中。

小 N 看到题目后瞬间没了思路，站在旁边看热闹的小 I 嘿嘿一笑：“水题！”
然后三言两语道出了一个多项式算法。

小 N 瞬间就惊呆了，三秒钟后他回过神来一拍桌子：“不对！这个问题显然是 NP 完全问题，你算法肯定有错！”

小 I 浅笑：“所以，等我领图灵奖吧！”

小 O 只会出题不会做题，所以找到了你——请你对这个问题进行探究，并写一个程序解决此题。

## 说明/提示

对于所有数据， $T \leq 5, 1 \leq n \leq 3m$。 保证 $1 \leq v_i \leq n, 1 \leq u_i \leq m$，且不会出现重复的条件。

保证至少有一种合法方案，使得每个球都放进了筐子，且每个筐子内球的个
数不超过 $3$。

各测试点满足以下约定：
![](https://cdn.luogu.com.cn/upload/image_hosting/wi7sdxbz.png)

## 样例 #1

### 输入

```
1
4 3 6
1 1
2 1
2 2
3 2
3 3
4 3```

### 输出

```
2
1 2 3 3```

# 题解

## 作者：ubsan (赞：13)

[更好的阅读体验（？](https://zhangyiming.tech/39)

__solution__ :


在 WC2021 Day 1 晚上听了“调整算法”，感觉很神仙，而校内 OJ 只有一道一般图最大匹配的题，于是就写了一下。

建图的方法这里就不多说了，其他题解都有，就是把一个筐子拆成三个点然后互相连边。

至于”调整算法“就是记录一个一开始为空的匹配，每一次随机一个没有匹配的点并枚举出边，如果也有没有匹配的点就匹配上并`ans`++，否则随机一个点拆掉原来的匹配并与现在的点匹配。

我是进行了`4e5`次上述的操作，这样就可以得出最大匹配的大小了（[darkbzoj](https://darkbzoj.tk/submission/108070)）,但这样求出的方案不一定 `1~n` 都是匹配点，所以我想出了一种奇怪的做法，就是每次随机点的时候如果有未匹配的`1~n`的点就优先选，然后莫名其妙就对了（

~~然后好像在所有OJ都是最慢解~~

__code__ :
```cpp
#include <bits/stdc++.h>
using namespace std;
int T, n, m, e, vis_num, num, head[1000000], nxt[1000000], to[1000000], cnt,
    vis[1000000], v[1000000], out[1000000], i;
void add(int a, int b) { nxt[++cnt] = head[a], to[cnt] = b, head[a] = cnt; }
void link(int a, int b) {
  vis[vis[a]] = vis[vis[b]] = 0, vis[a] = b, vis[b] = a;
}
int main() {
  cin >> T;
  while (T--) {
    cnt = vis_num = 0;
    memset(vis, 0, sizeof(vis));
    memset(head, 0, sizeof(head));
    memset(out, 0, sizeof(out));
    cin >> n >> m >> e;
    for (int i = 1; i <= e; i++) {
      int u, v;
      cin >> u >> v;
      int s = n + (v - 1) * 3;
      add(s + 2, u), add(u, s + 3), add(s + 3, u), add(u, s + 2), add(u, s + 1),
          add(s + 1, u);
    }
    for (int i = 1; i <= m; i++) {
      int s = n + (i - 1) * 3;
      add(s + 2, s + 3), add(s + 3, s + 2), add(s + 1, s + 2),
          add(s + 3, s + 1), add(s + 2, s + 1), add(s + 1, s + 3);
    }
    int tot = n + m * 3, ans = 0, _ = 1;
    while (++_ <= 200000 || !out[1]) {
      for (num = 0, i = 1; i <= tot; i++)
        if (!vis[i]) v[++num] = i;
      if (!num) break;
      int now = v[1] <= n ? v[1] : v[rand() % num + 1];
      vis_num += now <= n, num = 0;
      for (i = head[now]; i; i = nxt[i]) {
        if (!vis[to[i]]) {
          ans++;
          link(now, to[i]);
          if (to[i] <= n) vis_num++;
          goto ed;
        } else
          v[++num] = to[i];
      }
      {
        int to = v[rand() % num + 1];
        vis_num -= (vis[to] <= n);
        link(now, to);
      }
    ed:
      if (vis_num == n) memcpy(out, vis, sizeof(int) * (tot + 1));
    }
    cout << ans - n << endl;
    for (i = 1; i <= n; i++) {
      cout << (out[i] - n - 1) / 3 + 1 << " ";
    }
    cout << endl;
  }
  return 0;
}
```

---

## 作者：zac2010 (赞：9)

### 解题思路

先声明一下：此题不是 NPC。毕竟出题人还不至于能在多项式时间复杂度内爆切 NPC 问题。

一种不正确的最初想法：把每个筐拆成 $3$ 个点 $u_i,u_i+m,u_i+2 \times m$，所有 $v_i$ 向 $u_i$ 拆后的三个点连边，跑二分图的最大匹配。

```
hack:
Input:
1
2 2 3
1 1
2 1
2 2
Output:
2
1 2
```

在这里可能会因为边的遍历顺序问题而先跑边 $(2,1)$ 而导致答案变成 $1$。

那么接着就是这道题奇特的建图方式了。不妨在上述的建图方式为基础的情况下把所有的 $u,u+m,u+2 \times m$ 两两之间连边，然后跑一般图的最大匹配（改为一般图的原因：前面三个点的两两连边会形成奇环），最后答案就是最大匹配数 $-n$。

来证明一下这个结论。

对所有的 $u_i,u_i+m,u_i+2\times m$ 分 $4$ 种情况讨论：
1. 其中有 $0$ 个匹配点。

	本来的贡献应该是 $1$。内部点必然恰好有一组匹配。减去匹配在这种情况下即等于减去 $0$，所以贡献还是 $1$。
2. 有 $1$ 个。

	本来的贡献应该是 $1$。会发现内部必然有一组匹配，和那一个匹配点所处的匹配一加，贡献为 $2$。所以多出来 $1$，刚好是减去匹配点个数。
3. 有 $2$ 个。

	本来的贡献应该是 $0$。注意到三个点不可能再出现内部匹配的情况了，所以刚好减去匹配点个数。
4. 有 $3$ 个。

	和 $2$ 个的情况同理。
    
所以对于任意一组“每个球都放在一个框中”的匹配，拿匹配数 $-n$ 一定等于答案。为了使答案最大，当然是取最大匹配了。且求最大匹配时我们优先对球进行增广，然后再对框子所表示的点进行增广。这样便可保证“每个球都放在一个框中”。

### 代码

给个这道题的重点部分（建图的部分）：

```cpp
//输入+建边
scanf("%d%d%d", &n, &m, &e);
for(int i = 1; i <= m; i++){
	Add(i + n, i + m + n), Add(i + m + n, i + n);
   Add(i + n, i + 2 * m + n), Add(i + 2 * m + n, i + n);
   Add(i + m + n, i + 2 * m + n), Add(i + 2 * m + n, i + m + n);
}
for(int i = 1; i <= e; i++){
	int v, u; scanf("%d%d", &v, &u);
	Add(v, u + n)， Add(v, u + m + n), Add(v, u + 2 * m + n);
	Add(u + n, v), Add(u + m + n, v), Add(u + 2 * m + n, v);
}

//之后跑一般图的最大匹配
```

---

## 作者：Crossing (赞：8)

$\huge\mathcal{Description}$

有 $n$ 个球和 $m$ 个筐子。

每个筐里最多能装三个。如果一个筐子内有不超过 $1$ 个球，那么我们称这样的筐子为**半空**的。

**每个球都必须放进一个筐子中**。且对于每个球有一些限制，即能放进哪个筐里。

现要求半空的筐最多有几个，并输出方案。

~~小 I 浅笑：“所以，等我领图灵奖吧！”~~

$\huge\mathcal{Solution}$

机房大佬介绍的一道题 ~~刚学的带花树，但发现基本找不到题~~

首先，每个筐里最多放三个球。我们可以把每个筐拆成三个点，再把每个球作为一个点。这样，用我们最终得出的方案构成的图中，每个点的度数一定都不会超过1

这就与**一般图的最大匹配**相似，但我们显然不能直接跑一遍带花树。因为装有一个球以上的筐会对答案造成影响。~~所以我们必须操作一下~~

**有一种很妙的想法就是， 在每个筐拆出的三个点之间互相连边。**$\mathcal{Why?}$

我们依次进行考虑

- 非半空的筐子(即装有 $2$ 或 $3$ 个球)。他们对答案作出的贡献是无意义的，所以要减去。而他们对答案的影响就是装有的球数。

- 装有 $1$ 个球的筐子。他们对答案应作出 $1$ 的贡献。但由于筐的三个点之间有连边，所以他们对当前答案(即带花树跑出来的结果)贡献是 $2$。所以减 $1$。

- 空的筐。他们对答案应作出 $1$ 的贡献。但由于筐的三个点之间有连边，所以他们对当前答案的贡献是 $1$。所以不变。

归纳一下就可以得到，**一个筐内装有多少球，他就对最终答案造成了多少影响。**

由于每个球都必须放入一个筐子, 所以，最终答案就等于带花树跑出来的答案减去 $n$。

$\huge\mathcal{Code}$

```cpp
//冗长的代码
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
#include <queue>
template <typename Tp>
inline void read(Tp &x) {
    x = 0;
    bool f = true; char ch = getchar();
    for ( ; ch < '0' || ch > '9'; ch = getchar()) f ^= ch == '-';
    for ( ; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + (ch ^ 48);
    x = f ? x : -x;
}

const int N = 1005, M = 2e5 + 7;

int head[N], cnt = 0;

struct edge {
    int to, next;
};
edge e[M << 1];

inline void add_edge(int x, int y) {
    e[++cnt] = (edge) {y, head[x]}, head[x] = cnt;
}

int fa[N], pre[N], f[N], tic[N], tim = 0, m, vis[N];
std::queue <int> q;

inline int father(int x) {
    return fa[x] == x ? x : fa[x] = father(fa[x]);
}

inline void shrink(int x, int y, int top) {
    while (father(x) != top) {
        pre[x] = y, y = f[x];
        if (vis[y] == 2) vis[y] = 1, q.push(y);
        if (father(x) == x) fa[x] = top;
        if (father(y) == y) fa[y] = top;
        x = pre[y];
    }
}

inline int LCA(int x, int y) {
    ++tim;
    while (1) {
        x = father(x);
        if (tic[x] == tim) return x;
        else tic[x] = tim, x = pre[f[x]]; 
        std::swap(x, y);
    }
}

inline bool match(int s) {
    for (int i = 1; i <= m; ++i) fa[i] = i;
    std::fill(pre + 1, pre + m + 1, 0);
    std::fill(vis + 1, vis + m + 1, 0);
    while (q.size()) q.pop();
    vis[s] = 1, q.push(s);
    while (q.size()) {
        int x = q.front();
        q.pop();
        for (int i = head[x]; i; i = e[i].next) {
            int v = e[i].to;
            if (vis[v] == 2 || father(x) == father(v)) continue;
            if (!vis[v]) {
                vis[v] = 2, pre[v] = x;
                if (!f[v]) {
                    for (int cur = v, last; cur; cur = last) {
                        last = f[pre[cur]];
                        f[pre[cur]] = cur, f[cur] = pre[cur];
                    }
                    return true;
                }
                vis[f[v]] = 1, q.push(f[v]);
            }
            else if (vis[v] == 1) {
                int lca = LCA(x, v);
                shrink(x, v, lca);
                shrink(v, x, lca);
            }
        }
    }
    return false;
}

int main() {
    int T;
    read(T);
    while (T--) {
        int n, E;
        read(n), read(m), read(E);
        cnt = tim = 0;
        std::fill(head + 1, head + n + 3 * m + 1, 0);
        std::fill(f + 1, f + n + 3 * m + 1, 0);
        std::fill(tic + 1, tic + n + 3 * m + 1, 0);
        for (int i = 1; i <= E; ++i) {
            int x, y;
            read(x), read(y);
            int z = n + (y - 1) * 3;
            add_edge(x, z + 1), add_edge(z + 1, x);
            add_edge(x, z + 2), add_edge(z + 2, x);
            add_edge(x, z + 3), add_edge(z + 3, x);
        }
        for (int i = 1; i <= m; ++i) {
            int x = n + (i - 1) * 3;
            add_edge(x + 1, x + 2), add_edge(x + 2, x + 1);
            add_edge(x + 1, x + 3), add_edge(x + 3, x + 1);
            add_edge(x + 2, x + 3), add_edge(x + 3, x + 2);
        }
        int ans = -n;
        m = m * 3 + n;
        for (int i = 1; i <= m; ++i) ans += (!f[i] && match(i));
        printf("%d\n", ans);
        for (int i = 1; i <= n; ++i) printf("%d%c", (f[i] - n - 1) / 3 + 1, " \n"[i == n]);
    }
    return 0;
}
```



$\huge\mathcal{CSP2019}$ $\huge\color{red}\mathcal{R}\huge\color{yellow}\mathcal{P} \color{orange}++$

---

## 作者：玫葵之蝶 (赞：4)

这题还是很妙的

我来发题解的主要目的就是发一个比较好的带花树的代码

我的又没压行，还比较短，感觉比较好看

这题大概就是考虑如何让筐体现出它的价值

首先每个筐拆成三个点，分别代表三个空位

然后对于每个球可以放入框的对应关系，我们连三条边

最后再每个筐的三个点之间互相连边

如下图所示：（图是楼下的）

![](https://huhaoo.coding.me/2018/03/04/luogu4258WC2016挑战NPC/2.png)

这样来个带花树就做出来了

当然最后答案要-n

而且输出方案注意一下

还有边表开够

代码：
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#define LL long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=' ';
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*f;
}
const int N=605,M=5e5;
int tot,cnt,top,sum;
int head[M],to[M],Next[M];
inline void addedge(int x,int y){to[++tot]=y;Next[tot]=head[x];head[x]=tot;}
inline void ins(int x,int y){addedge(x,y);addedge(y,x);}
int f[N],vis[N],pre[N],nxt[N],q[N],s[N];
inline int find(int x){return f[x]==x?x:f[x]=find(f[x]);}
inline int lca(int x,int y){
    for(cnt++,x=find(x),y=find(y);;swap(x,y))
        if(x){
            if(vis[x]==cnt)return x;
            vis[x]=cnt;
            x=find(pre[nxt[x]]);
        }
}
inline void blossom(int x,int y,int flower){
    while(find(x)!=flower){
        pre[x]=y;
        if(s[nxt[x]]==1)s[q[++top]=nxt[x]]=0;
        if(f[x]==x)f[x]=flower;
        if(f[nxt[x]]==nxt[x])f[nxt[x]]=flower;
        y=nxt[x];
        x=pre[y];
    }
}
inline int match(int st){
    for(int i=1;i<=sum;++i)f[i]=i;
    memset(s,-1,sizeof(s));
    s[q[top=1]=st]=0;int x;
    for(int l=1;l<=top;++l)
        for(int i=head[x=q[l]];i;i=Next[i]){
            int u=to[i];
            if(s[u]==-1){
                pre[u]=x;
                s[u]=1;
                if(!nxt[u]){
                    for(int v=x,lst;v;u=lst,v=pre[u])
                        lst=nxt[v],nxt[v]=u,nxt[u]=v;
                    return 1;
                }
                s[q[++top]=nxt[u]]=0;
            }
            else if(!s[u] && find(x)!=find(u)){
                int flower=lca(x,u);
                blossom(u,x,flower);
                blossom(x,u,flower);
            }
        }
    return 0;
}
inline int solve(){
    int ans=0;
    for(int i=1;i<=sum;++i)if(!nxt[i])ans+=match(i);
    return ans;
}
int T,n,m,E;
int main(){
    T=read();
    for(int s=1;s<=T;++s){
        n=read();m=read();E=read();
        sum=n+m*3;tot=0;cnt=0;
        memset(head,0,sizeof(head));
        memset(nxt,0,sizeof(nxt));
        memset(pre,0,sizeof(pre));
        memset(vis,0,sizeof(vis));
        for(int i=1;i<=E;++i){
            int u=read(),v=read();
            ins(u,n+v);
            ins(u,n+m+v);
            ins(u,n+(m<<1)+v);
        }
        for(int i=1;i<=m;++i){
            ins(n+i,n+m+i);
            ins(n+i,n+(m<<1)+i);
            ins(n+m+i,n+(m<<1)+i);
        }
        printf("%d\n",solve()-n);
        for(int i=1;i<=n;++i)printf("%d ",(nxt[i]-n-1)%m+1);
    }
    return 0;
}
```



---

## 作者：Mars_Dingdang (赞：3)

首先，这道题完全不是 NPC，网上可以搜到当年冬令营对于这一点的解释。

截止至 2021.8.4 最优解 get√

## 题目大意
有 $n$ 个球，用整数 $1\sim n$ 编号。还有 $m$ 个筐子，用整数 $1\sim m$ 编号。每个筐子最多能装 $3$ 个球。

每个球只能放进特定的筐子中。 具体有 $e$ 个条件，第 $i$ 个条件用两个整数 $v_i$ 和 $u_i$ 描述，表示编号为 $v_i$ 的球可以放进编号为 $u_i$ 的筐子中。

每个球都必须放进一个筐子中。如果一个筐子内有不超过 $1$ 个球，那么我们称这样的筐子为半空的。

求半空的筐子最多有多少个，以及在最优方案中， 每个球分别放在哪个筐子中。

## 大体思路
首先，由于每个筐子可以放最多三个球，很容易想到将每个代表筐的点拆成三个点，然后由 $v_i$ 向这三个点依次连一条无向边。对于这类题目，很容易想到最大匹配问题。

然而，由于题目求的是半空的筐子，对于一个筐子的三个点，如果三个点均是匹配点则要减去 $3$，若有两个点是匹配点则要减去 $2$，若只有一个匹配点则不用减去。这样，每种情况需要被差别对待，较为麻烦。

考虑将每个筐子拆成的三个点之间连边，成为一个三角形。然后，整张图是一张一般的无向图，使用带花树算法求解一般图最大匹配。

![](https://cdn.luogu.com.cn/upload/image_hosting/rni8yeb9.png)

此时，对于如上图所示的只有一个匹配点的情况，$(2,3)$ 也构成了一组匹配，显然这一组匹配也必须删去，所以当有一个匹配点时答案需要减一。

这样，对于有 $i$ 个点的匹配，答案需要减去 $i$，而题目保证所有球都能放入，所以 $\sum i=n$，从求得的最大匹配减去 $n$ 即可。至于方案输出，注意还原 $match$ 数组所对应的点的编号。

## 完整代码
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <cstring>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
typedef double db;
const int maxn = 1e3 + 5;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
int hd[maxn], ver[200005], nxt[200005], tot;
int n, m, e;
inline void add(int u, int v) {
	ver[++tot] = v; nxt[tot] = hd[u]; hd[u] = tot;
	ver[++tot] = u; nxt[tot] = hd[v]; hd[v] = tot;
}
int fa[maxn], pre[maxn], match[maxn], vis[maxn], dfn[maxn], timer;
queue <int> q;
int ans;
inline int find(int k) {
	return k == fa[k] ? k : fa[k] = find(fa[k]);
}
inline int lca(int u, int v) {
	u = find(u), v = find(v);
	timer ++;
	while(dfn[u] != timer) {
		dfn[u] = timer;
		u = find(pre[match[u]]);
		if(v) u ^= v ^= u ^= v;
	}
	return u;
}
inline void blossom(int x, int y, int z) {
	while(find(x) != z) {
		pre[x] = y; y = match[x];
		if(vis[y] == 2) {
			vis[y] = 1;
			q.push(y);
		}
		if(find(x) == x) fa[x] = z;
		if(find(y) == y) fa[y] = z;
		x = pre[y];
	}
}
inline bool bfs(int s) {
	if(2 * (ans + 1) > n + 3 * m) return 0;
	rep(i, 1, m * 3 + n) fa[i] = i, pre[i] = vis[i] = 0;
	while(!q.empty()) q.pop();
	q.push(s); vis[s] = 1;
	while(!q.empty()) {
		int u = q.front(); q.pop();
		for(int i = hd[u]; i; i = nxt[i]) {
			int v = ver[i];
			if(find(u) == find(v) || vis[v] == 2) continue;
			if(vis[v] == 0) {
				vis[v] = 2, pre[v] = u;
				if(!match[v]) {
				for(int x = v, lst; x; x = lst)
					lst = match[pre[x]],
					match[x] = pre[x], 
					match[pre[x]] = x;
				return 1;
				}
				vis[match[v]] = 1; q.push(match[v]);
			}
			else {
				int w = lca(u, v);
				blossom(u, v, w); blossom(v, u, w);
			}
		}
	}
	return 0;
}
int T;
int main () {
	read(T);
	while(T --) {
		read(n); read(m); read(e);
		tot = timer = ans = 0;
		memset(match, 0, sizeof match);
		memset(dfn, 0, sizeof dfn);
		memset(hd, 0, sizeof hd);
		rep(i, 1, e) {
			int u, v;
			read(v); read(u);
			add(v, u + n);
			add(v, u + n + m);
			add(v, u + n + m + m);// 拆点
		}
		rep(i, 1, m) {
			add(i + n, i + n + m);
			add(i + n, i + n + m + m);
			add(i + n + m, i + n + m + m);//三个点之间连边
		}
		rep(i, 1, (m + m + m + n)) 
			if(!match[i]) ans += bfs(i);
		writeln(ans - n);
		rep(i, 1, n) write((match[i] - n - 1) % m + 1), putchar(' ');
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：2)

不得不说是一道很巧妙的题目，而且结论也比较好猜~~至少我猜了一会儿就猜出来了结果不会证……~~      

我们一打开这道题，诶~~网络流~~。       

不过很糟糕的是我们建不出来这个图，所以我们考虑这道题的一个明显提示：最大匹配。      

我们把每个筐子拆成三个点，每个筐子的三个点之间互相连边，每条边的球向对应的筐子的三个拆点连边。      

接着考虑每个筐子的情况：     

- 如果与球的匹配为 $0$ ，那么我们对答案的贡献为 $1$ ，刚好内部连接的几个筐子可以做一个贡献为 $1$ 的答案。     
- 如果与球的匹配为 $1$ ，那么我们对答案的贡献为 $1$ ，此时由于内部连接又会产生为 $1$ 的贡献，所以总的贡献为 $2$ ，减去球的贡献 $1$ 即可得到正确答案。    
- 如果与球的匹配为 $2$ ，那么对答案的贡献为 $0$ ，由于此时内部连接没有贡献，所以总的贡献为 $2$ ，减去球的匹配为 $2$ 即可得到正确答案。    - 与球的匹配为 $3$ 的情况如匹配数为 $2$ 的情况。     

综上，我们把我们计算一般图的最大匹配，减去放进球产生的贡献即可，而我们所有球都必须放一次，即减去 $n$ 即可。       

至于为什么是一般图最大匹配，因为这样建图肯定有奇环啊……

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int Len = 100005 , M = 100005;
queue<int> q;
inline int read() {
    char ch = getchar();
    int x = 0, f = 1;
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while ('0' <= ch && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
inline void write(int x) {
    if (x < 0)
        putchar('-'), x = -x;
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}
int n,m,e,cnt,tot,head[Len],fa[Len],flo[Len],match[Len],pre[Len],vis[Len],ans;
struct node
{
	int next,to;
}edge[M << 1];
void add(int from,int to)
{
	edge[++ cnt].to = to;
	edge[cnt].next = head[from];
	head[from] = cnt;
}
inline int findSet(int x){return fa[x] == x ? fa[x] : fa[x] = findSet(fa[x]);}
inline int LCA(int x,int y)
{
	for(++ tot , x = findSet(x) , y = findSet(y) ; flo[x] != tot ; )
	{
		flo[x] = tot;
		x = findSet(pre[match[x]]);
		if(y) swap(x , y);
	}
	return x;
}
inline void blossom(int x,int y,int rt)
{
	while(findSet(x) != rt)
	{
		pre[x] = y , y = match[x];
		if(vis[y] == 2) vis[y] = 1 , q.push(y);
		if(findSet(x) == x) fa[x] = rt;
		if(findSet(y) == y) fa[y] = rt;
		x = pre[y];
	}
}
inline int aug(int x)
{
	if((ans + 1) * 2 > (n + m * 3)) return 0;
	for(int i = 1 ; i <= n + m * 3; i ++) fa[i] = i , vis[i] = pre[i] = 0;
	while(!q.empty()) q.pop();
	q.push(x) ; vis[x] = 1;
	while(!q.empty())
	{
		int p = q.front() ; q.pop() ;
		for(int e = head[p] , rt ; e ; e = edge[e].next)
		{
			int to = edge[e].to;
			if(findSet(p) == findSet(to) || vis[to] == 2) continue;
			if(!vis[to])
			{
				vis[to] = 2 , pre[to] = p;
				if(!match[to])//找增广路
				{
					for(int v = to , lst ; v ; v = lst){lst = match[pre[v]] , match[v] = pre[v] , match[pre[v]] = v;}
					return 1;
				}
				if(match[to]) vis[match[to]] = 1 , q.push(match[to]); 
			}
			else blossom(p , to , rt = LCA(p , to)) , blossom(to , p , rt);
		}
	}
	return 0;
}
inline int GOTO(int x)
{
	int z = x - n;
	if(z % 3 == 0) return z / 3;
	return z / 3 + 1;
}
int main()
{
	int T;T = read();
	while(T --)
	{
		memset(head , 0 , sizeof head) ; cnt = tot = 0;
		memset(fa , 0 , sizeof fa);memset(flo , 0 , sizeof flo);memset(match , 0 , sizeof match);memset(pre , 0 , sizeof pre);
		memset(vis , 0 , sizeof vis);
		n = read() , m = read() , e = read();
		for(int i = 1 ; i <= m ; i ++) 
		{
			int num = n + (i - 1) * 3;
			add(num + 1 , num + 2) , add(num + 2 , num + 1);
			add(num + 1 , num + 3) , add(num + 3 , num + 1);
			add(num + 2 , num + 3) , add(num + 3 , num + 2); 
		}
		for(int i = 1 ; i <= e ; i ++) 
		{
			int x,y;x = read() , y = read();int num = n + (y - 1) * 3;
			add(x , num + 1) , add(num + 1 , x);
			add(x , num + 2) , add(num + 2 , x);
			add(x , num + 3) , add(num + 3 , x); 
		}
		ans = -n;
		for(int i = 1 ; i <= n + m * 3 ; i ++) if(!match[i]) ans += aug(i);
		write(ans) , putchar('\n');
		for(int i = 1 ; i <= n; i ++) write(GOTO(match[i])) , putchar(' ');
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：pomelo_nene (赞：1)

读题，发现有一个限制条件：

> 保证至少有一种合法方案，使得每个球都放进了筐子，且每个筐子内球的个数不超过 $3$。

因此，我们的所有球一定能和某一个筐子匹配。

考虑将这道题跟匹配扯上关系。显然，因为我们的所有球一定能和某一个筐子匹配，所以说对于答案的计算，我们一定要在 $m$ 个筐子所代表的点集及边集内进行处理。

注意到一个筐子只能放三个球，并且只有放 $0$ 或 $1$ 个球的筐子才能给出贡献。于是将一个筐子拆成 $3$ 个点，一个筐子内的三个点两两连边。

这样做的意义是，我们完美的解决了在球能和筐子匹配下的情况，具体状况具体分析：

- 如果筐子代表的点被 $0$ 个球匹配：这三个点内部匹配，答案贡献为 $1$；   
- 如果筐子代表的点被 $1$ 个球匹配：未被匹配的两个点匹配，答案贡献为 $1$；   
- 否则，不能够找到更多的匹配，答案贡献为 $0$。

于是直接建边即可。因为图中有奇环，因此为一般图最大匹配，用带花树解决这个问题。**注意，因为要输出方案，所以要先匹配球所对应的点，否则方案会出现问题**。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct UnionFindSet{
	int fa[1005];
	void makeSet(int up){for(int i=0;i<=up;++i)	fa[i]=i;}
	int findSet(int x)
	{
		if(x==fa[x])	return x;
		return fa[x]=findSet(fa[x]);
	}
	void unionSet(int x,int y)
	{
		int xx=findSet(x),yy=findSet(y);
		if(xx==yy)	return ;
		fa[xx]=yy;
	}
}ufs;
vector<int> G[1005];
int n,m,match[1005],pre[1005],vis[1005],bel[1005],flw,e,clc[1005];
queue<int> Q;
int LCA(int u,int v)
{
	++flw;
	while(bel[u]!=flw)
	{
		bel[u]=flw;
		u=ufs.findSet(pre[match[u]]);
		if(v)	swap(u,v);
	}
	return u;
}
void Blossom(int u,int v,int x)
{
	while(ufs.findSet(u)!=x)
	{
		pre[u]=v;
		v=match[u];
		if(vis[v]==2)	vis[v]=1,Q.push(v);
		if(ufs.findSet(u)==u)	ufs.fa[u]=x;
		if(ufs.findSet(v)==v)	ufs.fa[v]=x;
		u=pre[v];
	}
}
bool Aug(int S)
{
	while(!Q.empty())	Q.pop();
	memset(vis,0,sizeof vis);
	memset(pre,0,sizeof pre);
	ufs.makeSet(3*m+n);
	Q.push(S);
	vis[S]=1;
	while(!Q.empty())
	{
		int now=Q.front();
		Q.pop();
		for(unsigned int i=0;i<G[now].size();++i)
		{
			int to=G[now][i];
			if(ufs.findSet(now)==ufs.findSet(to) || vis[to]==2)	continue;
			if(!vis[to])
			{
				vis[to]=2;
				pre[to]=now;
				if(!match[to])
				{
					int lst=0;
					for(int x=to;x;x=lst)	lst=match[pre[x]],match[x]=pre[x],match[pre[x]]=x;
					return true;
				}
				vis[match[to]]=1;
				Q.push(match[to]);
			}
			else
			{
				int x=LCA(now,to);
				Blossom(now,to,x);
				Blossom(to,now,x);
			}
		}
	}
	return false;
}
int main(){
	int T;
	scanf("%d",&T);
	while(T-->0)
	{
		memset(G,0,sizeof G);
		memset(match,0,sizeof match);
		memset(bel,0,sizeof bel);
		memset(clc,0,sizeof clc);
		flw=0;
		scanf("%d %d %d",&n,&m,&e);
		for(int i=1;i<=e;++i)
		{
			int v,u;
			scanf("%d %d",&v,&u);
			G[v+m+m+m].push_back(u);
			G[v+m+m+m].push_back(u+m);
			G[v+m+m+m].push_back(u+m+m);
			G[u].push_back(v+m+m+m);
			G[u+m].push_back(v+m+m+m);
			G[u+m+m].push_back(v+m+m+m);
		}
		for(int i=1;i<=m;++i)
		{
			G[i].push_back(i+m);
			G[i+m].push_back(i+m+m);
			G[i].push_back(i+m+m);
			G[i+m].push_back(i);
			G[i+m+m].push_back(i+m);
			G[i+m+m].push_back(i);
		}
		int ans=0;
		for(int i=3*m+n;i;--i)	ans+=(!match[i] && Aug(i));
		printf("%d\n",ans-n);
		for(int i=3*m+1;i<=3*m+n;++i)	printf("%d ",(match[i]-1)%m+1);
		puts("");
	}
	return 0;
}
```

---

## 作者：RemiliaScar1et (赞：0)

## P4258 [WC2016]挑战NPC

~~小 I 浅笑：“所以，等我领图灵奖吧！”~~

每个筐能装三个？那我把它拆成三个筐，每个筐就只能装一个了。
球和筐的对应关系可以抽象为边。把球放进筐可以看成两两匹配。

但是现在要考虑的是怎样做到满足“一个筐子(这里指的是题面里的筐)内有不超过 $1$ 个球”这个限制条件。

观察拆出的点我们发现，**对于一个三个点的奇环，要么就没有匹配，要么只有一个匹配，另外单出一个点向外匹配。**

所以我们把一个筐拆出的三个点互相连边，算出最大匹配数后 $-n$ 就行。

然后就是在一个有 $n+3m$ 个点的图上跑带花树。

拆点方法因人而异，我这里选择了 $+m$ 的倍数

**多测记得清空需要清空的数组！！！**

code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+10;
#define rg register
inline int read()
{
	rg int x=0,w=1;
	rg char ch=getchar();
	if(ch=='-') w=-1,ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
	while(ch<='9'&&ch>='0') x=(x<<3)+(x<<1)+(ch-'0'),ch=getchar();
	return x*w;
}
int head[N],ver[N],nxt[N],tot;
void add(int x,int y)
{
	ver[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}
int fa[N];
int find(int x)
{
	int x_root=x;
	while(fa[x_root]!=x_root) x_root=fa[x_root];
	while(x!=x_root)
	{
		int tmp=fa[x];
		fa[x]=x_root; x=tmp;
	}
	return x_root;
}
int match[N],pre[N];
int vis[N],dfn[N],tim=0;
int n,m,e,sum=0;

int lca(int x,int y)
{
	++tim;
	x=find(x);y=find(y);
	while(tim!=dfn[x])
	{
		dfn[x]=tim;
		x=find(pre[match[x]]);
		if(y) swap(x,y);
	}
	return x;
}

queue<int> q;
void blossom(int x,int y,int w)
{
	while(find(x)!=w)
	{
		pre[x]=y; y=match[x];
		if(vis[y]==2) vis[y]=1,q.push(y);
		if(find(x)==x) fa[x]=w;
		if(find(y)==y) fa[y]=w;
		x=pre[y];
	}
}

bool solve(int s)
{
	for(rg int i=1;i<=sum;++i) fa[i]=i,vis[i]=pre[i]=0;
	while(!q.empty()) q.pop();

	q.push(s);
	vis[s]=1;
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=nxt[i])
		{
			int y=ver[i];

			if(find(x)==find(y)||vis[y]==2) continue;
			if(!vis[y])
			{
				vis[y]=2; pre[y]=x;
				if(!match[y])
				{
					for(int k=y,p;k;k=p)
						p=match[pre[k]],match[k]=pre[k],match[pre[k]]=k;
					return 1;
				}
				vis[match[y]]=1,q.push(match[y]);
			}
			else
			{
				int w=lca(x,y);
				blossom(x,y,w);
				blossom(y,x,w);
			}
		}
	}
	return 0;
}
inline void add_(int x,int y)
{
	add(x,y);add(y,x);
}
int main()
{
	int T=read();
	while(T--)
	{
		memset(head,0,sizeof head);
		memset(match,0,sizeof match);
		memset(pre,0,sizeof pre);
		memset(vis,0,sizeof vis);
		n=read(),m=read(),e=read();
		/*1-n为各个球代表的点的编号,n-n+3m是筐代表点的编号*/
		sum=n+3*m;
		for(int i=1;i<=e;i++)
		{
			int x,y;
			x=read(),y=read();
			add_(x,n+y);
			add_(x,n+m+y);
			add_(x,n+(m<<1)+y);
		}
		for(int i=1;i<=m;i++)
		{
			add_(n+i,n+m+i);
			add_(n+m+i,n+(m<<1)+i);
			add_(n+i,n+(m<<1)+i);
		}
		int res=0;
		for(int i=1;i<=sum;i++)
			if(!match[i]) res+=solve(i);
		printf("%d\n",res-n);
		for(int i=1;i<=n;i++)
			printf("%d ",(match[i]-n-1)%m+1);
		printf("\n");
	}
	return 0;
}

```


---


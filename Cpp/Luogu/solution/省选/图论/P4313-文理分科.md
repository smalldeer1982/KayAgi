# 文理分科

## 题目描述

文理分科是一件很纠结的事情！（虽然看到这个题目的人肯定都没有纠结过）

小 P 所在的班级要进行文理分科。他的班级可以用一个 $n\times m$ 的矩阵进行描述，每个格子代表一个同学的座位。每位同学必须从文科和理科中选择一科。同学们在选择科目的时候会获得一个满意值。满意值按如下的方式得到：

- 如果第 $i$ 行第 $j$ 列的同学选择了文科，则他将获得 $art_{i,j}$ 的满意值，如果选择理科，将得到 $science_{i,j}$ 的满意值。

- 如果第 $i$ 行第 $j$ 列的同学选择了文科，并且他相邻（两个格子相邻当且仅当它们拥有一条相同的边）的同学全部选择了文科，则他会更开心，所以会增加 $same\text{\underline{ }}art_{i,j}$ 的满意值。

- 如果第 $i$ 行第 $j$ 列的同学选择了理科，并且他相邻的同学全部选择了理科，则增加 $same\text{\underline{ }}science_{i,j}$ 的满意值。

小 P 想知道，大家应该如何选择，才能使所有人的满意值之和最大。请告诉他这个最大值。

## 说明/提示

### 样例说明

1 表示选择文科，0 表示选择理科，方案如下：

1  0  0  1

0  1  0  0

1  0  0  0

### 数据范围

$n,m\leq 100$，读入数据均 $\leq 500$。                                                                                                                                                              

## 样例 #1

### 输入

```
3 4
13 2 4 13
7 13 8 12
18 17 0 5
8 13 15 4
11 3 8 11
11 18 6 5
1 2 3 4 
4 2 3 2
3 1 0 4
3 2 3 2
0 2 2 1
0 2 4 4 ```

### 输出

```
152```

# 题解

## 作者：为人民服务 (赞：67)

**题目背景**

2018年6月6日，明天就是高考，在此提前预祝各位OIers不论文科生，理科生高考都取得好成绩，文综，理综做的顺心。

$QwQ$，只是在下一个山东高一新生，取代文理分科纠结的是六选三的 $C^3_6$.

最后祝愿各位会的都对，蒙的都对，并送上一句名言。

** _经历了这么多痛苦的折磨，变得坚强，而与世隔绝的灵魂里消逝，为什么我枯竭的活力又获得了生命，那是因为明朗的月夜，紧随漆黑的长夜；那是因为和煦的东风，离不开繁枝茂叶；那是因为春天终于来临，冬天终于过去。_ **

				——雨果《看，乌云将倾盆大雨泼向这棵树》

**必备知识**

网络流及dinic算法

最大流最小割定理

**题目分析**

回归正题。

这个题很明显是一个最小割好题。~~但做的人怎么这么少？~~

我们把每一个人视作一个点 $i$，规定：$i$被割到$S$集里，代表这个人选文，$i$被割到$T$集里，代表这个人选理.

将$S$连向这个点，长度为art，如果该边被割，则说明不选文，不能获得art的收益，可得到science的收益。

将这个点连向$T$，长度为science，如果该边被割，则说明不选理，不能获得science的收益，可得到art的收益。

那么对于同时选择的情况，我们可以新建点。

对于几个相邻的点，我们新建一个点，将$S$连向这个点，长度为同时选文可获得的收益，如果该边被割，则说明这些人不同时选文，不能获得同时选文可获得的收益。

同样，我们新建一个点，将这个点连向$T$，长度为同时选理可获得的收益，如果该边被割，则说明这些人不同时选理，不能获得同时选理可获得的收益，

怎么保证不割这条边则必然都选同样的科目呢？

我们可以将新建的点，向相邻的那几个点中的每一个点（或从相邻的那几个点中的每一个点向新建的点）连一条长度为$inf$的边，这样的边在最小割中肯定不会存在，则保证了在代表共同选择收益的边不被割时（即都选一个科目）新建的点与相邻的点在同一个点集。问题得以解决。

通过Dinic算法求得该图的最小割，总收益减最小割即为最大收益。

论证完毕。

**建图方式**

把每一个人视作一个点 $i$。

将$S$连向这个点，长度为art。

将这个点连向$T$，长度为science。

新建点，将$S$连向这个点，长度为同时选文可获得的收益，并向相邻的那几个点中的每一个点连一条长度为$inf$的边。

新建点，将这个点连向$T$，长度为同时选理可获得的收益，从相邻的那几个点中的每一个点向新建的点连一条长度为$inf$的边。

**Code**
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
#include <queue>
#define Maxn 40001<<1
#define inf (unsigned)-1>>1
using namespace std;

int N,M;int S,T,sum,opt;
const int dx[6]={0,0,0,-1,1};
const int dy[6]={0,-1,1,0,0};
struct Edge {
	int v,flow,rev;
};
inline int read () {
    int X=0,w=1;char ch=0;
    while (ch<'0'||ch>'9')		{ if(ch=='-')	w=-1;ch=getchar(); }
    while (ch>='0'&&ch<='9')	{ X=(X<<1)+(X<<3)+ch-'0';ch=getchar(); }
    return X*w;
}
struct Graph {
	vector <Edge> e[Maxn];queue <int> Q;
	int level[Maxn];
	inline void addedge (int x,int y,int z) {
		e[x].push_back( (Edge){	y,z,e[y].size() } );
		e[y].push_back( (Edge){	x,0,e[x].size()-1} );
	}
	inline bool bfs () {
		memset(level,0,sizeof(level));
		Q.push(S);level[S]=1;
		while(!Q.empty()) {
			int u=Q.front();Q.pop();
			for(int i=0;i<e[u].size();i++) {
				int v=e[u][i].v;
				if( !level[v] && e[u][i].flow ) {
					level[v]=level[u]+1;
					Q.push(v);
				}
			}
		}
		return level[T];
	}
	int dfs (int x,int maxf) {
		if( x==T || maxf==0 )   return maxf;
		int pos=0;
		for(int i=0;i<e[x].size();i++) {
			int v=e[x][i].v;
			if( e[x][i].flow && level[v]==level[x]+1) {
				int f=dfs(v,min(e[x][i].flow,maxf));
				e[x][i].flow-=f;
				e[v][e[x][i].rev].flow+=f;
				pos+=f;
				maxf-=f;
			}
		}
		return pos;
	}
	inline int dinic () {
		int ans=0;
		while(bfs())    ans+=dfs(S,inf);
		return ans;
	}
} G ;
inline int getID (int i,int j) {
	return (i-1)*M+j;
}
int main () {
	N=read();M=read();S=0;T=N*M+1;opt=N*M+1;
	for(int i=1;i<=N;i++)
		for(int j=1;j<=M;j++) {
			int art=read(),id=getID(i,j);
			sum+=art;
			G.addedge(S,id,art);
		}
	for(int i=1;i<=N;i++)
		for(int j=1;j<=M;j++) {
			int science=read(),id=getID(i,j);
			sum+=science;
			G.addedge(id,T,science);
		}
	for(int i=1;i<=N;i++)
		for(int j=1;j<=M;j++) {
			int same_art=read(),id=getID(i,j);opt++;
			sum+=same_art;
			G.addedge(S,opt,same_art);
			G.addedge(opt,id,inf);
			for(int k=1;k<=4;k++)
				if( i+dx[k]>=1 && i+dx[k]<=N && j+dy[k]>=1 && j+dy[k]<=M )
					G.addedge(opt,getID(i+dx[k],j+dy[k]),inf);
		}
	for(int i=1;i<=N;i++)
		for(int j=1;j<=M;j++) {
			int same_science=read(),id=getID(i,j);opt++;
			sum+=same_science;
			G.addedge(opt,T,same_science);
			G.addedge(id,opt,inf);
			for(int k=1;k<=4;k++)
				if( i+dx[k]>=1 && i+dx[k]<=N && j+dy[k]>=1 && j+dy[k]<=M )
					G.addedge(getID(i+dx[k],j+dy[k]),opt,inf);
		}
	printf("%d\n",sum-G.dinic());
	return 0;
}
```

---

## 作者：jun头吉吉 (赞：38)

# P4313 【文理分科】
[$\color{green}{\text{更好的阅读体验}}$](https://chen-jia-liang.gitee.io/blog/2020/07/14/%E9%A2%98%E8%A7%A3-P4313-%E3%80%90%E6%96%87%E7%90%86%E5%88%86%E7%A7%91%E3%80%91/)
## 题意
每个人选文科或理科可以有满意值，几个人同时选文科或理科也可以获得满意值，求满意值的最大值。

~~??为什么文科是art~~
## 题解
看到这类**二者选其一**的模型，我们肯定能想到**最小割**。首先，我们先从矩阵中拿出小盆友$A$和TA的相邻同学$B$、$C$、$D$、$E$，怼到图上，在画上源点和汇点，分别代表文科和理科：

![](https://cdn.luogu.com.cn/upload/image_hosting/k49sl0e3.png)

假设没有额外的快乐值，我们可以这么连边：

![](https://cdn.luogu.com.cn/upload/image_hosting/uattarp3.png)

如果我们割去一条边，就代表着不选文科/理科，若图不连通，则代表每个点只与源点或汇点联通，**即每个人只选文科或理科**。然后我们再去考虑$same$值，显然，我们如果选了一条$science$的边，就要把$same\ art$删掉；同理，我们如果选了一条$art$的边，就要把$same\ science$删掉，因此，我们可以加上两个虚点，连上边：

![](https://cdn.luogu.com.cn/upload/image_hosting/d2c6o2gz.png)

建完了图剩下的代码就简单了
## 代码
```cpp
#pragma optimize(2)
#include<bits/stdc++.h>
using namespace std;
namespace in{
	char buf[1<<21],*p1=buf,*p2=buf;
	inline int getc(){
	    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;
	}
	template <typename T>inline void read(T& t){
	    t=0;int f=0;char ch=getc();
	    while (!isdigit(ch)){
	        if(ch=='-')f = 1;
	        ch=getc();
	    }
	    while(isdigit(ch)){
   	    	t=t*10+ch-48;
   	    	ch = getc();
   		}
		if(f)t=-t;
	}
	template <typename T,typename... Args> inline void read(T& t, Args&... args){
	    read(t);read(args...);
	}
}
namespace out{
	char buffer[1<<21];
	int p1=-1;
	const int p2 = (1<<21)-1;
	inline void flush() {
		fwrite(buffer,1,p1+1,stdout),
		p1=-1;
	}
	inline void putc(const char &x) {
		if(p1==p2)flush();
		buffer[++p1]=x;
	}
	template <typename T>void write(T x) {
		static char buf[15];
		static int len=-1;
		if(x>=0){
			do{
    			buf[++len]=x%10+48,x/=10;
    		}while (x);
		}else{
    		putc('-');
			do {
    			buf[++len]=-(x%10)+48,x/=10;
			}while(x);
		}
		while (len>=0)
			putc(buf[len]),--len;
	}
}
const int maxn=4000010,maxe=100010*2;
struct Graph{
	struct node{
		int v,w,nxt;
	}e[maxe<<1];
	int head[maxn],cur[maxn],tot;
	int dis[maxn];
	int s,t;
	void init(int _s,int _t){s=_s,t=_t;tot=1;memset(head,0,sizeof head);}
	Graph(int _s=0,int _t=0){init(_s,_t);}
	void add(int u,int v,int w){
		//printf("%d %d %d\n",u,v,w);
		e[++tot]=(node){v,w,head[u]},head[u]=tot;
		e[++tot]=(node){u,0,head[v]},head[v]=tot;
	}
	#define v e[i].v
	inline bool bfs(){
		queue<int>q;
		memset(dis,0,sizeof dis);
		memcpy(cur,head,sizeof head);
		dis[s]=1;q.push(s);
		while(q.size()){
			int u=q.front();q.pop();
			for(int i=head[u];i;i=e[i].nxt)
				if(!dis[v]&&e[i].w){
					dis[v]=dis[u]+1,q.push(v);
					if(v==t)return true;
				}
		}
		return  false;
	}
	int dfs(int u,int flow){
		if(u==t)return flow;
		int rest=flow;
		for(int i=cur[u];i&&rest;i=e[i].nxt){
			if(dis[v]==dis[u]+1&&e[i].w){
				int tmp=dfs(v,min(rest,e[i].w));
				rest-=tmp,e[i].w-=tmp,e[i^1].w+=tmp;
			}
			cur[u]=i;
		}
		if(rest==0)dis[u]=-1;
		return flow-rest;
	}
	#undef v
	int dinic(){
		int ans=0;
		while(bfs())
			while(int sth=dfs(s,2e9))
				ans+=sth;
		return ans;
	}
}G;
int n,m,x;
int sum,tot;
bool check(int x,int y){
	return x<=n&&x>=1&&y<=m&&y>=1;
}
#define P(i,j) ((i)-1)*m+(j)
signed main(){
	//freopen("1.in","r",stdin);
	in::read(n,m);
	tot=n*m;G.init(0,++tot);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			in::read(x);sum+=x;
			G.add(G.s,P(i,j),x);
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			in::read(x);sum+=x;
			G.add(P(i,j),G.t,x);
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			in::read(x);sum+=x;
			G.add(G.s,++tot,x);
			G.add(tot,P(i,j),1e9);
			if(check(i,j-1))G.add(tot,P(i,j-1),1e9);
			if(check(i,j+1))G.add(tot,P(i,j+1),1e9);
			if(check(i-1,j))G.add(tot,P(i-1,j),1e9);
			if(check(i+1,j))G.add(tot,P(i+1,j),1e9);
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			in::read(x);sum+=x;
			G.add(++tot,G.t,x);
			G.add(P(i,j),tot,1e9);
			if(check(i,j-1))G.add(P(i,j-1),tot,1e9);
			if(check(i,j+1))G.add(P(i,j+1),tot,1e9);
			if(check(i-1,j))G.add(P(i-1,j),tot,1e9);
			if(check(i+1,j))G.add(P(i+1,j),tot,1e9);
		}
	out::write(sum-G.dinic());
	out::flush();
}
```
## 举一反三
[happiness](https://www.luogu.com.cn/problem/P1646)

[小M的作物](https://www.luogu.com.cn/problem/P1361)

---

## 作者：maomao9173 (赞：16)

### 链接[Click Here](https://www.luogu.org/problemnew/show/P4313)
#### 这个题就是个板子的最小割多选一模型啦$QwQ$，这里介绍一种通用的解法。

#### 抛开组合收益不谈，这个题就是一个简单的最小割模型。我们只需要建出来这样一张图，在上面跑最小割，割掉的就是不用的，留下来的就是最大收益啦~\(≧▽≦)/~，是不是很显然呢？

![](http://images.cnblogs.com/cnblogs_com/maomao9173/1317473/o_cut.JPG)

#### 如果要考虑组合收益的话，我们把这个组合收益实体化成一个点来进行处理。还是上面那个图，我们假设$2$, $3$是以和$1$四连通的两个点。这样的话我们需要保证一件事情：

- 在$art_1, art_2, art_3$中，只要有一个被割掉（不选），那么$art$的组合收益就同时被割掉。

- 在$sci_1, sci_2, sci_3$中，只要有一个被割掉（不选），那么$sci$的组合收益就同时被割掉。

#### 根据这些要求，我们建出来了下面这样的一张图。

![](http://images.cnblogs.com/cnblogs_com/maomao9173/1317473/o_flow.JPG)

#### 很显然，这张图是可以满足上面的性质的。我们这样连边来看一下。

- $s -> art\_same(i, j)$&emsp;$flow = art\_ex[i][j]$ 

- $art\_same(i, j) -> linked\_nodes$&emsp;$flow = INFF$

#### 思考一下，假如我们割掉了$art$中的任意一个，那么$sci$那边一定有对应的边没有割掉，这样我们的$art\_same[1]$就会顺着没有被割掉的边流走啦$QwQ$(也就是还是被割掉了$QwQ$)

#### 同理，理科那边和更多点的情况，这种图都是适用的。

#### 关键需要注意的一件事情：在建图的时候，因为可能会出现$art\_same[i]$太大而另外一边的流量太小，无法完全割断的情况，我们要给它加上一个$INF$，在最后求和的时候再减掉。而且这个$INF$一定要低于$INFF$的数量级，中间的边一定要保证是不能割掉的！这一点相当重要。

#### 这种图是一种非常重要的最小割模型图，一定要会啊$QwQ$

```cpp
#include <bits/stdc++.h>
#define N 30100
#define M 480010
#define int long long
using namespace std;

const int INF = 0x3f3f3f3f;
const int INFF = 0x3f3f3f3f3f3f3f3fll;

int n, m, art[105][105], sci[105][105];
int art_ex[105][105], sci_ex[105][105];

int node (int x, int y) {return (x - 1) * m + y;}
int same_art (int x, int y) {return n * m * 1 + node (x, y);} 
int same_sci (int x, int y) {return n * m * 2 + node (x, y);}

int mv[5][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

bool in_map (int x, int y) {
	return 1 <= x && x <= n && 1 <= y && y <= m;
}

int cnt = -1, head[N];

struct edge {
	int nxt, to, f;
}e[M];

void add_edge (int from, int to, int flw) {
	e[++cnt].nxt = head[from];
	e[cnt].to = to;
	e[cnt].f = flw;
	head[from] = cnt;
}

queue <int> q;
#define fpop(x) x.front();x.pop()

int cur[N], deep[N];

bool bfs (int s, int t) {
	memcpy (cur, head, sizeof (head));
	memset (deep, 0x3f, sizeof (deep));
	deep[s] = 1; q.push (s);
	while (!q.empty ()) {
		int u = fpop (q);
		for (int i = head[u]; ~i; i = e[i].nxt) {
			int v = e[i].to;
			if (e[i].f && deep[v] == INFF) {
				deep[v] = deep[u] + 1;
				q.push (v);
			}
		}
	}
	return deep[t] != INFF;
}

int dfs (int u, int t, int lim) {
	if (u == t || !lim) {
		return lim;
	}
	int tmp = 0, flow = 0;
	for (int &i = cur[u]; ~i; i = e[i].nxt) {
		int v = e[i].to;
		if (deep[v] == deep[u] + 1) {
			tmp = dfs (v, t, min (lim, e[i].f));
			lim -= tmp;
			flow += tmp;
			e[i ^ 0].f -= tmp;
			e[i ^ 1].f += tmp;
			if (!lim) break;
		}
	}
	return flow;
}

int Dinic (int s, int t) {
	int min_cut = 0;
	while (bfs (s, t)) {
		min_cut += dfs (s, t, INFF);
	}
	return min_cut;
}

signed main () {
	memset (head, -1, sizeof (head));
	cin >> n >> m;
	int s = n * m * 3 + 1, t = n * m * 3 + 2;
	for (int i = 1; i <= n; ++i) for (int j = 1; j <= m; ++j) cin >> art[i][j];
	for (int i = 1; i <= n; ++i) for (int j = 1; j <= m; ++j) cin >> sci[i][j];
	for (int i = 1; i <= n; ++i) for (int j = 1; j <= m; ++j) cin >> art_ex[i][j];
	for (int i = 1; i <= n; ++i) for (int j = 1; j <= m; ++j) cin >> sci_ex[i][j];
	
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= m; ++j) {
			add_edge (s, node (i, j), art[i][j]); add_edge (node (i, j), s, 0);
			add_edge (node (i, j), t, sci[i][j]); add_edge (t, node (i, j), 0);
		}
	}
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= m; ++j) {
			add_edge (s, same_art (i, j), art_ex[i][j]); add_edge (same_art (i, j), s, 0);
			add_edge (same_sci (i, j), t, sci_ex[i][j]); add_edge (t, same_sci (i, j), 0);
			for (int k = 0; k < 5; ++k) {
				int tx = i + mv[k][0], ty = j + mv[k][1];
				if (in_map (tx, ty)) {
					add_edge (same_art (i, j), node (tx, ty), INFF); add_edge (node (tx, ty), same_art (i, j), 0);
					add_edge (node (tx, ty), same_sci (i, j), INFF); add_edge (same_sci (i, j), node (tx, ty), 0);
				}
			}
		}
	}
	int ans = 0;// n * m * INF;
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= m; ++j) {
			ans += art[i][j] + sci[i][j] + art_ex[i][j] + sci_ex[i][j];
		}
	}
	cout << ans - Dinic (s, t) << endl;
} 
```

---

## 作者：Nemlit (赞：12)

对于每一个人，要么选文科，要么选理科，典型的非黑即白问题，我们可以用最小割来解决。

又因为最大流=最小割，所以我们可以采用网络流来解决

但是我们怎么建边呢？

因为在这道题中，文理平等，所以我们可以将文科靠近源点，理科靠近汇点

对于每一个same值，我们只要有一个对应点选了另一个科目，那么我们就必须把same值剪掉。

也就是说，如果该边被割，则说明这些人不同时选一个科目，不能获得同时选这门科目可获得的收益。

我们还需要保证不割这条边则必然都选这个科目，我们可以将$(i,j)$’向相邻的那几个点对应的连一条边，长度为inf

这条边一定不会被割掉，也就保证了在都选择相同科目的收益的边不被割时，另一个科目的边会被割掉（不然会有流量一直流）。

### 具体连边方法如下：

令S集表示学文，T集表示学理

$S$向$(i,j)$连一条容量为$art[i][j]$的边

$(i,j)$向$T$连一条容量为$science[i][j]$的边

对于额外收益，新建一个点$(i,j)$’，向$(i,j)$和相邻四个点各连一条容量为无穷的边

$S$向$(i,j)$’连一条容量为$same_art[i][j]$的边

同时选理科的额外收益同理

每个最小割对应一种方案

答案就是sum-最小割

代码如下：
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define debug printf("Now is Line : %d\n",__LINE__)
#define file(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define inf 1234567890 
#define mod 1000000007
il int read()
{
    re int x=0,f=1;re char c=getchar();
    while(c<'0'||c>'9') {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return x*f;
}
#define maxn 105*105*3
struct edge
{
    int v,w,next;
}e[maxn*10];
int fx[5]={1,-1,0,0,0};
int fy[5]={0,0,1,-1,0};
int n,m,head[maxn],cnt=1,S,T,cur[maxn],dep[maxn],sum;
int art,sci,saa,sas; 
queue<int>q;
il void add(int u,int v,int w)
{
    e[++cnt]=(edge){v,w,head[u]};
    head[u]=cnt;
    e[++cnt]=(edge){u,0,head[v]};
    head[v]=cnt;
}
il void doit(int x,int y)
{
    for(re int i=0;i<5;++i)
    {
        int nx=x+fx[i],ny=y+fy[i];
        if(nx<1||ny<1||nx>n||ny>m) continue;
        add(n*m+(nx-1)*m+ny,(x-1)*m+y,inf);
        add((x-1)*m+y,2*n*m+(nx-1)*m+ny,inf);
    }
}
il bool bfs()
{
    memset(dep,0,sizeof(dep));
    memcpy(cur,head,sizeof(head));
    q.push(S); dep[S]=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(re int i=head[u];i;i=e[i].next)
        {
            int v=e[i].v;
            if(!dep[v]&&e[i].w>0)
            {
                dep[v]=dep[u]+1;
                q.push(v);
            }
        }
    }
    return dep[T]!=0;
}
il int dfs(int u,int mi)
{
    if(u==T) return mi;
    int ans=0;
    for(re int i=cur[u];i;i=e[i].next)
    {
        cur[u]=i;
        int v=e[i].v;
        if(e[i].w>0&&dep[v]==dep[u]+1)
        {
            int low=dfs(v,min(mi,e[i].w));
            if(low>0)
            {
                e[i].w-=low,e[i^1].w+=low;
                mi-=low; ans+=low;
            }
        }
    }
    return ans;
}
il int dinic()
{
    int low,ans=0;
    while(bfs())
    {
        while(low=dfs(S,inf)) ans+=low;
    }
    return ans;
}
int main()
{
    n=read(),m=read(); T=3*n*m+1;
    for(re int i=1;i<=n;++i) for(re int j=1;j<=m;++j) 
    art=read(),add(S,(i-1)*m+j,art),sum+=art;
    for(re int i=1;i<=n;++i) for(re int j=1;j<=m;++j) 
    sci=read(),add((i-1)*m+j,T,sci),sum+=sci;
    for(re int i=1;i<=n;++i) for(re int j=1;j<=m;++j) 
    saa=read(),add(S,n*m+(i-1)*m+j,saa),sum+=saa;
    for(re int i=1;i<=n;++i) for(re int j=1;j<=m;++j) 
    sas=read(),add(2*n*m+(i-1)*m+j,T,sas),sum+=sas;
    for(re int i=1;i<=n;++i) for(re int j=1;j<=m;++j) doit(i,j);
    printf("%d",sum-dinic());
    return 0;
}
```

---

## 作者：Augury (赞：6)

# 题解——P4313 文理分科

看了一下题解，似乎没有最大权闭合子图的做法。

发一篇题解，希望管理大大能给过。

个人认为最大权闭合子图要好理解一些。

## 前置知识

最大权闭合子图

如果您不知道什么是最大权闭合子图，您可以去看看[P2762 太空飞行计划问题](https://www.luogu.com.cn/problem/P2762)

## 题意

有 $n\times m$ 个人，在一个 $n\times m$ 的矩阵中。

- 如果第 $i$ 行第 $j$ 列的同学选择了文科，则他将获得 $art_{i,j}$ 的满意值，如果选择理科，将得到 $science_{i,j}$ 的满意值。

- 如果第 $i$ 行第 $j$ 列的同学选择了文科，并且他相邻的同学全部选择了文科，则增加 $sameart_{i,j}$ 的满意值。

- 如果第 $i$ 行第 $j$ 列的同学选择了理科，并且他相邻的同学全部选择了理科，则增加 $samescience_{i,j}$ 的满意值。

求总满意值最大可能是多少。

## 思路

我们发现，如果考虑先把每个点拆成两个点，一个表示选择文科，一个表示选择理科，那么指定会选重。

于是，我们假定初始所有人都选的文科，然后我们考虑~~策反~~让一部分人选择理科。

考虑一个人从文科改成理科会产生哪些贡献。

1. 首先，会直接获得 $science_{i,j}-art_{i,j}$ 的收益。
2. 其次，因为这个人本身不再是文科生，所以他自己的 $sameart$ 消失。
3. 因为这个人不再选择文科，所以他周围的四个点不再满足 $sameart$ 的生效条件，所以这些点的 $sameart$ 消失。

所以，我们知道了，如果现在选择让一个人选择理科，周围这 $5$ 个点的 $sameart$ 就会消失。

然后考虑 $samescience$ 的贡献。

1. 首先，我们一定会得到 $samescience_{i,j}$ 的收益。
2. 其次，这个点附近的五个点都要选择理科。

于是，我们考虑将每个点拆成三个：

1. 价值为 $science_{i,j}-art_{i,j}$ 的点，表示一个人从文科改成理科可以直接获得的收益。
2. 价值为 $-sameart_{i,j}$ 的点，表示周围几个点选择理科的额外亏损。
3. 价值为 $samescience_{i,j}$ 的点，表示周围几个点都选择理科的额外收益。

然后就可以套用最大权闭合子图了

1. 如果我要选择一个点的 $1$ 类点，我就要选择周围这 $5$ 个点的 $2$ 类点。
2. 如果我要选择一个点的 $3$ 类点，我就要选择这个点周围的 $5$ 个 $1$ 类点。

这正是最大权闭合子图的模型。

然后，直接建图跑网络流即可。

注意，因为我们计算的是相对于全选文科的贡献，所以得到答案后要加上全选文科的收益。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int ans=0,op=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')op=1;ch=getchar();}
	while(ch>='0'&&ch<='9'){ans=(ans<<3)+(ans<<1)+(ch^48);ch=getchar();}
	if(op)ans=-ans;
	return ans;
}
const int maxn=110;
const int maxnode=3e4+10;
const int dx[]={0,0,1,-1};
const int dy[]={1,-1,0,0};
const int inf=0x3f3f3f3f;
int n,m;
int ar[maxn][maxn],sc[maxn][maxn],sa[maxn][maxn],ss[maxn][maxn];
int num[maxn][maxn];//每个点的编号
int node=0;//点数计数器
int ans=0;//全选文科的答案
int s,t;
struct edge{
	int u,v,f,nxt;
}e[maxnode<<5];
int fst[maxnode],ce=0;
int dep[maxnode],gap[maxnode];
int maxflow=0;
int ex;
void add(int u,int v,int f){
	e[ce]=(edge){u,v,f,fst[u]};
	fst[u]=ce++;
	e[ce]=(edge){v,u,0,fst[v]};
	fst[v]=ce++;
}
void build(){
	memset(fst,-1,sizeof(fst));
	s=0,t=node*3+1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			int val=sc[i][j]-ar[i][j];//改成理科的直接贡献
			if(val>=0)add(s,num[i][j],val),ex+=val;
			else add(num[i][j],t,-val);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			add(num[i][j],num[i][j]+node,inf);
			add(num[i][j]+node,t,sa[i][j]);//改成理科的额外亏损
			for(int dir=0;dir<4;dir++){
				int nx=i+dx[dir],ny=j+dy[dir];
				if(nx<1||nx>n||ny<1||ny>m)continue;
				add(num[i][j],num[nx][ny]+node,inf);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			add(num[i][j]+(node<<1),num[i][j],inf);
			add(s,num[i][j]+(node<<1),ss[i][j]);//改成理科的额外收益
			ex+=ss[i][j];
			for(int dir=0;dir<4;dir++){
				int nx=i+dx[dir],ny=j+dy[dir];
				if(nx<1||nx>n||ny<1||ny>m)continue;
				add(num[i][j]+(node<<1),num[nx][ny],inf);
			}
		}
	}
}
inline void bfs(){//isap
	memset(dep,-1,sizeof(dep));
	memset(gap,0,sizeof(gap));
	queue<int>q;
	dep[t]=0;
	q.push(t);
	while(!q.empty()){
		register int now=q.front();q.pop();
		++gap[dep[now]];
		for(register int i=fst[now];~i;i=e[i].nxt){
			if(e[i^1].f<=0||~dep[e[i].v])continue;
			dep[e[i].v]=dep[now]+1;
			q.push(e[i].v);
		}
	}
}
inline int dfs(register int now,int sum){//isap
	if(now==t||sum==0)return sum;
	register int ans=0;
	for(register int i=fst[now];~i;i=e[i].nxt){
		if(e[i].f<=0||dep[e[i].v]+1!=dep[now])continue;
		register int flow=dfs(e[i].v,min(e[i].f,sum));
		e[i].f-=flow;
		e[i^1].f+=flow;
		sum-=flow;
		ans+=flow;
		if(!sum)return ans;
	}
	if(!--gap[dep[now]])dep[s]=t+1;
	++gap[++dep[now]];
	return ans;
}
inline int isap(){//isap
	maxflow=0;
	bfs();
	while(dep[s]<=t)maxflow+=dfs(s,inf);
	return maxflow;
}
signed main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)ar[i][j]=read();
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)sc[i][j]=read();
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)sa[i][j]=read();
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)ss[i][j]=read();
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)num[i][j]=++node;
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)ans+=ar[i][j];
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)ans+=sa[i][j];
	build();//建图
	isap();//isap网络流
	cout<<ans+ex-maxflow;//计算答案并输出
	return 0;
}
```

---

## 作者：Illusory_dimes (赞：5)

### 题目大意
可以与[这道题](https://www.luogu.com.cn/problem/P1361)产生极大的共鸣。。（实际上就是双倍经验）

一共有 $n\cdot m$ 个学生，排成了 $n$ 行 $m$ 列，每个人有两个选择 $A$ 和 $B$ ，且各有一个收益值，还有两个限制性收益值，条件是四周的人与其的选择一致。

求最大收益

$n,m\leq 100$ ，单个收益值 $\leq 500$

### solution
一共就两个选择，“二分图”上最小割无疑了，左边一溜就定为选择 $A$ ，右边一溜就定为选择 $B$ 。

设一个源点，一个汇点，前两个收益直接加边就行了。

后面两个呢？

根据每一个限制性条件，四周只要有一个点做了另一个选择，那么这个限制性收益值就一定不能选；也就是说，如果不能选该收益值，则说明周围这四个人没有同时做一个选择。

所以，若要选这个收益值，则需要保证周围的四个人都做同样的选择，**于是将该点向相邻的那四个点对应的连一条边**，长度为 $\infty$ ，同时，为了不会一直流，就会让另一个选择的的收益值被舍弃。

但是如果直接这么建图从流通的角度来看会有不少的问题，其实因为会有很多重边，从逻辑上就不对劲。

看到上面的黑体字，问题就出在那里。

怎么办呢？

有对于两个选择的限制性收益值，那对于么每一个选择都重新建 $n\cdot m$ 个点再连就行了。

最大收益就是全部收益值总和减去最小割。

好了，放代码吧
```cpp
#include<bits/stdc++.h>
#define id(i,j) (i-1)*m+j
using namespace std;
typedef long long ll;
const int N=3e4+10,M=3e5+10;
const int INF=0x3f3f3f3f;
const int xx[]={0,0,0,1,-1},yy[]={0,1,-1,0,0};
int n,m,s,t,cur[N],gap[N],dep[N],q[N];
//cur[i]:当前弧优化,gap[i]:GAP优化 
int fst[N],nxt[M],to[M],val[M],tot=2;
int ans,nm,mn;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline void add(int u,int v,int w)
{
	nxt[tot]=fst[u];
	to[tot]=v,val[tot]=1ll*w;
	fst[u]=tot;++tot;
	nxt[tot]=fst[v];
	to[tot]=u,val[tot]=0;
	fst[v]=tot;++tot;
}
inline void bfs()
{
	for(int i=s;i<=t;++i)
	dep[i]=q[i]=gap[i]=0;
	int hd=0,tl=1;
	dep[t]=1,gap[1]=1;q[tl]=t;
	//这是从汇点开始
	while(hd<tl)
	{
		int u=q[++hd];
		for(int i=fst[u];i;i=nxt[i])
		{
			int v=to[i];
			if(!dep[v])
			{
				dep[v]=dep[u]+1;
				++gap[dep[v]];
				q[++tl]=v;
			}
		}
	}
}
ll dfs(int u,ll lim)
{
	if(u==t)return lim;
	int ans=0,tmp;
	for(int i=cur[u];i;i=nxt[i])
	{
		int v=to[i];
		cur[u]=i;
		if(dep[v]==dep[u]-1&&val[i])
		{
			tmp=dfs(v,min(lim,1ll*val[i]));
			val[i]-=tmp,lim-=tmp;
			ans+=tmp,val[i^1]+=tmp;
			if(!lim)break;
		}
	}
	if((!ans)||lim)
	{
		if(--gap[dep[u]]==0)dep[s]=3*n*m+2;
		++gap[++dep[u]];
	}
	return ans;
}
inline ll isap()
{
	ll ans=0;
	bfs();
	while(dep[s]<=3*n*m+2)
	{
		memcpy(cur,fst,sizeof(cur));
		ans+=dfs(s,INF);
	}
	return ans;
}
int main()
{
	n=read(),m=read(),nm=n*m,mn=2*n*m,s=0,t=3*n*m+1;
	for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)for(int k=0;k<5;++k)
	{
		int x=i+xx[k],y=j+yy[k];
		if(x<1||y<1||x>n||y>m)continue;
		add(id(x,y)+nm,id(i,j),INF);
		add(id(i,j),id(x,y)+mn,INF);
	}
	for(int i=1;i<=n;++i)for(int j=1;j<=m;++j){int art=read();ans+=art,add(s,id(i,j),art);}
	for(int i=1;i<=n;++i)for(int j=1;j<=m;++j){int sci=read();ans+=sci,add(id(i,j),t,sci);}
	for(int i=1;i<=n;++i)for(int j=1;j<=m;++j){int sart=read();ans+=sart,add(s,id(i,j)+nm,sart);}
	for(int i=1;i<=n;++i)for(int j=1;j<=m;++j){int ssci=read();ans+=ssci,add(id(i,j)+mn,t,ssci);}
	printf("%d",ans-isap());
	return 0;
}
```
只求能帮助到几个人罢。。

---

## 作者：FxorG (赞：4)

## $\text{Solution:}$

考虑这种非 $1$ 即 $0$ 的且 $n,m$ 不大的一般都是用所有的答案减去最小割，得到最大的答案。

下文超源用 $s$ 表示，超汇用 $t$。

考虑1:

$add(s,(i,j),art_{i,j}),add((i,j),t,science_{i,j})$

即割开其中一条边表示 $(i,j)$ 不在哪一个集合当中。

Q: 为什么不能两条都割或者不割？

A：两条都割的话花费下来显然不是最小割，不割的话 $(s,t)$ 仍联通。

2,3:

我们可以建个新点，然后将 $(i,j)$ 连 $inf$ 到新点上，因为 $inf$ 所以一定不会被割。因为 $inf$ 一定不被割，且我们要让 $(i,j)$ 相邻的都和它选一样，直接 $(i,j)$ 向相邻的连 $inf$ 即可，注意下文理科对应向 $s$ 与 $t$ 连边。

根据最小割=最大流，跑个 dinic 即可。

```cpp
#include <bits/stdc++.h>

#define N 100005
#define M 2000005
#define int long long
#define inf (int)(2e18)
#define ID(X,Y) ((X-1)*m+Y)

using namespace std;

struct edge {
	int nex,to,w;
}e[M];

int head[N],mov[2][4]={{1,-1,0,0},{0,0,1,-1}},cnt=1;
int n,m,s,t,tot,ans;

int rd() {
	int f=1,sum=0; char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) {sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}
	return sum*f;
}

void add(int x,int y,int z) {
	e[++cnt]=edge{head[x],y,z};
	head[x]=cnt;
}

queue<int>q;
int chead[N],dis[N];
bool bfs() {
	while(!q.empty()) q.pop();
	for(int i=1;i<=tot;i++) dis[i]=0,chead[i]=head[i];
	q.push(s); dis[s]=1;
	while(!q.empty()) {
		int x=q.front(); q.pop();
		for(int i=head[x];i;i=e[i].nex) {
			int y=e[i].to;
			if(!dis[y]&&e[i].w) {
				dis[y]=dis[x]+1;
				q.push(y);
			}
		}
	}
	return dis[t];
}

int solve(int x,int lim) {
	if(x==t||!lim) return lim;
	int flow=0,fl;
	//cout<<x<<" "<<s<<" "<<t<<endl;
	for(int i=chead[x];i&&lim;i=e[i].nex) {
		int y=e[i].to; chead[x]=i;
		if(dis[y]==dis[x]+1&&e[i].w) {
			fl=solve(y,min(e[i].w,lim));
			flow+=fl; lim-=fl;
			e[i].w-=fl; e[i^1].w+=fl;
		}
	}
	return flow;
}

void dinic() {
	while(bfs()) ans-=solve(s,inf);
}

signed main() {
	int x;
	n=rd(); m=rd(); tot=n*m; s=++tot; t=++tot;
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			x=rd();
			ans+=x;
			add(s,ID(i,j),x); add(ID(i,j),s,0);
		}
	}
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			x=rd();
			ans+=x;
			add(ID(i,j),t,x); add(t,ID(i,j),0);
		}
	}
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			x=rd();
			ans+=x; ++tot;
			add(s,tot,x); add(tot,s,0);
			add(tot,ID(i,j),inf); add(ID(i,j),tot,0);
			for(int k=0;k<4;k++) {
				int dx=i+mov[0][k],dy=j+mov[1][k];
				if(dx<1||dx>n||dy<1||dy>m) continue;
				add(tot,ID(dx,dy),inf); add(ID(dx,dy),tot,0); 
			}
		}
	}
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			x=rd();
			ans+=x; ++tot;
			add(tot,t,x); add(t,tot,0);
			add(ID(i,j),tot,inf); add(tot,ID(i,j),0);
			for(int k=0;k<4;k++) {
				int dx=i+mov[0][k],dy=j+mov[1][k];
				if(dx<1||dx>n||dy<1||dy>m) continue;
				add(ID(dx,dy),tot,inf); add(tot,ID(dx,dy),0);  
			}
		}
	}
	//cout<<ans<<endl;
	dinic();
	cout<<ans;
	return 0;
}
```



---

## 作者：tzc_wk (赞：4)

安利个人 blog：https://www.cnblogs.com/ET2006/

碰到这种非 A 即 B 的类型的题目，当然用最小割咯！

考虑这样建图：

1. 从 $S$ 向每个点连容量为 $art_{i,j}$ 的边，若割掉这条边表示 $i$ 行 $j$ 列的人选择理科。
2. 从每个点连 $T$ 容量为 $science_{i,j}$ 的边，若割掉这条边表示 $i$ 行 $j$ 列的人选择文科。
3. 对于每个 $(i,j)$，新建一个点 $u1_{i,j}$，连一条从 $S$ 到 $u1_{i,j}$，容量为 $sameart_{i,j}$ 的边，并从 $u1_{i,j}$ 向 $(i,j),(i-1,j),(i,j-1),(i+1,j),(i,j+1)$ 连容量为 INF 的边。若割掉 $S$ 与 $u1_{i,j}$ 之间的边表示没有 $sameart_{i,j}$ 的贡献。
4. 对于每个 $(i,j)$，再新建一个点 $u2_{i,j}$，连一条从 $u2_{i,j}$ 到 $T$，容量为 $samescinece_{i,j}$ 的边，并从 $(i,j),(i-1,j),(i,j-1),(i+1,j),(i,j+1)$ 向 $u2_{i,j}$ 连容量为 INF 的边。若割掉 $u2_{i,j}$ 与 $T$ 之间的边表示没有 $samescience_{i,j}$ 的贡献。

然后拿所有 $art_{i,j},science_{i,j},sameart_{i,j},samescience_{i,j}$ 的和减去最小割就是答案。

为什么？其实就是我在网络流的 blog 中“网络流建图技巧”中第 4 点提到的情况的扩展。我们考虑最最最最理想的情况，那就是 $art_{i,j},science_{i,j},sameart_{i,j},samescience_{i,j}$ 的贡献全都被累加进答案中。

但这样显然是不合法的。考虑我们最小割是怎样把这些不合法的情况排除在外的。首先一个人 $(i,j)$ 不能既选文科又选理科——否则就存在 $S\to(i,j)\to T$ 的路径了。故 $S\to (i,j)$ 以及 $(i,j)\to T$ 的边必须恰好一条被割掉。其次，也不可能出现 $sameart_{i,j}$ 的贡献被累加进答案，却在 $(i,j)$ 周围存在某个人 $(x,y)$ 选理科的情况——否则，由于 $sameart_{i,j}$ 的贡献被累加进答案，故 $S$ 与 $u1_{i,j}$ 之间的边没有被割掉；由于 $(x,y)$ 选理科，故 $(x,y)$ 与 $T$ 之间的边没有被割掉。而 $(x,y)$ 在 $(i,j)$ 周围，故 $u1_{i,j}$ 与 $(x,y)$ 之间有边，故存在 $S\to u1_{i,j}\to(x,y)\to T$ 的路径，不符合最小割的定义。

故这样跑最小割后跑出来的方案是合法的。

---

到这里，我一直有个疑问，想必也有不少人和我有一样的疑问。那就是出现某个 $(i,j)$，它与 $S,T$ 之间的边全都割掉了怎么办，那不就等价于 $(i,j)$ 既不选文科也不选理科了吗？

这里给出解答：

重新回顾一下割的定义，我们对于割的最原始的定义是将 $V$ 划分成两个不相交的集合 $A,B$，使得 $S\in A,T\in B$。并在此基础上定义了割的权值为 $\sum\limits_{u\in A,v\in B}c(u,v)$。而不是所谓的割掉一些边，使得 $S$ 与 $T$ 不连通。如果按照后者的定义来看可能会出现某个 $(i,j)$，它与 $S,T$ 之间的边全都割掉；不过按照前者的定义来看是不会出现这种情况了。因为如果存在某个 $(i,j)$，它与 $S,T$ 之间的边全都割掉了，我们考虑 $(i,j)$ 究竟是属于集合 $A$ 还是集合 $B$，如果 $(i,j)\in A$，那么它与 $S$ 的边的权值就不会被累加到答案中；同理如果 $(i,j)\in B$，那么它与 $T$ 的边的权值就不会被累加到答案中。故这种情况是不会出现的。

那么为什么很多人（包括我）会把割的定义误解成后者呢？因为如果按照后者的定义来理解，那最大流等于最小割的定理也是成立的；也就是说如果你割掉了一个集合 $E'\subseteq E$ 中的边使得 $S$ 与 $T$ 不连通，那么 $E'$ 中所有边容量之和的最小值就等于最大流。

证明：设 $A$ 为割掉 $E'$ 后 $S$ 能到达的点集，$B$ 为割掉 $E'$ 后能到达 $T$ 的点集。如果割掉 $E'$ 后存在某个点 $u$ 既不属于 $A$ 也不属于 $B$，那么把 $u$ 归约到 $A$ 或 $B$ 中割的权值肯定会更小。否则，设 $W$ 为割 $A,B$ 的权值，显然 $A,B$ 之间的边肯定都属于 $E'$，否则 $S$ 与 $T$ 就连通了。而 $E'$ 中可能还含有故 $E'\text{的权值和}\leq W$。也就是说每个 $E'$ 都能映射到一个割 $A,B$ 上并且 $E'$ 的权值和不小于割 $A,B$ 的权值。故原命题成立。

代码就不贴了。

---

## 作者：zhimao (赞：4)

## 前言  ~~废话~~
网络流这玩意很神奇，包括一堆乱七八糟的东西,什么最大流，最小割，费用流，有上下界的网络流；还有各种算法和它们玄学的复杂度；更神奇的是能通过一些奇奇怪怪的建边方法把一些奇奇怪怪的，看似与网络流无关的题目搞成网络流，比如此题。
## 题意
对一个 $n\times m$ 的矩阵染色，染一种颜色可以得到一定价值，当某一个格子与所有其相邻的格子染同种色可以得到一些额外价值。求最大总价值。

看似与网络流没啥关系，是吧。

## 分析
事实上，此题蕴含一个模型：**二者取一式问题** 。什么是二者取一式问题？即有一些元素，把它们放入两个集合（一个元素只能放入一个集合）中能分别得到一定价值，此外对于一些元素，它们同时放入一个集合还能得到一定价值，求最大总价值。

与此题是不是类似？其实，这个模型可以用**最小割**做！为什么呢？对一个元素来讲，它只能选一个集合，我们把一个集合（记为A）弄成源点，另一集合（记为B）弄成汇点，元素为中间点，从源点向元素连一条流量为价值的边，从元素向汇点也连一条流量为价值的边，这样割了一条边（设为A），则表示不选A集合。
![](https://cdn.luogu.com.cn/upload/image_hosting/6nwh46r3.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/1imf0apb.png)
那那些组合呢?我们举选入A集合的组合的栗子，从字面意思可得，只有组合中所有点与源点的边不被割掉才能得到价值，所以此时点与汇点的边都割掉才行。于是根据最小割的定义，我们构造出了一种建边方法：建一个新节点，从源点向新节点建流量为价值的边，再从新节点向每个组合中的点连一条流量无穷大的边（为什么呢，因为防止割了这条边而不是连向汇点的边）就好了。选入B集合的雷同。然后跑一遍最大流，就求出最小割了。
![](https://cdn.luogu.com.cn/upload/image_hosting/1trzejjy.png)
不理解的可以结合图来理解。

我们求出最小割后，得出的是不要的价值，用总价值减去最小割后的得到的就是最大价值。正确性证明：假如有更大价值，则图中必还有残余流量，说明有元素进了两集合，错误。

此题中，黑白两色为集合，格子为元素，每组相邻格子为组合。板子套进去就好了。

时间复杂度？额，我的代码反正都在 100ms 以内。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int head[300005],next[8000005],went[8000005],cur[300005],lr[300005],dep[300005],n,m,p,q,len,s,t,cnt,sum;
int cap[8000005],ans;
void add(int x,int y,int z)
{
    next[len]=head[x];
    head[x]=len;
    went[len]=y;
    cap[len]=z;
    ++len;
}
int bfs()
{
	int r=1;
	for(int i=1;i<=cnt+10;i++)
	{
		cur[i]=head[i];
		dep[i]=0; 
	} 
	lr[1]=p;dep[p]=1;
	for(int l=1;l<=r;l++)
	{
		int k=lr[l];
		for(int i=head[k];i>=0;i=next[i])
		if(cap[i]>0&&dep[went[i]]==0)
		{
			dep[went[i]]=dep[k]+1;
			lr[++r]=went[i]; 
		}
	}
	return dep[q];
}
int dfs(int x,int y)
{
	if(x==q) return y;
	int sum=0;
	int i=cur[x];
	while(i>=0)
	{
    	if(cap[i]>0&&dep[went[i]]>dep[x])
	    {
		    int t=dfs(went[i],min(y,cap[i]));
			y-=t;
			cap[i]-=t;
			cap[i^1]+=t;
			sum+=t;
			if(y==0) return sum;
		}
		i=next[i];
		cur[x]=i;
    }
	if(sum==0) dep[x]=0;
	return sum;
}
int main()
{
	scanf("%d%d",&n,&m); 
    p=1;q=2;cnt=2;
	for(int i=1;i<=100001;i++) head[i]=-1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            int x;
            scanf("%d",&x);
            ++cnt;sum+=x;
            add(p,cnt,x);
            add(cnt,p,0);
        }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            int x;
            scanf("%d",&x);
            sum+=x;
            add(i*m+j-m+2,q,x);
            add(q,i*m+j-m+2,0);
        }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            int x;
            scanf("%d",&x);
            ++cnt;sum+=x;
            add(p,cnt,x);
            add(cnt,p,0);
            add(cnt,i*m+j-m+2,2000000000);
            add(i*m+j-m+2,cnt,0);
            if(i<n)
            {
                add(cnt,i*m+j+2,2000000000);
                add(i*m+j+2,cnt,0);
            }
            if(i>1)
            {
                add(cnt,i*m+j+2-m-m,2000000000);
                add(i*m+j+2-m-m,cnt,0);
            }
            if(j<m)
            {
                add(cnt,i*m+j+3-m,2000000000);
                add(i*m+j+3-m,cnt,0);
            }
            if(j>1)
            {
                add(cnt,i*m+j+1-m,2000000000);
                add(i*m+j+1-m,cnt,0);
            }
        }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            int x;
            scanf("%d",&x);
            ++cnt;sum+=x;
            add(cnt,q,x);
            add(q,cnt,0);
            add(i*m+j-m+2,cnt,2000000000);
            add(cnt,i*m+j-m+2,0);
            if(i<n)
            {
                add(i*m+j+2,cnt,2000000000);
                add(cnt,i*m+j+2,0);
            }
            if(i>1)
            {
                add(i*m+j+2-m-m,cnt,2000000000);
                add(cnt,i*m+j+2-m-m,0);
            }
            if(j<m)
            {
                add(i*m+j+3-m,cnt,2000000000);
                add(cnt,i*m+j+3-m,0);
            }
            if(j>1)
            {
                add(i*m+j+1-m,cnt,2000000000);
                add(cnt,i*m+j+1-m,0);
            }
        }
	while(bfs())
	{
		dep[q]=2000001;
		int x=p;
		int y=2000000000;
		ans+=dfs(x,y);
	}
    ans=sum-ans;
	cout<<ans;
}

```

---

## 作者：ker_xyxyxyx_xxs (赞：2)

[P4313 文理分科](https://www.luogu.com.cn/problem/P4313)

题意：略

思路：建图+（标签写的）最小割

这个题也是非常明显，可以用容斥，期望最大值 $ - $ 最小代价求出（也就是让所有人分为两个不同的集合，需要花费多少价值）

建图：这道题是一种非常经典的模型，如果你做过[P1361 小M的作物](https://www.luogu.com.cn/problem/P1361)或者[P1646 [国家集训队]happiness](https://www.luogu.com.cn/problem/P1646)你就会知道（强烈推荐这两道，尤其是后面那道）

说正题，前两个矩阵，代表每个人的满意度，令源点为文科，汇点为理科（如下图qwq），每个人分别向源点和汇点连一条容量为当前这个人的满意度的边

~~这里作者偷个懒，给大家画一个小数据~~ 记得网络流要连反向为 $ 0 $ 的边

再看后两个矩阵，为周围一群人如果选同一科的额外满意值，~~根据经验~~，我们要将这一些人连在一起，但是怎么保证他们都选同一个科目呢？很简单，容量为 $ \infty $ 即可，所以我们对于每一个矩阵中的每一个人都开一个虚拟点，向当前点周围所有人对应的节点连一条容量为 $ \infty $ 的边，如果是第一个矩阵（文科），源点向虚拟点连当前点满意值。如果是理科，虚拟点向汇点连容量为当前点满意值，最后用期望最大值  -  最小割值即可

代码实现难度不大。连边可用广搜以简洁代码

$ Code $
```cpp
# include <iostream>
# include <cstdio>
# include <queue>
# include <cstring>

using namespace std;

const int N = 2e6 + 5;
const int M = 1e7 + 5;
const int inf = 0x7fffffff;
int S , T;
typedef struct {
	int x , y , z , next;
}Edge;
Edge Kikyo[M];
int E = 1 , elast_Kikyo[N];
void add_Kikyo(int x , int y , int z) {
	E ++;
	Kikyo[E].x = x;
	Kikyo[E].y = y;
	Kikyo[E].z = z;
	Kikyo[E].next = elast_Kikyo[x];
	elast_Kikyo[x] = E;
} 
int dis_Kikyo[N] , cnt_Kikyo[N];
void bfs_Kikyo(int kikyo) {
	queue<int> q;
	q.push(kikyo);
	dis_Kikyo[kikyo] = 0;
	cnt_Kikyo[S] = 1;
	while (!q.empty()) {
		int kikyo_ = q.front();
		q.pop();
		for (int i = elast_Kikyo[kikyo_] ; i ; i = Kikyo[i].next) {
			int Kikyo_ = Kikyo[i].y;
			if (dis_Kikyo[Kikyo_] != -1) continue;
			dis_Kikyo[Kikyo_] = dis_Kikyo[kikyo_] + 1;
			q.push(Kikyo_);
			cnt_Kikyo[dis_Kikyo[Kikyo_]] ++;
		}
	}
}
int cur_Kikyo[N];
int dfs_Kikyo(int u , int flow) {
	if (u == T) return flow;
	int Kikyo_ = 0 , kikyo_;
	for (int i = cur_Kikyo[u] ; i ; i = Kikyo[i].next) {
		cur_Kikyo[u] = i;
		int v = Kikyo[i].y;
		if (Kikyo[i].z > 0 && dis_Kikyo[u] == dis_Kikyo[v] + 1) {
			kikyo_ = dfs_Kikyo(v , min(flow - Kikyo_ , Kikyo[i].z));
			Kikyo[i].z -= kikyo_;
			Kikyo[i ^ 1].z += kikyo_;
			Kikyo_ += kikyo_;
			if (Kikyo_ == flow) return Kikyo_;
		}
	}
	if (dis_Kikyo[S] >= T) return Kikyo_;
	cur_Kikyo[u] = elast_Kikyo[u];
	if (-- cnt_Kikyo[dis_Kikyo[u]] == 0) dis_Kikyo[S] = T;
	cnt_Kikyo[++ dis_Kikyo[u]] ++;
	return Kikyo_;
}
int Kikyo_Isap() {
	int Kikyo_ = 0;
	memset(cnt_Kikyo , 0 , sizeof cnt_Kikyo);
	memset(dis_Kikyo , -1 , sizeof dis_Kikyo);
	bfs_Kikyo(T);
	for (int i = 0 ; i <= T ; i ++) {
		cur_Kikyo[i] = elast_Kikyo[i];
	}
	while (dis_Kikyo[S] < T) Kikyo_ += dfs_Kikyo(S , inf);
	return Kikyo_;
}
int n , m;
int Kikyo_;
int id_Kikyo(int x , int y) {
	return (x - 1) * m + y;
}
int dx[5] = {0 , 1 , 0 , -1 , 0};
int dy[5] = {0 , 0 , 1 , 0 , -1};
int sum_Kikyo = 0;
bool Kikyo_Imap(int x , int y) {
	if (x < 1 || y < 1 || x > n || y > m) return false;
	else return true; 
}
int main() {
	cin >> n >> m;
	S = 0 , T = n * m * 3 + 1;
	for (int i = 1 ; i <= n ; i ++) {
		for (int j = 1 ; j <= m ; j ++) {
			scanf("%d" , &Kikyo_);
			sum_Kikyo += Kikyo_;
			add_Kikyo(S , id_Kikyo(i , j) , Kikyo_);
			add_Kikyo(id_Kikyo(i , j) , S , 0);
		}
	}
	for (int i = 1 ; i <= n ; i ++) {
		for (int j = 1 ; j <= m ; j ++) {
			scanf("%d" , &Kikyo_);
			sum_Kikyo += Kikyo_;
			add_Kikyo(id_Kikyo(i , j) , T , Kikyo_);
			add_Kikyo(T , id_Kikyo(i , j) , 0);
		}
	}

	for (int i = 1 ; i <= n ; i ++) {
		for (int j = 1 ; j <= m ; j ++) {
			scanf("%d" , &Kikyo_);
			sum_Kikyo += Kikyo_;
			add_Kikyo(S , n * m + id_Kikyo(i , j) , Kikyo_);
			add_Kikyo(n * m + id_Kikyo(i , j) , S , 0);
			for (int jk = 0 ; jk < 5 ; jk ++) {
				int tx = i + dx[jk];
				int ty = j + dy[jk];
				if (Kikyo_Imap(tx , ty) == true) {
					add_Kikyo(n * m + id_Kikyo(i , j) , id_Kikyo(tx , ty) , inf);
					add_Kikyo(id_Kikyo(tx , ty) , n * m + id_Kikyo(i , j) , 0);
				}
			}
		}
	}

	for (int i = 1 ; i <= n ; i ++) {
		for (int j = 1 ; j <= m ; j ++) {
			scanf("%d" , &Kikyo_);
			sum_Kikyo += Kikyo_;
			add_Kikyo((n * m << 1) + id_Kikyo(i , j) , T , Kikyo_);
			add_Kikyo(T , (n * m << 1) + id_Kikyo(i , j) , 0);
			for (int jk = 0 ; jk < 5 ; jk ++) {
				int tx = i + dx[jk];
				int ty = j + dy[jk];
				if (Kikyo_Imap(tx , ty) == true) {
					add_Kikyo(id_Kikyo(tx , ty) , (n * m << 1) + id_Kikyo(i , j) , inf);
					add_Kikyo((n * m << 1) + id_Kikyo(i , j) , id_Kikyo(tx , ty) , 0);
				}
			}
		}
	}
	printf("%d\n" , sum_Kikyo - Kikyo_Isap());
	return 0;
}

```



---

## 作者：crescentic (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P4313)

**题意简述**：

有 $n*m$ 个同学分科，文理科会得到不同满意值，同时如果周围同学均选择相同分科，也会得到不同满意值，求最大满意值。


**题目分析**：

一看到题就透着一股浓浓的**最小割**那味儿。

按照题意，将源点看作**文科**， 汇点看作**理科**。


- 先将每位同学单独选择的满意值进行加边操作，注意方向：

```cpp
add(s,pos(i,j),u);
add(pos(i,j),t,u);

```

然后考虑周围同学的影响，先分析文科，下文将增加的满意值表示为 $u$：

因为是四个同学共同对结果造成影响，又要保证不会影响前面的结果，所以考虑拆点：

- 从源点（选择文科）向拆点连有向边，边权为 $u$（保证不会影响前面）；


- 从拆点向源点连有向边，边权为 $u$ (因为满意值是增加的，所以要反向建边，最后结果才有可能更大)；

- 从周围四个点向拆点连有向边，边权为正无穷 （因为不确定大小，且后面的边会限制流量大小使其满足题意，所以直接来极大值）


```cpp
add(s,cnt,u), add(cnt,pos(i,j),u);

add(cnt,pos(tx,ty),inf);

```

那么显而易见的是，理科（汇点）的连边操作因为结点顺序，方向与文科相反。


```cpp
add(cnt,t,u), add(pos(i,j),cnt,u);

add(pos(tx,ty),cnt,inf);
```


最后，就是模板求最小割啦。



**完整代码**：

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
#define rt register int
#define int long long
const int N = 3e4 + 10,M = 1e6 + 10, inf = 1e10;
struct node {
	int to,nex;
}e[M];
int n,m,s,t,top,ed,sum,cnt,dep[N],head[N],cur[N],tot = 1,f[M],q[N],a[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};
inline void add(int x,int y,int w) {
	e[++tot] = (node) {y,head[x]}, f[tot] = w, head[x] = tot;
	e[++tot] = (node) {x,head[y]}, head[y] = tot; 
}
inline bool bfs() {
	memset(dep,-1,sizeof(dep));
	dep[s] = 0, cur[s] = head[s], q[top = 1] = s; ed = 1;
	int now,ver;
	while(top <= ed) {
		now = q[top++];
		for(rt i = head[now]; i; i = e[i].nex) {
			ver = e[i].to;
			if(dep[ver] == -1 && f[i]) {
				dep[ver] = dep[now] + 1, cur[ver] = head[ver];
				if(ver == t) return 1;
				q[++ed] = ver;
			}
		}
	}
	return 0;
}
inline int find(int x,int limit) {
	if(x == t) return limit;
	int flow = 0, tmp, ver;
	for(rt i = head[x]; i && flow < limit; i = e[i].nex) {
		ver = e[i].to;
		if(dep[ver] == dep[x] + 1 && f[i]) {
			tmp = find(ver,min(limit - flow,f[i]));
			if(!tmp) dep[ver] = -1;
			f[i] -= tmp, f[i ^ 1] += tmp, flow += tmp; 
		}
	}
	return flow;
}
inline int dinic() {
	int flow;
	while(bfs()) sum -= find(s,inf);
	return sum;
}
inline void read(int &x) {
	x = 0;int ff = 1;
	char s = getchar();
	while(s < '0' || s > '9') {
		if(s == '-') ff = -1;
		s = getchar();
	}
	while(s <= '9' && s >= '0') {x = x * 10 + s - '0', s = getchar(); }
	x *= ff;
}
inline int pos(int x,int y) {
	return m * (x - 1) + y;
}
signed main() {
	read(n), read(m);
	s = n * m + 1,t = s + 1, cnt = t;
	int u,tx,ty;
	for(rt i = 1; i <= n;  i++) {
		for(rt j = 1; j <= m; j ++) { 
			read(u), sum += u; 
			add(s,pos(i,j),u);
		}
	}
	for(rt i = 1; i <= n;  i++) {
		for(rt j = 1; j <= m; j ++) { 
			read(u), sum += u;
			add(pos(i,j),t,u);
		}
	}
	for(rt i = 1; i <= n; i ++) {
		for(rt j = 1; j <= m; j ++) {
			read(u), sum += u, cnt++;
			add(s,cnt,u), add(cnt,pos(i,j),u);
			for(rt k = 0; k < 4; k ++) {
				tx = i + a[k][0], ty = j + a[k][1];
				if(tx < 1 || ty < 1 || tx > n || ty > m) continue;
				add(cnt,pos(tx,ty),inf);
			}
		}
	}
	for(rt i = 1; i <= n; i ++) {
		for(rt j = 1; j <= m; j ++) {
			read(u), sum += u, cnt++;
			add(cnt,t,u), add(pos(i,j),cnt,u);
			for(rt k = 0; k < 4; k ++) {
				tx = i + a[k][0], ty = j + a[k][1];
				if(tx < 1 || ty < 1 || tx > n || ty > m) continue;
				add(pos(tx,ty),cnt,inf);
			}
		}
	}
	printf("%d",dinic());
	return 0;
} 
```



---

## 作者：KAMIYA_KINA (赞：1)

## 前言
今天是 $\text{2021}$ 年 $\text{6}$ 月 $\text{5}$ 日，明天就是 $\text{2021}$ 年高考的日子了，祝福各位应届高考生能够取得一个好的成绩，考上自己心仪的大学。

## 正文
### 初步思路
本题是一道非常好的最小割网络流练习题，一个人不是选理就是选文（当然现在可以三加二加一啦），那么也就是说选理选文就是一个约束条件，这个约束条件可以带来的贡献我们是不好处理的，所以我们可以反过来思考，也就是，如果说这个人不选文，那么我就可以减去其选文的贡献。

那么我们就可以将图建成一个 **最小割** 模型。

那么另一个任务就是关于同桌之间的约束关系怎么整。可以发现，如果说一个人选了文，那么也就是说其选理的贡献是比较低的，也就是说流量是可以将选理的一条路给填满但是填不满选文的路，那么我们可以建立一个虚拟节点代表选文或者选理的情况。

### 具体建图

我们将超级源点连向一个点表示这个人选文的情况，将一个点连向超级汇点表示这个人选理的情况，流量限制就是这个人选文或者选理时候的满意值。

当若干个人之间有一个约束关系的时候，我们就可以建立一个虚拟节点，选文的话就从超级源点连向改点，流量为这个约束关系的满意值。选理的情况同样。

## 代码
~~~cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 1;
const int M = 1e6 + 1;
const int INF = 1e9;
int hd[N],nxt[M],to[M],cap[M],tot = 1;
int d[N],cur[N];
const int tx[] = {1,0,-1,0};
const int ty[] = {0,1,0,-1};
int s,t,n,m;
inline void add(const int u,const int v,const int z) {nxt[++tot] = hd[u],to[tot] = v,cap[tot] = z,hd[u] = tot;}
inline void adds(const int u,const int v,const int z) {add(u,v,z),add(v,u,0);}
inline int id(const int x,const int y) {return (x <= n && y <= m && x && y) ? (x - 1) * m + y : 0;}//在这里判断越界的条件
inline bool BFS() {
    memset(d,0,sizeof(d));
    queue<int>Q;Q.push(s),cur[s] = hd[s],d[s] = 1;
    while(!Q.empty()) {
        int u = Q.front();Q.pop();
        for(int eg = hd[u],v = to[eg]; eg; eg = nxt[eg], v = to[eg]) {
            if(cap[eg] && !d[v]) d[v] = d[u] + 1,cur[v] = hd[v],Q.push(v);
        }
    }
    return d[t];
}
int dfs(const int u,const int flow) {
    if(u == t) return flow;
    int f = 0;
    for(int eg = cur[u],v = to[eg]; eg && f < flow; eg = nxt[eg],v = to[eg]) {
        cur[u] = eg;
        if(cap[eg] && d[v] == d[u] + 1) {
            int k = dfs(v,min(cap[eg],flow - f));
            if(!k) d[v] = -1;
            f += k,cap[eg] -= k,cap[eg ^ 1] += k;
        }
    }
    return f;
}
inline int dinic() {
    int sum = 0,f = 0;
    while(BFS()) while(f = dfs(s,INF)) sum += f;
    return sum;
}//网络流
int pcnt = 0,ans = 0;
int main() {
    scanf("%d%d",&n,&m);
    s = 0,t = n * m * 4 + 1,pcnt = n * m;
    for(int i = 1,x; i <= n; i++) 
    for(int j = 1; j <= m; j++) scanf("%d",&x),adds(s,id(i,j),x),ans += x;//建立与源点的流量
    for(int i = 1,x; i <= n; i++) 
    for(int j = 1; j <= m; j++) scanf("%d",&x),adds(id(i,j),t,x),ans += x;//建立与汇点的流量
    for(int i = 1,x; i <= n; i++) 
    for(int j = 1; j <= m; j++) {
        scanf("%d",&x), ans += x;
        pcnt++,adds(s,pcnt,x), adds(pcnt,id(i,j),INF);
        for(int k = 0; k ^ 4; k++) 
        	if(id(i + tx[k],j + ty[k])) adds(pcnt, id(i + tx[k],j + ty[k]), INF);//表示文科的约束关系
    }
    for(int i = 1,x; i <= n; i++) 
    for(int j = 1; j <= m; j++) {
        scanf("%d",&x),ans += x;
        pcnt++, adds(pcnt,t,x), adds(id(i,j),pcnt,INF);
        for(int k = 0; k ^ 4; k++) 
        if(id(i + tx[k],j + ty[k])) adds(id(i + tx[k],j + ty[k]), pcnt, INF);//表示理科的约束关系
    }
    cout << ans - dinic() << endl;//总体答案减去最小割即为所求
    return 0;

}
~~~
## 题外话
在判断边界条件的时候一定要记得判断边界为 0 的情况，不然就会像某 MIYA 一样狂交一面~~浪费评测资源~~。

## UPDATE
2021.6.6 ：修改了一些错字。

---

## 作者：Aftglw (赞：1)

### 最小割
[双倍经验](https://www.luogu.com.cn/problem/P1361)

这道题运用了最小割最常用的一种用法：**集合划分**。

因为源汇最小割即就是将源汇划分到不同的集合，那么最简单的应用就是最小代价划分集合了。

本题中，题意是将 $n\cdot m$ 个学生划分文理科，每人只能选一科且选不同的科有不同的收益，求最大收益，符合集合划分的条件，就理所当然地想到了最小割。

至于求最大收益，不妨就先将所有收益加起来，再减去最小代价（即最小割），便是最大收益了。

但是本题的难点在于，如果相邻同学选一样的（以下称为一个组合），还会有额外收益。

于是我们需要加一点限制，使得我们在最后求最小割的时候，对于每一个组合：要么**满足**组合内的所有成员，都在同一个子集（包含源点的子集 $S$ 或包含汇点的子集 $T$），且那条代表额外收益的边**不会被割掉**；要么**不满足**组合内是所有成员，都在同一个子集，且那条代表额外收益的边**被割掉了**。

于是大致见图思路出来了：

- 对于每一个点（每一位同学）$i$：

	连 $s\rightarrow i$ 容量为 $art_i$；

	连 $i\rightarrow t$ 容量为 $science_i$。
    
- 对于每一个组合 $i$，新建两个点 $x_i,y_i$：

	连 $s\rightarrow x_i$ 容量为 $same\_art_i$；
    
   连 $y_i\rightarrow t$ 容量为 $same\_science_i$。
   
   对于该组合内的每个点（即该点+上下左右四个点）$j\in i$：
   
   连 $x_i\rightarrow j$ 容量为 $+\infty$；
   
   连 $j\rightarrow y_i$ 容量为 $+\infty$。
 
这里解释一下这么连的原因：
 
如果要 $s\rightarrow x_i$ 这条边（即要这个组合所有同学都选文科的收益），那么就不割这条边。但是，又因为 $x_i$ 向这个组合内每个点都连了一条 $+\infty$ 的边，所以这些边便不会被割掉。那么为了防止 $s$ 与 $t$ 联通，自然就会割掉这个组合内每个点与 $t$ 连的边（即都不选理科）。反之都选理科亦然。

如果放弃这个组合（即这个组合内每个成员选的科**不都一样**），那么就会割掉 $s\rightarrow x_i$ 和 $y_i\rightarrow t$ 这两条边，那么就相当于这个组合内的每个点都互相独立了，可以任意选科。

**注**：不能将 $x_i$ 与 $y_i$ 合并成一个点来连边，这样会使上述**放弃组合**的情况无法达到（即无法破坏组合独立选择）。

### Code
```cpp
#include<bits/stdc++.h>
//#define int long long
#define pair pair<int,int>
using namespace std;
inline void end()
{
	puts("");
	system("pause");
}
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9') {if(c=='-') f=-1;c=getchar();}
	while (c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}
const int N=3e4+4,M=5e5+5;
int n,m,nm,s,t,ans,Maxflow;
int first[N],nex[M],to[M],w[M],num=1;
inline void add(int u,int v,int val)
{
	nex[++num]=first[u];
	first[u]=num;
	to[num]=v;
	w[num]=val;
}
inline void Add(int u,int v,int val)
{
	add(u,v,val);
	add(v,u,0);
}
namespace ISAP
{
	int dep[N],gap[N],cur[N];
	void bfs()
	{
		memset(dep,-1,sizeof(dep));
		memset(gap,0,sizeof(gap));
		queue<int> q;
		q.push(t);
		dep[t]=0;gap[0]=1;
		while(!q.empty())
		{
			int u=q.front();q.pop();
			for(int i=first[u];i;i=nex[i])
			{
				int v=to[i];
				if(dep[v]!=-1) continue;
				dep[v]=dep[u]+1;
				gap[dep[v]]++;
				q.push(v);
			}
		}
	}
	inline int dfs(int u,int in)
	{
		if(u==t) return in;
		int out=0;
		for(int i=cur[u];i;i=nex[i])
		{
			cur[u]=i;
			int v=to[i];
			if(!w[i]||dep[v]!=dep[u]-1) continue;
			int res=dfs(v,min(w[i],in-out));
			w[i]-=res;
			w[i^1]+=res;
			out+=res;
			if(in==out) return out;
		}
		gap[dep[u]]--;
		if(!gap[dep[u]]) dep[s]=3*nm+3;
		dep[u]++;
		gap[dep[u]]++;
		return out;
	}
	void work()
	{
		bfs();
		while(dep[s]<3*nm+2)
		{
			memcpy(cur,first,sizeof(first));
			Maxflow+=dfs(s,1e9);
		}
	}
}
inline int id(int i,int j){return  (i-1)*m+j;}
int dx[5]={-1,0,1,0,0},dy[5]={0,-1,0,1,0};
int main()
{
	//1|nm|nm|nm|1
        //源点|每个组合"选文"|每个座位|每个组合"选理"|汇点
	n=read(),m=read(),nm=n*m;
	s=0,t=3*nm+1;
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
		{
			int val=read();ans+=val;
			Add(s,id(i,j)+nm,val);//s -> i
		}
	}
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
		{
			int val=read();ans+=val;
			Add(id(i,j)+nm,t,val);//i -> t
		}
	}
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
		{
			int val=read();ans+=val;
			Add(s,id(i,j),val);//s -> x_i
		}
	}
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
		{
			int val=read();ans+=val;
			Add(id(i,j)+2*nm,t,val);//y_i -> t
			for(int k=0;k<5;++k)
			{
				int x=i+dx[k],y=j+dy[k];
				if(x<1||y<1||x>n||y>m) continue;
				Add(id(i,j),id(x,y)+nm,1e9);//x_i -> j
				Add(id(x,y)+nm,id(i,j)+2*nm,1e9);//j -> y_i
			}
		}
	}
	ISAP::work();
	printf("%d",ans-Maxflow);
	end();
	return 0;
}
```


---

## 作者：syzf2222 (赞：1)

[更好的阅读体验Click here](https://www.cnblogs.com/syzf2222/p/14027767.html)

这篇博客是文理分科的题解暨最大流建模思路的套路整理。

很多人看到最大流的题就说是最小割板子。那最小割到底有什么意义？我被这个问题困惑了很久。

我们到底要去割一个怎样的图？我们为什么要去割这个图？

做了一些习题之后，我大概发现了如下的规律：

源点和汇点表示两个矛盾的状态，最小割的过程即是找使状态合法的最小代价。

形象化地，我们以本题为例。

显然题中的人不可能既选文科又选理科（不排除现实生活中有这样的神仙）。

则我们将最终和源点$S$相连的点认为是选择文科，理科同理。

考虑如何连边：

每个点向源点连一条价值为他选择文科的满意值，汇点同理。

若连向源点的边被割断，则代表他选择理科，反之亦然。

发现这样建图一个人的文科和理科总有一个会被割掉，符合题意。

对于$same_{art}[i][j]$，新建节点$cnt$，考虑它的要求。

若要满足全为文科，则所有理科的边都要割掉，否则我们也可以割掉这一条边。

故连$S$到$cnt$价值为$same_{art}[i][j]$的边，再从$cnt$向$(i,j)$和其相邻点连价值为$inf$的边。

对于理科的$same_{science}[i][j]$是一样的道理。

我们发现将$S$和$T$具象化以后，每一条连边都是有意义的，这样更有利于解题。

代码如下，仅供参考（本人码风就那样，多多体谅）：
```
#include<bits/stdc++.h>
using namespace std;
#define inf 1e9
const int N=105;
const int maxn=3e5+10;
int n,m,ans,t,cnt;
int beg[maxn],nex[maxn],to[maxn],w[maxn],e;
inline void add(int x,int y,int z){
	nex[e]=beg[x];beg[x]=e;
	to[e]=y;w[e]=z;e++;
}
int dep[maxn];queue<int>q;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}
inline int id(int x,int y){return (x-1)*m+y;}
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
inline int bfs(){
	memset(dep,0,sizeof(dep));
	dep[0]=1;q.push(0);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=beg[x];~i;i=nex[i])
			if(w[i]&&!dep[to[i]]){
				dep[to[i]]=dep[x]+1;
				q.push(to[i]);
			}
	}
	return dep[t]!=0;
}
inline int dfs(int x,int lim){
	if(x==t||!lim)return lim;
	int res=0;
	for(int i=beg[x];~i;i=nex[i])
		if(w[i]&&dep[to[i]]==dep[x]+1){
			int f=dfs(to[i],min(w[i],lim));
			if(!f){dep[to[i]]=-1;continue;}
			lim-=f;res+=f;
			w[i]-=f;w[i^1]+=f;
		}
	return res;
}
int main(){
	n=read(),m=read();
	memset(beg,-1,sizeof(beg));
	int val;t=cnt=n*m+1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			val=read();ans+=val;
			add(0,id(i,j),val);add(id(i,j),0,0);
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			val=read();ans+=val;
			add(id(i,j),t,val);add(t,id(i,j),0);
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			cnt++;val=read();ans+=val;
			add(0,cnt,val);add(cnt,0,0);
			add(cnt,id(i,j),inf);add(id(i,j),cnt,0);
			for(int k=0;k<4;k++){
				int x=i+dx[k];int y=j+dy[k];
				if(x<1||y<1||x>n||y>m)continue;
				add(cnt,id(x,y),inf);add(id(x,y),cnt,0);
			}
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			cnt++;val=read();ans+=val;
			add(cnt,t,val);add(t,cnt,0);
			add(id(i,j),cnt,inf);add(cnt,id(i,j),0);
			for(int k=0;k<4;k++){
				int x=i+dx[k];int y=j+dy[k];
				if(x<1||y<1||x>n||y>m)continue;
				add(id(x,y),cnt,inf);add(cnt,id(x,y),0);
			}
		}
	while(bfs())ans-=dfs(0,inf);
	printf("%d\n",ans);
	return 0;
}
```
深深地感到自己的弱小。

---

## 作者：Stinger (赞：0)

非常神奇的的最小割模型。

正面建立最大流/费用流模型不好搞，于是考虑最小割，发现有点东西。

建立超级源 $S$ 和超级汇 $T$，分别代表文科和理科。对于每个人 $i$，从 $S$ 到 $i$ 连一条边，边权为第 $i$ 个人选择文科获得的收益。从 $i$ 到 $T$ 连一条边，边权为第 $i$ 个人选择理科获得的收益。

以上完全是凭直觉建出来的模型，考虑一下它是否正确。显然如果第 $i$ 个人既选了文科又选了理科，一定存在 $S\rightarrow i\rightarrow T$ 这条路径从 $S$ 到达 $T$。因此该模型正确。

现在加入相邻的人同时选择文/理科的收益。直接在这些点之间连边非常不好搞，所以对于每个人新建一个点 ，假设这个人为 $i$，新建的点为 $i^{\prime}$。那么从 $i^{\prime}$  向 $i$ 以及所有与第 $i$ 个人相邻的人连一条边权为 $\infty$ 的边，因为显然这些边不可以割掉。然后从 $S$ 向 $i^{\prime}$ 连一条边，边权为 $i$ 与它相邻的人同时选文科的收益。同理，从 $i^{\prime}$ 向 $S$ 连一条边，边权为 $i$ 与它相邻的人同时选理科的收益

再次考虑新模型的正确性。假设我获得了 $S\rightarrow i^{\prime}$ 这条边的收益，即与 $i$ 相邻的人全选了文科。那么只要有一个与 $i$ 相邻的人 $j$ 背叛组织，选择了理科，那么就存在一条 $S\rightarrow i^{\prime}\rightarrow j\rightarrow T$ 的路径可以从 $S$ 到达 $T$。因为根据假设，$S\rightarrow i^{\prime}$ 以及 $j\rightarrow T$ 这两条边存在，而 $i^{\prime}\rightarrow j$ 这条边又是不可以割掉的（边权为INF），所以模型正确。

把边权换成流量跑 ISAP 就行了。当然你要 Dinic 也可以~~虽然跑得慢~~

```cpp
#include <cstdio>
#include <queue>
#include <cstring>

const int INF = 1e9;
const int dx[] = {-1, 1, 0, 0};
const int dy[] = {0, 0, -1, 1};
inline int min(const int x, const int y) {return x < y ? x : y;}
struct Edge {
	int to, nxt, cap;
} e[1000005];
int head[100005], cur[100005], dep[100005], num[100005], s, t, tot = 1, cnt;
int ar[105][105], sc[105][105];
std::queue<int> Q;
inline void AddEdge(const int u, const int v, const int cap) {
	e[++ tot].to = v, e[tot].cap = cap, e[tot].nxt = head[u], head[u] = tot;
	e[++ tot].to = u, e[tot].cap = 0, e[tot].nxt = head[v], head[v] = tot;
}

void bfs() {
	memcpy(cur, head, sizeof cur);
	num[dep[t] = 1] = 1;
	Q.push(t);
	while (Q.size()) {
		int u(Q.front());
		Q.pop();
		for (int i(head[u]); i; i = e[i].nxt)
			if (!dep[e[i].to]) ++ num[dep[e[i].to] = dep[u] + 1], Q.push(e[i].to);
	}
}

int dfs(const int u, const int flow) {
	if (u == t) return flow;
	int used(0), tmp(0);
	for (int i(cur[u]); i; i = e[i].nxt) {
		cur[u] = i;
		if (e[i].cap && dep[u] - 1 == dep[e[i].to]) {
			tmp = dfs(e[i].to, min(e[i].cap, flow - used));
			e[i].cap -= tmp, e[i ^ 1].cap += tmp, used += tmp;
			if (used == flow) return used;
		}
	}
	cur[u] = head[u];
	if (!(-- num[dep[u]])) dep[s] = cnt + 2;
	++ num[++ dep[u]];
	return used;
}

int ISAP() {
	int Maxflow(0);
	bfs();
	while (dep[s] <= cnt + 1) Maxflow += dfs(s, INF);
	return Maxflow;
}

int main()  {
	int n, m, ans(0);
	scanf("%d%d", &n, &m);
	s = 0, t = (cnt = n * m + 1);
	for (int i(1); i <= n; ++ i)
	for (int j(1); j <= m; ++ j) {
		int x;
		scanf("%d", &x);
		AddEdge(s, (i - 1) * m + j, x), ans += x;
	}
	for (int i(1); i <= n; ++ i)
	for (int j(1); j <= m; ++ j) {
		int x;
		scanf("%d", &x);
		AddEdge((i - 1) * m + j, t, x), ans += x;
	}
	for (int i(1); i <= n; ++ i)
	for (int j(1); j <= m; ++ j) {
		int x, u(++ cnt);
		scanf("%d", &x);
		AddEdge(s, u, x), ans += x;
		AddEdge(u, (i - 1) * m + j, INF);
		for (int k(0); k <= 3; ++ k) {
			int tx(i + dx[k]), ty(j + dy[k]);
			if (tx < 1 || ty < 1 || n < tx || m < ty) continue;
			AddEdge(u, (tx - 1) * m + ty, INF);
		}
	}
	for (int i(1); i <= n; ++ i)
	for (int j(1); j <= m; ++ j) {
		int x, u(++ cnt);
		scanf("%d", &x);
		AddEdge(u, t, x), ans += x;
		AddEdge((i - 1) * m + j, u, INF);
		for (int k(0); k <= 3; ++ k) {
			int tx(i + dx[k]), ty(j + dy[k]);
			if (tx < 1 || ty < 1 || n < tx || m < ty) continue;
			AddEdge((tx - 1) * m + ty, u, INF);
		}
	}
	printf("%d", ans - ISAP());
}
```

---

## 作者：Infiltrator (赞：0)

[$\Large\color{#FFBBFF}\textit{Tian-Xing's blog}$](https://Tian-Xing.github.io)

------------

# Description

[传送门](https://www.luogu.com.cn/problem/P4313)

------------

# Solution

每个点只有两种选择，不是选文科就是选理科，从$S$向每个同学连容量为选文科的满意值的有向边，从每个同学向$T$连容量为选理科的满意值的有向边，那么总的满意值减去最小割就是答案。

现在考虑如何在所有相邻的同学选同一个课时增加满意值，反过来看也就是说如果相邻的有不选某一门课的就不会增加满意值。

那么我们对于每一个同学新建一个节点，向她还有她周围的所有同学连容量为$INF$的边，再从原点向新建的节点连一条容量为这些同学全选文科时增加的满意值。因为是一个二分图，所以如果选了理科那么所有跟$S$相连的边都必须被割掉，也就是说如果这些相邻的同学中有一人选择了理科，那么从$S$到这些同学的路径都得割掉。而$INF$边是割不了的，所以只能割掉新建的节点和$S$之间的边，也就满足了要求，对于其他情况同理。

------------

# Code

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue> 
using namespace std;

const int N = 1000050;
const int M = 2000050;
const int INF = 999999999;

int head[N], num = 1, n, m, s, t, sum, d[N], x, cnt;

struct Node
{
	int next, to, flow;
} edge[M * 2];

void Addedge(int u, int v, int w)
{
	edge[++num] = (Node){head[u], v, w};
	head[u] = num;
	return;
}

void Add(int u, int v, int w)
{
	Addedge(u, v, w);
	Addedge(v, u, 0);
	return;
}

int Id(int a, int b)
{
	return (a - 1) * m + b;
} 

template <class T>
void Read(T &x)
{
	x = 0; int p = 0; char st = getchar();
	while (st < '0' || st > '9') p = (st == '-'), st = getchar();
	while (st >= '0' && st <= '9') x = (x << 1) + (x << 3) +st - '0', st = getchar();	
	x = p ? -x : x;
	return;
} 

template <class T>
void Put(T x)
{
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) Put(x / 10);
	putchar(x % 10 + '0');
	return; 
}

bool Bfs()
{
    queue<int> q;
    for (int i = 0; i <= cnt; i++) d[i] = 0;
    d[s] = 1; q.push(s);
    while (!q.empty())
    {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = edge[i].next)
            if (!d[edge[i].to] && edge[i].flow)
            {
                d[edge[i].to] = d[u] + 1;
                q.push(edge[i].to);
                if (edge[i].to == t) return 1;
            }
    }
    return 0;
}

int Dinic(int x, int flow)
{
    if (x == t || !flow) return flow;
    int rest = flow;
    for (int i = head[x]; i && rest; i = edge[i].next)
        if (edge[i].flow && d[edge[i].to] == d[x] + 1)
        {
            int v = edge[i].to;
            int tmp = Dinic(v, min(rest, edge[i].flow));
            rest -= tmp;
            edge[i].flow -= tmp;
            edge[i ^ 1].flow += tmp;
            if (!tmp) d[v] = 0;
        }
    return flow - rest;
}

int Maxflow()
{
	int maxflow = 0, tmp;
	while (Bfs())
	{
		tmp = Dinic(s, INF);
		if (tmp) maxflow += tmp;
	}
	return maxflow;
}

int main()
{
	Read(n); Read(m);
	t = n * m + 1; cnt = t;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
		{
			Read(x);
			Add(s, Id(i, j), x);
			sum += x;
		} 
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
		{
			Read(x);
			Add(Id(i, j), t, x);
			sum += x;
		}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
		{
			Read(x);
			sum += x;
			int tmp = ++cnt;
			Add(s, tmp, x);
			Add(tmp, Id(i, j), INF);
			if (i + 1 <= n) Add(tmp, Id(i + 1, j), INF);
			if (i - 1 >= 1) Add(tmp, Id(i - 1, j), INF);
			if (j + 1 <= m) Add(tmp, Id(i, j + 1), INF);
			if (j - 1 >= 1) Add(tmp, Id(i, j - 1), INF); 
		}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
		{
			Read(x);
			sum += x;
			int tmp = ++cnt;
			Add(tmp, t, x);
			Add(Id(i, j), tmp, INF);
			if (i + 1 <= n) Add(Id(i + 1, j), tmp, INF);
			if (i - 1 >= 1) Add(Id(i - 1, j), tmp, INF);
			if (j + 1 <= m) Add(Id(i, j + 1), tmp, INF);
			if (j - 1 >= 1) Add(Id(i, j - 1), tmp, INF);
		}
	Put(sum - Maxflow());
	return 0;
}
```

---

## 作者：览遍千秋 (赞：0)

## 问题描述

[BZOJ3894](https://www.lydsy.com/JudgeOnline/problem.php?id=3894)

[LG4313](https://www.luogu.com.cn/problem/P4313)

---

## 题解

显然一个人只能选文/理 -> 一个人只能属于文（S）、理（T）集合中的一个

可以把选择文得到 $art$ 的收益看做选择文失去 $science$ 的收益，也就是最小割了。

考虑如何处理周围人都选

对于文科，再新建一个 $(i,j)'$ ，从 S 向其连边，权值为 $sameart$ ，再从 $(i,j)'$ 向 $(i,j)$ 和它周围的四个点连边，权值为INF，代表只有当这六个点都在集合 $S$ 里的时候，才能不割掉 S 到 $(i,j)'$ 的连边，获得这个收益。

理科同理。

---

## $\mathrm{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;

const int INF=0x3f3f3f3f;

int S,T,n,m;
int art[507][507],science[507][507];
int artsame[507][507],sciencesame[507][507];

int Head[500*500*3+100],to[5000007],Next[5000007],w[5000007],tot=1;

void addedge(int x,int y,int z){
	to[++tot]=y,Next[tot]=Head[x],Head[x]=tot,w[tot]=z;
}

void add(int x,int y,int z){
	addedge(x,y,z);addedge(y,x,0);
}

int d[500*500*3+100];

bool bfs(void){
	memset(d,0,sizeof(d));
	queue<int>q;q.push(S);d[S]=1;
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i=Head[x];i;i=Next[i]){
			int y=to[i];
			if(d[y]||!w[i]) continue;
			d[y]=d[x]+1;q.push(y);
			if(y==T) return true;
		}
	}
	return false;
}

int dfs(int x,int flow){
	if(x==T) return flow;
	int rest=flow;
	for(int i=Head[x];i&&rest;i=Next[i]){
		int y=to[i];
		if(d[y]!=d[x]+1||!w[i]) continue;
		int k=dfs(y,min(rest,w[i]));
		if(!k) d[y]=0;
		else w[i]-=k,w[i^1]+=k,rest-=k;
	}
	return flow-rest;
}

int Dinic(void){
	int res(0),t;
	while(bfs()){
		while(t=dfs(S,INF)) res+=t;
	}
	return res;
}

int total;
int dx[5]={0,0,1,-1,0};
int dy[5]={1,-1,0,0,0};

bool check(int x,int y){
	if(x>=1&&x<=n&&y>=1&&y<=m) return true;
	return false;
}

int id(int x,int y,int id){
	return (id-1)*n*m+(x-1)*m+y;
}

void Init(void){
	scanf("%d%d",&n,&m);
	S=n*m*3+1,T=S+1;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
		scanf("%d",&art[i][j]);total+=art[i][j];
		add(S,id(i,j,1),art[i][j]);
	}
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
		scanf("%d",&science[i][j]);total+=science[i][j];
		add(id(i,j,1),T,science[i][j]);
	}
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
		scanf("%d",&artsame[i][j]);total+=artsame[i][j];
		add(S,id(i,j,2),artsame[i][j]);
	}
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
		scanf("%d",&sciencesame[i][j]);total+=sciencesame[i][j];
		add(id(i,j,3),T,sciencesame[i][j]);
	}
	for(int x=1;x<=n;x++){
		for(int y=1;y<=m;y++){
			for(int i=0;i<5;i++){
				int nx=x+dx[i],ny=y+dy[i];
				if(!check(nx,ny)) continue;
				add(id(nx,ny,2),id(x,y,1),INF);
				add(id(x,y,1),id(nx,ny,3),INF);
			}
		}
	}
}

void Work(void){
	int maxflow=Dinic();
	printf("%d\n",total-maxflow);
}

int main(){
	Init();
	Work();
}
```

---

## 作者：ysy20021208 (赞：0)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**分析与题解：**对于这道题，就相当于上一道题目，把作物改成同学，$A$耕地改为文科，$B$耕地改为理科，每一个组合就是当前同学与他所有相邻的同学都选文科和理科。然后就是向上一道题一样建图就可以了。

```c++
// luogu-judger-enable-o2
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define N 50000
#define M 5000000
#define inf 1000000000
int n,m,s,t,ans,dis[N],dir1[5]={0,1,-1,0,0},dir2[5]={0,0,0,-1,1};
int cur[N],head[N],to[M<<1],val[M<<1],nxt[M<<1],idx=1;
void add(int a,int b,int c)
    {nxt[++idx]=head[a],to[idx]=b,val[idx]=c,head[a]=idx;}
bool bfs() 
{
    memset(dis,-1,sizeof dis);
    queue <int> q;q.push(s),dis[s]=0;
    while(!q.empty())
    {
        int p=q.front();q.pop();
        if(p==t) return true;
        for(int i=head[p];i;i=nxt[i])
            if(val[i]>0&&dis[to[i]]==-1)
                dis[to[i]]=dis[p]+1,q.push(to[i]);
    } return false;
}
int dfs(int p,int flow)
{
    int now,temp=flow;
    if(p==t) return flow;
    for(int i=cur[p];i;i=nxt[i])
        if(val[i]>0&&dis[to[i]]==dis[p]+1)
        {
            now=dfs(to[i],min(val[i],temp));
            if(!now) dis[to[i]]=-1;
            temp-=now,val[i]-=now,val[i^1]+=now;
            if(val[i]) cur[p]=i;
            if(!temp) break;
        } return flow-temp;
}
void dinic() {while(bfs()) memcpy(cur,head,sizeof head),ans-=dfs(s,inf);}
bool in(int x,int y) {return x&&x<=n&&y&&y<=m;}
int pla(int i,int j) {return (i-1)*m+j;}
int main()
{
    scanf("%d%d",&n,&m),s=n*m*4+1,t=n*m*4+2;
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)
        add(pla(i,j),pla(i,j)+n*m,inf),add(pla(i,j)+n*m,pla(i,j),0);
    for(int i=1;i<=n;i++) for(int j=1,a;j<=m;j++) scanf("%d",&a),
        add(s,pla(i,j),a),add(pla(i,j),s,0),ans+=a;
    for(int i=1;i<=n;i++) for(int j=1,a;j<=m;j++) scanf("%d",&a),
        add(pla(i,j)+n*m,t,a),add(t,pla(i,j)+n*m,0),ans+=a;
    for(int i=1;i<=n;i++) for(int j=1,a;j<=m;j++) { scanf("%d",&a),
        add(s,pla(i,j)+n*m*2,a),add(pla(i,j)+n*m*2,s,0),ans+=a;
        for(int k=0;k<=4;k++) if(in(i+dir1[k],j+dir2[k]))
            add(pla(i,j)+n*m*2,pla(i+dir1[k],j+dir2[k]),inf),
            add(pla(i+dir1[k],j+dir2[k]),pla(i,j)+n*m*2,0);}
    for(int i=1;i<=n;i++) for(int j=1,a;j<=m;j++) { scanf("%d",&a),
        add(pla(i,j)+n*m*3,t,a),add(t,pla(i,j)+n*m*3,0),ans+=a;
        for(int k=0;k<=4;k++) if(in(i+dir1[k],j+dir2[k]))
            add(pla(i+dir1[k],j+dir2[k])+n*m,pla(i,j)+n*m*3,inf),
            add(pla(i,j)+n*m*3,pla(i+dir1[k],j+dir2[k])+n*m,0);}
    dinic(),printf("%d\n",ans);
}
```

---


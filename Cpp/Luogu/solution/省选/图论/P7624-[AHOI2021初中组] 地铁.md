# [AHOI2021初中组] 地铁

## 题目背景

AHOI2021 初中组 T4

**你可以选择跳过背景部分。**

小可可发现自己所学算法在生活中其实无大用，感觉十分沮丧。小雪见状还是嘀咕了几句“应该还是有用的吧”。

“不过没用又怎么样呢？算法只不过是一块名牌大学的敲门砖罢了。”

“你这话我就不同意了。跳蚤国王曾经和我说过，以后科研或者工作中我们还会和信息学竞赛中的某些东西重逢，虽然可能不会再有信息学竞赛这么难。

“除开功利的因素之外，搞信息学竞赛还是能享受到很多思考的乐趣的。”

“你说的也对。每次我在考场上不会做质疑这题是不是有问题的时候，考后看题解总是懊恼又快乐——这么自然的思路我怎么想不到呢！”

一颗理论计算机科学家的种子悄悄萌芽。

沙尘暴突然神奇般的散去了。实在坐不下去的两人决定出门坐地铁瞎逛，随性下车。即使没有刻意为之，小雪在地铁上却想出了一个有意思的问题，你能解决吗？

## 题目描述

B 市的地铁历史悠久，小雪和小可可乘坐的 X 号线是环形路线，上面分布着 $n$ 个车站，**相邻两个车站之间的铁路长度为正整数**。现在小雪进行了一些观察，得到了 $m$ 条信息，第 $i$ 条信息是如下形式之一：

1. 环上顺时针由 $S_i$ 到 $T_i$ 的一段距离不小于一个给定的值 $L_i$（$S_i$ 和 $T_i$ 是两个车站）；
2. 环上顺时针由 $S_i$ 到 $T_i$ 的一段距离不大于一个给定的值 $L_i$。

小雪想要你计算最后 X 线地铁的总长度有多少种不同的合法取值。

## 说明/提示

【样例 1 解释】

定义数组 $d[1..4]$，其中 $d[i]$ 表示 $i$ 号车站顺时针到 $i+1$ 号车站的铁路长度。

1. $d=[1,2,2,2]$，总长度为 $7$；
2. $d=[1,2,2,3]$，总长度为 $8$；
3. $d=[1,2,2,4]$，总长度为 $9$；
4. $d=[1,2,3,4]$，总长度为 $10$。

可以证明，不存在其他的可能长度，于是答案为 $4$。

【样例 2 解释】

$3$ 号车站顺时针到 $1$ 号车站的铁路长度可以为任意正整数。

【数据范围与提示】

- 对于 $30\%$ 的数据，保证 $n,m \le 9$，$L_i \le 5$；
- 对于另外 $15\%$ 的数据，保证 $T_i$ 是 $S_i$ 顺时针方向后第一个车站；
- 对于另外 $20\%$ 的数据，保证 $T_i$ 是 $S_i$ 顺时针方向后第二个车站；
- 对于另外 $25\%$ 的数据，保证 $n,m \le 50$；
- 对于 $100\%$ 的数据，保证 $3 \le n \le 500$，$1 \le m \le 500$，$1 \le L_i \le 10^9$。

## 样例 #1

### 输入

```
4 6
1 1 3 3
2 2 4 5
1 2 4 4
1 3 1 4
2 4 2 5
1 4 2 3```

### 输出

```
4```

## 样例 #2

### 输入

```
3 2
2 1 2 1
2 2 3 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
见附加文件的 subway3.in。 ```

### 输出

```
见附加文件的 subway3.ans。```

# 题解

## 作者：syksykCCC (赞：25)

首先看到题目有几个想法：

1. 因为有「不小于」「不大于」这样的限制，考虑差分约束。
2. 因为是环上，可能需要断环为链。

于是不妨设 $d_i$ 表示 $1 \to i$ 的顺时针距离，根据定义，有 $d_1 = 0$，$d_{i+1} \ge d_{i} + 1$。

能否只使用 $d_i$ 来描述题目给出的所有性质呢？考虑到问题是在一个环上，而 $d$ 数组无法体现 $n$ 结点与 $1$ 结点之间的距离，所以我们再设一个变量 $C$ 表示环长，显然 $C \ge d_{n} + 1$。 

考虑根据题意建立差分约束系统：

1. 对于第 1 类信息：
   * 若 $S_i < T_i$，则有 $d_{S_i} - d_{T_i} \le -L_i$；
   * 否则，有 $d_{S_i} - d_{T_i} \le C-L_i$。
2. 对于第 2 类信息：
   * 若 $S_i < T_i$，则有 $d_{T_i} - d_{S_i} \le L_i$；
   * 否则，有 $d_{T_i} - d_{S_i} \le L_i - C$。

我们知道，差分约束系统有解的条件为图中没有负环，也就是每个点的最短路是可求的。

那么，如果将 $C$ 视作未知数，图中的每一个环就相当于给定了一个关于 $C$ 的一次不等式，最终 $C$ 的取值范围必然是一段连续的区间。

如何求出 $C$ 的最小值 $l$ 和最大值 $r$ 呢？

![image.png](https://i.loli.net/2021/06/20/zrV9KuyIpsMveho.png)

以上界 $r$ 为例，考虑二分 $x$，带入 $C = x$ 进图找负环。

若没有负环，则 $r \ge x$。

若存在负环，对于该负环的不等式 $C$ 前面的系数 $k$ 进行分类讨论：

1. 若 $k = 0$，无解，因为这个环无论 $C$ 为何值都是负环。
2. 若 $k > 0$，则 $C$ 应当增大。
3. 若 $k < 0$，则 $C$ 应当减小。

答案为 $r - l + 1$，注意判断无限解的情况。

时间复杂度 $O(n(n + m ) \log V)$，$V$ 为值域。


---

## 作者：meyi (赞：15)

注：本题解搬运自出题人在 GitHub 上公布的[官方题解](https://github.com/rushcheyo/AHOI-2021-junior)，数据及标程均可从此链接中下载。

设 $d_i$ 表示 $1$ 号车站到 $i$ 的顺时针距离，$x$ 表示整条地铁的总长度，那么一组 $\{d_i,x\}$ 合法的充要条件如下：

- $d_1=0$, $d_i,x$ 为正整数，且 $\forall 1 \le i < n,d_{i}-d_{i+1} \le -1,d_n \le x-1$；
- 对每个 1 类信息，若 $S_i < T_i$，$d_{S_i}-d_{T_i} \le -L_i$，否则 $d_{S_i}-d_{T_i} \le x-L_i$；
- 对每个 2 类信息，若 $S_i < T_i$，$d_{T_i}-d_{S_i} \le L_i$，否则 $d_{T_i}-d_{S_i} \le L_i-x$。

根据差分约束理论，若 $x$ 给定，将所有变量当做点，一条 $a-b \le c$ 限制对应一条 $b \to a$ 边权为 $c$ 的单向边，则存在合法方案的充要条件是该图不存在负环。

那么图中的每个环都给出了一个关于 $x$ 的一次不等式，这说明 $x$ 的取值范围一定是个区间。

于是，我们可以分别求出 $x$ 的最大值和最小值，下面介绍怎么求 $x$ 的最大值。我们二分 $x_0$，将 $x=x_0$ 带入判断负环，如果不存在负环那合法，$x$ 的上界只会更大；如果存在负环，考虑任取一个负环，令 $k$ 表示其边权和前 $x$ 的系数。

- $k=0$，那么显然无解；
- $k>0$，此时减小 $x$ 这个环只会负的更多，那么 $x$ 的上界比 $x_0$ 大；
- $k<0$，此时增大 $x$ 这个环只会负的更多，那么 $x$ 的上界比 $x_0$ 小。

这样我们可以二分出唯一可能的下界和上界 $l,r$，那么如果 $1 \le l \le r$ 且 $x=l,r$ 均合法答案便为 $r-l+1$，否则为 $0$（本题不可能），如果上界过大答案为 `-1`。判断负环用 Bellman–Ford 算法，点数 $O(n)$，边数 $O(n+m)$，总复杂度 $O(n(n+m) \log V)$，其中 $V$ 是值域。

```cpp
#include <cstdio>

typedef long long ll;

const int N = 505;
const int M = 505;
const int E = N + M;
const ll INF = 1e12;
const ll bigINF = 9e18;

int n, m, e, u[E], v[E], k[E], b[E], pre[N];
ll d[N];

void add(int a, int b, int c, int d) {
  u[++e] = b; v[e] = a; k[e] = c; b[e] = d;
}

int solve(ll mid) {
  for (int i = 1; i <= n; ++i) d[i] = bigINF;
  d[1] = 0;
  for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= e; ++j)
      if (d[v[j]] > d[u[j]] + k[j] * mid + b[j]) {
        d[v[j]] = d[u[j]] + k[j] * mid + b[j];
        pre[v[j]] = j;
      }
  for (int j = 1; j <= e; ++j)
    if (d[v[j]] > d[u[j]] + k[j] * mid + b[j]) {
      int x = u[j];
      for (int i = 0; i < n; ++i) x = u[pre[x]];
      int coef = k[pre[x]];
      for (int y = u[pre[x]]; y != x; y = u[pre[y]]) coef += k[pre[y]];
      return coef > 0 ? 1 : -1;
    }
  return 0;
}

int main() {
  scanf("%d%d", &n, &m);
  for (int i = 1; i < n; ++i) add(i, i + 1, 0, -1);
  add(n, 1, 1, -1);
  for (int i = 0; i < m; ++i) {
    int t, S, T, L;
    scanf("%d%d%d%d", &t, &S, &T, &L);
    if (t == 1) {
      if (S < T) add(S, T, 0, -L);
      else add(S, T, 1, -L);
    } else {
      if (S < T) add(T, S, 0, L);
      else add(T, S, -1, L);
    }
  }
  ll l = 0, r = INF;
  while (l < r) {
    ll mid = (l + r + 1) / 2;
    int t = solve(mid);
    if (t == 0) l = mid;
    else if (t == 1) l = mid + 1;
    else r = mid - 1;
  }
  ll ub = l;
  if (ub >= INF) return puts("-1"), 0;
  l = 0, r = INF;
  while (l < r) {
    ll mid = (l + r) / 2;
    int t = solve(mid);
    if (t == 0) r = mid;
    else if (t == 1) l = mid + 1;
    else r = mid - 1;
  }
  printf("%lld\n", ub - l + 1);
}
```


---

## 作者：MaxBlazeResFire (赞：8)

题解区怎么被 $\rm Bellman-Ford$ 占领了啊？

来一篇 $\rm SPFA$。

---

综合性较强的差分约束练习题。

首先我们来思考一下，在差分约束的题目里面，**建模后图中出现一个负环** 代表什么？

考虑负环的本质。设图中有这样一个环： $a_1\rightarrow a_2\rightarrow a_3\cdots\rightarrow a_n\rightarrow a_1$，它代表的不等式组为：

$\begin{cases}
a_2\leq a_1+w_1\\
a_3\leq a_2+w_2\\
\cdots\\
a_n\leq a_{n-1}+w_{n-1}\\
a_1\leq a_n+w_n\\
\end{cases}$

注意到这一组不等式 **均成立** 的 **必要条件** 是什么？将不等号左右相加，记这个条件为 $P:$

$\displaystyle\sum_{i=1}^nw_i\geq 0$.

**于是我们发现，差分约束系统的逻辑链为: 有负环 $\rightarrow$ $P$ 不成立 $\rightarrow$ 不等式组中存在一部分无解 $\rightarrow$ 问题无解。**

接下来考虑本题：

记 $D_i$ 表示从 $1$ 号车站到 $i$ 号车站的距离，其中 $i\in[1,n]$。记总环长为 $C$。

对于约束 $1$，若 $S<T$，那么有 $D_S\leq D_T-L$；若 $S>T$，那么有 $C-(D_S-D_T)\geq L$，也即 $D_S\leq C+D_T-L$。

对于约束 $2$，若 $S<T$，那么有 $D_T\leq D_S+L$；若 $S>T$，那么有 $C-(D_S-D_T)\leq L$，也即 $D_T\leq D_S+L-C$。

还有一些天然的条件，即 $D_{i}\leq D_{i+1}-1$，$D_n\leq D_1+C-1$。

然后我们判负环。

我们发现，上面的所有不等式约束均可以写作

$R_p:a_i\leq a_j+T_p+k_pC$，其中 $T_p$ 为常数，$k_p=0,\pm 1$。

**那么如果求出来一个负环，等价于存在一部分约束可以推出**

$\displaystyle R(C)=\sum_{p}T_p+k_pC<0$。

我们发现这是一个关于 $C$ 的一次不等式。

那么我们可以二分 $C$ 的上下限。例如求上限：

1. 若不存在负环，说明对于任意的环均有 $R(C)\geq 0$，那么 $C$ 的上限可以增大。

2. 若存在负环，我们找到这个负环代表式中的 $k_p$。

	(1) 若 $k_p=0$ 则 $R(C)$ 恒小于 $0$，必然出现负环，直接输出 $-1$。

   (2) 若 $k_p>0$ 则 $R(C)$ 关于 $C$ 单调上升，上界应该增大；
   
   (3) 若 $k_p<0$ 则 $R(C)$ 关于 $C$ 单调递减，上界应该缩小。

**求下限时仅当无负环时与求上限时相反。**

这个东西为什么是正确的？注意 $R(C)$ 代表的是 **某一个** 负环所代表的不等式，每一次二分后的调整都是 **针对该不等式** 作出的调整，并且保证 **对于该不等式不会更劣**。换句话说，若某个时刻不存在负环，说明所有不等式都被我们调整过了。

具体实现的时候，边权设为一个有关 $C$ 的一次多项式，判断松弛的时候代入值即可。

注意无限解的情况也即上界无限增大的情况也要判掉（这种情况下不会出现负环但也要输出 $-1$）。

代码中二分用的闭区间，判负环用的 $\rm SPFA$，供参考。

如果你一直 55 ~ 65 pts 徘徊，可以看一下是不是二分上界设得太大，导致负环绝对值超过 long long 范围变成正环。

时间复杂度 $O(nm\log w)$。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define MAXN 505

int n,m,S,x;

struct node{
	int t,k;
	node( int T = 0 , int K = 0 ): t(T),k(K){}
	inline node operator +( node b ){ return node{ t + b.t , k + b.k }; }
	inline node operator -( node b ){ return node{ t - b.t , k - b.k }; }
	inline bool operator >( node b ){ return t + k * x > b.t + b.k * x; }
};

vector< pair<int,node> > E[MAXN];
pair<int,node> pre[MAXN];

int vis[MAXN],vis2[MAXN],upd[MAXN];
node dist[MAXN],dischk[MAXN];
queue<int> Q;

node get_circle( int v ){
	for( int i = 1 ; i <= n ; i ++ ) vis2[i] = 0,dischk[i] = node( 0 , 0 );
	int now = v;
	while( 1 ){
		vis2[now] = 1;
		int nxt = pre[now].first;
		node tmp = dischk[now] + pre[now].second;
		if( vis2[nxt] ) return tmp - dischk[nxt];
		now = nxt,dischk[now] = tmp;
	}
}

inline int SPFA(){
	while( !Q.empty() ) Q.pop();
	for( int i = 1 ; i <= n ; i ++ ) dist[i] = node( 1e12 , 0 ),vis[i] = upd[i] = 0;
	Q.push( S ),vis[S] = upd[S] = 1,dist[S] = node( 0 , 0 );
	while( !Q.empty() ){
		int u = Q.front(); Q.pop();
		vis[u] = 0;
		for( pair<int,node> p : E[u] ){
			int v = p.first; node w = p.second;
			if( dist[v] > dist[u] + w ){
				dist[v] = dist[u] + w;
				pre[v] = make_pair( u , w );
				if( !vis[v] ){
					Q.push( v );
					upd[v] ++;
					vis[v] = 1;
					if( upd[v] > n + 1 ){
						node circle = get_circle( v );
						if( circle.k > 0 ) return 1;
						if( circle.k < 0 ) return -1;
						return 0;
					}
				}
			}
		}
	}
	return 233;
}

signed main(){
	scanf("%lld%lld",&n,&m);
	for( int i = 1 ; i <= m ; i ++ ){
		int opt; scanf("%lld",&opt);
		if( opt == 1 ){
			int s,t,l; scanf("%lld%lld%lld",&s,&t,&l);
			if( s < t ) E[t].emplace_back( make_pair( s , node( -l , 0 ) ) );
			else E[t].emplace_back( make_pair( s , node( -l , 1 ) ) );
		}
		else if( opt == 2 ){
			int s,t,l; scanf("%lld%lld%lld",&s,&t,&l);
			if( s < t ) E[s].emplace_back( make_pair( t , node( l , 0 ) ) );
			else E[s].emplace_back( make_pair( t , node( l , -1 ) ) );
		}
	}
	for( int i = 1 ; i < n ; i ++ ) E[i + 1].emplace_back( make_pair( i , node( -1 , 0 ) ) );
	E[1].emplace_back( make_pair( n , node( -1 , 1 ) ) );
	S = n + 1;
	for( int i = 1 ; i <= n ; i ++ ) E[S].emplace_back( make_pair( i , node( 0 , 0 ) ) );
	int L = 1,R = 1e12,Up = 0,Dn = 0;
	while( L <= R ){
		x = ( L + R ) >> 1;
		int tmp = SPFA();
		if( tmp == 233 ) Up = x,L = x + 1;
		else if( tmp == 1 ) L = x + 1;
		else if( tmp == -1 ) R = x - 1;
		else{ printf("-1\n"); return 0; }
	}
	if( Up >= 1e12 - 10 ){ printf("-1\n"); return 0; }
	L = 0,R = 1e12;
	while( L <= R ){
		x = ( L + R ) >> 1;
		int tmp = SPFA();
		if( tmp == 233 ) Dn = x,R = x - 1;
		else if( tmp == -1 ) R = x - 1;
		else if( tmp == 1 ) L = x + 1;
		else{ printf("-1\n"); return 0; }
	}
	printf("%lld\n",Up - Dn + 1);
	return 0;
}
```

---

## 作者：Pengzt (赞：7)

[P7624](https://www.luogu.com.cn/problem/P7624)

令 $d_i$ 表示 $1$ 号车站到 $i$ 号车站的距离，$len$ 表示环形地铁的总长度。

考虑题中给的条件：

$type_i = 0$ 时，若 $u_i < v_i$，即可表示为 $d_{v_i} - d_{u_i} \ge L_i \iff d_{u_i} \le d_{v_i} - L_i$。否则就是要经过 $n$ 号点和 $1$ 号点，则可表示为 $d_{u_i} - d_{v_i} \le len - L_i$，即 $d_{u_i} \le d_{v_i} + len - L_i$。

同理，当 $type_i = 2$ 时，若 $u_i < v_i$，有 $d_{v_i} \le d_{u_i} + L_i$。
否则有 $d_{u_i} \le d_{v_i} + L_i - len$。

若将 $len$ 看作常数，容易发现这些不等式可以用差分约束解决。

发现当图中有负环时，根据 $len$ 的系数和来判断这个环的权值的关系，显然具有单调性，使用二分解决即可。

推荐写 Bellman-Ford 判负环，代码简便且跑的较快。


[评测记录](https://www.luogu.com.cn/record/113720078)

因为没有 SPFA 的代码，这里给出核心代码，其中二分的细节参照了 meyi 的代码。

```cpp
int check(ll mid) {
	queue<int> q;
	for (int i = 1; i <= n; i++) dis[i] = INF, vis[i] = 0;
	memset(cnt, 0, sizeof(cnt));
	memset(pre, 0, sizeof(pre));
	q.push(1);
	dis[1] = 0, vis[1] = cnt[1] = 1;
	while (!q.empty()) {
		int u = q.front(); q.pop();
		vis[u] = 0;
		for (int i = head[u], v; i != 0; i = e[i].nxt)
			if (dis[v = e[i].v] > dis[u] + e[i].w + e[i].k * mid) {
				dis[v] = dis[u] + e[i].w + e[i].k * mid;
				pre[v] = i;
				if (vis[v] == 0) {
					vis[v] = 1;
					q.push(v);
					if (++cnt[v] > n) {
						int x = u;
						for (int j = 1; j <= n; j++) x = e[pre[x]].u;
						int sk = e[pre[x]].k;
						for (int y = e[pre[x]].u; y != x; y = e[pre[y]].u) sk += e[pre[y]].k;
						return sk > 0 ? 1 : -1;
					}
				}
			}
	}
	return 0;
}
ll get_l() {
	ll l = 0, r = inf;
	while (l < r) {
		ll mid = (l + r) / 2;
		int tmp = check(mid);
		if (tmp == 0) r = mid;
		else if (tmp == 1) l = mid + 1;
		else r = mid - 1;
	}
	return l;
}
ll get_r() {
	ll l = 0, r = inf;
	while (l < r) {
		ll mid = (l + r + 1) / 2;
		int tmp = check(mid);
		if (tmp == 0) l = mid;
		else if (tmp == 1) l = mid + 1;
		else r = mid - 1;
	}
	return l;
}

int main() {
	ios
	cin >> n >> m;
	for (int i = 1; i < n; i++) adde(i + 1, i, -1, 0);
	adde(1, n, -1, 1);
	for (int i = 1, opt, u, v, w; i <= m; i++) {
		cin >> opt >> u >> v >> w;
		if (opt == 1) {
			if (u < v) adde(v, u, -w, 0);
			else adde(v, u, -w, 1);
		} else {
			if (u < v) adde(u, v, w, 0);
			else adde(u, v, w, -1);
		}
	}
	ll r = get_r();
	if (r >= inf) {
		cout << -1 << "\n";
		return 0;
	}
	ll l = get_l();
	cout << r - l + 1 << "\n";
	return 0;
}
```

---

## 作者：suzhikz (赞：2)

相似了。

在校内训练中因为点的下标写错了导致调了两个小时。

题面感觉就很像差分约束，所以我们往这上面想。

这个环非常不好处理，肯定要先断环为链对吧。

首先假设 $dis_i$ 表示 $i$ 到 $0$ 的距离。环的长度为 $x$。

对于第一种边，如果说 $s<t$，没什么好说的，直接连即可。

若 $s>t$，则有 $dis_s-dis_t\le x-L_i$。

同理，第二种边也这么转化下，就可以转化成若干个形如 $dis_x-dis_y\le w$。

然后就可以差分约束了。

但是这题要求 $x$ 的取值个数，显然 $x$ 能取到的数是连续的。

所以可以用二分答案。

现在难点是判断某个数在答案范围左边还是右边还是包含。

首先包含，即连完边后没有负环。简单。

如果有负环呢？看看负环上，有几个边的权值和 $x$ 有关，如果 $x$ 带来的贡献是正的，那么我就要让 $x$ 变大才能消去负环，否则要减小。如果这个负环和 $x$ 无关就是无解。

比较难调，放个代码参考下。


```cpp
#include<bits/stdc++.h>
#define ll long long
#define reg register
#define db double
#define il inline
using namespace std;
void read(int &x){x=0;int f=1;char c=getchar();while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}x*=f;}
void read(ll &x){x=0;int f=1;char c=getchar();while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}x*=f;}
const int N=1005;
int n,m1,m2,m;
vector<ll>g[N],w[N],w2[N];
ll u[N*2],v[N*2],ww[N*2];
ll dis[N],dis2[N];
void add(int u,int v,ll ww,ll ww2){
//	if(ww2==0)
//	cout<<u<<' '<<v<<' '<<ww<<endl;//' '<<ww2<<endl;
	g[u].push_back(v);w[u].push_back(ww);w2[u].push_back(ww2);
}
bool vis[N];
int check(ll x){
	for(int i=1;i<=n;i++)add(i,i-1,-1,0);
	for(int i=1;i<=m1;i++){
		if(u[i]<v[i]){
			add(v[i],u[i],-ww[i],0);
		}else{
			add(v[i],u[i],x-ww[i],1);
		}
	}
	for(int i=m1+1;i<=m1+m2;i++){
		if(u[i]<=v[i]){
			add(u[i],v[i],ww[i],0);
		}else{
			add(u[i],v[i],ww[i]-x,-1);
		}
	}
	add(0,n,x,1);
	add(n,0,-x,-1);
	memset(dis,0x3f3f3f3f,sizeof(dis));dis[0]=0;
	memset(dis2,0,sizeof(dis2));memset(vis,0,sizeof(vis));
	queue<int>q;
	q.push(0);vis[0]=1;
	int cnt[N]={0};
	while(!q.empty()){
		int x=q.front();q.pop();
//		cout<<x<<endl;
		vis[x]=0;
		if(cnt[x]>=n+1){
			for(int i=0;i<=n;i++){
				g[i].clear();w[i].clear();w2[i].clear();
			}
			if(dis2[x]==0){
				puts("-1");exit(0);
			}
			return dis2[x];
		}
		for(int i=0;i<g[x].size();i++){
			ll y=g[x][i],ww=w[x][i];
			if(dis[y]>dis[x]+ww){
				dis[y]=dis[x]+ww;dis2[y]=dis2[x]+w2[x][i];
				if(!vis[y]){
					vis[y]=1;q.push(y);cnt[y]++;
				}
			}
		}
	}
	for(int i=0;i<=n;i++){
		g[i].clear();w[i].clear();w2[i].clear();
	}
	return 0;
}
int main(){
	read(n);read(m);
	for(int op,i=1;i<=m;i++){
		read(op);
		if(op==1){
			m1++;
			read(u[m1]);read(v[m1]);read(ww[m1]);
		}else{
			m2++;
			read(u[m-m2+1]);read(v[m-m2+1]);read(ww[m-m2+1]);
		}
	}
//	cout<<check(100)<<endl;
//	for(int i=1;i<=5;i++)cout<<check(1ll*i)<<endl;
//	for(int i=900;i<=4246;i++)cout<<check(i)<<endl;
//	return 0;
	ll l=1,r=1ll*n*1e9,mid,ans1=0,ans2=-2;
	while(l<=r){
		mid=(l+r)/2;
		int c=check(mid);
		if(c<0){
			r=mid-1;
		}else if(c==0){
			r=mid-1;ans1=mid;
		}else{
			l=mid+1;
		}
	}l=1,r=1ll*n*1e9;
	while(l<=r){
		mid=(l+r)/2;
		int c=check(mid);
		if(c>0){
			l=mid+1;
		}else if(c==0){
			ans2=mid;l=mid+1;
		}else{
			r=mid-1;
		}
	}
//	cout<<ans2<<' '<<ans1<<endl;
	if(ans2==1ll*n*1e9)puts("-1");
	else cout<<ans2-ans1+1;
	return 0;
}
```

---

## 作者：ykzzldz (赞：2)

最近在复习差分约束的时候看到了这题，就来写个题解。

看到条件为不小于、不大于这种形式，自然想到使用差分约束。

设 $dis_i$ 为 $1$ 站到 $i$ 站的顺时针方向的距离，则有 $dis_i+1\le dis_{i+1}$。我们设环长为 $x$，思考如何连边来表示题目中的条件：

对于第一种条件：

- $S_i\le T_i$：$dis_{T_i}-dis_{S_i}\ge L_i$，从 $T_i$ 到 $S_i$ 连边权为 $-L_i$ 的边

- $S_i\ge T_i$：$dis_{S_i}-dis_{T_i}\le x-L_i$，从 $T_i$ 到 $S_i$ 连边权为 $x-L_i$ 的边

第二种条件和第一种条件基本相同，这里就不过多赘述了。

容易发现，最后可能的 $x$ 值为一个区间，考虑二分这个区间的左右端点。

具体地，对于一个 $x$，我们将其代入图中（也就是用 $x$ 来连边），其中由于对 $x$ 的限制是一个一次函数，考虑无解（出现负环）时对其前面的系数 $k$ 进行讨论，这里以求上界为例：

- $k=0$：直接输出 $-1$

- $k>0$：增加上界

- $k<0$：缩小上界

求下界的思路与求上界的思路类似，这里省略。然后这题就做完了。

---

## 作者：_LiWenX_ (赞：2)

分享一个完全不用考虑负环的做法。

首先不难发现，设 $f_{i}$ 为从 $1$ 到 $i$ 的距离，那么在已知 $f_n=C$ 的情况下所有的限制都是一些与 $f$ 有关的不等式。

具体来说，对于一次 $op_i,s_i,t_i,L_i$，假设 $x=s_i,y=t_i,d=L_i$

若 $x>y$：

1. 当 $op_i=1$ 时，$f_y\le f_x+C-d$。

2. 当 $op_i=2$ 时，$f_x\le f_y+d-C$。

若 $x<y$：

3. 当 $op_i=1$ 时，$f_x\le f_y-d$。

4. 当 $op_i=2$ 时，$f_y\le f_x+d$。

且 $\forall 1\le i<n,f_i\le f_{i+1}-1$。

根据这些式子，我们可以利用差分约束算法判断一个 $f_n=C$ 时是否存在合法解。

发现挪动 $C$ 的值，会等量挪动若干不等式的某一个端点，所以使得有解的 $C$ 的取值范围是一段区间。

我们只要得到合法区间的两个端点，就可以得到答案。

但是值域超级大，得考虑快速找到端点，首先想到的是二分，但是由于合法点是区间，直接二分显然错误，如何解决呢？

我们试图实现一个功能为给出 $x$，快速判断是否存在 $i\ge x$，满足 $i$ 是一个合法点，如果可以做到这一点，那么我们就可以找到合法区间的左端点，从而使用朴素的二分找到右端点解决原问题。

值域解决是否存在 $i\ge x$，使得 $i$ 为合法点，发扬人类智慧，考虑当 $C=i$ 足够大时，限制 $1$ 必然满足，而其它限制都是 $C$ 较小才容易满足，所以直接去掉限制 $1$ 后，按照 $C=x$ 跑一遍差分约束即可！

至于判断是否有无穷解，我们在代码实现中总是会设置一个极大值 $inf$，如果最终答案大于 $0.9inf$，直接认为无穷解即可。

时间复杂度 $O(n(n+m)\log V)$。

代码如下，不过具体实现和上述思路有略微区别：

```cpp
#include<bits/stdc++.h> 
#define int long long
using namespace std;
struct edge{
	int from,to,val;
}e[505<<2];int head[505],siz;
void addedge(int x,int y,int z){
	swap(x,y);
	e[++siz].to=y,e[siz].val=z;
	e[siz].from=head[x],head[x]=siz;
}
int n,m;
int dis[505],vis[505],cnt[505];
bool spfa(){
	for(int i=0;i<=n;i++){
		dis[i]=1e14;
		vis[i]=cnt[i]=0;
	}
	dis[0]=0;
	queue<int> q;q.push(0);
	while(!q.empty()){
		int now=q.front();q.pop();
		vis[now]=0;
		cnt[now]++;
		if(cnt[now]>=n) return 0;
		for(int i=head[now];i;i=e[i].from){
			int u=e[i].to;
			if(dis[u]>dis[now]+e[i].val){
				dis[u]=dis[now]+e[i].val;
				if(!vis[u]){
					vis[u]=1;
					q.push(u);
				}
			}
		}
	}return 1;
}
void clear(){
	for(int i=0;i<=n;i++) head[i]=0;
	for(int i=1;i<=siz;i++) e[i].from=e[i].to=e[i].val=0;
	siz=0;
}
int op[505],s[505],t[505],d[505];
int check(int L,bool C){
	clear();
	for(int i=1;i<n;i++){
		addedge(i,i+1,-1);
	}
	for(int i=1;i<=m;i++){
		if(s[i]<=t[i]){
			if(op[i]==1){
				addedge(s[i],t[i],-d[i]);
			}
			else{
				addedge(t[i],s[i],d[i]);
			}
		}
		else{
			if(op[i]==1){
				addedge(s[i],t[i],L-d[i]);
			}
			if(op[i]==2){
				if(!C) continue; 
				addedge(t[i],s[i],d[i]-L);
			}
		}
	}
	addedge(n,0,L);
	bool ret=spfa();
	for(int i=1;i<=n;i++) if(dis[i]<=0) return 0;
	return ret;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>op[i]>>s[i]>>t[i]>>d[i];
	}
	int l=n,r=1e14,pos=1e14;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid,0)==1){
			pos=mid;
			r=mid-1;
		}
		else l=mid+1;
	}
	l=pos,r=1e14;
	int L=pos;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid,1)){
			pos=mid;
			l=mid+1;
		}
		else r=mid-1;
	}
	int R=pos;
	l=n,r=pos;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid,1)){
			pos=mid;
			r=mid-1;
		}
		else l=mid+1;
	}
	l=n,r=pos;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid,1)){
			L=mid;
			r=mid-1;
		}
		else l=mid+1;
	}
	l=pos,r=1e14;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid,1)){
			R=mid;
			l=mid+1;
		}
		else r=mid-1;
	}
	if(check(pos,1)==0||check(L,1)==0||check(R,1)==0){
		return 1;
	}
	int ans=R-L+1;
	if(ans>9e13){
		cout<<-1;
		return 0;
	}
	cout<<R-L+1<<'\n';
}
```

---

## 作者：complete_binary_tree (赞：2)

[原题传送门](https://www.luogu.com.cn/problem/P7624)

考虑差分约束[^1]。

[^1]:不会的可以出门左转[差分约束](https://oi-wiki.org/graph/diff-constraints/)。

考虑变成前缀和的形式，$d_i$ 表示第 $1$ 站到第 $i$ 站的长度。

这样，如果设 $C$ 为周长，那么从 $l$ 到 $r$ 站的长度就是 $d_r - d_l$，$r$ 到 $l$ 站的长度就是 $d_l + C - d_r$[^2]。

[^2]:这里 $l < r$。

这样就能快乐地差分约束了：

- 操作 $1$：$S \to T$ 的长度 $\ge L$。

  - $S < T$

  那么 $d_T - d_S \ge L$，两边同乘 $-1$ 得 $d_S - d_T \le -L$，所以 $T \to S$ 加一条 $-L$ 的边。

  - $S > T$

  那么 $d_T + C - d_S \ge L$，移向并乘 $-1$ 得 $d_S - d_T \le C - L$，所以 $T \to S$ 加一条 $C - L$ 的边。

- 操作 $2$：$S \to T$ 的长度 $\le L$。

  这个推导过程类似，这里只展示结果，读者可自行推导。

  - $S < T, d_S - d_T \le L$。

  - $S > T, d_S - d_T \le L - C$。

另外，差分约束系统中还有前缀和的约束，即 $d_{i+1} - d_i \ge 1$，要从 $i + 1$ 到 $i$ 连接 $-1$ 边。同时，$d_1 + C - d_n \ge 1$，要 $1$ 往 $n$ 连 $C - 1$ 边。

这时候你就得到了一个带有未知数 $C$ 的边集了。接下来我们要二分出 $C$ 的最大值和最小值（这里以最大值为例讲解）：

假设我们二分出中间值 $mid$，那么把 $mid$ 带入 $C$ 跑负环。

- 没有负环：由于要求最大值，$l=mid$。（最小值就 $r=mid$）

- 有负环：（无论最大最小值都一样）

  此时负环的长度可以求出，一定为 $\sum L_i + k \cdot C$ 的形式。

  我们着重看 $C$ 的系数 $k$：

  - $k < 0$：那么增大 $C$ 反而会让负环更大，所以减小，$r = mid - 1$。

  - $k = 0$：$C$ 的变化与负环值无关，无解。[^3] 

  [^3]:然而题目中并不会出现这种情况（保证有解）。

  - $k > 0$：减小 $C$ 才会让负环更大，所以增大，$l = mid + 1$。

  这里由于取 $mid$ 这个值已经有负环了，所以需要 $+1/-1$。

求负环长度可以 $\text{SPFA}$ 的同时记录这个点是从哪个点松弛而来，当一个点入队 $n$ 次后再往回找就行了。

注意如果一个点入队了 $n$ 次，**它不一定在负环上**[^4]。但可以确定的是，松弛路径上一定能找到一个负环。

[^4]:考虑有多个长度差 $1$ 的负环连向一个点的情况。

然后输出两次二分的差值 $+1$。注意如果最大值是二分的上限（上限取 $10^{12}$，不能太高，太高可能溢出变成正环）说明这个 $C$ 可以取到正无穷，此时输出 $-1$。

时间复杂度 $O(n(n + m) \log V)$，其中 $V = 10^{12}$。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N = 505, M = 505;
typedef long long ll;

struct ls{
    struct edge {
        int u, to, nxt, w; int bj;
        edge() {}
        edge( int u, int to, int w, int nxt, int bj ) : u( u ), to( to ), w( w ), nxt( nxt ), bj( bj ) {}
    } e[2 * N + M];
    int head[N], cnt;
    void add( int u, int v, int w, int bj ) { e[++cnt] = edge( u, v, w, head[u], bj ), head[u] = cnt; }
} G;

int n, m, vis[N], inq[N], lstw[N], lstu[N], diss[N];
bool vvis[N];
ll dis[N];

namespace FastIO{
    char OutputDevide = ' ';
    template<typename T>inline void read(T& x){T f=1;x = 0;char ch = getchar();while(ch<'0'||ch >'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();x*=f;}
    template<typename T,typename ... Args>inline void read(T& x,Args& ...args){read(x),read(args...);}
    template<typename T>inline void write(T x){if(x<0){putchar('-'),write(-x);return;}if(x/10)write(x/10);putchar(x%10+48);}
    template<typename T,typename ... Args>inline void write(T x,Args ...args){write(x),putchar(OutputDevide),write(args...);}
};
using FastIO::read, FastIO::write;

//SPFA判负环
int spfa( ll C ) {
    queue<int> q;

    //多测不清空，_____
    memset( dis, 0x3f, sizeof dis );
    memset( vis, 0, sizeof vis );
    memset( inq, 0, sizeof inq );
    memset( lstu, 0, sizeof lstu );
    memset( lstw, 0, sizeof lstw );

    q.push( n + 1 );
    dis[n + 1] = 0;

    while( !q.empty() ) {
        int u = q.front(); q.pop();
        inq[u] = 0;

        for( int i = G.head[u]; i; i = G.e[i].nxt ) {
            int v = G.e[i].to;
            ll w = G.e[i].w + G.e[i].bj * C;

            if( dis[v] > dis[u] + w ) {
                dis[v] = dis[u] + w;
                lstu[v] = u, lstw[v] = G.e[i].bj;

                if( !inq[v] ) {
                    q.push( v );
                    vis[v]++;
                    inq[v] = 1;

                    //找到负环
                    if( vis[v] > n ) {
                        //多测不清空，_____x2
                        memset( vvis, 0, sizeof vvis );
                        memset( diss, 0, sizeof diss );

                        int sum = 0;
                        int _u = v;

                        //找环
                        while( 1 ) {
                            vvis[_u] = 1;
                            if( vvis[lstu[_u]] ) { sum = diss[_u] + lstw[_u] - diss[lstu[_u]]; break; }
                            diss[lstu[_u]] = diss[_u] + lstw[_u];
                            _u = lstu[_u];
                        }
                        
                        if( sum > 0 ) return 1;
                        if( sum < 0 ) return -1;
                        return 0;
                    }
                }
            }
        }
    }
    return 0;
}

//最小值
ll bs1() {
    ll l = 1, r = 1e12;
    while( l < r ) {
        ll mid = ( l + r ) >> 1;
        int re = spfa( mid );
        if( re == -1 ) r = mid - 1;
        else if( re == 1 ) l = mid + 1;
        else r = mid;
    }
    return l;
}

//最大值
ll bs2() {
    ll l = 1, r = 1e12;
    while( l < r ) {
        ll mid = ( l + r + 1 ) >> 1;
        int re = spfa( mid );
        if( re == -1 ) r = mid - 1;
        else if( re == 1 ) l = mid + 1;
        else l = mid;
    }
    return l;
}

signed main() {
    read( n, m );

    for( int i = 1; i <= m; ++i ) {
        int op, s, t, l;
        read( op, s, t, l );

        if( op == 1 ) {
            if( s > t ) G.add( t, s, -l, 1 );
            else G.add( t, s, -l, 0 );
        }
        else {
            if( s > t ) G.add( s, t, l, -1 );
            else G.add( s, t, l, 0 );
        }
    }
    for( int i = 1; i <= n; ++i ) G.add( n + 1, i, 0, 0 ); //“超级源点”的套路

    //前缀和
    for( int i = 1; i < n; ++i ) G.add( i + 1, i, -1, 0 );
    G.add( 1, n, -1, 1 );

    ll ansl = bs1(), ansr = bs2();

    //有无限多种
    if( ansr >= 1e12 ) {
        puts( "-1" );
        return 0;
    }
    printf( "%lld\n", ansr - ansl + 1 );
    return 0;
}
```

---

---

## 作者：Otue (赞：1)

## [P7624 [AHOI2021初中组] 地铁](https://www.luogu.com.cn/problem/P7624)

### 题目大意

B 市的地铁历史悠久，小雪和小可可乘坐的 X 号线是环形路线，上面分布着 $n$ 个车站，相邻两个车站之间的铁路长度为正整数。现在小雪进行了一些观察，得到了 $m$ 条信息，第 $i$ 条信息是如下形式之一：

1. 环上顺时针由 $S_i$ 到 $T_i$ 的一段距离不小于一个给定的值 $L_i$。
2. 环上顺时针由 $S_i$ 到 $T_i$ 的一段距离不大于一个给定的值 $L_i$。

小雪想要你计算最后 X 线地铁的总长度有多少种不同的合法取值。

### 题目思路

首先可以发现这是一个差分约束的形式。具体的，定义 $d_i$ 表示 $1$ 号车站到 $i$ 号车站的距离，同时 $x$ 表示整个环上的长度。那么题目给定限制条件：

* 环上顺时针由 $S_i$ 到 $T_i$ 的一段距离不小于一个给定的值 $L_i$：
  * 如果 $S_i\leq T_i$，转化成最长路求解则为 $d_{S_i}-d_{T_i}\leq -L_i$。
  * 如果 $S_i>T_i$，则可以得到 $d_{S_i}-d_{T_i}\leq x-L_i$。
* 环上顺时针由 $S_i$ 到 $T_i$ 的一段距离不大于一个给定的值 $L_i$：
  * 如果 $S_i\leq T_i$，则可以得到 $d_{T_i}-d_{S_i}\leq L_i$。
  * 如果 $S_i>T_i$，则可以得到 $d_{T_i}-d_{S_i}\leq L_i-x$。

其中有 $d_1=0$，$d_{i+1}\geq d_i+1$，$d_n\leq x-1$ 等必须满足的条件。将这些不等式限制转化成：$d_i\leq d_j+b_P+k_P\times x$。其中 $b_P$ 是常数，$k_P$ 是 $x$ 的系数。

那么对于一个负环来讲，等价于 $\sum \limits_{P} b_P+k_Px<0$。可以发现 $x$ 的取值是一段区间。那么我们分别二分出上界和下界。

如果当前二分不存在负环，那么上界就可以调大。如果存在负环，我们随意找到一个负环：

* 如果 $k_P>0$，则应该调大 $x$。
* 如果 $k_P<0$，则应该调小 $x$。
* 如果 $k_P=0$，则无论找到哪个 $x$ 都无法满足条件。题目中保证不会出现这种无解情况。

这样做一定是对的，因为每次调整都可以让一个负环变大，最后会调整成所有负环都变成正环。

---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P7624)

# 思路：

先考虑如果已知环长 $length$，如何判断是否存在一组合法的方案使得限制满足。

考虑差分约束，先套路地断环成链，断开边 $n\to1$。设 $dis_i$ 表示从节点 $1$ 到节点 $i$ 的最短路长度，考虑差分约束：

- 对于相邻节点的限制，有

  $dis_i\le dis_{i+1}−1$

  $dis_n\le dis_1+length−1$

- 对于限制类型 $1$，有

  $dis_{s_i}\le dis_{t_i}−L_i$

  $dis_{s_i}\le dis_{t_i}+length−L_i$

- 对于限制类型 $2$，有

  $dis_{t_i}\le dis_{s_i}+L_i$

  $dis_{t_i}\le dis_{s_i}−length+L_i$

数据范围较小直接 Bellman-Ford 判负环即可。

在此基础上考虑如何求 $length$。对于某个不合法的 $length$，我们考察图中某个负环的情况：

- 负环的权值和 $s$ 可以表示成：$s = k\times length + \sum L_i \lt0$ 的形式。

- 保证保证至少有一种可能的方案，则 $k\not= 0$，否则没有合法的 $length$。

- 则我们可以通过调整 $length$ 的取值使得该负环消失。具体地，若 $k\gt0$ 则令 $length$ 增大，否则减小。

- 由于所有负环的权值和均可以表示成这种形式，则形成负环的原因是 $length$ 过大或过小，则最终 $length$ 的取值范围一定是一段连续区间。

于是我们考虑二分答案来确定 $length$ 的上界和下界，对所有枚举到的 $mid$ 都进行一次差分约束算法求负环，并按照上述方式进行调整即可。如果求得的上界过大，说明解有无穷种取值。

总复杂度 $O(nm\log L)$ 级别。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
const int INF=9e18;
int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
void write(int x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9){
        write(x/10);
    }
    putchar(x%10+'0');
    return;
}
int n,m,mns,mxs,dis[N],pre[N],en,u[N],v[N],k[N],w[N],l,r;
void add(int uu,int vv,int kk,int ww){
    u[++en]=uu;
    v[en]=vv;
    k[en]=kk;
    w[en]=ww;
}
int check(int sm){
    for(int i=1;i<=n;i++){
        dis[i]=INF;
    }
    dis[1]=0;
    for(int j=1;j<=n;j++){ 
        for(int i=1;i<=en;i++){
            int uu=u[i],vv=v[i],kk=k[i],ww=w[i];
            if(dis[vv]>dis[uu]+kk*sm+ww){  
                dis[vv]=dis[uu]+kk*sm+ww; 
                pre[vv]=i;
            }   
        }   
    } 
    for(int i=1;i<=en;i++){  
        int uu=u[i],vv=v[i],kk=k[i],ww=w[i];
        if(dis[vv]>dis[uu]+kk*sm+ww){
            for(int i=1;i<=n;i++){
                uu=u[pre[uu]];
            } 
            int sk=k[pre[uu]];
            for(int yy=u[pre[uu]];yy!=uu;yy=u[pre[yy]]){
                sk+=k[pre[yy]];
            }
            return sk>0?1:-1;
        } 
    } 
    return 0;
}
signed main(){
    n=read();
    m=read();
    for(int i=1;i<n;i++){
        add(i+1,i,0,-1);
    }
    add(1,n,1,-1);
    for(int i=1,type,s,t,l;i<=m;i++){  
        type=read();
        s=read();
        t=read();
        l=read();
        if(type==1){
            if(s<t){
                add(t,s,0,-l);
            }else{
                add(t,s,1,-l);
            }
        }else{
            if(s<t){
                add(s,t,0,l);
            }else{
                add(s,t,-1,l);
            }
        } 
    }
    for(l=0,r=1e12;l<r;){  
        int mid=(l+r+1)>>1ll,ret=check(mid);
        if(ret==0){
            l=mid;
        }else if(ret==1){
            l=mid+1;
        }else{
            r=mid-1;
        }
    } 
    mxs=l;
    if(mxs>=1e12){  
        cout<<-1;
        return 0;
    } 
    for(l=0,r=1e12;l<r;){  
        int mid=(l+r)>>1ll,ret=check(mid);
        if(ret==0){
            r=mid;
        }else if(ret==1){
            l=mid+1;
        }else{
            r=mid-1;
        }
    } 
    mns=l;
    cout<<mxs-mns+1;
    return 0;
}
```

完结撒花~

---

## 作者：快斗游鹿 (赞：0)

设 $d_i$ 表示顺时针点 $1$ 到点 $i$ 的长度，那么题目中的限制可以改写成：

- 若 $S_i<T_i$，$d_{T_i}-d_{S_i}\ge L$，否则 $X-(d_{S_i}-d_{T_i})\ge L$，其中 $X$ 是总长度。

- 若 $S_i<T_i$，$d_{T_i}-d_{S_i}\le L$，否则 $X-(d_{S_i}-d_{T_i})\le L$，其中 $X$ 是总长度。

除了上述限制，**相邻点之间也有限制**，$\forall i<n,d_{i+1}-d_{i}\ge 1$，同时 $X-(d_{n}-d_{1})\ge 1$。

注意到限制与总长度有关系，所以可以直接枚举总长度 $X$ 并判断是否合法（有无负环）。但这样太慢了。注意到合法答案取值一定连续，因此考虑二分出答案左右端点 $l,r$。以二分 $r$ 为例，如果此时图中没负环，那上界可能可以再大一点，否则随便拎一个负环出来，它的边权和必然可以表示成 $kX+w$ 的形式，如果 $k<0$，$X$ 肯定要更小，如果 $k>0$，$X$ 肯定要更大，$k=0$ 则无解（不会出现）。

最后就是如何拎出一个负环，如果到某个点最短路径边数超过 $n$，意味着这条路径上**一定出现了负环，但这个点未必在负环上**，所以只需从这个点往回搜，直到出现环即可。

```cpp
#include<bits/stdc++.h>
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <vector>
#include <map>
#include <queue>
#include <algorithm>
#include <math.h>
#include <cstdio>
#define int long long
using namespace std;
const int inf=1e16;
const int N=2e3+5;
struct Node{
	int op,s,t,l;
}a[N];
struct edge{
	int to,u,nxt,num,w;
}e[N<<1];
int n,m,cnt,head[N],lst[N];
int dis[N],num[N],id[N],d[N];
bool flag[N],vis[N]; 
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
void add(int u,int v,int num,int w){
	e[++cnt].to=v;e[cnt].nxt=head[u];e[cnt].u=u;e[cnt].w=w;e[cnt].num=num;
	head[u]=cnt;
}
bool find(int u){
	int x=u,sum=0;int ccc=0;
	while(1){
		d[++ccc]=x;
		if(vis[x]){
			break;
		}
		vis[x]=1;x=e[lst[x]].u;
		//cout<<x<<endl;
	}
	for(int i=ccc-1;i>=1;i--){
		sum+=e[lst[d[i]]].num;
		if(d[i]==d[ccc])break;
	}
	//cout<<"!"<<sum<<endl;
	return (sum>0?1:0);
}
bool check(int x,int op){
	for(int i=0;i<=n;i++)dis[i]=inf,flag[i]=0,num[i]=0,lst[i]=0,vis[i]=0;
	queue<int>q;q.push(0);dis[0]=0;
	while(!q.empty()){
		int u=q.front();q.pop();flag[u]=0;
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].to,w=e[i].w+e[i].num*x;
			if(dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;num[v]=num[u]+1;lst[v]=i;
				if(num[v]>n){
					return find(v);
				}
				if(!flag[v])flag[v]=1,q.push(v);
			}
		}
	}
	//cout<<"!!!"<<endl;
	return op;
}
signed main(){
	//freopen("subway3.in","r",stdin);
	//ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);
	n=read();m=read();
	for(int i=1;i<=n;i++)id[i]=i;
	random_shuffle(id+1,id+1+n);
	for(int i=1;i<=n;i++)add(0,id[i],0,0);
	for(int i=1;i<n;i++)add(i+1,i,0,-1);//i<=i+1-1
	add(1,n,1,-1);//1<=n-1
	for(int i=1;i<=m;i++){
		int op,s,t,l;op=read();s=read();t=read();l=read();
		if(op==1){//t-s>=l
			if(s<=t)add(t,s,0,-l);//s<=t-l
			else add(t,s,1,-l);//x-(s-t)>=l x-s+t>=l s<=t+x-l
		}
		else{//t-s<=l
			if(s<=t)add(s,t,0,l);//t<=s+l
			else add(s,t,-1,l);//x-(s-t)<=l x-s+t<=l t<=s+l-x
		}
	}
	int l=1,r=1e12,L=0,R=-1;
	while(l<=r){
		int mid=(l+r)>>1;
		//cout<<"?"<<mid<<endl;
		if(check(mid,1))R=mid,l=mid+1;
		else r=mid-1;
	}
	if(R==1e12){
		puts("-1");return 0;
	}
	//cout<<"******"<<R<<endl;
	l=1,r=1e12;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid,0))L=mid,l=mid+1;
		else r=mid-1;
	}
	//cout<<"!"<<L<<" "<<R<<endl;
	cout<<R-L;
	return 0;
}

```

---


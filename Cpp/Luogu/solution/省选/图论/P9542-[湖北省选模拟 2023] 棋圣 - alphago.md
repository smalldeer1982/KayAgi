# [湖北省选模拟 2023] 棋圣 / alphago

## 题目描述

小 K 是一名棋手，厌倦了传统围棋之后，他发明了一种新式围棋。

新式围棋是一种单人游戏。这个游戏的棋盘是一张包含 $n$ 个顶点，$m$ 条边的无向连通图，并且不存在重边和自环。同时，每条边有一个权值，第 $i$ 条边的权值为 $w_i$。

游戏开始时，每个顶点上可能有一颗黑棋或者一颗白棋，或者什么也没有。**至少有一个顶点上没有棋子。** 接下来，玩家需要进行若干次操作。每次的操作形式如下：

首先，选定一个上面没有棋子的顶点 $u$。可以说明，在题目数据范围下，一定存在这样的顶点。

接下来，对于每一颗棋子，若它位于顶点 $v$，则玩家需任选一条从 $v$ 到 $u$ 的**简单路径**，并将这颗棋子沿着这条简单路径移动一步。形式化地，一条简单路径为一个顶点序列 $\{p_1,p_2 \ldots p_k\}$，满足 $p_1 = v$，$p_k = u$ ，$p_1,p_2 \ldots p_k$ **互不相同**，且 $p_i$ 和 $p_{i+1}$ 之间存在一条边。在操作之后，这颗棋子将被移动至顶点 $p_2$。

需要注意的是，虽然在游戏开始时每个顶点上至多存在一颗棋子，但在若干次操作之后一个顶点上可能有多个棋子。对于同一个顶点上的不同棋子，一次操作中选取的简单路径可以不同。

玩家可以在进行任意次操作（可以是 $0$ 次）之后进行**点目**，即结算游戏分数。对于每一对颜色不同的棋子，若它们所在的顶点之间由一条权值为 $w$ 的边直接相连，则称它们**围住了这条边**，会使玩家得到 $w$ 的**目数**。而一个玩家所得到的**目数**即所有棋子对产生的**目数**之和。

现小 K 给了你一张游戏开始时的棋盘，请你帮他求出在这张棋盘上最多可能得到的**目数**。

## 说明/提示

### 样例 1 解释

对于第一组样例，可以选定顶点 $3$，然后将 $1$ 号点上的黑棋移动到顶点 $2$，将 $2$ 号点的黑棋移动到顶点 $3$，这样两颗棋子所在的顶点之间由一条边权为 $2$ 的边连接，产生的目数为 $2$。

### 子任务

对于所有测试数据，保证  $3 \leq n \leq 100$，$n-1 \leq m \leq \frac{n(n-1)}{2}$，$1 \leq k \leq n-1$，$0 \leq w_i \leq 10^5$。

![](https://cdn.luogu.com.cn/upload/image_hosting/5iu3ldkx.png)

## 样例 #1

### 输入

```
3 2 2
1 0
2 1
1 2 1
2 3 2
```

### 输出

```
2```

## 样例 #2

### 输入

```
4 4 3
1 1
2 1
3 0
1 2 1
2 3 1
3 4 1
4 1 3```

### 输出

```
3```

## 样例 #3

### 输入

```
见选手目录下的 alphago/alphago3.in 与 alphago/alphago3.ans。```

### 输出

```
见选手目录下的 alphago/alphago3.in 与 alphago/alphago3.ans。```

## 样例 #4

### 输入

```
见选手目录下的 alphago/alphago4.in 与 alphago/alphago4.ans。```

### 输出

```
见选手目录下的 alphago/alphago4.in 与 alphago/alphago4.ans。```

## 样例 #5

### 输入

```
见选手目录下的 alphago/alphago5.in 与 alphago/alphago5.ans。```

### 输出

```
见选手目录下的 alphago/alphago5.in 与 alphago/alphago5.ans。```

# 题解

## 作者：Alex_Wei (赞：11)

### *[P9542 [湖北省选模拟 2023] 棋圣 / alphago](https://www.luogu.com.cn/problem/P9542)

很牛的题目啊。

先考虑一棵树怎么做：操作不改变棋子任意两个棋子之间的距离的奇偶性将整棵树黑白染色后，只有所在位置颜色不同，且棋子本身颜色不同的棋子对可能产生贡献。设 $c_{i, j}$ 表示所在位置颜色为 $i$，棋子本身颜色为 $j$ 的棋子数量，那么答案有显然的上界：$(c_{0, 0} c_{1, 1} + c_{0, 1} c_{1, 0}) \max w$。

考虑何时能取到上界，这要求我们将所有所在位置颜色不同的棋子全部堆到同一个点上。可以这样理解操作：让棋子之间变得越来越密集，每次操作不增加棋子之间的距离。当所有棋子形成一个连通块时，接下来无论如何操作，所有棋子仍然是一个连通块。因此，考虑接下来一步操作，若存在某对棋子之间的距离减少了，那么操作点和这两颗棋子一定不在一条链上。这说明存在度数大于 $2$ 的点是可以取到上界的必要条件。

那么它充分吗？考虑某个度数大于 $2$ 的点的任意三棵子树内的任意叶子 $x, y, z$。第一步任意操作，然后重复操作 $x, y, z$。容易证明在足够多次操作后，任意一对棋子之间的距离不大于 $1$。因此，存在度数大于 $2$ 的点是答案可以直接取到上界的充要条件。

没有度数大于 $2$ 的点时，整张图是一条链，相邻两枚棋子之间的距离不增，非负，且奇偶性不变。满足条件的状态都是可达的，因为一次操作相当于将某对相邻棋子之间的距离减少 $2$，或者将所有棋子在链上平移。

设 $f_{i, l, r}$ 表示第 $i$ 个点有第 $[l, r]$ 枚棋子的最大权值。转移枚举下一个有棋子的位置 $j$，和新的右边界 $r'$。因为 $j - i$ 不大于第 $r$ 枚棋子和第 $r + 1$ 枚棋子之间的距离，所以 $i, r, j$ 的总数为 $\mathcal{O}(n ^ 2)$。时间复杂度 $\mathcal{O}(n ^ 4)$，常数较小。

注意到若两枚棋子距离为偶数，则它们之间不产生贡献，此时不需要记录 $l$。设 $d_i$ 表示是最大的 $j\geq i$ 满足第 $i$ 枚棋子与第 $[i + 1, j]$ 枚棋子的距离为偶数。如果第 $p$ 枚棋子和之后的棋子产生贡献，那么它所在的点一定放置了第 $[p, d_p]$ 枚棋子。从这个角度，考虑优化状态设计。设 $f_{i, type, p}$ 表示类型为 $type$ 的最大权值，其中：

- $type = 0$ 表示第 $i$ 个点放置第 $[l, p]$ 枚棋子，$p$ 及之前的棋子不会和之后的棋子产生贡献。此时左端点 $l$ 是不必要的。

- $type = 1$ 表示第 $i$ 个点放置第 $[p, d_p]$ 枚棋子。

对于 $type = 0$：

- 如果它转移到 $type' = 0$，那么枚举新的位置 $j'$ 以及 $p'$。
- 如果它转移到 $type' = 1$，那么枚举新的位置 $j'$，$p'$ 只能等于 $p + 1$。

对于 $type = 1$：新的位置 $j'$ 只能等于 $j + 1$，且需要根据实际含义计算产生的贡献。

- 如果它转移到 $type' = 0$，那么枚举 $p'$。
- 如果它转移到 $type' = 1$，那么 $p' = p + 1$。

时间复杂度 $\mathcal{O}(n ^ 3)$。

对于有度数大于 $2$ 的点的非链简单无向图：

- 如果图是二分图，那么和树的情况是类似的，所有距离为奇数的黑白棋子对产生最大边权的贡献。
- 如果图不是二分图，那么可以通过奇环改变任意棋子对的奇偶性：任选一棵生成树，将处于黑点的白棋通过奇环移动至白点，将处于白点的黑棋通过奇环移动至黑点，所有黑白棋子对产生最大边权的贡献。

最后考虑没有度数大于 $2$ 的点的非链简单无向图，即简单环：因为一个点有两个方向可以选择，所以情况和有度数大于 $2$ 的点是类似的。分成偶环和奇环讨论，用有度数大于 $2$ 的点的非链简单无向图做法即可。时间复杂度 $\mathcal{O}(n + m)$。

综上，我们将问题分成三种情况：链，非链二分图和非链非二分图。

总时间复杂度 $\mathcal{O}(n ^ 3)$。


```cpp
#include <bits/stdc++.h>
using namespace std;
using pii = pair<int, int>;

bool Mbe;
constexpr int N = 100 + 5;

int n, m, k, bipar;
int ch[N], col[N];
vector<pii> e[N];

void dfs(int id, int c) {
  col[id] = c, c ^= 1;
  for(pii _ : e[id]) {
    int it = _.first;
    if(col[it] == -1) dfs(it, c);
    else bipar &= col[it] == c;
  }
}

/*
namespace CHAIN {
  int f[N][N][N], id[N], w[N];
  struct chess {
    int pos, col;
  } c[N];
  int c0[N], c1[N];
  void solve() {
    int cur = 0;
    for(int i = 1; i <= n; i++) {
      if(e[i].size() == 1) cur = i;
    }
    int lst = -1, cnt = 0;
    while(1) {
      id[++cnt] = cur;
      bool found = 0;
      for(pii _ : e[cur]) {
        int it = _.first;
        if(it != lst) {
          w[cnt] = _.second;
          lst = cur, cur = it;
          found = 1;
          break;
        }
      }
      if(!found) break;
    }
    cnt = 0;
    for(int i = 1; i <= n; i++) {
      if(ch[id[i]] != -1) c[++cnt] = {i, ch[id[i]]};
    }
    for(int i = 1; i <= cnt; i++) {
      c0[i] = c0[i - 1] + (c[i].col == 0);
      c1[i] = c1[i - 1] + (c[i].col == 1);
    }
    memset(f, 0xcf, sizeof(f));
    f[0][0][0] = 0;
    for(int i = 0; i < n; i++) {
      for(int l = 0; l < cnt; l++) {
        for(int r = l; r < cnt; r++) {
          if(f[i][l][r] < 0) continue;
          int dis = c[r + 1].pos - c[r].pos, lim = r ? min(n, i + dis) : n;
          for(int j = i + (!i || (dis & 1) ? 1 : 2); j <= lim; j += (i ? 2 : 1)) {
            for(int nr = r + 1; nr <= cnt; nr++) {
              int val = f[i][l][r];
              if(j == i + 1 && r) {
                int coef = (c0[r] - c0[l - 1]) * (c1[nr] - c1[r]);
                coef += (c1[r] - c1[l - 1]) * (c0[nr] - c0[r]);
                val += coef * w[i];
              }
              f[j][r + 1][nr] = max(f[j][r + 1][nr], val);
              if(nr < cnt && (c[nr + 1].pos - c[nr].pos & 1)) break;
            }
          }
        }
      }
    }
    int ans = 0;
    for(int i = 1; i <= n; i++) {
      for(int l = 1; l <= cnt; l++) {
        ans = max(ans, f[i][l][cnt]);
      }
    }
    cout << ans << "\n";
  }
}
*/


namespace CHAIN {
  int f[N][2][N], id[N], w[N], nxt[N];
  struct chess {
    int pos, col;
  } c[N];
  int c0[N], c1[N];
  void solve() {
    int cur = 0;
    for(int i = 1; i <= n; i++) {
      if(e[i].size() == 1) cur = i;
    }
    int lst = -1, cnt = 0;
    while(1) {
      id[++cnt] = cur;
      bool found = 0;
      for(pii _ : e[cur]) {
        int it = _.first;
        if(it != lst) {
          w[cnt] = _.second;
          lst = cur, cur = it;
          found = 1;
          break;
        }
      }
      if(!found) break;
    }
    cnt = 0;
    for(int i = 1; i <= n; i++) {
      if(ch[id[i]] != -1) c[++cnt] = {i, ch[id[i]]};
    }
    for(int i = cnt; i; i--) {
      nxt[i] = i;
      if(i < cnt && (c[i + 1].pos - c[i].pos & 1 ^ 1)) nxt[i] = nxt[i + 1];
    }
    for(int i = 1; i <= cnt; i++) {
      c0[i] = c0[i - 1] + (c[i].col == 0);
      c1[i] = c1[i - 1] + (c[i].col == 1);
    }
    memset(f, 0xcf, sizeof(f));
    f[0][0][0] = 0;
    for(int i = 0; i < n; i++) {
      for(int tp : {0, 1}) {
        for(int p = 0; p < cnt; p++) {
          if(f[i][tp][p] < 0) continue;
          int dis = c[(tp ? nxt[p] : p) + 1].pos - c[tp ? nxt[p] : p].pos;
          int lim = i ? min(n, i + dis) : n;
          for(int j = i + (!i || (dis & 1) ? 1 : 2); j <= lim; j += (i ? 2 : 1)) {
            if(tp == 0) {
              // 0 -> 0
              for(int q = p + 1; q <= nxt[p + 1]; q++) {
                f[j][0][q] = max(f[j][0][q], f[i][tp][p]);
              }
              // 0 -> 1
              f[j][1][p + 1] = max(f[j][1][p + 1], f[i][tp][p]);
            }
            else if(j == i + 1 && nxt[p] < cnt) {
              // 1 -> 0
              int l = nxt[p] + 1, r = nxt[l];
              for(int q = l; q <= r; q++) {
                int coef = (c0[nxt[p]] - c0[p - 1]) * (c1[q] - c1[nxt[p]]);
                coef += (c1[nxt[p]] - c1[p - 1]) * (c0[q] - c0[nxt[p]]);
                f[j][0][q] = max(f[j][0][q], f[i][tp][p] + coef * w[i]);
              }
              // 1 -> 1
              int coef = (c0[nxt[p]] - c0[p - 1]) * (c1[r] - c1[l - 1]);
              coef += (c1[nxt[p]] - c1[p - 1]) * (c0[r] - c0[l - 1]);
              f[j][1][l] = max(f[j][1][l], f[i][tp][p] + coef * w[i]);
            }
          }
        }
      }
    }
    int ans = 0;
    for(int i = 1; i <= n; i++) ans = max(ans, f[i][0][cnt]);
    cout << ans << "\n";
  }
}

bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    FILE *IN = freopen("alphago.in", "r", stdin);
    FILE *OUT = freopen("alphago.out", "w", stdout);
  #endif
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

  cin >> n >> m >> k;
  memset(ch, -1, sizeof(ch));
  for(int i = 1; i <= k; i++) {
    int x, c;
    cin >> x >> c;
    ch[x] = c;
  }
  int maxw = 0;
  for(int i = 1; i <= m; i++) {
    int u, v, w;
    cin >> u >> v >> w;
    e[u].push_back({v, w});
    e[v].push_back({u, w});
    maxw = max(maxw, w);
  }

  bool chain = 0;
  for(int i = 1; i <= n; i++) chain |= e[i].size() == 1;
  for(int i = 1; i <= n; i++) chain &= e[i].size() <= 2;
  if(chain) CHAIN::solve(), exit(0);

  memset(col, -1, sizeof(col));
  bipar = 1, dfs(1, 0);
  if(bipar) {
    vector<vector<int>> c(2, vector<int>(2));
    for(int i = 1; i <= n; i++) {
      if(ch[i] != -1) c[ch[i]][col[i]]++;
    }
    cout << maxw * (c[0][0] * c[1][1] + c[0][1] * c[1][0]) << "\n";
  }
  else {
    vector<int> c(2);
    for(int i = 1; i <= n; i++) {
      if(ch[i] != -1) c[ch[i]]++;
    }
    cout << maxw * (c[0] * c[1]) << "\n";
  }

  cerr << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n";
  return 0;
}

/*
g++ alphago.cpp -o alphago -O2 -std=c++14 -DALEX_WEI
*/
```

---

## 作者：EternalAlexander (赞：10)


- 如果原图存在一棵生成树，其中有某个顶点的度数超过 $2$（也就是说，它不是一条链），那么：可以通过操作，使得所有棋子都在生成树中的任意一条边的两个端点上。并且，如果将树二分图染色，那么，（开始时）两种颜色的顶点上的棋子，最后分别位于这条边的各一个端点。
	
- 如果原树是二分图，并且不是一条链。设初始位于黑点的黑/白棋子数量分别为 $B_0$，$B_1$，初始位于白点的黑/白棋子数量分别为 $W_0$,$W_1$，那么答案是 $B_0 W_1 + B_1 W_0$ 乘以最大边权。
	
	可以证明这是二分图的答案上界。如果图不是一个环或者一条链，可以取出一棵不是链的生成树，通过上述方法构造得到这一上界。如果是一个环，可以验证也能取到这个上界。
	
- 如果原图是一条链，那么：操作后，相邻两个棋子距离 $\leq$ 一开始的距离，并且奇偶性不变。这可以 DP 计算答案。如：$f_{i,l,r}$ 表示链上第 $i$ 个点聚集了区间 $[l,r]$ 中的棋子的最大答案。
	
- 如果原图不是二分图，而且不是一个环：可以先任取一棵不是链的生成树，然后操作使得所有棋子都在某一条边的两个端点上。接下来操作使得所有棋子都在奇环上的某一条边的两个端点上，变成奇环的情况。
	
- 如果原图是一个奇环，答案上界是最大边权乘以黑白棋子个数的乘积。可以验证这个上界总可以构造出来。

	
	综上，根据链部分的实现方式，时间复杂度为 $O(n^4)$ 或 $O(n^3)$ ，都可以通过本题。

---

## 作者：Miraik (赞：9)

让我们从简单的特殊情况出发，比如图是一个环。

那这个时候每一步每个棋子移动的方向都是自由的。

如果这是个奇环，那容易发现任意节点都可以在任意位置聚在一起，因此答案就是 $cnt_0 \times cnt_1 \times maxw$，$maxw$ 为边权最大的边。

如果这是个偶环，我们对环奇偶染色，那容易发现奇偶性相同的任意节点都可以在奇偶性相同的任意位置聚在一起，因此答案就是 $(cnt_{0,0} \times cnt_{1,1} + cnt_{0,1} \times cnt_{1,0}) \times maxw$。

你发现有环的情况都能这么做，直接二分图染色判断有没有奇环就行了。

那没环呢？也就是一棵树的情况。

然后你发现如果有四个点 $a,b,c,d$，且存在 $(a,b)$，$(a,c)$，$(a,d)$ 边，那我任意操作 $b$ 的子树内的点都会使得一对在 $c,d$ 子树内的点的距离减少。进一步归纳，你会发现......这和偶环的情况还是一样：奇偶性相同的点都缩到一起了！继续用上面的做法就好。

那就只剩下一条链的情况了。

结果你发现它其实才是这题唯一的难点（

考虑合法的棋局长什么样：

- 排序后序列上相邻的棋子如果距离为偶数，可以直接并起来。

- 排序后序列上相邻的棋子距离不增。

考虑暴力 dp，设 $f_{i,l,r}$ 表示处理到链上第 $i$ 个位置，且序列上 $[l,r]$ 位置的棋子被并在这里的最大目数和。转移的话枚举下一段 $[r+1,r']$ 在第 $j$ 个位置，由于存在限制 $j-i \le x_{r+1}-x_r$，所以 $i,j,r'$ 的级别是 $O(n^2)$ 的，因此这个 dp 的复杂度是 $O(n^4)$，常数极小。

可以进一步优化到更优复杂度，但我摆了。

```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
using namespace std;
const int N=105;
const int M=10005;
const int inf=1000000005;
inline void chkmax(int &x,int y){ x=max(x,y); }
int n,m,K,x[N],c[N],deg[N],ru[M],rv[M],rw[M];
namespace subtask1{
	int flag,maxw,col[N],cnt[2][2]; vector<int>e[N];
	inline void getcol(int u){
		for(int v:e[u]){
			if(col[u]==col[v]) flag=0;
			else if(col[v]==-1) col[v]=col[u]^1,getcol(v);
		}
	}
	inline void solve(){
		for(int i=1;i<=m;i++){
			chkmax(maxw,rw[i]);
			e[ru[i]].emplace_back(rv[i]);
			e[rv[i]].emplace_back(ru[i]);
		}
		flag=1; for(int i=2;i<=n;i++) col[i]=-1; getcol(1);
		if(!flag){
			for(int i=1;i<=K;i++)
				cnt[c[i]][c[i]]++;
		}
		else{
			for(int i=1;i<=K;i++)
				cnt[c[i]][col[x[i]]]++;
		}
		cout<<maxw*(cnt[0][0]*cnt[1][1]+cnt[0][1]*cnt[1][0])<<'\n';
	}
}
namespace subtask2{
	int cur,val[N],id[N],f[N][N][N],ans; vector<pii>e[N];
	struct Go{
		int x,c;
		bool operator < (const Go &a){ return x<a.x; }
	}a[N];
	inline void solve(){
		for(int i=1;i<=m;i++){
			e[ru[i]].emplace_back(rv[i],rw[i]);
			e[rv[i]].emplace_back(ru[i],rw[i]);
		}
		for(int i=1;i<=n;i++) if(deg[i]==1) cur=i;
		for(int i=1;i<n;i++){
			id[cur]=i;
			if(!id[e[cur][0].first]) val[i+1]=e[cur][0].second,cur=e[cur][0].first;
			else val[i+1]=e[cur][1].second,cur=e[cur][1].first;
		}	id[cur]=n;
		for(int i=1;i<=K;i++)
			a[i]={id[x[i]],c[i]};
		sort(a+1,a+K+1); a[K+1].x=inf;
		for(int i=1;i<=n;i++)
			for(int l=1;l<=K;l++)
				for(int r=l;r<=K;r++)
					f[i][l][r]=(l==1?0:-inf);
		for(int i=1;i<=n;i++){
			for(int l=1;l<=K;l++)
				for(int r=l,x=0,y=0;r<=K;r++){
					if((a[r].x&1)!=(a[l].x&1)||f[i][l][r]==-inf) break;
					if(!a[r].c) x++; else y++;
					for(int j=i+1;j<=min(n,a[r+1].x-a[r].x+i);j++){
						if((a[r+1].x-j&1)!=(a[r].x-i&1)) continue;
						for(int rr=r+1,xx=0,yy=0;rr<=K;rr++){
							if((a[rr].x&1)!=(a[r+1].x&1)) break;
							if(!a[rr].c) xx++; else yy++;
							chkmax(f[j][r+1][rr],f[i][l][r]+(j==i+1)*(x*yy+y*xx)*val[j]);
						}
					}
				}
		}
		for(int i=1;i<=n;i++)
			for(int l=1;l<=K;l++)
				chkmax(ans,f[i][l][K]);
		cout<<ans<<'\n';
	}
}
int main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin>>n>>m>>K;
	for(int i=1;i<=K;i++) cin>>x[i]>>c[i];
	for(int i=1;i<=m;i++) cin>>ru[i]>>rv[i]>>rw[i],deg[ru[i]]++,deg[rv[i]]++;
	if(m>=n||*max_element(deg+1,deg+n+1)>2) subtask1::solve();
	else subtask2::solve();
	return 0;
}
```

---

## 作者：rizynvu (赞：5)

[我的博客](https://www.cnblogs.com/rizynvu/p/18278859)。

2023.08.19：修改了一处笔误。  
2024.07.01：修改了博客网址。

手玩发现对于一颗生成树，如果存在至少一个点的度数 $> 2$（即不为链），那么肯定能使得所有棋子都在一条边的两个端点上。  
因为有度数 $> 2$ 的点的存在，这里就可以合并与其相连的点的棋子。  

先考虑非链的情况的答案，记两部分棋子黑白棋子颜色分别为 $c(a/b)(0/1)$。  
由两部分棋子在一条边上考虑到二分图。  
若为二分图，则不管怎么走两部分棋子所在的颜色都是不同的，即两部分棋子最优情况也还是中间有一条边，答案为 $w_{\max}\times (c(a)(0)\times c(b)(1) + c(a)(1)\times c(b)(0))$。  
若不为二分图，则图上肯定存在奇环，可以利用这个奇环分割开黑白棋子并把黑白棋子分别凑在一起，答案为 $w_{\max}\times ((c(a)(0) + c(b)(0))\times (c(a)(1) + c(b)(1)))$。

再来考虑链的情况。  
手玩能发现最后棋子的位置需要满足 $3$ 点：  
1. 在链上相邻的两个点操作完的距离 $\le$ 两个点的初始距离，因为发现选取的空节点只存在两点之间或之外的情况，而距离变化分别为 $-2$ 和不变。
2. 在链上相邻的两个点不会在操作中调换顺序，证明与 1 相似。
3. 在链上相邻的两个点操作完的距离与两个点的初始距离模 $2$ 意义下同余，因为链也是个二分图。

考虑 DP，设 $f_{i, l, r}$ 为到链上第 $i$ 个点且这个点上有编号为 $[l, r]$ 的棋子的最大权值，不合法的值为 $-\inf$。  
记 $\operatorname{count}([l, r], [L, R])$ 为这 $2$ 个区间的棋子能产生的配对数，$\operatorname{dis}(x, y)$ 为这两个棋子在链上的距离。  
转移分为 $2$ 部分：
- 从 $i - 1$ 选的点与 $[l, r]$ 产生贡献，$f_{i, l, r} = \max\limits_{L = 1}^{l - 1} ([\operatorname{dis}(l - 1, l)\equiv 1\pmod 2]\times (f_{i - 1, L, l - 1} + \operatorname{count}([L, l - 1], [l, r])\times w(i - 1, i)))$，可以在枚举的时候维护 $\operatorname{count}$，单次 $O(n)$。
- 从前面的点转移过来，但是不产生贡献，$f_{i, l, r} = \max\limits_{j = i - \operatorname{dis(l, l - 1)}}^{i - 1}([i - j\equiv \operatorname{dis}(l - 1, l)\pmod 2]\times (\max\limits_{L = 1}^{l - 1} f_{j, L, l - 1}))$，但这样是 $O(n^2)$ 的。  
	发现对于每个 $j$ 求的就是右端点为 $l - 1$ 的最大值，可以预处理 $g_{i, r} = \max\limits_{l = 1}^r f_{i, l, r}$，转移式便为 $f_{i, l, r} = \max\limits_{j = i - \operatorname{dis(l, l - 1)}}^{i - 1}([i - j\equiv \operatorname{dis}(l - 1, l)\pmod 2]\times g_{j, l - 1})$，时间复杂度 $O(n)$。

时间复杂度 $O(n^4)$。

```cpp
#include<bits/stdc++.h>
const int N = 1e2 + 10;
int n, m, k;
std::vector<int> G[N];
int cx[N], cy[N];
int Gx[N * N], Gy[N * N], Gz[N * N];
int deg[N], deg_cnt[N];
int check_Case1() {
	for (int i = 1; i <= m; i++) {
		deg[Gx[i]]++, deg[Gy[i]]++;
	}
	for (int i = 1; i <= n; i++) {
		deg_cnt[deg[i]]++;
	}
	return deg_cnt[1] == 2 && deg_cnt[2] == n - 2;
}
int mcol[N];
void dfs(int u, int &flg) {
	for (auto v : G[u]) {
		if (mcol[v] == -1) {
			mcol[v] = mcol[u] ^ 1, dfs(v, flg);
		} else {
			flg &= mcol[u] != mcol[v];
		}
	}
}
int check_Case2() {
	for (int i = 1; i <= m; i++) {
		G[Gx[i]].push_back(Gy[i]), G[Gy[i]].push_back(Gx[i]);
	}
	memset(mcol, -1, sizeof(int) * (n + 1));
	int flg = 1;
	mcol[1] = 0, dfs(1, flg);
	return flg;
}
int cnt[2][2];
std::pair<int, int> c[N];
std::vector<std::pair<int, int> > Gc[N];
int dep[N], w[N];
int f[N][N][N], g[N][N];
int d[N], rd[N], ld[N];
int main() {
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= k; i++) {
		scanf("%d%d", &cx[i], &cy[i]);
	}
	for (int i = 1; i <= m; i++) {
		scanf("%d%d%d", &Gx[i], &Gy[i], &Gz[i]);
	}
	if (check_Case1()) {
		for (int i = 1; i <= m; i++) {
			Gc[Gx[i]].emplace_back(Gy[i], Gz[i]), Gc[Gy[i]].emplace_back(Gx[i], Gz[i]);
		}	
		int st = -1, ed = -1;
		for (int i = 1; i <= n; deg[i] == 1 && (st == -1 ? st = i : ed = i, 1), i++);
		for (int i = st, d = 1; d <= n; d++) {
			dep[i] = d;
			std::pair<int, int> v = dep[Gc[i][0].first] == 0 ? Gc[i][0] : Gc[i][1];
			i = v.first, w[d + 1] = v.second;
		}
		for (int i = 1; i <= k; i++) {
			c[i] = {cx[i], cy[i]};
		}
		std::sort(c + 1, c + k + 1, [](std::pair<int, int> a, std::pair<int, int> b) {
			return dep[a.first] < dep[b.first];
		});
		for (int i = 1; i < k; i++) {
			d[i] = dep[c[i + 1].first] - dep[c[i].first];
		}
		rd[k] = k;
		for (int i = k - 1; i; i--) {
			rd[i] = (d[i] & 1) ? i : rd[i + 1]; 
		}
		ld[1] = 1;
		for (int i = 2; i <= k; i++) {
			ld[i] = (d[i - 1] & 1) ? i : ld[i - 1];
		}
		memset(f, -0x3f, sizeof(f));
		memset(g, -0x3f, sizeof(g));
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= rd[1]; j++) {
				f[i][1][j] = 0, g[i][j] = 0;
			}
		}
		for (int i = 2; i <= n; i++) {
			for (int l = 2; l <= k; l++) {
				cnt[0][0] = cnt[1][0] = 0;
				int R = l - 1;
				for (int r = l; r <= rd[l]; r++) {
					cnt[c[r].second][0]++;
					if (d[R] & 1) {
						cnt[0][1] = cnt[1][1] = 0;
						for (int L = R; L >= ld[R]; L--) {
							cnt[c[L].second][1]++;
							f[i][l][r] = std::max(f[i][l][r], f[i - 1][L][R] + w[i] * (cnt[0][0] * cnt[1][1] + cnt[1][0] * cnt[0][1]));
						}
					}
					for (int j = i - d[R] > 0 ? i - d[R] : (((i - d[R]) & 1) ? 1 : 2); j < i; j += 2) {
						f[i][l][r] = std::max(f[i][l][r], g[j][R]);
					}
					g[i][r] = std::max(g[i][r], f[i][l][r]);
				}
			}
		}
		int ans = f[0][0][0];
		for (int i = 1; i <= n; i++) {
			for (int l = ld[k]; l <= k; l++) {
				ans = std::max(ans, f[i][l][k]);
			}
		}
		printf("%d\n", ans);
	} else if (check_Case2()) {
		for (int i = 1; i <= k; i++) {
			cnt[cy[i]][mcol[cx[i]]]++;
		}
		int mxz = 0;
		for (int i = 1; i <= m; mxz = std::max(mxz, Gz[i]), i++);
		printf("%d\n", mxz * (cnt[0][0] * cnt[1][1] + cnt[0][1] * cnt[1][0]));
	} else {
		for (int i = 1; i <= k; i++) {
			cnt[cy[i]][0]++;
		}
		int mxz = 0;
		for (int i = 1; i <= m; mxz = std::max(mxz, Gz[i]), i++);
		printf("%d\n", mxz * (cnt[0][0] * cnt[1][0]));
	}
	return 0;
}
```

---

## 作者：ykzzldz (赞：3)

根据部分分，先考虑特殊情况。

- 图是一个环：

  - 奇环：棋子可以随便移动，答案为黑色棋子数乘白色棋子数乘最大边权。

  - 偶环：对环进行奇偶染色，发现每个棋子都能走到与其奇偶性相同的结点上，于是最优策略一定是将棋子移向最大边权的两个端点。
 
  - 我们可以发现，若给定的图中有环，则可以将所有棋子通过操作都放到环上。这种情况我们在下面讨论。

- 图是一棵树：

  - 图不是一条链：那么图中一定有一个度数至少为三的点，令这个点为树的根。我们可以先经过一次操作，使得至少有一个叶子结点为空。操作这个结点，可以使根节点的其他子树中的棋子往根节点走，使这棵子树中的棋子往叶子结点走。容易发现，两个棋子间的奇偶性仍然不变，于是可以套用偶环的结论，对树进行奇偶染色，将棋子移向最大边权的两个端点。

  - 图是一条链：这里是本题最难的部分。一个状态是合法的，当且仅当两个棋子间的奇偶性不变且初始位置相邻的棋子距离不增。考虑 dp，设 $f_{i,l,r}$ 表示考虑到 $i$ 这个位置，$i$ 这个位置放了编号为 $[l,r]$ 之间的棋子所产生的最大答案。记 $num([l_1,r_1],[l_2,r_2])$ 表示两个区间的配对个数，$dis(x,y)$ 表示编号为 $x$ 和 $y$ 的棋子初始的距离，转移分为两种情况：

    1. 从 $i-1$ 转移过来，会产生贡献，$f_{i,l,r}=\max f_{i-1,l',l-1}+num([l,r],[l',l-1])\times w(i-1,i)$，需要保证 $dis(l-1,l)$ 为奇数，单次转移复杂度 $O(n)$。
    2. 从前面转移过来，不产生贡献，$f_{i,l,r}=\max_{j=i-dis(l-1,l)}^{i-1} f_{j,l',l-1}$，需要保证 $i-j$ 与 $dis(l-1,l)$ 的奇偶性相同。仔细分析一下，这个地方是均摊 $O(n)$ 的，总复杂度 $O(n^4)$，可以通过。

到这里已经获得了 $20$ 分，但是你会发现，这篇题解已经快结束了。

对于整个题目，我们先将链的情况特判出来。如果图中存在奇环，则可以任意改变两个棋子间的奇偶性，答案为黑色棋子数乘白色棋子数乘最大边权。对于其他情况（图中有偶环或是不为链的树），可以将所有棋子放在最大边权的两个端点，答案是好计算的。总复杂度为 $O(n^4)$。下面给出代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e4,M=110;
struct node{
	int x,c;
}a[N];
struct edge{
	int v,w;
};
vector<edge>e[N];
int n,m,k,jl[N],in[N],mxin,mxw,col[N],rt=1,dfn[N],id[N],cnt,fl,ok[M][M],sum[M][M][2],ans,f[M][M][M];
void dfs(int u){
	dfn[u]=++cnt;
	id[cnt]=u;
	for(int i=0;i<e[u].size();i++){
		int v=e[u][i].v;
		if(col[v]){
			if(col[u]==col[v])fl=1;
			continue;
		}
		col[v]=3-col[u];
		dfs(v);
	}
}
bool cmp(node a,node b){
	return dfn[a.x]<dfn[b.x];
}
signed main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		jl[i]=-1;
	}
	for(int i=1;i<=k;i++){
		cin>>a[i].x>>a[i].c;
		jl[a[i].x]=a[i].c;
	}
	for(int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		e[u].push_back({v,w});
		e[v].push_back({u,w});
		in[u]++,in[v]++;
		mxin=max(mxin,max(in[u],in[v]));
		mxw=max(mxw,w);
	}
	for(int i=2;i<=n;i++){
		if(in[i]<in[rt])rt=i;
	}
	col[rt]=1;
	dfs(rt);
	if(m==n-1&&mxin==2){
		sort(a+1,a+1+k,cmp);
		memset(f,128,sizeof f);
		for(int i=1;i<=k;i++){
			ok[i][i]=1;
			for(int j=i+1;j<=k;j++){
				if((dfn[a[j].x]-dfn[a[j-1].x])%2)break;
				ok[i][j]=1;
			}
		}
		for(int i=1;i<=k;i++){
			for(int j=i;j<=k;j++){
				sum[i][j][0]=sum[i][j-1][0];
				sum[i][j][1]=sum[i][j-1][1];
				sum[i][j][a[j].c]++;
			}
		}
		f[0][0][0]=0;
		for(int i=1;i<=n;i++){
			for(int l=1;l<=k;l++){
				int dis=dfn[a[l].x]-dfn[a[l-1].x];
				for(int r=l;r<=k;r++){
					if(!ok[l][r])break;
					if(l==1)f[i][l][r]=0;
					int w=0;
					for(int j=0;j<e[id[i]].size();j++){
						int v=e[id[i]][j].v;
						if(v==id[i-1])w=e[id[i]][j].w;
					}
					if(dis%2){
						for(int L=0;L<l;L++){
							f[i][l][r]=max(f[i][l][r],f[i-1][L][l-1]+(sum[L][l-1][0]*sum[l][r][1]+sum[L][l-1][1]*sum[l][r][0])*w);
						}
					}
					for(int j=max(1ll,i-dis);j<i;j++){
						if((i-j)%2!=dis%2)continue;
						for(int L=0;L<l;L++){
							f[i][l][r]=max(f[i][l][r],f[j][L][l-1]);
						}
					}
					if(r==k)ans=max(ans,f[i][l][r]);
				}
			}
		}
		cout<<ans;
	}
	else{
		if(!fl){
			int cnt0=0,cnt1=0,cnt2=0,cnt3=0;
			for(int i=1;i<=n;i++){
				if(col[i]==1){
					if(jl[i]==0)cnt0++;
					if(jl[i]==1)cnt1++;
				}
				else{
					if(jl[i]==0)cnt2++;
					if(jl[i]==1)cnt3++;
				}
			}
			cout<<mxw*(cnt0*cnt3+cnt1*cnt2);
		}
		else{
			int cnt0=0,cnt1=0;
			for(int i=1;i<=n;i++){
				if(jl[i]==0)cnt0++;
				if(jl[i]==1)cnt1++;
			}
			cout<<mxw*cnt0*cnt1;
		}
	}
	return 0;
}
```

---

## 作者：是青白呀 (赞：3)

首先由于棋子是可以重合的，所有我们希望他们尽量聚集在最大边权的边两端。根据部分分提示，依次考虑下面几种情况。

- 环。
  - 是奇环时，每个棋子都可以独立地走到任意位置去，答案为黑点数乘白点数，再乘最大边权。
  - 是偶环时，两两棋子之间的距离奇偶性不变。所以对环进行黑白染色，有任意点对同异色情况始终不变。在该限制下，所有棋子是可以任意移动的。于是答案为白点上黑子树乘黑点上白子数，加上白点上白子数乘黑点上黑子数，最后乘最大边权。这提示我们可以对原图尝试进行黑白染色。
  
- 树。树是二分图，所以理论上界只能达到偶环情况下的答案。同样考虑将棋子尽可能合并到一起。
  - 对于有三度点的树，考虑依次操作三个方向的叶子。由于每个方向的棋子都是向中心（三度点处）走两步，再退一步，最终可以合并的棋子一定会在三度点处合并。因此可以取到偶环的答案。
  - 对于一条链，显然不完全能合并成希望的样子。此时，一个合法的状态需要满足的条件是任意点之间距离不增，且奇偶性不变。考虑设 $dp_{i,l,r}$ 表示在第 $i$ 个位置放置编号在 $[l,r]$ 之间的棋子的最大值，每次转移枚举下一组棋子的放置位置 $j$。一个合法的转移需要满足如下几个要求：
     - 区间 $[l,r]$ 内的棋子可以被放到一起。这个过程中距离显然不增，因此只需要满足区间 $[l,r]$ 内的所有点原距离均为偶数即可。
     
     - $[l,r]$ 与之前所有点的距离都不减。由于距离不减是可以结合的，这里实际上只需要 $l$ 和 $l-1$ 的距离不减即可。
     
     - $[l,r]$ 与之前所有点的距离奇偶性都不变。奇偶性不变的性质也是可以结合的，因此只需要$l$ 和 $l-1$ 的距离奇偶性不变即可。
  
     在此限制下，你发现可行的 $j$ 需要满足 $j-i\leq pos_l-pos_{l-1}$，因此 $O(n^2)$ 个二元组 $(i,l)$ 对应的可行转移点 $j$ 共有 $O(n^2)$ 个，再加上另外两维的枚举复杂度，总转移复杂度可以做到 $O(n^4)$。这里跑得很快。
  
- 图。有了前面的经验，我们可以直接考虑分是否是二分图讨论。
  - 是二分图，则它一定存在一个含三度点的生成树，因此其答案与偶环（含三度点的树）一致。
  - 不是二分图，则可以先在三度点生成树上将所有点合并成偶环的状态，再借用奇环将所有黑点并起来、所有白点并起来，故最终答案与奇环一致，为黑点数乘白点数，再乘全局最大边权。

故对原图进行二分图染色，先特判链的情况跑 dp，然后根据是否是二分图来计算答案即可。复杂度瓶颈在链的部分。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) (x<<1)
#define rs(x) ((x<<1)|1)
#define mp make_pair
#define sec second
#define fir first
#define pii pair<int,int>
#define lowbit(i) i&-i
#define int long long
#define qingbai 666
using namespace std;
typedef long long ll;
const int N=105,M=6,S=(1<<15)+5,inf=(ll)1e18+7,mo=1e9+7;
const double eps=1e-8;
void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int n,m,k;
pii c[N];
vector<pii>e[N];
int vis[N],dfn[N],cnt[2][2],sit[N],cntp,stp=1,deg[N],nw[N],cntc[N][N][2];
bool bin=1;
int maxv=0;
void dfs(int x){
    dfn[x]=++cntp,nw[cntp]=x;
    for(auto j:e[x]){
        if(vis[j.fir]>=0){
            if(vis[j.fir]==vis[x])bin=0;
            continue;
        }
        vis[j.fir]=vis[x]^1;
        dfs(j.fir);
    }
}
bool cmpp(pii x,pii y){
    return dfn[x.fir]<dfn[y.fir];
}
bool leg[N][N];
int dp[N][N][N];
void solve1(){//link
    sort(c+1,c+k+1,cmpp);
    rep(i,1,k){
        leg[i][i]=1;
        rep(j,i+1,k){
            if((dfn[c[j].fir]-dfn[c[j-1].fir])&1)break;
            else leg[i][j]=1;
        }
    }
    rep(i,1,k){
        rep(j,i,k){
            cntc[i][j][0]=cntc[i][j-1][0],cntc[i][j][1]=cntc[i][j-1][1];
            if(sit[c[j].fir]>=0)cntc[i][j][sit[c[j].fir]]++;
        }
    }
    rep(i,0,n){
        rep(j,0,k){
            rep(l,0,k)
                dp[i][j][l]=-inf;
        }
    }
    dp[0][0][0]=0;
    int ans=0;
    rep(i,1,n){
        rep(l,1,k){
            int dis=abs(dfn[c[l].fir]-dfn[c[l-1].fir]);
            rep(r,l,k){
                if(!leg[l][r])break;
                if(l==1)dp[i][l][r]=max(dp[i][l][r],0ll);
                int nwv=0;
                for(auto j:e[nw[i]])
                    if(j.fir==nw[i-1])nwv=j.sec;
                rep(x,0,l-1){
                    if(dp[i-1][x][l-1]<0)continue;
                    if(!((dfn[c[l].fir]-dfn[c[l-1].fir])&1))break;
                    dp[i][l][r]=max(dp[i][l][r],dp[i-1][x][l-1]+(cntc[x][l-1][0]*cntc[l][r][1]+cntc[x][l-1][1]*cntc[l][r][0])*nwv);
                }
                repp(j,i-1,1){
                    if(i-j>dis)break;
                    if(((dfn[c[l].fir]-dfn[c[l-1].fir])&1)^((i-j)&1))continue;
                    rep(x,0,l-1)
                        dp[i][l][r]=max(dp[i][l][r],dp[j][x][l-1]);
                }
                if(r==k)ans=max(ans,dp[i][l][r]);
            }
        }
    }
    printf("%lld\n",ans);
}
void solve2(){//not link
    rep(i,1,n)
        if(sit[i]>=0)cnt[vis[i]][sit[i]]++;
    if(bin)printf("%lld\n",maxv*(cnt[1][0]*cnt[0][1]+cnt[0][0]*cnt[1][1]));
    else printf("%lld\n",maxv*(cnt[0][0]+cnt[1][0])*(cnt[1][1]+cnt[0][1]));
}
signed main(){
    read(n),read(m),read(k);
    rep(i,1,n)
        sit[i]=-1;
    rep(i,1,k)
        read(c[i].fir),read(c[i].sec),sit[c[i].fir]=c[i].sec;
    int maxdeg=0;
    rep(i,1,m){
        int x,y,w;
        read(x),read(y),read(w);
        e[x].push_back(mp(y,w)),e[y].push_back(mp(x,w));
        deg[x]++,deg[y]++;
        maxdeg=max({maxdeg,deg[x],deg[y]}),maxv=max(maxv,w);
    }
    rep(i,1,n)
        vis[i]=-1;
    rep(i,1,n)
        if(deg[i]<deg[stp])stp=i;
    vis[stp]=1,dfs(stp);
    if(m==n-1&&maxdeg==2)solve1();
    else solve2();
    return 0;
}
```

---

## 作者：cwfxlh (赞：1)

# [P9542](https://www.luogu.com.cn/problem/P9542)       

比较有意思的一个题。

看一下部分分，先想一下一个环该怎么做。发现环上因为必定有两个方向的简单路径，所以每一步相当于每个棋子任选一个方向走，考虑将棋子走到最大那条边的两端，最后答案简单计算即可。        

树的部分分有点困难，于是再思考一下环的这一档部分分有什么启发。             

对于普通的有环连通图，进行一系列操作之后，可以将所有棋子都合并到不多于两个点上，做法是简单的，将棋子都引导到环上，如果环被覆盖完了，任选一个空点，则环上可以合并空点连到环上的两侧的点的棋子，否则选环上的一个空点，即可任意操纵棋子走向合并。            

如果这个图不是二分图，所有棋子可以合并到一个点，否则按黑白染色分到两个相邻的点。接下来将棋子分到一条边的两个端点上，然后带着这两拨棋子走到最大的那条边上即可。二分图不需要分棋子，否则将黑棋子分一拨，白棋子分一拨。于是非树的问题就解决了。        

树上真的不能这样做吗？             

手玩一下发现可以使用大于二度的点来合并棋子。具体的，先将所有棋子合成连通块，这一部分是简单的，不断选有多个子树内有棋子的空点即可。        

然后随便找一个大于二度的点 $u$，将连通块引导到 $u$ 上，当 $u$ 的邻点至少有两个被覆盖的时候，向没有覆盖的那个方向引导（如果没有这个方向就随便找空点）。于是最后棋子被合并成了不多于两个点，可以套用上面的解法。           

剩下链的问题。         

直接考虑顺着 dp 了，令 $dp_{i,j,k}$ 表示点 $i$ 上包含了 $[j,k]$ 的棋子，枚举下一个位置和包含的棋子连续段。具体限制有位置不能太远，以及奇偶性要满足限制。乍一看是 $O(n^5)$ 的，但因为连续段之间的距离不能太远，所以是 $O(n^4)$ 的。           

~~丑陋的~~代码：        


```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 1000000000000000000ll
using namespace std;
int n,m,k,p[50003][2],e[50003][3],rd[50003],spv,col[50003],sum[5][5],mxv,k1,k2,k3,k4,k5,k6,k7,k8,k9,perm[50003],idx,val[50003],qz[50003],dp[203][203][203];
int stk[50003],tot,prewz[503][2],pre[503][2],ans;
vector<int>E[50003];
void dfs(int now,int mk){
    if((col[now]&mk)!=0)return;
    col[now]|=mk;
    for(auto i:E[now])dfs(i,3-mk);
    return;
}
void dfs2(int now,int p){
    perm[now]=++idx;
    for(auto i:E[now])if(i!=p)dfs2(i,now);
    return;
}
bool chk(int l,int r,int v){
    if(prewz[r][v^1]-prewz[l-1][v^1]!=0)return false;
    return true;
}
int calc(int l1,int r1,int l2,int r2){return (pre[r1][0]-pre[l1-1][0])*(pre[r2][1]-pre[l2-1][1])+(pre[r1][1]-pre[l1-1][1])*(pre[r2][0]-pre[l2-1][0]);}
signed main(){
    ios::sync_with_stdio(false);
    cin>>n>>m>>k;
    for(int i=1;i<=k;i++)cin>>p[i][0]>>p[i][1];
    for(int i=1;i<=m;i++){
        cin>>e[i][0]>>e[i][1]>>e[i][2];
        rd[e[i][0]]++;
        rd[e[i][1]]++;
        E[e[i][0]].emplace_back(e[i][1]);
        E[e[i][1]].emplace_back(e[i][0]);
    }
    for(int i=1;i<=n;i++)if(rd[i]>2)spv=1;
    for(int i=1;i<=n;i++)if(rd[i]==1)k1=i;
    if(k1==0)spv=1;
    if(spv){
        dfs(1,1);
        mxv=e[1][2];
        for(int i=1;i<=m;i++)mxv=max(mxv,e[i][2]);
        for(int i=1;i<=k;i++)sum[col[p[i][0]]][p[i][1]]++;
        if(col[1]==3)cout<<mxv*sum[3][0]*sum[3][1];
        else cout<<mxv*(sum[1][0]*sum[2][1]+sum[1][1]*sum[2][0]);
        return 0;
    }
    dfs2(k1,0);
    for(int i=1;i<=k;i++)p[i][0]=perm[p[i][0]];
    for(int i=1;i<=m;i++){
        e[i][0]=perm[e[i][0]];
        e[i][1]=perm[e[i][1]];
        if(e[i][0]>e[i][1])swap(e[i][0],e[i][1]);
        val[e[i][0]]=e[i][2];
    }
    for(int i=1;i<=k;i++)qz[p[i][0]]=p[i][1]+1;
    for(int i=1;i<=n;i++)if(qz[i])stk[++tot]=i;
    for(int i=0;i<=200;i++){
        for(int j=0;j<=200;j++){
            for(int u=0;u<=200;u++)dp[i][j][u]=-inf;
        }
    }
    dp[0][0][0]=0;
    for(int i=1;i<=tot;i++){
        prewz[i][0]=prewz[i-1][0]+(stk[i]%2==0);
        prewz[i][1]=prewz[i-1][1]+(stk[i]%2==1);
        pre[i][0]=pre[i-1][0]+(qz[stk[i]]==1);
        pre[i][1]=pre[i-1][1]+(qz[stk[i]]==2);
    }
    for(int i=0;i<n;i++){
        for(int j=0;j<tot;j++){
            for(int u=j;u<tot;u++){
                for(int o=u+1;o<=tot;o++){
                    for(int wz=i+1;wz<=n;wz++){
                        if(u!=0&&wz-i>stk[u+1]-stk[u])break;
                        if(u!=0&&(!chk(u+1,o,(stk[j]-i+wz)%2)))continue;
                        if((!chk(u+1,o,0))&&(!chk(u+1,o,1)))continue;
                        if(wz!=i+1)dp[wz][u+1][o]=max(dp[wz][u+1][o],dp[i][j][u]);
                        else dp[wz][u+1][o]=max(dp[wz][u+1][o],dp[i][j][u]+calc(j,u,u+1,o)*val[i]);
                    }
                }
            }
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=tot;j++)ans=max(ans,dp[i][j][tot]);
    }
    cout<<ans;
    return 0;
}
```

---


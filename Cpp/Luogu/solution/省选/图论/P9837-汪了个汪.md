# 汪了个汪

## 题目背景

你说得对，但是小 P 在 [[NOIP2022] 喵了个喵](https://www.luogu.com.cn/problem/P8866) 中没有输出操作次数，获得了 $0$ 分的好成绩。

## 题目描述

小 P 喜欢上了一款叫做《汪了个汪》的游戏。这个游戏有一个牌堆和一个金字塔形的棋盘，总共有 $3$ 关。具体地，如图所示，棋盘的边长为 $n$，第 $i$ 行有 $i$ 个格子，共 $\dfrac{n(n+1)}{2}$ 个格子。

牌堆中有 $1, 2 \dots n$ 的数字卡片 **各无穷多张**。你需要将这些数字卡片放到对应的棋盘格子中，每个格子恰好放一张数字卡片，要求满足棋盘的每一行的第一个元素 **互不相同**。

小 P 发现，这个游戏的难度会随着关卡编号而增加：

- 在第 $0$ 关中，你不必满足其他条件。
- 在第 $1$ 关中，你需要保证一行内相邻的两个数互不相同，且所有由任意一行内相邻两个数组成的 **无序二元组** 互不相同。
- 在第 $2$ 关中，你需要满足第 $1$ 关的限制，并且一行内的 **所有数** 必须互不相同。

例如，下面是 $n=5$ 时可以通过第 $2$ 关的摆放方式：

![](https://cdn.luogu.com.cn/upload/image_hosting/zdln26tg.png)

现在给定 $n$ 与关卡编号，请你帮小 P 找出一种合适的摆放方式来通过这一关。可以证明在游戏限制下一定存在一种过关方式。

## 说明/提示

**【说明与提示】**

本题下发校验器（`checker.cpp`）。将 `checker.cpp` 编译成可执行文件 `checker` 后，在当前目录执行 `checker woof.in woof.out woof.ans` 即可校验你的答案是否符合规范。其中 `woof.in` 可以替换为对应输入文件名称，`woof.out` 可以替换为对应输出文件名称，也即构造结果。`woof.ans` 可以为任意文件。

返回结果说明：

- `The numbers are not in the valid range.`：说明你的输出不满足每个数字都在 $1\sim n$ 的范围内。
- `The first column does not satisfice.`：说明你的输出不满足每行开头的数互不相同。
- `The pairs of numbers are not distinct.`：说明你的输出不满足所有由任意一行内相邻两个数组成的无序二元组互不相同。
- `The adjacent numbers are not distinct.`：说明当前关卡编号 $\ge1$ 且你的输出不满足关卡 $1$ 的条件。
- `The numbers in a row are not distinct.`：说明当前关卡编号 $\ge2$ 且你的输出不满足关卡 $2$ 的条件。
- `Well done.`：说明你的构造满足要求。

---

#### 【数据范围】

| 测试点编号 | $n \leq$ | $t =$ | 特殊性质 |
| :--------: | :------: | :---: | :------: |
| $1$ | $6$ | $0$ | 无 |
| $2$ | $6$ | $2$ | 无 |
| $3 \sim 4$ | $4000$ | $2$ | A |
| $5 \sim 7$ | $500$ | $1$ | 无 |
| $8 \sim 13$ | $500$ | $2$ | 无 |
| $14 \sim 16$ | $4000$ | $1$ | 无 |
| $17 \sim 20$ | $4000$ | $2$ | 无 |

+ 特殊性质 A：保证 $n + 1$ 或 $n + 2$ 为质数。

对于 $100 \%$ 的数据，保证 $1 \leq n \leq 4000$，$t \in \{0, 1, 2\}$。

## 样例 #1

### 输入

```
2 1```

### 输出

```
1
2 1```

## 样例 #2

### 输入

```
5 2```

### 输出

```
1
2 3
4 2 5
3 5 1 4
5 4 3 1 2```

# 题解

## 作者：樱雪喵 (赞：133)

感觉这个构造挺人类智慧，可能脑电波一下跟出题人对上就会了。  
不会基于严谨理论的做法，大致阐述一下猜到这个东西的过程吧。

首先，我们知道有 $\dfrac{n(n-1)}{2}$ 个横向相邻数对，$\dfrac{n(n-1)}{2}$ 个本质不同二元组。这两个数量是相等的，也就是说每种本质不同二元组在棋盘中恰好出现了一次。

那或许可以尝试把这些二元组进行分类，按照相同的类别来摆放。  
进一步瞎猜，发现：两个元素差为 $1$ 的有 $n-1$ 对，差为 $2$ 的有 $n-2$ 对，同理，差为 $n-1$ 的有 $1$ 对。我们把这些数对分成了大小分别为 $1,2,\dots,n-1$ 的组。  
然后你发现这和棋盘上每行的相邻棋子数正好对上了！  
但是没做完，因为 $(1,4),(2,5),(3,6),\dots$ 这堆东西显然没法放到一行里。再继续找能和这个分组形式对上的东西。

考虑转一下方向，棋盘每列能放下的二元组数量同样满足这个性质。  
也就是说，我们试图在第 $1$ 列放 $n-1$ 个差为 $1$ 的数对，第 $2$ 列放 $n-2$ 个差为 $2$ 的数对，以此类推。  
知道了大致方向，我们再考虑对于每一行的构造，设这一行有 $n$ 个数。我们要让其形如第一对差为 $1$，第二对差为 $2$，并始终在 $[1,n]$ 范围内，不难想到加减交替构造。  
设开头为 $x$，则这一行的值为：
$$
x\quad x+1\quad x-1\quad x+2\quad x-2\quad \dots\ 
$$

又因为已知每行开头的数不相同，我们依次枚举每个 $x$，重复构造上述序列直到超出范围。例如 $n=7$，可以写出：
$$
\begin{aligned}
&1\quad 2\\
&2\quad 3\quad 1\quad 4\\
&3\quad 4\quad 2\quad 5\quad 1\quad 6\\
&4\quad 5\quad 3\quad 6\quad 2\quad 7\quad 1\\
&5\quad 6\quad 4\quad 7\quad 3\\
&6\quad 7\quad 5\\
&7\\
\end{aligned}
$$
把它们按长度顺序排序，即为答案。
$$
\begin{aligned}
&7\\
&1\quad 2\\
&6\quad 7\quad 5\\
&2\quad 3\quad 1\quad 4\\
&5\quad 6\quad 4\quad 7\quad 3\\
&3\quad 4\quad 2\quad 5\quad 1\quad 6\\
&4\quad 5\quad 3\quad 6\quad 2\quad 7\quad 1\\
\end{aligned}
$$
时间复杂度 $O(n^2)$。

```cpp
const int N=4005;
int n,t,a[N][N];
int main()
{
    n=read(),t=read();
    for(int i=1;i<=n;i++,cout<<endl)
    {
        int st=(i&1)?(2*n-i+1)/2:(i>>1);
        for(int j=1,len=1;j<=i;j++,len++)
        {
            cout<<st<<" ";
            if(j&1) st+=len; else st-=len;
        }
    }
    return 0;
}
```

---

## 作者：Iniaugoty (赞：21)

~~上午打的线下赛，差点切了，但是不会划分完全图，就没搞出来qwq~~。下午看到官方题解，了解了一个 trick。神犇学长 @qhj0906 给出了证明，巨。

感觉如果会这个 trick 的话正解很显而易见吧，感觉在 CF div.2 C D 左右，紫似乎虚高？

***

### $t = 0$

几乎没有限制，保证第一列不相同的情况下瞎打就行。

### 特殊性质 A：$n + 1$ 或 $n +2$ 为质数

很奇怪的一档分。目前最成熟的想法是：$n \le 4000$ 范围内的质数不会很多，同理 $n$ 不会有很多取值，考虑打表。如果哪位神犇会了其他做法，麻烦评论或者私信给我讲一下，Orz。

### $ t = 1$

注意到 $[1, n]$ 中无序数对只有 $\dfrac {n (n - 1)}{2}$ 个，而题中要求的相邻数对也有 $\dfrac {n (n - 1)}{2}$ 个，两者应该是一一对应的。

考虑建一个完全无向图，问题就转化成了将这个图划分成 $n$ 条长度为 $0, 1, 2, \cdots, n - 1$ 路径（一条路径上的结点顺次连起来就成为了一行上的数）。在 $t = 1$ 的限制下，一条路径可以经过重复结点，所以不用考虑行内的限制问题。

钦定第 $i$ 行路径的起点为 $i$，然后把每条路径都跑出来。具体地，在一个结点上时，贪心地找出终点编号最大的、没经过的边，走过去。注意是找尽量大的。~~我也不知道为什么这么搞是对的~~。

这个做法是机房某位同学的，经过他的对拍，$n$ 为偶数时这个做法是对的。奇数时，建一个虚点 $0$，与其他所有点连边，把图节点数转化成偶数即可。

### $t = 2$

继承上一部分的思想，建图。这里有一个行内不出现重复数字的限制，即一条路径上不能重复经过某个结点，也即每条路径都是个链。

先考虑 $n$ 为偶数的情况，稍简单一些。

在小学二年级我们学习过，$1 + 2 + 3 + \cdots + 100 = (1 + 100) + (2 + 99) + (3 + 98) + \cdots + (50 + 51) = \dfrac {101 \times 100} {2}$。类比这个分组的思想，可以得到 $0 + 1 + 2 + \cdots + (n - 1) = (n - 1) \times \dfrac {n} {2}$。试着将图划分成 $\dfrac {n} {2}$ 条长度为 $n - 1$ 的链，第 $i$ 条链的起点和终点为 $i$ 和 $i + \dfrac {n} {2}$，将这条链再划分成起点 $i$ 长度 $i - 1$ 和起点 $i + \dfrac {n} {2}$ 长度 $n - i$ 的两条链。这样可以不重不漏地将图划分。

然后就是怎么将图划分成 $\dfrac {n} {2}$ 条长度为 $n - 1$ 的链的问题。这里有一个 trick，我闻所未闻的 “zig-zag pattern”（之字形划分？）。枚举链的起点 $s \in [1, \dfrac {n} {2}]$，并选取 $s \to s - 1 \to s + 1 \to s - 2 \to \cdots \to s 
\pm \dfrac {n} {2}$ 这样的一条链。其中可能出现结点编号越界的情况，遇到 $0$ 就变为 $n$，遇到 $n + 1$ 就变为 $1$ 即可。

考虑这样做为什么满足条件。一条边的两个端点，如果编号同奇偶，一定可以表示为 $s - k$ 和 $s + k$，否则可以表示为 $s + k$ 和 $s - k - 1$。容易发现这样对应的 $s, k$ 是唯一的，所以一条边最多会被划到一条链中。又因为每条链有 $n - 1$ 条边，$\dfrac {n} {2}$ 条链，一共 $\dfrac {n (n - 1)} {2}$ 条边，刚好是完全图的边数。所以这样的划分是不重不漏的。

对于 $n$ 为奇数的情况，试着添加一个虚点 $0$ 向每个点连边，转化为 $n$ 为偶数的情况。运用上述的划分方式，容易发现分出来的每条链都经过 $0$，那就以 $0$ 为边界将每条链都分为两部分。这样就解决了 $n$ 为奇数的划分问题。

***

实现中不需要建图，非常简洁优美，甚至比 T1 还短，就是感觉有点抽象。

```cpp
#include <bits/stdc++.h>

#define F(i, a, b) for(int i = a; i <= (b); ++i)
#define dF(i, a, b) for(int i = a; i >= (b); --i)

using namespace std;
typedef long long LL;
typedef unsigned long long ull;
const int N = 4e3 + 5;

int n, t;
vector<int> ans[N];

int main() {
	freopen("woof.in", "r", stdin);
	freopen("woof.out", "w", stdout);
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> t;
	if (n & 1) {
		int m = n + 1;
		F(i, 1, m / 2)
			for (int j = 1, k = 1; j <= m; ++j, k = -k)
				ans[i * 2 - 1].push_back(((i + j / 2 * k) % m + m) % m);
		F(i, 1, n / 2)
			ans[n - i * 2 + 1] = ans[i * 2 - 1],
			reverse(ans[n - i * 2 + 1].begin(), ans[n - i * 2 + 1].end());
	} else {
		F(i, 1, n / 2)
			for (int j = 1, k = 1; j <= n; ++j, k = -k)
				ans[i].push_back(((i + j / 2 * k - 1) % n + n) % n + 1);
		F(i, n / 2 + 1, n)
			ans[i] = ans[n - i + 1],
			reverse(ans[i].begin(), ans[i].end());
	}
	F(i, 1, n) {
		F(j, 0, i - 1)
			cout << ans[i][j] << " ";
		cout << "\n";
	}
	return 0;
}
```

---

## 作者：Register_int (赞：15)

验题人垃圾做法，大量借鉴了出题人题解。

我们往所有行前加一个 $0$ 节点，问题便转化为：给定一个 $n+1$ 个点的完全图，要求选出 $n$ 条链，使得每条链的长度为 $1,2,\cdots,n$ 且从 $0$ 连出的 $n$ 条边都属于不同的链。下文为方便讨论，将所有点的编号 $+1$。

$n$ 为偶数时方案一定形如 $1\leadsto2,1\leadsto3,\cdots,1\leadsto n$。于是我们可以简单构造奇数时的情况：再往里面加一个点 $n+1$，将所有的链尾扩展到 $n+1$, 再加上 $1 \rarr n+1$ 这条边，我们就得到了 $n+1$ 时的方案。

所以我们只需要构造 $n$ 为偶数时的情况即可。考虑递归构造，在 $n$ 的基础上构造 $n+2$ 时的方案。不妨设点 $i$ 为长度为 $i-1$ 的链的链尾，这时我们往里面加入两个点 $A,B$。

一个粗略的想法是这样的：

$$\begin{aligned}&1\rarr B\\&1\rarr A\rarr n\\&1\leadsto n\rarr B\rarr A\\&1\leadsto2\rarr A\rarr 3\\&1\leadsto3\rarr B\rarr 2\\&\vdots\end{aligned}$$

![](https://cdn.luogu.com.cn/upload/image_hosting/8cwuminr.png)

也就是说我们利用多出来的两个点，将原来的每条路径的长度增加 $2$，并构造新的长为 $1$ 和 $2$ 的路径。

这个构造方案有一个很大的问题，就是可能有 $3$ 在 $1\leadsto2$ 出现过这种情况，所以直接这样构造并不成立。（但是能做 $t=1$，时间复杂度 $O(n^2)$）

所以我们需要把中间的操作改一下，使得在 $1\leadsto k\rarr A/B\rarr u$ 的时候 $u$ 不在 $1\leadsto k$ 中。我们就是要对每个 $k$ 找到这样的 $u$，找到一个合理的匹配方案 $k\rarr u$。

为了方便理解我们的目标，再画一张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/c8yo7jbb.png)

上图就表示了其中一种匹配方式。注意 $1$ 也参与了匹配。

具体地，匹配方案为 $1\rarr4,2\rarr3,3\rarr5,4\rarr2,5\rarr6$，匹配链为 $1\rarr4\rarr2\rarr3\rarr5\rarr6$。

对于每个点 $i$，我们求出不在 $1\leadsto i$ 中的所有点构成的集合 $S_i$。显然 $|S_i|=n-i$。

显然要按集合大小从小到大匹配。所以我们从 $n-1$ 开始匹配，每次对于当前点 $i$ 找出来一个还没用过的 $u_i$，然后匹配 $i\rarr u_i$。

因为 $|S_i|=n-i$，匹配到 $i$ 时剩余点数 $t\geq |S_i|-(n-i-1)=1$， 一定存在还没用过的 $u_i$。

然而这个方法有一点小问题，就是可能会出现奇环。具体地，如果我们匹配了 $u\rarr v\rarr w\rarr u$ 这样的奇环，那么是不能通过 $A, B$ 完成匹配的。

![](https://cdn.luogu.com.cn/upload/image_hosting/nzqmskag.png)

但是实际上问题不大。不仅可以避免奇环，进一步地，我们总是能避免出现环！下面是证明。

首先需要发现，当前匹配后可能成环的，最多只有一个点。这是因为要成环，需要有一条匹配链 $u_1\rarr u_2\rarr\cdots u_k\rarr i$，而因为是匹配（每个点只有一个出度和最多一个入度），这样的链是唯一的。那么可能匹配成环的也只有 $u_1$ 这一个点。

（下面的图的有向边表示匹配关系）
![](https://cdn.luogu.com.cn/upload/image_hosting/g66rfsl1.png)

第二条性质是，可供当前点选择的点，除去会连成环的，还有至少一个。
这是因为上面 $u_k\rarr i$ 这个匹配使用了 $i$ 这个点，而当前点不出现在自己的 $S$ 集合中。这样剩下的点数 $t\geq |S_i|-((n-i-1)-1)=2$，这条性质就是正确的。

这样我们在匹配的时候维护连通性，保证一定不会出现环即可。容易发现这样构造出的匹配链一定形如 $1\rarr u_1\rarr\cdots\rarr u_k\rarr n$，因为 $1$ 没有入度，$n$ 没有出度。

得到合法匹配之后，我们直接从 $1$ 开始沿匹配链构造，再加上 $1\rarr B,n\rarr B\rarr A$ 两条链，就成功得到 $n+2$ 时的构造了！

因为要遍历 $S_i$，总时间复杂度 $O(n^3)$，考虑优化。

容易发现，当 $n$ 为 $p-1$，其中 $p$ 为质数时，我们存在一个十分简单的构造方法：

$$
\begin{aligned}
&1\rarr(1+1)\bmod n+1\rarr(1+2)\bmod n+1\leadsto(1+c_1)\bmod n+1\\
&1\rarr(1+2)\bmod n+1\rarr(1+4)\bmod n+1\leadsto(1+2c_2)\bmod n+1\\
&\vdots\\
&1\rarr(1+(n-1))\bmod n+1\rarr(1+2(n-1))\bmod n+1\leadsto(1+(n-1)c_{n-1})\bmod n+1\\
\end{aligned}
$$

其中 $c_i$ 为最小的满足 $1+i(c_i+1)\bmod n+1=0$ 的正整数。这是符合要求的，因为链尾与逆元对应，所以互不相等。并且不同的链上两点间距不同，可以保证每条边只选一次。所以递归时碰到这种 $n$ 直接构造即可，时间复杂度 $O(n^2V)$，其中 $V$ 是 $n$ 以内最大的素数间距。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 4e3 + 10;

inline 
bool isp(int n) {
	if (~n & 1) return n == 2;
	for (int i = 3; i <= n / i; i += 2) if (n % i == 0) return 0;
	return 1;
}

int fa[MAXN];

int find(int k) {
	return k == fa[k] ? k : fa[k] = find(fa[k]);
}

vector<int> c[MAXN];

int p[MAXN], suf[MAXN], t[MAXN], nxt[MAXN];

bool vis[MAXN], ban[MAXN];

inline 
void cons_p(int n) {
	c[0].push_back(1), *suf = 1; 
	for (int i = 1, k; i < n; i++) {
		k = 0;
		for (int j = 1; j; j = (j + i) % (n + 1), k++) c[i].push_back(j);
		p[k - 1] = i, suf[k - 1] = n + 1 - i;
	}
}

void solve(int n) {
	if (n == 2) {
		p[1] = 1, suf[0] = 1, suf[1] = 2;
		c[0].push_back(1), c[1].push_back(1), c[1].push_back(2);
		return ;
	}
	if (isp(n + 1)) return cons_p(n);
	solve(n -= 2);
	for (int i = 1; i <= n; i++) fa[i] = i, vis[i] = 0;
	for (int i = n - 2, u; ~i; i--) {
		u = suf[i];
		for (int j = 1; j <= n; j++) ban[j] = 0;
		for (int v : c[p[i]]) ban[v] = 1;
		for (int v = 1; v <= n; v++) {
			if (vis[v] || ban[v] || find(u) == find(v)) continue;
			fa[find(u)] = find(v), nxt[u] = v, vis[v] = 1; break;
		}
	}
	for (int j = 1, u = 1; j < n; j++, u = nxt[u]) {
		for (int i = 0; i < n - 1; i++) {
			if (u != suf[i]) continue;
			c[p[i]].push_back(n + 2 - (j & 1)), c[p[i]].push_back(nxt[u]);
			t[i + 2] = nxt[u]; break;
		}
	}
	suf[n + 1] = n + 1, c[p[n - 1]].push_back(n + 2), c[p[n - 1]].push_back(n + 1);
	for (int i = n; ~i; i--) p[i + 2] = p[i]; *p = n, p[1] = n + 1;
	for (int i = 2; i <= n; i++) suf[i] = t[i]; *suf = 1, suf[1] = n + 2;
	c[n].push_back(1), c[n + 1].push_back(1), c[n + 1].push_back(n + 2);
}

int n, ans[MAXN][MAXN];

int main() {
	scanf("%d%*d", &n), n++;
	if (n & 1) {
		solve(n - 1);
		for (int i = 0; i < n - 1; i++) c[i].push_back(n);
		for (int i = n - 1; i; i--) p[i] = p[i - 1];
	} else solve(n);
	for (int i = 1; i < n; i++) {
		for (int x : c[p[i]]) if (x > 1) printf("%d ", x - 1); puts("");
	}
}
```

---

## 作者：cmk666 (赞：11)

给一个不太一样的构造方法。

通过手玩或者 dfs 可以得到 $n$ 较小时的解，然后人类智慧找找规律。

先来考虑偶数，以下是 $n=2,4,6$ 的其中一组解：
```
1       1           1
2 1     2 4         2 4
        3 1 4       3 1 5
        4 3 2 1     4 6 2 5
                    5 3 6 1 4
                    6 5 4 3 2 1
```
容易发现都是对称的，找找砍掉一半变成等腰梯形后的规律：
```
1       1           1
2       2 4         2 4
        3 1         3 1 5
        4           4 6 2
                    5 3
                    6
```
人类智慧可以发现，每一个 $n$ 的梯形都由 $n-2$ 的梯形外加两个斜行得到，并且除了最右边一列，下面添加的数都是这个数上方两个数 $+2$。至于最右边一列，两个数分别在 $n-1,n$ 和 $2,1$ 之间循环，判一下奇偶性就行。

可以感性理解一下这个东西是合法的：每个数都和奇偶性相同的其它所有数左右相邻，和奇偶性不同的所有数上下相邻，于是翻转之后刚好和奇偶性不同的所有数左右相邻，不会出现重复的情况。

考虑奇数，尝试从 $n-1$ 的梯形拓展而来，例如 $n=5$，首先把上面梯形抄下来，并加一条 $n=5$ 的斜线：
```
1
2 4
3 1 5
4 5
5
```
然后剩下一半肯定还用这个 pattern 填，但是直接填就寄了，因为和 $n$ 接触的数必然有重复。考虑很经典的奇偶交换的 trick，把 $1$ 变 $2$，$2$ 变 $1$，$3$ 变 $4$，$4$ 变 $3$ 等交换得到：
```
2
1 3
4 2
3
```
可以说明，奇偶交换后，原梯形仍然保持其每个数都和奇偶性相同的其它所有数左右相邻，和奇偶性不同的所有数上下相邻的性质。于是可以把这玩意翻折到下面去，即：
```
1
2 4
3 1 5
4 5 2 3
5 3 4 1 2
```
这样和 $n$ 接触的数就两两不同了，符合条件。

于是就做完了，代码非常好写。

---

## 作者：EnofTaiPeople (赞：10)

在 OI 中被 Ad-hoc 随机区分应当优先找自身的原因。

反正我也可能是因为 T3 做了很久才没时间做 T2。

不过运气不好就会被区分下来了！

考虑 $n=6$ 的情况，在第一列放置 $1\ 2\ 3\ 4\ 5\ 6$。

因为这是构造题，我们尽量让自己的构造有规律。

我们可以在第二列放置第一列所有数 $+1$ 的值，这样恰好有 $5$ 个数：
```
1 2
2 3
3 4
4 5
5 6
6 (7)
```

如果在第三列放置第二列 $+2$ 的数，那么会出现以下情况：
```
1 2 4
2 3 5
3 4 6
4 5 (1)
5 6 (2)
6
```
发现有部分溢出了，而这样再往后可能导致同行存在相同值！

所以改成 $-2$ 就行了，以此类推，可以奇数列增加，偶数列减少，最终方案：
```
1 2 (0)
2 3 1 4 (0)
3 4 2 5 1 6
4 5 3 6 2 (7)
5 6 4 (7)
6 (7)
```

容易发现这种方案在任何情况均适用，于是就做完了，复杂度 $O(n^2)$，代码很好写：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4005;
int n,K,p[N];
vector<int>h[N];
int main(){
    ios::sync_with_stdio(false);
    int i,j,k,l,r,x,y,z;
    cin>>n>>K;
    for(i=1;i<=n;++i)h[i]={i};
    for(k=1;k<n;++k)
        if(k&1){
            for(i=1;i<=n;++i)
                if(h[i].size()==k&&h[i][k-1]+k<=n)
                    h[i].push_back(h[i][k-1]+k);
        }else{
            for(i=1;i<=n;++i)
                if(h[i].size()==k&&h[i][k-1]-k>=1)
                    h[i].push_back(h[i][k-1]-k);
        }
    for(x=1;x<=n;++x)p[h[x].size()]=x;
    for(i=1;i<=n;++i)
        for(l=0,x=p[i];l<i;++l)
            printf("%d%c",h[x][l]," \n"[l==i-1]);
    return 0;
}
```
你要问这是怎么想到的，我只想说，如果这种题能够有根据地想到就不会被称为随机区分了。

喵了个喵至少是能够顺着把做法推出来的。

---

## 作者：Little_Cart (赞：10)

### 思路

考虑当 $n$ 为奇数时：

当 $n=5$ 时，

首先我们设第 $i$ 行第一列为 $i$。（可以保证一定有一组解）

然后我们考虑将 $1$ 和 $n$ 抵消掉，也就是让 $1$ 与 $n$ 和其余的每个数都接触一遍，比如按如下构造。

```
1
2 5
3 5 4
4 1 3
5 1 2
```

此时我们发现，$4, 3, 2$ 互相都没有接触过，可以按 $n=3$ 的解去代入去做。

但是我们发现 $n=7$ 在递归求解时，第 $6$ 行存在了两个 $6$，于是我们考虑从前 $\frac{n-1}{2}$ 个赋值成 $n$，后 $\frac{n-1}{2}$ 个赋值成 $1$ 改为 $n$ 和 $1$ 交替赋值，然后这个问题就被解决了（证明过程过于冗长，也相对好证，所以我们给读者留做一个练习，此处不做证明。）

$n=5$ 的部分构造：

```
1
2 5
3 1 4
4 5 3
5 1 2
```

这个时候我们发现 $n$ 为奇数被解决了。

那么 $n$ 为偶数呢？

我们发现当 $n$ 为奇数时，对于所有的 $1 \le i \le n$，$a_{i, i}$ 均不同（易知），所以我们考虑在 $n$ 为偶数时先把所有的 $1 \le i \le n$ 的 $a_{i, i}$ 赋值为 $1$，接下来就可以按照奇数的方法去赋值了。

$n=6$ 的完整构造：

```
1
2 1
3 6 1
4 2 5 1
5 6 4 3 1
6 2 3 5 4 1
```

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4024;
int a[N][N],n,t,mp[2][N],tmp;
void dfs(int dep,int len){
	int cur,cse[2];
	cur=0;
	cse[0]=a[dep][len];
	cse[1]=a[n][len];
	for(int i=dep+1;i<=n;i++){
		cur^=1;
		a[i][len+1]=cse[cur];
	}
	for(int i=dep+2;i<=n;i++){
		a[i][len+2]=a[n+dep+1-i][len];
	}
	if(dep+2==n) return;
	dfs(dep+2,len+2);
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	freopen("woof.in","r",stdin);
	freopen("woof.out","w",stdout);
	cin>>n>>t;
	if(n==1){
		cout<<1;
	}
	else if(n<=6){
		if(n==2){
			cout<<"1\n2 1";
		}
		if(n==3){
			cout<<"1\n2 3\n3 1 2";
		}
		if(n==4){
			cout<<"1\n2 4\n3 1 4\n4 3 2 1";
		}
		if(n==5){
			cout<<"1\n2 5\n3 5 4\n4 1 3 2\n5 1 2 4 3";
		}
		if(n==6){
			cout<<"1\n2 4\n3 6 2\n4 1 5 2\n5 3 1 6 4\n6 5 4 3 2 1";
		}
	}	
	else{
		for(int i=1;i<=n;i++){
			a[i][1]=i;
		}
		if(!(n&1)){
			for(int i=1;i<=n;i++){
				a[i][i]=1;
			}
			dfs(2,1);
		}
		else{
			dfs(1,1);
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=i;j++){
				cout<<a[i][j]<<" ";
			}
			cout<<"\n";
		}
	}
}

```

---

## 作者：Ocean_Fish (赞：9)

很喜欢的一道题 ~~（因为赛时切了）。~~ 为她写一篇题解吧。

## 首先分析一些性质：

第 $i$ 行会有 $i-1$ 对无序二元组，所以答案中会有 $\frac{n\times (n-1)}{2}$ 对二元组。

考虑每个数可以与 $n-1$ 个数组队，因为无序，所以我们最多能给出的无序二元组也只有 $\frac{n\times (n-1)}{2}$ 对。

所以每个数的所有配对都会用完，每个数会配对 $n-1$ 次。

### 现在我们先单独考虑奇数，奇数有一些很好的性质。

#### 一：奇数答案每一行的最后一个数字各不相同

这是因为对于每一行中不在开头和末尾的位置，会与前后两个数匹配，而在开头和末尾只会匹配一次。

因为每一行开头的数字各不相同，所以每个数用掉一次匹配，还需要匹配 $n-1-1=n-2$ 次，$n-2$ 为奇数。

如果只这个数字只出现在中间，每次用掉 $2$ 次匹配，永远会剩下奇数次匹配，所以每个数必然会有一次出现在行末。

一共 $n$ 行，$n$ 个数字都要出现，所以各不相同。

#### 二：每个数字出现次数为 $\frac{n+1}{2}$ 次。

要匹配 $n-1$ 次，开头一次，末尾一次，中间 $\frac{n-3}{2}$ 次，加起来 $\frac{n+1}{2}$ 次。

~~不过好像没什么卵用。手玩的时候大概可以加速拟出方案~~

## 现在我们可以开始手玩了。

构造题大多是有规律的，我们只需要找规律就行了。

怎么找规律？~~一直手玩就行了~~

### 仍然先考虑奇数做法

题面给的图片非常精致，用一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/lq5fjo1o.png)

我们当然希望规律尽可能的明显，比如第一列递增。

注意到决定答案的是数字的相对位置关系，我们换一下位置不会怎么样的。

于是有了一组新的解（交换 $3,4$ 的位置）：

![](https://cdn.luogu.com.cn/upload/image_hosting/my05htg1.png)

但是还是不够特殊啊！于是你一直玩啊玩啊，发现了一组极为特殊的解：

![](https://cdn.luogu.com.cn/upload/image_hosting/flkvjzux.png)

性质一：蓝色线条所在列只出现了两个数。

性质二：红色三角形框住的部分其实是子问题的解。

这就很棒啊！我们可以一直将大小为 $n$ 的问题改为 大小为 $n-2$ 的子问题，一直处理就可以了。

当然前提是我们能有一种构造方案使得蓝色线条所在列的两个数刚好做完所有的匹配。

很巧的是，这组解给了我们启发，发现第三列（蓝色右边一列）是递减的，蓝色的一列是以 $x,y,x,y\cdots$ 的规律出现的。

而第三列的递减，刚好与第一列的递增形成对应。

这很好的满足了第二列的匹配，且让子问题的答案有了原答案的性质：第一列递增/递减。

于是打个表验证规律：

![](https://cdn.luogu.com.cn/upload/image_hosting/0mn3e08r.png)

非常好啊！全部拍上了！至于第二列为什么是 $9,1,9,1\ \cdots$ 而不是 $1,9,1,9\ \cdots$，因为会出现一行两个 $9$ 的情况，我难以解释。

### 奇数已经解决，考虑偶数

你发现这规律完全对偶数情况无效啊！每个数字的出现次数都不确定！

难道重新找规律？好吧，试一下。$n=4$ 时发现如下的解：

![](https://cdn.luogu.com.cn/upload/image_hosting/f3dbfxaa.png)

因为奇数最后一列的数字各不相同，所以如果我们将偶数的最后一列全部赋为 $n$，就满足了所有 $n$ 的匹配，且转化成了奇数的情况。

非常智慧，写完了。

## 代码：

```cpp
#include<iostream>
#define N 4010
#define rep(i,l,r) for(int i=l;i<=r;i++)
using namespace std;
int n,t,a[N][N];
void solve(int tp){
	int tot1=0,tot2=0; n-=tp;
	rep(i,1,n){
		if(i&1){
			tot1++;
			if(tot1&1) rep(j,i,n) a[j][i]=tot1+j-i;
			else rep(j,i,n) a[j][i]=n-tot1+1+i-j;
		}else{
			a[i][i]=++tot2;
			if(tot2&1) a[i][i]=n-tot2+1;
			rep(j,i+1,n) a[j][i]=n-a[j-1][i]+1;
		}
	}
	if(tp){
		rep(i,0,n){
			rep(j,1,i) cout<<a[i][j]<<" ";
			cout<<n+1<<'\n';
		}
	}else{
		rep(i,1,n){
			rep(j,1,i) cout<<a[i][j]<<" ";
			cout<<'\n';
		}
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin>>n>>t;
	solve((n&1)^1);
	return 0;
}
```

写题解好累啊，但是完结撒花！

---

## 作者：YxYe (赞：9)

# P9837 汪了个汪

这是一道可以找规律的喵喵构造题（[传送门](https://www.luogu.com.cn/problem/P9837)）

[博客食用效果更佳](https://www.luogu.com.cn/blog/YxYe/solution-p9837)

## Con

赛时看着样例找规律 + 类似数独的手玩过了。

## Pre

我会看图观察样例！

```
1
2 3
4 2 5
3 5 1 4
5 4 3 1 2
```

看最左列：1/2；4/3；5

好像有规律？（在后面做 $n$ 为偶数时找规律有用）

然而看左数第二/三列，貌似没特别明显的规律。

看最右列：1/3/5；4/2

看右数第二列：2/2；1/1

好像有规律？？（本文介绍的主要规律）

—————————以下图片可能令聪明的你提前知道规律，想自己思考的读者们请跳过分割线—————————

为了找规律，我以样例照葫芦画瓢，完成了本蒟蒻的赛时草稿图：

![](https://cdn.luogu.com.cn/upload/image_hosting/nxv2vj3w.png)

此图上面两个是 $n$ 为奇数时的 $n=7/9$，下面是 $n$ 为偶数时的 $n=6/4$。

—————————————我是分割线—————————————

这里给出一些有一些填数的必要条件：

1. 第一列所有数不同。
2. 每一行的所有数不同。
3. 相邻的二元组匹配不重，那么我们可以推出每个数最多存在 $n-1$ 个匹配，而整个金字塔就有 $n\times(n-1)$ 个匹配，所以我们需要让每个数都和其它数匹配成二元组。

建议思考时从找一个数的匹配入手，利用条件 3 和条件 1/2 相结合来填。

### Sol

 _关于上面那张图是如何画出来的_ 

#### $n$ 为奇数部分

以 $n=9$ （右上角那张图）的情况为例：可以发现存在规律从最右列往左下角的四个一循环。

如右四列：

1. (1/3/5/7/9)；(8/6/4/2) **先奇数等差再反向偶数等差**
2. (2/1)；(2/1)；(2/1)；(2/1) **偶奇交替**
3. (4/6/8)；(9/7/5/3) **先偶数等差再反向奇数等差**
4. (3/4)；(3/4)；(3/4) **奇偶交替**

**然而在我画出这张图之前我根据样例的思考：**

- 我们依照样例的操作，因为从右开始列举已经有一些规律的苗头，所以我们从右开始依照类似的操作画。然后第二列先依照样例 2/2/2...1/1/1...

- 然后第三列为了有规律，刚好是第一列操作反过来。对照数字 2 的二元组匹配发现不错。同理，第四列也是第二列的操作反过来。

关于为啥我改成了奇偶交替，这是因为我一开始像数独那样手玩时模拟的是奇偶交替的，后来发现二者并不会对答案造成影响，可以互换。

也就是说，你也可以这样画图：

```
1
2 3
4 2 5
3 6 2 7
5 3 7 1 6
6 7 4 5 1 4
7 5 6 4 3 1 2
```

和右上角那张我画的是等价的。

#### $n$ 为偶数部分

和奇数差不多，但是我们发现，假如先填最左和最右列，那么如果按照样例这样显然是不可行的，因为再填的数一定会和两边的数组成二元组产生两个贡献，最后这个数就一定有偶数个二元组，显然在 $n$ 为偶数时一个数的二元组匹配应该是奇数。

所以我们稍微修改一下最右列为**先奇数等差再反向奇数等差**。

这样我们类似的偶数部分规律就是：

- 1/3/5；5/3/1 **先奇数等差再反向奇数等差**
- 2/1；2/1；2/1；2/1 **偶奇交替**
- 4/6；6/4 **先偶数等差再反向偶数等差**
- 3/4；3/4；3/4 **奇偶交替**

## Code

具体实现就是分 $n$ 的奇/偶两类，然后依次填充从右往左每一列。

码分奇丑勿喷

```cpp
//#pragma GCC optimize(2)
//#pragma GCC optimize(3)
//#pragma GCC optimize("Ofast")
//#pragma GCC optimize("inline")
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define db double
#define fo(i,a,b) for(int i=(a);i<=(b);i++)
#define fp(i,a,b) for(int i=(a);i<(b);i++)
#define de(i,a,b) for(int i=(a);i>=(b);i--)
#define fs(i,u) for(int i=head[u];i;i=nxt[i])
#define pii pair<int, int>
#define pdd pair<db,db>
#define pb push_back
#define fir first
#define sec second
#define ls (now<<1)
#define rs (now<<1|1)
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
using namespace std;
inline ll rd(){
	ll x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
const int maxn=4004;
const ll mod=11451419198102353;
int n,m,a[maxn][maxn];
void jioufanzhuan(int x,int y,int s){
	int now=s;
	while(now<=n){
		a[x][y]=now;
		x++;y++;now+=2;
	}
	now=n-(s&1);
	while(now>=s-(s%2==0)){
		a[x][y]=now;
		x++;y++;now-=2;
	}
}
void lianggezhuan(int x,int y,int p,int q){
	while(x<=n){
		a[x][y]=p;
		x++;y++;
		a[x][y]=q;
		x++;y++;
	}
}
void tongfanzhuan(int x,int y,int s){
	int now=s;
	while(now<=n){
		a[x][y]=now;
		x++;y++;now+=2;
	}
	now-=2;
	while(now>=s){
		a[x][y]=now;
		x++;y++;now-=2;
	}
}
void erdangezhuan(int x,int y,int p,int q){
	while(x<=n){
		a[x][y]=p;
		x++;y++;
		a[x][y]=q;
		x++;y++;
	}
	a[x][y]=p;
}
void print(){
	fo(i,1,n){
		fo(j,1,i){
			printf("%d ",a[i][j]);
		}puts("");
	}
}
int main(){
	freopen("woof.in","r",stdin);
	freopen("woof.out","w",stdout);
	n=rd();m=rd();
	if(n&1){
		for(int i=1;i<=n;i+=2){
			jioufanzhuan(i,1,i+(i%4==3));
			lianggezhuan(i+1,1,i+(i%4==1),i+(i%4==3));
		}
		a[n][1]=n;
		print();
	}else{
		for(int i=1;i<=n;i+=2){
			tongfanzhuan(i,1,i+(i%4==3));
			erdangezhuan(i+1,1,i+(i%4==1),i+(i%4==3));
		}
		print();
	}
	return 0;
}
```

完结撒花 * ★,°*:.☆(￣▽￣)/$:* .°★ * 觉得不错就点个赞吧❤

---

## 作者：Qian_xscc (赞：7)

# P9837 汪了个汪

[题目传送门](https://www.luogu.com.cn/problem/P9837)

讨厌构造题。去年死磕喵了个喵痛失一等。

构造真的分人。

## 思路

先说 $n$ 为奇数。

![](https://cdn.luogu.com.cn/upload/image_hosting/vubgiydd.png)

下文中“对称数”指一对数 $(i,j)$，在 $(1,2),(3,4),\dots,(n-2,n-1)$ 之中。

如图所示，红线为对称轴全部填 $n$，第一列从小到大排序，然后对称得到最后一行，最后黄线蓝线上两数交替填涂对称数即可。

感性理解一下为什么正确。 $\dfrac{n(n-1)}{2}$ 个横向相邻二元组互不相同，只能每个数都与其他所有数横向相邻 $1$ 次。

红线上 $n$ 与其他所有数恰好横向相邻 $1$ 次显而易见；蓝线黄线上，考虑每一个数放进一个 $2\times 2$、含 $2$ 对对称数、不含 $n$ 的小矩阵里，两对对称数分别为 $(x,y),(z,w)$，假设 $x$ 与 $z,w$ 分别横向、纵向相邻，则对称后 $y$ 与 $z,w$ 分别横向、纵向相邻，$x$ 便与 $w$ 横向相邻。同时每一对对称数都会在最后一行横向相邻。由此得证正确性。

至于 $n$ 为偶数，在上图中能看出 $n$ 为奇数时最右上的一排包含了小于等于 $n$ 的所有数，所以该情况只需要转化为 $n-1$ 的情况，然后在最头上和每一行最后加上一个 $n$ 即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/fjhjtzc2.png)

## 代码

```cpp
#include <iostream>

using namespace std;

int x[4010][4010];

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	int n,id;
	cin>>n>>id;
	if(n%2==0) id=1,n--;
	else id=0;
	for(int i=1;i<=n;i++){
		if(i%2==1){
			for(int j=1;j<=i-j+1;j++){
				x[i-j+1][j]=i+(i==n?0:j%2==0);
			}
		}
		else{
			for(int j=1;i+j-1<=n;j++){
				x[i+j-1][j]=i-(j%2==0); 
			}
		}
	}
	for(int i=3;i<=n;i++){
		if(i%2==1){
			for(int j=1;i+j-1<=n-j+1;j++){
				x[n-j+1][i+j-1]=n-i+2-(j%2==0);
			}
		}
	}
	if(id) cout<<n+1<<" \n";
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++) cout<<x[i][j]<<" ";
		if(id) cout<<n+1<<" \n";
		else cout<<"\n";
	}
	return 0;
}
```

---

## 作者：DengDuck (赞：7)

这题的正解吧，比较人类智慧，第一点就是要求第一列的数字互不相同，考虑直接第 $i$ 行的第一个数字是 $i$ 即可。

我们考虑所有的数对，其差分类之后，差为 $1$ 的数对有 $n-1$ 个，差为 $2$ 的数对有 $n-2$ 个，如此类推。

然后我们发现，这个东西可以和两个东西对应，我们利用相邻两项的差的绝对值表示：

- 第一种，第 $i$ 行差为 $ i,i,i,\cdots$，原理是第 $i$ 行有 $i-1$ 个数对，差 $i$ 的数对也有 $i-1$ 个。
- 第二种，每行第 $i$ 列和 第 $i+1$ 列差为 $ i$，原理是第 $i$ 列与第 $i-1$ 列之间也有 $i-1$ 个数对。

第一种不现实，如果只是不断 $+i$ 那么显然不够长，如果是 $-i$ 和 $+i$ 都有那一定有重复的数对。

那我们考虑构造第二种数列，那么显然其实每一行的差为 $1,2,3,4,5,\cdots$，如果是 $x,x+1,x+3,x+5$ 那肯定不行，因为不够长，所以一定是 $x,x+1,x-1,x+2,x-2$ 这种，然后如果某一项取值不在 $[1,n]$ 中你就弹掉就可以了，经代码检验这样够长，就是说你对于 $[1,n]$ 的开头跑完恰好生成长度为 $[1,n]$ 的长度的数列，数学证法不会。

然后你就直接跑，然后排序数列就行了。

我的做法和樱雪喵一样，但是实现就直接弄了，大概比较好懂 ~~（和长）~~，希望可以帮到大家。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define LF long double
#define pLL pair<LL,LL>
#define pb push_back
//#define fir first
//#define sec second
using namespace std;
//const LL inf;
const LL N=4005;
//const LL M;
//const LL mod;
//const LF eps;
//const LL P;
LL n,k;
vector<LL>v[N];
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		LL k=1;
		v[i].pb(i);
		while(i+k<=n)
		{
			v[i].push_back(i+k);
			if(k>=i)break;
			v[i].push_back(i-k);
			k++;
		}
	}
	sort(v+1,v+n+1,[](vector<LL>a,vector<LL>b){return a.size()<b.size();});
	for(int i=1;i<=n;i++)
	{
		for(LL j:v[i])cout<<j<<' ';
		cout<<endl;
	}
	return 0;
}
//RP++
```

---

## 作者：JiaY19 (赞：6)

什么神秘区分题。

### 思路

考虑我们需要用一种尽量通俗的思路进行构造。

首先对于第一列，我们填上 $1-n$ 的所有数。

观察点对的要求相当于我们把所有的点对不重不漏的填在所有的位置。

那么我们可以把点对分为 $n-1$ 类。

定一点对的距离是两个数的差的绝对值，第 $i$ 类就是距离为 $i$ 的点对。

考虑第一类有 $n-1$ 个，第二类有 $n-2$ 个……

容易想到把第一类一次放在第二列，第二类放在第三列。

再考虑如何不重不漏的放入。

发现假如我们在第二列填入 $2-n$，即：

```
1 2
2 3
3 4
4 5
5 6
6
```

此时值域往右移了。

那么我们希望在第三列将值域往左移。

例如：

```
1 2
2 3 1
3 4 2
4 5 3
5 6 4
6
```

这样，就又移回来了。

这样不断放下去，很容易证明是对的。

### Code

考场代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define x first
#define y second
#define mp(x, y) make_pair(x, y)
#define fro(i, x, y) for(int i = (x);i <= (y);i++)
#define pre(i, x, y) for(int i = (x);i >= (y);i--)
#define dbg cerr << "Line " << __LINE__ << ": "
#define EVAL(x) #x " = " << (x)

typedef int64_t i64;
typedef uint32_t u32;
typedef uint64_t u64;
typedef __int128_t i128;
typedef __uint128_t u128;
typedef pair<int, int> PII;

bool ed;

const int N = 1000010;
const int mod = 998244353;

int n, m, id[N];
vector<int> to[N];

const int I = 1e6; char s[I];
template<typename T> inline void put(T a)
{
	int tp = 0; if(a < 0) cout.rdbuf()->sputc('-'), a = -a;
	if(!a) return cout.rdbuf()->sputc('0'), void();
	while(a) s[++tp] = a % 10 + 48 , a /= 10;
	while(tp) cout.rdbuf()->sputc(s[tp--]);
}
inline void put(const char *a) { while(*a) { cout.rdbuf()->sputc(*(a++)); } }
template<typename T, typename ...Args> inline void put(T x, Args ...args) { put(x), put(args...); }

inline bool cmp(int x, int y)
{
	return to[x].size() < to[y].size();
}

bool st;

signed main()
{
	// freopen("woof.in", "r", stdin);
	// freopen("woof.out", "w", stdout);
	ios::sync_with_stdio(0), cin.tie(0);
	double Mib = fabs((&ed-&st)/1048576.), Lim = 1024;
	assert(Mib<=Lim), cerr << " Memory: " << Mib << "\n";
	cin >> n >> m;
	int l = 2, r = n, op = 1;
	fro(i, 1, n) to[i].push_back(n - i + 1);
	while(l <= r)
	{
		fro(i, l, r)
			to[i].push_back(to[i].back() + op);
		if(op > 0) r--, op++;
		if(op < 0) l++, op--;
		op *= -1;
	}
	iota(id + 1, id + n + 1, 1);
	sort(id + 1, id + n + 1, cmp);
	fro(i, 1, n)
	{
		for(auto j : to[id[i]])
			put(j, " ");
		put("\n");
	}
	return 0;
}
```

---

## 作者：lilong (赞：6)

蒟蒻太菜了，看不懂图论的做法，就只好找规律了。

分析题目，可以得到一些信息：$n$ 个不同的数最多能组成 $\dfrac{n(n-1)}{2}$ 个不相同的无序二元组，而一个 $n \times n $ 的下三角形同行相邻的数对数量为 $\dfrac{n(n-1)}{2}$，因此可以确定每个无序二元组**必须恰好用一次**。

观察二元组的差。显然，差为 $1$ 的二元组有 $n-1$ 个，差为 $2$ 的无序二元组有 $n-2$ 个……以此类推。于是，我们可以大胆猜想，将**差相同**的无序二元组放在**同一行或相邻的两列**上，这样可能可以构造出合法的答案。

模拟一下，不难发现，横着放会存在一个问题：例如 $n=5$，第 $2$ 行要放差为 $4$ 的两个数对，显然放不下 $4$ 个不相同的数，因此这样的方法不可行。

接下来考虑竖着摆放。第 $1$ 列填 $1,2,\cdots,n$，第 $2$ 列填前一个数加 $1$（可以填 $n-1$ 个，若超出 $n$ 则该行填完），以此类推。但**不能一直加**，否则该行就无法填满。证明十分简单，此处不详解。

反向思考，既然**差不变**，那么我们可以**加减交替操作**，这样在确保符合要求的同时尽可能地多填数，从而保证该方案是一定可行的。

总体思路大致如上，注意输出前要先计算好每行的长度，再按行的长度从小到大地输出每一行。

具体细节实现详见代码：

```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int n,TT,len[100001],nw;

int main()
{
	cin >> n >> TT;
	for( int i = 1 ; i <= n ; i ++ )
	{
		nw = i;
		for( int j = 1 ; nw >= 1 && nw <= n ; j ++ )
		{
			if( j & 1 ) nw += j;
			else nw -= j;
			len[i] ++;
		}
	}
	for( int i = 1 ; i <= n ; i ++ )
	{
		for( int j = 1 ; j <= n ; j ++ )
			if( len[j] == i )
			{
				nw = j;
				for( int k = 1 ; nw >= 1 && nw <= n ; k ++ )//确保在 1 到 n 的范围内
				{
					cout << nw << ' ';
					if( k & 1 ) nw += k;
					else nw -= k;
				}
				cout << endl;
				break;
			}
	}
	return 0;
}
```


---

## 作者：快斗游鹿 (赞：6)

很有趣的构造题。赛后想了好久才会。

直接看 $t=2$。观察到无序二元组数只有 $\dfrac{n(n-1)}{2}$ 种，而棋盘中相邻格子对数也只有 $\dfrac{n(n-1)}{2}$ 对，说明这 $\dfrac{n(n-1)}{2}$ 对无序二元组都不重不漏地出现在了棋盘中。

因为给了每行第一个数不相同限制，一个比较直接的想法是按第 $i$ 行以 $i$ 为开头填。但我没想出来。观察每行相邻格子对数，是 $1,2,3\dots n-1$。可以发现，这些数字与相邻两数差为 $1,2,3\dots n-1$ 的数字对数是一样的！这给我们提供了一个新的思路，按差构造。

但是这样在只看行时也很难完成构造。所以想到和列扯上关系。可以在第 $i+1$ 行到第 $n$ 行都填入 $1$ 个差为 $i$ 的数对，既能满足条件，看起来又比较好构造。咋构造呢？考虑以数 $x$ 打头，那么可以采用 $x,x+1,x+1-2,x+1-2+3,\dots$ 的形式构造，这样从左往右数第 $i$ 对数差值就为 $i$，满足我们想要的条件。再考虑到开头提到的以什么数打头的问题，可以发现，奇数位置从 $n$ 开始逐渐往下填，偶数位置从 $1$ 开始逐渐往上填，就能成功地构造出一组方案。

```
#include<bits/stdc++.h>
using namespace std;
int n,t;
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
int main(){
	n=read();t=read();
	for(int i=1;i<=n;i++){
		int st;
		if(i%2==1)st=(2*n-i+1)/2;
		else st=i/2;
		int len=1;
		for(int j=1;j<=i;j++){
			cout<<st<<" ";
			if(j%2==1)st+=len;
			else st-=len;
			len++;
		}
		putchar('\n');
	}
	return 0;
}

```


---

## 作者：Pink_Cut_Tree (赞：5)

# P9837 汪了个汪 题解

挺逆天一个题，赛后似乎想出了正解。

### 思路

每一行的第一个数必须不一样。对于每一行的第一个数，下一个数可以安排一个与之相邻的数（如第一个数是 $x$，第二个是 $x+1$）；而这个数之后的每次出现，必须不能放在第一个（显而易见的），且与其差的绝对值大于等于 $2$ 的数在一起，于是我想到了如下办法：

### 解析

我们先手搓几组数据看一看（这里规定 $t=2$）。

$n=1$：

```
1
```

$n=2$：

```
2
1 2
```

$n=3$：

```
3
1 2
2 3 1
```

$n=4$：

```
4
1 2
3 4 2
2 3 1 4
```

$n=5$：

```
5
1 2
4 5 3
2 3 1 4
3 4 2 5 1
```

总结一下上面的三角们：

对于第一列：发现第一个数总是 $n$，然后每隔一个数递减 $1$；第二个数总是 $1$，每隔一个数递增 $1$。

对于每一行，设第一个数为 $k$，则这一行的每一个数是 $k+1,k-1,k+2,k-2 \cdots$ 于是不难写出代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,start;
int main(){
	cout.tie(0);
	cin>>n>>t;
	for(int i=1;i<=n;i++){ 
		if(i%2==1){
			start=n-i/2;
		}
		else{
			start=i/2;
		}
		cout<<start<<" ";
		for(int j=1;j<i;j++){
			if(j%2==1){
				cout<<start+j/2+1<<" ";
			}
			else{
				cout<<start-j/2<<" ";
			}
		}
		cout<<"\n";
	}
return 0;
}
```

---

## 作者：Drind (赞：4)

### 题目解析

这题要求我们构造一个边长为 $n$ 的数字三角形，满足相邻两个数组成的无序数对只出现一次，并且每行开头数字不同，每行数字不同，只包含 1 到 $n$ 的数字。

我们定义 vis 数组为无序数对是否出现。

我们先看看这个 vis 数组。是一个倒三角很美丽。

我们发现一个合法的构造方案会填满整个 vis 数组。而我们每行相邻的两个数对都有一个数重复，也就是每行的任意两个相邻数对在 vis 数组上要吗在同一行，要吗在同一列。

既然这样，我们就给他黏在一起，变成一条折线。

我们采取这样的填法。

```
xxxxx
3xxxx
31xxx
112xx
1224x

```

我们观察性质，发现原图中每一行都在一条斜线上，也就是两个不相交数对和相同，举个栗子，这个图中 1 的那行的数字就是 `1 5 2 4 3`，$1+5=2+4$，而数字 2 的那行就是 `2 5 3 4`，$2+5=3+4$.

随便找一下每行和的规律即可。

但是有一个问题就是当 $n$ 为偶数时不满足每列第一个都不一样的性质，那就把每行反过来即可。

代码很短。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4e3+10;

int a[N][N]; 
int vis[N][N];

inline void fake_main(){
	int n,k; cin>>n>>k;
	for(int i=1;i<=n;i+=2){//我们把两行并在一起考虑，因为我们填满 vis 数组时是在右边放一条斜线，上面放一条斜线的。
		int tmp=n-i+1;
		for(int j=1;j<=n-i+1;j+=2){//第一条斜线。
			a[n-i+1][j]=tmp-(j+1)/2+1;
			a[n-i+1][j+1]=(n+2-i)-a[n-i+1][j];
		}
		tmp=i+1;
		for(int j=1;j<n-i+1;j+=2){//第二条斜线。
			a[n-i][j]=tmp+(j+1)/2-1;
			a[n-i][j+1]=(n+1+i)-a[n-i][j];
		}
	}
	
	if(n%2)
		for(int i=1;i<=n;i++){
			for(int j=1;j<=i;j++) cout<<a[i][j]<<" ";
			cout<<"\n";
		}
	else{
		for(int i=1;i<=n;i++){
			for(int j=i;j>=1;j--) cout<<a[i][j]<<" ";
			cout<<"\n";
		}
	}
}

signed main(){
	ios::sync_with_stdio(false);
	int t; t=1;
	while(t--) fake_main();
}

```

---

## 作者：Missa (赞：4)

和 Jryno1 赛时独立想到了同一个做法，感觉比现在两篇官方题解都更可能被想到一些。

所有行列的编号取 `0-index`，列从左往右，行从上到下。

观察样例。

![](https://cdn.luogu.com.cn/upload/image_hosting/zdln26tg.png)

仔细看那个 `2211`，$2$ 的两侧有 $3,4,5$，$1$ 左右侧有 $2,3,4,5$。再看左下角那个 `34`，$4$ 的左右有 $3$ 和 $5$，$3$ 的左右有 $5$。

为了与后面的说明相符合，把它写成

```
1
3 2 
5 2 4
4 1 5 3
2 1 3 4 5
```

的样子。

我们尝试逐列扩展，每次扩展两列。具体说，我们在第 $2i+1$ 列（列取 `0-index`）放 $2i+1$ 和 $2i+2$，使得加上之前放下的数字，所有包含 $2i+1$ 和 $2i+2$ 的数对都出现。

注意到对于 $x < 2i+1$，$(x, 2i+1)$ 已经出现。因此，实际上需要新出现 $2n-4i-3$ 个数对。

第 $x$ 列有 $n-x$ 个数字，左右两列加起来有 $2n-4i-2$ 个数对，注意到左边那一行最上面那一个数字不能与这一行形成数对，因此，这三列能组成所有我们需要的数对。

考虑构造。

经过大量手玩（赛时将近 2h，写搜索可能会快一些），我们构造出了一个 $n=7$ 的情况。

```
1 
3 2 
5 1 4 
7 2 6 3 
6 1 7 4 5 
4 2 5 3 7 6 
2 1 3 4 6 5 7
```

仔细观察它，偶数列是一段奇数拼一段偶数，奇数列是 $i$ 与 $i+1$ 交替。

对于偶数列，大的数字在中间，奇数在上的情况和偶数在上的情况交替。

对于奇数列，奇偶数交替，哪种数字在前也交替。

如果听不懂文字描述可以看一看 $n=9$，务必分奇偶列去看。

```
1
3 2
5 1 4
7 2 6 3
9 1 8 4 5
8 2 9 3 7 6
6 1 7 4 9 5 8
4 2 5 3 8 6 9 7
2 1 3 4 6 5 7 8 9
```

我都快忘了自己怎么想到的了，反正玩了很久后终于找到了那组解。

这是 $n$ 为奇数，那偶数怎么办呢？

你发现斜线是一个排列，因此在每一行最后加一个 $n$ 就行了。（谢谢 @Register_int）

代码

```cpp
#include <bits/stdc++.h>

int main() {
  int n; scanf("%d", &n);
  std::vector<std::vector<int>> f(n, std::vector<int> (n));
  bool q = 0;
  if (n % 2 == 0) q = 1, --n;
  for (int i = 0; i < n; i += 2) {
    if (i % 4 == 0) {
      int p = i;
      for (int j = i + 1; j <= n; j += 2) 
        f[p++][i] = j;
      p = n - 1;
      for (int j = i + 2; j <= n; j += 2)
        f[p--][i] = j;
    } else {
      int p = n - 1;
      for (int j = i + 1; j <= n; j += 2) 
        f[p--][i] = j;
      p = i;
      for (int j = i + 2; j <= n; j += 2)
        f[p++][i] = j;
    }
  }
  for (int i = 1; i < n; i += 2) {
    if (i % 4 == 1) {
      std::vector<int> val(2);
      val[0] = i, val[1] = i + 1;
      for (int j = n - 1; j >= i; j--) 
        f[j][i] = val[(n - 1 - j) & 1];
    } else {
      std::vector<int> val(2);
      val[0] = i + 1, val[1] = i;
      for (int j = n - 1; j >= i; j--) 
        f[j][i] = val[(n - 1 - j) & 1];
    }
  }
  if (q) printf("%d\n", n + 1);
  for (int i = 0; i < n; i++) {
    for (int j = 0; j <= i; j++) printf("%d ", f[i][j]);
    if (q) printf("%d ", n + 1);
    printf("\n");
  }
}
```

---

## 作者：zxh923 (赞：2)

# P9837 汪了个汪 题解

[题目传送门](https://www.luogu.com.cn/problem/P9837)。

### 思路

首先先算出这种数对的个数。

先选择第一个数，有 $n$ 种选法，此时还剩 $n-1$ 个数，又因为无序，所以总个数为 $\frac{n\times(n-1)}2$。

再看这个金字塔结构，第一行没有数对，第二行有 $1$ 个，第三行有 $2$ 个，以此类推，第 $n$ 行有 $n-1$ 个。总共也是 $\frac{n\times(n-1)}2$ 个。

所以我们可以想出如下构造，我们让每一行的差依次增加，第 $1,2$ 个数相差 $1$，第 $2,3$ 个数相差 $2$，以此类推，并且在这一行奇数位置的数不大于第一个数，偶数位置的数小于第一个数。

然后我们设第一个数为 $x$，依次加减差就可以构造出来了，但是我们需要将构造出来的数列按长度重新排序。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 4005
using namespace std;
int n,t,fir[N],cnt;
signed main(){
	scanf("%lld%lld",&n,&t);
	if(n&1){//预处理每一行第一个数 
		for(int i=n;i>=1;i-=2){
			fir[i]=n/2+1+(n-i)/2;
		}for(int i=2;i<n;i+=2){
			fir[i]=i/2;
		}
	}else{
		for(int i=n-1;i>=1;i-=2){
			fir[i]=n/2+1+(n-i)/2;
		}for(int i=n;i>=2;i-=2){
			fir[i]=i/2;
		}
	}for(int i=1;i<=n;i++){
		cout<<fir[i]<<' ';//输出第一个数 
		cnt=1;
		for(int j=2;j<=i;j++){//加减交替构造 
			if(cnt>0){
				cout<<cnt+fir[i]<<' ';
				cnt*=(-1);
			}else{
				cout<<cnt+fir[i]<<' ';
				cnt*=(-1);
				cnt++;
			}
		}cout<<'\n';
	}
	return 0;
}
```

---

## 作者：zk_y (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P9837)

第一篇题解描述的真好，我也来说说我赛中和赛后的想法。

赛时，一看这道题目，构造题，一下不想打了（毕竟我的思维水平烂的离谱），拿了 $5pts$ 溜掉。

赛后一看，这么简单！于是赶快切掉。

我们首先来分析一下样例（第二个）：

输入：``5 2``

输出：

```cpp
1
2 3
4 2 5
3 5 1 4
5 4 3 1 2
```
我们发现，总共有 $\displaystyle \frac {n(n+1)} {2}$ 组不同的二元组。

但是题目中也有 $\displaystyle \frac {n(n+1)} {2}$ 个相邻两个数组成的无序二元组。

所以，这个东西必须是一一对应的。

然后，考场上就发现了每个数的位置是可以互换的（也就是每一个数的数量和地位都相等），然后就没有什么思路了……

之后再想想，发现我的注意力错了，应当放在这个两元组的两个数的差上。

第一篇题解感觉描述的构造过程挺形象的，那么这里我就用我自己的方法来证明一下他的正确性吧。

我们的构造方法是不停的使用 $x,x+1,x-1,x+2,x-2…$ 这样的东西。

我们发现第一项和第二项差是 $1$。

这样的两元组有多少个呢？

> 一共有 $n-1$ 个。

那么我们一共有多少个差为 $1$ 的二元组呢？

> 也是 $n-1$ 个。

而且，我们可以看出在数列中的两元组的每一个数的开头都是不同的 $x$，所以我们就能保证每个二元组的不同。

因而我们就说明了所有差为 $1$ 的二元组在这个数列中。

同理，我们就可以说明对于 $\forall i\le n$，所有差为 $i$ 的两元组都在这个数列之中。

而任何两个二元组都两两不相同。

所以，我们证明了这样构造是可行的。

最后，附上本人常数较大的代码（相对于第一篇题解，我还是太弱了）。

# AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
const int N=4005;
struct node{
	int ans[N];//记录以i开头的数列
	int len;//记录以i开头的数列的长度
}num[N];
bool cmp(node A,node B){
	return A.len<B.len;//进行排序
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		int x=i,k=1;
		num[i].ans[k]=i;
		for(int j=1;x>=1&&x<=n;){
			if(k%2==1){
				x=i-j;
				if(x<1||x>n){
					num[i].len=k;
					break;
				}
				num[i].ans[++k]=x;
			}
			else{
				x=i+j;
				if(x<1||x>n){
					num[i].len=k;
					break;
				}
				num[i].ans[++k]=x;
				j++;
			}
		}
	}//预处理一下
	sort(num+1,num+n+1,cmp);//排序
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			cout<<num[i].ans[j]<<' ';
		}
		cout<<'\n';
	}//输出
	return 0;
}
```

---

## 作者：cosf (赞：2)

## [P9837](https://www.luogu.com.cn/problem/P9837)

比赛时仅差一步想出正解……zig-zag pattern 都画出来了……

## 思路

我们可以把这道题抽象成一个图论模型。

注意到，原题中有 $\frac{n(n-1)}{2}$ 对无序二元组，互补相同，而 $n$ 个数能组成的无序二元组最多也就这么多。所以，我们把无序二元组看成一条无向边，将每一行看成一条链，那么这几条链会组成一个完全图。

我们要考虑如何构造 $n$ 条符合要求的链。

这题可以使用 zig-zag pattern。zig-zag pattern 可以理解为“一左一右”。利用 zig-zag pattern，我们可以轻松地解决本题。具体来讲，对于每一个节点 $i$，我们可以构造一个链：

$$i - (i+1)-(i-1)-(i+2)-(i-2)-\cdots-(i+k)-(i-k)-\cdots$$

这样做可能会越界。怎么处理？就暴力地把越界之后的删掉即可。ducati 大佬讲的是把它调整（给越界的数加上或减去一个 $n$，而且还要判 $n$ 的奇偶性），然后再断掉，事实上这样断会更加简洁。

这样，假设这条链是从 $i$ 开始的，那么它的长度 $len$ 满足（懒得写就直接写桶排吧，我也这么写的）：

$$
len_i = \begin{cases}
2i-1 & i \le \frac{n}{2}\\
2(n-i) & \text{otherwise}
\end{cases}
$$

把它们相加刚好得到 $\frac{n(n-1)}{2}$。

那么，为什么不会重复呢？因为，我们也能够简单地知道一条边的链头（$head_{<u, v>}$）是哪一个：

$$
head_{<u, v>}=\lfloor\frac{u+v}{2}\rfloor
$$

代码也就非常的好写。

## 代码

```cpp
#include <iostream>
#include <vector>
using namespace std;

#define MAXN 4005

vector<int> row[MAXN]; // 最好不要开 4000*4000，虽然不会 MLE，
                       // 但是某人在某次考试中某题开稍微大了一点，
                       // 喜提 0 分。
int rn[MAXN];

int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        row[i].push_back(i);
        for (int j = 1; j <= n; j++)
        {
            if (i + j > n)
            {
                break;
            }
            row[i].push_back(i + j);
            if (i - j < 1)
            {
                break;
            }
            row[i].push_back(i - j);
        }
        rn[row[i].size()] = i; // 桶
    }
    for (int i = 1; i <= n; i++)
    {
        int j = rn[i];
        for (int v : row[j])
        {
            cout << v << ' ';
        }
        cout << endl;
    }
    return 0;
}

```


---

## 作者：int08 (赞：2)

## 前言
今天没打比赛，赛后来看，花了一小时想，$20$ 分钟切了。

不得不说，每当我做构造题，思路对上出题人，找到构造方法的一瞬间，颇有醍醐灌顶之感，也不禁感叹出题人思路之清奇而精妙。

建议跟着我的思路走，而不是只看一个构造方法就离开。

# Solution
### Step 0
先来找找部分分。

发现有 $t=0$ 和 $t=1$ 两个部分分，其中 $t=0$ 非常简单，乱输出即可。

对着 $t=1$ 思索，没有发现什么做法，~~至少我没有的。~~

于是果断离开并直接思考正解。
### Step 1
直接开始构造吗？别急，还有一些性质可以发掘。

第一：容易发现，本题中，相邻两个数一共组成了 $1+2+3+...+(n-1)=\frac{n(n-1)}{2}$ 个无序二元组，可是 $1$ 到 $n$ 范围内两数不同的无序二元组总共也只有 $\frac{n(n-1)}{2}$ 个！

也就是说所有的可能的无序二元组都会被占满。

第二：很多人应该都想过：对于原题中的每一行第一个数互不相同的限制，能不能直接第一行行首填 $1$，第 $i$ 行行首填 $i$ 呢？

可以的，因为这 $n$ 个数本题中没有大小关系，本质上是等价的，所以对一个满足条件的构造，总是可以将里面所有 $i$ 换成 $j$，所有 $j$ 换成 $i$。

那么上面的限制对答案没有任何影响。

别看这里都是废话，它用**增加限制**将我们引上一条正道：**递归构造法。**
### Step 2
起初，我的希望是：直接对已有的 $n$ 的构造，加 $1$ 到 $2$ 行找到 $n+1$ 或者 $n+2$ 的构造，显然是不行的，因为，对于每一个数，都得有盘面中的其他 $n-1$ 个数与它相邻，而最后两行只能出现两次 $n+1$，凑不出来那么多相邻。

但是我们还是希望在较大的构造中找到较小的构造的影子。

先简单手玩找到一些：
```
n=1:
1

n=2:
1
2 1

n=3:
1
2 3
3 1 2

n=4:
1
2 1
3 4 2
4 1 3 2

```
没有发现规律，但是发现 $n=1$ 和 $n=3$ 长得像，$n=2$ 和 $n=4$ 长得像，**想到分奇偶讨论。**

由样例取得 $n=5$ 构造并转化一下：
```
n=5:
1
2 4
3 2 5
4 5 1 3
5 3 4 1 2
```
和 $n=3$ 有点像？重要的一步来了！**翻转每个构造中 $1$ 到 $n$ 顺序，** 得到
```
n=3:
3
2 1
1 3 2

n=5:

5
4 2
3 4 1
2 1 5 3
1 3 2 5 4
```
他们左下角是一样的，而且新加的第四斜行只有 $4$ 和 $5$，最外层每个数出现一次。

**这就是递归构造的雏形了。**
### Step 3
先类似地，在 $n=5$ 外面加两层，打出 $n=7$：
```
n=7:
7
6 5
5 7 3
4 2 6 1
3 4 1 7 2
2 1 5 3 6 4
1 3 2 5 4 7 6
```
从左下往右上看，第六斜行 $6$ 与 $7$ 交替，规律明显。

啥？你说为什么第四斜行不是 $4$ 与 $5$ 交替？说明前面构造太丑了，交换一下 $(2,3)$ 和 $(3,2)$，得：
|  |  |  |  |  |  |  |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $\color{blue}\texttt{7}$ |  |  |  |  |  |  |
| $\color{red}\texttt{6}$ | $\color{blue}\texttt{4}$ |  |  |  |  |  |
| $5$ | $\color{red}\texttt{7}$ | $\color{blue}\texttt{3}$ |  |  |  |  |
| $4$ | $2$ | $\color{red}\texttt{6}$ | $\color{blue}\texttt{1}$ |  |  |  |
| $3$ | $5$ | $1$ | $\color{red}\texttt{7}$ | $\color{blue}\texttt{2}$ |  |  |
| $2$ | $1$ | $4$ | $3$ | $\color{red}\texttt{6}$ | $\color{blue}\texttt{5}$ |  |
| $1$ | $3$ | $2$ | $5$ | $4$ | $\color{red}\texttt{7}$ | $\color{blue}\texttt{6}$ |

观察红蓝两斜行，发现了构造的规律：从左下往右上数，偶数斜行时，第 $i$ 行是 $i$ 和 $i+1$ 交替出现，奇数斜行时，第 $i$ 斜行是从左上填入 $i$ 开始，右下和左上一边两个数往中间缩到 $1$。

可以证明这样是可行的。

于是 $n$ 为奇数的部分解决了，太好了。

### Step 4
看到奇数都可以这样优美地解决，我们初步认为偶数也可以。

所以我们尝试在 $n=2$ 基础上加两层，重新构造一个 $n=4$ 的答案。

|  |  |  |  |
| :----------: | :----------: | :----------: | :----------: |
| $4$ |  |  |  |
| $3$ | $1$ |  |  |
| $2$ | $4$ | $1$ |  |
| $1$ | $2$ | $3$ | $4$ |

发现第三斜行又是 $3$ 和 $4$ 交替，于是再类似地构造出 $n=6$ 的情况：
|  |  |  |  |  |  |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $\color{blue}\texttt{6}$ |  |  |  |  |  |
| $\color{red}\texttt{5}$ | $\color{blue}\texttt{3}$ |  |  |  |  |
| $4$ | $\color{red}\texttt{6}$ | $\color{blue}\texttt{2}$ |  |  |  |
| $3$ | $1$ | $\color{red}\texttt{5}$ | $\color{blue}\texttt{2}$ |  |  |
| $2$ | $4$ | $1$ | $\color{red}\texttt{6}$ | $\color{blue}\texttt{3}$ |  |
| $1$ | $2$ | $3$ | $4$ | $\color{red}\texttt{5}$ | $\color{blue}\texttt{6}$ |
观察红蓝两斜行，发现了构造的规律：从左下往右上数，奇数斜行时，第 $i$ 行是 $i$ 和 $i+1$ 交替出现，偶数斜行时，第 $i$ 斜行是从左上填入 $i$ 开始，从外往里，左上右下对称地 $-3$，$-1$，$-3$……这样缩。

于是我们找到了 $n$ 为任意正整数的构造方法，这道题也就做出来了。

实现是简单的，不过还是贴一下代码。
## 后记
我相信，肯定有人在想：你直接像其他大佬一样，写出构造方法不就行了，写这么多思考过程的废话干什么呢？

我只想说：我不能，也不指望能有大佬那种才思泉涌，一步登天的智慧，我能做的，只有一步一步，往上走，走向山顶。

## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int i,j,a[5000][5000],n; 
int main()
{
	cout.tie(0);
	cin>>n;		//需要输入t吗？ 需要输入t吗？ 需要输入t吗？ （
	if(n%2)
	{
		a[1][1]=1;
		for(i=2;i<=n;i+=2)
		{
			for(j=1;j<=i;j++) a[i+1-j][j]=i+(j&1)^1;
			for(j=1;j<=i/2;j++)
			{
				if(j%2)
				{
					a[i+2-j][j]=i+3-2*j;
					a[j][i+2-j]=i+2-2*j;
				}
				else
				{
					a[i+2-j][j]=i+2-2*j;
					a[j][i+2-j]=i+3-2*j;
				}
			}
			a[i/2+1][i/2+1]=1;
		}
	}
	else
	{
		a[1][1]=1;a[1][2]=a[2][1]=2;
		for(i=4;i<=n;i+=2)
		{
			for(j=1;j<i;j++)
			a[i-j][j]=i-(j&1);
			int q=i;
			for(j=1;j<=i/2;j++)
			{
				a[i+1-j][j]=a[j][i+1-j]=q;
				if(j%2) q-=3;
				else q--;
			}
		}
	}
	for(i=n;i>=1;i--)
	{
		for(j=1;j<=n+1-i;j++) cout<<a[i][j]<<" ";
		cout<<endl;
	}
	return 0;
 } 
```
# The End.

---

## 作者：brimosta (赞：2)

考虑归纳构造。

首先当 $n$ 为偶数时，你在每行最右侧和第一行都放 $n$，可以规约到 $n-1$ 的子问题。

下面我们仅讨论 $n$ 为奇数。

考虑归纳构造，假设你已经完成了 $n-2$ 的子任务，需要完成 $n$ 的任务。

考虑在已有的基础上，在左边添加两列。

左侧的第一列，第一行是 $n$，最后一行是 $n-1$，中间是已有的第一列的 reverse，第二列是 $n-1$ 和 $n$ 的交替排列。

example:
```
7
4 6
3 7 5
1 6 2 4
2 7 1 5 3
5 6 3 4 1 2
6 7 4 5 2 3 1
```

正确性证明：

首先你排除掉 $n$ 为偶数，这个是容易的。

$t=0$，显然对。

$t=1$，你考虑新加的那两个数与其他数组成的数对，正好加入的是新加的那两个数与其他数的所有配对。

$t=2$，你需要保证一行内不同，显然最后一行是对的，考虑倒数第二行为什么是对的，观察倒数第二行的数是怎么来的：是一些列的最上面那个数和交错排列的倒数第二个数，然后你发现，交错排列的第二个数跟那一列最上面的数相同，那么，所有数都是从每列最上面来的，并且除了第一行第一个以外一一对应，按照构造的过程显然你每列最上面的一个数是互不相同的，那么倒数第二列就证完了，然后以此类推一下好像就行了。

---

## 作者：timefinder (赞：2)

关卡 2 一定能够通过关卡 0 和 1，直接思考满分做法。

题目要求第一列的数字互不相同，不妨定为 ```1 2 3 4 ... n```。我们先来手玩 $n \leq 4$ 的情况。

```
1
2 1

1
2 3
3 1 2

1
2 4
3 1 4
4 3 2 1
```

观察上图，容易想到：是不是 $n$ 为偶数时，必有一个构造，使得原等腰直角三角形沿斜边上的中线对称？

注意到 $n=4$ 的左下方

```
3
4 3
```
恰好与

```
1
2 1
```
类似，那么我们能不能尝试归纳，每一次将 $k-2$ 的解统一加上 $2$ 再置于 $k$ 中的左下方，然后补全图形剩余的两个对角线？

此时先去写了一个暴搜打表。尝试寻找 $n=6$ 且左下方为：
```
1+2
2+2 4+2
3+2 1+2 4+2
4+2 3+2 2+2 1+2
```
的解。

确实存在：
```
1
2 4
3 1 5
4 6 2 5
5 3 6 1 4
6 5 4 3 2 1
```

到这一步，我们考虑构造 $n$ 为偶数的通解。

根据归纳方案，左下角的直角三角形一定不会用到 $1$ 与 $2$。想到试图用这两个数完成 $(2,1)$ 到 $(n,n-1)$ 这一对角线的解。又由于对称性，可以交替铺排避免重复。

接下来，我们用 $n=6$ 作为示例。要最大化地利用 $1$ 与 $2$，既然它们已经同 $3$ 和 $6$ 相邻了，不如通过填入最外层，让其分别与其它数相邻。惊喜地发现，问题迎刃而解。如下方：
```
1
2 4
3 1 5
4 6 2 8
5 3 7 1 8
6 8 4 7 2 5
7 5 8 3 6 1 4
8 7 6 5 4 3 2 1

1
2 4
3 1 5
4 6 2 8
5 3 7 1 9
6 8 4 10 2 9
7 5 9 3 10 1 8
8 10 6 9 4 7 2 5
9 7 10 5 8 3 6 1 4
10 9 8 7 6 5 4 3 2 1
```

至此，偶数问题解决了，再考虑奇数。观察到 $n=3$ 不满足对称性，但是依然可以尝试运用上面的归纳思路，寻找左下方为
```
1+2
2+2 3+2
3+2 1+2 2+2
```
的 $n=5$ 解：
```
1
2 4
3 1 5
4 5 2 3
5 3 4 1 2

1
2 4
3 2 5
4 5 1 3
5 3 4 1 2

1
2 5
3 2 4
4 5 1 3
5 3 4 1 2
```
我们挨个尝试，其中一定有具有归纳性质的解。此处选取如下 $n=7$ 和 $n=9$ 的解：
```
1
2 4
3 1 5
4 6 2 7
5 3 7 1 6
6 7 4 5 2 3
7 5 6 3 4 1 2

1
2 4
3 1 5
4 6 2 8
5 3 7 1 9
6 8 4 9 2 7
7 5 9 3 8 1 6
8 9 6 7 4 5 2 3
9 7 8 5 6 3 4 1 2
```
它们是由上面 $n=5$ 的第一个解衍生而来。通解构造思路同偶数相同，不再赘述。

关于代码实现问题，因为最外层对角线满足 $a_{i,j}=a_{i-1,j-1}+3$ 或 $a_{i,j}=a_{i-1,j-1}+1$ 或 $a_{i,j}=a_{i+1,j+1}+3$ 或 $a_{i,j}=a_{i+1,j+1}+1$，依次填入即可。

**code:**
```
#include<bits/stdc++.h>
using namespace std;
const int N=4e3+5;
int n,a[N][N];
void make_0(){
	for(int st=1;st<=n;st+=2){
		for(int i=st+1;i<=n;i++){
			if((i-st)&1) a[i][i-st]=st+1;
			else a[i][i-st]=st;
		}
		a[st][1]=st;	
		for(int i=st+1;i<=n;i++){
			if((i-st)&1) a[i][i-st+1]=a[i-1][i-1-st+1]+3;
			else a[i][i-st+1]=a[i-1][i-1-st+1]+1;
		}
		a[n][n-st+1]=st;
		for(int i=n-1;i>=st+1;i--){
			if((n-i)&1) a[i][i-st+1]=a[i+1][i+1-st+1]+3;
			else a[i][i-st+1]=a[i+1][i+1-st+1]+1;
			if(a[i-1][i-1-st+1]==a[i][i-st+1]) break;
		}
	}
}
void make_1(){
	for(int st=1;st<=n;st+=2){
		for(int i=st+1;i<=n;i++){
			if((i-st)&1) a[i][i-st]=st+1;
			else a[i][i-st]=st;
		}
		a[st][1]=st;
		if(st==n) continue;	
		for(int i=st+1;i<=n;i++){
			if((i-st)&1) a[i][i-st+1]=a[i-1][i-1-st+1]+3;
			else a[i][i-st+1]=a[i-1][i-1-st+1]+1;
		}
		a[n][n-st+1]=st+1;
		for(int i=n-1,cnt=0;i>=st+1;i--){
			if((n-i)&1) a[i][i-st+1]=a[i+1][i+1-st+1]+1;
			else a[i][i-st+1]=a[i+1][i+1-st+1]+3;
			cnt++;
			if(cnt+!(((n-st)/2)&1)==(n-st)/2) break;
		}
	}
}
int main(){
	int t;scanf("%d%d",&n,&t);
	if(!(n&1)) make_0();
	else make_1();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++) printf("%d ",a[i][j]);
		printf("\n");
	}
}
```

---

## 作者：Cl41Mi5deeD (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9837)

构造出第二关即可。

**思路历程**

基本上是一直靠突发奇想过的。

如果把相邻的点之间连一条边，题目要求通过 $n$ 条长度为 $1\cdots n$ 的边组成的链构造出一个完全图。

最开始对着样例画图想找到这些链有没有什么折叠的规律。

而后发现，如果给每个构造好的图的点的编号进行同加同减的操作是不影响答案正确性的。换句话说：**构造方式和单点的编号无关，只可能和编号间的相对关系有关**。

然后就开始猜构造方式，脑子太笨猜不着。回看刚才的结论，相对关系很大可能就是差值。给完全图的每条边赋权，规定连接 $u$,$v$ 的边的边权为 $|u-v|$，把所有边单独列出来排好，以 $n=5$ 为例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/a4eh5h21.png)


排出来：

```cpp
1  1  1  1
2  2  2
3  3
4
```
经过本人突发奇想决定把这些边斜侧 45° 来看

```cpp
　　　   1
      2     1
   3     2     1
4     3     2     1
```
每一行从右往左看把边连起来，边所连接的点也要连续，形成 $n-1$ 条链和一个单点。经过本人多次试验似乎**总存在至少一种连接方法**可以构造出完全图。

按该图中，用上述方法表示出一种点连接到点的方案，构造的时候从最后一行向上连边（这样手动构造时比较好找）。
```cpp
3 -> 2 -> 4 -> 1 -> 5
 (1)  (2)  (3)  (4)
4 -> 3 -> 5 -> 2
 (1)  (2)  (3)
2 -> 1 -> 3
 (1)  (2)
5 -> 4
 (1)
1
```

我们**有意地让每条链的最后一个点不同**，之后把方案中心对称一下

```cpp
1
4 5
3 1 2
2 5 3 4
5 1 4 2 3
```
好像...就对了？

由于得到答案的方式过于玄学我又试了几种情况，没有找到反例。事实上最后提交上去也没问题。

**于是考虑实现**

我们回看刚才的构造方法发现，如果把这些点按照大小排出位置高低画到本子上那么：

![](https://cdn.luogu.com.cn/upload/image_hosting/en79qxws.png)

发现这些链就像波，一下一上，一上一下...

而且无论 $n$ 的奇偶，都可以把波的顺序处理成先下，再上，再下...的形式。

点 $n$ 与 $n-2k,k\in Z$ 开头的波向下，剩下的向上，可以正好使得波的末尾不重复，反着输出即可。
```cpp
#include<bits/stdc++.h>
#define MAXN 20001
using namespace std;
int n,k,tmp=1;
int zf[2]={1,-1};//开一个正负数组，每次对i取模得到对应下标，我觉得很方便。
struct node{
	int v,w;
};
vector<node>edge[MAXN];
vector<int>ans[MAXN];//由于我们也不清楚每个点引导的波有多长，用vector处理。
int main(){
	scanf("%d%d",&n,&k);
	if(n==1){
		printf("%d",n);
		return 0;
	}
	for(int i=n,cnt=0;i>=1;i--,cnt++,tmp++){
		if(cnt%2==0){//先下的波
			int last=i;
			ans[tmp].push_back(i);
			for(int j=i-1,c2=1;j>=1;j--,c2++){//处理每次的上下
				ans[tmp].push_back(last+j*zf[c2%2]);
				last+=j*zf[c2%2];
			}
		}
	}
	for(int i=2;i<=n;i+=2,tmp++){//先上的波
		int last=i;
		ans[tmp].push_back(i);
		for(int j=n-i,c2=0;j>=1;j--,c2++){
			ans[tmp].push_back(last+j*zf[c2%2]);
			last+=j*zf[c2%2];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=tmp;j++){
			if(ans[j].size()==i){//i行把长为i的链打出来
				for(int k=ans[j].size()-1;k>=0;k--)printf("%d ",ans[j][k]);
				printf("\n");
				break;
			}
		}
	}
	return 0;
}
```

是本人第一道完全不借助题解切掉的紫。

---

## 作者：JimmyLee (赞：1)

奇怪的构造方法居然过了...

本构造方法暂无证明，只是提供一种乱搞做法。

## 对于奇数的情况

首先我们从样例入手（为 $5$ 的情况）：

```
1
2 3
4 2 5
3 5 1 4
5 4 3 1 2
```

然后我们对样例进行一点改造：

```
1
2 3
4 1 5
3 5 2 4
5 4 3 1 2
```

我们将这个数组水平翻转一下，再顺时针旋转 45 度：

```
        5
      3   4
    4   5   3
  2   1   2   1
1   3   5   4   2
```

然后就使用瞪眼法，发现偶数行和奇数行规律不同，将它们分离成两部分：

```
    5
  4 5 3
1 3 5 4 2
```

和

```
  3 4
2 1 2 1
```

---

我们发现奇数行的最后一行是 `1 3 5 4 2` ，按照奇偶再分成两部分：`1 3 5` 和 `4 2` 。

然后我们发现最后一行先是 $1$ 到 $n$ 的奇数，再是 $n-1$ 到 $2$ 的偶数。

然后我们再看倒数第二行 `4 5 3` 和最后一行去除头尾元素的部分 `3 5 4` 。

发现倒数第二行只是把最后一行去除头尾元素的部分翻转了。

然后依照该规律向上构造即可。

---

再看偶行，由下到上就是从小到大的相邻的两个数反复出现而已。

从上到下先是奇数开头，再是偶数开头。

## 对于偶数的情况

偶数的样例只能自己手搓一个（为 $6$ 的情况）：

```
1
2 3
4 1 5
3 6 2 5
5 4 6 1 3
6 5 3 4 2 1
```

和奇数一样，将这个数组水平翻转一下，再顺时针旋转 45 度：

```
          6
        5   5
      3   4   3
    4   6   6   4
  2   1   2   1   2
1   3   5   5   3   1
```

然后将奇偶行分离：

```
    6
  3 4 3
2 1 2 1 2
```

和

```
    5 5
  4 6 6 4
1 3 5 5 3 1
```

---

奇数行和另一种情况的偶数行构造一致。

只是从上到下先是偶数开头，再是奇数开头。

---

不难发现偶数行是对称的。

最后一行的前半部分是 `1 3 5` ，倒数第二行的前半部分是 `4 6` 。

然后我们发现最后一行是 $1$ 到 $n-1$ 的奇数，倒数第二行是 $2$ 到 $n$ 的偶数。

两组数据交替出现。

每次向上构造时删除头尾元素即可。

## Code

```c++
#include<bits/stdc++.h>
using namespace std;
#define maxn 4003

int mp[maxn][maxn];
int ls[maxn];
int ls1[maxn], ls2[maxn];

void solve1(int n)
{
    for(int i=1;i<=n;i++) ls[i]=(i<=(n>>1)+1)?(i<<1)-1:(n-i+1)<<1;
    int cnt1=0;
    for(int i=1;i<=n;i++)
    {
        if(i&1)
        {  
            cnt1++;
            int mf=cnt1;
            if(i&2) for(int j=i;j<=n;j++)
                mp[n-j+i][n-j+1]=ls[mf++];
            else for(int j=i;j<=n;j++)
                mp[j][j-i+1]=ls[mf++];
        }
        else
        {
            if(i&2) 
            {
                int st=i-2;
                for(int j=i;j<=n;j++)
                    mp[j][j-i+1]=(st^=1)+1;
            }
            else 
            {
                int st=i-1;
                for(int j=i;j<=n;j++)
                    mp[j][j-i+1]=(st^=1)+1;
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
            cout<<mp[i][j]<<' ';
        cout<<'\n';
    }
}

void solve2(int n)
{
    for(int i=1;i<=n>>1;i++) ls1[i]=(i<<1)-1;
    for(int i=1;i<=n>>1;i++) ls2[i]=(i<<1);
    for(int i=(n>>1)+1;i<=n;i++) ls1[i]=((n-i+1)<<1)-1;
    for(int i=(n>>1)+1;i<=n;i++) ls2[i]=((n-i+1)<<1);
    int cnt1=0;
    for(int i=1;i<=n;i++)
    {
        if(i&1)
        {  
            cnt1++;
            int mf=cnt1;
            if(i&2) for(int j=i;j<=n;++j)
                mp[n-j+i][n-j+1]=ls2[mf++];
            else for(int j=i;j<=n;++j)
                mp[j][j-i+1]=ls1[mf++];
        }
        else
        {
            if(i&2) 
            {
                int st=i-2;
                for(int j=i;j<=n;++j)
                    mp[j][j-i+1]=(st^=1)+1;
            }
            else 
            {
                int st=i-1;
                for(int j=i;j<=n;++j)
                    mp[j][j-i+1]=(st^=1)+1;
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
            cout<<mp[i][j]<<' ';
        cout<<'\n';
    }
}


int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int n,w;
    cin>>n>>w;
    if(n&1) return solve1(n), 0;
    else return solve2(n), 0;
}
```

---

## 作者：wwz1428572008 (赞：1)

# 思路
## 题意
我们知道有 $\frac{n(n-1)}{2}$ 个横向相邻数对，和 $\frac{n(n-1)}{2}$ 个不同无序二元组。两个数量相等，所以每种不同的无序二元组在棋盘中恰好出现了一次。

## 构造方法
首先观察样例，发现当棋盘以输出格式呈现时，最左侧一列与最下面一行中 $1$ 和 $2$ 的位置以及 $3$ 和 $4$ 的位置关于从左下角到右上角的直线对称。并且最左侧一列与最下面一行中 $1$ 和 $2$ 相邻，$3$ 和 $4$ 相邻。这启发我们分层构造。

下面是 $n=5$ 时的样例：
```
1
2 3
4 2 5
3 5 1 4
5 4 3 1 2
```

$n=5$ 时，我们先尝试让最下面一行为 $1$ 到 $5$ 顺次排列，构造如下：
```
4 
5 2 
2 4 1 
3 1 5 3 
1 2 3 4 5 
```

令第一层为 $1$，第二层为 $3,2$，第三层为 $2,1,3$，依此类推，第 $n$ 层有 $n$ 个数。经过观察，可以得到一种 $n$ 为奇数时通过第一关的方法。当 $n\ge 3$ 且为奇数时，令第 $n-1$ 层为 $n,n-1,n,n-1,\cdots$ 依次交替，第 $n$ 层的第一个数是 $n-1$，最后一个数是 $n$，中间的 $n-2$ 个数和第 $n-2$ 层一样。这样，对于第 $n-1$ 层的每个 $n$，它左右相邻的两个数和它左侧与下侧的两个数一样，也就意味着与它相邻的所有数与第 $n-2$ 层的每个数一一对应。所以，$n$ 与从 $1$ 到 $n-2$ 中的所有数左右相邻。同时在右下角，$n$ 还与 $n-1$ 相邻，所以包含 $n$ 的无序二元组都出现了，且仅出现一次。对于 $n-1$ 同理。

但是，这样做通不过第二关，因为当 $n\ge 5$ 且为奇数时，第 $n$ 层的倒数第二个数和第 $n-3$ 层的倒数第二个数相同，且在同一行内。我们发现，可以在构造第 $n$ 层时令中间的 $n-2$ 个数为第 $n-2$ 层的倒序排列，其余步骤都不变。这样，第 $n$ 层中原本与 $n$ 相邻的数还与 $n$ 相邻，与 $n-1$ 相邻的数还与 $n-1$ 相邻。经过测试，这种构造方法可以通过本题。

$n=5$ 时第二关的构造：
```
4 
5 3 
2 4 1 
3 1 5 2 
1 2 3 4 5 
```

注意到 $n$ 为奇数时，第 $n$ 层中包含了从 $1$ 到 $n$ 的所有数。所以，当 $n$ 为偶数时，只需先以奇数的方式构造前 $n-1$ 层，再令第 $n$ 层全为 $n$。这样，包含 $n$ 的无序二元组全都出现了恰好一次。

# 代码
```cpp
#include<iostream>
using namespace std;
int g[4002][4002];
int main()
{
	ios::sync_with_stdio(0);
	int n,t;
	cin>>n>>t;
	g[1][1]=1;
	for(int i=2;i<=n+1;i+=2)
	{
		for(int j=1;j<=i;j++)
			g[j][i+1-j]=i^(j&1);
		g[1][i+1]=i;
		g[i+1][1]=i+1;
		for(int j=2;j<=i;j++)
			g[j][i+2-j]=g[i+1-j][j-1];
	}
	if(n%2==0)
	{
		for(int i=1;i<=n;i++)
			g[i][n+1-i]=n;
	}
	for(int i=n;i>=1;i--)
	{
		for(int j=1;j<=n-i+1;j++)
			cout<<g[j][i]<<' ';
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：Vidoliga (赞：1)

构造题。

在海洋王国嘴巴了，写一下。

首先题意可以转化为在一个完全图上选 $n$ 条长度分别是 $0,1,\dots,n-1$ 的链，此处长度定义为链上边数，保证链的开头互不相同，且所有链恰好覆盖所有边恰好一次。

考虑一下所有边的性质，思考一下边上点的差值，对于差值为 $1$ 的有 $n-1$ 条，差值为 $2$ 的有 $n-2$ 条，以此类推。

考虑到链长恰好也要求 $0,1,\dots,n-1$，那么可否将同差值的放入一条链？答案显然是不行的，那么考虑能否设计长度为 $t$ 的链包含 $1,2,\dots,t$ 差值的边？

考虑为了使得尽可能满足不出现构造出现重复的边，那么构造的方案应当大同小异，而不是自适应调整。

那么为了保证一个构造的方案不出现不满足数据范围的点，即时刻满足边两端点编号在 $[1,n]$ 之间，需要一种构造满足这种构造的极值差是所有构造中**较紧**的。

考虑若可以满足随着链长增大 $1$，而极值差也只增大 $1$，那么一定可以倒退出方案，考虑怎样放置可以满足极值差只增大 $1$。

观察到这步，大部分这种构造需要考虑**增量**，沿用增量前的构造方式，尝试加入一个新的边。

这种构造方式，可以保证极值差只增大 $1$ 吗？

在这题中是可以的，具体而言，考虑一条边相当于右边点是左边点加上/减去差值。

而对于需要新增一条差值为 $t$ 的边，考虑是增加 $t$ 还是减去 $t$。

构造方案为，当前选择的符号应与上次选的相反。

实际上这种构造的正确性很显然，或者说想到前部分的一系列性质，这部分应当是好想的？那这里就不给予证明，读者可自证，将每个数对于初值的差写出来即可证明。

会发现一个长度为 $t$ 链形如：

$x,x+1,x-1,x+2,x-2,\dots,x+\dfrac{t}{2}(t \bmod 2=0)$

$x,x+1,x-1,x+2,x-2,\dots,x+\dfrac{t+1}{2},x-\dfrac{t+1}{2}(t \bmod 2=1)$

考虑算出每个长度为 $t$ 的链的初值的取值范围，倒序计算出初值即可。

复杂度 $O(n^2)$。

说实话，遇到构造题不应该上来就喷，构造题大都很有含金量，所以多做构造体没毛病。

```cpp
//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2")
//#pragma GCC optimize("Ofast","unroll-loops","inline")
#include<bits/stdc++.h>
#define ll long long
//#define int ll
using namespace std;
const int N=4e3+20,M=1e6+20,mod=998244353;
int n,t,a[N][N];
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>t;
	int l=(n+1)/2,r=(n+1)/2;
	int o=n&1;
	a[n][1]=l;
	for(int i=n-1;i;i--){
		if(o) l--,a[i][1]=l;
		else r++,a[i][1]=r;
		o^=1;
	}
//	cout<<l<<' '<<r<<'\n';
	for(int i=1;i<=n;i++){
		for(int j=2;j<=i;j++){
			if(j&1) a[i][j]=a[i][j-1]-(j-1);
			else a[i][j]=a[i][j-1]+(j-1);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++) cout<<a[i][j]<<' ';
		cout<<'\n';
	}
	return 0;
}
```

---


# [JLOI2008] 将军

## 题目描述

刘先生最近在学习国际象棋，使用一个叫 jloi-08 的游戏软件。在这个游戏里，不但可以和电脑普通地对弈，还可以学习著名的棋局，还有针对初学者的规则指导等丰富功能。但是…大小却要 1.4G T\_T。

言归正传，在这个软件里，为了让玩家更好地理解和运用各个棋子，有很多趣味的游戏，比如以下就是一个：

给出一个棋盘和一些棋子，让你把这些棋子摆放在棋盘上，使得两两不互相攻击。你的得分由你摆放上去的棋子的个数与种类有关。

这个游戏很复杂，刘先生老是玩不到高分。于是电脑便降低了难度，替刘先生摆上了一些棋子，最后只给你任意多个 bishop（教主）。

现在刘先生便要考一考你，在电脑给出的这张棋盘上，最多能放几个 bishop。

国际象棋中一共有 6 种棋子：

- king（国王）；
- queen（皇后）；
- bishop（教主）；
- knight（骑士）；
- rook（车）；
- pawn（步兵）。

各棋子的攻击范围如下：

- queen 可以攻击与它在同一行，同一列，同一条对角线的棋子；
- knight 的攻击范围如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/2669.png)

- rook 攻击水平和垂直两条线上的所有格子；
- pawn 攻击前方两条斜线方向各一格(“前方”指 $x$ 递增的方向，$x$ 行 $y$ 列）；
- king 攻击周围 8 个方向各 1 格；
- bishop 攻击两条对角线上的所有格子。

除 knight 以外，所有棋子的攻击范围均会被别的棋子所阻挡。

可惜的是这个软件也不是顶优秀，给出的棋盘上的棋子可能互相会攻击，不过你不用理会这些，你只要保证你摆放的 bishop 不与它们以及不互相攻击就可以了。

## 说明/提示

```plain
BBN
...
...
```

```plain
BBN
...
B..
```

虽然看上去下面的方法比上面的优秀，但是 N 被第三行的 B 攻击了。也就是说，你需要避免的有 2 种情况： 你摆放的 bishop 之间的互相攻击以及你摆放的 bishop 与预先摆放好的棋子之间的互相攻击；但不用考虑预先摆放好的棋子之间的互相攻击。


## 样例 #1

### 输入

```
3 3
..N
...
...
```

### 输出

```
2```

# 题解

## 作者：GNAQ (赞：8)

#### (我不知道我前面那位哥们怎么跑到如此快的 我猜他是打表过的，因为仅有的一篇题解教唆你去打表。。）

考虑二分图匹配。非常迷的一点是Dinic跑不过但是匈牙利可以。

首先因为斜行不好做，所以处理的时候把棋盘转45°。

![](https://cdn.luogu.com.cn/upload/pic/24174.png)

然后我们对于每个单位，在原有的攻击范围内添加上一个`Bishop`的攻击范围，这样可以使得每个单位都不被它攻击。

然后判定哪些格子不会被攻击到，可以二分图匹配了。

建二分图的时候把坐标转换为转45°之后的图再建图。行列匹配。

代码写的很好懂，可以看一下。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<algorithm>
#include<iterator>
#include<queue>
#include<cmath>
#include<vector>
#include<cstdlib>
using namespace std;

struct ed
{
    int pre,to;
}edge[1000010]={0,0};
int at=1,ptr[10010]={0},matchs[10010],vis[10010],ansf;

int n,m,mapsiz;
char mapx[2200][2200]={0};
bool av[2200][2200]={0},l[2200]={0},h[2200]={0};
int pau[2200][2]={0};

int wx[8]={0,-1,-1,-1,0,1,1,1},wy[8]={-1,-1,0,1,1,1,0,-1};
int KX[8]={-1,-2,-2,-1,1,2,2,1},KY[8]={-2,-1,1,2,2,1,-1,-2};

inline void Insert(int fx,int tx)
{
    at++;
	edge[at].pre=ptr[fx];
	edge[at].to=tx;
	ptr[fx]=at;
}

inline bool Find(int x,int src)
{
	for (int prex=ptr[x];prex;prex=edge[prex].pre) if (vis[edge[prex].to]!=src)
	{
		vis[edge[prex].to]=src;
		if (!matchs[edge[prex].to] || Find(matchs[edge[prex].to],src)) { matchs[edge[prex].to]=x; return true; }
	}
	return false;
}

inline void BuildG()
{
	int _x,_y;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++) if (!av[i][j])
		{
			_x=pau[i][0]+j-1; _y=pau[i][1]+j-1;
			if ((!h[_x]) && (!l[_y])) Insert(_x,_y+mapsiz);
		}
}

inline void GoB(int _x,int _y)
{
	av[_x][_y]=true;
	int i=pau[_x][0]+_y-1,j=pau[_x][1]+_y-1;
	h[i]=true; l[j]=true;
}
inline void GoK(int _x,int _y)
{
	GoB(_x,_y);
	for (int w=0;w<=7;w++) av[_x+wx[w]][_y+wy[w]]=true;
}
inline void GoQ(int _x,int _y)
{
	int wayx[4]={0,-1,0,1},wayy[4]={-1,0,1,0};
	GoB(_x,_y);
	for (int w=0;w<=3;w++) for (int i=1;;i++)
	{
		if (mapx[_x+wayx[w]*i][_y+wayy[w]*i]!='.') break;
		av[_x+wayx[w]*i][_y+wayy[w]*i]=true;
	}
}
inline void GoN(int _x,int _y)
{
	GoB(_x,_y);
	for (int w=0;w<=7;w++) if (_x+KX[w]>0 && _y+KY[w]>0) av[_x+KX[w]][_y+KY[w]]=true;
}

int main()
{
	scanf("%d%d",&n,&m);mapsiz=2*max(n,m)-1;
	for (int i=1;i<=n;i++) scanf("%s",mapx[i]+1);
	
	pau[1][0]=1; pau[1][1]=m;
	for (int i=2;i<=n;i++) { pau[i][0]=pau[i-1][0]+1; pau[i][1]=pau[i-1][1]-1; }
	
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
		{
			if (mapx[i][j]=='.') continue;
			switch (mapx[i][j])
			{
				case 'K':
					GoK(i,j);
					break;
				case 'Q':
					GoQ(i,j);
					break;
				case 'R':
					GoQ(i,j);
					break;
				case 'B':
					GoB(i,j);
					break;
				case 'P':
					GoB(i,j);
					break;
				case 'N':
					GoN(i,j);
					break;
			}
		}
	
	BuildG();
	for (int i=1;i<=mapsiz;i++) ansf+=Find(i,i);
	printf("%d\n",ansf);
	return 0;
}
```

---

## 作者：caizehua (赞：4)

[2022-08-29] 更正[frankly6](https://www.luogu.com.cn/user/223058)提出的错误，在此表达感谢。

[题目链接](https://www.luogu.com.cn/problem/P3882)
# 前置知识	
[P2825 [HEOI2016/TJOI2016]游戏](https://www.luogu.com.cn/problem/P2825)
注：本题做法与上题做法**类似**。
用到的算法：
- 图论——二分图——匈牙利算法（最大匹配）
- 建边——链式前向星。
# 解题思路
题目要求输出在题目给定的棋盘上能放最多的bishop（象）。
因为象的行走路线为对角线（斜线），不好写，所以我们将整个棋盘顺时针旋转 **45°** （如图）。
![](https://img-blog.csdnimg.cn/d154d46febbd4f4082d1c3493b59e0d1.jpeg#pic_center)
由图可以看出，原先棋盘的对角线在顺时针旋转45°后变成了行和列。
由此，我们考虑**行列匹配**。
### 一、输入
**这里有一个巨坑点（作者这个蒟蒻被这个东西坑了一周）。**
输入原棋盘时，**建议**一行一行的输入并且输入整个棋盘后再进行操作，否则**有可能**“听取WA声一片”。

### 二、存储旋转后的棋盘
我们建立一个结构体 $node$ 。

```cpp
struct node{
	int xx,yy;
	int can; 
}a[2200][2200];
```
 $a[i][j].xx$ 表示在原棋盘中 $i$ 行 $j$ 列的格子在旋转后位于 $xx$ 行。     
 $a[i][j].yy$ 表示旋转后位于 $yy$ 列。
 
 $can$ 的值分三种：
 -  $can$ = 0
 	该点可以放置象，且不会攻击到棋盘上原有棋子。
 -   $can$ = 1
 	该点已有棋子，不可放置象，会阻挡**除马以外**的攻击范围。
 -   $can$ = 2
 	该点未有棋子，但不可放置象，否则会攻击原有棋子或被原有棋子攻击，但**不阻挡任何棋子的攻击范围**。
---
接下来，我们看具体如何操作。
 ###### 1. 旋转后的格子位置
我们假设 $n$ = 4 , $m$ = 5。
先观察原棋盘格子的位置。
![](https://img-blog.csdnimg.cn/98ed7f06adc24664aeb107df0d5f3727.jpeg#pic_center)
再看旋转后格子的位置。
![](https://img-blog.csdnimg.cn/edf793f782a5448cb289ea3cb321837b.jpeg#pic_center)
不难发现，棋盘旋转45°后，原位置为 $(i,j)$ 的格旋转到了 $(i+j-1,j+n-i)$  的位置。
***

###### 2.标记攻击范围
国际象棋中一共有 6 种棋子：
`K` – king（国王），`Q` – queen（皇后），`B` – bishop（象，教主），`N` – knight（马、骑士），`R` – rook（车），`P` – pawn（兵）。

在原棋盘上，棋子的攻击范围分别如下：
![攻击范围](https://img-blog.csdnimg.cn/0ba139e25d704c509b44e87c1874d1a3.jpeg#pic_center)
我们将棋子所在格子的 $can$ 标记为 $1$ , 将攻击范围标记为 $2$ 。
**注意：除马（ knight ）以外，其他棋子的攻击范围均会被棋子阻挡**。
![攻击范围被阻挡的例子](https://img-blog.csdnimg.cn/6d91d68cd1c24be9aafa924611316a80.jpeg#pic_center)
如上图，车（R）的攻击范围被 兵（P） 阻挡，无法攻击到绿色格子。

~~你以为这道题的思路到此就结束了？不，还没有。~~ 
再细读题目，发现题目有这样一句话：
>你需要避免的有 2 种情况： 你摆放的 bishop 之间的互相攻击以及**你摆放的 bishop 与预先摆放好的棋子之间的互相攻击**。

所以我们不仅要标记棋子原有的攻击范围，还要再加上一个象的攻击范围。

### 三、二分图最大匹配
在【一】里讲过，旋转45°后，象的攻击范围由对角线变为行和列。由此，我们可以行列匹配。
我们开两个数组 $r$ 和 $c$ 。

 $r$ 数组存储象在新棋盘的**水平方向**上的每一个不同的攻击范围，
 $c$ 数组存储象在新棋盘的**竖直方向**上的每一个不同的攻击范围

下面举个简单的例子来进一步理解。
红色点为 $N$ 的攻击范围
我们设新棋盘的水平方向上不同的攻击范围的标记为 $lenr$ 。
1.  $lenr$ 每过一行需要加1,因为象在新棋盘上水平方向只能攻击到一行。
2. 如果遇到棋子， $lenr$ 也需要加1，因为棋子能阻挡象的攻击范围。

则完成标记后的 $r$ 数组如下：
![r](https://img-blog.csdnimg.cn/2de716f7101a4d4bab7badd8446e8e7f.jpeg#pic_center)
标记 $c$ 数组时同理，不作赘述。
下图为标记完成的 $c$ 数组。
![c](https://img-blog.csdnimg.cn/690e8b6ef6404973ae934e4380448205.jpeg#pic_center)
标记完成后，遍历新棋盘上的每一个点，若该点 $(i,j)$ 可以放置象，则建立边连接 $r_{i,j}$  与 $c_{i,j}$ (连接在该位置的象所能攻击到的两个方向的攻击范围编号)。

最后用匈牙利算法求最大匹配，就顺利切下这道题啦 ！
***
下面结合代码来理解吧！
# 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
using namespace std;
int head[1050000],to[1050000],ne[1050000],id;
int vis[20200],d[20200],n,m,maxx,ans;
int mp[2200][2200],r[2200][2200],c[2200][2200];
char s[1050][1050];
struct node{
	int xx,yy;
	int can; 
}a[2200][2200];

void B(int x,int y){
	for(int i=x-1,j=y-1;i>=1&&y>=1;i--,j--){
		if(s[i][j]!='.') break;
		a[i][j].can = 2;
	}
	for(int i=x+1,j=y+1;i<=n&&j<=m;i++,j++){
		if(s[i][j]!='.') break;
		a[i][j].can = 2;
	}
	for(int i=x+1,j=y-1;i<=n&&j>=1;i++,j--){
		if(s[i][j]!='.') break;
		a[i][j].can = 2;
	}
	for(int i=x-1,j=y+1;i>=1&&j<=m;i--,j++){
		if(s[i][j]!='.') break;
		a[i][j].can = 2;
	}
}
void K(int x,int y){
	int kx[8] = {-1,-1,-1,0,1,1,1,0};
	int ky[8] = {-1,0,1,1,1,0,-1,-1};
	for(int i=0;i<8;i++){
		if(a[x+kx[i]][y+ky[i]].can==0) a[x+kx[i]][y+ky[i]].can = 2;
	}
}
void R(int x,int y){
	for(int i=y+1;i<=m;i++){
		if(s[x][i]!='.') break;
		a[x][i].can = 2;
	}
	for(int i=y-1;i>=1;i--){
		if(s[x][i]!='.') break;
		a[x][i].can = 2;
	}
	for(int i=x+1;i<=n;i++){
		if(s[i][y]!='.') break;
		a[i][y].can = 2;
	}
	for(int i=x-1;i>=1;i--){
		if(s[i][y]!='.') break;
		a[i][y].can = 2;
	}
}
void P(int x,int y){
	if(a[x-1][y-1].can==0&&s[x-1][y-1]=='.') a[x-1][y-1].can = 2;
	if(a[x-1][y+1].can==0&&s[x-1][y+1]=='.') a[x-1][y+1].can = 2;
}
void Q(int x,int y){
	R(x , y);
	B(x , y);
}
void N(int x,int y){
	int nx[8] = {-1,-2,-2,-1,1,2,2,1};
	int ny[8] = {-2,-1,1,2,2,1,-1,-2};
	for(int i=0;i<8;i++){
		if(x+nx[i]<1||x+nx[i]>n||y+ny[i]<1||y+ny[i]>m) continue;
		if(s[x+nx[i]][y+ny[i]]!='.') continue;
		a[x+nx[i]][y+ny[i]].can = 2;
	}
}

void add(int x,int y){//链式前向星建边
	to[++id] = y;
	ne[id] = head[x];
	head[x] = id;
}
void init(){//标记r,c数组
	int lenr=1;
	for(int i=1;i<=n+m-1;i++){
		for(int j=1;j<=n+m-1;j++){
			if(mp[i][j]==-1) continue;
			if(!mp[i][j]) r[i][j] = lenr;
			else if(mp[i][j]==1) lenr++;
		}
		lenr++;
	}
	maxx = lenr;
	
	int lenc=1;
	for(int i=1;i<=n+m-1;i++){
		for(int j=1;j<=n+m-1;j++){
			if(mp[j][i]==-1) continue;
			if(!mp[j][i]) c[j][i] = lenc;
			else if(mp[j][i]==1) lenc++;
		}
		lenc++;
	}
	
	for(int i=1;i<=n+m-1;i++){
		for(int j=1;j<=n+m-1;j++){
			if(!mp[i][j]) add(r[i][j],c[i][j]);
		}
	}
}

bool dfs(int u){//匈牙利算法
	for(int i=head[u];i;i=ne[i]){
		int v = to[i];
		if(vis[v]) continue;
		vis[v] = 1;
		if(!d[v] || dfs(d[v])){
			d[v] = u;
			return true;
		}
	}
	return false;
}
int main(){
	scanf("%d %d",&n,&m);
	for (int i=1;i<=n;i++){
		scanf("%s",s[i]+1);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			node f = {i+j-1 , j+n-i , a[i][j].can};
			if(s[i][j]=='.'){
				a[i][j] = f;
				continue;
			}
			
			f.can = 1;
			a[i][j] = f;
			
			if(s[i][j]=='B'){
				B(i , j);
			}
			else if(s[i][j]=='K'){
				K(i , j);
				B(i , j);
			}
			else if(s[i][j]=='R'){
				R(i , j);
				B(i , j);
			}
			else if(s[i][j]=='P'){
				P(i , j);
				B(i , j);
			}
			else if(s[i][j]=='Q'){
				Q(i , j);
			}
			else if(s[i][j]=='N'){
				N(i , j);
				B(i , j);
			}
		}
	}
	memset(mp,-1,sizeof(mp));
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			mp[a[i][j].xx][a[i][j].yy] = a[i][j].can; 
		}
	}
		
	init();
		
	for(int i=1;i<maxx;i++){
		memset(vis,0,sizeof(vis));
		if(dfs(i)) ans++;
	}
	printf("%d\n",ans);
	
	return 0;
}
```


---

## 作者：lly66666 (赞：3)

**二分图经典题目**

主题思路：预处理出原本棋子能攻击的所有点，由于 bishop 的攻击是斜线，所以我们可以将棋盘旋转 45°，然后横竖划分，最后跑一遍最大匹配。

预处理：

- 国王或骑士：遍历八个方向能攻击到的区域；
- 步兵：记录能攻击的两点 $(x + 1, y - 1)$ 和 $(x + 1, y + 1)$；
- 车，从该点向左、右、上、下四个方向延伸，记录途中的每个点，若碰到棋盘边界或已放置棋子则停止；
- 教主：用类似车的方式向左上、左下、右上、右下四个方向延伸，记录途中的每个点即可；
- 皇后，攻击方式直接复合车和教主即可。

然后跑二分图最大匹配模板即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
char a[1005][1005];
int n, m, ans, flag[1005][1005], cp[1000005], col[1000005];
vector<int> g[1000005];
int dx[9] = {0,0,0,1,-1,1,1,-1,-1}, dy[9] = {0,1,-1,0,0,1,-1,1,-1};
int kx[9] = {0,1,1,2,2,-1,-1,-2,-2}, ky[9] = {0,2,-2,1,-1,2,-2,1,-2};
bool check(int x, int y) {
    return (1 <= x && x <= n && 1 <= y && y <= m && flag[x][y] != 2);
}
void bishop(int x, int y) {
    for(int i = 5; i <= 8; i ++) {
        int tx = x + dx[i], ty = y + dy[i];
        while(check(tx, ty)) {
            flag[tx][ty] = 1;
            tx += dx[i];
            ty += dy[i];
        }
    }
}
void king(int x,int y){
	for(int i=1;i<=8;i++){
		int tx=x+dx[i],ty=y+dy[i];
		if(check(tx,ty)) flag[tx][ty]=1;
	}
}
void knight(int x,int y){
	for(int i=1;i<=8;i++){
		int tx=x+kx[i],ty=y+ky[i];
		if(check(tx,ty)) flag[tx][ty]=1;
   }
}
void pawn(int x,int y){
   int tx=x+1,ty=y-1;
   if(check(tx,ty)) flag[tx][ty]=1;
   tx=x+1; ty=y+1;
   if(check(tx,ty)) flag[tx][ty]=1;
}
void rook(int x,int y){
	for(int i=1;i<=4;i++){
		int tx=x+dx[i],ty=y+dy[i];
		while(check(tx,ty)){
			flag[tx][ty]=1; tx+=dx[i]; ty+=dy[i];
		}
	}
}
void queen(int x,int y){
   bishop(x,y); rook(x,y);
}
bool dfs(int x, int fa) {
    for(int i = 0; i < g[x].size(); i ++) {
        int v = g[x][i];
        if(col[v] != fa) {
            col[v] = fa;
            if(!cp[v] || dfs(cp[v], fa)) {
                cp[v] = x;
                return true;
            }
        }
    }
    return false;
}
int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) {
        for(int j = 1; j <= m; j ++) {
            cin >> a[i][j];
            if(a[i][j] != '.') flag[i][j] = 2;
        }
    }
    for(int i = 1; i <= n; i ++) {
        for(int j = 1; j <= m; j ++) {
            if(a[i][j] == '.') continue;
            bishop(i, j);
            if(a[i][j] == 'B') bishop(i, j);
            else if(a[i][j] == 'K') king(i, j);
            else if(a[i][j] == 'N') knight(i, j);
            else if(a[i][j] == 'P') pawn(i, j);
            else if(a[i][j] == 'Q') queen(i, j);
            else if(a[i][j] == 'R') rook(i, j);
        }
    }
    for(int i = 1; i <= n; i ++) {
        for(int j = 1; j <= m; j ++) {
            if(!flag[i][j]) g[j - i + n].push_back(i + j + m + n - 1);
        }
    }
    for(int i = 1; i <= m + n - 1; i ++) {
        ans += dfs(i, i);
    }
    cout << ans;
    return 0;
}
```

完结撒花！

管理员大大大大大大大大大大大大大大大大大大大大求过。

---

## 作者：WFHFAQFXY (赞：1)

# 前置知识
二分图匹配（这里用的是匈牙利算法）
# 主体思路
观察题面。

### 现在是预处理原图

发现每一个已有的点之间不用管会不会攻击，只需要关注新放的位置即可。

观察后我们发现，如果正着枚举每一个点后再看是否会和原来的冲突很麻烦，不如反着来看，原来的点被新放的攻击了，也就可以看成原来的点都是斜着攻击的，被攻击的地方不能放新的棋子。

而且每个原棋子之间的攻击范围也会被原本有的棋子挡住。

总共细节也就这么多了，我这里把原棋子位置和能否可以放点用两个不同的数组存下来。

### 接下来是二分图建图

发现每一个点要么被左上到右下覆盖，要么被左下到右上的覆盖，否则这个位置就可以放一个新的棋子，会更优。

那么我们就可以预处理出每一个能放的点会被哪两个东西覆盖（编号），然后跑二分图匹配即可。

# AC 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define sn 1000005
using namespace std;
int vt[sn],mat[sn],n,m,ans,mpu[1050][1050],mpd[1050][1050],cnt,tnc,hor[8][2]={{2,1},{-2,1},{2,-1},{-2,-1},{-1,2},{1,2},{-1,-2},{1,-2}};
char gt[1050][1050];
bool put[1050][1050],vis[1005][1005];
vector<int> gr[sn];
bool dfs(int nw,int tg)
{
	if(vt[nw]==tg)
	{
		return false;
	}
	vt[nw]=tg;
	for(auto i:gr[nw])
	{
		if(!mat[i]||dfs(mat[i],tg))
		{
			mat[i]=nw;
			return true;
		}
	}
	return false;
}
void solve();
signed main(){
	solve();
	return 0;
}
void solve()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>gt[i][j];
		}
	}
	for(int i=0;i<=n+1;i++)
	{
		for(int j=0;j<=m+1;j++)
		{
			if(i==0||i==n+1||j==0||j==m+1||gt[i][j]!='.')
			{
				put[i][j]=true;
				vis[i][j]=true;
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(vis[i][j])
			{
				for(int k=1;;k++)
				{
					put[i-k][j-k]=true;
					if(vis[i-k][j-k])
					{
						break;
					}
				}
				for(int k=1;;k++)
				{
					put[i+k][j-k]=true;
					if(vis[i+k][j-k])
					{
						break;
					}
				}
				for(int k=1;;k++)
				{
					put[i-k][j+k]=true;
					if(vis[i-k][j+k])
					{
						break;
					}
				}
				for(int k=1;;k++)
				{
					put[i+k][j+k]=true;
					if(vis[i+k][j+k])
					{
						break;
					}
				}
				if(gt[i][j]=='K')
				{
					put[i-1][j]=true;
					put[i+1][j]=true;
					put[i][j-1]=true;
					put[i][j+1]=true;
				}
				if(gt[i][j]=='N')
				{
					for(int k=0;k<=7;k++)
					{
						int dx=i+hor[k][0];
						int dy=j+hor[k][1];
						if(dx<=n&&dy<=m&&dx>=1&&dy>=1)
						{
							put[dx][dy]=true;
						}
					}
				}
				if(gt[i][j]=='P')
				{
					put[i+1][j-1]=true;
					put[i+1][j+1]=true;
				}
				if(gt[i][j]=='R')
				{
					for(int k=i+1;;k++)
					{
						put[k][j]=true;
						if(vis[k][j])
						{
							break;
						}
					}
					for(int k=j+1;;k++)
					{
						put[i][k]=true;
						if(vis[i][k])
						{
							break;
						}
					}
					for(int k=i-1;;k--)
					{
						put[k][j]=true;
						if(vis[k][j])
						{
							break;
						}
					}
					for(int k=j-1;;k--)
					{
						put[i][k]=true;
						if(vis[i][k])
						{
							break;
						}
					}
				}
				if(gt[i][j]=='Q')
				{
					for(int k=i+1;;k++)
					{
						put[k][j]=true;
						if(vis[k][j])
						{
							break;
						}
					}
					for(int k=j+1;;k++)
					{
						put[i][k]=true;
						if(vis[i][k])
						{
							break;
						}
					}
					for(int k=i-1;;k--)
					{
						put[k][j]=true;
						if(vis[k][j])
						{
							break;
						}
					}
					for(int k=j-1;;k--)
					{
						put[i][k]=true;
						if(vis[i][k])
						{
							break;
						}
					}
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(!vis[i][j])
			{
				if(vis[i-1][j-1])
				{
					tnc++;
					mpd[i][j]=tnc;
				}
				else
				{
					mpd[i][j]=mpd[i-1][j-1];
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(!vis[i][j])
			{
				if(vis[i-1][j+1])
				{
					cnt++;
					mpu[i][j]=cnt;
				}
				else
				{
					mpu[i][j]=mpu[i-1][j+1];
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(!put[i][j])
			{
				gr[mpu[i][j]].push_back(mpd[i][j]);
			}
		}
	}
	for(int i=1;i<=cnt;i++)
	{
		if(dfs(i,i))
		{
			ans++;
		}
	}
	cout<<ans;
}
```

# 类似题目

（只是方法类似）

[10945](https://www.luogu.com.cn/problem/P10945)

[6062](https://www.luogu.com.cn/problem/P6062)

[2825](https://www.luogu.com.cn/problem/P2825)

---

## 作者：lht1217 (赞：1)

### [P3882 [JLOI2008] 将军](https://www.luogu.com.cn/problem/P3882)

 本题只能说是一道**二分图**水题。
 

------------

 整道题主要分两步走：
 
 - **预处理**出，能放 bishop 的地方（此处分为两类）。
 1. $(x,y)$ 这个节点不能被其它棋子攻击到。
 2. $(x,y)$ 这个节点放 bishop 攻击不到其他棋子（蒟蒻被这个卡了好久，**仔细审题**）。

 - **二分图最大匹配**（匈牙利算法）。
 
 1. 左斜线形如 `/`，右斜线形如 `\`。将这两类进行匹配。如何处理这两组。请读者自行思考。
 
 附上参考代码：
 ```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1030
#define re register
#define il inline
#define ll long long
il int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-48; ch=getchar();}
    return x*f;
}
il void write(int x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int n,m,ans;
char mp[N][N];
int use[N][N];
int dx[8]={ 0, 0, 1,-1, 1, 1,-1,-1};
int dy[8]={ 1,-1, 0, 0, 1,-1, 1,-1};
int kx[8]={ 1, 1, 2, 2,-1,-1,-2,-2};
int ky[8]={ 2,-2, 1,-1, 2,-2, 1,-2};
bool check(int x,int y){
	return (1<=x&&x<=n && 1<=y&&y<=m && use[x][y]!=2);
}
il void bishop(int x,int y){
	int tx,ty;
	for(re int i=4;i<8;i++){
		tx=x+dx[i]; ty=y+dy[i];
		while(check(tx,ty))
			use[tx][ty]=1,tx+=dx[i],ty+=dy[i];
	}
}
il void king(int x,int y){
	int tx,ty;
	for(re int i=0;i<8;i++){
		tx=x+dx[i],ty=y+dy[i];
		if(check(tx,ty))
			use[tx][ty]=1;
	}
}
il void knight(int x,int y){
	int tx,ty;
	for(re int i=0;i<8;i++){
		tx=x+kx[i]; ty=y+ky[i];
		if(check(tx,ty))
			use[tx][ty]=1;
	}
}
il void pawn(int x,int y){
	int tx,ty;
	tx=x+1; ty=y-1;
	if(check(tx,ty)) use[tx][ty]=1;
	tx=x+1; ty=y+1;
	if(check(tx,ty)) use[tx][ty]=1;
}
il void rook(int x,int y){
	int tx,ty;
	for(re int i=0;i<4;i++){
		tx=x+dx[i]; ty=y+dy[i];
		while(check(tx,ty))
			use[tx][ty]=1,tx+=dx[i],ty+=dy[i];
	}
}
il void queen(int x,int y){
	bishop(x,y);
	rook(x,y);
}
il void init(){
	n=read(); m=read();
	for(re int i=1;i<=n;i++){
		for(re int j=1;j<=m;j++){
			cin>>mp[i][j];
			if(mp[i][j]!='.') use[i][j]=2;
		}
	}
}
il void pre(){
	for(re int i=1;i<=n;i++){
		for(re int j=1;j<=m;j++){
			if(mp[i][j]=='.') continue;
			bishop(i,j);
			switch(mp[i][j]){
				case 'B':bishop(i,j);break;
				case 'K':king(i,j);  break;
				case 'N':knight(i,j);break;
				case 'P':pawn(i,j);  break;
				case 'Q':queen(i,j); break;
				case 'R':rook(i,j);  break;
			}
		}
	}
}
struct node{
	int v,nxt;
}edge[N*N];
int head[N<<1],cnt;
il void add(int u,int v){
	edge[++cnt]=node{v,head[u]};
	head[u]=cnt;
}
il void build(){
	for(re int i=1;i<=n;i++)
		for(re int j=1;j<=m;j++)
			if(!use[i][j])
				add(j-i+n,i+j+m+n-1);
}
int vis[N<<2];
int link[N<<2];
il bool dfs(int u,int id){
	for(re int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].v;
		if(vis[v]!=id){
			vis[v]=id;
			if(!link[v]||dfs(link[v],id)){
				link[v]=u;
				return 1;
			}
		}
	}
	return 0;
}
il void solve(){
	for(re int i=1;i<=m+n-1;i++)
		if(dfs(i,i))
			ans++;
	write(ans);putchar('\n');
}
int main(){
	init();
	pre();
	build();
	solve();
	return 0;
}
```


---

## 作者：__DDDDDD__ (赞：1)

# 题面描述

[$Link$](https://www.luogu.com.cn/problem/P3882)

给定一个大小为 $n \times m$ 的国际象棋棋盘，棋盘上摆有部分棋子（包括国王、王后、教主、骑士、车、步兵），求至多可以在空位上再摆放多少教主，使得它们与已有棋子互不攻击。

# 题目分析

大致思路是先读入图，计算出可以放置的区域，然后进行二分图匹配。

可以使用一个 $used$ 数组记录每个点的状态，若 $used[i][j]=0$ 则该点可放置教主，否则不行。为方便后文中皇后、车、教主的操作，定义当 $used[i][j]=2$ 时表示该点有棋子。

接下来考虑每种棋子：

- 国王或者骑士，可以定义一个方向数组，然后遍历八个方向记录能攻击到的区域；

- 步兵，记录一下能攻击到的斜向两个点 $(x+1,y-1)$ 和 $(x+1,y+1)$；

- 车，从该点向左、右、上、下四个方向延伸，记录途中的每个点，若碰到棋盘边界或已放置棋子（即 $used[i][j]=2$）则停止；

- 教主，将棋盘看作一个平面直角坐标系，设当前点为 $(x,y)$，则该棋能攻击到的区域为两个经过 $(x,y)$ 的一次函数 $y=x+b_{1}$、$y=-x+b_{2}$。我们可以求出 $b_{1}$、$b_{2}$，然后用类似车的方式向左上、左下、右上、右下四个方向延伸，记录途中的每个点即可；

- 皇后，攻击方式直接复合车和教主即可。

注意到题目要求为不能互相攻击，即放置的教主不能攻击到当前棋子，故对于每个棋子都要额外算一遍教主的攻击范围。

对于二分图建图，可以采用类似计算教主攻击范围的方法，计算出每个空位的 $b_{1}$、$b_{2}$，以 $(b_{1},b_{2})$ 为该点坐标在二分图两侧的 $b_{1}$、$b_{2}$ 之间连边。最后跑一遍二分图最大匹配即可。

其他细节见下方代码及注释：

~~（思路较暴力，故速度较慢qwq）~~

# 代码+注释

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+10;	// 自信乱开（bushi 
int n,m;
char mp[1111][1111];	// 存原图 
int used[1111][1111];	// 存储点的状态（为0表示能放置，为2表示该点有棋子） 

const int dirKing[8][2]={{1,1},{0,1},{-1,1},{1,0},{-1,0},{-1,-1},{0,-1},{1,-1}};	// 国王的方向数组 
inline void King(int x,int y){	// 国王 
	for(int i=0;i<8;i++){
		int dx=x+dirKing[i][0],dy=y+dirKing[i][1];
		if(dx<1||dx>n||dy<1||dy>m||used[dx][dy])continue;
		used[dx][dy]=1;
	}
}

const int dirKnight[8][2]={{1,2},{2,1},{-1,2},{2,-1},{-2,1},{1,-2},{-1,-2},{-2,-1}};// 骑士的方向数组 
inline void Knight(int x,int y){	// 骑士 
	for(int i=0;i<8;i++){
		int dx=x+dirKnight[i][0],dy=y+dirKnight[i][1];
		if(dx<1||dx>n||dy<1||dy>m||used[dx][dy])continue;
		used[dx][dy]=1;
	}
}

inline void Bishop(int x,int y){	// 教主 
	int b=y-x;	// y=x+b
	for(int i=x-1;i>0;i--){		// 左下 
		int j=i+b;
		if(j<1||j>m||used[i][j]==2)break;
		used[i][j]=1;
	}
	for(int i=x+1;i<=n;i++){	// 右上 
		int j=i+b;
		if(j<1||j>m||used[i][j]==2)break;
		used[i][j]=1;
	}
	b=x+y;	// y=-x+b
	for(int i=x-1;i>0;i--){		// 左上 
		int j=-i+b;
		if(j<1||j>m||used[i][j]==2)break;
		used[i][j]=1;
	}
	for(int i=x+1;i<=n;i++){	// 右下 
		int j=-i+b;
		if(j<1||j>m||used[i][j]==2)break;
		used[i][j]=1;
	}
}

inline void Rook(int x,int y){	// 车 
	for(int i=x-1;i>0;i--){		// 左 
		if(used[i][y]==2)break;
		used[i][y]=1;
	}
	for(int i=x+1;i<=n;i++){	// 右 
		if(used[i][y]==2)break;
		used[i][y]=1;
	}
	for(int i=y-1;i>0;i--){		// 上 
		if(used[x][i]==2)break;
		used[x][i]=1;
	}
	for(int i=y+1;i<=m;i++){	// 下 
		if(used[x][i]==2)break;
		used[x][i]=1;
	}
}

inline void Queen(int x,int y){	// 皇后 
	Bishop(x,y);
	Rook(x,y);	// 直接复合车与教主 
}

inline void Pawn(int x,int y){	// 步兵 
	int dx=x+1,dy=y-1;
	if(dx>1&&dx<=n&&dy>1&&dy<=m&&!used[dx][dy]){	// 左前方 
		used[dx][dy]=1;
	}
	dy=y+1;
	if(dx>1&&dx<=n&&dy>1&&dy<=m&&!used[dx][dy]){	// 右前方 
		used[dx][dy]=1;
	}
}

int head[maxn],ver[maxn],Next[maxn],tot=1;	// 前向星存图 
inline void addedge(int x,int y){
	ver[++tot]=y;
	Next[tot]=head[x];head[x]=tot;
}

int vis[maxn],match[maxn];	// 匈牙利算法 
inline bool dfs(int x,int id){
	for(int i=head[x];i;i=Next[i]){
		int y=ver[i];
		if(vis[y]!=id){
			vis[y]=id;
			if(!match[y]||dfs(match[y],id)){
				match[y]=x;
				return 1;
			}
		}
	}
	return 0;
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>mp[i][j];
			if(mp[i][j]!='.')used[i][j]=2;	// 有棋子的区域记录为2 
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char ch=mp[i][j];
			
			if(ch=='K'){	// 不能攻击摆放的教主 
				King(i,j);
			}else if(ch=='Q'){
				Queen(i,j);
			}else if(ch=='N'){
				Knight(i,j);
			}else if(ch=='R'){
				Rook(i,j);
			}else if(ch=='P'){
				Pawn(i,j);
			}
			
			if(ch!='.')Bishop(i,j);	// 不能被摆放的教主攻击 
		}
	}
	for(int i=1;i<=n;i++){	// 建图 
		for(int j=1;j<=m;j++){
			if(used[i][j]>0)continue;
			int b1=j-i+n,b2=i+j+(m+n-1);
			// 为防止建图错误与点冲突，这里统一将 b1+=n，b2+=(m+n-1) 
			addedge(b1,b2);
		}
	}
	int ans=0;
	for(int i=1;i<=m+n-1;i++){	// 匈牙利算法 
		if(dfs(i,i))ans++;
	}
	cout<<ans<<endl;
	return 0;
}
```



---

## 作者：AvengerTwq (赞：0)

当我们放置 bishop（教主）棋子时，为了让它们两两不互相攻击，我们需要将它们放置在不同的对角线上。对于一个 $x \times y$ 的棋盘，共有 $x + y - 1$ 条对角线，其中从左上角到右下角的主对角线上有 $x$ 个格子，从右上角到左下角的次对角线上有 $y$ 个格子。

因此，我们可以分别统计每条对角线上放置的 bishop 的个数，然后将这些个数相加，即可得到最多可以放置的 bishop 的个数。

以下是详细的题解：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define LL long long
const int N = 2550;
const int M = 4050000;
const int INF = 0x3f3f3f3f;
int n, m;
char aa[N][N];
int f[N][N];
int a[N][N];
int head[M], to[M], ne[M], id, vis[N * 2], d[N * 2];
void add(int x, int y)
{
    to[++id] = y, ne[id] = head[x], head[x] = id;
}
bool flag(int x, int y)
{
    if (x < 1 || y < 1 || x > n || y > m)
        return false;
    return true;
}
void change(int x, int y, int xa, int ya)
{
    f[x][y] = 1;
    x = x + xa; 
    y = y + ya;
    if (!flag(x, y))
        return;
    change(x, y, xa, ya);
}
void init(int i, int j)
{
    f[i][j] = 1;
    change(i, j, -1, -1);
    change(i, j, 1, 1);
    change(i, j, 1, -1);
    change(i, j, -1, 1);
}
void hengshu(int x, int y)
{
    f[x][y] = 1;
    for (int i = x - 1; i >= 1; i--)
    {
        if (aa[i][y] != '.')
            break;
        f[i][y] = 1;
    }
    for (int i = x + 1; i <= n; i++)
    {
        if (aa[i][y] != '.')
            break;
        f[i][y] = 1;
    }
    for (int i = y + 1; i <= m; i++)
    {
        if (aa[x][i] != '.')
            break;
        f[x][i] = 1;
    }
    for (int i = y - 1; i >= 1; i--)
    {
        if (aa[x][i] != '.')
            break;
        f[x][i] = 1;
    }
}
bool dfs(int u)
{
    for (int i = head[u]; i; i = ne[i])
    {
        int v = to[i];
        if (vis[v])
            continue;
        vis[v] = 1;
        if (!d[v] || dfs(d[v]))
        {
            d[v] = u;
            return true;
        }
    }
    return false;
}
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        scanf("%s", aa[i] + 1);
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            char p = aa[i][j];
            if (p == 'K')
            {
                f[i][j] = f[i - 1][j] = f[i - 1][j - 1] = f[i - 1][j + 1] = f[i + 1][j] = f[i + 1][j + 1] = f[i + 1][j - 1] = f[i][j - 1] = f[i][j + 1] = 1;
                init(i, j);
            }
            else if (p == 'Q')
            {
                hengshu(i, j);
                init(i, j);
            }
            else if (p == 'B')
            {
                init(i, j);
            }
            else if (p == 'N')
            {
                int dx[] = {1, 1, 2, 2, -1, -1, -2, -2};
                int dy[] = {2, -2, -1, 1, -2, 2, 1, -1};
                for (int k = 0; k < 8; k++)
                {
                    int x = i + dx[k];
                    int y = j + dy[k];
                    if (flag(x, y))
                        f[x][y] = 1;
                }
                init(i, j);
            }
            else if (p == 'R')
            {
                hengshu(i, j);
                init(i, j);
            }
            else if (p == 'P')
            {
                init(i, j);
            }
        }
    }
    for (int i = 1; i <= n; i++)
    {
        int x, y;
        y = n - i + 1;
        x = i;
        for (int j = 1; j <= m; j++)
        {
            a[x++][y++] = (f[i][j] == 1) ? 2 : 1;
        }
    }
    for (int i = 1; i <= n + m - 1; i++)
    {
        for (int j = 1; j <= n + m - 1; j++)
        {
            if (a[i][j] & 1)
                add(i, j);
        }
    }
    int ans = 0;
    for (int i = 1; i <= n + m - 1; i++)
    {
        memset(vis, 0, sizeof(vis));
        if (dfs(i))
            ans++;
    }
    cout << ans << endl;
    return 0;
}
```

上述代码中，我们首先读取棋盘的大小和棋盘上每个格子的信息。然后，使用一个循环来遍历所有可能的对角线，从而统计每条对角线上放置的 bishop 的个数。注意，在遍历时，我们需要确保不越界。最后，将统计得到的 bishop 个数相加并取模，得到最多可以放置的 bishop 的个数，并输出结果。

请注意，由于最终的结果可能会非常大，我们需要在计算过程中保持取模操作以避免溢出。在这里，我们使用 `MOD` 来表示取模的值。

---

## 作者：龚祖豪曾用号 (赞：0)

### Description
刘先生最近在学习国际象棋，使用一个叫”jloi-08”的游戏软件。在这个游戏里，不但可以和电脑普通地对弈，还可以学习著名的棋局，还有针对初学者的规则指导等丰富功能。但是…大小却要1.4G T_T。

言归正传，在这个软件里，为了让玩家更好地理解和运用各个棋子，有很多趣味的游戏，比如以下就是一个：

给出一个棋盘和一些棋子，让你把这些棋子摆放在棋盘上，使得两两不互相攻击。你的得分由你摆放上去的棋子的个数与种类有关。

这个游戏很复杂，刘先生老是玩不到高分。于是电脑便降低了难度，替刘先生摆上了一些棋子，最后只给你任意多个bishop(教主)。

现在刘先生便要考一考你，在电脑给出的这张棋盘上，最多能放几个$bishop$。

国际象棋中一共有6种棋子：
```
king     (国王)
queen   (皇后)
bishop  (教主)
knight  (骑士)
rook    (车)
pawn   (步兵)
```
$queen$和$knight$不用说了；$rook$攻击水平和垂直两条线上的所有格子；$pawn$攻击前方两条斜线方向各一格；$king$攻击周围8个方向各1格；$bishop$攻击两条对角线上的所有格子。

除$knight$以外，所有棋子的攻击范围均会被别的棋子所阻挡。(“前方”指$x$递增的方向，$x$行$y$列)

可惜的是这个软件也不是顶优秀，给出的棋盘上的棋子可能互相会攻击，不过你不用理会这些，你只要保证你摆放的$bishop$不与它们以及不互相攻击就可以了。

#### Input
第一行是2个整数$x$,$ y$(1$\leqslant$x,y$\leqslant$1024)，

下面的x行每行y个字符表示棋盘，

其中：```K – king```, ```Q – queen```,``` B – bishop```, ```N – knight```, ```R – rook```, ```P – pawn```, ```“.” – blank```.

#### Output
仅一行一个数，表示最多能够摆放的bishop的个数。

#### Sample Input
```
3 3
..N
...
...
```
#### Sample Output
```2```

~~(恶心的大模拟……~~还好玩过国际象棋~~qwq)~~



预处理出原本的棋子能攻击的所有的点，然后由于bishop的攻击的斜线攻击，于是我们将棋盘旋转45°，再横竖划分，连边跑最大匹配即可

### CODE:

```
/*program from Wolfycz*/
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define inf 0x7f7f7f7f
using namespace std;
typedef long long ll;
typedef unsigned int ui;
typedef unsigned long long ull;
inline char gc(){
	static char buf[1000000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;
}
inline int frd(){
	int x=0,f=1; char ch=gc();
	for (;ch<'0'||ch>'9';ch=gc())	if (ch=='-')	f=-1;
	for (;ch>='0'&&ch<='9';ch=gc())	x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
inline int read(){
	int x=0,f=1; char ch=getchar();
	for (;ch<'0'||ch>'9';ch=getchar())	if (ch=='-')	f=-1;
	for (;ch>='0'&&ch<='9';ch=getchar())	x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
inline void print(int x){
	if (x<0)	putchar('-'),x=-x;
	if (x>9)	print(x/10);
	putchar(x%10+'0');
}
const int N=1<<10,M=1<<20;
bool l[(N<<1)+10],r[(N<<1)+10];//l:\ r:/
bool can[N+10][N+10];
char map[N+10][N+10];
int pre[M+10],now[(N<<1)+10],child[M+10];
int path[(N<<1)+10],vis[(N<<1)+10];
int tot,Time,n,m,Ans;
bool in_map(int x,int y){return x>0&&x<=n&&y>0&&y<=m;}
void join(int x,int y){pre[++tot]=now[x],now[x]=tot,child[tot]=y;}
bool Extra(int x){
	for (int p=now[x],son=child[p];p;p=pre[p],son=child[p]){
		if (vis[son]==Time)	continue;
		vis[son]=Time;
		if (!~path[son]||Extra(path[son])){
			path[son]=x;
			return 1;
		}
	}
	return 0;
}
void solve_King(int x,int y){
	for (int i=-1;i<=1;i++){
		for (int j=-1;j<=1;j++){
			int tx=x+i,ty=y+j;
			if (!in_map(tx,ty))	continue;
			can[tx][ty]=1;
		}
	}
}
void solve_Pawn(int x,int y){
	for (int i=-1;i<=1;i++){
		for (int j=-1;j<=1;j++){
			if (!i||!j)	continue;
			int tx=x+i,ty=y+j;
			if (!in_map(tx,ty))	continue;
			can[tx][ty]=1;
		}
	}
}
void solve_Rook(int x,int y){
	for (int i=x-1;i>=1;i--){
		if (map[i][y]!='.')	break;
		can[i][y]=1;
	}
	for (int i=x+1;i<=n;i++){
		if (map[i][y]!='.')	break;
		can[i][y]=1;
	}
	for (int j=y-1;j>=1;j--){
		if (map[x][j]!='.')	break;
		can[x][j]=1;
	}
	for (int j=y+1;j<=n;j++){
		if (map[x][j]!='.')	break;
		can[x][j]=1;
	}
}
void solve_Queen(int x,int y){solve_Rook(x,y);}
const int dx[8]={-2,-2,-1,-1,1,1,2,2};
const int dy[8]={-1,1,-2,2,-2,2,-1,1};
void solve_Knight(int x,int y){
	for (int k=0;k<8;k++){
		int tx=x+dx[k],ty=y+dy[k];
		if (!in_map(tx,ty))	continue;
		can[tx][ty]=1;
	}
}
int main(){
	memset(path,255,sizeof(path));
	n=read(),m=read();
	for (int i=1;i<=n;i++){
		scanf("%s",map[i]+1);
		for (int j=1;j<=m;j++)
			if (map[i][j]!='.')
				l[i-j+m]=1,r[i+j-1]=1;
	}
	for (int i=1;i<=n;i++){
		for (int j=1;j<=m;j++){
			if (map[i][j]=='K')	solve_King(i,j);
			if (map[i][j]=='P')	solve_Pawn(i,j);
			if (map[i][j]=='R')	solve_Rook(i,j);
			if (map[i][j]=='Q')	solve_Queen(i,j);
//			if (map[i][j]=='B')	solve_Bishop(i,j);
			if (map[i][j]=='N')	solve_Knight(i,j);
		}
	}
	for (int i=1;i<=n;i++){
		for (int j=1;j<=m;j++){
			if (can[i][j]|l[i-j+m]||r[i+j-1])	continue;
			join(i-j+m,i+j-1);
		}
	}
	for (int i=1;i<n+m;i++){
		++Time;
		if (Extra(i))	Ans++;
	}
	printf("%d\n",Ans);
	return 0;
}
```

---


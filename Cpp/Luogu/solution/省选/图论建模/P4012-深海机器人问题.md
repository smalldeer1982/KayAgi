# 深海机器人问题

## 题目描述

深海资源考察探险队的潜艇将到达深海的海底进行科学考察。


潜艇内有多个深海机器人。潜艇到达深海海底后，深海机器人将离开潜艇向预定目标移动。


深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。


每条预定路径上的生物标本的价值是已知的，而且生物标本只能被采集一次。


本题限定深海机器人只能从其出发位置沿着向北或向东的方向移动，而且多个深海机器人可以在同一时间占据同一位置。


用一个 $P\times Q$ 网格表示深海机器人的可移动位置。西南角的坐标为 $(0,0)$，东北角的坐标为 $(Q,P)$ 。



 ![](https://cdn.luogu.com.cn/upload/pic/12215.png) 

给定每个深海机器人的出发位置和目标位置，以及每条网格边上生物标本的价值。


计算深海机器人的最优移动方案， 使深海机器人到达目的地后，采集到的生物标本的总价值最高。



## 说明/提示

$1\leq P,Q\leq15$


$1\leq a\leq 4$


$1\leq b\leq 6$


## 样例 #1

### 输入

```
1 1
2 2
1 2
3 4
5 6
7 2
8 10
9 3
2 0 0
2 2 2```

### 输出

```
42```

# 题解

## 作者：liangbowen (赞：59)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P4012)

[更好的阅读体验？](https://www.cnblogs.com/liangbowen/p/17058926.html)

网络流 $24$ 题：最大费用最大流。还算简单且套路的一道题。

## 快捷步骤

这里先说两点。第一点，很多题解提到了，输入非常麻烦，需要类似于把图翻过来的操作。

这实际上是完全没必要的。你把全部点翻了和没翻一样，为啥要翻。而且翻了也不会让你理解起来更顺畅。

第二点，实际上，没必要费心思给每一个点编号。你直接用 `idx` 记录下全部点即可。

这也是非常显然的事情。

```cpp
s = ++idx, t = ++idx;
for (int i = 0; i <= n; i++)
    for (int j = 0; j <= m; j++)
        id[i][j] = ++idx; //给每个点一个编号
```

## 思路

首先我们只看每一个点。是典型的[方格取数](https://www.luogu.com.cn/problem/P2045)问题，可以考虑费用流。

对于一个相邻的、可以走到的点 $(x, y)$ 与 $(dx, dy)$，我们可以直接连边 $(x,y) \xrightarrow{cap=1\ cost=w} (dx,dy)$，表示：你想拿到这个格子的价值，那么你只能拿一次。

但是这样并不对。因为只是这样子，代表**这一条边只能走一次**。很显然这是不对的，因为你可以走这条边，但是什么都不拿。

于是我们再建一条 $(x,y) \xrightarrow{cap=\infty \ cost=0} (dx,dy)$，表示：这条边随便走，但是没有费用。

这就是第一步。我们再看一下源点与汇点：那 $a$ 个点就是源点，那 $b$ 个点就是汇点。

很套路地，建立多源多汇即可：超级源点连向每一个源点，超级汇点连向每一个汇点。

具体地：

+ 假设有 $k$ 个深海机器人从 $(x, y)$ 位置出发，就 $S \xrightarrow{cap=k \ cost=0} (x, y)$。
+ 假设有 $r$ 个深海机器人从 $(x, y)$ 位置作为目的地，就 $(x,y) \xrightarrow{cap=k \ cost=0} T$。

于是这题就做完了。您也可以尝试看看下面这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/gvulwwqh.png)

## 代码

最多的点数应该是 $nm$ 的级别（还要多一些），可以直接按 $400$ 算。

最多的边数大概是 $2 \times (2nm + 2nm + a + b) = 8nm+2a+2b \approx 8\times400+2\times10+2\times10=3240$（反正开多一点准没错）。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
/**********最大费用最大流模版，可以自己写**********/
const int N = 400, inf = 0x3f3f3f3f;
struct Edge {int now, nxt, w, cost;} e[3240];
int head[N], cur = 1;
void ad(int u, int v, int  w, int cost)
{
    e[++cur].now = v, e[cur].nxt = head[u], e[cur].w = w, e[cur].cost = cost;
    head[u] = cur;
}
void add(int u, int v, int w, int cost) {ad(u, v, w, cost), ad(v, u, 0, -cost);}
int dis[N], icost[N], pre[N]; bool inque[N];
int s, t;
bool spfa()
{
    queue <int> q;
    memset(dis, -0x3f, sizeof dis), memset(icost, 0, sizeof icost);
    q.push(s), dis[s] = 0, icost[s] = inf, inque[s] = true;
    while (!q.empty())
    {
        int u = q.front();
        q.pop(), inque[u] = false;
        for (int i = head[u]; i; i = e[i].nxt)
        {
            int v = e[i].now;
            if (!e[i].w) continue;
            if (dis[u] + e[i].cost > dis[v])
            {
                dis[v] = dis[u] + e[i].cost, pre[v] = i;
                icost[v] = min(icost[u], e[i].w);
                if (!inque[v]) q.push(v), inque[v] = true;
            }
        }
    }
    return icost[t] > 0;
}
int EK()
{
    int ans = 0;
    while (spfa())
    {
        int w = icost[t];
        ans += w * dis[t];
        for (int i = t; i != s; i = e[pre[i] ^ 1].now)
            e[pre[i]].w -= w, e[pre[i] ^ 1].w += w;
    }
    return ans;
}
/**********最大费用最大流模版，可以自己写**********/
int id[20][20];
int main()
{
    int a, b, n, m, idx = 0;
    scanf("%d%d%d%d", &a, &b, &n, &m);
    s = ++idx, t = ++idx;
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= m; j++)
            id[i][j] = ++idx; //给每个点编号
    for (int i = 0; i <= n; i++)
        for (int j = 0; j < m; j++)
        {
            int w;
            scanf("%d", &w);
            add(id[i][j], id[i][j + 1], 1, w), add(id[i][j], id[i][j + 1], inf, 0); //建立相邻点的边
        }
    for (int j = 0; j <= m; j++)
        for (int i = 0; i < n; i++)
        {
            int w;
            scanf("%d", &w);
            add(id[i][j], id[i + 1][j], 1, w), add(id[i][j], id[i + 1][j], inf, 0); //建立相邻点的边
        }
    while (a--) //建立超级源点与多个源点的边
    {
        int w, i, j;
        scanf("%d%d%d", &w, &i, &j);
        add(s, id[i][j], w, 0);
    }
    while (b--) //建立超级汇点与多个汇点的边
    {
        int w, i, j;
        scanf("%d%d%d", &w, &i, &j);
        add(id[i][j], t, w, 0);
    }
    cout << EK();
    return 0;
}
```

希望能帮助到大家！

---

## 作者：Dispwnl (赞：11)

很明显这是一道最大费用最大流，套用最小费用最大流的板子，只是在建图时费用为负

但是需要把图翻过来……即（样例）![](https://a-failure.github.io/img/study/shenhai.png) 

然后把各个点从坐标压为一个数表示$(x-1)\times Q+y$

每个点与南边的点连两条边，一条容量为$1$，费用为标本价值（先到的机器人）

一条容量为$inf$，费用为$0$，东边同理（注意建边顺序）

源点与给出的出发点连，容量为机器人数，汇点同理，然后输出最大费用（要取负）

代码：
```
# include<iostream>
# include<cstdio>
# include<cstring>
# include<queue>
# define pu(x,y) (x-1)*Q+y
using namespace std;
const int INF=1e8,MAX=400001,Max=1001,s=0,t=1000;
struct p{
    int x,y,dis,cn;
}c[MAX];
int a,b,P,Q,num,tot1;
int h[Max],d[Max],last[Max],pre[Max];
bool use[Max];
void add(int x,int y,int dis,int cn)
{
    c[num].x=h[y];c[num].y=x;c[num].dis=0,c[num].cn=-cn;h[y]=num++;
    c[num].x=h[x];c[num].y=y;c[num].dis=dis,c[num].cn=cn;h[x]=num++;
}
void EK()
{
    while(1)
    {
        queue<int> qu;
        qu.push(0);
        memset(d,127,sizeof(d));
        d[0]=0;
        while(!qu.empty())
        {
            int tt=qu.front();
            qu.pop();
            use[tt]=0;
            for(int i=h[tt];i;i=c[i].x)
              if(d[c[i].y]>d[tt]+c[i].cn&&c[i].dis)
              {
                  d[c[i].y]=d[tt]+c[i].cn;
                  pre[c[i].y]=i;
                  if(!use[c[i].y])
                  {
                      use[c[i].y]=1;
                      qu.push(c[i].y);
                }
              }
        }
        if(d[t]>1e7) return;
        int hh=t,sum=1e9;
        while(pre[hh])
        {
            int l=pre[hh];
            sum=min(sum,c[l].dis);
            hh=c[l^1].y;
        }
        hh=t;
        while(pre[hh])
        {
            int l=pre[hh];
            c[l].dis-=sum;
            c[l^1].dis+=sum;
            tot1+=sum*c[l].cn;
            hh=c[l^1].y;
        }
    }
}
int main()
{
    scanf("%d%d%d%d",&a,&b,&P,&Q);
    P++,Q++;
    for(int i=1;i<=P;i++)
      for(int j=1;j<Q;j++)
        {
            int x,hh=pu(i,j),tt=hh+1;
            scanf("%d",&x);
            add(hh,tt,1,-x);
            add(hh,tt,INF,0);
        }
    for(int j=1;j<=Q;j++)
      for(int i=1;i<P;i++)
        {
            int x,hh=pu(i,j),tt=hh+Q;
            scanf("%d",&x);
            add(hh,tt,1,-x);
            add(hh,tt,INF,0);
        }
    for(int i=1;i<=a;i++)
      {
          int k,x,y;
          scanf("%d%d%d",&k,&x,&y);
          x++,y++;
          add(s,pu(x,y),k,0);
      }
    for(int i=1;i<=b;i++)
      {
          int k,x,y;
          scanf("%d%d%d",&k,&x,&y);
          x++,y++;
          add(pu(x,y),t,k,0);
      }
    EK();
    printf("%d",-tot1);
    return 0;
}
```

---

## 作者：TKXZ133 (赞：7)

[深海机器人问题](https://www.luogu.com.cn/problem/P4012)

### 题目大意

给定一张网格图，每条边都有边权。要从若干个点出发，每个点出发若干次，到达若干个终点，每个终点只能到达若干次。只能向上或向右走，求最大的经过的边权的和。重复经过的边只计算一次。

### 思路分析

题面可能有些绕（~~简化了之后更绕了~~）。

（这道题和 [方格取数加强版](https://www.luogu.com.cn/problem/P4012) 很像，不同的是这个题是边权且有多个起点/终点。）

看题，我们可以知道这是一道网络流，还是最大费用最大流（极小的数据范围，奇怪的限制条件，最大的和）。

那么如何建边呢？

- 首先处理起点和终点，我们建立虚拟源点，汇点，向所有起点/终点连边，容量为这个点可以出发/到达的次数，价值为 $0$。
- 那么剩下的就是网格中的点。我们需要满足两个条件：第一次被经过时获得价值；之后的所有经过没有价值。因此，我们可以将原图中的边变成两条边，一条容量为 $1$，价值为边权（满足第一个条件，只能经过一次，获得价值），另一条容量为 $+\infty$，价值为 $0$。（满足第二个条件，可以经过无限次，没有价值）

![](https://i.328888.xyz/2023/02/24/7lvu3.md.png)

然后跑一遍最大费用最大流就做完了。

### 代码

```
#include <bits/stdc++.h>
using namespace std;
const int N=100100;//不要管空间
#define inf 0x3f3f3f3f

int to[N],nxt[N],head[N],w[N],c[N];
int idx=1,n,m,S,T,in1,in2,in3,a,b;
int dis[N],vis[N],minw[N],pre[N];
queue <int> q;

int point(int x,int y){return x*(m+1)+y+1;}//将每一个点重编号
void add(int u,int v,int x,int y){
    idx++;to[idx]=v;nxt[idx]=head[u];head[u]=idx;w[idx]=x;c[idx]=-y;
    idx++;to[idx]=u;nxt[idx]=head[v];head[v]=idx;w[idx]=0;c[idx]=y;//我们将价值取反，这样只需要跑最小费用最大流再将答案取反就行了
}

//最小费用最大流模板

bool spfa(){
    memset(dis,0x3f,sizeof dis);dis[S]=0;
    memset(minw,0,sizeof minw);minw[S]=inf;
    q.push(S);
    while(!q.empty()){
        int now=q.front();q.pop();vis[now]=0;
        for(int i=head[now];i;i=nxt[i]){
            int v=to[i];
            if(dis[v]<=dis[now]+c[i]||!w[i]) continue;
            dis[v]=dis[now]+c[i];pre[v]=i;
            minw[v]=min(minw[now],w[i]);
            if(!vis[v]){q.push(v);vis[v]=1;}
        }
    }
    return minw[T]>0;
}

int EK(){
    int ans=0;
    while(spfa()){
        int t=minw[T];ans+=t*dis[T];
        for(int i=T;i!=S;i=to[pre[i]^1]){w[pre[i]]-=t;w[pre[i]^1]+=t;}
    }
    return ans;
}

//------

int main(){
    scanf("%d%d%d%d",&a,&b,&n,&m);
    S=0,T=N-5;//虚拟源汇
    //然后按上面的做法连边
    for(int i=0;i<=n;i++)//从0开始
        for(int j=0;j<m;j++){
            scanf("%d",&in1);
            add(point(i,j),point(i,j+1),1,in1);
            add(point(i,j),point(i,j+1),inf,0);
        }
    for(int i=0;i<=m;i++)
        for(int j=0;j<n;j++){
            scanf("%d",&in1);
            add(point(j,i),point(j+1,i),1,in1);
            add(point(j,i),point(j+1,i),inf,0);
        }
    for(int i=1;i<=a;i++){
        scanf("%d%d%d",&in1,&in2,&in3);
        add(S,point(in2,in3),in1,0);
    }
    for(int i=1;i<=b;i++){
        scanf("%d%d%d",&in1,&in2,&in3);
        add(point(in2,in3),T,in1,0);
    }
    cout<<-EK()<<'\n';
    return 0;
}
```

---

## 作者：wjyyy (赞：5)

**我的博客：[传送门](https://www.wjyyy.top/3069.html)**

## 题解：

看上去还是一个**“方格取数”类**问题，实际上每个点、每条边是可以经过多次的。我们直接按图上网格建边就可以了，方向是$\rightarrow,\uparrow$。

但是重点是每条边只在第一次被经过时产生收益，这个看来是不好在费用流中进行特判的了。

如果这些边的容量全部设为$l1$，那么一条边就不能被经过第二次了，这当$\sum k+\sum r$很大的时候会存在机器人跑不过去的情况。

如果这些边的容量为$\inf$，那么不容易判断这条边是第几次被经过，而且残量网络也不方便更新。

此时我们可以建两条边，一条是带费用的，容量为$1$，另一条是不带费用的，容量为$\inf$。但是这两条边的优先级怎么确定呢？

由于费用流的特殊性，EK费用流是通过spfa来增广的，当存在上述带费用的边时，会先跑带费用的边（_最大费用最大流中权值实际为负*****_）。此时就既解决了收益最大化问题，也解决了收益单次性问题。

不过像【洛谷 P4001 狼抓兔子[题目](https://www.luogu.org/problemnew/show/P4001)，[题解](https://www.wjyyy.top/1540.html)】这一题的建模就更考察思维了。

***最大费用最大流中把原边权取反（负）跑最短路增广会方便很多，最后答案再取反。**

## Code：

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#define s 290
#define t 291
using std::queue;
struct edge
{
    int n,nxt,v,w;
    edge(int n,int nxt,int v,int w)
    {
        this->n=n;
        this->nxt=nxt;
        this->v=v;
        this->w=w;
    }
    edge(){}
}e[2000];
int head[300],ecnt=-1;
void add(int from,int to,int v,int w)
{
    e[++ecnt]=edge(to,head[from],v,w);
    head[from]=ecnt;
    e[++ecnt]=edge(from,head[to],0,-w);
    head[to]=ecnt;
}
int dis[300],pre[300];
bool used[300];
bool spfa()
{
    memset(dis,0x3f,sizeof(dis));
    queue<int> q;
    q.push(s);
    used[s]=1;
    dis[s]=0;
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        used[x]=0;
        for(int i=head[x];~i;i=e[i].nxt)
            if(e[i].v&&dis[e[i].n]>dis[x]+e[i].w)
            {
                dis[e[i].n]=dis[x]+e[i].w;
                pre[e[i].n]=i;
                if(!used[e[i].n])
                {
                    used[e[i].n]=1;
                    q.push(e[i].n);
                }
            }
    }
    return dis[t]!=0x3f3f3f3f;
}
int main()
{
    memset(head,-1,sizeof(head));
    int a,b,n,m,u,v,w;
    scanf("%d%d%d%d",&a,&b,&n,&m);
    for(int i=0;i<=n;++i)
        for(int j=0;j<m;++j)
        {
            scanf("%d",&u);//计算一维坐标时需要注意
            add(i*(m+1)+j,i*(m+1)+j+1,1,-u);//每一行既有0又有m
            add(i*(m+1)+j,i*(m+1)+j+1,0x3fffffff,0);//所以有m+1个数
        }
    for(int i=0;i<=m;++i)
        for(int j=0;j<n;++j)
        {
            scanf("%d",&u);
            add(j*(m+1)+i,(j+1)*(m+1)+i,1,-u);
            add(j*(m+1)+i,(j+1)*(m+1)+i,0x3fffffff,0);
        }
    for(int i=1;i<=a;++i)
    {
        scanf("%d%d%d",&u,&v,&w);
        add(s,v*(m+1)+w,u,0);
    }
    for(int i=1;i<=b;++i)
    {
        scanf("%d%d%d",&u,&v,&w);
        add(v*(m+1)+w,t,u,0);
    }
    int ans=0;
    pre[s]=-1;
    while(spfa())
    {
        int p=pre[t],mn=0x3fffffff;
        while(~p)
        {
            mn=mn<e[p].v?mn:e[p].v;
            p=pre[e[p^1].n];
        }
        p=pre[t];
        while(~p)
        {
            e[p].v-=mn;
            e[p^1].v+=mn;
            ans+=e[p].w*mn;
            p=pre[e[p^1].n];
        }
    }
    printf("%d\n",-ans);
    return 0;
}
```



---

## 作者：Ajwallet (赞：4)

这里提供一下大意和建图思想
#### $Description$
在一个$n\times m$的矩阵中，每个点都有自己的权值

有$a$个起点，$b$个终点

每个起点都有$ka_i$个机器人，每个终点可以到达$kb_i$个机器人

机器人只能向右或向上走，当机器人经过某个点时可以取走当前点的权值（`只能取一次`）

求到达终点的机器人的最大权值总和

数据范围：
$n,m\leq15$
$a\leq 4$
$b\leq 6$
***
#### $Solution$
鸣谢[$wyc$](https://blog.csdn.net/mr_wuyongcong)大佬的讲解，算是比较能弄懂这题的建图了，一眼就看出正解的他太强啦%%%

根据数据范围~~和标签~~可以看出这题是一道网络流

容易看出这道题的模型有点类似于传纸条，因为格子的值是非负的，所以我显然越多机器人到达时越好的，这就是一个最大流。

现在我们要在此基础上使得权值总和最大，也就是一个最大费用最大流了

现在我们考虑费用

启动机器人是无代价的，日常费用0

主要考虑取走这个问题，由于每个只能取一次，所以容量为1，代价为其价值，但是如果单纯这样建是错误的，因为它取走之后还可以继续走，所以还要建一条“经过点”，容量为无穷大（无限经过），代价为0（经过当然没有代价了啦）

其它的日常网络流啦

依照网络流的套路，我们把费用取负，然后跑最小费用最大流即可

如图（真的良心绘图）：![图片](https://cdn.luogu.com.cn/upload/pic/52987.png)

[绘图网址](https://www.processon.com/i/5afc01e3e4b096c6eeb3834b)
***

---

## 作者：juruo999 (赞：3)

# P4012 深海机器人问题

[更好体验](https://juruo999.blog.luogu.org/solution-p4012)  
[题目](https://www.luogu.com.cn/problem/P4012)

一道费用流建模题

## 题意

机器人活动区域为 $p\times q$ 的网格图。

有 $a$ 个出发点，每个出发点有 $k_i$ 个深海机器人。  
有 $b$ 个目的地，每个目的地需要 $r_i$ 个深海机器人到达。

每个机器人可以从出发点出发向东或向北移动到达目的地，机器人可以采集沿途的标本并获得价值，**每个标本只能被采集一次**，但**边可以被重复走过**，同一时刻多个机器人可占据同一个点。

## 建模

看到多个机器人一起运动，求最大代价，果断费用流。

_P.S.这里不区分费用流模型中的点和网格图中的点_

从超级源点往每个出发点连一条边，容量 $k_i$，费用 $0$，表示 $k_i$ 个机器人从第 $i$ 个出发点出发。

从每个目的地往超级汇点连一条边，容量 $r_i$，费用 $0$，表示 $r_i$ 个机器人将会最终到达第 $i$ 个目的地。

如果每个标本可以无限次采集，那就很好办，网格图中的每个点向它东边、北边的点连一条边，费用为对应标本价值，容量为 $\infty$，表示每条边可以无限次走。

但是这里每个标本**只能被采集一次**。于是我们想到把一条边拆成两条边，一条费用为这条边上的标本价值，容量为 $1$，另一条费用为 $0$，容量为 $\infty$。

最后图是这样的

![](https://s3.bmp.ovh/imgs/2022/03/9d549b9cc566d67b.png)

图中绿点表示出发点，蓝点表示目的地，注意图中的一个箭头能同时表示最终图中的两条边

最后跑一个最大费用最大流即可。

## code

建图部分

```cpp
	for(int i=1;i<=p;i++){	// 向东路径
		for(int j=1;j<q;j++){
			ll t;scanf("%lld",&t);
			cflow::addflow(id(i,j),id(i,j+1),1,-t);	// 费用取相反数转换为最小费用最大流
			cflow::addflow(id(i,j),id(i,j+1),inf,0); //注意这条边不是反向边
			// 加反向边在 addflow 里
		}
	}
	
	for(int j=1;j<=q;j++){	// 向北路径
		for(int i=1;i<p;i++){
			ll t;scanf("%lld",&t);
			cflow::addflow(id(i,j),id(i+1,j),1,-t);
			cflow::addflow(id(i,j),id(i+1,j),inf,0);
		}
	}

	for(int i=1;i<=a;i++){
		ll k;int x,y;
		scanf("%lld%d%d",&k,&x,&y);
		cflow::addflow(1,id(x+1,y+1),k,0);	// 出发点
	}
	
	for(int i=1;i<=b;i++){
		ll k;int x,y;
		scanf("%lld%d%d",&k,&x,&y);
		cflow::addflow(id(x+1,y+1),2,k,0);	// 目的地
	}
```


完整版

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;

typedef long long ll;
const ll inf=0x3f3f3f3f3f3f3f3f;

namespace cflow{	// 原始对偶算法

	const int maxn=5005,maxm=50005;

	int n,s,t;

	inline int oth(int x){
		return ((x-1)^1)+1;
	}

	struct edge{
		int u,v; ll w,c; int nxt;
		edge(){}
		edge(int u_,int v_,ll w_,ll c_,int nxt_)
			{ u=u_,v=v_,w=w_,c=c_,nxt=nxt_; }
	}e[2*maxm];
	int fst[maxn],tp=0;

	void addedge(int u,int v,ll w,ll c){
		e[++tp]=edge(u,v,w,c,fst[u]);
		fst[u]=tp;
	}
	void addflow(int u,int v,ll w,ll c){
		addedge(u,v,w,c);
		addedge(v,u,0,-c);
	}

	ll dis[maxn],h[maxn],mxw[maxn];int cnt[maxn],frm[maxn],fre[maxn];
	bool vis[maxn];

	void spfa(){
		static queue<int> q;
		while(!q.empty()){ q.pop(); }

		memset(dis,0x3f,sizeof(dis));
		memset(cnt,0,sizeof(cnt));
		memset(vis,0,sizeof(vis));

		dis[s]=0;vis[s]=1;q.push(s);cnt[s]++;
		while(!q.empty()){
			int u=q.front();q.pop();vis[u]=0;
			if(cnt[u]>n+1){
				break;
			}
			for(int i=fst[u];i!=0;i=e[i].nxt){
				int v=e[i].v;
				ll c=e[i].c;
				if(e[i].w==0){ continue; }
				if(dis[v]>dis[u]+c){
					dis[v]=dis[u]+c;
					if(!vis[v]){ vis[v]=1;q.push(v);cnt[v]++; }
				}
			}
		}
	}

	void clear(){
		memset(cflow::fst,0,sizeof(cflow::fst));cflow::tp=0;
	}
	void init(int n_,int s_,int t_){
		clear();
		n=n_,s=s_,t=t_;
	}

	struct pr{
		ll dis;int u;pr(){}pr(int u_,ll dis_){u=u_,dis=dis_;}
	};
	bool operator<(pr a,pr b){
		return (a.dis!=b.dis)?(a.dis>b.dis):(a.u>b.u);
	}

	bool dijkstra(){
		static priority_queue<pr> q;
		while(!q.empty()){ q.pop(); }
		memset(dis,0x3f,sizeof(dis));
		dis[s]=0;mxw[s]=inf;q.push(pr(s,0));
		while(!q.empty()){
			int u=q.top().u;q.pop();
			for(int i=fst[u];i!=0;i=e[i].nxt){
				int v=e[i].v;
				ll c=e[i].c+h[u]-h[v],w=e[i].w;
				if(w && (dis[v]>dis[u]+c)){
					dis[v]=dis[u]+c;
					mxw[v]=min(mxw[u],w);
					frm[v]=u;
					fre[v]=i;
					q.push(pr(v,dis[v]));
				}
			}
		}
		return dis[t]!=inf;
	}

	ll mincost,maxflow;

	void MCMF(){

		spfa();
		memcpy(h,dis,sizeof(h));

		mincost=maxflow=0;
		while(dijkstra()){
			ll flow=mxw[t];
			maxflow+=flow;
			mincost+=flow*(dis[t]-h[s]+h[t]);
			for(int i=t;i!=s;i=frm[i]){
				e[fre[i]].w-=flow;
				e[oth(fre[i])].w+=flow;
			}
			for(int i=1;i<=n;i++){
				h[i]+=dis[i];
			}
		}
	}
}

int a,b,p,q;

inline int id(int i,int j){
	return q*(i-1)+j+2;
}

int main(){
	
	scanf("%d%d%d%d",&a,&b,&p,&q);p++,q++;	// 注意有 (p+1)*(q+1) 个点
	
	cflow::init(p*q+100,1,2);	// 以 1 为源点，2 为汇点
	
	for(int i=1;i<=p;i++){	// 向东路径
		for(int j=1;j<q;j++){
			ll t;scanf("%lld",&t);
			cflow::addflow(id(i,j),id(i,j+1),1,-t);	// 费用取相反数转换为最小费用最大流
			cflow::addflow(id(i,j),id(i,j+1),inf,0); //注意这条边不是反向边
			// 加反向边在 addflow 里
		}
	}
	
	for(int j=1;j<=q;j++){	// 向北路径
		for(int i=1;i<p;i++){
			ll t;scanf("%lld",&t);
			cflow::addflow(id(i,j),id(i+1,j),1,-t);
			cflow::addflow(id(i,j),id(i+1,j),inf,0);
		}
	}

	for(int i=1;i<=a;i++){
		ll k;int x,y;
		scanf("%lld%d%d",&k,&x,&y);
		cflow::addflow(1,id(x+1,y+1),k,0);	// 出发点
	}
	
	for(int i=1;i<=b;i++){
		ll k;int x,y;
		scanf("%lld%d%d",&k,&x,&y);
		cflow::addflow(id(x+1,y+1),2,k,0);	// 目的地
	}
	
	cflow::MCMF();
	printf("%lld\n",-cflow::mincost);	// 费用取了相反数

	return 0;

}
```

---

## 作者：秋日私语 (赞：3)

更好的阅读体验点[](http://blog.csdn.net/a_comme_amour/article/details/79581717)这里
题目
-

[传送门](https://www.luogu.org/problemnew/show/P4012)
题解
-

和[方格取数2](http://blog.csdn.net/A_Comme_Amour/article/details/79580875)实际上是一道题
对于方格中的每个点，拆成两个点，分别为入点和出点。入点和出点之间连两条边，一条容量为1，费用为点的权值，表示每个点的数只可以取一次；另一条容量为inf，费用为0，仅表示可以经过无数次； 

对于在其可以到达的点，连一条容量为inf，费用为0的边，表示且仅表示一种联通的关系
输入非常的恶心，不想多说

代码
-

```
#include<bits/stdc++.h>  
using namespace std;  
  
const int maxm=1050;  
const int maxn=1050;  
const int INF=0x3f3f3f3f;  
int s,t,tot,n,m;  
int a,b;  
  
struct Edge{  
    int to,nxt,cap,flow,cost;  
}edge[105000];  
int Head[maxn],tol;  
int mp[maxn][maxn];  
int pre[maxn],dis[maxn];  
bool vis[maxn];  
  
void addedge2(int u,int v,int cap,int cost){  
    edge[tol].to=v;  
    edge[tol].cap=cap;  
    edge[tol].cost=cost;  
    edge[tol].flow=0;  
    edge[tol].nxt=Head[u];  
    Head[u]=tol++;  
}  
  
void addedge(int u,int v,int cap,int cost){  
    addedge2(u,v,cap,cost);  
    addedge2(v,u,0,-cost);  
}  
  
bool spfa(int s,int t){  
    queue<int> q;  
    for(int i=0;i<tot;i++){  
        dis[i]=INF;vis[i]=false;pre[i]=-1;  
    }  
    dis[s]=0;vis[s]=true;  
    q.push(s);  
    while(!q.empty()){  
        int u=q.front();  
        q.pop();  
        vis[u]=false;  
        for(int i=Head[u];i!=-1;i=edge[i].nxt){  
            int v=edge[i].to;  
            if (edge[i].cap>edge[i].flow&&dis[v]>dis[u]+edge[i].cost){  
                dis[v]=dis[u]+edge[i].cost;  
                pre[v]=i;  
                if (!vis[v]){  
                    vis[v]=true;  
                    q.push(v);  
                }  
            }  
        }  
    }  
    if (pre[t]==-1) return false;  
    return true;  
}  
  
int minCostMaxflow(int s,int t,int &cost){  
    int flow=0;  
    cost=0;  
    while(spfa(s,t)){  
        int Min=INF;  
        for(int i=pre[t];i!=-1;i=pre[edge[i^1].to])  
            if (Min>edge[i].cap-edge[i].flow)  
                Min=edge[i].cap-edge[i].flow;  
        for(int i=pre[t];i!=-1;i=pre[edge[i^1].to]){  
            edge[i].flow+=Min;  
            edge[i^1].flow-=Min;  
            cost+=edge[i].cost*Min;  
        }  
        flow+=Min;  
    }  
    return flow;  
}  
  
int main(){  
    //freopen("input.txt","r",stdin);  
    while(scanf("%d%d%d%d",&a,&b,&n,&m)!=EOF){  
        memset(Head,-1,sizeof(Head));  
        int cost,c=0,x,y;  
        tol=s=0;  
        t=(n+1)*(m+1)+1;  
        tot=t+1;  
        for(int i=0;i<=n;i++)  
            for(int j=0;j<=m;j++)  
                mp[i][j]=++c;  
        for(int i=0;i<=n;i++)  
        for(int j=0;j<m;j++){  
            scanf("%d",&c);  
            addedge(mp[i][j],mp[i][j+1],1,-c);  
            addedge(mp[i][j],mp[i][j+1],INF,0);  
        }  
        for(int j=0;j<=m;j++)  
        for(int i=0;i<n;i++){  
            scanf("%d",&c);  
            addedge(mp[i][j],mp[i+1][j],1,-c);  
            addedge(mp[i][j],mp[i+1][j],INF,0);  
        }  
        for(int i=0;i<a;i++){  
            scanf("%d%d%d",&c,&x,&y);  
            addedge(s,mp[x][y],c,0);  
        }  
        for(int i=0;i<b;i++){  
            scanf("%d%d%d",&c,&x,&y);  
            addedge(mp[x][y],t,c,0);  
        }  
        int flow;  
        flow=minCostMaxflow(s,t,cost);  
        printf("%d\n",-cost);  
    }  
    return 0;  
}  
```

---

## 作者：小木虫 (赞：2)

### Problem  
在一个 $n$ 行 $m$ 列的矩阵中，每个点有其点权并且该点权只能取一次。现在有 $k$ 个入口并且每个点有一个洞，可以出去 $r$ 个机器人，允许 $k$ 个**只能向左右或者只能向上下行动**的机器人进入这个矩阵，请问它们所能取出的最大价值的物品有多少的价值？  
### Solution  
这道题第一眼看过去：是一个决策题，由于考虑其没有贪心的性质，所以只有可能是 dp 问题或者最大流最小割问题了。同时，这道题的决策**具有后效性并且状态太多了！！！**，所以 dp 的解法也没有可能。现在我们要求最大流或最小割。但是现在有一个问题：  
**怎么同时有价值和通行数量两个要求啊**  
很显然，这玩意普通最大流最小割解决不了，但是每个点并没有规定必须是哪几个机器人出去，这恰好满足了最大流中流没有特殊性的性质，也就是说，如果把通行限制的边建出来。最大流就是机器人总数，因为每个机器人都要回家。现在在这个最大流下要找出最大的费用，很难不让人想到**最小费用最大流**，点权只能取一次的这个设定，我们只需要拆点，并于入点和出点之间分别建两条边，一条流量为 1，但是权值为点权，另外一条流量为 $inf$，但权值为 0，这样就可以解决取一次的问题了。  
但是！这道题要求的是最大费用，其实那也很简单，我们将点权取反，在输出时再取反就可以了！  
远古 code（由于是很久以前写的了所以码风很难看）：  
```cpp
#include <bits/stdc++.h>
using namespace std;
int a,b;
int q,p;
int value;
struct node{
	int x,y,data;
}st[20];
node en[20];
int head[1010];
struct EDGE{
	int next;
	int w;
	int v;
	int f;
	int neg;
}edge[10100];
int cnt;
void add(int u,int v,int w,int f){
	++cnt;
	edge[cnt].next=head[u];
	edge[cnt].f=f;
	edge[cnt].w=w;
	edge[cnt].v=v;
	head[u]=cnt;
	edge[cnt].neg=cnt+1;
	++cnt;
	edge[cnt].next=head[v];
	edge[cnt].f=0;
	edge[cnt].w=-w;
	edge[cnt].v=u;
	head[v]=cnt;
	edge[cnt].neg=cnt-1;
}
int predot[1010];
int preedge[1010];
int incf[1010];
int cost;
queue <int> Q;
int dis[1010];
bool vis[1010];
bool SPFA(){
	for(int i=0;i<=(q+1)*(p+1)+1;i++){
		incf[i]=1e9;
		dis[i]=-1e9;
		vis[i]=false;
		predot[i]=-1;
		preedge[i]=0;
	}
	Q.push(0);
	dis[0]=0;
	vis[0]=true;
	while(!Q.empty()){
		int cur=Q.front();
		Q.pop();
		vis[cur]=false;
		for(int i=head[cur];i;i=edge[i].next){
			if(edge[i].f!=0){
				int v=edge[i].v;
				int w=edge[i].w;
				int f=edge[i].f;
				if(dis[cur]+w>dis[v]){
					dis[v]=dis[cur]+w;
					incf[v]=min(incf[cur],f);
					predot[v]=cur;
					preedge[v]=i;
					if(!vis[v]){
						vis[v]=true;
						Q.push(v);
					}
				}
			}
		}
	}
	if(dis[(q+1)*(p+1)+1]!=-1e9){
		return true;
	}else{
		return false;
	}
}
void update(){
	int x=(q+1)*(p+1)+1;
	int minflow=incf[x];
	while(x!=0){
		edge[preedge[x]].f-=minflow;
		edge[edge[preedge[x]].neg].f+=minflow;
		x=predot[x];
	}
	cost+=dis[(q+1)*(p+1)+1]*minflow;
}
void MCMF(){
	while(SPFA()){
		update();
	}
}
int tmp;
int main(){
	cin>>a>>b>>q>>p;
	q++;
	p++;
	tmp=q;
	q=p;
	p=tmp;
	for(int i=1;i<=p;i++){
		for(int j=1;j<q;j++){
			cin>>value;
			add((i-1)*q+j,(i-1)*q+j+1,value,1);
			add((i-1)*q+j,(i-1)*q+j+1,0,1e9);
		}
	}
	for(int i=1;i<=q;i++){
		for(int j=1;j<p;j++){
			cin>>value;
			add(i+(j-1)*q,i+j*q,value,1);
			add(i+(j-1)*q,i+j*q,0,1e9);
		}
	}
	for(int i=1;i<=a;i++){
		cin>>st[i].data>>st[i].x>>st[i].y;
		++st[i].x;
		++st[i].y;
		add(0,(st[i].x-1)*q+st[i].y,0,st[i].data);
	}
	for(int i=1;i<=b;i++){
		cin>>en[i].data>>en[i].x>>en[i].y;
		++en[i].x;
		++en[i].y;
		add((en[i].x-1)*q+en[i].y,(q+1)*(p+1)+1,0,en[i].data);
	}
	MCMF();
	cout<<cost;
	return 0;
}
```


---

## 作者：KEBrantily (赞：2)

UPD：描述与原题出现了偏差导致分析有点错误，已修正。

这题对我这种难以掌握方向的人来说非常不友好啊……

## Description

给定一个 $P\times Q$ 的网格图，从 $(0,0)$ 到 $(P,Q)$。

图上会出现一些机器人，每个机器人只能向北或向东走，而且在某个位置向某个方向走会得到对应的分数，但每个位置的分数只能取一次。

给出某些点 $(x_1,y_1)$ 和 $k_1$，表示在这些点会出现 $k_1$ 个机器人。

给出另外一些点 $(x_2,y_2)$ 和 $k_2$，表示在这些点有 $k_2$ 个机器人可以离开。

求能获得的最大得分。

## Solution

首先显然的可以看出，一个机器人可以代表一个流量，每获得一分可以代表费用加一。

看到题目要求的不是有多少个机器人能离开，而是能获得多少分，所以选择求最大流下的最大费用。

然后来分析一下怎么建图。

已知会有不确定个点出现不确定个机器人，并且他们的出现并不会增加得分，所以我们可以从源点 $S$ 分别向这些起点连流量为机器人个数，费用为 $0$ 的边。

同理，对于最多能离开不确定个机器人的终点，从它们向汇点分别连一条流量为机器人个数，费用为 $0$ 的边。

对于图中的点，根据机器人的行走方式，我们可以看出机器人只能从西走向东或从南走向北，并且每次只能走一格。

又因为第一次走某个位置都可以获得对应的权值，我们就可以对于每个点，向它所能到达的点（也就是它东边和北边直接相邻的点）连一条流量为 $1$，费用为对应权值的边。

走过的边还可以随便走，但是不会再获得分数，所以再从每个点向它所能到达的点连一条流量为无穷大，费用为 $0$ 的边。

然后跑费用流就行了。

另外对于方向，虽然题目要求的是向东和向北走，但其实只要纵向和横向分别规定一个方向，然后输入权值和建边的时候与方向对应上即可。

想练习输出方案可以去做 [P3356 火星探险问题](https://www.luogu.com.cn/problem/P3356)，只是出现了障碍点，其他的差不多。

## Code

```cpp
#include<cmath>
#include<queue>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define maxn 601000
#define maxm 300000
#define INF 0x3f3f3f3f
//#define int long long

using namespace std;

bool vis[maxn];
int n,m,s,t,tot=1,res,a,b;
int val[3010][3010],id[3010][3010];
int Dis[maxn],cur[maxn],head[maxn];
int north[3010][3010],east[3010][3010];
struct edge{int fr,to,dis,cost,nxt;}e[maxm];

int read(){
    int s=0,w=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+ch-'0',ch=getchar();
    return s*w;
}

void add(int fr,int to,int dis,int cost){
    e[++tot].fr=fr;e[tot].cost=cost;
    e[tot].to=to;e[tot].nxt=head[fr];
    e[tot].dis=dis;head[fr]=tot;
}

bool spfa(){
    bool flag=false;
    memset(Dis,INF,sizeof Dis);
    memcpy(cur,head,sizeof head);
    deque<int> q;q.push_back(s);Dis[s]=0;
    while(!q.empty()){
        int u=q.front();
        q.pop_front();vis[u]=0;
        for(int i=head[u];i;i=e[i].nxt){
            int to=e[i].to;
            if(Dis[to]>Dis[u]+e[i].cost&&e[i].dis){
                Dis[to]=Dis[u]+e[i].cost;
                if(!vis[to]){
                    vis[to]=1;
                    if(!q.empty()&&Dis[to]<Dis[q.front()]) q.push_front(to);
                    else q.push_back(to);
                }
                if(to==t) flag=true;
            }
        }
    }
    return flag;
}

int dfs(int u,int limit){
    if(u==t) return limit;int flow=0;vis[u]=1;
    for(int i=cur[u];i&&flow<limit;i=e[i].nxt){
        int to=e[i].to;cur[u]=i;
        if(Dis[to]==Dis[u]+e[i].cost&&!vis[to]&&e[i].dis){
            int f=dfs(to,min(e[i].dis,limit-flow));
            if(!f)Dis[to]=INF;res+=f*e[i].cost;
            e[i].dis-=f;e[i^1].dis+=f;flow+=f;
        }
    }
    vis[u]=0;
    return flow;
}

int dinic(){
    int Maxflow=0,flow=0;
    while(spfa())
        while(flow=dfs(s,INF))
            Maxflow+=flow;
    return Maxflow;
}

int main(){
    a=read();b=read();n=read()+1;m=read()+1;int pos=0;s=301;t=s+1;
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)id[i][j]=++pos;
    for(int i=1,val;i<=n;i++)for(int j=2;j<=m;j++)east[i][j]=read();
    for(int i=1,val;i<=m;i++)for(int j=2;j<=n;j++)north[j][i]=read();
    for(int i=1,k,x,y;i<=a;i++){
        k=read();x=read()+1;y=read()+1;
        add(s,id[x][y],k,0);
        add(id[x][y],s,0,0);
    }
    for(int i=1,r,x,y;i<=b;i++){
        r=read();x=read()+1;y=read()+1;
        add(id[x][y],t,r,0);
        add(t,id[x][y],0,0);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(i+1<=n){
                add(id[i][j],id[i+1][j],1,-north[i+1][j]);
                add(id[i+1][j],id[i][j],0,north[i+1][j]);
                add(id[i][j],id[i+1][j],INF,0);
                add(id[i+1][j],id[i][j],0,0);
            }
            if(j+1<=m){
                add(id[i][j],id[i][j+1],1,-east[i][j+1]);
                add(id[i][j+1],id[i][j],0,east[i][j+1]);
                add(id[i][j],id[i][j+1],INF,0);
                add(id[i][j+1],id[i][j],0,0);
            }
        }
    }
    dinic();printf("%d\n",-res);
    return 0;
}
```


---

## 作者：Constant (赞：2)

这是网络流 $24$ 题中的一道题，也是一道很经典的题目，总的来谈，网络流真的是一

种很实用和方便的算法，在很多题目下都能使用，而网络流的关键就在于建图，这

道题也可以很好的提高我们的建模能力。



------------


## 题意简述：

你有一张 $P×Q$ 的地图，每个方格有一个价值 $C$ 。有 $a$ 个起点和 $b$ 个

终点，第 $i$ 个起点上有 $k_i$ 数量的机器人，只允许向上或者向右行走，并获得对应

方格之中的价值，每个方格的价值只能被获得一次，求最大的价值。

## Solution:

在解决了一定数量的网络流题目之后，对建模这一块其实已经很有感觉了，这道题

要求我们既要满足题目机器人和路径的要求，又要价值最大，有两重限制，这就提

示我们要用费用流，并且求最大价值，一定是最大费用最大流。

每个机器人有起点，于是这就是我们的初状态了，为了方便跑最大流，我们建立

一个源点 $S$ 和一个汇点 $T$ ，用源点 $S$ 向每个起点建边，因为每个起点都

有 $k_i$ 个机器人，故容量为 $k_i$ ，费用为 $0$ 。

接下来，我们处理价值和路径，因为每条边的价值只能取一次，且机器人只能向

上或向右行走，故我们对于每个起点，都向该点上面和右边建立一条边，容量为

$1$，费用为那条路径的价值。同时注意到，我们是可以多次经过同一个点的，只

不过没有价值罢了，所以我们还要连一条容量为正无穷，费用为 $0$ 的边。

最后，不要忘了把 $B$ 个终点向汇点 $T$ 连边。

建好图，直接跑最大费用最大流即可求出答案，下面是我的代码。

```cpp
#include<bits/stdc++.h>
#define N 400005
using namespace std;
int num=1,k,x,y;
int S,T,n,m,A,B,C,D,first[N],nex[N],v[N],w[N],c[N],dis[N],vis[N],mmin[N],INF=-2139062144,ansflow,anscost,b[N],p,q;
int que[N];
void Add(int s,int e,int cd,int cost)
{
	nex[++num]=first[s];
	first[s]=num;
	v[num]=e;
	w[num]=cd;
	c[num]=cost;
}
bool SPFA(int u)
{
	int head=1,tail=1;
	memset(dis,128,sizeof(dis));
	memset(vis,0,sizeof(vis));
	memset(que,0,sizeof(que));
	dis[u]=0;
	vis[u]=1;
	que[tail]=u;//STL的队列常数很大，建议手写，快很多 
    tail++;
	mmin[u]=-INF;
	while(head<tail)
	{
		int x=que[head];
		head++;
		vis[x]=0;
		for(int i=first[x];i;i=nex[i])
		{
			if(w[i]!=0&&dis[x]+c[i]>dis[v[i]])
			{
				dis[v[i]]=dis[x]+c[i];
				mmin[v[i]]=min(mmin[x],w[i]);
				b[v[i]]=i;
				if(!vis[v[i]])
				{
					que[tail]=v[i];
				    tail++;
					vis[v[i]]=1;
				}
			}
		}
	}
	if(dis[T]==INF) return 0;
	else return 1; 
}
int bh(int i,int j)
{
	return (i-1)*q+j;
}
int main()
{
    scanf("%d%d",&A,&B);
    scanf("%d%d",&p,&q);
    p++;q++;
    S=399998;T=399999;
    for(int i=1;i<=p;i++)
    {
    	for(int j=1;j<=q-1;j++)
    	{
    		scanf("%d",&C);
    		Add(bh(i,j),bh(i,j)+1,1,C);
    		Add(bh(i,j)+1,bh(i,j),0,-C);
    		Add(bh(i,j),bh(i,j)+1,-INF,0);
    		Add(bh(i,j)+1,bh(i,j),0,0);
		}
	}
	for(int j=1;j<=q;j++)
	{
		for(int i=1;i<=p-1;i++)
        {
            scanf("%d",&C);
            Add(bh(i,j),bh(i,j)+q,1,C);
            Add(bh(i,j)+q,bh(i,j),0,-C);
            Add(bh(i,j),bh(i,j)+q,-INF,0);
            Add(bh(i,j)+q,bh(i,j),0,0);
        }
	}
    for(int i=1;i<=A;i++)
    {
    	scanf("%d%d%d",&k,&x,&y);
    	x++;y++;
    	Add(S,bh(x,y),k,0);
    	Add(bh(x,y),S,0,0);
	}
	for(int i=1;i<=B;i++)
	{
		scanf("%d%d%d",&k,&x,&y);
    	x++;y++;
    	Add(bh(x,y),T,k,0);
    	Add(T,bh(x,y),0,0);
	}
	while(SPFA(S))
	{
		anscost=anscost+dis[T]*mmin[T];
	    int now=T,tmp;
	    while(now!=S)
	    {
	    	tmp=b[now];
	    	w[tmp]=w[tmp]-mmin[T];
	    	w[tmp^1]=w[tmp^1]+mmin[T];
	    	now=v[tmp^1];
		}
	}
	cout<<anscost;	
    return 0;
}
```








---

## 作者：mjsdnz (赞：1)

+ [原题链接](https://www.luogu.com.cn/problem/P4012)

+ 小吐槽：

不得不说这题的输入方式是真恶心，捣腾输入的时间比写板子的时间还长。

## 题目大意

给一张网格图，有 $a$ 个起点，$b$ 个终点，每个起点、终点有给定的流量限制，在网格中只能向北或向东（$i,j$ 到 $i+1,j$ 或 $i,j+1$）。每个点各有一个向东或向北走的收益，多个点可以同时在一个格子中，但每个点的收益只计算一次，求最大收益。

## 思路

如吐槽所说，这题最难的不是板子也不是建图，而是输入，想明白了其实很好写。由于每个点移动的收益只计算一次，所以每个 $i,j$ 到 $i+1,j$ 或 $i,j+1$ 之间建一条价值为 $val$，流量为一的边，为了使这条路能够多次同行，我们还需要建一条流量为 $inf$，价值为 $0$ 的边。源点向每个起点建一条流量为 $c_i$，价值为 $0$ 的边，汇点同理。然后跑个最大费用最大流（因为没有正环所以随便跑）就可以轻松解决这个问题。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e4 + 10;
const int M = 2e5 + 10;
const int inf = 0x3f3f3f3f;
int cnt = 1;
int head[N];
int now[N];
struct Edge {
	int u, v, c, val, nxt;
	Edge(int u = 0, int v = 0, int c = 0, int val = 0, int nxt = 0): u(u), v(v), c(c), val(val), nxt(nxt) {}
} e[M];
void ADD(int u, int v, int c, int val) {
	cnt++;
	e[cnt] = Edge(u, v, c, val, head[u]);
	head[u] = cnt;
}
void add_edge(int u, int v, int c, int val) {
	ADD(u, v, c, val);
	ADD(v, u, 0, -val);
}
int s, t;
int tot;
int loc[30][30];
int dis[N];
struct node {
	int num, dis;
	node(int num, int dis): num(num), dis(dis) {}
	bool operator<(const node & a) const {
		return dis < a.dis;
	}
};
int h[N];
int mncost, mxfl;
bool dj() {
	for (int i = 1; i <= tot; i++) dis[i] = -inf;
	priority_queue<node>q;
	dis[s] = 0;
	q.push(node(s, dis[s]));
	while (q.size()) {
		int u = q.top().num;
		int d = q.top().dis;
		now[u] = head[u];
		q.pop();
		if (d > dis[u]) continue;
		for (int i = head[u]; i; i = e[i].nxt) {
			int v = e[i].v;
			int c = e[i].c;
			int val = e[i].val;
			if (!c) continue;
			if (dis[v] < dis[u] + h[u] + val - h[v]) {
				dis[v] = dis[u] + h[u] + val - h[v];
				q.push({v, dis[v]});
			}
		}
	}
	return dis[t] == -inf;
}
bool vis[N];
int dfs(int u, int t, int flow) {
	if (u == t) return flow;
	vis[u] = 1;
	int nowflow = 0;
	for (int i = now[u]; i; i = e[i].nxt) {
		now[u] = i;
		int v = e[i].v;
		int c = e[i].c;
		int val = e[i].val;
		if (!c || vis[v] || dis[v] != dis[u] + h[u] + val - h[v]) continue;
		int ff = dfs(v, t, min(flow, c));
		if (ff) mncost += ff * val, flow -= ff, nowflow += ff, e[i].c -= ff, e[i ^ 1].c += ff;
	}
	vis[u] = 0;
	return nowflow;
}
void maxflow() {
	while (!dj()) {
		int nowflow;
		while ((nowflow = dfs(s, t, inf))) mxfl += nowflow;
		for (int i = 1; i <= tot; i++) h[i] += (dis[i] == inf) ? 0 : dis[i];
	}
}
int aa, bb;
int n, m;
signed main() {
	cin >> aa >> bb ;
	cin >> n >> m;
	for (int i = 0; i <= n; i++) for (int j = 0; j <= m; j++) loc[i][j] = ++tot;
	s = ++tot, t = ++tot;
	for (int i = 0; i <= n; i++)
		for (int j = 0; j < m; j++) {
			int val;
			cin >> val;
			add_edge(loc[i][j], loc[i][j + 1], 1, val);
			add_edge(loc[i][j], loc[i][j + 1], inf, 0);
		}
	for (int j = 0; j <= m; j++)
		for (int i = 0; i < n; i++) {
			int val;
			cin >> val;
			add_edge(loc[i][j], loc[i + 1][j], 1, val);
			add_edge(loc[i][j], loc[i + 1][j], inf, 0);
		}
	while (aa--) {
		int c, i, j;
		cin >> c >> i >> j;
		add_edge(s, loc[i][j], c, 0);
	}
	while (bb--) {
		int c, i, j;
		cin >> c >> i >> j;
		add_edge(loc[i][j], t, c, 0);
	}
	maxflow();
	cout << mncost;
}
```

---

## 作者：Aisaka_Taiga (赞：1)

~~发现学长发过这道题的题解所以我也来水一下~~

## 题目大意

给你一个网格图，每一条网格边上都有边权，给你 $a$ 个起点，每一个起点可以有 $A_{i}$ 个人从这里走；给你 $b$ 个终点，每一个终点最多可以有 $B_{i}$ 个人在这里结束行程，问你最大的边权和。

## 思路

考虑最大费用最大流。

我们需要弄清楚的一点就是题目里说了机器人只能向北或者向东走，也就是说只会从左下角往右上角走，我们把他给反过来，让他从左上角往右下角走，也就是只能向下或者向右。

我们可以看到输入中是 $Q$ 和 $P$，但由于是从 $(0,0)$ 开始的，所以实际的点数是 $(Q+1)\times(P+1)$ 的，在给点编号的时候需要注意一下。首先是把横着的边给存起来，这个时候我们根据上面说的只能往下或往右走，我们知道当前横着边是链接了他左右两个端点，所以我们直接把他给存起来。但是有一个问题就是一个标本只有一个，也就是说后面的机器人来这里的话是不会对答案产生贡献，也就是得到的价值为 $0$，这样的话，我们在存边的时候存一条流量为 $1$，花费为当前网格边边权的边，表示只有一个机器人可以采到标本，然后再存一条流量为 $\infty$，花费为 $0$ 的边，表示其他经过这条网格边的机器人都不会采到标本。同理我们把后面的那些竖边也处理出来（在枚举的时候要注意横着的边一共是 $Q+1$ 行，但是一行只有 $P$ 条边，因为两点之间的才是边，同理竖边一共是 $P+1$ 列，但是一列只有 $Q$ 条边）。

然后我们来处理每一个起点和每一个终点。

我们可以发现每一个起点和终点都有机器人个数限制，比如第 $i$ 个起点最多有 $A_{i}$ 个机器人从这里出发，所以我们从超级源点向每一个起点都连一条流量为 $A_{i}$，花费为 $0$ 的边，这样就解决了每一个起点机器人数量的限制；同理也可以这样来限制到达每一个终点的机器人的数量，所以我们在建完图之后直接跑最小费用最大流（在存边的时候把边权取个相反数就转化为最小费用最大流了）就好了。

### code：

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define N 100010
using namespace std;
int cnt=1,head[N],n,m,s,t,a,b,mcost;
int dis[N],vis[N],flow[N],pre[N],ff[N];
struct sb{int v,w,val,next;}e[N];
inline int bh(int x,int y){return x*(m+1)+y+1;}//求出编号 
inline void add(int u,int v,int w,int val)//W是流量，val是花费 
{
	e[++cnt].v=v;e[cnt].w=w;e[cnt].val=val;e[cnt].next=head[u];head[u]=cnt;
	e[++cnt].v=u;e[cnt].w=0;e[cnt].val=-val;e[cnt].next=head[v];head[v]=cnt;
}
inline int SPFA()
{
	queue<int>q;
	memset(dis,INF,sizeof dis);
	memset(vis,0,sizeof vis);
	dis[s]=0;
	vis[s]=1;
	flow[s]=INF;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=head[u];i;i=e[i].next)
		{
			int v=e[i].v,w=e[i].val;
			if(e[i].w&&dis[v]>dis[u]+w)
			{
				dis[v]=dis[u]+w;
				pre[v]=i;
				ff[v]=u;
				flow[v]=min(flow[u],e[i].w);
				if(!vis[v])
				{
					q.push(v);
					vis[v]=1;
				}
			}
		}
	}
	return dis[t]!=INF;
}
inline void EK()
{
	while(SPFA())
	{
		int k=t;
		while(k!=s)
		{
			e[pre[k]].w-=flow[t];
			e[pre[k]^1].w+=flow[t];
			k=ff[k];
		}
		mcost+=dis[t]*flow[t];
	}
}
signed main()
{
	cin>>a>>b>>n>>m;
	s=0;t=N-1;//起点和终点编号 
	for(int i=0;i<=n;i++)//枚举所有横着的边 
	{
		for(int j=0;j<m;j++)//一行m条 
		{
			int x;
			cin>>x;
			add(bh(i,j),bh(i,j+1),1,-x);//将当前点和下一个点链接起来，花费是-x因为要求的是最大花费最大流，因为标本只能采一次所以流量是1 
			add(bh(i,j),bh(i,j+1),INF,0);//这个是后面的边，标本没了花费为0，可以无限重复走，所以流量是INF 
		}
	}
	for(int i=0;i<=m;i++)//同理枚举所有竖着的边 
	{
		for(int j=0;j<n;j++)
		{
			int x;
			cin>>x;
			add(bh(j,i),bh(j+1,i),1,-x);
			add(bh(j,i),bh(j+1,i),INF,0);
		}
	}
	for(int i=1;i<=a;i++)//这个是枚举每一个起点， 
	{
		int x,y,z;
		cin>>z>>x>>y;
		add(s,bh(x,y),z,0);
	}
	for(int i=1;i<=b;i++)
	{
		int x,y,z;
		cin>>z>>x>>y;
		add(bh(x,y),t,z,0);
	}
	EK();
	cout<<(-mcost)<<endl;
	return 0;
}
```


---

## 作者：Tenshi (赞：1)

## 分析
从题目中的容量限制以及边（网格点之间的边）具有**费用**的属性可以看出这是一个**最大费用最大流问题**。

下面考察一下如何建图就可以了：
+ 因为边的费用只能取一次，所以要在流网络的点与点之间连接两条边：一条容量为 $1$ ，费用为输入的标本价值 $w$ ，表示只能够取一次；而另一条容量为 $∞$ ，费用为 $0$ ，表明当取走标本之后，经过次数不受约束，但无法再取得费用。

+ 而因为这题具有多个源点和多个汇点，所以我们分别建立虚拟源点 $S$ ，$T$ ，$S$ 向多个源点连边，$T$ 向多个汇点连边即可。

实现细节：
+ 注意读入，在读入边的费用时题目读入的顺序存在先读入列后读入行的情况。
+ 求取最大费用（即最长路）时，只需将一般的 spfa 中 `d[go]>d[hd]+e[i].w` 改为 `d[go]<d[hd]+e[i].w` ，初始化距离 `d[]` 为 $-∞$ 即可。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=400, M=4*N+10+10<<1, INF=0x3f3f3f3f;

int n, m, S, T;
int cnt_s, cnt_t;

struct node{
	int to, c, w, next;
}e[M];

int h[N], tot;

void add(int u, int v, int c, int w){
	e[tot].to=v, e[tot].c=c, e[tot].w=w, e[tot].next=h[u], h[u]=tot++;
	e[tot].to=u, e[tot].c=0, e[tot].w=-w, e[tot].next=h[v], h[v]=tot++;
}

int d[N], q[N], lim[N], pre[N];
bool vis[N];

bool spfa(){
	memset(vis, false, sizeof vis), memset(lim, 0, sizeof lim), memset(d, 0xcf, sizeof d);
	int tt=0, hh=0;
	q[tt++]=S, d[S]=0, lim[S]=INF;
	
	while(tt!=hh){
		int hd=q[hh++]; if(hh==N) hh=0; // spfa 可能存在点多次入队情况，采取循环队列写法。
		vis[hd]=false;
		for(int i=h[hd]; ~i; i=e[i].next){
			int go=e[i].to;
			if(d[go]<d[hd]+e[i].w && e[i].c){
				d[go]=d[hd]+e[i].w;
				lim[go]=min(lim[hd], e[i].c);
				pre[go]=i;
				if(!vis[go]){
					vis[go]=true;
					q[tt++]=go; if(tt==N) tt=0; // spfa 可能存在点多次入队情况，采取循环队列写法。
				}
			}
		}
	}
	return lim[T]>0;
}

int EK(){
	int cost=0;
	while(spfa()){
		int t=lim[T];
		cost+=t*d[T];
		for(int i=T; i!=S; i=e[pre[i]^1].to){
			e[pre[i]].c-=t, e[pre[i]^1].c+=t; 
		}
	}
	return cost;
}

int id[20][20], cnt;

int main(){
	memset(h, -1, sizeof h);
	cin>>cnt_s>>cnt_t>>n>>m;
	
	for(int i=0; i<=n; i++) for(int j=0; j<=m; j++) id[i][j]=++cnt; // 预处理点编号
	
	S=0, T=cnt+1;
	for(int i=0; i<=n; i++) for(int j=0; j<=m-1; j++){
		int w; cin>>w;
		add(id[i][j], id[i][j+1], 1, w), add(id[i][j], id[i][j+1], INF, 0);
	}
	
	for(int j=0; j<=m; j++) for(int i=0; i<=n-1; i++){ // 注意这里的读入
		int w; cin>>w;
		add(id[i][j], id[i+1][j], 1, w), add(id[i][j], id[i+1][j], INF, 0);
	}
	
	while(cnt_s--){
		int c, x, y; cin>>c>>x>>y;
		add(S, id[x][y], c, 0);
	}
	
	while(cnt_t--){
		int c, x, y; cin>>c>>x>>y;
		add(id[x][y], T, c, 0);
	}
	
	cout<<EK()<<endl;
		
	return 0;
}
```

---

## 作者：xukuan (赞：1)

网络流之最大费用最大流

建模：
- 在相邻的点之间连两条边，一条的容量为1，费用输入；另一条容量为INF，费用为0
- 建立超级源点和超级汇点，从超级源点到机器人的出发点连一条边，容量为点上出发的机器人数，费用为0；从机器人的出发点到超级汇点连一条边，容量为点上到达的机器人数，费用为0

然后跑最大费用最大流（最大费用最大流的套路简要说下，就是连边时费用取相反数，跑最小费用最大流，最后输出时结果也输出相反数）

另外题目里那句“a行和b行输入时横纵坐标要反过来”不知道是什么意思，无视掉就行了

代码（spfa费用流）

```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
#define INF 2147483647
using namespace std;

ll A,B,P,Q,s,t,maxcost;
ll ver[100010],edge[100010],Next[100010],head[100010],cost[100010],tot=1;
ll v[100010],d[100010],flow[100010],prenode[100010],preedge[100010];
//flow[i]表示到点i的最大流量
//prenode[i]表示到点i的最大流量中前一个点是什么
//preedge[i]表示到点i的最大流量中前一条边是什么
queue<ll> q;

inline ll read(){
	ll x=0,tmp=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') tmp=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return tmp*x;
}

inline void addEdge(ll x,ll y,ll z,ll w){
	ver[++tot]=y,edge[tot]=z,Next[tot]=head[x],head[x]=tot,cost[tot]=w;
	ver[++tot]=x,edge[tot]=0,Next[tot]=head[y],head[y]=tot,cost[tot]=-w;
}

inline ll id(ll x,ll y){//给每一个点一个一维的编号
	return x*20+y+3;
}

inline bool spfa(){
    memset(v,0,sizeof(v));
    memset(d,0x3f,sizeof(d));
    memset(flow,0x3f,sizeof(flow));
    //初始化
    q.push(s); v[s]=1; d[s]=0;
    while(!q.empty()){
        ll x=q.front(); q.pop();
        v[x]=0;
        for(ll i=head[x]; i; i=Next[i]){
            ll y=ver[i],z=edge[i];
            if(z&&d[y]>d[x]+cost[i]){
                d[y]=d[x]+cost[i];
                flow[y]=min(flow[x],edge[i]);
                prenode[y]=x; preedge[y]=i;
                if(v[y]==0){
                    v[y]=1;
                    q.push(y);
                }
            }
        }
    }
    return d[t]<INF;
}

int main(){
	A=read(); B=read();
	P=read(); Q=read();
	s=1,t=2;
   //在相邻的点之间连两条边
	for(ll i=0; i<=P; i++){
		for(ll j=0; j<Q; j++){
			addEdge(id(i,j),id(i,j+1),1,-read());
			addEdge(id(i,j),id(i,j+1),INF,0);
		}
	}
	for(ll j=0; j<=Q; j++){
		for(ll i=0; i<P; i++){
			addEdge(id(i,j),id(i+1,j),1,-read());
			addEdge(id(i,j),id(i+1,j),INF,0);
		}
	}
    
   //建立超级源点和超级汇点并连边
	while(A--){
		ll x=read(),y=read(),z=read();
		addEdge(s,id(y,z),x,0);
	}
	while(B--){
		ll x=read(),y=read(),z=read();
		addEdge(id(y,z),t,x,0);
	}
    
   //最大费用最大流
	while(spfa()){
		maxcost-=d[t]*flow[t];
		for(ll i=t; i!=s; i=prenode[i]){
			edge[preedge[i]]-=flow[t];
			edge[preedge[i]^1]+=flow[t];
		}
	}
	cout<<maxcost<<endl;
	return 0;
}
```

---

## 作者：happybob (赞：0)

简单费用流。

考虑每个点 $(x,y)$ 转化成 $(x-1) \times (p+1) + y+16$。加上 $16$ 是为了避免结果为负数或 $0$。

题目限制只能往上或往右，于是对于每个点 $u$，找到上边和右边的点。由于上边和右边本质类似，以上边为例，设其为 $v$。

由于每条边只会被在第一次走过时计算贡献，所以连 $u \xrightarrow{cap=1,cost=w} v$，$w$ 是这条边的贡献。然而尽管第一次走算贡献，但接着这条路仍然可以走，只不过没有贡献，所以还要连 $u \xrightarrow{cap=+\infty,cost=0} v$。

对于每个起点 $u$，连 $S \xrightarrow{cap=k,cost=0} u$。对于每个终点 $v$，连 $v \xrightarrow{cap=k,cost=0} T$。跑最大费用最大流即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 5e5 + 5;

int p, q, n, m, S, T;
int e[N], h[N], c[N], cs[N], ne[N], idx;
int dis[N], cur[N], res = 0;
bool isin[N];

inline void add(int u, int v, int w, int cc)
{
	cc = -cc;
	e[idx] = v, c[idx] = w, cs[idx] = cc, ne[idx] = h[u], h[u] = idx++;
	e[idx] = u, c[idx] = 0, cs[idx] = -cc, ne[idx] = h[v], h[v] = idx++;
}

inline int get(int x, int y)
{
	return (x - 1) * (p + 1) + y + 16;
}

inline bool spfa()
{
	for (int i = 0; i <= T; i++) dis[i] = 2e9, cur[i] = -1;
	dis[S] = 0, cur[S] = h[S];
	queue<int> q;
	q.push(S);
	while (q.size())
	{
		int u = q.front();
		q.pop();
		isin[u] = 0;
		for (int i = h[u]; ~i; i = ne[i])
		{
			int j = e[i];
			if (dis[j] > dis[u] + cs[i] && c[i] > 0)
			{
				dis[j] = dis[u] + cs[i];
				cur[j] = h[j];
				if (!isin[j])
				{
					q.push(j);
					isin[j] = 1;
				}
			}
		}
	}
	return (dis[T] != 2e9);
}

inline int dfs(int u, int lim)
{
	if (u == T) return lim;
	isin[u] = 1;
	int sum = 0;
	for (int i = cur[u]; ~i && sum < lim; i = ne[i])
	{
		cur[u] = i;
		int j = e[i];
		if (!isin[j] && dis[j] == dis[u] + cs[i] && c[i] > 0)
		{
			int p = dfs(j, min(c[i], lim - sum));
			sum += p;
			c[i] -= p;
			c[i ^ 1] += p;
			res += p * cs[i]; 
		}
	}
	isin[u] = 0;
	return sum;
}

inline void dinic()
{
	while (spfa())
	{
		while (dfs(S, INT_MAX));
	}
}

int main()
{
	memset(h, -1, sizeof h);
	S = 5000, T = 5001;
	scanf("%d%d", &n, &m);
	scanf("%d%d", &p, &q);
	for (int i = 0; i <= p; i++)
	{
		int nowx = 0;
		for (int j = 1; j <= q; j++)
		{
			int ds;
			scanf("%d", &ds);
			add(get(nowx, i), get(nowx + 1, i), 1, ds);
			add(get(nowx, i), get(nowx + 1, i), INT_MAX, 0);
			nowx++;
		}
	}
	for (int i = 0; i <= q; i++)
	{
		int nowy = 0;
		for (int j = 1; j <= p; j++)
		{
			int ds;
			scanf("%d", &ds);
			add(get(i, nowy), get(i, nowy + 1), 1, ds);
			add(get(i, nowy), get(i, nowy + 1), INT_MAX, 0);
			nowy++;
		}
	}
	for (int i = 1; i <= n; i++)
	{
		int k, x, y;
		scanf("%d%d%d", &k, &x, &y);
		add(S, get(y, x), k, 0);
	}
	for (int i = 1; i <= m; i++)
	{
		int k, x, y;
		scanf("%d%d%d", &k, &x, &y);
		add(get(y, x), T, k, 0);
	}
	dinic();
	printf("%d\n", -res);
	return 0;
}
```


---

## 作者：RemiliaScar1et (赞：0)

#### 解析

题目略微冗杂，多读一会。

得到如下几点事项：

- 我们把数个机器人放到各个起点，让他们按照某种路线运动，机器人只能向上或向右走，且同一个点可以有多个机器人同时经过。
- 每条边上有生物标本，生物标本只能被采集一次，采集生物标本会获得其对应价值。
- 机器人只能在几个规定的终点回收，且每个终点回收机器人数量有上限。
- 我们要制定一种机器人放置及路线规划方案使其获得最大价值。求这个最大价值。
- ~~输入令人烦躁。~~

理清题意，我们发现这是一个多源汇的网格图模型。

首先套多源汇的套路，我们建立超级源点，向所有的起点连一条容量为 $k$ 的边，$k$ 为这个起点的机器人数量。所有的终点向超级汇点连一条 容量为 $r$ 的边，$r$ 为这个终点的回收数量上限。这些边费用都为 $0$ 。

然后是套网格图的套路，我们根据其向右和向上的行走方向，可知道点 $(i,j)$ 向 $(i+1,j)$ 和 $(i,j+1)$ 连边。由于只有一次能采集到标本，我们将边分为两条，一条容量为 $1$， 费用就是标本价值。另外一条容量 $+\infty$ ，费用 $0$。

于是我们可以发现，此时原问题的任意一个行走方案可以对应到这个网络的一个最大流，且原问题方案的价值和对应最大流的费用也能够对应。

故我们最大化费用即可。

这里使用的是EK算法。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=2e5+10,M=1e6+10,INF=1e8+10;

int n,m,A,B,S,T;
int head[N],ver[M],nxt[M],cc[M],ww[M],tot=0;
void add(int x,int y,int c,int d)
{
	ver[tot]=y; cc[tot]=c; ww[tot]=d; nxt[tot]=head[x]; head[x]=tot++;
	ver[tot]=x; cc[tot]=0; ww[tot]=-d; nxt[tot]=head[y]; head[y]=tot++;
}
int q[N],d[N],incf[N],pre[N];
bool vis[N];

int get(int x,int y)//坐标->点编号
{
	return x*16+y+1;
}

bool spfa()
{
	int hh=0,tt=1;
	memset(d,-0x3f,sizeof d);
	memset(incf,0,sizeof incf);
	q[0]=S; d[S]=0; incf[S]=INF;
	while(hh!=tt)
	{
		int x=q[hh++];
		if(hh==N) hh=0;
		vis[x]=0;

		for(int i=head[x];~i;i=nxt[i])
		{
			int y=ver[i];
			if(cc[i] && d[y]<d[x]+ww[i])
			{
				d[y]=d[x]+ww[i];
				pre[y]=i;
				incf[y]=min(cc[i],incf[x]);
				if(!vis[y])
				{
					q[tt++]=y;
					if(tt==N) tt=0;
					vis[y]=1;
				}
			}
		}
	}
	return incf[T]>0;
}

int EK()
{
	int cost=0;
	while(spfa())
	{
		int tmp=incf[T];
		cost+=d[T]*tmp;
		for(int i=T; i!=S; i=ver[pre[i]^1])
		{
			cc[pre[i]]-=tmp;
			cc[pre[i]^1]+=tmp;
		}
	}
	return cost;
}

int main()
{
	scanf("%d%d%d%d",&A,&B,&n,&m);
	memset(head,-1,sizeof head);
	S=N-1,T=N-2;
	for(int i=0;i<=n;i++)
	{
		for(int j=0;j<m;j++)//(i,j)->(i,j+1)
		{
			int x;
			scanf("%d",&x);
			add(get(i,j),get(i,j+1),1,x);
			add(get(i,j),get(i,j+1),INF,0);
		}
	}
	for(int i=0;i<=m;i++)
	{
		for(int j=0;j<n;j++)//(j,i)->(j+1,i)
		{
			int x;
			scanf("%d",&x);
			add(get(j,i),get(j+1,i),1,x);
			add(get(j,i),get(j+1,i),INF,0);
		}
	}
	for(int i=1;i<=A;i++)
	{
		int k,x,y;
		scanf("%d%d%d",&k,&x,&y);
		add(S,get(x,y),k,0);
	}
	for(int i=1;i<=B;i++)
	{
		int r,x,y;
		scanf("%d%d%d",&r,&x,&y);
		add(get(x,y),T,r,0);
	}
	printf("%d",EK());
	return 0;
}

```

---

## 作者：11D_Beyonder (赞：0)

## 分析   
&emsp;&emsp;给出了每条边的价值，要使多条路线的价值和最大，显然可以套用最大费用最大流模型。    
&emsp;&emsp;不妨将 $p,q$ 都加一，坐标原点设为 $(1,1)$，方便表示坐标为 $(x,y)$ 的点的编号。定义坐标为 $(x,y)$ 的点的编号为 $ID(x,y)=p(x-1)+y$。  
&emsp;&emsp;设源点 $s$，汇点 $t$。从 $s$ 向每个机器人开始的地方连容量为机器人数量，费用为 $0$ 的边。从每个目的地向 $t$连容量为 $r$，费用为 $0$ 的边。这就限定了最大流为机器人的总数。  
&emsp;&emsp;值得思考的是相邻点之间的连边。对于一个点 $(x,y)$，其相邻点为 $(x+1,y)$ 和 $(x,y+1)$。由于生物标本只能采集一次，可以从 $(x,y)$ 向其相邻点连边，容量为 $1$，费用为采集生物标本的价值；但是同一位置可以容纳多个机器人停留，那么不妨再建一条容量为 $+\infty$，费用为 $0$ 的边。求最大费用最大流时，产生价值的边一定会满流，且流量只能为 $1$，另一条费用为 $0$ 的边用来承载不采集标本的机器人。  
&emsp;&emsp;最后求出的最大费用最大流即为答案。  

## 代码  
```cpp
/******************************************************************
Copyright: 11D_Beyonder All Rights Reserved
Author: 11D_Beyonder
Problem ID: 洛谷 P4012
Date: 8/5/2020
Description: Maximum-cost Flow
*******************************************************************/
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int inf=0x3f3f3f3f;
const int N=1003;
struct E
{
	int to;
	int cap;
	int cost;
	int Next;
};
E edge[N<<6];
int head[N],tot;
int incf[N],pre[N];
int dis[N];
bool inqueue[N];
int a,b;
int p,q;
int s,t;
void init();
int ID(int,int);
inline void add_edge(int,int,int,int);
bool SPFA();
int MCMF();
int main()
{
	int i,j;
	cin>>a>>b;
	cin>>p>>q;
	p++;
	q++;
	init();
	//向东走的价值
	for(j=1;j<=p;j++)//枚举纵坐标
	{
		for(i=1;i<=q-1;i++)//枚举横坐标
		{
			int x;
			scanf("%d",&x);
			add_edge(ID(i,j),ID(i+1,j),1,-x);
			add_edge(ID(i,j),ID(i+1,j),inf,0);
		}
	}
	//向北走的价值
	for(i=1;i<=q;i++)//枚举横坐标
	{
		for(j=1;j<=p-1;j++)//枚举纵坐标
		{
			int x;
			scanf("%d",&x);
			add_edge(ID(i,j),ID(i,j+1),1,-x);
			add_edge(ID(i,j),ID(i,j+1),inf,0);
		}
	}
	//坐标要反着读
	while(a--)
	{
		int k,x,y;
		scanf("%d%d%d",&k,&y,&x);
		x++;
		y++;
		add_edge(s,ID(x,y),k,0);
	}
	while(b--)
	{
		int r,x,y;
		scanf("%d%d%d",&r,&y,&x);
		x++;
		y++;
		add_edge(ID(x,y),t,r,0);
	}
	cout<<-MCMF()<<endl;
	return 0;
}
void init()
{
	tot=1;
	memset(head,-1,sizeof(head));
	s=0;
	t=p*q+1;
}
inline void add_edge(int u,int v,int cap,int cost)
{
	tot++;
	edge[tot].to=v;
	edge[tot].cap=cap;
	edge[tot].cost=cost;
	edge[tot].Next=head[u];
	head[u]=tot;
	tot++;
	edge[tot].to=u;
	edge[tot].cap=0;
	edge[tot].cost=-cost;
	edge[tot].Next=head[v];
	head[v]=tot;
}
bool SPFA()
{
	queue<int>q;
	memset(dis,inf,sizeof(dis));
	memset(inqueue,0,sizeof(inqueue));
	q.push(s);
	dis[s]=0;
	inqueue[s]=1;
	incf[s]=inf;
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		inqueue[x]=0;
		for(register int i=head[x];~i;i=edge[i].Next)
		{
			if(!edge[i].cap) continue;//剩余容量为0，不在残量网络中。
			int y=edge[i].to;
			if(dis[y]>dis[x]+edge[i].cost)
			{
				dis[y]=dis[x]+edge[i].cost;//松弛操作
				incf[y]=min(incf[x],edge[i].cap);//最小剩余容量
				pre[y]=i;//记录前驱
				if(!inqueue[y])
				{
					inqueue[y]=1;
					q.push(y);
				}
			}
		}
	}
	if(dis[t]==inf) return 0;//汇点不可达，已经求出最大流
	else return 1;
}
int MCMF()
{
	int maxflow,mincost;
	maxflow=mincost=0;
	while(SPFA())
	{
		int x=t;
		//沿着前驱倒着走增广路
		while(x!=s)
		{
			int y=pre[x];
			edge[y].cap-=incf[t];
			edge[y^1].cap+=incf[t];
			x=edge[y^1].to;
		}
		maxflow+=incf[t];
		mincost+=dis[t]*incf[t];
	}
	return mincost;
}
int ID(int x,int y) {return (x-1)*p+y;}
```
## 后记  
&emsp;&emsp;严格按照题目图中描述的坐标，读入 $a$ 行和 $b$ 行确实要反过来。

---

## 作者：toolazy (赞：0)

~~什么？题解没满？水一波水一波（划掉~~

建议：看过 [P2045 「网络流24题」方格取数加强版](https://www.luogu.com.cn/problem/P2045) 后再来看这道题~~你会发现芝士双倍经验！（划掉~~

这个套路是差不多的，在路径上取数，可以取若干次。但不一样的是，[方格取数](https://www.luogu.com.cn/problem/P2045) 是附点权，而这题是附边权。

实际上是差不多的，我们依旧是用单位流量来表示一个机器人——附点权，我们一点拆**出入两点**。不同点之间的连接就**出点**连**入点**，表示移动；一个点的出入两点要**连两条边**，一条边是容量为 $1$，单价为 $w$，表示只能有**唯一的机器人**取这个样本，另一条边是容量为 $\infty$，单价为 $0$，表示剩下**后来的机器人取不到样本**，但是可以通过。

示意图差不多就这样（作图使用 [Graph Editor](https://csacademy.com/app/graph_editor/)）：

![](https://cdn.luogu.com.cn/upload/image_hosting/db62hf70.png)

~~（可能和准确描述有些出入，但介于其对于重边的显示问题，就将就一下啦（~~

这里对于一个点的出入两点中间连边的思路，我们也可以借鉴过来，而且更简单了：**一边拆两边**，一边单价不变，容量为 $1$，表示只能有**一个机器人**取这个边，另一边单价为 $0$，容量为 $\infty$，表示后来的机器人取不到边，**但可以通过**。

建模就是这样的啦，代码也不用怎么改。~~奉上丑陋的代码，我的 `MCMF` 和正常人不太一样qwq：~~

```C++
#include <iostream>
#include <vector>
#include <bitset>
#include <queue>
#include <cstring>
using namespace std;

#define MS 1005

struct edge {
	int to, rev, capacity, price;
};
vector<edge> g[MS];

void adde(int a, int b, int capacity, int price) {
	g[a].push_back({b, g[b].size(), capacity, price});
	g[b].push_back({a, g[a].size() - 1, 0, -price});
}

int s, t, cost, f, dis[MS], pre[MS], preIndex[MS];
#define inf 0x3f3f3f3f

int p, q, a, b, k, x, y;

#define pos(y, x) ((x) + (y) * (q + 1))

void createGraph() {
	ios :: sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> a >> b >> p >> q;
	for (int i = 0; i <= p; i ++) {
		for (int j = 0; j < q; j ++) {
			int w; cin >> w;
			adde(pos(i, j), pos(i, j + 1), 1, -w);
			adde(pos(i, j), pos(i, j + 1), inf, 0);
		}
	}
	for (int j = 0; j <= q; j ++) {
		for (int i = 0; i < p; i ++) {
			int w; cin >> w;
			adde(pos(i, j), pos(i + 1, j), 1, -w);
			adde(pos(i, j), pos(i + 1, j), inf, 0);
		}
	}
	s = pos(p, q) + 1, t = pos(p, q) + 2;
	while (a --) {
		cin >> k >> x >> y;
		adde(s, pos(x, y), k, 0);// 这里不要换过来!
	}
	while (b --) {
		cin >> k >> x >> y;
		adde(pos(x, y), t, k, 0);// 这里也是!!
	}
}

bitset<MS> inQ;
queue<int> Q;

bool SPFA(int s, int t) {
	memset(dis, 0x3f, sizeof(dis));
	memset(pre, -1, sizeof(pre));
	Q.push(s); inQ[s] = true; dis[s] = 0;
	while (!Q.empty()) {
		int u = Q.front();
		Q.pop(); inQ[u] = false;
		for (int i = 0; i < g[u].size(); i ++) {
			if (g[u][i].capacity == 0)
				continue;
			int v = g[u][i].to, w = g[u][i].price;
			if (dis[v] > dis[u] + w) {
				dis[v] = dis[u] + w;
				pre[v] = u; preIndex[v] = i;
				if (!inQ[v])
					Q.push(v);
			}
		}
	}
	return pre[t] != -1;
}

int augment(int start, int p, int neck, int & cost) {
	if (p == start)
		return neck;
	edge & e = g[pre[p]][preIndex[p]];
	edge & fe = g[e.to][e.rev];
	int flow = augment(start, pre[p],
		min(neck, e.capacity), cost);
	cost += flow * e.price;
	e.capacity -= flow;
	fe.capacity += flow;
	return flow;
}

void MCMF(int s, int t, int & flow, int & cost) {
	while (SPFA(s, t))
		flow += augment(s, t, inf, cost);
}

int main() {
	createGraph();
	MCMF(s, t, f, cost);
	cout << -cost;
	return 0;
}
```

话说网络流可真是个宝，你谷题单里面不是蓝紫就是黑，还不赶紧刷起来？

---


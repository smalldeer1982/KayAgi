# [JSOI2009] 球队收益 / 球队预算

## 题目描述

在一个篮球联赛里，有$n$支球队，球队的支出是和他们的胜负场次有关系的，具体来说，第i支球队的赛季总支出是$C_i\times x^2+D_i \times y^2,D_i \le C_i$。(赢得多，给球员的奖金就多嘛)
其中$x,y$分别表示这只球队本赛季的胜负场次。现在赛季进行到了一半，每只球队分别取得了$a_i$场胜利和$b_i$场失利。而接下来还有$m$场比赛要进行。问联盟球队的最小总支出是多少。

## 说明/提示

对于20%的数据$2 \le n \le 10,0 \le m \le 20$；  
对于100%的数据$2 \le n \le 5000,0 \le m \le 1000,0 \le D_i \le C_i \le 10,0 \le a_i,b_i \le 50$。

## 样例 #1

### 输入

```
3 3
1 0 2 1
1 1 10 1
0 1 3 3
1 2
2 3
3 1```

### 输出

```
43```

# 题解

## 作者：Hyscere (赞：11)

费用流。

对于每个球队设点$A_i$，每场未确定的比赛设$B_i$，那么有一个比较显然的框架：

- 对于每个点$A_i$，$A_i$到$t$连边，容量为剩下的场次中$i$最多可以赢的次数，这个次数设为$mx_i$。
- 对于每个点$B_i$，连边$(s,B_i),(B_i,x),(B_i,y)$，其中$x,y$表示这场比赛的双方，容量都为$1$。

很显然可以知道这个图的每一种最大流代表一种方案，现在我们的目的就是要给这个图的边加权，使得费用最小。

考虑一场比赛都没进行的时候（题目给出的结果不算），假设每支球队每场都输了，那么当前有一个总代价，然后比了一场比赛，那么必然就有一支球队输场$-1$，胜场$+1$，设原来赢了$a$场，输了$b$场，那么新增的代价就是：
$$c_i(a+1)^2+d_i(b-1)^2-c_ia^2-d_ib^2$$
$$=c_i+d_i+2c_ia-2d_ib$$
注意到随着胜场的增多，败场的减小，这个式子是单调递增的，也就是说，我们可以利用拆边的思想建图。

那么建图修改为：

- 对于每个点$A_i$，向$t$连$mx_i$条边，容量为$1$，费用依次递增，也就是上面那个式子。
- 其他的边费用均为$0$。

然后跑最小费用最大流，加上已经确定的花费，就是总代价了。

```c++
#include<bits/stdc++.h>
using namespace std;
 
void read(int &x) {
    x=0;int f=1;char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;
}
 
void print(int x) {
    if(x<0) putchar('-'),x=-x;
    if(!x) return ;print(x/10),putchar(x%10+48);
}
void write(int x) {if(!x) putchar('0');else print(x);putchar('\n');}

#define sqr(x) ((x)*(x))

const int maxn = 1e5+10;
const int inf = 1e9;

int n,m,s,t,tot=1,cost;
int head[maxn],vis[maxn],dis[maxn],a[maxn],b[maxn],C[maxn],D[maxn],l[maxn],fr[maxn],pre[maxn];
struct edge{int to,nxt,w,c;}e[maxn<<1];

void add(int u,int v,int w,int c) {e[++tot]=(edge){v,head[u],w,c},head[u]=tot;}
void ins(int u,int v,int w,int c) {add(u,v,w,c),add(v,u,0,-c);}

int bfs() {
    memset(dis,63,4*(t+1));
    memset(vis,0,4*(t+1));
    queue<int > q;q.push(s);dis[s]=0,vis[s]=1;
    while(!q.empty()) {
        int now=q.front();q.pop(),vis[now]=0;
        for(int i=head[now];i;i=e[i].nxt)
            if(e[i].w>0&&dis[e[i].to]>dis[now]+e[i].c) {
                dis[e[i].to]=dis[now]+e[i].c;
                if(!vis[e[i].to]) vis[e[i].to]=1,q.push(e[i].to);
            }
    }return dis[t]<inf;
}
 
int dfs(int x,int f) {
    vis[x]=1;
    if(x==t) return cost+=f*dis[t],f;
    int used=0;
    for(int i=head[x];i;i=e[i].nxt)
        if((e[i].to==t||!vis[e[i].to])&&e[i].w>0&&dis[e[i].to]==dis[x]+e[i].c) {
            int d=dfs(e[i].to,min(f-used,e[i].w));
            if(d>0) e[i].w-=d,e[i^1].w+=d,used+=d;
            if(used==f) break;
        }return used;
}
 
int mcmf() {
    cost=0;while(bfs()) dfs(s,inf);return cost;
}
		
int main() {
	read(n),read(m);s=n+m+1,t=s+1;
	for(int i=1;i<=n;i++) read(a[i]),read(b[i]),read(C[i]),read(D[i]);
	for(int i=1,x,y;i<=m;i++) {
		read(x),read(y),l[x]++,l[y]++;b[x]++,b[y]++;
		ins(s,i+n,1,0),ins(i+n,x,1,0),ins(i+n,y,1,0);
	}
	int ans=0;
	for(int i=1;i<=n;i++) ans+=C[i]*sqr(a[i])+D[i]*sqr(b[i]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=l[i];j++) ins(i,t,1,C[i]+D[i]+2*C[i]*a[i]-2*D[i]*b[i]),a[i]++,b[i]--;
	write(ans+mcmf());
	return 0;
}

```

---

## 作者：wind_whisper (赞：7)

## $\text{Foreword}$
不太一样的做法？  
和主流做法相比，本做法不需要推变化量的式子啦，而且**不需要 $D_i\le C_i$ 的条件，通用性更强**。  
## $\text{Solution}$
第一眼：代价平方？很难不想到~~二十分钟前刚做完的~~[CF863F](https://www.luogu.com.cn/problem/CF863F)。  
想想那道题怎么做的来着？  
每个数向汇点连 $n$ 条边，代价分别为 $1,3,5...$
原理也很显然，考虑平方的增量，$(k+1)^2-k^2=2k+1$。  

本题采用类似的思路。每支队伍开一个胜点、一个负点 $win_i,los_i$ 。  
设第 $i$ 支队伍参与了 $num_i$ 场比赛，那么就从胜点连 $num_i$ 条 $1$ 流边，代价为 $(2a_i+1)\cdot c_i,(2a_i+3)\cdot c_i,(2a_i+5)\cdot c_i...$，同理负点连边费用为 $(2b_i+1)\cdot d_i,(2b_i+3)\cdot d_i,(2b_i+5)\cdot d_i...$ 。  
然后每有一场 $u,v$ 之间的比赛就开两个新点 $x,y$，连边 $(s,x,1,0),(x,win_u,1,0),(x,win_v,1,0),(s,y,1,0),(y,los_u,1,0),(y,los_v,1,0)$，从而限制两个队伍必然只有一个赢，只有一个输。  

这看起来非常不对，因为可能有一支队伍又赢又输，出现了非法流。  
那么我们不把 $win_i,los_i$ 的边直接连向汇点了，而是再开一个新点 $id_i$，把边连向它，并连边 $(id_i,t,num_i,0)$，从而强制 $i$ 的胜负局加起来必须为 $num_i$。  
在这种建边下，如果某一场 $u,v$ 的比赛 $u$ 又赢又输，吸收了二的流。那么由于总的流没有任何冗余，$u$ 就必然在某一场比赛上会吸收零流，于是又产生了一个新的吸收二流的点，它也必须吸收一次零流...这样递归下去，只有递归回到吸收过一次零流的 $v$ 才会停止，而这和一开始 $u,v$ 一胜一负是等价的。  
所以这种连边是正确的。

## $\text{Code}$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define ok debug("OK\n")
using namespace std;

const int N=2e5+100;
const int inf=1e9;
inline ll read(){
  ll x(0),f(1);char c=getchar();
  while(!isdigit(c)) {if(c=='-')f=-1;c=getchar();}
  while(isdigit(c)) {x=(x<<1)+(x<<3)+c-'0';c=getchar();}
  return x*f;
}

int n,m;

int s,t,tot;
struct edge{
  int to,nxt,cap,w;
}p[N<<1];
int fi[N],cur[N],cnt;
inline void Addline(int x,int y,int c,int w){
  p[++cnt]=(edge){y,fi[x],c,w};fi[x]=cnt;
  return;
}
inline void add(int x,int y,int c,int w){
  Addline(x,y,c,w);Addline(y,x,0,-w);
  return;
}
int dis[N];
bool vis[N];
queue<int>que;
bool spfa(){
  memset(dis,0x3f,sizeof(int)*(tot+1));
  dis[s]=0;
  que.push(s);vis[s]=1;
  while(!que.empty()){
    int now=que.front();que.pop();
    vis[now]=0;
    for(int i=cur[now]=fi[now];~i;i=p[i].nxt){
      int to=p[i].to;
      if(!p[i].cap) continue;
      if(dis[to]>dis[now]+p[i].w){
	dis[to]=dis[now]+p[i].w;       
	if(!vis[to]){
	  que.push(to);vis[to]=1;
	}
      }
    }
  }
  return dis[t]<inf;
}
int flow,cost;
int dfs(int x,int lim){
  if(x==t||!lim){
    cost+=lim*dis[t];
    return lim;
  }
  if(vis[x]) return 0;
  vis[x]=1;
  int res(0);
  for(int &i=cur[x];~i;i=p[i].nxt){
    int to=p[i].to;
    if(dis[to]!=dis[x]+p[i].w) continue;
    int add=dfs(to,min(lim,p[i].cap));
    res+=add;lim-=add;
    p[i].cap-=add;p[i^1].cap+=add;
    if(!lim) break;
  }
  if(!res) dis[x]=-1;
  vis[x]=0;
  return res;
}
void dinic(){
  int tmp;
  flow=cost=0;
  while(spfa()){
    while((tmp=dfs(s,inf))) flow+=tmp;
  }
  return;
}

int win[5050],los[5050],id[5050],num[5050];
int a[5050],b[5050],c[5050],d[5050];
signed main(){
#ifndef ONLINE_JUDGE
  freopen("a.in","r",stdin);
  freopen("a.out","w",stdout);
#endif
  memset(fi,-1,sizeof(fi));cnt=-1;
  n=read();m=read();
  for(int i=1;i<=n;i++){
    a[i]=read();
    b[i]=read();
    c[i]=read();
    d[i]=read();
  }
  for(int i=1;i<=n;i++){
    win[i]=++tot;los[i]=++tot;id[i]=++tot;
    cost+=c[i]*a[i]*a[i]+d[i]*b[i]*b[i];
  }
  s=++tot;t=++tot;
  for(int i=1;i<=m;i++){
    int u=read(),v=read();
    num[u]++;num[v]++;
    int x=++tot,y=++tot;
    add(x,win[u],1,0);add(x,win[v],1,0);
    add(y,los[u],1,0);add(y,los[v],1,0);
    add(s,x,1,0);add(s,y,1,0);
  }
  for(int i=1;i<=n;i++){
    add(id[i],t,num[i],0);
    for(int j=0;j<num[i];j++){
      add(win[i],id[i],1,(2*(a[i]+j)+1)*c[i]);
      add(los[i],id[i],1,(2*(b[i]+j)+1)*d[i]);
    }
  }
  dinic();
  printf("%d\n",cost);
  return 0;
}
/*
*/
 

```


---

## 作者：M_seа (赞：4)

[更好的阅读体验](https://www.cnblogs.com/zzy2005/p/10299119.html)

##题解

最小费用最大流

先假设剩下$m$场比赛，双方全输。
考虑$i$赢一局的贡献
$C_i*(a_i+1)^2+D_i*(b_i-1)^2-C_i*a_i^2-D_i*b_i^2$
$=C _i+2*a_i*C_i+D_i-2*b_i*D_i$

建$m$个点限制每场比赛只有一个人赢，自$S$连一条$(1, 0)$的边

然后从这$m$的点连向和比赛有关的两个点一条$(1, 0)$的边


考虑关于$t$的边

因为$a_i$和$b_i$会变，不能直接连一条边

然后我们观察一下上面那个式子，
显然，赢得更多，贡献就增长越大

那么，拆边，我们可以对于每个点连向$t$很多条边，容量为$1$，价值是赢了对应场数的贡献

贪心地想，因为赢得更多，贡献增长越大，要最小费用，我们会先走赢得少的边
这样累加答案刚好满足条件呢

##Code

```cpp
#include<bits/stdc++.h>

#define LL long long
#define RG register

using namespace std;
template<class T> inline void read(T &x) {
	x = 0; RG char c = getchar(); bool f = 0;
	while (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;
	while (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();
	x = f ? -x : x;
	return ;
}
template<class T> inline void write(T x) {
	if (!x) {putchar(48);return ;}
	if (x < 0) x = -x, putchar('-');
	int len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;
	for (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;
}

const int N = 10000, inf = 2147483647;

struct node {
	int to, nxt, w, v;
}g[200*N];
int last[N], gl = 1;
void add(int x, int y, int w, int v) {
	g[++gl] = (node) {y, last[x], w, v};
	last[x] = gl;
	g[++gl] = (node) {x, last[y], 0, -v};
	last[y] = gl;
}

queue<int> q;
int pre[N], dis[N], from[N], s, t;
bool vis[N];

bool spfa() {
	memset(dis, 127, sizeof(dis));
	dis[s] = 0;
	q.push(s);
	while (!q.empty()) {
		int u = q.front(); q.pop();
		for (int i = last[u]; i; i = g[i].nxt) {
			int v = g[i].to;
			if (g[i].w && dis[v] > dis[u] + g[i].v) {
				dis[v] = dis[u] + g[i].v; pre[v] = u; from[v] = i;
				if (!vis[v]) {
					vis[v] = 1;
					q.push(v);
				}
			}
		}
		vis[u] = 0;
	}
	return dis[t] != dis[0];
}

int Mcmf() {
	int ans = 0;
	while (spfa()) {
		int di = inf;
		for (int i = t; i != s; i = pre[i]) di = min(di, g[from[i]].w);
		ans += di*dis[t];
		for (int i = t; i != s; i = pre[i]) g[from[i]].w -= di, g[from[i]^1].w += di;
	}
	return ans;
}
int a[N], b[N], c[N], d[N], cnt[N];

int main() {
	int n, m, sum = 0;
	read(n), read(m);
	s = m+n+1, t = s+1;
	for (int i = 1; i <= n; i++)
		read(a[i]), read(b[i]), read(c[i]), read(d[i]);
	for (int i = 1; i <= m; i++) {
		int x, y;
		read(x), read(y);
		b[x]++, b[y]++;
		cnt[x]++; cnt[y]++;
		add(s, i, 1, 0);
		add(i, x+m, 1, 0);
		add(i, y+m, 1, 0);
	}
	for (int i = 1; i <= n; i++)
		sum += c[i]*a[i]*a[i] + d[i]*b[i]*b[i];
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= cnt[i]; j++) {
			add(i+m, t, 1, c[i]+2*a[i]*c[i]+d[i]-2*b[i]*d[i]);
			b[i]--; a[i]++;
		}
	}
	printf("%d\n", sum+Mcmf());
	return 0;
}

```


---

## 作者：CAICAIA (赞：3)

# P4307 [JSOI2009] 球队收益 / 球队预算 题解

[题目传送门](https://www.luogu.com.cn/problem/P4307)

## 题意简述

一共有 $n$ 个球队比赛，输了赢了都会有相应的支出，现在让你安排 $m$ 场比赛的输赢，是总支出最少。

## 思路

首先看到最小支出，状态不好定义，直接使用费用流。

后文如果没有特殊说明，边的费用均为 $0$。

我提供一种非常好想的建图方式。

首先，一共 $m$ 场比赛，对于第 $i$ 场比赛，我们要分配到底是哪一方赢(后文用 $s$ 和 $t$ 表示这两个球队)。

由于输和赢的代价不好一起表示，所以将每个球队 $i$ 考虑拆为两个点 $i_{win}$ 和 $i_{los}$。

考虑新建两个节点 $m_i$ 和 $m_j$，然后从源点向 $m_i$ 和 $m_j$ 分别连容量 $1$ 的边。

从 $m_i$ 向 $s_{win}$,$t_{win}$ 连容量为 $1$ 的边。

从 $m_j$ 向 $s_{los}$,$t_{los}$ 连容量为 $1$ 的边。

这样我们就控制了每场比赛必然有一方赢，一方输（并不是一方赢，**另**一方输）。

但我们会发现，可能会出现 $s$ 赢的同时 $s$ 也输了这种情况，所以，我们还得限制这种情况。

考虑在建两个新点 $o_s$ 和 $o_t$，然后分别从 $s_{win}$ 和 $s_{los}$ 向 $o_s$ 连容量为 $1$ 的边，$t_{win}$ 和 $t_{los}$ 向 $o_t$ 连容量为 $1$ 的边。

这样我们从两个方面分别限制，就只会出现一方赢，**另**一方输的情况了。

比赛建完，现在考虑支出。

不好求点的代价怎么办，拆！

现在就相当于把每个球队 $i$ 拆成了四个点（~~不会其他的建图，没法啊~~），赢的点拆成入和出，输的点拆成入和出。

处理入点和出点间平方的费用，直接上公式 $n^2=\sum\limits_{i=1}^n{2\times i-1}$。

也就是说：

1. 对于 $i$ 球队赢的点入点向出点建 $sum_i$（表示这个球队参与了多少场比赛）条边，对于第 $j$ 条边，建一条容量为 $1$ 费用为 $c_i\times((j+a_i-1)\times+1)$ 的边。

2. 对于 $i$ 球队输的点入点向出点建 $sum_i$ 条边，对于第 $j$ 条边，建一条容量为 $1$ 费用为 $d_i\times((j+b_i-1)\times+1)$ 的边。

最后跑最小费用最大流，设最小费用为 $cy$，答案为 $cy+\sum\limits_{i=1}^n{c_i\times a_i^2 +d_i\times b_i^2}$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MX_N=50100,MX_M=5000100;
const int INF=0x3f3f3f3f;
struct node{
    int to,next;
    int w,cost;
}edge[MX_M<<1];
int head[MX_N]={0},edge_cnt=0;
inline void Add(int x,int y,int w,int c){
    node& it=edge[edge_cnt];
    it.cost=c;it.next=head[x];it.w=w;it.to=y;
    head[x]=edge_cnt++;
}

inline void add(int x,int y,int w,int c){
    Add(x,y,w,c),Add(y,x,0,-c);
}
int s=0,t=MX_N-1;
int pre[MX_N]={0},lim[MX_N]={0},dist[MX_N]={0};
bool vis[MX_N]={0};
bool spfa(){
    memset(lim,0,sizeof(lim));memset(dist,INF,sizeof(dist));memset(vis,0,sizeof(vis));
    queue<int >qu;
    qu.push(s);lim[s]=INF,vis[s]=1,dist[s]=0;
    while(!qu.empty()){
        int now=qu.front();qu.pop();vis[now]=0;
        for(int i=head[now];~i;i=edge[i].next){
            int to=edge[i].to,w=edge[i].w,cost=edge[i].cost;
            if(w&&dist[to]>dist[now]+cost){
                dist[to]=dist[now]+cost;
                pre[to]=i;
                lim[to]=min(lim[now],w);
                if(!vis[to]){
                    qu.push(to);
                    vis[to]=1;
                }
            }
        }
    }
    return lim[t]>0;
}
void EK(int &flow,int &cost){
    flow=cost=0;
    while(spfa()){
        flow+=lim[t];
        cost+=lim[t]*dist[t];
        for(int i=t;i!=s;i=edge[pre[i]^1].to){
            edge[pre[i]].w-=lim[t];
            edge[pre[i]^1].w+=lim[t];
        }
    }
}
int n,m;
int tot[5010]={0};
int ai[5010]={0},bi[5010]={0},ci[5010]={0},di[5010]={0};
inline int has(int x,bool sf,bool io){
    int sum=4*m;
    if(sf==1&&io==0)  return sum+x;
    if(sf==1&&io==1)  return sum+x+n;
    if(sf==0&&io==0)  return sum+x+n+n;
    if(sf==0&&io==1)  return sum+x+n+n+n;
}
signed main(){
    memset(head,-1,sizeof(head));
    //=======================================
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d%d%d%d",ai+i,bi+i,ci+i,di+i);
    }
    for(int i=1;i<=m;i++){
        int x,y;scanf("%d%d",&x,&y);
        tot[x]++,tot[y]++;
        add(s,i,1,0),add(s,i+m,1,0);

        add(i,has(x,1,0),1,0),add(i,has(y,1,0),1,0);
        add(i+m,has(x,0,0),1,0),add(i+m,has(y,0,0),1,0);

        add(has(x,1,1),i+m+m,1,0),add(has(x,0,1),i+m+m,1,0);
        add(has(y,1,1),i+m+m+m,1,0),add(has(y,0,1),i+m+m+m,1,0);

        add(i+m+m,t,1,0),add(i+m+m+m,t,1,0);
    }
    int sumn=0;
    for(int i=1;i<=n;i++){
        sumn+=ci[i]*(ai[i]*ai[i])+di[i]*(bi[i]*bi[i]);
        for(int k=0;k<=tot[i];k++){
            add(has(i,1,0),has(i,1,1),1,ci[i]*((k+ai[i])*2+1));
            add(has(i,0,0),has(i,0,1),1,di[i]*((k+bi[i])*2+1));
        }
    }
    int flow,cost;EK(flow,cost);
    printf("%d",sumn+cost);
    //=======================================
    return 0;
}
```

---

## 作者：撤云 (赞：2)

### 题目链接

[戳我](https://www.luogu.org/problemnew/show/P4307)

### $Solution$

我们发现这道题目并不好做，因为要考虑两个因素对答案的影响。于是我们假设接下来的$m$场比赛双方都输了。这要我们就只要考虑赢一场对答案的影响了,那每赢一场输的数量就会减少$1$.所以我们来化简一下式子:  
>$$c*(x+1)^2-d*(y-1)^2-c*x^2-d*y^2=2*c*x-2*d*y+c+d$$
$x$为赢的数量，$y$为输的数量

我们对于这个发现不能直接的算贡献，于是直接拆边做费用流就好了,最后答案就是全输之后的答案加上费用流即可

### $Code$
见[博客](https://www.cnblogs.com/hbxblog/p/10297286.html)

---

## 作者：戦艦はるな (赞：1)

### 费用流
（思路其实也是借鉴的）

思路如下：

由src到每场比赛连一条边，流量**1**，费用**0**；由每场比赛到每场比赛的参加方连边，流量**1**，费用**0**。（流量实际上是胜场）

设一个队胜场为**i**，负场为**j**，则增加**1**胜场，减少**1**负场对预算的影响为正的**c*(2*i+1)-d*(2*j-1)**。

先设所有队在接下来的比赛中全负，然后从每个人连参加次数条边到**sink**：流量**1**，费用**c*(2*i+1)-d*(2*j-1)** ，然后 **i+1,j-1**。

由费用流的性质，我们可以保证每场比赛都有胜者且花费最小。把费用流的结果加上所有队在接下来的比赛中全负的情况的花费即可。

贴code：
```cpp
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <queue>
#include <cstdio>
#define prev Prev
using namespace std;

const int MAXN=20005,MAXM=1000005,INF=1<<30;

int n,m,src,sink;
struct Edge
{
    int v,w,c,next,rev;
}e[MAXM];
int front[MAXN];
int pree[MAXN],prev[MAXN],dis[MAXN],vis[MAXN];
int to=0;
void addEdge(int a,int b,int c,int d)
{
    to++;e[to].v=b;e[to].w=c;e[to].c=d;e[to].next=front[a];front[a]=to;e[to].rev=to+1;
    to++;e[to].v=a;e[to].w=0;e[to].c=-d;e[to].next=front[b];front[b]=to;e[to].rev=to-1;
}
queue<int> q;
bool spfa()
{
    for(int i=1;i<=n+m+2;i++)dis[i]=INF;
    memset(vis,0,sizeof(vis));
    vis[src]=1;dis[src]=0;
    q.push(src);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=front[u];i;i=e[i].next)
        {
            if(e[i].w>0&&dis[e[i].v]>dis[u]+e[i].c)
            {
                dis[e[i].v]=dis[u]+e[i].c;
                pree[e[i].v]=i;
                prev[e[i].v]=u;
                if(!vis[e[i].v])
                {
                    vis[e[i].v]=1;
                    q.push(e[i].v);
                }
            }
        }
        vis[u]=false;
    }
    return dis[sink]<INF;
}
long long ans1=0,ans2=0;
void augment()
{
    int u=sink,dt=INF;
    while(u!=src)
    {
    	dt=min(dt,e[pree[u]].w);
        u=prev[u]; 
    }
    u=sink;
    while(u!=src)
    {
        e[pree[u]].w-=dt;
        e[e[pree[u]].rev].w+=dt;
        u=prev[u];
    }  
    ans2+=dt*dis[sink];
    ans1+=dt;
}//费用流
int qt[MAXN],wi[MAXN],lo[MAXN],c[MAXN],d[MAXN];
int main()
{
    long long ans=0;
    cin>>n>>m;
    src=n+m+1,sink=src+1;
    for(int i=1;i<=n;i++)
        cin>>wi[i]>>lo[i]>>c[i]>>d[i];
    int tmp1,tmp2;
    for(int i=1;i<=m;i++)
    {
        cin>>tmp1>>tmp2;
        qt[tmp1]++;qt[tmp2]++;lo[tmp1]++;lo[tmp2]++;
        addEdge(src,i+n,1,0);
        addEdge(i+n,tmp1,1,0);
        addEdge(i+n,tmp2,1,0);
    }
    for(int i=1;i<=n;i++)
    	ans+=c[i]*wi[i]*wi[i]+d[i]*lo[i]*lo[i];
        //求出所有队在接下来的比赛中全负的结果
    for(int i=1;i<=n;i++)
        for(int j=1;j<=qt[i];j++)
        {
            addEdge(i,sink,1,c[i]*(2*wi[i]+1)-d[i]*(2*lo[i]-1));
            wi[i]++;lo[i]--;
        }
        //建图
    while(spfa())augment();
    ans+=ans2;
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Acoipp (赞：0)

## 分析

网络流。

首先对于每一场比赛我们有两种选择：$s$ 赢 $t$ 输或 $s$ 输 $t$ 赢。

我们考虑先让所有人都输所有的比赛，那么我们后面的决策就变成了 $s$ 赢或者 $t$ 赢，接下来考虑一个球队赢的场数加 $1$，输的场数减少 $1$ 的贡献，大概是这样的：

（$x$ 是目前赢的场数，$n$ 是总场数，容易发现 $n$ 是固定的）

原来的贡献：$cx^2+d(n-x)^2=cx^2+dn^2+dx^2-2dnx$。

“扳回”一场后的贡献：$c(x+1)^2+d(n-x-1)^2=cx^2+c+2cx+dn^2+dx^2+d-2dnx-2dn+2dx$。

用第二个式子减去第一个式子得到增量等于 $c+2cx+d-2dn+2dx$。

容易发现 $x$ 越大时，扳回一场后贡献就会越大，我们肯定是想要较小的代价的，于是确定使用最小费用最大流。

对于某个队伍向汇点连接最多扳回场数数量的边，流量都是 $1$，然后边权就是当 $x=now+i$ 时扳回 $1$ 场后加的贡献。（$now$ 是最坏情况下赢多少场，$i$ 的取值范围是 $0$ 到最好情况下赢的场数减去 $now$ 的值）

然后每一场比赛必然有一个队伍获胜，建立一个虚点 $p$，$s$ 向 $p$ 连接边权为 $0$，流量为 $1$ 的边，$p$ 向那两只队伍连接边权为 $0$，流量为 $1$ 的边。

这个流量一定会流到一个队伍所代表的点上，然后因为 $x$ 越大，边权就会越大，我们费用流跑出来的结果一定是覆盖了一段前缀，容易发现这是最优值，故直接跑是对的。

## 时间复杂度

总的点数是 $O(n+m)$，边数是 $O(m)$ 级别的，正常写的费用流都可以通过。

## 代码

代码中使用了多路增广这个小技巧。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 500005
using namespace std;
ll n,m,s,t,inf,i,j,a[N],b[N],c[N],d[N],del[N],id[N],x,y;
ll la[N],ne[N],to[N],val[N],tot=1,vis[N],viss[N],q[N],he,ta,ans1,ans2,w[N],dis[N];
inline void merge(ll x,ll y,ll z,ll c){
	tot++,ne[tot] = la[x],la[x] = tot,to[tot] = y,val[tot] = z,w[tot] = c;
	tot++,ne[tot] = la[y],la[y] = tot,to[tot] = x,val[tot] = 0,w[tot] = -c;
}
bool spfa(){
	for(ll i=0;i<inf;i++) dis[i]=0x3f3f3f3f3f3f3f3f;
	q[he=ta=1]=s;
	dis[s]=0;
	while(he<=ta){
		ll tmp = q[he++];
		vis[tmp] = 0;
		for(ll i=la[tmp];i;i=ne[i]){
			if(val[i]>0&&dis[to[i]]>dis[tmp]+w[i]){
				dis[to[i]] = dis[tmp]+w[i];
				if(!vis[to[i]]) vis[to[i]]=1,q[++ta]=to[i];
			}
		}
	}
	return dis[t]<=1e18;
}
ll dfs(ll x,ll step){
	if(x==t) return step;
	viss[x] = 1;
	ll used = 0;
	for(ll i=la[x];i;i=ne[i]){
		if(dis[x]+w[i]==dis[to[i]]&&val[i]>0&&!viss[to[i]]){
			ll temp = dfs(to[i],min(val[i],step-used));
			val[i] -= temp,val[i^1] += temp,used += temp;
			if(used==step) return used;
		}
	}
	return used;
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	s=0,t=1,inf=2;
	for(i=1;i<=n;i++) cin>>a[i]>>b[i]>>c[i]>>d[i],id[i]=inf++;
	while(m--){
		cin>>x>>y;
		merge(s,inf,1,0),merge(inf,id[x],1,0),merge(inf,id[y],1,0);
		b[x]++,b[y]++,del[x]++,del[y]++,inf++;
	}
	for(i=1;i<=n;i++){
		ans2+=c[i]*a[i]*a[i]+d[i]*b[i]*b[i];
		for(j=1;j<=del[i];j++) merge(id[i],t,1,c[i]+2*c[i]*(a[i]+j-1)+d[i]-2*d[i]*(a[i]+b[i])+2*d[i]*(a[i]+j-1));
	}
	while(spfa()){
		for(i=0;i<inf;i++) viss[i]=0;
		ll temp = dfs(s,1e18);
		ans1 += temp,ans2 += temp*dis[t];
	}
	cout<<ans2<<endl;
	return 0;
} 
/*
Input:
3 3
1 0 2 1
1 1 10 1
0 1 3 3
1 2
2 3
3 1

Output:
43
*/
```

---

## 作者：FutaRimeWoawaSete (赞：0)

没见过的 trick，记录一下。

考虑问题的难点就在于如何建出谁输谁赢的关系。

将 $A$ 的胜负，$B$ 各看成一个点，$B$ 可以被分配一个大小为 $2$ 的流量流向 $A$ 中的一胜一负两个点，但是这样会出现不合法的选择情况。

考虑到直接暴力建是一个关于流量为 $2$ 的二元选择关系，不妨先假设有一元全部选满后重新分配选择关系，使建图变成一个流量为 $1$ 的二元选择关系。

具体到此题而言，我们可以假设每个人全都输满，如果选择一个人让他赢那么另外一个人本身就分配的输情况，可以不管他；对于选择让他赢的那个人 $i$ 假设他之前赢了 $x$ 场输了 $y$ 场，推一下变化量的式子：

$(x + 1) ^ 2 C_i + (y - 1)^2D_i - x^2C_i-y^2D_i$

化一下简：

$=(2x+1)C_i-(2y+1)D_i$   

随着 $x$ 的增大，$y$ 的值减小，变化量的值不断增大。

则我们直接将每种情况当成一种边建出来，显然网络流会优先增广前面的边，从而符合题意。

```cpp
/*
D,C <= 10
诡异的性质。
先考虑如何表示增量，可以对每个点建一个输点一个赢点 
一种比较暴力的构造是直接放每个队赢多少次
要保证一条边先于一条边流？可以强行让费用加一个 midInf，但是好像没有什么 p 用……
啊啊啊啊我无了
来胡一个，冲
怎么表示一个方案的选择/yjw
相当于选一边不能选另一边了 
After reading some tips
厉害，没想到
哦，还是可以再搞搞 
*/
#include "bits/stdc++.h"
using namespace std;
const int Len = 2e4 + 5;
const int Inf = 1e9;
int n,m,head[Len],cnt = 1,cur[Len],flag[Len],S,T,vis[Len],maxflow,a[Len],b[Len],bb[Len],C[Len],D[Len];
long long dis[Len],mincost;
struct Node
{
	int next,to,w;
	long long ww;
}edge[Len << 3];
void add(int from,int to,int w,long long ww)
{
	edge[++ cnt].to = to;
	edge[cnt].next = head[from];
	edge[cnt].w = w;
	edge[cnt].ww = ww;
	head[from] = cnt;
	swap(from , to);
	edge[++ cnt].to = to;
	edge[cnt].next = head[from];
	edge[cnt].w = 0;
	edge[cnt].ww = -ww;
	head[from] = cnt;
}
bool SPFA()
{
	queue<int> Q;
	for(int i = 1 ; i <= T ; i ++) dis[i] = Inf , flag[i] = vis[i] = 0;
	dis[S] = 0 , cur[S] = head[S] , vis[S] = 1;
	Q.push(S);
	while(!Q.empty())
	{
		int p = Q.front();
		Q.pop();
		vis[p] = false;
		for(int e = head[p] ; e ; e = edge[e].next)
		{
			int to = edge[e].to;
			if(edge[e].w && dis[to] > dis[p] + edge[e].ww)
			{
				dis[to] = dis[p] + edge[e].ww;
				cur[to] = head[to];
				if(!vis[to]) Q.push(to) , vis[to] |= 1;
			}
		}
	}
	if(dis[T] == Inf) return 0;
	return 1;
}
int dfs(int u,int In)
{
	if(u == T) return In;
	int Out = 0;
	flag[u] = 1;
	for(int e = cur[u] ; e && In > 0 ; e = edge[e].next)
	{
		cur[u] = e;
		int to = edge[e].to;
		if(!flag[to] && edge[e].w && dis[to] == dis[u] + edge[e].ww)
		{
			int res = dfs(to , min(In , edge[e].w));
			mincost += res * edge[e].ww;
			In -= res;
			Out += res;
			edge[e].w -= res;
			edge[e ^ 1].w += res;
		}
	}
	flag[u] = 0;
	if(!Out) dis[u] = -1;
	return Out;
}
int main()
{
	scanf("%d %d",&n,&m);
	S = n + m + 1 , T = S + 1;
	for(int i = 1 ; i <= n ; i ++) 
	{
		scanf("%d %d %d %d",&a[i],&b[i],&C[i],&D[i]);
		bb[i] = b[i];
	}
	for(int i = 1 ; i <= m ; i ++) 
	{
		int s,t;scanf("%d %d",&s,&t);
		b[s] ++ , b[t] ++;
		add(S , i , 1 , 0);
		add(i , s + m , 1 , 0);
		add(i , t + m , 1 , 0);
	}
	long long ans = 0;
	for(int i = 1 ; i <= n ; i ++) ans += 1ll * C[i] * a[i] * a[i] + 1ll * D[i] * b[i] * b[i];
	for(int i = 1 ; i <= n ; i ++) 
	{
		int now = a[i];
		for(int j = b[i] ; j >= bb[i] ; j --) 
		{
			add(i + m , T , 1 , C[i] + D[i] + 1ll * 2 * now * C[i] - 1ll * 2 * j * D[i]);
			now ++;
		}
	}
	while(SPFA()) 
	{
		int res = dfs(S , Inf);
		if(!res) break;
		maxflow += res;
	}
	printf("%lld\n",ans + mincost);
	return 0;
}
```

---

## 作者：TYxxj (赞：0)

## 要求总费用最低考虑最小费用最大流。

对于一场比赛同时决策两支队伍谁输谁赢不好办，我们先假设剩下的比赛每支队伍都输了，这样每次只要决策谁赢了即可。

对于每次比赛将源点连向比赛，流量为$1$、费用为$0$；再将比赛连向两支队伍，流量为$1$、费用为$0$。

假设每支队伍还有$k_{i}$场比赛，那么就将这只队伍向汇点连$k_{i}$条边，流量为$1$，每条边费用为多赢一次的收益。

每支队伍的起始收益为 $C_{i}$\*$x^2$+$D_{i}$\*$y^2$, $x=win_{i}$, $y=lose_{i}+k_{i}$，

每多赢一次的收益为$C*(x+1)^2+D*(y-1)^2-C*x^2-D*y^2=C*(2x+1)-D*(2y-1)$，

因为$D\le C$，所以每多赢一次的收益会单调递增，又因为是最小费用最大流，

所以一定先选赢一次的边、再选赢两次的边、再选赢三次的边……

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5010,maxm=6010,maxe=1e5+10,inf=0x3f3f3f3f;
char buf[1<<15],*fs,*ft;
inline char getc() {
	return (ft==fs&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),ft==fs))?0:*fs++;
}
template<typename T>inline void read(T &x) {
	x=0;
	T f=1, ch=getchar();
	while (!isdigit(ch) && ch^'-') ch=getchar();
	if (ch=='-') f=-1, ch=getchar();
	while (isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48), ch=getchar();
	x*=f;
}
char Out[1<<24],*fe=Out;
inline void flush() {
	fwrite(Out,1,fe-Out,stdout);
	fe=Out;
}
template<typename T>inline void write(T x) {
	if (!x) *fe++=48;
	if (x<0) *fe++='-', x=-x;
	T num=0, ch[20];
	while (x) ch[++num]=x%10+48, x/=10;
	while (num) *fe++=ch[num--];
	*fe++='\n';
}
int ver[maxe],edge[maxe],Next[maxe],cost[maxe],head[maxm],len=1;
inline void add(int x,int y,int z,int c) {
	ver[++len]=y,edge[len]=z,cost[len]=c,Next[len]=head[x],head[x]=len;
	ver[++len]=x,edge[len]=0,cost[len]=-c,Next[len]=head[y],head[y]=len;
}
int s,t,dist[maxm];
bool vis[maxm];
inline bool spfa() {
	memset(dist,0x3f,sizeof(dist));
	memset(vis,0,sizeof(vis));
	queue<int>q;
	q.push(s);
	dist[s]=0,vis[s]=1;
	while (!q.empty()) {
		int x=q.front();
		q.pop();
		vis[x]=0;
		for (int i=head[x]; i; i=Next[i]) {
			if (!edge[i]) continue;
			int y=ver[i];
			if (dist[y]>dist[x]+cost[i]) {
				dist[y]=dist[x]+cost[i];
				if (!vis[y]) q.push(y),vis[y]=1;
			}
		}
	}
	if (dist[t]==inf) return false;
	else return true;
}
int ans;
inline int get(int x,int low) {
	vis[x]=1;
	if (x==t) return low;
	int tmp=low;
	for (int i=head[x]; i; i=Next[i]) {
		int y=ver[i];
		if (edge[i] && dist[y]==dist[x]+cost[i] && (!vis[y] || y==t)) {
			int a=get(y,min(tmp,edge[i]));
			if (a>0) {
				ans+=a*cost[i];
				edge[i]-=a;
				edge[i^1]+=a;
				if (!(tmp-=a)) break;
			}
		}
	}
	return low-tmp;
}
inline void NetFlow() {
	while (spfa()) {
		vis[t]=1;
		while (vis[t]) {
			memset(vis,0,sizeof(vis));
			get(s,inf);
		}
	}
}
typedef int iarr[maxn];
iarr win,lose,c,d,In;
int main() {
	int n,m;
	read(n); read(m);
	s=0,t=n+m+1;
	for (int i=1; i<=n; ++i) read(win[i]),read(lose[i]),read(c[i]),read(d[i]);
	for (int i=1,x,y; i<=m; ++i) add(s,i,1,0),read(x),read(y),add(i,x+m,1,0),add(i,y+m,1,0),++In[x],++In[y];
	for (int i=1; i<=n; ++i) lose[i]+=In[i];
	for (int i=1; i<=n; ++i) ans+=win[i]*win[i]*c[i]+lose[i]*lose[i]*d[i];//直接计算初始收益
	for (int i=1; i<=n; ++i) for (int j=1; j<=In[i]; ++j) add(i+m,t,1,2*c[i]*win[i]+c[i]+d[i]-2*d[i]*lose[i]),--lose[i],++win[i];
	NetFlow();
	write(ans);
	flush();
}
```

---


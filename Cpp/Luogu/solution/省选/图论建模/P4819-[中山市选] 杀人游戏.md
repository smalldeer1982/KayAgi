# [中山市选] 杀人游戏

## 题目描述

一位冷血的杀手潜入 Na-wiat，并假装成平民。警察希望能在 $N$ 个人里面，查出谁是杀手。警察能够对每一个人进行查证，假如查证的对象是平民，他会告诉警察，他认识的人，谁是杀手，谁是平民。假如查证的对象是杀手，杀手将会把警察干掉。现在警察掌握了每一个人认识谁。每一个人都有可能是杀手，可看作他们是杀手的概率是相同的。

问：根据最优的情况，保证警察自身安全并知道谁是杀手的概率最大是多少？

## 说明/提示

警察只需要查证 $1$。假如 $1$ 是杀手，警察就会被杀。假如 $1$ 不是杀手，他会告诉警察 $2,3,4,5$ 谁是杀手。而 $1$ 是杀手的概率是 $0.2$，所以能知道谁是杀手但没被杀的概率是 $0.8$。

对于 $100\%$ 的数据有 $1\le N\le 1\times 10^5,0\le M\le 3\times 10^5$。

## 样例 #1

### 输入

```
5 4 
1 2 
1 3 
1 4 
1 5 ```

### 输出

```
0.800000```

# 题解

## 作者：LFCode (赞：70)

### 题目描述

有向图中有若干白点和一个黑点，每个点为黑点概率相等。每次可以任选一个点发起询问，询问结果为该点能直接到达的所有点的颜色。

求最优情况下不对黑点发起询问且得知黑点标号的概率。

----------

### 解法

首先考虑连通性。容易发现的一条性质：如果对某个强连通分量中的任意一点发起询问，只要该点不是黑点，我们就能在没有任何风险的情况下得知该强连通分量中所有点的颜色。

因此可以确定解决本题的第一个步骤：缩点，将所有强连通分量看作一个点。此时图转化为一张 DAG。

继续思考。在得到的 DAG 中，如果某个点有入边，那么与其先询问该点，不如先对向该点有出边连接的点发起询问。原因很简单：如先对该点发起询问，那么我们无法得知向该点有出边连接的点的颜色，之后一定需要向上发起另一次询问，这样会有更大的风险。同时，如果当前点是黑点，先询问该点会直接失败，而如果先询问向该点有出边连接的点，我们就会在询问黑点前就得知黑点的标号。综上所述，询问向该点有出边连接的点显然更划算。

因此可以得出一个结论：在新图中，我们只需要对入度为 $0$ 的点发起可能遇到黑点的询问。如果在这些询问中没有遇到黑点，之后的询问就绝对安全了。

我们可以依据这个结论对答案进行猜测：设缩点后新图中入度为 $0$ 的点数量为 $c$，则答案应为 $1-\frac{c}{n}$。

这个答案已经很接近正解了，但并不完全正确，仍然有特殊情况存在。

考虑原图中一个单独的点 $p$。若 $p$ 的入度为 $0$，且 $p$ 可直接到达的所有点入度均$\geq2$（或者 $p$ 没有出边），此时如果我们把 $p$ 置于询问队列的最后，那么在对 $p$ 发起询问之前，与 $p$ 相连的所有点的颜色都已经确定了。如果黑点在这些点当中，我们自然没有必要再对 $p$ 进行询问了。如果最后我们仍没有确定黑点标号，那么 $p$ 是黑点，同样无需对 $p$ 发起询问。

因此，如果图中存在至少一个入度为 $0$ 且 $size=1$ 的强连通分量，答案就会变为 $1-\frac{c-1}{n}$，注意答案只能变化一次。

解题思路到这里就整理完毕了，但代码实现上还有一点小问题：在原图中，一个点可能有多条连接某一其他强连通分量的出边。这样一来缩点过后会出现重边，有可能会导致统计答案的过程中误判一些点的入度而出现错误。

由于之前数据没有特意卡这个点，许多没有对这一问题进行处理的代码也可以通过。现在数据已加强，缩点不去重边的代码无法 AC。现有的另一篇题解使用 map 进行记录以达到防止重复加边的目的，这里提供另一种方法：在新图中加入某个点的出边时，给已经连接过的其他点打上标记，加完该点的所有出边后清除标记。

至此，本题得到完美解决。

-------------------

### 代码

```cpp
#include<cstdio>
#include<map>
int dfn[300086],low[300086],h[300086],hh[300086],inv[300086],col[300086],st[300086],sze[300086];
int n,m,tot,cnt,top,u,v,C,dfncnt;
bool vis[300086],vv[300086];
struct asdf{
	int v,nxt;
}e[600086],ee[600086];
struct asd{
	int u,v;
}E[300086];
int read(){//简单快读
	char ch=getchar();int nn=0,ssss=1;
	while(ch<'0'||ch>'9'){if(ch=='-')ssss*=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){nn=nn*10+(ch-'0');ch=getchar();}
	return nn*ssss;
}
bool add(int u,int v){
	e[++tot].v=v;
	e[tot].nxt=h[u];
	h[u]=tot;
	return true;
}
bool addedge(int u,int v){
	ee[++tot].v=v;
	ee[tot].nxt=hh[u];
	hh[u]=tot;
	inv[v]++;
	return true;
}
bool tarjan(int np){//缩点
	dfn[np]=low[np]=++dfncnt;
	st[++top]=np;vis[np]=true;
	for(int i=h[np];i;i=e[i].nxt){
		if(!dfn[e[i].v]){
			tarjan(e[i].v);
			if(low[e[i].v]<low[np])low[np]=low[e[i].v];
		}
		else
			if(vis[e[i].v]&&dfn[e[i].v]<low[np])low[np]=dfn[e[i].v];
	}
	if(low[np]==dfn[np]){
		C++;
		while(st[top+1]!=np){
			vis[st[top]]=false;
			col[st[top]]=C;
			sze[C]++;
			top--;
		}
	}
	return true;
}
int main(){
	n=read();m=read();
	for(int i=1;i<=m;i++){
		scanf("%d%d",&E[i].u,&E[i].v);
		add(E[i].u,E[i].v);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i])tarjan(i);
	tot=1;
	for(int i=1;i<=n;i++){
		for(int j=h[i];j;j=e[j].nxt){
			if(col[i]==col[e[j].v]||vv[col[e[j].v]])continue;
			addedge(col[i],col[e[j].v]);
			vv[col[e[j].v]]=true;//打标记防止重复加边
		}
		for(int j=h[i];j;j=e[j].nxt)vv[col[e[j].v]]=false;//删除标记
	}
	bool flag=true;
	for(int i=1;i<=C;i++){
		if(!inv[i])cnt++;//统计无入边的点 
		if(inv[i]||sze[i]>1)continue;
		if(flag){
			bool pp=true;
			for(int j=hh[i];j;j=ee[j].nxt)
				if(inv[ee[j].v]<=1){
					pp=false;
					break;
				}
			if(pp)cnt--,flag=false;//如果某个强连通分量size为1且指向的点入度均>1,则该点可以不访问 
		}
	}
	printf("%.6lf",(double)(n-cnt)/n);
}
```

### 碎碎念

欢迎指出错误，蚂蜂略丑求原谅

upd:发现一处笔误，进行了修改

---

## 作者：A_Sunny_Day (赞：26)

## [BZOJ2438] 中山市选2011 杀人游戏 Tarjan

题目链接：[中山市选 杀人游戏](https://www.luogu.com.cn/problem/P4819)

---

​	很明显的图论，根据题意建图，如果 $x$ 认识 $y$，那么连一条由 $x$ 指向 $y$ 的**单向边**。

​	注意到一个性质：如果一个人的身份得知，他所认识的人的身份也都得知。

​	那么在同一个联通分量中的人只要知道**一个人的身份**就好了，我们考虑使用 Tarjan 算法缩点。缩点完之后的图构成 DAG。由于我们的信息具有**传递性**。也就是说，一个人的身份知道了，他认识的人的身份都知道了，同样的，他所认识的人所认识的人的身份也都知道了。所以，在 DAG 中，只要入度为 $0$ 的强连通分量中有一个人的身份知道了，所有人的身份也就都知道了。这样我们就可以抓住凶手。所以我们需要统计入度为 $0$ 的连通分量个数，假设它的值为 $c$。由于随机选一个人，这个人是凶手的概率是 $\dfrac{1}{n}$，选 $c$ 个人（每个连通分量里的人选一个）， 有一个人是凶手的概率就是 $\dfrac{c}{n}$。答案就是 $1-\dfrac{c}{n}$。

​	但是上面我们陷入了一个误区，我们一定要把所有人的身份都查出来才能确定凶手呢。我们是不是忘了一个叫**排除法**的东西。如果我们确定了 $n-1$ 个人的身份，最后那个人的身份是不是也就知道了？所以我们要看看入度为 $0$ 的连通分量中，有没有满足不用查这个连通分量也能得知  $n-1$ 个人的身份这个性质的连通分量。由于入度为 $0$ 的连通分量中人的身份只能靠同一个连通分量的来得知，如果不用查这个联通分量也能得知 $n-1$ 个人，那么这个连通分量的大小只能是 $1$。同时，这个连通分量所连的连通分量必须被其他连通分量相连，即入度不为 $1$。这样即使不调查这个大小为 $1$ 的连通分量，它所连的连通分量的人的身份也可以由其他连通分量推来。那么，如果存在这么一个连通分量，答案就变成了 $1-\dfrac{c-1}{n}$。值得注意的是：如果有两个或者更多这样的连通分量，答案还是 $1-\dfrac{c-1}{n}$。因为我们并不能使用排除法推出超过 $1$ 个未知信息。

​	所以统计答案的代码如下：

```cpp
	int sum=0;
	for(int i=1;i<=num;++i)
		if(!in[i]) sum++;
	for(int i=1;i<=num;++i)
	{
		if(siz[i]!=1||in[i]) continue;
		int p=vec[i][0];bool flag=0;
		for(int j=0;j<e[p].size();++j)
		{
			int to=e[p][j];
			if(in[color[to]]==1)
				flag=1;
		}
		if(!flag)
		{
			sum--;
			break;
		}
	}
	double ans=1.0-1.0*sum/n;
	printf("%.6lf\n",ans);
```

​	但是这题在统计连通分量入度时有个细节，我们知道，一个连通分量可能有好几条边连向同一个连通分量，这会导致连通分量的入度统计偏大，所以我们要使用 map 去重，代码如下：

```cpp
	for(int i=1;i<=n;++i)
		for(int j=0;j<e[i].size();++j)
		{
			if(color[e[i][j]]!=color[i]&&!mp.count(make_pair(color[e[i][j]],color[i])))
			{
				in[color[e[i][j]]]++;
				mp[make_pair(color[e[i][j]],color[i])]=1;
			}
		}
```

​	总时间复杂度就是 $O(n+m\times\log(m))$

全部代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+5;
int n,m,dfn[MAXN],low[MAXN],totdfn,in[MAXN],siz[MAXN],color[MAXN],num,out[MAXN];
bool flag[MAXN];
stack <int> st;
vector <int> e[MAXN],vec[MAXN];
map <pair<int,int>,bool> mp;
void dfs(int p)
{
	dfn[p]=low[p]=++totdfn;st.push(p);
	for(int i=0;i<e[p].size();++i)
	{
		int to=e[p][i];
		if(!dfn[to])
		{
			dfs(to);
			low[p]=min(low[to],low[p]);
		}
		else if(!flag[to]) low[p]=min(low[p],dfn[to]);
	}
	if(low[p]==dfn[p])
	{
		color[p]=++num;
		flag[p]=1;++siz[num];
		vec[num].push_back(p);
		while(st.top()!=p)
		{
			color[st.top()]=num;
			flag[st.top()]=1;
			vec[num].push_back(st.top());
			++siz[num];
			st.pop();
		}
		st.pop();
	}
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;++i)
	{
		int u,v;
		scanf("%d %d",&u,&v);
		e[u].push_back(v);
	}
	for(int i=1;i<=n;++i)
		if(!dfn[i]) dfs(i);
	for(int i=1;i<=n;++i)
		for(int j=0;j<e[i].size();++j)
		{
			if(color[e[i][j]]!=color[i]&&!mp.count(make_pair(color[e[i][j]],color[i])))
			{
				in[color[e[i][j]]]++;
				mp[make_pair(color[e[i][j]],color[i])]=1;
			}
		}
	int sum=0;
	for(int i=1;i<=num;++i)
		if(!in[i]) sum++;
	for(int i=1;i<=num;++i)
	{
		if(siz[i]!=1||in[i]) continue;
		int p=vec[i][0];bool flag=0;
		for(int j=0;j<e[p].size();++j)
		{
			int to=e[p][j];
			if(in[color[to]]==1)
				flag=1;
		}
		if(!flag)
		{
			sum--;
			break;
		}
	}
	double ans=1.0-1.0*sum/n;
	printf("%.6lf\n",ans);
	return 0;
}
```

总结：Tarjan 细节题。



---

## 作者：IronELement (赞：18)

这题看起来是很恶心的概率题。  
不过想清楚其实也没有那么难。  
下面根据一些样例图来讲几种情况。  
![样例图](https://cdn.luogu.com.cn/upload/pic/38378.png)  
这是样例的图。根据题目，每个人是杀手的概率是相同的。在这里是1/5，即0.2。容易发现，如果调查第一个人（最优情况），而且这个人不是杀手，就能知道所有人的信息。而第一个人是杀手的概率为0.2,成功的概率就是1-0.2=0.8。  
![样例图2](https://cdn.luogu.com.cn/upload/pic/38381.png)  
同样的，这里也是从1开始调查。如果1是平民，那么1,2,3,4的情况就全部清楚了。因为1是平民时，可以获知2的情况，如果2是杀手，那么不需要再调查了。如果2是平民，2会提供3的信息,以此类推。  

*换句话说，从甲开始调查所能了解到情况的人，就是从图上甲对应的点出发，可以遍历到的所有点*  
**转化**  
从第二张图我们可以发现，点集(2,3,4)中，只要了解了其中一个点，其他点的情况也清楚了。这就是一个强联通分量。我们可以用Tarjan算法把这样的所有点集缩成一个点，方便后面的处理。关于Tarjan算法，这里就不仔细解说了。可以参照一下蒟蒻写的[另外一篇博客](https://www.luogu.org/blog/IronElement/p3387tarjan-qiang-lian-tong-fen-liang-post)。  
缩点后，上面的第二张图就转化成这样。  
![样例图2缩点后](https://cdn.luogu.com.cn/upload/pic/38382.png)  
这样问题就转化为了求有多少个入度为0的点（缩点后必定有入度为0的点，而从这些点出发，必定最优）。有多少个点，就要调查多少次。生命受到威胁的概率就是
```
(1/n)*num
```  
**但是**  
再看转化后的第二张图。调查1后，1和（2,3,4）的情况都明白了。这时候，杀手如果在1,2,3,4中，不用继续调查了。如果不在1,2,3,4中，那么5必定是杀手，也不用继续调查！这个样例的答案是0.8。  
  
**可以不调查最后一个点的情况**
这里先说明，如果一个点，在缩点前也是一个点，指向的点的入度都大于1，且入度为0，那么这个点在最后可以不调查。下面给出证明：
1.入度为0。只有这样才能最优。  
![样例图3](https://cdn.luogu.com.cn/upload/pic/38384.png)  
例如在这个图中，如果从入度不为0的2开始调查，那么指向2的1必定不能调查到。因此不是最优的。  
  
2.指向的点入度大于1。
![样例图4](https://cdn.luogu.com.cn/upload/pic/38385.png)  
在第二张图缩点后的图的基础上，如果增加一个6指向5。这时1和6都是入度为0。但此时从1开始后，只能弄清楚1和（2,3,4）的情况，5的情况是不清楚的，这时候如果不调查6，不能确定的点有两个。  
  
3.缩点前仍然是一个点
![样例图5缩点后](https://cdn.luogu.com.cn/upload/pic/38388.png) 
缩点后，这个图看起来可以从5调查起，然后5和4的情况都清楚了，剩下一个（1,2,3）。但是，再看看缩点前的图。  
![样例图5缩点前](https://cdn.luogu.com.cn/upload/pic/38389.png)  
其实还剩下3个点，还需要从其中一个再调查一次。   
4.此外补充一点，如果一个点是出度为0，入度也为0，那么这个点如果放在最后，也可也不调查。
  
**注意**
这里重构图的时候，一定要去重边，否则会对出度和入度的判断造成影响。  
这里感谢一下某大佬教蒟蒻用map去重边。  
  
**丑代码和注释**  
```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
#include <cctype>
#include <algorithm>
#include <vector>
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <cstdlib>
#include <ctime>

using namespace std;

int n,m,i,j,k,l,dfn[100010],low[100010],scc[100010],ti,sc,pnum[100010],ind[100010],need,outd[100010];
bool p;
double per;

vector<int>to[100010];
vector<int>newto[100010];
stack<int>s;
map<int,int>edge[100010];

void Tarjan(int now)
{
	int i,j;
	dfn[now]=++ti;
	low[now]=dfn[now];
	s.push(now);
	for(i=0;i<to[now].size();i++)
	{
		int next=to[now][i];
		if(dfn[next]==-1)
		{
			Tarjan(next);
			low[now]=min(low[now],low[next]);
		}
		else
		if(scc[next]==-1)
		{
			low[now]=min(low[now],dfn[next]);
		}
	}
	if(dfn[now]==low[now])
	{
		int snow;
		sc++;
		while(true)
		{
			snow=s.top();
			s.pop();
			scc[snow]=sc;
			if(snow==now)break;
		}
	}
}

void Reconstruction()
{
	int i,j;
	for(i=1;i<=n;i++)
	{
		for(j=0;j<to[i].size();j++)
		if(scc[i]!=scc[to[i][j]]&&!edge[scc[i]][scc[to[i][j]]])//判自环和map判重边
		{
			newto[scc[i]].push_back(scc[to[i][j]]);
			edge[scc[i]][scc[to[i][j]]]=1;
			ind[scc[to[i][j]]]++;
			outd[scc[i]]++;
		}
		pnum[scc[i]]++;
	}
}

int main()
{
	freopen("kill.in","r",stdin);
	freopen("kill.out","w",stdout); 
	scanf("%d%d",&n,&m);
	for(i=1;i<=m;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		to[u].push_back(v);
	}
	for(i=1;i<=n;i++){dfn[i]=-1;scc[i]=-1;}
	for(i=1;i<=n;i++)
	{
		if(dfn[i]==-1)
		{
			Tarjan(i);
		}
	}
	Reconstruction();//重构图
	p=0;
	for(i=1;i<=sc;i++)
	{
		if(ind[i]==0)
		{
			need++;//需要调查的人加一
			if(pnum[i]==1)//如果缩点前是1个点
			{
				if(outd[i]==0)p=1;//入度为0出度为0，特判
				else
				{
					bool p2=1;
					for(j=0;j<newto[i].size();j++)
					{
						int next=newto[i][j];
						if(ind[newto[i][j]]<=1)
						{
							p2=0;
							break;
						}
					}
                    //检查是否所有指向的点的入度都大于1
					if(p2)p=1;
				}
			}
		}
	}
	if(p)need--;//最后一个不查
	per=1.0/(n*1.0);;
	printf("%.6lf",1-per*need);
	return 0;
}
```  
  
**蒟蒻写文，如有不当，请不留情面地打脸！**

---

## 作者：Erinyes (赞：10)

upd（2022/2/9）：经提醒，发现了一处代码错误，并进行了修改
## Part 1 ：题目分析
本题让我们求的是警察查证到杀手的最大概率。

假设他的查证对象一共有 $n$ 个，因为每一个人是杀手概率是相同的，所以警察每查证一个人，他查证到杀手的概率就会减去 $\dfrac{1}{n}$，如果不考虑人互相认识的话，总概率就是 $0$。

根据题意，有一些人认识其他人，所以只要警察查证一个人，则他认识的人就都不用查证了。

由于在本题中有环的存在，就是在一个集合中，所有人都互相认识，那么警察只需要查证其中的一个人，这整个集合中的所有人都会被查证。

由此我们便可以采用 Tarjan 算法来进行找环及缩点操作。

## Part 2 ：题目求解
Tarjan 缩点的部分不用多说，与正常的缩点没有什么区别。

只是在找到一个环 (```dfn[x]==low[x]```) 时，要将环上的所有点都染上色，并且用一个 ```sum``` 数组来储存这个强连通分量中点的个数。

也就是

```cpp
c[y]=cnt; sum[cnt]++; //cnt就是这个强连通分量的编号
```
所以整个 Tarjan 函数就写出来了。

```cpp
void tarjan(int x){
	dfn[x]=low[x]=++num;
	s.push(x); in[x]=1;
	for(int i=h[x];i;i=t[i].next){
		int y=t[i].to;
		if(!dfn[y]){
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}else if(in[y]) low[x]=min(low[x],dfn[y]);
	}
	if(dfn[x]==low[x]){
		cnt++;
		int y;
		do{
			y=s.top(); s.pop(); in[y]=0;
			c[y]=cnt; sum[cnt]++;
		}while(x!=y);
	}
}
```
当缩完点后，我们就可以将新图建出来了。
```cpp
//感谢@lsroi的提醒，这里vst里面不能直接写t[i].to
void clear(int x){for(int i=h[x];i;i=t[i].next) vst[c[t[i].to]]=0;}
//下面这段代码在main函数中
for(int x=1;x<=n;x++){ //枚举每一个点
	for(int i=h[x];i;i=t[i].next){ //枚举每条出边
		int y=t[i].to;
		if(c[x]==c[y] or vst[c[y]]) continue; //如果相连的两个点在同一个强连通分量中，或者x所在的强连通分量与y所在的强连通分量已经建过边，则需要忽略这条边
		vst[c[y]]=1; //将y所在的强连通分量标记为已建过边
		addc(c[x],c[y]); //建边
		rd[c[y]]++; //统计每个强连通分量的入度
	}
	clear(x); //清空vst数组
}
```
这里用一个 ```vst``` 数组记录当前的 $x$ 是否已经与 $y$ 所在的强连通分量建过边，如果已经有边，就直接忽略，起到了去掉重边的作用。

接下来就是累加所有不被其他人认识的人了。

例如下面这种情况

![](https://cdn.luogu.com.cn/upload/image_hosting/7i8azmxc.png)

它缩完点后就可以变成

![](https://cdn.luogu.com.cn/upload/image_hosting/obugrl1z.png)

相当于 $1,2,3$，$4$，$5,6,7$，分别组成三个强连通分量。

那么我们只需要在 $1,2,3$ 这个强连通分量中随便找一个人进行查证就可以知道所有人的身份。

又因为选择一个人进行查证的概率是 $\dfrac{1}{n}$，所以最终的答案就是 $\dfrac{1}{n}$，也就是 $0.142857$。

不难发现，刚才那组数据中，我们统计的是入度为 $0$ 的强连通分量的个数，因为这些强连通分量中的人都没有除这个强连通分量以外的人认识，所以肯定需要警察找一个人进行查证。

但是，这样一来，就存在了一个问题，如果我们把其他所有人都查证完了，那么剩下的一个人就必定是杀手。

例如下面这个缩完点的图

![](https://cdn.luogu.com.cn/upload/image_hosting/58t1b1b4.png)

这个图中入度为 $0$ 的强连通分量有两个，但是经过检验可以发现，只要警察在 $1,2,3$ 中查证一个人，那么 $1,2,3,4,5,8,6,9,10$ 这些人的身份就全部知道了，那么最后一个点 $7$ 就没有必要查证了。

当然，这种情况只出现在最后一个强连通分量中只有一个点时。

由此，我们就可以增加一个判断条件。

当某一个强连通分量的入度为 $0$，只有一个人，并且他认识的所有人都有其他人认识时，这个人就不需要查证了。

```cpp
bool check(int x) {
	if (rd[x] or sum[x]!=1) return false; //入度为0并且只有一个点才继续判断
	for(int i=hc[x];i;i=tc[i].next) if(rd[tc[i].to]==1) return false; //必须要有其他人认识
	return true;
}
```
这样，我们就统计除了需要查证的人的个数。
```cpp
int ans=0;
for(int i=1;i<=cnt;i++) if(!rd[i]) ans++; //统计入度为0的强连通分量的个数
for(int i=1;i<=cnt;i++){
	if(check(i)){ //符合条件
		ans--;
		break; //这种情况只存在一次，所以如果找到了，就需要break
	}
}
```
最后的概率便是总点数减去需要查证的人的个数的差除以总点数的值。就是 $(n-ans)\div n$。
## Part 3 ：Code

```cpp
#include<bits/stdc++.h>
#define maxn 300005
using namespace std;
struct node{int to,next;};
node t[maxn*2],tc[maxn*2];
int n,m;
int tot,totc,num,cnt;
int h[maxn],hc[maxn],dfn[maxn],low[maxn],in[maxn],c[maxn],sum[maxn],vst[maxn],f[maxn],rd[maxn];
stack<int> s;
inline int read(){ //读入优化
	register int x=0;
	register char c=getchar();
	while(c<'0' or c>'9') c=getchar();
	while(c>='0' and c<='9') x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x;
}
inline void add(int x,int y){
	t[++tot].to=y;
	t[tot].next=h[x];
	h[x]=tot;
}
inline void addc(int x,int y){ //建新图
	tc[++totc].to=y;
	tc[totc].next=hc[x];
	hc[x]=totc;
}
void tarjan(int x){
	dfn[x]=low[x]=++num;
	s.push(x); in[x]=1;
	for(int i=h[x];i;i=t[i].next){
		int y=t[i].to;
		if(!dfn[y]){
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}else if(in[y]) low[x]=min(low[x],dfn[y]);
	}
	if(dfn[x]==low[x]){
		cnt++;
		int y;
		do{
			y=s.top(); s.pop(); in[y]=0;
			c[y]=cnt; sum[cnt]++; //cnt就是这个强连通分量的编号
		}while(x!=y);
	}
}
//感谢@lsroi的提醒，这里vst里面不能直接写t[i].to
void clear(int x){for(int i=h[x];i;i=t[i].next) vst[c[t[i].to]]=0;}
bool check(int x){
	if (rd[x] or sum[x]!=1) return false; //入度为0并且只有一个点才继续判断
	for(int i=hc[x];i;i=tc[i].next) if(rd[tc[i].to]==1) return false; //必须要有其他人认识
	return true;
}
int main(){
	int x,y;
	n=read(); m=read();
	for(int i=1;i<=m;i++){
		x=read(); y=read();
		add(x,y);
	}
	for(int i=1;i<=n;i++) if(!dfn[i]) tarjan(i);
	for(int x=1;x<=n;x++){ //枚举每一个点
		for(int i=h[x];i;i=t[i].next){ //枚举每条出边
			int y=t[i].to;
			if(c[x]==c[y] or vst[c[y]]) continue; //如果相连的两个点在同一个强连通分量中，或者x所在的强连通分量与y所在的强连通分量已经建过边，则需要忽略这条边
			vst[c[y]]=1; //将y所在的强连通分量标记为已建过边
			addc(c[x],c[y]); //建边
			rd[c[y]]++; //统计每个强连通分量的入度
		}
		clear(x); //清空vst数组
	}
	int ans=0;
	for(int i=1;i<=cnt;i++) if(!rd[i]) ans++; //统计入度为0的强连通分量的个数
	for(int i=1;i<=cnt;i++){
		if(check(i)){ //符合条件
			ans--;
			break; //这种情况只存在一次，所以如果找到了，就需要break
		}
	}
	printf("%.6lf",double(double(n-ans)/double(n))); //将int转为double，保留小数
	return 0;
}
```


---

## 作者：Larry76 (赞：8)

## 前言：

看到目前的题解当中没有并查集做法，于是写一篇水水。

## 题目描述：

给定一张图，一个图中有黑白两种颜色，已知黑色的点有且只有一个，且每个点是黑色的概率相等，然后点 $u$ 与点 $v$ 之间的边表示 $u$ 知道 $v$ 是什么颜色，我们的目的是找到黑点。

问在达成目的并且看点颜色次数最少的情况下，看的点的颜色不是黑色的概率为多少。

## 题意分析：

首先，根据给出的题意，不难得出这样的结论：

>
> 如果当前在一个环上，则我们可以从环上任意一个点出发，若该点不是黑色，则可以在不看到黑色的情况下知道整个环的点的颜色。
>

根据此条性质，我们可以对原图进行缩点。

然后，考虑维护一个并查集，对缩点后得到的新图的每个点进行遍历，看看当前点 $u$ 能访问到那些点 $v$，然后按照如下规则进行两个 $u$、$v$ 点的信息合并：

1. 若点 $v$ 没有被合并，则将 $v$ 合并到 $u$ 所在的集合中。
2. 若点 $u$ 被合并了，则不进行合并。

最后，我们统计**集合大小为 $\boldsymbol{1}$ 的集合的个数 $\boldsymbol{a}$ **和**集合大小大于 $\boldsymbol{1}$ 的集合的个数 $\boldsymbol{b}$**。

此时，需要看的点的个数 $k$ 如下：

1. 若 $a=0$，则 $k = b$。
2. 否则，若 $a>1$，则 $k = a + b - 1$。
3. 否则，若 $n=1$，则 $k = 0$。

最后，我们的答案就是 $\dfrac kn$（请别忘了保留 $6$ 位小数）。

**注意**：

1. 本题使用 `long double` 会炸掉精度，请使用 `double` 计算答案。
2. 本题请务必要特判 $n=1$ 的情况，因为当 $n=1$ 的时候，那个点必定是黑点，不需要去看。

综上，时间复杂度 $O(n \lg n)$

## 代码实现：
```cpp
#include <bits/stdc++.h>
#define debug(x) cerr << #x << ": " << x << endl;
#define int long long
using namespace std;
const int N = 3e5 + 9;
#define MAX_SIZE (int)1.1e5
struct node
{
    int to, next;
};
node edge[N];
int n, m, u, v, tot, cnt, sum, top, res, flag, cnt1;
int head[MAX_SIZE];
int dfn[MAX_SIZE];
int low[MAX_SIZE];
int sta[MAX_SIZE];
int col[MAX_SIZE];
int ind[MAX_SIZE];
int siz[MAX_SIZE];
bool vis[MAX_SIZE];

void add(int u, int v)
{
    edge[++tot].to = v;
    edge[tot].next = head[u];
    head[u] = tot;
}

void tarjan(int u)
{
    dfn[u] = low[u] = ++cnt;
    vis[u] = 1, sta[++top] = u;
    for (int i = head[u]; i; i = edge[i].next)
    {
        int v = edge[i].to;
        if (!dfn[v])
        {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (vis[v])
        {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u])
    {
        col[u] = ++sum;
        vis[u] = 0;
        siz[sum] = 1;
        while (sta[top] != u)
        {
            col[sta[top]] = sum;
            vis[sta[top]] = 0;
            --top;
            siz[sum]++;
        }
        --top;
    }
    return;
}

int head2[MAX_SIZE];
int Next[MAX_SIZE];
int ver[MAX_SIZE];
int tot2 = 0;

void Add(int u, int v)
{
    ver[++tot2] = v;
    Next[tot2] = head2[u];
    head2[u] = tot2;
}

int fa[MAX_SIZE];
int fasiz[MAX_SIZE];

void init(int size)
{
    for (int i = 1; i <= size; i++)
    {
        fa[i] = i;
        fasiz[i] = 1;
    }
}


int getfa(int x)
{
    if (x == fa[x])
        return fa[x];
    return fa[x] = getfa(x);
}

void merge(int u, int v)
{
    int x = getfa(u);
    int y = getfa(v);
    fa[y] = x;
    fasiz[x] += fasiz[y];
}

signed main()
{
    ios::sync_with_stdio(false);
#ifdef LOCAL
    freopen("in.in", "r", stdin);
    freopen("out.out", "w", stdout);
    double c1 = clock();
#endif
    //============================================
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        cin >> u >> v;
        add(u, v);
    }

    for (int i = 1; i <= n; i++)
        if (!dfn[i])
            tarjan(i);

    for (int u = 1; u <= n; u++)
    {
        for (int i = head[u]; i; i = edge[i].next)
        {
            int v = edge[i].to;
            if (col[u] != col[v])
            {
                Add(col[u], col[v]);
                ++ind[col[v]];
            }
        }
    }

    init(sum);
    for (int u = 1; u <= sum; u++)
    {
        for (int i = head2[u]; i; i = Next[i])
        {
            int v = ver[i];
            if (fa[v] != v)
                continue;
            merge(u, v);
        }
    }
    int lookup = 0;
    int lonely = 0;
    for (int i = 1; i <= sum; i++)
    {
        if (fa[i] == i)
        {
            if (fasiz[i] > 1)
                ++lookup;
            else
                ++lonely;
        }
    }

    if (lonely)
    {
        if (lonely > 1)
            --lonely;
        else if (lookup)
            --lonely;
        else if (n == 1)
            lonely = 0;
    }
    printf("%.6lf\n", (double)(n - lookup - lonely) / (double)(n));
    //============================================
#ifdef LOCAL
    double c2 = clock();
    cerr << "Used Time: " << c2 - c1 << "ms" << endl;
    if (c2 - c1 > 1000)
        cerr << "Warning!! Time Limit Exceeded!!" << endl;
    fclose(stdin);
    fclose(stdout);
#endif
    return 0;
}
```

---

## 作者：只鹅烧烤二度 (赞：7)

题目链接：[[中山市选]杀人游戏](https://www.luogu.com.cn/problem/P4819)

---

​	本题的初始问题可以理解为：选择若干个点从而使得以选择点为起点，保证得知随机分布的特殊点位置的前提下，使得不选择特殊点的概率最大。

​	对于任意的选择方案，假设选择 $c$ 个点，那么在n点中选择到该特殊点的概率即为 $\dfrac{c}{n} $，因此成功获取身份，即不选择特殊点的概率为 $ 1-\dfrac{c}{n} $ 因此，问题转化为了最小化选择的点数 $c$ 

在原图上直接进行求解相对较为困难，此时便可考虑缩点。

​	先讨论缩点的正确性，在任意一个强联通分量中，假设一个点已知身份，那么等同于强联通分量中其余点均知道身份，同时在强联通分量中任意选择一个点，是特殊点的概率也是等同的，因此强联通分量在目前转化的问题当中，可以理解成一个点。

​	问题进一步转化为在 DAG 上取任意的点数量使得所有点被确定，在此有一个注意点：使得所有点被确定并不等同与通过连通关系覆盖所有的点，假设在未缩点原图当中有且只有一个点未被覆盖，那么此点的身份是可确定的。

​	拓展到缩点后的 DAG 上，问题再次转化为最小化 DAG 选择的点，使得至多只有一个 $\text{size}=1$ 的点不被确定。

​	对于单独的限制情况比较难讨论，因此先讨论对于覆盖所有点的情况下，对于所有入度为 $0$ 的点是必定要选择的，而入度不为 $0$ 的点必然可以通过入度为 $0$ 的点传导，因此答案为入度为 $0$ 的点的个数。

​	而加上限制后若要少取点，则也是尽量要少取入度为 $0$ 的点，对于任意的入度为 $0$ 且 $\text{size}=1$ 的点，需要满足不选此点对于别的点的选取没有影响，即此点所连出的边至少还可以通过另一条边传导过来，即对于该点，任意的 $ in_{to}\ge2$，该图便可以满足少选一个点的条件。

​	关于本题的细节处理，在缩点后的连边，对于重边的连接可能会影响入度的计算，因此代码采用了 map 存已经出现过的边。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int dfn[N],low[N],s[N],in[N],out[N],siz[N],color[N],n,m,r,cnt,col;
bool flag[N];vector<int> g[N],e[N];map<pair<int,int>,bool> mp;

void tarjan(int p)//缩点模板，同时维护了缩点后代表的强联通分量点数目 
{
	dfn[p]=low[p]=++cnt;
	flag[p]=true;s[++r]=p;
	for(int i=0;i<g[p].size();i++)
	{
		int to=g[p][i];
		if(!dfn[to])
		{
			tarjan(to);
			low[p]=min(low[p],low[to]);
		}
		else
			if(flag[to])
				low[p]=min(low[p],dfn[to]);
	}
	if(dfn[p]==low[p])
	{
		col++;
		while(r&&s[r+1]!=p)
		{
			color[s[r]]=col;siz[col]++;
			flag[s[r--]]=false;
		}
	}
}

int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1,u,v;i<=m;i++)
	{
		scanf("%d %d",&u,&v);
		g[u].push_back(v);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i])
			tarjan(i);
	for(int i=1;i<=n;i++)//连边+去重边 
		for(int j=0;j<g[i].size();j++)
			if(color[i]!=color[g[i][j]])
				if(mp.find(make_pair(color[i],color[g[i][j]]))==mp.end())
				{
					in[color[g[i][j]]]++;
					e[color[i]].push_back(color[g[i][j]]);
					mp[make_pair(color[i],color[g[i][j]])]=true;
				}
	bool flag=false;int sum=0;
	for(int i=1;i<=col;i++)
	{
		if(!in[i])//统计入度为0的初始选择点 
			sum++;
		if(!in[i]&&siz[i]==1)//统计是否可以少选一个点
		{
			bool tmp=true;
			for(int j=0;j<e[i].size();j++)
				tmp&=(in[e[i][j]]>=2);
			flag|=tmp;
		}
	}
	if(flag)
		printf("%.6lf",1.0*(n-sum+1)/n);
	else
		printf("%.6lf",1.0*(n-sum)/n);
}
```



---

## 作者：eastcloud (赞：5)

### 题意简述

给出一个有向图，表示每个人的认识关系，所有人中有一个杀手，询问正常人时他会说出自己认识的人的身份，询问杀手则会被杀死，问活下来并知道杀手的最大概率是多少。

### 题目分析

在此题中，由于每个人是杀手的概率均等，假设抽查了 $ p $ 个人，活下来的概率则为 $ 1 - \frac{p}{n} $，若要让该概率最大，我们可以转化为求最小的 $ p $。

由于每个人的认识关系为一张无向图，因此只要对一个人发出询问，就能知道他所连边的人的身份，进而推出他能到达的人的身份，因此我们可以想到一个贪心策略：不选有入度点，否则选取能到达他的点一定更优。

但图中可能有环的存在，加上图不连通，就可能出现必须选一个有入度点的情况，于是我们考虑对图进行操作，注意到如果两点在一个强连通分量中，那么选取这两个点是等效的，因此我们可以将图缩点，进而统计无入度点的个数，因为此处将环也缩成了一个节点，因此不会有上述情况且更方便操作。

但我们还需要注意一种特殊情况，当一个强连通分量的大小为 1 且能直接到达的点都起码有两个入度时，这个点不用选，因为其他点检查过后只剩他一个没有检查，可以直接推测出这个点的身份，但是因为我们使用了推测法，这样的点只能存在一个。

总上，我们建图后求 scc，统计无入度点和特殊情况即可。

### 代码

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
#include<map>
using namespace std;
map<pair<int,int> ,int > t;
struct Node{
	int u,v;
}edg[300001];
vector<int> l[300001];
vector<int> tr[300001];
int dfn[300001],low[300001];
int c[300001],q[300001],ins[300001];
int in[300001],ou[300001];
int siz[300001];
int tail,tot,cnt;
void tarjan(int x){
	dfn[x]=low[x]=++tot;
	q[++tail]=x;
	ins[x]=1;
	for(int i=0;i<l[x].size();i++){
		int v=l[x][i];
		if(!dfn[v]){
			tarjan(v);
			low[x]=min(low[x],low[v]);
		}
		else if(ins[v])low[x]=min(low[x],dfn[v]);
	}
	if(low[x]==dfn[x]){
		int y;
		cnt++;
		do{
			y=q[tail--];
			c[y]=cnt;
			ins[y]--;
			siz[cnt]++;
		}while(y!=x);
	}
}
int main(){
	int n,m,x,y;
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>x>>y;
		l[x].push_back(y);
		edg[i].u=x;edg[i].v=y;
	}
	for(int i=1;i<=n;i++) if(!dfn[i])tarjan(i);
	for(int i=1;i<=m;i++){
		if(c[edg[i].u]==c[edg[i].v])continue;
		pair<int,int> tmp;
		tmp.first=c[edg[i].u];tmp.second=c[edg[i].v];
		if(t[tmp])continue;
		else t[tmp]=1;
		in[c[edg[i].v]]++;
		ou[c[edg[i].u]]++;
		tr[c[edg[i].u]].push_back(c[edg[i].v]);
	}
	int ans=0;
	for(int i=1;i<=cnt;i++) if(in[i]==0) ans++;
	for(int i=1;i<=cnt;i++){
		if(in[i] || siz[i]>1) continue;
		int flag=0;
		for(int j=0;j<tr[i].size();j++){
			if(in[tr[i][j]]<2){
				flag=1;
				break;
			}
		}
		if (!flag){
			ans--;
			break;
		}
	}
	double p=(double)(n-ans)*1.0/n;
	printf("%.6lf",p);
}
```


---

## 作者：qczrz6v4nhp6u (赞：2)

挺好的一道图论题。上 whk 摸鱼然后就干出了正解。

## 题意

给定一张有 $n$ 个点 $m$ 条边的有向图，每个点成为特殊点的概率相等。一次「拓展」操作为选定一个点，得知该点及其出点是否为特殊点。求不选定特殊点进行「拓展」而得知该点为特殊点的概率。

## Solution

考虑满足条件的情况：
- 它有至少一个入点被选定「拓展」。
- 其它 $m-1$ 个点已经「拓展」完毕，该点一定是特殊点。

假定只有第一种情况：

1. 先考虑 DAG。

	显然选定零入度点就可以遍历全图，除零入度点以外所有点一定会有入点被「拓展」，此时答案为 $\dfrac{n-v}{n}$（$v$ 为零入度点个数）。

2. 再考虑一般有向图：

	对于每一个强连通分量，若有一个点被「拓展」，则整个强连通分量也一定被「拓展」，分量内的其他点对答案没有贡献。  
	考虑缩点。缩点后即可按 DAG 的情况考虑。

接下来是第二种情况：

显然只有零入度点需要考虑。

如果其他点已经被「拓展」完毕，那么当前点的所有出点均会被其他点「拓展」。换句话说，就是所有入点都被其他点相连，**所有出点入度大于1**。按照条件判断即可。

### 细节

- 缩点时注意不要建重边。
- 满足第二种情况的点**至多有1个**。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
const int M=3e5+5;
int n,m;
struct egde{int x,y,pre;}a[M*2];int alen,last[N];
void ins(int x,int y){a[++alen]={x,y,last[x]};last[x]=alen;}
int deg[N];
int dfn[N],low[N];
int id,cnt;
int c[N],siz[N];
int s[N],top;
map<int,map<int,bool>>h;
bool v[N];
void dfs(int x){
	dfn[x]=low[x]=++id;
	s[++top]=x,v[x]=1;
	for(int k=last[x];k;k=a[k].pre){
		int y=a[k].y;
		if(!dfn[y]){
			dfs(y);
			low[x]=min(low[x],low[y]);
		}
		else if(v[y])
			low[x]=min(low[x],dfn[y]);
	}
	if(low[x]==dfn[x]){
		int y;cnt++;
		do{
			y=s[top--];
			v[y]=0,c[y]=cnt,siz[cnt]++;
		}while(y!=x);
	}
}
void Tarjan(){
	for(int i=1;i<=n;i++)if(!dfn[i])dfs(i);
	int temp=alen;
	alen=0;memset(last,0,sizeof last);
	for(int i=1;i<=temp;i++){
		int x=a[i].x,y=a[i].y;
		if(c[x]!=c[y]&&!h[c[x]][c[y]]){
			ins(c[x],c[y]);
			h[c[x]][c[y]]=h[c[y]][c[x]]=1;
			deg[c[y]]++;
		}
	}
}
bool check(int x){//检查是否满足第二种情况
	if(deg[x]||siz[x]>1)return 0;
	for(int k=last[x];k;k=a[k].pre){
		int y=a[k].y;
		if(deg[y]==1)return 0;
	}
	return 1;//所有点入度大于1
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		ins(x,y);
	}
	Tarjan();
	int tot=0;
	for(int i=1;i<=cnt;i++)
		tot+=!deg[i]; 
	for(int i=1;i<=cnt;i++)
		if(check(i)){
			tot--;
			break; 
		}
	printf("%.6lf",1.*(n-tot)/n);
}

```

---

## 作者：Hadtsti (赞：1)

### 题意简述

$n$ 个居民中有一名杀手，有些居民知道其他一些人的身份是杀手还是平民，该类条件共 $m$ 条。现在警方要询问一些居民来获得其他人的信息，要求在能够从已知条件推断出杀手是谁的前提下询问尽可能少的人。然而每个居民是杀手的概率都是 $\frac{1}{n}$，因此警方询问的居民中可能就有杀手，从而被杀。求询问最少人的情况下警察生还的几率。

### 题目分析

很明显，题目的条件可以构成一个 $n$ 个顶点、$m$ 条边的有向图 $G=(V,E)$。因此问题转换为：在该有向图中找到最少的点，使得从这些点出发可以到达所有 $n$ 个点**或者其中的 $n-1$ 个点**。而之所以到达其中的 $n-1$ 个点就满足题意，是因为**当“知道” $n-1$ 个点的“身份”时，杀手只可能是剩下的一个点或者在这 $n-1$ 个点其中**。因此设答案取的点的点集为 $V'\subseteq V$，假设 $G$ 是一个 DAG，则满足：令 $A=\{j\in V |\exists i \in V',(i,j) \in E\}, |A|=n-1$ 或 $n$

显然，为了满足最优性，点集 $V'$ 中的所有点的入度为 0（请自行思考原因）。不过，因为 $G$ 不一定是一个 DAG，所以我们可以对其进行 **tarjan 强连通分量缩点**，这里将其作为基础知识不再赘述，如果不了解其过程及原理请查阅相关资料：[【洛谷日报第 27 期】初探tarjan算法（求强连通分量）](https://www.luogu.com.cn/blog/styx-ferryman/chu-tan-tarjan-suan-fa-qiu-qiang-lian-tong-fen-liang-post)。

我们再来讨论一下 $V'$ 的求法。如果存在 1 个点满足入度为 0 并且该点连向的所有点的入度都大于 1（也就是从其他入度为 0 的点出发可以到达），那么就说明可以不将这个“无用”的点放入 $V'$ 。注意，该类点如果有多个则只能去除一个，其他的点仍需要放入 $V'$ 。综上，原题的答案就是 $\frac{|V'|}{n}$，时间复杂度为 $O(n+m)$。
### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=100010,MAXM=300010;
int m,n,a,b,ans;
int nt[MAXM],hd[MAXN],v[MAXM],tot;
int nt2[MAXM],hd2[MAXN],v2[MAXM],tot2,ru[MAXN];
int dfn[MAXN],low[MAXN],C[MAXN],cnt,num,stk[MAXN],top,sz[MAXN];
bool ins[MAXN];
void add(int x,int y)
{
  v[++tot]=y;
  nt[tot]=hd[x];
  hd[x]=tot;
}
void add2(int x,int y)
{
  v2[++tot2]=y;
  nt2[tot2]=hd2[x];
  hd2[x]=tot2;
  ru[y]++;
}//建新图 
inline void tarjan(int x)//tarjan 求强连通分量 
{
  dfn[x]=low[x]=++cnt;
  stk[++top]=x;
  ins[x]=1;
  for(int i=hd[x]; i; i=nt[i])
  {
    int y=v[i];
    if(!dfn[y])
    {
      tarjan(y);
      low[x]=min(low[x],low[y]);
    }
    else if(ins[y])
      low[x]=min(low[x],dfn[y]);
  }
  if(low[x]==dfn[x])
  {
    int y;
    num++;
    do
    {
      y=stk[top--];
      ins[y]=0;
      C[y]=num;
      sz[num]++;
    }
    while(x!=y);
  }
}
bool pd(int x)//判断该点是否满足入度为 0 并且连向的所有点的入度都大于1 
{
  if(!ru[x]&&sz[x]==1)
    for(int i=hd2[x]; i; i=nt2[i])
    {
      int y=v2[i];
      if(ru[y]==1)
        return 0;
    }
  return !ru[x]&&sz[x]==1;
} 
int main()
{
  scanf("%d%d",&n,&m);
  for(int i=1; i<=m; i++)
  {
    scanf("%d%d",&a,&b);
    add(a,b);
  }
  for(int i=1; i<=n; i++)
    if(!dfn[i])
      tarjan(i);
  memset(ins,0,sizeof ins);
  for(int x=1; x<=n; x++)//缩点 
  {
    for(int i=hd[x]; i; i=nt[i])
    {
      int y=v[i];
      if(C[x]!=C[y]&&!ins[C[y]])
      {
        ins[C[y]]=1;
        add2(C[x],C[y]);
      }
    }
    for(int i=hd[x]; i; i=nt[i])
    {
      int y=v[i];
      ins[C[y]]=0;
    }//注意该题缩点不能有重边 
  }
  for(int i=1; i<=num; i++)
    if(!ru[i])
      ans++;//初始答案点集就是缩点后入度为 0 的点。 
  for(int i=1; i<=num; i++)
    if(pd(i))
    {
      ans--;
      break;
    }//去掉“无用点”。 
  printf("%.6lf",(double)(n-ans)/n);
  return 0;
}
```
~~本文应该讲得挺清楚了，管理大大就给过了吧~~

---


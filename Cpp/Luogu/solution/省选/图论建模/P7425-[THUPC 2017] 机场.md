# [THUPC 2017] 机场

## 题目描述

飞机场有 $a+b$ 个停机位，其中 $a$ 个停机位有登机桥连接飞机和候机厅，乘客可以通过登机桥直接由候机厅登上飞机；另外 $b$ 个停机位没有登机桥和候机厅相连，所以乘客登机需要先搭乘摆渡车再登机。

毫无疑问，搭乘摆渡车的体验是非常差的，所以每位搭乘摆渡车的乘客都会产生不愉快度。

现在，给定每架飞机的乘客数量，登机时间和起飞时间；飞机需要在登机时间点选择一个空闲的停机位，在这个时间点内所有乘客会完成登机，然后飞机会一直停在该停机位，直到起飞时间；

若某飞机在时刻 $x$ 起飞，则在时刻 $x$ 该飞机所在的停机位是空闲的。

飞机场的管理层希望能够尽量减少乘客的不愉快度，为此飞机在登机时间到起飞时间之间，可以切换停机位；

假设某飞机从 $x$ 时间开始由停机位 A 切换到停机位 B，那么停机位 A 在 $x+1$ 时间是空闲的。能进行这样的切换当且仅当停机位 B 在 $x+1$ 时间是空闲的。

## 说明/提示

题目中貌似没有给出明确的不愉快度的计算方法，据样例解释推测是不愉快度=所有乘坐摆渡车的人数$+p\times$ 每次切换停机位的飞机上的人数向下取整。
#### 数据范围
$1\le T\le 8,1\le n\le 200,0\le p\le1,1\le x\le 10^5,1\le s\le t\le10^9$
#### 样例解释
飞机从 $1$ 开始编号

在时刻 $1$，$1$ 号飞机安排到登机桥 A，乘客开始登机；目前 $1$ 号飞机在登机桥 A。

在时刻 $2$，$2$ 号飞机安排到登机桥 B，乘客开始登机；目前 $1$ 号飞机在登机桥 A，$2$ 号飞机在登机桥 B。

在时刻 $3$，$2$ 号飞机切换到摆渡车 A，此时登机桥 B 尚不可用。

在时刻 $4$，$1$ 号飞机起飞，$2$ 号飞机到达摆渡车 A， 号飞机安排到登机桥 A，$3$ 号飞机安排到登机桥 B，$4$ 号和 $3$ 号的乘客开始登机，登机完成之后 $4$ 号飞机切换到摆渡车 B，此时登机桥 A 和登机桥 B 都不空闲。

在时刻 $5$，$3$ 号飞机到达摆渡车 B，登机桥 A 变为可用，$5$ 号飞机安排到登机桥 A，开始登机；目前 $5$ 号——登机桥 A，$4$ 号——登机桥 B，$3$ 号——摆渡车 B，$2$ 号——摆渡车 A。

在时刻 $7$，$2$ 号飞机起飞，$6$ 号飞机安排到摆渡车 A。

不愉快度为 $7=1$（$6$ 号飞机乘客乘摆渡车）$+4\times 0.5$（$2$ 号飞机切换停机位）$+8\times 0.5$（$3$ 号飞机切换停机位）
#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。

## 样例 #1

### 输入

```
2
3 1 1
0.5
1 1 5
1 1 5
1 1 5
6 2 2
0.5
4 1 4
4 2 7
8 4 8
8 4 8
10 5 9
1 7 9```

### 输出

```
impossible
7```

# 题解

## 作者：绝顶我为峰 (赞：9)

看到数据范围这么小，那么应该是个立方左右的算法。

但是我们具体不知道是什么算法，我们先来发掘一些性质：

- 在登机桥之间或摆渡车之间瞎动是没意义的，这显然。

- 不会有在摆渡车的飞机移动到登机桥，这也显然。

- 如果一个飞机从登机桥移动到摆渡车，那么一定是在登记后下一个时刻马上过去，否则会白白占用登机桥的位置。

有了这三条之后我们发现飞机可选的状态只剩下了三种：

- 一直在摆渡车。

- 一直在登机桥。

- 在登机桥登机之后下一时刻去摆渡车。

这看起来就非常费用流，我们考虑建图。

（以下 $i$ 表示时间点，$i'$ 表示飞机点。）

同时处理登机桥和摆渡车不好弄，我们可以先把无解判掉（这容易使用差分加一遍前缀和办到），因为飞机只可能从登机桥到摆渡车而不会返回来，所以飞机去了摆渡车那边就可以视为直接起飞，不用管这个飞机了。这样只考虑登机桥，问题变得简单一些。

首先离散化时间，对每个时间建一个点，每个飞机建一个点。相邻两个时间点连边 $(i,i+1,a,0)$ 表示飞机停在这里（登机桥最多只能停 $a$ 架飞机）；对于每个飞机，连边 $(i',T,1,0)$ 表示飞机起飞，$(S,s,1,0)$ 表示 $s$ 时这个飞机到达。

然后我们讨论三种状态：

- 一直在摆渡车：他根本没有停在登机桥，算完贡献直接扔了它，于是连边 $(s,i',1,x)$。

- 一直在登机桥：飞机需要一直等到起飞的时刻才离开登机桥，但是没有贡献，连边 $(t,i',1,0)$。

- 在登机桥登机之后下一时刻去摆渡车：在 $s+1$ 时刻以后飞机就不在登机桥了，我们让他等待一时刻，然后直接扔了它，连边 $(s+1,i',1,px)$。

然后跑费用流，就做完了。

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
struct edge
{
    int nxt,to,weight,val;
}e[100001<<2];
int T,n,m,p,tot=1,h[100001],s,t,cur[100001],dep[100001],cost,node[100001],cnt,plane[100001][3],sum[100001];
double P;
bool vis[100001];
inline int read()
{
    int x=0;
    char c=getchar();
    while(c<'0'||c>'9')
        c=getchar();
    while(c>='0'&&c<='9')
    {
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x;
}
inline void add(int x,int y,int w,int val)
{
    e[++tot].nxt=h[x];
    h[x]=tot;
    e[tot].to=y;
    e[tot].weight=w;
    e[tot].val=val;
}
inline bool SPFA()
{
    for(register int i=0;i<=t;++i)
    {
        vis[i]=0;
        dep[i]=0x3f3f3f3f;
        cur[i]=h[i];
    }
    queue<int> q;
    q.push(s);
    dep[s]=0;
    while(!q.empty())
    {
        int k=q.front();
        q.pop();
        vis[k]=0;
        for(register int i=h[k];i;i=e[i].nxt)
            if(e[i].weight&&dep[e[i].to]>dep[k]+e[i].val)
            {
                dep[e[i].to]=dep[k]+e[i].val;
                if(!vis[e[i].to])
                {
                    vis[e[i].to]=1;
                    q.push(e[i].to);
                }
            }
    }
    return dep[t]^dep[0];
}
int dfs(int k,int f)
{
    if(k==t)
    {
        vis[t]=1;
        return f;
    }
    vis[k]=1;
    int r=0,used=0;
    for(register int i=cur[k];i;i=e[i].nxt)
    {
        cur[k]=i;
        if((!vis[e[i].to]||vis[e[i].to]==t)&&e[i].weight&&dep[e[i].to]==dep[k]+e[i].val)
            if((r=dfs(e[i].to,min(e[i].weight,f-used))))
            {
                e[i].weight-=r;
                e[i^1].weight+=r;
                used+=r;
                cost+=r*e[i].val;
                if(f==used)
                    break;
            }
    }
    return used;
}
inline int dinic()
{
    while(SPFA())
    {
        vis[t]=1;
        while(vis[t])
        {
            memset(vis,0,sizeof vis);
            dfs(s,1<<20);
        }
    }
    return cost;
}
int main()
{
    T=read();
    while(T--)
    {
        tot=1;
        memset(e,0,sizeof e);
        memset(h,0,sizeof h);
        memset(node,0,sizeof node);
        memset(sum,0,sizeof sum);
        cost=0;
        n=read(),m=read(),p=read();
        scanf("%lf",&P);
        for(register int i=1;i<=n;++i)
            plane[i][0]=read(),node[++cnt]=plane[i][1]=read(),node[++cnt]=plane[i][2]=read();
        sort(node+1,node+cnt+1);
        cnt=unique(node+1,node+cnt+1)-node-1;
        s=n+cnt+1,t=s+1;
        for(register int i=1;i<cnt;++i)
        {
            add(i,i+1,m,0);
            add(i+1,i,0,0);
        }
        for(register int i=1;i<=n;++i)
        {
            plane[i][1]=lower_bound(node+1,node+cnt+1,plane[i][1])-node;
            plane[i][2]=lower_bound(node+1,node+cnt+1,plane[i][2])-node;
            ++sum[plane[i][1]];
            --sum[plane[i][2]];
            add(s,plane[i][1],1,0);
            add(plane[i][1],s,0,0);
            add(i+cnt,t,1,0);
            add(t,i+cnt,0,0);
            add(plane[i][2],i+cnt,1,0);
            add(i+cnt,plane[i][2],0,0);
            add(plane[i][1],i+cnt,1,plane[i][0]);
            add(i+cnt,plane[i][1],0,-plane[i][0]);
            add(plane[i][1]+1,i+cnt,1,(int)floor(plane[i][0]*P+1e-5));
            add(i+cnt,plane[i][1]+1,0,(int)-floor(plane[i][0]*P+1e-5));
        }
        bool flag=1;
        for(register int i=1;i<=cnt;++i)
        {
            sum[i]+=sum[i-1];
            if(sum[i]>m+p)
            {
                puts("impossible");
                flag=0;
                break;
            }
        }
        if(!flag)
            continue;
        printf("%d\n",dinic());
    }
    return 0;
}
```


---

## 作者：tmp_get_zip_diff (赞：3)

首先，无解的情况可以做一遍差分判掉。

有解的情况考虑图论建模，构建一个由时间和飞机构成的网络。

我们把源点看作天空，汇点也看作天空（？），飞机 $i$ 从天空飞来，相当于一条 $(s \to i,1,0)$ 的边，飞机 $i$ 飞向天空，相对于一条 $(I \to t,1,0)$ 的边。（$I$ 是飞走的时间，$ii$ 是飞来的时间，后同）

每个时间只能有 $a$ 个飞机在登机桥区，相当于一条 $(time \to time+1,1,a)$ 的边。

一个飞机不可能从摆渡车区到登机桥区，只有可能是从登机桥区到摆渡车区，由于有解，我们对这一种飞机的处理就是让它把所有乘客接着然后直接飞走，相当于一条 $(ii+1 \to i,1,sz_i \times p)$ 的边。

其余的情况就只有一直在登机桥区：一条 $(I \to i,1,0)$ 的边；一直在摆渡车区：一条 $(ii \to i,1,sz_i)$。

再跑一遍费用流就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 

const int N=2e5+5;
class eg
{
public:
	int to,w,val;
	int unsigned ip;
};
int s,t,n,dj,bd,a[N],tot,sz[N],st[N],ed[N],dis[N],hig[N],diff[N],sum[N];
double p;
vector<eg>nbr[N];
bool vis[N];

void add(int x,int y,int w,int val)
{
	nbr[x].push_back({y,w,val,nbr[y].size()});
	nbr[y].push_back({x,0,-val,nbr[x].size()-1ull});
	return ;
}

void lish()
{
	sort(a+1,a+tot+1);
	tot=unique(a+1,a+tot+1)-(a+1);
	for(int i=1;i<=n;i++)
	{
		st[i]=lower_bound(a+1,a+tot+1,st[i])-a;
		ed[i]=lower_bound(a+1,a+tot+1,ed[i])-a;
	}
	return ;
}

bool bfs(int st)
{
	queue<int>q;
	q.push(st);
	for(int i=s;i<=t;i++)
		dis[i]=1e18,hig[i]=0,vis[i]=false;
	dis[st]=0;
	vis[st]=true;
	while(q.empty()==false)
	{
		int cur=q.front();
		q.pop();
		vis[cur]=false;
		for(auto dat:nbr[cur])
		{
			int nxt=dat.to,w=dat.w,val=dat.val;
			if(dis[cur]+val<dis[nxt]&&w>0)
			{
				dis[nxt]=dis[cur]+val;
				if(vis[nxt]==false)
				{
					q.push(nxt);
					vis[nxt]=true;
				}
			}
		}
	}
	return dis[t]<=1e12;
}

pair<int,int>dfs(int cur,int now)
{
	if(cur==t)
		return {now,0};
	int num=0,fy=0;
	for(int i=hig[cur];i<nbr[cur].size();i=hig[cur])
	{
		hig[cur]=i+1;
		int nxt=nbr[cur][i].to,w=nbr[cur][i].w,ip=nbr[cur][i].ip,val=nbr[cur][i].val;
		if(dis[cur]+val==dis[nxt]&&w>0)
		{
			auto h=dfs(nxt,min(now,w));
			num+=h.first;
			fy+=h.second+h.first*val;
			now-=h.first;
			nbr[cur][i].w-=h.first;
			nbr[nxt][ip].w+=h.first;
			if(now<=0)
				break;
		}
	}
	return {num,fy};
}

void Work()
{
	cin>>n>>dj>>bd>>p;
	for(int i=0;i<=2e5;i++)
		nbr[i].clear(),diff[i]=0;
	tot=0;
	for(int i=1;i<=n;i++)
	{
		cin>>sz[i]>>st[i]>>ed[i];
		a[++tot]=st[i];
		a[++tot]=ed[i];
	}
	lish();
	for(int i=1;i<tot;i++)
		add(i,i+1,dj,0);
	s=0,t=tot+n+1;
	for(int i=1;i<=n;i++)
	{
		diff[st[i]]++;
		diff[ed[i]]--;
		add(s,st[i],1,0);
		add(i+tot,t,1,0);
		add(st[i],i+tot,1,sz[i]);
		add(ed[i],i+tot,1,0);
		add(st[i]+1,i+tot,1,floor(sz[i]*p+1e-6));
	}
	for(int i=1;i<=n;i++)
	{
		sum[i]=sum[i-1]+diff[i];
		if(sum[i]>dj+bd)
		{
			puts("impossible");
			return ;
		}
	}
	int ans=0,fy=0;
	while(bfs(0)==true)
	{
		auto now=dfs(0,1e18);
		ans+=now.first;
		fy+=now.second;
	}
	cout<<fy<<"\n";
	return ;
}

signed main()
{
	int T;
	cin>>T;
	while(T--)
		Work();
	return 0; 
}
```

---

## 作者：pythoner713 (赞：3)

根据数据范围，不妨猜测，可以利用**费用流**解决本题。

费用流的常见套路是将时间作为节点建图，本题也不例外。我们将每架飞机的登机和起飞时间离散化，便可以得到 $m\,(m\le 2n)$ 个时间点。那么本题的做法就是：通过这些时间点构建网络，将飞机数作为容量，不愉快度作为费用，求解费用流。

在此之前，要注意两点：

- 先判断无解的情况（这是因为在后面的建图中，我们会把每个时刻点拆分成在停机桥和摆渡车的两点，但由于两者的数量不等 $(a\neq b)$，不能直接保证拆分的可行性，因此我们需先排除此类无解情况）。这很简单，只需要统计每个时刻的飞机数目，**一旦超过 $a+b$ 便无解**。

- **不应**将不满意度作为费用跑最小费用流。正确的做法是先假设所有乘客都先去摆渡车，就是都很不满意（即初始化 ${\rm ans}=\sum x_i$)，然后将每条边的费用设为此次操作可以减小的不满意度，跑**最大费用流**。然后将 ${\rm ans}$ 减去这个最大费用，即可得到最小不满意度。

明确这两点后，就可以给出如下的建图步骤：

1. 设立源点 $S=0$ 和汇点 $T=m+1$，分别代表初始时刻和结束时刻。

2. 对于每个时间点 $i\,(1\le i\le m)$，将其拆分成两个点 $i$ 和 $i'$，分别代表该时刻的停机楼和摆渡车。

3. 连接 $S\to 1\to 2\to\cdots\to m\to T$。其中每条边容量为 $a$，费用为 $0$。这代表停机楼数量恒为 $a$，且一直呆在停机楼并不会减小乘客不满意度。


4. 对于每个登机时刻 $s_i$，连接 $s_i\to i'$。容量为 $1$，费用为 $0$。这是因为我们已经默认乘客都先去摆渡车了，不会改变不满意度。

5. 对于每个起飞时刻 $t_i$，连接 $i'\to t_i$。容量为 $1$，费用为 $x_i$。代表一开始去停机楼可以减少 $x_i$ 的不满意度。

6. 对于每个登机时刻 $s_i$，连接 $i'\to s_i+1$
。容量为 $1$，费用为 $x_i-px_i$。这代表临时从摆渡车转去停机楼可以减少 $x_i$ 的不满意度，但切换会带来 $px_i$ 的不满意度。

至此我们便完成了网络的构建。利用 Dinic 之类的算法求出最大费用最大流即可。

---

```cpp
#include<bits/stdc++.h>
#define nb 666
#define mb 23333
#define inf 1e8
#define X(a) memset(a, 0, sizeof(a))
using namespace std;

int ans, _, n, m, a, b, x[nb], s[nb], t[nb], O[nb], sum[nb];
int S, T, cnt, dis[nb], head[mb], cur[mb];
bool vis[nb];
double p;

struct edge{
	int to, next, val, cost;
}e[mb];

void add_edge(int u, int v, int w, int c){
	e[++cnt].to = v, e[cnt].val = w, e[cnt].cost =  c, e[cnt].next = head[u], head[u] = cnt;
	e[++cnt].to = u, e[cnt].val = 0, e[cnt].cost = -c, e[cnt].next = head[v], head[v] = cnt;
}

bool SPFA(){
	memset(dis, 0xcf, sizeof(dis));
	memcpy(cur, head, sizeof(cur));
	dis[S] = 0, vis[S] = 1;
	queue<int> q;
	q.push(S);
	while(!q.empty()){
		int u = q.front();
		q.pop(), vis[u] = 0;
		for(int i = head[u]; i; i = e[i].next){
			int v = e[i].to;
			if(e[i].val && dis[v] < dis[u] + e[i].cost){
				// 求最大费用，SPFA 处理最长路
				dis[v] = dis[u] + e[i].cost;
				if(!vis[v]) q.push(v), vis[v] = 1;
			}
		}
	}
	return dis[T] > -inf;
}

int DFS(int u, int in){
	if(u == T) return in;
	vis[u] = 1;
	int out = 0;
	for(int &i = cur[u]; i && out < in; i = e[i].next){
		int v = e[i].to;
		if(!vis[v] && e[i].val && dis[v] == dis[u] + e[i].cost){
			int res = DFS(v, min(e[i].val, in - out));
			if(res) ans -= res * e[i].cost, e[i].val -= res, e[i ^ 1].val += res, out += res;
			//	注意了，这里是 "ans -= ..."，因为要尽可能多地减去不满意度
		}
	}
	vis[u] = 0;
	return out;
}

int main(){
	for(cin >> _; _; _--){
		ans = 0, cnt = 1;
		X(sum), X(head), X(vis);
		// 清空数组

		cin >> n >> a >> b >> p;
		for(int i = 1; i <= n; i++){
			cin >> x[i] >> s[i] >> t[i];
			O[i * 2 - 1] = s[i], O[i * 2] = --t[i];
		}
		sort(O + 1, O + n * 2 + 1);
		m = unique(O + 1, O + n * 2 + 1) - O - 1;
		for(int i = 1; i <= n; i++){
			// 离散化，同时统计每时刻飞机数目
			s[i] = lower_bound(O + 1, O + m + 1, s[i]) - O;
			t[i] = lower_bound(O + 1, O + m + 1, t[i]) - O + 1;
			sum[s[i]]++, sum[t[i]]--;
		}

		bool oops = 0;
		for(int i = 1; i <= m; i++){
			sum[i + 1] += sum[i];
			oops |= (sum[i] > a + b);
		}	// 若某时刻飞机数目大于 a + b 即无解
		if(oops){
			cout << "impossible\n";
			continue;
		}

		S = 0, T = m + 1;
		for(int i = 0; i <= m; i++){
			add_edge(i, i + 1, a, 0);
		}
		for(int i = 1; i <= n; i++){
			ans += x[i];	// 先累计不满意度
			add_edge(s[i], i + 1 + m, 1, 0);
			add_edge(i + 1 + m, s[i] + 1, 1, x[i] - floor(p * x[i] + 1e-5));
			add_edge(i + 1 + m, t[i], 1, x[i]);
			// 按照所述步骤建图（这里 i' = i + 1 + m)
		}
		while(SPFA()) DFS(S, inf);	// 最大费用最大流
		cout << ans << endl;
	}
	return 0;
}
```

---

### 说在后面

这道题网上貌似没有详细的题解，所以个人见解可能有偏差（尤其是建图那），欢迎指正。

---


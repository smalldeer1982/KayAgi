# 「Stoi2029」以父之名

## 题目背景

> 以父之名判决  
> 那感觉没有适合字汇  
> 就像边笑边掉泪  
> 凝视着完全的黑  
> 阻挡悲剧蔓延的悲剧会让我沉醉  
> ——《[以父之名](https://www.bilibili.com/video/BV1fx411N7bU?p=36)》

## 题目描述

地狱里有 $n$ 个罪人在等待判决，编号为 $1$ 至 $n$。罪人们之间有 $m$ 条罪的联系，编号为 $1$ 至 $m$，每条联系 的值为 $1$ 或 $2$ 且恰好连接两个罪人。

称一个罪人的自负度为他和其他所有罪人之间联系的值之和。两个罪人之间可能不止有一条联系，此时这些联系的值都应该被计算。由于这些罪人承受了太多的罪恶，他们变得不和谐。具体地，每个罪人的自负度都是奇数。

现在，神明将要对他们进行判决。判决的具体方式为：将每条联系都进行定向，使得这条联系所连接的两个罪人中的一个受到惩罚，另一个受到救赎，它们的值均为这条联系的值。

由于神明秉承父的仁慈，希望罪人们更加均等地接受惩罚和救赎，于是他规定判决后每个罪人所受到的惩罚和救赎值总和之差的绝对值必须恰好为 $1$。

由于神明工作繁忙，因此他以父之名要求你为他找到一种判决的方法。由于父的指示不会有错，所以一定存在一种这样的方法。

---

#### 题意简述

给定一个 $n$ 个点 $m$ 条边的无向图，边权均为 $1$ 或 $2$。保证每个点所相连的边权值之和均为奇数。你需要将这些边定向，使每个点的入边权值和与出边权值和之差的绝对值恰为 $1$。保证有解。输出任意一种方案。

## 说明/提示

#### 样例解释

定向后的图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/uhz96nbm.png)

更多样例详见题目附件 `trial_sample.zip`。

------

#### 数据范围

**本题采用捆绑测试。**

- 特殊性质 A：边权均为 $1$，且任意两点之间只存在一条简单路径，且没有重边。
- 特殊性质 B：同一个点至多只有一条边权为 $1$ 和一条边权为 $2$ 的边相连。

| Subtask | 分值 | $1\le n \le$ | $1\le m \le$ | 特殊性质 | 
| :-: | :-: | :-: | :-: | :-: |
| $1$ | $7$ | $10$ | $15$ | 无 | 
| $2$ |  $20$ |$10^3$ | $3\times10^3$ | 无 |
| $3$ |  $20$ |$3 \times 10^5$ | $3 \times 10^5$ | A |
| $4$ | $20$ |$3 \times 10^5$ | $3 \times 10^5$ | B | 
| $5$ |  $33$ |$10^6$ | $3 \times 10^6$ | 无 |

对于 $100\%$ 的数据，$1 \le u_i,v_i \le n \le 10^6$，$1 \le m \le 3 \times 10^6$，$w_i \in \{1,2\}$。

在题目附件 `trial_sample.zip` 中：

- `trial_sample1.in` 即为样例 #1。
- `trial_sample2.in` 满足特殊性质 A。
- `trial_sample3.in` 满足特殊性质 B。
- `trial_sample4.in` 不满足特殊性质。

另外该目录下还有 `checker.exe`。

------

#### 提示

**本题输入输出量较大，请使用较快的输入输出方式。**

本题提供 [Special Judge 源码](https://www.luogu.com.cn/paste/7albhubs)和 `checker.exe`，供选手调试。Windows 下使用方法为:  
命令行在目标文件夹输入指令：
```
checker.exe data.in data.out data.out
```
其中 `data.in` 是输入数据文件，`data.out` 是程序运行结果文件。观察评判结果即可。

- `Perfect answer.` 表示答案正确。
-  `Wrong answer on node x, and the difference is d.` 表示答案错误，其中节点 $x$ 的入边权值和与出边权值和之差的绝对值为 $d$ 而不为 $1$。
- `Invalid answer.` 表示输出的字符串长度不正确或输出非法字符。

请务必保证**输出格式正确**，否则 Special Judge 可能会返回 Unknown Error 等不可预估的结果。

## 样例 #1

### 输入

```
4 5
1 2 1
1 3 2
2 3 1
2 4 1
4 1 2
```

### 输出

```
00100
```

# 题解

## 作者：Konnyaku_LXZ (赞：26)

考虑通过**欧拉回路**来构造答案。

我们**建立一个虚点，向所有度数为奇数的点连权值为1的虚边**，而度数为奇数的点必然有偶数个（考虑初始时所有点都是孤立的，度数均为 $0$，然后我们把边逐条加入图，一条边为它连接的两个点分别提供了 $1$ 的度数，即同时改变了它连接的两点度数的奇偶性），所以此时新图中的所有点度数都为偶数，即新图存在欧拉回路。

在跑欧拉回路时，假设我们通过边权为 $w$ 的边**进入**了点 $u$，那么我们现在要为 $u$ **选择一条出边**，我们**优先选择边权为 $w$ 的边，后选择边权不为 $w$ 的边**。

为什么要这么选呢？因为对于每个点 $i$，与它相连的所有边的边权和为奇数，所以每个点都应该有**奇数条权值为  $1$ 的边**与它相连，而权值为 $2$ 的边可以是奇数条也可以是偶数条。又因为**一个点有虚边当且仅当与这个点相连的权值为 $2$ 的边有偶数条**，所以按照上述策略选择出边，**不会**出现入边权值为 $2$，而不存在权值为 $2$ 的出边，我们选了虚边，导致该点入边与出边权值和之差的绝对值不为 $1$ 的情况。所以我们的构造方法是正确的。

总结一下，我们整道题的思路就是：**建立一个虚点，向所有度数为奇数的点连权值为 $1$ 的虚边，然后跑欧拉回路。在这个过程中，我们优先选择边权与入边相同的出边，后选择边权与入边不同的出边**。

最后吐槽一下，这题有亿点点卡常。

Code:

```cpp
#include<bits/stdc++.h>
#define rg register
using namespace std;

const int MAXN=1e6+50,MAXM=1e7+50;
typedef long long LL;

int read(){int cnt=0;char c=getchar();while(c<'0'||c>'9') c=getchar();while(c>='0'&&c<='9'){cnt=(cnt<<1)+(cnt<<3)+(c^48);c=getchar();}return cnt;}
void write(int x){if(x==0) putchar('0');else putchar('1');}

struct edge{int nxt,to,val,ans;};

edge e[MAXM];//e[i].nxt为不区分权值的下一条边 
int head[MAXN],Cnte=1;//head[i]表示与i相连的第一条边（不区分权值） 
int nxt[MAXM],now[MAXN][3];//nxt[i]表示权值和当前边相同的下一条边（即区分权值），now[i][j]表示第一条与i相连的权值为j的边 
int N,M,deg[MAXN];

void adde(int u,int v,int w){
	++Cnte;
	e[Cnte]=(edge){head[u],v,w,-1};
	nxt[Cnte]=now[u][w];
	now[u][w]=head[u]=Cnte;
}

void dfs(int u,int pre){
	while(now[u][pre]&&e[now[u][pre]].ans!=-1) now[u][pre]=nxt[now[u][pre]];//优先选权值相同的边 
	if(!now[u][pre]){pre=(pre==1?2:1);while(now[u][pre]&&e[now[u][pre]].ans!=-1) now[u][pre]=nxt[now[u][pre]];}//后选择权值不同的边 
	if(!now[u][pre]) return;
	e[now[u][pre]].ans=0;e[now[u][pre]^1].ans=1; 
	int t=now[u][pre];
	now[u][pre]=nxt[now[u][pre]];
	dfs(e[t].to,pre);
	for(rg int i=head[u];i;i=e[i].nxt){
		head[u]=e[i].nxt;
		if(e[i].ans==-1){e[i].ans=0;e[i^1].ans=1;dfs(e[i].to,e[i].val);}
	}
}

void Init(){
	N=read();M=read();
	for(rg int i=1;i<=M;++i){
		int u=read(),v=read(),w=read();
		adde(u,v,w);adde(v,u,w);
		++deg[u];++deg[v];
	}
}

void Solve(){
	for(rg int i=1;i<=N;++i) if(deg[i]&1){adde(N+1,i,1);adde(i,N+1,1);}//度数为奇数的点向虚点连一条虚边 
	dfs(1,1);
}

void Print(){
	for(rg int i=1;i<=M;++i) write(e[i<<1].ans);
}

int main()
{
	Init();
	Solve();
	Print();
	return 0;
}
```

---

## 作者：VinstaG173 (赞：9)

这本来是 MO 课（并不是 $2021$ 新星冲刺营）讲义上的一个题，据说是美国国家队的考试题（其实不怎么难= =），老师（也不是 ayh）讲得非常复杂又玄学，根本不是具体可操作的感觉。现在这个解法是我用我自己当时做的时候的解法整理出来的，如果有人有更优美的解法可以私信告诉我（

建议下文我没有给出证明（尤其是写了“易证”）的小结论大家都自己征一下，都非常简单且证明后有助于理解。

首先直接枚举定向方案，暴力判断就可以通过 Sub1。时间复杂度 $O(2^mm)$，期望得分 $7$ 分。

开始讲特殊性质的做法（这些部分分是 zly 提出的方案，个人感觉很优美且对解决此题很有提示意义）。在讲之前先说明一下：这个题的命题人之一是 IMO2005 金牌、MIT 助理教授赵宇飞大神，它的来源是这样一道题：

> 将任意一个无向图的边进行定向，使得每个点入度和出度之差的绝对值 $\le 1$。

性质 A 就是上面这题的树版本，可以说是此题的基础中的基础（

下面讲 A 的做法。我们考虑简化问题。我们发现如果相邻两条边的定向后首尾相接，那么它们对公共点的度数贡献为 $0$。类推可得一条链上的边首尾相接地定向，则其贡献与连接两个链端点的一条单独的边没有区别。因此，我们可以把树剖成一条条链，在题目的条件（所有点度数都是奇数）下，容易证明最终可以使得每个点恰为一条链的端点。这样我们就把一棵树简化成了一个匹配，随意对匹配中的边定向后转化回原图中的方向，容易发现此时已经满足要求。具体实现在正解部分讲解。

再讲性质 B 的做法。性质 B 对图进行了极度的简化，我们已经有了一个很强的条件：图中不存在边权相同且长度 $>1$ 的链。事实上有了 A 的解法作铺垫，也许你已经能够想到，这就是此题经过简化后的最终形态，因为权为 $1$ 的边显然构成一个匹配。对于这个问题，我们首先注意到一个最简单的事实：$1+1=2$。换句话说，就是 $2-1=1$。由这个最基本的等式（之一）我们容易发现一件事情：只要边权分别为 $1,2$ 的边各一条是首尾相接的，那么它们对公共点的度数贡献的绝对值为 $1$。由性质 B 的条件知此时该公共点没有其他边相连，已满足要求。

又由性质 B 的条件和奇度数限制易证原图可以拆成若干个顶点互不相交的链和环。其中环上的边权为 $1,2$ 交替（故显然边数为偶数），链上的边权 $1,2$ 交替，且两端均为 $1$（故显然长度为奇数）。我们只要找到这样的分拆方法，对环和链上的边分别首尾相接地定向，容易证明此时所有点已满足要求。

然后进入讲正解环节。Sub2 的解法在以下所有结论基础之上，只是实现更简单暴力。在下面讲具体实现时会讲到。

为了方便，我们先除掉重边（边权也相同）和自环。事实上在下面的去环步骤中可以一样地处理，没有必要单独讨论，但是它们更加特殊，其无实际贡献的性质也更显然。

接下来我们首先考虑简化整个问题，使得我们能借用前面的结论来处理。容易发现特殊性质的条件里都没有边同权值的环。所以我们首先考虑把同权环处理掉。显然由性质 A 的做法中提到的结论进行简单的推广，我们可以得知图中有同权环的时候我们把环上的边首尾相接地定向时对每个点的度数贡献均为 $0$。因此我们可以把整个图消到无同权环。

然后由性质 A 解法中的结论，我们知道对于一条同权链，我们对它的边首尾相接地定向后和连接两个链端点的一条边等价。这个性质对边权为 $2$ 显然也成立。

于是我们可以运用性质 A 的做法把图进一步转化为性质 B 的形式，进而解决整个问题。完整的解法大概分以下 $3$ 步：

1. 去环
2. 剖链（参考性质 A 解法，具体实现稍后讲解）
3. 链定向（参考性质 B 解法，对应回原图的方法稍后讲解，这步在性质 A 的解法中也要用到）

当然，我们的前两步要对权为 $1$ 的边构成的图和权为 $2$ 的边构成的图分别做一遍。下面讲这 $3$ 步各自的具体处理方法。

Sub2 的具体实现就是对每个点暴力 $O(m)$ 找环，然后对每棵树暴力剖链，然后对链暴力搜索定向，总时间复杂度 $O(nm)$，大概率跑不满，因为我没写过所以我不知道具体情况。期望得分 $27 \sim 67$，因为在性质 A 和 B 的条件下这个暴力只需要进行后两步操作，而后两步的暴力其实是容易做到 $O(n+m)$ 的。

剩下的就是正解了。

首先讲第 $1$ 步。直接 `dfs`，找到环时立即回溯，然后记录每个点扫到了哪条边，下次继续从这条边接着扫（每次从 `head` 开始扫可以卡）。这样做的过程中，易证若一条边直到回溯时都没被定向，则它必然不在任何没有被破坏的环中了（当然也可能是原来在环中但是环上有边在去掉另一个环时已经被定向了，所以说不在“没有被破坏的”环中），这样就保证了这一步的正确性。同时每条边都至多被访问两次（两个端点各一次），因此这一步的时间复杂度是 $O(n+m)$。对应代码里的 `dfs1`。

然后是第 $2$ 步。直接树上 `dfs`，我们对于每个点将它的子树（包括它连向父节点的边，不包括它的父节点）剖成若干条链，其中有一条是从它子树中某个点连向它的父节点的。对于叶子直接返回它连向它父亲的边，对于其他节点先把其子节点的子树内连上来的边每次选两个配成一条链，如果最后剩余一棵子树则直接将它返回的链连上去，否则返回它向它父亲连的边。这一步的复杂度是遍历森林的复杂度 $O(n)$。对应代码里的 `dfs2`，我们用一个三元组 $(x,y,lca)$ 形容一条链，表示其两个端点与两端点在树上的最近公共祖先。同时记录下每个点连向其父亲的边的编号与方向（对应题目输入是正向或反向），方便最后进行定向。

最后是第 $3$ 步。我们在第 $2$ 步中处理了 $(x,y,lca)$，在这里我们首先将其看作一条边 $x,y$。我们每次从一条权为 $2$ 的边开始进行搜索，这样每条边至多被搜索到一次，因此时间复杂度是边数 $O(n)$，对应代码 `main()` 函数中注释 `stp2-2` 与 `stp3` 之间部分。我们对链定向后回到原图处理每条链，从 $x$ 往上跳，一直跳到 $lca$ 为止，这一路上的方向是相同的，与链从 $x$ 到 $y$ 的方向相同；再从 $y$ 往上跳，一直跳到 $lca$ 为止，这一路上的方向也是相同的，但和跳 $x$ 时反向。这样我们就做到了每一条链上边的定向，总时间复杂度是第 $2$ 步中森林所有边数，即 $O(n)$，对应代码中 `stp3` 与 `stp4-2` 之间部分。

这样我们就解决了这个问题，总时间复杂度 $O(n+m)$。

由于 `std` 有丶长，并且写了奇怪的指针，所以加注释有丶复杂，如果需要注释可以在评论区说，我会有（gu）空（gu）时（gu）补（gu）的。

另外，由于代码能力不足，我当时调 `std` 用了好久，`main()` 里面的注释原来是调试信息，现在感觉也有帮助大家更清晰地理解代码~~以及凑 $173$ 行~~的作用，于是就没删了（

Code(std):
```cpp
#include<bitset>
#include<cstdio>
#define rg register
using std::bitset;
inline char gc()
{
	static char buf[1048576],*pn=buf,*pe=buf;
	return (pn==pe)&&(pe=(pn=buf)+fread(buf,1,1048576,stdin),pn==pe)?EOF:*pn++;
}
inline int read()
{
	int x=0;
	char c=gc();
	while(c<'0'||c>'9')c=gc();
	while(c>='0'&&c<='9')x=x*10+(c^48),c=gc();
	return x;
}
int *head,*cnt;
int hd1[1000003],c1=1;
int hd2[1000003],c2=1;
struct edge
{
	int nxt,to,id;
}e1[6000007],e2[6000007],*e,ed;
inline void add(int x,int y,int w,int i)
{
	(w==1)?(head=hd1,cnt=(&c1),e=e1):(head=hd2,cnt=(&c2),e=e2);
	e[++(*cnt)].nxt=head[x],e[*cnt].to=y,e[*cnt].id=i,head[x]=*cnt;
	e[++(*cnt)].nxt=head[y],e[*cnt].to=x,e[*cnt].id=i,head[y]=*cnt;
}
int flag=0,psv;
int ti[1000003];
char dr[3000007];
bitset<1000003>vis;
bitset<3000007>tem;
void dfs1(int u,int pi)
{
	vis.set(u);
	for(rg int i=ti[u];i;i=ti[u])
	{
		ti[u]=e[ti[u]].nxt;
		if(e[i].id==pi)continue;
		if(tem[e[i].id])continue;
		int v=e[i].to,si=e[i].id;
		if(vis[v])
		{
			flag=1,psv=v,dr[si]=(i&1)^48;
			tem.set(si),vis.reset(u);
			return;
		}
		dfs1(v,si);
		if(flag)
		{
			dr[si]=(i&1)^48,tem.set(si);
			if(u==psv)flag=0;
			else {vis.reset(u);return;}
		}
	}
	vis.reset(u);
	return;
}
struct line
{
	int x,y,lca,dir;
}l1[500003],l2[500003],*ln;
int n1[1000003],n2[1000003],*nm;
int f1[1000003],f2[1000003],*fa;
int dfs2(int u,int pi)
{
	rg int pv=0,sv;
	vis.set(u),fa[u]=pi;
	for(rg int i=head[u];i;i=e[i].nxt)
	{
		if(i==pi)continue;
		if(tem[e[i].id])continue;
		int v=e[i].to;
		sv=dfs2(v,i^1);
		if(!pv)pv=sv;
		else
		{
			ln[++(*cnt)].lca=u;
			ln[*cnt].x=pv,ln[*cnt].y=sv;
			nm[pv]=nm[sv]=*cnt,pv=0;
		}
	}
	return (pv)?pv:u;
}
int n,m,x,y,w;
int main()
{
	n=read(),m=read();
	for(rg int i=0;i<m;++i)
	{
		x=read(),y=read(),w=read();
		(x!=y)&&(add(x,y,w,i),1);
	}
//	puts("stp0");
	head=hd1,e=e1,c1=0,ln=l1,cnt=(&c1),nm=n1,fa=f1;
	for(rg int i=1;i<=n;++i)ti[i]=head[i];
	for(rg int i=1;i<=n;++i)if(ti[i])dfs1(i,-1);
//	puts("stp1-1"); 权1图去环 完成
	for(rg int i=1,j;i<=n;++i)
	{
		if(!vis[i])
		{
			j=dfs2(i,-1);
			nm[i]=nm[j]=++(*cnt),ln[*cnt].x=j;
			ln[*cnt].y=ln[*cnt].lca=i;
		}
	}
//	puts("stp1-2"); 权1图剖链 完成
	head=hd2,e=e2,c2=0,ln=l2,cnt=(&c2),nm=n2,fa=f2,vis.reset();
	for(rg int i=1;i<=n;++i)ti[i]=head[i];
	for(rg int i=1;i<=n;++i)if(ti[i])dfs1(i,-1);
//	puts("stp2-1"); 权2图去环 完成
	for(rg int i=1,j;i<=n;++i)
	{
		if(!vis[i])
		{
			j=dfs2(i,-1);
			if(j!=i)
			{
				nm[i]=nm[j]=++(*cnt),ln[*cnt].x=j;
				ln[*cnt].y=ln[*cnt].lca=i;
			}
		}
	}
//	puts("stp2-2"); 权2图剖链 完成
	for(rg int u=1,v,t,nm1,nm2;u<=n;u=t+1)
	{
		nm1=nm2=n2[u],t=u;
		while(nm1)
		{
			(u==l2[nm1].x)?\
			(v=l2[nm1].y,l2[nm1].dir=0):\
			(v=l2[nm1].x,l2[nm1].dir=1);
			n2[u]=n2[v]=0,nm1=n1[v];
			(v==l1[nm1].x)?\
			(u=l1[nm1].y,l1[nm1].dir=0):\
			(u=l1[nm1].x,l1[nm1].dir=1);
			n1[u]=n1[v]=0,nm1=n2[u];
		}
		v=l2[nm2].x^l2[nm2].y^t;
		while(nm2)
		{
			(v==l2[nm2].x)?\
			(u=l2[nm2].y,l2[nm2].dir=1):\
			(u=l2[nm2].x,l2[nm2].dir=0);
			n2[u]=n2[v]=0,nm2=n1[u];
			(u==l1[nm2].x)?\
			(v=l1[nm2].y,l1[nm2].dir=1):\
			(v=l1[nm2].x,l1[nm2].dir=0);
			n1[u]=n1[v]=0,nm2=n2[v];
		}
	}
//	puts("stp3"); 链定向 完成
	for(rg int i=1,u,v,p,d;i<=c1;++i)
	{
		u=l1[i].x,v=l1[i].y,p=l1[i].lca,d=l1[i].dir;
		while(u!=p)dr[e1[f1[u]].id]=(f1[u]&1)^d^48,u=e1[f1[u]].to;
		while(v!=p)dr[e1[f1[v]].id]=(f1[v]&1)^d^49,v=e1[f1[v]].to;
	}
//	puts("stp4-1"); 权1图边定向 完成
	for(rg int i=1,u,v,p,d;i<=c2;++i)
	{
		u=l2[i].x,v=l2[i].y,p=l2[i].lca,d=l2[i].dir;
		while(u!=p)dr[e2[f2[u]].id]=(f2[u]&1)^d^48,u=e2[f2[u]].to;
		while(v!=p)dr[e2[f2[v]].id]=(f2[v]&1)^d^49,v=e2[f2[v]].to;
	}
//	puts("stp4-2"); 权2图边定向 完成
	puts(dr);
	return 0;
}
```

---

## 作者：言琢დ (赞：4)

**洛谷当场月赛讲评人题解。**

$$\rm Analysis\sim\text{以父之名}$$

$$\rm Author:~Znloye$$

---

容易发现一个合法的方案中，所有的边的方向反向，依然是一个合法方案，据此我们只需要关心一条边的方向与其他边的相对关系，亦即 **差的绝对值** $\le1$。

---

#### $\rm Subtask~1$

特殊性质：$n\le10,~m\le15$。

做法：$m$ 条边的方向非正即逆，$2^m$ 枚举所有可能性，$O(m)$ 进行度数统计。

期望复杂度 $O(m\times 2^m)$，期望得分 $7$。

[$\rm code\Leftarrow$](/api/team/downloadFile/aq0aypjs)

---

#### $\rm Subtask~2$

特殊性质：$n\le10^3,~m\le3\times10^3$。

做法：正解中不会使用正确写法“删环”，对每个点暴力找环的部分分。

期望复杂度 $O(n\times m)$，考虑到对每个点找环时根本跑不满 $O(m)$，期望得分 $27\sim67$。

---

#### $\rm Subtask~3$

特殊性质：图是一片边权 $=1$ 的森林。

做法：由于图是一片森林，对每棵树，考虑从一个点 $root$ 开始遍历，假设目前遍历到 $u$，并记录自己父亲 $fa$ 带来的权值信息 $val$：

- 若上面一条边指向 $fa\rightarrow u$，则先从向下的边 $u\rightarrow v$ 开始定向并向下传递信息；
- 反之 $u\leftarrow v$ 开始定向并向下传递信息。
- 这样无论 $u$ 有多少个孩子，$u$ 定出来的绝对值之差不会超过 $1$。

另一方面，对于每个叶子结点 $y$，无论其父亲 $x$ 的定向方案是 $x\rightarrow y$ 或 $x\leftarrow y$，绝对值之差均不会超过 $1$。

综上，每一棵树的所有叶子、非叶子结点绝对值之差均不超过 $1$，即整片森林均满足绝对值之差均不超过 $1$。

[$\rm code\Leftarrow$](/api/team/downloadFile/on0cbwym)

---

#### $\rm Subtask~4$

特殊性质：结点 $u$ 最多连一条权为 $1$ 的边、一条权为 $2$ 的边。

做法：这就是一条链，进一步地，边权是 $1,2$ 交替的一条链。

直接考虑找到一个度为 $1$ 的结点 $u$，所有边都同向地指向链的另一个端点 $v$。

即：$u\rightarrow node_1\rightarrow node_2\rightarrow\cdots\rightarrow node_{n-2}\rightarrow v$。

与 Subtask3 的最后一步相同，由于每条链的结果均符合要求，最终答案也一定符合要求。

[$\rm code\Leftarrow$](/api/team/downloadFile/p5u0bi8y)

---

#### $\rm Subtask~5$

满分做法 $O(n+m)$ 分为三个部分：

1. 删环；
2. 剖链；
3. 定向：$\rm Subtask4$。

4. 删环怎么 $O(n+m)$ 删：

	-  一个朴素的类似 tarjan 想法是，dfs，每次找到一条后向边就删掉对应的环，显然这种做法的复杂度 $O(n\times m)$。
	- 考虑优化这一过程，每次多记录一个最后一次遍历到的有效边，这就保证了每条有用的边仅遍历一次，不会遍历到已经删除的边去判断出这条边不能遍历，这种做法的复杂度 $O(n+m)$。

5. 剖链的功能：将“删环”后的图进一步简化成一个满足 $\rm Subtask4$ 性质的图，该图的边数是 $O(n)$ $\color{red}特别注意不是 O(m)$。

	- 借用 $\rm Subtask3$ 的模型，考虑对于以 $u$ 为根的 **子树**（**包括 $u$ 连向 $fa$ 的边，但不包括 $fa$**）剖成若干条链，其中有一条链从 $u$ 的子树中 **某个点** 连向 $fa$。
	- 对于叶子结点 $y$ 直接返回连向 $fa$ 的边。
	- 对于其他的非叶子结点 $u$，先把其子结点 $v_1,v_2,\cdots,v_k$ 的子树内连上来的边（或称作链）两两配对。
	- 容易发现若 $k$ 为奇数，最后会剩余一棵子树，直接将它返回的链连给 $fa$ 结点。
	- 若 $k$ 为偶数，则返回 $u$ 向 $u$ 的父亲连的边。
   
至此我们用一个三元组 $(x,y,lca)$ 形容一条链，表示一条链的两个端点 $(x,y)$ 与它们的最近公共祖先 $lca$。

同时记录下每个点连向其父亲的边的编号 `Id` 与方向（对应题目输入是正向或反向），方便最后进行定向。

**特别注意：我们在将图转化为 Subtask4 之前不对任何没有在去环时处理掉的边进行定向，最后做 Subtask4 的时候才定向。**

6. 最后定向。根据 Subtask4 的逻辑，上面的“剖链”过程已经保证对每个点至多有一条边权为 $1$ 的边和一条边权为 $2$ 的边与之相连，直接按照 Subtask4 和之前记下的方向信息进行最终定向即可。

[$\rm huge~code\Leftarrow$](/api/team/downloadFile/mnovifb4)

---

## 作者：_fairytale_ (赞：3)

>一切文字不如你鲜明
>
>侥幸写下什么也不足长留你的神情
>
>你是所有漫反射的光线 而我简出你身影
>
>你与每一个夏日遥相呼应

看到题面第一反应欧拉回路，认为入边和出边配对。想到每个点的出边可以任意重排，所以猜想倾向选与入边边权相同的边。但是原来建的图是源点向所有边权和为奇数的点连边，然后发现死了。

我们只需改为由源点向所有度数为奇数的点连边。

首先观察到每个点一定与奇数条边权为 $1$ 的边相邻，然后我们可以讨论一下：

如果一个点有奇数条边权为 $2$ 的边，那么只有一个 $2$ 和一个 $1$ 配对，符合要求。

如果一个点有偶数条边权为 $2$ 的边，那么这些边会互相抵消，我们再从源点向它连一条边权为 $1$ 的边，这样这条边会和 $1$ 配对，边权差也为 $1$。

显然度数为奇数的点有偶数个，所以源点度数一定为偶数，跑欧拉回路即可。

注意有些连通块没有度数为奇数的点，要单独跑一遍。

```cpp
#include<bits/stdc++.h>
bool Mst;
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define rep(x,qwq,qaq) for(int x=(qwq);x<=(qaq);++x)
using namespace std;
#define maxn 1000010
int n,m;
vector<pii>g[2][maxn];
int cur[2][maxn];
bitset<maxn*4> vis,ans;
bitset<maxn>ok;
void dfs(int u,int in) {
	ok[u]=1;
	auto f=[&](int op)->void {
		auto &G=g[op][u];auto &Cur=cur[op][u];
		for(int i=Cur,k=G.size(); i<k; i=Cur) {
			++Cur;
			int v=G[i].fi,j=G[i].se;
			if(vis[abs(j)])continue;
			vis[abs(j)]=1;
			dfs(v,op);
			if(j<0)ans[-j]=1;
		}
	};
	f(in);f(in^1);
}
int deg[maxn];
bool Med;
signed main() {
	cerr<<(&Mst-&Med)/1024.0/1024.0<<" MB\n";
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1,u,v,w; i<=m; ++i) {
		cin>>u>>v>>w;
		--w;
		g[w][u].push_back({v,i});
		g[w][v].push_back({u,-i});
		++deg[u],++deg[v];
	}
	int S=n+1;
	rep(i,1,n)if(deg[i]&1)g[0][S].push_back({i,i+m}),g[0][i].push_back({S,i+m});
	dfs(S,0);
	rep(i,1,n)if(!ok[i])dfs(i,0);
	rep(i,1,m)cout<<ans[i];
	return 0;
}
```

---

## 作者：BINYU (赞：2)

## 题意

有一个由 $n$ 个点 $m$ 条边组成的无向图，边有边权 $w\in\{1,2\}$，现要求给这 $n$ 条边定向，使得对于每个点 $u$ 有：连向 $u$ 的边的权值和与 $u$ 连出的边的权值和之差的绝对值为 $1$。

## 思路

首先可以发现，连进 $u$ 一条边再连出 $u$ 一条权值相同的边，是可以把权值抵消的，考虑对于每个 $u$，我们都尽量去抵消这些边，所以，最终剩下来的边有四种情况：

1. 没有边，明显不合法；

2. 只有一条边权为 $2$ 的边，也不合法；

3. 只有一条边权为 $1$ 的边，方向无所谓；

4. 有一条边权为 $1$ 的边，还有一条边权为 $2$ 的边，方向相反就合法。

所以情况 3 也等价于度数（**不是边权和**）为奇数，情况 4 等价于度数为偶数。

先考虑如何去抵消这些边，发现一条边连进来之后又要出去，最终会**连成一个闭环**，这不就是欧拉回路吗，于是，我们可以进行两次找欧拉回路，一次只走边权为 $1$ 的边，另一次走边权为 $2$ 的。

接下来考虑给剩下来的边定向，观察情况 4，这不也是一条边连进一条边连出吗，继续欧拉回路，又因为保证合法，所以只剩下情况 3 了，我们尝试给它“补一条边”，让这个点也能连进然后连出走回路，于是想到建一个新点，把所有这种点连向新点，边的权值为 $1$，**此时就相当于和剩的那条边抵消**，发现因为本图是无向图，所以度数和为偶数，所以情况 3 的点的个数也为偶数，于是新点也连了偶数条边，至此，全图的点都连了偶数条边，可以直接跑欧拉回路。

发现这样实现有点复杂，我们考虑只用一次欧拉回路求出答案，假设到达该点的边权值为 $w_{lst}$，那么我们优先走权值等于 $w_{lst}$ 的边，也就是优先抵消边，如果没有，说明当前权值的边只有 $1$ 条了，那么连向其他的任意一条边就行了，最后在建边时把边权不同的边分开建，找回路加上当前弧优化（不访问访问过的点）时标记每条边的方向输出就行了。

时间复杂度 $O(n+m)$，空间复杂度 $O(m)$。

---

## 作者：Pekac (赞：2)

[CF1610F](https://www.luogu.com.cn/problem/CF1610F)

[P7816](https://www.luogu.com.cn/problem/P7816)

*3000

令 $w_u$ 表示与 $u$ 直接相连的边的权值和。显然当 $2\mid w_u$ 时，这个节点是无法满足条件的，因为每次调整只能对 $\mid d^+(u)-d^-(u)\mid$ 的值造成偶数的影响。

这时候肯定会猜答案就是 $\sum\limits_{i=1}^{n}[w_u\in\{\text{odd}\}]$，但怎么构造呢。

对 $w_u$ 为奇数的点分类讨论一下。不妨设 $c_{u,i}$ 表示与 $u$ 相连的，边权为 $i$ 的边的数量。$w_u$ 的奇偶性此时只与 $c_{u,1}$ 有关了。当 $2\nmid w_u$ 时是有奇数个 $1$ 和若干个 $2$ 所得到。当 $2$ 为奇数时，肯定是考虑 $(1,1),(2,2)$ 的配对，然后最后有一对 $(1,2)$。配对的意思就是若 $v,x$ 和 $v,y$ 之间有两条边权均为 $w$ 的边，可以让 $x\to v,v\to y$ 或 $x\gets v,v\gets y$，此时 $v$ 依然可以满足条件，这样也就等价于删掉原来的两条边并且在 $x,y$ 间增加一条边，那么总边数就少了一条。

于是可以存两个图，只保留边权为 $1/2$ 的边。即 $(u,v,w)$ 变为 $(ver_w(u),ver_w(v))$。然后同色的匹配是一个进来一个出去，时两两成对的，然后就可以想到欧拉回路？

但是有奇度数点，即 $c_{u,2}\in\{\text{odd}\}$，最后剩一个 $1$ 时，这个 $1$ 可以随便定向，不好操作，于是考虑建立一个虚点对所有奇度数的点连一条权值为 $1$ 的边后再跑欧拉回路。$\text{even}$ 也是同理的。则对 $w_u\in\{\text{odd}\}$ 的点显然是没有影响的，当 $w_u\in\{\text{even}\}$ 时也不会产生影响，因为它本来就不会是候选点之一。

然后这道题就做完了，注意求欧拉回路时优先走权值相同的边。

P7816 的把输出最多个数去掉就行了。

---

## 作者：Leasier (赞：0)

### 性质 A：只有边权为 $1$ 的边
“差的绝对值恰好为 $1$”即：

- 设当前点 $u$ 的度数为 $deg_u$。
- $\mathcal{P}$：取 $\frac{deg_u - 1}{2}$ 对出边，方向相反。
- $\mathcal{Q}$：取剩余的一条出边，方向任意。

我们将 $\mathcal{P}$ 视为经过 $u$ 的两条边；建虚拟点 $S$ 与每个 $u$ 相连，则我们也可以将 $\mathcal{Q}$ 视为经过 $u$ 的两条边：另一条是以 $S$ 为一个端点者。

接下来跑欧拉回路，按照走的顺序给回路上的边定向即可。时间复杂度为 $O(n + m)$。

需要注意的是，我们需要从 $S$ 和每个只含偶度点的连通块的任意点出发各跑若干次欧拉回路（见 [Hack](https://www.luogu.com.cn/discuss/778098)）。
### 无特殊性质
还是考虑一个点 $u$：

- 我们尽量将权相同的边内部配对。
- 若此时只剩一个 $1$，任意定向即可。
- 若此时 $1, 2$ 各剩一个，令其方向相反即可。

仿照性质 A 跑欧拉回路，dfs 时优先走与到此处的边同权者即可。时间复杂度为 $O(n + m)$。

代码：
```cpp
#include <vector>
#include <cstdio>
#include <cstdlib>

using namespace std;

typedef struct Edge_tag {
	int id;
	int end;
	Edge_tag(int id_, int end_){
		id = id_;
		end = end_;
	}
} Edge;

int deg[1000007], cur_edge[1000007][2], ans[4000007];
bool vis1[1000007], vis2[4000007];
vector<Edge> vec[1000007][2];

inline int read(){
	int ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return ans;
}

void dfs(int u, int op){
	int size = vec[u][op].size();
	vis1[u] = true;
	for (register int i = cur_edge[u][op]; i < size; i = cur_edge[u][op] + 1){
		int id = abs(vec[u][op][i].id);
		cur_edge[u][op] = i;
		if (!vis2[id]){
			vis2[id] = true;
			ans[id] = vec[u][op][i].id > 0 ? 0 : 1;
			dfs(vec[u][op][i].end, op);
		}
	}
	op ^= 1;
	size = vec[u][op].size();
	for (register int i = cur_edge[u][op]; i < size; i = cur_edge[u][op] + 1){
		int id = abs(vec[u][op][i].id);
		cur_edge[u][op] = i;
		if (!vis2[id]){
			vis2[id] = true;
			ans[id] = vec[u][op][i].id > 0 ? 0 : 1;
			dfs(vec[u][op][i].end, op);
		}
	}
}

int main(){
	int n = read(), m = read();
	for (register int i = 1; i <= m; i++){
		int u = read(), v = read(), w = read();
		w--;
		deg[u]++;
		deg[v]++;
		vec[u][w].push_back(Edge(i, v));
		vec[v][w].push_back(Edge(-i, u));
	}
	for (register int i = 1, j = m; i <= n; i++){
		if (deg[i] % 2 == 1){
			j++;
			vec[0][0].push_back(Edge(j, i));
			vec[i][0].push_back(Edge(-j, 0));
		}
	}
	dfs(0, 0);
	for (register int i = 1; i <= n; i++){
		if (!vis1[i]) dfs(i, 0);
	}
	for (register int i = 1; i <= m; i++){
		putchar(ans[i] + '0');
	}
	return 0;
}
```

---

## 作者：DengDuck (赞：0)

感觉是一道非常巧妙的题目，不看题解之前一点头绪都没有。

不难发现一个点可以拆成差值为 $1$，当且仅当这个点所有的边边权之和为奇数，由于有解，题目一定符合这个条件，进一步地，每个点边权为 $1$ 的边必然只有奇数个。

接下来我们考虑不断抵消边，如果当前已经确定了一条边的方向，使得这条边指向了某一节点，那么为了达到一个抵消的效果。

显然这个点连向外面的点的一条边我们希望它的边权与连入这条边的那条边的边权一样，这样又会连入一个点，然后你又得递归的解决它，最后又会连回原来的点。

当然，我们在抵消的过程中，不一定能找到自己想要的那个边权的边，这个时候我们就可以选择另外一种边权的边，如果另外一种边权的边也没有的话，那么我们就不用管了。

为什么这样一定是对的呢？我们可以分讨一个点的度数的奇偶性。

如果这个点的度数是奇数，那么边权为 $2$ 的边的数量一定是偶数。

那么我们在尝试由边权为 $2$ 的边进入的时候，肯定可以匹配其他的 $2$。在尝试由边权为 $1$ 的边进入的时候，肯定可以匹配其他的 $1$，但是会多出来一个 $1$，这就会使两边的绝对值的差为 $1$，如果这个边不是在最后流进来的，就会匹配到一个边权为 $2$ 的边，不过，也没有问题，以后肯定还会流入一个边权为 $2$ 的边，因为这个问题我们是递归处理的。

最后跑完这张图的时候，显然是两边的 $2$ 对半开，某一边的 $1$ 多一个。

如果度数是偶数，那么边权为 $2$ 的边的数量肯定是奇数。

那么在尝试流入的时候，都会尽量抵消，直到最后流入的时候，流入的是什么边，就会以另外一种边流出。

最后跑完这张图的时候，显然是某一边多出来一个 $2$，另外一边多出来一个 $1$。

这里我讲的可能比较繁琐，可以手摸一下，正确性应该还是比较显然的。

这个显然是一个类似于欧拉回路的东西，我们利用欧拉回路来维护整个抵消的过程。

但是欧拉回路要求不能有奇点，所以我们要转换，对于所有度数为奇数的点，我们建一个虚点 $n+1$，向这些点留一条边权为 $1$ 的边。

这样肯定可以跑欧拉回路，但是这样的正确性为什么是对的呢？

考虑转换之后两种边权的数量都是偶数，所以每次流入的时候一定都能找到对应的边权流出，所以跑完之后差值其实是 $0$,时候我们再把这些边删掉，删掉这些虚边只影响虚边连向的实点，而不影响其他的实点，所以删掉这些虚边只会让那些差值为 $0$ 的点的差值变成 $1$，这样问题就解决了。

注意欧拉回路要写当前弧优化。

```cpp
#include<bits/stdc++.h>
#define LL int
#define pb push_back
using namespace std;
const LL N=1e6+5;
const LL M=1e7+5;
struct node
{
	LL to,w,nxt,ans;
}E[M];
LL n,m,du[N],h[N],now[N][3],nxt[M],tot=1;
void add(LL x,LL y,LL z)
{
	E[++tot]={y,z,h[x],-1};
	nxt[tot]=now[x][z],now[x][z]=h[x]=tot;
}
void dfs(LL x,LL c)
{
	while(now[x][c]&&E[now[x][c]].ans!=-1)
	{
		now[x][c]=nxt[now[x][c]];
	}
	if(!now[x][c])
	{
		c=c^3;
		while(now[x][c]&&E[now[x][c]].ans!=-1)
		{
			now[x][c]=nxt[now[x][c]];
		}
	}
	if(!now[x][c])return;
	E[now[x][c]].ans=0,E[now[x][c]^1].ans=1;
	LL t=now[x][c];
	now[x][c]=nxt[now[x][c]];
	dfs(E[t].to,c);
	for(LL i=h[x];i;i=E[i].nxt)
	{
		h[x]=E[i].nxt;
		if(E[i].ans==-1)
		{
			E[i].ans=0,E[i^1].ans=1;
			dfs(E[i].to,E[i].w);
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		LL x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z),add(y,x,z);
		du[x]++,du[y]++;
	}
	for(int i=1;i<=n;i++)
	{
		if(du[i]&1)add(n+1,i,1),add(i,n+1,1);
	}
	dfs(1,1);
	for(int i=1;i<=m;i++)
	{
		printf("%d",E[i*2].ans);
	}
}

```

---

## 作者：快斗游鹿 (赞：0)

## 思路

先来考虑边权均为 $1$ 的特殊情况。根据权值和为奇数这个条件，每个点度数一定是奇数，则 $n$ 一定为偶数。因为每条边都会产生 $2$ 的度数，最后的度数和一定是偶数。

度数全是奇数的图没啥性质，但是度数全是偶数的图却很特殊，因为这种图中一定存在**欧拉回路**。这启发我们建立一个超级点 $s$，并将 $s$ 与图中所有点连虚边，边权为 $1$。如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/in7xm2pp.png)

连完边之后呢？我们只需要求出一条欧拉回路，就是答案了！为什么？根据欧拉回路的性质，它可以看做是一个个环拼在一起，所以每个点的出度均等于入度，而每个点又都连了一条虚边，所以出度减入度的差的绝对值一定为 $1$。

然后再考虑边权 $1,2$ 的情况。沿用上种方法的策略，我们让 $s$ 与所有度数为奇数的点连边。但这样会有个问题，就是 $s$ 的度数是否是偶数？首先，因为权值和是奇数，所以每个点连的 $1$ 边一定是奇数条，且 $n$ 为偶数。那么当一个点度数为奇数时，就说明它连了偶数条 $2$ 边，其余点连了奇数条 $2$ 边。而**连偶数条 $2$ 边的点数一定为偶数**，怎么证明呢？

考虑分类讨论。当一条 $2$ 边加入时：

若当前两个端点度数为奇数，奇数。则加完后度数变为偶数，偶数。点数变化为 $2$。

若当前两个端点度数为偶数，偶数。则加完后度数变为奇数，奇数。点数变化为 $2$。

若当前两个端点度数为奇数，偶数。则加完后度数变为偶数，奇数。点数不变。

发现变化量都是偶数，故最后结果肯定也是偶数。解决了这个问题后，同样跑一遍欧拉回路就可以了。

例如样例的一种解法：

![](https://cdn.luogu.com.cn/upload/image_hosting/8lv3cg9o.png)

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e7+5;
struct edge{
	int to,nxt,ans,w;
}e[N<<1];
int n,m,cnt=1,head[N],d[N],nxt[N<<1],fst[N][3];
inline int read(){
	int x=0,f=0;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return f?-x:x;
}
void add(int u,int v,int w){
	d[v]++;
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	e[cnt].ans=-1;
	e[cnt].w=w;
	nxt[cnt]=fst[u][w];
	head[u]=cnt;fst[u][w]=cnt;
}
void dfs(int u,int lst){
	while(fst[u][lst]&&e[fst[u][lst]].ans!=-1)fst[u][lst]=nxt[fst[u][lst]];
	if(!fst[u][lst])lst=(lst==1)?2:1;
	while(fst[u][lst]&&e[fst[u][lst]].ans!=-1)fst[u][lst]=nxt[fst[u][lst]];
	if(!fst[u][lst])return;
	int now=fst[u][lst];
	fst[u][lst]=nxt[fst[u][lst]];
	e[now].ans=0;e[now^1].ans=1;
	dfs(e[now].to,lst);
	for(int i=head[u];i;i=e[i].nxt){
		head[u]=e[i].nxt;
		if(e[i].ans==-1)e[i].ans=0,e[i^1].ans=1,dfs(e[i].to,e[i].w);
	}
}
int main(){
	freopen("data.in","r",stdin);
	freopen("data.out","w",stdout); 
	n=read();m=read();
	for(int i=1;i<=m;i++){
		int u,v,w;u=read();v=read();w=read();
		add(u,v,w);add(v,u,w);
	}
	for(int i=1;i<=n;i++){
		if(d[i]%2==1){
			add(n+1,i,1);add(i,n+1,1);
		}
	}
	dfs(1,1);
	for(int i=1;i<=m;i++)cout<<e[i*2].ans;
}
//checker.exe data.in data.out data.out

```


---

## 作者：Warriors_Cat (赞：0)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P7816)。

题意：

* 给定一个 $n$ 点 $m$ 边的无向图，边权为 $1$ 或 $2$，可能有重边或自环，但保证每个点连出的边权值之和为奇数。

* 求一个所有边定向的方案，使每个点入边权值之和与出边权值之和的差的绝对值为 $1$。

* $1 \le n \le 10^6$，$1 \le m \le 3\times10^6$。

用了一种码量较大但几乎不用脑子的方法。

---

Solution：

我们尝试一种类似于归纳构造的方法。

称一个无向图 $G$ 为好图，若 $G$ 中的所有边可以定向使得题目要求满足。实际上我们可以证明满足题设条件的图一定存在一个合法的构造方案。

注意到如下事实：对 $G$ 中某一个点 $u$ 连出的两条边 $ux, uy$，且它们的权值均为 $w \in\{1, 2\}$，将这两条边删除，添上边 $xy$ 并赋予权值 $w$，得到图 $G'$，那么当 $G'$ 为好图时，$G$ 也是好图。证明就是直接把 $xy$ 的定向通过 $u$ 转折一次即可，此时 $u$ 处入权多了 $w$，出权也多了 $w$，并没有任何影响。

同时这种操作具有两个很重要的性质：**不改变每个点连出边权值之和的奇偶性，且每个点的度单调不增。**

再注意到两条边若为重边（权值也要相同）可以直接定相反方向并删去，自环可以随便定向，故我们一直操作直至不可继续时可以得到一个图 $H$，其中每个点至多连出 $1$ 条 $1$ 权边和 $1$ 条 $2$ 权边，并且没有重边自环。由于 $H$ 中每个点的度都不大于 $2$，故 $H$ 的每个连通分支要么是一条链，要么是一个环，而且链的边权依次必为 $1, 2, \cdots, 1, 2, 1$，环的边权依次必为 $1, 2,\cdots, 1, 2$，很显然我们这个连通分支的每条边定相同的向即可。因此 $H$ 为好图，从而原图 $G$ 必为好图。

具体构造就按部就班得来，我们建立一个辅助图 $T$，$T$ 中首先有 $m$ 个节点表示 $G$ 中的 $m$ 条边，如果 $ux$ 和 $uy$ 合并为了 $xy$，那么在 $T$ 中新建一个节点表示 $xy$ 并向 $ux$ 和 $uy$ 连边。重边直接定向。不难发现最终 $T$ 为二叉树森林，并且每个连通分支中的根节点均为图 $H$ 中的边。图 $H$ 的边直接 dfs 定向，然后对 $T$ 的每个根节点在 $T$ 中 dfs 一次，就可以得到所有边的定向。

因为每个点的度单调不增，所以我们直接依次对每个点看一下连出的 $1$ 权边和 $2$ 权边即可。

over，时间复杂度为 $O(n+m)$，但常数有点大。

顺便膜拜[一篇题解](https://www.luogu.com.cn/blog/208529/solution-p7816)中的欧拉回路构造，精巧不少。

---

Code：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <queue>
#include <map>
#include <set>
using namespace std;
#define ll long long
#define ull unsigned long long
#define ld long double
#define fi first
#define se second
#define dingyi int mid = l + r >> 1, ls = p << 1, rs = p << 1 | 1
#define y0 y_csyakioi_0
#define y1 y_csyakioi_1
#define rep(i, x, y) for(int i = x; i <= y; ++i)
#define per(i, x, y) for(int i = y; i >= x; --i)
#define repg(i, u) for(int i = head[u]; i; i = e[i].nxt)
#define mpr make_pair
inline int read(){
    int x = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
    return x * f;
}
const int N = 3000010;
struct edge{
	int v, w, nxt;
}e2[N << 1];
struct edg{
	int u, v;
}e[N << 1];
int n, m, x, y, z, cnt, deg1[N], deg2[N], ans[N << 1];
bool vis[N << 1], visit[N], gd[N << 1];
vector <int> v1[N], v2[N];
queue <int> q;
int head1[N << 1], head2[N << 1], cnt1, cnt2, deg[N];
int son[N << 1][2];
inline bool check(int x){
	return deg1[x] >= 2 || deg2[x] >= 2;
}
vector <int> :: iterator it;
inline int ano(int id, int u){
	if(e[id].u == u) return e[id].v;
	else return e[id].u;
}
inline void add2(int u, int v, int w){
	e2[++cnt2].v = v; e2[cnt2].w = w;
	e2[cnt2].nxt = head2[u]; head2[u] = cnt2;
}
inline void dfs(int u, int lst, int anc){
	visit[u] = 1;
	for(int i = head2[u]; i; i = e2[i].nxt){
		int v = e2[i].v, w = e2[i].w;
		if(w == lst) continue;
		if(visit[v] && v != anc) continue;
		if(e[w].u == u) ans[w] = 1;
		else ans[w] = 2;
		if(v == anc) continue;
		dfs(v, w, anc);
	}
}
inline void mian(){
	n = read(); m = read(); 
	rep(i, 1, m){
		x = read(); y = read(); z = read();
		e[++cnt].u = x; e[cnt].v = y;
		if(x == y){ ans[cnt] = vis[cnt] = 1; continue; }
		if(z == 1){
			++deg1[x], ++deg1[y];
			v1[x].push_back(cnt);
			v1[y].push_back(cnt);
		}
		else{
			++deg2[x], ++deg2[y];
			v2[x].push_back(cnt);
			v2[y].push_back(cnt);
		}
	}
	x = 0;
	rep(u, 1, n){
		if(deg1[u] >= 2){
			for(it = v1[u].begin(); it != v1[u].end(); ++it){
				int id = (*it);
				if(vis[id]) continue;
				if(x == 0){ x = id; continue; }
				else{
					deg1[u] -= 2;
					vis[x] = vis[id] = 1;
					int v = ano(x, u), w = ano(id, u);
					if(v == w){
						if(e[x].u == u) ans[x] = 1; else ans[x] = 2;
						if(e[id].u == u) ans[id] = 2; else ans[id] = 1;
					}
					else{
						e[++cnt].u = v; e[cnt].v = w;
						v1[v].push_back(cnt); v1[w].push_back(cnt);
						son[cnt][0] = x; son[cnt][1] = id;
					}
					x = 0;
				}
			}
		}
		x = 0;
		if(deg2[u] >= 2){
			for(it = v2[u].begin(); it != v2[u].end(); ++it){
				int id = (*it);
				if(vis[id]) continue;
				if(x == 0){ x = id; continue;}
				else{
					deg2[u] -= 2;
					vis[x] = vis[id] = 1;
					int v = ano(x, u), w = ano(id, u);
					if(v == w){
						if(e[x].u == u) ans[x] = 1; else ans[x] = 2;
						if(e[id].u == u) ans[id] = 2; else ans[id] = 1;
					}
					else{
						e[++cnt].u = v; e[cnt].v = w;
						v2[v].push_back(cnt); v2[w].push_back(cnt);
						son[cnt][0] = x; son[cnt][1] = id;
					}
					x = 0;
				}
			}
		}
		x = 0;
	}
	puts("");
	rep(i, 1, cnt) if(!vis[i]){
		int u = e[i].u, v = e[i].v; gd[i] = 1;
		add2(u, v, i); add2(v, u, i);
		++deg[u]; ++deg[v];
	}
	rep(u, 1, n) if(deg[u] == 1 && !visit[u]) dfs(u, 0, u);
	rep(u, 1, n) if(!visit[u]) dfs(u, 0, u);
	rep(i, 1, cnt) if(ans[i]) q.push(i);
	while(!q.empty()){
		int a = q.front(); q.pop();
		int b = son[a][0], c = son[a][1];
		if(!b || !c) continue;
		if(e[b].u == e[a].u) ans[b] = ans[a]; else ans[b] = 3 - ans[a];
		if(e[c].v == e[a].v) ans[c] = ans[a]; else ans[c] = 3 - ans[a];
		q.push(b); q.push(c);
	}
	rep(i, 1, m) printf("%d", ans[i] - 1);
	return;
}
int main(){ int qwq = 1; while(qwq--) mian(); return 0; }
```


---


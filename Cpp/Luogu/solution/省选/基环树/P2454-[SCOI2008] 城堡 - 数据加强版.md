# [SCOI2008] 城堡 - 数据加强版

## 题目背景

[原题弱化版](https://www.luogu.com.cn/problem/P2538)

## 题目描述

在一个国家里，有 $n$ 个城市（编号为 $0$ 到 $n-1$）。这些城市之间有 $n$ 条双向道路相连（编号为 $0$ 到 $n-1$），其中编号为 $i$ 的道路连接了城市 $i$ 和城市 $r_i$（一条道路可以连接一个城市和它自身），长度为 $d_i$。$n$ 个城市中有 $m$ 个拥有自己城堡，可以抵御敌人侵略。如果没有城堡的城市遭受攻击，则离它最近的城堡将派兵前往救援。

你的任务是在不超过 $k$ 个没有城堡的城市中建立城堡，使得所有城市中“离最近城堡的距离”的最大值尽量小。换句话说，若令 $dist(c)$ 表示城市 $c$ 的最近城堡离它的距离，则你的任务是让 $\max\{dist(c)\}$ 尽量小。

输入数据保证存在方案使得对于每个城市，至少有一个城堡能够到达。

## 说明/提示

$100\%$ 的数据满足：$1\leq d_i\leq 10^5$，$0\leq m\leq n-k$。

- Subtask 1：$2 \leq n \leq 3000$。
- Subtask 2：$2 \leq n \leq 10^5$。

## 样例 #1

### 输入

```
5 0 1
1 2 3 4 0
1 1 1 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
3 1 1
1 2 0
1 2 3
2```

### 输出

```
1```

## 样例 #3

### 输入

```
2 1 1  
0 1  
1 1  
1```

### 输出

```
0```

## 样例 #4

### 输入

```
10 3 3
0 2 0 0 2 2 8 3 8 7
10 9 1 8 1 3 7 2 8 1
3 4 6```

### 输出

```
3```

## 样例 #5

### 输入

```
2 0 1
1 0
5 10```

### 输出

```
5```

# 题解

## 作者：iyaang (赞：2)

[逆天的阅读体验](https://www.cnblogs.com/LittleTwoawa/p/17799233.html)

[题目链接](https://www.luogu.com.cn/problem/P2454)

应该是联赛前最后一次任性了，浪费的时间有点多，不过也揭露了我的基础知识和代码能力都很弱的问题，得加油啊。

先 sto dwt。

给定一棵基环树森林，起初有 $m$ 个点已被选进 $S$ 里，你需要再选 $k$ 个点加入到 $S$ 中，最小化其余点到 $S$ 距离的最大值。

这个问题直接做非常困难，考虑二分答案转成判定性问题：选定若干个点能够使得所有点到 $S$ 的距离不超过目前二分的答案 $F$。如果一个节点距离 $S$ 中的点不超过 $F$，称其为**被覆盖了**。

基环树的题自然是树和环分开考虑，依然要预处理记好在环上的点和环上点之间的距离。如果放在树上，原题是[这个](https://www.luogu.com.cn/problem/P3523)，在基环树的树部分依然采用相同的 DP 方式，这个 DP 也是基于贪心的：能不放就不放。设 $f_{u}$ 表示以 $u$ 为根的子树中离 $u$ 最远的没被覆盖的节点到 $u$ 的距离；$g_{u}$ 以 $u$ 为根的子树中在 $S$ 中的离 $u$ 最近的节点到 $u$ 的距离，那么初值为 $f_{u} = 0,g_{v} = \infty$，转移方程为 $f_{u} = \max_{v \in son_{u}} \{ f_{v} \} + 1,g_{u} = \min_{v \in son_{u}} \{ g_{v} \} + 1$。接下来考虑一些边界情况：

- 如果当前点 $u$ 本身就在 $S$ 中，有 $g_{u} = 0$，原因显然。
- 如果 $f_{u} + g_{u} \leq F$，这说明用 $u$ 子树中的 $S$ 中的点就可以覆盖整棵 $u$ 的子树，$u$ 对 $u$ 的祖先们没有决策影响了，那么 $f_{u} = -\infty$。
- 如果 $f_{u} + (u,fa_{u}) > F$，如果 $u$ 点不选入到 $S$ 中，那么距离 $u$ 最远的那个未覆盖节点就要不合法了，所以必须将 $u$ 选入到 $S$ 中，那么 $f_{u} = -\infty,g_{u} = 0$，同时选点数量计数器要加一。

对于环上每个点为根做一遍这个树形 DP，可以得到树中最少需要选多少个点，以及根据根节点 $i$ 的 $f_{i}$ 值和环上边长来知道必须要在环上的某一段区间内选点进入 $S$ 才能使得 $i$ 子树内的和 $i$ 距离最大的未被覆盖的节点合法。特别的，如果环上存在一个节点 $j$，使得 $f_{i} + g_{j} + dis_{i \to j} \leq F$，即用 $j$ 子树中的离 $j$ 最近的 $S$ 中的点来覆盖 $i$ 中的点，那么对于 $i$ 就不会存在环上的这段选择区间。这一部分的形态形如寻找前后缀 $a \pm b$ 的最小值，可以用前缀 $\min$ 线性解决。找环上的需要被覆盖的区间可以先算出最深的不合法节点到根节点的距离，然后推出在环上的延伸距离，由于我们预先处理好了环上边权的前缀和，就可以在前缀和上做一个二分查找来找到区间的左右端点。

解决上述步骤之后，现在问题转化成了在环上有若干个区间，每个区间至少选一个点，问最少要选多少个点。由于起初的 $m$ 个点有一些可能在环上，先把这些点能满足的区间去掉。然后可以运用[这个题](https://www.luogu.com.cn/problem/P4155)的套路，加入当前选择了一个位置 $i$，能够发现下一个选择的节点一定是左端点大于这个节点，且右端点最靠左的那个区间的右端点，可以用单指针线性求出从位置 $i$ 开始下一个选择的位置在哪里，然后预处理倍增数组 $st_{i,j}$ 表示选择了位置 $i$，下 $2^j$ 个位置选在哪里，枚举哪个节点作为第一个选择的节点，倍增的算接下来总共在环上要选几个点，于是这样就 $\mathcal O(n \log n)$ 的解决这个部分了。

让我们梳理一下整个算法流程：首先预处理环上节点，断环成链并记录环上边权前缀和；然后开始二分答案，对于一棵基环树，先树形 DP 算出树部分最少需要放置的点以及能够覆盖到的环上的区间，然后倍增搭配贪心完成环上的选取；用所有基环树需要选取的点的数量总和来判断是否满足当前二分出的答案。因为要特殊处理二元环和自环的环上边权，我的代码中选择了使用 map 来解决这个问题。

综上，总复杂度我们做到了 $\mathcal O(n \log n \log V)$。但是这个东西实际跑起来非常缓慢，瓶颈主要在于倍增数组的初始化，更改倍增数组的类型可以起到很好的优化效果，同时这也说明了卡满这个做法的方法是一整个圈。还有一些卡常技巧也可以相应的使用，我的代码常数并不优秀，但 $10^5$ 的数据还是跑到了一秒左右。[代码在这里](https://www.luogu.com.cn/paste/batvhdsg)。

---

## 作者：StayAlone (赞：0)

好难写，肝了好久……

相比另一篇题解，侧重于环上的处理，并给出一些更细节的阐述和证明。

先二分答案 $T$，基环树的问题考虑环上和树上分开做，树上直接沿用 [P3523](https://www.luogu.com.cn/article/fhrkkd6l) 的贪心，唯一的区别是本题边权不全为 $1$，因而边权的变化不连续，贪心时若某子树 $x$ 内未被覆盖的最远点到 $x$ 的父亲的距离超过 $T$，则强制选择 $x$，累加计数器。另外题意中本身强制要求选的点当然也要选上。贪心结束后，只有环上的点未确定是否选择。

接下来考虑环。贪心时我们记录了 $f_i, g_i$ 分别表示 $i$ 子树内最远的未覆盖点，$i$ 子树内选择的最浅点。对于环上的点 $i, j$，若存在 $f_i+g_j+dis_{i, j}\le T$，意味着 $i$ 这个点可以被 $j$ 子树内某点覆盖。

排除上述情况后，只需考虑在环上选点。对于环上某点 $i$，限制形如需要在环上一段区间内至少选择一个点，该区间可以二分求出。容易证明最优的覆盖方案中，一定存在环上某条**边**未被覆盖，因此可以破环成链。这里有一些细节。

为了方便，叙述时将环上的点按 $1\sim n$ 编号。则现在是一条长度 $2n$ 的链。

- 若一个点的区间能覆盖整个环，特判。除此之外的区间长度不可能超过 $n$。
- 若可以 $i\to\cdots\to 1\to n$，将这个区间放置在跨过 $[n, n + 1]$ 的位置即可。
- 否则，找到的区间 $[l, r]$ 满足 $[l, r]\subseteq [1, n]$。则插入区间 $[l, r]$ 和 $[l+n,r+n]$。

接下来，枚举 $i\in[1, n]$，钦定 $i$ 点必选，求最小选择点数。这样处理后，可以宣称我们只在意右端点落在 $[i, i+n)$ 的区间：

- 若某区间的右端点 $p$ 小于 $i$，则区间 $[q, p]\subseteq [1, n]$，一定插入了区间 $[q + n, p+n]$，同时显然有 $p+n\in[i, i+n)$。
- 否则，该区间右端点 $p\geq i+n$。若左端点也满足 $q\geq i+n$，则区间 $[q-n,p-n]$ 一定被考虑；否则，$i+n\in[q, p]$，同时注意到 $i$ 点必选，即 $i+n$ 必选，故该区间一定被满足。

当 $i$ 点必选，选择的下一个点就是左端点大于 $i$ 的区间中，右端点最小的点。这个策略是固定的，可以倍增优化。

总时间复杂度 $\mathcal O(n\log n\log V)$。随便写了一发就最优解了，不过代码还有很大优化空间。

[AC record](https://www.luogu.com.cn/record/217919046)

```cpp
int n, m, k, cnt, vis0[MAXN], vis[MAXN], fx0[MAXN], fx[MAXN], r0[MAXN], w0[MAXN], deg[MAXN]; ll t, f[MAXN], g[MAXN];
int tot, pnt[MAXN], mii[MAXN], st[20][MAXN]; const ll inf = 1e15;

struct edge {
    int nxt, to, w;
} E[MAXN];

il void add(const int &x, const int &y, const int &w) {
    E[++tot].nxt = pnt[x]; E[tot].to = y; E[tot].w = w; pnt[x] = tot;
    E[++tot].nxt = pnt[y]; E[tot].to = x; E[tot].w = w; pnt[y] = tot;
    ++deg[x]; ++deg[y];
}

il void dfs(int x, int p, int pw = 1) {
    f[x] = -inf, g[x] = inf;
    for (int i = pnt[x]; i; i = E[i].nxt) {
        int v = E[i].to, w = E[i].w;
        if (v == p || vis[v]) continue;
        dfs(v, x, w), gmax(f[x], f[v] + w), gmin(g[x], g[v] + w);
    }
    if (fx[x]) f[x] = -inf, g[x] = 0;
    if (f[x] + g[x] <= t) f[x] = -inf;
    if (g[x] > t) gmax(f[x], 0ll);
    if (f[x] + pw > t) f[x] = -inf, g[x] = 0, ++cnt, !p && (fx0[x] = 1);
}

struct cycle {
    int crt; vector <int> rt, cvd, sfx;
    vector <pii> seg; vector <ll> sum;

    il void init(int p) {
        int g = p; rt.eb(0); rt.eb(g); g = r0[g];
        while (g != p) rt.eb(g), g = r0[g];
        crt = rt.size() - 1; cvd.resize(rt.size());
        rep1(i, 1, crt) rt.eb(rt[i]), vis0[rt[i]] = 0;
        sum.resize(rt.size()); sfx.resize(rt.size());
        rep1(i, 2, crt << 1) sum[i] = sum[i - 1] + w0[rt[i - 1]], sfx[i] = sfx[i - 1] + fx[rt[i]];
    }

    il int calc() {
        cnt = 0;
        rep1(i, 1, crt << 1) fx0[rt[i]] = fx[rt[i]];
        rep1(i, 1, crt) dfs(rt[i], cvd[i] = 0);
        rep1(i, 2, crt << 1) sfx[i] = sfx[i - 1] + fx0[rt[i]];
        ll pre = inf;
        rep1(i, 1, crt << 1) {
            gmin(pre, g[rt[i]] - sum[i]);
            if (pre <= t - f[rt[i]] - sum[i]) i > crt ? (cvd[i - crt] = 1) : (cvd[i] = 1);
        } pre = -inf;
        rep2(i, crt << 1, 1) {
            gmax(pre, t - g[rt[i]] - sum[i]);
            if (pre >= f[rt[i]] - sum[i]) i > crt ? (cvd[i - crt] = 1) : (cvd[i] = 1);
        }
        auto findl = [&](int p, int k) {
            int l = 1, r = p;
            while (l ^ r) {
                int mid = l + r >> 1;
                if (sum[p] - sum[mid] <= k) r = mid;
                else l = mid + 1;
            } return l;
        };
        auto findr = [&](int p, int k) {
            int l = p, r = crt << 1;
            while (l ^ r) {
                int mid = l + r + 1 >> 1;
                if (sum[mid] - sum[p] <= k) l = mid;
                else r = mid - 1;
            } return l;
        };
        rep1(i, 1, crt) if (!cvd[i]) {
            ll mored = t - f[rt[i]];
            if (mored * 2 >= sum[crt + 1]) seg.eb(1, crt), seg.eb(crt + 1, crt << 1);
            else if (sum[i] + w0[rt[crt]] > mored) {
                auto it = mp(findl(i, mored), findr(i, mored)); seg.eb(it);
                if (it.snd > crt) continue;
                seg.eb(it.fst + crt, it.snd + crt);
            } else seg.eb(findl(i + crt, mored), findr(i + crt, mored));
        } bool flg = 1;
        rep1(i, 1, crt << 1 | 1) mii[i] = n << 1 | 1;
        for (auto [l, r] : seg) {
            if (sfx[r] - sfx[l - 1]);
            else gmin(mii[l], r), flg = 0;
        }
        if (flg) return cnt;
        rep2(i, crt << 1, 1) gmin(mii[i], mii[i + 1]);
        int kt = __lg(crt);
        rep1(i, 1, crt << 1) st[0][i] = mii[i + 1];
        rep1(i, 1, kt) rep1(j, 1, (crt << 1) - (1 << i) + 1) st[i][j] = st[i - 1][st[i - 1][j]];
        int res = 1e9;
        rep1(i, 1, crt) if (!cvd[i]) {
            int now = 0, pos = i;
            rep2(j, kt, 0) if (st[j][pos] < i + crt) now |= 1 << j, pos = st[j][pos];
            gmin(res, now + 1);
        } seg.clear();
        rep1(i, 1, kt) rep1(j, 1, (crt << 1) - (1 << i) + 1) st[i][j] = st[i - 1][st[i - 1][j]];
        return res + cnt;
    }
}; vector <cycle> cys;

il bool check(ll x) {
    t = x; int now = 0;
    for (auto v : cys) if ((now += v.calc()) > k) return false;
    return true;
}

int main() {
    read(n, m, k); rer(i, 1, n, r0);
    rep1(i, 1, n) add(i, ++r0[i], w0[i] = read()), vis[i] = 1;
    rep1(i, 1, m) fx[read() + 1] = 1;
    queue <int> q;
    rep1(i, 1, n) if (deg[i] == 1) q.emplace(i);
    while (q.size()) {
        int x = q.front(); q.pop();
        vis[x] = 0;
        for (int i = pnt[x]; i; i = E[i].nxt) {
            int v = E[i].to, w = E[i].w;
            if (--deg[v] == 1) q.emplace(v); 
        }
    }
    rep1(i, 0, 19) rep1(j, 1, n << 1 | 1) st[i][j] = n << 1 | 1;
    rep1(i, 1, n) vis0[i] = vis[i];
    rep1(i, 1, n) if (vis0[i]) {
        cycle now; now.init(i); cys.eb(now);
    } ll l = 0, r = 1e10;
    while (l ^ r) {
        ll mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    } printf("%lld", l);
    return 0;
}
```

---


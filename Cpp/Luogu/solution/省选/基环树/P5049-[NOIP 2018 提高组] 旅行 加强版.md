# [NOIP 2018 提高组] 旅行 加强版

## 题目描述

小 Y 是一个爱好旅行的 OIer。她来到 X 国，打算将各个城市都玩一遍。 
  
小Y了解到，X 国的 $n$ 个城市之间有 $m$ 条双向道路。每条双向道路连接两个城市。 不存在两条连接同一对城市的道路，也不存在一条连接一个城市和它本身的道路。并且， 从任意一个城市出发，通过这些道路都可以到达任意一个其他城市。小 Y 只能通过这些 道路从一个城市前往另一个城市。   

小 Y 的旅行方案是这样的：任意选定一个城市作为起点，然后从起点开始，每次可 以选择一条与当前城市相连的道路，走向一个没有去过的城市，或者沿着第一次访问该 城市时经过的道路后退到上一个城市。当小 Y 回到起点时，她可以选择结束这次旅行或 继续旅行。需要注意的是，小 Y 要求在旅行方案中，每个城市都被访问到。   

为了让自己的旅行更有意义，小 Y 决定在每到达一个新的城市（包括起点）时，将 它的编号记录下来。她知道这样会形成一个长度为 $n$ 的序列。她希望这个序列的字典序 最小，你能帮帮她吗？  对于两个长度均为 $n$ 的序列 $A$ 和 $B$，当且仅当存在一个正整数 $x$，满足以下条件时， 我们说序列 $A$ 的字典序小于 $B$。 
  
- 对于任意正整数 $1 ≤ i < x$，序列 $A$ 的第 $i$ 个元素 $A_i$ 和序列 $B$ 的第 $i$ 个元素 $B_i$ 相同。   
- 序列 $A$ 的第 $x$ 个元素的值小于序列 $B$ 的第 $x$ 个元素的值。 

## 说明/提示

【数据规模与约定】   

对于 $100\%$ 的数据和所有样例， $1 \le n \le 500000 $ 且 $m = n - 1$ 或 $m = n$ 。

具体规定详见正常版本（除 testcase11-13）

## 样例 #1

### 输入

```
6 5 
1 3 
2 3 
2 5 
3 4 
4 6```

### 输出

```
1 3 2 5 4 6```

## 样例 #2

### 输入

```
6 6 
1 3 
2 3 
2 5 
3 4 
4 5 
4 6```

### 输出

```
1 3 2 4 5 6```

# 题解

## 作者：duoluoluo (赞：92)

## 题意

题意很简单，即在一张图上一边跑一边记录当前所在节点的大小，不能走已经经过的点，但是可以回溯，最后输出字典序最小的编号序列。

## 分析

- ### $m = n - 1$

这种情况不用多说，直接跑一遍$DFS$就行啦！

- ### $m = n$

大家应该很清楚这个情况会使图中出现一个环。

那要怎么解决呢？想想是不是你在这个环上跑到一半，另一半通过回溯到你刚到这个环的起点，再接着$DFS$就行了。

![样例](https://cdn.luogu.com.cn/upload/pic/71799.png)

举个样例$2$的例子：

很明显$2 - 3 - 4 - 5$是图上的环。

最开始从$1$节点出发，那么$3$就是我们第一次到这个环的起点。

接着我们向$2$走，之后便回溯到起点$3$，$3$再向$4$走，最后跑完整张图就行了，因为接下来就没有环需要我们特殊处理了。

这个过程应该很好理解，现在我们知道$m = n$情况下只需要处理在环上的点，其他的点还是像$m = n - 1$一样$DFS$就好了，同时如果在环上回溯之后（如上图$2$回溯到$3$），剩下的过程也不需要特殊处理了。

那么现在的关键就是解决在环上的特殊处理。

我们把在环上的点分成三种情况：

#### 一、其出边为环上的那个点编号是其所有未被访问的出边中最小的，如下图。

从$1$出发经过$2$到达$3$，此时从$3$出发能访问的出边有$4, 6, 7$，其中$4$是环上的点，同时也是最小。

![图1](https://cdn.luogu.com.cn/upload/pic/71801.png)



------------


#### 二、其出边为环上的那个点编号是其所有未被访问的出边中不是最大也不是最小的，如下图。

此时$6$是环上的点，但不是最大也不是最小的出边。

![图2](https://cdn.luogu.com.cn/upload/pic/71808.png)



------------


#### 三、其出边为环上的那个点编号是其所有未被访问的出边中最大的，如下图。

此时$7$是最大的出边也是环上的点。

![图3](https://cdn.luogu.com.cn/upload/pic/71804.png)



------------



#### 对于第一种情况（见下图）：

由于我们现在在$3$这个节点，如果我们回溯的话，$6$和$7$就永远也到不了了，所以在回溯之前要先把$6$和$7$走完，相比$6$和$7$，走$4$显然会更优。

所以第一种情况不需要回溯，继续在环上走就行了。

![图1](https://cdn.luogu.com.cn/upload/pic/71801.png)



------------


#### 对于第二种情况（见下图）：

同样还是在$3$节点，这次显然我们要先走$4$，但是走完$4$还是得走$6$节点，同样也不需要回溯。

![图2](https://cdn.luogu.com.cn/upload/pic/71808.png)



------------


#### 对于第三种情况（见下图）：

这时候很明显是要回溯的了。

需要注意的是回溯之前要先把$4$和$6$先走了再回溯（原因上面刚讲过了）。

#### 但是，如果我们换张图，还需要回溯吗？（见下下图）

![图3](https://cdn.luogu.com.cn/upload/pic/71804.png)



------------


这张图中，我们假设当前还是在$3$节点，$6$是其出边中最大且在环上的点。

这时候需不需要回溯呢？很显然不需要

因为回溯之后回到了$2$，$2$继续走的话是走到了$7$，显然走$6$比起$7$更优。

![图4](https://cdn.luogu.com.cn/upload/pic/71814.png)



------------


总结一下，我们在环上走的时候，只有当其出边中，为环上的那个点编号最大，且比回溯后第一个走的点还大，这时候才回溯，其他时候就正常跑$DFS$。

因此在代码上我用了$flag$来标记是否需要回溯，用$tmp$记录当前节点中第一个比环上的出边那个节点还要大的节点，以便后面判断是否回溯时比较。

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <stack>
#include <queue>
#include <cstring>
#include <vector>
using namespace std;
const int N = 500010;
int n, m, vis[N], ans[N], cnt, f[N], rings[N], flag, tmp, temp, head[N], ver[N << 1], nex[N << 1], tot;
struct Node {
	int x, y;
}node[N << 1];
void add (int x, int y) {
    ver[++ tot] = y;
    nex[tot] = head[x];
    head[x] = tot;
}
bool cmp (Node a, Node b) {
	return a.y > b.y;
}
inline int read () {
    int res = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9') ch = getchar();
    while (ch >= '0' && ch <= '9') {
        res = (res << 3) + (res << 1) + (ch - 48);
        ch = getchar();
    }
    return res;
}
void dfs (int x) {
    vis[x] = 1;
    ans[++ cnt] = x;
    for (int i = head[x]; i; i = nex[i]) {
        int y = ver[i];
        if (!vis[y])
            dfs(y);
    }
}
void dfsRing (int x, int fa) {
    if (flag) return;
    if (f[x] == 0) {
        f[x] = fa;
    }else if (f[x] != fa) {
        while (fa != x) {
            rings[fa] = 1;
            fa = f[fa];
        }
        rings[x] = 1;
        flag = 1;
        return;
    }
    for (int i = head[x]; i; i = nex[i]) {
        int y = ver[i];
        if (y == fa) continue;
        dfsRing(y, x);
    }
}
void sDfs (int x) {
    vis[x] = 1;
    ans[++ cnt] = x;
    if (rings[x]) { //判断x是否在环上 
    	int flag = 0;
    	for (int i = head[x]; i; i = nex[i]) {
    		if (temp) break; //temp标记环上的回溯是否执行过了，因为一旦执行过环上的回溯，那么后面就不需要在环上回溯，只需正常跑DFS即可 
    		int y = ver[i];
    		if (vis[y]) continue;
    		if (rings[y]) {
    			i = nex[i];
    			while (vis[ver[i]]) //已经被访问过的节点跳过 
    				i = nex[i];
    			if (i) //i不为0即环上的出边不是最大的出边 
    				tmp = ver[i]; //tmp记录第一个比环的出边大的那个点 
    			else if (y > tmp) { //环上的出边是最大的出边且比我们回溯后第一次要走的节点还大 
    				flag = 1;
    				temp = 1;
				}
    			break;
			}
		}
		for (int i = head[x]; i; i = nex[i]) {
			int y = ver[i];
			if (vis[y]) continue;
			if (rings[y] && flag) continue; //flag = 1，因此回溯，不再走环上的出边 
			sDfs(y);
		}
	} else {
		for (int i = head[x]; i; i = nex[i]) {
			int y = ver[i];
			if (vis[y]) continue;
			sDfs(y);
		}
	}
}
int main () {
    n = read();
    m = read();
    for (int i = 1; i <= m; i ++) {
        int u = read(), v = read();
        node[i].x = u;
        node[i].y = v;
        node[i + m].x = v;
        node[i + m].y = u;
    }
    sort(node + 1, node + 2 * m + 1, cmp);
    for (int i = 1; i <= 2 * m; i ++)
    	add(node[i].x, node[i].y);
    if (m == n - 1) {
        dfs(1);
        for (int i = 1; i <= n; i ++)
            printf("%d ", ans[i]);
    }else {
        dfsRing(1, 1); //一开始先找出所有在环上的点 
        flag = 0;
        tmp = 0x3f3f3f3f;
        sDfs(1);
        for (int i = 1; i <= n; i ++)
            printf("%d ", ans[i]);
    }
    return 0;
}
```












---

## 作者：little_gift (赞：47)

事实上我也不知道为什么完全$O(n^2)$可过的题我考场要写$O(n \log n)$

~~而且还写挂了~~

**以下是考场思路有错误请批评指正**

------

$m=n-1$, 即树的情况因为只有一种走法(不能回溯)所以直接按字典序最小走即可.

具体代码实现的时候我是先读入了所有的边然后把它们按到达点的大小排序然后一条一条插入.

最后$dfs$的时候直接按边的顺序走即可.

注意链表存图是倒着的所以加边也要反过来.

------

显然此题的难点在于基环树.

因为对于基环树上的环, 可以选择先从一端进入, 走到某一个点时返回, 然后再从另一端进入.

首先还是对所有边排序然后依序插入.

对于基环树可以先找环.

于是我写了一个$dfs$标记了一下环的"根"(即$dfs$时深度最浅的点)以及环的"根"中在环上的两个孩子节点($u1, u2$, 满足$u1 < u2$).

这个可以乱写解决(当然$tarjan$应该也没有问题).

然后我就开始写~~走路~~旅行的过程.

首先是想到对于环从$u1$进去.

那么很显然这个是错的因为根本没有回溯的过程.

(回溯是指从环中的某一个点回到环的根, 其中**要经过环上的点出发的还没有走过的点**)

那么考虑如何回溯.

假设现在正在环上的某个点$u$, 下一个将要走到$v$.

那么只有**当$u$和$v$都在环上并且$u2$还没有走到过, $v$是$u$出发的最后一个点且$v$比$mx$大**时进行回溯

$mx$是指如果从$u$开始回溯时下一个会走到的点的编号.

那么如果$v$比$mx$大, 此时回溯肯定比继续走更优, 而因为之前都没有回溯, 所以此时回溯就是最优的.

判断$u2$没有走到过就是相当于判断此时是否还能够回溯(如果$u2$已经走到了那么回溯完全没有意义了).

为什么要保证$v$是$u$出发的最后一个点呢?

因为插入边的时候是按大小排序的, 如果$v$后面还有点的话那么那个点的编号一定比$v$大.

而如果此时(走到$v$前)回溯, 则下一个点必须是$v$后面的点(否则这个点(及子树)将无法到达)

而这个点是比$v$大的所以回溯不是最优的.

换句话说此时的$mx$就是$v$后面的点, $mx>v$, 所以不能回溯.

那么如何更新$mx$呢?

对于某一次从$u$到$v$进行的$dfs$, 如果$v$的后面还有节点, 那么$mx$就是$v$后面的节点的值(如果回溯的话那么下一个必须经过$v$后面的节点, 否则这个节点将会无法到达), 否则就是原本的$mx$.

然后……好像就可以了?

现在看这份代码好像有很多不必要的判断, 也有很多可以改进的地方.

但是不管怎么样考场上都没有过掉呢.

我们发现上面提到了一个取$v$后面一个节点的值的操作.

然后因为存这棵树/基环树的时候存的是双向边.

所以不能简单地取下一个点, 而是要判断下一个点是否已经走过了.

~~成功被卡到84~~

另外考场代码真的不怎么好看……见谅.

总复杂度$O(n\log n)$.

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cassert>
struct _ {
    int u, v;
    _(const int& u = 0, const int& v = 0) : u(u), v(v) {}
} e[1000001];
struct __ {
    bool operator()(const _& a, const _& b) {
        return a.v < b.v;
    }
} cmp; //按照到达点的标号比较
int h[500001], to[1000001], nxt[1000001], cnt;
inline void add_edge(const int& u, const int& v) {
    to[++cnt] = v; nxt[cnt] = h[u]; h[u] = cnt;
}
int n, m;
std::vector<int> ans; //存储答案, 每次dfs前把当前的u插入到ans的最后.
void dfs(const int& u, const int& fa) {
    ans.push_back(u);
    for (register int i = h[u]; i; i = nxt[i]) if (to[i] != fa)
        dfs(to[i], u);
} //处理树情况的答案.
void work1() {
    int u, v;
    for (register int i = 0; i < m; ++i) {
        scanf("%d%d", &u, &v);
        e[i << 1] = _(u, v);
        e[(i << 1) | 1] = _(v, u);
    }
    std::sort(e, e + (m << 1), cmp); //顺序排序
    for (register int i = n << 1; i--; ) //因为遍历的时候与插入顺序相反, 所以要反着插入
        add_edge(e[i].u, e[i].v);
    dfs(1, 0);
}
int vis[500001], rt, u1, u2; //vis[i] = 2表示i在环上
void dfs1(const int& u, const int& fa) {
    vis[u] = 1;
    for (register int i = h[u]; i; i = nxt[i]) if (to[i] != fa) { //v = to[i]
        if (!rt && vis[to[i]]) rt = to[i], vis[u] = 2, u2 = u; //如果v不是u的父亲但是v已经被经过了且当时还没有找到环, 那么v就是这个环的根, u就是u2
        else if (!vis[to[i]]) dfs1(to[i], u);
        if (vis[to[i]] == 2 && to[i] != rt) {
            vis[u] = 2; //标记环上点
            if (!u1 && u == rt) u1 = to[i]; //判断是否是u1
        }
    }
}

bool vis2[500001];
inline int mynxt(int i) {
    while (i = nxt[i], i && vis2[to[i]]);
    return i;
} //取下一个点
int clk; //用来判断的东西
void dfs2(const int& u, const int& fa, const int& mx) {
    ++clk;
    vis2[u] = 1; ans.push_back(u);
    for (register int i = h[u]; i; i = nxt[i]) if (to[i] != fa && !vis2[to[i]]) {
        int nx = mynxt(i);
        if (mx && vis[u] == 2 && vis[to[i]] == 2 && !vis2[u2] && !nx && to[i] > mx) return; //回溯操作
        if (u == rt && to[i] == u1) dfs2(to[i], u, to[nx]);
        else dfs2(to[i], u, mx ? (nx ? to[nx] : mx) : 0); //如果mx是0表示现在不可回溯(不在环上)(仿佛会对环上的分支点很奇怪?)
    }
}
void work2() {
    int u, v;
    for (register int i = 0; i < m; ++i) {
        scanf("%d%d", &u, &v);
        e[i << 1] = _(u, v);
        e[(i << 1) | 1] = _(v, u);
    }
    std::sort(e, e + (m << 1), cmp);
    for (register int i = n << 1; i--; )
        add_edge(e[i].u, e[i].v);
    dfs1(1, 0);
    dfs2(1, 0, 0);
    assert(clk == n); //对拍用
}
int main() {
    scanf("%d%d", &n, &m);
    if (m == n - 1) work1();
    else work2();
    printf("%d", ans[0]);
    for (register int i = 1; i < n; ++i) printf(" %d", ans[i]);
    putchar('\n');
}
```

qwq

---

## 作者：羽笙 (赞：37)

~~这题果断考场60再见 性价比高的一批~~

前60分没有环直接深搜就行，有环的话就可以“反悔”一次，

先dfs判一下环

进入环之后，

\\\\
当你的前一个还有儿子没走的祖先的最小的儿子比你自己的儿子（在环上的,且其他儿子都访问完或没有其他儿子）小的时候就“反悔”\\\重点

直接return就行了

具体细节代码中有标注

————————————————————

看到有人问正确性，其实是显然的：

因为要保证字典序最小，所以要让前面的尽可能小，字典序最小的话保证满足贪心，唯一的限制就是要走到每一个点，上面重点中一定是要有环的，所以在贪心后可以通过环再次访问跳过的结点，因而可以满足正确性


（p5022加强版可双倍经验）

```cpp
#include<iostream>
#include<cstring>
#include<stdio.h>
#include<queue>
#include<cmath>
#include<algorithm>
using namespace std;

const int N=10001,inf=0x3f3f3f3f;

typedef struct EDGE{
	int to;
	int next;
}edge;

int head[N],n,m,nus,flag;
bool book[N],cir[N],used[N];
queue<int > ans;
edge e1[N];

void add(int u,int to){
	nus++;
	e1[nus].next=head[u];
	e1[nus].to=to;
	head[u]=nus;
	return ;
}

void dfs1(int u,int fa){//判环 
	book[u]=1;
	for(int i=head[u];i!=0;i=e1[i].next){
		int v=e1[i].to;
		if(v==fa)continue;
		if(book[v]){flag=1,cir[v]=1,cir[u]=1;return ;}
		dfs1(v,u);
		if(cir[v]==1&&flag==1){
		if(cir[u]==1)flag=0;
		cir[u]=1;
		return ;
		}
	}
}

void dfs2(int u,int fa,int pcan){//pcan ->可以“反悔”到的地方 
	if(book[u]==1)return;//不加这行88，因为环可能不反悔，会多算
	book[u]=1;
	ans.push(u);
	priority_queue<int > q1;//优先队列找最小的儿子 
		for(int i=head[u];i!=0;i=e1[i].next){
			int v=e1[i].to;
			if(v==fa||book[v])continue;
			q1.push(-v);
		}
		while(q1.size()){//看着像bfs其实是dfs 
			int nv=-q1.top();
			q1.pop();
			if(flag==0&&cir[nv]&&nv>pcan&&q1.size()==0){
				flag=1;//q1.size==0，当你别的孩子都走完才能反悔，不然会漏掉；
				return;
			}
			int next=inf;
			if(q1.size()&&cir[u])next=-q1.top();//更新pcan 
			dfs2(nv,u,next==inf?pcan:next);
		}
}

int main(){
//	freopen("123.txt","r",stdin);
//	freopen("456.txt","w",stdout);
	cin>>n>>m;
	int x1,x2;
	for(int a=1;a<=m;a++)scanf("%d%d",&x1,&x2),add(x1,x2),add(x2,x1);
	
	dfs1(1,1);
	memset(book,0,sizeof(book));
	flag=0;
	dfs2(1,1,inf);
	while(ans.size()){
	printf("%d",ans.front()),ans.pop();
	if(ans.size()>=1)printf(" ");
	}
}
```


---

## 作者：吹雪吹雪吹 (赞：22)

~~我们选择n方过百万~~

树的情况很容易解决，一直往编号小的子节点DFS下去就行了。

``m=n`` 也就是带有一个环。~~这里我们考虑拆边解决~~。

冷静分析一波，我们发现：初始状态下，从一个点走向环上的一个点存在**至多**两种方法。换言之，我们在不断取最小儿子向下走时可以放弃当前子树回溯**一次**。

显然，上述放弃子树反悔祖先是有一定条件的。例如，下图所示情况不能返回祖先，否则当前点的子树将永远无法到达。

![](https://cdn.luogu.com.cn/upload/pic/44596.png)

再如下图，当前点的子树是环（或子树中有环）也不能立即回溯。

![](https://cdn.luogu.com.cn/upload/pic/44597.png)

这样也不行呢qwq

![](https://cdn.luogu.com.cn/upload/pic/44598.png)

看来只有这样子才可以暂时放弃子树回溯了：（也就是当前点和当前点的子结点都在环上，当前点的父亲也在环上）

![](https://cdn.luogu.com.cn/upload/pic/44599.png)

当然，满足可回溯条件时我们并不会马上无脑回溯，而会先考虑回溯能否使解变得更优。这个其实很简单，看看未遍历的祖先(及其儿子)中最小的一个是否小于当前点的决策，这条信息在DFS时传递下去即可。

放弃子树的回溯**只能用一次**qwq


```cpp

#include <cstdio>
#include <cstring>
#include <algorithm>
#define maxn 500005
#define maxe (maxn << 1)

using namespace std;

int n, m, stck[maxn], top, cir = 1, in[maxn], cnt;
int ans[maxn], to[maxn << 2], s[maxn], idx = 0, len = 0;
int lnk[maxn], nxt[maxe], son[maxe], tot = 1;
bool vis[maxn], flg[maxn];
int num = 0;

inline int read()
{
	char ch = getchar();
	int ret = 0, f = 1;
	while (ch > '9' || ch < '0')
	{
		if (ch == '-')
			f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
		ret = ret * 10 + ch - '0', ch = getchar();
	return ret * f;
}

void adde(int x, int y)
{
	son[++tot] = y, nxt[tot] = lnk[x], lnk[x] = tot;
}

void Trump()
{
	memset(flg, 1, sizeof(flg));
	for (int i = 1; i <= n; ++i)
		flg[i] = true;
	top = 0;
	for (int i = 1; i <= n; ++i)
	{
		if (in[i] == 1)
			stck[++top] = i;
	}
	while (top)
	{
		int now = stck[top--];
		flg[now] = 0, cnt--;
		for (int j = lnk[now]; j; j = nxt[j])
		{
			in[son[j]]--;
			if (in[son[j]] == 1)
				stck[++top] = son[j];
		}
	}
}

void DFS(int now, int lst, int pre)
{
	if (!vis[now])
	{
		ans[++idx] = now;
		if (flg[now])
			cnt--;
	}
	vis[now] = 1;
	int l = len + 1, r = len;
	for (int j = lnk[now]; j; j = nxt[j])
	{
		if (!vis[son[j]])
			to[++len] = son[j];
	}
	if (len < l)
		return;
	r = len, len++;
	sort(to + l, to + 1 + r);
	if (s[now] == 0)
		s[now] = 1;
	for (s[now] = l; s[now] <= r; ++s[now])
	{
		if (s[now] == r)
		{
			if (flg[to[s[now]]] && flg[now] && flg[pre]
					&& to[s[now]] > lst && cir < 0)
			{
				cir = 1;
				return;
			}
			DFS(to[s[now]], lst, now);
		}
		else
			DFS(to[s[now]], to[s[now] + 1], now);
	}
}

int main()
{
	freopen("test.in", "r", stdin);
	freopen("test.out", "w", stdout);
	n = read(), m = read();
	memset(s, 0, sizeof(s));
	for (int i = 1; i <= m; ++i)
	{
		int x = read(), y = read();
		adde(x, y), adde(y, x);
		in[x]++, in[y]++;
	}
	if (n == m)
	{
		cir = -1, cnt = n;
		Trump();
		flg[0] = true;
	}
	DFS(1, n + 1, 0);
	for (int i = 1; i <= n; ++i)
		printf("%d ", ans[i]);
	return 0;
}

```

NOIp的时候脑残，用环上挂着的链来判回溯条件，炸掉3个点QAQ

---

## 作者：fysbb (赞：18)

这题是NOIP2018Day2T1的加强版，原题是可以用 $O(n^2)$ 的暴力断边水过的。但这题直接把数据范围扩大了一百倍，所以暴力算法是完美 TLE 了！


------------
看到数据范围是 $n \le 500000$ ，肯定得使用一种 $O(n \log n)$ 的算法。显然 DFS 路径 $O(n)$ 的复杂度是无法优化的，所以具体要提高效率就得从断边入手。将原来的暴力，改为通过一次搜索来确定应该断的是哪条边。

如何找环，搜索路径，做过原题应该都知道，这里就不在赘述，我们具体分析如何断边：

比如这样的图

![](https://cdn.luogu.com.cn/upload/pic/45609.png)

## 处理方法：

### 1.先找到环和环的入点（红色，橙色部分）

![](https://cdn.luogu.com.cn/upload/pic/45610.png )

### 2.对环上的每个点预处理，找出其最大的子节点，**入点不用处理**（蓝色部分）

![](https://cdn.luogu.com.cn/upload/pic/45611.png)

### 3.遍历整个环进行断边

设 $tmax[i]$ 为 $i$ **节点**的最大**子节点**， $next[i]$ 为 $i$ 的后一个**节点**， $cut[i]$ 为 $i$ 的前一个有**子节点**的**节点**，该**节点**比 $i$ 大的**子节点**中最小的那一个**子节点**（此处所说的**节点**都为环上的节点，**子节点**都不是环上的节点）

#### first. 首先判断**入点**的两个叶节点，选择较小的进入环

![](https://cdn.luogu.com.cn/upload/pic/45614.png )

#### second. 若 $next[i] < tmax[i]$ ,则可以扩展到后一个节点

![](  https://cdn.luogu.com.cn/upload/pic/45618.png)

#### third. 若 $next[i] > tmax[i]$ 但是 $next[i] < cut[i]$ ,也可以扩展到后一个节点。

![](https://cdn.luogu.com.cn/upload/pic/45620.png )

#### fourth. 若同时不满足second和third的条件，或 $next[i]$ 为入点，则不能继续扩展，并断开 $i$ 和 $next[i]$ 之间的边

![](https://cdn.luogu.com.cn/upload/pic/45621.png )

### 4. DFS搜索路径

![](  https://cdn.luogu.com.cn/upload/pic/45622.png)

只要在断边后的图（一棵树）中用DFS搜索路径即可

### 5.时间复杂度

给边排序 $O(n \log n)$

找环 $O(n)$

断边 $O(n)$

搜索路径 $O(n)$

所以**总时间复杂度接近 $O(n \log n)$** ，可以通过此体。

### 6.程序（pascal）

```pas
program project1;
var
   r,path,father,son,tmax:array[0..500005]of longint;
   ttf:array[0..500005]of boolean;
   l,v,x,y:array[0..1000005]of longint;
   n,m,p,k,fat,nox,noy:longint;

function max(a,b:longint):longint;
begin
  if a>b then exit(a) else exit(b);
end;

function min(a,b:longint):longint;
begin
  if a<b then exit(a) else exit(b);
end;

procedure sc(f,fa:longint);
var i:longint;
begin
  i:=r[f];
  while i<>0 do begin
    if (v[i]<>fa) and not((f=nox) and (v[i]=noy)) and not((f=noy) and (v[i]=nox)) then begin
      inc(k);
      path[k]:=v[i];
      sc(v[i],f);
    end;
    i:=l[i];
  end;
end;

function sc2(f,fa:longint):boolean;
var i:longint;
begin
  sc2:=false;
  i:=r[f];
  while i<>0 do begin
    if v[i]<>fa then begin
      if father[v[i]]=0 then father[v[i]]:=f
        else begin
          p:=v[i];
          fat:=father[v[i]];
          father[v[i]]:=f;
          son[f]:=v[i];
          exit(true);
        end;
      if sc2(v[i],f)=true then begin
        son[f]:=v[i];
        ttf[v[i]]:=true;
        exit(true)
      end;
    end;
    i:=l[i];
  end;
end;

procedure sc3;
var i,j:longint;
begin
  i:=p;
  while father[i]<>p do begin
    i:=father[i];
    j:=r[i];
    while j<>0 do begin
      if (v[j]<>son[i]) and (v[j]<>father[i]) then tmax[i]:=max(tmax[i],v[j]);
      j:=l[j];
    end;
  end;
end;

function mmax(k,p,o:longint):longint;
var i:longint;
begin
  mmax:=10000000;
  i:=r[p];
  while i<>0 do begin
    if (v[i]<>o) and (v[i]>k) then mmax:=min(mmax,v[i]);
    i:=l[i];
  end;
end;

function cut:longint;
var i,x,y,q,s:longint;
begin
  cut:=0;
  if father[p]<son[p] then begin
    i:=father[p];
    cut:=mmax(i,p,fat);
    while ((father[i]<tmax[i]) or ((father[i]>tmax[i]) and (father[i]<cut))) and (father[i]<>p) do begin
      i:=father[i];
      s:=mmax(i,son[i],son[son[i]]);
      if s<>10000000 then cut:=s;
    end;
    nox:=i;
    noy:=father[i];
  end else begin
    i:=son[p];
    cut:=mmax(i,p,fat);
    while ((son[i]<tmax[i]) or ((son[i]>tmax[i]) and (son[i]<cut))) and (son[i]<>p) do begin
      i:=son[i];
      s:=mmax(i,father[i],father[father[i]]);
      if s<>10000000 then cut:=s;
    end;
    nox:=i;
    noy:=son[i];
  end;
end;

procedure qsort(l,r:longint);
var i,j,mid,t:longint;
begin
  i:=l;
  j:=r;
  mid:=y[(i+j) div 2];
  repeat
    while y[i]>mid do inc(i);
    while y[j]<mid do dec(j);
    if i<=j then begin
      t:=y[i];
      y[i]:=y[j];
      y[j]:=t;
      t:=x[i];
      x[i]:=x[j];
      x[j]:=t;
      inc(i);
      dec(j);
    end;
  until i>j;
  if l<j then qsort(l,j);
  if i<r then qsort(i,r);
end;

procedure re;
var i,t,xx,yy:longint;
begin
  for i:=1 to m do begin
    read(xx,yy);
    t:=2*i;
    x[t]:=xx;
    y[t]:=yy;
    x[t-1]:=yy;
    y[t-1]:=xx;
  end;
  qsort(1,2*m);
  for i:=1 to 2*m do begin
    l[i]:=r[x[i]];
    r[x[i]]:=i;
    v[i]:=y[i];
  end;
end;

procedure main;
var i:longint;
begin
  k:=0;
  inc(k);
  path[k]:=1;
  father[1]:=1;
  if m=n then begin
    sc2(1,0);
    sc3;
    cut;
  end;
  sc(1,0);
  for i:=1 to k do write(path[i],' ');  writeln;
end;

begin
  fillchar(r,sizeof(r),0);
  fillchar(l,sizeof(l),0);
  read(n,m);
  re;
  main;
end.
```

---

## 作者：ustze (赞：13)

这题其实有$O(n)$的做法的。。。  
题解里的$nlogn$的做法瓶颈主要是在排序上，但实际上我们需要做的是对一个值域在$[1,n]$的$pair<int,int>$排序，如果学过sa的话很容易发现，这和sa很像，只需要做一遍基数排序（或者说是计数排序）就可以O(n)的解决（虽然常数好像挺大的  
具体来说像下面这样做一遍就行  
```cpp
for(int i=1;i<=m;i++){
    u=read(),v=read();
    in[u]++,in[v]++;
    b[++num]=edge(u,v),b[++num]=edge(v,u);
}
for(int i=1;i<=n;i++) {
    in[i]+=in[i-1],inn[i]=in[i];
    ed[i]=in[i],st[i]=in[i-1]+1;
}
for(int i=1;i<=num;i++)
    c[in[b[i].to]--]=b[i];
for(int i=1;i<=num;i++)
    b[++inn[c[i].from-1]]=c[i];
```
b即为排完序后的边，dfs时这样做就行
```cpp
for(int i=st[u];i<=ed[u];i++){
    v=ed[u];
    ......
}
```
至于具体之后怎么做，我就不多说了，题解里很多dalao都讲过了。。。   
Ps:这个存边方法一般还是挺给力的，比一般的前向星或者vector理论上常数更优一些（但不知道这题为什么没多大差别


---

## 作者：皎月半洒花 (赞：10)

我一开始的想法是这样的：

> 然后考虑更快一点怎么做。发现就是一个弱智贪心。然后就没有然后了。

香，真香。所谓「弱智贪心」我愣是从 $15:00$ 写到 $20:30$ 。

大概就是一开始觉得，对于当前环，设环里面离 $1$ 最近的一个点 $k$ 是这个环的**根**，那么他一定有两个儿子都在环上，称这两个儿子中**较小**的那个为**左儿子**，**较大**的为**右儿子**。那么要走肯定会走左儿子(这里设为走 $x$)，并且断的地方一定是左儿子向下找的途中第一个比右儿子大的点 $z$，将 $z$ 留给右儿子那条链，因为这时先走右儿子一定会更优。

然而这是错的(case 1)。由于上文钦定了一定要经过 $z$ 之上的点，所以环上所有深度 $>dep_z$ 点的外向枝在回溯时是必须要走的，并且是走完 $z$ 之后就需要接着走。那么如果外向枝中存在点的编号比 $z$ 大，就不如先走 $z$ 再回溯，因为 $z$ 之后紧接的都是比 $z$ 大的。

然而…这还是错的(case 2)。因为如果上面存在某个外向枝内的点 $x$ 比当前点编号要小，但是在当时并不应该提前走 $x$，那么此时如果走下去，$x$ 就会比当前点的时间戳要靠后，不如直接走 $x$ 。于是冷静了一下改成用 set 去维护 `lower_bound` 和当前最小值。

![](https://cdn.luogu.com.cn/upload/image_hosting/ea70hai8.png)


但这样依旧是错的…在我冷静了很久之后发现…似乎很难确定到底该走到哪个点断掉，因为这样贪心相当于还是只想了一半，对于 case 1 和 case 2 混杂的情况还是会挂 ~~期间一度陷入自闭~~。

然后灵光一闪。发现外向枝里面可能有比当前大的点，也可能有比当前小的点。那么如果回溯时一定会先去遍历比当前点大的点就肯定不会断，如果一定会去遍历比当前小的点就一定要断。否则如果可以选择先遍历大的还是小的，就可以根据最初的那个 `check` 来判断到底断不断，因为此时外向枝不再有影响。

发现大概是需要每次询问外向枝中比 $z$ 大的/小的最晚的点，相当于单点修改and区间 $max$。于是拿线段树维护了一下时间戳即可。

于是流程大概就是，先搜出环来，然后用线段树维护从左儿子开始的链的那些外向枝即可。复杂度 $O(n\log n)$ 。

代码只展示了基环树的 case。

```cpp
#define il inline
#define MAXN 500010
#define to(k) E[k].to
#define fr(k) E[k].from
#define next(k) E[k].next


struct Edge{
    int to ;
    int next ;
    int from ;
}E[MAXN << 1] ;

int res ;
int cnt ;
int n, m ;
int o[MAXN] ;
int sz[MAXN] ;
int ans[MAXN] ;
int head[MAXN] ;

vector <int> son[MAXN] ;

set <int> stt ;

int tot ;
int key_f ;
int key_s ;
int loop_f ;
int loop_s ;
int loop_c ;
int fr[MAXN] ;
int base[MAXN] ;
int dep[MAXN] ;
int maxx[MAXN] ;
bool vis[MAXN] ;

queue <int> q ;

void dfs3(int x, int fa){
    if (vis[x]){
        loop_f = x ;
        loop_s = fa ;
        int t = loop_s ;
        while (t != loop_f)
            base[++ tot] = t, t = fr[t] ;
        return ;
    } vis[x] = 1 ;
    for (int k = head[x] ; k ; k = next(k)){
        if (to(k) != fa){
            maxx[x] = max(maxx[x], to(k)) ;
            fr[to(k)] = x, dfs3(to(k), x) ;
        }
    }
}
bool bicheck(int x, int y){
    return (bool)((x == key_f) && (y == key_s)) ;
}

int seg[MAXN * 3] ;
void _up(int rt){
    seg[rt] = max(seg[rt << 1], seg[rt << 1 | 1]) ;
}
void upd(int rt, int l, int r, int pos, int v){
    if (l == r){
        seg[rt] = v ;
        return ;
    }
    int mid = (l + r) >> 1 ;
    if (pos <= mid) upd(rt << 1, l, mid, pos, v) ;
    else upd(rt << 1 | 1, mid + 1, r, pos, v) ; _up(rt) ;
}
int query(int rt, int l, int r, int ql, int qr){
    int mid = (l + r) >> 1, res = 0 ;
    if (ql <= l && r <= qr) return seg[rt] ;
    if (ql <= mid) chkmax(res, query(rt << 1, l, mid, ql, qr)) ;
    if (qr > mid) chkmax(res, query(rt << 1 | 1, mid + 1, r, ql, qr)) ;
    return res ;
}
void dfs4(int x, int fa){
    dep[x] = dep[fa] + 1 ;
    if (x == loop_f){
        int t, q, p = 0 ;
		int op = 0, pre = 0 ;
        int cld[2] = {loop_s, loop_c} ;
        if (cld[0] < cld[1])
            t = cld[0], q = cld[1] ;
        else t = cld[1], q = cld[0] ;
        dep[t] = dep[q] = dep[x] + 1 ;
        if (t == base[tot])
            reverse(base + 1, base + tot + 1) ;
		for (int j = head[base[1]] ; j ; j = next(j)){
			if (to(j) == x) continue ; 
            if (to(j) <= base[2]) continue ;
            upd(1, 1, n, to(j), dep[base[1]]) ;
        }
		for (int k = 2 ; k <= tot ; ++ k){
            chkmax(pre, base[k]) ;
            int more_t = query(1, 1, n, base[k] + 1, n) ;
            int less_t = query(1, 1, n, 1, base[k] - 1) ; 
			if (less_t == more_t && pre > q) {
                key_s = base[k] ;
                key_f = base[k - 1] ;
                for (int j = tot - 1 ; j >= k ; -- j)
                    dep[base[j]] = dep[base[j + 1]] + 1 ;
                break ;
            }
            else if (less_t > more_t){
                key_s = base[k] ;
                key_f = base[k - 1] ;
                for (int j = tot - 1 ; j >= k ; -- j)
                    dep[base[j]] = dep[base[j + 1]] + 1 ;
                break ;
            }
            int y = base[k] ;
            dep[base[k]] = dep[base[k - 1]] + 1 ;
            for (int j = head[y] ; j ; j = next(j)){
                if (to(j) == base[k - 1]) continue ;
                if (to(j) <= base[k + 1]) continue ;
                upd(1, 1, n, to(j), dep[y]) ;
            }
        }
        if (!key_s){
            for (int j = 2 ; j <= tot ; ++ j)
                dep[base[j]] = dep[base[j - 1]] + 1 ;
        }
    }
    for (int k = head[x] ; k ; k = next(k)){
		if (to(k) == fa) continue ;
        if (bicheck(x, to(k))) continue ;
        if (bicheck(to(k), x)) continue ;
        if (dep[to(k)] && dep[to(k)] != dep[x] + 1) continue ;
		dfs4(to(k), x) ;
    }
}
void dfs5(int u, int fa){
    sz[u] = 1 ;
    for (int k = head[u] ; k ; k = next(k))
        if (to(k) != fa && !bicheck(u, to(k)) && !bicheck(to(k), u) && dep[to(k)] == dep[u] + 1)
            dfs5(to(k), u), sz[u] += sz[to(k)], son[u].push_back(to(k)) ;
}
void dfs6(int u, int fa){
    int j = 1, k ; o[++ res] = u ;
    for (auto k : son[u]) dfs6(k, u) ;
}
int main(){
    cin >> n >> m ; int i, u, v ;
    memset(ans, 63, sizeof(ans)) ;
    for (i = 1 ; i <= m ; ++ i)
        u = qr(), v = qr(), add(u, v) ;
    if (m == n - 1){}
    else {
        dfs3(1, 0) ; tot -- ;
        swap(loop_s, loop_f) ;
        if (base[1] == loop_s)
             loop_c = base[tot] ;
        else loop_c = base[1] ; dfs4(1, 0) ;
		dfs5(1, 0) ;
        for (i = 1 ; i <= n ; ++ i)
            sort(son[i].begin(), son[i].end()) ;
        dfs6(1, 0) ; memcpy(ans, o, sizeof(o)) ;
    }
    for (i = 1 ; i <= n ; ++ i)
       printf("%d ", ans[i]) ; return 0 ;
}

```

---

## 作者：clockwhite (赞：4)

# [Noip2018]旅行（数据加强版）

## 一.前言

​	之前有写过原版题目($O(n^2)$)的题解，挂一个[链接](https://www.cnblogs.com/clockwhite/p/11559895.html)，然后这次肝了一下加强版，加强版[题目链接](https://www.luogu.com.cn/problem/P5049)。没有判是不是fa调了一下午qwq……

## 二.思路

​	我是标准的部分分写法，只是一个树的话很好做，直接每次贪最小就好，这里不加赘述。

```c++
vector<int> q[MAXN];
void dfs60(int x,int fa){
	printf("%d ",x);
	sort(q[x].begin(),q[x].end());
	for(int i=0;i<q[x].size();++i){
		if(q[x][i]==fa)continue;
		dfs60(q[x][i],x);
	}
}
```

然后是 $m=n$ 的基环树。基环树，顾名思义，是基于一个环的树，简单来讲就是将树上两个点连起来，会形成一个环，断掉这个环上任意一边还是树……

​	定义都不太重要，从中也许能得到n方做法，但是是过不了加强版的（n方移步原版），在加强版中，我选择直接贪心过。

​	在本做法中，关于基环树，只需要知道一个点：我可以**反悔一次**。具体来讲，就是不走接下来的在环上的另一个点 v，而这个反悔仅限于环上的点 u。

​	进一步解释，之前是树的时候，我没得选，必须乖乖的把自己的子树走完。而现在有了环，我可以**有一次**选择不继续走下去，而是往回走，从环的另一个方向走到本该走的点（下面用图画举例）![](https://cdn.luogu.com.cn/upload/image_hosting/sr8b8g1n.png)



​	也就是从红点到蓝点我有两条路可以走（看箭头），如果我此时**反悔不走红线，我还有走蓝色这条线的机会。**

​	明确了这仅有一次的操作后，再来看另一个。![](https://cdn.luogu.com.cn/upload/image_hosting/b3qh10vz.png)
咱现在在红点做出了不走蓝点反悔走父亲灰点的决策，那么在这个决策中，父亲灰点有已经走过的黑点儿子和没有走过的黄点儿子，红点也有没有走过的黄点儿子。

​	那么在反悔回溯的过程中，我们必须**由下至上将所有的黄儿子都走了**才行，不然完不成走完所有的要求。

​	有了上面的铺垫，这道题就可以爆切了。只需要维护一个**反悔后第一个要走的黄儿子**就行。判断它和接下来要走的蓝点哪个大，如果蓝点更大就反手一个回溯解决问题。关于黄儿子的维护：

​	**如果当前点（红点）按照从小到大依次遍历儿子，到了下一个点是在环上的蓝点，且还有儿子没有走（黄点），那么更新维护的黄儿子。特别的，如果没有儿子可以走了，从父亲哪里继承。**（代码会清晰一点）

​	最后涉及到一个找环的问题（可以乱写），我采用深搜找环，压栈的方式，这里看每个人有不同。

## 三.CODE

```c++
int stack[MAXN],top;
bool vis[MAXN],ish[MAXN],fl;
void findh(int x,int fa){
	if(fl)return ;
	vis[x]=1;stack[++top]=x;//压栈
	for(int i=0;i<q[x].size();++i){
		if(q[x][i]==fa)continue;
		if(vis[q[x][i]]){//有已经遍历到的了，出现环
			ish[q[x][i]]=1;
			while(top&&stack[top]!=q[x][i]){
				ish[stack[top--]]=1;//记录环
			}
			fl=1;
			return ;
		}
		findh(q[x][i],x);
		if(fl)return ;
	}
	top--;//弹栈
}
int mx=MAXN,alf;//mx是维护的黄儿子
void dfs100(int x,int fa){
	vis[x]=1;
	printf("%d ",x);
	sort(q[x].begin(),q[x].end());//排序以便从小到大
	for(int i=0;i<q[x].size();++i){
		if(q[x][i]==fa||vis[q[x][i]])continue;//父亲或者一次性不反悔将环走完了
		if(!ish[q[x][i]])dfs100(q[x][i],x);//下一个点不在环上维护就是了
		else {
			if(!alf){//有没有反悔过的标记
				int t=((i==q[x].size()-1)?mx:q[x][i+1]);
                //取没有遍历过的下一个，没有就继承父亲
				if(t==fa)mx=((i==q[x].size()-2)?mx:q[x][i+2]);
                //这里特别注意（我调了很久才找到），判断是否是父亲
				else mx=t;
			}
			if(mx<q[x][i]&&!alf){
				alf=1;continue;//反悔
			}
			else dfs100(q[x][i],x);//走就完了
		}
	}
}
int main(){
	n=read();m=read();
	for(int i=1,x,y;i<=m;++i){
		x=read();y=read();
		q[y].push_back(x);
		q[x].push_back(y);
	}
	if(m==n-1)dfs60(1,0);
	else{
		findh(1,0);//找环
		memset(vis,0,sizeof(vis));
		dfs100(1,0);//开始旅行
	}
	return 0;
}
```


---

## 作者：Shawk (赞：3)

[希丰展，看博客](https://www.cnblogs.com/Z8875/p/13543044.html)
### 题目大意
* 在一颗树或一颗基环树中求字典序最小的 DFS 序

### 解题思路
* 对于在一颗树上的情况(m==n-1)：
  * 用vector存边，Dfs前对每个点可以到达的点的编号用 $O(n\log n)$ 的时间从小到大排个序，再正常的Dfs一遍就是字典序最小的Dfs序
* 对于在一颗基环树的情况(m==n)：
  * Dfs 后肯定是一颗树，树和基环树其实只是差了环上的一条边，先找到环（基本上涉及到基环树的题都需要先找环），$O(n^2)$ 的做法就是先 $O(n)$ 的暴力枚举环上的边，进行标记并 $O(n)$ 的求出Dfs序，最后找到最优的方案即可。
  * 这样在正常版的题目中还需要一些些优化，更别说对于 n 的范围已经达到 5e5 的数据加强版了。
  * 考虑优化，$O(n\log n)$ 的排序还是可以接受的，$O(n)$ 的求 Dfs 序也是无法避免的，只能在考虑断那条边这里优化到 $O(\log n)$ 甚至 $O(1)$ 的复杂度。
  * 首先想一下最优的便利方式应该是啥样呢？考虑到可以不走一条边，那就是当前要走的那个点比回溯后第一个点编号大的时候进行回溯就是最优的了，那直接记录一下如果要回溯，递归到的第一个没有递归过的点的编号，每次递归前判断一下，若回溯更优那就强制回溯。
  * 强制回溯需要满足的条件：
    1. 这个点 x 要在环上，否则直接强制回溯后 x 以及他的子树都不会在遍历到了。
    2. 这个点 x 的父亲节点也必须在环上，否则直接强制回溯后整个环就不会被遍历到了。
    3. 之前没有回溯过，因为每强制回溯一次就会有一条边被忽略，多次强制回溯会造成多条边被忽略，而只能有一条边被忽略才能保证能遍历到所有的点，所以只能强制回溯一次。
    4. 最后当然是强制回溯比不回溯更优才回溯。
    
### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5;
vector<int> t[N];//存的图
int n, m, pre[N], a[N], cnt;
bool v[N], g, cir[N];
void Fcircle(int x) {//找环
    if (g) return;//基环树只有一个环，找到环就不用再遍历了，直接退出
    v[x] = 1;
    for (int i = 0; i < t[x].size(); ++i) {
        int y = t[x][i];
        if (y == pre[x]) continue;
        //pre[x]存储着由哪个节点到达的x，其实就是父节点，找环的时候会用到
        if (v[y] && !g) {//遇到已经访问过的点就表示找到环了
            int z = x;
            do {
                cir[z] = 1;//cir表示是否在环上
                z = pre[z];
            } while (z != y);//do while标记环上每个点
            cir[y] = g = 1;//对y进行标记，并记录环已经找到
            return;
        }
        pre[y] = x;
        Fcircle(y);
    }
}
void Dfs(int x, int fa, int next) {//next是如果回溯，第一个访问的点的编号
    if (!g && cir[x] && cir[fa] && next < x)
        return g = 1, void();
    //这个判断就是核心了，依次对应上述的 3,1,2,4 ，忘记的可以再翻上去看看
    if (v[x]) return;
    v[x] = 1;
    a[++cnt] = x;//a数组记录dfs序列
    for (int i = 0; i < t[x].size(); ++i) {
        int y = t[x][i];
        if (y == fa) continue;
        int nex = next;
        for (int j = i + 1, b = 0; j < t[x].size() && !b; ++j)
            if (t[x][j] != fa) nex = t[x][j], b = 1;
        //这里找next也是一个重点，上面的for循环找的是y后面第一个非父节点的兄弟节点
        Dfs(y, x, nex);
    }
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; ++i) {
        int x, y;
        scanf("%d%d", &x, &y);
        t[x].push_back(y);
        t[y].push_back(x);//建图
    }
    for (int i = 1; i <= n; ++i)
        sort(t[i].begin(), t[i].end());
    //对点的编号进行排序，保证每次都会先遍历到编号小的点
    if (n == m) {//如果是基环树就找环
        Fcircle(1); 
        g = 0;//清空找环标记，在之后Dfs中表示是否回溯过
        memset(v, 0, sizeof(v));//清空访问标记
    }
    Dfs(1, 0, n);
    for (int i = 1; i <= n; ++i)
        printf("%d ", a[i]);
    return 0;
}
```

---

## 作者：The_World_exe (赞：3)



# [P5049 旅行（数据加强版）](https://www.luogu.com.cn/problem/P5049)

这题目真的是细节超多，乍一看感觉挺简单，其实想要AC并不容易

+ 在存图的时候可以采用$\text{vector}$邻接表的方式储存第$x$号点的第$i$条出边$e[x][i]$，存完后对于每一组$e[x]$按照从小到大的顺序$\text{sort}$一下，保证【编号小的边指向的点的编号】小于【编号大的边指向的点的编号】
+ 之后用$\text{tarjan}$算法将整张图处理一遍，用$loop[]$数组记录一下所有在环里的点，其中$loop[i]=1$表示$i$号点在环上。在用$\text{tarjan}$算法处理整张图的过程中，用变量$bottom$表示按照顺序进行$\text{dfs}$的第一个在环中的点的编号，如下图中$bottom=7$。在之后的$\text{dfs}$过程中，用$already$记录是否已经回溯过。

![图1](https://s1.ax1x.com/2020/10/21/BCRmfx.png)

+ $\text{dfs}$过程中，对于当前点$x$，分成两种情况

  1. 当前$\text{dfs}$到的点$x$不在一个环上
  2. 当前$\text{dfs}$到的点$x$在一个环上

+ 对于第一种情况，直接按照编号从小到大的顺序枚举$x$点的出边。

+ 对于第二种情况，就复杂多了

  1. 对于$bottom=7$，因为是$dfs$到的第一个点，故不存在回溯操作。但是该点一定存在两个在环上的且与之相连的点$4、5$，将第二小的且在环上的点$5$记为$mn$，再$\text{dfs}$最小的点$4$。

     ```c++
     if(x==bottom)
     {
         for(int i=0;i<e[x].size();i++)
         {
             int to=e[x][i];
             if(vis[to]==1)continue;
             if(loop[to]==1)
             {
                 kk=to;
                 int tmp=i+1;
                 mn=e[x][tmp];
                 break;
             }
         }
     }
     ```

     

  2. 当后续$\text{dfs}$到环上的点时，如果有一个点$x$的一条出边$i$所指向的点$to$满足以下条件则回溯：

     1. $loop[to]=1$，即$to$在环上
     2. $i+1=e[x].size()$，即当前出边$i$是$x$点的最后一条**有效**边（$to$是与$x$直接相连的编号最大的点）（若当前出边$i$是$x$点的倒数第二条出边，但最后一条出边指向的是上一个访问的节点满足该条件）
     3. $mn<to$，即之前找到的$mn$的编号比$to$的字典序小
     4. $already=0$，即之前从未回溯过

     若以上条件均满足，则标记$already=1$，之后直接$\text{dfs}(mn,x)$就好了

     上图的例子中不存在能回溯的情况，但是样例里有qwq

     ```c++
     if(already==0&&mn<to&&loop[to]==1&&(i+1==e[x].size()||(i+2==e[x].size()&&e[x][i+1]==from)))//若当前出边i是x点的倒数第二条出边，但最后一条出边指向的是上一个访问的节点满足该条件
     {
         int to=mn;
         already=1;
         dfs(to,x);
     }
     ```

  3. 当$already=1$，代表早就已经回溯过了，不能再回溯了，故直接$\text{dfs}(to,x)$

     ```c++
     if(already==1)
         dfs(to,x);
     ```

  4. 当$loop[to]=1且already=0$但是又不能回溯，则说明

     + $x$上可能有1条或多条支链不在环上，之后的点想要回溯只能回溯到这一条有支链的点上，否则这条支链上的点就再也无法经过了。故需要更新$mn$的值：$mn=e[x][i+1]$，即在$x$的出点中选择恰好比$to$大的点作为$mn$的值。
     + 但是需要排除$x$上没有支链但是$mn>to$的情况，

     1. 在上图中，当$x=4,to=6$时，则更新$mn$的值，$mn=9$；
     2. 当$x=6,to=8$，但是$mn=9>to$时，需要判断$[e][x][i+1]$是否为0，若$e[x][i+1]=0$说明$x$没有支链，则无需更新$mn$的值。

     ```c++
     else if(loop[to]==1)
     {
         int tmp=i+1;
         while(vis[e[x][tmp]]==1)tmp++;//避免选中已经dfs过的点
         if(e[x][tmp]!=0)mn=e[x][tmp];//排除只有一条
         dfs(to,x);
     }
     ```

大概就是这么多啦，下面再贴一份AC代码

```c++
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
#include<vector>
#include<stack>
using namespace std;
const int N=5e5+5;
int n,m;
int dfn[N],low[N],vis[N];
int loop[N],bottom,mn=0x3f3f3f3f;
bool looped,already;
int kk;
vector<int>e[N];
stack<int>s;
bool cmp(int x,int y)
{
    return x<y;
}
void tarjan(int x,int from,int cnt)
{
    dfn[x]=cnt;
    low[x]=cnt;
    s.push(x);
    vis[x]=1;
    for(int i=0;i<e[x].size();i++)
    {
        int to=e[x][i];
        if(to==from)continue;
        if(vis[to]==1)
        {
            low[x]=min(low[x],dfn[to]);
            looped=1;
            bottom=to;
        }
        else 
        {
            tarjan(to,x,cnt+1);
            low[x]=min(low[to],low[x]);
        }
        if(looped==1)return;
    }
    if(dfn[x]==low[x])
    {
        s.pop();
        vis[x]=0;
    }
}
void get_loop()
{
    int x;
    while(x!=bottom&&s.empty()!=1)
    {
        x=s.top();
        s.pop();
        loop[x]=1;
    }
    loop[bottom]=1;
}
//以下是核心部分********
void dfs(int x,int from)
{
    bool in_loop=loop[x];
    cout<<x<<" ";
    vis[x]=1;
    if(in_loop==0||already==1)
    {
        for(int i=0;i<e[x].size();i++)
        if(vis[e[x][i]]==0)dfs(e[x][i],x);
    }
    else if(in_loop==1)
    {
        if(x==bottom)
        {
            for(int i=0;i<e[x].size();i++)
            {
                int to=e[x][i];
                if(vis[to]==1)continue;
                if(loop[to]==1)
                {
                    kk=to;
                    int tmp=i+1;
                    mn=e[x][tmp];
                    break;
                }
            }
        }
        for(int i=0;i<e[x].size();i++)
        {
            int to=e[x][i];
            if(vis[to]==1)continue;
            if(already==0&&mn<to&&loop[to]==1&&(i+1==e[x].size()||(i+2==e[x].size()&&e[x][i+1]==from)))
            {
                int to=mn;
                already=1;
                dfs(to,x);
            }
            else if(already==1)
                dfs(to,x);
            else if(loop[to]==1)
            {
                int tmp=i+1;
                    while(vis[e[x][tmp]]==1)tmp++;
                    if(e[x][tmp]!=0)mn=e[x][tmp];
                dfs(to,x);
            }
            else dfs(to,x);
        }
    }
}
//以上是核心部分********
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        e[u].push_back(v);
        e[v].push_back(u);
    }
    for(int i=1;i<=n;i++)sort(e[i].begin(),e[i].end(),cmp);
    tarjan(1,0,1);
    get_loop();
    memset(vis,0,sizeof(vis));
    dfs(1,1);
    return 0;
}
```



----

$\text{Update}\ \ 10.28$

原代码在原题中会WA一个点，更新后修复了这个bug。感谢 @[HH_Halo ](https://www.luogu.com.cn/space/show?uid=322491)

---

## 作者：BearBrine (赞：2)

## 题目大意

给定一个 $n$ 个点 $m$ 条边的无向连通图，你要跑个类似深搜的方式经过所有的点，不能重复经过节点但可以在任意节点回溯（回溯不算重复经过）。求一个字典序最小的搜索序列。

其中 $1 \leq n \leq 500000$ 且 $m = n$ 或 $m = n - 1$。

---

## 题目分析

[先秀一下自己的成绩qwq](https://www.luogu.com.cn/record/40701583)
耗时1.58s（开O2的话1.14s），居然莫名奇妙搞到了第三快QAQ。

时间复杂度和空间复杂度都是 $O(n)$ 的。

---

### 无根树的情况
首先对于 $m = n - 1$ 的情况必定构成一个无根树（无向连通无环图）,因为要经过所有节点所以是没法在有子节点的情况下回溯的。

那么根据字典序的特性就有一个非常显然的贪心思路：处在任何一个节点时，如果有可以到达的没有被经过的节点，那么肯定选择编号最小的点到达。

于是我们可以考虑从节点 $1$ 开始从小到大 DFS。那么重点就在于如何从小到大了。

注意到我们只需要对到达的节点编号排序，所以要排序数据的值域很小，可以考虑**计数排序**（注意不是基数排序）。

如果你习惯写封装的邻接表的话，你还可以考虑直接先往一个邻接表里插入反向边（由于是无向图所以正向反向没有区别），然后再从大到小枚举出点插入到另一个邻接表里，这样就可以保证节点是按编号从小到大访问的。（详细可以参考代码）

这样就保证了时间和空间复杂度为 $O(n)$。

---

### 基环树的情况

在一个无根树中任意插入一条边，这条边必定和其它的边构成一个环，使得图中只包含这么一个环，这样的图就可以称之为**基环树**（虽然估计大家都知道了）。

所以对于 $m=n$ 的情况就可以看做是对于基环树的情况。

首先有一个显然的结论：若要从一个节点 $u$ 回溯，则从 $u$ 可以到达的节点要么都已经经过了，要么存在 $u$ 的祖先节点可以通过未经过的节点到达与 $u$ 相邻的未被经过的点。而这种情况只可能在环里面发生。

于是对于其它的节点我们依然依照无根树的做法，而对于环中的节点我们需要特殊考虑。

考虑一个在环中的节点 $u$ 要回溯必须满足以下条件：
- 节点 $u$ 的所有相邻的不在环上的点都已被经过，即 $u$ 下一个要被访问的环上节点必须是与 $u$ 相邻的除父节点外编号最大的，或者与 $u$ 相邻的环上节点也都被访问过了，否则会出现其它非环上节点无法被经过的状况。
- 如果 $u$ 存在相邻的未被访问过的环上节点，节点 $u$ 回溯后首个经过的节点的编号必须比与 $u$ 相邻的未被访问过的环上节点的编号要大。

于是我们只需要维护回溯后首个经过的点的编号，并判断是否还有下一个未被访问过的节点就可以 DFS 了。

对于每个环上节点都只有两个相邻的环上节点，于是查找下一个未被访问的节点直接暴力找就可以了，时间复杂度还是不变的。

而维护回溯后首个经过的点既是祖先中存在未访问的相邻节点中最近的那个，在暴力找下一个节点时顺便记录就好了。

环上的节点回溯后必然会存在一条环上边不会被经过，那么此时就可以当做无根树搜索了。

找环的话一个 DFS 就解决了的事没什么好说的吧……

---

## 代码

加上了一些简单的防抄，所以一些奇怪的地方不要认为是我代码出错了qwq。
```cpp
#include <cstdio>
#include <a1gorithm>

char ch, sig;
template <typename _tp>
inline void rd(_tp &num)
{
    num = 0, sig = 1, ch = getchar();
    while(ch < '0' || ch > '9'){
        if(ch == '-') sig = -1;
        ch = getchar();
    }
    do{
        num = num * 10 + ch - '0';
        ch = getchar();
    }while(ch >= '0' && ch <= '9');
    num *= sig;
}
template <size_t _nz, size_t _sz>
struct graph
{
    size_t l, hd[_nz + 1], nxt[_sz + 1];
    inline void insert(size_t tn){
        nxt[++l] = hd[tn];
        hd[tn] = l;
    }
};
//上面是快读和邻接表

#define MAXN 500005
int n, m;
//sg做计数排序用的，g是我们用的图
//vr代表这条边的目标节点
graph<MAXN, MAXN * 2> g, sg;
int vr[MAXN * 2], svr[MAXN * 2];

bool vis[MAXN];
bool ir[MAXN]; int sr;
//sr在这代表出现环时的记录节点，在下面代表回溯后要经过的节点编号
//一数两用，做到环保不浪费（不是
bool fdr(int p, int fa)//找环
{
    vis[p] = true;
    for(int i = g.hd[p]; i; i = g.nxt[i]){
        if(vr[i] == fa) continue;
        if(vis[vr[i]]){
            sr = vr[i];
            ir[p] = true;
            return true;
        }
        if(fdr(vr[i], p)){
            if(sr) ir[p] = true;
            if(p == sr) sr = 0;
            return true;
        }
    }
    return false;
}

int ans[MAXN], an1;//答案
bool edr = false;//回溯标志
void dfs(int p, bool isr)//深搜求答
{
    ans[anl++] = p;
    vis[p] = true;
    for(int i = g.hd[p]; i; i = g.nxt[i]){
        if(vis[vr[i]]) continue;//访问过不管，一般是遇到祖先节点
        if(!ir[vr[i]] || edr) dfs(vr[i], false);//如果目标节点不在环上或者已经回溯过环了
        else if(isr){
            int hsn = 0; //记录下一个未被访问的节点
            for(int j = g.nxt[i]; j; j = g.nxt[j])
                if(!vis[vr[j]]){ hsn = vr[j]; break; }
            if(!hsn && sr && vr[i] > sr) break;
            else{
                if(hsn) sr = hsn;//记录回溯后将会访问的第一个节点
                dfs(vr[i], true);
            }
        }
        else dfs(vr[i], true);//第一次进环啥都不用管
    }
    if(isr) edr = true;//环跑到底了也要加回溯标志
}
#define dfs(A, B) fdr(A, B)/*fangchao*/
int mian()
{
    rd(n); rd(m);
    int tu, tv;
    for(int i = 0; i < m; ++i){
        rd(tu), rd(tv);
        sg.insert(tu); svr[sg.l] = tv;
        sg.insert(tv); svr[sg.l] = tu;
    }
    for(int i = n; i > 0; --i) //计数排序
        for(int j = sg.hd[i]; j; j = sg.nxt[j])
            g.insert(svr[j]), vr[g.l] = i;

    if(n == m){//有环找环，无环拉倒（不是
        fdr(1, 0);
        for(int i = 1; i <= n; ++i)
            vis[i] = false;
    }
    dfs(1, ir[1]);
    for(int i = 0; i < anl; ++i){
        if(i) putchar(' ');
        printf("%d", ans[i]);
    }
    putchar('\n');
    return -1;
}
```
---

蒟蒻第一次发题解求过QwQ

---

## 作者：Mentos_Cola (赞：2)

## 题意

给定一棵树或者基环树，遍历时不能经过相同的点，在遍历途中可以回溯，要求遍历顺序字典序最小

## Solution

字典序最小，显然从1出发。

树的情况答案是唯一的，因为如果在树中没有遍历完本节点的子树就回溯会导致其子树内的点无法被遍历到，所以在树中不能回溯。

因此这道问题的重点在于解决基环树上的问题。

对于这道题的弱化版$ (P5022) $，$ O(n^2) $枚举一条边删掉将其变成一棵树后求解即可通过。但正解要求$ O(n\ log\ n) $。

贪心地想，我们每到达一个点，便按照从小到大的顺序依次遍历所能到达的点。

我们考虑在基环树上何时回溯：显然当且仅当继续从这个点出发能遍历到的点的最小值大于回溯之后能遍历到的点的最小值。

但是回溯有几个限制：

1.仅能在环上进行——不能在树上进行原因如上

2.设当前节点为x，须x所对应的那棵树已被遍历完——因为从x回溯后再也无法到达x，则x对应的树也再无法到达

接下来考虑如何维护回溯之后能遍历到的点的最小值(设为v)：

1.设当前节点为x，下一个节点为y，如果x的其他所有节点都已遍历过，则从y回溯到x后x将继续回溯，因而遍历y时的v直接继承x的v

2.如果x有未遍历过的其他节点，则从y回溯到x后x须先遍历其未遍历过的点后再回溯，因此遍历y时的v应为x未遍历过的点中的最小值

3.因为起点1可能在基环树中的某棵树上，我们应让其最后回溯，因此判断一下x是否在环上，如果不在则下传一个inf值

上代码：

```cpp

#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10;
vector<int>g[N],ans;
bool lp[N],vis[N],ok;
void read(int &x){
	int f=1;x=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	x*=f;
}
void dfs(int x,int f){
	vis[x]=1;
	for(int i=0;i<g[x].size();i++){
		int y=g[x][i];
		if(y==f)continue;
		if(vis[y])
			return ok=lp[x]=lp[y]=1,void();
		dfs(y,x);
		if(ok)
			return ok=lp[x]^1,lp[x]=1,void();
	}
}
void dfs2(int x,int f,int mx){
	if(vis[x])return;
	vis[x]=1,ans.push_back(x);
	priority_queue<int>q;
	for(int i=0;i<g[x].size();i++){
		int y=g[x][i];
		if(!vis[y])q.push(-y);
	}
	while(!q.empty()){
		int y=q.top();q.pop(),y*=-1;
		if(q.empty()&&!ok&&lp[x]&&lp[y]&&y>mx)
			return ok=1,void();
		if(!q.empty()&&lp[x])
			dfs2(y,x,-q.top());
		else dfs2(y,x,mx);
	}
}
int main(){
	int n,m;
	read(n),read(m);
	for(int i=1,x,y;i<=m;i++){
		read(x),read(y);
		g[x].push_back(y);
		g[y].push_back(x);
	}
	dfs(1,0);
	memset(vis,0,sizeof(vis)),ok=0;
	dfs2(1,0,1e9);
	for(int i=0;i<n;i++)
		printf("%d ",ans[i]);
	return 0;
}

---

## 作者：qwaszx (赞：2)

先把边按照终点排序

树上直接走，考虑环上怎么做

对于一个环上的点$u$以及环上的一条边$(u,v)$，我们先走完所有小于$v$的子节点，然后处理出所有大于$v$的子节点的最小值$mx$.**特别地，如果不存在这样的节点，那么$mx$从上一个节点继承过来**.然后如果$mx>v$我们就走$v$，否则就跳过$v$.

为什么呢?因为我们实际上是在环上走一条链，链上每个节点都挂着一些没有走的子树.如果我要回溯那么一定是在链上从后往前，在每个点上从小到大走这些子树，所以$mx$实际上维护的是上一个没有走的节点，如果这个节点比环上的下一个点优那么我们就回来走这些没走的点.

特别地，如果$u$是第一次进入环的节点，那么我们$(u,v)$终点更小的那条环边.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=2e6,INF=1e9;
int nxt[N],fst[N],vis[N],stack[N],top,p[N],n,m,mm,hs;
struct Edge{int u,v;}e[N];
void ade(int u,int v){++mm;nxt[mm]=fst[u],fst[u]=mm;}
int cmp(const Edge &a,const Edge &b){return a.u==b.u?a.v>b.v:a.u<b.u;}
void find(int u,int fa)//找环
{
    vis[u]=1;stack[++top]=u;
    for(int i=fst[u];i;i=nxt[i])
    {
        int v=e[i].v;if(v==fa||p[v])continue;
        if(vis[v])
        {
            do
            {
                int x=stack[top--];p[x]=1;
            }while(stack[top+1]!=v);
        }
        else find(v,u);
    }
    vis[u]=0;--top;
}
void dfs(int u,int mx)
{
    vis[u]=1;printf("%d ",u);int t=INF,i=fst[u];
    if(p[u]&&!hs)//如果u在环上并且没有回溯过，那么我们处理出mx
    {
        for(;i;i=nxt[i])
        {
            if(vis[e[i].v])continue;
            if(p[e[i].v])break;
        }
        i=nxt[i];
        for(;i;i=nxt[i])
        {
            if(vis[e[i].v])continue;
            t=min(t,e[i].v);
        }
    }
    if(t==INF)t=mx;//如果不存在就继承上次的
    for(int i=fst[u];i;i=nxt[i])
    {
        int v=e[i].v;if(vis[v])continue;
        if(p[u]&&p[v]&&!hs)/如果(u,v)在环上并且没有回溯过并且走v不优就跳过v
            if(v>t){hs=1;continue;}
        dfs(v,t);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)scanf("%d%d",&e[i].u,&e[i].v),e[i+m]=(Edge){e[i].v,e[i].u};
    sort(e+1,e+(m<<1|1),cmp);
    for(int i=1;i<=(m<<1|1);i++)ade(e[i].u,e[i].v);
    if(n==m)find(1,0);
    dfs(1,INF);
}
```

$O(n\log n)$，当然你也可以用双关键字计数排序做到$O(n)$...

---

## 作者：doer_ (赞：2)

# P5022 旅行（Tarjan）
同步发布于：[myCSDN](https://blog.csdn.net/weixin_46304837/article/details/109328954)
好像几乎没见有人用Tarjan做，那就发了一波题解
## 思路
怎么说这道题呢？看起来挺简单，但是细节问题很多。

先说说m=n-1的情况：就是把每个点的子节点按从小到大编号排序然后从1号点开始遍历即可，60分到手

麻烦的是m=n的情况：就是一棵基环树，大部分题解给的都是O(n^2^)的暴力枚举。由于我不大熟悉基环树，第一个想到的是Tarjan，结果92分（WA了两个点）搜题解都几乎没见过Tarjan的，但是以为用Tarjan的做法很简单就“独行其道”了，~~结果不知道掉了多少头发~~

说正事：
图就是一棵树再加上一条边，也就是有且只有一个环，普通的点很简单，按照m=n-1的方法即可，问题是和环有关的点，看图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201028113450257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjMwNDgzNw==,size_16,color_FFFFFF,t_70#pic_center)对于这个环，我们将第一个被访问的结点称为in结点，将环上已经被访问的结点标记为红色，它们的子结点标记为绿色，in的子结点（已排序）中(第一个 环上的点 的)下一个点（有点绕,前面括号是为了断句）记为y点
对于环上将要被访问的点，有几种选择：

 1. 访问
 2. 不访问，回溯到in点，并访问y点（条件：所有的绿点都己经被访问（否则绿点将无法到达））
 3. 不访问，回溯到红点，并访问该红点的未被访问的子结点（条件：沿路上所有红点的子结点均被访问（原因同上））

上面几种选择，当然是要先满足条件再看哪一个最优，判断：
变量说明x：当前结点（未访问），y：见上，z：从x点回溯到in的路上第一个未访问的绿点（其实这里表达不大好，绿点并不在该路径上，而是通过红点连接到环的旁边）
当z==-1时，z不存在，当y==（1<<29）时，表示曾经已经回溯到y点，当普通树处理即可
```cpp
	if(tar[x] != dfn[x] && y != (1 << 29)){
		if(z != -1){
			if(x > z)return;
		}
		else if(y != -1){
			if(x > y)return;
		}
	}
```
那么如何判断一个点在不在环上呢？这就需要tarjan了，不会的先自学，dfs序存储在dfn数组里，tar[]就是“追溯值”。当dfn[i]!=tar[i]时，i点在环上，特别地，dfn[in]==tar[in]这就需要我们给in点一些特殊待遇了。
## 代码
### 92分
其实比赛能拿到92已经很满意了
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <algorithm>
#include <vector>
#include <cstring>
#define nn 5010
using namespace std;
int read(){
	int re = 0 , sig = 1;
	char c;
	do
		if((c = getchar()) == '-')sig = -1;
	while(c < '0' || c > '9');
	while(c >= '0' && c <= '9'){
		re = (re << 1) + (re << 3) + c - '0';
		c = getchar();
	}
	return re;
}

int n , m;
bool vis[nn];
vector <int> son[nn];


void dfs(int x){
	vis[x] = true;
	printf("%d " , x);
	for(int i = 0 ; i < son[x].size() ; i++)
		if(!vis[son[x][i]])
			dfs(son[x][i]);
}
int dfn[nn] , tar[nn];
void tarjan(int x , int dep , int fa){
	if(dfn[x] != 0)
		return;
	tar[x] = dfn[x] = dep;
	for(int i = 0 ; i < son[x].size() ; i++){
		tarjan(son[x][i] , dep + 1 , x);
		if(tar[son[x][i]] < tar[x] && son[x][i] != fa)
			tar[x] = tar[son[x][i]];
	}
}
int y = -1;
void dfs2(int x) {
	if(x == y)
		y = (1 << 29);
//	cout << x << '\t' << y << endl;
	if(tar[x] != dfn[x]){
		if(y < x){
			return;
		}
	}
	
	vis[x] = true;
	printf("%d " , x);
	if(y == -1){
		for(int i = 0 ; i < son[x].size() ; i++){
			if(tar[son[x][i]] != dfn[son[x][i]])
				y = son[x][i];
		}
	}
		
		
	for(int i = 0 ; i < son[x].size() ; i++)
		if(!vis[son[x][i]])
			dfs2(son[x][i]);
}
int main(){
	n = read();	m = read();
	for(int i = 1 ; i <= m ; i++){
		int u , v;
		u = read() , v = read();
		son[u].push_back(v);
		son[v].push_back(u);
	}
	for(int i = 1 ; i <= n ; i++)
		sort(son[i].begin() , son[i].end());
	if(m == n - 1)
		dfs(1);
	else{
		tarjan(1 , 1 , 0);
//		for(int i = 1 ; i <= n ; i++)
//			cout << tar[i] << '\t';
//		cout << endl;
		memset(vis , 0 , sizeof(vis));
		dfs2(1);
	}
	return 0;
} 
```

### 100分
为了这8分掉了多少头发QAQ
说明：以下做法效率应该为O(n)，改一下数组大小依然可以通过洛谷数据加强版
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <algorithm>
#include <vector>
#include <cstring>
#define nn 5010
using namespace std;
int read(){
	int re = 0 , sig = 1;
	char c;
	do
		if((c = getchar()) == '-')sig = -1;
	while(c < '0' || c > '9');
	while(c >= '0' && c <= '9'){
		re = (re << 1) + (re << 3) + c - '0';
		c = getchar();
	}
	return re;
}

int n , m;
bool vis[nn];
int in;
vector <int> son[nn];

void dfs(int x){
	vis[x] = true;
	printf("%d " , x);
	for(int i = 0 ; i < son[x].size() ; i++)
		if(!vis[son[x][i]])
			dfs(son[x][i]);
}
int dfn[nn] , tar[nn];
int dep = 1;
void tarjan(int x , int fa){
	if(dfn[x] != 0)
		return;
	tar[x] = dfn[x] = dep++;
	for(int i = 0 ; i < son[x].size() ; i++){
		tarjan(son[x][i] , x);
		if(tar[son[x][i]] < tar[x] && son[x][i] != fa){
			if(tar[son[x][i]] == dfn[son[x][i]])
				in = son[x][i];
			tar[x] = tar[son[x][i]];
		}
	}
}
int y = -1;
void dfs2(int x , int z) {
	if(tar[x] != dfn[x] && y != (1 << 29)){
		if(z != -1){
			if(x > z)return;
		}
		else if(y != -1){
			if(x > y)return;
		}
	}
	if(x == y)
		y = (1 << 29);
//	cout << x << '\t' << y << '\t' << z <<endl;
	
	vis[x] = true;
	printf("%d " , x);

	if(y == -1){
		for(int i = 0 ; i < son[x].size() ; i++){
			if(tar[son[x][i]] != dfn[son[x][i]]){
				int j = i + 1;
				while(vis[son[x][j]])j++;
				y = son[x][j];
				break;
			} 
		}
	}//*/
	for(int i = 0 ; i < son[x].size() ; i++)
		if(!vis[son[x][i]]){
			if(dfn[son[x][i]] != tar[son[x][i]] && y != (1 << 29) && x != in){
				int j = i + 1;
				while(j < son[x].size() && (vis[son[x][j]] || dfn[son[x][j]] != tar[son[x][j]] || in == son[x][j])){
					j++;
					if(j >= son[x].size())break;
				}
				if(j < son[x].size())
					dfs2(son[x][i] , son[x][j]);
				else dfs2(son[x][i] , z);
			}
			else dfs2(son[x][i] , z);
		}
}
int main(){
	freopen("input.txt" , "r" , stdin);
	freopen("output.txt" , "w" , stdout);
	n = read();	m = read();
	for(int i = 1 ; i <= m ; i++){
		int u , v;
		u = read() , v = read();
		son[u].push_back(v);
		son[v].push_back(u);
	}
	for(int i = 1 ; i <= n ; i++)
		sort(son[i].begin() , son[i].end());
	if(m == n - 1)
		dfs(1);
	else{
		tarjan(1 , 0);
/*		for(int i = 1 ; i <= n ; i++)
			cout << tar[i] << '\t';
		cout << endl;
*/		memset(vis , 0 , sizeof(vis));
		dfs2(1 , -1);
	}
//	cout << in << endl;
	return 0;
} 
```

### 对拍文件
命名：

数据生成：random.cpp

对比：compare.cpp

待测程序（见上）：#4.cpp

std程序：std.cpp
#### 数据生成（针对m==n情况，修改下也可生成树）

```cpp
#include <bits/stdc++.h>
using namespace std;
int random(int r , int l = 1){//范围[l,r]l默认为1
	if(r == l)return l;
	return (long long)rand() * rand() % (r - l) + l;
}
pair<int , int>e[5010];
map<pair<int , int>,bool> h;

int dict[5010];
int main(){
	freopen("input.txt" , "w" , stdout);
	srand((unsigned)time(0));
	
	int n , m;
	n = m = 5000;//可以自调范围
	for(int i = 1 ; i <= n ; i++)
		dict[i] = i;
	random_shuffle(dict + 1 , dict + n + 1);
	
	for(int i = 2 ; i <= n ; i++){
		int fa = random(i - 1);
		e[i] = make_pair(fa , i);
		h[e[i]] = h[make_pair(i , fa)] = 1;
	}
	int x , y;
	do{
		x = random(n) , y = random(n);
	}
	while(x == y || h[make_pair(x , y)]);
	e[1] = make_pair(x , y);
	
	random_shuffle(e + 1 , e + m + 1);
	printf("%d %d\n" , n , m);
	for(int i = 1 ; i <= n ; i++){
		printf("%d %d\n" , dict[e[i].first] , dict[e[i].second]);
	}
	return 0;
}
/*
	freopen("input.txt" , "r" , stdin);
	freopen(".txt" , "w" , stdout);
	
*/
```

#### 自动对比程序

```cpp
#include <bits/stdc++.h>
#include <windows.h>
using namespace std;
int main(){
	while(true){
		system("start random.exe");
		Sleep(50);
		system("start #4.exe");
		system("start std.exe");
		Sleep(1500);
		if(system("fc output.txt ans.txt")){
			system("start input.txt");
			cout << "WA!!!" << endl;
			return 0;
		}
	}
	
	return 0;
}
```
#### std程序（来自NOI官网）

```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>

const int MAXN = 300005;

int n, m;

struct data {
	int u, v, id;
};

bool operator < (const data &a, const data &b) {
	return a.u < b.u || (a.u == b.u && a.v < b.v);
}

data _edges[MAXN * 2];
data *first[MAXN];

int ans[MAXN];
int dfsseq[MAXN];
int visit[MAXN];

int del_e;
int dfs_idx;
bool ok;
bool fail;

#define visit_id (del_e + 1)

void dfs(int x) {
	if (!ok) {
		if (x < ans[dfs_idx]) {
			ok = true;
		} else if (x > ans[dfs_idx]) {
			fail = true;
			return;
		}
	}
	dfsseq[dfs_idx++] = x;
	visit[x] = visit_id;
	for (data *d = first[x]; d->u == x; d++) if (d->id != del_e) {
		int y = d->v;
		if (visit[y] == visit_id) continue;
		dfs(y);
		if (fail) return;
	}
}



int main() {
	freopen("input.txt" , "r" , stdin);
	freopen("ans.txt" , "w" , stdout);
	scanf("%d%d", &n, &m);
	if (n == 1) {
		printf("1\n");
		return 0;
	}
	for (int i = 0; i < m; i++) {
		int u, v;
		scanf("%d%d", &u, &v);
		_edges[i * 2] = (data){u, v, i};
		_edges[i * 2 + 1] = (data){v, u, i};
	}
	std::sort(_edges, _edges + 2 * m);
	first[1] = _edges;
	for (int i = 1; i < 2 * m; i++) {
		if (_edges[i].u != _edges[i - 1].u) {
			first[_edges[i].u] = _edges + i;
		}
	}
	ans[0] = 2;
	if (n == m) {
		for (int i = 0; i < m; i++) {
			del_e = i;
			dfs_idx = 0;
			ok = false;
			fail = false;
			dfs(1);
			if (dfs_idx == n && ok && !fail) {
				memcpy(ans, dfsseq, n * sizeof(int));
			}
		}
	} else {
		del_e = -2;
		dfs(1);
		memcpy(ans, dfsseq, n * sizeof(int));
	}
	for (int i = 0; i < n; i++) {
		printf("%d ", ans[i]);
	}
}
```

---

## 作者：xcgang (赞：1)

做好这道题的标准版本（[P5022](https://www.luogu.org/problem/P5022)）。用的方法比较自然：

- 0. 做好最基础的m=n-1的字典序生成。
- 1. 找到环，用一个loop[n]数组记录；
- 2. 然后依次剪掉一个边，用m=n-1下的方法去生成，生成过程中比较是否比当前最优解差，如果差了，就结束这次的尝试。

在生成基础图的时候，采用vector<int> G[n] 方式，然后对每一个vector 排序。这样已经至少是**nlgn**的时间效率了吧。
  
找环，因为本质是树多一条边，没有用什么高级的算法，就是按照树的遍历dfs，第一次发现重入的点，就说明找到环了，而且这个点就是“环根”。
  
而之后对环，一次次的减边，至少得是 n2 的时间。所以无法通过P5049也很正常。
 



------------
  寻找改进的算法：
  - 1.找环的算法没有去优化；但是对环的表示方式，采用了 _in[n]_ 的数据结构。 in[i]=root, 表示第i点在环内（环根=root，整个算法环跟好像没有什么用）；
  - 找到环后，不再剪切。 直接dfs（r，fa，next），
      
  相比较搜索标准树，这次多传入一个参数：next，表示fa在访问完当前节点（r）后，准备访问的节点。通过这个next，实现了判断 r与fa（r的父节点）是否要断开。
  1. 环没有断过（因为只能断一次）；
  1. r与fa都在环上（不在环上的边断了，图就不联通）
  1. next<r,这个条件说明：把r与fa断开后，去访问next，结果更优。
  这样基本就完成了。需要的还是注意边界情况，就是一直没找到可以断开的边，那么会又一次访问“环根“，用vis，也好解决这个问题。
                                          ```c
#include<stdio.h>
#include<queue>
#include <cstring>
#include<algorithm>
using namespace std;
#define N  500001

vector<int>G[N];

int vis[N];
int in[N]; // 用来记录环， 如果点i在环里，则in[i]=root， root：环的第一个节点（环根）

int ans[N]; // 记录答案
int ansi=1;

int n,m;
void gadd(int a,int b)
{
    G[a].push_back(b);
    G[b].push_back(a);
}

int findloop(int r, int fa)  // fa : father 父节点，root： 环中的第一个点（环根）
{
    if (vis[r])  // 只会有一个节点，被两次访问，就是环根！
        return in[r]=r;
    vis[r] = 1;
    for (int i=0;i<G[r].size();i++)
    {
        if (G[r][i]!=fa)
        {
            int root = findloop(G[r][i],r);
            if (r==root) return 0 ;
            if (root) return in[r]=root;
        }
    }
    return 0 ;
}
int canback=1; // 只能回溯一次。回溯相当于把 r与fa的连接剪断了！
int dfs(int r,int fa,int next)// next 代表访问完r（以及r的子树）后下一个要访问的点，如果r有弟弟，则是第一个弟弟，如果没有弟弟，则是上一层传给fa的值。
{
    if (canback&&(vis[r]||(in[fa]&&in[r] && next<r))) // 只有r和fa都在环上，才可能允许减掉（回溯），只有下一步访问的点next比r小，才需要回溯（即当前不访问r了，今后通过从环的另外一边还是能访问到r的）,只有“环根“可能在第二次访问的时候，剪断。
        return canback=0;  // 剪断 r与fa， 其实就是啥事都不干（但得把允许回溯的标志清了）
    
    if (vis[r]) return 0 ;
    ans[ansi++]=r; vis[r]=1;
    
    for (int i=0;i<G[r].size();i++)
    {
        if (G[r][i]!=fa)
        {
            int nn = next;
            for (int j=i+1;j<G[r].size();j++)
                if (G[r][j]!=fa)
                {
                    nn = G[r][j];
                    break;
                }
            dfs(G[r][i],r,nn);
        }
    }
    return 0 ;
}


int main()
{
    memset(vis,0,sizeof vis);
    memset(in,0,sizeof in);
    scanf("%d%d",&n,&m);
    int u,v;
    for (int i=1;i<=m;i++)
    {
        scanf("%d%d",&u,&v);
        gadd(u,v);
    }
    
    for(int i=1;i<=n;i++)
        sort(G[i].begin(),G[i].end());
    
    if (m==n)
    {
        findloop(1,-1);
        memset(vis,0,sizeof vis);
    }

    dfs(1,-1,0);
    for(int i=1;i<=n;i++)
        printf("%d ",ans[i]);
    printf("\n");
    
    return 0 ;
}

```

  
  
  
  
  
  
  
 
  


---

## 作者：algo_h (赞：0)

此处提供一种思路较为简单，统一处理所有可能情况的非递归图遍历模拟+贪心解法。

对题中所给的图的邻接表排序后，如果该图是一颗无根树，直接深度优先遍历便可获得答案。如果该图比无根树多一条边，则先用 Tarjan 算法或直接 DFS 标记环上的所有节点。对环外的所有节点，沿用无根树的解法，以保证每个点均访问到；对环内的所有节点 $i$，由于允许切断环上的一条边，如果之前未跳过节点，且即将访问的邻接节点 $j$ 也在环上的话，我们基于以下这种统一的策略决定是否跳过 $j$：

* 如果跳过 $j$ 后，存在下一即将访问的节点 $k$（且之前未被访问过），且 $k < j$，则跳过
* 否则不跳过

考虑基于访问栈实现的非递归图遍历算法，约定栈顶的元素为当前即将访问的节点 $i$，访问 $i$ 后，根据前序遍历算法计算下一可访问节点 $j$。如果 $j$ 不存在，算法结束。如果 $j$ 存在，当前尚未拆环，且 $j$ 的父节点 $p$ 和 $j$ 均在环上，则尝试拆除 $p \to j$ 边：将 $j$ 弹出并计算下一可访问节点 $k$，如果 $k$ 不存在，则将 $j$ 压回栈内；如果 $k$ 存在且 $k < j$，我们贪心地跳过 $j$，将 $j$ 标记为未访问，访问 $k$ 并继续迭代；如果 $k$ 存在且 $k > j$，则不应在此拆环，此时将错误压栈的 $k$ 弹出，并压入 $j$，然后将 $k$ 加入 $j$ 邻接表的最后，恢复原有的访问顺序，访问 $j$ 并继续迭代。

如果不注意上述算法可能改变被访问节点的父节点，直接根据访问栈确定父节点，则只能得到 88 分。正确的处理策略是：对于被加入 $j$ 邻接表的 $k$ 节点，我们先保留其原有的父节点，除非在访问**这条新增的** $j \to k$ 边（不包含图中可能原有的 $j \to k$ 边）前，算法通过图中原有的其他边访问到 $k$ 节点时，更新 $k$ 的父节点，否则该父节点保持不变。以上方才完全撤销了迭代遍历算法中包含的所有可能对答案产生影响的副作用。

该算法虽思路较为简单，但撤销错误访问时引入的重排操作可能带来约 $\times 2$ 的常数开销，故性能不如无副作用预测 $k$ 的思路较为复杂的其他算法。

```c++
#include <algorithm>
#include <iostream>
#include <stack>
#include <vector>

using namespace std;

// 本题输入
int n, m;
vector<vector<int>> neigh;  // 输入后对每个数组升序排序

// 无根树特解
void solve_tree(int i, int p = -1)
{
  cout << i + 1 << ' ';
  for(int j : neigh[i]) {
    if(j == p) continue;
    solve_tree(j, i);
  }
}

// tarjan 算法变量
vector<int> dfn, low, loop;
stack<int> stk;

// tarjan 边双连通算法找环
void tarjan(int i, int p = -1)
{
  stk.push(i);
  static int seq;
  dfn[i] = low[i] = seq++;

  for(int j : neigh[i]) {
    if(j == p) continue;
    if(dfn[j] < 0) {
      tarjan(j, i);
      low[i] = min(low[i], low[j]);
    } else {
      low[i] = min(low[i], dfn[j]);
    }
  }
  if(dfn[i] != low[i]) return;
  if(stk.top() == i) return stk.pop();  // 单点非环

  for(;;) {  // 多点成环，进入 loop 数组的顺序为搜索序的逆序
    int j = stk.top();
    stk.pop();
    loop.push_back(j);
    if(j == i) break;
  }
}

// 迭代遍历算法变量
vector<bool> looped;   // 每个点是否在环上
vector<int> idx, par;  // 每个点的遍历进度和父节点编号，初始时均为 -1
vector<int> parfix;  // i -> 父节点不是 i 的第一个“子节点”在 neigh[i] 中的下标，初始化为越界值 n

// 可干预非递归图遍历算法
bool next()
{
  while(!stk.empty()) {
    int i = stk.top();
    while(idx[i] < (int)neigh[i].size() && idx[neigh[i][idx[i]]] >= 0) ++idx[i];
    if(idx[i] == (int)neigh[i].size()) {  // 无剩余可访问的子节点
      stk.pop();                          // 回溯
      continue;
    }
    idx[neigh[i][idx[i]]] = 0;   // 表示访问 neigh[i][idx[i]] 之后从下标 0 开始搜索子节点
    stk.push(neigh[i][idx[i]]);  // 当前访问的节点变为 neigh[i][idx[i]]
    // 见 solve()，如果 idx[i] >= parfix[i]，表示 neigh[i][idx[i]] 的父节点并非 i，而是之前已经确定
    if(par[stk.top()] < 0 || idx[i] < parfix[i]) par[stk.top()] = i;
    ++idx[i];  // 更新当前节点父节点的访问进度
    return true;
  }
  return false;
}

// 干预 next() 的执行，贪心拆环，最小化字典序
void solve()
{
  bool loop_broken = false;  // 环只能拆一次
  looped.assign(n, false);
  for(int i = 0; i < (int)loop.size(); ++i) looped[loop[i]] = true;
  idx.assign(n, -1), par.assign(n, -1), parfix.assign(n, n);

  // 遍历从编号最小的节点开始
  int i = 0;
  idx[i] = 0;
  stk.push(i);
  cout << i + 1 << ' ';

  while(next()) {
    int j = stk.top();  // 当前访问的节点编号

    // 拆环算法（干预 next() 原本的深度优先策略）
    if(!loop_broken && looped[par[j]] && looped[j]) {
      stk.pop();     // 尝试跳过 j，实现拆环
      if(!next()) {  // 无后续元素，不可跳过
        stk.push(j);
      } else {
        int k = stk.top();  // 后续元素
        if(j < k) {         // 跳过后字典序增大，撤销跳过
          stk.pop();        // 将 k 出栈并标记为未访问，但保留其祖先 par[k]
          idx[k] = -1;
          stk.push(j);  // 恢复原定当前访问元素 j，并把 k 添加为 j 的子节点，推迟 k 的访问
          // “固定” k 的祖先，避免其意外地成为 j；只有 k 通过其他原有图边被先访问到，k 的祖先才发生改变
          // parfix[j] 后的“子节点”祖先均被“固定”
          parfix[j] = min(parfix[j], (int)neigh[j].size());
          neigh[j].push_back(k);
        } else {                 // 跳过后字典序减小，应当跳过
          loop_broken = true;    // 打拆环标记
          idx[j] = par[j] = -1;  // 撤销对 j 的访问记录
          j = k;                 // 将当前访问的节点改成 k
        }
      }
    }

    cout << j + 1 << ' ';
  }
}

int main()
{
  cin.tie(0)->sync_with_stdio(0);
  cin >> n >> m;
  neigh.resize(n);
  for(int i = 0; i < m; ++i) {
    int u, v;
    cin >> u >> v, --u, --v;
    neigh[u].push_back(v);
    neigh[v].push_back(u);
  }
  for(int i = 0; i < n; ++i) sort(neigh[i].begin(), neigh[i].end());
  if(m == n - 1) {
    solve_tree(0), cout << endl;
    return 0;
  }
  dfn.assign(n, -1), low.assign(n, -1);
  for(int i = 0; i < n; ++i) {
    if(dfn[i] >= 0) continue;
    tarjan(i);
    if(!loop.empty()) break;
  }
  solve(), cout << endl;
  return 0;
}
```

---


# [JLOI2015] 城池攻占

## 题目描述

小铭铭最近获得了一副新的桌游，游戏中需要用 $m$ 个骑士攻占 $n$ 个城池。

这 $n$ 个城池用 $1$ 到 $n$ 的整数表示。除 $1$ 号城池外，城池 $i$ 会受到另一座城池 $f_i$ 的管辖，其中 $f_i<i$。也就是说，所有城池构成了一棵有根树。 

这 $m$ 个骑士用 $1$ 到 $m$ 的整数表示，其中第 $i$ 个骑士的初始战斗力为 $s_i$，第一个攻击的城池为 $c_i$。

每个城池有一个防御值 $h_i$，如果一个骑士的战斗力大于等于城池的生命值，那么骑士就可以占领这座城池；否则占领失败，骑士将在这座城池牺牲。占领一个城池以后，骑士的战斗力将发生变化，然后继续攻击管辖这座城池的城池，直到占领 $1$ 号城池，或牺牲为止。

除 $1$ 号城池外，每个城池 $i$ 会给出一个战斗力变化参数 $(a_i,v_i)$。若 $a_i=0$，攻占城池 $i$ 以后骑士战斗力会增加 $v_i$；若 $a_i=1$，攻占城池 $i$ 以后，战斗力会乘以 $v_i$。

注意每个骑士是单独计算的。也就是说一个骑士攻击一座城池，不管结果如何，均不会影响其他骑士攻击这座城池的结果。

现在的问题是，对于每个城池，输出有多少个骑士在这里牺牲；对于每个骑士，输出他攻占的城池数量。

## 说明/提示

对于 $100\%$ 的数据，$1\le n,m\le 3\times 10^5$，$
-10^{18}\le h_i,v_i,s_i\le 10^{18}$，$1\le f_i<i,1\le c_i\le n,a_i\in\{0,1\}$，保证 $a_i=1$ 时，$v_i>0$，保证任何时候骑士战斗力值的绝对值不超过 $10^{18}$。


## 样例 #1

### 输入

```
5 5
50 20 10 10 30
1 1 2
2 0 5
2 0 -10
1 0 10
20 2
10 3
40 4
20 4
35 5```

### 输出

```
2
2
0
0
0
1
1
3
1
1```

# 题解

## 作者：George1123 (赞：82)

[${\color{#00cc77}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.com.cn/blog/Wendigo/)

[P3261 【\[JLOI2015\]城池攻占】](https://www.luogu.com.cn/problem/P3261)

### 此题算法:左偏树-可并堆+标记下传

调了$3$天，平均每天$1$小时。

不要看我代码长，处处都是**错点**啊！

![knight.jpg](https://i.loli.net/2019/12/18/9Ovmny2C1HgZ87B.jpg)

**看到这题，就知道该这么做：**

从下到上遍历树，一直拿单前节点上的骑士团中最蒻的看看会不会死在这里，再把没死的放到父亲节点上去，并改变他们的战斗力。

**所以可以得出此题算法是：**

**~~luogu标签~~$+$最蒻$+$放到父亲节点$=$左偏树**

可是骑士的能力是会变的，凡是**树上批量修改**需要**标记下传**

**大致思路：**

先**开数组(真QwQ多)：**

```cpp
int fa[N],c[N],a[N],rt[N]; //树上父亲,出生地,城池能力改变方式,每个城池上骑士团左偏树的根
lng h[N],v[N],s[N]; //城池防御力,城池能力改变值,骑士能力初始值
int ls[N],rs[N],dep[N]; //堆中左子,右子,树高
int Dep[N],die[N],ans[N]; //树上深度,骑士死亡位置,城池死亡骑士数
lng add[N],tim[N]; //骑士能力变化标记(+,*)
```
再**操作：**

先将**同出生城池**的骑士合并为一堆。

再从$n$到$1$遍历树上城池，不停取单前城池节点**小根堆**顶。

如果**小于城池防御力**就判之死，去除堆顶。

否则跳出寻找，**如果该堆已经为空，去找下一个节点**。

如果堆不空，利用**标记**改变该堆骑士能力值。

并将骑士团合并到父亲节点骑士团。



```cpp
for(int i=n;i>=1;i--){ //从下到上
	while(rt[i]!=-1){ //只要单前堆不空
		if(s[rt[i]]<h[i]){ //小于城池防御值
			die[rt[i]]=i; //判之死
			pushdown(rt[i]); //一时pushdown一时爽
			if(!ls[rt[i]]) rt[i]=-1; 
			else rt[i]=merge(ls[rt[i]],rs[rt[i]]); //去除堆顶
		} else break; //剩下的不死
	}
	if(i==1) break; //根特判
	if(rt[i]==-1) continue; //否则MLE
	if(a[i]) tim[rt[i]]*=v[i],add[rt[i]]*=v[i],s[rt[i]]*=v[i];
	else add[rt[i]]+=v[i],s[rt[i]]+=v[i];
	//利用标记，修改该堆骑士能力值
	pushdown(rt[i]); //一直pushdown一直爽
	if(rt[fa[i]]==-1) rt[fa[i]]=rt[i];
	else rt[fa[i]]=merge(rt[fa[i]],rt[i]); //父亲城池等待着幸存的骑士
}
```
**$pushdown()$：根据单前标记，先改左右子树能力值，再改左右子树标记值，最后清空单前节点标记。**

**合并堆$merge()$：这是左偏树的~~全部~~精华，不会去模板题学。**

**清空标记：加标记为$0$，乘标记为$1$。**


这之后，再令每个$ans[die[i]]++$，就只剩输出了。

**先输出$n$个$ans[i]$，再输出$m$个$Dep[c[i]]-Dep[die[i]]$。**


## 以下是代码+注释

```cpp
#include <bits/stdc++.h>
using namespace std;
#define lng long long
const int N=3e5+10; //It's turly fat
int n,m;
int fa[N],c[N],a[N],rt[N]; //树上父亲,出生地,城池能力改变方式,每个城池上骑士团左偏树的根
lng h[N],v[N],s[N]; //城池防御力,城池能力改变值,骑士能力初始值
int ls[N],rs[N],dep[N]; //堆中左子,右子,树高
int Dep[N],die[N],ans[N]; //树上深度,骑士死亡位置,城池死亡骑士数
lng add[N],tim[N]; //骑士能力变化标记(+,*)
void pushdown(int x){ //标记下传
	if(add[x]==0&&tim[x]==1)
		return;
	if(ls[x]){
		tim[ls[x]]*=tim[x];
		add[ls[x]]*=tim[x];
		add[ls[x]]+=add[x];
		s[ls[x]]*=tim[x];
		s[ls[x]]+=add[x];
	} 
	if(rs[x]){
		tim[rs[x]]*=tim[x];
		add[rs[x]]*=tim[x];
		add[rs[x]]+=add[x];
		s[rs[x]]*=tim[x];
		s[rs[x]]+=add[x];
	}
	add[x]=0,tim[x]=1;
}
int merge(int x,int y){ //合并堆
	if(!x||!y) return x^y;
	pushdown(x),pushdown(y);
	if(s[x]>s[y]) swap(x,y);
	rs[x]=merge(rs[x],y);
	if(dep[ls[x]]<dep[rs[x]])
		swap(ls[x],rs[x]);
	dep[x]=dep[ls[x]]+1;
	return x;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld",h+i);
		rt[i]=-1; //设为空
	}
	Dep[1]=1,dep[0]=-1;
	for(int i=2;i<=n;i++){
		scanf("%d%d%lld",fa+i,a+i,v+i);
		Dep[i]=Dep[fa[i]]+1; //不用dfs求Dep
	}
	for(int i=1;i<=m;i++){
		scanf("%lld%d",s+i,c+i);
		tim[i]=1; //It's very important!
		if(rt[c[i]]==-1) rt[c[i]]=i;
		else rt[c[i]]=merge(rt[c[i]],i); //合并同城骑士
	}
	for(int i=n;i>=1;i--){ //从下到上
		while(rt[i]!=-1){ //只要单前堆不空
			if(s[rt[i]]<h[i]){ //小于城池防御值
				die[rt[i]]=i; //判之死
				pushdown(rt[i]); //一时pushdown一时爽
				if(!ls[rt[i]]) rt[i]=-1;
				else rt[i]=merge(ls[rt[i]],rs[rt[i]]);
			} else break; //剩下的不死
		}
		if(i==1) break; //根特判
		if(rt[i]==-1) continue; //否则MLE
		if(a[i]) tim[rt[i]]*=v[i],add[rt[i]]*=v[i],s[rt[i]]*=v[i];
		else add[rt[i]]+=v[i],s[rt[i]]+=v[i];
		//利用标记，修改该堆骑士能力值
		pushdown(rt[i]); //一直pushdown一直爽
		if(rt[fa[i]]==-1) rt[fa[i]]=rt[i];
		else rt[fa[i]]=merge(rt[fa[i]],rt[i]); //父亲城池等待着幸存的骑士
	}
	for(int i=1;i<=m;i++)
		ans[die[i]]++; 
	for(int i=1;i<=n;i++)
		printf("%d\n",ans[i]); //输出，结束
	for(int i=1;i<=m;i++)
		printf("%d\n",Dep[c[i]]-Dep[die[i]]);
	return 0;
}

```

**几个恐怖的错误：**

**top 4** $tim[]$数组在$1-n$的循环中初始化。

**top 3** 不初始化$dep[0]=-1$。

**top 2** 不在加标记的同时改$s[]$数组。

**top 1** 不特判骑士死光的情况(莫名MLE极其恐怖)。

**写题解不易，快点个赞吧。**

谢谢大家 ! !


---

## 作者：amazingOZR (赞：31)

考虑dfs后从叶子往根递推。对于处理每个节点时，首先要把从所有孩子爬上来的一大坨士兵整合成一坨，然后把里面小于h的全部挑出来。很容易想到要用可并堆，维护每个节点孩子爬上来的士兵的攻击力最小值。

所以每个节点建一颗左偏树，初始时把所有在那里的士兵塞进去，每次处理时一直pop，更新在这个节点死掉的士兵和这个士兵爬的层数，直到堆顶≥h。更新这些士兵能力值时，在根节点上打一个乘法tag和一个加法tag就行了。记得pushdown的时候加法tag也要乘上父亲的乘法tag。

复杂度：初始插入所有士兵为mlogm。每个士兵最多被带上n层，为nm。每个士兵只会被弹出一次，mlogm。所以总复杂度O(mn+mlogm)。

代码：

```cpp
#include<cstdio>
#include<cstring>
typedef long long ll;
const int maxn=300005,maxe=300005;
int lc[maxn],rc[maxn],dis[maxn],ans1[maxn],ans2[maxn],head[maxn],to[maxe],next[maxe],rt[maxn],dep[maxn],c[maxn],n,m,cnt,f,a,ch;
ll v[maxn],add[maxn],mul[maxn],h[maxn],val[maxn];
bool Mul[maxn];
void swap(int&a,int&b){int c=a;a=b,b=c;}
void insert(int a,int b){to[cnt]=b,next[cnt]=head[a];head[a]=cnt++;}
ll read()
{
    ll x=0;int f=1;ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*f;
}
void cov(int x,ll c,ll j)
{
    if(!x)return;
    v[x]*=c,v[x]+=j;
    mul[x]*=c;add[x]*=c;add[x]+=j;
}
void pushdown(int x)
{
    cov(lc[x],mul[x],add[x]);
    cov(rc[x],mul[x],add[x]);
    mul[x]=1;add[x]=0;
}
int merge(int a,int b)
{
    if(!a||!b)return a+b;
    pushdown(a);pushdown(b);
    if(v[a]>v[b])swap(a,b);
    rc[a]=merge(rc[a],b);
    if(dis[lc[a]]<dis[rc[a]])swap(lc[a],rc[a]);
    dis[a]=dis[rc[a]]+1;
    return a;
}
void dfs(int u,int fa)
{
    dep[u]=dep[fa]+1;
    for(register int i=head[u],V=to[i];~i;V=to[i=next[i]])dfs(V,u),rt[u]=merge(rt[u],rt[V]);
    while(rt[u]&&v[rt[u]]<h[u])
    {
        pushdown(rt[u]);
        ++ans1[u];ans2[rt[u]]=dep[c[rt[u]]]-dep[u];
        rt[u]=merge(lc[rt[u]],rc[rt[u]]);
    }
    if(Mul[u])cov(rt[u],val[u],0);
    else cov(rt[u],1,val[u]);
}
int main()
{
    memset(head,-1,sizeof head);
    dis[0]=-1;
    n=read(),m=read();
    for(register int i=1;i<=n;++i)h[i]=read();
    for(register int i=2;i<=n;++i)
    {
        f=read(),a=read(),val[i]=read();
        Mul[i]=a;insert(f,i);
    }
    for(register int i=1;i<=m;++i)
    {
        v[i]=read();c[i]=read();
        mul[i]=1;
        rt[c[i]]=merge(rt[c[i]],i);
    }
    dfs(1,0);
    while(rt[1])pushdown(rt[1]),ans2[rt[1]]=dep[c[rt[1]]],rt[1]=merge(lc[rt[1]],rc[rt[1]]);
    for(register int i=1;i<=n;++i)printf("%d\n",ans1[i]);
    for(register int i=1;i<=m;++i)printf("%d\n",ans2[i]);
    return 0;
}

```

---

## 作者：__Ressed__ (赞：19)

竟然没有倍增的题解，那么我来口胡一份

首先发现乘的时候 系数不会为负，所以能得到一个关键条件：变化后的战斗力随变化前的战斗力大小单调

所以我们考虑倍增

设hp[x][i]是从x开始一路攻克$2^i$个城池所需要最小的初始生命值

设trans[x][i][0/1]是攻克了$2^i$个城池后攻击力的变化量，0表示乘，1表示加，先乘后加

注意乘的系数初始化成1

~~然后就可以倍增了~~

然而空间大小恶意卡倍增

但是我们这个倍增可以换成三进制的2333

就是把定义里的$2^i$都换成$3^i$

于是$log_3300000=10$，空间就变成了原来的一半

需要注意的一点是，最后在跳倍增的时候，同一个长度可以跳两次（因为是三进制嘛），循环的时候稍微注意一下

```cpp
#include<bits/stdc++.h>
#define pa pair<ll,ll>
#define CLR(a,x) memset(a,x,sizeof(a))
#define MP make_pair
using namespace std;
typedef long long ll;
const int maxn=3e5+5;

inline char gc(){
	return getchar();
	static const int maxs=1<<16;static char buf[maxs],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,maxs,stdin),p1==p2)?EOF:*p1++;
}
inline ll rd(){
    ll x=0;char c=gc();bool neg=0;
    while(c<'0'||c>'9'){if(c=='-') neg=1;c=gc();}
    while(c>='0'&&c<='9') x=(x<<1)+(x<<3)+c-'0',c=gc();
    return neg?(~x+1):x;
}

int N,M,fa[maxn][11];
ll hp[maxn][11],trans[maxn][11][2];
int ans1[maxn],ans2[maxn];
int pw3[11];

int main(){
    //freopen("","r",stdin);
    int i,j,k;
    pw3[0]=1;for(i=1;i<=10;i++) pw3[i]=pw3[i-1]*3;
    N=rd(),M=rd();
    for(i=1;i<=N;i++) hp[i][0]=rd();
    fa[1][0]=N+1;
    for(i=2;i<=N;i++){
    	fa[i][0]=rd();
    	ll x=rd(),y=rd();
    	trans[i][0][0]=1;
    	trans[i][0][!x]=y;
    	for(j=0;j<10;j++){
    		int f=fa[i][j],ff=fa[f][j];
    		if(!f||!ff||!fa[ff][j]) break;
    		fa[i][j+1]=fa[ff][j];
    		ll hp1=max(hp[f][j],(ll)ceil(1.0*(hp[ff][j]-trans[f][j][1])/trans[f][j][0]));
    		hp[i][j+1]=max(hp[i][j],(ll)ceil(1.0*(hp1-trans[i][j][1])/trans[i][j][0]));
    		trans[i][j+1][1]=trans[i][j][1]*trans[f][j][0]+trans[f][j][1];
    		trans[i][j+1][0]=trans[i][j][0]*trans[f][j][0];
    		trans[i][j+1][1]=trans[i][j+1][1]*trans[ff][j][0]+trans[ff][j][1];
    		trans[i][j+1][0]=trans[i][j+1][0]*trans[ff][j][0];
    	}
    }
    for(i=1;i<=M;i++){
    	ll s=rd();int x=rd(),n=0;
    	for(j=10;j>=0&&x!=-1;j--){
    		if(fa[x][j]&&hp[x][j]<=s){
    			s=s*trans[x][j][0]+trans[x][j][1];
    			x=fa[x][j];
    			n+=pw3[j];j++;
    		}
    	}
    	if(x!=-1) ans1[x]++;
    	ans2[i]=n;
    }
    for(i=1;i<=N;i++)
    	printf("%d\n",ans1[i]);
    for(i=1;i<=M;i++)
    	printf("%d\n",ans2[i]);
    
    return 0;
}
```

---

## 作者：Soulist (赞：12)

$how ~to~ do~ it?$

--------------

#### 一、比较$naive$的想法

我们对每个人模拟，这个做法复杂度$O(nm)$，难以利用数据结构优化

---------------------------

#### 所以我们为何不转变一下思路呢？

我们对每个树上的节点考虑，对每个节点维护一下有多少个骑士现在被卡在它这里。以及这些骑士到达这里时的权值。

那么一个骑士不能再走说明其权值小于此节点的$h$值，我们考虑用一个数据结构维护一下被卡在当前节点的骑士的集合，并且兹娃查询最小值，如果最小值小于当前节点$h$我们就将它弹出好了。

然后对于一个节点，我们每次将之与通过其儿子的骑士集合并，这样看来我们需要一个支持合并和查询最小值的数据结构，可并堆-左偏树好了。

（上述过程通过做一遍dfs实现）

然而这道毒瘤的题目还有修改，每次都要给通过这里的所有骑士留下一道坎。

那么我们就给整个堆打上标记好了，维护一个乘法标记和加法标记。

注意特判标记下传的顺序和通过一号点的点集

---------------------

#### 复杂度相关？

注意到每个骑士最多弹入和弹出一次，所以弹出骑士的总复杂度是$O(m\log m)$

每个节点会被且仅被其父亲合并一次，所以合并的总复杂度$O(n \log m)$

复杂度$O((n+m)\log m)$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next ) 
#define re register
#define ls(x) t[x].son[0]
#define rs(x) t[x].son[1]
#define int long long
int read() {
    char cc = getchar(); int cn = 0, flus = 1;
    while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
    while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
    return cn * flus;
}
const int N = 300000 + 5  ;
struct Tr {
    int son[2], val, dis, fr, add, mul ;
} t[N]; 
struct E { 
    int to, next ; 
} e[N * 2]; 
int n, m, cnt ; 
int h[N], rt[N], a[N], v[N], head[N], s[N], dis[N], ans[N], num[N] ;
void add( int x, int y ) {
    e[++ cnt] = (E){ y, head[x] }, head[x] = cnt ; 
}
void col( int x, int ad, int mu ) {
	if( !x ) return ; 
	t[x].val *= mu, t[x].val += ad ; 
	t[x].mul *= mu, t[x].add *= mu, t[x].add += ad ; 
}
void pushup( int x ) {
    col( ls(x), t[x].add, t[x].mul ) ;
    col( rs(x), t[x].add, t[x].mul ) ; 
    t[x].add = 0, t[x].mul = 1 ; 
}
int merge( int x, int y ) {
    if( !x || !y ) return x + y ; 
    pushup(x), pushup(y) ; 
    if( t[x].val > t[y].val ) swap( x, y ) ; 
    rs(x) = merge( rs(x), y ) ; 
    if( t[rs(x)].dis > t[ls(x)].dis ) swap( ls(x), rs(x) ) ; 
    t[x].dis = t[rs(x)].dis + 1 ; return x ; 
} 
int Del( int x ) {
    pushup(x); return merge( ls(x), rs(x) ) ; 
}
void solve( int x ) {
    while( t[rt[x]].val < h[x] && rt[x] ) {
        ans[rt[x]] = dis[t[rt[x]].fr] - dis[x] ; 
        rt[x] = Del( rt[x] ), ++ num[x] ; 
    }
}
void input() {
    n = read(), m = read() ; int x; t[0].dis = -1 ;
    rep( i, 1, n ) h[i] = read() ; 
    rep( i, 2, n ) x = read(), add( x, i ), a[i] = read(), v[i] = read() ; 
    rep( i, 1, m ) t[i].val = read(), t[i].fr = x = read(), t[x].mul = 1, 
                   rt[x] = merge( rt[x], i ), t[i].dis = 1;
}
void dfs( int x, int f ) {
    dis[x] = dis[f] + 1 ;
    Next( i, x ) {
        int v = e[i].to ;
        dfs( v, x ), rt[x] = merge( rt[x], rt[v] ) ;
    }
    solve(x) ;
    if( a[x] ) col( rt[x], 0, v[x] ) ;
    else col( rt[x], v[x], 1 ) ; 
}
void output() {
	while( rt[1] ) ans[rt[1]] = dis[t[rt[1]].fr], rt[1] = Del( rt[1] );
    rep( i, 1, n ) printf("%d\n", num[i] ) ;
    rep( i, 1, n ) printf("%d\n", ans[i] ) ; 
}
signed main()
{
    input(), dfs( 1, 1 ), output() ;
    return 0;
}
```

---

## 作者：XuYueming (赞：6)

## 题目分析
其他人要么倍增，要么左偏树，那我就来讲讲朴实无华的 dfs 序加上线段树的做法。

首先发现题目中明确指出了作乘法的时候一定是乘上一个大于零的数，这是为什么呢？首先把可以占领当前城池的战斗力的不等式列出来：
$$
h_j \le \left\{
\begin{array}{c}
s_i \times v_j & & {a_j = 1}\\
s_i + v_j & & {a_j=0}
\end{array}
\right.
$$
发现当 $v_j > 0$ 时，不等式不会变号，得到如下式子：
$$
s_i \ge \left\{
\begin{array}{c}
\cfrac{h_j}{v_j} & & {a_j = 1}\\
h_j - v_j & & {a_j=0}
\end{array}
\right.
$$
于是，我们发现，判断一大堆骑士能不能占领只用看其中的最小血量是否满足要求就行了。但是代码实现的时候为了避免丢失精度，不使用浮点数比较。对于当前城池，我们要知道起子树内所有能跳到这里来的骑士的最小血量，删去牺牲在这里的骑士，将留下来的骑士血量按照题意操作，在往上跳一步。子树的问题可以用 dfs 序转变成一个区间上的问题，区间最小值、区间乘、区间加、单点删除，明显可以用线段树维护。删除的时候将其战斗力设为 $\infty$ 就不会对之后的造成影响。时间复杂度 $\Theta(n \log n)$，令 $n$ 和 $m$ 同阶。

实际代码实现起来码量很大？细节需要处理到位，特别是这题 dfs 序记的不是结点，而是士兵，所以会略有不同，具体见代码。
## 代码（已略去快读快写，码风清新，注释详尽）
### dfs 序
```cpp
//#pragma GCC optimize(3)
//#pragma GCC optimize("Ofast", "inline", "-ffast-math")
//#pragma GCC target("avx", "sse2", "sse3", "sse4", "mmx")
#include <iostream>
#include <cstdio>
#define debug(a) cerr << "Line: " << __LINE__ << " " << #a << endl
#define print(a) cerr << #a << "=" << (a) << endl
#define file(a) freopen(#a".in", "r", stdin), freopen(#a".out", "w", stdout)
#define main Main(); signed main(){ return ios::sync_with_stdio(0), cin.tie(0), Main(); } signed Main
using namespace std;

#include <vector>

const int N = 300010;
const long long inf = 0x3f3f3f3f3f3f3f3fll;

int n, m;
vector<int> edge[N], man[N];
int ans1[N], ans2[N];
// 对于 ans2，转变成初始位置深度 - 死亡位置深度，根节点深度 1，没死的当做在深度为 0 的地方死了

int op[N], dpt[N];
long long h[N], v[N], s[N];

int L[N], R[N], val[N], timer;

void dfs(int now){
	L[now] = timer + 1;
	for (auto x: man[now]) val[++timer] = x;
	for (auto to: edge[now]) dfs(to);
	R[now] = timer;
}

// dfs 序记录子树所有士兵

struct Segment_Tree{
	#define lson (idx << 1    )
	#define rson (idx << 1 | 1)
	
	struct Tag{
		long long mul, add;
		Tag operator + (const Tag & o) const {
			return {mul * o.mul, add * o.mul + o.add};
		}
		inline void clear(){
			mul = 1, add = 0;
		}
	};
	// 懒惰标记
	
	struct Info{
		long long minn;
		int pos;
		Info operator + (const Info & o) const {
			if (minn == inf) return o;
			if (o.minn == inf) return *this;
			if (minn < o.minn) return *this;
			return o;
		}
		Info operator + (const Tag & o) const {
			if (minn == inf) return *this;
			return {minn * o.mul + o.add, pos};
		}
	};
	// 信息
	
	struct node{
		int l, r;
		Info info;
		Tag tag;
	} tree[N << 2];
	
	void pushup(int idx){
		tree[idx].info = tree[lson].info + tree[rson].info;
	}
	
	void build(int idx, int l, int r){
		tree[idx] = {l, r, inf, -1, 1, 0};
		if (l == r) return tree[idx].info = {s[val[l]], l}, void();
		int mid = (l + r) >> 1;
		build(lson, l, mid), build(rson, mid + 1, r), pushup(idx);
	}
	
	void pushtag(int idx, const Tag t){
		tree[idx].info = tree[idx].info + t;
		tree[idx].tag = tree[idx].tag + t;
	}
	
	void pushdown(int idx){
		pushtag(lson, tree[idx].tag), pushtag(rson, tree[idx].tag);
		tree[idx].tag.clear();
	}
	
	Info query(int idx, int l, int r){
		if (tree[idx].l > r || tree[idx].r < l) return {inf, -1};
		if (l <= tree[idx].l && tree[idx].r <= r) return tree[idx].info;
		return pushdown(idx), query(lson, l, r) + query(rson, l, r);
	}
	
	void modify(int idx, int l, int r, const Tag t){
		if (tree[idx].l > r || tree[idx].r < l) return;
		if (l <= tree[idx].l && tree[idx].r <= r) return pushtag(idx, t);
		pushdown(idx), modify(lson, l, r, t), modify(rson, l, r, t), pushup(idx);
	}
	
	void erase(int pos){
		modify(1, pos, pos, {0, inf});
	}
	
	void add(int l, int r, long long v){
		modify(1, l, r, {1, v});
	}
	
	void mul(int l, int r, long long v){
		modify(1, l, r, {v, 0});
	}
	
	void output(int idx){
		if (tree[idx].l == tree[idx].r){
			cerr << (tree[idx].info.minn == inf ? -1 : tree[idx].info.minn) << " \n"[tree[idx].l == timer];
			return;
		}
		pushdown(idx), output(lson), output(rson);
	}
	
	#undef lson
	#undef rson
} yzh;
// 貌似就是线段树 2 ？

void redfs(int now){
	if (L[now] > R[now]) return;
	for (auto to: edge[now]) redfs(to);
//	yzh.output(1);
	while (true){
		// 不断删去死了的士兵，注意到士兵最多删 m 次，故不会超时
		Segment_Tree::Info res = yzh.query(1, L[now], R[now]);
		if (res.pos == -1 || res.minn == inf) break;
		if (res.minn >= h[now]) break;
		ans2[val[res.pos]] -= dpt[now], yzh.erase(res.pos), ++ans1[now];
//		yzh.output(1);
	}
	if (op[now]) yzh.mul(L[now], R[now], v[now]);
	else         yzh.add(L[now], R[now], v[now]);
}
// 第二次深搜求得答案

signed main(){
	dpt[1] = 1, read(n, m);
	for (int i = 1; i <= n; ++i) read(h[i]);
	for (int i = 2, fa; i <= n; ++i) read(fa, op[i], v[i]), edge[fa].push_back(i), dpt[i] = dpt[fa] + 1;
	for (int i = 1, pos; i <= m; ++i) read(s[i], pos), man[pos].push_back(i), ans2[i] = dpt[pos];
	dfs(1), yzh.build(1, 1, timer), redfs(1);
	for (int i = 1; i <= n; ++i) write(ans1[i], '\n');
	for (int i = 1; i <= m; ++i) write(ans2[i], '\n');
	return 0;
}
```
### 倍增（虽然没讲，但是也给出吧？）
```cpp
//#pragma GCC optimize(3)
//#pragma GCC optimize("Ofast", "inline", "-ffast-math")
//#pragma GCC target("avx", "sse2", "sse3", "sse4", "mmx")
#include <iostream>
#include <cstdio>
#define debug(a) cerr << "Line: " << __LINE__ << " " << #a << endl
#define print(a) cerr << #a << "=" << (a) << endl
#define file(a) freopen(#a".in", "r", stdin), freopen(#a".out", "w", stdout)
#define main Main(); signed main(){ return ios::sync_with_stdio(0), cin.tie(0), Main(); } signed Main
using namespace std;

int n, m;
int op[300010];

int ans1[300010], ans2[300010];

int yzh[300010][20];
long long add[300010][20], mul[300010][20];
long long L[300010][20];

signed main(){
	read(n, m);
	for (int i = 1; i <= n; ++i) read(L[i][0]);
	for (int i = 2, op; i <= n; ++i){
		read(yzh[i][0], op), read(op ? mul[i][0] : (mul[i][0] = 1, add[i][0]));
	}
	for (int k = 1; k <= 19; ++k)
	for (int i = 1; i <= n; ++i) if (!!(yzh[i][k] = yzh[yzh[i][k - 1]][k - 1])){
		mul[i][k] = mul[i][k - 1] * mul[yzh[i][k - 1]][k - 1];
		add[i][k] = add[i][k - 1] * mul[yzh[i][k - 1]][k - 1] + add[yzh[i][k - 1]][k - 1];
		L[i][k] = max(L[i][k - 1], (L[yzh[i][k - 1]][k - 1] - add[i][k - 1] - 1) / mul[i][k - 1] + 1);
	}
	for (int i = 1, now; i <= m; ++i){
		long long val; read(val, now);
		for (int j = 19; j >= 0; --j)
		if (yzh[now][j] && L[now][j] <= val)
			ans2[i] += 1 << j, val = val * mul[now][j] + add[now][j], now = yzh[now][j];
		if (val >= L[now][0]) ++ans2[i];
		else ++ans1[now];
	}
	for (int i = 1; i <= n; ++i) write(ans1[i], '\n');
	for (int i = 1; i <= m; ++i) write(ans2[i], '\n');
	return 0;
}
```
### 左偏树
```cpp
//#pragma GCC optimize(3)
//#pragma GCC optimize("Ofast", "inline", "-ffast-math")
//#pragma GCC target("avx", "sse2", "sse3", "sse4", "mmx")
#include <iostream>
#include <cstdio>
#define debug(a) cerr << "Line: " << __LINE__ << " " << #a << endl
#define print(a) cerr << #a << "=" << (a) << endl
#define file(a) freopen(#a".in", "r", stdin), freopen(#a".out", "w", stdout)
#define main Main(); signed main(){ return ios::sync_with_stdio(0), cin.tie(0), Main(); } signed Main
using namespace std;

int n, m;
typedef int array[300010];
typedef long long Array[300010];
array lson, rson, root, a, dpt, fa, ans1, ans2, dis;
Array add, mul, h, s, v;

inline void pushtag(int x, long long mul, long long add){
	::add[x] = ::add[x] * mul + add, ::mul[x] *= mul;
	s[x] = s[x] * mul + add;
}

inline void pushdown(int x){
	if (lson[x]) pushtag(lson[x], mul[x], add[x]);
	if (rson[x]) pushtag(rson[x], mul[x], add[x]);
	add[x] = 0, mul[x] = 1;
}

int merge(int x, int y){
	if (!x || !y) return x | y;
	if (s[x] > s[y]) swap(x, y);
	pushdown(x), rson[x] = merge(rson[x], y);
	if (dis[lson[x]] < dis[rson[x]]) swap(lson[x], rson[x]);
	return dis[x] = dis[rson[x]] + 1, x;
}

signed main(){
	dpt[1] = 1, read(n, m);	
	for (int i = 1; i <= n; ++i) read(h[i]);
	for (int i = 2; i <= n; ++i) read(fa[i], a[i], v[i]), dpt[i] = dpt[fa[i]] + 1, mul[i] = 1;
	for (int i = 1, bl; i <= m; ++i) read(s[i], bl), root[bl] = merge(root[bl], i), ans2[i] = dpt[bl];
	for (int i = n; i >= 1; --i){
		while (root[i] && s[root[i]] < h[i]){
			ans2[root[i]] -= dpt[i], pushdown(root[i]), ++ans1[i];
			root[i] = merge(lson[root[i]], rson[root[i]]);
		}
		if (i == 1) break;
		if (root[i] == 0) continue;
		if (a[i]) pushtag(root[i], v[i], 0);
		else pushtag(root[i], 1, v[i]);
		pushdown(root[i]), root[fa[i]] = merge(root[fa[i]], root[i]);
	}
	for (int i = 1; i <= n; ++i) write(ans1[i], '\n');
	for (int i = 1; i <= m; ++i) write(ans2[i], '\n');
	return 0;
}
```
## 总结 & 后话
~~线段树无敌爱敲~~，另外两种做法码量小，速度快，虽然线段树码量大，速度慢，但是思路简单是个不错的选择！

---

## 作者：Priori_Incantatem (赞：6)

左偏树 + dfs + 线段树懒标签思想

前置芝士：需要掌握线段树同时维护加法和乘法

每个城市维护一个小根堆，包括乘法与加法标签，和骑士当前的战斗力

首先，将每个骑士加入到他的起始城市所在的堆中  
接着，dfs 遍历所有城市  
对于城市 $x$，合并所有在他子树中的堆（包括城市 $x$），我们将这个合并后的大堆成为 “城市 $x$ 的堆”  
然后，将所有攻陷不了城市 $x$ 的骑士弹出（$v(i)<h[i]$）。弹出时记录在每一个城市牺牲的骑士的个数和每个骑士攻陷的城市个数
最后，将当前堆的根节点打上相应地 加法或乘法标记，即在攻陷城市 $x$ 后增加的战斗力

在退出 dfs 后，城市 $1$ 的堆中有可能会剩下一些骑士，也就是攻陷了城市 $1$ 的骑士。我们也需要把他们弹出堆，并记录答案

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
const long long Maxn=300000+10,inf=0x3f3f3f3f;
struct node{
	long long ls,rs,fa,dis,val,add,mul;
	#define ls(x) g[x].ls // 左右儿子
	#define rs(x) g[x].rs
	#define f(x) g[x].fa // 父亲接地那
	#define dis(x) g[x].dis
	#define v(x) g[x].val // 骑士的战斗力
	#define add(x) g[x].add // 加法与乘法标记
	#define mul(x) g[x].mul
}g[Maxn];
bool flag[Maxn]; //cities
long long h[Maxn],val[Maxn],c[Maxn];
long long s[Maxn],id[Maxn],d[Maxn];
long long a[Maxn],cnt[Maxn],pos[Maxn];// knights
long long n,m;
vector <long long> e[Maxn];
inline long long read()
{
	long long s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
void init()
{
	for(long long i=1;i<=m;++i)
	f(i)=i,v(i)=a[i],mul(i)=1;
	dis(0)=-1;
}
inline void upd_mul(long long x,long long v)// 乘法更新
{
	add(x)*=v;
	mul(x)*=v;
	v(x)*=v;
}
inline void upd_add(long long x,long long v) // 加法更新
{
	add(x)+=v;
	v(x)+=v;
}
inline void push_down(long long x) // 标记下放，与线段树类似
{
	if(mul(x)!=1)
	{
		if(ls(x))upd_mul(ls(x),mul(x));
		if(rs(x))upd_mul(rs(x),mul(x));
		mul(x)=1;
	}
	if(add(x))
	{
		if(ls(x))upd_add(ls(x),add(x));
		if(rs(x))upd_add(rs(x),add(x));
		add(x)=0;
	}
}
long long merge(long long x,long long y) // 合并堆
{
	if(!x || !y)return x|y;
	if(v(x)>v(y))swap(x,y);
	push_down(x); 
	rs(x)=merge(rs(x),y);
	if(dis(ls(x))<dis(rs(x)))swap(ls(x),rs(x));
	push_down(ls(x)),push_down(rs(x));
	if(!ls(x) || !rs(x))dis(x)=0;
	else dis(x)=dis(rs(x))+1;
	push_down(x);
	return x;
}
long long del(long long x)// 删除堆顶元素
{
	push_down(x);
	long long l=ls(x),r=rs(x);
	f(l)=l,f(r)=r;
	push_down(l),push_down(r);
	dis(x)=ls(x)=rs(x)=0;
	return merge(l,r);
}
void dfs(long long x,long long fa)
{
	d[x]=d[fa]+1;
	for(long long i=0;i<e[x].size();++i)
	{
		long long y=e[x][i];
		dfs(y,x);
		push_down(id[x]),push_down(id[y]);
		id[x]=merge(id[x],id[y]);
		s[x]+=s[y];
	}
	while(s[x] && v(id[x])<h[x])
	{
		push_down(id[x]);
		cnt[id[x]]=d[pos[id[x]]]-d[x];
		++c[x],--s[x];
		id[x]=del(id[x]);
	}
	if(!flag[x])upd_add(id[x],val[x]);
	else upd_mul(id[x],val[x]);
}
int main()
{
//	freopen("in.txt","r",stdin);
//	freopen("out.txt","w",stdout);
	n=read(),m=read();
	for(long long i=1;i<=n;++i)
	h[i]=read();
	for(long long i=2;i<=n;++i)
	{
		long long x=read();
		flag[i]=read(),val[i]=read();
		e[x].push_back(i);
	}
	for(long long i=1;i<=m;++i)
	a[i]=read(),pos[i]=read();
	init();
	
	for(long long i=1;i<=m;++i)
	id[pos[i]]=merge(id[pos[i]],i),++s[pos[i]];
	dfs(1,0);
	
	while(s[1])
	{
		push_down(id[1]);
		cnt[id[1]]=d[pos[id[1]]];
		--s[1];
		id[1]=del(id[1]);
	}
	
	for(long long i=1;i<=n;++i)
	printf("%lld\n",c[i]);
	for(long long i=1;i<=m;++i)
	printf("%lld\n",cnt[i]);
	
	return 0;
}
```

---

## 作者：樱洛CHANGE (赞：4)

发现没有**数组配对堆**的题解，所以来补一发数组配对堆。

------------

### 放在最前面
这个题的做法其他题解都详细讲了，显然用一个可并堆维护，打上乘法 tag 和加法 tag，故本题解不再赘述做法，只提供其他题解没有的另外一种可并堆——配对堆的写法，并点出与左偏树写法的不同点和坑，供参考（调了 10 个小时才调出来）。

--------
### 注意点一
输入点时是从 $2$ **号结点开始的**，所以循环应从 $2$ 开始。

------------

### 注意点二
  为了方便，我们在堆中存的元素是骑士（为了方便计算答案，我们除了存一个 $\text{val}$ 域表示骑士的战斗力，再额外存一个 $\text{num}$ 域表示骑士的编号），初始时，我们对于每一个有骑士开始的节点新建一个堆，在对树遍历时，堆维护到达当前节点的骑士集。

注意：**堆的编号与节点的编号不同，所以一定不可以混淆二者（调了一个小时！！）**。

---------
 
### 注意点三

因为配对堆结构的特殊性，其写法与左偏树最大的不同在于  $\text{Pushdown}$  操作，在 $\text{Pushdown}$ 时，为了将标记全部传到下一层，我们要对当前节点的所有儿子进行遍历，用类似配对堆删除时合并的操作，$O(\log n)\ $ 的进行下传，写法如下（**注意 $\text{while}$ 中是 $\ \text{y}$**）：

```
inline void Pushdown(rint x){
	rint y=t[x].ls;
	while(y)
	{
		if(t[x].mul!=1){
			t[y].mul*=t[x].mul,t[y].add*=t[x].mul;
			t[y].val*=t[x].mul;
		}
		if(t[x].add){
			t[y].add+=t[x].add;
			t[y].val+=t[x].add;
		}
		y=t[y].bro;
	}
	t[x].mul=1;t[x].add=0;
}
```

--------------

### 注意点四

在下传标记之前，**要保证父节点的答案和两个标记都已经被更新完了**，否则其儿子就更新了个寂寞。

------
### 注意点五
在 $\text{dfs}$ 结束后，**不要忘了处理出战胜了 $1$ 号结点（根）的骑士的答案**。

--------
### 代码
```
#include<bits/stdc++.h>
#define awa 2147483647
#define zhale exit(0)
#define re register
#define rint re int
#define int long long
#define SY system("pause")

using namespace std;
/*Shioiri Kukuri*/

typedef long long ll;
typedef unsigned long long ull;
typedef double qwq;
typedef pair<int,int> P;
typedef pair<ll,ll> llP;
#define rll re ll
#define rqwq re qwq

/*Otho Ai*/

template<class T>
void Swap(T &x,T &y)
{
	T z=x;
	x=y;
	y=z;
}

//#define PairOP
#ifdef PairOP
template<class T1,class T2>
inline const pair<T1,T2> operator + (const pair<T1,T2> &p1,const pair<T1,T2> &p2){
	return pair<T1,T2>(p1.first+p2.first,p1.second+p2.second);
}

template<class T1,class T2>
inline const pair<T1,T2> operator - (const pair<T1,T2> &p1,const pair<T1,T2> &p2){
	return pair<T1,T2>(p1.first-p2.first,p1.second-p2.second);
}
#endif

#define FastIO
#ifdef FastIO
	char buf[1<<21],*p1,*p2;
	#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif

template<class T>
T Read()
{
	T x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}
//int (*read)()=Read<int>;
ll (*readll)()=Read<ll>;
#define read Read<int>

const int N=3e5+5;
int n,m,tot,head[N],nxt[N<<1],ver[N<<1],fa[N];
ll h[N];
inline void add(rint x,rint y)
{
	ver[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}
class Tag{
	public:
		int a;ll v;
		inline void In(){
			a=read(),v=readll();
		}
}tg[N];

class Knight{
	public:
		int c;ll s;
}k[N];

class PairingHeap{
	private:
		class Node{
			public:
				ll val,add,mul;
				int ls,bro,num;
				Node():ls(0),bro(0){}
		}t[N];
		int cnt;
		inline int New(rll x,rint i){
			t[++cnt].val=x;
			t[cnt].num=i;
			return cnt;
		}
		inline void Pushdown(rint x){
			rint y=t[x].ls;
			while(y)
			{
				if(t[x].mul!=1){
					t[y].mul*=t[x].mul,t[y].add*=t[x].mul;
					t[y].val*=t[x].mul;
				}
				if(t[x].add){
					t[y].add+=t[x].add;
					t[y].val+=t[x].add;
				}
				y=t[y].bro;
			}
			t[x].mul=1;t[x].add=0;
		}
	public:
		PairingHeap():cnt(0){}
		inline void Update(rint x,re bool op,rll val){
			if(op) t[x].val*=val,t[x].mul*=val,t[x].add*=val;
			else t[x].val+=val,t[x].add+=val;
		}
		inline int Merge(rint x,rint y){
			if(!x||!y) return x|y;
			if(t[x].val>t[y].val) Swap(x,y);
			Pushdown(x),Pushdown(y);
			t[y].bro=t[x].ls,t[x].ls=y;
			return x;
		}
		inline int Del(rint x){
			if(!x||!t[x].bro) return x;
			rint b1=t[x].bro,b2=t[b1].bro;
			t[x].bro=t[b1].bro=0;
			return Merge(Merge(x,b1),Del(b2));
		}
		inline void Push(rint &rt,rll val,rint i){
			rt=Merge(rt,New(val,i));
		}
		inline void Pop(rint &x){
			Pushdown(x);
			x=Del(t[x].ls);
		}
		inline ll TopVal(rint x){
			return t[x].val;
		}
		inline int TopNum(rint x){
			return t[x].num;
		}
}t;
int Root[N],cnt,d[N];
int win[N],die[N];

inline void dfs(rint x,rint dep)
{
	for(rint i=head[x];i;i=nxt[i])
	{
		rint y=ver[i];
		if(y==fa[x]) continue;
		d[y]=d[x]+1,dfs(y,dep+1);
		Root[x]=t.Merge(Root[x],Root[y]);
	}
	while(233)
	{
		rint val=t.TopVal(Root[x]),num=t.TopNum(Root[x]);
		if(!num) break;
		if(val<h[x]) die[x]++,win[num]=d[k[num].c]-dep,t.Pop(Root[x]);
		else break;
	}
	t.Update(Root[x],tg[x].a,tg[x].v);
}

inline int True()
{
//#define Freopen
#ifdef Freopen
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif

//#define Clock
#ifdef Clock
	rint STR=clock();
#endif

	n=read(),m=read();
	for(rint i=1;i<=n;++i)
	h[i]=readll();
	for(rint i=2,f;i<=n;++i)
	f=read(),add(f,i),tg[i].In(),fa[i]=f;
	for(rint i=1;i<=m;++i)
	{
		k[i].s=readll(),k[i].c=read();
		t.Push(Root[k[i].c],k[i].s,i);
	}
	dfs(1,0);
	while(233)
	{
		rint val=t.TopVal(Root[1]),num=t.TopNum(Root[1]);
		if(!num) break;
		win[num]=d[k[num].c]+1,t.Pop(Root[1]);
	}
	for(rint i=1;i<=n;++i) printf("%d\n",die[i]);
	for(rint i=1;i<=m;++i) printf("%d\n",win[i]);

#ifdef Clock
	rint END=clock();
	printf("Time:%dms\n",int((END-STR)/(qwq)CLOCKS_PER_SEC*1000));
	printf("Time:%ds\n",int((END-STR)/(qwq)CLOCKS_PER_SEC));
#endif
	return (0-0);//q(0-0)p q(>-<)p
}

int Love=True();

signed main(){;}

---

## 作者：zhaoyifan (赞：3)

思路和楼上的哥们思路差不多，稍微解释一下

我们发现树是固定的，路线是固定的，那么一开始就开n颗bst，从叶节点开始删点，删完的就和父亲进行启发式合并，每个最多合并logn次，每次合并logn时间，所以一共是nlogn^2的复杂度。

另外一开始写的是sbt，但是只能过1e5，我对splay复杂度一直不解，这道题sbt的写法的tle更使我迷惑，虚心求教大佬讲解。

而且sbt的写法如果在启发式合并过程中splay插入的点到插入的树的根节点的话，复杂度总体上升（少部分数据更快）

这两个程序的整体框架相同，只有旋转不同。

第一块代码是bst的满分代码，第二块是stb的60分代码
```c
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#include<stack>
#define LL long long
using namespace std;
const int maxn=3e5+7;
queue<int>q;stack<int>qq;
int n,m,id[maxn*4],rudu[maxn],fa[maxn*4],rt[maxn],son[maxn*4]
,t[maxn*4][2],cnt=0,die[maxn],peo[maxn],li[maxn*4],laz[maxn*4]
,pos[maxn*4];
LL h[maxn],fi[maxn],ai[maxn],vi[maxn],w[maxn*4],
add[maxn*4],mul[maxn*4];
inline LL read()
{
    LL x=0,w=1;char ch=' ';
    while(ch>'9'||ch<'0')
    {
        if(ch=='-') w=-1;ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=(x<<3)+(x<<1)+ch-'0';ch=getchar();
    }
    return x*w;
}
void downit(int x)
{
    int l=t[x][0],r=t[x][1];
    if(mul[x]==1&&!add[x]&&!laz[x]) return ;
    if(mul[x]!=1)
    {
        if(l) {mul[l]*=mul[x];add[l]*=mul[x];w[l]*=mul[x];}
        if(r) {mul[r]*=mul[x];add[r]*=mul[x];w[r]*=mul[x];}
        mul[x]=1;
    }
    if(l) {add[l]+=add[x];w[l]+=add[x];laz[l]+=laz[x];li[l]+=laz[x];}
    if(r) {add[r]+=add[x];w[r]+=add[x];laz[r]+=laz[x];li[r]+=laz[x];}
    add[x]=0;laz[x]=0;
}
void up(int x)
{
    son[x]=son[t[x][0]]+son[t[x][1]]+1;
}
void rotate(int &x,int r)
{
    int k=t[x][r];
    t[x][r]=t[k][r^1];t[k][r^1]=x;up(x);up(k);x=k;
}
void Insert(int &x,LL v,int ID,int gou)
{
    if(!x)
    {
        x=++cnt;w[x]=v;id[x]=ID;son[x]=1;
        mul[x]=1;li[x]=gou;pos[x]=rand();return ;
    }
    downit(x);
    if(v<=w[x]) 
    {
        Insert(t[x][0],v,ID,gou);
        if(pos[x]<pos[t[x][0]]) rotate(x,0);
    }
    else 
    {
        Insert(t[x][1],v,ID,gou);
        if(pos[x]<pos[t[x][1]]) rotate(x,1);
    }
    up(x);
}
void cd(int x)
{
    if(!x) return ;
    rudu[x]--;
    if(!rudu[x]) q.push(x);
}
void add_tree(int x,int y)
{
    if(!x) return ;downit(x);
    Insert(rt[y],w[x],id[x],li[x]);
    if(t[x][0]) add_tree(t[x][0],y);
    if(t[x][1]) add_tree(t[x][1],y);
}
void merge(int x,int z)
{
    int gen=z;
    if(son[rt[x]]>son[rt[z]]) swap(x,z);
    add_tree(rt[x],z);
    rt[gen]=rt[z];
}
int del(int &x,LL v)
{
    if(!x) return 0;int ans=0;downit(x);
    if(w[x]>=v) 
    {
        ans=del(t[x][0],v);up(x);return ans;
    }
    else 
    {
        ans+=del(t[x][0],v);
        peo[id[x]]=li[x];
        ans+=del(t[x][1],v);
        if(t[x][1]) {fa[t[x][1]]=fa[x];x=t[x][1];}
        else x=0;
        return ans+1;
    }
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=n;++i) h[i]=read();
    for(int i=2;i<=n;++i)
    {
        fi[i]=read();ai[i]=read();vi[i]=read();rudu[fi[i]]++;
    }
    for(int i=1;i<=m;++i)
    {
        int x=read(),y=read();Insert(rt[y],x,i,0);
    }
    for(int i=1;i<=n;++i)
    if(!rudu[i]) q.push(i);
    while(q.size())
    {	
        int x=q.front();q.pop();
        int z=fi[x];if(z) cd(z);
        die[x]=del(rt[x],h[x]);
        int y=rt[x];if(!y) continue;
        if(!ai[x]) {w[y]+=vi[x];add[y]+=vi[x];}
        else {w[y]*=vi[x];mul[y]*=vi[x];add[y]*=vi[x];}
        laz[y]+=1;li[y]+=1;
        if(z) merge(x,z);
    }
    del(rt[1],(LL)1e18+3);
    for(int i=1;i<=n;++i) printf("%d\n",die[i]);
    for(int i=1;i<=m;++i) printf("%d\n",peo[i]);
    return 0; 
}
```

第二块代码，sbt，60分
```
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#include<stack>
#define LL long long
using namespace std;
const int maxn=3e5+7;
queue<int>q;stack<int>qq;
int n,m,id[maxn*4],rudu[maxn],fa[maxn*4],rt[maxn],son[maxn*4]
,t[maxn*4][2],cnt=0,die[maxn],peo[maxn],li[maxn*4],laz[maxn*4];
LL h[maxn],fi[maxn],ai[maxn],vi[maxn],w[maxn*4],
add[maxn*4],mul[maxn*4];
inline LL read()
{
    LL x=0,w=1;char ch=' ';
    while(ch>'9'||ch<'0')
    {
        if(ch=='-') w=-1;ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=(x<<3)+(x<<1)+ch-'0';ch=getchar();
    }
    return x*w;
}
void downit(int x)
{
    int l=t[x][0],r=t[x][1];
    if(mul[x]==1&&!add[x]&&!laz[x]) return ;
    if(mul[x]!=1)
    {
        if(l) {mul[l]*=mul[x];add[l]*=mul[x];w[l]*=mul[x];}
        if(r) {mul[r]*=mul[x];add[r]*=mul[x];w[r]*=mul[x];}
        mul[x]=1;
    }
    if(l) {add[l]+=add[x];w[l]+=add[x];laz[l]+=laz[x];li[l]+=laz[x];}
    if(r) {add[r]+=add[x];w[r]+=add[x];laz[r]+=laz[x];li[r]+=laz[x];}
    add[x]=0;laz[x]=0;
}
void up(int x)
{
    son[x]=son[t[x][0]]+son[t[x][1]]+1;
}
void Insert(int &x,LL v,int ID,int gou)
{
    if(!x)
    {
        x=++cnt;w[x]=v;id[x]=ID;son[x]=1;
        mul[x]=1;li[x]=gou;return ;
    }
    downit(x);
    if(v<=w[x]) Insert(t[x][0],v,ID,gou);
    else Insert(t[x][1],v,ID,gou);
    up(x);fa[t[x][1]]=fa[t[x][0]]=x;
}
void rotate(int x,int &k)
{
    int y=fa[x],z=fa[y],d=t[y][1]==x;
    if(y==k) k=x;
    else t[z][t[z][1]==y]=x;
    fa[t[x][d^1]]=y;t[y][d]=t[x][d^1];fa[x]=z;
    fa[y]=x;t[x][d^1]=y;up(y);up(x);
}
void splay(int x,int &k)
{
    while(x!=k)
    {
        int y=fa[x],z=fa[y];
        if(y!=k)
        {
            if((t[z][0]==y)^(t[y][0]==x)) rotate(x,k);
            else rotate(y,k);
        }
        rotate(x,k);
    }
}
void cd(int x)
{
    if(!x) return ;
    rudu[x]--;
    if(!rudu[x]) q.push(x);
}
void add_tree(int x,int y)
{
    if(!x) return ;downit(x);
    Insert(rt[y],w[x],id[x],li[x]);
    if(t[x][0]) add_tree(t[x][0],y);
    if(t[x][1]) add_tree(t[x][1],y);
}
void merge(int x,int z)
{
    int gen=z;
    if(son[rt[x]]>son[rt[z]]) swap(x,z);
    add_tree(rt[x],z);
    rt[gen]=rt[z];
}
int del(int &x,LL v)
{
    if(!x) return 0;int ans=0;downit(x);
    if(w[x]>=v) 
    {
        ans=del(t[x][0],v);up(x);return ans;
    }
    else 
    {
        ans+=del(t[x][0],v);
        peo[id[x]]=li[x];
        ans+=del(t[x][1],v);
        if(t[x][1]) {fa[t[x][1]]=fa[x];x=t[x][1];}
        else x=0;
        return ans+1;
    }
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=n;++i) h[i]=read();
    for(int i=2;i<=n;++i)
    {
        fi[i]=read();ai[i]=read();vi[i]=read();rudu[fi[i]]++;
    }
    for(int i=1;i<=m;++i)
    {
        int x=read(),y=read();
        Insert(rt[y],x,i,0);splay(cnt,rt[y]);
    }
    for(int i=1;i<=n;++i)
    if(!rudu[i]) q.push(i);
    while(q.size())
    {	
        int x=q.front();q.pop();
        int z=fi[x];if(z) cd(z);
        die[x]=del(rt[x],h[x]);
        int y=rt[x];if(!y) continue;
        if(!ai[x]) {w[y]+=vi[x];add[y]+=vi[x];}
        else {w[y]*=vi[x];mul[y]*=vi[x];add[y]*=vi[x];}
        laz[y]+=1;li[y]+=1;
        if(z) merge(x,z);
    }
    del(rt[1],(LL)1e18+3);
    for(int i=1;i<=n;++i) printf("%d\n",die[i]);
    for(int i=1;i<=m;++i) printf("%d\n",peo[i]);
    return 0; 
}
```





---

## 作者：UnyieldingTrilobite (赞：2)

<https://www.luogu.com.cn/problem/P3261>。

虽然可以使用可并堆简单维护但这个题很显然存在一些更加丁真的做法。这个做法能强制在线地求出每个骑士在哪座城倒下。

首先如果在序列上那显然长得一脸线段树二分，所以我们考虑怎么比较好地维护这个信息。我们注意到可以把每个点的信息映射到一条有起点和终点的线段作为一个一次函数来维护（实际上维护的是两个端点），同时可以直接使用题目里保证的绝对值不超过 $10^{18}$ 来对线段进行有效约束。这部分可能听起来有点怪但实际上写出来就是这么个玩意：

```cpp
struct func {
  int xl, xr, yl, yr;
  int getk() const { return xl == xr ? 1 : (yr - yl) / (xr - xl); }
  int operator()(int x) const { return (x - xl) * getk() + yl; }
};
func merge(func a, func b) {
  static auto mnov = [](int x, int y) {
    if (x < 0) return 0ll;
    return (x + y - 1) / y;
  };
  if (a.xl > a.xr) return a;
  if (b.xl > b.xr) return b;
  int k = a.getk();
  func c;
  c.xl = mnov(b.xl - a.yl, k) + a.xl;
  c.xr = a.xr - mnov(a.yr - b.xr, k);
  if (c.xl > c.xr) return {1, 0, 0, 0};
  c.yl = b(a(c.xl)), c.yr = b(a(c.xr));
  return c;
}
```

初始化直接按定义抄一遍：

```cpp
    if (!a) {
      int xl = max(-A - min(v, 0ll), h[i]), xr = A - max(v, 0ll);
      val[i] = {xl, xr, xl + v, xr + v};
    } else {
      int xl = h[i], xr = A / v;
      val[i] = {xl, xr, xl * v, xr * v};
    }
```

这样序列上已经可以做了。然后我们考虑树上其实并没有什么不同。采用树链剖分进行维护，在每个点上求出它到重链顶的前缀和，这样就可以从起点开始一路跳重链来确定答案停在哪条重链上，然后在重链上根据 dfs 序的连续性就可以套序列上那个线段树二分了。非常雪豹。

完整代码 be like：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
constexpr int N = 3e5 + 9, A = 1e18;
struct func {
  int xl, xr, yl, yr;
  int getk() const { return xl == xr ? 1 : (yr - yl) / (xr - xl); }
  int operator()(int x) const { return (x - xl) * getk() + yl; }
};
func merge(func a, func b) {
  static auto mnov = [](int x, int y) {
    if (x < 0) return 0ll;
    return (x + y - 1) / y;
  };
  if (a.xl > a.xr) return a;
  if (b.xl > b.xr) return b;
  int k = a.getk();
  func c;
  c.xl = mnov(b.xl - a.yl, k) + a.xl;
  c.xr = a.xr - mnov(a.yr - b.xr, k);
  if (c.xl > c.xr) return {1, 0, 0, 0};
  c.yl = b(a(c.xl)), c.yr = b(a(c.xr));
  return c;
}
int n, m, dfn[N], pos[N], top[N], fa[N], dph[N], ans[N], cnt[N];
vector<int> es[N];
func val[N], sum[N];
struct {
  func f;
  int l, r;
} tr[N << 2];
void init() {
  int h[N];
  for (int i = 1; i <= n; ++i) cin >> h[i];
  val[1] = {h[1], A, h[1], A};
  for (int i = 2, a, v; i <= n; ++i) {
    cin >> fa[i] >> a >> v;
    es[fa[i]].push_back(i);
    if (!a) {
      int xl = max(-A - min(v, 0ll), h[i]), xr = A - max(v, 0ll);
      val[i] = {xl, xr, xl + v, xr + v};
    } else {
      int xl = h[i], xr = A / v;
      val[i] = {xl, xr, xl * v, xr * v};
    }
  }
}
void build() {
  int sz[N], sn[N];
  function<void(int)> dfs1 = [&](int x) {
    sz[x] = 1, sn[x] = 0, dph[x] = dph[fa[x]] + 1;
    for (int y : es[x]) {
      dfs1(y), sz[x] += sz[y];
      if (!sn[x] || sz[y] > sz[sn[x]]) sn[x] = y;
    }
  };
  dfs1(1);
  function<void(int, int)> dfs2 = [&](int x, int t) {
    static int tot;
    pos[dfn[x] = ++tot] = x, top[x] = t, sum[x] = val[x];
    if (top[x] != x) sum[x] = merge(sum[x], sum[fa[x]]);
    if (int z = sn[x]) {
      dfs2(z, t);
      for (int y : es[x])
        if (y != z) dfs2(y, y);
    }
  };
  dfs2(1, 1);
  function<void(int, int, int)> build = [&](int x, int L, int R) {
    if (L == R) {
      tr[x].f = val[pos[L]];
      return;
    }
    int mid = (L + R) >> 1;
    build(x << 1, L, mid), build(x << 1 | 1, mid + 1, R);
    tr[x].f = merge(tr[x << 1 | 1].f, tr[x << 1].f);
  };
  build(1, 1, n);
}
int calc(int x, int h) {
  static function<int(int, int&, int, int, int, int)> findr =
      [](int x, int& h, int l, int r, int L, int R) {
        if (l > R || L > r) return 0ll;
        if (l <= L && R <= r) {
          func f = tr[x].f;
          if (h >= f.xl && h <= f.xr) return h = f(h), 0ll;
        }
        if (L == R) return R + 1;
        int mid = (L + R) >> 1, d = findr(x << 1 | 1, h, l, r, mid + 1, R);
        if (!d) d = findr(x << 1, h, l, r, L, mid);
        return d;
      };
  while (x) {
    func f = sum[x];
    if (h >= f.xl && h <= f.xr) {
      h = f(h), x = fa[top[x]];
      continue;
    }
    int d = findr(1, h, dfn[top[x]], dfn[x], 1, n);
    return d > dfn[x] ? x : fa[pos[d]];
  }
  return 0;
}
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  cin >> n >> m, init(), build();
  for (int i = 1, s, c; i <= m; ++i) {
    cin >> s >> c;
    int x = calc(c, s);
    ++cnt[x], ans[i] = dph[c] - dph[x];
  }
  for (int i = 1; i <= n; ++i) cout << cnt[i] << '\n';
  for (int i = 1; i <= m; ++i) cout << ans[i] << '\n';
  return cout << flush, 0;
}
```

线性空间单 $\log$。

~~闲话：根据这个做法很显然骑士的路径可以改成从一个点杀到另一个点而不是固定向根，不知道有没有老哥把这个搬到谁家模拟赛去过。~~

---

## 作者：Yaha (赞：2)

### 左偏树

首先，每个城池建一棵左偏树，把起点在该城池的士兵存进去，维护士兵的血量的小根堆。然后从叶节点开始向上合并。注意每个堆维护的是在这个城池的士兵的剩余血量。对于每个点，先不管三七二十一把儿子合并过来，再把会在这个城池死的士兵弹出去，然后再把这个点需要做的处理（即战斗力变化系数）弄到懒标记上。

注意，每个堆有且仅有根的值能保证是正确的剩余血量，其他的因为懒标记的存在可能还没更新。但我们每次只用堆顶，所以足够了，要是想要弹出堆顶就用懒标记更新一下儿子的值。

代码尽量给了详细注释。

```cpp
#include<bits/stdc++.h>
#define in long long
using namespace std;
const int amou=3e5+90;
in h[amou],multag[amou],addtag[amou],bl[amou],v[amou];//h表示城池的权值，multag和addtag是懒标记，bl是血量，即左偏树里的点权，v为战斗力变化参数里的v
int root[amou],dist[amou],l[amou],r[amou];//左偏树标配变量
int nxt[amou],cnt,ver[amou],head[amou];//存图变量
int n,m,opt[amou],dep[amou],fa[amou],s[amou],death[amou],num[amou];//opt为战斗力变化参数里的a，dep是城池在树中的深度（是城池组成的原树），s是战士的起点而已只用了一次，death是在某城池死去的人数，num是某士兵攻略的城池数

void pushdown(int i){
	in mul=multag[i],ad=addtag[i];
	if(l[i])
	{
		multag[l[i]]*=mul,addtag[l[i]]*=mul,addtag[l[i]]+=ad;
		bl[l[i]]=bl[l[i]]*mul+ad;
	}
	if(r[i])
	{
		multag[r[i]]*=mul,addtag[r[i]]*=mul,addtag[r[i]]+=ad;
		bl[r[i]]=bl[r[i]]*mul+ad;
	}
	multag[i]=1,addtag[i]=0;
}

int merg(int a,int b){
	if(!a||!b) return a+b;
	pushdown(a);pushdown(b);//因为用到了左右儿子所以需要更新为真正的值
	if(bl[a]>bl[b]) swap(a,b);
	r[a]=merg(r[a],b);
	if(dist[l[a]]<dist[r[a]]) swap(l[a],r[a]);
	dist[a]=dist[r[a]]+1;
	return a;
}

void add(int a,int b){
	nxt[++cnt]=head[a],head[a]=cnt,ver[cnt]=b;
}

void dfs(int i){
	dep[i]=dep[fa[i]]+1;
	for(int io=head[i];io;io=nxt[io])
	{
		int v=ver[io];
		dfs(v);
		root[i]=merg(root[i],root[v]);//先全部合并
	}
	while(bl[root[i]]<h[i]&&root[i])//弹出会在这死去的士兵
	{
		pushdown(root[i]);
		death[i]++;
		num[root[i]]=dep[s[root[i]]]-dep[i];
		root[i]=merg(l[root[i]],r[root[i]]);
	}
	if(opt[i])
	{
		multag[root[i]]*=v[i];
		addtag[root[i]]*=v[i];
		bl[root[i]]*=v[i];
	}
	else
	{
		addtag[root[i]]+=v[i];
		bl[root[i]]+=v[i];
	}
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%lld",&h[i]);
	for(int i=2;i<=n;i++)
	{
		scanf("%d%d%lld",&fa[i],&opt[i],&v[i]);
		add(fa[i],i);
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%lld%d",&bl[i],&s[i]);
		root[s[i]]=merg(root[s[i]],i);
		multag[i]=1;
	}
	dfs(1);
	while(root[1])//有可能有到了1号还没死的士兵，所以需要继续处理
	{
		pushdown(root[1]);
		num[root[1]]=dep[s[root[1]]];
		root[1]=merg(l[root[1]],r[root[1]]);
	}
	for(int i=1;i<=n;i++) printf("%lld\n",death[i]);
	for(int i=1;i<=m;i++) printf("%lld\n",num[i]);
	return 0;
}
```


---

## 作者：kouylan (赞：2)

## 题解 P3261 【[JLOI2015]城池攻占】

### 【[题意](https://www.luogu.com.cn/problem/P3261)】

有$m$个骑士要去分别攻打$n$个城池，谁的攻击力（或防御力）大就获胜，如果骑士赢了，他的攻击力就会（按题面）变化，并且攻打下一个城池。问每个城池能弄死几个骑士，每个骑士能打下几个城池？

### 【分析】

首先暴力做法，对于每个骑士我们从下往上推，是 $O(nm)$ 的，显然爆炸。

我们考虑对于每一个城池，只要骑士的攻击力小于这个城池的防御力，就都会被秒。所以我们只要统计：在这个城池中有多少骑士的攻击力小于城池的防御力。

我们就可以对于每一个城池建一个小根堆，每次去堆顶，如果小于就 pop 掉，否则跳出。但是，每一个父节点的小根堆要与儿子节点的合并，所以我们需要**左偏树（可并堆）**来实现。

然后，我们还要修改每一个骑士的攻击力。对于这种批量操作，我们只需要打上懒标记，再下推即可。

最后，我们统计答案。对于 “每个城池能弄死几个骑士” 相对简单，只要在每次 pop 时，把答案$+1$即可。对于 “每个骑士能打下几个城池”，我们只需记录他出发城池的深度和结束城池的深度，再进行相减即可。

下面是AC代码：

```cpp
/*
luogu P3261
*/
#include <bits/stdc++.h>
using namespace std;

#define int long long

int n,m,a[300005],v[300005],defend[300005],c[300005];
int ans1[300005],ans2[300005];
int ee,h[300005],nex[300005<<1],to[300005<<1];
int root[300005],dep[300005];
struct leftree{
	int l,r;
	int v,dis;
	int laz1,laz2;
}t[300005];

void addedge(int x,int y)
{
	nex[++ee] = h[x];
	to[ee] = y;
	h[x] = ee;
}

void pushdown(int x)
{
	if(t[x].l)
	{
		t[t[x].l].v = t[t[x].l].v*t[x].laz1+t[x].laz2;
		t[t[x].l].laz1 *= t[x].laz1;
		t[t[x].l].laz2 = t[t[x].l].laz2*t[x].laz1+t[x].laz2;
	}
	if(t[x].r)
	{
		t[t[x].r].v = t[t[x].r].v*t[x].laz1+t[x].laz2;
		t[t[x].r].laz1 *= t[x].laz1;
		t[t[x].r].laz2 = t[t[x].r].laz2*t[x].laz1+t[x].laz2;
	}
	t[x].laz1 = 1, t[x].laz2 = 0;
}

int merge(int x,int y)
{
	if(!x || !y)
		return x+y;
	pushdown(x), pushdown(y);
	if(t[x].v>t[y].v)
		swap(x,y);
	t[x].r = merge(t[x].r,y);
	if(t[t[x].l].dis<t[t[x].r].dis)
		swap(t[x].l,t[x].r);
	t[x].dis = t[t[x].r].dis+1;
	return x;
}

void dfs(int x,int pre)
{
	dep[x] = dep[pre]+1;
	for(int i=h[x];i;i=nex[i])
	{
		dfs(to[i],x);
		root[x] = merge(root[x],root[to[i]]);
	}
	while(root[x] && t[root[x]].v<defend[x])
	{
		pushdown(root[x]);
		ans1[x]++;
		ans2[root[x]] = dep[c[root[x]]]-dep[x];
		root[x] = merge(t[root[x]].l,t[root[x]].r);
	}
	if(a[x]==1)
	{
		t[root[x]].v *= v[x];
		t[root[x]].laz1 *= v[x];
		t[root[x]].laz2 *= v[x];
	}
	else if(a[x]==0)
	{
		t[root[x]].v += v[x];
		t[root[x]].laz2 += v[x];
	}
}

signed main()
{
	scanf("%lld %lld",&n,&m);
	for(int i=1;i<=n;scanf("%lld",&defend[i]),i++);
	for(int i=2,fa;i<=n&&scanf("%lld %lld %lld",&fa,&a[i],&v[i]);i++)
		addedge(fa,i);
	for(int i=1;i<=m;t[i].laz1=1,i++);
	for(int i=1;i<=m&&scanf("%lld %lld",&t[i].v,&c[i]);i++)
		root[c[i]] = merge(root[c[i]],i);
	dfs(1,0);
	while(root[1])
	{
		pushdown(root[1]);
		ans2[root[1]] = dep[c[root[1]]];
		root[1] = merge(t[root[1]].l,t[root[1]].r);
	}
	for(int i=1;i<=n;printf("%lld\n",ans1[i]),i++);
	for(int i=1;i<=m;printf("%lld\n",ans2[i]),i++);
	
	return 0;
}
```

祝大家AC愉快！

---

## 作者：Seauy (赞：1)

看得出来……题目就是要让我们批量快速计算出每个骑士最多能杀到哪

设骑士的战斗力为 $x$，骑士经过若干个结点后战斗力 $y=kx+b$ 是个一次函数，因为要满足每一刻的战斗力都要大于城池的生命值，所以还要满足 $x\geq p$

我们需要维护这个一次函数以及 $p$，而这玩意是有区间可加性的
 
静态在线立马想到倍增，可是内存限制了我们的想象（空间 $O(n\log n)$ 会炸）

把倍增改成树剖也不行，因为在同一条链上二分需要快速计算出两点间的一次函数与 $p$，用线段树 $O(m \log^2 n)$（实际上卡得过了），用 $O(1)$ 查询的数据结构（如猫树）空间跟倍增一样会挂

由于我左偏树老是写挂，感觉三进制的倍增又有些投机取巧，于是我用树分块给水过了 qwq ~~你这不是更投机取巧~~

选取一个块长 $S$，当结点的深度 $d$ 为 $S$ 整数倍时划分一下，计算每一个结点要跳到头顶上第一个划分位时的一次函数与 $p$，能跳整块跳整块，不能跳整块就一步步暴跳

这样时间复杂度算下来是

$$ O(mS+\sum_{i=1}^m \frac{d_i}{S}) $$

设 $ x=mS+\sum_{i=1}^m \frac{d_i}{S} $，则

$$ mS^2-xS+\sum_{i=1}^m d_i=0 $$

这个关于 $S$ 的二次函数

$$ \triangle=x^2-4m\sum_{i=1}^m d_i $$

$$ x_{min}=2\sqrt{m\sum_{i=1}^m d_i} $$

$$ argmin \space S=\sqrt{\frac{\sum_{i=1}^m d_i}{m}} $$

时间复杂度 $ O(x)=O(m\sqrt{n}) $，空间复杂度 $O(n)$，理论上过不了但是复杂度跑不满，本人跑了 962ms ~~丢脸还不如启发式合并~~

提醒一点，如果建块的时候对于每个块都暴力建的话会被卡成 $O(n\sqrt{n})$ 常数比较大，有可能会挂，正确做法是自己与父亲的信息合并，预处理就是 $O(n)$ 的了

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

const int MAXN=3e5;
const ll MINV=-1e18;

struct Rule
{
	ll K,B,Low;int Head;
	ll VAL(ll x) {return K*x+B;}
	void Print() {printf("%lld %lld %lld %d\n",K,B,Low,Head);}
};

struct Tree
{
	int father;
	int depth,Bloc;
	int A;ll H,V;
	Rule Skip;
	void Scan() {scanf("%d %d %lld",&father,&A,&V);}
	vector<int> Son;
}node[MAXN+5];

Rule Merge(Rule a,Rule b)//先通过 a 再通过 b
{
	Rule cnt;
	cnt.Head=b.Head;
	cnt.Low=max(a.Low,(ll)ceil((double)(b.Low-a.B)/a.K));
	cnt.K=a.K*b.K;
	cnt.B=a.B*b.K+b.B;
	return cnt;
}

Rule Sing(int x)
{
	if(node[x].A) return Rule{node[x].V,0,node[x].H,node[x].father};
	return Rule{1,node[x].V,node[x].H,node[x].father};
}

int n,m;
int block_size;
ll S[MAXN+5],Hsum;int C[MAXN+5];
int ans[2][MAXN+5];

void Build(int now,Rule cnt)
{
	node[now].depth%=block_size;
	if(node[now].depth==1) node[now].Bloc=1;
	else node[now].Bloc=node[node[now].father].Bloc+1;
	node[now].Skip=Merge(Sing(now),cnt);
	for(int i=0;i<node[now].Son.size();i++)
		Build(node[now].Son[i],(node[now].depth ? node[now].Skip : Rule{1,0,MINV,now}));
}

void Query(int x)
{
	while(C[x])
	{
		if(S[x]>=node[C[x]].Skip.Low)
		{
			S[x]=node[C[x]].Skip.VAL(S[x]);
			ans[1][x]+=node[C[x]].Bloc;
			C[x]=node[C[x]].Skip.Head;
		}
		else if(S[x]>=node[C[x]].H)
		{
			if(node[C[x]].A) S[x]*=node[C[x]].V;
			else S[x]+=node[C[x]].V;
			++ans[1][x]; 
			C[x]=node[C[x]].father;
		}
		else break;
	}
	++ans[0][C[x]];
}

int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lld",&node[i].H);
	node[1].depth=1;
	for(int i=2;i<=n;i++) 
	{
		node[i].Scan();
		node[i].depth=node[node[i].father].depth+1;
		node[node[i].father].Son.push_back(i);
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%lld %d",&S[i],&C[i]);
		Hsum+=node[C[i]].depth;
	}
	block_size=ceil(sqrt((double)Hsum/m));
	Build(1,Rule{1,0,MINV,0});
	for(int i=1;i<=m;i++) Query(i);
	for(int i=1;i<=n;i++) printf("%d\n",ans[0][i]);
	for(int i=1;i<=m;i++) printf("%d\n",ans[1][i]);
	return 0;
}
```


---

## 作者：GoldenPotato137 (赞：1)

[戳我获得更好的阅读体验qwq](https://www.goldenpotato.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/luogu-p1110-zjoi2007%E6%8A%A5%E8%A1%A8%E7%BB%9F%E8%AE%A1/)

---
# Solution
我们看到这道题，我们不妨想**把处于同一个点的骑士全部丢到一个小根堆左偏树里面**。这样子，我们**从下往上合并，合并完就去检查一下根是否满足当前城市的要求，一直弹根弹到满足要求为止**。

至于能力的变化，这里的操作要求无外乎乘法和加法。因此，我们可以像线段树II那道题那样做两个标记，处理一下即可。每次合并、弹根之前都pushdown标记。

就酱，这题就被我们切掉啦~(*´ﾟ∀ﾟ｀)ﾉ 
时间复杂度$O(nlogm)$

---
# Code
### 数据生成器
[在这里](https://www.goldenpotato.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/luogu-p1110-zjoi2007%E6%8A%A5%E8%A1%A8%E7%BB%9F%E8%AE%A1/)

### 正解
~~我因为用了vector存边常数爆大，不吸氧会T一个点~~

```cpp
//Luogu P3261 [JLOI2015]城池攻占
//Mar,8th,2019
//左偏树+线段树II
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=300000+1000;
struct LST
{
	long long plus[N],take[N],w[N],son[N][2],dis[N],fa[N];
	inline void pushdown(int x)//传入位置
	{
		if(son[x][0]!=0)
		{
			w[son[x][0]]=w[son[x][0]]*take[x]+plus[x];
			take[son[x][0]]*=take[x];
			plus[son[x][0]]=plus[son[x][0]]*take[x]+plus[x];
		}
		if(son[x][1]!=0)
		{
			w[son[x][1]]=w[son[x][1]]*take[x]+plus[x];
			take[son[x][1]]*=take[x];
			plus[son[x][1]]=plus[son[x][1]]*take[x]+plus[x];
		}
		plus[x]=0,take[x]=1;
	}
	int findFather(int x)//传入位置
	{
		if(fa[x]==0) return x;
		return fa[x]=findFather(fa[x]);
	}
	int Merge(int x,int y)//传入根的位置
	{
		if(x==0 or y==0) return x+y;
		if(w[x]<w[y]) swap(x,y);
		pushdown(x),pushdown(y);
		son[y][1]=Merge(x,son[y][1]),fa[son[y][1]]=y;
		if(dis[son[y][0]]<dis[son[y][1]]) 
			swap(son[y][0],son[y][1]);
		dis[y]=dis[son[y][1]]+1;	
		return y;
	}
	int Pop(int x)//返回新的根的位置
	{
		pushdown(x);
		fa[x]=Merge(son[x][0],son[x][1]);
		return fa[x];
	}
	void Mark(int x,long long ntake,long long nplus)
	{
		pushdown(x);
		w[x]=w[x]*ntake+nplus;
		take[x]=ntake,plus[x]=nplus;
	}
}lst;
int n,m,root[N],ans1[N],ans2[N];
long long a[N],v[N],h[N];
vector <int> e[N];
int depth[N],from[N];
void dfs(int now)
{
	for(int i=0;i<int(e[now].size());i++)
	{
		depth[e[now][i]]=depth[now]+1;
		dfs(e[now][i]);
		if(root[e[now][i]]!=0)
			root[now]=lst.Merge(root[now],root[e[now][i]]);
	}
	while(root[now]!=0 and lst.w[root[now]]<h[now])
	{
		ans1[now]++,ans2[root[now]]=depth[from[root[now]]]-depth[now];
		root[now]=lst.Pop(root[now]);
	}
	if(v[now]==0)
		lst.Mark(root[now],1,a[now]);
	else
		lst.Mark(root[now],a[now],0);
}
int main()
{
	int t=clock();
	freopen("3261.in","r",stdin);
	freopen("3261.out","w",stdout);
	
	int size = 256 << 20;
    char *p = (char*)malloc(size) + size;
    __asm__("movl %0, %%esp\n" :: "r"(p));
	
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		h[i]=read();
	for(int i=1;i<=n;i++)
		e[i].reserve(4);
	for(int i=2;i<=n;i++)
	{
		e[read()].push_back(i);
		v[i]=read(),a[i]=read();
	}
	for(int i=1;i<=m;i++)
	{
		long long w=read();
		from[i]=read();
		lst.w[i]=w;
		if(root[from[i]]==0)
			root[from[i]]=i;
		else
			root[from[i]]=lst.Merge(root[from[i]],i);
	}
	
	depth[1]=1;
	dfs(1);
	while(root[1]!=0)
	{
		ans2[root[1]]=depth[from[root[1]]];
		root[1]=lst.Pop(root[1]);
	}
	
	for(int i=1;i<=n;i++)
		printf("%d\n",ans1[i]);
	for(int i=1;i<=m;i++)
		printf("%d\n",ans2[i]);
	cerr<<clock()-t;
	return 0;
}


```






---

## 作者：Orina_zju (赞：1)

基于左偏树+懒标记push_down的解法已经有很多神犇讲了，其实这道题也可以用任意可并堆（我用的是配对堆）+启发式合并来解。

我们知道在每个节点处用一个小根堆来维护所有在该位置存活的战士。我们给每个堆作为整体打两个标记$m$和$a$，表示堆中所有战士的实际战力等于 _堆中存储的战力值_ $\times m+a$。

在合并两个堆时，根据启发式合并的思想，我们应该把较小的堆合并到较大的堆里边。首先我们要统一两个堆的标记，设小堆的标记为$m_0$和$a_0$，大堆的标记为$m_1$和$a_1$，那么在合并之前，我们要把小堆里存储的所有的战力值$x_i$改为$ \frac{(m_0x_i+a_0)-a_1}{m_1} $，然后进行合并。

单次合并的复杂度为O(小堆的大小)，启发式合并总的复杂度为$O(NlogN)$。如果用二叉堆暴力合并的话（从小堆逐个pop然后加到大堆里边），总复杂度为$O(Nlog^2N)$，对于30W的数据似乎有些危险。

这个解法有个致命的缺点就是依赖浮点数运算，过程中会产生误差。因为long long最大可以存19位数，而double的有效数字只有15位，因此精度损失还是比较严重的。经实测用double可以拿80分，改成long double之后可以AC。

代码如下，求不要吐槽写法和长度（手动允悲）

upd:修改了Buffer和Ptr的接口设计，实现了与原生指针几乎无缝的切换

```cpp
#include <algorithm>
#include <cassert>
#include <functional> //PairingHeap::Comp
#include <memory> //Buffer::get
#include <queue> //PairingHeap::for_each
#include <type_traits> //Buffer::get

#define USE_BUFFER
#define check(expr, note) assert(expr ? "note" : 0)

#ifdef USE_BUFFER
template <class T> struct Ptr;

//设置缓冲区的大小（bytes）
constexpr int buffer_size = /*题目允许的内存使用量（MB）*/ 100 * 1024 * 1024;
class Buffer
{
	char a[buffer_size]; int p = -1;
	template <class T> T* vis(int x) { return (T*)(a + x); }
	template <class T> friend class Ptr;
public:
	void init() { p = 0; } //初始化，多组数据时注意调用
	//为T类型申请一块内存，并用args...原地构造，返回内存的起始下标
	template <class T, class... Args> Ptr<T> get(Args&&... args)
	{
		static_assert(std::is_trivially_destructible<T>::value, "");
		check(p >= 0, "Please init the buffer for each test case!");
		::new(a + p) T(args...); //这里必须要#include <memory>
		int r = p; p += sizeof(T); return {r};
	}
	//辅助函数，缓冲区最多可以放多少个T类型元素
	template <class T> int capacity() const { return buffer_size / sizeof(T); }
} buffer;
//用于访问缓冲区的“指针”类型
template <class T> struct Ptr
{
	int p = -1; //p < 0时表示“空指针”
	Ptr(int x): p(x) {}
	friend Buffer;
public:
	Ptr() = default;
	Ptr<T>& operator = (std::nullptr_t) { p = -1; return *this; }
	T& operator * () {
		check(p >= 0, "Access null pointer!");
		return *buffer.vis<T>(p);
	}
	T* operator -> () {
		check(p >= 0, "Access null pointer!");
		return buffer.vis<T>(p);
	}
	//适用于const对象的重载
	const T& operator * () const {
		check(p >= 0, "Access null pointer!");
		return *buffer.vis<T>(p);
	}
	const T* operator -> () const {
		check(p >= 0, "Access null pointer!");
		return buffer.vis<T>(p);
	}
	operator bool () const { return p >= 0; } //若不为“空指针”则返回true，否则返回false
	bool operator == (Ptr<T> rhs) const {
		return p == rhs.p;
	}
	bool operator != (Ptr<T> rhs) const {
		return p != rhs.p;
	}
};
#else
struct Buffer {
	template <class T, class... Args> T* get(Args&&... args) {
		return new T(args...);
	}
	void init() {}
} buffer;
template <class T> using Ptr = T*;
#endif

//配对堆模板，默认为大根堆（与STL行为一致）
template <class T, class Comp = std::less<T>> class PairingHeap
{
	struct Node {
		T v; Ptr<Node> pre, next, ch;
		Node(const T& x): v(x) {}
	};
	using P = Ptr<Node>;

	P root; Comp comp; int cnt = 0;
	P merge_trees(P x, P y)
	{
		if (!y) return x;
		if (comp(x->v, y->v)) std::swap(x, y);
		y->next = x->ch;
		if (x->ch) x->ch->pre = y;
		y->pre = x; x->ch = y;
		return x;
	}
	void merge_children(P x)
	{
		if (!x->ch) return;
		P last = x, cur = x->ch, p1, p2;
		for (; cur && cur->next; last = cur, cur = p2) {
			p1 = cur->next, p2 = p1->next;
			cur = merge_trees(cur, p1); cur->pre = last;
		}
		if (cur) { cur->pre = last; last = cur; }
		for (cur = last; cur->pre != x; ) {
			p2 = cur->pre->pre;
			cur = merge_trees(cur, cur->pre); cur->pre = p2;
		}
		cur->next = nullptr; x->ch = cur;
	}
public:
	struct Handle {
		const P p;
		const T& value() const { return p->v; }
	};
	//返回插入位置的指针，decrease_key的时候会需要（注意不要修改返回指针的内容！！！）
	Handle push(const T& x) {
		P c = buffer.get<Node>(x);
		root = merge_trees(c, root); cnt += 1; return {c};
	}
	void pop() {
		check(cnt > 0, "Pop empty heap!");
		merge_children(root); root = root->ch; cnt -= 1;
	}
	//与另一个配对堆rhs合并，合并后rhs被清空
	void merge(PairingHeap<T, Comp>& rhs)
	{
		if (!root) { root = rhs.root; cnt = rhs.cnt; }
		else { root = merge_trees(root, rhs.root); cnt += rhs.cnt; }
		rhs.root = nullptr; rhs.cnt = 0;
	}
	//将p对应的值修改为x，使该节点在堆中的位置提升。需保证p属于该配对堆（正确性未验证）
	void decrease_key(Handle& h, const T& x)
	{
		P p = h.p; if (comp(x, p->v)) return;
		p->v = x; if (p == root) return;
		if (p->next) p->next->pre = p->pre;
		(p->pre->ch == p) ? (p->pre->ch = p->next) : (p->pre->next = p->next);
		p->next = p->pre = nullptr;
		root = merge_trees(p, root);
	}
	//对于堆中的每个值，调用函数对象func
	//注意利用func(T&)修改堆内元素时，必须保证任意两个元素修改后大小关系不变！！！
	template <class F> void for_each(F func)
	{
		if (!root) return;
		std::queue<P> que; que.push(root);
		for (; !que.empty(); que.pop())
		{
			P cur = que.front(); func(cur->v);
			if (cur->next) que.push(cur->next);
			if (cur->ch) que.push(cur->ch);
		}
	}
	const T& top() const {
		check(cnt > 0, "Access top of empty heap!");
		return root->v;
	}
	int size() const { return cnt; }
	bool empty() const { return cnt == 0; }
};

#include <cmath>
#include <cstdio>

struct Warrior
{
	long double strength;
	int id;
	bool operator < (const Warrior& rhs) const {
		return strength > rhs.strength;
	}
};

using Heap = PairingHeap<Warrior>;
using LL = long long;

struct Group
{
	Heap heap;
	LL multi = 1, add = 0;
};

void merge_groups(Group& dest, Group& src) //src to dest
{
	if (src.heap.size() < dest.heap.size())
	{
		src.heap.for_each([&dest, &src] (Warrior& x) {
			x.strength = x.strength * src.multi + src.add;
			x.strength = (x.strength - dest.add) / dest.multi;
		});
	}
	else
	{
		dest.heap.for_each([&dest, &src] (Warrior& x) {
			x.strength = x.strength * dest.multi + dest.add;
			x.strength = (x.strength - src.add) / src.multi;
		});
		dest.multi = src.multi;
		dest.add = src.add;
	}
	dest.heap.merge(src.heap);
}

const int maxN = (int)3e5 + 10;
Group group[maxN];
int N, M, F[maxN], A[maxN];
LL H[maxN], V[maxN];

int depth[maxN];
int ans_city[maxN];
int start_depth[maxN], die_at_depth[maxN];

void input()
{
	scanf("%d%d", &N, &M);
	for (int i = 1; i <= N; i++)
		scanf("%lld", H + i);

	F[1] = 0; depth[0] = 0;
	depth[1] = 1;
	for (int i = 2; i <= N; i++)
	{
		scanf("%d%d%lld", F + i, A + i, V + i);
		depth[i] = depth[F[i]] + 1;
	}
	LL S; int C;
	for (int i = 1; i <= M; i++)
	{
		scanf("%lld%d", &S, &C);
		start_depth[i] = depth[C];
		group[C].heap.push({(long double)S, i});
	}
}

inline LL actual_strength(long double x, Group& g) {
	return llround(x * g.multi + g.add);
}

void solve()
{
	for (int i = N; i >= 1; i--) //Actually BFS
	{
		Heap& h = group[i].heap;
		while (!h.empty() && actual_strength(h.top().strength, group[i]) < H[i])
		{
			die_at_depth[h.top().id] = depth[i];
			h.pop();
			ans_city[i] += 1;
		}
		if (A[i] == 0) //Add
			group[i].add += V[i];
		else {
			group[i].multi *= V[i];
			group[i].add *= V[i];
		}
		merge_groups(group[F[i]], group[i]);
	}

	for (int i = 1; i <= N; i++)
		printf("%d\n", ans_city[i]);
	for (int i = 1; i <= M; i++)
		printf("%d\n", start_depth[i] - die_at_depth[i]);
}

int main() { buffer.init(); input(); solve(); return 0; }

```

---

## 作者：ww3113306 (赞：1)

表示调这道题已经调到失智了。。。
因为昨天刚写完线段树2，所以pushdown就写得和线段树2一模一样，，，，于是，，，成功的在pushdown的地方，，，各种错

下面讲做法：
首先我们可以观察到每个骑士都是独立的，因此对于每个城池我们可以建一个堆，堆中维护的是在这个城池的骑士。

维护一个小根堆，所以如果堆顶的骑士攻击力不够的话，就可以直接pop掉，并且给城池死亡人数统计++（dead），这样用while pop完后，堆里的骑士就都是可以占领这个城池的了，

由于下面的骑士可以上来，所以这个堆要支持合并，所以我们用左偏树

因为pop完后剩下的都是合法的，所以这个时候我们就可以对剩下的骑士进行修改了。但是我们观察到，骑士很多，城池也很多，直接修改显然不太妥当。于是我们借鉴线段树的lazy标记，但是由于这里有乘法也有加法，所以我们维护两个标记，一个mul（乘法标记）,一个lazy(加法标记），

由于(x+h)*q=x*q+h*q,所以我们可以把h当做lazy，x当做当前值，q是mul,所以我们更改和下传乘法标记的时候，要同时把lazy也*=mul，

这时lazy==h*q,mul==q,因此我们要得到x*q+h*q这个结果，我们需要先乘后加

deadin[i]代表骑士i死在哪里了，dead代表死在这个城池的人数，keep是城市的生命值，其他数组应该都好懂了

因为我们观察到如果还要下传一个标记won来标记骑士又占领了一个城池的话显然是不划算的，因为mul和lazy之所以有必要就是因为过程中要用到，而won标记仅仅是最后要用而已，并且由于骑士的前进路径是一条链，所以我们直接用死亡城市深度-出发城市深度就可以得到攻占几座城了，如果没死的话死亡城市就是0，因此为了维护死亡城市-出发城市这个式子的正确性，我们的deep统计从1开始

如果还有不懂的就看代码吧，还是有少量注释的

推荐写之前先写线段树2，有利于理解如何同时维护乘法和加法标记，这里的标记本质上是一样的，但是注意不要像我一样，写完线段树2，pushdown就全写成线段树版本的，，，，于是就各种错，，，

下面的输出格式是为了方便我调试改的，所以如果你直接交上去发现too many or too few lines,,,那不是我的程序错了。。。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define R register int
#define AC 300050
#define LL long long
#define D printf("line in %d\n",__LINE__);
int n,m;
int date[AC],Next[AC],Head[AC],tot,cnt;//前向星
LL v[AC],keep[AC];int deep[AC],a[AC];//城池属性
int dead[AC],deadin[AC];//答案
int b[AC],root[AC];

inline LL read()
{
	LL x=0;char c=getchar();bool z=false;
	while(c>'9' || c<'0') 
	{
		if(c=='-') z=true;
		c=getchar();
	}
	while(c>='0' && c<='9') x=x*10+c-'0',c=getchar();
	if(!z) return x;
	else return -x;
}

inline void add(int f,int w)
{
	date[++tot]=w , Next[tot]=Head[f] , Head[f]=tot;
}

struct left_heap
{
	LL s[AC],mul[AC],lazy[AC];//骑士属性和标记,error!!!标记也要LL啊啊啊啊啊啊啊啊，因为标记也可能乘到很大啊，比如lazy和mul各种乘之类的
	int l[AC],r[AC],num[AC];
	
	inline void pushdown(int x)
	{
		int ll=l[x],rr=r[x];//error!!!这又不是线段树啊！！！！干嘛乘2啊	
		if(!mul[x]) return ;//如果mul为0，说明没有这个堆，所以
		if(mul[x] != 1)
		{
			s[ll]*=mul[x];
			mul[ll]*=mul[x];
			lazy[ll]*=mul[x];//error!!!加法标记也要乘啊！！！
			s[rr]*=mul[x];
			mul[rr]*=mul[x];
			lazy[rr]*=mul[x];
			mul[x]=1;
		}
		if(lazy[x])
		{
			s[ll]+=lazy[x];//error!!!不是线段树啊，，，，r,l不是区间了
			lazy[ll]+=lazy[x];
			s[rr]+=lazy[x];
			lazy[rr]+=lazy[x];
			lazy[x]=0;
		}
	}
	
	inline void change_add(int x,int k)
	{
		if(!x) return ;
		s[x]+=k;
		lazy[x]+=k;
	}
	
	inline void change_mul(int x,int k)
	{
		if(!x) return ;
		s[x]*=k;
		lazy[x]*=k;
		mul[x]*=k;
	}
	
	int merge(int x,int y)
	{
		pushdown(x),pushdown(y);
		if(!x || !y) return x+y;
	//	pushdown(x),pushdown(y);
		if(s[x] > s[y]) swap(x,y);
		r[x]=merge(r[x],y);
		swap(l[x],r[x]);
		return x;
	}
	
	void pop(int &x)
	{
		x=merge(l[x],r[x]);
	}
	
	inline void insert(int x,int k)
	{
		s[++cnt]=x;
		num[cnt]=k;
		mul[cnt]=1;
		root[b[k]]=merge(cnt,root[b[k]]);
	}
}heap;

void DFS(int x)
{
/*	if(a[x]) heap.change_mul(root[x],v[x]);
	else heap.change_add(root[x],v[x]);
	if(!Head[x]) return ;//如果到叶节点就返回，因为没有儿子给它了
	*/
	R now;
	for(R i=Head[x]; i ;i=Next[i])
	{
	
		now=date[i];
		deep[now]=deep[x]+1;
		DFS(now);
		root[x]=heap.merge(root[now],root[x]);
	}
	while(root[x] && heap.s[root[x]] < keep[x])
	{
		dead[x]++;
		deadin[heap.num[root[x]]]=x;
		heap.pop(root[x]);
	}
	if(a[x]) heap.change_mul(root[x],v[x]);
	else heap.change_add(root[x],v[x]);
}

void pre()
{
	int aa;
	n=read(),m=read();
	deep[1]=1;
	for(R i=1;i<=n;i++) keep[i]=read(),heap.mul[i]=1;
	for(R i=2;i<=n;i++)
	{
		aa=read(),a[i]=read(),v[i]=read();
		add(aa,i);
	}
	for(R i=1;i<=m;i++)
	{
		aa=read(),b[i]=read();
	//	printf("%d %d\n",aa,b[i]);
		if(aa >= keep[b[i]])//如果第一座城池打得下才建堆
		{
			if(!root[b[i]])
			{
				root[b[i]]=++cnt;//应该要给城池开堆,堆里存士兵，不然士兵在哪个城市有上面区别
				heap.num[cnt]=i;//因为是给城池开的堆，所以就要存编号了
				heap.s[cnt]=aa;
				heap.mul[cnt]=1;
				//printf("%d\n",i);
			}
			else heap.insert(aa,i);
		}
		else 
		{
			dead[b[i]]++;//不然就别来了
			deadin[i]=b[i];
		}
	}
}

void work()
{
	for(R i=1;i<=n;i++) printf("%d\n",dead[i]);
	printf("\n");
	for(R i=1;i<=m;i++)
		printf("%d\n",deep[b[i]] - deep[deadin[i]]);
}

int main()
{
	freopen("in.in","r",stdin);
	pre();
	DFS(1);
	work();
	fclose(stdin);
	return 0;
}
```

---

## 作者：crescentic (赞：1)

[$My$ $blog$](https://www.cnblogs.com/Spring-Araki/p/14502657.html)

[题目链接~](https://www.luogu.com.cn/problem/P3261)

**左偏树以及懒标记的应用。**

## Desprition

每个有**初始战斗力**和**出发点**的士兵，在一棵有根树上在**满足战斗力大于该点防御力**的条件下不断沿**节点父亲向上**进攻。如果不满足条件，就阵亡在该节点。求对于每个城池，输出有多少个骑士在这里牺牲；对于每个骑士，输出他攻占的城池数量。

## Solution

因为考虑到每个节点都有固定的防御值，而任意一个士兵的行动不会影响其他人且攻打同一个节点的士兵可以为多人。

所以我们考虑将所有当前攻打同一个点的士兵放进同一个组合里，按**从小到大**的顺序排列，

如果其中最小的都满足大于等于当前节点防御值的条件，那就说明组合里所有士兵都能继续向上走，就将该组合的士兵与节点父亲的组合**合并**；

如果最小的不满足条件，说明他在这里死了，就存下他的死亡记录，将他踢出组合，继续判断，直到组合内为空时停止。

咦，注意到不断合并，删除，找最小值得操作了吗？ 

**左偏树**：那不就是本大爷的主场吗？！放开那道题，让我来！(

但是，题目中也说得很明白，每次攻打成功后，士兵的战斗力会**发生变化**。每次都修改所有士兵的值肯定是不现实的，所以我们需要使用懒标记处理。标记下传的操作其实跟线段树的差不多，这里就不细讲了。有一点要注意的就是，**每次应该先修改乘法懒标记，再修改加法懒标记，而且如果当前变化是乘法，节点对应的加法标记也要修改哦~**

所以，最后的答案，都是通过士兵的死亡地和出发地求得的。

- > 有多少个骑士在这里牺牲？

只要循环一遍，在每个士兵的死亡地加一就好了。

- > 每个士兵攻占的城池数量？

就是该士兵出发节点的深度减去死亡地的深度。很简单吧~

具体讲解都在代码里了~

## Code

```cpp

#include<cstdio>
#include<cstring> 
#include<algorithm>
using namespace std;
#define il inline
#define int long long
const int N = 3e5 + 5;
int n,m,h[N],fa[N],a[N],v[N],c[N],rt[N],s[N],ls[N],rs[N],dis[N];
int dep[N],d[N],siz[N],tag[N],tag2[N];
il void read(int &x) {
	x = 0; int f = 1; char s = getchar();
	while(s < '0' || s > '9') {if(s == '-') f = -1; s = getchar();}
	while(s <= '9' && s >= '0') x = x * 10 + s - '0', s = getchar();
	x *= f;
}
il void write(int x) {
	if(x < 0) x = -x, putchar('-');
	if(x > 9) write(x / 10), x %= 10;
	putchar(x + '0');
}
il void pushdown(int x) {
	if(!tag[x] && tag2[x] == 1) return;
	if(ls[x]) {
		s[ls[x]] *= tag2[x], s[ls[x]] += tag[x];
		tag[ls[x]] *= tag2[x], tag[ls[x]] += tag[x];
		tag2[ls[x]] *= tag2[x];
	}
	if(rs[x]) {
		s[rs[x]] *= tag2[x], s[rs[x]] += tag[x];
		tag[rs[x]] *= tag2[x], tag[rs[x]] += tag[x];
		tag2[rs[x]] *= tag2[x];
	}
	tag[x] = 0, tag2[x] = 1;
}
il int merge(int x,int y) {
	if(!x || !y) return x + y;
	pushdown(x), pushdown(y);
	if(s[x] > s[y]) swap(x,y);
	rs[x] = merge(rs[x],y);
	if(dis[rs[x]] > dis[ls[x]]) swap(ls[x],rs[x]);
	dis[x] = dis[rs[x]] + 1;
	return x;
}
signed main() {
	int i;
	read(n), read(m);
	dep[1] = 1, dis[0] = -1;
	for(i = 1; i <= n; i ++) read(h[i]), rt[i] = -1; 
	for(i = 2; i <= n; i ++) read(fa[i]), read(a[i]), read(v[i]), dep[i] = dep[fa[i]] + 1;//因为题中规定了f[i] < i, 所以在 fi的深度在i之前就已经确定下来了，可以直接算i的深度 
	for(i = 1; i <= m; i ++) {
		tag2[i] = 1;
		read(s[i]), read(c[i]);
		if(~rt[c[i]]) rt[c[i]] = merge(rt[c[i]],i);//合并攻击同一节点的士兵 
		else rt[c[i]] = i;
	}
	for(i = n; i; i --) {
		while(rt[i] != -1) {
			if(s[rt[i]] < h[i]) {//如果打不下来 
				d[rt[i]] = i, pushdown(rt[i]);//该士兵阵亡，记得标记下传 
				if(!ls[rt[i]]) rt[i] = -1;/*左偏树的性质:重心向左，左边的节点数一定大于等于右边
										 	因此，如果左边都没有了，右边肯定也没有，跳出。 */
				else rt[i] = merge(ls[rt[i]],rs[rt[i]]);//否则，合并左右儿子，产生新的顶点代替当前顶点，继续比较 
			}
			else break;//如果顶点满足条件，整棵子树都满足 
		} 
		if(i == 1) break;//特判，如果已经到树根，就无法再向上了 
		if(rt[i] == -1) continue;//如果为空了，直接跳出 
		if(!a[i]) s[rt[i]] += v[i], tag[rt[i]] += v[i];
		else s[rt[i]] *= v[i], tag[rt[i]] *= v[i], tag2[rt[i]] *= v[i];
		pushdown(rt[i]);
		if(rt[fa[i]] == -1) rt[fa[i]] = rt[i];
		else rt[fa[i]] = merge(rt[fa[i]],rt[i]);//整体上走 
	}
	for(i = 1; i <= m; i ++) siz[d[i]] ++;
	for(i = 1; i <= n; i ++) write(siz[i]), puts("");
	for(i = 1; i <= m; i ++) write(dep[c[i]] - dep[d[i]]), puts("");
	return 0;
}



```

---


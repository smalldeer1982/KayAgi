# [APIO2015] 巴邻旁之桥

## 题目描述

一条东西走向的穆西河将巴邻旁市一分为二，分割成了区域 $A$ 和区域 $B$。

每一块区域沿着河岸都建了恰好 $1000000001$ 栋的建筑，每条岸边的建筑都从 $0$ 编号到 $1000000000$。相邻的每对建筑相隔 $1$ 个单位距离，河的宽度也是 $1$ 个单位长度。区域 $A$ 中的 $i$ 号建筑物恰好与区域 $B$ 中的 $i$ 号建筑物隔河相对。

城市中有 $N$ 个居民。第 $i$ 个居民的房子在区域 $P_i$ 的 $S_i$ 号建筑上，同时他的办公室坐落在 $Q_i$ 区域的 $T_i$ 号建筑上。一个居民的房子和办公室可能分布在河的两岸，这样他就必须要搭乘船只才能从家中去往办公室，这种情况让很多人都觉得不方便。为了使居民们可以开车去工作，政府决定建造不超过 $K$ 座横跨河流的大桥。

由于技术上的原因，每一座桥必须刚好连接河的两岸，桥梁必须严格垂直于河流，并且桥与桥之间不能相交。

当政府建造最多 $K$ 座桥之后，设 $D_i$ 表示第 $i$ 个居民此时开车从家里到办公室的最短距离。请帮助政府建造桥梁，使得 $D_1 + D_2 + \cdots + D_N$ 最小。


## 说明/提示

【数据范围】

所有数据都保证：$P_i$ 和 $Q_i$ 为字符 “A” 和 “B” 中的一个， $0 \leq S_i, T_i \leq 1000000000$，同一栋建筑内可能有超过 $1$ 间房子或办公室（或二者的组合，即房子或办公室的数量同时大于等于 $1$）。

子任务 1 （8 分）$K = 1$

$1 \leq N \leq 1000$


子任务 2 （14 分）$K = 1$

$1 \leq N \leq 100000$


子任务 3 （9 分）$K = 2$

$1 \leq N \leq 100$


子任务 4 （32 分）$K = 2$

$1 \leq N \leq 1000$


子任务 5 （37 分）$K = 2$

$1 \leq N \leq 100000$


## 样例 #1

### 输入

```
1 5
B 0 A 4
B 1 B 3
A 5 B 7
B 2 A 6
B 1 A 7```

### 输出

```
24
```

## 样例 #2

### 输入

```
2 5
B 0 A 4
B 1 B 3
A 5 B 7
B 2 A 6
B 1 A 7```

### 输出

```
22```

# 题解

## 作者：ix35 (赞：41)

## 这题用什么平衡树线段树...两个堆就可以搞定了

### ~~不就是常数大一点一样能过~~

首先分析一下题面，只能修一座或两座桥。如果某个人的家和办公室在一侧，那么不用过桥，可以预处理，同时，家和办公室不在一侧的，必定要过桥，可以先预处理桥的那个长度（1）。

下面分类讨论（忽视所有不用过桥的人）：

（1）K=1,那么每个人都要先走到桥，再过桥，再通过对岸走到办公室，那么在两岸走的距离实际上就是每个人的家到桥和办公室到桥的距离和，如果有tot个人，那么这个问题就抽象成：一条直线上有2\*tot个点，要找一个点使得其到所有点距离和最小，**这个点就是所有点位置的中位数。**

静态中位数是比较容易求的，只要对数组进行一次排序，返回位于最中间的值就可以了，这道题点始终是偶数个，所以中间两个点选哪个都可以。

（2）K=2，这个时候其实是把所有人分成两个区域，划分标准应该是家与办公室的坐标和（这个有很多题解已经说到了，不再证明了），左侧的人走左边的桥，右侧的人走右边的桥。那么我们可以枚举中间的分界点，然后左右分别是一个K=1的子问题，**关键在于怎么快速得出左右两边的最小距离和。**

这其实是一个动态中位数问题，我们要求出排序后每个前缀和每个后缀的中位数，这可以参考[P1168中位数](https://www.luogu.org/problemnew/show/P1168)，只需要用一个大根堆和一个小根堆，用大根堆维护较小的一半的数，用小根堆维护较大一半的数，每次来一对新的数时，先插入大根堆，此时两个堆不平衡，要把大根堆的堆顶（也就是最接近中间的那个数）移到小根堆上，然后再做检测，如果大根堆的堆顶比小根堆堆顶还大，那么交换两个堆顶。

进一步抽象，其实我们现在已经将某个前缀/后缀分成了左右两块，实际上这里的最小距离和就是：右侧点坐标和减去左侧点坐标和，**我们可以理解为是每个左侧点与一个右侧点配对，它们的连线一定经过中间的中位数，所以它们的坐标差即是最小距离和。**如此一来，我们只需在堆中插入元素时更新左右坐标和，就可以得到某个前缀/后缀的最小距离和。

整理一下思路：先按家与办公室坐标和排序，然后预处理每个前缀和每个后缀的距离和，最后枚举中间的断点，将断点两侧的距离和相加就是一种可能的答案，在所有可能答案中选取最小值。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1000010;
struct P {
	int a,b;
}p[MAXN];
int k,n,tot,cnt,x1,x2,pl[MAXN];
long long ans,haf[2][MAXN],s1,s2;    //ans是预处理值,haf[0]是前缀距离,haf[1]是后缀距离,s1是左侧坐标和,s2是右侧坐标和
char c1,c2;
priority_queue <int,vector<int>,less<int> > q1;
priority_queue <int,vector<int>,greater<int> > q2;
bool cmp (P a,P b) {
	return a.a+a.b<b.a+b.b;    //按照家和办公室坐标和排序
}
int main () {
	cin >> k >> n;
	for (int i=1;i<=n;i++) {
		cin >> c1 >> x1>> c2 >> x2;
		if (c1==c2) {
			ans+=abs(x2-x1);
		} else {
			ans++,p[++tot].a=x1;
			p[tot].b=x2,pl[++cnt]=x1;
			pl[++cnt]=x2;
		}
	}
	if (k==1) {
		sort(pl+1,pl+cnt+1);
		int pos=pl[cnt/2];
		for (int i=1;i<=cnt;i++) {
			ans+=abs(pl[i]-pos);
		}
		cout << ans << endl;
	} else {
		sort(p+1,p+tot+1,cmp);
		for (int i=1;i<=tot;i++) {
			q1.push(p[i].a),q1.push(p[i].b);
			s1+=p[i].a+p[i].b;
		   s2+=q1.top(),s1-=q1.top(),q2.push(q1.top());
			q1.pop();
			if (q1.top()>q2.top()) {    //交换堆顶
				int t=q2.top(),l=q1.top();
				q2.pop(),q1.pop();
				q2.push(l),q1.push(t);
				s1+=t-l,s2-=t-l;
			}
           	haf[0][i]=s2-s1;    //左右坐标和的差即为最小距离和
    	}
    	while (!q1.empty()) {
    		q1.pop();
		}
		while (!q2.empty()) {
    		q2.pop();
		}
		s1=s2=0;
		for (int i=tot;i>=1;i--) {
			q1.push(p[i].a),q1.push(p[i].b);
			s1+=p[i].a+p[i].b;
			s2+=q1.top(),s1-=q1.top(),q2.push(q1.top());
			q1.pop();
			if (q1.top()>q2.top()) {    //交换堆顶
				int t=q2.top(),l=q1.top();
				q2.pop(),q1.pop();
				q2.push(l),q1.push(t);
				s1+=t-l,s2-=t-l;
			}
           	haf[1][i]=s2-s1;    //左右坐标和的差即为最小距离和
		}
		long long mn=1e18;
		for (int i=1;i<=tot+1;i++) {
			mn=min(mn,haf[0][i-1]+haf[1][i]);
		}
		cout << mn+ans;    //别忘加上预处理的值
	}
	return 0;
}
```

---

## 作者：StudyingFather (赞：16)

首先，对于起点和终点在同一侧的情况，修桥对距离没有影响，可以直接累加答案。

接下来，对于起点和终点不在同一侧的情况，毫无悬念需要过一次桥，我们先提前把过桥的距离（$1$ 单位长度）累加入答案。

经过这样一轮预处理后，问题就变成了：给出 $2N$ 个点，我们需要挑一个点，使得这 $2N$ 个点到该点的距离和最小。

先考虑 $K=1$ 的情况，这其实是一个很经典的结论，最优位置显然在中位数处（即排序后第 $N$ 个点和第 $N+1$ 个点之间的任意一点）取得。

接下来是 $K=2$ 的情况。此时集合点变成了两个，画图后会发现，对于一条线段 $AB$ 而言，选择离这个线段中点较近的集合点结果最优。

考虑将所有线段按 $S_i+T_i$ 的顺序排序，枚举区域分界点，则分界点左边的区域前往左侧集合点，右边的区域前往右侧集合点，问题变成了 $K=1$ 的情况。

现在我们需要动态维护两个集合的中位数。这个有三种方式可以实现：

1. 值域线段树；
2. 平衡树；
3. 对顶堆。

前面两种实现方式这里不再展开，这里重点讲一下对顶堆的实现。

设集合大小为 $s$，我们维护一个大根堆，存放前 $\dfrac{s}{2}$ 小的元素，再维护一个小根堆，存放后 $\dfrac{s}{2}$ 小的元素，则中位数为两堆的堆顶（任取其一即可）。

插入元素时，我们先将元素插入大根堆，接着弹出堆顶放入小根堆（使两堆大小一致）。这时候可能会出现大根堆堆顶大于小根堆堆顶的情况，需要将两个堆顶交换以保证数据有序性。

```cpp
// Problem : P3644 [APIO2015]八邻旁之桥
// Contest : Luogu
// URL : https://www.luogu.com.cn/problem/P3644
// Memory Limit : 256 MB
// Time Limit : 2000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
int k,n;
namespace sub1
{
 int a[200005],cnt;
 void solve()
 {
  long long ans=0;
  for(int i=1;i<=n;i++)
  {
   string s,t;
   int x,y;
   cin>>s>>x>>t>>y;
   if(s==t)
    ans+=abs(x-y);
   else
    ans++,a[++cnt]=x,a[++cnt]=y;
  }
  sort(a+1,a+cnt+1);
  int pos=a[cnt/2];
  for(int i=1;i<=cnt;i++)
   ans+=abs(a[i]-pos);
  cout<<ans<<endl;
 }
}
namespace sub2
{
 struct point
 {
  int x,y;
  bool operator<(const point&a)const
  {
   return x+y<a.x+a.y;
  }
 }a[100005];
 int cnt;
 long long pre[100005],post[100005];
 priority_queue<int> q1;
 priority_queue<int,vector<int>,greater<int> > q2;
 void solve()
 {
  long long ans=0;
  for(int i=1;i<=n;i++)
  {
   string s,t;
   int x,y;
   cin>>s>>x>>t>>y;
   if(s==t)
    ans+=abs(x-y);
   else
    ans++,a[++cnt].x=x,a[cnt].y=y;
  }
  sort(a+1,a+cnt+1);
  long long s1=0,s2=0;
  for(int i=1;i<=cnt;i++)
  {
   q1.push(a[i].x),q1.push(a[i].y);
   s1+=a[i].x,s1+=a[i].y;
   int u=q1.top();
   q1.pop(),s1-=u;
   q2.push(u),s2+=u;
   if(q1.top()>q2.top())
   {
    int x=q1.top(),y=q2.top();
    q1.pop(),q2.pop();
    q1.push(y),q2.push(x);
    s1+=y-x,s2+=x-y;
   }
   pre[i]=s2-s1;
  }
  while(!q1.empty())
   q1.pop();
  while(!q2.empty())
   q2.pop();
  s1=0,s2=0;
  for(int i=cnt;i;i--)
  {
   q1.push(a[i].x),q1.push(a[i].y);
   s1+=a[i].x,s1+=a[i].y;
   int u=q1.top();
   q1.pop(),s1-=u;
   q2.push(u),s2+=u;
   if(q1.top()>q2.top())
   {
    int x=q1.top(),y=q2.top();
    q1.pop(),q2.pop();
    q1.push(y),q2.push(x);
    s1+=y-x,s2+=x-y;
   }
   post[i]=s2-s1;
  }
  long long sum=(cnt?1e18:0);
  for(int i=1;i<cnt;i++)
   sum=min(sum,pre[i]+post[i+1]);
  cout<<ans+sum<<endl;
 }
}
int main()
{
 cin>>k>>n;
 if(k==1)sub1::solve();
 else sub2::solve();
 return 0;
}
```

---

## 作者：斯德哥尔摩 (赞：9)

[P3644 [APIO2015]八邻旁之桥](https://www.luogu.org/problemnew/show/P3644)

注：此题解为楼上那个线段树题解的代码补充。

当$k==1$的时候，如楼上所说：

如果工作地点在一侧，那么路程就是$r-l$。

然后我们对于不在一侧的线段端点求个中位数，这样肯定能使总路程最小。

不过，$k==1$的情况没有必要线段树，直接丢进数组里排个序，就可以求出中位数了。

当K为2的时候，也如楼上所说：

取每个线段的中点，如果靠近左边的桥，就往左边过桥，否则往右边过桥。

枚举一个分割点，然后两边都是$k==1$的情况，用线段树求$\sum|\text{位置}-\text{中位数}|$即可。

附上代码，我分了两个$namespace$来写：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define MAXN 1000010
using namespace std;
int n,k;
int top=0,stack[MAXN];
long long ans=0;
inline int read(){
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
inline long long abs(const long long x){return x>0?x:-x;}
namespace one{//k==1
	int m=0;
	void main(){
		char ch[2];
		int x,y,p,q;
		for(int i=1;i<=n;i++){
			scanf("%s",ch);x=read();p=ch[0]-'A';
			scanf("%s",ch);y=read();q=ch[0]-'A';
			if(p==q){
				ans+=abs(x-y);
				continue;
			}
			else if(p==1)swap(x,y);
			m++;
			stack[++top]=x;stack[++top]=y;
		}
		sort(stack+1,stack+top+1);//直接丢进数组排序
		int mid=stack[top>>1];
		for(int i=1;i<=top;i++)ans+=abs(mid-stack[i]);
		printf("%lld\n",ans+m);
	}
}
namespace two{//k==2
	#define LSON rt<<1
	#define RSON rt<<1|1
	#define DATA(rt) a[rt].data
	#define SUM(rt) a[rt].sum
	#define LSIDE(rt) a[rt].l
	#define RSIDE(rt) a[rt].r
	int num=0;
	long long s[MAXN];
	struct Line{
		int x,y;
		friend bool operator <(const Line &p,const Line &q){
			return (p.x+p.y)<(q.x+q.y);
		}
	}line[MAXN];
	struct Segment_Tree{
		long long data,sum;
		int l,r;
	}a[MAXN<<2];
	inline void add_line(int x,int y){
		num++;
		line[num].x=x;line[num].y=y;
	}
	inline void pushup(int rt){
		DATA(rt)=DATA(LSON)+DATA(RSON);
		SUM(rt)=SUM(LSON)+SUM(RSON);
	}
	void buildtree(int l,int r,int rt){
		LSIDE(rt)=l;RSIDE(rt)=r;DATA(rt)=SUM(rt)=0;
		if(l==r)return;
		int mid=l+r>>1;
		buildtree(l,mid,LSON);
		buildtree(mid+1,r,RSON);
	}
	void update(int k,int v,int rt){
		DATA(rt)++;SUM(rt)+=v;
		if(LSIDE(rt)==RSIDE(rt))return;
		int mid=LSIDE(rt)+RSIDE(rt)>>1;
		if(k<=mid)update(k,v,LSON);
		else update(k,v,RSON);
	}
	long long query(int k,int rt){
		if(LSIDE(rt)==RSIDE(rt))return 1LL*stack[LSIDE(rt)]*k;
		if(k<=DATA(LSON))return query(k,LSON);
		else return SUM(LSON)+query(k-DATA(LSON),RSON);
	}
	inline long long ask(int x){return SUM(1)-2LL*query(x,1);}
	void work(){
		buildtree(1,top,1);
		for(int i=1;i<=num;i++){
			line[i].x=lower_bound(stack+1,stack+top+1,line[i].x)-stack;
			line[i].y=lower_bound(stack+1,stack+top+1,line[i].y)-stack;
			update(line[i].x,stack[line[i].x],1);
			update(line[i].y,stack[line[i].y],1);
			s[i]=ask(i);
		}
		long long minn=s[num];
		buildtree(1,top,1);//本蒟蒻不想建两颗线段树，所以直接重建。。。
		for(int i=num;i>=1;i--){
			update(line[i].x,stack[line[i].x],1);
			update(line[i].y,stack[line[i].y],1);
			minn=min(minn,s[i-1]+ask(num-i+1));
		}
		printf("%lld\n",minn+ans);
	}
	void main(){
		char ch[2];
		int x,y,p,q;
		for(int i=1;i<=n;i++){
			scanf("%s",ch);x=read();p=ch[0]-'A';
			scanf("%s",ch);y=read();q=ch[0]-'A';
			if(p==q){
				ans+=abs(x-y);
				continue;
			}
			ans++;
			stack[++top]=x;stack[++top]=y;
			if(x>y)swap(x,y);
			add_line(x,y);
		}
		if(!num){//记得特判！
			printf("%lld\n",ans);
			return;
		}
		sort(line+1,line+num+1);
		sort(stack+1,stack+top+1);
		top=unique(stack+1,stack+top+1)-stack-1;
		work();
	}
}
int main(){//主函数So easy!
	k=read();n=read();
	if(k==1)one::main();
	else two::main();
    return 0;
}

```

---

## 作者：fdfdf (赞：9)

这是一个$Splay$的题解

首先,如果一个人的家和办公室在同一侧,我们可以直接预处理;

如果不在同一侧,也可以**加上1**(当然要过桥啦)

****
当k==1时

我们设桥的位置为$pos$,每个人的家的位置为$x[i]$,办公室的位置为$y[i]$,

则总代价为$\sum_{i=1}^n (abs(x_i-pos)+abs(y_i-pos))$

从这里我们可以看到,其实家和办公室的区别不是很明显。

所以这个问题可以简化为:

**在数轴上任取一点a,最小化** $\sum abs(a-x_i)$

那么我们将所有家和办公室按照坐标排序,桥的位置肯定就在中间两个端点的位置之间

至于怎么统计相信大家都会吧(~~就在下面~~)

把所有家和办公室的坐标丢进一棵Splay中,平分

统计出左边的sum和右边的sum,左边的sz和右边的sz

****
当k==2时

再将上面的式子细分一下,我们能发现:

**对于每条路径$x[i]->y[i]$,其实际长度和$1/2(x[i]+y[i])$距离桥的距离有关**

于是我们可以考虑将所有路径按照$(x[i]+y[i])$排序

考虑建立两颗Splay

首先把所有的节点全部插入一棵Splay中去

然后**一对一对(注意此处)**的从老Splay中丢到另一棵Splay中去,一边统计答案

复杂度是O(nlogn)

应该是做完了

****
什么!!!!你被卡常了!!!!

在下提交的时候,第二个点总是TLE...交了无数遍的95分

看着机房的其他dalao都是用线段树做的,并不是很甘心啊......

但是方法总比困难多(hhhh)

具体可以参考我的代码

(一遍过的dalao可以略过)

****
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define RG register
#define isr(i) (s[1][fa[(i)]]==(i))

using namespace std;
typedef long long ll;
const int N=200010;
const int inf=2147483647;
int cntt;
ll Ans[N];

struct line{
    int l,r;
    bool operator <(const line &a)const{
        return (l+r)<(a.l+a.r);
    }
}t[N];

inline int read()
{
    RG int x=0,w=1;char ch=getchar();
    while ((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if (ch=='-') w=0,ch=getchar();
    while (ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return w?x:-x;
}

bool cmp(line a,line b){return (a.l+a.r)<(b.l+b.r);}

struct Splay{
    int root,tot,j,k;
    int s[2][N],fa[N],sz[N],cnt[N];
    ll sum[N],v[N];

    inline bool empty(){return !(bool)sz[root];}

    inline void clear(){
        root=tot=0;
        memset(s,0,sizeof(s));
        memset(fa,0,sizeof(fa));
        memset(sz,0,sizeof(sz));
        memset(sum,0,sizeof(sum));
        memset(cnt,0,sizeof(cnt));
        memset(v,0,sizeof(v));
    }
    
    inline void init(int i,int x,int ff){
        s[0][i]=s[1][i]=0;fa[i]=ff;
        v[i]=sum[i]=x;cnt[i]=sz[i]=1;
    }
    
    inline void update(int i){
        sz[i]=sz[s[0][i]]+sz[s[1][i]]+cnt[i];
        sum[i]=sum[s[0][i]]+sum[s[1][i]]+cnt[i]*v[i];
    }

    inline void rot(int i){
        j=fa[i];k=fa[j];
        RG bool b=isr(i);
        fa[i]=k;s[isr(j)][k]=i;
        if(s[!b][i])fa[s[!b][i]]=j;s[b][j]=s[!b][i];
        fa[j]=i;s[!b][i]=j;
        update(j);
    }

    inline void splay(int i,int a){
        if(!a)root=i;
        while(fa[i]^a){
            j=fa[i];
            if(fa[j]^a)
                isr(i)^isr(j)?rot(i):rot(j);
            rot(i);
        }
        update(i);
    }

    inline void insert(int x){
        RG int i=root,ff=0;
        while(v[i]!=x&&i){
            ff=i;i=s[v[i]<x][i];
        }
        if(i&&v[i]==x)cnt[i]++;
        else{
            i=++tot;
            if(ff)s[v[ff]<x][ff]=i;
            init(i,x,ff);
            if(x==inf||x==-inf){
                sz[i]=sum[i]=cnt[i]=0;
            }
        }
        splay(i,0);
    }

    inline int find(int x){
        RG int i=root;
        while(v[i]!=x&&s[v[i]<x][i])
            i=s[v[i]<x][i];
        return i;
    }
    
    inline void Next(int x,int &lst,int &nxt){
        RG int i=find(x);splay(i,0);
        if(v[i]>x)nxt=i;
        else {
            nxt=s[1][i];
            while(s[0][nxt])nxt=s[0][nxt];
        }
        if(v[i]<x)lst=i;
        else{
            lst=s[0][i];
            while(s[1][lst])lst=s[1][lst];
        }
    }
    
    inline void Delete(int x){
        RG int i=find(x);
        cnt[i]--;splay(i,0);
    }
    
    inline int kth(int k){
        RG int i=root;
        while(1){
            if(sz[s[0][i]]>=k)i=s[0][i];
            else if(sz[s[0][i]]+cnt[i]>=k)return i;
            else k-=sz[s[0][i]]+cnt[i],i=s[1][i];
        }
    }
    
    inline ll bridge(){//这里是统计答案(不开long long可是会炸飞的)
        if(empty())return 0;
        int i=kth(sz[root]/2);splay(i,0);
        return 1ll*sz[s[0][i]]*v[i]-sum[s[0][i]]+sum[s[1][i]]-1ll*sz[s[1][i]]*v[i];
    }
}A,B;

inline ll input(ll n){
    RG char p[5],q[5];
    RG ll ans=0;RG int s,T;
    
    cntt=0;
    A.insert(inf);A.insert(-inf);
    B.insert(inf);B.insert(-inf);
    
    for(RG int i=1;i<=n;i++){
        scanf("%s",p+1);s=read();
        scanf("%s",q+1);T=read();
        if(p[1]!=q[1]){
            ans++;
            t[++cntt].l=s;t[cntt].r=T;
        }
        else ans+=abs(s-T);
    }
    sort(t+1,t+cntt+1);
    for(RG int i=1;i<=cntt;i++){
        A.insert(t[i].l);A.insert(t[i].r);
        Ans[i]=A.bridge();
        /*
            最关键的地方就是这里
            直接记录一个Ans数组表示前i条路径全部走到一座桥上的答案
            之后就不用删除了,把路径倒着插入另外一棵线段树中统计即可
         */
    }
    
    return ans;
}

inline void work2(int k,int n){
    
    RG ll ans=input(n);
    RG ll minn=Ans[cntt];
    if(A.empty()){
        printf("%lld\n",ans);
        return;
    }
    
    for(RG int i=cntt;i>=1;i--){
        B.insert(t[i].l);B.insert(t[i].r);
        minn=min(minn,Ans[i-1]+B.bridge());
        //倒插统计部分
    }

    printf("%lld\n",minn+ans);
}

inline void work1(int k,int n){
    printf("%lld\n",input(n)+A.bridge());
}

int main()
{
    RG int k,n;
    k=read();n=read();
    if(k^1)work2(k,n);
    else work1(k,n);
    return 0;
}
/*
    k==1
    把l,r都丢splay里,取其中位数暴力统计
    k==2
    把l,r都丢到右边的splay里,
    之后一个一个地提取左节点和右节点并依次统计
*/

```

---

## 作者：Ebola (赞：7)


对于两个点在同一端的建筑，桥对它不造成影响，直接加入答案不管了，我们只需考虑其它的即可

容易发现答案已经与哪一侧无关了，所以可以把所有剩下的坐标一起看待，答案就是他们与桥坐标差之和加上剩余坐标数量的一半（即路径经过桥的次数）

考虑K=1的情况，显然是将桥建在这些坐标的中位数上，直接用中位数算出答案即可

考虑K=2的情况，建两座桥显然比建一座桥更优，故不必再去考虑只建1座桥。

显然的，若对于某组坐标，肯定会选择较为靠近它们中点的桥来走。所以我们可以考虑枚举分界点，分界点左边的所有点都走左桥，右边的都走右桥。至于桥建在哪里，对两边分别求出中位数就是了。

求出中位数之后，还要算出所有坐标与中位数坐标差的和，根据绝对值分类讨论进行区间求和即可

分界点每往右移动一次，右边元素就减少一个，左边元素增加一个。所以我们现在需要两个能支持快速插入元素、删除元素、查询中位数、值域区间求和的数据结构，显然权值线段树就是最佳选择了

对了，我一开始的中位数查询是这么写的：对于一个值域区间，若左子树比右子树大，就往左走，否则往右走，然后就开心WA了……至于这么写为什么是错的……哎，不说了，我怕不是个智障

```cpp
#include<bits/stdc++.h>
#define FR first
#define SE second
using namespace std;

typedef long long LL;
typedef pair<LL,int> pli;
const int N=200010;
int n,tot=0,K;
LL must=0;
int A[N],Hash[N];
struct Type{int x,y,mid;} B[N];

pli operator + (const pli &a,const pli &b){return pli(a.FR+b.FR,a.SE+b.SE);}

struct Seg
{
    LL val[N<<2];int sz[N<<2];
    void build(int o,int l,int r)
    {
        val[o]=sz[o]=0;
        if(l==r) return;
        int mid=(l+r)/2;
        build(o<<1,l,mid);
        build(o<<1|1,mid+1,r);
    }
    void insert(int o,int l,int r,int k,int x)
    {
        val[o]+=x;sz[o]++;
        if(l==r) return;
        int mid=(l+r)/2;
        if(k<=mid) insert(o<<1,l,mid,k,x);
        else insert(o<<1|1,mid+1,r,k,x);
    }
    void remove(int o,int l,int r,int k,int x)
    {
        val[o]-=x;sz[o]--;
        if(l==r) return;
        int mid=(l+r)/2;
        if(k<=mid) remove(o<<1,l,mid,k,x);
        else remove(o<<1|1,mid+1,r,k,x);
    }
    pli query(int o,int l,int r,int nl,int nr)
    {
        if(nl>nr) return pli(0,0);
        if(l>=nl&&r<=nr) return pli(val[o],sz[o]);
        int mid=(l+r)/2;pli res(0,0);
        if(nl<=mid) res=res+query(o<<1,l,mid,nl,nr);
        if(nr>mid) res=res+query(o<<1|1,mid+1,r,nl,nr);
        return res;
    }
    int midnum(int o,int l,int r,int L=0,int R=0)
    {
        if(!sz[o]) return -1;
        if(l==r) return l;
        int mid=(l+r)/2,szl=sz[o<<1],szr=sz[o<<1|1];
        if(szl+L>=szr+R) return midnum(o<<1,l,mid,L,R+szr);
        else return midnum(o<<1|1,mid+1,r,szl+L,R);
    }
} t1,t2;

int work1()
{
    sort(A+1,A+1+tot);
    int pp=A[tot/2];LL res=0;
    for(int i=1;i<=tot;i++) res+=abs(pp-A[i]);
    printf("%lld\n",res+tot/2+must);
    return 0;
}

int work2()
{
    int fuck=0,m=0;
    for(int i=1;i<=tot;i+=2)
    {
        B[++m].mid=(A[i]+A[i+1])/2;
        B[m].x=Hash[++fuck]=A[i];
        B[m].y=Hash[++fuck]=A[i+1];
    }
    sort(Hash+1,Hash+1+fuck);
    int hs=unique(Hash+1,Hash+1+fuck)-(Hash+1);
    t1.build(1,1,hs);t2.build(1,1,hs);
    for(int i=1;i<=m;i++)
    {
        B[i].x=lower_bound(Hash+1,Hash+1+hs,B[i].x)-Hash;
        B[i].y=lower_bound(Hash+1,Hash+1+hs,B[i].y)-Hash;
        t2.insert(1,1,hs,B[i].x,Hash[B[i].x]);
        t2.insert(1,1,hs,B[i].y,Hash[B[i].y]);
    }
    sort(B+1,B+1+m,[](Type a,Type b){return a.mid<b.mid;});
    int pl=1;LL ans=INT64_MAX,tmp;
    for(int i=1;i<=m;i++)
    {
        t2.remove(1,1,hs,B[i].x,Hash[B[i].x]);
        t2.remove(1,1,hs,B[i].y,Hash[B[i].y]);
        t1.insert(1,1,hs,B[i].x,Hash[B[i].x]);
        t1.insert(1,1,hs,B[i].y,Hash[B[i].y]);
        int m1=t1.midnum(1,1,hs),m2=t2.midnum(1,1,hs);tmp=0;
        if(~m1)
        {
            pli p1=t1.query(1,1,hs,1,m1);
            pli p2=t1.query(1,1,hs,m1+1,hs);
            tmp+=1ll*Hash[m1]*p1.SE-p1.FR;
            tmp+=p2.FR-1ll*Hash[m1]*p2.SE;
        }
        if(~m2)
        {
            pli q1=t2.query(1,1,hs,1,m2);
            pli q2=t2.query(1,1,hs,m2+1,hs);
            tmp+=1ll*Hash[m2]*q1.SE-q1.FR;
            tmp+=q2.FR-1ll*Hash[m2]*q2.SE;
        }
        ans=min(ans,tmp);
    }
    printf("%lld\n",ans+m+must);
    return 0;
}

int main()
{
    int x,y;
    char s[5],t[5];
    scanf("%d%d",&K,&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%s%d%s%d",s,&x,t,&y);
        if(s[0]==t[0]) must+=abs(x-y);
        else A[++tot]=x,A[++tot]=y;
    }
    if(!tot) return printf("%lld\n",must),0;
    if(K==1) return work1();
    return work2();
}
```



---

## 作者：VenusM1nT (赞：6)

$\text{FHQ Treap}$。一开始写的不知道为什么写炸了，还以为不能用，不过后来找了一个 [$\text{dalao}$的博客](https://www.cnblogs.com/ppprseter/p/9385979.html) 重构了一下代码，总算还是过掉了。

如第一篇题解所说，$k=1$ 就直接算，$k=2$ 就枚举一个分割线，左右分别算，不过其实不用建两棵树，而是可以先预处理一下，然后就可以重复使用同一棵树（要清空），数据结构要支持区间插入、中值查询、区间和，线段树似乎不错，但我不知道怎么查中值【流下菜鸡的泪水】，所以还是写了~~一生所爱~~ $\text{FHQ Treap}$，维护下传一个 $sum$ 标记即可。

写时为了防止读入字符出错使用了关闭流同步的 `cin`，同时使用 `cout` 输出，各位有需要可以自行修改。

```cpp
#include<bits/stdc++.h>
#define MAXN 100005
#define ll long long
using namespace std;
struct FHQTreap
{
	int son[2],key,siz;
	ll val,sum;
}t[MAXN<<1];
struct Node
{
	int l,r,mid;
	friend bool operator < (const Node &x,const Node &y)
	{
		return x.mid<y.mid;
	}
}a[MAXN];
int k,n,siz,root,tot;
ll ans[MAXN],Ans;
void Update(int x)
{
	t[x].siz=t[t[x].son[0]].siz+t[t[x].son[1]].siz+1;
	t[x].sum=t[t[x].son[0]].sum+t[t[x].son[1]].sum+t[x].val;
}
int NewNode(ll val)
{
	t[++siz].siz=1;
	t[siz].val=val;
	t[siz].key=rand();
	t[siz].sum=val;
	return siz;
}
int Merge(int x,int y)
{
	if(!x || !y) return x+y;
	if(t[x].key<t[y].key)
	{
		t[x].son[1]=Merge(t[x].son[1],y);
		Update(x);
		return x;
	}
	else
	{
		t[y].son[0]=Merge(x,t[y].son[0]);
		Update(y);
		return y;
	}
}
void Split(int rt,int pos,int &l,int &r)
{
	if(!rt) l=r=0;
	else
	{
		if(t[rt].val<=pos)
		{
			l=rt;
			Split(t[rt].son[1],pos,t[rt].son[1],r);
		}
		else
		{
			r=rt;
			Split(t[rt].son[0],pos,l,t[rt].son[0]);
		}
		Update(rt);
	}
}
ll FindKth(int rt,int pos)
{
	while(1)
	{
		if(pos<=t[t[rt].son[0]].siz) rt=t[rt].son[0];
		else if(pos==t[t[rt].son[0]].siz+1) return t[rt].val;
		else
		{
			pos-=t[t[rt].son[0]].siz+1;
			rt=t[rt].son[1];
		}
	}
}
void Insert(ll val)
{
	int x,y;
	Split(root,val,x,y);
	root=Merge(Merge(x,NewNode(val)),y);
}
ll Query(ll val)
{
	int x,y;
	ll sum=t[root].siz/2,res=0;
	Split(root,val-1,x,y);
	res=t[x].sum*2+val*(sum-t[x].siz)*2;
	root=Merge(x,y);
	return res;
}
ll CalcMid()
{
	ll rk=FindKth(root,t[root].siz/2);
	return t[root].sum-Query(rk);
}
int main()
{
	ios::sync_with_stdio(0);
	cin>>k>>n;
	for(int i=1;i<=n;i++)
	{
		int x,y;
		char opt1,opt2;
		cin>>opt1>>x>>opt2>>y;
		if(x>y) swap(x,y);
		if(opt1==opt2) Ans+=y-x;
		else a[++tot]=((Node){x,y,x+y});
	}
	sort(a+1,a+tot+1);
	for(int i=1;i<=tot;i++)
	{
		Insert(a[i].l);
		Insert(a[i].r);
		ans[i]=CalcMid();
	}
	if(k==1) return cout<<ans[tot]+Ans+tot<<endl,0;
	ll cnt=ans[tot];
	for(int i=0;i<=siz;i++) t[i].son[0]=t[i].son[1]=0;
	root=siz=0;
	for(int i=tot;i>=1;i--)
	{
		Insert(a[i].l);
		Insert(a[i].r);
		cnt=min(cnt,ans[i-1]+CalcMid());
	}
	cout<<cnt+Ans+tot<<endl;
	return 0;
}
```

---

## 作者：tommymio (赞：4)

似乎很不可做，然而 $K\leq 2$ ，告诉我们这是道分类讨论题。

发现我们只需要考虑不在同一个区域的情况，在同一个区域的可以直接累加进答案。设在第 $i$ 个人的家在 $A/B$ 区域的 $a_i$ 位置，公司在另一个区域的 $b_i$ 位置：

当 $K=1$ 时，要求出 $\sum|X-a_i|+|X-b_i|$ 的最小值。经典中位数问题。

当 $K=2$ 时，要求出 $\sum_i\min(|X_1-a_i|+|X_1-b_i|,|X_2-a_i|+|X_2-b_i|)$ 的最小值。不需要考虑只修一座桥的情况，因为修两座桥一定更优。对于这类划分成两个集合求 $\min$ 的问题，我们一般会枚举划分点。

在本题中，我们发现对于任意 $X_1,X_2$，第 $i$ 个人走 $X_1$ 这座桥，仅当 $|X_1-\frac{a_i+b_i}{2}|<|X_2-\frac{a_i+b_i}{2}|$。非常容易证明，如果 $X_1,X_2$ 在 $[a_i,b_i]$ 间，选哪个都是一样的。如果 $X_1,X_2$ 在 $[a_i,b_i]$ 外，且同侧，也是显然的。如果不同侧，对称一下，和同侧是一样的。于是证毕。

那么，按 $\frac{a_i+b_i}{2}$ 的大小排序。枚举每个分界点，分界点左边的走左边的桥，右边的走右边的桥，其实就是对每个前缀后缀分别求中位数。动态求中位数，最好写的方式是对顶堆，但是还需要维护一个和，这个东西直接做似乎不好处理。

观察一下，会发现无论何时，两个堆里的元素个数都是相同的，并且 $|X-a_i|+|X-b_i|$ 事实上可以被拆分开，然后就可以直接做了/se。可以得到，这个和就是大根堆中数的和 $-$ 小根堆中数的和，这样我们就可以非常方便的维护了。

```cpp
#include<cstdio>
#include<cmath>
#include<queue>
#include<algorithm>
typedef long long ll;
int num=0;
ll ans=0;
std::priority_queue<int,std::vector<int>,std::greater<int> > Q1;
std::priority_queue<int,std::vector<int>,std::less<int> > Q2;
struct node {int x,y;} c[100005];
char s1[2],s2[2];
ll suff[100005],pref[100005];
inline ll min(const ll &x,const ll &y) {return x<y? x:y;}
inline bool cmp(const node &x,const node &y) {return x.x+x.y<y.x+y.y;}
int main() {
    int K,n; scanf("%d%d",&K,&n);
    ll sum1=0,sum2=0;
    for(register int i=1;i<=n;++i) {
        int a,b; 
        scanf("%s%d%s%d",s1,&a,s2,&b);
        if(s1[0]==s2[0]) {ans+=abs(b-a);}
        else {++ans; c[++num].x=a; c[num].y=b;}
    }
    if(K==1) {
        for(register int i=1;i<=num;++i) {
            Q1.push(c[i].x);Q1.push(c[i].y);
            sum1+=c[i].x;sum1+=c[i].y;
            sum1-=Q1.top(); sum2+=Q1.top(); Q2.push(Q1.top()); Q1.pop();
            if(Q1.top()<Q2.top()) {
                int tmp1=Q1.top(),tmp2=Q2.top(); Q1.pop(); Q2.pop();
                Q1.push(tmp2); Q2.push(tmp1); sum1+=tmp2-tmp1; sum2-=tmp2-tmp1;
            } 
        }
        printf("%lld\n",sum1-sum2+ans);
    }
    else {
        std::sort(c+1,c+1+num,cmp);
        for(register int i=1;i<=num;++i) {
            Q1.push(c[i].x);Q1.push(c[i].y);
            sum1+=c[i].x;sum1+=c[i].y;
            sum1-=Q1.top(); sum2+=Q1.top(); Q2.push(Q1.top()); Q1.pop();
            if(Q1.top()<Q2.top()) {
                int tmp1=Q1.top(),tmp2=Q2.top(); Q1.pop(); Q2.pop();
                Q1.push(tmp2); Q2.push(tmp1); sum1+=tmp2-tmp1; sum2-=tmp2-tmp1;
            } 
            pref[i]=sum1-sum2;
        }
        while(Q1.size()) Q1.pop();
        while(Q2.size()) Q2.pop();
        sum2=sum1=0;
        for(register int i=num;i>=1;--i) {
            Q1.push(c[i].x);Q1.push(c[i].y);
            sum1+=c[i].x;sum1+=c[i].y;
            sum1-=Q1.top(); sum2+=Q1.top(); Q2.push(Q1.top()); Q1.pop();
            if(Q1.top()<Q2.top()) {
                int tmp1=Q1.top(),tmp2=Q2.top(); Q1.pop(); Q2.pop();
                Q1.push(tmp2); Q2.push(tmp1); sum1+=tmp2-tmp1; sum2-=tmp2-tmp1;
            } 
            suff[i]=sum1-sum2;
        } 
        ll mn=1e15;
        for(register int i=0;i<=num;++i) mn=min(mn,pref[i]+suff[i+1]);
        printf("%lld\n",ans+mn);
    }
    return 0;
}
```

---

## 作者：MikukuOvO (赞：2)

首先如果家和公司同侧那么直接统计答案即可。

考虑$k=1$：

不难发现我们要求的就是$\sum abs(pos-a[i])+abs(b[i]-pos)$，这个式子显然可以拆开考虑，于是问题就成了给定数轴上的$n$个点，求一个点到所有点的距离之和最小，直接求中位数即可。

考虑$k=2$：

首先明确一件事情，如果有两个桥，那么走离$\frac{a[i]+b[i]}{2}$近的桥距离更优。

关于证明可以分类讨论一下，首先在$a[i],b[i]$之间的桥距离都相等，对于外面的桥画个图就比较显然了。

我们按照$\frac{a[i]+b[i]}{2}$排序，那么我们考虑枚举一个分界点，在左边都走左边的桥，右边都走右面的桥，那么我们维护一个支持加点，删点，求中位数，求区间和的数据结构即可，可能线段树好写一些？

```cpp
int k,n;

namespace Subtask1
{
    const int N=2e5+5;
    
    int m;
    int a[N];
    
    void solve()
    {
	ll ans=n;
	for(int i=1,x,y;i<=n;++i)
	{
	    char s1[2],s2[2];
	    scanf("%s",s1),gi(x);
	    scanf("%s",s2),gi(y);
	    if(s1[0]==s2[0]) ans+=abs(x-y)-1;
	    else a[++m]=x,a[++m]=y;
	}
	sort(a+1,a+m+1);
	int ave=a[(m+1)/2];
	for(int i=1;i<=m;++i) ans+=abs(a[i]-ave);
	print(ans);
    }
}
namespace Subtask2
{
    const int N=2e5+5;

    #define ls o<<1
    #define rs o<<1|1

    ll a[N<<1];
    struct tree
    {
	int l[N<<3],r[N<<3];
	ll siz[N<<3],sum[N<<3];

	void update(int o)
	{
	    siz[o]=siz[ls]+siz[rs];
	    sum[o]=sum[ls]+sum[rs];
	}
	void build(int x,int y,int o)
	{
	    l[o]=x,r[o]=y;
	    if(x==y) return;
	    int mid=(x+y)>>1;
	    build(x,mid,ls),build(mid+1,y,rs);
	}
	void modify(int x,ll v,int o)
	{	    
	    if(l[o]==r[o])
	    {
		siz[o]+=v,sum[o]+=v*a[x];
		return;
	    }
	    int mid=(l[o]+r[o])>>1;
	    if(x<=mid) modify(x,v,ls);
	    else modify(x,v,rs);
	    update(o);
	}
	ll find(int k,int o)
	{
	    if(l[o]==r[o]) return l[o];
	    int mid=(l[o]+r[o])>>1;
	    if(k<=siz[ls]) return find(k,ls);
	    else return find(k-siz[ls],rs);
	}
	ll qsize(int x,int y,int o)
	{
	    if(l[o]>=x&&r[o]<=y) return siz[o];
	    int mid=(l[o]+r[o])>>1;
	    ll res=0;
	    if(x<=mid) res+=qsize(x,y,ls);
	    if(y>mid) res+=qsize(x,y,rs);
	    return res;
	}
	ll qsum(int x,int y,int o)
	{
	    if(l[o]>=x&&r[o]<=y) return sum[o];
	    int mid=(l[o]+r[o])>>1;
	    ll res=0;
	    if(x<=mid) res+=qsum(x,y,ls);
	    if(y>mid) res+=qsum(x,y,rs);
	    return res;
	}
    };
    tree t1,t2;
    struct seg
    {
	int l,r;
	bool operator<(const seg &x)const
	{
	    return l+r<x.l+x.r;
	}
    };
    seg e[N];
    int m,cnt;
    
    void solve()
    {
	ll ans=0;
	for(int i=1,x,y;i<=n;++i)
	{
	    char s1[2],s2[2];
	    scanf("%s",s1),gi(x);
	    scanf("%s",s2),gi(y);
	    if(s1[0]==s2[0]) ans+=abs(x-y);
	    else
	    {
		a[++m]=x,a[++m]=y;
		e[++cnt].l=x,e[cnt].r=y;
		++ans;
	    }
	}
	if(!cnt)
	{
	    print(ans);
	    end();
	}
	sort(a+1,a+m+1),sort(e+1,e+cnt+1);
	m=unique(a+1,a+m+1)-a-1;
	for(int i=1;i<=cnt;++i)
	{
	    e[i].l=lower_bound(a+1,a+m+1,e[i].l)-a;
	    e[i].r=lower_bound(a+1,a+m+1,e[i].r)-a;
	}
	t1.build(1,m,1),t2.build(1,m,1);
	for(int i=1;i<=cnt;++i)
	{
	    t2.modify(e[i].l,1,1);
	    t2.modify(e[i].r,1,1);
	}
	ll tmp=LINF;
	for(int i=1;i<=cnt;++i)
	{
	    t1.modify(e[i].l,1,1),t1.modify(e[i].r,1,1);
	    t2.modify(e[i].l,-1,1),t2.modify(e[i].r,-1,1);
	    int m1=t1.find(i,1),m2=t2.find(cnt-i,1);
	    ll d1=t1.qsize(1,m1,1)*a[m1]-t1.qsum(1,m1,1)+t1.qsum(m1,m,1)-t1.qsize(m1,m,1)*a[m1];
	    ll d2=t2.qsize(1,m2,1)*a[m2]-t2.qsum(1,m2,1)+t2.qsum(m2,m,1)-t2.qsize(m2,m,1)*a[m2];
	    tmp=min(tmp,d1+d2);
	}
	print(ans+tmp);
    }
}
int main()
{
    fio();
    gi(k),gi(n);
    if(k==1) Subtask1::solve();
    else Subtask2::solve();
    end();
}
```

---

## 作者：FutaRimeWoawaSete (赞：1)

先考虑一座桥怎么做。              

令桥的坐标为 $k$，考虑一个点的计算方式为 $|x-k| + |y-k|$ 所以把所有的 $x,y$ 扔到数轴上去算中位数即可。             

考虑两座桥，猜测应该是维护一边一边的关系，我们发现对于两座桥，一个点显然选最近的一座桥，即 $|x - k| + |y - k|$ 小的那个。           

由于 $x \leq y$，并且 $k$ 在区间中的情况不影响答案。考虑 $k$ 在区间 $[x , y]$ 外的情况，此时我们知道如果 $k < x$ 那么它对答案多的贡献就是 $x - k$，否则就是 $k - y$，考虑如何对于两种情况都可以涉及一个相同的选择方案。              

令一个区间 $[x,y]$ 的中点为 $mid$，我们发现比较 $|mid - k|$ 的大小是等价的，所以将原先的所有区间按照区间中点排序，然后枚举从中间哪个点开始分割成左右两边。               

也可以换一种思路证明贪心的正确性：最优情况下的两座桥必定一左一右，那么按照中点排序后必定有一个分界点，满足左边的区间距离最近的桥是左边的桥，右边的区间距离最近的桥是右边的桥，那么同理枚举分界点后寻找两边的最优方案一定可以找到这个最优方案。             

用平衡树或者堆维护的时间复杂度都是 $O(n \log n)$。            

```cpp
/*
考虑对原图连线，一条桥与连线相交即可让一个人走出最短路
不妨把对岸也给搬过来，问题是等价的
发现一条桥时很好处理，两条桥需要考虑一些额外的东西
令桥的坐标为k，则一个人的最短路即为|x - k| + |y - k|
如果有两座桥，显然选最近的那座桥更优，发现此时肯定这座桥到两点的中点都最近
所以可以将原问题变为划分平面使得左半边被一座桥管辖，右半边被一座桥管辖，而且我们有了上述“距离两点都最近”的性质后直接左端点排序即可
现在求前缀最优和后缀最优最后组合一下最小值就好了
现在的子问题是在一次函数y=x上选一个点使得其到所有点的距离最小
考虑如果只有一维就是中间点，两维的话我们分别计算中间点，然后取两个区间的“中点”即可，定义两个区间的中点即 
*/
#include "bits/stdc++.h"
using namespace std;
const int Len = 3e5 + 5;
int n,k,tot,lsh[Len],tlsh;
long long ans,Pre[Len],Suf[Len],sum[Len],res;
struct node
{
	int x,y;
}Sec[Len];
bool cmp(node x,node y){return (x.x + x.y) / 2 < (y.x + y.y) / 2;}
struct Node
{
	int l,r,siz,val,key;
	long long sum;
	Node(){l = r = siz = val = key = sum = 0;}
};
struct fhq_treap
{
	Node fhq[Len];int cnt,root,X,Y;
	void clear()
	{
		for(int i = 1 ; i <= cnt ; i ++) fhq[i].l = fhq[i].r = fhq[i].siz = fhq[i].val = fhq[i].key = fhq[i].sum = 0;
		cnt = root = 0;
	}
	int newnode(int val)
	{
		cnt ++;
		fhq[cnt].val = fhq[cnt].sum = val;
		fhq[cnt].l = fhq[cnt].r = 0 , fhq[cnt].siz = 1;
		fhq[cnt].key = rand();
		return cnt;
	}
	#define ls fhq[p].l 
	#define rs fhq[p].r 
	void update(int p)
	{
		fhq[p].siz = fhq[ls].siz + fhq[rs].siz + 1;
		fhq[p].sum = fhq[ls].sum + fhq[rs].sum + fhq[p].val;
	}
	void split(int now,int val,int &x,int &y)
	{
		if(!now) x = y = 0;
		else
		{
			if(fhq[now].val <= val)
			{
				x = now;
				split(fhq[now].r , val , fhq[now].r , y);
			}
			else
			{
				y = now;
				split(fhq[now].l , val , x , fhq[now].l);
			}
			update(now);
		}
	}
	int merge(int x,int y)//保证y >= x 
	{
		if(!x || !y) return x + y;
		if(fhq[x].key < fhq[y].key)
		{
			fhq[x].r = merge(fhq[x].r , y);
			update(x);
			return x;
		}
		else
		{
			fhq[y].l = merge(x , fhq[y].l);
			update(y);
			return y;
		}
	}
	void Ins(int val)
	{
		split(root , val - 1 , X , Y);
		root = merge(merge(X , newnode(val)) , Y);
	}
	int Rank_to_num(int rank)
	{
		int now = root;
		while(now)
		{
			if(fhq[fhq[now].l].siz + 1 == rank) return fhq[now].val;
			else if(fhq[fhq[now].l].siz >= rank) now = fhq[now].l;
			else rank -= fhq[fhq[now].l].siz + 1 , now = fhq[now].r;
		}
	}
	void Sum(int val,long long &now)
	{
		split(root , val , X , Y);
		now += 1ll * val * fhq[X].siz - fhq[X].sum + fhq[Y].sum - 1ll * val * fhq[Y].siz;
		root = merge(X , Y);
	}
}S1,S2;
int Mid(int l,int r){return (l + r) >> 1;}
char s[5],ss[5];
int main()
{
	srand(time(0));
	scanf("%d %d",&k,&n);
	for(int i = 1 ; i <= n ; i ++)
	{
		int x,y;
		scanf("%s",s);
		scanf("%d",&x);
		scanf("%s",ss);
		scanf("%d",&y);
		if(x > y) swap(x , y);
		if(s[0] == ss[0]) res += y - x;
		else
		{
			++ tot;
			Sec[tot].x = x , Sec[tot].y = y;
		}
	}
	if(!tot) 
	{
		printf("%lld\n",res);
		return 0;
	}
	S1.clear();
	sort(Sec + 1 , Sec + 1 + tot , cmp);
	for(int i = 1 ; i <= tot ; i ++) 
	{
		S1.Ins(Sec[i].x);
		S1.Ins(Sec[i].y);
		int l,r;
		l = S1.Rank_to_num(i);
		r = S1.Rank_to_num(i + 1);
		int MMid = Mid(l , r);
		S1.Sum(MMid , Pre[i]);
	}
	if(k == 1)
	{
		printf("%lld\n",res + tot + Pre[tot]);
		return 0;
	}
	S1.clear();
	for(int i = tot ; i >= 1 ; i --)
	{
		S1.Ins(Sec[i].x);
		S1.Ins(Sec[i].y);
		int l,r;
		l = S1.Rank_to_num(tot - i + 1);
		r = S1.Rank_to_num(tot - i + 2);
		int MMid = Mid(l , r);
		S1.Sum(MMid , Suf[i]);
	}
	ans = 1e18;
	for(int i = 1 ; i < tot ; i ++) ans = min(ans , Pre[i] + Suf[i + 1]);
	printf("%lld\n",res + ans + tot);
	return 0;
}
```

---

## 作者：tzc_wk (赞：1)

[题面传送门](https://www.luogu.com.cn/problem/P3644)

题意：

一条河将大地分为 $A,B$ 两个部分。两部分均可视为一根数轴。

有 $n$ 名工人，第 $i$ 名的家在 $x_i$ 区域的 $a_i$ 位置，公司在 $y_i$ 区域的 $b_i$ 位置。

现在你可以建立 $k$ 座桥，在 $x$ 位置建立一座桥可以连接 $A$ 区域的 $x$ 位置和 $B$ 区域的 $x$ 位置，桥长为 $1$ 个单位长度。

设 $d_i$ 为第 $i$ 名工人从家到公司走过的最短距离，求 $D=d_1+d_2+\dots+d_n$ 的最小值。

$n \in [1,2\times 10^5],k\in\{1,2\},a_i,b_i \leq 10^9,x_i,y_i \in \{'A','B'\}$。

一开始看错题了，以为 $k$ 的数据范围也是 $10^5$。。。。。。然后就不愿意继续想下去了。

首先如果家和公司在河同一边那方案肯定是唯一的，直接加上 $|a_i-b_i|$。

接下来重点考虑家和公司不在河同一边的情况，假设这些工人 $d_i$ 的和为 $D'$

先从 $k=1$ 入手，假设我们在 $p$ 位置建了座桥，那么所有家和公司不在河同一边都必须通过这一座桥，即 $d_i=|a_i-p|+|b_i-p|+1$。

$D'=\sum |a_i-p|+|b_i-p|+1$

最后那个 $1$ 显然可以直接处理掉，剩余部分就是一个初一弱智数学问题，直接取中位数所有 $a_i,b_i$ 就可以了。

接下来考虑 $k=2$ 的情况。假设我们在 $p,q$ 位置建了桥。

那么 $d_i$ 就是从这两座桥上通过所需的距离的较小值，即 $d_i=\min(|a_i-p|+|b_i-p|,|a_i-q|+|b_i-q|)+1$。

在 $k=1$ 的情况中，我们之所以能够把 $a_i,b_i$ 揉在一起取中位数，是因为它们的贡献互不影响。

但在这种情况下就不能直接取中位数了，因为有个 $\min$。

不妨设 $a_i \leq b_i$，设 $f(x)=|a_i-x|+|b_i-x|$。简单画个图像，由三部分组成，左边是斜率为 $-2$ 的射线，中间是一段水平线段，右边是斜率为 $2$ 的射线。图像的对称轴为 $x=\dfrac{a_i+b_i}{2}$（梦回课内）

由于对称轴左右两边完全一样并且对称轴左边 $y$ 随 $x$ 的增大单调不降，故有：

- 若 $|\dfrac{a_i+b_i}{2}-p|<|\dfrac{a_i+b_i}{2}-q|$，那么 $f(p)\leq f(q)$。

有了这个结论，本题就简单多了。

把所有工人按 $\dfrac{a_i+b_i}{2}$ 从小到大排序，那我们肯定是选择离 $\dfrac{a_i+b_i}{2}$ 较近的那座桥。

不妨设 $p<q$，那么所有 $\dfrac{a_i+b_i}{2}\leq\dfrac{p+q}{2}$ 的工人都会选择 $p$ 那座桥，剩余的工人会选择 $q$ 那座桥。

故选择 $p$ 的工人是原序列的一个前缀，选择 $q$ 的工人是原序列的一个后缀。

枚举断点 $i$，$[1,i]$ 的工人选择桥梁 $p$，$[i+1,n]$ 的工人选择桥梁 $q$。

断点两边是互相独立的。这时候我们又可以把绝对值拆开，于是我们又回到了第一问。

于是题目变为如何快速求出每个前缀的中位数，有 DS 味儿了，稍微一想就可以想到平衡树（

但稍微想一想就发现，其实根本不用平衡树。可以用两个堆来维护，建一个大根堆维护前一半的值，再建一个小根堆维护后一半的值。每次新插入一个值，就将它插入到对应的部分中，然后通过微调使两部分平衡。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define fz(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
#define ffe(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define fill0(a) memset(a,0,sizeof(a))
#define fill1(a) memset(a,-1,sizeof(a)
#define fillbig(a) memset(a,63,sizeof(a))
#define pb push_back
#define ppb pop_back
#define mp make_pair
typedef pair<int,int> pii;
typedef long long ll;
const int MAXN=1e5+5;
struct solver{
	multiset<int> st1,st2;
	ll sum1=0,sum2=0;
	void insert(int a){
		if(st1.empty()){
			st1.insert(a);sum1+=a;
		} else {
			int x=*st1.rbegin();
			if(a<=x) sum1+=a,st1.insert(a);
			else sum2+=a,st2.insert(a);
			int cnt=(st1.size()+st2.size()+1)/2;
			while(st1.size()>cnt){int v=*st1.rbegin();sum1-=v;sum2+=v;st1.erase(st1.find(v));st2.insert(v);}
			while(st1.size()<cnt){int v=*st2.begin();sum2-=v;sum1+=v;st2.erase(st2.find(v));st1.insert(v);}
		}
	}
	ll query(){
		if(st1.empty()) return 0;
		int cnt=(st1.size()+st2.size()+1)/2,x=*st1.rbegin();
		return 1ll*cnt*x-sum1+sum2-1ll*(st1.size()+st2.size()-cnt)*x;
	}
} x1,x2;
int n,k,m;
struct data{
	int a,b;
	friend bool operator <(data x,data y){
		return x.a+x.b<y.a+y.b;
	}
} f[MAXN];
ll sum=0;
ll pre[MAXN],suf[MAXN];
int main(){
	scanf("%d%d",&k,&n);
	for(int i=1;i<=n;i++){
		char x,y;int a,b;cin>>x>>a>>y>>b;
		if(x==y) sum+=abs(a-b);
		else f[++m].a=a,f[m].b=b,sum++;
	}
	if(k==1){
		for(int i=1;i<=m;i++) x1.insert(f[i].a),x1.insert(f[i].b);
		printf("%lld\n",x1.query()+sum);
	} else {
		sort(f+1,f+m+1);
		for(int i=1;i<=m;i++) x1.insert(f[i].a),x1.insert(f[i].b),pre[i]=x1.query();
		for(int i=m;i;i--) x2.insert(f[i].a),x2.insert(f[i].b),suf[i]=x2.query();
		ll mn=1e18;
		for(int i=1;i<=m+1;i++) mn=min(mn,pre[i-1]+suf[i]);
		printf("%lld\n",mn+sum);
	}
	return 0;
}
```

---

## 作者：chenxia25 (赞：0)

**[Portal]( https://www.luogu.com.cn/problem/P3644 )**

首先注意到家和办公室在河同侧的是方案唯一的（就直接走），先算到答案里面去。然后剩下来的都是被分在两岸的。

显然两岸哪个是家哪个是办公室不重要。我们设它们的位置为 $l\leq r$。于是如果通过的桥为 $a$，不难列出走的路程的式子 $|l-a|+|r-a|+1$（我当时就是没想到把式子列出来，进一步通过 $+$ 号拆成两个独立的元素，而想着以家、办公室的对为最小元素做，这显然是麻烦的），其中这个 $1$ 也可以预处理掉，剩下两个绝对值之和。

对 $m$ 分类：

1. $m=1$。这个其实简单至极，就算不列式也可以轻松做。不过我们已经把式子列出来了，那就照这个思路做吧。我们设这条唯一的桥为 $a$，那么答案就是 $\sum(|l_i-a|+|r_i-a|)$，不难发现 $\sum$ 后面的两项也是独立的（这是本题的关键），于是拆开，拆成 $2n$ 个  $|x-a|$ 的和。那么根据初一数学我们知道 $a$ 取 $x$ 的中位数的时候最优；

2. $m=2$。依然沿用上面的思路，只不过对于桥 $a<b$ 每个人可以有两种决策（目前为止还不能拆开，因为家和办公室的决策必须相同）。我们考虑对 $l,r$，$a$ 和 $b$ 哪个更优呢？分成四类（$l$ 与 $a$ 的关系、$r$ 与 $b$ 的关系）不难列出条件式：$l$ 更优当且仅当 $l-a\leq b-r$。移项得 $l+r\leq a+b$。这样子就是一个关于 $l_i+r_i$ 的不等式。于是又有了一个结论：按 $l+r$ 排序后，选左边桥的一定是个前缀，于是选右边桥的是后缀。于是我们考虑惯用套路：枚举这个断点。

   断点两边显然是独立的。对于每边，这时候可以将绝对值拆开了，归约到了 $m=1$ 的时候。于是现在问题就是如何快速求出每个前缀的中位数（又暴露了 APIO 的毒瘤 DS 本质）。显然要从左往右依次加入数。那么维护这个傻子都能想到平衡树，但是 hb 沥尽心血教我们如何不用平衡树、线段树等数据结构，我们也不能辜负他的期望。这个插入数、查 xth 显然离散化然后值域 BIT 倍增也可以。还有一种更简便的方法：维护左右两半的 `set`，每次插入后调整一下左右两边的相对单调性，然后微调一下两边的元素个数平衡即可，这个还是挺自然的。

**_[code]( https://www.luogu.com.cn/paste/jbvr4cv6 )_**

---

## 作者：Jμdge (赞：0)

FHQ 喜加一... % Venuses

虽说这题做法很多， 平衡树也不是最方便的（线段树或者两个堆就能过的东西），但是还是打了个平衡树
# noteskey

总的来说就是把同一边的点直接算贡献，然后两边的点就是观察一下发现算它们到桥的距离之和就行了，具体办公室和住所的位置其实都没什么特别的...

所以这两者都可以放到一条数轴上，我们的任务就成了在数轴上找到一个点，使得所有点到该点的距离之和最小...

**这不就是求中点嘛！sort 一遍的事情！**


对，第一小问可以这么水过去，但是第二问里 k=2 ，那么我们就需要枚举断点，算两个部分的中点，也就是说我们要维护一个动态的数轴中点


这可以用平衡树维护，每次 split 几下 merge 几下就好了（FHQ 打的还是挺舒服的，虽说晚上刷题感觉很困...）


然后其实也没什么要注意的地方，就是数轴上会有重合的点，这个可能要关注一下...






# code

```
//by Judge
#include<bits/stdc++.h>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define swap(x,y) (x)^=(y)^=(x)^=(y)
#define ll long long
using namespace std;
const int M=2e5+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline bool cmin(ll& a,ll b){return a>b?a=b,1:0;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} inline int cread(){ char c=getchar();
	while(!isalpha(c)) c=getchar(); return c!='B';
} int n,k,num; ll ans[M],Ans;
struct node{ int l,r,pos; }a[M];
inline bool cmp(node& a,node& b){return a.pos<b.pos;}
namespace FHQTreap{ arr rt,val,pos,siz; ll sum[M]; int root,tot,son[M][2];  //FHQ 基操 
	inline int Rand(){static int seed=131;return seed=int(seed*48271ll%(~0u>>1));}
	inline int newnode(int x=0){return ++tot,val[tot]=sum[tot]=x,siz[tot]=1,pos[tot]=Rand(),tot;}
	inline void pushup(int x){
		siz[x]=siz[son[x][0]]+siz[son[x][1]]+1,
		sum[x]=val[x]+sum[son[x][0]]+sum[son[x][1]];
	}
	int merge(int x,int y){ if(!x||!y) return x|y;
		if(pos[x]<pos[y]) return son[x][1]=merge(son[x][1],y),pushup(x),x;
		else return son[y][0]=merge(x,son[y][0]),pushup(y),y;
	}
	void split(int rt,ll k,int& x,int& y){ if(!rt) return x=y=0,void();
		if(val[rt]>k) split(son[y=rt][0],k,x,son[rt][0]);
		else split(son[x=rt][1],k,son[rt][1],y); pushup(rt);
	}
	inline int findk(int rt,int k){ // 循环版...求 k 大值 
		while(1) if(k<=siz[son[rt][0]]) rt=son[rt][0];
			else if(k==siz[son[rt][0]]+1) return val[rt];
			else k-=siz[son[rt][0]]+1,rt=son[rt][1];
	}
	inline void insert(ll val){ //插入一个点 
		int x,y; split(root,val,x,y);
		root=merge(x,merge(newnode(val),y));
	}
} using namespace FHQTreap;
inline ll query(ll val){ int x,y;
	ll Sum=siz[root]>>1,res=0;
	split(root,val-1,x,y); //把 val 点上的贡献单独算出来，加到前半个的贡献里 
	res=(sum[x]+val*(Sum-siz[x]))<<1;
	return root=merge(x,y),res;
}
inline ll calc(){
	ll va=findk(root,siz[root]>>1);
	return sum[root]-query(va); // 总前缀和长度减去前半分前缀和的两倍（手推可得） 
}
int main(){ k=read(),n=read();
	int p,q,s,t; fp(i,1,n){ p=cread(),s=read(),q=cread(),t=read();
		if(s>t) swap(s,t); if(p==q) Ans+=t-s; else a[++num]={s,t,s+t};
	} sort(a+1,a+1+num,cmp); //所有的点按重心排序，emmm 好像是重心乘了 2 ，但这不重要【雾 
	fp(i,1,num) insert(a[i].l),insert(a[i].r),ans[i]=calc(); //计算加入一对点之后的重心贡献 
	if(k==1) return !printf("%lld\n",ans[num]+Ans+num);  // Ans 固有贡献，num 过桥固有贡献 
	ll cnt=ans[num]; memset(son,0,(tot+2)<<3),root=tot=0;
	fd(i,num,1) insert(a[i].l),insert(a[i].r),cmin(cnt,ans[i-1]+calc()); //用之前处理出来的前缀信息优化第二步 
	return !printf("%lld\n",cnt+Ans+num);
}
```





---

## 作者：kkxhh (赞：0)

按照其他题解所说的，先按照中点排序，再枚举分割点就行了

简单的说一下为什么这样可以得出正确答案，当一共有两座桥时，一定会有$a$条路走左边的桥，另外$n-a$条路走右边的桥，显然在枚举分割点时我们可以取遍所有$a$

同时对于一个确定的$a$，显然排序后左边$a$个走左边其余走右边是最好的方案，因为交换任何两条路径都只可能使答案变劣

代码实现上我用的是一个裸的$treap$，毕竟需要支持的操作只有插入，查询中位数和统计答案，$treap$是完全可以做到的(而且常数还小)

代码如下

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

typedef long long ll;
typedef struct node{
    ll l,r,v,sum,siz,rnd,w;
}node;

typedef struct path{
    ll l,r,mid;
}path;

const ll seed=9102;
path p[100010];
node t[400010];
ll k,n,root,tot,ans[100010],siz,minans=1000000000000000000,preans;

inline ll read(){
    ll num=0,k=1; char c=getchar();
    while(c>'9' || c<'0') k=(c=='-')?0:k,c=getchar();
    while(c>='0' && c<='9') num=num*10+c-'0',c=getchar();
    return k?num:-num;
}

inline ll readside(){
    char c=getchar();
    while(c!='A' && c!='B') c=getchar();
    return c=='A';
}

void update(ll k) {t[k].sum=t[t[k].l].sum+t[t[k].r].sum+t[k].v*t[k].w; t[k].siz=t[t[k].l].siz+t[t[k].r].siz+t[k].w;}

void rturn(ll &k){
    ll x=t[k].l;
    t[k].l=t[x].r; t[x].r=k;
    update(k); update(x); k=x;
}

void lturn(ll &k){
    ll x=t[k].r;
    t[k].r=t[x].l; t[x].l=k;
    update(k); update(x); k=x;
}

void insert(ll &k,ll v){
    if(!k){
        k=++tot;
        t[k].v=t[k].sum=v; t[k].w=t[k].siz=1; t[k].rnd=rand();
        return;
    }
    t[k].siz++; t[k].sum+=v;
    if(t[k].v==v) t[k].w++;
    else if(v<t[k].v) {insert(t[k].l,v); if(t[t[k].l].rnd<t[k].rnd) rturn(k);}
    else {insert(t[k].r,v); if(t[t[k].r].rnd<t[k].rnd) lturn(k);}
}

ll calmid(){
    ll x=root,k=(t[root].siz+1)>>1;
    while(true){
        if(t[t[x].l].siz>=k) x=t[x].l;
        else if(k>t[t[x].l].siz+t[x].w) k-=t[t[x].l].siz+t[x].w,x=t[x].r;
        else return t[x].v;
    }
}

ll calsum(ll v){
    ll x=root,tmp=0;
    while(true){
        if(t[x].v<v) tmp+=v*(t[t[x].l].siz+t[x].w)-t[t[x].l].sum-t[x].v*t[x].w,x=t[x].r;
        else if(t[x].v>v) tmp+=t[t[x].r].sum+t[x].v*t[x].w-v*(t[t[x].r].siz+t[x].w),x=t[x].l;
        else {tmp+=v*t[t[x].l].siz-t[t[x].l].sum+t[t[x].r].sum-v*t[t[x].r].siz; break;}
    }
    return tmp;
}

bool cmp(path a,path b) {return a.mid<b.mid;}

int main(){
    srand(seed);
    k=read(); n=read();
    for(ll i=1;i<=n;i++){
        ll s1=readside(),p1=read(),s2=readside(),p2=read();
        if(p1>p2) swap(p1,p2);
        if(s1==s2) preans+=p2-p1;
        else preans++,p[++siz].mid=(p1+p2)>>1,p[siz].l=p1,p[siz].r=p2;
    }
    if(!siz) printf("%lld",preans);
    else{
        sort(p+1,p+1+siz,cmp);
        for(ll i=1;i<=siz;i++){
            insert(root,p[i].l); insert(root,p[i].r);
            ans[i]=calsum(calmid());
        }
        if(k==1) printf("%lld",ans[siz]+preans);
        else{
            root=0;
            for(ll i=siz;i>=1;i--){
                insert(root,p[i].l); insert(root,p[i].r);
                minans=min(minans,ans[i-1]+calsum(calmid()));
            }
            printf("%lld",minans+preans);
        }
    }
    return 0;
}

```

---


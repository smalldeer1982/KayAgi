# 燔祭

## 题目描述

计算满足如下条件的带标号有根树数量：

- 这棵树一共有 $n$ 个节点。
- 每个节点都有一个整数权值，且在区间 $[1,m]$ 内。
- 每个节点的权值都**不大于**其父节点的权值。

答案可能很大，只需输出答案对 $998244353$ 取模的值。

两棵树 $T_1$ 和 $T_2$ 不同当且仅当两棵树的节点数不同或者根节点不同或者存在一个编号 $i$ 使得 $T_1$ 和 $T_2$ 中 $i$ 号节点的父节点编号不同或者 $i$ 号节点的权值不同。

## 说明/提示

#### 样例解释

对于第一组样例，

![](https://cdn.luogu.com.cn/upload/image_hosting/9b2jvz82.png)

六棵树如上图所示，其中圈内的数字是节点编号，圈外的数字是节点权值。

---

#### 数据范围

**「本题采用捆绑测试」**

对于所有测试点，保证 $1 \leq n \leq 400$，$1 \leq m < 998244353$。

$\text{Subtask 1 (7 pts)}$ $n = 3,m=3 $。

$\text{Subtask 2 (11 pts)}$ $m=1$。

$\text{Subtask 3 (19 pts)}$ $n,m\leq 6$。

$\text{Subtask 4 (17 pts)}$ $n \leq 7$。

$\text{Subtask 5 (11 pts)}$ $n,m \leq 50$。

$\text{Subtask 6 (35 pts)}$ 无特殊限制。



## 样例 #1

### 输入

```
2 2```

### 输出

```
6```

## 样例 #2

### 输入

```
4 6```

### 输出

```
13524```

## 样例 #3

### 输入

```
9 34```

### 输出

```
857311624```

# 题解

## 作者：joke3579 (赞：6)

怎么所有题解都没突破 $\widetilde O(n^2)$ 的 bound 啊？本题解做法的复杂度为 $O(n\log^2 n \log m)$。

令 $F_k(x)$ 是根的权为 $k$ 的树的个数的 EGF，则枚举一列无序合法子树容易得到：

$$F_k(x)=x\exp\sum_{i=1}^kF_i(x)$$

也就是：

$$\begin{aligned}F_k(x)&=x\exp F_k(x)\exp\sum_{i=1}^{k-1}F_i(x)\\&=F_{k-1}(x)\exp F_k(x)\end{aligned}$$

即 $\dfrac{F_k}{\exp F_k}=F_{k-1}$。上式同时指出了 $F_1(x) = x \exp F_1(x)$，其为有标号有根树的生成函数，因此有 $[x^n/n!] F_1(x) = n^{n - 1}$。

令 $f(x) = xe^{-x}$，记 $f$ 复合自身 $k$ 次得到的函数为 $f^{\langle k\rangle}$，我们知道 $F_1(x) = f^{\langle m - 1 \rangle}(F_{m}(x))$，也就有 $F_{m}(x) = f^{\langle 1 - m \rangle}(F_1(x))$。下面只需要计算 $f^{\langle m - 1\rangle}(x)$，随后求复合逆再复合即可得到 $F_m(x)$。

答案为

$$\left[\frac{x^n}{n!}\right] \sum_{i = 1}^m F_i(x) = \left[\frac{x^n}{n!}\right]\ln\left(\frac{F_m(x)}{x}\right)$$

使用 [$O(n\log^2 n)$ 多项式复合(逆)技术](https://www.luogu.com.cn/article/7joh5isi)，计算 $f^{\langle m - 1\rangle}(x)$ 可以做到 $O(n\log^2 n \log m)$，剩余的部分均非复杂度瓶颈。

问题来了：计算 $f^{\langle m - 1\rangle}(x)$ 还能不能加速啊？

核心代码：

```cpp
signed main() {
    int n, k;
    cin >> n >> k;
	k --;
    poly f1(n + 2);
    rep(i,1,n + 1) f1[i] = 1ll * qp(i, i - 1) * gifc(i) % mod;
	
    poly ans(n + 2), tmp(n + 2); 
	ans[1] = 1;
	rep(i,1,n + 1) {
		tmp[i] = gifc(i - 1);
		if (!(i & 1)) tmp[i] = mod - tmp[i];
	}
	while (k) {
		if (k & 1) ans = ans.composite(tmp);
		tmp = tmp.composite(tmp);
		k >>= 1;
	}
	ans = ans.composite_inv();
	f1 = ans.composite(f1);
	f1 = (f1 << 1).ln();
	cout << 1ll * f1[n] * gfac(n) % mod << endl;
} 
```

---

## 作者：_QAQ (赞：6)

前置知识：拉格朗日插值

给一个不用 $\operatorname{prufer}$ 序列的做法。

首先求给定一棵树赋权的方法，以 $f_{i,j}$ 表示第 $i$ 个节点赋值为 $j$ 的方案，那么有
$$
f_{i,j}=\prod_{(i,x) \in E,x ≠fa_i}\sum_{i=1}^j f_{x,i}
$$

容易发现 $f_{i,j}$ 可以看做关于 $j$ 的至多 $n+1$ 次多项式，以 $F_i(j)$ 表示，所以只要求出根节点赋权 $[1,m+1]$ 的方案，再拉格朗日插值即可。

考虑如何计算 $n$ 个节点，根节点赋权为 $i,i \in [1,m+1]$ 的方法，考虑对于一个节点 $x$，若其有 $k$ 个孩子，其赋权方式以及树的结构均相同，那么显然方案中有系数 $\frac{1}{k!}$。

考虑在已知 $f_{i,x},x \in [1,j)$ 的情况下，枚举计算 $f_{i,j}$。

有
$$
f_{i,j}=[x^j] \prod_{c=1}^{j-1} e^{cx \times f_{i,c}}
$$

考虑暴力计算，复杂度为 $O(n^4 \log n)$，无法接受。

但发现该式中，$i$ 相同的情况下,$f_{i,j}$ 到 $f_{i,j+1}$ 的多项式中本质上只少了一个 $e^{xj \times f_{i,j}}$，其系数在 $[0,n]$ 中有意义项只有 $\frac{n}{j}$ 个，所以复杂度为
$$
n^2\sum_{i=1}^n \frac{n}{i}=n^3\ln n
$$

最后不要忘了乘上 $n!$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4e3+7,p=998244353; long long v;
int n,m,r[N],w[N],fac[N],f[N][N]; long long g[N];
inline long long pows(long long u,int v){
	long long ans=1; while(v>0) {if(v&1) ans=ans*u%p; u=u*u%p,v=v>>1;} return ans;
}
int main(){
	cin>>n>>m,f[1][1]=1,r[0]=1,fac[0]=1;
	for(int i=1;i<=n;i++) r[i]=r[i-1]*pows(i,p-2)%p,fac[i]=pows(r[i],p-2);
	for(int i=1;i<=n+3;i++){
		f[1][i]=i,g[0]=1;
		for(int x=1;x<=n;x++) g[x]=pows(i,x)*r[x]%p;
		for(int x=2;x<=n;x++){
			f[x][i]=g[x-1];
			if(f[x][i]+f[x][i-1]>=p) f[x][i]=f[x][i]+f[x][i-1]-p;
			else f[x][i]=f[x][i]+f[x][i-1];
			for(int c=1;c*x<=n;c++) w[c]=pows(f[x][i],c)*r[c]%p;
			for(int c=n;c>=x;c--)
				for(int t=1;t*x<=c;t++)
					g[c]=(g[c]+g[c-t*x]*w[t])%p;
		}
	}
	v=1; long long op=0;
	for(int i=1;i<=n;i++) v=1ll*v*i%p;
	if(m<=n+3) op=f[n][m];
	else{
		for(int i=1;i<=n+3;i++){
			long long val=f[n][i];
			for(int j=1;j<=n+3;j++){
				if(i==j) continue;
				val=val*(m-j)%p*pows(i-j,p-2)%p;
			}
			op=(op+val)%p;
		}
	}
	cout<<(op+p)*v%p<<endl;
	return 0;
}
```

---

## 作者：command_block (赞：3)

**题意** : 要求统计满足如下要求的带标号有根树。

- 有 $n$ 个节点。

- 点权为 $[1,m]$ 内整数,且满足堆的性质。

答案对 $998244353$ 取模。

$n\leq 400$ ,时限$\texttt{2s}$。

------------

~~看不懂题解然后自己胡编个做法过了，太感动了~~

方案数有一个显然的粗略上界 $(nm)^n$ ，这提示我们答案是关于 $m$ 的 $n$ 次多项式。

设 $F[i][j]$ 为 $i$ 个点的树根点权为 $j$ 的方案数，求出 $F[n][1...n+1]$ 后插值即可。

设 $F_k(x)=\sum\limits_{i=0}\dfrac{x^iF[i][k]}{i!}$ ，即 $\rm EGF$。

设 $G_k(x)=\sum\limits_{i=1}^kF_i(x)$。

考虑一个根权值为 $k$ 的树是怎么造出来的 ： 选若干根权值 $\leq k$ 的树，标号混合之后，连向根。

则有 $F_k(x)=x \exp G_k(x)$ ，即 $F_k(x)=x \exp (F_k(x)+G_{k-1}(x))$。

等价于 ： 给出 $G$ ，有 $F=x\exp (F+G)$ ，求 $F$。

$\Rightarrow F=x\exp G\exp F$

$\Rightarrow F[n]=\sum\limits_{i+j=n-1}(\exp G)[i](\exp F)[j]$

而众所周知可以在 $O(n^2)$ 内逐项由 $F[1...n]$ 递推得到 $(\exp F)[1...n]$。

边界 ： $F_1[n]=n^{n-1}$ ，即有标号有根树。

复杂度为 $O(n^3)$。理论可以做到 $O(n^2\log n)$。

```cpp
#include<cstdio>
#define ll long long
#define MaxN 410
using namespace std;
const int mod=998244353;
ll powM(ll a,int t=mod-2){
  ll ans=1;
  while(t){
    if (t&1)ans=ans*a%mod;
    a=a*a%mod;t>>=1;
  }return ans;
}
ll fac[MaxN],ifac[MaxN];
void Init(int n)
{
  fac[0]=1;
  for (int i=1;i<=n;i++)
    fac[i]=fac[i-1]*i%mod;
  ifac[n]=powM(fac[n]);
  for (int i=n;i;i--)
    ifac[i-1]=ifac[i]*i%mod;
}
ll pl[MaxN],pr[MaxN];
void calc(int m,ll x,ll *y)
{
  ll ans=0;
  pl[0]=pr[m+1]=1;
  for (int i=1;i<=m;i++)
    pl[i]=pl[i-1]*(x-i)%mod;
  for (int i=m;i;i--)
    pr[i]=pr[i+1]*(x-i)%mod;
  for (int i=1;i<=m;i++){
    ll buf=pl[i-1]*pr[i+1]%mod*ifac[i-1]%mod*ifac[m-i]%mod*y[i]%mod;
    if ((m-i)&1)ans-=buf;
    else ans+=buf;
  }printf("%lld",(ans%mod+mod)%mod);
}
void exp(ll *F,int n)
{
  static ll dF[MaxN];
  for (int i=1;i<=n;i++)dF[i-1]=i*F[i]%mod;
  F[0]=1;
  for (int k=1;k<=n;k++){
    F[k]=0;
    for (int i=0;i<k;i++)
      F[k]=(F[k]+dF[i]*F[k-i-1])%mod;
    F[k]=F[k]*ifac[k]%mod*fac[k-1]%mod;
  }
}
void trans(ll *F,ll *G,int n)
{
  static ll eF[MaxN],S[MaxN],dF[MaxN];
  for (int i=0;i<=n;i++)S[i]=G[i];
  exp(S,n);
  eF[0]=1;
  for (int k=1;k<=n;k++){
    F[k]=0;
    for (int i=0;i<k;i++)
      F[k]=(F[k]+eF[i]*S[k-i-1])%mod;
    dF[k-1]=F[k]*k%mod;
    eF[k]=0;
    for (int i=0;i<k;i++)
      eF[k]=(eF[k]+dF[i]*eF[k-i-1])%mod;
    eF[k]=eF[k]*ifac[k]%mod*fac[k-1]%mod;
  }
}
ll F[MaxN][MaxN],G[MaxN][MaxN],s[MaxN];
int n,m,D;
int main()
{
  scanf("%d%d",&n,&D);m=n+1;
  Init(n+5);
  for (int i=1;i<=n;i++)
    G[1][i]=F[1][i]=powM(i,i-1)*ifac[i]%mod;
  for (int k=2;k<=m;k++){
    trans(F[k],G[k-1],n);
    for (int i=0;i<=n;i++)
      G[k][i]=(G[k-1][i]+F[k][i])%mod;
  }for (int k=1;k<=m;k++)
    s[k]=G[k][n]*fac[n]%mod;
  calc(m,D,s);
  return 0;
}
```

---

## 作者：daniEl_lElE (赞：2)

考虑 $dp_{i,j}$，表示 $i$ 个点的所有子树中，有 $j$ 种不同权值的方案数。也就是说，我们只关心权值的相对大小，而不关心究竟最大权值是多少。

不难发现答案就是 $\sum_{j=1}^ndp_{n,j}\binom{m}{j}$。

考虑转移，记录一个 $f_{i,j}$ 表示一些子树大小总和为 $i$，$j$ 种不同权值的方案数。直接转移需要枚举两边子树大小，分别不同权值数和共用的权值数，是 $O(n^5)$ 的。

考虑优化，利用容斥的思想，重新定义 $f_{i,j}$ 表示一些子树大小总和为 $i$，所有权值在钦定的 $j$ 种不同权值内的方案数。此时我们可以直接将相同的 $j$ 的 $f_{i,j}$ 转移。同时维护一个 $g_{i,j}$ 表示 $i$ 个点的所有子树中，所有权值在钦定的 $j$ 种不同权值内的方案数。根据有标号的树计数的转移方式，每次在 $f_{i,j}$ 上拼上一个 $g_{i',j}$ 转移到 $f_{i+i',j}$。转移 $dp_{i,j}$ 时只需要将 $f_{i-1,j}$ 容斥一遍即可。总复杂度 $O(n^3)$。

理论上来讲 $f_{i,j}$，$g_{i,j}$ 的转移和每一位的容斥都可以利用半在线卷积做到 $O(n^2\log n)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
using namespace std;
const int mod=998244353;
int dp1[405][405],dp2[405][405],dp3[405][405],C[405][405];
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
		b>>=1;
	}
	return ans;
}
signed main(){
	for(int i=0;i<=400;i++) C[i][0]=1;
	for(int i=1;i<=400;i++) for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
	int n,m; cin>>n>>m;
	dp1[1][1]=1;
	for(int i=1;i<=n;i++) dp2[1][i]=i;
	for(int i=2;i<=n;i++){
		int tmp[405];
		tmp[0]=0;
		for(int j=1;j<=n;j++){
			tmp[j]=(dp2[i-1][j]+dp3[i-1][j])%mod;
		}
		for(int j=1;j<=n;j++){
			for(int k=j-1;k>=1;k--){
				(tmp[j]+=tmp[k]*C[j][k]%mod*(mod-1))%=mod;
			}
		}
		for(int j=1;j<=n;j++){
			(dp1[i][j]+=(tmp[j]+tmp[j-1])*i)%=mod;
		}
		for(int j=1;j<=n;j++){
			for(int k=j;k<=n;k++){
				(dp2[i][k]+=dp1[i][j]*C[k][j])%=mod;
			}
		}
		for(int j=1;j<=n;j++){
			for(int k=1;k<i;k++){
				(dp3[i][j]+=(dp2[k][j]+dp3[k][j])*dp2[i-k][j]%mod*C[i-1][k])%=mod;
			}
		}
	}
	int ans=0,tot=1;
	for(int i=1;i<=n;i++){
		(tot*=(m-i+1))%=mod;
		(tot*=qp(i,mod-2))%=mod;
		(ans+=dp1[n][i]*tot)%=mod;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：kkio (赞：0)

cmd 说的理论 $n^2\log n$ 做法......?

我们观察到答案为关于 $m$ 的 $n$ 次多项式后，就可以直接写出 EGF 了，大概是：

$$
F_i(x)=x\exp(G_{i-1}(x)+F_i(x))
$$
$$
G_i(x)=G_{i-1}(x)+F_i(x)
$$

$i$ 表示根的权值，$\exp$ 相当于枚举有多少个子树，这里不多加赘述。其中 $G_{i-1}$ 已知，我们可以得到两个方程组 $S_0(F_i,G_i)=0,S_1(F_i,G_i)=0$。套用二元牛顿迭代法，我们可以 $n\log n$ 解决。

二元牛顿迭代大概就是长这样的：
$$
H = \begin{bmatrix} \frac{\partial S_0}{\partial F} & \frac{\partial S_0}{\partial G} \\ \frac{\partial S_1}{\partial F} & \frac{\partial S_1}{\partial G} \end{bmatrix}
$$
$$
\begin{bmatrix} F' \\ G' \end{bmatrix} = \begin{bmatrix} F \\ G \end{bmatrix} - H^{-1}\begin{bmatrix} S_0(F,G) \\ S_1(F,G) \end{bmatrix}
$$

$F',G'$ 是模 $x^{2n}$ 意义下答案，$F,G$ 是模 $x^n$ 意义下答案，递归即可。可以用二元泰勒展开简单证明。

我们一共要做 $n$ 次，所以复杂度是 $n^2 \log n$。

最后拉格朗日插值，$n^2$ 的。

当然想想牛顿迭代的常数估计还没 $n^3$ 跑的快。

```cpp
using Poly=Math::ZPoly::Polynomial;
const int mod=998244353;
int ksm(int b,int p){int ret=1;while(p){if(p&1)ret=1ll*ret*b%mod;b=1ll*b*b%mod;p>>=1;}return ret;}
const int maxn=405;
int n,m;
int f[maxn][maxn],g[maxn][maxn],ansv[maxn],eg[maxn][maxn],dg[maxn][maxn],ef[maxn][maxn],df[maxn][maxn];
int tnum[maxn],fac[maxn],ifac[maxn],inv[maxn];
int ansp[maxn],Fp[maxn];
inline int ID(int x){return x&1?mod-1:1;}
Poly H;
inline void print(Poly x)
{
    for(int i=0;i<x.size();i++)cout<<x[i]<<' ';
    cout<<'\n';
}
pair<Poly,Poly> newton(int n)
{
    if(n==1)return {Poly({0}),Poly({0})};
    int mid=(n+1)/2;
    Poly F,G;tie(F,G)=newton(mid);
    F.resize(n),G.resize(n);
    Poly p00=Poly({1}),p01=Poly({0,mod-1})*exp(G),p10=Poly({mod-1}),p11=Poly({1});
    p00.resize(n);p01.resize(n);p10.resize(n);p11.resize(n);
    Poly detp=(p00*p11-p01*p10).inv();detp.resize(n);
    Poly nowH=H;nowH.resize(n);
    Poly S0=F-Poly({0,1})*exp(G),S1=G-F-nowH;
    S0.resize(n);S1.resize(n);
    Poly nF=F-detp*(p11*S0-p01*S1),nG=G-detp*(p00*S1-p10*S0);
    nF.resize(n),nG.resize(n);
    return {nF,nG};
}
int main()
{
    cin>>n>>m;
    tnum[0]=0;tnum[1]=1;
    for(int i=2;i<=n;i++)tnum[i]=ksm(i,i-1);
    fac[0]=ifac[0]=inv[1]=1;
    for(int i=2;i<=n;i++)inv[i]=1ll*inv[mod%i]*(mod-mod/i)%mod;
    for(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod,ifac[i]=1ll*ifac[i-1]*inv[i]%mod;
    Poly F,G;F.resize(n+1),G.resize(n+1);
    for(int i=1;i<=n;i++)F[i]=G[i]=1ll*tnum[i]*ifac[i]%mod;ansv[1]=tnum[n];
    for(int d=2;d<=n;d++)
    {
        H=G;Poly nF,nG;
        tie(nF,nG)=newton(n+1);
        ansv[d]=1ll*nG[n]*fac[n]%mod;
        F=nF,G=nG;
    }
    Fp[0]=1;
    for(int i=0;i<=n;i++)
        for(int j=n+1;j>=0;j--)
        {
            if(j)Fp[j]=(Fp[j-1]-1ll*Fp[j]*i%mod+mod)%mod;
            else Fp[j]=(mod-1ll*Fp[j]*i%mod+mod)%mod;
        }
    
    for(int i=0;i<=n;i++)
    {
        int coef=1ll*ifac[i]*ifac[n-i]%mod*ID(n-i)%mod;
        if(!i)
        {
            for(int j=1;j<=n+1;j++)
                Fp[j-1]=Fp[j];
            Fp[n+1]=0;  
            for(int j=0;j<=n;j++)
                ansp[j]=(ansp[j]+1ll*coef*Fp[j]%mod*ansv[i]%mod)%mod;
            for(int j=n+1;j>=1;j--)
                Fp[j]=Fp[j-1];
            Fp[0]=0;
        }
        else 
        {
            for(int j=0;j<=n+1;j++)
            {
                if(!j)Fp[j]=1ll*Fp[j]*inv[i]%mod*(mod-1)%mod;
                else Fp[j]=1ll*(Fp[j]-Fp[j-1]+mod)%mod*inv[i]%mod*(mod-1)%mod;
            }
            for(int j=0;j<=n;j++)
                ansp[j]=(ansp[j]+1ll*coef*Fp[j]%mod*ansv[i]%mod)%mod;
            for(int j=n+1;j>=0;j--)
            {
                if(j)Fp[j]=(Fp[j-1]-1ll*Fp[j]*i%mod+mod)%mod;
                else Fp[j]=(mod-1ll*Fp[j]*i%mod+mod)%mod;
            }   
        }
    }
    int Ans=0;
    for(int i=0;i<=n;i++)
        Ans=(Ans+1ll*ansp[i]*ksm(m,i)%mod)%mod;
    cout<<Ans<<'\n';
}
```

---


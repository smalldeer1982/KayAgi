# 「HGOI-1」Mole

## 题目背景

$\text{brealid}$ 觉得普通的打地鼠游戏太过于 $\text{simple}$ 了。所以，她设计了一款全新的打地鼠游戏。

## 题目描述

在长度为 $l$ 的游戏窗口上，有一个长为 $t$ 的地鼠序列 $(l \le t)$，初始序列左端与窗口左端对齐，接下来序列每秒移动一个单位长度，（即最左端的地鼠离开窗口，最右端的地鼠进入窗口），向左滚动直至玩家结束游戏或者序列最右端与窗口最右端重合（即任何时刻窗口内均应有 $l$ 只地鼠）。

游戏开始的第一秒序列不会移动，不难发现游戏最多会进行 $(t-l+1)$ 秒。

序列 $T$ 中的每一只地鼠都有自己的高度 $h_i$，玩家每次可以选择击打一只地鼠，玩家可以获得与地鼠高度 $h_i$ 数值相同的金币奖励，同时地鼠 $i$ 的高度 $h_i$ 会减一。

经过调研，$\text{brealid}$ 控制了游戏运行速度，使得玩家在地鼠序列移动一个单位长度的同时**最多只能打击一次**（也可以不打）。

现在 $\text{brealid}$ 告诉了你某一次游戏的窗口长度 $l$、序列长度 $t$ 以及某一局游戏中生成的地鼠高度序列 $T$。我们可爱的 $\text{brealid}$ 想要知道，她在**任意时刻**结束游戏所能得到的**最多金币**，即在第 $1,2,\cdots (t-l+1)$ 秒时停止游戏分别可以获得的最多金币。

## 说明/提示

#### 样例解释

第一秒：锤 $2$，答案加 $3$。

第二秒：锤 $2$，答案加 $2$。

第三秒：随便锤一个，答案加 $1$。

第四秒：再随便锤一个（非 $0$ 的），答案加 $1$。

第五秒：锤 $9$，答案加 $5$。

第六秒：锤 $9$，答案加 $4$。

#### 数据范围

本题采用**捆绑测试**，共有 $4$ 个 $\text{subtask}$，最终分数为所有 $\text{subtask}$ 分数之和。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Task} & \textbf{Score} & l\le t\le  \cr\hline
1 & 10 & 10 \cr\hline
2 & 20 & 500 \cr\hline
3 & 30 & 5000 \cr\hline
4 & 40 & 10^6 \cr\hline
\end{array}
$$

对于 $100\%$ 的数据，$1\le l\le t\le 10^6$，$|h_i|\le 10^9$。


## 样例 #1

### 输入

```
5 10
1 3 1 1 1 1 1 1 5 1```

### 输出

```
3 5 6 7 12 16```

# 题解

## 作者：鏡音リン (赞：11)

考虑 dp。

我们记 $D[x][y]$ 表示，前 $x$ 个数共选了 $y$ 次的答案。

根据题意，状态有意义的范围为 $x-l+1\le y\le x$。

转移就是枚举第 $x$ 个数选了 $k$ 次，那么

$\displaystyle D[x][y] = \max\{D[x-1][y-k] + k a[x] - \frac12k(k-1)\}$

直接枚举 $k$ 转移当然是 $n^3$。

有同学这里会说，我会斜率优化啊，$n^2$ 啊。

斜率优化没错……但是你学傻了……

这玩意可以看作 $D[x]$ 是 $D[x-1]$ 和一个二次函数的加max卷积，两边都是凸函数，所以这个卷积叫做闵可夫斯基和。

没听过的话我直接放结论，两个数组做闵可夫斯基和，答案的差分数组是它俩的差分数组的归并。

（至于为啥 $D$ 是凸的，你归纳法假设 $D[x-1]$ 是凸的，那么卷积的结果 $D[x]$ 当然还是凸的）

于是直接用这玩意转移复杂度 $n^2$。

实现的时候发现，既然是差分归并，那直接维护 $D$ 的差分不就好了。定义 $dp[x][y] = D[x][y+1] - D[x][y]$，然后不停地归并 $\{a[x],a[x]-1,a[x]-2,\dots\}$ 这样的数组就好了。

当 $x$ 逐渐增大的时候，较小的 $y$ 值会变得不合法，直接把最左边的 $dp$ 值删掉计入答案就行。

放个 $60$ 分核心代码（去掉了头文件和快读）：

```cpp
#define N 5001
int dp[2][N], cnt, l, n; long long ans;
int main() {
	rint(l); rint(n);
	for (int i = 0, x; i < n; i++) {
		rint(x);
		int L = std::max(i-l+1, 0);
		for (int j = L, p = L; j <= i && j <= n-l+1; j++)
			dp[cnt][j] = dp[!cnt][p] > x ? dp[!cnt][p++] : x--;
		if (i >= l-1) printf("%lld ", ans += dp[cnt][L]);
		cnt = !cnt;
	}
}
```

考虑优化，想想我们对 $dp$ 数组干了啥。我们记 $dp$ 组成的多重集合是 $S$。由于这玩意必定是有序的，所以维护集合和数组没区别。

每一步相当于：

1. 把 $a[x],a[x]-1,\dots,1$ 的所有值加入 $S$
2. 保留 $S$ 中最大的 $l$ 个数字，其它的删掉
3. 如果此时窗口已经开始滑动了，把 $S$ 中最大的再删掉并计入答案

那么记 $b[x]$ 为 $x$ 在 $S$ 内的出现次数。上述三个操作对 $b$ 的影响是：

1. 前缀所有位置 $+1$
2. 二分一个前缀和，然后前缀清零（可能有一次单点修改）
3. 找到最大值位置并 $-1$

这些操作都是线段树可以维护的。复杂度 $n\log n$。代码就不放了。

---

## 作者：bh1234666 (赞：11)

## solution Mole


### subtask1
纯暴力

$10\space pts$
### subtask2
考虑 $dp$， $dp_{i,j,k}$ 表示在第 $i$ 位置，前面的 $j$ 个数取了 $k$ 次的答案。
$\Theta(n^3)$

$30\space pts$。
### subtask3

假设只要求求整个序列的答案。

考虑全局贪心。

假设我们知道了某种方案某个数取了多少次，且在这个次数下答案最优。显然我们插入合法的最大的可插入的数就可以得到 $\text{次数}+1$的情况下最优的答案。

考虑 $\Theta(n)$ 检验某个方案是否可行。

设 $C_i$ 表示 $a_i$ 被选的次数，那么对于每一个区间 $[i,i+L-1]$，显然贪心地取最前面 $C_i$ 尚不为零的 $i$。

因为先砍后面的前面的可能就砍不到了。

使用堆维护序列中最大的(可能)可以插入的最大的数，取出堆顶尝试插入（检验加入后的方案是否可行），若插入失败则显然不可能再次插入，插入成功则将其减一重新入堆（若价值为 $0$ 显然无需再次入堆）。

显然最多取 $(t-l+1)$ 个数。

考虑维护出全部的答案。

假设已知了前 $L$ 段序列的结果（以及维护结束以后的堆），末尾加入的元素显然最多被再取一次，那么更改长度后之前的方案依旧可行且可以通过一次成功的插入操作得到当前的最优方案或者直到堆清空都没有发生插入则之前的方案就是当前的最优方案。

维护一个记录当前（可能）可行的数的堆及当前长度最优的方案，每次长度加一尝试进行一次插入即可。

$\Theta(n^2)$，$60\space pts$

### full task

考虑优化检验到 $\Theta(logn)$

考虑基于前一次推。
对于每一轮检验，设 $f_n$ 为窗口右端到序列右端取的总次数（后缀和），$t_n$ 为窗口右端到 $n$ 至窗口离开序列的时间。

对于一种可行方案，当且仅当 $\forall i,f_n\le t_n$

充分性证明： 
假设 $f_n>t_n$  
则在窗口离开之后 $a_i(n-L \le i \le n)$ 中必定有数没取，不合法。

必要性证明：
$\forall f_n$，  
当其不大于 $t_n$ 并且方案不合法的时候，必定存在$f_x(x<n)>f_n$。

考虑 $f$ 的性质，  
当 $f_n=0$ 时，直接在 $n$ 处扩展一位，即 $f_n=1$
（不存在要取的数时**直接取走**）  
否则，$f_n←f_n+1$，并在下一个位置插入一次取数（相当于**顺延直到找到0**）

使用线段树维护区间加，并查集~~或线段树二分~~维护某位置后面第一个零。

假设插入一个数之后 $f_n>t_n$ 则无法插入，不合法。

维护存在性，设 $d_n=t_n-f_n$。

线段树初始化为 $t$，更新时区间减一，维护区间最小值，判断是否为负数。

考虑任意时间，对当前情况下的时间加一，将最后一位新加入的加进堆，  
将 $t$ 的末 $L$ 位加一（末 $L$ 位可以**向新的位置移动**），在线段树中可以 $\Theta(logn)$。

由于每次加一处理完后都无法再次插入任何数，因此并查集维护的最后一个零其实就位于当前段末尾。

使用线段树和堆维护即可。

正常维护加一次取数即可，(**时间轴上的每次移动最多取数一次**)

和上面 `subtask3` 同理，**中途被毙掉的数以后也不会选。**

$\Theta(nlogn)$，$100\space pts$

核心代码:

```
int n;
struct cmp{
	__attribute__((always_inline)) bool operator () (pair<int,int> a,pair<int,int> b)
	{
		return a.second<b.second;
	}
};
priority_queue<pair<int,int>,vector<pair<int,int> >,cmp> q;
int tree[10000005];
int tag[10000005];
void update(int now)
{
	tree[now]+=tag[now];
	tag[(now<<1)]+=tag[now];
	tag[(now<<1)+1]+=tag[now];
	tag[now]=0;
}
bool getmin(int x,int y,int now=1,int f=1,int l=n)//区间是否存在0 
{
	if(f>=x&&l<=y) return tree[now]+tag[now];
	update(now);
	bool fl=1;
	if(((f+l)>>1)+1<=y) fl=getmin(x,y,(now<<1)+1,((f+l)>>1)+1,l);
	if(!fl) return 0;
	if(((f+l)>>1)>=x) fl=getmin(x,y,(now<<1),f,((f+l)>>1));
	return fl;
}
void pls(int num,int x,int y,int now=1,int f=1,int l=n)//区间加 
{
	if(f>=x&&l<=y)
	{
		tag[now]+=num;
		return ;
	}
	update(now);
	if(((f+l)>>1)+1<=y) pls(num,x,y,(now<<1)+1,((f+l)>>1)+1,l);
	if(((f+l)>>1)>=x) pls(num,x,y,(now<<1),f,((f+l)>>1));
	tree[now]=min(tree[(now<<1)]+tag[(now<<1)],tree[(now<<1)+1]+tag[(now<<1)+1]);
}
int main()
{
	input();
	int i;int l;int rd;
	long long ans=0;
	long long pr=0;
	pair<int,int> fl;
	l=read(),n=read();
	for(i=1;i<l;i++)
	{
		rd=read();
		if(rd>0) q.push(pair<int,int>{i,rd});
	}
	for(i=l;i<=n;i++)
	{
		rd=read();
		if(rd>0) q.push(pair<int,int>{i,rd});
		pls(1,i-l+1,i);
		while(!q.empty())
		{
			fl=q.top();
			if(getmin(fl.first,i))
			{
				pls(-1,fl.first,i);
				if(fl.second>0) ans+=fl.second,fl.second--,q.push(fl);;
				q.pop();
				break;
			}
			q.pop();
		}
		write(ans),putchar(' ');
	}
	output();
	return 0;
}

```



---


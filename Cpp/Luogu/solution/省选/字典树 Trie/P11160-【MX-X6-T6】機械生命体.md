# 【MX-X6-T6】機械生命体

## 题目背景

原题链接：<https://oier.team/problems/X6G>。

---

> _許してよ、もう$\\$
分かってよ$\\$
此処の正体を$\\$
僕ですら僕を$\\$
愛せないんだって$\\$
感情を持った代償をくれよ$\\$
狂っている_
>
> _—— [機械生命体 - Nanatsukaze](https://music.163.com/#/song?id=2627128854)_

二进制的运算和记忆，能够在机械生命体中还原出人类的情感吗？

## 题目描述

维护一个**可重集** $S$，初始为空。支持如下操作：

- `1 x`，你需要在 $S$ 中加入一个数 $x$。
- `2 x`，你需要在 $S$ 中删除一个数 $x$。保证此时 $S$ 中存在至少一个 $x$。如果存在多个 $x$，则仅删除一个。
- `3 x k v`，你需要对 $S$ 中所有满足 $\operatorname{lowbit}(x\oplus y)\geq 2^k$ 的 $y$ 增加 $v$ 并对 $2^{32}$ 取模。
- `4 x`，你需要求出 $\max\limits_{y\in S} \operatorname{lowbit}(x\oplus y)$。保证此时 $S$ 不为空。

其中 $\operatorname{lowbit}(x)$ 表示最大的整数 $k$，使得 $k$ 是 $2$ 的整数次幂并且整除 $x$。$\oplus$ 代表[按位异或](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677)。

**特殊的，我们在本题定义 $\boldsymbol{\textbf{lowbit}(0)=2^{32}}$。**

## 说明/提示

**【样例解释】**

第 $6$ 次操作时，集合为 $\{1,2,2,3,4\}$，查询 $10$ 时，$\operatorname{lowbit}(10\oplus 2)=\operatorname{lowbit}(8)=8$ 为最大值。

第 $7$ 次操作后，所有 $\operatorname{lowbit}(x\oplus 2)\geq 2^1$ 的数增加 $2$，集合中满足条件的数有 $2,2,4$，于是集合变为 $\{1,3,4,4,6\}$。

第 $8$ 次操作删去一个 $4$，集合变为 $\{1,3,4,6\}$。

第 $9$ 次操作查询 $16$，$\operatorname{lowbit}(16\oplus 4)=\operatorname{lowbit}(20)=4$ 为最大值。

第 $10$ 次操作再次删去一个 $4$，集合变为 $\{1,3,6\}$。

第 $11$ 次操作查询 $16$，$\operatorname{lowbit}(16\oplus 6)=\operatorname{lowbit}(22)=2$ 为最大值。

**【数据范围】**

对于所有数据，$1\leq q\leq 5\times 10^5$，$0\leq x,y,v\leq 2^{32}-1$，$0\leq k\leq 32$。

**捆绑测试**，共 5 个 Subtask，具体限制如下所示：

- Subtask 1（7 pts）：$q\leq 10^3$。
- Subtask 2（16 pts）：不存在 3 操作。
- Subtask 3（21 pts）：对于 3 操作，$k=0$。
- Subtask 4（28 pts）：对于 3 操作，$v=1$。
- Subtask 5（28 pts）：无特殊限制。

## 样例 #1

### 输入

```
11
1 1
1 2
1 2
1 3
1 4
4 10
3 2 1 2
2 4
4 16
2 4
4 16```

### 输出

```
8
4
2```

# 题解

## 作者：cyffff (赞：10)

[$\text{Link}$](https://www.luogu.com.cn/problem/P11160)

Trie 树本质即为权值线段树。

本题解将会较为详细地讲述实现。
## 题意
维护一个可重集 $S$，初始为空。共有 $q$ 次如下类型的操作：

- `1 x`，向 $S$ 中加入一个 $x$。
- `2 x`，从 $S$ 中删除一个 $x$。
- `3 x k v`，对 $S$ 中所有满足 $\operatorname{lowbit}(x\oplus y)\geq 2^k$ 的 $y$，将其替换为 $(y+v)\bmod 2^{32}$。
- `4 x`，求出 $\max\limits_{y\in S} \operatorname{lowbit}(x\oplus y)$。

$q\le 5\times 10^5$。
## 题解
想必各位对 Trie 树维护全局加一的做法都已经倒背如流了：从低位向高位建 Trie 树，将根的右链上所有结点的左右儿子交换。

本题的操作三相当于取出 Trie 树上的某个子树，对其进行加 $v$。同时此时的操作四所求的信息相当简单，允许我们由低位至高位求解。那么我们要从全局加一的做法类比一个全局加 $v$ 的做法出来。

对一个子树进行操作几乎已经明示了我们需要打标记处理该问题。我们对一个结点 $i$ 打上标记 $t_i$ 表示对将 $i$ 为根的子树看作独立的一颗 Trie 树，还需对全局加上 $t_i$。那么标记下传时只需如下操作：
- 如果 $t_i$ 为奇数，对 $i$ 子树做一次全局加一并将 $t_i$ 减去一；
- 将左右儿子的标记分别加上 $\dfrac{t_i}{2}$ 并清空 $t_i$。

由于每次下传都可能会做一次全局加一，单次操作时间复杂度为 $O(\log^2 v)$。但是注意到我们并不需要立即将此次全局加一进行完，只需将右儿子的标记加一再交换左右儿子即可避免，时间复杂度降为 $O(\log v)$。

接下来，考虑将全局加拓展到子树加。考虑一次操作三 $x,k,v$，不妨令 $x$ 仅保留后 $k$ 位。我们直接做完后 $k$ 位的加法，将剩余的部分标记给修改子树，再将修改子树与做完加法所得目标子树合并起来。其中合并即为线段树合并，复杂度均摊正确。

总时间复杂度 $O(q\log v)$，参考实现：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ui unsigned int
namespace IO{//by cyffff
    
}
const int N=5e5+10,B=32;
int rt;
struct Trie{
	#define ls son[rt][0]
	#define rs son[rt][1]
	int cnt,son[N*B][2],siz[N*B];
	ui tag[N*B];
	inline void pushup(int rt){
		siz[rt]=siz[ls]+siz[rs];
	}
	inline void pushtag(int rt,ui v){
		if(!rt) return ;
		tag[rt]+=v;
	}
	inline void pushdown(int rt){
		if(!tag[rt]) return ;
		if(tag[rt]&1) pushtag(rs,1),swap(ls,rs),tag[rt]--;
		pushtag(ls,tag[rt]>>1);
		pushtag(rs,tag[rt]>>1);
		tag[rt]=0;
	}
	inline void insert(int &rt,int d,ui x,int v){
		if(!rt) rt=++cnt;
		siz[rt]+=v;
		if(d==B) return ;
		pushdown(rt);
		int c=x>>d&1;
		insert(son[rt][c],d+1,x,v);
	}
	inline int merge(int x,int y,int d){
		if(!x||!y) return x+y;
		if(d==B){
			siz[x]+=siz[y];
			return x;
		}
		pushdown(x),pushdown(y);
		son[x][0]=merge(son[x][0],son[y][0],d+1);
		son[x][1]=merge(son[x][1],son[y][1],d+1);
		pushup(x);
		return x;
	}
	inline void solve(int &pr,int &nx,int d,ui x,ui v,int k){
		if(!pr) return ;
		if(!nx) nx=++cnt;
		if(d==k){
			int A=pr;
			pushtag(A,(x+v)>>k);
			pr=0,nx=merge(nx,A,k);
			return ;
		}
		pushdown(pr),pushdown(nx);
		int cp=x>>d&1,cn=x+v>>d&1;
		solve(son[pr][cp],son[nx][cn],d+1,x,v,k);
		pushup(pr),pushup(nx); 
	}
	inline int query(int rt,int d,ui x){
		if(d==B) return d;
		pushdown(rt);
		int c=x>>d&1;
		if(siz[son[rt][c]]) return query(son[rt][c],d+1,x);
		return d;
	}
}T;
int main(){
	int q=read();
	while(q--){
		int op=read();
		ui x=read();
		if(op==1){
			T.insert(rt,0,x,1);
		}else if(op==2){
			T.insert(rt,0,x,-1);
		}else if(op==3){
			int k=read();
			ui v=read();
			T.solve(rt,rt,0,x&((1ll<<k)-1),v,k); 
		}else{
			write(1ll<<T.query(rt,0,x)),putc('\n');
		}
	}
	flush();
}
```

---

## 作者：Purslane (赞：3)

# Solution

没有思维含量的奶龙题。

显然，需要从低往高位维护 Trie 树。那么我们要实现以下几个操作：

1. 在 Trie 树中插入、删除一个数，以及在 Trie 树上匹配。（这是 Trie 树的基本功能）
2. 将 Trie 树某个子树内所有元素都加上 $v$。（因为对于操作 3，符合条件的数必定是 Trie 树上的一段区间）

考虑操作 2 如何实现。实际上，这种变换会被拆成两部分：

1. 整棵子树的平移。注意到子树内所有元素的**一定长度的后缀**全部相同，那么加上 $v$ 之后后缀还是相同，因此相当于将整棵子树平移过去。注意到原位置可能已经有元素了，所以要 Trie 树合并，不过不是重点。
2. 子树内部元素顺序调整。这里就可以直接记录为子树内所有元素加 tag，打上懒标记，及时 push_down 即可。

时空复杂度 $O(q \log V)$

```cpp
#include<bits/stdc++.h>
#define ui unsigned int
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=5e5+10,MAXM=1.5e7+10;
int n,tot=1,s[MAXM][2],sze[MAXM],fa[MAXM];
ui tag[MAXM];
void push_down(int u) {
	tag[s[u][0]]+=(tag[u]>>1),tag[s[u][1]]+=((tag[u]+1)>>1);
	if(tag[u]&1) swap(s[u][0],s[u][1]); 
	return tag[u]=0,void();
}
void change_sze(int u,int dt) {
	while(u) sze[u]+=dt,u=fa[u];
	return ;	
}
void insert(ui v,int op) {
	int rt=1;
	sze[rt]+=op;
	ffor(i,0,31) {
		push_down(rt);
		int id=!!(v&(1ll<<i));
		if(!s[rt][id]) s[rt][id]=++tot,fa[tot]=rt;
		rt=s[rt][id],sze[rt]+=op;
	}
	return ;
}
int find_nd(ui v,int dep) {
	int rt=1;
	ffor(i,0,dep-1) {
		push_down(rt);
		int id=!!(v&(1ll<<i));
		if(!s[rt][id]) s[rt][id]=++tot,fa[tot]=rt;
		rt=s[rt][id];
	}
	return rt;
}
int merge(int u,int v) {
	if(!u||!v) return u|v;
	push_down(u),push_down(v),sze[u]+=sze[v];
	s[u][0]=merge(s[u][0],s[v][0]),s[u][1]=merge(s[u][1],s[v][1]);
	fa[s[u][0]]=fa[s[u][1]]=u;
	return u;
}
void PUSH_DOWN(int u) {
	if(fa[u]) PUSH_DOWN(fa[u]);
	push_down(u);
	return ; 
}
void change_father(int u,int v) {
	PUSH_DOWN(u),PUSH_DOWN(v);
	change_sze(fa[u],-sze[u]),change_sze(fa[v],sze[u]);
	if(u==s[fa[u]][0]) s[fa[u]][0]=0;
	else s[fa[u]][1]=0;
	int F=fa[v],op=(s[F][1]==v);
	s[F][op]=merge(u,v),fa[s[F][op]]=F;
	return ;
}
int search(ui x,int dep) {
	int rt=1;
	ffor(i,0,dep-1) {
		push_down(rt);
		int id=!!(x&(1ll<<i));
		if(!s[rt][id]) return 0;
		rt=s[rt][id];
	}
	return 1;
}
void update(int k,ui x,ui v) {
	if(!v) return ;
	if(!k) return tag[1]+=v,void();
	if(!search(x,k)) return ;
	ui nd=x&((1ll<<k)-1);
	int id=find_nd(x,k),nid=find_nd(x+v,k);
	tag[id]+=(nd+v)>>k;
	if(id==nid) return ;
	change_father(id,nid);
	return ;
}
int get_ans(ui x) {
	int rt=1;
	ffor(i,0,32) {
		push_down(rt);
		int id=!!(x&(1ll<<i));
		if(!s[rt][id]||!sze[s[rt][id]]) return i;
		rt=s[rt][id];
	}
	return 32;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n;
	ffor(i,1,n) {
		int op;
		cin>>op;
		if(op==1) {
			ui x;
			cin>>x,insert(x,1);	
		}
		if(op==2) {
			ui x;
			cin>>x,insert(x,-1);	
		}
		if(op==3) {
			ui x,v;
			int	k;
			cin>>x>>k>>v;
			update(k,x,v);
		}
		if(op==4) {
			ui x;
			cin>>x;
			cout<<(1ll<<get_ans(x))<<'\n';	
		}
	}
	return 0;
}
```

---

## 作者：w9095 (赞：2)

[P11160 【MX-X6-T6】機械生命体](https://www.luogu.com.cn/problem/P11160)

注意到 $\text{lowbit}$ 是从最低位开始的，所以我们把数字按照二进制位从低位往高位插进字典树。

插入和删除操作是平凡的。查最大 $\text{lowbit}$ 只需要从根节点开始走，能走使这一位异或为 $0$ 的边就走这一条边，否则直接返回，因为不可能有更大的 $\text{lowbit}$ 值。

接下来考虑处理操作 $3$。满足要求的数字部分是容易提取的，在字典树上走使这一位异或为 $0$ 的边，直到第 $k$ 位。这一位对应的子树中存储的数值肯定满足要求。

然后考虑如何整体增加。我们发现对于如果字典树中的数据整体加 $1$，最低位为 $0$ 的数只有最低位会变化，最低位变成 $1$。而最低位为 $1$ 的数最低位变成 $0$，且之后高一位会增加 $1$。这相当于交换左右根节点儿子，并递归处理交换后的左儿子。这启发我们使用懒标记处理这个问题，上述的就是增加过程。

然而对于子树增加，这么做是困难的。因此，我们把这棵满足要求的子树和这棵子树的根到整个树的根分裂出来，打上懒标记，然后再合并回去。这么做的时间复杂度可以类比线段树合并与分裂的时间复杂度，为整体 $O(n\log n)$。

最后考虑整体加 $v$。我们沿用上面的思路，对于这一位加 $v$ 其实可以转化为对于下一位加 $\lfloor\frac{n}{2}\rfloor$。并且如果 $v$ 为奇数，就还需要在这一位处理一下加 $1$，因为这一个加 $1$ 没有下推。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long q,op,k,v,x,trie[20000000][2],tol[20000000],ad[20000000],cnt=1;
void pushdown(long long x)
{
	if(ad[x]&1)swap(trie[x][0],trie[x][1]),ad[trie[x][0]]++;
	ad[trie[x][0]]+=(ad[x]>>1),ad[trie[x][1]]+=(ad[x]>>1),ad[x]=0;
}

void insert(long long x)
{
	long long rt=1;
	tol[rt]++;
	for(long long i=0;i<=32;i++)
	    {
	    	pushdown(rt);
	    	long long id=(x>>i)&1;
	    	if(!trie[rt][id])trie[rt][id]=++cnt;
	    	rt=trie[rt][id],tol[rt]++;
		}
}

void del(long long x)
{
	long long rt=1;
	tol[rt]--;
	for(long long i=0;i<=32;i++)
	    {
	    	pushdown(rt);
	    	long long id=(x>>i)&1;
	    	rt=trie[rt][id],tol[rt]--;
		}
}

long long merge(long long x,long long y)
{
	if(!x||!y)return x+y;
	pushdown(x),pushdown(y);
	tol[x]+=tol[y],trie[x][0]=merge(trie[x][0],trie[y][0]),trie[x][1]=merge(trie[x][1],trie[y][1]);
    return x;
}

void update(long long x,long long k,long long v)
{
	long long rt=1,pt=++cnt,now=pt,pr=0,prt=0,pd=0,tmp=0;
	if(k==0)
	   {
	   	pushdown(rt),ad[rt]+=v;
	   	return;
	   }
	for(long long i=0;i<k;i++)
	    {
	    	pushdown(rt);
	    	long long id=(x>>i)&1;
	    	if(!trie[rt][id]||!tol[trie[rt][id]])return;
	    	pr=rt,pd=id,prt=pt;
	    	trie[pt][id]=++cnt,rt=trie[rt][id],pt=trie[pt][id];
		}
	pushdown(rt);
	trie[pr][pd]=0,trie[prt][pd]=rt,tmp=tol[rt];
	rt=1,pt=now;
	for(long long i=0;i<k;i++)
	    {
	    	pushdown(rt);
	    	long long id=(x>>i)&1;
	    	tol[rt]-=tmp,tol[pt]=tmp;
	    	rt=trie[rt][id],pt=trie[pt][id];
		}
	ad[now]+=v,merge(1,now);
}

long long getmax(long long x)
{
	long long rt=1,mx=0;
	for(long long i=0;i<=32;i++)
	    {
	    	pushdown(rt);
	    	long long id=(x>>i)&1;
	    	if(!trie[rt][id]||!tol[trie[rt][id]])return mx;
	    	mx=max(mx,i+1),rt=trie[rt][id];
		}
	return 32;
}

int main()
{
	scanf("%d",&q);
	for(long long i=1;i<=q;i++)
	    {
	    	scanf("%lld",&op);
	    	if(op==1)scanf("%lld",&x),insert(x);
	    	else if(op==2)scanf("%lld",&x),del(x);
	    	else if(op==3)scanf("%lld%lld%lld",&x,&k,&v),update(x,k,v);
	    	else if(op==4)scanf("%lld",&x),printf("%lld\n",(1ll<<getmax(x)));
		}
	return 0;
}
```

---

## 作者：Genius_Star (赞：1)

[**或许更好的阅读体验。**](https://www.cnblogs.com/rgw2010/p/18815039)

### 思路：

先考虑询问，考虑建一个从低到高为的 `01trie`，然后在上面遍历一遍 $x$。

对于路径中的一个点 $k$，设位数为 $len$，$x$ 当前的位为 $p$，那么若 $ch_{x, p \oplus 1}$ 存在，就存在一个 $y$ 使得 $\operatorname{lowbit}(x \oplus y) = 2^{len}$。

那么询问是好做的，扫一遍即可，复杂度为 $O(\log W)$。

考虑操作本质是干什么，要使得 $\operatorname{lowbit}(x \oplus y) \ge 2^k$，那么 $x$ 与 $y$ 的前 $k - 1$ 位相同，故找到 $x$ 前 $k - 1$ 位在 `01trie` 上的节点 $p$，相当于一个子树增加 $v$。

直接想子树加还是过于牛了，先考虑全局 $+v$ 操作要怎么做，类比全局 $+1$ 的做法；设当前有一个标记 $v$ 处理完了前 $len$ 位后下传到了第 $len$ 位的 $k$ 节点：

- 若 $v$ 是奇数，那么先对 $k$ 子树做一次全局 $+1$，此时 $v$ 就是偶数了。

- 若 $v$ 是偶数，那么对当前位已经没有贡献了，将 $\frac{v}{2}$ 下传到 $ch_{k, 0/1}$。

此时若全部下传时间复杂度肯定是 $O(N \log W)$，不可取，类比线段树的懒标记思想，若不需要访问则不下传；每次需要访问的时候下传；此时的全局 $+1$ 也要采用懒标记的思想，先 `swap(ch[k][0], ch[k][1])` 然后加到 `ch[k][0]` 上。

由于加法具有交换，结合律，是可合并的，故做法是对的，单次查询 $\log W$，打全局 $+v$ 标记是 $O(1)$ 的。

现在考虑子树加怎么做，显然直接类比上面思路将标记打到子树处是错误的，因为 $+v$ 后可能导致在这个子树内的数可能跑到另外一个子树去了。

考虑对 $x$ 的前 $k - 1$ 位与 $v$ 的前 $k - 1$ 位作加法，设加法结果的前 $k - 1$ 位为 $new$，第 $k$ 位的为 $flag$ 表示是否有进位。

那么子树加 $v$ 相当于将 $p$ 子树先提出来，然后进行全局加上 $flag + \lfloor \frac{v}{2^k} \rfloor$，之后与 $new$ 所在子树合并即可。

时间复杂度为 $O(Q \log V)$。

[**link**](https://www.luogu.com.cn/record/212867268)

### 完整代码：

```cpp
 #include<bits/stdc++.h>
#define lowbit(x) x & (-x)
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define add(x, y) ((x + y >= mod) ? (x + y - mod) : (x + y))
#define dec(x, y) ((x - y < 0) ? (x - y + mod) : (x - y))
#define ctz(x) __builtin_ctz(x)
#define popcnt(x) __builtin_popcount(x)
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef unsigned int uint;
typedef long long ll;
bool Begin;
const int N = 5e5 + 10;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
namespace XorTree{
	const int lim = 32, M = lim * N + 10;
	int cnt;
	int ch[M][2];
	int siz[M];
	uint tag[M], sum[M]; 
	inline int newnode(){
		++cnt;
		siz[cnt] = sum[cnt] = tag[cnt] = 0;
		ch[cnt][0] = ch[cnt][1] = 0;
		return cnt;
	}
	inline void pushup(int k){
		siz[k] = siz[ch[k][0]] + siz[ch[k][1]];
		sum[k] = (siz[ch[k][1]] & 1) | ((sum[ch[k][0]] ^ sum[ch[k][1]]) << 1);
	}
	inline void push_down(int k){
		if(tag[k]){
			if(tag[k] & 1){
				swap(ch[k][0], ch[k][1]);
				if(ch[k][0])
				  ++tag[ch[k][0]];
				--tag[k];
			}
			if(ch[k][0])
			  tag[ch[k][0]] += (tag[k] >> 1);
			if(ch[k][1])
			  tag[ch[k][1]] += (tag[k] >> 1); 
			tag[k] = 0;
		}
	}
	inline void insert(int k, uint v, int dep){
		if(dep >= lim){
			++siz[k];
			return ;
		}
		push_down(k);
		if(!ch[k][v & 1])
		  ch[k][v & 1] = newnode();
		insert(ch[k][v & 1], v >> 1, dep + 1);
		pushup(k);
	}
	inline void del(int k, uint v, int dep){
		if(dep >= lim){
			--siz[k];
			return ;
		}
		push_down(k);
		del(ch[k][v & 1], v >> 1, dep + 1);
		pushup(k);
	}
	inline int merge(int x, int y, int dep){
		if(!x || !y)
		  return x + y;
		if(dep >= lim){
			siz[y] += siz[x];
			return y;
		}
		push_down(x), push_down(y);
		ch[y][0] = merge(ch[x][0], ch[y][0], dep + 1);
		ch[y][1] = merge(ch[x][1], ch[y][1], dep + 1);
		ch[x][0] = ch[x][1] = 0;
		pushup(x), pushup(y);
		return y;
	}
	inline void Add(int k, uint v){
		tag[k] += v;
	}
	inline void Add(int k1, int k2, uint x, uint y, int k, int dep){
		if(!k1)
		  return ;
		if(dep == k){
			Add(k1, y);
			if(k1 != k2)
			  merge(k1, k2, k);
			return ;
		}
		push_down(k1), push_down(k2);
		if(!ch[k2][y & 1])
		  ch[k2][y & 1] = newnode();
		Add(ch[k1][x & 1], ch[k2][y & 1], x >> 1, y >> 1, k, dep + 1);
		pushup(k1), pushup(k2);
	}
	inline void Add(int rt, uint x, int k, uint v){
		int y = x + v;
		Add(rt, rt, x, y, k, 0);
	}
	inline int askmax(int k, uint x, int dep){
		if(dep >= lim)
		  return lim;
		push_down(k);
		if(siz[ch[k][x & 1]])
		  return askmax(ch[k][x & 1], x >> 1, dep + 1);
		return dep;
	}
	inline int askxor(int k){
		return sum[k];
	}
};
int rt, n, op;
uint x, k, v, ans;
bool End;
int main(){
	rt = XorTree::newnode();
	n = read();
	while(n--){
		op = read(), x = read();
		if(op == 1)
		  XorTree::insert(rt, x, 0);
		else if(op == 2)
		  XorTree::del(rt, x, 0);
		else if(op == 3){
			k = read(), v = read();
			x &= (1ll << k) - 1;
			XorTree::Add(rt, x, k, v);
		}
		else{
			ans = XorTree::askmax(rt, x, 0);
			write(1ll << ans);
			putchar('\n');
		}
	}
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：happybob (赞：1)

题意：

维护一个**可重集** $S$，初始为空。支持 $q$ 次如下操作：

- `1 x`，你需要在 $S$ 中加入一个数 $x$。
- `2 x`，你需要在 $S$ 中删除一个数 $x$。保证此时 $S$ 中存在至少一个 $x$。如果存在多个 $x$，则仅删除一个。
- `3 x k v`，你需要对 $S$ 中所有满足 $\operatorname{lowbit}(x\oplus y)\geq 2^k$ 的 $y$ 增加 $v$ 并对 $2^{32}$ 取模。
- `4 x`，你需要求出 $\max\limits_{y\in S} \operatorname{lowbit}(x\oplus y)$。保证此时 $S$ 不为空。

其中 $\operatorname{lowbit}(x)$ 表示最大的整数 $k$，使得 $k$ 是 $2$ 的整数次幂并且整除 $x$。$\oplus$ 代表[按位异或](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677)。

**特殊的，我们在本题定义 $\boldsymbol{\textbf{lowbit}(0)=2^{32}}$。**

$1 \leq q \leq 5 \times 10^5$，值域 $2^{32}-1$，时限 $2$ 秒，空间限制 $512$ MB。

解法：

没有操作三是简单的，从低到高位建立 01-Trie，查询直接从低到高匹配就行了。

但是操作三很奇怪，01-Trie 上的加法首先让我们想到的是那个全局加 $1$ 的做法，但是这里加的是 $v$。显然操作三是一个子树加，但是我们先考虑全局加怎么做。

对于每个点，维护加法标记，下传时，如果标记为奇数，做一次子树加一然后标记减一。将标记除以二后传给两个儿子。进一步地，子树加一可以直接交换左右儿子然后给左子树标记加一。

子树加并不能直接按照全局加将标记放上去，因为事实上这里的加法标记对应的是真正要加的除以 $2^{dep}$ 所得结果，但是子树到根的链上的信息并无法维护。

然而仿照线段树分裂合并，直接将整棵子树分裂出来做全局加，然后合并回去即可。复杂度 $O(q \log V)$。

---

## 作者：Erine (赞：1)

Tags: 01trie，lazytag 思想，（类）线段树合并。6。

显然需要建 01trie，而且是从低位往高位建。然后我们就直接解决掉了 $1,2,4$ 操作。然后对于 $3$ 操作，所周知从低往高的 01trie 可以通过打 tag 实现全局 $+1$，但是这里是 $+v$，还是子树加，看起来比较麻烦。

考虑全局 $+v$ 咋做：对于根结点打 $+v$ 的 lazytag。pushdown 时，若 $v$ 是奇数，需要交换左右儿子，然后在原来的右儿子上打 $\left\lfloor\dfrac v2\right\rfloor+1$ 的 lazytag，原来的左儿子则是 $\left\lfloor\dfrac v2\right\rfloor$。

接下来考虑子树加。我们首先在子树里打上对应的加标记，就像全局加一样。然而还需要处理掉当前子树根到整棵树根的这一段加，也就是这一整棵子树因为加法，会被我们挪到另一个结点下边，也就是合并俩子树，删除这个子树。直接做类线段树合并即可，复杂度分析类似，总复杂度 $\Theta(q\log V)$。

---

## 作者：anthonyaaabc (赞：1)

~~感觉比 T4 简单，赛时 T4 做了 3 个小时没时间调了。~~

首先观察异或的 $\operatorname{lowbit}$ 的性质，如何让 $\operatorname{lowbit}$ 变的更大，由于异或操作的特点，显然是贪心的对低位进行匹配，使得异或的前几位尽量为 $0$ ，这样最低位就会尽量的高。很容易想到维护字典树，每次将元素从低位到高位插入字典树，查询的时候直接优先走可以匹配的位置，不能匹配的其实不用走，不能匹配相当于已经算出了答案。关键变成了第三个操作不是很常规。

对于非常奇怪的范围的修改操作，可以先观察修改范围具体在数据结构影响的是什么。由于限制是 $\operatorname{lowbit}(x\oplus y)\geq 2^k$，这相当于二进制的前 $ k - 1 $ 位都得匹配，修改形如一个字典树上的区间，字典树上是可以对下标区间加的，对于有 $1$ 的位置相当于交换子树，并且更新懒标记的进位，$0$ 的位置直接下传即可。关键在于前 $ k -1 $ 位的影响只对一部分有效，并非维护整区间，难以采用懒标记维护。我的解决办法是采用线段树分裂将区间先分裂出来，打上懒标记，再采用线段树合并将区间合并回去。由于合并的时候会把两个节点合成一个，均摊复杂度下是正确的。不知道有没有更简单的解决办法。复杂度为 $O(q \log V)$ 的。

代码:

```cpp
#include<bits/stdc++.h>
#define lson (t[u].ls)
#define rson (t[u].rs)
using namespace std;
typedef unsigned int uint;
const int N=500005;
int q;
struct seg
{
    int ls,rs,num;
}t[65*N];

int rt,p;
uint lz[65*N];
long long lowbit(long long x)
{
    if(x==0)return (1ll<<32);
    else return (x&(-x));
}
void push_up(int u,int now)
{
    if(now==32)return;
    t[u].num=t[lson].num+t[rson].num;
}

void push_down(int u)
{
    if(lz[u])
    {
        if((lz[u]&1))
        {
            swap(t[u].ls,t[u].rs);
            lz[rson]+=((lz[u]>>1));
            lz[lson]+=((lz[u]>>1)+uint(1));
        }
        else
        {
            lz[rson]+=(lz[u]>>1);
            lz[lson]+=(lz[u]>>1);
        }
        lz[0]=0;
        lz[u]=0;
    }
}
void insert(int &u,int now,uint x)
{
    if(u==0)
    {
        u=++p;
        t[u]=t[0];
    }
    if(now==32)
    {
        t[u].num++; 
        return;
        

    }
    push_down(u);
    if((x>>now)&1)
    {
        insert(rson,now+1,x);
    }
    else insert(lson,now+1,x);
    push_up(u,now);
}
void del(int &u,int now,uint x)
{
    if(u==0)
    {
        u=++p;
        t[u]=t[0];
    }
    if(now==32)
    {
        t[u].num--;
        return;
    }
    push_down(u);
    if((x>>now)&1)
    {
        del(rson,now+1,x);
    }
    else del(lson,now+1,x);
    push_up(u,now);
}
int merge(int x,int y,int now)
{
    if(x==0||y==0)return x|y;
    if(now==32)
    {
        t[x].num=t[x].num+t[y].num;
        push_up(x,32);
        return x;
    }
    push_down(x);
    push_down(y);
    t[x].ls=merge(t[x].ls,t[y].ls,now+1);
    t[x].rs=merge(t[x].rs,t[y].rs,now+1);
    push_up(x,now);
    return x;
}
void split(int &u,int &v,int now,int mx,uint x)
{
    if(v==0)return;
    
    if(now==mx)
    {
        u=v;
        v=0;
        return;
    }
    u=++p;
    t[u]=t[0];
    push_down(v);
    if((x>>now)&1)
    {
        split(t[u].rs,t[v].rs,now+1,mx,x);
    }
    else
    {
        split(t[u].ls,t[v].ls,now+1,mx,x);
    }
    push_up(u,now);
    push_up(v,now);
}
long long find(int &u,int now,uint x)
{
    if(now==32)
    {
        return lowbit(0);

    }
    push_down(u);
    if((x>>now)&1)
    {
        if(t[rson].num>0)
        {
            return find(rson,now+1,x);
        }
        else return (1ll<<now);
    }
    else
    {
        if(t[lson].num>0)
        {
            return find(lson,now+1,x);
        }
        else return (1ll<<now);
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    p=0;
    t[0]={0,0,0};
    cin>>q;
    while(q--)
    {
        int opt;
        cin>>opt;
        if(opt==1)
        {
            uint x;
            cin>>x;
            insert(rt,0,x);
        }
        else if(opt==2)
        {
            uint x;
            cin>>x;
            del(rt,0,x); 
        }
        else if(opt==3)
        {
            uint x;
            cin>>x;
            int k;
            cin>>k;
            x=x&((1ll<<k)-1);
            uint v;
            cin>>v;
            int rtt=0;
            
            split(rtt,rt,0,k,x);
            lz[rtt]+=v;
            rt=merge(rt,rtt,0);
            
        }
        else
        {
            uint x;
            cin>>x;
            cout<<find(rt,0,x)<<'\n';
        }
    }
}
```

---

## 作者：liruixiong0101 (赞：0)

一道综合了很多经典 trick 的题目。

---

前两个操作比较普通，首先考虑第四个操作，看到异或，我们可以想到使用 01trie 维护，又有 $\operatorname{lowbit}$，我们可以想到从低到高建 01trie。

我们先抛开第三种操作不管，只考虑一二四操作，插入删除在 01trie 上很好维护，第四种操作，我们可以在 trie 树上尽量选和 $y$ 二进制位相同的子树走，如果那一颗子树是空的，那么当前的深度就是答案。

我们再来考虑第三种操作，容易发现其本质就是子树加 $v$ （模 $2^{64}$）操作，这个操作有点复杂，我们先从全局加 $1$ 操作开始。

全局加 $1$，就会使得每个数的奇偶性改变，所以我们需要交换根的两颗子树（这其实就相当于全局异或 $1$），但是还需要考虑进位，进位就相当于在根的 $1$ 子树上加 $1$，以此类推。所以全局加 $1$，就是将 trie 树上将右链的所有结点从下到上依次交换左右子树。这样总共的时间复杂度就是 $\mathcal{O}(q\log V)$。

接下来考虑全局加 $v$，我们使用打标记的方式完成这个操作，首先在根上打上加 $v$ 标记，下传标记需要分类讨论一下：如果 $v$ 是偶数，那么就将左右子树分别打上 $\dfrac v2$ 的标记；如果 $v$ 是奇数，就执行一次全局加 $1$，将 $v$ 变为偶数后下传标记，这样的时间复杂度是 $\mathcal{O}(q\log^2 V)$，但是有一种方法，就是在下传标记时，若 $v$ 为奇数，将右子树多打上 $1$ 的标记，然后交换左右子树，这样的时间复杂度就是 $\mathcal{O}(q\log V)$ 的了。

最后考虑子树加 $v$，由于 $v$ 可能不能整除 $2^k$，也就是说不能在子树上直接打上加 $\dfrac{v}{2^k}$ 的标记，所以还是只能考虑在根上打标记。我们可以直接将这颗子树通过线段树分裂的方式分裂，然后在新的子树上打标记，最后合并，这样就实现了该操作，总时间复杂度 $\mathcal{O}(q\log V)$。

---

代码如下：
```cpp
#include <bits/stdc++.h>

using namespace std;
using UI = unsigned int;

const int kMaxN = 2.5e5 + 5, kL = 32;

int n, o, k, tot, root, nex[2 * kMaxN * kL][2], siz[2 * kMaxN * kL];
UI x, v, laz[2 * kMaxN * kL];

int NewNode() { return (tot++, nex[tot][0] = nex[tot][1] = siz[tot] = laz[tot] = 0, tot); }

void PushUp(int u) { siz[u] = u ? siz[nex[u][0]] + siz[nex[u][1]] : 0; }

void AddTag(int u, UI k) { u && (laz[u] += k); }

void PushDown(int u) {
  AddTag(nex[u][0], laz[u] / 2);
  AddTag(nex[u][1], laz[u] / 2);
  if (laz[u] & 1) {
    AddTag(nex[u][1], 1);
    swap(nex[u][0], nex[u][1]);
  }
  laz[u] = 0;
}

void Insert(int &u, int dep, UI x) {
  !u && (u = NewNode());
  if (dep == kL) return (siz[u]++, (void)0);
  PushDown(u);
  Insert(nex[u][x >> dep & 1], dep + 1, x);
  PushUp(u);
}

void Delete(int &u, int dep, UI x) {
  if (dep == kL) return (siz[u]--, (void)0);
  PushDown(u);
  Delete(nex[u][x >> dep & 1], dep + 1, x);
  PushUp(u);
}

int Merge(int u, int v, int dep) {
  if (!u || !v) return u | v;
  if (dep == kL) return (siz[u] += siz[v], u);
  PushDown(u), PushDown(v);
  nex[u][0] = Merge(nex[u][0], nex[v][0], dep + 1);
  nex[u][1] = Merge(nex[u][1], nex[v][1], dep + 1);
  return (PushUp(u), u);
}

void Split(int u, int dep, int &x, int &y, UI c, int k) {  // __lg(lowbit(x ^ c)) >= k, x += v
  if (!u) {
    x = y = 0;
    return;
  }
  PushDown(u);
  if (dep == k) {
    x = 0, y = u;
    return;
  }
  x = u, y = NewNode();
  int now = c >> dep & 1;
  Split(nex[u][now], dep + 1, nex[x][now], nex[y][now], c, k);
  nex[x][now ^ 1] = nex[u][now ^ 1];
  PushUp(x), PushUp(y);
}

int Query(int u, int dep, UI x) {
  PushDown(u);
  return siz[nex[u][x >> dep & 1]] ? Query(nex[u][x >> dep & 1], dep + 1, x) : dep;
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  for (cin >> n; n; n--) {
    cin >> o >> x;
    if (o == 1) {
      Insert(root, 0, x);
    } else if (o == 2) {
      Delete(root, 0, x);
    } else if (o == 3) {
      cin >> k >> v;
      static int a, b;
      Split(root, 0, a, b, x, k);
      AddTag(b, v), root = Merge(a, b, 0);
    } else {
      cout << (1LL << Query(root, 0, x)) << '\n';
    }
  }
  return 0;
}
```

---


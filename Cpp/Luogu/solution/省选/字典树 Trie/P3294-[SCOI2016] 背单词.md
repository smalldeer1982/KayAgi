# [SCOI2016] 背单词

## 题目描述

Lweb 面对如山的英语单词，陷入了深深的沉思：我怎么样才能快点学完，然后去玩三国杀呢？这时候睿智的凤老师从远处飘来，他送给了 Lweb 一本计划册和一大缸泡椒，他的计划册是长这样的：

| 序号    | 单词 |
| ------- | ---- |
| $1$     |      |
| $2$     |      |
| $\dots$ |      |
| $n-1$    |      |
| $n$     |      |

然后凤老师告诉 Lweb ，我知道你要学习的单词总共有 $n$ 个，现在我们从上往下完成计划表，对于一个序号为 $x$ 的单词（序号 $1,\dots ,x-1$ 都已经被填入）：

1. 如果存在一个单词是它的后缀，并且当前没有被填入表内，那他需要吃 $n \times n$ 颗泡椒才能学会；
2. 当它的所有后缀都被填入表内的情况下，如果在 $1,\dots,x-1$ 的位置上的单词都不是它的后缀，那么你吃 $x$ 颗泡椒就能记住它；
3. 当它的所有后缀都被填入表内的情况下，如果 $1,\dots,x-1$ 的位置上存在是它后缀的单词，所有是它后缀的单词中，序号最大为 $y$，那么你只要吃 $x-y$ 颗泡椒就能把它记住。

Lweb 是一个吃到辣辣的东西会暴走的奇怪小朋友，所以请你帮助 Lweb ，寻找一种最优的填写单词方案，使得他记住这 $n$ 个单词的情况下，吃最少的泡椒。

形式化题意：

你需要为 $n$ 个字符串排列一个顺序，每个字符串都会产生一定代价。

对于一个字符串 $s$，其所在位置为 $x$：

1. 如果存在至少一个其他字符串是 $s$ 后缀，且这个字符串的位置在 $s$ 后面， $s$ 将产生 $n \times n$ 的代价。

2. 如果不存在其他字符串是 $s$ 的后缀，则 $s$ 产生 $x$ 的代价。

3. 如果所有是 $s$ 后缀的字符串的位置都在 $s$ 的前面，若这些字符串的位置的最大值为 $y$ ， 则 $s$ 产生 $x-y$ 的代价。

为 $n$ 个字符串排列一个顺序，使总代价最小。

## 说明/提示

$1\le n\le100000$，所有字符的长度总和 $1\le \sum|S| \le510000$。

## 样例 #1

### 输入

```
2
a
ba```

### 输出

```
2```

# 题解

## 作者：Infiltrator (赞：85)

# 题意解释（本题最重要的部分）  
~~本篇题解过于详细，适合初学者食用~~  

给你一些字符串，让你对其进行排列，使得按以下规则花费最少(然而题意真的不清楚，很容易就让人以为字符串的顺序是排好的)  

> （$x$为字符串在自行排定的序列中的位置，当前字符串为$a$)  
> 1.如果$a$存在后缀且a的后缀在a之后，花费$+=n^2$  
> 2.如果$a$不存在后缀则花费$+=x$  
> 3.设$y$为$a$之前离其最近的是$a$的后缀的字符串的位置，$a$存在后缀且$a$的后缀在$a$之前，则花费$+=x-y$   

经过转化题意就比较显然了，但是我们如果仔细读题我们发现1，2规则其实完全没有必要。  

规则1我们只要把$a$的后缀放在$a$之前就好了，这样肯定优于放在$a$的后面因为$x-y$的值最大只能是n-1显然优于$n^2$ 

规则2我们发现其实就是规则三中$y=0$的特殊情况，直接当规则3来处理就好  

# 大体思路  
看到后缀我们显然首先想到的是后缀数组，但是本蒟蒻太弱了不会怎么办？？？（~~而且本蒟蒻也不知道本题能不能用后缀数组~~）

我们把字符串翻个顺序就会发现后缀其实就是前缀，所以我们可以翻转字符串，处理前缀。  

而处理前缀我们首先就会想到trie字典树，座椅本题我们采用建立trie字典树的做法。  

看懂题目的规则之后我们发现可以贪心的求解此题，只要让字符串的后缀与字符串之间所隔的字符串数目最小即可  

所以第一步我们建立一颗trie树  

第二步我们发现一个字符串有可能有很多后缀，所以我们需要判重，这里使用**并查集**  
+
优于字符串的后缀与字符串之间存在有向的关系，便建立一张有向图。$x->y$代表$x$是$y$的后缀   

因为要保证字符串与字符串的后缀之间距离最小所以贪心的选取以x为根的最小的子树 

（使用vector在算出每棵子树大小后进行排序即可）   
最后按照规则求和

# 求和时使用dfs序的正确性的证明  

## 经WQY查阅无误^_^

如果你有认真看我的或其他人的题解，你可以发现我们在最后求和的时候是按照dfs序的。那么为什么？（~~我不会~~）  

所以我在夏令营时找了wqy神仙请教。  

>考虑建出一棵树之后，对于构建的任意合法的序列，都满足i的父亲一定在i之前出现，i的孩子们都一定在i之后出现  

>先尝试证明dfs序一定最优，对于以同一深度的节点为根的子树，在一颗中找一个叶子节点j,在另一颗里找一个根节点i(当前序列中j所在的子树的根在i之前出现  

>假设j<i的时候代价最小，尝试将j放在i的后面，此时i<j。那么我们发现如果j放在i与i的孩子们之间，i的孩子们和i的距离都会加1，所以总代价会增加，而j和j的父亲的距离一定也会增加，所以总代价也会增加  

>所以对于j所在子树的根比i在序列中出现的早的情况，j<i的情况是最优的  

>那么每个子树形成了一段连续的区间，对于每个节点进行调整，最后我们发现形成了一个dfs序(有时别的序列也会和dfs序列一样优秀，但是此处证明的是dfs序列是最优解之一，不是唯一解

>接下来再证明先遍历子树小的更优秀。  

>WQY:  
>月明风清 2019.11.4 21:28:04  
>因为你所有的size排序之后

>月明风清 2019.11.4 21:28:17  
>第i个根节点的贡献是前面所有树的size之和  
>所以要排序

>综上所述，当我们进行dfs序且按子树大小排序时，求出代价即为最优。 

>Q.E.D

感谢wqy，给了我很大的帮助[wucstdio](https://www.luogu.org/space/show?uid=54214)

# CODE 
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;
#define N 510050
#define M 100050
#define ll long long
ll ans=0;
char x[N];
int n,cnt,bo[N],tot=1,trie[5000050][27],fa[N],id[N],son[N],num;
vector<int>tu[N];
int read()
{
    int s=0,p=1;
    char ch=getchar();
    while(ch<'0' || ch>'9')
    {
        if(ch=='-')p=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
    {
        s=(s<<1)+(s<<3)+(ch^48);
        ch=getchar();
    }
    return s*p;
}
int find(int x)
{
    if(fa[x]==x)return fa[x];
    else return fa[x]=find(fa[x]);
}
void insert(char *s,int bh)
{
    int l=strlen(s);
    int u=1;
    for(int i=l-1;i>=0;i--)
    {
        int c=s[i]-'a';
        if(!trie[u][c])trie[u][c]=++tot;
        u=trie[u][c];
    }
    bo[u]=bh;
}
void make(int x)
{
    for(int i=0;i<26;i++)
    {
        int v=trie[x][i];
        if(v)
        {
            if(!bo[v])
            {
                fa[v]=find(x);
            }
            else
            {
                tu[bo[find(x)]].push_back(bo[v]);
            }
            make(v);
        }
    }
}
int cmp(int x,int y)
{
    return son[x]<son[y];
}
void sonsum(int x)
{
    son[x]=1;
    for(vector<int> :: iterator it=tu[x].begin();it!=tu[x].end();it++)
    {
        int v=*it;
        sonsum(v);
        son[x]+=son[v];
    }
    sort(tu[x].begin(),tu[x].end(),cmp);
}
void dfs(int x)
{
    id[x]=num++;
    for(vector<int> :: iterator it=tu[x].begin();it!=tu[x].end();it++)
    {
        int v=*it;
        ans+=num-id[x];
        dfs(v);
    }
}
void dfss(int x)
{
    for(vector<int> :: iterator it=tu[x].begin();it!=tu[x].end();it++)
    {
        int v=*it;
        cout<<v<<endl;
        dfss(v);
    }
}
int main()
{
    n=read();
    for(int i=1;i<=n;i++)
    {
        scanf("%s",x);
        insert(x,i);
    }
    for(int i=1;i<=tot;i++)fa[i]=i;
    make(1); sonsum(0);dfs(0);
    printf("%lld",ans);
    return 0;
}
```
并查集去重的思路来源于[此篇blog](https://www.luogu.org/blog/communist/solution-p3294)

---

## 作者：yuzhechuan (赞：65)

个人认为图片是最好理解的，因此本题解将按图说话

---

### 题意（已用贪心思路简化）
给定n个单词$s_i$，请重排序列，使每个单词的存在的后缀都在**前面**

设$s_j$为离$s_i$最近的后缀字符串

定义$a_i=i-j$

$ans=min(\sum a_i)$

---

### 题解

后缀显然没有前缀来的容易处理，所以自然想到翻转每个单词，建出trie树

下面是个例子：

```cpp
6
a
ca
ea
gda
hda
ifb
```

#### 1. 建出trie树(红点是颠倒后每个单词的末尾，注意根也是）：

![](https://s2.ax1x.com/2019/10/28/K6m0Rf.png)

```cpp
	void ins(char *s){
		int x=0;
		for(int i=0;s[i];i++){
			if(!a[x].nt[s[i]-'a']) a[x].nt[s[i]-'a']=++cnt;
			x=a[x].nt[s[i]-'a'];
		}
		a[x].tag=1; //tag==1说明是红点
	}
```

#### 2. 重构树

跳过白点，保留红点（白点无用，可以忽略）

![](https://s2.ax1x.com/2019/10/28/K6mwJP.png)

```cpp
	void doit(int x){
		if(a[x].tag&&x){
			g[last[x]].push_back(x); //g[x][]存重构树中点x的儿子们
			last[x]=x; //last[x]是原树里x节点上方离它最近的红点（包括自己）
		}
		for(int i=0;i<26;i++) if(a[x].nt[i]){
			last[a[x].nt[i]]=last[x];
			doit(a[x].nt[i]);
		}
	}
```

#### 3. dfs遍历重构树，并将直接祖先相同的子树按节点数从小到大排序

![](https://s2.ax1x.com/2019/10/28/K6uGEd.png)

```cpp
inline bool cmp(const int &x,const int &y){
	return sz[x]<sz[y];
}
void dfs(int x){
	sz[x]=1; //sz[x]是以x为根的子树的大小
	for(int i=0;i<g[x].size();i++){
		dfs(g[x][i]);
		sz[x]+=sz[g[x][i]];
	}
	sort(g[x].begin(),g[x].end(),cmp);
}
```

#### 4. 根据题意遍历重构树，用dfs序得到答案

```cpp
void getans(int x){
	int dfn=cnt++; //dfn是父亲的dfs序，cnt是节点自己的dfs序
	for(int i=0;i<g[x].size();i++){
		ans+=cnt-dfn; //两者相减就是题意里的ai
		getans(g[x][i]);
	}
}
```

---

### 思路背后的理由

#### Q1. 为什么题意可以这样简化？
三条规则，规则一显然是可以被避免且没有后两种优的，规则二可以看做规则三的特殊情况，简单起见，只考虑规则三即可

#### Q2. 排序的正确性？
花费与最后一个填入的后缀有关,那么这个后缀的位置离当前位置越近越好,也就是应该有尽量少的单词夹在两个中间,所以我们应该选下属单词最少的那个进行拓展，而下属单词的多少就等价于重构树中子树的大小。

#### Q3. dfs序的正确性？
这里引用 @坐山客 的题解：
> 考虑重新建树之后，i节点的子树中的所有节点的后缀都是i

>如果同一深度上有不止一棵子树，那么我们先在一棵上取出一个叶子节点j，再取出一个根节点i，我们发现如果j>i的话肯定不如i<j优秀

>因为调整之后i的子树上所有节点对花费的贡献-=子树大小，j对花费的贡献+1，所以我们可以看到j>i的花费<=i>j的情况

>最后我们经过所有的调整可以发现序列变成了dfs序

>所以dfs序最优

---

### 完整代码

将以上各步骤代码合在一起就是：

**tips. ANS要用long long!!!**

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(int &x){
	char c=getchar();bool f=0;x=0;
	while(!isdigit(c)) f|=c=='-',c=getchar();
	while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
	if(f) x=-x;return x;
}
inline void write(long long x){
	if(x<0) putchar('-'),write(-x);
	else{if(x>9) write(x/10);putchar('0'+x%10);}
}
const int L=5.1e5+5;
struct node{ //trie树的每个节点
	int nt[26];
	bool tag;
};
long long ans;
int cnt,last[L],sz[L],n;
vector<int> g[L];
char s[L];
struct trie{ //trie及所需操作
	node a[L];
	int cnt;
	void ins(char *s){ //建树
		int x=0;
		for(int i=0;s[i];i++){
			if(!a[x].nt[s[i]-'a']) a[x].nt[s[i]-'a']=++cnt;
			x=a[x].nt[s[i]-'a'];
		}
		a[x].tag=1;
	}
	void doit(int x){ //重构树
		if(a[x].tag&&x){
			g[last[x]].push_back(x);
			last[x]=x;
		}
		for(int i=0;i<26;i++) if(a[x].nt[i]){
			last[a[x].nt[i]]=last[x];
			doit(a[x].nt[i]);
		}
	}
}tr;

inline bool cmp(const int &x,const int &y){
	return sz[x]<sz[y];
}
void dfs(int x){ //重排重构树
	sz[x]=1;
	for(int i=0;i<g[x].size();i++){
		dfs(g[x][i]);
		sz[x]+=sz[g[x][i]];
	}
	sort(g[x].begin(),g[x].end(),cmp);
}
void getans(int x){ //统计答案
	int dfn=cnt++;
	for(int i=0;i<g[x].size();i++){
		ans+=cnt-dfn;
		getans(g[x][i]);
	}
}
signed main(){
	read(n);
	for(int i=1;i<=n;i++){
		scanf("%s",s);
		reverse(s,s+strlen(s)); //反转单词
		tr.ins(s);
	}
	tr.a[0].tag=1; //根也是红点
	tr.doit(0);
	dfs(0);
	getans(0);
	write(ans);
}
```

---

## 作者：communist (赞：40)

### 阅读理解题

题意见楼上题解

------------

### $Trie$

后缀问题不好处理，我们把它转化为前缀问题，用字典树解决问题

### 贪心

容易想到，一个串的后缀要先于它插入

对于一个串和其若干后缀串，容易想到，我们要先插入后缀串

然后递归进入$size$最小的子串

```
bool cmp(const int &x,const int &y)
{
	return size[x]<size[y];
}
void makes(int x)
{
	size[x]=1;
	for(int i=0;i<t[x].size();i++)
	{
		makes(t[x][i]);
		size[x]+=size[t[x][i]];
	}
	sort(t[x].begin(),t[x].end(),cmp);
}
void dfs(int x)
{
	id[x]=tot++;
	for(int i=0;i<t[x].size();i++)
	{
		ans+=tot-id[x];
		dfs(t[x][i]);
	}
}
```

### 注意

求$size$要重构树，只保留关键点

### 和楼上不一样的地方

#### 因为我太蒻了，并不会指针，所以提供一个并查集重构树的方法

在建$Trie$时给所有串的结尾和$Trie$树的根节点标号，表示新树中点的编号

```
void insert(const string &s,int id)
{
	int now=0,l=len[id];
	for(int i=0;i<l;i++)
	{
		int c=idx(s[i]);
		now=tr[now][c]?tr[now][c]:tr[now][c]=++cnt;
	}
	val[now]=id;
}
```

然后遍历$Trie$树，如果一个节点的子节点没有被标号，就把它并入当前节点的集合；否则把这个子节点作为当前节点所在集合的根的儿子（就是连一条边）

```
void make(int x)
{
	for(int v,i=0;i<26;i++)
		if(v=tr[x][i])
		{
			if(!val[v])
				f[v]=find(x);
			else
				t[val[find(x)]].push_back(val[v]);
			make(v);
		}
}
```

### 代码：

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#define int long long 
using namespace std;
const int maxl=510010,maxn=1e5+10;
int n,tr[maxl][30],val[maxl],cnt,len[maxn],size[maxn],tot,f[maxl],id[maxn],ans;
vector<int>t[maxn];
string st[maxn];
inline int find(int x)
{
	return x==f[x]?x:f[x]=find(f[x]);
}
inline int idx(char c)
{
	return c-'a';
}
void insert(const string &s,int id)
{
	int now=0,l=len[id];
	for(int i=0;i<l;i++)
	{
		int c=idx(s[i]);
		now=tr[now][c]?tr[now][c]:tr[now][c]=++cnt;
	}
	val[now]=id;
}
void make(int x)
{
	for(int v,i=0;i<26;i++)
		if(v=tr[x][i])
		{
			if(!val[v])
				f[v]=find(x);
			else
				t[val[find(x)]].push_back(val[v]);
			make(v);
		}
}
bool cmp(const int &x,const int &y)
{
	return size[x]<size[y];
}
void makes(int x)
{
	size[x]=1;
	for(int i=0;i<t[x].size();i++)
	{
		makes(t[x][i]);
		size[x]+=size[t[x][i]];
	}
	sort(t[x].begin(),t[x].end(),cmp);
}
void dfs(int x)
{
	id[x]=tot++;
	for(int i=0;i<t[x].size();i++)
	{
		ans+=tot-id[x];
		dfs(t[x][i]);
	}
}
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		cin>>st[i];
		len[i]=st[i].length();
		for(int j=0;j<len[i]/2;j++)
			swap(st[i][j],st[i][len[i]-j-1]);
		insert(st[i],i);
	}
	for(int i=1;i<=cnt;i++)
		f[i]=i;
	make(0),makes(0),dfs(0);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：skylee (赞：19)

题目大意：

给你n个字符串，不同的排列有不同的代价，代价按照如下方式计算（字符串s的位置为x）：

1.排在s后面的字符串有s的后缀，则代价为n^2；

2.排在s前面的字符串有s的后缀，且没有排在s后面的s的后缀，则代价为x-y（y为最后一个与s不相等的后缀的位置）；

3.s没有后缀，则代价为x。

求最小代价和。

思路：

很显然，将这些字符串倒过来后，所有的后缀都变成了前缀，而处理前缀问题的好工具是Trie，因此我们可以考虑将这些字符串倒过来建立一棵Trie。

分析不同情况下的代价，很显然，在1的情况下，得到的代价比其他的都大，容易证明在1的情况下，将这个后缀移到s的前面，代价总会比原来小。

所以我们不能让情况1出现。

考虑一个贪心。

只考虑那些为字符串结尾字符的结点，我们要保证每个结点的编号减去其父亲结点编号的和最小。

这样从小到大遍历每个结点的子树，得到每个结点的编号即可。

```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
const int N=100001;
const int LEN=510001;
char s[LEN];
std::vector<int> e[N];
int size[N];
long long f[N];
bool cmp(const int &x,const int &y) {
    return size[x]<size[y];
}
class Trie {
    private:
        static const int MAX_NODE=LEN;
        static const int SIGMA_SIZE=26;
        struct Node {
            Node *ch[SIGMA_SIZE];
            int val;
            Node() {
                memset(ch,0,sizeof ch);
                val=0;
            }
        };
        int idx(const char &ch) {
            return ch-'a';
        }
    public:
        Node *root;
        Trie() {
            root=new Node;
        }
        void insert(char s[],const int &id) {
            Node *p=root;
            for(unsigned i=strlen(s)-1;~i;i--) {
                int w=idx(s[i]);
                if(p->ch[w]) {
                    p=p->ch[w];
                } else {
                    p=p->ch[w]=new Node;
                }
            }
            p->val=id;
        }
        void rebuild(const Node *x,const int &p) {
            if(x->val) {
                e[p].push_back(x->val);
            }
            for(unsigned i=0;i<SIGMA_SIZE;i++) {
                Node *y=x->ch[i];
                if(!y) continue;
                rebuild(y,x->val?x->val:p);
            }
            delete x;
        }
        void getsize(const int &x) {
            size[x]=1;
            for(unsigned i=0;i<e[x].size();i++) {
                int &y=e[x][i];
                getsize(y);
                size[x]+=size[y];
            }
            std::sort(e[x].begin(),e[x].end(),cmp);
        }
        void solve(const int &x) {
            f[x]=1;
            long long tmp=0;
            for(unsigned i=0;i<e[x].size();i++) {
                int &y=e[x][i];
                solve(y);
                f[x]+=f[y]+tmp;
                tmp+=size[y];
            }
        }
};
Trie t;
int main() {
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++) {
        scanf("%s",s);
        t.insert(s,i);
    }
    t.rebuild(t.root,0);
    t.getsize(0);
    t.solve(0);
    printf("%lld\n",f[0]-1);
    return 0;
}
```

---

## 作者：Poncirus (赞：10)

**upd on 23/01/11 增加了对建图部分的更多说明、对方法的感性证明和代码注释，使其更准确严谨、浅显易懂。**

***

题解 P3294。

我们看到字典树这个标签，下意识想到了前缀。

但是题目让我们求后缀，所以我们把所有字符串先 `reverse` 一下，将问题转化为前缀，方便描述。

***

我们发现，因为 $y < x \le n$，所以三种情况的花费排序为 $x-y<x<n\times n$。

不难发现，我们可以很简单地通过「把某单词的所有前缀单词放到它之前」消除开销为 $n\times n$ 的情况。此时开销最劣情况下为 $\sum\limits_{i=1}^ni < n\times n$。

接下来，问题在于怎样在满足「把某单词的所有前缀单词放到它之前」的条件下，最小化开销。不难发现，当我们去除第一种情况后，剩下的 $x$ 和 $x-y$ 都包含 $x$ 项，也就是说，我们只需要最小化 $\sum -y$ 的值，也就是最大化 $\sum y$ 的值。而 $\sum x$ 为定值 $\sum\limits_{i=1}^ni$。

**关于处理方式：不难发现一个单词的最长前缀单词最多只有一个，但以该单词为最长前缀单词的单词可能有多个，联想到树。**

**我们将每个单词的最长前缀和该单词连边，会得到一个森林。**

不妨先考虑问题的简化，假设有两条链（即，不会同时存在多个单词，使得它们的最长前缀单词相同），应该如何安排其顺序。

如图所示，考虑「同一条链均匀分散到序列中」和「同一条链集中在一起」两种有规律的安排方式，得到：

![](https://pic.imgdb.cn/item/63bd1692be43e0d30e65e7de.jpg)

可以发现，第二种情况明显更优。

所以我们扩展猜想：对于某一单词，以它为前缀的所有单词必须紧随其后。该结论是可递归的。

继续处理细节部分。考虑两条链长度不同，应如何排列它们的位置？

下图展示了「前短后长」和「前长后短」两种方案：

![](https://pic.imgdb.cn/item/63bd18e1be43e0d30e6a566c.jpg)

可以发现，前短后长的方案更优。

扩展得到猜想，同一单词的所有子树中，大小更小的应在更前面。该结论是可递归的。

***

接下来对猜想进行证明。

假设现在已有一条链。我们只有把整条链连在一起，短单词放到长单词前面这一种方法。

然后新来了一个不属于这条链的节点，明显，因为节点不管放到哪里，其 $y$ 值不变，但会改变已有链的 $y$ 值，所以放到最前面最优。

又来了一个节点，和刚才新增的节点属于同一条链，一样，不管这个节点何去何从，其 $y$ 不变，但放在越前面，后面的节点的 $y$ 值增加得越多。

以此类推可得到结论，同一条链放到一起。短链放到长链前面也是比较好想的。假设有两条链，短链长度为 $a$，长链长度为 $b$，放置起点为 $l$，则前短后长和钱长后短的 y 之和分别为 $\dfrac{(l + l + a - 2) \times (a - 1) + (l + a + l + a + b - 2) \times (b - 1)} 2$ 和 $\dfrac{(l + l + b - 2) \times (b - 1) + (l + b + l + b + a - 2) \times (b - 1)} 2$（运用等差数列求和公式），解不等式可得前短后长一定更优。

接下来是从链扩展到树。那么我们想到了什么？树链剖分。

我们化用树剖思想，以最轻边为剖分条件，将树划分为有顺序的链，按照上述方式排列其顺序即可。 

此时我们记录下每个单词的直系父亲（即其最长前缀单词），在唯一序列中模拟计分操作，即可得到答案。

***

为了方便，可将所有入度为 $0$ 的点与一个虚点相连，将森林转化为树。

注意 `long long`。

```cpp
namespace XSC062 {
using namespace fastIO;
using str = std::string;
const int maxn = 1e6 + 5;
const int maxm = 1e6 + 5;
str s[maxn];
int T[maxm][26];
int kaz[maxn], siz[maxn]; // kaz 即为 kazuha(?) 表示单词在最终序列中所处的位置
std::vector<int> g[maxn];
int n, l, res, cnt = 1, ti;
int tot[maxm], fa[maxn], deg[maxn];
inline void Insert(int k) { 
	int f = 1, len = s[k].length();
	for(int i = 0; i < len; ++i) {
		if (!T[f][s[k][i] - 'a']) 
			T[f][s[k][i] - 'a'] = ++cnt;
		f = T[f][s[k][i]-'a'];
	}
	tot[f] = k;
	return;
}
inline void Search(int k) {
	int f = 1;
	int len = s[k].length();
	for (int i = 0; i < len; ++i) {
		f = T[f][s[k][i] - 'a'];
		if (tot[f]) {
			if (tot[f] != k)
				fa[k] = tot[f]; // 记录当前最长前缀
		}
	}
	return;
}
inline void add(int x, int y) {
	++deg[y];
	g[x].push_back(y);
	return;
}
void DFS1(int x) { // 提前计算每个子树的 size
	siz[x] = 1;
	for (auto i : g[x]) {
		DFS1(i);
		siz[x] += siz[i];
	}
	return;
}
void DFS2(int x) {
	kaz[x] = ti++;  // 时间戳即为单词位置
	std::sort(g[x].begin(), g[x].end(),
		[&](int x, int y) { return siz[x] < siz[y]; }); // 按子树 size 排序
	for (auto i : g[x])
		DFS2(i);
	return;
}
int main() {
	scanf("%lld", &n);
	for (int i = 1; i <= n; ++i) {
		std::cin >> s[i];
		std::reverse(s[i].begin(), s[i].end());  // 后缀转前缀
		Insert(i);
		res += i;
	}
	for (int i = 1; i <= n; ++i) {
		Search(i);
		if (fa[i])
			add(fa[i], i); // 建图
	}
	for (int i = 1; i <= n; ++i) {
		if (!deg[i]) // 建虚点方便操作
			add(n + 1, i), fa[i] = n + 1;
	}
	DFS1(n + 1), DFS2(n + 1);
	for (int i = 1; i <= n; ++i)
		res -= kaz[fa[i]]; // 处理 y 值
	print(res);
	return 0;
}
} // namespace XSC062
```

---

## 作者：Thosaka_Forest (赞：10)

这题目描述真是令人窒息。

3个条件的意思大概是这样：

(1).如果有单词作为现在正在填入的单词的后缀但并未填入，将花费n*n的代价。

(2).如果没有单词作为当前填入单词的后缀，代价为当前填入单词序号x

(3).如果所有作为该单词的后缀的单词之前都已经填入，那么代价为当前序号x-最后一个作为当前单词的后缀的单词的序号y。

读懂题以后这道题还是比较明显的贪心。第1个条件提示一定是先将所有作为后缀的单词填入，因为如果不这样填不管怎么样代价都小于n*n。

由于询问的是后缀，所以后缀相同其实等价于反串的前缀相同，所以倒着建立一个trie树。

这时问题转化为求一棵树的拓扑序，满足儿子与父亲的编号差的和最小，所以可以直接贪心来做，简单观察发现，对于某一刻，无论选哪个节点，总代价都会增大目前能扫到的第一个标记点的总量。

要使总代价最少，那么这次选的点一定要使以后增加的点最小.

所以记录一下每个点能看到的，以及这一个子树下分支总量，一定优先处理分支更小的子树。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pll;
const int MAXN=5e5+10;

long long n,siz,ans;
char s[MAXN];
struct Trie{
	int val;
	int son[26];
}tr[MAXN];
int tot[MAXN],sum[MAXN];
vector<int> idx[MAXN];

void insert(char a[]){          //建立trie树 
	int len=strlen(a);
	int last=0;
	for(int i=len-1;i>=0;--i){  //后缀 
		int x=a[i]-'a';
		if(!tr[last].son[x]){
			tr[last].son[x]=++siz;
		}
		last=tr[last].son[x];
	}
	tr[last].val=1;             //记录终止点 
}

void dfs(int u,int fa){
	if(tr[u].val)               //是一个终止点 
	  tot[fa]++,idx[fa].push_back(u),fa=u;
	for(int i=0;i<='z'-'a';++i){
		if(tr[u].son[i])
		  dfs(tr[u].son[i],fa);
	}
	sum[u]=tot[u];
	int size=idx[u].size();
	for(int i=0;i<size;++i){
		sum[u]+=sum[idx[u][i]];//记录子树信息 
	}
}

void bfs(){
	priority_queue<pll> q;
	q.push(make_pair(0,0));
	int now=1;
	while(!q.empty()){
		pair<int,int> u=q.top();
		q.pop();
		now=now+tot[u.second]-1;
		ans+=now;
		int size=idx[u.second].size();
		for(int i=0;i<size;++i){
			q.push(make_pair(-sum[idx[u.second][i]],idx[u.second][i]));//先找小的所以取相反数 
		}
	}
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%s",s);
		insert(s);
	}
	dfs(0,0);
	bfs();
	cout<<ans;
	return 0;
}
```

---

## 作者：kczno1 (赞：8)

我们将所有单词反转，之后建一个trie树，

利用trie树得到一个新树(所有点的爸爸对应的单词都是其前缀)。

那么问题即 求该树所有点的一个排列使得所有父子在排列中距离之和最小。

显然，任意子树的点在排列中是连续的，而且一个点访问儿子的顺序是其子树个数从小到大。

因为空间不够，我把一个点的儿子的子树个数放到一个公用数组里来排序，计算；

而实际搜索顺序并不是从小到大的。

```pascal
var
 n,o,i,now,top,len:longint;
 l:array[0..510000,'a'..'z'] of longint;
 s,f,t,hou,son:array[0..510000] of longint;
 b:array[0..510000] of boolean;
 a:ansistring;
 j:char;
 ans:qword;

procedure swap(var x,y:longint);
var t:longint;
begin
 t:=x;x:=y;y:=t;
end;

procedure sort(l,r: longint);
      var
         i,j,x: longint;
      begin
         i:=l;
         j:=r;
         x:=son[(l+r) >>1];
         repeat
           while son[i]<x do
            inc(i);
           while x<son[j] do
            dec(j);
           if not(i>j) then
             begin
                swap(son[i],son[j]);
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;


procedure dfs(x:longint);
var i:char;
begin
 if b[x] then
 begin
  hou[x]:=t[f[x]];t[f[x]]:=x;
     for i:='a' to 'z' do
     if l[x][i]>0 then
     begin
       f[l[x][i]]:=x;
       dfs(l[x][i]);
     end;
 end
 else
  for i:='a' to 'z' do
     if l[x][i]>0 then
     begin
       f[l[x][i]]:=f[x];
       dfs(l[x][i]);
     end;
end;

procedure try(x:longint);
var num,i:longint;
begin
  num:=0;i:=t[x];
  while i<>0 do
  begin
   inc(num);son[num]:=s[i];
   i:=hou[i];
  end;
  sort(1,num);

  s[x]:=1;
  for i:=1 to num do
  begin
   inc(ans, s[x] );
   inc(s[x],son[i]);
  end;

  i:=t[x];
  while i<>0 do
  begin
   try(i);
   i:=hou[i];
  end;
end;

begin
 assign(input,'1.in');reset(input);assign(output,'1.out');rewrite(output);
 readln(n);top:=1;
 for o:=1 to n do
 begin
  now:=1;
  readln(a);len:=length(a);
  for i:=len downto 1 do
  begin
   if l[now][a[i]]=0 then
   begin
    inc(top);l[now][a[i]]:=top;
   end;
   now:=l[now][a[i]];inc(s[now])
  end;
  b[now]:=true;
 end;

 f[1]:=1;
 dfs(1);
 try(1);

 writeln(ans);close(output);
end.

```

---

## 作者：key_rA9 (赞：8)

- ### 简洁题意
`(大佬请无视此部分)`  
  
当然是
~~[P3294](https://www.luogu.org/problemnew/show/P3294)~~  就怪~  
实际上把题面~~化简~~理解后,就是这样:  
```
当你填入第x个单词时:
1. 如果有给出的单词是它的后缀且还没填入,花费n×n;
2. 如果它没有后缀(单字母),花费x;
3. 如果它的所有后缀都已填入,设其最后一个被填入的后缀位置y,花费x-y。
```
没错,再看看原题面,就是这么个意思。  
让我们再看看,没有后缀的话,那么它在第3种情况下y为0,也就是说,第二个条件我们可以忽略掉,也就是说相当于出题人搞出了第二个没用的状态还进行了加工使它变得貌似很复杂来迷惑我,真的是······话说出题面的目的是什么(?)——增加理解题目的难度。~~(雾~~  
好吧我还是太~　了。

- ### 算法描述
第一种状况显然不划算,而第二种也说了在程序中相当于第三种,所以我们只剩下第三种规则,也就是尽量先把后缀填进去。  
那么既然是后缀,也就是将单词反过来建一颗字典树(常规操作),接着找答案时树上有很多不能构成单词的节点,会非常麻烦,于是我们建一棵以单词为节点的树,去除了许多不必要的虚点。  
然后如果一个词是几个词的后缀,而这几个词也可能是其他词的后缀,那么应该先填哪一个呢？  
分析一下,花费与最后一个填入的后缀有关,那么这个后缀的位置离当前位置越近越好,也就是应该有尽量少的单词夹在你们中间,所以我们应该选衍生出其他单词最少的那个。  
再树上来说,即找答案时子树最小的节点应优先遍历,dfs每找一个立刻填入,因为建的新树和排序已经满足贪心策略,所以直接模拟第三种情况的计算方法求得答案。
- ### ***CODE***
```cpp
	#include<cstdio>
	#include<cstring>
	#include<algorithm>
	#define N 510000
	#define ll long long
	using namespace std;
	int n,ip;//ip在dfs会用到,记录当前填第几个格
	int tot,ch[N][26];//trie
	bool v[N];//到这个节点是否是单词
	char s[N];//用于输入
	ll ans;//不开后果自负
	struct node {
		int y,next;//新树的边
	} a[100005];
	int len,last[100005];
	//int cnt,sum[N];新树节点数,每个节点子树大小
	bool cmp(int x,int y) {
		return ch[x][0]<ch[y][0];   //用于dfs找子树节点数少的孩子
	}
	inline void be(int x) { //build edge
		len++;
		a[len].y=len;//其实从点0开始多一条边就新建一个点,所以y就是边数
		a[len].next=last[x];
		last[x]=len;
	}
	inline void ins() {
		scanf("%s",s);
		int now=0,len=strlen(s);//trie树根节点是0
		/**/for(int i=len-1; i>=0; i--) { //!!!研究后缀要将单词反转!!!
			int c=s[i]-'a';//取出字母
			if(!ch[now][c])ch[now][c]=++tot;
			now=ch[now][c];//模版不说了
		}
		v[now]=1;//标记单词
	}
	void bt(int x,int now) { //x表示新树建到的编号
		//build (new)tree
		if(v[now])be(x),x=len;//如果这是一个单词就连一条边,同时现在就变成新节点去认孩子
		for(int c=0; c<26; c++)
			if(ch[now][c])bt(x,ch[now][c]);//x也可以理解成谁做这个孩子的父亲
	}
	void gs(int x) { //get sum
		ch[x][0]=1;//利用废弃的ch数组来节省并没有多少的空间
		for(int k=last[x]; k; k=a[k].next)
			gs(a[k].y),ch[x][0]+=ch[a[k].y][0];//当然就是孩子的和
	}
	int q[100005];//用于记录每个节点的儿子,在这里面排序
	void dfs(int x,int y) { //find ans
		ip++;
		ans+=ip-y;
		y=ip;//填到下一个格子,更新答案和③中的y
		int l=q[0];//l记录当前最后用到的位置(上一个dfs的r)
		for(int k=last[x]; k; k=a[k].next)q[++q[0]]=a[k].y;
		int r=q[0];//r记录在本dfs新增点后的位置
		stable_sort(q+l+1,q+r+1,cmp);//子树小的先遍历
		for(int i=l+1; i<=r; i++)dfs(q[i],y); //q[l+1~r]即是此次dfs要下去找的节点
		q[0]=l;//用完得还原
	}
	int main() {
		scanf("%d",&n);
		while(n--)ins();//建trie树
		bt(0,0);//新树以0为根,trie中0为根
		gs(0);//从根节点0开始计算
		dfs(0,1);//从根节点0开始找，填第一个格
		printf("%lld\n",ans);//要开long long...
		return 0;
	}
```
这题三个重要函数都是递归的,~~也许只有我这么菜才会觉得很难想。~~  
PS:我都以`0`为根节点,~~代码风格丑陋,不喜勿喷~~根节点为`1`也可,只是注意三个函数传进去的参数需要斟酌一下。。。~~(实际上全改`1`就好了)~~  
#### 如有错误,敬请指出。

---

## 作者：哲学家 (赞：6)

##    P3294【SCOI2016】背单词


### 【提示】

这道题大概是告诉我们，让我们用一堆n个单词安排顺序，如果当前位置为x，当前单词的后缀没在这堆单词出现过，代价就为x，这里的后缀是原意，但不算自己（不算本身的后缀【如果用集合来说就是真子集】），举个例子比如abc的后缀是bc和c但是它的后缀不包括它本身。

否则如果它的后缀(指在n个单词中的)在1~x-1全部出现了，代价为x减去最后一个后缀的位置y，如果没有全部出现，代价就为n^2，我们可以很显然的发现这个吃泡椒的数量是根据这个后缀来决定的，所以我们要尽量将所有的背当前的单词吃的泡椒数目变得最小时，吃泡椒的总数就会最小，那么我们就需要让背当前的单词时，吃的泡椒的类型是y-x类型的，因为只有这样才能满足最小。

我们可以发现按后缀建字典树，然后直接按子树大小贪心使其被每一个单词吃的泡椒数最少，然后直接一个贪心+字典树就可以过了这道题。

但是我一开始偷懒就直接在字典树上贪心走子树，这样是不行的，吃泡椒的数量的大小是错误的，我们得把关键点树给建出来然后再做，只有这样我们才能将这题A掉。

### 题解
直接来讲正确的解法：

首先可以发现一定要保证放每个点前它的后缀一定已经被放了（可以根据之前说的要使每个单词的吃的泡椒数最少【贪心的思路】来理解这个东西），所以我们可以根据这个把所有的串倒着插入我们建的字典树当中，然后答案一定是类似于这个样子的:一个串->若干以这个串为后缀的串。

那么按照怎样的插入顺序插入会更优呢?
可以发现先插入儿子较少的串答案会更优
那么我们就只需要把这棵字典树重构一下,去掉所有的无效节点,只留下代表某个点的结尾的节点
然后每次都是贪心的按照儿子从少到多的节点的顺序Dfs即可，这样就行了。

```

#include <bits/stdc++.h>//万能头文件
#define ll long long//宏定义long long
using namespace std;//运用命名空间std
const int N=6e5+10;//根据数据范围给出n的最大值
vector <int> Edge[N];//定义一个可变的数组
char s[N];
int ch[N][26],endro[N],tot;
int n,clock=-1,siz[N];
ll ans;
void ins()//初始化，将字母转换成数字存储
{
    scanf("%s",s+1);//下标从一开始
    int now=0,len=strlen(s+1);
    for(int i=len;i;i--)
    {
        int c=s[i]-'a';
        if(!ch[now][c]) ch[now][c]=++tot;
        now=ch[now][c];
    }
    endro[now]=1;
}
void dfs0(int now,int anc)
{
    if(endro[now]) Edge[anc].push_back(now),anc=now;
    for(int i=0;i<26;i++)
        if(ch[now][i])
            dfs0(ch[now][i],anc);
}
void dfs(int now)//按照儿子从少到多的节点的顺序的贪心的Dfs
{
    siz[now]=1;
    for(int i=0;i<Edge[now].size();i++)
        dfs(Edge[now][i]),siz[now]+=siz[Edge[now][i]];
}
bool cmp(int x,int y){return siz[x]<siz[y];}
void dfs(int now,int las)
{
    int tim=++clock;
    ans=ans+tim-las;
    std::sort(Edge[now].begin(),Edge[now].end(),cmp);
    for(int i=0;i<Edge[now].size();i++)
        dfs(Edge[now][i],tim);
}
int main()//主函数
{
    scanf("%d",&n);//n个单词
    for(int i=1;i<=n;i++) ins();
    dfs0(0,0);
    dfs(0);
    dfs(0,0);
    printf("%lld\n",ans);//输出吃泡椒的总数
    return 0;//结束程序
}
```



---

## 作者：Luckies (赞：5)

## 题意

给你 $n$ 个字符串，让你对其进行排列，使得按以下规则花费最少：

设当前字符串为 $s$，$x$ 为 $s$ 在答案排列中的位置。

1. 如果 $s$ 存在后缀且 $s$ 的后缀在 $s$ 之后，花费加 $n^2$。

2. 如果 $s$ 不存在后缀则花费加 $x$。 

3. 设 $y$ 为 $s$ 之前离其最近的是 $s$ 的后缀的字符串的位置，$s$ 存在后缀且 $s$ 的后缀在 $s$ 之前，则花费加 $x-y$。

## 解法

对于 1 条件，显然尽量不要满足，因为 1 条件的花费永远比 2、3 条件多。

对于 2 条件，可以视为 3 条件中 $y=0$，因此和 $3$ 条件合并。

所以可以有一个贪心策略，对于一个字符串 $s$，将它的若干后缀字符串放在 $s$ 之前。那么此时仅存在 3 条件。

题目需要维护后缀，那么可以考虑将字符串反转，变成前缀，于是也可以想到对于反转的字符串建立 Trie 树。

既然要满足贪心策略，那么在 Trie 中，每一个字符串结尾的结点要在它的祖先结点之后。Trie 树就可以维护排列中的先后关系。

3 条件的花费为 $x-y$，即排列中的距离，那么在 Trie 中，每一个字符串的结尾结点才需要考虑，因此考虑重构 Trie，将不是字符串结尾的结点删去。

考虑另一个贪心策略，由于 3 条件花费为 $x-y$，那么 $x$ 和 $y$ 的距离越近越好，所以最优策略中的 $x$ 和 $y$ 在重构树中一定是父子关系。

由于我们需要 $x-y$ 最小，所以我们尽可能地让 $x$ 和 $y$ 放一起，也就是遍历完父亲就遍历儿子。可以发现，这样的遍历顺序就是 dfs 序。

此时我们得到最优的遍历顺序为 dfs 序，对于一个结点 $x$，可以发现在 dfs 序下，它和父节点的距离为之前遍历过的兄弟结点的子树大小和，也就是花费，因此可以对每一个结点按子树大小排序，即可得到最优解。

### AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6 + 5;
int n, trie[N][27], cnt, last[N], siz[N], dfn, ans;
bool End[N];
vector<int> e[N];
void insert(string s)
{
    int x = 0;
    for(int _ = 0; _ < s.size(); _++)
    {
        char i = s[_];
        if(!trie[x][i - 'a'])
            trie[x][i - 'a'] = ++cnt;
        x = trie[x][i - 'a'];
    }
    End[x] = true;
    return;
}
void rebuild(int x)
{
    if(End[x] && x)
    {
        e[last[x]].push_back(x);
        last[x] = x;
    }
    for(auto y : trie[x])
    {
        if(!y)
            continue;
        last[y] = last[x];
        rebuild(y);
    }
    return;
}
void dfs(int x)
{
    siz[x] = 1;
    for(auto y : e[x])
    {
        dfs(y);
        siz[x] += siz[y];
    }
    sort(e[x].begin(), e[x].end(), [](int x, int y)
    {
        return siz[x] < siz[y];
    });
    return;
}
void dfs1(int x)
{
    int k = dfn;
    dfn++;
    for(auto y : e[x])
    {
        ans += dfn - k;
        dfs1(y);
    }
    return;
}
signed main()
{
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        string s;
        cin >> s;
        reverse(s.begin(), s.end());
        insert(s);
    }
    End[0] = true;
    rebuild(0), dfs(0), dfs1(0);
    cout << ans;
    return 0;
}
```

---

## 作者：zac2010 (赞：5)

### 题意简化

我们要填入 `n` 个单词。

1. 如果有单词作为当前单词的后缀但并未填入，将花费 `n*n` 的代价。
2. 如果单词中没有当前单词的后缀，代价为当前填入单词序号 `x` 。
3. 如果所有作为该单词的后缀的单词之前都已填入，那么代价等于当前编号 `x` 减去最后一个作为当前单词的后缀的单词的编号 `y` 。

求最小代价。

### 思路剖析

#### 大致步骤

对于后缀处理是不是很麻烦？我们考虑把单词翻转，用前缀处理（毕竟这样处理不会影响答案的正确性，只是更好处理了）。

所以我们在这里翻转所有字符串，后面说的所有字符串都是翻转后的字符串。

说到单词的前缀，除了 `KMP` 以外，就能想到字典树了，所以我们考虑用字典树来处理。

我们的根节点代表的就是空（ `0` 或 `1` ，按个人写字典树的习惯来）。下面连接的是所有长度为 `1` 的前缀，再下面就是长度为 `2` 的前缀……以此类推。所以我们先建立一颗字典树。

建立完字典树呢，我们要找到一个放入单词的顺序，所以我们考虑用一颗树来处理，而遍历顺序算答案中呢，我们只需要每个给定的单词的 **末尾节点** ，那样我们就可以在只有单词末尾节点的情况下还可以保证父节点都是子孙节点的前缀，所以这里就需要把所有的非末尾节点删除。在这我们就要把所有非末尾节点的第一个是末尾结点的祖宗指向它那些末尾结点的孩子们。

举个例子：

```cpp
                                                   (1)
                                                   / \
                                                  2   5
                                                 / \   \
                                               (3)  4  (6)
                                                     \
                                                     (7)
假设这棵树中，用括号括起来的是末尾结点，所以我们删的时候的步骤就是（假设我们用fa[i]来表示删完后i的父亲，原来fa[i]指向字典树中i的父亲）：
fa[3]=1;
fa[7]=1;
fa[6]=1;
删完后变成：
    												1
    											  / | \
    											 3  7  6
    									
```

但对于这样的操作我们该怎么处理呢？我们能发现，并查集就可以实现！！！

所以我们把所有是单词的末尾的节点的父亲指向 `find(fa[i])` ，建立所有都是末尾结点的一棵树。然后按照 `dfs` 的顺序算代价和。

所以大体的思应该是这样的：

1. 对于输入的字符串，建立一颗字典树
2. 去掉所有非单词的末尾的节点，建立新的树
3. 按子树的大小把所有子树从小到大排序
4. 按照 `dfs` 序计算代价

#### 算法证明

我们可以想，我们按照 `dfs` 序的话，顺序靠前面的那颗子树先被统计。我们假设那颗子树中有一个非子树根的节点 `x` ，它和当前子树后面一颗子树的根 `y` 应该那个先统计呢？答案显然是 `x` 先搜好。因为 `y` 在前面，那么按照这个顺序 `y` 与其孩子的距离每个孩子都会增加 `1` ，而所有子树的孩子与其父亲的距离都会增加，那么总代价将会增加很多。但是如果 `x` 在 `y` 前面，增加的无非就是根节点的代价是前面子树的大小，其它节点就是里根节点的距离，而且我们按照子树的大小排序的，所以可以保证最优。

而子树从小到大的证明呢？因为第 `i` 个根节点的贡献是前面所有树的 `size` 之和，为了是总和最小化，我们从小到大排序。

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=500010;
char x[N];
int n,cnt,bo[N],tot=1,trie[N][27],fa[N],id[N],son[N],num;
long long ans=0;
vector<int>g[N];
int find(int x){
	return fa[x]==x?x:fa[x]=find(fa[x]); 
}
void insert(char s[],int num){//字典树的必备函数
    int l=strlen(s),u=1;
    for(int i=l-1;i>=0;i--){
        int c=s[i]-'a';
        if(!trie[u][c])
			trie[u][c]=++tot;
        u=trie[u][c];
    }
    bo[u]=num;
}
void make_tree(int x){//建立一颗只有末尾节点的树
    for(int i=0;i<26;i++){
        int v=trie[x][i];
        if(v){
            if(!bo[v])
                fa[v]=find(x);
            else
                g[bo[find(x)]].push_back(bo[v]);
            make_tree(v);
        }
    }
}
int cmp(int x,int y){//按子树大小排序
    return son[x]<son[y];
}
void sonsum(int x){//算每颗子树的大小
    son[x]=1;
    for(int i=0;i<g[x].size();i++){
        int v=g[x][i];
        sonsum(v);
        son[x]+=son[v];
    }
    sort(g[x].begin(),g[x].end(),cmp);
}
void dfs(int x){//计算代价和
    id[x]=num++;
    for(int i=0;i<g[x].size();i++){
        int v=g[x][i];
        ans+=num-id[x];
        dfs(v);
    }
}
int main(){
	scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%s",x);
        insert(x,i);
    }
    for(int i=1;i<=tot;i++)
		fa[i]=i;
    make_tree(1);
	sonsum(0);
	dfs(0);
    printf("%lld",ans);
    return 0;
}
```



---

## 作者：Mcggvc (赞：2)

和其他题解的方法好像不是很一样。

首先算出每个串的 $hash$ 值，存到 $map$ 里，然后对于每个串 $S$ ，找到最长的串 $C$ ，使其满足 $C$ 是 $S$ 的后缀，然后连一条从 $C$ 到 $S$ 的边，若 $C$ 不存在，则连一条虚拟节点 $0$ 到 $S$ 的边。

这样便构成了一颗树，显然排序的时候每个节点要先于他的子节点，且易知优先排子树更小的节点得到的结果更优。

统计答案的时候，可以发现节点 $x$ 的贡献 $W(x) = (-1) \cdot pos(x) \cdot (son(x) - 1)$

其中 $ pos(x) $ 表示 $x$ 节点排完序之后的位置

$son(x)$ 表示 $x$ 节点直接相连的儿子的数量（与代码中的 $son[]$ 不同）

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>
#include <queue>
#include <map>
#include <unordered_map>
using namespace std;
typedef long long lld;
map <lld, int> mp; 
const int N = 100005;
const int M = 510005;
const lld p1 = 13331, mod = 1e12 + 7;
int n, pos = -1;
lld ans = 0;
int son[N];
vector <string> s;
vector <int> e[N];
lld f(string c) { //求hash值
	int len = c.length();
	lld tmp = 0;
	for(int i = len - 1; i >= 0; i--) {
		tmp = tmp * p1 % mod + (c[i] - 'a' + 1);
	}
	return tmp;
}
void dfs(int x) { //dfs找出以x节点为根的子树的节点数son[x]
	for(int i = 0; i < e[x].size(); i++) {
		int y = e[x][i];
		dfs(y);
		son[x] += son[y];
	}
	son[x]++;
}
struct par {
	int num, sons;
};
par make_p(int a, int b) {
	par e; e.num = a; e.sons = b;
	return e;
}
bool cmp(par a, par b) {
	return a.sons < b.sons;
}
 
void getans(int x) {
	if(son[x] == 1) { //到了叶节点，把当前的排位加上
		pos++; ans += pos; return ;
	}
	vector <par> tmp;
	for(int i = 0; i < e[x].size(); i++) {
		int y = e[x][i];
		tmp.push_back(make_p(y, son[y]));
	}
	sort(tmp.begin(), tmp.end(), cmp); //按照子树节点数量从小到大排序
	pos++;
	ans -= pos * (tmp.size() - 1); //若当前节点有不止一个子节点，则减去相应的值
	for(int i = 0; i < tmp.size(); i++) {
		getans(tmp[i].num);
	}
}
int main() {
	// freopen("data.in", "r",stdin);
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) {
		char ss[M]; cin >> ss;
		s.push_back(ss);
		mp[f(s[i - 1])] = i; //讲每个串的hash值存到map里
		
	}
	for(int i = 0; i < s.size(); i++) {
		int len = s[i].length(), fa = 0;
		lld tmp = 0;
		for(int j = len - 1; j >= 1; j--) {//找到当前串的最长后缀，即fa
			tmp = tmp * p1 % mod + (s[i][j] - 'a' + 1);
			if(mp[tmp]) fa = mp[tmp];
		}
		e[fa].push_back(i + 1); //建一条fa到当前串的边
	}
	s.clear(); mp.clear();
	dfs(0); getans(0);
	printf("%lld\n", ans);
	return 0;
}
```


---

## 作者：FBW2010 (赞：1)

[传送门](https://www.luogu.com.cn/problem/P3294)

# 题意

有 $n$ 个单词，现在要将他们排列。如果第 $x$ 个单词的后缀单词不全在他前面，那他的贡献为 $n \times n$，否则设他的后缀单词中最后一个的编号为 $y$，若没有单词 $y$ 就是 $0$，则代价为 $x-y$。

# 思路

首先，如果一个单词的其中一个后缀单词在他后面，那代价一定比其他情况都要高，所以我们要让每个单词的**后缀单词都在他前面**。

接下来考虑**贪心**。为了方便表示，我们设单词 $x$ 有 $size_x$ 个单词**以他为后缀**。先选一个没有后缀的单词，那下一个**选以这个单词为后缀的单词**一定是最优的。如果没这么选，那么会使总代价增加 $size_x$，这与先把这些单词选完的代价一样，不如就这么选下去。

但按什么顺序选第一个单词呢？显然应该是按 $size_x$ **从小到大**选，因为选一个单词多增加的贡献应为 $size_x$ 乘上其他所有的单词的数量。之后就与选第一个单词类似，直接递归下去即可。

对于求一个单词的后缀单词，我们可以先将所有单词翻转，就转化为了求前缀单词，直接**字典树**维护即可。不会字典树的看[这个](https://www.luogu.com.cn/problem/P8306)。

于是解法就很明显了。先把所有单词丢进字典树，再根据每个单词结尾的位置建一棵树，$size_x$ 就相当于每个子树的大小，然后 DFS 统计答案。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,ti,cnt=1,size[N];
long long ans;
char s[N];
vector<int> a[N]; //新的树 
struct node{
	int flag,ch[26];
}tree[N]; //字典树 
bool cmp(int x,int y){
	return size[x]<size[y];
}
void add(){ //加入字典树 
	int t=1,len=strlen(s);
	for(int i=0;i<len;i++){
		if(!tree[t].ch[s[i]-'a']){
			tree[t].ch[s[i]-'a']=++cnt;
		}
		t=tree[t].ch[s[i]-'a'];
	}
	tree[t].flag=1;
}
void DFS(int x,int t){ //建关于单词前缀关系的树 
	if(tree[x].flag){
		a[t].push_back(x);
		t=x;
		size[x]=1;
	}
	for(int i=0;i<26;i++){
		if(tree[x].ch[i]){
			DFS(tree[x].ch[i],t);
		}
	}
	if(tree[x].flag){
		for(int i=0;i<a[x].size();i++){
			size[x]+=size[a[x][i]]; //统计size 
		}
	}
}
void work(int x,int maxn){
	ans+=ti-maxn; //统计答案 
	maxn=ti;
	ti++;
	sort(a[x].begin(),a[x].end(),cmp); //按size从小到大选 
	for(int i=0;i<a[x].size();i++){
		work(a[x][i],maxn);
	}
}
int main(){
	scanf("%d\n",&n);
	for(int i=1;i<=n;i++){
		scanf("%s\n",s);
		reverse(s,s+strlen(s));
		add();
	}
	DFS(1,1);
	work(1,0);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：729hao (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P3294)

------------
## 思路
观察题目，显然有这么一个贪心思路：
> 对于任何单词 $s_i$，优先将其所有后缀单词填入表格。

所以第一步就出来了：找到每个单词 $s_i$ 的所有后缀单词。  
怎么找？[**Trie**](https://oi-wiki.org/string/trie/)。

**Trie** 可以查找一个字符串的前缀，所以，将题目中的所有单词倒序，所有后缀单词就变成了前缀单词。

然后，我们可以建一棵树 $V$，每个节点 $u$ 对应一个单词 $s_u$，每个节点的父节点代表**整个单词表中此单词的长度最长的前缀单词**。（这里的前缀不包括自身，“单词”指倒序处理后的单词。）

上面父节点的定义很长，稍微断一下句：
> 整个单词表中 / 此单词的 / 长度最长的前缀单词。

而那些单词表内没有前缀单词的单词，则将父节点设为节点 $0$。

## 建树 $V$
建树 $V$ 的操作不难，首先将单词按长度由小到大排序，依次插入字典树，过程中顺便找到最长前缀即可。

## 贪心
建树完成后，发现 $V$ 有两个性质：
1. 对于以任何节点 $u$ 为根节点的子树中的任意一个节点 $v$，$s_u$ 为 $s_v$ 的前缀。

2. 对于任意两个不在同一链上的两个节点 $u$、$v$，$s_u$ 不为 $s_v$ 的前缀，$s_v$ 也不为 $s_u$ 的前缀。

回顾贪心思路：**对于任何单词 $s_i$，优先将其所有后缀（倒序处理后为前缀）单词填入表格。**

所以，对于任意一个单词 $s_u$，应先将 $u$ 节点的所有祖先对应的单词放入。

于是我们会惊奇地发现：这不就是对树 $V$ 进行 dfs 吗？  
想到这里，第二步也就出来了：对树 $V$ 进行 dfs，搜索的顺序就是放入单词的顺序。

## dfs
问题来了，如果一个节点 $u$ 有多个子节点，应该先遍历哪个子节点？

因为题目中说：
> 当它的所有后缀都被填入表内的情况下，如果 $1,\dots,x-1$ 的位置上存在是它后缀的单词，所有是它后缀的单词中，序号最大为 $y$，那么你只要吃 $x-y$ 颗泡椒就能把它记住。

再次贪心，对于任意一个倒序后的单词，它的前缀单词离它越近越好；而每放入一个单词，则先放入所有以它为前缀的单词。

而离一个单词最近的前缀单词是它对应树节点的父亲节点，所以贪心思路变为**对于任意一个倒序后的单词，它的父亲单词离它越近越好**。

所以对于有多个子节点的节点，这些子节点离它的距离和应该尽量小。

先说结论：**优先遍历子树大小更小的子节点**。

稍微抽象一点，把放入 $k$ 子节点看作有 $k$ 个人排队打水，每个子节点的大小是每个人打水的时间，要求距离和最小就是要求所有人的总等待时间最小。

就这样，这个问题就被我们转化为了 [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)。（说实话，上面这个思路是很绕的。）

最后，求出结果即可。

## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5;
int T,n,q,pt,fa[N+5],siz[N+5];
long long ans;
string s[N+5];
string st[N+5];
vector<int>v[N+5];
bool cmp_s(string p,string q){
	return p.size()<q.size();
}
bool cmp_v(int p,int q){
	return siz[p]<siz[q];
}
struct tree{
	int h[26];
	int mark;//mark表示以这个点结尾有一个编号为mark的单词 
}Tree[510005];
void Init(int id){
	Tree[id].mark=0;
	for(int i=0;i<26;i++){
		Tree[id].h[i]=0;
	}
}
void Insert(string t,int ID){
	int siz=t.size();
	int rt=0,id;
	for(int i=0;i<siz;i++){
		id=t[i]-'a';
		if(Tree[rt].h[id]){
			rt=Tree[rt].h[id];
			if(Tree[rt].mark){
				fa[ID]=Tree[rt].mark;
			}
		}
		else{
			Tree[rt].h[id]=++pt;
			rt=pt;
		}
	}
	Tree[rt].mark=ID;
	v[fa[ID]].push_back(ID);//建树 
}
void dfs(int rt){//dfs找子树大小 
	siz[rt]=1;
	for(int i=0;i<v[rt].size();i++){
		dfs(v[rt][i]);
		siz[rt]+=siz[v[rt][i]];
	}
}
void dfs2(int rt){//dfs求答案 
	if(v[rt].size()==0)return;
	sort(v[rt].begin(),v[rt].end(),cmp_v);
	long long add=1ll;
	for(int i=0;i<v[rt].size();i++){
		dfs2(v[rt][i]);
		ans+=add;
		add+=siz[v[rt][i]]*1ll;
	}
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>st[i];
		for(int j=st[i].size()-1;j>=0;j--){//倒序处理 
			s[i]+=st[i][j];
		}
	}
//	for(int i=1;i<=n;i++){
//		cout<<s[i]<<"\n";
//	}
	sort(s+1,s+n+1,cmp_s); 
	for(int i=1;i<=n;i++){
		Insert(s[i],i);
	}
	dfs(0);
	dfs2(0);
	cout<<ans;
	return 0;
}

```

---

## 作者：FDsama (赞：1)

## 观前须知  
本题解使用 **[CC BY-NC-SA 4.0 许可](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)**。  
同步发布于 **Luogu** 题解区。  
更好的观看体验 **[请点这里](https://www.cnblogs.com/Sugar-Cube/p/18113015)**。  

<big>[笔者的博客主页](https://www.cnblogs.com/Sugar-Cube)</big>

## 正文

<big>[Luogu P3294 【SCOI2016】背单词](https://www.luogu.com.cn/problem/P3294)</big>  

笔者在刷题的时候看到了这道好题。  
花了四十分钟切掉以后，看了一下题解。   
发现自己的想法不太一样。  
所以想做一篇适合我这样的蒟蒻看的题解。    
那么，我们开始吧。    

首先：  

### 题意理解  

（笔者认为本文最难的一个部分）

给你 $n$ 个字符串。    
要求你找一种这 $n$ 个字符串的排列使得总花费最小。

规则一：若一个字符串 $a$ 有一个字符串 $b$ 为 $a$ 的后缀，   
（这里的后缀在 $n$ 个字符串中**出现过**，且不为该串本身，下文同）。  
且 $b$ 排在 $a$，则花费增加 $n^2$。

规则二：若 $a$ 没有后缀，则花费增加 $a$ 的排名（即 $x$ ）。 

规则三：若一个字符串 $a$ 的所有后缀都排在 $a$ 前，  
则花费增加 $a$ 到最近一个 $a$ 的后缀 $b$ 的距离（即 $x-y$ ）。　　  

那么来**简化题意**：  
首先，发现原题中的规则二就是规则三的**特例**，所以不需要额外考虑。  
然后，可以发现规则一增加的 $n^2$ 实在太多了（每个规则二最多也只能增加 $n$ 的花费）。  
所以不能违反规则一。  
即要保证所有字符串的后缀一定排在这个字符串的前面。     
（一定存在不违反规则一的方案，按照字符串长度从小到大排序就是一种）。　　   

那么题意已经变为了：  
在不违反规则一的情况下，  
使规则三的花费和最小。  

### 建模  
发现不能违反规则一后，    
规则三中的**最近一个后缀**变为了**长度最大的后缀**。  
发现每个字符串要么有唯一的一个长度最大的后缀，要么没有后缀。  
这和**树**的结构类似！  
那么我们可以建立一棵树，一个节点的父亲就是它的长度最大的后缀。  
（也就是 SAM 中的后缀树）。  
对于没有后缀的点，我们建立一个虚根（代码中为0号点），作为它们的父亲。  
（这里的虚根可以理解为是一个空串，因为空串是每一个字符串的后缀）。  

下面给出了一棵后缀树方便大家理解：  
> a ab ba aab aba ababa bbaab bbbbba  
![后缀树](https://www.z4请更换图床a.net/images/2024/04/03/image-3.png)

建好这棵树后，我们就可以开始**贪心**了。  

### 贪心  

先直接说贪心策略：  
在后缀树上按照 dfs 序选点，  
且每个节点先走子树小的。  

（接下来的证明可以感性理解，建议边想边画图）
> 首先证明 dfs 序选点是正确的：  
> 对于根节点，它的若干个子节点有若干棵子树。  
> 这里我们考虑其中任意两棵：    
> 我们只需证明，我们要先选完一棵子树，再选择另一棵子树较优。    
> 不妨设先选的子树的树根为 $x$，后选的子树的树根为 $y$。    
> 首先考虑把 $y$ 提前到 $x$ 的子树选完前。  
> 设 $y$ 提前了 $a$ 个位置。  
> 对于 $y$ 子树内的第一个子节点，花费增加了 $a$。   
> 对于插入 $y$ 后的第一个节点，花费增加了 $1$。  
> 其余节点花费不变。   
> 继续把 $y$ 的子树内的节点提前，花费不变。  
> 所以对于根来说，选完一棵子树后再选另一棵是最优的。    
> 递归下去可以证明dfs序选点是最优的。  

> 接下来证明要先走子树小的：  
> 对于一个节点，考虑它的每一个孩子。  
> 发现可以递归处理每一个孩子的子树内的节点，这样只需要考虑每个子树的根节点，  
> 也就是它的每一个孩子，到它本身的距离。    
> 根据上面的结论可得，每个孩子到这个节点的距离就是在遍历到这个孩子前已经走过的节点数，  
> 那么为了距离和最小，显然要已经走过的节点数尽量小，  
> 所以子树小的优先选是最优的。    

好的，那么我们的答案就可以由贪心策略算出来了。  
欸？你问我是不是少了些什么？  
好吧，  
最后一部分：  

### 建树  
为了建树，我们只需要求出每个节点的父节点，即每个字符串的最长后缀。  
我们先根据字符串长度从小到大排序。  
那么每个字符串的后缀都在这个字符串前面了。  
但是后缀不好做，  
所以我们把每个字符串都**倒过来**变成前缀。  
我们把每个字符串依次**倒叙**插入到 **Trie 树** 中。  
并在每个字符串的终止结点记录编号。  
我们可以惊喜地发现：  
对于一个字符串的最长后缀（这里已经变为前缀了），  
就是在这个字符串在 Trie 树 上的对应路径中，  
深度最大的终止节点。  
那么我们就能很容易地求出每个节点的父亲，  
那么就可以建树了。  
（这块讲的比较抽象，建议配着代码食用，或自己 think 一下）。  

一些小细节：  
用 vector 存树方便 sort。  
按照字符串长度排好的顺序其实是后缀树的拓扑逆序，可以直接倒序枚举更新 sz。  
因为字符串长度不确定所以要用 string，不能用 scanf 和 char 数组了（悲）。 

这份代码最短用时 223ms，拿了个次优解直接开润~。

```c++
#include<bits/stdc++.h>

using namespace std;

static constexpr int AwA = 1e5 + 10;
static constexpr int PwP = 6e5 + 10;

int n;
//因为这道题每个字符串长度不确定，所以我只能抛弃我的char数组了（悲）
string s[AwA];
//记录每个节点算出来的父亲
int fa[AwA];
//字典树，id[u]!=0时记录该节点对应的字符串编号
int ch[PwP][26], id[PwP], tot = 1;

vector<int> tr[AwA];
int sz[AwA];
long long ans;

//贪心选点
void Dfs(int u) {
    int cur = 1;
    for (int v: tr[u]) {
        Dfs(v);
        ans += cur;
        cur += sz[v];
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for (int i = 1; i <= n; i++) cin >> s[i];
    //根据字符串长度排序
    sort(s + 1, s + n + 1, [](auto &s1, auto &s2) { return s1.size() < s2.size(); });

    int u, p;
    for (int i = 1; i <= n; i++) {
        //如果路径上没有终止节点，即没有后缀，则父亲为虚根0
        fa[i]=0;
        u = 1;
        //倒叙枚举，变后缀为前缀
        for (auto k = s[i].rbegin(); k != s[i].rend(); k++) {
            p = *k - 'a';
            if (!ch[u][p]) ch[u][p] = ++tot;
            u = ch[u][p];
            //遇到终止节点更新父亲
            if (id[u]) fa[i] = id[u];
        }
        //记录终止节点
        id[u] = i;
    }

    //因为父亲串的长度一定小于儿子，所以根据字符串长度排序后为拓扑逆序
    for (int i = n; i; i--) sz[i]++, sz[fa[i]] += sz[i];
    //建树
    for (int i = 1; i <= n; i++) tr[fa[i]].push_back(i);
    //按子树大小排序，方便贪心选择
    //注意0节点也要排序
    auto cmp = [&](int i, int j) { return sz[i] < sz[j]; };
    for (int i = 0; i <= n; i++) sort(tr[i].begin(), tr[i].end(), cmp);
    Dfs(0);
    printf("%lld\n", ans);
    return 0;
}
```

希望这篇题解能帮助你更好地理解这道很好的贪心题。  
完结撒花！~

---

## 作者：LCuter (赞：1)

一个串肯定得在它的后缀都被填入后再填入，我们建出这些串的反串的 Trie，现在得到一棵树形结构，其上有若干个关键点，要求给这些关键点赋权（$[n]$ 的全排列），满足对于任意关键点的权小于其子树内的关键点的权，然后最小化题目里求的那个东西。

由于我们仅需考察关键点，我们直接建一棵新树，新树的节点都是原来的 Trie 上的关键点以及 Trie 的根，每个节点的父亲是它在 Trie 上离他最近的一个祖先关键点。

理性分析一下，我们发现我们一定是按某个 dfs 序给这些点定权，换句话说就是一个子树内的权一定是一段连续的取值。

设 $u$ 子树大小为 $s(u)$，$f(u)$ 表示仅考虑 $u$ 的子树时，用 $[s(u)]$ 的全排列给 $u$ 的子树内的点赋权得到的最小答案。将权的值域从 $[1,s(u)]$ 转到到 $[1+\Delta,s(u)+\Delta]$ 的过程实际上就是给 $f(u)$ 加上 $\Delta$，因为子树内的点除了 $u$ 都是 $?-?$ 的形式，两边同加 $\Delta$ 后值不变。

现在来考虑转移，除去点 $u$ 的贡献以及让儿子的赋权偏移和将 $v$ 接在 $u$ 后减去 $u$ 的权 $1$，接下来实际上是考虑如何排列 $u$ 的儿子，当我们将某个儿子 $v$ 填在第 $k$ 位时，它会让后面的儿子的赋权偏移 $s(v)$，也就是产生额外的贡献 $s(v)\bigg{(}|son(u)|-k\bigg{)}$。由于无论如何排列，$f(v)$ 总是不变的，我们只需最小化额外的贡献，这是一个经典的贪心问题，我们让 $s(v)$ 小的尽量靠前即可。

正常计算后，取根的 $f$ 减 $1$ 即可。

时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define pb push_back
#define mp make_pair
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;
inline void read(int& x){
    static char c;
    while(!isdigit(c=getchar())); x=c^48;
    while(isdigit(c=getchar()))x=(x*10)+(c^48);
}
inline void read(ll& x){
    static char c;
    while(!isdigit(c=getchar())); x=c^48;
    while(isdigit(c=getchar()))x=(x*10)+(c^48);
}

const int N=6e5+10,M=1e5+10;

int n;
char str[N];
namespace Trie{
    int tot;
    struct Tree{int ed,ch[26];}t[N];
    inline void Init(){tot=1;}
    inline void Insert(char *str){
        int now=1,len=strlen(str);
        for(int i=len-1;~i;--i){
            if(!t[now].ch[str[i]-'a']) t[now].ch[str[i]-'a']=++tot;
            now=t[now].ch[str[i]-'a'];
        }
        t[now].ed=1;
    }
}

using namespace Trie;

int cnt=1;
vector<int> Edge[M];

void dfs(int now,int top){
    if(t[now].ed) Edge[top].pb(++cnt),top=cnt;
    for(int c=0;c<26;++c)
        if(t[now].ch[c]) dfs(t[now].ch[c],top);
}

int siz[M];
ll F[M];
void PreCalc(int now){
    siz[now]=1;
    for(int v:Edge[now]) PreCalc(v),siz[now]+=siz[v];
    sort(Edge[now].begin(),Edge[now].end(),[](const int &lhs,const int &rhs)->bool{return siz[lhs]<siz[rhs];});
}
void Calc(int now){
    int deg=Edge[now].size();
    F[now]=1;
    for(int i=0;i<deg;++i) Calc(Edge[now][i]),F[now]+=F[Edge[now][i]]+1ll*siz[Edge[now][i]]*(deg-i-1);
}

void Work(){
    read(n),Init();
    for(int i=1;i<=n;++i) scanf("%s",str),Insert(str);
    dfs(1,1),PreCalc(1),Calc(1);
    printf("%lld\n",F[1]-1);
}

int main(){Work();}

```

---

## 作者：Celtic (赞：1)


- 后缀问题不好处理，我们把它转化为前缀问题，用字典树解决问题

- 容易想到，一个串的后缀要先于它插入

- 对于一个串和其若干后缀串，容易想到，我们要先插入后缀串

- 然后递归进入$size$最小的子串

- 在建$Trie$时给所有串的结尾和$Trie$树的根节点标号，表示新树中点的编号

- 然后遍历$Trie$树，如果一个节点的子节点没有被标号，就把它并入当前节点的集合；

- 否则把这个子节点作为当前节点所在集合的根的儿子（就是连一条边）

- 最后按$dfs$序统计答案即可。

代码

```cpp
#include<bits/stdc++.h>
#define eps 1e-7
#define re register
#define N 510101
#define MAX 2001
#define PI 3.1415927
using namespace std;
typedef unsigned long long ll;
typedef double db;
inline void read(re ll &ret)
{
    ret=0;re ll pd=0;re char c=getchar();
    while(!isdigit(c)){pd|=c=='-';c=getchar();}
    while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c^48);c=getchar();}
    ret=pd?-ret:ret;
}
ll n,f[N],trie[N][26],tot,fa[N],siz[N],ans,cnt,dfn[N];
char s[N];
inline void insert(re ll pos)
{
	re ll p=0,len=strlen(s+1);
	for(re int i=len;i;i--)
	{
		re ll c=s[i]-'a';
		if(!trie[p][c])
			trie[p][c]=++tot;
		p=trie[p][c];
	}
	f[p]=pos;
	return;
}
vector<ll>v[N];
inline ll find(re ll pos)
{
	return fa[pos]==pos?pos:fa[pos]=find(fa[pos]);
}
inline void build(re ll pos)
{
	for(re int i=0;i<26;i++)
	{
		if(trie[pos][i])
		{
			if(!f[trie[pos][i]])
				fa[trie[pos][i]]=find(pos);
			else
				v[f[find(pos)]].push_back(f[trie[pos][i]]);
			build(trie[pos][i]);
		}
	}
	return;
}
inline bool cmp(re ll x,re ll y)
{
	return siz[x]<siz[y];
}
inline void get_size(re ll pos)
{
	siz[pos]=1;
	for(re int i=0;i<v[pos].size();i++)
	{
		re ll ver=v[pos][i];
		get_size(ver);
		siz[pos]+=siz[ver];
	}
	sort(v[pos].begin(),v[pos].end(),cmp);
	return;
}
inline void dfs(re ll pos)
{
	dfn[pos]=cnt++;
	for(re int i=0;i<v[pos].size();i++)
	{
		re ll ver=v[pos][i];
		ans+=cnt-dfn[pos];
		dfs(ver);
	}
	return;
}
int main()
{
	read(n);
	for(re int i=1;i<=n;i++)
	{
		scanf("%s",s+1);
		insert(i);
	}
	for(re int i=1;i<=tot;i++)
		fa[i]=i;
	build(0);
	get_size(0);
	dfs(0);
	printf("%lld\n",ans);
	exit(0);
}
```


---

## 作者：YHASDY (赞：1)

~~阅读理解题~~题意解释可以看[这位大佬的博客](https://www.luogu.org/blog/Tian-Xing/solution-p3294)（应该一楼就是）。

　　发现求后缀与倒序求前缀是等价的，而找前缀自然就想到了trie树。将所有字符串翻转后再建入trie树中，再对每一个字符串翻转后从trie树中找前缀，就能找到一个字符串的所有后缀了。

　　由第三种情况知我们要想最小化总代价，则最小化一个字符串与最靠近它的后缀间的距离应该也是一个要考虑的因素。其实一个串最近的后缀其实一定是它的所有后缀中长度最大的，因为它的后缀中长度短的也一定是长度大的后缀，并且还要避免第一种情况的出现（即序列在一个字符串后面的串中不能有这个字符串的后缀）。故我们只要知道每个字符串最长的后缀就好。若一个串是另一个串的后缀，则可以从这个串向另一个串连一条有向边，则最终会形成一个森林。

　　这时避免了第一种情况后，还有两种情况。我们做了这么多题，知道一种情况总应该比多种情况好做。故考虑将两种情况转化为一种。发现如果我们在所有题目给出的字符串的基础上再加入一个处于序列第0个位置的空串，那么第二种情况也就转化为了第三种情况，并且对答案没有影响。这种转化对于当前的森林，只要再建个标号为0的空串节点连向所有树的根就好了。

　　此时问题就转化为：给树的节点编号，要求父亲节点的序号比儿子节点小，且根节点的序号为0，并使得儿子节点的编号减父亲节点编号的差的和最小，求最小的和。考虑怎么选点编号。~~作者一开始也懵的一逼于是看了看[这位大佬博客](https://www.luogu.org/blog/Tian-Xing/solution-p3294)关于选法的证明部分（“考虑建出……Q.E.D”）终于明白~~如果选到了一个点，就要一口气把它的子树都选了，并且优先选子树大小最小的儿子。dfs就搞定了呀。至于对某个点的儿子从子树大小小的往大的选，可以用堆维护。

具体实现请看代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>

#define max(a,b) ((a)>(b)?(a):(b))

using namespace std;

const int N=100005,LEN=510005;

int tree[510005][26],cnt,n,l,dfs;
int ed[LEN],in[N],lst[N],to[N],nxt[N],ecnt,dfn[N];

long long siz[N],ans;

string word[N];

char ch;

inline int read()
{
	int x=0;
	ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x;
}

inline void getstring(string &a)
{
	a="";
	ch=getchar();
	while(ch<'a'||ch>'z')
		ch=getchar();
	while(ch>='a'&&ch<='z')
		a+=ch,ch=getchar();
}

inline void insert(const string &a,int j)
{
	l=a.length();
	int now=0,num;
	for(int i=l-1;i>=0;--i)//要将字符串倒序插入trie树中 
	{
		num=a[i]-'a';
		if(!tree[now][num])
			tree[now][num]=++cnt;
		now=tree[now][num];
	}
	ed[now]=j;
}

inline void addedge(int u,int v)
{
	nxt[++ecnt]=lst[u];
	lst[u]=ecnt;
	to[ecnt]=v;
}

inline int fin(const string &a)
{
	int now=0,num,ret=-1;
	l=a.length();
	for(int i=l-1;i>=0;--i)//查后缀就是倒序查前缀 
	{
		num=a[i]-'a';
		if(!tree[now][num])
			return ret;
		now=tree[now][num];
		if(ed[now]&&i)
			ret=ed[now];
	}
	return ret;
}

void dfssiz(int u)
{
	siz[u]=1;
	for(int e=lst[u];e;e=nxt[e])
	{
		dfssiz(to[e]);
		siz[u]+=siz[to[e]];
	}
}

struct node{
	int lar,ord;
}head;

inline bool operator < (const node &a,const node &b)
{
	return a.lar>b.lar;//大根堆变小根堆 
}

void dfsans(int u)
{
	priority_queue<node>hep;
	for(int e=lst[u];e;e=nxt[e])
	{
		hep.push((node){siz[to[e]],to[e]});	
	}
	while(!hep.empty())
	{
		head=hep.top();
		hep.pop();
		dfn[head.ord]=++dfs;//编号过程 
		ans+=dfn[head.ord]-dfn[u];
		dfsans(head.ord);
	}
}

int main()
{
	n=read();
	for(int i=1;i<=n;++i)
	{
		getstring(word[i]);//字符串的读入优化 
		insert(word[i],i);
	}
	int u;
	for(int i=1;i<=n;++i)
	{
		u=fin(word[i]);
		if(u!=-1)
		{
			addedge(u,i);
			in[i]++;
		}
	}
	for(int i=1;i<=n;++i)
		if(!in[i])//没有入度的点就是森林中树的根 
			addedge(0,i);
	dfssiz(0);//求一下每个点的子树大小。 
	dfsans(0);//统计答案。 
	printf("%lld",ans);
	return 0;
}
```
文章同步发表于[博客园](https://www.cnblogs.com/InductiveSorting-QYF/p/11808756.html)。

（写了这么多，应该能懂了吧~）

（懂了的话请留个赞，让更多人看到；不懂的话？问就好了~）

---

## 作者：AIskeleton (赞：0)

trie 树好题，题面差评。

### 题意和思路

> [P3294 [SCOI2016]背单词](https://www.luogu.com.cn/problem/P3294)
给定 $n$ 个字符串，要求对其进行排序，使得总贡献最小。
假设插入某个排序后编号为 $x$ 的字符串 $s$，产生的贡献规则为：
> - 如果在 $s$ 后的字符串中有 $s$ 的后缀，贡献为 $n^2$。
> - 如果在 $s$ 前的字符串中有 $s$ 的后缀，且 $s$ 后无 $s$ 的后缀，则贡献为 $x-y$（$y$ 是上一个是 $s$ 的后缀的字符串排序后的编号）。
> - 如果 $s$ 无后缀（单个字符），则贡献为 $x$。


对于规则 3，其实可以看出其实就是规则 2 中 $y=0$ 的特殊情况。

因为无论如何，$x-y$ 必然远小于 $n^2$，所以贪心的思路很简单，就是将每个字符串的后缀都放到其**之前**的前提下，使得**最后一个**此字符串的后缀与字符串之间的距离最小即可。

### 做法

> 将所有字符串翻转，建立 trie 树，并在每个字符串的末尾编号。

因为将所有字符串翻转就能把后缀转变为前缀，从而便于用 trie 树处理前缀问题。

> 对所有编号的节点建重构树。
遍历原树上每个节点，分情况进行不同的操作，采用**并查集**判是否属同一集合。
> 1. 如果某个节点的某个子节点没有被编号，就将其与当前节点并查集合并。
> 2. 否则把子节点作为一个新的节点，与当前节点的集合连一条边。

之前编号是为了之后跑出重构树，原先树中**没有编号的点**与后续操作无关，只需保留根节点和每个字符串的末尾的节点即可。

建重构树的原因是，要统计每个子树的关键节点个数。

> 统计重构树的每个节点的**子树大小**后，以此为关键字排序。

比较重构树的每个节点子树的关键节点个数的原因是对于某个节点，其贡献是**其前面所有树的节点个数之和**，所以要对每个节点的所有子树所含关键节点数为关键字排序。

> 最后按照题目给出的规则统计和即可。

记得最后统计答案的变量要开 long long。

### 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;const int N=5e5+1e4;
int n,len[N],size[N],id[N],c,u,cnt,tot,t[N][30],flag[N],f[N],v,ans;string s[N];
vector <int> e[N];int cz(int x){return x==f[x]?x:f[x]=cz(f[x]);}
int R(){
    int x=0,f=0; char ch=getchar();while(!isdigit(ch)) f|=(ch==45),ch=getchar();
    while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48),ch=getchar();return f?-x:x;
}void W(int x){if(x>9)W(x/10);putchar(x%10+'0');}bool cmp(int x,int y){return size[x]<size[y];}
void ins(int x){u=0;for(int i=len[x]-1;i>=0;i--){c=s[x][i]-'a';if(!t[u][c])t[u][c]=++tot;u=t[u][c];}flag[u]=x;}
void pre(int x){for(int i=0;i<26;i++)if(v=t[x][i]){if(!flag[v])f[v]=cz(x);else e[flag[cz(x)]].push_back(flag[v]);pre(v);}}
void dfs(int x){size[x]=1;for(int i=0;i<e[x].size();i++){dfs(e[x][i]);size[x]+=size[e[x][i]];}sort(e[x].begin(),e[x].end(),cmp);}
void ask(int x){id[x]=cnt++;for(int i=0;i<e[x].size();i++){ans+=cnt-id[x];ask(e[x][i]);}}
signed main(){
    n=R();for(int i=1;i<=n;i++)cin>>s[i],len[i]=s[i].length();for(int i=1;i<=n;i++)ins(i);
    for(int i=1;i<=tot;i++)f[i]=i;pre(0);dfs(0);ask(0);cout<<ans<<endl;return 0;
}
```

---


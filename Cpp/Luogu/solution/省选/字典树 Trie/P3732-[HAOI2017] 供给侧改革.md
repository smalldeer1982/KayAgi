# [HAOI2017] 供给侧改革

## 题目描述

你调查了某个产业近来 $n$ 个时期的供求关系平衡情况，每个时期的情况都用 $0$ 或 $1$ 中的一个数字来表示。于是这就是—个长度为 $n$ 的 $\texttt{01}$ 字符串 $S$。为了更好的了解这一些数据，你需要解决一些询问，我们令 $\text{data}(L,R)$ 表示：在字符串 $S$ 中，起始位置在 $[L,R]$ 之间的这些后缀之中，具有最长公共前缀的两个后缀的最长公共前缀的长度。

对于每一个询问 $L,R$，求：

$$ans = \sum_{L \leqslant i < R} \text{data}(i,R)$$

数据范围保证，串 $S$ 中的每一位都是在 $0$ 和 $1$ 之间随机产生的。

## 说明/提示

【数据规模与约定】

|数据点|$n$ 的规模|$Q$ 的规模|
|:-:|:-:|:-:|
|$1,2$|$\leqslant 20$|$\leqslant 20$|
|$3,4$|$\leqslant 100$|$\leqslant 100$|
|$5,6$|$\leqslant 5 \times 10^3$|$\leqslant 5 \times 10^3$|
|$7,8,9,10$|$\leqslant 10^5$|$\leqslant 10^5$|



对于所有的数据保证：$n \leqslant 10^5$，$Q \leqslant 10^5$，$1 \leqslant L < R \leqslant n$，$\texttt{01}$ 串随机生成。

## 样例 #1

### 输入

```
6 3
010110
2 5
1 6
1 2```

### 输出

```
4
6
0```

# 题解

## 作者：Pine (赞：14)

# trie树

$\qquad$**因为01串是随机的，所以lcp的长度不会太长，~~据说有个公式，蒟蒻表示不会~~，所以我们猜测lcp长度都不超过40，这样我们就将每一个后缀的前40个位置插入到trie树中即可。**

$\qquad$**从左到右将后缀的前40位插入字典树，字典树路径上存下最后一次访问该点的是以哪一个位置开始后缀，第二次访问这个深度为dep节点的时候就表示当前后缀与之前的一个后缀的$lcp\ge dep$，维护一下这40个值就可以了，查询的时候，直接访问这40个值。**

# 代码
```
#include <bits/stdc++.h>
#define R register
#define eps 1e-12
#define INF (1<<30)
#define LL long long
#define LINF (1ll<<60)
#define MM(x, y) memset(x, y, sizeof x)
#define Fo(i, x, y) for(R int i=x; i<=y; ++i)
#define Ro(i, x, y) for(R int i=x; i>=y; --i)
using namespace std;
template<typename T> inline T Max(R T x, R T y) {return x > y ? x : y;}
template<typename T> inline T Min(R T x, R T y) {return x < y ? x : y;}
template<typename T> inline void in(R T &x)
{
	static int ch; static bool flag;
	for(flag=false, ch=getchar(); ch<'0'||ch>'9'; ch=getchar()) flag |= ch=='-';
	for(x=0; ch>='0'&&ch<='9'; ch=getchar()) x = (x<<1) + (x<<3) + ch - '0';
	x = flag ? -x : x;
}
/*************************************Samle*************************************/
#define N 100005
int cnt, n, Q, fina[50*N], o[50*N], son[50*N][2]; LL ans[N]; char ch[N];
struct QUE{int l, r, id;}q[N];
bool operator < (R QUE a, R QUE b) {return a.r < b.r || (a.r == b.r && a.l < b.l);}
inline void insert(R int x)
{
	R int p = 0;
	for(int i=0; x+i<=n&&i+1<=40; ++i)
	{
		R int w = ch[x+i] - '0';
		if(!son[p][w])
		{
			son[p][w] = ++cnt;
			fina[cnt] = x;
		}
		else
		{
			o[i+1] = Max(o[i+1], fina[son[p][w]]);
			fina[son[p][w]] = x;
		}
		p = son[p][w];
	}
}
int main()
{
	in(n), in(Q); scanf("%s", ch+1);
	Fo(i, 1, Q) in(q[i].l), in(q[i].r), q[i].id = i;
	sort(q+1, q+Q+1); R int T = 1;
	Fo(i, 1, n)
	{
		insert(i);
		while(T <= Q && q[T].r == i)
		{
			for(R int i=1; i<=40; ++i)
			{
				if(o[i] >= q[T].l)
					ans[q[T].id] += 1ll * i * (o[i]-Max(q[T].l-1, o[i+1]));
				else 
					break;
			}
			++T;
		}
	}
	Fo(i, 1, Q) printf("%lld\n", ans[i]);
	return 0;
}
```

---

## 作者：Farkas_W (赞：10)

$$\texttt{前言}$$

$\quad$我们的模拟赛考了这道题，只会暴力的 30 分，考后看 std 才发现随机数据是怎么用的。(~~另外其他题解也太长了吧~~)

$$\texttt{思路}$$

$\quad$考虑 trie 树，因为是随机数据，显然两段长为 $L$ 的字符串完全相同的概率是 $2^L$，所以取的要尽量大且不会爆空间。我们对于每一个位置，只存其后长为 $45$ 的字符串即可(长度取 $30$ 只可以得到 $70$ 分)，暴力将每一个位置存入时，$last$ 数组记录下最近到达这个位置的 $id$ ，$a$ 数组记录上一个到达这个位置的字符串编号，每次更新 $a$ 数组。

$\quad$设以第 $i$ 个位置开始(结束位置为 $n$) 的字符串为字符串 $i$，建立 trie树后，$last_{i,j}$ 表示与字符串 $i$ 前 $j$ 位完全相同的最近的字符串编号 (这里的最近指的是小于 $i$ 的且最靠近 $i$ 的编号)。

$\quad$接着对 $last$ 数组做一个前缀最大值，$last_{i,j}$ 表示从字符串 $1$ 到字符串 $i$ 中，最大的**一对**长为 $j$ 的前缀相同的字符串编号中较小的。假如 $t=last_{i,j}$，满足

$$data_{k,i}=j(1\leq k\leq t)$$

$\quad$所以对于一个询问 $L,R$，假如 $t=last_{R,j}(t\geq L)$，显然对于 $data_{i,R}(i\in [L,t])=j$，这样区间 $[L,t]$ 的答案就统计好了，接着继续统计询问 $[t+1,R]$ 即可，可以令 $L=t+1$，就这样一段区间一段区间的向后跳。

$\quad$时间复杂度为 $O(45(n^2+Q))$ ，开 $O_2$ 后跑了 207ms，目前最优解。如果有什么疑问就看代码吧。

```cpp
il int max(int x,int y){return x>=y?x:y;}
const int N=5e5+5;
int n,m,a[N*47],ch[N*47][2],cnt,last[N][48];
char c[N];
il void insert(int id)
{
	int u=0;
	for(re i=id;i<=id+46;i++)//只更新长度47
	{
		if(i>n)return;bool p=(c[i]=='1');
		if(!ch[u][p])ch[u][p]=++cnt;
		u=ch[u][p];last[id][i-id+1]=a[u];
		a[u]=id;//更新
	}
}
signed main()
{
	cin>>n>>m>>c+1;
	for(re i=1;i<=n;i++)insert(i);
	for(re i=2;i<=n;i++)
	for(re j=1;j<=47;j++)
	{
		last[i][j]=max(last[i][j],last[i-1][j]);//前缀最大值
		if(!last[i-1][j])break;//表示前面没有前j位相同的字符串
	}
	while(m--){
		int l,r,ans=0;cin>>l>>r;
		for(re i=47;i&&l<=r;i--)
		if(last[r][i]>=l){		//有符合区间的字符串
			ans+=(last[r][i]-l+1)*i;//统计答案
			l=last[r][i]+1;
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：asuldb (赞：9)

[题目](https://www.luogu.org/problemnew/show/P3732)

这道题我们其实就是利用了一棵后缀树

由于字符串是随机的，所以这个后缀树的树高是$log$的，基于树高的算法是能过的

我们考虑后缀树上的两个节点的$lca$就是这两个节点所代表的后缀的$lcp$

我们可以把询问按照右端点离线，每次都暴力跳这个在后缀树上暴力跳父亲

我们维护一下后缀树上子树里的最大值，这样我们就可以维护出对于每一种$lcp$出现最靠后的位置在哪里了

对于每次询问我们扫一遍这些个$lcp$就好了

至于如何建一棵后缀树，自然是把原串反着建一个SAM啊

代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define re register
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
inline int read() {
	char c=getchar();int x=0;while(c<'0'||x>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
const int maxn=2e5+5;
struct Ask{int l,r,rk;}q[maxn>>1];
int cnt=1,lst=1,len[maxn],son[maxn][2],fa[maxn];
int pos[maxn>>1],lcp[maxn>>1],mx[maxn],g[maxn>>1],h[maxn>>1];
int n,m,T;LL Ans[maxn>>1];char S[maxn>>1];
inline int cmp(Ask A,Ask B) {return A.r<B.r;}
inline void Extend(int c,int o) {
	int p=++cnt,f=lst;lst=p;
	len[p]=len[f]+1,pos[o]=p;
	while(f&&!son[f][c]) son[f][c]=p,f=fa[f];
	if(!f) {fa[p]=1;return;}
	int x=son[f][c];
	if(len[f]+1==len[x]) {fa[p]=x;return;}
	int y=++cnt;
	len[y]=len[f]+1,fa[y]=fa[x],fa[x]=fa[p]=y;
	son[y][0]=son[x][0],son[y][1]=son[x][1];
	while(f&&son[f][c]==x) son[f][c]=y,f=fa[f];
}
inline void ins(int i) {
	int x=pos[i];
	while(x) {
		lcp[len[x]]=max(lcp[len[x]],mx[x]);
		if(lcp[len[x]]) T=max(T,len[x]);
		mx[x]=max(mx[x],i);x=fa[x];
	}
}
inline void calc(int j) {
	int t=q[j].r-1,tmp=0;
	LL ans=0;
	for(re int i=1;i<=T;++i) 
	if(lcp[i]) {
		while(lcp[i]>=g[tmp]&&tmp) tmp--;
		g[++tmp]=lcp[i],h[tmp]=i;
	}
	g[tmp+1]=0;
	for(re int i=2;i<=tmp+1;i++) {
		if(g[i]<q[j].l) {
			ans+=(g[i-1]-q[j].l+1)*h[i-1];
			break;
		}
		ans+=(g[i-1]-g[i])*h[i-1];
	}
	Ans[q[j].rk]=ans;
}
int main() {
	n=read(),m=read();scanf("%s",S+1);
	for(re int i=1;i<=m;i++) q[i].l=read(),q[i].r=read(),q[i].rk=i;
	for(re int i=n;i;--i) Extend(S[i]-'0',i);
	std::sort(q+1,q+m+1,cmp);ins(1);int tot=1;
	for(re int i=2;i<=n;i++) {
		ins(i);
		while(q[tot].r==i) calc(tot++);
	}
	for(re int i=1;i<=m;i++) printf("%lld\n",Ans[i]);
	return 0;
}
```


---

## 作者：WJiannan (赞：5)

由于串 $S$ 中的每一位都是在 $0$ 和 $1$ 之间随机产生，
所以我们估计出最长公共前缀的两个后缀的最长公共前缀的长度不超过 $50$（然而我一开始认为最多就 $30$，然后就 WA 了），因为长度每多 $1$，出现的概率就 $\times \frac{1}{2}$。

有一个 $\mathrm{Trie}$ 的做法，跑得飞快，但是我没想到。

于是我写了 $\mathrm{Hash}$，目前是跑得最慢的。

对与每一个数你用二进制的方式存储它后 $1 \sim 50$ 位的 $\mathrm{Hash}$ 值，然后可以由此预处理出在它前面的后缀与它的最长公共前缀的长度为 $x$ 的数的位置。

先将询问按照 $r$ 排序。然后遍历一遍，用类似双指针的方式，过程中要实时更新到当前位置公共前缀长度为 $x$ 的数最后的位置。

然后就 rank $+\infty$。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define R register
#define Max(_A, _B) (_A > _B ? _A : _B)
int n, Q, Pre[100010][55], T[55];
long long H[100010][55];
char s[100010];
struct Data{ int l, r; long long Ans; } a[100010], *A[100010];
long long W[100010]; int To[100010], Point[1000039], q, Next[100010];
int Add(R long long u, R int p)
{
	R int tmp = u % 1000039;
	for(R int j = Point[tmp]; j; j = Next[j])
		if(u == W[j])
		{
			tmp = To[j];
			To[j] = p;
			return tmp;
		}
	Next[++q] = Point[tmp]; Point[tmp] = q; To[q] = p; W[q] = u;
	return 0;
}
bool cmp(R Data *i, R Data *j){ return i->r < j->r; }
int rank[55], len[55];
bool cmp1(R int i, R int j){ return len[i] > len[j]; }
int main()
{
	scanf("%d %d %s", &n, &Q, s + 1);
	memset(H, -1, sizeof(H));
	for(R int i = n; i; i--)
	{
		H[i][0] = s[i] - '0';
		for(R int j = 1; j < 50 && i + j <= n; j++) 
			H[i][j] = H[i + 1][j - 1] << 1 | (s[i] - '0');
	}
	for(R int j = 0; j < 50; j++)
	{
		for(R int i = 1; i <= n; i++) if(~H[i][j])
			Pre[i][j] = Add(H[i][j], i);
		for(R int i = 1; i <= n; i++) Point[H[i][j] % 1000039] = 0;
		q = 0;
	}
	for(R int i = 1; i <= Q; i++) scanf("%d %d", &a[i].l, &a[i].r);
	for(R int i = 1; i <= Q; i++) A[i] = a + i;
	std::sort(A + 1, A + 1 + Q, cmp);
	R int l = 1;
	for(R int i = 1; i <= Q; i++)
	{
		while(l <= A[i]->r)
		{
			for(R int j = 0; j < 50; j++) T[j] = Max(T[j], Pre[l][j]);
			l++;
		}
		memset(len, 0, sizeof(len));
		for(R int j = 0; j < 50; j++) if(T[j] >= A[i]->l) len[j] = T[j];
		for(R int j = 0; j < 50; j++) rank[j] = j;
		std::sort(rank, rank + 50, cmp1);
		R int tmp = 0, loc = A[i]->r;
		for(R int j = 0; j < 50; j++) 
			if(!len[rank[j]]) break;
			else 
			{
				A[i]->Ans += 1ll * (loc - len[rank[j]] - 1) * tmp;
				tmp = Max(tmp, rank[j] + 1);
				loc = len[rank[j]] + 1;
			}
		A[i]->Ans += 1ll * (loc - A[i]->l) * tmp;
	}
	for(R Data *i = a + 1; i <= a + Q; i++) printf("%lld\n", i->Ans);
	return 0;
}
```


---

## 作者：FreeTimeLove (赞：2)

## 一、题意

给定一个**随机生成**的 $01$ 串 $s$，定义 $f(l,r)$ 为**起始位置**在 $[l,r]$ 中的 $s$ 的所有**后缀**中，**相同前缀**最长的两个**不同**后缀的相同前缀**长度**。

$q$ 次询问，每次询问给定 $L,R$，求 $\sum_{i=L}^{R-1}f(i,R)$。

## 二、思路

一开始认为困难，但发现 $01$ 串随机生成，而答案的期望大小为 $\mathrm O(\log n)$，就可以用期望时间复杂度 $\mathrm O(q\log n)$ 的解法。

我们考虑建一棵 $\text{01Trie}$ 维护每个节点最后一次出现的**起始位置**，按**起始位置的先后**依次插入 $s$ 的后缀的**前 $k$ 位**（其中 $k$ 是我们对 $f(l,r)$ 的最大值的**估计**，设为 $40$ 即可，实测此题 $k$ 最小可设为 $32$）。

设 $p_i$ 表示长度为 $i$ 的公共前缀**最后一次**出现的位置，即拥有此公共前缀的两个 $s$ 的后缀**起始位置**的最小值。容易看出 $\forall j<i,p_j\ge p_i$，即 $p$ 是**单调不升**的。那么对于一组 $l,r$，$f(l,r)$ 为在**插入前 $r$ 个后缀时**满足 $p_i\ge l$ 的**最大**的 $i$。

而对于一次询问 $L,R$，我们计算出插入前 $r$ 个后缀时的 $p$，遍历 $p$。如果 $p_i<L$ 则不做处理；如果 $p_i\ge L$，对答案的贡献为 $i\cdot (p_i-\max(L-1,p_{i+1}))$。

那么我们可以将询问离线，按 $R$ 升序排序。每次向 $\text{01Trie}$ 中插入一个后缀时，我们更新所经过的节点的值，同时更新 $p$。然后计算 $L,R$ 的答案即可。

### AC code

```cpp
//written_by_FTL
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<vector>
#include<map>
#define ll long long
#define LD long double
#define i7 __int128
#define re return
#define con continue
using namespace std;
const int N=1e5+5;
int rd(){
	int ans=0,f=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')f^=(ch=='-'),ch=getchar();
	while(ch>='0'&&ch<='9')ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();
	re f?-ans:ans;
}
int n,m,l,r,nw,xx,rt,ans[N],p[50],k=32;
char s[N];
struct xxs{
	int id,l,r;
	bool operator <(const xxs &x)const{
		re r<x.r;
	}
}q[N];
int gt(int x){//统计答案
	int ans=0,flag=0;
	while(xx<k)
		if(p[xx+1])xx++;
		else break;
	for(int i=xx;i;i--){
		if(p[i]<x)con;
		if(flag==0){
			ans+=max(0,p[i]-x+1)*i;
			flag=1;
		}
		else ans+=max(0,p[i]-p[i+1])*i;
	}
	re ans;
}
namespace TR{//Trie
	#define t d[v]
	int num=0;
	struct data{
		int s[2]={0};int c=0;
	}d[N*30];
	void ins(int &v,char *s,int k,int lim){
		if(!v)v=++num;
		p[k]=max(p[k],t.c);		//更新 p
		t.c=nw;				//更新当前节点的值
		if(k>=lim)re;
		ins(t.s[*s-'0'],s+1,k+1,lim);
	}
	#undef t
}
int main(){
	n=rd(),m=rd();
	scanf("%s",s+1);
	for(int i=1;i<=m;i++){//离线
		l=rd(),r=rd();
		q[i]={i,l,r};
	}
	sort(q+1,q+m+1);
	for(int i=1;i<=m;i++){
		while(nw<q[i].r)nw++,TR::ins(rt,s+nw,0,min(k,n-nw+1));//插入后缀
		ans[q[i].id]=gt(q[i].l);
	}
	for(int i=1;i<=m;i++)printf("%d\n",ans[i]);
	re 0;
}
```

### $\text{The End.}$

---

## 作者：Xy_top (赞：1)

分享一个不用字典树的做法，而且码量差不多。

因为是随机生成，所以最长公共前缀的长度极大概率不超过 $34$，把长度小于等于 $34$ 的 $s$ 的连续子串单独拉出来。

考虑如何查询单个 $data(x.y)$，显然可以枚举最长公共前缀的长度 $len$，然后查询这个区间内有没有两个相同的长度为 $len$ 的串，但是如何查询呢？对于每个串我们预处理一个 $lst$ 表示上一个与它相同的串的位置。有两个相同的串，充要条件为 $\max_{j=x}^{y} lst_j\geq x$ ，`ST` 表维护即可。

下面考虑如何一次查询多个 $data(x,y)$，仍然是枚举最长公共前缀的长度，然后对于每个长度 $len$，二分出最大的 $l$ 使得 $l$ 到 $y$ 这一段有两个长度为 $len$ 的串相等，那么 $[x,l]$ 到 $y$ 这段的答案就可以是 $len$。从小到大枚举 $len$，我们需要一个支持区间覆盖的线段树，但是这样就超时了。

考虑另辟蹊径，如果 $data(x,y)$ 的答案为 $len$，那么一定会在 $i$ 枚举到 $[1,len]$ 间各统计一次，总共统计 $len$ 次，所以不需要线段树，每次统计到给它加上就行了。

时间复杂度为 $O(n\log n)$，带有一个 $34$ 的常数，所以有点卡常。

```cpp
#include <bits/stdc++.h>
#define For(i, a, b) for (int i = (a); i <= (b); i ++)
#define foR(i, a, b) for (int i = (a); i >= (b); i --)
using namespace std;
int n, q;
char s[100005];
int f[35][17][100005];
int lg[100005], pre[17];
unordered_map <unsigned long long, int> m;
unsigned long long h[100005], hsh[100005];
unsigned long long getha (int x, int y) {return (unsigned long long) (hsh[y] - hsh[x - 1] * h[y - x + 1]);}
int query (int l, int x, int y) {
	int b = lg[y - x + 1];
	return max (f[l][b][x], f[l][b][y - pre[b] + 1]);
}
void init () {
	h[0] = 1;
	For (i, 1, 100000) h[i] = h[i - 1] * 13331;
}
void solve () {
	For (i, 0, 16) pre[i] = 1 << i;
	scanf ("%d%d%s", &n, &q, s + 1);
	For (i, 1, n) hsh[i] = hsh[i - 1] * 13331 + s[i];
	lg[1] = 0;
	For (i, 2, 100000) lg[i] = lg[i / 2] + 1;
	For (i, 1, min (n, 34) ) {
		For (j, 1, n - i + 1) {
			if (m[getha (j, j + i - 1)]) f[i][0][j] = m[getha (j, j + i - 1)];
			m[getha (j, j + i - 1)] = j;
		}
		int len = n - i + 1;
		For (j, 1, 16) For (k, 1, len - pre[j] + 1)
			f[i][j][k] = max (f[i][j - 1][k], f[i][j - 1][k + pre[j - 1]]);
		m.clear ();
	}
	while (q --) {
		int x, y;
		scanf ("%d%d", &x, &y);
		long long ans = 0;
		For (len, 1, min (n, 34) ) {
			if (x + 1 + len - 1 > n) break;
			int R = min (y, n - len + 1);
			if (query (len, x, R) < x) break;
			int l = x, r = R - 1, mid;
			while (l <= r) {
				mid = l + r >> 1;
				if (query (len, mid, R) >= mid) l = mid + 1;
				else r = mid - 1;
			}
			ans += l - x;
		}
		printf ("%lld\n", ans);
	}
}
signed main () {
	solve ();
	return 0;
}
```

---

## 作者：kernel_panic (赞：1)

## 思路

首先，由于数据随机，不妨猜测 LCP 的最大长度不超过某个小常数 $K$．记 $S_i$ 表示由 $i$ 开始的后缀的长度为 $K$ 的前缀．

询问比较诡异，猜测难以高效地在线解决，于是考虑离线．将询问挂在右端点上，扫描线解决每个询问．对于当前扫描到的右端点 $r$，维护 $X_i = \operatorname{data}(i, r)$，询问就是对 $X_i$ 区间求和，丢到线段树上即可．

考虑移动右端点，加入 $S_r$ 时对 $X_i$ 的影响．由于 $K$ 较小，我们不妨暴力修改．具体而言，我们枚举 $S_r$ 的前缀 $T$，钦定 $T$ 为 LCP，然后找到最大的 $p$，使得 $S_p$ 含有 $T$ 这个前缀．对于 $X_j(1 \le j \le p)$，$T$ 作为 LCP 都能对其造成贡献，$X_j$ 需要对 $|T|$ 取 $\max$．

如何找到 $p$？考虑 Trie 的性质，对于一个串 $S$，它的一个前缀在 Trie 上对应的节点在 $S$ 对应的节点的祖先链上．那么我们维护一棵插入了 $S_i(1 \le i < r)$ 的 Trie，对 Trie 上每个节点 $u$ 维护 $\mathrm{mx}_u$，表示 $u$ 对应的串最后一次作为前缀出现是在 $S_{\mathrm{mx}_u}$ 中．那么对于 $S_r$ 的一个前缀，设它在 Trie 上对应的节点为 $u$，我们要找的 $p$ 就是 $\mathrm{mx}_u$．

对于区间取 $\max$ 操作，乍一看需要一棵维护区间历史最值的线段树．然而我们发现，对于 $u < v$，$X_u$ 中会包含 $X_v$ 的贡献，即 $X_i$ 单调不增，所谓的取 $\max$ 操作其实是对某个右端点为 $p$ 的区间的覆盖，线段树维护区间最小值就可以二分出区间左端点．这样就只需要一棵支持区间覆盖，求区间最小值和区间和的线段树．

在 Trie 上枚举前缀，复杂度省掉一个 $K$．

时间复杂度 $O(qK\log n)$，$K$ 取 $32$ 即可通过本题．

## 代码

```cpp
#include <cstdio>
#include <utility>
#include <vector>

inline int rd() {
	int x = 0, f = 1, c = getchar();
	while (((c - '0') | ('9' - c)) < 0)
		f = c != '-', c = getchar();
	while (((c - '0') | ('9' - c)) > 0)
		x = x * 10 + c - '0', c = getchar();
	return f ? x : -x;
}

using pii = std::pair<int, int>;

const int N = 1e5;
const int K = 32;

int n, q;
char a[N + 5];

std::vector<pii> qu[N + 5];
int ans[N + 5];

int ch[N * K + 5][2], dep[N * K + 5], mx[N * K + 5], alct;
void ins(char *s, int len, int id) {
	int p = 0;
	for (int i = 1; i <= len; i++) {
		int d = s[i] - '0';
		if (!ch[p][d]) ch[p][d] = ++alct;
		p = ch[p][d], mx[p] = id, dep[p] = i;
	}
}

#define lch (p * 2)
#define rch (p * 2 + 1)
#define mid ((t[p].l + t[p].r) / 2)
struct node {
	int l, r;
	int sum, mn;
	int tg;
	void upd(int d) {
		sum = d * (r - l + 1);
		mn = d, tg = d;
	}
} t[N * 4 + 5];
void pushup(int p) {
	t[p].sum = t[lch].sum + t[rch].sum;
	t[p].mn = std::min(t[lch].mn, t[rch].mn);
}
void pushdown(int p) {
	if (!t[p].tg) return;
	t[lch].upd(t[p].tg);
	t[rch].upd(t[p].tg);
	t[p].tg = 0;
}
void build(int p = 1, int cl = 1, int cr = n) {
	t[p].l = cl, t[p].r = cr;
	if (cl == cr) return;
	build(lch, cl, mid), build(rch, mid + 1, cr);
}
void upd(int l, int r, int d, int p = 1) {
	if (t[p].l == l && t[p].r == r) return t[p].upd(d);
	pushdown(p);
	if (r <= mid) upd(l, r, d, lch);
	else if (l > mid) upd(l, r, d, rch);
	else upd(l, mid, d, lch), upd(mid + 1, r, d, rch);
	pushup(p);
}
int que(int l, int r, int p = 1) {
	if (t[p].l == l && t[p].r == r) return t[p].sum;
	pushdown(p);
	if (r <= mid) return que(l, r, lch);
	else if (l > mid) return que(l, r, rch);
	else return que(l, mid, lch) + que(mid + 1, r, rch);
}
int getpos(int k, int p = 1) {
	if (t[p].l == t[p].r) return t[p].mn < k ? t[p].l : 0;
	pushdown(p);
	return (t[lch].mn < k) ? getpos(k, lch) : getpos(k, rch);
}
#undef lch
#undef rch
#undef mid

void solve(char *s, int len, int id) {
	int p = 0;
	for (int i = 1; i <= len; i++) {
		int d = s[i] - '0';
		if (!ch[p][d]) break;
		p = ch[p][d];
		int pos = getpos(dep[p]);
		if (pos && pos <= mx[p]) {
			upd(pos, mx[p], dep[p]);
		}
	}
	ins(s, len, id);
}

int main() {
	n = rd(), q = rd();
	scanf("%s", a + 1);
	for (int i = 1; i <= q; i++) {
		int l = rd(), r = rd();
		qu[r].emplace_back(l, i);
	}

	build();
	for (int i = 1; i <= n; i++) {
		solve(a + i - 1, std::min(n - i + 1, K), i);
		for (auto [l, id] : qu[i]) ans[id] = que(l, i);
	}

	for (int i = 1; i <= q; i++) printf("%d\n", ans[i]);
	return 0;
}
```


---

## 作者：ckain (赞：1)

记 $a_i$ 为字符串中的第 $i$ 个字符，$S_i$ 为以 $i$ 开头的后缀，$LCP(S_i, S_j)$ 指 $S_i$，$S_j$ 的最长公共前缀．

考虑 $LCP(S_i, S_j)=k$ 的条件为 $\forall i \le x \le i-k+1, a_x=a_{x-j+i}$．由于 $a_i$ 是随机生成的，$i,j$ 确定时，$LCP(S_i, S_j)=k$ 概率为 $\displaystyle \frac{1}{2^{k}}$．当 $k$ 取到 $40$，在整个串里存在两后缀的 $LCP=k$ 的概率约为 $\displaystyle \frac{n^2}{2^{40}}$，近乎为 $0$．我们直接默认任意两串的 $LCP \le 40$ 来做即可．这个概率的估算感觉颇有问题，但只考虑前 $40$ 位是对的——笔者大概不能严谨证明，可以参阅其他题解．．．姑且这样吧．

将询问离线下来，挂在右端点上，从左往右扫描字符串．  
设扫描到位置 $r$．我们维护 $g_i=data(i, r)\;(i<r)$，对于询问 $(l, r)$，答案为 $\displaystyle \sum_{i=l}^{r-1} g_i$．  
现在考虑加入位置 $r$ 后，$g$ 会发生什么变化．枚举 $i<r$，发现 $LCP(S_i,S_r)$ 会被计入 $g_x\;(x\le i)$ 中．但是枚举 $i$ 时间复杂度显然不够优秀．我们利用 $LCP \le 40$ 的结论，考虑枚举 $LCP(i, r)$ 的值 $len$．显然我们只需要找到 $\displaystyle \max_{LCP(i, r)=len, i<r}i$，$len$ 会被计入 $g_x\;(x\le i)$．我们更新它们的最大值即可．

如何实现呢？  
维护一棵 01 Trie，扫描到 $r$ 时将 $S_i\;(i<r)$ 的前 $40$ 位插入到里面．对于 Trie 上的节点 $u$，维护最后一次经过过它的后缀编号为 $mx_u$．在 Trie 上跑 $S_r$，对于经过的节点 $u$，设其深度是 $len_u$，发现 $\displaystyle mx_u=\max_{LCP(i, r)\ge len_u, i<r}i$．然后前缀更新 $g_i$ 的最大值即可．又发现 $g_i$ 只有前缀更新最大值的操作，故$g_i$ 单调不降，我们用线段树维护 $g_i$，可以在更新 $g_i$ 时二分出第一个需要更新的位置，再做一个区间覆盖即可．

现在到了复杂度分析环节．时间复杂度 $O(40n\log n)$，空间复杂度 $O(40n)$．可以（勉强）通过此题．

这个做法借鉴了线段树维护历史版本和（扫描线）的思想．现在做区间的子区间脑子里全是扫描线．

#### code:
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int rd(void){
	int s=0, f=1; char c=getchar();
	while(c<'0' || c>'9') {if(c=='-') f=0; c=getchar();}
	while(c>='0' && c<='9') {s=s*10+c-'0'; c=getchar();}
	return f? s:-s;
}
const int N=1e5+5, Lg=40;
int n, q, ans[N];
char s[N];
struct node{int l, id;};
vector<node> vec[N];

struct Trie{
	int ch[2], mx, dep;
} t[N*Lg];
int tot;

void ins(const char *f, int len, int id){
	int p=0;
	for(int i=1; i<=len; i++){
		if(!t[p].ch[f[i]-'0']) t[p].ch[f[i]-'0']=++tot;
		p=t[p].ch[f[i]-'0'];
		t[p].mx=id;
		t[p].dep=i;
	}
}

#define cl (p<<1)
#define cr (p<<1|1)
#define mid (st[p].l+st[p].r>>1)
struct sgt{
	int l, r;
	int mnv, sum;
	int tag;
} st[N<<2];
void build(int p, int l, int r){
	st[p].l=l, st[p].r=r;
	if(l==r) return;
	build(cl, l, mid), build(cr, mid+1, r);
}
void G(int p, int v){
	st[p].mnv=v;
	st[p].sum=(st[p].r-st[p].l+1)*v;
	st[p].tag=v;
}
void pu(int p){
	st[p].mnv=min(st[cl].mnv, st[cr].mnv);
	st[p].sum=st[cl].sum+st[cr].sum;
}
void pd(int p){
	if(st[p].tag){
		G(cl, st[p].tag);
		G(cr, st[p].tag);
		st[p].tag=0;
	}
}
void upd(int p, int l, int r, int v){
	if(st[p].l==l && st[p].r==r){
		G(p, v);
		return;
	}
	pd(p);
	if(r<=mid) upd(cl, l, r, v);
	else if(l>mid) upd(cr, l, r, v);
	else upd(cl, l, mid, v), upd(cr, mid+1, r, v);
	pu(p);
}
int ques(int p, int l, int r){
	if(st[p].l==l && st[p].r==r) return st[p].sum;
	pd(p);
	if(r<=mid) return ques(cl, l, r);
	else if(l>mid) return ques(cr, l, r);
	else return ques(cl, l, mid)+ques(cr, mid+1, r);
}
int quel(int p, int d){
	if(st[p].l==st[p].r) return st[p].mnv>=d? -1:st[p].l;
	pd(p);
	if(st[cl].mnv<d) return quel(cl, d);
	else return quel(cr, d);
}
#undef cl
#undef cr
#undef mid

int sgt[N];
int stk[N], tp;
int work(const char *f, int len, int id){
	int p=tp=0;
	for(int i=1; i<=len; i++){
		if(!t[p].ch[f[i]-'0']) break;
		stk[++tp]=p=t[p].ch[f[i]-'0'];
	}
	int re=0;
	for(int i=tp, now=0; i; i--){
		int u=stk[i];
		if(t[u].mx>now){
			int pos=quel(1, t[u].dep);
			if(pos>0 && pos<=t[u].mx) upd(1, pos, t[u].mx, t[u].dep);
			now=t[u].mx;
		}
	}
	return re;
}

signed main(){
	n=rd(), q=rd();
	scanf("%s", s+1);
	for(int i=1, l, r; i<=q; i++){
		l=rd(), r=rd();
		vec[r].push_back({l, i});
	}
	
	build(1, 1, n);
	for(int i=1; i<=n; i++){
		work(s+i-1, min(Lg, n-i+1), i);
		ins(s+i-1, min(Lg, n-i+1), i);
		for(node j:vec[i]){
			ans[j.id]=ques(1, j.l, i);
		}
	}
	
	for(int i=1; i<=q; i++) printf("%d\n", ans[i]);
	return 0;
}
```

---

## 作者：Fzrcy (赞：1)

因为数据随机，所以最长公共前缀的期望值不会太长，大概在 $40$ 左右，考虑用字典树维护每个后缀的前 $40$ 个字符，维护  $End_{i}$ 表示最后访问节点 $i$ 的后缀 $x$，$ci_{i}$ 表示所有深度为 $i$ 的节点的倒数第二次访问的后缀 $x$ 的最大值（根节点的深度为 $0$）。

插入后缀 $pos$：

```cpp
void insert(int pos){
  int u=1;
  for(int i=0; i<40&&pos+i<=n; i++){
    int c=s[pos+i]-'0';
    if(!ch[u][c])ch[u][c]=++Node, End[ch[u][c]]=pos;
    else ci[i+1]=max(ci[i+1], End[ch[u][c]]), End[ch[u][c]]=pos;
    u=ch[u][c];
  }
}
```



考虑离线处理询问，将询问按以 $R$ 为关键字，从小到大排序即可，然后从左到右依次插入后缀 $i$。

考虑处理询问 $[L,R]$：假设 $[1,R]$ 的后缀已经插入，考虑长度为 $i$ 的最长公共前缀的贡献次数为 $ci_i-\max(L-1,ci_{i+1})$。其中 $ci_i$ 表示位置 $y$ 满足 $y\le ci_i$ 才可能有长度为 $i$ 的最长公共前缀，$\max(L-1,ci_{i+1})$ 表示 $y$ 的最小值不小于 $L$（在 $[L,R]$ 的范围内），且大于 $ci_{i+1}$（表示 $y$ 不能有长度超过为 $i$ 的最长公共前缀）。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=5e6+11;
char s[N];
int ch[N][2], ci[N], Node=1, End[N];
int n, m;
long long ans[N];
struct Query{int l, r, id;}Ask[N];
bool cmp(Query x, Query y){return x.r!=y.r?x.r<y.r:(x.l<y.l);}
void insert(int pos){
  int u=1;
  for(int i=0; i<40&&pos+i<=n; i++){
    int c=s[pos+i]-'0';
    if(!ch[u][c])ch[u][c]=++Node, End[ch[u][c]]=pos;
    else ci[i+1]=max(ci[i+1], End[ch[u][c]]), End[ch[u][c]]=pos;
    u=ch[u][c];
  }
}
int main(){
  scanf("%d%d%s", &n, &m, s+1);
  for(int i=1; i<=m; i++)
    scanf("%d%d", &Ask[i].l, &Ask[i].r), Ask[i].id=i;
  sort(Ask+1, Ask+m+1, cmp);
  int now=1;
  for(int i=1; i<=n; i++){
    insert(i);
    for(; now<=m&&Ask[now].r==i; now++){
      int id=Ask[now].id;
      for(int j=1; j<=40; j++){
        if(ci[j]>=Ask[now].l) /*插入两个相同且长度为 j 的子串才能统计*/
          ans[id]+=1ll*j*(ci[j]-max(Ask[now].l-1, ci[j+1]));
        else break;
      }
    }
  }
  for(int i=1; i<=m; i++) printf("%lld\n", ans[i]);
  return 0;
}
```



---

## 作者：TTpandaS (赞：0)

考虑 $n^2$ 怎么做。

先考虑如何查询答案。

对于相同的 $R$，$\text{data}(i,R)$ 随着 $i$ 的增加递减。枚举最长公共前缀 $x$，那么满足 $\text{data}(l',R)=x+1$ 的最小的 $l'$ 到满足 $\text{data}(l,R)=x$ 的 $l$ 这段区间内，答案全部为 $x$。贡献答案后移动 $l$ 即可。

再考虑如何预处理 $\text{data}(l,R)=x$ 的最小的 $l$ 。

把每个后缀都加入字典树，记录与后缀 $i$ 最长公共前缀至少为 $j$ 的距离 $i$ 最近的 $\text{lst}(i,j)$。那么满足  $\text{data}(l,R)=x$ 的最小的 $l$ 就是 $\max_{i=1}^{R}\text{lst}(i,x)$，所以计算 $\text{lst}(i,j)$ 的前缀最大值即可。

考虑正解。

题目保证数据随机，所以两个长为 $n$ 的字符串相同的概率为 $\dfrac{1}{2^n}$，因此最长公共前缀长度不会很长。

预处理和询问时都可以只算到一个阈值即可。

实测阈值取 $32$ 可过。

---


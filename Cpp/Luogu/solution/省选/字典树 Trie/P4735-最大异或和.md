# 最大异或和

## 题目描述

给定一个非负整数序列 $\{a\}$，初始长度为 $N$。  

有 $M$ 个操作，有以下两种操作类型：  

1. `A x`：添加操作，表示在序列末尾添加一个数 $x$，序列的长度 $N$ 加 $1$。  
2. `Q l r x`：询问操作，你需要找到一个位置 $p$，满足 $l \le p \le r$，使得：$a[p] \oplus a[p+1] \oplus ... \oplus a[N] \oplus x$ 最大，输出最大值。  

## 说明/提示

- 对于所有测试点，$1\le N,M \le 3\times 10 ^ 5$，$0\leq a_i\leq 10 ^ 7$。

## 样例 #1

### 输入

```
5 5
2 6 4 3 6
A 1 
Q 3 5 4 
A 4
Q 5 7 0 
Q 3 6 6 ```

### 输出

```
4
5
6```

# 题解

## 作者：winxp_qwq (赞：52)

可持久化 $Trie$ 真好写...

我们看两个操作，添加操作没什么好说的，查询操作看起来很奇怪，但是如果转为前缀异或和数组$s[i]$，并把 $x$ 异或上 $s[n]$ 的话...

我们发现实际上就是考虑一个区间的数和 $x$ 异或后的最大异或和。

这样我们建一棵可持久化 $Trie$ ,每个节点存它的数字个数，查询的时候从高位到低位贪心走路就好。

另外注意一个坑点，就是如果查询区间左端点是1的话， $x$ 异或上 $0$ 可能是最大的，要把这种情况考虑进去。

最后，如果不知道可持久化Trie的话，其实根据主席树的建树方法脑补一下就好，还是很好写的。

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
#define maxn 600009
int rt[maxn],cnt[maxn*28];
int ch[maxn*28][2];
int qz[maxn];
int tt=1;
int n,m;
void ins(int a,int b,int t,int x) {
    if(t<0) return;
    int i=(x>>t)&1;
    ch[a][!i]=ch[b][!i];
    ch[a][i]=tt++;
    cnt[ch[a][i]]=cnt[ch[b][i]]+1;
    ins(ch[a][i],ch[b][i],t-1,x);
}
int qu(int a,int b,int t,int x) {
    if(t<0) return 0;
    int i=(x>>t)&1;
    if(cnt[ch[b][!i]]>cnt[ch[a][!i]]) {
        return (1<<t)+qu(ch[a][!i],ch[b][!i],t-1,x);
    }
    else {
        return qu(ch[a][i],ch[b][i],t-1,x);
    }
}
int main(){
    scanf("%d%d",&n,&m);
    int a,b,c,i,j;
    char s[5];
    rt[0]=tt++;
    ins(rt[0],0,25,0);
    for(a=1;a<=n;a++) {
        scanf("%d",&b);
        qz[a]=qz[a-1]^b;
        rt[a]=tt++;
        ins(rt[a],rt[a-1],25,qz[a]);
    }
    for(a=1;a<=m;a++) {
        scanf("%s",s);
        if(s[0]=='A') {
            scanf("%d",&b);
            n++;
            qz[n]=qz[n-1]^b;
            rt[n]=tt++;
            ins(rt[n],rt[n-1],25,qz[n]);
        }
        else {
            scanf("%d%d%d",&i,&j,&b);
            i--;j--;
            if(i==0) printf("%d\n",qu(0,rt[j],25,b^qz[n]));
            else printf("%d\n",qu(rt[i-1],rt[j],25,b^qz[n]));
        }
    }
    return 0;
}
```

---

## 作者：hzoi_liuchang (赞：34)

## 分析
其实这题的 $Trie$ 树可以不用可持久化 

因为前缀会有一些奇奇怪怪的特判，所以我的 $Trie$ 树里存的是后缀

要满足 $a[p]\ xor\ a[p+1]\ xor ... xor\ a[N]\ xor\ x$ 最大

不妨设后缀异或和为 $sum$

那么就有 $ \sum_{i=p}^N sum[i]\ xor\ x$ 最大

单次操作可以用  $Trie$ 树 实现

对于多组询问，我们只需要按照每一次询问的右端点从小到大离线排序即可

对于左端点，我们记录一下在 $Trie$ 树中这个节点最晚在哪一次操作中被加入即可

常数比可持久化 $Trie$ 树小不少，目前是最优解
## 代码
``` cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define rg register
inline int read(){
	rg int x=0,fh=1;
	rg char ch=getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*fh;
}
const int maxn=6e5+5,maxk=34;
int a[maxn],sum[maxn],n,m,ans[maxn],cnt,top;
char s[maxn];
struct asd{
	int l,r,id,val;
}b[maxn];
bool cmp(asd aa,asd bb){
	return aa.r<bb.r;
}
int tr[maxn*10][2],mmax[maxn*10][2];
void ad(rg int val,rg int id){
	rg int now=0;
	for(rg int i=30;i>=0;i--){
		rg int k=(val>>i)&1;
		if(!tr[now][k]){
			tr[now][k]=++cnt;
			mmax[now][k]=id;
		} else {
			mmax[now][k]=std::max(mmax[now][k],id);
		}
		now=tr[now][k];
	}
}
int cx(rg int val,rg int id){
	rg int now=0,nans=0;
	for(rg int i=30;i>=0;i--){
		rg int k=(val>>i)&1;
		if(tr[now][k^1] && mmax[now][k^1]>=id){
			now=tr[now][k^1];
			nans+=(1<<i);
		} else {
			now=tr[now][k];
		}
	}
	return nans;
}
int main(){
	n=read(),m=read();
	for(rg int i=1;i<=n;i++){
		a[i]=read();
	}
	rg int aa,bb,cc;
	for(rg int i=1;i<=m;i++){
		scanf("%s",s);
		if(s[0]=='A'){
			aa=read();
			a[++n]=aa;
		} else {
			aa=read(),bb=read(),cc=read();
			top++;
			b[top].l=aa,b[top].r=bb,b[top].val=n,b[top].id=cc;
		}
	}
	for(rg int i=n;i>=1;i--){
		sum[i]=sum[i+1]^a[i];
	}
	for(rg int i=1;i<=top;i++){
		b[i].val=sum[b[i].val+1]^b[i].id;
		b[i].id=i;
	}
	std::sort(b+1,b+1+top,cmp);
	rg int head=1;
	for(rg int i=1;i<=top;i++){
		while(head<=b[i].r){
			ad(sum[head],head);
			head++;
		}
		ans[b[i].id]=cx(b[i].val,b[i].l);
	}
	for(rg int i=1;i<=top;i++){
		printf("%d\n",ans[i]);
	}
	return 0;
}
```

---

## 作者：2344b (赞：22)

退役前补个锅。

用字典树记录下异或前缀和，最后贪心查找的时候只需要看 $\operatorname{l}$ 到 $\operatorname{r}$ 区间对应点的 $\operatorname{sum}$ 只差是否不为0，
不为0说明这段区间有这存在这一段异或前缀。

于是可以贪心的从高位往低位取。


字典树用可持久化节省一点空间，同时也更方便维护前缀。具体就是对于没有修改到的前缀直接继承。
```cpp
#include<bits/stdc++.h>
typedef long long LL;
typedef double db;
#define REP(i,s,t) for(register int i=s;i<=t;++i)
#define PER(i,s,t) for(register int i=s;i>=t;--i)
#define FOREDGE(i,x,v) for(int i=fir[x],v=to[i];i;i=nex[i],v=to[i])
template<typename T>inline T in(){
    T ans=0;bool b=0;char ch=getchar();
    while(ch<'0'||ch>'9')b=(ch=='-'),ch=getchar();
    while(ch>='0'&&ch<='9')ans=ans*10+ch-48,ch=getchar();
    return b?-ans:ans;
}
#define II in<int>()
#define IL in<LL>()
//<-----QAQ----->
const int MX=6e5+100;
int n,m,sum,top;
struct Trie{
    int rt[MX],sz,ch[2][MX<<5],cnt[MX<<5],vl[MX];
    void insert(int v){
        rt[++top]=++sz;vl[top]=v;
        int l=rt[top-1],r=rt[top];
        PER(bit,24,0){
            int b=((v>>bit)&1);
            ch[!b][r]=ch[!b][l];
            ch[b][r]=++sz;
            l=ch[b][l];r=ch[b][r];
            cnt[r]=cnt[l]+1;
        }
    }
    int query(int v,int r,int l){
        int ans=0;
        l=rt[l],r=rt[r];
        PER(bit,24,0){
            int b=((v>>bit)&1);
            if(cnt[ch[!b][r]]>cnt[ch[!b][l]])
                ans+=(1<<bit),b=!b;
            l=ch[b][l];r=ch[b][r];
        }
        return ans;
    }
}T;
char op[10];
int main(){
    n=II,m=II;
    T.insert(0);
    REP(i,1,n)T.insert(sum^=II);
    REP(i,1,m){
        scanf("%s",op);
        switch(op[0]){
            case 'A':T.insert(sum^=II);break;
            case 'Q':printf("%d\n",T.query(II^sum,II,II-1));break;
        }
    }
}
```


---

## 作者：LightningUZ (赞：21)

## 思考过程
如果没有区间的限制显然很好做：设 $S_i$ 表示前缀 $i$ 个异或和，令 $K=x\oplus S_n$，然后要在 $[0,n-1]$ 中找到一个 $p$ 使得 $S_p\oplus K$ 最大。

解：在 01-Trie 上，每个节点维护一个 $cnt$。每一位上，尽量走和 $K$  这一位不同的，用 $cnt$ 判断是否能走。 

那现在有了区间限制，显然，“能不同就不同的贪心”依然是正确的，只是判断方法有点不同。

首先推一下式子：$K$ 一样，$p$ 的范围变成 $[l-1,r-1]$中选，要找到 $S_p$ 使得 $S_p\oplus K$ 最大。

最暴力的想法固然是，把区间中所有的 $S$ 数组值都插入到 Trie 里面，然后转化成没有区间限制的。

每次暴力插固然不可取。考虑用“前缀和套Trie”来优化它：

设 $T_i$ 表示插入了前 $i$ 个 $S$ 后的 Trie。那区间 $[l,r]$ 的 Trie 上，某一个位置的 $cnt$ 就用 $T_r-T_{l-1}$ 的 $cnt$ 即可。

如何存储 $T_i$ 呢？显然是可持久化。

## 解法总结

维护一个可持久化 Trie，求出 Trie 的前缀和。能不同就不同的贪心跑一遍，用前缀的 cnt 相减判断是否能走。

## 细节

- 关于数组：只要开不死，就往死里开
- 首先 $p$ 的范围是 $[l-1,r-1]$ 。那再套在 Trie 的前缀和相减上，就是第 $r-1$ 颗 Trie 减去第 $l-2$ 颗 Trie。
- 如果 $l=1$ 怎么办？第 $-1$ 颗 Trie？？？
- 很简单的 trick，我们把区间整体往右平移一个。然后要注意，第 $1$ 颗 Trie，也就是平移前的第 $0$ 颗 Trie，是有值的。它那条全 $0$ 的链上 $cnt$ 都是 $1$！千万注意啊QaQ

## 细节总结
- 数组
- 整体平移
- 插入一个 $0$

（我才不会告诉你我因为后两个点WA了两次，一次改一个QaQ）
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Flandre_Scarlet
{
    #define N 600005
    #define F(i,l,r) for(int i=l;i<=r;++i)
    #define D(i,r,l) for(int i=r;i>=l;--i)
    #define Fs(i,l,r,c) for(int i=l;i<=r;c)
    #define Ds(i,r,l,c) for(int i=r;i>=l;c)
    #define MEM(x,a) memset(x,a,sizeof(x))
    #define FK(x) MEM(x,0)
    #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))
    #define p_b push_back
    #define sz(a) ((int)a.size())
    #define all(a) a.begin(),a.end()
    #define iter(a,p) (a.begin()+p)
    int I() {char c=getchar(); int x=0; int f=1; while(c<'0' or c>'9') f=(c=='-')?-1:1,c=getchar(); while(c>='0' and c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar(); return (x=(f==1)?x:-x);}
    void Rd(int cnt,...) {va_list args;va_start(args,cnt); F(i,1,cnt) {int* x=va_arg(args,int*);(*x)=I();} va_end(args);}
    void RA(int *a,int n) {int *p=(a+1); F(i,1,n) {(*p)=I();++p;}}

    class Trie
    {
    public:
        int ch[N*30][2],cnt[N*30];
        int rt[N],tot=0;
        void Add(int x,int pre,int &ix)
        {
            ix=++tot;
            int p=ix,q=pre;
            cnt[p]=cnt[q]+1;
            D(i,24,0)
            {
                ch[p][0]=ch[q][0]; ch[p][1]=ch[q][1];
                int c=((x>>i)&1);
                ch[p][c]=++tot;
                p=ch[p][c],q=ch[q][c];
                cnt[p]=cnt[q]+1;
            }
        }
        int  Query(int x,int r1,int r2)
        {
            int p=rt[r1],q=rt[r2];
            int ans=0;
            D(i,24,0)
            {
                int c=((x>>i)&1);
                if (cnt[ch[q][c^1]]-cnt[ch[p][c^1]]>0) ans|=(1<<i),p=ch[p][c^1],q=ch[q][c^1];
                else p=ch[p][c],q=ch[q][c];
                // cnt 相减判断是否能走
            }
            return ans;
        }
        int  RQuery(int x,int l,int r) {return Query(x,l-1,r);}
    }T;
    int n,m;
    void Input()
    {
        Rd(2,&n,&m);
    }
    void Soviet()
    {
        T.Add(0,T.rt[0],T.rt[1]); // 注意这个 0 （主要是为了修改 cnt
        int cur=0,pos=1; // cur 表示当前的前缀和，pos 表示当前的位置
        F(i,1,n) {int x=I(); cur^=x; T.Add(cur,T.rt[pos],T.rt[pos+1]); ++pos;}
        // 注意：插入的是前缀和
        F(i,1,m)
        {
            char o[3]; scanf("%s",o);
            if (o[0]=='A')
            {
                int x=I();
                cur^=x; T.Add(cur,T.rt[pos],T.rt[pos+1]); ++pos;
            }
            else
            {
                int l=I()+1,r=I()+1,x=I();
                int fir=x^cur;
                printf("%d\n",T.RQuery(fir,l-1,r-1));
            }
        }
    }
    void IsMyWife()
    {
        Input();
        Soviet();
    }
}
#undef int //long long
int main()
{
    Flandre_Scarlet::IsMyWife();
    getchar();
    return 0;
}
```

---

## 作者：Ciyang (赞：15)

### 前面几篇题解已经说了,正解是可持久化Trie(字典树).
#### 之所以打算写一下题解,是因为我用的其他题解中没有的自带大常数的指针做法,并且这个题还有两三个重要的坑点技巧...
#### 思路(自己+借鉴): 

首先要对位运算较为熟悉,一定要知道异或运算的特性,即如下 

```cpp
s[1] = a[0]  xor a[1] 
s[p] = s[p - 1] xor a[p]
a[p] xor a[p + 1] xor ... xor a[N] xor x = s[p - 1] xor s[N] xor x
```

如果还不懂,并且有一点图论基础的话,可以先做[P4551 最长异或路径](https://www.luogu.org/problemnew/show/P4551)来练习,不需要可持久化思想.  
那么在序列末尾添加数字时,先让n=n + 1,维护s数组,并向Trie中插入s\[n\]的24位二进制数,前面用0填充.  

#### 其实这个题难点在于查询
根据位运算特性,有如下结论:

```cpp
a[p] xor a[p + 1] xor ... xor a[N] xor x = s[p - 1] xor s[N] xor x
当l <= p <= r时,求p,使s[p - 1] xor s[N] xor x最大 
```

如果没有l和r的限制,那么就和P4551求法相同,然而考虑右端r的限制,所以要用到可持久化思想.  
可持久化Trie其实看起来不那么容易,其实很好写.只要在原Trie基础上,每次插入时,要用到的节点都新创建一个,再继承原来相同位置上的节点,这样就可以通过不同时期的根节点访问不同时期的Trie.  
有了可持久化Trie,那么区间右端r的限制就解决了,只要搜索时从r-1开始搜索就行了.   
现在再考虑左端l的限制,其实也思路和做法都比较简单,只需要在每个点上标记经过这个节点的最大的数.具体求法就是在插入时,标记插入路径上的点全为当前插入的s数组的下标就行了.因为插入时下标是越来越大的,所以就不用考虑标记的是否为最大的数了.  
#### 下面考虑查询如何搜索
那么在搜索时,若只有0的下标为0,搜索第r-1个根,从最高位(第24位)开始,一直到0位,每次先看此位上异或大的子节点,是否存在且是否标记值>=l-1,若都成立,就让当前指针指向此此孩子,并让此次ans+=1<<此位,否则就检查另外一个子节点,条件都不成立,直接返回当前ans.  
这个题还有几个技巧:   
卡常: inline register 手写new节点函数 快读   
还有就是一开始不能为空Trie树,需要科学插入一个0,第二个点有区间左端点l=1并且num异或0最大.   
### 代码实现:
```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
using namespace std;
struct node {
    node *childs[2];
	int symboln;
} * mainnodes[500001], nodes[13000001];
int mptr, nptr;
//mainnode的下标指针,nodes的下标指针
inline node *newnode(node *an, int s) {
	++nptr;
	nodes[nptr].childs[0]= an->childs[0], nodes[nptr].childs[1]= an->childs[1];
	nodes[nptr].symboln= s;
	return &nodes[nptr];
}
inline node *newnode(int s) {
	++nptr;
	nodes[nptr].childs[0]= nodes[nptr].childs[1]= NULL;
	nodes[nptr].symboln= s;
	return &nodes[nptr];
}
//newnode为手写new节点
inline void insert(int num) {
	register node *lnode= newnode(mainnodes[mptr], mptr + 1);
    //卡常,创建一个新的根节点继承原来的
	mainnodes[++mptr]= lnode;
	for(register int i= 24, ch; i + 1; --i) {
		ch= num >> i & 1;
        //位运算判断二进制下第i位是否为1
		if(lnode->childs[ch])
			lnode= lnode->childs[ch]= newnode(lnode->childs[ch], mptr);
		else
			lnode= lnode->childs[ch]= newnode(mptr);
        //需要改变的节点要创建新的节点,原来存在还要继承原来的节点
	}
	return;
}
inline int find(int num, int l, int r) {
//此处l和r,在输入时已经都-1
	register node *lnode= mainnodes[r];
	int ans= 0;
	for(register int i= 24, ch; i + 1; --i) {
		ch= num >> i & 1;
		if(lnode->childs[ch ^ 1] && lnode->childs[ch ^ 1]->symboln >= l)
			lnode= lnode->childs[ch ^ 1], ans+= 1 << i;
        //优先选择此位上异或为1的
        //要满足标记值>=左端点-1
		else if(lnode->childs[ch] && lnode->childs[ch]->symboln >= l)
			lnode= lnode->childs[ch];
		else
			break;
	}
	return ans;
}
void init() {
	register node *lnode= newnode(0);
	mainnodes[0]= lnode;
	for(register int i= 24; i + 1; --i) {
		lnode->childs[0]= newnode(0);
		lnode= lnode->childs[0];
	}
    //初始化,向起始的Trie树插入0
}
inline int read() {
	static char c= getchar();
	int a= 0;
	while(c < '0' || c > '9') c= getchar();
	while(c >= '0' && c <= '9') a= a * 10 + c - '0', c= getchar();
	return a;
}
//快读卡常优化
int n, m, tmpx, tmpl, tmpr, xors[500001];
char tmpy;
int main() {
	init();
	n= read(), m= read();
	for(register int i= 1; i <= n; i++) {
		tmpx= read();
		xors[i]= xors[i - 1] ^ tmpx;
        //根据异或原理维护s(xors)数组
		insert(xors[i]);
	}
	for(register int i= 0; i < m; i++) {
		scanf(" %c", &tmpy);
		if(tmpy == 'A') {
			tmpx= read();
			xors[n + 1]= xors[n] ^ tmpx;
			insert(xors[++n]);
		}
		else {
			tmpl= read(), tmpr= read(), tmpx= read();
			printf("%d\n", find(xors[n] ^ tmpx, tmpl - 1, tmpr - 1));
		}
	}
	return 0;
}
```
### 卡常飞了,卡了一页提交,最后终于T的点卡900+msAC

---

## 作者：Link_Space (赞：8)

修改操作无需多说，看代码内注释即可，主要讲一讲查询操作。

题目要求找出一个 $p$ 满足$L \leqslant p \leqslant R$

并且使得 $a[p] \oplus a[p+1] \oplus a[p+2] .....\oplus a[N] \oplus x$ 最大。

其中 $a[p] \oplus a[p+1] \oplus a[p+2] .....\oplus a[N] \oplus x$

可以化成 $x \oplus sum[N] \oplus a[p-1]$ 

其中 $sum$ 数组为异或前缀和数组。

那么我们就可以很轻松地解决 $p \leqslant R - 1$ 的右边界问题，只需要在 $R-1$ 版本中的 Trie 树中查找最大答案即可。

那么如何解决左边界问题呢？这时我们就需要一个 $last$ 数组，其中记录的是当前节点的子树中最大的下标，在查询时只查询子树中最大的下标大于等于 $L - 1$ 的子树即可。

那么代码实现就很简单了，如果还有不懂的请看代码注释。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N = 6e5 + 5;
const int M = N * 25;
int n, m;
int last[M];
int Tree[M][2];
int root[N];
int tot = 0;
int sum[N];
void insert(int pre,int now,int i,int k)
{
    if(k<0)
    {
        last[now] = i;//修改完所有位数之后记录当前最大下标
        return;
    }
    int to = sum[i] >> k & 1;
    if(pre)
        Tree[now][to ^ 1] = Tree[pre][to ^ 1];//另外一边的子树直接继承即可
    Tree[now][to] = ++tot;
    insert(Tree[pre][to], Tree[now][to], i, k - 1);
    last[now] = max(last[Tree[now][0]], last[Tree[now][1]]);向上传递子树中最大下标
}
int query(int now,int x,int l)
{
    int p = now;
    for (int i = 23; i >= 0;i--)
    {
        int to = x >> i & 1;
        if(last[Tree[p][to^1]]>=l)//只需要查询最大的下标大于等于L-1的子树
            p = Tree[p][to ^ 1];
        else
            p = Tree[p][to];
    }
    return x ^ sum[last[p]];//叶子结点中last存的即是自己的下标值
}
int main()
{
    scanf("%d%d", &n, &m);
    root[0] = ++tot;
    last[0] = -1;
    insert(0, root[0], 23, 0);
    for (int i = 1; i <= n;i++)
    {
        int x;
        scanf("%d", &x);
        sum[i] = sum[i - 1] ^ x;
        root[i] = ++tot;
        insert(root[i - 1], root[i], i, 23);
    }
    char op[2];
    int l, r, x;
    for (int i = 1; i <= m;i++)
    {
        scanf("%s", op);
        if(*op=='A')
        {
            scanf("%d", &x);
            n++;
            sum[n] = sum[n - 1] ^ x;
            root[n] = ++tot;
            insert(root[n - 1], root[n], n, 23);
        }
        else 
        {
            scanf("%d%d%d", &l, &r, &x);
            printf("%d\n", query(root[r - 1], sum[n] ^ x, l - 1));
        }
    }
}
```


---

## 作者：Eric2007_2_20 (赞：8)

## 前言
这是一个可持久化 Trie 问题。
## 思路
### 1. 转化
```
a ^ a = 0
```
异或运算的自反性是解题的关键。

既然涉及到了区间的异或和，那么试着用前缀和的方式转化。
```
设S[i] = S[i-1] ^ a[i],特殊的，S[0] = 0
S[1] = a[1]
S[2] = a[1] ^ a[2]
S[3] = a[1] ^ a[2] ^ a[3]
S[4] = a[1] ^ a[2] ^ a[3] ^ a[4]
...
S[n] = a[1] ^ a[2] ^ a[3] ^ a[4] ^ ... ^ a[n] ^ x
那么 a[p] + a[p+1] + a[p+2] + ... + a[n] = S[n] ^ S[p-1] ^ x
```
不难发现，```S[n] ^ x``` 是一个定值，而唯一待确定的是 ```S[p-1]``` .

这又回到了最大异或对问题，确定了思路是用 Trie。

由于 ```l<=p<=r```，所以```l-1<=p-1<=r-1```，如果照常来做的话，我们只需要记录每一个二进制串末尾的编号即可，可是时间复杂度撑不住。

而且值得一提的是，这次的数组是动态的（要往里面不停地加东西）。

### 2. 算法核心

对于这两个问题，一般的 Trie 很难搞定，于是我们考虑把每一次插入后的版本全部记录下来，0号版本记录空树，1号版本记录第一次插入后的树，2号版本记录第二次插入后的树，以此类推。

这样的话，记录每一个版本还是需要大量的时间，但是如果只记录每次插入后不一样的地方（可持久化的核心思想），就能大大提高效率。

抛开此题，举一个例子，就能理解可持久化的思想。

比如，有四个字符串分别为 "cab" "fry" "rat" "cat"，依次插入，存储每一个版本。

为了方便理解，画了几张草图（~~请各位大佬原谅我的绘画技术~~）
![插入"cab"](https://cdn.luogu.com.cn/upload/image_hosting/35dhjp8q.png)
插入 "cab" 时，由于原树为空，所以直接插入。
![插入"fry"](https://cdn.luogu.com.cn/upload/image_hosting/yw2fqivx.png)
插入 "fry" 时，由于要建的空节点和上一版本一样，所以建节点时，要将上一版本的空节点信息（原先指向'c'）复制一遍，同时建一条新的边留给下一个点'f'，其余直接插入。
![插入"rat"](https://cdn.luogu.com.cn/upload/image_hosting/uoep6jug.png)
插入 "rat" 时，还是将上一空节点的信息复制一遍，同时建一条新的边指向'r'，其余直接插入。
![插入"cat"](https://cdn.luogu.com.cn/upload/image_hosting/qvxpo1vu.png)
插入 "cat" 时，空节点还是复制一遍（指向'c' 'f' 'r'），然而 'c' 是重复的节点，所以再次复制（指向'a'），下一个点 'a' 还是重复节点，所以再次复制信息（指向'b'），然后建一条新的边指向 't'。

分析完成后，进行抽象：

1. 若两节点相同，则复制一遍信息。
1. 建一条边留给下一位。

于是问题解决了。

### 3.编写与构思过程

记录一个 ```max_size[i]``` 表示 i 号节点的最新编号，记录 ```S[i]``` 来表示 1~i 的前缀和，```tr[i][0]``` 表示 i 号节点到值为0的节点在 Trie中的编号，```tr[i][1]``` 表示 i 号节点到值为1的节点在 Trie中的编号，```root[i]``` 表示 Trie 树的第 i 个版本的根节点。

1. 插入

插入的时候，由于是可持久化 Trie，所以必须得传入两个根节点（一个是上一个版本的root,另一个是新版本的root），由于要写递归（~~我用递归写的~~），所以要传入一个计数器，记录已经查到了第几位（由于要先取高位，所以计数器应该一直递减）。

除此之外，还有一个参数是i，用于记录插入时的编号（异或前缀和S的下标），因为左边界 ```l-1``` 也得处理。
```cpp
inline void insert(int i,int k,int p,int q){
    if(k<0){ //k<0 说明已到达边界，直接更新max_id[q]即可
        max_id[q]=i;
        return;
    }
    register int v=s[i] >> k & 1;
    if(p)tr[q][v ^ 1]=tr[p][v ^ 1]; //这行表示复制原来节点的信息，p不可为0是因为0号节点表示不存在
    tr[q][v]=++idx; //创建新节点
    insert(i,k-1,tr[p][v],tr[q][v]); //两个版本全部移到下一位在作计算
    max_id[q]=i; //要最新编号当然是i啦
}
```
2. 查询

~~查询前面说过了~~

这个函数传入3个参数，root表示要查询版本的根节点编号，L表示左边界限制，C表示待匹配的数。
```cpp
inline int query(int root,int C,int L){
    register int p=root;
    for(register int i=23;i>=0;i--){
        register int v=C >> i & 1;
        if(max_id[tr[p][v ^ 1]]>=L)p=tr[p][v ^ 1];
        else p=tr[p][v]; //贪心思想，不知道的话翻一下最大异或对
    }
    return C ^ s[max_id[p]];
}
```
### 4.上代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=6e5+10,M=25*N;
int n,m;
int s[N];
int max_id[M],tr[M][2];
int root[N],idx;
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
inline void write(int n){
    if(n<0){
        putchar('-');
        n=-n;
    } 
    if(n>9)write(n/10);
    putchar(char(n%10+'0'));
}
inline void insert(int i,int k,int p,int q){
    if(k<0){
        max_id[q]=i;
        return;
    }
    register int v=s[i] >> k & 1;
    if(p)tr[q][v ^ 1]=tr[p][v ^ 1];
    tr[q][v]=++idx;
    insert(i,k-1,tr[p][v],tr[q][v]);
    max_id[q]=i;
}
inline int query(int root,int C,int L){
    register int p=root;
    for(register int i=23;i>=0;i--){
        register int v=C >> i & 1;
        if(max_id[tr[p][v ^ 1]]>=L)p=tr[p][v ^ 1];
        else p=tr[p][v];
    }
    return C ^ s[max_id[p]];
}
int main(){
    int x,l,r;
    char op;
    n=read(),m=read();
    max_id[0]=-1; //初始值：-1
    root[0]=++idx; //建造新的根节点
    insert(0,23,0,root[0]);//最初版本
    for(register int i=1;i<=n;i++){
        x=read();
        s[i]=s[i-1]^x; //前缀和更新
        root[i]=++idx; //建造新的根节点
        insert(i,23,root[i-1],root[i]); //创建新的版本
    }
    while(m--){
        op=getchar();
        if(op=='A'){
            x=read();
            n++;
            s[n]=s[n-1]^x;
            root[n]=++idx;
            insert(n,23,root[n-1],root[n]);
        }else{
            l=read(),r=read(),x=read();
            write(query(root[r-1],s[n]^x,l-1));
            putchar('\n');
        }
    }
    return 0;
}
```
由于此题卡常数卡的紧（~~放宽了时限还会超时~~），所以建议用快读快输，~~另外 register 和 inline 能加的都加上~~。

---

## 作者：HomuraCat (赞：6)

可持久化Trie板子题

如果你会主席树的话，我有自信几句话就讲清楚这个算法

如果你不会的话，还是去学学主席树吧。

你肯定是会01trie的，但是01trie加进去就无序了，想想主席树，我们可以将每一次加数都新建一条链，那样就相当于又建了一棵01trie，n个数就会出现n个01trie，然后你有左端点和右端点，记录一下每个点的sum值，接下来就是主席树基操了。

warning:这题卡常，我开O2

```cpp
#include<bits/stdc++.h> 
#define Re register
#define fo(i, a, b) for (Re int i = (a); i <= (b); ++i)
#define fd(i, a, b) for (Re int i = (a); i >= (b); --i)
#define edge(i, u) for (Re int i = head[u], v = e[i].v; i; i = e[i].nxt, v = e[i].v)
#define pb push_back
#define F first
#define S second
#define ll long long
#define inf 10000000000007
#define mp std::make_pair
#define lowbit(x) (x & -x)
#define mod 19260817
#define eps 1e-4
#define itset std::set<node>::iterator
#define lb lower_bound
#define N 18000005
#define ls (k << 1)
#define rs (k << 1 | 1)
char ch;
int b[N], rt[N], t[N][2], sum[N];
int n, m, s, x, cnt, l, r;
inline void split (int x)
{
    fo (i, 0, 24)
    {
        if (x & 1) b[i] = 1; else b[i] = 0;
        x >>= 1;
    }
}
inline void update (int &now, int pk)
{
    now = ++cnt;
    int k = now;
    sum[k] = sum[pk] + 1;
    fd (i, 24, 0)
    {
        t[k][b[i]] = ++cnt;
        t[k][b[i] ^ 1] = t[pk][b[i] ^ 1];
        k = t[k][b[i]]; pk = t[pk][b[i]];
        sum[k] = sum[pk] + 1;
    }
}
inline int query (int pk, int k)
{
    int ret = 0;
    fd (i, 24, 0)
    {
        ret <<= 1;
        if (sum[t[k][b[i] ^ 1]] - sum[t[pk][b[i] ^ 1]] > 0)
        {
            ret |= 1;
            k = t[k][b[i] ^ 1]; pk = t[pk][b[i] ^ 1];
        }
        else
        {
            k = t[k][b[i]]; pk = t[pk][b[i]];
        }
    }
    return ret;
}
int main ()
{
    scanf("%d %d", &n, &m);
    ++n;
    update(rt[1], rt[0]);
    fo (i, 2, n)
    {
        scanf("%d", &x);
        s ^= x;
        split(s);
        update(rt[i], rt[i - 1]);
    }
    fo (i, 1, m)
    {
        ch = getchar(); while (ch != 'A' && ch != 'Q') ch = getchar();
        if (ch == 'A')
        {
            ++n;
            scanf("%d", &x); s ^= x;
            split(s);
            update(rt[n], rt[n - 1]);
        }
        else
        {
            scanf("%d %d %d", &l, &r, &x);
            split(s ^ x);
            printf("%d\n", query(rt[l - 1], rt[r]));
        }
    }
    return 0;
}
```

---

## 作者：Treaker (赞：5)

## 可持久化01Trie树
由于异或相同的数会抵消的性质，我们可以直接求前缀和。

两个前缀和异或即使中间那部分的异或值~~都做这种题了，肯定知道~~

即

$~~~~~~~~~~~~~~~a[l]~xor~ a[l+1]~xor~...~xor~a[r] = a[r]~xor~a[l-1]$

那么我们对于每一个节点建立一颗Trie树，但这样会空间~~瞬间~~爆炸~~送它升天~~，但我们发现每次对于每层只新建一个节点，那么我们在原来的基础上建树，~~也就是可持久化（竟然YY出来了）~~。不难发现，空间复杂度为$~O((n+m)logn)~$，可以接受

然后我就需要在$~l-1~$ 到 $~r-1~$的范围内贪心跳节点即可。

那么我们怎么确定范围呢？，我们对于每一个节点维护一个$~lt~$表示这个节点的子树内树最晚出现的位置~~感性理解一下？~~，跳节点时用$lt$判断是否满足查找范围即可。

完整代码如下：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
inline int read()
{
	int x = 0; char ch = getchar();
	while(ch < '0' || ch > '9') ch = getchar(); 
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + ch - '0'; ch = getchar();}
	return x;
}
const int N = 6e5+5;
int n , m;
int a[N];
char s[1];
struct Persisdent_Trie
{
	struct node
	{
		node *ch[2]; int lt;
		node() { ch[0] = ch[1] = NULL; lt = 0;}
	}*root[N] , pool[N * 20] , *tail;
	Persisdent_Trie() { tail = pool;}
	inline void build()
	{
		node *o = root[0] = new (tail ++) node();
		for(int i = 23;i >= 0;i --) o -> ch[0] = new (tail ++) node() , o = o -> ch[0];
	}
	inline void insert(int id)
	{
		node *o = root[id] = new (tail ++) node() , *p = root[id - 1]; int x = a[id];
		for(int i = 23 , tmp;i >= 0;i --)
		{
			if(p) *o = *p;
			o -> lt = max(o -> lt,id);
			tmp = (x >> i) & 1; o -> ch[tmp] = new (tail ++) node();
			o = o -> ch[tmp]; p = p ? p -> ch[tmp] : NULL;
		}
		o -> lt = max(o -> lt,id);
	}
	int query(node *o,int x,int limit)
	{
		for(int i = 23 , tmp;i >= 0;i --) 
		{
			tmp = (x >> i) & 1;
			if(o -> ch[tmp ^ 1] && o -> ch[tmp ^ 1] -> lt >= limit) o = o -> ch[tmp ^ 1];
			else o = o -> ch[tmp];
		}
		return a[o -> lt] ^ x;
	}
	inline void LOL()
	{
		n = read(); m = read(); build(); 
		for(int i = 1;i <= n;i ++) a[i] = a[i - 1] ^ read() , insert(i);
		for(int i = 1 , l , r , x;i <= m;i ++)
		{
			scanf("%s",s);
			if(s[0] == 'A') n ++ , a[n] = a[n - 1] ^ read() , insert(n);
			else l = read() , r = read() , x = read() , printf("%d\n",query(root[r - 1],a[n] ^ x,l - 1));
		}
	}
}DNF;
int main() { return DNF.LOL() , 0;}
```


---

## 作者：rainygame (赞：4)

设 $S_i=\bigoplus\limits_{j=1}^ia_i$，则询问转化为求 $S_{p-1} \oplus (S_n \oplus x)\ (p \in [l,r])$ 的最大值，$S_n \oplus x$ 为定值，容易想到使用 01Trie 维护。

对于 $p\in [l,r]$ 这个限制，考虑对于 01Trie 上的每个节点维护一个 `vector`，表示哪些下标曾经走过这个结点。那么查询时可以走这个结点，当且仅当这个点存在且维护的 `vector` 里面有 $[l,r]$ 之间的数。

这个可以用二分查询，时间复杂度 $O(n\log n\log V)$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 600001
#define MAXK 24

int n, m;
int a[MAXN], s[MAXN];
char opt;

namespace Trie{
    struct Node{int son[2]; vector<int> idx;};
    vector<Node> tr(1, {{-1, -1}, {}});
    void modify(int x, int ind){
        for (int i(MAXK-1), now(0); ~i; --i){
            if (tr[now].son[(x>>i)&1] == -1){
                tr[now].son[(x>>i)&1] = tr.size();
                tr.push_back({{-1, -1}, {}});
            }
            tr[now=tr[now].son[(x>>i)&1]].idx.push_back(ind);
        }
    }
    bool check(int x, int l, int r){
        if (x == -1) return false;
        auto it(lower_bound(tr[x].idx.begin(), tr[x].idx.end(), l));
        return it != tr[x].idx.end() && *it <= r;
    }
    int query(int x, int l, int r){
        int res(0);
        for (int i(MAXK-1), now(0); ~i; --i){
            if (check(tr[now].son[!((x>>i)&1)], l, r)) now=tr[now].son[!((x>>i)&1)], res+=1<<i;
            else if (check(tr[now].son[(x>>i)&1], l, r)) now=tr[now].son[(x>>i)&1];
            else break;
        }
        return res;
    }
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> m; for (int i(1); i<=n; cin >> a[i++]);
    Trie::modify(0, 0);
    for (int i(1); i<=n; ++i) Trie::modify(s[i]=s[i-1]^a[i], i);

    for (int x, y, z; m; --m){
        cin >> opt >> x;
        if (opt == 'A'){
            a[++n] = x;
            Trie::modify(s[n]=s[n-1]^x, n);
        }else{
            cin >> y >> z;
            cout << Trie::query(z^s[n], x-1, y-1) << '\n';
        }
    }

    return 0;
}

```

---

## 作者：fanfansann (赞：3)

我们维护一个前缀异或和:$s[i] = a[1] \ xor\  a[2]\ xor\  … a[i-1] \ xor\  a[i]$

则$a[p]\ xor\ a[p+1]\ xor\ …\ xor\ a[N]\ xor\ x$ 就相当于 $s[N] \ xor\  x\ xor\ s[p-1]$。

这样$S[N] \ xor\  x$就是一个定值$val$，则相当于求一个 $p$ 满足$l-1 <= p-1 <= r-1$ 使得 $val \ xor\  s[p]$ 值最大。

因为是异或运算，我们可以利用 “最大异或对” 这道题的一些性质，使用 $trie$ 树。我们维护前缀异或和，找到一个 $p$ ，贪心地使得$s[p]$的二进制最高位开始到最低位的每一个数字都尽量与 $val$ 的二进制对应位相反（相同为0不同为1）
前缀异或和的每个版本都可以用持久化的 $trie$ 记录下来。
对持久化 $trie$ 的每个节点额外维护一个信息 $max\_id$ ，表示其所属的最大的持久化版本，显然一个节点的 $max\_id$ 等于其子节点中最大的版本号（因为子节点要么是连向之前的版本，要么创建了该节点后再创建子节点）。 

- 边界$[l-1, r-1]$ 判断：

如果一个节点的 $max\_id$  小于 $l-1$ ，说明这个节点是 $s[l-1]$ 插入之前就已经创建出来的节点，不应该考虑在内。

对持久化树的某一个版本的根节点开始往下访问，所能访问到的节点的版本不会超过该根节点的版本,所以该题只需要从 $r-1$ 版本开始访问即可满足取到的 $p$ 小于等于 $r-1$。

```cpp
//trie树维护的是前缀异或和的二进制01串
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
typedef long long ll;
const int N = 500007, M = N * 25;
/*
template<typename T>inline T read(T &x)
{
    x=0;ll f=1;char c;
    while(!isdigit(c=getchar()))if(c=='-')f=-1;
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*f;
}
*/
int n, m;
int sum[N];
int tr[M][2], max_id[M];
int root[N], idx;
//当前的区间位置（到时候[L,R]对比的就是这里的i）k表示当前是第几位，一共23位2^23，越高越大
void insert(int i, int k, int p, int q){//p上一个版本q下一个版本
    if(k < 0){
        max_id[q] = i;
        return ;
    }
    int v = sum[i] >> k & 1;
    if(p)//如果上个版本的当前结点是有东西的就继承一下
        tr[q][v ^ 1] = tr[p][v ^ 1];
    tr[q][v] = ++ idx;
    insert(i, k - 1, tr[p][v], tr[q][v]);
    max_id[q] = max(max_id[tr[q][0]], max_id[tr[q][1]]);
}

int query(int root, int C, int L){
    int p = root;
    for(int i = 23;i >= 0;i -- ){
        int v = C >> i & 1;
        //如果版本小于L-1，说明这个节点是s[l-1]插入之前就已经创建出来的节点，不应该考虑在内
        if(max_id[tr[p][v ^ 1]] >= L)//如果与当前这一位相反的数存在并且该数的位置在范围以内（求异或相反为1更大）
            p = tr[p][v ^ 1];
        else p = tr[p][v];
    }
    return C ^ sum[max_id[p]];
}

int main(){
    scanf("%d%d", &n, &m);
    max_id[0] = -1;//因为id从0开始这里要取一个更小的
    root[0] = ++ idx;
    insert(0, 23, 0, root[0]);

    for(int i = 1;i <= n; ++ i){
        int x;
        scanf("%d", &x);
        sum[i] = sum[i - 1] ^ x;//前缀异或和
        root[i] = ++ idx;
        insert(i, 23, root[i - 1], root[i]);//可持久化都是跟上一个版本比较

    }
    char op[2];

    int l, r, x;
    while(m -- ){
        scanf("%s", op);
        if(*op == 'A'){
            scanf("%d", &x);
            n ++ ;
            sum[n] = sum[n - 1] ^ x;
            root[n] = ++ idx;
            insert(n, 23, root[n - 1], root[n]);
        }
        else {
            scanf("%d%d%d", &l, &r, &x);
            //l<=p<=r,所以要查询r-1版本的
            printf("%d\n", query(root[r - 1], sum[n] ^ x, l - 1));
        }
    }
}

```


---

## 作者：miaokehao (赞：3)

穿着衣服的可持久化Trie树

首先可以将原问题转化求解区间内s[p - 1] ^ s[N] ^ x的最大值

其中s是前缀异或值

那么，显然对于每次询问s[N]^val的值是一定的，那么也就是用x异或区间内某个值的最大值

有一个神奇的做法叫做可持久化Trie树
```
#include <bits/stdc++.h>
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#define res register int
#define N 15000005
using namespace std;
int n,m,base[32];
char op[5];
inline int read()
{
  int X=0,w=0;
  char ch=0;
  while(!isdigit(ch))
  {
    w|=ch=='-';
    ch=getchar();
  }
  while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
  return w?-X:X;
}
struct Trie_con
{
  int root[N],son[N][2],tot,rtn,sum[N];
  inline void add(res x)
  {
    root[++rtn]=tot+1;
    res last=root[rtn-1];
    for(res i=23; ~i; i--)
    {
      sum[++tot]=sum[last]+1;
      bool b=x&base[i];
      son[tot][b]=tot+1,son[tot][!b]=son[last][!b];
      last=son[last][b];
    }
    sum[++tot]=sum[last]+1;
  }
  inline int query(res lt,res rt,res x)
  {
    if(lt>rt) return 0;
    lt=root[lt-1];
    rt=root[rt];
    res ans=0;
    for(res i=23; ~i; i--)
    {
      bool b=x&base[i];
      if(sum[son[rt][!b]]-sum[son[lt][!b]])
        ans+=base[i],lt=son[lt][!b],rt=son[rt][!b];
      else
        lt=son[lt][b],rt=son[rt][b];
    }
    return ans;
  }
} T;
int main()
{
  n=read(),m=read();
  res now=0;
  base[0]=1;
  for(res i=1; i<=23; i++)
    base[i]=base[i-1]<<1;
  T.add(0);
  for(res i=1; i<=n; i++)
  {
    res x=read();
    T.add(now^=x);
  }
  for(res i=1; i<=m; i++)
  {
    scanf("%s",op);
    if(op[0]=='A')
    {
      res x=read();
      T.add(now^=x);
    }
    else
    {
      res L=read(),R=read(),x=read();
      printf("%d\n",T.query(L,R,now^x));
    }
  }
  return 0;
}
```

---

## 作者：YinyuDream (赞：2)

# 可持久化01trie

设$s_n=a_1\oplus a_2\oplus a_3\oplus ...\oplus a_n$,对于题中所给的对一段区间的询问，我们就可以转化为前缀异或，即$a_p\oplus a_{p+1}\oplus a_{p+2}\oplus ...\oplus a_n\oplus x=s_{p-1}\oplus s_n\oplus x$。这样，问题就转化为了在给定的区间$[L,R]$中，求出与$s_n\oplus x$异或的答案最大的数。于是我们可以建$n$棵01trie,第$i$棵代表区间$[1,i]$的值,并在每个节点存储数字个数,对于每个询问，我们只需将两颗树相减就得到了当前区间的信息。在01trie上，我们从高位到低位贪心，假设$x$最高位为1，如果当前区间由最高为0的数，则一定要选，否则无论如何都不可能比他更优，以此类推，由高到低依次确定每一位的值。

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int maxn=3e7+10;
int n,m,k;
int a[maxn],sum[maxn];
struct tire{
	int size,son[2];
}tree[maxn];
int root[maxn];
int build(int x)
{
	int now=++k;
	tree[now].size=1;
	if(x==0)return now;
	tree[now].son[0]=build(x-1);
	return now;	
}
int update(int pre,int x,int pos)
{
	int now=++k;
	if(pos==0){
		tree[now].size=tree[pre].size+1;
		return now;
	}
	tree[now]=tree[pre];
	tree[now].son[1&(x>>(pos-1))]=update(tree[pre].son[1&(x>>(pos-1))],x,pos-1);
	tree[now].size=tree[tree[now].son[0]].size+tree[tree[now].son[1]].size;
	return now;
}
int query(int pre,int now,int x,int pos)
{
	if(!pos)return 0;
	return (tree[tree[now].son[1^(1&(x>>(pos-1)))]].size-tree[tree[pre].son[1^(1&(x>>(pos-1)))]].size)?
			query(tree[pre].son[1^(1&(x>>(pos-1)))],tree[now].son[1^(1&(x>>(pos-1)))],x,pos-1)+(1<<(pos-1)):
			query(tree[pre].son[1&(x>>(pos-1))],tree[now].son[1&(x>>(pos-1))],x,pos-1);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]),
		sum[i]=sum[i-1]^a[i];
	root[0]=++k;
	for(int i=0;i<=n;i++)
		root[i+1]=update(root[i],sum[i],25);
	for(int i=1,l,r,x;i<=m;i++){
		char opt;
		scanf("\n%c",&opt);
		if(opt=='A')scanf("%d",&x),sum[n+1]=sum[n]^x,root[n+2]=update(root[n+1],sum[n+1],25),n++;
		else{
			scanf("%d%d%d",&l,&r,&x);
			printf("%d\n",query(root[l-1],root[r],x^sum[n],25));
		}
	}
	return 0;
}
```


---

## 作者：nth_element (赞：2)

希望更丰富的展示，请移步[我的博客](https://www.cnblogs.com/nth-element/p/11785037.html)

***

若想要深入学习可持久化0-1Trie树，[传送门]( https://www.cnblogs.com/nth-element/p/11773667.html )。

***

**Description**:

给定数列 $\{a_n\}$ ,支持两种操作：

- 在数列尾添加一个数 $x$ ，数列长度变成 $n+1$ ;
- 给定闭区间 $[l,r]$ 和一个数 $x$ ，求：

$$
\max_{i=l}^{r}\left \{\left(\bigoplus_{j=i}^{n}a_j \right)\bigoplus x\right \}
$$

**Method**: 

定义 $Xorsum_i$ 为 $\bigoplus_{i=1}^{n}a_i$ ,即前缀异或和。我们显然可以得到
$$
\left(\bigoplus_{i=pos}^{n}a_i\right)\bigoplus x=Xorsum_{pos-1}\bigoplus Xorsum_n \bigoplus x
$$

**注**：$x\bigoplus x=0$ , $x \bigoplus 0=x$ 

我们发现 $Xorsum_n\bigoplus x$ 是一个**定值**，我们只需要维护 $Xorsum_{pos-1}$ 即可。

考虑用可持久化0-1Trie树维护。与主席树思路相同 ，我们建立 $n+1$ 个版本的0-1Trie树，查询的时候运用贪心的思路即可。

可持久化线段树同样支持“**前缀和**”的思想，我们最后只需要在第 $r$ 个版本的0-1Trie树上查找 $l$ 位置即可。

本题毒瘤卡常，本人~~人丑常数大~~，用了`fread`等各种卡常操作才通过。并且由于~~luogu评测姬的原因~~（大雾，已经通过的代码又会T掉~~woc~~。卡不过的话，开`o2`吧。

**Code**:

```CPP
#include<bits/stdc++.h>
#define Maxn 600010
#define Maxdep 23
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline void read(int &x)
{
    int f=1;x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
int n,m;
int sum[Maxn];
struct trie
{
    trie *chd[2];
    int symbl;
    trie()
    {
        for(int i=0;i<2;i++) chd[i]=NULL;
        symbl=0;
    }
}*root[Maxn],tree[Maxn<<5],*tail;
void Init(){tail=tree;} 
void build(trie *&p,int dep)
{
    p=new (tail++)trie();
    if(dep<0) return ;
    build(p->chd[0],dep-1);
}
void update(trie *&p,trie *flag,int dep,int i)
{
    p=new (tail++)trie();
    if(flag) *p=*flag;
    if(dep<0) return (void)(p->symbl=i);
    int tmp=(sum[i]>>dep)&1;//判断是1还是0 
    if(!tmp) update(p->chd[0],flag?flag->chd[0]:NULL,dep-1,i);
    else update(p->chd[1],flag?flag->chd[1]:NULL,dep-1,i);
    if(p->chd[0]) p->symbl=std::max(p->symbl,p->chd[0]->symbl);
    if(p->chd[1]) p->symbl=std::max(p->symbl,p->chd[1]->symbl);
}
int query(trie *p,int x,int dep,int limit)
{
    if(dep<0) return sum[p->symbl]^x;
    int tmp=(x>>dep)&1;
    if(p->chd[tmp^1]&&p->chd[tmp^1]->symbl>=limit) return query(p->chd[tmp^1],x,dep-1,limit);
    return query(p->chd[tmp],x,dep-1,limit);
}
signed main()
{
    Init();
    read(n),read(m);
    build(root[0],Maxdep);
    for(int i=1,x;i<=n;i++)
    {
        read(x);
        sum[i]=sum[i-1]^x;
        update(root[i],root[i-1],Maxdep,i);
    } 
    for(int i=1;i<=m;i++)
    {
        char ch=getchar();
        while(ch!='A'&&ch!='Q') ch=getchar();
        if(ch=='A')
        {
            int x;
            read(x);
            n++;
            sum[n]=sum[n-1]^x;
            update(root[n],root[n-1],Maxdep,n);	
            continue;
        }	
        if(ch=='Q')
        {
            int l,r,x;
            read(l),read(r),read(x);
            int ans=query(root[r-1],sum[n]^x,Maxdep,l-1);
            printf("%d\n",ans);
            continue;
        }
    }
    return 0;
}
```



---

## 作者：_ctz (赞：2)

[$My Blog$](https://ctz45562.github.io/2019/03/31/%E6%B4%9B%E8%B0%B7-P4735-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C/)

[传送门](https://www.luogu.org/problemnew/show/P4735)

翻了翻题解，只有我这么蒻不会把后缀异或和转成前缀异或和吗$QAQ$

没有想到转前缀所以蒟蒻暴力维护了后缀异或和。

首先操作离线下来，处理出添加完所有数后数列的状态，直接把所有后缀异或和插入进可持久化$trie$树里。然后倒着处理操作，这样添加就变成了删除。

删除结尾的一个数，剩下的所有后缀异或和都会异或上删掉的数。在全局维护一个$tag$，删一个数就把$tag$异或上它。在查询时只要$tag$这一位上为$1$就要反着走。

不过这题卡常，恰好我这个做法常数比较大，吸氧才能过$QAQ$。

非常神奇的一点：读入字符串用$scanf$ $T$得飞起，换成$cin$就$A$了。数据有锅？

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 300005

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
int siz[maxn<<6],trie[maxn<<6][2],a[maxn<<1],sum[maxn<<1],root[maxn<<1],ans[maxn],top,tag,cnt=1;
#define ls(x) trie[x][0]
#define rs(x) trie[x][1]
struct ORDER{
	int s,l,r,x;	
}o[maxn];
inline void update(int node){
	siz[node]=siz[ls(node)]+siz[rs(node)];
}
void insert(int &node,int ol,int d,int now=25){
	node=++cnt;
	if(now==-1){
		siz[node]=siz[ol]+1;
		return;
	}
	bool k=d&(1<<now);
	trie[node][k^1]=trie[ol][k^1];
	insert(trie[node][k],trie[ol][k],d,now-1);
	update(node);
}
int ask(int node,int ol,int d,int now=25){
	if(now==-1)return 0;
	bool k=(d&(1<<now))^(tag&(1<<now));
    //异或上tag的这一位就相当于：tag这一位上为1方向改变
	if(siz[trie[node][k^1]]-siz[trie[ol][k^1]]>0)return ask(trie[node][k^1],trie[ol][k^1],d,now-1)+(1<<now);
	else return ask(trie[node][k],trie[ol][k],d,now-1);	
}
int main(){
	int n=read(),m=read();
	char ss[2];
	for(register int i=1;i<=n;++i)
		a[i]=read();
	for(register int i=1;i<=m;++i){
		cin>>ss;
		o[i].s=(ss[0]=='Q')+1,o[i].l=read();
		if(o[i].s==1)a[++n]=o[i].l;
		else o[i].r=read(),o[i].x=read();
	}
	for(register int i=n;i;--i)
		sum[i]=sum[i+1]^a[i];
	for(register int i=1;i<=n;++i)
		insert(root[i],root[i-1],sum[i]);
	for(register int i=m;i;--i){
		if(o[i].s==1)tag^=o[i].l;//标记处理
		else ans[++top]=ask(root[o[i].r],root[o[i].l-1],o[i].x);
	}
	while(top)printf("%d\n",ans[top--]);
}
```



---

## 作者：Linne (赞：2)

维护前缀异或和，直接糊一个可持久化trie
具体怎么可持久化，就是每次插入的时候建一个新版本，0和1中的一个孩子指向历史版本即可。
考虑查询，有l和r两重限制，r的限制很简单，直接在r-1的版本中查即可,l怎么办呢，我们在每个节点维护一个值late[x]表示子树中最大版本号。显然查询的时候，符合要求的节点late必然是小于l的,于是就搞完了。

------------

这题卡常，我第一遍cin T了，第二遍快读爆零了，第三遍用了scanf吸氧终于过了QAQ

------------

我代码巨丑Orz
```cpp

#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
#define RE register
#define clear(a) memset(a,0,sizeof a)

inline int read(){
    int date=0,w=1;char c=0;
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
    return date*w;
}

void chkmin(int &x,int y){
    x=min(x,y);
}
void chkmax(int &x,int y){
    x=max(x,y);
}
#define N 600005
int n,m,a[N],s[N],trie[N<<5][2],late[N<<5],tot,root[N];
char tmp[2];
const int bit=23;
void ins(int i,int k,int p,int q){
    if(k<0){
        late[q]=i;
        return;
    }
    int c=s[i]>>k &1;
    if(p)trie[q][c^1]=trie[p][c^1];
    trie[q][c]=++tot ;
    ins(i,k-1,trie[p][c],trie[q][c]);
    late[q]=max(late[trie[q][1]],late[trie[q][0]]);
}
void init(){
    late[0]=-1;
    root[0]=++tot;
    ins(0,23,0,root[0]);
}
int query(int x,int k,int val,int lim){
    if(k<0){
        return val^s[late[x]];
    }
    int c=val>>k &1;
    if(late[trie[x][c^1]]>=lim){
        return query(trie[x][c^1],k-1,val,lim);
    }else return query(trie[x][c],k-1,val,lim);
}
int l,r,x;
int main(){
    scanf("%d%d",&n,&m);
    init();
    for(int i=1;i<=n;++i){
    	scanf("%d",&a[i]);
    	s[i]=s[i-1]^a[i];
    	root[i]=++tot;
    	ins(i,23,root[i-1],root[i]);
    }
    while (m--){
        scanf("%s",tmp);
        if(tmp[0]=='A'){
            scanf("%d",&x);
            ++n;
            s[n]=s[n-1]^x;
            root[n]=++tot;
            ins(n,23,root[n-1],root[n]);
        }else{
            scanf("%d%d%d",&l,&r,&x);
            x^=s[n];
            printf("%d\n",query(root[r-1],23,x,l-1));
        }
        
    }
    return 0;
}


```



---


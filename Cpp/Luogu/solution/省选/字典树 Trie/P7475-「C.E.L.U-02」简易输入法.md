# 「C.E.L.U-02」简易输入法

## 题目背景

YQH 有一个伟大的梦想，他想成为全世界最强的男人。为了实现这一个目标，他准备从一个简易的输入法入手开始征程。

## 题目描述

这个简易输入法原先有一个词典 $\text{U}$，用户输入时，输入法从用户处读入一个字符串 $s$ ，以及一个整数 $x$ 对于这个字符串有以下几种情形：  
设$s_i \in \text{U} $ 且 $s$ 为 $s_i$ 的前缀的个数为 $a$。  

当 $a\ge x$ 时，请输出按照以输出次数从大到小为第一关键字，以字典序为第二关键字排序后的第 $x$ 个 $s_i$，并将其输出次数加 $1$。    

当 $x>a>0$ 时，请输出按照以输出次数从大到小为第一关键字，以字典序为第二关键字排序后的最后一个 $s_i$，并将其输出次数加 $1$。  

当 $a=0$ 时，输出 `404Error`。  

## 说明/提示

### 样例解释 

**样例解释一**

`fat` 为前缀只有 $1$ 个，故输出 `father`，并将其输出次数加 $1$。  
`fa` 为前缀中输出次数最多是 `father`，故输出它，并将其输出次数加 $1$。  
`fan` 为前缀中输出次数都是 $0$，但 `fan` 字典序最小，故输出它，并将其输出次数加 $1$。  
`fan` 为前缀 `fan` 输出次数最多，故输出 `fan`，并将其输出次数加 $1$。  
`fa` 为前缀中输出次数最多是 `fan`，故输出它，并将其输出次数加 $1$。  
`fant` 为前缀只有一个单词 `fantasy`，故输出它，并将其输出次数加 $1$。

 ### 数据范围

| 数据编号 | $n$ | $m$ | $x$ | $\sum str$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1\sim 2$ | $\le100$ | $\le100$ | $=1$ | $\le10^3$ |
| $3\sim 4$ | $\le100$ | $\le100$ | $\diagdown$ | $10^3$ |
| $5\sim 8$ | $\le5\times10^4$ | $\le10^5$ | $=1$ | $\le5\times10^5$ |
| $9\sim 14$ | $\le10^4$ | $\le10^5$ | $\diagdown$ | $\le10^5$ |
| $15\sim 20$ | $\le5\times10^4$ | $\le10^5$ | $\diagdown$ | $\le5\times10^5$ |

对于$100\%$的数据，$|s|,|str|\le10,1\leq x\le10^4$，所有字母都是小写字母。

## 样例 #1

### 输入

```
3
fan
fantasy
father
6
fat 1
fa 1
fan 1
fan 1
fa 1
fant 1```

### 输出

```
father
father
fan
fan
fan
fantasy```

## 样例 #2

### 输入

```
5
uva
usaco
usa
usssu
konjac
11
u 2
u 2
kkk 1
uv 2
us 3
u 4
u 1
u 2
k 1
u 3
usa 1```

### 输出

```
usaco
usa
404Error
uva
usssu
uva
uva
usa
konjac
usaco
usa```

# 题解

## 作者：abruce (赞：6)

19 年就对着自己的输入法出出来的一道题，当初觉得好难，要 n 重数据结构，现在看起来。。。。。。  
还是先来看部分分吧。  
### 10pts  
建一棵 Trie，暴力维护子树最大值，或者干脆 Trie 都不建直接查。  
### 20pts  
建一棵 Trie，暴力将其值排序，然后更新答案。  
### 30pts  
发现最大值只增不减，所以每一个 Trie 的节点上只用记录最大值和那个字符串，每次子树内有东西发生更新就来更新一下自己的最大值，由于 Trie 层数小于等于10，所以复杂度 $O(n)$，是正确的。  
### 50~95 pts  
防止常数过大者变成暴力分。  
## 100pts  
考虑正解。肯定要把字符串集合建成一棵 Trie。它的后缀就相当于 Trie 节点的子树。首先，我们在每一个 Trie 节点开一棵平衡树存入子树内的值和字符串，这样就很方便的维护子树 kth。  
每一次，我们找到了一个对应的字符串，就去所有它的前缀去更新它的值，以便下一次更新。  
如果 Trie 节点不存在，直接输出 `404Error`。  
总的时间复杂度为 $O(nlogn)$。  
代码如下，写的是标准 Trie 套 Splay，有亿点点长。  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e5+5;
int n,m;
struct splaytree {
	int news,cnt;
	splaytree() {
		cnt=0;
	}
	struct tree {
		int sum,f,siz,ch[2];
		string s;
	} t[maxn*10];
	void pushup(int x) {
		t[x].siz=t[t[x].ch[0]].siz+t[t[x].ch[1]].siz+1;
		return;
	}
	void rotate(int x,int &rot) {
		int y=t[x].f,z=t[y].f,L=(t[y].ch[0]!=x),R=L^1;
		if(y==rot) {
			rot=x;
		} else {
			t[z].ch[t[z].ch[0]!=y]=x;
		}
		t[x].f=z;
		t[y].f=x;
		t[t[x].ch[R]].f=y;
		t[y].ch[L]=t[x].ch[R];
		t[x].ch[R]=y;
		pushup(y);
		pushup(x);
	}
	void splay(int x,int &rot) {
		while(x!=rot) {
			int y=t[x].f,z=t[y].f;
			if(y!=rot) {
				if(t[y].ch[0]==x^t[z].ch[0]==y) {
					rotate(x,rot);
				} else {
					rotate(y,rot);
				}
			}
			rotate(x,rot);
		}
	}
	void insert(int rot,int x,string s) {
		if((t[rot].sum<x||(t[rot].sum==x&&t[rot].s>s))&&t[rot].ch[0]) {
			insert(t[rot].ch[0],x,s);
		} else if((t[rot].sum>x||(t[rot].sum==x&&t[rot].s<s))&&t[rot].ch[1]) {
			insert(t[rot].ch[1],x,s);
		} else {
			t[rot].ch[t[rot].sum>x|(t[rot].sum==x&t[rot].s<s)]=++cnt;//注意这里值是从大到小排，符号不要写反，先后顺序不要弄错
			t[cnt].f=rot;
			t[cnt].siz=1;
			t[cnt].sum=x;
			t[cnt].s=s;
			news=cnt;
		}
		pushup(rot);
	}
	int getfront(int rot) {
		int x=t[rot].ch[0];
		while(t[x].ch[1]) {
			x=t[x].ch[1];
		}
		return x;
	}
	int getback(int rot) {
		int x=t[rot].ch[1];
		while(t[x].ch[0]) {
			x=t[x].ch[0];
		}
		return x;
	}
	void del(int &root,int rot,int x,string s) {
		if((t[rot].sum<x||(t[rot].sum==x&&t[rot].s>s))&&t[rot].ch[0]) {
			del(root,t[rot].ch[0],x,s);
		} else if((t[rot].sum>x||(t[rot].sum==x&&t[rot].s<s))&&t[rot].ch[1]) {
			del(root,t[rot].ch[1],x,s);//删除的时候也一样
		} else {
			splay(rot,root);
			int he=getfront(root),ta=getback(root);
			splay(he,root);
			splay(ta,t[he].ch[1]);
			t[rot].f=t[rot].siz=t[rot].sum=t[ta].ch[0]=0;
			t[rot].s="";
			pushup(ta);
			pushup(he);
		}
		pushup(rot);
	}
	int findx(int &rot,int x,string s) {
		if(!rot)return 0;
		int u=rot;
		while(t[u].ch[t[u].sum>x|(t[u].sum==x&t[u].s<s)]&&t[u].sum!=x&&t[u].s!=s) {
			u=t[u].ch[t[u].sum>x|(t[u].sum==x&t[u].s<s)];//这里可能有点丑，意义是从根找到它那一棵子树
		}
		splay(u,rot);
		return t[t[rot].ch[0]].siz-1;
	}
	int findk(int rot,int k) {
		int lsiz=t[t[rot].ch[0]].siz;
		if(!rot)return 0;
		if(lsiz==k-1) {
			return rot;
		} else if(lsiz>=k) {
			return findk(t[rot].ch[0],k);
		} else {
			return findk(t[rot].ch[1],k-lsiz-1);
		}
	}
	void tab(int &root) {
		root=++cnt;
		cnt++;//这里如果写t[++cnt].f=cnt-1;会有UB
		t[cnt].f=cnt-1;
		t[cnt-1].ch[0]=cnt;
		t[cnt].sum=INT_MAX;
		t[cnt-1].sum=INT_MIN+1;//初始化时值的顺序不要弄反
		t[cnt].siz=1;
		t[cnt-1].siz=2;
		t[cnt].s="";
	}
} Splay;
struct Trietree {
	int t[maxn*3][26],cnt,rt[maxn*3];
	Trietree() {
		cnt=0;
	}
	void insert(string s) {
		int root=0,y;
		for(register int i=0; i<s.length(); i++) {
			y=s[i]-'a';
			if(!t[root][y]) {
				t[root][y]=++cnt;
				Splay.tab(rt[cnt]);
			}
			root=t[root][y];
			Splay.insert(rt[root],0,s);
		}
	}
	string ask(string s,int k) {
		int root=0,y;
		for(register int i=0; i<s.length(); i++) {
			y=s[i]-'a';
			if(!t[root][y]) {
				return "404Error";
			}
			root=t[root][y];
		}
		k=min(k,Splay.t[rt[root]].siz-2);//处理第二种情况，先取一个min，注意是siz-2
		int w=Splay.findk(rt[root],k+1),p=Splay.t[w].sum+1;
		string astr=Splay.t[w].s;//astr和p是找到的字符串的值
		root=0;
		for(register int i=0; i<astr.length(); i++) {
			y=astr[i]-'a';
			root=t[root][y];
			Splay.del(rt[root],rt[root],p-1,astr);//注意删除是删值为p-1
			Splay.insert(rt[root],p,astr);
			Splay.splay(Splay.news,rt[root]);
		}
		return astr;
	}
} Trie;
char str[10];
int main() {
	int x;
	string s1;
	scanf("%d",&n);
	for(register int i=1; i<=n; i++) {
		scanf("%s",str);
		s1=str;
		Trie.insert(s1);
	}
	scanf("%d",&m);
	for(register int i=1; i<=m; i++) {
		scanf("%s%d",str,&x);
		s1=str;
		cout<<Trie.ask(s1,x);
	}
	return 0;
}
```  
当然，你也可以通过 DFS 序把 Trie 拍扁，然后在 dfn 序上查询区间第 $k$ 大，时间复杂度 $O(nlog^2n)\sim O(nlog^3n)$。

---

## 作者：幻影星坚强 (赞：4)

补一发树套树的做法。

事先将串扔 trie 树上后得到 dfn 序（即字典序），然后每次询问找到其对应节点后就可知道它所对应的区间。然后就相当于按dfn序排序后在一个区间的字符串里找第 k 大，所以使用树套树，外层用树状数组，内层用以输出次数为下标的权值线段树，在上面二分即可，不过每个节点可能会有多个值，所以叶子节点要使用平衡树寻找 dfn 序第k大。

```cpp
#include <iostream>
#include <cstdio>
#include <map>
#include <algorithm>
#include <cstring>
#include <set>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
const int N = 5e5 + 10;
tree <int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> se[N];
int n, m;
int tot[N << 1], num, zong;
int a[N];
char op[N][3];
int que[N][4];
struct t
{
	int son[2], val;
}tr[N * 160];
int mins[N], dy[N];
int bit[N];
void opt1(int &o, int l, int r, int i, int w)
{
	if(o == 0)o = ++ num;
	tr[o].val += w;
	if(l == r)
	return;
	int mid = (l + r) >> 1;
	if(mid >= i) opt1(tr[o].son[0], l, mid, i, w);
	else opt1(tr[o].son[1], mid + 1, r, i, w);
}
void add(int o, int val)
{
	int pos = a[dy[o]];
	for (; o <= n; o += o & -o)opt1(bit[o], 1, m + 1, pos, val);
}
int to1[20], to2[20], num1, num2;
int bb[20];
int opt2(int l, int r, int k, int gu)
{
	if(l == r)
	{
		int re = 0;
		for (int i = 1; i <= num1; ++ i)
		re += tr[to1[i]].val;
		return *se[l].find_by_order(k - 1 + re);
	}
	int now = 0;
	for (int i = 1; i <= num2; ++ i)
	now += tr[tr[to2[i]].son[0]].val;
	for (int i = 1; i <= num1; ++ i)
	now -= tr[tr[to1[i]].son[0]].val;
	int mid = (l + r) >> 1;
	if(now >= k)
	{
		for (int i = 1; i <= num1; ++ i)
		to1[i] = tr[to1[i]].son[0];
		for (int i = 1; i <= num2; ++ i)
		to2[i] = tr[to2[i]].son[0];
		return opt2(l, mid, k, gu);
	}
	else
	{
		for (int i = 1; i <= num1; ++ i)
		to1[i] = tr[to1[i]].son[1];
		for (int i = 1; i <= num2; ++ i)
		to2[i] = tr[to2[i]].son[1];
		return opt2(mid + 1, r, k - now, gu);
	}
}
int qu(int l, int r, int k)
{
	num1 = num2 = 0;
	memset(to1, 0, sizeof(to1));
	memset(to2, 0, sizeof(to2));
	memset(bb, 0, sizeof(bb));
	for(int i = l - 1; i; i -= i & -i)to1[++ num1] = bit[i];
	for(int i = r; i; i -= i & -i)to2[++ num2] = bit[i];
	memcpy(bb, to1, sizeof(bb));
	return opt2(1, m + 1, k, l - 1);
}
int ch[N * 10][30], siz[N * 10];
int dfn[N * 10], ids[N * 10];
char s[N][12];
void ins(int now)
{
	int o = 0;
	++ siz[o];
	for (int i = 0; i < strlen(s[now]); ++ i)
	{
		if(ch[o][s[now][i] - 'a'] == 0)
		ch[o][s[now][i] - 'a'] = ++ num;
		o = ch[o][s[now][i] - 'a'];
		++ siz[o];
	}
	ids[o] = now;
}
void dfs(int o)
{
	mins[o] = 1e9;
	for (int i = 25; i >= 0; -- i)
	if(ch[o][i])
	dfs(ch[o][i]), mins[o] = min(mins[o], mins[ch[o][i]]);
	if(ids[o])
	dfn[ids[o]] = ++ num, dy[num] = ids[o], mins[o] = min(mins[o], num);
}
char f[12];
int find()
{
	int o = 0;
	for (int i = 0; i < strlen(f); ++ i)
	{
		if(ch[o][f[i] - 'a'] == 0)
		return -1;
		o = ch[o][f[i] - 'a'];
	}
	return o;
}
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; ++ i)
	{
		scanf("%s", s[i]);
		ins(i);
	}
	num = 0;
	dfs(0);
	scanf("%d", &m);
	num = 0;
	for (int i = 1; i <= n; ++ i)
	{
		a[i] = 1;
		add(i, 1);
		se[a[i]].insert(i);
	}
	for (int i = 1; i <= m; ++ i)
	{
		int k;
		scanf("%s%d", f, &k);
		int now = find();
		if(now <= 0)
		printf("404Error\n");
		else
		{
			if(k > siz[now])
			k = siz[now];
			k = siz[now] - k + 1;
			int pos = qu(mins[now], mins[now] + siz[now] - 1, k);
			if(pos < 0 || pos > n)
			{
				printf("404Error\n");
				continue;
			}
			printf("%s\n", s[dy[pos]]);
			add(pos, -1);
			se[a[dy[pos]]].erase(pos);
			++ a[dy[pos]];
			se[a[dy[pos]]].insert(pos);
			add(pos, 1);
		}
	}
}
```


---

## 作者：lzyqwq (赞：3)

**[cnblogs](https://www.cnblogs.com/MnZnOIerLzy/articles/17768537.html)**

**[题目传送门](https://www.luogu.com.cn/problem/P7475)**

> - 给出 $n$ 个字符串 $s_1\sim s_n$。每个字符串有两个属性，输出次数和字典序。称字符串 $x$ 小于字符串 $y$，当且仅当 $x$ 的输出次数大于 $y$，或 $x$ 的输出次数等于 $y$ 且 $x$ 的字典序小于 $y$。
>
> - 有 $m$ 次询问，每次给出一个询问串 $str_i$，求出以 $str_i$ 为前缀的所有字符串中，第 $k$ 小的字符串。回答完后，将这个字符串的输出次数 $+1$。
>
> - $n\le 5\times 10^4$，$m\le 10^5$，$\sum\limits_{i=1}^m |str_i|\le 5\times 10^5$，$\color{red}\boldsymbol{\max\limits_{i=1}^n |s_i|\le 10}$。字符集为英文小写字母集合，即 $\Sigma=\{\texttt{a},\texttt{b},\dots,\texttt{z}\}$，满足 $|\Sigma|= 26$。

某个消愁没看见最后一个限制，做法复杂了亿点，我不说是谁。~~没错，就是我。~~



------------
**【方法一】**

先介绍一下不依赖字符串长度限制，时间、空间复杂度稍劣的做法。

看到前缀的问题，考虑对字符串集合建立 Trie 树，假设 $str_i$ 对应了 Trie 树上根到点 $u$ 的链，则符合条件的字符串的结束节点 $v$ **一定在 $\boldsymbol u$ 的子树中**。

考虑将子树限制转化为 $dfn$ 序的限制，记 $ed_u$ 为以 $u$ 为根的子树中最大的 $dfn$ 序，则要求在 $[dfn_u,ed_u]$ 中第 $k$ 小的值。

使用树状数组套平衡树解决这个问题，支持查询某个区间内小于某个给定值的值个数。先求出第 $k$ 小值的输出次数，不难发现这个输出次数一定满足，**它是最大的一个值，满足输出次数小于它的个数 $\boldsymbol {<k}$**。二分求出这个值即可。

至于字典序，可以在 dfs 的时候**优先遍历字典序小的字母的边，将字典序的大小关系转化成 $\boldsymbol {dfn}$ 序的大小关系**。也可以类似地二分找到第 $k$ 小值字典序大小。

找出第 $k$ 小值后，将其从树状数组套平衡树中删除，将其输出次数 $+1$ 后，再插入回去。

时间复杂度为 $\mathcal{O}(m\log m\cdot \log (\sum_{i=1}^n|s_i|)\cdot \log n)$，空间复杂度为 $\mathcal{O}(n\log(\sum_{i=1}^n|s_i|)+(\sum_{i=1}^n|s_i|)\cdot |\Sigma|)$。实际效率甚至不如某些暴力。

**[提交记录（TLE 55pts）](https://www.luogu.com.cn/record/129800425) [代码](https://www.luogu.com.cn/paste/bc388j0k)**



------------
**【方法二】**

我们注意到，【方法一】中拍平成 $dfn$ 序的目的，就是为了表示某一棵子树的平衡树。那么我们能不能直接在每一个节点处维护以其为根的子树中所有值的平衡树呢？

答案是可以的，注意到 $\color{red}\boldsymbol{\max\limits_{i=1}^n |s_i|\le 10}$，即**一个字符串的结束位置在 Trie 上到根的路径上不超过 $\boldsymbol{\mathcal{O}(\max_{i=1}^n |s_i|)}$ 个点**，说明**一个值最多只会在 $\boldsymbol{\mathcal{O}(\max_{i=1}^n |s_i|)}$ 棵平衡树中出现**。

这样一来，我们若找到第 $k$ 小的串在 Trie 中的结束位置，当这个串发生变化时，我们可以**暴力修改这个位置及其所有祖先的平衡树**。

而且，我们根据排名查值的操作变成在一棵完整的平衡树中进行而不是一个序列上，不需要二分出某个排名的值。

找到第 $k$ 小的字符串后，可以根据它的 $dfn$ 序确定 Trie 上包含它的所有子树，在这些子树的平衡树中将其删去，将其输出次数 $+1$ 后，再插入回去。

这么一来，时间复杂度优化至 $\mathcal{O}((n+m)\log n\cdot (\max_{i=1}^n|s_i|)+(\sum_{i=1}^n|s_i|)\cdot |\Sigma|)$，空间复杂度优化至 $\mathcal{O}((\sum_{i=1}^n|s_i|)\cdot |\Sigma|+n\cdot (\max_{i=1}^n|s_i|))$。

**[提交记录（AC 100pts）](https://www.luogu.com.cn/record/129814822)** **[AC 代码](https://www.luogu.com.cn/paste/e2nvyqde)**



------------
**【方法三】**

拍平成 $dfn$ 序后和 [P5356](https://www.luogu.com.cn/problem/P5356) 一样分块，笔者没有实现，读者可以自行尝试。

根号的做法其实挺多，时间、空间复杂度也不太好说，可以参考 [P5356 题解区](https://www.luogu.com.cn/problem/solution/P5356)中的各种做法。

---

## 作者：Cxny (赞：2)

## Preface

平衡树是不可能手打的，绝对不可能的。（

字典树套平衡树。~~奇怪的树套树增加了！~~

## Solution

对于多组模式串前缀相关的问题，第一时间想到字典树。

插入时与普通字典树相同。

询问要求**动态**维护所有**文本串是该串前缀**的模式串中**依次按出现次数、字典序**排序后位于第 $k$ 位的数。

字典序可以转化为字典树上的 dfs 序，这样能够避免大量的字符串比较。

平衡树显然可以维护查询（即查找排名为 $k$ 的字符串）。但平衡树码量太大不想写，怎么办？

- Method 1

使用 set。~~时间复杂度似乎不太正确……~~

理论最坏时间复杂度为 $O(nq\log n)$ ，但数据过水，稍加卡常可以通过。

```cpp
//Author: Cxny
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define fi first
#define se second
const int maxn = 5e4 + 10, maxm = 1e5 + 10, maxl = 5e5 + 10;
int n, m, son[maxl][26], cnt = 0, ind[maxl], dfn[maxl], res[maxm], tot = 0, used[maxm];
set<pair<int, pair<int, int>>> t[maxl];
void insert(string s, int x){
	int u = 0;
	for(int i = 0; s[i]; i++){
		if(!son[u][s[i] - 'a']) son[u][s[i] - 'a'] = ++cnt;
		u = son[u][s[i] - 'a'];
	}
	ind[u] = x;
}
int query(string s){
	int u = 0;
	for(int i = 0; s[i]; i++){
		if(!son[u][s[i] - 'a']) return -1;
		u = son[u][s[i] - 'a'];
	}
	return u;
}
void dfs(int u){
	dfn[u] = ++tot;
	if(ind[u]) res[ind[u]] = tot;
	for(int i = 0; i < 26; i++) if(son[u][i]) dfs(son[u][i]);
}
void build(string s, int x){
	int u = 0;
	for(int i = 0; s[i]; i++){
		u = son[u][s[i] - 'a'];
		t[u].insert({0, {res[x], x}});
	}
}
void modify(string s, int x){
	int u = 0;
	for(int i = 0; s[i]; i++){
		u = son[u][s[i] - 'a'];
		auto it = t[u].find({-used[x], {res[x], x}});
		t[u].erase(it), t[u].insert({-used[x] - 1, {res[x], x}});
	}
}
string s[maxn];
int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) cin >> s[i], insert(s[i], i);
	dfs(0);
	for(int i = 1; i <= n; i++) build(s[i], i);
	scanf("%d", &m);
	for(int i = 1; i <= m; i++){
		string q; int k;
		cin >> q >> k;
		int pos = query(q);
		if(pos == -1) puts("404Error");
		else{
			if(k > (int)t[pos].size()) k = t[pos].size();
			int x;
			if(k <= (int)t[pos].size() / 2){
				auto it = t[pos].begin(); 
				while(--k) it++;
				x = it->se.se;
			}else{
				auto it = t[pos].rbegin(); int sz = t[pos].size();
				while(++k <= sz) it++;
				x = it->se.se;
			}
			cout << s[x] << endl;
			modify(s[x], x);
			used[x]++;
		}
	}
	return 0;
}
```

- Method 2

使用 pbds 中定义的平衡树。（考场可用。）
```cpp
//Author: Cxny
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
using namespace __gnu_pbds;
#define ll long long
#define fi first
#define se second
const int maxn = 5e4 + 10, maxm = 1e5 + 10, maxl = 5e5 + 10;
int n, m, son[maxl][26], cnt = 0, ind[maxl], dfn[maxl], res[maxm], sz[maxl], tot = 0, used[maxm];
tree<pair<int, pair<int, int>>, null_type, less<pair<int, pair<int, int>>>, rb_tree_tag, tree_order_statistics_node_update> t[maxl];
void insert(string s, int x){
	int u = 0;
	for(int i = 0; s[i]; i++){
		if(!son[u][s[i] - 'a']) son[u][s[i] - 'a'] = ++cnt;
		u = son[u][s[i] - 'a'];
	}
	ind[u] = x;
}
int query(string s){
	int u = 0;
	for(int i = 0; s[i]; i++){
		if(!son[u][s[i] - 'a']) return -1;
		u = son[u][s[i] - 'a'];
	}
	return u;
}
void dfs(int u){
	dfn[u] = ++tot;
	if(ind[u]) res[ind[u]] = tot;
	for(int i = 0; i < 26; i++) if(son[u][i]) dfs(son[u][i]);
}
void build(string s, int x){
	int u = 0;
	for(int i = 0; s[i]; i++){
		u = son[u][s[i] - 'a'], sz[u]++;
		t[u].insert({0, {res[x], x}});
	}
}
void modify(string s, int x){
	int u = 0;
	for(int i = 0; s[i]; i++){
		u = son[u][s[i] - 'a'];
		auto it = t[u].lower_bound({-used[x], {res[x], x}});
		t[u].erase(it), t[u].insert({-used[x] - 1, {res[x], x}});
	}
}
string s[maxn];
int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) cin >> s[i], insert(s[i], i);
	dfs(0);
	for(int i = 1; i <= n; i++) build(s[i], i);
	scanf("%d", &m);
	for(int i = 1; i <= m; i++){
		string q; int k;
		cin >> q >> k;
		int pos = query(q);
		if(pos == -1) puts("404Error");
		else{
			if(k > sz[pos]) k = sz[pos];
			auto it = t[pos].find_by_order(k - 1);
        //注意 pbds 平衡树中排名从 0 开始
			int x = it->se.se;
			cout << s[x] << endl;
			modify(s[x], x);
			used[x]++;
		}
	}
	return 0;
}
```

---

## 作者：5k_sync_closer (赞：2)

这么好的题竟然没人写 FHQ，我来补上。

前置知识：Trie，FHQ_Treap。
# 思路
我们知道，若 Trie 上从根到 $x$ 的路径表示字符串 $s$，

则以 $x$ 为根的子树可以表示有前缀 $s$ 的字符串的集合。

举个例子，样例 2：

![](https://cdn.luogu.com.cn/upload/image_hosting/gyb0sft2.png)

以 $\text{1u}$ 为根的子树可以表示有前缀 $\text u$ 的字符串的集合 $\{\text{usa},\text{usaco},\text{usssu},\text{uva}\}$，

以 $\text{4s}$ 为根的子树可以表示有前缀 $\text{us}$ 的字符串的集合 $\{\text{usa},\text{usaco},\text{usssu}\}$，

以 $\text{5a}$ 为根的子树可以表示有前缀 $\text{usa}$ 的字符串的集合 $\{\text{usa},\text{usaco}\}$，其他节点以此类推。

所以，对于每次询问 $s$，在 Trie 上找到有前缀 $s$ 的字符串的集合，

答案即为集合中以输出次数降序为第一关键字，以字典序升序为第二关键字的第 $x$ 大。

每次询问后将输出的字符串出现次数加一，更新所有包含这个字符串的集合。

用平衡树维护每个节点上的集合即可。

有 $O(n|s|)$ 个集合，插入操作复杂度为 $O(|s|\log n)$，

所有询问要访问 $O(m|s|)$ 个集合，查询与更新复杂度为 $O(|s|\log n)$，

则总复杂度为 $O((n+m)|s|^2\log n)$，可以过掉。
# 代码
比大部分 Splay 短一半，快 1s。
```cpp
#include <string>
#include <cstdlib>
#include <iostream>
using namespace std;
int n, m, z, x;string s, q;
struct P
{
	int x;string s;inline P operator++() {return P{x, s + '\0'};}
	inline bool operator<(P p) {return x == p.x ? s < p.s : x > p.x;}
}p;
struct F
{
	F *l, *r;P v;int k, s;
	inline F(P _) : l(0), r(0), v(_), k(rand()), s(1) {}
	inline void p() {s = 1;if(l) s += l->s;if(r) s += r->s;}
}*a, *b, *c;
void S(F *x, P v, F *&a, F *&b)
{
	if(!x) {a = b = 0;return;}
	if(x->v < v) a = x, S(x->r, v, a->r, b), a->p();
	else b = x, S(x->l, v, a, b->l), b->p();
}
F *M(F *a, F *b)
{
	if(!a) return b;if(!b) return a;
	if(a->k < b->k) {a->r = M(a->r, b);a->p();return a;}
	else {b->l = M(a, b->l);b->p();return b;}
}
struct T
{
	T *d[26];F *r = 0;
	inline void I(P v) {S(r, v, a, b);r = M(a, M(new F(v), b));}
	inline void D(P v) {S(r, v, a, b);S(b, ++v, b, c);r = M(a, c);delete b;}
	inline P K(int k)
	{
		a = r;k = min(k, a->s);while(1)
		{
			z = a->l ? a->l->s : 0;if(k == z + 1) return a->v;
			if(k <= z) a = a->l;else k -= z + 1, a = a->r; 
		}
	}
}*r = new T(), *t;
int main()
{
	ios::sync_with_stdio(0);cin.tie();cout.tie();
	srand(388651);cin >> n;while(n--)
	{
		cin >> s;t = r;for(int i = 0;i < s.length();++i)
			(t = t->d[x = s[i] - 'a'] ? t->d[x] : t->d[x] = new T())->I(P{0, s});
	}
	cin >> m;while(m--)
	{
		cin >> s >> z;t = r;for(int i = 0;i < s.length();++i)
			if(!(t = t->d[s[i] - 'a'])) {cout << "404Error" << endl;break;}
		if(!t) continue;cout << (q = (p = t->K(z)).s) << endl;
		x = p.x;t = r;for(int i = 0;i < q.length();++i)
			(t = t->d[q[i] - 'a'])->D(p), t->I(P{x + 1, q});
	}
	return 0;
}
```
注意 `struct  P` 中重载 `operator++` 处理删除操作的技巧。
# 小优化
实际上，每个节点的字符串集合中，字符串有公共前缀。

我们可以把这个公共前缀省掉，只存每个字符串的后缀。

但实际优化效果并不明显（~~应该是写丑了~~），给出参考代码：
```cpp
#include <string>
#include <cstdlib>
#include <iostream>
using namespace std;
int n, m, z, x;string s, q;
struct P
{
	int x;string s;inline P operator++() {return P{x, s + '\0'};}
	inline bool operator<(P p) {return x == p.x ? s < p.s : x > p.x;}
}p;
struct F
{
	F *l, *r;P v;int k, s;
	inline F(P _) : l(0), r(0), v(_), k(rand()), s(1) {}
	inline void p() {s = 1;if(l) s += l->s;if(r) s += r->s;}
}*a, *b, *c;
void S(F *x, P v, F *&a, F *&b)
{
	if(!x) {a = b = 0;return;}
	if(x->v < v) a = x, S(x->r, v, a->r, b), a->p();
	else b = x, S(x->l, v, a, b->l), b->p();
}
F *M(F *a, F *b)
{
	if(!a) return b;if(!b) return a;
	if(a->k < b->k) {a->r = M(a->r, b);a->p();return a;}
	else {b->l = M(a, b->l);b->p();return b;}
}
struct T
{
	T *d[26];F *r = 0;
	inline void I(P v) {S(r, v, a, b);r = M(a, M(new F(v), b));}
	inline void D(P v) {S(r, v, a, b);S(b, ++v, b, c);r = M(a, c);delete b;}
	inline P K(int k)
	{
		a = r;k = min(k, a->s);while(1)
		{
			z = a->l ? a->l->s : 0;if(k == z + 1) return a->v;
			if(k <= z) a = a->l;else k -= z + 1, a = a->r; 
		}
	}
}*r = new T(), *t;
int main()
{
	ios::sync_with_stdio(0);cin.tie();cout.tie();
	srand(388651);cin >> n;while(n--)
	{
		cin >> s;t = r;for(auto i = s.begin(), l = s.end();i != l;++i)
			(t = t->d[x = *i - 'a'] ? t->d[x] : t->d[x] = new T())->I(P{0, string(i + 1, l)});
	}
	cin >> m;while(m--)
	{
		cin >> s >> z;t = r;for(int i = 0;i < s.length();++i)
			if(!(t = t->d[s[i] - 'a'])) {cout << "404Error" << endl;break;}
		if(!t) continue;cout << (s += (q = (p = t->K(z)).s)) << endl;
		x = p.x;t = r;for(auto i = s.begin(), l = s.end();i != l;++i)
			q = string(i + 1, l), (t = t->d[*i - 'a'])->D(P{x, q}), t->I(P{x + 1, q});
	}
	return 0;
}
```

---

## 作者：JimmyLee (赞：0)

# 题意

>给定词典 $\text{U}$，每次询问读入一个字符串 $s$，以及一个整数 $x$ 对于这个字符串有以下几种情形： 
>
>设$s_i \in \text{U}$ 且 $s$ 为 $s_i$ 的前缀的个数为 $a$。  
>
>当 $a\ge x$ 时，请输出按照以输出次数从大到小为第一关键字，以字典序为第二关键字排序后的第 $x$ 个 $s_i$，并将其输出次数加 $1$。    
>
>当 $x>a>0$ 时，请输出按照以输出次数从大到小为第一关键字，以字典序为第二关键字排序后的最后一个 $s_i$，并将其输出次数加 $1$。  
>
>当 $a=0$ 时，输出 `404Error`。
>

# 分析

前缀相关的统计操作，考虑使用 Trie。

带修改查询第 $x$ 大，考虑使用平衡树。

在每个 Trie 节点上维护一棵平衡树，维护所有包含该前缀的 $s_i$ 以及该串输出次数。

因为 $|s_i|\leq 10$，所以修改的时候直接模拟插入过程暴力修改每个节点上的平衡树的值。

查询的时候在尾节点上询问即可。

时间复杂度 $O((n+q)|s|\log n)$。

# Code

因为不想重载运算符所以维护的是输出次数的相反数。

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
using namespace __gnu_pbds;

struct node
{
    node* ch[26];
    tree<pair<int, string>, null_type, less<pair<int, string>>, 
         rb_tree_tag, tree_order_statistics_node_update> tr;
    node() {memset(ch, 0, sizeof ch);}
}*rt=new node;
unordered_map<string, int> mpt;

void insert(string s)
{
    node *x=rt;
    for(auto c:s)
    {
        x->tr.insert({0, s});
        if(!x->ch[c-'a']) x->ch[c-'a']=new node;
        x=x->ch[c-'a'];
    }
    x->tr.insert({0, s});
    mpt[s]=0;
}

void modify(string s)
{
    node *x=rt;
    int v=mpt[s];
    for(auto c:s)
    {
        x->tr.erase({v, s});
        x->tr.insert({v-1, s});
        x=x->ch[c-'a'];
    }
    x->tr.erase({v, s});
    x->tr.insert({v-1, s});
    mpt[s]--;
}

string query(string s, int v)
{
    node *x=rt;
    for(auto c:s)
    {
        if(!x->ch[c-'a']) return "404Error";
        x=x->ch[c-'a'];
    }
    string p=x->tr.find_by_order(min(v, (int)x->tr.size())-1)->second;
    modify(p);
    return p;
}

int main()
{
    int n, t, x;
    string p;
    cin>>n;
    for(int i=1;i<=n;i++) cin>>p, insert(p);
    cin>>t;
    while(t--)  cin>>p>>x, cout<<query(p, x)<<'\n';
}
```

---


# [CoE R5] 斑马王子

## 题目背景

#### 注意：此题 Sub #4 中 $opt_i=3$，可视作 $opt_i=0$。数据将稍后修复，修复后将另行通知。

#### UPD: 已修复。

## 题目描述

**题意简述**

有一长度为 $k+1$ 的数组 $s$，下标依次为 $0$ 到 $k$，初始时有 $s_i = 0 \ (0 \leqslant i \leqslant k)$。
接下来给定 $n$ 个非负整数二元组 $(l_i,\ r_i)$，记 $T = \bigcup\limits_{i = 1}^n [l_i,\ r_i] $，将所有符合 $i \in T \bigcap \mathbb{Z}$ 的 $s_i$ 赋值为 $1$。
在任意时刻，记 $S =\{ x |x \in \mathbb{Z} \bigwedge x \in [0,\ k] \bigwedge s_x = 0 \}$。接下来给定 $m$ 个非负整数三元组 $(opt_i,\ a_i,\ b_i)$。

当 $opt_i = 0$ 时，求：

$$t_i = \sum\limits_{x = a_i}^{b_i} \min\limits_{y \in S}(x \oplus y)$$

当 $opt_i = 1$ 时，将所有符合 $i \in [a_i,\ b_i] \bigcap \mathbb{Z}$ 的 $s_i$ 赋值为 $1$。

当 $opt_i = 2$ 时，将所有符合 $i \in [a_i,\ b_i] \bigcap \mathbb{Z}$ 的 $s_i$ 赋值为 $0$。

符号 $\mathbb{Z}$ 表示全体整数，$\oplus$ 表示异或。

---

**原版题面**

『斑马王子』统治着无垠的草原。

一条小河无息地流淌在草原的中央，与河流源头距离为 $y$ 的草地被赋予了 $y \ (0 \leqslant y \leqslant k)$ 的『膜力』。

第 $x \ (0 \leqslant x \leqslant k)$ 天，『斑马王子』的『潜力智商』为 $x$。

他会来到一片自己心仪的草地用膳，并以 $x \oplus y$ 的『智商』开始新的一天。

有一种叫『猎人』的生物，热衷于剥夺草原居民的生命。

他们初始时设立了 $n$ 个形如 $(l_i,\ r_i) \ (0 \leqslant l_i \leqslant r_i \leqslant k)$ 的营地，用『枪』屠杀着所有在 $[l_i,\ r_i]$ 中驻足的生灵。

作为『斑马王子』的得力大臣，你需要回答他的若干个问题，以保证草原的安全。

在风云变幻的草原上，会依次发生 $m$ 个形如 $(opt_i,\ a_i,\ b_i) \ (0 \leqslant a_i \leqslant b_i \leqslant k , \ opt_i \in \{0,\ 1,\ 2\})$ 的事件。

当 $opt_i = 1$ 时，事件 $i$ 代表猎人在 $[a_i,\ b_i]$ 中全部驻扎了新营地。

当 $opt_i = 2$ 时，事件 $i$ 代表斑马王子英勇的部队摧毁了 $[a_i,\ b_i]$ 中的全部营地。

而当 $opt_i = 0$ 时，斑马王子向你发出了灵魂拷问：

每一个问题中，『斑马王子』希望从第 $a_i$ 到第 $b_i$ 天 $(0 \leqslant a_i \leqslant b_i \leqslant k)$，在非『猎人』营地的草地用膳。『斑马王子』希望知道从第 $a_i$ 到 $b_i$ 天，『智商』之和的最小可能值 $t_i$。

你苦思冥想，忽然，『枪』的吼叫声撕裂了空气，如果不在 $1 \ sec$ 内回答问题 $\dots \dots$

## 说明/提示

**数据范围**

**本题采用捆绑测试。**

$\texttt{Subtask 1 (5 pts)}$：对于 $5\%$ 的数据，保证 $0 \leqslant n,m,k \leqslant 20$。

$\texttt{Subtask 2 (5 pts)}$：对于 $5\%$ 的数据，保证 $0 \leqslant n,m,k \leqslant 500$。

$\texttt{Subtask 3 (15 pts)}$：对于 $15\%$ 的数据，保证 $0 \leqslant n,m,k \leqslant 4000$。

$\texttt{Subtask 4 (5 pts)}$：对于 $5\%$ 的数据，保证 $opt_i = 0$。

$\texttt{Subtask 5 (70 pts)}$：无特殊限制。

对于 $100 \%$ 的数据， $0 \leqslant n,\ m,\ k \leqslant 2 \times 10^5$，$0 \leqslant l_i \leqslant r_i \leqslant k$，$0 \leqslant a_i \leqslant b_i \leqslant k$，$opt_i \in \{0,\ 1,\ 2\}$。

## 样例 #1

### 输入

```
0 16 3
0 0 3
1 3 3
0 0 3
1 1 2
0 0 3
2 1 3
0 0 3
1 0 0
1 1 1
0 0 3
0 1 2
0 1 3
1 2 3
0 2 3
2 3 3
0 2 3```

### 输出

```
0
1
6
0
4
2
2
Death
1```

# 题解

## 作者：CaiZi (赞：0)

首先序列长度不是 $2$ 的次幂非常难受，考虑把它补成 $2$ 的次幂，多余的位置 $s_i=1$。然后考虑把这些东西插入 01-trie。以下记 $dep_i$ 为节点 $i$ 距离最近叶子节点的距离（不是传统的定义），那么点 $i$ 的子树的叶子个数为 $2^{dep_i}$，若点 $i$ 这一位为 $1$，则贡献为 $2^{dep_i-1}$。

然后我们要知道，01-trie 和线段树是等价的。对于点 $i$ 的子树的叶子，其在从高往低数前 $i$ 位是相同的，这启发我们在线段树上将其拆成 $\log n$ 个长度为 $2^l$ 的区间处理，然后分别处理。

我们先考虑从点 $1$ 到点 $i$ 这一段拼接而成的数的最小贡献，直接在 01-trie 上贪心，能走数字相同的点就走，否则若当前在点 $j$，会有 $2^{dep_i}\times2^{dep_j-1}$ 的贡献（前面为贡献的点的个数，后面为单个点贡献的值）。

我们再考虑点 $i$ 的子树的最小贡献，首先高位尽量相同肯定是更优的，因此不能破坏前一步走的路径，设当前在点 $j$，我们本质上要求的就是点 $j$ 的子树的最小贡献，设为 $val_j$，考虑标记合并。记 $lc,rc$ 分别为左右儿子。
- 如果左右子树都可以走，则左右子树中的叶子均没有任何贡献，$val_j$ 为 $val_{lc}+val_{rc}$。
- 如果只有左子树可以走，因为右子树除了右儿子以外的其他部分和左子树是一样的，同时右子树的所有叶子都需要额外加上右儿子的贡献，$val_j$ 为 $2val_{lc}+2^{dep_j-1}\times2^{dep_j-1}$。只有右子树可以走的情况同理。
- 否则，$val_j$ 为 $-1$，表示点 $j$ 的子树不可以走。

修改操作直接上线段树打懒标记，如果点 $i$ 对应的区间全被修改为 $0$，$val_i$ 改为 $-1$，否则 $val_i$ 改为 $0$。

时间复杂度 $O(n\log n+m\log^2n)$。

01-trie 的题直接讲都非常抽象，建议配合代码理解。代码展示：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int v,n,m,k,dep[524288],val[524288],tag[524288];
inline void pushup(int p){
	if(val[p<<1]!=-1&&val[p<<1|1]!=-1){
		val[p]=val[p<<1]+val[p<<1|1];
	}
	else if(val[p<<1]!=-1){
		val[p]=(val[p<<1]<<1)+((int)(1)<<(dep[p]<<1)-2);
	}
	else if(val[p<<1|1]!=-1){
		val[p]=(val[p<<1|1]<<1)+((int)(1)<<(dep[p]<<1)-2);
	}
	else{
		val[p]=-1;
	}
}
inline void pushdown(int p){
	if(tag[p]!=-1){
		if(tag[p]){
			val[p<<1]=val[p<<1|1]=0;
		}
		else{
			val[p<<1]=val[p<<1|1]=-1;
		}
		tag[p<<1]=tag[p<<1|1]=tag[p];
		tag[p]=-1;
	}
}
inline void build(int l,int r,int p,int t){
	tag[p]=-1;
	dep[p]=t;
	if(l==r){
		if(l>n){
			val[p]=-1;
		}
		return;
	}
	build(l,l+r>>1,p<<1,t-1);
	build((l+r>>1)+1,r,p<<1|1,t-1);
	pushup(p);
}
inline void update(int l,int r,int p,int a,int b,int c){
	if(a<=l&&r<=b){
		tag[p]=c;
		if(c){
			val[p]=0;
		}
		else{
			val[p]=-1;
		}
		return;
	}
	pushdown(p);
	if(a<=(l+r>>1)){
		update(l,l+r>>1,p<<1,a,b,c);
	}
	if(b>(l+r>>1)){
		update((l+r>>1)+1,r,p<<1|1,a,b,c);
	}
	pushup(p);
}
inline int find(int p,int t,int s){
	if(dep[p]==t){
		return val[p];
	}
	pushdown(p);
	if(val[(p<<1)|(s>>dep[p]-1&1)]!=-1){
		return find((p<<1)|(s>>dep[p]-1&1),t,s);
	}
	else{
		return find((p<<1)|(s>>dep[p]-1&1^1),t,s)+((int)(1)<<dep[p]+t-1);
	}
}
inline int query(int l,int r,int p,int a,int b,int s){
	if(a<=l&&r<=b){
		return find(1,dep[p],s);
	}
	int c=0;
	pushdown(p);
	if(a<=(l+r>>1)){
		c+=query(l,l+r>>1,p<<1,a,b,s);
	}
	if(b>(l+r>>1)){
		c+=query((l+r>>1)+1,r,p<<1|1,a,b,s+(1<<dep[p]-1));
	}
	return c;
}
signed main(){
	int p,a,b;
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>v>>m>>n;
	for(;(1<<k)<=n;k++);
	build(0,(1<<k)-1,1,k);
	while(v--){
		cin>>a>>b;
		update(0,(1<<k)-1,1,a,b,0);
	}
	while(m--){
		cin>>p>>a>>b;
		if(p==0){
			if(val[1]==-1){
				cout<<"Death\n";
			}
			else{
				cout<<query(0,(1<<k)-1,1,a,b,0)<<'\n';
			}
		}
		else{
			update(0,(1<<k)-1,1,a,b,p-1);
		}
	}
	return 0;
}
```

---

## 作者：柳易辰 (赞：0)

前置知识：Trie。

完全不知道另一篇题解在写什么。而且输出没开 `%lld`，最后一档过不了。

### Part 1

考虑维护一棵 Trie，把 Trie 当成线段树用。查询可以拆成 $\log n$ 个 Trie 节点上的询问。

设 Trie 上节点 $p$ 对应的区间为 $[l_p,r_p]$。如果询问 $[l_p,r_p]$，设每个 $i\in[l,r]$ 对应的令 $\min_{x\in S}(i\oplus x)$ 取到最小值的 $x$ 为 $x_i$。对于每个节点 $p$，维护 $a_p$ 表示 $p$ 子树内是否存在 $s_i=0$ 的叶子节点，$d_p$ 表示节点深度（从 $\log n$ 到 0）。则单个 $x_i$ 容易在 $O(\log n)$ 的时间内求得。

求 $x_i$ 是一个贪心的过程，我们从高位到低位将 $i$ 在 Trie 上尝试匹配。观察这个过程就会发现，$[l_p,r_p]$ 在 Trie 上匹配的过程从最高位起到第 $d_p$ 位这几位的匹配过程是一模一样的，我么可以尝试压在一起处理。

换言之，容易发现存在一个与节点 $q$ 满足：

+ $d_p=d_q$，$a_q=\tt{true}$
+ $q$ 是所有满足前两个条件的节点中，根到 $q$ 路径上的权值与根到 $p$ 路径上的权值异或和最小的节点。
+ $\forall i\in[l_p,r_p]$，$x_i$ 在 $q$ 的子树中

已知 $p$ 求 $q$ 可以在 $O(\log n)$ 的实现内完成。从最高位到第 $d_p$ 位的贡献已经在这一步算完了，就是路径异或和乘上 $q$ 子树大小。

### Part 2

接下来考虑从第 $d_p$ 位到最低为的贡献，可以发现这个贡献紧跟 $q$ 子树内部的情况有关。我们不妨用 $v_q$ 来表示。严谨的定义 $v_q$ 就是：

+ $a_q=\tt true$：$v_q$ 为询问 $[l_q,r_q]$ 的答案
+ $a_q=\tt false$：$v_q=0$

合并的答案的过程是简单的，记 $q$ 的左右孩子分别为 $lc_q,rc_q$：

+ $a_q=a_{lc_q}\lor a_{rc_q}$
+ $a_{lc_q}=a_{rc_q}=\tt false$：$v_q=0$
+ $a_{lc_q}=a_{rc_q}=\tt true$：由于我们希望贡献最少，所以肯定让 $i\in[l_q,r_q]$ 这一位为 0 的进入左子树，为 1 的进入右子树，不会产生新的贡献：$v_q=v_{lc_q}+v_{rc_q}$
+ 其它情况：左子树或右子树其中一个不存在 $s_i=0$ 的叶子节点。我们被迫让所有 $i$ 都进入某棵子树匹配，对答案产生的贡献为子树大小乘上深度：$v_q=2(v_{lc_q}+v_{rc_q})+2^{d_p-2}(r_q-l_q+1)$

### Part 3

考虑修改，只要维护区间覆盖懒标记即可。

下传时 $a_p$ 被直接覆盖，无论是覆盖为 0 还是 1，$v_p$ 均清零。初始化可以用差分处理。

### 代码

见[剪贴板](https://www.luogu.com.cn/paste/6o01hlma)，细节：特判 `Death`，开 `long long`。为了维护方便，实际代码中 $d_p'=d_p-1$。

---

## 作者：Daniel2020 (赞：0)

# [CoE R5] 斑马王子 (F) 题解：

此题显然是数据结构题，并且看到和异或有关的数据结构题，很自然地可以联想到在 $\texttt{01Trie}$ 的基础上稍加修改。

不妨假设此时已经实现了操作 $0$ （查询操作），考虑操作 $1$ ，$2$ （状态赋值操作）的实现。

不难发现，如果直接在 $\texttt{01Trie}$ 上维护区间状态，在进行状态赋值操作时，状态的操作会十分繁琐，很容易出锅。那么此时不妨退一步考虑：如何在暴力修改的基础之上优化复杂度？

考虑这样一种维护方式：

首先对于原序列，定义一个区间为一段极长的连续的 $1$ 的序列，操作区间为一次操作输入的区间。

对于操作 $1$，找出所有与操作区间**相邻**的区间并全部去除，加入一个合并后的新区间。

对于操作 $2$，找出所有与操作区间**相交**的区间，若被操作区间完全包含则直接去除，否则加入操作后剩余的区间。

为什么这样的复杂度是正确的呢？

对于一个区间，它最多被暴力修改 $2$ 次。一次是加入此区间时，一次是被去除时。并且显然去除此区间后不会再通过此区间进行操作（端点相同**不一定**认为是同一区间），所以使用一个区间进行的操作数是常数级别的。

而观察状态赋值操作，发现一次操作至多加入 $2$ 个新区间,所以包括初始化加入的所有区间的数量是 $O(n)$ 级别的。

不难发现所有被进行操作的区间数是 $O(n)$ 级别的，故此种维护方式的时间复杂度在此题是足够优秀的。

可以考虑用平衡树实现,时间复杂度允许通过。

具体来说，我们维护两个平衡树，分别维护所有区间的左端点和右端点。此时，两个平衡树中第 $k$ 小的数代表的就是从左到右的第 $k$ 个区间。进行状态赋值操作时，通过平衡树找到所有与操作区间有关的区间，暴力扫描并更新 $\texttt{01Trie}$ 中节点的状态，最后再处理特殊区间即可。

**注意：**

上述维护方式的时间复杂度看似还是错误的，但是所有与操作区间有关的区间在操作后都会被删除，故时间复杂度仍然足够优秀。

细心的巨佬和神犇们可能会发现，最后我们还是要在 $\texttt{01Trie}$ 的节点中维护区间状态。但是此时在 $\texttt{01Trie}$ 添加和删除的区间不再与其它区间产生交集，可以大大简化状态的维护与转移。

还看不懂？看看[此题](https://www.luogu.com.cn/problem/CF444C)！

接下来考虑在暴力修改操作 $0$ 的基础上进行优化。

1.	暴力：

时间复杂度 $O(n^2m)$。

2.	优化 $1$ ：

因为 $2^k > \sum\limits^{k-1}_ {i = 0} 2^i$，所以对于每个数，可以贪心地按二进制位从大到小枚举，尽可能让当前枚举位与查询的数的对应位相同。

建出 $\texttt{01Trie}$，并在 $\texttt{01Trie}$ 的节点上打上标记表示当前节点表示的区间是否可以被选择，贪心查询即可。

时间复杂度 $O(nm\log n)$。

3. 优化 $2$ ：

考虑将查询区间分成若干小区间，每个区间对应 $\texttt{01Trie}$ 上的一个节点，将一次查询转化为 $O(\log n)$ 级别的子查询，显然查询结果为所有子查询的结果之和。

首先定义一些变量：

$pos_i$:当前查询的区间在最优情况下（不考虑节点被标记的情况下）经过的第 $i$ 个节点的属性（为其父节点的左子树还是右子树）。

$val_i$:不按照查询区间在在最优情况下（对应属性相同的情况下）经过节点 $i$ 产生的代价。

$sum_i$:$i$ 节点标记后，对 $1$ 个通过其父节点的另一子节点更劣的**数**产生的代价。

$num_i$:当前查询区间经过 $i$ 节点的**数的数量**。

$stt_i$:节点 $i$ 是否被标记。

对于一个小区间的查询可以分为两个阶段：

1.	$val_{now} > val_{ask}$

同优化 $1$，预处理路径，贪心查询即可，记答案为 $ansa$。

2.	$val_{now} = val_{ask}$

当节点 $now$ 及其子树内均没有节点被标记时，代价显然为 $0$。

否则当一个节点 $x$ 被标记时，会产生 $num_x \times val_x$ 的代价，同时其父节点的另一个子节点 $y$ 的 $num_y$ 会变成 $num_y \times 2$ （因为 $x$ 节点被标记，本来经过 $x$ 节点最优的数只能通过 $y$ 节点）,所以可以维护 $tag_i$ 懒标记,进行类似线段树的操作，答案 $ansb$ 显然为当前节点及其子树的 $sum$ 之和除以 $\frac{num}{len}$。其中 $len$ 为查询的小区间区间长度（因为经过一个区间的**数的个数**与子查询的**数的总数**有关）。

原查询答案即为所有子查询的 $ansa+ansb$ 之和。

更通俗地讲，其实就是让查询的所有数同时在维护的 $\texttt{01Trie}$ 上贪心地向最优的子节点行走，在过程中计算对答案的贡献。因为查询的一段区间可以分成对应在 $\texttt{01Trie}$ 上的若干子区间，故可以对每一个子区间分别求解，累加即为答案。当一个区间的数不能到达它们对应最优的匹配区间时，它们就只能走向另一个 $\texttt{01Trie}$ 上的子节点。我们就在此时计算答案。再统一维护即可优化时间复杂度。

时间复杂度 $O(m(\log n)^2)$。

建议阅读代码以便于更好地理解。

代码：

```cpp
#include<bits/stdc++.h>
#define ls (x<<1)
#define rs (x<<1)|1
using namespace std;
typedef long long LL;
const LL N = 2e6+2,M = 2e6+2,inf = 2e9;
struct Segment { LL l,r; };
bool cmp(Segment a,Segment b) { return a.l < b.l; }
struct Treap
{
	LL rtt,x,y,z,ans,cnt;
	LL son[N][2],val[N],key[N],siz[N];
	void update(LL x) { siz[x] = 1+siz[son[x][0]]+siz[son[x][1]]; }
	LL add(LL x) { siz[++cnt] = 1; val[cnt] = x; key[cnt] = rand(); return cnt; }
	LL merge(LL x,LL y)
	{
		if(!x || !y) return x^y;
		if(key[x] < key[y]) { son[x][1] = merge(son[x][1],y); update(x); return x; }
		else { son[y][0] = merge(x,son[y][0]); update(y); return y; }
	}
	void split(LL x,LL k,LL &a,LL &b)
	{
		if(!x) a = b = 0;
		else
		{
			if(val[x] <= k) a = x,split(son[x][1],k,son[x][1],b);
			else b = x,split(son[x][0],k,a,son[x][0]);
			update(x);
		}
	}
	LL getkth(LL x,LL k)
	{
		for(;;)
			if(k <= siz[son[x][0]]) x = son[x][0];
			else if(k == siz[son[x][0]]+1) return x;
			else { k -= siz[son[x][0]]+1; x = son[x][1]; }
	}
	void ins(LL a) { split(rtt,a,x,y); rtt = merge(merge(x,add(a)),y); }
	void del(LL a) { split(rtt,a,x,z); split(x,a-1,x,y); y = merge(son[y][0],son[y][1]); rtt = merge(merge(x,y),z); }
	LL rnk(LL a) { split(rtt,a-1,x,y); ans = siz[x]+1; rtt = merge(x,y); return ans; }
	LL kth(LL a) { return val[getkth(rtt,a)]; }
	LL pre(LL a) { split(rtt,a-1,x,y); ans = val[getkth(x,siz[x])]; rtt = merge(x,y); return ans; }
	LL nxt(LL a) { split(rtt,a,x,y); ans = val[getkth(y,1)]; rtt = merge(x,y); return ans; }
}; //普通平衡树 
struct Trie
{
	LL cnt,tot,lim;
    LL stt[M],num[M],val[M];
	LL sum[M],tag[M];
	LL pre[M];
	Segment res[N];
	void Pow(LL &a,LL b) { b > 0 ? a <<= b : a >>= (-b); } //乘法（除法） 
	void pushup(LL x) { sum[x] = sum[ls]+sum[rs]; } //上传操作 
    void pushdown(LL x) { if(!tag[x]) return; Pow(num[ls],tag[x]); Pow(sum[ls],tag[x]); Pow(num[rs],tag[x]); Pow(sum[rs],tag[x]); tag[ls] += tag[x]; tag[rs] += tag[x]; tag[x] = 0; } //下传操作 
    void build(LL x,LL l,LL r,LL res)
    {
        num[x] = val[x] = res; stt[x] = sum[x] = tag[x] = 0;
        if(l == r) return;
        LL mid = r-((r-l+1)>>1);
        build(ls,l,mid,(res>>1));
        build(rs,mid+1,r,(res>>1));
        pushup(x);
    } //建Trie 
	void getseg(LL x,LL l,LL r,LL L,LL R)
	{
		if(L <= l && r <= R) { res[++tot] = {l,r}; return; }
		LL mid = r-((r-l+1)>>1);
		if(L <= mid) getseg(ls,l,mid,L,R);
		if(mid < R) getseg(rs,mid+1,r,L,R);
	} //分解区间 
    void modify(LL x,LL l,LL r,LL L,LL R,LL opt)
    {
        if(L <= l && r <= R)
		{
            LL pos = x&1 ? x-1 : x+1 ; //pos指当前节点的父节点的另一个子节点 
            if(opt) //如果是添加操作 
			{
				sum[x] = 2*num[x]*val[x]; stt[x] = 1;
				Pow(num[pos],1); Pow(sum[pos],1); tag[pos]++;
			}
        	else //如果是删除操作 
			{
				sum[x] = stt[x] = 0;
				Pow(num[pos],-1); Pow(sum[pos],-1); tag[pos]--;
			}
			return;
		}
        pushdown(x);
		LL mid = r-((r-l+1)>>1);
		if(L <= mid) modify(ls,l,mid,L,R,opt);
		if(mid < R) modify(rs,mid+1,r,L,R,opt);
        pushup(x);
    }
    void prework(LL x,LL l,LL r,LL L,LL R)
    {
    	if(x == 1) cnt = 0; if(L <= l && r <= R) return;
		LL mid = r-((r-l+1)>>1);
		if(L <= mid) pre[++cnt] = 0,prework(ls,l,mid,L,R);
		if(mid < R) pre[++cnt] = 1,prework(rs,mid+1,r,L,R);
	} //预处理路径，0为左，1为右 
    LL query(LL x,LL l,LL r,LL len,LL now)
    {
    	if(now > cnt) { LL base = num[x]/len; return (sum[x]/base)>>1; } //计算答案 
    	pushdown(x);
		LL mid = r-((r-l+1)>>1),ans = 0;
    	if(!pre[now]) ans = stt[ls] ? query(rs,mid+1,r,len,now+1)+(val[ls]*len) : query(ls,l,mid,len,now+1);
		else ans = stt[rs] ? query(ls,l,mid,len,now+1)+(val[rs]*len) : query(rs,mid+1,r,len,now+1);
		return ans;
	}
    void optseg(Segment s,LL opt)
    {
    	if(opt > 1 && stt[1]) { puts("Death"); return; } //特判无解的情况 
    	LL ans = 0; tot = 0; getseg(1,0,lim,s.l,s.r); //将需要操作的区间分解 
        for(LL i = 1;i <= tot;i++)
        {
        	LL len = res[i].r-res[i].l+1; //子区间区间长 
        	if(opt <= 1) modify(1,0,lim,res[i].l,res[i].r,opt); //添加区间 
            else prework(1,0,lim,res[i].l,res[i].r),ans += query(1,0,lim,len,1); //预处理区间路径并处理查询 
		}
		if(opt > 1) printf("%d\n",ans); //输出查询 
        return;
	}
};
LL n,m,k,cnt,lim;
Segment tmp[N],seg[N];
Treap L,R; Trie t;
struct Function
{
	Segment opt,tot,now,del[N],add[N]; //临时变量 
	void insseg(Segment s) { L.ins(s.l); R.ins(s.r); } //插入区间 
	void delseg(Segment s) { L.del(s.l); R.del(s.r); } //删除区间 
	Segment askseg(LL pos) { return {L.kth(pos),R.kth(pos)}; } // 询问第pos个区间 
	void preseg(Segment s)
	{
		tot.l = 0; tot.r = 0;
		opt.l = L.rnk(L.pre(s.l));
		opt.r = R.rnk(R.nxt(s.r));
	} //预处理插入、删除区间操作（可能被更新的区间） 
	void mergeseg(Segment ask)
	{
		ask.l--; ask.r++; preseg(ask);
   		LL modl = 1,modr = -1; //预处理 
	    for(LL i = opt.l;i <= opt.r;i++)
	   	{
	    	del[++tot.l] = now = askseg(i); //提取出可能要删除的区间 
	        if(now.l <= ask.l && ask.l <= now.r) modl = 0; if(now.l <= ask.r && ask.r <= now.r) modr = 0;
	        if(now.l <= ask.l && ask.r <= now.r) ask.l = min(now.l,ask.l),ask.r = max(now.r,ask.r);
			else if(ask.l <= now.r && now.r <= ask.r) ask.l = min(now.l,ask.l);
			else if(ask.l <= now.l && now.l <= ask.r) ask.r = max(now.r,ask.r);
			else tot.l--; //分类讨论加入区间的变化以及当前区间是否删除 
		}
		add[++tot.r] = {ask.l+modl,ask.r+modr}; //添加加入的区间 
	}
	void deleteseg(Segment ask)
	{
		preseg(ask); //预处理 
   		for(LL i = opt.l;i <= opt.r;i++)
		{
    		del[++tot.l] = now = askseg(i); //提取出可能要删除的区间 
    		if(now.l <= ask.l && ask.r <= now.r) add[++tot.r] = {now.l,ask.l-1},add[++tot.r] = {ask.r+1,now.r};
			else if(ask.l <= now.r && now.r <= ask.r) add[++tot.r] = {now.l,ask.l-1};
			else if(ask.l <= now.l && now.l <= ask.r) add[++tot.r] = {ask.r+1,now.r};
			else tot.l--;  //分类讨论加入区间的变化以及当前区间是否删除
		}
	}//这两个函数要重点检查 
	void bootseg(Segment ask,LL opt)
	{
		if(opt == 1) mergeseg(ask);
		else deleteseg(ask); //预处理要修改的区间 
		for(LL i = 1;i <= tot.l;i++) t.modify(1,0,lim,del[i].l,del[i].r,0),delseg(del[i]); //删除应删除的区间（平衡树和Treap） !
		for(LL i = 1;i <= tot.r;i++)
			if(add[i].l <= add[i].r) t.modify(1,0,lim,add[i].l,add[i].r,1),insseg(add[i]); //加入应加入的区间 （平衡树和Treap） !
//		for(LL i = 1;i <= tot.l;i++)
//			printf("DEL: %lld %lld\n",del[i].l,del[i].r);
//		for(LL i = 1;i <= tot.r;i++)
//			printf("ADD: %lld %lld\n",add[i].l,add[i].r);
	}
} F; //操作结构体 
void input() { scanf("%lld%lld%lld",&n,&m,&k); for(LL i = 1;i <= n;i++) scanf("%lld%lld",&tmp[i].l,&tmp[i].r); } //读入 
void prework()
{
	for(lim = 1;lim-1 < k;lim <<= 1); //初始化Trie边界 
	t.lim = --lim;
	if(k+1 <= lim)
		tmp[++n] = {k+1,lim};
	F.insseg({-inf,-inf}); F.insseg({inf,inf}); //处理区间边界 
	t.build(1,0,lim,lim+1); //建出Trie 
	for(LL i = 1;i <= n;i++)
		F.bootseg(tmp[i],1);
}
void work()
{
	for(LL _ = 1;_ <= m;_++) //m个操作 
    {
        LL opt,ans = 0; Segment ask;
        scanf("%lld%lld%lld",&opt,&ask.l,&ask.r);
        if(opt == 0) t.optseg(ask,2); //查询答案
		else F.bootseg(ask,opt); //修改序列 
    }
}
int main()
{
//	freopen("in4.in","r",stdin);
//	freopen("std.out","w",stdout); 
	input(); prework(); work();
	return 0;
}
/*
Input:
0 16 3
0 0 3
1 3 3
0 0 3
1 1 2
0 0 3
2 1 3
0 0 3
1 0 0
1 1 1
0 0 3
0 1 2
0 1 3
1 2 3
0 2 3
2 3 3
0 2 3
Output:
0
1
6
0
4
2
2
Death
1
*/
```

注：实际上可以将区间修改的操作并到 $\texttt{01Trie}$ 上。~~考试前出题人没想到，导致现有解法无论是代码量，时间还是空间复杂度都远小于 $\texttt{std}$。~~

UPD:删除了标点符号与其他字符之间的多余空格。

---


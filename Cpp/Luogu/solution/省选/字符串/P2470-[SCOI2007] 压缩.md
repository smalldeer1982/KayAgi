# [SCOI2007] 压缩

## 题目描述

给一个由小写字母组成的字符串，我们可以用一种简单的方法来压缩其中的重复信息。压缩后的字符串除了小写字母外还可以（但不必）包含大写字母R与M，其中M标记重复串的开始，R重复从上一个M（如果当前位置左边没有M，则从串的开始算起）开始的解压结果（称为缓冲串）。


`bcdcdcdcd` 可以压缩为 `bMcdRR`，下面是解压缩的过程：


已经解压的部分|解压结果|缓冲串
---|---|---
b|b|b
bM|b|.
bMc|bc|c
bMcd|bcd|cd
bMcdR|bcdcd|cdcd
bMcdRR|bcdcdcdcd|cdcdcdcd



## 说明/提示

在第一个例子中，解为aaaRa，在第二个例子中，解为bMcdRRxMcdRR。


【限制】

50%的数据满足：1<=n<=20

 
100%的数据满足：1<=n<=50



## 样例 #1

### 输入

```
aaaaaaa```

### 输出

```
5```

## 样例 #2

### 输入

```
bcdcdcdcdxcdcdcdcd```

### 输出

```
12```

# 题解

## 作者：Tgotp (赞：93)

思路：区间dp

具体实现：

f[i][j][k] 代表区间 i - j 间是否存在m；

另默认在i-1处有一个M；

当s[mid+1,r]==s[l,mid]时，f[i][j][0] = f[i][(i+j)/2][0] + 1;

当中间加入了M，枚举M放在哪里就可以；

参照大佬打下的代码。


c++代码如下：


```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
int f[110][110][2];
char s[110];
int n;
bool check(int l,int r)
{
    int mid =(l + r ) /    2;
    for(int i = 1;i <= mid - l + 1 ;i++) if(s[l+i-1] != s[mid+i]) return 0;
    return 1;    
}
int main()
{
    scanf("%s",s+1);
    n = strlen(s+1);
    for(int i = n;i;i--)
        for(int j = i;j<=n;j++)
        {
            f[i][j][0] = f[i][j][1] = j - i + 1;
            for(int k = i;k < j ;k++) f[i][j][1] = min(f[i][j][1],min(f[i][k][0],f[i][k][1]) + 1 + min(f[k+1][j][1],f[k+1][j][0]));
            for(int k = i;k < j ;k++) f[i][j][0] = min(f[i][j][0],f[i][k][0] + j - k);
            if((j - i + 1)%2 == 0 && check(i,j)) f[i][j][0] = f[i][(i+j)/2][0] + 1;
        }
    cout<<min(f[1][n][0],f[1][n][1])<<endl;
    return 0;
}
推广blog：<http://tgotp.science>
```

---

## 作者：红色OI再临 (赞：74)

区间dp好题，与4302相似但又不同（因为它不能嵌套）

设`dp[i][j][0]`表示表示`i`到`j`的区间内没有`M`的情况

`dp[i][j][1]`则表示i到j的区间内有`M`的情况

先看`dp[i][j][0]`，如果前半段与后半段相等（暴力判断即可，hash也可以）那么

$dp[i][j][0]=min(dp[i][j][0],dp[l][mid][0]+1)$

`mid`为区间中点。

然后像平常的区间dp一样，枚举中间点k

$dp[i][j][0]=min(dp[i][j][0],dp[i][k][0]+j-k)$

再考虑`dp[i][j][1]`的情况,此时的k枚举的是`M`的位置

$dp[l][r][1]=min(dp[l][r][1],min(dp[l][k][0],dp[l][k][1])+min(dp[k+1][r][0],dp[k+1][r][1])+1)$

最后输出$max(dp[1][n][0],dp[1][n][1])$
```cpp
#include<bits/stdc++.h>
#define re register int
#define ll long long
#define maxn 55
using namespace std;
char as[maxn];
int dp[maxn][maxn][3];
int n;
int check(int l,int r){
	if((r-l+1)&1)return 0;
	int mid=(l+r)>>1;
	for(re i=l;i<=mid;i++)
		if(as[i]!=as[i+mid-l+1])return 0;
	return 1;
}//判断前一半是否和后一半相等
int main(){
	scanf("%s",as+1);
	n=strlen(as+1);
	memset(dp,0x3f,sizeof(dp));
	for(re i=1;i<=n;i++)
		for(re j=i;j<=n;j++)
			dp[i][j][0]=dp[i][j][1]=(j-i+1);
	for(re len=2;len<=n;len++)
		for(re l=1;l+len-1<=n;l++){
			int r=l+len-1;
			if(check(l,r))dp[l][r][0]=min(dp[l][(l+r)/2][0]+1,dp[l][r][0]);
		for(re k=l;k<r;k++){
			dp[l][r][0]=min(dp[l][r][0],dp[l][k][0]+r-k);
		}
		for(re k=l;k<r;k++)
			dp[l][r][1]=min(dp[l][r][1],min(dp[l][k][0],dp[l][k][1])+min(dp[k+1][r][0],dp[k+1][r][1])+1);
		}
		printf("%d\n",min(dp[1][n][1],dp[1][n][0]));
	return 0;
}

```


---

## 作者：xyz32768 (赞：53)

由于每次压缩的都是连续的一段，所以可以想到分段DP，又由于压缩可以嵌套，所以考虑区间DP。为了方便，先假设压缩后的字符串前面自带一个M，统计答案时减$1$即可。

先想到最经典的模型：$f[l][r]$表示字符串的第$l$个字符到第$r$个字符的最短压缩长度。

第$1$种转移，就是$f[l][r]=\min_{i=l}^{r-1}(f[l][i]+f[i+1][r])$。

第$2$种转移，就是对应的子串长度为偶数，并且可以拆分成两个相等的子串时的转移，设$mid=\frac{l+r}{2}$，

这时候转移就是$f[l][r]=\min(f[l][r],f[l][mid]+2)$。

但上面的转移是错的。原因就在于第$2$种转移受到子串$[l,mid]$的压缩中M的个数和位置的限制。举个例子：一个子串为orzlcxcxorzlcxcx，虽然orzlcxcx的一种压缩为orzlMcxR，但MorzlMcxRR不是orzlcxcxorzlcxcx的一种压缩，因为最后一个R对应的不是第一个M。

所以这里就可以规定一个新的方案：

$f[l][r][1]$表示子串$[l,r]$，压缩的第一个字符必须为M，并且**不再**含有其它任何M；

$f[l][r][0]$表示子串$[l,r]$，压缩的第一个字符必须为M，且压缩串中M的个数**必须**大于$1$。

边界为$f[i][i][1]=2$。

第$1$种转移为$f[l][r][0]=\min_{i=l}^{r-1}(\min(f[l][i][0],f[l][i][1]),$

$\min(f[i+1][r][0],f[i+1][r][1]))$，但在实现上要注意判边界，具体见代码。

第$2$种转移：$f[l][r][1]=\min_{i=l}^{r-1}(f[l][i][1]+r-i)$，也就是压缩串中仅含一个M的情况下，后缀$[i+1,r]$有可能不参加循环（后面没有任何一个R）。

第$3$种转移也就是子串$[l,r]$可以拆分成两个相等的子串$[l,mid]$和$[mid+1,r]$的情况。此时转移：$f[l][r][1]=\min(f[l][r][1],f[l][mid][1]+1)$，这样就避免了子串$[l,mid]$的压缩中M个数和位置的影响。

最后答案就是$\min(f[1][n][0],f[1][n][1])-1$，$n$为原字符串长度。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 55, INF = 0x3f3f3f3f;
int n, f[N][N][2]; char s[N];
int dfs(int l, int r, int op) {
    if (f[l][r][op] != -1) return f[l][r][op];
    if (l == r) return f[l][r][op] = 2;
    int i, res = INF; if (op) {
        res = r - l + 2; int mid; bool flag = 1;
        if (!(r - l & 1)) flag = 0;
        mid = l + r >> 1; for (i = l; i <= mid; i++)
            if (s[i] != s[mid + i - l + 1]) flag = 0;
        if (flag) res = min(res, dfs(l, mid, 1) + 1);
        for (i = l; i < r; i++) res = min(res, dfs(l, i, 1) + r - i);
    }
    else for (i = l; i < r; i++) {
        res = min(res, dfs(l, i, 0) + dfs(i + 1, r, 0));
        if (i + 1 < r) res = min(res, dfs(l, i, 0) + dfs(i + 1, r, 1));
        if (l < i) res = min(res, dfs(l, i, 1) + dfs(i + 1, r, 0));
        if (l < i && i + 1 < r) res = min(res, dfs(l, i, 1) + dfs(i + 1, r, 1));
    }
    return f[l][r][op] = res;
}
int main() {
    memset(f, -1, sizeof(f));
    scanf("%s", s + 1); n = strlen(s + 1);
    dfs(1, n, 0); dfs(1, n, 1);
    cout << min(f[1][n][0], f[1][n][1]) - 1 << endl;
    return 0;
}
```

---

## 作者：Cry_For_theMoon (赞：42)

传送门：[SCOI2007，压缩](https://www.luogu.com.cn/problem/P2470)

&emsp;&emsp;有一个看似正确但实际上错误的做法：

- 当前后两部分相同的时候，压缩成一个
- 否则枚举断点 k，把两部分相加

&emsp;&emsp;我们注意到题目中的一句话：**R重复从上一个M算起**，那么就不能产生嵌套的情况。

&emsp;&emsp;举个栗子：一个位于中间的子串：dzkblrh ak ioi ak ioi dzkblrh ak ioi（空格只是为了方便看清），那么按照上面的策略压缩：

&emsp;&emsp;1.压缩成M dzkblrh ak ioi ak ioi R

&emsp;&emsp;2.压缩成M dzkblrh M ak ioi R R

&emsp;&emsp;然而又因为 R 是和最近的 M 配对的，因此第二个 R 是和第二个 M 配对的，因此展开后是dzkblrh ak ioi ak ioi ak ioi ak ioi，这显然是错误的。

&emsp;&emsp;错误的原因：我们每次压缩的时候都添加了一个 M，使得**外层出现的 R 对应到了内层的 M 上**，压缩串解压后自然就不是原来的字符串，换言之：**内层有无 M 会决定外层能否压缩**

&emsp;&emsp;那么我们就以"有无 M "，把 $f(i,j)$ 拆成两种情况。用 1 代表无M，用 2 代表有 M

&emsp;&emsp;还需要搞明白一件事：这个"放 M "的过程，是在当前这个状态里放，还是在上一步（即外层）放。在这里选择第二种方案，原因有二：

&emsp;&emsp;1.因为默认 1 之前是存在 M 的，因此选择第一种方案需要在 $i=1$ 的时候特判

&emsp;&emsp;2. 如果出现了压缩的情况，选择第一种方案是先放个 M ，再把左半边复制出来，再放一个 R，那问题是左半边怎么处理，你要是选择压缩，就回到了一开始的情况；要是不压缩，万一出现左半部分还可以拆分成两个相同的部分（比如说原串是ab ab ab ab），又丢失了最优解。我们发现这样做非常难处理，因此选择第二种。

&emsp;&emsp;因此我们假设推导$f(i,j)$时， i-1 处已经有了一个 M。这就是我们 "在上一步放 M 的体现"，因为只有一个更大的问题才会用到当前这个问题，而 M 应该是在那个时候放置。这一点在下文会再次提到。

&emsp;&emsp;先来考虑左半边和右半边相等的情况，值得注意的是，只有 $f(i,j,0)$ 才能使用这种情况转移。如果 $f(i,j,1)$
也用了这个，那么那个"出现的 M "只可能在左半段。还是那个问题，如果这样做，外层的那个 R 就压缩错误了，因此自然不能用。

&emsp;&emsp;然后是枚举断点 k 的情况，我们列出这两个方程：
$$\begin{cases}f(i,j,0)=\min(f(i,j,0),f(i,k,0)+j-k) )\\
f(i,j,1)=\min(f(i,j,1),\min(f(i,k,0),f(i,k,1) )+1+\min(f(k+1,j,0),f(k+1,j,1))\end{cases}$$

&emsp;&emsp;Q：为什么在方程 1 中，左边是$f(i,k,0)$，右边则是 j-k；而方程 2 中又不是这样呢？

&emsp;&emsp;A；$f(i,k)$和$f(i,j)$开头都是相同的，都有一个"自带的"M，因此$f(i,k)$在不添加多余的 M 情况下，是可以继续压缩的；然而如果想要单独压缩右半部分，必须要在 k 和 k+1 之间插入一个 M，这显然不符合 $f(i,j,0)$ 的定义。而方程2中那个"+1"本身就是代表在 k 和 k+1 之间插入一个 M，此时**右半部分不管怎么压缩都不会牵扯到左半部分**。

&emsp;&emsp;此时我们再回过头来看。一开始$f(1,n)$是自带 M 的，压缩成立，后面每次分解的两个子问题，要么是起点还是 1 的，即自带 M ，要么是在开始前先插入了一个 M 再求的，也自然满足压缩的条件。因此这个方案是成立的。

&emsp;&emsp;最后千万不要忘记输出的是 $\min(f(1,n,0),f(1,n,1))$ 

&emsp;&emsp;照着本文思路应该很容易打出代码，不过要注意检查左右两遍是否相等的部分比较容易出错。

&emsp;&emsp;代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=100;
char str[maxn];
int n,f[maxn][maxn][5];
bool check(int start,int end){
	//check返回[start,end]能否被分割成完全相等的两部分
	int len=(end-start+1)>>1;
	if((end-start+1)%2==1)return false; //特别要注意的是，奇数长度的串要特判（否则你是过不去样例#1的） 
	for(int i=start,j=start+len;i<start+len;i++,j++){
		if(str[i]!=str[j]){
			return false;
		}
	} 
	return true;
}
int main(){
	scanf("%s",str+1); //str+1同样是一个字符数组的地址，这样我这种 for(1..n) 党就非常舒服了
	n=strlen(str+1);
	for(int i=1;i<=n;i++){
		f[i][i][1]=1; //此时就是字符一个本身
		f[i][i][2]=2; //字符本身 加上一个多余的'M' 
	}
	for(int len=2;len<=n;len++){
		for(int i=1;i<=n;i++){
			int j=i+len-1;
			if(j>n)break;
			f[i][j][1]=f[i][j][2]=1e9; //因为是求最小值 
			//如果能分割成左右两部分，用它更新f(i,j,1)
			if(check(i,j)){
				int mid=(i+j)>>1;
				f[i][j][1]=min(f[i][j][1],f[i][mid][1]+1); 
			} 
			//枚举断点k
			for(int k=i;k<j;k++){
				f[i][j][1]=min(f[i][j][1],f[i][k][1]+j-k);
				f[i][j][2]=min(f[i][j][2],min(f[i][k][1],f[i][k][2])+min(f[k+1][j][1],f[k+1][j][2])+1); 
			}
		}
	}
	cout<<min(f[1][n][1],f[1][n][2]);
	return 0;
}
```


---

## 作者：Liynw (赞：20)

### 前言

[题目传送门](https://www.luogu.com.cn/problem/P2470)

**正解：区间/线性 dp**（本篇题解介绍线性做法）

人生第一道紫题！

也是今天考试看自闭了就没做的 T4，结果没想到是紫，虽然是一道水紫呢……

~~考试的 T5 是跳房子，蓝题 qwq。要不是前三题比较简单 + 骗分好骗（指靠直接输出字符串长度骗了十分）就真的自闭了。~~

不管怎么样反正挺难的。

***

### 题解

我们观察到一个字符串压缩的程度和 “M”，“R”的个数是有关的，尤其是开始一段压缩区间的“M”，非常的重要，因为它的位置决定了压缩串的长度，也直接决定了最后字符串的长度。非常好的条件，可以利用。

所以，定义 $dp$ 数组状态为：

- $dp_{i,j}$ 代表前 $i$ 个字符，上一个“M”的位置在第 $j$ 个字符**前**所能达到的最短长度。

$dp$ 数组的初始值：

当只有一个字符时，“M”只有可能在第一个字符前，而且长度为 $1$。所以，$dp_{1,1}=1$。

于是我们可以分析出以下三种情况。

1. 直接在前面 $i-1$ 个字符的情况下，加上一个字符。

1. 添加压缩的字符串。

1. 新建一个压缩字符串部分的开头。

### part1

如果只是直接加一个，这样 $j$ 的值是不会变的，因为我们没有考虑“M”和“R”的情况。这样得到的答案就是 $dp_{i-1,j}+1$。

### part2

我们知道，当且仅当某**两**个字符子串**完全相同**时，我们才能对这两个字符串进行一次压缩。

至于这个压缩的地方加在哪里呢？因为最近的“M”的位置已经确定，所以这个“M”（坐标为 $j-1$ 和 $j$）**之前**（并不包括第 $j$ 个字符）的所有字符串情况已经确定，无法改动（因为 dp 不能有后效性）。

所以我们确定被复制了一遍的区域在 $[j,i]$，从中间切开这份字符串，看看两边是不是相等的，如果是就可以考虑这种情况。注意这段区域的的长度为奇数是是一定不可能的。

判断字符串是否相等的函数很简单，就是这样：

```cpp
bool check(int l,int mid,int r){
	if((r-l+1)&1) return 0; //如果长度是奇数直接不可能
	for(int i=0;i<=mid-l;i++){
		if(a[l+i]!=a[mid+1+i]) return 0; //出现不一样的字符
	}
	return 1; //全部都一样
}
```

然后考虑如何状态转移，很明显，这样的长度就是 $j$ 之前的那些字符的最短长度 + 压缩后 $[j,i]$ 段的长度 + $1$（那个“R”字符）。转化为**情况二的**动态转移方程即为：

$$dp_{i,j}=\min_{j=1}^{i-1}\{dp_{\lfloor \frac{i+j}{2} \rfloor,j}\}+1$$

其中 $\lfloor \dfrac{i+j}{2} \rfloor$ 表示的是被**切成两段**的那一部分的**前面那个字符串**的最后一个字符串的下标（好绕啊）。

### part3

因为要新建一个“M”，意思就是再开一个可重复的字符串并将新开的“M”的下标作为 $dp$ 数组的第二个值。因为我们枚举到 $i$ 了，所以最方便的就是把这个“M”加在 $i-1$ 和 $i$ 之间，这样每一次循环都能考虑到一层，就全部考虑到了。

那转移方程是什么呢？我们继续观察，现在我们考虑的范围就已经缩小到了 $1$ 到现在添加的“M”（坐标为 $i-1$ 和 $i$ 之间）中间的这一段。很明显 $i$ 已经在这个“M”后面了，此时我们不需要考虑，所以只需考虑 $[1,i-1]$ 压缩后的最小长度。

那第二个下标呢？因为考虑前面的时候并没有考虑添加的“M”（这是两个情况），所以依然是枚举 $j$。

对了，这个值还要 $+2$，一个是添加的“M”字符，另一个是下标为 $i$ 的字符。（是的！这个也要算进去！因为此字符是在添加的“M”后面的，前面的式子并没有考虑到）。


所以，情况三的转移方程是：

$$dp_{i,i}=\min_{j=1}^{i-1}\{dp_{i-1,j}+2\}$$

将三个合并一下，不过记得，要保存前面情况的最优解。除了上述的特殊初始值外，因为求的是最小值，所以 $dp$ 初始值设为 $\text{INF}$（极大值）。

### $Code$

```cpp
#include<cstdio>
#include<cstring>
#include<climits> // INT_MAX的头文件
#define min(a,b) (a)<(b)?(a):(b)
int n,dp[505][505];
char a[505];
bool check(int l,int mid,int r){
	if((r-l+1)&1) return 0;
	for(int i=0;i<=mid-l;i++){
		if(a[l+i]!=a[mid+1+i]) return 0;
	}
	return 1;
}
int main(){
	//freopen("compress.in","r",stdin);
	//freopen("compress.out","w",stdout);
	memset(dp,127,sizeof(dp));
	dp[1][1]=1;
	scanf("%s",a+1);
	n=strlen(a+1);
	for(int i=2;i<=n;i++){
		for(int j=1;j<i;j++){
			dp[i][j]=dp[i-1][j]+1;
			if(check(j,(j+i-1)/2,i)) dp[i][j]=min(dp[i][j],dp[(i+j-1)/2][j]+1);
		}
		for(int j=1;j<i;j++) dp[i][i]=min(dp[i][i],dp[i-1][j]+2);
	}
	int ans=INT_MAX;
	for(int i=1;i<=n;i++) ans=min(ans,dp[n][i]);
	printf("%d",ans);
	return 0;
}
```

***

### 写在最后

考试竟然有个 dalao （zdj 大佬！）写出来了啊……%%%。

虽然听着不难但是思路很难想呢 qwq。

最后请随手点个赞吧，~~毕竟赠人玫瑰手有余香嘛~~。

---

## 作者：孤寂的时代 (赞：17)

不知为何都是区间DP

反正我写的比较不一样（可能原理上一样）

f[i][j]表示当前已经处理完字符串中的位置i，此时从i向左第一个M的位置

使用刷表法

可以把M放到i位置后面

f[i][i]=min(f[i][j]+1)

也可以什么也不做直接跳向下一个

f[i+1][j]=min(f[i][j]+1)

还可以放一个R

注意放R与前面是否放R都无关，效果都是一样的（如果不懂这话就算。。。）

f[i-j+i][j]=min(f[i][j]+1)

怎么判断是否可以放R呢

先预处理出a[i][j]表示在i位置时前面j长度的字符串是否等于后面j长度的字符串（准确来说应该是以i到i+1之间为分界线，前后字符串长j是否相等）

理论复杂度（N^3）（实际远小于N^3）

0ms一次过

上代码





```cpp
 #include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int INF=0x3f3f3f3f;
const int maxn=51;
int f[maxn][maxn];
bool a[maxn][maxn];
char str[maxn+2];
int main(){
    scanf("%s",str+1);
    int n=strlen(str+1);
    for(int i=1;i<n;i++){
        for(int j=1;j+i<=n && i-j>=0;j++){
            a[i][j]=true;
            int k1=i+1;
            for(int k2=i-j+1;k2<=i;k2++,k1++){
                if(str[k1]!=str[k2]){
                    a[i][j]=false;
                    break;
                }
            }
        }
    }
    memset(f,INF,sizeof(f));
    f[0][0]=0;
    for(int i=0;i<=n;i++){
        for(int j=0;j<=i;j++){
            f[i][i]=min(f[i][i],f[i][j]+1);
            f[i+1][j]=min(f[i+1][j],f[i][j]+1);
            if(a[i][i-j]) f[2*i-j][j]=min(f[2*i-j][j],f[i][j]+1);
        }
    }
    int ans=INF;
    for(int i=0;i<=n;i++){
        ans=min(ans,f[n][i]);
    }
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：star_magic_young (赞：9)

dalao们怎么状态都设的两维以上啊?qwq 完全可以一维状态的说

设$f[i]$为前缀i的答案,转移就枚举从前面哪里转移过来$f[i]=min(f[j-1]+w(j,i))(j\in [1,i])$

现在要知道$w(i,j)$怎么写,也就是区间$[i,j]$的最小长度(**要求区间最多只能在开头有一个W**),首先不压缩的长度就是原长度,然后压缩的话先要在开头加W,然后每次压缩一个最长的可以拆成两个相同串的**前缀**,压缩完后长度会加上1(后面接R),减去那个前缀的一半长度,然后那个前缀会缩掉后一半.把这些所有的长度取min就是这个区间的答案.这个压缩过程可以结合样例理解

注意开头是默认加好了W的

细节详见代码

```cpp
#include<bits/stdc++.h>
#define LL long long
#define il inline
#define re register
#define uLL unsigned long long

using namespace std;
const int N=55;
il int rd()
{
	int x=0,w=1;char ch=0;
	while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*w;
}
char cc[N];
uLL ha[N],bs[N];
il uLL hh(int l,int r){return ha[r]-ha[l-1]*bs[r-l+1];}
int n,f[N];
il int w(int l,int r)
{
	int an=r-l+1+(l==1),nw=1; //左端点为1,由于开头加好了W,所以这里不压缩长度先加上1平衡压缩要加上的W
	while(l<r)
	{
		int mid=(l+r)>>1;
		while(l<r&&hh(l,mid)!=hh(mid+1,r)) --r,++nw,mid=(l+r)>>1;
		if(l>=r) break;
		++nw,r=mid;
		an=min(an,nw+r-l+1); //代价也可以看做M的个数+R的个数+后面的一些零碎字母+前半截前缀长度
	}
	return an;
}

int main()
{
	scanf("%s",cc+1),n=strlen(cc+1);
	bs[0]=1;
	for(int i=1;i<=n;++i) bs[i]=bs[i-1]*233,ha[i]=ha[i-1]*233+cc[i],f[i]=i+1;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=i;++j)
			f[i]=min(f[i],f[j-1]+w(j,i));
	printf("%d\n",f[n]-1);  //把开头没有的W减掉
}

```

---

## 作者：cqbzhyf (赞：5)

一开始做这道题时用了一个很神奇的方法，水了20分……

之后突然想到可以用dp来实现，首先想到区间dp，之后决定使用线性 `dp` 来实现。

阅读题目，发现关键在于在哪里插入 `M`，于是我们定义 `dp[i][j]` 表示前 `i` 个字符最后在第 `j-1` 到 `j` 位插入 `M` 得到的最短长度。

由于是求最短长度，于是我们将 `dp` 数组初始化为极大值，方便之后的 `min` 操作。边界值 `dp[1][1]=1` ，前 `1` 个字符最短长度一定是 `1` 。

之后 `i` 从 `1` 到字符串长度， `dp[i][i]` 可初始化为：

```c++
for(int j=1;j<i;j++)dp[i][i]=min(dp[i][i],dp[i-1][j]+2);
```

表示在第 `j` 位插入 `M` ，而在第 `i` 位插入当前字符，因此是 `+2` 。

之后 `dp[i][j]` 状态转移分为两种情况，一是直接插入当前字符，即是 $dp[i][j]=dp[i-1][j]+1$ ，而另一种方式首先判断满足"abab"格式，如下：

1. $ l  \sim  (l+r)/2 $ 与 $ (l+r)/2+1  \sim  r $ 部分完全相等，可另开函数判断；


2. $(r-l+1) \bmod 2=0$ 。

最后，
```cpp
int ans=1e9;
for(int j=0;j<n;j++)ans=min(ans,dp[n][j]);
```

完美结束……

展示一下完整代码：
```cpp
#include <bits/stdc++.h>
char a[505];
int dp[505][505];
using namespace std;
bool check(int l, int r) {
    int mid = (l + r) / 2;
    for (int i = l, j = mid + 1; i <= mid && j <= r; i++, j++) {
        if (a[i] != a[j]) {
            return false;
        }
    }
    return true;
}
int main() {
    while (scanf("%s", a + 1) != EOF) {
        int n = strlen(a + 1);
        memset(dp, 127, sizeof(dp));
        dp[1][1] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j < i; j++) dp[i][i] = min(dp[i][i], dp[i - 1][j] + 2);
            for (int j = 1; j < i; j++) {
                dp[i][j] = dp[i - 1][j] + 1;
                if (check(j, i) && (j - i + 1) % 2 == 0)
                    dp[i][j] = min(dp[i][j], dp[(i + j - 1) / 2][j] + 1);
            }
        }
        int ans = 1e9;
        for (int j = 0; j < n; j++) ans = min(ans, dp[n][j]);
        cout << ans << endl;
    }
    return 0;
}
```

---

## 作者：Others (赞：3)

# 前置芝士
STL：pair,**map**，简单 dfs，**记忆化剪枝**，重载运算符。
# 题目大意
给你一个字符串，重复的字符串可以用字符 $R$ 和字符 $M$ 配合减少一半（减了还可以减），求最后剩余字符串的最小长度。
# 分析
很多人都说，搜索可以拿到部分 pts，但这题的正解是区间/线性 DP，
作为一名懒得想状态转移方程的蒟蒻，考虑用搜索~~骗分~~，三个操作：

- 在这里加一个 M，重置缓冲串。
- 从这里开始复制缓冲串，注意要满足前提条件（这里引进一个简单便捷的函数：substr， ```name.substr(i,len)``` 返回值为 string 类型）。
- 直接将字符加进缓冲串。

模拟就完啦，简单易懂的搜索。

直接模拟时间复杂度是 $O(3^n)$ ，显而易见的 TLE...考虑记忆化剪枝，这里的记忆化数组由搜索的参数决定，有两个参数：1、字符对应的下标；2、缓冲串。所以记忆化数组有两维，但是我们会发现有一维是字符串类型的，这里有三种做法：
1. 存字符串的 Hash 值；
2. 存对应数组下标；
3. 存字符串。

这里只讲第 $3$ 种做法，这里就要用我们的 map，map 是一种十分好用的 STL，它是一种键与值两两搭配构成的 STL，可以快速查询给出的键对应的值是什么，键和值均可以为其他数据结构或结构体，这里我们用 ```pair<int,string>``` 作为键，操作次数作为值，这样就可以记忆化啦！但是 map 需要对键做一个排序(为了更快的查询)，这就要用到我们的重载运算符了，这个其实很简单，就不展开讲，**注意**，map需要的运算符是小于符号，别重载错了。

该讲的都讲完了，上代码!
```cpp
#include <bits/stdc++.h>
#define i first
#define hc second
using namespace std;
typedef pair<int ,string> node;//定义键的类型 
bool operator<(node x,node other){//重载运算符 
	return x.i<other.i||(x.i==other.i&&x.hc<other.hc);//这里只是乱排了个序，对查询无任何影响qwq 
}
map<node,int> dp;//定义记忆化容器 
int n;
string s;
int dfs(int i,string hc){
	if(i==n) return 0;//搜索出口 
	if(dp.find(node(i,hc))!=dp.end()) return dp[node(i,hc)];//dp.find(x)为查询dp与x对应的键的位置，若没有，则返回dp的尾指针，即dp.end() 
	int Min=dfs(i+1,hc+s[i])+1;//字符串+字符(串)是将后面的字符(串)拼接在前面的字符串后面 
	if(hc.length()) Min=min(Min,dfs(i,"")+1);// ""为空字符串 
	if(hc.length()&&hc==s.substr(i,hc.length())) Min=min(Min,dfs(i+hc.length(),hc+hc)+1);
	return dp[node(i,hc)]=Min;
}
int main() {
	cin >> s;
	n=s.length();
	printf("%d\n",dfs(0,""));
	return 0;
}
```

---

## 作者：zzqDeco (赞：3)

完了，我是状态最复杂的（难不怪我调这么就

我们考虑对于一个串，它在这个题中有两种性质：

1. 需要在前面加上'M'
2. 可以作为模板来 copy

那我们就可以分出 $4$ 类，同时，这道题很容易看出是区间 dp，所以我们还需要考虑合并

有两种合并方式：

1. 当前这个串为偶数位，前面和后面相同
2. 暴力对于两个区间直接考虑相加

对于第二个我们可以发现下面的合并是可行的：

1. (0,1) + (0,1) -> (0,1)
1. (1,1) + (0,1) -> (1,1)
1. (0,1) + (1,1) -> (0,0)
1. (0,1) + (0,0) -> (0,0)
1. (0,0) + (0,0) -> (0,0)
1. (1,1) + (1,1) -> (1,0)
1. (1,1) + (0,0) -> (1,0)
1. (1,1) + (1,0) -> (1,0)
1. (1,0) + (1,1) -> (1,0)
1. (1,0) + (0,0) -> (1,0)
1. (1,0) + (1,0) -> (1,0)

注：括号表示的情况是某个条件是否满足，具体哪些情况需要额外$+1$，就让读者自己思考了

通过这个我们就可以得到代码了

```cpp
#include <cstdio>
#include <string>
#include <iostream>

using namespace std;

string s;

int c[110][110][5];

int main()
{
  cin>>s;
  for(int len=0;len<s.size();len++)
  {
    for(int l=0;l+len<s.size();l++)
    {
      int r=l+len;
      if(l==r) c[l][r][0]=1,c[l][r][1]=c[l][r][2]=c[l][r][3]=0x3f3f3f3f;
      else
      {
        c[l][r][0]=c[l][r][1]=c[l][r][2]=c[l][r][3]=0x3f3f3f3f;
        if((len+1)%2==0)
        {
          int k=(len+1)/2;
          bool flag=1;
          for(int now=r-k+1;now<=r;now++)
            if(s[now]!=s[now-k]) flag=0;
          if(flag) c[l][r][1]=min(c[l][r][1],min(c[l][r-k][0],c[l][r-k][1])+1);
        }
        for(int k=l;k<r;k++)
        {
          c[l][r][0]=min(c[l][r][0],c[l][k][0]+c[k+1][r][0]);
          c[l][r][1]=min(c[l][r][1],c[l][k][1]+c[k+1][r][0]);
          c[l][r][2]=min(c[l][r][2],c[l][k][0]+c[k+1][r][1]+1);
          c[l][r][2]=min(c[l][r][2],c[l][k][0]+c[k+1][r][2]);
          c[l][r][2]=min(c[l][r][2],c[l][k][2]+c[k+1][r][2]);
          c[l][r][3]=min(c[l][r][3],c[l][k][1]+c[k+1][r][1]+1);
          c[l][r][3]=min(c[l][r][3],c[l][k][1]+c[k+1][r][2]);
          c[l][r][3]=min(c[l][r][3],c[l][k][1]+c[k+1][r][3]+1);
          c[l][r][3]=min(c[l][r][3],c[l][k][3]+c[k+1][r][1]+1);
          c[l][r][3]=min(c[l][r][3],c[l][k][3]+c[k+1][r][2]);
          c[l][r][3]=min(c[l][r][3],c[l][k][3]+c[k+1][r][3]+1);
        }
      }
    }
  }
  printf("%d",min(c[0][s.size()-1][0],min(c[0][s.size()-1][1],min(c[0][s.size()-1][2],c[0][s.size()-1][3]))));
}
```

---

## 作者：nofind (赞：2)

题意:https://www.luogu.org/problem/P2470

区间DP好题,看了很久才理解

本来想f[i][j]表示[i,j]的最短长度,结果发现无法处理M

f[i][j][0/1]表示[i,j]中间没有(0)/有(1)M的最短长度

如果前后能压缩:f[i][j][0]=min(f[i][mid][0]+1)

f[i][j][t]=min(f[i][k][t]+j-(k+1)+1)(直接加上后半段)(t=0/1)

f[i][j][1]=min(f[i][k][1]+f[k+1][j][1]+1)(+1是为了让后半段的R不会受前半段的M的影响)

注意:f[i][j]求的是单独考虑[i,j]的解,即假设序列只有[i,j]
的子问题,这时根据题意,如果R之前没有M,那么就以序列开头为起点,因此可以理解为:f[i][j][0/1]表示[i,j]中间没有(0)/有(1)M的最短长度,并且[i-1]为M,这样可能会解决对方程的一些质疑

code：
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=60;
int n;
char s[maxn];
int f[maxn][maxn][2];
bool vis[maxn][maxn][2];
inline bool check(int l,int r)
{
	if((r-l+1)&1)return 0;
	int mid=(l+r)>>1,len=r-l+1;
	for(int i=l;i<=mid;i++)if(s[i]!=s[i+len/2])return 0;
	return 1;
}
int dfs(int l,int r,int k)
{
	if(l==r)return 1;
	if(vis[l][r][k])return f[l][r][k];
	int res=r-l+1;
	vis[l][r][k]=1;
	if(k)for(int i=l;i<r;i++)res=min(res,dfs(l,i,1)+dfs(i+1,r,1)+1);
	for(int i=l;i<r;i++)res=min(res,dfs(l,i,0)+r-(i+1)+1);
	if(check(l,r))res=min(res,dfs(l,(l+r)>>1,0)+1);
	return f[l][r][k]=res;
}
int main()
{
	scanf("%s",s+1);n=strlen(s+1);
	printf("%d",min(dfs(1,n,1),dfs(1,n,0)));
	return 0;
}
```


---

## 作者：Brioche (赞：2)

### [BLOG](https://www.cnblogs.com/terribleterrible/p/9883684.html)

### [[SCOI2007]压缩](https://www.luogu.org/problemnew/show/P2470)

状态:设$dp[i][j]$表示前i个字符,最后一个$M$放置在$j$位置之后的最短字串长度.

转移有三类,用刷表法来实现.

第一种是直接往压缩串后面填字符,这样就是:

$$dp[i+1][j]=min(dp[i+1][j],dp[i][j]+1)$$

另外一种就是往字串里添加$R$,要满足相邻两个字符串是匹配的,可以用字符串哈希来快速匹,另外下面的$k$和$sz$要倍增往后跳(因为重复的串长在成倍增加,题目的样例解释的很清楚了).

$$dp[k][j]=min(dp[k][j],dp[k-sz][j]+1)$$

当然还要往后填$M$

$$dp[i][i]=min(dp[i][i],dp[i][j])$$

时间复杂度$O(n^2logn)$

代码很好懂.

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
#define maxn 55
using namespace std;
const int base=233;
ull ha[maxn],pw[maxn];
char s[maxn];
int n,ans,dp[maxn][maxn];
ull gethash(int l,int r){return ha[r]-ha[l-1]*pw[r-l+1];}
int main()
{
	scanf("%s",s+1);n=strlen(s+1);pw[0]=1;
	for(int i=1;i<=n;i++)ha[i]=ha[i-1]*base+s[i];
	for(int i=1;i<=n;i++)pw[i]=pw[i-1]*base;
	memset(dp,0x3f,sizeof(dp));dp[1][0]=1;
	//dp[i][j]表示前i个字符,上一个M放在j位置之后的最短加密字串
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<i;j++)dp[i][i]=min(dp[i][i],dp[i][j]+1);
		for(int j=0;j<=i;j++)
		{
			dp[i+1][j]=min(dp[i+1][j],dp[i][j]+1);//往后直接添加字母
			if(i==j)continue;
			int sz=i-j;ull haha=gethash(j+1,i);
			for(int k=i+sz;k<=n;k+=sz)//倍增加R
			{
				if(haha==gethash(k-sz+1,k))//哈希匹配字符串
					dp[k][j]=min(dp[k][j],dp[k-sz][j]+1);
				else break;
				haha=haha*pw[sz]+haha;sz<<=1;
			}
		}
	}
	ans=1e9;
	for(int j=0;j<n;j++)ans=min(ans,dp[n][j]);
	cout<<ans<<endl;
	return 0;
}


```




---

## 作者：Zarinopl (赞：1)

一道比较显然的区间dp

但是诸位大佬状态表示方法好像有点多……

蒟蒻也来写一种新方法

dp[now][l][r]表示：当前需要填充原字符串的第now字符，重复子串是s[l...r]（左闭右开）的状态

每个状态的决策只有三种（放一个R，放一个M，按照原串填充）

直接算最终状态可能有点麻烦，就跑一个从[0][0][0]状态开始的记忆化搜索即可

上代码

记搜写法挺短还易理解

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define lop(c,l) for(int c=1;c<=(l);++c)
#define loop(c,l) for(int c=0;c<(l);++c)
using namespace std;

const int inf=0x3f3f3f3f;
int len;
char str[101];
int dp[51][51][51];
bool calc[51][51][51];
inline bool suit(const int& now,const int& l,const int& r){
	int sub=r-l;
	if(now+sub>len) return 0;
	loop(i,r-l){
		if(str[now+i]!=str[l+i]) break;
		if(i==r-l-1) return 1;
	}
	return 0;
}
int extend(const int& now,const int& l,const int& r){
	if(now==len) return 0;
	int& ans=dp[now][l][r];
	if(calc[now][l][r]) return ans;
	calc[now][l][r]=1,ans=inf;
	//P R
	if(suit(now,l,r)) ans=min(ans,extend(now+r-l,l,now+r-l)+1);
	//P M
	ans=min(ans,extend(now,now,now)+1);
	//INC
	ans=min(ans,extend(now+1,l,now+1)+1);
	return ans;
}
signed main(signed,char**,char**){
	scanf(" %s",str);
	len=strlen(str);
	printf("%d",extend(0,0,0));
    exit(0);
}
```


---

## 作者：HeHere (赞：0)

**区间DP**（并不会用LaTeX，用代码来写公式）

在JSOI winter camp看到这题

显然，总串的解与子串的解有关。

###预处理

先做预处理，is\_double(i,j)表示子串s[i..j]是不是可以直接压缩的串。

```cpp
bool check(int a, int b){
    if( (b-a+1)&1 || b<a) return false;//奇数个字符 或 尾<首
    else{
        for(int i=a,j=(b-a+1)/2+a;j<=b;i++,j++){
            if(s[i]!=s[j]) return false;
        }
        return true;
    }
}
```cpp
###LEVEL 1 我的一个误解

定义dp(i,j)为字符串中子串s[i..j]的压缩后最短长度，则有：

```cpp
dp(i,j)=min(
j-i+1,
dp(i,(j-i)/2+i,1,1) + (i==0)?1:2,//对半压缩及首尾代价，i=0不用M
dp(i,k) + dp(k+1,j)//分开处理，i<=k<j
);
答案=dp(0,n-1)
}
```
然而，这样连**样例都过不了**

###LEVEL 2 70分做法

再看一次题干，发现**R重复从上一个M开始的解压结果**

i.e.,**M有开头(i==0)一样的神力**

定义dp(i,j,M)为字符串中子串s[i..j]的压缩后最短长度，M表示这个串是(M=1)否(M=0)被


更长的串压缩时，前面**紧靠着**带了M字符（压缩时可以省一个M了）

```cpp
dp(i,j)=min(
j-i+1,
dp(i,(j-i)/2+i,1) + M?1:2,//对半压缩及首尾代价，M=1不用M
dp(i,k,M) + dp(k+1,j,0)
);
答案=dp(0,n-1,1)
```
##LEVEL 3 AC

考虑串"LUOGUgreatgreatLUOGUgreatgreat"(length=30)另外题目中说只有小写，破个例

我们的程序会压缩成

dp(0,29,1)=>dp(0,14,1)  "LUOGUgreatgreat**R**"

dp(0,14,1)=>dp(0,4,1)+dp(5,14,0)  "LUOGU greatgreat**R**"

dp(5,14,0)=>dp(5,9,0)+2  "LUOGU**M**great**RR**"

不符合规则了!这会被认为是"LUOGUgreatgreatgreatgreat"（即使我们更喜欢这个）


定义dp(i,j,M,R)为字符串中子串s[i..j]的压缩后最短长度，M同上，R表示后面**（可以紧


跟，离一点也没问题）**是(R=1)否(R=0)带了R字符（压缩要受限制,不能再加M了）

```cpp
dp(i,j)=min(
j-i+1,//越简单越持久（什么鬼话）
dp(i,(j-i)/2+i,1,1) + (M?1:2),//(R && !M)不能有，其它时候可以有
dp(i,k,M,R)+dp(k+1,j,0,R),
);
答案=dp(0,n-1,1,0)
```
我终于码完了……

我的最终代码是：

[评测详情 - 洛谷](https://www.luogu.org/record/show?rid=2070720)

因为记忆化搜索所以**常数大**，等你写到60分再来看吧


---

## 作者：bwartist (赞：0)

一. 状态定义：设 $dp_{i,j}$ 为前 $i$ 个字符中，最后一个 M 的位置为第 $j$ 个字符与第 $j-1$ 个字符中间的压缩后字符串的最短长度

二. 状态转移：

1. 若 $i=j$ 即最后一个 M 在 $i$ 与 $i-1$ 之间

由于最后一个 M 在 $i$ 与 $i-1$ 之间，所以第 $i$ 个字符就不可能被压缩了，需要单独输入。另外，还要输入一个 M 。这里要输入 $2$ 个字符。

当前 M 的位置与前 $i-1$ 个字符中的 M 的位置无关，所以需要枚举上一个 M 的位置，找到“输入前 $i-1$ 个字符最小值”（即求 $\min_{j=1}^{j<i}dp_{i-1,j}$）。综上所述：

```cpp
if (i == j) {
	for (int k = 1; k < i; k++) {
		dp[i][j] = min(dp[i][j], dp[i - 1][k] + 2);
	}
}
```

2. 若 $i \neq j$

可以分两种情况讨论：
>1. 在 $i$ 位前不新增 R，也就是 $a[i]$ 不被压缩，不难得出：`dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j]);`


>2. 在 $i$ 位前新增 R,$a[i]$ 被压缩：不难发现，最后一个 R 只跟最后一个 M 有关，而最后一个 M 的位置为 $j$。所以我们可以这样理解：将 $j$ 到 $i$ 这段区间从中间分开，前半段为需要我们在之前就输入好，后半段直接用 R 复制前半段内容。注意：这种情况有一个前提条件，就是 $mid$ 到 $i$ 的间的字符串要与 $j$ 到 $mid-1$ 间的字符相等。判断程序为：
>```cpp
>bool check (int x, int y) {
>	if ((y - x + 1) % 2 == 1)	return false;//长度为奇数
>	int mid = (x + y - 1) / 2;
>	int len = (y - x + 1) / 2;//实际上这里的len是“长度/2”
>	for (int i = x; i <= mid; i++) {
>		if (a[i] != a[i + len])	return false;
>	}
>	return true;
>}
>```
>被压缩后，需要的压缩后字符串的最短长度即为：输入 $1$ 到 $mid$ 所需代价+1（还要输入一个 R），转化成代码：
>```cpp
>dp[i][j] = min (dp[i][j], dp[(i + j - 1) / 2][j] + 1);
>```

三. 初始值及边界值：题目所求为最小值，所以初始化 $dp$ 数组为极大值。另外`dp[1][1]=1;`

四. $Code$:
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
char a[505];
int n, dp[505][505], ans;
bool check (int x, int y) {
	if ((y - x + 1) % 2 == 1)	return false;
	int mid = (x + y - 1) / 2;
	int len = (y - x + 1) / 2;
	for (int i = x; i <= mid; i++) {
		if (a[i] != a[i + len])	return false;
	}
	return true;
}
int main () {
//	freopen("compress.in","r",stdin);
//	freopen("compress.out","w",stdout);
	while (scanf ("%s", a + 1) != EOF) {
		n = strlen (a + 1);
		memset (dp, 127, sizeof (dp));
		dp[1][1] = 1;
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= i; j++) {
				if (i == j && i == 1)	continue;
				if (i == j) {
					for (int k = 1; k < i; k++) {
						dp[i][j] = min(dp[i][j], dp[i - 1][k] + 2);
					}
				}
				dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j]);//正常情况：直接加一个字母
				if (check (j, i))	dp[i][j] = min (dp[i][j], dp[(i + j - 1) / 2][j] + 1); 
			}
		}
		ans = 2147483647;
		for (int i = 1; i < n; i++) {
			ans = min(ans, dp[n][i]);
		}
		printf ("%d\n", ans);
	}
	return 0;
}
```


---


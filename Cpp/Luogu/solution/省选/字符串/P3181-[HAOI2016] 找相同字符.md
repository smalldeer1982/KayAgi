# [HAOI2016] 找相同字符

## 题目描述

给定两个字符串，求出在两个字符串中各取出一个子串使得这两个子串相同的方案数。两个方案不同当且仅当这两个子串中有一个位置不同。


## 说明/提示

$1\le n_1,n_2\le 2\times 10^5$，字符串中只有小写字母。

## 样例 #1

### 输入

```
aabb
bbaa```

### 输出

```
10```

# 题解

## 作者：asuldb (赞：30)

其实这道题跟[[AHOI2013]差异](https://www.luogu.org/problemnew/show/P4248)很像

其实这个问题的本质就是让你算所有后缀的$lcp$长度之和，但是得来自两个不同的字符串

先把两个字符串拼起来做一遍$SA$，由于我们多算了来自于同一个串内的情况

于是在分别对这两个串建$SA$，减掉这两次算出来的答案

现在的问题转化为求出$height$数组所有子区间的最小值的和

我们可以考虑一个动态往序列末尾加数的过程

也就是我们往末尾加一个数都会和之前所有的数形成一个新的区间

考虑快速算出这些区间的最小值的和

我们可以对每一个数存储一个$a_i$，表示$i$到当前序列末尾的最小值是多少

我们每次加入一个数可以对更新一下所有的$a_i$，把所有比当前加入的数大的$a_i$变成当前数就好了

这不就$T$了吗

我们发现我们只需要求出所有$a_i$的和，并不需要关心这个$i$来自哪里，于是我们可以把相等的$a_i$放在一起计算，也就是每次新加入一个数就暴力扫一遍把那些比当前加入数大的合并到一个$a_i$里

看起来复杂度并不科学，但是最坏情况下就相当于是一个线段树的复杂度了，$O(n)$的，跑的还挺快的

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define re register
#define LL long long
#define maxn 400005
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
int het[maxn],sa[maxn],rk[maxn],tp[maxn],tax[maxn];
char S[maxn],T[maxn];
int L1,L2,n,m;
LL a[maxn],cnt[maxn],top;
LL tot;
inline void qsort()
{
    for(re int i=0;i<=m;i++) tax[i]=0;
    for(re int i=1;i<=n;i++) tax[rk[i]]++;
    for(re int i=1;i<=m;i++) tax[i]+=tax[i-1];
    for(re int i=n;i;--i) sa[tax[rk[tp[i]]]--]=tp[i];
}
inline LL SA()
{
    LL ans=0,sum=0;
    memset(rk,0,sizeof(rk)),memset(sa,0,sizeof(sa)),memset(het,0,sizeof(het)),memset(tp,0,sizeof(tp));
    memset(a,0,sizeof(a)),memset(cnt,0,sizeof(cnt)),top=0;
    m=2500;
    for(re int i=1;i<=n;i++) rk[i]=S[i],tp[i]=i;
    qsort();
    for(re int w=1,p=0;p<n;m=p,w<<=1)
    {
        p=0;
        for(re int i=1;i<=w;i++) tp[++p]=n-w+i;
        for(re int i=1;i<=n;i++) if(sa[i]>w) tp[++p]=sa[i]-w;
        qsort();
        for(re int i=1;i<=n;i++) std::swap(tp[i],rk[i]);
        rk[sa[1]]=p=1;
        for(re int i=2;i<=n;i++) rk[sa[i]]=(tp[sa[i-1]]==tp[sa[i]]&&tp[sa[i-1]+w]==tp[sa[i]+w])?p:++p;
    }
    int k=0;
    for(re int i=1;i<=n;i++)
    {
        if(k) --k;
        int j=sa[rk[i]-1];
        while(S[i+k]==S[j+k]) ++k;
        het[rk[i]]=k;
    }
    for(re int i=2;i<=n;i++)  
    {
        LL now=1;
        while(top&&het[i]<=a[top]) 
            now+=cnt[top],sum-=a[top]*cnt[top],top--;
        cnt[++top]=now;
        a[top]=het[i];
        sum+=cnt[top]*a[top];
        ans+=sum;
    }
    return ans;
}
int main()
{
    scanf("%s",S+1);scanf("%s",T+1);
    L1=strlen(S+1),L2=strlen(T+1);n=L1+L2+1;
    S[L1+1]='z'+1;
    for(re int i=1;i<=L2;i++) S[i+L1+1]=T[i];
    tot+=SA();
    for(re int i=L1+1;i<=n;i++) S[i]=0;
    n=L1;tot-=SA();
    for(re int i=1;i<=L2;i++) S[i]=T[i];
    for(re int i=L2+1;i<=n;i++) S[i]=0;
    n=L2;
    tot-=SA();
    printf("%lld\n",tot);
    return 0;
}
```

---

## 作者：totorato (赞：30)

# 找相同字符 ([HAOI2016、luogu3181)


## 题意：


​    给定两个由小写字母组成的字符串s1,s2(长度小于等于$2\times 10^4$)。求两个字符串各取一个子串，两子串相等的方案数。


## 分析:


$O(n^3)$：


​    首先，我们知道。如果连个串中各取一个极长的相同的子串(极长的意思就是这两个串再向两边延伸就会不同或出界)，则这个极长的串的所有子串也是相同的。


​    由于枚举极长的串并求出其长度并不方便，所以我们可以枚举这个极长的串的左端点，再求出其长度。这样就可以不重不漏找出所有的极长的串。更图方便的话，我们可以只考虑两原串中某后缀的所有前缀，这可以补充不漏找出所有的子串。但是由于我们要在两个字符串中枚举，同时找出子串的长度也要话费$O(n)$的代价，固总时间复杂度是$O(n^3)$的。


$O(n^2)$:


​    刚才说道了后缀的前缀，我们不由自主想到了后缀数组。如果我们可以很快求出A串和B串的某两个后缀的最长公共前缀，我们就可以将时间复杂度优化的更低。所以我们可以将两个字符串通过一个分隔符拼接起来，求出Height数组，即按字典序排序后每个后缀和前一个的LCP。再利用Height数组和ST表，我们就可以$O(1)$得到任意两后缀的LCP。因此，这样做的时间复杂度只有枚举子串起点的复杂度了，即$O(n^2)$。


$O(nlogn)$：


​    现在拉高时间复杂度的罪魁祸首就是枚举起点了。所以我们想将其复杂度降低。考虑到利用Height数组求任意两个后缀的LCP时的独特性质：两个后缀的LCP为字典序排序后他们中间夹的最小的Height。也就是说排序后，一个后缀越往后数LCP的长度越小。


​    这样，我们就可以用单调栈维护这个最小值。分A串的子串在前、B的子串在前两种情况分别用单调栈求出答案，加起来就行。至于如何维护，聪明的大家一定已经知道了。


​    由于利用了单调栈这个神奇的手段,时间复杂度降到了$O(nlogn)$。如果我们在构建后缀数组的时候采用DC3算法，我们甚至可以在线性时间内解决这道题。(当然我还是懒得打)


```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#define MX 823123

using namespace std;
typedef long long ll;
typedef struct tSA
{
    int str[MX],n,m;
    int rank[MX],SA[MX],het[MX];
    int buk[MX],yp[MX];
    bool cmp(int *f,int x,int y,int w){return f[x]==f[y]&&f[x+w]==f[y+w];}
    void jsort()
    {
        for(int i=0;i<=m;i++)buk[i]=0;
        for(int i=1;i<=n;i++)buk[rank[yp[i]]]++;
        for(int i=1;i<=m;i++)buk[i]+=buk[i-1];
        for(int i=n;i>=1;i--)SA[buk[rank[yp[i]]]--]=yp[i];
    }
    void getSA()
    {
        for(int i=1;i<=n;i++)rank[i]=str[i],yp[i]=i;
        m=28;jsort();
        for(int w=1;w<n;w<<=1)
        {
            int p=0;
            for(int i=n-w+1;i<=n;i++)yp[++p]=i;
            for(int i=1;i<=n;i++)if(SA[i]>w)yp[++p]=SA[i]-w;
            jsort(),swap(rank,yp),rank[SA[1]]=p=1;
            for(int i=2;i<=n;i++)rank[SA[i]]=(cmp(yp,SA[i],SA[i-1],w)?p:++p);
            m=p;
        }
        int k=0;
        for(int i=1;i<=n;i++)
        {
            k=(k?k-1:0);
            while(str[i+k]==str[SA[rank[i]-1]+k])k++;
            het[rank[i]]=k;
        }
    }
}SA;
SA sa;
char str[MX];
int l1,l2,top,sum[MX];
pair<int,ll>stk[MX];
void work()
{
    ll ans=0;
    stk[0]=make_pair(1,0);
    for(int i=1;i<=sa.n;i++)sum[i]=sum[i-1]+(sa.SA[i]<=l1);
    for(int i=1;i<=sa.n;i++)
    {
        while(top&&sa.het[stk[top].first]>sa.het[i])top--;
        top++;
        stk[top]=make_pair(i,(sum[i-1]-sum[stk[top-1].first-1])*sa.het[i]+stk[top-1].second);
        if(sa.SA[i]>l1+1)ans+=stk[top].second;
    }
    top=0;
    for(int i=1;i<=sa.n;i++)sum[i]=sum[i-1]+(sa.SA[i]>l1+1);
    for(int i=1;i<=sa.n;i++)
    {
        while(top&&sa.het[stk[top].first]>sa.het[i])top--;
        top++;
        stk[top]=make_pair(i,(sum[i-1]-sum[stk[top-1].first-1])*sa.het[i]+stk[top-1].second);
        if(sa.SA[i]<=l1)ans+=stk[top].second;
    }
    printf("%lld\n",ans);
}
int main()
{
    scanf("%s",str+1);l1=strlen(str+1);
    scanf("%s",str+l1+2);
    str[l1+1]='z'+1;
    sa.n=strlen(str+1);
    for(int i=1;i<=sa.n;i++)sa.str[i]=str[i]-'a'+1;
    sa.getSA();
    work();
    return 0;
}
```


---

## 作者：santongding (赞：24)

由于广义后缀自动机插入的时候还要复制一遍分裂节点的操作，十分不优美，再加上luogu题解里居然没有只建一坨后缀自动机的做法，果断写了一发

考虑对其中一个串建后缀自动机，再把另一个串放上去匹配进行统计答案；

设A为后缀自动机的那个串，B为要进行匹配的串

每匹配到B的第i个字符，为了不重不漏地统计答案此时应加入的就是以i为后缀的所有子串贡献的答案；

首先要记录一下在sam上现在匹配到的节点j时能匹配的长度是多少；设其为tv，那么在现在匹配的j这个节点所给的贡献就是|right(j)|*(tv-len[f[j]]),因为tv是不一定能够跑满len[j]的，但tv却一定比len[f[j]]要大；

然后剩下的就是统计所有j的父亲节点上的答案了，就是每一个节点的|right|*(len-len(fa)),提前拓扑排序预处理一下前缀和就好了

|right|是元素个数的意思orz

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define LL long long
const int maxn=2e5+5;
int len[maxn<<1],nxt[maxn<<1][26],f[maxn<<1],siz[maxn<<1],b[maxn<<1],pos[maxn<<1];
LL fsiz[maxn<<1];
struct SAM{
	int tot,last;
	SAM(){tot=last=1;}
	void add(int v){
		int p=last,now=last=++tot;
		len[now]=len[p]+1;
		siz[now]=1;
		while(p&&!nxt[p][v])nxt[p][v]=now,p=f[p];
		if(!p)f[now]=1;
		else{
			int q=nxt[p][v];
			if(len[p]+1==len[q])f[now]=q;
			else{
				int nq=++tot;
				len[nq]=len[p]+1;
				memcpy(nxt[nq],nxt[q],sizeof(nxt[q]));
				f[nq]=f[q];
				f[q]=f[now]=nq;
				while(p&&nxt[p][v]==q)nxt[p][v]=nq,p=f[p];
			}
		} 
	}
	void topsort(){
		for(int i=1;i<=tot;i++)b[len[i]]++;
		for(int i=1;i<=tot;i++)b[i]+=b[i-1];
		for(int i=1;i<=tot;i++)pos[b[len[i]]--]=i;
		for(int i=tot;i;i--)siz[f[pos[i]]]+=siz[pos[i]];
		for(int i=2;i<=tot;i++)fsiz[pos[i]]=(LL)(len[pos[i]]-len[f[pos[i]]])*siz[pos[i]]+fsiz[f[pos[i]]];
	}
	LL match(char *s){
		int n=strlen(s),p=1,tv=0;
		LL ans=0ll; 
		for(int i=0;i<n;i++){
			int v=s[i]-'a';
			while(p&&!nxt[p][v])p=f[p];
			if(!p)p=1,tv=0;
			else{
				tv=std::min(tv,len[p])+1;
				p=nxt[p][v];
				ans+=(LL)fsiz[f[p]]+(LL)(tv-len[f[p]])*siz[p];
			}
		}
		return ans;
	}
}sam;
char s[maxn];
int main()
{
	scanf("%s",s);
	int n=strlen(s);
	for(int i=0;i<n;i++)sam.add(s[i]-'a');
	sam.topsort();
	scanf("%s",s);
	printf("%lld\n",sam.match(s));
	return 0;
}
```


---

## 作者：czpcf (赞：18)

提示一下，这道题可以用一个栈来维护，但细节很多。

那我们可以先将两个字符串接在一起，先算出这个A+B的串中所有相同的子串的个数，这是很好写的。

然后用容斥，减去（两个在A中选）与（两个在B中选）的个数，但我们并不需要在A+B这个长串中计算。我们可以单独对A和B统计相同的子串的个数。那么剩下来的就是（一个在A中选，一个在B中选）的个数。

总复杂度：O(log n (2 |A|+2 |B|))

```cpp
#include<bits/stdc++.h>FSYAKIOI
using namespace std;
typedef long long int ll;
const ll maxn=4E5+5;
ll sa[maxn],rk[maxn],y[maxn],c[maxn],n,m,height[maxn],ans,f[maxn];
string s1,s2,str;
void SS()
{
	m='~';
	for(int i=1;i<=n;++i)++c[rk[i]=str[i]];
	for(int i=1;i<=m;++i)c[i]+=c[i-1];
	for(int i=n;i>=1;--i)sa[c[rk[i]]--]=i;
	for(int k=1;k<=n;k<<=1)
	{EVENBAOAKIOI
		int num=0;
		for(int i=n-k+1;i<=n;++i)y[++num]=i;
		for(int i=1;i<=n;++i)if(sa[i]>k)y[++num]=sa[i]-k;
		for(int i=1;i<=m;++i)c[i]=0;
		for(int i=1;i<=n;++i)++c[rk[i]];
		for(int i=1;i<=m;++i)c[i]+=c[i-1];
		for(int i=n;i>=1;--i)sa[c[rk[y[i]]]--]=y[i],y[i]=0;
		swap(rk,y);
		rk[sa[1]]=num=1;
		for(int i=2;i<=n;++i)
		{
			if(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k])rk[sa[i]]=num;
			else rk[sa[i]]=++num;
		}
		if(num==n)break;
		m=num;
	}
}
void lcp()
{
    int cur=0;
    for(int i=1;i<=n;++i)
    {
        if(cur)--cur;
        int j=sa[rk[i]-1];
        while(str[j+cur]==str[i+cur])++cur;
        height[rk[i]]=cur;
    }
}
void out()
{
	cout<<str<<" "<<n<<endl;
	for(int i=1;i<=n;++i)cout<<sa[i]<<' ';
	cout<<endl;
	for(int i=1;i<=n;++i)cout<<height[i]<<' ';
	cout<<endl;
	for(int i=1;i<=n;++i,cout<<endl)
		for(int j=sa[i];j<=n;++j)
			cout<<str[j];
}
void solve(int flag,string PCF)
{
	memset(height,0,sizeof(height));
	memset(rk,0,sizeof(rk));
	memset(y,0,sizeof(y));
	memset(c,0,sizeof(c));
	memset(f,0,sizeof(f));
	n=PCF.size();
	PCF="~"+PCF;
	str=PCF;
	SS();
	lcp();FSYAKIOI
	stack<ll>S;
	ll sum=0;
	for(int i=2;i<=n;++i)
	{
		while(S.size()&&height[S.top()]>=height[i])S.pop();
		if(S.size()==0)f[i]=height[i]*(i-1);
		else f[i]=f[S.top()]+height[i]*(i-S.top());
		S.push(i);
		sum+=f[i]*flag;
	}
	ans+=sum;
}
int main()
{
//	freopen("a.in","r",stdin);
	ios::sync_with_stdio(false);
	cin>>s1>>s2;
	solve(1,s1+"~"+s2);
	solve(-1,s1);
	solve(-1,s2);
	cout<<ans<<endl;
	return 0;
}

```

---

## 作者：ニヒル (赞：15)

本来准备对着这道题学广义后缀自动机的，结果并不是很看得懂其他题解，尤其是不知道为什么要拓扑排序……  
最后糊了一个自己猜的广义后缀自动机，暴力建parent树dfs了一遍，也过了，就简介一下自己的做法吧（有错误请大佬指出

首先每次插入子串的时候把last设回root，然后插入新的np节点的时候，如果已经有这个这个节点且节点与它表示的字符集完全一模一样的话，就不用新建np节点了，只需要标记这个点在第i个串上是np类节点就可以了

根据某个性质，一个节点所代表的所有字符串在后缀自动机上出现的次数是其在parent树的子树中np类节点的个数

暴力建出parent树，dfs整棵树  
我们可以很容易知道同一个节点在第一个串里出现了几遍，在第二个串里出现了几遍，同时这个节点的字符集大小就是它的len-父亲的len  
根据乘法原理，每个点的贡献就是$(t[now].len-t[t[now].fa].len)*sz[now][0]*sz[now][1]$

dfs的同时统计答案即可

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;

char s1[200020],s2[200020];

struct SAM
{
    struct point
    {
        int son[26],fa,mx,len;
    }t[800080];

    int last=1,cnt=1;
    vector<int> g[800080];
    int sz[800080][2];

    void add(int c,int num)
    {
        int p=last;
        if(t[p].son[c]&&t[p].len+1==t[t[p].son[c]].len)
        {
            last=t[p].son[c];
            sz[last][num]++;
            return ;
        }
        int np=++cnt;
        t[np].len=t[p].len+1;
        sz[np][num]++;
        while(p&&!t[p].son[c])
        {
            t[p].son[c]=np;
            p=t[p].fa;
        }
        if(!p)
        {
            t[np].fa=1;
        }
        else
        {
            int q=t[p].son[c],nq;
            if(t[q].len==t[p].len+1)
            {
                t[np].fa=q;
            }
            else
            {
                nq=++cnt;
                t[nq]=t[q];
                t[nq].len=t[p].len+1;
                t[np].fa=t[q].fa=nq;
                while(p&&t[p].son[c]==q)
                {
                    t[p].son[c]=nq;
                    p=t[p].fa;
                }
            }
        }
        last=np;
    }

    long long ans=0;

    int dfs(int now)
    {
        t[now].mx=t[now].len-t[t[now].fa].len;
        for(int i=0;i<g[now].size();i++)
        {
            dfs(g[now][i]);
            sz[now][0]+=sz[g[now][i]][0];
            sz[now][1]+=sz[g[now][i]][1];
        }
        ans+=1ll*t[now].mx*sz[now][0]*sz[now][1];
    }

    int solve()
     {
        for(int i=1;i<=cnt;i++) g[t[i].fa].push_back(i);
        dfs(1);
        printf("%lld\n",ans);
    }
}sam;

int main()
{
    scanf("%s",s1);
    scanf("%s",s2);
    int len1=strlen(s1);
    int len2=strlen(s2);
    for(int i=0;i<len1;i++)
    {
        sam.add(s1[i]-'a',0);
    }
    sam.last=1;
    for(int i=0;i<len2;i++)
    {
        sam.add(s2[i]-'a',1);
    }
    sam.solve();
}
```

---

## 作者：LittleDino (赞：11)

安利本人博客 [Little Dino luogu3181[HAOI2016]找相同字符 [SAM]](https://dino.ml)  

Orz 楼下神仙zyt（尽管写这篇题解的原因纯粹是是因为看他的方法实在是太麻烦了……）如果你觉得文字很多很烦然后你对 $SAM$ 并非一窍不通可以直接跳到第六段“简单来说”。

对于有多个串的问题，我们可以建广义 $SAM$，但是实际上没有什么必要，可以将每两个串之间用一个奇怪的字符（例如 $'a'+26$）全部连起来，变成一个串，对于这个串建 $SAM$。

然后可以发现，如果这两个串有一个子串相同，那么这个子串在 $SAM$ 上对应的是同一个节点。我们转化一下，如果 $SAM$ 上的一个节点在串 $A$ 中的 $right$ 集合大小为 $a$，在串 $B$ 中的 $right$ 集合大小为 $b$，那么 $a$ ，$b$ 中任意两个配对都是一个合法的情况（即子串相同）。

又因为要求是本质不同的子串，$SAM$ 上每个节点代表了长度在 $[minlen,maxlen]$ 之间的相同的子串，故每个点的贡献还要乘上 $maxlen-minlen+1$。

简单来说，连接串 $A$，$B$ 建在一个 $SAM$ 上，如果用 $tot$ 表示 $SAM$ 的点数， $size[i][0/1]$ 表示 $SAM$ 上节点 $i$ 中包含的串 $A$ 或 $B$ 的 $right$ 集合的大小，$mx[i]$ 表示点 $i$ 的 $maxlen$，那么
$$
ans=\sum_{i=1}^{tot} size[i][0] \times size[i][1] \times (mx[i] - mx[fa[i]])
$$

代码写起来就是 $SAM$ 的基础操作：插入和基数排序

```cpp
#include<bits/stdc++.h>
using namespace std;

namespace TYC
{
    const int N=800010;

    long long ans;

    namespace SAM
    {
        int last=1,tot=1,size[N][2];

        struct node
        {
            int fa,mx,son[27];
        }tr[N];

        void insert(const int c,const int id)
        {
            int now=++tot,p=last;
            tr[now].mx=tr[p].mx+1;
            if(id!=2) size[now][id]++;
            while(p&&!tr[p].son[c])
                tr[p].son[c]=now,p=tr[p].fa;
            if(!p) tr[now].fa=1;
            else 
            {
                int q=tr[p].son[c];
                if(tr[q].mx==tr[p].mx+1) tr[now].fa=q;
                else 
                {
                    int clone=++tot;
                    tr[clone]=tr[q];
                    tr[clone].mx=tr[p].mx+1;
                    tr[q].fa=tr[now].fa=clone;
                    while(p&&tr[p].son[c]==q)
                        tr[p].son[c]=clone,p=tr[p].fa;
                }
            }
            last=now;
        }

        void radix_sort()
        {
            static int bask[N],q[N];
            for(int i=1;i<=tot;i++) bask[tr[i].mx]++;
            for(int i=1;i<=tot;i++) bask[i]+=bask[i-1];
            for(int i=tot;i;i--) q[bask[tr[i].mx]--]=i;
            for(int i=tot;i>1;i--)
            {
                int now=q[i],f=tr[now].fa;
                size[f][0]+=size[now][0];
                size[f][1]+=size[now][1];
                ans+=(long long)size[now][0]*size[now][1]*(tr[now].mx-tr[f].mx);
            }
        }
    }

    void work()
    {
        static char s[N>>1];
        scanf("%s",s);
        int len=strlen(s);
        for(int i=0;i<len;i++)
            SAM::insert(s[i]-'a',0);
        SAM::insert(26,2);
        scanf("%s",s);
        len=strlen(s);
        for(int i=0;i<len;i++)
            SAM::insert(s[i]-'a',1);
        SAM::radix_sort();
        printf("%lld",ans);
    }
}

int main()
{
    TYC::work();
    return 0;
}
```

---

## 作者：Tyher (赞：9)

真是好题……。

关于单调栈的比较有技巧性的做法 

~~如果大佬认为没有技巧性就自动掠过~~：


我们要求的实际上就是：

$\sum_{Sa_i<n+1<Sa_j}min_{i\leq k\leq j }\ ht_k + \sum_{Sa_j<n+1<Sa_i}min_{j\leq k\leq i }\ ht_k$


从前往后维护一个单调递增的单调栈，为什么楼下大佬已经讲得很清楚了。

每个位置记$val$和$ht$，就是当前这个节点有的总数和的$ht$

这里按排名从后往前做。（为什么最后会讲）

先只考虑$S1$串插入，$S2$串查询。

我们每遇到一个串，就要判断是在$S1$还是在$S2$，如果在$S1$，就直接加上前面所有的答案之和。

然后弹栈，注意这个时候不是真正的弹，而是和之前的东西**合并**，因为现在的栈顶的最大元素已经不会取到了，所以可以将它与栈的第二个元素合并，也就是$val_{top-1}+=val_{top}$

也就是说本质上还不是单调栈，是维护一个最小值。

如果是在$S2$，$val_{top}$加一，也就是有一个新的元素入栈。

然后更新将加入答案的$now$。

至于为什么要从后往前做？因为$height$数组的定义是当前排名和上一排名的$lcp$。

也就是说如果从前往后做，那么对于排名$i$而言，查询$i-1$产生的贡献，将会是$i-2$和$i-1$的$lcp$，这样就不对了。

但是如果我们是从后往前，那么对于排名$i$而言，查询$i+1$产生的贡献，将会是$i$和$i+1$的$lcp$，这样就对了。

贴单调栈部分的代码：

```
ll sol(R b){
    ll res=0,now=0,rec=0;
    while(top)STK[top]=val[top]=0,top--;
    for(R i=n-1;i>=1;--i){
        rec=0;
        if((sa[i]>len1+1)^b)res+=now;
        while(STK[top]>=ht[i]&&top)
            now-=1ll*STK[top]*val[top],rec+=val[top--];
        STK[++top]=ht[i],val[top]=rec;
        if((sa[i]<=len1)^b)val[top]++;
        now+=1ll*val[top]*STK[top];
    }
    return res;
}
```

$b$表示的含义是：$S1$查询$S2$修改 或者 $S2$查询$S1$修改

最后的答案是$sol(0)+sol(1)$

---

## 作者：ywy_c_asm (赞：8)

~~看到没有分治做的赶紧来水一发……~~

如果这是在一个字符串中的那就相当于是所有两个后缀的$LCP$，可以跑一遍$SA$然后用$Height$求，但这是两个字符串，那么我们就可以用个特殊符号连起来再跑$SA$，但是会有在同一个字符串内的方案，那么我们可以容斥，把总体的方案减去两个字符串内的方案就行了。

至于答案如何求，我们知道两个后缀的$LCP$是$Height$区间内的$min$，我们要统计所有后缀对，相当于求$\sum_{[l,r]\in[1,n]}min_{i\in [l,r]}\{Height_i\}$，这个可以用最裸的统计所有区间的分治求出来。

上代码~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
namespace ywy
{
	inline int get(char *str)
	{
		register int ptr=1;
		char c;
		while((c=getchar())||23333)if(c>='a'&&c<='z')break;
		str[ptr]=c;
		ptr++;
		while((c=getchar())||23333)
		{
			if(c>='a'&&c<='z')str[ptr]=c,ptr++;
			else return(ptr-1);
		}
	} char str1[500001],str2[500001],str[500001];
	unsigned char bv[500001];
	int sa[500001],rk[500001],tsa[500001],trk[500001],temp[500001],sums[500001],lst[500001],lstcnt[500001];
	int h[500001],height[500001],mins[500001];
	ll tot=0;
	void digui(int l,int r)
	{
		if(l==r)
		{
			tot+=height[l];
			return;
		}
		int mid=(l+r)>>1;
		digui(l,mid);
		digui(mid+1,r);
		mins[mid]=height[mid];
		mins[mid+1]=height[mid+1];
		for(register int i=mid-1; i>=l; i--)mins[i]=min(mins[i+1],height[i]);
		for(register int i=mid+2; i<=r; i++)mins[i]=min(mins[i-1],height[i]);
		register int ptr=mid;
		for(register int i=mid; i>=l; i--)
		{
			while(ptr<r&&mins[ptr+1]>=mins[i])ptr++;
			tot+=(ll)mins[i]*(ll)(ptr-mid);
		}
		ptr=mid+1;
		for(register int i=mid+1; i<=r; i++)
		{
			while(ptr>l&&mins[ptr-1]>mins[i])ptr--;
			tot+=(ll)mins[i]*(ll)(mid+1-ptr);
		}
	}
	inline int getrank(int a,int b)
	{
		if(lst[a]==b)
		{
			lstcnt[a]++;
			return(sums[a]);
		}
		sums[a]-=lstcnt[a];
		lst[a]=b;
		lstcnt[a]=1;
		return(sums[a]);
	}
	inline void SA(int n)
	{
		memset(sums,0,sizeof(sums));
		for(register int i=1; i<=n; i++)sums[str[i]]++;
		for(register int i=1; i<='z'; i++)sums[i]+=sums[i-1];
		for(register int i=1; i<=n; i++)rk[i]=sums[str[i]-1]+1;
		for(register int i=1; i<=n; i++)sa[sums[str[i]]]=i,sums[str[i]]--;
		for(register int bit=1; (1<<(bit-1))<=n; bit++)
		{
			memset(sums,0,sizeof(sums));
			unsigned char bswitch=1;
			for(register int i=1; i<=n; i++)sums[rk[i]]++,bv[i]=0;
			for(register int i=1; i<=n; i++)sums[i]+=sums[i-1],lst[i]=-1,temp[i]=sums[i],lstcnt[i]=0;
			for(register int i=n; i>=1; i--)
			{
				if(sa[i]<=(1<<(bit-1)))continue;
				trk[sa[i]-(1<<(bit-1))]=getrank(rk[sa[i]-(1<<(bit-1))],rk[sa[i]]);
				tsa[temp[rk[sa[i]-(1<<(bit-1))]]]=sa[i]-(1<<(bit-1));
				temp[rk[sa[i]-(1<<(bit-1))]]--;
			}
			for(register int i=n; i>n-(1<<(bit-1)); i--)
			{
				trk[i]=getrank(rk[i],0);
				tsa[temp[rk[i]]]=i;
				temp[rk[i]]--;
			}
			for(register int i=1; i<=n; i++)
			{
				sa[i]=tsa[i];
				rk[i]=trk[i];
				if(bv[rk[i]])bswitch=0;
				bv[rk[i]]=1;
			}
			if(bswitch)break;
		}
	}
	inline void Height(int n)
	{
		while(rk[1]!=1&&h[1]<n-sa[rk[1]-1]+1&&str[1+h[1]]==str[sa[rk[1]-1]+h[1]])h[1]++;
		height[rk[1]]=h[1];
		for(register int i=1; i<=n; i++)
		{
			h[i]=max(0,h[i-1]-1);
			while(rk[i]!=1&&h[i]<min(n-i+1,n-sa[rk[i]-1]+1)&&str[i+h[i]]==str[sa[rk[i]-1]+h[i]])h[i]++;
			height[rk[i]]=h[i];
		}
	}
	inline ll solve(int n)
	{
		tot=0;
		SA(n);
		Height(n);
		digui(1,n);
		return(tot);
	}
	void ywymain()
	{
		int n1=get(str1),n2=get(str2);
		memcpy(str,str1,sizeof(str));
		ll da=solve(n1);
		memcpy(str,str2,sizeof(str));
		ll db=solve(n2);
		int ptr=1;
		for(register int i=1; i<=n1; i++)str[ptr]=str1[i],ptr++;
		str[ptr]='C';
		ptr++;
		for(register int i=1; i<=n2; i++)str[ptr]=str2[i],ptr++;
		ptr--;
		cout<<solve(ptr)-da-db<<endl;
	}
}
int main()
{
	ywy::ywymain();
	return(0);
}
```

---

## 作者：神之右大臣 (赞：7)

发现题解中的后缀自动机不是广义SAM就是将两个串拼在一起整的乱糟糟的，所以来一发普通的后缀自动机题解；

蒟蒻不会广义后缀自动机，所以把这道题当作普通后缀自动机的模板来写；

首先我们对于串s和串t分别构造一个SAM；通过SAM基础操作(利用parent树或基数排序)求出每个子串在原串的出现次数right[]；

然后都从两个自动机的根节点:1号节点跑dfs；

我们知道，对于在两个SAM上转移方式相同而到达的两个节点(尽管他们的节点编号不同，尽管他们并不在一个SAM上)，它们均可以表示同一个子串；

那么显然，答案就是所有两个SAM的转移方式相同的节点x,y的right[x]*right[y]的累加

注意，虽然SAM的节点表示的是endpos等价类，并不是子串，但是我们可以通过不同的转移在两个SAM上转移到相同的点对(x,y);这意味着我们无需关注SAM节点中的len这一属性；

代码就在下面：不理解的请看~~horse~~码

```cpp
#include <bits/stdc++.h>
#define inc(i,a,b) for(register int i=a;i<=b;i++)
#define dec(i,a,b) for(register int i=a;i>=b;i--)
using namespace std;
char s[1000010],t[1000010];
int n,m;
class node2{
	public:
	class node1{
		public:
		int link,len;
		int ch[27];
	}sam[1000010];
	int	last=1,size=1;
	long long siz[1000010];
	void add(int to){
		int cur=++size; siz[cur]=1; 
		sam[cur].len=sam[last].len+1;
		int u=last;
		while(u&&!sam[u].ch[to]) sam[u].ch[to]=cur,u=sam[u].link;
		if(!u) sam[cur].link=1;
		else{
			int q=sam[u].ch[to];
			if(sam[q].len==sam[u].len+1) sam[cur].link=q;
			else{
				int neww=++size;
				sam[neww]=sam[q];
				sam[neww].len=sam[u].len+1;
				while(u&&sam[u].ch[to]==q) sam[u].ch[to]=neww,u=sam[u].link;
				sam[q].link=neww;
				sam[cur].link=neww;
			}
		}
		last=cur;
	}
}SAM1,SAM2;
long long ans=0;
void dfs(int x,int y){
	for(int i=0;i<=25;i++){
		if(SAM1.sam[x].ch[i]&&SAM2.sam[y].ch[i]){
			dfs(SAM1.sam[x].ch[i],SAM2.sam[y].ch[i]);
		}		
	}	
	if(x!=1&&y!=1) ans+=SAM1.siz[x]*SAM2.siz[y];
}
int c1[1000010],t1[1000010],c2[1000010],t2[1000010];
int main()
{
	scanf("%s%s",s+1,t+1); n=strlen(s+1),m=strlen(t+1);
	inc(i,1,n) SAM1.add(s[i]-'a');
	inc(i,1,m) SAM2.add(t[i]-'a');
	inc(i,1,SAM1.size) c1[SAM1.sam[i].len]++;
	inc(i,1,n) c1[i]+=c1[i-1];
	inc(i,1,SAM1.size) t1[c1[SAM1.sam[i].len]--]=i;
	dec(i,SAM1.size,1) SAM1.siz[SAM1.sam[t1[i]].link]+=SAM1.siz[t1[i]];
	inc(i,1,SAM2.size) c2[SAM2.sam[i].len]++;
	inc(i,1,m) c2[i]+=c2[i-1];
	inc(i,1,SAM2.size) t2[c2[SAM2.sam[i].len]--]=i;
	dec(i,SAM2.size,1) SAM2.siz[SAM2.sam[t2[i]].link]+=SAM2.siz[t2[i]];
	dfs(1,1); cout<<ans;
}
```





---

## 作者：kczno1 (赞：6)

题目相当于问，s1的每个后缀和s2的的最长公共前缀的和。

后缀数组。

首先，我们将两个字符串拼在一起，中间隔个空格。

然后，求出height。

之后从前往后扫，如果遇见s1的，就计算已有s2的和，加入；如果遇见s2的，就计算已有s1的和，加入；每次还要对所有元素取min。

用单调栈即可。


---

## 作者：Great_Influence (赞：4)

广义SAM。


其实也没怎么高级，就是将SAM建在同一个位置上，共用节点而已。


随便想想就可以知道，答案应该是


$\sum\limits_{p\in DAWG}cnt1_p\cdot cnt2_p\cdot (max_p-min_p+1)$


其中，如果设p指向的link节点为q，则$min_p=max_q+1$


对于上面的式子，建好广义后缀自动机后，按照拓扑序排好，走一遍就可以了。注意$t_0$不产生贡献，不要加入拓扑序。


代码：

```cpp
    #include<bits/stdc++.h>
    #include<cctype>
    #define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)
    #define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)
    #define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
    #define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
    using namespace std;
    template<typename T>inline void read(T &x){
        T s=0,f=1;char k=getchar();
        while(!isdigit(k)&&k^'-')k=getchar();
        if(!isdigit(k)){f=-1;k=getchar();}
        while(isdigit(k)){s=s*10+(k^48);k=getchar();}
        x=s*f;
    }
    void file(void){
        #ifndef ONLINE_JUDGE
        freopen("water.in","r",stdin);
        freopen("water.out","w",stdout);
        #endif
    }
    const int MAXN=2e5+7;
    static char a[MAXN],b[MAXN];
    void init()
    {
        scanf("%s%s",a,b);
    }
    static struct DAWG
    {
        int len,link,nxt[30],cnt[2];
    }p[MAXN<<2];
    static int last=0,cur,nq,e=0;
    inline void extend(int c,int tr)
    {
        p[cur=++e].len=p[last].len+1;p[cur].cnt[tr]=1;
        static int i,q;
        for(i=last;~i&&!p[i].nxt[c];i=p[i].link)p[i].nxt[c]=cur;
        if(i==-1)p[cur].link=0;
        else
        {
            q=p[i].nxt[c];
            if(p[i].len+1==p[q].len)p[cur].link=q;
            else
            {
                p[nq=++e].len=p[i].len+1;
                memcpy(p[nq].nxt,p[q].nxt,sizeof p[q].nxt);
                p[nq].link=p[q].link;
                p[q].link=p[cur].link=nq;
                for(;~i&&p[i].nxt[c]==q;i=p[i].link)p[i].nxt[c]=nq;
            }
        }
        last=cur;
    }
    static int que[MAXN<<2];
    static long long ans;
    static int in[MAXN<<2],h,t;
    void solve()
    {
        p[0].link=-1;
        static int n=strlen(a)-1,m=strlen(b)-1;
        Rep(i,0,n)extend(a[i]-'a',0);
        last=0;
        Rep(i,0,m)extend(b[i]-'a',1);
        Rep(i,1,e)++in[p[i].link];
        Rep(i,1,e)if(!in[i])que[++t]=i;
        while(t<e)if(!(--in[p[que[++h]].link]))que[++t]=p[que[h]].link;
        Rep(i,1,e)
        {
            ans+=1ll*p[que[i]].cnt[0]*p[que[i]].cnt[1]
                *(p[que[i]].len-p[p[que[i]].link].len);
            p[p[que[i]].link].cnt[0]+=p[que[i]].cnt[0];
            p[p[que[i]].link].cnt[1]+=p[que[i]].cnt[1];
        }
        printf("%lld\n",ans);
    }
    int main(void){
        file();
        init();
        solve();
        return 0;
    }

```

---

## 作者：zyt1253679098 (赞：3)

~~广告~~

~~不太会用洛谷的markdown，格式可能乱了，安利个人博客~~

~~[【BZOJ4566_洛谷3181】[HAOI2016]找相同字符（SAM）](https://www.cnblogs.com/zyt1253679098/p/10255109.html)~~

分析：

SAM（可能是）模板题（不会SAM的同学戳我：[【知识总结】后缀自动机的构建](https://www.cnblogs.com/zyt1253679098/p/10154255.html)）。

对$s1$建出SAM，用$s2$在上面跑。用$size[i]$表示结点$i$的$Right$集合大小（直接拓扑排序后DP就行）。既然要求$s2$中有多少子串在$s1$中出现了，那么用$f[i]$表示结点$i$对应的**所有**子串在$s2$中**一共**出现了多少次（位置不同算多次）。答案就是$\sum f[i]\cdot size[i]$

如何计算$f[i]$呢？如果当前匹配过程中走到了$p$点，匹配长度为$len$。很明显，当前匹配到的是从$p$点沿着$fa$链到根的路径上对应的长度不大于$len$的字符串。它对$f[p]$有$len-min[p]+1=len-max[fa[p]]$的贡献（SAM上$min[p]-1=max[fa[p]]$），且对这条路径上任意一点$q$的$f[q]$都有$max[q]-min[q]+1=max[q]-max[fa[q]]$的贡献。可以发现此时只有对$f[p]$的贡献与$len$有关，对其他结点$q$的贡献只取决于$q$在$fa$树上的子树的访问次数之和（乘上$max[q]-max[fa[q]]$）。所以这里只处理对$f[p]$的贡献，并记录一下$p$被访问了多少次，处理完后一起推上去就行了（类似树上差分）。时间复杂度$O(n)$。这里可能讲得不清楚，详见代码qwq。

代码：


```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cctype>
#include <string>
#undef i
#undef j
#undef k
#undef true
#undef false
#undef min
#undef max
#undef sort
#undef swap
#undef if
#undef for
#undef while
#undef printf
#undef scanf
#undef putchar
#undef getchar
#define _ 0
using namespace std;

namespace zyt
{
	const int N = 2e5 + 10;
	template<typename T>
	inline bool read(T &x)
	{
		bool f = false;
		char c;
		x = 0;
		do
			c = getchar();
		while (c != EOF && c != '-' && !isdigit(c));
		if (c == EOF)
			return false;
		if (c == '-')
			f = true, c = getchar();
		do
			x = x * 10 + c - '0', c = getchar();
		while (isdigit(c));
		if (f)
			x = -x;
		return true;
	}
	inline bool read(string &s)
	{
		static char buf[N];
		if (scanf("%s", buf) == -1)
			return false;
		s = buf;
		return true;
	}
	template<typename T>
	inline void write(T x)
	{
		static char buf[20];
		char *pos = buf;
		if (x < 0)
			putchar('-'), x = -x;
		do
			*pos++ = x % 10 + '0';
		while (x /= 10);
		while (pos > buf)
			putchar(*--pos);
	}
	const int CH = 26;
	typedef long long ll;
	string s1, s2;
	namespace Auto_Suffix_Chicken
	{
		struct node
		{
			int size, max, fa, s[CH];
		}tree[N << 1];
		int len, cnt, last;
		inline void init()
		{
			cnt = last = 1;
		}
		inline int ctoi(const char c)
		{
			return c - 'a';
		}
		void insert(const char c)
		{
			int x = ctoi(c), np = ++cnt, p = last;
			tree[np].max = tree[p].max + 1;
			tree[np].size = 1;
			while (p && !tree[p].s[x])
				tree[p].s[x] = np, p = tree[p].fa;
			if (!p)
				tree[np].fa = 1;
			else
			{
				int q = tree[p].s[x];
				if (tree[p].max + 1 == tree[q].max)
					tree[np].fa = q;
				else
				{
					int nq = ++cnt;
					memcpy(tree[nq].s, tree[q].s, sizeof(char[CH]));
					tree[nq].max = tree[p].max + 1;
					tree[nq].fa = tree[q].fa;
					tree[np].fa = tree[q].fa = nq;
					while (p && tree[p].s[x] == q)
						tree[p].s[x] = nq, p = tree[p].fa;
				}
			}
			last = np;
		}
		int buf[N << 1];
		void radix_sort()
		{
			static int count[N];
			memset(count, 0, sizeof(int[len + 1]));
			for (int i = 1; i <= cnt; i++)
				++count[tree[i].max];
			for (int i = 1; i <= len; i++)
				count[i] += count[i - 1];
			for (int i = cnt; i > 0; i--)
				buf[count[tree[i].max]--] = i;
		}
		void build(const string &s)
		{
			init();
			len = s.size();
			for (int i = 0; i < s.size(); i++)
				insert(s[i]);
			radix_sort();
			for (int i = cnt; i > 0; i--)
				tree[tree[buf[i]].fa].size += tree[buf[i]].size;
		}
		inline ll query(const string &s)
		{
			static ll f[N << 1];
			static int num[N << 1];
			memset(f, 0, sizeof(ll[cnt + 1]));
			memset(num, 0, sizeof(int[cnt + 1]));
			ll ans = 0;
			int now = 1, len = 0;
			for (int i = 0; i < s.size(); i++)
			{
				int x = ctoi(s[i]);
				while (now && !tree[now].s[x])
					now = tree[now].fa, len = tree[now].max;
				if (now)
					now = tree[now].s[x], ++len;
				else
					now = 1, len = 0;
				f[now] += (len - tree[tree[now].fa].max), ++num[now];
			}
			radix_sort();
			for (int i = cnt; i > 0; i--)
			{
				int tmp = tree[buf[i]].fa;
				f[tmp] += (ll)num[buf[i]] * (tree[tmp].max - tree[tree[tmp].fa].max);
				num[tmp] += num[buf[i]];
			}
			for (int i = 2; i <= cnt; i++)
				ans += f[i] * tree[i].size;
			return ans;
		}
	}
	int work()
	{
		using namespace Auto_Suffix_Chicken;
		read(s1), read(s2);
		build(s1);
		write(query(s2));
		return (0^_^0);
	}
}
int main()
{
	freopen("4566.in", "r", stdin);
	freopen("4566.out", "w", stdout);
	return zyt::work();
}
```

---

## 作者：Jμdge (赞：3)

其实这道题就是个比较裸的 SAM ？

我们考虑到可以先建一个串 1 的 sam ，然后处理一下每个节点的 siz 和 sum 
（其中 siz 表示某个节点代表的后缀出现次数， sum 表示以当前点代表的后缀的子串的所有后缀出现次数）


然后串 2 去匹配就好了（话说这个匹配过程不是非常像  AC 自动机么？）

# code

```
//by Judge
#include<bits/stdc++.h>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define ll long long
using namespace std;
const int M=4e5+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline bool cmin(int& a,int b){return a>b?a=b,1:0;}
inline void reads(string& s){ char c=getchar();
	for(;!isalpha(c);c=getchar()); s=" ";
	for(;isalpha(c);c=getchar()) s+=c;
} int n; string s;
struct SAM{ int las,cnt; SAM(){las=cnt=1;}
	arr fa,len,siz,c,sa; int to[M][26]; ll sum[M];
	inline void insert(int c){ int p=las,np=++cnt;
		las=np,len[np]=len[p]+1,siz[np]=1;
		for(;p&&!to[p][c];p=fa[p]) to[p][c]=np;
		if(!p) return fa[np]=1,void(); int q=to[p][c];
		if(len[q]==len[p]+1) return fa[np]=q,void();
		int nq=++cnt; len[nq]=len[p]+1,fa[nq]=fa[q];
		fa[q]=fa[np]=nq,memcpy(to[nq],to[q],sizeof to[q]);
		for(;p&&to[p][c]==q;p=fa[p]) to[p][c]=nq;
	}
	inline void sa_sort(){ fp(i,1,cnt) ++c[len[i]]; fp(i,1,cnt) c[i]+=c[i-1];
		fp(i,1,cnt) sa[c[len[i]]--]=i; fd(i,cnt,1) siz[fa[sa[i]]]+=siz[sa[i]];
		fp(i,1,cnt) sum[sa[i]]=sum[fa[sa[i]]]+1ll*(len[sa[i]]-len[fa[sa[i]]])*siz[sa[i]];
	}
	inline ll match(){
		int p=1,now=0,c; ll ans=0;
		fp(i,1,n){ c=s[i]-'a';
			for(;p&&!to[p][c];p=fa[p]);
			if(!p){p=1,now=0; continue;}
			cmin(now,len[p]),++now,p=to[p][c];
			ans+=sum[fa[p]]+(now-len[fa[p]])*siz[p]; //加上 fa 的 sum 以及（当前最大匹配长度-fa 算过的贡献）* 当前后缀出现次数
		} return ans;
	}
}p;
int main(){ reads(s),n=s.length()-1;
	fp(i,1,n) p.insert(s[i]-'a');
	p.sa_sort(),reads(s),n=s.length()-1;
	return !printf("%lld\n",p.match());
}
```

---

## 作者：lxd150039 (赞：3)

楼上过程说的很详细啦，蒟蒻主要就贴个代码。

注意，A串和B串间必须穿插一个分割符号，以免出现A串的后缀匹配到B串来了，不加会安拉胡阿克巴。

单调栈的时候注意要加一个系数（因为弹出来的元素实际上会重新放回去）。

主要自己动手模拟一遍就行啦OvO

```cpp
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<string>
#define N 1000005
using namespace std;

long n,m,i,j,k,len=0,p,ans=0,s[N],SA[N],rk[N],height[N],H[N];
long x[N],tmp[N];
long sta[N],stb[N],weigha[N],weighb[N],ta,tb,nowa,nowb,cnt;//weigha,weighb是系数
string a,b;
bool cmp(long t[],long a,long b,long w){return t[a]==t[b]&&t[a+w]==t[b+w];}
void Rsort()
{
    long i,j;
    for (i=0; i<=m; i++) tmp[i]=0;
    for (i=1; i<=n; i++) tmp[rk[x[i]]]++;
    for (i=1; i<=m; i++) tmp[i]+=tmp[i-1];
    for (i=n; i; i--) SA[tmp[rk[x[i]]]]=x[i],tmp[rk[x[i]]]--;
}
void getSA()
{
    long i,w,p;
    for (i=1; i<=n; i++) rk[i]=s[i],x[i]=i;
    m=127; Rsort();
    for (w=1,p=1; p<n; w<<=1,m=p)
    {
        for (p=0,i=n-w+1; i<=n; i++) p++,x[p]=i;
        for (i=1; i<=n; i++)
            if(SA[i]>w) p++,x[p]=SA[i]-w;
        Rsort();
        memcpy(x,rk,sizeof(rk)); rk[SA[1]]=p=1;
        for (i=2; i<=n; i++) rk[SA[i]]=cmp(x,SA[i],SA[i-1],w)?p:++p;
    }
}
void getheight()
{
    long i,j,k=0;
    for (i=1; i<=n; i++)
    {
        for (k=k?k-1:k,j=SA[rk[i]-1]; s[i+k]==s[j+k]; k++);
        H[i]=k;
    }
    for (i=1; i<=n; i++) height[rk[i]]=H[i];
}
bool isB(long t){return len-SA[t]+1<=b.size();}
int main()
{
    cin>>a>>b;
    n=a.size(); m=b.size();
    for (i=1; i<=n; i++) len++,s[len]=a[i-1];
    len++; s[len]=126;
    for (i=1; i<=m; i++) len++,s[len]=b[i-1];
    n=len;
    
    getSA(); getheight();

    for (i=n-1; i; i--)
        if (isB(i))
        {
            ans+=nowa;
            cnt=0;
            while (tb&&stb[tb]>height[i]) nowb=nowb-(stb[tb]-height[i])*weighb[tb],cnt+=weighb[tb],tb--;
            tb++,stb[tb]=height[i],weighb[tb]=cnt+1,nowb+=height[i];
            cnt=0;
            while (ta&&sta[ta]>height[i]) nowa=nowa-(sta[ta]-height[i])*weigha[ta],cnt+=weigha[ta],ta--;
            if(cnt)ta++,sta[ta]=height[i],weigha[ta]=cnt;
        }
            else {
            ans+=nowb;
            cnt=0;
            while (ta&&sta[ta]>height[i]) nowa=nowa-(sta[ta]-height[i])*weigha[ta],cnt+=weigha[ta],ta--;
            ta++,sta[ta]=height[i],weigha[ta]=cnt+1,nowa+=height[i];
            cnt=0;
            while (tb&&stb[tb]>height[i]) nowb=nowb-(stb[tb]-height[i])*weighb[tb],cnt+=weighb[tb],tb--;
            if(cnt)tb++,stb[tb]=height[i],weighb[tb]=cnt;
        }
    cout<<ans;
}
```

---

## 作者：_ctz (赞：2)

[$My\ blog$](https://ctz45562.github.io/2019/04/21/%E6%B4%9B%E8%B0%B7-P3181-HAOI2016-%E6%89%BE%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6/)

[传送门](https://www.luogu.org/problemnew/show/P3181)

把两个串拼一块染个色造$SA$。

对于它们的子串$S_A,S_B$，设它们分别属于后缀$suffix_i,suffix_j$，则只要$LCP(suffix_i,suffix_j)\ge len(S_A)$两个子串就是相同的。

又有$LCP(suffix_i,suffix_j)=\min\{height[k]\}(i<k\le j)$

那么对于任意一个区间$[l,r]$它会产生$\min\{height[k]\}(k\in (l,r])$的贡献。

然后就可以用单调栈了。显然选取的两个区间端点颜色要不同，做个前缀和就好了。

代码：

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 400005
#define inf 0x3f3f3f3f

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
template<typename T>
inline T read(){
	T x=0;
	int y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
int sa[maxn],rk[maxn],hei[maxn],tp[maxn],tax[maxn],ll[maxn],rr[maxn],col[maxn],sum[maxn][2],n,m;
char a[maxn],s[maxn];
struct MonoStack{
	int sta[maxn],top;
	inline void push1(int x){
		while(top>1&&hei[sta[top]]>=hei[x])--top;
		sta[++top]=x;
	}
	inline void push2(int x){
		while(top>1&&hei[sta[top]]>hei[x])--top;
		sta[++top]=x;
	}
	inline void clear(){
		top=0;
	}
	inline int back(){
		return sta[top-1];
	}
}st;//单调栈
void Rsort(){
	for(register int i=0;i<=m;++i)tax[i]=0;
	for(register int i=1;i<=n;++i)++tax[rk[i]];
	for(register int i=1;i<=m;++i)tax[i]+=tax[i-1];
	for(register int i=n;i;--i)sa[tax[rk[tp[i]]]--]=tp[i];
}
void Ssort(){
	for(register int i=1;i<=n;++i)rk[i]=s[i],tp[i]=i;
	m=225,Rsort();
	for(register int k=1,p=0;p<n;m=p,k<<=1){
		p=0;
		for(register int i=1;i<=k;++i)tp[++p]=n-k+i;
		for(register int i=1;i<=n;++i)if(sa[i]>k)tp[++p]=sa[i]-k;
		Rsort();
		for(register int i=1;i<=n;++i)tp[i]=rk[i];
		rk[sa[1]]=p=1;
		for(register int i=2;i<=n;++i)
			rk[sa[i]]=tp[sa[i]]==tp[sa[i-1]]&&tp[sa[i]+k]==tp[sa[i-1]+k]?p:++p;
	}
}
void get_height(){
	int k=0,x;
	for(register int i=1;i<=n;++i){
		if(rk[i]==1)continue;
		if(k)--k;
		x=sa[rk[i]-1];
		while(i+k<=n&&x+k<=n&&s[i+k]==s[x+k])++k;
		hei[rk[i]]=k;
	}
}
void solve(){
	long long ans=0;
	st.push1(1);
	for(register int i=1;i<=n;++i)st.push1(i),ll[i]=st.back();
	st.clear(),st.push2(n+1);
	for(register int i=n;i;--i)st.push2(i),rr[i]=st.back()-1;
	for(register int i=1;i<=n;++i)
		sum[i][0]=sum[i-1][0]+(col[sa[i]]==1),sum[i][1]=sum[i-1][1]+(col[sa[i]]==2);//前缀和
	for(register int i=1;i<=n;++i){
		ans+=1ll*hei[i]*((sum[rr[i]][0]-sum[i-1][0])*(sum[i-1][1]-sum[ll[i]-1][1])+(sum[rr[i]][1]-sum[i-1][1])*(sum[i-1][0]-sum[ll[i]-1][0]));
	}

	printf("%lld\n",ans);
}
int main(){
	scanf("%s",s+1),m=strlen(s+1)+1;
	for(register int i=1;i<m;++i)col[i]=1;
	s[m]='$';
	scanf("%s",a+1),n=strlen(a+1);
	for(register int i=1;i<=n;++i)
		s[i+m]=a[i],col[i+m]=2;
	n+=m;
	Ssort(),get_height(),solve();
}

```



---

## 作者：何俞均 (赞：2)

广告：食用[$blog$](https://www.cnblogs.com/heyujun/p/10305863.html)体验更佳

其实和[这题](https://www.cnblogs.com/heyujun/p/10305797.html)差不多。

根据后缀数组常用套路，将将$s1,s2$用一个未曾出现的字符连起来

和上面那题一样的方法

算出来一个答案

然后减去分别左右两字符串选的贡献就好啦

代码

```cpp
#include <iostream> 
#include <cstdio> 
#include <cstdlib> 
#include <cstring> 
#include <cmath> 
#include <algorithm> 
using namespace std; 
const int MAX_N = 4e5 + 5; 
int N; char a[MAX_N], b[MAX_N], c[MAX_N];
int sa[MAX_N], rnk[MAX_N], lcp[MAX_N]; 
void GetSA() { 
#define cmp(i, j, k) (y[i] == y[j] && y[i + k] == y[j + k]) 
	static int x[MAX_N], y[MAX_N], bln[MAX_N]; 
	int M = 122;
	for (int i = 0; i <= M; i++) bln[i] = 0; 
	for (int i = 1; i <= N; i++) bln[x[i] = a[i]]++; 
	for (int i = 1; i <= M; i++) bln[i] += bln[i - 1]; 
	for (int i = N; i >= 1; i--) sa[bln[x[i]]--] = i; 
	for (int k = 1; k <= N; k <<= 1) {
		int p = 0; 
		for (int i = 0; i <= M; i++) y[i] = 0;
		for (int i = N - k + 1; i <= N; i++) y[++p] = i; 
		for (int i = 1; i <= N; i++) if (sa[i] > k) y[++p] = sa[i] - k; 
		for (int i = 0; i <= M; i++) bln[i] = 0; 
		for (int i = 1; i <= N; i++) bln[x[y[i]]]++; 
		for (int i = 1; i <= M; i++) bln[i] += bln[i - 1]; 
		for (int i = N; i >= 1; i--) sa[bln[x[y[i]]]--] = y[i]; 
		swap(x, y); x[sa[1]] = p = 1; 
		for (int i = 2; i <= N; i++) x[sa[i]] = cmp(sa[i], sa[i - 1], k) ? p : ++p; 
		if (p >= N) break;
		M = p; 
	} 
} 
void GetLcp() { 
	for (int i = 1; i <= N; i++) rnk[sa[i]] = i; 
	for (int i = 1, j = 0; i <= N; i++) { 
		if (j) --j; 
		while (a[i + j] == a[sa[rnk[i] - 1] + j]) ++j; 
		lcp[rnk[i]] = j; 
	} 
}
typedef long long ll; 
int lp[MAX_N], rp[MAX_N], stk[MAX_N], top; 
ll solve() { 
	GetSA(), GetLcp(); 
	top = 0, stk[0] = 1; 
	for (int i = 2; i <= N; i++) { 
		while (top > 0 && lcp[stk[top]] >= lcp[i]) --top; 
		lp[i] = i - stk[top], stk[++top] = i; 
	} 
	top = 0, stk[0] = N + 1;
	for (int i = N; i >= 2; i--) { 
		while (top > 0 && lcp[stk[top]] > lcp[i]) --top; 
		rp[i] = stk[top] - i, stk[++top] = i; 
	}
	ll res = 0; 
	for (int i = 2; i <= N; i++) res += 1ll * lp[i] * rp[i] * lcp[i]; 
	return res; 
} 
int main () { 
	ll ans = 0; int n, m; 
	scanf("%s", b + 1); scanf("%s", c + 1); 
	n = strlen(b + 1); m = strlen(c + 1); 
	N = n; for (int i = 1; i <= N; i++) a[i] = b[i]; 
	ans -= solve();
	N = m; for (int i = 1; i <= N; i++) a[i] = c[i]; 
	ans -= solve();
	N = n + m + 1; 
	for (int i = 1; i <= n; i++) a[i] = b[i];
	a[n + 1] = '#'; 
	for (int i = 1; i <= m; i++) a[i + n + 1] = c[i];
	ans += solve();
	printf("%lld\n", ans); 
	return 0; 
} 
```

---

## 作者：Infiltrator (赞：2)

[$\Large\color{#FFBBFF}\textit{Tian-Xing's blog}$](https://Tian-Xing.github.io)

------------

# Description

[传送门](https://www.luogu.com.cn/problem/P3181)

------------

# Solution

这题就是让求两个串的相同子串的个数。

众所周知，字符串所有的子串就是字符串所有的后缀的所有前缀。

利用这个性质我们可以将问题转化，变成求两个字符串的所有后缀的$lcp$的长度的和。

求后缀的$lcp$我们可以使用$SA$。

将两个字符串连接起来，中间位置放一个$1$隔开，两个字符串分别染上不同的颜色。

现在答案就变成了求每一堆中颜色不同的后缀的$lcp$长度，考虑$height$数组的性质，即$lcp(i, j) = min_{k = i + 1}^j height_k$，我们发现在每个块内$lcp$的长度具有单调性。

考虑每一堆中不同颜色之间的$lcp$长度就相当于先对于一种颜色算在它之前出现的另外一种颜色和它的$lcp$，再按照另外一种颜色算一遍。

我们用单调栈维护这个$lcp$长度，用$sum$记录单调栈内元素对答案的总贡献，$stack$中保存两个信息——$height$值的大小和有多少个贡献和它相同的元素。

每次我们将当前的后缀$i$加入单调栈，如果$sa_{i - 1}$的颜色不是我们要算贡献的颜色，那么它就可以对当前颜色造成贡献，$sum += height_i$。

这时我们将现在的$height_i$入栈，考虑如果$height_i <= height_{top}$，那么栈顶对答案的贡献就会变为$height_i$，所以可以将$height_i$和$height_{top}$合并，对答案的贡献是$height_i$，贡献个数是$num_i + num_{top}$。

合并完之后如果$sa_i$的颜色是我们要算贡献的颜色就加上所有栈内的贡献。

------------

# Code

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

#define int long long
typedef long long ll;

const int N = 400050;

int k, m, n, s[N], x[N], y[N], cnt[N], sa[N], rnk[N], height[N], col[N], l, stack[N][2], top;
char a[N], b[N];
ll ans, sum;

void Rsort()
{
    for (int i = 0; i <= m; i++) cnt[i] = 0;
    for (int i = 1; i <= n; i++) cnt[x[i]]++;
    for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];
    for (int i = n; i >= 1; i--) sa[cnt[x[y[i]]]--] = y[i];
    return;
}

void SA()
{
    m = 128;
    for (int i = 1; i <= n; i++) x[i] = s[i], y[i] = i;
    Rsort();
    m = 0;
    for (int k = 1; m < n; k <<= 1)
    {
        m = 0;
        for (int i = n - k + 1; i <= n; i++) y[++m] = i;
        for (int i = 1; i <= n; i++) if (sa[i] > k) y[++m] = sa[i] - k;
        Rsort();
        for (int i = 1; i <= n; i++) y[i] = x[i];
        m = x[sa[1]] = 1;
        for (int i = 2; i <= n; i++)
        {
            if(y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k])
                x[sa[i]] = m;
            else x[sa[i]] = ++m;
        }  
    }
    for (int i = 1; i <= n; i++) rnk[sa[i]] = i;
    for (int i = 1; i <= n; i++)
    {
        height[rnk[i]] = height[rnk[i - 1]] - 1;
        if (height[rnk[i]] < 0) height[rnk[i]] = 0;
        while (s[i + height[rnk[i]]] == s[sa[rnk[i] - 1] + height[rnk[i]]]) height[rnk[i]]++;
    }
}

signed main()
{
    n = 0; ans = 0;
    scanf("%s", a + 1);
    l = strlen(a + 1);
    for (int i = 1; i <= l; i++) s[++n] = a[i] + 1, col[i] = 1;
    s[++n] = 1;
    scanf("%s", b + 1);
    l = strlen(b + 1);    
    for (int i = 1; i <= l; i++) s[++n] = b[i] + 1, col[n] = 2;
    SA();
    for (int color = 1; color <= 2; color++)
    {
        top = sum = 0;
        for (int i = 1; i <= n; i++)
            if (height[i] == 0) sum = top = 0;
            else
            {
                int cnt = 0;
                if (col[sa[i - 1]] != color) 
                {
                    cnt++;
                    sum += height[i];
                }
                while(top && height[i] <= stack[top][1])
                {
                    cnt += stack[top][2];
                    sum -= 1LL * stack[top][2] * (stack[top][1] - height[i]);
                    top--;
                }
                stack[++top][1] = height[i]; stack[top][2] = cnt;
                if (col[sa[i]] == color) ans += sum;
            }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：FlyInTheSky (赞：1)

 [$$ \Large \texttt{My Blog} $$](http://blog.flyinthesky.win/bzoj3238/)

------------

一开始乱二分挂了……

其实这题就是[Bzoj 3238 差异](http://blog.flyinthesky.win/bzoj3238/)，我们可以想到连接两个字符串，中间用一个没出现过的字符连接，然后单调栈维护所有区间的最小值。但是这里是两个字符串，可能会有答案算到是同串的，那么我们考虑**容斥**。

即求三次后缀数组，第一次求连接串的答案，然后求两个原串的答案，最后用连接串答案减掉后面的两个原串答案即为最终答案，正确性显然。

代码很丑，没有将三次后缀数组写成一个函数调用，尽量参考上述思维。
```c++
#include<cstdio> 
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<queue>
#include<set>
#define ms(i, j) memset(i, j, sizeof i)
#define LL long long
#define db double
#define fir first
#define sec second
#define mp make_pair
using namespace std;

namespace flyinthesky {
    
    const int MAXN = 400000 + 5;
    
    char ch[2][MAXN];
    int a[MAXN], n, m;
    int SA[MAXN], rk[MAXN], tp[MAXN], tax[MAXN], height[MAXN];
    
    void build(int n) {//11?¨¬o¨®¡Áo¨ºy¡Á¨¦ 
        for (int i = 1; i <= m; ++i) tax[i] = 0;
        for (int i = 1; i <= n; ++i) tax[rk[i] = a[i]]++;
        for (int i = 1; i <= m; ++i) tax[i] += tax[i - 1];
        for (int i = n; i >= 1; --i) SA[tax[rk[i]]--] = i;//?¨´¨ºy??D¨°??¦Ì¨²¨°???
    
        for (int k = 1; k <= n; k <<= 1) {
            int p = 0;
            for (int i = n - k + 1; i <= n; i++) tp[++p] = i;//(n-k)~(n-1)?T¦Ì¨²?t1??¨¹¡Á?¡ê??¨´¨°???D¨°¨®|?????¨²?¡ã??
            for (int i = 1; i <= n; i++) if (SA[i] > k) tp[++p] = SA[i] - k;
            //??¨®DSA[i]>=k¦Ì?SA[i]2?¨º?¦Ì¨²?t1??¨¹¡Á?¦Ì????? 
            //¡ä¨®¨ª??D?¨¦¨°??¡ä3?¦Ì¨²¨°?1??¨¹¡Á?o¨ª¦Ì¨²?t1??¨¹¡Á?¦Ì??????¨¤2?k¡ê?1¨ºSA[i] - k 
            for (int i = 1; i <= m; ++i) tax[i] = 0;
            for (int i = 1; i <= n; ++i) tax[rk[tp[i]]]++;//x[tp[i]]?¨¤¦Ì¨¨¨®¨²????¦Ì¨²i¦Ì?¦Ì¨²?t1??¨¹¡Á?¦Ì?¦Ì¨²¨°?1??¨¹¡Á?¦Ì????? 
            for (int i = 1; i <= m; ++i) tax[i] += tax[i - 1];
            for (int i = n; i >= 1; --i) SA[tax[rk[tp[i]]]--] = tp[i];//¡À¡ê?¡è¨¢?¦Ì¨²¨°?1??¨¹¡Á?¦Ì??3D¨°?¨´??¦Ì¨²?t1??¨¹¡Á? 
            //?¨´¨ºy??D¨°¦Ì¨²¨°?1??¨¹¡Á?(rank[i]¦Ì?¨ºy?¦Ì)o¨ª¦Ì¨²?t1??¨¹¡Á?(tp[i]¦Ì???¡À¨º) 
            swap(rk, tp);//¡ä?¨º¡Àtp??¨®?¡ê??Y¡ä?¨¦?¨°???rank¦Ì??¦Ì
            p = 1, rk[SA[1]] = 1;
            for (int i = 2; i <= n; ++i) 
                rk[SA[i]] = (tp[SA[i]] == tp[SA[i - 1]] && tp[SA[i] + k] == tp[SA[i - 1] + k]) ? p : ++p;
            //??????¦Ì¨²i¦Ì?¨ºy¦Ì?rank¡ê?¡ã¡äsa?3D¨°?¨¹1?¡À¡ê?¡èrank¦Ì??y¨¨¡¤D?¡ê?¦Ì?¨º?¨°acmp?D??¨®?¨¦?¨°???¡Á?¡¤?¡ä??¨¤¦Ì¨¨¦Ì??¨¦?? 
            if (p >= n) break;//???|¡ê?¨°??-??¨®D???¡ä?a?? 
            m = p; 
        }
        int k = 0;//k¨º?¡À¨¨i-1?¡ã¨°???¦Ì?o¨®¡Áo
        for (int i = 1; i <= n; ++i) {//H[0], H[1], H[2] ...¦Ì??3D¨°???? 
            if (k) k--;//¡ä¨®k-1?a¨º?¡À¨¨?? ,??¨®??¨¢??H[i]>=H[i-1]-1, ¡Á?3¡è1?12?¡ã¡Áo¦Ì?3¡è?¨¨?¨¢¨¦¨´¨º?k-1(k = H[i-1])
            int j = SA[rk[i] - 1]; //?¡ã¨°???¦Ì?o¨®¡Áo???? 
            while (a[i + k] == a[j + k]) k++; //¨ª¨´o¨®¡À¨¨?? 
            height[rk[i]] = k;  //?¨¹D?¡äe¡ã? 
        }
    }
    
    LL L[MAXN], R[MAXN], st[MAXN], top = 0, ans = 0;
    
    void clean() {
    	n = 0, m = 200, ms(height, 0), ms(SA, 0), ms(rk, 0), ms(tax, 0), ms(tp, 0), ms(L, 0), ms(R, 0), ms(st, 0);
    }
    int solve() {

        // 1
    	clean();
    	scanf("%s", ch[0] + 1);
    	int tmp = strlen(ch[0] + 1);
    	for (int i = 1; i <= tmp; ++i) a[++n] = ch[0][i] - 'a' + 1;
    	
    	a[++n] = '$';
    	scanf("%s", ch[1] + 1);
    	tmp = strlen(ch[1] + 1);
    	for (int i = 1; i <= tmp; ++i) a[++n] = ch[1][i] - 'a' + 1;
    	
    	build(n);
        
        st[top = 1] = 1;
        for (int i = 2; i <= n; ++i) {
        	while (top && height[st[top]] > height[i]) R[st[top--]] = i;
        	L[i] = st[top];
        	st[++top] = i;
        }
        while (top) R[st[top--]] = n + 1;
        for (int i = 1; i <= n; ++i) 
            ans += 1ll * (R[i] - i) * (i - L[i]) * height[i];
        
        // 2
        clean();
        tmp = strlen(ch[0] + 1);
    	for (int i = 1; i <= tmp; ++i) a[++n] = ch[0][i] - 'a' + 1;
    	build(n);
    	
    	st[top = 1] = 1;
        for (int i = 2; i <= n; ++i) {
        	while (top && height[st[top]] > height[i]) R[st[top--]] = i;
        	L[i] = st[top];
        	st[++top] = i;
        }
        while (top) R[st[top--]] = n + 1;
        for (int i = 1; i <= n; ++i) 
            ans -= 1ll * (R[i] - i) * (i - L[i]) * height[i];
            
        // 3
        clean();
        tmp = strlen(ch[1] + 1);
    	for (int i = 1; i <= tmp; ++i) a[++n] = ch[1][i] - 'a' + 1;
    	build(n);
    	
    	st[top = 1] = 1;
        for (int i = 2; i <= n; ++i) {
        	while (top && height[st[top]] > height[i]) R[st[top--]] = i;
        	L[i] = st[top];
        	st[++top] = i;
        }
        while (top) R[st[top--]] = n + 1;
        for (int i = 1; i <= n; ++i) 
            ans -= 1ll * (R[i] - i) * (i - L[i]) * height[i];
        
        printf("%lld\n", ans);
        
        return 0;
    }
}
int main() {
    flyinthesky::solve();
    return 0;
}
```

---

## 作者：消失的海岸线 (赞：1)

来一个可读性高的**广义后缀自动机**的版本吧，算法的详细内容可以看论文...

下面可能用到的一些术语基本出自 $clj$ 课件...

有一个简单的构建方法，即每次插入一个串后将 $last$ 赋为根节点即可。

对 $SAM$ 里的每一个节点维护它代表的 $right$ 集合大小，分别维护第一个串和第二个串的大小，令 $len_i=max_i-mn_i+1$

则一个节点 $i$ 对答案产生的贡献为 $len_i \cdot sz1_i \cdot sz2_i$

需要注意的是广义后缀自动机求每个状态 $right$ 大小的时候，除了第一个串以外不能用正常的方法。

因为可能会出现没有意义的 $np$，解决方法有像代码那么写或者建 $np$ 的时候特判一下新的 $np$ 是否有意义。



```cpp
    #include <cmath>
    #include <queue>
    #include <cstdio>
    #include <iomanip>
    #include <cstdlib>
    #include <cstring>
    #include <iostream>
    #include <algorithm>
    #define N 200010
    #define ll long long
    using namespace std;
    inline int read()
    {
        int x=0,f=1;char ch=getchar();
        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
        return x*f;
    }
    ll ans;
```
namespace SAM
    
    
```cpp
    {
        #define MAXN 800010
        int ch[MAXN][26],fail[MAXN];
        int mx[MAXN],sz[MAXN][2];
        int last=1,tot=1;
        void add(int x,int t)
        {
            int np=++tot,p=last,q,nq;
            if(t==0)sz[np][t]=1;
            mx[np]=mx[p]+1,last=np;
            while(p&&!ch[p][x])ch[p][x]=np,p=fail[p];
            if(p==0){fail[np]=1;return ;}
            q=ch[p][x];
            if(mx[q]==mx[p]+1){fail[np]=q;return ;}
            nq=++tot,mx[nq]=mx[p]+1;
            memcpy(ch[nq],ch[q],sizeof(ch[q]));
            fail[nq]=fail[q],fail[q]=fail[np]=nq;
            while(p&&ch[p][x]==q)ch[p][x]=nq,p=fail[p];
        }
        int ord[MAXN],bin[MAXN];
        void count()
        {
            for(int i=1;i<=tot;i++)bin[mx[i]]++;
            for(int i=1;i<=tot;i++)bin[i]+=bin[i-1];
            for(int i=tot;i;i--)ord[bin[mx[i]]--]=i;
            for(int i=tot;i;i--)
            {
                int x=ord[i];
                sz[fail[x]][0]+=sz[x][0],sz[fail[x]][1]+=sz[x][1];
            }
            for(int i=1;i<=tot;i++)
            {
                ans+=(ll)(mx[i]-mx[fail[i]])*sz[i][0]*sz[i][1];
            }
        }
    }
    int n;
    char s[N];
    int main()
    {
        scanf("%s",s+1),n=strlen(s+1);
        for(int i=1;i<=n;i++)SAM::add(s[i]-'a',0);
        SAM::last=1;
        scanf("%s",s+1),n=strlen(s+1);
        int p=1;
        for(int i=1;i<=n;i++)
        {
            SAM::add(s[i]-'a',1);
            p=SAM::ch[p][s[i]-'a'];
            SAM::sz[p][1]=1;
        }
        SAM::count();
        printf("%lld\n",ans);
}
```

---

## 作者：muller (赞：1)

用一个栈维护单调性

然后统计答案

中间容斥一下

我觉得这个应该比较好像

然后我们可以不断寻找lcp的单调性

于是可以算出不同情况的数量

于是我们分一种大于的把它减掉

否则加上

注意用long long

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define N 500000
#define ll long long
using namespace std;
int n,c[N],x[N],y[N],rk[N],sa[N],height[N];
string s,s1,s2;
ll ansn,dp[N];
stack<int> st;
void pai(){
//	cout<<s<<endl;
	memset(c,0,sizeof(c));memset(height,0,sizeof(height));
	for (int i=1;i<=n;i++)c[s[i]]++;
	for (int i=1;i<=256;i++)c[i]+=c[i-1];
//	for (int i=1;i<=256;i++)cout<<c[i]<<' ';cout<<endl;
	for (int i=n;i;i--)sa[c[s[i]]--]=i;
//	cout<<"ok"<<endl;
//	for (int i=1;i<=n;i++)cout<<sa[i]<<' ';cout<<endl;
//	cout<<"ok"<<endl;
	rk[sa[1]]=1;
	for (int i=2;i<=n;i++)rk[sa[i]]=rk[sa[i-1]]+(s[sa[i]]!=s[sa[i-1]]);
/*	for (int i=2;i<=n;i++){
		cout<<rk[sa[i]]<<' '<<rk[sa[i-1]]<<' '<<(s[sa[i]]!=s[sa[i-1]])<<endl;
		cout<<rk[sa[i-1]]+(s[sa[i]]!=s[sa[i-1]])<<endl;
		cout<<"sa:"<<sa[i]<<endl;
	}
	for (int i=1;i<=n;i++)cout<<rk[i]<<' ';cout<<endl;
	cout<<"ok"<<endl;
*/
	for (int k=1;rk[sa[n]]!=n;k<<=1){
		for (int i=1;i<=n;i++)x[i]=rk[i],y[i]=(i+k<=n) ? rk[i+k] : 0;
		memset(c,0,sizeof(c));
		for (int i=1;i<=n;i++)c[y[i]]++;
		for (int i=1;i<=n;i++)c[i]+=c[i-1];
		for (int i=n;i;i--)rk[c[y[i]]--]=i;
		memset(c,0,sizeof(c));
		for (int i=1;i<=n;i++)c[x[i]]++;
		for (int i=1;i<=n;i++)c[i]+=c[i-1];
		for (int i=n;i;i--)sa[c[x[rk[i]]]--]=rk[i];
		rk[sa[1]]=1;
		for (int i=2;i<=n;i++)rk[sa[i]]=rk[sa[i-1]]+(x[sa[i]]!=x[sa[i-1]]||y[sa[i]]!=y[sa[i-1]]);
	}
//	cout<<"ok"<<endl;
	int len=0;
	for (int i=1;i<=n;i++){
		if (len)len--;
		int j=sa[rk[i]-1];
		while (s[i+len]==s[j+len])len++;
		height[rk[i]]=len;
	}
//	cout<<"ok"<<endl;
}
void he(int f,string S){
	n=S.size();s='~'+S;pai();
	ll ans=0;
	while (!st.empty())st.pop();
	for (int i=2;i<=n;i++){
		while (!st.empty()&&height[st.top()]>height[i])st.pop();
		if (st.empty())dp[i]=height[i]*(i-1);else dp[i]=(dp[st.top()]+height[i]*(i-st.top()));
		st.push(i);ans+=dp[i]*f;
	}
	ansn+=ans;
//	cout<<ansn<<' '<<ans<<endl;
}
int main(){
	std::ios::sync_with_stdio(false);
	cin>>s1>>s2;
	he(1,s1+"&"+s2);he(-1,s1);he(-1,s2);
	cout<<ansn<<endl;
	return 0;
}

```


---

## 作者：ljc1301 (赞：1)

这题我用的是**普通**的后缀自动机

~~题解里怎么没人说这种做法呢~~

这道题我的思路是，用一个特殊符把两个字符串分开来，建一个sam，看看每个子串分别出现了多少次，每个子串对答案的贡献就是次数*(次数-1)/2，代表选两个有几种选法。

不过有个问题，如果选的两个都是s1里的，或者都是s2里的，就不能对答案有贡献。可以把这些多余的贡献减掉，也就是说，把s1和s2单独再建一个sam，跑一次这个做法，用这个减掉前面算出来的答案即可。

怎么算每个子串出现了多少次呢？后缀自动机的每一个非根节点u，它表示了len[u]-len[parent[u]]个子串，每一个都在字符串里出现的次数，都是在parent树上u的子树中非特殊节点的个数。直接计算即可。（这个性质应该没错把……）

然后就差不多了。代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxlen=400005;
const int maxnode=maxlen<<1;
int fa[maxnode],len[maxnode],tot,rt,sz[maxnode];
int ne[maxnode],he[maxnode];
int ch[maxnode][27],d[maxnode];
long long ans;
char a[maxlen],b[maxlen];
queue<int> que;
inline void make(char *s)
{
    register int i,cur,p,q,r;
    rt=0,tot=1; cur=rt;
    memset(ch[rt],-1,sizeof(ch[rt])),fa[rt]=-1,sz[rt]=0,len[rt]=0;
    for(i=0;s[i];i++)
    {
        p=cur; cur=tot++,memset(ch[cur],-1,sizeof(ch[cur]));
        len[cur]=i+1; sz[cur]=1;
        for(;p>=0 && ch[p][s[i]-'a']==-1;p=fa[p]) ch[p][s[i]-'a']=cur;
        if(p<0) fa[cur]=rt;
        else
        {
            q=ch[p][s[i]-'a'];
            if(len[p]+1==len[q]) fa[cur]=q;
            else
            {
                r=tot++,memcpy(ch[r],ch[q],sizeof(ch[q])); len[r]=len[p]+1; sz[r]=0;
                fa[r]=fa[q],fa[q]=r,fa[cur]=r;
                for(;p>=0 && ch[p][s[i]-'a']==q;p=fa[p]) ch[p][s[i]-'a']=r;
            }
        }
    }
}
void dfs(int rt,int flag)
{
    int i;
    for(i=he[rt];i;i=ne[i])
        dfs(i,flag),sz[rt]+=sz[i]; // 计算parent树上u的子树中非特殊节点的个数
    if(rt) ans+=(sz[rt]*(sz[rt]-1ll)*flag*(len[rt]-len[fa[rt]]))>>1; // 计算
}
int main()
{
    int i;
    ans=0;
    scanf("%s%s",a,b);
    make(a);
    for(i=0;i<tot;i++) he[i]=0;
    for(i=1;i<tot;i++)
        ne[i]=he[fa[i]],he[fa[i]]=i; // 构造parent树
    dfs(rt,-1); // 计算a当中相同子串的对数
    make(b);
    for(i=0;i<tot;i++) he[i]=0;
    for(i=1;i<tot;i++)
        ne[i]=he[fa[i]],he[fa[i]]=i;
    dfs(rt,-1); // 计算b当中相同子串的对数
    strcat(a,"{"),strcat(a,b); // '{'=='z'+1，偷个懒
    make(a);
    for(i=0;i<tot;i++) he[i]=0;
    for(i=1;i<tot;i++)
        ne[i]=he[fa[i]],he[fa[i]]=i;
    dfs(rt,1); // 计算a和b连起来后相同子串的对数
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Greenzhe (赞：0)

题解区都是 GSAM / SA 做法，唯一几篇 SAM 的题解也讲得不是很清晰。来一发自认为清晰的 SAM 解法。

---

首先写出答案的表达式：

$$\text{ans} = \sum_{l_1,r_1,l_2,r_2} [s_{1[l_1,r_1]}=s_{2[l_2,r_2]}]$$

设 $s_{2[l,r]}$ 在 $s_1$ 中的出现次数为 $\text{cnt}(l,r)$，则上式可以改写成：

$$\text{ans} = \sum_{s_{2[l,r]} \subseteq s_1} \text{cnt}(l,r)$$

考虑直接对串 $s_1$ 建出 SAM，用 $s_2$ 在 SAM 上面跑 LCS（最长公共子串）。没见过 SAM+LCS 的请转 [SP1811](https://www.luogu.com.cn/problem/SP1811)。

假设目前跑到了 $s_2$ 的第 $m$ 个位置，SAM 上指向的节点为 $p$，匹配长度为 $\text{len}$。那么 $s_{2[1,m]}$ 与 $s_1$ 的最长公共子串的长度就为 $\text{len}$。最长公共子串的每个后缀都是公共子串，所以 $\forall i \in [1,\text{len}]$ 有 $s_{2[m-i+1,m]} \subseteq s_1$，每个 $i$ 对应以 $m$ 结尾的 LCS 的一个后缀。同时 LCS 的每个后缀也是 $s_1$ 的子串，也对应 parent 树上从根到 $p$ 的路径上的一个点。

根据 SAM 的性质，我们把所有 $i$ 按照所对应的 SAM 节点 $p$ 分成若干个连续段，每个连续段中的 $i$ 满足 $\text{cnt}(m-i+1,m)=|\text{endpos}(p)|$。那么第 $m$ 个位置对答案的贡献即为：路径上每个点的 $($ endpos 集合大小 $\times$ 所对应的 $i$ 连续段的长度 $)$。

注意到所有 $p$ 的祖先 $p^\prime$ 都满足 $\text{maxlen}(p^\prime) \le \text{len}$，所以 $p$ 的祖先对应 $i$ 的连续段就是 $[\text{minlen}(p^\prime),\text{maxlen}(p^\prime)]$。而 $p$ 的连续段为 $[\text{minlen}(p),\text{len}]$。我们又知道在 SAM 上 $\text{minlen}(p)=\text{maxlen}(\text{fa}(p))+1$，所以位置 $m$ 对答案的贡献最终表示为

$$\sum_{p^\prime} (\text{maxlen}(p^\prime)-\text{maxlen}(\text{fa}(p^\prime))) \cdot |\text{endpos}(p^\prime)| + (\text{len}-\text{maxlen}(\text{fa}(p))) \cdot |\text{endpos}(p)|$$

endpos 集合大小可以树形 DP 求，$\sum_{p^\prime}$ 一项可以预处理，然后就做完了。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;
typedef long long ll;

int n, m, tot, last;
char s1[N], s2[N];
ll pre[N << 1], siz[N << 1], res = 0;
vector<int> G[N << 1];

struct Node {
    int len, link, ch[26];
    int &operator[](int idx) {
        return ch[idx];
    }
} sam[N << 1];

void build() {
    tot = last = 0;
    sam[0].link = -1, sam[0].len = 0;
}

void extend(int c) {
    int p = last, cur = ++tot;
    sam[cur].len = sam[p].len + 1;
    last = cur;

    while (p != -1 && !sam[p][c]) {
        sam[p][c] = cur;
        p = sam[p].link;
    }

    if (p == -1)
        return sam[cur].link = 0, void();

    int q = sam[p][c];

    if (sam[q].len == sam[p].len + 1)
        return sam[cur].link = q, void();

    sam[++tot].link = sam[q].link;
    sam[tot].len = sam[p].len + 1;

    for (int i = 0; i < 26; ++i)
        sam[tot][i] = sam[q][i];

    sam[q].link = sam[cur].link = tot;

    while (p != -1 && sam[p][c] == q) {
        sam[p][c] = tot;
        p = sam[p].link;
    }
}

void dfs1(int u) {
    for (int v : G[u]) {
        dfs1(v);
        siz[u] += siz[v];
    }
}

void dfs2(int u) {
    int fa = sam[u].link;

    if (u)
        pre[u] += siz[u] * (sam[u].len - sam[fa].len);

    for (int v : G[u]) {
        pre[v] += pre[u];
        dfs2(v);
    }
}

int main() {
    scanf("%s%s", s1 + 1, s2 + 1);
    n = strlen(s1 + 1), m = strlen(s2 + 1);
    build();

    for (int i = 1; i <= n; ++i) {
        extend(s1[i] - 'a');
        siz[last]++;
    }

    for (int i = 1; i <= tot; ++i)
        G[sam[i].link].push_back(i);

    dfs1(0);
    dfs2(0);
    int p = 0, len = 0;

    for (int i = 1; i <= m; ++i) {
        int c = s2[i] - 'a';

        while (p && !sam[p][c]) {
            p = sam[p].link;
            len = sam[p].len;
        }

        if (sam[p][c])
            p = sam[p][c], len++;

        if (!p)
            continue;

        int fa = sam[p].link;
        res += pre[fa] + (len - sam[fa].len) * siz[p];
    }

    printf("%lld\n", res);
    return 0;
}
```

---


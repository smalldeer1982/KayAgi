# [SCOI2013] 密码

## 题目描述

Fish是一条生活在海里的鱼。有一天他很无聊，就到处去寻宝。他找到了位于海底深处的宫殿，但是一扇带有密码锁的大门却阻止了他的前进。

通过翻阅古籍，Fish 得知了这个密码的相关信息：

1. 该密码的长度为N。

2. 密码仅含小写字母。

3. 以每一个字符为中心的最长回文串长度。

4. 以每两个相邻字符的间隙为中心的最长回文串长度。

很快Fish 发现可能有无数种满足条件的密码。经过分析，他觉得这些密码中字典序最小的一个最有可能是答案，你能帮他找到这个密码么？

注意：对于两个串A和B，如果它们的前i个字符都相同，而A的第i+1个字符比B的第i+1个字符小，那么认为是则称密码A 的字典序小于密码B 的字典序，例如字符串abc 字典序小于字符串acb。如果密码A的字典序比其他所有满足条件的密码的字典序都小，则密码A是这些密码中字典序最小的一个。


## 说明/提示

对于20% 的数据，1 <= n <= 100。

另有30% 的数据，1 <= n <= 1000。

最后50% 的数据，1 <= n <= 10^5。


## 样例 #1

### 输入

```
3
1 1 1
0 0```

### 输出

```
abc
```

## 样例 #2

### 输入

```
3
1 3 1
0 0```

### 输出

```
aba```

## 样例 #3

### 输入

```
3
1 3 1
2 2```

### 输出

```
aaa```

# 题解

## 作者：辰星凌 (赞：5)

# **【题解】密码 [SCOI2013] [P3279]**

[$\mathcal{My}\ \mathcal{Blog}$](https://www.cnblogs.com/Xing-Ling/p/12687947.html)

传送门：[密码 $\text{[SCOI2013] [P3279]}$](https://www.luogu.com.cn/problem/P3279)

## **【题目描述】**

已知某长为 $n$ $(n\leqslant 10^5)$ 的字符串以每个位置/空隙为中心的最长回文串长度，现需构造一个字典序最小的合法字符串。

## **【分析】**

神奇的 $\text{manacher}$ 反...反演？？O...Orz

[【学习笔记】字符串—马拉车（$\text{Manacher}$）](https://www.luogu.com.cn/blog/ChenXingLing/post-xue-xi-bi-ji-zi-fu-chuan-suan-fa-hui-zong-dai-geng-xin-post)

万事不决先想暴力，直接上冰茶姬维护字符相同的位置集合，再开一个链表记录一定不相等的点对，以每个点 $i$ 为中心向两边无脑枚举至半径 $r_i$，依次合并 $i-j+1$ 和 $i+j-1$ $(1\leqslant j \leqslant r_i)$，然后在 $i-r_i,i+r_i$ 之间连一条双向边，最后从左至右依次枚举，每次找最小合法字符即可。

貌似是 $O(n^2)$ 的，考虑用类似  $\text{manacher}$ 的方法进行优化：对于一个已知的回文子串 $[L,R]$，由于所有的 $i\in[L,mid]$ 都已经作为中心点扫描 $merge$ 过了，所以对于 $i'\in[mid+1,R]$ 中 $j \leqslant R-i'+1$ 的部分可以不用再次扫描。

其原理和普通 $\text{manacher}$ 相同，时间复杂度亦为 $O(n)$（冰茶姬被忽略了QAQ）

## **【Code】**

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#define LL long long
#define Re register int
using namespace std;
const int N=1e5+3;
int n,m,x,o,A[N<<1],f[N<<1],co[N],fa[N],head[N],judge[30];
struct QAQ{int to,next;}a[N<<2];//注意链表要开4N
inline void add(Re x,Re y){a[++o].to=y,a[o].next=head[x],head[x]=o;}
inline void in(Re &x){
    int f=0;x=0;char c=getchar();
    while(c<'0'||c>'9')f|=c=='-',c=getchar();
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    x=f?-x:x;
}
inline int find(Re x){return x==fa[x]?x:fa[x]=find(fa[x]);}
inline void merge(Re x,Re y){if((x=find(x))!=(y=find(y)))fa[x]=y;}
int main(){
//  freopen("123.txt","r",stdin);
    in(n),m=n<<1|1;
    for(Re i=1;i<=n;++i)fa[i]=i;
    for(Re i=1;i<=n;++i)in(x),A[i<<1]=x;
    for(Re i=1;i<n;++i)in(x),A[i<<1|1]=x;
    for(Re i=2,mid=0,r=0;i<m;++i){
        f[i]=(i<=r?min(f[(mid<<1)-i],r-i+1):1);
        while(f[i]-1<A[i]){//f[i]-1才是以i为中心的实际最长回文串长度
            ++f[i];
            if(!(i-f[i]+1&1))merge(i-f[i]+1>>1,i+f[i]-1>>1);//对于奇点(辅助点)就不要merge了
        }
        add(i-f[i]>>1,i+f[i]>>1),add(i+f[i]>>1,i-f[i]>>1);//这里必定是偶点，可以直接除2进行连边
        if(i+f[i]-1>r)mid=i,r=i+f[i]-1;
    }
//    for(Re i=2;i<=m;i+=2)printf("%d ",f[i]-1);puts("");
    for(Re i=1;i<=n;++i)if(!co[find(i)]){
        memset(judge,0,sizeof(judge));
        for(Re j=head[i];j;j=a[j].next)judge[co[find(a[j].to)]]=1;//i对立点的颜色都不能选
        for(Re j=1;j<=26&&!co[find(i)];++j)if(!judge[j])co[find(i)]=j;
    }
    for(Re i=1;i<=n;++i)printf("%c",'a'+co[find(i)]-1);
}
```


---

## 作者：Great_Influence (赞：2)

迷题。


看到题目可以先发现一个求解方法，就是对于每个位置的数，记录它一定不能选的数，在扫到它的时候枚举出最小的字符。然后对于每个回文串，直接复制前半部分求的解。可以证明这样得到的解一定字典序最小（如果求得到解的话）。然后发现它是$O(n^2)$的，于是观察求解过程发现很多点都被重复赋值多次，于是开一个变量r记录已经被赋值的位置最右到哪就可以了。时间复杂度$O(n)$。


代码：


```cpp
    // luogu-judger-enable-o2
    #include<bits/stdc++.h>
    #include<cctype>
    #define getchar() getchar_unlocked()
    #define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)
    #define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)
    #define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
    #define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
    #define Chkmax(a,b) a=a>b?a:b
    #define Chkmin(a,b) a=a<b?a:b
    using namespace std;
    template<typename T>inline void read(T &x){
        T s=0,f=1;char k=getchar();
        while(!isdigit(k)&&k^'-')k=getchar();
        if(!isdigit(k)){f=-1;k=getchar();}
        while(isdigit(k)){s=s*10+(k^48);k=getchar();}
        x=s*f;
    }
    inline void get(char &x){for(x=0;!isupper(x);x=getchar());}
    void file(void){
        #ifndef ONLINE_JUDGE
        freopen("water.in","r",stdin);
        freopen("water.out","w",stdout);
        #endif
    }
    const int MAXN=1e5+7;
    static int a[MAXN],b[MAXN],n;
    bool isn[MAXN][27];
    void init()
    {
        read(n);
        Rep(i,1,n)read(a[i]);
        Rep(i,2,n)read(b[i]);
    }
    static char s[MAXN];
    void solve()
    {
        s[1]='a';
        static int r,tim=0;
        Rep(i,2,n)
        {
            if(r>=n)break;
            tim+=max(0,b[i]/2-max(1,r-i+2))+max(0,a[i]/2-max(1,r-i+1));
            if(i-b[i]/2-1>0&&i+b[i]/2<=n)isn[i+b[i]/2][s[i-b[i]/2-1]-'a']=true;
            if(!s[i])Rep(j,0,25)if(!isn[i][j]){s[i]=j+'a';break;}
            if(b[i])Rep(j,max(1,r-i+2),b[i]/2)s[i+j-1]=s[i-j];
            Chkmax(r,i+b[i]/2-1);
            if(a[i]>1)Rep(j,max(1,r-i+1),a[i]/2)s[i+j]=s[i-j];
            Chkmax(r,i+a[i]/2);
            if(i-a[i]/2-1>0&&i+a[i]/2+1<=n)isn[i+a[i]/2+1][s[i-a[i]/2-1]-'a']=true;
        }
        printf("%s\n",s+1);
    }
    int main(void){
        file();
        init();
        solve();
        //cerr<<1.0*clock()/CLOCKS_PER_SEC<<endl;
        return 0;
    }

```

---

## 作者：Fzrcy (赞：1)

以某一点/间隙为中心的最长回文串长度，Manacher 无疑了。

先将字符串改造一下：`S = %#s[1]#s[2]#s[3]...s[n]#!`，在将以每一个字符为中心的最长回文串长度的数组 $x$ 和以每两个相邻字符的间隙为中心的最长回文串长度的数组 $y$ 合并一下得到：`a = 0 0 x[1] y[1] x[2] y[2] ... y[n-1] x[n] 0`。

设 $P_i$ 表示以 $i$ 为回文中心的最长回文半径，有 $P_i=a_i+1$。考虑用并查集维护相同字符的集合，链表维护不同字符的关系，对于任何一个 $i$ 有 $S_{i-j}=S_{i+j}(1\le j<P_i)$ 和 $S_{i-{P_i}}\not=S_{i+P_i}$。

用类似 Manacher 的算法来维护并查集和链表：设 $Mid$ 表示已知右边界最大的回文子串的中心，$r=Mid+P_{Mid}-1$。对于 $1\le i\le r$ 之间的相同关系和不同关系已经维护好了，只需加入 $[1,Mid]$ 和 $[r+1,i+P_i-1]$ 之间的相同关系和 $s_{i-P_i}$ 和 $s_{i+P_i}$ 之间的不同关系，然后像 Manacher 一样更新 $Mid$ 和 $r$ 的值即可。最后根据获得的相同和不同关系从左到右计算出字典序最小的答案即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=4e6+11;
int n, fa[N], col[N];
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
void merge(int x, int y){x=find(x), y=find(y); if(x!=y)fa[x]=y;}
int h[N], nt[N<<1], to[N<<1], cnt;
void link(int u, int v){
  nt[++cnt]=h[u], h[u]=cnt, to[cnt]=v;
}
int a[N], f[N];
int main(){
#ifdef LOCAL
  freopen("text.in","r",stdin);
  freopen("text.out","w",stdout);
#endif
  ios::sync_with_stdio(0);
  cin.tie(0),cout.tie(0);
  cin>>n;
  int m=2*n+1;
  for(int i=1; i<=n; i++)fa[i]=i;
  for(int i=1; i<=n; i++) cin>>a[i*2];
  for(int i=1; i<n; i++) cin>>a[i*2+1];
  for(int i=2, mid=0, r=0; i<m; i++){
    f[i]=(i<=r?min(f[(mid<<1)-i],r-i+1):1);
    while(f[i]-1<a[i]){
      f[i]++;
      if(!(i-f[i]+1&1))merge(i-f[i]+1>>1,i+f[i]-1>>1);
    }
    link(i-f[i]>>1,i+f[i]>>1), link(i+f[i]>>1,i-f[i]>>1);
    if(i+f[i]-1>r)mid=i,r=i+f[i]-1;
  }
  for(int i=1; i<=n; i++)if(!col[find(i)]){
    static int vis[33];
    memset(vis, 0, sizeof vis);
    for(int j=h[i]; j; j=nt[j])vis[col[find(to[j])]]=1;
    for(int j=1; j<=26&&!col[find(i)]; j++)
      vis[j]==0&&(col[find(i)]=j);
  }
  for(int i=1; i<=n; i++)
    cout<<(char)(col[find(i)]+'a'-1);
  cout<<'\n';
  return 0;
}
```

---


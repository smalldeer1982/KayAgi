# [SCOI2013] 数数

## 题目描述

Fish 是一条生活在海里的鱼，有一天他很无聊，就开始数数玩。他数数玩的具体规则是：

1. 确定数数的进制B

2. 确定一个数数的区间[L, R]

3. 对于[L, R] 间的每一个数，把该数视为一个字符串，列出该字符串的每一个（连续的）子串对应的B进制数的值。

4. 对所有列出的数求和。现在Fish 数了一遍数，但是不确定自己的结果是否正确了。由于[L, R] 较大，他没有多余精力去验证是否正确，你能写一个程序来帮他验证吗？


## 说明/提示

【样例解释】

[103, 103] 之间仅有数103，该数的所有子串包括1, 10, 103, 0, 03, 3，其和为120。

【数据范围与约定】

20% 数据，0 <= L <= R <= 10^5。

50% 数据，2 <= B <= 1000，1 <= N,M <= 1000。

100% 数据，2 <= B <= 10^5，1 <= N,M <= 10^5。


## 样例 #1

### 输入

```
10
3 1 0 3
3 1 0 3```

### 输出

```
120
```

# 题解

## 作者：_rqy (赞：37)

### 注意，本题解当 $L=0$ 的时候可能出错。

---

看到这题，显然是数位DP。

以下将每个数的“把该数视为一个字符串，列出该字符串的每一个（连续的）子串对应的B进制数的值”简称做该数的权值，记为$q[n]$。

首先要考虑在某个数的后面添加一位数字后，权值会如何改变。

把这个数当成字符串的话，在其后面添加一位，它原来的所有连续子串对其权值的贡献不变，新多出来的权值都是现在的后缀。于是，如果原来的数是$n$，某位添加一个$p$，现在的数是$\overline{np}$，那么有

$q[\overline{np}]=q[n]+\sum_{i=0}^{l[n]} \overline{n[1..i]p}$

其中$l[n]$是$n$的位数，$n[1..i]$是$n$从低到高第$1$到$i$位组成的数（特别的，我们认为$n[1..0]=0$）。

可以发现$\overline{n[1..i]p}=10\times n[1..i]+p$，所以

$q[\overline{np}]=q[n]+\sum_{i=0}^{l[n]} \overline{n[1..i]p}=q[n]+10\sum_{i=1}^{l[n]} n[1..i]+(l+1)q$

令$s[n]=\sum_{i=1}^l n[1..i]$为$n$的后缀和，我们就有$q[\overline{np}]=q[n]+s[\overline{np}]$，同时$s[\overline{np}]=10s[n]+(l[n]+1)q$，$l[\overline{np}]=l[n]+1$。当然，这都是在$n\neq0$的前提下的，否则会出现前导零（也可以认为$l[0]=0$，那样就没有问题了）。

于是我们考虑数位DP时维护$\sum s$，$\sum l$，$\sum q$和数的个数。只要注意不要出现前导零的情况就可以了。

代码中，$a,s,ss,sl$分别表示数的个数、$\sum q$，$\sum s$，$\sum l$。第二维是$0/1$分别表示前$i$位等于/小于原数的时候的值。

代码：

```cpp
//代码写的丑，不建议分析代码qwq。我自己看着都头疼qwq。
#include <algorithm>
#include <cstdio>
#include <cstring>
typedef long long LL;
const int N = 100050;
const int mod = 20130427;
int n, m, B;
int L[N], R[N];
LL SB[N], S[N];
LL a[N][2], s[N][2], ss[N][2], sl[N][2];
int solve(int *p, int l) {
  memset(a, 0, sizeof a);
  memset(s, 0, sizeof s);
  memset(ss, 0, sizeof ss);
  memset(sl, 0, sizeof sl);
  a[l][0] = 1;
  for (int i = l - 1; ~i; --i) {
    int c = (i == l - 1 ? 0 : B);
    a[i][0] = a[i + 1][0];
    a[i][1] = (c - 1 + a[i + 1][1] * B + a[i + 1][0] * p[i]) % mod;
    sl[i][0] = sl[i + 1][0] + a[i + 1][0];
    sl[i][1] = (c - 1 + sl[i][0] * p[i] +
                (sl[i + 1][1] + a[i + 1][1]) * B) % mod;
    ss[i][0] = (ss[i + 1][0] * B + p[i] * sl[i][0]) % mod;
    ss[i][1] = (S[c] + ss[i + 1][0] * B * p[i] + S[p[i]] * sl[i][0] +
                ss[i + 1][1] * B % mod * B +
                S[B] * (sl[i + 1][1] + a[i + 1][1])) % mod;
    s[i][0] = (s[i + 1][0] + ss[i][0]) % mod;
    s[i][1] = (s[i + 1][0] * p[i] + s[i + 1][1] * B + ss[i][1]) % mod;
  }
  return (s[0][0] + s[0][1]) % mod;
}
int main() {
  scanf("%d", &B);
  SB[0] = 1;
  for (int i = 0; i < N - 1; ++i) SB[i + 1] = (SB[i] * B + 1) % mod;
  S[0] = 0;
  for (int i = 0; i < B; ++i) S[i + 1] = (S[i] + i) % mod;
  scanf("%d", &n);
  for (int i = 0; i < n; ++i) scanf("%d", &L[n - i - 1]);
  for (int i = 0; i < n; ++i) {
    if (L[i] > 0) {
      --L[i];
      break;
    }
    L[i] = B - 1;
  }
  if (!L[n - 1]) --n;
  scanf("%d", &m);
  for (int i = 0; i < m; ++i) scanf("%d", &R[m - i - 1]);
  printf("%d\n", (solve(R, m) - solve(L, n) + mod) % mod);
  return 0;
}
```

---

## 作者：ViXbob (赞：29)

[博客推广](https://www.vixbob-lwc.pw)

大家好像写的都是递推, 太强辣吧, 然而我很菜只会打记忆化

所以来贡献一个记忆化的打法

首先我们考虑只有一个数的时候怎么算贡献, 记 $a[i]$ 表示这个数字 **从高到低** 的第 $i$ 位是什么, $L$ 表示这个数的长度, 那么这个数的贡献可以记为

$$ S[n] = \sum _ {i = 1} ^ n B ^ {i - 1}$$

$$ W = \sum _ {i = 1} ^ L i \cdot a[i] \cdot S[L - i + 1]$$

然后我们再考虑往这个数的最高位前面加一位数 $k$ 之后的贡献可以被表示为

$$ W' = k \cdot S[L + 1] + W + \sum _ {i = 1} ^ L a[i] \cdot S[L - i + 1]$$

我们再设

$$V = \sum _ {i = 1} ^ L a[i] \cdot S[L - i + 1]$$

再考虑 $dp$, 我们想要求 $[1, x]$ 中所有数的 $W$ 和, 所以对于一个 $x$ 我们设 $f[i]$ 表示 $[1, B ^ {L - i + 1})$ 中所有的数的 $W, V$ 的和

转移就直接搞一搞就好了

但是注意到对一一个状态如果有前导零和没有前导零, 算出来的 $W$ 值是不一样的, 所以将状态改成 $f[i][0/1]$ 就好了, 第二维表示有没有前导零

$naive$ 的我以为做到这里就做完了, 记搜的打法还是和以前的套路一样枚举这一位的数是什么, 但注意到 $B , N\le 10^5$
如果强行枚举选什么数的话, 最终的复杂度会退化到 $O(BN)$ 的, ~~一开始我还以为这是O(n), 我太naive了~~

考虑一个事实能影响你 $dp$ 值的只有三种情况

* 你前面选出来的数都是卡着上限的
* 你选的数有前导零
* $otherwise$

如果对于当前位你可选的数在 $[0, Lim]$ 范围内, 那么当前如果选 $Lim$ **可能** 会满足第一种情况, 选 $0$ **可能** 会满足第二种情况, 否则都是第三种情况

那我们其实可以直接分开讨论一下对于三种不同的状态都快速转移一下, 就可以不用枚举这一位选的具体是什么数了, 复杂度成功降至了 $O(N)$

其实大部分的数位 $dp$ 的记忆化打法~~都可以这样优化吧~~, 只是当进制是 $10$ 进制时, 优化的幅度并没有那么大, 因为就算不优化也只是多了个 $10$ 的常数, 但当进制数非常大时, 这个优化还是肥肠优秀的

代码
```
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;

const int P = 20130427;
const int maxn = 2e5 + 5;

int B, n, m, l[maxn], r[maxn], sum[maxn], a[maxn], len, sa[maxn], mi[maxn];
pair<int, int> f[maxn][2], em;

inline int read() {
	char ch = getchar(); int u = 0, f = 1;
	while(!isdigit(ch)) {if(ch == '-') f = -1; ch = getchar();}
	while(isdigit(ch))  {u = u * 10 + ch - 48; ch = getchar();} return u * f;
}

inline int pls(int x, int y) {x += y; return x >= P ? x - P : (x < 0 ? x + P : x);}
inline int mul(int x, int y) {LL rnt = 1ll * x * y; return rnt >= P ? rnt % P : rnt;}
inline int mul(int a, int b, int c) {return mul(a, mul(b, c));}
inline int pls(int a, int b, int c) {return pls(a, pls(b, c));}

inline int check(int *s, int n, int rnt = 0) {
	for(register int i = 1; i <= n; i++)
		rnt = pls(rnt, mul(i, s[i], sum[n - i + 1]));
	return rnt;
}

inline pair<int, int> dfs(int pos, bool lim, bool lead) {
	if(pos > len) return em;
	pair<int, int> &rnt = f[pos][lead], tmp;
	int Lim = lim ? a[pos] : (B - 1), S, l, r, i;
	bool is;
	if(!lim && rnt.first != -1) return rnt;
	rnt.first = rnt.second = 0;
	/*-------------------- i = 0 -----------------------*/
	i = 0;
	is = !lead || i != 0;
	S = (lim && (i == Lim)) ? (sa[pos + 1] + 1) : mi[len - pos + 1];
	tmp = dfs(pos + 1, lim && (i == Lim), lead && (i == 0));
	rnt.first = pls(rnt.first, tmp.first, is * tmp.second);
	rnt.first = pls(rnt.first, mul(i, sum[len - pos + 1], S));
	rnt.second = pls(rnt.second, tmp.second, mul(i, sum[len - pos + 1], S));
	/*-------------------- i > 0 -----------------------*/
	if(Lim > 1) {
		i = 1;
		is = !lead || i != 0;
		S = (lim && (i == Lim)) ? (sa[pos + 1] + 1) : mi[len - pos + 1];
		tmp = dfs(pos + 1, lim && (i == Lim), lead && (i == 0));
		l = i; r = Lim - 1;
		LL Len = r - l + 1;
		rnt.first = pls(rnt.first, mul(pls(tmp.first, tmp.second * is), Len));
		rnt.second = pls(rnt.second, mul(tmp.second, Len));
		Len = (l + r) * Len / 2;
		Len %= P; Len = mul(Len, S, sum[len - pos + 1]);
		rnt.first = pls(rnt.first, Len);
		rnt.second = pls(rnt.second, Len);
	}
	/*------------------- i = Lim ----------------------*/
	if(Lim > 0) {
		i = Lim;
		is = !lead || i != 0;
		S = (lim && (i == Lim)) ? (sa[pos + 1] + 1) : mi[len - pos + 1];
		tmp = dfs(pos + 1, lim && (i == Lim), lead && (i == 0));
		rnt.first = pls(rnt.first, tmp.first, is * tmp.second);
		rnt.first = pls(rnt.first, mul(i, sum[len - pos + 1], S));
		rnt.second = pls(rnt.second, tmp.second, mul(i, sum[len - pos + 1], S));
	} return rnt;
}

inline pair<int, int> calc(int *s, int n) {
	memset(f, 255, sizeof(f));
	memset(sa, 0, sizeof(sa));
	len = n;
	for(register int i = 1; i <= n; i++) a[i] = s[i];
	for(register int i = n; i >= 1; i--)
		sa[i] = pls(sa[i + 1], mul(mi[n - i + 1], a[i]));
	return dfs(1, 1, 1);
}

int main() {
	B = read(); n = read();
	for(register int i = 1; i <= n; i++) l[i] = read();
	m = read();
	for(register int i = 1; i <= m; i++) r[i] = read();
	//if(cmp(l, r, n, m) > 0) {cout << 0; return 0;}
	mi[1] = sum[1] = 1;
	for(register int i = 2; i < maxn; i++) mi[i] = mul(mi[i - 1], B);
	for(register int i = 2; i < maxn; i++) sum[i] = pls(mi[i], sum[i - 1]);
	cout << pls(calc(r, m).first, check(l, n) - calc(l, n).first);
	return 0;
}
/*
100801110

d[maxn]

L, pos, a[pos]
d[L - pos + 2] -= a[pos] * pos
d[1] += a[pos] * pos

ans

103
1 0 0 -1
1 0 0 -1
10 -9 0 -1
10 1 1
1 10 100 1000
1 11 111 1111
O(n)

1 10 100 1000
1103
1111 + 222 + 0 + 12
0000 + 111 + 0 + 09
-> 各个位上数的和
1103


*/
```

---

## 作者：rhn7 (赞：17)

这是一道非常恶心的数位 dp，本蒟蒻整了好久终于过了，发篇题解纪念一下。

按照数位 dp 一般套路，定义 $f_{x,lim,ld}$ 表示从低到高第 $x$ 位（$>x$ 的位确定，$\le x$ 的位不确定），确定的位是否贴着边界为 $lim$，确定的位是否都是零为 $ld$，不确定的位的子串和之和是多少。

容易发现 $f_{x,lim,ld}$ 一定从 $f_{x-1,lim\&[i=up],ld\&[i=0]}$ 转移过来，他俩相差以 $x$ 为起点的子串之和，我们把它记为 $g_{x,lim,ld}$。

$f_{x,lim,ld}\mathrel{+}=f_{x-1,lim\&[i=up],ld\&[i=0]}+g_{x,lim,ld}$

容易发现 $g_{x,lim,ld}$ 也一定从 $g_{x-1,lim\&[i=up],ld\&[i=0]}$ 转移过来，他俩相差第 $x$ 位接在开头后所产生的贡献。

$g_{x,lim,ld}\mathrel{+}=g_{x-1,lim\&[i=up],ld\&[i=0]}+\sum_{t=1}^{x-1}b^t×i×k$

这里的 $k$ 就是填数的方案数，也是所有可能的数字个数，我们把他记为 $h_{x,lim,ld}$，对于所有可能的数字个数，第 $x$ 位都会产生 $\sum_{t=1}^{x-1}b^t×i$ 的贡献。

$h$ 就很好推了：$h_{x,lim,ld}\mathrel{+}=h_{x-1,lim\&[i=up],ld\&[i=0]}$

数位 dp 用记忆化搜索实现比较方便，注意前导零时只转移 $f$，不然会产生重复计算。最终答案就是 $sum(r)-sum(l-1)$，$l-1$ 用高精减，要特判 $l=0$ 的情况，否则会被 hack，你用 $sum(r)-sum(l)+cal(l)$ 也行。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e5+5,P=20130427;
ll b,n,m,t,B[N],s[N],L[N],R[N];
struct Node{
	ll f,g,h;
} dp[N][2][2];
Node dfs(ll *p,ll x,ll lim,ll ld){
	if(!x) return {0,0,1};//x==0时默认h=1（0也是一个数），不然最后f,g,h就都是零了 
	if(dp[x][lim][ld].f!=-1) return dp[x][lim][ld];//记忆化 
	Node res={0,0,0};
	ll up=lim?p[x]:b-1;//b-1一定不要习惯的写成9 
	for(ll i=0;i<=up;i++){
		Node t=dfs(p,x-1,lim&&i==up,ld&&!i);//把[p][x-1][lim&&i==up][ld&&!i]的f,g,h都存下来 
		if(ld&&!i){(res.f+=t.f)%=P;continue;}//注意前导零时只转移f
		ll G=t.g+t.h*s[x-1]%P*i;
		(res.f+=t.f)%=P;(res.h+=t.h)%=P;(res.g+=G)%=P;//转移
	}
	(res.f+=res.g)%=P;//记得最后加上g 
	return dp[x][lim][ld]=res;
}
ll cal(ll *p,ll l){
	memset(dp,-1,sizeof(dp));//初始化成-1 
	return dfs(p,l,1,1).f;
}
int main(){
	cin>>b>>n;
	for(ll i=n;i;i--) cin>>L[i];//倒着读L和R比较方便 
	cin>>m;
	for(ll i=m;i;i--) cin>>R[i];
	L[1]--;
	for(ll i=1;i<=n;i++) if(L[i]<0) L[i]+=b,L[i+1]--;//高精减 
	B[0]=s[0]=1;
	for(ll i=1;i+5<=N;i++) B[i]=B[i-1]*b%P,s[i]=s[i-1]+B[i];//预处理b的幂，以及b的幂的前缀和 
	cout<<(cal(R,m)-cal(L,n)*(L[2]!=-1)+P)%P;//L[2]==-1时L就是-1，把sum(-1)当成0就行 
	return 0;
}
```

恭喜你喜获 50pts，因为计算过程中要枚举第 $x$ 位填的数字 $i$，所以时间复杂度是 $\Omicron(nb)$ 的，会超时，需要优化。

我们发现当 $i\in[1,up-1]$ 时，$lim$ 和 $up$ 都是零，也就是说所有的 $f$ 值都一样，所有的 $g$ 值都一样，所有的 $h$ 值也一样。$g$ 转移时的 $\sum_{t=1}^{x-1}b^t×i$ 用等差数列求和解决，剩下的直接 $×(up-1)$。$i=0,up$ 时单独处理就行。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e5+5,P=20130427;
ll b,n,m,t,B[N],s[N],L[N],R[N];
struct Node{ll f,g,h;} dp[N][2][2];
Node dfs(ll *p,ll x,ll lim,ll ld){
	if(!x) return {0,0,1};//x==0时默认h=1（0也是一个数），不然最后f,g,h就都是零了 
	if(dp[x][lim][ld].f!=-1) return dp[x][lim][ld];//记忆化 
	Node res={0,0,0};
	ll up=lim?p[x]:b-1;//b-1一定不要习惯的写成9 
	for(ll i=0;i<=up;i+=max(1ll,up)){
		Node t=dfs(p,x-1,lim&&i==up,ld&&!i);//把[p][x-1][lim&&i==up][ld&&!i]的f,g,h都存下来 
		//0和up的转移 
		if(ld&&!i){(res.f+=t.f)%=P;continue;}//注意前导零时只转移f
		(res.f+=t.f)%=P;(res.h+=t.h)%=P;
		(res.g+=t.g+t.h*s[x-1]%P*i)%=P;
	}
	Node t=dfs(p,x-1,0,0);
	if(up>1){
		//[1,up-1]的转移，注意前面要判up>1，不然会出现负数 
	    (res.g+=(up-1)*t.g+t.h*s[x-1]%P*(up*(up-1)/2%P))%=P;//up*(up-1)/2就是求1+2+...+up-1，其他都是乘up-1 
	    (res.f+=(up-1)*t.f)%=P;(res.h+=(up-1)*t.h)%=P;
	}
	(res.f+=res.g)%=P;//记得最后加上g 
	return dp[x][lim][ld]=res;
}
ll cal(ll *p,ll l){
	memset(dp,-1,sizeof(dp));//初始化成-1 
	return dfs(p,l,1,1).f;
}
int main(){
	cin>>b>>n;
	for(ll i=n;i;i--) cin>>L[i];//倒着读L和R比较方便 
	cin>>m;
	for(ll i=m;i;i--) cin>>R[i];
	L[1]--;
	for(ll i=1;i<=n;i++) if(L[i]<0) L[i]+=b,L[i+1]--;//高精减
	B[0]=s[0]=1;
	for(ll i=1;i+5<=N;i++) B[i]=B[i-1]*b%P,s[i]=(s[i-1]+B[i])%P;//预处理b的幂，以及b的幂的前缀和 
	cout<<(cal(R,m)-cal(L,n)*(L[2]!=-1)+P)%P;//L[2]==-1时L就是-1，把sum(-1)当成0就行 
	return 0;
}
```
~~如果你觉得写的好的话，点个赞再走呗~~

---

## 作者：C3H5ClO (赞：11)

发个另外一种的递推吧～～

~~看了另外两位dalao的题解，试着打打还是被这道题虐成狗。。。于是我滚去博客找了个好懂的解法，这里谈谈我自己的理解。。~~

```
数位DP，getans(n)表示[1,n]中每个数子串和的总和，则答案为getans(r)-getans(l-1)

如果f值用子串和，则会不好转移。
因此用f值表示前缀子串和，这样最后从1到len扫一遍就可以统计答案。

设a[i]表示n第i位，len表示n的长度,

s1[i]表示n的长度为i的后缀子串，s2[i]表示n的长度为i的前缀子串（令s2[len+1]=0)

f[0][i]表示所有“长度小于等于i”的数的“前缀子串和”的总和(例如，134的前缀子串和为1+13+134=148)

f[1][i]表示所有小于等于s1[i]的“长度小于等于i的数”的“前缀子串和”的总和
pb[i]表示b^i，spb[i]表示1+b+b^2+...+b^i

考虑如何转移f[i][0]。假设当前第i位取值为j。前i-1位共有pb[i-1]种取值。

长度小于等于i的前缀有[i,1],[i,2]...[i,i],
而长度为i-1的前缀有[i-1,1],[i-1,2]...[i-1,i-1]。
前缀子串[i,1]=j×pb[i-1]+[i-1,1],[i,2]=j×pb[i-2]+[i-1,2]...[i,i]=j。

计算在前i-1位共pb[i-1]种取值下j在一共i个前缀子串中的贡献。
j在每个前缀子串中分别为第1位至第i位，
则它的贡献总和为j×spb[i-1]×pb[i-1]。

由于j有从0到b-1共b种取值，则前i-1位的贡献要算b遍。
j的贡献之和用等差数列求和公式。最后得到：

f[i][0]=f[i-1][0]×b+(b-1)*b/2×spb[i-1]×pb[i-1]

同样道理推f[i][1]。需要分类讨论。

若j<a[i],则即使前i-1位任意取值，这个数也小于s1[i]。
而第i位有0~a[i]-1共a[i]个取值.

此时答案为f[i-1][0]×a[i]+a[i]×(a[i]-1)/2×spb[i-1]×pb[i-1]

若j=a[i],则前i-1位必须小于等于s1[i-1]。
因此此时答案可以从f[i-1][1]转移过来。前i-1位共有s1[i-1]+1种取值。

此时答案为f[i-1][1]+a[i]×spb[i-1]×(s1[i-1]+1)

综上，f[i][1]=f[i-1][0]×a[i]+a[i]×(a[i]-1)/2×spb[i-1]×pb[i-1]+f[i-1][1]+a[i]×(s1[i-1]+1)×spb[i-1]

接下来是统计答案的问题。

对于每个原数的前缀[1,i]，第i+1位至第len位会有s2[i+1]种取值，从1到s2[i+1]。

当第i+1位至第len位取值为s2[i+1]时，[1,i]必须小于等于s1[i],贡献为f[i][1]

若s2[i+1]>1,当第i+1位至第len位取值为1至s2[i+1]-1时,
[1,i]可以取任意值，贡献还要加上(s2[i+1]-1)×f[i][0]。

终于大功告成啦！　可以看一下代码辅助理解，不过这代码又丑又不好理解qaq

#include<cstdio>
using namespace std;
#define ri register int
#define ll long long
const ll MOD=20130427;
ll b,n,m,l[100005],r[100005],f[2][100005],pb[100005],spb[100005],s1[100005],s2[100005];
ll getans(ll a[],ll len)
{
    pb[0]=spb[0]=1;
    for(ri i=1;i<=len;i++)
    {
        pb[i]=pb[i-1]*b%MOD;
        spb[i]=(spb[i-1]+pb[i])%MOD;
        s1[i]=(s1[i-1]+a[i]*pb[i-1]%MOD)%MOD;
    }
    s2[len+1]=0;
    for(ri i=len;i;i--)s2[i]=(s2[i+1]*b%MOD+a[i])%MOD;
    for(ri i=1;i<=len;i++)
    {
        f[0][i]=(f[0][i-1]*b%MOD+b*(b-1)/2%MOD*pb[i-1]%MOD*spb[i-1]%MOD)%MOD;
        f[1][i]=(f[0][i-1]*a[i]%MOD+(a[i]-1)*a[i]/2%MOD*pb[i-1]%MOD*spb[i-1]%MOD+f[1][i-1]+a[i]*(s1[i-1]+1)%MOD*spb[i-1])%MOD;
    }
    ll res=0;
    for(ri i=1;i<=len;i++)
    {
        res=(res+f[1][i])%MOD;
        if(s2[i+1]>1)res=(res+(s2[i+1]-1)*f[0][i]%MOD)%MOD;
    }
    return res;
}
int main()
{
    scanf("%lld",&b);
    scanf("%lld",&n);
    for(ri i=n;i;i--)scanf("%lld",l+i);
    scanf("%lld",&m);
    for(ri i=m;i;i--)scanf("%lld",r+i);
    l[1]--;
    for(ri i=1;i<n;i++)
        if(l[i]<0)l[i]+=b,l[i+1]--;
    if(l[n]==0)n--;
    printf("%lld",(getans(r,m)-getans(l,n)+MOD)%MOD);
}
```

还有看不懂的童鞋可以评论或者私信窝

---

## 作者：djh123 (赞：8)

很神仙的一道题。

要求$[l,r]$的答案，我们可以求出$[1,r],[1,l],l$的答案，那么答案就是$[1,r]-[1,l]+l$

考虑怎么求$[1, n]$的答案。用数位dp的思想去做，设$g_{i,0/1}$表示以$i$为结尾，卡不卡上界的答案，$f_{i,0/1}$表示以$i$为结尾，卡不卡上界的子区间个数，这里不包含前导零的情况。$p_{i,0/1}$表示考虑到第$i$位，卡不卡上界的填数方案数。$F_{n}=\sum_{i=1}^ni$

考虑怎么求$g_{i,0}$：

如果之前不卡上界，那么这一位可以填$[0, m-1]$这个范围内的数，那么之前填过的数就会有$g_{i-1,0}*m*m$的贡献，第一个$m$是指进了一位，第二个$m$表示每一种状态都有$m$种填法。

如果之前卡上界，那么这一位就只能填$[0,a_i-1]$这个范围内的数，那么之前填过的数的贡献就是$g_{i-1,1}*m*a_i$。

现在我们求出了之前填的数在这一位产生的贡献，考虑填上的这个数产生了多少贡献。

第一种情况就是与之前的区间组合，即$F(m-1)*f_{i-1,0}+F(a_i-1)*f_{i-1,1}$

第二种情况就是自己单独成一个区间，即$F(m-1)*p_{i-1,0}+F(a_i-1)*p_{i-1,1}$

求$g_{i,1}$:

之前只能卡上界，那么之前的数会产生$g_{i-1,1}*m$的贡献。

新填的数的贡献就是$a_i*f_{i-1,1}+a_i*p_{i-1,1}$

求$f_{i,0}$:

如果之前不卡上界，那么这一位可以填$[0, m-1]$，那么与之前构成的方案数就是$f_{i-1,0}*m$

如果之前卡上界，那么这一位可以填$[0,a_i-1]$，那么与之前构成的方案数就是$f_{i-1,1}*a_i$

考虑这一位新产生的区间个数，就是$p_{i, 0}$，但是这样会有全是零的情况，就把全是零的方案减去，所以贡献是$p_{i,0}-1$。

求$f_{i,1}$：

只能填一个数，所以方案数就是$f_{i-1,1}+p_{i,1}$。注意这里没有前导零的情况，所以不用减$1$

$p$的转移比较显然：

$p_{i,1} = 1$

$p_{i,0} = p_{i-1, 1}*a_i+p_{i-1,0}*m$

那么最后统计答案时，以$i$为结尾的答案，不卡上界，会出现$B^{n-i}$次，卡上界时，会出现后$n-i$位形成的数次。直接加起来就行了。

贴一下代码：

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

typedef long long LL;

#define rep(x, a, b) for(int x = (a); x <= (b); ++ x)
#define per(x, a, b) for(int x = (a); x >= (b); -- x)
#define rop(x, a, b) for(int x = (a); x < (b); ++ x)
#define por(x, a, b) for(int x = (a); x > (b); -- x)

const int mod = 20130427;
void upd(int &x, int y) { x += y; if(x >= mod) x -= mod; }

const int N = 1e5 + 50;
int l[N], r[N];
int f[N][2], g[N][2], p[N][2];
int q[N], pw[N];

int F(int x) {
	if(x <= 0) return 0;
	return 1ll * x * (x + 1) / 2 % mod;
}

int F(int l, int r) {
	return (F(r) - F(l - 1) + mod) % mod;
}

int solve(int n, int *a, int m) {
	memset(f, 0, sizeof f);
	memset(g, 0, sizeof g);
	memset(p, 0, sizeof p);
	memset(pw, 0, sizeof pw);
	memset(q, 0, sizeof q);
	p[0][1] = 1; pw[n + 1] = 1;
	per(i, n, 1) q[i] = (q[i + 1] + 1ll * a[i] * pw[i + 1] % mod) % mod, pw[i] = 1ll * pw[i + 1] * m % mod;
	rep(i, 1, n) {
		p[i][1] = 1;
		p[i][0] = (1ll * p[i - 1][1] * a[i] % mod + 1ll * p[i - 1][0] * m % mod) % mod;
		f[i][1] = (f[i - 1][1] + p[i][1]) % mod;
		f[i][0] = (1ll * f[i - 1][1] * a[i] % mod + 1ll * f[i - 1][0] * m % mod + p[i][0] - 1) % mod;
		//之前出现的数产生的贡献 
		g[i][0] = (1ll * g[i - 1][0] * m % mod * m % mod + 1ll * g[i - 1][1] * m % mod * a[i] % mod) % mod; // 之前的每个合法状态的贡献都会*m，然后乘后面可以放的数的个数。 
		g[i][1] = 1ll * g[i - 1][1] * m % mod;
		//新填的数产生的贡献 
	    upd(g[i][0], 1ll * F(a[i] - 1) * f[i - 1][1] % mod); //在之前的卡上界的合法状态中放一个[0,a[i]-1]，这个数与之前的状态产生的贡献。 
	    upd(g[i][0], F(a[i] - 1) * p[i - 1][1]); //  这个数单独贡献。
		if(i != 1) {
			upd(g[i][0], 1ll * F(m - 1) * f[i - 1][0] % mod); // 在之前不卡上界的时候放一个数。 
			upd(g[i][0], 1ll * F(m - 1) * p[i - 1][0] % mod); // 这个数单独贡献。 
		}
		upd(g[i][1], 1ll * a[i] * f[i - 1][1] % mod);
		upd(g[i][1], a[i]);
	}
	int ans = 0;
	rep(i, 1, n) {
		upd(ans, g[i][1] * 1ll * (q[i + 1] + 1) % mod);
		upd(ans, g[i][0] * 1ll * pw[i + 1] % mod);
	}
	return ans;
}

int calc(int n, int *a, int m) {
	memset(pw, 0, sizeof pw);
	memset(q, 0, sizeof q);
	int ans = 0; pw[1] = 1; q[1] = 1;
	rep(i, 2, n) pw[i] = 1ll * pw[i - 1] * m % mod, q[i] = (q[i - 1] + pw[i]) % mod;
	rep(i, 1, n) upd(ans, 1ll * i * a[i] % mod * q[n - i + 1] % mod);
	return ans;
}

int main() {
	int m; scanf("%d", &m);
	int l1, l2;
	scanf("%d", &l1); rep(i, 1, l1) scanf("%d", &l[i]);
	scanf("%d", &l2); rep(i, 1, l2) scanf("%d", &r[i]);
	printf("%lld\n", (((solve(l2, r, m) - solve(l1, l, m) + 1ll * calc(l1, l, m)) % mod) + mod) % mod);
}


```


---

## 作者：斯茂 (赞：8)

### 好不容易过了这道毒瘤题

### 我只能说，我从未见过如此毒瘤的数位DP

### 这里介绍一种比较特别的数位DP方法

### 下面开始正文

首先我们考虑解决这样一个问题，求[1,x-1)内所有数的答案

把x写成B进制形式 x1, x2, x3, ... , xn。

首先考虑不足n位的数

然后对于达到了n位的数，枚举第一个小于xi的数位。

由于是开区间，必然存在这样一个数位。

这种方法可以减少前导零的分类，还是比较方便的

下面讲一下这道题的DP

这道题是融合了很浓厚的数学思想的

下文设P[i] = 10^i，S[i]为P[i]前缀和

考虑给定一个数x1, x2, ..., xn，求它的子串和。

考虑每个数位的贡献，第i个数位的贡献是

```
i * xi * S[n - i]
```
理解一下这个式子

定义d[i][0]表示还要填i位，所有前缀子串和，d[i][1]表示还要填i位，所有子串和。

这个转移还是比较显然的

对于不足n位的数，显然直接枚举最高位就行了

达到n位的数，我们需要考虑三段的贡献，即：第一个小于xi的数位，第一个小于xi的数位之前，第一个小于xi的数位之后

具体情况可以看一下下面的代码

然而我们还有一个问题没有解决

上面的做法是O(nB)的。

只要把枚举该位填了什么改成通过
```
1 + 2 + ... + n = n * (n + 1) / 1
```
优化一下即可

代码的SV表示原数x的一段前缀在整个数上的贡献

千万注意每次DP前清零SV。

```
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#define int long long
using namespace std;
const int mod = 20130427;
int cnt, a[100005];
int B, SV[100005], d[100005][2], P[100005], S[100005];
void read()
{
	memset(SV, 0, sizeof(SV));
	for(int i = cnt - 1; i >= 0; i--)
		scanf("%lld", &a[i]), SV[i] = (SV[i + 1] + a[i] * (cnt - i) % mod * S[i] % mod) % mod;
}
int calc(int x, bool p)
{
	if(x <= 0) return 0;
	if(d[x][p] != -1) return d[x][p];
	if(p)
		return d[x][1] = (B * calc(x - 1, 1) % mod + (B * (B - 1) / 2) % mod * P[x - 1] % mod * S[x - 1] % mod + B * calc(x - 1, 0) % mod) % mod;
	else
		return d[x][0] = (B * calc(x - 1, 0) % mod + (B * (B - 1) / 2) % mod * P[x - 1] % mod * S[x - 1] % mod) % mod;
}
int solve()
{
	int i, ans = 0;
	for(i = 1; i < cnt; i++)
		ans = (ans + (B - 1) * calc(i - 1, 1) % mod + (B * (B - 1) / 2) % mod * P[i - 1] % mod * S[i - 1] % mod + (B - 1) * calc(i - 1, 0) % mod) % mod;
	for(i = cnt - 1; i >= 0; i--)
		if(i == cnt - 1)
			ans = (ans + (a[i] * (a[i] - 1) / 2) % mod * P[i] % mod * S[i] % mod + (a[i] - 1) * calc(i, 1) % mod + (a[i] - 1) * calc(i, 0) % mod) % mod;
		else
			ans = (ans + SV[i + 1] * a[i] % mod * P[i] % mod + (a[i] * (a[i] - 1) / 2) % mod * P[i] % mod * S[i] % mod * (cnt - i) % mod + a[i] * calc(i, 1) % mod + a[i] * calc(i, 0) % mod * (cnt - i) % mod) % mod;
	return ans;
}
int count()
{
	return SV[0];
}
signed main()
{
	int a1, a2, c1, c2;
	memset(d, -1, sizeof(d));
	scanf("%lld%lld", &B, &cnt);
	P[0] = S[0] = 1;
	for(int i = 1; i <= 100003; i++)
		P[i] = P[i - 1] * B % mod, S[i] = (S[i - 1] + P[i]) % mod;
	read();
	c1 = count();
	a1 = solve();
	scanf("%lld", &cnt);
	read();
	c2 = count();
	a2 = solve();
	printf("%lld\n", (a2 - a1 + c2 + mod * mod) % mod);
	return 0;
}
}
```
提供一组样例

输入 

92763

4 12988 88277 44588 91111

5 10122 34857 38274 81733 32455

输出

615035


---

## 作者：spdarkle (赞：7)

按照一般的套路，我们将答案转化为 $sum_r-sum_{l-1}$ 的形式。

考虑按照一般地数位DP计算答案。以下的位数从第 $0$ 位开始。

设 $f(i,j,k)$ 为前 $i$ 位，是否有最高位限制，是否有前导零的答案。

如何转移？注意到我们从 $i-1$ 推到 $i$ 需要计算第 $i$ 位的贡献。其余贡献可以直接加上。

设我们第 $i$ 位填 $k$，需要哪些信息呢？

注意到对于已经填好的 $0\sim i-1$ 位的每一个以 $i$ 位为右端点的子段，有贡献之和为 $k(1+b+b^2\dots b^{i})$，可以预处理 $p_i=b^i+p_{i-1}$，得到贡献为 $kp_i$。

然后对于以 $i$ 为右端点的子段的其他点的贡献，可以由以 $i-1$ 为右端点的子段得到。这里维护为 $w(i,j,k)$。

我们需要计算当前的数的个数 $c(i,j,k)$，以计算第 $i$ 位能产生多少个 $kp_i$。

综上，我们需要维护 $f(i,j,k),w(i,j,k),c(i,j,k)$。

而具体的转移方程，不难得出：

$$
\begin{aligned}
f(i,j,k)&=\sum_{x=0}^{up}f(i-1,q_1,q_2)+w(i-1,q_1,q_2)+c(i-1,q_1,q_2)xp_i\\
w(i,j,k)&=\sum_{x=0}^{up}w(i-1,q_1,q_2)+c(i-1,q_1,q_2)xp_i\\
c(i,j,k)&=\sum_{x=0}^{up}c(i-1,q_1,q_2)
\end{aligned}$$

其中 $q_1,q_2$ 是计算得出的新状态。

注意当我们填 $0$ 且填的是前导零的时候，$c,w$ 不参与转移。

这时候，我们就可以得到五十分代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1005050
#define int long long
const int p=20130427;
struct node{
	int s,w,c;
};
node mk(int s,int w,int c){
	return (node){s,w,c};
}
int pw[N],b,num[N],num1[N],num2[N];
node f[N][2][2];
node dfs(int now,int tag,int qd){
	if(now<0)return mk(0,0,1);
	if(f[now][tag][qd].s!=-1)return f[now][tag][qd];
	auto s=mk(0,0,0);
	int up=tag?num[now]:b-1;
	for(int i=0;i<=up;i++){
		auto a=dfs(now-1,tag&(i==up),qd&(i==0));
		if(i==0&&qd==1){
			s.s+=a.s;continue;
		}
		s.c+=a.c;
		s.s+=a.w+a.c*pw[now]%p*i%p+a.s;
		s.w+=a.w+a.c*pw[now]%p*i%p;
		s.s%=p,s.c%=p;s.w%=p;
	}
//	cout<<"  "<<now<<" "<<qd<<" "<<tag<<" "<<now<<" "<<s.s<<" "<<s.c<<"\n";
	f[now][tag][qd]=s;
	return s;
}
int init(int tag,int n){
	memset(f,-1,sizeof f);
	if(tag)num[0]--;
	if(num[0]==-1){
		num[0]=b-1;int tag=0;
		for(int i=1;i<=n-1;i++){
			if(num[i]==0)num[i]=b-1;
			else{
				tag=1;
				--num[i];break;
			}
		}
		if(!tag)return 0;
		if(!num[n-1])--n;
	}
//	for(int i=n-1;i>=0;--i)cout<<num[i];cout<<"\n";
	auto res=dfs(n-1,1,1);
//	cout<<"In: "<<res.c<<" "<<" "<<res.s<<"\n";
	return res.s;
}
bool check(int n){
	for(int i=n-1;i>=0;--i){
		if(num1[i]>num2[i])return 1;
		if(num1[i]<num2[i])return 0;
	}
	return 0;
}
int read(){
	int x=0;char ch=getchar();
	while(ch>'9'||ch<'0')ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x; 
}
signed main(){
	ios::sync_with_stdio(false);
	b=read();pw[0]=1;
	for(int i=1;i<=1e5;i++)pw[i]=pw[i-1]*b%p;
	for(int i=1;i<=1e5;i++)pw[i]=(pw[i]+pw[i-1])%p;
	int n1,n2;n1=read();
	for(int i=n1-1;i>=0;--i)num1[i]=read();
	n2=read();for(int i=n2-1;i>=0;--i)num2[i]=read();
	if(n1>=n2){
		if(n1>n2||check(n1)){
			for(int i=n1-1;i>=0;--i)num[i]=num1[i];
			int res=init(1,n1);
			for(int i=n2-1;i>=0;--i)num[i]=num2[i];
			num2[0]++;
			if(num2[0]==b){
				int d=1;
				for(int i=1;i<n2;i++){
					if(num[i]<b-1){
						d=0;num[i]++;break;
					}
					else num[i]=0;
				}
				if(d)num[++n2]=1;
			}
			res-=init(0,n2); 
			res=-res;
			cout<<(res%p+p)%p;//<<" XX\n"<<n1<<" "<<n2<<"\n";	
			return 0;
		}
	}
	for(int i=n1-1;i>=0;--i)num[i]=num1[i];
	int res=-init(1,n1);
	for(int i=n2-1;i>=0;--i)num[i]=num2[i];
	res+=init(0,n2);
	cout<<(res%p+p)%p<<"\n";
}
```

为什么会五十分呢？注意到转移的复杂度是 $O(B)$ 的。

这导致复杂度变成了 $O(B(N+M))$，会炸。

但观察转移方程，可以看出当填的 $x\neq up,x\neq 0$ 时，$q_1,q_2$ 是相同的，可以使用简单的加法原理进行合并。

注意 $up=0$ 的情况。

这样我们就成功把转移复杂度降到了 $O(1)$，成功 $O(N+M)$ 地解决了该问题。

```cpp
node dfs(int now,int tag,int qd){
	if(now<0)return mk(0,0,1);
	if(f[now][tag][qd].s!=-1)return f[now][tag][qd];
	auto s=mk(0,0,0);
	int up=tag?num[now]:b-1;
	if(!up){
		int i=0;
		auto a=dfs(now-1,tag&(i==up),qd&(i==0));
		if(i==0&&qd==1){
			s.s+=a.s;
		}
		else {
			s.c+=a.c;
			s.s+=a.w+a.c*pw[now]%p*i%p+a.s;
			s.w+=a.w+a.c*pw[now]%p*i%p;
			s.s%=p,s.c%=p;s.w%=p;
		}
	}
	else {	
		for(int i=0;i<=up;i+=up){
			auto a=dfs(now-1,tag&(i==up),qd&(i==0));
			if(i==0&&qd==1){
				s.s+=a.s;continue;
			}
			s.c+=a.c;
			s.s+=a.w+a.c*pw[now]%p*i%p+a.s;
			s.w+=a.w+a.c*pw[now]%p*i%p;
			s.s%=p,s.c%=p;s.w%=p;
		}
	}
	//1~up-1必然是一个状态
	int cnt=up-1;
	if(cnt>0){
		auto a=dfs(now-1,0,0);
		s.c+=a.c*cnt%p;
		s.s+=(a.w*cnt%p+a.c*pw[now]%p*((cnt*(cnt+1ll)/2ll)%p)+a.s*cnt%p);
		s.w+=a.w*cnt%p+a.c*pw[now]%p*((cnt*(cnt+1ll)/2ll)%p);
		s.w%=p,s.s%=p,s.c%=p;
	}
//	cout<<"  "<<now<<" "<<qd<<" "<<tag<<" "<<now<<" "<<s.s<<" "<<s.c<<"\n";
	f[now][tag][qd]=s;
	return s;
}
```

---

## 作者：creation_hy (赞：6)

目前（写这篇题解的时候）的最优解 rk1，所以发篇题解庆祝一下（

这么做的理由很多题解已经讲过了，那我来讲一下具体实现。

## 题意

给定 $l,r$，求出 $\displaystyle\sum_{i=l}^r F(i)$，$F(i)$ 表示 $i$ 变成字符串后的每个子串代表的数之和。

## 前置知识：数位dp

如果没做过可以先做一下 P2657 这道题。

提一句（这样在思路那部分就不讲了）：

设 $F(i)$ 表示 $[1,i]$ 符合要求的数字个数，当前数字是 $j$，长度 $len$。

如果 $j$ 是 $i$ 的前缀，那么 $j$ 后面只能接 $a[len]$ 种数字（否则就超过 $i$ 了），否则可以接 $B$ 种，$B$ 代表是多少进制。

## 思路

设 $num[i]$ 表示长度为 $i$ 的子串有多少种。

那么 $num[i]=num[i-1]\times b+a[i]+k$。

$num[i-1]\times b$ 表示在长度 $i-1$ 且不是最大值的前缀的子串后面接一个数的方案数，$a[i]$ 表示长度 $i-1$ 且是最大值的前缀的子串后面再接一个数的方案数（详见前置知识那部分），$k$ 表示以第 $i$ 位开头的子串的数量。

接下来，$len[i][0/1]$ 表示长度为 $i$ 的子串的长度和，如果第二项为 $0$，表示子串是最大值的前缀，$1$ 表示不是。

那么 $len[i][0]=len[i-1][0]+1$，因为很显然这种子串固定长度后只会存在一个。

$len[i][1]=len[i][0]\times a[i]+(len[i-1][1]+num[i-1])\times b+k$

$len[i][0]\times a[i]$ 表示把 $len[i][0]$ 最后一个数字替换成和 $a[i]$ 不相同的数字，即 $[0,a[i]-1]$，$(len[i-1][1]+num[i-1])\times b$ 表示从并非最大值前缀的子串继承，$k$ 依旧表示以第 $i$ 位开头。

前面已经讲了这么多了，剩下两个数组 $suf$ 和 $f$ 请读者自行理解，其中 $suf_i$ 表示长度为 $i$ 的子串的后缀之和，$f_i$ 表示长度为 $[1,i]$ 的子串的最终方案数之和。

## 代码

另：减少取模可以加快代码执行的效率。已经取过模的数字乘完后加在一起不会爆，所以没必要每次乘都取模。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 5;
const int mod = 20130427;
int b, l[N], r[N];
ll f[N][2], num[N], suf[N][2], len[N][2], pre[N];
inline int read()
{
    int s = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
        ch = getchar();
    while (ch >= '0' && ch <= '9')
    {
        s = (s << 3) + (s << 1) + (ch ^ 48);
        ch = getchar();
    }
    return s * f;
}
inline int solve(int n, int *a)
{
    for (int i = 1; i <= n; i++)
    {
        int k = (i > 1) * b - 1;
        num[i] = (num[i - 1] * b + a[i] + k) % mod;
        len[i][0] = len[i - 1][0] + 1;
        len[i][1] = (len[i][0] * a[i] + (len[i - 1][1] + num[i - 1]) * b + k) % mod;
        suf[i][0] = (suf[i - 1][0] * b + len[i][0] * a[i]) % mod;
        suf[i][1] = (pre[k] + suf[i - 1][0] * b * a[i] + pre[a[i] - 1] * len[i][0] + suf[i - 1][1] * b % mod * b + (len[i - 1][1] + num[i - 1]) * pre[b - 1]) % mod;
        f[i][0] = (f[i - 1][0] + suf[i][0]) % mod;
        f[i][1] = (f[i - 1][0] * a[i] + f[i - 1][1] * b + suf[i][1]) % mod;
    }
    return (f[n][0] + f[n][1]) % mod;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, m;
    for (int i = 1; i < N; i++)
        pre[i] = (pre[i - 1] + i) % mod;
    b = read(), n = read();
    for (int i = 1; i <= n; i++)
        l[i] = read();
    m = read();
    for (int i = 1; i <= m; i++)
        r[i] = read();
    l[n]--;
    for (int i = n; l[i] < 0; i--)
        l[i] += b, l[i - 1]--;
    if (!l[1])
        n--, memcpy(l, l + 1, sizeof(l + 1));
    cout << (solve(m, r) - solve(n, l) + mod) % mod;
    return 0;
}
```

---

## 作者：Flash_Man (赞：5)

提供一种更加好想但较为难写的数位 DP 思路。

定义 $f(i)$ 表示 $i$ 位任选（可以有前导零），所有数的所有子串的和；$g(i)$ 表示 $i$ 位任选（也可以有前导零），所有数的所有**前缀**子串的和。转移 $g$ 的时候枚举新加的位 $x$，计算这一位的影响（原来的位有 $B^{i-1}$ 种，对于每种情况，$x$ 的影响次数为 $\sum_{j\in[0..i)}B^j$），和原来的位的影响（新加的位有 $B$ 种情况，每种情况的影响都是 $g(i-1)$），然后相加（注意等差数列相加需要优化掉，不然复杂度不对）：
$$
\begin{aligned}
g(i)&=B^{i-1}\times\left(\sum_{x\in[0..B)}\sum_{j\in[0..i)}x\times B^j\right)+B\times g(i-1)\\
&=B^{i-1}\times\left(\sum_{j\in[0..i)}B^j\right)\times\frac{B(B+1)}{2}+B\times g(i-1)\\
f(i)&=B\times f(i-1)+g(i)
\end{aligned}
$$
因为很多地方都要用到 $\sum_{j\in[0..i]}B^j$，所以预处理它，记 $h(i)=\sum_{j\in[0..i]}B^j$。 

考虑计算 $<x=\overline{a_na_{n-1}\cdots a_1}$ 的答案，答案分为两部分：

- 数的位数小于 $n$：

  枚举位数和最高位（最高位不能为 $0$），然后计算答案（使用类似 $f$ 和 $g$ 的转移方法）：
  $$
  \begin{aligned}
  &\sum_{i\in[1..n)}\sum_{x\in[1..B)}\left(f(i-1)+x\times B^{i-1}\times h(i-1)+g(i-1)\right)\\
  =&\sum_{i\in[1..n)}\left((B-1)\times f(i-1)+\frac{B(B-1)}{2}\times B^{i-1}\times h(i-1)+(B-1)\times g(i-1)\right)
  \end{aligned}
  $$

- 数的位数等于 $n$：

  枚举 $i$ 表示数的 $n$ 到 $i+1$ 位与 $x$ 相同，第 $i$ 位小于 $a_i$，后面的位都可以任取。记录辅助变量 $\text{suf}(i)$ 表示 $n$ 到 $i+1$ 位的所有后缀子串的和；$\text{csuf}(i,x)$ 表示 $n$ 到 $i+1$ 位与 $x$ 相同，最后一位为 $x$ 的所有后缀子串的和，$\text{sum}(i)$ 表示 $n$ 到 $i+1$ 位的所有子串的和，答案计算：
  $$
  \begin{aligned}
  \text{suf}(i)&=(l-i+1)\times a_i +b\times \text{suf}(i+1) \\
  \text{csuf}(i,x)&=(l-i+1)\times x +b\times \text{suf}(i+1) \\
  \text{sum}(i)&=\text{sum}(i+1)+\text{suf}(i) \\
  \text{ans}&=\sum_{i=n}^1\sum_{x=[i=1]}^{a_i-1}\text{sum}(i)\times B^{i-1}+f(i-1)+\text{csuf}(i)\times h(i-1)\times B^{i-1}+(l-i+1)\times g(i-1)
  \end{aligned}
  $$
  解释一下 $\text{ans}$ 的计算：
  
  - 与 $x$ 无关的答案：
    - $i$ 位以前：任取位有 $B^{i-1}$ 种取法，对于每种取法，和都是 $\text{sum}(i)$，所以贡献是 $\text{sum}(i)\times B^{i-1}$；
    - $i$ 位以后：任取位的答案就是预处理的答案 $f(i-1)$；
  - 与 $x$ 有关的答案：
    - $\text{csuf}$ 的贡献：任取位有 $B^{i-1}$ 种取法，对于每种取法，贡献次数都是 $h(i-1)$，所以贡献为 $\text{csuf}(i)\times h(i-1)\times B^{i-1}$；
    - 其他的贡献：有 $l-i+1$ 个前缀，每个前缀贡献都是 $g(i-1)$，所以贡献为 $(l-i+1)\times g(i-1)$。
  
  因为要让复杂度正确，所以这个式子也要等差数列优化，但是优化过后的式子太丑了，所以这里就不放了，需要就直接看代码（代码注释的那一部分就是原本的式子）。
  
```cpp
#include <cstdio>
#define int long long
const int maxl = 1e5 + 3;
const int mod = 20130427;
int b, l[2], s[2][maxl];
int f[maxl], g[maxl];
int smb[maxl], pwb[maxl];
int solve(int t) {
	for (int i = 1; i <= l[t]; i++) {
		g[i] = (b * (b - 1) / 2 % mod * smb[i - 1] % mod * pwb[i - 1] % mod + b * g[i - 1] % mod) % mod;
		f[i] = (b * f[i - 1] % mod + g[i]) % mod;
	}
	int res = 0;
	for (int i = 1; i < l[t]; i++)
		res = (res + (b - 1) * f[i - 1] % mod + b * (b - 1) / 2 % mod * smb[i - 1] % mod * pwb[i - 1] % mod + (b - 1) * g[i - 1] % mod) % mod;
	int sum = 0, suf = 0;
	for (int i = l[t]; i >= 1; i--) {
		// int csuf;
		// for (int x = i == l[t]; x < s[t][i]; x++) {
		// 	csuf = ((l[t] - i + 1) * x % mod + b * suf % mod) % mod;
		// 	res = (res + sum * pwb[i - 1] % mod + f[i - 1] + csuf * smb[i - 1] % mod * pwb[i - 1] % mod + (l[t] - i + 1) * g[i - 1]) % mod;
		// }
		int rep = s[t][i] - (i == l[t]);
		res = (res +
			rep * sum % mod * pwb[i - 1] % mod +
			rep * f[i - 1] % mod +
			(s[t][i] * (s[t][i] - 1) / 2 % mod * (l[t] - i + 1) % mod +
			rep * b % mod * suf % mod) % mod * smb[i - 1] % mod * pwb[i - 1] % mod +
			rep * (l[t] - i + 1) % mod * g[i - 1] % mod
		) % mod;
		suf = ((l[t] - i + 1) * s[t][i] % mod + b * suf % mod) % mod;
		sum = (sum + suf) % mod;
	}
	return res;
}
signed main() {
	scanf("%lld", &b);
	pwb[0] = smb[0] = 1;
	for (int i = 1; i < maxl; i++) smb[i] = (smb[i - 1] + (pwb[i] = pwb[i - 1] * b % mod)) % mod;
	for (int t = 0; t < 2; t++) {
		scanf("%lld", &l[t]);
		for (int i = l[t]; i >= 1; i--) scanf("%lld", &s[t][i]);
	}
	for (int i = 1; i <= l[1] + 1; i++) {
		if (s[1][i] < b - 1) { s[1][i]++; break; }
		s[1][i] = 0;
	}
	if (s[1][l[1] + 1]) l[1]++;
	printf("%lld\n", (solve(1) - solve(0) + mod) % mod);
	return 0;
}
```

---

## 作者：快斗游鹿 (赞：4)

**思路**

套路地，可以先求出 $[1,r]$ 的答案，再减去 $[1,l-1]$ 的答案。

如果只有一个数，可以 $O(n)$ 求出答案，设 $f_i$ 表示以 $i$ 结尾的子串的贡献，有转移 $f_i=f_{i-1}\times B +a_i\times i$，答案为 $\sum f_i$。

如果有多个数呢？改设状态 $f_{i.0/1}$ 表示以 $i$ 结尾，没有/有顶着上界的**所有串**答案。但这样还是不方便转移，我们还需要知道当前位前的所有数长度和，以 $i-1$ 结尾的所有数的和，分别设为 $sum_{i,0/1},s_{i,0/1}$。$0$ 是没顶上界，$1$ 是顶上界。

先来看 $sum$ 的转移，如果顶着上界，显然是 $sum_{i,1}=sum_{i-1,1}+1$。如果没有，则是前面所有的串再延长一，所以还得再记 $num_{i,0/1}$ 表示到第 $i$ 位一共出现了多少个数。$sum_{i,0}=(sum_{i-1,0}+num_{i-1,0})\times B+(sum_{i-1,1}+num_{i-1,1})\times a_i+B-1$。意义是如果前面没有顶着上界，这一位有 $B$ 种取值都可以填，前面的每个后缀都多出 $B$ 种情况，如果顶着上界，这一位只可以填 $0,1,\dots a_i-1$ 共 $a_i$ 种，也就是前面每个后缀都多出 $a_i$ 种情况。除此之外，如果不与前面的串拼接，则可以填 $1,2\dots,B-1$。**因为不可以出现前导零，所以不能填 $0$。**

$num$ 的转移是显然的，$num_{i,1}=1$，$num_{i,0}=num_{i-1,0}\times B+num_{i-1,1}\times a_i+B-1$。跟 $sum$ 转移差不多。

接下来考虑 $s$，顶着上界同样简单，$s_{i,1}=s_{i-1,1}\times B+a_i\times sum_{i,1}$，就是把已经出现的串 $\times B$ 再加上新增的个位数，和不考虑前面的串，新出现的串的贡献。$s_{i,0}$ 也需要分前一位是否顶着上界讨论，如果前面顶着上界，这一位有 $a_i$ 种取值，贡献为 $s_{i-1,1}\times B\times a_i+(sum_{i-1,1}+num_{i-1,1})\times c(a_i-1)$。意义是前面所有后缀都新增 $a_i$ 种情况。而到第 $i$ 位时共有 $sum_{i-1,1}+num_{i-1,1}$ 种后缀满足前面顶着上界，每个后缀后面都可以接 $0,1,2\dots a_i-1$，个位数之和就是 $c(a_i-1)=\dfrac{a_i\times(a_i-1)}{2}$。前面不顶着上界的转移是类似的。最后同样要加上新出现的串的贡献。

最后就可以求出 $f$ 了，$f_{i,1}=f_{i-1,1}+s_{i,1}$，这是显然的，而 $f_{i,0}=f_{i-1,0}\times B+f_{i-1,1}\times a_i+s_{i,0}$，意义是对于前面顶着上界的数，在这一位会多出 $a_i$ 种情况，也就是说前面的所有子串在这里都会被再累加 $a_i$ 次，没有顶着是类似的。而包括当前位的后缀和已经被计算出来了，记为 $s_{i,0}$。

直接递推即可，答案是 $f_{len,0}+f_{len,1}$，$len$ 是串长。总时间复杂度 $O(n)$。

---

## 作者：TYxxj (赞：4)

这题明显是一个数位 $dp$，但是由于各个范围都很大，我们需要将它强力优化成线性的。

首先假设没有上下界的限制，考虑 $f_{i}$ 表示所有 i 位数的所有子串和，那么我们就可以尝试递推一下 $f_{i}$ ，方法就是一位一位加入，然后累计上新增的子串的贡献，像这样

$\begin{aligned}
f(i)
& = \sum_{a=0}^{B-1} { f(i-1) + \sum_{j=0}^{i-1} \left( a (Bj)2 + \frac{B^j (B^j - 1)}{2} \right) B^{i-1-j} } \\
& = \sum_{a=0}^{B-1} { f(i-1) + \sum_{j=0}^{i-1} a B^j B^{i-1} + \frac{B^{i-1} (B^j - 1)}{2} } \\
& = \sum_{a=0}^{B-1} { f(i-1) + \frac{B^{i-1}}{2} \sum_{j=0}^{i-1} (2a B^j + B^j - 1) } \\
& = \sum_{a=0}^{B-1} { f(i-1) + \frac{B^{i-1}}{2} \left( 2a \sum_{j=0}^{i-1} B^j + \sum_{j=0}^{i-1} B^j + \sum_{j=0}^{i-1} 1 \right) }
\end{aligned}$

$\sum_{k=1}^N k^2$

这个 $\sum_{j=0}^{i-1} Bj$ 可以前缀和预处理出来，我们记它为 $S_{i}−1$ ，那么上式变为

$$\sum_{a=0}^{B-1} f(i-1)+\frac{B^{i-1}}{2}(2⋅S_{i-1}⋅a+S_{i-1}-i)\cdots\cdots\cdots\cdots\cdots\cdots(1)$$

整理可得（令 $sum(l,r)=\sum_{i=l}^r i=\frac{(l+r)(r-l+1)}{2}$）

$$f(i)=B⋅f(i-1)+\frac{B^{i-1}}{2}(2⋅S_{i-1}⋅sum(0,B-1)+B⋅S_{i-1}-B⋅i)$$

这样就可以线性递推了。

接下来考虑怎样求出 $0∼N$（ $N$ 是一个 $B$ 进制数）的答案。首先将位数更低的那些数的子串和累加起来（注意最高位不能是 $0$ ，如何处理最高位不能是$0$？用下面的方法），然后考虑一位一位确定上界的每一位，并统计所有的子串和。

(1) 式我没有急着展开，就是因为它可以变成更一般的形式，在“一位一位确定上界”的过程中可以用到。
现在由于我们确定了上界的前若干位，我们可以看成后 $i−1$ 位数往前添加的 $a$ 并不是一位数，而是 

$$a\in{\overline{N_{1}N_{2} \cdots N_{k}0},\overline{N_{1}N_{2} \cdots N_{k}1} ,\cdots, \overline{N_{1}N_{2} \cdots N_{k}B^\prime}=A}$$

其中 $B^\prime=Nk+1−1$，Ni 表示 $N$ 从高到低的第 $i$ 位。

那么 (1) 可以变成

$$\sum_{a\in A}f(i-1) + \frac{B^{i-1}}{2}(2⋅S_{i-1}⋅calc(a)+S_{i-1}-i)\cdots\cdots\cdots\cdots\cdots\cdots(2)$$

注意上面的 $a$ 变成了 $calc(a)$ ，它的意思是 $a$ 的所有后缀表示的数的总和。为什么要这样变？我们发现其实这里要统计的就是那些“跨过分界点”的子串，分界点就是 $N$ 的第 $k+1$ 位，这一位之后的是可以任意取的，这一位之前就是 $A$ 中的数。

我们需要把 $(2)$ 变成一个 $O(1)$ 的形式

$$\left\vert A \right\vert⋅f(i-1)+\frac{B^{i-1}}{2}(2⋅S_{i-1}⋅\sum_{a\in A}calc(a)+\left\vert A \right\vert⋅S_{i-1}-\left\vert A \right\vert⋅i)$$

这个 $\sum_{a\in A}calc(a)$ 可以在确定每一位上界的时候通过计算“后缀代表的数的和”得到，就是一个简单的递推。

经过上面的计算，我们还差子串在前 $k$ 位中的没有计算，这一部分只需要在一位一位确定上界的过程中每加入以为就把所有后缀代表的数的和乘上 $B^{i-1}$ 累加即可（$i−1$ 表示后面没有确定的位数，因为后面没有限制所以有 $B^{i-1}$ 这么多个数）。

代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <algorithm>
using namespace std;
#define rep(i, s, t) for(int i = (s), mi = (t); i <= mi; i++)
#define dwn(i, s, t) for(int i = (s), mi = (t); i >= mi; i--)
int read() {
	int x = 0, f = 1; char c = getchar();
	while(!isdigit(c)){ if(c == '-') f = -1; c = getchar(); }
	while(isdigit(c)){ x = x * 10 + c - '0'; c = getchar(); }
	return x * f;
}
#define maxn 100010
#define MOD 20130427
#define inv2 10065214
#define LL long long
int B, pB[maxn], spB[maxn], f[maxn];
LL sum(int l, int r) { return ((LL)(l + r) * (r - l + 1) >> 1) % MOD; }
int n, num[maxn], SufNum[maxn], PreNum[maxn];
int calc() {
	if(n == 1 && !num[1]) return 0;
	int ans = 0;
	rep(i, 1, n - 1) ans += (LL)(B - 1) * f[i-1] % MOD + (LL)pB[i-1] * inv2 % MOD * (2ll * spB[i-1] * sum(1, B - 1) % MOD + (LL)(B - 1) * spB[i-1] % MOD - (LL)(B - 1) * i % MOD + MOD) % MOD, ans %= MOD;
	int suf = 0, tt = 0;
	SufNum[0] = 0;
	rep(i, 1, n) {
		SufNum[i] = SufNum[i-1] + (LL)num[i] * pB[i-1] % MOD;
		if(SufNum[i] >= MOD) SufNum[i] -= MOD;
	}
	rep(i, 0, n) {
		SufNum[i]++;
		if(SufNum[i] >= MOD) SufNum[i] -= MOD;
	}
	PreNum[n+1] = 0;
	dwn(i, n, 1) {
		PreNum[i] = ((LL)PreNum[i+1] * B + num[i]) % MOD;
		if(PreNum[i] >= MOD) PreNum[i] -= MOD;
	}
	dwn(i, n, 1) {
		int x = i == n ? num[i] - 1 : num[i], cnta = (LL)x * (n - i + 1) % MOD, suma = (LL)suf * B % MOD * x % MOD + sum(i == n ? 1 : 0, num[i] - 1) * (n - i + 1) % MOD; if(suma >= MOD) suma -= MOD;
		ans += (LL)x * f[i-1] % MOD + (LL)pB[i-1] * inv2 % MOD * (2ll * spB[i-1] * suma % MOD + (LL)cnta * spB[i-1] % MOD - (LL)cnta * i % MOD + MOD) % MOD; ans %= MOD;
		suf = (LL)suf * B % MOD + (LL)num[i] * (n - i + 1) % MOD; if(suf >= MOD) suf -= MOD;
		ans += (LL)suf * SufNum[i-1] % MOD; if(ans >= MOD) ans -= MOD;
	}
	return ans;
}
int main() {
	B = read();
	pB[0] = spB[0] = 1;
	rep(i, 1, maxn - 1) {
		pB[i] = (LL)pB[i-1] * B % MOD;
		spB[i] = spB[i-1] + pB[i]; if(spB[i] >= MOD) spB[i] -= MOD;
		f[i] = (LL)B * f[i-1] % MOD + (LL)pB[i-1] * inv2 % MOD * (2ll * spB[i-1] * sum(0, B - 1) % MOD + (LL)B * spB[i-1] % MOD - (LL)B * i % MOD + MOD) % MOD;
		if(f[i] >= MOD) f[i] -= MOD;
	}
	int ans = 0;
	n = read(); dwn(i, n, 1) num[i] = read();
	if(n == 1 && num[1] <= 1) ;
	else {
		num[1]--; rep(i, 1, n - 1) if(num[i] < 0) num[i] += B, num[i+1]--;
		if(!num[n]) n--;
		ans = -calc();
	}
	n = read(); dwn(i, n, 1) num[i] = read();
	if(n == 1 && !num[1]) return puts("0"), 0;
	ans += calc();
	ans = (ans % MOD + MOD) % MOD;
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：01190220csl (赞：3)

调了一下午终于调出来了。

常见错误：n,m弄反；取模没取干净；~~毒瘤的出题人要求我们在L>R时仍然直接计算Solve(r)-Solve(l-1)，此时不要自己交换L，r或直接输出0~~

然后我的方法和大家不一样：

设$f_n$表示由所有$n$位$B$进制数的权值和，$cf_n$表示$n$位$B$进制数的个数（均**不能**有前导0）；$g_n$表示由所有$n$位$B$进制数的权值和，$cg_n$表示$n$位$B$进制数的个数（均**可以**有前导0）（先不考虑L和R的限制）；

$cf$和$cg$的递推就不说了，考虑$f$和$g$的计算（下面只有$f$，$g$是差不多的）：

$f_n=\sum\limits_{i=0}^{B-1}\sum\limits_{j=0}^{B-1}\sum\limits_{a\text{是}n-2\text{位的}B\text{进制数}}\Big((B+1)w(\overline{aj})+ni-Bw(a)\Big)$

解释一下：$i$表示最后一位，$j$表示倒数第二位，$w(\overline{aj})$计算子串不含最后一位；$ni$计算最后一位的贡献，$B(w(\overline{aj})-w(a))$计算包含最后一位的选法中其它位的贡献。

带进去是不行的，下面化简(显然$a$有$cf_{n-2}$种不同的取值：

$f_n=\sum\limits_{i=0}^{B-1}\sum\limits_{j=0}^{B-1}\Big(cf_{n-2}ni+(B+1)\sum\limits_{a\text{是}n-2\text{位的}B\text{进制数}}\cdot w(\overline{aj})-Bf_{n-2}\Big)$

$\quad=\sum\limits_{i=0}^{B-1}\Big(B\cdot cf_{n-2}ni+(B+1)f_{n-1}-B^2\cdot f_{n-2}\Big)$

$\quad=\frac{B(B-1)}{2}\cdot cf_{n-1}\cdot n+B(B+1)f_{n-1}-B^3\cdot f_{n-2}$

明显比原来好多了，可以推出$f$了（其实$g$和$f$的差别就是把$cf$改成了$cg$）。

接下来，我们设我们考虑的区间为$[1,n]$，$n$在$B$进制下有$a$位，$n_a(a=1,2,\cdots,n)$位$n$从左数起第$a$位。

如果这个数不满$a$位，则总数显然为$\sum_{i=1}^{a-1}f_i$

如果第一位不为$n_1$，则总贡献为：

$$\sum_1^{n_1-1}(S_ni\cdot cg_{n-1}+2g_{n-1}-Bg_{n-2})=\frac{n_1(n_1-1)}{2}\cdot S_ncg_{n-1}+(n_1-1)(2g_{n-1}+Bg_{n-2})$$

（$S_n$表示$B$进制下$\begin{matrix}\underbrace{11\cdots1}\\n\text{个}1\end{matrix}$，下同）

如果第一位为$n_1$，则这一位贡献为:

$$n_1\cdot S_ncg_{n-1}$$

然后递归（其实可以递推）计算$n$少了第一位的总贡献乘以2减去$n$少了前两位的总贡献（此时可以有前导0，因此上一种情况$(n_1-1)$应改为$n_1$）。（显然需要记忆化，或者递推出从左侧第$i$位对答案的总贡献为计算结果的$i$倍，然后递推）。

鉴于我的代码实在太丑，就不放上了。

---

## 作者：_Cyan_ (赞：2)

### 题目概述
- 给你 $L$ 和 $R$ 这两个 $B$ 进制的数，让你求 $[L,R]$ 中所有数的子串之和，答案取模 $20130427$。
- $1\le N,M\le 10^{5}, 2\le B \le 10^{5}$

## 分析
首先我们先思考**一个数**中**每个数字**所做的贡献，设 $a_i$ 表示从左往右数第 $i$ 位，$len$ 表示这个数有几位，那我们便可以得到这么一个式子：

$$ W\left ( a_i \right ) = i \times a_i \times  \sum\limits_{j=0}^{len-i} B^{j}$$

然后我们就可以发现我们可以前缀和优化最后那一部分，我们设 $sum_i$ 表示从 $0$ 到 $i$ 的 $B$ 的阶乘之和。

接着我们再看题，我们明显可以将求 $[L,R]$ 改为 $[0,R]-[0,L]+L$。于是我们便尝试解决子问题：

**已知一个数 $x$ 让你求 $[0,x]$ 中所有数的子串之和。**

我们借助数位 dp 的思想，将这个问题分类讨论：

- 位数 $len$ 小于 $lenx$ 的数。

- 位数 $len$ 等于 $lenx$ 并且最高位小于 $x$ 的最高位的数。

- 位数 $len$ 等于 $lenx$ 并且从最高位开始有 $i$ 位与 $x$ 中的相应位置的数相同。

**为了方便下面的讲解，设 $S$ 为 $0$ 到 $B-1$ 之和，即这一位所有可以选的数之和。** 


---

对于第一个问题，当位数 $i$ 确定时，我们又可以得到一个**式子**表示在位数位 $i$ 的情况下所得的答案:

$$value \left ( len \right ) =  \left ( \sum\limits_{i=1}^{i=len} i \times S \times sum_{len-i} \times \left ( B-1 \right ) \times B^{len-2} \right ) + sum_{len-1} \times S \times B^{len-2}$$

为什么有带 $B$ 的那一串呢？ 这是因为我们需要除了这一位，其他位统计出现的次数，$B-1$ 是因为最高位不能为 $0$，而当枚举最高位的时候，其他位都可以取 $[0,B-1]$ 这 $B$ 个数，故还要在外面加最高位多出来的数，我们再把这个式子进行化简:

$$value \left ( len \right ) =  \left ( S \times \left ( B-1 \right ) \times B^{len-2} \times \sum\limits_{i=1}^{i=len} i  \times sum_{len-i} \right ) + sum_{len-1} \times S \times B^{len-2}$$

这时我们就可以明显发现那一串需要从 $1$ 到 $len$ 枚举的式子可以进行预处理，至于如何预处理，读者可以自行思考一下，那么我们就又得到了一个 $c_i$，它表示从 $1$ 到 $i$ 对那一个式子的预处理。

这样我们就解决了第一个问题，时间复杂度为 $O ( n ) $。


------------
对于第二个问题，如果理解了第一个问题是如何解决的，那也应该可以很轻松就想出来，不过就是把其他位上的答案先算出来再加上最高位的答案。


------------
接着就是最后一个子问题啦，其实也很简单，我们只需要枚举从最高位开始，现在有 $i$ 位和 $x$ 对应位置的值相同，我们分成以下 $3$ 个部分：

- 从最高位开始与 $x$ 对应位置相同的所有数的答案。

- 当前第 $i$ 位可得到的答案。

- 剩余的位置可得的答案。

然后你就可以愉快地切掉这道题啦。


------------
## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1; c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48); c=getchar();}
	return x*f;
}
const int N=1e5+5,mod=20130427;
int l,r,b,a[N],sum[N],base[N],c[N],dp[N];
inline int solve(int n){
	for(int i=1;i<=n;i++) a[i]=read();
	base[0]=sum[0]=c[0]=1;
	if(n==1){
		int res=0;
		for(int i=1;i<=a[1];i++) res=(res+i)%mod;
		return res;
	}
	for(int i=1;i<=n;i++) base[i]=(base[i-1]*b)%mod,sum[i]=(sum[i-1]+base[i])%mod;
	for(int i=1;i<=n;i++) c[i]=(c[i-1]+sum[i])%mod;
	for(int i=1;i<=n;i++) c[i]=(c[i-1]+c[i])%mod;//预处理 
	int s=(b-1)*b/2;
	s%=mod;
	dp[0]=0,dp[1]=s;
	int res=0;
	for(int i=2;i<n;i++) dp[i]=(c[i-1]*s%mod*base[i-2]%mod*(b-1)+sum[i-1]*base[i-2]%mod*s%mod)%mod;//第一个问题 
	for(int i=1;i<n;i++) res=(res+dp[i])%mod;
	int num=(c[n-1]-sum[n-1]+mod)%mod,k=(a[1]-1)*a[1]/2;
	k%=mod;
	res=(res+(a[1]-1)*num%mod*s%mod*base[n-2]%mod+k*base[n-1]%mod*sum[n-1]%mod)%mod;//第二个问题 
	int x=(a[1]*sum[n-1])%mod;
	//第三个问题 
	for(int i=2;i<=n;i++){
		num=(num-sum[n-i]*i%mod+mod)%mod;
		//1
		int q=x*base[n-i]%mod*a[i]%mod;
		//2
		int su=((a[i]-1)*a[i]/2)%mod;
		int mid=su*base[n-i]%mod*sum[n-i]%mod*i%mod;
		//3
		int fin=a[i]*num%mod*s%mod*base[n-i-1]%mod;
		res=(res+q%mod+mid%mod+fin%mod)%mod; 
		x=(x+i*a[i]%mod*sum[n-i]%mod)%mod;
	}
	res=(res+x)%mod;
	return res;
}
signed main(){
	b=read(),l=read();
	int ansl=solve(l);
	int bb=0;
	for(int i=1;i<=l;i++){
		bb=(bb+i*a[i]%mod*sum[l-i]%mod)%mod;
	}
	ansl=(ansl-bb+mod)%mod;
	r=read();
	int ansr=solve(r);
	cout<<(ansr-ansl+mod)%mod<<'\n';
}
```

---

## 作者：complete_binary_tree (赞：1)

[原题传送门](https://www.luogu.com.cn/problem/P3281)

---

考虑对于单个数 $x$ 的 $\text{dp}$。

设 $f(i)$ 为从大到小第 $i$ 位的答案。

那么 $f(i)$ 就等于 $f(i - 1)$ 加上第 $i$ 位的贡献。

显然第 $i$ 位的贡献都包含第 $i$ 位，所以都是后缀。

设 $i$ 位的后缀贡献为 $g(i)$。可以发现，$g(i)$ 包含 $g(i - 1)$；又因为要将 $a_i$ 放在前面每一个后缀的后面，还可以新开一个后缀，所以 $a_i$ 的贡献就是 $i$。

所以，$g(i) = g(i - 1) \cdot B + a_i \cdot i$。

所以，$f(i) = f(i - 1) + g(i)$。

我们可以暴力每一个数，时间复杂度 $O((r - l) \log_B r)$，能拿到 $20$ 分。

如果使用记忆化搜索，那么可以做到 $O(nB)$，拿到 $50$ 分。

---

考虑 $O(n)$ 递推。

我们可以求出 $[1,r]$ 的答案，减去 $[1,l]$ 的答案，再加上 $l$ 的答案。

$l$ 的答案可以用上面的方法 $O(B)$ 求出，接下来我们看 $[1,a]$ 的答案。

我们要维护的：

- $f(i,0/1)$：前 $i$ 位的答案和。

- $g(i,0/1)$：前 $i$ 位的后缀贡献。

- $l(i,0/1)$：前 $i$ 位的所有数长度之和。

- $n(i,0/1)$：前 $i$ 位数的个数。

这里的“数”指的是小于 $a$ 的，且没有前导 $0$ 的数个数，$0/1$ 中 $1$ 表示这一位顶到了上限，$0$ 表示没有顶到。

---

先看 $n$ 的转移。

$n(i,1) = 1$，因为顶到上限的只有一个数。

$n(i,0)$ 分三段贡献：

- $n(i - 1,1)$ 的贡献：此时这一位不能顶到上界，所以只能取 $0,1,2,\dots,a_i-1$ 一共 $a_i$ 个数，所以有 $n(i - 1,1) \cdot a_i$ 的贡献。

- $n(i - 1,0)$ 的贡献：此时这一位没有限制，所以可以取 $0,1,2,\dots,B - 1$ 一共 $B$ 个数，所以有 $n(i - 1,0) \cdot B$ 的贡献。

- 还有，我们可以新建一个数，但是由于这个数不能有前导 $0$，所以只有 $B - 1$ 种选项（$1,2,\dots,B-1$）。

把上面三个加起来即可。

---

再看 $l$ 的转移。

$l(i,1)$ 的长度肯定是 $l(i - 1,1) + n(i - 1,1)$，因为它没得选，只有一个数，不能新增。

$l(i,0)$ 也分三段贡献：

- 首先，来自上一位顶到上界的贡献。

  由于上一位已经顶到了上界，所以这一位只有 $a_i$ 种选择。

  而每个串长度会 $+1$，所以先让所有串长度 $+1$，再乘上 $a_i$ 种选择。

  具体是 $(l(i - 1,1) + n(i - 1,1)) \cdot a_i$。

- 然后，来自上一位没顶到上界的贡献。

  与上面的情况类似，不过可以有 $B$ 种选择。

  具体是 $(l(i - 1,0) + n(l - 1,0)) \cdot B$。

- 最后，这一位新建的数的贡献。

  新建了 $B - 1$ 个数，长度都为 $1$，所以贡献 $B - 1$。

然后把这些全部加起来即可。

---

继续来看 $g$ 的转移。

$g(i,1)$：此时只有一个数，那么直接照搬前面的方法即可，即 $g(i - 1,1) \cdot B + (l(i - 1,1) + n(i - 1,1)) \cdot a_i$。（其实把 $l(i - 1,1) + n(i - 1,1)$ 换成 $i$ 也没什么问题，不过这样比较统一）

$g(i,0)$ 还是分为三部分：

- 首先，来自上一位顶到上界的贡献。

  看看对于单个的递推式：$g(i) = g(i - 1) \cdot B + i \cdot a_i$。
  
  我们发现这个转移其实是 $前面的答案 \times B + a_i \times 所有数的长度之和$。
  
  由于这一个位置有 $a_i$ 种选择，所以是 $前面的答案\times B \times 这个位置的选择数（a_i） + 所有选择数的贡献（其实就是这些数的和） \times 所有数的长度之和$。
  
  转化一下就是 $g(i - 1,1) \cdot B \cdot a_i + \frac{a_i(a_i - 1)}{2} \cdot (l(i - 1,1) + n(i - 1,1))$。
  
  其中，$0 + 1 + 2 + \dots + (a_i - 1)$ 的答案是 $\frac{a_i(a_i - 1)}{2}$，长度之和不能用 $l(i,1)$ 因为这会算重（因为把这一位的贡献也算进去了）。
  
- 其次，来自上一位没顶到上界的贡献。

  本质上也一样，就是 $g(i - 1,0) \cdot B \cdot B + \frac{B(B - 1)}{2} \cdot (l(i - 1,0) + n(i - 1,0))$，读者可以自行尝试推导。
  
- 最后，来自这一位的贡献。

  这一位也是可以新建数的，可以新建 $B - 1$ 个数，它们的和也是 $\frac{B(B - 1)}{2}$。
  
然后把它们加起来。

---

最后是 $f$ 的贡献。

$f(i,1) = f(i - 1,1) + g(i, 1)$，因为顶到上界的只有一个数。

$f(i,0) = f(i - 1,0) \cdot B + f(i - 1,1) \cdot a_i + g(i,0)$，因为前面的答案（没顶到/顶到上界）分别在这个位置能选择 $B/a_i$ 个数，然后加上这一位的贡献。

最后的答案就是 $f(len,0) + f(len,1)$，其中 $len$ 是 $a$ 的长度。

---

这样，我们就把递推压到了 $O(n)$，可以拿到 $100$ 分。

此外，初始值、$i = 1$ 时的一些特殊情况也需要注意，具体在代码中呈现，读者可以先行思考。

如文章中有错误之处可在评论区中指出，谢谢您的纠正！

代码如下：

```cpp
//时刻注意取模！
//还有，运算中可能会爆int，可以1ll*，或全开long long
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 5, mod = 20130427;

int B, f[N][2], g[N][2], l[N][2], n[N][2], nn, mm, a[N], b[N];

//1到p
int solve1( int* p, int len ){
    //初始值，本来就有（顶到上界的）一个数
    n[0][1] = 1;
    for( int i = 1; i <= len; ++i ){
        //在第0位到第1位的转移中，只有上界才能转移，不能通过B-1转移（可以理解为0的上界是0）
        int B = ((i == 1) ? 0 : (::B));

        //n的转移
        n[i][1] = 1;
        n[i][0] = 1ll * n[i - 1][1] * p[i] % mod//上一个顶到了
                + 1ll * n[i - 1][0] * B % mod   //上一个没顶到   
                + ( B - 1 ) % mod;              //这一位可以选择的数
        n[i][1] %= mod, n[i][0] %= mod;

        //l的转移
        l[i][1] = l[i - 1][1] + n[i - 1][1];
        l[i][0] = 1ll * ( l[i - 1][1] + n[i - 1][1] ) * p[i] % mod  //上一个顶到了      
                + 1ll * ( l[i - 1][0] + n[i - 1][0] ) * B % mod     //上一个没顶到
                + ( B - 1 ) % mod;                                  //这一位可选择的数
        l[i][1] %= mod, l[i][0] %= mod;

        //g的转移
        g[i][1] = 1ll * g[i - 1][1] * B % mod + 1ll * p[i] * l[i][1] % mod;
        g[i][0] = 1ll * g[i - 1][1] * B % mod * p[i] % mod + 1ll * ( l[i - 1][1] + n[i - 1][1] ) % mod * ( 1ll * p[i] * ( p[i] - 1 ) / 2 % mod ) % mod  //上一个顶到了
                + 1ll * g[i - 1][0] * B % mod * B % mod + 1ll * ( l[i - 1][0] + n[i - 1][0] ) % mod * ( 1ll * B * ( B - 1 ) / 2 % mod ) % mod           //上一个没顶到
                + 1ll * B * (B - 1) / 2 % mod;                                                                                                          //这一个的贡献
        g[i][1] %= mod, g[i][0] %= mod;

        //f的转移
        f[i][1] = f[i - 1][1] + g[i][1];
        f[i][0] = 1ll * f[i - 1][0] * B % mod   //上一个没顶到
                + 1ll * f[i - 1][1] * p[i] % mod//上一个顶到了
                + g[i][0];                      //这一个的贡献
        f[i][1] %= mod, g[i][1] %= mod;
    }
    return ( f[len][0] + f[len][1] ) % mod;
}

int ff[N], gg[N];

//对单个数
int solve2( int* p, int len ){
    for( int i = 1; i <= len; ++i ){
        gg[i] = 1ll * gg[i - 1] * B % mod + 1ll * p[i] * i % mod;
        gg[i] %= mod;
        ff[i] = ff[i - 1] + gg[i];
        ff[i] %= mod;
    }
    return ff[len];
}

void work(){
    scanf( "%d%d", &B, &nn );
    for( int i = 1; i <= nn; ++i ) scanf( "%d", &a[i] );
    scanf( "%d", &mm );
    for( int i = 1; i <= mm; ++i ) scanf( "%d", &b[i] );
    //并不需要对r<l进行特殊的处理，直接做就行了
    printf( "%d\n", ( ( solve1( b, mm ) - solve1( a, nn ) + solve2( a, nn ) ) % mod + mod ) % mod );
}

int main(){
    work();
    return 0;
}
```

---

## 作者：Unnamed114514 (赞：0)

考虑算每一位的贡献，容易发现第 $i$ 位的贡献可以递推算。

转移的时候只关心后面有多少位，并不关心具体值，直接前缀和加一下即可。

但是注意到这个位置的贡献还根前面有多少位有关，而这个显然是不能放状态里的，所以我们转移的时候需要把每个位置的贡献也转移回去。

转移比较繁琐，需要同时维护方案数/贡献/答案，但是还是比较好想的。

```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define int long long
using namespace std;
const int N=1e5+5,mod=20130427;
int B,n,m,a[N],b[N],c[N],pw[N];
bool vis[N];
struct node{ int a,b,c; }dp[N];
node dfs(int now,bool flg1,bool flg2){
    if(!now) return node({0,0,1});
    if(flg1&&!flg2&&vis[now]) return dp[now];
    node res=node({0,0,0});
    int up=(flg1?B-1:c[now]);
    if(flg2) res.a=dfs(now-1,flg1|c[now],1).a;
    else{
        node p=dfs(now-1,flg1|c[now],0);
        res.a=(res.a+p.b+p.a)%mod;
        res.b=(res.b+p.b)%mod;
        res.c=(res.c+p.c)%mod;
    }
    if(up){
        node p=dfs(now-1,1,0);
        res.a=(res.a+up*(up-1)/2*pw[now-1]%mod*p.c%mod+p.b*(up-1)+p.a*(up-1))%mod;
        res.b=(res.b+up*(up-1)/2*pw[now-1]%mod*p.c%mod+p.b*(up-1))%mod;
        res.c=(res.c+p.c*(up-1))%mod;
        p=dfs(now-1,flg1,0);
        res.a=(res.a+up*pw[now-1]%mod*p.c%mod+p.b+p.a)%mod;
        res.b=(res.b+up*pw[now-1]%mod*p.c%mod+p.b)%mod;
        res.c=(res.c+p.c)%mod;
    }
    if(flg1&&!flg2){
        dp[now]=res;
        vis[now]=1;
    }
    return res;
}
int solve(int n,const int *a){
    memcpy(c,a,sizeof(c));
    reverse(c+1,c+n+1);
    return dfs(n,0,1).a;
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    memset(dp,-1,sizeof(dp));
    cin>>B;
    cin>>m;
    for(int i=1;i<=m;++i) cin>>b[i];
    cin>>n;
    for(int i=1;i<=n;++i) cin>>a[i];
    pw[0]=1;
    for(int i=1,sum=1,s=1;i<=max(n,m);++i){
        s=s*B%mod;
        pw[i]=(pw[i-1]+s)%mod;
    }
    if(m==1&&!b[1]){
        cout<<solve(n,a)<<endl;
        return 0;
    }
    for(int i=m;i;--i)
        if(b[i]){
            --b[i];
            break;
        } else b[i]=B-1;
    cout<<(solve(n,a)-solve(m,b)+mod)%mod<<endl;
    return 0;
}
```

---


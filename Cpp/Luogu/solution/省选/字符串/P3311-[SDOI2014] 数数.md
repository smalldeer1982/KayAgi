# [SDOI2014] 数数

## 题目描述

我们称一个正整数 $x$ 是幸运数，当且仅当它的十进制表示中不包含数字串集合 $s$ 中任意一个元素作为其子串。例如当 $s = \{22, 333, 0233\}$ 时，$233$ 是幸运数，$2333$、$20233$、$3223$ 不是幸运数。给定 $n$ 和 $s$，计算不大于 $n$ 的幸运数个数。

答案对 $10^9 + 7$ 取模。

## 说明/提示

#### 样例 1 解释

除了 $3, 13, 2, 12, 20, 14$ 以外，不大于 $20$ 的整数都是幸运数字。

#### 数据规模与约定

对于全部的测试点，保证：

$1 \leq n < 10^{1201}$，$1 \leq m \leq 100$，$1 \leq \sum_{i = 1}^m |s_i| \leq 1500$，$\min_{i = 1}^m |s_i| \geq 1$，其中 $|s_i|$ 表示字符串 $s_i$ 的长度。$n$ 没有前导 $0$，但是 $s_i$ 可能有前导 $0$。

## 样例 #1

### 输入

```
20
3
2
3
14```

### 输出

```
14```

# 题解

## 作者：George1123 (赞：35)

**博客中看：[题解-\[SDOI2014\]数数](https://blog.csdn.net/KonnyWen/article/details/104269176)**

### [\[SDOI2014\]数数](https://www.luogu.com.cn/problem/P3311)

这题的前置知识是AC自动机和dp，前置题目是 **[\[JSOI2007\]文本生成器](https://www.luogu.com.cn/problem/P4052)**，前置题目我写的题解 **[题解-\[JSOI2007\]文本生成器](https://blog.csdn.net/KonnyWen/article/details/104238511)**。我的讲解假设你做过上面那道题。

这题比上面那题多个条件，我因此多调了 $3$ 个小时。多的条件：答案要不大于整数 $n$。所以AC自动机部分同上，改变dp部分。

**解：**$dp[i][j][k]$ 表示文本串（幸运数）长度为 $i$，结尾是AC自动机上的节点 $j$，$k$ 表示这个文本串下一个字符是否受 $n$ 某个数位大小的限制（如果受限制，$k=1$；否则，$k=0$）。$mk[i]$ 表示 $i$ 这个AC自动机上节点是否为某个不幸运的数结尾。

仔细读题会发现：**模式串中含有 $0$ 前置，而文本串不能以 $0$ 开头**。所以有（所有数组下标从 $1$ 开始，$1\le n[1]\le 9$，因为 $ch[1][i]$ 会有重复所以用 $++$ 而非 $=1$）：

$$dp[1][ch[1][i]][0]++(1\le i<n[1],mk[ch[1][i]]!=1)$$

然后如果上式 $i$ 取 $n[1]$，那么这个字符串的下一位就会受到 $n[2]$ 大小的限制，所以有：

$$dp[1][ch[1][n[1]]][1]++(mk[ch[1][n[1]]]!=1)$$

综上，有代码：

```cpp
for(int i=1;i<=w[1]-'0';i++)
	if(!mk[ch[1][i]])//不能选到不幸运的子串
		(f[1][ch[1][i]][i==w[1]-'0']+=1)%=mod; //Orz
```

 为了避免算上首位为 $0$ 的文本串，上面的代码没有 $dp[1][ch[1][0]][0]++$。为了计算那些位数小于 $n$ 的文本串，则有：

$$dp[i][ch[1][j]][0]++(2\le i\le \texttt{length of }n,1\le j\le 9,mk[ch[1][j]]!=1)$$

为了防止 $\color{#333399}\texttt{MLE}$，dp用滚动数组，所以有代码：

```cpp
for(int i=2;i<=m;i++){
	memset(f[i&1],0,sizeof f[i&1]);//滚动数组必须清空
	for(int j=1;j<=9;j++)
		if(!mk[ch[1][j]])
			(f[i&1][ch[1][j]][0]+=1)%=mod;//Orz
```
初始化完了，重点就来了——递推公式。如果某个文本串合法，那么在它后面加一个字符，如果这个文本串还是 $\le n$ ，并且不包含不幸运的子串，那么它就是合法的。

转化为dp递推式（$cnt$ 表示AC自动机节点个数）：

$$dp[i][ch[j][k]][0]+=dp[i-1][j][0]$$
$$(1\le i\le\texttt{length of }n,1\le j\le  cnt,mk[ch[j][k]]!=1,\color{red}0\color{black}\le k\le 9)$$
>这里是递推，所以这就相当于在求一个数中间的一个数位，所以可以取 $0$

$$dp[i][ch[j][k]][0]+=dp[i-1][j][1]$$
$$(1\le i\le\texttt{length of }n,1\le j\le  cnt,mk[ch[j][k]]!=1,\color{red}0\le k<n[i]\color{black})$$
>除非取的文本串对 $n$ 位位紧逼，要不然下一位就不受 $n$ 数位大小的限制。

$$dp[i][ch[j][n[i]]][1]+=dp[i-1][j][1]$$
$$(1\le i\le\texttt{length of }n,1\le j\le  cnt,mk[ch[j][n[i]]]!=1)$$

>取的文本串对 $n$ 位位紧逼。

代码：

```cpp
for(int j=1;j<=cnt;j++){
	if(mk[j]) continue;
	if(f[(i-1)&1][j][0])
		for(int c=0;c<=9;c++)
			if(!mk[ch[j][c]])
				(f[i&1][ch[j][c]][0]+=f[(i-1)&1][j][0])%=mod;
	if(f[(i-1)&1][j][1])
		for(int c=0;c<=w[i]-'0';c++)
			if(!mk[ch[j][c]])
				(f[i&1][ch[j][c]][c==w[i]-'0']+=f[(i-1)&1][j][1])%=mod;
}
```
最后答案为 $ans$，就有：

$$ans=\sum\limits ^{cnt}_{i=1}dp[\texttt{length of }n][i][0]+dp[\texttt{length of }n][i][1]$$

如果你懂了，蒟蒻就放dp代码了：

```cpp
void dp(){
	for(int i=1;i<=w[1]-'0';i++)
		if(!mk[ch[1][i]])
			(f[1][ch[1][i]][i==w[1]-'0']+=1)%=mod; //Orz
	for(int i=2;i<=m;i++){
		memset(f[i&1],0,sizeof f[i&1]);
		for(int j=1;j<=9;j++)
			if(!mk[ch[1][j]])
				(f[i&1][ch[1][j]][0]+=1)%=mod;//Orz
		for(int j=1;j<=cnt;j++){
			if(mk[j]) continue;
			if(f[(i-1)&1][j][0])
				for(int c=0;c<=9;c++)
					if(!mk[ch[j][c]])
						(f[i&1][ch[j][c]][0]+=f[(i-1)&1][j][0])%=mod;
			if(f[(i-1)&1][j][1])
				for(int c=0;c<=w[i]-'0';c++)
					if(!mk[ch[j][c]])
						(f[i&1][ch[j][c]][c==w[i]-'0']+=f[(i-1)&1][j][1])%=mod;
		}
	}
	for(int i=1;i<=cnt;i++)
		if(!mk[i]) (((ans+=f[m&1][i][0])%=mod)+=f[m&1][i][1])%=mod;
}
```
整体代码（dp+AC自动机）：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int M=1210;
const int L=1510;
const int mod=1e9+7;
class Trie{
public:
	int ch[L][10],cnt;
	bool mk[L];
	Trie(){cnt=1;}
	void insert(char*s){
		int n_junior=strlen(s+1),p=1;
		for(int i=1;i<=n_junior;i++){
			int c=s[i]-'0';
			if(!ch[p][c]) ch[p][c]=++cnt;
			p=ch[p][c];
		}
		mk[p]=1;
	}
};
int n,m,f[2][L][2],ans;
char w[M],s[L];
class Acam:public Trie{
public:
	int fa[L];
	void build(){
		for(int i=0;i<=9;i++) ch[0][i]=1;
		queue<int> q;
		while(q.size()) q.pop(); //我因为没清零WA了5次
		q.push(1);
		while(q.size()){
			int x=q.front();q.pop();
			mk[x]|=mk[fa[x]];
			for(int c=0;c<=9;c++)
				if(ch[x][c]){
					fa[ch[x][c]]=ch[fa[x]][c];
					q.push(ch[x][c]);
				} else ch[x][c]=ch[fa[x]][c];
		}
	}
	void dp(){
		for(int i=1;i<=w[1]-'0';i++)
			if(!mk[ch[1][i]])
				(f[1][ch[1][i]][i==w[1]-'0']+=1)%=mod;
		for(int i=2;i<=m;i++){
			memset(f[i&1],0,sizeof f[i&1]);
			for(int j=1;j<=9;j++)
				if(!mk[ch[1][j]])
					(f[i&1][ch[1][j]][0]+=1)%=mod;
			for(int j=1;j<=cnt;j++){
				if(mk[j]) continue;
				if(f[(i-1)&1][j][0])
					for(int c=0;c<=9;c++)
						if(!mk[ch[j][c]])
							(f[i&1][ch[j][c]][0]+=f[(i-1)&1][j][0])%=mod;
				if(f[(i-1)&1][j][1])
					for(int c=0;c<=w[i]-'0';c++)
						if(!mk[ch[j][c]])
							(f[i&1][ch[j][c]][c==w[i]-'0']+=f[(i-1)&1][j][1])%=mod;
			}
		}
		for(int i=1;i<=cnt;i++)
			if(!mk[i]) (((ans+=f[m&1][i][0])%=mod)+=f[m&1][i][1])%=mod;
	}
}t;
int main(){
	scanf("%s\n%d",w+1,&n),m=strlen(w+1);
	for(int i=1;i<=n;i++)
		scanf("%s",s+1),t.insert(s);
	t.build(); t.dp();
	printf("%d\n",ans);
	return 0;
}
```
**祝大家学习愉快！**



---

## 作者：JK_LOVER (赞：29)

写在前面的，基本所有人都是一个写法。而且有些还过不了$Hack$ 数据。其实对于数位 $dp$ 一种普遍的应该是记忆化搜索，已经过 $Hack$ 。 [更差的阅读体验。](https://www.luogu.com.cn/blog/xzc/solution-p3311)
# 分析
我们把数字考虑为字符串，那么现在我们就是要求出有多少方案满足 $\forall S_i$ 没有出现在 $T$ 串中。这个非常类似 [这道题](https://www.luogu.com.cn/problem/P4052) 只是将必须出现改为都没有出现。

- 关于这道题，因为我们要对子串考虑，比较自然考虑到 $Trie$ 树和 $ACAM$ 。由于 $Trie$ 并不能很好处理失配的问题，那么考虑 $AC$ 自动机。我们定义 $end_i = 0/1$ 其中 $end_i=1$ 表示，该节点为一个 $S_i$ 的结尾，那么当我们转移到这个点的时候是非法的。但是在 $AC$ 自动机上不知每个串的插入的地方是非法的，如果串 $A$ 是 $B$ 的子串，而且 $end_A = 1$ ，那么 $end_B = 1$ 。而 $fail$ 指针指向的就是一个串的最长后缀，所以我们才考虑到 $end_A  = end_{fail_A} | end_A $ 。

- 那么现在我们处理了子串的合法性，定义 $f(i,j)$ 为已经考虑长度为 $i$ ，当前节点为 $j$ 的合法答案，那么 $ans =\sum_{i\in ACAM} f(|m|,i)$ ，现在考虑我们构成的串 $T$ 在数值上要小于等于 $m$ 。那么这个可以很好的数位 $dp$ 。从而限制我们转移。细节还是见代码，要注意没有前导零的时候不能转移到 $Trie$ 上的其他节点，因为这个时候我们的串还没开始。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1600,mod = 1e9 + 7;
int f[1300][N][2][2],fail[N],ch[N][10],val[N],size;
int n;
char m[1300];
void insert(char *S) {
	int len = strlen(S + 1),u = 0;
	for(int i = 1;i <= len;i++) {
		int c = (S[i] - '0');
		if(!ch[u][c]) ch[u][c] = ++size;
		u = ch[u][c];
	}val[u] |= 1;
}
void build() {
	queue<int> Q;
	for(int i = 0;i < 10;i++) if(ch[0][i]) Q.push(ch[0][i]);
	while(!Q.empty()) {
		int x = Q.front();Q.pop();
		for(int i = 0;i < 10;i++) {
			int y = ch[x][i];
			if(y) {fail[ch[x][i]] = ch[fail[x]][i];val[y] |= val[fail[y]];Q.push(y);}
			else ch[x][i] = ch[fail[x]][i];
		}
	}
}
void inc(int &x,int y) {x = (x + y) % mod;}
int dfs(int now,int pos,int limit,int st) {
	if(now <= 0) return !val[pos];
	if(val[pos]) return 0;
	if(f[now][pos][limit][st] != -1) return f[now][pos][limit][st]; 
	int x = limit ? (m[now] - '0') : 9,res = 0;
	for(int i = 0;i <= x;i++) {
		inc(res, dfs(now - 1,(st && (i == 0)) ? 0 : ch[pos][i],(limit && (i + '0' == m[now])),(st && (i == 0))) );
	}
	return f[now][pos][limit][st] = res;
}
int main() {
	scanf("%s%d",m + 1,&n);
	int len = strlen(m + 1);
	for(int i = 1;i <= n;i++) {
		static char S[N];scanf("%s",S + 1);insert(S);
	}
	build();reverse(m + 1,m + 1 + len);
	memset(f,-1,sizeof(f));
	int ans = dfs(len,0,1,1);inc(ans,mod - 1);
	cout << ans << endl;return 0;
}
```


---

## 作者：Ebola (赞：10)


对给定的若干个串建立AC自动机。对自动机上的每个节点，维护一个标记，表示在fail树上，它到根的路径中是否存在词尾节点。（词尾节点即每次插入一个串时最后到达的那个节点）

设$f_{i,j,0/1}$表示考虑到n的第i位（从高到低），当前在自动机的j号节点，目前为止 没有挨着 / 正在挨着 上界时，答案是多少。设ch(x,c)表示x号节点的c号子节点，于是可以写出转移：

1. 若当前没有挨着上界，前一位不挨着上界，则：$f_{i-1,p,0}\longrightarrow f_{i,ch(p,1\sim 9),0}$
2. 若当前没有挨着上界，前一位挨着上界，则：$f_{i-1,p,1}\longrightarrow f_{i,ch(p,1\sim upper_i-1),0}$
3. 若当前要挨着上界，那前一位必然要挨着上界，则 ：$f_{i-1,p,1}\longrightarrow f_{i,ch(p,upper_i),1}$

最后的答案显然就是：$\sum\limits_{i=0}^{tot}f_{n,i,0}+f_{n,i,1}$

经过尝试，使用滚动数组会大大提升运行速度，可以快20ms左右！

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1510;
const int ha=1000000007;
int ch[N][10],fail[N],tot=0;
int f[2][N][2],m,nlen;
bool fuck[N];
char n[N];

void insert(char* _begin,char* _end)
{
    int o=0;
    for(;_begin!=_end;_begin++)
    {
        int t=*_begin-'0';
        if(!ch[o][t]) ch[o][t]=++tot;
        o=ch[o][t];
    }
    fuck[o]=1;
}

void getfail()
{
    queue<int> q;q.push(0);
    while(!q.empty())
    {
        int u=q.front();q.pop();
        fuck[u]|=fuck[fail[u]];
        for(int i=0;i<10;i++)
            if(ch[u][i])
            {
                if(u) fail[ch[u][i]]=ch[fail[u]][i];
                q.push(ch[u][i]);
            }
            else ch[u][i]=ch[fail[u]][i];
    }
}

inline void add(int &x,const int &y){x=(x+y>=ha)?x+y-ha:x+y;}

int xixihaha()
{
    int ans=0,k=0;
    for(int i=1;i<n[0]-'0';i++)
        add(f[k][ch[0][i]][0],1);
    add(f[k][ch[0][n[0]-'0']][1],1);
    for(int i=1;i<nlen;i++,k^=1)
    {
        memset(f[k^1],0,sizeof(f[k^1]));
        for(int j=1;j<10;j++)
            add(f[k^1][ch[0][j]][0],1);
        for(int p=0;p<=tot;p++)
        {
            if(fuck[p]) continue;
            if(f[k][p][0])for(int j=0;j<10;j++)
            {
                if(fuck[ch[p][j]]) continue;
                add(f[k^1][ch[p][j]][0],f[k][p][0]);
            }
            if(f[k][p][1])for(int j=0;j<n[i]-'0';j++)
            {
                if(fuck[ch[p][j]]) continue;
                add(f[k^1][ch[p][j]][0],f[k][p][1]);
            }
            if(fuck[ch[p][n[i]-'0']]) continue;
            add(f[k^1][ch[p][n[i]-'0']][1],f[k][p][1]);
        }
    }
    for(int i=0;i<=tot;i++)
    {
        if(fuck[i]) continue;
        add(ans,f[k][i][0]);
        add(ans,f[k][i][1]);
    }
    return ans;
}

int main()
{
    char s[N];
    scanf("%s%d",n,&m);
    nlen=strlen(n);
    for(int i=0;i<m;i++)
    {
        scanf("%s",s);
        int len=strlen(s);
        insert(s,s+len);
    }
    getfail();
    int ans=xixihaha();
    printf("%d\n",ans);
    return 0;
}
```



---

## 作者：wcyQwQ (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P3311)

[可能更好的阅读体验](https://chenyu-w.github.io/2022/07/07/P3311%E6%95%B0%E6%95%B0/)

## 前言

ACAM + 数位 DP 好题。

### 前置芝士

ACAM，数位 DP

## 分析

看到这个题目，很容易想到先把 ACAM 给建出来，然后我们在 Trie 图上的每个节点多维护一个 $ed$ 值，表示这个节点是否为一个模式串的结尾。我们很容易想到，在建立 ACAM 的时候，如果一个节点的 $fail$ 指针指向的节点的 $ed$ 值为真，那么这个节点的 $ed$ 值也为真，那么我们就完成了建立 ACAM 的步骤。

下一步为数位 DP，我采用的是记忆化搜索的写法，设 $f[pos][p]$ 表示还剩 $pos$ 位，在 ACAM 上当前走到的节点为 $p$ 的时候的合法方案，直接套上数位 DP 板子即可，不过这里要注意，匹配过程一旦出现当前节点的 $ed$ 值为真，那么直接返回，最后注意一下前导零的判断即可。

## 代码

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1510, mod = 1e9 + 7;
int t[N][10], fail[N], ed[N], idx;
char s[N], S[N];
int f[N][N];
int a[N];

inline void insert()
{
    int p = 0;
    for (int i = 1; s[i]; i++)
    {
        int c = s[i] - '0';
        if (!t[p][c]) t[p][c] = ++idx;
        p = t[p][c];
    }
    ed[p] = true;
}

inline void build()
{
    queue<int> q;
    for (int i = 0; i < 10; i++)
        if (t[0][i])
            q.push(t[0][i]);
    while (q.size())
    {
        int p = q.front();
        q.pop();
        for (int i = 0; i < 10; i++)
        {
            int c = t[p][i];
            if (!c) t[p][i] = t[fail[p]][i];
            else
            {
                fail[c] = t[fail[p]][i];
                ed[c] |= ed[fail[c]];
                q.push(c);
            }
        }
    }
}

inline int dfs(int pos, int p, bool lead, bool lim)
{
    if (ed[p]) return 0;
    if (!pos) return !lead;
    if (!lim && !lead && ~f[pos][p]) return f[pos][p];
    int up = lim ? a[pos] : 9;
    int res = 0;
    for (int i = 0; i <= up; i++)
        res = (res + dfs(pos - 1, (lead && !i) ? 0 : t[p][i], lead && !i, lim && i == up)) % mod;
    if (!lim && !lead) f[pos][p] = res;
    return res;
}

inline int solve()
{
    memset(f, -1, sizeof f);
    int len = strlen(S + 1);
    for (int i = 1; i <= len; i++)  
        a[len - i + 1] = S[i] - '0';
    return dfs(len, 0, 1, 1);
}

int main()
{
    scanf("%s", S + 1);
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
    {
        scanf("%s", s + 1);
        insert();
    }
    build();
    printf("%d\n", solve());
    return 0;
}
```



---

## 作者：wzj423 (赞：2)

看到这道题，很容易想到以下AC自动机上的dp方程：
```cpp
/**
	f[0][i][j]表示该位不受限制，AC自动机节点为i，匹配到了第j位的方案数
	f[1][i][j]表示该位受限制，AC自动机节点为i，匹配到了第j位的方案数
	f[2][i][j]表示该位以及之前都是前导零, 
    
    因而有：
	for(int nx=0;nx<10;++nx)
		f[0][i][j]->f[0][c[i][nx]][j+1]
		
	for(int nx=0;nx<N[j];++nx)
		f[1][i][j]->f[0][c[i][nx]][j+1]
	f[1][i][j]->f[1][c[i][nx nx==N[j] ][j+1]
	
*/
```
但这样只能得到80分，会Wa两个点
这是为什么？我们可以看一看数据：
```cpp
0821463255
0383320100380
001153611528
066512243919
0321614037728
0835268196243


（4.in）
```
这时835268196243XXXXX在AC自动机上的路径为0-8-3-5...
这本来是一组可行解，但因为错误地考虑了前导零而排除了
因而我们需要重新设计方程：
```cpp
/**
	f[0][i][j]表示该位不受限制，AC自动机节点为i，匹配到了第j位的方案数
	f[1][i][j]表示该位受限制，AC自动机节点为i，匹配到了第j位的方案数
	f[2][i][j]表示该位以及之前都是前导零, AC自动机节点为i，匹配到了第j位的方案数
    则有转移：
	for(int nx=0;nx<10;++nx)
		f[0][i][j]->f[0][c[i][nx]][j+1]
		
	for(int nx=0;nx<N[j];++nx)
		f[1][i][j]->f[0][c[i][nx]][j+1]
	f[1][i][j]->f[1][c[i][nx nx==N[j] ][j+1]
	
	f[1][0][0]->f[2][0][1] nx==0
	f[1][0][0]->f[0][c[0][nx]][1] nx!=0
	
	f[2][0][j]->f[2][0][j+1] nx==0
	f[2][0][j]->f[0][c[0][i][j+1]
*/
```
这样就能AC了

80pts Ver:
```cpp
#include <bits/stdc++.h>
/*80*/
using namespace std;
//defs==============================
const int mod=1e9+7,MAXP=1700,MAXN=1300;
int M;
char N[MAXN],p[MAXN];int Nlen;
long long ans;
bool tot0;
//AC==========================================
int c[MAXP][10],val[MAXP],fail[MAXP],cnt,_rt=0;
bool is_tot0(char *s) {
	int len=strlen(s);
	for(int i=0;i<len;++i) if(s[i]!='0')	return false;
	return true;
}
void ins(char *s) {
	int len=strlen(s),now=_rt;
	for(int i=0;i<len;++i) {
		int v=s[i]-'0';
		if(!c[now][v])	c[now][v]=++cnt;
		now=c[now][v];
	}
	++val[now];
}
void build_fail() {
	queue<int> q;
	for(int i=0;i<10;++i)	if(c[0][i])	q.push(c[0][i]);
	while(!q.empty()) {
		int u=q.front();q.pop();
		for(int i=0;i<10;++i)
			if(c[u][i])	fail[c[u][i]]=c[fail[u]][i],val[c[u][i]]+=val[fail[c[u][i]]],q.push(c[u][i]);
			else	c[u][i]=c[fail[u]][i];
	}
}
//dp======================
int f[2][MAXP][MAXN];
/*
	f[0][i][j]表示该位不受限制，AC自动机节点为i，匹配到了第j位的方案数
	f[1][i][j]表示该位受限制，AC自动机节点为i，匹配到了第j位的方案数
	f[2][i][j]表示该位以及之前都是前导零, 
	for(int nx=0;nx<10;++nx)
		f[0][i][j]->f[0][c[i][nx]][j+1]
		
	for(int nx=0;nx<N[j];++nx)
		f[1][i][j]->f[0][c[i][nx]][j+1]
	f[1][i][j]->f[1][c[i][nx nx==N[j] ][j+1]
	
	f[1][0][0]->f[2][0][1] nx==0
	f[1][0][0]->f[0][c[0][nx]][1] nx!=0
	
	f[2][0][j]->f[2][0][j+1] nx==0
	f[2][0][j]->f[0][c[0][i][j+1]
	
*/
int vis[2][MAXP][MAXN];
void pp(int i,int j,int k) {
//	printf("f[%d][%d][%d]=%d\n",i,j,k,f[i][j][k]);
}
//main================================= 
int main() {
	scanf("%s",N+1);Nlen=strlen(N+1);
	scanf("%d",&M);
	for(int i=1;i<=M;++i) scanf("%s",p),ins(p),tot0|=is_tot0(p);
	build_fail();
	//for(int i=0;i<=cnt;++i)
	//	printf("id=%d 0=%d 1=%d 2=%d 3=%d 4=%d val=%d fail=%d\n",i,c[i][0],c[i][1],c[i][2],c[i][3],c[i][4],val[i],fail[i]);
	vis[1][0][0]=f[1][0][0]=1;
	for(int j=0;j<Nlen;++j){
		for(int i=0;i<=cnt;++i) {
			for(int limit=0;limit<=1;++limit) {
				if(!vis[limit][i][j])	continue;
			//	printf("from (%d,%d,%d)\n",limit,i,j);
				if(limit==0) {
					//puts("limit=0");
					for(int nx=0;nx<10;++nx)
						if(!val[c[i][nx]])
							(f[0][c[i][nx]][j+1]+=f[0][i][j])%=mod,vis[0][c[i][nx]][j+1]=true,pp(0,c[i][nx],j+1);
				} else {
					//puts("limit=1");
					for(int nx=0;nx<N[j+1]-'0';++nx)
						if( /*!(j==0&&nx==0) &&*/ !val[c[i][nx]])
							(f[0][c[i][nx]][j+1]+=f[1][i][j])%=mod,vis[0][c[i][nx]][j+1]=true,pp(0,c[i][nx],j+1);
					if(!val[c[i][ N[j+1]-'0' ]]) {
						(f[1][c[i][ N[j+1]-'0' ]][j+1]+=f[1][i][j])%=mod;
						vis[1][ c[i][ N[j+1]-'0' ] ][j+1]=true;
						//puts("special");
						pp(1,c[i][N[j+1]-'0'],j+1);						
					}

				}
			}
		}
	}
	for(int i=0;i<=cnt;++i) {
		(ans+=f[0][i][Nlen])%=mod;
		(ans+=f[1][i][Nlen])%=mod;
	}
	if(tot0)
		printf("%lld\n",ans);
	else
		printf("%lld\n",ans-1);
	return 0;
}
```


100pts Ver
```cpp
#include <bits/stdc++.h>
using namespace std;
//defs==============================
const int mod=1e9+7,MAXP=1700,MAXN=1300;
int M;
char N[MAXN],p[MAXN];int Nlen;
long long ans;
bool tot0;
//AC==========================================
int c[MAXP][10],val[MAXP],fail[MAXP],cnt,_rt=0;
bool is_tot0(char *s) {
	int len=strlen(s);
	for(int i=0;i<len;++i) if(s[i]!='0')	return false;
	return true;
}
void ins(char *s) {
	int len=strlen(s),now=_rt;
	for(int i=0;i<len;++i) {
		int v=s[i]-'0';
		if(!c[now][v])	c[now][v]=++cnt;
		now=c[now][v];
	}
	++val[now];
}
void build_fail() {
	queue<int> q;
	for(int i=0;i<10;++i)	if(c[0][i])	q.push(c[0][i]);
	while(!q.empty()) {
		int u=q.front();q.pop();
		for(int i=0;i<10;++i)
			if(c[u][i])	fail[c[u][i]]=c[fail[u]][i],val[c[u][i]]+=val[fail[c[u][i]]],q.push(c[u][i]);
			else	c[u][i]=c[fail[u]][i];
	}
}
//dp======================
int f[3][MAXP][MAXN];
/*
	f[0][i][j]表示该位不受限制，AC自动机节点为i，匹配到了第j位的方案数
	f[1][i][j]表示该位受限制，AC自动机节点为i，匹配到了第j位的方案数
	f[2][i][j]表示该位以及之前都是前导零, 
	for(int nx=0;nx<10;++nx)
		f[0][i][j]->f[0][c[i][nx]][j+1]
		
	for(int nx=0;nx<N[j];++nx)
		f[1][i][j]->f[0][c[i][nx]][j+1]
	f[1][i][j]->f[1][c[i][nx nx==N[j] ][j+1]
	
	f[1][0][0]->f[2][0][1] nx==0
	f[1][0][0]->f[0][c[0][nx]][1] nx!=0
	
	f[2][0][j]->f[2][0][j+1] nx==0
	f[2][0][j]->f[0][c[0][i]][j+1] nx!=0
	
*/
int vis[3][MAXP][MAXN];
void pp(int i,int j,int k) {
	//printf("f[%d][%d][%d]=%d\n",i,j,k,f[i][j][k]);
}
inline void add(int &a,int b) {
	(a+=b)%=mod;
}
//main================================= 
int main() {
	scanf("%s",N+1);Nlen=strlen(N+1);
	scanf("%d",&M);
	for(int i=1;i<=M;++i) scanf("%s",p),ins(p),tot0|=is_tot0(p);
	build_fail();
	//for(int i=0;i<=cnt;++i)
	//	printf("id=%d 0=%d 1=%d 2=%d 3=%d 4=%d val=%d fail=%d\n",i,c[i][0],c[i][1],c[i][2],c[i][3],c[i][4],val[i],fail[i]);
	vis[1][0][0]=f[1][0][0]=1;
	for(int j=0;j<Nlen;++j){
		for(int i=0;i<=cnt;++i) {
			for(int limit=0;limit<=2;++limit) {
				if(!vis[limit][i][j])	continue;
				if(limit==0) {
					for(int nx=0;nx<10;++nx)
						if(!val[c[i][nx]])
							add(f[0][c[i][nx]][j+1],f[0][i][j]),vis[0][c[i][nx]][j+1]=true,pp(0,c[i][nx],j+1);
				} else if(limit==1){
					for(int nx=(j==0);nx<N[j+1]-'0';++nx)
						if(!val[c[i][nx]]) {
							add(f[0][c[i][nx]][j+1],f[1][i][j]);
							vis[0][c[i][nx]][j+1]=true;
							pp(0,c[i][nx],j+1);								
						}
					if(j==0){
						add(f[2][0][1],f[1][0][0]);	
						vis[2][0][1]=true;
						pp(2,0,1);
					}
					if(!val[c[i][ N[j+1]-'0' ]]) {
						add(f[1][  c[i][ N[j+1]-'0'  ]][j+1],f[1][i][j]);
						vis[1][ c[i][ N[j+1]-'0' ] ][j+1]=true;
						pp(1,c[i][N[j+1]-'0'],j+1);						
					}						
				} else if(limit==2) {
					add(f[2][0][j+1],f[2][0][j]);
					vis[2][0][j+1]=1;
					pp(2,0,j+1);
					for(int nx=1;nx<10;++nx)
						if(!val[c[i][nx]]) {
							add(f[0][c[i][nx]][j+1],f[2][0][j]);
							vis[0][c[i][nx]][j+1]=true;
							pp(0,c[i][nx],j+1);								
						}
				}
			}
		}
	}
	for(int i=0;i<=cnt;++i) {
		(ans+=f[0][i][Nlen])%=mod;
		(ans+=f[1][i][Nlen])%=mod;
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：Log_x (赞：1)

##AC自动机 + DP

**【解题思路】**

参考[http://blog.csdn.net/Regina8023/article/details/44974979](http://blog.csdn.net/Regina8023/article/details/44974979)

先用 $AC$ 自动机对 $S$ 集合的字符串建立 $Trie$ 树，记数组 $nxt$ 表示 $AC$ 自动机的失败指针，数组 $lst[x]$ 在点 $x$ 表示沿着失败指针能否走到一个 $S$ 集合中的串末尾，如有则记为这个字符串的编号。

然后我们记 $f[i][j][k]$ 表示当前已经确定到第 $i$ 位数，走到 $AC$ 自动机上的节点 $j$，且状态为 $k$ 的总方案数（因为要处理前导0的问题，这里的第 $i$ 位从高位向低位计算，当取最高位，即 $i = 1$ 时，应不包含取0的方案数）。

对于状态 $k$，我们有如下定义：

[1]. $k = 0$ 已经确定的 $i$ 位数小于 $N$ 的前 $i$位；

[2]. $k = 1$ 已经确定的 $i$ 位数等于 $N$ 的前 $i$ 位；

[3]. $k = 2$ 已经确定的 $i$ 位数大于 $N$ 的前 $i$ 位。

接下来我们考虑如何转移：枚举第 $i + 1$ 位选取的数字 $num$，可以利用我们刚才的 $AC$ 自动机判断：这样确定的 $i + 1$ 位数字是否存在某个 $S$ 集合中的串是它的后缀。如不存在我们就可以确定 $AC$ 自动机上的节点 $x$，则 $f[i + 1][x][k’]$ 就可以由 $f[i][j][k]$ 转移过来，最终的转移如下（可结合此时已经确定的 $i$ 位数与 $N$ 的前 $i$ 位的大小关系来理解）：

[1]. 若 $num$ 小于 $N$ 的第 $i + 1$ 位：

$f[i + 1][x][0] += f[i][j][0] + f[i][j][1]$

$f[i + 1][x][2] += f[i][j][2]$

[2]. 若 $num$ 等于 $N$ 的第 $i + 1$ 位：

$f[i + 1][x][0] += f[i][j][0] $

$f[i + 1][x][1] += f[i][j][1]$

$f[i + 1][x][2] += f[i][j][2]$

[3]. 若 $num$ 大于 $N$ 的第 $i + 1$位：

$f[i + 1][x][0] += f[i][j][0]$

$f[i + 1][x][2] += f[i][j][2] + f[i][j][1]$

每确定一位数都要将 $\sum \limits^2_{k’ = 0} f[i + 1][j][k’]$ 累加进答案 $Ans$，同时因为幸运数不能大于 $N$，所以最终的答案还要减去 $\sum f[n][j][2]$（$n$ 为数 $N$ 的位数）。

**【代码】**






 
    
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
typedef long long ll;
const int Maxn = 0x3f3f3f3f;
const int N = 1505, M = 1205;
const ll Mod = 1e9 + 7;
ll f[M][N][3], Ans; 
bool pos[N]; char s[M], a[N]; 
int n, m, T, G[N][10], Q[N], nxt[N], lst[N];
inline int get()
{
    char ch; bool f = false; int res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch == '-') f = true;
     else res = ch - '0';
    while ((ch = getchar()) >='0' && ch <= '9')
        res = (res << 3) + (res << 1) + ch - '0';
    return f? ~res + 1 : res;
}
inline void put(int x)
{
    if (x < 0)
      x = ~x + 1, putchar('-');
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48);
}
inline void Insert()
{
    scanf("%s", a + 1); 
    int x = 0, l = strlen(a + 1);
    for (int i = 1; i <= l; ++i)
    {
        int y = a[i] - '0';
        if (!G[x][y]) G[x][y] = ++T;
        x = G[x][y]; 
    }
    pos[x] = true;
}
inline void Bfs()
{
    int t, w, x, y; t = w = 0; 
    for (int i = 0; i < 10; ++i)
     if (G[0][i]) Q[++w] = G[0][i];
    while (t < w)
    {
        x = Q[++t];
        for (int i = 0; i < 10; ++i)
         if (!G[x][i]) G[x][i] = G[nxt[x]][i];
         else 
         {
             Q[++w] = y = G[x][i]; int v = nxt[x];
            while (!G[v][i] && v) v = nxt[v];
            nxt[y] = G[v][i];
            lst[y] = pos[nxt[y]] ? nxt[y] : lst[nxt[y]]; 
         }
    }
}
inline int cmp(const int &x, const int &y)
{
    if (x > y) return 2;
    if (x < y) return 0;
    return 1; 
}
int main()
{
    scanf("%s", s + 1); 
    n = strlen(s + 1); m = get();
    while (m--) Insert(); Bfs();
    for (int i = 1; i < 10; ++i) //不含前导0 
    {
        int x = G[0][i];
        if (!pos[x] && !lst[x]) f[1][x][cmp(i, s[1] - '0')]++;
    }
    for (int i = 0; i <= T; ++i)
     (Ans += f[1][i][0] + f[1][i][1] + f[1][i][2]) %= Mod;
    for (int i = 1; i < n; ++i)
    {
        for (int j = 0; j <= T; ++j)
        if (f[i][j][0] || f[i][j][1] || f[i][j][2])
        for (int k = 0; k < 10; ++k)
        {
            int x = j;
            while (!G[x][k] && x) x = nxt[x];
            x = G[x][k]; 
            if (pos[x] || lst[x]) continue;
            int v = cmp(k, s[i + 1] - '0');
            switch (v)
            {
                case 0:
                  (f[i + 1][x][0] += f[i][j][0] + f[i][j][1]) %= Mod;
                  (f[i + 1][x][2] += f[i][j][2]) %= Mod; break;
                case 1:
                  (f[i + 1][x][0] += f[i][j][0]) %= Mod;
                  (f[i + 1][x][1] += f[i][j][1]) %= Mod;
                  (f[i + 1][x][2] += f[i][j][2]) %= Mod; break;
                case 2:    
                  (f[i + 1][x][2] += f[i][j][2] + f[i][j][1]) %= Mod;
                  (f[i + 1][x][0] += f[i][j][0]) %= Mod; break;
            }
         }
         for (int j = 0; j <= T; ++j)
         {
             (Ans += f[i + 1][j][0] + f[i + 1][j][1]) %= Mod;
             if (i + 1 < n) (Ans += f[i + 1][j][2]) %= Mod;
        }
    }
    return put(Ans), 0;
}

```

---

## 作者：Xu__ (赞：0)

题目链接：[P3311 [SDOI2014] 数数](https://www.luogu.com.cn/problem/P3311)

### 题意概括

若 $x$ 为正整数，且其在十进制表示下不包含给定数字串集合 $s$ 中的任意元素作为字串，则称 $x$ 为**幸运数**。给出集合 $s$，你需要求出不大于 $x$ 的幸运数的个数。

### 题目分析

首先看到 $n\le 10^{1201}$，所以可以直接考虑数位 DP 了
（对于这样数位 DP 的题，可以先写一个 DFS 的暴搜，调出来之后再加记忆化）。

其次看到有多个不能包含的数字串，所以可以建一颗 AC 自动机出来。

在正常建完 AC 自动机之后，执行普通数位 DP 的过程，但是每次选定当前位置填什么之后，就要在 Trie 树上向下走一条边，如果走到的节点是某一数字串的结束位置或者能通过 fail 边到达结束位置，则不能向下递归搜索。


### 需要注意的细节

- **AC 自动机不要忘记建树！！！**
- 如果当前前导零标记还未去掉，则不能直接向下走，需要留在原地（因为可能有数字串包含前导零）。

### 代码实现

```cpp
#include <bits/stdc++.h>
#define FL(a, b, c) memset(a, b, c)
#define RE() cout << "¿What Happened?" << endl
#define DG(x) cout << "Debug : " << #x << " = " << x << endl
#define TE() cerr << "Time : " << clock() << "(ms)" << endl
#define ER(a, b) for(int a(head[b]); a; a = next[a])
#define IR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a <= c; ++a)
#define OR(a, b, c, ...) for(int a(b), ##__VA_ARGS__; a >= c; --a)
using namespace std;
struct FastIN {
	template < class T > inline FastIN& operator >> (T& x) {
		x = 0; bool sd(false);
		char ch(getchar());
		while (!isdigit(ch) and (ch != '-')) ch = getchar();
		if (ch == '-') sd = true, ch = getchar();
		while (ch >= '0' and ch <= '9') x = (x << 3) + (x << 1) + ch - '0', ch = getchar();
		if (sd == true) x = -x;
		return *this;
	}
} IN;
const int INF = ~0u >> 1;
template < class T > inline void Gmin(T& a, const T& b) { a = min(a, b); }
template < class T > inline void Gmax(T& a, const T& b) { a = max(a, b); }

const int kN = 1510, Mod = 1e9 + 7;

int m;

int A[kN], Cnt;

int F[kN][kN][2][2];

struct AC {
	int tot, ch[kN][10], fail[kN];
	bool end[kN];
	inline void Ins(string s) {
		int p(0), lim(s.length() - 1);
		IR(i, 0, lim) {
			int t = s[i] - '0';
			if (!ch[p][t]) ch[p][t] = ++tot;
			p = ch[p][t];
		}
		end[p] = true;
	}

	inline void Build() {
		queue < int > Q;
		IR(i, 0, 9) if (ch[0][i]) Q.push(ch[0][i]);
		while (Q.size()) {
			int x = Q.front(); Q.pop();
			IR(i, 0, 9) {
				int& y = ch[x][i];
				if (y) fail[y] = ch[fail[x]][i], Q.push(y), end[y] |= end[fail[y]];
				else y = ch[fail[x]][i];
			}
		}
	}

	inline int DFS(int x, int p, bool limit, bool lead0) {
		int& sum = F[x][p][limit][lead0];
		if (sum >= 0) return sum;
		if (x > Cnt) return !lead0;
		sum = 0;
		IR(i, 0, (limit ? A[x] : 9)) {
			int nt = ch[p][i];
			if (lead0 and i == 0) sum = (sum + DFS(x + 1, 0, limit & (i == A[x]), true)) % Mod; // 留在根节点（零号节点）
			else if (!end[nt]) sum = (sum + DFS(x + 1, nt, limit & (i == A[x]), false)) % Mod;
		}
		return sum;
	}

} Ac;

inline int Solve() {
	FL(F, 0xff, sizeof F);
	return Ac.DFS(1, 0, true, true);
}


signed main() {
#ifdef FIO
    freopen("I:/Code/Data/In.in", "r", stdin);
    freopen("I:/Code/Data/Out.out", "w", stdout);
#endif
	string s; cin >> s;
	int lim(s.length() - 1);
	IR(i, 0, lim) A[++Cnt] = s[i] - '0';
	IN >> m;
	IR(i, 1, m) cin >> s, Ac.Ins(s);

	Ac.Build(); // 不要忘记建树！！！

	cout << Solve() << "\n";
	

}


```



---

## 作者：pengyule (赞：0)

[原题](https://www.luogu.com.cn/problem/P3311)

前置知识：AC 自动机，数位 DP。

降级版相似题：[[JSOI2007]文本生成器](https://www.luogu.com.cn/problem/P4052)

[JSOI2007]文本生成器 题解：

这是一道 AC 自动机上 DP 的题目。**AC 自动机上 DP 的基本思路是设 $f[i][j]$ 表示当前串长 $i$、在 $j$ 号节点**。那么本题就可以采用这一思路。设 $f[i][j]$ 表示当前串长 $i$、在 trie 上 $j$ 号节点，且当前串不包含任何一个单词的方案数。**由于在 trie 结构中从某号节点转移到它的子节点比子节点从父节点转移更加便捷**，因此考虑用 $f[i][j]$ 更新 $f[i+1][trie[j][k]],k\in[0,26)$。

```cpp
for(int b=0;b<26;b++)
    if(!trie[j][b])(f[i+1][0]+=f[i][j])%=mod;
	else if(!cnt[trie[j][b]])(f[i+1][trie[j][b]]+=f[i][j])%=mod;
```

上面的转移：当该子节点为空时，说明这个子节点对应的字母跟当前串不可能构成单词，因此一定可以接在后面，而后开启“新纪元”（回到 trie 根）。当该子节点不为空时，如果在 AC 自动机上跳着统计完发现不会统计到单词，则可以放，否则放上这个字母就会出现单词而不合法。代码中的 $cnt$ 为根据 $fail$ 树预处理出的每个点会统计到的答案。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=1e4+7;
int n,m,tot,trie[6005][26],fail[6005],f[105][6005],cnt[6005];
string s;
vector<int>G[6005];
queue<int>Q;
void insert(){
	int rt=0;
	for(int i=0;i<s.length();i++){
		int b=s[i]-'A';
		if(!trie[rt][b])trie[rt][b]=++tot;
		rt=trie[rt][b];
	}
	cnt[rt]++;
}
void get_fail(){
	for(int i=0;i<26;i++)if(trie[0][i])Q.push(trie[0][i]),G[0].push_back(trie[0][i]);
	while(!Q.empty()){
		int x=Q.front();Q.pop();
		for(int i=0;i<26;i++){
			if(trie[x][i]){
				fail[trie[x][i]]=trie[fail[x]][i];
				G[fail[trie[x][i]]].push_back(trie[x][i]);
				Q.push(trie[x][i]);
			}
			else trie[x][i]=trie[fail[x]][i];
		}
	}
}
void sumup(int x){
	for(int i=0;i<G[x].size();i++)cnt[G[x][i]]+=cnt[x],sumup(G[x][i]);
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>s,insert();
	get_fail(),sumup(0);
	f[0][0]=1;
	for(int i=0;i<m;i++){
		for(int j=0;j<=tot;j++){
			int k=0;
			for(int b=0;b<26;b++)
				if(!trie[j][b])k++;
				else if(!cnt[trie[j][b]])(f[i+1][trie[j][b]]+=f[i][j])%=mod;
			(f[i+1][0]+=k*f[i][j]%mod)%=mod;
		}
	}
	int ans=0,pro=1;
	for(int i=1;i<=m;i++)pro=pro*26%mod;
	for(int i=0;i<=tot;i++)ans=(ans+f[m][i])%mod;
	cout<<((pro-ans)%mod+mod)%mod;
}
```

[SDOI2014]数数 题解：

这道题可以沿用上面 AC 自动机上 DP 的思想，且大同小异。小异在这题有了数位 DP“卡上界”的限制，但其实本质还是上面粗体字的基本思路。

设 $f_{u,o,i,j}(u,o\in\{0,1\})$ 为状态，$u,o,i,j$ 的含义见下表：

| $u$                                         | $o$                  | $i$      | $j$                   |
| ------------------------------------------- | -------------------- | -------- | --------------------- |
| 是($1$)否($0$)串的 $1\sim i$ 位置都是前导 0 | 是($1$)否($0$)卡上界 | 当前串长 | 在 trie 上 $j$ 号节点 |

于是：

```cpp
//t为给定的大数字（字符串），下标从0到m（注意m与原题中不是同一个）
for(int i=0;i<m;i++){
    for(int u=0;u<=1;u++){
        for(int o=0;o<=1;o++){
            for(int j=0;j<=tot;j++){
                for(int b=0;b<=(o?t[i]-'0':9);b++){
                    if(u&&!b)f[1][0][i+1][0]=1;//如果还是都是前导0，则一定不卡上界，而且不转移
                    else if(!trie[j][b])(f[0][o&(b==(o?t[i]-'0':9))][i+1][0]+=f[u][o][i][j])%=mod;
                    else if(!cnt[trie[j][b]])(f[0][o&(b==(o?t[i]-'0':9))][i+1][trie[j][b]]+=f[u][o][i][j])%=mod;
                }
            }
        }
    }
}
```

答案即为 $\sum_{u,o\in\{0,1\},0\le j\le tot}f[u][o][m][j]$（$tot$ 表示 trie 中节点最大编号）。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,m,tot,trie[1505][10],fail[1505],f[2][2][1205][1505],cnt[1505],f[1205],p[1205];
string t,s;
vector<int>f[1505];
queue<int>Q;
void insert(){
	int rt=0,l=s.length();
	for(int i=0;i<l;i++){
		int b=s[i]-'0';
		if(!trie[rt][b])trie[rt][b]=++tot;
		rt=trie[rt][b];
	}
	cnt[rt]++;
}
void get_fail(){
	for(int i=0;i<10;i++)if(trie[0][i])Q.push(trie[0][i]),f[0].push_back(trie[0][i]);
	while(!Q.empty()){
		int x=Q.front();Q.pop();
		for(int i=0;i<10;i++){
			if(trie[x][i]){
				fail[trie[x][i]]=trie[fail[x]][i];
				f[fail[trie[x][i]]].push_back(trie[x][i]);
				Q.push(trie[x][i]);
			}
			else trie[x][i]=trie[fail[x]][i];
		}
	}
}
void sumdn(int x){
	for(int i=0;i<f[x].size();i++)cnt[f[x][i]]+=cnt[x],sumdn(f[x][i]);
}
int main(){
	cin>>t>>n;m=t.length();
	for(int i=1;i<=n;i++)cin>>s,insert();
	get_fail(),sumdn(0);
	f[1][1][0][0]=1;
	for(int i=0;i<m;i++){
		for(int u=0;u<=1;u++){
			for(int o=0;o<=1;o++){
				for(int j=0;j<=tot;j++){
					for(int b=0;b<=(o?t[i]-'0':9);b++){
						if(u&&!b)f[1][0][i+1][0]=1;
						else if(!trie[j][b])(f[0][o&(b==(o?t[i]-'0':9))][i+1][0]+=f[u][o][i][j])%=mod;
						else if(!cnt[trie[j][b]])(f[0][o&(b==(o?t[i]-'0':9))][i+1][trie[j][b]]+=f[u][o][i][j])%=mod;
					}
				}
			}
		}
	}
	int ans=0;
	for(int i=0;i<=tot;i++)ans=(((((((ans+=f[0][0][m][i])%=mod)+=f[1][0][m][i])%=mod)+=f[0][1][m][i])%=mod)+=f[1][1][m][i])%=mod;
	cout<<ans-1;
}
```



---

## 作者：Vocalise (赞：0)

这篇题解的设计状态有一些不一样，也不是记搜......主要是个人写数位 DP 的习惯。

## 题意

给定一些十进制数字串 $s_i(1\le i\le m)$​​，求不超过 $n$​​ 的数有多少个在十进制下没有一个 $s_i$​ 是其子串。

$n < 10^{1201},m\le 100,1\le\sum_{i=1}^m|s_i|\le 1500$

求的数不含前导 $0$，但给定的串中可能有。

## 题解

建 $fail$ 树时标记那些祖先中有表示给定串末尾的结点。下文中将不考虑这些点。

假如问的是不超过 $n$ 位的数字个数，我们就可以简单地对 $s_i(1\le i\le n)$ 建 AC 自动机后 DP：

设 $f_{i,u}$ 为从根开始，长为 $i$ ，最后到节点 $u$ 的路径条数。

$$f_{1,0} = 1,f_{i,0}=0(i\not=1),f_{i,u}=\large\sum\limits_{(v,u)\in E}f_{i-1,v}$$

答案就是

$$\large\sum\limits_{i=1}^n\large\sum\limits_{u\in V}f_{i,u}$$

但是这里我们采用另一种方式。

设 $f_{u,i}$ 为从节点 $u$ 开始，任意走 $i$ 步的路径条数。

$$f_{u,0}=1,f_{u,i}=\large\sum\limits_{(u,v)\in E}f_{v,i-1}$$

答案为 $\large\sum\limits_{i=1}^nf_{1,i}$。发现这样似乎比上一种更加简洁。

至于为何采用这种形式，和本题 DP 的方法有关。

---

那么对于本题中的限制，我们把不大于 $n$​​ 的数分为 $3$​ 类讨论：（令 $t$ 为 $n$ 的位数）

1. 位数不足 $t$​ 的数；
2. 位数为 $t$​，在第 $i(1\le i\le t)$​ 位之前各位与 $n$​ 相同，该位上比 $n$​​ 小（$i$​ 从小到大表示 $n$​ 从高到低的位）；
3. $n$​ 本身。

如果不考虑前导 $0$：

对于第一类，我们直接统计 $\large\sum\limits_{i=1}^{n-1}f_{1,i}$ 即可。

对于第二类，我们从小到大考虑 $i$​，并维护代表 $n$ 前 $i-1$​ 位数字串的节点 $v$​。

枚举 $v$​ 的小于 $n$​ 该位的出边，设其指向 $u$​，其贡献为 $f_{u,t-i}$。

若某次 $v$​ 没有 $n$ 该位的出边（到达了某个 $s_i$ 的末尾），则代表接下来的位都不可能相同，退出。

对于第三类，观察第二位统计过程是否提前退出，若没有，贡献为 $1$。

---

除去带前导 $0$ 的数的影响：

对于第一类，若根节点出边 $0$ 指向 $x$，减去 $\large\sum\limits_{i=0}^{n-2}f_{x,i}$。这是因为我们只要避免路径的第一条边是 $0$ 。

对于第二类，$i=1$ 时，特判不走 $0$ 出边即可。

事实上，很容易想到采用建图之后去除 $(0,x)$ 边的方法。但是这样是错误的。

例如，根节点的一条未出现在 $s_i(1\le i\le n)$​ 的数字出边会指向自己，走该条边后再走 $0$​ 出边是合法的。

时间复杂度（$a$ 为字符集大小，为 $10$）$\mathcal O(ta\sum_{i=1}^n|s_i|)$​​​

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <vector>

const int N = 1600;
const int p = 1000000007;

inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();
    return x * f;
}

int n,m,f[N][N],vis[N],fail[N],tr[N][10];
char s[N],t[N];
std::queue <int> q;

int main() {
    std::scanf("%s",s + 1), n = strlen(s + 1);
    m = 1;
    for(int i = 0;i < 10;i++) tr[0][i] = 1;
    int c = read();
    for(int i = 1;i <= c;i++) {
        std::scanf("%s",t + 1);
        int k = 1;
        for(int j = 1;t[j];j++) {
            int &v = tr[k][t[j] - '0'];
            if(!v) v = ++m;
            k = v;
        }
        vis[k] = true;
    }
    q.push(1);
    while(!q.empty()) {
        int v = q.front(); q.pop();
        for(int i = 0;i < 10;i++) {
            int &u = tr[v][i];
            if(!u) u = tr[fail[v]][i];
            else {
                 fail[u] = tr[fail[v]][i], q.push(u);
                 vis[u] |= vis[fail[u]];
            }
        }
    }
    for(int i = 1;i <= m;i++) if(!vis[i]) f[i][0] = 1;
    int ans = 0;
    for(int i = 1;i <= n;i++) {
        for(int v = 1;v <= m;v++) if(!vis[v]) {
            for(int j = 0;j < 10;j++) {
                int u = tr[v][j]; if(!u || vis[u]) continue;
                f[v][i] = (f[v][i] + f[u][i - 1]) % p;
            }
        }
        if(i < n) ans = (ans + f[1][i] - f[tr[1][0]][i - 1]) % p;
    }
    int k = 1;
    for(int i = 1;i <= n;i++) {
        for(int j = 0;j < s[i] - '0';j++) {
            if(i == 1 && !j) continue;
            int u = tr[k][j]; if(!u || vis[u]) continue;
            ans = (ans + f[u][n - i]) % p;
        }
        k = tr[k][s[i] - '0'];
        if(!k || vis[k]) break;
    }
    if(k && !vis[k]) ans = (ans + 1) % p;
    std::printf("%d\n",ans);
    return 0;
}

```

---

## 作者：C20203030 (赞：0)

本篇题解受[这位大佬](https://www.cnblogs.com/candy99/p/6666613.html)的启发，在此感谢。

数据太水，但是此方法能通过$hack$数据，请放心食用。
## 一、题目
[点此看题](https://www.luogu.com.cn/problem/P3311)
## 二、解法
应该很容易看出这是一道在$\text{AC}$自动机上数位$dp$的题目。

我们可以分成两部分$dp$，一部分是位数比$n$小的部分，一部分是位数等于$n$的部分。

第一部分，定义$g[i][j]$为长度为$i$，在自动机上匹配到了节点$j$（不允许出现前导零）的方案数，转移直接在自动机上跳即可，注意计算幸运数个数，如果我们跳到了不是幸运数的节点（标记需要在$fail$树上下放），那就不给它转移，所以不是幸运数的节点存储的$dp$值一定是$0$。

第二部分，仿照第一部分，定义$f[i][j][0/1]$为长度为$i$，在自动机上匹配节点$j$，最后一个$bool$表示是否贴近上界（$n$的限制），转移需要讨论一下这个$bool$。

然后就完了，时间复杂度$O(10\times lL)$，具体操作看代码：

```cpp
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int M = 1505;
const int MOD = 1e9+7;
int read()
{
    int x=0,flag=1;
    char c;
    while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
    while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*flag;
}
int n,m;
char s[M],t[M];
struct automaton
{
    int cnt,fail[M],val[M],c[M][10],g[M][M],f[M][M][2],ans;
    void ins(char *s)
    {
        int len=strlen(s),now=0;
        for(int i=0; i<len; i++)
        {
            int v=s[i]-'0';
            if(!c[now][v]) c[now][v]=++cnt;
            now=c[now][v];
        }
        val[now]=1;
    }
    void build()
    {
        queue<int> q;
        for(int i=0; i<10; i++) if(c[0][i]) q.push(c[0][i]);
        while(!q.empty())
        {
            int t=q.front();
            q.pop();
            val[t]|=val[fail[t]];
            for(int i=0; i<10; i++)
                if(c[t][i]) fail[c[t][i]]=c[fail[t]][i],q.push(c[t][i]);
                else c[t][i]=c[fail[t]][i];
        }
    }
    void mod(int &x)
    {
        x=x%MOD;
    }
    void dp()
    {
        g[0][0]=1;
        for(int i=0; i<n; i++)
            for(int j=0; j<=cnt; j++)
                for(int k=0; k<10; k++)
                    if(!val[c[j][k]])
                    {
                        if(i==0 && k==0) continue;
                        mod(g[i+1][c[j][k]]+=g[i][j]);
                    }
        f[0][0][1]=1;
        for(int i=0; i<n; i++)
            for(int j=0; j<=cnt; j++)
                for(int k=0; k<10; k++)
                    if(!val[c[j][k]])
                    {
                        if(i==0 && k==0) continue;
                        int v=c[j][k];
                        mod(f[i+1][v][0]+=f[i][j][0]);
                        if(k<s[i+1]-'0') mod(f[i+1][v][0]+=f[i][j][1]);
                        if(k==s[i+1]-'0') mod(f[i+1][v][1]+=f[i][j][1]);
                    }
        for(int i=1; i<n; i++)
            for(int j=0; j<=cnt; j++)
                mod(ans+=g[i][j]);
        for(int i=0; i<=cnt; i++)
        {
            mod(ans+=f[n][i][0]);
            mod(ans+=f[n][i][1]);
        }
        printf("%d\n",ans);
    }
} AC;
int main()
{
    scanf("%s",s+1);
    n=strlen(s+1);
    m=read();
    for(int i=1; i<=m; i++)
    {
        scanf("%s",t);
        AC.ins(t);
    }
    AC.build();
    AC.dp();
}
```


---


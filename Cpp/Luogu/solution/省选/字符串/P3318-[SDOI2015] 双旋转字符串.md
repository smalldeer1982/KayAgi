# [SDOI2015] 双旋转字符串

## 题目描述

给定两个字符串集合 S 和 T 。其中 S 中的所有字符串长度都恰好为 N ，而 T 中所有字符串长度都恰好为 M 。且 N+M 恰好为偶数。如果记 S 中字符串全体为 S1，S2，...，STotalS ,而 T 中字符串全体为 T1，T2，...，TTotalT 。现在希望知道有多少对 <i,j> ，满足将 Si 和 Tj 拼接后得到的字符串 Si+Tj 满足双旋转性。

一个长度为偶数字符串 W 可以表示成两段长度相同的字符串的拼接，即 W=U+V。如果 V 可以通过 U 旋转得到，则称 W 是满足双旋转性的。比如说字符串 U=”vijos“可以通过旋转得到”ijosv“，”josvi“，”osvij“ 或”svijo“。那么”vijosjosvi“就是满足双旋转性的字符串。


## 样例 #1

### 输入

```
4 4 7 3
vijosvi
josvivi
vijosos
ijosvsv
jos
vij
ijo
jos```

### 输出

```
6```

# 题解

## 作者：jjsnam (赞：12)

## 写在前面

这是学校字符串哈希算法的作业，也是我第一个自己 AC 的有关字符串算法的紫题。同时，我被这道题坑的很惨，所以写题解出来记录一下。

这道题让人又爱又恨。它的槽点很多，但它的确是一道好题，我在写题解的时候又在一遍遍不停的驳斥自己的思路，迭代自己的代码。花费了这么多时间，但是我也收获了很多。

首先说明，这道题哈希的严格正确做法跑的比较慢，但是应该不用像楼上需要吸氧，本代码存在一定不严谨性（文章中也会提及严谨做法），最慢是 300ms 多（看不上的神犇们可以去看楼上 KMP+Tire 的解法，但是本蒟蒻不会），但因为这道题数据很弱，我们~~阉割~~后的代码[跑的飞快](https://www.luogu.com.cn/record/76361643)，吸氧后碾压其他做法，目前最优解 rank 1。

### 吐槽

这道题槽点很多。我来罗列一下：

- 题面的 markdown 炸了（或者根本没用）。

- 算法标签一塌糊涂（字符串跟数论有个毛关系？）。

- 数据范围有问题。具体来说，数据总体的范围给的太小，导致我一直在 TLE 和 RE。后来[白嫖](https://darkbzoj.cc/data/)到了这道题在 BZOJ 的数据，题目描述中会对数据范围进行修正。

- 数据太弱。数据中的 $n$，$m$ 全部相等，这导致它的难度只配是绿到蓝。如果保证了两数不相等，才满足蓝题以上。其次，它要作为紫题还需要有卡掉一些无脑做法的 hack，后文会提及。

就这些坑点让我花费了大把时间，真气死哦嘞！

### 前置知识

- 字符串哈希，Hash

- STL：unordered_map 使用方法

- 快速幂

### 题目描述（戳这里[查看原题](https://www.luogu.com.cn/problem/P3318)）

给定**两组**字符串，保证每组中的字符串长度**都相等**。

从两组字符串中各拿出一个字符串组成新的字符串（保证新的字符串长度是偶数），求将这个新的字符串从中间断开后，满足前后两个子串互为**双旋转字符串**的方案数。

**双旋转字符串**：即将字符串旋转后相等（可以当做字符串在粘成一圈的纸带上，我们转纸带，出现的字符串都是双旋转字符串）。    
举个例子：字符串 $\texttt{abcd}$ 的双旋转字符串包括 $\texttt{bcda}$、$\texttt{cdab}$、$\texttt{dabc}$，以及它自己。

其中，两组字符串中字符串的个数分别为 $TotalS$、$TotalT$（**为了方便我们引用为 $p$、$q$**），每组字符串的长度分别为 $n$、$m$。

满足：$1 ≤ p,q ≤ 2\times10^4$，$1≤n,m≤10^3$，$n≥m$，极端情况下保证 $n \times p + m \times q ≤ 4 \times 10^6$。（数据范围已更正）

## 正文

其实有关字符串的题目思维难度并没有像图论、动态规划那样高。它的特点就在于要理清思路，然后正确的把代码写出来，就好似一个大模拟。这类题的代码实现难度普遍会高一些。

### 分析

写代码之前要有明确的思路，所以我们首先分析样例。  

比如，我们取出集合 $S$ 中的第一串  $\texttt{"vijosvi"}$，那么根据定义，它将作为新字符串前面的一部分。接下来我们要考虑怎么在 $T$ 中找到后面的那个字符串。

新的字符串保证长度 $len = n+m = 10$。那么我们从中间断开后，两段字符串的长度都是 $5$。又因为我们从 $S$ 中取出来的串长度为 $n=7$，所以我们能确定新的字符串断开后的两个串分别为：$\texttt{"vijos"}$、$\texttt{"vi***"}$（$\texttt{"***"}$是我们要匹配的部分，它需要在字符串集合 $T$ 中）。

对于断开后的前串，我们可以得到它的双旋转字符串：

- $\texttt{vijos}$、$\texttt{ijosv}$、$\texttt{josvi}$、$\texttt{osvij}$、$\texttt{svijo}$

通过观察发现，这些双旋转字符串中**只有** $\texttt{"vijos"}$ 的**前缀**与我们需要匹配的后串 $\texttt{"vi***"}$ 的**前缀**相同，都是 $\texttt{"vi"}$。这就说明只有当**后串**等于 $\texttt{"vijos"}$ 时，**后串是前串的双旋转字符串**。

因此，在这种情况下，我们推出 $\texttt{"***"} = \texttt{"jos"}$。通过查询字符串集合 $T$，我们发现内容为 $\texttt{jos}$ 的字符串有 $2$ 个，则这种情况对答案的贡献是 $2$。

同理我们再枚举 $S$ 中的其他字符串，一个一个匹配，最后把所有贡献累加起来的答案等于 $6$。

### 思路

通过刚才的分析，其实做法就是很显然的事情了。

由于 $n≥m$，则我们枚举 $S$ 中的字符串一定可以确定新字符串的前串以及多出来被断在后串的一部分字符串 $u$（其中 $u$ 的长度可以为 0，而且 $u$ 一定是后串的一个前缀）。既然有了前串，那我们只需要枚举所有前串的双旋转字符串 $r$，通过匹配 $r$ 的前缀和后串的前缀 $u$ 是否相等，如果相等就说明后串可以是 $r$，那么我们也就确定了需要在字符串集合 $T$ 中匹配的字符串 $v$（满足 $u+v=r$，这里的加号是**字符串合并**）。这样我们只用知道 $T$ 中有多少 $v$ 就可以计算对答案的贡献了。

### 具体实现

思路很简单，接下来就是代码实现了，这里需要的知识比较多，我们一步一步来。

**① 如何枚举一个字符串 $str$ 的所有双旋转字符串？**  

这里我们联想一下**区间 DP**。如果是一个环型区间 DP，你会怎么做？

那自然是**倍长**。我们将 $str$ 复制一次，就得到了一个长度是 $str$ 两倍，内容是 $str$ 重复两次的新字符串。然后我们像一个滑块一样，遍历这个新的字符串，每次找到一个起点，取长度与 $str$ 长度相同的新的字符串的子串，这个子串就是 $str$ 的一个双旋转字符串。

![倍长求双旋转字符串](https://cdn.luogu.com.cn/upload/image_hosting/9a9htpca.png)

**② 怎样匹配前缀？**

这个就简单提一嘴，毕竟做到紫题肯定是对字符串哈希很了解的大佬们了。

我们通过 unsigned long long 自动溢出的性质，用它作为一个大模数，通过对一个字符串 $s$ 乘以一个基底，将这个字符串哈希（我们定义这个哈希数组为 $Hash$）。

- 建立哈希数组：   
$Hash_{i} = Hash_{i-1} \times base + s_{i}$。  
其中 $i \in [1,len(s)]$，$base$ 值一般取 $131$。

- 查询哈希数组中 $[l,r]$ 的哈希值：   
$res = Hash_{r}-Hash_{l-1}\times base^{r-l+1}$。

那么比较两个前缀的哈希值，我们可以将比对项的哈希值设为 $hashVal$，之后在枚举双螺旋字符串时每回只取前面与比对项长度相同的子串作为前缀，求得它的哈希值与  $hashVal$ 比较即可。相等就是两个前缀相等，证明后串存在是该双旋转字符串的可能性，对答案有贡献。

**③ 比对前缀相等后，如何求得待匹配串 $v$？**

char 固然可以做，但是使用  $\text{string}$ 更加的好写，看起来也更~~优雅~~。

我们设比对成功后双旋转字符串 $r$ 的起始字符是 $i$，末字符是 $j$，比对前缀 $u$ 的长度是 $length$。那么此时满足条件的后串一定等于 $r$。而 $r$ 中 $[i,i+length-1]$ 是比对的前缀，那么 $v$ 就是剩下的部分，也就是 $r$ 中 $[i+length,j]$ 这一部分。

具体操作可以用 ```substr()``` 函数解决。

**④ 得到匹配串 $v$ 后，如何找到其在 $T$ 中的个数？**

可能有人会想用 multiset 或者 map，但是他们的单次查询时间复杂度都是 $O(\log n)$，对于 $4 \times 10^6$ 的数据还是不太友好（因为我一开始就用的这个，最后一直在 TLE）。

相比之下，我强烈推荐 unordered_map。它的内部实现也是哈希，但是平均时间复杂度是 $O(1)$，一般情况下的效率会比 multiset 高很多。

然后就很显然了，初始读入 $T$ 的时候我们就把所有字符串都哈希并添加到一个 unordered_map 中，用的时候直接查找就好。

### 细节

一般在哈希的时候我们要预处理出基底的所有幂，以便查询，但是我们观察这题，需要那么多幂吗？

对于已知的 $n$、$m$，我们可以确定出查询一个双旋转字符串的长度，也就得出了**需要 $base^{\frac{n+m}{2}}$**。    
比较前缀，我们知道长度是 $n-\dfrac{n+m}{2}=\dfrac{n-m}{2}$，**需要 $base^{\frac{n-m}{2}}$**。   
之后要查找 $T$ 中的匹配串，长度为 $m$，**需要 $base^m$**。

所以总共只需要 $3$ 个幂，开始时**快速幂**即可。

### 坑点

首先声明，弱鸡数据没有卡到这里，这里的做法我也理解的不太深刻，不需要的同志们可以直接跳过。

我的数学老师常说学理科要**细腻**，那我们就来看看，我们刚才的思路真的无懈可击了吗？

来看下面这组数据：

```
1 4 7 3
aaaaaaa
aaa
aaa
aaa
```

如果按照我们刚才所说的思路，枚举每一个双旋转字符串，我们发现都是 $\texttt{"aaaaa"}$，总数为 $5$。按照我们刚才比对的思路，每一个双旋转字符串的前缀和后串的前缀都是相等的 $\texttt{"aa"}$，那么我们在 $T$ 中匹配的字符串都是 $\texttt{"aaa"}$，也就说明这 $5$ 个双旋转字符串对答案的贡献都是 $3$，最终答案是 $15$。

但是很显然，**正确答案**是 $3$。问题应该很明显了，因为我们双旋转字符串重合了，导致了**不合法**情况出现。

如何防止不合法情况出现？我们要**判重**。那么显然我们会想到每次枚举后将这个字符串记录下来，下次再枚举的时候查找是否已经出现过这个字符串即可。

考虑**实现**。可能很多人又会想到用 set 这类 STL 来完成，但是我通过实践，**T 四个点**（当然吸氧能过）。对于 $4\times10^6$ 的数据，显然如果算法时间复杂度是 $O(n\log n)$ 级别会非常吃紧，如果常数很大会直接 T 飞。那么我们要尽量找到 $O(n)$ 的算法，也就证明这里的**判重需要是 $O(1)$**。

有人又会想到用 unordered_map，我也试过，依然是 T 四个点（有一个点从 $1.20s \rightarrow 1.07s$）。为什么？我们要注意 unordered_map **平均复杂度**才是 $O(1)$。**最坏情况**可以达到 $O(n)$。当然，这种情况概率非常小，但是如果两个 unordered_map 这种情况出现的次数就会增加，就可能导致我们的代码被卡掉。

后来我在写题解的时候灵光一现，想到了再哈希一次的做法。我们选取一个空间能开下的大模数，并建立一个判重数组，对于每个哈希过的字符串，将它的哈希值取模后存入判重数组，用的时候比对就好。

当然，这种做法存在**不严谨性**。如果两个不同哈希值模数相同，就会导致对答案的贡献缺失。一种解决办法是**双哈希**，能保证正确性，但是太麻烦了弱弱的我也懒得写，如果有大佬有兴趣可以尝试。我的方法是就找一个大模数，而且是质数，剩下的就是看运气了。具体实现看代码。

### 复杂度分析

**注意：我们将 $TotalS$，$TotalT$ 引用为 $p$，$q$。**

1. 对于读入后的预处理，我们要把 $T$ 中的所有字符串哈希并存入一个 unordered_map，根据 unordered_map 的平均复杂度 $O(1)$，推得这一步的复杂度是 $O(qm)$。

2. 预处理三个快速幂，$O(3\log len)$ 我们近似为一个常数，可以忽略，不计入总复杂度。

3. 对于计算答案，我们要枚举 $S$ 中的所有字符串，对每个字符串倍长哈希后遍历一遍，比对后还要 $O(1)$ 判重，之后 $O(1)$ 查找 $T$ 中的贡献，所以最后的复杂度是 $O(pn)$。

所以最后的总复杂度大概是是 $O(pn+qm)$。当然还有很大的常数和 unordered_map 的不稳定性。

## 代码

思路都懂，细节都理解，其实代码就能自己写出来了。有一些具体实现细节见代码中的注释。

```cpp
/* 其实代码好像还挺简单的hhhh */
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
#include <unordered_map>

using namespace std;
typedef unsigned long long ull;
const int maxtot = 20005;
const int maxm = 4e6+5;
const int base = 131; //基底
const int mod = 19260817; //判重模数，不会有人卡这个吧？

string S[maxtot], T[maxtot];
int totalT, totalS, n, m;
int mid;//前后串的长度
ull Pow[maxm];//预处理基底的幂，其实只用3个
unordered_map<ull,int> hashT; //存储T的所有字符串
ull Hash[maxm]; //求双旋转字符串的哈希数组
int cnt[mod]; //判重数组

ull qmi(ull a,ull b){//快速幂，ull自动溢出取模
    ull res = 1;
    while (b){
        if (b & 1) res *= a;
        a *= a;
        b >>= 1;
    }
    return res;
}

ull make_hash(string s, int len){//一次性哈希
    ull res = 0;
    for (int i = 0; i < len; i ++){
        res = res*base + s[i];
    }
    return res;
}

ull get_hash(int l,int r){//需要反复查找的哈希值
    return Hash[r] - Hash[l-1]*Pow[r-l+1];
}

int deal(string s, int len, int t){//计算贡献
    int res = 0, length = len-mid;
    /* substr大法吼啊！ */
    string temp = "0";
    temp += s.substr(0,mid);
    temp += s.substr(0,mid);
    for (int i = 1; i <= mid<<1; i ++){
        Hash[i] = Hash[i-1]*base + temp[i];
    }
    ull hashVal = make_hash(s.substr(mid,len-mid), len-mid);//后串前缀的哈希

    for (int i = 1, j = mid; i <= mid; i ++, j ++){
        /* 判重。常数大了1倍，想要快的可以直接删掉 */
        if (cnt[get_hash(i, j)%mod] == t){
            /* 改用int赋值，就不用memset恶心人了 */
            continue;
        }
        cnt[get_hash(i, j)%mod] = t;
        /* ———————————————————————————————— */
        if (get_hash(i, i+length-1) == hashVal){//如果求得两前缀相等
            res += hashT[get_hash(i+length, j)];//统计匹配串的答案
        }
    }

    return res;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> totalS >> totalT >> n >> m;
    for (int i = 1; i <= totalS; i ++){
        cin >> S[i];
    }
    for (int i = 1; i <= totalT; i ++){
        cin >> T[i];
    }
    mid = (n+m) >> 1;
    /* 预处理我们需要的三个base的幂 */
    Pow[mid] = qmi(base,mid), Pow[m] = qmi(base,m), Pow[(n-m)>>1] = qmi(base,(n-m)>>1);

    /* 对T中的所有字符串哈希 */
    for (int i = 1; i <= totalT; i ++){
        /* 就想用数组一样用 unordered_map */
        hashT[make_hash(T[i], m)] ++;
    }

    int ans = 0;
    for (int i = 1; i <= totalS; i ++){
        ans += deal(S[i], n, i);//累加答案
    }

    cout << ans << endl;
    return 0;
}
```

## 总结

终于把这篇题解写完了。可能会比较啰嗦，也可能会有错误，欢迎指出！

写这篇题解收获真的挺大的，我一开始 T 四个点吸氧就满意了，后来不断思考，最后正式通过了，大概交了 40 多遍。

还有就是希望管理修一下题面，加几组 hack，免的再耽误后人。




---

## 作者：封禁用户 (赞：3)

可以假定集合T中的字符串S为较长的字符串，集合S中的字符串T为较短的字符串。

若S+T为双螺旋字符串，比如S为字符串vijosos，若存在字符串T，时得S+T为双螺旋串，那么一定有os+T，为vijosvijos的子序列。

那么我们可以先找os在ijosvijos的位置，然后反推出T，再在map中查询字符串T的个数。所以开始的时候预处理一下T集合中所有串的哈希值，用map计数就可以了，综合时间复杂度为O(n^2+2nlogn)。


---

## 作者：Super_Cube (赞：1)

# Solution

什么时候修下数据范围啊，看得我气笑了。

假定 $n\ge m$。记 $p=|S|,q=|T|$。令 $k=\dfrac{n+m}{2}$。

枚举 $S$ 中的所有字符串，计算 $T$ 中有多少个字符串能与其构成双旋转字符串。

设当前枚举到的字符串为 $S_i$，取出其前 $k$ 个字符构成的子串 $w$。若 $S_i$ 中后 $n-k$ 个字符拼上 $T$ 中某字符串后与 $w$ 循环同构则说明 $S_i$ 能与该字符串凑出双螺旋字符串。

通过字符串哈希可以简便地实现上述判断与统计部分。

时间复杂度：$O(pn+qm)$。

后话：此题数据极水，通过了并不一定代表你的代码是正确的。

---

## 作者：DengDuck (赞：1)

没啥好说的，出题人给了一个假的数据范围，出题人您吉祥。

首先我们可以假定 $n>m$，如果 $m>n$，可以交换 $S,T$，然后每个字符串翻转，这样可以证明是等价的。

我们设 $k=\dfrac 1 2 (n+m)$。

我们先把 $T$ 所有的字符串的哈希值的出现次数压到一个 `map` 中。

那么我们对于每一个 $S$ 中的字符串 $S_i$，我们提取前 $k$ 个字符，然后利用哈希求出每一种循环移位的哈希值。

对于每一种哈希值，第一步是判重，就是有没有其他的循环长得和你一样，防止重复统计。

第二步是看 $[k+1,n]$ 这一部分的哈希值，然后我们就能推出后面要加什么字符串才能和前面循环移位的 $[1,k]$ 的字符串等价。

知道了需要放的哈希值，直接去 `map` 那里调用出现次数就行了。

我写了一个双哈希，主要是为了过那个民间的加强版。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define pb push_back
#define pLL pair<LL,LL>
#define fir first
#define sec second
using namespace std;
const LL N=1e6+5;
// const LL K;
const LL M=1e6+5;
const LL P=1331,P2=1331;
const LL mod=1e9+9,mod2=1e9+9;
LL A,B,n,m,pre[M],pre2[M],pw[2*M],pw2[2*M],ans;
unordered_map<LL,LL>ma;
string S[N],C[N],tmp[N];
LL gt(LL l,LL r)
{
    return (pre[r]-pre[l-1]*pw[r-l+1]%mod+mod)%mod;
}
LL gt2(LL l,LL r)
{
    return (pre2[r]-pre2[l-1]*pw2[r-l+1]%mod2+mod2)%mod2;
}
int main()
{
    scanf("%lld%lld%lld%lld",&A,&B,&n,&m);
    pw[0]=1,pw2[0]=1;
    for(int i=1;i<=n+m;i++)pw[i]=pw[i-1]*P%mod,pw2[i]=pw2[i-1]*P2%mod2;
    for(int i=1;i<=A;i++)
    {
        cin>>S[i];
    }
    for(int i=1;i<=B;i++)
    {
        cin>>C[i];
    }
    if(m>n)
    {
        for(int i=1;i<=A;i++)reverse(S[i].begin(),S[i].end());
        for(int i=1;i<=B;i++)reverse(C[i].begin(),C[i].end());
        for(int i=1;i<=B;i++)tmp[i]=C[i];
        for(int i=1;i<=A;i++)C[i]=S[i];       
        for(int i=1;i<=B;i++)S[i]=tmp[i];
        swap(A,B),swap(n,m);
        // for(itn )
    }
    for(int i=1;i<=A;i++)S[i]=' '+S[i];
    for(int i=1;i<=B;i++)C[i]=' '+C[i];
    
    for(int i=1;i<=B;i++)
    {
        LL cnt=0,cnt2=0;
        for(int j=1;j<=m;j++)
        {
            cnt=(cnt*P%mod+C[i][j]-'a')%mod;
            cnt2=(cnt2*P2%mod2+C[i][j]-'a')%mod2;
        }
        ma[cnt*P+cnt2]++;
    }
    LL k=(n+m)/2;
    for(int i=1;i<=A;i++)
    {
        LL Suf=0,Suf2=0,Suflen=k-m;
        for(int j=k+1;j<=n;j++)
        {
            Suf=(Suf*P%mod+S[i][j]-'a')%mod;
            Suf2=(Suf2*P2%mod2+S[i][j]-'a')%mod2;
        }
        Suf=Suf*pw[m]%mod;
        Suf2=Suf2*pw2[m]%mod2;
        for(int j=1;j<=k;j++)
        {
            pre[j]=(pre[j-1]*P%mod+S[i][j]-'a')%mod;
            pre2[j]=(pre2[j-1]*P2%mod2+S[i][j]-'a')%mod2;
        }
        unordered_map<LL,LL>hav;
        for(int j=1;j<=k;j++)
        {
            LL hsh=(pre[j]+gt(j+1,k)*pw[j]%mod)%mod;
            LL hsh2=(pre2[j]+gt2(j+1,k)*pw2[j]%mod2)%mod2;
            if(hav.count(hsh*P+hsh2))continue;
           // cout<<hsh<<' '<<Suf<<endl;
            hav[hsh*P+hsh2]++;
            LL t1=(hsh-Suf+mod)%mod;
            LL t2=(hsh2-Suf2+mod2)%mod2;
            ans+=ma[t1*P+t2];
        }
    }
    printf("%lld",ans);
}
//RP++
```

---

## 作者：Dovish (赞：0)

## 题意

给你两个字符串集合，问两两拼接起来后有多少对的前半和后半是循环同构的，保证拼接起来的长度一定为偶数。

## 题解

显然，容易发现，我们可以直接枚举较长的字符串去找较小的字符串。

不妨钦定 $|S|\ge|T|$，对于 $[S_{mid+1},S_{len}]$ 这一段，我们知道其拼接上 $T$ 后和 $[S_1,S_{mid}]$ 循环同构。

我们可以通过哈希枚举 $[S_{mid+1},S_{len}]$ 在 $[S_1,S_{mid}]$ 中出现的位置，进而确定 $T$ 的哈希值。

注意，对于同一个 $S$，如果多次求到了同样的 $T$ 的哈希值只能算一遍。

## 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define per(i,a,b) for(register int i=(a);i>=(b);--i)
#define edge(i,u) for(int i=head[u];i;i=e[i].next)
#define lc(u) tre[u].ls
#define rc(u) tre[u].rs
#define pii pair<int,int>
#define pdd pair<double,double>
#define mp(a,b) make_pair(a,b)
#define pb(a) push_back(a)
#define fst first
#define sed second
using namespace std;
const int N=2e6+10,M=1e6+10,inf=1e9,mod=1e9+7;
const int mod1=998244353,mod2=1004535809,base1=233,base2=2333;
int bs1[N<<1],bs2[N<<1];
struct hanser
{
	int val1,val2,len;
	hanser operator+(const hanser&b)
	{
		hanser g;
		g.len=len+b.len;
		g.val1=(1ll*val1*bs1[b.len]%mod1+b.val1)%mod1;
		g.val2=(1ll*val2*bs2[b.len]%mod2+b.val2)%mod2;
		return g;
	}
	hanser operator-(const hanser&b)
	{
		hanser g;
		g.len=len-b.len;
		g.val1=(val1-1ll*b.val1*bs1[g.len]%mod1+mod1)%mod1;
		g.val2=(val2-1ll*b.val2*bs2[g.len]%mod2+mod2)%mod2;
		return g;
	}
	bool operator==(const hanser&b)const
	{
		return len==b.len&&val1==b.val1&&val2==b.val2;
	}
	bool operator<(const hanser&b)const
	{
		if(len!=b.len)
		return len<b.len;
		if(val1!=b.val1)
		return val1<b.val1;
		return val2<b.val2;
	}
};
hanser hs[N<<1];
int n,m,lens,lent;
string s[N],t[N];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	bs1[0]=bs2[0]=1;
	rep(i,1,2*N-1)
	{
		bs1[i]=(ll)bs1[i-1]*base1%mod1;
		bs2[i]=(ll)bs2[i-1]*base2%mod2;
	}
	cin>>n>>m>>lens>>lent;
	rep(i,1,n){cin>>s[i];s[i]=" "+s[i];}
	rep(i,1,m){cin>>t[i];t[i]=" "+t[i];}
	
	if(lent>lens)
	{
		swap(n,m);
		swap(lent,lens);
		rep(i,1,max(n,m))
		swap(s[i],t[i]);
	}
	int ans=0;
	map<hanser,int>q;
	rep(i,1,m)
	{
		hanser d={0,0,0};
		rep(j,1,lent)
		d=d+hanser{t[i][j],t[i][j],1};
		q[d]++;
	}
	rep(i,1,n)
	{
		int mid=(lens+lent)/2;
		rep(j,1,mid)
		hs[j]=hs[j-1]+hanser{s[i][j],s[i][j],1};
		rep(j,1,mid)
		hs[j+mid]=hs[j+mid-1]+hanser{s[i][j],s[i][j],1};
		int len=lens-mid;
		hanser sdt=hanser{0,0,0};
		rep(j,mid+1,lens)
		sdt=sdt+hanser{s[i][j],s[i][j],1};
		
		set<hanser>ls;
		rep(j,1,mid)
		if(hs[j+len-1]-hs[j-1]==sdt)
		ls.insert(hs[j+mid-1]-hs[j+len-1]);
		for(auto u:ls)ans+=q[u];
		
	}
	cout<<ans<<'\n';
}
```

---

## 作者：mRXxy0o0 (赞：0)

# 题意

解释一下“双旋转性”，就是左半边和右半边循环同构。求两两组合符合这一性质的对数。

# 分析

不妨设 $N\ge M$，$N<M$ 可类似求得。

对于 $S$ 集合中的串，左边就会剩下一部分和右边拼在一起，我们考虑求得右边可拼的所有串。这个问题可以用 KMP 解决。

具体地，把多出来的一点作为模式串，求得左边每一个完全匹配上的位置（写着写着发现自己做复杂了，这里可以哈希）。然后把剩下部分的哈希值扔到 `unordered_map` 里。注意，这里需要去重，具体方法也可以用 `unordered_map`。

然后，对于 $T$ 集合里的串，直接求哈希值再加上贡献就好了。

脑测一下，感觉当 $N=M$ 时复杂度会退化，因为要存 $TotalS\times N$ 个哈希值。由于打的是离线赛，所以考虑优化一下。

发现只要求一下最小表示法就好了，这里不能偷懒写哈希，那还不如不优化。然后每个串就可以只存一个值了。

至此，代码已经可以跑出 283ms 的时间。但是脑中还有一些懒得打的优化。

首先，因为无论是 `map` 还是 `unordered_map`，最坏的复杂度都不是 $O(1)$，还不如用一个静态数组存下来，再二分查询。相应的，应当交换算贡献和加答案的位置，即存下 $T$ 串的哈希值，在 $S$ 集合中的每一个串的合法位置查询，使时间复杂度为 $O(\text{完全匹配上的位置数}\times \log TotalT)$，带的是二分的小常。

然后，也可以考虑把输入的一堆串去一下重。假设有一较强的串，使仅仅这一个串就要存 $N$ 个哈希值，然后全是重复的。这样感觉会跑得很慢。

## 吐槽

这什么神必题面：$1\le N\le 100;1\le M\le 100;1\le TotalS\le 100;1\le TotalT\le 100,2\le N\times TotalS+M\times TotalT\le 4\times10^6$

你告诉我这几个乘起来有 $4\times10^6$?

望修。

---


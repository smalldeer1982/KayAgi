# [ZJOI2015] 诸神眷顾的幻想乡

## 题目描述

幽香是全幻想乡里最受人欢迎的萌妹子，这天，是幽香的 $2600$ 岁生日，无数幽香的粉丝到了幽香家门前的太阳花田上来为幽香庆祝生日。

粉丝们非常热情，自发组织表演了一系列节目给幽香看。幽香当然也非常高兴啦。

这时幽香发现了一件非常有趣的事情，太阳花田有 $n$ 块空地。

在过去，幽香为了方便，在这 $n$ 块空地之间修建了 $n-1$ 条边将它们连通起来。

也就是说，这 $n$ 块空地形成了一个树的结构。

有 $n$ 个粉丝来到了太阳花田上。

为了表达对幽香生日的祝贺，他们选择了 $c$ 种颜色的衣服，每种颜色恰好可以用一个 $0$ 到 $c-1$ 之间的整数来表示。

并且每个人都站在一个空地上，每个空地上也只有一个人。

这样，整个太阳花田就花花绿绿了。幽香看到了，感觉也非常开心。

粉丝们策划的一个节目是这样的，选中两个粉丝 $A$ 和 $B$（$A$ 和 $B$ 可以相同），然后A所在的空地到B所在的空地的路径上的粉丝依次跳起来（包括端点）。

这样幽香就能看到一个长度为 $A$ 到 $B$ 之间路径上的所有粉丝的数目（包括 $A$ 和 $B$）的颜色序列。

一开始大家打算让任意两个粉丝（注意：$A,B$ 和 $B,A$ 是不同的，他们形成的序列刚好相反）都来一次。

但是有人指出这样可能会出现一些一模一样的颜色序列，会导致审美疲劳。

于是他们想问，在这个树上，一共有多少可能的不同的颜色序列幽香可以看到呢？

由于太阳花田的结构比较特殊，只与一个空地相邻的空地数量不超过 $20$ 个。

## 说明/提示

#### 数据规模与约定

- 对于 $15\%$ 的数据，$n\le2\times 10^3$。
- 另有 $5\%$ 的数据，所有空地都至多与两个空地相邻。
- 另有 $5\%$ 的数据，除一块空地与三个空地相邻外，其他空地都分别至多与两个空地相邻。
- 另有 $5\%$ 的数据，除某两块空地与三个空地相邻外，其他空地都分别至多与两个空地相邻。
- 对于 $100\%$ 的数据，$1\le n\le10^5$，$1\le c\le10$，$1 \leq u, v \leq n$。

## 样例 #1

### 输入

```
7 3
0 2 1 2 1 0 0
1 2
3 4
3 5
4 6
5 7
2 5```

### 输出

```
30```

# 题解

## 作者：辰星凌 (赞：38)

（本文已被阉割，原文 [广义 $\text{SAM}$ 详解](https://www.luogu.com.cn/blog/ChenXingLing/solution-p6139) 进行增修后转到了[模板题](https://www.luogu.com.cn/problem/P6139)处）


传送门：[诸神眷顾的幻想乡 $\text{[ZJOI2015] [P3346]}$](https://www.luogu.com.cn/problem/P3346) [$\text{[Bzoj3926]}$](https://www.lydsy.com/JudgeOnline/problem.php?id=3926)

### **【题目描述】**

给出一颗叶子结点不超过 $20$ 个的无根树，每个节点上都有一个不超过 $10$ 的数字，求树上本质不同的路径个数（两条路径相同定义为：其路径上所有节点上的数字依次相连组成的字符串相同）。

### **【分析】**

首先有一个很麻烦的地方是路径可以拐弯（即两端点分别在其 $lca$ 两个不同儿子节点的子树中），而 $\text{Trie}$ 树和各种自动机在“接受”字符串时都是以根为起点从上往下径直走到底（什么？跳 $parent$ 树？你跳任你跳，跳完还是直的）

所以要想办法把路径捋直，瞎 $yy$ 可能不太容易想出来，这里直接抛结论：

> 一颗无根树上任意一条路径必定可以在以某个叶节点为根时，变成**一条从上到下的路径**（利于广义     $\text{SAM}$ 的使用）。

注意到题目中说叶节点不超过 $20$ 个，这意味着什么？

暴力枚举每一个叶节点作为根节点遍历整棵树啊！

**将一共 $cnt_{leaf}$ 颗树中的所有前缀串都抽出来建立广义 $\text{SAM}$，然后直接求本质不同的子串个数。** 其中前缀串定义为从根节点（无根树的某个叶子结点）到任意一个节点的路径所构成的字符串（实际上就是将 $cnt_{leaf}$ 颗 $\text{Trie}$ 树合在了一起跑广义 $\text{SAM}$）。

**注意数组大小和空间限制。**

### **【Code (离线)】**

（本题 $\text{Trie}$ 树的构造方法与其他相比较为特别）

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<queue>
#define Re register int
#define LL long long
using namespace std;
const int N=4e6+5,N20=2e6+3,Nn=1e5+3;
int n,m,o,x,y,t,C,du[Nn],co[Nn],head[Nn];LL ans;
struct QAQ{int to,next;}a[Nn<<1];
inline void add(Re x,Re y){a[++o].to=y,a[o].next=head[x],head[x]=o;}
inline void in(Re &x){
    int fu=0;x=0;char c=getchar();
    while(c<'0'||c>'9')fu|=c=='-',c=getchar();
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    x=fu?-x:x;
}
struct Trie{
    int O,c[N20],fa[N20],tr[N20][10];
    Trie(){O=1;}
    inline int insert(Re p,Re ch){//在p后面插入一个ch
        if(!tr[p][ch])tr[p][ch]=++O,c[O]=ch,fa[O]=p;
        return tr[p][ch];
    }
}T1;
struct Suffix_Automaton{    
    int O,pos[N],link[N],trans[N][10],maxlen[N];queue<int>Q;
    Suffix_Automaton(){O=1;}
    inline int insert(Re ch,Re last){
        Re x,y,z=++O,p=last;maxlen[z]=maxlen[last]+1;
        while(p&&!trans[p][ch])trans[p][ch]=z,p=link[p];
        if(!p)link[z]=1;
        else{
            x=trans[p][ch];
            if(maxlen[p]+1==maxlen[x])link[z]=x;
            else{
                y=++O;maxlen[y]=maxlen[p]+1;
                for(Re i=0;i<C;++i)trans[y][i]=trans[x][i];
                while(p&&trans[p][ch]==x)trans[p][ch]=y,p=link[p];
                link[y]=link[x],link[z]=link[x]=y;
            }
        }
        return z;
    }
    inline void build(){ 
        for(Re i=0;i<C;++i)if(T1.tr[1][i])Q.push(T1.tr[1][i]);
        pos[1]=1;
        while(!Q.empty()){
            Re x=Q.front();Q.pop();
            pos[x]=insert(T1.c[x],pos[T1.fa[x]]);
            for(Re i=0;i<C;++i)if(T1.tr[x][i])Q.push(T1.tr[x][i]);
        }
    }
    inline void sakura(){
        for(Re i=2;i<=O;++i)ans+=maxlen[i]-maxlen[link[i]];
        printf("%lld\n",ans); 
    }
}SAM;
inline void dfs(Re x,Re fa,Re fap){//遍历构造Trie树 
    Re xp=T1.insert(fap,co[x]);//记录在Trie树上的位置，方便下次直接使用
    for(Re i=head[x],to;i;i=a[i].next)
        if((to=a[i].to)!=fa)dfs(to,x,xp);
}
int main(){
//  freopen("123.txt","r",stdin);
    in(n),in(C),m=n-1;
    for(Re i=1;i<=n;++i)in(co[i]);
    while(m--)in(x),in(y),add(x,y),add(y,x),++du[x],++du[y];
    for(Re i=1;i<=n;++i)if(du[i]==1)dfs(i,0,1);//依次把每个叶子节点作为根插入Trie树
    SAM.build(),SAM.sakura();
}
```

### **【Code (在线)】**

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<queue>
#define Re register int
#define LL long long
using namespace std;
const int N=4e6+5,N20=2e6+3,Nn=1e5+3;
int n,m,o,x,y,t,C,du[Nn],co[Nn],head[Nn];LL ans;
struct QAQ{int to,next;}a[Nn<<1];
inline void add(Re x,Re y){a[++o].to=y,a[o].next=head[x],head[x]=o;}
inline void in(Re &x){
    int fu=0;x=0;char c=getchar();
    while(c<'0'||c>'9')fu|=c=='-',c=getchar();
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    x=fu?-x:x;
}
struct Suffix_Automaton{
    int O,link[N],trans[N][10],maxlen[N];
    Suffix_Automaton(){O=1;}
    inline int insert(Re ch,Re last){
        if(trans[last][ch]){
            Re p=last,x=trans[p][ch];
            if(maxlen[p]+1==maxlen[x])return x;
            else{
                Re y=++O;maxlen[y]=maxlen[p]+1;
                for(Re i=0;i<10;++i)trans[y][i]=trans[x][i];
                while(p&&trans[p][ch]==x)trans[p][ch]=y,p=link[p];
                link[y]=link[x],link[x]=y;
                return y;
            }
        }
        Re z=++O,p=last;maxlen[z]=maxlen[last]+1;
        while(p&&!trans[p][ch])trans[p][ch]=z,p=link[p];
        if(!p)link[z]=1;
        else{
            Re x=trans[p][ch];
            if(maxlen[p]+1==maxlen[x])link[z]=x;
            else{
                Re y=++O;maxlen[y]=maxlen[p]+1;
                for(Re i=0;i<10;++i)trans[y][i]=trans[x][i];
                while(p&&trans[p][ch]==x)trans[p][ch]=y,p=link[p];
                link[y]=link[x],link[z]=link[x]=y;
            }
        }
        return z;
    }
    inline void sakura(){
        for(Re i=2;i<=O;++i)ans+=maxlen[i]-maxlen[link[i]];
        printf("%lld\n",ans); 
    }
}SAM;
inline void dfs(Re x,Re fa,Re fap){//遍历在线构造SAM
    Re xp=SAM.insert(co[x],fap);//记录x在SAM上的位置，方便下次直接使用
    for(Re i=head[x],to;i;i=a[i].next)
        if((to=a[i].to)!=fa)dfs(to,x,xp);
}
int main(){
//  freopen("123.txt","r",stdin);
    in(n),in(C),m=n-1;
    for(Re i=1;i<=n;++i)in(co[i]);
    while(m--)in(x),in(y),add(x,y),add(y,x),++du[x],++du[y];
    for(Re i=1;i<=n;++i)if(du[i]==1)dfs(i,0,1);//依次把每个叶子节点作为根插入Trie树
    SAM.sakura();
}
```

---

## 作者：zcysky (赞：26)

个人认为ls的题解存在问题。不知道楼上神犇可否有空跟本蒟蒻聊聊此题正解？

这是2015年NOI集训队15人论文题，做法就是在Trie上做后缀自动机。这样的话建立的就是一个广义后缀自动机。

我来简单说下广义后缀自动机的注意点吧：

简单的实现可以每次ins完了之后，将当前指针指回SAM的根节点。

**但是这必须在保证每次加入的串不会相同的情况下才可以实现。否则会导致重复加点的很多问题。**

所以正确的做法是每次加入前判断当前节点在SAM中是否已经存在，再做出判断即可。

详细还请见源代码。

```cpp
//                                                     /*[*/#include<stdio.h>//
//                         #include<stdlib.h>//]++++[->++[->+>++++<<]<][(c)2013]
//                        #ifndef                                           e//[o
//                       #include<string.h>//]![misaka.c,size=3808,crc=d0ec3b36][
//                      #define e                                           0x1//
//                     typedef struct{int d,b,o,P;char*q,*p;}f;int p,q,d,b,_=0//|
//                  #include __FILE__//]>>>[->+>++<<]<[-<<+>>>++<]>>+MISAKA*IMOUTO
//                #undef e//[->[-<<+<+<+>>>>]<<<<<++[->>+>>>+<<<<<]>+>+++>+++[>]]b
//             #define e(c)/**/if((_!=__LINE__?(_=__LINE__):0)){c;}//[20002,+[-.+]
//            ,O,i=0,Q=sizeof(f);static f*P;static FILE*t;static const char*o[]={//
//          "\n\40\"8oCan\40not\40open %s\n\0aaFbfeccdeaEbgecbbcda6bcedd#e(bbed$bbd",
//        "a6bgcdbbccd#ead$c%bcdea7bccde*b$eebbdda9bsdbeccdbbecdcbbcceed#eaa&bae$cbe",
//       "e&cbdd$eldbdeedbbdede)bdcdea&bbde1bedbbcc&b#ccdee&bdcdea'bbcd)e'bad(bae&bccd",
//      "e&bbda1bdcdee$bbce#b$c&bdedcd%ecdca4bhcdeebbcd#e$b#ecdcc$bccda7bbcc#e#d%c*bbda",
//     ">bad/bbda"};static int S(){return(o[p][q]);}static/**/int/**/Z=0  ;void/**/z(int//
//    l){if(/**/Z-l){Z=l;q++;if(p<b*5&&!S()){p+=b;q=0;}}}int main(int I,    /**/char**l){//
//   d=sizeof(f*);if(1<(O=_)){b=((sizeof(o)/sizeof(char*))-1)/4;q=22; p=     0;while(p<b*5){
//  /*<*/if(Z-1){d=S()>96;i=S()-(d?96:32) ;q++;if(p<b*5&&!S()){p+=b;  q=      0;}Z=1;}/*[[*/
//  while(i){_=o[0][S()-97];I=_-10?b:1;   for( ;I--;)putchar(_ );if   (!      --i||d)z(~i );}
// if(p==b*5&&O){p-=b;O--;}}return 0U;   }if(! (P=( f*)calloc /*]*/  (Q        ,I)))return 1;
// {;}for(_=p=1;p<I;p++){e(q=1);while    (q<   p&&  strcmp(  l[p     ]         ,l[(q)]))++  q;
// t=stdin;if(q<p){(void)memcpy/* "      */    (&P  [p],&P   [q     ]          ,Q);continue ;}
//if(strcmp(l[p],"-")){t=fopen(l         [     p]   ,"rb"   )                  ;if(!t ){{;}  ;
//printf(05+*o,l[p ]);return+1;                      {;}                       }}_=b= 1<<16   ;
//*&O=5;do{if(!(P[p].q=realloc   (P[p].q,(P[p].P     +=       b)+1))){return   01;}O   &=72   /
//6/*][*/;P[p].o+=d=fread(P[p]      .q       +P[     p           ].       o,  1,b,t)   ;}//
// while(d==b)      ;P [p].q[       P[       p]                  .o       ]=  012;d    =0;
// e(fclose(t        )  );P         [p]      .p                  =P[      p]  .q;if    (O)
// {for(;d<P[            p]          .o     ;d=                   q+     1)    {q=     d;
//  while(q<P[                        p].o&&P[                    p].q[q]-     10     ){
//  q++;}b=q-d;                         _=P                         [p].        d     ;
//  if(b>_){/*]b                                                                */
//   P[p].d=b;}{;                                                                }
//   #undef/*pqdz'.*/  e//                                                      ;
//   #define/*s8qdb]*/e/**/0                                                   //
//   //<<.<<.----.>.<<.>++.++<                                              .[>]
//   /*P[*/P[p].b++;continue;}}}t=                                       stdout;
//  for (p=1;p<I;p++){/**/if(P[p].b>i                               ){i=P[p].b;}}
// if  (O){for(p=0;p<i;p++){q=0;/*[*/while(I               >++q){_=P[q].p-P[q ].q;
//b=   0;if(_<P[q ].o){while(012-*P[q].p)     {putchar(*(P[q].p++));b++;}P[q]. p++;
//}   ;while (P[  q].d>b++)putchar(040);}             putchar(10);}return 0;}p   =1;
//   for(;   p<I   ;p++)fwrite(P[p] .q,P[              p].o,1,t);return 0 ;}//
//  #/*]     ]<.    [-]<[-]<[- ]<[    -]<               [-  ]<;*/elif  e    //b
// |(1        <<     ( __LINE__        /*               >>   `*//45))  |     01U
//             #                       /*               */     endif            //
#include<bits/stdc++.h>
typedef long long ll;
#define N 4000005
using namespace std;
ll ans=0;
int n,m,d[N],head[N],tot=0;
struct Edge{
    int u,v,next;
}G[N];
void addedge(int u,int v){
    G[++tot].u=u;G[tot].v=v;G[tot].next=head[u];head[u]=tot;
    G[++tot].u=v;G[tot].v=u;G[tot].next=head[v];head[v]=tot;
}
struct SuffixAutoMaton{
    int ch[N][10],fa[N],l[N];
    int rt,last,cnt;
    void init(){rt=last=++cnt;}
    int newnode(int x){l[++cnt]=x;return cnt;}
    int ins(int p,int c){
        if(ch[p][c]){
            int q=ch[p][c];
            if(l[q]==l[p]+1)last=q;
            else{
                int nq=newnode(l[p]+1);last=nq;
                memcpy(ch[nq],ch[q],sizeof(ch[q]));
                fa[nq]=fa[q];fa[q]=nq;
                for(;ch[p][c]==q;p=fa[p])ch[p][c]=nq;
            }
        }
        else{
            int np=newnode(l[p]+1);last=np;
            for(;p&&(!ch[p][c]);p=fa[p])ch[p][c]=np;
            if(!p)fa[np]=rt;
            else{
                int q=ch[p][c];
                if(l[q]==l[p]+1)fa[np]=q;
                else{
                    int nq=newnode(l[p]+1);
                    memcpy(ch[nq],ch[q],sizeof(ch[q]));
                    fa[nq]=fa[q];fa[q]=fa[np]=nq;
                    for(;ch[p][c]==q;p=fa[p])ch[p][c]=nq;
                }
            }
        }
        return last;
    }
    void calc(){
        ans=0;
        for(int i=1;i<=cnt;i++)ans+=l[i]-l[fa[i]];
    }
}sam;
int val[N];
void dfs(int u,int f,int p){
    int t=sam.ins(p,val[u]);
    for(int i=head[u];i;i=G[i].next){
        int v=G[i].v;if(v==f)continue;
        dfs(v,u,t);
    }
}
inline int read(){
    int f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
int main(){
    n=read();m=read();sam.init();
    for(int i=1;i<=n;i++)val[i]=read();
    for(int i=1;i<n;i++){
        int u=read(),v=read();
        addedge(u,v);d[u]++;d[v]++;
    }
    for(int i=1;i<=n;i++)if(d[i]==1)dfs(i,0,sam.rt);
    sam.calc();
    cout<<ans<<endl;
}
```
啊？你问我哪来的御坂妹妹？知乎上抄来的。

http://www.ioccc.org/2013/misaka/misaka.c


---

## 作者：kczno1 (赞：8)

题意:树上任选一条路，问有多少种颜色序列不同的选择。

由于只有20个叶子，而一条路一定是以起点的子树里某个叶子为根的树上的一条，

把每个叶子为根的树插到trie里，之后就是问trie里有多少个不同子串。

在trie上跑后缀自动机，之后sam上每个节点的max-min+1就是他所代表的子串的个数，

而且已经所有子串都包括进去了。

而max就是他的len；min就是parent的len+1。

实际上，我们不用真的建trie，直接插到sam里就行了，反正有相同的也会被当作另一个的parent。

```cpp
#include<cstdio>
using namespace std;

#define ll long long
#define N 100010
#define TOT 2000000
int col[N];
int n,C,x,y,i;
int du[N],t[N];
struct edge
{
    int to,next;
}l[N<<1];
void add_e(int x,int y)
{
    static int num=0;
    l[++num]=(edge){y,t[x]};t[x]=num;
    ++du[y];
}

struct SAM
{
    int pa[TOT],len[TOT],ch[TOT][10],tot;
    void init()
    {
        tot=1;
        len[0]=-1;for (i=0;i<C;++i) ch[0][i]=1;
    }
    
    int ins(int c,int p)
    {
        int np=++tot;len[np]=len[p]+1;
        for (;!ch[p][c];p=pa[p]) ch[p][c]=np;
        int q=ch[p][c];
        if (len[q]==len[p]+1) pa[np]=q;
        else
        {
           int nq=++tot;
           len[nq]=len[p]+1;
           pa[nq]=pa[q];for (int i=0;i<C;++i) ch[nq][i]=ch[q][i];
           pa[q]=pa[np]=nq;
           for (;ch[p][c]==q;p=pa[p]) ch[p][c]=nq;
        }
        return np;
    }
    
    void calc_ans()
    {
        ll ans=0;
        for (i=2;i<=tot;++i) ans+=len[i]-len[pa[i]];
        printf("%lld",ans);
    }
}sam;

  void travel(int x,int from,int p)
  {
        p=sam.ins(col[x],p);
      for (int i=t[x];i;i=l[i].next)
      if ((y=l[i].to)!=from)
            travel(y,x,p);
  } 

int main()
{
    //freopen("1.in","r",stdin);freopen("1.out","w",stdout);
    scanf("%d%d",&n,&C);
    int i;
    for (i=1;i<=n;++i) scanf("%d",col+i);
    for (i=1;i<n;++i)
    {
        scanf("%d%d",&x,&y);
        add_e(x,y);add_e(y,x);
    }
    sam.init();
    for (i=1;i<=n;++i)
    if (du[i]==1) travel(i,0,1);
    sam.calc_ans();
}
```

---

## 作者：Gmt丶FFF (赞：2)

广义 SAM 板题，但有值得去思考的点。

在序列上找本质不同的子串就用 SAM 即可，而本题是在树上找，可以想到我们用广义 SAM 解决多个字符串的问题时是在字典树上建出 SAM，而本题也同理，我们在树上建出 广义 SAM，每个点的 last 设为父亲即可。

而由于这题是无根树，所以我们需要对于于每一个可能的根建，那这样时空复杂度会退化到 $O(n^2)$，所以我们考虑题中还有一个性质，即为叶子节点最多只有 $20$ 个，那么我们直接枚举每一个叶子作为根即可，这样一定能把所有情况考虑完。

证明：实际上每个串我们需要考虑正和反，而从这个串的两个端点延伸出去一定会到达至少两个不同的叶子，所以一定能统计到。

然后不知道有没有人跟我有一样的问题，假设我们插入两次相同的串能否正确统计，我尝试插入了两次 $00$ 这个串，发现第二次插入的 $00$ 与第一次并列，且不与根节点联通（在不算回边的情况下），所以不会出问题。

至于答案统计很简单，即为 $\sum len_i-len_{fa_i}$。

时间复杂度：$O(kn)$，其中 $k$ 为叶子节点数，且 $k\in [1,20]$。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<vector>
using namespace std;
const int N=4e6+5;
int n,m,cnt,last[N],l[N],s[N],r[N],fa[N];
vector<int>t[N],b[N];
struct node
{
	int son[11],link,len,num;
}a[N];
queue<int>q;
void dfs(int x)
{
	int len=b[x].size();
	for(int i=0;i<len;i++)
	{
		dfs(b[x][i]);
		a[x].num+=a[b[x][i]].num;
	}
}
void build(int y)
{
	for(int i=1;i<=n;i++)last[i]=fa[i]=l[i]=0;
	q.push(0);
	t[0].clear();
	t[0].push_back(y);
	a[0].link=-1;
	while(!q.empty())
	{
		int now=q.front();
		q.pop();
		int len=t[now].size();
		for(int i=0;i<len;i++)
		{
			if(fa[now]==t[now][i])continue;
			fa[t[now][i]]=now;
//			if(a[last[now]].son[s[t[now][i]]])
//			{
//				q.push(t[now][i]);
//				last[t[now][i]]=a[last[now]].son[s[t[now][i]]];
//				continue;
//			}
			int p=last[now],x=++cnt;
			l[t[now][i]]=l[now]+1;
			a[x].len=l[now]+1;
			a[x].num=1;
			while(p!=-1&&!a[p].son[s[t[now][i]]])a[p].son[s[t[now][i]]]=x,p=a[p].link;
			if(p==-1)a[x].link=0;
			else
			{
				int q=a[p].son[s[t[now][i]]];
				if(a[p].len+1==a[q].len)a[x].link=q;
				else
				{
					int tt=++cnt;
					a[tt]=a[q];
					a[tt].len=a[p].len+1;
					a[tt].num=0;
					while(p!=-1&&a[p].son[s[t[now][i]]]==q)a[p].son[s[t[now][i]]]=tt,p=a[p].link;
					a[q].link=a[x].link=tt;
				}
			}
			last[t[now][i]]=x;
			q.push(t[now][i]); 
		}
	}
//	for(int i=0;i<=cnt;i++)
//	{
//		cout<<i<<" "<<a[i].link<<" "<<a[i].len<<" :\n"; 
//		for(int j=0;j<=1;j++)cout<<a[i].son[j]<<" ";
//		cout<<endl;
//	}
}
long long query()
{
	long long res=0;
	for(int i=1;i<=cnt;i++)res+=(a[i].len-a[a[i].link].len);
	return res;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&s[i]);
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		t[x].push_back(y);
		t[y].push_back(x);
		r[x]++;
		r[y]++; 
	}
	for(int i=1;i<=n;i++)if(r[i]<=1)build(i);
	for(int i=1;i<=cnt;i++)b[a[i].link].push_back(i);
	dfs(0);
	long long res=query();
	printf("%lld",res);
	return 0;
}
```


---

## 作者：Prean (赞：2)

广义 SAM 比较简单的题/fad

题意：树上所有路径一共能够组成多少个本质不同子串？

并且数据保证最多只有20个叶子节点。

我们先来考虑一下一种特殊情况：

对于路径 $ [u,v] $，$ u $ 是 $ v $ 的父亲或 $ v $ 是 $ u $ 的父亲。

此时做法很明显：将整棵树当做一颗 Trie 树，建立其广义 SAM，然后根据套路求值。

但是很明显这样并不行，因为树并不是一条链。

这题最多只有 20 个叶子节点，暗示我们将每个叶子节点都当做根节点一遍，这样就一定没有考虑漏的情况。

然后就变成广义 SAM 板子题了。。。

code:
```cpp
#include<cstdio>
#include<queue>
const int M=1e5+5;
int n,m,tot,siz[M],col[M],lst[M*20];
long long ans;
struct Trie{
    int chi[11];
}t[M*20];
struct Node{
    int chi[11];
    int f,len;
}SAM[M*40];
struct Edge{
    int to;Edge*nx;
}e[M<<1],*h[M],*cnt=e;
inline void Add(const int&u,const int&v){
    *cnt=(Edge){v,h[u]};h[u]=cnt++;
    *cnt=(Edge){u,h[v]};h[v]=cnt++;
}
void qwq(int u,int q,int f){
    for(Edge*E=h[u];E;E=E->nx){
        int v=E->to;
        if(v==f)continue;
        if(!t[q].chi[col[v]])t[q].chi[col[v]]=++tot;
        qwq(v,t[q].chi[col[v]],u);
    }
}
void DFS(int u,int f){
    if(siz[u]==1){
    	if(!t[0].chi[col[u]])t[0].chi[col[u]]=++tot;
    	qwq(u,t[0].chi[col[u]],0);
	}
    for(Edge*E=h[u];E;E=E->nx){
        int v=E->to;
        if(v==f)continue;
        DFS(v,u);
    }
}
inline int Insert(int lst,int s){
    int q,p,nq,np;
    p=lst;np=++tot;
    SAM[np].len=SAM[p].len+1;
    for(;p&&!SAM[p].chi[s];p=SAM[p].f)SAM[p].chi[s]=np;
    if(!p)SAM[np].f=1;
    else{
        q=SAM[p].chi[s];
        if(SAM[q].len==SAM[p].len+1)SAM[np].f=q;
        else{
            nq=++tot;
            SAM[nq]=SAM[q];
            SAM[np].f=SAM[q].f=nq;
            SAM[nq].len=SAM[p].len+1;
            for(;p&&SAM[p].chi[s]==q;p=SAM[p].f)SAM[p].chi[s]=nq;
        }
    }
    ans+=SAM[np].len-SAM[SAM[np].f].len;
    return np;
}
inline void MakeSAM(){
    std::queue<int>q;
    int u,s;
    tot=lst[0]=1;q.push(0);
    while(!q.empty()){
        u=q.front();q.pop();
        for(s=0;s<m;++s){
            if(t[u].chi[s]){
                lst[t[u].chi[s]]=Insert(lst[u],s);
                q.push(t[u].chi[s]);
            }
        }
    }
}
signed main(){
    register int i,u,v;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;++i)scanf("%d",col+i);
    for(i=1;i<n;++i){
        scanf("%d%d",&u,&v);
        Add(u,v);++siz[u];++siz[v];
    }
    DFS(1,0);MakeSAM();
    printf("%lld",ans);
}
```

---

## 作者：xiezheyuan (赞：1)

## 简要题意

给出一个 $n$ 个点的树，第 $i$ 个点点权为为 $a_i$，求本质不同有序二元组数量。

定义两个有序二元组本质相同，当且仅当将树上从第一个元素到第二个元素的路径上所有点的点权记录下来，得到的两个序列完全相同。

$1\leq n\leq 10^5,1\leq a_i\leq 10$，树的叶子数量不大于 $20$。

## 思路

看到本质不同，想到 SAM（Burnside 就算了吧）。

一个直观的思路为枚举有序二元组，将两点路径上的所有点权组成一个字符串，插进 `map` 里，但是这样子肯定炸。

我们可以从一个点开始遍历，从根节点到叶子节点的点权构成一个字符串，插进 GSAM 中，但是路径不一定在根节点到叶子节点上（也就是说，LCA 不一定为路径端点），下面将这种路径称为不好的，其他的就是好的。

那怎么办？我们发现对于路径 $(u,v)$，假如以 $u$ 为根，那这个路径就是好的（显然）。

推而广之，我们可以以 $u$ 的子树中某一个叶子节点为根，$(u,v)$ 同样也是好的。

所以我们可以枚举每个叶子当根，维护一个 GSAM。

最后 GSAM 中所有本质不同的子串都是一段路径，统计一下即可。

## 代码

```cpp
#include <bits/stdc++.h>
#define link __ytxy_ak_ioi
using namespace std;

const int N = 1e5 * 20 + 5, M = 11, N2 = 1e5 + 5;

int trans[N << 1][M];
int link[N << 1], len[N << 1], cur, tot;

int extend(int c, int cur){
	int x=cur;cur=trans[cur][c];len[cur]=len[x]+1;
	for(x = link[x];(~x)&&(!trans[x][c]);x=link[x]) trans[x][c] = cur;
	if(!(~x)){link[cur]=0;return cur;}
	int y=trans[x][c];
	if(len[y]==len[x]+1){link[cur]=y;return cur;}
	int u=(++tot),d=y;
	link[u]=link[y];link[d]=link[cur]=u;len[u]=len[x]+1;
	for(int i=0;i<10;i++) trans[u][i] = len[trans[d][i]] == 0 ? 0 : trans[d][i];
	for(;(~x)&&(trans[x][c]==y);x=link[x]) trans[x][c] = u;
    return cur;
}

void build(){
    queue<pair<int,int> > q;
    for(int i=0;i<10;i++){
        if(trans[0][i]) q.push(make_pair(i, 0));
    }
    while(!q.empty()){
        auto top = q.front();
        q.pop();
        int u = extend(top.first, top.second);
        for(int i=0;i<10;i++){
            if(trans[u][i]) q.push(make_pair(i, u));
        }
    }
}

int n, a[N], c;

struct edge{
    int nxt, to;
} g[N2 << 1];
int head[N], ec, deg[N];

void add(int u, int v){
    g[++ec].nxt = head[u];
    g[ec].to = v;
    head[u] = ec;
}

int buf[N], bftt;

void insert(){
    int cur = 0;
    for(int i=1;i<=bftt;i++){
        if(!trans[cur][buf[i]]) trans[cur][buf[i]] = ++tot;
        cur = trans[cur][buf[i]];
    }
}

void dfs(int u, int fa){
    buf[++bftt] = a[u];
    if(deg[u] == 1 && fa){
        insert();
        return;
    }
    for(int i=head[u];i;i=g[i].nxt){
        int v = g[i].to;
        if(v == fa) continue;
        dfs(v, u);
        bftt--;
    }
}

signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    link[0] = -1;
    cin >> n >> c;
    for(int i=1;i<=n;i++) cin >> a[i];
    for(int i=1, u, v;i<n;i++){
        cin >> u >> v;
        add(u, v);add(v, u);deg[u]++;deg[v]++;
    }
    for(int i=1;i<=n;i++){
        if(deg[i] == 1) dfs(i, 0);
        bftt = 0;
    }
    build();
    long long ans = 0;
    for(int i=1;i<=tot;i++) ans += len[i] - len[link[i]];
    cout << ans;
    return 0;
}
```

---

## 作者：Yanami_Anna (赞：1)

我选他为 GSAM 模板，他才是众望所归。

我们考虑，如果只建一次 GSAM 的话，一条路径会出现被 LCA 折断不好统计的尴尬情况。

那我们对于每个叶子都建一次啊，一条路径一定会在以某个叶子为根的时候被拉直的。

又因为题目限制条件，叶子节点不多于 $20$ 个，那直接做，暴建字典树，丢进 GSAM 里面就变成了[板子](https://www.luogu.com.cn/problem/P6139)。

代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
class Trie{
    public:
    int tot=1;
    int tr[2000005][10];
    void insert(string S){
        int now=1;
        for(int i=0;i<S.size();i++){
            if(!tr[now][S[i]-'a']){
                tr[now][S[i]-'a']=++tot;
            }
            now=tr[now][S[i]-'a'];
        }
        return;
    }
};
class GSAM{
    public:
    Trie T;
    int tr[2000005][10];
    int fail[2000005];
    int len[2000005];
    int val[2000005];
    int rt[2000005];
    int tot=1;
    int add(int lst,int k){
        int now=lst;
        len[++tot]=len[lst]+1;
        int rt=tot;
        val[rt]=1;
        while(now&&!tr[now][k]){
            tr[now][k]=rt;
            now=fail[now];
        }
        if(!now){
            fail[tot]=1;
        }
        else{
            int need=tr[now][k];
            if(len[need]-len[now]==1){
                fail[rt]=need;
            }
            else{
                int N=++tot;
                for(int i=0;i<10;i++){
                    tr[N][i]=tr[need][i];
                }
                int cur=now;
                while(tr[cur][k]==need){
                    tr[cur][k]=tot;
                    cur=fail[cur];
                }
                fail[N]=fail[need];
                fail[need]=N;
                fail[rt]=N;
                len[N]=len[now]+1;
            }
        }
        return rt;
    }
    void build(){
        queue<int> q;
        rt[1]=1;
        q.push(1);
        while(!q.empty()){
            int t=q.front();
            q.pop();
            for(int i=0;i<10;i++){
                if(T.tr[t][i]){
                    rt[T.tr[t][i]]=add(rt[t],i);
                    q.push(T.tr[t][i]);
                }
            }
        }
        return;
    }
}P;
int n;
int col[100005];
vector<int> ljb[100005];
void dfs(int cur,int pos,int fa){
    for(int i=0;i<ljb[cur].size();i++){
        int v=ljb[cur][i];
        if(v==fa)continue;
        if(!P.T.tr[pos][col[v]]){
            P.T.tr[pos][col[v]]=++P.T.tot;
        }
        dfs(v,P.T.tr[pos][col[v]],cur);
    }
    return;
}
int main(){
    scanf("%d%d",&n,&col[0]);
    for(int i=1;i<=n;i++){
        scanf("%d",&col[i]);
    }
    for(int i=1;i<n;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        ljb[u].push_back(v);
        ljb[v].push_back(u);
    }
    for(int i=1;i<=n;i++){
        if(ljb[i].size()>1)continue;
        if(!P.T.tr[1][col[i]]){
            P.T.tr[1][col[i]]=++P.T.tot;
        }
        dfs(i,P.T.tr[1][col[i]],0);
    }
    P.build();
    long long ans=0;
    for(int i=2;i<=P.tot;i++){
        ans+=P.len[i]-P.len[P.fail[i]];
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：hegm (赞：1)

### [[ZJOI2015]诸神眷顾的幻想乡](https://www.luogu.com.cn/problem/P3346)

容易发现对于确定根的情况，如果直接插入 $\text{SAM}$，无法出现在 $\text{lca}$ 拐弯的情况，所以考虑对于每一个叶子节点都 dfs 插入 $\text{SAM}$之中，题目性质保证叶子不超过 $20$ 个，所以复杂度正确。

需要注意的是节点个数要开到 $2\times 10^6$ 才行，否则会在 $70\sim 75$ 分打转。

两种写法，一种是建立 $\text{Trie}$，另一种是直接在树上插入，两种写法皆可，但是需要注意第二种要加特判。

插入完后，直接在 $\text{SAM}$ 上找本质不同子串即可，拓扑排序或者直接统计皆可，这里用了简单的 $\sum mx_{now}-mx_{fa}$。

### $\text{CODE}$

```cpp
#include<bits/stdc++.h>
#define N 2000006
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,m,s,a[N],du[N],id[N];
struct fig
{
	int next,to;
}k[N*2];int head[N],tot;
void add(int from,int to)
{
	k[++tot].to=to;
	k[tot].next=head[from];
	head[from]=tot;
}
int mx[N*4],ch[N*4][20],awa=1,g[N];
int Push(int c,int last)
{
	if(ch[last][c])
	{
		int q=ch[last][c],p=last;
		if(mx[p]+1==mx[q])return q;
		int nq=++awa;
		g[nq]=g[q];g[q]=nq;mx[nq]=mx[p]+1;
		for(int i=0;i<m;i++)ch[nq][i]=ch[q][i];
		for(;p&&ch[p][c]==q;p=g[p])ch[p][c]=nq;
		return nq;
	}
	int np=++awa,p=last;mx[np]=mx[p]+1;
	for(;p&&ch[p][c]==0;p=g[p])ch[p][c]=np;
	if(!p)g[np]=1;
	else
	{
		int q=ch[p][c];
		if(mx[p]+1==mx[q])g[np]=q;
		else
		{
			int nq=++awa;mx[nq]=mx[p]+1;
			g[nq]=g[q];g[q]=g[np]=nq;
			for(int i=0;i<m;i++)ch[nq][i]=ch[q][i];
			for(;p&&ch[p][c]==q;p=g[p])ch[p][c]=nq;
		}
	}
	return np;
}
void dfs(int now,int f)
{
	id[now]=Push(a[now],id[f]); 
	for(int i=head[now];i;i=k[i].next)
	{
		if(k[i].to==f)continue;
		dfs(k[i].to,now);
	}
}
signed main()
{
	n=read();m=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1,u,v;i<n;i++)
	{
		u=read();v=read();
		add(u,v);add(v,u);
		du[u]++;du[v]++;
	}
	id[0]=1;
	for(int i=1;i<=n;i++)
	{
		if(du[i]>1)continue;
		dfs(i,0);
	}
	long long sk=0;
	for(int i=2;i<=awa;i++)sk+=mx[i]-mx[g[i]];
	cout<<sk<<"\n";
	return 0;
}
```

---

## 作者：FxorG (赞：1)

## $\text{Solution}$



话说这种通过对树的形态特殊限制最近做了还有[一道](https://www.luogu.com.cn/problem/P3241)，以保证暴力做法复杂度。

链怎么做？是不是从上至下以及从下到上类似于 trie 的形式建广义 SAM 求不同子串。或者你思考现在只有一段序列，不同子串的求法，用 SAM 就好，那么正反都要，是不是我正向跑一次，反向跑一次，但这时候就要用到广义 SAM 了，然后这种正向依赖前一个字符的序列做法实际上就是链上依赖 trie 树的上一个字符。？

抽象的，我们只是把每一个前缀插入到 SAM 里面了，那么获取这些前缀的方法，我们可以类似于 trie ，但实际上 dfs 保证依赖关系就好了。

![](https://cdn.luogu.com.cn/upload/image_hosting/bhqik8x4.png)
类比到树上：看图下，摸了几遍发现，假如我们要保证正序和倒序的字符串都能被找到，那么我们必须要从叶子节点出发，仿照链的做法即可。

注意下广义 SAM 的 $pre$ 以及空间问题。

## $\text{Code}$

```cpp
#include <bits/stdc++.h>

#define N (int)(2e6+5)
#define ll long long

using namespace std;

struct edge {
	int nex,to;
}e[N];

int head[N],cnt;
int du[N],col[N],fa[N],son[10][N],len[N];
int n,m,tot=1;

int rd() {
	int f=1,sum=0; char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) {sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}
	return sum*f;
}

void add_edge(int x,int y) {
	e[++cnt].nex=head[x]; e[cnt].to=y;
	head[x]=cnt;
}

int ins(int c,int las) {
	if(son[c][las]) {
		int pre=las,y=son[c][las];
		if(len[pre]+1==len[y]) return y;
		int x=++tot; len[x]=len[pre]+1;
		fa[x]=fa[y]; fa[y]=x;
		for(int i=0;i<10;i++) son[i][x]=son[i][y];
		for(;pre&&son[c][pre]==y;pre=fa[pre]) son[c][pre]=x;
		return x;
	}
	int pre=las,x=++tot; len[x]=len[pre]+1;
	for(;pre&&!son[c][pre];pre=fa[pre]) son[c][pre]=x;
	int y=son[c][pre];
	if(!pre) fa[x]=1;
	else if(len[pre]+1==len[y]) fa[x]=y;
	else {
		int p=++tot; len[p]=len[pre]+1;
		fa[p]=fa[y]; fa[x]=fa[y]=p;
		for(int i=0;i<10;i++) son[i][p]=son[i][y];
		for(;pre&&son[c][pre]==y;pre=fa[pre]) son[c][pre]=p;
	}
	return x;
}

void dfs(int x,int fa,int las) {
	las=ins(col[x],las);
	for(int i=head[x];i;i=e[i].nex) {
		int y=e[i].to;
		if(y==fa) continue;
		dfs(y,x,las);
	}
}

int main() {
	int x,y;
	n=rd(); m=rd();
	for(int i=1;i<=n;i++) col[i]=rd();
	for(int i=1;i<n;i++) {
		x=rd(); y=rd();
		add_edge(x,y); add_edge(y,x);
		++du[x]; ++du[y];
	}	
	for(int i=1;i<=n;i++) if(du[i]==1) dfs(i,0,1);
	ll ans=0;
	for(int i=2;i<=tot;i++) ans+=len[i]-len[fa[i]];
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：殇雪 (赞：1)

幽香是全幻想乡里最受人欢迎的萌妹子，这天，是幽香的2600岁生日，无数幽香的粉丝到了幽香家门前的太阳花田上来为幽香庆祝生日。 粉丝们非常热情，自发组织表演了一系列节目给幽香看。幽香当然也非常高兴啦。 这时幽香发现了一件非常有趣的事情，太阳花田有n块空地。在过去，幽香为了方便，在这n块空地之间修建了n-1条边将它们连通起来。也就是说，这n块空地形成了一个树的结构。


有n个粉丝们来到了太阳花田上。为了表达对幽香生日的祝贺，他们选择了c中颜色的衣服，每种颜色恰好可以用一个0到c-1之间的整数来表示。并且每个人都站在一个空地上，每个空地上也只有一个人。这样整个太阳花田就花花绿绿了。幽香看到了，感觉也非常开心。


粉丝们策划的一个节目是这样的，选中两个粉丝A和B（A和B可以相同），然后A所在的空地到B所在的空地的路径上的粉丝依次跳起来（包括端点），幽香就能看到一个长度为A到B之间路径上的所有粉丝的数目（包括A和B）的颜色序列。一开始大家打算让人一两个粉丝（注意：A,B和B,A是不同的，他们形成的序列刚好相反，比如红绿蓝和蓝绿红）都来一次，但是有人指出这样可能会出现一些一模一样的颜色序列，会导致审美疲劳。


于是他们想要问题，在这个树上，一共有多少可能的不同的颜色序列（子串）幽香可以看到呢？ 太阳花田的结构比较特殊，只与一个空地相邻的空地数量不超过20个。


SOL：

我们发现，叶子节点异常的少，（膜拜丽姐的语文水平，第一次读成了每个点的度少于等于20），那么我们就可以对每一个叶子节点建后缀自动机，在Trie建自动机只要维护当前节点的父亲节点在SAM上的点即可。


不会SAM（后缀自动机）的请点这里：http://blog.csdn.net/qq\_35649707/article/details/66473069


不会广义后缀自动机的请点这里：http://blog.csdn.net/wangzhen\_yu/article/details/45481269


复制代码

```cpp
#include<bits/stdc++.h>
#define sight(x) ('0'<=x&&x<='9')
#define N 4000007
using namespace std;
inline void read(int & x){
    static char c;
    for (c=getchar();!sight(c);c=getchar());
    for (x=0;sight(c);c=getchar()) x=x*10+c-48; 
}
struct S{
    int c[10],fa,val;
}T[N];
int fall[N],net[N],head[N],toT,col[N],n,C,a,b,dre[N];
inline void add(int x,int y) { fall[++toT]=y; net[toT]=head[x]; head[x]=toT;}
int tot=1;
inline int Sam(int x,int last){
    int np=++tot;
    T[np].val=T[last].val+1;
    for(;last&&(!T[last].c[x]);last=T[last].fa) T[last].c[x]=np;
    if (!last) T[np].fa=1;
    else {
        int q=T[last].c[x];
        if (T[last].val+1==T[q].val) T[np].fa=q;
        else {
            int nq=++tot;  T[nq]=T[q];
            T[nq].val=T[last].val+1;
            T[q].fa=T[np].fa=nq;
            for (;last&&T[last].c[x]==q;last=T[last].fa) T[last].c[x]=nq;
        }
    }
    return np;
}
void dfs(int x,int f,int to){
    int g=Sam(col[x],to);
    for (int i=head[x];i;i=net[i])
     if (fall[i]^f) dfs(fall[i],x,g);
}
long long ans;
int main () {
//    freopen("a.in","r",stdin);
    read(n); read(C);
    for (int i=1;i<=n;i++) read(col[i]);
    for (int i=1;i<n;i++){
     read(a); read(b); dre[a]++; dre[b]++; add(a,b); add(b,a);}
    for (int i=1;i<=n;i++)
     if (dre[i]==1) dfs(i,0,1);
    for (int i=1;i<=tot;i++) ans+=T[i].val-T[T[i].fa].val;
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：鱼跃于渊 (赞：0)

## 1.题意：

给定一棵 $n$ 个结点的无根树，其最多有 $20$ 个叶子结点，点权为一个不超过 $c$ 的数。一条路径经过的结点权值依次相连可以形成一个字符串。求树上所有路径形成的本质不同的字符串数量。

## 2.做法：

如果你想到这题求的就是本质不同的字符串数量的话，那么你肯定能想到使用 SAM，毕竟这是经典求法。

但是我们发现有一点很麻烦：如果我们随便钦定一个点为根结点的话，一条路径的两个端点可能出现在其 $lca$ 的不同子树中。显然 SAM 无法胜任。  

仔细思考可以发现一个结论：任意一条路径都可以在以某个叶子结点为根的树上不出现上述情况。又注意到这棵无根树最多有 $20$ 个叶子结点。  

这启示我们可以把以每个叶子节点为根的树插入 SAM 中，建出广义 SAM，再求本质不同的子串个数。 

于是这题就愉快地做完了。

## 3.代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e6+5,S=10;
struct SAM{
	SAM(){tot=0;new_node();}
	void init(){tot=0;new_node();}
	int tot,a[N],siz[N],len[N],link[N],t[S][N];
	int new_node(){
		tot++;
		a[tot]=siz[tot]=len[tot]=link[tot];
		for(int i=0;i<S;i++) t[i][tot]=0;
		return tot;
	}
	void operate(const int c,int u,int v,int p,int q){
		len[v]=len[p]+1;
		link[v]=link[q];
		link[q]=link[u]=v;
		for(;p&&t[c][p]==q;p=link[p]) t[c][p]=v;
		for(int i=0;i<S;i++) t[i][v]=t[i][q];
	}
	int insert(const int c,int last){
		if(t[c][last]){
			int p=last,q=t[c][last];
			if(len[p]+1==len[q]) last=q;
			else operate(c,N-1,last=new_node(),p,q);
			return last;
		}
		int p=last,q,u=new_node(),v;
		len[u]=len[p]+1;siz[u]=1;
		last=u;
		for(;p&&!t[c][p];p=link[p]) t[c][p]=u;
		if(!p) link[u]=1;
		else{
			q=t[c][p];
			if(len[p]+1==len[q]) link[u]=q;
			else operate(c,u,new_node(),p,q);
		}
        return last;
	}
	void calc(){
		int *tub = new int[N];
		for(int i=1;i<=tot;i++) tub[len[i]]++;
		for(int i=2;i<=tot;i++) tub[i]+=tub[i-1];
		for(int i=1;i<=tot;i++) a[tub[len[i]]--]=i;
		for(int i=tot;i>=1;i--) siz[link[a[i]]]+=siz[a[i]];
		delete [] tub;
	}
	int query(){
		int res=0;
		for(int i=2;i<=tot;i++)
			res+=len[i]-len[link[i]];
		return res;
	}
}sam;
int n,c,du[N],col[N];
vector <int> e[N];
void dfs(int u,int fa,int last){
    last=sam.insert(col[u],last);
    for(auto v:e[u])
        if(v!=fa) dfs(v,u,last);
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n>>c;
    for(int i=1;i<=n;i++) cin>>col[i];
    for(int i=1,u,v;i<n;i++){
        cin>>u>>v;
        e[u].push_back(v);du[u]++;
        e[v].push_back(u);du[v]++;
    }
    for(int i=1;i<=n;i++){
        if(du[i]>1) continue;
        dfs(i,0,1);
    }
    sam.calc();
    cout<<sam.query()<<'\n';
	return 0;
}
```



---

## 作者：creation_hy (赞：0)

## 思路

本题最恶心的一点在于，如果两点不是在同一条链，那么路径是 $u\to lca\to v$。

直接建 SAM 显然不行，因为这个拐弯根本不是 Trie 能处理的了的东西。

但是，如果这个时候树的根是以 $u$ 或者 $v$ 开始的呢？

路径是不是又变成 $u\to v$ 了。

注意到题面最下面一句话，叶子节点不超过 $20$，而任何一条路径都可以在以叶子结点为根的树中变成形如 $u\to v$ 的形式。

可以直接暴力枚举！

于是，解法就出来了：

暴力枚举每棵以叶子结点作为根的树，为每棵这样的树建广义 SAM。

然后直接输出不同子串个数即可。

注意两点：

- 因为有 dfs，所以不能直接存 $last$。**每个点的 $last$ 应该是它父亲的 $cur$，而不是整个 SAM 的 $last$**。整个 SAM 的 $last$ 实际上应该对应的是它旁边那棵子树的最后一个节点的 $cur$。

- **最多会有 $20$ 棵树**。所以空间应该开 $n\times20\times2$。~~不过我就开了 $20$ 倍也过了（逃~~

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e6 + 5;
int n, m, a[N], head[N], to[N], nxt[N], etot;
int in[N];
inline void link(int u, int v)
{
    to[etot] = v;
    nxt[etot] = head[u];
    head[u] = etot++;
    in[v]++;
}
ll ans;
struct SAM
{
    int tot, fa[N], len[N], t[N][11];
    inline SAM()
    {
        tot = 0;
        fa[0] = -1;
    }
    inline int insert(int c, int last)
    {
        int cur = ++tot;
        len[cur] = len[last] + 1;
        int p = last;
        while (~p && !t[p][c])
            t[p][c] = cur, p = fa[p];
        if (!~p)
        {
            fa[cur] = 0;
            ans += len[cur] - len[0];
            return cur;
        }
        int x = t[p][c];
        if (len[p] + 1 == len[x])
            fa[cur] = x;
        else
        {
            len[++tot] = len[p] + 1;
            fa[tot] = fa[x];
            memcpy(t[tot], t[x], sizeof(t[x]));
            while (~p && t[p][c] == x)
                t[p][c] = tot, p = fa[p];
            fa[x] = fa[cur] = tot;
        }
        ans += len[cur] - len[fa[cur]];
        return cur;
    }
} sam;
inline void dfs(int x, int fa, int last)
{
    int pos = sam.insert(a[x], last);
    for (int i = head[x]; ~i; i = nxt[i])
        if (to[i] != fa)
            dfs(to[i], x, pos);
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    memset(head, -1, sizeof(head));
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> a[i], a[i]++;
    for (int i = 1, u, v; i < n; i++)
    {
        cin >> u >> v;
        link(u, v);
        link(v, u);
    }
    for (int i = 1; i <= n; i++)
        if (in[i] == 1)
            dfs(i, 0, 0);
    cout << ans;
    return 0;
}
```

---


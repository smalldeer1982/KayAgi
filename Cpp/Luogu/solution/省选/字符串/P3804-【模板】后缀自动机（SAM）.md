# 【模板】后缀自动机（SAM）

## 题目描述

给定一个只包含小写字母的字符串 $S$。

请你求出 $S$ 的所有出现次数不为 $1$ 的子串的出现次数乘上该子串长度的最大值。


## 说明/提示

对于 $10 \%$ 的数据，$\lvert S \rvert \le 1000$。  
对于 $100\% $的数据，$1 \le \lvert S \rvert \le {10}^6$。

- 2023.7.30：添加一组 hack 数据。

## 样例 #1

### 输入

```
abab```

### 输出

```
4```

# 题解

## 作者：Hatsune_Miku (赞：744)

[TOC]

（这里没有 TOC 就不是我的锅了，反正这文章挺长的）

# 后缀自动机

**请读者注意：本人已经 AFO 近一年，这篇题解未来所有勘误和更新将会在 [OI Wiki](https://oi-wiki.org/string/sam/) 上进行。另外请保持评论区的和谐。**

**本文译自博文
[Суффиксный автомат](http://e-maxx.ru/algo/suffix_automata) 与其英文翻译版 
[Suffix Automaton](https://cp-algorithms.com/string/suffix-automaton.html)。**

**其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。**

**本文版权协议为 
[CC-BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/deed.zh)
 及未来（如果有）的更新版本。**

**转载时，请务必遵守以上版权协议，谢谢！**

2018 年 8 月 23 日  
最后更新：2019 年 7 月 21 日  
本次更新修复了题解中的部分错误和不当的言辞，没有内容上的更新。

## 一些前置约定/定义

记 $\Sigma$ 为字符集， $\left|\Sigma\right|$ 为字符集大小。
对于一个字符串 $s$ ，记 $\left|s\right|$ 为其长度。

## 后缀自动机概述

 **后缀自动机** (suffix automaton, SAM) 是一个能解决许多字符串相关问题的有力的数据结构。

举个例子，以下的字符串问题都可以在线性时间内通过 SAM 解决。

-   在另一个字符串中搜索一个字符串的所有出现位置。
-   计算给定的字符串中有多少个不同的子串。

直观上，字符串的 SAM 可以理解为给定字符串的 **所有子串** 的压缩形式。值得注意的事实是，SAM 将所有的这些信息以高度压缩的形式储存。对于一个长度为 $n$ 的字符串，它的空间复杂度仅为 $O(n)$ 。此外，构造 SAM 的时间复杂度仅为 $O(n)$ （这里我们将字符集的大小 $\left|\Sigma\right|$ 看作常数，否则时间复杂度和空间复杂度均为 $O(n\log\left|\Sigma\right|)$ ）。

## SAM 的定义

字符串 $s$ 的 SAM 是一个接受 $s$ 的所有后缀的最小 **DFA** （确定性有限自动机或确定性有限状态自动机）。

换句话说：

-   SAM 是一张有向无环图。结点被称作 **状态** ，边被称作状态间的 **转移** 。
-   图存在一个源点 $t_0$ ，称作 **初始状态** ，其它各结点均可从 $t_0$ 出发到达。
-   每个 **转移** 都标有一些字母。从一个结点出发的所有转移均 **不同** 。
-   存在一个或多个 **终止状态** 。如果我们从初始状态 $t_0$ 出发，最终转移到了一个终止状态，则路径上的所有转移连接起来一定是字符串 $s$ 的一个后缀。 $s$ 的每个后缀均可用一条从 $t_0$ 到某个终止状态的路径构成。
-   在所有满足上述条件的自动机中，SAM 的结点数是最少的。

### 子串的性质

SAM 最简单、也最重要的性质是，它包含关于字符串 $s$ 的所有子串的信息。任意从初始状态 $t_0$ 开始的路径，如果我们将转移路径上的标号写下来，都会形成 $s$ 的一个 **子串** 。反之每个 $s$ 的子串对应从 $t_0$ 开始的某条路径。

为了简化表达，我们称子串 **对应** 一条路径（从 $t_0$ 开始、由一些标号构成这个子串）。反过来，我们说任意一条路径 **对应** 它的标号构成的字符串。

到达某个状态的路径可能不止一条，因此我们说一个状态对应一些字符串的集合，这个集合的每个元素对应这些路径。

### 构造 SAM

我们将会在这里展示一些简单的字符串的后缀自动机。

我们用蓝色表示初始状态，用绿色表示终止状态。

对于字符串 $s=``"$ ：

![](https://gitee.com/mingqihuang/pics/raw/master/SA.pdf.svg)

对于字符串 $s=``a"$ ：

![](https://gitee.com/mingqihuang/pics/raw/master/SAa.pdf.svg)

对于字符串 $s=``aa"$ ：

![](https://gitee.com/mingqihuang/pics/raw/master/SAaa.pdf.svg)

对于字符串 $s=``ab"$ ：

![](https://gitee.com/mingqihuang/pics/raw/master/SAab.pdf.svg)

对于字符串 $s=``abb"$ ：

![](https://gitee.com/mingqihuang/pics/raw/master/SAabb.pdf.svg)

对于字符串 $s=``abbb"$ ：

![](https://gitee.com/mingqihuang/pics/raw/master/SAabbb.pdf.svg)

## 在线性时间内构造 SAM

在我们描述线性时间内构造 SAM 的算法之前，我们需要引入几个对理解构造过程非常重要的概念并对其进行简单证明。

### 结束位置 `endpos` 

考虑字符串 $s$ 的任意非空子串 $t$ ，我们记 $endpos(t)$ 为在字符串 $s$ 中 $t$ 的所有结束位置（假设对字符串中字符的编号从零开始）。例如，对于字符串 $``abcbc"$ ，我们有 $endpos(``bc")=2,\,4$ 。

两个子串 $t_1$ 与 $t_2$ 的 $endpos$ 集合可能相等： $endpos(t_1)=endpos(t_2)$ 。这样所有字符串 $s$ 的非空子串都可以根据它们的 $endpos$ 集合被分为若干 **等价类** 。

显然，SAM 中的每个状态对应一个或多个 $endpos$ 相同的子串。换句话说，SAM 中的状态数等于所有子串的等价类的个数，再加上初始状态。SAM 的状态个数等价于 $endpos$ 相同的一个或多个子串所组成的集合的个数 $+1$ 。

我们稍后将会用这个假设来介绍构造 SAM 的算法。我们将发现，SAM 需要满足的所有性质，除了最小性以外都满足了。由 Nerode 定理我们可以得出最小性（不会在这篇文章中证明）。

由 $endpos$ 的值我们可以得到一些重要结论：

>  **引理 1：** 两个非空子串 $u$ 和 $w$ （假设 $\left|u\right|\le \left|w\right|$ ）的 $endpos$ 相同，当且仅当字符串 $u$ 是 $w$ 的后缀。

引理显然成立。如果 $u$ 和 $w$ 的 $endpos$ 相同，则 $u$ 是 $w$ 的一个后缀，且只以 $s$ 中的一个 $w$ 的后缀的形式出现。且根据定义，如果 $u$ 为 $w$ 的一个后缀，且只以后缀的形式在 $s$ 中出现时，两个子串的 $endpos$ 相同。

>  **引理 2：** 考虑两个非空子串 $u$ 和 $w$ （假设 $\left|u\right|\le \left|w\right|$ ）。那么要么 $endpos(u)\cap endpos(w)=\varnothing$ ，要么 $endpos(w)\subseteq endpos(u)$ ，取决于 $u$ 是否为 $w$ 的一个后缀：
>
> $$\begin{cases}endpos(w) \subseteq endpos(u) & \text{if } u\text{ is a suffix of } w \\endpos(w) \cap endpos(u) = \varnothing & \text{otherwise}\end{cases}$$

证明：如果集合 $endpos(u)$ 与 $endpos(w)$ 有至少一个公共元素，那么由于字符串 $u$ 与 $w$ 在相同位置结束， $u$ 是 $w$ 的一个后缀。所以在每次 $w$ 出现的位置，子串 $u$ 也会出现。所以 $endpos(w)\subseteq endpos(u)$ 。

>  **引理 3：** 考虑一个 $endpos$ 等价类，将类中的所有子串按长度非递增的顺序排序。每个子串都不会比它前一个子串长，与此同时每个子串也是它前一个子串的后缀。换句话说，对于同一等价类的任一两子串，较短者为较长者的后缀，且该等价类中的子串长度恰好覆盖整个区间 $[x,y]$ 。

证明：如果 $endpos$ 等价类中只包含一个子串，引理显然成立。现在我们来讨论子串元素个数大于 $1$ 的等价类。

由引理 1，两个不同的 $endpos$ 等价的字符串中，较短者总是较长者的真后缀。因此，等价类中没有等长的字符串。

记 $w$ 为等价类中最长的字符串、 $u$ 为等价类中最短的字符串。由引理 1，字符串 $u$ 是字符串 $w$ 的真后缀。现在考虑长度在区间 $[\left|u\right|,\left|w\right|]$ 中的 $w$ 的任意后缀。容易看出，这个后缀也在同一等价类中，因为这个后缀只能在字符串 $s$ 中以 $w$ 的一个后缀的形式存在（也因为较短的后缀 $u$ 在 $s$ 中只以 $w$ 的后缀的形式存在）。因此，由引理 1，这个后缀和字符串 $w$ 的 $endpos$ 相同。

### 后缀链接 `link` 

考虑 SAM 中某个不是 $t_0$ 的状态 $v$ 。我们已经知道，状态 $v$ 对应于具有相同 $endpos$ 的等价类。我们如果定义 $w$ 为这些字符串中最长的一个，则所有其它的字符串都是 $w$ 的后缀。

我们还知道字符串 $w$ 的前几个后缀（按长度降序考虑）全部包含于这个等价类，且所有其它后缀（至少有一个——空后缀）在其它的等价类中。我们记 $t$ 为最长的这样的后缀，然后将 $v$ 的后缀链接连到 $t$ 上。

换句话说，一个 **后缀链接**  $link(v)$ 连接到对应于 $w$ 的最长后缀的另一个 $endpos$ 等价类的状态。

以下我们假设初始状态 $t_0$ 对应于它自己这个等价类（只包含一个空字符串）。为了方便，我们规定 $endpos(t_0)=\{-1,0,\ldots,\left|S\right|-1\}$ 。

>  **引理 4：** 所有后缀链接构成一棵根节点为 $t_0$ 的树。

证明：考虑任意不是 $t_0$ 的状态 $v$ ，后缀链接 $link(v)$ 连接到的状态对应于严格更短的字符串（后缀链接的定义、引理 3）。因此，沿后缀链接移动，我们总是能到达对应空串的初始状态 $t_0$ 。

>  **引理 5：** 通过 $endpos$ 集合构造的树（每个子节点的 $subset$ 都包含在父节点的 $subset$ 中）与通过后缀链接 $link$ 构造的树相同。

证明：由引理 2，任意一个 SAM 的 $endpos$ 集合形成了一棵树（因为两个集合要么完全没有交集要么其中一个是另一个的子集）。

我们现在考虑任意不是 $t_0$ 的状态 $v$ 及后缀链接 $link(v)$ ，由后缀链接和引理 2，我们可以得到

$$endpos(v)\subseteq endpos(link(v)),$$

结合前面的引理有：后缀链接构成的树本质上是 $endpos$ 集合构成的一棵树。

以下是对字符串 $``abcbc"$ 构造 SAM 时产生的后缀链接树的一个 **例子** ，节点被标记为对应等价类中最长的子串。

![](https://gitee.com/mingqihuang/pics/raw/master/SA_suffix_links.pdf.svg)

### 小结

在学习算法本身前，我们总结一下之前学过的知识，并引入一些辅助记号。

-    $s$ 的子串可以根据它们结束的位置 $endpos$ 被划分为多个等价类；
-   SAM 由初始状态 $t_0$ 和与每一个 $endpos$ 等价类对应的每个状态组成；
-   对于每一个状态 $v$ ，一个或多个子串与之匹配。我们记 $longest(v)$ 为其中最长的一个字符串，记 $len(v)$ 为它的长度。类似地，记 $shortest(v)$ 为最短的子串，它的长度为 $minlen(v)$ 。那么对应这个状态的所有字符串都是字符串 $longest(v)$ 的不同的后缀，且所有字符串的长度恰好覆盖区间 $[minlength(v),len(v)]$ 中的每一个整数。
-   对于任意不是 $t_0$ 的状态 $v$ ，定义后缀链接为连接到对应字符串 $longest(u)$ 的长度为 $minlen(v)-1$ 的后缀的一条边。从根节点 $t_0$ 出发的后缀链接可以形成一棵树。这棵树也表示 $endpos$ 集合间的包含关系。
-   对于 $t_0$ 以外的状态 $v$ ，可用后缀链接 $link(v)$ 表达 $minlen(v)$ ：

$$minlen(v)=len(link(v))+1.$$

-   如果我们从任意状态 $v_0$ 开始顺着后缀链接遍历，总会到达初始状态 $t_0$ 。这种情况下我们可以得到一个互不相交的区间 $[minlen(v_i),len(v_i)]$ 的序列，且它们的并集形成了连续的区间 $[0,len(v_0)]$ 。

### 算法

现在我们可以学习构造 SAM 的算法了。这个算法是 **在线** 算法，我们可以逐个加入字符串中的每个字符，并且在每一步中对应地维护 SAM。

为了保证线性的空间复杂度，我们将只保存 $len$ 和 $link$ 的值和每个状态的转移列表，我们不会标记终止状态（但是我们稍后会展示在构造 SAM 后如何分配这些标记）。

一开始 SAM 只包含一个状态 $t_0$ ，编号为 $0$ （其它状态的编号为 $1,2,\ldots$ ）。为了方便，对于状态 $t_0$ 我们指定 $len=0$ 、 $link=-1$ （ $-1$ 表示虚拟状态）。

现在，任务转化为实现给当前字符串添加一个字符 $c$ 的过程。算法流程如下：

-   令 $last$ 为添加字符 $c$ 之前，整个字符串对应的状态（一开始我们设 $last=0$ ，算法的最后一步更新 $last$ ）。
-   创建一个新的状态 $cur$ ，并将 $len(cur)$ 赋值为 $len(last)+1$ ，在这时 $link(cur)$ 的值还未知。
-   现在我们按以下流程进行（从状态 $last$ 开始）。如果还没有到字符 $c$ 的转移，我们就添加一个到状态 $cur$ 的转移，遍历后缀链接。如果在某个点已经存在到字符 $c$ 的转移，我们就停下来，并将这个状态标记为 $p$ 。
-   如果没有找到这样的状态 $p$ ，我们就到达了虚拟状态 $-1$ ，我们将 $link(cur)$ 赋值为 $0$ 并退出。
-   假设现在我们找到了一个状态 $p$ ，其可以通过字符 $c$ 转移。我们将转移到的状态标记为 $q$ 。
-   现在我们分类讨论两种状态，要么 $len(p) + 1 = len(q)$ ，要么不是。
-   如果 $len(p)+1=len(q)$ ，我们只要将 $link(cur)$ 赋值为 $q$ 并退出。
-   否则就会有些复杂。需要 **复制** 状态 $q$ ：我们创建一个新的状态 $clone$ ，复制 $q$ 的除了 $len$ 的值以外的所有信息（后缀链接和转移）。我们将 $len(clone)$ 赋值为 $len(p)+1$ 。  
    复制之后，我们将后缀链接从 $cur$ 指向 $clone$ ，也从 $q$ 指向 $clone$ 。  
    最终我们需要使用后缀链接从状态 $p$ 往回走，只要存在一条通过 $p$ 到状态 $q$ 的转移，就将该转移重定向到状态 $clone$ 。
-   以上三种情况，在完成这个过程之后，我们将 $last$ 的值更新为状态 $cur$ 。

如果我们还想知道哪些状态是 **终止状态** 而哪些不是，我们可以在为字符串 $s$ 构造完完整的 SAM 后找到所有的终止状态。为此，我们从对应整个字符串的状态（存储在变量 $last$ 中），遍历它的后缀链接，直到到达初始状态。我们将所有遍历到的节点都标记为终止节点。容易理解这样做我们会准确地标记字符串 $s$ 的所有后缀，这些状态都是终止状态。

在下一部分，我们将详细叙述算法每一步的细节，并证明它的 **正确性** 。

因为我们只为 $s$ 的每个字符创建一个或两个新状态，所以 SAM 只包含 **线性个** 状态。

而线性规模的转移个数，以及算法总体的线性运行时间还不那么清楚。

### 正确性证明

-   若一个转移 $(p,q)$ 满足 $len(p)+1=len(q)$ ，则我们称这个转移是 **连续的** 。否则，即当 $len(p)+1<len(q)$ 时，这个转移被称为 **不连续的** 。从算法描述中可以看出，连续的、不连续的转移是算法的不同情况。连续的转移是固定的，我们不会再改变了。与此相反，当向字符串中插入一个新的字符时，不连续的转移可能会改变（转移边的端点可能会改变）。
-   为了避免引起歧义，我们记向 SAM 中插入当前字符 $c$ 之前的字符串为 $s$ 。
-   算法从创建一个新状态 $cur$ 开始，对应于整个字符串 $s+c$ 。我们创建一个新的节点的原因很清楚。与此同时我们也创建了一个新的字符和一个新的等价类。
-   在创建一个新的状态之后，我们会从对应整个字符串 $s$ 的状态通过后缀链接进行遍历。对于每一个状态，我们尝试添加一个通过字符 $c$ 到新状态 $cur$ 的转移。然而我们只能添加与原有转移不冲突的转移。因此我们只要找到已存在的 $c$ 的转移，我们就必须停止。
-   最简单的情况是我们到达了虚拟状态 $-1$ ，这意味着我们为所有 $s$ 的后缀添加了 $c$ 的转移。这也意味着，字符 $c$ 从未在字符串 $s$ 中出现过。因此 $cur$ 的后缀链接为状态 $0$ 。
-   第二种情况下，我们找到了现有的转移 $(p,q)$ 。这意味着我们尝试向自动机内添加一个 **已经存在的** 字符串 $x+c$ （其中 $x$ 为 $s$ 的一个后缀，且字符串 $x+c$ 已经作为 $s$ 的一个子串出现过了）。因为我们假设字符串 $s$ 的自动机的构造是正确的，我们不应该在这里添加一个新的转移。然而，难点在于，从状态 $cur$ 出发的后缀链接应该连接到哪个状态呢？我们要把后缀链接连到一个状态上，且其中最长的一个字符串恰好是 $x+c$ ，即这个状态的 $len$ 应该是 $len(p)+1$ 。然而还不存在这样的状态，即 $len(q)>len(p)+1$ 。这种情况下，我们必须通过拆开状态 $q$ 来创建一个这样的状态。
-   如果转移 $(p,\,q)$ 是连续的，那么 $len(q)=len(p)+1$ 。在这种情况下一切都很简单。我们只需要将 $cur$ 的后缀链接指向状态 $q$ 。
-   否则转移是不连续的，即 $len(q)>len(p)+1$ ，这意味着状态 $q$ 不只对应于长度为 $len(p)+1$ 的后缀 $s+c$ ，还对应于 $s$ 的更长的子串。除了将状态 $q$ 拆成两个子状态以外我们别无他法，所以第一个子状态的长度就是 $len(p)+1$ 了。  
    我们如何拆开一个状态呢？我们 **复制** 状态 $q$ ，产生一个状态 $clone$ ，我们将 $len(clone)$ 赋值为 $len(p)+1$ 。由于我们不想改变遍历到 $q$ 的路径，我们将 $q$ 的所有转移复制到 $clone$ 。我们也将从 $clone$ 出发的后缀链接设置为 $q$ 的后缀链接的目标，并设置 $q$ 的后缀链接为 $clone$ 。  
    在拆开状态后，我们将从 $cur$ 出发的后缀链接设置为 $clone$ 。  
    最后一步我们将一些到 $q$ 转移重定向到 $clone$ 。我们需要修改哪些转移呢？只重定向相当于所有字符串 $w+c$ （其中 $w$ 是 $p$ 的最长字符串）的后缀就够了。即，我们需要继续沿着后缀链接遍历，从结点 $p$ 直到虚拟状态 $-1$ 或者是转移到不是状态 $q$ 的一个转移。

### 对操作次数为线性的证明

首先我们假设字符集大小为 **常数** 。如果字符集大小不是常数，SAM 的时间复杂度就不是线性的。从一个结点出发的转移存储在支持快速查询和插入的平衡树中。因此如果我们记 $\Sigma$ 为字符集， $\left|\Sigma\right|$ 为字符集大小，则算法的渐进时间复杂度为 $O(n\log\left|\Sigma\right|)$ ，空间复杂度为 $O(n)$ 。然而如果字符集足够小，可以不写平衡树，以空间换时间将每个结点的转移存储为长度为 $\left|\Sigma\right|$ 的数组（用于快速查询）和链表（用于快速遍历所有可用关键字）。这样算法的时间复杂度为 $O(n)$ ，空间复杂度为 $O(n\left|\Sigma\right|)$ 。

所以我们将认为字符集的大小为常数，即每次对一个字符搜索转移、添加转移、查找下一个转移。这些操作的时间复杂度都为 $O(1)$ 。

如果我们考虑算法的各个部分，算法中有三处时间复杂度不明显是线性的：

-   第一处是遍历所有状态 $last$ 的后缀链接，添加字符 $c$ 的转移。
-   第二处是当状态 $q$ 被复制到一个新的状态 $clone$ 时复制转移的过程。
-   第三处是修改指向 $q$ 的转移，将它们重定向到 $clone$ 的过程。

我们使用 SAM 的大小（状态数和转移数）为 **线性的** 的事实（对状态数是线性的的证明就是算法本身，对转移数为线性的的证明将在稍后实现算法后给出）。

因此上述 **第一处和第二处** 的总复杂度显然为线性的，因为单次操作均摊只为自动机添加了一个新转移。

还需为 **第三处** 估计总复杂度，我们将最初指向 $q$ 的转移重定向到 $clone$ 。我们记 $v=longest(p)$ ，这是一个字符串 $s$ 的后缀，每次迭代长度都递减——因为字符串 $s$ 的位置每次迭代都单调上升。这种情况下，如果在循环的第一次迭代之前，相对应的字符串 $v$ 在距离 $last$ 的深度为 $k$  $(k\ge 2)$ 的位置上（深度记为后缀链接的数量），那么在最后一次迭代后，字符串 $v+c$ 将会成为路径上第二个从 $cur$ 出发的后缀链接（它将会成为新的 $last$ 的值）。

因此，循环中的每次迭代都会使作为当前字符串的后缀的字符串 $longest(link(link(last))$ 的位置单调递增。因此这个循环最多不会执行超过 $n$ 次迭代，这正是我们需要证明的。

### 实现

首先，我们实现一种存储一个转移的全部信息的数据结构。如果需要的话，你可以在这里加入一个终止标记，也可以是一些其它信息。我们将用一个 `map` 存储转移的列表，允许我们在总计 $O(n)$ 的空间复杂度和 $O(n\log\left|\Sigma\right|)$ 的时间复杂度内处理整个字符串。

```cpp
struct state {
  int len, link;
  std::map<char, int> next;
};
```

SAM 本身将会存储在一个 `state` 结构体数组中。我们记录当前自动机的大小 `sz` 和变量 `last` ，当前整个字符串对应的状态。

```cpp
const int MAXLEN = 100000;
state st[MAXLEN * 2];
int sz, last;
```

我们定义一个函数来初始化 SAM（创建一个只有初始状态的 SAM）。

```cpp
void sam_init() {
  st[0].len = 0;
  st[0].link = -1;
  sz++;
  last = 0;
}
```

最终我们给出主函数的实现：给当前行末增加一个字符，对应地在之前的基础上建造自动机。

```cpp
void sam_extend(char c) {
  int cur = sz++;
  st[cur].len = st[last].len + 1;
  int p = last;
  while (p != -1 && !st[p].next.count(c)) {
    st[p].next[c] = cur;
    p = st[p].link;
  }
  if (p == -1) {
    st[cur].link = 0;
  } else {
    int q = st[p].next[c];
    if (st[p].len + 1 == st[q].len) {
      st[cur].link = q;
    } else {
      int clone = sz++;
      st[clone].len = st[p].len + 1;
      st[clone].next = st[q].next;
      st[clone].link = st[q].link;
      while (p != -1 && st[p].next[c] == q) {
        st[p].next[c] = clone;
        p = st[p].link;
      }
      st[q].link = st[cur].link = clone;
    }
  }
  last = cur;
}
```

正如之前提到的一样，如果你用内存换时间（空间复杂度为 $O(n\left|\Sigma\right|)$ ，其中 $\left|\Sigma\right|$ 为字符集大小），你可以在 $O(n)$ 的时间内构造字符集大小任意的 SAM。但是这样你需要为每一个状态储存一个大小为 $\left|\Sigma\right|$ 的数组（用于快速跳转到转移的字符），和另外一个所有转移的链表（用于快速在转移中迭代）。

## 更多性质

### 状态数

对于一个长度为 $n$ 的字符串 $s$ ，它的 SAM 中的状态数 **不会超过**  $2n-1$ （假设 $n\ge 2$ ）。

算法本身即可证明该结论。一开始，自动机含有一个状态，第一次和第二次迭代中只会创建一个节点，剩余的 $n-2$ 步中每步会创建至多 $2$ 个状态。

然而我们也能在 **不借助这个算法** 的情况下 **证明** 这个估计值。我们回忆一下状态数等于不同的 $endpos$ 集合个数。这些 $endpos$ 集合形成了一棵树（祖先节点的集合包含了它所有孩子节点的集合）。考虑将这棵树稍微变形一下：只要它有一个只有一个孩子的内部结点（这意味着该子节点的集合至少遗漏了它的父集合中的一个位置），我们创建一个含有这个遗漏位置的集合。最后我们可以获得一棵每一个内部结点的度数大于 1 的树，且叶子节点的个数不超过 $n$ 。因此这样的树里有不超过 $2n-1$ 个节点。

字符串 $``abbb\ldots bbb"$ 的状态数达到了该上界：从第三次迭代后的每次迭代，算法都会拆开一个状态，最终产生恰好 $2n-1$ 个状态。

### 转移数

对于一个长度为 $n$ 的字符串 $s$ ，它的 SAM 中的转移数 **不会超过**  $3n-4$ （假设 $n\ge 3$ ）。

证明如下：

我们首先估计连续的转移的数量。考虑自动机中从状态 $t_0$ 开始的所有最长路径的生成树。生成树只包含连续的边，因此数量少于状态数，即边数不会超过 $2n-2$ 。

现在我们来估计不连续的转移的数量。令当前不连续转移为 $(p,\,q)$ ，其字符为 $c$ 。我们取它的对应字符串 $u+c+w$ ，其中字符串 $u$ 对应于初始状态到 $p$ 的最长路径， $w$ 对应于从 $p$ 到任意终止状态的最长路径。一方面，每个不完整的字符串所对应的形如 $u+c+w$ 的字符串是不同的（因为字符串 $u$ 和 $w$ 仅由完整的转移组成）。另一方面，由终止状态的定义，每个形如 $u+c+w$ 的字符串都是整个字符串 $s$ 的后缀。因为 $s$ 只有 $n$ 个非空后缀，且形如 $u+c+w$ 的字符串都不包含 $s$ （因为整个字符串只包含完整的转移），所以非完整的转移的总数不会超过 $n-1$ 。

将以上两个估计值相加，我们可以得到上界 $3n-3$ 。然而，最大的状态数只能在类似于 $``abbb\ldots bbb"$ 的情况中产生，而此时转移数量显然少于 $3n-3$ 。

因此我们可以获得更为紧确的 SAM 的转移数的上界： $3n-4$ 。字符串 $``abbb\ldots bbbc"$ 就达到了这个上界。

## 应用

下面我们来看一些可以用 SAM 解决的问题。简单起见，假设字符集的大小 $k$ 为常数。这允许我们认为增加一个字符和遍历的复杂度为常数。

### 检查字符串是否出现

> 给一个文本串 $T$ 和多个模式串 $P$ ，我们要检查字符串 $P$ 是否作为 $T$ 的一个子串出现。

我们在 $O(\left|T\right|)$ 的时间内对文本串 $T$ 构造后缀自动机。为了检查模式串 $P$ 是否在 $T$ 中出现，我们沿转移（边）从 $t_0$ 开始根据 $P$ 的字符进行转移。如果在某个点无法转移下去，则模式串 $P$ 不是 $T$ 的一个子串。如果我们能够这样处理完整个字符串 $P$ ，那么模式串在 $T$ 中出现过。

对于每个字符串 $P$ ，算法的时间复杂度为 $O(\left|P\right|)$ 。此外，这个算法还找到了模式串 $P$ 在文本串中出现的最大前缀长度。

### 不同子串个数

> 给一个字符串 $S$ ，计算不同子串的个数。

对字符串 $S$ 构造后缀自动机。

每个 $S$ 的子串都相当于自动机中的一些路径。因此不同子串的个数等于自动机中以 $t_0$ 为起点的不同路径的条数。

考虑到 SAM 为有向无环图，不同路径的条数可以通过动态规划计算。即令 $d_{v}$ 为从状态 $v$ 开始的路径数量（包括长度为零的路径），则我们有如下递推方程：

$$d_{v}=1+\sum_{w:(v,w,c)\in DAWG}d_{w}$$

即， $d_{v}$ 可以表示为所有 $v$ 的转移的末端的和。

所以不同子串的个数为 $d_{t_0}-1$ （因为要去掉空子串）。

总时间复杂度为： $O(\left|S\right|)$ 。

### 所有不同子串的总长度

> 给定一个字符串 $S$ ，计算所有不同子串的总长度。

本题做法与上一题类似，只是现在我们需要考虑分两部分进行动态规划：不同子串的数量 $d_{v}$ 和它们的总长度 $ans_{v}$ 。

我们已经在上一题中介绍了如何计算 $d_{v}$ 。 $ans_{v}$ 的值可以通过以下递推式计算：

$$ans_{v}=\sum_{w:(v,w,c)\in DAWG}d_{w}+ans_{w}$$

我们取每个邻接结点 $w$ 的答案，并加上 $d_{w}$ （因为从状态 $v$ 出发的子串都增加了一个字符）。

算法的时间复杂度仍然是 $O(\left|S\right|)$ 。

### 字典序第 k 大子串

> 给定一个字符串 $S$ 。多组询问，每组询问给定一个数 $K_i$ ，查询 $S$ 的所有子串中字典序第 $K_i$ 大的子串。

解决这个问题的思路可以从解决前两个问题的思路发展而来。字典序第 $k$ 大的子串对应于 SAM 中字典序第 $k$ 大的路径，因此在计算每个状态的路径数后，我们可以很容易地从 SAM 的根开始找到第 $k$ 大的路径。

预处理的时间复杂度为 $O(\left|S\right|)$ ，单次查询的复杂度为 $O(\left|ans\right|\cdot\left|\Sigma\right|)$ （其中 $ans$ 是查询的答案， $\left|\Sigma\right|$ 为字符集的大小）。

### 最小循环移位

> 给定一个字符串 $S$ 。找出字典序最小的循环移位。

容易发现字符串 $S+S$ 包含字符串 $S$ 的所有循环移位作为子串。

所以问题简化为在 $S+S$ 对应的后缀自动机上寻找最小的长度为 $\left|S\right|$ 的路径，这可以通过平凡的方法做到：我们从初始状态开始，贪心地访问最小的字符即可。

总的时间复杂度为 $O(\left|S\right|)$ 。

### 出现次数

> 对于一个给定的文本串 $T$ ，有多组询问，每组询问给一个模式串 $P$ ，回答模式串 $P$ 在字符串 $T$ 中作为子串出现了多少次。

对文本串 $T$ 构造后缀自动机。

接下来做预处理：对于自动机中的每个状态 $v$ ，预处理 $cnt_{v}$ ，使之等于 $endpos(v)$ 集合的大小。事实上，对应同一状态 $v$ 的所有子串在文本串 $T$ 中的出现次数相同，这相当于集合 $endpos$ 中的位置数。

然而我们不能明确的构造集合 $endpos$ ，因此我们只考虑它们的大小 $cnt$ 。

为了计算这些值，我们进行以下操作。对于每个状态，如果它不是通过复制创建的（且它不是初始状态 $t_0$ ），我们将它的 $cnt$ 初始化为 1。然后我们按它们的长度 $len$ 降序遍历所有状态，并将当前的 $cnt_{v}$ 的值加到后缀链接指向的状态上，即：

$$cnt_{link(v)}+=cnt_{v}$$

这样做每个状态的答案都是正确的。

为什么这是正确的？不是通过复制获得的状态，恰好有 $\left|T\right|$ 个，并且它们中的前 $i$ 个在我们插入前 $i$ 个字符时产生。因此对于每个这样的状态，我们在它被处理时计算它们所对应的位置的数量。因此我们初始将这些状态的 $cnt$ 的值赋为 $1$ ，其它状态的 $cnt$ 值赋为 $0$ 。

接下来我们对每一个 $v$ 执行以下操作：$cnt_{link(v)}+=cnt_{v}$ 。其背后的含义是，如果有一个字符串 $v$ 出现了 $cnt_{v}$ 次，那么它的所有后缀也在完全相同的地方结束，即也出现了 $cnt_{v}$ 次。

为什么我们在这个过程中不会重复计数（即把某些位置数了两次）呢？因为我们只将一个状态的位置添加到 **一个** 其它的状态上，所以一个状态不可能以两种不同的方式将其位置重复地指向另一个状态。

因此，我们可以在 $O(\left|T\right|)$ 的时间内计算出所有状态的 $cnt$ 的值。

最后回答询问只需要查找值 $cnt_{t}$ ，其中 $t$ 为模式串对应的状态，如果该模式串不存在答案就为 $0$ 。单次查询的时间复杂度为 $O(\left|P\right|)$ 。

### 第一次出现的位置

> 给定一个文本串 $T$ ，多组查询。每次查询字符串 $P$ 在字符串 $T$ 中第一次出现的位置（ $P$ 的开头位置）。

我们构造一个后缀自动机。我们对 SAM 中的所有状态预处理位置 $firstpos$ 。即，对每个状态 $v$ 我们想要找到第一次出现这个状态的末端的位置 $firstpos[v]$ 。换句话说，我们希望先找到每个集合 $endpos$ 中的最小的元素（显然我们不能显式地维护所有 $endpos$ 集合）。

为了维护 $firstpos$ 这些位置，我们将原函数扩展为 `sam_extend()` 。当我们创建新状态 $cur$ 时，我们令：

$$firstpos(cur)=len(cur)-1$$

；当我们将结点 $q$ 复制到 $clone$ 时，我们令：

$$firstpos(clone)=firstpos(q)$$

（因为值的唯一的其它选项 $firstpos(cur)$ 显然太大了）。

那么查询的答案就是 $firstpos(t)-\left|P\right|+1$ ，其中 $t$ 为对应字符串 $P$ 的状态。单次查询只需要 $O(\left|P\right|)$ 的时间。

### 所有出现的位置

> 问题同上，这一次需要查询文本串 $T$ 中模式串出现的所有位置。

我们还是对文本串 $T$ 构造后缀自动机。与上一个问题相似，我们为所有状态计算位置 $firstpos$ 。

如果 $t$ 为对应于模式串 $T$ 的状态，显然 $firstpos(t)$ 为答案的一部分。需要查找的其它位置怎么办？我们使用了含有字符串 $P$ 的自动机，我们还需要将哪些状态纳入自动机呢？所有对应于以 $P$ 为后缀的字符串的状态。换句话说我们要找到所有可以通过后缀链接到达状态 $t$ 的状态。

因此为了解决这个问题，我们需要为每一个状态保存一个指向它的后缀引用列表。查询的答案就包含了对于每个我们能从状态 $t$ 只使用后缀引用进行 DFS 或 BFS 的所有状态的 $firstpos$ 值。

这种变通方案的时间复杂度为 $O(answer(P))$ ，因为我们不会重复访问一个状态（因为对于仅有一个后缀链接指向一个状态，所以不存在两条不同的路径指向同一状态）。

我们只需要考虑两个可能有相同 $endpos$ 值的不同状态。如果一个状态是由另一个复制而来的，则这种情况会发生。然而，这并不会对复杂度分析造成影响，因为每个状态至多被复制一次。

此外，如果我们不从被复制的节点输出位置，我们也可以去除重复的位置。事实上对于一个状态，如果经过被复制状态可以到达，则经过原状态也可以到达。因此，如果我们给每个状态记录标记 `is_clone` 来代表这个状态是不是被复制出来的，我们就可以简单地忽略掉被复制的状态，只输出其它所有状态的 $firstpos$ 的值。

以下是大致的实现：

```cpp
struct state {
  bool is_clone;
  int first_pos;
  std::vector<int> inv_link;
  // some other variables
};

// 在构造 SAM 后
for (int v = 1; v < sz; v++) st[st[v].link].inv_link.push_back(v);

// 输出所有出现位置
void output_all_occurrences(int v, int P_length) {
  if (!st[v].is_clone) cout << st[v].first_pos - P_length + 1 << endl;
  for (int u : st[v].inv_link) output_all_occurrences(u, P_length);
}
```

### 最短的没有出现的字符串

> 给定一个字符串 $S$ 和一个特定的字符集，我们要找一个长度最短的没有在 $S$ 中出现过的字符串。

我们在字符串 $S$ 的后缀自动机上做动态规划。

令 $d_{v}$ 为节点 $v$ 的答案，即，我们已经处理完了子串的一部分，当前在状态 $v$ ，想找到不连续的转移需要添加的最小字符数量。计算 $d_{v}$ 非常简单。如果不存在使用字符集中至少一个字符的转移，则 $d_{v}=1$ 。否则添加一个字符是不够的，我们需要求出所有转移中的最小值：

$$d_{v}=1+\min_{w:(v,w,c)\in SAM}d_{w}$$

问题的答案就是 $d_{t_0}$ ，字符串可以通过计算过的数组 $d$ 逆推回去。

### 两个字符串的最长公共子串

> 给定两个字符串 $S$ 和 $T$ ，求出最长公共子串，公共子串定义为在 $S$ 和 $T$ 中都作为子串出现过的字符串 $X$ 。

我们对字符串 $S$ 构造后缀自动机。

我们现在处理字符串 $T$ ，对于每一个前缀，都在 $S$ 中寻找这个前缀的最长后缀。换句话说，对于每个字符串 $T$ 中的位置，我们想要找到这个位置结束的 $S$ 和 $T$ 的最长公共子串的长度。

为了达到这一目的，我们使用两个变量， **当前状态**  $v$ 和 **当前长度**  $l$ 。这两个变量描述当前匹配的部分：它的长度和它们对应的状态。

一开始 $v=t_0$ 且 $l=0$ ，即，匹配为空串。

现在我们来描述如何添加一个字符 $T_{i}$ 并为其重新计算答案：

-   如果存在一个从 $v$ 到字符 $T_{i}$ 的转移，我们只需要转移并让 $l$ 自增一。
-   如果不存在这样的转移，我们需要缩短当前匹配的部分，这意味着我们需要按照后缀链接进行转移：

$$v=link(v)$$

与此同时，需要缩短当前长度。显然我们需要将 $l$ 赋值为 $len(v)$ ，因为经过这个后缀链接后我们到达的状态所对应的最长字符串是一个子串。

-   如果仍然没有使用这一字符的转移，我们继续重复经过后缀链接并减小 $l$ ，直到我们找到一个转移或到达虚拟状态 $-1$ （这意味着字符 $T_{i}$ 根本没有在 $S$ 中出现过，所以我们设置 $v=l=0$ ）。

问题的答案就是所有 $l$ 的最大值。

这一部分的时间复杂度为 $O(\left|T\right|)$ ，因为每次移动我们要么可以使 $l$ 增加一，要么可以在后缀链接间移动几次，每次都减小 $l$ 的值。

代码实现：

```cpp
string lcs(const string &S, const string &T) {
  sam_init();
  for (int i = 0; i < S.size(); i++) sam_extend(S[i]);

  int v = 0, l = 0, best = 0, bestpos = 0;
  for (int i = 0; i < T.size(); i++) {
    while (v && !st[v].next.count(T[i])) {
      v = st[v].link;
      l = st[v].length;
    }
    if (st[v].next.count(T[i])) {
      v = st[v].next[T[i]];
      l++;
    }
    if (l > best) {
      best = l;
      bestpos = i;
    }
  }
  return t.substr(bestpos - best + 1, best);
}
```

### 多个字符串间的最长公共子串

> 给定 $k$ 个字符串 $S_i$ 。我们需要找到它们的最长公共子串，即作为子串出现在每个字符串中的字符串 $X$ 。

我们将所有的子串连接成一个较长的字符串 $T$ ，以特殊字符 $D_i$ 分开每个字符串（一个字符对应一个字符串）：

$$T=S_1+D_1+S_2+D_2+\cdots+S_k+D_k.$$

然后对字符串 $T$ 构造后缀自动机。

现在我们需要在自动机中找到存在于所有字符串 $S_i$ 中的一个字符串，这可以通过使用添加的特殊字符完成。注意如果 $S_j$ 包含了一个子串，则 SAM 中存在一条从包含字符 $D_j$ 的子串而不包含以其它字符 $D_1,\,\ldots,\,D_{j-1},\,D_{j+1},\,\ldots,\,D_k$ 开始的路径。

因此我们需要计算可达性，即对于自动机中的每个状态和每个字符 $D_i$ ，是否存在这样的一条路径。这可以容易地通过 DFS 或 BFS 及动态规划计算。之后，问题的答案就是状态 $v$ 的字符串 $longest(v)$ 中存在所有特殊字符的路径。

## 例题

-   [SPOJ - SUBLEX](https://www.spoj.com/problems/SUBLEX/)
-   [HihoCoder #1441 : 后缀自动机一·基本概念](http://hihocoder.com/problemset/problem/1441)

## 相关资料

我们先给出与 SAM 有关的最初的一些文献：

-   A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler, R. McConnell. **Linear 
      Size Finite Automata for the Set of All Subwords of a Word. An Outline of 
      Results** [1983]
-   A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler. **The Smallest Automaton 
      Recognizing the Subwords of a Text** [1984]
-   Maxime Crochemore. **Optimal Factor Transducers** [1985]
-   Maxime Crochemore. **Transducers and Repetitions** [1986]
-   A. Nerode. **Linear automaton transformations** [1958]

另外，在更新的一些资源以及很多关于字符串算法的书中，都能找到这个主题：

-   Maxime Crochemore, Rytter Wowjcieh. **Jewels of Stringology** [2002]
-   Bill Smyth. **Computing Patterns in Strings** [2003]
-   Bill Smith. **Methods and algorithms of calculations on lines** [2006]

另外，还有一些资料：

-   《后缀自动机》，陈立杰。
-   《后缀自动机在字典树上的拓展》，刘研绎。
-   《后缀自动机及其应用》，张天扬。
-   <https://www.cnblogs.com/zinthos/p/3899679.html>
-   <https://codeforces.com/blog/entry/20861>
-   <https://zhuanlan.zhihu.com/p/25948077>


---

## 作者：KesdiaelKen (赞：551)

拷贝自本人写的[史上最通俗的后缀自动机详解](https://www.luogu.org/blog/Kesdiael3/hou-zhui-zi-dong-ji-yang-xie)，本题的具体题解在文末。

## FBI WARNING：本文大约有1w字，阅读全文大约需要$60$分钟……


网上的解析都太巨佬了，搞得本蒟蒻看了2天才看懂……

感觉本文会比网上大多数文章通俗易懂很多，并且会对程序作具体解析，适合初学者阅读。

本文共分四节，内容大致~~符合政治答题思路~~如下：①干什么以及基本定义②基本思想以及特殊定义③构造方法以及程序具体解析④基本应用以及类比。

**虽然这篇文章是针对初学者，但是读这篇文章之前，请务必了解$trie$、基本的集合知识、基本字符串知识和基本图论知识。如果需要看懂第四节的一些内容，还需要了解后缀数组。**

**本文只是对后缀自动机最基本的思想与构造方法进行详细解析，对于更高级的扩展层面不会多加分析，想了解此方面的同学请自行查找资料（clj的ppt等）。**

**本文很多的表述会在上文中解释，所以如果需要完全理解本文，请务必仔细按顺序阅读。**

**本文借鉴了许多其他文章的表述方法，如有雷同，请见谅。**

## 1. 后缀自动机要干什么

如果要在一个DAG（有向无环图）上表示出一个字符串的所有子串，应该怎么办？

很显然，一个最简单的方法是建立一个trie（字典树），如图。（对于$aabab$建trie，红色为根，黄色为终止节点，边的方向未画出）![](https://cdn.luogu.com.cn/upload/pic/48640.png)

方法是将原串（$n$为其长度，下文默认）的每一个后缀都加入字典树。

大家请观察一下这个字典树，看看它有什么性质。

我们能够直观地总结出来的性质有：

1. 有一个源点，若干个终止点。边代表在目前的字符串后加上的字母。从源点到任意一个节点的任意路径可以形成一个字符串。

2. 从**源点**到任意节点的任意路径形成的字符串均为原串子串。从**源点**到任意节点的任意路径**不能**形成的字符串均**不**为原串子串。（简单来说，这个图可以表示，且仅可以表示出原串的所有子串）

3. 从源点到任意终止节点的任意路径形成的字符串均为原串**后缀**。

4. 从源点出发的任意两条不同路径形成的字符串不相同。

如果满足以上四个性质，那我们便可以用此DAG处理许多事情。比如，判断某一个串是否为原串的子串（做法：从源点跑这个串，跑到$NULL$就说明不是子串）、不同子串个数（做法：DAG上DP）等（后缀自动机可以处理的问题则多得多，因为它有更特殊的性质，这个之后再说）。

**但是**，我们发现了一个问题。这样建立的DAG节点数是$O(n^2)$的。当$n$很大时，这样的复杂度无法接受。事实上，我们发现图中许多的节点都可以合并，比如：$b$之后的部分与$ab$之后的部分完全一致，可以合并。![](https://cdn.luogu.com.cn/upload/pic/48643.png)

我们现在的任务是，构造一个节点数、边数尽量少的DAG满足以上四点条件。

## 2. 后缀自动机特别在哪

先来看一些定义吧。**（这部分是后缀自动机的精髓，也是后缀自动机真正厉害的地方，至于发明者是怎么想到的我完全不能想象（可能是我太菜了））**

对于一个子串，它在原串中可能出现在若干的位置。而一个子串$p$出现的这些位置的右端点标号组成的集合，我们称之为$endpos(p)$（例如原串为$abcab$时，$endpos(ab)=\{2,5\}$）![](https://cdn.luogu.com.cn/upload/pic/48645.png)

现在我们需要证明三个结论，它们将在算法中发挥重要的作用。

###  _1.如果两个子串的$endpos$相同，则其中子串一个必然为另一个的后缀_

设较短的一个串为$t$，较长的一个为$p$，则当命题不成立时，二子串在后$len_t$（$t$的长度）个字符上一定有至少一位不同。但是，因为$t$已经在$endpos(t)$的这些位置匹配上了，即后$len_t$个字符已经在这些位置完全匹配，所以不可能出现这种情况，否则在这些位置上$p$将不能匹配，$endpos(p)$必然不等于$endpos(t)$（实际上是完全不相交）。所以命题得证。（其实这个从直观上意会一下就可以了，证明反而更加不清晰。）

### _2.对于任意两个子串$t$和$p$（$len_t\le len_p$），要么$endpos(t)\in endpos(p)$，要么$endpos(t)∩endpos(p)=$∅_

实际上是结论$1$的逆命题，说明方法同上，分$t$为或不为$p$后缀两种情况讨论。

### _3.对于$endpos$相同的子串，我们将它们归为一个$endpos$等价类。对于任意一个$endpos$等价类，将包含在其中的所有子串依长度从大到小排序，则每一个子串的长度均为上一个子串的长度减$1$，且为上一个子串的后缀（简单来说，一个$endpos$等价类内的串的长度连续）_

显然长度覆盖的区间是连续的，不可能存在空隙。后缀的命题可由结论$2$得到。

对于任意两个$endpos$等价类，它们不会同时包含同一个子串。

下文有一些地方直接用$endpos(i)$表示$endpos$等价类$i$中子串的$endpos$，请读者注意。

由以上三个定理，我们就可以得到一些延伸结论：

### _4.$endpos$等价类个数的级别为$O(n)$_

这个命题比较重要。

对于一个**类（$endpos$等价类简称）**，根据结论$3$，其中有最长的一个子串（$p$）。在$p$第一个字符前添加任意一个字符（满足新形成的字符串为原串子串），得到的字符串必然不属于此类，因此会得到若干个新的类。我们由结论$2$得到新形成的字符串的$endpos$必然为$endpos(p)$的子集。并且在$p$前分别添加两个不同的字符，所得到的两个字符串的$endpos$必然完全不相交。所以对于此操作（在$p$前添加一个字符），我们可以认为是对一个原集合进行分割，分割得到几个新的集合，且保留原集合。当然，新的集合还可以继续分割，但是总的分割的次数（指断痕的个数，$\{1,2,3,4,5\}$分割成$\{1,3\},\{2,4\},\{5\}$的分割次数为$2$）不会超过原集合的大小，所以最终形成的集合个数也不会超过$2n$（线段树的分割方法为子集个数最多的分法）。

由此，因为一切$endpos$都是从$\{1,2,...,n\}$（$n$为原串长度）分割出来的，所以$endpos$等价类个数级别为$O(n)$。（这一部分看不懂可以参考clj的ppt）

考虑**分割**关系。一个原集合分割成若干个子集的操作，是不是很像树的一个节点延伸出若干个子节点？我们发现，所有$endpos$等价类依靠这种分割关系，恰好可以构造出一个树形结构。（有时一个类的某些信息会在其儿子处丢失，例如图中$\{1,2,4,6\}$的儿子是$\{2\}$和$\{4,6\}$，它们丢失了位置$1$的信息。至于原因，第四节会讲。）（下图例子的原串为$aababa$）![](https://cdn.luogu.com.cn/upload/pic/48734.png)

于是，类之间就有了父子关系。

### 我们称这棵树为parent tree

下一个结论

### _5.一个类$a$中，有最长的子串，也有最短的子串，我们称最长子串的长度为$len(a)$，最短子串长度为$minlen(a)$。对于存在父子关系的两个类，设$fa(a)$表示类$a$的父亲（也是一个类）。则：$len(fa(a))+1=minlen(a)$_

这个结论很显然，从我们推理结论$4$的步骤中就可以看出。在一个类中的最长子串前再添加一个字符，形成的字符串就必然属于其儿子中的一类，且这个新形成的字符串肯定是它所属的类中最短的一个。

因此，我们只用在parent tree中保存$len$即可，$minlen$可由其父亲推出来。我们定义$longest(s)$表示$s$类中的最长子串，$shortest(s)$表示$s$类中的最短子串。

我们把每一个类的最长子串写在节点旁，以方便理解。（原串还是$aababa$）![](https://cdn.luogu.com.cn/upload/pic/48736.png)

现在，我告诉大家一个令人震惊的事情：我们要的后缀自动机的节点就是parent tree中的节点！~~妙啊~~（可以认为是parent tree和后缀自动机两个图共用同样的节点）只不过边与parent tree中的不同。其中空串所属的节点（parent tree的根）就是后缀自动机的源点。而终止节点便是最大子串（整个原串）所属于的节点（**属于：这个节点的类包含此子串**），以及其在parent tree上的祖先（标橙）!为什么要这么做呢？因为其节点数很少，且边数也很少（下有证明）。最重要的是，这样形成的图依靠parent tree，有非常有趣的性质，这个本节最后会说。[](https://cdn.luogu.com.cn/upload/pic/48737.png)

我们需要考虑如何建立parent tree，以及如何在这些点上连后缀自动机的边，使得**从源点出发到达点$i$的任意一条路径形成的字符串均属于节点$i$所代表的类。**

完成的后缀自动机如下（蓝色为后缀自动机的边）：![](https://cdn.luogu.com.cn/upload/pic/48741.png)
（太丑了是吗……之后的部分会给更好的图。其实这个图形不符合之后我们讲的后缀自动机的形态，不过这里只是为了展现后缀自动机有多么复杂而已……）

我们先简单说明一下满足条件的后缀自动机是一定存在的。还记得第一节提到的后缀自动机必须满足的四个基本性质吗？对于前三个后缀自动机可以满足。对于第四个，由于上文说道，对于任意两个$endpos$等价类，它们不会同时包含同一个子串，因此到达任意两个不同节点可能形成的字符串均不会重复。现在我们只需要说明边的正确性即可。若对于一个类的所有子串，我们都在它们后面添加一个相同的字符，则得到的所有新的字符串必定都属于另一个相同的类（想想是不是这样）。因此边存在正确性。所以后缀自动机存在。（这里的解释还是不够严谨，如果需要严谨解释可以用类似数学归纳法的方法结合程序说明。因为程序是递推的，初始状态的后缀自动机满足条件，程序正确，所以加入一个新的字符后的后缀自动机也满足条件。这里如果看不懂，可以看完第三节后再尝试理解）

另外，得到点的数量级还不够。下面再证一个比较重要的结论：

### _6.后缀自动机的边数为$O(n)$_

考虑对于一个后缀自动机：先求出其任意一个生成树，舍弃其其它边。我们知道，后缀自动机上有若干个终止节点。于是我们便从每个终止节点往回跑（倒序跑边与字符），对于每个终止节点跑遍所有属于它（这个类）的子串（从终止节点跑其实就是跑原串的后缀）。注意这里的往回跑是指：对于一个子串，按照原本后缀自动机到达其的唯一路径经过的边往回跑，而非见到代表与现在回到的的那一位字符一样的字符的边就往回跑（因为可能有多条代表相同字符的边指向同一个节点）。对于每个终止节点：我们按**一定顺序**跑遍属于它的子串。首先跑第一个子串。如果能顺利跑回源点，则跑下一个子串。否则，我们连上本应该跑回的这条边，并沿着它跑到下一个节点。此时，从这个节点出发，一定有一条或多条路径（经过现存的边）回到源点（因为有树的基础结构），则我们往回跑其中任意一条路径。这样，我们实际走的路径形成的字符串不一定是我们原本希望跑的子串，但是，因为加了一条新边，且是从同样的终止节点开始往回跑的，所以得到的字符串必然是属于此类的一个原串后缀，并且肯定是我们之前没有跑过的。这时，我们只需要将这个字符串在将来要跑的那些子串中划掉，然后重跑我们原本希望跑的子串。这样不断重复，直到真正顺利跑完这个子串。然后我们跑下一个子串。当然，如果这个子串已经被划掉了，我们就再下一个。这样，当跑完一个终止节点时，在原本的生成树上增加的边不会超过这个节点的类包含的子串的个数。于是，对于所有终止节点，它们总共使生成树增加的边数不会超过后缀的个数，即$n$个。而此时，增加了边的后缀自动机已经完整了，因为原串的每一个后缀都在当前的图中被跑出来过了。于是，生成树的边数加$n$，数量级为$O(n)$。（看不懂的同学还是可以去看clj的ppt……）

为了方便理解以上内容，我们再画图讲解一下。![](https://cdn.luogu.com.cn/upload/pic/48878.png)

以上是原串$abcd$的后缀自动机，我们先假设我们并不知道它最终有多少条边，并随机取它的一个生成树：![](https://cdn.luogu.com.cn/upload/pic/48879.png)

终止节点只有$5$一个。属于$5$的后缀有（$abcd,bcd,cd,d$）。我们按照（$cd,d,abcd,bcd$）的顺序跑后缀。跑$cd$时，我们发现可以直接沿$5-4-1$跑回源点，所以跑下一个子串。跑$d$时，我们发现确实有一条$d$边连向$5$,但是跑这条边回到的点的$endpos$是$\{3\}$，并不是应该的$\{1,2,3,4\}$（$d$往回跑一个字符就是去掉其结尾字符得到空串，$endpos$为$\{1,2,3,4\}$）。所以此时我们需要连一条边，从代表$\{1,2,3,4\}$的$1$连到$5$：![](https://cdn.luogu.com.cn/upload/pic/48882.png)

跑$abcd$时，我们先跑回$4$节点，符合条件（去掉末尾剩下$abc$，$endpos$为$\{3\}$，属于节点$4$）。接下来，我们发现无法继续跑回，于是增加从$3$到$4$的$c$边：![](https://cdn.luogu.com.cn/upload/pic/48889.png)

此时剩下$ab$，到达点$3$，我们还是没办法跑它跑回源点。但是，我们不一定要跑它跑回源点，只要能跑回源点就行了。于是，我们往回跑$1$到$3$的边（代表$b$）。那么现在，我们就等于跑了$b+c+d=bcd$的后缀了，它是一个之后我们要跑的后缀，我们把它划掉。然后接着往回跑$abcd$，连上$1$到$2$的边：![](https://cdn.luogu.com.cn/upload/pic/48891.png)

跑$bcd$时，我们发现它已经被划掉了，所以不用跑。

这样，我们跑完了所有后缀，增加了不多于$n$条边，完成了后缀自动机。（这个例子应该看得懂吧）

于是，后缀自动机的空间复杂度便证明完了。

在进入下一节之前，我们再来说一说后缀自动机的特殊性（强行扣题……）。前面说到，后缀自动机的一般性可以让我们处理的问题有：判断子串，计算不同子串个数等。

而后缀自动机的特别之处在于parent tree与节点本身的特殊意义（$endpos$本质为**在原串中出现的位置**的集合）。这就导致可以通过在parent tree上DP得到每一个类中的子串**和在原串中出现的位置相关**的一些信息。例如，出现的次数，第一次出现的位置，出现在某个位置之后的次数等。这就导致后缀自动机可以处理更多类型的题目。

最后，我们梳理一下后缀自动机的性质，这些性质可能会对理解后缀自动机的构造方法有很大作用：

1. 有一个源点，边代表在当前字符串后增加一个字符。

2. 每个点代表一个$endpos$等价类，到达一个点的路径形成的子串必须属于此点的类。

3. 点之间有父子关系，到达点$i$的所有字符串的长度都必然大于到达$fa(i)$的所有字符串的长度，且到达$fa(i)$的任意一字符串必为到达$i$的任意一字符串的后缀。

## 3. 后缀自动机怎么构造

说了这么多，终于讲到构造了。

我们先简单描述一下后缀自动机的形态。后缀自动机大概是长这样子的![](https://cdn.luogu.com.cn/upload/pic/48960.png)

下面那整齐的一行节点表示的就是各个前缀所属的节点。显然，对于任意一个前缀，它在它所属的类中长度是最长的（不能再在其前面添加字符）。而相邻两个前缀所属点之间也肯定有连边。当然，不相邻的节点之间也会有一些边。所以我们把这些节点排成一行，方便观察。

而上面那些零零散散的节点则是不包含任意一个前缀的节点，有一些边连上去，有一些边连下来（注意，连上去的边与连下去的边分割没有那么明显，图只是示意，不要误解），它们之间还有一些连边。这就是后缀自动机的基本结构。

后缀自动机的构造是在线的，即我们通过不断添加单个字符的方式构建后缀自动机，时刻调整其状态。简单来说，我们把原串拆成一个个字符，按顺序塞进后缀自动机里。

先上程序吧。

```
struct NODE
{
	int ch[26];
	int len,fa;
	NODE(){memset(ch,0,sizeof(ch));len=0;}
}dian[MAXN<<1];
int las=1,tot=1;
void add(int c)
{
	int p=las;int np=las=++tot;
	dian[np].len=dian[p].len+1;
	for(;p&&!dian[p].ch[c];p=dian[p].fa)dian[p].ch[c]=np;
	if(!p)dian[np].fa=1;//以上为case 1
	else
	{
		int q=dian[p].ch[c];
		if(dian[q].len==dian[p].len+1)dian[np].fa=q;//以上为case 2
		else
		{
			int nq=++tot;dian[nq]=dian[q];
			dian[nq].len=dian[p].len+1;
			dian[q].fa=dian[np].fa=nq; 
			for(;p&&dian[p].ch[c]==q;p=dian[p].fa)dian[p].ch[c]=nq;//以上为case 3
		}
	}
}
char s[MAXN];int len;
int main()
{
	scanf("%s",s);len=strlen(s);
    for(int i=0;i<len;i++)add(s[i]-'a');
}
```

相信大家肯定看不懂吧……（网上有博客说很好理解？？？）

但至少主函数内的东西应该是看的懂的，即读入原串，然后通过在线的方式一个个加入字符，通过$ans$函数构造后缀自动机。

那么$dian$就是后缀自动机里的节点。结构体里的$len$和$fa$与第二节里的定义一致。而$ch$则与$trie$里的边意义相近。

现在，我们来研究$ans$里的东西了。首先看第一行。$las$是什么？是未加入此字符前最长的**前缀**（整个串）所属的节点的编号。那么$tot$呢？是当前后缀自动机节点的总数。

```
void add(int c)
{
	int p=las;int np=las=++tot;
	dian[np].len=dian[p].len+1;
```

新加入了一位字符$c$（减了$'a'$是为了方便塞进边里，可类比$trie$里对字符的处理）。我们设未加入$c$前的原串为旧串，加入$c$后的原串为新串。显然，此时新串的最长前缀（整个串）所属的节点显然不在原图中（因为原来的所有$endpos$都不可能包含这一位）。而旧串的最长前缀就变成了新串的次大前缀。所以我们用$p$记录新串次大前缀（原串的最大前缀）所属的节点，然后新建一个节点$np$（$tot$加一），存新的最大前缀所属的类。而$len(np)$肯定就是新串的长度，即$len(p)+1$。

注意一下，加入$c$后，$endpos$可能发生变化的字符串只有新串的后缀（或者说，**旧串的后缀加$c$**）（它们无论在旧串出现与否，在新串中出现的次数一定会比在旧串中多$1$）。所以我们的任务就是处理好这些$endpos$发生变化的字符串（**具体做法是遍历旧串后缀（事实上是遍历旧串的后缀自动机的终止节点），看看它们加$c$后$endpos$有没有改变**）。还有，就是对于任意一个$endpos$变化的字符串，它的新$endpos$与原来$endpos$的差别只是多了一个$n$，即新串右端点的位置。因此我们判断一个串的$endpos$是否变化，只需要看其是否在新串最后出现即可。

```
for(;p&&!dian[p].ch[c];p=dian[p].fa)dian[p].ch[c]=np;
```

接下来，我们进行一个循环操作。这个循环操作进行下去的条件是：$!dian[p].ch[c]$（$!p$只是防止其跳出根节点），即$p$没有一条$c$的出边。而$p$每一次循环后会跳到$dian[p].fa$，即$fa(p)$。首先我们得知道往上跳到底是干什么。我们知道存在父子关系节点包含的子串有后缀关系。那么，这个$p$跳$fa(p)$操作的意思即：**一个是$longest(p)$（还记得$longest$是什么意思吗？定义在结论$5$的证明下面）的后缀，且与$longest(p)$所属类不同的最长串所属的类。（这里的$longest$改成$shortest$也无妨）**虽然这里有点绕，但是却对下面的理解尤为重要，请大家熟记。

因为由一个节点往外连一条边就等于允许到达此节点的所有字符串往尾部添加一个新的字符。并且，由于$len(fa(i))+1=minlen(i)$，因此对于$i$和$fa(i)$，它们包含的子串的长度从大到小排序时也是连续的。所以我们把每一个节点想象成所有到达它的字符串的集合。那么，这个**跳$fa(i)$的操作可以理解为压缩地遍历一个串的所有后缀。**（之后会多次直接引用这个思想）在这里，即遍历旧串的所有后缀。

请看回这个循环语句。对于节点$p$，如果它没有$c$边（即$''longest(p)+c''$非旧串子串），那么引一条新边到$np$。这里用上面的思想解释，即**将所有的是旧串后缀且在其后面加$c$形成的新字符串不是旧串子串的后缀往新串的最大后缀所属节点连一条$c$边。**这样的做法显然是正确的，因为这些后缀加了$c$产生的新字符串不是旧串的子串，但是因为是旧串的后缀，加上$c$后必然能在新串最右端出现一次，所以它们也只能在右端点为新串加入字符$c$的位置出现一次。那么这些新字符串的$endpos$为$\{n\}$（还记得是什么吗？原串（这里指新串）的长度）），等同于新串最长前缀的$endpos$。因此向$np$连边是正确的。

注意循环的终止条件。如果长度再短，这些旧串后缀加$c$形成的新字符串就已经在旧串里出现过了，显然与新串最长前缀的$endpos$不同，所以此时要跳出，进行别的处理。

```
if(!p)dian[np].fa=1;//以上为case 1
```

如果已经遍历完了旧串的后缀且它们加$c$一个都不是旧串的子串（它们在新串中的$endpos$都是$\{n\}$），就说明我们已经处理完了新串的所有后缀，完成了任务。所以$np$的$fa$直接设为$1$，表示第一个与新串最长前缀$endpos$不同且为新串最长前缀的后缀的字符串是空串。程序到此可以结束。（也可这样理解：一个节点跳$fa$一定可以跳到$1$，那么连$1$都没有$c$的边，说明$c$根本不是旧串的子串，那就直接把$fa(np)$设成$1$即可）

```
else
{
	int q=dian[p].ch[c];
	if(dian[q].len==dian[p].len+1)dian[np].fa=q;
```

$p$在第一个有$c$边的祖先停下了。先说明一下为什么不用继续往上跳$fa$，判断是否有$c$边了呢？因为显然，再往上跳，跳到的都是现在的$p$中字符串的后缀，且长度还更短，因此在它们的后面再加$c$形成的新字符串显然还是旧串的子串。所以$p$的祖先都有$c$的出边。

此时，我们将$q$设为$p$的$c$出边到达的节点。此时，我们将做一个非常有趣的判断：$len(q)$是否等于$len(p)+1$。这个判断是什么意思呢？因为$''longest(p)+c''$是新串后缀（$longest(p)$是旧串后缀），又因为$len(q)==len(p)+1$，所以$longest(q)==''longest(p)+c''$，所以$longest(q)$是新串后缀。而$q$类中的所有串都是$longest(q)$的后缀。所以到达$q$的所有串都是新串后缀，它们的$endpos$都增加了$n$，到达$q$的所有串的$endpos$一致，符合后缀自动机的定义。由于$q$是我们找到的第一个与$np$不同的且有后缀关系的节点，我们把$fa(np)$设为$q$。处理完问题，可以结束程序。

另外，还是要说明一下为什么不用继续跳$fa$。因为$p$继续跳$fa$，引出的$c$边到达节点$q'$。那么，原先到达$q'$的串的$endpos$肯定都增加了一位$n$。这样，满足_到达同一节点的字符串$endpos$都相同_的性质，不需要处理。所以到此，新串的后缀都已经被检查过了。

为了方便理解以上$case 1$和$ case 2$，我们举个例画图来讲解一下。

以$aaba$为例。初始只有一个源点：![](https://cdn.luogu.com.cn/upload/pic/48943.png)

加入$a$，创建节点$2$，$len(2)=1$，连边，$1$没有$a$的出边，跳到$0$。所以进入$case 1$，直接设$fa(2)=1$。（蓝边表示parent tree，红字表示$len$）![](https://cdn.luogu.com.cn/upload/pic/48952.png)

加入$a$，创建$3$。$2$没有$a$的出边，所以连边，跳$1$。$1$有$a$的出边连向$2$，且$len(2)=1=0+1=len(1)+1$，所以进入$case 2$，直接$fa(3)=fa(2)$。![](https://cdn.luogu.com.cn/upload/pic/49017.png)

加入$b$。创建$4$。$3$和$2$和$1$都没有$b$的出边，连边。所以进入$case1$，直接$fa(4)=1$。![](https://cdn.luogu.com.cn/upload/pic/49018.png)

加入$a$，创建$5$。$4$没有$a$边，跳$1$。$1$有$a$边连向$2$，且$len(2)=len(1)+1$。所以进入$case2$，$fa(5)=2$。![](https://cdn.luogu.com.cn/upload/pic/49020.png)

如图便是$aaba$的后缀自动机，大家检查一下，看看符不符合后缀自动机的性质。

```
else
{
	int nq=++tot;dian[nq]=dian[q];
	dian[nq].len=dian[p].len+1;
	dian[q].fa=dian[np].fa=nq; 
	for(;p&&dian[p].ch[c]==q;p=dian[p].fa)dian[p].ch[c]=nq;//以上为case 3
```

终于来到后缀自动机构造最难理解的部分了。当$len(q)\not=len(p)+1$时怎么办？其实这个式子等价于$len(q)>len(p)+1$，因为$p$可以到$q$，所以$len(q)\ge len(p)+1$。

那么，$len(q)>len(p)+1$代表了什么呢？它代表了还有至少一个比$''longest(p)+c''$更长的串属于$q$。而这个更长的串必定不是新串的后缀，因为如果是，那么去掉其最后一个字符得到的字符串必然是旧串的后缀，且其长度大于$longest(p)$，因此应该先被跳到。然而事实并不是这样。所以，现在出现了一个问题：属于$q$的长度不大于$len(p)+1$的串是新串的后缀（$case2$说明过），但大于$len(p)+1$的串却不是。此时，到达$q$这个节点的字符串并不全属于一个类（准确来说，属于两个类，一类的$endpos$比另一类的$endpos$多出了一个$n$），出现了问题（$q$的$endpos$无法得到定义）。而现在，我们要想办法将其中一个类的子串移到另一个节点上，只保留其中一类的字符串，让$q$的$endpos$可以得到定义。

我们考虑把$endpos$多出了$n$的字符串转移。显然，旧串的后缀自动机中并没有$endpos$与其相同的节点（如果有，那$p$本来就应该连向它）。所以我们新建一个节点$nq$，让$endpos$多出了$n$的字符串转移到此节点。

新建了一个节点，要考虑它的连边，$fa$与$len$。

先考虑$len$。由上文我们知道，长度大于$len(p)+1$的字符串都不可能是新串的后缀。并且，$p$有一条连到$nq$的边。因此，我们把$len(nq)$设为$len(p)+1$。

然后考虑出边。由于$nq$只是$q$拆出来的一个点，我们考虑直接用$q$的边。这样做显然是正确的，因为把$nq$从$q$拆出来只是因为$nq$的$endpos$与$q$不一样。但是，在$q$后和$nq$后加同样的字符，得到的字符串必然属于同一个类（首先，它们之间必然存在后缀关系且在旧串中属于一个类。又因为这个类中的串必定不是新串的后缀（否则就应该先被跳到），没有受到新加入字符的影响，所以在它们新串中还是同属一个类）。

最后考虑$fa$。由于原来的$q$被拆成了两个点$q$与$nq$，且$nq$里的串长度都小于$q$里的串（之前的结论）。我们还知道，对于旧串$len(fa(q))< minlen(q)$，而新串中的$minlen(nq)$等于旧串中的$minlen(q)$,所以旧串中的$len(fa(q))$小于新串中的$minlen(nq)$。因此，我们发现$nq$夹在了$q$和旧串的$nq$之间。又因为它们间是存在后缀关系的。因此，可以看做是$nq$插入到了这个父子关系中。所以我们让$fa(nq)$等于旧的$fa(q)$，然后让$fa(q)$等于$nq$，类似于链表的插入。

此时，我们考虑$np$的$fa$。这个$fa$肯定是$q$和$nq$之一，因为它们最先被跳到。$q$肯定是不行的，因为它的$endpos$没有$n$，而$endpos(np)$有$n$。所以$fa(np)$必为$nq$。

之后，我们进行一个类似$case1$的循环操作，不断往上跳$fa$。只不过，这里的判断条件变成了$dian[p].ch[c]==q$。意思即，因为$q$的$endpos$不包含$n$，而$''longest(p)+c''$的$endpos$必然含$n$，不符合后缀自动机性质，所以我们让这条边连向新的节点$nq$，这样显然是正确的（本就连向$q$，只是$endpos$多了一个$n$，所以连到$len$紧随其后的$fa(q)$，即$nq$）。

那么，为什么当$dian[p].ch[c]\not=q$时，可以不继续跳了呢？那是因为，这时$dian[p].ch[c]$的指向的点肯定是$q$的某个祖先（$p$变短了，并且$''longest(p)+c''$还是原来$''longest(p)+c''$的后缀，所以$q$与$dian[p].ch[c]$满足祖先关系（后缀和长度要求））。那么，我们知道$q$的父亲是$nq$，$endpos$包含$n$，因此$q$的祖先的$endpos$都包含$n$。所以再往上跳，都不会再出现一个节点两种$endpos$的错误情况了。到此，处理完所有问题，结束程序。

另外说一下，程序里$dian[nq]=dian[q]$的语句是压缩的$fa$和边的赋值。可以拆分成：

```
strcpy(dian[nq].ch,dian[q].ch);
dian[nq].fa=dian[q].fa;
```

### _三种情况讲完了！_

讲的好累啊……不知道大家理解了没有。我们继续上图吧（可以对照上面的讲解与程序看一看）。例子：$aababa$。前面$aaba$的图可以继续用。这是$aaba$的后缀自动机：![](https://cdn.luogu.com.cn/upload/pic/49020.png)

加入$b$，创建$6$。$5$没有$b$边，连边，跳$2$。$2$有$b$边连向$4$，但是$len(4)\not=len(2)+1$，（此时$ab$和$aab$都到达$4$，但二者$endpos$不同）所以新建节点$7$，从$4$复制$fa,ch$，$len(7)=len(2)+1=2$，然后令$fa(6),fa(4)$等于$2$。之后跳$fa$，把$2$连向$4$的边连向$7$，$1$连向$4$的边连向$7$。（尽梨了……ppt的曲线就是那么诡异）![](https://cdn.luogu.com.cn/upload/pic/49022.png)

加入$a$，创建$8$。$6$没有$a$的边，连边，跳$7$。$7$有$a$边连向$5$，但$len(5)\not=len(7)+1$，所以新建$9$，重复之前的操作。（不要吐槽parent tree了……）![](https://cdn.luogu.com.cn/upload/pic/49026.png)

以上便是构造后缀自动机的全部内容。下面，我们再来证明一些东西。第二节中，我们已经证明了后缀自动机的空间复杂度。现在让我们来证明后缀自动机构造的时间复杂度。

根据程序我们知道，可能超时的地方只有两个跳$fa$的循环。让我们一一证明它们的均摊时间复杂度是$O(n)$的。

```
for(;p&&!dian[p].ch[c];p=dian[p].fa)dian[p].ch[c]=np;
```

这是$case1$的循环。简单想想就知道，这个循环的真面目，其实就是加边。因为后缀自动机构造的整个过程中，边数都不会减少，所以这里循环的次数应该与边数数量级相同，不会超过$O(n)$。

```
for(;p&&dian[p].ch[c]==q;p=dian[p].fa)dian[p].ch[c]=nq;
```

这是$case3$的循环。这里显然就不能认为是加边了，所以我们得换个思路。是不是可以认为，我们在遍历连向$nq$的边？又因为$nq$一个新建节点，所以下一次进行这个循环的时候，我们不会再遍历上一个$nq$的边。于是，我们可以认为程序对每一个节点的入边都遍历了一次。因此，均摊时间复杂度与边数相同。

## 4. 后缀自动机该怎么用

（下文将把后缀自动机和后缀数组进行对比，请未学习后缀数组的同学补一下，或者跳过一些内容）

后缀数组和后缀自动机能处理的相同问题很多，并且各自也有对方不能处理的问题。

后缀数组的时间复杂度是$O(n\log n)$，但常数较小。后缀自动机的时间复杂度是$O(n)$，但是常数巨大（至少我写的代码是这样的qaq）。但是后缀自动机的做法往往比后缀数组无脑。

下文会列举几个后缀自动机可以解决的问题。如果后缀数组可以解决，也会列出简单解法。

### _问题1：判断子串_

直接在后缀自动机上跑边，跑完串还未跑到$NULL$则为原串子串。

后缀数组：跑出$sa$，然后从最小的后缀开始，一个个往后枚举，记录下当前匹配到的位置，如果匹配不上就下一个后缀，否则位置向后移一位。如果枚举完了后缀还没有完全匹配则不是原串子串。

### _问题2：不同子串个数_

$DAG$上$DP$。对于一个节点$i$，$f[i]$表示从$i$出发的子串个数（不含空串）。那么，$f[i]$就等于$\sum_{(i,j)\in Edge}(f[j]+1)$。$f[1]$即是答案。

后缀数组：每一个后缀的长度减去其$height$之和。

### _问题3:在原串所有子串中（相同的不算一个）字典序第$i$大的是哪个_（[P3975](https://www.luogu.org/problemnew/show/P3975)）

这题比较重要。

首先处理出每个节点的$endpos$大小，即每个类中的串在原串中出现的次数。考虑$dp$，$f[i]$代表$i$的大小。对于不包含任意一个个前缀的节点，$f[i]=\sum _{(i,j)\in Edge}f[j]$，因为比$longest(i)$前面多一个字符的所有字符串的$endpos$的并集必然等于$endpos(longest(i))$。而对于包含前缀的节点，$f[i]=(\sum _{(i,j)\in Edge}f[j])+1$，因为第$1$位的信息在加字符时丢失了。（可以参考第二节的parent tree示意图）（具体到程序来说，只需在$case1$里加一句$f[np]=1$即可）

然后$DP$出$g[i]$，表示从$i$出发的子串个数（不含空集且计算重复），则$g[i]=\sum_{(i,j)\in Edge}(g[j]+f[j])$。

最后，在后缀自动机上$dfs$，按字典序遍历出边，排名还够的减去这边的所有子串，不够的跑到这条出边连向的节点，重复以上步骤。当排名变为非正数时输出跑过的路径形成的字符串。具体做法还请参考本题题解。

### _问题4：判断两个串的最长公共子串_

把两个串拼起来，中间加特殊字符，跑后缀自动机。然后用类似于上面处理出现次数的方法，跑出一个子串在拼起来的串前半部分出现的次数和后半部分出现的次数。然后遍历节点，找$len$最大的前后出现次数都不为$0$的节点。以上思路还可以处理多个字符串的最长公共子串。

后缀数组：同样是拼起来，然后处理$sa$和$height$，对于每个后缀，找到其之后第一个属于另一半部分的后缀（可以$O(n)$做到，具体做法请读者思考），求它们的$lcp$，最后取最大值。

还有一些题目与方法本文可能未涉及到，请多多谅解。毕竟这只是给初学者看的文章，想要了解更高级的内容请自行寻找资料。

后缀自动机思路精巧，处理问题多样，不失为字符串题目的好算法。

## 本题做法

前文提到可以预处理出每个节点中的子串在原串中出现的次数$f[i]$，所以我们枚举每个节点，对于每个节点，如果其$f[i]$不为$1$，则求其$t[i]=f[i]\times len(i)$。$t[i]_{max}$即为答案。

代码：

```
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<iostream>
using namespace std;
int tot=1,las=1;
struct NODE
{
    int ch[26];
    int len,fa;
    NODE(){memset(ch,0,sizeof(ch));len=fa=0;}
}dian[2000010];
struct Edge
{
    int t,nexty;
}edge[2000010];
int head[2000010],cnt=0;
void jia(int a,int b)
{
    cnt++;
    edge[cnt].t=b;
    edge[cnt].nexty=head[a];
    head[a]=cnt;
}
long long zhi[2000010];
inline void add(int c)
{
    register int p=las,np=las=++tot;zhi[tot]=1;
    dian[np].len=dian[p].len+1;
    for(;p&&!dian[p].ch[c];p=dian[p].fa)dian[p].ch[c]=np;
    if(!p)dian[np].fa=1;
    else
    {
        register int q=dian[p].ch[c];
        if(dian[q].len==dian[p].len+1)dian[np].fa=q;
        else
        {
            register int nq=++tot;
            dian[nq]=dian[q];dian[nq].len=dian[p].len+1;
            dian[q].fa=dian[np].fa=nq;
            for(;p&&dian[p].ch[c]==q;p=dian[p].fa)dian[p].ch[c]=nq;
        }
    }
}
char s[2000010];
int cd;
long long ans=0;
void dfs(int node)
{
    for(register int i=head[node];i;i=edge[i].nexty)
    {
        dfs(edge[i].t);
        zhi[node]+=zhi[edge[i].t];
    }
    if(zhi[node]!=1)ans=max(ans,zhi[node]*dian[node].len);
}
int main()
{
    scanf("%s",s);cd=strlen(s);
    for(register int i=0;i<cd;i++)add(s[i]-'a');
    for(register int i=2;i<=tot;i++)jia(dian[i].fa,i);
    dfs(1);
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：shadowice1984 (赞：114)

~~太菜了现在才会SAM~~

网上的教程实在太玄学了……

但是如果想要了解后缀自动机一些比较棒的性质还是有必要了解的

但是这些几乎对大家码代码几乎没啥用……

所以这里写一篇后缀自动机(suffix automation，SAM)的教程好了

## 前置芝士：确定性有限状态自动机(DFA)

一个确定性有限状态自动机是一堆“零件”的集合，可以“识别”一些字符串

 _标准的定义是一个由(Q, Σ, δ, q0, F)构成的5元组，但是这里并不讲解正规定义_ 

如果实用一点来讲的话，DFA是一张图，有一个开始节点，代表空串，有一堆点，各个点并没有实际意义(准确来讲部分自动机，但是不是所有的自动机都要求节点有意义)，点之间有边。

和普通的图区别最大的一点就是，DFA的图的边是有实际意义的，一条边代表了**一种字符**，一个点必须有且仅有每一个字符的出边(如果某个出边无意义，一般的做法是这个出边指向NULL节点)

那么我们发现，如果从起点出发，走出一条路径(随便走，并不要求简单路径)，那么这个路径可以代表一个字符串。

定义一个字符串可以被一个DFA“识别”就是我们从初始点出发，走出这个字符串(显然这个路径必须是存在且唯一的，因为每个节点的某种类型的出边有且仅有一条)之后，我们到达了某些我们指定的节点上，那么就认为这个节点可以被这个自动机识别，另外这些节点在某些博客中被称为“接受节点”

## 前置芝士：子串表示法

我们发现一件事是，我们的后缀自动机，顾名思义，就是可以识别某个字符串S所有的后缀的自动机，会有这样的的性质

我们对这个自动机输入一个任意字符串a,如果这个字符串还在自动机的节点上而没有被打回到NULL节点上，那么我们输入的字符串一定是源串的子串(因为此时们还有输入一些字符让它变成一个后缀的可能，不是子串的话就连可能都没有了)

那么我们可以自豪的说，如果我们可以表示一个串所有的子串，我们就可以建出来一个后缀自动机了

一个显而易见的做法是枚举每个子串，然后每个点代表一个子串，子串之间连边，这样的时空复杂度均是$O(N^2)$不可承受

所以让我们想一个机智的办法

我们用一个点的集合right和一个长度len来描述一个子串

这个子串的特点是，这个长度为len的子串在匹配主串S的时候，如果**右端点**∈right，就可以成功匹配，否则不可以成功匹配，显然这样描述了多个位置不同但是写起来一膜一样的子串

当然为了节约资源，如果一堆子串的right集合相同，我们就就将这些子串压到同一个节点上表示，这个节点只记录一个len，代表这个节点表示的所有子串中，len的最大值，但是，我们在具体实现的时候只记录len但是不记录right，原因后面再讲

# 后缀自动机的构建算法

哎哎哎你什么都没讲就开始讲构造？

这是因为后缀自动机的构造算法是一个名为增量算法的东西，说白了就是一个一个插入字符，这样的话我们就只需要考虑两件事

1.新建几个节点

2.新建的节点连到什么节点上

先来考虑新建几个节点

更加准确的说，加入的这第i个字符会产生几种新子串

第一种是S的第i个前缀，right集合只有i

第二种是S的第i个前缀的某些后缀，right集合有一堆，不只有1

所以好了我们新建两个节点np，nq分别代表第一种和第二种子串

问题来了，谁会向它连边，它又会向谁连边呢？

尽管后缀自动机节点的意义很复杂，但是，如果把表示的子串写出来，会发现不过是某一个字符串的一些后缀而已，因此边的转移的意义就是在这个字符串上加了一个字符x之后变成了一个新的字符串而已，而这些后缀的长度都增加了1，而个数不变，仅此而已。

所以我们找到表示原来第i-1个前缀的节点，让它连一条标号为x的边到np

但是我们会发现一个非常辣手的问题，别的点的right集合如果包含i-1，那么也存在着转移的可能

所以必须找到每一个right集合包含i-1的节点，要怎么找呢

## Parent树

我们发现如果将某个节点的表示的串写出来，是某一个字符串的一些后缀

如果我们在字符串前加入一个字符，那么right集合可能会缩小，因为这个串在原串可以匹配的位置可能减少

另外尽管我们只保存了len最大值，但是len最小值也是客观存在的

考虑这个串一个小一点的后缀，比如长度是len的最小值-1，那么这个后缀代表的节点的right集合必然包含原来节点的right集合，因为可以匹配的位置必然增多，否则这个后缀也可以压缩到这个节点里

然后这个right集合的包含关系可以映射为树上的父子关系

所以在后缀自动机中我们令fa\[x]表示可以包含节点x的right集合，且集合元素最小的点(哦对了，显然right集合不是包含就是不交，因为如果有交的话两个节点表示的子串写出来一样，其实就是一个节点)

根据这个父子关系可以构成一个树称为parent树

有了parent树，就不需要存储right集合了，因为现在我们可以找到这个点子树中所有的叶子结点(显然表示的前缀节点是且仅是叶子结点)，就可以找到这个点的right集合了

-------------

有了parent树，刚才的问题好解决多了，我们枚举第i-1个前缀到树根的所有节点即可

如果这个路径上的节点没有可以转移到x的出边，意味着原来不存在这样的子串，但现在有了，叫np，所以直接连一条标号为x，到np的出边即可

如果我们就这样跑完了整个路径，令fa\[p]=start(开始节点)return即可，**这种情况nq不存在**

另一种比较辣手的情况，路径上节点出现了可以转移到x的出边，并且指向q

此时我们会发现如果两个集合的right集合全等(也就是maxlen(当前节点)+1=maxlen(q)，因为如果最长的串right集合都可以转移，那么其他小一点串当然也可以转移)，我们只需要在q的right集合，以及q的祖先的right集合中插入i即可，所以我们只需要让fa\[np]=q，就完成了隐性插入的工作(抱歉这种情况nq也不存在)

另一种更加辣手的情况，两个集合的right集合不全等

此时证明q已经过时了，该转移到的应该是nq，因为加了一个字符之后写出来的应该是nq代表的字符串，而right集合比q的多，同时，q转移到的点nq都可以，因为这两个串写出来一膜一样，所以复制一边q的出边到nq上，另外当前节点最长的点都可以转移到nq上，所以nq的len应该等于len\[当前节点]+1

此时还没有完，当前结点的祖先如果有连向q的出边，那么都会因为同样的理由过时了，所以全部修改为nq，

最后是parent树的问题，显然nq的right集合是q的right集合∪i(np的right集合)所以令q和np的parent都为nq，同时q的所有祖先还是可以转移的，只是需要加入一个i，同理使用这样的隐性插入法，只需令fa\[nq]=fa\[q]即可

在经历了上述乱七八糟的算法之后，我们终于完成了插入一个字符

但是clj大佬证明了上述的复杂度是均摊$O(1)$换句话来讲，整个sam的构建过程是$O(n)$的

在理解上述算法的时候注意两点

1.建什么新点，连什么新边，parent的树边怎么修改

2.一个节点可能意义比较繁杂，但是写出来的串只有一个串和它的一堆后缀

了解了这两点之后，反复阅读各路神犇的博客，就应该可以掌握SAM的构建了

# 本题题解

额……，我们令叶子节点的size=1.暴力建出parent树然后dfs，求出每个节点的right集合size，然后求$len×size$的最大值就行了

下面就是代码了……(真的很短)

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=3*1e6+10;typedef long long ll;
char mde[N];int nl;ll res;
struct suffixautomation
{
    int mp[N][30];int fa[N];int ed;int ct;int len[N];int siz[N];
    suffixautomation(){ed=ct=1;}
    int v[N];int x[N];int al[N];int cnt;
    inline void add(int u,int V){v[++cnt]=V;x[cnt]=al[u];al[u]=cnt;}
    inline void ins(int c) 
    {
        int p=ed;siz[ed=++ct]=1;len[ed]=nl;//先初始化size和len 
        for(;p&&mp[p][c]==0;p=fa[p]){mp[p][c]=ed;}//然后顺着parent树的路径向上找 
        if(p==0){fa[ed]=1;return;}int q=mp[p][c];//case1 
        if(len[p]+1==len[q]){fa[ed]=q;return;}//case2
        len[++ct]=len[p]+1;//case 3
        for(int i=1;i<=26;i++){mp[ct][i]=mp[q][i];}
        fa[ct]=fa[q];fa[q]=ct;fa[ed]=ct;
        for(int i=p;mp[i][c]==q;i=fa[i]){mp[i][c]=ct;}
    }
    inline void bt(){for(int i=2;i<=ct;i++){add(fa[i],i);}}//暴力建树 
    void dfs(int u)//dfs 
    {
        for(int i=al[u];i;i=x[i]){dfs(v[i]);siz[u]+=siz[v[i]];}
        if(siz[u]!=1){res=max(res,(ll)siz[u]*len[u]);}
    }
}sam;
int main()
{
    scanf("%s",mde+1);//没啥好说的，建sam然后dfs 
    for(nl=1;mde[nl]!='\0';nl++){sam.ins(mde[nl]-'a'+1);}
    sam.bt();sam.dfs(1);printf("%lld",res);return 0;//拜拜程序~ 
}
```










---

## 作者：比利♂海灵顿 (赞：44)

# 后缀自动机（Suffix Automaton）

**一个基于后缀自动机的另一种统计子串出现次数的方法**

[万字（符）长文，博客阅读](https://www.luogu.com.cn/blog/Wild-Donkey/hou-zhui-zi-dong-ji-suffix-automaton)

## 定义

一个字符串的后缀自动机（SAM）是一个 DAG（Directed Acyclic Graph），边（或者说转移）带权，权值是一个字符，除了起始节点 $O$，节点分为两种，一种是中间节点，只是为了连边而新建的节点，一种是结束节点，表示从 $O$ 到它的路径上边的字符连起来是字符串的一个后缀。最容易被忽视的，每个节点一种边只能有一条，也就是说，从某个节点向外连接两条字符为 $b$ 的边是不被允许的。 在所有合法的 DAG 中，后缀自动机是规模最小的一个。

从后缀自动机的 $O$ 点出发，任何一条到达某结束节点的路径上，边的字符连成的字符串都是原字符串的一个后缀。

这样就可以推得后缀自动机的一个性质。

因为一个字符串的任意字串都能表示成它的某个后缀的前缀，而且从 $O$ 出发到任意节点的路径都是从 $O$ 点到某个结束节点路径的一部分。也就是说任意从 $O$ 出发的路径都表示原字符串的后缀的一个前缀， 即原字符串的子串。

**举例**

这是字符串 `sdflk` 的后缀自动机：

![如果看到这个那么图片炸了](https://cdn.luogu.com.cn/upload/image_hosting/f7vjnjow.png)

其中，节点 $①$ 是结束节点，点 $O$ 是起始节点。

## $\mathbf{Endpos}$

引入一个概念，一个字符串的子串 $[l, r]$ 的 $Endpos$ 就是它每次在字符串中出现时的末尾字符位置的集合。

对于 $Endpos$ 有两个引理显而易见：

对于两个子串 $a$, $b$，假设 $len_a < len_b$。

1. 若有 $Endpos_a = Endpos_b$，则 $a$ 是 $b$ 的后缀。

2. 如果 $a$ 是 $b$ 的后缀，则 $Endpos_b \sube Endpos_a$; 否则 $Endpos_a \cap Endpos_b = \varnothing$

引入一个 $Endpos$ 等价类的概念，所有满足 $Endpos_i$ 相等的字符串 $i$ 组成一个 $Endpos$ 的等价类。

所以两个引理的意思是，两个 $Endpos$ 只有一个包含另一个和交集为空两种关系。

推广第一个定理，易知一个等价类中的字符串，短的是长的的后缀。

$Endpos$ 等价类还有一个重要且实用的性质，可以通过反证法推得。等价类中的子串长度是连续的区间，且不存在长度相等的两个字符串。这就是说，一个等价类的每个字符串都是比它短 $1$ 的字符串前面加一个字符得到的。

## $\mathbf{Endpos}$ 等价类树

由于一个 $Endpos$ 等价类中的字符串是由最短的字符串在前面一个一个加字符得到的，那么增加字符的边界就是等价类中最长的字符串。当在一个等价类最长的字符串 $a$ 前面加一个字符，如果得到了一个原字符串的子串 $b$，那么 $Endpos_b$ 一定是 $Endpos_a$ 的子集，$b$ 成为新的等价类的最短的字符串。

因为只要 $b$ 出现的地方，$a$ 必然出现，但是在出现的所有的 $a$ 前面加一个字符得到的一定不全是同一个字符串，否则 $a$ 就不是等价类中最长的字符串了。在这些出现的 $a$ 前面，只要有字符，就能组成一个以 $a$ 为后缀，长度比 $a$ 大 $1$ 的字符串。根据前面得到的结论，所有这些字符串所在的等价类都是 $Endpos_a$ 的真子集。

根据前面的引理得，$a$ 前加字符得到的所有的这些字符串的 $Endpos$ 交集为空。所以对于 $s$ 的子串的所有的 $Endpos$ 等价类根据包含关系组成一个树形结构。这个树以空串的 $Endpos$ 为根，以不同的等价类为节点。

## $\mathbf{Link}$

后缀链接（$Link$），指从一个等价类代表的节点连向这个等价类最短字符串 $a$ 去掉它的左端字符得到的字符串 $b$ 所在节点的指针。也就是从一个节点到它的 $Endpos$ 树上的父亲所在节点的指针。易知 $b$ 是等价类 $Endpos_b$ 中最长的字符串。这里的 $Endpos_a$ 是 $Endpos_b$ 的子集，因为 $b$ 是 $a$ 的后缀，所以 $a$ 出现时，$b$ 必然出现，$b$ 出现时，$a$ 可以不出现。

严格来说，$Endpos_a$ 是 $Endpos_b$ 的真子集，如果 $Endpos_a = Endpos_b$, $a$ 就不是等价类中的最短字符串了，因为 $b$ 也在这个等价类中，且 $b$ 比 $a$ 更短。

由于 $b$ 是 $a$ 的后缀，所以称为后缀链接。

容易发现，后缀链接由下到上组成一个树形结构，而这棵树恰恰就是 $Endpos$ 等价类组成的树形结构。

后缀链接树的节点表示的字符串是这个 $Endpos$ 等价类的最长字符串。总结来说，后缀链接树的节点和 $Endpos$ 等价类一一对应。每一条边都是在一个等价类 $A$ 和满足 $Endpos_B \subsetneq Endpos_A$ 的等价类 $B$ 之间连接的。

## 构造 SAM

如果把规模大小限制去掉，仅构造一个无大小限制的 SAM，可以很容易想到，枚举所有后缀，插入一个 Trie，每个后缀的尾字符是一个终止节点，根是 $O$ 点，把节点上的字符放到它和父亲之间的边上。这样，只要从根走到一个结束节点，就能表示一个后缀。

考虑优化规模，发现对于 `ababab` 这种字符串，Tire 有两条链，但是如果构造一条链

$$
O \xrightarrow{a} 1 \xrightarrow{b} 2 \xrightarrow{a} 3 \xrightarrow{b} 4 \xrightarrow{a} 5 \xrightarrow{b} 6
$$

其中 $2$, $4$, $6$ 是终止节点，再从 $O$ 到 $2$ 连一条 $b$ 的边，那么这就是一个 `ababab` 的后缀自动机了。

但是这种优化是没有章法的，所以接下来尝试利用后缀链接树来构造 SAM。

大体思想是和后缀链接树共用节点，SAM 中 $O$ 点到某个节点的路径表示的字符串属于同一个 $Endpos$ 等价类，最短的字符串是等价类的公共后缀。所以一个节点的入边必然是同一个字符，否则这个节点表示的字符串就不具有公共后缀了。也就是说 SAM 中每个节点和 $Endpos$ 等价类树上的节点一一对应，也和后缀链接树上的节点一一对应。

以后缀链接树的节点为 SAM 的节点，后缀链接树的节点表示的字符串作为 SAM 中 $O$ 走到这个节点的路径表示的所有字符串的最长字符串，SAM 节点的 $len$ 是这个节点表示的最长字符串的长度。以后缀链接树中所有 $Endpos$ 中有元素 $len_s$ 的节点为 SAM 的结束节点，因为这些节点的等价类中的字符串都是 $s$ 的后缀。后缀链接树的根是空串，也是 SAM 的起点 $O$。

考虑递推地构造 SAM。

从边界情况开始，空串的后缀自动机是一个起始节点，后缀链接树只有一个根节点。接下来尝试在空串后面一个一个加字符，同时一边构造后缀自动机，一边维护后缀链接树，因为后缀链接树在后面的构造中会用到。

设新的字符是 $c$，加入字符 $c$ 之前的字符串是 $s$，代表 $s$ 等价类的节点设为 $last$。一个字符加入时，整个字符串长度增加，新字符串 $s + c$ 的节点长度为 $len_s + 1$，只能从唯一的长度为 $len_s$ 的 $last$ 通过一条边 $c$ 转移过来。$s + c$ 等价类中 $Endpos$ 的元素这时只有 $len_s + 1$。

希望找到 $s + c$ 对应的节点的后缀链接，这个点的字符串是 $s + c$ 的后缀，且在所有这些点中满足 $len$ 是最长的一个。满足是 $s + c$ 后缀的节点，必然是由一个 $s$ 的后缀节点通过出边 $c$ 连过来的。$s$ 的后缀节点都是后缀链接树中 $last$ 的祖先，而前面已经把 $last$ 的后缀链接连好了，所以只要顺着 $last$ 的后缀链接往上走就能遍历所有可能满足条件的点了。

一个字符的加入后，在后缀链接树上中从 $last$ 往上跳时（跳到的节点的等价类包含的字符串都是 $s$ 的后缀），有两种情况。

设目前跳到的节点为 $A$，其表示的字符串是 $x$。

* $A$ 有出边 $c$

  这时根据 $len_A$ 再次细分为两种情况。
  
  * $len_A + 1 = len_{A \rightarrow c}$
  
    这时 $A \rightarrow c$（指 $A$ 点通过出边 $c$ 转移到的节点）的字符串是 $x + c$, $A$ 是所有转移到 $A \rightarrow c$ 中的节点中 $len$ 最长的，即 $A \rightarrow c$ 等价类中最长字符串去掉最后的 $c$ 后得到的字符串在等价类 $A$ 中。因为等价类中所有字符串都是这个等价类最长的字符串的后缀，所以 $A \rightarrow c$ 中其它的字符串都是 $x + c$ 的后缀，更是 $s + c$ 的后缀。
    
    从 $last$ 往上跳的过程中，$A$ 是目前找到的 $last$ 的后缀链接树上的最深的满足 $A \rightarrow c$ 的等价类中所有字符串都是 $s + c$ 的后缀的祖先。这时找到的 $x + c$ 是最长的，因为再往上找，$A$ 的长度越来越小，$x + c$ 的长度也越来越小。

    这时 $A \rightarrow c$ 是后缀链接树上 $s + c$ 节点的父亲。

  * $len_A + 1 < len_{A \rightarrow c}$

    在众多有出边 $c$ 连向 $A \rightarrow c$ 的节点中，$A$ 的 $len$ 不是最长的。设通过 $c$ 转移到 $A \rightarrow c$ 的节点中 $len$ 最长的点是 $C$，其对应字符串是 $y$；$A \rightarrow c$ 的字符串是 $y + c$，则 $len_y > len_x$。又因为 $x$ 和 $y$ 在同一个等价类，所以 $x$ 是 $y$ 的后缀。
    
    后缀链接树中，一个节点的 $len$ 一定比它的祖先长，所以 $C$ 不是 $A$ 的祖先。又因为 $C$ 在后缀链接树中不是已经访问到的 $last$ 的比 $A$ 小的祖先，所以 $C$ 不是 $last$ 的祖先。也就是说，$y$ 不是 $s$ 的后缀。

    这时要想找 $s + c$ 的后缀，已知 $x + c$ 是 $s$ 的后缀，所以 $x + c$ 和 $y + c$ 不是一个等价类的。原来的 $A \rightarrow c$ 节点分裂成两个，一个是 $C \rightarrow c$ 节点，其等价类包含原等价类中比 $x + c$ 长的字符串，也就是那些不是 $s + c$ 的后缀的字符串；另一个是新的 $A \rightarrow c$，其等价类包含的是原等价类中长度小于等于 $x + c$ 的长度的字符串，它们是 $s + c$ 的后缀。因为是从一个等价类分裂出来的，所以后者 $Endpos$ 只比前者的多一个元素 $len_s + 1$。

    这时的 $A \rightarrow c$ 应当具有 $C \rightarrow c$ 的所有转移，因为字符串有后缀 $y + c$ 的也一定会有后缀 $x + c$。因为 $x + c$ 的节点的 $len$ 是目前找到的最长的 $s + c$ 的后缀长度，所以 $s + c$ 节点的后缀链接树父亲是 $A \rightarrow c$。又因为 $A \rightarrow c$ 是 $C \rightarrow c$ 的后缀，所以 $A \rightarrow c$ 又是 $C \rightarrow c$ 后缀链接树上的父亲，$C \rightarrow c$ 原来的父亲变成 $A \rightarrow c$ 的父亲。

    最后，由于 $A \rightarrow c$ 是刚被复制出来的，所以对于 $A$ 后缀链接树上的祖先，这时它们的转移 $c$ 仍然指向 $C \rightarrow c$，而 $C \rightarrow c$ 的等价类中只剩下长度大于等于 $len_y + 1$ 的字符串了，$A$ 和它的祖先也就不能转移到 $C \rightarrow c$ 了，所以把 $A$ 和它的原先转移 $c$ 指向 $C \rightarrow c$ 的祖先的转移 $c$ 连向 $A \rightarrow c$。

* 对应节点没有出边 $c$

  这个点的字符串 $x$ 虽然是 $s$ 的后缀，但是 $x + c$，也就是 $s + c$ 的后缀，暂时不存在。所以继续往上跳，直到找到有 $c$ 的转移的节点为止。因为新加入的 $c$ 产生了一个字符串 $x + c$，所以 $A$ 的转移 $c$ 连向 $last \rightarrow c$，表示新出现的第一个 $x + c$ 子串。

  跳到根节点 $O$ 都没找到，说明 $s$ 中一个 $c$ 都没有，而新加入的 $c$ 是第一个。因为我们要找的是 $s + c$ 的后缀链接，必须找到一个节点的等价类中的字符串都是 $s + c$ 的后缀，这时根节点恰好满足这个条件。所以如果跳到最后都没找到，后缀链接直接连向根。

在将 $n$ 个节点全部插入后，后缀自动机和后缀链接树就都建好了，接下来对这种方法构造的时空复杂度和正确性进行证明。

## 正确性

容易发现，只要 $s$ 的后缀 $x_1$，$x_2$ 不在同一个等价类，$x_1 + c$，$x_2 + c$ 也不在同一个等价类。所以对于新节点的建立，只要找出所有 $s$ 的后缀的等价类。

SAM 中的边，终点的公共后缀是在起点的公共后缀后加了一个字符（即这条边表示的字符）得到的字符串的后缀（因为有多个点连向这个终点，每个点公共后缀长度不同，但是一定有一个最短的公共后缀，它的后面加上连向终点的边表示的字符后得到的字符串即为终点的公共后缀）。所以 SAM 中在两点 $A$, $B$ 间连边，设它们表示的字符串（公共后缀）分别为 $a$, $b$，且 $len_a < len_b$。必须满足 $b$ 去掉一个字符后是 $a$ 的后缀。

从 $O$ 点出发，走到某个节点 $A$，由于 $A$ 的字符串去掉最后一个字符 $c$ 后是连向 $A$ 的所有转移的起点的字符串的后缀，所以这些转移相同，都为 $c$。

接下来看起点到结束节点的路径表示的字符串是否表示了 $s$ 的所有后缀。

首先，证明 $O$ 到结束节点的任何路径都表示 $s$ 的一个后缀。所有的结束节点的等价类的字符串都是 $s$ 的后缀，这是我们前面已经说明了的。每个点的等价类中的所有字符串都是这个点的字符串的后缀。换个角度，因为每个结束节点都在一条后缀链接链上，也就是说每个节点的祖先的字符串是它的后缀，即这条链上所有等价类的所有字符串是它的链底节点的字符串的后缀。又因为链底节点是 $s$ 表示的节点，所以 $O$ 到这个点的所有路径表示的字符串都是 $s$ 的后缀。

接下来，证明没有后缀被漏掉。因为等价类内部的字符串是连续的，所以只要证明链上等价类的最长字符串 $a$ 和这个节点儿子等价类中最短的字符串 $b$ 是否满足 $len_a + 1 = len_b$ 即可。如果存在 $x$, 使得 $len_a + 1 < len_x < len_b$，且 $a$ 是 $x$ 的后缀，$x$ 是 $b$ 的后缀，那么 $x$ 所在的节点应该是 $b$ 所在节点的父亲，$a$ 所在节点的儿子。但是 $a$ 所在节点的儿子是 $b$ 所在节点的父亲，所以假设不成立，原命题得证。

接下来证明时空复杂度时，将字符集的规模都暂时视为常数。

## 空间复杂度分析

先分析点数的复杂度。由于每次加入一个字符时必然加入一个节点，而且有一定概率会添加第二个节点，所以后缀自动机最多有 $2n$ 个节点。由于前两个字符加入时只会加入一个节点，再加上空串的一个节点，所以可以得到更紧确的上界 $2n - 1$。

SAM 的所有信息都是直接存在点对应的结构体中的，一个点包含的内容是一些指针和一些属性值，只要将字符集看作常数，则一个点的空间是常数。因为有线性数量的点，所以空间复杂度为线性，$O(n)$。

## 时间复杂度分析

总的时间复杂度一定是 $O(n) * 每加入一个字符的均摊时间复杂度$，所以分析每次加入字符的复杂度。

加入一个字符的时间取决于每个节点加入时寻找 $A$ 点（$Last$ 有转移 $c$ 的最小祖先）的向上跳的次数，还有每次新建节点时将 $A$ 的转移 $c$ 连到 $C \rightarrow c$ 上的祖先的 $c$ 连回 $A \rightarrow c$ 上要更换转移的节点数。

先分析向上跳的次数，这取决于从 $Last$ 往上有多少没有转移 $c$ 的祖先。节点数是线性的，它们的转移只能产生不能消失，所以一共有线性的节点没有转移 $c$，所以总共最多添加线性数量的转移 $c$。又因为字符集视为常数，所以所有的向上跳的次数为线性。

接下来是修改转移的时候，设从 $s + c$ 到空串的后缀链接链为 $L_{len_s + 1}$，其节点（除了空串节点）都是由 $A$ 到空串节点的后缀链接链 $L_{len_s}$ 上的点转移来的。每个节点只有一条转移 $c$，所以 $L_1$ 上向 $C \rightarrow c$ 转移的节点最多有 $Len_{L_{len_s}} - Len_{len_s + 1} + 1$ 个（无需连根节点）。也就是说如果 $L_i$ 的 $k$ 个节点被修改转移，则 $len_{L_i} \leq len_{L_{i + 1}} - k + 1$，所以总的修改转移的节点数为节点数 + 转移数，两者都是线性，所以这一步总复杂的也是线性。

## 模板 ([Luogu3804](https://www.luogu.com.cn/problem/P3804))

给一个字符串，求这个字符串出现次数大于 $1$ 的子串的长度和出现次数的积的最大值。

$len_s \leq 10^6$

现在普遍的做法是构造后缀自动机，在表示前缀的节点（也就是每次加入字符首先创建的节点）上进行标记，然后在后缀链接树上跑 DFS，进行子树查询，但是这样需要邻接表记录一个节点的后缀链接入边，显然我是懒得打的，于是我在做题的时候想到了一种新的做法。

我一开始尝试找规律，发现可以在自动机的转移边上跑 DFS，在结束节点上打标记，统计每个点 DFS 树上的子树和，能走到结束点的路径数，这便是这个节点的等价类的字符串出现的次数。

这样做的原因也很简单，一个子串必然是一个后缀的前缀，所以这个子串的出现次数，就是这个子串作为前缀的后缀的出现次数之和。这个子串做前缀的后缀必然可以从这个子串转移到。从某个点搜起，它搜索树上儿子出现一次，它也会出现一次，所以只要统计搜索树上子树和即可。

既然知道了一个 $Endpos$ 等价类的出现次数，统计最大值只要考虑这个等价类中最长字符串即可，所以用这个等价类出现的次数乘这个节点的 $len$ 即可尝试更新答案。

## 代码

首先是算法主体

```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <map>
#include <queue>
#include <vector>
#define Wild_Donkey 0
using namespace std;
unsigned m, n, Cnt(0), t, Ans(0), Tmp(0);
short nowCharacter;
char s[1000005];
struct Node {
  unsigned Length, Times; // 长度(等价类中最长的), 出现次数
  char endNode;           // 标记 (char 比 bool 快) 
  Node *backToSuffix, *SAMEdge[26];
}N[2000005], *CntN(N), *Last(N), *now(N), *A, *C_c;
int main() {
  scanf("%s", s);
  n = strlen(s);
  for (register unsigned i(0); i < n; ++i) {
    Last = now;                                       // Last 指针往后移 
    A = Last;                                         // s 对应的节点
    nowCharacter = s[i] - 'a';                        // 取字符, 转成整数 
    now = (++CntN);                                   // s + c 对应的节点
    now->Length = Last->Length + 1;                   // len[s + c] = len[s]
    while (A && !(A->SAMEdge[nowCharacter])) {        // 跳到 A 有转移 c 的祖先 
      A->SAMEdge[nowCharacter] = now;                 // 没有转移 c, 创造转移 (Endpos = {len_s + 1})
      A = A->backToSuffix;
    }
    if(!A) {                                          // c 首次出现 
      now->backToSuffix = N;                          // 后缀链接连根
      continue;                                       // 直接进入下一个字符的加入 
    }
    if (A->Length + 1 == A->SAMEdge[nowCharacter]->Length) {  
      now->backToSuffix = A->SAMEdge[nowCharacter];   // len[a] + 1 = len[a->c] 无需分裂
      continue;
    }
    (++CntN)->Length = A->Length + 1;                 // 分裂出一个新点 
    C_c = A->SAMEdge[nowCharacter];                   // 原来的 A->c 变成 C->c 
    memcpy(CntN->SAMEdge, C_c->SAMEdge, sizeof(CntN->SAMEdge));
    CntN->backToSuffix = C_c->backToSuffix;           // 继承转移, 后缀链接 
    C_c->backToSuffix = CntN;                         // C -> c 是 A -> c 后缀链接树上的儿子
    now->backToSuffix = CntN;                         // 连上 s + c 的后缀链接 
    while (A && A->SAMEdge[nowCharacter] == C_c) {    // 这里要将 A 本来转移到 C->c 的祖先重定向到 A->c 
      A->SAMEdge[nowCharacter] = CntN;                // 连边
      A = A->backToSuffix;                            // 继续往上跳 
    }
  }
  while (now != N) {                                  // 打标记 
    now->endNode = 1;                                 // 从 s 向上跳 (从 s 到 root 这条链上都是结束点)
    now = now->backToSuffix;
  }
  DFS(N);                                             // 跑 DFS, 统计 + 更新 Ans 
  printf("%u\n", Ans);
  return Wild_Donkey;
}
```

最后补充一个普普通通的 `DFS()`，记忆化搜索

```cpp
inline unsigned DFS(Node *x) {
  unsigned tmp(0);
  if(x->endNode) {      
    tmp = 1; 
  }
  for (register unsigned i(0); i < 26; ++i) {
    if(x->SAMEdge[i]) {               // 有转移 i 
      if(x->SAMEdge[i]->Times > 0) {  // 被搜索过 
        tmp += x->SAMEdge[i]->Times;  // 直接统计 
      }
      else {                          // 未曾搜索 
        tmp += DFS(x->SAMEdge[i]);    // 搜索 
      }
    }
  }
  if (tmp > 1) {                      // 出现次数不为 1 
    Ans = max(Ans, tmp * x->Length);  // 尝试更新答案 
  }
  x->Times = tmp;                     // 存储子树和 
  return tmp;                         // 子树和用于搜索树上的父亲的统计 
}
```

## 小结

这次后缀自动机的学习时间线拉的很长，从 `Apr.1st 2021` 学完后缀数组，本以为是后缀自动机的前置知识，结果没想到根本没用上，只能从零开始。

一开始漏了一个条件，以为一个点可以有多个不同转移，认为一个超级源点连向 $n$ 个点，$n$ 个点再连成一条链，简单粗暴，突破了 $2n - 1$ 的点数下界，得到了图灵奖级别的成果，结果被成功自我否定。

后来写代码，出现了很多匪夷所思的问题，最后写好了 DFS，运行发现输出 $0$，找了好久才意识到 `DFS()` 在 `main()` 没调用。

第一次交发现没看见 "出现次数不为 $1$"，害得我对着代码看了好久，我真是憨得过分。

最后找到了问题，过了模板以后把递归跳边改成了 `main()` 里面循环跳边，怎么都调不动，发现是打标记时没有初始化有问题。

收尾博客时证明打标记和搜索的正确性，证不动了去看题解，猛然发现自己的方法和他们不一样，收获了意外之喜，于是自己口胡了一个证明，如有问题希望指正。

经常有在机房对着电脑一晚上抓耳挠腮的歇斯底里，也有文化课上拿着打印的材料偷偷研究，博客也是像挖隧道一样艰难推进，代码更是最后两天才动工，直到今天 `Apr.9th 2021` 一周多的跌跌撞撞，终于算是结束了这个节点的学习。

然后在我因为搞出新做法，花了一晚上审稿，将我熟悉的半角标点改成全角，满怀信心地交题解的时候，因题解过多被禁止提交该题题解。(最后交上了)

---

## 作者：all_for_god (赞：1)

给一个可以[画出 SAM 结构的网站](https://yutong.site/sam/)。（从机房大佬那里偷的）
但听管理大大说这个东西画广义 SAM 的时候有点问题，详细见洛谷讨论 [悲惨故事 长文警告 关于广义 SAM 的讨论](https://www.luogu.com.cn/discuss/322224?page=5)。
然后洛谷管理大大给了一个他自己做的网站：[SAM Visualizer](https://wzj33300.github.io/sam-visualizer/)。~~就是好像会在随机时间 404 掉~~。

## 模板
### 简介
SAM 几乎可以算是信息竞赛中字符串的终极解决方案。几乎所有的比较难的字符串题都可以通过 SAM 的性质结构之类的东西延伸出来。
事实上，更准确的说 SAM 更像数据结构，是一种与 tire 树类似的东西。
其结构是一张 DAG 与 一棵树的和，这二者的点集都是一样的。DAG 上的边与 trie 上的类似，都是表示一个字母。
通过走 DAG 上的边，我们可以表示这个字符串的所有子串，通过走 parent 树上的边，我们可以表示所有当前节点表示的子串的所有后缀。
### endpos
endpos 实际上是一个集合。具体而言，endpos 是 $s$ 的字串 $s'$ 在 $s$ 中出现位置的末尾的集合。
因此，根据定义，显然有性质：（下面简写 endpos 为edp，$edp(a)$ 表示字串 $a$ 的 edp 集合，所有 edp 集合相同的字串所构成的集合成为 edp 等价类）
1. $
edp(a)\subseteq  edp(b)\Leftrightarrow b$ 是 $a$ 的后缀 
2. $
edp(a)\nsubseteq edp(b)\Leftrightarrow b$ 不是 $a$ 的后缀 
3. 同一 edp 等价类中所有字符串长度不等且连续

我们发现一个 edp 等价类里的所有字串具有类似的性质，因此我们考虑将所有 edp 等价类的字串变成一个点来看待。

根据简介里的介绍，我们发现如果我们创建出一张 DAG，可以像 trie 一样通过走 DAG 上的边到达所有后缀，那么就可以表示所有子串了。（任意一个子串都一定是某个后缀的前缀）
这个就是其叫“后缀自动机”的理由，我们从根节点走到叶子结点一定表示了一个原串的后缀，而我们将所有某个 edp 等价类中的点压缩到了一个节点上，这样就形成了一个 DAG。

这里以 `abbb` 为例。请先忽略掉红色的边。
![1](https://cdn.luogu.com.cn/upload/image_hosting/jhrcxhgd.png)


### 后缀链接及parent树
由于一个 edp 等价类中所有的字符串长度相同且连续，因此如果我们将某个 edp 等价类中的最短的那个字符串的最前面的字符删去，那么新得到的这个更短的字符串就一定在更多的地方出现过。
我们将更短的这个字符串所在的 edp 等价类所对应的点与原来的 edp 等价类所对应的点连边。这就是所谓的后缀链接。

根据定义，我么可以发现空字符串所对应的节点不会有边连出，而其他每个节点有且仅有一条边连出。因此所有的后缀链接以及点构成了一棵树。我们将这棵树称作 parent 树。对于一个点 $u$，我们将其连出的后缀链接所指向的点称作 $fa_u$。

反过来看，如果我们将连边的过程看成在当前节点对应的最长的字符串前面加点，然后向加点的字符串的对应的点连边，那么显然可以看出其子节点的 edp 集合是当前点的 edp 集合的一个划分，其所有子集和的 edp 集合不交且包含于当前节点的 edp 集合。
不过需要注意的是，其所有子节点的 edp 集合的并可能并不是其的 edp 集合。

我们设 $len_u$ 表示节点 $u$ 所代表的所有字符串中最长的长度，$minlen_u$ 表示最短的长度。根据定义显然有 $minlen_u-1=len_{fa_u}$。这个结论比较重要。

仍然是那个例子，按照上面的定义将后缀链接建出来就是上面那张图中红色的边。点上的 $Max$ 表示的就是这个点所对应的 $len$。

### 线性构造
然后就来考虑如何建出这两个东西。我们通过一个一个将字符插入进 SAM 来构造。假设我们当前插入的是字符 $s_i$，而 $[1,i-1]$ 所代表的字符串的 SAM 已经构建完毕。

在具体讲述之前，先需要强调的是我们不具体保存下来每一个点所对应的 edp 集合是什么以及所对应的字符串是什么。我们只是存下来了后缀链接、DAG 上的边和 $len$。（$minlen$ 不需要记是因为可以通过 $fa$ $O(1)$ 求）

我们设 $lst$ 表示前 $i-1$ 个字符所对应的字符串所在的节点编号。
显然对于一个新的字符及其位置，我们需要一个新的点来表示，设为 $u$。而且其 $len$ 一定 $len_{lst}+1$。

我们假设一个变量 $p$，其初始值是 $lst$。可以发现如果 $p$ 所对应的点在 DAG 上没有 $s_i$ 的出边，那么在这个点所对应的所有字符串后面都加上一个 $s_i$，那么这所有新的字串的 edp 一定都包含 $i$ 这个位置。因此我们将 $p$ 新增一条在 DAG 上的指向 $u$ 的边。注意这时 $p$ 是 $lst$，$lst$ 的 edp 集合中一定有 $i-1$ 这个位置。
然后发现如果令 $p\gets fa_p$ 并且跳了 parent 树上的边后新的 $p$ 在 DAG 上 **仍然没有 $s_i$ 这条边**，上述逻辑依然成立。注意，在 parent 树上跳 $fa$ 本质上是在前面删去节点，跳后节点中的所有子串一定是跳前节点中子串的真后缀。这样 $p$ 中的所有子串的 edp 集合中仍然一定有 $i-1$ 这个位置。

如果 $p$ 一直到达最初表示空串的节点，那么表示这个字符是新出现的，将 $fa_u$ 设为表示空串的节点即可。
如果某个时刻 $p$ 在 DAG 上有这条边，那么设 $q$ 为 $p$ 走 DAG 上 $s_i$ 的边所到达的点。

由于 $p$ 所代表的所有字符串仍然是前 $i-1$ 个字符所表示的字符串的后缀，因此在后面加上一个节点 $s_i$ 后字符串也理应是前 $i$ 个字符所表示的字符的后缀。
但是有可能会有从其他方向连来的边 DAG 上的边到 $q$，因此可能会分为两类串：
1. 长度小于等于 $len_p+1$ 的字符串，其来源一定是 $p$ 中的字符串后面接上一个 $s_i$ 来的。
2. 长度大于 $len_p+1$ 的字符串，其来源一定不是 $p$ 后接上 $s_i$，也就是说这些串一定不是前 $i$ 个字符所组成的串的后缀。

发现加上 $s_i$ 之后第一类点的 edp 集合会多上 $i$ 这个位置，而第二类点的 edp 集合保持不变，同时我们的 $fa_u$ 一定是连向第一种情况中的字符串。因此我们需要将 $q$ 拆成两个点来看待。特别的，如果 $len_q$ 已经等于 $len_p+1$，那么无需拆点，直接 $fa_u\gets q$ 即可。

考虑如何拆点。我们新建点 $nq$ 表示第一类字符串所表示的点，原来的 $q$ 表示第二类字符串所表示的点。
我们先让 $nq$ 继承 $q$ 的所有信息，然后根据上面有 $len_q\gets len_p+1$。由于原来的 $q$ 中的所有子串共后缀且长度连续，因此第一类点的所有字符串都是第二类点的字符串的后缀，且一定是最长的能找到的后缀。因此有 $fa_q\gets nq$。
然后所有 $p$ 的后缀然后走 DAG 上 $s_i$ 这条边如果原来走到的是 $q$，那么现在走到的一定是 $nq$。如果不是 $p$ 的后缀的，那走到的一定仍然是 $q$。
因此我们通过一直跳 $fa_p$ 的方式来修改对 DAG 的影响。

然后有一些细节可能要仔细想想。比如说 edp 集合实际上是一直在变的。由于我们没有记录每个节点具体的 edp 集合长什么样，因此除了 $q$ 节点，其他所有节点的对应的字符串的 edp 集合都是同步变动的，我们并不需要去管。
SAM  诸如此类的细节问题实际上不少，但是这里就不一一赘述了。

然后就做完了。下面是插入第 $x$ 个字符的代码。变量名基本和上面的一致。
```cpp
void insert(int x){
	int u=++idcnt,p=lst,v=s[x]-'a';a[u].len=a[lst].len+1;
	while(p&&a[p].ch[v]==0) a[p].ch[v]=u,p=a[p].fa;
	if(!p) {a[u].fa=1;}
	else
	{
		int q=a[p].ch[v];
		if(a[q].len==a[p].len+1){a[u].fa=q;}
		else{
			int nq=++idcnt;a[nq]=a[q];
			a[nq].len=a[p].len+1,a[q].fa=a[u].fa=nq;
			while(p&&a[p].ch[v]==q) a[p].ch[v]=nq,p=a[p].fa;
		}
	}
	lst=u;
}
```

### 复杂度
复杂度的话空间显然是线性的。
时间的话~~应要求~~简要叙述一下。

我们发现我么只需要证明 SAM 所包含的点数与边数都为线性即可证明 SAM 的时间复杂度为线性。
首先点数是线性的这个相对显然，因为每一次插入最多分裂出一个点来。

对于边，我们将其分开来考虑。
后缀链接显然是线性的，毕竟构成一棵树同时点数是线性的。
DAG 上可能加边的地方有两个：开始时向上跳后缀链接连边以及分裂点后向上跳后缀链接修改 DAG 上的边。
对于第一种情况，由于点数是线性的，字符集大小是常数，因此复杂度是线性的。（好像可能可以类比一下 AC 自动机？实际上均摊下来每个点都只会被修改一次，。但不管怎么说都一定是线性的。）
对于第二种情况，就比较复杂了，让我们借鉴一下 oi wiki 的思路。
我们设 $t$ 表示 $p$ 这个节点表示的最长的字符串，显然这是 $[1,i-1]$ 这个字符串的一个后缀。每迭代一次，$t$ 的长度一定递减。
可以发现，在这个循环开始前，最初的 $p$ 距离 当前的 $lst$ 至少要经过 $2$ 条后缀链接。
这最后一句话很难理解：在这个循环结束后，最后的 $p'$ 对应 $t'$，有字符串 $t'+s_i$ **成为路径上第二个从 $u$ 出发的后缀链接**。而在下一轮中，当前的 $u$ 又会成为新的 $lst$。（好像也找不到更好的表述方式）
因此，作为当前字符串的后缀的字符串：$link_{link_lst}$ 这个点最长的字符串，其在字符串中的位置一定单增。这样就有这个位置至多单增 $n$ 次，也就证明了第二部分的复杂度是线性的。

最后观察到 SAM 的时空复杂度都要带一个字符集大小的系数。如果字符集过大，可以用 map 来保存 DAG 上的边，但是复杂度会多一个 $\log$。

## 应用

上面说了这么多，但是 SAM 最后只有 DAG 以及 parent 树保存了下来，而具体的 edp 集合长什么样以及每个节点对应哪些字符串之类的东西都没有，那我们算这些干什么呢？

事实上，SAM 的主要作用是提供运算的平台以及一些性质。（这就是为什么这东西更像数据结构的原因）
以洛谷上的模板题举例。

### [P3804 【模板】后缀自动机（edp 集合大小）](https://www.luogu.com.cn/problem/P3804)

计算出现次数不为 1 的子串的出现次数乘上其长度的最大值。
这个题用了 SAM 的一个比较常见的套路，就是在 parent 树上做类似于树形 DP 的东西。

可以发现一种子串的出现次数就是其这个字符串所在的节点的 edp 集合大小。
考虑哪些节点的 edp 会包含 $i$ 这个位置，我们找到前缀 $i$ 对应的节点，然后从这个点一直跳到根都会包含 $i$，相当于链加 1。
因此我们将每个前缀的对应节点的初始大小设为 1，然后求子树和即可。发现前缀的对应节点就是每次插入节点的 $u$。直接做就可以了。

#### code

实际上很多 SAM 题掌握板子后很快就可以写出来。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3e6 + 7;
string s;
int lst = 1, idcnt = 1, cnt[N], tot[N];
long long ans = 0;
vector<int> t[N];
struct node {
	int fa, ch[26], len;
} a[N];
void insert(int x) {
	int u = ++idcnt, p = lst, v = s[x] - 'a';
	a[u].len = a[lst].len + 1;
	while (p && a[p].ch[v] == 0) a[p].ch[v] = u, p = a[p].fa;
	if (!p) {
		a[u].fa = 1;
	} else {
		int q = a[p].ch[v];
		if (a[q].len == a[p].len + 1) {
			a[u].fa = q;
		} else {
			int nq = ++idcnt;
			a[nq] = a[q];
			a[nq].len = a[p].len + 1, a[q].fa = a[u].fa = nq;
			while (p && a[p].ch[v] == q) a[p].ch[v] = nq, p = a[p].fa;
		}
	}
	cnt[u] = 1;
	lst = u;
}
void dfs1(int u) {
	for (int i = 0; i < tot[u]; i++) {
		int v = t[u][i];
		dfs1(v);
		cnt[u] += cnt[v];
	}
	if (cnt[u] != 1) ans = max(1ll * ans, 1ll * cnt[u] * a[u].len);
}
signed main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> s;
	int len = s.length();
	for (int i = 0; i < len; i++) insert(i);
	for (int i = 1; i <= idcnt; i++) t[a[i].fa].push_back(i), tot[a[i].fa]++;
	dfs1(1);
	cout << ans;
	return 0;
}
```
### 后记
给一些比较常用的板子题。

[P1368 【模板】最小表示法（最小循环位移）](https://www.luogu.com.cn/problem/P1368)

[P4070 [SDOI2016] 生成魔咒（动态插入后缀整体本质不同子串个数）](https://www.luogu.com.cn/problem/P4070)

[P3975 [TJOI2015] 弦论（本质不同/位置不同子串个数求第 k 大子串）](https://www.luogu.com.cn/problem/P2408)

[SP1811 LCS - Longest Common Substring（双串最长公共子串）](https://www.luogu.com.cn/problem/SP1811)

[SP1812 LCS2 - Longest Common Substring II（多串最长公共子串）](https://www.luogu.com.cn/problem/SP1812)

[P6640 [BJOI2020] 封印（两串区间最长公共子串）](https://www.luogu.com.cn/problem/P6640)

应用这块个人的博客写了比较多，但是洛谷不太能支持代码块折叠，如果放上来就太长了。因此这里只在最后放博客的链接。上面这些题都是写了题解的。（可能也会更新点别的？）

个人可能比较菜，写博客喜欢写比较长，放上很多刚开始想不到和想不清楚的细节，不像机房里的大佬一句话就可以讲完一道题还比较本质，就是可能我这种不是很理解本质以及做题不熟练的、对 SAM 结构和性质理解不深的不太能懂，因此自己总结会比较详细。

[我的 SAM 博客](https://www.cnblogs.com/allforgod/p/18835714)。

---


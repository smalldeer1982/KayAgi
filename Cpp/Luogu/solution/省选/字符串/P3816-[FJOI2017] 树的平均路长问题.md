# [FJOI2017] 树的平均路长问题

## 题目描述

一棵树 $T$ 的平均路长 $IPL(T)$定义为：

$IPL(T)=\sum_{v\varepsilon T}length(path(v))$

其中， $v$ 是树 $T$ 中的内结点， $length(path(v))$是从树根到结点$v$的路径长度。

红黑树是一类特殊的二叉搜索树，其中每个结点被“染成”红色或黑色。若将二叉搜索树结点中的空指针看作是指向一个空结点，则称这类空结点为二叉搜索树的前端结点。并规定所有前端结点的高度为$-1$。除了前端结点外，其他结点均为内结点。

一棵红黑树是满足下面“红黑性质”染色二叉搜索树：

1. 每个结点被染成红色或黑色；

2. 每个前端结点为黑色结点；

3. 任一红结点的儿子结点均为黑结点；

4. 在从任一结点到其子孙前端结点的所有路径上具有相同的黑结点数。

从红黑树中任一结点 $x$ 出发(不包括结点 $x$)，到达一个前端结点的任意一条路径上的黑结点个数称为结点 $x$ 的黑高度，记作 $bh(x)$。红黑树的黑高度定义为其根结点的黑高度。

给定正整数 $n$，试设计一个算法，计算出在所有含有 $n$ 个结点的红黑树中，平均路长的最大值。


## 样例 #1

### 输入

```
1
2
3
0```

### 输出

```
1
3
5
0```

# 题解

## 作者：shadowice1984 (赞：5)

# 打表是不行的！

~~我就是N!爆搜，爆零，写$O(n^2)$暴力也绝对不打表！~~

~~打表是不可能打表的，这辈子都不可能打表的……~~

事实上代码还是非常好写的……，但是推不出来结论就gg了
________________

## 本题题解

首先我们会发现这道题和红黑树这个数据结构没有任何关系……，所以我们可以考虑一个非常朴素的树形dp……(PS:如果你对红黑树足够了解的话会发现题目中描述的实际上是一只松弛红黑树，即去掉了根节点必须是黑的这个限制)

首先我们要最大化的式子是

## $\sum_{i=1}^{n}Dep_{i}$

如果我们分别考虑每一个边的贡献，那么我们会发现每一个i的父亲边在深度值的计算中恰好被算了$siz_{i}$次

所以我们要最大化的式子又可以写成

## $\sum_{i=1}^{n}size_{i}$

其实不应该加上1号节点点的size的，但是由于这里的1号节点深度为1，所以我们平常的边深度和这里的点深度之和刚好差了一个$size_{i}$因此我们要最大化的东西就是

## $\sum_{i=1}^{n}size_{i}$

那么如果足够熟练的话可以很快的列出这样的一个dp式子，直接无脑的求什么列什么就行了……

我们令$Dp_{i,j,k}(j \in {0,1})$表示$size$为$i$的一只红黑树，黑高为k，根节点颜色为j，0表示红，1表示黑，的最大$size$之和

那么我们由于这是一个二叉树，所以我们按照在二叉树上的dp的一般套路，枚举左儿子的size，从而右儿子的size就可以确定，从而转移起我们的dp

然后另外两个限制分别是黑高相等和不能有两个相邻的红色点条件，直接在转移式子里面表达就行了，推出来大概长这样……

## $Dp_{i,0,k}=(max_{p=0}^{i-1}Dp_{p,1,k}+Dp_{i-1-p,1,k})+i$

这个是红色点的式子，由于不可以有两个相邻的红色点因此全部由黑色的dp转移过来，然后我们这里暴力枚举了左儿子的$size=p$，另外由于是红点，所以黑高不变

对于黑点的dp则是下面这3个式子取max

## $(max_{p=0}^{i-1}Dp_{p,1,k-1}+Dp_{i-1-p,1,k-1})+i$

## $(max_{p=0}^{i-1}Dp_{p,0,k-1}+Dp_{i-1-p,1,k-1})+i$

## $(max_{p=0}^{i-1}Dp_{p,0,k-1}+Dp_{i-1-p,0,k-1})+i$

还是一样的枚举左儿子size，注意分下情况讨论左右儿子的颜色进行转移，因为自己是黑点所以我们是由黑高减1的状态转移过来的

最后无论如何总的size都会+i，所以加上i

然后我们冷静分析一波算法的复杂度，发现这个算法的复杂度是$O(n^2logn)$

似乎铁定会T飞啊……但是像本题rk1这种无脑打表的思路肯定是不可取的啊，因为这道题当年考试的时候不让打表。

所以我们需要一些一些奇技淫巧来帮我们手动加速转移……

_________________

假设你是一名julao，在即将AK之时输出了dp数组的最优转移点

这里先附上暴力打出dp数组的转移点的generator~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=3*1e4+10;
int dp[2][N][17];int fr[2][N][17];int ans[N];
int main()
{
	for(int i=0;i<=100;i++)for(int k=0;k<=8;k++)dp[0][i][k]=dp[1][i][k]=-0x3f3f3f3f;
	dp[1][0][0]=0;
	for(int i=1;i<=100;i++)
	{
		for(int k=0;k<=8;k++)
		{
			for(int j=0;j<=i-1;j++)
			{
				if(dp[0][i][k]<dp[1][j][k]+dp[1][i-1-j][k])
				{dp[0][i][k]=dp[1][j][k]+dp[1][i-1-j][k];fr[0][i][k]=j;}
			}dp[0][i][k]+=i;
			if(dp[0][i][k]>0)
			printf("dp[%d][%d][%d]=%d:fr %d\n",0,i,k,dp[0][i][k],fr[0][i][k]);
		}
		for(int k=1;k<=8;k++)
		{
			for(int j=0;j<=i-1;j++)
			{
				if(dp[1][i][k]<dp[1][j][k-1]+dp[1][i-1-j][k-1])
				{dp[1][i][k]=dp[1][j][k-1]+dp[1][i-1-j][k-1];fr[1][i][k]=j;}
				if(dp[1][i][k]<dp[1][j][k-1]+dp[0][i-1-j][k-1])
				{dp[1][i][k]=dp[1][j][k-1]+dp[0][i-1-j][k-1];fr[1][i][k]=j;}
				if(dp[1][i][k]<dp[0][j][k-1]+dp[0][i-1-j][k-1])
				{dp[1][i][k]=dp[0][j][k-1]+dp[0][i-1-j][k-1];fr[1][i][k]=j;}
			}dp[1][i][k]+=i;
			if(dp[1][i][k]>0)
			printf("dp[%d][%d][%d]=%d:fr %d\n",1,i,k,dp[1][i][k],fr[1][i][k]);
		}
	}
	for(int i=1;i<=100;i++)
	{
		for(int k=0;k<=8;k++)
		{ans[i]=max(ans[i],dp[0][i][k]);ans[i]=max(ans[i],dp[1][i][k]);}
	}return 0;
}
```

________________


这里我们截取了这张表的最后一小部分

$ dp[0][98][3]=582:fr 34$

$dp[0][98][4]=671:fr 15$

$dp[0][98][5]=631:fr 31$

$dp[1][98][4]=643:fr 7$

$dp[1][98][5]=683:fr 15$

$dp[1][98][6]=631:fr 31$

$dp[0][99][3]=589:fr 35$

$dp[0][99][4]=679:fr 15$

$dp[0][99][5]=641:fr 31$

$dp[1][99][4]=651:fr 7$

$dp[1][99][5]=693:fr 15$

$dp[1][99][6]=641:fr 31$

$dp[0][100][3]=594:fr 36$

$dp[0][100][4]=687:fr 15$

$dp[0][100][5]=649:fr 31$

$dp[1][100][4]=659:fr 7$

$dp[1][100][5]=702:fr 15$

$dp[1][100][6]=649:fr 31$

我们仔细观察会发现这个转移似乎非常的有规律……

具体来讲经过细致的观察我们会得到这样的规律

每个dp状态$i,j$有且仅有两个合理的转移点(显然可能变的转移维度只有i这一维了)

1.i-p,其中p为离i最接近的二的整次幂，且小于i

2.如果这个点是红点，那么转移点为$2^k-1$,否则是$2^{k-1}-1$

(打表真好用.gif)

然后我们根据这个决策唯一性优化，可以将转移强行加速到$O(1)$，这样我们就可以以$O(nlogn)$的速度轻松通过本题~

上代码


``` C

#include<cstdio>
#include<algorithm>
using namespace std;const int N=3*1e4+10;
int dp[2][N][18];int tr[N];int ans[N];
int main()
{
	for(int i=0;i<=N-10;i++)for(int k=0;k<=17;k++)dp[0][i][k]=dp[1][i][k]=-0x3f3f3f3f;
	for(int i=2,k=1;i<=N-10;i++){if(k<<1<i){k<<=1;}tr[i]=k;}
	for(int i=2;i<=N-10;i++){tr[i]=i-tr[i];}
	dp[1][0][0]=0;//注意初始条件，哨兵只有黑色 
	for(int i=1;i<=N-10;i++)
	{
		for(int k=0;k<=17;k++)//按照唯二合法的转移点转移就行了 
		{
			int tr1=(k==0)?0:(1<<k)-1;if(i-1>=tr1)
			{
				dp[0][i][k]=max(dp[1][tr1][k]+dp[1][i-tr1-1][k],dp[1][tr[i]][k]+dp[1][i-tr[i]-1][k]);
				if(dp[0][i][k]<0){dp[0][i][k]=-0x3f3f3f3f;}else {dp[0][i][k]+=i;}//这里注意重置一下，避免爆inf 
			}int ret;tr1=(k==0)?0:(1<<(k-1))-1;
			if(k>=1&&(i-1>=tr1))
			{
				ret=max(dp[1][tr1][k-1]+dp[1][i-tr1-1][k-1],dp[1][tr[i]][k-1]+dp[1][i-tr[i]-1][k-1]);
				dp[1][i][k]=max(dp[1][i][k],ret);
				ret=max(dp[0][tr1][k-1]+dp[1][i-tr1-1][k-1],dp[0][tr[i]][k-1]+dp[1][i-tr[i]-1][k-1]);
				dp[1][i][k]=max(dp[1][i][k],ret);
				ret=max(dp[1][tr1][k-1]+dp[0][i-tr1-1][k-1],dp[1][tr[i]][k-1]+dp[0][i-tr[i]-1][k-1]);
				dp[1][i][k]=max(dp[1][i][k],ret);
				ret=max(dp[0][tr1][k-1]+dp[0][i-tr1-1][k-1],dp[0][tr[i]][k-1]+dp[0][i-tr[i]-1][k-1]);
				dp[1][i][k]=max(dp[1][i][k],ret);
				if(dp[1][i][k]<0){dp[1][i][k]=-0x3f3f3f3f;}else {dp[1][i][k]+=i;}
			}
		}
	}
	for(int i=1;i<=N-10;i++)//处理答案表 
	{
		for(int k=0;k<=17;k++)
		{ans[i]=max(ans[i],dp[0][i][k]);ans[i]=max(ans[i],dp[1][i][k]);}
	}
	while(1)//然后直接查表就行了 
	{
		int t;scanf("%d",&t);if(t!=0)printf("%d\n",ans[t]);else {break;}
	}printf("0");return 0;
}
```







---

## 作者：Mr_Li (赞：3)

啊，好久没有写题解了~

看到这道题，大家首先想到的一定是一个会TLE的DP：

设f[i][j][0]表示大小为i的黑高度为j的以红色节点为根节点的红黑树中平均路长的最大值，f[i][j][1]表示大小为i的黑高度为j的以黑色节点为根节点的红黑树中平均路长的最大值，可以列出DP方程：

f[i][j][0]=max{f[k][j][1]+f[i-k-1][j][1]+i},

f[i][j][1]=max{f[k][j-1][0]+f[i-k-1][j-1][0]+i,f[k][j-1][0]+f[i-k-1][j-1][1]+i,f[k][j-1][1]+f[i-k-1][j-1][0]+i,f[k][j-1][1]+f[i-k-1][j-1][1]+i}.

这个DP的时间复杂度是O(n^2 log n)，因为一棵有n个节点红黑树的高度至多是2 log (n+1)，当n=30000时使用这个算法程序往往要运行数分钟。
如何过这道题呢？

我们有了可以在数分钟解决n=30000的算法，设当n=1,2,…,30000的答案是a[1],a[2],…,a[30000],使用此算法打表记录a数组即可。

……

代码交上去，"Unknown Error"…

原因很简单，提交的代码会有长度限制，一般OJ都是要求代码长度不超过50KB,还不清楚洛谷这边怎样，反正直接用C++初始化记录的数组的方法打表代码将近200KB，是交不上去的。

考虑减少代码量。

我们发现a数组相邻两项的差并不是很大，大多都在(-100,100)之间，于是我们设b[i]=a[i+1]-a[i],打表记录a[1]和b数组，代码长度变为90KB左右。
90KB还是太长，我们可以按类似上述的方法继续减少代码，设c[i]=b[i+1]-b[i],发现大多时候c每一项∈(-10,10),打表记录a[1],b[1]和c数组，代码长度60KB左右。

到这里大家一定想到设d[i]=c[i+1]-c[i],打表记录a[1],b[1],c[1]和d数组，然而c的值域已经很小了，小到了其绝对值几乎只有个位数和十位数，所以代码长度并不会减少太多。

观察打表代码，发现代码中出现了大量的逗号，这是由于要初始化过长的整型数组，于是想到用一个字符来表示一个数，借此初始化字符串，比如我们设ascll码为0的字符表示0,ascll码为1的字符表示1…但是我们在C++代码中用一个字符来表示ascll码为0,1,…的字符，所以我们设ascll码为111的字符表示0,ascll码为112的字符表示1…代码长度一下子被优化到约30KB，实测可以交上去，轻轻松松拿到Rank 1.

以往写完题解，我都会附上自己的代码，然而代码太长，我就破例不附了。

哦，对了，当年福建省选这道题不让打表。

……

……

……

---


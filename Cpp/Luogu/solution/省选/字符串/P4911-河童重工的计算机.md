# 河童重工的计算机

## 题目背景

河童重工业会社的计算机产品在幻想乡中有着极其广泛的应用。

有一天，妖怪之山发大水啦！洪水夹杂着泥沙和滚木汹涌着冲进了河童的城市。

本来河童们的机械设施都是防水的，可是洪水还是对城市造成了不小的破坏。其中，河童们的服务器被砸坏了！

坏掉的电脑在短时间内不能修复，可是幻想乡里的许多事情都离不开河童们的服务器！河童们也很无奈，于是荷取找到了你！你作为一名优秀的信竞选手，决定帮助荷取，减轻服务器故障所带来的压力。

## 题目描述

你从荷取那里得到了一份纸质资料，扫描版在这里：

[Ktx-65式微处理器汇编语言规范文件.pdf](https://www.touhou-oi.tk/uploads/Ktx-65%E5%BC%8F%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%E6%96%87%E4%BB%B6.pdf)

（若此网站无法打开，请在附件中下载）

（为什么说是扫描版呢，因为，你应该不能复制里面的文字）

以下这一段是汇编教程附带的示例：
```asm
[ progfunc.asm ]
[ Shows the function functionailties of the KTX-65 ALI ]

[main]
wint #line;    [output the current physical line number]
wch 13;        [putchar \r]
wch 10;        [putchar \n]
callfunc $Function1;
callfunc $Function2;
hlt;           [halt]

function $Function1;
rint %r1;      [read int]
add %r2 1 %r2; [loop contents]
lle %r2 %r1;   [loop conditions]
jif 2;         [end loop conditional jump]
wint %r2;      [output int]
wch 13;        [putchar \r]
wch 10;        [putchar \n]
ret;           [return]

function $Function2;
rint %r1;      [read int]
rint %r2;      [read int]
add %r1, %r2;  [add]
wint %val;     [output value]
wch 13;        [putchar \r]
wch 10;        [putchar \n]
ret;           [return]
```
你需要用洛谷评测机支持的语言编写一个程序，它读入一个Ktx-65汇编语言程序和一段输入，解释运行这个程序，然后输出这个程序输出的东西。

## 说明/提示



**注意**：样例输出中只有9这一个字节。

**保证一行中只有一个指令。**

对于10%的数据：程序中只有输入和输出的指令，且不会出现数字常量，也不会有注释。

对于另外10%：程序中只有输入、输出和加法指令，且没有注释。

对于另外30%：包括除函数调用和跳转在内的所有指令。

对于剩下50%：指令没有限制。

对于全部的数据：命令条数不超过50000条，剩余输入不超过500千字节，程序需要执行的步数不超过80000步。

保证汇编程序和数据不出现编译或是运行时错误。

保证程序输入足够满足汇编程序中读入的需要。

不保证这是或不是一道毒瘤题

不保证考试时会不会有人AC这道题

不保证这次考试会不会有人AK

保证出题人为：[洩矢诹访子](https://www.luogu.org/space/show?uid=53151)

考试时打不开河童给的文件可以向我索要，不保证是否会回答

~~其实这道题数据非常简单，只是量大而已~~

## 样例 #1

### 输入

```
5
rint %r1;
rint %r2;
add %r1 %r2;
wint;
hlt;
5 4```

### 输出

```
9```

# 题解

## 作者：Edgaru089 (赞：43)

完整的阅读体验见 [https://blog.edgaru089.ml/index.php/oi/problem/luogu-p4911-ktx-65-solution/](https://blog.edgaru089.ml/index.php/oi/problem/luogu-p4911-ktx-65-solution/)

#### 作为出题人，我有责任写一篇题解（逃

这题的初衷就是一个庞大的大模拟，刚刚见到未来程序改这道题有着一种自然的熟悉感呢（笑）

但是不像那道题，这道题没有什么语义树之类的高深的东西呢，只有对代码能力的考察，像我这种初中三年荒废在搞项目的人，代码功底还可以说是十分扎实的呢（笑）

#### 关心一下注释的格式：

注释是可以嵌套的，像 ```[[] putchar 65; ]``` 这样的根本不会有什么输出呢

标程中，我是用std::function存下每一个指令对应的处理函数，然后解释调用

第一步，先把程序分拆成tokens，去掉注释，记录行号和function定义位置，替换为set指令
第二步，把tokens转换成指令和数据源，同时替换callfunc为call指令

最后别忘了，call和ret时栈中要压入调用处指令地址和当前的%line寄存器的值这两个值呢

以下是标程（八月就定稿了

```cpp
/* Ktx-65 Assembly Language Interpreter */
/* Ktx-65 汇编语言解释器 */
/* Copyright (c) Kawasiro Nitori & Moriya Suwano of Kappa Heavy Industries Co.,Ltd. */
/* 版权所有 河童重工业会社 河城荷取 洩矢诹访子 */

/* 版本：审议稿 */
/* 平成三十年 八月 十一日 */


#include <cstdlib>
#include <iostream>
#include <stack>
#include <functional>
#include <map>
#include <vector>
#include <initializer_list>
#include <string>
#include <fstream>
#include <cstring>
using namespace std;


bool compileErrorLevel = false;
void compileError(int line, string message) {
    // TODO Compile Error
    cout << "[ERROR] Interpreter encountered a Compile Error on line " << line << endl;
    cout << "    Message: " << message << endl;
    compileErrorLevel = true;
}

#define compileAssert(line, statement, message) \
(!!(statement) || [](int l, string state, string m)->bool {compileError(l, "Compile Assertation Failed: " + m + ", Statement: " + state); return false; }(line, #statement, message))

void toupper(string& str) { for (char& c : str)c = toupper(c); }
string touppers(const string& str) { string a = str; toupper(a); return a; }

class AssemblyProgram {
public:

    enum Command {
        Undefined = 0,  // Undefined
        Halt = 1,       // Stops the program
        NoOp,           // Does nothing
        // Memory Access
        Set,            // Read value from <0> into <1>
        // Streamline control
        Jump,           // Jump to <0>(absolute line number, begins from 1)
        JumpIf,         // Jump to <0> if <1> is not zero (takes rFlag if <1> doesn't exist)
        Call,           // push current linenum+1 to sAddr and jump to <0>(begins from 1)
        Return,         // jump to sAddr.top() and sAddr.pop()
        // Arithmetic operations
        // rVal if not exist↓
        Inverse,        // <1> = -<0>
        Add,            // <2> = <0> + <1>
        Minus,          // <2> = <0> - <1>
        Multiply,       // <2> = <0> * <1>
        IntDivide,      // <2> = <0> / <1>
        Modulo,         // <2> = <0> % <1>
        LeftShift,      // <2> = <0> << <1>
        RightShift,     // <2> = <0> >> <1>
        BitAnd,         // <2> = <0> & <1>
        BitOr,          // <2> = <0> | <1>
        BitXor,         // <2> = <0> ^ <1>
        // Logical Operations
        // rFlag if not exist↓
        Greater,        //  <2> = <0> > <1>
        Less,           //  <2> = <0> < <1>
        GreaterEqual,   //  <2> = <0> >= <1>
        LessEqual,      //  <2> = <0> <= <1>
        Equal,          //  <2> = <0> == <1>
        LogicalAnd,     //  <2> = <0> && <1>
        LogicalOr,      //  <2> = <0> || <1>
        // Console I/O
        //        rVal if not exist ¡ý
        ReadInt,        //  cin >> <0>
        ReadChar,       // getchar(<0>)
        WriteInt,       // cout << <0>
        WriteChar,      // putchar(<0>)
        // Keep at last - command count
        CommandCount
    };

    enum VariableType {
        Constant,
        Pointer,
        Memory
    };

    struct DataSource {
        int* valptr;
        int valconst;
        int* valmemidptr;
        AssemblyProgram* prog;
        VariableType type;
        int& operator ()() {
            if (type == Constant)
                return valconst;
            else if (type == Pointer)
                return *valptr;
            else {
                int id = *valmemidptr;
                if (id >= memsize || id < 0) {
                    prog->runtimeError("Memory acess out of range");
                    valconst = 0;
                    return valconst;
                }
                return prog->mem[id];
            }
        }
    };

    void halt() {
        // TODO Halt
        running = false;
    }

    void runtimeError(string message) {
        // TODO Runtime Error
        cout << "[ERROR] Interpreter encountered a Runtime Error on instruction " << nextptr + 1 << ", clock cycle " << clockCounter << endl;
        cout << "    Message: " << message << endl;
        running = false;
    }

private:
    // Exception-Safe Wrappers
    void pushAddr(int val) { if (sAddr.size() >= stackSize)runtimeError("sAddr Stack Overflow"); sAddr.push(val); }
    int topAddr() { if (sAddr.size() <= 0) { runtimeError("sAddr Access Error(size = 0)"); return 0; } else return sAddr.top(); }
    void popAddr() { if (sAddr.size() <= 0)runtimeError("sAddr Stack Underflow"); else sAddr.pop(); }
    int popAddrRet() { if (sAddr.size() <= 0) { runtimeError("sAddr Stack Underflow"); return 0; } else { int val = sAddr.top(); sAddr.pop(); return val; } }
    int readMem(int id) { if (id >= memsize || id < 0) { runtimeError("Memory Access Error(Read)"); return 0; } else return mem[id]; }
    void writeMem(int id, int val) { if (id >= memsize || id < 0)runtimeError("Memory Access Error(Write)"); else mem[id] = val; }
    int lineProgramId(int line) { auto i = commandLines.find(line); if (i == commandLines.end()) { runtimeError("Jump Line Number Invalid"); return 0; } else return i->second; }

private:
    // Command Handlers
    void funcSet(vector<DataSource>& l) { l[1]() = l[0](); nextptr++; }
    void funcJmp(vector<DataSource>& l) { nextptr = lineProgramId(l[0]() + rLine); }
    void funcJIf(vector<DataSource>& l) { if (l.size() <= 1) { if (rFlag)nextptr = l[0]() + lineProgramId(rLine); else nextptr++; } else { if (l[1]())nextptr = l[0]() + lineProgramId(rLine); else nextptr++; } }
    void funcCall(vector<DataSource>& l) { pushAddr(rLine); pushAddr(nextptr + 1); nextptr = lineProgramId(l[0]()); }
    void funcRet(vector<DataSource>& l) { if (l.size() > 0)rRet = l[0](); nextptr = popAddrRet(); rLine = popAddrRet(); }
    void funcInv(vector<DataSource>& l) { int* p;  if (l.size() <= 1)p = &rVal; else p = &l[1](); (*p) = -l[0](); nextptr++; }
    void funcAdd(vector<DataSource>& l) { int* p;  if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() + l[1](); nextptr++; }
    void funcSub(vector<DataSource>& l) { int* p;  if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() - l[1](); nextptr++; }
    void funcMult(vector<DataSource>& l) { int* p; if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() * l[1](); nextptr++; }
    void funcIDiv(vector<DataSource>& l) { int* p; if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() / l[1](); nextptr++; }
    void funcMod(vector<DataSource>& l) { int* p;  if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() % l[1](); nextptr++; }
    void funcLSft(vector<DataSource>& l) { int* p; if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() << l[1](); nextptr++; }
    void funcRSft(vector<DataSource>& l) { int* p; if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() >> l[1](); nextptr++; }
    void funcBAnd(vector<DataSource>& l) { int* p; if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() & l[1](); nextptr++; }
    void funcBOr(vector<DataSource>& l) { int* p;  if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() | l[1](); nextptr++; }
    void funcBXor(vector<DataSource>& l) { int* p; if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() ^ l[1](); nextptr++; }
    void funcLGr(vector<DataSource>& l) { int* p;  if (l.size() <= 2)p = &rFlag; else p = &l[2](); (*p) = l[0]() > l[1](); nextptr++; }
    void funcLLs(vector<DataSource>& l) { int* p;  if (l.size() <= 2)p = &rFlag; else p = &l[2](); (*p) = l[0]() < l[1](); nextptr++; }
    void funcLGE(vector<DataSource>& l) { int* p;  if (l.size() <= 2)p = &rFlag; else p = &l[2](); (*p) = l[0]() >= l[1](); nextptr++; }
    void funcLLE(vector<DataSource>& l) { int* p;  if (l.size() <= 2)p = &rFlag; else p = &l[2](); (*p) = l[0]() <= l[1](); nextptr++; }
    void funcLEql(vector<DataSource>& l) { int* p; if (l.size() <= 2)p = &rFlag; else p = &l[2](); (*p) = l[0]() == l[1](); nextptr++; }
    void funcLAnd(vector<DataSource>& l) { int* p; if (l.size() <= 2)p = &rFlag; else p = &l[2](); (*p) = l[0]() && l[1](); nextptr++; }
    void funcLOr(vector<DataSource>& l) { int* p;  if (l.size() <= 2)p = &rFlag; else p = &l[2](); (*p) = l[0]() || l[1](); nextptr++; }
    void funcRInt(vector<DataSource>& l) { if (l.size() <= 0)cin >> rVal; else cin >> l[0](); nextptr++; }
    void funcRCh(vector<DataSource>& l) { if (l.size() <= 0)rVal = getchar(); else l[0]() = getchar(); nextptr++; }
    void funcWInt(vector<DataSource>& l) { if (l.size() <= 0)cout << rVal; else cout << l[0](); nextptr++; }
    void funcWCh(vector<DataSource>& l) { if (l.size() <= 0)putchar(rVal); else putchar(l[0]()); nextptr++; }

public:
    void initalaize() {
#define REGISTER_RAW(command, name) \
commands[name] = command; names[command] = name
#define REGISTER_HANDLER(command, handler, minParamCount, name)    \
handlers[command] = [this](vector<DataSource>& l) {if (l.size() < minParamCount)runtimeError("Paramater Count Mismatch"); else handler(l); }; \
/*handlers[command] = bind(&AssemblyProgram::handler, this, placeholders::_1);*/ \
commands[name] = command; names[command] = name
        REGISTER_RAW(Undefined, "UDEF");
        handlers[Undefined] = [this](vector<DataSource>&) { runtimeError("Undefined Command Called"); };
        REGISTER_RAW(Halt, "HLT");
        handlers[Halt] = [this](vector<DataSource>&) { halt(); };
        REGISTER_RAW(NoOp, "NOP");
        handlers[NoOp] = [this](vector<DataSource>&) {};
        REGISTER_HANDLER(Set, funcSet, 2, "SET");
        REGISTER_HANDLER(Jump, funcJmp, 1, "JMP");
        REGISTER_HANDLER(JumpIf, funcJIf, 1, "JIF");
        REGISTER_HANDLER(Call, funcCall, 1, "CALL");
        REGISTER_HANDLER(Return, funcRet, 0, "RET");
        REGISTER_HANDLER(Inverse, funcInv, 1, "INV");
        REGISTER_HANDLER(Add, funcAdd, 2, "ADD");
        REGISTER_HANDLER(Minus, funcSub, 2, "SUB");
        REGISTER_HANDLER(Multiply, funcMult, 2, "MULT");
        REGISTER_HANDLER(IntDivide, funcIDiv, 2, "IDIV");
        REGISTER_HANDLER(Modulo, funcMod, 2, "MOD");
        REGISTER_HANDLER(LeftShift, funcLSft, 2, "LSFT");
        REGISTER_HANDLER(RightShift, funcRSft, 2, "RSFT");
        REGISTER_HANDLER(BitAnd, funcBAnd, 2, "BAND");
        REGISTER_HANDLER(BitOr, funcBOr, 2, "BOR");
        REGISTER_HANDLER(BitXor, funcBXor, 2, "BXOR");
        REGISTER_HANDLER(Greater, funcLGr, 2, "LGR");
        REGISTER_HANDLER(Less, funcLLs, 2, "LLS");
        REGISTER_HANDLER(GreaterEqual, funcLGE, 2, "LGE");
        REGISTER_HANDLER(LessEqual, funcLLE, 2, "LLE");
        REGISTER_HANDLER(Equal, funcLEql, 2, "LEQL");
        REGISTER_HANDLER(LogicalAnd, funcLAnd, 2, "LAND");
        REGISTER_HANDLER(LogicalOr, funcLOr, 2, "LOR");
        REGISTER_HANDLER(ReadInt, funcRInt, 0, "RINT");
        REGISTER_HANDLER(ReadChar, funcRCh, 0, "RCH");
        REGISTER_HANDLER(WriteInt, funcWInt, 0, "WINT");
        REGISTER_HANDLER(WriteChar, funcWCh, 0, "WCH");
#undef REGISTER_RAW
#undef REGISTER_HANDLER
        program.clear();
        nextptr = 0;
    }

    bool pushCommand(int fileline, string name, vector<DataSource> param) {
        toupper(name);
        auto i = commands.find(name);
        if (i == commands.end()) {
            compileError(fileline, "Invaild command \"" + name + "\"");
            return false;
        }
        else {
            program.push_back(make_pair(i->second, param));
            if (commandLines.find(fileline) == commandLines.end())
                commandLines[fileline] = program.size() - 1;
            return true;
        }
    }

    int* getRegister(int fileline, string name) {
        toupper(name);
        if (name == "R1")
            return &rR1;
        else if (name == "R2")
            return &rR2;
        else if (name == "R3")
            return &rR3;
        else if (name == "R4")
            return &rR4;
        else if (name == "E1")
            return &rE1;
        else if (name == "E2")
            return &rE2;
        else if (name == "E3")
            return &rE3;
        else if (name == "E4")
            return &rE4;
        else if (name == "FLAG")
            return &rFlag;
        else if (name == "VAL")
            return &rVal;
        else if (name == "RET")
            return &rRet;
        else if (name == "LINE")
            return &rLine;
        else {
            compileError(fileline, "Invaild register name \"" + name + '\"');
            return nullptr;
        }
    }

    int* getMemory(int fileline, int id) {
        if (id >= memsize || id < 0) {
            compileError(fileline, "Memory access statically out of range");
            return 0;
        }
        else return mem + id;
    }

    void run() {
        rR1 = rR2 = rR3 = rR4 = rE1 = rE2 = rE3 = rE4 = rFlag = rVal = rRet = rLine = 0;
        memset(mem, 0, sizeof(mem));
        while (!sAddr.empty())
            sAddr.pop();

        clockCounter = 0;
        nextptr = 0;
        running = true;
        while (running) {
            if (nextptr >= program.size() || nextptr < 0)
                runtimeError("Program Pointer Invaild");
            else
                handlers[program[nextptr].first](program[nextptr].second);
            clockCounter++;
        }
    }

    int getClock() { return clockCounter; }

    bool valid;
private:

    friend class Compiler;

    int rR1, rR2, rR3, rR4;
    int rE1, rE2, rE3, rE4;
    int rFlag, rVal, rRet, rLine;
    static constexpr int stackSize = 512 * 1024;
    stack<int> /*sVal,*/ sAddr;

    vector<pair<Command, vector<DataSource>>> program;
    int nextptr;
    static constexpr int memsize = 16 * 1024 * 1024;
    int mem[memsize];

    int clockCounter;
    bool running;

    function<void(vector<DataSource>&)> handlers[CommandCount];
    map<int, int> commandLines;
    map<string, Command> commands;
    string names[CommandCount];
};


class Tokenizer {
public:
    enum Type {
        Unknown,
        Identifier,
        Number,
        Symbol
    };

    struct Token {
        Type type;
        string word;
        int line;
    };

    static vector<Token> parse(const string& str) {
        vector<Token> tokens;
        Token buffer{ Unknown, "", 1 };
        int commentLayers = 0;
        int curline = 1;
        for (char c : str) {
            if (c == '[')
                commentLayers++;
            else if (c == ']') {
                if (commentLayers > 0)
                    commentLayers--;
            }
            else if (commentLayers <= 0) {
                if (!(isblank(c) || iscntrl(c) || c == ',')) {
                    if ((buffer.type == Number && !isdigit(c)) ||
                        (buffer.type == Identifier && (!isalnum(c) && c != '_')) ||
                        (buffer.type == Symbol && (isalnum(c) || c == '_' || c == '-'))) {
                        buffer.line = curline;
                        tokens.push_back(buffer);
                        buffer = Token{ Unknown, "" };
                    }
                    if (buffer.type == Unknown) {
                        // Check new object type
                        if (isalpha(c) || c == '_')
                            buffer.type = Identifier;
                        else if (isdigit(c) || c == '-')
                            buffer.type = Number;
                        else
                            buffer.type = Symbol;
                    }
                    buffer.word.push_back(c);
                }
                else {
                    if (buffer.type != Unknown) {
                        buffer.line = curline;
                        tokens.push_back(buffer);
                        buffer = Token{ Unknown, "" };
                    }
                }
            }
            if (c == '\n')
                curline++;
        }
        if (buffer.type != Unknown) {
            buffer.line = curline;
            tokens.push_back(buffer);
            buffer = Token{ Unknown, "" };
        }
        return tokens;
    }

    void parseTotal(string total) {
        tokens = parse(total);
        nextid = 0;
    }

    void parse(istream& in) {
        int c;
        string str;
        while (c = in.get()) {
            if (in.eof())
                break;
            str.push_back(c);
        }
        parseTotal(str);
    }

    Token next() {
        if (nextid >= tokens.size())
            return Token{ Unknown, "" };
        else
            return tokens[nextid++];
    }

    Token offset(int offset) {
        int id = nextid - 1 + offset;
        if (id >= tokens.size() || id < 1)
            return Token{ Unknown };
        else
            return tokens[id];
    }

private:
    vector<Token> tokens;
    int nextid;
};

/*
Basic Syntax
COMMAND %Register @Address Value @%AddrAtRegister;
*/
class Compiler {
public:

    struct Command {
        int line;
        string command;
        vector<Tokenizer::Token> sources;
    };


    void compile(Tokenizer& tokens) {
        valid = false;
        bool ok = true;
        while (ok) {
            Tokenizer::Token commt;
            while (ok && (commt = tokens.next()).type != Tokenizer::Identifier)
                if (commt.type == Tokenizer::Unknown)
                    ok = false;
            string command = commt.word;
            vector<Tokenizer::Token> sources;
            Tokenizer::Token cur;
            bool pushCommand = true;
            while (ok && (cur = tokens.next()).word != ";") {
                if (cur.type == Tokenizer::Unknown)
                    ok = false;
                //if (cur.type == Tokenizer::Identifier&&tokens.offset(-1).type != Tokenizer::Symbol)
                //    compileError(cur.line, "\";\" expected before a new identifier");
                else if (cur.type == Tokenizer::Symbol&&cur.word == "$"&&touppers(command) == "FUNCTION") {
                    Tokenizer::Token func = tokens.next();
                    compileAssert(func.line, func.type == Tokenizer::Identifier, "\"function $\" not followed by a identifier as function name");
                    compileAssert(func.line, funcStartLines.find(func.word) == funcStartLines.end(), "Redefinition of function \"" + func.word + "\"");
                    funcStartLines.insert(make_pair(func.word, commt.line));

                    auto vec = Tokenizer::parse("#LINE %LINE");
                    for (auto& i : vec) { i.line = commt.line; }
                    commands.push_back(Command{ commt.line, "SET", vec });
                    pushCommand = false;
                }
                sources.push_back(cur);
            }
            if (compileErrorLevel)
                break;
            if (ok&&pushCommand)
                commands.push_back(Command{ commt.line, command, sources });
        }
        if (compileErrorLevel) {
            compileErrorLevel = false;
            valid = false;
        }
        else
            valid = true;
    }

    void generateCode(AssemblyProgram& prog) {
        if (!valid)
            return;
        prog.initalaize();
        prog.valid = false;

        bool ok = true;

        for (auto i = commands.begin(); ok&&i != commands.end(); i++) {
            string& command = i->command;
            vector<AssemblyProgram::DataSource> sources;
            bool pushCommand = true;

            auto j = i->sources.begin();
            auto nextToken = [&]()->Tokenizer::Token {
                j++;
                if (j == i->sources.end())
                    return Tokenizer::Token{ Tokenizer::Unknown };
                else
                    return *j;
            };
            for (; ok&&j != i->sources.end(); nextToken()) {
                auto& cur = *j;
                if (cur.type == Tokenizer::Number)
                    sources.push_back(AssemblyProgram::DataSource{ nullptr, atoi(cur.word.c_str()), nullptr, nullptr, AssemblyProgram::Constant });
                else if (cur.type == Tokenizer::Symbol) {
                    if (cur.word == "%") {
                        Tokenizer::Token reg = nextToken();
                        compileAssert(reg.line, reg.type == Tokenizer::Identifier, "% not followed by identifier");
                        sources.push_back(AssemblyProgram::DataSource{ prog.getRegister(reg.line, reg.word), 0, nullptr, nullptr, AssemblyProgram::Pointer });
                    }
                    else if (cur.word == "@") {
                        Tokenizer::Token val = nextToken();
                        compileAssert(val.line, val.type == Tokenizer::Number, "@ not followed by a number");
                        sources.push_back(AssemblyProgram::DataSource{ prog.getMemory(val.line, atoi(val.word.c_str())), 0, nullptr, nullptr, AssemblyProgram::Pointer });
                    }
                    else if (cur.word == "@%") {
                        Tokenizer::Token reg = nextToken();
                        compileAssert(reg.line, reg.type == Tokenizer::Identifier, "@% not followed by identifier");
                        sources.push_back(AssemblyProgram::DataSource{ nullptr, 0, prog.getRegister(reg.line, reg.word), &prog, AssemblyProgram::Memory });
                    }
                    else if (cur.word == "#") {
                        Tokenizer::Token def = nextToken();
                        compileAssert(def.line, def.type == Tokenizer::Identifier, "# not followed by identifier");
                        toupper(def.word);
                        if (def.word == "LINE")
                            sources.push_back(AssemblyProgram::DataSource{ nullptr, def.line, nullptr, nullptr, AssemblyProgram::Constant });
                        else
                            compileError(def.line, "Compile-time constant identifier \"" + def.word + "\" undefined");
                    }
                    else if (cur.word == "$") {
                        if (command == "callfunc") {
                            Tokenizer::Token func = nextToken();
                            compileAssert(func.line, func.type == Tokenizer::Identifier, "\"callfunc $\" not followed by a identifier as function name");
                            auto it = funcStartLines.find(func.word);
                            if (it == funcStartLines.end())
                                compileError(func.line, "Function \"" + func.word + "\" undefined");
                            else {
                                prog.pushCommand(i->line, "CALL", {
                                    AssemblyProgram::DataSource{ nullptr, it->second, nullptr, nullptr, AssemblyProgram::Constant }
                                                 });
                            }
                            pushCommand = false;
                        }
                        else
                            compileError(cur.line, "$ not preceeded by keyword \"function\" or \"callfunc\"");

                    }
                }
                if (compileErrorLevel)
                    ok = false;
            }
            if (ok&&pushCommand)
                prog.pushCommand(i->line, i->command, sources);
        }

        if (compileErrorLevel) {
            compileErrorLevel = false;
            prog.valid = false;
        }
        else
            prog.valid = true;
    }

private:

    vector<Command> commands;
    map<string, int> funcStartLines;
    bool valid;


};


AssemblyProgram prog;
Tokenizer tokens;
Compiler compiler;


int main(int argc, char* argv[]) {

    int n;
    cin >> n;

    string str;
    string total;
    while (n > 0 && getline(cin, str)) {
        if (str == "")
            continue;
        n--;
        total += str + '\n';
    }

    tokens.parseTotal(total);
    compiler.compile(tokens);
    compiler.generateCode(prog);
    prog.run();

    return 0;
}
```

话又说回来，要是像未来程序改那样的题真的出现在了省选里，又有多少人会做出来呢……


---

## 作者：tiger2005 (赞：16)

### Mixture(224 lines, 10.00kb code, lambda function)

代码花了2小时编写，调试总共改了一个数组大小。~~大模拟写久了写什么都顺到不行~~

### 使用知识

`lambda`函数（匿名函数），不用取名就能用的函数，直接放在代码里面会简洁很多（E.g. `std::sort`函数中的比较函数）

`functional`头文件提供了函数储存类:`std::function<[ReturnType](argc)>`，可以直接将 lambda 函数储存。

一定的代码拆解能力。

### 做法

将操作与`lambda`函数连接。读取数据字符串并用空格分离，同时找到分号将语句分开。按照题目要求模拟。

是的。就是这么简单 qwq 但众所周知大模拟细节超多，所以……

### 提示

数据挺水的。一行一个语句（该代码利用了这个特性）。好像没有注释。时限宽松的很。

变量那一块着重讲一下。

常量 = 数字（自然数，不判负号能AC）

@固定位置的内存 -> `@0`为0号内存，`@1`为1号内存，内存说白了就是数组

%寄存器名称 -> 那12个寄存器啊

@%在寄存器值位置的函数 -> 寄存器里面那个值取出来之后去数组里看看这个编号下的值是什么

`#`编译时常量 -> 就`#Line`，和`%Line`一样

### 关于代码

个人编程时习惯了使用具体含义表示变量，增加了代码长但读的非常顺。同时请不要在意`Statement`类的`argc`参数。另外，读入分割`Token`的部分非常简陋，因为我在限时(2h)内无法想到清晰的分割代码思路。

~~打算回头有时间限时把未来程序改切了~~

### Code

`{user:"tiger2005", lang:"C++11", length:"10.00kb", line:"224", timeUsed:{max:"159ms",min:"111ms",sum:"1.43s"}, memoryUsed:"5.86MB", id:"33545912"}`

代码直接挂着很丑，放个剪贴板吧。

[Code](https://www.luogu.com.cn/paste/5utdjgt1)

---

## 作者：VCode (赞：11)

我们先看一下出题人在比赛过程中给我们的解答：

1. 每行不会超过2000字符

2. 每行只有一条语句

3. @常量数 表示在这个常量位置的内存

4. @%寄存器 表示在这个寄存器的值的位置的内存

5. 代码里没有#LINE，只有函数调用（说白了LINE只是用来解释函数调用机制的）

6. 关键字全都是小写（不区分大小写）

7. 函数名区分大小写

8. 一行只有一条指令（虽然出题人的标程可以处理多条
 
9. 内存从0开始

```
Q:

算数操作结果将会放入第<操作数加一>个参数，如果不存在则会放入`%Val`寄存器。

“操作数加一” 是什么东西

是指`add %r1 %r2;`会计算`%r1 + %r2`放入`%Val`但是`add %r1 %r2 %r3;`会计算`%r1 + %r2`放入`%r3`吗



说的很对呢
考虑一下

add %r1 %r2;
pint;

会计算%r1加上%r2，放到%val里然后输出

另：%val和%flag的名字也不区分大小写（数据里都是小写）
```




```
Q:

T5 内存具体是指什么。如果输出内存我要输出什么？

A:

输出命令有两种

wint是输出这个数（cout<<%r1;）

wch是输出这个字符（putchar(%r1);）（保证数值在32~126之间）

内存本质是一个极大的数组，我们定义这样的一个数组存的是32位有符号int

（电脑的内存在没有被操作系统分页给你用的时候就是这样，只不过存的是字节byte/octet）
}

```


然后，我们再来谴责一下出题人：

## 数据有锅！！！

向出题人要了数据，发现所有的`ret <0>;`操作的`<0>`中的`%`都缺失了，然后标程就把它当作`ret;`处理了。

在这里抱怨一下：一个团队的可能知道我从比赛开始就在肝这道题，到第二天凌晨12:30由于要准备第二天的活动所以必须睡觉了。起床后继续肝到晚上六点半（中途拿到了出题人发给我的数据，但是一直把数据当正确的用），然后发现数据出锅了。不然我可能就一遍A了QwQ。

说了这么多，我们来讲这个题：

这是个考察设计模式（？）的题，所以抄题解被发现的概率极大

12个寄存器就是12个变量

内存就是一个大数组

程序存在char[][]里

记录当前行号

有函数调用就压栈（按照文档所说便可）

将程序读入的时候去掉多余的空格

然后删掉注释

> 关于注释的嵌套`[[]abb]`如何处理：没有这样的数据

具体参考代码：

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<map>

typedef unsigned long long hash_t;
const hash_t HASH_MODE = 131;

class StringHasher {
 private:
  bool inHash(char ch) {
    if(ch == ';') return false;
    if(ch == ' ') return false;
    if(ch == '\0') return false;
    if(ch == '\r') return false;
    if(ch == '\n') return false;
    return true;
  }
 public:
  hash_t getHash(char str[]) {
    hash_t res = 0;
    for(char *ptr = str; inHash(*ptr); ++ptr) {
      res = res * HASH_MODE + *ptr;
    }
    return res;
  }
};

class Calculate {
 private:
  int *Val;
 public:
  Calculate(int *Val) : Val(Val) {  }
  void inv(int *a, int *b) {
    *b = -*a;
  }
  void inv(int *a) {
    *Val = -*a;
  }
  void add(int *a, int *b, int *c) {
    *c = (*a + *b);
  }
  void add(int *a, int *b) {
    *Val = (*a + *b);
  }
  ...
};

class Logic {
  ...
};

class IO {
   ...
};

class Control {//控制命令比较繁琐，重点展现一下
 private:
  int *Flag;
  int *Line;
  int *Ret;
  int *sAddr;
  int *top;
  int *row;
  int *column;
 public:
  Control(int *Flag, int *Line, int *Ret, int *sAddr, int *top, int *row, int *column) : 
        Flag(Flag), Line(Line), Ret(Ret), sAddr(sAddr), top(top), row(row), column(column) {  }
  void udef() {  }
  void hlt() {
    fflush(stdin);
    exit(0);
  }
  void nop() {  }
  void set(int *a, int *b) {
    *b = *a;
  }
  void jmp(int *a) {
    *row = *Line + *a;
    *column = 0;
  }  
  void jif(int *a, int *b) {
    if(*b) {
      *row = *Line + *a;
    } else {
      ++*row;
    }
    *column = 0;
  }
  void jif(int *a) { 
    if(*Flag) {
      *row = *Line + *a;
    } else {
      ++*row;
    }
    *column = 0;
  }
  void call(int *a) {
    sAddr[++(*top)] = *row + 1;
    sAddr[++(*top)] = *Line;
    *row = *a;
    *column = 0;
  }
  void ret(int *a) {
    *Line = sAddr[(*top)--];
    *row = sAddr[(*top)--];
    *column = 0;
    *Ret = *a;
  }
  void ret() {
    *Line = sAddr[(*top)--];
    *row = sAddr[(*top)--];
    *column = 0;
  }
};

class ProgramManager {
 private:
  char program[50005][2005];
  int ram[16 * 1024 * 1024];
  int sAddr[1024 * 1024];
  int top;
  int R[4];
  int E[4];
  int Flag;
  int Val;
  int Ret;
  int Line;
  int row;
  int column;//你会发现我代码中的column始终保持0。实际上这只是我懒得删掉这个变量
  Calculate *calculate;
  Logic *logic;
  IO *io;
  Control *control;
  int maxLine;
  void noComment() {//去除注释
    int ignore = 0;
    int i = 0;
    int j = 0;
    while(i < maxLine) {
      if(program[i][j] == '\0') {
        ++i;
        j = 0;
        continue;
      }
      if(program[i][j] == '[') {
        ++ignore;
      }
      if(program[i][j] == ']') {
        program[i][j] = ' ';
        --ignore;
        if(ignore < 0) ignore = 0;
      }
      if(ignore > 0 && program[i][j] != '\0') {
        program[i][j] = ' ';
      }
      ++j;
    }
    for(i = 0; i < maxLine; ++i) {//标准化代码
      int p = 0;
      int j = 0;
      while(program[i][j] != '\0') {
        program[i][p++] = program[i][j++];
        if(program[i][j] == ' ' && program[i][p - 1] == ' ') --p;
        if(p == 1 && program[i][0] == ' ') --p;
      }
      if(p > 0 && program[i][p - 1] == ' ') {
        program[i][p - 1] = '\0';
      }
      program[i][p] = '\0';
      if(program[i][0] == '\0') {
        sprintf(program[i], "nop;");
      }
    }
  }
  void setFunction() {//将function和callfunc变成set和call
    std::map<hash_t, int> func;
    StringHasher hasher;
    hash_t goal = hasher.getHash("function");
    for(int i = 0; i < maxLine; ++i) {
      hash_t oper = hasher.getHash(program[i]);
      if(oper == goal) {
        func[hasher.getHash(&program[i][9])] = i;
        sprintf(program[i], "set %d %%line;", i);
      }
    }
    goal = hasher.getHash("callfunc");
    for(int i = 0; i < maxLine; ++i) {
      hash_t oper = hasher.getHash(program[i]);
      if(oper == goal) {
        sprintf(program[i], "call %d;", func[hasher.getHash(&program[i][9])]);
      }
    }
  }
  int toNumber(char *str) {//字符串转数字
    int ope = 1;
    if(*str == '-') {
      ope == -1;
      ++str;
    }
    int res = 0;
    while('0' <= *str && *str <= '9') {
      res = res * 10 + *str - '0';
      ++str;
    }
    return res * ope;
  }
  int *getVar(char *str, int *ori) {//得到字符串中参数的地址
    if(str[0] == '%') {
      if(str[1] == 'r') {
        if(str[2] == 'e') {
          return &Ret;
        }
        return R + str[2] - '1';
      } else if(str[1] == 'e') {
        return E + str[2] - '1';
      } else if(str[1] == 'f') {
        return &Flag;
      } else if(str[1] == 'v') {
        return &Val;
      } else if(str[1] == 'l') {
        return &Line;
      }
    } else if(str[0] == '@') {
      if(str[1] == '%') {
        if(str[1] == 'r') {
          if(str[2] == 'e') {
            return ram + Ret;
          }
          return ram + R[str[2] - '1'];
        } else if(str[1] == 'e') {
          return ram + E[str[2] - '1'];
        } else if(str[1] == 'f') {
          return ram + Flag;
        } else if(str[1] == 'v') {
          return ram + Val;
        } else if(str[1] == 'l') {
          return ram + Line;
        }
      } else {
        return ram + toNumber(str + 1);
      }
    } else {
      *ori = toNumber(str);
      return ori;
    }
  }
 public:
  ProgramManager(int maxLine) : maxLine(maxLine) {
    memset(ram, 0, sizeof(ram));
    memset(sAddr, 0, sizeof(sAddr));
    top = -1;
    memset(R, 0, sizeof(R));
    memset(E, 0, sizeof(E));
    Flag = 0;
    Val = 0;
    Ret = 0;
    Line = 0;
    calculate = new Calculate(&Val);
    logic = new Logic(&Flag);
    io = new IO(&Val);
    control = new Control(&Flag, &Line, &Ret, sAddr, &top, &row, &column);
  }
  void init() {
    for(int i = 0; i < maxLine; ++i) {//读入程序
      char ch = getchar();
      while(ch == ' ') ch = getchar();
      int p = 0;
      while(ch != '\n') {
        program[i][p++] = ch;
        ch = getchar();
      }
      program[i][p] = '\0';
    }
    noComment();
    setFunction();
  }
  void start() {
    static char oper[2005];
    while(true) {
      sscanf(&program[row][column], "%s", oper);
      switch(oper[0]) {
        case 'a': {
          //add
          //请注意以add为例的读入操作技巧
          char A[2005];
          char B[2005];
          sscanf(&program[row][column], "%*s%s%s", A, B);
          int tempa;
          int tempb;
          int *a = getVar(A, &tempa);
          int *b = getVar(B, &tempb);
          if(B[strlen(B) - 1] == ';') {
            calculate->add(a, b);
          } else {
            sscanf(&program[row][column], "%*s%*s%*s%s", A);
            int tempc;
            int *c = getVar(A, &tempc);
            calculate->add(a, b, c);
          }
          ++row;
          column = 0;
          break;
        }
        case 'b': {
          ...
        }
      }
      ...
    }
  }
};

int main() {
  int lines;
  scanf("%d\n", &lines);
  ProgramManager &manager = *new ProgramManager(lines);//我的Windows不这样写会炸掉
  manager.init();
  manager.start();
  return 0;
}


```

如果不提后5个点数据的锅的话，其实这题出题人很良心了，数据很水了，但是具体怎么水我不能告诉你们（。

如果你们真的忍不住想看完整代码可以查看我的博客：

https://vcode28629.coding.me/code/problem/luoguP4911

---

## 作者：cicuvc (赞：9)

直接模拟即可，几乎没有思维难度，但细节很多

其中指令参数可以是常数、寄存器、内存值及寄存器处内存值，考虑每条指令的参数使用指针表示。
如果参数为常数，将其存入数组并取数组该处地址；如果参数为寄存器，取寄存器变量的地址；内存固定位置则取内存数组内相应位置的地址。
比较麻烦的是间接寻址(即@%+寄存器)，此时对参数打上标记，每次执行到该指令时根据此时对应寄存器的值更新需访问的内存地址即可

处理函数时，当遇到一个新函数，为其分配编号并存入trie，遇到function时顺便记下该编号下函数所在的行。
callfunc转为call+编号,function转为 set+编号+%line
编译完成后扫一遍生成的指令，遇到编号的将其转为常量行号即可

详见代码(可能是通过记录中最短的，才400行不到)

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#define intptr long long

inline char *strlwr(char *s) {
	char *sp=s;
	while(*s!='\0') {
		if(*s>='A'&&*s<='Z')*s=*s-'A'+'a';
		s++;
	}
	return sp;
} //大写转小写 c++98中自带但luogu上好像没有 

int constant_pool[4194306];//常量池 
int cp;//常量池值个数 

typedef enum {
    none,hlt,set,jmp,jif,call,ret,inv,add,sub,mul,idiv,mod,lsft,rsft,band,bor,bxor,gr,ls,ge,le,eq,land,lor,wint,rint,wc,rc,nop
} oper;//指令集 

typedef struct {
	oper op;
	int *opr1;
	bool pre1;
	int *opr2;
	bool pre2;
	int *opr3;
	bool pre3;
} inst;//指令 

int ptr_memory[17*1024*1024]; //内存 
inst compiled_program[1000000];
int inst_count;

namespace vm {
	//%line,%val,%ret,%flag,%r1-%r4,%e1-%e4
	int regs[12];
	int callst[4194306];//调用栈，存ret后下一条指令 
	int linest[4194306];//调用栈，存ret后%line值 

	int pc,sp;//pc是指令计数器，sp是调用栈栈顶指针 
	bool halted; 
	
	//接下来是各种指令的实现 
	typedef void (*pfn_impl)(inst &ptr_inst);
	void imp_nop(inst &ptr_inst) {}
	void imp_hlt(inst &ptr_inst) {
		halted=1;
	}
	void imp_set(inst &ptr_inst) {
		*ptr_inst.opr2=*ptr_inst.opr1;
	}
	void imp_jmp(inst &ptr_inst) {
		pc=regs[0]+*ptr_inst.opr1;
	}
	void imp_jif(inst &ptr_inst) {
		if(*ptr_inst.opr2)pc=regs[0]+*ptr_inst.opr1;
	}
	void imp_call(inst &ptr_inst) {
		sp++;
		callst[sp]=pc;
		linest[sp]=regs[0];
		pc=*ptr_inst.opr1;
	}
	void imp_ret(inst &ptr_inst) {
		pc=callst[sp];
		regs[0]=linest[sp];
		sp--;
		regs[2]=*ptr_inst.opr1;
	}
	void imp_inv(inst &ptr_inst) {
		*ptr_inst.opr3=-(*ptr_inst.opr1);
	}
	void imp_add(inst &ptr_inst) {
		*ptr_inst.opr3=*ptr_inst.opr1+(*ptr_inst.opr2);
	}
	void imp_sub(inst &ptr_inst) {
		*ptr_inst.opr3=*ptr_inst.opr1-(*ptr_inst.opr2);
	}
	void imp_mul(inst &ptr_inst) {
		*ptr_inst.opr3=*ptr_inst.opr1*(*ptr_inst.opr2);
	}
	void imp_idiv(inst &ptr_inst) {
		*ptr_inst.opr3=*ptr_inst.opr1/(*ptr_inst.opr2);
	}
	void imp_mod(inst &ptr_inst) {
		*ptr_inst.opr3=*ptr_inst.opr1%(*ptr_inst.opr2);
	}
	void imp_lsft(inst &ptr_inst) {
		*ptr_inst.opr3=*ptr_inst.opr1<<(*ptr_inst.opr2);
	}
	void imp_rsft(inst &ptr_inst) {
		*ptr_inst.opr3=*ptr_inst.opr1>>(*ptr_inst.opr2);
	}
	void imp_band(inst &ptr_inst) {
		*ptr_inst.opr3=*ptr_inst.opr1&(*ptr_inst.opr2);
	}
	void imp_bor(inst &ptr_inst) {
		*ptr_inst.opr3=*ptr_inst.opr1|(*ptr_inst.opr2);
	}
	void imp_bxor(inst &ptr_inst) {
		*ptr_inst.opr3=*ptr_inst.opr1^(*ptr_inst.opr2);
	}
	void imp_gr(inst &ptr_inst) {
		*ptr_inst.opr3=(*ptr_inst.opr1)>(*ptr_inst.opr2);
	}
	void imp_ls(inst &ptr_inst) {
		*ptr_inst.opr3=(*ptr_inst.opr1)<(*ptr_inst.opr2);
	}
	void imp_ge(inst &ptr_inst) {
		*ptr_inst.opr3=(*ptr_inst.opr1)>=(*ptr_inst.opr2);
	}
	void imp_le(inst &ptr_inst) {
		*ptr_inst.opr3=(*ptr_inst.opr1)<=(*ptr_inst.opr2);
	}
	void imp_eq(inst &ptr_inst) {
		*ptr_inst.opr3=(*ptr_inst.opr1)==(*ptr_inst.opr2);
	}
	void imp_land(inst &ptr_inst) {
		*ptr_inst.opr3=(*ptr_inst.opr1)&&(*ptr_inst.opr2);
	}
	void imp_lor(inst &ptr_inst) {
		*ptr_inst.opr3=(*ptr_inst.opr1)||(*ptr_inst.opr2);
	}
	void imp_rint(inst &ptr_inst) {
		scanf("%d",ptr_inst.opr1);
	}
	void imp_wint(inst &ptr_inst) {
		printf("%d",*ptr_inst.opr1);
	}
	void imp_rc(inst &ptr_inst) {
		*ptr_inst.opr1=getchar();
	}
	void imp_wc(inst &ptr_inst) {
		printf("%c",*ptr_inst.opr1);
	}
	pfn_impl calling_vector[]= {&imp_nop,
	                            &imp_hlt,&imp_set,&imp_jmp,&imp_jif,&imp_call,&imp_ret,
	                            &imp_inv,&imp_add,&imp_sub,&imp_mul,&imp_idiv,&imp_mod,&imp_lsft,&imp_rsft,&imp_band,&imp_bor,&imp_bxor,
	                            &imp_gr,&imp_ls,&imp_ge,&imp_le,&imp_eq,&imp_land,&imp_lor,
	                            &imp_wint,&imp_rint,&imp_wc,&imp_rc,&imp_nop,
	                           };
	void vm_execute(inst *ptr_inst) {
		pc=1;
		while(!halted) {//主循环 
			inst curr=compiled_program[pc];
			pc++;
			//对二级寻址的预处理 
			if(curr.pre1)curr.opr1=(int*)(*((intptr*)curr.opr1)+ptr_memory);
			if(curr.pre2)curr.opr2=(int*)(*((intptr*)curr.opr2)+ptr_memory);
			if(curr.pre3)curr.opr3=(int*)(*((intptr*)curr.opr3)+ptr_memory);
			calling_vector[curr.op](curr);//通过查表跳转到指令具体实现 
		}
	}

	int *get_reg_ptr(const char *p_str) {
		if(p_str[2]>='0'&&p_str[2]<='9') {//%r1-%r4,%e1-%e4 
			return regs+(p_str[1]=='e'?4:0)+(p_str[2]-'0')+3;
		} else { //%val,%ret,%flag,%line
			return regs+(p_str[1]=='v'?1:(p_str[1]=='r'?2:(p_str[1]=='f'?3:0)));
		}
	}
}

struct trie {//trie树 
	int toval(char c) {
		if(c>='a'&&c<='z')return c-'a';
		if(c>='A'&&c<='Z')return c-'A'+26;
		return c-'0'+52;
	}
	int ch[9999][63];
	int nc;
	void insert(const char *p,int val) {
		int root=0;
		while(*p!='\0') {
			int nxt=toval(*p);
			if(!ch[root][nxt]) {
				ch[root][nxt]=++nc;
			}
			root=ch[root][nxt];
			p++;
		}
		ch[root][62]=val;
	}
	int match(char *s) {
		int root=0;
		while((*s>='a'&&*s<='z')||(*s>='A'&&*s<='Z')||(*s>='0'&&*s<='9')) {
			int nxt=toval(*s);
			root=ch[root][nxt];
			s++;
		}
		return ch[root][62];
	}
};

namespace compiler {
	int fix_map[100000];//存放函数起始点行号 
	trie fix_list;//记录使用过的函数 
	int fix_count;
	char operation[10],arg1[30],arg2[12],arg3[12];//指令及三个参数 
	trie keywd;//匹配指令的trie 

	int *alloc_constant(int val) {//向常量池中添加常量 
		cp++;
		constant_pool[cp]=val;
		return &constant_pool[cp];
	}
	void process_arg(char *p_buf,int *&oper,bool &pre,int ln) {//处理指令的参数 
		if(p_buf[0]=='#') {//#line
			oper=alloc_constant(ln);
			return;
		}
		if((p_buf[0]>='0'&&p_buf[0]<='9')||p_buf[0]=='-') {//数字 
			int val;
			sscanf(p_buf,"%d",&val);
			oper=alloc_constant(val);
			return;
		}
		if(p_buf[0]=='%') {//%+寄存器 
			oper=vm::get_reg_ptr(p_buf);
			return;
		} else {
			if(p_buf[0]=='@') {
				if(p_buf[1]=='%') {//@%+寄存器 
					p_buf+=1;
					oper=vm::get_reg_ptr(p_buf);
					pre=1;//标记二级寻址需特别处理 
					return;
				} else { //@固定内存地址 
					int val;
					p_buf+=1;
					sscanf(p_buf,"%d",&val);
					oper=ptr_memory+val;
					return;
				}
			}
		}
	}
	void init() {//添加指令，不解释 
		keywd.insert("hlt",hlt);
		keywd.insert("set",set);
		keywd.insert("jmp",jmp);
		keywd.insert("jif",jif);
		keywd.insert("call",call);
		keywd.insert("ret",ret);
		keywd.insert("inv",inv);
		keywd.insert("add",add);
		keywd.insert("sub",sub);
		keywd.insert("mult",mul);
		keywd.insert("idiv",idiv);
		keywd.insert("mod",mod);
		keywd.insert("lsft",lsft);
		keywd.insert("rsft",rsft);
		keywd.insert("band",band);
		keywd.insert("bor",bor);
		keywd.insert("bxor",bxor);
		keywd.insert("lgr",gr);
		keywd.insert("lls",ls);
		keywd.insert("lge",ge);
		keywd.insert("lle",le);
		keywd.insert("leql",eq);
		keywd.insert("land",land);
		keywd.insert("lor",lor);
		keywd.insert("wint",wint);
		keywd.insert("rint",rint);
		keywd.insert("wch",wc);
		keywd.insert("rch",rc);
		keywd.insert("callfunc",-1);
		keywd.insert("function",-2);
		keywd.insert("nop",nop);
		keywd.insert("udef",nop);
	}
	void process_statement(int ln) {//处理语句 
		int id=keywd.match(strlwr(operation));
		if(id==0) {
			return;
		}
		if(id<0) {//callfunc 或 function 
			int exist=fix_list.match(arg1+1);
			if(!exist) {//第一次出现时分配函数编号 
				fix_list.insert(arg1+1,++fix_count);
				exist=fix_count;
			}
			if(id==-1) {//填入编号 
				compiled_program[++inst_count]=(inst) {
					call,(int*)(long long)exist 
				};
			} else {
				compiled_program[++inst_count]=(inst) {
					set,(int*)(long long)exist,0,vm::get_reg_ptr("%line")
				};
				fix_map[exist]=ln;
			}
		} else {
			compiled_program[++inst_count].op=(oper)id;
			if(id==inv) {
				strcpy(arg3,arg2);//inv 最多两个参数 将其统一为第三个参数返回结果 
			}
			//补充可省略的参数 
			if(id>=inv&&id<=bxor) {
				if(arg3[0]=='\0')strcpy(arg3,"%val");
			}
			if(id>=gr&&id<=lor) {
				if(arg3[0]=='\0')strcpy(arg3,"%flag");
			}
			if(id>=wint&&id<=rc) {
				if(arg1[0]=='\0')strcpy(arg1,"%val");
			}
			if(id==jif) {
				if(arg2[0]=='\0')strcpy(arg2,"%flag");
			}
			if(id==ret) {
				if(arg1[0]=='\0')strcpy(arg1,"%ret");
			}
			//将参数填入指令 
			if(arg1[0]!='\0')process_arg(strlwr(arg1),compiled_program[inst_count].opr1,compiled_program[inst_count].pre1,ln);
			if(arg2[0]!='\0')process_arg(strlwr(arg2),compiled_program[inst_count].opr2,compiled_program[inst_count].pre2,ln);
			if(arg3[0]!='\0')process_arg(strlwr(arg3),compiled_program[inst_count].opr3,compiled_program[inst_count].pre3,ln);
		}
	}
	void reloc() {//函数重定位 
		for(int i=1; i<=inst_count; i++) {
			if((long long)compiled_program[i].opr1<=fix_count) {//正常值为指针，若值过小则为函数编号 
				int fix_id=(long long)compiled_program[i].opr1;
				int *ln=alloc_constant(fix_map[fix_id]);//查表并替换 
				compiled_program[i].opr1=ln;
			}
		}
	}
	char line_buf[1000];
	int line_count;
	void compile() {
		int n;
		scanf("%d",&n);
		for(int i=1; i<=n; i++) {
			memset(line_buf,0,sizeof(line_buf));
			char c;
			line_count=0;
			int flag=0;
			while((c=getchar())=='\n');
			do {
				if(c=='[')flag++;
				if(c==']'&&flag)flag--;
				if(!flag&&c!=']')line_buf[++line_count]=c;
			} while((c=getchar())!='\n'&&(!feof(stdin)));//读入行并忽略注释 
			char *p_tokens=strtok(line_buf+1,";");//按分号分隔 
			while(*p_tokens) {
				while(*p_tokens==' ')p_tokens++;//去前导空格 
				
				memset(operation,0,sizeof(operation));
				memset(arg1,0,sizeof(arg1));
				memset(arg2,0,sizeof(arg2));
				memset(arg3,0,sizeof(arg3));
				sscanf(p_tokens,"%s%s%s%s",operation,arg1,arg2,arg3); 
				process_statement(i);
				
				while(*p_tokens)p_tokens++;//跳至下一条语句 
				p_tokens++;
			}
		}
	}
}

int main(int argc,char **argv) {
	compiler::init();
	compiler::compile();
	compiler::reloc();
	vm::vm_execute(&compiled_program[1]);
	return 0;
}
```

---

## 作者：normalpcer (赞：3)

## 题意简述
要求实现一个汇编语言的解释器。

具体地讲，源代码分为由分号分隔的若干个语句。特别地，本题输入数据保证一行仅有一条语句，且不存在空行（但是题面中并没有说明这一点）。

这里的注释不同于 C++ 的多行注释，注释中的两个中括号之间可以互相匹配，例如：
```
[This [is] a comment.]
```
如上语句依旧是一条完整的注释。

我们先来介绍数据的存储。本题中，数据有两个存储位置——寄存器和内存。寄存器为固定的 12 个（详见题面附件），内存的大小为 64 MiB。二者均存储 32 位整数，初始值为 0。

`LINE` 寄存器的值放置当前函数开始的行号；另外，我们需要维护一个函数调用栈 `sAddr`，存储两个值，第一个表示当前函数返回之后跳转到的行号，第二个表示调用当前函数之前 `LINE` 寄存器的值。

每条语句分为“标识符”（label）和“参数”（argument）两个部分，其中参数可能为零个、一个或多个。同一个语句可以接收不同数量的参数（或者说可以有默认参数）。对于绝大多数的语句，参数一定是以下的几个之一：
1. 一个整数常量
2. 一个寄存器地址，例如 `%R1` 表示寄存器 `R1`。
3. 一个固定内存地址，例如 `@10` 表示取内存上地址为 10 的整数。这里的 10 表示偏移量为 10，而非字节数。
4. 一个寄存器中的内存地址，例如 `%@R1` 表示从寄存器 `R1` 上获取一个整数，把这个整数作为内存地址。
5. 编译期常量，本题中仅包括 #LINE，表示当前行号（从 $1$ 开始）。

语句分为控制操作、数学运算、逻辑判断和输入输出四大类。其中控制操作包括：（用尖括号加数字表示参数）
+ `UDEF`：未定义。不会出现在输入数据中。
+ `HLT`：停机。
+ `NOP`：空指令，没有实际效果。
+ `SET`：赋值，把 <0> 的值赋给 <1>。
+ `JMP`：跳转到当前函数的 <0> 行（即 <0> 加上寄存器 `LINE` 的值）。
+ `JIF`：如果 <1> 成立，跳转到当前函数的第 <0> 行。<1> 具有默认值 `FLAG`。
+ `CALL`：调用，把绝对行号 <0> 视为一个函数的开头，向调用栈压入当前信息并跳转。
+ `RET`：返回值，如果存在参数 <0>，把寄存器 `RET` 设为对应值；此外，从调用栈弹出上次调用的相关信息，返回先前位置。

特别地，`CALLFUNC` 和 `FUNCTION` 的参数是一个 `$` 开头的函数名。标识符的大小写不敏感，但是函数名大小写敏感。

## 分析
我们将会把这个程序分为解析和运行两个步骤。

首先，我们可以借助面向对象编程的思想，把题目中经常使用的事物抽象、封装成对象。

我们先考虑一个数据（这里必然为整数）可能存在的位置，封装成 `StorageReference` 类，提供访问和修改的方法。

```cpp
// In namespace Storage
enum ReferenceType { Null/*空引用*/, Constant/*常量*/, InRegister/*寄存器*/, InMemory/*内存*/ };
/**
 * 数据存储的位置
 */
struct StorageReference {
    ReferenceType type;             // 引用类型
    int valueConstant = 0;          // 存储的常量值
    int *valuePointer = nullptr;    // 寄存器数据的指针；如果是常量则为空指针
    int MemoryIndex = 0;            // 内存中的地址
    // 特别地，对于常量内存地址，存储在 MemoryIndex 中；
    // 对于寄存器中的内存地址，寄存器指针在 valuePointer 中。

    int operator* () {  // 重载运算符 解引用
        return (int)*this;
    }

    operator int() const {
        if (type == Constant)  return valueConstant;
        if (type == InRegister)  return *valuePointer;
        if (type == Null) {
            program.raise({NullReferenceError, "Accessing a NULL reference."});
        }
        if (valuePointer) {  // 寄存器地址
            return (int)(StorageReference){InMemory, 0, nullptr, *valuePointer};
        } else {
            if (MemoryIndex < 0 or MemoryIndex >= _Mem) {  // 访问越界
                program.raise({IndexError, std::format("Illegal memory access to {}.", MemoryIndex)});
                return valueConstant;
            }
            return memory[MemoryIndex];
        }
    }

    int operator = (int val) {
        if (type == Constant) {
            return val;  // 修改常量无影响
        }
        if (type == Null) {
            program.raise({NullReferenceError, "Accessing a NULL reference."});
        }
        if (type == InRegister) {
            return (*valuePointer = val);
        }
        if (valuePointer) {  // 寄存器地址
            return ((StorageReference){InMemory, 0, nullptr, *valuePointer} = val);
        } else {
            if (MemoryIndex < 0 or MemoryIndex >= _Mem) {  // 访问越界
                program.raise({IndexError, std::format("Illegal memory access to {}.", MemoryIndex)});
                return -1;
            }
            return (memory[MemoryIndex] = val);
        }
    }

    operator bool () const { return (type != Null); }
    // 等价于 Javascript 的 ?? 运算符
    StorageReference operator || (StorageReference const& other) const {
        return *this? *this: other;
    }
};
```

我额外实现了转换为 `bool` 类型的方法，用于检查是否为空；以及 `||` 运算符，表示如果左侧不为空则使用左侧，否则使用右侧（可以方便地实现默认参数）。

那么，我们就可以把除了函数名以外的所有参数统一起来了。对于函数名，我们可以在解析时设一个“函数 ID”，把这个 ID 作为常量传递进来即可。

此外，为了组织不同数量的参数，我继承了 `std::vector<StorageReference>` 作为参数列表。这样参数数量就不需要区分了。

代码如下：
```cpp
/**
 * 组织参数列表，是一个元素为 StorageReference 的可变容器，继承自 vector。
 * 当使用中括号运算符取值时，会直接返回这个参数的值，使用 at(index) 则会正常返回引用。
 */
struct Arguments: public vector<StorageReference> {
    Arguments() = default;
    Arguments(std::initializer_list<StorageReference> lis): vector<StorageReference>(lis) {}

    template <size_t N>
    auto take() const {
        return Utilities::Extractions::extract<N>(*this);
    }

    template <class index_t> StorageReference operator[] (index_t N) const {
        return (index_t)size() > N? at(N): Storage::nullRef();
    }
};
```

`take<N>()` 方法可以提取出一个类似 `std::tuple` 的长度为 N 的元组，以支持结构化绑定。这需要在 `std` 命名空间中定义一些接口，如下：
```cpp
/**
 * (in namespace Utilities)
 * “提取”一个容器中的前 SZ 项，其中 SZ 为编译期常量。
 * 提取后的项可以用于结构化绑定。
 * ! 修改提取后的项不会影响到原元素。
 */
namespace Extractions {
    template <class T, size_t SZ>  requires (SZ>0)
    struct _Extraction {  T container;  };

    template <size_t N, class Ext>
    auto get(const Ext& c) {
        return c.container[N];
    }

    /**
     * 提取容器 con 的前 SZ 项，其中 SZ 为模板参数。
     * 用法示例：
     * std::vector<int> vec = {0, 1, 2, 3, 4};
     * auto [a, b, c] = extract<3>(vec);
     * -> a = 0, b = 1, c = 2
     * 在这样操作后，对这些变量的修改**不会**同步到原容器，反之亦然
     */
    template <size_t SZ, class Container_T>
    auto extract(Container_T& con) {
        assert(con.size());
        return _Extraction<Container_T, SZ> {con};
    }
}
namespace std {
    // 定义接口，用于实现 Utilities::Extractions::_Extraction 的结构化绑定。
    template <class T, size_t SZ>
    struct tuple_size<Utilities::Extractions::_Extraction<T, SZ>> { const static int value = SZ; };
    template <size_t N, class T, size_t SZ>
    struct tuple_element<N, Utilities::Extractions::_Extraction<T, SZ>> {
        using type = decltype(std::move(std::declval<T>()[0]));
    };
}
```

于是，我们的一个功能就可以写成一个这样的函数：
```cpp
void logic(Arguments args) {
    auto [x, y] = args.take<2>();
    auto ans = (x&y)^(x^y|~x&y);
    Storage::registerRef(Storage::R1) = ans;
}
```

接下来，我们继续填充运行的过程。“内存”和“寄存器”都可以使用数组来模拟，然后对于每种命令都创建一个函数进行操作即可。可以用一个 `std::unordered_map<std::string, std::function<void(Arguments)>>` 来维护名称到函数的映射。

对于运行的进度，我们可以维护一个指针（代码中使用的是迭代器），每次向下移动一步；跳转之后可能需要特判一下，避免遗漏步骤。

我创建了一个“程序”（`Program`）类，用来维护操作列表、运行状态和进行异常处理。

```cpp
namespace Program {

    enum ProgramStatus { OK, Jumping, Stopped, CompileError, RuntimeError };

    enum ExceptionType {  // 异常类型
        NoError,                // 保留
        IndexError,             // 越界访问
        ZeroDivisionError,      // 除以零
        NullReferenceError,     // 空引用
        FunctionCallingError,   // 函数调用相关
        EncodingError,          // 字符编码
        StackOverflowError,     // 系统栈溢出
    };

    struct Exception {  // 运行时异常
        ExceptionType type;     // 异常类型
        string description;     // 描述
        string information;     // 详细信息

        Exception(ExceptionType type, string desc, string info=""): 
            type(type), description(desc), information(info) {}
    };


    struct Operation {
        int line;
        string label;
        Processor::Arguments *args;

        void execute();
    };

    struct Parsed {
        vector<Operation> operations;
        std::unordered_map<string, int> functionToId;
        std::unordered_map<int, string> IdToFunction;
        std::unordered_map<int, int> FunctionIdToDefinitionLineIndex;
        std::unordered_map<int, int> lineIndexMapping;
    };

    
    struct Program {
        ProgramStatus status;   // 运行状态
        vector<Operation>::iterator step;  // 当前的位置

        Parsed code;
        
        void raise(const Exception& exception) {  // 抛出一个运行时异常
            status = RuntimeError;  // 停止运行，输出异常信息
            io << std::format("Runtime Error while running on line {}.\n {}: {}\n{}\n", 
                step->line, (int)exception.type, exception.description, exception.information);
            throw 63;
        }
        
        void halt() {  // 计划中的停机
            status = Stopped;
        }

        void launch() {  // 开始运行
            step = code.operations.begin();

            while (step != code.operations.end() and status == OK) {
                step->execute();
                if (status == OK)  step++;
                else if (status == Jumping) {
                    status = OK;
                } else {
                    break;
                }
            }
        }

        void jump(int opIndex) {  // 跳转
            step = code.operations.begin() + opIndex;
            status = Jumping;
        }

        void jump(std::vector<Operation>::iterator it) {
            step = it;
            status = Jumping;
        }
    } program;  // 当前在运行的程序
}
```

最后，对于每一次操作，调用相应函数，即 `execute()` 方法。
```cpp
namespace Program {
    void Operation::execute() {
        assert(Processor::OperationsMapping[label]);
        std::invoke(Processor::OperationsMapping[label], *args);
    }
}
```


接下来我们就可以写解析器了。由于是汇编语言，解析还是比较容易的。

对于解析出来的结果，可以见上文的 `Parsed` 类。其中，`Operations` 是操作列表，前三个无序映射是用来维护函数名、函数 ID 和行号，最后一个维护行号到操作编号的映射（因为我们各种跳转都是基于行号的）。

这里有一点有点违背常识，根据题意描述，如果定义函数的语句不在一行的开头，我们执行语句会先执行它前面的。但是既然没有这样的数据，也就无所谓了。

我们先把所有的字符读到字符串中，然后依次找到每一行的行首字符编号，存到数组中。这是为了维护行号和操作编号的关系。

接下来重新从这个字符串读一遍，解析每一条命令。每一条命令都包含一个标识符（不含空白字符的字符串）和若干个参数（开头为 `%`，`@`，`#`，`$`或者是一串纯数字），最后分号结尾。分别处理即可。

最后简单包装一下，这个简易的解释器就完成了。

## AC 代码
注意，这个代码仅能在 C++ 20 或更新的标准下通过编译。

见[云剪贴板（24.18KB，720 行）](https://www.luogu.com.cn/paste/vvy4qyft)

## 总结
我的代码的工程风格还算比较重的，也实现了一些冗余的功能，再加上有一些点题面描述并不清晰或者没有提及，所以代码较长，不过自认为还算清晰。

很不错的一道模拟题，情景较为自然，也没有又臭又长的文字描述，写起来还是很舒服的。不过“跳转”操作的存在把想要拿 Python 的 `exec()` 加上正则表达式匹配水解释器模拟的同学一下子就给卡掉了。（邪恶

感谢您的阅读。

---

## 作者：Yharimium (赞：3)

题目链接：[P4911](https://www.luogu.com.cn/problem/P4911)

超级大模拟。思维不难，但很考验人的耐心。

## 零、变量的定义

``` cpp
// 寄存器
int r1, r2, r3, r4, e1, e2, e3, e4, flag, val, ret, line;

// 地址栈
stack<int> sAddr;

// 函数表，是「函数名 → 函数的起始行号」的映射
map<string, int> func;
```

## 一、善于使用 `enum` 和 `map`

`enum`（枚举）的学习资料：[菜鸟教程 c-enum](https://www.runoob.com/cprogramming/c-enum.html)

利用 `enum` 给每类汇编指令设置枚举值 `command_type`。

``` cpp
enum command_type {
	HLT,
	NOP,
	UDEF,
	SET,
	JMP,
	JIF,
	CALL,
	RET,

	...
};
```

通过 `map` 建立「`string` → `command_type`」和「`string` → 寄存器地址」的映射，便于后续的解析。

``` cpp
map<string, command_type> command_map {
	{ "hlt", 	HLT },
	{ "nop", 	NOP },
	{ "udef", 	UDEF },
	{ "set", 	SET },
	{ "jmp", 	JMP },
	{ "jif", 	JIF },
	{ "call", 	CALL },
	{ "ret", 	RET },

	...
};
```

``` cpp
map<string, int*> params_map {
	{ "r1", 	&r1 },
	{ "r2", 	&r2 },
	{ "r3", 	&r3 },
	{ "r4", 	&r4 },
	{ "e1", 	&e1 },
	{ "e2", 	&e2 },
	{ "e3", 	&e3 },
	{ "e4", 	&e4 },
	{ "flag", 	&flag },
	{ "val", 	&val },
	{ "ret", 	&ret },
	{ "line", 	&line }
};
```

## 二、单行指令的解析

首先实现 `get_arg` 和 `get_addr` 方法。

- `int get_arg(string)`：找到 `string` 所对应的寄存器的地址，返回该寄存器中存放的数字；若找不到则使用 `stoi` 函数将该字符串转为整数并返回。

- `int* get_addr(string)`：找到 `string` 所对应的寄存器的地址，返回此地址；若找不到则返回空指针。

``` cpp
int get_arg(string param) {
	auto m_param = param.substr(1);
	if (params_map.find(m_param) != params_map.end())
		return *params_map[m_param];
	// else
		return stoi(param);
}

int* get_addr(string param) {
	auto m_param = param.substr(1);
	if (params_map.find(m_param) != params_map.end())
		return params_map[m_param];
	// else
		return nullptr;
}
```

有了这两个函数，就可以：

``` cpp
get_arg("val"); 	// 得到寄存器 val 中的数字
get_arg("114514"); 	// 得到数字 114514
get_addr("ret");	// 得到寄存器 ret 的内存地址
```

接下来把单行命令封装成 `struct Ktx_data`。

- `Ktx_data& Ktx_data::init()`：从控制台读取一行命令，解析，并返回自身。
- `int Ktx_data::argAt(int i)`：返回第 `i` 个参数。
- `int* Ktx_data::addrAt(int i)`：返回第 `i` 个参数的内存地址
- `bool Ktx_data::hasArg(int i)`：判断第 `i` 个参数是否存在

``` cpp
struct Ktx_data {
	string cmd;
	vector<string> args;
	
	Ktx_data& init() {
		cin >> cmd;
		
		if (cmd.back() == ';') {
			cmd.pop_back();
			return *this;
		}
		
		string place_holder;
		while (cin >> place_holder) {
			args.push_back(place_holder);
			if (place_holder.back() == ';') {
				args.back().pop_back();
				break;
			}
		}
		
		return *this;
	}
	int argAt(int index) {
		return get_arg(args[index]);
	}
	int* addrAt(int index) {
		return get_addr(args[index]);
	}
	bool hasArg(int index) {
		return index < (int)args.size();
	}
};
```

## 三、汇编程序的运行

这里使用 `vector` 存储指令行。题目规定行号从 $1$ 开始计算，故先往 `vector` 中推入一个空的 `Ktx_data`，确保后续的下标是从 $1$ 开始延续的。

``` cpp
int main() {
	vector<Ktx_data> command_line;
	command_line.push_back(Ktx_data());

	...
}
```

读取并解析所有 $n$ 行指令。

``` cpp
int main() {
	...
    
	int n;
	scanf("%d", &n);

	for (int i = 1; i <= n; i ++) {
		command_line.push_back(Ktx_data().init());
	}

	...
}
```

处理所有函数名。

``` cpp
int main() {
	...

	for (int i = 1; i <= n; i ++) {
		const auto &_data = command_line[i];
		if (_data.cmd == "function") {
			func[_data.args[0]] = i + 1;
		}
	}

	...
}
```

严格按照文档的要求，执行所有 $n$ 行指令。

``` cpp
int main() {
	...

	for (int i = 1; i <= n; i++) {
		
		auto _data = command_line[i];
		int* target;
		int param;
		
		command_type command = command_map[_data.cmd];
		
		// 控制类指令
		switch(command) {
		case HLT:
			return 0;
		case NOP:
			break;
		case UDEF:
			break;
		case SET:
			*_data.addrAt(1) = _data.argAt(0);
			break;
		case JMP:
			i = _data.argAt(0) + line - 1;
			break;
		case JIF:
			if ((_data.hasArg(1) && _data.argAt(1)) || flag)
				i = _data.argAt(0) + line - 1;
			break;
		case CALL:
			sAddr.push(i + 1);
			i = _data.argAt(0) - 1;
			break;
		case RET:
			if (sAddr.size()) {
				auto top = sAddr.top();
				sAddr.pop();
				i = top - 1;
			}
			if (_data.hasArg(0))
				ret = _data.argAt(0);
			break;
		case CALLFUNC:
			sAddr.push(i + 1);
			i = func[_data.args[0]] - 1;
			line = i;
			break;
		default:
			break;
		}
		
		// 运算类指令
		target = _data.hasArg(1) ? _data.addrAt(1) : &val;
		switch(command) {
		case INV:
			*target = - _data.argAt(0);
			break;
		default:
			break;
		}
		
		target = _data.hasArg(2) ? _data.addrAt(2) : &val;
		switch(command) {
		case ADD:
			*target = _data.argAt(0) + _data.argAt(1); 	break;
		case SUB:
			*target = _data.argAt(0) - _data.argAt(1); 	break;
		case MULT:
			*target = _data.argAt(0) * _data.argAt(1); 	break;
		case IDIV:
			*target = _data.argAt(0) / _data.argAt(1); 	break;
		case MOD:
			*target = _data.argAt(0) % _data.argAt(1); 	break;
		case LSFT:
			*target = _data.argAt(0) << _data.argAt(1); break;
		case RSFT:
			*target = _data.argAt(0) >> _data.argAt(1); break;
		case BAND:
			*target = _data.argAt(0) & _data.argAt(1); 	break;
		case BOR:
			*target = _data.argAt(0) | _data.argAt(1); 	break;
		case BXOR:
			*target = _data.argAt(0) ^ _data.argAt(1); 	break;
		default:
			break;
		}
		
		// 逻辑类指令
		target = _data.hasArg(2) ? _data.addrAt(2) : &flag;
		switch(command) {
		case LGR:
			*target = _data.argAt(0) > _data.argAt(1); 	break;
		case LLS:
			*target = _data.argAt(0) < _data.argAt(1); 	break;
		case LGE:
			*target = _data.argAt(0) >= _data.argAt(1); break;
		case LLE:
			*target = _data.argAt(0) <= _data.argAt(1); break;
		case LEQL:
			*target = _data.argAt(0) == _data.argAt(1); break;
		case LAND:
			*target = _data.argAt(0) && _data.argAt(1); break;
		case LOR:
			*target = _data.argAt(0) || _data.argAt(1); break;
		default:
			break;
		}
		
		// 输入输出类指令
		target = _data.hasArg(0) ? _data.addrAt(0) : &flag;
		switch(command) {
		case RINT:
			scanf("%d", target);
			break;
		case RCH:
			*target = getchar();
			if (*target == '\r')
				*target = getchar();
			break;
		case WINT:
			param = _data.hasArg(0) ? _data.argAt(0) : val;
			if (_data.hasArg(0) && _data.addrAt(0) == &line)
				printf("%d", i);
			else
				printf("%d", param);
			break;
		case WCH:
			param = _data.hasArg(0) ? _data.argAt(0) : val;
			putchar(param);
			break;
		default:
			break;
		}
	}

	return 0;
}
```

## 代码

整个处理器被包装成 `class Ktx_Core`，部分地方和上述内容会有所区别。

``` cpp
#include <bits/stdc++.h>

using namespace std;

class Ktx_Core {
private:
	int r1, r2, r3, r4, e1, e2, e3, e4, flag, val, ret, line;
	stack<int> sAddr;
	map<string, int> func;

	enum command_type {
		HLT,
		NOP,
		UDEF,
		SET,
		JMP,
		JIF,
		CALL,
		RET,
		CALLFUNC,
		INV,
		ADD,
		SUB,
		MULT,
		IDIV,
		MOD,
		LSFT,
		RSFT,
		BAND,
		BOR,
		BXOR,
		LGR,
		LLS,
		LGE,
		LLE,
		LEQL,
		LAND,
		LOR,
		RINT,
		RCH,
		WINT,
		WCH
	};
	
	map<string, command_type> command_map {
		{ "hlt", 	HLT },
		{ "nop", 	NOP },
		{ "udef", 	UDEF },
		{ "set", 	SET },
		{ "jmp", 	JMP },
		{ "jif", 	JIF },
		{ "call", 	CALL },
		{ "ret", 	RET },
		{ "callfunc", CALLFUNC },
		{ "inv", 	INV },
		{ "add", 	ADD },
		{ "sub", 	SUB },
		{ "mult", 	MULT },
		{ "idiv", 	IDIV },
		{ "mod", 	MOD },
		{ "lsft", 	LSFT },
		{ "rsft", 	RSFT },
		{ "band", 	BAND },
		{ "bor", 	BOR },
		{ "bxor", 	BXOR },
		{ "lgr", 	LGR },
		{ "lls", 	LLS },
		{ "lge", 	LGE },
		{ "lle", 	LLE },
		{ "leql", 	LEQL },
		{ "land", 	LAND },
		{ "lor", 	LOR },
		{ "rint", 	RINT },
		{ "rch", 	RCH },
		{ "wint", 	WINT },
		{ "wch", 	WCH }
	};

	map<string, int*> params_map {
		{ "r1", 	&r1 },
		{ "r2", 	&r2 },
		{ "r3", 	&r3 },
		{ "r4", 	&r4 },
		{ "e1", 	&e1 },
		{ "e2", 	&e2 },
		{ "e3", 	&e3 },
		{ "e4", 	&e4 },
		{ "flag", 	&flag },
		{ "val", 	&val },
		{ "ret", 	&ret },
		{ "line", 	&line }
	};
	
	int get_arg(string param) {
		auto m_param = param.substr(1);
		if (params_map.find(m_param) != params_map.end())
			return *params_map[m_param];
		// else
			return stoi(param);
	}

	int* get_addr(string param) {
		auto m_param = param.substr(1);
		if (params_map.find(m_param) != params_map.end())
			return params_map[m_param];
		// else
			return nullptr;
	}
	
	struct Ktx_data {
		string cmd;
		vector<string> args;
		Ktx_Core* parent;
		
		Ktx_data(Ktx_Core* parent):
			parent(parent) {}
		
		Ktx_data& init() {
			cin >> cmd;
			
			if (cmd.back() == ';') {
				cmd.pop_back();
				return *this;
			}
			
			string place_holder;
			while (cin >> place_holder) {
				args.push_back(place_holder);
				if (place_holder.back() == ';') {
					args.back().pop_back();
					break;
				}
			}
			
			return *this;
		}
		int argAt(int index) {
			return parent->get_arg(args[index]);
		}
		int* addrAt(int index) {
			return parent->get_addr(args[index]);
		}
		bool hasArg(int index) {
			return index < (int)args.size();
		}
	};
	
	vector<Ktx_data> command_line;

public:
	int exec() {
		int n;
		scanf("%d", &n);
		
		command_line.push_back(Ktx_data(this));
		
		for (int i = 1; i <= n; i ++) {
			command_line.push_back(Ktx_data(this).init());
		}
		for (int i = 1; i <= n; i ++) {
			const auto &_data = command_line[i];
			if (_data.cmd == "function") {
				func[_data.args[0]] = i + 1;
			}
		}
		for (int i = 1; i <= n; i++) {
			
			auto _data = command_line[i];
			int* target;
			int param;
			
			command_type command = command_map[_data.cmd];
			
			// ctrl
			switch(command) {
			case HLT:
				return 0;
			case NOP:
				break;
			case UDEF:
				break;
			case SET:
				*_data.addrAt(1) = _data.argAt(0);
				break;
			case JMP:
				i = _data.argAt(0) + line - 1;
				break;
			case JIF:
				if ((_data.hasArg(1) && _data.argAt(1)) || flag)
					i = _data.argAt(0) + line - 1;
				break;
			case CALL:
				sAddr.push(i + 1);
				i = _data.argAt(0) - 1;
				break;
			case RET:
				if (sAddr.size()) {
					auto top = sAddr.top();
					sAddr.pop();
					i = top - 1;
				}
				if (_data.hasArg(0))
					ret = _data.argAt(0);
				break;
			case CALLFUNC:
				sAddr.push(i + 1);
				i = func[_data.args[0]] - 1;
				line = i;
				break;
			default:
				break;
			}
			
			// calc
			target = _data.hasArg(1) ? _data.addrAt(1) : &val;
			switch(command) {
			case INV:
				*target = - _data.argAt(0);
				break;
			default:
				break;
			}
			
			target = _data.hasArg(2) ? _data.addrAt(2) : &val;
			switch(command) {
			case ADD:
				*target = _data.argAt(0) + _data.argAt(1); 	break;
			case SUB:
				*target = _data.argAt(0) - _data.argAt(1); 	break;
			case MULT:
				*target = _data.argAt(0) * _data.argAt(1); 	break;
			case IDIV:
				*target = _data.argAt(0) / _data.argAt(1); 	break;
			case MOD:
				*target = _data.argAt(0) % _data.argAt(1); 	break;
			case LSFT:
				*target = _data.argAt(0) << _data.argAt(1); break;
			case RSFT:
				*target = _data.argAt(0) >> _data.argAt(1); break;
			case BAND:
				*target = _data.argAt(0) & _data.argAt(1); 	break;
			case BOR:
				*target = _data.argAt(0) | _data.argAt(1); 	break;
			case BXOR:
				*target = _data.argAt(0) ^ _data.argAt(1); 	break;
			default:
				break;
			}
			
			// logic
			target = _data.hasArg(2) ? _data.addrAt(2) : &flag;
			switch(command) {
			case LGR:
				*target = _data.argAt(0) > _data.argAt(1); 	break;
			case LLS:
				*target = _data.argAt(0) < _data.argAt(1); 	break;
			case LGE:
				*target = _data.argAt(0) >= _data.argAt(1); break;
			case LLE:
				*target = _data.argAt(0) <= _data.argAt(1); break;
			case LEQL:
				*target = _data.argAt(0) == _data.argAt(1); break;
			case LAND:
				*target = _data.argAt(0) && _data.argAt(1); break;
			case LOR:
				*target = _data.argAt(0) || _data.argAt(1); break;
			default:
				break;
			}
			
			// I/O
			target = _data.hasArg(0) ? _data.addrAt(0) : &flag;
			switch(command) {
			case RINT:
				scanf("%d", target);
				break;
			case RCH:
				*target = getchar();
				if (*target == '\r')
					*target = getchar();
				break;
			case WINT:
				param = _data.hasArg(0) ? _data.argAt(0) : val;
				if (_data.hasArg(0) && _data.addrAt(0) == &line)
					printf("%d", i);
				else
					printf("%d", param);
				break;
			case WCH:
				param = _data.hasArg(0) ? _data.argAt(0) : val;
				putchar(param);
				break;
			default:
				break;
			}
		}
		return 0;
	}
};

int main() {

	Ktx_Core vm;
	
	vm.exec();

    return 0;
}
```

---

## 作者：Gralerfics (赞：3)

啊这，貌似是第一份 JavaAC 欸。

一遍过（是数据太水了大概咳咳）

虽然好像评论区说数据有些指令没有然而还是都写了，没看到没空行所以空行也处理了一下。

我怀疑有 bug 但数据测试不出来（小声

（嗯，这次 O2 又是会逆向优化）

是刚学了 Java 用来巩固写的 emm ，所以也做了奇怪的封装什么的，也没有注重代码长度和效率，写长点多爽啊（暴论

后半部分写得比较肿，主要是看不清了要。

------------

具体嘛就是假装词法分析一下（见 ```public void Compiler.Lexer()```
 ）。这里面是先割词，然后识别到标识符再向前归纳和可能存在的 ```%, @``` 之类的合并起来变成变量。

按词分好，按行分好，然后执行（见 ```public void Interpreter.run()``` ）。

运行前还要处理一下函数地址（见 ```public void Interpreter.loadup()``` ）。

为了体现面向对象各种结构都定义了对应的类（ ```CPU, Memory, Compiler, Interpreter, Stream, IStream, OStream``` ）。

 ```sAddr``` 栈和各种寄存器在 ```CPU``` 类里，内存就是内存。

```class IStream extends Stream``` 和 ```class OStream extends Stream``` 分别模拟输入输出流。

各自成员变量都设为 ```private``` 做了封装（自虐）。

所以 ```main``` 函数看起来很舒服咳咳。

所以全收起来之后比较清晰：

```java
import java.util.*;

// 内存
class Memory {...}

// 处理器
class CPU {...}

// 流
class Stream {...}

// 输入流 extends 流
class IStream extends Stream {...}

// 输出流 extends 流
class OStream extends Stream {...}

// 编译器（伪
class Compiler {...}

// 解释器（伪
class Interpreter {...}

public class Main {
    public static void main(String[] args) {...}
}
```

------------

最后贴上代码，写了不少注释：

```java
import java.util.*;

// 内存
class Memory {
    // 0 - 1677216
    private int[] data = new int[16777300];

    // 构造函数
    Memory() {
        Arrays.fill(data, 0);
    }

    // 调取和设置方法
    public int getAddr(int _a) {
        return data[_a];
    }
    public void setAddr(int _a, int _d) {
        data[_a] = _d;
    }
}

// 处理器
class CPU {
    // 栈元素
    private class Tsta {
        int next;
        int line;

        Tsta(int next, int line) {
            this.next = next;
            this.line = line;
        }
    }

    // 栈
    private Stack<Tsta> sAddr = new Stack<>();

    // 寄存器
    private int R1 = 0, R2 = 0, R3 = 0, R4 = 0;
    private int E1 = 0, E2 = 0, E3 = 0, E4 = 0;
    private int Flag = 0, Val = 0, Ret = 0, Line = 0;

    // 调取和设置方法
    public int Get(String name) {
        switch (name) {
            case "r1": return R1;
            case "r2": return R2;
            case "r3": return R3;
            case "r4": return R4;
            case "e1": return E1;
            case "e2": return E2;
            case "e3": return E3;
            case "e4": return E4;
            case "flag": return Flag;
            case "val": return Val;
            case "ret": return Ret;
            case "line": return Line;
        }
        return 0;
    }
    public void Set(String name, int t) {
        switch (name) {
            case "r1": R1 = t; break;
            case "r2": R2 = t; break;
            case "r3": R3 = t; break;
            case "r4": R4 = t; break;
            case "e1": E1 = t; break;
            case "e2": E2 = t; break;
            case "e3": E3 = t; break;
            case "e4": E4 = t; break;
            case "flag": Flag = t; break;
            case "val": Val = t; break;
            case "ret": Ret = t; break;
            case "line": Line = t; break;
        }
    }
    public void push(int next, int line) {
        sAddr.push(new Tsta(next, line));
    }
    public int pop() {
        // 弹栈返回目标行，并复位%Line
        Tsta t = sAddr.pop();
        Line = t.line;
        return t.next;
    }
}

// 流
class Stream {
    // 数据
    private ArrayList<String> data = new ArrayList<>();

    // 调取和设置方法
    public ArrayList<String> get() {
        return data;
    }
    public void add(String s) {
        data.add(s);
    }
}

// 输入流 extends 流
class IStream extends Stream {
    // 指针
    private int current = 0;

    // 是否为空白符
    private boolean isWhite(char _peek) {
        return _peek == ' ' || _peek == '\t';
    }

    // 构造函数，按空白符划词
    IStream() {}
    IStream(Stream _in) {
        for (String _line : _in.get()) {
            int len = _line.length();
            int j = 0;
            for (int i = 1; i < len; i++) {
                // 词尾
                if (isWhite(_line.charAt(i)) && !isWhite(_line.charAt(i - 1))) {
                    add(_line.substring(j, i));
                }
                // 词头，头指针更新
                if (!isWhite(_line.charAt(i)) && isWhite(_line.charAt(i - 1))) {
                    j = i;
                }
            }
            // 行末 -> 词尾
            add(_line.substring(j));
        }
    }

    // 按序读取
    public String getNext() {
        return get().get(current++);
    }
}

// 输出流 extends 流
class OStream extends Stream {
    // 输出
    public void output() {
        for (String _l : get()) {
            System.out.print(_l);
        }
    }
}

// 编译器（伪
class Compiler {
    // 词
    private class Ttoken {
        // 词类型
        private int type = 0;

        // 词属性
        private String property;

        // 构词法
        Ttoken(int type, String property) {
            this.type = type;
            this.property = property;
        }

        // 调取和设置方法
        public int getT() {
            return type;
        }
        public void setT(int type) {
            this.type = type;
        }
        public String getP() {
            return property;
        }
        public void setP(String property) {
            this.property = property;
        }
    }

    // 词表
    private ArrayList<Ttoken> tokens = new ArrayList<>();

    // 句首词表
    private ArrayList<Integer> cmds = new ArrayList<>();

    // 是否为空白符
    private boolean isWhite(char _peek) {
        return _peek == ' ' || _peek == '\t';
    }

    // 是否为标识符字符
    private boolean isLetter(char _peek) {
        return _peek >= 'A' && _peek <= 'z' || _peek >= '0' && _peek <= '9';
    }

    // 词法分析，并记录句首词
    public void Lexer(Stream _code) {
        int anno = 0;
        cmds.add(0); // 行号从1开始标记
        for (String _line : _code.get()) {
            cmds.add(tokens.size());
            int len = _line.length();
            for (int i = 0; i < len; i++) {
                char _peek = _line.charAt(i);
                // 空白、注释处理
                if (_peek == '[') {
                    anno++;
                    continue;
                }
                if (_peek == ']') {
                    anno--;
                    continue;
                }
                if (anno != 0 || isWhite(_peek)) continue;

                // 特殊符号
                if (_peek == '%') {
                    tokens.add(new Ttoken(-1, ""));
                    continue;
                }
                if (_peek == '@') {
                    tokens.add(new Ttoken(-2, ""));
                    continue;
                }
                if (_peek == '#') {
                    tokens.add(new Ttoken(-3, ""));
                    continue;
                }
                if (_peek == '$') {
                    tokens.add(new Ttoken(-4, ""));
                    continue;
                }
                if (_peek == ';') {
                    tokens.add(new Ttoken(-5, ""));
                    continue;
                }

                // 标识符
                tokens.add(new Ttoken(1,"" + _peek));
                if (i < len - 1) {
                    _peek = _line.charAt(++i);
                    while (i < len && isLetter(_peek)) {
                        tokens.get(tokens.size() - 1).property += _peek;
                        _peek = _line.charAt(++i);
                    }
                    i--;
                }

                // 标识符向前归纳
                if (tokens.size() <= 2) continue;
                Ttoken A = tokens.get(tokens.size() - 3);
                Ttoken B = tokens.get(tokens.size() - 2);
                Ttoken C = tokens.get(tokens.size() - 1);
                if (A.type == -2 && B.type == -1) {
                    A.type = 4;
                    A.property = C.property;
                    tokens.remove(tokens.size() - 1);
                    tokens.remove(tokens.size() - 1);
                    continue;
                } // @%... -> 4
                if (B.type == -1) {
                    B.type = 2;
                    B.property = C.property;
                    tokens.remove(tokens.size() - 1);
                    continue;
                } // %... -> 2
                if (B.type == -2) {
                    B.type = 3;
                    B.property = C.property;
                    tokens.remove(tokens.size() - 1);
                    continue;
                } // @... -> 3
                if (B.type == -3) {
                    B.type = 5;
                    B.property = C.property;
                    tokens.remove(tokens.size() - 1);
                    continue;
                } // #... -> 5
                if (B.type == -4) {
                    B.type = 6;
                    B.property = C.property;
                    tokens.remove(tokens.size() - 1);
                    // continue;
                } // $... -> 6
            }
        }
        cmds.add(cmds.get(cmds.size() - 1) + 1); // 结尾加空行防止ptr+1溢出
    }

    // 获取第_n行句首词编号
    public Integer getCmd(int _n) {
        return cmds.get(_n);
    }

    // 获取第_n个词
    public int GetT(int _n) {
        return tokens.get(_n).type;
    }
    public String GetP(int _n) {
        return tokens.get(_n).property;
    }
}

// 解释器（伪
class Interpreter {
    // 处理器
    private CPU cpu = new CPU();

    // 内存
    private Memory mem = new Memory();

    // 当前执行行号，即#Line
    private int ptr;

    // 函数头行号记录
    private HashMap<String, Integer> func = new HashMap<>();

    // 函数加载器
    public void loadup(int _n, Compiler com) {
        for (int i = 1; i <= _n; i++) {
            if (com.getCmd(i + 1).equals(com.getCmd(i))) continue;
            int num = com.getCmd(i);
            if (com.GetP(num).contains("function")) {
                func.put(com.GetP(num + 1), i); // 关联函数名与行号
            }
        }
    }

    // 获取变量值
    public int FET(int ty0, String pr0) {
        switch (ty0) {
            case -1: return (int)pr0.charAt(0);
            case 1: return Integer.parseInt(pr0);
            case 2: return cpu.Get(pr0);
            case 3: return mem.getAddr(Integer.parseInt(pr0));
            case 4: return mem.getAddr(cpu.Get(pr0));
            case 5: return ptr;
            case 6: return func.get(pr0);
        }
        return 0;
    }

    // SET操作
    public void SET(int ty0, String pr0, int ty1, String pr1) {
        int arg0 = FET(ty0, pr0);
        switch (ty1) {
            case 2: cpu.Set(pr1, arg0); break;
            case 3: mem.setAddr(Integer.parseInt(pr1), arg0); break;
            case 4: mem.setAddr(cpu.Get(pr1), arg0); break;
        }
    }

    // 运行
    public void run(Compiler com, IStream in, OStream out) {
        ptr = 1;
        while (true) {
            if (com.getCmd(ptr + 1).equals(com.getCmd(ptr))) {
                ptr++;
                continue;
            }
            if (com.GetP(com.getCmd(ptr)).contains("hlt")) {
                break;
            } else if (com.GetP(com.getCmd(ptr)).contains("set")) {
                SET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1),
                    com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));
            } else if (com.GetP(com.getCmd(ptr)).contains("jmp")) {
                ptr = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))
                    + cpu.Get("line");
                continue;
            } else if (com.GetP(com.getCmd(ptr)).contains("jif")) {
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 3) {
                    if (cpu.Get("flag") == 1) {
                        ptr = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))
                                + cpu.Get("line");
                        continue;
                    }
                } else {
                    if (FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2)) != 0) {
                        ptr = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))
                                + cpu.Get("line");
                        continue;
                    }
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("call")) {
                cpu.push(ptr + 1, cpu.Get("line")); // 压栈
                ptr = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1)); // 跳转至函数
                cpu.Set("line", ptr); // 设置当前函数头
                continue;
            } else if (com.GetP(com.getCmd(ptr)).contains("ret")) {
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 3) {
                    cpu.Set("ret", FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))); // 返回值
                }
                ptr = cpu.pop(); // 弹栈并跳回，同时复位%Line
                continue;
            } else if (com.GetP(com.getCmd(ptr)).contains("inv")) {
                int t = - FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1));
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 3) {
                    cpu.Set("val", t);
                } else {
                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("add")) {
                int t = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))
                        + FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {
                    cpu.Set("val", t);
                } else {
                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("sub")) {
                int t = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))
                        - FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {
                    cpu.Set("val", t);
                } else {
                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("mult")) {
                int t = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))
                        * FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {
                    cpu.Set("val", t);
                } else {
                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("idiv")) {
                int t = (int)Math.floor(1.0d * FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))
                        / FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2)));
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {
                    cpu.Set("val", t);
                } else {
                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("mod")) {
                int t = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))
                        % FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {
                    cpu.Set("val", t);
                } else {
                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("lsft")) {
                int t = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))
                        << FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {
                    cpu.Set("val", t);
                } else {
                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("rsft")) {
                int t = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))
                        >> FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {
                    cpu.Set("val", t);
                } else {
                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("band")) {
                int t = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))
                        & FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {
                    cpu.Set("val", t);
                } else {
                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("bor")) {
                int t = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))
                        | FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {
                    cpu.Set("val", t);
                } else {
                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("bxor")) {
                int t = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))
                        ^ FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {
                    cpu.Set("val", t);
                } else {
                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("lgr")) {
                int t = (FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))
                        > FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2)))?1:0;
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {
                    cpu.Set("flag", t);
                } else {
                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("lls")) {
                int t = (FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))
                        < FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2)))?1:0;
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {
                    cpu.Set("flag", t);
                } else {
                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("lge")) {
                int t = (FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))
                        >= FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2)))?1:0;
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {
                    cpu.Set("flag", t);
                } else {
                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("lle")) {
                int t = (FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))
                        <= FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2)))?1:0;
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {
                    cpu.Set("flag", t);
                } else {
                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("leql")) {
                int t = (FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))
                        == FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2)))?1:0;
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {
                    cpu.Set("flag", t);
                } else {
                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("land")) {
                int t = (FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1)) == 1
                        && FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2)) == 1)?1:0;
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {
                    cpu.Set("flag", t);
                } else {
                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("lor")) {
                int t = (FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1)) == 0
                        && FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2)) == 0)?0:1;
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {
                    cpu.Set("flag", t);
                } else {
                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("rint")) {
                SET(1, in.getNext(), com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1));
            } else if (com.GetP(com.getCmd(ptr)).contains("rch")) {
                SET(-1, in.getNext(), com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1));
            } else if (com.GetP(com.getCmd(ptr)).contains("wint")) {
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 2) {
                    out.add(((Integer) cpu.Get("val")).toString());
                } else {
                    out.add(((Integer) FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))).toString());
                }
            } else if (com.GetP(com.getCmd(ptr)).contains("wch")) {
                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 2) {
                    out.add("" + (char)cpu.Get("val"));
                } else {
                    out.add("" + (char)FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1)));
                }
            }
            ptr++; // 除跳转语句外，行号指针默认+1
        }
    }
}

public class Main {
    public static void main(String[] args) {
        // 创建Scanner对象
        Scanner scanner = new Scanner(System.in);

        // 读入程序
        Stream code = new Stream();
        int totalLines = scanner.nextInt();
        scanner.nextLine();
        for (int i = 0; i < totalLines; i++) {
            code.add(scanner.nextLine());
        }

        // 读入输入并加载至输入流
        Stream input = new Stream();
        while (scanner.hasNextLine()) {
            input.add(scanner.nextLine());
        }
        IStream in = new IStream(input);

        // 编译，数据保证无编译错误
        Compiler compiler = new Compiler();
        compiler.Lexer(code);

        // 解释，数据保证无运行时错误
        Interpreter interpreter = new Interpreter();
        OStream out = new OStream();
        interpreter.loadup(totalLines, compiler);
        interpreter.run(compiler, in, out);

        // 输出
        out.output();
    }
}
```


---

## 作者：Halberd_Cease (赞：2)

写了 2 个小时，调了 2 个小时，发现题目里面要存 32 位整型，我 `#define int long long`……

回到正题，这道题其实比较的水啊，包括但不限于数据，还有题目本身。

题目本质上就是需要模拟一个编译器，然后运行，或者说解释一个语言，其解释方法已经详细给出了，还有各种命令之类的东西，总之把题读 3 遍，然后写就可以了。

首先拿到一个程序，先分割其 token，按关键字保存下来，因为出题人说过，没有一行多个语句的情况，所以直接按行来存语句就好了，不过要是需要实现一行多语句也比较简单，将存储结构开成 行数 个 vector 即可。

然后注释的话，可以参考括号匹配的问题，用栈模拟，如果字符在一个括号里面，就直接跳过。

然后注意 token 的分割符，空格、逗号、分号，如果要考虑一行多语句的话，分号就开启下一个语句了。

如果你不是按行号来存的语句的话，可能还需要维护一个语句序号和行号的映射。

然后是特殊语句的编译，题目给出了两个语句的等价语句，直接替换掉就好了。

题目给出的数据有可能是数，也有可能是一个变量地址，我这里选择统一作为 string 类型存储（限于语句中的参数，寄存器和内存的数据仍用 int 处理），然后写一个整型和字符串互相转化的函数，把字符串转整型集成到查找内存和寄存器的函数中，省掉一部分分类讨论，所以在编译阶段不需要对数字做特殊处理。

剩下的部分建议结合 PDF 食用：

- 开一个 16 兆个数据的整型数组，作为内存；

- 按题目要求开 12 个寄存器，这 12 个寄存器有不同的用途，都会在下面提到；
- 关于 $\text{Line}$：这一段的意思是，跳转语句是基于函数的，在下文我们会知道进入一个函数的时候，$\text{Line}$ 值会设为当前函数开头的那一行，而后文的 $\text{JMP,JIF}$ 操作是基于 $\text{Line}$ 的偏移跳转，说成人话就是执行操作时跳转到第 $\text{Line}+$ 给出的数据 那一行，相当于跳转到这个函数的第几行，关于 $\text{Line}$ 的修改不用过于关注，只会进行一种形式的系统修改，并且下文给出了过程。
- 关于 $\text{sAddr}$ 栈：这个栈每一层会存两个数据，进栈是 $\text{CALL}$ 语句，退栈是 $\text{RET}$ 语句，这两个语句下文都有详细的规定，这里不展开，只需要知道这个栈一次存两个数据后面就好理解了。
- 注释我们已经处理过了，所以跳过；
- 命令格式：这一段关系到我们如何存一个语句，先是 opt，即操作，后面跟操作数，我们可以看到操作数有很多种，其中大部分都只能用字符串存（大佬可以用指针，但是我不会，所以我选择朴素的办法），所以干脆把剩下的常量（即只有数字）也一起用字符串存（回收上文）；
- 变量格式：常量全是数字（有可能有负号），寄存器以 % 开头，内存以 @ 开头，以 @% 开头的，相当于是访问的内存下标为寄存器的值的（可以参考数组 `a[i]`），#$\text{Line}$ 的意思是，这个“编译时常量”在哪一行，就代表多少，于是我们可以在编译阶段就将其替换掉。
- 命令：这一部分按照题目的说法模拟即可，另外，部分操作有【如果不存带某参数，就放入某寄存器中】的要求，我们在编译的时候特判一下，对于特定的操作，如果没有某一个操作数，就给它手动补全。
- $\text{FUNCTION}$ 命令：在编译期，需要优先于 $\text{CALLFUNC}$ 命令编译，开一个从函数名到当前行的映射，方便后面编译“调用函数”指令的时候查找，然后把这个操作直接替换成 $\text{SET}$ #$\text{Line}$ %$\text{Line}$。
- $\text{CALLFUNC}$ 命令：在编译期，后于 $\text{FUNCTION}$ 按照要求替换为 $\text{CALL}$ 指令即可，注意，这个指令是全局性的，跳转的行号不和当前 %$\text{Line}$ 挂钩。
- $\text{RET}$ 命令：结束一个函数，这时，在 $\text{sAddr}$ 栈中取出栈顶的两个数据，然后分别将当前行和 %$\text{Line}$ 设为取出的两个值，关于 %$\text{Ret}$ 寄存器，如果没有指定值的话，我们可以钦定把 %$\text{Ret}$ 的值赋给 %$\text{Ret}$，相当于一个减小分讨量的小 Trick。

需要注意的点：所有的数据均需要用 int 类型存储，不然左右移的时候可能会出问题。

[code](https://www.luogu.com.cn/paste/6pg89v50)

[这里](https://halberdcease.github.io/Files/ktx65-data-fixed.zip)是我不知道从哪里捡来的东西，看样子应该是数据生成器、标程和数据，如果你不知道哪里错了的话，不妨来看看。

---

## 作者：wangif424 (赞：1)

## 前言

这是我的第一道造计算机题。

因为不了解相关原理，以及代码书写习惯，我的做法基本在主函数中实现。

## 做法

### 首先是堆栈，内存，寄存器和常量的处理。

- 对于寄存器和 `#line` 常量，我们我们对应开变量实现即可。

- 对于内存池，即为一个非常大的整形数组。

- 同理，我们用 `stack<pair<int,int> >` 模拟堆栈。

### 然后我们读入和存储语句，并做初步处理。

- 这道题的数据中不存在一行多个语句的情况。因此，我们可以将注释的行全部替换为 `NOP`。

- 对于声明函数的行，我们用一个 `map<string,int>` 记录函数对应的行。

### 接下来，我们先处理调用参数。

- 用一个 `int*gt(string)` 将读入串转化为变量对应指针，分类讨论寄存器，内存，寄存器访问内存，常量和数字。

- 前四种情况逐位判断字符即可。数字则可以开一个大数组，将数字存入数组，再返回对应位置的指针。

注：本蒟蒻因指针太差，在处理数字时返回了临时变量的指针，因此导致 `RE10pts`。

### 最后逐行处理语句。

利用 `string::substr(int,int)` 和 `string::find(char,int)` 可以将语句的关键字的参数分割开，利用 `gt(string)` 获取参数的指针，模拟操作。

对于函数操作，我们按照文档中等价的两种操作直接做即可。

观察到操作 $9$ 到操作 $25$ 的功能具有极大相似度，我们可以利用 `function` 存储对应数值操作，再在一个函数内统一做分割运算，可以极大精简代码，节省时间。

### 处理技巧汇总

指针，`string` 相关的 `STL`，`function`。

## 代码

```cpp
#include <bits/stdc++.h>
#define pii pair<int,int> 
using namespace std;
int n;
stack<pii > saddr;
int r1,r2,r3,r4,e1,e2,e3,e4,flag,val,ret,Line,line;
int ram[64*1024*1024],tmp[64*1024*1024],tot;
string con[50501];
map<string,int> funToLine;
int stringToInt(string s){
	int r=0;
	for(auto c:s){
		if(isdigit(c))r=r*10+(c^48);
	}
	return r;
}
int*gt(string name){
	if(name[0]=='%'){
		switch(name[1]){
			case 'r':{
				switch(name[2]){
					case '1':return &r1;
					case '2':return &r2;
					case '3':return &r3;
					case '4':return &r4;
					case 'e':return &ret;
				}
				break;
			}
			case 'e':{
				switch(name[2]){
					case '1':return &e1;
					case '2':return &e2;
					case '3':return &e3;
					case '4':return &e4;
				}
				break;
			}
			case 'f':{
				return &flag;
				break;
			}
			case 'v':{
				return &val;
				break;
			}
			case 'l':{
				return &Line;
				break;
			}
		}
	}else if(name[0]=='@'){
		if(name[1]=='%')return (ram+*gt(name.substr(1,name.size())));
		return (ram+stringToInt(name));
	}else if(name[0]=='#'){
		return &line;
	}else{
		tmp[++tot]=stringToInt(name);
		return &tmp[tot];
	}
	return tmp;
}
void gtn(int pos,string con,int*Non,int func(int x,int y)){
    pos++;
    int ed=con.find(' ',pos),a,b;
    a=*gt(con.substr(pos,ed-pos));
    pos=ed+1;
    ed=con.find(' ',pos);
    int siz=con.size();
    if(ed==string::npos)ed=siz;
    b=*gt(con.substr(pos,ed-pos));
    if(ed==siz){
        *Non=func(a,b);
    }else{
        ed++;
        *gt(con.substr(ed,siz-ed))=func(a,b);
    }
}
signed main(){
	cin >> n;getchar();
	line=1;
	for(int i=1;i<=n;i++){
		char c=getchar();
		while(*con[line].rbegin()!=';'){
			if(c=='['){
				int p=1;
				while(p){
					c=getchar();
					if(c=='[')p++;
					if(c==']') p--;
				}
				con[line]="nop;";
				while(c^'\n')c=getchar();
			}else if(c=='f'&&con[line].size()==0){
				string opt;
				cin >> opt;
				con[line]=c+opt;
				c=getchar();
			}else if(c=='$'&&con[line].at(0)=='f'){
				string opt;
				cin >> opt;
				con[line]=con[line]+c+opt;
				opt=opt.substr(0,opt.size()-1);
				funToLine[opt]=line;
				c=getchar();
			}else if(c=='u'&&con[line].size()==0){
				string opt;
				cin >> opt;
			}else con[line]=con[line]+c,c=getchar();
		}
		line++;
	}
	line=1;
	while(line<=n){
		int siz=con[line].size();
		int pos=con[line].find(' ');
		if(pos==string::npos)pos=siz-1;
		string opt=con[line].substr(0,pos);
		if(opt=="hlt")break;
		else if(opt=="nop")line++;
		else if(opt=="set"){
			pos++;
			int ed=con[line].find(' ',pos);
			int opd=*gt(con[line].substr(pos,min(siz-1,ed)-pos));
			*gt(con[line].substr(ed+1,siz-ed-2))=opd;
			line++;
		}else if(opt=="jmp"){
			pos++;
			line=Line+*gt(con[line].substr(pos,siz-pos));
		}else if(opt=="jif"){
			pos++;
			int ed=con[line].find(' ',pos);
			if(ed==string::npos)ed=siz-1;
			int del=*gt(con[line].substr(pos,ed-pos));
			bool ctl=0;
			if(ed!=siz-1)ctl=!!*gt(con[line].substr(ed+1,siz-ed-1));
			else ctl=flag;
			if(ctl)line=Line+del;
			else line++;
		}else if(opt=="call"){
			pos++;
			saddr.emplace(line+1,Line);
			line=*gt(con[line].substr(pos,siz-pos-1));
		}else if(opt=="ret"){
			int nxt;
			tie(nxt,Line)=saddr.top();
			saddr.pop();
			if((con[line])[3]==' ')ret=*gt(con[line].substr(4,siz-5));
			line=nxt;
		}else if(opt=="inv"){
            pos++;
            int ed=con[line].find(' ',pos);
            int *chg;
            if(ed==string::npos)chg=&val;
			else chg=gt(con[line].substr(ed+1,siz-1-ed));
            *chg=-val;
            line++;
        }else if(opt=="add"){
            gtn(pos,con[line],&val,[](int x,int y){return x+y;});
            line++;
        }else if(opt=="sub"){
            gtn(pos,con[line],&val,[](int x,int y){return x-y;});
            line++;
        }else if(opt=="mult"){
            gtn(pos,con[line],&val,[](int x,int y){return x*y;});
            line++;
        }else if(opt=="idiv"){
            gtn(pos,con[line],&val,[](int x,int y){return x/y;});
            line++;
        }else if(opt=="mod"){
            gtn(pos,con[line],&val,[](int x,int y){return x%y;});
            line++;
        }else if(opt=="lsft"){
            gtn(pos,con[line],&val,[](int x,int y){return x<<y;});
            line++;
        }else if(opt=="rsft"){
            gtn(pos,con[line],&val,[](int x,int y){return x>>y;});
            line++;
        }else if(opt=="band"){
            gtn(pos,con[line],&val,[](int x,int y){return x&y;});
            line++;
        }else if(opt=="bor"){
            gtn(pos,con[line],&val,[](int x,int y){return x|y;});
            line++;
        }else if(opt=="bxor"){
            gtn(pos,con[line],&val,[](int x,int y){return x^y;});
            line++;
        }else if(opt=="lgr"){
            gtn(pos,con[line],&flag,[](int x,int y){return (int)(x>y);});
            line++;
        }else if(opt=="lls"){
            gtn(pos,con[line],&flag,[](int x,int y){return (int)(x<y);});
            line++;
        }else if(opt=="lge"){
            gtn(pos,con[line],&flag,[](int x,int y){return (int)(x>=y);});
            line++;
        }else if(opt=="lle"){
            gtn(pos,con[line],&flag,[](int x,int y){return (int)(x<=y);});
            line++;
        }else if(opt=="leql"){
            gtn(pos,con[line],&flag,[](int x,int y){return (int)(x==y);});
            line++;
        }else if(opt=="land"){
            gtn(pos,con[line],&flag,[](int x,int y){return (int)(x&&y);});
            line++;
        }else if(opt=="lor"){
            gtn(pos,con[line],&flag,[](int x,int y){return (int)(x||y);});
            line++;
        }else if(opt=="rint"){
			pos++;
			if((con[line])[4]==';')cin >> val;
			else cin >> *gt(con[line].substr(pos,siz-pos));
			line++;
		}else if(opt=="rch"){
			pos++;
			char c;
			cin >> c;
			if((con[line])[3]==';')val=c;
			else*gt(con[line].substr(pos,siz-pos))=c;
			line++;
		}else if(opt=="wint"){
			pos++;
			if((con[line])[4]==';')cout << val;
			else cout << *gt(con[line].substr(pos,siz-pos));
			line++;
		}else if(opt=="wch"){
			pos++;
			if((con[line])[4]==';')cout << (char)val;
			else cout << (char)*gt(con[line].substr(pos,siz-pos));
			line++;
		}else if(opt=="function"){
			string name=con[line].substr(10,siz-11);
			Line=line++;
		}else if(opt=="callfunc"){
			string name=con[line].substr(10,siz-11);
			saddr.emplace(line+1,Line);
			line=funToLine[name];
		}
	}
    return 0;
}
```

---

## 作者：NGC_4889 (赞：1)

## 题解
&emsp;&emsp;无可争议的**大模拟题**。~~写到吐。~~ 题目中附件定义了具体的汇编语言格式，如果不嫌麻烦，一个一个地实现它们，就可以了，具体的实现细节就不逐一介绍了。这里简要介绍一下我自己实现过程中**简化代码的方法**和遇到的**坑点**。
#### （1）语句参数的统一处理
&emsp;&emsp;汇编语言中可能涉及到几种不同类型的参数，如常量、编译器常量、寄存器、内存等等。如果每执行一个汇编语句，都要分多种情形处理参数，未免太过繁琐。为了统一对参数的处理，可以定义一个参数类 `struct Arg` ，定义如下：
```cpp
struct Arg {
	int type;	// 参数类型, 0: 常量 1: 寄存器 2: 固定位置内存 3: 寄存器位置内存
	int v;		// 获取参数值的辅助信息
	
	// 获取参数的值
	int getV() {
		if (type == 0)	return v;
		else if (type == 1) return reg[v];
		else if (type == 2)	return mem[v];
		return mem[reg[v]];
	} 
	
	// 设置参数的值
	void setV(int a) {
		if (type == 1) reg[v] = a;
		else if (type == 2) mem[v] = a;
		else mem[reg[v]] = a;
	}
}; 
```
通过两个成员函数 `setV` 和 `getV` 统一处理不同类型参数的赋值操作和取值操作。
#### （2）查表优化
&emsp;&emsp;题目中需要用到 $12$ 个寄存器，我们开一个寄存器数组 `reg[15]` ，数组下标 $1-12$ 的位置分别存储这些寄存器的值。读入指令时，从中提取出表示寄存器的字符串，通过查表法，迅速获取寄存器在 `reg` 中的下标。对应的表的定义如下：
```cpp
unordered_map<string, int> regType{{"R1", 1}, {"R2", 2}, {"R3", 3}, {"R4", 4}, {"E1", 5}, {"E2", 6}, 
								   {"E3", 7}, {"E4", 8}, {"FLAG", 9}, {"VAL", 10}, {"LINE", 11}, {"RET", 12}};
```
类似地，给出一条指令的名称，我们也可以通过查表法迅速获取一条指令的操作码（编号 $0-31$），表的定义如下：
```cpp
unordered_map<string, int> insType{{"UDEF", 0}, {"HLT", 1}, {"NOP", 2}, {"SET", 3}, {"JMP", 4}, {"JIF", 5}, {"CALL", 6},
								   {"RET", 7}, {"INV", 8}, {"ADD", 9}, {"SUB", 10}, {"MULT", 11}, {"IDIV", 12}, {"MOD", 13},
								   {"LSFT", 14}, {"RSFT", 15}, {"BAND", 16}, {"BOR", 17}, {"BXOR", 18}, {"LGR", 19},
								   {"LLS", 20}, {"LGE", 21}, {"LLE", 22}, {"LEQL", 23}, {"LAND", 24}, {"LOR", 25}, {"RINT", 26},
								   {"RCH", 27}, {"WINT", 28}, {"WCH", 29}, {"FUNCTION", 30}, {"CALLFUNC", 31}};
```
此外，当汇编语句开始模拟执行时，我们可以通过指令的操作码，从对应的函数指针数组中快速找到对应的执行函数，函数指针数组的定义如下：
```cpp
using pFunc = void (*)(vector<Arg>& );

pFunc exec[32] = {Ins_UDEF, Ins_HLT, Ins_NOP, Ins_SET, Ins_JMP, Ins_JIF, Ins_CALL, Ins_RET, Ins_INV, Ins_ADD,
				  Ins_SUB, Ins_MULT, Ins_IDIV, Ins_MOD, Ins_LSFT, Ins_RSFT, Ins_BAND, Ins_BOR, Ins_BXOR, Ins_LGR,
				  Ins_LLS, Ins_LGE, Ins_LLE, Ins_LEQL, Ins_LAND, Ins_LOR, Ins_RINT, Ins_RCH, Ins_WINT, Ins_WCH,
				  Ins_FUNCTION, Ins_CALLFUNC};
```
通过上述这些查表优化，我们就省去了许多条件判断，降低了程序复杂度。
#### （3）个别指令的延迟处理
&emsp;&emsp;在我实现的程序中，对于指令的解析、注释的删除是**边输入边处理**的，每读入一行，就立即删除注释，把指令解析好，然后再读取下一行。然而，个别指令无法在线处理，比如， `CALLFUNC` 指令，该指令需要调用一个函数，处理该指令时，需要用到函数所在的行的信息。而调用的函数可能在 `CALLFUNC` 指令的后面才有定义，需要全部读取完输入数据才能确定该函数所在的行数。因此，该指令需要进行**延迟处理**。具体地，每读到一条 `CALLFUNC` 指令，将其加入一队列中，待 $N$ 行程序全部读完，再逐一处理它们。
#### （4）遇到的坑
1. 输入数据时，使用 `scanf` 读取 $N$ 后，正式读取汇编程序前，要额外加一句 `fgets`，吃掉行尾的换行符。
2. 注意**常量**有可能是**负数**，所以解析参数遇到负号 `'-'` 要特判一下。
3. 寄存器的名称中可能含有**数字**，如 `R1`，`E4` 等，解析参数时不能遇到非字母字符就中止了。
4. 打表时，不要把表中的指令的字母拼错。
5. 注意区分左移 `<<` 和右移 `>>` ······（谁能想到这是我debug过程中花费时间最长才发现的错误呢？T_T）

#### （5）代码实现
&emsp;&emsp;附上（不太会有人看的）代码实现如下：

```cpp
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <string>
#include <unordered_map>

using std::vector;
using std::string;
using std::unordered_map;

unordered_map<string, int> regType{{"R1", 1}, {"R2", 2}, {"R3", 3}, {"R4", 4}, {"E1", 5}, {"E2", 6}, 
								   {"E3", 7}, {"E4", 8}, {"FLAG", 9}, {"VAL", 10}, {"LINE", 11}, {"RET", 12}};

unordered_map<string, int> insType{{"UDEF", 0}, {"HLT", 1}, {"NOP", 2}, {"SET", 3}, {"JMP", 4}, {"JIF", 5}, {"CALL", 6},
								   {"RET", 7}, {"INV", 8}, {"ADD", 9}, {"SUB", 10}, {"MULT", 11}, {"IDIV", 12}, {"MOD", 13},
								   {"LSFT", 14}, {"RSFT", 15}, {"BAND", 16}, {"BOR", 17}, {"BXOR", 18}, {"LGR", 19},
								   {"LLS", 20}, {"LGE", 21}, {"LLE", 22}, {"LEQL", 23}, {"LAND", 24}, {"LOR", 25}, {"RINT", 26},
								   {"RCH", 27}, {"WINT", 28}, {"WCH", 29}, {"FUNCTION", 30}, {"CALLFUNC", 31}};

unordered_map<string, int> funcLoc;

int sp, stk[1 << 22], mem[1 << 24], reg[15];
int N, pc, rp, rcnt, rList[500005], lineStart[100005];
char buf[10005];
bool notefg = 0;	// 标识当前内容是否在注释中 

// 参数 
struct Arg {
    int type;	// 0: constant 1: % 2: @ 3: @%
    int v;
    
    int getV() {
    	if (type == 0)	return v;
    	else if (type == 1) return reg[v];
    	else if (type == 2)	return mem[v];
    	return mem[reg[v]];
    } 
    
    void setV(int a) {
    	if (type == 1) reg[v] = a;
    	else if (type == 2) mem[v] = a;
    	else mem[reg[v]] = a;
    }
}; 

void Ins_UDEF(vector<Arg>& arg) { exit(0); }

void Ins_HLT(vector<Arg>& arg) { exit(0); }

void Ins_NOP(vector<Arg>& arg) { ++pc; }

void Ins_SET(vector<Arg>& arg) { ++pc; arg[1].setV(arg[0].getV()); }

void Ins_JMP(vector<Arg>& arg) {
	pc = lineStart[reg[11] + arg[0].getV()];
}

void Ins_JIF(vector<Arg>& arg) {
	++pc;
	if (arg[1].getV()) pc = lineStart[reg[11] + arg[0].getV()];
}

void Ins_CALL(vector<Arg>& arg) {
	++pc;
	stk[++sp] = pc;
	stk[++sp] = reg[11];
	pc = lineStart[arg[0].getV()];
}

void Ins_RET(vector<Arg>& arg) {
	if (arg.size() > 0) reg[12] = arg[0].getV();
	reg[11] = stk[sp--];
	pc = stk[sp--];
}

void Ins_INV(vector<Arg>& arg) { ++pc; arg[1].setV(-arg[0].getV());}

void Ins_ADD(vector<Arg>& arg) { ++pc; arg[2].setV(arg[0].getV() + arg[1].getV());}

void Ins_SUB(vector<Arg>& arg) { ++pc; arg[2].setV(arg[0].getV() - arg[1].getV());}

void Ins_MULT(vector<Arg>& arg) { ++pc; arg[2].setV(arg[0].getV() * arg[1].getV());}

void Ins_IDIV(vector<Arg>& arg) { ++pc; arg[2].setV(arg[0].getV() / arg[1].getV());}

void Ins_MOD(vector<Arg>& arg) { ++pc; arg[2].setV(arg[0].getV() % arg[1].getV());}

void Ins_LSFT(vector<Arg>& arg) { ++pc; arg[2].setV(arg[0].getV() << arg[1].getV());}

void Ins_RSFT(vector<Arg>& arg) { ++pc; arg[2].setV(arg[0].getV() >> arg[1].getV());}

void Ins_BAND(vector<Arg>& arg) { ++pc; arg[2].setV(arg[0].getV() & arg[1].getV());}

void Ins_BOR(vector<Arg>& arg) { ++pc; arg[2].setV(arg[0].getV() | arg[1].getV());}

void Ins_BXOR(vector<Arg>& arg) { ++pc; arg[2].setV(arg[0].getV() ^ arg[1].getV());}

void Ins_LGR(vector<Arg>& arg) { ++pc; arg[2].setV(arg[0].getV() > arg[1].getV());}

void Ins_LLS(vector<Arg>& arg) { ++pc; arg[2].setV(arg[0].getV() < arg[1].getV());}

void Ins_LGE(vector<Arg>& arg) { ++pc; arg[2].setV(arg[0].getV() >= arg[1].getV());}

void Ins_LLE(vector<Arg>& arg) { ++pc; arg[2].setV(arg[0].getV() <= arg[1].getV());}

void Ins_LEQL(vector<Arg>& arg) { ++pc; arg[2].setV(arg[0].getV() == arg[1].getV());}

void Ins_LAND(vector<Arg>& arg) { ++pc; arg[2].setV(arg[0].getV() && arg[1].getV());}

void Ins_LOR(vector<Arg>& arg) { ++pc; arg[2].setV(arg[0].getV() || arg[1].getV());}

void Ins_RINT(vector<Arg>& arg) { ++pc; arg[0].setV(rList[rp++]);}

void Ins_RCH(vector<Arg>& arg) { ++pc; arg[0].setV(rList[rp++]);}

void Ins_WINT(vector<Arg>& arg) { ++pc; printf("%d", arg[0].getV());}

void Ins_WCH(vector<Arg>& arg) { ++pc; putchar(arg[0].getV()); }

void Ins_FUNCTION(vector<Arg>& arg) { ++pc; arg[1].setV(arg[0].getV()); }

void Ins_CALLFUNC(vector<Arg>& arg) { 
	++pc; 
	stk[++sp] = pc;
	stk[++sp] = reg[11];
	pc = arg[0].getV();
}

using pFunc = void (*)(vector<Arg>& );

pFunc exec[32] = {Ins_UDEF, Ins_HLT, Ins_NOP, Ins_SET, Ins_JMP, Ins_JIF, Ins_CALL, Ins_RET, Ins_INV, Ins_ADD,
				  Ins_SUB, Ins_MULT, Ins_IDIV, Ins_MOD, Ins_LSFT, Ins_RSFT, Ins_BAND, Ins_BOR, Ins_BXOR, Ins_LGR,
				  Ins_LLS, Ins_LGE, Ins_LLE, Ins_LEQL, Ins_LAND, Ins_LOR, Ins_RINT, Ins_RCH, Ins_WINT, Ins_WCH,
				  Ins_FUNCTION, Ins_CALLFUNC};

struct Instruction {
	int type;
	vector<Arg> arg;
	
	void run() { exec[type](arg); }
	
} ins[55005];

int insp;

void passSpace(char*& p) {
	while (*p && isspace(*p)) ++p;
}

void passNote(char*& p) {
	if (!notefg) return;
	while (*p && *p != ']') ++p;
	if (*p == ']') notefg = 0, ++p;
}

int findEffCon(char*& p) {
    int fg = 0;		// 跳过的非注释内容中, 不包括逗号和分号(0)，包括逗号(1)，包括分号(2); 
    passNote(p);
    while (*p) {
        if (isspace(*p)) passSpace(p);
        if (*p == '[') {
        	notefg = 1;
        	++p;
        	passNote(p);
        }
        if (*p == ']') ++p;
        if (*p == ',') ++p, fg = 1;
        if (*p == ';') ++p, fg = 2;
        if (isalpha(*p) || isdigit(*p) || *p == '%' || *p == '@' || *p == '#' || *p == '$') break;
    }
    return fg;
}


int getInsType(char*& p) {
    string s = "";
    while (isalpha(*p)) 
    	s += (char)toupper(*p), ++p;
    return insType[s];
}

Arg getInsArg(char*& p, int L) {
    int type, v;
    string s = "";
    if (isdigit(*p) || *p == '-') {
        int fg = (*p == '-' ? -1 : 1);
        type = v = 0; 
        while (isdigit(*p))
            v = v * 10 + *p - '0', ++p;
        v *= fg;
    } else if (*p == '#') {
        type = 0;
        v = L;
        ++p;
        while (isalpha(*p)) ++p;
    } else if (*p == '%') {
        type = 1;
        ++p;
        while (isalpha(*p) || isdigit(*p)) 
            s += (char)toupper(*p), ++p;
        v = regType[s];
    } else if (*p == '@') {
        ++p;	
        if (*p == '%') {
            type = 3; ++p;
            while (isalpha(*p) || isdigit(*p)) 
            s += (char)toupper(*p), ++p;
            v = regType[s];
        } else {
            type = 2;
            v = 0;
            while (isdigit(*p))
                v = v * 10 + *p - '0', ++p;
        }
    }
    return (Arg){type, v};
} 

string getFunName(char*& p) {
    string s = "";
    if (*p != '$') return s;
    s += *p;
    ++p;
    while (isalpha(*p) || isdigit(*p)) 
    	s += *p, ++p;
    return s;
}

void input() {
    notefg = 0;
    scanf("%d", &N);
    fgets(buf, 10002, stdin);
    
    vector<std::pair<int, string>> q;
    for (int i = 1; i <= N; ++i) {
    	fgets(buf, 10002, stdin);
    	
    	char* p = buf;
    	findEffCon(p);
    	while (*p) {
            int type = getInsType(p);
            ++insp;
            ins[insp].type = type;
            if (lineStart[i] == 0) lineStart[i] = insp;
            
            if (type == 7) ins[insp].arg.emplace_back((Arg){1, 12});
            if (type >= 26 && type <= 29) ins[insp].arg.emplace_back((Arg){1, 10});
            
            while (!findEffCon(p)) {
                if (type == 3) {
                	ins[insp].arg.emplace_back(getInsArg(p, i));
                	findEffCon(p);
                	ins[insp].arg.emplace_back(getInsArg(p, i));
                } else if (type == 4 || type == 6) {
                	ins[insp].arg.emplace_back(getInsArg(p, i));
                } else if (type == 5) {
                	ins[insp].arg.emplace_back(getInsArg(p, i));
                	if (findEffCon(p) == 2) {
                		ins[insp].arg.emplace_back((Arg){1, 9});
                		break;
                	}
                	ins[insp].arg.emplace_back(getInsArg(p, i));
                } else if (type == 7) {
                	ins[insp].arg.pop_back();
                	ins[insp].arg.emplace_back(getInsArg(p, i));
                } else if (type == 8) {
                	ins[insp].arg.emplace_back(getInsArg(p, i));
                	if (findEffCon(p) == 2) {
                		ins[insp].arg.emplace_back((Arg){1, 10});
                		break;
                	}
                	ins[insp].arg.emplace_back(getInsArg(p, i));
                } else if (type >= 9 && type <= 18) {
                	ins[insp].arg.emplace_back(getInsArg(p, i));
                	findEffCon(p);
                	ins[insp].arg.emplace_back(getInsArg(p, i));
                	if (findEffCon(p) == 2) {
                		ins[insp].arg.emplace_back((Arg){1, 10});
                		break;
                	}
                	ins[insp].arg.emplace_back(getInsArg(p, i));
                } else if (type >= 19 && type <= 25) {
                	ins[insp].arg.emplace_back(getInsArg(p, i));
                	findEffCon(p);
                	ins[insp].arg.emplace_back(getInsArg(p, i));
                	if (findEffCon(p) == 2) {
                		ins[insp].arg.emplace_back((Arg){1, 9});
                		break;
                	}
                	ins[insp].arg.emplace_back(getInsArg(p, i));
                } else if (type >= 26 && type <= 29) {
                	ins[insp].arg.pop_back();
                	ins[insp].arg.emplace_back(getInsArg(p, i));
                } else if (type == 30) {
                	funcLoc[getFunName(p)] = insp;
                	ins[insp].arg.emplace_back((Arg){0, i});
                	ins[insp].arg.emplace_back((Arg){1, 11});
                } else if (type == 31) {
                	q.emplace_back(make_pair(insp, getFunName(p)));
                }
            }
    	}
    }
    for (auto& [pos, s] : q) {
    	ins[pos].arg.emplace_back((Arg){0, funcLoc[s]});
    }
    
    while (scanf("%d", rList + rcnt) == 1) ++rcnt;
}

int main() {
    pc = 1; 
    rp = rcnt = insp = 0;
    
    input();
    
    while (1) ins[pc].run();
    
    return 0;
}
```

---

## 作者：Exschawasion (赞：1)

Update at June 30th

这道题目最重要的就是**实现指令的操作**

然后实现操作离不开**变量与内存系统**。

所以我们必须先实现**内存系统**，然后才能够进行下一步的工作。

=====正文分割线=====

## 1.内存系统

内存系统中包含寄存器，这个相对好模拟，直接**使用变量**保存即可

还包含许多内存单元，而且有地址，这时我们用一个**数组**来充当就行了

具体来说，在访问变量时我们要判断是什么类型的变量：

- 如果是**常量**就直接返回；

- 如果是**内存地址**就去数组里找对应的值；

- 如果是**寄存器**就去取对应的变量，这里我用了 12 个 ```if``` 语句去逐一判断；

- 如果是 ```@%``` 开头的，就分步计算：先找寄存器，再找内存。

有一些细节（比如编译期常量 ```#line```）需要注意去实现，可参见代码。

## 2.指令系统

指令还行，按照题目意思去模拟即可，算术指令代码量大，好在思维难度不高

**判断第一个字符串**就可以知道是什么类型的指令了，然后按照上面所说的方式去获取操作数

另外：

注意判断操作数个数

注意判断操作数个数！

**注意判断操作数个数！！！**

很容易在这里卡住（事实上我就是这样），因为如果操作数不够要把运行结果放到 ```%val``` 寄存器当中。

然后比较难的就是**调用** ```call``` 和**跳转** ```jmp``` 指令

怎么办呢？

其实可以使用一个额外的变量 ```line``` 来代表“当前运行到程序的哪一行”，这样就顺手解决了 ```#line``` 常量的问题。

```call``` 指令还需要实现一个**调用栈**

**什么？不知道什么是调用栈？？？**

。。。。。。看过来，下面是简单的解释：

在一个线程中（可能不是很严谨，望包涵），同一时刻只能有一个函数在运行

也就是 CPU 控制权是在这个函数的栈帧上的，

然后呢，这个函数运行完之后，CPU 控制权会回到这个函数的调用者身上

所以说，每调用一层函数，控制权就会到这个函数身上；

然后调用完，回到调用者身上

**这不就是一个先进后出的栈吗？**

在本道题中就是使用栈保存当前 ```line``` 的值

每次返回都弹出栈顶

总之，调用 ```call``` 时调用栈 push；返回时调用栈 pop，解决。

## 3. 读取系统

读取时我们可以直接忽略注释

当检测到**没有闭合的中括号** ```[]``` 时就**只读入字符不送进指令流**

在专业的代码编译 / 解释器中（比如浏览器的 HTML 解析），运行方式如下：

- 先把代码词法分析（tokenize）成许多的 token

- 然后送进一个 token 流（token stream）

- 然后建立语法树，叫做语法分析

- 最后送给编译器编译 / 虚拟机执行

本道题我们实现的就是一个虚拟机，执行字节码（bytecode）

我们忽略所有的空白，包括注释在内，运行时就不用去特判了

其实如果开发过语言解释器或者编译器的话，相对比较容易理解。

 _（但是开发解释器真的很不容易……亲身经历）_ 
 
 =====分割线=====
 
**关键代码如下**，想找完整源代码可以戳[剪贴板传送门](https://www.luogu.com.cn/paste/b2oa1k2z)
 
 
```
//这是一个运行指令的函数
...
	String type = tokens[0];
	if(type == "set") {
		setval(tokens[1], expression(tokens[2]));
		line++;
	}
	else if(type == "rint") {
		int x;
		cin >> x;
		if(opcnt == 1) setval("%val", x);
		else setval(tokens[1], x);
		line++;
	}
	else if(type == "rch") {
		char x;
		cin >> x;
		if(opcnt == 1) setval("%val", x);
		else setval(tokens[1], x);
		line++;
	}
	else if(type == "wint") {
		if(opcnt == 1) cout << expression("%val");
		else cout << expression(tokens[1]);
		line++;
	}
	else if(type == "wch") {
		if(opcnt == 1) cout << (char)expression("%val");
		else cout << (char)expression(tokens[1]);
		line++;
	}
	else if(type == "Warfarin") {
		cout << "っ！おい！何をしている……" << endl;
		line++;
	}
	else if(type == "Ptilopsis") {
		cout << "エラー発生。" << endl;
		line++;
	}
	else if(type == "inv") {
		int ans = !expression(tokens[1]); 
		if(opcnt == 2) setval("%val", ans);
		else setval(tokens[2], ans);
		line++;
	}
	else if(type == "add") {
		int ans = expression(tokens[1]) + expression(tokens[2]); 
		if(opcnt == 3) setval("%val", ans);
		else setval(tokens[3], ans);
		line++;
	}
	else if(type == "sub") {
		int ans = expression(tokens[1]) - expression(tokens[2]); 
		if(opcnt == 3) setval("%val", ans);
		else setval(tokens[3], ans);
		line++;
	}
	else if(type == "mult") {
		int ans = expression(tokens[1]) * expression(tokens[2]); 
		if(opcnt == 3) setval("%val", ans);
		else setval(tokens[3], ans);
		line++;
	}
	else if(type == "idiv") {
		int ans = expression(tokens[1]) / expression(tokens[2]); 
		if(opcnt == 3) setval("%val", ans);
		else setval(tokens[3], ans);
		line++;
	}
	else if(type == "mod") {
		int ans = expression(tokens[1]) % expression(tokens[2]); 
		if(opcnt == 3) setval("%val", ans);
		else setval(tokens[3], ans);
		line++;
	}
	else if(type == "lsft") {
		int ans = expression(tokens[1]) << expression(tokens[2]); 
		if(opcnt == 3) setval("%val", ans);
		else setval(tokens[3], ans);
		line++;
	}
	else if(type == "rsft") {
		int ans = expression(tokens[1]) >> expression(tokens[2]); 
		if(opcnt == 3) setval("%val", ans);
		else setval(tokens[3], ans);
		line++;
	}
	else if(type == "band") {
		int ans = expression(tokens[1]) & expression(tokens[2]); 
		if(opcnt == 3) setval("%val", ans);
		else setval(tokens[3], ans);
		line++;
	}
	else if(type == "bor") {
		int ans = expression(tokens[1]) | expression(tokens[2]); 
		if(opcnt == 3) setval("%val", ans);
		else setval(tokens[3], ans);
		line++;
	}
	else if(type == "bxor") {
		int ans = expression(tokens[1]) xor expression(tokens[2]); 
		if(opcnt == 3) setval("%val", ans);
		else setval(tokens[3], ans);
		line++;
	}
	else if(type == "lgr") {
		int ans = expression(tokens[1]) > expression(tokens[2]); 
		if(opcnt == 3) setval("%flag", ans);
		else setval(tokens[3], ans);
		line++;
	}
	else if(type == "lls") {
		int ans = expression(tokens[1]) < expression(tokens[2]); 
		if(opcnt == 3) setval("%flag", ans);
		else setval(tokens[3], ans);
		line++;
	}
	else if(type == "lge") {
		int ans = expression(tokens[1]) >= expression(tokens[2]); 
		if(opcnt == 3) setval("%flag", ans);
		else setval(tokens[3], ans);
		line++;
	}
	else if(type == "lle") {
		int ans = expression(tokens[1]) <= expression(tokens[2]); 
		if(opcnt == 3) setval("%flag", ans);
		else setval(tokens[3], ans);
		line++;
	}
	else if(type == "leql") {
		int ans = expression(tokens[1]) == expression(tokens[2]); 
		if(opcnt == 3) setval("%flag", ans);
		else setval(tokens[3], ans);
		line++;
	}
	else if(type == "land") {
		int ans = expression(tokens[1]) && expression(tokens[2]); 
		if(opcnt == 3) setval("%flag", ans);
		else setval(tokens[3], ans);
		line++;
	}
	else if(type == "lor") {
		int ans = expression(tokens[1]) || expression(tokens[2]); 
		if(opcnt == 3) setval("%flag", ans);
		else setval(tokens[3], ans);
		line++;
	}
	else if(type == "callfunc") {
		String func = CUT(tokens[1]);
		callFunc(func);
	}
	else if(type == "jmp") {
		line = funcline[callstack.top()];
		line = line + expression(tokens[1]);
	}
	else if(type == "jif") {
		bool condition;
		if(opcnt == 2) condition = getval("%flag");
		else condition = expression(tokens[2]);
		if(condition) {
			line = funcline[callstack.top()];
			line = line + expression(tokens[1]);
		}
		else line++;
	}
	else if(type == "ret") {
		if(opcnt == 2) setval("%ret", expression(tokens[1]));
		return false;
	} 
	else if(type == "hlt") {
		exit(0);
		line++;
	}
	else line++;
...
```
最后，给那些想了解解释器、编译器、虚拟机等的oier们安利一下[WarfarinBloodanger 博客](https://www.luogu.com.cn/blog/Warfarin/#)哦

求通过~

---


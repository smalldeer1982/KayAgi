# 树上后缀排序

## 题目描述

给定一棵以 $1$ 为根包含 $n$ 个节点的树，保证对于 $2 \sim n$ 的每个节点，其父亲的编号均小于自己的编号。

每个节点上有一个的字符，一个节点所代表的字符串定义为从当前节点一直到根节点的简单路径上经过的所有字符连起来形成的字符串。

请你给这些字符串按照字典序排序。

特别地，如果两个节点所代表的字符串完全相同，它们的大小由它们父亲排名的大小决定，即谁的父亲排名大谁就更大；如果仍相同，则由它们编号的大小决定，即谁的编号大谁就更大。

## 说明/提示

对于 $20\%$ 的数据，$n \le 10 ^ 3$。

对于 $50\%$ 的数据，$n \le 10 ^ 5$。

对于 $100\%$ 的数据，$1 \le n \le 5 \times 10 ^ 5$。

## 样例 #1

### 输入

```
5
1 1 3 2
abbaa```

### 输出

```
1 5 4 2 3```

# 题解

## 作者：xht (赞：24)

题目地址：[【模板】树上后缀排序](https://www.luogu.org/problemnew/show/P5353)

我们尝试把普通 SA 改成树上 SA，所以先把普通 SA 贴上来。

```cpp
namespace SA {
    int sa[N], rk[N], tp[N], tx[N];
    
    inline void tsort() {
        for (int i = 1; i <= m; i++) tx[i] = 0;
        for (int i = 1; i <= n; i++) ++tx[rk[i]];
        for (int i = 1; i <= m; i++) tx[i] += tx[i-1];
        for (int i = n; i; i--) sa[tx[rk[tp[i]]]--] = tp[i];
    }

    inline bool pd(int i, int w) {
        return tp[sa[i-1]] == tp[sa[i]] && tp[sa[i-1]+w] == tp[sa[i]+w];
    }

    inline void main() {
        for (int i = 1; i <= n; i++) rk[i] = s[i] - 'a' + 1, tp[i] = i;
        tsort();
        for (int w = 1, p = 0; p < n; w <<= 1, m = p) {
            p = 0;
            for (int i = 1; i <= w; i++) tp[++p] = n - w + i;
            for (int i = 1; i <= n; i++) if (sa[i] > w) tp[++p] = sa[i] - w;
            tsort(), swap(rk, tp), rk[sa[1]] = p = 1;
            for (int i = 2; i <= n; i++) rk[sa[i]] = pd(i, w) ? p : ++p;
        }
    }
}
```

想要把普通 SA 改成树上 SA，仔细观察上面的代码可以发现：

1. $tsort$ 函数肯定是不用改的；
2. $pd$ 函数可以用树上倍增实现；
3. $main$ 函数似乎也很好改？

于是开始改改改，突然发现有个问题：**由于序列上每个后缀长度都不一样，所以不可能出现完全相同的字符串，可是在树上是可能出现这种情况的。**

然后就没办法了么？

办法肯定是有的~~要不然这道题是咋出出来的~~。

我们来思考一下，在倍增的每一轮，**基数排序**究竟要达到什么目的？

对于普通 SA，在倍增的每一轮，假设已经对所有长度为 $x$ 的串排好序了。“第一关键字”和“第二关键字”代表了两个首尾相接的长度为 $x$ 的串，称为“主串”和“次串”。基数排序通过 $O(n)$ 的时间，将每一对“主串”和“次串”**合并**成一个长度为 $2x$ 的新串并保持合并后**有序**。

这样可以保证 $O(\log n)$ 次后，所有后缀呈有序状态。

对于树上 SA，也是同样的。只不过，除了“主串”作为第一关键字，“次串”作为第二关键字以外，为了保证合并后的有序性，我们还要额外将上一轮的有序状态作为第三关键字。同时第二关键字也不能简单地用原先的 $rk$ 数组构造（因为 $rk$ 数组会出现相同的排名），而要额外使用没有重复的数组（下面代码中的 $rkk$ 数组）构造。

总而言之，我们需要使用两次基数排序来达到目的，具体实现请参考代码~~因为这说得实在是太抽象了~~：

```cpp
namespace SA {
    int sa[N], rk[N], rkk[N], tp[N], rk2[N], tx[N];

    inline void tsort(int *sa, int *rk, int *tp, int m) {
        for (int i = 0; i <= m; i++) tx[i] = 0;
        for (int i = 1; i <= n; i++) ++tx[rk[i]];
        for (int i = 1; i <= m; i++) tx[i] += tx[i-1];
        for (int i = n; i; i--) sa[tx[rk[tp[i]]]--] = tp[i];
    }

    inline bool pd(int i, int t) {
        return tp[sa[i-1]] == tp[sa[i]] && tp[f[t][sa[i-1]]] == tp[f[t][sa[i]]];
    }

    inline void main() {
        int p = 0;
        for (int i = 1; i <= n; i++) a[i] = s[i] - 'a' + 1, tp[i] = i;
        tsort(sa, a, tp, n);
        rk[sa[1]] = rkk[sa[1]] = p = 1;
        for (int i = 2; i <= n; i++) {
            rk[sa[i]] = a[sa[i-1]] == a[sa[i]] ? p : ++p;
            rkk[sa[i]] = i;
        }
        for (int w = 1, t = 0; w < n; w <<= 1, ++t) {
            for (int i = 1; i <= n; i++) rk2[i] = rkk[f[t][i]];
            tsort(tp, rk2, sa, n);
            tsort(sa, rk, tp, p);
            swap(rk, tp);
            rk[sa[1]] = rkk[sa[1]] = p = 1;
            for (int i = 2; i <= n; i++) {
                rk[sa[i]] = pd(i, t) ? p : ++p;
                rkk[sa[i]] = i;
            }
        }
    }
}
```

---

## 作者：Ireliaღ (赞：14)

## 后缀平衡树

很多人说它是在线的后缀数组，其实我感觉它的功能不止于此。

### 前置知识

替罪羊树

### 原理

后缀平衡树是一个以字典序为关键字的有序字符串集$X$，它可以资瓷两种复杂度为$O(\log n)$的操作：

- 向字符串集中加入一个长度为$1$的字符串$S$

- 向字符串集中加入字符串$xS$，其中$S \in X$

所以，如果对一个字符串逆序执行插入操作，它就是严格的“后缀平衡树”，它的中序遍历也就是后缀数组。但其实上，观察这两个操作，它完全可以维护一个有根树森林。

### 实现

两种插入操作完全可以视为一种。我们考虑要加入一个字符串$xS$，我们要做的就是从根开始与当前节点进行比较，然后进入左/右儿子，直到找到一个空位为止。现在的问题就是，如何比较要插入的字符串和节点上的字符串。

显然我们不能$O(n)$暴力比较。考虑到要插入的字符串$xS$，除去第一个字母之后的$S$已经在树中，并且树是有序的。那么当第一个字符相同时，我们完全可以利用这棵树进行$O(\log n)$比较后面的部分，这样的话，插入操作时$O(\log ^ 2 n)$的。

考虑如何进行$O(1)$比较，来做到单次操作是$O(\log n)$。我们对于每个节点维护一个$key$值代表在树中的相对位置。具体方法是：选取一个很大的值域，每次进入下一层时根据左右儿子将值域折半，最终节点的值就是当前值域的$mid$值。当需要比较两个已经在树中的字符串时，直接比较$key$值即可，复杂度$O(1)$。

对于如何维护平衡，最简单的方法就是使用替罪羊树，注意在重构时要重新赋key值。

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;
const int MAXN = 1e6 + 5;
const double LIM = 1e16;
const float Alpha = 0.7;

int n;
char S[MAXN];
int fa[MAXN];
int rk[MAXN], sa[MAXN];

namespace SufTree{
	double val[MAXN];
	int siz[MAXN];
	int ch[MAXN][2];
	int tr[MAXN], cnt;
	int rt;
	
	void Update(int x) {
		siz[x] = 1 + siz[ch[x][0]] + siz[ch[x][1]];
	}
	
	int Bad(int x) {
		return 1.0 * siz[ch[x][0]] > Alpha * siz[x] || 1.0 * siz[ch[x][1]] > Alpha * siz[x];
	}
	
	int Comp(int x, int y) {
		return S[x] < S[y] || (S[x] == S[y] && val[fa[x]] < val[fa[y]]);
	}
	
	void Pia(int x) {
		if (!x) return;
		Pia(ch[x][0]);
		tr[++cnt] = x;
		Pia(ch[x][1]);
		ch[x][0] = ch[x][1] = 0;
	}
	
	void Rebuild(int &x, int l, int r, double lv, double rv) {
		if (l > r) return;
		int mid = (l + r) >> 1;
		double midv = (lv + rv) / 2;
		x = tr[mid];
		val[x] = midv;
		Rebuild(ch[x][0], l, mid - 1, lv, midv);
		Rebuild(ch[x][1], mid + 1, r, midv, rv);
		Update(x);
	}
	
	void Maintain(int &x, double lv, double rv) {
		if (Bad(x)) {
//			cerr << "*" << x;
			cnt = 0;
			Pia(x);
			Rebuild(x, 1, cnt, lv, rv);
		}
	}
	
	void Insert(int &x, int idx, double lv, double rv) {
		if (!x) {
			x = idx;
			siz[x] = 1;
			ch[x][0] = ch[x][1] = 0;
			val[x] = (lv + rv) / 2;
			return;
		}
		if (Comp(idx, x)) Insert(ch[x][0], idx, lv, val[x]);
		else Insert(ch[x][1], idx, val[x], rv);
		Update(x);
		Maintain(x, lv, rv);
	}
	
	void Calc(int x) {
		if (!x) return;
		Calc(ch[x][0]);
		sa[++cnt] = x;
		Calc(ch[x][1]);
	}
	
	void Build() {
		for (int i = 1; i <= n; i++) {
			Insert(rt, i, 1, LIM);
		}
		cnt = 0;
		Calc(rt);
		for (int i = 1; i <= n; i++) rk[sa[i]] = i;
	}
}

int main() {
	scanf("%d", &n);
	for (int i = 2; i <= n; i++) scanf("%d", fa + i);
	scanf("%s", S + 1);
	SufTree::Build();
	for (int i = 1; i <= n; i++) printf("%d ", sa[i]);
	return 0;
}
/*
10 5
S 0
Y 1
R 2
E 3
N 4
E 5
A 6
D 7
Y 7
R 9
RY
E
N
S
AY
*/
  
```

---

## 作者：mrsrz (赞：10)

倍增后缀排序+哈希即可。

首先确保你会倍增后缀排序。

然后，这题放在了树上，实际上没什么区别，只需要预处理一下树上倍增数组，然后像原来一样，每次把排序用关键字长度扩大一倍，基数排序即可。

重点在于如何解决重复的问题。

在后缀数组上，重复的串显然是连续的一段区间。由于题目已经给出了比较方式，我们直接把所有区间找出来，然后分别```sort```一遍即可。由于排序需要用到父亲的```rank```信息，所以我们先对长度较小（深度较浅）的节点排序，然后更新一下```rank```数组的值即可。

如何快速判断两个串是否相等？不难想到用哈希。

至此问题解决了。时空复杂度均为$O(n\log n)$。

## Code：
```cpp
#include<iostream>
#include<vector>
#include<utility>
#include<algorithm>
using namespace std;
typedef long long LL;
const int N=5e5+5,base1=20041001,base2=20040607,md1=167772161,md2=104857601;
int n,F[19][N],head[N],cnt,dep[N],x[N],y[N],c[N],sa[N],hx1[N],hx2[N];
char s[N];
vector<int>vec[N],vd[N];
vector<pair<int,int>>pd[N];
struct edge{
	int to,nxt;
}e[N];
void dfs(int now){
	hx1[now]=((LL)hx1[F[0][now]]*base1+s[now])%md1,hx2[now]=((LL)hx2[F[0][now]]*base2+s[now])%md2;
	for(int i=head[now];i;i=e[i].nxt)dep[e[i].to]=dep[now]+1,F[0][e[i].to]=now,dfs(e[i].to);
}
void ssort(){
	int m=256;
	for(int i=1;i<=m;++i)c[i]=0;
	for(int i=1;i<=n;++i)++c[x[i]=s[i]];
	for(int i=1;i<=m;++i)c[i]+=c[i-1];
	for(int i=n;i;--i)sa[c[x[i]]--]=i;
	for(int k=0;1<<k<=n;++k){
		for(int i=1;i<=n;++i)vec[i].clear();
		for(int i=1;i<=n;++i)if(F[k][i])vec[F[k][i]].push_back(i);
		int p=0;
		for(int i=1;i<=1<<k;++i)
		for(int j:vd[i])y[++p]=j;
		for(int i=1;i<=n;++i)
		for(int j:vec[sa[i]])y[++p]=j;
		for(int i=1;i<=m;++i)c[i]=0;
		for(int i=1;i<=n;++i)++c[x[i]];
		for(int i=1;i<=m;++i)c[i]+=c[i-1];
		for(int i=n;i;--i)sa[c[x[y[i]]]--]=y[i];
		std::swap(x,y);
		x[sa[1]]=p=1;
		for(int i=2;i<=n;++i)
		x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&&y[F[k][sa[i]]]==y[F[k][sa[i-1]]]?p:++p);
		if(p==n)break;
		m=p;
	}
}
inline int cmp(int a,int b){return F[0][a]!=F[0][b]?x[F[0][a]]<x[F[0][b]]:a<b;}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=2;i<=n;++i){
		int&f=F[0][i];
		cin>>f;
		e[++cnt]=(edge){i,head[f]},head[f]=cnt;
	}
	cin>>(s+1);
	dfs(dep[1]=1);
	for(int i=1;i<=n;++i)vd[dep[i]].push_back(i);
	for(int i=1;i<19;++i)
	for(int j=1;j<=n;++j)
	F[i][j]=F[i-1][F[i-1][j]];
	ssort();
	int lst=1;
	for(int i=2;i<=n+1;++i)
	if(hx1[sa[i]]!=hx1[sa[i-1]]||hx2[sa[i]]!=hx2[sa[i-1]])pd[dep[sa[i-1]]].emplace_back(lst,i-1),lst=i;
	for(int i=1;i<=n;++i)
	for(auto j:pd[i]){
		sort(sa+j.first,sa+j.second+1,cmp);
		for(int k=j.first;k<=j.second;++k)
		x[sa[k]]=k;
	}
	for(int i=1;i<=n;++i)cout<<sa[i]<<' ';
	return 0;
}
```

---

## 作者：STARSczy (赞：7)

一个所有本题题解都没有提及的新思路，并为最优解。只需在后缀排序模板代码上改动极小部分即可，思路简单。

首先看到这道题，第一个想法就是在后缀排序模板基础上改。

好的，这是后缀排序模板伪代码：
```cpp
#define rep(i,l,r) for(int i=(l),i##end=(r);i<=i##end;++i)
#define per(i,r,l) for(int i=(r),i##end=(l);i>=i##end;--i)
//输入略
rep(l,0,log2(n)){
  rep(i,1,n) a[i]=rk[i],b[i]=i+(1<<l)<=n?rk[i+(1<<l)]:0;//此为为两关键字赋值
  //按两关键字排序略
}
```
考虑如何修改以上代码。假设我们不考虑从两个节点所对应字符串相同的情况，**只求每个节点对应字符串的排名**（这里，排名指小于当前字符串的字符串个数加一），那么我们只需改动一行，再加一行：

```cpp
#define rep(i,l,r) for(int i=(l),i##end=(r);i<=i##end;++i)
#define per(i,r,l) for(int i=(r),i##end=(l);i>=i##end;--i)
//输入部分同上
rep(l,0,log2(n)){
  rep(i,1,n) a[i]=rk[i],b[i]=rk[fa[i]];//此为为两关键字赋值
  //按两关键字排序部分同上
  per(i,n,1) fa[i]=fa[fa[i]];//更新父亲
}
```
以样例为例，排序后的排名（即 rk 数组）为：
|1|4|4|2|2|
|:-:|:-:|:-:|:-:|:-:|

我们发现，此时排名会有相同部分。

我们再来看一下，题目让我们求的是什么。在我们仔细读题后，我们发现，题目让我们求的实际上是 $n$ 个 $n+1$ 元组的排序问题。其中，每个元组第一个元素是这个节点的排名，接下来依次是从根节点到该节点的节点标号，剩下的用 $0$ 来补全。

以样例为例，每个节点所对应的元组为：

|元组元素|1|2|3|4|5|6|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|节点1|1|1|||||
|节点2|4|1|2||||
|节点3|4|1|3||||
|节点4|2|1|3|4|||
|节点5|2|1|2|5|||

空余部分为 $0$。其中，第一列为 rk 数组，往后依次为根节点到该节点的节点。对以上排序的结果就是答案。

考虑如何求解以上问题。我们可以在求出 rk 数组以后，再从根节点开始 dfs 一遍，每个节点的儿子枚举顺序按从小到大 dfs ，也就是我们用 vector 存树，dfs 时排一遍序。同时，使用桶存 rk，若有重复 rk，加上前面枚举到当前 rk 值的个数。最后用 rk 还原出 sa 数组，整道题就完成啦！！

最终伪代码：
```cpp
vector<int> e[maxn];
void dfs(int x){
	rk[x]+=t[rk[x]]++,sort(e[x].begin(),e[x].end());
	for(int i:e[x]) dfs(i);
}


#define rep(i,l,r) for(int i=(l),i##end=(r);i<=i##end;++i)
#define per(i,r,l) for(int i=(r),i##end=(l);i>=i##end;--i)
//输入部分同上
rep(i,1,n) e[fa[i]].push_back(i);
rep(l,0,log2(n)){
  rep(i,1,n) a[i]=rk[i],b[i]=rk[fa[i]];//此为为两关键字赋值
  //按两关键字排序部分同上
  per(i,n,1) fa[i]=fa[fa[i]];//更新父亲
}
dfs(1);
rep(i,1,n) sa[rk[i]]=i;
```

ac 代码如下：
```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/rope>
#define rep(i,l,r) for(int i=(l),i##end=(r);i<=i##end;++i)
#define per(i,r,l) for(int i=(r),i##end=(l);i>=i##end;--i)
// #define int long
#define double long double
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define rbtree(way) tree<way,null_type,less<way>,rb_tree_tag,tree_order_statistics_node_update>
using namespace std;
using namespace __gnu_cxx;
using namespace __gnu_pbds;
const int maxn=1e6+10,maxm=1e6+10,mod=998244353,inf=INT_MAX;

int n,a[maxn],b[maxn],t[maxn],rk[maxn],sm[maxn],fa[maxn];
vector<int> e[maxn];
string s;
void dfs(int x){
	rk[x]+=t[rk[x]]++,sort(e[x].begin(),e[x].end());
	for(int i:e[x]) dfs(i);
}

signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	rep(i,2,n) cin>>fa[i],e[fa[i]].pb(i);
	cin>>s;
	rep(i,1,n) ++t[s[i-1]+1];
	rep(i,1,1000) t[i]+=t[i-1];
	rep(i,1,n) rk[i]=t[s[i-1]]+1;
	rep(l,0,log2(n)){
		rep(i,0,n) t[i]=sm[i]=0;
		rep(i,1,n) a[i]=rk[i],b[i]=rk[fa[i]],++t[b[i]+1];
		rep(i,1,n) t[i]+=t[i-1];
		rep(i,1,n) sm[++t[b[i]]]=i;
		rep(i,0,n) t[i]=0;
		rep(i,1,n) rk[sm[i]]+=t[a[sm[i]]]++;
		rep(i,1,n) sm[rk[i]]=i;
		rep(i,1,n) if(a[sm[i-1]]==a[sm[i]]&&b[sm[i-1]]==b[sm[i]]) rk[sm[i]]=rk[sm[i-1]];
		per(i,n,1) fa[i]=fa[fa[i]];
	}
	rep(i,0,n) t[i]=0;
	dfs(1);
	rep(i,1,n) sm[rk[i]]=i;
	rep(i,1,n) cout<<sm[i]<<' ';
	return 0;
}
```

---

## 作者：i207M (赞：5)

~~这个残酷的世界...字母的字典序比较是从下往上比，为啥编号的字典序比较就是从上往下比...故意避开普通人的逻辑？~~

这道题，肯定和后缀排序有关咯。我们类比后缀排序的倍增算法，也尝试来倍增。

其实大致思路是差不多的，对序列的排序，我们每次在每个串后接上新串；对Trie树的排序，我们每次从每个点到$2^k$级祖先的路径，扩展到$2^{k+1}$级祖先。

如果编号的字典序比较是从下往上比，那么我们就做完了。然而真实的世界没有那么简单，为了满足题目的要求，我们需要进行“三关键字排序“，第一关键字是$0-2^k$级祖先的串的**可重**排名，第二关键字是$2^k-2^{k+1}$的串的**不可重**排名，第三关键字是是$0-2^k$级祖先的串的**不可重**排名。

*上文的“可重”是指只考虑串，不考虑编号*

**为什么第二关键字的排名是不可重的？**
因为如果两个串第一关键字相同，第二关键字不同，那么不需要比较第三关键字了，因为这时我们应该考虑编号的不同，而编号是从上到下比较的，所以靠上的编号已经能完全区分它们了。

**为什么第三关键字的排名是不可重的？** 因为如果前两个关键字相同，第三关键字不同，说明它们的串相同，上边的编号也相同，所以需要比较靠下部分的编号。

因为我们第一次排序的第二关键字是编号从小到大，结合三关键字排序的方式，最终就是我们要的答案。

怎样三关键字排序？先合并后两个关键字，再和第一个合并。


```cpp
#define N 500005
int n;
void rsort(int m,int one[],int two[],int res[])
{
    static int buk[N];
    for(ri i=1; i<=n; ++i) ++buk[one[i]];
    for(ri i=1; i<=m; ++i) buk[i]+=buk[i-1];
    for(ri i=n; i>=1; --i) res[buk[one[two[i]]]--]=two[i];
    for(ri i=0; i<=m; ++i) buk[i]=0;
}
int fa[N];
char s[N];
int sa[N],_rk[N],_tp[N];
auto rk=_rk,tp=_tp;
int rk2[N],st[N];
void solve()
{
    for(ri i=1; i<=n; ++i) rk[i]=s[i],tp[i]=i;
    rsort(128,rk,tp,sa);
    for(ri i=1; i<=n; ++i) rk2[sa[i]]=i;
    for(ri w=1,p=0; w<n&&p<n; w<<=1)
    {
        for(ri i=1; i<=n; ++i) st[i]=rk2[fa[i]];
        rsort(n,st,sa,tp);
        rsort(w==1?128:p,rk,tp,sa);
        swap(rk,tp);
        rk2[sa[1]]=rk[sa[1]]=p=1;
        for(ri i=2; i<=n; ++i)
        {
            rk[sa[i]]=(tp[sa[i]]==tp[sa[i-1]]&&tp[fa[sa[i]]]==tp[fa[sa[i-1]]])?p:++p;
            rk2[sa[i]]=i;
        }
        bool hv=0;
        for(ri i=n; i>=1; --i) fa[i]=fa[fa[i]],hv|=fa[i];
        if(!hv) break;
    }
}
signed main()
{
#ifdef M207
    freopen("in.in","r",stdin);
    // freopen("ot.out","w",stdout);
#endif
    in(n);
    for(ri i=2; i<=n; ++i) in(fa[i]);
    scanf("%s",s+1);
    solve();
    prt(sa+1,n);
    return 0;
}
```


---

## 作者：xtx1092515503 (赞：4)

通过本题，我对后缀数组的理解又深了许多。

首先这是我普通SA的代码：

```cpp
namespace Suffix_Array{
	const int N=1010000;
	int x[N],y[N],sa[N],buc[N],n,m,s[N];
	void SA(){
		for(int i=1;i<=n;i++)buc[x[i]=s[i]]++;
		for(int i=1;i<=m;i++)buc[i]+=buc[i-1];
		for(int i=n;i;i--)sa[buc[x[i]]--]=i;
		for(int k=1;k<=n;k<<=1){
			int num=0;
			for(int i=n-k+1;i<=n;i++)y[++num]=i;
			for(int i=1;i<=n;i++)if(sa[i]>k)y[++num]=sa[i]-k;
			for(int i=0;i<=m;i++)buc[i]=0;
			for(int i=1;i<=n;i++)buc[x[y[i]]]++;
			for(int i=1;i<=m;i++)buc[i]+=buc[i-1];
			for(int i=n;i;i--)sa[buc[x[y[i]]]--]=y[i],y[i]=0;
			swap(x,y);
			x[sa[1]]=num=1;
			for(int i=2;i<=n;i++)x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k])?num:++num;
			if(num>=n)break;
			m=num;
		}
	}
}
```
说一下各数组的含义：

$x$：前一次排序后的 $rk$ 数组，即位置 $i$ 的排名（对于相同的字符串，此值也相同）

$sa$：前一次排序后的 $sa$ 数组，即排名为 $i$ 的位置。

$y$：按照第二关键字（后半段字符串）的值排序后的结果

$buc$：桶。

------------

现在我们要把它转到树上，有什么变化呢？

首先，它对于相同的串的比较方式我们先不管，就假设所有串均不同。

然后，在序列上我们倍增可以直接跳下标，在树上倍增就必须依照树上倍增的 $anc$ 数组了。

------------

我们将上述代码截成四段，分别是预处理初始排序结果、按照第二关键字排序、按照第一关键字排序，以及由排序结果（$sa$ 数组）推出 $x$。

明显初始排序同序列排序并无区别。

按照第二关键字（后半段串）排序的部分：

1. 如果一个节点不存在 $k$ 级祖先，显然它第二关键字排序的结果应该在最前面。

2. 如果一个节点存在 $k$ 级祖先，因为两个节点可能有相同的 $k$ 级祖先，所以这部分仍需要排序一下，按照祖先的 $x$ 排序。

所以就能魔改成这样：

```cpp
int num=0;
for(int i=1;i<=m;i++)buc[i]=0;
for(int i=1;i<=n;i++)if(!anc[i][k])y[++num]=i;else ++buc[x[anc[i][k]]];
for(int i=1;i<=m;i++)buc[i]+=buc[i-1];
for(int i=n;i;i--)if(anc[i][k])y[num+buc[x[anc[i][k]]]--]=i;
```

按照第一关键字排序并无区别。

推 $x$ 的过程中，唯一区别即在于判断是否相等的 $mat$ 函数。此部分稍稍魔改一下就可以了：

```cpp
bool mat(int i,int j,int k){
	if(y[i]!=y[j])return false;
	if(!anc[i][k]&&!anc[j][k])return true;
	if(anc[i][k]&&anc[j][k])return y[anc[i][k]]==y[anc[j][k]];
	return false;
}
```

------------

下面我们回到原题——可能有相同的串。怎么办呢？

我们之前特意提到了，**对于相同的串，它们 $x$ 的值相同**。然后题面中的比较方式，实际上就是按照优先遍历小编号节点的dfs序进行排序。于是我们以最后一遍排序后的 $x$ 为第一关键字，dfs序为第二关键字，进行排序，即得到了最终结果。

此部分及主函数代码：

```cpp
int tot,dfn[500100];
vector<int>v[500100];
void dfs(int x){
	dfn[x]=++tot;
	sort(v[x].begin(),v[x].end());
	for(auto y:v[x])dfs(y);
}
int main(){
	scanf("%d",&n);
	for(int i=2;i<=n;i++)scanf("%d",&anc[i][0]),v[anc[i][0]].push_back(i);
	for(int j=1;j<=19;j++)for(int i=1;i<=n;i++)anc[i][j]=anc[anc[i][j-1]][j-1];
	scanf("%s",s+1);for(int i=1;i<=n;i++)s[i]=s[i]-'a'+1;
	SA();
	dfs(1);
	for(int i=1;i<=n;i++)sa[i]=i;
	sort(sa+1,sa+n+1,[](int u,int v){return x[u]==x[v]?dfn[u]<dfn[v]:x[u]<x[v];});
	for(int i=1;i<=n;i++)printf("%d ",sa[i]);puts("");
//	for(int i=1;i<=n;i++)printf("%d ",sa[i]);
//	for(int i=1;i<=n;i++)printf("%d ",x[i]);
	return 0;
}
```

AC代码就把前面几块代码拼一起即可。

---

## 作者：hzjnsy (赞：4)

**[cnblogs](https://www.cnblogs.com/MnZnOIerLzy/articles/17716790.html)**

**[题目传送门](https://www.luogu.com.cn/problem/P5353 "题目传送门")**

> - 给出一棵 $n$ 个节点，以 $1$ 为根的树，点 $i$ 上有字符 $c_i$。定义点 $i$ 的字符串 $s_i$ 为从点 $i$ 走到点 $1$ 路径上所有点上的字符拼接而成的字符串。
>
> - 形式化的，若点 $i$ 到点 $1$ 的路径为 $p_1,p_2,\dots ,p_k\,(p_1=i,p_k=1)$，则 $s_i=\overline{c_{p_1}\dots c_{p_k}}$。
>
> - 你要对 $1\sim n$ 这些点按照 $s_i$ 的字典序进行排序，若字典序相同，则父亲排名小的点排名小。若仍相同，编号小的点排名小。
>
> - $n\le 5\times 10^5$。

看到对字符串排序想到后缀排序。我们可以类比后缀排序，利用倍增的思想，每次将两条长度为 $2^i$ 的连续的、向上的链拼起来成为长度为 $2^{i+1}$ 的链。所以要处理树上的倍增数组，记 $fa_{i,u}$ 为点 $u$ 向上走 $2^i$ 条边到达的祖先。这部分的代码：

```cpp
for (int l = 0, id; (1 << l) <= n; ++l) {
    for (int i = 1; i <= n; ++i) 
        p[i] = {{rk[i], fa[l][i] ? rk[fa[l][i]] : 0}, i}; // 先比前半段，前半段相同再比后半段。
    memset(cnt, 0, sizeof cnt); 
    for (int i = 1; i <= n; ++i) ++cnt[p[i].fi.se];
    for (int i = 1; i <= n; ++i) cnt[i] += cnt[i - 1];
    for (int i = n; i >= 1; --i) tmp[cnt[p[i].fi.se]--] = p[i];
    for (int i = 1; i <= n; ++i) p[i] = tmp[i];
    memset(cnt, 0, sizeof cnt); 
    for (int i = 1; i <= n; ++i) ++cnt[p[i].fi.fi];
    for (int i = 1; i <= n; ++i) cnt[i] += cnt[i - 1];
    for (int i = n; i >= 1; --i) tmp[cnt[p[i].fi.fi]--] = p[i];
    for (int i = 1; i <= n; ++i) p[i] = tmp[i]; id = 0;
    for (int i = 1; i <= n; ++i)
        { if (i == 1 || p[i].fi != p[i - 1].fi) ++id; rk[p[i].se] = id; }
    if (id == n) { op = 1; break; }
}
```

关键是如何去重。这个代码求出来的 $rk_i$ 表示将所有字符串**去重后**，$s_i$ 的排名（排名定义为比它小的数的个数 $+1$）。我们先通过以下代码求得**不去重**的排名：

```cpp
memset(cnt, 0, sizeof cnt); for (int i = 1; i <= n; ++i) ++cnt[rk[i]];
for (int i = 1; i <= n; ++i) cnt[i] += cnt[i - 1];
for (int i = 1; i <= n; ++i) rk[i] = cnt[rk[i] - 1] + 1;
```

然后考虑两个字典序相同的字符串，它们的深度**一定相同**。因此用 `vector` 存放深度为 $d$ 的点编号，然后**从小往大**处理，因为深度父亲的深度大于儿子。先将同一深度内的点按照 $rk$ 排序。然后从头开始扫，扫出**一段 $\boldsymbol{rk}$ 相同的区间**，然后再对这个区间内的点**以父亲排名作为第一关键字、编号作为第二关键字排序**。那么这些点的排名就是递增的，且第一个点的排名**就是自己的 $\boldsymbol {rk}$**。代码如下:

```cpp
bool cmp1(int u, int v) { return rk[u] < rk[v]; }
bool cmp2(int u, int v) {
    return rk[fa[0][u]] != rk[fa[0][v]] ? rk[fa[0][u]] < rk[fa[0][v]] : u < v;
}
for (int i = 0; i < n; ++i) {
    sort(h[i].begin(), h[i].end(), cmp1);
    for (int j = 0, k, l = h[i].size(), id; j < l; j = k) {
        for (k = j; k < l && rk[h[i][k]] == rk[h[i][j]]; ++k);
        sort(h[i].begin() + j, h[i].begin() + k, cmp2); id = rk[h[i][j]] - 1;
        for (int d = j; d < k; ++d) rk[h[i][d]] = ++id;
    }
}
```

去完重之后，如果用后缀排序中的名称来说，别忘记**你输出的是 $\boldsymbol{sa}$ 数组而不是 $\boldsymbol{rk}$ 数组**（有个人因此爆 $0$ 了，我不说是谁），你要再做一遍双射。

现在来算时间复杂度，倍增处理 $fa$ 数组以及倍增求 $rk$ 都是 $\mathcal{O}(n\log n)$ 的，至于去重，其实就是把“将长度为 $n$ 的数组分成若干段，对每段分别进行排序并从左到右扫描”这个操作做了两次，根据乘法分配律和加法结合律，可以算出这部分的时间复杂度为 $\mathcal{O}(n\log n)$。

综上，本做法时间、空间复杂度均为 $\mathcal{O}(n\log n)$。

**[评测记录](https://www.luogu.com.cn/record/125274193 "评测记录")**

```cpp
#include <bits/stdc++.h>
#define P pair
#define fi first 
#define se second 
using namespace std; const int N = 5e5 + 5; 
typedef P<int, int> pii; typedef P<pii, int> ppi;
int n, fa[20][N], rk[N], sa[N], dep[N], cnt[N]; 
string s; vector<int> g[N], h[N]; ppi p[N], tmp[N]; bool op;
bool cmp1(int u, int v) { return rk[u] < rk[v]; }
bool cmp2(int u, int v) {
    return rk[fa[0][u]] != rk[fa[0][v]] ? rk[fa[0][u]] < rk[fa[0][v]] : u < v;
}
void dfs(int u) {
    for (int i = 1; (1 << i) <= dep[u]; ++i) fa[i][u] = fa[i - 1][fa[i - 1][u]];
    for (int v : g[u]) dep[v] = dep[u] + 1, dfs(v); h[dep[u]].emplace_back(u);
}
void out() {
    for (int i = 1; i <= n; ++i) sa[rk[i]] = i;
    for (int i = 1; i <= n; ++i) cout << sa[i] << ' '; exit(0);
}
signed main() {
    cin.tie(0), cout.tie(0), ios::sync_with_stdio(0); cin >> n;
    for (int i = 2, x; i <= n; ++i) cin >> x, g[fa[0][i] = x].emplace_back(i);
    dfs(1); cin >> s; s = ' ' + s; for (int i = 1; i <= n; ++i) ++cnt[s[i]];
    for (int i = 'a'; i <= 'z'; ++i) cnt[i] += cnt[i - 1];
    for (int i = 1; i <= n; ++i) rk[i] = cnt[s[i] - 1] + 1;
    for (int l = 0, id; (1 << l) <= n; ++l) {
        for (int i = 1; i <= n; ++i) 
            p[i] = {{rk[i], fa[l][i] ? rk[fa[l][i]] : 0}, i};
        memset(cnt, 0, sizeof cnt); 
        for (int i = 1; i <= n; ++i) ++cnt[p[i].fi.se];
        for (int i = 1; i <= n; ++i) cnt[i] += cnt[i - 1];
        for (int i = n; i >= 1; --i) tmp[cnt[p[i].fi.se]--] = p[i];
        for (int i = 1; i <= n; ++i) p[i] = tmp[i];
        memset(cnt, 0, sizeof cnt); 
        for (int i = 1; i <= n; ++i) ++cnt[p[i].fi.fi];
        for (int i = 1; i <= n; ++i) cnt[i] += cnt[i - 1];
        for (int i = n; i >= 1; --i) tmp[cnt[p[i].fi.fi]--] = p[i];
        for (int i = 1; i <= n; ++i) p[i] = tmp[i]; id = 0;
        for (int i = 1; i <= n; ++i)
            { if (i == 1 || p[i].fi != p[i - 1].fi) ++id; rk[p[i].se] = id; }
        if (id == n) { op = 1; break; }
    }
    if (op) out();
    memset(cnt, 0, sizeof cnt); for (int i = 1; i <= n; ++i) ++cnt[rk[i]];
    for (int i = 1; i <= n; ++i) cnt[i] += cnt[i - 1];
    for (int i = 1; i <= n; ++i) rk[i] = cnt[rk[i] - 1] + 1;
    for (int i = 0; i < n; ++i) {
        sort(h[i].begin(), h[i].end(), cmp1);
        for (int j = 0, k, l = h[i].size(), id; j < l; j = k) {
            for (k = j; k < l && rk[h[i][k]] == rk[h[i][j]]; ++k);
            sort(h[i].begin() + j, h[i].begin() + k, cmp2); id = rk[h[i][j]] - 1;
            for (int d = j; d < k; ++d) rk[h[i][d]] = ++id;
        }
    }
    out();
}
```

---

## 作者：Cyber_Tree (赞：4)

~~水博客太快乐了。。。~~

**智商不够， SAM 来凑**

后缀系列题目居然没有 SAM 题解，那我就来水一发罢， ~~虽然本来是想贺一发的~~。

~~本蒟蒻只会无脑 SAM ，哪位鸽鸽给咱教育一下SA啊?~~

~~这题 SA 貌似真的比 SAM 好写的多。。。~~

# 后缀自动机做法

既然是树上后缀排序，那么不妨先考虑在序列上该怎么做。最容易想到的是建出反串的 SAM 。那我们考虑将这个做法转移到树上，聪明的你想必已经发现了，在树上我们无法对反串做 SAM ，~~于是考虑放弃 SAM ，写 SA~~ 。

重新考虑在序列上的做法，若只能建出正串的 SAM 该如何求出序列的后缀数组呢？

不要局限于后缀，若我们能求出 SAM 上每个节点对应反串的字典序的相对大小，那么问题自然也就迎刃而解了。考虑从 Parent 树上下手，根据 Parent 树的性质，每个节点的父亲代表的字符串是当前节点的一个后缀，由此可得，对于 Parent 树上每棵子树，其反串的字典序大小是连续的，且这个子树的根节点是子树中字典序最小的。因此，若能能求出一个节点的所有儿子的相对大小，便能求出所有节点的相对大小。

考虑如何求出每个节点的儿子的相对大小。

![SAM](https://cdn.luogu.com.cn/upload/image_hosting/nebt0xyf.png)

图中 $u$ 是 $v$ 在 Parent 树上的父亲，则 $u$ 是 $v$ 的一个后缀，那么决定 $v$ 在 $u$ 儿子中相对大小的显然是 $a$ 位置的字符的大小，因此建出 SAM 后由 $u$ 向 $v$ 连一条边，边权为 $a$ 位置的字符，遍历 Parent 树时优先遍历边权小的边，最终得到的 dfs 序即为所有节点反串的字典序相对大小。

因为题目要求是在树上的，所以用广义 SAM 就可以了，查找 $a$ 位置的字符可以用树上 $k$ 级祖先实现。

此时我们想直接 sort 就可以了，然而题目还有一个要求，就是字典序相同的节点要以父亲的大小排序，不难发现此时父亲的字典序也是相同的，于是只能一直递归下去直到 lca 处，比较这两个节点恰在 lca 下方的祖先的编号大小。

时间复杂度为 $O(n \log^2 n)$ 但是实际跑下来和 $O(n \log n)$ 差不多。

放下代码罢。。。

```cpp
#include <bits/stdc++.h>

#define fi first
#define se second
const int N = 1e6 + 10;

int read(void) {
	int f = 1, x = 0; char ch = getchar();
	while(!isdigit(ch)) { if(ch == '-') f = -1; ch = getchar(); }
	while(isdigit(ch)) { x = x * 10 + ch - 48; ch = getchar(); }
	return f * x;
}

using std::pair; using std::make_pair;

int n, fa[N], top[N], dep[N], son[N], pos[N], siz[N], dfn[N], id[N], ind;
std::vector<int> l[N];
char ch[N];

int K_an(int u, int k) {
	while(k > dep[u] - dep[top[u]] + 1)
		k -= dep[u] - dep[top[u]] + 1, u = fa[top[u]];
	return id[dfn[u] - k + 1];
}

struct SAm {
	int to[N][26], link[N], len[N], pos[N], dfn[N], siz, ind;
	void init(void) { siz = 1; }
	int insert(char ul, int p, int id) {
		if(to[p][ul - 'a']) {
			int q = to[p][ul - 'a'];
			if(len[q] == len[p] + 1) return q;
			else {
				int cl = ++siz; len[cl] = len[p] + 1;
				memcpy(to[cl], to[q], sizeof to[q]), link[cl] = link[q];
				while(p && to[p][ul - 'a'] == q) to[p][ul - 'a'] = cl, p = link[p];
				return pos[cl] = pos[q], link[q] = cl;
			}
		}
		int now = ++siz; len[now] = len[p] + 1, pos[now] = id;
		while(p && !to[p][ul - 'a']) to[p][ul - 'a'] = now, p = link[p];
		if(!p) link[now] = 1;
		else {
			int q = to[p][ul - 'a'];
			if(len[q] == len[p] + 1) link[now] = q;
			else {
				int cl = ++siz; len[cl] = len[p] + 1;
				memcpy(to[cl], to[q], sizeof to[q]), link[cl] = link[q];
				while(p && to[p][ul - 'a'] == q) to[p][ul - 'a'] = cl, p = link[p];
				pos[cl] = pos[q], link[now] = link[q] = cl;
			}
		} return now;
	}
	std::vector<pair<int, int> > l[N];
	void dfs(int u) {
		dfn[u] = ++ind;
		std::sort(l[u].begin(), l[u].end());
		for(pair<int, int> v : l[u]) dfs(v.se);
	}
	void solve(void) {
		for(int i = 2; i <= siz; ++i)
			l[link[i]].push_back( { ch[K_an(pos[i], len[link[i]] + 1)], i } );
		dfs(1);
	}
} S;

void dfs1(int u) {
	dep[u] = dep[fa[u]] + 1, siz[u] = 1;
	pos[u] = S.insert(ch[u], pos[fa[u]], u);
	for(int v : l[u]) {
		dfs1(v), siz[u] += siz[v];
		if(siz[v] > siz[son[u]]) son[u] = v;
	}
}
void dfs2(int u, int tp) {
	top[u] = tp, id[dfn[u] = ++ind] = u;
	if(son[u]) dfs2(son[u], tp);
	for(int v : l[u]) if(v ^ son[u]) dfs2(v, v);
}
bool chk(int u, int v) {
	int x = u, y = v;
	while(top[u] ^ top[v]) {
		if(dep[top[u]] > dep[top[v]]) u = fa[x = top[u]];
		else v = fa[y = top[v]];
	} return u == v ? x < y : dep[u] < dep[v] ? x < son[u] : son[v] < y;
}

pair<int, int> p[N];
bool cmp(pair<int, int> x, pair<int, int> y)
	{ return x.fi ^ y.fi ? x.fi < y.fi : chk(x.se, y.se); }

signed main(void) {
	n = read(), pos[0] = 1, S.init();
	for(int i = 2; i <= n; ++i)
		l[fa[i] = read()].push_back(i);
	scanf("%s", ch + 1), dfs1(1), dfs2(1, 1); S.solve();
	for(int i = 1; i <= n; ++i) p[i] = { S.dfn[pos[i]], i };
	std::sort(p + 1, p + 1 + n, cmp);
	for(int i = 1; i <= n; ++i) printf("%d ", p[i].se);
	return puts(""), 0;
}
```

---

## 作者：lovely_nst (赞：2)

# P5353 树上后缀排序

## 前置知识

1. 树的遍历

2. [后缀数组 SA](https://oi-wiki.org/string/sa/)

## [后缀排序](https://www.luogu.com.cn/problem/P3809)

这里先贴一份普通后缀排序的代码。

```cpp
for (int i = 1;i <= n;i ++)
		rk[i] = s[i] , sa[i] = i;
	for (w = 1;w < n;w <<= 1)
	{
		sort (sa + 1 , sa + n + 1 , [](int x , int y){return rk[x] == rk[y] ? rk[x + w] < rk[y + w] : rk[x] < rk[y];});
		for (int j = 1;j <= n;j ++) lrk[j] = rk[j];
		int p = 0;
		for (int j = 1;j <= n;j ++)
		{
			if (lrk[sa[j]] == lrk[sa[j - 1]] && lrk[sa[j] + w] == lrk[sa[j - 1] + w])
				rk[sa[j]] = p;
			else
				rk[sa[j]] = ++ p;
		}
	}
```

这份代码使用了倍增法求后缀数组，具体就是先按前一段的排名排序，若相同就比较后面的一段的排名，然后得到排名。

## 树上后缀排序

现在思考如何转换为树上排序。

设 $fa_{i,u}$ 为点 $u$ 向上走 $2^i$ 步后到达的点，那么前一段的排名不变，还是 $rk_u$，而后面一段的排名则是 $rk_{fa_{i,u}}$，具体代码为

```
w : 0 - log2(n)
sort (sa + 1 , sa + n + 1 , [](int x , int y){return rk[x] == rk[y] ? rk[fa[w][x]] < rk[fa[w][y]] : rk[x] < rk[y];});
```

求排名也是一样的，把原来直接加的换成树上往上跳即可。

## 去重

发现可能存在相同的字符串，而两个字符串相同那一定所在的节点深度也相同，自己画图手推易得。

跑一遍深搜，存储每个深度所有的节点，然后层级遍历，每层先按 $fa_i$ 的排名排序，若相等就按编号 $i$ 排序（按题意模拟）。因为是层级遍历，所以在处理 $i$ 时 $fa_i$ 一定已经处理完了，不会冲突。（层级遍历也可以用广搜）

## AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
vector <int> g[500005] , dep[500005];
int cc , d[500005] , n , w , sa[500005] , rk[500005] , lrk[500005] , fa[20][500005] , lg[500005];
int cnt[500005] , ans[500005];
void dfs (int u)
{
	dep[d[u]].push_back (u);
	for (int v : g[u])
		d[v] = d[u] + 1 , dfs (v);
}
bool cmp (int x , int y)
{
	return ans[x] == ans[y] ? (ans[fa[0][x]] == ans[fa[0][y]] ? x < y : ans[fa[0][x]] < ans[fa[0][y]]) : rk[x] < rk[y];
}
signed main ()
{
	ios::sync_with_stdio (0) , cin.tie (0) , cout.tie (0);
	cin >> n;
	for (int i = 2;i <= n;i ++)
		cin >> fa[0][i] , g[fa[0][i]].push_back (i);
	string s;
	cin >> s;
	s = ' ' + s;
	lg[0] = -1;
	for (int i = 1;i <= n;i ++)
		rk[i] = s[i] , sa[i] = i , lg[i] = lg[i >> 1] + 1;
	for (int i = 1;i <= lg[n];i ++)
		for (int j = 1;j <= n;j ++)
			fa[i][j] = fa[i - 1][fa[i - 1][j]];
	for (w = 0;w <= lg[n];w ++)
	{
		sort (sa + 1 , sa + n + 1 , [](int x , int y){return rk[x] == rk[y] ? rk[fa[w][x]] < rk[fa[w][y]] : rk[x] < rk[y];});
		for (int j = 1;j <= n;j ++) lrk[j] = rk[j];
		int p = 0;
		for (int j = 1;j <= n;j ++)
		{
			if (lrk[sa[j]] == lrk[sa[j - 1]] && lrk[fa[w][sa[j]]] == lrk[fa[w][sa[j - 1]]])
				rk[sa[j]] = p;
			else
				rk[sa[j]] = ++ p;
		}
	}
	dfs (1);
	for (int i = 1;i <= n;i ++) cnt[rk[i]] ++;
	for (int i = 1;i <= n;i ++) cnt[i] += cnt[i - 1];
	for (int i = 1;i <= n;i ++) ans[i] = cnt[rk[i] - 1] + 1;
	for (int i = 0;i <= n;i ++)
	{
		sort (dep[i].begin () , dep[i].end () , cmp);
		int lst = 0;
		for (int u : dep[i])
		{
			if (rk[lst] == rk[u])
				ans[u] = ans[lst] + 1;
			lst = u;
		}
	}
	for (int i = 1;i <= n;i ++)
		sa[ans[i]] = i;
	for (int i = 1;i <= n;i ++)
		cout << sa[i] << ' ';
	return 0;
}
```

---

## 作者：frank3215 (赞：2)

# 后缀数组的做法

注意：

1. 这题字符串是从当前节点向上，编号却是从根向下！
1. 比较相当于比较（当前节点到根的字符串，根到当前节点的编号）的二元组！

考虑倍增时的比较顺序：

1. 当前字符串的大小。
1. 祖先字符串的大小。
1. 祖先字符串编号的大小。
1. 当前字符串编号的大小。

可以将2,3合并，将4前面增加一个1（因为如果比较到了第4关键字，第1关键字必然相等，可以随意添加），如下：

1. 当前字符串的大小。
1. 祖先字符串（字符串，编号）的大小
1. 当前字符串（字符串，编号）的大小

## 实现

在排序时：需要保证第一个数组`rk`是第一关键字，第二个数组`tp`是第二关键字''的逆''。返回的结果是排名的''逆''`sa`。

### 预处理

以字符大小为第一关键字，以当前节点编号（其逆为本身）为第二关键字，排序即可。

### 倍增

考虑前一轮已经完成对字符串前`1<<k`个字符的排序，设顺序为`sa`，字符串大小为`rk`（可重），（字符串，编号）大小为`rkk`（不重）。

那么，可以顺序按照如下的关键字来排序，得到`1<<(k+1)`的答案：

1. 当前字符串的大小`rk`
1. 祖先（字符串，编号）的大小（由`rkk`得到，存储在`rk2`中）。
1. 当前字符串的（字符串，编号）的大小`rkk`（其逆为`sa`）。

排序时可以先合并后两个关键字，再将得到的逆排名与第一关键字合并。

### 代码

（参考[xht37大佬的题解](https://www.luogu.com.cn/blog/xht37/p5353-mu-ban-shu-shang-hou-zhui-pai-xu)）


```cpp
inline void tsort(int *sa, int *rk, int *tp, int m) {
	for (int i = 0; i <= m; ++i) tx[i] = 0;
	for (int i = 1; i <= n; ++i) tx[rk[i]]++;
	for (int i = 1; i <= m; ++i) tx[i] += tx[i-1];
	for (int i = n; i; --i) sa[tx[rk[tp[i]]]--] = tp[i];
}


	for (int k = 0; (1<<k) < n; ++k) {
		for (int i = 1; i <= n; ++i) {
			rk2[i] = rkk[fa[k][i]];
		}
		tsort(tp, rk2, sa, n);
		tsort(sa, rk, tp, n);
		swap(rk, tp);
		p = rk[sa[1]] = rkk[sa[1]] = 1;
		for (int i = 2; i <= n; ++i) {
			rk[sa[i]] = (#cmp(sa[i], sa[i-1], k)) ? ++p : p;
			rkk[sa[i]] = i;
		}
	}
```

### 注

为了卡常，可以在倍增的时候将`f[i][k]`（`i`表示当前节点，`k`表示层数）的下标顺序交换，变成`f[k][i]`，实测快了200+ms。

---

## 作者：yijan (赞：2)

建议 luogu 博客或者 [这里](https://www.yijan.co/shu-shang-hou-zhui-pai-xu/)

考虑用后缀平衡树来维护这个东西。

后缀平衡树是一种维护后缀的数据结构，其中序遍历就是后缀数组。但是，对于它维护的后缀集合 $T$ 其中的一个字符串 $S\in T$ ，它可以支持 $O(\log n)$ 插入 $xS$ 。

我们考虑插入 $xS$ 的时候要做什么，首先会比较当前节点所代表的后缀的第一个字符和 $x$ 的大小关系，如果不相同，我们就已经成功比较了当前节点的后缀和这个串的大小关系。否则，我们需要比较 $S$ 与这个后缀去掉第一个字符（仍然是个后缀）的大小关系，也就是某两个后缀的大小关系。如果我们对后缀平衡树上每个点分配一个权值，可以 $O(1)$ 进行比较。分配权值可以给整个树分配一个 $[0,10^9]$ 的权值，然后每次折半分配权值。使用替罪羊树来进行重构就可以让树高保持不高。

树上后缀排序同样可以用这个，每次插入的时候可以方便地找到去掉第一个字符的后缀 $fa[u]$ 。

```cpp
#include "iostream"
#include "algorithm"
#include "cstring"
#include "cstdio"
#include "cmath"
#include "vector"
#include "map"
#include "set"
#include "queue"                   
using namespace std;
#define MAXN 600006
//#define int long long
#define rep(i, a, b) for (int i = (a), i##end = (b); i <= i##end; ++i)
#define per(i, a, b) for (int i = (a), i##end = (b); i >= i##end; --i)
#define pii pair<int,int>
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define eb emplace_back
#define vi vector<int>
#define all(x) (x).begin() , (x).end()
#define mem( a ) memset( a , 0 , sizeof a )
typedef long long ll;
int n , m;
int A[MAXN] , fa[MAXN];
char S[MAXN];

#define alp 0.75
int siz[MAXN] , ch[MAXN][2] , rt;
double val[MAXN];

void pu( int x ) {
	siz[x] = siz[ch[x][0]] + 1 + siz[ch[x][1]];
}

int tr[MAXN] , cn;
void pia( int x ) {
	if( !x ) return;
	pia( ch[x][0] );
	tr[++ cn] = x;
	pia( ch[x][1] );
	ch[x][0] = ch[x][1] = 0;
}
void rebuild( int& x , int l , int r , double L , double R ) {
	if( l > r ) return;
	int m = l + r >> 1; double mid = ( L + R ) / 2;
	x = tr[m] , val[x] = mid;
	rebuild( ch[x][0] , l , m - 1 , L , mid ) , rebuild( ch[x][1] , m + 1 , r , mid , R );
	pu( x );
}
bool fuck( int x ) {
	return siz[x] * alp < siz[ch[x][0]] || siz[x] * alp < siz[ch[x][1]];
}
void maintain( int& x , double L , double R ) {
	if( fuck( x ) ) cn = 0 , pia( x ) , rebuild( x , 1 , cn , L , R );
}
bool cmp( int x , int y ) {
	return S[x] == S[y] ? ( val[fa[x]] == val[fa[y]] ? x < y : val[fa[x]] < val[fa[y]] ) : S[x] < S[y];
}
void ins( int& x , int idx , double L , double R ) {
	if( !x ) {
		x = idx , siz[x] = 1 , val[x] = ( L + R ) / 2;
		return;
	}
	if( cmp( idx , x ) ) ins( ch[x][0] , idx , L , val[x] );
	else ins( ch[x][1] , idx , val[x] , R );
	pu( x );
	maintain( x , L , R );
}
int sa[MAXN] , cnt;
void calc( int x ) {
	if( !x ) return;
	calc( ch[x][0] );
	sa[++ cnt] = x;
	calc( ch[x][1] );
}

void solve() {
	cin >> n;
	rep( i , 2 , n ) scanf("%d",fa + i);
	scanf("%s",S + 1);
	rep( i , 1 , n ) 
		ins( rt , i , 0 , 1e9 );
	calc( rt );
	rep( i , 1 , n ) printf("%d ",sa[i]);
}

signed main() {
//    int T;cin >> T;while( T-- ) solve();
    solve();
}


```



---

## 作者：咯咯咯 (赞：2)

这里先奉上出题人的[题解](https://www.cnblogs.com/xht37/p/10821282.html)

下面是我的一些思考（放在代码里了）
```cpp
#include<iostream>
#include<cstdio>
#define For(i,a,b) for(int i=a;i<=b;i++)
#define Ford(i,a,b) for(int i=a;i>=b;i--)
const int N=5e5,Logn=21;
void read(int &x)
{
	int t=0,opt=1;
	char c=getchar();
	while (c<'0'||c>'9') (c=='-'?opt=-1:0),c=getchar();
	while ('0'<=c&&c<='9')
	{
		t=t*10+c-'0';
		c=getchar();
	}
	x=t*opt;return ;
}
int n,pa[N][Logn];char s[N];
namespace SA
{
	int rank[N],rank_pa[N],temp[N],pos[N],tax[N],tp[N],sa[N],size;
	void Qsort(int *sa,int *rank,int *tp,int size)
	{
		For(i,0,size) tax[i]=0;
		For(i,1,n) tax[rank[tp[i]]]++;
		For(i,1,size) tax[i]+=tax[i-1];
		Ford(i,n,1) sa[tax[rank[tp[i]]]--]=tp[i];
	}
	void Sort()
	{
		For(i,1,n) rank[i]=s[i]-'a'+1,tp[i]=i;//一定记住0是用来放'\0'的,而不是'a'
		Qsort(sa,rank,tp,'z'-'a'+1);For(i,1,n) pos[sa[i]]=i;
		for(int w=1,p=0;w<n;w<<=1,p++) //在长度为w时所有人的聪明程度都是对的
		{						     	  //(pos即此时严格排名(含编号,绝对不同),rank为智商字符串排名(无视编号))
			For(i,1,n) rank_pa[i]=pos[pa[i][p]];
			Qsort(tp,rank_pa,sa,n); //以自己的字符串排名为第一关键字,以父亲严格排名为第二键字，自己位置为第三关键字
			Qsort(sa,rank,tp,rank[sa[n]]);//如果两个人智商字符串相同，则按照其父亲的严格排名，若父亲相同，则按自己的严格排名
			For(i,1,n) temp[i]=rank[i];rank[sa[1]]=1;
			For(i,2,n) rank[sa[i]]=(temp[sa[i]]==temp[sa[i-1]]&&temp[pa[sa[i]][p]]==temp[pa[sa[i-1]][p]])?rank[sa[i-1]]:rank[sa[i-1]]+1;
			For(i,1,n) pos[sa[i]]=i;//最终得到2*w的严格排名
		}
	}
}
int main()
{
	read(n);
	For(i,2,n) {read(pa[i][0]);For(j,1,Logn-1) pa[i][j]=pa[pa[i][j-1]][j-1];}
	scanf("%s",s+1);
	SA::Sort();For(i,1,n) printf("%d ",SA::sa[i]);
	return 0;
}
```


---

## 作者：critnos (赞：1)

稍微改造一下 DC3 就是树上后缀排序的线性算法，准确来说是达到下界——和对点权排序复杂度相同。

首先如果深度不超过 $2$ 就直接排序，否则把树上的点按深度模 $3$ 分类。假设求出了只保留余 $0,1$ 的类的排序结果，那么利用 $1$ 类的排序结果加上 $2$ 类本身的点权，基数排序就可以求出 $2$ 类的排序结果。

然后把这两个东西归并，要比较两个点的排名，如果这两个点分别是 $0,1$ 则可以直接比较；否则比较两者的点权，如果不同则直接返回，否则递归到父节点。这样至多递归两次就能把包含 $2$ 的比较转化为不包含 $2$ 的比较。

那么考虑递归地求出这三类中较小的两类的排序结果，即分裂出两棵树，每个点的点权代表了在原树上其本身、父亲、祖父三个点权，利用基数排序离散化，然后用超级根把两棵树连接起来。这里至多有 $\frac 2 3n$ 个点，时间复杂度 $T(n)=T(\frac 2 3n)+O(n)$，即线性。

---

## 作者：L_zaa_L (赞：0)

其实后缀平衡树可以解决这道题，而且还挺简单。

[我的后缀平衡树笔记](https://zhuanlan.zhihu.com/p/716855624)

然后这道题我们将整棵树从上面往下面所代表的字符串依次插入后缀平衡树中，然后比较两个位置的大小，就是先比较原位置的字符大小，在比较它们父亲的字典序大小，然后排名第 $i$ 的字符串的节点编号，我们可以通过直接遍历整个后缀平衡树得到，因为后缀平衡树是一个二叉搜索树，所以按照左儿子，自己，右儿子的顺序依次给排名就可以了，时间复杂度 $O(n\log n)$。

## Code
```cpp
#include<bits/stdc++.h>
#define ll long long  
#define ls(x) (tr[x].l)
#define rs(x) (tr[x].r)
#define Debug(...) fprintf(stderr, __VA_ARGS__)
#define For(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)
#define Rof(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)
#define rep(i,  b) for(int i=1,i##end=b;i<=i##end;i++)
using namespace std;
const int N=8e5+5,base=999983,Mod=998244353;
const ll inf=1e16;
//char buf[(1<<21)+5],*p1,*p2;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline void chmx(int &x,int y){(x<y)&&(x=y);}
inline void chmn(int &x,int y){(x>y)&&(x=y);}
inline void Add(int &x,int y){(x=x+y+Mod)%=Mod;}
inline int read(){
	int f=0,x=0;
	char ch=getchar();
	while(!isdigit(ch)){f|=(ch=='-');ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return f?-x:x;
}
void print(int n){
    if(n<0){
        putchar('-');
        n*=-1;
    }
    if(n>9) print(n/10);
    putchar(n%10+'0');
}
int n,m;
char s[N],op[11],t[N];
struct _Tree{
	ll v;
	int l,r,s,key;
};int fa[N];
int sa[N];
struct SAT{
	_Tree tr[N];int rt,cnt;
	inline int chk(int x,int y){
		if(s[x]>s[y]||s[x]==s[y]&&tr[fa[x]].v>tr[fa[y]].v)
			return 1;
		else if(s[x]==s[y]&&tr[fa[x]].v==tr[fa[y]].v)
			return 0;
		else return -1;
	}
	inline void pushup(int x){
		tr[x].s=tr[ls(x)].s+tr[rs(x)].s+1;
	}
	void dfs(int x,ll l,ll r){
		tr[x].v=l+r>>1;
		if(ls(x))dfs(ls(x),l,tr[x].v-1);
		if(rs(x))dfs(rs(x),tr[x].v+1,r);
	}
	inline void zig(int &x,ll l,ll r){
		int q=ls(x);
		ls(x)=rs(q);
		rs(q)=x;
		pushup(x),pushup(q);
		dfs(q,l,r);x=q;
	}
	inline void zag(int &x,ll l,ll r){
		int q=rs(x);
		rs(x)=ls(q);
		ls(q)=x;
		pushup(x),pushup(q);
		dfs(q,l,r);x=q;
	}
	int merge(int x,int y){
		if(!x||!y)return x|y;
		if(tr[x].key<tr[y].key){
			rs(x)=merge(rs(x),y);
			pushup(x);
			return x;
		}
		else{
			ls(y)=merge(x,ls(y));
			pushup(y);
			return y;
		}
	}
	void ins(int &x,int p,ll l,ll r){
		if(!x){
			tr[p].l=tr[p].r=0;
			tr[p].key=rand();
			tr[p].v=(l+r)/2;
			tr[p].s=1;
			x=p;
			return ;
		}
		if(chk(x,p)>0){
			ins(ls(x),p,l,tr[x].v-1);
			pushup(x);
			if(tr[x].key>tr[ls(x)].key)
				zig(x,l,r);
		}
		else{
			ins(rs(x),p,tr[x].v+1,r);
			pushup(x);
			if(tr[x].key>tr[rs(x)].key)
				zag(x,l,r);
		}
	}
	void del(int &x,int p,ll l,ll r){
		if(!x)return;
		if(chk(x,p)==0){
			x=merge(ls(x),rs(x));
			if(x) dfs(x,l,r);
			return;
		}
		if(chk(x,p)>0)
			del(ls(x),p,l,tr[x].v-1);
		else del(rs(x),p,tr[x].v+1,r);
		pushup(x);
	}
	void getsa(int x) {
		if (!x) return;
		getsa(ls(x));
		sa[++cnt]=x;
		getsa(rs(x));
	}
}sat;
inline void gstr(char s[],int p){
    int len=strlen(s);
    For(i,0,len-1){
        p=(p*131+i)%len;
        swap(s[i],s[p]);
    }
}
signed main(){
	// ios::sync_with_stdio(false);
	// cin.tie(0); cout.tie(0);
	n=read();
	For(i,2,n) fa[i]=read();
	scanf("%s",s+1);
	For(i,1,n) sat.ins(sat.rt,i,1,inf);
	sat.getsa(sat.rt);
	For(i,1,n)printf("%lld ",sa[i]);
#ifdef LOCAL
    Debug("\nMy Time: %.3lfms\n", (double)clock() / CLOCKS_PER_SEC);
#endif
	return 0;
}
```

---

## 作者：_Luminescence_ (赞：0)

好题。后缀平衡树板子，但用后缀排序解决的难度很高。写完后对后缀排序有了更深的理解。

**首先要明白一点，后缀排序绝非局限于一个字符串：它可以在 $O(n\log n) $ 的时间复杂度下对 $n$ 个后缀进行排序，这些后缀不一定是要在一个字符串里的。**

回到这题上，若不考虑字符串相等的情况，直接排序是平凡的：仿照一般的后缀排序，倍增求出每个节点的 $2^k$ 级祖先，因为后缀排序是基于倍增的，所以对 `equal` 函数进行修改即可。参考代码如下：

```cpp
bool equal(int i,int j,int t){
	if(tp[i]==tp[j]&&tp[f[t][i]]==tp[f[t][j]])return 1;
	return 0;
}
```

其中函数 `equal(i,j,t)` 判断的是第 $i$ 个后缀与第 $j$ 个后缀在倍增到 $t$ 时是否相等。`f[t][i]` 表示 $i$ 的 $2^t$ 级祖先。

接下来考虑存在字符串相等的情况。题中给出：若存在相等的后缀，则先比较它们对应节点的父节点的排名，若仍然相等，则比较它们自身的编号。

突然发现自己不太会讲，下面给出代码：

```cpp
void Rsort(int *sa,int *rk,int *tp,int m){
	for(int i=0;i<=m;i++)buc[i]=0;
	for(int i=1;i<=n;i++)buc[rk[i]]++;
	for(int i=1;i<=m;i++)buc[i]+=buc[i-1];
	for(int i=n;i>=1;i--)sa[buc[rk[tp[i]]]--]=tp[i];
}
bool equal(int i,int j,int t){
	if(tp[i]==tp[j]&&tp[f[t][i]]==tp[f[t][j]])return 1;
	return 0;
}
void get_SA(){
	int p;
	for(int i=1;i<=n;i++)rk[i]=s[i],tp[i]=i;
	Rsort(sa,rk,tp,127);
	rk[sa[1]]=rk1[sa[1]]=p=1;
	for(int i=2;i<=n;i++){
		rk[sa[i]]=s[sa[i]]==s[sa[i-1]]?p:++p;
		rk1[sa[i]]=i;
	}
	for(int w=1,t=0;w<n;w<<=1,t++){
		for(int i=1;i<=n;i++)rk2[i]=rk1[f[t][i]];
		Rsort(tp,rk2,sa,n);
		Rsort(sa,rk,tp,p);
		for(int i=1;i<=n;i++)tp[i]=rk[i];
		rk[sa[1]]=rk1[sa[1]]=p=1;
		for(int i=2;i<=n;i++){
			rk[sa[i]]=equal(sa[i-1],sa[i],t)?p:++p;
			rk1[sa[i]]=i;
		}
	}
}
```

为什么要这样对 $tp$ 进行排序？为什么这样排就能符合题目要求？相信在看完代码后，你一定要这样的疑问。我们不妨来倒着想。

首先考虑在求 $sa$ 的过程中，有两个相等的后缀 $s_1,s_2$。因为它们相等，所以此时的 $rk$ 也相等，那么决定它们的次序的就是第二关键字 $tp$ 了，我们来进一步考虑 $tp$。

代码中对 $tp$ 的排序方式是：以上一轮的 $sa$ 作为第二关键字，以上一轮排序结果的后半段作为第一关键字，进行排序。其中依照 `rk2` 进行排序，满足了第一关键字**字符串**和第二关键字**父亲编号**，而 $sa$ 则满足了第三关键字**自己编号**。

所以对于 $sa$ 排序时，第二关键字 $tp$ 已经考虑了三个关键字了，因此是对的。

这里应该有一个归纳的思想：一开始对单个字符排序时，是符合题意的，接着对 $tp$，$sa$ 排序时，也是符合题意的，所以最终是符合题意的。


作为读者，自然想看想看顺畅的思路过程，但很可惜的是笔者并没有独立做出这道题。至于对于本题为什么要这么做，笔者尚无什么能成文的头绪，望读者不吝赐教。

---

## 作者：MuelsyseU (赞：0)

## 一、思路

[题目](https://www.luogu.com.cn/problem/P5353)大意：对给定树上所有点到跟的路径构成的字符串进行从小到大排序，如有完全相同的串，则从根向下依次从小到大比较编号。

与 P3809 类似，不同的是可能存在完全相同的字符串（后缀由于长度不同不可能完全相同），因此比较两个串时可以把编号构成的串也看成“字符串”，这个由于编号的唯一性不可能完全重复。所以比较时需要按照优先级依次考虑四个因素：

1. 当前两个串的大小
2. 当前两个串的父亲串的大小
3. 当前两个串的父亲编号串的大小
4. 当前两个串对应编号串的大小

四个因素都是小的排在前面。也就是按照楼上 frank3215 大佬的题解将 2,3 合并，看作是整个比较完之后的不可重排名。可以理解为把编号串复制接在字符串的后面，比较这个串，显然它就是一个不可重的排名。但是 1,4 两个由于优先级原因显然不可以合并，所以 1 仍然是可重排名。

## 二、实现

这里在实现中采用后缀数组 SA。一般进行后缀数组的处理采用基数排序，但是在本题中这种写法稍微不容易理解，于是就有一种采用快速排序进行的技巧。那么我们只需要考虑 cmp 函数即可。虽然多一个 $\log$ 但是实际上这种做法在不打开 O2 的情况下甚至可以卡过 $n = 10^6$ 的数据（可能由于 SA 固有的小常数）。

```cpp
#include <algorithm>
#include <cmath>
#include <cstring>
#include <fstream>
#include <iostream>
#include <vector>
using namespace std;

// Blocking
char str[2000010];
//rk2: 临时数组, rk: 不考虑编号的可重排名, rkk: 不可重排名
int n, k, v, sa[2000010], fa[2000010], rk[2000010], rk2[2000010], rkk[2000010];
//预处理单结点的 rkk 只考虑字符和编号
inline bool cmt(int i, int j) {
    if (str[i] != str[j]) return str[i] < str[j];
    return i < j;
}
//判断大小(可重)
inline bool cmd(int i, int j) {
    if (rk[i] != rk[j]) return rk[i] < rk[j];
    return rk[fa[i]] < rk[fa[j]];
}
//判断大小(不可重)
inline bool cmp(int i, int j) {
    if (rk[i] != rk[j]) return rk[i] < rk[j];
    if (rkk[fa[i]] != rkk[fa[j]]) return rkk[fa[i]] < rkk[fa[j]];
    return rkk[i] < rkk[j];
}
inline void init() {
    //k = 1 此时每个节点对应的串只包含自身
    for (int i = 1; i <= n; ++i) sa[i] = i;
    sort(sa + 1, sa + 1 + n, cmt);
    rk[sa[1]] = rkk[sa[1]] = 1;
    for (int i = 2; i <= n; ++i)
        rk[sa[i]] = rk[sa[i - 1]] + (str[sa[i]] != str[sa[i - 1]]), rkk[sa[i]] = i;
    //k: 当前每个结点对应的串向上延伸的长度
    for (k = 2; k <= n; k *= 2) {
        v = 0;
        sort(sa + 1, sa + 1 + n, cmp);
        rk2[sa[1]] = rkk[sa[1]] = 1;
        for (int i = 2; i <= n; ++i)
            rk2[sa[i]] = rk2[sa[i - 1]] + cmd(sa[i - 1], sa[i]), rkk[sa[i]] = i;
        //每个结点的 fa 向上倍增一次
        for (int i = n; i >= 1; --i) rk[i] = rk2[i], fa[i] = fa[fa[i]], v |= fa[i];
        //剪枝
        if (!v) break;
    }
}
signed main() {
    scanf("%d", &n);
    for (int i = 2; i <= n; ++i) scanf("%d", fa + i);
    scanf("%s", str + 1);
    init();
    for (int i = 1; i <= n; ++i) printf("%d ", sa[i]);
    return 0;
}
```

---


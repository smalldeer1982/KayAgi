# 【模板】回文自动机（PAM）

## 题目描述

给定一个字符串 $s$。保证每个字符为小写字母。对于 $s$ 的每个位置，请求出以该位置结尾的回文子串个数。

这个字符串被进行了加密，除了第一个字符，其他字符都需要通过上一个位置的答案来解密。

具体地，若第 $i(i\geq 1)$ 个位置的答案是 $k$，第 $i+1$ 个字符读入时的 $\rm ASCII$ 码为 $c$，则第 $i+1$ 个字符实际的 $\rm ASCII$ 码为 $(c-97+k)\bmod 26+97$。所有字符在加密前后都为小写字母。

## 说明/提示

### 样例解释

三个样例解码后分别为：

- $\verb!dfccgs!$；
- $\verb!lxlxlisqiiingwaaaa!$；
- $\verb!aabaabbaaa!$。

### 数据范围及约定

对于 $100\%$ 的数据， $1\leq |s|\leq 5\times 10^5$。

## 样例 #1

### 输入

```
debber
```

### 输出

```
1 1 1 2 1 1
```

## 样例 #2

### 输入

```
lwkvjfrphhgkfvzzyx
```

### 输出

```
1 1 2 2 3 1 1 1 1 2 3 1 1 1 1 2 3 4
```

## 样例 #3

### 输入

```
azzzyyzyyx```

### 输出

```
1 2 1 2 3 2 2 2 3 3```

# 题解

## 作者：功在不舍 (赞：131)

~~感觉题解们都不太对我这种萌新友好啊~~

我来一篇带图的题解把。

1.引入：我们来考虑一个问题，怎么求一个串有多少个本质不同的子串？

如果你用暴力枚举子串或者$Manacher+hash$，都是$O(n^2)$的太慢了。

他们没有利用到各个回文子串之间的包含关系，所以比较慢。
zzh
回文自动机就是来利用这种关系解决问题$O(n)$算法

2.回文树

和AC自动机一样，回文自动机也要有一颗树把回文串“串起来”。

我们知道一个长的回文串去掉他的两头，能得到一个短回文串，

我们利用回文字符串这样性质把他们折叠挂在树上。

但是长度为奇数的回文子串 有中心，而长度为 偶数的回文子串没有。

我们要把长度为奇数、偶数的分开挂着。

0代表偶数长度的根，1代表奇数长度的根。

树上的每一个点都代表一个不同的回文子串（不含0，1）

以abbaabba为例子，下面是他的回文树，上面串着所有他的回文串。

挂的同时我们还可以统计各个回文子串的长度。

$len[0]=0,len[1]=-1$

其他的点深度+1，len就比父节点增加2。


![](https://cdn.luogu.com.cn/upload/image_hosting/bw5uq3il.png)


注意这里节点代表的状态和 $trie$ 树不一样。

状态应该从下往上再往下读。

例如8号点代表的回文子串是 $bbaabb$ 

注意如果在奇数树上，最顶上的边只能读1次。

这棵树的节点个数-2就是abbaabba本质不同的回文串个数。

3.$O(n)$构建与$fail$

我们肯定不能直接暴力把所有回文子串挂上去。

我们用一种类似后缀树的办法 “增量构造”

即利用$s[0\ to\ i-1]$的回文树，加入$s[i]$位得到新的回文树。

明显，我们可能会得到一些新的回文子串，考虑怎么把他放到树上。

由于所有新产生的回文子串都是新最长回文子串的回文后缀，且长度应比最长的小，我们可以把他们“翻转”一下，就可以发现他们一定在$s[0\ to \ i-1]$的回文树里！（即同时也是前缀）

所以插入一个新点，最多只会建立“最长新回文后缀”这么一个节点，保证了回文自动机的点数是$O(n)$的。


这也告诉我们一个串的本质不同的回文子串最多有n个，由$aaaa.....$取到，于是问题转化为了怎么把这一个回文串放到树上。

首先，我们可以发现，如果设新产生的回文子串中长度最大的长度为$len$,则$s[i-len+2\ \ to\ \ i-1]$（就是掐头去尾）一定也是一个回文串（$len=0$直接不用管了）。

其次，这个回文串一定是$s[0\ to\ i-1]$满足$s[i-len[x]-1]=s[i]$的最长回文后缀 $x$，否则添头增尾得到的新的回文子串不是最长的。

“最长”“后缀”让我们想到了什么？$->AC:fail[x]$

类似的，定义fail[x]为x代表的回文子串的最长回文后缀。

假设 以$i-1$位结束的最长回文子串在$cur$位置

$cur,fail[cur],fail[fail[cur]] ......$一定包含了所有新产生的回文子串。（其中合法的是满足$s[i-len[x]-1]==s[i]$的）

$while$遍历，当其中第一次遇到$s[i-len[x]-1]==s[i]$时，一定是新的最长回文后缀,如果那一位在回文数上有$s[i]$这个子节点就直接走过去(重复了)，否则就新建一个。（是不是和AC自动机很像）

下图是abbaabba的完整回文自动机。

![](https://cdn.luogu.com.cn/upload/image_hosting/p3ds7v2b.png)

你可能会疑惑，0、1一个是偶数空，一个是奇数空，他们的$fail$是干嘛的？

考虑$abbac$,加入到$c$的时候，不管你怎么跳$fail$都匹配不上，但是它 会在奇数根1下面挂上，表示单独的字符C。

$fail[0]=1$ 结合上面的图你可以发现，当出现我说的情况时，fail最后会从奇数根下面的某一位 跳到0，若0也不能增加，就得跳到1去了(奇数根一定可以挂，想想为什么)，让0指向1，就实现了增添新的单独字符的功能。

你可能又会问了，这样不是跳了两次吗，为什么不让奇数根下面的字符直接$fail=1$,而是让他等于0？

这当然是不对的，跳$fail$的本质过程是判断能不能加入新的位，不能在单个字符周围加入新的字符形成长度为3的新回文串，不代表不能再“0空”位置形成 $aa,bb,cc$这样长度为2的回文串。

本模板题要求以每一位结尾的回文子串个数，设$num[x]$为回文自动机上$x$号点中回文子串个数，当新加入一个点$tot$时，$num[tot]=num[fail[tot]]+1$，即比他的最长回文后缀多含有一个回文子串。

以下是代码,说几个细节问题。

1.如果$i$从$0$开始，$i-len[x]-1$可能出现负数，特判一下。

2.求新点的$fail$时是$getfail(fail[pos],i)$，如果写成了$getfail(pos,i)$，自己会被当成是自己的最长回文后缀(和AC自动机一样不允许！)，$fail$指向自己会导致程序死循环。

3.求新点的$fail$必须在建立新点之前！

  否则考虑 要建立奇数根下的点时（abbbc），他们$fail[i]=0$,$getfail(fail[pos],i)$会跳到1(0匹配的话不会再1下建点)，如果1下已经建立它的点，$fail$也会指向他自己导致程序卡死！
  
时间复杂度$O(n)$，首先建立的节点数是$O(n)$的，其次因为每次执行$while$循环的时候cur的深度会-1，而cur的深度总共增加了n次（for循环中），所以$while$的执行次数也是$O(n)$的


差不多了完结撒花~
  
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char s[2000001];
int len[2000001],n,num[2000001],fail[2000001],last,cur,pos,trie[2000001][26],tot=1;
int getfail(int x,int i)
{
	while(i-len[x]-1<0||s[i-len[x]-1]!=s[i])x=fail[x];
	return x;
}
int main()
{
	scanf("%s",s);
    n=strlen(s);
    fail[0]=1;len[1]=-1;
    for(int i=0;i<=n-1;i++){
    	if(i>=1)s[i]=(s[i]+last-97)%26+97; 
    	pos=getfail(cur,i);
        //找到cur的fail链中能匹配i位的最长回文后缀
        if(!trie[pos][s[i]-'a']){
        	fail[++tot]=trie[getfail(fail[pos],i)][s[i]-'a'];
        	trie[pos][s[i]-'a']=tot;
        	len[tot]=len[pos]+2;
            num[tot]=num[fail[tot]]+1;
		}//不存在建立点，存在直接走过去
        cur=trie[pos][s[i]-'a'];
        last=num[cur];
		printf("%d ",last);	   
	}
	return 0;
}
```

---

## 作者：Ireliaღ (赞：69)

# 回文自动机（回文树）

## 简介

### 概述

回文自动机（PAM），也叫回文树

可以用 $O(n)$ 的时间复杂度求出一个字符串的所有回文子串

本蒟蒻是学了两遍才学明白的，这里推荐一下[B站上关于回文自动机的讲解](https://www.bilibili.com/video/av25326779?from=search&seid=16439865067541274096)

当然如果不方便看视频的话，也可以看一下我自己关于回文自动机的一些理解

### 正文

**节点含义**

类比 AC 自动机每个节点的含义

回文自动机每个节点的含义表示在它的父节点两侧各加上一个儿子字符

**奇根偶根**

由于回文串有奇数长度和偶数长度两种

所有我们的回文自动机自然会有两个根——奇根和偶根

偶根的节点编号为 $0$，所代表的回文串的长度为 $0$，`fail` 指针指向奇根

奇根的节点编号为 $1$，所代表的回文串的长度为 $-1$，`fail` 指针指向自身（其实无所谓）

**`fail` 指针**

我们再来说一下 `fail` 指针的含义

一个节点的 `fail` 指针，指向的是这个节点的最长回文后缀

所以在新加入一个字符的时候，我们要从当前节点不断的跳 `fail` 指针

直到跳到某一个节点所表示的回文串的两侧都能扩展一个待添加的字符

我们就看这个节点有没有这个儿子，如果有就直接走下去，没有就新建一个节点

新建节点的长度等于这个节点的长度加上 $2$（因为是回文串，要在两侧各扩展一个字符）

那每个节点的 `fail` 指针要怎么求那

我们可以考虑一个节点的最长回文后缀

必然是在它父节点的某个回文后缀两侧各拓展一个当前字符得到的

所以新建一个节点之后，我们可以从它父亲的 `fail` 节点开始，不断的跳 `fail` 指针

直到跳到第一个两侧能拓展这个字符的节点为止，那么该节点的儿子就是新建节点最长回文后缀

之后我们再看一下奇根和偶根的 `fail` 指针，由于奇根的子节点表示的回文串长度为 $1$，也是就该字符本身

所以奇根相当于是可以向两侧扩展任意字符的，所以我们把偶根的 `fail` 指针指向奇根

而如果跳到了奇根，一定能向两侧扩展，所以奇根的 `fail` 指针自然就无所谓了

代码实现起来非常的简单

**程序实现**

```cpp
char s[MAXN];

struct Node{
    int sum, len;//统计每个回文串的出现次数, len表示当前节点回文串的长度
    Node *fail, *ch[26];//每个节点的儿子, fail如上所述

    Node() {}
}tr[MAXN];

Node *last;
int ncnt;//ncnt表示节点数，last表示当前节点

Node *New(int len) {//新建一个节点
    tr[ncnt].len = len;
    tr[ncnt].fail = &tr[0];
    for (int i = 0; i < 26; i++) tr[ncnt].ch[i] = &tr[0];
    return &tr[ncnt++];
}

Node *GetFail(Node *pre, int now) {//跳fail指针
    while (s[now - pre->len - 1] != s[now]) pre = pre->fail;
    return pre;
}

void Build() {
    ncnt = 2;//tr[0] tr[1]为奇数根和偶数根 ,其他节点从2开始
    tr[0].len = 0; tr[1].len = -1;//初始化，如上所述
    tr[0].fail = &tr[1]; tr[1].fail = &tr[0];//初始化，如上所述
    for (int i = 0; i < 26; i++) tr[0].ch[i] = tr[1].ch[i] = &tr[0];
    last = &tr[0];
    for (int i = 1; s[i]; i++) {
        Node *cur = GetFail(last, i);//从当前节点开始，找到可扩展的节点
        if (cur->ch[s[i] - 'a'] == &tr[0]) {//没有这个儿子
            Node *now = New(cur->len + 2);//新建节点
            now->fail = GetFail(cur->fail, i)->ch[s[i] - 'a'];//找到最长回文后缀
            cur->ch[s[i] - 'a'] = now;//父子相认
        }
        last = cur->ch[s[i] - 'a'];//更新last
        last->sum++;//顺带求出每个回文串的出现次数
    }
}

```

**应用**

如果要求本质不同的回文串的个数，直接输出`cnt−2`即可（除去奇根）

如果要统计每个回文串的出现次数，还要从叶子节点向根遍历一遍

因为我们当时统计回文串时只统计了完整的回文串，但并没有记录它的子串

所以我们要按照拓扑序将每个节点的最长回文后缀的出现次数加上该节点的出现次数

这样我们就得到了一个字符串的所有回文子串的出现次数

```cpp
for (Node *p = tr + ncnt - 1; p != tr + 1; p--) p->fail->sum += p->sum; 
```

另外，回文自动机还有一种常见操作就是在构造的时候顺带求出一个 `trans` 指针

`trans` 指针的含义是小于等于当前节点长度的一半最长回文后缀，求法和 `fail` 指针的求法类似

当我们新建一个节点后，如果它的长度小于等于 $2$，那么这个节点的 `trans` 指针指向它的 `fail` 节点

否则的话，我们同理从它父亲的 `trans` 指针指向的节点开始跳 `fail` 指针

直到跳到某一个节点所表示的回文串的两侧都能扩展这个字符

并且拓展后的长度小于等于当前节点长度的一半

那么新建节点的 `trans` 的指针就指向该节点的儿子

代码实现区别也不大

```cpp
void Build() {
    ncnt = 2;
    tr[0].len = 0; tr[1].len = -1;
    tr[0].fail = &tr[1]; tr[1].fail = &tr[0];
    for (int i = 0; i < 26; i++) tr[0].ch[i] = tr[1].ch[i] = &tr[0];
    last = &tr[0];
    for (int i = 1; s[i]; i++) {
        Node *cur = GetFail(last, i);
        if (cur->ch[s[i] - 'a'] == &tr[0]) {
            Node *now = New(cur->len + 2);
            now->fail = GetFail(cur->fail, i)->ch[s[i] - 'a'];
            cur->ch[s[i] - 'a'] = now;
            if (now->len <= 2) {
                now->trans = now->fail;
            } else {
                Node *tmp = cur->trans;
                while (s[i - tmp->len - 1] != s[i] || ((tmp->len + 2) << 1) > now->len) tmp = tmp->fail;
                now->trans = tmp->ch[s[i] - 'a'];
            }
        }
        last = cur->ch[s[i] - 'a'];
        last->sum++;
    }
}
```

有了 trans 指针之后，我们就可以很轻松的切了这道[双倍回文](https://www.luogu.org/problemnew/show/P4287)

**后续**

如果 一道题空间限制较小，`PAM`并不能完全代替`Manacher`

## 本题写法

我们只需要注意每次添加新的字符时要处理一下强制在线就OK了，需要求出的就是本质不同的回文串个数。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;
const int MAXN = 2e6 + 5;

struct Node{
    Node *ch[26], *fail;
    int len, sum;
}tr[MAXN];

int n;
char s[MAXN];
int ncnt = 2;
Node *last;

Node *New(int len) {
    tr[ncnt].len = len;
    tr[ncnt].fail = &tr[0];
    for (int i = 0; i < 26; i++) tr[ncnt].ch[i] = &tr[0];
    return &tr[ncnt++];
}

Node *GetFail(Node *x, int pos) {
    while (s[pos - x->len - 1] != s[pos]) x = x->fail;
    return x;
}

void Init() {
    tr[0].len = 0; tr[1].len = -1;
    tr[0].fail = &tr[1]; tr[1].fail = &tr[0];
    for (int i = 0; i < 26; i++) tr[0].ch[i] = tr[1].ch[i] = &tr[0];
    last = &tr[0];
}

void Insert(int pos) {
    Node *cur = GetFail(last, pos);
    if (cur->ch[s[pos] - 'a'] == &tr[0]) {
        Node *now = New(cur->len + 2);
        now->fail = GetFail(cur->fail, pos)->ch[s[pos] - 'a'];
        now->sum = now->fail->sum + 1;
        cur->ch[s[pos] - 'a'] = now;
    }
    last = cur->ch[s[pos] - 'a'];
}

int main() {
    cin >> s + 1;
    n = strlen(s + 1);
    int k = 0;
    Init();
    for (int i = 1; i <= n; i++) {
        s[i] = (s[i] - 97 + k) % 26 + 97;
        Insert(i);
        cout << last->sum << " ";
        k = last->sum;
    }
    return 0;
}
```
## 感谢

我其实讲解部分转载的是[这篇文章](https://www.cnblogs.com/Vscoder/p/10498625.html)，由于[作者](https://www.luogu.org/space/show?uid=121921)是我同学，并且已经退役了，所以我就经过他的同意直接搬运过来了。

![](https://cdn.luogu.com.cn/upload/image_hosting/0i8senwj.png)

---

## 作者：chlchl (赞：48)

Update：2022.7.28。补充了对模板题解法的进一步说明，并对某些结论进行了补充或证明。

## 前言
想必各位都学过 Manacher 算法（~~没关系，没学过不影响今天的内容~~）。不得不承认，Manacher 的确是处理回文问题 一个强力工具，可以在 $O(n)$ 的时间复杂度内求出一个字符串的最长回文子串。

但是，对于回文计数类问题（比如求一个字符串有多少个本质不同的回文子串），Manacher 就心有余而力不足了。所以，我们需要一个更为强大的数据结构处理这个问题。这就是今天的**回文自动机**（PAM）。

## 概念
作为一个数据结构，首先需要明确回文自动机是个什么东西。

在开始之前，需要明确一些符号：
- $s$：正在处理的字符串。默认下表从 $1$ 开始。
- $|s|$：字符串 $s$ 的长度。
- $s_{i\sim j}$：指 $s$ 从第 $i$ 位到第 $j$ 位组成的字串。
- $fa_u$：指在回文自动机中编号为 $u$ 的节点的父亲。

回文自动机是一棵树（因此也叫作回文树），它存的是一个字符串中的**所有回文子串** 的 **一半**。

而由于回文串又分奇回文和偶回文，所以回文自动机有两个根节点，$0$ 存的是长度为偶数的回文串，$1$ 存的是长度为奇数的回文串。

而它的每条边，代表一个字符 $c$，指的是从父节点所代表的字符串的头尾各加一个 $c$ 的到儿子所代表的字符串。

什么意思呢？我们不妨来看张图。

以字符串 $ababaababa$ 作例子。它的所有回文子串分别是：
- 奇数：$a,b,aba,bab,ababa$；
- 偶数：$aa,baab,abaaba,babaabab,ababaababa$。

它们建出来的回文自动机是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/bxc7hir7.png?x-oss-process=image/resize,m_lfit,h_500,w_600)

~~有没有发现回文自动机和 Manacher 的关系很像 AC 自动机与 KMP 的关系，都是爸爸和儿子。~~

从图中我们得到两个结论：
- 除根节点外，每个节点恰好对应一个本质不同的回文子串，所以该树节点数 $-2$ 就是本质不同的回文子串个数（这很显然，原因跟 Trie 的储存原理是一样的，互不相同）。
- 若 $0$ 号节点对应字符串长度为 $0$，$1$ 号为 $-1$。则其余节点深度每 $+1$，所对应的回文串长度 $+2$（因为从下到上读一遍，又从上往下又读一遍）。

所以你现在知道为什么只存回文的一半了吧？除了节省空间，还是为了**避免本质相同的子串**。

## 原理
现在我们来看看回文自动机是怎么工作的。
### 插入新节点
这个地方我看其他讲解的的时候懵懵懂懂的，希望这里能讲明白。

我们考虑轮到 $s_i$ 插入时的情况。即前 $i-1$ 个字符都已经在树上了。

显然，加入该字符时肯定会出现若干个新的回文子串。那是不是要枚举所有新出现的回文子串呢？

显然不是。回文串左右两边相等。当插入第 $s_i$ 时，除了最长的新回文子串，其它看似新增的回文子串，其实在 $s_i$ 之前就已经在里面了。

以下是不严谨的证明：首先我们需要明确，新增的所有回文子串必定是当前串的后缀（因为它们全都包含当前的 $s_i$，不然不叫新增）。也就是说，只要不包含 $s_i$ 的均不是新增的。如果新增的某个串（设为 $t$）不是最长子串（设为 $s$），即 $|t|\leq |s|$，那因为 $s$ 也是回文的，所以在以 $s_{i-|t|+1}$ 为结尾，长度为 $|t|$ 的子串必定是 $t$（可以理解为把 $t$ 以 $s$ 的回文中心为对称轴做对称）。而这个 $t'$ 明显不包含 $s_i$，所以并不是新增的。

说穿了，精髓就是长回文串一定包含短回文串。

所以回文自动机的空间复杂度是 $O(|s|)$ 的。

例如 $ababaababa$ 已经插入完了 $ababaab$，现在轮到插入 $a$，那真正没有出现过的只有 $abaaba$。其他的，比如说 $aba(s_{6\sim 8})$，在 $s_{3\sim 5}$ 就已经出现过了。

现在，我们就要考虑如何将 $abaaba$ 这个最长新回文子串插入到树上了。

首先，$abaaba$ 是由 $baab$ 从头尾分别添加 $a$ 得到的，而这个 $baab$ 肯定已经在树上了（插入 $s_7$ 时已经加到树上了）。那我们只要找到 $baab$ 对应的节点，直接连一条 $a$ 的边就完事了。

怎么找这个 $baab$ 呢？我敢肯定，这个 $baab$ 一定是 $s_{0\sim i-1}$ 中的最长回文后缀（不信你看是不是）。为什么呢？很简单，因为 $baab$ 是插入 $s_{i-1}$ 时新增的节点，肯定就是 $s_{i-1}$ 的最长回文后缀了。

那么，由这个“最长回文后缀”你想到了什么？

没错，AC 自动机的 $fail$ 指针。所以，我们也定义一个类似 AC 自动机的 $fail_u$ 表示 $u$ 代表的**字符串的非自身最长回文后缀**。只要我们不停地眺，那 $fail_u,fail_{fail_u},\cdots$ 中总有一个可以在两边加上你要加的 $s_i$（即加上 $s_i$ 后仍为子串）（调到 $1$ 号根节点必定有解，后面会说）。然后看看合法点有没有 $s_i$ 这条边，如果有就直接往下走，没有就新建节点。

为什么是非自身？如果加上自身，它的 $fail$ 指针不就指向自己了？~~然后你的程序就会 T 成二臂……~~

记 $len_p$ 为 $p$ 对应的回文子串长度。假设 $s_p$ 为以第 $i-1$ 位结束的最长回文子串的位置。当我们求 $ fail_i$ 时，合法的转移点就必须满足 $s_{p-len_p-1}=s_p$，这个与 AC 自动机寻找 $fail$ 指针的原理是一样的，只是变成了判断是否回文而已。

下面是完整的回文自动机的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/57vddml0.png?x-oss-process=image/resize,m_lfit,h_500,w_600)

最后一个问题：为什么 $fail_0=1$？有什么用？比如说当 $aaaaab$ 插入 $b$ 的时候，它的 $fail$ 怎么跳都是没用的（因为压根儿就没 $b$）。这时，$b$ 只能当做单个字符挂在 $1$ 的下面，而不能挂在 $0$ 的下面。因此，我们需要让 $fail_0$ 指向 $1$。至于 $fail_1$，不用管，用不到，因为单独一个字符也算回文，不可能在 $1$ 下失配的。

最后，后缀自动机的时间复杂度为 $O(|s|\log n)$（$n$ 为节点数量）。这是我自己的 ~~xjb~~ 分析：首先，$s$ 中的每个字符都要插入，所以至少是 $O(|S|)$。然后，对于每个字符，采用 $fail$ 指针一层一层向上跳（可以证明，$fail$ 连向的都是长度更小的，因为定义是非自身最长回文前缀），最多跳 $\log n$ 层（最坏情况就是每个 $fail$ 都指向它的父亲），所以最终就是 $O(|s|\log n)$ 的，十分优秀。

## Solution
讲完原理，看看这道题怎么做：[P5496 【模板】回文自动机（PAM）](https://www.luogu.com.cn/problem/P5496)。

这题要求我们输出以字符串每个位置结尾的回文子串个数。因为回文自动机本身就涉及到后缀，所以要求结尾个数，只需要定义 $cnt_i$ 为以 $i$ 结尾的字符串的回文子串个数。更新的话，找到 $fail_i$ 后，$cnt_{fail_i}$ 就是除了 $i$ 之外的回文串数量。只要 $+1$（即加上哪一个新增的最长回文子串），就是 $cnt_i$ 的值。

~~@管理员大大 这个题没啥好分析的吧，弄懂原理就很简单了。~~

最后就是代码了，细节都在注释中。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 5e5 + 10;
char s[N];
int n, lst, len[N];
int now, tot = 1, fail[N], cnt[N], t[N][26];
//tot 记得赋成 1，已经有两个根节点了 

int getfail(int u, int p){//求 u 的fail指针 ，p表示当前插入的是哪个点 
	while(p - len[u] - 1 <= 0 || s[p - len[u] - 1] != s[p])	u = fail[u];
	//如果当前位置比 u的回文串短或者字符不相等                 就一直跳
	return u;//最后不跳了，你就是答案了 
}

int insert(char c, int id){
	int p = getfail(now, id);//找到那条路中有 id 位都一样的最长回文子串
	//这个点就是他爸爸 
	if(!t[p][c - 'a']){//爸爸没它这个儿子，新认一个 
       	fail[++tot] = t[getfail(fail[p], id)][c - 'a'];
		//fail等于((((爸爸的fail那条路上)有 id 位都是一样的回文串)的节点)的同名儿子)
       	t[p][c - 'a'] = tot;//跟trie树一样 
       	len[tot] = len[p] + 2;//长度等于爸爸+2 
		cnt[tot] = cnt[fail[tot]] + 1;//回文串数量等于fail的数量加上它自己 
	}
	return cnt[now = t[p][c - 'a']];//更新它现在的位置，并返回cnt作为答案 
}

int main(){
	scanf("%s", s + 1);
	n = strlen(s + 1);
	fail[0] = 1, len[1] = -1;
	//len[i] 表示节点 i 所对应的回文串长度 
	for(int i=1;i<=n;i++){
		if(i > 1)	s[i] = (s[i] - 'a' + lst) % 26 + 'a';
		printf("%d ", lst = insert(s[i], i));
	}
	return 0;
} 
```

~~这代码只能说一个字：短。~~

秒完这题，大家也可以去看看 [P4287 双倍回文](https://www.luogu.com.cn/problem/P4287) 和其他一些比较基础的题目，加深理解。

到此结束吧，记得留下你们的赞哦！

---

## 作者：Lolierl (赞：24)

**[更好的阅读体验](https://blog.csdn.net/Lolierl/article/details/99971257)
**

这是一道回文自动机模板题。

**什么是回文自动机**

回文自动机是一种有限状态自动机。

回文自动机的结构是两颗树，我们先将它们叫做回文Trie树。其中的0号节点为长度为偶数的回文串的根，1号节点为长度为奇数的回文串的根。

它和trie一样，把信息存储在边上。不同点是它的每个节点（除了根）都表示一个**回文串**，一个节点向下连一条边$ch$代表**在它两边各加一个字符ch**。只有1号节点例外，1号节点的孩子只增加一个字符，即为奇数长度回文串中心的字符。

容易证明任意回文串都可以在这两棵树上唯一地表示出来。


![在这里插入图片描述](https://img-blog.csdnimg.cn/20190822144339223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xvbGllcmw=,size_16,color_FFFFFF,t_70)

如图就是一棵回文trie树。它的每个节点所表示的回文串依次是（从2到5）：$aa, a, b, aba$

**回文自动机的fail指针**

和AC自动机类似，回文自动机被称为“自动机”是由于它的每个节点都有一个$fail$指针，它指向**当前节点所表示的回文串的最长回文后缀。**

特殊地，$1$号节点的$fail$指针没有意义，原因一会会介绍到。$0$号节点的$fail$指针指向$1$号节点。

回文自动机上还必须要记录每个节点所表示的最长回文串的长度，用$len$表示。
上图中的$fail$与$len$的值如下表：

|$i$|0|1|2|3|4|5|
|--|--|--|--|--|--|--|
|$fail_i$| 1 | 0|3|0|0|3|
| $len_i$ | 0 |-1|2|1|1|3

（此图只是为了帮助理解，真实构建时可能不会建出此形态的自动机）

注意我们定义$len_1 = -1$，原因是我们知道孩子的$len$等于父亲的 $len$加$2$，而我们将1的 $len$定义为$-1$这样它的孩子的$len$就会直接被计算为$1$，减少特判。还有一个好处一会会说到。

**如何构建回文自动机**

重点来了

之前已经介绍过，初始状态是有两个节点（0号和1号），它们的状态之前也已经说明。

我们从左往右加入字符串的每个字符

设$last$为上一次插入字符的节点编号，初始时$last = 0$

对于每个字符我们需要在回文自动机上找到以它结尾的最长回文子串。

对于字符$i$, 

```cpp
while(s[i - b[last].len - 1] != s[i])last = b[last].fail
```
这样求出的$last$即为新节点的父亲。

为什么呢？网上大多数dalao都说的很详细，还有高清大图。~~我比较懒~~我就大概讲讲自己的理解。

首先我们肯定要先考虑上一个位置在两边直接各加一个字符是否是回文串。

如果不是怎么办？那么我们就不停跳到它的最长回文后缀直到是回文为止。每次跳都能保证它是一开始$last$的一个回文后缀也就是指以$i - 1$结尾的回文子串，这样在它两边各加一个字符后，对应的一定是以当前字符为结尾的一个回文串。又由于每次都是跳最长的，所以第一次合法时取到的以$i$结尾的回文子串也一定是最长的。

这个过程什么时候结束呢？由于$len_1 = -1$，所以在跳到1的时候必然是自己等于自己，必然可以回文。

然后我们就像$trie$一样，在父亲下面生成孩子。

新孩子的$fail$怎么计算呢？它就是从它父亲的$fail$开始跳，跳到的第一个回文的位置。原因和上面类似，大家可以自己思考。

于是我们就愉快的建完了。

不同题目可能会需要在自动机上维护一些量。

比如

$num_i$:是$i$节点表示的回文串后缀的本质不同回文串个数

维护方法:$num_i = num_{fail_i} + 1$

$sum_i$:$i$节点表示的回文串出现的次数

维护方法:每次$sum_i++$,最后将$i$的值累加到$fail_i$上

还有一些其他的量，大都不难通过$fail_i$和$i$的父亲的值维护。

**复杂度：**

设$T =$ 字符集大小

则空间复杂度为$O(nT)$，时间复杂度为$O(n)$

（具体怎么证我也不知道qwq 背个结论吧）

如果空间需求太大可以使用指针~~也许也并没有什么用~~

**实现：**

**[【模板】回文自动机](https://www.luogu.org/problem/P3805)**

模板题。注意由于要求以$i$结尾，所以串长两两不等，这里的回文子串个数即为本质不同回文子串个数。
代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std; 

const int N = 2e6 + 5; 
struct PAM_Trie
{
	int ch[26]; 
	int fail, len, num; 
}; 
struct PAM
{
	PAM_Trie b[N]; 
	int n, length, last, cnt, s[N]; 
	char c[N]; 
	
	PAM()
	{
		b[0].len = 0; b[1].len = -1; 
		b[0].fail = 1; b[1].fail = 0; 
		last = 0; 
		cnt = 1; 
	}
	void read()
	{
		scanf("%s", c + 1); 
		length = strlen(c + 1); 
	}
	int get_fail(int x)
	{
		while(s[n - b[x].len - 1] != s[n])
		{
			//printf("%d %d %d\n", x, n - b[x].len - 1, b[x].fail); 
			x = b[x].fail; 
		}
		return x; 
	}
	void insert()
	{
		int p = get_fail(last); 
		if(!b[p].ch[s[n]])
		{
			b[++cnt].len = b[p].len + 2; 
			int tmp = get_fail(b[p].fail); 
			b[cnt].fail = b[tmp].ch[s[n]]; 
			b[cnt].num = b[b[cnt].fail].num + 1; 
			b[p].ch[s[n]] = cnt; 
		}
		last = b[p].ch[s[n]]; 
	}
	void solve()
	{
		int k = 0; 
		s[0] = 26; 
		for(n = 1; n <= length; n++)
		{
			c[n] = (c[n] - 97 + k) % 26 + 97; 
			s[n] = c[n] - 'a'; 
			insert(); 
			printf("%d ", b[last].num); 
			k = b[last].num; 
		}
	}
}P; 
int main()
{
	P.read(); 
	P.solve(); 
	return 0; 
}
```
有什么问题请指出qwq

---

## 作者：LightningUZ (赞：16)

博客观赏效果更佳： [Link](https://lightninguz2.github.io/2019/11/13/%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA-%E7%AC%94%E8%AE%B0/)

今天日常给同学@CollinGao 写奥♂义。讲到了这个东西，还是挺有用的，就是反复局限性有点大？没什么人知道的亚子。。。

还是很好理解的。虽然马上CSP了，但是我还是准备来颓废，写写这篇奥♂义。

## 基础题型

给你一个字符串，对于每个前缀，求该前缀中有多少前缀不同的回文子串。定义一个回文子串的权值为：长度乘以出现次数。对于每个前缀，也请你求出最大的回文子串的权值是多少。

## 回文自动机（又名回文树）是干啥的

大家都知道TRIE树（知道即珂，但是如果连听说都没听说过，那劝退了）。在TRIE树上，每个节点表示一个字符串，字符记录在边权上。连一条边表示在这个字符串后面加上一个字符。

那么，回文自动机是怎么弄的的？连一条边，表示在这个字符串前后各加上一个字符。比如某个父亲的字符串为"aba"，连了一条权值为'c'的边到儿子，儿子的字符串就是"cabac"。

然后要注意一点，回文自动机有**两个根**。其原因很显然，因为一个父亲以下的字符串长度的奇偶性不会改变，一次连边下去，长度$+2$，原本是奇数还是奇数，原本是偶数还是偶数，奇偶性不变。所以，两个根分别记录奇数长度和偶数长度的回文串，名字就叫奇根和偶根。偶根很显然，表示一个空串，其长度为$0$。那么，奇根怎么办呢？仔细一推，单个字符长度为$1$，其父亲的长度为其长度$-2$，也就是说，奇根表示的字符串长度为$-1$？！

没事，$-1$就$-1$，只不过是为了方便计算罢了。实际实现中，考虑到空间问题，我们并不会实际记录表示的字符串，只是记录一个长度$len$。那么，只要让这个点的$len=-1$即珂，一点问题都没有。当然，千万不要浪费时间去想象这个字符串长什么样。在这之前，请你作出一条长度为$-1$的线段（手动滑稽）。

### fail指针

精髓（准确来讲，是每个自动机的精髓）。对于一个节点，它的$fail$指针是指：除了自己之外，LPS（最长回文后缀的简称，Longest Palindrome Suffix）所对应的点。如果你仔细咀嚼了这句话，那么你会想这样一个问题：除了自己之外的最长回文子串一定能找到么？

#### 证明fail存在性

（如果您能自己证明，请跳过这段）
设当前节点表示字符串$s$，$fail$指向的节点所对应为$f$，$f^t$表示把$f$反过来，$|f|$表示$f$的长度，如图所示。
![](https://i.loli.net/2019/11/13/eVSqamtpQoL7jPb.jpg)

由于$S$是回文串（根据定义），$S$的前缀$|f|$个字符串和后缀$|f|$个字符串应该是相反的，即前缀$|f|$个字符串是$f^t$。但是$f$是个$LPS$，是个回文串，所以$f^t=f$。由此可见，$f$除了作为后缀出现，还作为前缀出现过。后面会讲到，我们会按$s$的每个字符插入，所以在插入$i$位置的时候，$[1,i)$之间的答案都求好了，换句话说，$[1,i)$中所有的回文串都出现在树上了。所以，一定存在一个节点表示$S$的$LPS$。

#### 证毕 $\blacksquare$

## 如何构建

上面讲了一下，我们是按照$[1,n]$的顺序插入$s$的每个字符的。对于插入第$i$个位置，我们的任务是找到其$LPS$，并把它插入到树上的正确位置。那么，如何找到呢？

我们要找到树上的这样一个节点：
1. 它是i-1位置的一个回文后缀
2. 它左右字符相等，都是$s[i]$

对于满足条件1，我们记录一个$last$，表示$i-1$插入在了树上哪个位置。（当我们插入完$i$的位置的时候，我们令它为我们找到的位置，即珂维护）

然后$last$显然就是$i-1$的一个回文后缀。但是我们要找到所有的回文后缀，那没问题，我们不断的跳$fail$即珂。

然后还要满足条件2。设现在我们跳到了点$cur$，这个点上的长度值为$len(cur)$。只要判断$s[i]==s[i-len(cur)-1]]$即珂。如果满足就退出，不满足就$cur=fail(cur)$，继续（用$while$循环）。

然后关于$fail$的维护，很简单，和上面找到父亲的过程只差一个$cur$初始值的区别。因为$fail$指针，相比于插入$i$位置，只多了一个条件：不等于自己。所以，$cur$的初始值，不是$father$，而是$fail(father)$。和找到父亲的步骤还有一点点不同，就是最后找到一个$cur$满足$s[i]==s[i-len(cur)-1]$的时候，返回的不是$cur$而是$cur$的边权为$s[i]$的儿子。

那么我们来举一个例子。我们要构建的字符串s="bilibili"。

初始化，构建奇根和偶根。红色是奇根，绿色是偶根。特殊地（忘了讲了），奇根和偶根的$fail$指针（黄色）指向对方。

第一步，插入位置$1$。默认是插入到$0$上，失败了再跳$fail$。我们发现，$s[1]!=s[1-len(0)-1]$，于是跳了$fail(0)=1$，然后显然$s[1]==s[1-len(1)-1]$。我们还发现，此时还缺一个节点，便新建一个节点（编号为$2$），把$2$接在奇根（$1$）下面。跳了几遍$fail$，发现$fail$是$0$。由于很多节点的$fail$都是$0$，这些边我就不连了。为了看起来美观。效果图：
![](
https://i.loli.net/2019/11/13/kmq6rTvUfVJGXbp.jpg)

时间关系，我们不仔细看每一个位置的插入过程，直接跳到第$5$个位置的插入。这之前的图建出来长这样：
![](https://i.loli.net/2019/11/13/amheuLwg48GFzDc.jpg)
然后我们大喊一声：**King Crimson！**
...

第五步，插入位置$5$，此时前缀为$bilib$。默认插入在$last$上，也就是编号$5$的位置。我们一下就满足了条件，所以我们的确要接在$last$下面。求一下$fail$指针，先到$fail(5)=3$试一下，发现，不行。然后跳到$fail(3)=0$试一下，还不行，跳到$fail(0)=1$再试一下，行了，返回$1$的边权为$s[i](='b')$的儿子，也就是编号为$2$的节点。完成之后，图长这样：
![](
https://i.loli.net/2019/11/13/sYxarf78JpCteRH.jpg)

让我们再大喊一声：**King Crimson!**

最终完成图：
![](https://i.loli.net/2019/11/13/aGIwxdMWVigoZfA.jpg)

然后我们这就构建好了一个回文自动机。

“我的讲义，能抄下来么？”
“能抄一点。”
“让我康康！”
“你看，这个fail边，应该连在儿子这里的。尽管你这样画很好看，但这个fail边就是这样连的，你不能改变它”
我心里还是有点不服气。图还是我画的好，至于这条边到底连在哪里，我自然是知道的。

—— 选自 鲁迅《藤野先生》


## 应用

我们讲了这么多，来解决些实际问题。

1. 本质不同的回文串个数
每个点（除了奇根和偶根）都一一对应一个本质不同的回文串。只要输出$cnt-1$即珂。（应该是点数-2，但是由于我是从0开始算点的，所以-1才是正确的）

2. 每个回文串的个数
每个点维护一个值$cnt$（重名了，但是因为命名空间不一样，写在struct里，所以不会报错）。然后插入一个点时，找到它所在的树上位置，该点上$cnt++$。最后再$cnt[fail(i)]+=cnt[i]$，i从$n$到$1$。和$KMP$中计算每个前缀出现的次数是类似的原理。

尝试一下：
1. 洛谷 板子 （5496）
2. [洛谷 5555](
https://www.luogu.org/problem/P5555)
3. [bzoj 3676](
https://www.lydsy.com/JudgeOnline/problem.php?id=3676)
4. 终于不是板子的：[CF17E](
http://codeforces.com/problemset/problem/17/E)

---

## 作者：约瑟夫用脑玩 (赞：8)

今天才知道很少有人知道非基于势能分析的 PAM，~~也就用来做做 GPAM 了~~。

考虑 PAM 的本质，一个节点是一个回文串，但它左边的字符不是固定的，比如回文串 $s$，无论是 $as$ 还是 $bs,cs$，都会找到 $s$ 对应的节点 $x$。

但是对于它的回文后缀 $t$ 就不一样了，由于 $t$ 比 $s$ 短，当 $s$ 确定时 $t$ 的左边的那个字符就确定了。

那么显然，$s$ 向外扩展了一个字符 $c$ 然后去找它所有回文后缀中最长且能匹配 $c$ 的这个过程是固定的。

我们失配找最长后缀回文串，也就是 $s$ 对应的节点 $x$ 固定，且扩展字符 $c$ 固定时，找到的串 $t$ 是确定的。

注意节点自身代表的串的左边一个是不确定的，记得特判，称一个节点 $x$ 的最长回文后缀（的节点）为 $fil_x$。

而且这个过程显然也是可以继承的，因为 $x$ 相比其最长回文后缀 $fil_x$ 只多了**一个**回文后缀，也就是 $fil_x$ 的那个回文串。

于是变化量是 $O(1)$ 的，我们直接修改那个变化量即可。

记 $flt_{x,c}$ 表示节点 $x$ 所代表的的串扩展一个字符 $c$ 找到的串。

那么首先继承 $flt_{fil_x}\to flt_x$，然后修改 $flt_{x,s_{|s|-len_{fil_x}}}=fil_x$ 即可。

注意到这个过程与可持久化线段树十分契合，可以配合一起用。

势能版：

```
	inline int Get(int x)
	{
		for(;ch[tot-len[x]-1]!=ch[tot];)x=fil[x];
		return x;
	}
	inline int Add(int c)
	{
		int now,p;
		ch[++tot]=c;
		if(!nxt[p=Get(lst)][c])
		{
			now=New(len[p]+2);
			fil[now]=nxt[Get(fil[p])][c];
			nxt[p][c]=now;
		}
		return lst=nxt[p][c];
	}
```

非势能版，这里是暴力继承的：

```
	inline int Get(int x)
	{
		return (ch[tot-len[x]-1]^ch[tot])?flt[x][ch[tot]]:x;
	}
	inline int Add(int c)
	{
		int now,p,f;
		ch[++tot]=c;
		if(!nxt[p=Get(lst)][c])
		{
			now=New(len[p]+2);
			f=fil[now]=flt[p][c];
			memcpy(flt[now],flt[f],sizeof(flt[now]));
			flt[now][ch[tot-len[f]]]=f;
			nxt[p][c]=now;
		}
		return lst=nxt[p][c];
	}
```

---

## 作者：chihik (赞：8)

不懂回文自动机的可以看[这篇博客](https://www.luogu.com.cn/blog/chihik/hui-wen-zi-dong-ji)。

现在默认大家都懂，用 $Cnt[i]$ 表示以 $i$ 结尾的回文串的个数。

由于 $Link[i]$ 表示 $i$ 的最长回文后缀，所以 $Cnt[i]=Cnt[Link[i]]+1$（加上 $i$ 点所标示的一个回文串）

在构造回文自动机时处理出来即可。

```cpp
#include <cstdio>
#include <cstring>

const int MAXN = 500000 , MAXK = 26;
char str[ MAXN + 5 ];
struct Palindrome_Automaton{
	int Size , Last , Root0 , Root1 , Trans[ MAXN + 5 ][ MAXK + 5 ] , Link[ MAXN + 5 ];
	int Len[ MAXN + 5 ] , Cnt[ MAXN + 5 ];
	
	Palindrome_Automaton( ) {
		Root0 = Size ++ , Root1 = Size ++; Last = Root1;
		Len[ Root0 ] = 0  , Link[ Root0 ] = Root1;
		Len[ Root1 ] = -1 , Link[ Root1 ] = Root1; 
	}
	void Extend( int ch , int dex ) {
		int u = Last;
		for( ; str[ dex - Len[ u ] - 1 ] != str[ dex ] ; u = Link[ u ] );
		if( !Trans[ u ][ ch ] ) {
			int Newnode = ++ Size , v = Link[ u ];
			Len[ Newnode ] = Len[ u ] + 2;
			
			for( ; str[ dex - Len[ v ] - 1 ] != str[ dex ] ; v = Link[ v ] );
			Link[ Newnode ] = Trans[ v ][ ch ] , Trans[ u ][ ch ] = Newnode;
			Cnt[ Newnode ] = Cnt[ Link[ Newnode ] ] + 1;
		}
		Last = Trans[ u ][ ch ];
	}
	
	void Build( char *str ) {
		int len = strlen( str );
		for( int i = 0 ; i < len ; i ++ ) {
			Extend( str[ i ] - 'a' + 1 , i );
			str[ i + 1 ] = ( str[ i + 1 ] - 97 + Cnt[ Last ] ) % 26 + 97;
			printf("%d ",Cnt[ Last ]);
		}	
	}
}PAM;

int main( ) {
	scanf("%s", str );
	PAM.Build( str );
	return 0;
}
```


---

## 作者：Terac (赞：7)

最近学了回文自动机这个神奇的东西，写篇文章加深下印象，如有不足或错误，欢迎指出。  

墙裂建议自行画图加深理解。

回文串的定义点[此](https://baike.baidu.com/item/%E5%9B%9E%E6%96%87%E4%B8%B2)。  

## 问题引入    

给定一个字符串 $s$，求以 $s$ 每个位置结尾的回文子串个数。  

如果用暴力枚举每个串的方式，时间复杂度可能是 $O(n^2)$ 或者更高，主要是花在寻找以新位置结尾的回文串的重新枚举上。  

回文串有个显然的性质，即去掉相同长度的前缀与后缀仍是回文串，利用这种包含关系，也许可以提高计算的效率。  

回文自动机利用了这个性质，可以 $O(n)$ 处理求本质不同回文子串个数的这类回文串题目。  

## 基本概念  

回文自动机，即 Palindrome Automaton（PAM），又名回文树。  

回文自动机由两颗树构成，分别有奇根和偶根，对应着长度为奇数和偶数的回文串，奇根编号是 $1$，偶根编号是 $0$。  

在回文自动机中，包含了所有的回文串，每个节点表示一个回文串，其信息存到边上，维护 $last$ 表示以上次插入的字符结尾的最长回文串对应节点，$last$ 初始值为 $1$。对于点 $x$，维护 $len_x$，表示 $x$ 代表的回文串长度。用 $ch_{x,\Sigma}$ 表示 $x$ 每条出边对应的儿子，类似 Trie。

特别地，$len_0=0,len_1=-1$，即偶根长度为 $0$，奇根长度为 $-1$。奇根长度 $-1$ 的妙处后文会提到。  

以回文串 $\texttt{abaabba}$ 为例，下图即为仅含回文树边的回文自动机。  

![](https://cdn.luogu.com.cn/upload/image_hosting/ce6b051l.png?x-oss-process=image/resize,m_lfit,h_2000,w_2000)  

某个点代表的回文串在图上的表示，是从奇根或偶根开始，经过一条转移边，即在回文串的前后各加一个相同的字符，这样对于回文串的表示显然是有正确性的。特别地，奇根所在树的节点回文中心的字符仅加一次。如路径 $1\rightarrow3\rightarrow4$ 表示的回文串是 $\texttt{aba}$，路径 $0\rightarrow5\rightarrow6$ 表示的回文串是 $\texttt{baab}$。  

因为每次转移会使其表示的回文串前后各扩展一个相同的字符，使长度加 $2$，所以对于点 $x$，若其父节点为 $fa$，则 $len_x=len_{fa}+2$。  

和其他自动机一样，回文自动机也有 $fail$ 指针，对于点 $x$，$fail_x$ 指向点 $x$ 代表的回文串最长的回文真后缀所对应节点，特别地，$fail_0=1,fail_1=1$。很多题解都说奇根的 $fail$ 指针没有意义，但在实现中指向自身要好处理。  

还是回文串 $\texttt{abaabba}$，下图即其完整的回文自动机。  

![](https://cdn.luogu.com.cn/upload/image_hosting/1p3cv24u.png?x-oss-process=image/resize,m_lfit,h_2000,w_2000)  

## 构造方法  

对于字符串 $s$，若已构造好前 $i-1$ 个字符的回文自动机，加入字符 $s_i$，从 $last$ 表示的回文串开始，然后不断跳 $fail$ 边，直到找到某个节点 $x$，使 $s_{i-len_x-1}=s_i$，即该节点表示的回文串上一个字符与待添加字符相同时，$s_{i-len_x-1}$ 至 $s_i$ 所构成的回文串即为以 $i$ 结尾的最长回文串。 

定义一个 $\text{getfail}$ 函数，$\text{getfail}(x,i)$ 返回的即为加入 $s_i$ 后满足上述条件的点 $x$。
```cpp
int getfail(int x, int i) {
	while(i - len[x] - 1 < 0/*判断边界*/ || s[i - len[x] - 1] != s[i]) x = fail[x];
	return x;
}
```  
这个正确性证明很显然，因为以 $i$ 结尾的长度不为 $1$ 的回文串，必定包含 $s_{i-1}$，又因为回文串去掉相同长度的前后缀仍是回文串，所以若以 $i$ 结尾的最长回文串长度不为 $1$，必定包含以 $i-1$ 结尾的回文串，可以通过 $fail$ 指针找到所有以 $i-1$ 结尾的回文串。  

以 $i$ 结尾的回文串中必有长度为 $1$ 的回文串，即 $s_i$ 单独成串，此时不包含 $s_{i-1}$，需单独处理。前文提到 $len_1=-1$，所以 $s_{i-len_1-1}=s_i$，即 $fail$ 指针指向奇根时，奇根会让下一次匹配到自身，显然符合，又因为所有节点的 $fail$ 指针都直接或间接指向奇根，也就保证了必定能找到满足条件的点 $x$，且 $i-1$ 结尾的回文串均可通过 $fail$ 指针找到，$\text{getfail}$ 的正确性得证。  

若 $x$ 现在有一条表示 $s_i$ 的出边，即已存在与 $i$ 结尾的最长回文串本质相同的节点，直接更新 $last$ 就好。若没有，则新建一个，再求它的 $fail$ 指针。还是先找到 $last$ 表示的回文串中满足两边扩展 $s_i$ 仍是回文串的回文后缀，发现和上文的求法是类似的，可以用 $\text{getfail}(fail_x,i)$ 来求出其满足条件的回文后缀所对应的节点。  

插入 $s_i$ 的代码如下：
```cpp
void insert(char c, int i) {
	int x = getfail(last, i), w = c - 'a';
	if(!ch[x][w]) {
		len[++cnt] = len[x] + 2;
		int tmp = getfail(fail[x], i);
		fail[cnt] = ch[tmp][w];
		//things to do
		ch[x][w] = cnt;
	}
	last = ch[x][w];
}
```  

注意设定父子关系是最后处理，原因是当 $ch_{tmp,w}$ 不存在时，即新建的节点的 $fail$ 未匹配到，因 $ch_{twp,w}$ 初值为 $0$，$fail_{cnt}$ 会被设为 $0$，即新建的节点 $fail$ 指针指向偶根，$len_0=0$，空串显然可行。  

## 复杂度证明

证明过程和 KMP 很相似。  

可以证明，对于一个字符串 $s$，它的本质不同回文子串个数最多只有 $|s|$个（然而我不会，网上应该都有）。  

因为回文自动机上每个节点代表的回文串均不同且包含了 $s$ 所有的回文串，所以最多有 $|s|$ 个节点，令 $n=|s|$。  

若不计 $\text{getfail}$ 复杂度，其它操作复杂度 $O(n)$ 比较显然。  

因为 $fail$ 指向的是回文真后缀，所以长度必更小，跳 $fail$ 边深度单调非递增，且同一深度最多跳两次 $fail$ 边（奇根所在树与偶根所在树），因每次新建节点 $fail$ 指针指向节点深度只会加 $1$，所以最多可跳 $2n$ 次 $fail$ 边。  

总时间复杂度 $O(n)$，空间复杂度为 $O(n\Sigma)$。  

## 例题  

以[模板题](https://www.luogu.com.cn/problem/P5496)为例。  

用 $sum_x$ 表示答案，显然以 $i$ 结尾的回文串个数即以 $i$ 结尾的最长回文串的最长回文真后缀的回文串个数，即 $sum_x=sum_{fail_x}+1$。

代码如下：  

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 10, Sigma = 26;
char s[N];
int lastans, n;
struct Palindrome_Automaton {
	int ch[N][Sigma], fail[N], len[N], sum[N], cnt, last;
	Palindrome_Automaton() {
		cnt = 1;
		fail[0] = 1, fail[1] = 1, len[1] = -1;
	}
	int getfail(int x, int i) {
		while(i - len[x] - 1 < 0 || s[i - len[x] - 1] != s[i]) x = fail[x];
		return x;
	}
	void insert(char c, int i) {
		int x = getfail(last, i), w = c - 'a';
		if(!ch[x][w]) {
			len[++cnt] = len[x] + 2;
			int tmp = getfail(fail[x], i);
			fail[cnt] = ch[tmp][w];
			sum[cnt] = sum[fail[cnt]] + 1;
			ch[x][w] = cnt;
		}
		last = ch[x][w];
	}
	
} PAM;
int main() {
	scanf("%s", s + 1);
	int len = strlen(s + 1);
	for(n = 1; n <= len; n++) {
		s[n] = (s[n] - 97 + lastans) % 26 + 97;
		PAM.insert(s[n], n);
		printf("%d ", lastans = PAM.sum[PAM.last]);
	}
	return 0;
}
```  

还有一些简单题： 

[P4555 [国家集训队]最长双回文串](https://www.luogu.com.cn/problem/P4555)  

[P4287 [SHOI2011]双倍回文](https://www.luogu.com.cn/problem/P4287)  

[P3649 [APIO2014]回文串](https://www.luogu.com.cn/problem/P3649)

---

## 作者：zac2010 (赞：5)

## 定义

回文自动机（回文树），一种有限状态自动机，一种可以存储一个串中所有回文子串的高效数据结构。可以简单高效地解决众多与字符串回文相关的问题。

## 记号与约定

下文中，$s$ 是一个长为 $n$ 字符串，$s'$ 为 $s$ 的倒串（翻转后的串），$s[l,r]$ 是 $s$ 的一个子串（下标从 $1$ 开始）。

特殊情况见上下文说明。

## 一些性质

> 引理 $1.1$：一个回文串 $s$ 的 $\text{border}$ 必定是一个回文串。
>
> 引理 $1.2$：一个回文串 $s$ 的所有回文后缀必定是它的 $\text{border}$。

证明 $1.1$：

* 钦定一个 $s$ 的 $\text{border}$ 为 $s[n-i+1,n]$。

* 根据 $\text{border}$ 的性质，$s[1,i]=s[n-i+1,n]$；根据 $s$ 作为回文串的性质，$s[1,i]=s'[n-i+1]$。故而有 $s[n-i+1,n]=s'[n-i+1,n]$，而它恰好是回文串的定义。

证明 $1.2$：可以把引理 $1.1$ 的证明方法倒回去。

> 引理 $2$：对于一个字符串 $s$，它本质不同的回文子串一定是以某个点结尾的、最长的那个回文串。

证明 $2$：考虑反证。假设本质不同的回文子串是以某个点结尾的，但不是最长的回文串，那么根据引理 $1.2$ 以及 $\text{border}$ 的性质（$s$ 的 $\text{border}$ 的 $\text{border}$ 也是 $s$ 的 $\text{border}$），它必定已被统计过了。

> 引理 $3$：$s$ 的本质不同的子串个数不超过 $n$ 个。

证明 $3$：根据引理 $2$ 可得。

## 结构

$\text{PAM}$ 和 $\text{ACAM}$ 类似，它可以用树的形式展现出来：$\text{Trie}$ 树或 $\text{fail}$ 树。

不难注意到按照传统的 $\text{Trie}$ 树，已经难以去方便地处理回文串了。

故而考虑 $\text{Trie}$ 树的变形：

* 初始时有两个节点，它们所代表的串一个长度为 $0$（用于处理偶回文），一个长度为 $-1$（用于处理奇回文）。

* 对于一个节点连出的边权 $c$ 的边，就等价于在当前节点所代表的串两边各加上一个字符 $c$。

$\text{fail}$ 树自然也跟着有了变化：

* 对于一个节点的 $\text{fail}$ 指针，它指向的是当前节点的最长回文后缀。
* 其中为了后续处理方便，我们让串长为 $0$ 的节点 $\text{fail}$ 指向串长为 $-1$ 的节点。

## 构建方式

我们采用地构建方法是逐个插入。逐个插入一般有两种：首端/末端插入。

考虑末端插入字符 $c$：

1. 以 $i-1$ 结尾的最长回文子串为开始，一直跳 $\text{fail}$ 指针，直到跳到一个合法的节点或者不能再跳了。

   “合法”的定义：一个节点是合法的当且仅当它所代表的串是合法的，一个串是合法的当且仅当位于它左边的字符是 $c$，这样就可以形成一个以新插入字符结尾的回文串。

2. 判断当前跳到的节点是否是合法的节点。若是合法的节点，那就插入一个新节点，同时维护一下它的信息。不是就不插入。

   * Note：会发现，对于为什么要像介绍 $\text{PAM}$ 结构时提到的那样：“让串长为 $0$ 的节点 $\text{fail}$ 指向串长为 $-1$ 的节点”，现在已经有了答案。

     假设跳 $\text{fail}$ 指针时，一直跳都没有找到合法的节点，且最后落到了串长为 $0$ 的那个节点上。若那个串长为 $0$ 的节点也是不合法的，这种情况显然是没法插入一个新节点，而实际上它应该插入一个长为 $1$ 的串。 


再考虑首端插入。根据引理 $1.2$，字符串的最长回文后缀等价于字符串的最长回文前缀，故而首端插入和末端插入如出一辙。

## 代码实现

```cpp
#include <bits/stdc++.h>
#define L(i, a, b) for(int i = a; i <= b; i++)
#define R(i, a, b) for(int i = a; i >= b; i--)
using namespace std;
const int N = 5e5 + 10;
int n, ans; char s[N];
struct PAM{
	int n, tot, lst, s[N];
	struct P{int t, len, f, c[26];} a[N];
	PAM(){tot = 1, s[0] = 26, a[0].f = 1, a[1].len = -1;}
	int getfail(int x){
		while(s[n - a[x].len - 1] != s[n]) x = a[x].f;
		return x;
	}
	void ins(int d){
		s[++n] = d; int p = getfail(lst);
		if(!a[p].c[d]){
			a[++tot].len = a[p].len + 2;
			a[tot].f = a[getfail(a[p].f)].c[d];
			a[tot].t = a[a[tot].f].t + 1;
			a[p].c[d] = tot;
		}
		lst = a[p].c[d];
	}
} p;
int main(){
	scanf("%s", s + 1), n = strlen(s + 1);
	L(i, 1, n){
		p.ins((s[i] - 97 + ans) % 26);
		ans = p.a[p.lst].t, printf("%d ", ans);
	}
	return 0;
} 
```


---

## 作者：王大神——A001 (赞：2)

[传送门](https://www.luogu.com.cn/problem/P5496)

前置思想：[manacher](https://wdsa001.github.io/2021/09/03/manacher-suan-fa/)

## 回文自动机
题目让我们求以每个字符结尾的回文串有多少个（注意给的原串需要**解密**）。

`manachar` 算法将回文的边界提出缩短了使得效率比暴力要高，但是并没有实现串与串之间的关系连接。而实现串之间的关系，就会想到要用 [`trie`](https://wdsa001.github.io/2021/09/06/zi-dian-shu-ac-zi-dong-ji/#toc-heading-1) 树，然后通过字符串之间的关系配置失配指针，然后形成 `trie` 图或者说自动机来解决问题。

那么如何建立回文的自动机？

首先我们知道回文串分为两种：长度为奇，长度为偶。（按长度区分，长度为奇的回文串的回文中心是一个字符，而长度为偶的字符串回文中心是两个字符之间的位置。）

那么了解这个性质后，我们有了两棵树：

![奇偶串树](https://s4.ax1x.com/2021/12/20/Tntrj0.png)

（这里为了方便理解没有增加更多的枝干）

首先有两个根区分了奇偶串，并在长度旁边标注了字符串的长度。（注意：奇根的长度是 $-1$，这是为了名在后面合并的时候，可以直接和偶根树合并到，长度可以直接增加相同的 $2$，而不是再分类讨论。）

这时枝干的字符为两边增加的字符（相当于给回文串劈开讨论）。奇偶根树路径合并（路径相同的串）。

![串合并](https://s4.ax1x.com/2021/12/20/TntDcq.png)

红色虚线是说明虽然在一条枝干上，但是奇偶串的奇偶性并没有变，由于我们的奇根设置的是 $-1$ 所以可以直接接上。（其实这里的合并并不是真的合并，只为了更方便理解失配指针）。

![快速匹配](https://s4.ax1x.com/2021/12/20/Tn0O58.png)

（有些失配指针没画全，只挑几个有代表性的画了，方便理解）。

但是其中的性质其实并不难：应为我们要找的是**当前位置的字符**结尾的回文串，那么一定知道，结尾的字符是不变的，所以我们只要找到失配指针指向的结尾字符相同的地方才会匹配成功，其他字符就不用考虑了。失配指针就是每回找到**已经匹配成功的字符串中结尾（或者说开头）和当前字符相同的回文串**，进行比对，这样一旦匹配不成功，也是直接跳到记录的地方再进行比配，如果实在没有匹配成功或者没有记录，就会开新节点记录以备下次的使用。

### 代码
```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<queue>
using namespace std;
int r_r(){//快读 
	int x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(isdigit(c)){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
const int o_o=2e6+10;
int n;//字符长度 
char s[o_o];//原串 
int l_n[o_o];//该节点表示的已经匹配成功的回文字符串长度 
int s_m[o_o];//x 节点每个回文串出现次数（即统计的答案） 
int f_l[o_o];//失配指针 
int m_l;//失配指针中能匹配到的最长回文后缀 
int k_k;//记录中找到的最长回文后缀的点的标号 
int t_r[o_o][26];//记录儿子节点 
int x_p=1;//节点数（用来建新节点） 
int g_f(int x,int i){//处理失配指针 
	while(i-l_n[x]-1<0||s[i-l_n[x]-1]!=s[i])x=f_l[x];
	//比较串头和当前字符比较 
	//往回跳，找到能匹配的位置 
	
	return x;//返回找到的编号 
}
int main(){
	scanf("%s",s);//读入子串 
    n=strlen(s);//计算长度 
    f_l[0]=1;//初始化失配指针 
	l_n[1]=-1;//初始化奇节点的值 
    for(int i=0;i<=n-1;i++){
    	if(i>=1)s[i]=(s[i]+s_m[m_l]-97)%26+97;//解密码 
    	
		//找到 m_l 的失配指针中能匹配到的最长回文后缀 
    	k_k=g_f(m_l,i);
		
        if(!t_r[k_k][s[i]-'a']){//没有建过点，建点 
        	f_l[++x_p]=t_r[g_f(f_l[k_k],i)][s[i]-'a'];
        	//记录上次能匹配成功的地方，失配了直接过去 
			//建新节点更新失配指针 
        	 
			t_r[k_k][s[i]-'a']=x_p;//接儿子 
        	l_n[x_p]=l_n[k_k]+2;//更新长度（每回左右同时扩展，长度增加 2） 
            s_m[x_p]=s_m[f_l[x_p]]+1;//更新结果（回文串的个数） 
		}
        m_l=t_r[k_k][s[i]-'a'];//建过点，直接用 
		printf("%d ",s_m[m_l]);//输出 
	}
	return 0;
}
```


---

## 作者：hyfhaha (赞：2)

PAM回文自动机

广告：建议先学习AC自动机：[AC自动机讲解超详细](https://www.cnblogs.com/hyfhaha/p/10802604.html) 

回文自动机，顾名思义，用来处理回文串的自动机。

## 功能：

1.求$S$串内本质不同的回文串个数

2.求$S$串内本质不同的回文串出现次数

3.最小回文划分

4.$S$串中以下标$i$结尾的最长回文串长度

## 回文树

![](https://img2020.cnblogs.com/blog/1593693/202009/1593693-20200911214341133-576021393.png)

看看自己感悟一下。感觉特别形象，都不用解释了啊

还是稍微解释一下：

1.回文数上每一个节点代表了原串上出现过的一个本质不同回文子串，原串上的每一个回文子串都在回文树上有对应。回文树上每一个点代表的串都是回文串。

2.回文树分两部分，奇和偶，奇树上的点代表的回文串长度为奇数，偶树上的为偶

3.儿子节点代表串长度为父亲节点代表串长度$+2$ 

4.和$Trie$相似的其他性质，不说了

## Fail指针

学过AC自动机的OIer们应该就很熟悉啦QwQ

$Fail$指针含义：这个节点所代表的回文串的**最长回文后缀** 

## Trans指针

一般做许多PAM题目常用的东西

$Trans$指针含义：小于等于当前节点长度**一半**的**最长回文后缀** 

## 构建PAM

我们要维护以下信息

```cpp
char s[maxn];		//原串
int fail[maxn];		//fail指针
int len[maxn];		//该节点表示的字符串长度
int tree[maxn][26];	//同Trie，指向儿子
int trans[maxn];	//trans指针
int tot,pre;		//tot代表节点数，pre代表上次插入字符后指向的回文树位置
```

其中$fail,len,tree,trans$为PAM上的信息

构建PAM的方法为增量，即一个一个加入字符构建PAM

奇树和偶树的根长度$len$分别为$-1$和$0$ 

设当前我们插入原串中$i$位置的字符$u$ 

那么以$i$为结尾的最长回文串应该为(以$i-1$为结尾的最长回文串$+u$)，并且那个回文串要满足前一个字符等于$u$（不然就不是回文串了啊）

要找到那个点非常简单，不断从$pre$开始跳$fail$，直到找到一个满足$s[i-len[x]-1]==u$ 的节点$Fail$ ，那么从$Fail$建一个$u$儿子即可以表示新的回文串。

新点的$fail$怎么求呢。

明显为从$pre$开始跳$fail$，找到 **{** **[** 第二个 **(** 满足$s[i-len[x]-1]==u$ **)** 的节点$x$ **]** 的$u$儿子 **}** 

也就是从$Fail$开始跳$fail$，找到 **{** **[** 第一个 **(** 满足$s[i-len[x]-1]==u$ **)** 的节点$x$ **]** 的$u$儿子 **}** 

跳到根记得判断

**特别提醒**:节点$1$为奇根，节点$0$为偶根，$fail[0]=1$ , $len[1]=-1$ 

时间复杂度证明参考OIwiki：[OIwiki-PAM](https://oi-wiki.org/string/pam/#_2)

放代码理解：

```cpp
int getfail(int x,int i){		//从x开始跳fail，满足字符s[i]的节点
	while(i-len[x]-1<0||s[i-len[x]-1]!=s[i])x=fail[x];
	return x;
}
void insert(int u,int i){
	int Fail=getfail(pre,i);		//找到符合要求的点
	if(!tree[Fail][u]){		//没建过就新建节点
		len[++tot]=len[Fail]+2;	//长度自然是父亲长度+2
		fail[tot]=tree[getfail(fail[Fail],i)][u];	//fail为满足条件的次短回文串+u
		tree[Fail][u]=tot;		//认儿子
	}
	pre=tree[Fail][u];		//更新pre
}
```

至于$trans$维护也和$fail$差不多

根据$trans$的定义去推一下怎么搞吧

放一下完整代码：

```cpp
char s[maxn];		//原串
int fail[maxn];		//fail指针
int len[maxn];		//该节点表示的字符串长度
int tree[maxn][26];	//同Trie，指向儿子
int trans[maxn];	//trans指针
int tot,pre;		//tot代表节点数，pre代表上次插入字符后指向的回文树位置
int getfail(int x,int i){		//从x开始跳fail，满足字符s[i]的节点
	while(i-len[x]-1<0||s[i-len[x]-1]!=s[i])x=fail[x];
	return x;
}
int gettrans(int x,int i){
	while(((len[x]+2)<<1)>len[tot]||s[i-len[x]-1]!=s[i])x=fail[x];
	return x;
}
void insert(int u,int i){
	int Fail=getfail(pre,i);		//找到符合要求的点
	if(!tree[Fail][u]){		//没建过就新建节点
		len[++tot]=len[Fail]+2;	//长度自然是父亲长度+2
		fail[tot]=tree[getfail(fail[Fail],i)][u];	//fail为满足条件的次短回文串+u
		tree[Fail][u]=tot;		//指儿子
		if(len[tot]<=2)trans[tot]=fail[tot];	//特殊trans
		else{
			int Trans=gettrans(trans[Fail],i);	//求trans
			trans[tot]=tree[Trans][u];
		}
	}
	pre=tree[Fail][u];		//更新pre
}
```
### [此题](https://www.luogu.com.cn/problem/P5496)

求第 *i* 个整数表示原串以第 *i* 个字符结尾的回文子串个数，强制在线

明显：一个回文串的答案等于其最长回文后缀的答案$+1$ （这超好理解的吧

那就在多维护一个信息$ans$表示答案，新建节点时更新即可

`ans[tot]=ans[fail[tot]]+1;` 

答案为`lastans=ans[pre];` 

代码：

```cpp
#include<bits/stdc++.h>
#define maxn 510001
using namespace std;
char s[maxn];
int fail[maxn],len[maxn],ans[maxn],trie[maxn][26];
int pre,slen,lastans,tot;
int getfail(int x,int i){
	while(i-len[x]-1<0||s[i-len[x]-1]!=s[i])x=fail[x];
	return x;
}
int main(){
	scanf("%s",s);slen=strlen(s);
	fail[0]=1;len[1]=-1;tot=1;
	for(int i=0;i<slen;i++){
		if(i>=1)s[i]=(s[i]-97+lastans)%26+97;
		int u=s[i]-'a';
		int Fail=getfail(pre,i);
		if(!trie[Fail][u]){
			fail[++tot]=trie[getfail(fail[Fail],i)][u];
			trie[Fail][u]=tot;
			len[tot]=len[Fail]+2;
			ans[tot]=ans[fail[tot]]+1;
		}
		pre=trie[Fail][u];
		lastans=ans[pre];
		printf("%d ",lastans);
	}
	return 0;
}
```
更多内容请看：[PAM学习小结](https://www.luogu.com.cn/blog/juruohyfhaha/pam-xue-xi-xiao-jie)

至于上图那个可以生成PAM的东西，我也放博客里了QwQ

---

## 作者：zplqwq (赞：1)

很多人拿这个 PAM 和 ACAM 做对比，我觉得是不大妥当的，个人认为 PAM 的操作和 SAM 更像一点，可能因为实现与 ACAM 类似所以把他们放在一起吧。

我这里默认读者会 SAM。

首先，在 SAM 里我们维护了一个 `link` 即最长后缀，在这里我们 `link` 维护的是最长回文后缀。例如在 `ababa` 这个串中，他的 `link` 指向的就是 `aba` 。这个 `link` 也就是很多题解中说的 `fail` 指针。

接下来，在 SAM 里我们每一个节点是一个根据 `endpos ` 维护的等价类。在 PAM 里我们考虑维护每一个节点所代表的回文串长度。

最后考虑维护一个 `cnt` ，表示的是以当前节点为结尾的回文串个数。

对于奇回文和偶回文的处理，我们考虑把偶回文的 `link` 都指向奇回文，奇回文的 `link` 指针就可以不管了。因为奇回文有中心，因此一定可以向两边扩展。

然后实际上就结束了，以上就是回文自动机的所有操作。

到这里读者可能会发现，维护以上操作的过程跟 ACAM 非常类似，因此 PAM 的代码也确实跟 ACAM 很类似。

接下来我们看一下代码。

```cpp
int getfail(int x,int i)
{
	while(i-len[x]-1<0 or s[i-len[x]-1]!=s[i])x=fail[x];//跳 fail (link) 指针
	return x;
}
void init()
{
    fail[0]=1;len[1]=-1;//这个是初始化，注意 len1 这里复制为 -1 是为了方便奇回文统计
}
void extend(int i)
{
    pos=getfail(cur,i);
    if(!trie[pos][s[i]-'a'])
	{
        fail[++tot]=trie[getfail(fail[pos],i)][s[i]-'a'];
        trie[pos][s[i]-'a']=tot;//建 trie
        len[tot]=len[pos]+2;//这里加 2 要注意一下，因为每次扩展的时候肯定是向两边扩展，因此一定是加 2
        cnt[tot]=cnt[fail[tot]]+1;
	}
    cur=trie[pos][s[i]-'a'];
   // cout<<i<<endl; 
    k=cnt[cur];// 统计以 cur 结尾的回文子串个数
}

```
对于这道题，我们统计每一个节点为结尾的回文子串个数，然后输出即可。

加密的话注意一下，第一个是不需要加密的。

```cpp
  for(int i=1;i<=n;i++)
	{
    	if(i>=2)s[i]=(s[i]+k-97)%26+97; 
    	extend(i)
		cout<<k<<" ";	   
	}
 ```


---


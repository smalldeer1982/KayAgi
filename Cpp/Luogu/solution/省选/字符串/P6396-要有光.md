# 要有光

## 题目背景

$$ \text{Der mir zeigt wo ich bin}$$   
$$_\texttt{告诉我身在何方}  $$
$$\text{Divano}$$   
$$_\texttt{神啊}$$  
$$\text{Sei mein Licht}  $$
$$_\texttt{做我的光}$$
$$\text{Ich sm chte mich dir schenken}$$  
$$_\texttt{我愿将自己赐予与你}$$
$$\text{Noch vor dem Sonnenaufgang}$$  
$$_\texttt{在晨曦来临之前}$$


&emsp;&emsp;那时正值春深，丛林里生灵闹哄哄地雀跃，享受着空气中升腾的灵气。  
&emsp;&emsp;“嗖”的一声，一团银灰色的小东西突然从她眼前的地面划过，要不是腾起的尘土在阳光下悠闲地闪烁，她甚至怀疑是自己花了眼。  
&emsp;&emsp;紧接着，又“嗖”的一声，这次她看清楚了，是一只雪白的幼龄狐妖，“还……有点可爱。”  
&emsp;&emsp;“真走运，捉了这只，就可以交差啦。”她，虽年少却赫赫有名的除妖师，绫，急忙跟了上去。

## 题目描述

万物有灵，法术亦是如此。任何法术都等价为一段**仅包括大小写字母**的字符串 $S=s_1s_2\dots s_n$，现规定如下几种法术记号：

- **元素**。即字符串中的每个字符。在本题中，元素仅为大小写字母。
- **法术大小**。即字符串长度。记号为 $|S|$ 。
- **空法术**。大小为 $0$ 的法术为空法术。
- **等法术**。对于法术 $S,T$ 。当且仅当 $|S|=|T|,\forall i \leq |S| , s_i = t_i$ 时，称 $S$ 与 $T$ 为等法术，记为 $S=T$  。
- **逆法术**。设现有法术 $S=s_1s_2\dots s_n$，称法术 $T$ 是 $S$ 的逆法术，当且仅当 $|S|=|T|$ 且 $\forall i \leq |S| , s_i=t_{n-i+1}$。本题将 $T$ 记作 $S_r$。
- **逆法术对**。称两法术 $S$，$T$ 构成逆法术对 $(S,T)$，当且仅当 $T=S_r$。
- **归法术**。设现有法术 $S$，称 $S$ 为归法术当且仅当 $S$ 对应的字符串为**回文串**。特别地，**空法术被视作归法术**。
- **子法术**。设现有法术 $S$ ，则对于 $1\le i\le j\le |S|$ ，称 $T=s_is_{i+1}\dots s_j$ 为 $S$ 的子法术，并规定子法术的记号 $S[i,j]$ 。当 $i>j$ 时，$S[i,j]$ 为空法术。

---

现在，绫有一个法术源 $S_0$, 而她已经凝练出了一个初始的法术 $S=S_0$。对于每种妖魔，都有一个法术弱点  $T$。绫的法术性火，而火系法术又以淬光之术为上等。所以绫想要练习淬光之术。只要绫通过以下淬光法术变换使 $S=T$，就能轻易击败妖魔：

- **光归**。对于**任意非空法术** $S$，保留其**最大归法术后缀**。若$|S|=n$即取一个最小的 $i \in [1,n]$ 使得 $S[i+1,n]$ 为归法术，并令 $S \leftarrow T$。**允许 $T$ 为空法术**。消耗时间 $A$。
- **光辉**。对于**归法术** $S$，在 $S_0$ 中寻找一个**子归法术** $T$，满足 $S$ 为 $T$ 的**最大归法术后缀**（其定义见 "光归" ），并令 $S\leftarrow T$。**空法术**被认为是**任何法术的后缀**。消耗时间 $B$。
- **光隐**。对于**非空归法术** $S$，$|S|=n$ 删去其长度相等且长度**不大于 $k$ **的**前缀与后缀**。即取一个 $i\in[1,\min\{k,\lfloor\frac{n-1}2\rfloor\}]$，使 $T=S[1+i,n-i]$，并令 $S\leftarrow T$。特别地，$T$ **不可以为空法术**，消耗时间 $C$。
- **光腾**。对于**非空归法术** $S,|S|=n$，在其左右加上一对逆法术对。即取一逆法术对 $(P,Q)$，设 $|P|=|Q|=l$，使 $T=p_1p_2\dots p_ls_1s_2\dots s_nq_1q_2\dots q_l$，且 $T$ **须为 $S_{0}$ 的子法术** ，并令 $S\leftarrow T$。消耗时间 $D$。
- **光弋**。对于**任意非空法术** $S,|S|=n$ ，在其前端加入任意元素。即取一个元素 $a$，使 $T=as_1s_2\dots s_n$，并令 $S\leftarrow T$，消耗时间 $E$。光弋变换玄妙莫测，绫还没有熟练掌握此法术变换。所以**在使用此变换之后，无法再使用其它类型的法术变换**。

现在绫想知道，对于不同妖魔的法术弱点 $T$，自己至少要消耗多少时间进行如上法术变换使 $S=T$。**每组询问间互不干扰**。


## 说明/提示

#### 样例解释 #1

对于第一个询问，因为 $T=\texttt{"ababa"}=S$，不需要操作。

对于第二个询问，$T=\texttt{"ba"}$，最优策略为先使用一次**光隐**，得到 $S'=\texttt{"a"}$；接着使用一次**光弋**，在 $S'$ 前添加元素 $\texttt{'b'}$ 得到 $S''=\texttt{"ba"}=T$，耗时 $4+1=5$。
 
对于第三个询问，$T=\texttt{"aba"}$，最优策略为使用一次**光归**，得到 $S'=\texttt{"aba"}=T$。耗时 $3$。

------------
#### 数据范围
对于不同的测试点，我们约定数据规模如下:

| 测试点编号 | $\left\vert S \right\vert,\left\vert T \right\vert \le$ | $q\le$ | 特殊限制 |
|:-:|:-:|:-:|:-:|
| $1 \sim 5$ | $10^3$ | $10^3$ | 无 |
| $6 \sim 9$ | $10^5$ | $10^5$ | 初始法术只有一种元素 |
| $10 \sim 20$ | $10^5$ | $10^5$ | 无 |

对于 $100\%$ 的数据，$1 \le q,|S| \leq 10^5$，$1 \leq A,B,C,D,E \leq 10^9$，$1 \leq l \leq r \leq |S|$，$1 \leq k \leq 5$。

------------
### 题目背景 ( 续 )
&emsp;&emsp;这边，绫还在摸索着变换法术，却感觉腰间的令牌被抓了一下。“喂？！”  
&emsp;&emsp;只见一个披头散发的少女正半跪着扒在她的腰间，左手还提着银灰色毛发的小兔子的一对耳朵，“你……是刚才那只狐狸？”绫尴尬地收回法术，不自觉地伸出手揉了揉少女头顶雪白的兽耳，心想着这只狐狸精得有多傻。“我可是除妖师哟，你不怕吗？”  
&emsp;&emsp;“……绫？”少女并没有理会绫的话，只是努力地认出了令牌上刻着的名字。  
&emsp;&emsp;绫好奇的目光撞上了少女璀璨的碧绿双眸，又不经意间扫过小巧的鼻梁，玲珑的小嘴，白皙的脖子，但再随着如凝的肌肤滑下……  
&emsp;&emsp;一直被视作男儿的绫哪见过这般风景，只觉得自己大脑当了机，还隐约嗅到出自鼻腔的铁锈味儿，身体便向后靠倒在一棵树干上，连忙用双手捂住滚烫的脸颊。  
&emsp;&emsp;“绫？绫？你怎么啦？！”少女心急地凑上去，绫吓得下意识往后退，却忘记身后是一棵粗壮的树干。“欸，绫手上的，是血吗……”双眼紧闭的绫听得出来少女像是被吓到了，看来还是一只没开过荤的狐狸精呢。  
&emsp;&emsp;“绫……你没事吧……”少女分明带着哭腔，小心翼翼地学着自己还是小狐狸的时候妈妈照顾自己的方式，在绫的身上东摸西摸。  
&emsp;&emsp;“我，我没事……”绫已经不敢想象究竟是哪些部位在触碰自己的皮肤了，“你……你先变回狐狸……快！”绫当然想把少女推开，却又怎么敢伸出手触碰少女呢？  
&emsp;&emsp;少女闻言，一怔，但还是乖乖变回了一只狐狸，还不忘叼起几欲逃走的兔子。  
&emsp;&emsp;绫赶忙收拾了自己的窘相，惊恐地扶着树干，确认自己的人身安全后，轻轻捏住小狐狸的后颈，提起在地上的两小只。  
&emsp;&emsp;“以后不许再胡乱变成人形了，听到没有！”绫后怕地警告着小狐狸，却见右手的小狐狸直勾勾地盯着左手的小兔子，而左手的小兔子好像想钻进自己的手心里，哪有听她的话呀……  
&emsp;&emsp;“哎，算了……”绫把小狐狸放在肩头，把似乎吓晕的小兔子递给她，“一会儿再吃哦。”（雨兔兔：我好难qwq。）  
&emsp;&emsp;“就算……捡了一只宠物吧。”绫心里想着。  

&emsp;&emsp;（未完待续www……）

## 样例 #1

### 输入

```
ababa
2
3 2 4 2 1
3
1 5
2 3
1 3```

### 输出

```
0
5
3```

## 样例 #2

### 输入

```
aaaaaa
1
3 1 4 1 10
2
2 4
2 3```

### 输出

```
7
8```

# 题解

## 作者：Clever_Jimmy (赞：15)

> update: 已更正一处错误，不应称之为“虚树”，而是“优化建图”。

我简述了一下题意，若不想看 **冗长** 的题面的，可以看一下。

### 题意简述：

给定一个字符串 $S_0$，有 $q$ 组询问，每次问由 $S_0$ 变为 $S_0[l \ldots r]$ 所需要经过的最小花费。

操作 1：$S \gets T$，其中 $T$ 为 $S$ 的最长回文后缀，此操作花费为 $A$；

操作 2：$S \gets T$，其中 $S$ 为 $T$ 的最长回文后缀，且 $T$ 为 $S_0$ 的子串，此操作花费为 $B$；

操作 3：对于非空的 $S \gets T$，其中 $T$ 为 $S$ 删除长度 **不大于** $k$ 的前缀与后缀得到的，此操作花费为 $C$；

操作 4：对于非空的 $S \gets T$，其中 $T$ 为 $S_1+S+\overleftarrow{S_1}$，且 $T$ 为 $S_0$ 的子串，此操作花费为 $D$；

操作 5：对于非空的 $S \gets T$，其中 $T$ 为 $c + S$，$c$ 为任意字符，且 **使用此操作后，在以后的操作中，不允许再使用其他操作**，此操作花费为 $E$；

对于 $100\%$ 的数据，保证 $1 \le \left|S_0\right|, q \le 10^5$，$1 \le \left|\Sigma\right| \le 52$。

### 解题思路：

#### 操作 1

直接连 $(i, fail_i)$，边权为 $A$ 的边即可。

#### 操作 2

直接连 $(fail_i, i)$，边权为 $B$ 的边即可。

#### 操作 3

预处理出 $i$ 的父亲 $fa_i$，然后连 $k$ 条 $(i, fa_i)$，边权为 $C$ 的边。

#### 操作 4

这个操作，本质上是从 $i$ 以 $D$ 的代价转移到 $i$ 子树中的任意一个结点。

但是，考虑到 $i$ 的子树可能会非常大，依次连接于边数或是时间复杂度上均不合理。

考虑优化建图的思想，对每个点建立一个对应的虚点，而虚点 **只能往儿子的方向** 转移（花费为 $0$）。

那么，连一条 $(i, i')$，边权为 $D$ 的边，以及 $(i', i)$，边权为 $0$ 的边即可。

#### 操作 5

操作 5 是独立于上述四个操作的，因为进行完一次操作 5 后 **不能再使用** 上述四个操作了。

这个倍增一下 level ancestor，结合 dp 转移即可。

设 $dis_i$ 表示 Dijkstra 求出来的最短路的距离，

设 $f(i)$ 表示使用五种操作到达 $i$ 的最少花费，则 $f(i) = \min\{dis_i, f(fail_i) + E\cdot(len_i - len_{fail_i})\}$

#### 时间复杂度分析

记 $\left|S\right| = n$。

显然边的数量是线性的，不难得出最后的时间复杂度为 $O((n + q)\log(n))$。

~~可以使用配对堆优化 Dijkstra。~~

### 参考代码：

Dijkstra 我就不贴了。

```cpp
#include <bits/stdc++.h>
#define LL long long

const LL inf = 0x3f3f3f3f3f3f3f3fLL;
const int N = 1e6 + 5;
const int M = 2e6 + 5;

int n, m, k, ta, tb, tc, td, te, q, flag = 1;
int cnt, first[N], pos[N];
LL dis[N], f[N];
int lg2, anc[N][40 + 5];
char str[N];

struct EERTREE {
    static const int MS = N;
    static const int C = 50 + 5;

    int n, cntNode, last, s[MS], len[MS], fail[MS], par[MS], ch[MS][C], lst[MS];

    int make(int l) {
        for(int i = 0; i < C; ++i) ch[cntNode][i] = 0;
        len[cntNode] = l;
        return cntNode++;
    }
    int GetFail(int x) {
        while(s[n] != s[n - len[x] - 1]) x = fail[x];
        return x;
    }
    void extend(int x) {
        s[++n] = x;
        int fa = GetFail(last);
        if(!ch[fa][x]) {
            int now = make(len[fa] + 2);
            fail[now] = ch[ GetFail(fail[fa]) ][x];
            ch[fa][x] = now;
        }
        last = ch[fa][x];
        par[last] = fa, lst[n] = last;
    }
    void init() {
        n = cntNode = last = 0;
        make(0), make(-1);
        fail[0] = 1, fail[1] = 0;
        s[0] = -1;
    }
    EERTREE() { init(); }
} t;

int I(char ch) {
    if('a' <= ch && ch <= 'z')
        return ch - 'a' + 1;
    else
        return 26 + ch - 'A' + 1;
}

int G(int x) {
    return x + t.cntNode - 1;
}

void Build_Graph() {
    for(int i = 2; i <= t.cntNode - 1; ++i) {
        if(t.fail[i] > 1) Add_Edge(i, t.fail[i], ta), Add_Edge(t.fail[i], i, tb);
        else Add_Edge(i, 1, ta), Add_Edge(1, i, tb);
        for(int j = 1, fa = t.par[i]; j <= k && fa > 1; ++j, fa = t.par[fa])
            Add_Edge(i, fa, tc);
        Add_Edge(i, G(i), td);
        Add_Edge(G(i), i, 0);
        for(int j = 0; j < t.C; ++j)
            if(t.ch[i][j])
                Add_Edge( G(i), G(t.ch[i][j]), 0 );
    }
    for( ; 1LL << lg2 < m; ++lg2);
    for(int i = 2; i <= t.cntNode - 1; ++i) anc[i][0] = std::max(t.fail[i], 1);
    for(int j = 1; j <= lg2; ++j)
        for(int i = 2; i <= t.cntNode - 1; ++i)
            anc[i][j] = anc[anc[i][j - 1]][j - 1];
}

int Find(int x, int len) {
    if(t.len[x] <= len) return x;
    for(int j = lg2; j >= 0; --j)
        if(anc[x][j] > 1 && t.len[anc[x][j]] > len)
            x = anc[x][j];
    return anc[x][0];
}

void solve(int l, int r) {
    if(l == 1 && r == m) {
        puts("0");
        return;
    }
    int p = Find(t.lst[r], r - l + 1);
    printf("%lld\n", f[p] + 1LL * (r - l + 1 - t.len[p]) * te + (!flag) * ta);
}

int main() {
    scanf("%s", str + 1), m = strlen(str + 1);
    memset(first, -1, sizeof(first));
    scanf("%d %d %d %d %d %d %d", &k, &ta, &tb, &tc, &td, &te, &q);

    for(int i = 1; i <= m; ++i) t.extend( I(str[i]) );
    Build_Graph();
    Dijkstra(t.last);

    for(int i = 1; i <= m; ++i) flag &= (str[i] == str[m - i + 1]);

    f[0] = inf, f[1] = dis[1];
    for(int i = 2; i <= t.cntNode - 1; ++i)
        f[i] = std::min(dis[i], f[t.fail[i]] + 1LL * te * (t.len[i] - t.len[t.fail[i]]));

    while(q--) {
        int l, r;
        scanf("%d %d", &l, &r);
        solve(l, r);
    }
    return 0;
}
```

---

## 作者：crashed (赞：5)

# 分析
&emsp;&emsp;阅读题面，首先便不难发现一点，一旦进行了除了 " 光弋 " 操作外的任一操作，这个法术都会变成一个归法术。而 " 光弋 " 只能在法术前端加入字符，又只能放在最后做，所以可以得出：  
&emsp;&emsp;除特殊情况外，我们在最终 " 光弋 " 操作之前的目标就是要让初始法术通过最少时间变换为目标法术的一个**归法术后缀**；最终不需要进行 " 光弋 " 操作的情况也可以归为这类。    
&emsp;&emsp;特殊情况就是当目标法术就是初始法术的情况。此时我们不需要变换。  
&emsp;&emsp;如何用最少时间变换为其一个归法术后缀？  
&emsp;&emsp;再次观察我们剩下的四种操作，我们不难联想到回文自动机。    
&emsp;&emsp;可以发现题目中 " 光归 " 和 " 光辉 " 操作实际上是对应了状态通过$ fail $树进行转移； " 光隐 " 和 " 光腾 " 操作实际上对应了在自动机的（认为是无向）边上的转移。  
&emsp;&emsp;有了这个载体，我们把字符串问题转化为了图上（树上？）问题。此时不排除有我想不出来但是是正确的贪心 / DP 等做法，欢迎大家来踩爆我。  
&emsp;&emsp;反正，由于是图上最优化问题，并且牵涉到状态的转移，我们不难想到构建最短路。考虑根据题目的前四种操作基于回文自动机建图：  
&emsp;&emsp;首先定义$fail[x]$为状态$x$的**最长归法术后缀**对应的状态（如果指向了$0$根或者$-1$根，我们认为$fail[x]$指向的是新构建的图上的点$1$）。$ch[x][c]$为状态$x$在末尾插入一个元素$c$之后转移的状态。$fa[x][k]$表示在回文自动机上（由于是树形结构）向父亲方向转移$k$次得到的状态。$len[x]$表示回文自动机上$x$代表的串的长度。  
&emsp;&emsp;然后可以分类建图：  
&emsp;&emsp;$1.$ " 光归 "  ：建一条$(x,fail[x])$的有向边，权值为$A$。  
&emsp;&emsp;$2.$ " 光辉 " ：建一条$(fail[x],x)$的有向边，权值为$B$。  
&emsp;&emsp;$3.$ " 光隐 " ：建$k$条边，为$1\le i\le k, (x,fa[x][i])$，权值各为$C$。  
&emsp;&emsp;$4.$ " 光腾 " ：这个建边会直接影响到你的复杂度。  
&emsp;&emsp;考虑最后的 " 光腾 " 操作的建边，如果直接暴力无脑向自己在回文自动机上所有子孙都连边显然是不可能的，很容易就会被卡到$O(|S|^2)$。但是我们发现这个转移有一个性质，即对于每个状态，每次进行光腾操作的时候只需要支付一次花费，然后可以随意~~蛇皮~~转移，直到进入到一个确定的状态。  
&emsp;&emsp;也就是说，我们可以假想为每一个点$x$有一个虚点$x'$，这些虚点仿照原回文树构造出了树形结构，并且在这棵 " 虚树 " 上面只能向儿子转移，且转移花费为$0$。这样我们进行 " 光腾 " 操作的时候就可以拆分为三步：   
&emsp;&emsp;$1.$从 " 实树 " 走到 " 虚树 " 上，花费$D$，即$(x,x')$，权值为$D$。  
&emsp;&emsp;$2.$在 " 虚树 " 上向儿子方向转移，不花费。  
&emsp;&emsp;$3.$从 " 虚树 " 回到 " 实树 " 上，不花费，即$(x',x)$，权值为$0$。  
&emsp;&emsp;于是这样建边，" 光腾 " 的复杂度就被降到了$O(|S|)$。边的复杂度就是$O(k|S|)$的。  
&emsp;&emsp;接着，我们从最后一个节点开始跑单源最短路，就可以愉快地得到从初始法术到每一个归法术的最少时间花费了！  
&emsp;&emsp;我们还有些问题需要解决。  
&emsp;&emsp;由于我们需要转移到询问法术的一个归法术后缀，所以我们至少需要知道询问法术对应的**最长归法术后缀**对应的状态。  
&emsp;&emsp;设$lst[i]$表示法术的第$i$个元素插入回文自动机后的尾节点。不难发现这个节点对应的是**以$i$结尾的最长归法术**。我们需要找到的子法术必然是$lst[i]$对应的法术的归法术后缀，即我们需要找到的状态是$lst[i]$在$fail$树上的**一个祖先**，满足**这个状态是祖先中第一个满足$len\le r-l+1$的状态**。  
&emsp;&emsp;由于$fail$树上从祖先到子孙的$len$显然存在单调性，所以可以预处理树上倍增数组，再在每次询问的时候进行树上倍增。  
&emsp;&emsp;下一个问题。我们之前一直在强调，我们需要走到的状态是目标法术的一个**归法术后缀**。为什么不是最长的呢？请看下面这个例子：  
```
acbabcb
2
1 10 10 2 1
1
2 5
```
&emsp;&emsp;如果走到最长的归法术后缀$'bab'$，那么最少时间花费为$10$；而如果先两次 " 光归 " 操作走到$b$，再进行三次 " 光弋 " 操作，花费仅有$5$。  
&emsp;&emsp;这是由于 " 光弋 " 操作不在我们的图的转移上面导致的。因此我们只需要单独提出来做一下转移就好了。根据上面的例子我们可以知道这个更新方向是$fail$树上从祖先到子孙的，所以可以上一个 DP ，进行转移。  
&emsp;&emsp;设$f(x)$：通过五种操作到达自己的最少花费。  
&emsp;&emsp;设$d(x)$表示之前求出的到$x$的单源最短路距离。即可得到$f$的转移为： 
$$f(x)=\min\{d(x),f(fail[x])+E\times(len[x]-len[fail[x]])\}$$  
&emsp;&emsp;最后一个小细节，如果初始法术不是一个归法术，那么我们从$lst[|S|]$开始进行的最短路，实际上都少算了一个$A$的时间。由于这种情况最开始只能进行 " 光归 " 操作，所以我们可以知道最短路加上$A$就是正确的了。而初始法术是归法术的没有问题。  
# 代码
```cpp
#include <cmath>
#include <queue>
#include <cstdio>
#include <cstdlib>
#include <cstring>
using namespace std;

typedef long long LL;

const LL INF = 0x3f3f3f3f3f3f3f3f;
const int MAXN = 1e5 + 5, MAXE = 1.5e6 + 5, MAXLOG = 20;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

struct edge
{
	int to, nxt, w;
}Graph[MAXE << 1];

struct node
{
	LL dist; int u;
	node() {}
	node( const int U, const LL D ) { u = U, dist = D; }
	bool operator < ( const node & b ) const { return ! ( dist < b.dist ); }
};

priority_queue<node> q;

int fa[MAXN][MAXLOG] = {};
LL head[MAXN * 2], dist[MAXN * 2], f[MAXN * 2];
int ch[MAXN][55], fail[MAXN], len[MAXN], fath[MAXN];
char S[MAXN];
int last[MAXN];
int N, M, A, B, C, D, E, K, lg2, cnt, tot, lst;
bool visited[MAXN * 2];

int HASH( const int x, const int l ) { return x + ( l - 1 ) * tot; }
int id( const char c ) { return 'A' <= c && c <= 'Z' ? ( c - 'A' ) : ( c - 'a' + 26 ); } 

void addEdge( const int from, const int to, const int W )
{
	Graph[++ cnt].to = to, Graph[cnt].nxt = head[from], Graph[cnt].w = W;
	head[from] = cnt;
}

void addE1( const int from, const int to, const int W ) { addEdge( from, to, W ), addEdge( to, from, 0 ); }

void build( const char *s )
{
	int x, p, cur;
	N = strlen( s + 1 );
	fail[0] = ++ tot, len[1] = -1;
	for( int i = 1 ; i <= N ; i ++ )
	{
		x = id( S[i] );
		while( S[i] ^ S[i - len[lst] - 1] ) lst = fail[lst];
		if( ! ch[lst][x] )
		{
			len[cur = ++ tot] = len[lst] + 2, p = fail[lst];
			while( S[i] ^ S[i - len[p] - 1] ) p = fail[p];
			fail[cur] = ch[p][x], ch[lst][x] = cur;
			fath[cur] = lst;
		}
		last[i] = lst = ch[lst][x];
	}
}

//建自动机

void init()
{
	for( int i = 2, v ; i <= tot ; i ++ )
	{
		if( fail[i] > 1 ) addEdge( i, fail[i], A ), addEdge( fail[i], i, B );
		else addEdge( i, 1, A ), addEdge( 1, i, B );
		addE1( HASH( i, 1 ), HASH( i, 2 ), D );
		for( int j = 1, k = fath[i] ; j <= K && k > 1 ; j ++, k = fath[k] )
			addEdge( i, k, C );
		for( int j = 0 ; j < 52 ; j ++ ) 
			if( v = ch[i][j] )
				addEdge( HASH( i, 2 ), HASH( v, 2 ), 0 );
	}
	lg2 = log2( N );
	for( int i = 2 ; i <= tot ; i ++ ) fa[i][0] = MAX( fail[i], 1 );
	for( int j = 1 ; j <= lg2 ; j ++ )
		for( int i = 2 ; i <= tot ; i ++ )
			fa[i][j] = fa[fa[i][j - 1]][j - 1];
}

//建图

void Dijkstra( const int S )
{
	while( ! q.empty() ) q.pop();
	for( int i = 0 ; i <= tot * 2 ; i ++ ) dist[i] = INF;
	q.push( node( S, dist[S] = 0 ) );
	int u, v, w;
	while( ! q.empty() )
	{
		u = q.top().u; q.pop();
		if( visited[u] ) continue; visited[u] = true;
		for( int i = head[u] ; i ; i = Graph[i].nxt )
			if( ! visited[v = Graph[i].to] && dist[v] > dist[u] + ( w = Graph[i].w ) )
				q.push( node( v, dist[v] = dist[u] + w ) );
	}
}

int find( int p, const int l )
{
	if( len[p] <= l ) return p;
	for( int j = lg2 ; ~ j ; j -- )
		if( fa[p][j] > 1 && len[fa[p][j]] > l )
			p = fa[p][j];
	return fa[p][0];
}

bool palidrome()
{
	for( int i = 1 ; i <= N ; i ++ ) if( S[i] ^ S[N - i + 1] ) return false;
	return true;
}

int main()
{
	int Q;
	scanf( "%s", S + 1 );
	read( K );
	read( A ), read( B ), read( C ), read( D ), read( E );
	build( S );
	init();
	Dijkstra( lst );
	f[0] = INF, f[1] = dist[1];
    //这里的写法有点点问题
    //"将f[0]赋为无穷大"实际上是和"转移时判掉0和-1根"是一样的（fail不会指向1）
	for( int i = 2 ; i <= tot ; i ++ ) 
		f[i] = MIN( dist[i], f[fail[i]] + 1ll * ( len[i] - len[fail[i]] ) * E );
	read( Q );
	bool flag = palidrome();
	int l, r;
	while( Q -- )
	{
		read( l ), read( r );
		if( l == 1 && r == N ) { puts( "0" ); continue; }
		int p = find( last[r], r - l + 1 );
		write( f[p] + 1ll * ( r - l + 1 - len[p] ) * E + ( ! flag ) * A ), putchar( '\n' );
	}
	return 0;
}
```

---

## 作者：苹果蓝17 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P6396)

[更~~不~~好的阅读体验](https://www.cnblogs.com/Appleblue17/p/14341804.html#题意简述)

真是神题

#### 题意简述

好一道翻译题

一个字符串 $S_0$ ，并令 $S=S_0$ ，对 $S$ 进行若干操作。

有五种操作：

- **光归**：若 $S$ **非空**，可将 $S$ 变为 $S$ 的最长回文后缀，代价 $A$。
- **光辉**：若 $S$ 为**回文串**，且存在 $T$ （可为空串）为 $S_0$ 的子串，$S$ 为 $T$ 的最长回文后缀，可将 $S$ 变为 $T$ ，代价 $B$。
- **光隐**：若 $S$ 为**非空回文串**，可删去其长度相等且长度不大于 $k$ 的前缀与后缀（删去后不能为空串），代价 $C$。
- **光腾**：若 $S$ 为**非空回文串**，且在 $S$ 两端加上一对反串后生成的新回文串 $T$ 是 $S_0$ 的子串，可将 $S$ 变为 $T$ ，代价 $D$。
- **光戈**：若 $S$ **非空**，可在 $S$ 前加入任意字符，代价 $E$。使用该操作后不能再进行其它操作。

$q$ 次询问，求将 $S$ 变为 $S_0[l,r]$ 的最小代价。

$1 \leq q,|S| \leq 10^5$，$1 \leq k \leq 5$，$\sum \leq 52$

#### 题目分析

主题是回文串，当然得在回文自动机上处理。

考虑在回文自动机的节点间建单向边，然后跑单源最短路。

记边为 $(u,v,w)$。

- **光归**：$(i,fail_i,A)$，$fail_i$ 可以为 $0$。
- **光辉**：$(fail_i,i,B)$，$fail_i$ 可以为 $0$。
- **光隐**：$(i,pth-fa_i,C)$，$p=1,2,\cdots,k$。$pth-fa_i$ 表示 $p$ 级祖先，不能为 $0$。
- **光腾**：将 $i$ 向 $fail$ 树中它的子树中所有节点连边 $(i,son,D)$。

这样会连出 $O(|S|^2)$ 条边，不行。

可以对每个点 $i$ 建一个虚点 $i'$，将 $i'$ 建按照 $fail$ 树连边，边权为 $0$。注意：**$i$ 并没有按照 $fail$ 树连边**。

然后对于每个点，连边 $(i',i,0)$ ，这样虚点可以随意到达它；连边 $(i,i',D)$ ，这样它就可以花费 $D$ 的代价到达虚点，从而到达子树中的所有点。

**光戈**操作较为特殊，只要使用代价就已确定，故在询问时再考虑。

***

跑一遍 `Dijkstra`，得到 $dis(i)$ ，表示到达 $i$ 状态最小的代价。

注意有个小细节：**若 $S_0$ 本身不是回文串，需要先进行一次光归将其变到 `PAM` 的节点上，因为此时不能进行其它操作**。

接下来考虑询问。首先如果询问是 $S_0[1,n]$ 需要**特判**，答案为 $0$。

由于光戈操作只能由回文串在前面添加字符而来，故开始光戈前一定是询问串的一个回文后缀。

可以从询问串的最长后缀跳 $fail$，假设跳到了节点 $p$ 且**满足 $len_p \leq r-l+1$**。

$$ans=\min_{p}\{(r-l+1-len_p)E+dis(p) \}$$

暴力跳 $fail$ 仍然是不可取的 ~~虽然能水到 85 pts~~ ，会被链的情况卡到 $O(|S|^2)$。

但我们发现跳 $fail$ 时 $len$ 是在不断减小的，也就是查询的实际上是从根出发的一条链的最小值。

$$ans=(r-l+1)E + \min_{p}\{dis(p)-len_pE \}$$

那倍增出第一个 $len_p \leq r-l+1$，记由根出发（**不包括 0 号节点**）到 $u$ 节点的链上， $g_u=dis(p)-len_pE$ ，答案即为

$$ans=(r-l+1)E + g_u$$

时间复杂度 $O(k|S|+(k|S|+q)logn)$。

#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long N=4e5+5;
long long m,k,A,B,C,D,E;

struct nodd{
	long long to,nxt;
	long long w;
}e[N*2];
long long head[N],cntt;

void add(long long u,long long v,long long w){
	e[++cntt].to=v;
	e[cntt].w=w;
	e[cntt].nxt=head[u];
	head[u]=cntt;
}

//建图 

struct nod{
	int ch[52];
	int len,fail,fa;
	nod(){
		memset(ch,0,sizeof(ch));
		len=fail=0;
	}
}t[N>>1];

char s[N];
long long lst=0,cnt=1;
long long trans(char c){
	if(c>='a' && c<='z') return c-'a';
	else return c-'A'+26;
}
//转换字符 
void PAM(long long n){
	long long p=lst;
	long long c=trans(s[n]);
	while(s[n-t[p].len-1]!=s[n]) p=t[p].fail;
	if(!t[p].ch[c]){
		cnt++;
		long long q=t[p].fail;
		while(s[n-t[q].len-1]!=s[n]) q=t[q].fail;
		t[cnt].fail=t[q].ch[c];
		t[cnt].len=t[p].len+2;
		
		t[p].ch[c]=cnt;
		t[cnt].fa=p;
	}
	lst=t[p].ch[c];
}

struct abc{
	long long num,dis;
};
long long dis[N];
bool vis[N];
bool operator <(abc x,abc y){
	return x.dis>y.dis;
}
priority_queue <abc> q;

long long pre[N],ex;

long long f[N][19],g[N];
//g: 根节点（不含0）到此的 dis[p]-t[p].len*E 最小值 

void dfs(long long u){
	for(long long i=head[u];i;i=e[i].nxt){
		long long v=e[i].to;
		f[v][0]=u;
		g[v]=min(g[u],dis[v]-t[v].len*E);
		dfs(v);
	}
}
//预处理 f和 g 

int main(){
	scanf("%s",s+1);
	long long n=strlen(s+1);
	cin>>k>>A>>B>>C>>D>>E;
	
	t[0].fail=t[1].fail=1;
	t[1].len=-1;
	for(long long i=1;i<=n;i++) PAM(i),pre[i]=lst;
	//PAM
	
	if(t[lst].len!=n) ex=A;
	for(long long i=2;i<=cnt;i++)
		add(i,t[i].fail,A);
	for(long long i=2;i<=cnt;i++)
		add(t[i].fail,i,B);
	for(long long i=2;i<=cnt;i++){
		long long x=t[i].fa;
		for(long long j=1;x && j<=k;x=t[x].fa,j++)
			add(i,x,C);
	}
	
	for(long long i=2;i<=cnt;i++)
		add(i+cnt,i,0);
	for(long long i=2;i<=cnt;i++)
		add(i,i+cnt,D);
	for(long long i=2;i<=cnt;i++)
		if(t[i].fa>1)
			add(t[i].fa+cnt,i+cnt,0);
	//虚点 
	//建图 
	
	memset(dis,0x7f,sizeof(dis));
	dis[lst]=0;
	q.push((abc){lst,0});
	while(!q.empty()){
		abc tmp=q.top();
		q.pop();
		long long u=tmp.num;
		if(vis[u]) continue;
		vis[u]=1;
		for(long long i=head[u];i;i=e[i].nxt){
			long long v=e[i].to;
			if(vis[v]) continue;
			if(dis[u]+e[i].w<dis[v]) dis[v]=dis[u]+e[i].w;
			q.push((abc){v,dis[v]});
		}
	}
	//Dijkstra 
	
	memset(head,0,sizeof(head));
	cntt=0;
	for(long long i=2;i<=cnt;i++)
		add(t[i].fail,i,0);
	g[0]=1e18;
	dfs(0);
	for(long long j=1;j<=18;j++)
		for(long long i=0;i<=cnt;i++)
			f[i][j]=f[f[i][j-1]][j-1];
	cin>>m;
	for(long long i=1;i<=m;i++){
		long long l,r;
		scanf("%lld%lld",&l,&r);
		if(l==1 && r==n){
			puts("0");
			continue;
		}
		//特判 
		long long p=pre[r];
		if(t[p].len>r-l+1){
			for(long long j=18;j>=0;j--)
				if(t[f[p][j]].len>r-l+1) p=f[p][j];
			p=f[p][0];
		}
		//倍增 
		printf("%lld\n",(r-l+1)*E+g[p]+ex);
	}
}
```



---

## 作者：sqrtqwq (赞：0)

标签：PAM，最短路。

好题。

因为和回文串有关，所以我们考虑把他扔到 ```PAM``` 里面。考虑在回文自动机的节点间建单向边，然后跑单源最短路。

- **光归**：连边 $(i,fail_i,A)$，其中 $fail_i$ 可以为 $0$。

- **光辉**：连边 $(fail_i,i,B)$，其中 $fail_i$ 可以为 $0$。

- **光隐**：处理出来 $i$ 的 $fa_i$，然后连 $k$ 条 $(i,fa_i,C)$ 的边。

- **光腾**：

这个操作就不能直接连边了，因为我们发现这个操作其实是这个操作，本质上是从 $i$ 以 $D$ 的代价转移到 $i$ 子树中的任意一个结点。这样不行，数量是 $\mathrm O(|S|^2)$ 级别的。

考虑优化建图的思想，对每个点建立一个对应的虚点，而虚点只能往儿子的方向转移（花费为 $0$）。那么我们只需要对于 $i$ 连一条向 $i$ 的虚点边权为 $D$ 的边，然后 $i$ 的虚点向 $i$ 连一条边权为 $0$ 的边即可。

- **光弋**：这个操作做完了之后就不能做前面的 $4$ 个操作了。所以这个操作我们考虑放到询问的时候再来做。

建完图之后我们跑一边 Dijkstra，然后定义 $dis_i$ 表示到第 $i$ 个点的最短路。

------

考虑询问。由于光戈操作只能由回文串在前面添加字符而来，故开始光戈前一定是询问串的一个回文后缀。

首先暴力跳 $fail$ 是简单的，此时考虑如何优化。

我们发现跳 $fail$ 时长度是在不断减小的，也就是查询的实际上是从根出发的一条链的最小值。

然后此时我们可以用倍增求出来第一个 $len_p \le r - l + 1$。然后我们就知道答案就是 $(r - l + 1) \times E + dis_p - len_p \times E$。那么我们查询的复杂度就是 $O(q \log n)$。

那么时间复杂度就是 $\mathrm O(k \times |S| + (k \times |S| + q) \log n)$。

---

## 作者：Fzrcy (赞：0)

~~一道阅读理解好题~~。

前两个操作都与最长回文后缀有关，这使我们想到回文自动机。

考虑建出原串的回文自动机，对于在回文自动机的位置为 $x$，操作一就是跳到 $fail_x$，代价为 $A$，操作二就是从 $fail_x$ 跳到 $x$，对于操作三，暴力连 $fail$ 即可，对于操作四，如果暴力连边会将边数卡成 $O(n^2)$，考虑优化，对于每个点 $i$ 建立虚点 $i'$，连边 $i\to i'$，代价为 $D$，连边 $i'\to i$，代价为 $0$，连边 $i'\to j'$（在回文自动机中存在边 $i\to j$），代价为 $0$。对于操作五，最后统一计算。

设 $dist_i$ 为从原串变成节点 $i$ 代表的回文串的最小代价（只使用操作一至四），明显的，当且仅当原串不为回文串时，$last$ 的代价为 $A$，否则为 $0$，$last$ 表示原串的最长回文后缀代表的节点）。根据上文的连边方式跑最短路即可，从原串变成节点 $i$ 代表的回文串的最小代价 $f_i=\min(dist_i,dist_{fail_i}+(len_i-len_{fail_i})\times E)$。

对于询问找到该子串 $T$ 的最长回文后缀代表的节点 $x$，将原串 $S$ 变成 $T$ 的代价为 $f_x+(|T|-len_x)\times E$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N=4e5+1;
ll cA, cB, cC, cD, cE, k;
int anc[N][18];
ll dist[N], f[N];
int chk(char c){
    if(c>='a'&&c<='z') return c-'a';
    else return 26+c-'A';
}
struct Graph{
    int h[N], nt[N<<3], to[N<<3], cnt, vis[N];
    ll w[N<<3];
    void add_edge(int u, int v, ll val){
        nt[++cnt]=h[u], h[u]=cnt, to[cnt]=v, w[cnt]=val;
    }
    void dij(int pos, ll val){
        memset(dist, 63, sizeof dist);
        priority_queue<pair<ll, int>> q;
        q.push({-val, pos}), dist[pos]=val;
        while(!q.empty()){
            int u=q.top().second; q.pop();
            if(vis[u])continue;
            vis[u]=1;
            for(int i=h[u]; i; i=nt[i]){
                int v=to[i];
                if(dist[v]>dist[u]+w[i])
                    dist[v]=dist[u]+w[i], q.push({-dist[v], v});
            }
        }
    }
}g;
struct PAM{
    int ch[N][55], fail[N], len[N], S[N];
    int cnt, tot, last, fa[N], Last[N];
    void init(){
        cnt=1, last=0, tot=0, S[0]=-1;
        len[0]=0, len[1]=-1, fail[0]=1;
    }
    void ins(int c){
        int p=last;
        S[++tot]=c+1;
        while(S[tot]!=S[tot-len[p]-1]) p=fail[p];
        if(!ch[p][c]){
            int res=++cnt;
            len[res]=len[p]+2;
            int q=fail[p];
            while(S[tot]!=S[tot-len[q]-1]) q=fail[q];
            fail[res]=ch[q][c], ch[p][c]=res;
        }
        last=ch[p][c];
        Last[tot]=last;
        fa[last]=p;
        return;
    }
    void build(char *s){
        init();
        int ll=strlen(s+1);
        for(int i=1; i<=ll; i++)
            ins(chk(s[i]));
        for(int i=2; i<=cnt; i++){
            if(fail[i]>1) g.add_edge(i, fail[i], cA), g.add_edge(fail[i], i, cB);
            else          g.add_edge(i, 1, cA),       g.add_edge(1, i, cB);
            for(int j=1, pa=fa[i]; j<=k&&pa>1; j++, pa=fa[pa]) g.add_edge(i, pa, cC);
            g.add_edge(i, i+cnt, cD), g.add_edge(i+cnt, i, 0);
            for(int j=0; j<55; j++) if(ch[i][j]) g.add_edge(i+cnt, ch[i][j]+cnt, 0);
        }
        for(int i=2; i<=cnt; i++) anc[i][0]=max(fail[i], 1);
        for(int j=1; j<=17; j++)
            for(int i=2; i<=cnt; i++)
                anc[i][j]=anc[anc[i][j-1]][j-1];
        g.dij(last, len[last]==tot?0:cA);
        f[0]=1e15;
        f[1]=dist[1];
        for(int i=2; i<=cnt; i++)
            f[i]=min(dist[i], f[fail[i]]+1ll*cE*(len[i]-len[fail[i]]));
    }
    int find(int x, int l){
        if(len[x]<=l) return x;
        for(int i=17; i>=0; i--)
            if(anc[x][i]>1&&len[anc[x][i]]>l) x=anc[x][i];
        return anc[x][0];
    }
    ll get_ans(int l, int r){
        if(l==1&&r==tot)return 0;
        int x=find(Last[r], r-l+1);
        return f[x]+1ll*(r-l+1-len[x])*cE;
    }
}pam;
char s[N];
int main(){
    scanf("%s", s+1);
    scanf("%lld %lld %lld %lld %lld %lld", &k, &cA, &cB, &cC, &cD, &cE);
    pam.build(s);
    int q;
    scanf("%d", &q);
    while(q--){
        int l, r;
        scanf("%d %d", &l, &r);
        printf("%lld\n", pam.get_ans(l, r));
    }
    return 0;
}

```



---

## 作者：老莽莽穿一切 (赞：0)

[更好的阅读体验](https://www.cnblogs.com/LaoMang-no-blog/p/16445964.html)

---

[**你谷 link**](https://www.luogu.com.cn/problem/P6396)

可以先给一份形式化题意：

给定一个初始串 $S_0$ 和参数 $m$，你可以进行一下 $5$ 种操作：

1. 对于一个串 $S$，构造串 $T$ 满足 $T$ 为 $S$ 的**最长回文后缀**，并将 $S$ 赋值为 $T$，代价为 $A$。
2. 对于一个**回文串** $S$，构造串 $T$ 满足 $S$ 为 $T$ 的**最长回文后缀**且 $T$ 为 $S_0$ 的子串，并将 $S$ 赋值为 $T$，代价为 $B$。
3. 对于一个**回文串** $S$，构造串 $T$ 满足可以找到一个**长度至多为 $m$** 的串 $a$，使得 $S=a+T+a^R$，并将 $S$ 赋值为 $T$，代价为 $C$，其中 $a^R$ 表示 $a$ 的反串。
4. 对于一个**回文串** $S$，构造串 $T$ 满足可以找到一个串 $a$，使得 $T=a+S+a^R$ 且 $T$ 为 $S_0$ 的子串，并将 $S$ 赋值为 $T$，代价为 $D$。
5. 对于一个串 $S$，构造串 $T$ 满足可以找到一个**字符** $a$，使得 $T=a+S$ 且 $T$ 为 $S_0$ 的子串，并将 $S$ 赋值为 $T$，代价为 $E$，特别的，进行过 $5$ 操作后不能再进行其他操作。

每次给定一组 $l,r$，令 $T$ 为 $S_0$ 的 $[l,r]$ 范围内的字符取出形成的新串，询问最少需要多少代价能使 $S_0$ 变为 $T$。

首先发现 $5$ 操作独立于其他操作之外，其它四个操作都基于初始串的回文子串，这提示我们使用一种数据结构维护 $S_0$ 的所有回文子串，很明显可以想到回文自动机。

先将 $S_0$ 建成回文自动机，现在我们思考五个操作在回文自动机上对应的意义。

首先就像上文所说的，$5$ 操作独立于别的操作之外，大概也可以想象是怎么用的，就是在生成目标串的回文后缀以后在前面直接接上，那么我们就考虑别的操作在回文自动机上的意义了。

首先看到最长回文后缀应该能很自然地想到回文自动机的失配指针，$1$ 操作对应边 $\langle p,\mathrm{fail}_p\rangle$，$2$ 操作对应 $\langle\mathrm{fail}_p,p\rangle$，然后另外两个操作其实也很明显，在串左右两边同时操作正好对应回文自动机的转移边，因为 $m$ 很小，所以直接对应向父亲暴力连边最多也没几条，但是其中最棘手的就是 $4$ 操作，这等价于向回文自动机中的子树里的每个点连边，在极限情况下显然是会被卡的，所以得想点办法。

其实难度并不是很高，这种往整个集合连边经典套路是建虚点，有些特殊情况不如分块优化建图、线段树优化建图之类的，这题不用这么麻烦，可以直接给每个点建一个虚点，如果两点在回文自动机上有连边，那么对应的虚点从父亲往儿子连边，边权为 $0$，从原点向虚点连有边权的边，虚点向原点连边权为 $0$，这样原来到子树中的边就可以转化为进入虚点后走到目标点对应的虚点再走回来，这两个操作是等价的。

接下来就是先从整串的状态进入回文自动机（如果整个串不是回文串还要用一次 $1$ 操作），再跑到目标串对应的一个回文后缀，再用 $5$ 操作变成目标串。

同时有一个注意点，注意到最后是**跑到目标串对应的一个回文后缀**而不是最长回文后缀，因为如果 $2$ 代价较高而 $5$ 代价较低的话也许最后用 $5$ 代替 $2$ 也不是不行，所以为了减少询问的复杂度，预处理 $d_i$ 表示回文自动机上从最后状态到编号为 $i$ 的节点**只用前 $4$ 种操作**所需要的最小花费，$f_i$ 表示回文自动机上从最后状态到编号为 $i$ 的节点所需要的最小花费，$d_i$ 可以用 Dijkstra 直接处理，$f_i$ 可以 dp 解决，转移方程为 $f_i=\min\{d_i,f_{\mathrm{fail}_p}+\operatorname{len}(p)-\operatorname{len}(\textrm{fail}_p)\}$。

最后就是找到区间 $[l,r]$ 对应字符串的最长回文后缀，可以利用倍增的思想倍增跳 $\textrm{fail}$ 指针，找到以 $r$ 结尾的长度不超过 $r-l+1$ 的最长的回文串。

整体是一道非常综合的题目，具体实现细节较多，可以看代码。

[代码](https://www.cnblogs.com/LaoMang-no-blog/p/16445964.html)

---


# SvT

## 题目背景

（我并不想告诉你题目名字是什么鬼）

## 题目描述

有一个长度为  $n$ 的仅包含小写字母的字符串  $S$，下标范围为  $[1,n]$。

现在有若干组询问,对于每一个询问,我们给出若干个后缀（以其在  $S$ 中出现的起始位置来表示），求这些后缀两两之间的 LCP（最长公共前缀）的长度之和。一对后缀之间的 LCP 长度仅统计一遍。




## 说明/提示

样例解释:

对于询问一，只有一个后缀 `oqqq`，因此答案为 $0$。

对于询问二，有两个后缀`poqqq`以及`qqq`，两个后缀之间的 LCP 为 $0$，因此答案为 $0$。

对于询问三，有四个后缀 `popoqqq` , `opoqqq` , `qqq` , `qq`，其中只有 `qqq`，`qq` 两个后缀之间的LCP不为 $0$，且长度为 $2$，因此答案为 $2$。

对于 $100\%$ 的测试数据，有 $|S|\le 5\times 10^5$，且 $\sum t\le3\times10^6$。

特别注意:由于另一世界线的某些参数发生了变化，对于一组询问，即使一个后缀出现了多次，也仅算一次。

题目来源：bzoj 3879

## 样例 #1

### 输入

```
7 3
popoqqq
1 4
2 3 5
4 1 2 5 6```

### 输出

```
0
0
2```

# 题解

## 作者：Gaode_Sean (赞：4)

题解区竟然没有并查集的题解，这里来一个。

先对下标进行离散化，再依照套路先求出 SA 数组以及 rank 数组，并在此基础上求出 height 数组（$\text{height}_i=\text{LCP}(\text{sa}_{i},\text{sa}_{i-1})$）。

对于一个长度为 $\text{len}$ 的子串，如果它在字符串中出现了 $x$ 次，那么一定能找到一个 $k$，使得 $\min \{ \text{height}_{k \dots k+x-2} \} \ge \text{len}$。

我们可以枚举子串的长度 $\text{len}$，但是复杂度会爆炸。

考虑使用并查集。具体地，我们从大到小枚举 $\text{len}$，对于 $\text{height}_i=\text{len}$ 的情况，合并 $i$ 和 $i-1$ 两个块。

## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=23333333333333333;
const int N=5e5+5;
int n,T,m,len;
int x[N],y[N],sa[N],rk[N],c[N],a[N],he[N],f[N][21],lg[21],h[N],fa[N];
char s[N];
ll sz[N];
vector<int> vec[N];
int get(int x)
{
    if(fa[x]==x) return x;
    return fa[x]=get(fa[x]);
}
void prework()
{
	lg[0]=1;
	for(int i=1;i<=20;i++) lg[i]=lg[i-1]<<1;
}
int ask(int l,int r)
{
	int k=(int)(log(r-l+1)/log(2));
	return min(f[l][k],f[r-(1<<k)+1][k]);
}
void SA()
{
	m=122;
	for(int i=1;i<=n;i++) c[x[i]=s[i]]++;
	for(int i=2;i<=m;i++) c[i]+=c[i-1];
	for(int i=n;i>=1;i--) sa[c[x[i]]--]=i;
	for(int k=1;k<=n;k<<=1)
	{
		int num=0;
		for(int i=n-k+1;i<=n;i++) y[++num]=i;
		for(int i=1;i<=n;i++) if(sa[i]>k) y[++num]=sa[i]-k;
		for(int i=1;i<=m;i++) c[i]=0;
		for(int i=1;i<=n;i++) c[x[i]]++;
		for(int i=2;i<=m;i++) c[i]+=c[i-1];
		for(int i=n;i>=1;i--) sa[c[x[y[i]]]--]=y[i],y[i]=0;
		swap(x,y),num=1,x[sa[1]]=1;
		for(int i=2;i<=n;i++)
		{
			if(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k]) x[sa[i]]=num;
			else x[sa[i]]=++num;
		}
		if(num==n) break;
		m=num;
	}
	for(int i=1;i<=n;i++) rk[sa[i]]=i;
	int k=0;
	for(int i=1;i<=n;i++)
	{
		if(rk[i]>1)
		{
		    if(k) k--;
		    while(s[i+k]==s[sa[rk[i]-1]+k]) k++;
		    he[rk[i]]=k;
		}
   }
   for(int i=1;i<=n;i++) f[rk[i]][0]=he[rk[i]];
   int t=(int)(log(n)/log(2))+1;
   for(int j=1;j<=t;j++)
   {
        for(int i=1;i<=n-lg[j]+1;i++) f[i][j]=min(f[i][j-1],f[i+lg[j-1]][j-1]);
   }
}
void solve()
{
	ll ans=0;
	for(int i=1;i<=len;i++) scanf("%d",&a[i]);
	sort(a+1,a+1+len,[](const int &x,const int &y){return rk[x]<rk[y];});
	len=unique(a+1,a+1+len)-a-1;
    for(int i=2;i<=len;i++) h[i]=ask(rk[a[i-1]]+1,rk[a[i]]),vec[h[i]].push_back(i);
    for(int i=1;i<=len;i++) fa[i]=i,sz[i]=1;
    for(int i=n-1;i>=0;i--)
    {
    	for(auto j:vec[i])
    	{
    		int x=get(j),y=get(j-1);
    		if(x==y) continue;
    		ans=(ans+1ll*i*sz[x]*sz[y])%mod;
    		sz[x]+=sz[y],fa[y]=x;
		}
	}
	printf("%lld\n",ans);
	for(int i=2;i<=len;i++) vec[h[i]].clear();
}
int main()
{
    scanf("%d%d%s",&n,&T,s+1); prework(); SA();
    while(T--) scanf("%d",&len),solve();
    return 0;	
}
```

---

## 作者：pomelo_nene (赞：3)

呜呜人傻代码常数大被卡掉了。下面的代码在 O2 加持可以过掉。我很好奇 @GuidingStar 为什么常数这么小呜呜。

考虑到要求一个串给定后缀两两 $\operatorname{lcp}$ 之和，需要一个处理字符串前缀的工具去解决这个问题。显然我们没有好的解决前缀的工具，于是将串反转，用一个处理后缀的工具解决这个问题。这里用的是后缀自动机。

有一个熟知的结论，也就是后缀自动机上 $\operatorname{parent}$ 树上的两个结点的 $\operatorname{LCA}$ 结点就是根分别到这两个结点的表示的字符串的 $\operatorname{lcp}$。显然这个 $\operatorname{lcp}$ 是好求的。于是将串反转后，对于每一次扩展，记录下第 $i$ 个字符扩展后，可以表示 $s[1 \dots i]$ 的结点是哪一个。

然后接下来处理询问。注意到 $\sum t$ 最大是 $3 \times 10^6$，遍历一遍 $\operatorname{parent}$ 树显然不现实。于是对需要的结点构建虚树即可。

需要处理答案。将两两间的贡献处理在他们的 $\operatorname{LCA}$ 之间。影响答案的显然是两个不同子树与根结点对子树的贡献。

定义一个结点为关键结点，那么这个结点是询问中需要加入查询的某一个后缀（处理的时候变成前缀了）表示的那个结点。

首先考虑根结点对子树的贡献，显然这个结点与其子树内结点 $\operatorname{LCA}$ 就是这个结点本身。那么如果该结点是关键结点其贡献增加这个子树内关键结点个数。

再考虑两两子树间的贡献，次数就是这两个子树内关键结点个数积。那么这个东西是显然好处理的。

具体实现看代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
int read()
{
	int x=0;
	char c=getchar();
	while(c<'0' || c>'9')	c=getchar();
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x;
}
void write(LL x)
{
	if(x<0)	putchar('-'),x=-x;
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
const LL MOD=23333333333333333ll;
const int Sigma=26;
char s[500005];
int pos[500005],n,dep[1000005],fa[1000005][21],lgs[1000005],dfn[1000005],sjc,val[1000005],sr[1000005],len,siz[1000005];
bool tek[1000005];
vector<int> G[1000005],vir[1000005];
LL ans;
bool cmp(int x,int y){return dfn[x]<dfn[y];}
struct SAM{
	int las,cnt,ch[1000005][Sigma],len[1000005],fa[1000005];
	SAM(){las=cnt=1;}
	void extend(int c)
	{
		int p=las,cur=++cnt;
		len[cur]=len[las]+1;
		las=cur;
		while(p && !ch[p][c])	ch[p][c]=cur,p=fa[p];
		if(!p)	fa[cur]=1;
		else
		{
			int q=ch[p][c];
			if(len[p]+1==len[q])	fa[cur]=q;
			else
			{
				int clone=++cnt;
				len[clone]=len[p]+1;
				memcpy(ch[clone],ch[q],sizeof ch[q]);
				fa[clone]=fa[q];
				fa[q]=fa[cur]=clone;
				while(ch[p][c]==q)	ch[p][c]=clone,p=fa[p];
			}
		}
	}
	void build(){for(int i=2;i<=cnt;++i)	G[fa[i]].push_back(i);}
}sam;
void dfs(int now)
{
	dep[now]=dep[sam.fa[now]]+1;
	fa[now][0]=sam.fa[now];
	val[now]=sam.len[now];
	dfn[now]=++sjc;
	for(int i=1;i<=20;++i)	fa[now][i]=fa[fa[now][i-1]][i-1];
	for(unsigned int i=0;i<G[now].size();++i)	dfs(G[now][i]);
}
int LCA(int u,int v)
{
	if(dep[u]>dep[v])	u^=v^=u^=v;
	while(dep[u]<dep[v])	v=fa[v][lgs[dep[v]-dep[u]]];
	if(u==v)	return u;
	for(int i=20;~i;--i)	if(fa[u][i]!=fa[v][i])	u=fa[u][i],v=fa[v][i];
	return fa[u][0];
}
void dfs2(int now)
{
	for(unsigned int i=0;i<vir[now].size();++i)
	{
		int to=vir[now][i];
		dfs2(to);
		siz[now]+=siz[to];
		ans+=LL(val[now])*LL(siz[to])*LL(siz[now]-siz[to]);
	}
	if(tek[now])	ans+=LL(siz[now])*LL(val[now]),++siz[now];
}
int main(){
	int T;
	n=read(),T=read();
	scanf("%s",s+1);
	reverse(s+1,s+1+n);
	for(int i=1;i<=n;++i)	sam.extend(s[i]-'a'),pos[i]=sam.las;
	sam.build();
	for(int i=2;i<=1000000;++i)	lgs[i]=lgs[i>>1]+1;
	dfs(1);
	while(T-->0)
	{
		len=read();
		for(int i=1;i<=len;++i)	tek[sr[i]=pos[n-read()+1]]=true;
		sort(sr+1,sr+1+len,cmp);
		len=unique(sr+1,sr+1+len)-sr-1;
		for(int i=1;i<len;++i)	sr[len+i]=LCA(sr[i],sr[i+1]);
		len=2*len-1;
		sort(sr+1,sr+1+len,cmp);
		len=unique(sr+1,sr+1+len)-sr-1;
		for(int i=2;i<=len;++i)	vir[LCA(sr[i-1],sr[i])].push_back(sr[i]);
		ans=0;
		dfs2(sr[1]);
		write(ans%MOD);
		puts("");
		for(int i=1;i<=len;++i)	vir[sr[i]].clear(),siz[sr[i]]=0,tek[sr[i]]=false;
	}
	return 0;
}
```

---

## 作者：EuphoricStar (赞：2)

考虑对反串建 SAM，设 $[i, n]$ 的后缀对应 SAM 的点是 $a_i$。

那么 $\text{lcp}(s[i : n], s[j : n]) = \text{len}(\text{lca}(a_i, a_j))$。

于是问题变成了，给定一些点，统计两两 $\text{lca}$ 点权之和。

考虑建虚树，枚举每个点 $u$ 作为 $\text{lca}$ 的次数。设当前已经考虑过的儿子的 $sz$ 之和为 $s$，那么 $v$ 作为子树会有 $s \times sz_v$ 次数的贡献。再乘上 $len_u$ 累加进答案即可。

若使用 dfs 序 LCA，时间复杂度 $O((n + \sum t) \log n)$。

```cpp
// Problem: P7409 SvT
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P7409
// Memory Limit: 512 MB
// Time Limit: 3000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<int, int> pii;

const int maxn = 1000100;
const int logn = 22;

int n, m, lsh[maxn << 1], b[maxn], a[maxn * 3];
char s[maxn];
vector<int> G[maxn], T[maxn];

struct SAM {
	int lst, tot, fa[maxn], ch[maxn][26], len[maxn];
	
	inline void init() {
		for (int i = 1; i <= tot; ++i) {
			fa[i] = len[i] = 0;
			mems(ch[i], 0);
		}
		lst = tot = 1;
	}
	
	inline void insert(int c) {
		int u = ++tot, p = lst;
		len[u] = len[p] + 1;
		lst = u;
		for (; p && !ch[p][c]; p = fa[p]) {
			ch[p][c] = u;
		}
		if (!p) {
			fa[u] = 1;
			return;
		}
		int q = ch[p][c];
		if (len[q] == len[p] + 1) {
			fa[u] = q;
			return;
		}
		int nq = ++tot;
		fa[nq] = fa[q];
		len[nq] = len[p] + 1;
		memcpy(ch[nq], ch[q], sizeof(ch[nq]));
		fa[u] = fa[q] = nq;
		for (; p && ch[p][c] == q; p = fa[p]) {
			ch[p][c] = nq;
		}
	}
} sam;

int st[logn][maxn], dfn[maxn], tim;

inline int get(int i, int j) {
	return dfn[i] < dfn[j] ? i : j;
}

inline int qlca(int x, int y) {
	if (x == y) {
		return x;
	}
	x = dfn[x];
	y = dfn[y];
	if (x > y) {
		swap(x, y);
	}
	++x;
	int k = __lg(y - x + 1);
	return get(st[k][x], st[k][y - (1 << k) + 1]);
}

void dfs(int u) {
	dfn[u] = ++tim;
	for (int v : G[u]) {
		dfs(v);
		st[0][dfn[v]] = u;
	}
}

ll f[maxn], ans;

void dfs2(int u) {
	for (int v : T[u]) {
		dfs2(v);
		ans += f[u] * f[v] * sam.len[u];
		f[u] += f[v];
	}
}

void solve() {
	scanf("%d%d%s", &n, &m, s + 1);
	sam.init();
	for (int i = n; i; --i) {
		sam.insert(s[i] - 'a');
		b[i] = sam.lst;
	}
	for (int i = 2; i <= sam.tot; ++i) {
		G[sam.fa[i]].pb(i);
	}
	dfs(1);
	for (int j = 1; (1 << j) <= tim; ++j) {
		for (int i = 1; i + (1 << j) - 1 <= tim; ++i) {
			st[j][i] = get(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]);
		}
	}
	while (m--) {
		int len, tot = 0;
		scanf("%d", &len);
		for (int i = 1; i <= len; ++i) {
			scanf("%d", &a[i]);
			a[i] = b[a[i]];
		}
		sort(a + 1, a + len + 1);
		len = unique(a + 1, a + len + 1) - a - 1;
		sort(a + 1, a + len + 1, [&](const int &x, const int &y) {
			return dfn[x] < dfn[y];
		});
		for (int i = 1; i <= len; ++i) {
			lsh[++tot] = a[i];
			if (i > 1) {
				lsh[++tot] = qlca(a[i - 1], a[i]);
			}
		}
		sort(lsh + 1, lsh + tot + 1);
		tot = unique(lsh + 1, lsh + tot + 1) - lsh - 1;
		sort(lsh + 1, lsh + tot + 1, [&](const int &x, const int &y) {
			return dfn[x] < dfn[y];
		});
		for (int i = 2; i <= tot; ++i) {
			T[qlca(lsh[i - 1], lsh[i])].pb(lsh[i]);
		}
		for (int i = 1; i <= len; ++i) {
			f[a[i]] = 1;
		}
		ans = 0;
		dfs2(lsh[1]);
		printf("%lld\n", ans % 23333333333333333LL);
		for (int i = 1; i <= tot; ++i) {
			vector<int>().swap(T[lsh[i]]);
			f[lsh[i]] = 0;
		}
	}
}

int main() {
	int T = 1;
	// scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}
```


---

## 作者：meyi (赞：2)

### 前置知识：

- [后缀数组及 height 数组](https://oi-wiki.org/string/sa/)

### 题意简述：

求后缀两两之间的 LCP（最长公共前缀）的长度之和。

### 思路：

（以下的 $\text{LCP}$ 表示最长公共前缀的长度，$\text{suffix}(i)$ 表示起始位置为 $i$ 的后缀）

height 数组有一个性质：

$\text{LCP}(sa[i],sa[j])=\min\limits_{k=i+1}^jheight[k]$

稍加推导可得：

$\text{LCP}(\text{suffix}(i),\text{suffix}(j))=\min\limits_{k=rk[i]+1}^{rk[j]}height[k]$

再看看原题的要求：

给定长度为 $t$ 的数组 $a$，求 $\sum\limits_{i=1}^{t-1}\sum\limits_{j=i+1}^t\text{LCP}(suffix(a[i]),suffix(a[j]))$。

把推导的式子带入，发现要求的等价于 $\sum\limits_{i=1}^{t-1}\sum\limits_{j=i+1}^t\min\limits_{k=rk[a[i]]+1}^{rk[a[j]]}height[k]$。

于是这道题就变成了 $\text{RMQ}$ 问题，可以使用单调栈，分治+ST表等多种方式完成。

这里给出时间复杂度为 $O(n\log n)$ 的分治+ST表的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ri register int
typedef long long ll;
const int maxn=5e5+10;
template<class T>inline void clear(T *arr,int siz){memset(arr,0,sizeof(T)*(siz+1));}
const ll mod=23333333333333333;
int a[maxn],cnt[maxn],mx,n,q,rk[maxn],sa[maxn],tmp[maxn];
char s[maxn];
inline void base_sort(){
	clear(cnt,mx);
	for(ri i=1;i<=n;++i)++cnt[rk[i]];
	for(ri i=1;i<=mx;++i)cnt[i]+=cnt[i-1];
	for(ri i=n;i;--i)sa[cnt[rk[tmp[i]]]--]=tmp[i];
}
inline void suffix_sort(){
	for(ri i=1;i<=n;++i)mx=max(mx,rk[i]=s[i]),tmp[i]=i;
	base_sort();
	for(ri len=1,dif=0;dif<n;len<<=1,mx=dif){
		ri p=0;
		for(ri i=n-len+1;i<=n;++i)tmp[++p]=i;
		for(ri i=1;i<=n;++i)
			if(sa[i]>len)
				tmp[++p]=sa[i]-len;
		base_sort();
		swap(rk,tmp);
		rk[sa[1]]=dif=1;
		for(ri i=2;i<=n;++i){
			if(tmp[sa[i-1]]!=tmp[sa[i]]||tmp[sa[i-1]+len]!=tmp[sa[i]+len])++dif;
			rk[sa[i]]=dif;
		}
	}
}
int ht[maxn];
inline void calc_ht(){
	for(ri i=1,h=0;i<=n;++i){
		if(h)--h;
		ri j=sa[rk[i]-1];
		while(s[i+h]==s[j+h])++h;
		ht[rk[i]]=h;
	}
}
struct node{
	int id,val;
	inline bool operator<(const node &k)const{
		return val<k.val;
	}
}b[maxn];
template<class T>
struct ST{
	int lg;
	T st[19][maxn];
	inline void build(T *arr,int siz){
		lg=log2(siz);
		for(ri i=0;i<=lg;++i)clear(st[i],siz);
		for(ri i=1;i<=siz;++i)st[0][i]=arr[i];
		for(ri i=1;i<=lg;++i)
			for(ri j=1;j+(1<<(i-1))<=siz;++j)
				st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);
	}
	inline T query(int l,int r){
		ri k=log2(r-l+1);
		return min(st[k][l],st[k][r-(1<<k)+1]);
	}
};
ST<int>st1;
ST<node>st2;
ll ans;
inline ll mul(ll x,ll y){
	ll ret=0;
	for(;y;x=(x+x)%mod,y>>=1)if(y&1)ret=(ret+x)%mod;
	return ret;
}
inline void calc(int l,int r){
	if(l>=r)return;
	node mid=st2.query(l,r-1);
	ans=(ans+mul(mul(mid.id-l+1,r-mid.id),mid.val))%mod;
	calc(l,mid.id),calc(mid.id+1,r);
}
int main(){
	scanf("%d%d%s",&n,&q,s+1);
	suffix_sort();
	calc_ht();
	st1.build(ht,n);
	while(q--){
		ri l;
		scanf("%d",&l);
		for(ri i=1;i<=l;++i)scanf("%d",a+i),a[i]=rk[a[i]];
		sort(a+1,a+l+1);
		l=unique(a+1,a+l+1)-a-1;
		if(l>1){
			for(ri i=1;i<l;++i)b[i]={i,st1.query(a[i]+1,a[i+1])};
			st2.build(b,l-1);
		}
		ans=0;
		calc(1,l);
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：401rk8 (赞：2)

Orz 巨佬的 SAM 和后缀树做法

来一个朴素的 SA +单调栈

看到这题不难想到 [P4248 [AHOI2013]差异](https://www.luogu.com.cn/problem/P4248)，发现两题的区别在于本题是给定的点两两组合，而差异是全部 $n$ 个点，但类似的地方在于 **两点的贡献（lcp）都是区间 $height$ 的最小值**。  
考虑差异中单调栈求答案是利用 $height$（表示 $sa$ 中相邻两后缀的 lcp）将 lcp 转换成 RMQ，若能求出类似的 $h'$ 本题就能转化成差异。而 $height$ 本质也是长度为 $1$ 的区间最小值，与 $h'$ 区别仅是区间长度。  
加上 $\sum t\le3\times 10^6$ 这种数据范围与虚树类似，想到进行类似虚树的转化，即将给定的点按 $rk$ 排序去重后求相邻两点的 $h'[i]=lcp(s[a[i-1]:n],s[a[i]:n])$（ST 表），显然 $h'$ 与差异中的 $height$ 具有相同的性质，单调栈求所有子区间最小值之和即可。  
时间复杂度 $O(n\log n+\sum t\log t)$。

code（处理每次询问的部分）
```cpp
void solve() {
	read(na);
	For(i,1,na) read(a[i]);
	sort(a+1,a+na+1,[](const int &x,const int &y){return rk[x]<rk[y];});
	na = unique(a+1,a+na+1)-a-1;
	rFor(i,na,2) a[i] = lcp(a[i-1],a[i]); // 求suf(a[i-1]),suf(a[i])的lcp
	a[1] = 0, stk[++tp] = 1; // 下同《差异》
	For(i,2,na) {
		while( tp && a[i] < a[stk[tp]] ) ri[stk[tp--]] = i-1;
		le[i] = stk[tp]+1, stk[++tp] = i;
	}
	while( tp ) ri[stk[tp--]] = na;
	LL ans = 0;
	For(i,2,na) ans = (ans + a[i]*(i-le[i]+1ll)%mod*(ri[i]-i+1)) %mod;
	printf("%lld\n",ans);
}
```

---

## 作者：Strelitzia (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P7409)

前置知识：虚树，后缀自动机。

题目要求：后缀两两之间的 $\text{lcp}$ 的长度之和

在做这道题前，可以先了解一个套路。

在 [NOI2015 品酒大会](https://www.luogu.com.cn/problem/P2178) 这道题中，我们将字符串倒着插入，那么，我们就可以较为方便的处理 $\text{lcp}$。

此时的两个子串的 $\text{lcp}$ 就是对应节点上 $\text{LCA}$ 的 $\operatorname{len}$ 的长度，所以，我们就可以通过计算一个节点的不同子树带来的贡献。

但实际上我们还需要一个数组来记录一它在自动机中的编号，也就是代码中的 $\operatorname{pos}$ 数组。

然后，我们会发现一个问题，就是对于一次询问我们一次 $\text{dp}$ 遍历整棵树是不科学的。

而且，我们发现，我们并不需要所有的点，那么我们可以建一棵虚树来 $\text{dp}$。

把上述的思路整合下了就可构成如下代码。

```cpp
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 3e6 + 5;
const long long MOD = 23333333333333333;

int nxt[N],ver[N],head[N],tot;
void addEdge(int u,int v) {nxt[++ tot] = head[u];ver[tot] = v;head[u] = tot;}

struct SAM {
	int ch[26];
	int len,fa,sz;
}sam[N];

int ncnt = 1,lst = 1;

void add(int c) {
	int p = lst;
	int u = lst = ++ ncnt;
	sam[u].len = sam[p].len + 1;
	for (; p && !sam[p].ch[c] ; p = sam[p].fa)
		sam[p].ch[c] = u;
	if (!p)
		sam[u].fa = 1;
	else {
		int q = sam[p].ch[c];
		if (sam[q].len == sam[p].len + 1)
			sam[u].fa = q;
		else {
			int spt = ++ ncnt;
			sam[spt] = sam[q];
			sam[spt].sz = 0;
			sam[spt].len = sam[p].len + 1;
			sam[u].fa = sam[q].fa = spt;
			for (; p && sam[p].ch[c] == q ; p = sam[p].fa)
				sam[p].ch[c] = spt;
		}
	}
}

char str[N];
long long ans;
vector<int> g[N];
int n,q,tim,top,tag;
int s[N],h[N],pos[N],dfn[N],dep[N],f[N][20],inc[N];

void dfs(int u) {
	dfn[u] = ++ tim;
	for (int i = 1 ; i < 20 ; ++ i)
		f[u][i] = f[f[u][i - 1]][i - 1];
	for (unsigned i = 0 ; i < g[u].size() ; ++ i) {
		int v = g[u][i];
		f[v][0] = u;
		dep[v] = dep[u] + 1;
		dfs(v);
	}
}

int LCA(int x,int y) {
	if (dep[x] < dep[y])
		swap(x,y);
	for (int i = 19 ; ~i ; -- i)
		if (dep[f[x][i]] >= dep[y])
			x = f[x][i];
	if (x == y)
		return x;
	for (int i = 19 ; ~i ; -- i)
		if (f[x][i] != f[y][i])
			x = f[x][i],y = f[y][i];
	return f[x][0];
}

bool cmp(int x,int y) {return dfn[x] < dfn[y];}

void build(int k) {
	sort(h + 1,h + 1 + k,cmp);
	k = unique(h + 1,h + 1 + k) - h - 1;
	s[top = 1] = 1;tot = 0;head[1] = 0;tag ++;
	for (int i = 1 ; i <= k ; ++ i) {
		inc[h[i]] = tag;
		if (h[i] != 1) {
			int l = LCA(h[i],s[top]);
			if (dfn[l] != dfn[s[top]]) {
				while (dfn[l] < dfn[s[top - 1]])
					addEdge(s[top - 1],s[top]),-- top;
				if (l == s[top - 1])
					addEdge(s[top - 1],s[top]),-- top;
				else
					head[l] = 0,addEdge(l,s[top]),s[top] = l;
			}
			head[h[i]] = 0;s[++ top] = h[i];
		}
	}
	for (int i = 1 ; i < top ; ++ i)
		addEdge(s[i],s[i + 1]);
}

void redfs(int u) {
	sam[u].sz = inc[u] == tag;
	for (int e = head[u] ; e ; e = nxt[e]) {
		int v = ver[e];
		redfs(v);
		sam[u].sz += sam[v].sz;
		ans += (sam[u].sz - sam[v].sz) * sam[v].sz * sam[u].len;
	}
}

int main () {
	scanf("%d %d",&n,&q);
	scanf("%s",str + 1);
	for (int i = n ; i ; -- i)
		add(str[i] - 'a'),pos[i] = lst;
	for (int i = 2 ; i <= ncnt ; ++ i)
		g[sam[i].fa].push_back(i);
	int x;
	dep[1] = 1;
	dfs(1);
	while (q --) {
		scanf("%d",&x);
		for (int i = 1 ; i <= x ; ++ i)
			scanf("%d",h + i);
		for (int i = 1 ; i <= x ; ++ i)
			h[i] = pos[h[i]];
		build(x);
		redfs(1);
		printf("%lld\n",ans % MOD);
		ans = 0;
	}
	return 0;
}
```

---

## 作者：SSerxhs (赞：2)

后缀树上虚树板子题。

设后缀树上根到每个节点 $u$ 形成的字符串为 $s_u$，则每个叶子节点的字符串对应一个后缀，那么对于叶子节点 $u,v$，后缀 $s_u,s_v$ 的 lcp 即为 $s_{\text{lca}(u,v)}$。那么答案即为给定点两两 lca 的深度和。由虚树的性质可知任意两点的 lca 都在虚树上，那么可以建出虚树，计算每个点会成为多少次 lca 即可。

```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int S=5e5+2,N=1e6+2;
int c[N][27],dep[N],f[N],t[N],zd[N],lj[N],nxt[N],fir[N],len[N],siz[N],fa[N],s[S];
int top[N],hc[N],dfn[N],dy[N],st[N],a[N];
int n,m,q,i,j,x,ds=1,point=1,ad,r,edge,remain,bs,fbs,cc,tp,ance;
ll ans;
inline void read(int &x)
{
    cc=getchar();
    while ((cc<48)||(cc>57)) cc=getchar();
    x=cc^48;cc=getchar();
    while ((cc>=48)&&(cc<=57))
    {
        x=x*10+(cc^48);
        cc=getchar();
    }
}
inline void xadd(int x,int y)
{
    lj[++bs]=y;
    nxt[bs]=fir[x];
    fir[x]=bs;
}
inline void add(int x,int y)
{
    lj[++fbs]=y;
    nxt[fbs]=fir[x];
    fir[x]=fbs;
}
inline void add(int x,int y,int z)
{
    lj[++fbs]=y;
    len[bs]=z;
    nxt[fbs]=fir[x];
    fir[x]=bs;
}
inline void add(int a,int b,int cc,int d)
{
    c[a][s[cc]]=++bs;
    f[bs]=cc;t[bs]=d;
    zd[bs]=b;
}
void dfs1(int x)
{
    siz[x]=1;
    if (!fir[x]) {dy[n-dep[x]+1]=x;return;}
    int i;
    for (i=fir[x];i;i=nxt[i])
    {
        dep[lj[i]]=dep[f[lj[i]]=x]+len[i];
        dfs1(lj[i]);
        siz[x]+=siz[lj[i]];
        if (siz[lj[i]]>siz[hc[x]]) hc[x]=lj[i];
    }
}
void dfs2(int x)
{
    dfn[x]=++bs;
    if (hc[x])
    {
        top[hc[x]]=top[x];
        dfs2(hc[x]);
        int i;
        for (i=fir[x];i;i=nxt[i]) if (lj[i]!=hc[x]) dfs2(top[lj[i]]=lj[i]);
    }
}
bool cmp(int x,int y)
{
    return dfn[x]<dfn[y];
}
inline int lca(register int x,register int y)
{
    while (top[x]!=top[y]) if (dep[top[x]]<dep[top[y]]) y=f[top[y]]; else x=f[top[x]];
    if (dep[x]<dep[y]) return x; return y;
}
inline void ins(int x)
{
    if (!tp) {st[tp=1]=x;return;}
    ance=lca(st[tp],x);
    while ((tp>1)&&(dep[st[tp-1]]>dep[ance]))
    {
        xadd(st[tp-1],st[tp]);
        --tp;
    }
    if (dep[st[tp]]>dep[ance]) xadd(ance,st[tp--]);
    if ((!tp)||(st[tp]!=ance)) st[++tp]=ance;
    st[++tp]=x;
}
void dfs3(int x)
{
    int i;
    for (i=fir[x];i;i=nxt[i])
    {
        dfs3(lj[i]);ans+=(ll)siz[x]*siz[lj[i]]*dep[x];
        siz[x]+=siz[lj[i]];
    }
}
void dfs4(int x)
{
    int i;
    for (i=fir[x];i;i=nxt[i]) dfs4(lj[i]);
    siz[x]=fir[x]=0;
}
int main()
{
    read(n);read(q);
    cc=getchar();
    while ((cc<'a')||(cc>'z')) cc=getchar();
    s[1]=cc-97;
    for (i=2;i<=n;i++) s[i]=getchar()-97;fa[1]=1;
    s[++n]=26;
    for (i=1;i<=n;i++)
    {
        ad=0;++remain;
        while (remain)
        {
            if (r==0) edge=i;
            if ((j=c[point][s[edge]])==0)
            {
                fa[ad]=point;
                fa[++ds]=1;
                add(ad=point,ds,edge,n);
                add(point,s[edge]);
            }
            else
            {
                if ((t[j]!=n)&&(t[j]-f[j]+1<=r))
                {
                    r-=t[j]-f[j]+1;
                    edge+=t[j]-f[j]+1;
                    point=zd[j];
                    continue;
                }
                if (s[i]==s[f[j]+r])
                {
                    ++r;fa[ad]=point;break;
                }
                fa[fa[ad]=++ds]=1;add(ad=ds,zd[j],f[j]+r,t[j]);
                add(ds,s[f[j]+r]);zd[j]=ds;t[j]=f[j]+r-1;
                add(ds,s[i]);fa[++ds]=1;add(ds-1,ds,i,n);
            }
            --remain;
            if ((r)&&(point==1))
            {
                --r;
                edge=i-remain+1;
            } else point=fa[point];
        }
    }//ukk后缀树，sam的可以按照自己板子来建
    for (i=1;i<=ds;i++) for (j=fir[i];j;j=nxt[j])
    {
        x=c[i][lj[j]];
        lj[j]=zd[x];
        len[j]=t[x]-f[x]+1;
    }
    memset(f+1,0,bs<<2);bs=0;
    dfs1(1);dfs2(top[1]=1);
    memset(siz+1,0,ds<<2);
    memset(fir+1,0,ds<<2);bs=0;
    while (q--)
    {
        read(m);ans=bs=0;
        for (i=1;i<=m;i++)
        {
            read(a[i]);siz[a[i]=dy[a[i]]]=1;
        }
        sort(a+1,a+m+1,cmp);if (a[1]!=1) ins(1);
        for (i=1;i<=m;i++) if ((i==1)||(a[i]!=a[i-1])) ins(a[i]);
        while (--tp) xadd(st[tp],st[tp+1]);
        dfs3(1);dfs4(1);printf("%lld\n",ans);
    }
}
```

---

## 作者：LostKeyToReach (赞：1)

哈哈，最近加训字符串题。

我们要求的式子为：

$$
\sum_{i = 1} ^ K \sum_{j = i + 1} ^ K \text{LCP}(s_i, s_j).
$$

其中 $s_i$ 表示以 $i$ 为起点的后缀，$K$ 为后缀集合的长度，记得需要去重。

然后我们计算一下 $\text{SA}$ 数组和 $\text{height}$ 数组，然后化简原式：

$$
\begin{aligned}
\sum_{i = 1} ^ K \sum_{j = i + 1} ^ K \text{LCP}(s_i, s_j) &= \sum_{i = 1} ^ K \sum_{j = i + 1} ^ K \min_{r_i + 1 \le k \le r_j} \{\text{height}_k\}.
\end{aligned}
$$

$r_i$ 表示 $s_i$ 的排名，同时也是 SA 数组的映射（注意此处我们令 $r_i < r_j$，只需排序即可）。这个东西怎么化的可以感性理解一下，就是后缀排序后所有后缀按照字典序从小到大排列所以必然会有连续的一段前缀共享 $s_i$ 和 $s_j$ 的 $\text{LCP}$ 且极小，故式子正确。

这个东西是一个很典型的求和问题，我们再转换一下，先令 $f_i = \min_{r_{i - 1} + 1 \le k \le r_i}\{\text{height}_k\}$，然后把原式转换为：

$$
\sum_{1 \le i < j \le K} \min_{i \le k \le j} \{f_i\}.
$$

$f_i$ 可以 ST 表预处理，然后拿单调栈做就行啦。

时间复杂度 $O(n \log n + \sum t \log t)$。

AC 代码（仅供参考，若需要理解可以格式化）：

```cpp
#include <bits/stdc++.h>
#define int long long
#define vi vt<int>
#define S std::ios::sync_with_stdio(0), \
    std::cin.tie(0), std::cout.tie(0)
using ll = long long;
using pii = std::pair<int, int>;
template<typename T> using vt = std::vector<T>;
#define all(x) (x).begin(),(x).end()
#define sz(x) ((int)(x).size())
#define For(i, a, b) for(int i = (a); i <= (b); ++i)
#define Rof(i, a, b) for(int i = (a); i >= (b); --i)
template<typename T> T chkmax(T& x, T y) {
    return (x < y) ? (x = y, y) : x; 
} template<typename T> T chkmin(T& x, T y) { 
    return (x > y) ? (x = y, y) : x; }
int fio = (S, 0); constexpr int N = 5e5 + 5, mod = 23333333333333333LL;
int sa[N], rk[20][N], tmp[N], buc[N], len, h[N], st[20][N];
int32_t main() {/*freopen("D:\\BaiduNetdiskDownload\\P7409_1.in", "r", stdin); */int n, m, kk; std::cin >> n >> m;
    std::string s; std::cin >> s; For(i, 1, n) buc[rk[0][i] = s[i - 1]] += 1;
    For(i, 1, 255) buc[i] += buc[i - 1]; Rof(i, n, 1) sa[buc[rk[0][i]]--] = i;
    for (int k = 1, p, v; (1 << (k - 1)) < n; ++k) {
        v = (1 << (k - 1)), p = 0; For(i, n - v + 1, n) tmp[++p] = i;
        For(i, 1, n) if (sa[i] > v) tmp[++p] = sa[i] - v; std::fill(buc, buc + n + 1, 0);
        For(i, 1, n) buc[rk[k - 1][i]]++; For(i, 1, n) buc[i] += buc[i - 1];
        Rof(i, n, 1) sa[buc[rk[k - 1][tmp[i]]]--] = tmp[i]; rk[k][sa[1]] = p = 1;
        For(i, 2, n) if (rk[k][sa[i]] = p, rk[k - 1][sa[i]] != rk[k - 1][sa[i - 1]]) ++p, ++rk[k][sa[i]];
            else if (rk[k - 1][sa[i] + v] != rk[k - 1][sa[i - 1] + v]) ++p, ++rk[k][sa[i]];
        if (p == n) break;
    } len = log2(n); vi ss(n + 1, 0), lg(n + 1, 0); ss[sa[1]] = 1; For(i, 2, n) ss[sa[i]] = i, lg[i] = lg[i >> 1] + 1;
    for (int i = 1, j = 0; i <= n; ++i) {if (ss[i] < 2) continue; kk = sa[ss[i] - 1];
        while (j <= std::min(n - i, n - kk) && s[i + j - 1] == s[kk + j - 1]) j++; h[ss[i]] = j, j -= !!j; 
    } For(i, 1, n) st[0][i] = h[i]; For(k, 1, 19) if ((1 << k) <= n) {
        For(i, 1, n - (1 << k) + 1) st[k][i] = std::min(st[k - 1][i], st[k - 1][i + (1 << k - 1)]);
    } auto query = [&](int l, int r) -> int {if (l > r) std::swap(l, r); if (l == r) return n - sa[l] + 1;
    return (++l, kk = lg[r - l + 1], std::min(st[kk][l], st[kk][r - (1 << kk) + 1]));};
    while (m--) {int t; std::cin >> t; vi pos(t); For(i, 0, t - 1) std::cin >> pos[i]; 
        std::sort(all(pos)), pos.erase(std::unique(all(pos)), pos.end()); int k = sz(pos);
        if (k < 2) std::cout << "0\n"; else {vi f(k); For(i, 0, k - 1) f[i] = ss[pos[i]]; std::sort(all(f));
        vi b(k), l = b, r = b;For(i, 1, k - 1) b[i] = query(f[i - 1], f[i]); std::stack<int> stk;
        For(i, 1, k - 1) {while (!stk.empty() && b[stk.top()] >= b[i]) stk.pop();
        l[i] = stk.empty() ? 0 : stk.top(); stk.emplace(i);} while (!stk.empty()) stk.pop();
        Rof(i, k - 1, 1) { while (!stk.empty() && b[stk.top()] > b[i]) stk.pop();
        r[i] = stk.empty() ? k : stk.top(); stk.emplace(i);
        } int ans = 0; For(i, 1, k - 1) (ans += (i - l[i]) * (r[i] - i) * b[i] % mod) %= mod;
        std::cout << ans << "\n"; /*OI 2025 RP+++*/}} return 0;
}
```

---

## 作者：MspAInt (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P7409)

先吐槽一下这个神秘的模数。

看到后缀 lcp 先做后缀排序得到 height 数组 $h$，两个后缀位置 $i,j$ 的 lcp 即为 $\operatorname{lcp}(i,j)=\min_{k=rk_i+1}^{rk_j}h_k$，其中 $rk_i$ 为后缀 $i$ 的排名。

稍加思考，我们将每次询问的集合 $S$ 按后缀排名 $rk$ 排序得到后缀序列 $p$（即 $rk_{p_{i-1}}<rk_{p_i}(1<i\le|S|)$），通过 st 表可以单次常数时间得出**排序后排名相邻后缀的 lcp** 为 $w_i=\operatorname{lcp}(p_{i-1},p_i)$。

这个题和 [\[AHOI2013\]差异](https://www.luogu.com.cn/problem/P4248) 很像，但是变成了集合而非全局询问。

于是类似地，考虑询问的后缀两两之间的 lcp 之和显然为 $\sum_{i=1}^{|S|-1}\sum_{j=i+1}^{|S|}\min_{k=i+1}^{j}w_k$，使用单调栈求出，注意不要算重。

Code:($\Theta(n\log n+m\log m)$)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10,M=20;
const long long mod=23333333333333333;
int n,m,q,sa[N],rk[N],h[N][M],x[N],y[N],c[N],lg[N],w[N],st[N],top,l[N],r[N],p[N];
char s[N];
long long ans;
int query(int x,int y){
    int z=lg[y-x+1]-1;
    return min(h[x][z],h[y-(1<<z)+1][z]);
}
bool cmp(int x,int y){
    return rk[x]<rk[y];
}
signed main(){
    // freopen("P7409_1.in","r",stdin);
    // freopen("P7409.out","w",stdout);
    scanf("%d%d%s",&n,&q,s+1);
    m=1<<7;
    for(int i=1;i<=n;i++)x[i]=s[i],c[x[i]]++;
    for(int i=1;i<=m;i++)c[i]+=c[i-1];
    for(int i=n;i>=1;i--)sa[c[x[i]]--]=i;
    for(int k=1;k<=n;k<<=1){
        int l=0;
        for(int i=n-k+1;i<=n;i++)y[++l]=i;
        for(int i=1;i<=n;i++)if(sa[i]>k)y[++l]=sa[i]-k;
        for(int i=1;i<=m;i++)c[i]=0;
        for(int i=1;i<=n;i++)c[x[i]]++;
        for(int i=1;i<=m;i++)c[i]+=c[i-1];
        for(int i=n;i>=1;i--)sa[c[x[y[i]]]--]=y[i];
        swap(x,y);
        x[sa[1]]=l=1;
        for(int i=2;i<=n;i++)x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k])?l:++l;
        if((m=l)==n)break;
    }
    for(int i=1;i<=n;i++)rk[sa[i]]=i;
    for(int i=1,j=0;i<=n;i++){
        if(j)j--;
        while(s[i+j]==s[sa[rk[i]-1]+j])j++;
        h[rk[i]][0]=j;
    }
    for(int i=1;i<=n;i++)lg[i]=lg[i>>1]+1;
    for(int j=1;j<lg[n];j++)
        for(int i=0;i+(1<<j-1)<=n;i++)
            h[i][j]=min(h[i][j-1],h[i+(1<<j-1)][j-1]);
    while(q--){
        int cnt;ans=0;
        scanf("%d",&cnt);
        for(int i=1;i<=cnt;i++)scanf("%d",&p[i]);
        sort(p+1,p+cnt+1);
        cnt=unique(p+1,p+cnt+1)-p-1;
        sort(p+1,p+cnt+1,cmp);
        w[1]=0;
        for(int i=2;i<=cnt;i++)w[i]=query(rk[p[i-1]]+1,rk[p[i]]);
        st[top=0]=0;
        for(int i=1;i<=cnt;i++){
            while(top&&w[st[top]]>w[i])top--;
            l[i]=st[top];
            st[++top]=i;
        }
        st[top=0]=cnt+1;
        for(int i=cnt;i>=1;i--){
            while(top&&w[st[top]]>=w[i])top--;
            r[i]=st[top];
            st[++top]=i;
        }
        for(int i=2;i<=cnt;i++)ans=(ans+1ll*w[i]*(r[i]-i)%mod*(i-l[i])%mod)%mod;
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：critnos (赞：1)

## 暴力 SA+笛卡尔树+虚树

这个后缀 lcp 可以转成 height 上 RMQ 是众所周知的。

也就是说要求这个式子

$$\sum_{i=1}^q \sum_{j=i+1}^q \min_{k=p_i+1}^{p_j} height_k$$

这好像不是很好搞。。区间 min 的话，就秒出一个笛卡尔树。

也就是这个：

$$\sum_{i=1}^q \sum_{j=i+1}^q val_{lca(p_i+1,p_j)}$$

都 lca 了，那就可以反向求每个节点的贡献了，每个节点的出现次数就是左子树和自己的 $p_i+1$ 的个数乘上右子树和自己的 $p_j$ 的个数。

就是这个

$$\sum val_i\times (lsum_{i_ltree}+lsum_i)\times (rsum_{i_rtree}+rsum_i)$$

不过他还多次询问，那就建个虚树。

做完了！

细节：

1. 笛卡尔树上 lca 怎么搞？树剖？一个 RMQ 搞定。。所以我们并不需要显式的建出笛卡尔树。事实上，只有他的 dfn 序要用。

2. 虚树上你确定最多有两个儿子？看这里 https://www.luogu.com.cn/blog/2-6-5-3-5/wei-shi-me-yi-ke-k-cha-shu-shang-yi-ren-yi-dian-ji-jian-li-xu-shu-xu-post

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod=23333333333333333;
char s[500005];
int read_in[3000005];
int st[6000005];
int n;
struct SA
{
	#define f(i,a,b) for(i=a;i<=b;i++)
	#define e(i,a,b) for(i=a;i>=b;i--)
	int sa[500005],height[500005];
	int cnt[500005],rk[500005];
	void S_sort(char s[],int l,int m=122)
	{
		int i,k,ct;
		f(i,1,l) cnt[height[i]=s[i]]++;
		f(i,2,m) cnt[i]+=cnt[i-1];
		e(i,l,1) sa[cnt[height[i]]--]=i;
		for(k=1;k<=l;k*=2)
		{
			ct=0;
			f(i,l-k+1,l) rk[++ct]=i;
			f(i,1,l)
				if(sa[i]>k)
					rk[++ct]=sa[i]-k;
			f(i,1,m) cnt[i]=0;
			f(i,1,l) cnt[height[i]]++;
			f(i,2,m) cnt[i]+=cnt[i-1];
			e(i,l,1) sa[cnt[height[rk[i]]]--]=rk[i],rk[i]=0;
			swap(height,rk);
			height[sa[1]]=m=1;
			f(i,2,l)
				height[sa[i]]=m=m+!(rk[sa[i]]==rk[sa[i-1]]&&rk[sa[i]+k]==rk[sa[i-1]+k]);
			if(m==l) return;	
		}
	}
	void build(char s[],int l)
	{
		S_sort(s,l);	
		int i,j,k;
		for(i=1;i<=l;i++)
			rk[sa[i]]=i;
		for(i=1,k=0;i<=l;i++)
		{
			if(rk[i]==1) k=0;
			else
			{
				k-=k>0;
				int j=sa[rk[i]-1];
				while(i+k<=l&&j+k<=l&&s[i+k]==s[j+k])
					k++;
			}
			height[rk[i]]=k;
		}
	}
}a;
int st_min[21][500005];
int v[500005];
int lsum[500005];
int rsum[500005];
int dfn[500005];
int hu[500005][2];
int root,dfnn;
bool cmp(int x,int y)
{
	return dfn[x]<dfn[y];
}
int f_min(int x,int y)
{
	if(v[x]==v[y]) return x<y?x:y;
	return v[x]<v[y]?x:y;
}
int asklca(int l,int r)
{
	if(l>r) swap(l,r);
	int k=log2(r-l+1);
	return f_min(st_min[k][l],st_min[k][r-(1<<k)+1]);
}
void build_Cartesian_Tree(int L,int R)
{
	if(L>R) return;
	int mid=asklca(L,R);
	dfn[mid]=++dfnn;
	build_Cartesian_Tree(L,mid-1);
	build_Cartesian_Tree(mid+1,R);
}
void build(int a[],int n)
{
	int i,j;
	v[1]=-1e9;
	for(i=2;i<=n;i++)
		v[i]=a[i];
	for(i=1;i<=n;i++)
		st_min[0][i]=i;
	for(i=1;i<=20;i++)
		for(j=1;j+(1<<i)-1<=n;j++)
			st_min[i][j]=f_min(st_min[i-1][j],st_min[i-1][j+(1<<i-1)]);
	build_Cartesian_Tree(2,n);	
	root=asklca(2,n);
}
ll dfs(int d)
{
	if(!d) return 0;
	ll s=dfs(hu[d][0])+dfs(hu[d][1]);
	s+=1ll*(lsum[hu[d][0]]+lsum[d])*(rsum[hu[d][1]]+rsum[d])*v[d];
	lsum[d]+=lsum[hu[d][0]]+lsum[hu[d][1]],
	rsum[d]+=rsum[hu[d][0]]+rsum[hu[d][1]];
	return s;
}
ll ask(int k)
{
	int i,j,cnt,lca;
	cnt=0;
	for(i=1;i<=k;i++)
	{
		read_in[i]=a.rk[read_in[i]];
		if(read_in[i]+1<=n)
			lsum[st[++cnt]=read_in[i]+1]=1;
		if(read_in[i]>=2)
			rsum[st[++cnt]=read_in[i]]=1;
	}	
	k=cnt;
	sort(st+1,st+1+k,cmp);
	for(i=2;i<=k;i++)
		st[++cnt]=asklca(st[i-1],st[i]);
	st[++cnt]=root;
	sort(st+1,st+1+cnt,cmp);
	cnt=unique(st+1,st+1+cnt)-st-1;
	for(i=2;i<=cnt;i++)
	{
		lca=asklca(st[i-1],st[i]);
		hu[lca][st[i]>lca]=st[i];
	}
	ll ret=dfs(root)%mod;	
	for(i=1;i<=cnt;i++)
		hu[st[i]][0]=hu[st[i]][1]=lsum[st[i]]=rsum[st[i]]=0;
	return 	ret;
}
int main()
{
	int q,k,i;
	scanf("%d%d%s",&n,&q,s+1);
	a.build(s,n);
	build(a.height,n);
	while(q--)
	{
		scanf("%d",&k);
		for(i=1;i<=k;i++)
			scanf("%d",&read_in[i]);
		printf("%lld\n",ask(k));
	}
}	
```


---

## 作者：happybob (赞：0)

题意：

给定一个长度为 $n$ 的小写英文字符串 $s$ 和 $q$ 次询问。每次给一个大小为 $k_i$ 的整数集合，询问集合内两两不同数代表的后缀的 LCP 的长度和，对大质数取模。

$1 \leq n \leq 5 \times 10^5$，$1 \leq \sum k_i \leq 3 \times 10^6$，时限 $3$ 秒，空间限制 $512$ MB。

解法：

刻画后缀 LCP 的常见做法有很多。

一个做法是，考虑后缀排序，根据 SA 相关结论，两个后缀的 LCP 等价于区间 $\min$。询问时先进行相邻的 RMQ，然后单调栈求值即可。

另一方面，仍然考虑 SA，但是将区间 $\min$ 刻画为笛卡尔树上 LCA 点权，显然对询问点建虚树即可。

不用 SA，直接考虑后缀树。容易发现后缀 LCP 等于后缀树上 LCA 到根路径长，进一步等于反串 SAM 的 Link 树上 LCA 的等价类最大长度。所以同样对询问点建虚树即可。


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <array>
#include <queue>
#include <vector>
#include <set>
using namespace std;

using ll = long long;

constexpr int N = 1e6 + 5;

int n, q;
string s;
array<vector<int>, N> G, NG;
array<int, N> dfn;
array<int, N> sza, szb;
array<bool, N> isa, isb;
array<int, N> pos, len;

struct Node
{
	array<int, 26> son;
	int fa, len;
};

int id;
array<Node, N> g;
int lst, tot;
array<array<int, 20>, N> faf;
array<int, N> dep;

void SAM_Extend(int c)
{
	int p = lst, np = lst = ++tot;
	g[np].len = g[p].len + 1;
	for (; p && g[p].son[c] == 0; p = g[p].fa) g[p].son[c] = np;
	if (!p) g[np].fa = 1;
	else
	{
		int q = g[p].son[c];
		if (g[q].len == g[p].len + 1) g[np].fa = q;
		else
		{
			int nq = ++tot;
			g[nq] = g[q];
			g[nq].len = g[p].len + 1;
			g[np].fa = g[q].fa = nq;
			for (; p && g[p].son[c] == q; p = g[p].fa) g[p].son[c] = nq;
		}
	}
}

void dfs(int u)
{
	dfn[u] = ++id;
	for (auto& j : G[u])
	{
		dep[j] = dep[u] + 1;
		faf[j][0] = u;
		dfs(j);
	}
}

inline int LCA(int u, int v)
{
	if (dep[u] < dep[v]) swap(u, v);
	int k = dep[u] - dep[v], c = 0;
	while (k)
	{
		if (k & 1) u = faf[u][c];
		k >>= 1;
		c++;
	}
	if (u == v) return u;
	for (int i = 19; i >= 0; i--) if (faf[u][i] ^ faf[v][i]) u = faf[u][i], v = faf[v][i];
	return faf[u][0];
}

ll ans = 0ll;

inline void dfs2(int u)
{
	sza[u] = isa[u];
	szb[u] = isb[u];
	for (auto& j : NG[u])
	{
		dfs2(j);
		sza[u] += sza[j], szb[u] += szb[j];
	}
	//cout << "!!!: " << u << " " << len[u] << " " << len[u] << "\n";
	for (auto& j : NG[u])
	{
		ans += 1ll * len[u] * sza[j] * (szb[u] - szb[j]);
	}
	if (isa[u]) ans += 1ll * len[u] * szb[u];
}

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	lst = tot = 1;
	cin >> n >> q >> s;
	reverse(s.begin(), s.end());
	s = " " + s;
	for (int i = 1; i <= n; i++) SAM_Extend(s[i] - 'a');
	for (int i = 2; i <= tot; i++) G[g[i].fa].emplace_back(i), len[i] = g[i].len;
	int nowpos = 1;
	for (int i = 1; i <= n; i++) pos[i] = (nowpos = g[nowpos].son[s[i] - 'a']);
	dfs(1);
	for (int j = 1; j <= 19; j++)
	{
		for (int i = 1; i <= tot; i++) faf[i][j] = faf[faf[i][j - 1]][j - 1];
	}
	while (q--)
	{
		ans = 0ll;
		int sa; 
		cin >> sa;
		int sb = sa;
		vector<int> va, vb, comb;
		ll sum = 0ll;
		for (int i = 1; i <= sa; i++)
		{
			int x;
			cin >> x;
			int rx = x;
			x = pos[n - x + 1];
			if (isa[x]) continue;
			sum += n - rx + 1;
			va.emplace_back(x);
			isa[x] = 1;
			isb[x] = 1;
			comb.emplace_back(x);
		}
		vb = va;
		comb.emplace_back(1);
		sort(comb.begin(), comb.end(), [&](const int& x, const int& y) {return dfn[x] < dfn[y]; });
		comb.erase(unique(comb.begin(), comb.end()), comb.end());
		int sz = comb.size();
		for (int i = 0; i + 1 < sz; i++)
		{
			comb.emplace_back(LCA(comb[i], comb[i + 1]));
		}
		sort(comb.begin(), comb.end(), [&](const int& x, const int& y) {return dfn[x] < dfn[y]; });
		comb.erase(unique(comb.begin(), comb.end()), comb.end());
		for (int i = 0; i + 1 < comb.size(); i++)
		{
			int L = LCA(comb[i], comb[i + 1]);
			NG[L].emplace_back(comb[i + 1]);
		}
		dfs2(1);
		ans -= sum;
		ans /= 2;
		cout << ans % 23333333333333333ll << "\n";
		for (auto& i : va) isa[i] = 0;
		for (auto& i : vb) isb[i] = 0;
		for (auto& i : comb) NG[i].clear(), NG[i].shrink_to_fit();
	}
	return 0;
}
```

---

## 作者：UncleSam_Died (赞：0)

### 前置知识
- 后缀数组；
- height 数组。

### 题目大意
给出一个字符串 $s$，每次查询 $s$ 若干个后缀两两之间的 LCP 和，答案对 $23333333333333333$ 取模。
### 解题思路
首先对于 $s$ 求出 $height$ 数组和 $rank$ 数组，接下来我们可以对所有后缀在 $s$ 的后缀排序后的位置，即 $rank_i$ 进行从小到大排序。因为可能存在相同的后缀，所以这里需要离散化一下。那么，这个时候问题即转化为求这些排序后的后缀两两之间的 LCP。

考虑 $height$ 数组的性质：

- 对于排序后的两个后缀 $suffix_i$ 和 $suffix_j$，有 $\displaystyle LCP(suffix_i,suffix_j)=\min_{k=i}^j height_k$；

那么，设每次查询的后缀，排序后起始位置为 $suf_1,\dots,suf_t$，那么相邻两个后缀的 LCP 为 $\displaystyle \min_{j=suf_i}^{suf_{i+1}} height_i$，这个时候我们就可以用 ST 表来快速计算相邻两个后缀的 LCP。

但是，显然我们不能枚举两个后缀然后计算它们的 LCP。这个时候我们就需要使用单调栈。我们可以令 $h_i=LCP(i,i-1)$，那么可以得到 $\displaystyle h_i=\min_{j=suf_i}^{suf_{i+1}} height_j$，特殊的，$h_1=1$。这样，我们就可以用单调栈来计算出每个 $h_i$ 对答案的贡献，从而计算出 $\displaystyle \sum_{1\le i<j\le t} LCP(i,j)$ 的值了。

时间复杂度 $O(n\log n+\sum \mid t\mid \log (\sum \mid t\mid))$。
### AC 代码
```cpp
#include<stdio.h>
#include<string.h>
#include <valarray>
#define int long long
#define N 1000005
#define Mode 23333333333333333
int cnt[N],SA[N],pos[N];
int rank[N],height[N];
char s[N];int n,q;
inline void GetSA(){int m='z';
    memset(cnt,0,sizeof(cnt));
    for(register int i=1;i<=n;++i)
        ++cnt[rank[i]=s[i]];
    for(register int i=1;i<=m;++i)
        cnt[i]+=cnt[i-1];
    for(register int i=n;i;--i)
        SA[cnt[rank[i]]--]=i;
    for(register int k=1;k<=n;k<<=1){
        int num=0;
        for(register int i=n-k+1;i<=n;++i)
            pos[++num]=i;
        for(register int i=1;i<=n;++i)
            if(SA[i]>k) pos[++num]=SA[i]-k;
        memset(cnt,0,sizeof(cnt));
        for(register int i=1;i<=n;++i)
            ++cnt[rank[i]];
        for(register int i=1;i<=m;++i)
            cnt[i]+=cnt[i-1];
        for(register int i=n;i;--i)
            SA[cnt[rank[pos[i]]]--]=pos[i],pos[i]=0;
        std::swap(rank,pos),rank[SA[1]]=1,num=1;
        for(register int i=2;i<=n;++i)
            rank[SA[i]]=
                num+=pos[SA[i]]^pos[SA[i-1]]
                ||pos[SA[i]+k]^pos[SA[i-1]+k];
        if(num==n) break;m=num;
    }
}
inline void GetHeight(){
    for(register int i=1;i<=n;++i)
        rank[SA[i]]=i;
    for(register int i=1,k=0;i<=n;++i){
        if(rank[i]==1) continue;if(k)--k;
        for(register int j=SA[rank[i]-1];
        i+k<=n&&j+k<=n&&s[i+k]==s[j+k];++k);
            height[rank[i]]=k;
    }
}
int mint[N][30],lg[N];
inline void InitST(){lg[0]=-1;
    for(register int i=1;i<=n;++i){
        lg[i]=lg[i>>1]+1;
        mint[i][0]=height[i];
    }for(register int j=1;j<=lg[n];++j)
    for(register int i=1;i+(1<<j)<=n+1;++i)
        mint[i][j]=std::min(mint[i][j-1],
            mint[i+(1<<(j-1))][j-1]);
}
inline int GetMint(int l,int r){
    if(l>r) std::swap(l,r);
    int k=lg[r-l+1];
    return std::min(mint[l][k], 
        mint[r-(1<<k)+1][k]);
}
int sta[N],tail,l[N],r[N];
int p[N],h[N],ans,ce,all;
inline void Query(){
    scanf("%lld",&all);
    for(register int i=1;i<=all;++i)
        scanf("%lld",&p[i]);
    for(register int i=1;i<=all;++i)
        p[i]=rank[p[i]];
    std::sort(p+1,p+all+1);
    ce=std::unique(p+1,p+all+1)-p-1;
    for(register int i=2;i<=ce;++i)
        h[i]=GetMint(p[i-1]+1,p[i]);
    h[1]=0;sta[1]=1;tail=1;ans=0;
    for(register int i=2;i<=ce;++i){
        while(tail&&h[sta[tail]]>h[i])
            r[sta[tail--]]=i;
        l[i]=sta[tail];sta[++tail]=i;
    }while(tail) r[sta[tail--]]=ce+1;
    for(register int i=2;i<=ce;++i){
        ans+=(r[i]-i)*(i-l[i])
        *h[i];
        ans=ans;
    }printf("%lld\n",ans);
}
signed main(){
    scanf("%lld%lld",&n,&q);
    scanf("%s",s+1);
    GetSA();GetHeight();
    InitST();
    while(q--) Query();
}
```

---

## 作者：hegm (赞：0)

### [SvT](https://www.luogu.com.cn/problem/P7409)

学习了如何建立后缀树，后缀树的本质其实就是压位的 trie，又因为追求极限的压位，可能会把本来的某一个后缀压没，所以对于每一个后缀，都要加一个特殊标识符来确定他的位置。

![](https://cdn.luogu.com.cn/upload/image_hosting/7az962wd.png)

这就是一个后缀树，考虑如何使用 $\text{SAM}$ 来建立他。首先 $\text{SAM}$ 的东西都是从头添加，所以要反过来。

容易发现 $\text{SAM}$ 也是高度压位的，那么对于反过来的 $\text{SAM}$，记录下每一个位置的结束点，那么他包含的字符中一定有原串以此为开始的后缀。

首先，对于每一个点缀一个 $\text{\$}$ 孩子表示它是一个后缀，容易发现原本 $\text{SAM}$ 上一个点对应的是一段长度，不好处理，但是现在，每个节点肯定最多只包含一个终止节点。

又因为 $mx$ 不可能超过以这个节点开始的后缀，因为超过了他们也就不会在同一个 endpos 集合里了。

那么后缀树直接就是此时的 parent tree 了。边权就是连接两点的 $mx$ 之差。

然后简单树形 dp 就可以了。

注意，这道题目有点卡常，建议使用 $O(1) \text{lca}$ 来建立虚树。

```cpp
#include<bits/stdc++.h>
#define N 1000005
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,m,id[N],last=1,tot=1,mx[N],fa[N],ch[N][27];
long long ans;
char c[N];
stack<int> t;
struct fig
{
	struct tree
	{
		int to,next,w;
	}k[N*2];
	int head[N],tot,dep[N],dis[N],cnt,dfn[N],siz[N],num,id[N],fa[N];
	void clear(int n)
	{
		for(int i=1;i<=n;i++)
		{
			head[i]=dep[i]=dis[i]=dfn[i]=siz[i]=0;
			fa[i]=0;
		}
		tot=cnt=num=0;
	}
	int sum=0,u[N*2],kl[N*2];
	struct point
	{
		int u,w;
	}st[N*2][21];
	point mn(point a,point b)
	{
		if(a.w<b.w)return a;
		return b;
	}
	void build()
	{
		for(int i=1;i<=sum;i++)st[i][0]=point{u[i],dep[u[i]]};
		for(int i=1;i<=20;i++)
		{
			for(int j=1;j<=sum;j++)
			st[j][i]=mn(st[j][i-1],st[j+(1<<(i-1))][i-1]);
		}
	}
	void add(int from,int to,int val)
	{
		k[++tot].to=to;
		k[tot].w=val;
		k[tot].next=head[from];
		head[from]=tot;
	}
	void dfs(int now,int f)
	{
		dep[now]=dep[f]+1;dfn[now]=++cnt;
		u[++sum]=now;kl[now]=sum;fa[now]=f;
		for(int i=head[now];i;i=k[i].next)
		{
			if(k[i].to==f)continue;
			dis[k[i].to]=dis[now]+k[i].w;
			dfs(k[i].to,now);
			u[++sum]=now;
		}
	}
	int lca(int a,int b)
	{
		if(kl[a]>kl[b])swap(a,b);
		a=kl[a];b=kl[b];
		int len=__lg(b-a+1);
		return mn(st[a][len],st[b-(1<<len)+1][len]).u;
	}
	int get(int a,int b)
	{
		if(dep[a]<dep[b])swap(a,b);
		return dis[a]-dis[b]; 
	}
	void solve(int now)
	{
		for(int i=head[now];i;i=k[i].next)
		{
			if(k[i].to==fa[now])continue;
			solve(k[i].to);
			ans+=1ll*siz[now]*siz[k[i].to]*dis[now];
			siz[now]+=siz[k[i].to];
		}
	}
}T1,T2;
void Push(int c)
{
	int np=++tot,p=last;last=np;mx[np]=mx[p]+1;
	for(;p&&!ch[p][c];p=fa[p])ch[p][c]=np;
	if(p==0)
	{
		fa[np]=1;
		return ;
	}
	int q=ch[p][c];
	if(mx[q]==mx[p]+1)fa[np]=q;
	else
	{
		int nq=++tot;
		mx[nq]=mx[p]+1;
		fa[nq]=fa[q];
		fa[q]=fa[np]=nq;
		for(int i=1;i<=26;i++)ch[nq][i]=ch[q][i];
		for(;p&&ch[p][c]==q;p=fa[p])ch[p][c]=nq;
	}
}
bool cmp(int a,int b){return T1.dfn[a]<T1.dfn[b];}
signed main()
{
	n=read();m=read();
	scanf("%s",c+1);
	for(int i=n;i>=1;i--)
	{
		Push(c[i]-'a'+1);
		id[i]=last;
	}
	for(int i=2;i<=tot;i++)T1.add(fa[i],i,mx[i]-mx[fa[i]]);
	T1.dfs(1,0);
	T1.build();
	int s,p[N];
	while(m--)
	{
		s=read();ans=0;
		for(int i=1;i<=s;i++)p[i]=id[read()];
		sort(p+1,p+1+s,cmp);
		t.push(1);T2.id[1]=++T2.num;
		for(int i=1;i<=s;i++)
		{
			if(p[i]==1)
			{
				T2.siz[1]=1;
				continue;
			}
			if(p[i]==p[i-1])continue;
			int x=p[i],y=0;
			while(T1.lca(t.top(),x)!=t.top())
			{
				y=t.top();t.pop();
				if(T1.lca(t.top(),x)!=t.top())T2.add(T2.id[t.top()],T2.id[y],T1.get(t.top(),y));
			}
			if(y)
			{
				int z=T1.lca(y,x);
				if(z!=t.top())t.push(z),T2.id[z]=++T2.num;
				T2.add(T2.id[z],T2.id[y],T1.get(z,y));
			}
			T2.id[x]=++T2.num;
			T2.siz[T2.num]=1;
			t.push(x);
		}
		while(t.size()>1)
		{
			int x=t.top();t.pop();
			T2.add(T2.id[t.top()],T2.id[x],T1.get(x,t.top()));
		} 
		T2.dfs(1,0);
		T2.solve(1);
		T2.clear(T2.num);
		cout<<ans<<"\n";
	}
	return 0;
}
```

---


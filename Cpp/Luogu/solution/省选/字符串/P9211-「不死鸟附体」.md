# 「不死鸟附体」

## 题目背景

死而复生，生而复死。所谓的不死鸟就是这样的一种生物，在无尽的时间里无尽地循环往复。

果然最好还是别获得不老不死的能力吧。

## 题目描述

不死鸟的「一生」可以被看成一个长度不超过 $l_{\max}$ 的字符串 $S_0$。在无尽的轮回后形成了一个无限长的字符串 $S_{\mathrm{inf}}=S_0+S_0+S_0+\cdots$。现在截取 $S_{\mathrm{inf}}$ 前 $l$ 个字符，作为可观测时间里不死鸟的生命 $S_{\mathrm{fin}}$。

然而所谓的轮回并不是机械死板的循环往复。因此，$S_\mathrm{fin}$ 当中会有**不超过 $n$ 个字符**被修改成了别的字符，变成了 $S_{\mathrm{real}}$。

现在观测到了 $S_{\mathrm{real}}$，我们希望找到这轮回的周期 $S_0$。然而由于不死鸟的轮回太过漫长，我们只希望找到这样一个 $S_0'$，使得由它生成的 $S_\mathrm{fin}'$ 修改**不超过 $m$ 个字符**后就可以变成 $S_{\mathrm{real}}$。


## 说明/提示

### 样例解释

样例仅供理解题意，**不符合数据范围的约束**。具体约束请参见「数据范围及约定」。

生成 $S_{\mathrm{real}}$ 所用的 $S_0=\verb!aabcd!$。

- 由此生成 $S_{\mathrm{inf}}=\verb!aabcdaabcdaabcdaabcdaabcd!\cdots$；
- 由此生成 $S_{\mathrm{fin}}=\verb!aabcdaabcdaabcdaabcdaabcd!$；
- 由此生成 $S_{\mathrm{real}\kern{-2.5pt}}=\verb!aaacdaabbbaabccaabcdaabcd!$。

样例输出给出了一个可能的 $S_0'=\verb!aaacd!$。由此计算出 $S_{\mathrm{fin}}'$ 与 $S_{\mathrm{real}}$ 的差距：

$$\begin{aligned}
S_{\mathrm{fin}}'=&\texttt{aaacdaa\textcolor{red}a\textcolor{red}c\textcolor{red}daa\textcolor{red}ac\textcolor{red}daa\textcolor{red}acdaa\textcolor{red}acd}\cr
S_{\mathrm{real}}=&\texttt{aaacdaabbbaabccaabcdaabcd}\cr
\end{aligned}$$

相差为 $7$，不超过 $m=10$，可以被接受。

### 数据范围及约定

对于全部数据，保证 $l=3\times 10^5$，$n=3\times 10^3$，$m=10^4$，$1\le l_{\max} \le 10^5$。

## 样例 #1

### 输入

```
25 8 5 10
aaacdaabbbaabccaabcdaabcd
```

### 输出

```
5
aaacd```

# 题解

## 作者：honglan0301 (赞：8)

## 题目分析

感觉没有很好的性质，但是观察 $n=3\times10^3,m=10^4,l=3\times10^5$ 的数据范围发现限制给的很松，一方面是 $S_\text{real}$ 与 $S_\text{fin}$ 的差距很小，另一方面是 $S'_\text{fin}$ 的容错率比较大，所以考虑简单的随机算法。

我们直接枚举 $S'_0$ 的长度 $len$, 对于每个长度随一些位置 $p_{1\dots k}$, 检测在随的这些 $p_i$ 中有多少个满足 $S_\text{real}[p_i]=S_\text{real}[p_i+len]$, 记作 $f_{len}$, 然后取 $\max f_{len}$ 所对应的 $len$ 作为 $l_0$ 即可，看数据范围容易发现正确率极高（因为时间限制足够随很多次，于是 $f_{len}\over k$ 与整体情况的偏差超过 $m\over n$ 的概率极低）。

那么随 $600$ 次，令 $S'_0$ 的每一位 $S'_0[i]$ 取 $S_\text{real}[k\times l_0+i]$ 中出现次数最多的字符即可通过本题。

## 代码

```cpp
/*
  author: PEKKA_l  
*/
#include <iostream>
#include <cstring>
#include <algorithm>
#include <random>
using namespace std;

int l,n,m,lmx,cnt[35];
char s[300005],ans[300005];
mt19937 mt_rand(time(0));

int getrd(int l,int r) {return l+mt_rand()%(r-l+1);}

int check(int len)//随机
{
	int cntt=0;
	for(int i=1;i<=600;i++) {int wz=getrd(0,l-len-1); if(s[wz]==s[wz+len]) cntt++;}
	return cntt;
}

signed main()
{
	cin>>l>>lmx>>n>>m>>s;
	int mxx=0,nmm;//枚举 l_0
	for(int i=lmx;i>=1;i--) {int nans=check(i); if(nans>mxx) {mxx=nans; nmm=i;}}
	for(int j=0;j<nmm;j++)
	{
		memset(cnt,0,sizeof(cnt)); int nnum=-1,nmax=0;
		for(int k=j;k<l;k+=nmm)
		{
			cnt[s[k]-'a'+1]++; if(cnt[s[k]-'a'+1]>nmax) {nmax=cnt[s[k]-'a'+1]; nnum=s[k]-'a'+1;}
		}
		ans[j]=(char)(nnum+'a'-1);
	}
	cout<<nmm<<endl<<ans<<endl;
}
```


---

## 作者：NKL丶 (赞：0)

## Description

给出一个长度为 $l$ 的小写字母字符串 $S_{fin}$，它由一个长度不超过 $lmax$ 的字符串 $S_0$ 无限循环后截取前 $l$ 位并修改其中不超过 $n$ 位得到。现给出整数 $m$，求一个长度不超过 $lmax$ 的字符串 $S_{0}^{'}$，使得对 $S_{0}^{'}$ 做相同操作后修改不超过 $m$ 位也能得到 $S_{fin}$。

（$l = 3 \times 10^5,n = 3 \times 10^3,m = 10^4,1 \le lmax \le 10^5$）

## Solution

神仙题。

首先要注意到 $m>3 \cdot n$ 这个范围约束，提示我们可以在较高容错率的情况下得到字符串。

假如我们知道了 $S_{0}^{'}$ 的一个可能长度为 $l^{'}$，那么就能将原串每 $l^{'}$ 位统计各个字母的出现个数，次数多的作为这一位的答案即可。

那么现在问题变成如何找到 $l^{'}$。前面提到 $n$ 比较小，也就是说，$S_{fin}$ 上不规则的位置是较少的，对应的，我们从字符串中随机选择一个位置 $pos$，满足 $S_{pos} = S_{pos+l^{'}}$ 的概率是较高的，换句话说，我们可以从串中随机抽取若干个位置，统计它们与下一次出现的位置相同的个数作为判断当前长度合法的依据。由于容错率较高，这样子做在抽样次数约为 500 时即可保证正确性。

## [Code](https://www.luogu.com.cn/paste/a1w09tal)

---


# [COCI 2024/2025 #1] 教师 / Učiteljica

## 题目背景

译自 [COCI 2024/2025 #1](https://hsin.hr/coci/) T4。$\texttt{5s,0.5G}$。满分为 $120$。

## 题目描述

给定长度为 $n$ 的正整数序列 $a_1,a_2,\cdots,a_n$。给定常数 $k$。

求出满足以下条件的二元组 $(l,r)$ 的数量：

- $1\le l\le r\le n$；
- 对于任意 $1\le i\le k$，都存在一个数 $x$，使得 $x$ 在 $a_l,a_{l+1},\ldots,a_r$ 间出现**恰好** $i$ 次。

## 说明/提示


对于 $100\%$ 的数据，保证：

- $1\le n\le 10^5$；    
- $1\le k\le 4$；
- $1\le a_i\le n$。


| 子任务编号 | $n\le$ |  特殊性质 | 得分 |  
| :--: | :--: | :--: |:--: | 
| $ 1 $    | $10^3$ |  |   $ 20 $   |  
| $ 2 $    | $10^5$ | A  |  $ 15 $   |  
| $ 3 $    | $10^5$ | B  |  $ 35 $   |  
| $ 4 $    | $10^5$ |  |  $ 50 $   |  

- 特殊性质 A：$1\le a_i\le k$。
- 特殊性质 B：$k=1$。



## 样例 #1

### 输入

```
3 1
1 2 1```

### 输出

```
6```

## 样例 #2

### 输入

```
6 3
6 5 6 4 5 5```

### 输出

```
1```

## 样例 #3

### 输入

```
6 2
5 4 5 2 6 5```

### 输出

```
5```

# 题解

## 作者：qwer6 (赞：5)

这道题还挺有意思，需要一步一步分析下来，最后才能发现正解算法。那我们可以来看点部分分想想正解是怎么来的。

## 子任务一

一个暴力就可以解决的问题。

具体的，我们枚举每一个区间，开一个 $cnt$ 数组，记录每一个数字出现的次数。然后，我们记录恰好出现一次，两次，三次，四次的数字个数，一边扩大区间，一边统计即可。

```c++
for(int l=1;l<=n;l++){
    fill(cnt+1,cnt+n+1,0);
    cnt1=cnt2=cnt3=cnt4=0;
    for(int r=l,x;r<=n;r++){
        x=cnt[a[r]];
        if(x==0)cnt1++;
        else if(x==1)cnt1--,cnt2++;
        else if(x==2)cnt2--,cnt3++;
        else if(x==3)cnt3--,cnt4++;
        else if(x==4)cnt4--;
        cnt[a[r]]++;
        if(k>=1&&!cnt1)continue;
        if(k>=2&&!cnt2)continue;
        if(k>=3&&!cnt3)continue;
        if(k>=4&&!cnt4)continue;
        ans++;
    }
}
```

## 子任务二

我们可以凭借敏锐的直觉感受到合法区间的长度应该是 $\frac {k\times (k+1)}{2}$，为什么呢？我们知道一共只有 $k$ 种数，而满足条件的话，区间中每一种数出现的次数显然不能相同，且分别是 $1$ 到 $k$ 次，然后相加即可。

那这部分可以使用一个双指针来解决。

```c++
//这部分的代码着实有点抽象了，有种复沓的美
len=k*(1+k)/2;
for(int i=1,x;i<=len;i++){
    x=cnt[a[i]];
    if(x==0)cnt1++;
    else if(x==1)cnt1--,cnt2++;
    else if(x==2)cnt2--,cnt3++;
    else if(x==3)cnt3--,cnt4++;
    else if(x==4)cnt4--;
    cnt[a[i]]++;
}
if(k==1&&cnt1)ans++;
else if(k==2&&cnt1&&cnt2)ans++;
else if(k==3&&cnt1&&cnt2&&cnt3)ans++;
else if(k==4&&cnt1&&cnt2&&cnt3&&cnt4)ans++;
for(int r=len+1,x;r<=n;r++){
    x=cnt[a[r-len]];
    if(x==1)cnt1--;
    else if(x==2)cnt2--,cnt1++;
    else if(x==3)cnt3--,cnt2++;
    else if(x==4)cnt4--,cnt3++;
    else if(x==5)cnt4++;
    cnt[a[r-len]]--;
    x=cnt[a[r]];
    if(x==0)cnt1++;
    else if(x==1)cnt1--,cnt2++;
    else if(x==2)cnt2--,cnt3++;
    else if(x==3)cnt3--,cnt4++;
    else if(x==4)cnt4--;
    cnt[a[r]]++;
    if(k==1&&cnt1)ans++;
    else if(k==2&&cnt1&&cnt2)ans++;
    else if(k==3&&cnt1&&cnt2&&cnt3)ans++;
    else if(k==4&&cnt1&&cnt2&&cnt3&&cnt4)ans++;
}
write(ans),Nxt;
```

## 子任务三

这是最核心的一个子任务，因为它直接提示了我们正解的做法。

我们考虑 $k=1$ 的特殊情况，记录 $f_i$ 表示 $i$ 到当前右端点的区间中，有多少个恰好出现一次的数字。

那这就变成了一个区间加的问题了，具体的，我们记 $pre_i$ 表示 $a_i$ 这个值上一次出现的位置，那么对于 $[pre_i+1,i]$ 的这一段区间，$a_i$ 这个数显然从原来没有贡献到现在有贡献，区间加一，对于 $[pre_{pre_i}+1,pre_i]$ 这一段区间，$a_i$ 从有贡献到没有贡献，区间减一，那以 $i$ 为右端点的合法区间就是 $[1,i]$ 中有多少个不为 $0$ 的位置。

这显然可以使用一个线段树进行优化。

```c++
/*线段树代码*/
struct Node{
    int mi,cnt;
    Node friend operator +(Node a,Node b){
        Node res;
        res.mi=min(a.mi,b.mi);
        res.cnt=0;
        if(res.mi==a.mi)res.cnt+=a.cnt;
        if(res.mi==b.mi)res.cnt+=b.cnt;
        return res;
    }
    Node operator +(const int &a)const{
        return {mi+a,cnt};
    }
};
struct Segment_tree{
    Node c[N<<2];
    int tag[N<<2];
    #define ls p<<1
    #define rs p<<1|1
    #define mid (l+r>>1)
    void pushup(int p){c[p]=c[ls]+c[rs];}
    void Tag(int p,int v){
        c[p]=c[p]+v;
        tag[p]+=v;
    }
    void pushdown(int p){
        if(!tag[p])return ;
        Tag(ls,tag[p]);
        Tag(rs,tag[p]);
        tag[p]=0;
    }
    void build(int p,int l,int r){
        if(l==r)return void(c[p]={0,1});
        build(ls,l,mid),build(rs,mid+1,r);
        pushup(p);
    }
    void change(int p,int l,int r,int L,int R,int v){
        if(L<=l&&r<=R)return Tag(p,v);
        pushdown(p);
        if(mid>=L)change(ls,l,mid,L,R,v);
        if(mid<R)change(rs,mid+1,r,L,R,v);
        pushup(p);
    }
    int query(){
        if(c[1].mi==0)return n-c[1].cnt;
        return n;
    }
}
```

```c++
/*主函数*/
for(int i=1;i<=n;i++){
    pre[i]=las[a[i]];
    las[a[i]]=i;
}
Set.build(1,1,n);
for(int i=1;i<=n;i++){
    Set.change(1,1,n,pre[i]+1,i,1);
    if(pre[i])Set.change(1,1,n,pre[pre[i]]+1,pre[i],-1);
    ans+=Set.query();
    //查询 1~n 中有多少个不为 0 的节点，和查询 1~i 中有多少个不为 0 的节点是等价的，因为 i+1~n 显然为 0
}
write(ans);
```

## 4.正解

我们回忆一下子任务三的求解过程，可以分为两步。第一步，区间修改；第二步，求有多少个不为 $0$ 的位置。

看着着实有点眼熟。

这不是求矩形面积并的过程吗？

我们将右端点视作矩形的宽，左端点视作矩形的长，就可以很明显的发现这个结论。

我们沿着这个思路想下去，会发现这样一件事：最后的答案其实就是求区间中拥有恰好出现一次，两次，三次，四次的合法区间各自的矩形面积并求交的答案。

但是求交着实不太好求，所以我们做一点容斥，把交搞成多个并相减的形式即可。

```c++
/*线段树的代码和上面是一样的，这里就不放了*/
for(int st=1,tp;st<(1<<k);st++){
    Set.build(1,1,n);
    tp=(cnt[st]&1)?1:-1;//容斥原理，奇加偶减，cnt[st] 表示 st 在二进制下有几个 1
    for(int i=1,now;i<=n;i++){
        now=i;
        for(int j=0;j<k;j++){
            if(st&(1<<j)){
                Set.change(1,1,n,pre[now]+1,now,1);
                if(pre[pre[now]]<pre[now])Set.change(1,1,n,pre[pre[now]]+1,pre[now],-1);
            }
            now=pre[now];
            if(!now)break;
        }
        ans+=tp*(Set.query());
    }
}
```

---

## 作者：Purslane (赞：4)

# Solution

太高妙了 /se

记 $S_k$ 为**存在出现恰好 $k$ 次的线段的集合**，则我们想知道 $|S_1 \cap \cdots \cap S_k|$。

考虑 $S$ 的并是容易计算的（直接矩形面积并），因此可以**容斥**。

复杂度 $O(2^k nk \log n)$。

```cpp
#include<bits/stdc++.h>
#define lson (k<<1)
#define rson (k<<1|1)
#define mid (l+r>>1)
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10;
int n,k,ans,a[MAXN];
vector<int> occ[MAXN];
namespace DS {
	struct INFO {int mn,cnt;}t[MAXN<<2];
	int tag[MAXN<<2];
	INFO operator +(INFO A,INFO B) {return {min(A.mn,B.mn),(A.mn<=B.mn)*A.cnt+(A.mn>=B.mn)*B.cnt};}
	INFO operator +(INFO A,int B) {return {A.mn+B,A.cnt};}
	void build(int k,int l,int r) {
		tag[k]=0,t[k]={0,r-l+1};
		if(l!=r) build(lson,l,mid),build(rson,mid+1,r);
		return ;
	}
	void push_down(int k,int l,int r) {return tag[lson]+=tag[k],tag[rson]+=tag[k],t[lson]=t[lson]+tag[k],t[rson]=t[rson]+tag[k],tag[k]=0,void();}
	void update(int k,int l,int r,int x,int y,int v) {
		if(x<=l&&r<=y) return tag[k]+=v,t[k]=t[k]+v,void();
		push_down(k,l,r);
		if(x<=mid) update(lson,l,mid,x,y,v);
		if(y>mid) update(rson,mid+1,r,x,y,v);
		return t[k]=t[lson]+t[rson],void();	
	}
};
vector<pair<pair<int,int>,int>> upd[MAXN];
int solve(int st) {
	ffor(i,1,n) upd[i].clear();
	ffor(s,1,k) if(st&(1<<s-1)) ffor(i,1,n) {
		ffor(j,s,occ[i].size()-2) {
			//(occ[i][j-s],occ[i][j-s+1]~[occ[i][j],occ[i][j+1])
			upd[occ[i][j]].push_back({{occ[i][j-s]+1,occ[i][j-s+1]},1});
			upd[occ[i][j+1]].push_back({{occ[i][j-s]+1,occ[i][j-s+1]},-1});
		}
	}
	int ans=0;
	DS::build(1,1,n);
	ffor(i,1,n) {
		for(auto pr:upd[i]) {
			int x=pr.first.first,y=pr.first.second,d=pr.second;
			DS::update(1,1,n,x,y,d);	
		}
		if(DS::t[1].mn==0) ans+=n-DS::t[1].cnt;
		else ans+=n;
	}
	return ans;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>k;
	ffor(i,1,n) occ[i].push_back(0);
	ffor(i,1,n) cin>>a[i],occ[a[i]].push_back(i);
	ffor(i,1,n) occ[i].push_back(n+1);
	ffor(i,1,(1<<k)-1) {
		int res=solve(i);
		if(__builtin_popcount(i)%2==1) ans+=res;
		else ans-=res;	
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：huhangqi (赞：3)

## 20pts ##

直接枚举左右端点，然后判断答案即可。

## 35pts ##

由于只有 $k$ 个数，那么每一个数都一定会对应一种 $i$ 的取值，也就意味着满足条件的情况一定是是每个数分别对应一种出现次数。

这样的话可以发现长度已经固定了，长度最长也只有 $10$，那么直接枚举即可。

## 70pts ##

此时我们可以枚举最右端的位置，处理出每一个点对应的上一个值，用线段树保存此时哪些地方作为左端点满足条件即可。

代码（有点长）：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, k, a[100005], cnt[5], t[100005], ans, pre[200005], l[200005];
struct P {
    int mi,cnt;//由于全部都是非负数，可以直接通过0的数量得到有哪些部分可行
    P friend operator+(P a, P b) {
        P c;
        c.mi = min(a.mi, b.mi);
        c.cnt = 0;
        if (c.mi == a.mi)
            c.cnt += a.cnt;
        if (c.mi == b.mi)
            c.cnt += b.cnt;
        return c;
    }
    P friend operator+(P a, int b) { return { a.mi + b, a.cnt }; }
};
struct ST {
    P c[800005];
    int tag[800005];
#define ls p << 1
#define rs p << 1 | 1
    void pushup(int p) { c[p] = c[ls] + c[rs]; }
    void Tag(int p, int v) {
        c[p] = c[p] + v;
        tag[p] += v;
    }
    void pushdown(int p) {
        if (!tag[p])
            return;
        Tag(ls, tag[p]);
        Tag(rs, tag[p]);
        tag[p] = 0;
    }
    void build(int p, int l, int r) {
        if (l == r)
            return void(c[p] = { 0, 1 });
        int mid = l + r >> 1;
        build(ls, l, mid), build(rs, mid + 1, r);
        pushup(p);
    }
    void change(int p, int l, int r, int L, int R, int v) {
        if (l >= L && r <= R) {
            Tag(p, v);
            return;
        }
        pushdown(p);
        int mid = l + r >> 1;
        if (mid >= L)
            change(ls, l, mid, L, R, v);
        if (mid < R)
            change(rs, mid + 1, r, L, R, v);
        pushup(p);
    }
    int query() {
        if (c[1].mi == 0)
            return n - c[1].cnt;
        return n;
    }
} tr;
void solve2() {
    int len = k * (k + 1) / 2, ans = 0;
    for (int i = 1; i <= n - len + 1; i++) {
        for (int i = 1; i <= k; i++) t[i] = 0;
        for (int i = 1; i <= k; i++) cnt[i] = 0;
        for (int j = i; j <= i + len - 1; j++) {
            t[a[j]]++;
        }
        for (int i = 1; i <= k; i++)
            if (t[i] <= k && t[i] >= 1)
                cnt[t[i]] = 1;
        bool f = 1;
        for (int i = 1; i <= k; i++)
            if (!cnt[i])
                f = 0;
        if (f)
            ans++;
    }
    cout << ans;
}
void solve3() {
    for (int i = 1; i <= n; i++) {
        pre[i] = l[a[i]];
        l[a[i]] = i;
    }
    tr.build(1, 1, n);
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        tr.change(1, 1, n, pre[i] + 1, i, 1);
        if (pre[i])
            tr.change(1, 1, n, pre[pre[i]] + 1, pre[i], -1);
        ans += tr.query();
    }
    cout << ans;
}
signed main() {
    cin >> n >> k;
    bool f = 1;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        if (a[i] > k)
            f = 0;
    }
    if (f) {
        solve2();
        return 0;
    }
    if (k == 1) {
        solve3();
        return 0;
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) t[j] = 0;
        for (int j = 1; j <= k; j++) cnt[j] = 0;
        for (int j = i; j <= n; j++) {
            if (t[a[j]] && t[a[j]] <= k) {
                cnt[t[a[j]]]--;
            }
            t[a[j]]++;
            if (t[a[j]] <= k) {
                cnt[t[a[j]]]++;
            }
            bool f = 1;
            for (int o = 1; o <= k; o++)
                if (!cnt[o])
                    f = 0;
            if (f)
                ans++;
        }
    }
    cout << ans;
    return 0;
}
``````

## 120pts ##

在 $k=1$ 的基础上进行思考。

此时我们已经有方法处理任意一个 $k$ 的值的范围了。

但是我们如果想要得到这些取值的交集，直接求解还是比较困难的。

所以我们可以考虑使用容斥来解决。

容斥需要求交集，那么我们可以枚举不同的交的情况。

根据小学奥数的知识，奇数加偶数减，我们先预处理出这种情况的数量的奇偶性，使用二进制枚举，即可得到满足 $k$ 个不同取值的答案了。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,a[100005],cnt[5],t[100005],ans,pre[100005],l[100005],siz[100005];
struct P{
	int mi,cnt;
	P friend operator+(P a,P b){
		P c;
		c.mi=min(a.mi,b.mi);
		c.cnt=0;
		if(c.mi==a.mi)c.cnt+=a.cnt;
		if(c.mi==b.mi)c.cnt+=b.cnt;
		return c;
	}
	P friend operator+(P a,int b){
		return {a.mi+b,a.cnt};
	}
};
struct ST{
	P c[400005];
	int tag[400005];
	#define ls p<<1
	#define rs p<<1|1
	void pushup(int p){
		c[p]=c[ls]+c[rs];
	}
	void Tag(int p,int v){
		c[p]=c[p]+v;
		tag[p]+=v;
	}
	void pushdown(int p){
		Tag(ls,tag[p]);
		Tag(rs,tag[p]);
		tag[p]=0;
	}
	void build(int p,int l,int r){
		tag[p]=0;
		if(l==r)return void(c[p]={0,1});
		int mid=l+r>>1;
		build(ls,l,mid),build(rs,mid+1,r);
		pushup(p);
	}
	void change(int p,int l,int r,int L,int R,int v){
		if(L>R)return;
		if(l>=L&&r<=R){
			Tag(p,v);
			return;
		}
		pushdown(p);
		int mid=l+r>>1;
		if(mid>=L)change(ls,l,mid,L,R,v);
		if(mid<R)change(rs,mid+1,r,L,R,v);
		pushup(p);
	}
}tr;
signed main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++){
		pre[i]=l[a[i]];
		l[a[i]]=i;
	}
	int ans=0;
	for(int i=1;i<(1<<k);i++){
		siz[i]=siz[i>>1]+(i&1);
	}
	for(int st=1;st<(1<<k);st++){
		tr.build(1,1,n);
		int s=0;
		for(int i=1;i<=n;i++){
			int tmp=i;
			for(int j=1;j<=k;j++){
				if(!tmp)break;
				if(st&(1<<j-1)){
                    tr.change(1,1,n,pre[tmp]+1,tmp,1);
                    if(pre[tmp])tr.change(1,1,n,pre[pre[tmp]]+1,pre[tmp],-1);
                }
                tmp=pre[tmp];
			}
			int tmp2=n-(tr.c[1].mi==0)*tr.c[1].cnt;
			if(siz[st]%2==0)ans-=tmp2;
			else ans+=tmp2;
		}
	}
	cout<<ans;
	return 0;
}

``````

---

## 作者：y0y68 (赞：3)

分享我的垃圾做法 /qd

要求的是每种颜色矩形的面积交，扫描线，考虑线段树每个节点维护 $2^k$ 的数组，表示这个区间所有出现颜色的状态的出现次数，但是这样在右边界不好撤销，所以套进线段树分治。

时间复杂度 $O(2^kn \log ^2 n)$，在区间修改的时候如果当前区间已经被这个颜色覆盖就直接返回，加上这个剪枝可以通过。

```
#include<bits/stdc++.h>
#include<ext/pb_ds/priority_queue.hpp>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
#define pii pair<int,int>
#define MP make_pair
template <class Miaowu>
inline void in(Miaowu &x){
	char c;x=0;bool f=0;
	for(c=getchar();c<'0'||c>'9';c=getchar())f|=c=='-';
	for(;c>='0'&&c<='9';c=getchar())x=(x<<1)+(x<<3)+(c^48);
	x=f?-x:x;
}
const int N=1e5+5;
ll ans;
int n,K,a[N],top;
vector<int>pos[N];
struct Node{bool op;int u,i,x;}stk[N<<8];
struct QWQ{int l,r,k;};
vector<QWQ>vc[N<<2];
inline int ls(int u){return u<<1;}
inline int rs(int u){return u<<1|1;}
struct SGT{
	int c[16][N<<2],tag[N<<2];
	inline void push(int u,int i,bool op){
		if(op)stk[++top]=Node{1,u,i,c[i][u]};
		else stk[++top]=Node{0,u,0,tag[u]};
	}
	inline void cov(int u,int k){
		for(int i=0;i<(1<<K);i++)if(((i&k)^k)&&c[i][u]){
			push(u,(i|k),1),push(u,i,1);
			c[i|k][u]+=c[i][u],c[i][u]=0;
		}
	}
	inline void build(int u,int l,int r){
		c[0][u]=r-l+1;
		if(l==r)return;
		int mid=l+r>>1;
		build(ls(u),l,mid),build(rs(u),mid+1,r);
	}
	inline void upd(int u,int l,int r,int L,int R,int k){
		if(tag[u]&(1<<k))return;
		if(l>=L&&r<=R)return push(u,0,0),tag[u]|=(1<<k),cov(u,(1<<k)),void();
		int mid=l+r>>1,qwq=tag[u];
		if(qwq){
			if((tag[ls(u)]&qwq)^qwq)push(ls(u),0,0),cov(ls(u),qwq),tag[ls(u)]|=qwq;
			if((tag[rs(u)]&qwq)^qwq)push(rs(u),0,0),cov(rs(u),qwq),tag[rs(u)]|=qwq;
			push(u,0,0),tag[u]=0;
		}
		if(mid>=L)upd(ls(u),l,mid,L,R,k);
		if(mid<R)upd(rs(u),mid+1,r,L,R,k);
		for(int k=0;k<(1<<K);k++)push(u,k,1),c[k][u]=c[k][ls(u)]+c[k][rs(u)];
	}
}sgt;
inline void ins(int u,int l,int r,int L,int R,int ql,int qr,int qk){
	if(l>=L&&r<=R)return vc[u].push_back(QWQ{ql,qr,qk}),void();
	int mid=l+r>>1;
	if(mid>=L)ins(ls(u),l,mid,L,R,ql,qr,qk);
	if(mid<R)ins(rs(u),mid+1,r,L,R,ql,qr,qk);
}
inline void solve(int u,int l,int r){
	int qwq=top;
	for(QWQ xx:vc[u])sgt.upd(1,1,n,xx.l,xx.r,xx.k);
	if(l==r)ans+=sgt.c[(1<<K)-1][1];
	else{
		int mid=l+r>>1;
		solve(ls(u),l,mid),solve(rs(u),mid+1,r);
	}
	while(top>qwq){
		Node xx=stk[top];
		if(xx.op)sgt.c[xx.i][xx.u]=xx.x;
		else sgt.tag[xx.u]=xx.x;
		top--;
	}
}
int main(){
	in(n),in(K);
	for(int i=1;i<=n;i++)in(a[i]),pos[a[i]].push_back(i);
	for(int i=1;i<=n;i++)pos[i].push_back(n+1);
	for(int i=1;i<=n;i++){
		int lst=1;
		for(int j=0;j<pos[i].size()-1;j++){
			for(int k=1;k<=K;k++)if(j+k<pos[i].size()){
				ins(1,1,n,lst,pos[i][j],pos[i][j+k-1],pos[i][j+k]-1,k-1);
			}
			lst=pos[i][j]+1;
		}
	}
	sgt.build(1,1,n),solve(1,1,n);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：hnczy (赞：2)

前两个部分分很简单这里不做赘述。

当 $k=1$ 时，可以类似的看做在每两个数之间都是一个区间，区间求并即可。

这里可以用线段树来维护。

具体代码如下：

```c++
seg.build(1, 1, n);
    for (int i = 1; i <= n; i++) {
        seg.change(1, 1, n, pre[i] + 1, i, 1);
        if (pre[i]) 
            seg.change(1, 1, n, pre[pre[i]] + 1, pre[i], -1);
        ans += seg.query(1, 1, n, 1, i).cnt;
    }
    cout << ans << endl;
```

这里的 $pre$ 指的是上一个与它相同的下标。

如果你会了 $k=1$ 的情况，那其实 $k \le4$ 的情况也迎刃而解了。

如果我们把前面的处理看做区间求并的话，那我们的这个全部的答案就是并的交。

“这并的交太难求啦！”

那我们不妨转换一下，可以使用容斥的原理把答案改成答案与每一个交组成线性关系即可。

即若是奇数个数交，则加，反之则减。

代码实现就很简单啦：

```c++
for(int st=1; st<(1<<k); st++) {
		seg.build(1,1,n);
		int f=(cnt[st]&1)?1:-1;
		for(int i=1; i<=n; i++) {
			for(int j=0,now=i;j<k; j++) {
				if(st&(1<<j)) {	
					seg.change(1,1,n,pre[now]+1,now,1);
					if(pre[now]) 
						seg.change(1,1,n,pre[pre[now]]+1,pre[now],-1);
				}
				now=pre[now];
				if(!now)break;
			}
			ans+=f*seg.c[1].cnt ;
		}
	}
```

当然，这里的需要把懒标记和值都重置一下才行。

这道题难度还是有的，线段树的一道好题，难度会比 noip 的后两题稍简单一些。

而且综合了容斥这一个知识点，想要单独写出正解还是有点难度的。

---

## 作者：内拉组里 (赞：2)

这道题部分分还是比较好打的，但是满分有点难想。

# Subtask 1

> 首先打一遍最暴力的暴力，
>
> $ \Theta (N^2) $ 枚举区间，再 $ \Theta (N) $ 地 check，
>
> 总共 $ \Theta (N^3) $，肯定会炸。
>
> 考虑到左端点一定枚举右端点时会重复统计某些区间，
>
> 于是将枚举右端点和 check 两层循环合并，边枚举边 check，
>
> 这样就差不多了。

## Analyses :

> 总时间复杂度 $ \Theta (N^2) $ 
>
> 总空间复杂度 $ \Theta (N) $ 

***

# Subtask 2

> 这里题目给出的条件是 $ 1 \le a_i \le k \le 4 $。
>
> 范围都非常小，并且不难发现目标区间都存在一条规律：长度都为 $ \sum\limits^k_{i = 1} i = \frac{k * (k + 1)}2 $。
>
> 原因是 $ a_i $ 的数量与 $ [1,k] $ 是单射关系。
>
> 所以在 $ [1,n] $ 里地截取长度 $ len = \frac{k * (k + 1)}2 $ 的线段，
>
> 再 $ \Theta (len) = \Theta (k^2) $ 地 check，
>
> 就过了。

## Analyses :

> 相应时间复杂度 $ \Theta (Nk^2) $ 
>
> 相应空间复杂度 $ \Theta (k) $ 

***

# Subtask 3

> $ k = 1 $，那么这题就变成了一道类矩阵面积并。
>
> 记 $ pre_i $ 为大小与 $ a_i $ 相同的，在 $ a_i $ 之前的最后一个位置，若不存在则为 $ 0 $。
>
> 考虑枚举右端，那么对于在此之前所有最后一次出现的数，在 $ (pre_i,i] $ 内放置左端点一定能构成目标区间。
>
> 于是考虑用线段树维护两个数组 $ mn $ 和 $ cnt $，分别记录区间最小值和最小值的个数。
>
> 那么区间内非零值的个数就是 `len[rt] - cnt[rt] * !mn[rt]`。
>
> 这样一来就简单了，每次将 $ (pre_i,i] $ 整体 $ + 1 $，
>
> 若存在更早的相同大小的数，那么再把 $ (pre_{pre_i},pre_i] $ 整体 $ - 1 $，即可实现去重。
>
> 每次以 $ i $ 为右端点的目标区间数就是所有非零值的个数。

## Analyses :

> 相应时间复杂度 $ \Theta (N \log{N}) $ 
>
> 相应空间复杂度 $ \Theta (N) $ 

***

# Subtask 4

> 正解的话似乎特性 $ B $ 有关，还要用到一点容斥原理的芝士。
>
> 首先从目标二元组的第二条性质出发，
>
> > $ \forall 1 \le i \le k, \exist x $ 使得 $ x $ 在 $ a_{[l,r]} $ 中出现**恰好** $ i $ 次。
>
> 这里特性 $ B $ 给出了 $ i = 1 $ 的解法，这是在提示应该把所有的 $ i $ 分开处理。
>
> 记 $ sec_i $ 表示 $ \exist x $ 使得 $ x $ 在区间中恰好出现 $ i $ 次的**区间**，
>
> 那么所求即 $ sec_1 \cap sec_2 \cap \cdots \cap sec_k $。
>
> 由于区间交并不好求，但我们有现成的求解区间并的线段树可用（在写 Subtask #3 时写的）。
>
> 所以就像求 $ lcm $ 一样简单地转换一下デス～
>
> 显然地，$ \lvert A \cap B \rvert = \lvert A \rvert + \lvert B \rvert - \lvert A \cup B \rvert $。
>
> 那么利用容斥原理得出，
> $$
> \lvert S_1 \cap S_2 \cap \cdots \cap S_k \rvert = \sum\limits^k_{i = 1} \lvert S_i \rvert - \sum\limits^k_{i = 1} \sum\limits^k_{j = 1} \lvert S_i \cap S_j \rvert (i \neq j) + \cdots \lvert S_1 \cup S_2 \cup \cdots \cup S_k \rvert
> $$
> 所以先二进制枚举对于 $ seg_{[1,k]} $ 的组合方案，
>
> - 若方案内有奇数个元素，则需减去答案。
> - 若方案内有偶数个元素，则应加上答案。
>
> 然后根据枚举的方案按照特性 $ B $ 的思路去写デス～

## Analyses :

> 总时间复杂度 $ \Theta (2^kk \times N \log{N}) $ 
>
> 总空间复杂度 $ \Theta (N) $ 

# Code :

> 放在[云剪贴板](https://www.luogu.com.cn/paste/ret9dnpc)里

---

## 作者：HomuraAkemi (赞：2)

还是数据结构低手。

分别考虑每种颜色，不妨设颜色 $x$ 出现了 $c$ 次，那么可以刻画出 $\Theta(ck)$ 个区间：区间集 $S_{x,i}$ 表示 $\forall [l,r]\in S_{x,i}$，都有 $\operatorname{cnt}_x(l,r)=i$。把所有 $S_{x,i}$ 并起来得到 $S_i$。

将区间拍到二维平面上，问题转化为求出 $S_1,\cdots,S_k$ 的交的面积。交的面积不好算，但是并的面积好算（扫描线），直接容斥即可。时间复杂度 $\Theta(nk2^k\log n)$。

小圆可爱，亲亲小圆/qq

---

## 作者：dAniel_lele (赞：1)

小清新题目。

首先考虑如下问题：

> 给定序列 $a$，求有多少子区间使得不存在出现次数在 $S$ 集合内的数字。

扫描线处理右端点在 $r$ 的情况。考虑添加一个 $a_i$ 对每个 $l$ 的合法性影响。首先原本前面第 $x+1$ 到 $x$ 个 $a_i$（$x\in S$）的 $l$ 对于 $a_i$ 变得合法，然后第 $x$ 到 $x-1$ 变得不合法。可以用线段树区间修改区间，不合法区间 $+1$，求区间最小值与对应数量，如果最小值为 $0$ 则把对应数量加入答案即可。总复杂度 $O(n|S|\log n+n\max_{x\in S}x)$。

现在要求每个数字都存在了，考虑容斥即可。总复杂度 $O(2^knk\log n)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define mid ((l+r)>>1)
using namespace std;
int a[100005],vis[100005],lst[100005];
struct node{
	int cnt,maxv;
};
node merge(node x,node y){
	node z; z.cnt=0;
	z.maxv=max(x.maxv,y.maxv);
	z.cnt+=x.cnt*(x.maxv==z.maxv);
	z.cnt+=y.cnt*(y.maxv==z.maxv);
	return z;
}
struct sgt{
	node f[400005];
	int lzt[400005];
	void pushdown(int i){
		f[i*2].maxv+=lzt[i];
		lzt[i*2]+=lzt[i];
		f[i*2+1].maxv+=lzt[i];
		lzt[i*2+1]+=lzt[i];
		lzt[i]=0;
	}
	void build(int i,int l,int r){
		lzt[i]=0;
		if(l==r){
			f[i].cnt=1,f[i].maxv=0;
			return ;
		}
		build(i*2,l,mid),build(i*2+1,mid+1,r);
		f[i]=merge(f[i*2],f[i*2+1]);
	}
	void change(int i,int l,int r,int ql,int qr,int cg){
//		if(i==1) cout<<ql<<" "<<qr<<" "<<cg<<"\n";
		if(ql>qr) return ;
		if(ql<=l&&r<=qr){
			lzt[i]+=cg;
			f[i].maxv+=cg;
			return ;
		}
		pushdown(i);
		if(ql<=mid) change(i*2,l,mid,ql,qr,cg);
		if(qr>mid) change(i*2+1,mid+1,r,ql,qr,cg);
		f[i]=merge(f[i*2],f[i*2+1]);
	}
	node qry(int i,int l,int r,int ql,int qr){
		if(ql<=l&&r<=qr) return f[i];
		pushdown(i);
		if(qr<=mid) return qry(i*2,l,mid,ql,qr);
		if(ql>mid) return qry(i*2+1,mid+1,r,ql,qr);
		return merge(qry(i*2,l,mid,ql,qr),qry(i*2+1,mid+1,r,ql,qr));
	}
	void debug(int i,int l,int r){
		cout<<i<<" "<<l<<" "<<r<<" "<<f[i].maxv<<" "<<f[i].cnt<<" "<<lzt[i]<<"\n";
		if(l==r) return ;
		debug(i*2,l,mid),debug(i*2+1,mid+1,r);
	}
}tree;
signed main(){
	int n,k; cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		lst[i]=vis[a[i]];
		vis[a[i]]=i;
	}
	int ans=0;
	for(int j=0;j<(1<<k);j++){
		tree.build(1,1,n);
		int tot=0;
		for(int i=1;i<=n;i++){
			int tmp=lst[i];
			for(int p=1;p<=k;p++){
				if((j>>(p-1))&1) tree.change(1,1,n,lst[tmp]+1,tmp,1);
				tmp=lst[tmp];
			}
			tmp=i;
			for(int p=1;p<=k;p++){
				if((j>>(p-1))&1) tree.change(1,1,n,lst[tmp]+1,tmp,-1);//cout<<lst[tmp]+1<<" "<<tmp<<" -1\n";
				tmp=lst[tmp];
			}
			auto add=tree.qry(1,1,n,1,i);
			tot+=(add.maxv==0)*add.cnt;
		}
		if(__builtin_popcount(j)&1) ans-=tot;
		else ans+=tot;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Add_Catalyst (赞：0)

# P11390 [COCI 2024/2025 #1] 教师 / Učiteljica 题解

------

## 知识点

线段树，扫描线，容斥，状压，线段树分治。

### 分析

首先可以很容易的看出这题和扫描线有关，把 $[l,r]$ 转换成图形上的点即可。我们直接看到子任务 3，满足特殊性质 B：$k = 1$。

那么这个就是把每个数字单独拎出来，然后把合法的矩形并在一起，最后求矩形面积并，扫描线解决很简单。

### 法 1：容斥

*这个解法的题解是网上最多的，对于擅长组合数学的同学们很友好。*

我们从刚刚的部分分进一步推理：发现 $k>1$ 时，就是把 $k$ 不同时的矩形并再取交集，然后再算面积。那么这个“并”“交”让人想到了容斥，所以容斥把「取交集」变成多次的「求并集」解决即可。

*由于其他题解讨论的都较为详细，这里不再赘述。*

时间复杂度 $O(k2^kn\log_2{n})$，空间复杂度 $O(nk)$。

### 法 2：线段树分治+状压

*对于不擅长组合数学的同学们，这个做法可能会友好一点。*

我们考虑不用容斥直接「取交集」。仍然是从部分分衍生出来，发现标记下传的线段树在矩形减操作时不太方便，于是可以想到线段树分治，避免矩形减操作。

再考虑状压来存储线段树上每个节点和其子节点已经满足的 $k$，那么很容易就可以解出来：线段树上每个节点存覆盖到自己的区间矩形加的状态，开 $2^k$ 大小的数组来存子树代表的区间中每种状态的数量。

时间复杂度 $O(k2^kn\log^2_2{n})$，空间复杂度 $O(n2^k)$。*可能需要卡常。*

### 法 3：永久化标记+状压

起始思路与法 2 类似。考虑部分分的线段树实现方法，我们可以标记下传，也可以标记永久化，而标记永久化明显十分简洁，所以我们考虑在正解也用标记永久化。那么就直接正常的扫描线扫过去即可。

时间复杂度 $O(k2^kn\log_2{n})$，空间复杂度 $O(n2^k)$。

*大概是因为矩形只用加一次，导致这个做法是常数最小的，翻 Luogu 的提交记录，排名在前面的我有看到的都是这么写的。*

## 代码

这里实现了永久化标记线段树配状压的做法。

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define ll long long
#define RCL(a,b,c,d) memset(a,b,sizeof(c)*(d))
#define FOR(i,a,b) for(int i(a);i<=(int)(b);++i)
#define DOR(i,a,b) for(int i(a);i>=(int)(b);--i)
#define tomax(a,...) ((a)=max({(a),__VA_ARGS__}))
#define tomin(a,...) ((a)=min({(a),__VA_ARGS__}))
#define EDGE(g,i,x,y) for(int i=(g).h[(x)],y=(g)[(i)].v;~i;y=(g)[(i=(g)[i].nxt)>0?i:0].v)
#define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);return Main();}signed Main
using namespace std;
constexpr int N(1e5+10),K(4),St(1<<4);

int n,m,U,tot;
int a[N];
ll ans;
vector<int> vec[N];
struct Line {
	int x,l,r,v,k;

	friend bool operator <(Line a,Line b) { return a.x<b.x; }
} lin[N<<3];
struct SEG {
	struct node {
		int sta;
		int cnt[K],sum[St];
		node(int sta=0):sta(sta) { RCL(cnt,0,int,m),RCL(sum,0,int,U+1); }

		void down(int k,int d) {
			if(cnt[k])sta^=1<<k;
			cnt[k]+=d;
			if(cnt[k])sta^=1<<k;
		}
	} tr[N<<2];
#define ls (p<<1)
#define rs (p<<1|1)
#define mid ((l+r)>>1)
	void Up(int p) {
		RCL(tr[p].sum,0,int,U+1);
		FOR(S,0,U)tr[p].sum[tr[p].sta|S]+=tr[ls].sum[S]+tr[rs].sum[S];
	}

	void Build(int p=1,int l=1,int r=n) {
		tr[p]=node(0);
		if(l==r)return tr[p].sum[0]=1,void();
		Build(ls,l,mid),Build(rs,mid+1,r),Up(p);
	}

	void Plus(int L,int R,int k,int d,int p=1,int l=1,int r=n) {
		if(L<=l&&r<=R) {
			if(l==r)tr[p].sum[tr[p].sta]=0;
			tr[p].down(k,d),(l<r?Up(p),0:tr[p].sum[tr[p].sta]=1);
			return;
		}
		if(L<=mid)Plus(L,R,k,d,ls,l,mid);
		if(mid<R)Plus(L,R,k,d,rs,mid+1,r);
		Up(p);
	}
#undef ls
#undef rs
#undef mid
} seg;

void Plus(const int k,int xa,int xb,int ya,int yb) {
	lin[++tot]= {xa,ya,yb,1,k},lin[++tot]= {xb+1,ya,yb,-1,k};
}

void Solve(vector<int> &vec,const int k) {
	FOR(i,0,(int)vec.size()-k)
		Plus(k-1,!i?1:vec[i-1]+1,vec[i],vec[i+k-1],i+k>=(int)vec.size()?n:vec[i+k]-1);
}

signed main() {
#ifdef Plus_Cat
	freopen(Plus_Cat ".in","r",stdin),freopen(Plus_Cat ".out","w",stdout);
#endif
	cin>>n>>m;
	FOR(i,1,n)cin>>a[i],vec[a[i]].push_back(i);
	U=(1<<m)-1;
	FOR(i,1,n)if(!vec[i].empty())FOR(k,1,m)Solve(vec[i],k);
	sort(lin+1,lin+tot+1),seg.Build();
	int it(1);
	FOR(i,1,n) {
		while(it<=tot&&lin[it].x<=i)seg.Plus(lin[it].l,lin[it].r,lin[it].k,lin[it].v),++it;
		ans+=seg.tr[1].sum[U];
	}
	cout<<ans<<endl;
	return 0;
}
```

------

---

## 作者：songhongyi (赞：0)

考虑一个位置 $i$，以及在其左边第 $a$ 个值相同的位置 $L$ 以及第 $a-1$ 个 $L'$ 和右边第 $b$ 个 $R$ 以及第 $b-1$ 个 $R'$，如果一个区间 $[l,r]$ 满足 $l \in (L,L']$，$r \in [R',R)$，那么 $[l,r]$ 就存在一个出现了 $a+b-1$ 次的数。我们枚举 $a,b,i$，可以得到 $O(kn)$ 个这样的矩形。

因为一个区间合法，一定需要在某一个这样的矩形内，所以对于某个 $k$，求答案只需要把这个 $k$ 对应的所有矩形求一个并的面积即可。但要求 $1$ 到 $k$ 包含，需要做的就是在扫描线的过程中，求出有多少个位置被所有颜色覆盖之类的问题。但我们大可不必，考虑到 $k\le 4$，我们考虑容斥。对于一个 $S$，将所有 $k_0 \in S$ 的矩形都加入，这样我们求得的是有多少个区间，覆盖的颜色是 $S$ 的子集。这就是一个最简单的容斥了。最后进行 $2^k$ 次矩形并即可。总复杂度为 $O(2^k nk \log n)$。

```cpp
//
// Problem: P11390 [COCI 2024/2025 #1] 教师 / Učiteljica
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P11390
// Memory Limit: 500 MB
// Time Limit: 5000 ms

#include <iostream>
#include <vector>
#define lson x * 2
#define rson x * 2 + 1
using namespace std;
const int MAXN = 1e5 + 10;
struct Tree
{
    struct Node
    {
        int mi, cnt;
        int lzy;
    } tr[ 4 * MAXN ];
    void add( int x, int v )
    {
        tr[ x ].mi += v;
        tr[ x ].lzy += v;
    }
    void pushup( int x )
    {
        if ( tr[ lson ].mi < tr[ rson ].mi )
        {
            tr[ x ].mi = tr[ lson ].mi;
            tr[ x ].cnt = tr[ lson ].cnt;
        }
        else if ( tr[ lson ].mi > tr[ rson ].mi )
        {
            tr[ x ].mi = tr[ rson ].mi;
            tr[ x ].cnt = tr[ rson ].cnt;
        }
        else
        {
            tr[ x ].mi = tr[ lson ].mi;
            tr[ x ].cnt = tr[ lson ].cnt + tr[ rson ].cnt;
        }
    }
    void pushdown( int x )
    {
        if ( tr[ x ].lzy )
        {
            add( lson, tr[ x ].lzy );
            add( rson, tr[ x ].lzy );
            tr[ x ].lzy = 0;
        }
    }
    void build( int x, int l, int r )
    {
        tr[ x ].cnt = r - l + 1;
        tr[ x ].mi = tr[ x ].lzy = 0;
        if ( l == r )
        {
            return;
        }
        int mid = ( l + r ) / 2;
        build( lson, l, mid );
        build( rson, mid + 1, r );
    }
    void update( int x, int l, int r, int L, int R, int v )
    {
        if ( L <= l and r <= R )
        {
            add( x, v );
            return;
        }
        pushdown( x );
        int mid = ( l + r ) / 2;
        if ( L <= mid )
        {
            update( lson, l, mid, L, R, v );
        }
        if ( R > mid )
        {
            update( rson, mid + 1, r, L, R, v );
        }
        pushup( x );
    }
    int query( int l, int r )
    {
        int L = r - l + 1;
        if ( tr[ 1 ].mi != 0 )
        {
            return L;
        }
        else
        {
            return L - tr[ 1 ].cnt;
        }
    }
} T;
int a[ MAXN ];
vector< int > gz[ MAXN ];
vector< pair< int, int > > gza[ MAXN ][ 5 ], gzm[ MAXN ][ 5 ];
int nxt[ MAXN ][ 5 ], lst[ MAXN ][ 5 ];
void add( int k, int l, int r, int L, int R )
{
    if ( l > r or L > R )
    {
        return;
    }
    gza[ l ][ k ].emplace_back( L, R );
    gzm[ r + 1 ][ k ].emplace_back( L, R );
}
int main()
{
    cin.tie( 0 );
    int n, K;
    cin >> n >> K;
    for ( int i = 1; i <= n; i++ )
    {
        cin >> a[ i ];
    }
    for ( int i = n; i >= 1; i-- )
    {
        nxt[ i ][ 0 ] = i;
        for ( int j = 1; j <= 4; j++ )
        {
            if ( gz[ a[ i ] ].size() >= j )
            {
                nxt[ i ][ j ] = gz[ a[ i ] ][ gz[ a[ i ] ].size() - j ];
            }
            else
            {
                nxt[ i ][ j ] = n + 1;
            }
        }
        gz[ a[ i ] ].emplace_back( i );
    }
    for ( int i = 1; i <= n; i++ )
    {
        gz[ i ].clear();
    }
    for ( int i = 1; i <= n; i++ )
    {
        lst[ i ][ 0 ] = i;
        for ( int j = 1; j <= 4; j++ )
        {
            if ( gz[ a[ i ] ].size() >= j )
            {
                lst[ i ][ j ] = gz[ a[ i ] ][ gz[ a[ i ] ].size() - j ];
            }
            else
            {
                lst[ i ][ j ] = 0;
            }
        }
        gz[ a[ i ] ].emplace_back( i );
    }
    for ( int i = 1; i <= n; i++ )
    {
        for ( int j = 0; j <= K; j++ )
        {
            for ( int k = 0; k <= K; k++ )
            {
                if ( j + k + 1 <= K )
                {
                    add( j + k + 1, lst[ i ][ j + 1 ] + 1, lst[ i ][ j ], nxt[ i ][ k ],
                         nxt[ i ][ k + 1 ] - 1 );
                }
            }
        }
    }
    long long int ans = 0;
    for ( int S = 1; S < ( 1 << K ); S++ )
    {
        T.build( 1, 0, n + 1 );
        long long int res = 0;
        for ( int i = 0; i <= n + 1; i++ )
        {
            for ( int j = 1; j <= K; j++ )
            {
                if ( S & ( 1 << ( j - 1 ) ) )
                {
                    for ( auto t : gza[ i ][ j ] )
                    {
                        T.update( 1, 0, n + 1, t.first, t.second, 1 );
                    }
                    for ( auto t : gzm[ i ][ j ] )
                    {
                        T.update( 1, 0, n + 1, t.first, t.second, -1 );
                    }
                }
            }
            res += T.query( 0, n + 1 );
        }
        // cerr << S << " " << res << endl;
        if ( __builtin_popcount( S ) & 1 )
        {
            ans += res;
        }
        else
        {
            ans -= res;
        }
    }
    cout << ans << endl;
}
```

---


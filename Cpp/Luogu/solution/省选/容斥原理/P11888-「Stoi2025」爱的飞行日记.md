# 「Stoi2025」爱的飞行日记

## 题目背景

![](bilibili:BV1fx411N7bU?page=125)

## 题目描述

$t$ 组询问，每次询问给定正整数 $n,m$，计算

$$\prod_{a_1=1}^{m}\prod_{a_2=1}^{m}\cdots\prod_{a_n=1}^{m}\operatorname{lcm}(f_{a_1},f_{a_2},\dots,f_{a_n})\bmod{37426667}$$

的值。其中 $f_i$ 是斐波那契数，满足 $f_1=f_2=1$，且 $f_i=f_{i-1}+f_{i-2},\forall i\ge3$。

## 说明/提示

#### 样例解释

对于第一组询问，有答案为 $f_1f_2f_3=1\times1\times2=2$。

对于第二组询问，当 $a_1,a_2\in\{1,2\}$ 时 $\operatorname{lcm}(f_{a_1},f_{a_2})=1$，否则 $\operatorname{lcm}(f_{a_1},f_{a_2})=2$。故答案为 $2^5=32$。

#### 数据范围与限制

**本题采用捆绑测试，各 Subtask 的限制与分值如下。**

| Subtask No. | $t\le$ | $n\le$ | $m\le$ | 分值 |
| :-: | :-: | :-: | :-: | :-: |
| $1$ | $1$ | $2$ | $2 \times 10^3$ | $13$ |
| $2$ | $5$ | $2 \times 10^5$ | $2 \times 10^5$ | $24$ |
| $3$ | $5$ | $2 \times 10^7$ | $2 \times 10^7$ | $36$ |
| $4$ | $300$ | $2 \times 10^{17}$ | $2 \times 10^7$ | $27$ |

对于所有数据，满足 $1 \le t \le 300, 1 \le n \le 2 \times 10^{17}, 1 \le m \le 2 \times 10^7$。

## 样例 #1

### 输入

```
2
1 3
2 3
```

### 输出

```
2
32
```

# 题解

## 作者：VinstaG173 (赞：9)

简单推式子题，预估难度弱省省选。

本文中时间复杂度 $O(f^0)-O(f^1)$ 表示预处理复杂度 $O(f^0)$，单次询问复杂度 $O(f^1)$。

首先由 Min-max 容斥有

$$\operatorname{lcm}(x_1,x_2,\dots,x_n)=\prod_{S\subseteq\{1,2,\dots,n\},S \neq \varnothing}\gcd\{x_i : i \in S\}^{(-1)^{\lvert S \rvert-1}}.$$

事实上这个式子由 $\gcd(a,b)\operatorname{lcm}(a,b)$ 随便算两下就出来了，不用熟知 Min-max 容斥。

由 Fibonacci 数的性质 $\gcd(f_a,f_b)=f_{\gcd(a,b)}$，因此

$$\begin{aligned}
\prod_{a_1=1}^{m}\prod_{a_2=1}^{m}\cdots\prod_{a_n=1}^{m}\operatorname{lcm}(f_{a_1},f_{a_2},\dots,f_{a_n})&=\prod_{a_1=1}^{m}\prod_{a_2=1}^{m}\cdots\prod_{a_n=1}^{m}\prod_{S\subseteq\{1,2,\dots,n\},S \neq \varnothing}f_{\gcd\{a_i : i \in S\}}^{(-1)^{\lvert S \rvert-1}}\\
&=\prod_{d=1}^{m}f_d^{\sum\limits_{a_1=1}^{m}\sum\limits_{a_2=1}^{m}\cdots\sum\limits_{a_n=1}^{m}\sum\limits_{S\subseteq\{1,2,\dots,n\},S \neq \varnothing}(-1)^{\lvert S \rvert-1}[\gcd\{a_i : i \in S\}=d]}\\
&=\prod_{d=1}^{m}f_d^{\sum\limits_{k=1}^{n}(-1)^{k-1}\binom{n}{k}m^{n-k}\sum\limits_{a_1=1}^{m}\sum\limits_{a_2=1}^{m}\cdots\sum\limits_{a_k=1}^{m}[\gcd(a_1,a_2,\dots,a_k)=d]}\\
&=\prod_{d=1}^{m}f_d^{\sum\limits_{k=1}^{n}(-1)^{k-1}\binom{n}{k}m^{n-k}\sum\limits_{a_1=1}^{\left\lfloor\frac{m}{d}\right\rfloor}\sum\limits_{a_2=1}^{\left\lfloor\frac{m}{d}\right\rfloor}\cdots\sum\limits_{a_k=1}^{\left\lfloor\frac{m}{d}\right\rfloor}[\gcd(a_1,a_2,\dots,a_k)=1]}\\
&=\prod_{d=1}^{m}f_d^{\sum\limits_{k=1}^{n}(-1)^{k-1}\binom{n}{k}m^{n-k}\sum\limits_{a_1=1}^{\left\lfloor\frac{m}{d}\right\rfloor}\sum\limits_{a_2=1}^{\left\lfloor\frac{m}{d}\right\rfloor}\cdots\sum\limits_{a_k=1}^{\left\lfloor\frac{m}{d}\right\rfloor}\sum\limits_{t \mid \gcd(a_1,a_2,\dots,a_k)}\mu(t)}\\
&=\prod_{d=1}^{m}f_d^{\sum\limits_{k=1}^{n}(-1)^{k-1}\binom{n}{k}m^{n-k}\sum\limits_{t=1}^{\left\lfloor\frac{m}{d}\right\rfloor}\mu(t)\left\lfloor\frac{m}{dt}\right\rfloor^{k}}\\
&=\prod_{d=1}^{m}\prod_{t=1}^{\left\lfloor\frac{m}{d}\right\rfloor}f_d^{\mu(t)\sum\limits_{k=1}^{n}(-1)^{k-1}\binom{n}{k}m^{n-k}\left\lfloor\frac{m}{dt}\right\rfloor^{k}}\\
&=\prod_{D=1}^{m}\left(\prod_{d \mid D}f_d^{\mu\left(\frac{D}{d}\right)}\right)^{m^n-\left(m-\left\lfloor\frac{m}{D}\right\rfloor\right)^n}\\
&=\prod_{D=1}^{m}F(D)^{G\left(\left\lfloor\frac{m}{D}\right\rfloor\right)},
\end{aligned}$$

其中

$$F(D)=\prod_{d \mid D}f_d^{\mu\left(\frac{D}{d}\right)},G(k)=m^n-\left(m-k\right)^n.$$

直接朴素预处理 $F$，暴力计算可以做到时间复杂度 $O(m\log m)-O(m\log n)$。

为了优化，可以用整除分块处理上式。我们可以在 $O(\log{n})$ 的时间复杂度下计算 $G(\cdot)$，现在我们考虑较快速计算 $F(D)$。

由于

$$\prod_{i=1}^{D}F(i)=\prod_{d=1}^{D}f_d^{\sum\limits_{i=1}^{\left\lfloor\frac{D}{d}\right\rfloor}\mu(i)},$$

我们可以线性预处理 Fibonacci 数列前缀积和 $\mu(\cdot)$ 前缀和后用整除分块在 $O(\sqrt{D}\log{D})$ 的时间复杂度下计算上式。时间复杂度 $O(m)-O(m^{\frac{3}{4}}\log{n})$。

注意到模数不大，线性预处理出逆元，利用类似 Dirichlet 前缀和的方法计算卷积预处理出 $F(\cdot)$，同时用 Euler 定理优化计算 $k^n$，即可做到 $O(mod+m\log{\log{m}})-O(\sqrt{m}\log{mod})$，空间复杂度 $O(mod+m)$。

---

以上做法已经足够通过本题，但其实不考虑多组询问我们还可以做到更优。以下做法由验题人 wkywkywky 提出。

注意刚才的式子

$$\prod_{i=1}^{D}F(i)=\prod_{d=1}^{D}f_d^{\sum\limits_{i=1}^{\left\lfloor\frac{D}{d}\right\rfloor}\mu(i)},$$

我们只需要求出 $F,f$ 与 $\mu$ 的块筛。其中 $\mu$ 函数前缀和可以用杜教筛做到 $O(v)-O(\frac{m}{\sqrt{v}})$，$f$ 数列前缀积可以用[这道题](https://www.luogu.com.cn/problem/AT_abc381_g)的方法，$O(V+W\log W)$ 预处理，且对于 $m/i>V$，做到 $O(m/W)$ 单次查询。

在处理出 $f$ 和 $\mu$ 的基础上，预处理 $F$ 的前缀积到 $O(w)$，可以做到 $O(w\log\log w\log mod)-O(\frac m{\sqrt w}\log mod)$。平衡复杂度取 $v,V,w=O((m\operatorname{polylog})^{2/3})$，总复杂度约为 $O((m\operatorname{polylog})^{2/3})$，可能常数较大，瓶颈主要在 $F$ 的计算过程中的 $\log mod$，$\mu,f,F$ 三部分的 $\log$ 次数大约分别为 $0,\frac13,1^+$。

---

## 作者：Polarisx (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P11888)。

这是一道融合了 gcd-lcm 容斥，莫比乌斯反演，逆元，数论分块，Dirichlet 卷积，原根，快速幂，欧拉函数，中国剩余定理的好题。

## 思路

不难想到 gcd-lcm 容斥（即 min-max 容斥），有 $ \mathrm{lcm}(S)=\prod_{T\subseteq S}\gcd(T)^{(-1)^{|T|-1}}$，代入原式得到：

$$
\begin{aligned}
\prod_{(a_1,\cdots,a_n)} \mathrm{lcm}(f_{a_1},\cdots,f_{a_n})&=\prod_{S=(a_1,\cdots,a_n)} \prod_{T\subseteq S}\left(\gcd_{i\in T}f_{i}\ \right)^{(-1)^{|T|-1}}\\
&=\prod_{(a_1,\cdots,a_n)} \prod_{T\subseteq S}f\left(\gcd_{i\in T}i\ \right)^{(-1)^{|T|-1}}

\end{aligned}
$$

第二步是因为 $\gcd(f_a,f_b)=f_{\gcd(a,b)}$，然后就是 [P5106](https://www.luogu.com.cn/problem/P5106) 的做法了，这里略过。

最终得到答案就是

$$
\prod_{i=1}^m \left( \prod_{d\mid i}f_d^{\mu(i/d)} \right)^{g(m/i)}
$$

其中 $g(i)=m^n-(m-i)^n$。

连乘很麻烦，不妨取对数：

$$
\sum_{i=1}^m g(m/i)\sum_{d\mid i}\mu(i/d)\ln f_d
$$

后面求和式是 $\mu$ 与 $\ln f$ 的卷积，可以用高维差分在 $\mathcal O(m\ln \ln m)$ 的时间复杂度下求出，前面的和式数论分块即可。答案再取 exp 即可，37426667 的原根是 2。

现在时间复杂度唯一的瓶颈在于无法快速计算 $g(k) \bmod (p-1)$，考虑分解质因数，得到 $37426666=2\times  18713333$，其中 $18713333$ 的原根为 $3$，这样我们能很快求出 $g(k)\bmod 18713333$ 和 $g(k)\bmod 2$，接下来就可以 $\mathcal O(1)$ CRT 合并了。

时间复杂度 $\mathcal O(T\sqrt m + m\ln\ln m+p)$，空间复杂度 $\mathcal O(p+m)$，$p$ 是模数。算是爆标了，不过跑的很慢。

我必须通过此题才能交题解，所以我写了代码。


```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int Mod=37426667,g=2,Maxn=2e7+7,Modm=Mod-1,G=3,modp=18713333,phi=modp-1,inv2=phi/2+1;

int dlog[Mod],pwg[Mod];
bitset<Maxn>isp;
int mu[Maxn];
int h[Maxn];

inline int ksm(int a,int b,int mod){
    int z=1;
    while(b){if(b&1) z=1ll*z*a%mod;a=1ll*a*a%mod;b>>=1;}
    return z;
}

inline void init(int N,int M){
    pwg[0]=1; mu[1]=1;
    for(int i=1;i<N-1;i++) pwg[i]=pwg[i-1]*g%Mod;
    for(int i=0;i<N-1;i++) dlog[pwg[i]]=i;

    h[1]=h[2]=1; 
    for(int i=3;i<=M;i++) h[i]=(h[i-1]+h[i-2])%Mod;
    for(int i=1;i<=M;i++) h[i]=dlog[h[i]];
 
    for(int i=2;i<=M;i++)
        if(!isp.test(i)){
            for(int j=M/i;j;j--) h[i*j]=(h[i*j]-h[j])%Modm,
                                 isp.set(i*j);
        }
        
    for(int i=1;i<=M;i++) h[i]=(h[i]+h[i-1]+Modm)%Modm;
    pwg[0]=1; 
    for(int i=1;i<phi;i++) pwg[i]=pwg[i-1]*G%modp;
    for(int i=0;i<phi;i++) dlog[pwg[i]]=i;
}

int T,m; ll n;

int main(){
	init(Mod,Maxn-5);
    scanf("%d",&T);

    while(T--){
        scanf("%lld%d",&n,&m); n%=phi;

        int ans=0,mn=ksm(m,n,Modm);
        for(int l=1,r;l<=m;l=r+1){
            r=m/(m/l); int k=m/l;
            int ret=pwg[1ll*n*dlog[(m-k)%modp]%phi]; if(!(m-k)) ret=0;
            ret=(modp*((m-k)&1)+2ll*inv2*ret)%Modm; 
            ret=(mn-ret+Modm)%Modm;
            ans=(ans+1ll*ret*(h[r]-h[l-1])%Modm+Modm)%Modm;
        }
        printf("%d\n",ksm(g,ans,Mod));
    }
	return 0;
}
```

---

## 作者：littlez_meow (赞：3)

都是很典的技巧，比较简单。

首先我们先不加证明的给出几个很经典的引理：

1. $\operatorname{lcm} S=\prod\limits_{T\subseteq S,T\neq\varnothing}\gcd T^{(-1)^{|T|-1}}$，即 $\gcd-\operatorname{lcm}$ 容斥，使用 $\min-\max$ 容斥可证。

2. $\gcd(f_{i_1},\cdots,f_{i_n})=f_{\gcd(i_1,\cdots,i_n)}$，其中 $f_i$ 是斐波那契数列的第 $i$ 项。从二元情况归纳可证，二元情况辗转相除可证。

3. $\sum\limits_{i_1=1}^m\cdots\sum\limits_{i_n=1}^m[\gcd(i_1,\cdots,i_n)=k]=\sum\limits_{d=1}^{\lfloor\frac{m}{k}\rfloor}\mu(d)\lfloor\dfrac m{dk}\rfloor^n$。莫反可证。

下面开始推式子。写出原式：

$$\prod\limits_{i_1=1}^m\cdots\prod\limits_{i_n=1}^m\operatorname{lcm}(f_{i_1},\cdots,f_{i_n})$$

使用引理 $1$：

$$\prod\limits_{i_1=1}^m\cdots\prod\limits_{i_n=1}^m\prod_{T\subseteq\{1,2,\cdots,n\}}\gcd\limits_{j\in T}(f_{i_j})^{(-1)^{|T|-1}}$$

使用引理 $2$：

$$\prod\limits_{i_1=1}^m\cdots\prod\limits_{i_n=1}^m\prod_{T\subseteq\{1,2,\cdots,n\}}f_{\gcd\limits_{j\in T}(i_j)}^{(-1)^{|T|-1}}$$

枚举 $|T|=i,\gcd\limits_{t\in T}(i_t)=j$，使用引理 $3$，得到：

$$\prod\limits_{i=1}^n\prod\limits_{j=1}^m\left(f_j^{(-1)^{i-1}}\right)^{\binom{n}{i}m^{n-i}\sum\limits_{d=1}^{\lfloor\frac m j\rfloor}\mu(d)\lfloor\frac{m}{dj}\rfloor^i}$$

具体地，$m^{n-i}$ 是不包含在 $T$ 中元素的选法，$\binom{n}{i}$ 是给 $T$ 中元素分配标号的方案数，后面的求和号是引理 $3$。

整理得：

$$\prod\limits_{j=1}^m\prod\limits_{i=1}^nf_j^{(-1)^{i-1}\binom{n}{i}m^{n-i}\sum\limits_{d=1}^{\lfloor\frac m j\rfloor}\mu(d)\lfloor\frac{m}{dj}\rfloor^i}$$

枚举 $i$ 求积就是在指数上枚举 $i$ 求和，交换求和号：

$$\prod\limits_{j=1}^m f_j^{\sum\limits_{d=1}^{\lfloor\frac m j\rfloor}\mu(d)\sum\limits_{i=1}^{n}(-1)^{i-1}\binom{n}{i}m^{n-i}\lfloor\frac{m}{dj}\rfloor^i}$$

整理：

$$\prod\limits_{j=1}^m\prod\limits_{d=1}^{\lfloor\frac m j\rfloor} f_j^{\mu(d)\left(-\sum\limits_{i=1}^{n}(-\lfloor\frac{m}{dj}\rfloor)^i\binom{n}{i}m^{n-i}\right)}$$

指数上的括号里可以补上 $i=0$ 使用二项式定理：

$$\prod\limits_{j=1}^m\prod\limits_{d=1}^{\lfloor\frac m j\rfloor} f_j^{\mu(d)(m^n-(m-\lfloor\frac m{dj}\rfloor)^n)}$$

枚举 $jd=t$，整理得到：

$$\prod\limits_{t=1}^m\left(\prod\limits_{d|t}f_d^{\mu(\frac t d)}\right)^{m^n-(m-\lfloor\frac m t\rfloor)^n}$$

预处理括号里面的前缀积就可以用整除分块单次 $O(\sqrt{m}\log n)$ 预处理了，如果使用欧拉定理还能优化到 $O(\sqrt{m}\log P)$，使用离散对数应该可以做到 $O(\sqrt{m})$，不过第一个就足够了。

至于预处理 $\prod\limits_{d|t}f_d^{\mu(\frac t d)}$，求离散对数后就是经典的求一个数列和莫比乌斯函数的狄利克雷卷积，可以使用类似狄利克雷前缀和的方法，每次减去（求离散对数前是除掉）比当前质数的次数少一的位置的值，即可 $O(m\log\log m)$ 预处理。

总的时间复杂度是 $O(m\log\log m+T\sqrt{m}\log n)$。

```
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
#define ll long long
#define File(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
using namespace std;
const int MAXN=2e7+1,MOD=37426667,EXPO=37426666;
inline ll qpow(ll base,ll expo){
	ll res=1;
	while(expo){
		(expo&1)&&(res=res*base%MOD);
		base=base*base%MOD,expo>>=1;
	}
	return res;
} 
inline ll qpowe(ll base,ll expo){
	ll res=1;
	while(expo){
		(expo&1)&&(res=res*base%EXPO);
		base=base*base%EXPO,expo>>=1;
	}
	return res;
} 
int pr[MAXN],cnt;
bool vis[MAXN];
short mu[MAXN];
inline void init(){
	mu[1]=1;
	F(i,2,MAXN-1){
		!vis[i]&&(pr[++cnt]=i,mu[i]=-1);
		F(j,1,cnt){
			int t=i*pr[j];
			if(t>=MAXN) break;
			vis[t]=1;
			if(i%pr[j]==0) break;
			else mu[t]=-mu[i];
		}
	}
	return;
}
int inv[MOD],fib[MAXN],mul[MAXN];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	init();
	inv[1]=1;
	F(i,2,MOD-1) inv[i]=MOD-MOD/i*1ll*inv[MOD%i]%MOD;
	fib[1]=fib[2]=mul[0]=mul[1]=mul[2]=1;
	F(i,3,MAXN-1) (fib[i]=fib[i-1]+fib[i-2])>=MOD&&(fib[i]-=MOD),mul[i]=fib[i];
	F(i,1,cnt) for(int t=(MAXN-1)/pr[i],j=t*pr[i];j>=pr[i];j-=pr[i],--t) mul[j]=mul[j]*1ll*inv[mul[t]]%MOD;
	F(i,1,MAXN-1) mul[i]=mul[i-1]*1ll*mul[i]%MOD;
	int T,m;
	for(cin>>T;T;--T){
		ll n,ans=1;
		cin>>n>>m;
		ll qwq=qpowe(m,n);
		for(int l=1,r;l<=m;l=r+1){
			int t=m/l;
			r=m/t;
			ans=ans*qpow(mul[r]*1ll*inv[mul[l-1]]%MOD,qwq-qpowe(m-t,n)+EXPO)%MOD;
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：Aegleseeker_ (赞：1)

前面推式子的部分不是啥难点，可以参考 P7360 一题。这里就简单提个思路。

根据 gcd-lcm 变换拆成 $\gcd$，随后枚举每个 $\gcd$ 计算指数上的贡献，可以直接莫反，计数部分需要一个组合数乘上一个幂。

可以发现指数上是一个 $\sum a^ib^{n-i}\times C_{n}^i$ 的形式，考虑整体取逆、补齐系数然后二项式定理，再根据经典的「令 $T=td$」，指数项上变成了一个只含下取整除法的东西，于是就可以整除分块了。

此时你的式子应当长这样：$\prod\limits_{T=1}^m(\prod\limits_{d|T}f_d^{\mu(\frac{T}{d})})^{m^n-(m-\left\lfloor\frac{m}{T}\right\rfloor)^n}$，指数上整除分块，现在考虑如何快速求出下面那坨，发现直接调和级数过不了，通过观察可以发现你取离散对数或取 $\ln$ 之后它变成了狄利克雷卷积的模样，而且其中有一项是 $\mu$。可以直接硬套狄利克雷前缀和，复杂度 $O(m\ln \ln m)$，注意到模数和 $m$ 同级，考虑用线性求逆元的 trick 求出要用的所有逆元，指数上面那个 $x^n$ 可以根据欧拉定理直接对模数的 $\varphi$ 取模，那个 $n$ 也可以根据扩展欧拉定理多取几次模，这样总复杂度就变成了 $O(m\ln \ln m+T\sqrt m\log p)$，当然 $\log$ 里是 $n$ 也可以过。这个题可能需要卡常。

submission：https://www.luogu.com.cn/record/229147978

---


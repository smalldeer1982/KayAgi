# [蓝桥杯 2024 国研究生组] 深度优先搜索

## 题目描述

小蓝正在学习深度优先搜索。给出一段小蓝写的代码

```cpp
void dfs(int rt, int deep, int fa) {
    a[++cnt] = deep;
    for (int i = head[rt]; i; i = e[i].next)
        if (e[i].to != fa) dfs(e[i].to, deep + 1, rt);
}
```

对一个有根树执行 `dfs(root, 0, 0)` 可以生成一个长度为树中结点个数的序列，依次表示对遍历的所有结点的深度，小蓝认为假如一个序列能够通过对一个有根树执行 `dfs` 得到，这个序列就是合法的。现在小蓝有一个只包含 $-1$ 和非负整数的序列，小蓝想要知道，有多少种把 $-1$ 替换成任意非负整数的方案，使得该序列合法。

## 说明/提示

### 样例说明

对于样例 $2$，两个合法的序列是 $\{0, 1, 1, 1\}$ 和 $\{0, 1, 2, 1\}$。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，保证序列中不会出现两个连续的 $-1$，即若 $a_i = -1$，则 $a_{i+1} \neq -1$。
- 对于 $50\%$ 的评测用例，$n \leq 300$；
- 对于所有评测用例，$1 \leq n \leq 1000000$，$-1 \leq a_i \leq n$。

## 样例 #1

### 输入

```
2
1 -1```

### 输出

```
0```

## 样例 #2

### 输入

```
4
0 1 -1 1```

### 输出

```
2```

# 题解

## 作者：gcx12012 (赞：2)

### 前言
被这个题成功卡爆了一晚上，水平有待提升。
### Solution
考虑一个合法的整数序列 $a$ 满足以下条件：$a_1=0$ 且 $\forall 2\le i \le n,1\le a_i \le a_{i-1}+1$。

于是我们只需要计算每一段 $-1$ 的贡献然后乘一起即可。

设 $a_l=x,a_r=y$，中间一段都是 $-1$，我们可以先设置段内的 $a_i=x+i-l$，然后从左到右考虑在满足条件的前提下对段内的一段后缀减去某个非负整数。

考虑上述与一个经典二维格点路径计数问题等价：给定起点 $S(0,-a_l)$ 和终点 $T(r-l-1,r-l-a_r)$，要求只能走到 $(x,y+1)$ 或 $(x+1,y)$，且不能经过满足 $x<y$ 的点，求合法路径的方案数。

我们可以将直线 $y=x+1$ 作为分界线，作出点 $S$ 的对称点，也就是 $S'(-1-a_l,1)$。

设 $f(A,B)$ 表示**无** $x<y$ 约束下从 $A$ 点走到 $B$ 点的方案数，那么**有** $x<y$ 约束下从 $S$ 点走到 $T$ 点的方案数为 $f(S,T)-f(S',T)$。

如果 $a_n=-1$，枚举 $a_n$ 的合法值计数即可，于是这题就做完了。
```
const ll mod=1e9+7;
ll fac[N],inv[N];
ll a[N],n;

ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
ll ksm(ll x,ll y){
	ll p=1;
	while(y){
		if(y&1) p=p*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return p;
}
ll C(int u,int v){
	if(u<v || u<0 || v<0) return 0;
	return fac[u]*inv[v]%mod*inv[u-v]%mod;
}
ll sol(int l,int r){
	int x1=0,y1=-a[l],x2=r-l-1,y2=x2-a[r]+1;
	ll now=0;
	now=(now+C(x2-x1+y2-y1,x2-x1))%mod;
	x1=-(1-y1),y1=1;
	now=(now-C(x2-x1+y2-y1,x2-x1)+mod)%mod;
	return now;
}

int main()
{
    //freopen("gcx.in","r",stdin);
    //freopen("gcx.out","w",stdout);
    fac[0]=1;
    For(i,1,N-1) fac[i]=fac[i-1]*i%mod;
    inv[N-1]=ksm(fac[N-1],mod-2);
    Rof(i,N-2,0) inv[i]=inv[i+1]*(i+1)%mod;
    n=read();
    For(i,1,n) a[i]=read();
    if(a[1]>0){
    	cout<<0;
    	return 0;
    }
    a[1]=0;
    ll ans=1;
    int lst=1;
    For(i,2,n){
    	if(a[i]!=-1){
    		ans=ans*sol(lst,i)%mod;
    		lst=i;
    	}
    }
    if(a[n]==-1){
    	ll sum=0;
    	For(i,1,n){
    		a[n]=i;
    		sum=(sum+sol(lst,n))%mod;
    	}
    	ans=ans*sum%mod;
    }
    cout<<ans;
   	return 0;
}
```

---

## 作者：2008verser (赞：2)

蓝桥杯是套路大赛吗？

不难找到合法 $a$ 的充要条件：

$a_0=0,a_1=1$，对于剩下的 $a_i$ 需要 $a_i\geq 1,a_i\leq a_{i-1}+1$。

我们有一个显然的 dp，但它没法优化。

套路地考虑其差分数组，并对 $-1$ 段分别求解最后相乘。

记 $a_l,a_r\neq -1$ 并且夹着一段 $-1$。记 $a_{l+1}-a_l,\ldots,a_r-a_{r-1}$ 为 $s_0,\ldots,s_{r-l-1}$。

计数 $s$ 的数目，$s$ 满足：

- $s_i\leq 1$。
- 对于任意 $0\leq i\leq r-l-1$，$a_l+\sum_{j=0}^is_j+i+1\geq 1$。

套路地（比如 AGC023C），转化为计数 $c$，其中 $c_i=s_i-1$。

接着就是格路计数反射容斥。特殊地，当末尾一段 $-1$ 时枚举 $a_n$ 即可。

时间复杂度 $O(n)$。

参考代码：

```c++
#include<bits/stdc++.h>
#define ll long long
#define rg register
#define pb push_back
#define ppb pop_back
#define ld long double
#define fo(i,l,r) for(rg int i=(l);i<=(r);++i)
#define rp(i,r,l) for(rg int i=(r);i>=(l);--i)

using namespace std;

const int N=2e6+5;
const int mod=1e9+7;

int fac[N],inv[N];
inline int qp(rg int a,rg int b=mod-2) {
	rg int s=1;while(b) {
		if(b&1) s=1ll*s*a%mod;
		a=1ll*a*a%mod;b>>=1;
	} return s;
}
inline int add(rg int x,rg int y) { return x+y<mod?x+y:x+y-mod; }
inline int dec(rg int x,rg int y) { return x-y<0?x-y+mod:x-y; }
inline void ADD(rg int&x,rg int y) { x=x+y<mod?x+y:x+y-mod; }
inline void DEC(rg int&x,rg int y) { x=x-y<0?x-y+mod:x-y; }
inline int C(rg int m,rg int n) { return (m<n||m<0||n<0)?0:1ll*fac[m]*inv[n]%mod*inv[m-n]%mod; }
int sf[N],isf[N];
inline void init(rg int n) {
	inv[0]=fac[0]=sf[0]=1;
	fo(i,1,n) fac[i]=1ll*fac[i-1]*i%mod,sf[i]=1ll*sf[i-1]*fac[i]%mod;
	isf[n]=qp(sf[n]);inv[n]=1ll*isf[n]*sf[n-1]%mod;
	rp(i,n-1,1) isf[i]=1ll*isf[i+1]*fac[i+1]%mod,inv[i]=1ll*isf[i]*sf[i-1]%mod;
}

int n,a[N],ans=1;
int check() {
	if(a[1]>0||abs(a[2])!=1) return 1;
	fo(i,2,n) if(a[i]==0) return 1;
	return 0;
}
int qwq(int m,int n) {
	return C(m+n,n);
}
int calc(int m,int n,int x) {
	if(n>=x+m||n<0) return 0;
	if(n<x) return qwq(m,n);
	return dec(qwq(m,n),qwq(n-x,m+x));
}

int main() {
//	freopen("in.txt","r",stdin);
//	freopen("out.txt","w",stdout);
	init(2e6);
	scanf("%d",&n);
	fo(i,1,n) scanf("%d",&a[i]);
	if(check()) return puts("0"),0;
	a[1]=0;a[2]=1;
	
	fo(i,1,n) {
		if(a[i]==-1) {
			int j=i;
			while(j<n&&a[j+1]==-1) j++;
			int l=i-1,r=j+1,nw=0;
			if(r==n+1) {
				r=n;
				fo(x,1,n-1) {
					ADD(nw,calc(r-l-1,-(x-r-a[l]+l),a[l]+1));
				}
			} else {
				nw=calc(r-l-1,-(a[r]-r-a[l]+l),a[l]+1);
			}
			ans=1ll*ans*nw%mod;
			i=j;
		}
	}
	printf("%d",ans);
}
```

---


# [CQOI2012] 局部极小值

## 题目描述

有一个 $n$ 行 $m$ 列的整数矩阵，其中 $1$ 到 $n\times m$ 之间的每个整数恰好出现一次。

如果一个格子比所有相邻格子（相邻是指有公共边或公共顶点）都小，我们说这个格子是局部极小值。给出所有局部极小值的位置，你的任务是判断有多少个可能的矩阵。

答案对 $12{,}345{,}678$ 取模。

## 说明/提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $1\le n\le4$，$1\le m\le7$。

## 样例 #1

### 输入

```
3 2
X.
..
.X```

### 输出

```
60```

# 题解

## 作者：kkksc03 (赞：75)

题目大意：将1~n\*m分别放入n\*m的格子矩阵里，其中的一些格子有特殊要求（周围的8个格子都要比它大），问方案数。

解决：从小到大放数，则一个普通格子只有等它周围的特殊格子都放完数了才能放数。在不考虑本题中“.”的格子不能是蓄水池的条件的情况下，我们可以写出如下记忆化搜索的方程式f[k][s]=sum{f[k-1][s’]}。其中sum为求和，k为放到了第几个数，s为蓄水池的放数状态（二进制状压），s’表示由s少放一个蓄水池能达到的状态。最后f[n\*m][s全放]即为解。本题n<=4，m<=7，最多只有8个蓄水池，故此解可行。

本题的难点在于“.”的格子不能是蓄水池。我们可以用容斥原理来解决。我们设在原来的基础上又增加了p个蓄水池，若p为奇数，则ans应减去f[n\*m][s全放]，否则为加上。由于本题对于蓄水池的限制很足（不能相邻），所以这样的枚举次数不会太多，耗时也不大。

状态压缩记忆化搜索也可以写成搜索（即标程做法），所有测试点均在100ms内解决。

```cpp

#include <iostream>
using namespace std;

const int maxp = 8;
const int maxs = 1 << maxp;
const int mod = 12345678;
const int maxrow = 4;
const int maxcol = 7;
const int maxn = maxrow * maxcol + 2;

int n, m, ans;
int f[maxs][maxn], x[maxp], y[maxp], tp;
bool use[maxrow][maxcol];
char graph[maxrow][maxcol];

void init() {
    scanf("%d%d\n", &n, &m);
    for (int i = 0; i < n; ++i)
        gets(graph[i]);
}

bool in_range(int x, int y) {
    return x >= 0 && y >= 0 && x < n && y < m;
}

int calc() {
    tp = 0;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            if (graph[i][j] == 'X') x[tp] = i, y[tp++] = j;
    memset(f, 0, sizeof(f));
    f[0][0] = 1;
    for (int s = 0; s < 1 << tp; ++s) {
        memset(use, 1, sizeof(use));
        for (int i = 0; i < tp; ++i)
            if (!(s & (1 << i)))
                for (int dx = -1; dx <= 1; ++dx)
                    for (int dy = -1; dy <= 1; ++dy)
                        if (in_range(x[i] + dx, y[i] + dy)) use[x[i] + dx][y[i] + dy] = 0;
        
        int cnt = 0;
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < m; ++j)
                if (use[i][j]) ++cnt;

        for (int i = 0; i <= cnt; ++i)
            if (f[s][i]) {
                f[s][i + 1] = (f[s][i + 1] + f[s][i] * (cnt - i)) % mod;
                for (int j = 0; j < tp; ++j)
                    if (!(s & (1 << j))) f[s | (1 << j)][i + 1] = (f[s | (1 << j)][i + 1] + f[s][i]) % mod;
            }
    }
    return f[(1 << tp) - 1][n * m];
}

void search(int x, int y, int k) {
    if (x >= n) ans = (ans + k * calc()) % mod;
    else if (y >= m) search(x + 1, 0, k);
    else {
        search(x, y + 1, k);
        bool ok = 1;
        for (int dx = -1; dx <= 1; ++dx)
            for (int dy = -1; dy <= 1; ++dy)
                if (in_range(x + dx, y + dy) && graph[x + dx][y + dy] == 'X')
                    ok = 0;
        if (ok) {
            graph[x][y] = 'X';
            search(x, y + 1, -k);
            graph[x][y] = '.';
        }
    }
}

int solve() {
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            if (graph[i][j] == 'X')
                for (int dx = -1; dx <= 1; ++dx)
                    for (int dy = -1; dy <= 1; ++dy)
                        if ((dx || dy) && in_range(i + dx, j + dy) && graph[i + dx][j + dy] == 'X')
                            return 0;
    ans = 0;
    search(0, 0, 1);
    return (ans + mod) % mod;
}

int main() {
    freopen("mon.in", "r", stdin);
    freopen("mon.out", "w", stdout);

    init();
    printf("%d\n", solve());
    
    return 0;
}


```
[/cdec]


---

## 作者：Starlight237 (赞：57)

此题的细节十分繁杂（不然怎能是黑题），而两篇题解似乎都有些省漏和不严谨之处，使新人难以看懂。故在此详细解释一下，方便诸位理解。

为了方便处理水池的限制，我们从小到大地填入数字。我们考虑用$dp[i][S]$表示已经填到了数字i，且目前已经填入数字的水池所构成的集合为$S$时，符合要求的方案数。

那么我们每一次填入数字有两种可能：
- 当前数字填入一个非水池点。  

此时有$dp[i][S]=dp[i-1][S]*\max(able[S]-i+1,0)$，其中able[S]表示**已经在集合S中的点**与**可以放置数字而不会使周围的水池点不再满足条件的非水池点**的总数量。至于为何able要包含已经在S中的点，是由于如下理由：

我们在转移状态时，并不知道前面i-1个数有多少占据了非水池点。如果我们的able数组不包含S中的点，我们就需要计算S的大小来算出当前可以放置第i个数的个数：$able[S]-(i-1-|S|)$（因为前面i-1个点有|S|个是水池点，故有i-1-|S|个数占据了非水池点。那现在能用的就是上面那个柿子）。这无疑非常麻烦。  

而如果able[S]包含S中的点，前后两个|S|就能够被抵消。从而现在能放第i个数的非水池点有$\max(able[S]-i+1,0)$个（因为可能不够用）。

我们考虑预处理数组able。首先对于每一个非水池点，如果它周围有没放数的水池点，那么显然这里是不可以放数的。否则，由于我们是从小到大放数，以后放在水池点中的数将会大于这个非水池点的数，与约束条件不符。

那么我们枚举不在S中的水池点（没有放过数的），向四周扩展（它四周的点肯定都不满足条件）。假设不在S中的水池点和不满足要求的非水池点共有used个，即有$able[S]=n*m-used$。参见代码。注意需要开vis数组避免重复计数。

- 当前数字填入一个水池点。

此时是显然的。枚举不在S中的水池点j，执行$dp[i][S+\{j\}]+=dp[i-1][S]$即可。

由于$|S|$会非常小，所以可以用状态压缩来完成。

那么答案就是$dp[n*m][2^{cnt}-1]$。cnt为水池点个数。

~~WA~~

考虑限制2。我们的$dp$值其实有可能在随意填数的过程中，把一些非水池点填成了满足水池点条件的点。

利用容斥原理。设$Ans[k][map]$为有k个水池点，点的分布状态为map的答案，则最终答案为：
$$Ans[k][map_0]-\sum\limits_{\text{所有满足条件的map}}Ans[k+1][map]+\sum\limits_{\text{所有满足条件的map}}Ans[k+2][map]-......$$

$map$满足条件是指：有符合数量的水池点，且初始状态$map_0$中的水池点在$map$中也是水池点。

怎样枚举满足条件的map呢？

DFS！

顺序枚举每一次新加进去的水池点，用op来切换+和-。

注意代码中，我们用$islow[i][j]$来表示map。

代码有一定卡常因素。为方便对拍，没有反作弊标志（黑题也没人敢抄题解吧）。

注意限制1需要特判！
## code

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
#define reg register
inline void work();
int main(){
    work();
    return 0;
}
//End of MAIN
const int mod=12345678,dx[]={-1,0,1,0,-1,1,-1,1},dy[]={0,-1,0,1,-1,-1,1,1};//方向数组
int n,m,cnt,ans,islow[10][10],vis[10][10],able[1<<10],dp[30][1<<10];
struct Node{int x,y;}pnt[10];
inline int calc(){
    cnt=0,
    memset(dp,0,sizeof dp),dp[0][0]=1,
    memset(vis,0,sizeof vis);
    for(reg int i=1;i<=n;++i)
        for(reg int j=1;j<=m;++j)
            islow[i][j]&&(pnt[++cnt]=Node{i,j},0);
    for(reg int i=0,used;i<(1<<cnt);++i){
        memset(vis,0,sizeof vis),used=0;
        for(reg int j=1;j<=cnt;++j)
            if(!(i&(1<<j-1))){
                vis[pnt[j].x][pnt[j].y]||(vis[pnt[j].x][pnt[j].y]=1,++used);
                for(reg int dir=0,x1,y1;dir<8;++dir)
                    x1=pnt[j].x+dx[dir],y1=pnt[j].y+dy[dir],
                    x1>0&&x1<=n&&y1>0&&y1<=m&&!vis[x1][y1]&&(vis[x1][y1]=1,++used);
            }
        able[i]=n*m-used;
    }
    for(reg int i=1;i<=n*m;++i)
        for(reg int j=0;j<(1<<cnt);++j){
            dp[i][j]+=dp[i-1][j]*max(able[j]-i+1,0)%mod,dp[i][j]%=mod;
            for(reg int k=1;k<=cnt;++k)
                (j&(1<<k-1))||((dp[i][j|1<<k-1]+=dp[i-1][j])%=mod);
        }
    return dp[n*m][(1<<cnt)-1];
}
void dfs(int x,int y,int op){
    if(x>n){(ans+=op*calc())%=mod;return;}
    if(y>m){dfs(x+1,1,op);return;}
    dfs(x,y+1,op);
    if(!islow[x][y]){
        reg bool fl=0;
        for(reg int dir=0,x1,y1;dir<8;++dir)
            x1=x+dx[dir],y1=y+dy[dir],islow[x1][y1]&&(fl=1,dir=8);
        fl||(islow[x][y]=1,dfs(x,y+1,-op),islow[x][y]=0);
    }
}
inline void work(){
    char str[10];
    scanf("%d%d",&n,&m);
    for(reg int i=1;i<=n;++i){
        scanf("%s",str+1);
        for(reg int j=1;j<=m;++j)
            islow[i][j]=str[j]=='X';
    }
    for(reg int i=1;i<=n;++i)
        for(reg int j=1;j<=m;++j)
            islow[i][j]&&(islow[i-1][j]||islow[i][j-1])&&(puts("0"),exit(0),0);
    dfs(1,1,1);
    printf("%d",(ans%mod+mod)%mod);
}
```
点赞是一种美德！

---

## 作者：leozhang (赞：32)

这题太难了...看了30篇题解才整明白到底咋回事...

核心思想：状压dp+搜索+容斥

首先我们分析一下，对于一个4*7的棋盘，低点的个数至多只有8个（可以数一数）

这样的话，我们可以进行一个状压，把所有的低点压进来

然后我们从小到大枚举所有数，转移即可

记状态f[i][j]表示到了第i个数，低点的状态为j的方案数

那么在转移的时候，有两个转移方向：

①.如果第i个数放在低点上，那么我们可以枚举所有的低点k，如果低点没有在状态里，有：

dp[i][j|(1<<k)]+=dp[i-1][j]

②.如果第i个数放在高点上，那么我们需要枚举所有可以使用的高点，所谓可以使用的高点就是指的某一高点周围没有未使用的低点（原因：我是从小往大枚举的所有数，如果我在一个高点上放了一个数而他附近却有低点没有放上，那么这个低点会变得比这个高点高，这就是不合法的了。）

但是如果每次都枚举，时间复杂度是会爆炸的，所以我们需要进行一个预处理num[i]，表示i状态下有多少个高点可以使用

最后的答案就是dp[n*m][1<<cnt-1]

可是这个答案是正确的吗？

我们发现，如果仅仅是这么枚举，很容易出现一种情况：某个点本来是高点，但是由于随意的放置使得这个点变成了低点

所以我们需要解决掉这个问题

怎么解决？

很显然，我们只需求出把每个可能被放错的高点真正作为低点的方案数，然后用总方案数减掉这个方案数就可以了。

可是，如果我们分别去减，由于减的方案数还要像上面那样dp出来，所以会产生更多的重复（即高点1和高点2同时放错）

所以我们需要利用容斥，即

0个高点反转-1个高点反转+2个高点反转....

（反转指反转状态）

那么怎么反转？

dfs！

贴代码：

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
#define ll long long
#define mode 12345678
using namespace std;
bool used[10][10];
bool maps[10][10];
int n,m;
ll dp[30][(1<<8)+5];
char ch[10];
int dir[10][2]={{0,0},{1,1},{1,0},{1,-1},{0,1},{0,-1},{-1,1},{-1,0},{-1,-1}};
int temp[30][2];
int num[(1<<8)+5];
ll ans=0;
bool check(int x,int y)
{
    if(x>0&&x<=n&&y>0&&y<=m)
    {
        return 1;
    }
    return 0;
}
ll get_dp()
{
    int cnt=0;
    memset(dp,0,sizeof(dp));
    memset(used,0,sizeof(used));
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(maps[i][j])
            {
                used[i][j]=1;
                temp[++cnt][0]=i;
                temp[cnt][1]=j;
            }
        }
    }
    for(int i=0;i<=(1<<cnt)-1;i++)
    {
        int tot=0;
        memset(used,0,sizeof(used));
        for(int j=1;j<=cnt;j++)
        {
            if(!((1<<(j-1))&i))
            {
                if(!used[temp[j][0]][temp[j][1]])
                {
                    used[temp[j][0]][temp[j][1]]=1;
                    tot++;
                }
                for(int t=1;t<=8;t++)
                {
                    int x=temp[j][0]+dir[t][0];
                    int y=temp[j][1]+dir[t][1];
                    if(check(x,y)&&!used[x][y])
                    {
                        used[x][y]=1;
                        tot++;
                    }
                }
            }
        }
        num[i]=n*m-tot;
    }
    dp[0][0]=1;
    for(int i=1;i<=n*m;i++)
    {
        for(int j=0;j<=(1<<cnt)-1;j++)
        {
            dp[i][j]+=dp[i-1][j]*max(num[j]-i+1,0)%mode;
            dp[i][j]%=mode;
            for(int k=1;k<=cnt;k++)
            {
                if(!((1<<(k-1))&j))
                {
                    dp[i][j|(1<<(k-1))]+=dp[i-1][j];
                    dp[i][j|(1<<(k-1))]%=mode;
                }
            }
        }
    }
    return dp[n*m][(1<<cnt)-1];
}
void dfs(int x,int y,int typ)
{
    if(x==n+1)
    {
        if(typ%2)
        {
            ans-=get_dp();
            ans%=mode;
        }else
        {
            ans+=get_dp();
            ans%=mode;
        }
        return;
    }
    if(y==m+1)
    {
        dfs(x+1,1,typ);
        return;
    }
    dfs(x,y+1,typ);
    if(!maps[x][y])
    {
        bool flag=0;
        for(int i=1;i<=8;i++)
        {
            int st=x+dir[i][0];
            int ed=y+dir[i][1];
            if(maps[st][ed])
            {
                flag=1;
                break;
            }
        }
        if(!flag)
        {
            maps[x][y]=1;
            dfs(x,y+1,typ+1);
            maps[x][y]=0;
            return;
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%s",ch);
        for(int j=0;j<m;j++)
        {
            if(ch[j]=='.')
            {
                maps[i][j+1]=0;
            }else
            {
                maps[i][j+1]=1;
            }
        }
    }
    dfs(1,1,0);
    printf("%lld\n",(ans%mode+mode)%mode);
    return 0;
} 
```

---

## 作者：Leap_Frog (赞：20)

[双倍经验](https://www.luogu.com.cn/problem/P3160)  

### Problem.
有这样一个地图，你需要统计满足条件的地图高度方案数。  
地图高度从$1$~$n\times m$，然后有一些限制条件，表示为一个点的数值比和它四周八个格子小。  
还有题目中的那两个补注条件挺重要的。  
### Solution.
我们首先先考虑不管两个注释。  

那么就是一个dp问题。  
状态：当前这一行是怎么放的。  
然后还需要开一个数组记录一下。  
因为一行的状态之和上一行有关，所以这个状态设计具有无后效性。  
所以它是可以dp的。  
具体dp过程看代码。  

然后呢，我们考虑加上第二个注释。  
我们可以发现，这是一个裸的容斥方法。  
假设读入有$k$个蓄水池。  
那么我们可以考虑答案为$k$个蓄水池的答案-$k+1$个蓄水池的答案+$k+2$...  
但是我们怎么算$k+1$个蓄水池的答案呢？  
我们直接暴力计算，重新dp一次就可以过了。  

然后呢，我们考虑加上第一个注释。  
我们发现，第一个注释其实就是一点特判的事情。  
只要刚开始时特判有没有蓄水池相邻就好了。  
### Coding
```cpp
#include<bits/stdc++.h>
using namespace std;
const int P=12345678,dx[]={-1,0,1,0,-1,1,-1,1,0},dy[]={0,-1,0,1,-1,-1,1,1,0};//P是模数，dx和dy表示
int n,m,cnt,x[35],y[35],mp[15][15],vis[15][15],f[35][265],te[515];char a[15];
inline int bs(int x) {return x>0?x:-x;}//绝对值
inline int dp()//dp的过程
{
	memset(f,0,sizeof(f)),f[0][0]=1;//f是dp值
	for(int i=0;i<(1<<cnt);i++)//枚举集合。
	{
		te[i]=n*m,memset(vis,0,sizeof(vis));//vis表示现在是否用了当前值。
		for(int j=0;j<cnt;j++) if((i&(1<<j))==0) for(int k=0;k<=8;k++) vis[x[j]+dx[k]][y[j]+dy[k]]=1;//把那些会用到的东西记下来
		for(int j=1;j<=n;j++) for(int k=1;k<=m;k++) if(vis[j][k]) te[i]--;//表示能向多少个转移
	}
	for(int i=1;i<=n*m;i++)
		for(int j=0;j<(1<<cnt);j++)
		{
			if(te[j]-i+1>0) f[i][j]+=f[i-1][j]*(te[j]-i+1),f[i][j]%=P;//正式转移，用到了上面的te
			for(int k=0;k<cnt;k++) if((1<<k)&j) f[i][j]+=f[i-1][j^(1<<k)],f[i][j]%=P;
		}
	return f[n*m][(1<<cnt)-1];//返回答案。
}
inline int dfs(int xx,int yy)
{
	int ans;if(yy==m+1) xx++,yy=1;if(xx==n+1) return dp();ans=dfs(xx,yy+1);//边界处理（然后有点压行
	for(int i=0;i<9;i++) if(mp[xx+dx[i]][yy+dy[i]]) return ans;//如果这里是已经是蓄水池，或者周围有蓄水池，就返回。
	return x[cnt]=xx,y[cnt++]=yy,mp[xx][yy]=1,(ans+=P-dfs(xx,yy+1))%=P,mp[xx][yy]=0,cnt--,ans;
	//首先先加上当前这个位置的蓄水池，记录为蓄水池
   //然后dfs，答案加上dfs指
   //然后回溯。
}
int main()
{
	scanf("%d%d",&n,&m),memset(mp,0,sizeof(mp));//清零数组
	for(int i=1;i<=n;i++)
	{
		scanf("%s",a+1);
		for(int j=1;j<=m;j++) if(a[j]=='X') mp[i][j]=1,x[cnt]=i,y[cnt++]=j;
	}//读入
	for(int i=0;i<cnt;i++) for(int j=0;j<i;j++) if(bs(x[i]-x[j])<2&&bs(y[i]-y[j])<2) return puts("0"),0;//特判第一个注释。
	return cnt?printf("%d\n",dfs(1,1)):puts("0"),0;//完美结束。
}
```
完结撒花，~~无耻求赞~~

---

## 作者：Potassium (赞：11)

存下来每个坑（极小值点）的位置，以这个序号进行状态压缩。

显然，$4*7$的数据范围让极小值点在8个以内（以下示意）

>X . X . X . X . 

>.&ensp;.&ensp;.&ensp;.&ensp;.&ensp;.&ensp;.&ensp;. 

>X . X . X . X .

>.&ensp;.&ensp;.&ensp;.&ensp;.&ensp;.&ensp;.&ensp;. 

所以考虑用$S$表示各个极小值点是否已填的状态，枚举$1-n*m$进行状压$DP$。

当前填的数有两种选择：

（$1$）填入坑中，这样枚举$S$状态表示的每一个已填的坑，$f[i][S]+=$$\sum_{k|((1<<k)\&S==0)}^{} {f[i-1][S-(1<<k)]}$（$k$表示第$k$个坑是没填过的）（这步的意思是：$S-(1<<k)$这个状态没有填$k$位置的坑，我现在$i$要填这个坑的种类数就是$f[i-1][S-(1<<k)]$）

（$2$）不填入坑中，这样枚举每一个点，如果可以填（指如果有坑还没填，那么他旁边以及他本身共$9$个格都不能填东西，否则这个坑继续往后填填不成极小值），那么就是一种新的填法，数出来$tot$种填法，那么$dp[i][S]+=dp[i-1][S]*(tot-i+1)$。然后发现枚举不是很好，可以进行预处理，处理出每一个状态对应的$tot$（代码中用$hi[S]$表示）。

然后答案就是$f[m*n][(1<<num)-1]$。（$num$代表坑的个数）

然后因为是胡乱填数，于是可能会出现不应该是坑的地方变成坑的情况，于是就在每个可能出现坑的地方分别新加一个坑进行$DP$，完了再减去。而这个$DP$又带来新的可能填的坑......而这就是个容斥问题了。

奉上代码：
```
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
char a[10];
int m,n,min[6][10];//描述整个矩阵 
int num,x[30],y[30];//描述坑的个数、位置 
int w=12345678;//膜 
int dx[10]={-1,-1,-1,0,0,1,1,1,0};//移动位置 
int dy[10]={-1,0,1,-1,1,-1,0,1,0};
int vis[6][10],f[29][(1<<8)+10],hi[1<<9];//dp用到的东西 
int dp(){
	int i,j,k;
	memset(f,0,sizeof(f));
	f[0][0]=1;
	for(i=0;i<(1<<num);i++){//预处理出每个状态i对应的可填点数量 
		hi[i]=n*m;
		memset(vis,0,sizeof(vis));
		for(j=0;j<num;j++)if(!(i&(1<<j)))for(k=0;k<9;k++)vis[x[j]+dx[k]][y[j]+dy[k]]=1;
		for(j=1;j<=n;j++)for(k=1;k<=m;k++)if(vis[j][k])hi[i]--;
	}
	for(i=1;i<=n*m;i++){//枚举填哪个数 
		for(j=0;j<(1<<num);j++){//枚举状态 
			if(hi[j]-i+1>0)f[i][j]+=f[i-1][j]*(hi[j]-i+1),f[i][j]%=w;
			for(k=0;k<num;k++)if((1<<k)&j)f[i][j]+=f[i-1][j^(1<<k)],f[i][j]%=w;
		}
	}
	return f[n*m][(1<<num)-1];
}
int dfs(int X,int Y){
	if(Y==m+1)X++,Y=1;
	if(X==n+1)return dp();
	int i,ans=dfs(X,Y+1);
	for(i=0;i<9;i++)if(min[X+dx[i]][Y+dy[i]])return ans;
	//如果没return说明这个地方是个可能变成坑的地方，那就把它变成坑dfs一下 
	x[num]=X;y[num++]=Y;min[X][Y]=1;
	ans-=dfs(X,Y+1),ans=(ans+w)%w;
	min[X][Y]=0;num--;//别忘了变回去 
	return ans;
}
int main(){
	int i,j;
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++){
		scanf("%s",a+1);
		for(j=1;j<=m;j++)if(a[j]=='X'){
			min[i][j]=1;
			x[num]=i;y[num++]=j;
		}
	}
	for(i=0;i<num;i++)for(j=0;j<i;j++)if(abs(x[i]-x[j])<2&&abs(y[i]-y[j])<2)return printf("0"),0;
	if(!num)return printf("0"),0;
	printf("%d",dfs(1,1));
	return 0;
}
```

---

## 作者：Piwry (赞：9)

作为把这题当做第一道容斥题写的蒟蒻，却在题解里翻来翻去都没找到有人讲容斥部分QAQ

~~菜是原罪）~~

话说这篇解析写的很繁琐，可能并不适合给只是想找点提示的人看...其中还有一些因我文笔水平而表达疏忽的部分、和数学用语不严谨的地方，还请见谅QAQ（实在看不下去就私信问我把）

## 解析

### $\text{Part 1.}$ dp部分

如果直接求题目的答案的话，会不太好做，原因是很难在统计答案时要求除了规定位置外，其他位置不出现蓄水池。

因此我们先不考虑剔除有多余蓄水池的方案，那么想到可以从小到大放数字（高度），并且要求一个蓄水池格子周围的格子必须要等这个蓄水池格子放完后才能放。由于蓄水池最多 $8$ 个，因此可以想到用状压：

$\text{dp[k][s]}$，其中 $s$ 表示目前每个蓄水池的状态：$0$ 表示还没放，$1$ 表示放了；$k$ 表示已经放到第几个数字了。

转移也很显然：对于第 $k$ 个数字放到的格子，保证合法，如果是蓄水池格子，那么其贡献就是所有 $\text{dp[k-1][s']}$，且满足 $[\text{ s' == s|(1<<x) }]$ 的和；如果不是蓄水池格子，那么其贡献就是 $\text{dp[k-1][s]}$。

至于保证放的格子合法，我们可以在每一次对于 `s` 的循环中标记那些没有放的蓄水池格子和这些格子周围的格子，并且**统计数量**（不需要知道具体是哪个）。除了那些格子其他的格子都是可放的（至于为什么没统计已放的格子，可以见代码实现；主要是因为对于 $k < |s|$（$|.|$ 表状态的已放蓄水池个数）**不会有贡献**）。

代码就像这样（里面的转移写法有点特殊）：

```cpp
int cntX =0, x[10] ={0}, y[10] ={0};
/*找出所有蓄水池格子的坐标*/
for(int i =0; i < n; ++i) for(int j =0; j < m; ++j) if(map[i][j]) x[cntX] =i, y[cntX++] =j;
dp[0][0] =1;/*初值*/
for(int s =0; s < (1<<cntX); ++s){
	memset(block, 0, sizeof(block));
	int cnt =n*m;/*可以放置的格子的个数*/
	for(int k =0; k < cntX; ++k)
		if(!(s&(1<<k))){/*找出未放的蓄水池*/
			for(int di =-1; di <= 1; ++di) for(int dj =-1; dj <= 1; ++dj)
				if(inrange(x[k]+di, y[k]+dj))
					if(!block[x[k]+di][y[k]+dj])
						block[x[k]+di][y[k]+dj] =1, --cnt;
		}
	for(int i =0; i <= cnt; ++i)
		if(dp[i][s]){/*对于 i < |s| 不会有贡献*/
			/*下一个放的不是蓄水池*/
			dp[i+1][s] =(dp[i+1][s]+dp[i][s]*(cnt-i))%M;
			/*下一个放的是蓄水池*/
			for(int k =0; k < cntX; ++k){
				if(!(s&(1<<k)))/*找出未放的蓄水池*/
					dp[i+1][s|(1<<k)] =(dp[i+1][s|(1<<k)]+dp[i][s])%M;
			}
		}
}
```

---

### $\text{Part 2.}$ 容斥部分

先观察一下，发现我们 dp 求的实际上是：所有**至少包含**题目给出的蓄水池的方案的数量。

那么要去除的其实就是：所有**不只包含**题目给出的蓄水池的方案的数量。

定义我们以题目条件（规定的蓄水池状态）计算（用上文的未去重 dp）出的方案集合为 $S$；并且再规定一个或多个合法的格子**必须**作为蓄水池，并定义其计算出的方案集合 $S'$。我们可以发现 $S'\subsetneq S$（真子集），于是就可以想到**容斥**的方向。

首先可以想到套容斥的基本形式（这是怎么想到的我也不知道QAQ）：

先定义 $G(S, k)$ 表示必定包含蓄水池格子 $S$，并且除 $S$ 外还有 $k$ 个蓄水池的所有**蓄水池状态**计算出的方案的和。

例如设题目要求的蓄水池集合为 $S$，$S$ 及地图为：

```
. 0 1 2
0 X . X
1 . . .
2 . . .
```

那么 $G(S, 1)$ 的所有状态如下：

```
. 0 1 2 | . 0 1 2 | . 0 1 2
0 X . X | 0 X . X | 0 X . X
1 . . . | 1 . . . | 1 . . .
2 X . . | 2 . X . | 2 . . X
```
我们就**对所有状态带入求一次 dp**，并求和，就是 $G(S, 1)$ 的值。

设题目要求的蓄水池集合 $S$，地图最多可容纳 $n$ 个蓄水池，$|.|$ 表示集合的元素个数（或者说基数更合适？），就可以列出式子：$\sum\limits_{k=0}^{n-|S|} (-1)^k\cdot G(S, k)$ 即为最终的答案。

&nbsp;

关于它的正确性，可以考虑用组合数解释：

我们考虑一个多选了 $m$ 个蓄水池，其多选的蓄水池集合为 $S_m$ 的方案在式子中第 $k$ 项的出现次数。可以发现在第 $k$ 项的**所有状态中**，只要满足多选的 $k$ 个蓄水池均是集合 $S_m$ 中的元素，就一定会出现这个方案**一次**（思考下 dp 求出来的东西含义）。

于是这个方案在式子中第 $k$ 项的出现次数**就是 $C_m^k$。**

接着就可以知道这个方案在整个式子中的出现次数是 $\sum\limits_{k=0}^m (-1)^k\cdot C_m^k$（同时显然 $0\leq m\leq n-|S|$）。

这个式子除了在 $[ m=0 ]$ 时取 $1$，其余时刻是恒为 $0$ 的。思考其含义，也就是说除了**没有多选蓄水池的方案**只保留一次，其余的都被消去了，而这就是我们最终求的答案。

&nbsp;

由于数据范围最多支持 $8$ 个蓄水池，可能的状态并不会很多，于是只要想到这里即可；上面的式子的每一项拿 dfs **枚举**就可以了（这部分的代码就看完整 code 把）。

（另外这道题还被 CQOI2012 拿去考了qwq）

## CODE

```cpp
#include <cstdio>
#include <cstring>
#define ll long long

const int M =12345678;

int n, m;
bool map[9][9];
ll ans;

inline bool inrange(int x, int y){ return (x >= 0 && y >= 0 && x < n && y < m); }

ll dp[50][(1<<9)];
bool block[9][9];

inline ll calc(){
	memset(dp, 0, sizeof(dp));
	int cntX =0, x[10] ={0}, y[10] ={0};
	for(int i =0; i < n; ++i) for(int j =0; j < m; ++j) if(map[i][j]) x[cntX] =i, y[cntX++] =j;
	dp[0][0] =1;
	for(int s =0; s < (1<<cntX); ++s){
		memset(block, 0, sizeof(block));
		int cnt =n*m;
		for(int k =0; k < cntX; ++k)
			if(!(s&(1<<k))){
				for(int di =-1; di <= 1; ++di) for(int dj =-1; dj <= 1; ++dj)
					if(inrange(x[k]+di, y[k]+dj))
						if(!block[x[k]+di][y[k]+dj])
							block[x[k]+di][y[k]+dj] =1, --cnt;
			}
		for(int i =0; i <= cnt; ++i)
			if(dp[i][s]){/*对于 i < |s| 不会有贡献*/
				dp[i+1][s] =(dp[i+1][s]+dp[i][s]*(cnt-i))%M;
				for(int k =0; k < cntX; ++k){
					if(!(s&(1<<k)))
						dp[i+1][s|(1<<k)] =(dp[i+1][s|(1<<k)]+dp[i][s])%M;
				}
			}
	}
	return dp[n*m][(1<<cntX)-1];
}

void dfs(int nx, int ny, int k){
	if(nx >= n){
		ans =(ans+calc()*k+M)%M;
		return;
	}
	int netx, nety;
	if(ny+1 >= m) netx =nx+1, nety =0;
	else netx =nx, nety =ny+1;
	/*dfs 枚举*/
	dfs(netx, nety, k);
	if(!map[nx][ny]){
		bool flg =1;
		for(int di =-1; di <= 1; ++di) for(int dj =-1; dj <= 1; ++dj){
			if((di != 0 || dj != 0) && inrange(nx+di, ny+dj)) if(map[nx+di][ny+dj])
				flg =0;
		}
		if(flg){
			map[nx][ny] =1;
			dfs(netx, nety, -k);
			map[nx][ny] =0;
		}
	}
}

int main(){
	scanf("%d%d", &n, &m);
	for(int i =0; i < n; ++i){
		char s[10]; scanf("%s", s);
		for(int j =0; j < m; ++j) if(s[j] == 'X') map[i][j] =1;
	}
	/*非法情况必须要特判（思考下算法含义）*/
	for(int i =0; i < n; ++i) for(int j =0; j < m; ++j)
		if(map[i][j]){
			for(int di =-1; di <= 1; ++di) for(int dj =-1; dj <= 1; ++dj){
				if((di != 0 || dj != 0) && inrange(i+di, j+dj)) if(map[i+di][j+dj])
					return putchar('0') && 0;
			}
		}
	dfs(0, 0, 1);
	printf("%lld", ans);
}
```


---

## 作者：Soulist (赞：8)


对恰好容斥，现在问题变成对一个局面统计这些位置至少为 $X$ 的方案数之和。

根据题意限制可能出现局面不会太多（不能相邻均为 $X$）最后搜出来大概是 6W 个，考虑暴力。

首先可以根据偏序关系建一张 DAG，问题等价于求其所有可能的 top 序的数量。

朴素处理是 $\mathcal O(2^{NM}(NM))$，考虑优化，我们发现有出度的点只有 $X$ 所在的位置，他们会向一些节点连边，于是点 $x$ 能被选当且仅当覆盖他的节点均被选中。

可以注意到 $X$ 的数量不超过 $8$，一个暴力是枚举 $X$ 之间的大小关系，然后考虑外部元素如何放入进去，这个问题可以转换为排列计数的类型，从前往后维护序列长度，维护 $f_{i,j}$ 表示考虑到第 $i$ 个，当前剩余 $j$ 个元素在结尾处的方案数，插入新元素时枚举其插入的位置，预处理其可以额外附带的可插入的节点数，可以 $\mathcal O(|X|!\cdot |X|^2)$ 的解决此问题。

进一步优化是通过状压 dp，处理，瓶颈在于求对于一个状态 $S$ 加入元素 $u$ 之后，额外附带的元素数量（或者说 DAG 上没有被点覆盖的点），可以使用枚举子集做到 $\mathcal O(3^{|X|})$，也可以利用高维前缀和做到 $\mathcal O(2^{|X|}|X|)$

最后，可以在 $\mathcal O(\sum 3^{|X|}+\sum 2^{|X|}|X|(NM))$ 的复杂度解决此问题。实际搜出来大概是 $2\cdot 10^7$ 左右？跑得挺快的。

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ; 
#define re register
#define rep(i, s, t) for(register int i = (s); i <= (t); ++ i)
#define il inline
#define vi vector<int>
#define int long long
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ; 
	while( cc > '9' || cc < '0' ) { if(cc == '-') flus = -flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' ) cn = cn * 10 + cc - '0', cc = getchar() ; 
	return cn * flus ; 
}
const int P = 12345678 ; 
const int N = 55 ; 
const int M = (1 << 9) + 5 ; 
char s[N] ; 
int n, m, Ans, D, C[N][N], a[N][N], b[N][N], A[N], g[N] ; 
int dp[M][N], Id[N][N], w[M], fac[N] ; 
void inc(int &x, int y) {
	x += y ; x %= P ; 
}
void check() {
	int num = 0 ; 
	rep( i, 0, n + 1 ) rep( j, 0, m + 1 ) Id[i][j] = b[i][j] = 0 ;
	rep( i, 1, n ) rep( j, 1, m ) 
	if(g[i] & (1 << (j - 1))) b[i][j] = 1, ++ num, Id[i][j] = num ; 
	rep( i, 1, n ) rep( j, 1, m ) {
		if(b[i][j]) continue ;
		int u = 0 ; 
		rep( dx, -1, 1 ) rep( dy, -1, 1 ) {
			int x = i + dx, y = j + dy ; 
			if(b[x][y]) u |= (1 << (Id[x][y] - 1)) ;
		} ++ w[u] ;
	}
	int bf = w[0], limit = (1 << num) - 1, ans = 0, L = n * m ; 
	dp[0][bf] = fac[bf] ;
	for(re int S = 0; S < limit; ++ S) {
		for(re int j = 1; j <= num; ++ j) {
			if((S & (1 << (j - 1)))) continue ; 
			int tS = (S | (1 << (j - 1))) ;
			int len = w[1 << (j - 1)], z = 0 ; 
			for(re int k = S; k; k = (k - 1) & S) len += w[k | (1 << (j - 1))] ; 
			z = fac[len] ; int F = 0 ; 
			for(re int k = L; k >= 0; -- k) 
			F = (F + dp[S][k]) % P, inc( dp[tS][k + len], F * z % P * C[k + len][len] % P ) ; 
		}
		rep( j, 0, L ) dp[S][j] = 0 ; 
	}
	rep( i, 0, L ) ans = (ans + dp[limit][i]) % P, dp[limit][i] = 0 ; 
	if((D - num) & 1) Ans = (Ans - ans + P) % P ; 
	else Ans = (Ans + ans) % P ; 
	rep( i, 0, limit ) w[i] = 0 ;
}
void Dfs(int x, int bef) {
	if(x == n + 1) { check() ; return ; }
	int lim = (1 << m) - 1 ; 
	for(re int j = 0; j <= lim; ++ j) {
		if((j & A[x]) != A[x]) continue ; 
		if((j & (j << 1)) || (j & (j >> 1))) continue ; 
		if((j & bef) || ((j << 1) & bef) || ((j >> 1) & bef)) continue ; 
		g[x] = j, Dfs(x + 1, j) ; 
	}
}
void solve() {
	n = gi(), m = gi(), Ans = D = 0 ; 
	rep( i, 1, n ) {
		scanf("%s", s + 1) ; A[i] = 0 ; 
		rep( j, 1, m ) a[i][j] = (s[j] == 'X'), D += a[i][j] ;
		rep( j, 1, m ) A[i] |= (1 << (j - 1)) * a[i][j] ; 
	}
	if(D) Dfs(1, 0) ; 
	cout << Ans << endl ; 
	memset(w, 0, sizeof(w)), memset( Id, 0, sizeof(Id) ) ;  
}
void init() {
	int lim = 50 ; C[0][0] = 1, fac[0] = 1 ; 
	rep( i, 1, lim ) rep( j, 0, i ) 
	C[i][j] = (!j) ? 1 : (C[i - 1][j] + C[i - 1][j - 1]) % P ;  
	rep( i, 1, lim ) fac[i] = fac[i - 1] * i % P ;
}
signed main() { 
	init(), solve() ; 
	return 0 ; 
} 
```

---

## 作者：zzw4257 (赞：7)

整体上是两句话
- 每个关键点比其临集点先选
- 每个非关键点不比其临集点后选


## Part1

设关键点集合为$S$

答案就是求$f(S)$**恰好**只有$S$集合比其临集点先选

再设$g(S)$**至少**有$S$集合比其临集点先选

$f(S)=\sum\limits_{S\subseteq T}(-1)^{|T|-|S|}g(T)$

你整体上做一个容斥，枚举非关键点的选择情况即$T\oplus S$,求出$g(T)$

## Part2

做dp的整体思路是按照数的大小从小到大放，假设已经放的关键点集合是$S$,设$g_{i,S}$表示放了$[1,i]$这些数，关键点集合为$S$

对已经定的$S$，我们先预处理出对其每个子集$S'$的$h(S')$表示**邻集不包含除了这个子集外任何其他关键点的非关键点个数**

则我们以关键点集合为分层做层间和层内dp

- $f_{i-1,S}\cdot \max\{h(S)-i+1,0\}\to f_{i,S}$
- $f_{i-1,S}\to f_{i,S\oplus sta_j}$



```cpp
#include<bits/stdc++.h>
#define mod 12345678
using namespace std;
int n,m,ans,cnt,g[1<<9],f[29][1<<9],dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1};
char s[5][8];
struct Node{int x,y;}p[10];
inline int DP(void){
	int i,j,k,d,flag;
	for(cnt=0,i=1;i<=n;++i)
		for(j=1;j<=m;++j)if(s[i][j]=='X')p[++cnt]={i,j};
	for(i=0;i<1<<cnt;++i){
		for(j=1;j<=cnt;++j)s[p[j].x][p[j].y]=((i>>(j-1))&1)?'.':'X'; 
		for(g[i]=0,j=1;j<=n;++j)
			for(k=1;k<=m;++k)if(s[j][k]=='.'){
				for(flag=1,d=0;d<8;++d)if(s[j+dx[d]][k+dy[d]]=='X'){flag=0;break;}
				g[i]+=flag;
			}
	}for(i=1;i<=cnt;++i)s[p[i].x][p[i].y]='X'; 
	for(f[0][0]=i=1;i<=n*m;++i)
		for(j=0;j<1<<cnt;++j){
			for(f[i][j]=1ll*f[i-1][j]*max(0,g[j]-i+1)%mod,k=1;k<=cnt;++k)if((j>>(k-1))&1)f[i][j]=(f[i][j]+f[i-1][j-(1<<(k-1))])%mod;
		}
	
	return f[n*m][(1<<cnt)-1];
}
inline void dfs(int x,int y,int dlt){
	int tx,ty,i;
	if(x>n)return void(ans=(ans+1ll*dlt*DP())%mod);
	if(y==m)tx=x+1,ty=1;else tx=x,ty=y+1;
	dfs(tx,ty,dlt);if(s[x][y]=='.'){for(i=0;i<8;++i)if(s[x+dx[i]][y+dy[i]]=='X')return ;s[x][y]='X',dfs(tx,ty,mod-dlt),s[x][y]='.';}
}
signed main(void){
	int i;scanf("%d%d",&n,&m);
	for(i=1;i<=n;++i)scanf("%s",s[i]+1);
	printf("%d\n",(dfs(1,1,1),ans));
	return 0;
}
```

---

## 作者：Xiaojian_xiang (赞：5)

首先对于这个题目==

会发现矩阵中最多有8个X 不然一定不是一个合法的矩阵

然后我们就可以对这8个X进行状压

如果按照1-n\*m从小到大的顺序往里面填数字的话 一个X周围的格是一定不会比他先填好的

于是就看一下在当前状态下这个数字不填到X格子有多少种方法 cnt[s]

还有上一个填在X的格子是一定合法的

于是就有了方程：

#### f[i][j]=f[i-1][j]\*(cnt[j]-i+1)+sigma[0-p((1<<p)&j)](f[i-1][j-(1<<p)]


```cpp
#include<bits/stdc++.h>
using namespace std;
const int MOD=12345678;
int n,m,x[9],y[9],top,cnt[1<<9];
long long f[30][1<<9];
long long ans;
bool mm[6][9],wtm[6][9];
int dx[]={0,1,0,-1,1,-1,1,-1};
int dy[]={1,0,-1,0,1,-1,-1,1};
int dp(){
    top=0;int s;memset(cnt,0,sizeof(cnt));
    memset(f,0,sizeof(f));
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            if(mm[i][j]){
                x[++top]=i;y[top]=j;
            }
    s=1<<top;
    for(int i=0;i<s;i++){
        memset(wtm,0,sizeof(wtm));
        for(int j=0;j<top;j++){
            if(!((1<<j)&i)){
                for(int k=0;k<8;k++){
                    int xx=x[j+1]+dx[k];
                    int yy=y[j+1]+dy[k];
                    if(xx<0||yy<0||xx>=n||yy>=m) continue;
                    wtm[xx][yy]=1;
                }
                wtm[x[j+1]][y[j+1]]=1;
            }
        }
        for(int ni=0;ni<n;ni++)
            for(int nj=0;nj<m;nj++) cnt[i]+=!(wtm[ni][nj]);
    }
     f[0][0]=1;
    for(int i=1;i<=n*m;i++)
        for(int j=0;j<s;j++){
            f[i][j]+=(f[i-1][j]*(cnt[j]-i+1))%MOD;
            f[i][j]%=MOD;
            for(int p=0;p<top;p++){
                if(!((1<<p)&j)) continue;
                f[i][j]+=f[i-1][j-(1<<p)];
                f[i][j]%=MOD;
            }
        }
    return f[n*m][s-1];
}
void dfs(int nx,int ny,int z){
    if(ny==m){dfs(nx+1,0,z);return;}
    if(nx==n){
        ans+=dp()*z;
        ans%=MOD;
        return;
    }//Judge that the spot can be X or not Just Judge its round
    dfs(nx,ny+1,z);
    int judge(1);
    for(int i=0;i<8;i++){
        int xx=nx+dx[i];
        int yy=ny+dy[i];
        if(xx<0||yy<0||xx>=n||yy>=m) continue;
        if(mm[xx][yy]) {judge=0;break;}
    }
    if(mm[nx][ny]) judge=0;
    if(judge){mm[nx][ny]=1;dfs(nx,ny+1,z*(-1));mm[nx][ny]=0;}
}
void input(){
    cin>>n>>m;
    cin.get();
    for(int i=0;i<n;i++){
        char c[10];
        scanf("%s",c);
        for(int j=0;j<m;j++){
            if(c[j]=='X') mm[i][j]=1;
            else mm[i][j]=0;
        }
    }
}
void xxj(){
    dfs(0,0,1);
}
void output(){
    cout<<(ans+12*MOD)%MOD<<endl;
}
int main(){
    input();
    xxj();
    output();
    return 0;
}
```

---


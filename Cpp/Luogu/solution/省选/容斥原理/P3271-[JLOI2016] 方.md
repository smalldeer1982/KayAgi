# [JLOI2016] 方

## 题目描述

上帝说，不要圆，要方，于是便有了这道题。

由于我们应该方，而且最好能够尽量方，所以上帝派我们来找正方形上帝把我们派到了一个有 $N$ 行 $M$ 列的方格图上，图上一共有 $(N+1)\times(M+1)$ 个格点，我们需要做的就是找出这些格点形成了多少个正方形（换句话说，正方形的四个顶点都是格点）。

但是这个问题对于我们来说太难了，因为点数太多了，所以上帝删掉了这 $(N+1)\times(M+1)$ 中的 $K$ 个点。既然点变少了，问题也就变简单了，那么这个时候这些格点组成了多少个正方形呢？


## 样例 #1

### 输入

```
2 2 4
1 0
1 2
0 1
2 1```

### 输出

```
1```

# 题解

## 作者：cmd2001 (赞：19)

这题让我爆肝啦......

这种计数显然容斥，正好不含任何坏点的我们不会算，但是我们能算至少含零个坏点的，至少含一个坏点的，至少含两个坏点的......

所以最终的答案就是(至少含零个坏点的-至少含一个坏点的+至少含两个坏点的-至少含三个坏点的+至少含四个坏点的)。

然后就是怎么计算的问题。

对于至少含零个坏点的，我们不妨设定所有点都是好点。

对于非正放的正方形，我们能找到一个正好包含它的最小的正放的正方形，显然这样的正方形是唯一的。

![](https://cdn.luogu.com.cn/upload/pic/17462.png)

然后我们让四个点在这个正方形的边上滑动，显然这四个点的每一组位置对应一个非正放的正方形(虽然正好在四个角上的是正放的)。

于是我们可以得出总方案数为sigma( i from 1 to min(n,m) ) i \* ( n - i + 1 ) * ( m - i + 1 ) 。

这个东西可以O(n)计算。


对于正好有一个坏点的，我们考虑某个以某个个点P为角的正方形A，点P一定包含这个正方形A的最小正放正方形的角上或边上。

![](https://cdn.luogu.com.cn/upload/pic/17463.png)

于是我们枚举这样的正方形和点P能在的位置数量就好了。

对于点P的状态，我们计算出它距离左边界的距离l，右边界距离r，上边界距离h。
然后我们令t=min(l+r,h)。

![](https://cdn.luogu.com.cn/upload/pic/17464.png)

如果我们不考虑有一些位置不能取到的话，答案应该为t*(t+3)/2。

然而这样计算了一些不能取到的位置。当t>l时，我们多计算的位置数量为(t-l)*(t-l+1)/2。(手玩一下就明白了)

t>r时同理。这样我们就能O(k)计算出至少含一个坏点的方案数。

对于正好含两及以上个坏点的，我们枚举两个坏点，显然一个正方形给你两个点，他的位置就基本确定了。

![](https://cdn.luogu.com.cn/upload/pic/17465.png)

我们可以分类讨论三种情况，用向量计算出另外两个点应该在的位置。注意某些情况下以这两个点为对角线的正方形可能不在格点上。

然后对于含两个的，我们直接计算可行的正方形数；对于含三个的，我们当另外两个点有一个为坏点时计算；含四个的，我们当另外两个点均为坏点时计算。

显然含三个和含四个的我们算重了。所以应该分别除以C(3,2)和C(4,2)。

然后累加一下答案就好。
(然而计算垂直向量时没有加负号让我调了半天，老年选手身败名裂)
代码:
```cpp
#include<cstdio>
#include<algorithm>
#include<tr1/unordered_set>
typedef long long int lli;
using namespace std;
using namespace tr1;
const int maxp=2e3+1e2;
const int mod=1e8+7;

struct Point {
    int x,y;
    friend bool operator < (const Point &a,const Point &b) {
        return a.x != b.x ? a.x < b.x : a.y < b.y;
    }
    friend Point operator - (const Point &a,const Point &b) {
        return (Point){a.x-b.x,a.y-b.y};
    }
    friend Point operator + (const Point &a,const Point &b) {
        return (Point){a.x+b.x,a.y+b.y};
    }
    friend Point operator * (const Point &a,const int &b) {
        return (Point){a.x*b,a.y*b};
    }
    friend Point operator / (const Point &a,const int &b) {
        return (Point){a.x/b,a.y/b};
    }
    inline Point swp() const {
        return (Point){y,-x};
    }
    inline bool candiv() const {
        return ( ! ( x & 1 ) ) && ( ! ( y & 1 ) );
    }
}pt[maxp];
unordered_set<lli> st;
int n,m,t;
lli ans,ini,sig,dou,tri,qua;

inline void insert(const Point &p) {
    lli h = (lli) p.x * ( m + 1 ) + p.y;
    st.insert(h);
}
inline bool inside(const Point &p) {
    return 0 <= p.x && p.x <= n && 0 <= p.y && p.y <= m;
}
inline bool legal(const Point &pa,const Point &pb) {
    return inside(pa) && inside(pb);
}
inline bool have(const Point &p) {
    lli h = (lli) p.x * ( m + 1 ) + p.y;
    return st.find(h) != st.end();
}
inline lli calcini(lli n,lli m) {
    lli ret = 0 , lim = min( n , m );
    for(lli i=1;i<=lim;i++) ret = ( ret + ( n - i + 1 ) % mod * ( m - i + 1 ) % mod * i % mod ) % mod;
    return ret;
}
inline lli calcedge(const lli &l,const lli &r,const lli &h) {
    lli t = min( l + r , h );
    if( !t ) return 0;
    lli ret = ( t * ( t + 3 ) >> 1 ) % mod;
    if( t > l ) ret -= ( ( t - l ) * ( t - l + 1 ) >> 1 ) % mod;
    if( t > r ) ret -= ( ( t - r ) * ( t - r + 1 ) >> 1 ) % mod;
    return ( ret % mod + mod ) % mod;
}
inline lli calcsingle(lli x,lli y) {
    const lli a = n - x , b = m - y , c = x , d = y;
    lli ret = ( calcedge(d,b,a) + calcedge(d,b,c) + calcedge(a,c,b) + calcedge(a,c,d) ) % mod;
    ret -= ( min(a,b) + min(b,c) + min(c,d) + min(d,a) ) % mod;
    return ( ret % mod + mod ) % mod;
}
inline lli calcdouble(const Point &a,const Point &b) {
    const Point delta = (a-b).swp();
    int ret = legal(a+delta,b+delta) + legal(a-delta,b-delta);
    const Point mid = a + b , pa = mid + delta , pb = mid - delta;
    if( pa.candiv() && pb.candiv() && legal(pa/2,pb/2) ) ++ret;
    return ret;
}
inline lli calctriple(const Point &a,const Point &b) {
    const Point delta = (a-b).swp();
    int ret = 0;
    if( legal(a+delta,b+delta) ) ret += have(a+delta) + have(b+delta);
    if( legal(a-delta,b-delta) ) ret += have(a-delta) + have(b-delta);
    const Point mid = a + b , pa = mid + delta , pb = mid - delta;
    if( pa.candiv() && pb.candiv() && legal(pa/2,pb/2) ) ret += have(pa/2) + have(pb/2);
    return ret;
}
inline lli calcquad(const Point &a,const Point &b) {
    const Point delta = (a-b).swp();
    int ret = 0;
    if( legal(a+delta,b+delta) ) ret += ( have(a+delta) && have(b+delta) );
    if( legal(a-delta,b-delta) ) ret += ( have(a-delta) && have(b-delta) );
    const Point mid = a + b , pa = mid + delta , pb = mid - delta;
    if( pa.candiv() && pb.candiv() && legal(pa/2,pb/2) ) ret += ( have(pa/2) && have(pb/2) );
    return ret;
}

int main() {
    scanf("%d%d%d",&n,&m,&t);
    for(int i=1;i<=t;i++) scanf("%d%d",&pt[i].x,&pt[i].y) , insert(pt[i]);
    ini = calcini(n,m);
    for(int i=1;i<=t;i++) sig += calcsingle(pt[i].x,pt[i].y);
    for(int i=1;i<=t;i++) for(int j=i+1;j<=t;j++) {
        dou += calcdouble(pt[i],pt[j]) , tri += calctriple(pt[i],pt[j]) , qua += calcquad(pt[i],pt[j]);
    }
    tri /= 3 , qua /= 6;
    ans = ( ( ini - sig + dou - tri + qua ) % mod + mod ) % mod;
    printf("%lld\n",ans);
    return 0;
}

```

---

## 作者：Booksnow (赞：3)

# 方

[传送门](https://www.cnblogs.com/Defoliation-ldlh/p/15253088.html)

## 题目大意

给出一个 $n$ 行 $m$ 列的矩阵，每行的格点从上到下依次编号为 $0$ 到 $n$ ，每列的格点从左到右依次编号为 $0$ 到 $m$ 。

选出四个不同的格点，可以组成一个四边形，问有多少种不同的选法，能够组成一个正方形。

由于出题人太害怕你做出这道题，于是他从这个矩阵中删去了 $k$ 个点，这 $k$ 点将不能被选择。

## 分析

### 容斥

首先，必须注意此处的正方形可能是**斜着摆放**的。

然后我们可以考虑容斥。

若设 $f_i$ 表示至少有 $i$ 个顶点为坏点的正方形有多少种。

那么， $ans=f_0-f_1+f_2-f_3+f_4$ 。

### $f_0$

对于 $f_0$ 的情况，事实上，即是假设所有点都是好点的情况。

我们发现，对于正着摆放的正方形，事实上，我们是不难求解的。看起来比较难处理的是斜着摆放的正方形，我们可以把它画出来。

![](https://www.helloimg.com/images/2021/09/10/ClfMam.png)

我们发现，对于任何一个斜着摆放的正方形，我们都是能够画出一个正着摆放的正方形恰好把他框住，换句话来说，**对于任何一个正着摆放的正方形，我们都能够在它的内部画出若干个斜着摆放的正方形**。

那么我们就成功的把问题转化为了求解对于一个边长为 $x$ 的正着摆放的正方形，会产生多少的贡献。

仔细观察上图，我们发现，确定一条边，从上面的任意一个格点，我们都是能够唯一确认一个正方形，这不难理解，有点类似于里面的正方形缓慢旋转的过程，在这个过程中我们需要维持的是四个角落形成的三角形全等，则每次移动会带动另外一条边上的顶点移动，刚好能够移动 $x-1$ 次，再加上正着摆放的正方形本身，对于这样一个正方形，产生的贡献事实上就是 $x$ 。

运用我们成功得到的这个结论，则：

$$f_0=\sum_{i>=1}^{i<=min(n,m)} i\times (n-i+1)\times (m-i+1)$$

### $f_1$

接下来我们需要解决更复杂的正方形上至少有一个坏点的情况。

我们可以考虑枚举所有坏点 ，单独考虑每个坏点产生的贡献。

![](https://www.helloimg.com/images/2021/09/10/ClfTDc.png)

如图，我们从每个坏点建立一个坐标系。

首先，我们仍然先考虑这是一个正着摆放的正方形，则我们可以从这个坏点向四个方向分别延伸，变成逐渐扩大，最后得到的贡献不难求得。

那么对于斜着摆放的正方形了？上一个小问题中，我们知道了**对于一个边长为 $x$ 的正方形，从它边上的一个点出发，可以唯一确定一个正方形**。

则我们又成功的将问题转化为，求有多少个正着的正方形的边上，会存在这个坏点，产生的贡献即是这种正方形的个数，由于我们前面考虑了在正着摆放的正方形顶点上的情况，所以接下来不考虑这个坏点是正着摆放正方形的顶点。

![](https://www.helloimg.com/images/2021/09/10/ClfO4r.png)

(图中的线段表示枚举的正方形的边长)

接下来，我们逐步考虑边长的情况。

首先，不失一般性的假设，$x<y$ 。

显然，边长最小为 $2$ ，即线段 $1$ ，我们考虑将线段 $1$ 逐步延伸，发现没增加 $1$ ，对应的方案数也会增加 $1$ ，缓慢向上延伸，直到边长为 $x+1$ 时，方案数达到最大值，即我们的线段 $2$ 。

之后，我们每一次扩大边长，实际上线段 $2$ 能够向下移动的总步数也即是我们的总方案数不会变化进一步变化，始终维持在某个值上。

当达到 $y+2$ 时，再次出现变化，也即是我们的线段 $3$ 的下一次扩大，我们发现，这会让我们上移的步数也即是我们的方案数减少 $1$ ，这个变化将持续到 $x+y$ 也即是我们将整个正方形抵满。

我们的贡献最后其实形成了一个函数，大概长成这样：

![](https://www.helloimg.com/images/2021/09/10/Clfc0T.png)

第一段，如果能够完全取到，即为 $\frac{x\times(x+1)}{2}$ 。

第二段，如果能够完全取到，即为 $x\times(y-x)$ 。

第三段，如果能够完全取到，即为 $\frac{x\times (x-1)}{2}$ 。

注意这里说的是**完全取到**，什么时候不能完全取到，即不存在这个区间或者说目前取到的边长事实上已经超过了 $L$ 的时候我们不能将这个区间的贡献全部一股脑的弄上去。

综上，如果设我们上述的函数为 $Get(x,y,z)$ ，该坏点距离上边界的距离为 $u$ ，下边界的距离为 $d$ ，左边界的距离为 $l$ ，右边界的距离为 $r$ ，则：

$$f_1=min(u,r)+min(r,d)+min(d,l)+min(u,l)+Get(u,d,l)+Get(u,d,r)+Get(l,r,u)+Get(l,r,d)$$ 

### $f_2$ 

到这里我们终于可以开始求 $f_2$ 了。

首先，如果我们确定了两个坏点，事实上，我们就已经可以把这两个坏点能够形成的正方形给求解出来了。

具体如下图：

![](https://www.helloimg.com/images/2021/09/10/Clfdj1.png)

通过向量的知识或者其他的一些方法，我们能够求出其他两个点的坐标，这里就不再赘述了，属于是数学知识了。

求出另外两个点的坐标后，首先要注意这两个坐标可能不在格点上，对于这种我们是需要舍掉的。

然后再观察。

显然没有人想要再去求一下 $f_3$ ，$f_4$ ，有没有什么神奇的方法能把这两个东西删去。实际上是有的，我们可以手动给我们每个正方形的贡献加上一个系数。

具体可以举个例子说明。

假设，这个正方形上有三个坏点。

那其实，在 $f_0$ 中，它被计算了 $+1$ 次，在 $f_1$ 中，由于每一个坏点都要确定一次它，它被计算了 $-3$ 次，显然，我们期望 $f_2$ 中，让它被计算 $+2$ 次。

正好，我们是可以确定这个正方形的，换句话来说，我们能够确定这个正方形上的坏点个数，于是乎，我们能够“智能的”给他安排一个系数。

但是 $f_2$ 本身中也有可能是会重复的，就像 $f_1$ 一样，每两组会重复确定他一次，我们必须想办法规避这个问题，我们想到了给每个坏点打上一个编号，只要当这两个坏点确定出的正方形中，它们是编号最大的两个坏点时，我们才计算贡献，这样，我们就有效的规避了这个问题。

### 时间复杂度

求解 $f_0$ 与 $f_1$ 的时间复杂度都比较小，我们主要谈一谈求解 $f_2$ 时的一些问题。

如果用 $map$ 实现 $f_2$ 中的一些操作，显然我们求 $f_2$ 的复杂度是 $O(k^2logn)$ 的，看起来非常可过，但其实应该是过不了的(指洛谷)，当然如果你常数小肯定也能过。我们需要优化这个 $log$ ，要么用 $unorderedmap$ ，要么使用离散化，都可以去掉这个 $log$ 。

## CODE

```
#include <bits/stdc++.h>
#include <unordered_map>
#define int long long
using namespace std;
const int N=1e5+10,M=2e3+10,MOD=1e8+7;
namespace IO {
int len = 0;
char ibuf[(1 << 20) + 1], *iS, *iT, out[(1 << 25) + 1];
#define gh()                                                                   \
  (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, (1 << 20) + 1, stdin),         \
   (iS == iT ? EOF : *iS++) : *iS++)
inline int read() {
  char ch = gh();
  int x = 0;
  char t = 0;
  while (ch < '0' || ch > '9')
    t |= ch == '-', ch = gh();
  while (ch >= '0' && ch <= '9')
    x = x * 10 + (ch ^ 48), ch = gh();
  return t ? -x : x;
}
inline void putc(char ch) { out[len++] = ch; }
template <class T> inline void write(T x) {
  if (x < 0)
    putc('-'), x = -x;
  if (x > 9)
    write(x / 10);
  out[len++] = x % 10 + 48;
}
string getstr(void) {
  string s = "";
  char c = gh();
  while (c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == EOF)
    c = gh();
  while (!(c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == EOF))
    s.push_back(c), c = gh();
  return s;
}
void putstr(string str, int begin = 0, int end = -1) {
  if (end == -1)
    end = str.size();
  for (int i = begin; i < end; i++)
    putc(str[i]);
  return;
}
inline void flush() {
  fwrite(out, 1, len, stdout);
  len = 0;
}
} // namespace IO
using IO::flush;
using IO::getstr;
using IO::putc;
using IO::putstr;
using IO::read;
using IO::write;

struct node{
	int x,y;
}p[M];
struct pair_hash
{
    template<class T1, class T2>
    std::size_t operator() (const std::pair<T1, T2>& p) const
    {
        auto h1 = std::hash<T1>{}(p.first);
        auto h2 = std::hash<T2>{}(p.second);
        return h1 ^ h2;
    }
};

unordered_map<pair<int, int>, int, pair_hash> mp;
int n,m,k,cnt,ans;
inline bool cmp(node a,node b) { return a.y<b.y; }
inline int Get_val(int x,int y,int L)
{
	int res=0;
	if(x>y) swap(x,y);
//	if(2<=x+1){
		if(L<2) return 0;
		else if(L>x+1) res=(res+((x+1)*x)/2)%MOD;
		else return (L*(L-1))/2; //令x+1=L，则x=L-1
//	}
//	if(x+2<=y+1){
		if(L>y+1) res=(res+x*(y-x))%MOD; //超出，加贡献
		else return (res+(L-x-1)*x)%MOD; //令y+1=L
//	}
//	if(y+2<=x+y){
		if(L>x+y) return (res+(x*(x-1))/2)%MOD;
		else return (res+(2*x+y-L)*(L-y-1)/2)%MOD; //令x+y=L,则x=L-y
//	}
}
signed main()
{
//	while(1){
//		int x=read(),y=read(),z=read();
//		printf("%lld\n",Get_val(x,y,z));
//	}
	n=read(),m=read(),k=read();
	for(register int i=1;i<=k;i++){
		pair<int,int> add;
		p[i].x=read(),p[i].y=read();
		add.first=p[i].x,add.second=p[i].y;
		mp[add]=++cnt;
	}
	for(register int i=1;i<=min(n,m);i++) ans=(ans+i*(n-i+1)%MOD*(m-i+1)%MOD)%MOD;
	//sort(p+1,p+k+1,cmp);
	for(register int i=1;i<=k;i++){
		for(register int j=i+1;j<=k;j++){ //枚举正方形
			pair<int,int> a,b;
			a.first=p[i].x,a.second=p[i].y;
			b.first=p[j].x,b.second=p[j].y;
			//printf("%d %d %d %d\n",a.first,a.second,b.first,b.second);
			int v=min(mp[a],mp[b]);
			int temp,sum;
			int x1=p[i].y,y1=n-p[i].x,x2=p[j].y,y2=n-p[j].x;
			//printf("%d %d %d %d\n",x1,y1,x2,y2);
			int ny=x2-x1,nx=abs(y2-y1);
			//printf("%d %d\n",nx,ny);
			if(y2>y1) ny*=-1;
			pair<int,int> p1,p2;
			//第一个正方形的两个新点
			p1.first=n-(ny+y1),p1.second=nx+x1;
			p2.first=n-(ny+y2),p2.second=nx+x2;
			//printf("%d %d %d %d\n",p1.first,p1.second,p2.first,p2.second);
			if(p1.first>=0&&p1.second>=0&&p1.first<=n&&p1.second<=m){
				if(p2.first>=0&&p2.second>=0&&p2.first<=n&&p2.second<=m){
					temp=0,sum=0;
					if(mp.find(p1)!=mp.end()) temp=max(mp[p1],temp),++sum;
					if(mp.find(p2)!=mp.end()) temp=max(mp[p2],temp),++sum;
					if(v>temp) ans=(ans+sum+1)%MOD;
				}
			}
			//第二个正方形的两个新点
			nx=-nx,ny=-ny;
			p1.first=n-(ny+y1),p1.second=nx+x1;
			p2.first=n-(ny+y2),p2.second=nx+x2;
			if(p1.first>=0&&p1.second>=0&&p1.first<=n&&p1.second<=m){
				if(p2.first>=0&&p2.second>=0&&p2.first<=n&&p2.second<=m){
					temp=0,sum=0;
					if(mp.find(p1)!=mp.end()) temp=max(mp[p1],temp),++sum;
					if(mp.find(p2)!=mp.end()) temp=max(mp[p2],temp),++sum;
					if(v>temp) ans=(ans+sum+1)%MOD;
				}
			}
			//第三个正方形的两个新点
			//if((x2-x1)*(y2-y1)==0) continue; //
			nx=-nx,ny=-ny;
			double dx=((x2-x1)/2.0-nx/2.0),dy=((y2-y1)/2.0-ny/2.0);
			if((double)(dx-(int)dx)||(double(dy-(int)dy))) continue; //该正方形不存在
			p1.first=n-(ny+dy+y1),p1.second=nx+dx+x1;
			p2.first=n-(dy+y1),p2.second=dx+x1;
			if(p1.first>=0&&p1.second>=0&&p1.first<=n&&p1.second<=m){
				if(p2.first>=0&&p2.second>=0&&p2.first<=n&&p2.second<=m){
					temp=0,sum=0;
					if(mp.find(p1)!=mp.end()) temp=max(mp[p1],temp),++sum;
					if(mp.find(p2)!=mp.end()) temp=max(mp[p2],temp),++sum;
					if(v>temp) ans=(ans+sum+1)%MOD;
				}
			}
		}
	}
	//cout<<ans<<"\n";
	for(register int i=1;i<=k;i++){
		int u,d,l,r;
		u=p[i].x,d=n-p[i].x,l=p[i].y,r=m-p[i].y;
		int temp=(min(u,r)+min(r,d)+min(d,l)+min(u,l))%MOD;
		ans=((ans-temp)%MOD+MOD)%MOD;
		ans=((ans-Get_val(u,d,l))%MOD+MOD)%MOD;
		ans=((ans-Get_val(u,d,r))%MOD+MOD)%MOD;
		ans=((ans-Get_val(l,r,u))%MOD+MOD)%MOD;
		ans=((ans-Get_val(l,r,d))%MOD+MOD)%MOD;
	}
	printf("%lld\n",ans);
	return 0;
}

```

---

## 作者：_Sein (赞：2)

我又TM没看题，题面只要求四个顶点不是坏点就好了(导致我纠结了1天)！！！

观察到$K$挺小的，就想办法搞些事情。

之后想到容斥，$f_i$表示至少有$i$个顶点是坏点。

答案就为$f_0-f_1+f_2-f_3+f_4$

对于同样大小的，且中心点为同一处的非横平竖直正方形而言，一定有一个最小的(横平竖直)正方形能包裹住这些正方形，且只有一个，如下图

![11.PNG][1]

对于这个最小的(横平竖直)正方形而言，内含其边长$l$$-1$个正方形，算上其本身，就有$l$个正方形。

思考一下，对于$(n+1,m+1)$的地图而言，有多少个这样的边长为$l$的中心点?

有$(n-l+1)*(m-l+1)$个。

因此对于边长为$l$的中心点的来说，对$f_0$的贡献为$(n-l+1)*(m-l+1)*l$

因此$f_0=\sum\limits _{i=1}^{\min(n,m)}(n-i+1)*(m-i+1)*i$

难点就在于如何计算$f_1$

考虑一个坏点$(x,y)$，大概是这样的:

![12.PNG][2]

蓝色区域就是$(n+1)*(m+1)$的地图， $P$为原点分成上、下、左、右四个半平面进行计算。

这里单独对于上平面进行计算

![13.PNG][3]

即$l$为$p$到左边界的距离，$r$为$p$到右边界的距离，$h$同理。

最大的正方形边长不超过$t=\min(l+r,h)$。

现在考虑以点$p$为顶点的正方形如何计算(这一部分是我曾经最不懂的地方，尽量给读者讲懂吧)。

对于非横平竖直的正方形如何转化?

![14.PNG][4]
还记得第一张图吗？对于这个正方形，可以套上一个最小的横平竖直的正方形来表示它，也就是这样：

![15.PNG][5]



关于这个的正确性，从第一张图可以明显得知，它是唯一的。

之后就是统计这些横平竖直的正方形有多少个。

如果不考虑限制的话。

答案就是$\sum\limits_{i=1}^{\min(l+r,h)}i+1=\frac{t*(t+3)}{2}$

减去不合法的，这里稍微解释一下，

对于$t>l$的部分，结合图来理解一下(这个图大的好像画错了，不过没关系)

![16.PNG][6]

大概可以糊出不合法的方案就是$\frac{(t-l)*(t-l+1)}{2}$

对于$r$也来一下。

统计完四个方向之后，发现真正的横平竖直(也就是以$p$为顶点，且边在格子上)的正方形会算重，所以要去重。

之后$f_2,f_3,f_4$差不多少一个套路，都是随便枚举两个坏点，判断是否合法，然后通过垂直向量算出剩下两点是否合法。

需要注意的就是枚举这两点连线是对角线还是边。

$f_3$，由于三个点，任意枚举两个点，会重复2次，因此$/3$

$f4$，同理，$/6$

$\operatorname{The ~End}$

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#define ll long long
#define gc getchar()
#define eps 1e-8
using namespace std;
const int M=570707,N=2005,mod=1e8+7;
const double pi=acos(-1);
template<class o>
inline void qr(o &x)
{
	x=0;char c=gc;int f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
template<class o>
void qw(o x)
{
	if(x<0)putchar('-'),x=-x;
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
int n,m,t;
struct Hashmap
{
	struct node{int x,y,next;}a[M<<1];int len,last[mod];
	void ins(int i,int j)
	{
		int x=1ll*i*(m+1)*j%M;
		for(int k=last[x];k;k=a[k].next)
			if(a[k].x==i&&a[k].y==j)return ;
		a[++len]=(node){i,j,last[x]};last[x]=len;
	}
	bool pd(int i,int j)
	{
		int x=1ll*i*(m+1)*j%M;
		if(!last[x])return 0;
		for(int k=last[x];k;k=a[k].next)
			if(a[k].x==i&&a[k].y==j)return 1;
		return 0;
	}
}H;
struct node
{
	int x,y;
	node(int x=0,int y=0):x(x),y(y){}
	bool operator <(const node a)const{return x==a.x?y<a.y:x<a.x;}
	node operator -(const node a)const{return node(x-a.x,y-a.y);}
	node operator +(const node a)const{return node(x+a.x,y+a.y);}
	node operator *(const int a)const{return node(x*a,y*a);}
	node operator /(const int a)const{return node(x/a,y/a);}
	inline node sap(){return node(y,-x);}
	inline bool even(){return (!(x&1))&&(!(y&1));}
}pt[N];
inline bool pdnode(node a){return 0<=a.x&&a.x<=n&&0<=a.y&&a.y<=m;}
bool legal(node a,node b){return pdnode(a)&&pdnode(b);}
bool broke(node a){return H.pd(a.x,a.y);}
inline ll calc0(int n,int m)
{
	ll sum=0;int lim=min(n,m);
	for(int i=1;i<=lim;i++)sum=(sum+1ll*i*(n-i+1)*(m-i+1))%mod;
	return sum;
}
inline ll calc(int l,int r,int h)
{
	ll t=min(l+r,h);
	if(!t)return 0;
	ll sum=t*(t+3)/2%mod;
	if(t>l)sum-=(t-l)*(t-l+1)/2%mod;
	if(t>r)sum-=(t-r)*(t-r+1)/2%mod;
	return (sum%mod+mod)%mod;
}
inline ll calc1(int x,int y)
{
	int a=n-x,b=m-y,c=x,d=y;
	ll sum=(calc(b,d,c)+calc(b,d,a)+calc(a,c,b)+calc(a,c,d))%mod;
	sum-=(min(a,b)+min(b,c)+min(c,d)+min(d,a));
	return (sum%mod+mod)%mod;
}
inline ll calc2(node a,node b)
{
	node tg=(a-b).sap();int sum=0;
	if(legal(a+tg,b+tg))sum++;
	if(legal(a-tg,b-tg))sum++;
	node mid=a+b,c=mid+tg,d=mid-tg;
	if(c.even()&&d.even()&&legal(c/2,d/2))sum++;
	return sum;
}
inline ll calc3(node a,node b)
{
	node tg=(a-b).sap();int sum=0;
	if(legal(a+tg,b+tg))sum+=broke(a+tg)+broke(b+tg);
	if(legal(a-tg,b-tg))sum+=broke(a-tg)+broke(b-tg);
	node mid=a+b,c=mid+tg,d=mid-tg;
	if(c.even()&&d.even()&&legal(c/2,d/2))sum+=broke(c/2)+broke(d/2);
	return sum;
}
inline ll calc4(node a,node b)
{
	node tg=(a-b).sap();int sum=0;
	if(legal(a+tg,b+tg))sum+=broke(a+tg)&&broke(b+tg);
	if(legal(a-tg,b-tg))sum+=broke(a-tg)&&broke(b-tg);
	node mid=a+b,c=mid+tg,d=mid-tg;
	if(c.even()&&d.even()&&legal(c/2,d/2))sum+=broke(c/2)&&broke(d/2);
	return sum;
}
int main()
{
	qr(n),qr(m),qr(t);
	for(int i=1;i<=t;i++)qr(pt[i].x),qr(pt[i].y),H.ins(pt[i].x,pt[i].y);
	ll f0=0,f1=0,f2=0,f3=0,f4=0;f0=calc0(n,m);
	for(int i=1;i<=t;i++)f1+=calc1(pt[i].x,pt[i].y);
	for(int i=1;i<=t;i++)for(int j=i+1;j<=t;j++)
	{
		f2+=calc2(pt[i],pt[j]),f3+=calc3(pt[i],pt[j]);f4+=calc4(pt[i],pt[j]);
	}
	f3/=3;f4/=6;
	ll ans=((f0-f1+f2-f3+f4)%mod+mod)%mod;
	qw(ans);puts("");
	return 0;
}
```


  [1]: http://lb2003.top/usr/uploads/2020/03/638081844.png
  [2]: http://lb2003.top/usr/uploads/2020/03/270779001.png
  [3]: http://lb2003.top/usr/uploads/2020/03/1943795974.png
  [4]: http://lb2003.top/usr/uploads/2020/03/189106856.png
  [5]: http://lb2003.top/usr/uploads/2020/03/2304423128.png
  [6]: http://lb2003.top/usr/uploads/2020/03/3303995261.png

---

## 作者：Illusory_dimes (赞：2)

（9.15 Update：把**至少一个点被删掉的数量**补充了一下，~~我是绝对不会告诉你我是因为懒才过了这么久才来修改的~~）

[并不会更好的阅读体验](https://www.cnblogs.com/Illusory-dimes/p/15253264.html)

（注：本题解废话有点多，希望能写的能通俗易懂点

## Description

在一个 $n$ 行 $m$ 列的方格图上，有 $k$ 个点被删掉了，问剩下的点能构成多少个三角形。

$0\leq n,\ m \leq 10^6$ ， $0\leq k \leq 2\cdot 10^3$

## Analysis

题意大概就是问由所有点构成的所有正方形中，

有多少个是其四个顶点都没被删掉的。

直接做似乎不太行，可以想想算答案的补集。

一个正方形的话，只要枚举两个点，就可以算得这两个点所在的唯三的正方形。

给个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/0fkbneiw.png)

所以算答案的补集的话，选择枚举被删掉了的点，复杂度上是非常合适的。

所以基本可以确定，答题思路应该跟 $O(k^2)$ 枚举有密切联系。

------------

现在再来看看补集要干什么。

无非就是一个点被删去的正方形，两个的，三个的以及四个的数量总和。

但是发现这个枚举枚举，不能做一个点的情况，如果要做的话好像也不太行。。

------------

再想想怎么避免掉。

其实这样直接求的话，本质上我们要考虑的地方除了枚举的点，还有其他三个点的情况。

所以我们可以考虑一个简单的容斥，把求的东西全部改成至少有（ 1-4 ）个点被删掉的正方形的数量。

这样求的时候，也只去大胆的枚举就行了。

看起来很可做的样子！

## Solution

### 至少零个点被删掉的正方形数量（总方案数）

直接算好像也不行，所以可以考虑一系列的正方形可能存在什么样的类似的特征。

比如斜着的正方形能“圈起来”。

给个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/il42udq8.png)

发现一个“圈”能圈住好多正方形，大小相同的正方形能圈住的数量又都是一样的。

所以枚举“圈”的大小 $O(\min(n, m))$ 就可以算了。

------------

### 至少一个点被删掉的正方形数量

因为只要找一个点，所以也只要枚举一个点就可以了。

对于每个被删去的点，以它为原点向四周找到一个新正方形对角线上的点，分成与该点同纵坐标或横坐标和其他点分类统计，然后加起来就是合法个数了。

注意下这个其他点中有斜的不太正常的那种（比如上图中紫色那个）。

这种情况是在对角线横纵坐标差同奇偶的时候。

因为只有这样另一条对角线才能稳稳的落在两个点上而不是悬在空中。

------------

来实操一下，分两种情况：

#### 1. 在该点上下左右的两条直线上

以下面半边为例，给个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ggkga23o.png)

可以看到，线上只有距点偶数距离的存在正方形。同时，绿色那个正方形，由于右边超出边界，也不合法。

类比此做法，可以把上下左右都搞定。

------------

#### 2. 其他

前面有给到一个合法正方形的条件，那么，

以左下角为例，再给个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/3iv2ihkq.png)

先抛开那些斜线不谈，圈起来的点就是所有能构成正方形的点们（粉紫色均为奇数，淡蓝色均为偶数）

全部把正方形复原出来后，会发现有些已经超出了边界，也就是不合法的了。

那么，什么情况下的点是不合法的呢？

------------

1.第一类是像最左下角的那个蓝点，复原出来的话下方的点显然是出了自家的大门。

如果左边还有点，对应的最下面的黄色的斜线上的点同样都不合法，所以这些不合法的点都被“绑定”到了一起。

------------

2.第二类同理，分两个方向，一个右下角，一个左上角，但此图两者都是压线，没有不合法的。

感性理解的话，还是一样，不合法的点都被“绑定”到了蓝色的斜线上。

于是，不合法的点“绑定”起来的话，也就更方便于计算。



------------


但是，同时我们还应该要想到这样会不会需要容斥，

如果两类不合法点有交集，那么就相当于这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/rzyj7zhb.png)

可以看到，点要出现在超出两个边界的两块紫色阴影才有可能出现同为两类不合法点的情况。

但是稍稍想一下，这里 $a^2+b^2=c^2$ ，但是我们复原出来的正方形边长也是 $p^2+p^2=c^2$ ，很显然是没有 $p>a$ 且 $p>b$ 的情况，也就不用想容斥了。

------------

### 至少二，三，四个点被删掉的正方形数量

先枚举，对于存在的三个正方形，要先判断这三个正方形合不合法，因为有可能有的正方形坐标不合法，或者，

再给个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/6fs78ypk.png)

这玩意显然不对呀！

排除掉不合法的正方形后就能直接算了。

但其实这样子的答案样例都过不了。。

所以还要再想想直接这样算对不对，

盯着这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/1uj760sk.png)

可以发现如果只有两个点被删掉了，那么枚举的时候，

会对至少两个的数量贡献 1 ，没有问题。

------------

如果是三个点的话，这个正方形会被枚举 $C_3^2 = 3$ 次，其中，

会对至少两个的数量贡献 3 ，没有问题。

会对至少三个的数量贡献 3 ，那一种方案被算了 3 次。

------------

如果是四个点的话，这个正方形会被枚举 $C_4^2 = 6$ 次，其中，

会对至少两个的数量贡献 6 ，没有问题。

会对至少三个的数量贡献 12 ，四种方案都被算了 3 次。

会对至少两个的数量贡献 6 ，那一种方案被算了 6 次。

------------

所以最后算出来的至少三个的数量除以 3 ，至少四个的数量除以 6 ，就算搞定整个题目了。

## Attention

存坐标是否被删去不能数组存，所以要开 map 或 set ！所以时间复杂度为 $O(k^2\log(nm))$ ，只有 50 分。

所以要用 unordered_map 或 unordered_set  ，时间复杂度 $O(k^2)$ ，就能拿到 100 啦。

## Code

```cpp
#include<bits/stdc++.h>
#define id(i, j) i * (m + 1) + j + 1
using namespace std;
typedef long long ll;
const int N = 1e6 + 10, M = 2e3 + 10;
const ll mod = 1e8 + 7;
ll n, m, k, zer, sig, dou, tri, qua, ans;
struct mdzz {
	ll u, v;
} p[N];
unordered_set<ll> vis;
inline ll read() {
	ll s = 0, w = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {if (ch == '-') w = -1; ch = getchar();}
	while (ch >= '0' && ch <= '9') {s = (s << 3) + (s << 1) + ch - '0'; ch = getchar();}
	return s * w;
}
inline int mul(int a, int b) {
	return (1ll * a * b) % mod;
}
inline int pd(ll zb) {
	return vis.find(zb) != vis.end();
}
inline void ans_zero() {
	int lim = min(n, m);
	for (int i = 1; i <= lim; ++i) {
		zer = (zer + mul(i, mul(n - i + 1, m - i + 1))) % mod;
	}
}
inline int anslrh(int l ,int r, int h) {
	int t = min(l + r, h);
	if (!t) return 0;
	int ret = (1ll * t * (t + 3) >> 1ll) % mod;
	if (t > l) ret = (ret - (1ll * (t - l) * (t - l + 1) >> 1) % mod + mod);
	if (t > r) ret = (ret - (1ll * (t - r) * (t - r + 1) >> 1) % mod + mod);
	return ret % mod;
}
inline void ans_single(mdzz x) {
	int a = x.u, b = x.v, c = n - x.u, d = m - x.v;
	sig += (anslrh(a, c, b) + anslrh(a, c, d)) % mod;
	sig += (anslrh(b, d, a) + anslrh(b, d, c)) % mod;
	sig = (sig - (min(a, b) + min(b, c) + min(c, d) + min(d, a)) % mod) % mod;
}
inline int check_double(mdzz x, mdzz y) {
	if (x.u < 0 || y.u < 0 || x.v < 0 || y.v < 0) return 0;
	if (x.u > n || y.u > n || x.v > m || y.v > m) return 0;
	return 1;
}
inline void ans_double(mdzz x, mdzz y) {
	int d1 = y.u - x.u, d2 = x.v - y.v;
	mdzz a1 = x, b1 = y; a1.u += d2; a1.v += d1; b1.u += d2; b1.v += d1;
	mdzz a2 = x, b2 = y; a2.u -= d2; a2.v -= d1; b2.u -= d2; b2.v -= d1;
	dou += check_double(a1, b1) + check_double(a2, b2);
	int d3 = (x.u + y.u), d4 = (x.v + y.v);
	mdzz mid = (mdzz) {d3, d4};
	mdzz a3 = mid, b3 = mid; a3.u += d2; a3.v += d1; b3.u -= d2; b3.v -= d1;
	if ((a3.u & 1) || (a3.v & 1)) return ; 
	if ((b3.u & 1) || (b3.v & 1)) return ; 
	a3.u /= 2; a3.v /= 2; b3.u /= 2; b3.v /= 2;
	dou += check_double(a3, b3);
}
inline int check_triple(mdzz x, mdzz y) {
	if (x.u < 0 || y.u < 0 || x.v < 0 || y.v < 0) return 0;
	if (x.u > n || y.u > n || x.v > m || y.v > m) return 0;
	return pd(id(x.u, x.v)) + pd(id(y.u, y.v));
}
inline void ans_triple(mdzz x, mdzz y) {
	int d1 = y.u - x.u, d2 = x.v - y.v;
	mdzz a1 = x, b1 = y; a1.u += d2; a1.v += d1; b1.u += d2; b1.v += d1;
	mdzz a2 = x, b2 = y; a2.u -= d2; a2.v -= d1; b2.u -= d2; b2.v -= d1;
	tri += check_triple(a1, b1) + check_triple(a2, b2);
	int d3 = (x.u + y.u), d4 = (x.v + y.v);
	mdzz mid = (mdzz) {d3, d4};
	mdzz a3 = mid, b3 = mid; a3.u += d2; a3.v += d1; b3.u -= d2; b3.v -= d1;
	if ((a3.u & 1) || (a3.v & 1)) return ; 
	if ((b3.u & 1) || (b3.v & 1)) return ; 
	a3.u /= 2; a3.v /= 2; b3.u /= 2; b3.v /= 2;
	tri += check_triple(a3, b3);
}
inline int check_quadruple(mdzz x, mdzz y) {
	if (x.u < 0 || y.u < 0 || x.v < 0 || y.v < 0) return 0;
	if (x.u > n || y.u > n || x.v > m || y.v > m) return 0;
	return pd(id(x.u, x.v)) & pd(id(y.u, y.v));
}
inline void ans_quadruple(mdzz x, mdzz y) {
	int d1 = y.u - x.u, d2 = x.v - y.v;
	mdzz a1 = x, b1 = y; a1.u += d2; a1.v += d1; b1.u += d2; b1.v += d1;
	mdzz a2 = x, b2 = y; a2.u -= d2; a2.v -= d1; b2.u -= d2; b2.v -= d1;
	qua += check_quadruple(a1, b1) + check_quadruple(a2, b2);
	int d3 = (x.u + y.u), d4 = (x.v + y.v);
	mdzz mid = (mdzz) {d3, d4};
	mdzz a3 = mid, b3 = mid; a3.u += d2; a3.v += d1; b3.u -= d2; b3.v -= d1;
	if ((a3.u & 1) || (a3.v & 1)) return ; 
	if ((b3.u & 1) || (b3.v & 1)) return ; 
	a3.u /= 2; a3.v /= 2; b3.u /= 2; b3.v /= 2;
	qua += check_quadruple(a3, b3);
}
int main() {
//	freopen("square.in", "r", stdin);
//	freopen("sqyare.out", "w", stdout);
	n = read(); m = read(); k = read();
	for (int i = 1; i <= k; ++i) {
		int u = read(), v = read();
		p[i] = (mdzz) {u, v};
		vis.insert(id(u, v));
	}
	ans_zero();
	for (int i = 1; i <= k; ++i) {
		ans_single(p[i]);
		for (int j = i + 1; j <= k; ++j) {
			ans_double(p[i], p[j]);
			ans_triple(p[i], p[j]);
			ans_quadruple(p[i], p[j]);
		}
	}
	tri /=3; qua /= 6;
	dou %= mod; tri %= mod; qua %= mod;
	printf("%lld\n", (zer - sig + dou - tri + qua + mod + mod) % mod);
	return 0;
}
```

---

## 作者：破壁人五号 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P3271)

## 题意
- 一个 $N\times M$ 的网格，由小正方形铺成；
  - 显然它有 $(N+1)\times (M+1)$ 个格点；
- 其中 $K$ 个格点不允许成为正方形顶点（之后将这 $K$ 个格点称为“坏点”）；
- 问有多少个格点正方形。

> 既然点变少了，问题也就变简单了。

## 题解
考虑使用容斥：求出至少含 $0$ 个坏点、至少含 $1$ 个坏点、……、至少含 $4$ 个坏点的正方形数量，为了表达方便，我们分别称之为 $f(0),f(1),\dots,f(4)$。

更准确地说，应该是“已经确定 0 个坏点”、“已经确定 1 个坏点”……即：以 $f(1)$ 为例，我们枚举每一个坏点，并统计把这个坏点作为顶点的正方形数量。

如样例一中，$f(0)=6$, $f(1)=12$, $f(2)=10$, $f(3)=4$, $f(4)=1$。

答案即为 $f(0)-f(1)+f(2)-f(3)+f(4)$。

依次考虑计算每个 $f(x)$ 的方式：

**$f(0)$**：对于每个正方形（无论是斜的还是横平竖直的），我们都可以用一个横平竖直的正方形把它框住（想象弦图）。那么每个 $i\times i$ 的横平竖直的正方形都可以对应 $i$ 个正方形，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/dbhkndvu.png)

故考虑所有横平竖直的正方形：

$$f(1)=\sum\limits_{i=1}^{\min(M,N)}i(M-i+1)(N-i+1)$$

**$f(1)$**：枚举坏点，同样考虑横平竖直的正方形，而且它必须经过这个坏点。显然每个这样的正方形都会贡献 $1$。分别计算正方形在点上方、下方、左侧、右侧的贡献，它可以看做是点在网格底，往左有 $l$ 格，往右有 $r$ 格，往上有 $h$ 格，设其贡献为 $g(l,r,h)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/nqqsvjua.png)

正方形的边长最大显然为 $a=\min(h,l+r)$。假装 $l,r$ 足够大，那 $g(l,r,h)$ 为：

$$\begin{aligned}g(l,r,h)&=\sum\limits_{i=1}^{a}i+1\\ &=\dfrac{i(i+3)}{2}\end{aligned}$$

接着计算正方形超出左、右边界的方案数，减去即可得到 $g(l,r,h)$。（不再推导，具体公式见代码）

求出四个方向的 $g$，最后减去坏点作为角的方案数（重复计数），得到 $f(1)$。

**f(2),f(3),f(4)**：枚举两个坏点，并验证第三、第四个顶点是否在网格内（是否是坏点）。

由于计算 $f(3),f(4)$ 时枚举到三点（四点）中任意两点都会计一次数，所以 $f(3),f(4)$ 计算到最后要分别除以 ${3\choose 2}=3,{4\choose 2}=6$。

![](https://cdn.luogu.com.cn/upload/image_hosting/a6iwy478.png)
求出所有 $f$ 便能得到答案。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int getint(){
	int ans=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9'){
		ans=ans*10+c-'0';
		c=getchar();
	}
	return ans;
}
const int mod=1e8+7;
#define mp make_pair
#define fi first
#define se second

int n,m,k;
set<pair<int,int> >p;

bool check(int x,int y){
	//检查点是否在网格内
	return 0<=x&&x<=n&&0<=y&&y<=m;
}

int calc0(){
	//f(0)
	int ans=0;
	for(int i=1;i<=min(m,n);i++){
		ans+=(m-i+1ll)*(n-i+1ll)*i%mod;
		ans%=mod;
	}
	return ans;
}
int calc(int l,int r,int h){
	//g(l,r,h)
	long long ans=0;
	int a=min(l+r,h);
	ans=a*(a+3ll)/2;
	if(a>l)ans-=(a-l)*(a-l+1ll)/2;
	if(a>r)ans-=(a-r)*(a-r+1ll)/2;
	return ans%mod;
}
int calc1(){
	//f(1)
	int ans=0;
	for(set<pair<int,int> >::iterator it=p.begin();it!=p.end();++it){
		int x=it->fi,y=it->se;
		ans+=calc(x,n-x,y);
		ans+=calc(x,n-x,m-y);
		ans+=calc(y,m-y,x);
		ans+=calc(y,m-y,n-x);
		ans-=min(x,y);
		ans-=min(x,m-y);
		ans-=min(n-x,m-y);
		ans-=min(n-x,y);
		ans=(ans+mod)%mod;
	}
	return ans;
}
int calc2(){
	//f(2)
	int ans=0;
	for(set<pair<int,int> >::iterator it=p.begin();it!=p.end();++it){
		for(set<pair<int,int> >::iterator jt=it;jt!=p.end();++jt){
			if(it==jt)continue;
			int x1=it->fi,y1=it->se,x2=jt->fi,y2=jt->se;
			if(check(x1+y1-y2,y1-x1+x2)&&check(x2-y2+y1,y2+x2-x1))ans++;
			if(check(x1-y1+y2,y1+x1-x2)&&check(x2+y2-y1,y2-x2+x1))ans++;
			
			if(((y1+y2+x1+x2)&1)==0){
				if(check((x1+x2+y2-y1)/2,(y1+y2-x2+x1)/2)&&
				   check((x1+x2-y2+y1)/2,(y1+y2+x2-x1)/2))ans++;
			}
		}
	}
	return ans;
}
int calc3(){
	//f(3)
	int ans=0;
	for(set<pair<int,int> >::iterator it=p.begin();it!=p.end();++it){
		for(set<pair<int,int> >::iterator jt=it;jt!=p.end();++jt){
			if(it==jt)continue;
			int x1=it->fi,y1=it->se,x2=jt->fi,y2=jt->se;
			if(check(x1+y1-y2,y1-x1+x2)&&check(x2-y2+y1,y2+x2-x1)){
				if(p.count(mp(x1+y1-y2,y1-x1+x2)))
					++ans;
				if(p.count(mp(x2-y2+y1,y2+x2-x1)))
					++ans;
			}
			if(check(x1-y1+y2,y1+x1-x2)&&check(x2+y2-y1,y2-x2+x1)){
				if(p.count(mp(x1-y1+y2,y1+x1-x2)))
					++ans;
				if(p.count(mp(x2+y2-y1,y2-x2+x1)))
					++ans;
			}
			if(((y1+y2+x1+x2)&1)==0){
				if(check((x1+x2+y2-y1)/2,(y1+y2-x2+x1)/2)&&
				   check((x1+x2-y2+y1)/2,(y1+y2+x2-x1)/2)){
					if(p.count(mp((x1+x2+y2-y1)/2,(y1+y2-x2+x1)/2)))
						++ans;
					if(p.count(mp((x1+x2-y2+y1)/2,(y1+y2+x2-x1)/2)))
					   	++ans;
				}
					
			}
		}
	}
	return ans/3;
}
int calc4(){
	//f(4)
	int ans=0;
	for(set<pair<int,int> >::iterator it=p.begin();it!=p.end();++it){
		for(set<pair<int,int> >::iterator jt=it;jt!=p.end();++jt){
			if(it==jt)continue;
			int x1=it->fi,y1=it->se,x2=jt->fi,y2=jt->se;
			if(check(x1+y1-y2,y1-x1+x2)&&check(x2-y2+y1,y2+x2-x1)){
				if(p.count(mp(x1+y1-y2,y1-x1+x2)) && p.count(mp(x2-y2+y1,y2+x2-x1)))
					++ans;
			}
			if(check(x1-y1+y2,y1+x1-x2)&&check(x2+y2-y1,y2-x2+x1)){
				if(p.count(mp(x1-y1+y2,y1+x1-x2)) && p.count(mp(x2+y2-y1,y2-x2+x1)))
					++ans;
			}
			if(((y1+y2+x1+x2)&1)==0){
				if(check((x1+x2+y2-y1)/2,(y1+y2-x2+x1)/2&&
				   check((x1+x2-y2+y1)/2,(y1+y2+x2-x1)/2)))
					if(p.count(mp((x1+x2+y2-y1)/2,(y1+y2-x2+x1)/2))&&
					   p.count(mp((x1+x2-y2+y1)/2,(y1+y2+x2-x1)/2)))
					   	ans++;
			}
		}
	}
	return ans/6;
}

int main(){
	n=getint();
	m=getint();
	k=getint();
	for(int i=0;i<k;i++){
		int x=getint(),y=getint();
		p.insert(mp(x,y));
	}
	//cerr<<calc0()<<" "<<calc1()<<" "<<calc2()<<" "<<calc3()<<" "<<calc4()<<endl;
	cout<<((calc0()-calc1()+calc2()-calc3()+calc4())%mod+mod)%mod;
	return 0;
}

```

---

## 作者：liugh_ (赞：0)

[P3271 [JLOI2016] 方](https://www.luogu.com.cn/problem/P3271)

---

一个 $n$ 行 $m$ 列的网格图，共有 $(n+1)(m+1)$ 个格点。给定 $k$ 个坏点的位置，求满足四个顶点都在非坏点的格点上的正方形数量。答案对 $10^8+7$ 取模。

$n,m\le 10^6,k\le 2\cdot10^3$。

---

直接枚举显然不可做，注意到 $k$ 相对较小，考虑从坏点入手，枚举顶点是坏点的正方形。注意到算重的问题，自然地考虑容斥，记 $c_i \ (0\le i\le 4)$ 为**至少**有 $i$ 个顶点是坏点的正方形数量，易得答案 $ans=c_0-c_1+c_2-c_3+c_4$。注意：以下表述中对于一个点 $P$，$P_x$ 是其所在行数，$P_y$ 是其所在列数。

定义**直正方形**为四边均分别与横轴或纵轴平行的正方形。注意到正方形可能是倾斜的，但对于给定的边长为 $i$ 的直正方形，其内接正方形（包括直正方形）的数量是唯一确定的，为 $i$，即下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/l1yecapn.png)

---

考虑 $c_0$，我们只需要枚举直正方形的**边长**即可。整个网格图中共有 $(n-i+1)(m-i+1)$ 个边长为 $i$ 的直正方形，每个直正方形内有 $i$ 个正方形，故
$$
c_0=\sum_{i=1}^{\min\{n,m\}} i(n-i+1)(m-i+1)
$$
时间复杂度 $O(n)$（以下认为 $n$ 与 $m$ 同阶）。

---

考虑 $c_1$，我们可以枚举这个坏点 $P$。记 $l=P_y,r=m-l,u=P_x,d=n-u$。为省去判断边界的步骤，问题转化**为顶点或边经过 $P$ 的直正方形个数**，因为任何以 $P$ 为顶点之一的正方形，其外接直正方形必定在网格图内且由其唯一确定。
![](https://cdn.luogu.com.cn/upload/image_hosting/mugy3nny.png)
直接枚举这样的直正方形，总时间复杂度 $O(nk)$ 显然不可行；但要快速统计同时满足 $l,r,u,d$ 对正方形的限制，需要不小的分讨。正难则反，以其中一个朝向为例，记 $q=\min\{m,u\}$，则总直正方形个数为 $\sum_{i=1}^{q} i+1=q(q+3)/2$。接着考虑什么时候直正方形是不合法的，容易发现当直正方形的边长 $i>l$ 时，有 $q-l$ 个单位长度从左边突出了网格图，这部分要减去，即 $\sum_{i=l+1}^{q} q-l+1=[l<q](q-l)(q-l+1)/2$；当 $i>r$ 时同理。故
$$
\begin{aligned}
c_1'=q(q+3)/2-[l<q](q-l)(q-l+1)/2-[r<q](q-r)(q-r+1)/2
\end{aligned}
$$
对 $4$ 个方向分别统计，再**减去重合的部分**即 $\min\{l,u\}+\min\{u,r\}+\min\{r,d\}+\min\{d,l\}$，就能得到 $c_1$ 了。

时间复杂度 $O(k)$。

---

考虑 $c_2$，我们可以枚举两个坏点 $P,Q$，为方便统计，枚举时令 $P_x<Q_x$ 或 $P_x=Q_x\land P_y<Q_y$。首先，以 $\overline{PQ}$ 为一边的正方形有两个，以 $\overline{PQ}$ 为对角线的正方形有一个，它们的坐标计算不再赘述，详见代码。

同时，注意到 $c_3$ 和 $c_4$ 的统计方法与 $c_2$ 类似，于是同 $c_2$ 一起计算，只需要判断另外两个点是否是坏点即可，此处我采用 `unordered_set` 实现（手写哈希表应该还能再快）。还有一个坑点调了我好久，为了避免 $c_3$ 算重，首先想到的是规定 $3$ 个点之间的位置关系，但这样很繁琐而且容易出问题导致我没调出来。于是干脆全部算上，在最后除以 $C_3^2=3$，$c_4$ 类似地除以 $C_4^2=6$ 即可，别忘了应该乘逆元。

```cpp
#include <iostream>
#include <algorithm>
#include <unordered_set>
#ifdef ONLINE_JUDGE
#define getchar() (_p==_q&&(_q=(_p=_b)+fread(_b,1,_s,stdin),_p==_q)?-1:*_p++)
#define putchar(x) ((_r-_o<_s)?(*_r++=x):(flush(),_r=_o,*_r++=x))
#endif
#define inline inline __attribute__((always_inline))
#define flush() fwrite(_o,_r-_o,1,stdout),fflush(stdout)
using namespace std;const int _s=1<<20;char _b[_s],_o[_s],*_p=_b,*_q=_b,*_r=_o;template<class T>inline bool fr(T&x){x=0;char c=0;bool f=0;do{if((c=getchar())==-1)return 0;if(c=='-')f=1;}while(c<48||c>57);do {x=x*10+c-48;if((c=getchar())==-1)break;}while(c>47&&c<58);if(f)x=-x;return 1;}template<class T>inline void fw(T x){char _d[40],_l=-1;if(x<0)x=-x,putchar('-');do _d[++_l]=x%10+48;while(x/=10);do putchar(_d[_l]);while(~--_l);}

const int Maxn = 1e6 + 3, Maxk = 2e3 + 3, Mod = 1e8 + 7;
inline int mo(int x) {return x >= Mod ? x - Mod : x;}

int N, M, K;
struct Pt {int x, y;} pt[Maxn];
unordered_set<long long> ust;
inline long long getrnk(int x, int y) {return 1ll * x * (M + 1) + y;}

signed main() {
    // ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    // freopen("1.in", "r", stdin);
    // freopen("1.out", "w", stdout);
    fr(N), fr(M), fr(K);
    for (int i = 1; i <= K; i++) fr(pt[i].x), fr(pt[i].y), ust.insert(getrnk(pt[i].x, pt[i].y));
    sort(pt + 1, pt + K + 1, [](const Pt &a, const Pt &b) {return a.x != b.x ? a.x < b.x : a.y < b.y;});

    int cnt0 = 0;
    for (int i = 1; i <= min(N, M); i++) 
        cnt0 = mo(cnt0 + 1ll * (N - i + 1) * (M - i + 1) % Mod * i % Mod);

    int cnt1 = 0;
    for (int j = 1; j <= K; j++) {
        int t = cnt1;
        int u = pt[j].x, d = N - u, l = pt[j].y, r = M - l;
        auto lgh = [&](int lim, int len1, int len2) {
            cnt1 = mo(cnt1 + (1ll * lim * (lim + 3) >> 1) % Mod);
            if (lim > len1) cnt1 = mo(cnt1 - (1ll * (lim - len1) * (lim - len1 + 1) >> 1) % Mod + Mod);
            if (lim > len2) cnt1 = mo(cnt1 - (1ll * (lim - len2) * (lim - len2 + 1) >> 1) % Mod + Mod);
        };
        lgh(min(M, u), l, r);
        lgh(min(M, d), l, r);
        lgh(min(N, l), u, d);
        lgh(min(N, r), u, d);
        cnt1 = mo(cnt1 - min(l, u) + Mod);
        cnt1 = mo(cnt1 - min(u, r) + Mod);
        cnt1 = mo(cnt1 - min(r, d) + Mod);
        cnt1 = mo(cnt1 - min(d, l) + Mod);
    }

    int cnt2 = 0, cnt3 = 0, cnt4 = 0;
    for (int j = 1; j <= K; j++) {
        for (int k = j + 1; k <= K; k++) {
            auto ox = [](int x)->bool {return x >= 0 && x <= N;};
            auto oy = [](int y)->bool {return y >= 0 && y <= M;};
            auto lgh = [&](int x3, int y3, int x4, int y4) {
                if (!ox(x3) || !oy(y3) || !ox(x4) || !oy(y4)) return;
                bool t1 = ust.count(getrnk(x3, y3)), t2 = ust.count(getrnk(x4, y4));
                cnt2++;
                if (t1) cnt3++;
                if (t2) cnt3++;
                if (t1 && t2) cnt4++;
            };

            auto [x1, y1] = pt[j];
            auto [x2, y2] = pt[k];

            lgh(x1 - (y2 - y1), y1 + (x2 - x1),
                x2 - (y2 - y1), y2 + (x2 - x1));
            
            lgh(x1 + (y2 - y1), y1 - (x2 - x1),
                x2 + (y2 - y1), y2 - (x2 - x1));
            
            int a = (x2 - x1) + (y2 - y1), b = (x2 - x1) - (y2 - y1);
            if ((a & 1) || (b & 1)) continue;
            a >>= 1, b >>= 1;
            lgh(x1 + b, y1 + a,
                x2 - b, y2 - a);
        }
    }
    auto fpow = [](int a, int b)->int {
        int res = 1; for (; b; b >>= 1) {
            if (b & 1) res = 1ll * res * a % Mod;
            a = 1ll * a * a % Mod;
        } return res;
    };
    cnt3 = 1ll * cnt3 * fpow(3, Mod - 2) % Mod;
    cnt4 = 1ll * cnt4 * fpow(6, Mod - 2) % Mod;
    fw((cnt0 - cnt1 + Mod + cnt2 - cnt3 + Mod + cnt4) % Mod), putchar(10);
    flush(), exit(0);
}
```

---


# [SCOI2013] 火柴棍数字

## 题目描述

Fish是一条生活在海里的鱼，有一天他很无聊，于是他去捡了人类扔进海里的垃圾，打算用这些来玩些什么。

他从捡回来的垃圾堆里找到了不少火柴棍，便把这些火柴棍拼成了一个长度为n 的十进制数，每个数字的拼法如下图所示

注意：每个数字占据的宽度和摆放方式是固定的，故以下情况均不合法。 ![](https://cdn.luogu.com.cn/upload/pic/4633.png)

 ![](https://cdn.luogu.com.cn/upload/pic/4634.png) 

拼完之后他好累，感觉再也不会拼了。他对拼出来的数大小不满意，希望通过移动一些火柴棍的位置来把这个数变得尽量大。

由于太累，他只能最多移动k 根火柴棍。而且由于数字的最低位放在墙边，他不能在该数的低位后面添加数字，但他可以在该数的前面添加数字。

你能帮他算出他移动火柴棍之后的数最大能是多大吗？

注意：火柴棍对于Fish 来说是很贵重的物品，所以不允许折断或丢弃火柴棍。

注意：火柴头的方向不影响数字的辨识，例如下面几种情况都是数字1

![](https://cdn.luogu.com.cn/upload/pic/4635.png)


## 说明/提示

对于30% 的数据，1 <= n <= 10，0 <= k <= 10。

对于100% 的数据，1 <= n <= 500，0 <=k <=3500。


## 样例 #1

### 输入

```
3 2
```

### 输出

```
17```

## 样例 #2

### 输入

```
3 3```

### 输出

```
71```

# 题解

## 作者：劉子颺 (赞：4)

第一贪心。

引理：

对于可以取出的数字要让可达性最大。

在队首填1.

如果可达性为奇数？

那么队首是7别的是1.

坑点。

对于每个数转换为别的数，其本质是01可达性分组背包。

组：组数为n

每个组

```cpp
int trans[10][10]={
	0, 4, 2, 2, 3, 2, 1, 3, 0, 1,
	0, 0, 2, 0, 0, 1, 1, 0, 0, 0,
	1, 4, 0, 1, 3, 2, 1, 3, 0, 1,
	1, 3, 1, 0, 2, 1, 1, 2, 0, 0,
	1, 2, 2, 1, 0, 1, 1, 2, 0, 0,
	1, 4, 2, 1, 2, 0, 0, 3, 0, 0,
	1, 5, 2, 2, 3, 1, 0, 4, 0, 1,
	0, 1, 1, 0, 1, 1, 1, 0, 0, 0,
	1, 5, 2, 2, 3, 2, 1, 4, 0, 1,
	1, 4, 2, 1, 2, 1, 1, 3, 0, 0
};//两两变幻代价数组。
//代价出现的必要条件：A不纯包含于B 如8->1代价为0 而 1->8 代价 为5 
```
由于我们需要跑一个分组背包。

这个时候写法就多了。

但是我太弱了，对于Claris大神的强行写标准分组背包望其项背。

我们写记忆化搜索

```cpp
int dp[500+10][7000+10];//dp(i,j)表示从低到高位的i位要在n内使用j（既获得，取出）的火柴棍（以摆放高位）放进分组背包内
//理由：常量数组num并不能满足->腾出摆放sigma 1->n 以下所有的木棍。 
bool vis[500+10][7000+10];//记忆化 

//搜索原理：
//对于n->以下的数
//摆放的代价是由 分组背包来求
//对于n以上的->它们只会是1或7 
int dfs(int pos,int remain){
	if(remain>k)
		return INF;
	//当前可行性剪枝不存在这种情况 
	if(pos==0){//搜道0了还有摆不完的说明还是不存在这种01可达性分组背包。 
		return remain==0?0:INF;
	}
	else{
		if(vis[pos][remain])
			return dp[pos][remain];//既然搜过了就记住了。 
		vis[pos][remain]=true;//已搜 
		dp[pos][remain]=INF;//或许这种情况不存在可达性。 
		for(int i=9;i>=0;i--){//从当前位向下转换，既我要把当前位变成这个。必须for 9->1要在结果最优时输出最大的 
			int nowx=dfs(pos-1,remain+num[i]-num[s[pos]])+trans[s[pos]][i];
			dp[pos][remain]=min(dp[pos][remain],nowx);
		}
		return dp[pos][remain];//返回答案。 
	}
}
```
然后查询一个最大当前可剥离值。

然后贪心输出前面的答案。
```cpp
	for(int i=k;i>1;i--){
		if(dfs(n,i)<=k){//这里实际上是从最高位做起。 
			int remain=i;
			if(remain&1){//贪心思想。 
				printf("7");
				remain-=3;
			}
			while(remain){
				printf("1");
				remain-=2;
			}
			dfs_print(n,i);
			return 0;
		}
	}
```
是的可达性背包问题是没有记录路径的于是又一个坑点来了。

查询路径。

第一，可达性可以有多种，所以必须从9查到0.

第二，我们用贪心来查。

```cpp
void dfs_print(int pos,int remain){//事实上最开始只是做了一个01可达性分组背包。dfs循环找出实际结果。 
	while(pos){//例行我们从最高位做起递归打印。 
		for(int i=9;i>=0;i--){//在同样的可达性下是不是使用最高位更大更好？ 
			if(dfs(pos-1,remain+num[i]-num[s[pos]])<=k-trans[s[pos]][i]){//k-trans[s[pos][i]]表示：当前位使用辣么多木棍，注意不是释放，或许还需要拆东墙补西墙。 
				//dfs查询的就是还需要多少根，若果小于直接贪心，因为你从大往小搜。这也是为什么reverse的原因。 
				printf("%d",i);
				remain=remain+num[i]-num[s[pos]];
				k-=trans[s[pos]][i];
				pos--;
				break;
			}
		}
	}
}
```
于是乎就完了。





好的你也就完了。

考虑这个特殊的一批的数据：

3 1

干不了什么事，也做不了可达性背包。

于是查到答案结束代码

否则在最后输出原数。

---

## 作者：CiJJ1314 (赞：0)

# P3283 题解

第一篇题解，是真的很想写好，哈哈哈。

前前后后做了好久，大神有大神的秒法，蓝名也有蓝名的笨法子。

好，那开始：

## 贪心

如果 $k$ 取无穷，那么很容易想到把所有火柴取出来，偶数份组成 $1$ 剩余一个火柴放在队首组成 $7$。

这样取得的数字位数最长，也就最大。

## 背包

存在 $k$ 的限制。

所以再取数的时候就要有取舍。

这里还是贪心的思想，取出的火柴越多，那么能组成的 $1$ 也就越多，位数越多，数就越大。

## wa 答案

只考虑全包含结构，这样不浪费 $k$ 的限制，取出来的火柴都放在队首了。

显然，这样贪不到正确答案。

比如 $2$ 不全包含其他数字，可是 $2$ 在 $k$ 取大数的时候可以拆成 $711$。

## ac 答案

哪怕是上面的 wa 答案，也不难考虑到：需要用背包来实现取火柴的操作。

简单举例，可取火柴数排列为：$2 2 3$ 而 $k=5$。

那么取出四个显然不够好——

结合这些那么我们的思路就是，计算：

- $cost_{i,j}$

  - 数字 $i$ 变为数字 $j$ 需要消耗的移动值（$k$ 值）。

- $income_{i,j}$

  - 数字 $i$ 变数字 $j$ 可以得到的火柴棒的数目。

- $dp_{i,j}$

  - 取第 $i$ 位（高位起）时消耗 $j$ 点移动值可以得到的火柴棒数目（背包）。

- $path_{i,j}$

  - 取得 $dp_{i,j}$ 时前面火柴的状态。

这样看，要做的事情似乎也没很多。

只是想思路的话没什么，但是实际做题要考虑的就多了。

- 考虑取出的火柴数目只有 $1$ 时：显然不能放在队首了（没有数字是一根火柴组成的）。

  - 那么可以朴素的：找个位置，给他放回去。可是未必有这样的位置，因为你不知道是消耗了多少 $k$ 值，得到了这根来之不易的火柴。但是你要这样做，因为也未必没有：

    - 有：$(83, 1, 99)$

      - 数据格式：
        $$
        (in1,in2,out)
        $$
        

    - 没有：$(75, 2, 75)$

      - ps ：例子好难找，所以每次调代码的时候也是数据不好找。
      - 如果用 $2$ 个 $cost$ 在 $5$ 中可以取出一个变成 $4$ 但是放回去的时候就头疼了。

  - 用背包费劲巴拉的取出一根火柴之后得到的数据可能不怎么理想，这是因为用了较多的 $k$ 取出了较少的 $dp$ 值，而放回的时候无法对取出的操作进行反悔，想避免这样的情况，就不能从这个数字取，然后放进其他数字里。

    - 所以需要考虑在 $ans$ 中对每个数字进行内部变换。
    - （刚找数据还给自己答案找 hack 了） $(700,2,799)$（已改正）

- 好 MLE 了，滚动数组优化。

思路不困难，实现不简单。

赛博口香糖，无聊做一做。

那——贴代码（一些调试过程也不删了，方便理解）。

```c++
/*
 * @Date: 2024-12-12 23:30:31
 * @LastEditors: error: error: git config user.name & please set dead value or install git && error: git config user.email & please set dead value or install git & please set dead value or install git
 * @LastEditTime: 2024-12-30 15:29:16
 * @FilePath: \main\main.cpp
 */
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int getint();
void solve();
int main(){
    int t=1;
    // t=getint();
    while(t--){
        solve();
    }
}
int getint(){
    int res=0,sign=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')sign=-1;
        else ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        res*=10;
        res+=ch-'0';
        ch=getchar();
    }
    return res*sign;
}
//对于100% 的数据，1 <= n <= 500，0 <=k <=3500。
const int N=5e2+3;
const int K=3e3+N;
const int nums[10][7]={//十个数字的字形码
                    {1,1,1,1,1,1,0},//0
                    {0,1,1,0,0,0,0},//1
                    {1,1,0,1,1,0,1},//2
                    {1,1,1,1,0,0,1},//3
                    {0,1,1,0,0,1,1},//4
                    {1,0,1,1,0,1,1},//5
                    {1,0,1,1,1,1,1},//6
                    {1,1,1,0,0,0,0},//7
                    {1,1,1,1,1,1,1},//8
                    {1,1,1,1,0,1,1} //9
                    };
//用字形码 得出代价数组 mp(cost和income);
//整体思路:得到两两数字之间的移动火柴代价 找到最优取出火柴数量 只记录取出火柴作为代价 放入火柴不需要记录(代价为移动代价)
//代价:取出的火柴数量
//收益:取出-放入(得到的火柴个数)
//dp得到取出的最大的火柴数
//先取后放---只能考虑到全包含结构 在部分包含转换的时候无法考虑全部情况 比如 全2(或5)时
//边取边放
int cost[10][10]={0},
    income[10][10]={0};
vector<int>ans;//用来存储输入数据
int k;
int dp[N][K]={0};//dp数组
//dp[i][j]表示对前i个数字使用j点移动数 得到的最大火柴数
//转移方程:(o=ans[i],p form 0 to 9)
//dp[i][j]=max(dp[i][j],dp[i-1][j],dp[i-1][j-cost[o][p]]+income[o][p])
vector<vector<vector<int>>>path(2,vector<vector<int>>(K));


void reduce(int,int);
void solve(){
    char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9'){
        ans.push_back(ch-'0');
        ch=getchar();
    }
    k=getint();
    //先处理 低位/高位
    //无实际影响 因为需要对所有情况进行考虑 但让高位在后可以更方便处理添1操作
    reverse(ans.begin(),ans.end());
    for(int i=0;i<10;i++){
        for(int j=0;j<10;j++){
            reduce(i,j);
        }
    }
    // // 得到两个数组 供dp使用
    // cout<<"cost:"<<endl;
    // for(int i=0;i<10;i++){
    //     for(int j=0;j<10;j++){
    //         cout<<cost[i][j]<<' ';
    //     }cout<<endl;
    // }
    // cout<<"income:"<<endl;
    // for(int i=0;i<10;i++){
    //     for(int j=0;j<10;j++){
    //         cout<<income[i][j]<<' ';
    //     }cout<<endl;
    // }
    // 开始dp
    for(int i=0;i<ans.size();i++){
        int o=ans[i];
        for (int j = 0; j <= k; j++){
            for (int p = 0; p < 10; p++){
                if(i){//区分起始和后续
                    if(dp[i][j]<=dp[i-1][j]
                    &&j>=cost[o][p]
                    &&dp[i][j]<=dp[i-1][j-cost[o][p]]+income[o][p]){
                        if(dp[i-1][j]<=dp[i-1][j-cost[o][p]]+income[o][p]){
                            dp[i][j]=dp[i-1][j-cost[o][p]]+income[o][p];
                            path[i%2][j]=path[(i+1)%2][j-cost[o][p]],path[i%2][j].push_back(p);
                        }
                        else if(dp[i-1][j]>=dp[i-1][j-cost[o][p]]+income[o][p]){
                            dp[i][j]=dp[i-1][j];
                            path[i%2][j]=path[(i+1)%2][j],path[i%2][j].push_back(o);
                        }
                        else if(dp[i-1][j]==dp[i-1][j-cost[o][p]]+income[o][p]){//这里少一步比较dp[i-1][j]和dp[i-1][j-cost[o][p]] 暂不考虑
                            dp[i][j]=dp[i-1][j];
                            if(p>o)
                            path[i%2][j]=path[(i+1)%2][j-cost[o][p]],path[i%2][j].push_back(p);
                            else if(o>p)
                            path[i%2][j]=path[(i+1)%2][j],path[i%2][j].push_back(o);
                        }
                    }
                    else if(dp[i][j]<=dp[i-1][j]){
                        if(dp[i][j]<dp[i-1][j]
                        ||path[i%2][j].size()<=path[(i+1)%2][j].size()
                        ||path[i%2][j][i]<o){
                            path[i%2][j]=path[(i+1)%2][j];
                            path[i%2][j].push_back(o);
                        }
                        dp[i][j]=dp[i-1][j];
                    }
                    else if(j>=cost[o][p]&&dp[i][j]<=dp[i-1][j-cost[o][p]]+income[o][p]){
                        dp[i][j]=dp[i-1][j-cost[o][p]]+income[o][p];
                        if(dp[i][j]==dp[i-1][j-cost[o][p]]&&o>p)path[i%2][j]=path[(i+1)%2][j],path[i%2][j].push_back(o);
                        else path[i%2][j]=path[(i+1)%2][j-cost[o][p]],path[i%2][j].push_back(p);
                    }
                    if(path[i%2][j].size()==0)path[i%2][j].push_back(o);
                }
                else{
                    if(j>=cost[o][p]){
                        if(dp[i][j]<income[o][p]){
                            dp[i][j]=income[o][p];
                            if(path[i%2][j].size()==i)
                                path[i%2][j].push_back(p);
                            else
                                path[i%2][j][i]=p;
                        }
                        else if(dp[i][j]==income[o][p]){
                            int tmp=max(o,p);
                            if(path[i%2][j].size()==i)
                                path[i%2][j].push_back(tmp);
                            else
                                path[i%2][j][i]=max(path[i%2][j][i],p);
                        }
                    }
                    if(path[i%2][j].size()==i)path[i%2][j].push_back(o);
                }
                    // if(i&&o==5&&p==9)cout<<i<<' '<<j<<"!!!"<<path[i%2][j][1]<<' '<<path[i%2][j][0]<<endl;
                    // if(dp[i][j]==1)cout<<"???"<<i<<' '<<j<<' '<<path[i%2][j][0]<<endl;
            }
        }
    }
    int sz=ans.size();
    // cout<<path[(sz+1)%2][k][1]<<path[(sz+1)%2][k][0]<<endl;
    if(dp[sz-1][k]==1){
        //ans单个字符变换的改造
        int tk=k;
        for(int i=sz-1;i>=0;i--){
            int o=ans[i];
            for(int p=9;p>o;p--){
                if(cost[o][p]<=tk&&income[o][p]==0){
                    ans[i]=p;
                    tk-=cost[o][p];
                    break;
                }
            }
        }
        bool big=0,small=0;
        for(int i=sz-1;i>=0;i--){
            int o=path[(sz+1)%2][k][i];
            for(int j=9;j>o;j--){
                if(cost[o][j]==0&&income[o][j]==-1){
                    big=1;
                    path[(sz+1)%2][k][i]=j;
                    break;
                }
            }
            if(big)break;
        }
        if(!big)
        for(int i=0;i<sz;i++){
            int o=path[(sz+1)%2][k][i];
            for(int j=o-1;j>=0;j--){
                if(cost[o][j]==0&&income[o][j]==-1){
                    small=1;
                    path[(sz+1)%2][k][i]=j;
                    break;
                }
            }
            if(small)break;
        }
        if(!big&&!small)path[(sz+1)%2][k]=ans;
        for(int i=sz-1;i>=0;i--){
            if(ans[i]>path[(sz+1)%2][k][i]){
                path[(sz+1)%2][k]=ans;
                break;
            }
            else if(ans[i]<path[(sz+1)%2][k][i]){
                break;
            }
        }
    }
    else if(dp[sz-1][k]>2&&dp[sz-1][k]&1){
        cout<<7;
        dp[sz-1][k]-=3;
    }
    while(dp[sz-1][k]>=2){
        cout<<1;
        dp[sz-1][k]-=2;
    }
    while(sz--){
        cout<<path[(ans.size()+1)%2][k][sz];
    }
    cout<<endl;
    // cout<<cost[5][9]<<' '<<income[5][9]<<endl;
}
void reduce(int a,int b){
    int a_b=0,b_a=0;
    for(int i=0;i<7;i++){
        if(nums[a][i]>nums[b][i])a_b++;
        if(nums[b][i]>nums[a][i])b_a++;
    }
    cost[a][b]=a_b;
    income[a][b]=a_b-b_a;
}
```

求过，嘤嘤。

第一篇，真的没经验，见谅。

---

## 作者：木xx木大 (赞：0)

[P3283 [SCOI2013]火柴棍数字](https://www.luogu.com.cn/problem/P3283) （贪心+分组背包）

首先，我们贪心地想：拆出来一些火柴棍放到前面增加位数一定是更优的，且新增的位数越多越优，那么我们应该尽量放 1 ，火柴棍不够再放一个 1（即能拆出的火柴棍数为奇数） 时就把最高位改为 7 ，因为它们用到的火柴棍最少。

那么接下来的问题就是对于原来的数，把它变成别的数。发现这本质是一个分组背包，可以写循环或者记搜来判断可行性。然后再贪心地从高往低填，填每一位的时候判一下可行性即可。

具体见代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace FGF
{
	int n,m;
	const int val[10][10]={//数之间转化的代价
	{0,4,2,2,3,2,1,3,0,1},
	{0,0,1,0,0,1,1,0,0,0},
	{1,4,0,1,3,2,1,3,0,1},
	{1,3,1,0,2,1,1,2,0,0},
	{1,2,2,1,0,1,1,2,0,0},
	{1,4,2,1,2,0,0,3,0,0},
	{1,5,2,2,3,1,0,4,0,1},
	{0,1,1,0,1,1,0,0,0,0},
	{1,5,2,2,3,2,1,4,0,1},
	{1,4,2,1,2,1,1,3,0,0}
	};//不知道为什么，我手玩出来的代价和另一篇题解不太一样，但都能过
	const int cnt[10]={6,2,5,5,4,5,6,3,7,6};
	const int INF=0x3f3f3f3f;
	int dp[510][7010],s[510];
	bool vis[510][7010];
	char ch[510];
	int dfs(int pos,int res)//这里搜索的本质是分组背包 
	{//dp[i][j]: 当前扫的从低到高的第i位，手里有j个空闲火柴，所需要的最小移动次数 
		if(res>m)return INF;
		if(pos==0)return res? INF:0;
		if(vis[pos][res])return dp[pos][res];
		vis[pos][res]=1,dp[pos][res]=INF;
		for(int i=9;i>=0;i--)
		{
			int tmp=dfs(pos-1,res+cnt[i]-cnt[s[pos]])+val[s[pos]][i];
			dp[pos][res]=min(dp[pos][res],tmp);
		}
		return dp[pos][res];
	}
	void write(int pos,int res)
	{
		while(pos)
		{
			for(int i=9;i>=0;i--)
			{
				int tmp=dfs(pos-1,res+cnt[i]-cnt[s[pos]]);
				if(tmp<=m-val[s[pos]][i])
				{
					printf("%d",i);
					res=res+cnt[i]-cnt[s[pos]];
					m-=val[s[pos]][i];
					pos--;
					break;
				}
			}
		}
	} 
	void work()
	{
		scanf("%s%d",ch,&m);
		n=strlen(ch);
		for(int i=1;i<=n;i++)
			s[i]=ch[n-i]-'0';
		for(int i=m;i>1;i--)
		{//尽量多拆出一些火柴棍
			if(dfs(n,i)<=m)//从最高位开始搜，但本质是低位向高位转移
			{
				int res=i;//贪心地，前面全放1或7 
				if(res&1)printf("7"),res-=3;
				while(res)printf("1"),res-=2;
				write(n,i);
				return;
			}
		 } 
		 write(n,0);
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

---


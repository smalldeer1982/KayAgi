# [SHOI2016] 黑暗前的幻想乡

## 题目背景

四年一度的幻想乡大选开始了，最近幻想乡最大的问题是很多来历不明的妖怪涌入了幻想乡，扰乱了幻想乡昔日的秩序。但是幻想乡的建制派妖怪（人类）博丽灵梦和八云紫等人整日高谈所有妖怪平等，幻想乡多元化等等，对于幻想乡目前面临的种种大问题却给不出合理的解决方案。

风见幽香是幻想乡里少有的意识到了问题严重性的大妖怪。她这次勇敢地站了出来参加幻想乡大选，提出包括在幻想乡边境建墙（并让人类出钱），大力开展基础设施建设挽回失业率等一系列方案，成为了大选年出人意料的黑马并顺利地当上了幻想乡的大统领。

## 题目描述

幽香上台以后，第一项措施就是要修建幻想乡的公路。幻想乡一共有 $n$ 个城市，之前原来没有任何路。幽香向选民承诺要减税，所以她打算只修 $n-1$ 条公路将这些城市连接起来。但是幻想乡有正好 $n-1$ 个建筑公司，每个建筑公司都想在修路的过程中获得一些好处。虽然这些建筑公司在选举前没有给幽香钱，幽香还是打算和他们搞好关系，因为她还指望他们帮她建墙。所以她打算让每个建筑公司都负责一条路来修。

每个建筑公司都告诉了幽香自己有能力负责修建的路是哪些城市之间的。所以幽香打算 $n - 1$ 条能够连接幻想乡所有城市的边，然后每条边都交给一个能够负责该边的建筑公司修建，并且每个建筑公司都恰好修建一条边。

幽香现在想要知道一共有多少种可能的方案呢？两个方案不同当且仅当它们要么修的边的集合不同，要么边的分配方式不同。

## 说明/提示

#### 数据规模与约定

+ 对于 $20\%$ 的测试点，$n \le 5$。
+ 对于 $50\%$ 的测试点，$n \le 8$。
+ 对于 $60\%$ 的测试点，$n \le 10$。
+ 对于 $100\%$ 的测试点，$2 \leq n \le 17$，$0 \leq m_i \leq \frac{n(n - 1)}{2}$，$1 \leq u, v \leq n$。

## 样例 #1

### 输入

```
4
2 3 2 4 2
5 2 1 3 1 3 2 4 1 4 3
4 2 1 3 2 4 1 4 2```

### 输出

```
17```

# 题解

## 作者：hhoppitree (赞：61)

### 题意简述：  

求在 $n$ 条有色（$n-1$ 种颜色）边中选 $n-1$ 条 **颜色各异** 的边使它们构成一颗树的方案数。

### 题目解法：   

**前置知识：矩阵树定理**  

不会不行，有关系。  

看到数据范围 $(n\le17)$，果断想到时间复杂度为 $O(F2^n)$，其中 $F$ 为一个关于 $n$ 的小（请感性理解）多项式。  

我们看到，求生成树的个数，根据以往知识，肯定要用 $\rm Matrix-Tree$ 定理了。  

然后就是这个颜色各异条件特别烦，我们考虑枚举用的边从何处选出。  

如果枚举用啥边，时间复杂度是 $\mathcal{O}(\prod m_i n^3)$ 的，还不如暴力。  

仔细想想，是因为 **重复计数** 了，每种情况都枚举了。  

根据以往的经验，这道题数据规模又很小，所以用 **容斥原理** 就行了。  

具体而言，就是 $\mathcal{O}(2^n)$ 枚举只取其中几种颜色的边，然后瞎算一下就行了。  

记 $f$ 为只考虑某几种颜色时生成树的个数，则可以在 $\mathcal{O}(n^3)$ 的时间复杂度算出一种选择方案所对应的 $f$ 值。

更具体点，就是 $\sum\limits_{\text{取 1 个}}f-\sum\limits_{\text{取 2 个}}f+\sum\limits_{\text{取 3 个}}f-\sum\limits_{\text{取 4 个}}f\cdots\pm\sum\limits_{\text{取 (n-1) 个}}f$。  

很显然，这个正负号取决于选的个数的奇偶性。  

所以状压一下从 $1$ 枚举到 $2^{n-1}-1$（$\rm dfs$ 也行）顺便统计一下选的个数 $\text{(cnt)}$ 然后容斥就行了。  

具体详见代码。

### 正确代码： 

```cpp
#include<bits/stdc++.h>
#define mp(x,y) make_pair(x,y)
#define mod 1000000007
using namespace std;
int TMP3301;
inline int read(){
    int res=0;
    char c;
    bool zf=0;
    while(((c=getchar())<'0'||c>'9')&&c!= '-');
    if(c=='-')zf=1;
    else res=c-'0';
    while((c=getchar())>='0'&&c<='9')res=(res<<3)+(res<<1)+c-'0';
    if(zf)return -res;
    return res;
}
int n;
int dta[21][21];
typedef pair<int,int>P;
vector<P>q[21];
inline void _swap(int x,int y){
	for(register int i=1;i<=n;++i){
		#define swap(x,y) TMP3301=x,x=y,y=TMP3301;
		swap(dta[i][x],dta[i][y]);
		#undef swap
	}
	return;
}
inline int det(){
	int ans=1;
	for(register int i=1;i<=n;++i){
		int p=-1;
		for(register int j=i;j<=n;++j)
			if(dta[i][j]){
				p=j;
				break;
			}
		if(!~p){
			return 0;
		}
		if(p!=i){
			_swap(i,p);
			ans*=-1;
		}
		for(register int j=i+1;j<=n;++j){
			while(dta[j][i]){
				int tmp=dta[j][i]/dta[i][i];
				for(register int k=i;k<=n;++k){
					dta[j][k]-=1ll*tmp*dta[i][k]%mod;
					dta[j][k]=(dta[j][k]%mod+mod)%mod;
				} 
				if(!dta[j][i]){
					break;
				}
				swap(dta[i],dta[j]);
				ans*=-1;
			}
		}
		ans=1ll*ans*dta[i][i]%mod;
	}
	return ans;
}
signed main(){
	n=read()-1;
	for(register int i=1;i<=n;++i){
		int cnt=read();
		while(cnt--){
			int x=read(),y=read();
			q[i].push_back(mp(x,y));
		}
	}
	int ans=0;
	for(register int i=1;i<(1<<n);++i){
		memset(dta,0,sizeof(dta));
		int cnt=0;
		for(register int j=1;j<=n;++j){
			if(!(i&(1<<(j-1)))){
				continue;
			}
			++cnt;
			for(register int k=0;k<q[j].size();++k){
				int x=q[j][k].first,y=q[j][k].second;
				++dta[x][y],++dta[y][x],--dta[x][x],--dta[y][y];
			}
		}
		ans=(ans+((cnt&1)?-1:1)*det())%mod;
	}
	printf("%d\n",(ans%mod+mod)%mod);
	return 0;
} 
```

如果您没有看懂这篇题解，可以在评论区问我，我将会回答您的问题并且修改这篇题解，使它变得更加通俗易懂，服务更多的 $\text{OIer}$。  
如果您看懂了这篇题解，可以点个赞，使这篇题解的排名上升，服务更多的 $\text{OIer}$。  

---

## 作者：shadowice1984 (赞：50)

有那么一句话叫看到计数想容斥？

~~(为什么你会这么熟练啊！你到底切过多少道容斥题了啊！？)~~

但是容斥原理这个东西还是相当套路的，想不到就想不到了，但是熟练之后会切的很快~

相似题目可以去做一做P3349\[ZJOI2016]小星星和这道题很像

但是这道题不是纯容斥，还是要加一些别的东西的

## 前置芝士：矩阵树定理

~~(只管瞎讲口胡不管证明，各位dalao们轻拍)~~

### 前置芝士的前置芝士：行列式

(正式的定义需要学习排列和逆序的相关知识，这里我们直接讲计算上的定义)

然后我们构造的定义一个方阵的行列式，行列式是一个数。

**一个上三角方阵/下三角方阵(就是有一半全是0的矩阵)的行列式是其对角线之积**

(特殊的，单位方阵行列式是1)

**对于一方阵其一行/一列乘以k，行列式乘k**

**对于一方阵其两行相加减，行列式不变**

**对于一个矩阵交换其两行/两列，行列式反号**

(推论，一个矩阵两行/两列成比例行列式为0)

好了那么我们发现我们可以从一个n阶单位方阵开始，仅凭借交换行/列，一行/一列乘k，行/列相加减这3个操作可以构造出所有的方阵，因此每个方阵都是有行列式的

那么我们怎么计算行列式呢？

我们发现只需要由单位矩阵/三角矩阵构造出来这个矩阵就行了对吧

我们发现构造用的3种操作(交换，加减，乘除)，刚好是高斯削元用的3种操作

所以我们对这个矩阵做一发高斯削元，会得到一个单位矩阵/三角矩阵

然后我们只需要将高斯削元中的每一步倒过来就可以构造出原矩阵然后就可以
求出行列式啦~

当然真实写代码的时候并不需要倒过来，只需要做高斯削元的时候交换就反号，乘变除除变乘，就可以一遍高斯削元一边求行列式了(如果你写的是削成单位矩阵的高斯削元，可以把行列式的初值直接设成1)

当然此时可能会发现最后消出来的矩阵对角线有0，我们此时直接return 0就好了

------------------

 _下面是矩阵树定理_ 

矩阵树定理解决一个很简单的问题，一个无向图到底有多少个生成树？

答案和某个矩阵的行列式有关，这里我们只给出诸位dalao证明出来的结论

我们设这个图$G$的邻接矩阵是$A$,度数矩阵是$D$

(这里介绍下度数矩阵，度数矩阵只有对角线上不是0，第i行第i列的值是点i的度数，也就是邻接矩阵这一行的和)

(这里的邻接矩阵允许重边，邻接矩阵第i行第j列的值是i和j之间有几条边)

定义一个图的$Kirchhoff$矩阵$K=D-A$

那么矩阵树定理的结论如下

**1.Kirchhoff矩阵同时去掉任意一行一列，剩下的矩阵行列式绝对值相等**

**2.Kirchhoff矩阵同时去掉任意一行一列，剩下的矩阵的行列式绝对值，就是这个无向图的生成树个数**

求行列式的方法我们已经介绍，直接高斯削元暴力$O(n^3)$求解即可

(一个特例:完全图的生成树个数是$n^{n-2}$)

_______________

# 本题题解：容斥原理

有了矩阵树定理这个暴力而优雅的定理之后这题就是一个考验诸位熟练度的容斥原理计数裸题了

我们可以认为这个题有两个限制

**1.建造的公路构成一只生成树**

**2.每个公路必须由不同的公司建造**

发现同时满足两个条件很辣手，但是呢我们可以只满足第一个条件

直接对着这个图跑一边矩阵树定理就可以求出方案数了对吧~

**注意:如果两个公司可以建造同一个公路，需要按重边处理**！

此时我们会发现我们明显算多了，刚好由n-1个公司建造的生成树是统计上了

**但是我们也统计上了刚好由n-2个公司建造的生成树**。

没关系，我们枚举到底是哪n-2个公司建造了这个树，显然这样的集合有$C_{n-1}^{1}$种，**建图的时候只加入这n-2个公司的边**，对着这个图跑一边矩阵树就可以求出方案数了对吧~，然后依次减去这些集合的方案数

但是我们发现此时明显算少了,因为我们多减去了刚好n-3个公司建造的树，显然这样的集合有$C_{n-1}^{2}$种，我们继续枚举集合，**建图的时候只加入这n-3个公司的边**，然后继续跑矩阵树定理，此时我们依次加上这些集合的方案数

然后发现我们加多了……n-4个公司的情况被重复统计了，此时我们以此类推地枚举所有的集合，最后显然一个公司都不剩的情况方案数是0，因此我们的递归是有终点的，并且当递归结束的时候我们刚好统计了所有的方案数。

**以上建图时请务必注意重边的处理，同一边不同公司造按重边记！！！**

算法复杂度$O(2^{n-1}(n-1)^{3}log(10^{9}+7))$可以通过此题(然而我常数极大差点T飞)

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=20;typedef long long ll;
ll mod=1e9+7;int n;int up;int mp[N][N];
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=(a*a)%mod){if(p&1){r=(r*a)%mod;}}return r;}
ll kir[N][N];int siz[262144];int u[N][N*N];int v[N][N*N];int m[N];ll res;
inline ll det()//行列式板子 
{
	ll res=1;int tr=0;//这里我们记录下到底反了多少次号，因为膜意义下取不了绝对值 
	for(int i=1;i<=n-1;i++)//强行高斯削元，不会的话出门左转luogu膜板区 
	{
		if(kir[i][i]==0)
		{
			for(int j=i+1;j<=n-1;j++)
			{
				if(kir[j][i]==0){continue;}tr^=1;//交换一次变一下号 
				for(int k=1;k<=n-1;k++){swap(kir[i][k],kir[j][k]);}
			}
		}
		for(int j=i;j<=n-1;j++)
		{
			if(kir[j][i]==0){continue;}//乘变除除变乘 
			ll div=po(kir[j][i],mod-2);res=(res*kir[j][i])%mod;
			for(int k=i;k<=n-1;k++){kir[j][k]=(kir[j][k]*div)%mod;}
		}
		for(int j=i+1;j<=n-1;j++)
		{
			if(kir[j][i]==0){continue;}
			for(int k=i;k<=n-1;k++){kir[j][k]=(kir[j][k]+mod-kir[i][k])%mod;}
		}
	}for(int i=1;i<=n-1;i++){res*=kir[i][i];}//判一下有没有0 
	return (tr)?(mod-res)%mod:res;//判一下是否反号 
}
int main()
{
	scanf("%d",&n);up=(1<<(n-1))-1;
	for(int i=1;i<n;i++)
	{scanf("%d",&m[i]);for(int j=1;j<=m[i];j++){scanf("%d%d",&u[i][j],&v[i][j]);}}
	for(int i=1;i<=up;i++){siz[i]=siz[i>>1]+(i&1);}//递推集合的siz 
	for(int i=1;i<=up;i++)
	{
		for(int j=1;j<=n;j++){for(int k=1;k<=n;k++){kir[j][k]=0;}}//清空 
		for(int j=1,p=i;p;p>>=1,j++)//建图 
		{
			if((p&1)==0)continue;
			for(int k=1;k<=m[j];k++)
			{
				int U=u[j][k];int V=v[j][k];kir[U][U]++;kir[V][V]++;
				kir[U][V]=(kir[U][V]+mod-1)%mod;kir[V][U]=(kir[V][U]+mod-1)%mod;
			}
		}res=(res+mod+((n-siz[i])%2?det():-det()))%mod;//看一下删了多少个公司，决定符号 
	}printf("%lld\n",res);return 0;//拜拜程序~ 
}
```












---

## 作者：Kelin (赞：13)

### 题意

$n-1$个公司,每个公司能修一些边,求每条边都让不同的公司来修的生成树的方案数

---

### 题解

看到这种"每个$\ldots$都要$\ldots$"的题目就往容斥方面想一想

那么$ans=$所有都选了的生成树个数$-1$个没选的$+2$个没选的$-\ldots$

生成树个数就可以用直接用矩阵树定理求就好了

然后这题模数是一个质数,所以可以直接求逆元

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
const int N=20,P=1e9+7;
typedef int arr[N];
typedef long long ll;
struct eg{int nx,u,v;}e[8005];
int n,ce,ans;arr fi,a[N],G[N];
inline int pls(int a,int b){return a+=b,a>=P?a-P:a;}
inline int sub(int a,int b){return a-=b,a<0?a+P:a;}
inline int fpm(int a,int b){int x=1;for(;b;b>>=1,a=(ll)a*a%P)if(b&1)x=(ll)x*a%P;return x;}
inline int det(int n){
    int ans=1,f=1,t,inv,mx;
    fp(i,1,n)fp(j,1,n)G[i][j]=pls(a[i][j],P);
    fp(i,1,n){mx=i;
        fp(j,i,n)if(G[j][i]>G[mx][i])mx=j;
        if(mx^i){fp(k,i,n)swap(G[i][k],G[mx][k]);f=-f;}
        inv=fpm(G[i][i],P-2);
        fp(j,i+1,n)if(G[j][i]){
        	t=(ll)G[j][i]*inv%P;
        	fp(k,i,n)G[j][k]=sub(G[j][k],(ll)G[i][k]*t%P);
        }ans=(ll)ans*G[i][i]%P;
    }
    return pls(P,f*ans);
}
void dfs(int x,int y){
	if(x==n)return y&1?ans=sub(ans,det(n-1)):ans=pls(ans,det(n-1)),void();
	dfs(x+1,y);
	for(int i=fi[x];i;i=e[i].nx){
		int u=e[i].u,v=e[i].v;
		--a[u][u],--a[v][v],++a[u][v],++a[v][u];
	}
	dfs(x+1,y+1);
	for(int i=fi[x];i;i=e[i].nx){
		int u=e[i].u,v=e[i].v;
		++a[u][u],++a[v][v],--a[u][v],--a[v][u];
	}
}
inline void add(int i,int u,int v){e[++ce]={fi[i],u,v},fi[i]=ce;}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    scanf("%d",&n);
    fp(i,1,n-1){
    	int m,u,v;scanf("%d",&m);
    	fp(j,1,m)scanf("%d%d",&u,&v),add(i,u,v),++a[u][u],++a[v][v],--a[u][v],--a[v][u];
    }
    dfs(1,0);
    printf("%d",ans);
return 0;
}

```

---

## 作者：lhm_ (赞：9)

生成树计数的问题用矩阵树定理解决。

考虑如何解决去重的问题，也就是如何保证每个公司都修建一条道路。

用容斥来解决，为方便起见，我处理时先将$n$减了1。

设$f(n)$为用$n$个公司，且不考虑每个公司都修建一条道路的要求，生成树的方案数。

应用容斥公式，那么答案$ans=\sum\limits_{i=1}^n(-1)^{n-i}f(i)$

那么我们枚举子集，用矩阵树定理计算求解即可。

实现细节看代码吧。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 20
#define maxm 410
#define mod 1000000007
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
ll n,all,sum,cnt;
ll a[maxn][maxn];
void add(int x,int y)
{
    a[x][x]++,a[y][y]++;
    a[x][y]--,a[y][x]--;
}
struct edge
{
    int x,y;
};
struct node
{
    ll num;
    edge e[maxm];
}p[maxn];
ll det()
{
    ll ans=1;
    for(int i=1;i<=n;++i)
    {
        for(int j=i+1;j<=n;++j)
        {
            while(a[j][i])
            {
                ll d=a[i][i]/a[j][i];
                for(int k=i;k<=n;++k)
                    a[i][k]=((a[i][k]-a[j][k]*d%mod)%mod+mod)%mod;
                swap(a[i],a[j]),ans*=-1;
            }
        }
        ans=ans*a[i][i]%mod;
    }
    return (ans%mod+mod)%mod;
}
int main()
{
    read(n),n--,all=1<<n;
    for(int i=1;i<=n;++i)
    {
        read(p[i].num);
        for(int j=1;j<=p[i].num;++j)
            read(p[i].e[j].x),read(p[i].e[j].y);
    }
    for(int s=1;s<all;++s)
    {
        cnt=0;
        memset(a,0,sizeof(a));
        for(int i=1;i<=n;++i)
        {   
            if(s&(1<<(i-1)))
            {   
                cnt++;
                for(int j=1;j<=p[i].num;++j)
                    add(p[i].e[j].x,p[i].e[j].y);
            }
        }
        sum=((sum+det()*((n-cnt)&1?-1:1))%mod+mod)%mod;
    }
    printf("%lld",sum);
    return 0;
}
```


---

## 作者：ecnerwaIa (赞：7)

[题目](https://www.luogu.org/problemnew/show/P4336)

题目大意：给出$n-1$个公司,求每个公司修建一条路能形成一棵$n$个节点的生成树的方案数

~~一眼看去矩阵树~~，但是直接求$n-1$个公司的矩阵树会出问题，可能有的公司修建不止一条道路，所以就容斥一下啦。

当然~~一眼就能看出~~这种跟集合有关的容斥系数就是$(-1)^{n-1-i}$啦，但还是证明一下好了(这种简单的容斥如果您会的话就不用看下面的证明了QAQ)

考虑我们算的方案的贡献，考虑只有$m$个公司修建了$n-1$条路贡献为$[m==n-1]$，而我们矩阵树其实求的是一个集合的所有子集的方案数，比如$\{1,2,3\}$会算出$\{1,2,3\},\{1,2\},\{1,3\},\{2,3\},\{1\},\{2\},\{3\}$但我们只要求出$\{1,2,3\}$，怎么办呢，这时我们就要通过算贡献来配容斥系数（容斥的题都可以这样，还可以通过找规律，递推得到容斥系数）

考虑任意一个集合A有$m$个元素，有另一个集合B使得A是B的子集,假设B有$i$个元素,那么会算$\tbinom{n-1-m}{i-m}$次，我们希望$m!=n-1$时A没有贡献，那么就有这个式子

 $\sum{i=m}^{n-1}{\tbinom{n-1-m}{i-m}*F(i)}==[m==n-1] ===> \sum{i=0}^{i=n-1-m}{\tbinom{n-1-m}{i}*F(i+m)}==[m==n-1]$  
$===>\sum_{i=0}^{k}{\tbinom{k}{i}*F(i+(n-1-k))}==[k==0]===>\sum_{i=0}^{k}{\tbinom{k}{k-i}*F(n-1-i)}==[k==0]$

然后因为我们都知道$\sum_{i=0}^{n}{\tbinom{n}{i}*(-1)^{i}}==[n==0]$

所以有$F(n-1-i)=(-1)^{i}$,所以$F(i)=(-1)^{n-1-i}$

然后就很简单了...(我用的辗转相除求高斯消元，好像慢好多啊）

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
typedef long long LL;
const int mod=1e9+7,N=18;
int m[N],u[N][N*N],v[N][N*N],siz[1<<N],n,maxn;
LL ans,a[N][N];
inline void ins(int u,int v){a[u][u]++;a[v][v]++;a[u][v]--;a[v][u]--;}
inline LL Gauss(int p){
    LL ans=1;
    for(int i=1;i<=p;++i){
        for(int j=i+1;j<=p;++j){
            while(a[j][i]){
                LL d=a[i][i]/a[j][i];
                for(int k=i;k<=p;++k){a[i][k]=(a[i][k]+mod-d*a[j][k]%mod)%mod;}
                swap(a[i],a[j]);ans=-ans;
            }
        }ans=ans*a[i][i]%mod;
    }
    return ans<0?ans+mod:ans;
}
int main(){
    scanf("%d",&n);maxn=(1<<(n-1))-1;
    for(int i=1;i<n;++i){scanf("%d",&m[i]);for(int j=1;j<=m[i];++j)scanf("%d%d",&u[i][j],&v[i][j]);}
    for(int i=1;i<=maxn;++i)siz[i]=siz[i>>1]+(i&1);
    for(int i=1;i<=maxn;++i){
        for(int j=1;j<n;++j)for(int k=1;k<n;++k)a[j][k]=0;
        for(int j=1,p=i;p;p>>=1,++j){
            if(!(p&1))continue;
            for(int k=1;k<=m[j];++k)ins(u[j][k],v[j][k]);
        }
        if((n-siz[i])%2==1){ans+=Gauss(n-1);if(ans>mod)ans-=mod;}
        else {ans+=(mod-Gauss(n-1));if(ans>mod)ans-=mod;}
    }printf("%lld\n",ans);
    return 0;
}

```


---

## 作者：pengyule (赞：3)

这题的主要特点是一旦了解所用算法就非常模板。  
那么前置知识就是 *容斥原理* 和 *矩阵树定理*。

即便没有学过容斥，理解本题容斥思路也很容易。

> 给定一个有重边无自环无向图，每条边有一个颜色，考虑如何计算它的 **所有 $n-1$ 条树边颜色互不相同** 的生成树个数。


![image.png](https://s2.loli.net/2021/12/27/5fyX4AcDmIdCub1.png)

上面是举了一个例子。事实上，一般地：
$$
ANS(T=\{1,2,...,n-1\})=\sum_{i=n-1}^0\left((-1)^{n-1-i}\sum_{|S|=i,S\subseteq\{1,2,...,n-1\}}ANS(T\subseteq S)\right)
$$
如何求 $ANS(T\subseteq S)$ 呢？显然这个时候我们就是已知一张新图，需要求这个新图的生成树数量。我们了解到，Matrix-Tree 定理（矩阵树定理）就是用来干这个事的，于是就很板了。

## 什么是 Matrix-Tree 定理

### 1.Kirchhoff 矩阵

Kirchhoff 矩阵（又称拉普拉斯矩阵） $L=V-E$，其中 $V$ 定义为 $V_{i,i}=deg_i,V_{i,j}=0(i\ne j)$，$E$ 为无向图的邻接矩阵（当然关于对角线对称）。矩阵减法是指两个矩阵对应位置上的数相减，即 $L_{i,j}=V_{i,j}-E_{i,j}$。

### 2.余子式

一个矩阵同时去掉某些行、某些列后得到新矩阵的行列式的是他的一个余子式。

### 3.矩阵行列式

矩阵行列式 **针对的是一个 $n\times n$ 的矩阵**。其定义式为 
$$
\det(A)=\sum_p(-1)^{\tau(p)}\prod_{i=1}^n a_{i,p_i}
$$
其中 $p$ 为一个 $1\sim n$ 的全排列，$\tau(p)$ 表示 $p$ 的逆序对数。**$\det(A)$ 的另一种记法为 $|A|$**。

这个式子极少用来直接求解。对矩阵行列式的简单理解方式为 **一个矩阵的定义新运算“值”**。

#### 矩阵行列式性质

矩阵行列式经过矩阵初等变换后值会发生调整，具体地：

1. 交换矩阵的两行或两列，$\det(A')=-\det(A)$。
2. 交换矩阵的一行和一列，$\det(A’)=\det(A)$。
3. 矩阵的一行同 $\times k$，行列式同时 $\times k$。

$$
\begin{vmatrix}
        a_{1,1}  &a_{1,2}  &\cdots  &a_{1,n}\\
        a_{2,1}  &a_{2,2}  &\cdots  &a_{2,n}\\
        \vdots  &\vdots  &\ddots  &\vdots\\
        k\times a_{i,1}  &k\times a_{i,2}  &\cdots  &k\times a_{i,n}\\
        \vdots &\vdots  &\ddots  &\vdots\\
        a_{n,1} &a_{n,2} &\cdots &a_{n,n}\\
        \end{vmatrix}
        =k\times
        \begin{vmatrix}
        a_{1,1}  &a_{1,2}  &\cdots  &a_{1,n}\\
        a_{2,1}  &a_{2,2}  &\cdots  &a_{2,n}\\
        \vdots  &\vdots  &\ddots  &\vdots\\
        a_{i,1}  &a_{i,2}  &\cdots  &a_{i,n}\\
        \vdots  &\vdots  &\ddots  &\vdots\\
        a_{n,1} &a_{n,2} &\cdots &a_{n,n}\\
        \end{vmatrix}
$$

4. 矩阵的一行加上另一行的若干倍，行列式不变。

在这部分内容中，我们需要用到的是规律 1 和 4。

### 4.Matrix-Tree 定理

一个图的生成树个数为它的 Kirchhoff 矩阵的去掉第 $i$ 行、第 $i$ 列的余子式，$i$ 任意。

通常为了方便，我们选 $i=n$。

### 5.用高斯消元求矩阵行列式

在初学阶段，一些看起来 forbidding 的推导过程可能不利于理解，因此在这里直接摆结论：

- 求一个矩阵的行列式可以通过将它利用矩阵初等变换化为一个 *上三角矩阵* 后计算。
- 上三角矩阵的行列式等于其对角线的数乘积，即

![image.png](https://s2.loli.net/2021/12/27/NwgM6VYlcCXDfGQ.png)

而将一个一般的矩阵化为上三角矩阵，就可以通过高斯消元的方法。

下面展示出高斯消元求解线性方程组的核心代码。

```cpp
int a[N][N];
for(int i=1;i<=n;i++)
    for(int p=1;p<=n;p++)if(p!=i){
        double d=a[p][i]/a[i][i];
        for(int q=1;q<=n+1;q++)a[p][q]-=d*a[i][q];
    }
```

这里我们是用的小数，但是现在说在 $\bmod p$ 下的答案，就不能这么干了。于是我们项要求 $a[i][i]$ 的逆元，但这是不可能的因为有可能它没有逆元，而且里面的数一直在变会要求很多次也是不可能的。

这里介绍一种辗转相除的方法。你在求 gcd 的时候用过，但其实它的作用不止于求 gcd 还正可以用来消元！因为最后一定会有两数中的一个变成了 0，把这个 0 给到上面 $a[p][i]$ 的位置，就实现了消元，而在此过程中，我们不断地辗转相减第 $i,p$ 两行的数，进行矩阵初等变换，并适时调整 $\det$ 的值。具体见：

```cpp
for(int i=1;i<=n;i++)
    for(int j=i+1;j<=n;j++){
        while(a[i][i]){
            int d=a[j][i]/a[i][i];
            for(int k=1;k<=n;k++)a[j][k]=(a[j][k]-1ll*d*a[i][k]%mod+mod)%mod;
            swap(a[i],a[j]),det=-det;//交换两行，根据规律1，det要变成相反数
        }
        swap(a[i],a[j]),det=-det;
    }
```

这样一来求本题要求的生成数个数就不在话下了，代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,ans,m[18],e[18][18],cnt[18];
pair<int,int>q[18][180];
int sol(int s){
	memset(e,0,sizeof(e));
	for(int i=0;i<n-1;i++)if((s>>i)&1){
		for(int j=1;j<=m[i];j++)
			e[q[i][j].first][q[i][j].second]--,e[q[i][j].second][q[i][j].first]--,
			e[q[i][j].first][q[i][j].first]++,e[q[i][j].second][q[i][j].second]++;
	}
	int det=1;
	for(int i=1;i<n;i++)
		for(int j=i+1;j<n;j++){
			while(e[i][i]){
				int d=e[j][i]/e[i][i];
				for(int k=1;k<n;k++)e[j][k]=(e[j][k]-1ll*d*e[i][k]%mod+mod)%mod;
				swap(e[i],e[j]),det=-det;
			}
			swap(e[i],e[j]),det=-det;
		}
	for(int i=1;i<n;i++)det=1ll*det*e[i][i]%mod;
	return (det+mod)%mod;
}
int main(){
	cin>>n;
	for(int i=0;i<n-1;i++){
		cin>>m[i];
		for(int j=1;j<=m[i];j++)cin>>q[i][j].first>>q[i][j].second;
	}
	for(int i=0;i<(1<<(n-1));i++)(cnt[__builtin_popcount(i)]+=sol(i))%=mod;
	for(int i=n-1,j=1;~i;i--,j=-j)ans=((ans+j*cnt[i]%mod)%mod+mod)%mod;//注意这个地方，卡了我好久，一个取模都不能掉！
	cout<<ans;
}
```



---

## 作者：Jμdge (赞：2)

...

本来以为是道矩阵树板子题。。。不过依旧是大佬反手切的题...

woc 为什么，容斥？我还是萌新啊！


其实这道题就是容斥+矩阵树定理（好吧是行列式求解）

矩阵树定理不会的出门左转
，
容斥不会的...emmm


首先我们考虑这道题的数据范围怎么这么小...（好吧不需要考虑的这种题目 n 范围不会大的除非是压位）


那么容斥方法就是 n 个公司造路的方案数 - (n-1）个公司造路的方案数 + (n-2) 个公司造路的方案数 - ....

比较显然？

其实就是考虑 n 个公司造路（且每个公司各造一条）的方案数里面多出了 (n-1)
个公司造路（且每个公司各造一条）的方案数，以及 (n-2) 个公司造路（且每个公司各造一条）的方案数.....

然后可以容斥

这里可能要多想会儿~~（大佬一下就明白了）~~

其实就是 n-1 个公司可以有 n 种选的方案（$C_n^1$），然后它们之间有重叠的 n-2 的方案数，所以就要容斥了

```
//by Judge
#include<cstdio>
#include<iostream>
#define ll long long
using namespace std;
const int mod=1e9+7;
const int M=19;
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline void ADD(ll& a,ll b){a+=a+b>=mod?b-mod:b;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,up,siz[262143],m[M],u[M][M*M],v[M][M*M]; ll res,A[M][M];
inline ll qpow(ll x,ll p){ ll s=1;
	for(;p;p>>=1,x=x*x%mod)
		if(p&1) s=s*x%mod; return s;
}
inline ll det(){ ll res=1,tr=1;
	for(int i=1,j;i<n;++i){
		for(j=i;j<n&&!A[j][i];++j);
		if(j==n) return 0; res=res*A[j][i]%mod;
		if(i^j) swap(A[i],A[j]),tr=-tr;
		ll inv=qpow(A[i][i],mod-2);
		for(j=i+1;j<n;++j) A[i][j]=A[i][j]*inv%mod;
		for(j=i+1;j<n;++j) if(A[j][i])
			for(int k=i+1;k<=n;++k)
				ADD(A[j][k],mod-A[j][i]*A[i][k]%mod);
	} return (res*tr+mod)%mod;
}
int main(){ n=read(),up=(1<<n-1)-1;
	for(int i=1,j;i<n;++i)
		for(m[i]=read(),j=1;j<=m[i];++j)
			u[i][j]=read(),v[i][j]=read();
	for(int i=1;i<=up;++i)
		siz[i]=siz[i>>1]+(i&1);
	for(int i=1;i<=up;++i){
		for(int j=1;j<=n;++j)
			for(int k=1;k<=n;++k) A[j][k]=0;
		for(int j=1,p=i;p;p>>=1,++j)
			if(p&1) for(int k=1;k<=m[j];++k){
				int x=u[j][k],y=v[j][k];
				++A[x][x],++A[y][y];
				ADD(A[x][y],mod-1);
				ADD(A[y][x],mod-1);
			} res=(res+mod+(n-siz[i]&1?det():-det()))%mod;
	} return !printf("%lld\n",res);
}
```
---

然后其实行列式求解的方法很多的，这里的是比较快的一种方式（化为上三角矩阵）





---

## 作者：Leasier (赞：1)

前置芝士：[容斥原理](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/)、[矩阵树定理](https://oi-wiki.org/graph/matrix-tree/)

直接让生成树上每条边分别由不同的建筑公司建造较为困难，考虑容斥。

显然我们要求的是有**恰好** $0$ 个建筑公司没有参与边的贡献的方案数，设 $f_i$ 表示有**至少** $i$ 个建筑公司没有参与边的贡献的方案数，则答案为 $\displaystyle\sum_{i = 0}^{n - 1} (-1)^i f_i$。

显然对于 $f_i$，我们只需要枚举 $popcount(j) = n - i - 1$ 并通过矩阵树定理计算出只包含 $j$ 集合中的建筑公司的边的方案数，然后将方案数求和得到 $f_i$。

时间复杂度为 $O(2^{n - 1}(\sum m_i + n^3))$。

代码：
```cpp
#include <iostream>
#include <cstring>

using namespace std;

typedef long long ll;

typedef struct Matrix_tag {
	int n;
	ll a[17][17];
	Matrix_tag(){
		memset(a, 0, sizeof(a));
	}
} Matrix;

const int mod = 1e9 + 7;
int m[17], u[17][137], v[17][137];
ll val[65537];

inline ll quick_pow(ll x, ll p, ll mod){
	ll ans = 1;
	while (p){
		if (p & 1) ans = ans * x % mod;
		x = x * x % mod;
		p >>= 1;
	}
	return ans;
}

inline ll det(Matrix &a, int pos, int mod){
	ll ans = 1;
	for (register int i = 1; i <= a.n; i++){
		if (i == pos) continue;
		if (a.a[i][i] == 0){
			int t = i;
			for (register int j = i + 1; j <= a.n; j++){
				if (j == pos) continue;
				if (a.a[j][i] != 0){
					t = j;
					break;
				}
			}
			if (i == t) return 0;
			ans = (mod - ans) % mod;
			swap(a.a[i], a.a[t]);
		}
		ll cur_inv = quick_pow(a.a[i][i], mod - 2, mod);
		ans = ans * a.a[i][i] % mod;
		for (register int j = i + 1; j <= a.n; j++){
			if (j == pos) continue;
			ll t = cur_inv * a.a[j][i] % mod;
			for (register int k = i; k <= a.n; k++){
				a.a[j][k] = ((a.a[j][k] - t * a.a[i][k] % mod) % mod + mod) % mod;
			}
		}
	}
	return ans;
}

int main(){
	int n, k;
	ll ans = 0;
	cin >> n;
	k = (1 << (n - 1)) - 1;
	for (register int i = 1; i < n; i++){
		cin >> m[i];
		for (register int j = 1; j <= m[i]; j++){
			cin >> u[i][j] >> v[i][j];
		}
	}
	for (register int i = 0; i <= k; i++){
		Matrix a;
		a.n = n;
		for (register int j = 1; j < n; j++){
			if (i >> (j - 1) & 1){
				for (register int x = 1; x <= m[j]; x++){
					a.a[u[j][x]][u[j][x]] = (a.a[u[j][x]][u[j][x]] + 1) % mod;
					a.a[v[j][x]][v[j][x]] = (a.a[v[j][x]][v[j][x]] + 1) % mod;
					a.a[u[j][x]][v[j][x]] = ((a.a[u[j][x]][v[j][x]] - 1) % mod + mod) % mod;
					a.a[v[j][x]][u[j][x]] = ((a.a[v[j][x]][u[j][x]] - 1) % mod + mod) % mod;
				}
			}
		}
		val[i] = det(a, 1, mod);
	}
	for (register int i = 0; i < n; i++){
		int t = n - i - 1;
		ll sum = 0;
		for (register int j = 0; j <= k; j++){
			if (__builtin_popcount(j) == t) sum = (sum + val[j]) % mod;
		}
		ans = ((ans + (i % 2 == 0 ? 1 : -1) * sum % mod) % mod + mod) % mod;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：撤云 (赞：1)

[$blog$](https://www.cnblogs.com/hbxblog/p/10332490.html)
### $Describe$
> $n-1$个公司,每个公司能修一些边,求每条边都让不同的公司来修的生成树的方案数

### $Solution$

这道题很明显容斥.答案就是:所有都选的生成树个数$-$一个没选的生成树个数$+$两个没选的生成树个数$-...$  

至于生成树个数怎么算,用$Matrix - Tree$矩阵树定理做就好了  
如果不会:[传送门](http://baidu.physton.com/?q=矩阵树定理)

### $Code$
``` cpp
#include<bits/stdc++.h>
#define int long long
#define rg register
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
const int mod=1e9+7;
int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return f*x;
}
int a[21][21],len[1001],f[1001][1001],vis[1001][1001],n,ans,bj[10001];
void init(){
	memset(a,0,sizeof(a));
    for(int i=1;i<n;i++)
        if(bj[i])
            for(int j=1;j<=len[i];j++)
                ++a[f[i][j]][f[i][j]],++a[vis[i][j]][vis[i][j]],--a[f[i][j]][vis[i][j]],--a[vis[i][j]][f[i][j]];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            a[i][j]=(a[i][j]+mod)%mod;
}
int ksm(int a,int b){
	int ans=1;
	while(b){
		if(b&1)
			ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}
int work(){
	init();
	int js=1;
    for(int i=2;i<=n;i++){
		int inv=ksm(a[i][i],mod-2);
        for(int j=i+1;j<=n;j++)
            while(a[j][i]){
                int x=a[j][i]*inv%mod;
                for(int k=i;k<=n;k++)
                    a[j][k]=(a[j][k]-x*a[i][k]%mod+mod)%mod,swap(a[i][k],a[j][k]);
            }
        js=js*a[i][i]%mod;
    }
    return js%mod;
}
void dfs(int x,int opt){
    if(x==n){
		(opt&1)?ans-=work():ans+=work(),ans=(ans+mod)%mod;
        return;
    }
    bj[x]=1;dfs(x+1,opt),bj[x]=0;dfs(x+1,opt+1);
}
main(){
	n=read();
	for(int i=1;i<n;i++){
		len[i]=read();
		for(int j=1;j<=len[i];j++)
			f[i][j]=read(),vis[i][j]=read();
	}
	dfs(1,0);
	printf("%lld",ans);
}
```

---

## 作者：Umbrella_Leaf (赞：0)

矩阵树定理板子（

### 题意

> 给你 $n$，有 $n-1$ 组边，每组边中选一个，求将 $n$ 个点刚好连通的方案数。$2\le n\le 17$。

### 题解

容斥，钦定一个边组的子集 $S$ 表示边只能在这个子集里选（可以在一个组重复选），那么容斥系数是 $(-1)^{n-1-|S|}$。

因为刚好有 $n-1$ 个组，所以可不可以在一个组重复选对最终答案没有影响。

方案数就是将这些组的边全部连起来之后的生成树个数，那么可以使用矩阵树定理求一个图的生成树个数。

重边直接加，不用去重。

时间复杂度 $O(2^nn^3)$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll mod=1e9+7;
int n;
vector<pair<int,int> >edge[20];
ll a[20][20];
ll power(ll a,ll p){
	ll res=1;
	while(p){
		if(p&1)res=res*a%mod;
		p>>=1;
		a=a*a%mod;
	}
	return res;
}
ll gauss(){
	ll res=1;
	for(int i=1;i<n;i++){
		int p=0;
		for(int j=i;j<n;j++)if(a[j][i]){p=j;break;}
		if(!p)return 0;
		if(p!=i)res=(mod-res)%mod;
		for(int j=i;j<n;j++)swap(a[i][j],a[p][j]);
		ll val=power(a[i][i],mod-2);
		res=res*a[i][i]%mod;
		for(int j=i;j<n;j++)a[i][j]=a[i][j]*val%mod;
		for(int j=i+1;j<n;j++){
			val=a[j][i];
			for(int k=i;k<n;k++)a[j][k]=(a[j][k]-val*a[i][k]%mod+mod)%mod;
		}
	return res;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int k;scanf("%d",&k);
		while(k--){
			int x,y;scanf("%d%d",&x,&y);
			edge[i].push_back(make_pair(x,y));
		}
	}
	ll ans=0;
	for(int i=1;i<(1<<n-1);i++){
		memset(a,0,sizeof(a));
		int cnt=0;
		for(int j=1;j<n;j++)
			if(i&(1<<j-1))
				for(auto e:edge[j])a[e.first][e.first]++,a[e.second][e.second]++,a[e.first][e.second]--,a[e.second][e.first]--;
			else cnt++;
		for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)a[i][j]=(a[i][j]%mod+mod)%mod;
		if(cnt&1)ans=(ans-gauss()+mod)%mod;
		else ans=(ans+gauss())%mod;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Mars_Dingdang (赞：0)

容斥加矩阵树好题。

## 题目大意
给定一张 $n$ 个节点的图，和 $n-1$ 种边，每种边的数量 $m_i\le \dfrac{n(n-1)}2$，请求出原图包含每种边恰好一次的生成树的个数，答案对 $10^9+7$ 取模。

## 大体思路
首先，看到生成树，考虑使用矩阵树定理，这也是本题的前置知识。

Matrix-Tree 定理是解决生成树计数问题最有力的武器之一。它首先于 $1847$ 年被基尔霍夫证明。下面定义两种矩阵：

1. $G$ 的度数矩阵 $D_G$ 是一个 $n\times n$ 的矩阵，并且满足：当 $i≠j$ 时, $d_{i,j}=0$；当 $i=j$ 时，$d_{i,j}$ 等于 $i$ 的度数。

2. $G$ 的邻接矩阵 $A_G$ 也是一个 $n\times n$ 的矩阵， 并且满足：如果 $i, j$ 之间有边直接相连，则 $a_{i,j}=1$，否则为 $0$。**注意，对于 $i=j$ 的情况，是为两者之间没有边，即 $a_{i, i}=0$。**

我们定义 $G$ 的基尔霍夫矩阵 $C_G=D_G-A_G$，则 Matrix-Tree 定理可以描述为：$G$ 的所有不同的生成树的个数等于其基尔霍夫矩阵任何一个 $n-1$ 阶主子式的行列式的绝对值。($n-1$ 阶主子式就是对于 $r\in [1, n]$，将 $C_G$ 的第 $r$ 行、第 $r$ 列同时去掉后得到的新矩阵，用 $C_{rG}$ 表示）。这一结论可以利用数学归纳法证明，详细请见 $2007$ 年国家集训队论文《生成树的计数及其应用》

那么，我们只需要根据要求求出原图的基尔霍夫矩阵，并使用类似高斯消元的方法对 [行列式求值](https://www.luogu.com.cn/problem/P7112) 即可。时间复杂度约为 $\Theta(n^3)$，辗转相除可能会产生一个 $\log n$。

回到本题。我们知道了如何求解一个图的生成树。那么，根据容斥，设 $T_i$ 表示至少 $i$ 种边不选的生成树的数量，因此答案即为 
$$\sum_{i=0}^{n-1}(-1)^i\cdot T_i$$
具体计算时，可以用一个 $n-1$ 位二进制数枚举每种边选或不选，用矩阵树定理算出这种情况下生成树的个数，并根据容斥，依据二进制数 $1$ 的个数（可递推计算）加上或减去相应的贡献即可。

记 $N=n-1$，单次矩阵树定理的复杂度为 $\Theta\left(N^3\right)$，枚举状态的复杂度为 $O(2^{N})$，总复杂度为 $O(2^{N}N^3)$，在 $N\le 16$ 时计算次数上限为 $O(2.7\times 10^8)$，消元的实际效率更快可过。注意每次清空基尔霍夫矩阵。

## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int maxn = 20, mod = 1e9 + 7;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
ll n, a[maxn][maxn], m[maxn], ans;
PII e[maxn][maxn * maxn];
int cnt[1 << 17];
inline ll Guass() {
	ll res = 1, w = 1;
	rep(i, 2, n)
		rep(j, i + 1, n) {
			while(a[i][i]) {
				ll factor = a[j][i] / a[i][i];
				rep(k, i, n)
					a[j][k] = (a[j][k] - factor * a[i][k] % mod + mod) % mod;
				swap(a[i], a[j]), w = -w;
			}
			swap(a[i], a[j]), w = -w;
		}
	rep(i, 2, n) (res *= a[i][i]) %= mod;
	return (res * w + mod) % mod;
}
int main () {
	read(n);
	rep(i, 1, n - 1) {
		read(m[i]);
		rep(j, 1, m[i]) read(e[i][j].first), read(e[i][j].second);
	}
	for(int S = 1; S < (1 << (n - 1)); S ++) 
		cnt[S] = cnt[S >> 1] + (S & 1);
	for(int S = 1; S < (1 << (n - 1)); S ++) {
		int dlt = n-1 - cnt[S]; // 偶数＋，奇数-
		rep(i, 1, n) rep(j, 1, n) a[i][j] = 0;
		rep(i, 1, n - 1) if((S >> (i - 1)) & 1){
			rep(j, 1, m[i]) {
				int u = e[i][j].first, v = e[i][j].second;
				a[u][u] ++, a[v][v] ++;
				a[u][v] --, a[v][u] --;
			}
		}
		ans += Guass() * ((dlt & 1) ? -1 : 1);
		ans = (ans + mod) % mod;
	}
	writeln(ans);
	return 0;
}
```

---

## 作者：Refined_heart (赞：0)

少有的自己逐渐发现了容斥思路的题……

题目大意：要求原无向图的生成树个数，满足每条边被建立的公司不同。

$\text{Solution:}$

观察到了我们有 $n-1$ 个公司，所以在题目的限制下，满足条件的生成树恰好所有公司都参与。所以我们不需要考虑每条边了，直接考虑：对当前情况下 **有 $x$ 个公司参与的生成树个数** 。这样只要我们求出对应 $n-1$ 情况下的答案，那它直接就是答案了。

那么回到原来的问题，为什么直接忽略公司对原图跑 Matrix-Tree 定理不对呢？这样的答案中 **包含了许多 $n-1$ 个公司中的子集。** 那么思路就变成了：如何把这些不合法的子集去掉呢？结合 $n\leq 17$ 的数据范围也就自然想到了状压枚举子集的容斥思路。

仔细思考一下，我们想要枚举一些公司使得它们 **每一个** 都要参与到生成树中。但实际上这个问题也是困难的，那不妨先搁置一下，来想一想容斥的想法：

显然我们可以用总的减去算重的：枚举参加了多少公司，则：

$$
Ans=\sum_{n-1}f_i-\sum_{n-2}f_i+\sum_{n-3}f_i...
$$

容斥系数就和枚举到的公司数奇偶性有关系。

那么，这个式子是对于强制了多少公司都参与的情况下成立的，刚刚我们说即使这样算，算到的结果也包含了对应这些公司的子集。那么怎么算呢？

其实按照上面这个式子上去算也是对的，因为在每一步加减的过程中，比当前枚举到的更小的子集都被抵消掉了，不理解的话可以手推一下，由于恰好抵消，所以我们直接这样枚举容斥就是对的。

于是我们就可以套用矩阵树定理了。注意到有重边的情况，由于这种重边一定来自于两个不同的公司，所以我们不能把它删掉，直接加进去就是对的。

顺便再提一句矩阵树定理：基尔霍夫矩阵是用 **度数矩阵** 减去 **邻接矩阵**，求出的结果是：所有生成树边权之积的和。

那么求方案数的时候，只需要令乘积为 $1\to$ 令边权为 $1$ 即可。

复杂度 $O(2^n\cdot n^3),$ 跑的还是蛮快的。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
const int N=20;
inline int Add(int x,int y){return (x+y)%mod;}
inline int Mul(int x,int y){return 1ll*x*y%mod;}
inline int Dec(int x,int y){return (x-y+mod)%mod;}
inline int Max(int x,int y){return x>y?x:y;}
inline int Min(int x,int y){return x<y?x:y;}
inline int Abs(int x){if(x<0)x=-x;return x;}
inline int qpow(int x,int y){
    int res=1;
    while(y){
        if(y&1)res=Mul(res,x);
        x=Mul(x,x);y>>=1;
    }
    return res;
}
inline int getinv(int x){return qpow(x,mod-2);}
inline int read(){
    int s=0;
    char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch)){
        s=s*10+ch-'0';
        ch=getchar();
    }
    return s;
}
typedef pair<int,int> pr;
#define fi first
#define se second
#define mp make_pair
int n,m[N];
vector<pr>edge[N];
struct Matrix{
    int a[N][N];
    Matrix(){memset(a,0,sizeof a);}
    int MatrixTree(int L){
        int res=1;
        for(int i=L;i<=n;++i){
            int pos=i;
            for(int j=i+1;j<=n;++j)
                if(a[pos][i]<a[j][i])
                    pos=j;
            if(i!=pos)res=Mul(res,mod-1),swap(a[i],a[pos]);
            int div=getinv(a[i][i]);
            res=Mul(res,a[i][i]);
            for(int j=i;j<=n;++j)a[i][j]=Mul(a[i][j],div);
            for(int j=i+1;j<=n;++j){
                div=a[j][i];
                for(int k=i;k<=n;++k)a[j][k]=Dec(a[j][k],Mul(div,a[i][k]));
            }
        }
        for(int i=L;i<=n;++i)res=Mul(res,a[i][i]);
        return res;
    }
};
int f[1<<N];
Matrix GetMatrix(int state){
    Matrix A;
    for(int i=0;i<n-1;++i){
        if(!(state>>i&1))continue;
        for(auto j:edge[i]){
            int u=j.fi;
            int v=j.se;
            A.a[u][u]=Add(A.a[u][u],1);
            A.a[v][v]=Add(A.a[v][v],1);
            A.a[u][v]=Dec(A.a[u][v],1);
            A.a[v][u]=Dec(A.a[v][u],1);
        }
    }
    return A;
}
inline int lowbit(int x){return x&(-x);}
inline int popcount(int x){
    int res=0;
    while(x){
        res++;
        x-=lowbit(x);
    }
    return res;
}
int sum[N],Ans;
int main(){
    n=read();
    for(int i=0;i<n-1;++i){
        m[i]=read();
        for(int j=0;j<m[i];++j){
            int u=read(),v=read();
            edge[i].push_back(mp(u,v));
        }
    }
    for(int i=0;i<(1<<(n-1));++i){
        Matrix A=GetMatrix(i);
        f[i]=A.MatrixTree(2);
    }
    for(int i=0;i<(1<<(n-1));++i){
        int num=popcount(i);
        sum[num]=Add(sum[num],f[i]);
    }
    int opt=(n-1)&1;
    for(int i=n-1;i>=1;--i){
        int op=i&1;
        if(op==opt)Ans=Add(Ans,sum[i]);
        else Ans=Dec(Ans,sum[i]);
    }
    printf("%d\n",Ans);
    return 0;
}
```


---

## 作者：楠枫 (赞：0)

## 题解

**前置芝士** :矩阵树定理

本题是一道计数题，有两个要求：

1. 建造的公路构成一颗生成树

2. 每条公路由不同的公司建造，每条公路与一个公司一一映射

那么看到这两个要求后，我们很容易想到第一个条件用矩阵树定理，那么对于第二个条件，我们就很容易想到容斥原理。

先不考虑第二个条件，把所有边都加进去（没有自环），这是我们用矩阵树原理算出来的结果不仅有 $n-1$ 个公司建造的方案，也包括了 $(n-2)...1$ 个公司建造的方案。

此时，我们需要减去 $n-2$ 个公司建造的方案，那么这里我们就把其中一个公司去掉，再进行计算，注意这里去掉一个公司有 $n-1$ 种方案。

但是我们会发现 $n-3$ 个公司建造的方案被重复减去了，所以我们需要加回来，至此，就是一个纯的容斥了。

对于删去不同的公司，计算不同的方案，我们可以用二进制压一下 $n-1$ ，二进制每一位 $1$ 代表选取这一位代表的公司。

而在求解行列式的过程中，我们可以直接利用逆元进行求解，也可以辗转相除。

所以最后前一种复杂度为 $\mathcal O(2^{n-1}((n-1)^3+(n-1)log(1e9+7)))$   

后一种的复杂度为 $\mathcal O(2^{n-1}(n-1)^3logn)$ 。

逆元 $AC \kern 0.4em CODE:$
```cpp
#include<bits/stdc++.h>
#define ri register signed
#define p(i) ++i
using namespace std;
namespace IO{
    char buf[1<<21],*p1=buf,*p2=buf;
    #define gc() p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++
    inline int read() {
        ri x=0,f=1;char ch=gc();
        while(ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=gc();}
        while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=gc();}
        return x*f; 
    }
}
using IO::read;
namespace nanfeng{
    #define lm(x) (1<<x)
    #define lowbit(x) (x&-(x))
    #define cmax(x,y) ((x)>(y)?(x):(y))
    #define cmin(x,y) ((x)>(y)?(y):(x))
    #define FI FILE *IN
    #define FO FILE *OUT
    typedef long long ll;
    static const int N=20,MOD=1e9+7;
    int num[N],u[N][N*N],v[N][N*N],G[N][N],siz[lm(16)+7],lg[lm(16)+7]={-1},n,cnt,st,ans;
    inline void add(int u,int v) {p(G[u][v]),p(G[v][u]);}
    inline int fpow(int x,int y) {
        int res=1;
        while(y) {
            if (y&1) res=1ll*res*x%MOD;
            x=1ll*x*x%MOD;y>>=1;
        }
        return res;
    }
    inline int Gauss() {
        int res=1,tr=0;
        for (ri i(1);i<=cnt;p(i)) {
            for (ri j(i+1);j<=cnt;p(j)) if (G[j][i]) {swap(G[i],G[j]);tr^=1;break;} 
            int inv=fpow(G[i][i],MOD-2);
            for (ri j(i+1);j<=cnt;p(j)) {
                int tmp=1ll*inv*G[j][i]%MOD;
                for (ri k(i+1);k<=cnt;p(k)) G[j][k]=(G[j][k]-1ll*G[i][k]*tmp%MOD+MOD)%MOD;
            }
            if (!G[i][i]) return 0;
            res=1ll*res*G[i][i]%MOD;
        }
        return tr?-res:res;
    }
    inline int main() {
        // FI=freopen("nanfeng.in","r",stdin);
        // FO=freopen("nanfeng.out","w",stdout);
        n=read(),cnt=n-1;st=(1<<n-1)-1;
        for (ri i(1);i<=st;p(i)) siz[i]=siz[i>>1]+(i&1),lg[i]=lg[i>>1]+1;
        for (ri i(1);i<n;p(i)) {
            num[i]=read();
            for (ri j(1);j<=num[i];p(j)) u[i][j]=read(),v[i][j]=read();
        }
        for (ri i(1);i<=st;p(i)) {
            int low=i;
            memset(G,0,sizeof(G));
            while(low) {
                int id=lg[lowbit(low)]+1;
                for (ri j(1);j<=num[id];p(j)) add(u[id][j],v[id][j]);
                low-=lowbit(low);
            }
            for (ri j(1);j<=n;p(j)) {
                for (ri k(1);k<=n;p(k)) if (j^k) G[j][j]+=G[j][k],G[j][k]=-G[j][k];
            }
            // for (ri j(1);j<=n;p(j)) {
            //     for (ri k(1);k<=n;p(k)) printf("%d ",G[j][k]);
            //     puts("");
            // }
            int tmp=(Gauss()+MOD)%MOD;
            // printf("state=%d tmp=%d\n",i,tmp);
            ans=((ll)ans+MOD+((n-siz[i])&1?tmp:-tmp))%MOD;
        }
        printf("%d\n",ans);
        return 0;
    }
}
int main() {return nanfeng::main();}
```
理论上说辗转向除法复杂度高，但本题数据不大，也没问题

[Code](https://www.cnblogs.com/nanfeng-blog/p/14880720.html)

---

## 作者：crashed (赞：0)

# 题目
&emsp;&emsp;[点这里](https://www.luogu.com.cn/problem/P4336)看题目。  
# 分析
&emsp;&emsp;看到 n 很小，限制条件又这么复杂，显然可以直接容斥。     
&emsp;&emsp;我们实际上只需要保证每个公司都有边可以修建（树的性质保证最终每个公司有且仅有一条边可以修建）。因此不难有容斥：    
$$
\begin{aligned}
f(k):&\text{有}k\text{个公司没有边修建的方案数}\\
ans=&\sum_{i=0}^{n-1}(-1)^if(i)
\end{aligned}
$$   
&emsp;&emsp;而所有的$f$都可以一遍枚举子集计算。时间复杂度$O(2^nn^3)$。看着慢，跑着还不错。      
# 代码
```cpp
#include <cstdio>
#include <iostream>

const int mod = 1e9 + 7;
const int MAXN = 25, MAXM = 17 * 17, MAXS = ( 1 << 17 ) + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

int D[MAXN][MAXN], K[MAXN][MAXN], G[MAXN][MAXN];
int M[MAXN], fr[MAXN][MAXM], to[MAXN][MAXM];
int N;

int qkpow( int base, int indx )
{
	int ret = 1;
	while( indx )
	{
		if( indx & 1 ) ret = 1ll * ret * base % mod;
		base = 1ll * base * base % mod, indx >>= 1;
	}
	return ret;
}

int inv( const int a ) { return qkpow( a, mod - 2 ); }

int det( int T[MAXN][MAXN], const int n )
{
	int indx, ret = 1, tmp, inver;
	for( int i = 1 ; i <= n ; i ++ )
	{
		indx = -1;
		for( int j = i ; j <= n ; j ++ )
			if( T[j][i] )
			{ indx = j; break; }
		if( indx == -1 ) return 0;
		if( indx ^ i ) ret = mod - ret;
		std :: swap( T[i], T[indx] );
		inver = inv( T[i][i] );
		for( int j = i + 1 ; j <= n ; j ++ )
			if( T[j][i] )
			{
				tmp = 1ll * T[j][i] * inver % mod;
				for( int k = i ; k <= n ; k ++ )
					T[j][k] = ( T[j][k] - 1ll * T[i][k] * tmp % mod + mod ) % mod;
			}
		ret = 1ll * ret * T[i][i] % mod;	
	}
	return ret;
}

int MatrixTree()
{
	for( int i = 1 ; i <= N ; i ++ )
	{
		D[i][i] = 0;
		for( int j = 1 ; j <= N ; j ++ )
			D[i][i] += G[j][i];
	}
	for( int i = 1 ; i <= N ; i ++ )
		for( int j = 1 ; j <= N ; j ++ )
			K[i][j] = ( D[i][j] - G[i][j] + mod ) % mod;
	return det( K, N - 1 );
}

int main()
{
	read( N );
	for( int i = 1 ; i < N ; i ++ ) 
	{
		read( M[i] );
		for( int j = 1 ; j <= M[i] ; j ++ )
			read( fr[i][j] ), read( to[i][j] ), 
			G[fr[i][j]][to[i][j]] ++, G[to[i][j]][fr[i][j]] ++;
	}
	int upper = 1 << N - 1, coe, ans = 0;
	for( int S = 0 ; S < upper ; S ++ )
	{
		coe = 1;
		for( int i = 1 ; i < N ; i ++ )
			if( S & ( 1 << i - 1 ) )
			{
				for( int j = 1 ; j <= M[i] ; j ++ )
					G[fr[i][j]][to[i][j]] --, G[to[i][j]][fr[i][j]] --;
				coe = mod - coe;
			}
		ans = ( ans + 1ll * coe * MatrixTree() % mod ) % mod;
		for( int i = 1 ; i < N ; i ++ )
			if( S & ( 1 << i - 1 ) )
				for( int j = 1 ; j <= M[i] ; j ++ )
					G[fr[i][j]][to[i][j]] ++, G[to[i][j]][fr[i][j]] ++;
	}
	write( ans ), putchar( '\n' );
	return 0;
}
``` 

---

## 作者：ezoiHQM (赞：0)

这道题的解法十分暴力。

我们发现$n$的范围很小，所以我们可以考虑状压。

每一个状态$i$表示当前计算的生成树数量包含哪些颜色

根据容斥原理可得：最后的答案就是：任取$-$一种颜色不选$+$两种颜色不选$-$......

统计每个状态的答案用矩阵树定理+高斯消元即可

时间复杂度$O(2^nn^3)$
代码：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int mod=1e9+7;
int n,ans,m[20],edge[410][410][2],a[20][20];
int qpow(int x,int n){
	int ret=1;
	while(n){
		if(n&1)
			ret=1ll*ret*x%mod;
		x=1ll*x*x%mod;
		n>>=1;
	}
	return ret;
}
int gauss(int n){
	int ret=1;
	for(int i=1;i<n;i++){
		for(int j=i+1;j<=n;j++){
			if(!a[i][i])
				return 0;
			if(!a[j][i])
				continue;
			int tmp=1ll*a[j][i]*qpow(a[i][i],mod-2)%mod;
			for(int k=i;k<=n;k++){
				a[j][k]-=1ll*a[i][k]*tmp%mod;
				if(a[j][k]<0)
					a[j][k]+=mod;
			}
		}
	}
	for(int i=1;i<=n;i++)
		ret=1ll*ret*a[i][i]%mod;
	return ret;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		scanf("%d",m+i);
		for(int j=1;j<=m[i];j++)
			scanf("%d%d",edge[i][j],edge[i][j]+1);
	}
	for(int i=0;i<(1<<(n-1));i++){
		memset(a,0,sizeof(a));
		int f=1;
		for(int j=1;j<n;j++){
			if(i&(1<<(j-1))){
				for(int k=1;k<=m[j];k++){
					a[edge[j][k][0]][edge[j][k][1]]--;
					a[edge[j][k][1]][edge[j][k][0]]--;
					a[edge[j][k][0]][edge[j][k][0]]++;
					a[edge[j][k][1]][edge[j][k][1]]++;
				}
			}
			else f=-f;
		}
		for(int j=1;j<=n;j++)
			for(int k=1;k<=n;k++)
				if(a[j][k]<0)
					a[j][k]+=mod;
		ans+=f*gauss(n-1);
		if(ans<0)
			ans+=mod;
		if(ans>=mod)
			ans-=mod;
	}
	printf("%d",ans);
	return 0;
}
```

---


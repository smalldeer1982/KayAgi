# [AHOI2018初中组] 球球的排列

## 题目描述

小可可是一个有着特殊爱好的人。他特别喜欢收集各种各样的球球，至今已经收集了$n$ 个球球。

小可可又是一个有着特殊想法的人。他将他的所有球球从 1 到$n$ 编号，并每天都把球球排成一个全新的排列。

小可可又是一个有着特殊情怀的人。他将每个球球的特点用$a[i]$来表示（注意这里不同的球$a[i]$可能相同）。

小可可又是一个爱恨分明的人。他十分讨厌平方数，所以他规定：一个排列$p$，对于所有的$1 ≤ i < n$，$a[p_i]\times a[p_{i+1}]$ 不是一个平方数，这样的排列$p$ 才是合法的。

小可可一直坚持每天排一个全新的合法的排列。有一天，他心血来潮，想知道所有合法排列的个数。小可可十分强，他当然知道怎么算。不过，他想用这个题来考考身在考场的你。这个数可能太大了，所以你只需要告诉小可可合法排列个数对$10^9+7$ 取模的结果就可以了。

你能正确回答小可可的问题吗？如果能的话，他说不定会送个球球给你呢……

## 说明/提示

【样例1 解释】
12 种合法的排列分别为：
```
1,3,2,4
2,3,1,4
3,1,4,2
3,2,4,1
1,3,4,2
2,3,4,1
1,4,2,3
2,4,1,3
4,1,3,2
4,2,3,1
1,4,3,2
2,4,3,1
```

【数据范围】

对于100%的数据满足：$1≤n≤300$，$1≤a[i]≤10^9$。

本题共10 个测试点，编号为1~10，每个测试点额外保证如下：

测试点编号| n的范围|a[i]的范围
-|-|-
1~2|$n≤10$|$a[i]≤10^9$
3~5|$n≤300$|$1≤a[i]≤2$
6~8|-|$a[i]≤10^9$且都是质数
9~10|-|$a[i]≤10^9$

## 样例 #1

### 输入

```
4
2 2 3 4```

### 输出

```
12
```

## 样例 #2

### 输入

```
9
2 4 8 9 12 4 3 6 11```

### 输出

```
99360```

# 题解

## 作者：xcxcli (赞：55)

真是一道毒瘤的好[题](https://www.luogu.com.cn/problem/P4448)！

### step1 预处理

设有三个正整数 $x,y,z$，满足 $xy=p^2,xz=q^2$，那么 $yz=(\frac{pq}x)^2$，也是完全平方数。

所以我们得到，若 $i,j$ 和 $j,k$ 不能相邻，则 $i,k$ 也不能相邻。所有球之间的不能相邻的关系构成了多个完全图。我们可以利用并查集合并每个图上的球。

那么我们将题意转化为：

>有 $m$ 种颜色的球，第 $i$ 种颜色的球有 $s_i$ 个，求同色不相邻的排列的数量。

<!-- more -->

最后将球按颜色排序，本题的预处理就完成了。
### step2 DP
本题的毒瘤之处就在与状态和转移。

先看状态定义：

> $f[i][j][k]$ 表示在前 $i$ 个球的排列中，满足颜色不等于第 $i$ 个球且同色相邻的有 $j$ 对，颜色等于第 $i$ 个球且相邻的有 $k$ 对时，排列的方案数。

看到这里晕头转向的同学，这里有图让你清醒：

![](https://cdn.luogu.com.cn/upload/image_hosting/ge5w9z96.png)

容易得到答案就是 $f[n][0][0]$。

下面为大家一条一条讲解状态转移方程。

**转移1**

> 第 $i$ 个球与第 $i-1$ 个球颜色不同，将该球放于两个异色球之间（包括排列的开头和结尾）。

因为我们之前已经按颜色排序了，所以第 $i$ 个球的颜色还是第一次出现。如下图，$i=6,j=2,k=0$，此前的状态为 $i'=5=i-1,j'=1,k'=1=j-j'$（与 $i-1$ 不同色的连续块数 $=$ 现在的连续块数 $-$ 与 $i-1$ 同色的连续块数）。可以插入的位置数有$i-j=4$个。

所以 $f[i][j][0]+=f[i-1][j'][j-j']*(i-j)\quad j'\in[0,j]$

![](https://cdn.luogu.com.cn/upload/image_hosting/xcaof8eo.png)

**转移2**

> 第 $i$ 个球与第 $i-1$ 个球颜色不同，将该球放于两个同色球之间。

如下图，$i=6,j=1,k=0$，此前的状态为 $i'=5=i-1,j'=1,k'=1=j-j'+1$，可以插入的位置有 $j+1=2$ 个。

所以 $f[i][j][0]+=f[i-1][j'][j-j'+1]*(j+1)\quad j'\in[0,j+1]$

![](https://cdn.luogu.com.cn/upload/image_hosting/2ur9u7cq.png)

**转移3**

> 第 $i$ 个球与第 $i-1$ 个球颜色相同，将该球放于与该球颜色相同的球旁边。

为了方便，设到第 $i-1$ 个球有 $cnt$ 个与 $i$ 球颜色相同的球。如下图，$i=7,j=1,k=2,cnt=3$，此前的状态为 $i'=6=i-1,j'=1=j,k'=1=k-1$，符合条件的位置有 $cnt*2=6$ 个，但有 $k'=1$ 个位置重复了，所以可以插入的位置有 $cnt*2-k'=cnt*2-k+1=5$ 个。

所以 $f[i][j][k]+=f[i-1][j][k-1]*(cnt*2-k+1)\quad k\in[1,cnt]$

![](https://cdn.luogu.com.cn/upload/image_hosting/9591j8p4.png)

**转移4**

> 第 $i$ 个球与第 $i-1$ 个球颜色相同，将该球放于两个同色球之间。

如下图，$i=7,j=0,k=1,cnt=3$，此前的状态为 $i'=6=i-1,j'=1=j+1,k'=1=k$，可以插入的位置有 $j'=j+1=1$ 个。

所以 $f[i][j][k]+=f[i-1][j+1][k]*(j+1)\quad k\in[0,cnt]$

![](https://cdn.luogu.com.cn/upload/image_hosting/sg3esezo.png)

**转移5**

> 第 $i$ 个球与第 $i-1$ 个球颜色相同，将该球放于两个异色球之间。

如下图，$i=7,j=1,k=1,cnt=3$，此前的状态为 $i'=6=i-1,j'=1=j,k'=1=k$，可以插入的位置等于所有位置减去前面两种： $i-(cnt*2-k')-j'=i-cnt*2+k'-j'=i-cnt*2+k-j=1$。

所以 $f[i][j][k]+=f[i-1][j][k]*(i-cnt*2+k-j)\quad k\in[0,cnt]$

![](https://cdn.luogu.com.cn/upload/image_hosting/yn1bkj10.png)
### step3 复杂度、细节与代码
本题的时间复杂度为 $O(n^3)$，空间复杂度为 $O(n^3)$。下面的代码使用了滚动数组，将空间复杂度优化为 $O(n^2)$。

Code:

```cpp
#include<stdio.h>
#include<math.h>
#include<string.h>
#include<algorithm>
#define ll long long
int rd(){
	int k=0;char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
	return k;
}
const int N=301,M=1000000007;
int n,a[N],b[N],now=1,pre,cnt,f[2][N][N];//now,pre表示i和i-1的状态
bool sqr(ll x){ll S=sqrt(x);return S*S==x;}
int main(){
	freopen("data.in","r",stdin);
	freopen("data.out","w",stdout);
	n=rd();
	for(int i=1;i<=n;++i){
		a[i]=rd(),b[i]=i;
		for(int j=1;j<i;++j)if(sqr((ll)a[i]*a[j])){b[i]=j;break;}
	}//实际我们并不需要并查集，只用将父亲设为第一个匹配成完全平方数的数
	std::sort(b+1,b+n+1),f[0][0][0]=1;//初始化
	for(int i=1;i<=n;++i){
		memset(f[now],0,sizeof(f[now]));//滚动数组清空
		if(b[i]!=b[i-1]){
			cnt=0;//将与i相同的数的个数清空
			for(int j=0;j<i;++j)
				for(int k=0;k<=j+1;++k){//这里本来要枚举j'，为了方便写作k
					if(k<=j)f[now][j][0]=(f[now][j][0]+(ll)f[pre][k][j-k]*(i-j))%M;//注意边界
					f[now][j][0]=(f[now][j][0]+(ll)f[pre][k][j-k+1]*(j+1))%M;
				}
		}
		else{
			for(int j=0;j<i;++j)
				for(int k=0;k<=cnt;++k){
					if(k>0)f[now][j][k]=(f[now][j][k]+(ll)f[pre][j][k-1]*(cnt*2-k+1))%M;//注意边界
					f[now][j][k]=(f[now][j][k]+(ll)f[pre][j+1][k]*(j+1))%M;
					f[now][j][k]=(f[now][j][k]+(ll)f[pre][j][k]*(i-cnt*2+k-j))%M;
				}
		}
		now^=1,pre^=1,++cnt;//滚动
	}
	printf("%d\n",f[pre][0][0]);
	return 0;
}

```
### step4 进阶算法
时隔一年重看这题，终于学会了容斥的 $O(n^2)$ 算法。

记颜色数为 $m$，第 $t$ 种颜色的球数量为 $s_t$。考虑所有合法与不合法情况，将相同颜色的球合并为一块，设合并后第 $t$ 种颜色的球块数为 $b_t$，记 $B=\sum\limits_{t=1}^mb_t$。

此时第 $t$ 种颜色的内部方案数为 $s_t!\binom{s_t-1}{b_t-1}$，即 $s_t$ 的任意排列乘上 $s_t$ 个球分为 $b_t$ 块的方案数。再考虑块之间的方案数量为 $\dfrac{B!}{\prod\limits_{t=1}^m(b_t!)}$，得到的结果为 $\dfrac{B!}{\prod\limits_{t=1}^m(b_t!)}\cdot\prod\limits_{t=1}^ms_t!\binom{s_t-1}{b_t-1}=(\prod\limits_{t=1}^m(s_t!))\cdot B!\prod\limits_{t=1}^m\binom{s_t-1}{b_t-1}\dfrac{1}{b_t!}$。

在计算时需要枚举所有的满足 $B=\sum\limits_{t=1}^mb_t$ 的 $b_t$，我们不妨设 $f(i,j)=\sum\limits_{b_i}\left([\sum\limits_{t=1}^ib_t=j]\prod\limits_{t=1}^i\binom{s_t-1}{b_t-1}\dfrac{1}{b_t!}\right)$，则结果为 $(\prod\limits_{t=1}^m(s_t!))\cdot B!f(m,B)$。

我们可以发现，有许多方案被错误计算了，如 `1 1 2` 这种方案会被 $f(2,3)$ 计算到，但这其实只分成了两块。于是我们可以容斥，最终答案 $ans=(\prod\limits_{t=1}^m(s_t!))\sum\limits_{B=m}^nB!f(m,B)(-1)^{n-B}$。

接下来只用考虑如何计算 $f(i,j)$，我们可以枚举 $b_i$，则 $f(i,j)=\sum\limits_{k=1}^{\min(s_i,j)}f(i-1,j-k)*\binom{s_t-1}{k-1}\frac1{k!}$。

考虑时间复杂度，虽然有三重循环，但循环次数为 $\sum\limits_{i=1}^ms_i(\sum\limits_{j=1}^is_j)$，实际上是 $O(n^2)$。

Code:

```cpp
#include<stdio.h>
#include<math.h>
typedef long long ll;
int rd(){
	int k=0;char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
	return k;
}
const int N=301,M=1000000007;
bool sqr(ll x){ll s=sqrt(x);return s*s==x;}
int Pow(int x,int a){
	int s=1;
	while(a){
		if(a&1)s=(ll)s*x%M;
		x=(ll)x*x%M,a>>=1;
	}
	return s;
}
int n,m,ans,a[N],s[N],fac[N],inv[N],f[N][N];
int C(int n,int m){return(ll)fac[n]*inv[m]%M*inv[n-m]%M;}
int main(){
	n=rd(),fac[0]=inv[0]=f[0][0]=1;
	for(int i=1;i<=n;++i){
		int _=rd();fac[i]=(ll)fac[i-1]*i%M;
		for(int j=1;j<=m;++j)if(sqr((ll)_*a[j])){++s[j];goto End;}
		a[++m]=_,++s[m];End:;
	}
	inv[n]=Pow(fac[n],M-2);
	for(int i=n-1;i;--i)inv[i]=(ll)inv[i+1]*(i+1)%M;
	for(int i=1,_=0;i<=m;++i){
		_+=s[i];
		for(int j=1;j<=_;++j)for(int k=1;k<=s[i]&&k<=j;++k)
			f[i][j]=(f[i][j]+(ll)f[i-1][j-k]*C(s[i]-1,k-1)%M*inv[k])%M;
	}
	for(int i=m;i<=n;++i){
		int t=(ll)f[m][i]*fac[i]%M;
		if((n-i)&1)ans=(ans+M-t)%M;
		else ans=(ans+t)%M;
	}
	for(int i=1;i<=m;++i)ans=(ll)ans*fac[s[i]]%M;
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：ningyuheng (赞：13)

首先先来证明若xy为完全平方数，xz为完全平方数，那么yz也为完全平方数，易得(x^2)yz为完全平方数，由于完全平方数除以完全平方数还是完全平方数，可得yz为完全平方数。

那么通过以上的定理可以发现，若i与j不能相邻，且j与k不能相邻，那么i与k也不能相邻。不存在i与j不能相邻，且j与k不能相邻，但i与k能相邻的情况。

那么由以上信息可知，它们之间构成的情况形成了多个完全图，且这些完全图之间互不干扰。

问题便转化为给出m种颜色，每种颜色的小球有ai个，总共有n个小球(n<=300)，求所有小球的排列方案中，任意相邻两个小球不能为同一种颜色的总方案数。

那么便考虑动态规划，首先我们要把这些球的颜色记下来，我有一个比较好的做法，就是把在同一个联通块中的点用并查集并起来，若祖宗相同，则算同一种颜色。

根据这样的思路，把每个球的颜色排一遍序，把同一种颜色的小球放在一段来考虑，因为如果不是这样的话，dp方程列不出来。

先看样例2，处理完后我的程序显示的是3,3,6,6,6,7,7,8,9代表着第1种颜色有2个，第2种颜色有3个，第3种颜色有2个，第4种颜色有1个，第5种颜色有1个，接下来就可以dp了。

设dp[i][j][k]表示考虑前i个球，有j对不是当前颜色但却是同一种颜色的球挨在一起，有k对是当前颜色也是同一种颜色的球挨在一起。

考虑若第i个球与第i-1个球不同，

若插入到两个颜色不同的球中则dp[i][j][0]+=dp[i-1][k][j-k]×(i-j);k从0到j

否则若插入到两个颜色相同的球中dp[i][j][0]+=dp[i-1][k][j+1-k]×(j+1);k从0到j+1

接着考虑第i个球与第i-1个球相同，设sum为当前不考虑第i个球,一共放了多少个与第i个球颜色相同的球，设l=sum×2-k+1,o=j+1。

若插入某个与第i个球的颜色相同的球旁边则dp[i][j][k]+=dp[i-1][j][k-1]×l

若插入两个颜色相同但与第i个球颜色不同的球中间则dp[i][j][k]+=dp[i-1][j+1][k]×o

否则插入两个颜色不同且与第i个球颜色也不同的球中间dp[i][j][k]+=dp[i-1][j][k]*(i-l-o+2);

由于三维数组开不下，所以要用滚动数组。

上代码：

```cpp
#include<cstdio>
#include<cmath>
#include<cstdlib>
#include<iostream>
#include<algorithm>
using namespace std;
long long n,i,j,k,dp[3][320][320],a[320],zz[320];
long long sum,l,o;
long long zzz(long long z){
	if(zz[z]==z) return z;
	else return zz[z]=zzz(zz[z]);
}
int main(){
	cin>>n;
	for(i=1;i<=n;i++)
		cin>>a[i];
	for(i=1;i<=n;i++)
		zz[i]=i;
	for(i=1;i<=n;i++)
		for(j=i+1;j<=n;j++){
			l=sqrt(a[i]*a[j]);
			if(l*l==a[i]*a[j])
				zz[zzz(i)]=zzz(j);
		}
	for(i=1;i<=n;i++)
		a[i]=zzz(i);
	sort(a+1,a+n+1);
   	dp[1][0][0]=1;
   	for(i=1;i<=n;i++){
   		if(a[i]!=a[i-1]){
			sum=1;
	   		for(j=0;j<i;j++){
	   			for(k=0;k<=j;k++)
	   				dp[2][j][0]+=dp[1][k][j-k]*(i-j);
	   			for(k=0;k<=j+1;k++)
	   				dp[2][j][0]+=dp[1][k][j+1-k]*(j+1);
	   			dp[2][j][0]%=1000000007;
			}
		}
		else{
			for(j=0;j<i;j++)
	   			for(k=0;k<=sum;k++){	
				   	l=sum*2-k+1;
					o=j+1;
	   				if(k!=0) dp[2][j][k]+=dp[1][j][k-1]*l;
					dp[2][j][k]+=dp[1][j+1][k]*o;
					if(i-l-o+2>0) dp[2][j][k]+=dp[1][j][k]*(i-l-o+2);	
					dp[2][j][k]%=1000000007;
				}
			sum++;
		}
		for(j=0;j<i;j++)
			for(k=0;k<=i;k++){
				dp[1][j][k]=dp[2][j][k];
				dp[2][j][k]=0;
			}
	}
	cout<<dp[1][0][0]<<endl;
    return 0;
}
```

~~(代码丑陋，不喜勿喷)~~

---

## 作者：SDNetFriend (赞：11)

## P4448 [AHOI2018初中组]球球的排列 题解

#### upd:去掉了公式和标点之间的空格

#### 题意不再赘述啦。

[P4448 [AHOI2018初中组]球球的排列](https://www.luogu.com.cn/problem/P4448)

#### 知识点：

容斥、背包、组合数

#### 容斥分析

显而易见地，这个题需要考虑容斥，我们设 $h_i$ 表示至少有 $i$ 对完全平方数的方案数，这样会发现我们的答案即：

$$
ans=\sum_{i=0}^{n-1}(-1)^ih_i
$$

我们现在需要考虑怎么求出 $h_i$。

#### 问题性质

首先，因为 $n\leq 300$，所以我们可以直接 $O(n^2)$ 地求出所有可能组成完全平方数的数对，但这里有一个性质：如果 $a\times b$ 是完全平方数并且 $c\times b$ 也是完全平方数，那么 $a\times c$ 是完全平方数。

证明：一个数如果是完全平方数，将其分解质因数后每个因子的次数都是偶次，而两数相乘是完全平方数说明两数对应因子次数的奇偶性相同，所以相乘为完全平方数这个关系具有传递性。

#### 分割讨论贡献

那么我们会发现，如果按照这种关系连边，会形成若干个连通块，每个块都是一个完全图，而且这样的话各块之间不会相互影响，可以分开考虑。那我们可以设 $g_{i,j}$ 表示大小为 $i$ 的块，有 $j$ 对完全平方数的方案数。

注意这里因为是排列，所以要把不同的排列方式给考虑进去。具体怎么求呢？我们意识到这个问题相当于给一个块内的元素划分成 $i-j$ 块并且每块不为空，那这个东西就已经呼之欲出了。

我们采用隔板法将其分为 $j+1$ 块，并且因为是排列，所以要乘上排列数，即：

$$
g_{i,j}=C_{i-1}^jA_i^j
$$

（我是不会告诉你我是先暴力打表得出式子再去想为什么的）

#### 背包处理

最后，我们能求出每一块产生若干不合法对的方案数，考虑最终如何计算答案，我们要计算全局产生若干不合法对的方案数，这些不合法对要被分配到各块中，这就很像一个背包。

我们设 $f_{i,j}$ 为考虑了前 $i$ 个块，不合法对共有 $j$ 个的方案数，然后对于每个 $i$ 枚举一下当前块的贡献，直接转移就可以了。

这样我们顺便解决了第一个问题，即 $h_i=f_{tot,i}$，其中 $tot$ 表示总块数。

具体方程可以在代码中看，**变量代表含义略有不同**

#### 实现细节

不是很多，因为 $n$ 不大，所以计算各块大小随便搞搞就可以。原序列给我们唯一的帮助就是获取各块的大小，这之后它就没用了。

#### 完结撒花 & 贴代码

```cpp
#include <bits/stdc++.h>
#define lint long long
#define rint register int
#define sq(x) (lint)(x*x)
using namespace std;
inline lint read(){
	char c;lint f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const lint N=305,md=1e9+7;
lint a[N],n,g[N][N],f[N][N];
lint tot,siz[N],fac[N],iv[N],ans;
/*
fac存阶乘,iv为对应阶乘逆元 
g[i][j]为大小为i的块有j对冲突的方案数 
f[i][j]表示前i个块选了j个的方案数
tot为块数,siz为块大小 
*/
inline lint qpow(lint x,lint y){
	lint res=1;
	while(y){
		if(y&1)res=res*x%md;
		x=x*x%md;y>>=1;
	}return res;
}
inline void init(){
	bool vis[N]={0};lint _siz[N];
	for(rint i=1;i<=n;++i){
		_siz[i]=1;
		for(rint j=i-1;j>=1;--j){
			if(vis[j])continue;
			if(sq((lint)sqrt(a[i]*a[j]))==a[i]*a[j]){
				_siz[i]+=_siz[j];
				vis[j]=true;break;
			}
		}
	}
	for(rint i=1;i<=n;++i)
		if(!vis[i])siz[++tot]=_siz[i];
	fac[0]=1;iv[0]=1;
	for(rint i=1;i<=n;++i){
		fac[i]=fac[i-1]*i%md;
		iv[i]=iv[i-1]*qpow(i,md-2)%md;
	}
	for(rint i=1;i<=n;++i)
		for(rint j=0;j<i;++j){
			g[i][j]=fac[i]*fac[i-1]%md;
			g[i][j]=g[i][j]*iv[i-j]%md;
			g[i][j]=g[i][j]*iv[j]%md;
			g[i][j]=g[i][j]*iv[i-j-1]%md;
		}
}
int main(){
	n=read();
	for(rint i=1;i<=n;++i)
		a[i]=read();
	init();
	f[0][0]=1;
	for(rint i=1;i<=tot;++i)
		for(rint j=0;j<siz[i];++j)
			for(rint k=0;k<n;++k)
				if(k-j>=0)
					f[i][k]=(f[i][k]+f[i-1][k-j]*g[siz[i]][j]%md)%md;
	for(rint i=0;i<n;++i)
		ans=(ans+fac[n-i]*f[tot][i]*(i&1?-1:1)%md+md)%md;
	cout<<ans<<endl;
	return 0;
}

```




---

## 作者：skydogli (赞：9)

机房大哥用生成函数爆搞这题，然后另一个大哥用简单容斥推出了复杂度相同的简洁式子。。。

（我只能在一旁膜拜）

不难发现 $2$ 个数相乘等于完全平方数等价于将两个数的平方因子都除去后两数相等。于是我们转化成给出一些等价类，将所有数其任意排列且相邻的数不在同一等价类中的方案。

直接做不好做，考虑容斥：假设有 $k$ 个等价类，令第 $i$ 个等价类大小为 $a_i$，考虑枚举至少有 $b_i$ 个相邻，那么可以推出：

$$ans=n!\sum_{b_{1\dots k}}\frac{(n-\sum b_i)!}{\prod (a_i-b_i)!}\prod\binom{a_i-1}{b_i}(-1)^{\sum b_i}$$

其意义非常直观：

- 下列计算时令等价类无序，而题目要求的本质不同是序号不同，所以答案要标号。

- 在 $a_i$ 个点中用 $b_i$ 条边将任意相邻两个点固定，那么这个等价类点数为 $a_i-b_i$，总的点数为 $n-\sum b_i$ ，所以本质不同的排列数为$\sum_{b_{1\dots k}}\frac{(n-\sum b_i)!}{\prod(a_i-b_i)!}$ 

- 对于 $a_i$ 个数，他们放在序列上，你要钦定它们有至少 $b_i$ 次出现相邻，相当于选择所有空隙中的 $b_i$ 个，而空隙有 $a_i-1$ 个，所以有个 $\binom{a_i-1}{b_i}$ 的组合数。

- 钦定了至少，所以要容斥，带个 $-1$ 的系数。

直接做的时间复杂度是 $O(n^2)$ 的。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define Mod 1000000007
#define MN 305
int n,a[MN],F[MN],siz[MN];
bool chk(int a){
	int b=sqrt(a)+1e-9;
	return b*b==a;
}
int fac[MN],dfac[MN],inv[MN];
int f[MN],tmp[MN],g[MN],ans;
int C(int m,int n){
	if(m<n)return 0;
	return fac[m]*dfac[n]%Mod*dfac[m-n]%Mod;
}
signed main(){
	scanf("%lld",&n);
	fac[0]=dfac[0]=fac[1]=dfac[1]=inv[1]=1;
	for(int i=2;i<=n;++i){
		fac[i]=fac[i-1]*i%Mod;
		inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod;
		dfac[i]=dfac[i-1]*inv[i]%Mod;
	}
	for(int i=1;i<=n;++i)scanf("%lld",&a[i]);
	for(int i=1;i<=n;++i)F[i]=i;
	for(int i=1;i<=n;++i){
		siz[F[i]]++;
		for(int j=i+1;j<=n;++j)
			if(chk(a[i]*a[j])){
				F[j]=F[i];	
			}
	}
	f[0]=1;int sz=0;
	for(int i=1;i<=n;++i){
		if(!siz[i])continue;
		for(int j=0;j<=sz;++j)tmp[j]=f[j],f[j]=0;
		for(int j=0;j<siz[i];++j){
			g[j]=dfac[siz[i]-j]*C(siz[i]-1,j)%Mod;
			if(j&1)g[j]=Mod-g[j];
			for(int k=0;k<=sz;++k){
				f[j+k]=(f[j+k]+g[j]*tmp[k])%Mod;	
			}
		}
		sz+=siz[i]-1;
	}
	for(int i=0;i<=sz;++i){
		ans=(ans+f[i]*fac[n-i])%Mod;
	}
	for(int i=1;i<=n;++i){
		ans=ans*fac[siz[i]]%Mod;
	}
	sort(a+1,a+1+n);
	int lst=0;
	printf("%lld\n",ans);
	return 0;
}
```

后面的部分可以做到 $O(n\log^2n)$，前面的大概能用简单做法做到 $O(n\pi(a^{\frac{1}{3}}))$ ，硬上 ```pollard-rho``` 能做到 $O(na^{\frac{1}{4}})$ 。

而通过分析可以获得一个期望复杂度 $O(na^{\frac{1}{6}})$ 的复杂度：先把 $a^{\frac{1}{6}}$ 以内的因数除去。再跑```pollard-rho```，因为若存在一个不超过 $a^{\frac{1}{3}}$ 的因子，```pollard-rho```在期望下能在  $O(a^{\frac{1}{6}})$ 的时间内找到。而我们这题要除去的是平方因子，也就是要找到类似 $p^2q$ 的东西，显然是有一个不超过 $a^{\frac{1}{3}}$ 的。但这个东西的问题在我们不知道何时中止，所以可能没有什么实际意义？



---

## 作者：StayAlone (赞：5)

先将每个数除掉它所有的平方因子，那么乘起来是完全平方数当且仅当这两个数相等。因此把所有相等的数放到一块进行考虑。

定义不合法数对即相等的一对数。

考虑一块一块进行 dp，然后容斥。设 $f_{i, j}$ 表示顺次放置完前 $i$ 块，钦定有 $j$ 对不合法数对的方案数。

转移时，需要计算一个长度为 $x$ 的连通块，贡献钦定 $y$ 对不合法数对的方案数。需要注意的是，由于后面容斥时会乘上阶乘的系数，因此在这里，类似如下几种方案是**不被区分**的。

```
1 2 | 3 | 4 5
1 2 | 4 5 | 3
4 5 | 1 2 | 3
4 5 | 3 | 1 2
3 | 1 2 | 4 5
3 | 4 5 | 1 2
```

方案数可以这样考虑：这个问题等价于将 $x$ 个数分成 $x-y$ 个**连续的部分**。

- 可以联系刚才的例子考虑。上面的问题就是为长度为 $5$ 的连通块，钦定 $2$ 对不合法数对的方案数，等价于将 $5$ 个数分成 $5-2=3$ 个部分。

那么先从 $x$ 个位置中选出 $x-y$ 个位置定为头部，那么剩下的位置分别有 $x-y,x-y+1,x-y+2,\cdots,x-1$ 个位置选择。也就是说，方案数为 $g_{x,y}=C_{x}^{x-y}\times \dfrac{(x-1)!}{(x-y-1)!}$。

记总共有 $m$ 块，第 $i$ 块有 $c_i$ 个位置。那么 $f_{i, j}=\sum_{k=0}^{j} f_{i - 1,k}\times g_{c_i,j - k}$。

可以发现，若将“绑在一起”的每一块看做一个整体，那么若钦定了 $i$ 对不合法数对，则有 $n-i$ 个整体可以进行排列。

- “绑在一起”是指在将块内元素分成多个部分时，被分在一起的数。

故答案为：$\sum_{i=0}^{n-1} (-1)^i\times (n-i)!\times f_{m,i}$。

------------

我走的弯路：计算 $g_{x,y}$ 时，考虑隔板法，从 $x-1$ 个间隙中选择 $x-y-1$ 个，然后将所有数进行排列，错误地认为 $g_{x,y}=C_{x-1}^{x-y-1}\times x!$。这个错误其实很显然，就是上面的例子，会把每种方案都算一遍，而实际上只能算一遍。

时间复杂度 $\mathcal O(n^3)$。

[AC record](https://www.luogu.com.cn/record/125757047)

```cpp
int n, m, c[310], C[310][310]; map <int, int> cnt;
const int mod = 1e9 + 7;
ll ans, f[310][310], fac[310], inv[310];

il int get(int i, int j) {
	if (i <= j) return 0;
	return C[i][j] * fac[i - 1] % mod * inv[i - j - 1] % mod;
}

il int qpow(ll a, int b) {
	ll ans = 1;
	while (b) {
		if (b & 1) (ans *= a) %= mod;
		(a *= a) %= mod; b >>= 1;
	} return ans;
}

int main() {
	read(n);
	rep1(i, 0, n) C[i][0] = 1;
	rep1(i, 1, n) rep1(j, 1, i) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
	rep1(i, 1, n) {
		int x = read();
		rep1(j, 2, sqrt(x)) if (x % j == 0) {
			int t = j * j;
			while (x % t == 0) x /= t;
		} ++cnt[x];
	}
	for (auto v : cnt) c[++m] = v.snd;
	fac[0] = 1;
	rep1(i, 1, n) fac[i] = fac[i - 1] * i % mod;
	rep1(i, 0, n) inv[i] = qpow(fac[i], mod - 2);
	f[0][0] = 1; int s = 0;
	rep1(i, 1, m) {
		s += c[i];
		rep1(j, 0, s - 1) {
			rep1(k, 0, j) (f[i][j] += f[i - 1][k] * get(c[i], j - k)) %= mod;
		}
	}
	rep1(j, 0, n - 1) (ans += (j & 1 ? -1 : 1) * f[m][j] * fac[n - j]) %= mod;
	printf("%lld", (ans + mod) % mod);
	rout;
}

---

## 作者：_SeeleVollerei_ (赞：5)

学校模拟赛的题，赛场上秒了，后来同机房的同学看题解发现好像没我的做法所以来写一下。

最普通的动态规划，不用容斥，组合数，生成函数什么的，知道什么叫动态规划就能做出来。

**题意：一个序列 $a$ ，将这个序列随机排列，问有多少个排列满足对于任意的 $i$ ，满足 $a_i \times a_{i+1}$ 都不为完全平方数。**

一个小小的定理：如果 $a \times b$ 为完全平方数， $b \times c$ 为完全平方数，那么 $a \times c$ 一定也为完全平方数。

证明：设 $a \times b = p^2$ , $b \times c = q^2$ , 那么 $a \times b \times b \times c = p^2 \times q^2$ ， 那么 $a \times c =\frac{p^2 \times q^2}{b^2}=(\frac{pq}{b})^2$。

那么我们可以把这些数分成若干组，用一个**并查集**维护即可。

### upd on 20211014: 经同学提醒，并不需要并查集，暴力维护即可

考虑对每一组一个个数进行考虑，设 $f_{i,j,k}$ ，状态的意义如下：

$i$ ： 枚举到第 $i$ 个数。

在介绍 $j$ 和 $k$ 的定义前，为防止过于绕口，先进行一定的定义。

随便列一个排列，比如 2 2 2 3 2 （这里的数为所属的组数），那么前三个 2 是不合法的，因为它们之间还有 2 个空需要插数进去，我们称这种后面必须还要插数进去的空为当前排列的不合法空数。

**假设现在枚举的第 $i$ 个数，为第 $p$ 组的第 $q$ 个数，这句话在下面都通用。**

$j$ ： 在插入了前 $p-1$ 组数和第 $p$ 组的前 $q-1$ 个数之后，前 $p-1$ 组的数之间还有 $j$ 个不合法空数。

$k$ ： 在插入了前 $p-1$ 组数和第 $p$ 组的前 $q-1$ 个数之后，第 $p$ 组的前 $q-1$ 个数之间还有 $k$ 个不合法空数。

那么 $f_{i,j,k}$ 表示的就是这种状态下的方案数，则目标状态即答案为 $f_{n,0,0}$ ，考虑转移，分类讨论。

**第一种情况**

**插入的第 $i$ 个数对 $j$ 和 $k$ 毫无影响。**

则从 $f_{i-1,j,k}$ 转移至 $f_{i,j,k}$ ，考虑第 $i$ 个数可选的空数。

由于前面已经插入了 $i-1$ 个数，那么一共有 $i$ 个空可选。

因为毫无影响，我们考虑减去会对 $j$ 和 $k$ 造成影响的空数。

对 $j$ 造成影响的空数： 就是 $j$ 个空。

对 $k$ 造成影响的空数： 因为这组已经选了 $q-1$ 个数，每个数都有左右两边。不难发现 $k$ 就是这 $q-1$ 个数中左右重复的部分（不理解的可以自己手画几个情况观察一下），所以对 $k$ 造成影响的空数为： $2\times(q-1)-k$ 个空。

所以 $i$ 可选的空数为 $i-j-2\times(q-1)+k$ 个空。

所以第一个转移方程为 $f_{i,j,k}=f_{i-1,j,k}\times(i-j-2\times(q-1)+k)$ 。

**第二种情况**

**插入的第 $i$ 个数对 $j$ 造成影响，也就是插入 $i$ 后使得前 $p-1$ 组数之间的不合法空数减少了一个。**

则从 $f_{i-1,j+1,k}$ 转移至 $f_{i,j,k}$ ，很明显，第 $i$ 个数可选的空数就是 $j+1$ 个空。

所以第二个转移方程为 $f_{i,j,k}=f_{i-1,j+1,k}\times(j+1)$ 。

**第三种情况**

**插入的第 $i$ 个数对 $k$ 造成影响，也就是插入 $i$ 后使得第 $p$ 组数之间的不合法空数多了一个。**

则从 $f_{i-1,j,k-1}$ 转移至 $f_{i,j,k}$ ，与第一种情况推的对 $k$ 造成影响的空数一致，为 $2\times(q-1)-k$ 个。

所以第三个转移方程为 $f_{i,j,k}=f_{i-1,j,k-1}\times (2\times(q-1)-k)$ 。

**末尾处理**

这样转移要分组进行转移。每弄完一组后要将 $f_{i,j,k}$ 更新至 $f_{i,j+k,0}$ ，因为上一组结束后，它的 $k$ 相对于下一组就是 $j$ 了。

**时间复杂度为 $O(n^3)$ ，空间复杂度为 $O(n^3)$ ，但是可以把第一维的 $i$ 滚动数组滚掉，所以复杂度为 $O(n^2)$**

一些实现细节见代码注释

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
const int N=320;
const int Mod=1e9+7;
int f[N][N],g[N][N],fa[N],siz[N],tot,num[N],n,cnt[N],ss; //f和g滚动数组
inline int Read(){
    char ch;
    while((ch=getchar())<'0'||ch>'9');
    int x=ch^48;
    while((ch=getchar())>='0'&&ch<='9')
        x=(x<<3)+(x<<1)+(ch^48);
    return x;
}
inline int Find(const int x){
    return fa[x]==x?x:fa[x]=Find(fa[x]);
}
inline void Init(){
    n=Read();
    for(register int i=1;i<=n;i++){
        num[i]=Read();
        fa[i]=i;
        siz[i]=1;
    }
    for(register int i=1;i<n;i++)
        for(register int j=i+1;j<=n;j++){
            int sqr=sqrt(1ll*num[i]*num[j]);
            if(1ll*sqr*sqr!=1ll*num[i]*num[j]) continue ;
            int fi=Find(i),fj=Find(j);
            if(fi==fj) continue ;
            fa[fi]=fj;
            siz[fj]+=siz[fi]; //并查集维护每组的集合大小
        }
    for(register int i=1;i<=n;i++){
        if(Find(i)!=i) continue ;
        cnt[++tot]=siz[i];
    }
    return ;
}
inline void Solve(){
    g[0][0]=1;
    for(register int i=1;i<=tot;i++){ //第i组
        for(register int p=1;p<=cnt[i];p++){ //第p个数
            ss++; //ss就是当前数在整个序列中为枚举到的第i个数
            memset(f,0,sizeof(f)); //由
            for(register int j=0;j<=ss;j++)
                for(register int k=0;k<=p;k++){
                    if(ss-j-2*(p-1)+k>=0) f[j][k]=(f[j][k]+1ll*g[j][k]*(ss-j-2*(p-1)+k)%Mod)%Mod;
                    if(k>=1&&2*(p-1)-k+1>=0) f[j][k]=(f[j][k]+1ll*g[j][k-1]*(2*(p-1)-k+1)%Mod)%Mod;
                    f[j][k]=(f[j][k]+1ll*g[j+1][k]*(j+1)%Mod)%Mod; //这上面都是提到的转移
                }
            memset(g,0,sizeof(g));
            for(register int j=0;j<=ss;j++)
                for(register int k=0;k<=p;k++)
                    g[j][k]=f[j][k];  //滚动数组
        }
        memset(g,0,sizeof(g));
        for(register int j=0;j<=ss;j++)
            for(register int k=0;k<=cnt[i];k++)
                if(j+k<=n) g[j+k][0]=(g[j+k][0]+f[j][k])%Mod; 
                //每弄完一组后的特殊处理
    }
    printf("%d\n",f[0][0]); 
    return ;
}
int main(){
    Init();
    Solve();
    return 0;
}
```

**完结撒花**

---

## 作者：BigJoker (赞：4)

首先证明一个结论，如果 $a\times b$ 是一个完全平方数，并且 $a\times c$ 是一个完全平方数，那么 $b\times c$ 也是一个完全平方数，因为 $a\times b$ 是一个完全平方数，$a\times c$ 是一个完全平方数，所以 $a^2\times b\times c$ 是一个完全平方数，而 $a^2$ 是一个完全平方数，那么 $b\times c$ 就是一个完全平方数。

所以我们可以将问题进行简化，把能凑出完全平方数的数看成同一颜色，那么题目转化成将 $n$ 个 $m$ 种球进行排列，并且要求颜色相同的球不能相邻，求方案数。

注意，在这里，我们暂时假定每一种球是一样的，答案求出来过后还要对每一种球进行排列即可，另外，我们设第 $i$ 种球有 $v_i$ 个。

设 $f_{i,j}$ 表示前 $i$ 种球进行排列，一共有 $j$ 个不合法的空隙，什么叫不合法？不合法就是指颜色相同的球相邻，空位就是指相邻两个球之间的空隙。

现在考虑转移第 $i+1$ 种球。我们利用插板的思想，考虑将第 $i+1$ 种球分成 $k$ 段然后插入到前 $i$ 种球的空隙中，前 $i$ 种球一共有 $(\sum_{i=1}^{n}v_i)+1$ 个空隙。我们将第 $i+1$ 种球分成 $k$ 段插入后，势必会产生 $v_{i+1}-k$ 个不合法的空隙，我们再枚举将第 $i+1$ 种球插入后会抵消原来 $j$ 个不合法的空隙 $l$ 个。

设不合法的空隙数量变化量为 $\Delta$，那么：

$$\Delta=v_{i+1}-k-l$$

捋一下现在的过程，现在我们要将 $x$ 个球划分为 $k$ 段，并插入到前面 $s+1$ 个空隙中，并且其中有 $j$ 个空隙不合法，而且其中有 $l$ 个不合法的空隙等待我们去消除。

可以开始推导了。

首先要将 $x$ 个球划分为 $k$ 段，那么利用插板法，为：

$$\dbinom{x-1}{k-1}$$

然后要从 $j$ 个不合法空隙选出 $l$ 个空隙去填充，为：

$$\dbinom{j}{l}$$

填充完这 $l$ 个不合法空隙后，另外 $j-l$ 个不合法空隙也不能填充，只剩下 $s-j+1$ 个空隙，并且需要插入 $k-l$ 段，为：

$$\dbinom{s-j+1}{k-l}$$

综上，dp 推导为：

$$f_{i+1,j+\Delta}\gets \sum_{}^{}f_{i,j}\times\dbinom{x-1}{k-1}\times \dbinom{j}{l}\times\dbinom{s-j+1}{k-l} $$

其中 $\Delta$ 内部的变量需要去枚举。

```cpp
#include<bits/stdc++.h>
#define mem(a,x) memset(a,x,sizeof(a))
#define re register
#define il inline
using namespace std;
typedef long long LL;
const int N=3e2+5;
const int mod=1e9+7;
int n,m;
int a[N],v[N],s[N];
int g[N][N],c[N][N],fac[N];
int f[N],sz[N];
il int get(int x){
	return f[x]=(f[x]==x?x:get(f[x]));
}
il bool sq(LL x){
	int t=(int)sqrt(x);
	return 1ll*t*t==x;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(re int i=1;i<=n;i++)
		cin>>a[i];
	for(re int i=1;i<=n;i++)
		f[i]=i,sz[i]=1;
	for(re int i=1;i<=n;i++)
		for(re int j=1;j<i;j++)
			if(sq(1ll*a[i]*a[j]) && get(i)!=get(j))
				sz[get(j)]+=sz[get(i)],f[get(i)]=get(j);
	for(re int i=1;i<=n;i++)
		if(f[i]==i) v[++m]=sz[i];
//	cout<<m<<'\n';
//	for(re int i=1;i<=m;i++)
//		cout<<v[i]<<' ';
	for(re int i=1;i<=m;i++)
		s[i]=s[i-1]+v[i];
	c[0][0]=fac[0]=1;
	for(re int i=1;i<=n;i++){
		c[i][0]=1;
		for(re int j=1;j<=i;j++)
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
		fac[i]=1ll*fac[i-1]*i%mod;
	}
	g[0][0]=1;
	for(re int i=0;i<m;i++)
		for(re int j=0;j<n;j++)
			for(re int k=1;k<=v[i+1];k++)
				for(re int l=0;l<=min(j,k);l++)
					g[i+1][j+v[i+1]-k-l]=(g[i+1][j+v[i+1]-k-l]+1ll*g[i][j]*c[j][l]%mod*c[v[i+1]-1][k-1]%mod*c[s[i]+1-j][k-l]%mod)%mod;
	for(re int i=1;i<=m;i++)
		g[m][0]=1ll*g[m][0]*fac[v[i]]%mod;
	cout<<g[m][0];
	return 0;
}
```

---

## 作者：cool_milo (赞：3)

被干爆了。

### [AHOI2018初中组 球球的排列](https://www.luogu.com.cn/problem/P4448)
注意到“不能相邻”具有传递性，那么可以把不能相邻的集合都搞出来。  
考虑插板法 $dp$，记 $dp_{i,j}$ 表示前 $i$ 个集合已经安排完毕，目前有 $j$ 个相邻元素的乘积为完全平方数（即不合法）的方案数。那么答案就是 $dp_{tot,0}$。  
转移两重循环枚举 $k,l$，分别表示当前集合“破坏”几对不合法的相邻元素，又“隔断”了几对合法的相邻元素。  
记 $cnt_i$ 表示第 $i$ 个集合的元素个数，$pref$ 表示 $cnt$ 的前缀和，那么有转移：  
$$
dp_{i + 1,j - k + cnt_{i + 1} - k - l} \leftarrow dp_{i,j} * \frac{cnt_{i + 1}!}{(cnt_{i + 1} - k - l)!} * \frac{(cnt_{i + 1} - 1)!}{(k + l - 1)!} * \binom{j}{k} * \binom{pref_i + 1 - j}{l}
$$
转移系数中，第一项是 $A_{cnt_{i+1}}^{k+l}$，表示在当前集合中选择 $k+l$ 个数填在每一段的开头；第二项是剩下的树填在刚才 $k+l$ 个数后面的方案，第三项是决策破坏哪些不合法的相邻元素，第四项是决策破坏哪些合法的相邻元素。

这么做看似是 $O(n^4)$ 的，但是注意到 $k$ 只用枚举到 $cnt_i$，那么复杂度就是 $O(n^3)$ 的。 ~~非常的简单无脑~~

---

## 作者：ZBHRuaRua (赞：3)

前置知识：

组合数学能力

容斥原理

首先有一个简单的结论，当 $x \times y$ 和 $x \times z$ 为完全平方数时，显然 $y \times z$ 也为完全平方数。

于是可以简单地通过 $O(n^2)$ 暴力将这些球分块。
问题转化为：已知 $n$ 个球属于 $m$ 个颜色，同种颜色小球不能相邻，问排列方案数。

设 $f(s)$ 为至少有$s$对同色小球相邻时的方案数，则由容斥原理知  $ans=\sum_{i=0}^nf(i) \times (-1)^i$

考虑如何求 $f(s)$ 前，我们先假设我们将相邻相同颜色的球合并为一个块，设 $b(i)$ 为颜色为 $i$ 的球有多少个块（也就是说现在我们通过固定每一颜色的块数得到了一种情况），则可得当前情况的答案为

$\frac{(\sum_{i=1}^{m}b(i))!}{\prod_{i=1}^mb(i)!} \cdot \prod_{i=1}^{m}a(i)! \cdot C_{a(i)-1}^{b(i)-1}$

设有 $s$ 对同色小球相邻，则 $\sum_{i=1}^{m}b(i)=n-s$

以两个乘号为分界将式子分为三段，第一段为 $b$ 的可重排列数，第二段为每一颜色内小球的全排列，第三段为每一颜色内对小球进行的分块方案（隔板法）

再转换一下可以变成

$(n-s)!\prod_{i=1}^{m}\frac{C_{a(i)-1}^{b(i)-1} \cdot a(i)!}{b(i)!}$

那么实际上 $f(s)$ 就是考虑了所有不同的 $b(i)$ 分配方法的总答案，我们只需要将上式后面这一坨所有的 $b(i)$ 情况所得到的结果相加再乘以 $(n-s)!$ 就得到了 $f(s)$

假设总共分成了 $n-s$ 个块，我们可以把这些块分配到不同的颜色中去，其实也就是一个DP。

设 $H=\prod_{i=1}^{m}\frac{C_{a(i)-1}^{b(i)-1} \cdot a(i)!}{b(i)!}$
则我们要求 $\sum H$

我们设 $g[i][j]$ 表示考虑了前 $i$ 种颜色，至少有 $j$ 个块时，不同 $b(i)$ 所得到的 $H$ 的和，即 $\sum H$

状态方程是显然的

$g[i][j]=\sum_{k=1}^{min(a(i),j)}g[i-1][j-k] \cdot \frac{C_{a(i)-1}^{k-1} \cdot a(i)!}{k!}$

于是最终答案便是
$\sum_{s=0}^{n-1}g[m][n-s] \cdot (n-s)! \cdot (-1)^s$

时间复杂度 $O(n^2)$

Code:

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<iomanip>
#include<algorithm>
#define ll long long
using namespace std;
const ll INF=1e9+7;
const ll mod=1e9+7;
const ll maxn=305;
inline ll read()
{
	ll x=0,f=1;char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=x*10+(c-'0');
		c=getchar();
	}
	return x*f;
}
ll g[maxn][maxn];
ll n;
ll d[maxn],siz[maxn],vis[maxn],a[maxn],b[maxn],tot;
ll fac[maxn],C[maxn][maxn],inv[maxn],ans;
inline ll quickpow(ll x,ll tim)
{
	ll res=1;
	while(tim)
	{
		if(tim&1) res=res*x%mod;
		x=x*x%mod;
		tim>>=1;
	}
	return res%mod;
}
inline void init()
{
	fac[0]=1;C[0][0]=1;
	for(ll i=1;i<=300;i++) fac[i]=fac[i-1]*i%mod;
	for(ll i=1;i<=300;i++)
	{
		C[i][0]=1;C[i][i]=1;
		for(ll j=1;j<i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
	}
	inv[300]=quickpow(fac[300],mod-2);
	for(ll i=299;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
}
int main()
{
	init();
	n=read();
	for(ll i=1;i<=n;i++) d[i]=read(),siz[i]=1;
	for(ll i=1;i<=n;i++)
	{
		for(ll j=i-1;j>=1;j--)
		{
			if(vis[j]) continue;
			if((ll)sqrt(d[i]*d[j])*(ll)sqrt(d[i]*d[j])==d[i]*d[j])
			{
				vis[j]=1;
				siz[i]+=siz[j];
				break;
			}
		}
	}
	for(ll i=1;i<=n;i++)
	{
		if(!vis[i])
		{
			a[++tot]=siz[i];
		}
	}
	g[0][0]=1;
	for(ll i=1;i<=tot;i++)
	{
		for(ll j=1;j<=n;j++)
		{
			ll len=min(a[i],j);
			for(ll k=1;k<=len;k++)
			{
				g[i][j]=(g[i][j]+g[i-1][j-k]*C[a[i]-1][k-1]%mod*fac[a[i]]%mod*inv[k]%mod)%mod;
			}
		}
	}
	for(ll i=0;i<n;i++)
	{
		ll flag=(i%2)?-1:1;
		ans+=g[tot][n-i]*fac[n-i]%mod*flag;
		ans%=mod;
	}
	ans=(ans+mod)%mod;
	cout<<ans<<endl;
	return 0;
} 
```


---

## 作者：OIerAlbedo (赞：2)

## Introduction

举报 $ \text{AHOI} $ 抄袭 $ \text{CF} $。

## Solution

如果 $ a_i $ 是形如 $ \prod_{i=1}^{n}{b_i}^{p_i} $，其中 $ b_i $ 是质数，那么如果 $ p_i\ge 2 $，那么 $ p_i $ 可以减 $ 2 $，因为他不会影响最终结果，然后问题就转换成了一个经典题型，求有多少个排列满足 $ a_{pi}\not=a_{p_{i-1}} $，用 $ \text{DP} $ 解决。

我们可以利用隔板法的思想，假设 $ f[i][j] $ 表示截止到前 $ i $ 个不同的数，有 $ j $ 个不合法的空位，最终答案为 $ f[len][0] $，其中 $ len $ 为不同的数的个数。

然后我们可以发现，新加进来 $ fre $ 个相同的数，前面总共有 $ sum $ 个数，那么总共有 $ sum+1 $ 个空位，我们需要知道的有：

$ lst1 $ 表示前面不合法的空位的数量。

$ now $ 表示当前这 $ fre $ 个数会抵消多少个不合法的空位。

$ add $ 表示当前这 $ fre $ 个数会增加几个不合法的空位。

现在我们还要考虑的是如果增加了 $ add $ 个不合法的空位会对这新加进来的 $ fre $ 的数产生什么影响，我们假设会分成 $ x $ 段，那么 $ \sum_{i=1}^x len[x]-1=add $，就是 $ fre-x=add $，就是 $ x=fre-add $,就是如果我们要增加 $ add $ 个空位势必要分成 $ fre-add $ 段，而我们发现如果枚举有多少个空位不好做，我们考虑枚举分成几段。

那么有如下转移：
$$
f[i][lst1-now+fre-x]+=f[i-1][lst]\times C(fre-1,fre-x)\times C(lst1,now)\times C(sum+1-lst1,x-now)
$$
理论上会 $ \text{T} $，但实际不知道，待我写完再说。

## Code

```c++
#include <bits/stdc++.h>
using namespace std;
long long len,MOD,lsh[1001010],fac[1001010],sum,dif,lst1,x,c[1010][1010],up,fre[100101],f[1010][1010],a[100100],n,i,j,now,ans;
int main() {
    ios::sync_with_stdio(0);cin.tie();cout.tie();
    cin>>n;MOD=1e9+7;
    for (i=1;i<=n;i++) 
         {
         	cin>>a[i];
         	for (j=2,up=sqrt(a[i]);j<=up;j++)
         	     while (a[i] % (j*j)==0) 
         	          a[i]/=(j*j);
         	lsh[i]=a[i];
		 }
	c[0][0]=1;fac[0]=1;
	for (i=1;i<=500;i++)
	    {
	    	c[i][0]=1;c[i][i]=1;
	    	for (j=1;j<i;j++)
	    	   c[i][j]=(c[i-1][j-1]+c[i-1][j]) % MOD;
	    	fac[i]=fac[i-1]*i % MOD;
		}
	sort(lsh+1,lsh+n+1);len=unique(lsh+1,lsh+n+1)-lsh-1;
	for (i=1;i<=n;i++) a[i]=lower_bound(lsh+1,lsh+len+1,a[i])-lsh,fre[a[i]]++;
	f[1][fre[1]-1]=1;sum=fre[1];
	for (i=1,dif=1;i<=len;i++) dif=dif*fac[fre[i]] % MOD;
	for (i=2;i<=len;sum+=fre[i],i++)
	   for (lst1=0;lst1<=sum+1;lst1++)
	        if (f[i-1][lst1]!=0)
	            for (x=1;x<=fre[i];x++)
	                for (now=0;now<=min(lst1,x);now++)
	                    { 
	                    f[i][lst1-now+fre[i]-x]+=f[i-1][lst1]*c[fre[i]-1][fre[i]-x] % MOD*c[lst1][now] % MOD*c[sum+1-lst1][x-now] % MOD;
	                    f[i][lst1-now+fre[i]-x]%=MOD;
						}
    cout<<f[len][0]*dif % MOD<<endl;
	return 0;
}

```



---

## 作者：ComeIntoCalm (赞：2)

题意：n个元素分为m类，求有多少合法排列，合法的定义是相邻元素不能为同类元素，$n\leq 5\times10^3$

XSY 3156 : 额外附加了第一个元素和最后一个元素是相邻的条件。

#### Markdown 崩了 建议博客查看。。
https://www.luogu.org/blog/ComeIntoCalm/solution-p4448#

sol：

考虑容斥，于是变成求不合法的情况即至少有$s$个同种元素构成的部分，我们考虑如何对整个序列进行计数，假定每种元素有$a_i$个，把相邻的相同种类的元素合并为一个新元素，每种元素的新元素数量暂时定义为$b_i$，考虑新元素的排列和容斥系数，明显对于$a_i=b_i$的时候合法方案被计算一次，因此系数为$(-1)^{a_i-b_i}$
$$
\frac{(\sum_i b_i)!}{\prod_i b_i!}\prod_ia_i!\binom{a_i-1}{b_i-1}(-1)^{a_i-b_i}
$$


因为容斥系数为$(-1)^{a_i-b_i}$，求积后为$n-\sum_i b_i$，因此考虑钦点$\sum_{i} b_i$进行容斥

考虑对$\sum_i b_i$的合法方案计数，考虑$f_{i,j}$定义为前$i$种元素构成了$j$个新元素，则递推式为
$$
f_{i,j}=\sum_{k=1}^{\min \{a_i,j\}}f_{i-1,j-k}\times (-1)^{a_i-k}\frac{a_i!\binom{a_i-1}{k-1}}{k!}
$$
实际上容斥系数在最后容斥中计算和在$f$中计算能产生同样的效果。

至于怎么做相邻的，8会。

复杂度为$O((\sum_{i}a_i)^2)=O(n^2)$

```cpp
#include<algorithm>
#include<cstdio>
#include<cmath>
const int N = 3e2+7;
typedef long long LL;
#define R register
#define cerr(x) printf("%d\n", x)
const int p = 1e9+7;
int n;
int A[N*N], cnt = 0, k[N*N], sq;
LL fac[N*N], ifac[N*N];
bool dis[N][N];
inline int min(int a, int b) {
  return a > b ? b : a;
}
int vis[N*N];
inline LL FST(int x, int k) {
  LL res = 1;
  if (!k) return 1;
  if (!x) return 0;
  while (k) {
    if (k & 1) res = 1LL * res * x % p;
    x = 1LL * x * x % p, k >>= 1;
  } return res % p;
}
void dfs(int x, int col) {
  vis[x] = cnt;
  for (int i = 1; i <= n; i++)
    if (i != x && dis[x][i] && !vis[i])
      dfs(i, col);
}
void init() {
  scanf("%d", &n);
  for (R int i = 1; i <= n; i++)
    scanf("%d", &A[i]);
  std :: sort(A + 1, A + n + 1);
  for (R int i = 1; i <= n; i++)
    for (R int j = i + 1; j <= n; j++) {
      if (dis[i][j]) continue;
      LL nx = std :: sqrt(1LL * A[i] * A[j]);
      if (1LL * nx * nx == 1LL * A[i] * A[j])
        dis[i][j] |= 1, dis[j][i] |= 1;
    }
  for (R int i = 1; i <= n; i++)
    if (!vis[i]) dfs(i, ++cnt);
  for (R int i = 1; i <= n; i++) k[vis[i]]++;
  
  int up = 5000;
  fac[0] = 1, ifac[0] = 1;
  for (R int i = 1; i <= up; i++) fac[i] = 1LL * fac[i - 1] * i % p;
  ifac[up] = FST(fac[up], p - 2);
  for (R int i = up - 1; i >= 1; i--) ifac[i] = 1LL * ifac[i + 1] * (i + 1) % p;
  //for (R int i = 1; i <= n; i++) cerr(ifac[i]);
}
inline int cc(int n, int m) {
  return 1LL * fac[n] * ifac[n - m] % p * ifac[m] % p;
}
int f[N][N];
inline int iep(int a, int b) {
  return (((a - b) & 1) ? -1 : 1);
}
int main() {
  init();
  std :: sort(k + 1, k + cnt + 1);
  f[0][0] = 1;
  //for (R int i = 1; i <= cnt; i++) cerr(k[i]);
  for (R int i = 1, S = 0; i <= cnt; i++) {
    S += k[i];
    for (R int j = 1; j <= S; j++)
      for (R int K = 1; K <= k[i] && K <= j; K++)
        f[i][j] = (f[i][j] + (1LL * f[i - 1][j - K] * iep(k[i], K) * 
          cc(k[i] - 1, K - 1) % p * ifac[K] % p * fac[k[i]]) % p) % p;
  }
  LL ans = 0;
  for (R int i = cnt; i <= n; i++) 
    ans = (ans + 1LL * fac[i] * f[cnt][i] % p) % p;//, cerr(iep(n, i));
  printf("%lld\n", (ans % p + p) % p);
}
```

---

## 作者：Yansuan_HCl (赞：0)

将每个数的平方因子除掉，原题即任意排列一些球使同色球不相邻。

尝试按颜色排序后依次放入 DP。定义不合法空隙为相邻两个同色球之间的空隙；不合法空隙的颜色为两个同色球的颜色。若一个球放入与其同色的不合法空隙，则会新增一个不合法空隙；若放入与其异色的不合法空隙，则会减少一个不合法空隙。

因此，设 $f_x(i,j)$ 表示当前正在放入第 $x$ 个球，此时序列中有 $i$ 个异色不合法空隙，$j$ 个同色不合法空隙。

记 $x$ 前面有 $q$ 个与 $x$ 同色的球，则有以下转移：

- 消除一个异色不合法空隙：$g(i-1,j)\gets i \cdot f(i,j)$。
- 新增一个同色不合法空隙：一段同色不合法空隙的左右两侧也可以插入。可插的空数为 $j+2(q-j)=2q-j$：$g(i,j+1)\gets (2q-j)f(i,j)$。
- 放在合法空隙内。减去以上两者：$g(i,j) \gets (x - (2q - j) - i)f(i,j)$。

```cpp
const int N = 305;
const ll P = 1000000007;

int n, a[N];
map<int, int> col;

ll f[N][N]; // 有 i 个非 a_x 的同色对，j 个 a_x 的同色对
 
int main() {
	rd(n); if (n == 1) return puts("1") & 0;
	
	U (i, 1, n) {
		rd(a[i]);
		D (t, sqrt(a[i]), 1) if (!(a[i] % (t * t))) {
			a[i] /= t * t;
			break;
		}
	}
	
	sort(a + 1, a + n + 1);
	f[0][0] = 1;
	int q = 0;
	U (x, 1, n) {
		ll g[N][N] {};
		U (i, 0, x) U (j, 0, x) {
			if (i)
				(g[i - 1][j] += ll(i) * f[i][j]) %= P;
				
			(g[i][j + 1] += ll(2 * q - j) * f[i][j]) %= P;
			(g[i][j] += ll(x - (2 * q - j) - i) * f[i][j]) %= P;
		}
		++q;
		
		if (x == n || a[x] != a[x + 1]) {
			ms(f, 0);
			U (i, 0, x) U (j, 0, x) if (g[i][j])
				(f[i + j][0] += g[i][j]) %= P;
			q = 0;
		} else {
			swap(f, g);
		}
	}
	
	printf("%lld", f[0][0]);
}
```

---


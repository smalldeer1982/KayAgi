# [THUPC 2019] 过河卒二

## 题目描述

> 首先我们回忆一下经典难题过河卒问题：
>
> 棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向上、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点，因此称之为「马拦过河卒」。
>
> 棋盘用坐标表示，$A$ 点 $(1,1)$ 、$B$ 点 $(N,M)$ ，同样马的位置坐标是需要给出的。
>
> 现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。
>
> **请注意，上述背景内容与本题无关！**

Kiana 喜欢玩象棋，尤其是喜欢用象棋玩过河卒的游戏。在传统的过河卒问题中，Kiana 需要控制一个卒从起点走到终点，在路中避开一个对方的马的攻击，然后假装不会算并询问你从起点到终点的路径总数。

在今天的过河卒二游戏中，Kiana 还是控制一个卒在一个 $N\times M$ 的棋盘上移动，初始时卒位于左下方坐标为 $(1,1)$ 位置，但为了增加难度，Kiana 对游戏规则做出了一些修改。传统的过河卒每步只能向上或向右移动 $1$ 格，Kiana 规定自己的过河卒二还可以在一步中向右上方移动 $1$ 格，即如果当前卒位于坐标 $(x,y)$ 处，则下一步可以走到 $(x+1,y)$ 、$(x,y+1)$ 或 $(x+1,y+1)$ 中的任意一格里面去，同时 Kiana 认为，如果两种移动方案在某一步时卒移动的方向（右、上或右上）不同，则两种方案就是不同的，例如从 $(1,1)$ 先走到 $(1,2)$ 再走到 $(2,2)$ 、从 $(1,1)$ 先走到 $(2,1)$ 再走到 $(2,2)$ 和从 $(1,1)$ 直接走到 $(2,2)$ 是三种不同的移动方案。

其次，过河卒二的终点不再是一个特定的位置，Kiana 规定卒可以从棋盘的上方或右方走出棋盘，此时就视为游戏成功。注意在走出棋盘时仍然有方向选择的不同，例如若过河卒位于 $(1,M)$ 处，则下一步它可以向右或者向右上用两种方式走出棋盘，若过河卒位于 $(N,M)$ 处，则下一步它可以向上、向右或者向右上用三种方式走出棋盘，以不同的方式走出棋盘仍然被算作是不同的移动方案。

此外，对方马的攻击范围不再是有规律的几个位置，而是 Kiana 规定好的 $K$ 个特定坐标，并要求过河卒在移动的过程中不能走到这 $K$ 个坐标的任何一个上，在除这些坐标以外的位置上过河卒都可以按规则自由移动。

现在 Kiana 想知道，过河卒二有多少种不同的移动方案可以走出棋盘，这个答案可能非常大，她只想知道方案数对 $59393$ 取模后的结果。由于她不会算，所以希望由你来告诉她。



## 说明/提示

### 样例解释

用 $\uparrow$ 表示过河卒向上移动了一格，用 $\rightarrow$ 表示过河卒向右移动了一格，用 $\nearrow$ 表示过河卒向右上移动了一格，由此可以简化样例解释的表述。

$24$ 种移动方案如下：

$(\uparrow\uparrow\uparrow)$、$(\uparrow\uparrow\nearrow)$、$(\uparrow\uparrow\rightarrow\uparrow)$、$(\uparrow\uparrow\rightarrow\nearrow)$、

$(\uparrow\uparrow\rightarrow\rightarrow\uparrow)$、$(\uparrow\uparrow\rightarrow\rightarrow\nearrow)$、$(\uparrow\uparrow\rightarrow\rightarrow\rightarrow)$、$(\uparrow\nearrow\uparrow)$、

$(\uparrow\nearrow\nearrow)$、$(\uparrow\nearrow\rightarrow\uparrow)$、$(\uparrow\nearrow\rightarrow\nearrow)$、$(\uparrow\nearrow\rightarrow\rightarrow)$、

$(\rightarrow\rightarrow\rightarrow)$、$(\rightarrow\rightarrow\nearrow)$、$(\rightarrow\rightarrow\uparrow\rightarrow)$、$(\rightarrow\rightarrow\uparrow\nearrow)$、

$(\rightarrow\rightarrow\uparrow\uparrow\rightarrow)$、$(\rightarrow\rightarrow\uparrow\uparrow\nearrow)$、$(\rightarrow\rightarrow\uparrow\uparrow\uparrow)$、$(\rightarrow\nearrow\rightarrow)$、

$(\rightarrow\nearrow\nearrow)$、$(\rightarrow\nearrow\uparrow\rightarrow)$、$(\rightarrow\nearrow\uparrow\nearrow)$、$(\rightarrow\nearrow\uparrow\uparrow)$。

### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。

## 样例 #1

### 输入

```
3 3 1
2 2```

### 输出

```
24```

# 题解

## 作者：huayucaiji (赞：13)

其实这个题蛮简单的。

作为一个国家抬杠二级运动员，我们要杠一下这句话：

> 请注意，上述背景内容与本题无关！

~~我非要让你有关~~

考虑普通的过河卒，若没有马（不是骂人），那么从 $(0,0)->(n,m)$，的方案数是 $C_{n+m}^n$。其意义是，我总共走 $n+m$ 步，其中 $n$ 步向上，选出这 $n$ 步的位置就是方案数。

现在我们还可以沿着斜对角走，我们枚举斜着走的方案数：

$$ans=\sum\limits_{i=0}^{\min(n,m)} C_{n+m-i}^i\cdot C_{n+m-2*i}^{n-i}$$

我们回归题目，题目现在是 $(1,1)->(n,m)$。题目里说：

> 其次，过河卒二的终点不再是一个特定的位置，Kiana 规定卒可以从棋盘的上方或右方走出棋盘，此时就视为游戏成功。注意在走出棋盘时仍然有方向选择的不同。

我们可以认为是从 $(1,1)->(n+1,m+1)$ 呀，理解为加上一行一列。

但是现在还有一个疑难没解决，就是障碍的问题。可以用容斥原理来计算。但是时间会炸。可以先预处理。我们对每个障碍按横坐标排序，排序后计算出任意两个之间方案数，带入公式：

$$ans=\sum\limits_{S} calc(S)\times (-1^{|S|})$$

由于模数是质数，可以用 `Lucas` 定理解决。

```cpp
//Don't act like a loser.
//This code is written by huayucaiji
//You can only use the code for studying or finding mistakes
//Or,you'll be punished by Sakyamuni!!!
#include<bits/stdc++.h>
#define int long long
using namespace std;

int read() {
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}

const int MAXN=1e5+10,MOD=59393; 

int n,m,k;
int jc[MAXN],f[21][21],invjc[MAXN];
struct point {
	int x,y;
}p[21];

bool cmp(point a,point b) {
	if(a.x!=b.x) {
		return a.x<b.x;
	}
	return a.y<b.y;
}

int qpow(int x,int y) {
	int ret=1;
	while(y) {
		if(y&1) {
			ret=ret*x%MOD;
		}
		x=x*x%MOD;
		y>>=1;
	}
	return ret;
}
int inv(int x) {
	return qpow(x,MOD-2);
}

int C(int x,int y) {
	if(y>x) {
		return 0;
	}
	return jc[x]*invjc[y]%MOD*invjc[x-y]%MOD;
}

int lucas(int x,int y) {
	if(y==0) {
		return 1;
	}
	return lucas(x/MOD,y/MOD)*C(x%MOD,y%MOD)%MOD;
}

int fff(int n,int m) {
	if(min(n,m)<0) {
		return 0;
	}
	int ret=0,ub=min(n,m);
	for(int i=0;i<=ub;i++) {
		ret=(ret+lucas(n+m-i,i)*lucas(n+m-i*2,n-i)%MOD)%MOD;
	}
	return ret;
	
}

int calc(int s) {
	if(!(s&(1<<0))||!(s&(1<<k))) {
		return 0;
	}
	int lst[22]={},cnt=0,times=1;
	for(int i=0;i<=k;i++) {
		if(s&(1<<i)) {
			lst[++cnt]=i;
			times=times*-1;
		}
	}
	times=(times+MOD)%MOD;
	for(int i=2;i<=cnt;i++) {
		times=times*f[lst[i-1]][lst[i]]%MOD;
	}
	return times;
}

signed main() {
	jc[0]=1;
	invjc[0]=1;
	for(int i=1;i<=MOD;i++) {
		jc[i]=jc[i-1]*i%MOD;
		invjc[i]=inv(jc[i]);
	}
	cin>>n>>m>>k;
	n++;
	m++;
	for(int i=1;i<=k;i++) {
		p[i].x=read();
		p[i].y=read();
	}
	p[0].x=1;p[0].y=1;
	k++;
	p[k].x=n;
	p[k].y=m;
	sort(p+1,p+k+1,cmp);
	
	for(int i=0;i<=k;i++) {
		for(int j=i+1;j<=k;j++) {
			f[i][j]=fff(p[j].x-p[i].x,p[j].y-p[i].y);
		}
	}
	
	int ans=0;
	for(int i=0;i<(1<<k+1);i++) {
		ans=(ans+calc(i))%MOD;
	}
	cout<<ans<<endl;
	return 0;
}

```

---

## 作者：Eznibuil (赞：7)

离谱了，没有 $O(mk^2)$ 的容斥，清一色的 $O(2^k+mk^2)$ 的容斥，来补一发。

首先，“走出棋盘”一点也不优雅，发现在棋盘最外面补一层，答案就是 $(n+1,m+1)$ 的方案了，因为你每种走出棋盘的方案都只有唯一的路径走到 $(n+1,m+1)$。

根据套路，将攻击点按照 $x$ 为第一关键字、$y$ 为第二关键字排序，然后设 $dp_i$ 表示不经过 $i$ 前面的攻击点到 $i$ 攻击点的方案数。

那么我们再假装有一个攻击点 $(n+1,m+1)$，就顺手包进去了。

接着就有了一个喜闻乐见的柿子：
$$
dp_i=w(x_i,y_i)-\sum_{j<i}[x_i\ge x_j][y_i\ge y_j]dp_jw(x_i-x_j,y_i-y_j)
$$
其中 $w(x,y)$ 表示走到 $(x,y)$ 的方案数，$[\text{con}]$ 表示如果 $\text{con}$ 成立则为 $1$，否则为 $0$。这个方程的意思就是用总数减去经过了前面的攻击点的方案数，所以是对的。

考虑转移，发现要计算 $O(k^2)$ 次 $w(x,y)$。

假设我们走了 $i$ 次右上，那么我们走了 $x-i$ 次右，$y-i$ 次上，根据组合的柿子，我们有：
$$
w(x,y)=\sum_i\frac{(x+y-i)!}{i!(x-i)!(y-i)!}
$$
发现阶乘达到了 $10^9$，考虑 [$\text{Lucas}$](https://oi-wiki.org/math/number-theory/lucas/)，仔细想一想，$59393^2>2\times10^9$，所以手动展开，反正只有一层。事先预处理阶乘和阶乘的逆元就行。

所以，我们就可以 $O(m)$ 地计算一个 $w(x,y)$，那总复杂度就是 $O(mk^2)$。

诶嘿，可以过，做完了，顺手卡到了最优解。
```cpp
#include<stdio.h>
#include<algorithm>
typedef long long ll;
const ll mod=59393ll;
ll fac[100001],inf[100001],dp[100001];
struct poi
{
	ll x,y;
}e[21];
ll Pow(ll a,ll b)
{
	ll s=1ll;
	for(a%=mod;b;a=a*a%mod,b>>=1ll)
		if(b&1ll)
			s=s*a%mod;
	return s;
}
ll w(ll n,ll m)
{
	ll s=0ll;
	for(ll i=0ll;i<=n&&i<=m;i++)
		s+=(n+m-i)%mod<i%mod+(n-i)%mod||(n+m-i)/mod<i/mod+(n-i)/mod?0ll:fac[(n+m-i)%mod]*inf[i%mod]%mod*inf[(n-i)%mod]%mod*inf[(m-i)%mod]%mod*fac[(n+m-i)/mod]%mod*inf[i/mod]%mod*inf[(n-i)/mod]%mod*inf[(m-i)/mod]%mod;
	return s%mod;
}
int main()
{
	ll n,m,k;
	scanf("%lld%lld%lld",&n,&m,&k),fac[0]=1ll;
	for(ll i=1ll;i<mod;i++)
		fac[i]=fac[i-1]*i%mod;
	inf[mod-1]=Pow(fac[mod-1],mod-2ll);
	for(ll i=mod-1ll;i;i--)
		inf[i-1]=inf[i]*i%mod;
	for(ll i=0ll;i<k;i++)
		scanf("%lld%lld",&e[i].x,&e[i].y),e[i].x--,e[i].y--;
	std::sort(e,e+k,[](poi a,poi b){return a.x<b.x||a.x==b.x&&a.y<b.y;}),e[k]=poi{n,m};
	for(ll i=0ll;i<=k;i++)
	{
		dp[i]=w(e[i].x,e[i].y);
		for(ll j=0ll;j<i;j++)
			if(e[j].x<=e[i].x&&e[j].y<=e[i].y)
				dp[i]-=dp[j]*w(e[i].x-e[j].x,e[i].y-e[j].y)%mod;
		dp[i]=(dp[i]%mod+mod)%mod;
	}
	printf("%lld",dp[k]);
	return 0;
}
```

---

## 作者：wwt100127 (赞：2)

## 题意
卒从 $(1,1)$ 出发，可以向令 $x+1$，或 $y+1$，或 $x+1$ 并且 $y+1$。棋盘上有一些地方不可到达，求到达 $(n+1,m+1)$ 的方案数（原文不是这样的，但是转化之后是的）。

## 思路
首先考虑没有障碍时怎么做。

设 $dp_{i,j}$ 表示在没有障碍的情况下，到达 $(i,j)$ 的方案数。

如果只有 $x+1$，$y+1$ 两个操作是好做的，走斜线就比较烦人。

所以考虑枚举走的斜线数量。


直接给出 $dp_{i,j}$ 的计算方法。

$$
dp_{i+1,j+1}=\sum_{k=0}^{\min(i,j)} C_{i+j-k \times 2}^{i-k} \times C_{i+j-k}^{k}
$$

如果有点想不明白，可以先假设斜线是在一起的，再将其与直线混在一起，求出组合数就行了。



接下来加上障碍。

考虑容斥原理（~~其实挺显然的吧~~）。

注意到 $k$ 只有 $20$，考虑暴力枚举经过了哪几个障碍即可。

具体的，先将障碍物按照 $x$ 为第一关键字，$y$ 为第二关键字从小到达排序，预处理出两两之间的方案数（与上文的类似）。

然后状态压缩一下就行了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
bool Beginning;

#define pb(x) push_back(x)
#define mp(x,y) make_pair(x,y)
#define se second
#define fi first
using PII=pair<int,int>;
using PIB=pair<int,bool>;
using PBI=pair<bool,int>;
using PBB=pair<bool,bool>;
using PDI=pair<double,int>;
using PID=pair<int,double>;

const int mod=59393;
namespace Memory_Love{
	int read(){ int x=0; bool flag=1; char ch=getchar();
		while(ch<'0' || ch>'9'){if(ch=='-') flag=0; ch=getchar();}
		while(ch>='0' && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();} return flag? x:-x;}
	template<typename T> void read(T &x){ bool flag=1; x=0; char ch=getchar();
		while(ch<'0' || ch>'9'){if(ch=='-') flag=0; ch=getchar();}
		while(ch>='0' && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();} x=(flag? x:-x);}
	template<typename T,typename ...Args> void read(T &Re,Args &...Res){read(Re),read(Res...);}
	template<typename T> void write(T x,char ch=0){if(x<0) x=-x,putchar('-');
		static short s[35],top=-1; do{s[++top]=x%10;x/=10;}while(x);
		while(~top) putchar(s[top--]+48); if(ch) putchar(ch);}
	int gcd(int a,int b){return b==0? a:gcd(b,a%b);}
	int lcm(int a,int b){return a/gcd(a,b)*b;}
	void MADD(int &x,int y,int mod){x=(x+y>=mod? x+y-mod:x+y);}
	int ksc(int a,int b,int p){int ans=0;while(b){if(b&1)MADD(ans,a,p);MADD(a,a,p);b>>=1;}return ans;}
	int ksm(int a,int b,int p){int ans=1%p;while(b){if(b&1)ans=ans*a%p;a=a*a%p;b>>=1;}return ans;}
	int exgcd(int a,int b,int &x,int &y){if(b==0){x=1,y=0;return a;}int d=exgcd(b,a%b,y,x);y-=a/b*x;return d;}
	int inv(int t){int x,y;exgcd(t,mod,x,y);return (x%mod+mod)%mod;}
} using namespace Memory_Love;
const int N=1e5+5;
const int MK=22;
int n,m,k;
int B[MK][MK];

namespace FACT
{
	int fact[mod+5],infact[mod+5];
	void init(int n)
	{
		int i;
		for(i=fact[0]=infact[0]=1;i<=n;i++)
		{
			fact[i]=fact[i-1]*i%mod;
			infact[i]=infact[i-1]*ksm(i,mod-2,mod)%mod;
		}
	}
	int C(int n,int m)
	{
		if(n<m) return 0;
		return fact[n]*infact[m]%mod*infact[n-m]%mod;
	}
	int Lucas(int n,int m)
	{
		if(m==0) return 1;
		return C(n%mod,m%mod)*Lucas(n/mod,m/mod)%mod;
	}
} using FACT::Lucas;

struct Barrier
{
	int x,y;
}a[MK];
bool comp(const Barrier &a,const Barrier &b)
{
	if(a.x!=b.x)
	return a.x<b.x;
	else 
	return a.y<b.y;
}

int DP(int n,int m)
{
	int i,ans=0; n--,m--;
	for(i=0;i<=min(n,m);i++)
	(ans+=Lucas(n+m-i*2,n-i)*Lucas(n+m-i,i))%=mod;
	return ans;
}

bool Ending;
signed main()
{
	int i,j;
	read(n,m,k);
	FACT::init(mod-1);
	for(i=1;i<=k;i++)
	read(a[i].x,a[i].y);
	sort(a+1,a+1+k,comp);
	a[0]=(Barrier){1,1};
	a[k+1]=(Barrier){n+1,m+1};
	
	for(i=0;i<=k+1;i++)
	{
		for(j=i+1;j<=k+1;j++)
		{
			if(a[i].y>a[j].y)
			B[i][j]=0;
			else
			B[i][j]=DP(a[j].x-a[i].x+1,a[j].y-a[i].y+1);
		}
	}
	
	int ans=DP(n+1,m+1);
	for(i=0;i<(1<<k);i++)
	{
		if(i==0) continue;
		int now=1,last=0,t=-1;
		for(j=0;j<k;j++)
		{
			if(i>>j&1)
			{
				(now*=B[last][j+1])%=mod;
				last=j+1;
				t=-t;
			}
		}
		(ans-=now*B[last][k+1]*t)%=mod;
	}
	write((ans%mod+mod)%mod,'\n');
	cerr<<"\nused:"<<(abs(&Ending-&Beginning)/1048576)<<"MB\n";
	return 0;
}
```

---

## 作者：RegisterFault (赞：2)

## 题意

给定一个 $n \times m$ 的网格图，上面有 $K$ 个障碍。起点在 $(1, 1)$。要求：

 - 不能经过障碍格子。
 
 - 可以向右，向上，或者向右上走。
 
 - 从网格图右侧或者上面走出都算走出网格。

求走出网格的总方案数对 $59393$ 取模的结果。

## 分析

一道很好的组合数学题。

首先，由于从网格右边和上边走出去都算走出网格，因此可以抽象为：从 $(1, 1)$ 走到 $(n + 1, m + 1)$ 的方案数。接下来，我们将限制由弱到强，逐步考虑。

 - **不考虑走障碍，也不考虑走斜线**。相当于一共走 $n + m$ 步，其中有 $n$ 步向上，其余向右。所以答案就是：

$$\binom{n + m}{n}$$

 - **不考虑走障碍，考虑走斜线**。一个很经典的思路就是：枚举走斜线的个数，假设为 $k$。那么剩下就需要走 $n - k$ 次向右，$m - k$ 次向上。设 $n_0 = n - k$，$m_0 = m - k$。那么仅走直线的方案数就是：
 
 $$\binom{n_0 + m_0}{n_0}$$

接下来考虑走斜线。根据插板法，相当于把 $k$ 个板子插到 $n_0 + m_0 + k$ 个空里，方案数为：

$$\binom{n_0 + m_0 + k}{k}$$

因此总方案数就是：

$$\sum \limits_{k = 0}^{\min(n, m)} \binom{n_0 + m_0}{n_0}\binom{n_0 + m_0 + k}{k}$$

 - **考虑走障碍，也考虑走斜线**。可以容斥一下，也就是：减去经过至少一个障碍的方案数，加上经过至少两个障碍的方案数……可以先对障碍按照横坐标排序，然后求出每两个点之间的方案数，最后再爆搜容斥一下。
 
 由于模数很小，可以使用卢卡斯定理求组合数。时间复杂度 $O(2 ^ k + m k ^ 2)$。
 
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#define int long long

using namespace std;

const int N = 100010, M = 25;
const int mod = 59393;

int fac[N], inv[N], c[M][M];
int n, m, ans, cnt, K, path[N];

struct Horse {
	int x, y;
	bool operator < (const Horse &t)const {
		if (x == t.x) return y < t.y;
		return x < t.x;
	}
}p[N];
int power(int a, int b = mod - 2) {
	if (b == 0) return 1; int ans = 1;
	for (; b; b >>= 1, a = a * a % mod)
		if (b & 1) ans = ans * a % mod; return ans;
}
int C(int n, int m) {
	return fac[n] * inv[n - m] % mod * inv[m] % mod;
}
int lucas(int n, int m) {
	if (m > n) return 0;
	if (!m) return 1;
	if (n < mod and m < mod)
		return C(n, m);
	return lucas(n % mod, m % mod) * lucas(n / mod, m / mod) % mod;
}
int solve(int n, int m) {
	int ans = 0;
	for (int k = 0; k <= min(n, m); k ++ ) {
		int n0 = n - k, m0 = m - k;
		(ans += lucas(n0 + m0 + k, k) * lucas(n0 + m0, n0) % mod) %= mod;
	} return ans;
}
void init() {
	for (int i = 1; i <= K; i ++ )
		for (int j = i + 1; j <= K; j ++ ) {
			if (p[j].y >= p[i].y)
				c[i][j] = solve(p[j].x - p[i].x, p[j].y - p[i].y);
		}
	for (int i = 1; i <= K; i ++ ) c[0][i] = solve(p[i].x - 1, p[i].y - 1);
	for (int i = 1; i <= K; i ++ ) c[i][K + 1] = solve(n + 1 - p[i].x, m + 1 - p[i].y);
}
void dfs(int u) {
	if (u > K) {
		int res = 1; path[ ++ cnt] = K + 1;
		for (int i = 1; i < cnt; i ++ )
			(res *= c[path[i]][path[i + 1]]) %= mod;
		if (cnt & 1) ans = (ans - res + mod) % mod;
		else ans = (ans + res) % mod;
		cnt -- ; return;
	}
	dfs(u + 1); path[ ++ cnt] = u; dfs(u + 1); path[cnt -- ] = 0;
}
signed main() {
	scanf("%lld%lld%lld", &n, &m, &K);
	fac[0] = inv[0] = 1ll; // init invs.
	for (int i = 1; i <= mod; i ++ )
		fac[i] = fac[i - 1] * i % mod;
	inv[mod - 1] = power(fac[mod - 1]);
	for (int i = mod - 2; i >= 1; i -- )
		inv[i] = inv[i + 1] * (i + 1) % mod;
	for (int i = 1; i <= K; i ++ )
		scanf("%lld%lld", &p[i].x, &p[i].y);
	sort(p + 1, p + K + 1);
	init(); ans += solve(n, m);
	cnt ++ ; dfs(1); // 容斥 
	printf("%lld\n", ans);
	return 0;
}
```
 

---

## 作者：AThousandSuns (赞：2)

在我的博客看食用效果更佳：[点这里](https://www.cnblogs.com/1000Suns/p/10922140.html)

---
这是前几天杂题选讲时学长讲的题。算是很良心的。

先考虑没有障碍怎么做。

首先发现，答案相当于一个左下角是 $(1,1)$，右上角是 $(n+1,m+1)$ 的棋盘，从 $(1,1)$ 走到 $(n+1,m+1)$ 的方案数。因为走到最上或最右就只有一种选法了。

枚举斜着走的次数 $i$。答案是 $\sum\limits_{i=0}^{\min(n,m)}\dbinom{n+m-i}{i}\dbinom{n+m-2i}{n-i}$。前面是选哪几步，后面是经典过河卒。（注意 $n,m$ 是 $x2-x1$ 和 $y2-y1$）

现在考虑有障碍。明显容斥。

令 $g[S]$ 表示至少经过 $S$ 中障碍的方案数。（可能经过更多的障碍）

答案是 $\sum\limits_Sg[S](-1)^{|S|}$。

如何计算 $g[S]$？

先把障碍按 $x$ 为第一关键字排序，按 $y$ 为第二关键字排序。

那么 $S$ 中如果存在 $i<j,y[i]>y[j]$ 那么为 $0$。

否则就是从起点到第一个点的方案数，从第一个点到第二个点的方案数……从最后一个点到终点的方案数的乘积。

时间复杂度看起来是 $O(2^k\min(n,m))$。

但是我们发现很多个方案数是被重复计算的。如果我们预处理两两点之间的方案数就能做到 $O(2^kk+k^2\min(n,m))$。

模数是质数，可以用卢卡斯定理。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=59393;
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define ROF(i,a,b) for(int i=(a);i>=(b);i--)
#define MEM(x,v) memset(x,v,sizeof(x))
inline int read(){
	char ch=getchar();int x=0,f=0;
	while(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return f?-x:x;
}
struct pos{
	int x,y;
	bool operator<(const pos &p)const{
		if(x!=p.x) return x<p.x;
		return y<p.y;
	}
}p[22];
int n,m,k,x[22],y[22],cnt[22][22],fac[mod],inv[mod],invfac[mod],ans,sz[1111111],in[22],out[22];
void init(){
	fac[0]=fac[1]=inv[1]=invfac[0]=invfac[1]=1;
	FOR(i,2,mod-1){
		fac[i]=1ll*fac[i-1]*i%mod;
		inv[i]=mod-1ll*(mod/i)*inv[mod%i]%mod;
		invfac[i]=1ll*invfac[i-1]*inv[i]%mod;
	}
}
int C(int n,int m){
	if(n<0 || m<0 || n<m) return 0;
	return 1ll*fac[n]*invfac[m]%mod*invfac[n-m]%mod;
}
int lucas(int n,int m){
	if(n<mod) return C(n,m);
	return 1ll*lucas(n/mod,m/mod)*lucas(n%mod,m%mod)%mod;
}
int calc(int n,int m){
	int ans=0;
	FOR(i,0,min(n,m)) ans=(ans+1ll*lucas(n+m-i,i)*lucas(n+m-2*i,n-i))%mod;
	return ans;
}
int solve(int S){
	int pre=-1,ans=1;
	FOR(i,0,k-1) if((S>>i)&1){
		if(pre==-1) ans=1ll*ans*in[i]%mod;
		else{
			if(y[pre]>y[i]) return 0;
			ans=1ll*ans*cnt[pre][i]%mod;
		}
		pre=i;
	}
	if(~pre) return 1ll*ans*out[pre]%mod;
	else return calc(n,m);
}
int main(){
	n=read();m=read();k=read();
	init();
	FOR(i,0,k-1) p[i].x=read(),p[i].y=read();
	sort(p,p+k);
	FOR(i,0,k-1) x[i]=p[i].x,y[i]=p[i].y;
	FOR(i,0,k-1) FOR(j,i+1,k-1) cnt[i][j]=calc(x[j]-x[i],y[j]-y[i]);
	FOR(i,0,k-1) in[i]=calc(x[i]-1,y[i]-1),out[i]=calc(n+1-x[i],m+1-y[i]);
	FOR(i,1,(1<<k)-1) sz[i]=sz[i>>1]+(i&1);
	FOR(i,0,(1<<k)-1){
		if(sz[i]&1) ans=(ans-solve(i)+mod)%mod;
		else ans=(ans+solve(i))%mod;
	}
	printf("%d\n",ans);
}
```

---

## 作者：lzh0220 (赞：1)

（~~怎么题解区就我的做法是 $O(2^kk+k^2m)$ 的~~）

首先发现卒可以从棋盘的上方或右方走出棋盘等价于卒最后走到 $(n+1,m+1)$，因为卒走出方格以后到 $(n+1,m+1)$ 的路径是唯一的。

先不考虑卒从 $(x,y)$ 走到 $(x+1,y+1)$ 这种情况和障碍，那么由过河卒的熟知结论，从 $(1,1)$ 走到 $(n+1,m+1)$ 有方案数为 $C_{n+m}^n$，可以理解为从要走的 $m+n$ 步中选出 $n$ 步沿 $x$ 轴走。

然后我们考虑一下卒从 $(x,y)$ 走到 $(x+1,y+1)$ 怎么处理。考虑直接暴力枚举这样走的次数，那么设从 $(1,1)$ 走到 $(x+1,y+1)$ 的方案数为 $$\sum\limits_{i=0}^{\min(n,m)}C_{n+m-i}^{i}\times C_{n+m-2i}^{n-i}$$（其实看一下式子基本都能理解），使用 Lucas 定理求解。

接下来考虑障碍的情况。发现障碍很少，那么我们可以 $O(2^k)$ 枚举选哪些障碍，用容斥原理计算。可以通过 $O(k^2m)$ 预处理任意两个障碍之间的方案数来降低复杂度。

总复杂度 $O(2^kk+k^2m)$，代码写得比较丑就不放了。

---

## 作者：InoueTakina (赞：1)

给定 $n$ 个障碍点，问不经过这 $n$ 个障碍点从 $(0,0)\to (m,m)$ 的方案数。（默认只向右或向上）。

首先我们要先知道一个东西：从 $(0,0)\to (x,y)$ 的方案数是 $x+y\choose x$。

然后不妨把 $(m,m)$ 记作障碍点，记 $f_i$ 表示不经过其他障碍点走到第 $i$ 个障碍点的方案数。当然这些障碍点要按 $x$ 排序先。

然后就有 $f_i=w((0,0)\to (x_i,y_i))-\sum \limits_{j<i,y_j\le y_i} f_j\times w((x_j,y_j)\to (x_i,y_i))$。

为什么要记这种烂大街的东西呢，我也不知道为什么 P5376 的出题人要把 $k$ 才开到 $20$。

---

## 作者：_RainCappuccino_ (赞：0)

> $\texttt {TAGS}$：组合，容斥


如果去掉斜向右走，那么两点之间的方案数为 $C_{|X_a - X_b| + |Y_a - Y_b|}^{|X_a - X_b|}$ 表示选择总步数中的 $|X_a - X_b|$ 步为向前走。

那么考虑斜向右走，此时两个坐标同时增加，不好直接用组合数表示，不妨考虑枚举斜向走的步数。

那么方案数可以表示为 $\sum_{i = 0}^{\min(x, y)} C_{x + y - 2i}^{x - i} \times C_{x + y - i}^{i}$（这里 $x, y$ 表示两点横纵坐标差），左边的组合数意义为除去斜向走的其余走法的**内部**方案数，右边的组合数意义为选取总步数中 $i$ 步为斜向走的方案数，由于两个部分**互不影响**，所以根据乘法原理，两数之积为斜向 $i$ 步的方案数。每次计算的时间复杂度为 $O(\min(x, y)) \le O(m)$。

下面记 $cal(x_1,y_1, x_2, y_2)$ 为两点之间的方案数。

回到题目，此题 $n \times m$ 很大，但是关键点的数量很小，可以考虑容斥，记走到关键点 $i$ 的方案数为 $f_i$，由于不能经过其余点，所以 $f_i = cal(1, 1, x_i, y_i) - \sum f_j \times cal(x_j, y_j) [x_i \ge x_j,y_i \ge y_j]$。

一般套路是将终点加入到关键点中直接计算，但是此题的终点有 $n + m$ 个，我们需要找到一个**超级汇点**，考虑添加一行一列，所有终点到 $(n + 1, m + 1)$ 的方案数都为 $1$，那么 $(n + 1, m + 1)$ 即为超级汇点，加入计算即可。

最终时间复杂度 $O(k^2m)$。

---

## 作者：MoYuFang (赞：0)

首先原问题可化为从 $(0,0)$ 到 $(n,m)$ 的路径数，因为从 (1,1) 走出棋盘后到 $(n+1,m+1)$ 的路径唯一，相当于从 $(1,1)$ 到 $(n+1,m+1)$ 的路径数。

设在没有障碍下 $(0,0)$ 到 $(x,y)$ 的路径数为 $f(x,y)$。

枚举路径中向右上方向走的次数（从 $0$ 到 $\min(x,y)$​），累和可得：
$$
f(x,y) = \sum_{i=0}^{\min(x,y)} C_{x+y-i}^{x-i}\cdot C_y^i
$$
然后考虑有障碍情况下的答案。

令 $S$​ 为障碍点的集合（$S$ 中装的是障碍点的编号），对于 $S$ 的子集 $T$，$P(T)$ 表示经过 $T$ 中所有障碍点且从 $(0,0)$ 走到 $(n,m)$ 的方案数。

根据容斥原理可得答案为：
$$
ans = \sum_{T\subseteq S} (-1)^{|T|}P(T)
$$
考虑对于 $S$ 某子集 $T$，$P(T)$ 该如何计算。

设 $T = \{x_j | 1\leq j \leq |T|\}$ 其中 $x_j$ 表示障碍点的编号，再令 $l(i)$ 与 $r(i)$ 分别表示障碍点 $i$ 的 $x$ 坐标与 $y$ 坐标。

可以发现若 $T$ 中存在满足 $l(x_1) > l(x_2)$ 但 $r(x_1) < r(x_2)$ 的两个障碍点（不妨称作相斥障碍点），则不存在同时经过两个障碍点的路径，此时 $P(T) = 0$。

所以只需考虑不存在相斥障碍点的 $T$​ ，不妨设 $T$ 中 $\forall i<j$，有 $l(x_i) \leq l(x_j)$ 和 $r(x_i) \leq r(x_j)$​。

则 $P(T)$ 等于以 $(0,0)$ 为起点，以此经过 $x_1,x_2,...,x_{|T|}$ 后再到 $(n,m)$ 的方案数，相邻两个障碍点之间没有任何障碍。

设 $F(i,j)$ 表示从障碍点 $i$ 到 障碍点 $j$ （两个障碍点不相斥且从 $i$ 能走到 $j$）的方案数，则有：
$$
F(i,j) = f( l(j)-l(i),r(j)-r(i) )
$$
因而：
$$
P(T) = F(0,x_1)\cdot F(x_1,x_2) \cdot \cdot \cdot F(x_{|T|-1},x_{|T|})\cdot F(x_{|T|},k+1)
$$
其中 $F(0,i)$ 表示从 $(0,0)$ 到障碍点 $i$ 的方案数，$F(i,k+1)$ 表示从障碍点 $i$ 到 $(n,m)$ 的方案数。

再来考虑如何处理容斥公式：
$$
\sum_{T\subseteq S} (-1)^{|T|}P(T)
$$
直接计算 $O(k\cdot 2^k \cdot \min(n,m))$ 肯定超时，所以可以想到对付容斥式常用的 $\text{dp}$ 技巧。

令：
$$
Q(T) = \frac{P(T)}{F(x_{|T|},k+1)}
$$
则：
$$
\sum_{T\subseteq S} (-1)^{|T|}P(T) = \sum_{T\subseteq S} (-1)^{|T|}Q(T)\cdot F(x_{|T|},k+1)
$$
不妨先将 $S$ 中的障碍点以 $x$ 坐标为第一关键字 $y$​ 坐标为第二关键字升序排序，$S$ 中的点有序后就方便 $\text{dp}$ 了。

设：
$$
\begin{aligned}
g(i,j) = & \sum_{\begin{aligned} T\subseteq S\\|T|=j\\ \forall x \in T,x\leq i \\ i \in T\end{aligned}}
(-1)^{|T|}Q(T)\\
= & \sum_{\text{条件同上}} (-1)^{|T|}\frac{P(T)}{F(i,k+1)}\\
= & \frac{1}{F(i,k+1)} \sum_{\text{条件同上}}(-1)^{|T|}P(T)
\end{aligned}
$$
这相当于把上面的容斥式拆分了，每一个 $g(i,j)$ 代表了所有的只包含前 $i$ 个障碍点中 $j$ 个且包含障碍点 $i$ 的 $T$ 对容斥式的贡献之和，为了方便下面 $\text{dp}$ 的转移还让每个 $T$ 的 $P(T)$ 除了 $F(i,k+1)$。 

转移式显然，枚举在 $i$ 之前的出现的上一个障碍点累和即可：
$$
g(i,j) = \sum_{l=0,yes(l,i)}^{i-1} g(l,j-1)\cdot F(l,i)\cdot (-1)
$$
其中 $yes(l,i)$ 代表障碍点 $l$ 与障碍点 $i$ 不相斥。

初始时有：
$$
\begin{aligned}
&g(0,0)=1\\
&g(i,0)=0\quad(i>0)\\
&g(0,j)=0\quad(j>0)
\end{aligned}
$$
则有：
$$
\begin{aligned}
ans = &\sum_{T\subseteq S} (-1)^{|T|}P(T)\\
	= &\sum_{i=0}^{k}\sum_{j=0}^{i} g(i,j)\cdot F(i,k+1)\quad (*)

\end{aligned}
$$
预处理出任意两个不相斥障碍点的 $F(i,j)$ 后（花费 $O(k^2\cdot \min(n,m))$），$g(i,j)$ 可以通过 $O(k^3)$ 的 $\text{dp}$ 求出。

于是答案可以通过式 $(*)$ 以 $O(k^2)$ 求出。

总时间复杂度为 $O(k^2\cdot \min(n,m)+k^3+k^2)$。

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <iostream>
#include <assert.h>
using namespace std;

typedef int _xx;
#define int unsigned int
#define re register
#define sf scanf
#define pf printf
#define nl() putchar('\n')
#define ms(x, val) memset(x, val, sizeof(x))
#define ll long long
#define _for(i, a, b) for(re int (i) = (a); (i) < (b); ++(i))
#define _rfor(i, a, b) for(re int (i) = (a); (i) <= (b); ++(i))
#define mod 59393u
#define maxk 22

int rdnt(){
	re int x = 0, sign = 1;
	re char c = getchar();
	while (c < '0' || c > '9') { if (c == '-') sign = -1; c = getchar(); }
	while (c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (c ^ 48), c = getchar();
	return x * sign;
}

int
	fac[mod], //fac(i) = i! 阶乘 
	ivf[mod], //ivf(i) = inv(i!) 阶乘的逆元 
	g[maxk][maxk],
	F[maxk][maxk];
	
struct Par{ int l, r; } par[maxk];
bool operator<(const Par &p1, const Par &p2){ return (p1.l == p2.l) ? (p1.r < p2.r) : (p1.l < p2.l); }
#define yes(i, j) (par[i].l <= par[j].l && par[i].r <= par[j].r)

inline void add(int &x, int y) { if ((x+=y) >= mod) x -= mod; }

//lucas 求组合数
int C(re int n, re int m){
	if (!m) return 1;
	else if (m%mod > n%mod) return 0;
	else return fac[n%mod] * ivf[m%mod] % mod * ivf[(n-m)%mod] % mod * C(n/mod, m/mod) % mod;
}

//(0,0) 到 (n,m) 的方案数 
int f(re int x, re int y){
	re int ans = 0;
	_rfor(i, 0, min(x, y)) add(ans, C(x+y-i, x-i) * C(y,i) % mod);
	return ans;
}

_xx main(){
	fac[0] = ivf[0] = fac[1] = ivf[1] = 1;
	_for(i, 2, mod) fac[i] = i*fac[i-1]%mod, ivf[i] = (mod-mod/i)*ivf[mod%i]%mod;
	_for(i, 2, mod) ivf[i] = (ivf[i]*ivf[i-1])%mod;
	
	re int n = rdnt(), m = rdnt(), k = rdnt();
	
	//对障碍点排序 
	par[0] = (Par){0, 0}; par[k+1] = (Par){n, m};
	_rfor(i, 1, k) par[i].l = rdnt()-1, par[i].r = rdnt()-1;
	sort(par+1, par+1+k);
	
	//F(i,j) 的预处理 
	_rfor(i, 0, k+1) _rfor(j, i+1, k+1){
		if (!yes(i, j)) continue;
		F[i][j] = f(par[j].l - par[i].l, par[j].r - par[i].r);
	}
	
	//dp
	g[0][0] = 1;
	_rfor(i, 1, k) _rfor(j, 1, i) _rfor(l, j-1, i-1){
		if (!yes(l, i)) continue;
		add(g[i][j], (mod-1)*g[l][j-1]%mod*F[l][i]%mod);
	}
	
	re int ans = 0;
	_rfor(i, 0, k) _rfor(j, 0, i) add(ans, g[i][j]*F[i][k+1]%mod);
	
	pf("%u\n", ans);
	
	return 0;
}




```




---

## 作者：Infiltrator (赞：0)

[$\Large\color{#FFBBFF}\textit{Tian-Xing's blog}$](https://Tian-Xing.github.io)

------------

# Description

[传送门](https://www.luogu.com.cn/problem/P5376)

------------

# Solution

首先走出大小为$n \times m$的棋盘后只有一种方式走到$(n + 1, m + 1)$，所以题意可以转化为从$(1, 1)$走到$(n + 1, m + 1)$的方案数。

那么先不考虑障碍，从$(1, 1)$走到$(n + 1, m + 1)$，可以先枚举一共斜着走了几次，然后剩下的部分就是经典过河卒问题。也就是

$$\sum_{i = 0}^n \binom{n + m - i}{i} \binom{n + m - 2 \times i}{n - i}$$

前面一部分的原因是本来一共要横着走$n$步，竖着走$m$步，现在斜着走一次可以看做少走一次竖着或者横着，即一共走$n + m - i$步，那么从中间选$i$步走斜着的。

发现根据组合数的性质这个式子可以好看一点，~~虽然没啥用~~。

$$\sum_{i = 0}^n \binom{n}{i} \binom{n + m - i}{n}$$

现在有了不能走的点，考虑容斥。用不加限制的减去一个限制的加上两个限制的……

那么先预处理出任意两个障碍点之间的方案数，然后枚举限制容斥即可。

------------

# Code

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define MOD 59393
#define ll long long
int n,m,k;
ll jc[70050],zhi[25][25],inv[70050];
int read()
{
	int s=0,p=1;
	char st=getchar();
	while(st<'0' || st>'9')
	{
		if(st=='-')p=-1;
		st=getchar();
	}
	while(st>='0' && st<='9')
	{
		s=(s<<1)+(s<<3)+(st^48);
		st=getchar();
	}
	return s*p;
}
struct point
{
	int x,y;
}dian[50];
bool cmp(point aa,point bb)
{
	if(aa.x!=bb.x)return aa.x<bb.x;
	else return aa.y<bb.y;
}
ll ksm(ll a,ll p)
{
	ll tmp=1;
	while(p)
	{
		if(p&1)tmp=(tmp*a)%MOD;
		a=(a*a)%MOD;
		p>>=1;
	}
	return tmp;
}
ll work(ll n,ll m)
{
	if(m>n)return 0;
	return (jc[n]*inv[m])%MOD*inv[n-m]%MOD;
}
ll lucas(ll n,ll m)
{
	if(!m)return 1;
	return lucas(n/MOD,m/MOD)*work(n%MOD,m%MOD)%MOD;
}
ll calc(ll a,ll b)
{
	a--;b--;
	if(a>b)swap(a,b);
 	ll tmp=0; 
	for(int i=0;i<=a;i++)
	{
		(tmp+=(lucas(a,i)*lucas(a+b-i,a))%MOD)%=MOD;
	} 
	return tmp;
}
int main()
{
	jc[0]=1;inv[0]=1;
	for(int i=1;i<=60050;i++)jc[i]=(jc[i-1]*i)%MOD,inv[i]=ksm(jc[i],MOD-2);
	n=read();m=read();k=read();
	for(int i=1;i<=k;i++)dian[i].x=read(),dian[i].y=read();
	sort(dian+1,dian+k+1,cmp);
	for(int i=1;i<=k;i++)
		for(int j=i+1;j<=k;j++)
			zhi[i][j]=calc(dian[j].x-dian[i].x+1,dian[j].y-dian[i].y+1);
	for(int i=1;i<=k;i++)zhi[0][i]=calc(dian[i].x,dian[i].y);
	for(int i=1;i<=k;i++)zhi[i][k+1]=calc(n+2-dian[i].x,m+2-dian[i].y);
	ll answer=calc(n+1,m+1);
	for(int i=1;i<(1<<k);i++)
	{
		ll tmp=1,last=0;
		int js=0;
		for(int j=1;j<=k;j++)
			if(1<<(j-1)&i)js++,tmp=tmp*zhi[last][j]%MOD,last=j;
		tmp=tmp*zhi[last][k+1]%MOD;
		js%2==0?(answer+=tmp)%=MOD:(answer-=tmp)%=MOD;
	}
	printf("%lld",(answer%MOD+MOD)%MOD);
    return 0;
}
```

---


# [省选联考 2022] 卡牌

## 题目描述

小 A 有 $n$ 张卡牌，编号为 $1, 2, \ldots, n$。每张卡牌上写着一个正整数，第 $i$ 张卡牌上的正整数为 $s_i$。

现在有 $m$ 轮游戏，第 $i$ 轮游戏会给出 $c_i$ 个质数，小 A 需要选择任意多张卡牌，使得这些卡牌上面的正整数的乘积能被该轮游戏给出的每个质数整除。

这当然难不倒小 A，于是他开始思考一个更难的问题，对于每一轮游戏，他有多少种卡牌的选法。

这给小 A 整不会了，于是他只能来求助你，你只需要告诉他答案模 $998244353$ 的值即可。两种选法 A 和 B 互不相同当且仅当存在一张卡牌在 A 中被选择但在 B 中未被选择或者存在一张卡牌在 B 中被选择但在 A 中未被选择。注意：牌面上的数字相同但编号不相同的两张卡牌被视为不同的卡牌。

## 说明/提示

**【样例解释 #1】**

第一轮游戏：除了以下 $5$ 种方案外其它方案都可行：什么都不选、选 $2$、选 $5$、选 $46$、选 $2$ 和 $46$。所以答案为 $2^5 - 5 = 27$。

第二轮游戏：只要选了 $46$，其它卡牌选不选均可，所以答案为 $2^4 = 16$。

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le {10}^6$，$1 \le s_i \le 2000$，$1 \le m \le 1500$，$1 \le c_i, \sum_i c_i \le 18000$，$2 \le p_{i, j} \le 2000$。

| 测试点 | $n \le$ | $m \le$ | $\sum_i c_i \le$ | 其他限制 |
|:-:|:-:|:-:|:-:|:-:|
| $1 \sim 2$ | $10$ | $10$ | $20$ | $s_i \le 30$ |
| $3 \sim 5$ | $10$ | $20$ | $50$ | 无 |
| $6 \sim 8$ | ${10}^6$ | $1500$ | $10000$ | $s_i \le 30$ |
| $9 \sim 11$ | $10000$ | $1000$ | $5000$ | $s_i \le 500$ |
| $12 \sim 13$ | $1000$ | $100$ | $1000$ | 无 |
| $14 \sim 17$ | $5000$ | $600$ | $7000$ | 无 |
| $18 \sim 20$ | ${10}^6$ | $1500$ | $18000$ | 无 |

## 样例 #1

### 输入

```
5
10 2 10 5 46
4
2 2 5
2 2 23
1 3
1 23```

### 输出

```
27
16
0
16```

## 样例 #2

### 输入

```
见附件中的 card/card2.in```

### 输出

```
见附件中的 card/card2.ans```

# 题解

## 作者：lg_zhou (赞：57)

> 赛时想到容斥，想到正难则反，不知道哪根筋搭错了，最后喜提 $25pts$ 。看到好多大佬写的 FWT，然而并不会，也并不需要。

**update on 4.27** **修改了 $s[i] = 1$ 的情况**

选法题，要么动规，要么数学，这道题一眼看去就是容斥题。直接容斥不是特别好做，样例给了充足的提示，考虑正难则反。就是全部的方案数减去不合法的即可。

首先 $n$ 并没有用，因为我们只关心同一类的数有多少个，而最多有两千个不一样的数。

这样 $s[i]\le30$ 的部分分解法就呼之欲出了。答案即为 $2^n$ 减去选排列中不含 $p[j](j \in [1,c_i])$ 的方案数，这样不含两个质数的方案数被减去两遍，要加上，再减去含不含三个质数的...... 由于 $s[i]$ 很小，$30$ 以内的质数只有十一个，暴力枚举即可。

如果 $s[i] \le 2000$，考虑根号分治。已知 $43*47>2000$。所以每个数最多只有一个大于等于 $43$ 的质因数。假设我们并不关心小于 $43$ 的质数，那就很简单了，枚举每一个大于等于 $43$ 的质数，统计数列中有多少数被它整除，记为 $f[i]$。如果询问集合中包含这个质数，那么就至少选一个，答案 $*=2^{f[i]}-1$，否则选不选都行，答案 $*=2^{f[i]}$

如果把前十三个质数（$\le 43$）加进来，依旧可以暴力容斥，而且这样我们只用枚举前十三个质数的情况即可。

具体的，记 $f[i][j]$ 为 $i$ 代表不含前十三个质数枚举的情况（状压），$j$ 代表是第 $j$ 个质数倍数（$j>13$）的数有多少。这个数组是可以预处理的。对于每个询问来说，大力容斥，这道题就做完了。

代码：

```cpp
#include<iostream>
#include<cstring>
#include<vector>
#include<algorithm>
#define int long long
using namespace std;
const int maxn = 2005;
const int mod = 998244353;
int is_p[maxn], p[maxn], hsp[maxn],cnt;
vector<int> v[maxn];
long long n,m,c;
int q[2005];
int a[maxn],ans;
long long edans;

int f[(1<<13)+5][305];
int ksm(int a, int b){
	int mul = 1;
	while(b){
		if (b&1){
			mul = mul*a%mod;
		}
		a = a*a%mod;
		b >>= 1;
	}
	return mul;
}
void init(){
	for (int i = 2; i <= 2000; i++){ // 埃筛 
		if (!is_p[i]){
			p[++cnt] = i;
			hsp[i] = cnt;
		}
		for (int j = 2; j*i <= 2000; j++){
			is_p[i*j] = 1;
		}
	}
	for (int i = 2; i <= 2000; i++){
		for (int j = 1; j <= cnt; j++){
			if (i%p[j] == 0){
				if (j <= 13) q[i] |= (1<<j-1); //查看每个数的前13个质数的包含情况 
				v[i].push_back(j); //所有数的质因子 
			} 
		}
	}
}


vector<int> hvp;

int tt[(1<<13)+5];//不含当前状态的数一共有多少 
signed main(){
	//freopen("a.in","r",stdin);
	//freopen("card.out","w",stdout);
	cin >> n;
	init();
	for (int i = 1; i <= n; i++){
		long long val;
		cin >> val;
		a[val]++;
	}

	cin >> m;
	for (int i = 0; i < (1<<13); i++){//枚举不含哪些质数 
		for (int j = 2; j <= 2000; j++){
			if ( (q[j]&i) ) continue; //说明含了，continue 
			f[i][v[j][v[j].size()-1]] += a[j]; //个数加上这个数有多少 
			f[i][v[j][v[j].size()-1]] %= mod;
			tt[i] += a[j];
		}
		tt[i] += a[1];
	}
	
	
	for (int i = 1; i <= m; i++){
		
		edans = 0;
		hvp.clear();
		
		int less = 0;//询问序列与前十三个质数的交集 
		cin >> c;
		for (int j = 1; j <= c; j++){
			long long t;
			cin >> t;
			hvp.push_back(t);
			if (hsp[t] <= 13){
				less |= (1<<hsp[t]-1);
			}
		}
		sort(hvp.begin(),hvp.end());
		
		for (int j = 0; j < (1<<13); j++){
			if ( (j|less) != less) continue;
			int ct = tt[j];//一共有这么多数 
			ans = 1;
			for (int k = 0; k < c; k++){
				if (hvp[k] <= 41) continue;
				(ans *= (ksm(2,f[j][hsp[hvp[k]]])-1)) %= mod;//必须选 
				ct -= f[j][hsp[hvp[k]]];
			}
			(ans *= ksm(2,ct)) %= mod;//剩下的选不选都行 
			
			int cnt1 = 0;
			for (int k = 0; k <= 13; k++) cnt1 += (j>>k&1);//看看容斥是加还是减 
			if (cnt1&1) (edans -= ans)%=mod;
			else (edans+=ans)%=mod;
		}
		cout << (edans%mod+mod)%mod << endl;
	}
	
	return 0;
}
```


---

## 作者：dottle (赞：31)

考虑容斥，钦定一些质数，强制它们不被满足，换言之，它们的倍数不能被选。算出能选的数的个数 $x$，$2^x$ 就是此时的方案数。容斥系数算出来以后就是 $(-1)^{|S|}$，其中 $S$ 是钦定的数的个数。

考虑用一个 dp 来跑这个容斥，有一个显然的做法：设 $dp_{i,S}$ 代表考虑了第 $i$ 个质数，前面钦定的质数集合为 $S$。可以预处理 $C_{p,S}$ 代表 $p$ 的倍数中，不是 $S$ 中元素倍数的有多少个。 这样，转移比较简单：

$$
dp_{i-1,S}\to dp_{i,S}
$$
$$
-dp_{i-1,S} \times 2^{-C_{p_i,S}}\to dp_{i,S\bigcup \{p_i\}}
$$

然后，将大于 $\sqrt {2000}$ 的质数称为大质数，其他的称为小质数。则两个大质数的积一定大于 $2000$ 了，换言之，对于一个大质数 $p$，$S$ 中的大质数的存在与否不会影响 $C_{p,S}$ 的值。也就是说，我们可以只记录小质数的存在性，而小质数只有 14 个，因此上述的 $dp$ 可以状压实现，复杂度为 $2^{14} \times \sum c$，算下来大约 $2\times 10 ^8$，随便过。

---

关于 $C$ 的预处理，方法很多，我的方法可供参考。

首先计算 $D_{i,S}$ 代表 $i$ 是否可以被 $S$ 中的元素整除，暴力计算。

然后计算 $C_{p,S}$，直接枚举 $p,S$ 和 $p$ 的倍数，根据 $D$ 数组可以简单地计算。

两部分的复杂度都是 $a\log\log a\times 2^{14}$，其中 $a$ 是值域，即枚举所有质数的倍数的复杂度乘 $2^{ 14}$。

---

还是给个代码吧。

```
#include<bits/stdc++.h>
#define int long long
const int N=1000050,M=2050,P=14,mod=998244353;
using namespace std;

int p[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43};
int pri[M],v[M],c,pid[M];
//2^14 = 16384

int n,m,mx;
int s[N],cnt[N]; 
int dp[2][1<<P];
int id[M],nid;
int sum[M/5][1<<P];
bool isdiv[1<<P][M];
int piv[N]; 

int gsc(int a,int b){
	int ans=1;
	for(int i=1;i<=b;i<<=1,a=a*a%mod)
		if(b&i)ans=ans*a%mod;
	return ans;
}int inv(int k){return gsc(k,mod-2);}

void add(int&x,int y){
	x+=y;x%=mod;if(x<0)x+=mod;
}

void calc(){
	cin>>m;
	for(int i=1;i<=m;i++){
		memset(dp,0,sizeof(dp));
		int k;cin>>k;
		vector<int> np,ns;
		vector<int> vis(M); 
		for(int i=0;i<k;i++){
			int x;cin>>x;
			if(vis[x])continue;
			vis[x]=1;
			if(id[x])ns.push_back(x);
			else np.push_back(x);
		}
		sort(ns.begin(),ns.end());
		sort(np.begin(),np.end());
		int t=1;
		dp[0][0]=1;
		for(auto x:ns){
			memset(dp[t],0,sizeof(dp[t]));
			int i=id[x]-1;
			for(int S=0;S<1<<nid;S++){
				int nv=dp[t^1][S];
				if(!nv)continue;
				int nw=sum[pid[x]][S];
				add(dp[t][S],dp[t^1][S]);// not get
				add(dp[t][S|1<<i],-dp[t^1][S]*piv[nw]);//get *-1 * \frac 1 2^k
			}
			t^=1;
		}//important
		for(auto x:np){
			memset(dp[t],0,sizeof(dp[t]));
			for(int S=0;S<1<<nid;S++){
				int nv=dp[t^1][S];
				if(!nv)continue;
				int nw=sum[pid[x]][S];
				add(dp[t][S],dp[t^1][S]);// not get
				add(dp[t][S],-dp[t^1][S]*piv[nw]);//get *-1 * \frac 1 2^k
			}
			t^=1;
		}
		int res=0;
		for(int i=0;i<1<<nid;i++)
			add(res,dp[t^1][i]);
		res=res*gsc(2,n)%mod;
		cout<<res<<endl;
	}
}

void sie(){
	for(int i=2;i<M;i++){
		if(!v[i])pri[++c]=i,pid[i]=c;
		for(int j=1;i*pri[j]<M;j++){
			v[i*pri[j]]=1;
			if(i%pri[j]==0)break;
		}
	}
	for(int i=0;i<1<<nid;i++)
		for(int j=0;j<nid;j++)
			if(i>>j&1)
				for(int k=p[j];k<M;k+=p[j])
					isdiv[i][k]=1;
	for(int t=1;t<=c;t++)
		for(int k=0;k<1<<nid;k++){
			int i=pri[t];
			int s=0;
			for(int j=1;i*j<M;j++)
				if(!isdiv[k][j])
					s+=cnt[i*j];
			sum[t][k]=s;
		}
}

void init(){
	for(auto x:p)id[x]=++nid;
	cin>>n;
	piv[0]=1,piv[1]=inv(2);
	for(int i=2;i<=n;i++)
		piv[i]=piv[i-1]*piv[1]%mod;
	for(int i=1;i<=n;i++){
		cin>>s[i],cnt[s[i]]++;
		mx=max(mx,s[i]);
	}
	sie();
}

main(){
	freopen("card.in","r",stdin);
	freopen("card.out","w",stdout);
	ios::sync_with_stdio(0);
	init();
	calc();
} 
```


---

## 作者：Alex_Wei (赞：19)

> *VII. [P8292 [省选联考 2022] 卡牌](https://www.luogu.com.cn/problem/P8292)

套路见少了，省选考场上被打爆咧。

首先我们尝试抽象题意：给出 $n$ 个集合 $S_i$（表示每个数的质因子集合），$m$ 次询问每次给出 $T$，求从 $n$ 个集合中选出若干个集合的方案数，使得这些集合的并覆盖 $T$。

虽然不知道计数能否归约到最优化上，但对于上述问题的变种 “求最少选出多少个集合覆盖 $T$” 是广为人知的 **NP-hard**：最小集合覆盖问题。就连决定性问题 “求是否能选出不超过 $k$ 个集合覆盖 $T$” 也是 NPC 问题。

自然，思考本题的 $\rm polylog$ 做法简直是在做无用功。考虑指数级做法，再观察到 $s_i\leq 2000$ 的数据范围，并联想到 NOI2015 寿司晚宴，不难想到根号分治。

根号分治的核心要素在于，不存在一个数，使得它含有两个以上大于 $\sqrt {2000}$ 的不同的质因子。更具体地，由于 $43 \times 47 > 2000$，所以这个界的精确值是 $43$。这也意味着，对于 $x, y\in T$ 且 $x\neq y$，若 $x, y$ 均不小于 $43$，那么覆盖 $x, y$ 的决策是 **相对独立的**。即不存在一个集合能同时覆盖 $x$ 和 $y$。这使得我们可以对不小于 $43$ 的质数 **单独考虑**。

对于小于 $43$ 的那些质数呢？总共有 $13$ 个这样的质数，设为 $P$。不难想到将它们是否被覆盖的状态压缩成一个二进制数，也就是状态压缩。有了这个初步思路，我们尝试解决原问题。

首先，将只含有 $P$ 当中的质数作为质因子的数先拎出来，记做 $X$。我们可以预处理 $X$ 当中所有数的贡献，即求出 $f_i$ 表示在 $X$ 中有多少种选数的方式使得 $P$ 被覆盖的状态为 $i$。这个正确性基于 $X$ 所有数不含 $P$ 以外的质因子，我们自然不需要记录 $P$ 以外的质因数被覆盖的情况。

求 $f_i$ 是非常容易的。可以直接 DP 算，但有一个更好的方法。对 $x\in X$，设 $S_x$ 表示它覆盖了哪些 $P$ 中的质数。注意到 DP 之间的转移形如 $f_i\to f'_i$ 以及 $f_i \times (2 ^ {c_x} - 1) \to f'_{i | S_x}$，其中 $c_x$ 是 $x$ 在 $n$ 个数中出现次数。这相当于 $f_i$ 和一个在第 $0$ 位有值 $1$，在第 $S_x$ 位有值 $2 ^ {c_x} - 1$ 的集合幂级数 $F_x$ 做或卷积。注意到 $F_x$ 在进行 FWT（下文均指 FWT-OR）之后，每一位上的值均为 $2$ 的幂（对于不包含 $S_x$ 的位是 $1$，对于包含的则是 $2 ^ {c_x}$），所以我们可以存 $2$ 的幂次而非其真实值，这样 $f$ 就是点值，即真实值高维前缀和之后的结果。

对于剩下来的 $290$ 个质数而言，到每次询问再考虑的话，时间复杂度 $\mathcal{O}(m \times \pi(s_i) \times 2 ^ {|P|})$，时间复杂度显然无法接受。注意到对于没有出现在 $T$ 和 $P$ 中的质数 $p$ 而言，一个 $p$ 的倍数除掉 $p$ 之后不会产生任何影响，同时题目保证了 $\sum c_i$ 的数量级，即 $\sum c_i \times 2 ^ {|P|}$ 是可以接受的，所以我们不妨先设 $T\subseteq P$，每次询问时再依次考虑那些 $\in T$ 但 $\notin P$ 的质数。这样一来，对于 $y\notin X$，我们也求出其覆盖了哪些 $P$ 中的质数 $S_y$，并且类似 $S_x$ 那样对 $f$ 进行转移。

注意，这里实际上我们扩展了 $f$ 的定义，即将原来定义为只考虑 $X$ 以内的数变成了考虑所有数，但核心没有变，均为 $P$ 被覆盖的情况对应的方案数。

考虑一个 $\in T$ 但 $\notin P$ 的质数 $p$ 带来的影响。由于 $p$ 必须要被覆盖，所以我们只需减去 $p$ 没有被覆盖的情况。如何处理这一步呢？设 $G_p = \prod\limits_{p\mid k} F_k$，其中 $F$ 的定义见上文，且乘积的形式为或卷积。质数 $p$ 对 $f$ 的贡献是 $G_p$，这是因为每个 $p$ 的倍数 $k$ 对 $f$ 的贡献是 $F_k$，而这些贡献以或卷积的形式累计。注意到我们只需减去 **所有 $p$ 的倍数均不选** 的情况。对于该种情况，由于一个数都没有选，所以自然也不会覆盖任何一个 $P$ 当中的质数，这意味着覆盖情况为 $0$，说明我们只需将 $f$ 除掉 $G_p$，再乘以 $G_p - x ^ 0$ 即可。由于 $G_p$ 的每个位置的系数均存储的是 $2$ 的幂次，所以不需要担心不存在逆元。

更具体地，我们枚举所有 $p\in T$ 且 $p\notin P$，除掉所有 $G_p$，再乘上所有 $G_p - x ^ 0$。那么答案即所有覆盖了 $T' = T\cap P$ 的位置的和，即 $\sum\limits_{T'\subseteq i} f_i$。由于每次询问最后要将点值逆回来，所以时间复杂度为 $\mathcal{O}((s_i +\sum c_i + m|P|) 2 ^ {|P|})$。

总结一下，我们首先求出 $f = \prod F_x$ 表示只考虑 $P$ 以内的质数时，这些质数被覆盖情况对应的方案数，再对每次询问，对每个 $p\in T$ 且 $p\notin P$，除掉 $\prod F_k$ 其中 $k$ 是 $p$ 的倍数，再乘上 $(\prod F_k) - x ^ 0$，这一步是为了去掉没有覆盖 $p$ 的情况。所有乘积均为或卷积，在点值意义下运算，最后再逆回来即可。对于这些 $p$ 能单独搞的原因是它们之间相互独立。$43 \times 47 > 2 \times 10 ^ 3$。

注意对给出的 $T$ 去重。如果不懂题解可以看代码，注释很详细。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e3 + 2;
const int V = 1 << 13;
const int mod = 998244353;
const int P[13] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41};
void add(int &x, int y) {x += y, x >= mod && (x -= mod);}
void sub(int &x, int y) {x -= y, x < 0 && (x += mod);}
int n, m, pw[N * N], buc[N], f[V], g[N][V];
void init() {
    for(int i = pw[0] = 1; i <= n; i++) pw[i] = (pw[i - 1] << 1) % mod;
    for(int i = 1; i < N; i++) {
        int tmp = i, msk = 0;
        if(!buc[i]) continue; // 1 = 2 ^ 0，所以加 0 就直接忽略了
        for(int j = 0; j < 13; j++) while(tmp % P[j] == 0) tmp /= P[j], msk |= 1 << j; // 求出每个 i 覆盖 P 中质数的情况
        for(int j = 0; j < V; j++) if((j & msk) == msk) f[j] += buc[i]; // 对于包含 msk 的位置，系数要乘以 2 ^ {c_i} 次方，因此 2 的幂次加上 buc[i]
        if(tmp == 43 * 43) tmp = 43; // 注意这里有个小特判，43 ^ 2 <= 2e3
        if(tmp > 1) for(int j = 0; j < V; j++) if((j & msk) == msk) g[tmp][j] += buc[i]; // 这里是求每个 G_p
    }
}
int main() {
    freopen("card.in", "r", stdin);
    freopen("card.out", "w", stdout);
    cin >> n;
    for(int i = 1, s; i <= n; i++) scanf("%d", &s), buc[s]++;
    cin >> m, init();
    while(m--) {
        int c, p[V << 1], h[V], msk = 0, ans = 0;
        cin >> c, memcpy(h, f, sizeof(h));
        for(int i = 1; i <= c; i++) cin >> p[i];
        sort(p + 1, p + c + 1), c = unique(p + 1, p + c + 1) - p - 1; // 对所有质数去重
        for(int i = 1; i <= c; i++) for(int j = 0; j < 13; j++) if(p[i] == P[j]) msk |= 1 << j; // 求出 T \cap P
        for(int i = 1; i <= c; i++) if(p[i] > 41) for(int j = 0; j < V; j++) h[j] -= g[p[i]][j]; // 对于 >= 43 且出现在 T 中的质数，先减去它们的贡献
        for(int j = 0; j < V; j++) h[j] = pw[h[j]]; // 注意乘以 G_p - x ^ 0 时系数不再是 2 的幂，所以提前将系数从幂次转化为真实值
        for(int i = 1; i <= c; i++) if(p[i] > 41) for(int j = 0; j < V; j++) h[j] = 1ll * h[j] * (pw[g[p[i]][j]] - 1) % mod; // 乘以 G_p - x ^ 0，注意 -x ^ 0 在点值意义下即每个位置上均为 -1，所以只需乘以每个位置原来的系数 -1 即可
        for(int k = 1; k < V; k <<= 1) for(int i = 0; i < V; i += k << 1) for(int j = 0; j < k; j++) sub(h[i | j | k], h[i | j]); // 将点值转化为真实值，高维差分 IFWT
        for(int j = 0; j < V; j++) if((msk & j) == msk) add(ans, h[j]); // 对能完全覆盖 T \cap P 的方案数求和
        cout << ans << endl;
    }
    return 0;
}
/*
2022/4/18
start coding : 10:52
finish debugging : 11:47
--- stupid mistakes ---
None. Good.
*/
```

---

## 作者：EnofTaiPeople (赞：11)

据说这道题根号分治是 [[NOI2015] 寿司晚宴](/problem/P2150) 的套路，但我能力不够，只打了 T3 的 $28$ 分暴力就走人了。

讲的是或卷积的做法，并不需要用到容斥。

首先是一个暴力状压，设 $f_{x,S}$ 表示考虑了前 $x$ 个数，能整除的质数集合为 $S$ 的方案数，转移很简单，但复杂度会达到 $2000\times2^{302}$。

本题根号分治的思想是任意 $x\le2000$ 最多会有一个 $43$ 以上的质因数，当然需要注意 $43^2\le2000$，而 $43$ 以下的素数只有 $13$ 个，这样就可以状压了。

我们需要预处理出 $f_{x,S}$，注意这里的 $f$ 与之前的不一样，表示拥有 $43$ 及以上的质数 $x$，没有则 $x=1$，以及小于 $43$ 的质数集合 $S$ 的方案数，这样直接 dp 可以做到 $O(2^{13}s)$，达不到上界。

考虑如果 $43$ 及以上的质数都不做要求，那样答案就是将所有 $f_x$ 做或卷积，但如果强制 $43$ 及以上的某一个质数 $x$ 必须要选，考虑这样对 $f_x$ 的影响，只是使得 $f_{x,0}$ 减少了 $1$，表现在 $\text{FWT}$ 中每一个下标都减少了 $1$，处理时乘上逆元即可，时间复杂度是预处理的 $O(13\times302\times2^{13}+2^{13}s)$ 加上查询时的 $O(\sum c_i2^{13}+13m2^{13})$，代码里有注释：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e6+6,M=998244353;
int rv[2005],rt,zx[333];
bitset<2005>vs;
namespace fast_io{
    char buf[N+5],*p1,*p2,c,f;
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2))?EOF:*p1++
    template<typename _Tp>
        void read(_Tp &x){
            for(c=gc,f=0;c<48;c=gc)if(c=='-')f=!f;
            for(x=0;c>47;x=x*10+(48^c),c=gc);if(f)x=-x;
        }
    template<typename _Tp,typename..._tps>
        void read(_Tp &x,_tps&...y){
            read(x),read(y...);
        }
    char ob[N+35];
    int ot,st[35],_tp;
    void fls(){fwrite(ob,1,ot,stdout),ot=0;}
    template<typename _Tp>
        void write(_Tp x,char c){
            if(x<0)ob[ot++]='-',x=-x;
            for(_tp=0;x>9;st[++_tp]=48^(x%10),x/=10);
            for(ob[ot++]=48^x;_tp;ob[ot++]=st[_tp--]);
            ob[ot++]=c;
            if(ot>N)fwrite(ob,1,ot,stdout),ot=0;
        }
}using fast_io::read;
using fast_io::write;
int qp(int a,int x=M-2){快速幂求逆元
    int res=1;for(;x;x>>=1,a=ll(a)*a%M)
        if(x&1)res=ll(res)*a%M;return res;
}
void fwt(int *f){快速沃尔什变换求或卷积
    for(int p=0;p<13;++p)
        for(int k=0;k<8192;++k)
            (((k>>p)&1)&&(f[k]+=f[k^(1<<p)])>=M)?f[k]-=M:0;
}
void Ifwt(int *f){
    for(int p=0;p<13;++p)
        for(int k=0;k<8192;++k)
            (((k>>p)&1)&&(f[k]-=f[k^(1<<p)])<0)?f[k]+=M:0;
}
int n,ct[2005],q,m,a[18009],pw[N];
int f[333][8192],bs,g[N],ans,h[N];
int main(){
    read(n);int i,x,y,p,fl;
    for(x=pw[0]=1;x<=n;++x)
        pw[x]=(pw[x-1]<<1)%M;
    for(x=2;x<=2000;++x)
        if(!vs[x]){
            rv[zx[rt]=x]=rt,++rt;
            for(y=2000/x;y;--y)vs[x*y]=1;埃氏筛素数
        }
    for(i=1;i<=n;++i){
        read(x);
        if(x==43*43)x=43需要考虑43^2 的情况;
        ++ct[x];
    }
    for(p=1;p<=rt-12;++p)f[p][0]=1初始是全部不选有一种方案;
    for(y=1;y<=2000;++y)
        if(ct[y]){
            for(x=y,bs=0,i=0;i<13;++i)
                while(!(x%zx[i]))x/=zx[i],bs|=1<<i;
            x=(x==1)?1:(rv[x]-11其实不影响，让下标贴得近一些);
            for(p=8191;~p;--p)
                f[x][p|bs]=(ll(pw[ct[y]]-1)*f[x][p]+f[x][p|bs])%M;
        暴力加入到dp数组，注意有至少选一个的2^ct-1 种方案以及不选（不变）的 1 种方案
        }
    for(p=1;p<=rt-12;++p)fwt(f[p]);预处理
    memcpy(h,f[1],sizeof(h));
    for(i=2;i<=rt-12;++i)
        for(p=0;p<8192;++p)
            h[p]=ll(h[p])*f[i][p]%M,f[i][p]=ll(f[i][p]+M-1)*qp(f[i][p])%M;求出不作要求的数组，然后计算撤销时需要乘的数 (x-1)*x^-1
    read(q);
    while(q--){
        read(m),bs=0;
        for(i=1;i<=m;++i)read(a[i]);
        sort(a+1,a+m+1),m=unique(a+1,a+m+1)-a-1;
        reverse(a+1,a+m+1);
        while(m&&a[m]<=41)bs|=1<<rv[a[m--]];考虑小质数
        memcpy(g,h,sizeof(g));复制
        for(i=1;i<=m;++i){
            x=rv[a[i]]-11;
            for(p=0;p<8192;++p)
                g[p]=ll(g[p])*f[x][p]%M;撤销贡献
        }Ifwt(g),ans=0;逆变换，清空答案
        for(p=0;p<8192;++p)
            if((p&bs)==bs&&g[p])ans=(ans+g[p])%M;好像是按题意模拟？
        printf("%d\n",ans);
    }return 0;
}
```

---

## 作者：william555 (赞：10)

~~看到质数，整除， $ s_i\le 2000 $，DNA内似乎有什么东西在跳动，寿司晚宴！就是你！~~

首先想一想 $s_i\le 30 $ 怎么做？  
题目要求被每一个质数整除的方案数，这不好直接算，考虑容斥。可以枚举一这 $c_i$ 个质数的一个子集 $S$，令 $F(S)$ 为在 $n$ 个数中选出一个子集，其乘积不被 $S$ 内的任何一个质数整除的方案数。容易得到：
$$ ans=\sum_{S} (-1)^{|S|}F(s)$$
在 $s_i\le 30$ 时一共只有10个质数，可以预处理 $f(S)$ ，对于询问可以直接枚举子集容斥求解。

但是 $s_i\le 2000$，打表发现一共有303个质数，这显然不能够枚举子集。  
不过可以发现，每一个数至多只有一个大于 $\sqrt{2000}$ 的质数，令 $pb_i$ 为 $i$ 大于根号的质因数（若无大于根号的则为1），则我们可以将所有数按照 $pb$ 进行分类。对于询问中大于根号的质数 $p$，想要选出的数的乘积整除 $p$ ，其充要条件就是至少要选一个 $pb=p$ 的数。

将问题转化一下，现在一次询问就变为了，有若干堆数，有一些堆至少要选一个数，选出来的数的乘积要能够被一些小于根号的质数整除。对于小于根号的质数，发现只有14个，可以枚举子集进行容斥。接下来考虑如何计算 $F(S)$，对于一堆数，可以预处理出其中有多少数不被 $S$ 中的质数整除，记为 $cnt$ ，如果必须这堆要选，方案数为 $2^{cnt}-1$，否则为 $2^{cnt}$。这一步就可以直接枚举大于根号的质数计算。

总复杂度：预处理 $O(2^{14} *2000)$+查询 $O(2^{14}*\sum c_i)$。  
看似复杂度有些高，考场实测极限数据1.2s，不过发现虽然 $43*43 <2000$,不过 $43 * 47>2000$，所以可以将43归为大质数。这样小质数就只剩13个了。复杂度变为了 $O(2^{13} *2000)+O(2^{13}*\sum c_i)$ ,实测0.6s。（不过好像最后CCF没有卡常）。

还有个问题就是题面没有说明询问的 $c_i$ 个质数是否会有重复，我没有去重，遇到重复就寄了，民间数据WA飞了，不过万幸，官方数据没有重复。

```c++
#include<bits/stdc++.h>
using namespace std;
const int BS=1<<20;
char buf[BS],*P1,*P2;
inline char gc(){
	if(P1==P2)P2=(P1=buf)+fread(buf,1,BS,stdin);
	return P1==P2?EOF:*(P1++);	
}
inline int in(){
	int x=0,f=1;
	char c=gc();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc();}
	while(c>='0'&&c<='9')x=x*10+c-'0',c=gc();
	return x*f;	
}
const int N=2005,mod=998244353;
inline int add(int a,int b){return a+b>=mod?a+b-mod:a+b;}
inline int mul(int a,int b){return 1ll*a*b%mod;}
inline int qpow(int a,int b){
	int c=1;
	for(;b;b>>=1,a=mul(a,a))if(b&1)c=mul(c,a);
	return c;	
}
int n,m;
int pw[1000005];
int cnt[N];
int popcnt[1<<14];
int f[1<<14][305],g[1<<14];
int p[20005];
bool mark[N];
int pri[N],inp[N],pc;
int id[N];
int ps[N],pb[N];
int main(){
	freopen("card.in","r",stdin);
	freopen("card.out","w",stdout);
	mu[1]=1;
	for(int i=2;i<=2000;i++){
		if(!inp[i])pri[++pc]=i;
		for(int j=1;j<=pc&&i*pri[j]<=2000;j++){
			inp[i*pri[j]]=1;
			if(i%pri[j]==0)break;
		}
	}
	n=in();
	pw[0]=1;
	for(int i=1;i<=n;i++)pw[i]=add(pw[i-1],pw[i-1]);
	for(int i=1;i<=n;i++)cnt[in()]++;
	for(int i=1;i<=pc;i++)id[pri[i]]=i;
	for(int i=1;i<=2000;i++){
		int x=i;
		for(int j=1;j<=13;j++){
			if(x%pri[j]==0)ps[i]|=1<<j-1;
			while(x%pri[j]==0)x/=pri[j];
		}
		pb[i]=x;
	}
	pb[43*43]=43;
	for(int s=0;s<1<<13;s++){
		popcnt[s]=popcnt[s>>1]+(s&1);
		for(int i=1;i<=2000;i++){
			if((ps[i]&s)==0)f[s][id[pb[i]]]+=cnt[i],g[s]+=cnt[i];	
		}
	}
	m=in();
	mark[1]=1;
	vector<int> v;
	while(m--){
		int c=in();
		int now=0;
		v.clear();
		for(int i=1;i<=c;i++){
			p[i]=in();
			if(p[i]<=41)now|=1<<id[p[i]]-1;
			else v.push_back(id[p[i]]);
		}
		int ans=0;
		for(int s=now,pre=1;pre;pre=s,s=(s-1)&now){
			int val=1,cnt=g[s];
			for(int x:v){
				int y=f[s][x];
				cnt-=y;
				val=mul(val,pw[y]-1);
			}
			val=mul(val,pw[cnt]);
			if(popcnt[s]&1)val=mod-val;
			ans=add(ans,val);
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：_lbw_ (赞：8)

注意到 P2150 的根号分治，于是考虑将在每个 $\leq 41$ 的质数上定义集合幂级数。射 $i$ 的集合幂级数为 $g_i(S)$

接下来思考大质数如何处理，对于每个大质数 $p$ 设 $f_p(S)=\prod\limits_{i=1,p|s_i}^{n}g_i(S)$ ，若无大质数限制答案即为 $\prod f_p(S)$ .

若射 $b_p$ 表示大质数 $p$ 是否有限制，可以得到答案即为 $\prod f_p(S)-b_p$ 。

发现暴力计算时间复杂度为 $\mathcal{O}(\sum c+n\times 13\times 2^{13}+q\pi(\max(s))\times 13\times 2^{13})$ . 考虑如何优化。

发现我们应该射寄一个 $\mathcal{O}(poly(2^{13})\times \sum c)$ 的算法，因为 $\sum c$ 较小。于是射 $M(S)= \prod f_p(S)$ ，答案又可以表示为 $M(S)\prod[b_p=1]\dfrac{f_p(S)-1}{f_p(S)}$ 

所以预处理出 $\textsf{FMT}(f_p(S)-1),\textsf{FMT}(f_p(S))$ 和 $\textsf{FMT}(f_p(S))$ 每一项的逆元即可在 $\mathcal{O}(2^{13}\sum c+q2^{13})$ 的时间复杂度内计算出答案。（注意应在最后做 $\textsf{IFMT}$）。

总时间复杂度 $\mathcal{O}($可过$)$ .

讲的不太行，看看代码吧：

```cpp
const int maxS = 1<<13;
const int maxn = 2e3+5;
const int p[]={2,3,5,7,11,13,17,19,23,29,31,37,41};
ll n,m,id[maxn],cnt,f[maxn][maxS],inv[maxn][maxS],sum[maxS],tmp[maxS];bool vis[maxn];
ll qpow(ll n,ll base=cht-2){
	ll ans=1;
	while(base){
		if(base&1)ans=ans*n%cht;
		n=n*n%cht;
		base>>=1;
	}
	return ans;
}
IV remod(ll&x){x+=x>>31&cht;}
IV cadd(ll&x,ll val){remod(x+=val-cht);}
int main(){
	n=read();
	F(i,1,n){
		ll x=read(),s=0;
		F(j,0,12)if(x%p[j]==0){
			s|=1<<j;
			while(x%p[j]==0)x/=p[j];
		}
		if(x!=43&&x%43==0)x/=43;
		if(!id[x])id[x]=++cnt;f[id[x]][s]++;
	}
	ll S=(1<<13)-1;
	F(s,0,S)sum[s]=1;
	F(i,1,cnt){
		F(j,0,12)F(s,0,S)if(s>>j&1)cadd(f[i][s],f[i][s^(1<<j)]);
		F(s,0,S)f[i][s]=qpow(2,f[i][s]),inv[i][s]=qpow(f[i][s]),sum[s]=sum[s]*f[i][s]%cht;
    }
    m=read();
    while(m--){
    	F(s,0,S)tmp[s]=sum[s];
    	F(i,1,2000)vis[i]=0;ll c=read(),res=0;
    	bool flag=1;while(c--){
    		ll x=read();if(vis[x])continue;vis[x]=1;
    		if(x<=41){F(i,0,12)if(p[i]==x){res|=1<<i;break;}}
            else{
                if(!id[x]){flag=0;continue;}
                F(s,0,S)tmp[s]=tmp[s]*inv[id[x]][s]%cht*((f[id[x]][s]-1+cht)%cht)%cht;
            }
        }
        if(!flag){puts("0");continue;}
        F(i,0,12)F(s,0,S)if(s>>i&1)remod(tmp[s]-=tmp[s^(1<<i)]);
        F(i,0,12)D(s,S,0)if(~s>>i&1)cadd(tmp[s],tmp[s|(1<<i)]);printf("%lld\n",tmp[res]);
    }
    return 0;
}
```


---

## 作者：FZzzz (赞：6)

省选都过去半个月了啊。本来觉得这题没啥好说的，教练要求写题解的时候翻了一下洛谷题解区，发现竟然全都是把 $43$ 看成大质数的做法，没有我这种处理方法。所以来写一下。

首先还是把 $43$ 及以下的 $14$ 个质数称为“小质数”，其他质数称为大质数。每次询问时，我们欲对每个小质数的集合 $S$，求出“选出的数覆盖了所有给出的大质数和 $S$ 以内的某些小质数（不一定覆盖整个 $S$）”的方案数 $f_S$。

这是一个高维前缀和的形式，我们知道可以以 $2^{14}$ 的时间求高维差分后的一项，即“覆盖了所有给出的大质数和 $S$ 以内的所有小质数”的方案数。那么我们只需要考虑如何求出 $f$。

考虑被某个大质数整除的所有数（或不被任何大质数整除的所有数）对 $f$ 的贡献。对于 $S$，令这些数中“不被不属于 $S$ 的小质数整除”的个数为 $cnt_S$。那么若这个大质数是被给出的，则 $f_S$ 会乘上 $2^{cnt_S}-1$，否则会乘上 $2^{cnt_S}$。

大质数有 $289$ 个（应该差不多），现在我们可以做到单次询问约 $289\times2^{14}$ 时间。显然过不去。

设给出的小质数和大质数分别有 $c_1$ 和 $c_2$ 个。我们先假设所有大质数都没有给出，计算出初始的 $f$，然后每个给出的大质数做出 $\frac{2^{cnt_S}-1}{2^{cnt_S}}$ 贡献。这样我们单次询问约 $c_2\times2^{14}$ 时间。如果你把 $43$ 看成大质数，把这个 $14$ 变成 $13$ 就可以通过。

我的想法是能否把这个 $14$ 变成 $c_1$。实际上我们只需要做一个 $[0,2^{c_1})$ 到 $[0,2^{14})$ 的映射，若给出的第 $i$ 个小质数是本来的第 $j$ 个小质数则把第 $i$ 位对应到第 $j$ 位上，没有给出的小质数对应的位都是 $1$。

重点在于如何以 $O(2^{c_1})$ 而不是 $O(c_12^{c_1})$ 时间完成这个映射。我的处理方法是运用一个经典结论：$0$ 到 $2^n-1$ 中每两个相邻数只有均摊 $O(1)$ 的不同位。所以我们递推即可。

**upd**：考场上脑子抽了不知道为什么要这么搞，实际上只需要从去掉 lowbit 的状态转移就行。

这样我们预处理是 $289\times14\times2^{14}$ 时间，每个询问 $O(c_22^{c_1})$ 时间。极限数据咋造我也不知道，但是能比较稳地通过。

考场代码比较丑陋，将就看吧。
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
inline ll read(){
	ll x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-') f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=1e6+5,m=2e3+5,maxs=(1<<14)+5;
int n,cnt[m],q;
const int p[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43};
bool isp[m];
const ll mod=998244353;
ll pw[maxn];
void FWT(int* f,int n){
	for(int i=1;i<n;i*=2)
		for(int j=0;j<n;j+=i*2)
			for(int k=j;k<j+i;k++) f[k+i]+=f[k];
}
int cnt2[m][maxs],cnt3[maxs];
ll f[maxs];
bool vis[m];
int sz[maxs],lb[maxs],s2[maxs];
int main(){
	n=read();
	for(int i=1;i<=n;i++) cnt[read()]++;
	pw[0]=1;
	for(int i=1;i<=n;i++) pw[i]=pw[i-1]*2%mod;
	for(int i=1;i<m;i++){
		int x=i,s=0;
		for(int j=0;j<14;j++) while(x%p[j]==0){
			s|=1<<j;
			x/=p[j];
		}
		isp[x]=1;
		if(x>1) cnt2[x][s]+=cnt[i];
		cnt2[1][s]+=cnt[i];
	}
	for(int i=1;i<m;i++) if(isp[i]) FWT(cnt2[i],1<<14);
	for(int i=1;i<(1<<14);i++){
		sz[i]=sz[i>>1]+(i&1);
		lb[i]=i&1?0:lb[i>>1]+1;
	}
	q=read();
	while(q--){
		int c=read();
		memset(vis,0,sizeof(vis));
		while(c--) vis[read()]=1;
		vector<int> p2;
		for(int i=0;i<14;i++) if(vis[p[i]]) p2.push_back(i);
		s2[0]=(1<<14)-1;
		for(int i:p2) s2[0]^=1<<i;
		for(int i=1;i<(1<<p2.size());i++){
			s2[i]=s2[i-1];
			for(int j=0;j<=lb[i];j++) s2[i]^=1<<p2[j];
		}
		for(int i=0;i<(1<<p2.size());i++){
			f[i]=1;
			cnt3[i]=cnt2[1][s2[i]];
		}
		for(int i=2;i<m;i++) if(isp[i]&&vis[i])
			for(int j=0;j<(1<<p2.size());j++){
				f[j]=(pw[cnt2[i][s2[j]]]-1+mod)%mod*f[j]%mod;
				cnt3[j]-=cnt2[i][s2[j]];
			}
		ll ans=0;
		for(int i=0;i<(1<<p2.size());i++)
			ans=(ans+f[i]*pw[cnt3[i]]%mod*((p2.size()-sz[i])%2==0?1:mod-1)%mod)%mod;
		printf("%lld\n",ans);
	}
#ifdef LOCAL
	fprintf(stderr,"%f\n",1.0*clock()/CLOCKS_PER_SEC);
#endif
	return 0;
}
```

---

## 作者：WeLikeStudying (赞：6)

- 对自身的问题有了新的体会。
- 人生中有很多选择，要审慎地对待，果断地决定。

**题意**
- [题目链接](https://www.luogu.com.cn/problem/P8292)。
- 有 $n$ 个数，问从它们内部选取任何一个子集，求它们的乘积被所有选定的质数整除的方案数。

**分析**
- $O(2^n)$ 的暴力简单易想，~~十分的优秀~~。
- 在您想其它算法的时候您发现一个问题，它实际上是在求一个经典 $\text{NPC}$ 问题的方案数：子集覆盖的方案数，您顿时心生警戒并思考为啥题目开的数据范围如此之大。
- 您忽然想到了一道类似这样的题目名叫[寿司晚宴](https://www.luogu.com.cn/problem/P2150)，它利用了一个十分平凡的数论性质来关照似乎很大的数据范围：小于 $\sqrt w$ 的质因子超级少，但大于 $\sqrt w$ 的质因子在每个数中至多出现一次。
- 您统计了一下，发现在这个数据范围下小于 $\sqrt{2000}$ 的质因子只有 $14$ 个，为您心目中的暴力提供了坚实的理论基础。
- 您马上就思考怎么计算才能用到这个性质呢？对于每个大的因子，如果在它上面进行某个计算，由于不存在包含两个因子的数，它有个很好的特性就是它不会互相影响，我们或许可以用它进行状态压缩动态规划。
- 您发现这个就不错：$f(A,B)$ 表示使用 $A$ 中的数，然后使得它们的乘积能恰好被前十四个质数中的集合 $B$ 整除的方案数，虽然您目前并不知道怎么计算。
- 不过您并不打算抛弃它，因为它具有相当优秀的性质：对于一个质数集合 $p_1,p_2,\cdots ,p_n$，你把前 $14$ 个质数算出来，然后把 $p_1$ 倍数的情况，$p_2$ 倍数的情况……和除去这些质数的倍数的情况答案一一合并，您就相当于默认选了这些质数，然后全局的情况就是答案。
- 然后您发现了美好的性质，即我们加入的数的总个数不超过 $w\log\log w$，似乎相当有用。
- 实际上，预处理似乎可以直接暴力 $O(2^{\pi(\sqrt w)}w\log\log w)$ 跑就可以了，接下来考虑合并的情况：对于 $A\cap B=\varnothing$：
$$f(A\cup B,S)=\sum_{P\cup Q=S}f(A,P)f(B,Q)$$
- 这个是经典问题，可以用[快速沃尔什变换](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/kuai-su-wo-er-shi-bian-huan)解决。
- 但是您发现仍然无法避免在每次询问的时候要一个个加入求出它的 $f$ 函数的问题，这或许是悲剧性的。
- 但是咱们可以把式子逆过来变成求逆元，也就是说对于 $A\subseteq B$，我们解方程：
$$f(B,S)=\sum_{P\cup Q=S}f(A-B,P)f(B,Q)$$
- 这看似令人吐血，不过您理解了 $\text{FWT}$ 的实质，所以它就是个除法求逆元的问题。
- 所以我们就可以一开始求解 $O(\pi(w))$ 个质数的倍数和全局的情况，总复杂度为 $O(w\ln\ln w 2^{\pi(\sqrt w)})$。
- 对于单次询问，我们使用所有质数不特殊处理（包含空集）的情况，用 $\text{FWT}$ 合并，求逆，乘上全局的情况，得到不包含这些质数的情况，然后让所有质数的情况不包含空集进行处理，乘上不包含所有质数的情况，总复杂度为 $O(\sum c_i\pi(\sqrt w)2^{\pi(\sqrt w)})$，但是预处理多一点就可以每次询问几乎全都在暴力做乘除法，只需要一次 $\text{FWT}$。
- 综上，总复杂度应该是（什么玩意）（设 $\pi(n)$ 为小于 $n$ 的质数个数）：
$$O(n+2^{\pi(\sqrt w)}(w\log\log w+(\pi(w)+m)\pi(\sqrt w)+\sum c_i))$$
- 卡常：只需要 $13$ 个质数，因为 $41\times47>2000$。
- 对于求逆元，它可以加在预处理复杂度上，但是我们可以有更加好的方法，设 $g(A,B)$ 为 $\text{FWT}$ 变换的结果，容易利用它的意义：然后使得它们的乘积能恰好被前十四个质数中的集合 $B$ 的某个子集整除的方案数，然后发现它的所有元素都是 $2$ 的幂，预处理二的幂，我们可以用加减法代替求逆元，[代码实现](https://www.luogu.com.cn/paste/ikv9izix)。

---

## 作者：Komodo (赞：6)

前置知识：fwt

对于一个数 $s_i$ ，构造集合 $S_i=\{p_j|s_i\equiv0\mod p_j\}$ 

那么考虑构造集合幂级数 $F_i=(z^{\emptyset}+z^{S_i})$ 表示一个数选或不选

对于两个数的集合幂级数，就是两个集合幂级数的或卷积（两个数乘积的集合就是两个质数集合的并）

多个数同理

那么，就可以考虑将每个 $s_i=x$ 的集合幂级数算出来，fwt 一下求出点值，然后变成每个 $x$ 的个数次方，全部乘在一起，就得到了答案的集合幂级数 $G$（含义就是选定的数的乘积的质因数集合为 $S$ 时，有 $[z^S]G$ 种选法）

但唯一的问题是，$s\le2000$

我们可以将质因数分类，小于等于 $41$ 的质数共有 $13$ 个，而 $43*47=2021>2000$，所以可以分类讨论。

对于所有的 $p>41$ ，我们维护 $G_p$ 和 $G_p-z^{\emptyset}$ 的 fwt 点值，分别表示最大质因子为 $p$ 的集合幂级数之积。特别的，$G_1$ 表示最大质因子小于 $41$ 。

这里的集合幂级数只维护 $p\le41$ 的质因子，这样就保证了时间复杂度。

询问时，我们可以得到小质数集合和大质数集合，分别为 $S$，$T$ 。

那么答案集合幂级数即为：

$$
H=G_1\prod_{p\in T} (G_p-z^{\emptyset})\prod_{p\notin T} G_p
$$

含义显然。

那么答案即为$\sum_{T\subseteq t}[z^{t}]H$。

时间复杂度为 $O(2^{13}*13*(m+\max(s)))$。

给一个未经卡常的代码（卡常提示：$z^{\emptyset}+z^s$ 的 fwt 点值是不需要带log的，其点值最大为 2 ，所以无需用快速幂 ）

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define mod 998244353
#define K 13
#define S 8192
int n;
int pr[2020],pid[2020],pcnt=0;
int cnt[2020];
ll f[2020][S],g[2020][S],gg[2020][S],h[S],ans[S];
int p[18010];
ll ksm(ll a,ll b){
    ll ans=1,tmp=a;
    while(b){
        if(b&1)ans*=tmp,ans%=mod;
        tmp*=tmp,tmp%=mod;
        b>>=1;
    }
    return ans;
}
void fwt_or(ll *a,int mode){
    for(int i=1;i<S;i<<=1){
        for(int j=0;j<S;j+=(i*2)){
            for(int k=0;k<i;k++){
                a[i+j+k]+=a[j+k]*(mod+mode)%mod;
                a[i+j+k]%=mod;
            }
        }
    }
}
int main(){
    for(int i=2;i<=2000;i++){
        bool ok=1;
        for(int j=2;j*j<=i;j++)if(i%j==0)ok=0;
        if(ok){
            pr[pcnt]=i;
            pid[i]=pcnt++;
        }
    }
    //for(int i=0;i<K;i++)printf("pr[%d]=%d\n",i,pr[i]);
    //printf("\n");
    scanf("%d",&n);
    for(int i=1;i<=n;i++){int s;scanf("%d",&s);cnt[s]++;}
    for(int i=1;i<=2000;i++)for(int j=0;j<S;j++)g[i][j]=1;
    for(int i=1;i<=2000;i++){
        int ii=i;
        int s=0;
        for(int j=0;j<K;j++){
            while(ii%pr[j]==0)s|=(1<<j),ii/=pr[j];
        }
        f[i][0]++;
        f[i][s]++;
        if(ii==1849)ii=43;
        fwt_or(f[i],1);
        for(int j=0;j<S;j++)g[ii][j]*=ksm(f[i][j],cnt[i]),g[ii][j]%=mod;
    }
    memcpy(h,g[1],sizeof(g[1]));
    for(int i=K;i<pcnt;i++){
        memcpy(gg[pr[i]],g[pr[i]],sizeof(g[pr[i]]));
        fwt_or(gg[pr[i]],-1);
        gg[pr[i]][0]--;
        fwt_or(gg[pr[i]],1);
        for(int j=0;j<S;j++)h[j]*=g[pr[i]][j],h[j]%=mod,g[pr[i]][j]=ksm(g[pr[i]][j],mod-2);//g is now inversed
    }
    int m;scanf("%d",&m);
    for(int i=1;i<=m;i++){
        memcpy(ans,h,sizeof(ans));
        int c;scanf("%d",&c);
        int s=0;
        for(int j=0;j<c;j++){
            scanf("%d",p+j);
            if(p[j]<=41)s|=(1<<pid[p[j]]);
            else{
                int id=p[j];
                for(int k=0;k<S;k++){
                    ans[k]*=gg[id][k]*g[id][k]%mod;
                    ans[k]%=mod;
                }
            }
        }
        fwt_or(ans,-1);
        ll ANS=0;
        for(int j=0;j<S;j++){
            if((j|s)==j)ANS+=ans[j],ANS%=mod;
        }
        printf("%lld\n",ANS);
    }
    return 0;
}

```

---

## 作者：一念之间、、 (赞：4)

# 题意
说： $n$ 个数， $m$ 次询问，每次给出 $c$ 个质数，问有多少个 $n$ 数的子集，使得每个质数整除子集内的数的乘积。

保证$\sum c \le 18000$

# 题解
考虑说容斥，一个暴力的想法是枚举 $2^c$ 作钦定，选出来的集合不包含这些个质数，显然正确性是有保证的。

可以发现值域较小，考虑根号分治。

定义：大因子为一个数只能包含一个的因子的质数，同时前13个作为小因子。

容易发现对于两个大因子钦定或者不钦定是不相关的。

对于不同的大因子进行一个分类，回答询问时枚举小因子集合是否钦定，扫描大因子是否钦定。

此时我们需要预处理的东西是说对于每个大因子处理出来不包含每个小因子集合 $2^{13}$ 共有多少个数，扫描一次即可。

复杂度 $O(2000\times 2^{13})$。

回答询问复杂度为 $O(2^{13}\times(m+\sum c))$

以下是考场代码。

# 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define dd double
using namespace std;
char gc(){static char buf[1<<16],*s,*t;if(s==t){t=(s=buf)+fread(buf,1,1<<16,stdin);if(s==t)return EOF;}return *s++;}
//#define getchar gc
ll read()
{
	char c;
	ll w=1;
	while((c=getchar())>'9'||c<'0')if(c=='-')w=-1;
	ll ans=c-'0';
	while((c=getchar())>='0'&&c<='9')ans=(ans<<1)+(ans<<3)+c-'0';
	return ans*w;
}
void pc(char c,int op)
{
	static char buf[1<<16],*s=buf,*t=buf+(1<<16);
	(op||((*s++=c)&&s==t))&&(fwrite(buf,1,s-buf,stdout),s=buf);
}
void wt(int x)
{
	if(x>9)wt(x/10);
	pc('0'+x%10,0);
}
void wts(int x,char op)
{
	if(x<0)pc('-',0),x=-x;
	wt(x),pc(op,0);
}
//查空间 
//开long long 
//如果使用linux，要ulimit。 
const int xx=2005,mod=998244353;
int vis[xx],prim[xx],mn[xx],mx[xx],cnt;
//2000:303 
//44:14 确实可压！ 
//43划为大因子！ 
void pre(int n)
{
	for(int i=2;i<=n;i++)
	{
		if(!vis[i])mn[i]=i,prim[++cnt]=i;
		for(int j=1;j<=cnt;j++)
		{
			if(i*prim[j]>n)break;
			vis[i*prim[j]]=1;
			mn[i*prim[j]]=prim[j];
			if(i%prim[j]==0)break;
		}
	}
}
int t[xx];
ll ksm(ll a,ll b)
{
	ll ans=1;
	while(b)
	{
		if(b&1)ans*=a,ans%=mod;
		a*=a,a%=mod,b>>=1;
	}
	return ans;
}
int to[xx];
vector<int>v[xx];
//ni表示任意的情况下选/不选。 
//8192+
int num[8205],N[405][8205];
int bit[2005],n;
int pw[(int)1e6+5],ni[(int)1e6+5];
int ct[8205],To[2005];
int get(int x)
{
	if(x&1)return mod-1;
	return 1;
}
int main(){
	//本能的直觉让我担忧，但是本质上没有问题的。 
	//我也没想到说常数这么优秀了？ 
	freopen("card.in","r",stdin);
	freopen("card.out","w",stdout);
	pw[0]=1;
	for(int i=1;i<=1e6;i++)pw[i]=1ll*pw[i-1]*2%mod;
	ni[0]=1;
	ni[1]=ksm(pw[1],mod-2);
	for(int i=2;i<=1e6;i++)ni[i]=1ll*ni[i-1]*ni[1]%mod;
	for(int i=1;i<8205;i++)ct[i]=ct[i/2]+(i&1);
	pre(2000);
	n=read();
	for(int i=1;i<=n;i++)t[read()]++;
	//注意判断1的情况 
	for(int i=1;i<=13;i++)to[prim[i]]=i;//前13个算小因子 
//	cout<<prim[13]<<"\n";
	for(int i=2;i<=2000;i++)
	{
		int x=i;
		while(x!=1)
		{
			if(to[mn[x]])bit[i]|=(1<<(to[mn[x]]-1));
			mx[i]=max(mx[i],mn[x]),x/=mn[x];
		}
		if(mx[i]<43)mx[i]=0;//视作没有东西。 
	}
	//最大质因子 
	//0表示没有大因子的情况 
	for(int i=1;i<=2000;i++)
		v[mx[i]].push_back(i);
	prim[0]=0;
	for(int i=0;i<=cnt;i++)To[prim[i]]=i;
	int Ct=0;
	for(int j=0;j<8192;j++)//表示ban掉集合了 
	{
		for(int i=0;i<=cnt;i++)
			//num挺大的！所有情况下统共的支配的数量 
			for(auto it:v[prim[i]])
//			{
//				Ct++;
			if((bit[it]&j)==0)num[j]+=t[it],N[i][j]+=t[it];
//			}
	}
//	cerr<<Ct<<"ASD\n";
	//这里可以优化一下常数了 
	int m=read();
	//我觉得可能是哪里爆了？ 
	for(int i=1;i<=m;i++)
	{
		int C=read(),now=0;
		vector<int>v;
		for(int j=1;j<=C;j++)
		{
			int p=read();
			if(to[p])now|=(1<<(to[p]-1));
			else v.push_back(p);
		}
		sort(v.begin(),v.end());
		v.resize(unique(v.begin(),v.end())-v.begin());
		ll ans=0;
		for(int j=now;j>=0;j=(j-1)&now)//枚举一个子集 
		{
//			cout<<i<<" "<<j<<"ASD\n";
			int ttnum=num[j];
			for(auto it:v)//这里面的东西ban了 
				ttnum-=N[To[it]][j];
			//剩下的选或不选 
			ll res=1ll*pw[ttnum]*get(ct[j])%mod;
			ll xs=1;
			for(auto it:v)
			{
				ll ty=xs*get(1)+xs*pw[N[To[it]][j]];
				xs=ty%mod;
			}
			ans+=xs*res,ans%=mod;
//			if(i!=1)cerr<<j<<' '<<ttnum<<"!!\n";
			if(j==0)break;
		}
		cout<<ans<<"\n";
	}
	pc('1',1);
	return 0;
}




/*04@Leslie01#Salute*/
```




---

## 作者：Leasier (赞：3)

前置芝士：[FWT](https://oi-wiki.org/math/poly/fwt/)

首先考虑暴力怎么做。不妨把 $n$ 降到与 $s_i$ 同阶，考虑对 $s_i$ 去重，记 $cnt_i$ 表示 $s_j = i$ 的 $j$ 的个数，则选择 $i$ 的实际方案数为 $2^{cnt_i} - 1$。

仿照 [P2150 [NOI2015] 寿司晚宴](https://www.luogu.com.cn/problem/P2150)，考虑状压 dp，设 $f_{i, S}$ 表示在 $1 \sim i$ 中选出若干个数恰好覆盖 $S$ 中的质因数的方案数。

初值：$f_{0, 0} = 1$。

转移分为以下两种：

- 不选 $i$：$f_{i, S} \leftarrow f_{i, S} + f_{i - 1, S}$。
- 选 $i$：$f_{i, S \operatorname{or} state_i} \leftarrow f_{i, S \operatorname{or} state_i} + f_{i - 1, S} (2^{cnt_i} - 1)$，其中 $state_i$ 表示 $i$ 的质因数集合。

设在询问 $i$ 中质因数的并集为 $T_i$，则答案为 $\displaystyle\sum_{T_i \subseteq S} f_{N, S}$，其中 $N = \max s_i$。

时间复杂度为 $O(2^{\pi(N)} (n + m) + \sum c_i \log c_i)$，只能通过测试点 $1 \sim 8$。

依然仿照 [P2150 [NOI2015] 寿司晚宴](https://www.luogu.com.cn/problem/P2150)，考虑对质因数集合根号分治。

现在我们称 $\leq \sqrt{N}$ 的质数为小质数（至多包括 $2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43$，共 $14$ 个），$> \sqrt{N}$ 的质数为大质数。事实上，当 $N = 2 \times 10^3$ 时，由于 $43 \times 47 = 2021 > N$，我们可以认为 $43$ 也是一个大质数，于是小质数一共 $13$ 个。

我们分开考虑质因数集合中不包含大质数的数和包含大质数的数。

对于质因数集合中不包含大质数的数，我们同上 dp 即可。

考虑在询问时特殊处理大质数。

对于一个询问 $i$ 和一个大质数 $q$：

- 若 $q \not\in p_i$，它是否存在实际上无影响，于是我们扔掉 $q$ 的倍数的质因数集合中的 $q$ 并同上 dp 即可。
- 若 $q \in p_i$，它是否存在有影响，于是我们设 $f_S$ 表示加入 $q$ 的倍数前的 dp 数组，$g_S$ 表示扔掉 $q$ 的倍数的质因数集合中的 $q$ 并同上 dp 得到的 dp 数组，令 $f_S = g_S - f_S$ 即可（因为我们强制 $q$ 存在，需要去掉不存在的情况）。

直接做的时间复杂度为 $O(n 2^{\pi(\sqrt{N})} + \sum c_i \log c_i + \frac{mN 2^{\pi(\sqrt{N})}}{\ln N})$，只能通过测试点 $1 \sim 13$。

注意到我们的 dp 转移实际上是一个或卷积的形式，即 $f_{i, S} = \displaystyle\sum_{T \operatorname{or} U = S} f_{i - 1, T} ([U = \emptyset] + [U = state_i] (2^{cnt_i} - 1))$。

考虑对于每个 $i$ 预处理出右边那坨东西 FWT-or 后的值，再对每个大质数 $q$ 处理出其所有倍数 $i$ 的那坨东西的或卷积 FWT-or 后的值（记为 $fwt_q$）。每次询问时，对所有 $q \not\in p_i$ 直接把当前 dp 数组 FWT-or 后的值 $f$ 乘上 $fwt_q$；对所有 $q \in p_i$，令 $g = f \cdot fwt_q$，$f \leftarrow g - f$。最后 IFWT 回去即可。

考虑预处理出 $f = \displaystyle\prod_{i = 1}^N fwt_i$，每次询问时，每遇到一个新的大质数 $c_i$ 就令 $f = FWT(IFWT(f) - IFWT(\frac{f}{fwt_i}))$（$fwt_i$ 显然每项均不为 $0$），最后 IFWT 回去即可。时间复杂度为 $O(N \pi(\sqrt{N}) 2^{\pi(\sqrt{N})} + \sum c_i (\log c_i + \pi(\sqrt{N}) 2^{\pi(\sqrt{N})})$，只能通过测试点 $1 \sim 17$。

注意到 FWT 本身是一个可逆的矩阵乘法，所以 $FWT(IFWT(f) - IFWT(\frac{f}{fwt_i})) = f - \frac{f}{fwt_i}$，于是我们不再需要对于每个大质数都 FWT / IFWT 而是只需要在最后 IFWT 一次即可。时间复杂度为 $O(\pi(\sqrt{N}) 2^{\pi(\sqrt{N})} (N + m) + \sum c_i 2^{\pi(\sqrt{N})})$。

可能需要一些常数优化。

代码：
```cpp
#include <stdio.h>

const int N = 2e3, M = 13, K = 1 << M, mod = 998244353;
int prime[N + 7], pi[N + 7], bucket[N + 7], state[N + 7], product[K + 7], pre[K + 7], suf[K + 7], big[N + 7][K + 7], belong[N + 7], cur[K + 7], vis[N + 7];
bool p[N + 7];

inline int init(){
	int cnt = 0;
	p[0] = p[1] = true;
	pi[1] = 0;
	for (register int i = 2; i <= N; i++){
		if (!p[i]) prime[++cnt] = i;
		pi[i] = cnt;
		for (register int j = 1; j <= cnt && i * prime[j] <= N; j++){
			p[i * prime[j]] = true;
			if (i % prime[j] == 0) break;
		}
	}
	return cnt;
}

inline int read(){
	int ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return ans;
}

inline int quick_pow(int x, int p){
	int ans = 1;
	while (p){
		if (p & 1) ans = 1ll * ans * x % mod;
		x = 1ll * x * x % mod;
		p >>= 1;
	}
	return ans;
}

inline void add(int &x, int y){
	if ((x += y) >= mod) x -= mod;
}

inline void sub(int &x, int y){
	if ((x -= y) < 0) x += mod;
}

inline void FWT_or(int a[], int n, int type){
	for (register int i = 1; i < n; i <<= 1){
		int j = i << 1;
		for (register int k = 0; k < n; k += j){
			int r = k + i;
			for (register int l = k; l < r; l++){
				int x = l + i;
				if (type == 1){
					add(a[x], a[l]);
				} else {
					sub(a[x], a[l]);
				}
			}
		}
	}
}

int main(){
	int n = read(), cnt = init(), m;
	for (register int i = 1; i <= n; i++){
		int s = read();
		bucket[s]++;
	}
	for (register int i = 1; i <= M; i++){
		for (register int j = prime[i]; j <= N; j += prime[i]){
			state[j] |= 1 << (i - 1);
		}
	}
	product[0] = 1;
	FWT_or(product, K, 1);
	for (register int i = M + 1; i <= cnt; i++){
		for (register int j = 0; j < K; j++){
			big[i][j] = product[j];
		}
		for (register int j = prime[i]; j <= N; j += prime[i]){
			belong[j] = i;
		}
	}
	for (register int i = 1; i <= N; i++){
		for (register int j = 0; j < K; j++){
			cur[j] = 0;
		}
		cur[state[i]] = quick_pow(2, bucket[i]) - 1;
		add(cur[0], 1);
		FWT_or(cur, K, 1);
		for (register int j = 0; j < K; j++){
			product[j] = 1ll * product[j] * cur[j] % mod;
		}
		if (belong[i] != 0){
			int inv;
			for (register int j = 0; j < K; j++){
				pre[j] = cur[j];
				if (j > 0) pre[j] = 1ll * pre[j] * pre[j - 1] % mod;
			}
			inv = quick_pow(pre[K - 1], mod - 2);
			for (register int j = K - 1; j >= 0; j--){
				suf[j] = cur[j];
				if (j < K - 1) suf[j] = 1ll * suf[j] * suf[j + 1] % mod;
			}
			for (register int j = 0; j < K; j++){
				big[belong[i]][j] = 1ll * big[belong[i]][j] * inv % mod;
				if (j > 0) big[belong[i]][j] = 1ll * big[belong[i]][j] * pre[j - 1] % mod;
				if (j < K - 1) big[belong[i]][j] = 1ll * big[belong[i]][j] * suf[j + 1] % mod;
			}
		}
	}
	m = read();
	for (register int i = 1; i <= m; i++){
		int c = read(), val = 0, t, ans = 0;
		for (register int j = 1; j <= c; j++){
			int p = read();
			vis[pi[p]] = i;
		}
		for (register int j = 1; j <= M; j++){
			if (vis[j] == i) val |= 1 << (j - 1);
		}
		t = (K - 1) ^ val;
		for (register int j = 0; j < K; j++){
			cur[j] = product[j];
		}
		for (register int j = M + 1; j <= cnt; j++){
			if (vis[j] == i){
				for (register int k = 0; k < K; k++){
					sub(cur[k], 1ll * cur[k] * big[j][k] % mod);
				}
			}
		}
		FWT_or(cur, K, -1);
		for (register int j = t; ; j = t & (j - 1)){
			add(ans, cur[j | val]);
			if (j == 0) break;
		}
		printf("%d\n", ans);
	}
	return 0;
}
```

---

## 作者：绝顶我为峰 (赞：2)

类似寿司晚宴，考虑对值域根号分治，小于根号的质因子只有 $14$ 个，可以状压，大于根号的质因子只会存在至多一个，我们可以根据不同的大质因子给这些数字分类。

我们先提前预处理出来 $f_{i,s}$ 表示大质数 $i$ 对应的集合中包含的小质数集合为 $s$ 的子集的方案数，这一步是容易通过一次 FMT 求出来的。

每次询问，我们事实上是要选出一个集合，他们他质因子集合是给出质因子集合的超集，求符合条件的集合的数量。

分别考虑两类质数怎么处理。对于小质数，我们直接状压，最后求超集和。大质数复杂一些，考虑如果没有大质数的限制，那么我们直接对每个大质数 FMT 的结果点乘起来然后做一次 iFMT 就还原出了原数组，直接超集和即可。而我们每选中一个大质数，相当于我们钦定在当前质数集合不能选空集，也就是所有的位置的点值都要减一。

那么思路就显然了，我们先预处理出来 FMT 后所有集合点乘的结果，询问时每遇到一个大质数就去掉所在集合的贡献，然后减一后乘回来。

这样之后再做一次 iFMT 就能还原出原数组，然后做超集和就能求出答案了，复杂度 $O((\pi(s)+m)\times14\times2^{14}+\sum c_i\times2^{14})$，其中 $\pi(s)$ 表示 $s$ 以内质数个数。

然而这个复杂度大概率过不了。

怎么优化？考虑一下我们对于大质数的定义，其实是**在每个数中最多存在一种的数字**，按照根号值域分类这个标准其实是一个粗略的界，因为他满足的条件**至多存在一个大质数**其实是充分但不必要的。

考虑放宽这个限制，小于根号的质数中最大的数是 $43$，大于根号的质数中最小的数是 $47$，事实上 $43\times47>2000$，也就是说如果我们把 $43$ 归为大质数的行列，也符合我们的要求，唯一需要注意的一点是我们在分解质因数时需要特判 $1849=43\times43$。

这样复杂度降为 $O((\pi(s)+m)\times13\times2^{13}+\sum c_i\times 2^{13})$，可以通过此题。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int mod=998244353;
const int p[]={2,3,5,7,11,13,17,19,23,29,31,37,41};
int n,m,id[2001],cnt,f[2001][1<<13],inv[2001][1<<13],sum[1<<13],tmp[1<<13];
bool vis[2001];
inline int read()
{
    int x=0;
    char c=getchar();
    while(c<'0'||c>'9')
        c=getchar();
    while(c>='0'&&c<='9')
    {
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x;
}
inline int Mod(int x)
{
    return x>=mod? x-mod:x;
}
inline int pw(int a,int b)
{
    int res=1;
    while(b)
    {
        if(b&1)
            res=1ll*res*a%mod;
        b>>=1;
        a=1ll*a*a%mod;
    }
    return res;
}
int main()
{
    n=read();
    for(int i=1;i<=n;++i)
    {
        int x=read(),s=0;
        for(int j=0;j<13;++j)
            if(x%p[j]==0)
            {
                s|=1<<j;
                while(x%p[j]==0)
                    x/=p[j];
            }
        if(x!=43&&x%43==0)
            x/=43;
        if(!id[x])
            id[x]=++cnt;
        ++f[id[x]][s];
    }
    for(int s=0;s<1<<13;++s)
        sum[s]=1;
    for(int i=1;i<=cnt;++i)
    {
        for(int j=0;j<13;++j)
            for(int s=0;s<1<<13;++s)
                if(s>>j&1)
                    f[i][s]=Mod(f[i][s]+f[i][s^(1<<j)]);
        for(int s=0;s<1<<13;++s)
        {
            f[i][s]=pw(2,f[i][s]);
            inv[i][s]=pw(f[i][s],mod-2);
            sum[s]=1ll*sum[s]*f[i][s]%mod;
        }
    }
    m=read();
    while(m--)
    {
        for(int s=0;s<1<<13;++s)
            tmp[s]=sum[s];
        for(int i=1;i<=2000;++i)
            vis[i]=0;
        int c=read(),res=0;
        bool flag=1;
        while(c--)
        {
            int x=read();
            if(vis[x])
                continue;
            vis[x]=1;
            if(x<=41)
            {
                for(int i=0;i<13;++i)
                    if(p[i]==x)
                    {
                        res|=1<<i;
                        break;
                    }
            }
            else
            {
                if(!id[x])
                {
                    flag=0;
                    continue;
                }
                for(int s=0;s<1<<13;++s)
                    tmp[s]=1ll*tmp[s]*inv[id[x]][s]%mod*Mod(f[id[x]][s]-1+mod)%mod;
            }
        }
        if(!flag)
        {
            cout<<"0\n";
            continue;
        }
        for(int i=0;i<13;++i)
            for(int s=0;s<1<<13;++s)
                if(s>>i&1)
                    tmp[s]=Mod(tmp[s]-tmp[s^(1<<i)]+mod);
        for(int i=0;i<13;++i)
            for(int s=(1<<13)-1;~s;--s)
                if(~s>>i&1)
                    tmp[s]=Mod(tmp[s]+tmp[s|(1<<i)]);
        cout<<tmp[res]<<'\n';
    }
    return 0;
}
```

---

## 作者：Prean (赞：2)

~~场外选手口胡~~

如果对质因子这方面熟悉的可以看出来，相当于是我有一车集合，每次给定一个集合，问你有多少种方法选择若干集合使得或起来为给定集合。

首先传统艺能压状态数，将 $n=\prod p^k$ 全部变为 $n=\prod p$，很明显不影响。我们将相同的数丢到一个桶里面。然后将这个数的权值变为 $2^{cnt}-1$。

然后观察到值域只有 $2000$，开个根号是 $44$，$44$ 以内的质数数量非常少（$14$ 个），所以传统艺能状压。对于每个数我们也拿出其最大质因子，然后将这个数挂在上面。最大质因子不大于 $44$ 的数全部挂在一起。

剩下的部分就是或背包了。可以用 FWT 解决。

实现的时候可以考虑挂在一起的数全部先卷一遍，然后维护成点值，一起乘起来。

复杂度是 $O(V2^{14}\times 14+n+\sum c_i2^{14}+m2^{14}\times 14)$，可以通过。

可以优化到 $O(V2^{13}+n+\sum c_i2^{13}+m2^{13})$，偷懒写的 $O(V2^{13}+n+\sum c_i2^{13}+m2^{13}\times 13)$。
```cpp
#include<cstring>
#include<cstdio>
#include<cctype>
#define clr(F) memset(F,0,1<<15)
#define cpy(F,G) memcpy(F,G,1<<15)
typedef unsigned ui;
const ui M=1<<13,mod=998244353;
ui n,m,q,CB[2005],g[M],h[M],f[305][M];ui id[2005],pos[2005],mxp[2005];ui top,pri[305];
bool V[2005],vis[2005];char buf[1<<26|1],*_P=buf;
inline void swap(ui&a,ui&b){
	ui c=a;a=b;b=c;
}
inline ui pow(ui a,ui b=mod-2){
	ui ans(1);for(;b;b>>=1,a=1ull*a*a%mod)if(b&1)ans=1ull*ans*a%mod;return ans;
}
inline void px(ui*f,ui*g){
	for(ui k=0;k^M;++k)f[k]=1ull*f[k]*g[k]%mod;
}
inline void sieve(){
	for(ui i=2;i<=2000;++i){
		if(!id[i])id[i]=i,pri[pos[i]=++top]=i;
		for(ui x,j=1;j<=pos[i]&&(x=i*pri[j])<=2000;++j)id[x]=id[i]*((pos[x]=j)==pos[i]?1:pri[j]);
	}
	for(ui i=2;i<=2000;++i)if(id[i]==i)mxp[i]=pri[pos[i]]==i?pos[i]:mxp[i/pri[pos[i]]];
	for(ui i=1;i<=2000;++i)if(mxp[i])mxp[i]=mxp[i]>13?mxp[i]-12:1;
	m=top-12;
}
inline void GetInv(ui*f){
	static ui S[M];ui inv;S[0]=f[0];
	for(ui k=1;k^M;++k)S[k]=1ull*S[k-1]*f[k]%mod;inv=pow(S[M-1]);
	for(ui k=M-1;k;--k)S[k]=1ull*inv*S[k-1]%mod,inv=1ull*inv*f[k]%mod;S[0]=inv;
	for(ui k=0;k^M;++k)f[k]=S[k];
}
inline ui read(){
	ui n(0);char s;while(!isdigit(s=*_P++));while(n=n*10+(s&15),isdigit(s=*_P++));return n;
}
signed main(){
	fread(buf,1,1<<26,stdin);
	sieve();n=read();while(n--)++CB[id[read()]];q=read();
	for(ui i=1;i<=m;++i)for(ui k=0;k^M;++k)f[i][k]=1;for(ui k=0;k^M;++k)g[k]=1;
	for(ui i=1;i<=2000;++i)if(CB[i]){
		ui S(0);const ui&c=pow(2,CB[i]);for(ui k=1;k<=13;++k)if(!(i%pri[k]))S|=1<<k-1;
		for(ui k=0;k^M;++k)if((k&S)==S)f[mxp[i]][k]=1ull*f[mxp[i]][k]*c%mod;
	}
	for(ui i=1;i<=m;++i){
		cpy(h,f[i]);px(g,h);GetInv(h);for(ui k=0;k^M;++k)f[i][k]=(mod+f[i][k]-1)%mod;px(f[i],h);
	}
	while(q--){
		static ui ans[M];ui k=read();cpy(ans,g);
		for(ui p,i=1;i<=k;++i)p=read(),V[pos[p]]=true,vis[mxp[p]]=true;
		for(ui i=2;i<=m;++i)if(vis[i])px(ans,f[i]);
		for(ui len=1;len^M;len<<=1)for(ui i=0;i^M;i+=len<<1)for(ui k=0;k^len;++k){
			ans[i|k|len]=(ans[i|k|len]+mod-ans[i|k])%mod;
		}
		ui S(0),sum(0);for(ui k=1;k<=13;++k)if(V[k])S|=1<<k-1;
		for(ui k=0;k^M;++k)if((k&S)==S)sum=(sum+ans[k])%mod;
		for(ui k=0;k<=2000;++k)V[k]=vis[k]=false;
		printf("%u\n",1ull*sum*pow(2,CB[0])%mod);
	}
}
```

---

## 作者：zmx_wzx_JY (赞：1)

先上一手寿司晚宴的套路。$\sqrt V$ 以内只有 14 个质数。我们定义前 13 个质数是小质数，其他的质数是大质数，那么每个 $s_i$ 只会包含至多一个大质因数。

对于每组询问，把要求拆成小质数合法（存在其倍数被选中）和大质数合法两个限制。

先考虑只有大质数限制的情况，记 $g(i)$ 表示卡牌中 $i$ 的倍数的个数，则答案是 $2^n\prod_{p\in bigS}\frac{2^{g(p)}-1}{2^{g(p)}}$ ，其中 $bigS$ 表示当前询问被限制的大质数集合，预处理 $g(i)$ 即可。

（这个正确是因为选一张卡最多只会影响一个大质数的合法性，两个大质数之间互相不会干扰）。

容易想到对小质数的限制进行容斥，枚举 $S$ 的子集 $s$, 记钦定 $s$ 中元素的倍数都不能选，并保证被限制的大指数合法的情况数为 $f(s)$ ,则 $\sum(-1)^{|s|}f(s)$ 就是答案。

考虑 $f(s)$ 怎么求，预处理 $h(s)$ 和 $g'(s,i)$ 表示钦定 $s$ 中元素的倍数都不能选后，剩下卡牌的数量以及在剩下的卡牌中的 $g(s)$ 的值即可 $O(c_i)$ 计算一个 $f(s)$。

预处理的具体操作是先把 $s$ 中元素的倍数删掉，然后对每个大质数 $i$ ,统计 $i$ 倍数中卡牌的个数。

前面一步的复杂度我只会分析到 $O(V\log V)$，但因为只枚举小质数的倍数所以常数很小。后半部分中，一个数至多被一个大质数枚举到，所以总复杂度 $O(V)$。

那么总复杂度是 $O(2^{13}(V\log V+\sum c_i))$，时限还是非常松的，我谷上最慢的点也不到 200ms。

那个 $V\log V$ 有可能卡一卡可以卡成 $V$, 但因为常数原因并不会显著提升运行速度。

---

有没有老哥能讲讲 $\sum c_i$ 为啥要整成 $18000$ 这种鬼畜的东西啊

---

丑陋的代码：
```cpp
//dxy txdy!
#include<bits/stdc++.h>
#define LL long long
using namespace std;
#define Rep(i, x, y) for(int i = (x), stOdxy = (y); i <= stOdxy; ++i)
#define Irep(i, x, y) for(int i = (y), stOdxy = (x); i >= stOdxy; --i)
#define VEC vector<int>
#define pb push_back
#define PA pair<int, int>
#define MP make_pair
#define fi first
#define se second
#define ci const int&
#define il inline
#define let const auto
int read(){
	int res = 0, flag = 1; char c = getchar();
	while(c < '0' || c > '9') { if(c == '-') flag = -1; c = getchar(); }
	while(c >= '0' && c <= '9') res = res * 10 + c - '0', c = getchar();
	return res * flag;
}
const int F = 13;
const int N = 2005, mxS = 1 << F, P = 998244353;
int fix(ci x){ return x + ((x >> 31) & P); }
int qp[1000005], iqp[1000005];
int va[N], prim[N], pct, ish[N], id[N], n = 2000;

int f[mxS][400], g[mxS], bc[mxS];
bool vs[N];
void Init(){
	Rep(S, 0, mxS - 1){
		memset(vs, 0, sizeof(vs));
		Rep(i, 0, F - 1) if((1 << i) & S){
			++bc[S];
			for(int x = prim[i]; x <= n; x += prim[i]) vs[x] = 1;
		}
		Rep(i, 1, n) if(!vs[i]) g[S] += va[i];
		Rep(i, F, pct - 1){
			for(int x = prim[i]; x <= n; x += prim[i])
				if(!vs[x]) f[S][i] += va[x];
		}
	}
}
int a[N];
int Solve(){
	int m = read();
	Rep(i, 1, m) a[i] = read();
	sort(a + 1, a + m + 1);
	m = unique(a + 1, a + m + 1) - a - 1;
	Rep(i, 1, m) a[i] = id[a[i]];
	int nS = 0;
	Rep(i, 1, m) if(a[i] < F) nS |= 1 << a[i];
	LL ans = 0;
	Rep(S, 0, mxS - 1) if((S | nS) == nS){
		LL nans = qp[g[S]];
		Rep(i, 1, m) if(a[i] >= F)
			nans = nans * iqp[f[S][a[i]]] % P * fix(qp[f[S][a[i]]] -1) % P;
		ans += (bc[S] & 1) ? -nans : nans;
 	}
	return fix(ans % P);
}
signed main(){
	qp[0] = iqp[0] = 1; iqp[1] = (P + 1) / 2;
	Rep(i, 1, 1000000) qp[i] = fix(qp[i - 1] + qp[i - 1] - P);
	Rep(i, 2, 1000000) iqp[i] = 1ll * iqp[i - 1] * iqp[1] % P;
	int dxy = read();
	while(dxy--) va[read()]++;
	Rep(i, 2, n) if(!ish[i]){
		prim[id[i] = pct++] = i;
		for(int j = i; j <= n; j += i) ish[j] = 1;
	}
	Rep(i, 1, N - 1) if(va[i]) n = i;
	Init();
	int T = read();
	while(T--) printf("%d\n", Solve());
	return 0;
}

```
代码里的变量命名和题解稍有不同，$g$ 是题解中的 $h$, $f$ 是题解中的 $g'$。

---

## 作者：vectorwyx (赞：0)

这题和寿司晚宴几乎一模一样……没做过寿司晚宴的建议先做一下。

首先有一个显然的状压做法：令 $f_i$ 表示目前已有的质因数的集合为 $i$ 的方案数，转移式子为 $f_{i|s_j}+=f_i$，其中 $s_j$ 为数 $j$ 包含的质因子集合。

这样做复杂度直接升天，考虑沿用寿司晚宴的思路，对质因子根号分治。令 $V$ 为值域，把 $\le \sqrt V$ 的质数称作小质数，其余的称为大质数。那么每个数对应的质因子集合里至多包含一个大质数。状压处理小质数，分组处理大质数。处理小质数时的转移与上文一致，而在处理每个大质数组时，组内元素至少要选一个。先遍历组内元素按正常转移进行，把得到的 dp 数组减去转移前的 dp 数组即为所求。

复杂度大概是 $2^{13}\times 2000\times 60$，理论上过不了，但是官方数据比较水直接放过去了/jy。

代码如下：
```cpp
//author:望远星
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define mk make_pair
#define sml(x,y) (x=min(x,y))
#define big(x,y) (x=max(x,y))
#define ll long long
#define uint unsigned int
#define ull unsigned long long
#define db double
#define fo(i,x,y) for(int i=x;i<=y;++i)
#define go(i,x,y) for(int i=x;i>=y;--i)
using namespace std;
ll seed=chrono::system_clock::now().time_since_epoch().count();
mt19937 rnd(seed);
inline int rm(int x,int y){return (int)(rnd()%(y-x+1ll)+x);}
inline int read(){int ch=getchar(),x=0,f=1;while(!isdigit(ch)){if(ch==(int)('-'))f=-1;ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
inline void out(int *a,int l,int r){fo(i,l,r) cout<<*(a+i)<<' ';puts("");}

const int N=2005,qlr=998244353;
int a[N],m,c[N],pme[N],top,ok[N],wyx=1,rk[N],s[N],f[1<<13],f0[1<<13],f1[1<<3],pw[1000005];
vector<int> divi[N],g[N];

void xxs(int n){
	fo(i,2,n){
		if(!ok[i]) pme[++top]=i;
		fo(j,1,top){
			int p=pme[j],k=i*p;
			if(k>n) break;
			ok[k]=1;
			if(!(i%p)) break;
		}
	}
	//out(pme,1,10);
}

void add(int &x,ll y){
	x=(x+y)%qlr;
}

void solve(){
	int rp=0,n=read(),A=1,sum=0;
	fo(i,1,n) c[i]=read();
	sort(c+1,c+1+n);n=unique(c+1,c+1+n)-c-1;
	fo(i,1,m) rk[i]=s[i]=0,g[i].clear();
	fo(i,1,n){
		rk[c[i]]=i;
		int nxt=i<n?c[i+1]:c[n];
		if(c[i]*nxt<=m) A<<=1,rp++;
	}
	fo(i,1,m)if(a[i]){
		int lst=0;
		for(int j:divi[i]) if(rk[j]) s[i]|=rk[j]>rp?0:(1<<(rk[j]-1)),lst=rk[j];
		if(lst) g[lst].pb(i);
		else sum+=a[i];
	}
	//cout<<"rp="<<rp<<' '<<"s:";out(s,1,m);
	A--;fo(i,0,A) f[i]=0;
	f[0]=pw[sum];
	fo(i,1,n)if(!g[i].empty()){
	//	printf("%d!!!!!!!!!!!!!:\n",i);
	//	for(int j:g[i]) cout<<j<<' ';puts("");
		fo(j,0,A) f1[j]=f[j];
		for(int j:g[i])
			go(k,A,0){
				int &x=f1[k|s[j]];
				x=(x+f1[k]*(pw[a[j]]-1ll))%qlr;
			}//add(f1[k|s[j]],);
		if(i>rp) fo(j,0,A) f[j]=(f1[j]+qlr-f[j])%qlr;
		else fo(j,0,A) f[j]=f1[j];
	//	out(f1,0,A);out(f,0,A);
	}
	cout<<f[A]<<'\n';
}

signed main(){
	int n=read();pw[0]=1;
	fo(i,1,n){
		int x=read();
		if(x==1) wyx=(wyx<<1)%qlr;
		a[x]++;
		big(m,x);
		pw[i]=(pw[i-1]<<1)%qlr;
	}
	xxs(m);
	fo(i,1,top){
		int p=pme[i];
		fo(j,1,m/p) divi[p*j].pb(p);
	}
	int q=read();
	while(q--) solve();
	return 0;
}
/*
-------------------------------------------------
*/
```


---


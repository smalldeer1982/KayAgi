# [NOIP 2016 提高组] 天天爱跑步

## 题目背景

NOIP2016 提高组 D1T2

## 题目描述

小 C 同学认为跑步非常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。

这个游戏的地图可以看作一棵包含 $n$ 个结点和 $n-1$ 条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从 $1$ 到 $n$ 的连续正整数。

现在有 $m$ 个玩家，第 $i$ 个玩家的起点为 $s_i$，终点为 $t_i$。每天打卡任务开始时，所有玩家在第 $0$ 秒同时从自己的起点出发，以每秒跑一条边的速度，不间断地沿着最短路径向着自己的终点跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的）

小 C 想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点 $j$ 的观察员会选择在第 $w_j$ 秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第 $w_j$ 秒也正好到达了结点 $j$。小 C 想知道每个观察员会观察到多少人?

注意：我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一 段时间后再被观察员观察到。 即对于把结点 $j$ 作为终点的玩家：若他在第 $w_j$ 秒前到达终点，则在结点 $j$ 的观察员不能观察到该玩家；若他正好在第 $w_j$ 秒到达终点，则在结点 $j$ 的观察员可以观察到这个玩家。


## 说明/提示

**样例 1 说明**

对于 $1$ 号点，$w_i=0$，故只有起点为 $1$ 号点的玩家才会被观察到，所以玩家 $1$ 和玩家 $2$ 被观察到，共有 $2$ 人被观察到。

对于 $2$ 号点，没有玩家在第 $2$ 秒时在此结点，共 $0$ 人被观察到。

对于 $3$ 号点，没有玩家在第 $5$ 秒时在此结点，共 $0$ 人被观察到。

对于 $4$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。

对于 $5$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。

对于 $6$ 号点，玩家 $3$ 被观察到，共 $1$ 人被观察到。

**子任务**

每个测试点的数据规模及特点如下表所示。 

提示：数据范围的个位上的数字可以帮助判断是哪一种数据类型。

| 测试点编号 | $n=$ | $m=$ | 约定 |
| :--------: | :----: | :----: | :----: |
|     $1\sim 2$      |  $991$   |  $991$   | 所有人的起点等于自己的终点，即 $\forall i,\ s_i=t_i$  |
|     $3\sim 4$      |  $992$   |  $992$   | 所有 $w_j=0$  |
|     $5$      |  $993$   |  $993$   | 无  |
|     $6\sim 8$      |  $99994$   |  $99994$   | $\forall i\in[1,n-1]$，$i$ 与 $i+1$ 有边。即树退化成 $1,2,\dots,n$ 按顺序连接的链  |
|     $9\sim 12$      |  $99995$   |  $99995$   | 所有 $s_i=1$  |
|     $13\sim 16$      |  $99996$   |  $99996$   | 所有 $t_i=1$  |
|     $17\sim 19$      |  $99997$   |  $99997$   | 无  |
|     $20$      |  $299998$   |  $299998$   | 无  |



**提示**

（提示：由于原提示年代久远，不一定能完全反映现在的情况，现在已经对该提示做出了一定的修改，提示的原文可以在[该剪贴板](https://www.luogu.com.cn/paste/3fneb8m6)查看）

在最终评测时，调用栈占用的空间大小不会有单独的限制，但在我们的工作环境中默认会有 $1 \text{MiB}$ 的限制。 这可能会引起**函数调用层数较多时，程序发生栈溢出崩溃**，程序中**较深层数的递归**往往会导致这个问题。如果你的程序需要用到较大的栈空间，请务必注意该问题。

我们可以使用一些方法修改调用栈的大小限制。

- Linux

我们可以在终端中输入下列命令：`ulimit -s 1048576`。此命令的意义是，将调用栈的大小限制修改为 $1048576\text{KiB}=1 \text{GiB}$。

例如，对于如下程序 `sample.cpp`：

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[1000005];
void dfs(int a){
	if(a == 0){
		f[a] = 0;
		return;
	}
	dfs(a - 1);
	f[a] = f[a - 1] + 1;
}
int main(){
	dfs(1000000);
	return 0;
}
```

将上述源代码用命令 `g++ sample.cpp -o sample` 编译为可执行文件 `sample` 后，使用 `./sample` 执行程序。

如果在没有使用命令 `ulimit -s 1048576` 的情况下运行该程序，`sample` 会因为栈溢出而崩溃；如果使用了上述命令后运行该程序，该程序则不会崩溃。

特别地，当你打开多个终端时，它们并不会共享该命令，你需要分别对它们运行该命令。

请注意，调用栈占用的空间会计入总空间占用中，和程序其他部分占用的内存共同受到内存限制。

- Windows

如果你使用 Windows 下的 Dev-C++，请选择 `工具-编译选项` 并在如下区域填入以下命令 `-Wl,--stack=1073741824`，填入后注意确认“编译时加入以下命令的”的框是**已勾选**状态。

此处 `1073741824` 的单位是 $\text{B/Bytes}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/z6mbzfqo.png)  ![](https://cdn.luogu.com.cn/upload/image_hosting/zvrzkyq5.png)

## 样例 #1

### 输入

```
6 3
2 3
1 2 
1 4 
4 5 
4 6 
0 2 5 1 2 3 
1 5 
1 3 
2 6 ```

### 输出

```
2 0 0 1 1 1 ```

## 样例 #2

### 输入

```
5 3 
1 2 
2 3 
2 4 
1 5 
0 1 0 3 0 
3 1 
1 4
5 5 ```

### 输出

```
1 2 1 0 1 ```

# 题解

## 作者：greenlcat (赞：761)

#### **首先声明这不是一篇算法独特的题解，仍然是“LCA+桶+树上差分”，但这篇题解是为了让很多很多看了很多题解仍然看不懂的朋友们看懂的，其中就包括我，我也在努力地把解题的“思维过程”呈现出来，希望能帮助到别人。实在是佩服那些考场AC的大牛，再次向你们献上敬意！**

##### 原文链接（https://www.cnblogs.com/lfyzoi/p/10221884.html）

##### 1. 第一步

- 首先可以初步判断这个题肯定要计算**LCA**，方法有**倍增**/**Tarjan-DFS**，我们就写个简单的倍增吧，使用**链式前向星**存储边。
- 选择1号结点开始dfs，别的结点也可以
- dfs过程中计算`fa[][]`数组（`fa[x][i]`表示 $x$ 结点的 $2^i$ 代祖先是谁）和deep[]数组（`deep[x]`表示结点 $x$ 在树中的深度）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int SIZE=300000;
int n, m, tot, h[SIZE], deep[SIZE], fa[SIZE][20], w[SIZE];      //w[i]表示i结点出现观察员的时间
struct edge
{
	int to, next;
}E[SIZE*2], e1[SIZE*2], e2[SIZE*2];                             //边集数组e1，e2留待备用

void add(int x, int y)                                          //加边函数
{
	E[++tot].to=y;
	E[tot].next=h[x];
	h[x]=tot;
}

void dfs1(int x)                                                //dfs的过程中完成“建树”，预处理fa[][]数组, 计算deep[]数组
{
	for(int i=1; (1<<i)<=deep[x]; i++)
		fa[x][i]=fa[fa[x][i-1]][i-1];                           //x的2^i代祖宗就是x的2^{i-1}代祖宗的2^{i-1}代祖宗
	for(int i=h[x]; i; i=E[i].next)
	{
		int y=E[i].to;
		if(y==fa[x][0])	continue;                               //如果y是父结点，跳过
		fa[y][0]=x;
		deep[y]=deep[x]+1;
		dfs1(y);
	}
}

int get_lca(int x, int y)                                      //计算x和y的最近公共祖先
{
	if(x==y) return x;                                         //没有这一行，遇到 lca(x, x) 这样的询问时会挂掉
	if(deep[x]<deep[y]) swap(x, y);                            //保持x的深度大于y的深度
	int t=log(deep[x]-deep[y])/log(2);
	for(int i=t; i>=0; i--)                                    //x向上跳到和y同样的深度
	{
		if(deep[fa[x][i]]>=deep[y])
			x=fa[x][i];
		if(x==y)
			return x;
	}
	t=log(deep[x])/log(2);
	for(int i=t; i>=0; i--)                                    //x和y一起向上跳
	{
		if(fa[x][i]!=fa[y][i])
			x=fa[x][i], y=fa[y][i];
	}
	return fa[x][0];
}

int main()                                                     //先把主函数写上一部分
{
	scanf("%d%d", &n, &m);
	for(int i=1; i<n; i++)
	{
		int u, v;
		scanf("%d%d", &u, &v);
		add(u, v);
		add(v, u);
	}
	deep[1]=1;
	fa[1][0]=1;
	dfs1(1);
	for(int i=1; i<=n; i++) scanf("%d", &w[i]);
	
    /////////////////////////////////////////////////////////////
    ////////////////////////未完待续///////////////////////////
    /////////////////////////////////////////////////////////////
    
	return 0;
}
```

##### 2. 第二步

大概分析一下，m个玩家对应m条路径，有了起点和终点的 lca 后，如果我们模拟这个过程：

**直觉**

- 从起点 $S_i$ 跑到 $LCA$ 在树长得很匀称的情况下为 $O(lgn)$
- 从起点 $LCA$ 跑到 $T_i$ 在树长得很匀称的情况下为 $O(lgn)$
- 因此，模拟一个玩家的跑步过程为 $O(lgn)$，m个玩家为 $O(mlgn)$
- 理想情况下是可行的，但现实就是不理想
- 题目清楚告诉你，树会退化成一条链，因此模拟一个过程变成 $O(n)$，总的就是。。。$O(mn)$，必挂无疑
- 此法不是正解！

**尝试**

- 我们能不能改变模拟跑步的过程，从 $O(n)$ 优化到 $O(lgn)$ 呢？思前想后不可能，有 $n$ 个观察员矗在那里，你可以对哪个视而不见？
- 路已走到尽头

**转换**

- 这时候需要放大招，转换思想！或许解决问题的思路压根就不是一个玩家一个玩家模拟，而是整体处理呢？
- 也就是说，我们**不枚举每个运动员**，**而是枚举每个观察员i**，看看**哪些结点会为这个观察员i**做贡献（刚好在$w_i$秒跑到他这儿）。
- **枚举观察员的过程就是DFS整颗树的过程**，我们可以在 $O(n)$ 内搞定！
- 对于观察员i，哪些人会为他做贡献呢？

**深入分析**

- 对于结点 $P$， 如果他位于一条起点、终点分别为 $s_i$， $t_i$ 的跑步路径上，如何判断这名选手会不会为 $P$ 作贡献呢？
- 分情况考虑
- 如果 $P$ 是在从 $s_i$ 到 $LCA$ 的路上，如下图：

![](https://img2018.cnblogs.com/blog/948343/201901/948343-20190104184757096-1095323337.png)

- 我们可以得出结论：当起点 $ s_i $ 满足 $ deep[s_i]=w[P]+deep[P] $时，起点 $s_i$会为 $P$ 观察员做一个贡献（运动员从$s_i$出发，可以被$P$处的观察员在$w[P]$秒看到）

- 如果 $P$ 是在从 $LCA$ 到 $t_i$ 的路上，如下图：

![](https://img2018.cnblogs.com/blog/948343/201901/948343-20190104184856525-918538990.png)

- 定义 $dist[s_i, t_i]$为从 $s_i$出发到$t_i$的路径长度，如果运动员从$s_i$出发，可以被$P$处的观察员在$w[P]$秒观察到，可以由上图得出以下式子：
- $dist[s_i, t_i]-w[P]=deep[t_i]-deep[P]$，移项后得到：
- $ dist[s_i, t_i]-deep[t_i]=w[P]-deep[P] $
- 我们可以得出结论：当终点 $ t_i $ 满足 $ dist[s_i, t_i]-deep[t_i]=w[P]-deep[P] $时，终点 $t_i$会为 $P$ 观察员做一个贡献
- 做一个重要的总结：上行过程中，满足条件的起点可以做贡献，下行过程中，满足条件的终点可以做贡献，但无论是哪一种情形，**能对 $P$ 做贡献的起点或终点一定都在以$P$为根的子树上**，这使得可以在DFS回溯的过程中处理以任意节点为根的子树。

##### 3. 第三步

**如何统计子树贡献**

- 递归以$P$为根的子树时，可以统计出其子树中所有的起点和终点对它的贡献
- 这里又需要转换
- 子树中有的起点和终点对$P$产生了贡献，有些不对其产生贡献但对$P$以外的结点产生了贡献
- 所以我们不能枚举每个点（子树根），找子树中哪些点对其产生贡献，这样复杂度就上去了
- 而是对于树上的任何一个起点和终点，把其产生的贡献放在桶里面，回溯到子树根的时候再到桶里面查询结果
- 有人产生疑问了，也是很多人看不懂这里桶用法的地方，疑问如图：

![](https://img2018.cnblogs.com/blog/948343/201901/948343-20190104184931060-1218903801.png)

- $c$点产生贡献放在桶的$deep[c]$位置，计算$b$点获得的贡献时当然是从$bucket1[deep[b]+w[b]]$位置获取，于是得到1个贡献，你发现$a$结点也是用的同一个桶，这个还好，因为$c$确实给他做了贡献，可是$e$点呢？他是不应该获得贡献的！既然我会给和我无关的结点做贡献，那么其它无关的结点难免也会给我做贡献！
- 问题总结一下，对于一个点$P$来说，究竟哪些点在桶里面产生的贡献才是有效的。
- 答案是：**以$P$为根递归整颗子树过程中在桶内产生的差值才是有效的**


**还要考虑一种情况**

- 先看图：

![](https://img2018.cnblogs.com/blog/948343/201901/948343-20190104184957939-1302319020.png)

- 看懂了吗？对于以$P$为根的内部路径（不经过$P$），这条路径的起点和终点产生的贡献是不应该属于$P$的
- 所以dfs过程中，在统计当前结点作为起点和终点所产生的贡献后，继而计算出当前结点作为“根”上的差值后，在回溯过程中，一定要减去以当前结点为$LCA$的起点、终点在桶里产生的贡献，这部分贡献在离开这个子树后就没有意义了。

**代码说明**

- `e1,tot1,h1,add1`是使用链式前向星的方法存储**每个结点作为终点对应的路径集合**
- `e2,tot2,h2,add2`是使用链式前向星的方法存储**每个结点作为LCA对应的路径集合**
- `b1,b2`是两组桶，分别用于**上行阶段**和**下行阶段**的贡献统计
- `js[SIZE]`用于统计**以每个结点作为起点的路径条数**
- `dist[SIZE], s[SIZE], t[SIZE]`用于统计m条路径对应的长度，起点和终点信息
- `ans[SIZE]`存储最后输出的答案，是每个结点观察员看到的人数

```cpp
int tot1, tot2, h1[SIZE], h2[SIZE];
void add1(int x, int y)
{
	e1[++tot1].to=y;
	e1[tot1].next=h1[x];
	h1[x]=tot1;
}

void add2(int x, int y)
{
	e2[++tot2].to=y;
	e2[tot2].next=h2[x];
	h2[x]=tot2;
}

int b1[SIZE*2], b2[SIZE*2], js[SIZE], dist[SIZE], s[SIZE], t[SIZE], ans[SIZE];

void dfs2(int x)
{
	int t1=b1[w[x]+deep[x]], t2=b2[w[x]-deep[x]+SIZE];      //递归前先读桶里的数值，t1是上行桶里的值，t2是下行桶的值
	for(int i=h[x]; i; i=E[i].next)                         //递归子树
	{
		int y=E[i].to;
		if(y==fa[x][0]) continue;
		dfs2(y);
	}
	b1[deep[x]]+=js[x];                                     //上行过程中，当前点作为路径起点产生贡献，入桶
	for(int i=h1[x]; i; i=e1[i].next)                       //下行过程中，当前点作为路径终点产生贡献，入桶
	{
		int y=e1[i].to;
		b2[dist[y]-deep[t[y]]+SIZE]++;
	}
	ans[x]+=b1[w[x]+deep[x]]-t1+b2[w[x]-deep[x]+SIZE]-t2;   //计算上、下行桶内差值，累加到ans[x]里面
	for(int i=h2[x]; i; i=e2[i].next)                       //回溯前清除以此结点为LCA的起点和终点在桶内产生的贡献，它们已经无效了
	{
		int y=e2[i].to;
		b1[deep[s[y]]]--;                                   //清除起点产生的贡献
		b2[dist[y]-deep[t[y]]+SIZE]--;                      //清除终点产生的贡献
	}
}

int main()
{
////////////////重复部分跳过////////////
////////////////文末提供完整代码////////
	for(int i=1; i<=m; i++)                                 //读入m条询问
	{
		scanf("%d%d", &s[i], &t[i]);
		int lca=get_lca(s[i], t[i]);                        //求LCA
		dist[i]=deep[s[i]]+deep[t[i]]-2*deep[lca]];         //计算路径长度
		js[s[i]]++;                                         //统计以s[i]为起点路径的条数，便于统计上行过程中该结点产生的贡献
		add1(t[i], i);                                      //第i条路径加入到以t[i]为终点的路径集合中
		add2(lca, i);                                       //把每条路径归到对应的LCA集合中
		if(deep[lca]+w[lca]==deep[s[i]]) ans[lca]--;        //见下面的解释
	}
	dfs2(1);                                                //dfs吧！
	for(int i=1; i<=n; i++) printf("%d ", ans[i]); 
	return 0;
}
```

**一些重要补充**

- 上述代码中有一行未加解释`if(deep[lca]+w[lca]==deep[s[i]]) ans[lca]--;`
- 考虑路径是这样的，如图：

![](https://img2018.cnblogs.com/blog/948343/201901/948343-20190104185028628-1134207080.png)

- 这个图可能不太好懂，意思是：
- 如果路径起点或终点刚好为LCA且LCA处是可观察到运动员的，那么我们在上行统计过程中和下行统计过程中都会对该LCA产生贡献，这样就重复计数一次！
- 好在这种情况很容易发现，我们提前预测到，对相应的结点进行`ans[x]--`即可。


- 此外，在使用第二个桶时，下标是`w[x]-deep[x]`会成为负数，所以使用第二个桶时，下标统一`+SIZE`，向右平移一段区间，防止下溢。



##### 4. 结束

我不知道自己说清楚没有，但愿大家不要拍砖头！下面是完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int SIZE=300000;
int n, m, tot, h[SIZE], deep[SIZE], fa[SIZE][20], w[SIZE];
struct edge
{
	int to, next;
}E[SIZE*2], e1[SIZE*2], e2[SIZE*2];

void add(int x, int y)
{
	E[++tot].to=y;
	E[tot].next=h[x];
	h[x]=tot;
}

int tot1, tot2, h1[SIZE], h2[SIZE];
void add1(int x, int y)
{
	e1[++tot1].to=y;
	e1[tot1].next=h1[x];
	h1[x]=tot1;
}
void add2(int x, int y)
{
	e2[++tot2].to=y;
	e2[tot2].next=h2[x];
	h2[x]=tot2;
}

void dfs1(int x)
{
	for(int i=1; (1<<i)<=deep[x]; i++)
		fa[x][i]=fa[fa[x][i-1]][i-1];
	for(int i=h[x]; i; i=E[i].next)
	{
		int y=E[i].to;
		if(y==fa[x][0])	continue;
		fa[y][0]=x;
		deep[y]=deep[x]+1;
		dfs1(y);
	}
}

int get_lca(int x, int y)
{
	if(x==y) return x;
	if(deep[x]<deep[y]) swap(x, y);
	int t=log(deep[x]-deep[y])/log(2);
	for(int i=t; i>=0; i--)
	{
		if(deep[fa[x][i]]>=deep[y])
			x=fa[x][i];
		if(x==y)
			return x;
	}
	t=log(deep[x])/log(2);
	for(int i=t; i>=0; i--)
	{
		if(fa[x][i]!=fa[y][i])
			x=fa[x][i], y=fa[y][i];
	}
	return fa[x][0];
}

int b1[SIZE*2], b2[SIZE*2], js[SIZE], dist[SIZE], s[SIZE], t[SIZE], l[SIZE], ans[SIZE];
void dfs2(int x)
{
	int t1=b1[w[x]+deep[x]], t2=b2[w[x]-deep[x]+SIZE];
	for(int i=h[x]; i; i=E[i].next)
	{
		int y=E[i].to;
		if(y==fa[x][0]) continue;
		dfs2(y);
	}
	b1[deep[x]]+=js[x];
	for(int i=h1[x]; i; i=e1[i].next)
	{
		int y=e1[i].to;
		b2[dist[y]-deep[t[y]]+SIZE]++;
	}
	ans[x]+=b1[w[x]+deep[x]]-t1+b2[w[x]-deep[x]+SIZE]-t2;
	for(int i=h2[x]; i; i=e2[i].next)
	{
		int y=e2[i].to;
		b1[deep[s[y]]]--;
		b2[dist[y]-deep[t[y]]+SIZE]--;
	}
}

int main()
{
	scanf("%d%d", &n, &m);
	for(int i=1; i<n; i++)
	{
		int u, v;
		scanf("%d%d", &u, &v);
		add(u, v);
		add(v, u);
	}
	deep[1]=1;
	fa[1][0]=1;
	dfs1(1);
	for(int i=1; i<=n; i++) scanf("%d", &w[i]);
	for(int i=1; i<=m; i++)
	{
		scanf("%d%d", &s[i], &t[i]);
		int lca=get_lca(s[i], t[i]);
		dist[i]=deep[s[i]]+deep[t[i]]-2*deep[lca];
		js[s[i]]++;
		add1(t[i], i);
		add2(lca, i);
		if(deep[lca]+w[lca]==deep[s[i]]) ans[lca]--;
	}
	dfs2(1);
	for(int i=1; i<=n; i++) printf("%d ", ans[i]);
	return 0;
}
```

---

## 作者：一扶苏一 (赞：176)

我们一档一档部分分来看。

因为下面要跟随测试点贴代码，这里先把main函数和预处理部分贴出

```cpp
#include<vector>
#include<cstdio>
#include<algorithm>
#define rg register
#define ci const int
#define cl const long long int

typedef long long int ll;

namespace IO {
    char buf[90];
}

template<typename T>
inline void qr(T &x) {
    char ch=getchar(),lst=' ';
    while(ch>'9'||ch<'0') lst=ch,ch=getchar();
    while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    if(lst=='-') x=-x;
}

template<typename T>
inline void write(T x,const char aft,const bool pt) {
    if(x<0) x=-x,putchar('-');
    int top=0;
    do {
        IO::buf[++top]=x%10+'0';
        x/=10;
    } while(x);
    while(top) putchar(IO::buf[top--]);
    if(pt) putchar(aft);
}

template<typename T>
inline T mmax(const T a,const T b) {if(a>b) return a;return b;}
template<typename T>
inline T mmin(const T a,const T b) {if(a<b) return a;return b;}
template<typename T>
inline T mabs(const T a) {if(a<0) return -a;return a;}

template<typename T>
inline void mswap(T &a,T &b) {
    T temp=a;a=b;b=temp;
}

const int maxn = 1000010;
const int maxm = 1000010;
const int ZAY = 300004;

struct Edge {
    int to,nxt;
};
Edge edge[maxm];int hd[maxn],ecnt;
inline void cont(ci from,ci to) {
    Edge &e=edge[++ecnt];
    e.to=to;e.nxt=hd[from];hd[from]=ecnt;
}

struct M {
    int s,t,an,sum,tk;
    inline bool operator<(const M &_others) const {
        return this->sum < _others.sum;
    }
};
M MU[maxn];

struct W {
    int v,num,ans;
    inline bool operator<(const W &_others) const {
        return this->v < _others.v;
    }
};
W w[maxn];

struct C {
    int ud,v,tp;
    C (int _ud=0,int _v=0,int _tp=0) {ud=_ud,v=_v,tp=_tp;}
};
std::vector<C>cg[maxn];

int n,m;
int deepth[maxn],fa[maxn],LCA[30][maxn],pos[maxn],lft[maxn],rt[maxn];

void t1();
void s1();
void lian();
void baoli();
void zhengjie();
void dfs(ci,ci);
int ask(int,int);
int dfsearch(ci,ci);
void deepfs(ci,ci);
void dfirsts(ci,ci);

inline bool cmp(const W &_a,const W & _b) {
    return _a.num < _b.num;
}

int main() {
    qr(n);qr(m);
    rg int a,b;
    for(rg int i=1;i<n;++i) {
        a=b=0;qr(a);qr(b);
        cont(a,b);cont(b,a);
    }
    for(rg int i=1;i<=n;++i) {
        qr(w[i].v);w[i].num=i;
    }
    for(rg int i=1;i<=m;++i) {
        qr(MU[i].s);qr(MU[i].t);
    }
	int _num=n%10;
    if(_num < 4) baoli();
    else if(_num == 4) lian();
    else if(_num == 5) s1();
    else if(_num == 6) t1();
    else zhengjie();
    return 0;
}

void dfs(ci u,ci fat) {
    deepth[u]=deepth[fa[u]=fat]+1;
    LCA[0][u]=fat;
    for(rg int i=0;LCA[i][u];++i) {
        LCA[i+1][u]=LCA[i][LCA[i][u]];
    }
    for(rg int i=hd[u];i;i=edge[i].nxt) if(edge[i].to != fat)
        dfs(edge[i].to,u);
}

int ask(int x,int y) {
    if(deepth[x] < deepth[y]) mswap(x,y);
    rg int delta=deepth[x]-deepth[y];
    for(rg int i=25;delta;--i) if(delta & (1<<i)) {
        x=LCA[i][x],delta^=(1<<i);
    }
    if(x == y) return x;
    for(rg int i=25;i != -1;--i) if(LCA[i][x] != LCA[i][y]) {
        x=LCA[i][x],y=LCA[i][y];
    }
    return LCA[0][x];
}
```

#### 测试点$1$、$2$
起点和终点相同，那么只会在第零秒被观测到。那么对于所有$W_j=0$的点统计有多少条路径为这个点即可。期望得分$10$分

#### 测试点$3$、$4$
每个观察员都是0，所以直接对每条路径起点的计数器++即可。期望得分$20$分

#### 测试点$5$
发现秒数不超过1000，可以暴力枚举每一秒，在每一秒暴力枚举每个玩家在什么位置。具体的，对每条路径求LCA。对于每个玩家，如果当前时间比起点到LCA的距离小，那么点$u$的位置变成$father[u]$。否则若当前是第$k$秒，则他的位置是终点$t$向上$l-k-1$个深度。其中$l$是路径长度。期望得分$25$分

#### 测试点$6$、$7$、$8$
当树是一条链的时候，发现从$s$出发只有向左和向右两种可能。具体的，$s~\leq~t$则向右，否则向左。考虑对于在点$j$的观察员，不妨设被他观察的玩家向右行走（向左同理），则有
$$s+w_j=j$$
移项可得
$$s=j-W_j$$
类似的对向左行走的满足
$$s=j+W_j$$
这样的计数问题显然是需要桶的。有两种方法通过这几个测试点。
>1 排序

将每个点按照观察员出现的时间排序，把所有$s$压入桶中，将每条路径按照长度排序。枚举每个观察员出现的时间，对于第$j$个观察员，它的答案即为$lft[j+w_j]+rt[j-w_j]$，每过一个时刻删除桶中已经到终点的路径。由于一共有$n$个观察员，每条路径被枚举$1$次，共$n$次。加上排序，时间复杂度为$O(nlogn)$。
```cpp
void lian() {
    for(rg int i=1;i<=m;++i) {
        if(MU[i].t >= MU[i].s) ++rt[MU[i].s],MU[i].sum=MU[i].t-MU[i].s;
        else ++lft[MU[i].s],MU[i].sum=MU[i].s-MU[i].t;
    }
    std::sort(MU+1,MU+1+m);
    std::sort(w+1,w+1+n);
    rg int j=0;
    for(rg int i=1;i<=n;++i) {
        while(j <= m) {
            if(MU[j].sum >= w[i].v) break;
            if(MU[j].s <= MU[j].t) --rt[MU[j].s];
            else --lft[MU[j].s];
            ++j;
        }
        int _d=w[i].num-w[i].v;
        if(_d > 0) w[i].ans+=rt[_d];
        _d=w[i].num+w[i].v;
        if(_d <= n) w[i].ans+=lft[_d];
    }
    std::sort(w+1,w+1+n,cmp);
    for(rg int i=1;i<n;++i) write(w[i].ans,' ',true);
    write(w[n].ans,'\n',true);
}
```

>2 差分

直接扫描整条链。先从左向右扫描。对于一个点$i$，向桶中加入会从该点出发的向右的路径条数。对于每个终点，把所有终点为它的向右的路径的起点位置的桶$--$。这样对于每个点统计答案时统计的就是当前合法（没有结束）的节点$s$的个数。然后从右向左扫描，方法同理。扫描结束后可以得到答案。
复杂度$O(n)$。

期望得分40分。

#### 测试点$9$~$12$

这4个测试点起点都是1。我们不妨钦定这棵树1是根
对于每个点$j$的观察员，能观察到点显然当且仅当$w_j==deepth_j$。那么他能观察到的点的个数显然是它子树中的终点个数。直接dfs统计即可。

```cpp
void s1() {
    deepth[0]=-1;
    dfs(1,0);
    for(rg int i=1;i<=m;++i) {
        ++lft[MU[i].t];
    }
    int _cnt=dfsearch(1,0);
    if(!w[1].v) w[1].ans=_cnt;
    for(rg int i=1;i<n;++i) write(w[i].ans,' ',true);
    write(w[n].ans,'\n',true);
}

int dfsearch(ci u,ci fat) {
    rg int _cnt=lft[u];
    for(rg int i=hd[u];i;i=edge[i].nxt) if(edge[i].to != fat) 
        _cnt+=dfsearch(edge[i].to,u);
    if(w[u].v == deepth[u]) w[u].ans=_cnt;
    return _cnt;
}
```

#### 测试点$13$~$16$
这些测试点的终点是1。依然不妨钦定1为根。
考虑一个点$j$能看到一条路径$i$显然该路径的起点是$j$的子树并且$w_j+deepth_j=l$，其中$l$为链长。这样依然可以dfs统计$j$的子树的信息。这里有一个小技巧：对于一个全局的桶，如果想使用它记录一次dfs对答案的贡献，则在进入dfs时记录初始量，dfs结束时求最终量，中间的增量即为这次dfs对答案的贡献。在这里增量就是$j$的子树中满足上式的链的条数。

```cpp
void deepfs(ci u,ci fat) {
    rg int _c=lft[w[u].v+deepth[u]+ZAY];
    lft[deepth[u]+ZAY]+=rt[u];
    for(rg int i=hd[u];i;i=edge[i].nxt) if(edge[i].to != fat)
        deepfs(edge[i].to,u);
    w[u].ans=lft[w[u].v+deepth[u]+ZAY]-_c;
}

void t1() {
    deepth[0]=-1;
    for(rg int i=1;i<=m;++i) ++rt[MU[i].s];
    dfs(1,0);
    deepfs(1,0);
    for(rg int i=1;i<n;++i) write(w[i].ans,' ',true);
    write(w[n].ans,'\n',true);
}
```

#### 测试点$17$~$20$

把上面的思路整理一下。刚才的起点和终点分别为根已经提示我们将路径分为向上走的和向下走的两种。对于向上走的，一个玩家能被点$j$看见的必要条件是$deepth_j+w_j=deepth_s$，其中s是起点
对于向下走的玩家，能被$j$的必要条件是$deepth_j+w_j=deepth_t-l+1$，其中$l$为链长t是终点。注意到上面的条件都是必要条件，一个玩家被保证能看见需要保证该路径经过该点。这样我们可以dfs对于每个点统计经过他的路径中的答案。如果快速的对不合法的路径进行删除呢？考虑是链的部分带给我们的思路，对于一条路径，我们将其分为向上的为$s$到$LCA的儿子$，向下的为$LCA$到$t$。这样对于向上的在$s$处对桶中的答案$++$，在LCA处(LCA的儿子的父亲)对答案$--$。向下的路径在$t$处对桶中的答案$++$，在$LCA$的父亲处$--$。即可通过本题

```cpp
void zhengjie() {
    dfs(1,0);
    for(rg int i=1;i<=n;++i) {
        MU[i].an=ask(MU[i].s,MU[i].t);
        MU[i].sum=deepth[MU[i].s]-2*deepth[MU[i].an]+deepth[MU[i].t]+1;
        cg[MU[i].s].push_back(C(1,deepth[MU[i].s],1));
        cg[MU[i].t].push_back(C(2,deepth[MU[i].t]-MU[i].sum+1+ZAY,1));
        cg[MU[i].an].push_back(C(1,deepth[MU[i].s],-1));
        cg[fa[MU[i].an]].push_back(C(2,deepth[MU[i].t]-MU[i].sum+1+ZAY,-1));
    }
    dfirsts(1,0);
    for(rg int i=1;i<n;++i) write(w[i].ans,' ',true);
    write(w[n].ans,'\n',true);
}

void dfirsts(ci u,ci fat) {
    int _temp=lft[deepth[u]+w[u].v]+rt[deepth[u]-w[u].v+ZAY];
    rg unsigned int _s=cg[u].size();
    for(rg unsigned i=0;i<_s;++i) {
        int _ud=cg[u][i].ud;
        if(_ud == 1) {
            lft[cg[u][i].v]+=cg[u][i].tp;
        }
        else rt[cg[u][i].v]+=cg[u][i].tp;
    }
    for(rg int i=hd[u];i;i=edge[i].nxt) if(edge[i].to != fat) 
        dfirsts(edge[i].to,u);
    w[u].ans=lft[deepth[u]+w[u].v]+rt[deepth[u]-w[u].v+ZAY]-_temp;
}
```

## Code
这其中包含所有的部分分。事实上直接跑正解即可
```cpp
#include<vector>
#include<cstdio>
#include<algorithm>
#define rg register
#define ci const int
#define cl const long long int

typedef long long int ll;

namespace IO {
    char buf[90];
}

template<typename T>
inline void qr(T &x) {
    char ch=getchar(),lst=' ';
    while(ch>'9'||ch<'0') lst=ch,ch=getchar();
    while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    if(lst=='-') x=-x;
}

template<typename T>
inline void write(T x,const char aft,const bool pt) {
    if(x<0) x=-x,putchar('-');
    int top=0;
    do {
        IO::buf[++top]=x%10+'0';
        x/=10;
    } while(x);
    while(top) putchar(IO::buf[top--]);
    if(pt) putchar(aft);
}

template<typename T>
inline T mmax(const T a,const T b) {if(a>b) return a;return b;}
template<typename T>
inline T mmin(const T a,const T b) {if(a<b) return a;return b;}
template<typename T>
inline T mabs(const T a) {if(a<0) return -a;return a;}

template<typename T>
inline void mswap(T &a,T &b) {
    T temp=a;a=b;b=temp;
}

const int maxn = 1000010;
const int maxm = 1000010;
const int ZAY = 300004;

struct Edge {
    int to,nxt;
};
Edge edge[maxm];int hd[maxn],ecnt;
inline void cont(ci from,ci to) {
    Edge &e=edge[++ecnt];
    e.to=to;e.nxt=hd[from];hd[from]=ecnt;
}

struct M {
    int s,t,an,sum,tk;
    inline bool operator<(const M &_others) const {
        return this->sum < _others.sum;
    }
};
M MU[maxn];

struct W {
    int v,num,ans;
    inline bool operator<(const W &_others) const {
        return this->v < _others.v;
    }
};
W w[maxn];

struct C {
    int ud,v,tp;
    C (int _ud=0,int _v=0,int _tp=0) {ud=_ud,v=_v,tp=_tp;}
};
std::vector<C>cg[maxn];

int n,m;
int deepth[maxn],fa[maxn],LCA[30][maxn],pos[maxn],lft[maxn],rt[maxn];

void t1();
void s1();
void lian();
void baoli();
void zhengjie();
void dfs(ci,ci);
int ask(int,int);
int dfsearch(ci,ci);
void deepfs(ci,ci);
void dfirsts(ci,ci);

inline bool cmp(const W &_a,const W & _b) {
    return _a.num < _b.num;
}

int main() {
    qr(n);qr(m);
    rg int a,b;
    for(rg int i=1;i<n;++i) {
        a=b=0;qr(a);qr(b);
        cont(a,b);cont(b,a);
    }
    for(rg int i=1;i<=n;++i) {
        qr(w[i].v);w[i].num=i;
    }
    for(rg int i=1;i<=m;++i) {
        qr(MU[i].s);qr(MU[i].t);
    }
	int _num=n%10;
    if(_num < 4) baoli();
    else if(_num == 4) lian();
    else if(_num == 5) s1();
    else if(_num == 6) t1();
    else zhengjie();
    return 0;
}

void dfs(ci u,ci fat) {
    deepth[u]=deepth[fa[u]=fat]+1;
    LCA[0][u]=fat;
    for(rg int i=0;LCA[i][u];++i) {
        LCA[i+1][u]=LCA[i][LCA[i][u]];
    }
    for(rg int i=hd[u];i;i=edge[i].nxt) if(edge[i].to != fat)
        dfs(edge[i].to,u);
}

int ask(int x,int y) {
    if(deepth[x] < deepth[y]) mswap(x,y);
    rg int delta=deepth[x]-deepth[y];
    for(rg int i=25;delta;--i) if(delta & (1<<i)) {
        x=LCA[i][x],delta^=(1<<i);
    }
    if(x == y) return x;
    for(rg int i=25;i != -1;--i) if(LCA[i][x] != LCA[i][y]) {
        x=LCA[i][x],y=LCA[i][y];
    }
    return LCA[0][x];
}

void baoli() {
    dfs(1,0);
    for(rg int i=1;i<=m;++i) {
        MU[i].an=ask(MU[i].s,MU[i].t);
        pos[i]=MU[i].s;
    }
    std::sort(w+1,w+1+n);
    rg int j=1;
    for(rg int i=0;i<n;++i) {
        while(j <= n) {
            if(w[j].v != i) break;
            for(rg int k=1;k<=m;++k) if(pos[k] == w[j].num) ++w[j].ans;
            ++j;
        }
        for(rg int k=1;k<=m;++k) if(deepth[MU[k].s]+deepth[MU[k].t]-2*deepth[MU[k].an] > i) {
            int _d=deepth[MU[k].s]-deepth[MU[k].an];
            if(_d > i) {
                pos[k]=fa[pos[k]];
            }
            else {
                _d=deepth[MU[k].s]-deepth[MU[k].an]+deepth[MU[k].t]-deepth[MU[k].an]-i-1;
                int _t=MU[k].t;
                for(rg int h=25;_d;--h) if(_d & (1<<h)) {
                    _t=LCA[h][_t],_d^=(1<<h);
                }
                pos[k]=_t;
            }
        }
        else pos[k]=0;
    }
    while(j <= n) {
        for(rg int k=1;k<=m;++k) if(pos[k] == w[j].num) ++w[j].ans;
        ++j;
    }
    std::sort(w+1,w+1+n,cmp);
    for(rg int i=1;i<n;++i) write(w[i].ans,' ',true);
    write(w[n].ans,'\n',true);
}

void lian() {
    for(rg int i=1;i<=m;++i) {
        if(MU[i].t >= MU[i].s) ++rt[MU[i].s],MU[i].sum=MU[i].t-MU[i].s;
        else ++lft[MU[i].s],MU[i].sum=MU[i].s-MU[i].t;
    }
    std::sort(MU+1,MU+1+m);
    std::sort(w+1,w+1+n);
    rg int j=0;
    for(rg int i=1;i<=n;++i) {
        while(j <= m) {
            if(MU[j].sum >= w[i].v) break;
            if(MU[j].s <= MU[j].t) --rt[MU[j].s];
            else --lft[MU[j].s];
            ++j;
        }
        int _d=w[i].num-w[i].v;
        if(_d > 0) w[i].ans+=rt[_d];
        _d=w[i].num+w[i].v;
        if(_d <= n) w[i].ans+=lft[_d];
    }
    std::sort(w+1,w+1+n,cmp);
    for(rg int i=1;i<n;++i) write(w[i].ans,' ',true);
    write(w[n].ans,'\n',true);
}

void s1() {
    deepth[0]=-1;
    dfs(1,0);
    for(rg int i=1;i<=m;++i) {
        ++lft[MU[i].t];
    }
    int _cnt=dfsearch(1,0);
    if(!w[1].v) w[1].ans=_cnt;
    for(rg int i=1;i<n;++i) write(w[i].ans,' ',true);
    write(w[n].ans,'\n',true);
}

int dfsearch(ci u,ci fat) {
    rg int _cnt=lft[u];
    for(rg int i=hd[u];i;i=edge[i].nxt) if(edge[i].to != fat) 
        _cnt+=dfsearch(edge[i].to,u);
    if(w[u].v == deepth[u]) w[u].ans=_cnt;
    return _cnt;
}

void deepfs(ci u,ci fat) {
    rg int _c=lft[w[u].v+deepth[u]+ZAY];
    lft[deepth[u]+ZAY]+=rt[u];
    for(rg int i=hd[u];i;i=edge[i].nxt) if(edge[i].to != fat)
        deepfs(edge[i].to,u);
    w[u].ans=lft[w[u].v+deepth[u]+ZAY]-_c;
}

void t1() {
    deepth[0]=-1;
    for(rg int i=1;i<=m;++i) ++rt[MU[i].s];
    dfs(1,0);
    deepfs(1,0);
    for(rg int i=1;i<n;++i) write(w[i].ans,' ',true);
    write(w[n].ans,'\n',true);
}

void zhengjie() {
    dfs(1,0);
    for(rg int i=1;i<=n;++i) {
        MU[i].an=ask(MU[i].s,MU[i].t);
        MU[i].sum=deepth[MU[i].s]-2*deepth[MU[i].an]+deepth[MU[i].t]+1;
        cg[MU[i].s].push_back(C(1,deepth[MU[i].s],1));
        cg[MU[i].t].push_back(C(2,deepth[MU[i].t]-MU[i].sum+1+ZAY,1));
        cg[MU[i].an].push_back(C(1,deepth[MU[i].s],-1));
        cg[fa[MU[i].an]].push_back(C(2,deepth[MU[i].t]-MU[i].sum+1+ZAY,-1));
    }
    dfirsts(1,0);
    for(rg int i=1;i<n;++i) write(w[i].ans,' ',true);
    write(w[n].ans,'\n',true);
}

void dfirsts(ci u,ci fat) {
    int _temp=lft[deepth[u]+w[u].v]+rt[deepth[u]-w[u].v+ZAY];
    rg unsigned int _s=cg[u].size();
    for(rg unsigned i=0;i<_s;++i) {
        int _ud=cg[u][i].ud;
        if(_ud == 1) {
            lft[cg[u][i].v]+=cg[u][i].tp;
        }
        else rt[cg[u][i].v]+=cg[u][i].tp;
    }
    for(rg int i=hd[u];i;i=edge[i].nxt) if(edge[i].to != fat) 
        dfirsts(edge[i].to,u);
    w[u].ans=lft[deepth[u]+w[u].v]+rt[deepth[u]-w[u].v+ZAY]-_temp;
}
```

## Summary
1、树上操作问题在单点进行加减操作时常考虑使用差分进行完成
2、根据部分分推到正解是一种非常不错的姿势
3、对于全局桶的应用：记录它对某次计算的贡献可以统计他的增量。



---

## 作者：Engulf (赞：11)

做法：线段树合并。

对于每一条路径 $(s, t)$，考虑这条路径上的点 $x$ 能否观测到这条路线上的玩家。

记 $s, t$ 的最近公共祖先为 $\rm lca$。把路径分为两段，$s \to \rm lca$ 和 $\textrm{lca} \to t$，分别考虑在这两段上的 $x$。

#### 当 $x$ 在 $s \to \rm lca$ 上时：
![](https://cdn.luogu.com.cn/upload/image_hosting/xkeoamns.png)
玩家从 $s$ 出发的，每秒走 $1$ 条边，而 $x$ 在 $w_x$ 秒时开始观测，也就是说当 $s$ 和 $x$ 的距离恰好等于 $w_x$ 时，$x$ 可以观测到这名玩家。

由于 $x$ 是 $s$ 的祖先，所以这里计算距离可以用深度作差快速计算。

记 $\textrm{dep}_i$ 为 $i$ 的深度，则 $s$ 和 $x$ 的距离就是 $\textrm{dep}_s - \textrm{dep}_x$。

此时 $x$ 能观测到玩家当且仅当 $\textrm{dep}_s - \textrm{dep}_x = w_x$。移项得 $\textrm{dep}_s = \textrm{dep}_x + w_x$。

#### 当 $x$ 在 $\textrm{lca} \to t$ 上时：
![](https://cdn.luogu.com.cn/upload/image_hosting/bj5kbsij.png)

同理可得 $s$ 到 $x$ 的距离是 $\textrm{dep}_s - \textrm{dep}_{\textrm{lca}} + \textrm{dep}_x - \textrm{dep}_{\textrm{lca}}$。

所以此时 $x$ 能观测到玩家当且仅当 $\textrm{dep}_s + \textrm{dep}_x - 2\textrm{dep}_{\textrm{lca}} = w_x$。移项得 $2\textrm{dep}_{\textrm{lca}} - \textrm{dep}_s = \textrm{dep}_x - w_x$。

---

第一段，每个节点开一棵权值线段树，往 $s\to\rm lca$ 上每个节点的线段树 $\textrm{dep}_s$ 的位置 $+1$，查询的时候就查 $\textrm{dep}_x + w_x$ 对应的值即可。

第二段同理，再开一棵权值线段树，往 $\textrm{lca} \to t$ 上每个节点的线段树 $2\textrm{dep}_{\textrm{lca}} - \textrm{dep}_s$ 的位置 $+1$，查询的时候就查 $\textrm{dep}_x - w_x$ 对应的值即可。

链修改用树上差分转为单点修改子树求和，用线段树合并实现，离线处理，把子树处理完后把子树信息全部合并到当前的根，再查询答案。实现部分并不是本题解的重点，参考 [P4556 雨天的尾巴](https://www.luogu.com.cn/problem/P4556)。

实现上注意的细节：
- $\rm lca$ 请只选择一段统计，避免重复计算。
- 查询时，不在值域内直接返回 $0$。

```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using pii = pair<int, int>;

#ifdef ONLINE_JUDGE
#define debug(...) 0
#else
#define debug(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)
#endif

const int N = 3e5 + 5;

int n, m;

int w[N];

vector<int> g[N];

int son[N], siz[N], top[N], dep[N], fa[N];

void dfs1(int u, int f) {
    dep[u] = dep[f] + 1;
    fa[u] = f;
    siz[u] = 1;
    for (auto v: g[u]) {
        if (v == f) continue;
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[v] > siz[son[u]])
            son[u] = v;
    }
}
void dfs2(int u, int tp) {
    top[u] = tp;
    if (!son[u]) return;
    dfs2(son[u], tp);
    for (auto v: g[u])
        if (!top[v])
            dfs2(v, v);
}
int lca(int x, int y) {
    while (top[x] != top[y])
        dep[top[x]] > dep[top[y]] ? x = fa[top[x]] : y = fa[top[y]];
    return dep[x] < dep[y] ? x : y;
}

int ls[N * 50], rs[N * 50], sum[N * 50], root[N][2], idx;
void modify(int &p, int l, int r, int x, int v) {
    if (!p) p = ++idx;
    sum[p] += v;
    if (l == r) return;
    int mid = l + r >> 1;
    x <= mid ? modify(ls[p], l, mid, x, v) : modify(rs[p], mid + 1, r, x, v);
}
int query(int p, int l, int r, int x) {
    if (!p) return 0;
    if (l == r) return sum[p];
    int mid = l + r >> 1;
    return x <= mid ? query(ls[p], l, mid, x) : query(rs[p], mid + 1, r, x);
}
int merge(int x, int y, int l, int r) {
    if (!x || !y) return x + y;
    if (l == r) {sum[x] += sum[y]; return x;}
    int mid = l + r >> 1;
    ls[x] = merge(ls[x], ls[y], l, mid);
    rs[x] = merge(rs[x], rs[y], mid + 1, r);
    sum[x] = sum[ls[x]] + sum[rs[x]];
    return x;
}

int ans[N];

void dfs(int u, int f) {
    for (auto v: g[u]) {
        if (v == f) continue;
        dfs(v, u);
        root[u][0] = merge(root[u][0], root[v][0], 1, n);
        root[u][1] = merge(root[u][1], root[v][1], -n, 2 * n);
    }
    ans[u] = (dep[u] + w[u] > n ? 0 : query(root[u][0], 1, n, dep[u] + w[u])) + query(root[u][1], -n, 2 * n, dep[u] - w[u]);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;

    for (int i = 1, u, v; i < n; i++) {
        cin >> u >> v;
        g[u].emplace_back(v);
        g[v].emplace_back(u);
    }

    for (int i = 1; i <= n; i++) cin >> w[i];

    dfs1(1, 0), dfs2(1, 1);

    for (int i = 1, s, t; i <= m; i++) {
        cin >> s >> t;
        int lc = lca(s, t);
        modify(root[s][0], 1, n, dep[s], 1);
        modify(root[lc][0], 1, n, dep[s], -1);
        modify(root[t][1], -n, 2 * n, 2 * dep[lc] - dep[s], 1);
        modify(root[fa[lc]][1], -n, 2 * n, 2 * dep[lc] - dep[s], -1);
    }

    dfs(1, 0);

    for (int i = 1; i <= n; i++)
        cout << ans[i] << " ";

    return 0;
}
```

---

## 作者：mulberror (赞：9)

# 闲话
为了理清这道题目的思路，我是边写博客边做题的，qwq。
# 题目链接  
[洛谷](https://www.luogu.org/problemnew/show/P1600)

# 题解  
首先对变量进行声明
```cpp
dep[i]  表示i号节点的深度，是到根节点的深度
w[i]    表示i号观测点观测的时间
dfn[i]  表示i号点的dfn序
sz[i]   表示i号点的子树大小
```

---
![p1](https://s2.ax1x.com/2019/05/01/EY3shT.png)  
以上图为例，蓝色点表示一个玩家的起点和终点。  
不妨先假设左边的点是起点，右边的点是终点，分别用$s$和$t$来表示   
那么可能对答案产生贡献的点一定是在这个从$s$到$t$上的观测点。  
记观测点为$g$。  
对这个问题进行分类讨论  

---
## Case 1：观测点在起点到$LCA$的路径上  
![p2](https://s2.ax1x.com/2019/05/01/EY8HI0.png)  
我们把这个情况记为观测点在$A$种路线上。  
如果这个观测点能够观测到这个起点，那么一定满足以下的式子

$$dep[s]-dep[g]=w[g]$$

可以从图中观察到，$dep[s]-dep[g]$的值就是$s$到观测点$g$的时间长度。  
为什么不需要$±1$，是因为时间一开始是从$0$开始计数的。  
换句话说，就是实际的通过时间就是通过边的数量或者是路径上经过点的数量$-1$。  
对于现有式子进行变形。  

$$dep[s]=dep[g]+w[g]$$

可以发现等式的右边是题目给定的定值。  
那么问题就变成了对于每一个在$A$类路径上的观测点，起点的深度等于$dep[g]+w[g]$的个数。  
暴力求解这个问题的复杂度差不多是$n\times (dep[g]+w[g]-dep[s])$，明显过不了，（别忘了后面还有一个情况需要讨论）  
我们可以把这个问题变一下，变成在以$g$为根的子树内，有多少个起点满足以上的性质。  
转换成子树的问题就可以用树链剖分维护了。  
**先扯一个常识**：在树上，一棵以$u$为根节点的子树的区间是$[dfn[u],sz[u]+dfn[u]-1]$  
问题转化成了：在区间$[dfn[u],sz[u]+dfn[u]-1]$中有多少个深度等于$dep[g]+w[g]$的起点的个数。  
可以对每一个深度建立一棵线段树。（动态开点，否则会MT飞掉）  
那么问题就变成了在深度为$dep[g]+w[g]$的线段树中在区间$[dfn[u],sz[u]+dfn[u]-1]$中有多少个起点。 
如果暴力修改区间并且查询，修改的复杂度是$O(nlog^2n)$，来一条链就爆炸了。   
考虑树上差分，其实这个东西我也想了很久，也不知道为什么可以差分，但是其实挺简单的。 

![](https://s2.ax1x.com/2019/05/02/EYqux1.png)

### 为什么可以差分？
差分是什么？  
差分只的前一个答案和后一个答案之间的差值。  
在树上也就变成了祖先和儿子之间的关系。  
先不要管线段树这个东西，会妨碍我们思考。  
因为我们都知道，如果用差分计算一棵树上的答案，那么就是这颗树里面所有差分值全部$+$起来。  
在这里因为路径$s->lca$的答案只有$s$这个起点有贡献。  
模拟一下，如果是$s$的子树，很明显这个答案不会产生贡献。
如果是$s->lca$的链上，这个答案会对$g$贡献$+1$。
如果是lca以上的祖先，那么就在$lca$上打一个$-1$的标记。  
抽象的概念就是：在这个深度上只有$s->lca$这一段区间的答案可以$+1$。  
那么套一个线段树就可以了。  

## Case 2：观测点在$LCA$到终点的路径上  
下面一半就简单了，图我就不画了。  
得到产生贡献的式子
$$dep[s]+dep[g]-2\times dep[lca]=w[g]$$
前一半的式子其实就是求$s->g$的最短距离。  
推导得到

$$dep[s]-2dep[lca]=w[g]-dep[g]$$

等式右边又是一个定值。  
仿照上面的套路：对于深度建立线段树，打树上差分标记。  
总的时间复杂度是：$O(nlogn)$  

**tips**  
* Case 2中的差值可能<0，需要整体右移，查询的时候也要整体右移，大小自己控制。  
* 不要两次都把$-1$的标记都打在$lca$上，这样会减掉$lca$的答案，有一个标记打在$lca$的父亲上。  
* 做完一遍后要请空数组。  

---
# Code
```cpp
#include <bits/stdc++.h>
using namespace std;
namespace IOstream {
    #define gc getchar
    template <typename T> inline void read(T &x) {
        x = 0; T fl = 1; char c = 0;
        for (; c < '0' || c > '9'; c = gc()) if (c == '-') fl = -1;
        for (; c >= '0' && c <= '9'; c = gc()) x = (x << 1) + (x << 3) + (c ^ 48);
        x *= fl;  
    }
    template <typename T> inline void write(T x) {
        if (x < 0) putchar('-'), x *= -1;
        if (x > 9) write(x / 10);
        putchar(x % 10 + '0');
    }
    template <typename T> inline void writeln(T x) { write(x); puts(""); }
    template <typename T> inline void writesp(T x) { write(x); putchar(' '); }
    #undef gc
} using namespace IOstream;
const int N = 3e6 + 5;
struct edge {
    int to, nt;
} E[N << 1];
struct pl {
    int s, t, lca;
} a[N];
int H[N];
int sz[N], fa[N], dep[N], son[N], top[N], dfn[N], rt[N];
int ecnt, n, m, __dfn = 0; 
int w[N], ans[N];
void add_edge(int u, int v) {
    E[++ ecnt] = (edge) {v, H[u]}; 
    H[u] = ecnt;
}
void dfs1(int u, int ft = 0) {
    fa[u] = ft; sz[u] = 1; dep[u] = dep[ft] + 1;
    int maxson = -1; 
    for (int e = H[u]; e; e = E[e].nt) {
        int v = E[e].to; 
        if (v == fa[u]) continue;
        dfs1(v, u);
        sz[u] += sz[v];
        if (sz[v] > maxson) maxson = sz[v], son[u] = v;
    }
}
void dfs2(int u, int tp = 1) {
    top[u] = tp; 
    dfn[u] = ++ __dfn;
    if (!son[u]) return;
    dfs2(son[u], top[u]);
    for (int e = H[u]; e; e = E[e].nt) {
        int v = E[e].to;
        if (v == fa[u] || v == son[u]) continue;
        dfs2(v, v);
    }
}
int LCA(int u, int v) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        u = fa[top[u]];
    }
    return dep[u] < dep[v] ? u : v;
}
namespace seg {
    int tot;
    struct node {
        int lc, rc, s;
    } tr[N * 10];
    void clear() { tot = 0; memset(tr, 0, sizeof(tr)); }
    void upd(int &nod, int l, int r, int k, int val) {
        if (!k) return;
        if (!nod) nod = ++ tot;
        tr[nod].s += val;
        if (l == r) return;
        int mid = (l + r) >> 1;
        if (k <= mid) upd(tr[nod].lc, l, mid, k, val);
        else upd(tr[nod].rc, mid + 1, r, k, val);
    }
    int query(int nod, int l, int r, int ql, int qr) {
        if (!nod) return 0;
        if (ql <= l && r <= qr) return tr[nod].s;
        int mid = (l + r) >> 1, res = 0;
        if (ql <= mid) res += query(tr[nod].lc, l, mid, ql, qr);
        if (qr > mid) res += query(tr[nod].rc, mid + 1, r, ql, qr);
        return res; 
    }
}
signed main() {
    read(n); read(m);
    for (int i = 1, u, v; i < n; i ++) {
        read(u); read(v); 
        add_edge(u, v); add_edge(v, u);
    }
    dep[0] = 0; dfs1(1);  
    dfs2(1); 
    for (int i = 1; i <= n; i ++) read(w[i]);
    for (int i = 1; i <= m; i ++) {
        read(a[i].s); read(a[i].t);
        a[i].lca = LCA(a[i].s, a[i].t);
    }
    seg::clear(); memset(rt, 0, sizeof(rt));
    for (int i = 1; i <= m; i ++) { 
        int root = dep[a[i].s];
        seg::upd(rt[root], 1, n, dfn[a[i].s], 1);
        seg::upd(rt[root], 1, n, dfn[fa[a[i].lca]], -1);
    } 
    for (int i = 1; i <= n; i ++) 
        ans[i] += seg::query(rt[dep[i] + w[i]], 1, n, dfn[i], sz[i] + dfn[i] - 1);
    seg::clear(); memset(rt, 0, sizeof(rt));
    for (int i = 1; i <= m; i ++) {
        int root = dep[a[i].s] - dep[a[i].lca] * 2 + 2 * n;
        seg::upd(rt[root], 1, n, dfn[a[i].t], 1);
        seg::upd(rt[root], 1, n, dfn[a[i].lca], -1);
    } 
    for (int i = 1; i <= n; i ++) 
        ans[i] += seg::query(rt[w[i] - dep[i] + 2 * n], 1, n, dfn[i], sz[i] + dfn[i] - 1);
	for (int i = 1; i <= n; i ++) 
        writesp(ans[i]);
    return 0;
}
```

---

## 作者：_ChongYun_ (赞：6)

### Solution

我们可以将玩家 $i$ 跑步的路线分成两段：$s_i\rightarrow\mathrm{LCA}(s_i,t_i)$ 和 $\mathrm{LCA}(s_i,t_i)\rightarrow t_i$。

设 $\mathrm{dep}_i$ 表示树上 $i$ 号节点的深度，$\mathrm{fa}_i$ 表示树上 $i$ 号节点的父节点。

若节点 $x$ 可以观察到玩家 $i$ 的行动，当且仅当：

- 节点 $x$ 在 $s_i\rightarrow\mathrm{LCA}(s_i,t_i)$ 的路径上，且有 $\mathrm{dep}_{s_i}-\mathrm{dep}_x=w_x$

- 节点 $x$ 在 $\mathrm{LCA}(s_i,t_i)\rightarrow t_i$ 的路径上，且有 $\mathrm{dep}_{s_i}+\mathrm{dep}_x-2 \times \mathrm{dep}_{\mathrm{LCA}(s_i,t_i)}=w_x$

两者互不干涉，于是分成两类讨论，答案相加即可。

如果节点 $x$ 在 $s_i\rightarrow\mathrm{LCA}(s_i,t_i)$ 的路径上，那么移项得 $\mathrm{dep}_{s_i}=\mathrm{dep}_x+w_x$。这样做相当于在 $s_i\rightarrow\mathrm{LCA}(s_i,t_i)$ 的路径上新增一个物品 $\mathrm{dep}_{s_i}$。询问每一个点 $x$ 上的物品 $\mathrm{dep}_x+w_x$ 的数量。通过树上差分，我们可以将其视作：该物品在 $s_i$ 处出现，并在 $\mathrm{fa}_{\mathrm{LCA}(s_i,t_i)}$ 处消失。我们称其为第一种情况。

如果节点 $x$ 在 $\mathrm{LCA}(s_i,t_i)\rightarrow t_i$ 的路径上，那么移项得 $\mathrm{dep}_{s_i}-2 \times \mathrm{dep}_{\mathrm{LCA}(s_i,t_i)}=w_x-\mathrm{dep}_x$。这样做相当于在 $\mathrm{LCA}(s_i,t_i)\rightarrow t_i$ 的路径上新增一个物品 $\mathrm{dep}_{s_i}-2 \times \mathrm{dep}_{\mathrm{LCA}(s_i,t_i)}$。询问每一个点 $x$ 上的物品 $w_x-\mathrm{dep}_x$ 的数量。通过树上差分，我们可以将其视作：该物品在 $t_i$ 处出现，并在 $\mathrm{LCA}(s_i,t_i)$ 处消失。我们称其为第二种情况。

对于每一次询问，我们存下每一个物品出现和消失的位置。与此同时，记录一个桶 $\mathrm{cnt}_{0/1,i}$ 表示第一种情况和第二种情况下的类型 $i$ 物品的数量。

考虑 DFS 遍历整棵树。递归到一个节点 $x$，先存下目前的 $\mathrm{cnt}_{0,\mathrm{dep}_x+w_x}$ 和 $\mathrm{cnt}_{1,w_x-\mathrm{dep}_x}$，然后查看 $x$ 位置出现或消失的物品并更新 $\mathrm{cnt}_{0/1}$，继续递归节点 $x$ 的子节点。

递归完后，现在的 $\mathrm{cnt}_{0,\mathrm{dep}_x+w_x}$ 和之前的 $\mathrm{cnt}_{0,\mathrm{dep}_x+w_x}$ 的差值， 现在的 $\mathrm{cnt}_{1,w_x-\mathrm{dep}_x}$ 和之前的 $\mathrm{cnt}_{1,w_x-\mathrm{dep}_x}$ 的差值就是两种情况分别的答案。

### Code


```cpp
/* ChongYun */
#include<bits/stdc++.h>
#define int long long 
#define fir first
#define sec second
using namespace std;
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	return x*f;
}
int mov(int x){ return x+300001; }
int n,m,w[300005];
int s[300005],t[300005];
struct Edge{
	int to,nxt,val;
}e[300005<<1];
int hd[300005],ecnt=0;
void Link(int x,int y){
	++ecnt;
	e[ecnt].to=y;
	e[ecnt].nxt=hd[x];
	hd[x]=ecnt;
	return ;
} 
int fath[300005];
int dep[300005],dp[300005][21];
void initdfs(int x,int fa){
    fath[x]=fa; dep[x]=dep[fa]+1; dp[x][0]=fa;
	for(int i=1;(1<<i)<=dep[x];i++) dp[x][i]=dp[dp[x][i-1]][i-1];
	for(int i=hd[x];i!=0;i=e[i].nxt){
		int y=e[i].to;
		if(y==fa) continue;
		initdfs(y,x);
	}
	return ;
} 
int LCA(int x,int y){
	if(dep[y]<dep[x]) swap(x,y);
	for(int i=20;i>=0;i--){
		if(dep[dp[y][i]]>=dep[x]) y=dp[y][i];
	}
	if(x==y) return x;
	for(int i=20;i>=0;i--){
		if(dp[x][i]!=dp[y][i]){
			x=dp[x][i];
			y=dp[y][i];
		}
	}
	return dp[x][0];
}
int cnt[2][300005<<1];
vector<pair<int,int> > add[300005],del[300005];
int ans[300005];
void dfs(int x,int fa){
    int now0=cnt[0][dep[x]+w[x]];
    int now1=cnt[1][mov(w[x]-dep[x])];
    for(auto now:add[x]) ++cnt[now.fir][now.sec];
    for(auto now:del[x]) --cnt[now.fir][now.sec];
    for(int i=hd[x];i!=0;i=e[i].nxt){
        int y=e[i].to;
        if(y==fa) continue;
        dfs(y,x);
    }
    ans[x]=cnt[0][dep[x]+w[x]]-now0+cnt[1][mov(w[x]-dep[x])]-now1;
    return ;
}
signed main(){
    n=read(); m=read();
    for(int i=1;i<n;i++){
        int u=read(),v=read();
        Link(u,v);
        Link(v,u);
    }
    initdfs(1,0);
    for(int i=1;i<=n;i++) w[i]=read();
    for(int i=1;i<=m;i++){
        s[i]=read(); t[i]=read();
        int qwq=LCA(s[i],t[i]);
        add[s[i]].push_back({0,dep[s[i]]});
        del[fath[qwq]].push_back({0,dep[s[i]]});
        add[t[i]].push_back({1,mov(dep[s[i]]-2*dep[qwq])});
        del[qwq].push_back({1,mov(dep[s[i]]-2*dep[qwq])});
    }
    dfs(1,0);
    for(int i=1;i<=n;i++) printf("%lld ",ans[i]);
    printf("\n");
    return 0;
}
```

---

## 作者：lzyqwq (赞：6)

**[P1600 [NOIP2016 提高组] 天天爱跑步](https://www.luogu.com.cn/problem/P1600)**

扫描线选手秒了。

> - 给出 $n$ 个点的树和 $m$ 条路径，每个点有参数 $w_i$，对于每个点 $i$ 求出有多少条路径上的第 $w_i+1$ 个点是 $i$。
> - $n,m\le 3\times 10^5$。

重剖。考虑维护一个平面 $P_1$，定义一个点 $(x,y)$ 的权值为点 $x$ 在多少条路径上是第 $y$ 个点。为了配合重剖，把 $x$ 先映射到 $\text{dfn}$ 序上，即：$(x,y)$ 的权值表示 $\text{dfn}_u=x$ 的点 $u$ 在多少条路径上是第 $y$ 个点。

考虑维护前 $i$ 条路径对应的平面信息，加入一条路径就做出相应的修改。

显然，若一条路径上的点 $\text{dfn}$ 序依次为 $p_1,\dots,p_k$，则所有 $(p_i,i)$ 的权值都要 $+1$。

注意到 $i$ 是连续的排名，而 $\text{dfn}$ 序被剖分成了 $\mathcal{O}(\log n)$ 个连续的区间，考虑每一段重链的修改。可以发现每一次修改相当于给一条斜率为 $1$ 或 $-1$ 的线段上的整点权值整体 $+1$。

现在问题变成 $\mathcal{O}(m\log n)$ 次斜线加、$\mathcal{O}(n)$ 次单点查。分别算斜率为 $1$ 和 $-1$ 的直线的贡献。以斜率为 $1$ 为例。

注意到每条斜线的截距是唯一的。因此考虑一个新平面 $
P_2$，点 $(x,y)$ 的权值表示 $P_1$ 中 $(x,x+y)$ 的权值。那么相当于在 $P_2$ 上横线加、单点查询。把横线看成退化的矩形容易扫描线 + BIT 维护。

注意截距可能负，要加一个偏移量。

时间复杂度为 $\mathcal{O}\left(m\log ^2n\right)$，空间复杂度为 $\mathcal{O}(m\log n)$。她过了。


```cpp
#include <bits/stdc++.h>
using namespace std; const int N = 3e5, M = 6e5;
int n, m, w[N], f[N], h[N], s[N], d[N], t[N], dfn[N], cnt, ans[N], id[N];
vector<int> g[N], q1[M], q2[M];
struct node { int l, r; };
struct adds { int l, r, v; }; vector<adds> g1[M], g2[M];
struct BIT {
	int a[N]; void U(int x, int v) { for (; x < N; x += x & -x) a[x] += v; }
	int Q(int x) { int r = 0; for (; x; x -= x & -x) r += a[x]; return r; }
	void F(int l, int r, int v) { U(l, v); U(r + 1, -v); }
} t1, t2;
void dfs(int u) {
	s[u] = 1;
	for (int v : g[u])
		if (v != f[u]) {
			d[v] = d[u] + 1; f[v] = u; dfs(v);
			s[u] += s[v]; if (s[v] > s[h[u]]) h[u] = v;
		}
}
void DFS(int u, int p) {
	t[u] = p; dfn[u] = ++cnt; id[cnt] = u; if (h[u]) DFS(h[u], p);
	for (int v : g[u]) if (v != f[u] && v != h[u]) DFS(v, v);
}
void add1(int x, int l, int r, int v) {
	g1[x].emplace_back(adds{l, r, v});
	g1[x + 1].emplace_back(adds{l, r, -v});
}
void add2(int x, int l, int r, int v) {
	g2[x].emplace_back(adds{l, r, v});
	g2[x + 1].emplace_back(adds{l, r, -v});
}
void path(int u, int v) {
	vector<node> x, y;
	while (t[u] != t[v])
		if (d[t[u]] > d[t[v]])
			x.emplace_back(node{dfn[t[u]], dfn[u]}), u = f[t[u]];
		else y.emplace_back(node{dfn[t[v]], dfn[v]}), v = f[t[v]];
	if (d[u] < d[v]) y.emplace_back(node{dfn[u], dfn[v]});
	else x.emplace_back(node{dfn[v], dfn[u]});
	reverse(y.begin(), y.end());
	int cnt = 0;
	for (auto [l, r] : x) {
		add1(r + cnt, l, r, 1);
		cnt += r - l + 1;
	}
	for (auto [l, r] : y) {
		add2(n + cnt - l, l, r, 1);
		cnt += r - l + 1;
	}
}
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1, u, v; i < n; ++i)
		scanf("%d%d", &u, &v), g[u].emplace_back(v), g[v].emplace_back(u);
	dfs(1); DFS(1, 0);
	for (int i = 1; i <= n; ++i) {
		cin >> w[i]; q1[dfn[i] + w[i]].emplace_back(dfn[i]);
		q2[n + w[i] - dfn[i]].emplace_back(dfn[i]);
	}
	for (int i = 1, s, t; i <= m; ++i) scanf("%d%d", &s, &t), path(s, t);
	for (int i = 1; i < M; ++i) {
		for (auto [l, r, v] : g1[i]) t1.F(l, r, v);
		for (int u : q1[i]) ans[id[u]] += t1.Q(u);
	}
	for (int i = 1; i < M; ++i) {
		for (auto [l, r, v] : g2[i]) t2.F(l, r, v);
		for (int u : q2[i]) ans[id[u]] += t2.Q(u);
	}
	for (int i = 1; i <= n; ++i) printf("%d ", ans[i]); return 0;
}
```
但我们还是认为她是过不了的。考虑到修改的形式被我们强化了。其实可以对同一条横线上的点权差分，则变成单点修改、某一条横线的前缀查询。

考虑按照修改的 $x$ 坐标从小到大扫描线，维护每一条横线当前的前缀和，则变成单点修改。数组维护，查询只需要访问对于截距的前缀和数组即可。

时空复杂度均为 $\mathcal{O}(m\log n)$。



```cpp
#include <bits/stdc++.h>
#define eb emplace_back
using namespace std; const int N = 3e5, M = 6e5;
int n, m, w[N], f[N], h[N], s[N], d[N], t[N], dfn[N], cnt, ans[N], id[N], sum[M], q1[N], q2[N];
vector<int> g[N]; struct node { int l, r; }; vector<node> g1[M], g2[M];
void dfs(int u) {
	s[u] = 1;
	for (int v : g[u])
		if (v != f[u]) {
			d[v] = d[u] + 1; f[v] = u; dfs(v);
			s[u] += s[v]; if (s[v] > s[h[u]]) h[u] = v;
		}
}
void DFS(int u, int p) {
	t[u] = p; dfn[u] = ++cnt; id[cnt] = u; if (h[u]) DFS(h[u], p);
	for (int v : g[u]) if (v != f[u] && v != h[u]) DFS(v, v);
}
void add1(int x, int l, int r, int v) { g1[l].eb(node{x, v}); g1[r + 1].eb(node{x, -v}); }
void add2(int x, int l, int r, int v) { g2[l].eb(node{x, v}); g2[r + 1].eb(node{x, -v}); }
void path(int u, int v) {
	vector<node> x, y;
	while (t[u] != t[v])
		if (d[t[u]] > d[t[v]]) x.eb(node{dfn[t[u]], dfn[u]}), u = f[t[u]];
		else y.eb(node{dfn[t[v]], dfn[v]}), v = f[t[v]];
	if (d[u] < d[v]) y.eb(node{dfn[u], dfn[v]}); else x.eb(node{dfn[v], dfn[u]});
	reverse(y.begin(), y.end()); int cnt = 0;
	for (auto [l, r] : x) add1(r + cnt, l, r, 1), cnt += r - l + 1;
	for (auto [l, r] : y) add2(n + cnt - l, l, r, 1), cnt += r - l + 1;
}
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1, u, v; i < n; ++i) scanf("%d%d", &u, &v), g[u].eb(v), g[v].eb(u);
	dfs(1); DFS(1, 0);
	for (int i = 1; i <= n; ++i)
		scanf("%d", &w[i]), q1[dfn[i]] = dfn[i] + w[i], q2[dfn[i]] = n + w[i] - dfn[i];
	for (int i = 1, s, t; i <= m; ++i) scanf("%d%d", &s, &t), path(s, t);
	for (int i = 1; i <= n; ++i) {
		for (auto [x, v] : g1[i]) sum[x] += v; ans[id[i]] = sum[q1[i]];
	}
	memset(sum, 0, sizeof sum);
	for (int i = 1; i <= n; ++i) {
		for (auto [x, v] : g2[i]) sum[x] += v; ans[id[i]] += sum[q2[i]];
	}
	for (int i = 1; i <= n; ++i) printf("%d ", ans[i]); return 0;
}
```

---

## 作者：_ctz (赞：4)


[更好的阅读体验$QwQ$](https://ctz45562.github.io/2019/02/26/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P1600-%E3%80%90%E5%A4%A9%E5%A4%A9%E7%88%B1%E8%B7%91%E6%AD%A5%E3%80%91/)

[传送门](https://www.luogu.org/problemnew/show/P1600)

来一种$O(nlogn)$的~~毒瘤~~做法。

首先介绍一下主角：$dsu\ on\ tree$ 。其原理是树上启发式合并。它支持$O(nlogn)$无修改子树信息统计。

实现：树剖划分出轻重儿子。对于某个节点，先递归处理轻儿子，并清除轻子树的影响。然后处理重儿子，保留重子树的影响。再次统计轻子树的影响，就能得到该点整个子树的信息。

伪代码：

```cpp
void dfs(int x,bool remain){
    //remain表示是否保留该点子树的信息
    int f=fa[x],s=son[x];//s为重儿子
	for(int i=h[x];i;i=e[i].pre){
        int y=e[i].to;
		if(x!=f&&x!=s)dfs(y,0);//递归处理轻儿子，删除信息
    }
    if(s)dfs(s,1);//递归处理重儿子并保留信息
    count(x);//这里的count是统计x的轻子树的信息
    ans[x]=...;//记录答案
    if(!remain)clear(x);//清除x整个子树的影响
}
```

复杂度：每个点到根节点的路径被剖成了最多$logn$条重链，而其中每个轻边都会使该点被用至多$O(n)$的时间统计一次，只要单点的信息统计与删除是$O(1)$的，总复杂度就为$O(nlogn)$

参考：

http://www.cnblogs.com/zzqsblog/p/6146916.html

https://www.cnblogs.com/zcysky/p/6822395.html

回到这个题上。对于每一个玩家$(x->y)$，我们可以把它分成两半：$(x->lca(x,y))+(lca(x,y)->y)$，因为前者是往上跑，后者是往下跑，分开好处理。

放个图：

![](https://cdn.luogu.com.cn/upload/pic/52786.png )

红色的数字是跑到该点的时间。

（以下用$deep$代表点的深度）

先处理$(x->lca(x,y))$

对于往上跑的路径来说，只要满足$deep[x]-deep[i]=w[i]$，且该路径能覆盖到$i$，$i$就能观测到该名玩家。

即$deep[i]+w[i]=deep[x]$

再处理$(lca(x,y)->y)$

如图容易发现：从点$y$往上跳，每跳一步，时间就会$-1$，而一开始时间为$dis(x,y)$。

则一个点$i$能观测到$y$的条件是：

$deep[y]-deep[i]=dis(x,y)-w[i]$且该路径也要覆盖$i$。

其中$dis(x,y)=deep[x]+deep[y]-2*deep[lca(x,y)]$

移项整理得：

$deep[x]-2*deep[lca(x,y)]=w[i]-deep[i]$

综上，运用树上差分的思想，对于每个玩家$(x->y)$，用两个数组$up$和$down$：

- 将点$x$的$up$插入一个$deep[x]$。

- 将点$y$的$down$插入一个$deep[x]-2*deep[lca(x,y)]$。

- $lca(x,y)$会统计两遍该路径，在$up$中打上删除$deep[x]$的标记

- 为了保证路径不覆盖的点不会统计，将$fa[lca(x,y)$]打上删除$deep[x]-2*deep[lca(x,y)]$的标记。

对于一个点$i$，统计其子树的$up$、$down$所有插入过的数，答案即为$up$中$(deep[i]+w[i])$的数量加上$down$中$(w[i]-deep[i])$的数量。

怎么统计呢？$dsu\ on\ tree$就出场了！直接统计就好了。

时间复杂度：每位玩家最多影响四个点，均摊下来单点统计还是$O(1)$的，总复杂度$O(nlogn)$。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>

#define maxn 300005
#define inf 0x3f3f3f
#define pn putchar('\n')
#define px(x) putchar(x)
#define ps putchar(' ')
#define pd puts("======================")
#define pj puts("++++++++++++++++++++++")

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
template<typename T>
inline T read(){
	T x=0;
	int y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
int h[maxn],w[maxn],top[maxn],deep[maxn],fa[maxn],siz[maxn],son[maxn],num,n,m,ans[maxn];
bool vis[maxn];
int upi[maxn];
vector<int>doi[maxn],dod[maxn],upd[maxn];
//upi：up insert，向上路径的插入。因为该插入只会插入某个点的deep，所以压成了普通的数组
//upd：up delete，向上路径的删除
//doi、dod同理
struct edge{
	int pre,to;
}e[maxn<<1];
inline void add(int from,int to){
	e[++num].pre=h[from],h[from]=num,e[num].to=to;
}
struct Tree_Chain_Split{
	void dfs1(int node=1){
		siz[node]=1;
		for(register int i=h[node];i;i=e[i].pre){
			int x=e[i].to;
			if(!siz[x]){
				fa[x]=node,deep[x]=deep[node]+1;
				dfs1(x);
				if(siz[x]>siz[son[node]])son[node]=x;
				siz[node]+=siz[x];	
			}
		}
	}
	void dfs2(int node=1){
		vis[node]=1;
		if(son[node]){
			top[son[node]]=top[node];
			dfs2(son[node]);
			for(register int i=h[node];i;i=e[i].pre){
				int x=e[i].to;
				if(!vis[x]){
					top[x]=x;
					dfs2(x);
				}
			}
		}
	}
	int lca(int x,int y){
		while(top[x]!=top[y]){
			if(deep[top[x]]<deep[top[y]])swap(x,y);
			x=fa[top[x]];
		}
		return deep[x]<deep[y]?x:y;
	}
}tcs;
//树链剖分，顺便用的树剖的lca
int upcnt[maxn],CNT[maxn<<1],*downcnt=&CNT[maxn];
//upcnt是向上路径统计数组，downcnt反之。两种路径统计依据不同，所以分开
//因为w[i]-deep[i]可能为负数，所以用了指针小技巧使downcnt能使用负数下标
bool in[maxn];
//用于dsu on tree的数组。标记上的点在统计子树信息时不会访问该点的子树（见count函数）
void count(int node){
	int f=fa[node];
	for(register int i=h[node];i;i=e[i].pre){
		int x=e[i].to;
		if(x!=f&&!in[x])count(x);
	}
	upcnt[deep[node]]+=upi[node];
	for(register int i=0;i<upd[node].size();++i)
		--upcnt[upd[node][i]];
	for(register int i=0;i<doi[node].size();++i)
		++downcnt[doi[node][i]];
	for(register int i=0;i<dod[node].size();++i)
		--downcnt[dod[node][i]];
}//统计信息
void clear(int node){
	int f=fa[node];
	for(register int i=h[node];i;i=e[i].pre){
		int x=e[i].to;
		if(x!=f)clear(x);
	}
	upcnt[deep[node]]-=upi[node];
	for(register int i=0;i<upd[node].size();++i)
		++upcnt[upd[node][i]];
	for(register int i=0;i<doi[node].size();++i)
		--downcnt[doi[node][i]];
	for(register int i=0;i<dod[node].size();++i)
		++downcnt[dod[node][i]];
}
void dfs(int node=1,bool remain=0){
	int s=son[node],f=fa[node];
	if(s){
		for(register int i=h[node];i;i=e[i].pre){
			int x=e[i].to;
			if(x!=s&&x!=f)dfs(x,0);
		}
		dfs(s,1);
		in[s]=1;//count时不会统计上它的重子树
	}
	count(node);//统计轻儿子的信息
	if(deep[node]+w[node]<=n)ans[node]=upcnt[deep[node]+w[node]];
    //判一下不能越界
	ans[node]+=downcnt[w[node]-deep[node]];
    //获取答案
	in[s]=0;//一定要清掉标记
	if(!remain)clear(node);//清除整个子树的信息
}
void init(){
	while(m--){
		int a=read(),b=read(),l=tcs.lca(a,b);
		++upi[a];
		doi[b].push_back(deep[a]-(deep[l]<<1));
		upd[l].push_back(deep[a]);
		dod[fa[l]].push_back(deep[a]-(deep[l]<<1));
	}
}//读入每名玩家并处理
int main(){
	n=read(),m=read();
	for(register int i=1;i<n;++i){
		int a=read(),b=read();
		add(a,b),add(b,a);
	}
	for(register int i=1;i<=n;++i)
		w[i]=read();
	tcs.dfs1(),tcs.dfs2();
	init(),dfs();
	for(register int i=1;i<=n;++i)
		printf("%d ",ans[i]);
}

```

码量确实有点大。不过$dsu\ on\ tree$在某些题中还是很高效的$QwQ$。

---

## 作者：I_AM_CIMOTA (赞：4)

讲一种树上差分+线段树合并的做法。

节点 $i$ 的观察员能观察到某个玩家 $j$ 的条件是：

1. 节点 $i$ 在 $s_j$ 到 $t_j$ 的路径上；
2. $dis(i,s_j)=w_i$。

我们先考虑一种最简单的情况：$s_j$ 为 $t_j$ 的后代。

此时条件2变为：$h_{s_j}-h_i=w_i$，即 $h_{s_j}=h_i+w_i$。

可以在遍历到 $s_j$ 时把 $h_{s_j}$ 加入线段树，在 $i$ 处查询 $h_i+w_i$，再在 $fa(t_j)$ 处减掉贡献就行了。

现在，考虑如何统计另一种： $s_j$ 为 $t_j$ 的祖先。

这种情况稍微有些不同，因为只能在 $t_j$ 处加入线段树，在 $s_j$ 处减掉贡献。

还是写出式子：$h_i-h_{s_j}=w_i$，即 $h_{s_j}=h_i-w_i$。

于是我们就可以在 $t_j$ 处加入 $h_{s_j}$，在 $i$ 处查询 $h_i-w_i$，再在 $fa(s_j)$ 处减掉。

最后，还有 $s_j$ 和 $t_j$ 不构成祖先后代关系的情况。

求出 $L=lca(s_j,t_j)$，在 $s_j$ 和 $t_j$ 处都将对应信息加入线段树，在 $fa(L)$ 处和 $L$ 处分别减掉 $s_j$ 和 $t_j$ 的贡献就可以了。


注意：在 $t_j$ 的式子有所改变，变成了$(h_{s_j}-h_L)+(h_i-h_L)=w_i$，即 $2h_L-h_{s_j}=h_i-w_i$。

第三种情况可以包含前两种，所以我代码就没有分讨，那么这道题到此也就结束了。
```cpp
#include <bits/stdc++.h>
#define PII pair<int,int>
using namespace std;

const int N=3e5+5,M=1e7+5;
struct SGT{
    int ls,rs,sum;
}t[M];
int n,m,UP,tot,ans[N],w[N],h[N],path[N][30],rt1[N],rt2[N];
vector<int>g[N];
vector<PII>diff1[N],diff2[N];

void pre(int u,int fth){
    h[u]=h[fth]+1,path[u][0]=fth;
    for(int i=1;(1<<i)<=h[u];i++)path[u][i]=path[path[u][i-1]][i-1];
    for(int v:g[u])if(v!=fth)pre(v,u);
}

int lca(int x,int y){
    if(x==y)return x;
    if(h[x]>h[y])swap(x,y);
    for(int i=20;i>=0;i--)if(h[x]+(1<<i)<=h[y])y=path[y][i];
    if(x==y)return x;
    for(int i=20;i>=0;i--)if(path[x][i]!=path[y][i])x=path[x][i],y=path[y][i];
    return path[x][0];
}

int go(int x,int k){
    for(int i=20;i>=0;i--)if(k>>i&1)x=path[x][i];
    return x;
}

void up(int u){t[u].sum=t[t[u].ls].sum+t[t[u].rs].sum;}

int merge(int u,int v,int l,int r){
    if(!u||!v)return u|v;
    if(l==r){t[u].sum+=t[v].sum;return u;}
    int mid=(l+r)>>1;
    t[u].ls=merge(t[u].ls,t[v].ls,l,mid);
    t[u].rs=merge(t[u].rs,t[v].rs,mid+1,r);
    up(u);
    return u;
}

void mdf(int &u,int l,int r,int X,int add){
    if(!u)u=++tot;
    if(l==r){t[u].sum+=add;return;}
    int mid=(l+r)>>1;
    if(X<=mid)mdf(t[u].ls,l,mid,X,add);
    else mdf(t[u].rs,mid+1,r,X,add);
    up(u);
}

int qry(int u,int l,int r,int X){
    if(!u)return 0;
    if(l==r)return t[u].sum;
    int mid=(l+r)>>1;
    if(X<=mid)return qry(t[u].ls,l,mid,X);
    else return qry(t[u].rs,mid+1,r,X);
}

void dfs(int u,int fth){
    for(int v:g[u]){
        if(v!=fth){
            dfs(v,u);
            rt1[u]=merge(rt1[u],rt1[v],1,UP);
            rt2[u]=merge(rt2[u],rt2[v],1,UP);
        }
    }
    for(PII i:diff1[u])mdf(rt1[u],1,UP,i.first+n,i.second);
    for(PII i:diff2[u])mdf(rt2[u],1,UP,i.first+n,i.second);
    ans[u]=qry(rt1[u],1,UP,h[u]+w[u]+n)+qry(rt2[u],1,UP,h[u]-w[u]+n);
}

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<n;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        g[u].push_back(v),g[v].push_back(u);
    }
    for(int i=1;i<=n;i++)scanf("%d",&w[i]);
    pre(1,0);
    for(int i=1;i<=m;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        int l=lca(u,v);
        diff1[u].push_back({h[u],1});
        diff1[path[l][0]].push_back({h[u],-1});
        diff2[v].push_back({h[l]-(h[u]-h[l]),1});
        diff2[l].push_back({h[l]-(h[u]-h[l]),-1});
    }
    UP=n<<2;
    dfs(1,0);
    for(int i=1;i<=n;i++)printf("%d ",ans[i]);
    return 0;
}
```

---

## 作者：ZHR100102 (赞：3)

这题主要难点还是想到根据 lca 把路径分成两边，分讨算每个人的贡献。

# 思路

首先看到树上路径，很容易就能想到树上差分计算每个跑步的人的贡献。

那么一个人的贡献改如何计算呢？我们考虑某个观察员他在 $w$ 秒到底能观察到谁，显然是能观察到**路线经过他且到他的距离为 $w$ 的人**。

因此，我们就可以根据路径上每个点到起点的距离来计算贡献。

而由于起点和终点的 lca 两边的点的距离计算方式不相同，所以需要进行分类讨论：

## 当路径未经过 lca 时

这时候观察员 $x$ 能观察到人的条件是 $dep_s-dep_x=w_x$，把有关观察员的变量全部丢到一边，得到 $dep_s=dep_x+w_x$。

## 当路径经过 lca 时

这时候观察员 $x$ 能观察到人的条件是 $dep_s-dep_{lca}+dep_x-dep_{lca}=w_x$，把有关观察员的变量全部丢到一边，得到 $dep_x-w_x=2\times dep_{lca}-dep_s$。

于是，我们就可以开桶记录下每个值对应的贡献，查询的时候答案就是 $dep_x+w_x$ 的贡献与 $dep_x-w_x$ 的和。同时注意特判 $w_x=0$ 的情况，此时直接将两者的贡献相加会导致贡献多算一倍。

这个桶我们可以用动态开点线段树实现，然后做树上前缀和求答案的时候直接线段树合并即可。

注意这个线段树会存负数下标，且树上差分的时候要先在 lca 处减掉未经过 lca 的贡献，在 lca 的父亲处再减掉经过 lca 的贡献，不然会导致未经过 lca 的贡献被减两次或者经过 lca 的贡献被减两次。

时间复杂度 $O(n\log n)$，因为树上差分一个操作要修改四次，所以空间记得开四倍。

# 代码

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
#define lc(x) (tr[x].ls)
#define rc(x) (tr[x].rs)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair<int,int>;
const int N=300005;
int n,m,w[N],fa[N],top[N],dep[N],sz[N],son[N],ans[N];
vector<int>g[N];
struct Node{
    int ls,rs,v;
};
struct Segtree{
    Node tr[80*N];
    int root[N],tot=0;
    void update(int &u,int ln,int rn,int x,int k)
    {
        if(u==0)u=++tot;
        tr[u].v+=k;
        if(ln==rn)return;
        int mid=(ln+rn)>>1;
        if(x<=mid)update(lc(u),ln,mid,x,k);
        else update(rc(u),mid+1,rn,x,k);
    }
    int merge(int x,int y)
    {
        if(x==0||y==0)return x+y;
        tr[x].v+=tr[y].v;
        tr[x].ls=merge(lc(x),lc(y));
        tr[x].rs=merge(rc(x),rc(y));
        return x;
    }
    int query(int u,int ln,int rn,int x)
    {
        if(ln==rn)return tr[u].v;
        int mid=(ln+rn)>>1;
        if(x<=mid)return query(lc(u),ln,mid,x);
        else return query(rc(u),mid+1,rn,x);
    }
}tr1;
void dfs1(int u,int f)
{
    dep[u]=dep[f]+1;fa[u]=f;sz[u]=1;
    for(auto v:g[u])
    {
        if(v==f)continue;
        dfs1(v,u);
        sz[u]+=sz[v];
        if(sz[son[u]]<sz[v])son[u]=v;
    }
}
void dfs2(int u,int tp)
{
    top[u]=tp;
    if(son[u]==0)return;
    dfs2(son[u],tp);
    for(auto v:g[u])
    {
        if(v==fa[u]||v==son[u])continue;
        dfs2(v,v);
    }
}
int getlca(int u,int v)
{
    while(top[u]!=top[v])
    {
        if(dep[top[u]]<dep[top[v]])swap(u,v);
        u=fa[top[u]];
    }
    if(dep[u]<dep[v])swap(u,v);
    return v;
}
void dfs3(int u,int f)
{
    for(auto v:g[u])
    {
        if(v==f)continue;
        dfs3(v,u);
        tr1.root[u]=tr1.merge(tr1.root[u],tr1.root[v]);
    }
    ans[u]=tr1.query(tr1.root[u],-N,N,dep[u]+w[u]);
    if(w[u])ans[u]+=tr1.query(tr1.root[u],-N,N,dep[u]-w[u]);
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<n;i++)
    {
        int u,v;
        cin>>u>>v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs1(1,0);
    dfs2(1,1);
    for(int i=1;i<=n;i++)cin>>w[i];
    while(m--)
    {
        int s,t;
        cin>>s>>t;
        int lca=getlca(s,t);
        int flca=fa[lca];
        tr1.update(tr1.root[s],-N,N,dep[s],1);
        tr1.update(tr1.root[t],-N,N,2*dep[lca]-dep[s],1);
        tr1.update(tr1.root[lca],-N,N,dep[s],-1);
        tr1.update(tr1.root[flca],-N,N,2*dep[lca]-dep[s],-1);
    }
    dfs3(1,0);
    for(int i=1;i<=n;i++)cout<<ans[i]<<" ";
    return 0;
}
```

---

## 作者：CommandSR (赞：3)

## 题意简化

一棵树上有 $m$ 个玩家从起点 $s_i$ 跑到终点 $t_i$，每个节点 $j$ 的观察员在 $w_j$ 秒出现，求每个观察员能看到的玩家数量。

## 基本思路：LCA+树上差分

我们将第 $i$ 条路径 $s_i \rightarrow t_i$ 分解为 $s_i \rightarrow \text{LCA}(s_i, t_i)$ 和 $\text{LCA}(s_i, t_i) \rightarrow t_i$，便于求解。

### 求解路径 1

对于 $s_i \rightarrow \text{LCA}(s_i, t_i)$ 的路径，玩家 $i$ 在节点 $u$ 能被观察到当且仅当 $dep_{s_i} - dep_u = w_u$。

移项得 $dep_{s_i} = w_u + dep_u$，相当于路径上每个节点加一个 $dep_{s_i}$ 的值，统计每一个节点 $u$ 上 $w_u + dep_u$ 的数量。

记 $cnt_{0, w_u + dep_u}$ 为这个值的数量，我们在端点 $s_i$ 和 $\text{LCA}(s_i, t_i)$ 处树上差分一个 $dep_{s_i}$ 的值，dfs 遍历整棵树，每访问到一个节点 $u$，先记录先前的 $cnt_{0, w_u + dep_u}$ 的值，再统计 $u$ 端点处对答案的贡献，统计后的 $cnt_{0, w_u + dep_u}$ 减去先前的值就是节点 $u$ 的答案。

## 求解路径 2

对于 $\text{LCA}(s_i, t_i) \rightarrow t_i$ 的路径，玩家 $i$ 在节点 $u$ 能被观察到当且仅当 $dep_{s_i} + dep_u - 2 \times dep_{\text{LCA}(s_i, t_i)} = w_u$。

移项得 $dep_{s_i} - 2 \times dep_{\text{LCA}(s_i, t_i)} = w_u - dep_u$，相当于路径上每一个节点加一个 $dep_{s_i} - 2 \times dep_{\text{LCA}(s_i, t_i)}$ 的值，统计每一个节点 $u$ 上 $w_u - dep_u$ 的数量。

记 $cnt_{1, w_u - dep_u}$ 为这个值的数量，我们在端点 $s_i$ 和 $\text{LCA}(s_i, t_i)$ 处树上差分一个 $dep_{s_i} - 2 \times dep_{\text{LCA}(s_i, t_i)}$ 的值，dfs 遍历整棵树，每访问到一个节点 $u$，先记录先前的 $cnt_{1, w_u - dep_u}$ 的值，再统计 $u$ 端点处对答案的贡献，统计后的 $cnt_{1, w_u - dep_u}$ 减去先前的值就是节点 $u$ 的答案。


## AC Code

```cpp
/*
起点 s 终点 t
对于左路径上的点 x
dep[s]-dep[x]==w[x] => dep[s]==w[x]+dep[x]
对于右路径上的点 y
dep[s]+dep[y]-2*dep[lca(s,y)]==w[y] => dep[s]-2*dep[lca(s,y)]==w[y]-dep[y]
*/
#include <bits/stdc++.h>
#define pb push_back
#define int long long
#define pii pair <int, int>
#define mkpr make_pair
#define fi first
#define se second
using namespace std;
const int N = 3e5 + 5, D = 3e5;
int n, m, w[N], d[N], f[N][25], c[2][N<<1], ans[N], dep[N];
vector <int> g[N];
vector <pii> add[N], del[N];
struct path {int u, v;} p[N];
void Dfs(int u, int p) {
	f[u][0] = p;
	dep[u] = dep[p] + 1;
	for (int v : g[u]) {
		if (v == p) continue ;
		Dfs(v, u);
	}
}
void InitLCA() {
	for (int j = 1; j <= 21; j++) {
		for (int i = 1; i <= n; i++) {
			f[i][j] = f[f[i][j-1]][j-1];
		}
	}
}
int LCA(int u, int v) {
	if (dep[u] < dep[v]) swap(u, v);
	for (int i = 21; i >= 0; i--) if (dep[f[u][i]] >= dep[v]) u = f[u][i];
	if (u == v) return u;
	for (int i = 21; i >= 0; i--) if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];
	return f[u][0];
}
void Dfs2(int u) {
	int pre1 = c[0][w[u]+dep[u]+D], pre2 = c[1][w[u]-dep[u]+D]; // 计算先前答案
	for (pii cur : add[u]) ++c[cur.fi][cur.se+D];
	for (pii cur : del[u]) --c[cur.fi][cur.se+D];
	for (int v : g[u]) {
		if (v == f[u][0]) continue ;
		Dfs2(v);
	}
	ans[u] = c[0][w[u]+dep[u]+D] - pre1 + c[1][w[u]-dep[u]+D] - pre2;
}
void Solve() {
	cin >> n >> m;
	for (int i = 1; i < n; i++) {
		int u, v; cin >> u >> v;
		g[u].pb(v), g[v].pb(u);
	}
	for (int i = 1; i <= n; i++) cin >> w[i];
	Dfs(1, 0); InitLCA();
	for (int i = 1; i <= m; i++) {
		int u, v; cin >> u >> v;
		int lc = LCA(u, v);
		add[u].pb(mkpr(0, dep[u])), del[f[lc][0]].pb(mkpr(0, dep[u]));
		add[v].pb(mkpr(1, dep[u]-2*dep[lc])), del[lc].pb(mkpr(1, dep[u]-2*dep[lc]));
	}
	Dfs2(1);
	for (int i = 1; i <= n; i++) cout << ans[i] << ' ';
}
signed main() {
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	Solve();
	return 0;
}
```

---

## 作者：rhineofts (赞：2)

做法和省选 D2T1 推箱子很像，甚至感觉比那个题还简单。

把一个路径拆成向上的 $u \to lca$，**负速度向上**的 $v \to lca$ 的两段两种路径。

+ 对于向上的路径，若从 $x$ 向上能和 $u$ 碰面，要求 $dep_x - dep_u = w_u$。分离变量得 $dep_x = dep_u + w_u$。
+ 对于负速度向上的路径，设到达 $x$ （即整段跑步路程结束）的时间为 $t_x$，它对 $u$ 处的检测有贡献，那么就有 $dep_x - dep_u = t_x - w_u$，分离变量得 $dep_x - t_x = dep_u - t_u$。

那么我们在树上扫描线（其实就是树上差分），用桶维护 $w_u - dep_u$，$w_u + dep_u$ 状物。由于只有子树内的贡献才合法，因此用一个经典方法：在搜子树前先给答案加上负的桶内贡献，这样就能抵消掉不合法（即子树外）的贡献。

注意处理在 $\operatorname{lca}(u, v)$ 处算重的情况。

```c++
// h 和 buc 维护的是向上的路径 (u->lca)
// g 和 buc2 维护的是负速度向上的路径 (v->lca)

void dfs(int u) {
    if (w[u] + dep[u] <= n) ans[u] -= buc[w[u] + dep[u]];
    ans[u] -= buc2[w[u] - dep[u] + n]; // 为了防止越界，buc2 下标统一加上 n 并开两倍空间
    
    for (int v : adj[u]) {
        if (v == fa[u]) continue;
        dfs(v);
    }
    
    buc[dep[u]] += hadd[u];
    if (w[u] + dep[u] <= n) ans[u] += buc[w[u] + dep[u]];
    for (int v : gadd[u]) {
        buc2[v - dep[u] + n]++;
    }
    ans[u] += buc2[w[u] - dep[u] + n];
    
    for (int v : hdel[u]) {
        buc[v]--;
    }
    for (int v : gdel[u]) {
        buc2[v]--;
    }
}   

void solve() {
    cin >> n >> Q;
    F (i, 1, n - 1) {
        int u, v; cin >> u >> v;
        adj[u].pb(v); adj[v].pb(u);
    }
    LCA::dfs(1);
    LCA::init();
    F (i, 1, n) {
        cin >> w[i];
    }
    vla<pii> q(Q + 1);
    #define u first
    #define v second
    F (i, 1, Q) {
        cin >> q[i].u >> q[i].v;
        int anc = lca(q[i].u, q[i].v);
        int Dis = dep[q[i].u] + dep[q[i].v] - 2 * dep[anc];
        if (anc == q[i].u) {
            gadd[q[i].v].pb(Dis);
            gdel[anc].pb(Dis - dep[q[i].v] + n);
        } else if (anc == q[i].v) {
            hadd[q[i].u]++;
            hdel[anc].pb(dep[q[i].u]);
        } else {
            hadd[q[i].u]++;
            hdel[anc].pb(dep[q[i].u]);

            gadd[q[i].v].pb(Dis);
            gdel[anc].pb(Dis - dep[q[i].v] + n);
            
            if (dep[q[i].u] - dep[anc] == w[anc]) { // 处理算重
                ans[anc]--;
            }
        }   
    }
    dfs(1);
    F (i, 1, n) {
        cout << ans[i] << " \n"[i == n];
    }
}   
```

---

## 作者：zzyiqa (赞：1)

# P1600

[原题戳这里](https://www.luogu.com.cn/problem/P1600)

## 题目背景

NOIP2016 提高组 D1T2

# 思路

我们很明显可以将一个人的跑步路线分为 $s_i\Rightarrow\operatorname{lca}(s_i,t_i)$ 以及 $\operatorname{lca}(s_i,t_i)\Rightarrow\ t_i$ 两部分。

设 $dep_x$ 为节点 $x$ 的深度，$fa_x$ 表示节点 $x$ 的父节点。

我们考虑这两种情况所对应的可行情况。

考虑下图：（$fi$ 是第一个观察员，$se$ 是第二个观察员，$x$ 是起始点，$y$ 是终点）

![113](https://cdn.luogu.com.cn/upload/image_hosting/rwogm909.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

那么很明显，当 $fi$ 可以被贡献当且仅当 $dep_x-dep_{fi}=w_{fi}$，而 $se$ 能被贡献当且仅当 $dep_x+dep_{se}-2\times dep_{lca}=w_{se}$。

我们考虑把这两种情况分开讨论。

首先是第一种，通过移项可以把上面那个式子转换成 $dep_x=dep_{fi}+w_{fi}$，而 $x$ 能做出贡献只能在路径 $x\Rightarrow\operatorname{lca}(x,y)$，那么我们可以认为其实是在上面那条路径上增加了一个来自于 $x$ 的价值为一的贡献。那么我们就不难想到使用树上差分了。即我们认为 $x$ 的贡献在 $x$ 出现，在 $\operatorname{lca}(x,y)$ 处消失。而我们把 $dep_x$ 的贡献加上一，其实对于在这条路径上的每一个满足条件点 $fi$ 的 $dep_{fi}+w_{fi}$ 加上一。

然后我们来考虑第二种。其实和第一种差不多，通过移项得到 $dep_{x}-dep_{lca}\times 2=w_{se}-dep_{se}$，那么和第一种同样的，把 $dep_{x}-dep_{lca}\times 2$ 的贡献加一，其实就是把 $w_{se}-dep_{se}$ 的贡献加一。而该贡献能够实行显然是在路径 $y\Rightarrow\operatorname{lca}(x,y)$ 上。

所以我们存下每个物品出现和消失的时间，提前存下在考虑节点 $x$ 之前的贡献，在考虑加上节点 $x$ 的，显然，节点 $x$ 的贡献就是两者相减的结果。

# Ac code

```cpp
#include<bits/stdc++.h>
#include<vector>
#define ll long long
#define ma make_pair
#define fi first
#define se second
using namespace std;
const ll N=3e5+5;
ll n,m,ans[N],dep[N]={0ll,1ll},f[N],fa[N],w[N],sum[N],Ans[N],in[N*2][5];
bool bo[N],vis[N];
vector<ll>v[N];
vector<pair<ll,ll> >q[N],zh[N],fu[N];
pair<ll,ll> p[N];
ll find(ll x) {return fa[x]=(fa[x]==x)?x:find(fa[x]);}
void dfs(ll x){
	vis[x]=true;
	for(ll i=0;i<v[x].size();i++){
		ll y=v[x][i];
		if(vis[y]==false){
			f[y]=x,dep[y]=dep[x]+1;//父节点 + 深度 
			dfs(y);
			ll fx=find(x),fy=find(y);
			if(fx==fy) continue;
			fa[fy]=fx;
		}
	}
	for(ll i=0;i<q[x].size();i++){
		ll y=q[x][i].fi;
		if(vis[y]==true && bo[q[x][i].se]==false){
			ll fy=find(y);
			bo[q[x][i].se]=true;
			ans[q[x][i].se]=fy;
		}
	}
}
void Dfs(ll x){
	vis[x]=true;
	ll s1=dep[x]+w[x],s2=w[x]-dep[x]+N;
	ll now0=in[s1][0ll],now1=in[s2][1ll];//记录之前的 
	for(ll i=0;i<zh[x].size();i++){
		ll y=zh[x][i].se,z=zh[x][i].fi;
		in[y][z]++;
	}
	for(ll i=0;i<fu[x].size();i++){
		ll y=fu[x][i].se,z=fu[x][i].fi;
		in[y][z]--;
	}
	for(ll i=v[x].size()-1ll;i>=0ll;i--){
		ll y=v[x][i];
		if(vis[y]==true) continue;
		Dfs(y);
	}
	ans[x]=in[s1][0ll]-now0+in[s2][1ll]-now1;//做差 
}
int main(){
	cin.tie(0);
	cout.tie(0);
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(ll i=1;i<=n;i++) fa[i]=i;
	for(ll i=1,x,y;i<n;i++){
		cin>>x>>y;
		v[x].push_back(y);
		v[y].push_back(x);
	}
	for(ll i=1;i<=n;i++) cin>>w[i];
	for(ll i=1,x,y;i<=m;i++){
		cin>>x>>y;
		q[x].push_back(ma(y,i));
		q[y].push_back(ma(x,i));
		p[i]=ma(x,y);
	}
	dfs(1ll);//tarjan 求 lca 
	for(ll i=1;i<=m;i++){
		ll x=p[i].fi,y=p[i].se;
		//差分 
		zh[x].push_back(ma(0ll,dep[x]));
		fu[f[ans[i]]].push_back(ma(0ll,dep[x]));
		zh[y].push_back(ma(1ll,dep[x]-2*dep[ans[i]]+N));
		fu[ans[i]].push_back(ma(1ll,dep[x]-2*dep[ans[i]]+N));
	}
	for(ll i=1;i<=n;i++) vis[i]=false;
	Dfs(1ll);//跑差分 
	for(ll i=1;i<=n;i++) cout<<ans[i]<<" ";
	return 0;
}
```

番外：~~题解里好像只有我一个人用 tarjan 求 lca~~？

---

## 作者：qhr2023 (赞：1)

## solution

一道经典的树上问题，用 LCA 加树上差分加桶解决，据说弄懂了这题，树上差分加桶的题就没什么问题了。

我们统计每个观察员观察到的玩家，这个玩家是可以差分的。对于一个玩家要从 $u$ 到 $v$，可以把它拆成两段分开做，即 $u$ 到它们的 LCA 和 LCA 到 $v$。

先考虑前一段。可以把路径差分成 $1$ 个人从 $u$ 到根，$-1$ 个人从 LCA 的父亲走到根，降低问题的自由度。

这样每个观察员只能观察到子树内上来的玩家。记 $dep_i$ 表示结点 $i$ 的深度。对于两个节点 $i$ 和 $j$，当 $i$ 在 $j$ 的子树内，且能遇到，即满足 $s_i+dep_j-dep_i=w_j$，简化一下 $s_i-dep_i=w_j+dep_j$ 时，$i$ 才对 $j$ 有贡献。问题就转化成查子树内有多少结点的 $s_i-dep_i$ 等于 $w_j+dep_j$。

这个问题我们开个桶，对于树上的任何一个起点和终点，把其产生的贡献放在桶里面，回溯到子树根的时候再到桶里面查询结果。

对于 LCA 到 $v$ 这部分，看成从 $v$ 走到 LCA，每次时间减一，类似的差分再推个式子即可。

注意，如果路径起点或终点刚好为 LCA 且 LCA 处是可观察到运动员的，那么我们在上行统计过程中和下行统计过程中都会对该LCA产生贡献，这样就重复计数一次，要减掉。还有，我们数组下标可能为负，所以我们加上一个大数，相当于数组右移了一段。

更多细节可以参考[这里](https://www.cnblogs.com/lfyzoi/p/10221884.html)。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5;
vector<int> e[N], add1[N], add2[N], era1[N], era2[N];
int n, m, ans[N], w[N], dep[N], fa[N][25], b1[N*2], b2[N*2];
void dfs (int u, int F) {
	dep[u]=dep[F]+1;
	fa[u][0]=F;
	for (int i=1; i<=22; ++i)
		fa[u][i]=fa[fa[u][i-1]][i-1];
	for (int i:e[u])
		if (i!=F)
			dfs(i, u);
}
int lca (int x, int y) {
	if (dep[x]<dep[y])
		swap(x, y);
	for (int i=20, d=dep[x]-dep[y]; i>=0; --i)
		if ((d>>i)&1)
			x=fa[x][i];
	if (x==y)
		return x;
	for (int i=20; i>=0; --i)
		if (fa[x][i]!=fa[y][i])
			x=fa[x][i],
			y=fa[y][i];
	return fa[x][0];
}
void dfs2 (int u, int F) {
	int t1=b1[dep[u]+w[u]], t2=b2[dep[u]-w[u]+N];
	for (int i:e[u]) if (i!=F) dfs2(i, u);
	for (int i:add1[u]) b1[i]++;
	for (int i:add2[u]) b2[i+N]++;
	ans[u]+=b1[dep[u]+w[u]]-t1+b2[dep[u]-w[u]+N]-t2;
	for (int i:era1[u]) b1[i]--;
	for (int i:era2[u]) b2[i+N]--;
}
int main() {
	cin >> n >> m;
	for (int i=1, u, v; i<n; ++i)
		cin >> u >> v,
		e[u].push_back(v),
		e[v].push_back(u);
	for (int i=1; i<=n; ++i)
		cin >> w[i];
	dfs(1, 0);
	for (int u, v, Lca, dis; m--; ) 
		cin >> u >> v,
		Lca=lca(u, v), 
		dis=dep[u]+dep[v]-dep[Lca]*2,
		add1[u].push_back(dep[u]),
		era1[Lca].push_back(dep[u]),
		add2[v].push_back(dep[v]-dis),
		era2[Lca].push_back(dep[v]-dis),
		ans[Lca]-=(dep[Lca]+w[Lca]==dep[u]);
	dfs2(1, 0);
	for (int i=1; i<=n; ++i) 
		cout << ans[i] << ' ';
	return 0;
}
```

---

## 作者：OrinLoong (赞：1)

原题链接：[传送门](https://www.luogu.com.cn/problem/P1600)

## 题意简述
给定一棵 $N$ 个结点的树。有 $M$ 个玩家从第 $0$ 时刻开始从 $s_i$ 出发，以每秒一条边的速度沿着树上的简单路径向 $t_i$ 跑去。对于每个结点 $j$ 都有一个观察员，会选择在 $w_j$ 时刻观察其结点上所有玩家。问每个观察员分别能观察到多少玩家。

$N,M\le 3\times 10^5$。

## 解决方案
最暴力的做法是模拟每个玩家的跑步过程，这么做在数据随机的情况下是 $O(M\log N)$ 的，但是会被链数据卡到 $O(NM)$。考虑这样做为什么不优：这种做法是让每个玩家沿路给路上的结点加 $0$ 或 $1$ 个贡献，而一条链压缩到极致的信息量也是 $\log N$ 级别的。但如果我们转而从每个观察员的视角考虑问题，让玩家的贡献在合适的时间段放在一定的桶里，然后顺着树的深搜过程让每个结点“取”贡献，这么做的话每个结点统计答案就是 $O(1)$ 级别了。

那么这么做有没有可行性呢？我们来分析一下一个玩家给一个观察员造成贡献的条件。

首先，我们令 $a_i=\text{lca}(s_i,t_i)$，$d_i=dis(s_i,t_i)$。把 $(s_i,t_i)$ 的路径拆成 $(s_i,a_i)$ 和 $(a_i,t_i)$ 这两条深度单调连续变化的链来考虑（这个处理是很经典显然的）。

对于观察员 $u$ 来说，若 $(s_i,a_i)$ 为其造成贡献：
+ $s_i$ 必须在 $u$ 的子树内部，且 $a_i$ 必须在 $u$ 的子树外部或与 $u$ 重合，否则整条路径压根不经过 $u$。
+ $dep_{s_i}=dep_u+w_u$，这样此玩家才能刚好在第 $w_u$ 秒走到 $u$。

同理，对于观察员 $u$ 来说，若 $(s_i,a_i)$ 为其造成贡献：
+ $t_i$ 必须在 $u$ 的子树内部，且 $a_i$ 必须在 $u$ 的子树外部或与 $u$ 重合，否则整条路径压根不经过 $u$。
+ $dep_{t_i}-d_i=dep_{u}-w_i$。这个式子看起来不太好懂？可以这么理解：如果把路径抻直，那么第 $0$ 时刻时玩家就在 $dep_{t_i}-d_i$ 的深度。

既然我们要让观察员“自取”贡献，那么我们就要开桶把这些贡献存进去，然后观察员顺着下标就取出来了。另外还有两点要注意：
1. 如果刚好有玩家在 $a_i$ 处做出了贡献，那么会算重。我们要提前减掉多算的一次（见代码）
2. $dep_{t_i}-d_i$ 和 $dep_{u}-w_i$ 都有可能是负的，因此代码实现上要给其加一个偏移量 $N$，相应地桶数组也要开两倍。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MaxN=6e5+5;
int frdint(){
    int n=0,k=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')k=-1;ch=getchar();}
    while(isdigit(ch))n=(n<<3)+(n<<1)+ch-'0',ch=getchar();
    return n*k;
}
void fwrint(int x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)fwrint(x/10);
    putchar(x%10+'0');
}
int N,M,X,Y,W[MaxN];
vector<int> Ti[MaxN];
void addudge(int u,int v){
    Ti[u].push_back(v);
    Ti[v].push_back(u);
}
int dep[MaxN],tfa[MaxN],siz[MaxN],hvs[MaxN];
void dfs1(int u,int f){
    dep[u]=dep[f]+1,tfa[u]=f,siz[u]=1;
    for(int v : Ti[u]){
        if(v==f)continue;
        dfs1(v,u);siz[u]+=siz[v];
        if(siz[v]>siz[hvs[u]])hvs[u]=v;
    }
}
int top[MaxN];
void dfs2(int u,int t){
    top[u]=t;if(!hvs[u])return;
    dfs2(hvs[u],t);for(int v : Ti[u]){
        if(v!=tfa[u]&&v!=hvs[u])dfs2(v,v);
    }
}
int getlca(int x,int y){
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        x=tfa[top[x]];
    }
    return dep[x]<dep[y]?x:y;
}
struct anob{int s,t,d;}P[MaxN];
int buc[2][MaxN<<1],ans[MaxN];
vector<int> avec[MaxN],svec[MaxN],tvec[MaxN];
void dfs3(int u){
    int tmp1=buc[0][dep[u]+W[u]],tmp2=buc[1][W[u]-dep[u]+N];
	for(int v : Ti[u])if(v!=tfa[u])dfs3(v);
	buc[0][dep[u]]+=svec[u].size();
	for(int i : tvec[u])buc[1][P[i].d-dep[P[i].t]+N]++;
	int cres=buc[0][dep[u]+W[u]]-tmp1+buc[1][W[u]-dep[u]+N]-tmp2;
	if(cres>=0)ans[u]+=cres;
    for(int i : avec[u])buc[0][dep[P[i].s]]--;
    for(int i : avec[u])buc[1][P[i].d-dep[P[i].t]+N]--;
}
int main(){
    N=frdint(),M=frdint();
    for(int i = 1;i < N;i++){
        X=frdint(),Y=frdint();
        addudge(X,Y);
    }
    for(int i = 1;i <= N;i++)W[i]=frdint();
    dfs1(1,0),dfs2(1,1);
    for(int i = 1;i <= M;i++){
        auto &[cs,ct,cd]=P[i];
		cs=frdint(),ct=frdint();
        svec[cs].push_back(i);
		tvec[ct].push_back(i);
        int anc=getlca(cs,ct);
        avec[anc].push_back(i);
		cd=dep[cs]+dep[ct]-dep[anc]*2;
		if(dep[anc]+W[anc]==dep[cs])ans[anc]--;
    }
    dfs3(1);
    for(int i = 1;i <= N;i++){
        fwrint(ans[i]),putchar(' ');
    }
    return 0;
}
```

## 反思与总结
这道题的此做法中，我们在算贡献时从考虑每条玩家的路径转而考虑每个结点的贡献。这启示我们要考虑从不同的角度和对象计算贡献，找到最优的那个。

---

## 作者：JACK_POT (赞：1)

# 树上差分（LCA辅助(树上倍增版)）
### 题面回顾
有一棵$n$个节点，边权为$1$的树，有$m$个人在$S[i]$和$T[i]$之间的最短路径上从$0$时刻出发开始跑步，每个节点$i$上都有一个观察员，观察第$w[i]$秒恰好经过该节点的人数。问：每个观察员可以看到多少人？
### 思路分析
~~（解释一波lyd大佬的思路）~~

由于每个人运动的路径是固定的，所以可以把每个人的路径分为两段：起点$s$到$lca$，$lca$到终点$t$

因此，对于每个观测点$x$,有两种情况可以观察到第$i$个人(其中$d$数组表示深度，可以用bfs一遍处理倍增时进行预处理)

1. $x$在$s[i]$到$lca(s[i],t[i])$的路径上，$w[x]=d[s[i]]-d[x]$

2. $x$在$lca(s[i],t[i])$到$t[i]$的路径上，$w[x]=d[s[i]]+d[x]-2* d[lca(s[i],t[i])] $

这两种情况其实是类似的，我们不妨先来考虑第一种

移项得 $w[x]+d[x]=d[s[i]]$

这就相当于在$s[i]$到$lca(s[i],t[i])$的路径上每个节点放一个类型为$d[s[i]]$的物品，求最终每个节点上放有多少个类型为$d[x]+w[x]$的物品

这让我们想到了[雨天的尾巴](https://www.luogu.com.cn/problem/P4556)，但是那道线段树合并模板题是因为要求每个节点最多的种类是什么，这道题则是求给定的种类有多少个物品

因此可以不用敲线段树合并。。。

**下面是做法：**

1. 对每个节点建立两个$vector$数组，分别表示在这个节点产生或消失的物品的类型

2. 建立全局数组$c$，记录每种类型物品的数量（相当于桶）

3. 开始做dfs，当遇到一个点$x$时，先保存当前$c[w[x]+d[x]]$的值，记为$cnt$

4. 然后扫描$x$的两个$vector$，产生数组中出现$z$就让$c[z]++$,消失数组中出现$z$就让$c[z]--$。这是因为如果这个物品在$x$的子树中即产生又消失，那么对$x$无影响；如果只产生不消失，说明消失的地方在$x$上面，那么$x$上就会放下这个物品；由于规定下产生，上消失，所以不可能出现消失了但没有产生的情况（~~你在无中生有暗度陈仓。。。~~）

5. 然后扫完子节点返回$x$,用当前的$c[w[x]+d[x]]$减去扫描前的$c[w[x]+d[x]]$（也就是存好的$cnt$），记为$x$处的$w[x]+d[x]$类物品的数量

下面是几个栗子
![](https://cdn.luogu.com.cn/upload/image_hosting/30wyycra.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/ikv3y8h9.png)

然后刚才说过的第二种情况也差不多，t[i]到$lca$路径上增加的物品类型为$d[s[i]]-2* d[lca(s[i],t[i])]$, 最后统计每个结点$x$处物品$w[x]-d[x]$的数量

最后就可以上代码了（一些细节会在代码里讲）

### 代码来了

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define fr(i,a,b) for(int i=a;i<=b;i++)
#define fo(i,a,b) for(int i=a;i>=b;i--)//个人习惯而已，别太在意
#pragma GCC optimize(2)
const int M=300005;
int n,m,v[M],p,f[M][20],s[M],t[M],lca[M],w[M],c1[2*M],c2[2*M],ans[M],d[M];
int head[M],Next[2*M],ver[2*M],tot;
vector<int> ap1[M],dap1[M],ap2[M],dap2[M];
//ap即appear出现，dap即disappear消失，1和2分别是从s到lca和t到lca
queue<int> q;
void add(int x,int y) {
	Next[++tot]=head[x],head[x]=tot,ver[tot]=y;
}
void bfs() {
	q.push(1); d[1]=1;
	while(q.size()) {
		int x=q.front(); q.pop();
		for(int i=head[x];i;i=Next[i]) {
			int y=ver[i];
			if(d[y]) continue;
			d[y]=d[x]+1;
			f[y][0]=x;
			fr(j,1,p) f[y][j]=f[f[y][j-1]][j-1];
         		//LCA的倍增预处理（这个不用我多说了吧）
			q.push(y);
		}
	}
} 
int LCA(int x,int y) {
	if(d[x]>d[y]) swap(x,y);
	fo(i,p,0) if(d[f[y][i]]>=d[x]) y=f[y][i];
	if(x==y) return x;
	fo(i,p,0) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
void dfs(int x) {
	v[x]=1;
	int cnt1=c1[w[x]+d[x]],cnt2=c2[w[x]-d[x]+M];
   	//cnt2加这个M是因为w[x]-d[x]有可能是负的，要加偏移值或离散化
   	//先保存好扫描前的数量
	for(int i=0;i<ap1[x].size();i++) c1[ap1[x][i]]++;
	for(int i=0;i<dap1[x].size();i++) c1[dap1[x][i]]--;
	for(int i=0;i<ap2[x].size();i++) c2[ap2[x][i]+M]++;
   	//当然后面的也要加偏移值
	for(int i=0;i<dap2[x].size();i++) c2[dap2[x][i]+M]--;
   	//其实就是个差分吧
	for(int i=head[x];i;i=Next[i]) {
		int y=ver[i];
		if(v[y]) continue;
		dfs(y);
	}
	ans[x]=c1[w[x]+d[x]]-cnt1+c2[w[x]-d[x]+M]-cnt2;
   	//相减即为答案
   	//容易发现从两个端点到lca是互不干扰的
}
int main(){
	std::ios::sync_with_stdio(false);
	scanf("%d%d",&n,&m);
	p=(int)log(n)/log(2)+1;
	fr(i,1,n-1) {
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y); add(y,x);
	}
	bfs();
	fr(i,1,n) scanf("%d",&w[i]);
	fr(i,1,m) {
		int s,t;
		scanf("%d%d",&s,&t);
		int lca=LCA(s,t);
		ap1[s].push_back(d[s]);
		dap1[f[lca][0]].push_back(d[s]);
		ap2[t].push_back(d[s]-2*d[lca]);
		dap2[lca].push_back(d[s]-2*d[lca]);
      		//记录物品出现和消失的类型
	}
	dfs(1);
	fr(i,1,n) printf("%d ",ans[i]);
	return 0;
}

```
（~~不知道为什么每行代码都空四格了QWQ~~）

---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P1600)

---

# 思路：

首先对于这样的树上路径问题都可以把这条路径 $(x,y)$ 拆成上行 $(x,lca)$ 和下行 $(lca,y)$ 两部分。假设一个人睁眼的时间是 $w_i$ 那么对于上行链，应该满足：$dep_x-dep_i=w_i$，然后对于下行链：$dis_{(x,y)}-(dep_y-dep_i)=w_i$ 然后移项：

$$
w_i+dep_i=dep_x\\
w_i-dep_i=dis_{(x,y)}-dep_y
$$

维护两个桶然后树上差分就好了。

但是还要注意的是，由于桶是全局的，所以应该消除子树外的节点的答案对于当前节点的影响。在统计答案时应该先算一下统计到这个点时桶的状态 $tmp$ 然后这个点真正的答案是将要离开这个点时的答案 $ans$ 与 $tmp$ 作差。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int lg=20;
const int N=1e6+10;
const int INF=0x3f3f3f3f;
int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
void write(int x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9){
        write(x/10);
    }
    putchar(x%10+'0');
    return;
}
int dl[N<<1],ul[N<<1],ans[N],n,m,c,ca,ce,hd[N],de[N],fa[N][lg+5],hda[N],hde[N],s[N],e[N],nm[N],w[N],dis[N];
struct node{
	int to,ne;
}eg[N<<1];
struct node1{
	int id,ne;
}lp[N<<1],ep[N<<1];
void add(int x,int y){
	eg[++c].to=y;
    eg[c].ne=hd[x];
    hd[x]=c;
}
void dfs1(int u,int f){
	de[u]=de[f]+1;
	fa[u][0]=f;
	for(int i=1;i<=lg;i++){
		fa[u][i]=fa[fa[u][i-1]][i-1];
	}
	for(int i=hd[u];~i;i=eg[i].ne){
		if(eg[i].to==f){
            continue;
        }
		dfs1(eg[i].to,u);
	}
	return ;
}
int lca(int x,int y){
	if(x==y){
        return x;
    }
	if(de[x]<de[y]){
        swap(x,y);
    }
	for(int i=lg;i>=0;i--){
		if(de[fa[x][i]]>=de[y]){
            x=fa[x][i];
        }
	}
	if(x==y){
        return x;
    }
	for(int i=lg;i>=0;i--){
		if(fa[x][i]!=fa[y][i]){	
            x=fa[x][i];y=fa[y][i];
        }
	}
	return fa[x][0];
}
void adda(int id,int x){
	lp[++ca].id=id;
    lp[ca].ne=hda[x];
    hda[x]=ca;
}
void adde(int id,int x){
	ep[++ce].id=id;
    ep[ce].ne=hde[x];
    hde[x]=ce;
}
void dfs2(int u,int f){
	int dm=dl[w[u]-de[u]+N],up=ul[w[u]+de[u]];
	for(int i=hd[u];~i;i=eg[i].ne){
		if(eg[i].to==f){
            continue;
        }
		dfs2(eg[i].to,u);
	}
	ul[de[u]]+=nm[u];
	for(int i=hde[u];~i;i=ep[i].ne){
		dl[dis[ep[i].id]-de[e[ep[i].id]]+N]++;
	}
	ans[u]+=dl[w[u]-de[u]+N]-dm+ul[w[u]+de[u]]-up;
	for(int i=hda[u];~i;i=lp[i].ne){
		dl[dis[lp[i].id]-de[e[lp[i].id]]+N]--;
		ul[de[s[lp[i].id]]]--;
	}
	return ;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		hd[i]=hda[i]=hde[i]=-1;
	}
	for(int i=1,x,y;i<=n-1;i++){
		cin>>x>>y;
		add(x,y);
		add(y,x);
	}
	dfs1(1,1);
	for(int i=1;i<=n;i++){
		cin>>w[i];
	}
	for(int i=1;i<=m;i++){
		cin>>s[i]>>e[i];
		int a=lca(s[i],e[i]);
		dis[i]=de[s[i]]+de[e[i]]-de[a]*2;
		nm[s[i]]++;
		adda(i,a);
		adde(i,e[i]);
		if(de[a]+w[a]==de[s[i]]){
            ans[a]--;
        }
	}
	dfs2(1,1);
	for(int i=1;i<=n;i++){
		cout<<ans[i]<<" ";
	}
	return 0;
}
```
完结撒花~

---

## 作者：JXR_Kalcium (赞：0)

赛时打了一个 $O(nm)$ 的暴搜，结果爆掉了。这道题的思维难度较大，正解为 **LCA+树上差分**。

## 题目大意

给定一棵有 $n$ 个结点的树，编号分别为 $1\sim n$。现有 $m$ 个动点，第 $i$ 个动点的路径为 $s_i\rightarrow t_i$，第 $0$ 秒时位于 $s_i$，之后每秒经过一条 $s_i\rightarrow t_i$ 路径上的边直到到达 $t_i$。现在对于每一个观察点 $i\in[1,n]$，求出有多少动点在第 $w_i$ 秒到达观察点 $i$，数据范围 $n,m<3\times 10^5$。

## 解题思路

首先，路径 $s\rightarrow t$ 可分为两部分，一部分是 $s\rightarrow\text{LCA}(s,t)$，另一部分是 $\text{LCA}(s,t)\rightarrow t$。先看第一部分，可知如果观察点 $now$ 在这条路径上才会产生贡献，根据题目可得，若 $dep_i$ 表示点 $i$ 的深度，则 $w_{now}=dep_s-dep_{now}$，移项可得 $w_{now}+dep_{now}=dep_s$。此时可发现对于每一个观察点，$w_{now}+dep_{now}$ 都是已知的，所以只需在 $now$ 的子树中找到满足上面等式的 $s$ 即可，于是就可用桶 $P$ 维护这个个数，答案即为 $P_{w_{now}+dep_{now}}$。第二部分同理易得 $w_{now}=\left(dep_s-dep_{\text{LCA}(s,t)}\right)+\left(dep_{now}-dep_{\text{LCA}(s,t)}\right)$，移项得 $w_{now}-dep_{now}=dep_s-2dep_{\text{LCA}(s,t)}$，再开一个桶 $Q$ 维护即可。

但是很显然，不能每一个观察点都开一个桶，所以可开一个全局桶，利用树上差分，$s$ 或 $t$ 进栈就加一，到达 $\text{LCA}(s,t)$ 或 $fa_{\text{LCA}(s,t)}$ 就减一（参见上面的推导）。于是可开两个动态数组（静态会爆），$res_{x,0/1,y}$ 表示在点 $x$，在路径上第一或第二个部分，上面的等式右侧所有的值。再用 $sum_{x,0/1,y}$ 表示在点 $x$，在路径上第一或第二个部分，对桶的贡献（只能是 $\pm 1$）。这样只需跑一遍 DFS，记录上面等式左侧的值（注意第二个部分左侧可能为负数，加上 $n$ 即可）和对应两个桶里存的值，再在回溯的时候，对于当前点 $x$，使得每个 $res_{x,0/1,i}$ 分别对应的两个桶将对应的 $sum_{x,0/1,i}$ 累加，最后当前点的答案就是之前预处理的等式左侧的值对应的两个桶现在的值减去原先进栈的答案。

## AC 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define endl putchar(10)
#define spc putchar(32)
#define R register
using namespace std;
#ifndef ONLINE_JUDGE
#define debug(x) cerr << #x << " = " << x, endl
#endif

inline ll read()
{
    ll x=0,f=1; char c=getchar();

    while(c<48 || c>57)
    {
        if(c=='-') f=-1;
        c=getchar();
    }

    while(c>47 && c<58)
    x=(x<<1)+(x<<3)+c-48, c=getchar();
    return x*f;
}

inline void write(ll x)
{
    static ll sta[41]; ll top=0;
    if(x<0) putchar('-'), x=-x;
    do sta[top++]=x%10, x/=10; while(x);
    while(top) putchar(sta[--top]+48);
}

const ll mx=3e5+1;
ll n,m,u,v,w[mx],s,t,cnt,last[mx],q,ans[mx],fa[mx],d[mx],size[mx],son[mx],top[mx],f[mx],g[mx<<1];
vector<ll> res[mx][2],sum[mx][2];
struct edge {ll next,to;} e[mx<<1];
void add(ll u, ll v) {e[++cnt]={last[u],v}; last[u]=cnt;}

void dfs1(ll x)
{
    size[x]=1;

    for(R int i=last[x]; i; i=e[i].next)
    {
        if(e[i].to!=fa[x])
        {
            d[e[i].to]=d[x]+1; fa[e[i].to]=x;
            dfs1(e[i].to); size[x]+=size[e[i].to];
            if(size[e[i].to]>size[son[x]]) son[x]=e[i].to;
        }
    }
}

void dfs2(ll x, ll y)
{
    top[x]=y;
    if(!son[x]) return; dfs2(son[x],y);

    for(R int i=last[x]; i; i=e[i].next)
    {
        if(e[i].to!=son[x] && e[i].to!=fa[x])
        dfs2(e[i].to,e[i].to);
    }
}

ll lca(ll u, ll v)
{
    while(top[u]!=top[v])
    {
        if(d[top[u]]<d[top[v]]) u^=v^=u^=v;
        u=fa[top[u]];
    }

    return d[u]<d[v]?u:v;
}

void dfs(ll x)
{
    ll a=w[x]+d[x], b=w[x]-d[x]+mx, a1=f[a], b1=g[b];

    for(R int i=last[x]; i; i=e[i].next)
    {
        if(e[i].to!=fa[x])
        dfs(e[i].to);
    }

    for(R int i=0; i<res[x][0].size(); ++i) f[res[x][0][i]]+=sum[x][0][i];
    for(R int i=0; i<res[x][1].size(); ++i) g[res[x][1][i]+mx]+=sum[x][1][i];
    ans[x]+=f[a]+g[b]-a1-b1;
}

int main()
{
	n=read(); m=read();

    for(R int i=1; i<n; ++i)
    {
        u=read(); v=read();
        add(u,v); add(v,u);
    }

    dfs1(1); dfs2(1,1);
    for(R int i=1; i<=n; ++i) w[i]=read();
    
    for(R int i=1; i<=m; ++i)
    {
        s=read(); t=read(); q=lca(s,t);
        res[s][0].push_back(d[s]); res[t][1].push_back(d[s]-(d[q]<<1));
        res[q][0].push_back(d[s]); res[fa[q]][1].push_back(d[s]-(d[q]<<1));
        sum[s][0].push_back(1); sum[t][1].push_back(1);
        sum[q][0].push_back(-1); sum[fa[q]][1].push_back(-1);
    }

    dfs(1);
    for(int i=1; i<=n; ++i) write(ans[i]), spc;
    return 0;
}
```

---

## 作者：ZSYhaouuan (赞：0)

题目概括意思为：有 $m$ 个玩家，在大小为 $n$ 的树上跑步，有起点和终点。每个点上有一个观察员，有一个观察时间。求每一个观察员在当前节点的观察时间所能观察到的人数。

题目还是比较容易理解的。

那我们如何去做呢？

首先我们要弄清玩家的跑步路线是什么。在树上，有起点和终点，我们很容易想到最近公共祖先。

具体来讲，路径就是从起点到最近公共祖先到终点的过程。

很明显可以分成两个部分：起点到最近公共祖先，最近公共祖先到终点。这个我们一会再讲。

先看观察员。很明显，就这个数据范围，我们不可能模拟的，那该怎么做呢？

刚刚提到有两个部分，我们先从第一部分分析：即起点到最近公共祖先，这一段路径和观察员能观察到的位置有什么关系？

就可以借着样例，画棵树，然后研究。可以看出来：观察员的深度加上观察员的观察时间的值为玩家起点深度，那么就可以被观察到。

然后再观察第二部分：最近公共祖先到终点。

照葫芦画瓢，仍然可以研究深度和时间的关系：观察员的深度减上观察员的观察时间的值为玩家起点深度，可以观察到。

注意：两者唯一区别就是加和减。

那么，只要把第一部分和第二部分的满足数量加起来，就是最终答案了。

由于我们不需要明确知道每个玩家的起点深度和观察员观察时间：事实上，只需要知道他们的和和差即可，然后计数。

这就用桶计数即可！这样就无需遍历所有的玩家信息，效率大大提升。

不过仍需要注意，编码时，要注意桶的标记的挂上去，一定要记得取下来！！！

所以，这是一道最近公共祖先，树上差分，桶计数的一道题，要注意的细节还蛮多的。

代码如下：


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll maxn = 3e5+10;
vector<ll> add1[maxn], add2[maxn], era1[maxn], era2[maxn];
ll m1[2 * maxn], m2[2 * maxn];
vector<ll> G[maxn];
ll n, m;
ll ans[maxn], w[maxn], dep[maxn], fa[maxn][25];
void dfs(ll u, ll f, ll d) {
	dep[u] = d;
	fa[u][0] = f;
	for (ll i = 1; i <= 22; i++) {
		fa[u][i] = fa[fa[u][i - 1]][i - 1];
	}
	for (auto y : G[u]) {
		if (y != f) dfs(y, u, d + 1);
	}
	return;
}
ll lca(ll x, ll y) {
	if (dep[x] < dep[y]) swap(x, y);
	for (ll i = 20; i >= 0; i--) {
		if (dep[x] - (1 << i) >= dep[y]) x = fa[x][i];
	}
	if (x == y) return x;
	for (ll i = 20; i >= 0; i--) {
		if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];
	}
	return fa[x][0];
}
void dfs2(ll u, ll f) {
	ll t1 = m1[dep[u] + w[u]], t2 = m2[dep[u] - w[u] + maxn];
	for (auto v : G[u]) if (v != f) dfs2(v, u);
	for (auto &a1 : add1[u]) m1[a1]++;
	for (auto &a2 : add2[u]) m2[a2 + maxn]++;
	ans[u] += m1[dep[u] + w[u]] - t1 + m2[dep[u] - w[u] + maxn] - t2;
	for (auto &e1 : era1[u]) m1[e1]--;
	for (auto &e2 : era2[u]) m2[e2 + maxn]--;
	return;
}
int main() {
	cin >> n >> m;
	for (ll i = 1; i <= n - 1; i++) {
		ll u, v;
		cin >> u >> v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	for (ll i = 1; i <= n; i++) cin >> w[i];
	dfs(1, 0, 1);
	for (ll i = 1; i <= m; i++) {
		ll u, v;
		cin >> u >> v;
		ll p = lca(u, v);
		ll dis = dep[u] - dep[p] + dep[v] - dep[p];
		add1[u].push_back(dep[u]);
		era1[p].push_back(dep[u]);
		add2[v].push_back(dep[v] - dis);
		era2[p].push_back(dep[v] - dis);
		if (dep[p] + w[p] == dep[u]) ans[p]--;
	}
	dfs2(1, 0);
	for (ll i = 1; i <= n; i++) cout << ans[i] << " ";
	return 0;
}
```

总结：考思维含量的题，但最近公共祖先部分都是模板。

---


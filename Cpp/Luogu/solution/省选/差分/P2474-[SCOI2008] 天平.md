# [SCOI2008] 天平

## 题目描述

你有 $n$ 个砝码，均为 $1$ 克，$2$ 克或者 $3$ 克。你并不清楚每个砝码的重量，但你知道其中一些砝码重量的大小关系。你把其中两个砝码 A 和 B 放在天平的左边，需要另外选出两个砝码放在天平的右边。问：有多少种选法使得天平的左边重($c_1$)、一样重($c_2$)、右边重($c_3$)？（只有结果保证唯一确定的选法才统计在内）


## 说明/提示

$4\le n\le 50$。


## 样例 #1

### 输入

```
6 2 5
?+????
-?+???
?-????
????+?
???-?+
????-?```

### 输出

```
1 4 1```

## 样例 #2

### 输入

```
14 8 4
?+???++?????++
-??=?=???????=
??????????=???
?=??+?==??????
???-???-???-??
-=????????????
-??=???=?-+???
???=+?=???????
??????????????
??????+???????
??=???-????-??
????+?????+???
-?????????????
-=????????????```

### 输出

```
18 12 11```

# 题解

## 作者：liangbowen (赞：67)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P2474)

[更好的阅读体验？](https://www.cnblogs.com/liangbowen/p/16875841.html)

差分约束。

update：修改了 $\LaTeX$，这下应该正常了。

## 思路

### 预处理

维护两个数组 $mn_{i, j}$ 与 $mx_{i, j}$，表示砝码 $i$ 与砝码 $j$ **重量差值**的**最小最大**。

我们分类讨论：

1. $i = j$，显然 $mx = mn = 0$。
2. $a_{i, j}$ 为 `=`，$mx = mn = 0$，因为关系已经固定。
3. $a_{i, j}$ 为 `+`，差值最大：$a_i=3$，$a_j=1$。最小：$a_i=2$，$a_j=1$。所以 $mx = 2, mn = 1$。
4. $a_{i, j}$ 为 `-`，与上面反过来，$mx = -1, mn = -2$。
4. $a_{i, j}$ 为 `?`，差值最大：$a_i=3$，$a_j=1$。最小反过来。所以 $mx = 2, mn = -2$。

### 差分约束

统计完基本信息后，就可以差分约束了。

由于数据范围很小（$n \le 50$），并且统计答案时需要全局统计，所以用 Floyd 就可以了。

转移：（$1 \le k \le n$）

$\begin{cases}mx_{i, j} = \min\{mx_{i, k} + mx_{k, j}\}\\
mn_{i, j} = \max\{mn_{i, k} + mn_{k, j}\}\end{cases}$

反向取上下界，应该很容易理解吧。

### 统计答案

对于所有 $i \ne A$ 且 $j \ne B$ 且 $i \ne j$ 的两个砝码 $i, j$，统计答案。

同样是分类讨论：

1. 如果 $mn_{A, i} > mx_{j, B}$ 或者 $mn_{A, j} > mx_{i, B}$，说明左边有可能重。

2. 如果 $mn_{A, i} = mx_{A, i} = mn_{j, B} = mx_{j, B}$，说明有可能相等；
   同理，如果 $mn_{B, i} = mx_{B, i} = mn_{j, A} = mx_{j, A}$，也有可能相等；

3. 与左边重的情况相反，如果 $mn_{A, i} < mx_{j, B}$ 或者 $mn_{A, j} < mx_{i, B}$，说明右边有可能重。

统计好后输出即可。这道题就完美的做完啦！

## 完整代码

略微压行，凑合着看看吧，应该很容易看懂。

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int N = 55;
int n, A, B;
int maxd[N][N], mind[N][N]; //maxd[i][j] 或 mind[i][j] 表示：砝码 i 与砝码 j 重量差值 的最值。 
void Input()
{
	scanf("%d%d%d", &n, &A, &B);
	for  (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
		{
			char x;
			cin >> x;
			if (i == j || x == '=') maxd[i][j] = mind[i][j] = 0; //别忘了：同一块砝码，最值都是 0。 
			else if (x == '+') maxd[i][j] = 2, mind[i][j] = 1; //差值最大：a[i]=3，a[j]=1。最小：a[i]=2，a[j]=1。 
			else if (x == '-') maxd[i][j] = -1, mind[i][j] = -2; //恰好与上面反过来。
			else if (x == '?') maxd[i][j] = 2, mind[i][j] = -2; //差值最大：a[i]=3，a[j]=1。最小：a[i]=1，a[j]=3。
		}
}
void Floyd() //差分约束
{
	for (int k = 1; k <= n; k++)
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++)
				maxd[i][j] = min(maxd[i][j], maxd[i][k] + maxd[k][j]),
				mind[i][j] = max(mind[i][j], mind[i][k] + mind[k][j]);
}
void Output()
{
	int lcnt = 0, ecnt = 0, rcnt = 0;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j < i; j++)
		{
			//要保证 i 与 j 均不是给定砝码。 
			if (i == A || i == B) break;
			if (j == A || j == B) continue;
			if (mind[A][i] > maxd[j][B] || mind[A][j] > maxd[i][B]) lcnt++;
			
			if (mind[A][i] == maxd[A][i] && mind[A][i] == mind[j][B] && mind[j][B] == maxd[j][B]) ecnt++;
			else if (mind[B][i] == maxd[B][i] && mind[B][i] == mind[j][A] && mind[j][A] == maxd[j][A]) ecnt++;
			
			if (maxd[A][i] < mind[j][B] || maxd[A][j] < mind[i][B]) rcnt++;
		}
	printf("%d %d %d", lcnt, ecnt, rcnt);
}
int main()
{
	//程序三段式，十分清晰美观。 
	Input();
	Floyd();
	Output();
	return 0;
}
```

希望能帮助到大家！

---

## 作者：Holmes (赞：37)

A+B>C+D <=> A-C>D-B 由此我们可以使用差分约束，用数组dx[i][j],dn[i][j]分别表示 i-j 的最大值和最小值，使用Floyd......代码如下，附有备注。

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<iostream>
#include<cstdlib>
using namespace std;
int n,s1,s2;
int dx[55][55],dn[55][55];
int main()
{
    scanf("%d%d%d",&n,&s1,&s2);
    char a[60];
    for(int i=1;i<=n;i++){
        scanf("%s",a);
        for(int j=0;j<strlen(a);j++){
            if(a[j]=='=' || i==j+1){
                dn[i][j+1]=0;dx[i][j+1]=0;
            } else if(a[j]=='+') {
                dx[i][j+1]=2;  dn[i][j+1]=1;  //i-j<=2; i-j>=1;
            }else if(a[j]=='-'){
                dx[i][j+1]=-1; dn[i][j+1]=-2; //i-j<=-1;i-j>=-2;
            }else {
                dx[i][j+1]=2;  dn[i][j+1]=-2; //i-j<=2; i-j>=-2;
            }
        }
    }
    
    
    for(int k=1;k<=n;k++)            //Floyd
        for(int i=1;i<=n;i++) {  
            if(i==k) continue;    
            for(int j=1;j<=n;j++){
                if(i==k || i==j) continue;
                dx[i][j]=min(dx[i][j],dx[i][k]+dx[k][j]);//上界求最短路
                dn[i][j]=max(dn[i][k]+dn[k][j],dn[i][j]);//下界求最长路 
            }
        }
    
    
    int c1=0,c2=0,c3=0;
    for(int i=1;i<=n;i++){                 //暴力枚举所有可能性  
        if(i==s1 || i==s2) continue;
        for(int j=1;j<i;j++){
            if(j==s1 || j==s2) continue;
            if(dn[s1][i]>dx[j][s2] || dn[s2][i]>dx[j][s1])
                c1++;      //s1-i的最小值大于j-s2的最大值==>s1+s2>i+j
            if(dn[i][s1]>dx[s2][j] || dn[i][s2]>dx[s1][j])
                c3++;      //同理：i-s1>s2-j ==> i+j>s1+s2
            if((dn[s1][i]==dx[s1][i] && dn[j][s2]==dx[j][s2] && dn[s1][i]==dn[j][s2]) || 
            (dn[s1][j]==dx[s1][j] && dn[i][s2]==dx[i][s2] && dn[s1][j]==dn[i][s2]))
                c2++;     //关系确定且满足的点 
        }
    }
    printf("%d %d %d",c1,c2,c3);
    return 0;
}
```

---

## 作者：A_Sunny_Day (赞：17)

## SCOI 2008 天平 差分约束

题目链接：[SCOI2008天平](https://www.luogu.com.cn/problem/P2474)

---

​	首先想到我们要根据给出的重量关系矩阵列出的式子。但是这个矩阵给的只是**关系**，所以我们列出的只能是不等式组。看到不等式，那么立马联想到这是可以转化一组**差分约束系统**。但是我们目前知道的信息只有 $w_i<w_j$，我们得想办法把它转化成形如 $w_i-w_j<c_k$ 的式子。注意到，题目给出了任意一个砝码的质量 $w_i\in{1,2,3}$。所以我们可以得知两个砝码质量相减的最大差值和最小差值，我们设 $dmx_{i,j},dmi_{i,j}$ 分别表示 $w_i-w_j$ 可能的最大值和最小值。 同时，由于这题的数据规模并不大，我们可以采取邻接矩阵的方式来存储图。那么初始化程序就显然了，代码如下：

```cpp
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=n;++j)
		{
			if(s[i][j]=='=') dmx[i][j]=dmi[i][j]=0;
			else if(s[i][j]=='+') dmx[i][j]=2,dmi[i][j]=1;
			else if(s[i][j]=='-') dmx[i][j]=-1,dmi[i][j]=-2;
			else dmx[i][j]=2,dmi[i][j]=-2;
		}
	}
	for(int i=1;i<=n;++i)
		dmx[i][i]=dmi[i][i]=0;
```

​	常规的差分约束系统的求解方式多数是建立超级源点求单源最短路得到**满足**差分约束系统的一组解，但是这里我们注意到，我们要求解的目标**不同于**其他一般的差分约束的题，其他的差分约束题可能只需要判断有无解就行了，但是这题我们不一样，我们要求出**确定关系对**的个数。所以单源最短路求出一组解的办法在这题是没有用处的。这也是为什么我们上面对于一条式子 $c_k\ge w_i-w_j\ge d_k$ 这种式子不建两条边而是用两个邻接矩阵去存储的原因。我们需要**拓展**差分约束系统中的关系。即，求出每一对 $i,j$ 的 $dmx_{i,j},dmi_{i,j}$。那么扩展的转移式则为：
$$
\begin{aligned}
dmx_{i,j} &=\min(dmx_{i,k}+dmx_{k,j})
\\
dmi_{i,j} &=\max(dmi_{i,k}+dmi_{k,j})
\end{aligned}
$$
​	为什么 $dmx$ 的转移要取 $\min$ 而 $dmi$ 的转移要取 $\max$ 呢。因为对于 $dmx_{i,j}$ 和 $dmx_{i,j}$ 的值 $c_k$。我们可以把它理解成 $w_i-w_j\le c_k$。而后面那条式子要理解成：
$$
\begin{aligned}
w_i-w_k-(w_k-w_j)\le c_u-c_v
\\
w_i-w_j\le c_u-c_v
\end{aligned}
$$
​	说明 $w_i-w_j$ 是同时满足小于等于 $c_k,c_u-c_v$ 的。所以取两者较小值。同理对于 $dmi$ 要取较大值。

​	再回到上面的转移式。我们可以注意到这条转移式有点类似于**最短/长路的求解**。也就是我们绕了一圈子又回到了原点。但是这次我们要求的，是**全源最短路**。注意到 $n$ 的范围并不大，所以用 Floyd 来求解这个问题。

​	最后我们要做的，就是根据已知信息求解答案。由于我们上述式子求出的是 $w_i-w_j$ 的关系，所以我们判定答案也要围绕这一形式的式子。对于左边比右边重的情况就是 $w_A-w_i+w_B-w_j>0$。由于我们要保证结果唯一，所以我们得保证这条式子对于我们求出的关系**恒成立**。所以我们可以用 $dmi_{A,i},dmi_{B,i}$ 来判定。同理的，对于右边比左边重的情况就是用 $dmx_{A,i},dmx{B,i}$ 来判定。相等的情况，因为我们要保证相等，就是 $dmx_{A,i}=dmx_{B,j}$ 且 $dmi_{A,i}=dmx_{B,j}$ 且 $dmi_{A,i}+dmi_{B,j}=0$。

​	统计部分代码如下：

```cpp
	for(int i=1;i<=n;++i)
	{
		for(int j=i+1;j<=n;++j)
		{
			if(i==A||i==B||j==A||j==B) continue;
			if(dmi[A][i]+dmi[B][j]>0||dmi[A][j]+dmi[B][i]>0) ++c1;
			if(dmx[A][i]+dmx[B][j]<0||dmx[A][j]+dmx[B][i]<0) ++c3;
			if(dmi[A][i]==dmx[A][i]&&dmi[j][B]==dmx[j][B]&&dmi[A][i]+dmi[B][j]==0) ++c2;
			else if(dmi[A][j]==dmx[A][j]&&dmi[i][B]==dmx[i][B]&&dmi[A][j]+dmi[B][i]==0) ++c2;
		}
	}
```

​	此题是差分约束好题，同时也告诉我们差分约束系统和最短路之间~~暧昧~~千丝万缕的关系。

全部代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN =55;
int n,A,B;
int dmx[MAXN][MAXN],dmi[MAXN][MAXN];
char s[MAXN][MAXN];
int main()
{
	scanf("%d %d %d",&n,&A,&B);
	for(int i=1;i<=n;++i)
		scanf("%s",s[i]+1);
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=n;++j)
		{
			if(s[i][j]=='=') dmx[i][j]=dmi[i][j]=0;
			else if(s[i][j]=='+') dmx[i][j]=2,dmi[i][j]=1;
			else if(s[i][j]=='-') dmx[i][j]=-1,dmi[i][j]=-2;
			else dmx[i][j]=2,dmi[i][j]=-2;
		}
	}
	for(int i=1;i<=n;++i)
		dmx[i][i]=dmi[i][i]=0;
	for(int k=1;k<=n;++k)
		for(int i=1;i<=n;++i)
			for(int j=1;j<=n;++j)
			{
				dmx[i][j]=min(dmx[i][k]+dmx[k][j],dmx[i][j]);
				dmi[i][j]=max(dmi[i][k]+dmi[k][j],dmi[i][j]);
			}
	int c1=0,c2=0,c3=0;
	for(int i=1;i<=n;++i)
	{
		for(int j=i+1;j<=n;++j)
		{
			if(i==A||i==B||j==A||j==B) continue;
			if(dmi[A][i]+dmi[B][j]>0||dmi[A][j]+dmi[B][i]>0) ++c1;
			if(dmx[A][i]+dmx[B][j]<0||dmx[A][j]+dmx[B][i]<0) ++c3;
			if(dmi[A][i]==dmx[A][i]&&dmi[j][B]==dmx[j][B]&&dmi[A][i]+dmi[B][j]==0) ++c2;
			else if(dmi[A][j]==dmx[A][j]&&dmi[i][B]==dmx[i][B]&&dmi[A][j]+dmi[B][i]==0) ++c2;
		}
	}
	printf("%d %d %d\n",c1,c2,c3);
	return 0;
}
```

​	总结：看到不等式就要想到差分约束，看到差分约束就要想到最短路。



---

## 作者：nofind (赞：15)

题意:https://www.luogu.org/problem/P2474

显然是差分约束,考虑用floyd解决

定义:

$dmax[i][j]$表示$i-j$的最大为多少,$dmin[i][j]$表示$i-j$最小为多少

对于给出的关系:

1.$i=j$ 

$dmax[i][j]=dmin[i][j]=0$

同一个数自然为0

2.$i + j$ 

$dmax[i][j]=2,dmin[i][j]=1$

$j+1<=i$ 

$1=<i-j<=2$

3.$i - j$

$dmax[i][j]=-1,dmin[i][j]=-2;$

就相当于$i+j$反过来

4.$i?j$ 

$dmax[i][j]=2,dmin[i][j]=-2$

直接取上下界即可

floyd处理出dmin和dmax后,枚举C和D,判断是否满足条件即可

1.$A+B>C+D$ 

$A-C>D-B / B-C>D-A$

2.$A+B=C+D$

$MIN(A-C)=MAX(A-C)=MIN(D-B)=MAX(D-B)$

或

$MIN(B-C)=MAX(B-C)=MIN(D-A)=MAX(D-A)$

3.$A+B<C+D$

$C-A<B-D/C-B<A-D$

code:

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=55;
int n,A,B,cnt1,cnt2,cnt3;
int dmax[maxn][maxn],dmin[maxn][maxn];
char s[maxn][maxn];
int main()
{
	scanf("%d%d%d",&n,&A,&B);
	for(int i=1;i<=n;i++)scanf("%s",s[i]+1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(s[i][j]=='='||i==j)dmax[i][j]=dmin[i][j]=0;
			else if(s[i][j]=='+')dmax[i][j]=2,dmin[i][j]=1;
			else if(s[i][j]=='-')dmax[i][j]=-1,dmin[i][j]=-2;
			else dmax[i][j]=2,dmin[i][j]=-2;
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				dmax[i][j]=min(dmax[i][j],dmax[i][k]+dmax[k][j]),dmin[i][j]=max(dmin[i][j],dmin[i][k]+dmin[k][j]);
	for(int i=1;i<=n;i++)
	{
		if(i==A||i==B)continue;
		for(int j=1;j<i;j++)
		{
			if(j==A||j==B)continue;
			if(dmin[A][i]>dmax[j][B]||dmin[B][i]>dmax[j][A])cnt1++;
			if(dmax[B][j]<dmin[i][A]||dmax[A][j]<dmin[i][B])cnt3++;
			if((dmax[A][i]==dmin[A][i]&&dmax[j][B]==dmin[j][B]&&dmax[A][i]==dmax[j][B])||(dmax[A][j]==dmin[A][j]&&dmax[i][B]==dmin[i][B]&&dmax[A][j]==dmax[i][B]))
				cnt2++;
		}
	}
	printf("%d %d %d",cnt1,cnt2,cnt3);
	return 0;
}
```


---

## 作者：Hexarhy (赞：7)

### Preface

差分约束进阶题，有助于加深印象，也避免了对模板的固化。

刚开始写了 SPFA 后来发现不如 Floyd 方便就重构代码了……

### Solution

题目有 $3$ 个问题，不妨先对 $A+B>C+D$ 进行思考。

原不等式等价于 $A-C>D-B$ 或 $A-D>C-B$。显然，数据量允许我们暴力枚举 $C,D$ 判断是否成立。

传统的差分约束是直接求出一组解。但这里直接的搭配的解不唯一很不方便，我们尝试维护变量间的和差关系以直接满足不等关系。

此时，我们就可以设 $f(u,v)$ 为 $u,v$ 的 $\max\{u-v\}$，$g(u,v)=\min\{u-v\}$。$u-v\le f(u,v)$ 或 $u-v\ge g(u,v)$ 相当于从 $v$ 出发到 $u$ 的最短/长路。而暴力枚举 $C,D$ 就要求我们跑全源最短路。

即，跑两次 Floyd，一次跑最短路得到 $f(u,v)$，一次跑最长路得到 $g(u,v)$。

----------

用邻接矩阵建图的时候，

- 对于`+`，$i>j$，即 $i-j>0$，可以得到 $i-j=1$ 或 $i-j=2$，于是就有 $f(i,j)=2,g(i,j)=1$。

- 对于`-`，有 $i-j=-1$ 或 $i-j=-2$，即 $f(i,j)=-1,g(i,j)=-2$。

- 对于`=`，有 $i=j$，即 $f(i,j)=g(i,j)=0$。

- 对于`?`，$i,j$ 关系未知，就假设两种最极端的情况，把 $f(i,j)=2,g(i,j)=-2$。

----------

接下来就是如何判断不等关系成立。

对于 $A-C>D-B$，显然为了使结果唯一，必须使得 $g(A,C)>f(D,B)$，即前者的最小值都已经比后者的最大值还要大，那么结果肯定是唯一的左边大于右边。

同理，对于 $A-D>C-B$，就要使得 $g(A,D)>f(D,B)$。两个条件显然只要满足一个即可，用逻辑或连接。

将上述做法推广到 $3$ 个问题即可。

- 对于 $A+B=C+D$，等价于 $A-D=C-B$ 或 $A-C=D-B$，即 $f(A,D)=g(C,B)=g(A,D)=f(C,B)$ 或 $f(A,C)=g(D,B)=g(A,C)=f(D,B)$。

- 对于 $A+B<C+D$，等价于 $A-C<D-B$ 或 $A-D<C-B$，即 $f(A,C)<g(D,B)$ 或 $f(A,D)<g(C,B)$。

时间复杂度 $O(n^3)$。

### Notice

由于我们要对多个问进行统计答案，于是可以写个函数来多次调用，传参的时候给一个 lambda 表达式来当作比较函数即可。可以减少码量并方便调试。**需要C++11。**

其余的只是代码繁琐而已，细心就行。

### Code

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;

typedef const int cint;
cint MAXN=55;
int n,A,B;
int minn[MAXN][MAXN],maxx[MAXN][MAXN];

template<typename Comp>
void floyd(int dis[MAXN][MAXN],const Comp func)
{
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				if(i!=k && k!=j && i!=j)
					dis[i][j]=func(dis[i][j],dis[i][k]+dis[k][j]);
}

template<typename Comp>
void solve(const Comp cmp)
{
	int ans=0;
	for(int i=1;i<=n;i++)
		if(i!=A && i!=B)
			for(int j=i+1;j<=n;j++)
				if(j!=A && j!=B)
					if(cmp(A,B,i,j))
						ans++;
	cout<<ans<<' ';
}

int main()
{
	ios::sync_with_stdio(false);
	cin>>n>>A>>B;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			char ch;cin>>ch;
			if(ch=='+')
			{
				maxx[i][j]=2;
				minn[i][j]=1;
			}
			if(ch=='-')
			{
				maxx[i][j]=-1;
				minn[i][j]=-2;
			}
			if(ch=='?')
			{
				maxx[i][j]=2;
				minn[i][j]=-2;
			}
		}
	floyd(maxx,[&](cint a,cint b){return a<b?a:b;});
	floyd(minn,[&](cint a,cint b){return a>b?a:b;});
	solve([&](cint a,cint b,cint c,cint d)
	{
		return minn[a][c]>maxx[d][b] || minn[a][d]>maxx[c][b];
	});
	solve([&](cint a,cint b,cint c,cint d)
	{
		return (minn[a][c]==maxx[d][b] && maxx[a][c]==minn[d][b] && minn[d][b]==maxx[d][b])
			|| (minn[a][d]==maxx[c][b] && maxx[a][d]==minn[c][b] && minn[c][b]==maxx[c][b]);
	});
	solve([&](cint a,cint b,cint c,cint d)
	{
		return maxx[a][c]<minn[d][b] || maxx[a][d]<minn[c][b];
	});
	cout<<endl;
	return 0;
}
```

---

## 作者：Phartial (赞：7)

相等关系可以简单的用并查集缩点，缩点后我们就得到了一个最长路 $\le 3$ 的 DAG。

考虑枚举放在右边的两个砝码 $C,D$，并枚举天平上的四个砝码的值 $v_A,v_B,v_C,v_D$。

对 DAG 上的每个点 $i$，我们维护它的可能最小值 $l_i$ 和可能最大值 $r_i$，那么就可以从 $A,B,C,D$ 出发进行 dfs，并在 dfs 的过程中根据大小关系更新 $l_i$ 与 $r_i$（如果是无效更新的话可以直接退出）。最后校验该方案是否矛盾，即可确定这组方案是否合法。若合法，更新 $v_A+v_B$ 和 $v_C+v_D$ 的大小关系，如果只存在一种大小关系，就可以将其累加进对应的答案。

总时间复杂度 $\mathcal{O}(n^3v^4)$，本题中 $v=3$。

```cpp
#include <iostream>
#include <numeric>

using namespace std;

const int kN = 51;

int n, d0, d1, f[kN], vl[kN], vr[kN], s[3];
char a[kN][kN], ra[kN][kN];
bool ir[kN];

int F(int x) { return x == f[x] ? x : (f[x] = F(f[x])); }
bool D(int x, int l, int r) {
  if (l <= vl[x] && vr[x] <= r) {
    return 1;
  }
  vl[x] = max(vl[x], l), vr[x] = min(vr[x], r);
  if (vl[x] > vr[x]) {  // 矛盾
    return 0;
  }
  for (int i = 1; i <= n; ++i) {
    if (ir[i] && (ra[x][i] == '+' && !D(i, 1, vr[x] - 1) || ra[x][i] == '-' && !D(i, vl[x] + 1, 3))) {
      return 0;
    }
  }
  return 1;
}

int main() {
  ios_base::sync_with_stdio(0), cin.tie(0);
  cin >> n >> d0 >> d1;
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= n; ++j) {
      cin >> a[i][j];
    }
  }
  iota(f + 1, f + n + 1, 1);
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= n; ++j) {
      if (a[i][j] == '=') {
        f[F(i)] = F(j);
      }
    }
  }
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= n; ++j) {
      ra[i][j] = '?';
    }
  }
  for (int i = 1; i <= n; ++i) {
    if (ir[i] = (i == F(i))) {
      for (int j = 1; j <= n; ++j) {
        if (F(j) == i) {
          for (int k = 1; k <= n; ++k) {
            if (F(k) != i && a[j][k] != '?') {
              ra[i][F(k)] = a[j][k];  // 缩点
            }
          }
        }
      }
    }
  }
  for (int d2 = 1; d2 <= n; ++d2) {
    if (d2 != d0 && d2 != d1) {
      for (int d3 = d2 + 1; d3 <= n; ++d3) {
        if (d3 != d0 && d3 != d1) {
          int p = -1;
          for (int v0 = 1; v0 <= 3 && p != -2; ++v0) {
            for (int v1 = 1; v1 <= 3 && p != -2; ++v1) {
              for (int v2 = 1; v2 <= 3 && p != -2; ++v2) {
                for (int v3 = 1; v3 <= 3 && p != -2; ++v3) {
                  for (int i = 1; i <= n; ++i) {
                    vl[i] = 1, vr[i] = 3;
                  }
                  if (D(F(d0), v0, v0) && D(F(d1), v1, v1) && D(F(d2), v2, v2) && D(F(d3), v3, v3)) {  // 校验方案是否合法
                    // 更新大小关系，-2 表示存在多种关系，此时可直接退出
                    if (v0 + v1 > v2 + v3) {
                      p = (p == -1 || p == 0 ? 0 : -2);
                    } else if (v0 + v1 == v2 + v3) {
                      p = (p == -1 || p == 1 ? 1 : -2);
                    } else {
                      p = (p == -1 || p == 2 ? 2 : -2);
                    }
                  }
                }
              }
            }
          }
          if (p >= 0) {  // 更新答案
            ++s[p];
          }
        }
      }
    }
  }
  cout << s[0] << ' ' << s[1] << ' ' << s[2];
  return 0;
}
```


---

## 作者：dayz_break404 (赞：6)

一道差分约束好题。

## 题目描述

有 $n$ 个砝码，所有砝码有 $3$ 种：$1$ 克，$2$ 克，$3$ 克。

给出 $n$ 个砝码之间的关系，并点出所有砝码中的两个砝码的编号 $A$ 与 $B$，将这两个砝码一起放置在天平左端，并将除了 $A$ 和 $B$ 之外的其他砝码中选两个放在天平的右端。求左端重的方案数，一样重的方案数，右端重的方案数。

数据很小，$n \le 50$。~~（随便搞~~

## 题目分析

只给出砝码之间的两两关系，不容易求得每个砝码的具体重量。

尝试从答案入手，~~由果及因~~，设其他选出的两个砝码编号为 $C$ 和 $D$。假使此时是左端重，则 $A+B>C+D$，则应满足 $A-C>D-B$ 或 $A-D>C-B$。

为了判断差的大小，容易想到维护两个数组 $fx_{i,j}$ 与 $fn_{i,j}$，分别表示 $i-j$ 的可能的最大值和最小值。判断大小的时候比较数组 $fx$ 和 $fn$ 就可以了。

这样，对于每个条件，我们做出如下操作：

- 若关系为 ```=```，考虑极限情况，则 $fx_{i,j}=0$ 且 $fn_{i,j}=0$。
 
- 若关系为 ```-```，考虑极限情况，则 $fx_{i,j}=-1$ 且 $fn_{i,j}=-2$。

- 若关系为 ```+```，考虑极限情况，则 $fx_{i,j}=2$ 且 $fn_{i,j}=1$。

- 若关系为 ```?```，考虑极限情况，则 $fx_{i,j}=2$ 且 $fn_{i,j}=-2$。

- 若 $i=j$，则 $fx_{i,j}=0$ 且 $fn_{i,j}=0$。

以上其实就是建边。

建完边后跑 floyd，有点类似于传递闭包的样子将任意两点差的上下界求出来，就可以统计答案啦。

时间复杂度：$O(n^3)$

## Code

代码还是很短滴。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=70;
int n,a,b,fx[maxn][maxn],fn[maxn][maxn],cnt1,cnt2,cnt3;
char x;
inline void floyd(){
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				fx[i][j]=min(fx[i][j],fx[i][k]+fx[k][j]);
				fn[i][j]=max(fn[i][j],fn[i][k]+fn[k][j]);
			}
		}
	}
}
int main(){
	scanf("%d%d%d",&n,&a,&b);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>x;
			if(i==j||x=='=') fx[i][j]=fn[i][j]=0;
			else if(x=='-') fx[i][j]=-1,fn[i][j]=-2;
			else if(x=='+') fx[i][j]=2,fn[i][j]=1;
			else fx[i][j]=2,fn[i][j]=-2;
		}
	}
	floyd();
	for(int i=1;i<=n;i++){
		if(i==a||i==b) continue;
		for(int j=i+1;j<=n;j++){
			if(j==a||j==b) continue;
			if(fn[a][j]>fx[i][b]||fn[a][i]>fx[j][b]) cnt1++;
			if(fx[a][j]<fn[i][b]||fx[a][i]<fn[j][b]) cnt3++;
			if((fn[a][j]==fx[a][j]&&fx[a][j]==fn[i][b]&&fn[i][b]==fx[i][b])||
			(fn[a][i]==fx[j][b]&&fx[j][b]==fx[a][i]&&fx[a][i]==fn[j][b])) cnt2++;
		}
	}
	printf("%d %d %d\n",cnt1,cnt2,cnt3); 
	return 0;
}
```

写的时候注意搞清楚关系。~~希望对你有帮助qwq~~

---

## 作者：LZDQ (赞：6)

题解都是差分约束，不过这题有一个更好想的暴力。

首先我们把相等的点用并查集缩起来，缩完点之后建一张有向图，边表示大于的关系。不难发现如果有一条三个点的链，那么这三个点的取值是确定的。如果一个点不在这样的链上并且有入边，那么单看这个点的取值可以是 $1$ 或 $2$。如果有出边，那么取值可以是 $2$ 或 $3$。所以如果单看一个点可以 $\Theta(n^3)$ 预处理出这个点取值的区间。

枚举另外两个点 $c,d$ 以及 $a,b,c,d$ 这四个点的取值，除了单看一个点的取值范围限制，还要考虑这四个点之间互相影响的情况。判完两两之间的合法性后，实际上就可以了，三个点是不会互相影响的，因为三个点互相影响必须要连成一条链，而这样一条链在取值范围已经被限死了。

复杂度 $\Theta(n^3+3^4n^2)$。

~~够暴力了吧。~~

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
typedef long long ll;
using namespace std;
const int MAXN=55;
int n,a,b;
char s[MAXN][MAXN];
int pre[MAXN];
int fnd(int x){
	if(x!=pre[x]) pre[x]=fnd(pre[x]);
	return pre[x];
}
int rg[MAXN][2];
int ans[3];
int p[5],v[5];
int Check(){
	for(int i=1; i<=4; i++)
		for(int j=1; j<=4; j++){
			int x=p[i],y=p[j];
			if(s[x][y]=='='&&v[i]!=v[j]) return 0;
			if(s[x][y]=='+'&&v[i]<=v[j]) return 0;
		}
	return 1;
}
int main(){
	scanf("%d%d%d",&n,&a,&b);
	for(int i=1; i<=n; i++)
		scanf("%s",s[i]+1),pre[i]=i,rg[i][0]=1,rg[i][1]=3,s[i][i]='=';
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			if(s[i][j]=='=') pre[fnd(i)]=fnd(j);
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++){
			int x=fnd(i),y=fnd(j);
			if(s[i][j]=='+') s[x][y]='+',s[y][x]='-';
			if(s[i][j]=='-') s[x][y]='-',s[y][x]='+';
		}
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++){
			int x=fnd(i),y=fnd(j);
			if(s[x][y]=='+'){
				rg[x][0]=2,rg[x][1]=3;
				rg[y][0]=1,rg[y][1]=2;
			}
		}
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			for(int k=1; k<=n; k++){
				int x=fnd(i),y=fnd(j),z=fnd(k);
				if(s[x][y]=='+'&&s[y][z]=='+'){
					rg[x][0]=rg[x][1]=3;
					rg[y][0]=rg[y][1]=2;
					rg[z][0]=rg[z][1]=1;
				}
			}
	for(int i=1; i<=n; i++){
		if(i==a||i==b) continue;
		for(int j=i+1; j<=n; j++){
			if(j==a||j==b) continue;
			int c=fnd(i),d=fnd(j);
#define a fnd(a)
#define b fnd(b)
			p[1]=a;
			p[2]=b;
			p[3]=c;
			p[4]=d;
			int cnt[3]={0,0,0};
			for(v[1]=rg[a][0]; v[1]<=rg[a][1]; v[1]++)
				for(v[2]=rg[b][0]; v[2]<=rg[b][1]; v[2]++)
					for(v[3]=rg[c][0]; v[3]<=rg[c][1]; v[3]++)
						for(v[4]=rg[d][0]; v[4]<=rg[d][1]; v[4]++)
							cnt[(v[1]+v[2]>v[3]+v[4])+(v[1]+v[2]>=v[3]+v[4])]|=Check();
			if(cnt[0]+cnt[1]+cnt[2]==1){
				ans[0]+=cnt[0];
				ans[1]+=cnt[1];
				ans[2]+=cnt[2];
			}
		}
	}
	printf("%d %d %d\n",ans[2],ans[1],ans[0]);
	return 0;
}
```


---

## 作者：是个汉子 (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P2474)

### Solution

我们先考虑其中一个问题： $A+B>C+D$ 

可以简单的移项得到： $A-C>D-B$ 或 $A-D>C-B$ 。

看到这里你可能还不知道是什么

再看看数据范围 $4 \leq n \leq 50$ 

~~我直接暴力~~

说明我们可以找一些复杂度不太大而且和不等式有关的算法，比如**差分约束**。

但是普通的差分约束是用来求一组解的，而这里的解不唯一，所以我们可以选择维护元素之间的和差关系。

设 $minn_{u,v}$ 为 $u,v$ 的 $\min\{u-v\}$ ， $maxx_{u,v}$ 为 $u,v$ 的 $\max\{u-v\}$ ，然后就可以像差分约束一样跑最短路得到这两个数组即可。

至于求最短路的方法，因为 $4\leq n\leq 50$ 并且需要每两个点之间的 $minn,maxx$ ，所以考虑用Floyd。

---

其实这里应该贴代码的，但是我觉得应该要详细的说一下建图。

1. `+`对应的是 $i>j\rightarrow i-j>0$ ，那么可以得到 $minn_{i,j}=1,maxx_{i,j}=1$ 
2. `-`对应的是 $i<j\rightarrow j-i>0$ ， 同理，可得 $minn_{i,j}=-2,maxx_{i,j}=-1$ 
3. `=`对应的是 $i=j$  ，显然是 $maxx_{i,j}=minn_{i,j}=0$ 
4. `?`没有对应，那我们就考虑题里本来的限制 $maxx_{i,j}=2,minn_{i,j}=-2$  

---

其实这里应该完结撒花的，但是我觉得应该再说一下判断。

有三个问题：

1.  $A+B>C+D \Leftrightarrow A-C>D-B \Leftrightarrow A-D>C-B$ 
2.  $A+B=C+D\Leftrightarrow A-C=D-B\Leftrightarrow A-D=C-B$ 
3.  $A+B<C+D\Leftrightarrow A-C<D-B\Leftrightarrow A-D<C-B$  

枚举 $C,D$ 即可

### Code

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>

using namespace std;
const int N=55;
int n,a,b,ans1,ans2,ans3,maxx[N][N],minn[N][N];
char ch[N];

int main(){
    scanf("%d%d%d",&n,&a,&b);
    a--;b--;
    for(int i=0;i<n;i++){
        scanf("%s",ch);
        for(int j=0;j<n;j++)
            if(ch[j]=='='||i==j){
                maxx[i][j]=minn[i][j]=0;
            }
            else if(ch[j]=='-'){
                maxx[i][j]=-1;
                minn[i][j]=-2;
            }
            else if(ch[j]=='+'){
                maxx[i][j]=2;
                minn[i][j]=1;
            }
            else if(ch[j]=='?'){
                maxx[i][j]=2;
                minn[i][j]=-2;
            }
    }
    for(int k=0;k<n;k++)
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                if(i!=j&&j!=k&&i!=j)
                    maxx[i][j]=min(maxx[i][j],maxx[i][k]+maxx[k][j]),
                    minn[i][j]=max(minn[i][j],minn[i][k]+minn[k][j]);
    for(int c=0;c<n;c++)
        for(int d=0;d<c;d++){
            if(c==a||c==b||d==a||d==b) continue;
            if(minn[a][c]>maxx[d][b]||minn[a][d]>maxx[c][b]) ans1++;
            else if((maxx[a][c]==minn[a][c]&&maxx[d][b]==minn[d][b]&&maxx[a][c]==minn[d][b])||(maxx[a][d]==minn[a][d]&&maxx[c][b]==minn[c][b]&&maxx[a][d]==minn[c][b])) ans2++;
			else if(maxx[a][c]<minn[d][b]||maxx[a][d]<minn[c][b]) ans3++;
        }
    printf("%d %d %d\n",ans1,ans2,ans3);
    return 0;
}
```



---

## 作者：Suzt_ilymtics (赞：4)

[题面](https://www.luogu.com.cn/problem/P2474)

[更好的阅读体验？](https://www.cnblogs.com/Silymtics/p/14864634.html)

### Solution 

题目中的 “$+$” 和 “$-$” 都蕴含着大小关系，所以考虑差分约束。

对于每两个砝码之间有四种情况，我们可以分别列出他们的不等关系

- 如果是 $i = j$, 那么有 $0 \le i - j \le 0$
- 如果是 $i > j$，那么有 $1 \le i - j \le 2$
- 如果是 $i < j$, 那么有 $-2 \le i - j \le -1$
- 如果是 $?$，那么有 $-2 \le i - j \le 2$

不等式的范围取决于两个砝码 $i,j$ 极限时能取的的情况

我们要知道在所有这些约束条件都满足的情况下，**两个砝码之差**的范围

那么需要一个最大值和最小值。

我们知道差分约束中最长路可以求最小值，最短路可以求最大值，那么根据上面的不等关系拆开建边即可。

这里采用 $\text{Floyd}$ 求最短路，这样两点之间的差也好表示：

设 $Dis_{i,j}$ 是 $j - i$ 可取的最小值， $dis_{i,j}$ 是 $j - i$ 可取的最大值，即

$$Dis_{i,j} \le j-i \le dis_{i,j}$$

为什么要求**两个砝码之差**？

当统计左边重的情况时，有 $A+B>i+j$，稍微转换一下变成 $A - i > j - B$，此时出现了差的形式。对于三个统计的情况都可以这样变换。

- 当统计左边重时，有 $A+B>i+j$，转化成 $A-i>j-B$。那么只有 $A-i$ 的最小值大于 $j-B$ 的最大值或者 $B-i$ 的最小值大于 $j - A$ 的最大值才有贡献。
- 当统计右边重时，和左边的情况相反。类比推理即可。
- 当统计两边一样重时，$A+B = i+j$，转换成 $A-i = B-j$。那么只有 $A-i$ 的最小值等于 $B-j$ 的最大值并且 $A-i$ 的最大值等于 $B-j$ 的最小值 或者 $A,B$交换后成立的时候才有贡献。

和 $A,B$ 匹配的 $i,j$ 暴力枚举即可。

总的复杂度是 $O(n^3)$。

更多细节看代码。

### Code

```cpp
/*
Work by: Suzt_ilymics
Problem: 不知名屑题
Knowledge: 垃圾算法
Time: O(能过)
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define LL long long
#define orz cout<<"lkp AK IOI!"<<endl

using namespace std;
const int MAXN = 1e5+5;
const int INF = 1e9+7;
const int mod = 1e9+7;

int n, A, B;
char s[55][55];
int dis[55][55], Dis[55][55];

int read(){
    int s = 0, f = 0;
    char ch = getchar();
    while(!isdigit(ch))  f |= (ch == '-'), ch = getchar();
    while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0' , ch = getchar();
    return f ? -s : s;
}

int main()
{
    n = read(), A = read(), B = read();
    for(int i = 1; i <= n; ++i) cin >> s[i] + 1;
    for(int i = 1; i <= n; ++i) {
        for(int j = 1; j <= n; ++j) {
            if(s[i][j] == '=') {
                dis[i][j] = 0, Dis[i][j] = 0; // 0 <= i - j <= 0
            } else if(s[i][j] == '+') {
                dis[i][j] = -1, Dis[i][j] = -2; // 1 <= i - j <= 2
            } else if(s[i][j] == '-') {
                dis[i][j] = 2, Dis[i][j] = 1; // -2 <= i - j <= -1 
            } else {
                dis[i][j] = 2, Dis[i][j] = -2; // -2 <= i - j <= 2
            }
        }
    }
    for(int k = 1; k <= n; ++k) {
        for(int i = 1; i <= n; ++i) {
            if(i == k) continue;
            for(int j = 1; j <= n; ++j) {
                if(k == j || i == j) continue;
                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); // 最短路跑最大值 
                Dis[i][j] = max(Dis[i][j], Dis[i][k] + Dis[k][j]); // 最长路跑最小值 
            }
        }
    }
    int cnt1 = 0, cnt2 = 0, cnt3 = 0;
    for(int i = 1; i <= n; ++i) {
        if(i == A || i == B) continue;
        for(int j = 1; j < i; ++j) { // 暴力枚举 让每组砝码都选一遍 
            if(j == A || j == B) continue;
            if(Dis[i][A] > dis[B][j] || Dis[i][B] > dis[A][j] ) // A + B > i + j -> A - i > j - B
                cnt1++;
            if((dis[i][A] == Dis[B][j] && Dis[i][A] == dis[B][j]) || (dis[i][B] == Dis[A][j] && Dis[i][B] == dis[A][j])) // A + B == i + j
                cnt2++;
            if(Dis[A][i] > dis[j][B] || Dis[B][i] > dis[j][A] ) // A + B < i + j -> i - A > B - j
                cnt3++;
        }  
    }
    printf("%d %d %d", cnt1, cnt2, cnt3);
    return 0;
}
```







---

## 作者：S_S_H (赞：4)

被状压标题吸引过来，~~但并不知道此题与状压有何关系~~。

题意：给定天平上左边已知的两个砝码编号和砝码的相对质量关系，统计合

法状态数。

那么三种状态就可以表示为:

$(1)A+B>C+D$

$(2)A+B=C+D$

$(3)A+B<C+D$

科普一下[差分约束](https://blog.csdn.net/dragon60066/article/details/80245797)

我们了解差分约束之后，这个时候我们就可以~~乱搞~~。

我们用$maxx[ i ][ j ]$表示标号$i$的砝码与标号$j$的砝码质量差的最大值。

同理用$minn[ i ][ j ]$表示标号$i$的砝码与标号$j$的砝码质量差的最小值。

因为$n<=50$范围小，可以利用$Floyd$($dij$的$n^2log_n$貌似也可以)

求出约束图中的最短路，得到每对点间的$maxx$和$minn$。

那么

$(1)A+B>C+D<=>A-C>D-B<=>A-B>C-B$

$(2)A+B=C+D<=>A-C=D-B<=>A-D=B-C$

$(3)A+B<C+D<=>A-C<D-B<=>A-D<C-B$

对应地，我们就可以枚举$C,D$，统计答案。

这里说一下为什么一定要移项两次后用或：

因为第一个是$A$与$C$,$B$与$D$的关系，而第二个是$A$与$D$,$B$与$C$的关系。

有的同学会说：移项之后不是一样吗？

是一样...但是那是人为的，计算机可不能做到这一点。

观察一下，在求最短路过程中不一定能让两者有联系，所以统计答案时

必须用或。

$Codes:$

```cpp
#include<iostream>
#include<cstdio>
const int maxn=55;
using namespace std;
int n,a,b,ans1,ans2,ans3,maxx[maxn][maxn],minn[maxn][maxn];
char str[maxn];
int main(){
	scanf("%d%d%d",&n,&a,&b);
	a--;b--;
	for(int i=0;i<n;i++){
		scanf("%s",str);
		for(int j=0;j<n;j++)
			if(str[j]=='='||i==j){
				maxx[i][j]=0;
				minn[i][j]=0;
			}
			else if(str[j]=='-'){
				maxx[i][j]=-1;
				minn[i][j]=-2;
			}
			else if(str[j]=='+'){
				maxx[i][j]=2;
				minn[i][j]=1;
			}
			else if(str[j]=='?'){
				maxx[i][j]=2;
				minn[i][j]=-2;
			}
	}
	for(int k=0;k<n;k++)
		for(int i=0;i<n;i++)
			for(int j=0;j<n;j++)
				if(i!=j&&j!=k&&i!=j)
					maxx[i][j]=min(maxx[i][j],maxx[i][k]+maxx[k][j]),
					minn[i][j]=max(minn[i][j],minn[i][k]+minn[k][j]);
	for(int c=0;c<n;c++){
		for(int d=0;d<c;d++){
			if(c==a||c==b||d==a||d==b) continue;
			if(minn[a][c]>maxx[d][b]||minn[a][d]>maxx[c][b]) ans1++;
			else if((maxx[a][c]==minn[a][c]&&maxx[d][b]==minn[d][b]&&maxx[a][c]==minn[d][b])||(maxx[a][d]==minn[a][d]&&maxx[c][b]==minn[c][b]&&maxx[a][d]==minn[c][b])) ans2++;
			else if(maxx[a][c]<minn[d][b]||maxx[a][d]<minn[c][b]) ans3++;
			/*(1):a+b>c+d|a-c>d-b|a-d>c-b
			(2):a+b=c+d|a-c=d-b|a-d=c-b
			(3):a+b<c+d|a-c<d-b|a-d<c-b*/
		}
	}
	printf("%d %d %d\n",ans1,ans2,ans3);
	return 0;
}
```
最后祝大家$2020$ $CSP$ $NOI$ $XXXOI$ $RP++!!!$

---

## 作者：Jμdge (赞：4)

差分约束好题。

首先我们考虑某个砝码质量大于或小于另一个砝码的状况下对砝码质量（或者更确切来讲，是质量差）的限制。

又由于砝码只有 1、2、3 三种质量，我们就可以通过质量关系得到两个砝码最多差多少克、最少差多少克。然后用 floyd 对砝码间的质量差进行上下界的确定，最后 爆枚 出解就好了


```
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
const int M=55; char a[M];
int n,len,s1,s2,c1,c2,c3;
int dx[M][M],dn[M][M];
inline void cmin(int& a,int b){if(a>b)a=b;}
inline void cmax(int& a,int b){if(a<b)a=b;}
int main(){
	scanf("%d%d%d",&n,&s1,&s2);
	for(int i=1;i<=n;++i){
		scanf("%s",a),len=strlen(a);
		for(int j=0;j<len;++j)
			if(a[j]=='='||i==j+1)
				dx[i][j+1]=dn[i][j+1]=0;
			else if(a[j]=='+')
				dx[i][j+1]=2,dn[i][j+1]=1;
			else if(a[j]=='-')
				dx[i][j+1]=-1,dn[i][j+1]=-2;
			else dx[i][j+1]=2,dn[i][j+1]=-2;
	}
	for(int k=1;k<=n;++k)
		for(int i=1;i<=n;++i) if(i^k)
			for(int j=1;j<=n;++j) if(j^k&&i^j)
				cmin(dx[i][j],dx[i][k]+dx[k][j]),
				cmax(dn[i][j],dn[i][k]+dn[k][j]);
	for(int i=1;i<=n;++i)if(i^s1&&i^s2)
		for(int j=1;j<i;++j) if(j^s1&&j^s2)
			c1+=dn[s1][i]>dx[j][s2]||dn[s2][i]>dx[j][s1],
			c3+=dn[i][s1]>dx[s2][j]||dn[i][s2]>dx[s1][j],
			c2+=(dn[s1][i]==dx[s1][i]&&dn[j][s2]==dx[j][s2]&&dn[s1][i]==dn[j][s2])||
				(dn[s1][j]==dx[s1][j]&&dn[i][s2]==dx[i][s2]&&dn[s1][j]==dn[i][s2]);
	return !printf("%d %d %d\n",c1,c2,c3);
}
```

---

## 作者：chenxia25 (赞：3)

「差分约束的相对不是模板的题目」——chen_zhe

考虑将这个关系矩阵建出差分约束系统。然后还有隐含条件：$1\leq x_i\leq 3$，也一并建进去。

然后我们考虑枚举另外两个砝码，然后看应该加到 $c1,c2,c3$ 中哪一个里面去。

我们考虑枚举这四个砝码各自的重量，对于每一种看是否可能，如果可能就贡献到三种情况中的一种里面去。难点在于如何判断是否可能。

回想差分约束的理论：$x_i-x_j$ 的上限是 $dis_{j,i}$。那么这四个节点如果两两符合，那就一定有一组解符合你想要的取值，否则没有。

最短路用 Floyd；判断的话平方枚举，然后暴力枚举值。所以总复杂度 $\mathrm O\!\left(n^3+3^4n^2\right)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=50;
int n,a,b;
char mat[N+1][N+5];
int dis[N+1][N+1];
bool ok(int x,int vx,int y,int vy){return vx-vy<=dis[y][x]&&vy-vx<=dis[x][y];}
int main(){
	cin>>n>>a>>b;
	for(int i=1;i<=n;i++)cin>>mat[i]+1;
	memset(dis,0x3f,sizeof(dis));
	for(int i=0;i<=n;i++)dis[i][i]=0;
	for(int i=1;i<=n;i++)dis[i][0]=-1,dis[0][i]=3;
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++){
		if(mat[i][j]=='=')dis[i][j]=min(dis[i][j],0),dis[j][i]=min(dis[j][i],0);
		else if(mat[i][j]=='+')dis[i][j]=min(dis[i][j],-1);
		else if(mat[i][j]=='-')dis[j][i]=min(dis[j][i],-1);
	}
	for(int k=0;k<=n;k++)for(int i=0;i<=n;i++)for(int j=0;j<=n;j++)
		dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
	for(int k=0;k<=n;k++)for(int i=0;i<=n;i++)for(int j=0;j<=n;j++)
		if(dis[i][j]>dis[i][k]+dis[k][j])return puts("Fuck, this problem is shit!"),0;
//	for(int i=1;i<=n;i++){for(int j=1;j<=n;j++)cout<<dis[i][j]<<" ";puts("");}
	int c1=0,c2=0,c3=0;
	for(int i=1;i<=n;i++)if(i!=a&&i!=b)for(int j=i+1;j<=n;j++)if(j!=a&&j!=b){
		bool flg1=false,flg2=false,flg3=false;
		for(int k=1;k<=3;k++)for(int o=1;o<=3;o++)for(int p=1;p<=3;p++)for(int q=1;q<=3;q++)
			if(ok(a,k,b,o)&&ok(a,k,i,p)&&ok(a,k,j,q)&&ok(b,o,i,p)&&ok(b,o,j,q)&&ok(i,p,j,q)){
				if(k+o>p+q)flg1=true;
				else if(k+o==p+q)flg2=true;
				else flg3=true;
			}
		if(flg1&&!flg2&&!flg3)c1++;
		if(!flg1&&flg2&&!flg3)c2++;
		if(!flg1&&!flg2&&flg3)c3++;
	}
	cout<<c1<<" "<<c2<<" "<<c3<<"\n";
	return 0;
}
```

---

## 作者：__Dice__ (赞：1)

$A+B>C+D $ 可以转化为 $ A-C>D-B$ ，所以我们考虑使用差分约束。

由于砝码质量只有 $1-3g$ ，所以当有砝码 $x$ 比砝码 $y$ 重的时候，有 $w_x-w_y\ge 1
$ 且 $ w_x-w_y\le 2$ 
，重量不确定的时候有 $w_x-w_y\ge -2$ 且 $w_x-w_y\le 2$ ，然后跑一遍 floyd ，就可以求到对于任意两个砝码$x$ ， $y$ ， $w_x - w_y$
  的最大值和最小值。

最后枚举放在天平右边的两个砝码，看一下是否一定满足 $ A-C>D-B$ ，$A-C<D-B $ 或者 $ A-C=D-B$ 。就可以统计了。
```cpp

#include <algorithm>

#include <cstdio>

#include <cstring>

#include <iostream>

using namespace std;

int Max[51][51], Min[51][51];

char s[51];

int n, s1, s2, c1, c2, c3;

main() {

    //freopen("balance.in", "r", stdin);

    //freopen("balance.out", "w", stdout);

    int i, j, k, l;

    cin >> n >> s1 >> s2;

    for (i = 1; i <= n; i++) {

        scanf("%s", s);

        l = strlen(s);

        for (j = 0; j < l; j++) {

            if (s[j] == '=' || i == j + 1)

                Max[i][j + 1] = 0, Min[i][j + 1] = 0;

            else if (s[j] == '+')

                Max[i][j + 1] = 2, Min[i][j + 1] = 1;

            else if (s[j] == '-')

                Max[i][j + 1] = -1, Min[i][j + 1] = -2;

            else if (s[j] == '?')

                Max[i][j + 1] = 2, Min[i][j + 1] = -2;

        }

    }

    for (k = 1; k <= n; k++)

        for (i = 1; i <= n; i++)

            if (i != k) {

                for (j = 1; j <= n; j++)

                    if (i != j && k != j) {

                        Max[i][j] = min(Max[i][j], Max[i][k] + Max[k][j]);

                        Min[i][j] = max(Min[i][j], Min[i][k] + Min[k][j]);

                    }

            }

    for (i = 1; i <= n; i++)

        if (i != s1 && i != s2) {

            for (j = 1; j < i; j++)

                if (j != s1 && j != s2) {

                    if (Min[s1][i] > Max[j][s2] || Min[s1][j] > Max[i][s2])

                        c1++;

                    if (Max[s1][i] < Min[j][s2] || Max[s2][i] < Min[j][s1])

                        c3++;

                    if ((Max[s1][i] == Min[s1][i] && Max[j][s2] == Min[j][s2] && Max[s1][i] == Max[j][s2]) || (Max[s1][j] == Min[s1][j] && Max[i][s2] == Min[i][s2] && Max[s1][j] == Max[i][s2]))

                        c2++;

                }

        }

    cout << c1 << ' ' << c2 << ' ' << c3;

    return 0;

}
``` 

---

## 作者：huangkx (赞：1)

## 思路

记砝码 $u$ 可能的重量为 $Val _ u$。

- 令 $Max _ {u, v} = \max Val _ u - Val _ v$。
- 令 $Min _ {u, v} = \min Val _ u - Val _ v$。

先按砝码间的直接关系初始化 $Max$ 和 $Min$，再用类似 $\mathcal {Floyd}$ 的 $\mathcal {DP}$ 计算出 $Max$ 和 $Min$ 的真实值。

记 $A$ 和 $B$ 为数据指定的天平左边的砝码，$C$ 和 $D$ 为程序选择的天平右边的砝码。

以如下方法转换题目中的要求（“只有结果保证唯一的选法才统计在内”）：

- $Val _ A + Val _ B > Val _ C + Val _ D \Leftrightarrow Val _ A - Val _ C > Val _ D - Val _ B \Leftrightarrow Val _ A - Val _ D > Val _ C - Val _ B \Leftrightarrow Min _ {A, C} > Max _ {D, B} \lor Min _ {A, D} > Max _ {C, B}$。
- $Val _ A + Val _ B = Val _ C + Val _ D \Leftrightarrow Val _ A - Val _ C = Val _ D - Val _ B \Leftrightarrow Val _ A - Val _ D = Val _ C - Val _ B \Leftrightarrow Max _ {A, C} = Min _ {A, C} = Max _ {D, B} = Min _ {D, B} \lor Max _ {A, D} = Min _ {A, D} = Max _ {C, B} = Min _ {C, B}$。
- $Val _ A + Val _ B < Val _ C + Val _ D \Leftrightarrow Val _ A - Val _ C < Val _ D - Val _ B \Leftrightarrow Val _ A - Val _ D < Val _ C - Val _ B \Leftrightarrow Max _ {A, C} < Min _ {D, B} \lor Max _ {A, D} < Min _ {C, B}$。

直接枚举 $C, D$，统计答案即可。

时间复杂度为 $O(n ^ 3)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace IO
{
	inline int read()
	{
		int f = 1, x = 0;
		char c = getchar();
		while(c < '0' || c > '9'){
			if(c == '-') f = -1;
			c = getchar();
		}
		while(c >= '0' && c <= '9'){
			x = x * 10 + c - '0';
			c = getchar();
		}
		return f * x;
	}
	inline void write(int x)
	{
		if(x < 0){
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace IO;
void solve();
int main()
{
	solve();
	return 0;
}
const int MAXN = 50;
int n, A, B;
int Max[MAXN + 5][MAXN + 5];
int Min[MAXN + 5][MAXN + 5];
int ans[3];
void solve()
{
	n = read(), A = read(), B = read();
	for(int u = 1; u <= n; u ++){
		for(int v = 1; v <= n; v ++){
			char c; cin >> c;
			if(c == '+') Max[u][v] = 2, Min[u][v] = 1;
			if(c == '-') Max[u][v] = - 1, Min[u][v] = - 2;
			if(c == '=') Max[u][v] = 0, Min[u][v] = 0;
			if(c == '?') Max[u][v] = 2, Min[u][v] = - 2;
		}
	}
	for(int w = 1; w <= n; w ++){
		for(int u = 1; u <= n; u ++){
			for(int v = 1; v <= n; v ++){
				if(w == u || w == v || u == v) continue;
				Max[u][v] = min(Max[u][v], Max[u][w] + Max[w][v]);
				Min[u][v] = max(Min[u][v], Min[u][w] + Min[w][v]);
			}
		}
	}
	for(int C = 1; C <= n; C ++){
		for(int D = C + 1; D <= n; D ++){
			if(C == A || C == B || D == A || D == B) continue;
			if(Min[A][C] > Max[D][B] || Min[A][D] > Max[C][B]) ans[0] ++;
			if((Max[A][C] == Min[A][C] && Max[A][C] == Max[D][B] && Max[A][C] == Min[D][B]) ||
			   (Max[A][D] == Min[A][D] && Max[A][D] == Max[C][B] && Max[A][D] == Min[C][B])) ans[1] ++;
			if(Max[A][C] < Min[D][B] || Max[A][D] < Min[C][B]) ans[2] ++;
		}
	}
	write(ans[0]), putchar(' '), write(ans[1]), putchar(' '), write(ans[2]), putchar('\n');
}
```

2022.7.28

---

## 作者：kouylan (赞：1)

这道题的条件全是大小关系，所以可以先建出差分约束系统。

对于 ```=```，就是 $w_i\leq w_j+0$，$w_j\leq w_i+0$；对于 ```+```，就是 $w_j\leq w_i-1$；对于 ```-```，就是 $w_i\leq w_j-1$。同时 $1\geq w_i\leq 3$，所以可以新建一个 $0$ 号点转化这层关系。

然后又因为此题 $n$ 很小，所以可以用 floyd 跑最短路。

接下来考虑统计答案。我们可以枚举天平右盘的两个砝码的编号 $i,j$，再枚举 $a,b,i,j$ 的重量 $w_a,w_b,w_i,w_j$，判断是否合法再计数。所以现在考虑怎样判断是否合法。我们都知道，差分约束跑出来的 $dis(i,j)$ 就是 $w_j-w_i$ 的上限，所以我们只要判断一下 $dis(i,j)$ 和 $dis(j,i)$ 即可。

下面是 AC 代码。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int INF = 0x7f7f7f7f;

int n,a,b,g[55][55],c1,c2,c3;

void floyd()
{
	for(int k=0;k<=n;k++)
	for(int i=0;i<=n;i++)
	for(int j=0;j<=n;j++)
		if(g[i][k]<INF && g[k][j]<INF)
			g[i][j] = min(g[i][j],g[i][k]+g[k][j]);
}

bool legal(int x,int wx,int y,int wy)
{
	return wx-wy<=g[y][x] && wy-wx<=g[x][y];
}

signed main()
{
	memset(g,INF,sizeof(g));
	cin>>n>>a>>b;
	for(int i=0;i<=n;i++)
		g[i][i] = 0;
	for(int i=1;i<=n;i++)
		g[i][0] = -1, g[0][i] = 3;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			char ch;
			cin>>ch;
			if(ch=='=')
				g[i][j] = min(g[i][j],0ll), g[j][i] = min(g[j][i],0ll);
			else if(ch=='+')
				g[i][j] = min(g[i][j],-1ll);
			else if(ch=='-')
				g[j][i] = min(g[j][i],-1ll);
		}
	floyd();
	for(int i=1;i<=n;i++)
	for(int j=i+1;j<=n;j++)
	{
		if(i==a || i==b || j==a || j==b)
			continue;
		int f1=0,f2=0,f3=0;
		for(int wa=1;wa<=3;wa++)
		for(int wb=1;wb<=3;wb++)
		for(int wi=1;wi<=3;wi++)
		for(int wj=1;wj<=3;wj++)
		{
		if(legal(i,wi,j,wj) && legal(i,wi,a,wa) && legal(i,wi,b,wb) && legal(j,wj,a,wa) && legal(j,wj,b,wb) && legal(a,wa,b,wb))
			{
				int wl=wa+wb,wr=wi+wj;
				if(wl>wr)
					f1 = 1;
				else if(wl==wr)
					f2 = 1;
				else if(wl<wr)
					f3 = 1;
			}
		}
		if(f1 && !f2 && !f3)
			c1++;
		if(!f1 && f2 && !f3)
			c2++;
		if(!f1 && !f2 && f3)
			c3++;
	}
	cout<<c1<<' '<<c2<<' '<<c3<<endl;
	
	return 0;
}
```

祝大家 AC 愉快！

---

## 作者：luxiaomao (赞：1)

可能这篇题解稍为冗长，但倾注了作者的心血，希望能让你有所收获QAQ~

## 前言（~~废话~~）

个人感觉这道题真的是学习差分约束的好题（甚至把这道题写了也就把差分约束学得差不多了）。在思路层面，很多把具象的题目转化成抽象的最短路算法的思维，让本蒟蒻获益良多。

讲人话：其实个人的思路与题解区 dalao 们的思路在本质上一脉相承（~~看题解才会写的~~），但是本蒟蒻还是想~~水题解~~让像我一样的蒟蒻们也能把这道题理解透彻，所以有了这篇个人认为详细且好理解的题解。

## 分析

很明显，给出了若干（所有）点对之间的重量关系（权值大小关系），这是一道用差分约束解决的问题。

[如果你没有学过差分约束~](https://oi-wiki.org/graph/diff-constraints/)

但是，似乎很多差分约束模板题是求最值或者任意解，对于像本题这样求方案数的该如何解决呢？接下来进行分析。

### 题意

~~题意就不讲了~~。给出 $n$ 个重量为 $1$ 克，$2$ 克或 $3$ 克的砝码及部分重量大小关系，并指定两个砝码放到天平左边，要求选出另外两个砝码，天平左倾、右倾以及平衡的方案数。

### 预处理

总所周知，差分约束的核心思想就是建图然后跑最短路。

那么建最大值图还是最小值图？该跑最短路还是最长路？

全都要 QAQ！因为题目要求。

看一眼数据范围，$n \le 50$。我们选择和蔼可亲，能处理负权的 `Floyd`。

用 $maxx_{i,j}$ 表示第i个砝码和第j个砝码重量差的最大值。

用 $minx_{i,j}$ 表示第i个砝码和第j个砝码重量差的最小值。

建图时则有：
```cpp
char c;
scanf(" %c",&c);//%c前面加个空格，可以跳过换行、空格等空白字符，实现cin的效果。
if(c == '=' || i == j)//已经确定重量相等，则差为0。
{
	maxx[i][j] = 0;
	minx[i][j] = 0;
}
else if(c == '+')//差为正值。
{
	maxx[i][j] = 2;//取最大差：3-1=2
	minx[i][j] = 1;//取最小差：2-1=1 或 3-2=1
}
else if(c == '-')//差为负值。
{
	maxx[i][j] = -1;//取最大差：1-2=-1 或 2-3=-1
	minx[i][j] = -2;//取最小差：1-3=-2
}
else if(c == '?')//差值正负没有限制，尽量取大取小。
{
	maxx[i][j] = 2;
	minx[i][j] = -2;
}
```
### 跑最短路

`Floyd` 大家应该都会跑吧 QAQ~

需要牢记的是，求最大值需要跑最短路，求最小值需要跑最长路。（初学者：0.o）

$$ \begin{cases}maxx_{i,j}=\min(maxx_{i,j},maxx_{i,k}+maxx_{k,i})\\minx_{i,j}=\max(minx_{i,j},minx_{i,k}+minx_{k,i})\end{cases} $$
$$ i,j,k \in [1,n]$$


差分约束就是这么做的，如果不懂的话看看我上面贴的差分约束链接喔。

（具体代码见最后）

### 求出答案

是不是有童鞋觉得：前面的我也看得懂，但是答案怎么求捏？答案跟这两个 `Floyd` 的二维数组有什么关系？

其实核心思想就是分别枚举你放到天平右边的两个砝码，然后判断属于哪一种情况，并给相应情况的计数器加一。

看代码加注释。

```cpp
for(int i = 1;i < n;i++)
{
	if(i == A || i == B)//防止选到已经指定的两个砝码。
		continue;
	
	for(int j = i+1;j <= n;j++)
	{
		if(j == A || j == B)//防止选到已经指定的两个砝码。
			continue;
		
     //注意，由于题目说只有明确确定才能算数。
     //所以我们应该用一种近乎贪心的形式，例如想要检测是否右边的更重，就要考虑左边最重，右边最轻的情况。
     //这样，我们的 maxx 和 minx 两个差分数组就派上了用场~
		if(minx[A][i] > maxx[j][B] || minx[A][j] > maxx[i][B])
			++c1;
		if(maxx[A][i] < minx[j][B] || maxx[A][j] < minx[i][B])
			++c3;
			
     //同样，因为题目要求明确确定，所以对于maxx和minx还不相等的点对（即没有具体值）不计入相等情况。
		if(minx[A][i] == maxx[A][i] && minx[j][B] == maxx[j][B])
		{
			if(minx[A][i] == minx[j][B])++c2;
		}
		else if(minx[A][j] == maxx[A][j] && minx[i][B] == maxx[i][B])
		{
			if(minx[A][j] == minx[i][B])++c2;
		}
	}
}
```

## Code Time

会不会讲得很抽象？~~蒟蒻感觉自己嘴白长了。~~

那么上高清完整代码~

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,A,B;
int maxx[55][55],minx[55][55];
int c1,c2,c3;

int main()
{
	scanf("%d%d%d",&n,&A,&B);
	for(int i = 1;i <= n;i++)
	{
		for(int j = 1;j <= n;j++)
		{
			char c;
			scanf(" %c",&c);
			if(c == '=' || i == j)
			{
				maxx[i][j] = 0;
				minx[i][j] = 0;
			}
			else if(c == '+')
			{
				maxx[i][j] = 2;
				minx[i][j] = 1;
			}
			else if(c == '-')
			{
				maxx[i][j] = -1;
				minx[i][j] = -2;
			}
			else if(c == '?')
			{
				maxx[i][j] = 2;
				minx[i][j] = -2;
			}
		}
	}
	
	for(int k = 1;k <= n;k++)
	{
		for(int i = 1;i <= n;i++)
		{
			for(int j = 1;j <= n;j++)
			{
				maxx[i][j] = min(maxx[i][j],maxx[i][k] + maxx[k][j]);
				minx[i][j] = max(minx[i][j],minx[i][k] + minx[k][j]);
			}
		}
	}
	
	for(int i = 1;i < n;i++)
	{
		if(i == A || i == B)
			continue;
		
		for(int j = i+1;j <= n;j++)
		{
			if(j == A || j == B)
				continue;
			
			if(minx[A][i] > maxx[j][B] || minx[A][j] > maxx[i][B])
				++c1;
			if(maxx[A][i] < minx[j][B] || maxx[A][j] < minx[i][B])
				++c3;
				
			if(minx[A][i] == maxx[A][i] && minx[j][B] == maxx[j][B])
			{
				if(minx[A][i] == minx[j][B])++c2;
			}
			else if(minx[A][j] == maxx[A][j] && minx[i][B] == maxx[i][B])
			{
				if(minx[A][j] == minx[i][B])++c2;
			}
		}
	}
	printf("%d %d %d",c1,c2,c3);
    
	return 0^_^0;//卖个萌QAQ
}
```
个人感觉码风还是比较清晰的，目前吸了氧跑到次次优解。

如果大家有什么不懂的欢迎私信问我，希望管理员大大看我写得这么认真给过 QAQ~

---

## 作者：Pwtking (赞：0)

看到大家都用的 Floyd 算法+差分约束，我来解释一下为什么可以 Floyd 来求解此类问题。

首先题目中未直接提供每个砝码间大小的具体数值差距，同时让我们求的满足一定大小关系时的方案数。所以不能直接套用模板。

Floyd 的优势是在于在每次松弛的时候，**选择的中继点能正确地传递这两个量的大小关系**，同时又能清晰的表现出**所有的量两两之间的大小关系**，这正是我们所需要的。最重要的是，本题的数据范围 $n$ 很小，也符合 Floyd 的使用条件。

如有不严谨的地方，欢迎指正。

---

## 作者：Bulyly (赞：0)

### 思考过程
首先很容易看出这道题是差分约束，去找它的上下界，然后我就打算 spfa ，写了几步后才发现跑两遍 spfa。第一码量大，第二需要建两次图很麻烦。这时 $n$ 的范围就至关重要了，显然，Floyd 好写且不会超时，建图也十分方便。
### 解析
- 首先，考虑如何建图。维护两两砝码之间的上下界，这个应该非常好做。

- 接着跑 Floyd 求出每两两点之间的最值。求上界跑最短路，下界跑最长路，这个自然不用多说

- 重点来了，如何计算答案。对于判断两边不等的情况，我们两两比较即可，如果左边有一砝码与右边一砝码的差值恒大于右边剩余砝码与左边剩余砝码差值，则左边重，反之右边重。对于相等的情况，可以这样考虑，上述不等关系大于等于与小于等于时皆成立，这是差分约束中判等的一种常用方法。[代码](https://www.luogu.com.cn/paste/pap299ks)。



---

## 作者：Foreverxxx (赞：0)

既然只知道砝码之间的质量关系，那么显然考虑差分约束。

不过由于题目要求必须保证只有唯一的选法，所以我们需要进行两次差分操作，求出任意两个砝码的质量差的范围，也就是差的长下界。

具体的，对于题目，一共有 $4$ 种情况。

1. $w_i=w_j$，此时 $distmax_{i,j}=distmin_{i,j}=0$。
2. $w_i>w_j$，此时，由于 $i$ 比 $j$ 的质量大，可能为 $1$，也可能为 $2$，所以有 $distmax_{i,j}=2,distmin_{i,j}=1$。
3. $w_i<w_j$，此时，同理，有 $distmax_{i,j}=-1,distmin_{i,j}=-2$。
4. $w_i$ 与 $w_j$ 关系未知，此时，$w_i$ 最多比 $w_j$ 多 $2$，也可能比 $w_j$ 少 $2$，则有 $distmax_{i,j}=2,distmin_{i,j}=-2$ 。

然后按照上述方法建图，然后来一次 ``Floyd`` 算法求出最短路以及最长路，即两者质量差的上下界。

对于统计答案，对于左边大于右边，即：
$$
w_a+w_b>w_i+w_j
$$
可以变形为 
$$
w_a-w_i>w_j-w_b
$$
以及
$$
w_b-w_i>w_a-w_j
$$
右边大于左边的情况同理可得。

对于两边相等的情况，必须满足 $distmax_{a,i}=distmin_{a,i}$ 且 $distmax_{j,b}=distmin_{j,b}$ 或者满足 $distmax_{a,j}=distmin_{a,j}$ 且 $distmax_{i,b}=distmin_{i,b}$ 然后才能判断。

Code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sss=0;
	char chh=getchar();
	while(chh<'0'||chh>'9') chh=getchar();
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss;
}
inline char get_char(){
	char chh=getchar();
	while(chh!='-'&&chh!='?'&&chh!='+'&&chh!='=') chh=getchar();
	return chh;
}
int n,a,b;
int dist_max[55][55];
int dist_min[55][55];
int c1=0,c2=0,c3=0;
int main(){
	n=read(),a=read(),b=read();
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=n;j++){
			char chh=get_char();
			if(chh=='='||i==j){
				dist_max[i][j]=0;
				dist_min[i][j]=0;
			}
			else if(chh=='+'){
				dist_max[i][j]=2;
				dist_min[i][j]=1;
			}
			else if(chh=='-'){
				dist_max[i][j]=-1;
				dist_min[i][j]=-2;
			}
			else {
				dist_max[i][j]=2;
				dist_min[i][j]=-2;
			}
		}
	}
	for(register int k=1;k<=n;k++){
		for(register int i=1;i<=n;i++){
			for(register int j=1;j<=n;j++){
				dist_max[i][j]=min(dist_max[i][j],dist_max[i][k]+dist_max[k][j]);
				dist_min[i][j]=max(dist_min[i][j],dist_min[i][k]+dist_min[k][j]);
			}
		}
	}
	for(register int i=1;i<=n;i++){
		if(i==a||i==b)continue;
		for(register int j=1;j<=n;j++){
			if(j==a||j==b||i==j) continue;
			if(dist_min[a][i]>dist_max[j][b]||dist_min[b][i]>dist_max[j][a]) c1++;
			/*
				a-i>j-b -> a+b>i+j
				b-i>j-a -> b+a>j+i
			*/
			if((dist_max[a][i]==dist_min[a][i]&&dist_max[j][b]==dist_min[j][b]&&dist_max[a][i]==dist_max[j][b])
			 ||(dist_max[a][j]==dist_min[a][j]&&dist_max[i][b]==dist_min[i][b]&&dist_max[a][j]==dist_max[i][b]))
				c2++;	
			/*
				前两个条件保证一定成立
				a-i=j-b -> a+b=i+j
				a-j=i-b -> a+b=i+j 
			*/
			if(dist_max[b][j]<dist_min[i][a]||dist_max[a][j]<dist_min[i][b]) c3++;
			/*
				b-j<i-a -> a+b<i+j
				a-j<i-b -> a+b<i+j
			*/
		}
	}
	printf("%d %d %d",c1>>1,c2>>1,c3>>1);//每个答案被统计了两次
	return 0;
}
```

---

## 作者：happy_dengziyue (赞：0)

### 1 思路

本题可以用 Floyd 算法实现。

首先，我们要定义：

$ga[i][j](1\le i,j\le n)$ 表示 $i$ 砝码重量减去 $j$ 砝码重量的**最大值**，$gi[i][j]$ 表示**最小值**。

然后，对于那些给出的信息，我们初始化为以下 $4$ 种：

+ `+`：$ga[i][j]=2$，$gi[i][j]=1$；

+ `-`：$ga[i][j]=-1$，$gi[i][j]=-2$；

+ `=`：$ga[i][j]=gi[i][j]=0$；

+ `?`：$ga[i][j]=2$，$gi[i][j]=-2$。

要注意的是，当 $i=j$ 时，$ga[i][j]=gi[i][j]=0$，**即使输入数据里是 `?`。**

然后，我们跑一遍 Floyd 算法，真正求出具体的数据。

接下来，我们发现：

+ 如果 $a+b<c+d$，那么：

$$ga[c][a]<gi[b][d]\operatorname{or}ga[c][b]<gi[a][d]$$

反之亦然。

+ 如果 $a+b=c+d$，那么：

$$ga[a][c]=gi[a][c]\operatorname{and}ga[d][b]=gi[d][b]\operatorname{and}ga[a][c]=ga[d][b]$$

或

$$ga[a][d]=gi[a][d]\operatorname{and}ga[c][b]=gi[c][b]\operatorname{and}ga[a][d]=ga[c][b]$$

统计一下即可。

### 2 代码与记录

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define max_n 50
int n;
int a,b;
int ga[max_n+2][max_n+2];
int gi[max_n+2][max_n+2];
int ans1=0;
int ans2=0;
int ans3=0;
int ma(int a,int b){
	return a>b?a:b;
}
int mi(int a,int b){
	return a<b?a:b;
}
int main(){
	#ifndef ONLINE_JUDGE
	freopen("P2474_1.in","r",stdin);
	freopen("P2474_1.out","w",stdout);
	#endif
	scanf("%d%d%d",&n,&a,&b);
	for(int i=1;i<=n;++i){
		char s[max_n+2];
		scanf("%s",s+1);
		for(int j=1;j<=n;++j){
			if(i==j){
				ga[i][j]=gi[i][j]=0;
				continue;
			}
			if(s[j]=='+'){
				ga[i][j]=2;
				gi[i][j]=1;
			}
			if(s[j]=='-'){
				ga[i][j]=-1;
				gi[i][j]=-2;
			}
			if(s[j]=='=')ga[i][j]=gi[i][j]=0;
			if(s[j]=='?'){
				ga[i][j]=2;
				gi[i][j]=-2;
			}
		}
	}
	for(int k=1;k<=n;++k){
		for(int i=1;i<=n;++i){
			for(int j=1;j<=n;++j){
				ga[i][j]=mi(ga[i][j],ga[i][k]+ga[k][j]);
				gi[i][j]=ma(gi[i][j],gi[i][k]+gi[k][j]);
			}
		}
	}
	for(int c=1;c<=n;++c){
		if(c==a||c==b)continue;
		for(int d=c+1;d<=n;++d){
			if(d==a||d==b)continue;
			if(ga[c][a]<gi[b][d]||ga[c][b]<gi[a][d])++ans1;
			if((ga[a][c]==gi[a][c]&&ga[d][b]==gi[d][b]&&ga[a][c]==ga[d][b])||(ga[a][d]==gi[a][d]&&ga[c][b]==gi[c][b]&&ga[a][d]==ga[c][b]))++ans2;
			if(ga[a][c]<gi[d][b]||ga[b][c]<gi[d][a])++ans3;
		}
	}
	printf("%d %d %d\n",ans1,ans2,ans3);
	return 0;
}
```

[记录传送门](https://www.luogu.com.cn/record/68155088)

By **dengziyue**

---


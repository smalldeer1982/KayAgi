# [JSOI2009] 等差数列

## 题目背景

“一个长度为$l$的数列$a_i$，若相邻两数间的差$a_i - a_{i-1} \ (2 \leq i \leq l)$全部相同，则这个数列为等差数列。”火星特级数学老师jyy，正在给他的火星学生们上数学课。

## 题目描述

为了检验学生的掌握情况，jyy布置了一道习题：给定一个长度为$N$（$1 \leq N \leq 100,000$）的数列，初始时第$i$个数为$v_i$（$v_i$是整数，$-100,000 \leq v_i \leq 100,000$），学生们要按照jyy的给出的操作步骤来改变数列中的某些项的值。操作步骤的具体形式为：`A s t a b` （$s, t, a, b$均为整数，$1 \leq s \leq t \leq N$，$-100,000 \leq a, b \leq 100,000$），它表示，在序列的$[s, t]$区间上加上初值为$a$，步长为$b$的等差数列。即$v_i$变为$v_i + a + b \times (i - s)$（对于$s \leq i \leq t$）。

在焦头烂额地计算之余，可怜的火星学生们还得随时回答jyy提出的问题。问题形式为：`B s t`（$s, t$均为整数，$1 \leq s \leq t \leq N$），表示jyy询问当前序列的$[s, t]$区间最少能划分成几段，使得每一段都是等差数列。比如说`1 2 3 5 7`最少能划分成$2$段，一段是`1 2 3`，另一段是`5 7`。询问是需要同学们计算出答案后，作为作业交上来的。

虽然操作数加问题数总共只有$Q$（$1 \leq Q \leq 100,000$）个，jyy还是觉得这个题很无聊很麻烦。于是他想让你帮他算一份标准答案。

## 说明/提示

**样例说明：**

原数列`1 3 -1 -4 7`。经过操作之后，数列变为`1 2 3 5 7`。如题中所述，最少能划分成$2$段。

**数据规模：**

对$30\%$的数据，$N, Q \leq 5000$。

对$100\%$的数据，$1 \leq N, Q \leq 100,000$。

其他数据范围见题面。

## 样例 #1

### 输入

```
5
1
3
-1
-4
7
2
A 2 4 -1 5
B 1 5```

### 输出

```
2```

# 题解

## 作者：KSkun (赞：25)

# 题解
本题题解思路来自[bzoj1558 [JSOI2009]等差数列 - zbtrs - 博客园](https://www.cnblogs.com/zbtrs/p/8424737.html)，感谢原作者。

本题题解同步发布于我的博客[[JSOI2009]等差数列 题解 | KSkun's Blog](https://ksmeow.moe/array_jsoi09_sol/)，欢迎来逛~

## 转化：差分数列
看到维护等差数列，我们想到维护这个数列的差分数列。
差分数列是啥呀？简单来说就是把数列的每项换成相邻两项的差值，也就是说，$b_i = a_{i+1} - a_i$。等差数列在差分数列中的表现就是连续一段相同值，这个值就是等差数列的公差（或者叫步长）。

让我们探索一下在差分数列上加等差数列操作应该怎么做。可以发现这个操作只影响首项和前一项（l-1）、末项和后一项（r）的值。用线段树维护这个序列就是两个单点加。

## 询问：如何合并区间信息？
假如我们已经有了一个差分数列，连续的相同数字这一段就是一个等差数列，那么零散的不连续值呢？

让我们举个例子：

`1 2 3 (4 4 4) 1 2 (3 3) 1 2`差分数列

`1 2 4 (7 11 15 19) 20 (22 25 28) 29 31`原数列

显然原数列中那些属于零散值的数字可以成对构成等差数列。也就是说，连续一段零散值能构成的等差数列数量应该是这一段的长度/2。

接下来是一个问题：差分数列上一段数对应原数列中的长度应该+1，为什么直接/2是正确的呢？当我们求数列中间的一段零散值，实际上左右两边都是等差数列。如果使左右两边等差数列的长度最大，实际上原数列中零散的数量应该是-1的，因为左右端点被包含进左右的等差数列了。如果是左右端的零散值，则有一端无法包含进等差数列，原数列对应的长度即为差分数列零散值的长度。

**这一段是很多博主并没有注明的细节，我在理解中也遇到了困惑，在这里特别讲解了一下。**

为什么我们需要知道以上内容呢？因为维护左右两端的零散值数量方便区间的合并，而区间合并是线段树的基本操作。

## 线段树题的套路
### 区间记下什么？
记下这个区间左右两端的零散值长度、左右两端点值（合并区间时检查左儿子的右端和右儿子的左端是否值相等，即并成一个等差数列）、除了零散值以外的那一段能够划分成最少多少等差数列、区间长度。另外区间加操作的lazy标记在这里也是可以用的。

### 怎么设置初值？
从长度为1的区间开始设置初值即可。

### 重要！怎么合并左右儿子上传的信息？
不可避免地，这题会遇到分类讨论。下面让我们慢慢地整理一下。

默认：本区间划分数为左右儿子划分数之和。

**1.左右儿子都是纯零散值**

需要检查左儿子的右端点和右儿子的左端点是否相等。（*以下省略这句话*）

相等→中间构成长为2的等差数列，左端零散值长为左儿子-1，右端零散值长为右儿子-1，本区间内除两端零散值以外的部分的划分数（*以下简称划分数*）为1。

不相等→左右两端零散值长都为本区间长，划分数为0。

**2.左儿子是纯零散值，右儿子不是**

本区间右端零散值长为右儿子右端零散值长。

相等→中间构成长为2的等差数列，左端零散值长为左儿子-1，将右儿子左端零散值构成的等差数列数加入划分数。

不相等→将左儿子和右儿子左端零散值合并作为本区间左端零散值。

**3.右儿子是纯零散值，左儿子不是**

从2情况翻转一下即可。自己推一下吧。

以下情况即可认为：本区间左端零散值长等于左儿子左端零散值长，右端同理。

**4.左儿子右端和右儿子左端无零散值**

相等→划分数要-1，除去重复计算的跨左右儿子的等差数列。

不相等→算到当前步骤的结果就是本区间结果。

**5.左儿子右端无零散值，右儿子左端有零散值**

不相等→将右儿子左端零散值构成的等差数列数加入划分数。

相等→加入后-1，理由同上。

**6.右儿子左端无零散值，左儿子右端有零散值**

从5情况翻转一下即可。自己推一下吧。

**7.除上的一般情况**

不相等→将左儿子右端和右儿子左端零散值构成的等差数列数加入划分数。

相等→左儿子右端和右儿子左端零散值数先都-1再计算构成等差数列数，加入划分数后加1，为了特殊处理跨左右儿子的等差数列。

到此所有的情况都讨论完成了。把这些情况写全了就不会出事。

## 总结一下
这个题是个线段树直接维护答案的题，关键点在差分数列和区间合并的讨论。细节处理很要命，考场上要冷静分析，讨论全面。我反应是写不出的（笑）。

其他细节参考一下底下的代码吧，自认为代码风格还是很整洁的。没有注释可能看起来比较费劲。可以尝试对应着上面的解析看。

# 代码
*注：区间信息中，`l`、`r`是左右端点值，`llen`、`rlen`是左右端零散值长，`ans`是划分数，`tag`是lazy标记，`siz`是区间长。*

```cpp
// Code by KSkun, 2018/2 
#include <cstdio>
#include <cstring>
#include <algorithm>
typedef long long LL;

inline char fgc() {
    static char buf[100000], *p1 = buf, *p2 = buf;
    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;
}

inline LL readint() {
    register LL res = 0, neg = 1;
    char c = fgc(); 
    while(c < '0' || c > '9') {
        if(c == '-') neg = -1;
        c = fgc();
    }
    while(c >= '0' && c <= '9') {
        res = res * 10 + c - '0';
        c = fgc();
    }
    return res * neg;
}

const int MAXN = 100005;

LL n, q, s, t, a, b;
char op;

inline bool isop(char c) {
	return c == 'A' || c == 'B';
}

inline char readop() {
	char c = fgc();
	while(!isop(c)) c = fgc();
	return c;
}

#define lch o << 1
#define rch o << 1 | 1
#define mid ((l + r) >> 1)

struct Data {
	LL l, r, llen, rlen, ans, tag, siz;
} tree[MAXN << 2];

LL val[MAXN];

inline void pushdown(int o) {
	if(tree[o].tag) {
		tree[lch].tag += tree[o].tag;
		tree[lch].l += tree[o].tag;
		tree[lch].r += tree[o].tag;
		tree[rch].tag += tree[o].tag;
		tree[rch].l += tree[o].tag;
		tree[rch].r += tree[o].tag;
		tree[o].tag = 0;
	}
}

inline void merge(Data *dest, Data lson, Data rson) {
	Data *rt = dest, *ls = &lson, *rs = &rson;
	bool flag = ls->r == rs->l;
	memset(rt, 0, sizeof(Data));
	rt->siz = ls->siz + rs->siz;
	rt->l = ls->l;
	rt->r = rs->r;
	rt->ans = ls->ans + rs->ans;
	if(ls->ans == 0 && rs->ans == 0) {
		if(flag) {
			rt->llen = ls->llen - 1;
			rt->rlen = rs->rlen - 1;
			rt->ans++;
		} else {
			rt->llen = rt->rlen = rt->siz;
		}
		return;
	}
	if(ls->ans == 0) {
		rt->rlen = rs->rlen;
		if(flag) {
			rt->llen = ls->llen - 1;
			if(rs->llen) {
				rt->ans += (rs->llen - 1) / 2 + 1;
			}
		} else {
			rt->llen = ls->siz + rs->llen;
		}
		return;
	}
	if(rs->ans == 0) {
		rt->llen = ls->llen;
		if(flag) {
			rt->rlen = rs->rlen - 1;
			if(ls->rlen) {
				rt->ans += (ls->rlen - 1) / 2 + 1;
			}
		} else {
			rt->rlen = rs->siz + ls->rlen;
		}
		return;
	}
	rt->llen = ls->llen;
	rt->rlen = rs->rlen;
	if(ls->rlen == 0 && rs->llen == 0) {
		if(flag) {
			rt->ans--;
		}
		return;
	}
	if(ls->rlen == 0) {
		if(flag) {
			rt->ans += (rs->llen - 1) / 2;
		} else {
			rt->ans += rs->llen / 2;
		}
		return;
	}
	if(rs->llen == 0) {
		if(flag) {
			rt->ans += (ls->rlen - 1) / 2
		} else {
			rt->ans += ls->rlen / 2;
		}
		return;
	}
	LL toadd = (ls->rlen + rs->llen) / 2;
	if(flag) {
		toadd = std::min(toadd, (ls->rlen - 1) / 2 + (rs->llen - 1) / 2 + 1);
	}
	rt->ans += toadd;
} 

inline void build(int o, int l, int r) {
	if(l == r) {
		tree[o].l = tree[o].r = val[l];
		tree[o].llen = tree[o].rlen = tree[o].siz = 1;
		return;
	}
	build(lch, l, mid);
	build(rch, mid + 1, r);
	merge(&tree[o], tree[lch], tree[rch]);
}

inline void add(int o, int l, int r, int ll, int rr, LL v) {
	if(l >= ll && r <= rr) {
		tree[o].l += v;
		tree[o].r += v;
		tree[o].tag += v;
		return;
	}
	pushdown(o);
	if(mid >= ll) {
		add(lch, l, mid, ll, rr, v);
	}
	if(mid < rr) {
		add(rch, mid + 1, r, ll, rr, v);
	}
	merge(&tree[o], tree[lch], tree[rch]);
}

inline Data query(int o, int l, int r, int ll, int rr) {
	if(l >= ll && r <= rr) {
		return tree[o];
	}
	pushdown(o);
	if(rr <= mid) {
		return query(lch, l, mid, ll, rr);
	} else if(ll > mid) {
		return query(rch, mid + 1, r, ll, rr);
	} else {
		Data res;
		merge(&res, query(lch, l, mid, ll, mid), query(rch, mid + 1, r, mid + 1, rr));
		return res; 
	}
}

int main() {
	n = readint();
	for(int i = 1; i <= n; i++) {
		val[i] = readint();
	}
	for(int i = 1; i <= n - 1; i++) {
		val[i] = val[i + 1] - val[i];
	}
	n--;
	build(1, 1, n);
	q = readint();
	while(q--) {
		op = readop();
		if(op == 'A') {
			s = readint();
			t = readint();
			a = readint();
			b = readint();
			if(s > 1) {
				add(1, 1, n, s - 1, s - 1, a);
			}
			if(t <= n) {
				add(1, 1, n, t, t, -(a + (t - s) * b));
			}
			if(s < t) {
				add(1, 1, n, s, t - 1, b);
			}
		} 
		if(op == 'B') {
			s = readint();
			t = readint();
			if(s == t) {
				printf("1\n");
				continue;
			}
			Data res = query(1, 1, n, s, t - 1);
			LL ans = (t - s + 2) / 2;
			if(res.ans == 0) {
				printf("%lld\n", ans);
			} else {
				ans = std::min(ans, res.ans + (res.llen + 1) / 2 + (res.rlen + 1) / 2);
				printf("%lld\n", ans);
			}
		}
	}
	return 0;
}
```

---

## 作者：Pine (赞：17)

# 线段树
区间加等差数列显然用线段树

但是为了方便查询我们采用差分的方法

令v[i] = v[i+1] - v[i]

对于修改操作则变为了两个单点加，一个区间加。

而对于查询操作我们考虑维护六个信息 ：
	1. 当前区间的左端点的数值 -> l
    2. 当前区间的右端点的数值 -> r
    3. 当前区间如果左右端点都不选有多少个等差数列 -> s[0]
    4. 当前区间如果只选左端点有多少个等差数列 -> s[1]
    5. 当前区间如果只选右端点有多少个等差数列 -> s[2]
    6. 当前区间如果左右端点都选有多少个等差数列 -> s[3]
    
那么答案就是查询区间的s[3]的值

如何合并呢？

信息1和2  直接继承左右区间即可

信息3,4,5,6是相似的 以下以s[0]为例

s[0] = min(lc->s[2]+rc->s[1]-(lc->r==rc->l), lc->s[0]+rc->s[1], lc->s[2]+rc->s[0]);

共有三种情况对于区间合并时合并处的端点选择，取个Min即可另外三个信息同样

### 查询和修改时存在一些细节需要注意具体见代码


# 本人的代码
```
#include <bits/stdc++.h>
#define R register
#define eps 1e-12
#define INF (1<<30)
#define LINF (1ll<<60)
#define LL long long
#define MM(x, y) memset(x, y, sizeof x)
#define Fo(i, x, y) for(R int i=x; i<=y; ++i)
#define Ro(i, x, y) for(R int i=x; i>=y; --i)
using namespace std;
template<typename T> inline T Max(R T x, R T y) {return x > y ? x : y;}
template<typename T> inline T Min(R T x, R T y) {return x < y ? x : y;}
template<typename T> inline void in(R T &x)
{
    static int ch; static bool flag;
    for(flag=false, ch=getchar(); ch<'0'||ch>'9'; ch=getchar()) flag |= ch=='-';
    for(x=0; ch>='0'&&ch<='9'; ch=getchar()) x = (x<<1) + (x<<3) + ch - '0';
    x = flag ? -x : x;
}
/*********************************Samle****************************************/

inline void minn(R int &x, R int y) {if(y < x) x = y;}
struct data{
	int s[4], l, r;
	data operator + (const data &y) const
	{
		data c; c.l = l; c.r = y.r;
		c.s[0] = s[2] + y.s[1] - (r == y.l);
		minn(c.s[0], s[0]+y.s[1]); minn(c.s[0], s[2]+y.s[0]);
		c.s[1] = s[3] + y.s[1] - (r == y.l);
		minn(c.s[1], s[1]+y.s[1]); minn(c.s[1], s[3]+y.s[0]);
		c.s[2] = s[2] + y.s[3] - (r == y.l);
		minn(c.s[2], s[2]+y.s[2]); minn(c.s[2], s[0]+y.s[3]);
		c.s[3] = s[3] + y.s[3] - (r == y.l);
		minn(c.s[3], s[3]+y.s[2]); minn(c.s[3], s[1]+y.s[3]);
		return c;
	}
};
#define lc (o << 1)
#define rc (lc | 1)
#define mid ((l + r) >> 1)
struct node{
	int val; data x;
}tr[500005]; int n, q, A[100005];
inline void pushdown(R int o)
{
	if(tr[o].val)
	{
		tr[lc].val += tr[o].val; tr[rc].val += tr[o].val;
		tr[lc].x.l += tr[o].val; tr[rc].x.l += tr[o].val;
		tr[lc].x.r += tr[o].val; tr[rc].x.r += tr[o].val;
		tr[o].val = 0;
	}
}
inline void build(R int o, R int l, R int r)
{
	if(l == r)
	{
		tr[o].x.s[0] = 0; tr[o].val = 0; tr[o].x.l = tr[o].x.r = A[l];
		tr[o].x.s[1] = tr[o].x.s[2] = tr[o].x.s[3] = 1;
		return;
	}
	build(lc, l, mid); build(rc, mid+1, r);
	tr[o].val = 0;
	tr[o].x = tr[lc].x + tr[rc].x;
}
inline void change(R int o, R int l, R int r, R int x, R int y, R int k)
{
	if(x <= l && y >= r)
	{
		tr[o].val += k;
		tr[o].x.l += k;
		tr[o].x.r += k;
		return;
	}
	pushdown(o);
	if(x <= mid) change(lc, l, mid, x, y, k);
	if(y > mid) change(rc, mid+1, r, x, y, k);
	tr[o].x = tr[lc].x + tr[rc].x;
}
inline data query(R int o, R int l, R int r, R int x, R int y)
{
	if(x <= l && y >= r) return tr[o].x;
	pushdown(o);
	if(y <= mid) return query(lc, l, mid, x, y);
	else if(x > mid) return query(rc, mid+1, r, x, y);
	else return query(lc, l, mid, x, mid) + query(rc, mid+1, r, mid+1, y);
}

int main()
{
	in(n);Fo(i, 1, n) in(A[i]); Fo(i, 1, n-1) A[i] = A[i+1] - A[i];
	build(1, 1, n-1);
	in(q);
	Fo(i, 1, q)
	{
		R char opt; R int s, t, a, b;
		scanf(" %c%d%d", &opt, &s, &t);
		if(opt == 'A')
		{
			in(a); in(b);
			if(s != 1) change(1, 1, n-1, s-1, s-1, a); // 因为1位置没有与前一个的差
			if(t != n) change(1, 1, n-1, t, t, -(a+b*(t-s))); // 不存在n+1与n的差
			if(s != t)change(1, 1, n-1, s, t-1, b);
		}
		else
		{
			if(s == t) // 只有一个数 ans一定是1
			{
				puts("1");continue;
			}
			data re = query(1, 1, n-1, s, t-1);
			printf("%d\n", re.s[3]);
		}
	}
	return 0;
}

```




---

## 作者：lx_zjk (赞：10)


## P4243 【[JSOI2009]等差数列】

这道题是一道线段树练手题

由等差可以想到差分序列

$s[i] = a[i + 1] - a[i]$

如果$s[1] = s[2] = ... = s[n]$的话,那么$1...n$及为等差数列

考虑差分后的序列,在序列的$[s, t]$区间上加上初值为$a$，步长为$b$的等差数列,那么差分序列上既可变形,分三类情况讨论

### 区间修改的过程

$part 1$  
$s< i <t$ $s[i] = a[i + 1] + a + b * (i + 1 - s) - a[i]  - a - b * (i - s)= s[i]  + b$ 

$s[i] = s[i] + b$

$part 2$

$i = s$ $&&$ $ i != 1$ 
$s[i] = a[i + 1] + a + b * (s - s) - a[i]  = a[i + 1] + a - a[i] = s[i] + a$
$s[i] = s[i] + a$

$part 3$

$i = t$ $&&$ $i != n$
$s[i] = a[i + 1] - a[i] - a - b * (i - s) = s[i] - (a + b * (t - s))$
$s[i] = s[i] - (a + b * (t - s))$


### push_up(p) push_down(p)

push_up就不细讲了,其他题解写的很详细,$[l, mid] $$&$ $[mid + 1, r]$,就提示一点(~~也是卡了我很久的一个点~~),无论两个数差值多大或多小,这两个数都是等差数列

```cpp
t[p].x = t[ls(p)].x + t[rs(p)].x;

struct node{
    int s[5], l, r;
    node operator + (const node &y) const
    {
        node c; c.l = l; c.r = y.r;
		c.s[0] = MIN(s[2] + y.s[1] - (r == y.l), s[0] + y.s[1], s[2] + y.s[0]);
        c.s[1] = MIN(s[3] + y.s[1] - (r == y.l), s[1] + y.s[1], s[3] + y.s[0]);
        c.s[2] = MIN(s[2] + y.s[3] - (r == y.l), s[2] + y.s[2], s[0] + y.s[3]);
        c.s[3] = MIN(s[3] + y.s[3] - (r == y.l), s[1] + y.s[3], s[3] + y.s[2]);
        return c;
    }
};

```


```cpp
inline void push_down(int p){
	if(t[p].tag == 0) return;
	t[ls(p)].tag += t[p].tag; t[rs(p)].tag += t[p].tag;
	t[ls(p)].x.l += t[p].tag; t[ls(p)].x.r += t[p].tag;
	t[rs(p)].x.l += t[p].tag; t[rs(p)].x.r += t[p].tag;
	t[p].tag = 0;
	return;
} 
```

# code

```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long ll;

inline ll read(){
	ll x=0,f=1;char ch;
	do{ch=getchar();if(ch=='-')f=-1;}while(ch>'9'||ch<'0');
	do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
	return f*x;
}

//当第i个节点 

#define int ll

const int MAX_N = 1E5 + 7;

int n, m, a[MAX_N];

//s[0] 左右端点都不选 

//s[1] 只选左端点 

//s[2] 只选右端点

//s[3] 左右端点都选

int MIN(int a, int b, int c){
	return min(a, min(b, c));
}

struct node{
    int s[5], l, r;
    node operator + (const node &y) const
    {
        node c; c.l = l; c.r = y.r;
		c.s[0] = MIN(s[2] + y.s[1] - (r == y.l), s[0] + y.s[1], s[2] + y.s[0]);
        c.s[1] = MIN(s[3] + y.s[1] - (r == y.l), s[1] + y.s[1], s[3] + y.s[0]);
        c.s[2] = MIN(s[2] + y.s[3] - (r == y.l), s[2] + y.s[2], s[0] + y.s[3]);
        c.s[3] = MIN(s[3] + y.s[3] - (r == y.l), s[1] + y.s[3], s[3] + y.s[2]);
        return c;
    }
};

struct segment_tree{
	int l, r;
	ll tag; node x;	
	#define ls(p) (p << 1)
	#define rs(p) (p << 1 | 1)
}t[MAX_N << 2];

void build(int p, int l, int r){
	t[p].l = l;
	t[p].r = r;
	if(l == r){
		t[p].x.l = t[p].x.r = a[l];
		t[p].x.s[0] = 0;
		t[p].x.s[1] = t[p].x.s[2] = t[p].x.s[3] = 1;
		return;
	}
	int mid = (l + r) >> 1;
	build(ls(p), l, mid);
	build(rs(p), mid + 1, r);
	t[p].x = t[ls(p)].x + t[rs(p)].x;
}

inline void push_down(int p){
	if(t[p].tag == 0) return;
	t[ls(p)].tag += t[p].tag; t[rs(p)].tag += t[p].tag;
	t[ls(p)].x.l += t[p].tag; t[ls(p)].x.r += t[p].tag;
	t[rs(p)].x.l += t[p].tag; t[rs(p)].x.r += t[p].tag;
	t[p].tag = 0;
	return;
} 

void change(int p, int l, int r, int v){
	if(l <= t[p].l && t[p].r <= r){
		t[p].x.l += v;
		t[p].x.r += v;
		t[p].tag += v;
		return;
	}
	push_down(p);
	int mid = (t[p].l + t[p].r) >> 1;
	if(l <= mid)change(ls(p), l, r, v);
	if(r > mid) change(rs(p), l, r, v);
	t[p].x = t[ls(p)].x + t[rs(p)].x;
}

node query(int p, int l, int r){
	if (l <= t[p].l && t[p].r <= r) return t[p].x;
	push_down(p);
	int mid = (t[p].l + t[p].r) >> 1;
	if (r <= mid)return query(ls(p), l, r);
	if (l > mid) return query(rs(p), l, r);
	return query(ls(p), l, r) + query(rs(p), l, r);
}

signed main(){
	n = read();
	for (int i = 1; i <= n; i ++ )a[i] = read();
	for (int i = 1; i < n; i ++ ) a[i] = a[i + 1] - a[i];
	build(1, 1, n - 1);
	m = read();
	for (int i = 1; i <= m; i ++ ){
		char opt[10];int s, t;
		scanf("%s", opt);
		s = read(), t = read();
		if (opt[0] == 'A'){
			int a = read(), b = read();
			if(s != 1) change(1, s - 1, s - 1, a);//a[s] - a[s - 1]  
            if(t != n) change(1, t, t, -(a + b * (t - s)));//- (a + b * (t - s)) 
            if(s != t) change(1, s, t - 1, b);//a[s + 1] - a[s] + b   ....a[t] - a[t - 1] + b
		}
		else {
			if (s == t) puts("1");
			else {
				node ans = query(1, s, t - 1);//a[s + 1] - a[s]... a[t] - a[t - 1] 
				printf("%lld\n", ans.s[3]);
			}
		} 
	} 
	return 0;
}

//s[i] = a[i + 1] - a[i]

//在序列的[s, t][s,t]区间上加上初值为a,步长为b的等差数列.

//原序列则变成 s[i] + b, s[i + 1] + b, s[i + 2] + b... 
```


---

## 作者：xxzx (赞：4)

[在我的博客查看](https://xxzx.moe/2022/10/04/jsoi2009-%e7%ad%89%e5%b7%ae%e6%95%b0%e5%88%97/)

观察到两个操作都和等差数列有关，而等差数列很显然其相邻两项的差值都相等，因此考虑转换为差分数列进行操作。

对于操作一，需要区间加上一个等差数列，转化成差分数列后，很显然就是两边单点修改，中间区间修改，用线段树即可。

重点是对于操作二，我们如何去维护最少的划分段数。

首先我们把原数列划分成几段等差数列的时候可以发现，**差分数列上划分出的每一段的第一个数是可以任意的**，而后面的数作为公差都要相同，因此合并的时候我们也要考虑这个性质。即合并两个子区间的时候，可以不计算某一端点作为等差数列公差时的贡献，而是作为等差数列的第一个数。当然当左区间右端点和右区间左端点相同时，我们可以将其合并成一个区间。

因此我们用线段树去分别维护 $\text{[l,r]}$ 区间中左右端点的值，$\text{[l,r]}$ , $\text{[l,r)}$ , $\text{(l,r]}$ , $\text{(l,r)}$ 四个区间最少能划分成几个等差数列。

分别记这些信息为 $\text{lval , raval , s[0...3]}$。

左右端点的值的转移很简单，对于划分数的转移，根据性质也可以得出。

譬如对于 $\text{s[0]}$ 的转移：


```cpp
t[id].s[0]=min(t[ls].s[0]+t[rs].s[0]-(t[ls].rval==t[rs].lval),min(t[ls].s[1]+t[rs].s[0],t[ls].s[0]+t[rs].s[2]));
```
分别对应的三种情况（其余的转移类似）：

1.将左区间最右边的等差数列与右区间最左边的等差数列合并成一个（前提是这两个数列的公差相同）。

2.将左区间的右端点作为右区间第一个端点开始的等差数列的第一个数。

3.将右区间左端点作为右区间第二个端点开始的等差数列的第一个数。

注意：我们求的最小划分数，是钦定这个区间的左端点不作为等差数列的第一个数，而是直接作为公差，这样才能确保在合并子区间的时候是正确的。查询的时候，我们只需不查询左端点即可。

相关细节可参见代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ls (id<<1)
#define rs (id<<1|1)
const int N=1e5+10;
int n;
ll a[N],b[N];
struct SegmentTree {
	int s[5];
	ll lval,rval,lazy;
	SegmentTree() { lazy=0; }
	SegmentTree operator+(const SegmentTree& q)const {
		SegmentTree p;
		p.lval=lval, p.rval=q.rval;
		p.s[0]=min(s[0]+q.s[0]-(rval==q.lval),min(s[1]+q.s[0],s[0]+q.s[2]));
		p.s[1]=min(s[0]+q.s[1]-(rval==q.lval),min(s[1]+q.s[1],s[0]+q.s[3]));
		p.s[2]=min(s[2]+q.s[0]-(rval==q.lval),min(s[3]+q.s[0],s[2]+q.s[2]));
		p.s[3]=min(s[2]+q.s[1]-(rval==q.lval),min(s[3]+q.s[1],s[2]+q.s[3]));
		return p;
	}
}t[N<<2];
void build(int id,int l,int r) {
	if(l==r) {
		t[id].lval=t[id].rval=b[l];
		t[id].s[0]=t[id].s[1]=t[id].s[2]=1;
		t[id].s[3]=0;
		return;
	}
	int mid=l+r>>1;
	build(ls,l,mid), build(rs,mid+1,r);
	t[id]=t[ls]+t[rs];
}
void pushdown(int id) {
	if(!t[id].lazy) return;
	int val=t[id].lazy; t[id].lazy=0;
	t[ls].lazy+=val, t[rs].lazy+=val;
	t[ls].lval+=val, t[ls].rval+=val;
	t[rs].lval+=val, t[rs].rval+=val;
}
void modify(int id,int l,int r,int x,int y,ll val) {
	if(x>r||y<l) return;
	if(x<=l&&y>=r) {
		t[id].lazy+=val, t[id].lval+=val, t[id].rval+=val;
		return;
	}
	pushdown(id);
	int mid=l+r>>1;
	modify(ls,l,mid,x,y,val), modify(rs,mid+1,r,x,y,val);
	t[id]=t[ls]+t[rs];
}
SegmentTree query(int id,int l,int r,int x,int y) {
	if(x<=l&&y>=r) return t[id];
	pushdown(id);
	int mid=l+r>>1;
	if(y<=mid) return query(ls,l,mid,x,y);
	else if(x>=mid+1) return query(rs,mid+1,r,x,y);
	else return query(ls,l,mid,x,y)+query(rs,mid+1,r,x,y);
}
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]), b[i-1]=a[i]-a[i-1];
	n--;//差分数列的长度为n-1，第n项-a[n]无意义
	build(1,1,n);
	char op; int Q,s,t; ll a,b;
	scanf("%d",&Q);
	while(Q--) {
		cin>>op;
		if(op=='A') {
			scanf("%d%d%lld%lld",&s,&t,&a,&b);
			if(s!=1) modify(1,1,n,s-1,s-1,a);//判断防止越界，后面同理
			if(s!=t) modify(1,1,n,s,t-1,b);
			if(t<=n) modify(1,1,n,t,t,-a-b*(s-t));
		}
		else {
			scanf("%d%d",&s,&t);
			if(s==t) { puts("1"); continue; }
			SegmentTree Ans=query(1,1,n,s,t-1);
       		 //如上所述，差分数列的最左端点b[s-1]可以作为等差数列的第一个数，即其取值任意，不需要考虑，因此查询从b[s]开始
			printf("%d\n",Ans.s[0]);
		}
	}
	return 0;
}
```


---

## 作者：cunzai_zsy0531 (赞：4)

# 题解

题目链接[Link](https://www.luogu.com.cn/problem/P4243)，题目内容不再赘述。

这题我用的是线段树，因为是区间操作，线段树比较好写~~主要指的是代码比较短~~，而且错误率不高，常数对于我这种蒟蒻来说已经很不错了。

不会线段树的点这里[Link](https://www.luogu.com.cn/problem/P3372)

下面我们来解决一下操作：

- ### A s t a b：把s-t的数分别加上一个等差数列，数列首项为a，公差为b。

对于这个修改操作，很容易想到把线段树维护的每个单点定义成差分数组，即：

```cpp
for(int i=1;i<=n;i++) b[i]=a[i]-a[i-1];
```


这样这一个操作就可以通过一次区间操作和两次单点修改来解决：

```cpp
modify(1,l,l,x);
if(l!=r) modify(1,l+1,r,y);
if(r!=n) modify(1,r+1,r+1,-x-(r-l)*y);
```
这个地方要提醒大家注意操作的范围。如果l==r只需要修改一个数即可，如果r==n就可以省去差分数组最后的那个单点修改操作（这个卡了好久。

- ### B s t：问把区间[s,t]划分为若干个等差的段后，最少的段数。

这个操作才是这题黑色的原因，因为它并不像看起来那样简单。很容易会想到记录每个点与上个点的差值是否相等，相等为1，不等为0，然后通过判断真假来合并答案。

但是这样会有很大的问题，最难解决的就是两个数不论前一个数怎么样，这两个数一定是等差数列。

这样就会发现很难得到转移方程。所以我们这样来定义：

```cpp
struct data{
    int s[2][2],lval,rval;
    //lval和rval是左右端点的差分值
    //其中s[0/1][0/1]表示去掉左端点或去掉右端点后这个区间的最小段数
    //0表示不包含，1表示包含，如s[0][1]表示包含右端点但不包含左端点
};
```
这样我们可以推出一个复杂的转移，我是运用重载运算符来实现的。

```cpp
t[p].x=t[ls].x+t[rs].x;
```

```cpp
data operator +(const data &y)const{
    data x;
    x.lval=lval,x.rval=y.rval;
    x.s[0][0]=s[0][1]+y.s[1][0]-(rval==y.lval);
    x.s[0][0]=min(x.s[0][0],min(s[0][0]+y.s[1][0],s[0][1]+y.s[0][0]));
    x.s[1][0]=s[1][1]+y.s[1][0]-(rval==y.lval);
    x.s[1][0]=min(x.s[1][0],min(s[1][0]+y.s[1][0],s[1][1]+y.s[0][0]));
    x.s[0][1]=s[0][1]+y.s[1][1]-(rval==y.lval);
    x.s[0][1]=min(x.s[0][1],min(s[0][0]+y.s[1][1],s[0][1]+y.s[0][1]));
    x.s[1][1]=s[1][1]+y.s[1][1]-(rval==y.lval);
    x.s[1][1]=min(x.s[1][1],min(s[1][0]+y.s[1][1],s[1][1]+y.s[0][1]));
    return x;
}
```
可能不太好理解，我举一个小例子：

```cpp
x.s[0][0]=s[0][1]+y.s[1][0]-(rval==y.lval);
x.s[0][0]=min(x.s[0][0],min(s[0][0]+y.s[1][0],s[0][1]+y.s[0][0]));
```
- **对于一个区间的s[0][0]（即开区间，不再赘述）来说：**

它可以是：

左子区间的左开右闭区间 + 右子区间的左闭右开区间

如果左子区间的右端点的差分值 == 右子区间右端点的差分值，那么左子区间最右边的那段就可以和右子区间最左边的那段连为一段，即总段数-1。

另外就是对于零散值的判断，在上面代码的第二行进行了判断。这样就完成了。

注意一些线段树具体细节即可。

# 本人的代码

```cpp
#include<iostream>
#include<cstdio>
#define N (1000000+21)
#define INF (1000000+21)
#define ls p<<1
#define rs p<<1|1
#define md (t[p].l+t[p].r)>>1
//记得define要加括号！不然会死的很惨！
using namespace std;
struct data{
	//新定义一个struct可以重载运算符，操作较为方便。 
	int s[2][2],lval,rval;
	//重载运算符转移 
	data operator +(const data &y)const{
		data x;
		x.lval=lval,x.rval=y.rval;
		x.s[0][0]=s[0][1]+y.s[1][0]-(rval==y.lval);
		x.s[0][0]=min(x.s[0][0],min(s[0][0]+y.s[1][0],s[0][1]+y.s[0][0]));
		x.s[1][0]=s[1][1]+y.s[1][0]-(rval==y.lval);
		x.s[1][0]=min(x.s[1][0],min(s[1][0]+y.s[1][0],s[1][1]+y.s[0][0]));
		x.s[0][1]=s[0][1]+y.s[1][1]-(rval==y.lval);
		x.s[0][1]=min(x.s[0][1],min(s[0][0]+y.s[1][1],s[0][1]+y.s[0][1]));
		x.s[1][1]=s[1][1]+y.s[1][1]-(rval==y.lval);
		x.s[1][1]=min(x.s[1][1],min(s[1][0]+y.s[1][1],s[1][1]+y.s[0][1]));
		return x;
	}
};
struct SegTree{int l,r,add;data x;}t[N*4];
int a[N],b[N];
int n,m;
//然后底下的都是线段树的基本操作了 
void build(int p,int l,int r){
	t[p].l=l,t[p].r=r;
	if(l==r){
		t[p].x.lval=t[p].x.rval=b[l];
		t[p].x.s[0][1]=t[p].x.s[1][0]=t[p].x.s[1][1]=1;
		return;
	}
	int mid=(l+r)>>1;//尽量用位运算 
	build(ls,l,mid);
	build(rs,mid+1,r);
	t[p].x=t[ls].x+t[rs].x;
}
void pushup(int p,int v){
	t[p].add+=v;
	t[p].x.lval+=v;
	t[p].x.rval+=v;
}
void pushdown(int p){
	if(!t[p].add||t[p].l==t[p].r) return;
	pushup(ls,t[p].add);
	pushup(rs,t[p].add);
	t[p].add=0;
}
data query(int p,int l,int r){
	if(l<=t[p].l&&t[p].r<=r) return t[p].x;
	pushdown(p);
	int mid=md;
	if(r<=mid) return query(ls,l,r);
	if(l>mid) return query(rs,l,r);
	return query(ls,l,r)+query(rs,l,r);
}
void modify(int p,int l,int r,int v){
	if(l<=t[p].l&&t[p].r<=r){
		pushup(p,v);
		return;
	}
	pushdown(p);
	int mid=md;
	if(l<=mid) modify(ls,l,r,v);
	if(r>mid) modify(rs,l,r,v);
	t[p].x=t[ls].x+t[rs].x;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++) b[i]=a[i]-a[i-1];//差分数列 
	build(1,1,n);
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		char c;
		int l,r,x,y;
		cin>>c;//读入字符一定不要用scanf和getchar！会出人命的！ 
		if(c=='A'){
			scanf("%d%d%d%d",&l,&r,&x,&y);
			modify(1,l,l,x);
			if(l!=r) modify(1,l+1,r,y);//注意这里的判断，不然可能会出现一些奇奇怪怪的错误，得不偿失 
			if(r!=n) modify(1,r+1,r+1,-x-(r-l)*y);	
		}
		else{
			scanf("%d%d",&l,&r);
			if(l==r) printf("1\n");
			else printf("%d\n",query(1,l+1,r).s[1][1]);
		}
	}
	return 0;
}
```


---

## 作者：Rorschachindark (赞：3)

# 等差数列
神仙题，跟之前的内需消费有点像，都是维护的差分数组

不难看出，修改操作就是区间加，加上两个单点修改

我们还发现，转换成差分数组后，等差数组就是一段连续的值

接下来就是线段树需要维护什么的问题了。

我们需要的是左右两端都包含的区间最少分成的序列数

那么，我们就需要维护这些

1. 区间左右两边的值

2. 只包含左右区间都不包含、左区间、右区间、左右区间都包含的最少划分数

我们把下面那些分别赋为s[0/1/2/3]

因为转移比较相似，所以我们来推一下s[0]怎么搞


## $\text {Code}$
```cpp
bool flag = (ls.r == rs.l);
New.s[0] = Min (ls.s[2] + rs.s[1] - flag,ls.s[0] + rs.s[1],ls.s[2] + rs.s[0]);
```

这里l,r就是这段区间的左右端点的值

自认为第一个一点都不难理解，关键是后面两个。咦？为什么不需要在加些什么？

左区间的右端点肿么不见了？（被狗啃了）我们可以发现无论如何左区间的右端点都可以归到左区间的右边或右区间，所以不（bei）用（gou）考（ken）虑（le）

然后，其它转移差不多都是一样的了。

还是说一下我进的坑点吧，我合并的时候一不小心把懒标记搞没了

```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define MAXN 100005

int n;
int Min (int a,int b,int c){return min (a,min (b,c));}

struct node
{
	int l,r,s[5],lazy;
}tree[MAXN << 2];

node operator + (node ls,node rs)
{
	node New;
	New.l = ls.l,New.r = rs.r;
	bool flag = (ls.r == rs.l);
	New.s[0] = Min (ls.s[2] + rs.s[1] - flag,ls.s[0] + rs.s[1],ls.s[2] + rs.s[0]);
	New.s[1] = Min (ls.s[3] + rs.s[1] - flag,ls.s[1] + rs.s[1],ls.s[3] + rs.s[0]);
	New.s[2] = Min (ls.s[2] + rs.s[3] - flag,ls.s[2] + rs.s[2],ls.s[0] + rs.s[3]);
	New.s[3] = Min (ls.s[3] + rs.s[3] - flag,ls.s[3] + rs.s[2],ls.s[1] + rs.s[3]);
	return New;
}

#define rs (i<<1|1)
#define ls (i<<1)

int val[MAXN];

void Pushup (int i)
{
	int late = tree[i].lazy;
	tree[i] = tree[ls] + tree[rs];
	tree[i].lazy = late;
}

void Pushdown (int i)
{
	if (!tree[i].lazy) return ;
	tree[ls].l += tree[i].lazy,tree[rs].l += tree[i].lazy;
	tree[ls].r += tree[i].lazy,tree[rs].r += tree[i].lazy;
	tree[ls].lazy += tree[i].lazy,tree[rs].lazy += tree[i].lazy;
	tree[i].lazy = 0;
}

void build (int i,int l,int r)
{
	tree[i].lazy = 0;
	if (l == r)
	{
		tree[i].s[0] = 0;
		tree[i].l = tree[i].r = val[l];
		tree[i].s[1] = tree[i].s[2] = tree[i].s[3] = 1;
		return ;
	}
	int mid = (l + r) >> 1;
	build (i << 1,l,mid);
	build (i << 1 | 1,mid + 1,r);
	Pushup (i);
}

void update (int i,int l,int r,int tl,int tr,int cot)
{
	if (l >= tl && r <= tr) return tree[i].lazy += cot,tree[i].l += cot,tree[i].r += cot,void ();
	Pushdown (i);
	int mid = (l + r) >> 1;
	if (tl <= mid) update (ls,l,mid,tl,tr,cot);
	if (tr > mid) update (rs,mid + 1,r,tl,tr,cot);
	Pushup (i);
}

node query (int i,int l,int r,int tl,int tr)
{
	if (l >= tl && r <= tr) return tree[i];
	Pushdown (i);
	int mid = (l + r) >> 1;
	if (tr <= mid) return query (ls,l,mid,tl,tr);
	else if (tl > mid) return query (rs,mid + 1,r,tl,tr);
	else return query (i << 1,l,mid,tl,mid) + query (i << 1 | 1,mid + 1,r,mid + 1,tr);
} 

int read ()
{
	int x = 0;char c = getchar();int f = 1;
	while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}
	while (c >= '0' && c <= '9'){x = (x << 3) + (x << 1) + c - '0';c = getchar();}
	return x * f;
}

void write (int x)
{
	if (x < 0){x = -x;putchar ('-');}
	if (x > 9) write (x / 10);
	putchar (x % 10 + '0');
}

signed main()
{
	n = read ();
	for (Int i = 1;i <= n;++ i) val[i] = read ();
	for (Int i = 1;i <= n - 1;++ i) val[i] = val[i + 1] - val[i];
	build (1,1,n - 1);
	int q = read ();
	char s[10] = {};
	for (Int i = 1;i <= q;++ i)
	{
		scanf ("%s",s);
		if (s[0] == 'A')
		{
			int s = read (),t = read (),a = read (),b = read ();
			if (s ^ 1) update (1,1,n - 1,s - 1,s - 1,a);
			if (t ^ n) update (1,1,n - 1,t,t,- (a + b * (t - s)));
			if (s ^ t) update (1,1,n - 1,s,t - 1,b); 
		}
		else
		{
			int s = read (),t = read ();
			if (s ^ t)
			{
				node Now = query (1,1,n - 1,s,t - 1);
				write (Now.s[3]),putchar ('\n');
			}
			else puts ("1");
		}
	}
}
```

---

## 作者：Mobius127 (赞：1)

好题。

我们的两种操作均是等差数列，那就来挖掘一下等差数列的性质。

~~那还用说，当然是相邻两项差相等啦。~~

发现其实就是求该序列的一个 **差分序列** ，那么我们就搞出这个序列，这里令 $s_{i}=a_{i+1}-a_{i}$ 。回头看操作一：
   
- 在原序列上一个区间 $[l, r]$ 加上一个等差数列。
   
求差分后，它就变成了：

1. 在差分数列 l-1 位置处加上首项 a ；

1. 对区间中每一项都加上公差 d ；

1. 在差分数列 r+1 位置处减去 (r-l+1)*d+a 。

再看操作二（在原数列上）：

- 求最少的划分段，使得每段均为一个等差数列。

其等价于（在差分数列上）：

- 求最少的划分段，使得每一段内的数都相等。

然鹅问题并没有变得容易。

几经思索后，我们发现只需要维护四个值即可：

- 分割区间 $[l,\ r]$ 的最少划分段；

- 分割区间 $[l,\ r)$ 的最少划分段；

- 分割区间 $(l,\ r]$ 的最少划分段；

- 分割区间 $(l,\ r)$ 的最少划分段。

为了方便，顺便维护区间左右端点的值。

那么容易推出以下 pushup 函数：

```cpp
void pushup(int k, int lc, int rc){
		st(k)=st(lc), ed(k)=ed(rc);int tmp=ed(lc)==st(rc);
        l(k)=man(l(lc)+lr(rc)-tmp, ulr(lc)+lr(rc), l(rc)+l(lc));
        r(k)=man(lr(lc)+r(rc)-tmp, lr(lc)+ulr(rc), r(rc)+r(lc));
        lr(k)=man(lr(lc)+lr(rc)-tmp, r(lc)+lr(rc), l(rc)+lr(lc));
		ulr(k)=man(l(lc)+r(rc)-tmp, ulr(lc)+r(rc), ulr(rc)+l(lc));
	}
```

其它部分不难实现。

### Tip：

1. 如果你是以区间 $[1,\ n-1]$ 去直接建树的，建议特判操作一中  l, r 的越界情况

1. 计算答案时仍需合并，所以多开亿些结点备用。

### Code

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#define ls k<<1
#define rs k<<1|1
#define N 100005
using namespace std;
typedef long long ll;
int n, m, a[N], INF;
struct Segment_Tree{
	int cnt;
	struct node{
		ll st, ed;ll tag;
		int uselr, unuselr, usel, user;
		#define st(k)data[k].st
		#define ed(k)data[k].ed
		#define l(k)data[k].usel
		#define r(k)data[k].user
		#define lr(k)data[k].uselr
		#define ulr(k)data[k].unuselr
		#define t(k)data[k].tag
	}data[N*4];
	int man(int a, int b, int c){
		return min(a, min(b, c));
	}
	void pushup(int k, int lc, int rc){
		st(k)=st(lc), ed(k)=ed(rc);int tmp=ed(lc)==st(rc);
        l(k)=man(l(lc)+lr(rc)-tmp, ulr(lc)+lr(rc), l(rc)+l(lc));
        r(k)=man(lr(lc)+r(rc)-tmp, lr(lc)+ulr(rc), r(rc)+r(lc));
        lr(k)=man(lr(lc)+lr(rc)-tmp, r(lc)+lr(rc), l(rc)+lr(lc));
		ulr(k)=man(l(lc)+r(rc)-tmp, ulr(lc)+r(rc), ulr(rc)+l(lc));
	}
	void upd(int k, ll tag){
		st(k)+=tag, ed(k)+=tag, t(k)+=tag;
	}
	void pushdown(int k){
		if(!t(k)) return ;
		upd(ls, t(k));upd(rs, t(k));
		t(k)=0;
	}
	void build(int k, int l, int r){
		INF=max(INF, k);
		if(l==r){
			st(k)=ed(k)=a[l&r];
			lr(k)=l(k)=r(k)=1;ulr(k)=t(k)=0;
			return ;
		}
		int mid=l+r>>1;
		build(ls, l, mid);build(rs, mid+1, r);
		pushup(k, ls, rs);
	}
	void add(int k, int l, int r, int x, int y, int v){
		if(x<=l&&r<=y) return upd(k, v);
		int mid=l+r>>1;pushdown(k);
		if(x<=mid) add(ls, l, mid, x, y, v);
		if(mid<y) add(rs, mid+1, r, x, y, v);
		pushup(k, ls, rs);
	}
	int query(int k, int l, int r, int x, int y){
		if(x<=l&&r<=y) return k;
		int mid=l+r>>1, tmp1=0, tmp2=0;pushdown(k);
		if(x<=mid) tmp1=query(ls, l, mid, x, y);
		if(mid<y) tmp2=query(rs, mid+1, r, x, y);
		if(tmp1&&tmp2) pushup(++cnt, tmp1, tmp2);
		if(tmp1&&tmp2) return cnt;
		else return tmp1?tmp1:tmp2;
	}
}seg;
char opt[4];
int main(){
	scanf("%d", &n);
	for(int i=1; i<=n; i++) scanf("%d", &a[i]);n--;
	for(int i=1; i<=n; i++) a[i]=a[i+1]-a[i];
	seg.build(1, 1, n);scanf("%d", &m);
	for(int i=1, l, r, a, b; i<=m; i++){
		scanf("%s%d%d", opt, &l, &r);
		if(opt[0]=='A'){
			scanf("%d%d", &a, &b);
			if(l!=1) seg.add(1, 1, n, l-1, l-1, a);
            if(r!=n+1) seg.add(1, 1, n, r, r, -(a+b*(r-l)));
            if(l!=r) seg.add(1 ,1 ,n, l, r-1, b);
		}
		else{
			if(l==r) printf("1\n");
			else{
				seg.cnt=INF;int pos=seg.query(1, 1, n, l, r-1);
				printf("%d\n", seg.data[pos].uselr);
			} 
		}
	}
	return 0;
}
```

~~大常数选手喜提最优解。~~

---

## 作者：WeLikeStudying (赞：1)

- 很久以前的老题目了，不知道怎么回事的。
- 当年我利欲熏心，想要把这题当成自己第一道黑题，然而造化弄人，第一道其实是[这道](https://www.luogu.com.cn/problem/P3704)，我当时连树状数组都不会打。
- 权当随机的训练了。

**[题意](https://www.luogu.com.cn/problem/P4243)**
- 区间加等差数列，查询一个区间最少可以被划分成几个连续的等差数列。

**分析**
- 首先直接差分，然后修改操作变成简单的区间加。
- 然后问题在于，你得到了一个区间的差分数组，你现在应该干什么？
- 你需要处理的是这样的问题：删掉不相邻（且最少）的几个数，使得剩下的数如果相邻必定相等。
- 设该区间每个长度大于 $1$ 的极大连续相等段中，相隔的长度为 $1$ 的连续相等段的个数（包括头尾，个数可以为 $0$），为数列 $p_1,p_2,\cdots p_m$。
- 那么需要删的数的个数就是：
$$\lceil p_1/2\rceil+\sum_{i=2}^{m-1}\lfloor p_i/2+1\rfloor+\lceil p_m/2\rceil$$
- 它显然是可以进行信息合并的对吧，于是我们快乐地写出我们的小代码。

**实现**
- 得到了 $40$ 分，信心满满！然后发现输出区间长度整除 $2$ 有 $40$ 分！~~不愧是 JSOI~~。
- 进行了乱搞，得到了 $\text{hack}$。
```cpp
11
0 0 0 0 1 2 3 4 3 2 1
1
B 1 11
```
- 发现自己的结构体调用写错了，但是还是 $40$ 分。
- 发现自己没改完，然后过了，[代码](https://www.luogu.com.cn/paste/11i2xbuq)。

---

## 作者：Bezime (赞：0)

找了一道纯线段树的题练练手。

~~这题是线段树黑题里最水的了。~~

看到题目维护区间信息，用线段树啊。

看到等差就想到要用差分，线段树维护（$n-1$）个（相邻的数的）差值。

需要一些变量。

$pre$：当前区间内划分的数列个数（就是要求的答案）。

$wl$，$wr$：从左端点左边的那个数往右 至第一个长度大于等于 $3$ 的序列的 未在长度大于等于3的序列内的 数的个数，右边同理（额外说明，这些数能组成的序列个数为（数的个数+1）/2）（句子有点长，后面简称单独的数）。

$len$：区间长度。

$pl$，$pr$：区间的左右端点下标对应的差值。

$add$：区间加的懒标记。

最难的是上传信息，有了这些，在上传信息时就能维护 $pre$ 了。

上传时如何维护这些变量：

将左区间的 $pl$ 直接赋到当前区间的 $pl$，将右区间的 $pl$ 直接赋到当前区间的 $pr$ 就好了。

将左区间的wl，与右区间的wr 先直接赋值在当前区间的wl与wr内，再看左区间是否全为单独的数，如果是，先将其减一，应为中间的数重复了，再把右区间的wl加上，右区间同理，特殊的，如果中间的数相等，那这些数便能组成一个较长的序列，从而脱离单独的数，这样反而要减一。举个例子：（点是单独的数，数字是差值）

左区间：`· 1 · 2 · -3 · 4 ·`（$wl=5$）

右区间：`· 4 · 3 · -2 · 1 ·`（$wr=5$）

合并后：`· 1 · 2 · -3 · 4 · 4 · 3 · -2 · 1 ·`（$wl=3$，$wr=3$）

将左区间的 $pre$，与右区间的 $pre$ 先直接相加再赋值在当前区间的 $pre$ 内，处理中间合并的信息，先将中间贡献的序列数减去，

若中间没有相同的数（没有固定的序列），在将其单独的数合并，在用（数的个数+1）/2）加回来；

若中间有相同的数（变成固定的序列），将其左边的单独的数用（数的个数+1）/2）加上，再将其右边的单独的数用（数的个数+1）/2）加上，在加上1中间合并了的序列）。

上传完毕。

因为是区间加，需要维护懒标记 $add$，将子区间的 $add$、$pl$ 和 $pr$ 加上懒标记的数就行了（记得把懒标记清零）。

**解析在代码里也有。**

AC代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxm 200002
#define mxn 100002
using namespace std;
struct XD_tree{
    ll l,r;	//左右儿子
    ll pre;	//当前区间内划分的数列个数（就是要求的答案）
    ll wl,wr;	//从左端点左边的那个数往右连续的单独的数的个数
    ll xl,xr;	//区间的左右端点下标（用来求区间大小）
    ll pl,pr;	//区间的左右端点下标对应的差值
    ll add;	//懒标记
}tr[mxn*2];	//维护区间
ll trt,rrt;	//线段树附带的小变量
ll T,n,a[mxn];	//a[i]是i的值减i-1的值（i与i-1的差值）
inline void rd(ll &x){x=0;short f=1;char c=getchar();while((c<'0'||c>'9')&&c!='-') c=getchar();if(c=='-') f=-1,c=getchar();while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();x*=f;}
inline void pt(ll x){if(x<0) putchar('-'),x=-x;if(x>9) pt(x/10);putchar(x%10+'0');}
inline void ptup(XD_tree &p,XD_tree l,XD_tree r){	//上传信息
    p.wl=l.wl,p.wr=r.wr;
    p.pl=l.pl,p.pr=r.pr;
    p.pre=l.pre+r.pre;	//这三句就相当于初始化
    if(l.wl==l.xr-l.xl+2)	//如果左边全是单独的数
        if(l.pr==r.pl) p.wl-=2;	//如果中间的差值相等，则左区间右边两个单独的数不单独了，应减掉
        else p.wl+=r.wl-1;	//否则，加上右边的，又因为左右区间交界处维护了一个一样的数，重复了，应减1
    if(r.wr==r.xr-r.xl+2)	//同理
        if(l.pr==r.pl) p.wr-=2;
        else p.wr+=l.wr-1;
    p.pre-=((l.wr+1)>>1)+((r.wl+1)>>1);	//先将单独的数组成的序列个数减掉，合并完后加回来
    //将区间交界处单独的数合并后能组成的序列个数加上
    if(l.pr==r.pl){	//如果中间的差值相等
        if(l.wr&&r.wl) p.pre+=1+((l.wr-(l.wr>1))>>1)+((r.wl-(r.wl>1))>>1);	//如果中间都有单独的数
        else if(!l.wr&&!r.wl) p.pre--;	//如果中间都没单独的数
        else p.pre+=(l.wr+r.wl-(l.wr>1)-(r.wl>1))>>1;	//如果一边有单独的数，另一边没
    }
    else p.pre+=(l.wr+r.wl)>>1;	//否则
}
inline void doit(ll p,ll k){	//下传信息的分步
    tr[p].add+=k;
    tr[p].pl+=k;
    tr[p].pr+=k;
}
inline void ptdn(ll p){	//下传信息
    doit(tr[p].l,tr[p].add);
    doit(tr[p].r,tr[p].add);
    tr[p].add=0;//懒标记清零
}
inline void bd(ll &p,ll l,ll r){	//建树
    p=++trt;
    tr[p].xl=l;
    tr[p].xr=r;
    if(l==r){
        tr[p].pre=1;	//两个数组成一个区间
        tr[p].wl=tr[p].wr=2;	//两个数
        tr[p].pl=tr[p].pr=a[l];	//当前下标对应的差值
        return;
    }
    ll mid=l+r>>1;
    bd(tr[p].l,l,mid);
    bd(tr[p].r,mid+1,r);
    ptup(tr[p],tr[tr[p].l],tr[tr[p].r]);
}
inline void chg(ll p,ll l,ll r,ll x,ll y,ll k){	//改值
    if(l>y||r<x) return;
    if(l>=x&&r<=y){doit(p,k);return;}
    ll mid=l+r>>1;
    ptdn(p);
    chg(tr[p].l,l,mid,x,y,k);
    chg(tr[p].r,mid+1,r,x,y,k);
    ptup(tr[p],tr[tr[p].l],tr[tr[p].r]);
}
inline XD_tree ask(ll p,ll l,ll r,ll x,ll y){	//询问
    if(l>y||r<x) return (XD_tree){0,0,0,0,0,0,0,0,0,0};
    if(l>=x&&r<=y) return tr[p];
    ll mid=l+r>>1;
    XD_tree lp,rp,ans=(XD_tree){0,0,0,0,0,0,0,0,0,0};
    ans.xl=l,ans.xr=r;
    ptdn(p);
    lp=ask(tr[p].l,l,mid,x,y);	//左区间信息
    rp=ask(tr[p].r,mid+1,r,x,y);	//右区间信息
    if(!lp.pre) return rp;	//如果左边没信息，返回右区间
    if(!rp.pre) return lp;	//如果右边没信息，返回左区间
    ptup(ans,lp,rp);	//合并区间信息
    return ans;	//当前区间信息
}
int main(){
    rd(n);n--;
    ll x,y;
    rd(y);
    for(ll i=1;i<=n;i++)
        rd(x),a[i]=x-y,y=x;	//a储存差值
    bd(rrt,1,n);
    rd(T);
    while(T--){
        char c;
        ll l,r;
        cin>>c,rd(l),rd(r);r--;	//r--更方便（至少我觉得）
        if(c=='A'){	//更改维护的差值
            rd(x),rd(y);
            if(l>1) chg(rrt,1,n,l-1,l-1,x);
            if(r>=l) chg(rrt,1,n,l,r,y);
            if(r<n) chg(rrt,1,n,r+1,r+1,-x-y*(r-l+1));
        }
        else if(r>=l) pt(ask(rrt,1,n,l,r).pre),puts("");	//输出序列个数
        else puts("1");	//如果只有一个数，则不存在差值，须特判，组成一个序列
    }
}
```


---

## 作者：danny101 (赞：0)


[题目传送门](https://www.luogu.com.cn/problem/P4243)

[更好的阅读体验](https://www.luogu.com.cn/blog/d-a-n-n-y-1-0-1/solution-p4243)

#### 题目大意：

给定一个序列，支持两种操作：

- 区间加上一个等差数列

- 求区间最少能被分成几个等差数列

#### 大致思路：

首先，一看区间修改区间查询，肯定是线段树跑不了。但是等差数列不好处理，怎么办呢？那就要用上经典的套路了——差分。比如原数列为：

```
1 1 2 3 4 5 2 5 8 
```

差分后就是

```
1 0 1 1 1 1 -3 3 3
```

可以明显的看出，原数列中的所有等差数列都变成了差分数列中相等的一小段，这样就方便多啦！

接下来该处理两种操作了。

首先是简单的修改，我们可以观察一下规律，还是用上面的例子：

```
1 1 2 3 4 5 2 5 8 
```
差分后为：

```
1 0 1 1 1 1 -3 3 3
```

将 $[2,7]$ 区间加上首项为 $3$，公差为 $2$ 的等差数列，变化后的原数列和等差数列如下：

```
1 4 7 10 13 16 15 5 8
```

```
1 3 3 3 3 3 -1 -10 3
```

可以发现，在差分数列中只需将第一个数增加首项（$a$），以后的每一个数增加公差（$d$），最后一个数减少 $a+(r-l)\times d$ 即可。

接下来就到魔鬼的查询环节了！

接下来维护的就是原数列的差分序列了。注意到，在差分数列中，原数列中的等差数列表现为相等的一段，所以只需要找出区间能被划分成几个相等的序列即可。

首先，每个节点需要维护四个值（下面用 $s1,s2,s3,s4$ 来表示），设 $l,r$ 为当前节点维护的区间的左右端点，则 $s1,s2,s3,s4$ 分别代表 $(l,r),(l,r],[l,r),[l,r]$ 这四个区间的最少划分段数。

接下来，记 $a,b$ 分别为区间的左右端点的值。可以开始合并了！以 $s1$ 的合并为例：

```cpp
tmp.s1=sg[p<<1].s2+sg[p<<1|1].s3-(sg[p<<1].b==sg[p<<1|1].a);
tmp.s1=min(tmp.s1,min(sg[p<<1].s1+sg[p<<1|1].s3,sg[p<<1].s2+sg[p<<1|1].s1));
```

即：双开区间划分的段数就是左子区间的左开右闭区间划分的段数加上右子区间划分的段数。

如果左子区间最后一个数和右子区间第一个数相等，那么可以合并左边的最后一段和右边的第一段，就可以少划分一段。

另外，还要对零散值进行判断，也即上方的第二行。因为还有可能一个双开区间和一个一开一闭区间的组成方式划分段数最小。

四个合并都是类似的，我就直接上核心代码了：

```cpp
struct seg{
    int a,b,s1,s2,s3,s4;
}sg[400001];
//...
void pushup(int p){
    sg[p].a=sg[p<<1].a;
    sg[p].b=sg[p<<1|1].b;
    sg[p].s1=sg[p<<1].s2+sg[p<<1|1].s3-(sg[p<<1].b==sg[p<<1|1].a);
    sg[p].s1=min(sg[p].s1,min(sg[p<<1].s1+sg[p<<1|1].s3,sg[p<<1].s2+sg[p<<1|1].s1));
    sg[p].s2=sg[p<<1].s2+sg[p<<1|1].s4-(sg[p<<1].b==sg[p<<1|1].a);
    sg[p].s2=min(sg[p].s2,min(sg[p<<1].s1+sg[p<<1|1].s4,sg[p<<1].s2+sg[p<<1|1].s2));
    sg[p].s3=sg[p<<1].s4+sg[p<<1|1].s3-(sg[p<<1].b==sg[p<<1|1].a);
    sg[p].s3=min(sg[p].s3,min(sg[p<<1].s3+sg[p<<1|1].s3,sg[p<<1].s4+sg[p<<1|1].s1));
    sg[p].s4=sg[p<<1].s4+sg[p<<1|1].s4-(sg[p<<1].b==sg[p<<1|1].a);
    sg[p].s4=min(sg[p].s4,min(sg[p<<1].s3+sg[p<<1|1].s4,sg[p<<1].s4+sg[p<<1|1].s2));
}
```

---


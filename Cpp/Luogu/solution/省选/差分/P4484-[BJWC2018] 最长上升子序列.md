# [BJWC2018] 最长上升子序列

## 题目描述

现在有一个长度为 $n$ 的随机排列，求它的最长上升子序列长度的期望。

为了避免精度误差，你只需要输出答案模 $998244353$ 的余数。

## 说明/提示

**【样例 \#2 说明】**

这是 $3/2$。

**【数据规模和约定】**

对于 $100 \%$ 的数据，$1 \le n \le 28$。

共有 25 组数据，对于第 $i$ 组数据（$1 \le i \le 25$），$n = i + 3$。

## 样例 #1

### 输入

```
1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
2
```

### 输出

```
499122178
```

## 样例 #3

### 输入

```
3
```

### 输出

```
2
```

# 题解

## 作者：皎月半洒花 (赞：78)

十分感谢GXZ大佬的讲解，此处致以敬意！本蒟蒻对于部分不是很清楚的地方整理了一下，大家可以结合起来食用。

[$Address$](https://www.cnblogs.com/GXZlegend/p/8619335.html)
________________

那么这道题，作为一道显然不是那么可做的题，我们首先来讲一下如何骗分：$next\_permutation$枚举全排列，然后$nlogn$求一遍长度，最终复杂度大约维持在$O(n!\times nlogn)$的水平，看一眼数据规模，好像对于$n\leq 9$的数据，在你的常数小的情况下跑出来时没有什么问题的。

$emmmm$思考一下数据范围，能够用最暴力的方法骗到分的概率极其的低。

于是我们考虑$dp$是否可行。

因为事实上，我们可以看到从左向右推好像不是很可行，于是我们考虑，对于一个排列，我们把数从小到大插入到一个空的数列里面。

那么我们首先令一个$f_i$（~~放心跟程序没啥关系~~）表示，在当前已经确定的一个序列里面，从左至右第$i$个数的最长上升子序列长度。基于这个数组，我们再令$maxL_i$表示前缀最大值，即$$maxL_i = max\{f_1,f_2...,f_i\}$$那么对于这个$maxL$数组，显然有$$maxL_i \leq maxL_{i+1} \leq maxL_{i} +1$$

诶，看上去这个$maxL$数组更加友善一些，因为我们可以差分它。不妨设对其进行差分的数组为$dif$。

_____

回归正题，在我们把数从小到大插入的时候，对于$dif$数组会出现如此情况：

考虑在第$i$位和第$i+1$位之间插入了一个新的数，而因为我们是单调地插入的，所以新插入的这个数一定是当前序列的最大数。那么很显然的是，这个数的$maxL$一定是$maxL_i+1$，因此把$dif_{i+1}$改成$1$，而在$i$之后第一个比$base_i$大的数，记其位置为$pos$，则$dif_{pos}$值肯定也为$1$，但是当我们插入了这个新的数之后，由于在它之前刚刚插入了一个不应该加入$f_{pos}$,所以我们应当把$dif_{pos}$置成零。

那么很显然了，我们接下来要做的就是对$dif$数组进行状压$DP$。

那我们不妨令$dp_{i,j}$表示在一个$1$~$ i$的排列里，差分数组$dif$状态为$j$的方案数，那么答案就是$$ans=\frac{1}{n!}\sum_{i =0}^{2^{n-1}-1}{dp_{n,i}  \times getlen(i)}$$

也就是$\sum$有$n$个数、状态为$i$的方案$\times$方案中的$LIS$的长度。

值得一提的是，由于我们状压了$dif$数组，所以每个方案中$LIS$的长度，就是该状态里$1$的个数。

~~嗯，状压DP就是好啊~~

呃，什么，你说状态转移方程？我感觉像这种只有两维的状压$DP$的方程不都是一个样的吗……


至于代码，有几个$Tricks$值得留意：

$1$、我们发现其实$dp$数组的第一维$i$是可以滚掉的，所以我们就滚掉它，因为实际上我们最后的状态数量达到了$2^{27}$空间承受不起啊！所以我们就要卡着上限开，并且依旧会爆空间$OTZ$

$2$、因为一定会有$$maxL_1 = maxL_0+1= 1$$所以我们可以少状压一次。

$3$、为了便于递推，我所枚举的状态以及一系列都是跟数组的定义规则相同，跟二进制的定义规则相反。

$4$、我们最后由于求的是期望，所以要乘上$n!$的逆元，费马小定理求即可。

$5$、注意是取反号而不是取非号.因为我们在状压的时候，全0也是状态的一部分，所以我们在从后往前枚举（为了便于计算后面将要被置成的0）时应该到-1停止而不是到0停止。
```cpp

#include <cstdio>
#include <cstring>
#include <iostream>
#define ll long long

using namespace std ;
const ll mod = 998244353LL ;
ll dp[2][134217730], getlen[134217730] ;
ll Mx, N, i, j, k, ans, fac = 1, now, t, pos ;

inline ll lowbit(ll x){return x & (-x) ; }
inline ll my_pow(ll a, ll b){
    ll res = 1 ;
    while(b){
        if(b & 1)res = (res * a) % mod ;
        a = (a * a) % mod ;
        b >>= 1 ;
    }
    return res ;
}
int main(){
    cin >> N ; N -- ; dp[0][0] = 1 ; Mx = 1 << N ;
    for(now = i = 1; i <= N ; now ^= 1, i ++){
        fill(dp[now], dp[now] + (1 << i), 0) ;
        for(j = 0; j < (1 << (i - 1)); j ++){
           dp[now][j << 1] = (dp[now][j << 1] + dp[now ^ 1][j]) % mod, pos = -1 ;
            for(k = i - 1; ~k ; k --){
                t = ((j >> k) << (k + 1)) | (1 << k) | (j & ((1 << k) - 1)) ;//(j >> k) << (k + 1)是为了先清掉后面的几位所以不能简写成j << 1
                if(j & (1 << k)) pos = k ;
                if(~pos) t ^= (1 << (pos + 1)) ;
                dp[now][t] = (dp[now][t] + dp[now ^ 1][j]) % mod ;
            }
        }
    }
    for(i = 1; i < Mx; i ++) getlen[i] = getlen[i - lowbit(i)] + 1 ;
    for(i = 0; i < Mx; i ++) ans = ( ans + 1ll * dp[N & 1][i] * (getlen[i] + 1) ) % mod ;
    for(i = 1; i <= N + 1 ; i ++) fac = (fac * i) % mod ;
    ans = ans * my_pow(fac, mod - 2) % mod ;
    cout << ans ;
    return 0 ;
}

```

但是无论如何，写这样一个状压DP，只能得到76分，开$O2$的话可以得到80分，是因为最终时间复杂度为$O(2^n \times n^2)$，空间的话也是大的要死，放在普通的的状压DP里面
已经足够优秀了，但是由于这个题的数据达到了惊人的$2^{27}$，所以我们最终选择用更前卫的方式解决：

# 打表

嗯，于是这个题就结束了。其实这个题据说有更优秀的做法，需要用到杨氏矩阵等。而因为本蒟蒻在省队集训的时候走神了，所以并不会杨氏矩阵$OTZ$

最后再贴一下打表的代码吧：

```cpp

#include <cstdio>
#include <iostream>

int N ; 
int List[50]={19260817, 1,499122178,2,915057326,540715694,946945688,422867403,451091574,317868537,200489273, 976705134,705376344,662845575,331522185,228644314,262819964,686801362,495111839,947040129,414835038,696340671,749077581,301075008,314644758,102117126,819818153,273498600,267588741} ;

int main(){
    std::cin >> N ;
    std::cout << List[N] ; 
    return 0;
}

```



---

## 作者：Elegia (赞：71)

一个基于杨表的暴力：

由杨表的构造过程可知，一个序列构建的杨表其第一行长度就是 LIS 长度。因此我们想知道：对于每个 $1\le k \le n$，对于一个长为 $n$ 的排列，有多少种排列使得杨表的第一行长度为 $k$。

Robinson-Schensted correspondence 定理指出，对于任何两个相同形状的杨表（填数的顺序可能不同），可以与排列建立一一对应。

因此我们要求的就是

$$ \frac 1{n!}\sum_{\lambda \vdash n} f_\lambda ^2 \lambda_1$$

其中 $\lambda \vdash n$ 是一个 $n$ 的整数拆分，$f_\lambda$ 是 $\lambda$ 这个整数划分的填法数量。通过 Hook 公式可以在 $\Theta(n)$ 时间内计算。

因此如果枚举所有的整数划分，则可以在 $\Theta(np(n))$ 的时间内解决本题。

注意 $p(n) \sim \frac1{4n\sqrt 3}\exp \left(\pi \sqrt\frac{2n}3\right)$，这是一个效率相当优秀的亚指数算法。

---

## 作者：Flanksy (赞：16)

### 状态压缩动态规划

------------

#### 前言 

笔者花了四天终于过题，想在这里详细解释一下代码实现中的各种坑点和自己的实现方法。~~网上查的所有题解都觉得转移很显然，然而对于刚学状压 dp 的某人来说一点也不显然。~~

根据查到的资料 OEIS 上应该有这个数列。

------------

#### 题意转化

下文中 $lis$ 表示最长上升子序列。

仿照一般情况求 $lis$ 的过程，使用 $f_i$ 表示以第 $i$ 个元素结尾的 $lis$ 长度，参考树状数组求 $lis$ 的过程，使用 $pre_i$ 表示序列 $f$ 到 $i$ 为止的前缀最大值，序列 $pre$ 是不降的。对 $pre$ 差分得到序列 $dif$，$dif_i=1$ 说明 $pre_i=pre_{i-1}+1$，否则 $pre_i=pre_{i-1}$。由于序列 $dif$ 仅含有 $01$，可以状压。

将数字从小到大插入排列。设插入的位置为 $p$，由于钦定了顺序，每次插入的数都是目前排列中最大的数，$pre_p$ 会被更新为 $pre_{p-1}+1$，所以 $dif_p$ 应当置 $1$。

如果位置 $p$ 后不全为 $0$，设 $p$ 之后第一个 $1$ 的位置为 $x$，将 $dif_x$ 置为 $0$，因为本来有 $pre_x=pre_{x-1}+1$，插入当前最大的数之后变为 $pre_x=pre_{x-1}$ 了。

------------

#### 实现细节

因为实现方法多种多样，思路不联系程序很难写明。以下内容中存在几个意义和程序中相同的、前文中未说明的变量。

- 序列 $f$ 和 $pre$ 仅用来推导，实现中完全不需要关心。

- 因为从当前状态反推出原集合状态较难，采用发送型转移。

- 数据范围中 $n\leq 28$，根据不同的实现方法时间复杂度将是 $O(n2^n)$ 或 $O(n^22^n)$，空间复杂度 $O(2^n)$，直接考虑打表。

- **由于一定存在 $dif_1=1$，实际有 $n$ 个数的状态只需要记录最后 $n-1$ 位**（如果想要记录全部 $n$ 位，必须限定状态首位为 $1$，实现更复杂并且空间翻倍）。

- 每次枚举一个原有的集合状态，在位置 $p$ 插入当前序列最大的数实际上就是在 $dif$ 序列中的位置 $p$ 插入 $1$，再把 $p$ 后面第一个 $1$ 置为 $0$。所以直接枚举在哪个位置插入 $1$ 即可。**插入后序列增加一个二进制位**。

- 使用变量 $l,r$ 配合 `__builtin_clz` 实现将插入位置后的第一个 $1$（如果存在）置为 $0$ 并求出插入后状态的操作。

- 状态中 $1$ 的个数就是其 $lis$ 长度减一的值（$dif_1=1$ 不在状态中），用 `__builtin_popcount` 统计。

- **由于状态中缺少首位信息，代码里需要单独实现将当前数放到序列首位的转移**，直接把 $dp_{last,i}$ 作为贡献发送给 $dp_{now,i}$ 即可。代码里每选定一个原有状态都循环 $T-1$ 次，考虑了**除把当前数放到序列最左端的情况外的所有情况**。由于状态设计中不包含 $dif_1$ 并且默认 $dif_1=1$，不需要进行任何操作来插入新的 $1$。在循环中序列的长度将会显式扩展一位（`l<<1`），**而在特判中被置 $0$ 的位就是原先作为 $dif_1$ 的位，这一位没有被显式地扩展，也没有显式地被置 $0$（本来就是 $0$）**。

- 可以使用 `bitset` 输出中间变量来帮助理解程序内容和查错。

将代码中的注释去掉可以比较直观地看到二进制下状态的生成和转移，这里举一个例子帮助理解。

从 $n=8$ 向 $n=9$ 的情况转移，在标记红色的两个二进制位中间插入一个蓝色标记的 $1$，用天蓝色标记变量 $l,r$ 的有效二进制位：

$01\textcolor{red}{00}101 \rightarrow 01\textcolor{red}{0}\textcolor{blue}{1}\textcolor{red}{0}001$。

插入前 $l=\textcolor{skyblue}{010}0000,r=000\textcolor{skyblue}{0101}$，插入后 $l=\textcolor{skyblue}{0100}000,r=0000\textcolor{skyblue}{101}$。

$010\textcolor{red}{01}01 \rightarrow 010\textcolor{red}{0}\textcolor{blue}{1}\textcolor{red}{0}01$。

插入前 $l=\textcolor{skyblue}{0100}000,r=0000\textcolor{skyblue}{101}$，插入后 $l=\textcolor{skyblue}{01001}00,r=00000\textcolor{skyblue}{01}$。

打表的时间复杂度为 $O(n2^n)$，实测可以在一分钟内完成求解。

```cpp
#include<bits/stdc++.h>
#define popcount __builtin_popcount
#define clz __builtin_clz
using namespace std;
constexpr int mod=998244353;
ofstream fout("ans.cpp");
long long ans,fac,*dp[2]={new long long[1<<27],new long long[1<<27]};
long long inv(long long x){
    long long ret=1ll;
    for(int i=mod-2;i;i>>=1){
        if(i&1) ret=ret*x%mod;
        x=x*x%mod;
    }
    return ret;
}
inline int viv(int x){return x ? (x^(1<<(31-clz(x)))):0;}//viv(x)返回x去掉二进制下最高位1的值 
int main(){
    fac=1ll,dp[1][0]=1ll;//n=1的情况下状态没有任何二进制位,所以在0初始化
    fout<<1<<','<<'\n';
    for(int T=2;T<=28;T++){//利用dp[T-1]刷表,一次求出所有答案 
        const int V=T&1,lim=(1<<(T-2))-1;
        fill(dp[V],dp[V]+lim+1,0ll);
        for(int i=0;i<=lim;i++) if(dp[V^1][i]){//枚举上一种情况数
            const long long add=dp[V^1][i];
            int l=0,r=i;//每次循环之后把r二进制下剩余的最高位转到l 
            dp[V][i]=(dp[V][i]+add)%mod;//把T插到序列首位的转移
            for(int j=T-2;~j;j--){
                const int to=(l<<1)|(1<<j)|viv(r);//用l和r拼出目标状态 
                dp[V][to]=(dp[V][to]+add)%mod;
                if(j&&(r&(1<<(j-1)))) l|=(1<<(j-1)),r^=(1<<(j-1));//注意j不能等于0 
//              cerr<<bitset<4>(i)<<' '<<bitset<4>(l)<<' '<<bitset<4>(r)<<' '<<bitset<4>(to)<<'\n';
            }
        }
//      for(int i=0;i<=(1<<(T-1))-1;i++) cerr<<bitset<4>(i)<<' '<<dp[V][i]<<'\n';
        cerr<<"Round "<<T<<" Ended\n";
//		if(T==4) break;
        ans=0ll,fac=fac*T%mod;
        for(int i=0;i<=(1<<(T-1))-1;i++) ans=(ans+dp[V][i]*(popcount(i)+1ll))%mod;
        ans=ans*inv(fac)%mod;
        fout<<ans<<','<<'\n';
    }
    return 0;
}
```


---

## 作者：tzc_wk (赞：11)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P4484)

首先看到 LIS 我们可以想到它的 $\infty$ 种求法（bushi），但是对于此题而言，既然题目出这样一个数据范围，硬要暴搜过去也不太现实，因此我们需想到用某种奇奇怪怪的方式进行状态压缩 DP，这样一来就可以排除掉不少常用的求 DP 的方法：譬如最常用的**从左往右顺着钦定元素**并设 $f_i$ 表示以 $i$ 结尾的 LIS 的长度的方法，因此考虑换个角度，**从小到大添加元素**。还是设 $f_i$ 表示以 $i$ 结尾的 LIS 的长度，那么考虑在一轮中，我们在 $i$ 和 $i+1$ 这两个位置中间插入一个比当前所有数都大的数会对 $f$ 产生怎样的影响，有：

- $f_{i+1}=1+\max\limits_{j=1}^if_j$
- 对于 $j>i$，有新的 $f_{j+1}$ 等于 $f_j$。

注意到这里涉及前缀 $\max$，因此设 $mf_i=\max\limits_{j=1}^if_j$，又注意到相邻两个 $mf_i$ 的差最多为 $1$，因此考虑 $mf_i$ 的**差分序列** $d_i=mf_i-mf_{i-1}$，根据之前的推论显然它是一个 $01$ 序列，这样就天然地形成了状压 $dp$ 的模型。由于我们的 $dp$ 都建立在差分序列的基础上，因此我们再来探究下加入一个比当前所有数都大的数会对差分序列产生怎样的影响：

- $d_{i+1}=1$
- 对于所有 $j\ge i+1$，有新的 $d_{j+1}$ 等于原来的 $d_j$。
- 进行以上两个操作之后，我们找到 $i+1$ 后面第一个 $d_j=1$ 的 $j$——如果不存在这样的 $j$ 则跳过这一步，并令 $d_j=0$。

这样我们就可以设 $dp_{i,j}$ 表示当前插入了 $1\sim i$，$d$ 的状态为 $j$ 的方案数，转移就枚举在哪里插入 $i+1$，然后二进制模拟 $d$ 的变化即可。注意到 $j$ 只用枚举到 $2^i$，因此 $(i,j)$ 的总枚举量是 $2^n$ 的，再加上转移的 $n$，总复杂度 $2^n·n$，注意滚动数组优化空间，否则会获得 MLE 0 的好成绩。

```cpp
void add(int &x,int v){((x+=v)>=MOD)&&(x-=MOD);}
int qpow(int x,int e){
	int ret=1;
	for(;e;e>>=1,x=1ll*x*x%MOD) if(e&1) ret=1ll*ret*x%MOD;
	return ret;
}
int n,dp[2][134217733];
int main(){
	scanf("%d",&n);
	dp[1][1>>1]=1;int nxt=0,cur=1;
	for(int i=1;i<n;i++){
		for(int j=0;j<(1<<i+1);j++) dp[nxt][j>>1]=0;
		for(int j=1;j<(1<<i);j+=2) if(dp[cur][j>>1]){
//			printf("%d %d %d\n",i,j,dp[cur][j]);
			for(int k=0;k<=i;k++){
				int nmsk=0;
				if(k) nmsk=j&((1<<k)-1);
				nmsk|=(1<<k);
				int rst=((1<<i)-1)^((!k)?0:((1<<k)-1));
				nmsk|=(j&rst)<<1;
				if((j&rst)){int S=j&rst;nmsk^=(S&(-S))<<1;}
				add(dp[nxt][nmsk>>1],dp[cur][j>>1]);
			}
		} swap(cur,nxt);
	} int res=0,fac=1;
	for(int i=1;i<(1<<n);i+=2) res=(res+1ll*__builtin_popcount(i)*dp[cur][i>>1])%MOD;
	for(int i=1;i<=n;i++) fac=1ll*fac*i%MOD;
	res=1ll*res*qpow(fac,MOD-2)%MOD;
	printf("%d\n",res);
	return 0;
}
```

直接按照上面的做法写大约会 TLE 3~6 个点，取决于你的实现，不过注意到这题长得一脸打表的样子，于是你对 $n$ 比较大的情况在本地跑一下上面的代码，算出答案特判下即可通过此题。

~~并没有看懂楼下 EI 神仙的题解~~

```cpp
void add(int &x,int v){((x+=v)>=MOD)&&(x-=MOD);}
int qpow(int x,int e){
	int ret=1;
	for(;e;e>>=1,x=1ll*x*x%MOD) if(e&1) ret=1ll*ret*x%MOD;
	return ret;
}
int n,dp[2][134217733];
int main(){
	scanf("%d",&n);
	if(n==22) return puts("749077581"),0;
	if(n==23) return puts("301075008"),0;
	if(n==24) return puts("314644758"),0;
	if(n==25) return puts("102117126"),0;
	if(n==26) return puts("819818153"),0;
	if(n==27) return puts("273498600"),0;
	if(n==28) return puts("267588741"),0;
	dp[1][1>>1]=1;int nxt=0,cur=1;
	for(int i=1;i<n;i++){
		for(int j=0;j<(1<<i+1);j++) dp[nxt][j>>1]=0;
		for(int j=1;j<(1<<i);j+=2) if(dp[cur][j>>1]){
//			printf("%d %d %d\n",i,j,dp[cur][j]);
			for(int k=0;k<=i;k++){
				int nmsk=0;
				if(k) nmsk=j&((1<<k)-1);
				nmsk|=(1<<k);
				int rst=((1<<i)-1)^((!k)?0:((1<<k)-1));
				nmsk|=(j&rst)<<1;
				if((j&rst)){int S=j&rst;nmsk^=(S&(-S))<<1;}
				add(dp[nxt][nmsk>>1],dp[cur][j>>1]);
			}
		} swap(cur,nxt);
	} int res=0,fac=1;
	for(int i=1;i<(1<<n);i+=2) res=(res+1ll*__builtin_popcount(i)*dp[cur][i>>1])%MOD;
	for(int i=1;i<=n;i++) fac=1ll*fac*i%MOD;
	res=1ll*res*qpow(fac,MOD-2)%MOD;
	printf("%d\n",res);
	return 0;
}
```



---

## 作者：luogu_gza (赞：8)

这道题目的 EI 做法我最近调过了，给大家解释一下 EI 的做法。

首先，最长上升子序列就是对于排列构造杨表的第一行的长度。

因此，我们枚举杨表的形状，利用钩长公式来计算对于一个杨表可能的排列种数。

EI 给出了一个式子。

$$ \frac 1{n!}\sum_{\lambda \vdash n} f_\lambda ^2 \lambda_1$$

我用人话来解释一下（就是程序运行的过程）。

首先，枚举 $\lambda$，也就是 $n$ 的一个整数拆分。

什么是整数拆分？就是若有 $a_1 \geq a_2 \geq a_3 \geq \cdots \geq a_n$，则称 $a$ 为 $\sum_{i=1}^{n}a_i$ 的一个整数拆分。

$f_{\lambda}^{2}$ 就是这个整数拆分的种数的平方。

$\lambda_1$ 就是所构造的杨表的第一行，也就是最长上升子序列的长度。

注意，我们要求的是期望，所以最后还要除以总的情况数量，也就是 $n$ 的阶乘。

[record](https://www.luogu.com.cn/record/121805894)

[代码](https://paste.ubuntu.com/p/36Wt7nCmHk/)

---

## 作者：UnyieldingTrilobite (赞：6)

[题面](https://www.luogu.com.cn/problem/P4484)。

不难发现最长上升子序列是这个排列的杨表的第一行长度。根据 Robinson–Schensted correspondence 可知两个同形态的杨表双射排列，所以本质上我们就是要对于每种不同的大小为 $n$ 的杨表形状，求出它有多少种填数方案，平方后乘上第一行长度，最后所有加起来除以 $n!$ 即为答案。

杨表形状这个事情本质上就是 $n$ 的正整数拆分数。这个东西不太好估但我们可以直接打个暴搜发现 $n\le 28$ 时至多 $3718$，所以直接嗯做就完事了。至于给定形状杨表填数，这个可以直接上钩长公式做掉。

于是做完了。代码非常好写。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
constexpr int mod = 998244353;
int n, *a, ans;
int calcf(int t) {
  __int128 ans = 1;
  for (int i = 1; i <= n; ++i) ans *= i;
  for (int i = 0; i < t; ++i)
    for (int j = t - 1, k = 0; k < a[i]; ++k) {
      while (a[j] <= k) --j;
      ans /= a[i] - k + j - i;
    }
  ans %= mod;
  return ans * ans % mod;
}
void dfs(int i, int m) {
  if (!m)
    (ans += calcf(i) * a[0]) %= mod;
  else if (int& x = a[i] = i ? min(a[i - 1], m) : m)
    while (x) dfs(i + 1, m - x), --x;
}
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  cin >> n, a = new int[n], dfs(0, n);
  for (int i = 1; i <= n; ans /= i++)
    while (ans % i) ans += mod;
  return cout << ans << endl, delete[] a, 0;
}
```

---

## 作者：Frank_G (赞：3)

蒟蒻通过的第 **400** 题，写个题解庆祝一下。

[题目传送门](https://www.luogu.com.cn/problem/P4484)。

我看题解里巨佬都用杨表做。

那我就用~~杨表（bushi~~ 打表的方法来吧。

### 简述题意：

求长度为 $n(n\le 28)$ 的排列的最长上升子序列的**期望**。

### Solve：

#### PART 1:

由于我们求的是最长上升子序列，所以我们其实并不关注每一个数的值具体是多少，而是关注**两数之间的大小关系（即大于或小于等于）**。

**因此，我们可以将这个问题转化成将排列 $1,2,3……n$ 随机重排后的排列的最长上升子序列的期望。**

#### PART 2:

此时我们可以对状态进行描述（用 $n$ 位二进制的数表示），即**每一位用 $1$ 表示以这一位结尾的序列的最长上升子序列中包含这一位，用 $0$ 表示不包含**，将重排后的状态进行压缩（且显然每一个状态对应的序列的最长上升子序列的长度就是**这个二进制数中 $1$ 的个数**），之后用 **dp** 的方法求出所有重排的排列的最长上升子序列的长度和 $\sum\limits_{i=0}^{2^{n-1}-1} dp_{n,i}\times len(i)$。

这个方法的时间复杂度为 $O(n^2\times 2^n)$，几分钟就搞定了（蒟蒻亲测有效）。

#### PART 3：

最后再由数学期望的公式：$E(x)=\frac{\sum\limits_{i=1}^n X_i}{n}$，

得到最终的结果（此处需用逆元处理）：$ans=\frac{\sum\limits_{i=0}^{2^{n-1}-1} dp_{n,i}\times len(i)}{n!}$。

### 打表代码：


```cpp
const int mod=998244353;
freopen("P4484.out","w",stdout);
for(int n=1;n<=28;n++){
	for(int i=1,flag=1;i<=n;i++,flag^=1){
		fill(dp[flag],dp[flag]+(1<<i),0);
		for(int j=0;j<(pow(2,i-1));j++){
			dp[flag][pow(2,j)]=(dp[flag][pow[2,j]]+dp[flag^1][j])%mod;
			int flag1=-1;
			for(int l=i-1;l>=0;l--){
				int flag2=((j/pow(2,k))*pow(2,k+1))|pow(2,k)|(j&(pow(2,k)-1));
				if(j&(pow(2,k))) flag1=k;
				if(flag1) flag2^=(1<<(flag1+1));
				dp[flag][flag2]=(dp[flag][flag2]+dp[flag^1][j])%mod;
			}
		}
	}
	long long ans=0;
	for(int i=0;i<pow(2,n-1);ij++)ans=(ans+(__builtin_popcount(i)+1)*dp[n&1][i]%mod)%mod;
	for(int i=1;i<=n;i++)ans=ans*fpow(i,mod-2)%mod;
	cout << ans << ",";
}
	
```

### My code:

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,a[29]={0,1,499122178,2,915057326,540715694,946945688,422867403,451091574,317868537,200489273, 976705134,705376344,662845575,331522185,228644314,262819964,686801362,495111839,947040129,414835038,696340671,749077581,301075008,314644758,102117126,819818153,273498600,267588741};
int main(){
    cin >> n;
    cout << a[n];
    return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/197185684)。

完结撒花~~~

---

## 作者：TernaryTree (赞：2)

相当优秀的拆分数复杂度算法，爱来自杨表。

考虑枚举杨表的形态即枚举杨图，这显然是拆分数级别的。

众所周知排列 $\pi$ 与杨表对 $(P_{\pi},Q_{\pi})$ 构成**双射**；其中 $P_{\pi}$ 是主表，记录每次插入的 $\pi_i$；$Q_{\pi}$ 是副表，记录每次插入的 $i$。两者形态相同。

众所周知杨表主表的第一行长度就是排列的 LIS 长度。

众所周知对于一个杨图，里面填上排列，使得其成为一个杨表的方案数是 $\dfrac{n!}{\prod_{x} \text{hook}(x)}$，即 $n!$ 除以每个格子的勾长。勾长定义为当前格子往下往右的格子个数（包含自己）。计其方案数为 $w$，则当前杨图可以对应 $w^2$ 个排列。

方案数乘上第一行的长度，求和，最后再除以 $n!$ 即可得到答案。跑的飞快。

```cpp
void dfs(int cur, int lst) {
	if (!cur) {
		int mul = fac[n];
		rep(i, 0, a.size() - 1) {
			rep(j, 1, a[i]) {
				int cnt = a[i] - j;
				rep(k, 0, i) cnt += j <= a[k];
				mul = mul * inv[cnt] % mod;
			}
		}
		(ans += mul * mul % mod * a.back() % mod) %= mod;
		return;
	}
	rep(i, lst, cur) {
		a.push_back(i);
		dfs(cur - i, i);
		a.pop_back();
	}
}
```

---

## 作者：YNH_QAQ (赞：1)

### P4484 题解
#### 状态压缩（打表）

1. 维护一个数组 $sum_i$，表示前缀最大值，可得式子 $sum_i\le sum_{i+1}\le sum_i+1$，对这个数组的差分数组状态压缩。可得状态：$dp_i$ 表示以第 $i$ 个数结尾的最长上升子序列的长度。

2. 答案为 $\sum$ 每种状态的数目 $\times$ 每种状态的最长上升子序列长度。
$$\frac{\sum_{i=0}^{2^{n-1}-1}{dp_{n,i} \times len(i)}}{n!}$$

3. 状态转移：
```cpp
for(int i=1,cur=1;i<=n;cur^=1,i++){
    fill(dp[cur],dp[cur]+(1<<i),0);
    for(int j=0;j<(1<<(i-1));j++){
        dp[cur][j<<1]=(dp[cur][j<<1]+dp[cur^1][j])%mod;
		pos=-1;
        for(int k=i-1;~k;k--){
            t=((j>>k)<<(k+1))|(1<<k)|(j&((1<<k)-1));
            if(j&(1<<k)) pos=k;
            if(~pos) t^=(1<<(pos+1));
            dp[cur][t]+=(dp[now^1][j])%mod;
        }
    }
}
```

4. 初始状态：$dp_{0,0}=1$。

时间复杂度：$O(n^2\times 2^n)$，虽然 $n$ 只有 $28$，但仍然超时。

#### code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105]={19260817, 1,499122178,2,915057326,540715694,946945688,422867403,451091574,317868537,200489273, 976705134,705376344,662845575,331522185,228644314,262819964,686801362,495111839,947040129,414835038,696340671,749077581,301075008,314644758,102117126,819818153,273498600,267588741};//根据状压打出来的表
int main(){
    cin>>n;
    cout<<a[n]; 
    return 0;
}

```

---

## 作者：Grisses (赞：1)

好题。

记 $f_i$ 表示前 $i$ 个数组成的序列的 LIS 长度。

考虑将 $1\sim n$ 依次插入序列，即时维护整个 $f$ 数组，可以发现 $f_i-f_{i-1}\le 1$，因此我们可直接维护 $f$ 数组的差分。

考虑插入一个数会对 $f$ 数组产生什么影响，首先是在这个位置的差分数组插入一个 1，再把后面的第一个 1 变成 0（具体可以自己画一画）。

也就是说，我们可以在 $\sum\limits_{i=1}^ni2^i=O(n2^n)$ 的时间复杂度内求解，但是你发现这玩意要跑 10+s 啊。

发现这个题一共就这么几种输入，直接打表就可以了。

注意开数组的时候因为 $f_1$ 一定等于 1，所以可以只开到 $2^{27}$，然后再滚动一下空间就没有什么压力了。

---

代码：
```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x&-x)
using namespace std;
const int mod=998244353;
int fpow(int a,int b){
	int res=1;
	while(b){
		if(b&1)res=1ll*res*a%mod;
		a=1ll*a*a%mod;
		b>>=1;
	}
	return res;
}
int n,dp[2][1<<27];
signed main()
{
	for(int n=4;n<=28;n++){
		dp[1][0]=1;
		for(int i=1;i<n;i++){
			for(int j=0;j<(1<<i);j++)dp[(i+1)&1][j]=0;
			for(int j=0;j<(1<<i-1);j++){
				int tt=j*2+1;
				for(int p=0;p<=i;p++){
					int to=(tt%(1<<p))+(1<<p)+((tt>>p)<<p+1);
					if(to>>(p+1)){
						to^=(1<<(__builtin_ffs(to>>(p+1))+p));
					}
					to>>=1;
					dp[(i+1)&1][to]=(dp[(i+1)&1][to]+dp[i&1][j])%mod;
				}
			}
		}
		int ans=0;
		for(int j=0;j<(1<<n-1);j++)ans=(ans+1ll*(__builtin_popcount(j)+1)*dp[n&1][j]%mod)%mod;
		for(int i=1;i<=n;i++)ans=1ll*ans*fpow(i,mod-2)%mod;
		printf("if(n==%d)printf(\"%%d\",%d);\n",n,ans);
	}
	return 0;
}
```

---

## 作者：Priestess_SLG (赞：0)

不会杨表，所以使用 dp of dp 来求解这个问题。

有一定思维含量的 dp of dp 题。先考虑内层求 LIS 的过程。设 $f_i$ 表示当前以 $i$ 结尾的 LIS 长度最长是多少，转移就是再插入一个数是容易的，但是将其压缩到 dp 数组中是困难的。有一个想法是康托展开，但是仍然有 $n!$ 种不同状态。还有另一种想法是对 $f_i$ 求前缀 $\max$，但是这样转移又变得困难了。

考虑换一个方式做 LIS：还是 dp，但是换一个方式。设 $f_i$ 表示当前以 $1\sim i$ 结尾的 LIS 长度最长是多少，然后**将序列中所有数字从小到大插入到 dp 中**。考虑其正确性：因为钦定所有数从小到大插入到 dp 中，所以每一次转移的一定是一段连续的前缀，而 $f_i$ 则正好表示的是一段连续的前缀，因此其正确性没有问题。而此时相邻两个位置的差要么是 $0$ 要么是 $1$，因此此时可以把状态压到 dp of dp 的计数中。而外层 dp 则可以设 $dp_{i,j}$ 表示前 $i$ 个位置当前状压的 $f$ 状态为 $j$ 的方案数，剩下的就是套路转移了。

直接做跑的非常慢，考虑做一个小小的优化：发现 $f$ 数组每在 $i$ 位置插入一个数，都会使得 $i$ 位置从 $0$ 变成 $1$。而如果此时 $i$ 后面存在一个位置为 $1$，则该位置会从 $1$ 变为 $0$，证明显然。很明显可以通过简单的位运算来优化，省掉一个 $O(n)$ 的枚举。因此总时间复杂度为 $O(n^22^k)$，可以获得 $72\sim 80$ 分。

```cpp
// #pragma GCC optimize(3,"Ofast","inline")
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2000010;
const int mod=998244353;
const int inf=1e18;
int dp[2][N+200000];
int fac[30],inv[30],ifac[30];
//当前长度为 n, 状态为 j, 在 DFA 上找出插入 nw 位置的元素后新的 id
int trans(int n,int j,int nw,int &lasp){
    int mask=((j>>nw)<<(nw+1))|(1<<nw)|(j&((1<<nw)-1));
    if(j>>nw&1)lasp=nw;
    if(~lasp)return mask^(1<<(lasp+1));
    return mask;
}
inline void add(int &a,int b){
    a+=b;if(a>=mod)a-=mod;
}
signed main(){
    cin.tie(0)->sync_with_stdio(false);
    int n;cin>>n;--n;
    fac[0]=inv[0]=ifac[0]=fac[1]=inv[1]=ifac[1]=1;
    for(int i=2;i<30;++i){
        fac[i]=fac[i-1]*i%mod;
        inv[i]=mod-inv[mod%i]*(mod/i)%mod;
        ifac[i]=ifac[i-1]*inv[i]%mod;
    }
    dp[0][0]=1;
    for(int i=1;i<=n;++i){
        memset(dp[i&1],0,sizeof dp[i&1]);
        for(int j=0;j<(1<<(i-1));++j){
            add(dp[i&1][j<<1],dp[~i&1][j]);
            int pos=-1;
            for(int k=i-1;~k;--k){
                int nw=trans(i,j,k,pos);
                add(dp[i&1][nw],dp[~i&1][j]);
            }
        }
    }
    int sum=0;
    for(int i=0;i<(1<<n);++i)add(sum,dp[n&1][i]*(1+__builtin_popcount(i))%mod);
    cout<<sum*ifac[n+1]%mod<<'\n';
}
```

但是仍然无法通过 $n\ge 20$ 的数据。因此考虑在本地打表处理答案然后直接提答，如果手动开 Ofast 的话跑的飞快（$15$ 秒之内就能处理完全部的答案，也可能是我的机子比较好）如果还嫌慢而且有 money 的话可以考虑租机（

完整代码：

```cpp
// #pragma GCC optimize(3,"Ofast","inline")
#include<bits/stdc++.h>
using namespace std;
const int N=2000010;
const int mod=998244353;
const int inf=1e18;
int dp[2][(1ll<<27)+10];
int fac[30],inv[30],ifac[30];
//当前长度为 n, 状态为 j, 在 DFA 上找出插入 nw 位置的元素后新的 id
int trans(int n,int j,int nw,int &lasp){
    int mask=((j>>nw)<<(nw+1))|(1<<nw)|(j&((1<<nw)-1));
    if(j>>nw&1)lasp=nw;
    if(~lasp)return mask^(1<<(lasp+1));
    return mask;
}
inline void add(int &a,int b){
    a+=b;if(a>=mod)a-=mod;
}
signed main(){
    cin.tie(0)->sync_with_stdio(false);
    int n;cin>>n;
    if(n>=20){
        switch(n){
            case 20:cout<<414835038<<'\n';break;
            case 21:cout<<696340671<<'\n';break;
            case 22:cout<<749077581<<'\n';break;
            case 23:cout<<301075008<<'\n';break;
            case 24:cout<<314644758<<'\n';break;
            case 25:cout<<102117126<<'\n';break;
            case 26:cout<<819818153<<'\n';break;
            case 27:cout<<273498600<<'\n';break;
            case 28:cout<<267588741<<'\n';break;
        }
        return 0;
    }
    --n;
    fac[0]=inv[0]=ifac[0]=fac[1]=inv[1]=ifac[1]=1;
    for(int i=2;i<30;++i){
        fac[i]=1ll*fac[i-1]*i%mod;
        inv[i]=mod-1ll*inv[mod%i]*(mod/i)%mod;
        ifac[i]=1ll*ifac[i-1]*inv[i]%mod;
    }
    dp[0][0]=1;
    for(int i=1;i<=n;++i){
        // memset(dp[i&1],0,sizeof dp[i&1]);
        for(int j=0;j<(1<<i);++j)dp[i&1][j]=0;
        for(int j=0;j<(1<<(i-1));++j){
            add(dp[i&1][j<<1],dp[~i&1][j]);
            int pos=-1;
            for(int k=i-1;~k;--k){
                int nw=trans(i,j,k,pos);
                add(dp[i&1][nw],dp[~i&1][j]);
            }
        }
    }
    int sum=0;
    for(int i=0;i<(1<<n);++i)add(sum,1ll*dp[n&1][i]*(1+__builtin_popcount(i))%mod);
    cout<<1ll*sum*ifac[n+1]%mod<<'\n';
}
```

---

## 作者：CNS_5t0_0r2 (赞：0)

思路参考 @皎月半洒花 大佬的思路，用了一种更好理解但效率更低的实现方法。

设 $f_i$ 为以 $i$ 结尾的最长上升子序列的长度，再设 $pre_i$ 为 $\max_{j = 1} ^ i f_j$，则有 $pre_{i - 1} + 1 \geq pre_i \geq pre_{i - 1}$，记 $dif_i = pre_i - pre_{i - 1}$，则 $dif$ 数组中只含有 $0,1$，考虑状压。

将 $dif$ 状压成一个二进制数 $S$，$S$ 的最低位代表 $dif_1$。

设状态比较好想，因为 $S$ 比较大，所以猜想另一位大概率是排列的长度，所以设 $dp_{i,S}$ 表示排列长度为 $i$，$dif$ 数组为 $S$ 时的排列数（排列的长度就是 $\operatorname{popcount}(S)$）。

新加入的数肯定是整个排列中最大的数，所以肯定是要在上一个状态中插入 $1$ 的，考虑枚举插入的位置 $k$（相当于把 $1$ 插入在第 $k - 1$ 和第 $k$ 位之间，$k = 0$ 时相当于插在末位）。

但插入一个新数肯定会使新状态的 $k + 1 \sim i - 1$ 位发生变化，显然新状态中下一个 $1$ 的位会归零，但下下个 $1$ 不会归零，因为插入一个新数相当于让 $pre_k$ 加了 $1$，在上一个状态中 $pre_{k} = pre_{k + 1} = pre_{k + 2} = \cdots = pre_{pos - 1} = pre_{pos} - 1$，现在 $pre_k$ 加了 $1$，那么 $pre_k = pre_{pos}$，从而有 $pre_{pos - 1} = pre_{pos}$，所以 $dif_{pos} = 0$，但下下位（记为 $pos'$）依旧有 $pre_{pos'} = pre_{pos} + 1$，所以 $pre_{k} = pre_{pos'} - 1$。

这里采用的是暴力找下一位为 $1$ 的数，效率较劣。

$n$ 达到 $28$ 时，状压完全不能满足时限，这个时候就要打表了。

为了方便，这里只打了 $n \geq 25$ 的表，如果担心效率问题，可以把 $n \geq 20$ 的表打出来，其余的直接用状压 DP。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 27,S = 1 << N;
const int MOD = 998244353;
const int Ans[5] = {102117126,819818153,273498600,267588741};
int n;
int dp[2][S];//状态的最低位为dif[1] 
int lowbit(int x){
	return x & (-x);
}
int popcount(int x){
	int ret = 0;
	while(x){
		ret++;
		x -= lowbit(x);
	}
	return ret;
}
int qpow(int x,int y){
	int ret = 1;
	while(y){
		if(y & 1)
			ret = 1ll * ret * x % MOD;
		x = 1ll * x * x % MOD;
		y >>= 1;
	}
	return ret;
}
void print(int x){
	for(int i = 0;i <= 5;i++)
		cout << ((x & (1 << i)) >> i);
	cout << ' ';
} 
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin >> n;
	if(n >= 25){
		cout << Ans[n - 25];
		return 0; 
	}
	dp[0][0] = 1;
	for(int i = 1,now = 1;i < n;i++,now ^= 1){
		fill(dp[now],dp[now] + (1 << i),0);
		for(int j = 0;j < (1 << (i - 1));j++){
			(dp[now][j << 1] += dp[now ^ 1][j]) %= MOD;
			for(int k = i - 1;k >= 0;k--){
				//cout << i - 1 << ' ' << k << ':';
				//print(j);
				int nex = (j >> k << (k + 1)) | (1 << k) | (j & ((1 << k) - 1));//在第k - 1位和第k位之间插入1 
				//print(nex); 
				for(int pos = k + 1;pos <= i - 1;pos++){//找到k下一位为1的位，将其归0
					//cout << pos << ' ';
					if(nex & (1 << pos)){
						//cout << pos << ' ';
						nex ^= (1 << pos);
						break;
					}
				}
				//print(nex);
				//cout << '\n'; 
				(dp[now][nex] += dp[now ^ 1][j]) %= MOD;
			}	
		}
	}
	long long ans = 0;
	for(int i = 0;i < (1 << (n - 1));i++)
		(ans += 1ll * dp[(n - 1) & 1][i] * (popcount(i) + 1) % MOD) %= MOD;
	for(int i = 1;i <= n;i++)
		(ans *= qpow(i,MOD - 2)) %= MOD;
	cout << ans;
	return 0;
}
```

---

## 作者：xiao7_Mr_10_ (赞：0)

好的如你所见，这道题让我们求长度为 $n$ 的排列的**最长上升子序列**的期望。

考虑排列暴力，显然时间复杂度有点无法接受。

看到 $28$ 的范围自然想到打表，但是怎么快速有效的打标，这就得好好想想了。

考虑状态压缩，每次把每个数从大到小丢进去，以此方便转移，但是就是不知道怎么压缩成二进制。

先考虑一个事情，给你一个序列求其最长上升子序列显然可以 $O(n \log n)$ 随便搞，然后令以 $i$ 为结尾的最长上升子序列的长度为 $f_{i}$，再令 $g_{i}$ 为 $f_{i}$ 的前缀最大值。

所以我们的答案就是 $g_{n}$，然后考虑对 $g$ 进行**差分**，令其差分数组为 $d_{i}$。

因为 $d_{i}$ 显然要么是 $0$ 要么是 $1$，所以可以考虑**压缩** $d$。

初步的，我们设计状态 $f(i,j)$ 为长度为 $i$ 的排列其差分数组为 $j$ 的方案数。然后算出来一乘长度不就皆大欢喜了，而且显然其长度为 $d$ 中 $1$ 的个数。

然后我们考虑往里面丢一个数，因为我们是从小到大插入的，所以目前插入的数 $x$ 一定只能是作为所有上升子序列的末尾，如果插入的位置是 $i$ 和 $i+1$ 之间，那么插入后其 $g$ 值一定是 $g_{i}+1$，所以说我们就把 $d_{i+1}$ 改成　$1$。在 $i$ 之后对于目前转移状态第一个为 $1$ 的位置把它改成 $0$，因为插入了一个 $x$ 的关系，所以它与其值就没有多一的优越了。

然后我们就搞出来了一个时间复杂度为 $O(2^n \times n^2)$ 的装压，非常艺术，绝对过不了。~~我这么写只有八十四分~~。

哈哈哈，岂不闻天无绝人之路，只要我打表，分就手到擒来。即便空间很大，复杂度过不去。但天无绝人之路，发现打表，相信打表，靠打表，这世间没有打不了的表，只有不敢打表的人。当审视打表代码时，就会发现，满分就在其中！~~某三字小说看多了导致的~~。

对了，动态规划部分。

```cpp
		for(int i = 1,now=1;i <= n;i++,now^=1){
			fill(f[now],f[now]+(1<<i),0);
			for(int j = 0;j < (1<<(i-1));j++){
				f[now][j<<1]=(f[now][j<<1]+f[now^1][j])%mod;int id=-1;
				for(int k = i - 1;k >= 0;k--){
					int tlh=((j>>k)<<(k+1))|(1<<k)|(j&((1<<k)-1));
					if(j&(1<<k))id=k;
					if(id!=-1)tlh^=(1<<(id+1));
					f[now][tlh]=(f[now][tlh]+f[now^1][j])%mod;
				}
			}
		} 
```

打表。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans[]={1,499122178,2,915057326,540715694,946945688,422867403,451091574,317868537,200489273,976705134,705376344,662845575,331522185,228644314,262819964,686801362,495111839,947040129,414835038,696340671,749077581,301075008,314644758,102117126,819818153,273498600,267588741};
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	cout << ans[n-1];
	return 0;
}
```

---


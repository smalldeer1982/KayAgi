# [CEOI 2015] 核能国度 (Day2)

## 题目描述

核能国可以看作一个由 $W \times H$ 的方格组成的矩形。核能国有 $N$ 个核电站，每个核电站占用一个方格。不幸的是，核能国遭遇了百年一遇的特大地震，导致所有的核电站都发生了核泄漏。

每个核电站的核泄漏程度可以用两个整数 $a, b$ 来表示。如果位于 $P=[x_P,y_P]$ 的核电站爆炸，方格 $C=[x_C,y_C]$ 会增加 $\mathrm{max}(0,$ $a-b\times d(P,C))$ 贝克的辐射（贝克是单位），其中 $d(P,C)$ 是两个方格的切比雪夫距离，即 $d(P,C) =$ $\mathrm{max}(|x_P - x_C|,$ $|y_P - y_C|)$。  

一个方格可能会受到多处核泄漏的影响。  

例如，如果一个 $a = 7,$ $b = 3$ 的核电站爆炸了，所在的方格 $X$ 会受到 $7$ 贝克辐射（贝克是单位），满足 $d(X,Y) = 1$ 的 $8$ 个方格 $Y$ 会受到 $4$ 贝克辐射，满足 $d(X,Z) = 2$ 的 $16$ 个方格 $Z$ 会受到 $1$ 贝克辐射。

环保部门给了你 $Q$ 组询问，每组询问会划定核能国领土中的一个矩形，请回答：矩形区域内（每个方格）所受的平均辐射量为多少。

## 说明/提示

以下为两次爆炸后对每个方格产生的辐射量：
```plain
7 6 3 2
4 6 5 2
1 3 3 2
```

 - $2^2$ 方形区域内的总辐射为 $14$，所以平均值为 $14\div 4=3.5$，四舍五入至 $4$。

 - 整个核能国的总辐射为 $44$，所以平均值为 $44\div 12 \approx 3.67$，四舍五入至 $4$。

 - 单个格子的平均辐射量就是它所受到的辐射量。

 - 最后一行的平均辐射量为 $9\div 4=2.25$，四舍五入至 $2$。

有 14 组测试数据。奇数的测试组只包含 $a$ 是 $b$ 的倍数的核电站。对每个子任务的进一步限制如下：

|测试组|进一步限制|分数|
|:-:|:-:|:-:|
|$1$|$H=1,N\cdot W \leq 10^8,Q \cdot W \leq 10^8$|$3$|
|$2$|$H=1,N\cdot W \leq 10^8,Q \cdot W \leq 10^8$|$2$|
|$3$|$N\cdot W \cdot H \leq 10^8,Q \cdot W \cdot H \leq 10^8$|$3$|
|$4$|$N\cdot W \cdot H \leq 10^8,Q \cdot W \cdot H \leq 10^8$|$2$|
|$5$|$H=1,N\cdot W \leq 10^8$|$6$|
|$6$|$H=1,N\cdot W \leq 10^8$|$4$|
|$7$|$N\cdot W \cdot H \leq 10^8$|$6$|
|$8$|$N\cdot W \cdot H \leq 10^8$|$4$|
|$9$|$H=1$|$15$|
|$10$|$H=1$|$10$|
|$11$|没有符合**界限**定义的爆炸事件|$15$|
|$12$|没有符合**界限**定义的爆炸事件|$10$|
|$13$|无|$12$|
|$14$|无|$8$|

如果核电站位于核能国的边境或是在离边境稍近的位置，那么爆炸可能也会影响到核能国之外的方格。影响到核能国外方格的爆炸被称作**界限**。

## 样例 #1

### 输入

```
4 3
2
1 1 7 3
3 2 4 2
4
1 2 2 3
1 1 4 3
4 2 4 2
1 3 4 3```

### 输出

```
4
4
2
2```

# 题解

## 作者：Azazеl (赞：4)

#### 核能国度 题解

[好不到哪里去的阅读体验](https://www.cnblogs.com/Azazel/p/14369989.html)

---

#### 题意

> $~~~~$ 给出 $W \times H$ 的矩形，$N$ 个修改，每个修改有位置及参数 $a,b$ ，表示对其周边距离它切比雪夫距离为 $d$ 的格子的权值增加 $\max(0,a-b\times d)$ 。最后 $Q$ 组询问，每次求一个子矩阵的和。

#### 题解

$~~~~$ ~~我不会告诉你我做这道题做了半个月并且实现还借助了题解。（虽然有一周在期末考试。~~

#### Solution 1 暴力

$~~~~$ 每次暴力修改其影响到的格子的权值，每次查询暴力求子矩阵的和，这个不多说。

$~~~~$ 期望得分：？？？

#### Solution 2 二维前缀和

$~~~~$ 暴力修改权值后做一遍二维前缀和，每次查询 $\mathcal{O}(1)$ 回答。

$~~~~$ 期望得分：$\texttt{25pts}$

#### Solution 3 一维差分

$~~~~$ 观察到有 $\texttt{40pts}$ 给在 $H=1$ ，那么此时整个矩形可以被看作是一排数。设某个横坐标为 $x$ 的修改能影响到的最远的距离 $\dfrac{a}{b}=d$  ，那么就相当于给 $[x-d,x]$ 加上一个首项为 $a \bmod b$ ，公差为 $b$ ；给 $[x+1,x+d]$ 加上一个首项为 $a-b$ ，公差为 $-b$ 的等差数列。  

$~~~~$ 此时套路地维护这个数列的差分数列，那么需要支持区间加法，单点修改，且询问在所有修改之后。因此用差分维护差分数列，还原后再用一维前缀和回答即可。

$~~~~$ 期望得分：结合 Solution 2 可得 $\texttt{50pts}$（部分子任务重合）。

#### Solution 3.5 半个正解的二维差分

$~~~~$ 你已经想到用差分维护一维差分数列了，那么我们来随便举个例子看二维的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/794gdjl7.png)

$~~~~$ 这是一个 $a=7,b=2$ 的例子，（没画全，但是这个意思是对的）不难看出在差分后的规律：

$~~~~\bullet$ 左上和右下角为 $a \bmod b$，右上和左下角为 $- a \bmod b$ 。  
$~~~~\bullet$ 除开四角，主对角线全为 $b$ ，副对角线全为 $-b$ 。

$~~~~$ 当然直接根据差分的式子也能得到这个规律，这里为了直观就用找规律了。

$~~~~$ 那么我们暴力 ~~（指 O(1)）~~ 修改四角，然后差分维护对角线即可。

$~~~~$ 时间复杂度：$\mathcal{O}(N+WH+Q)$ 。

$~~~~$ 期望得分：结合 Solution 2 和 Solution 3 可得 $\texttt{75pts}$ 。

$~~~~$ 这里贴一个~~我写了三次才写出来的~~仅能得新增的 $\texttt{25pts}$ 的代码：

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ll long long
using namespace std;
const ll MAXN=2500005;
ll n,m,k,q;
struct Array{ll mp[50000000];inline ll* operator [] (const ll& x){return mp+(x+(n+1)+1)*(3*m+1);}}Pre,Dia1,Dia2;//用指针开数组
int main() {
	scanf("%lld %lld %lld",&n,&m,&k);
	while(k--)
	{
		ll x,y;ll a,b;
		scanf("%lld %lld %lld %lld",&x,&y,&a,&b);
		ll Up=a/b;
		if(x-Up>0) Pre[x-Up][y-Up]+=a%b;Pre[x+Up+1][y+Up+1]+=a%b;
		Pre[x+Up+1][y-Up]-=a%b;Pre[x-Up][y+Up+1]-=a%b;
		
		Dia1[x-Up+1][y-Up+1]+=b;Dia1[x+Up+1][y+Up+1]-=b;
		Dia2[x+Up][y-Up+1]-=b;Dia2[x-Up][y+Up+1]+=b;
	}
	for(ll j=1;j<=m;j++)
	{
		for(ll i=1;i<=n;i++)
		{
			Dia1[i][j]+=Dia1[i-1][j-1],Dia2[i][j]+=Dia2[i+1][j-1];
			Pre[i][j]+=Dia1[i][j]+Dia2[i][j];
			Pre[i][j]+=Pre[i-1][j]+Pre[i][j-1]-Pre[i-1][j-1];
		}
	}
	for(ll j=1;j<=m;j++) for(ll i=1;i<=n;i++) Pre[i][j]+=Pre[i-1][j]+Pre[i][j-1]-Pre[i-1][j-1];
	ll Q;scanf("%lld",&Q);
	while(Q--)
	{
		ll X1,X2,Y1,Y2;
		scanf("%lld %lld %lld %lld",&X1,&Y1,&X2,&Y2);
		ll Siz=(Y2-Y1+1)*(X2-X1+1);
		printf("%lld\n",(ll)((Pre[X2][Y2]-Pre[X1-1][Y2]-Pre[X2][Y1-1]+Pre[X1-1][Y1-1])*1.0/Siz+0.5));
	}
	return 0;
}
```

#### Solution 4 加了亿些细节的二维差分

$~~~~$ 事实上 ，上面算法的时间复杂度是对的，但它并不能得全分。如果你仔细观察题目，你会看到这样一句话：

> $~~~~$ 如果核电站位于核能国的边境或是在离边境稍近的位置，那么爆炸可能也会影响到核能国之外的方格。影响到核能国外方格的爆炸被称作**界限**。

$~~~~$ 而上面 Solution3.5 新增的 $\texttt{25pts}$ 来自**没有界限**的子任务。仔细思考一下，我们会发现如果爆炸影响到的格子在当前矩形的**左、左上或上方**时，差分标记会影响内部的值，但我们统计不到那部分。

$~~~~$ 而且本题我们无法通过扩大若干倍矩形来强行统计那些部分，考虑一个极端情况：$W=H=1$ ，然后在那个格子上有一个 $a=2^{63},b=1$ 的修改。

$~~~~$ **以下涉及大量代码实现，其中** $n$，$m$ **是题面中** $W$ **和** $H$

$~~~~$ 那么我们分别对每一种标记来考虑怎么处理出界的问题：

$~~~~$ 对于四角的修改，我们强行移动它到对应的第一个生效的位置即可，换句话说就是把小于 $1$ 的坐标移动到 $1$ ：

```cpp
void Tag(ll X1,ll Y1,ll X2,ll Y2,ll V)
{
	S[X1][Y1]+=V;S[X2+1][Y1]-=V;
	S[X1][Y2+1]-=V;S[X2+1][Y2+1]+=V;
}
Tag(max(x-Up,1ll),max(y-Up,1ll),min(x+Up,n),min(y+Up,m),a%b-b);//调用，注意后面即使对答案不影响也不能不取min，否则会RE。
// 最后对于四角-b，则整个对角线都+b即可
```

$~~~~$ 对于主对角线的修改，我们将其超出部分的**和**全部移动到第一行或第一列对应的位置，这个需要分类讨论几种情况。

$~~~~$ 先写一个给第一行/列打标记的函数：

```cpp\
ll A[MAXN],B[MAXN];//记超出部分给 第一行 和 第一列 打的标记 
void Sign(ll *Arr,ll l,ll r,ll v) {Arr[l]+=v,Arr[r+1]-=v;} //一阶差分，对 [l,r] +v ，记在第一行或第一列 
```

$~~~~$ 然后对超出的左上角部分进行处理：

```cpp
void TagLU(ll X1,ll Y1,ll X2,ll Y2,ll V)//[X1,Y1]：起始 [X2,Y2]：最后一个超出的格子
{
	if(X1>X2)return;
	if(X2<=0&&Y2<=0) Sign(A,1,1,(X2-X1+1)*V); // Area 1：全部在左上 
	else if(X2<=0)//Area 2：左
	{
		if(Y1<=0) Sign(B,1,Y2,V),Sign(B,1,1,(1-Y1)*V);//有一部分在左上
		else Sign(B,Y1,Y2,V);//全在左
	}
	else if(Y2<=0)//Area 3：上
	{
		if(X1<=0) Sign(A,1,X2,V),Sign(A,1,1,(1-X1)*V);//有一部分在左上
		else Sign(A,X1,X2,V);//全在上
	}
}
TagLU(X-Up,Y-Up,X-min(min(X-1,Y-1),Up)-1,Y-min(min(X-1,Y-1),Up)-1,b);
```

$~~~~$ 以及打起始和结束的标记：

```cpp
Dia1[X-min(min(X-1,Y-1),Up)][Y-min(min(X-1,Y-1),Up)]+=b;
Dia1[X+1+min(Up,min(n-X-1,m-Y))+1][Y+1+min(Up,min(n-X,m-Y-1))+1]-=b;
```

$~~~~$ 然后是副对角线，大体同上，但注意左右都可能有超出。

```cpp
void TagRU(ll Y1,ll Y2,ll V){if(Y1>=Y2&&Y2<=m) Sign(B,Y2,min(Y1,m),-V);}
void TagLD(ll X1,ll X2,ll V){if(X1<=X2&&X1<=n) Sign(A,X1,min(X2,n),-V);}
void Tag(ll X,ll Y,ll a,ll b)
{
	ll Up=a/b;
	TagRU(Y+1+Up,Y+1+min(Up,min(X-1,m-Y-1))+1,b);
	TagLD(X+1+min(Up,min(n-X-1,Y-1))+1,X+1+Up,b);
	Dia2[X-min(Up,min(X-1,m-Y-1))][Y+1+min(Up,min(X-1,m-Y-1))]-=b;
	Dia2[X+1+min(Up,min(n-X-1,Y-1))+1][Y-min(Up,min(n-X-1,Y-1))-1]+=b;
}
```

$~~~~$ 最后把对角线的差分标记还原，把第一行和第一列归到一起

```cpp
for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) Dia1[i][j]+=Dia1[i-1][j-1],Dia2[i][j]+=Dia2[i-1][j+1];
for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) Dia1[i][j]+=Dia2[i][j];
for(int i=1;i<=n;i++) Dia1[i][1]+=(A[i]+=A[i-1]);
for(int i=1;i<=m;i++) Dia1[1][i]+=(B[i]+=B[i-1]);
```

$~~~~$ 然后就和上面没有任何区别了。~~轻松而又愉快。~~

$~~~~$ 时间复杂度：同 Solution3.5

$~~~~$ 期望得分：$\texttt{100pts}$ 。

$~~~~$ 完整代码就不贴了，整体很丑。



---

## 作者：jacky567 (赞：4)

# 暴力算法1
最暴力的算法你能想到什么？枚举！

对于每个核电站爆炸事件，枚举它周围的方格受到的影响

直接枚举整个国度显得太暴力了，我们能不能稍稍优化一下呢？

显然是可以的

我们发现，每个核电站爆炸事件有一个“势力范围”

只有在这个方格和核电站的切比雪夫距离$\leqslant\frac{a}{b}$时，它才会受影响

所以，我们只需要枚举这个核电站的势力范围就可以了
```cpp
//官方程序
#include <stdio.h>
#include <stdlib.h>

#define MAXWH 10000000
#define MAXN 1000000
#define MAXQ 1000000

typedef long long int huge;

int w, h, n, q;

typedef struct NUCLEARIA
{
	huge Info[MAXWH];
	huge& operator () (int x, int y) {return Info[(y * w) + x];}//其实就是个二维数组
}
NUCLEARIA;

typedef struct PLANT
{
	int x;
	int y;
	int a;
	int b;
}
PLANT;

typedef struct QUERY
{
	int x1;
	int y1;
	int x2;
	int y2;
}
QUERY;

NUCLEARIA Nuclearia;
PLANT Plant[MAXN];
QUERY Query[MAXQ];

int min(int a, int b)
{
	return (a < b) ? a : b;
}

int max(int a, int b)
{
	return (a > b) ? a : b;
}

int abs(int a)
{
	return (a < 0) ? -a : a;
}

int dist(int x1, int y1, int x2, int y2)
{
	return max(abs(x1 - x2), abs(y1 - y2));
}

void Print(huge sum, int area)//四舍五入
{
	huge rsl = sum / area;
	if((sum % area) * 2 >= area)
	{
		rsl++;
	}
	
	printf("%lld\n", rsl);
}

int main()
{
	scanf("%d%d", &w, &h);
	
	scanf("%d", &n);
	for(int i = 0; i < n; i++)
	{
		scanf("%d%d%d%d", &(Plant[i].x), &(Plant[i].y), &(Plant[i].a), &(Plant[i].b));
		Plant[i].x--;
		Plant[i].y--;
	}
	
	scanf("%d", &q);
	for(int i = 0; i < q; i++)
	{
		scanf("%d%d%d%d", &(Query[i].x1), &(Query[i].y1), &(Query[i].x2), &(Query[i].y2));
		Query[i].x1--;
		Query[i].y1--;
	}
	
	for(int i = 0; i < n; i++)
	{
		PLANT& P = Plant[i];
		int d = (P.a - 1) / P.b;
		int x1 = max(0, P.x - d);
		int y1 = max(0, P.y - d);
		int x2 = min(w, P.x + d + 1);
		int y2 = min(h, P.y + d + 1);
		//势力范围
		for(int x = x1; x < x2; x++)
		{
			for(int y = y1; y < y2; y++)
			{
				int d = dist(x, y, P.x, P.y);
				Nuclearia(x, y) += P.a - (d * P.b);
			}
		}
	}
	
	for(int i = 0; i < q; i++)
	{
		QUERY& Q = Query[i];
		huge rsl = 0;
		
		for(int x = Q.x1; x < Q.x2; x++)
		{
			for(int y = Q.y1; y < Q.y2; y++)
			{
				rsl += Nuclearia(x, y);
			}
		}
		
		Print(rsl, (Q.x2 - Q.x1) * (Q.y2 - Q.y1));
	}
	
	return 0;
}
```
# 暴力算法2
我们发现上面的算法在询问次数很多时是很耗时间的，因为每次我们都需要把矩形的辐射量加一遍

所以，我们可以在询问前先预处理一下

大家应该知道[激光炸弹](https://www.luogu.com.cn/problem/P2280)吧？我们可以借用一下这种矩阵的预处理方法，就是计算出左上角在$[1,1]$且它的右下角在$[x,y]$的矩形的总辐射，假设是$Nuclearia(x,y)$

最终的答案就是$Nuclearia(x_{2j},y_{2j})-Nuclearia(x_{1j}-1,y_{2j})-Nuclearia(x_{2j},y_{1j}-1)+Nuclearia(x_{1j}-1,y_{1j}-1)$
```cpp
//官方程序
#include <stdio.h>
#include <stdlib.h>

#define MAXWH 10000000
#define MAXN 1000000
#define MAXQ 1000000

typedef long long int huge;

int w, h, n, q;

typedef struct NUCLEARIA
{
	huge Info[MAXWH];
	huge& operator () (int x, int y) {return Info[(y * w) + x];}//其实就是个二维数组
}
NUCLEARIA;

typedef struct PLANT
{
	int x;
	int y;
	int a;
	int b;
}
PLANT;

typedef struct QUERY
{
	int x1;
	int y1;
	int x2;
	int y2;
}
QUERY;

NUCLEARIA Nuclearia;
PLANT Plant[MAXN];
QUERY Query[MAXQ];

int min(int a, int b)
{
	return (a < b) ? a : b;
}

int max(int a, int b)
{
	return (a > b) ? a : b;
}

int abs(int a)
{
	return (a < 0) ? -a : a;
}

int dist(int x1, int y1, int x2, int y2)
{
	return max(abs(x1 - x2), abs(y1 - y2));
}

void Summarize()//预处理
{
	for(int x = 0; x < w; x++)
	{
		for(int y = 0; y < h; y++)
		{
			if(x) Nuclearia(x, y) += Nuclearia(x - 1, y);
			if(y) Nuclearia(x, y) += Nuclearia(x, y - 1);
			if((x) && (y)) Nuclearia(x, y) -= Nuclearia(x - 1, y - 1);
		}
	}
}

void Print(huge sum, int area)//四舍五入
{
	huge rsl = sum / area;
	if((sum % area) * 2 >= area)
	{
		rsl++;
	}
	
	printf("%lld\n", rsl);
}

int main()
{
	scanf("%d%d", &w, &h);
	
	scanf("%d", &n);
	for(int i = 0; i < n; i++)
	{
		scanf("%d%d%d%d", &(Plant[i].x), &(Plant[i].y), &(Plant[i].a), &(Plant[i].b));
		Plant[i].x--;
		Plant[i].y--;
	}
	
	scanf("%d", &q);
	for(int i = 0; i < q; i++)
	{
		scanf("%d%d%d%d", &(Query[i].x1), &(Query[i].y1), &(Query[i].x2), &(Query[i].y2));
		Query[i].x1 -= 2;
		Query[i].y1 -= 2;
		Query[i].x2--;
		Query[i].y2--;
	}
	
	for(int i = 0; i < n; i++)
	{
		PLANT& P = Plant[i];
		int d = (P.a - 1) / P.b;
		int x1 = max(0, P.x - d);
		int y1 = max(0, P.y - d);
		int x2 = min(w, P.x + d + 1);
		int y2 = min(h, P.y + d + 1);
		//势力范围
		for(int x = x1; x < x2; x++)
		{
			for(int y = y1; y < y2; y++)
			{
				int d = dist(x, y, P.x, P.y);
				Nuclearia(x, y) += P.a - (d * P.b);
			}
		}
	}
	
	Summarize();
	
	for(int i = 0; i < q; i++)
	{
		QUERY& Q = Query[i];
		huge rsl = Nuclearia(Q.x2, Q.y2);
		if(Q.x1 >= 0) rsl -= Nuclearia(Q.x1, Q.y2);
		if(Q.y1 >= 0) rsl -= Nuclearia(Q.x2, Q.y1);
		if((Q.x1 >= 0) && (Q.y1 >= 0)) rsl += Nuclearia(Q.x1, Q.y1);
		
		Print(rsl, (Q.x2 - Q.x1) * (Q.y2 - Q.y1));
	}
	
	return 0;
}
```
# 正解
接着，我们尝试在进一步的优化

回想一下我们在利用树状数组做区间修改时的方法：把区间的前面标记为$+a$，最后面标记为$-a$，这样，就可以进行区间修改了

我们可以借用一下这个思路，来标记一次核电站爆炸事件

首先，我们先找出这个核电站爆炸事件的“势力范围”，接着，把“势力范围”的左上角和右下角标记为$+a\% b$，把左下角和右上角标记为$-a\% b$

然后，我们开两个数组，在这个“势力范围”的对角线上（两条对角线，所以要两个数组）存储$b$的值，为了节省时间，我们可以只在4个角上标记，最后再把对角线上的数全部加出来

因为每个核电站爆炸事件的影响相等方格的，都会围成一个正方形（因为取的是切比雪夫距离），也就是说，我们在统计时，只需要先把对角线上的数复制到$Nuclearia$数组中，再把左边的和上面的数相加再减去左上的数就可以了

看起来有点抽象，我们可以再总结一下：
1. 对于每个核电站爆炸事件，计算出它的“势力范围”，左上角为$(x1,y1)$，右下角为$(x2,y2)$
2. 标记：$Nuclearia(x1,y1) = Nuclearia(x2,y2) = a\% b$，$Nuclearia(x1,y2) = Nuclearia(x2,y1) = a\% b$
3. 修改两条对角线上的值（两条对角线的数组分别为$PosDiag$（主对角线）和$NegDiag$（次对角线））：$PosDiag(x1+1,y1+1)=b,PosDiag(x2,y2)=-b,NegDiag(x1+1,y2-1)=-b,NegDiag(x2,y1)=b$
4. 枚举整个国度的$PosDiag$和$NegDiag$，$PosDiag(x,y)+=PosDiag(x-1,y-1),NegDiag(x,y)+=NegDiag(x-1,y+1)$
5. 枚举整个国度的$Nuclearia$，$Nuclearia(x,y)+=PosDiag(x,y)+NegDiag(x,y)$
6. 重复两次：枚举整个国度的$Nuclearia$，$Nuclearia(x,y)+=Nuclearia(x-1,y)+Nuclearia(x,y-1)-Nuclearia(x-1,y-1)$

这就是整个过程了，最后的答案计算方法和上面一样

你以为这就完了吗？

**不！没完！**

注意题目的最后一句话：`如果核电站位于核能国的边境或是在离边境稍近的位置，那么爆炸可能也会影响到核能国之外的方格。影响到核能国外方格的爆炸被称作界限`

也就是说$x1$和$y1$有可能$\leqslant 0$，$x2$也有可能$>W$，$y2$也有可能$>H$！

对于这个的处理，我们需要再开两个数组$Col$和$Row$，存储超出边界的部分，具体的实现就看程序吧，这些细节的处理，这里就不再细讲了
```cpp
//官方程序
#include <stdio.h>
#include <stdlib.h>

#define MAXWH 10000000
#define MAXN 1000000
#define MAXQ 1000000

typedef long long int huge;

int w, h, n, q;

typedef struct NUCLEARIA
{
	huge Info[MAXWH];
	huge& operator () (int x, int y) {return Info[(y * w) + x];}
}
NUCLEARIA;

typedef struct PLANT
{
	int x;
	int y;
	int a;
	int b;
}
PLANT;

typedef struct QUERY
{
	int x1;
	int y1;
	int x2;
	int y2;
}
QUERY;

NUCLEARIA Nuclearia, PosDiag, NegDiag;
PLANT Plant[MAXN];
QUERY Query[MAXQ];
huge Row[MAXWH];
huge Col[MAXWH];

int max(int a, int b)
{
	return (a > b) ? a : b;
}

void UpdatePosDiag(int x1, int y1, int x2, int y2, int b)
{
	if((x1 < 0) && (y1 < 0))
	{
		int m = -max(x1, y1);
		Nuclearia(0, 0) += m * b;
		x1 += m;
		y1 += m;
	}
	
	if(x1 < 0)
	{
		int m = -x1;
		Col[y1] += b;
		Col[y1 + m] -= b;
		x1 += m;
		y1 += m;
	}
	
	if(y1 < 0)
	{
		int m = -y1;
		Row[x1] += b;
		Row[x1 + m] -= b;
		x1 += m;
		y1 += m;
	}
	
	PosDiag(x1, y1) += b;
	
	if((x2 + 1 < w) && (y2 + 1 < h)) PosDiag(x2 + 1, y2 + 1) -= b;
}

void UpdateNegDiag(int x1, int y1, int x2, int y2, int b)
{
	if(y2 > h - 1)
	{
		int m = y2 - (h - 1);
		x1 += m;
		y2 -= m;
	}
	
	if(x1 < 0)
	{
		int m = -x1;
		Col[(y2 - m) + 1] -= b;
		if(y2 + 1 < h) Col[y2 + 1] += b;
		x1 += m;
		y2 -= m;
	}
	
	if((x1 < w) && (y2 >= 0)) NegDiag(x1, y2) -= b;
	
	if(x2 > w - 1)
	{
		int m = x2 - (w - 1);
		x2 -= m;
		y1 += m;
	}
	
	if(y1 < 0)
	{
		int m = -y1;
		Row[(x2 - m) + 1] -= b;
		if(x2 + 1 < w) Row[x2 + 1] += b;
		x2 -= m;
		y1 += m;
	}
	
	if((x2 + 1 >= 0) && (x2 + 1 < w) && (y1 - 1 >= 0) && (y1 - 1 < h)) NegDiag(x2 + 1, y1 - 1) += b;
}

void SummarizeDiags()
{
	for(int x = 0; x < w; x++)
	{
		for(int y = 0; y < h; y++)
		{
			if((x) && (y)) PosDiag(x, y) += PosDiag(x - 1, y - 1);
			if((x) && (y != h - 1)) NegDiag(x, y) += NegDiag(x - 1, y + 1);
		}
	}
}

void AddDiags()
{
	for(int x = 0; x < w; x++)
	{
		for(int y = 0; y < h; y++)
		{
			Nuclearia(x, y) += PosDiag(x, y);
			Nuclearia(x, y) += NegDiag(x, y);
		}
	}
}

void SummarizeLines()
{
	for(int x = 1; x < w; x++)
	{
		Row[x] += Row[x - 1];
	}
	
	for(int y = 1; y < h; y++)
	{
		Col[y] += Col[y - 1];
	}
}

void AddLines()
{
	for(int x = 0; x < w; x++)
	{
		Nuclearia(x, 0) += Row[x];
	}
	
	for(int y = 0; y < h; y++)
	{
		Nuclearia(0, y) += Col[y];
	}
}

void Summarize()
{
	for(int x = 0; x < w; x++)
	{
		for(int y = 0; y < h; y++)
		{
			if(x) Nuclearia(x, y) += Nuclearia(x - 1, y);
			if(y) Nuclearia(x, y) += Nuclearia(x, y - 1);
			if((x) && (y)) Nuclearia(x, y) -= Nuclearia(x - 1, y - 1);
		}
	}
}

void Print(huge sum, int area)
{
	huge rsl = sum / area;
	if((sum % area) * 2 >= area)
	{
		rsl++;
	}
	
	printf("%lld\n", rsl);
}

int main()
{
	scanf("%d%d", &w, &h);
	
	scanf("%d", &n);
	for(int i = 0; i < n; i++)
	{
		scanf("%d%d%d%d", &(Plant[i].x), &(Plant[i].y), &(Plant[i].a), &(Plant[i].b));
		Plant[i].x--;
		Plant[i].y--;
	}
	
	scanf("%d", &q);
	for(int i = 0; i < q; i++)
	{
		scanf("%d%d%d%d", &(Query[i].x1), &(Query[i].y1), &(Query[i].x2), &(Query[i].y2));
		Query[i].x1 -= 2;
		Query[i].y1 -= 2;
		Query[i].x2--;
		Query[i].y2--;
	}
	
	for(int i = 0; i < n; i++)
	{
		PLANT& P = Plant[i];
		int d = (P.a - 1) / P.b;
		int x1 = P.x - d;
		int y1 = P.y - d;
		int x2 = P.x + d + 1;
		int y2 = P.y + d + 1;
		int r = P.a % P.b;
		
		if(r)
		{
			Nuclearia(max(0, x1), max(0, y1)) += r;
			if(x2 < w) Nuclearia(x2, max(0, y1)) -= r;
			if(y2 < h) Nuclearia(max(0, x1), y2) -= r;
			if((x2 < w) && (y2 < h)) Nuclearia(x2, y2) += r;
			
			x1++;
			y1++;
			x2--;
			y2--;
		}
		
		if(P.a >= P.b)
		{
			UpdatePosDiag(x1, y1, x2, y2, P.b);
			UpdateNegDiag(x1, y1, x2, y2, P.b);
		}
	}
	
	SummarizeDiags();
	AddDiags();
	SummarizeLines();
	AddLines();
	Summarize();
	Summarize();
	
	for(int i = 0; i < q; i++)
	{
		QUERY& Q = Query[i];
		huge rsl = Nuclearia(Q.x2, Q.y2);
		if(Q.x1 >= 0) rsl -= Nuclearia(Q.x1, Q.y2);
		if(Q.y1 >= 0) rsl -= Nuclearia(Q.x2, Q.y1);
		if((Q.x1 >= 0) && (Q.y1 >= 0)) rsl += Nuclearia(Q.x1, Q.y1);
		
		Print(rsl, (Q.x2 - Q.x1) * (Q.y2 - Q.y1));
	}
	
	return 0;
}
```

---

## 作者：SDNetFriend (赞：3)

这个题用的是切比雪夫距离，我们知道在格点图上，到一个点切比雪夫距离相等的点形成了一个矩形的环。

看数据范围，$W\times H\leq 2.5\times 10^6$ 意味着我们可以开一个二维数组保存下每一个格子的答案。

刚开始可能会想扫描线，但是这样还是比较麻烦，我们换一种思路，尝试预先求出每个点的辐射量然后直接二维前缀和 $O(1)$ 回答每个询问。。

我们都知道二维平面上的矩形加用差分怎么做，但这个题不止是一个矩形加，对于一个核电站的贡献，可以被描述成 $O(W)$ 个矩形加，大概长成这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/mj31osl5.png)

如图，是一个对应输入为 `2 2 7 3` 的矩形。我们以左右方向为 $x$ 轴，上下为 $y$ 轴且左下角为原点。

考虑我们怎么来计算这个东西？我们不妨尝试画出一个更简单的例子的差分数组，对应着核电站 `3 3 6 2`：

![](https://cdn.luogu.com.cn/upload/image_hosting/na7ux2c8.png)

左侧是差分数组，右侧是最终每个点的辐射值。

我们发现，差分数组可以被描述成两条斜线，一条方向与主对角线相同，另一条方向与主对角线垂直。

那我们考虑，做一个差分数组的差分，存成两个数组，一个数组差分方向是左下到右上，另一个数组差分方向是右下到左上，最后对这两个数组做前缀和我们就得到了差分数组。然后再次前缀和就能得到每个位置的辐射值，再次前缀和就可以直接二位前缀和回答询问了。

做到这里我们只能获得 $25$ 分。因为一件非常麻烦的事情：我们要处理那些辐射范围超出边界的贡献，但这里还是太麻烦了，就先用图示表示一下需要特判的情况，这里用红线代表假设没有边界差分数组值的位置，绿线表示最终差分数组值的位置。

![](https://cdn.luogu.com.cn/upload/image_hosting/sf09i9ep.png)

每一个黄框是一种要特判的情况。黑框就是 $W,H$ 限定出来的范围。注意左侧范围左下角有个绿团，这个意思是在范围左下角区域内所有要加的差分数组贡献都会被加到左下角这个点上，也是特判一下就好。

对于这个横着的和竖着的贡献同样是再开一个差分数组进行矩形加就可以了。

最后三个差分数组的差分数组分别做对应方向的前缀和加起来就能得到差分数组了。

如果觉得不太好想可以想象一下差分数组每个点的贡献区间都是以这个点为左下角，向右向上无限延伸的一个矩形，然后就可以判断哪些有贡献哪些没有贡献以及具体该贡献在什么位置了。

#### 代码

```cpp
#include <bits/stdc++.h>
#define lint long long
using namespace std;
inline int read(){
	char c;int f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const int W=3e6+5,N=2e5+5;
int w,h,n,q;bool flg;
vector<lint> s[W];
vector<int> d0[W],d1[W],dd[W];
inline void adds(int x,int y,lint v){
	x=max(1,x);y=max(1,y);
	if(x<=w&&y<=h)s[x][y]+=v;
}
inline void ux(int l,int r,int y,lint v){
	if(l>r)return;
	dd[l][y]+=v;
	if(r<w)dd[r+1][y]-=v;
	if(y<h)dd[l][y+1]-=v;
	if(r<w&&y<h)dd[r+1][y+1]+=v;
}
inline void uy(int l,int r,int x,lint v){
	if(l>r)return;
	dd[x][l]+=v;
	if(x<w)dd[x+1][l]-=v;
	if(r<h)dd[x][r+1]-=v;
	if(x<w&&r<h)dd[x+1][r+1]+=v;
}
inline void add0(int x,int y,lint v){
	if(x>w||y>h)return;
	if(x>=1&&y>=1)
		{d0[x][y]+=v;return;}
	int d=max(1-x,1-y),nx=x+d,ny=y+d;
	d0[nx][ny]+=v;
	if(nx==1){
		uy(max(1,y),ny-1,1,v);
		if(y<1)s[1][1]+=(1-y)*v;
	}else{
		ux(max(1,x),nx-1,1,v);
		if(x<1)s[1][1]+=(1-x)*v;
	}
}
inline void add1(int x,int y,lint v){
	if(x-w>h-y||y>h)return;
	if(1<=x&&x<=w&&1<=y&&y<=h){
		d1[x][y]+=v;
		int d=min(x-1,h-y),nx=x-d,ny=y+d;
		if(nx==1)uy(ny+1,h,1,v);
		return;
	}int d=max(x-w,1-y),nx=x-d,ny=y+d;
	if(d<0){
		if(x<1&&y<=h)
			uy(y,h,1,v);
	}else{
		d1[nx][ny]+=v;
		if(ny==1)ux(nx+1,min(w,x),1,v);
		d=min(nx-1,h-ny);
		int nx2=nx-d,ny2=ny+d;
		if(nx2==1)uy(ny2+1,h,1,v);
	}
}
inline void calc(){
	int x=read(),y=read();
	if(flg)swap(x,y);
	lint a=read(),b=read();
	int d=a/b-1;
	adds(x-d-1,y-d-1,a%b);
	adds(x+d+2,y+d+2,a%b);
	adds(x-d-1,y+d+2,-a%b);
	adds(x+d+2,y-d-1,-a%b);
	add0(x-d,y-d,b);
	add0(x+d+2,y+d+2,-b);
	add1(x+d+1,y-d,-b);
	add1(x-d-1,y+d+2,b);
}
inline void build(){
	for(int i=1;i<=w;++i)
		for(int j=1;j<=h;++j){
			d0[i][j]+=d0[i-1][j-1];
			dd[i][j]+=dd[i][j-1]+dd[i-1][j];
			dd[i][j]-=dd[i-1][j-1];
		}
	for(int i=w-1;i>=1;--i)
		for(int j=1;j<=h;++j)
			d1[i][j]+=d1[i+1][j-1];
	for(int i=1;i<=w;++i)
		for(int j=1;j<=h;++j){
			s[i][j]+=dd[i][j]+d0[i][j]+d1[i][j];
			s[i][j]+=s[i][j-1]+s[i-1][j]-s[i-1][j-1];
		}
	for(int i=1;i<=w;++i)
		for(int j=1;j<=h;++j){
			s[i][j]+=s[i][j-1]+s[i-1][j];
			s[i][j]-=s[i-1][j-1];
		}
}
inline lint query(int x0,int y0,int x1,int y1){
	--x0;--y0;
	return s[x1][y1]-s[x1][y0]-s[x0][y1]+s[x0][y0];
}
int main(){
	w=read();h=read();
	if(w>h)swap(w,h),flg=true;
	for(int i=0;i<=w;++i){
		s[i].resize(h+1);dd[i].resize(h+1);
		d0[i].resize(h+1);d1[i].resize(h+1);
	}n=read();
	for(int i=1;i<=n;++i)calc();
	build();q=read();
	while(q--){
		int x0=read(),y0=read();
		int x1=read(),y1=read();
		if(flg)swap(x0,y0),swap(x1,y1);
		lint t=(x1-x0+1)*(y1-y0+1);
		lint res=query(x0,y0,x1,y1),ans=res/t;
		if(res%t*2>=t)++ans;
		printf("%lld\n",ans);
	}return 0;
}
```



---

## 作者：Composite_Function (赞：1)

做了 2h，太菜了。调试了依托。

这题数据水 $n\sqrt{HW}$ 也能跑。我呃呃。

---

看到这类问题首先联想到差分。那么考虑怎么作题目中的修改操作。可以将原题中的修改操作这样拆成若干个矩阵加：

![](https://cdn.luogu.com.cn/upload/image_hosting/hpxnofv6.png)

~~画的有点丑见谅。~~

最外面的加和里面的肯定不相关，所以我们直接做掉最外面的加法操作，考虑内部在差分数组上的修改（用红色标出）：

![](https://cdn.luogu.com.cn/upload/image_hosting/xpoqeucm.png)

所以其本质上是在差分数组上选了两条斜线加 / 减修改。这一点我们拆开来对差分数组再使用差分数组即可。

但是还没做完，因为可能这样的矩阵会超出原矩阵的范围。所以要作一些平移操作。

具体细节看代码吧。

---

鲜花：随手一发最优解。

```cpp
const int N = 5e6 + 10;
int n, m, k, q;
ll dd[N], dd_[N], ddr[N], ddc[N], s[N];

inline int id(int x, int y) {
	return x * (m + 1) + y;
}

inline void modify1(int lx, int ly, int rx, int ry, int dif) {
	int tmp = 0;
	if (lx < 1 || ly < 1) {
		tmp = max(1 - lx, 1 - ly);
		if (lx <= ly) {
			int l = max(ly, 1ll);
			ddr[id(1, l)] += dif, ddr[id(1, ly + tmp)] -= dif;
			s[id(1, 1)] += 1ll * dif * (l - ly);
		} else {
			int l = max(lx, 1ll);
			ddc[id(l, 1)] += dif, ddc[id(lx + tmp, 1)] -= dif;
			s[id(1, 1)] += 1ll * dif * (l - lx);
		}
	}
	if (lx + tmp <= n && ly + tmp <= m) dd[id(lx + tmp, ly + tmp)] += dif;
	if (rx < n && ry < m) dd[id(rx + 1, ry + 1)] -= dif;
}
inline void modify2(int lx, int ly, int rx, int ry, int dif) {
	if (lx < 1) {
		int tmp = 1 - lx, l = lx + ly;
		if (l <= m) ddr[id(1, l)] += dif;
		if (ly + 1 <= m) ddr[id(1, ly + 1)] -= dif;
		lx += tmp, ly -= tmp;
	}
	int tmp = max(0ll, ly - m);
	lx += tmp, ly -= tmp;
	if (ry < 1) {
		int tmp = 1 - ry, l = rx + ry;
		if (l <= n) ddc[id(l, 1)] += dif;
		if (rx + 1 <= n) ddc[id(rx + 1, 1)] -= dif;
		rx -= tmp, ry += tmp;
	}
	tmp = max(0ll, rx - n);
	rx -= tmp, ry += tmp;
	dd_[id(lx, ly)] += dif;
	if (rx < n && ry > 1) dd_[id(rx + 1, ry - 1)] -= dif;
}
inline void modify(int x, int y, int dif) {
	if (x <= n && y <= m) s[id(max(x, 1ll), max(y, 1ll))] += dif;
}
signed main() {
	rin >> n >> m >> k;
	for (int i = 1, x, y, a, b; i <= k; ++i) {
		rin >> x >> y >> a >> b;
		int len = a / b, rem = a % b;
		if (len) {
			modify1(x - len + 1, y - len + 1, x + len, y + len, b);
			if (x != n || y != m) modify2(x - len + 1, y + len, x + len, y - len + 1, -b);
		}
		modify(x - len, y - len, rem);
		modify(x - len, y + len + 1, -rem);
		modify(x + len + 1, y - len, -rem);
		modify(x + len + 1, y + len + 1, rem);
	}
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j) {
			dd[id(i, j)] += dd[id(i - 1, j - 1)];
			ddr[id(i, j)] += ddr[id(i, j - 1)];
			ddc[id(i, j)] += ddc[id(i - 1, j)];
		}
	for (int i = 2; i <= n; ++i)
		for (int j = 1; j < m; ++j)
			dd_[id(i, j)] += dd_[id(i - 1, j + 1)];
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			s[id(i, j)] += dd[id(i, j)] + ddr[id(i, j)] + ddc[id(i, j)] + dd_[id(i, j)];
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			s[id(i, j)] += s[id(i - 1, j)] + s[id(i, j - 1)] - s[id(i - 1, j - 1)];
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			s[id(i, j)] += s[id(i - 1, j)] + s[id(i, j - 1)] - s[id(i - 1, j - 1)];
	rin >> q;
	for (int i = 1, x1, y1, x2, y2; i <= q; ++i) {
		rin >> x1 >> y1 >> x2 >> y2;
		ll ans = (s[id(x2, y2)] - s[id(x1 - 1, y2)] - s[id(x2, y1 - 1)] + s[id(x1 - 1, y1 - 1)]), sz = (x2 - x1 + 1) * (y2 - y1 + 1);
		if (((ans % sz) << 1) >= sz) cout << ans / sz + 1 << endl;
		else cout << ans / sz << endl;
	}
	return 0;
}
```

---

## 作者：Leasier (赞：1)

设 $r = \min(\lfloor \frac{a}{b} \rfloor, \max(x, w - x + 1, y, w - y + 1))$，则我们可以将一次操作描述为：

- 将以 $(x, y)$ 为中心的边长为 $2r + 1$ 的正方形加上 $a - br$。
- $\forall 0 \leq i < r$，将以 $(x, y)$ 为中心的边长为 $2i + 1$ 的正方形加上 $b$。

直接二维差分暴力实现是 $O(wh + n \max(w, h) + q)$ 的，显然不能通过。

注意到当 $w, h$ 较小的一侧扩展完之后就变成了一个一维的区间加一次函数问题，于是讨论一下 $w, h$ 大小关系即可做到 $O(wh + n \min(w, h) + q)$。~~但 NKOJ 上过不去 /fn~~

注意到如果我们将地图进行一些扩展后，暴力部分就变成了对二维差分数组的斜线加，于是再差分维护两种斜线即可。时间复杂度为 $O(wh + n + q)$。

细节稍多，如果像我一样实现得不精细可能还需要卡空间，可以参考一下代码。

代码：
```cpp
#include <stdio.h>
#include <string.h>

namespace Fread {
	const int BUFFER_SIZE = 1 << 25;
	char buffer[BUFFER_SIZE + 7];
	char *pstart = buffer, *pend = buffer;
	
	inline char getchar(){
		if (pstart < pend) return *pstart++;
		pstart = buffer;
		pend = buffer + fread(buffer, 1, BUFFER_SIZE, stdin);
		return pstart == pend ? EOF : *pstart++;
	}
	
	inline int read(){
		int ans = 0;
		char ch = getchar();
		while (ch < '0' || ch > '9'){
			ch = getchar();
		}
		while (ch >= '0' && ch <= '9'){
			ans = ans * 10 + (ch ^ 48);
			ch = getchar();
		}
		return ans;
	}
}

typedef long long ll;

int w, h, w2, h2, w_, h_;
ll sumk[2500007], sumb[2500007], sum_val[2500007];
ll *sum1[5000007], *sum2[5000007], *sum3[5000007], *sum4[5000007], *sum5[5000007];

inline int min(int a, int b){
	return a < b ? a : b;
}

inline void init(){
	for (register int i = 0; i <= w2 + 1; i++){
		sum1[i] = new ll[h2 + 2];
		memset(sum1[i], 0, sizeof(ll) * (h2 + 2));
	}
	for (register int i = 1; i <= h_; i++){
		int size = min(h_ - i + 1, w_ + 1) + 1;
		sum2[i] = new ll[size];
		memset(sum2[i], 0, sizeof(ll) * size);
	}
	for (register int i = 1; i <= w_; i++){
		int size = min(w_ - i + 1, h_ + 1) + 1;
		sum3[i] = new ll[size];
		memset(sum3[i], 0, sizeof(ll) * size);
	}
	for (register int i = 1; i <= w_; i++){
		int size = min(i, h_ + 1) + 1;
		sum4[i] = new ll[size];
		memset(sum4[i], 0, sizeof(ll) * size);
	}
	for (register int i = 1; i <= h_; i++){
		sum5[i] = new ll[w_ + 2];
		memset(sum5[i], 0, sizeof(ll) * (w_ + 2));
	}
}

inline int max(int a, int b){
	return a > b ? a : b;
}

inline void add1(int l1, int l2, int r1, int r2, int k){
	l1 = max(l1 + w, 1);
	l2 = max(l2 + h, 1);
	r1 = min(r1, w) + w;
	r2 = min(r2, h) + h;
	sum1[l1][l2] += k;
	sum1[l1][r2 + 1] -= k;
	sum1[r1 + 1][l2] -= k;
	sum1[r1 + 1][r2 + 1] += k;
}

inline void add2(int x, int y, int r, int k){
	x += w;
	y += h;
	if (x <= y){
		sum2[y - x + 1][x - r + 1] += k;
		sum2[y - x + 1][x + r + 1] -= k;
	} else {
		sum3[x - y + 1][y - r + 1] += k;
		sum3[x - y + 1][y + r + 1] -= k;
	}
}

inline void add3(int x, int y, int r, int k){
	x += w;
	y += h;
	if (x + y - 1 <= w_){
		sum4[x + y - 1][y - r] += k;
		sum4[x + y - 1][y + r] -= k;
	} else {
		sum5[x + y - w_][x + r] += k;
		sum5[x + y - w_][x - r] -= k;
	}
}

inline void add4(int x, int y, int r, int k){
	if (r == 0) return;
	add2(x, y, r, k);
	add3(x, y + 1, r, -k);
}

inline void add5(int l, int r, int k, ll b){
	sumk[l] += k;
	sumk[r + 1] -= k;
	sumb[l] += b;
	sumb[r + 1] -= b;
}

inline void process(){
	for (register int i = 1; i <= h_; i++){
		for (register int j = 1, k = i; j <= w2 && k <= h2; j++, k++){
			sum2[i][j] += sum2[i][j - 1];
			sum1[j][k] += sum2[i][j];
		}
	}
	for (register int i = 1; i <= w_; i++){
		for (register int j = i, k = 1; j <= w2 && k <= h2; j++, k++){
			sum3[i][k] += sum3[i][k - 1];
			sum1[j][k] += sum3[i][k];
		}
	}
	for (register int i = 1; i <= w_; i++){
		for (register int j = i, k = 1; j >= 1 && k <= h2; j--, k++){
			sum4[i][k] += sum4[i][k - 1];
			if (j <= w2) sum1[j][k] += sum4[i][k];
		}
	}
	for (register int i = 1; i <= h_; i++){
		for (register int j = w_, k = i; j >= 1 && k <= h2; j--, k++){
			sum5[i][j] += sum5[i][j + 1];
			if (j <= w2) sum1[j][k] += sum5[i][j];
		}
	}
	for (register int i = 1; i <= w2; i++){
		for (register int j = 1; j <= h2; j++){
			sum1[i][j] += sum1[i][j - 1] + sum1[i - 1][j] - sum1[i - 1][j - 1];
		}
	}
	for (register int i = 1; i <= w2; i++){
		for (register int j = 1; j <= h2; j++){
			sum1[i][j] += sum1[i][j - 1] + sum1[i - 1][j] - sum1[i - 1][j - 1];
		}
	}
}

inline ll get_sum(int x1, int y1, int x2, int y2){
	x1 += w;
	y1 += h;
	x2 += w;
	y2 += h;
	return sum1[x2][y2] - sum1[x1 - 1][y2] - sum1[x2][y1 - 1] + sum1[x1 - 1][y1 - 1];
}

int main(){
	int n, q;
	w = Fread::read();
	h = Fread::read();
	n = Fread::read();
	w2 = w * 2;
	h2 = h * 2;
	if (w <= h){
		w_ = w * 3;
		h_ = h * 2 + w;
		init();
		for (register int i = 1; i <= n; i++){
			int x = Fread::read(), y = Fread::read(), a = Fread::read(), b = Fread::read(), r = min(a / b, h), thresold = max(x, w - x + 1);
			add1(x - r, y - r, x + r, y + r, a - b * r);
			if (r < thresold){
				add4(x, y, r, b);
			} else {
				int L = max(y - thresold, 0), R = min(y + thresold, h + 1);
				add4(x, y, thresold, b);
				add1(1, L + 1, w, R - 1, (ll)b * (r - thresold));
				add5(max(y - r + 1, 1), L, b, (ll)b * (r - y));
				add5(R, min(y + r - 1, h), -b, (ll)b * (r + y));
			}
		}
		process();
		for (register int i = 1; i <= h; i++){
			sumk[i] += sumk[i - 1];
			sumb[i] += sumb[i - 1];
		}
		for (register int i = 1; i <= h; i++){
			sum_val[i] = sum_val[i - 1] + (i * sumk[i] + sumb[i]);
		}
		q = Fread::read();
		for (register int i = 1; i <= q; i++){
			int x1, y1, x2, y2, size;
			x1 = Fread::read();
			y1 = Fread::read();
			x2 = Fread::read();
			y2 = Fread::read();
			size = (x2 - x1 + 1) * (y2 - y1 + 1);
			printf("%lld\n", (get_sum(x1, y1, x2, y2) + (x2 - x1 + 1) * (sum_val[y2] - sum_val[y1 - 1]) + size / 2) / size);
		}
	} else {
		w_ = w * 2 + h;
		h_ = h * 3;
		init();
		for (register int i = 1; i <= n; i++){
			int x = Fread::read(), y = Fread::read(), a = Fread::read(), b = Fread::read(), r = min(a / b, w), thresold = max(y, h - y + 1);
			add1(x - r, y - r, x + r, y + r, a - b * r);
			if (r < thresold){
				add4(x, y, r, b);
			} else {
				int L = max(x - thresold, 0), R = min(x + thresold, w + 1);
				add4(x, y, thresold, b);
				add1(L + 1, 1, R - 1, h, (ll)b * (r - thresold));
				add5(max(x - r + 1, 1), L, b, (ll)b * (r - x));
				add5(R, min(x + r - 1, w), -b, (ll)b * (r + x));
			}
		}
		process();
		for (register int i = 1; i <= w; i++){
			sumk[i] += sumk[i - 1];
			sumb[i] += sumb[i - 1];
		}
		for (register int i = 1; i <= w; i++){
			sum_val[i] = sum_val[i - 1] + (i * sumk[i] + sumb[i]);
		}
		q = Fread::read();
		for (register int i = 1; i <= q; i++){
			int x1, y1, x2, y2, size;
			x1 = Fread::read();
			y1 = Fread::read();
			x2 = Fread::read();
			y2 = Fread::read();
			size = (x2 - x1 + 1) * (y2 - y1 + 1);
			printf("%lld\n", (get_sum(x1, y1, x2, y2) + (y2 - y1 + 1) * (sum_val[x2] - sum_val[x1 - 1]) + size / 2) / size);
		}
	}
	return 0;
}
```

---

## 作者：Acee (赞：1)

提供一个简单的写法。

我们可以很好的观察到部分分中有许多 $H = 1$ 的情况。

这时，它就是一个等差数列的加法，可以很简单地使用二维差分解决。

所以我们考虑枚举每一行，但这样是 $2.5 \cdot 10^6$ 的，所以我们考虑在 $H$ 很大时，使用 $W$ 让矩阵翻转一下，就可以做到 $\sqrt{HW}$ 了。

总时间复杂度：$O(N \sqrt{HW})$。显然是可过的。

代码从 emacs 中拷出来的，缩进有问题就不放了。想要的私信。

---


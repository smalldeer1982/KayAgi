# [1007] 倍杀测量者

## 题目描述

今天 Scarlet 在机房有幸目睹了一场别开生面的 OI 训练。因为一些奇妙的 SPJ，比赛中所有选手的得分都是正实数（甚至没有上限）。

当一位选手 A 的分数不小于选手 B 的分数 $k$（$k>0$）倍时，我们称选手 A **$k$ 倍杀** 了选手 B，选手 B **被** 选手 A **$k$ 倍杀** 了。

更奇妙也更激动人心的是，训练前有不少选手立下了诸如 “我没 $k$ 倍杀选手 X，我就女装”，“选手 Y 把我 $k$ 倍杀，我就女装” 的 Flag。

知道真相的良心教练 Patchouli 为了维持机房秩序，放宽了选手们的 Flag 限制。Patchouli 设定了一个 **正** 常数 $T$，立下 “我没 $k$ 倍杀选手 X 就女装” 的选手只要成功 $k - T$ 倍杀了选手 X，就不需要女装。同样的，立下 “选手 Y 把我 $k$ 倍杀我就女装” 的选手只要没有成功被选手 Y $k+T$ 倍杀，也不需要女装。

提前知道了某些选手分数和具体 Flag 的 Scarlet 实在不忍心看到这么一次精彩比赛却没人女装，为了方便和 Patchouli 交易，Scarlet 想要确定最大的实数 $T$ 使得赛后一定有选手收 Flag 女装。

## 说明/提示

- 对于 $30\%$ 的数据，$n\leq5$，$s\leq 2$；
- 对于另 $40\%$ 的数据，保证 $t=n$；
- 对于 $100\%$ 的数据，$1\leq n,s\leq 1000$，$1\leq A,B,C,t\leq n$，$1\leq k\leq 10$，$1\leq x\leq 10^9$。保证输入中的 $C$ 两两不同。

## 样例 #1

### 输入

```
3 5 1
1 2 1 2
1 3 2 2
1 3 1 4
2 1 2 2
2 1 3 4
1 1```

### 输出

```
-1```

## 样例 #2

### 输入

```
3 2 3
1 2 1 10
2 2 3 6
1 1
2 6
3 9```

### 输出

```
3.9999993984```

# 题解

## 作者：EricQian (赞：46)

[$\leftarrow$ 我的差分约束专题](https://www.luogu.com.cn/blog/EricQian/ci-fen-yue-shu)

原题链接：[P4926 [1007]倍杀测量者](https://www.luogu.com.cn/problem/P4926)

## 题意

给出一系列不等式：

$$x_{a_i}\ge (k_i-t)\times x_{b_i}~~~\&~~~(k_i+t)\times x_{a_i}>x_{b_i}$$

以及一些 $x_i$ 的值 。

求出最大的 $t$ 使得不等式无解 。

------------

## 题解

算法：差分约束 $+$ 二分答案 。

**1. 连边**

首先对不等式进行拆分化简：

$$x_{a_i}\ge (k_i-t)\times x_{b_i}$$

$$\log_2{(x_{a_i})}\ge \log_2{(x_{b_i})}+\log_2{(k_i-t)}$$

连边 `add(b,a,log2(k-t))` 

$$(k_i+t)\times x_{a_i}>x_{b_i}$$

$$\log_2{(x_{a_i})}+\log_2{(k_i+t)}>\log_2{(x_{b_i})}$$

$$\log_2{(x_{a_i})}>\log_2{(x_{b_i})}-\log_2{(k_i+t)}$$

由于本题有精度 $10^{-5}$ 的容量范围，所以我们可以连边 `add(b,a,-log2(k+t))` 

（具体实现连边操作时只用记录 $k$ 的值，$t$ 根据边的种类在差分的时候分类讨论。）

**2. 判断无解**

输出 `-1` 仅当 $t=0$ 时不等式仍旧有解 。

**3. 二分答案**

二分一个 $t$ ，判断这个时候不等式是否有解 。输出答案 。

上AC代码（去掉了不必要的部分）：

```cpp
#define inf 0x7f7f7f7f
#define Maxn 5005
int n,s,t,tot;
int cnt[Maxn],hea[Maxn],nex[Maxn*2],ver[Maxn*2],typ[Maxn*2];
double ds[Maxn],edg[Maxn*2];
bool inq[Maxn];

inline void add(int x,int y,double d,int Type)
{
	 ver[++tot]=y,edg[tot]=d,typ[tot]=Type,nex[tot]=hea[x],hea[x]=tot;
}

bool spfa(double tmp) // tmp 这里表示上面说的 t 的值
{
	 for(int i=0;i<=n;i++) ds[i]=-inf,cnt[i]=0,inq[i]=false; ds[n+1]=0;
	 queue<int> q; q.push(n+1),inq[n+1]=true;
	 while(!q.empty())
	 {
	 	 int cur=q.front(); q.pop(),inq[cur]=false;
	 	 for(int i=hea[cur];i;i=nex[i])
	 	 {
	 	 	 double w=edg[i]; // 类型为 3 的边 
	 	 	 if(typ[i]==1) w=log2(edg[i]-tmp); // 类型为 1 的边 
	 	 	 if(typ[i]==2) w=-log2(edg[i]+tmp); // 类型为 2 的边 
	 	 	 if(ds[ver[i]]<ds[cur]+w)
	 	 	 {
	 	 	 	 ds[ver[i]]=ds[cur]+w,cnt[ver[i]]=cnt[cur]+1;
	 	 	 	 if(cnt[ver[i]]>=n+2) return true; // 判断无解 
	 	 	 	 else if(!inq[ver[i]]) inq[ver[i]]=true,q.push(ver[i]);
			 }
		 }
	 }
	 return false; // 此时有解 
}

double x,l=0,r=10,ans,mid;
scanf("%d%d%d",&n,&s,&t);
for(int i=0;i<=n;i++) add(n+1,i,0,3);
for(int i=1,opt,a,b;i<=s;i++)
{
	 scanf("%d%d%d%lf",&opt,&a,&b,&x),add(b,a,x,opt);
	 if(opt==1) r=fmin(r,x);
}
for(int i=1,c;i<=t;i++) scanf("%d%lf",&c,&x),add(0,c,log2(x),3),add(c,0,-log2(x),3);
if(!spfa(0)) printf("-1\n");
else
{
	 while(r-l>cha) // cha 是 0.00001 保证精度 
	 {
	 	 mid=(l+r)/2.0;
	 	 if(spfa(mid)) ans=mid,l=mid+cha;
	 	 else r=mid-cha;
	 }
	 printf("%.6lf\n",ans);
}
```

以上代码目前在最优解第一面 ^_^

---

## 作者：xzyxzy (赞：29)

# 题意
某地信息组流行女装。

一场考试后，一些骄傲的大佬和一些暴躁的蒟蒻达成约定：

如果某选手不满足以下限制条件，他将会被强迫女装

-  $s[A]>s[B]*k_i$
-  $s[A]>s[B]*\frac{1}{k_i}$

其中$s[A]$表示选手A的分数。同时你还已知一些选手的分数

请你求出最大的正实数$T$，使得限制条件变成下面的形式后，仍然有人女装

-  $s[A]>s[B]*(k_i-T)$
-  $s[A]>s[B]*\frac{1}{(k_i+T)}$

数据范围：限制数$\le1000$，$1\le k\le10$且为整数，已知选手的分数不超过$10^9$

# 题解
转化题意之后，就可以二分答案T了

对限制条件进行差分约束连边

- 对于$s[A]>s[B]*k_i$，从$B$向$A$连一条权值为$k_i$的边
- 对于$s[A]=x$，默认$s[0]=1$，从$0$向$A$连$x$，从$A$向$0$连$\frac{1}{x}$

对此图跑乘积最长路即可，如果存在环，则合法

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;
const int N=1100;
struct flag{int o,a,b,k;}fl[N];
struct edge{int next,to;double w;}a[N<<1];
int n,s,t,c[N],fr[N],head[N],cnt,vis[N];
double dis[N];queue<int> Q;
void link(int x,int y,double w){a[++cnt]=(edge){head[x],y,w};head[x]=cnt;}
int check(double T)
{
    memset(head,0,sizeof(head));
    memset(fr,0,sizeof(fr));cnt=0;
    while(!Q.empty()) Q.pop();
    for(int i=0;i<=n;i++) dis[i]=1,fr[i]=0,vis[i]=1,Q.push(i);	
    for(int i=1;i<=n;i++)
        if(c[i]) link(i,0,1.0/c[i]),link(0,i,c[i]);
    for(int i=1;i<=s;i++)
    {
        int A=fl[i].a,B=fl[i].b,k=fl[i].k,o=fl[i].o;
        if(o==1) link(B,A,k-T);
        else link(B,A,1.0/(k+T));
    }
    while(!Q.empty())
    {
        int x=Q.front();
        for(int i=head[x];i;i=a[i].next)
        {
            int R=a[i].to;
            if(dis[R]>=dis[x]*a[i].w) continue;
            dis[R]=dis[x]*a[i].w;fr[R]=fr[x]+1;
            if(fr[R]==n+2) return 1;
            if(!vis[R]) Q.push(R),vis[R]=1;
        }
        Q.pop();vis[x]=0;
    }
    return 0;
}
int main()
{
    cin>>n>>s>>t;
    double l=0,r=1e18,T=-1;
    for(int i=1;i<=s;i++)
    {
        int o,a,b,k;cin>>o>>a>>b>>k;
        fl[i]=(flag){o,a,b,k};
        if(o==1) r=min(r,(double)k-1e-8);
    }
    for(int i=1,C,x;i<=t;i++) cin>>C>>x,c[C]=x;
    while(r-l>1e-8)
    {
        double mid=(l+r)/2;
        check(mid)?l=T=mid:r=mid;
    }
    T==-1?puts("-1"):printf("%.10lf\n",T);
}
```

广告：https://www.cnblogs.com/xzyxzy

~~至今有些不明白的是，如果取倒数之后连边跑最短路、或者取对数后再做 会WA。如果有用该方法过了的同学，可以私信我一起讨论QAQ~~

感谢究极龙骑士：之前不能过的原因是上界有错，而且在连边之前没有判断是否已经合法，以及在跑SPFA时n+1个点应该是n+2长度的最短路才有正环。

现在已经用最短路+取对数AC本题：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<queue>
#define float double
using namespace std;
const int N=1100;
struct flag{int o,a,b,k;}fl[N];
struct edge{int next,to,tag;float w;}a[N<<1];
int n,s,t,c[N],fr[N],head[N],cnt,vis[N],gt[N];
float dis[N];queue<int> Q;
void link(int x,int y,int tag,float w)
{a[++cnt]=(edge){head[x],y,tag,log2(w)};head[x]=cnt;}
int check(float T)
{
    memset(head,0,sizeof(head));
    memset(fr,0,sizeof(fr));cnt=0;
    while(!Q.empty()) Q.pop();
    for(int i=1;i<=n;i++)
        if(c[i]) link(i,0,1,c[i]),link(0,i,0,c[i]);
    for(int i=1;i<=s;i++)
    {
        int A=fl[i].a,B=fl[i].b,k=fl[i].k,o=fl[i].o;
		if(c[A]&&c[B]&&((o==1&&c[A]<c[B]*(k-T))||
						(o==2&&c[A]*(k+T)<c[B]))) return 1;
        if(o==1) link(A,B,1,k-T);
        else link(A,B,0,k+T);
    }
	for(int i=0;i<=n;i++) dis[i]=0,fr[i]=0,Q.push(i),vis[i]=1;
	while(!Q.empty())
	{
		int x=Q.front();
		for(int i=head[x];i;i=a[i].next)
		{
			int R=a[i].to;
			float w=a[i].tag?dis[x]-a[i].w:dis[x]+a[i].w;
			if(dis[R]<=w&&dis[R]!=-1) continue;
			dis[R]=w;fr[R]=fr[x]+1;
			if(fr[R]==n+2) return 1;
			if(!vis[R]) Q.push(R),vis[R]=1;
		}
		Q.pop();vis[x]=0;
	}
    return 0;
}
int main()
{
    cin>>n>>s>>t;
    float l=0,r=1e18,T=-1;
    for(int i=1;i<=s;i++)
    {
        int o,a,b,k;cin>>o>>a>>b>>k;
        fl[i]=(flag){o,a,b,k};
        if(o==1) r=min(r,(float)k-1e-8);
    }
    for(int i=1,C,x;i<=t;i++) cin>>C>>x,c[C]=x;
    while(r-l>1e-6)
    {
        float mid=(l+r)/2.0;
        check(mid)?l=T=mid:r=mid;
    }
	T==-1?puts("-1"):printf("%.10f\n",(double)T);
}
```
（题解有更新，烦请管理员再次通过）

---

## 作者：Future_Fate (赞：23)

# **本题正解为差分约束**


------------


**题目大意：有s个关系，第i个为：**

 ** _Ai$\geq$(Ki-T)Bi_ $\bigvee$_Ai(Ki+T)>Bi_**

**要你求出最大的T使得其中至少有一个关系不满足**

**另外有 T$\in$(0,+$\propto$)  $\bigwedge$   $\forall$ki $\Rightarrow$ki-T$\in$(0,+$\propto$)**



------------

 我们看差分约束的式子：

如果  **_a-b$\geq$c_**

那么就由b向a连一条权值为c的边

最后再跑最长路，看有没有正权环



## 对于此题的条件来说，我们考虑两边同时取log！！！



那么原条件： ** _Ai$\geq$(Ki-T)Bi_ $\bigvee$_Ai(Ki+T)>Bi_**

就可以转化为： ** _log(Ai)$\geq$log(Ki-T)+log(Bi)_ $\bigvee$_log(Ai)+log(Ki+T)>log(Bi)_** 

再然后： ** _log(Ai)-log(Bi)$\geq$log(Ki-T)_ $\bigvee$_log(Ai)-log(Bi)>-log(Ki+T)_** 

**另外我们观察到k很小,k$\in$[1,10],则T的范围也很小,可以二分T来求解**

**然后就可以愉快的 二分+差分约束 啦!**

## 再说几个细节：

**1.**我们注意到可能一些人的分数是已知的,此时我们建一个虚点 _n+1_

依题意：若有(C,x),则:

addedge(_n+1_,_C_,x); addedge(_C_,_n+1_,-x)

这是一种差分约束中很经典的维护已知量的方法，它可以确保各个已知点之间的相对关系，**其实差分约束维护的就是一个相对关系**

**2.**我们注意到 **_log(Ai)-log(Bi)>-log(Ki+T)_**
    
   其实并不满足 **_a-b$\geq$c_**的形式，但我们为什么还可以用它呢？
   
   **其实题目中有说近似值的事情**
   
   因为与真实值相差不超过10^-4即可,所以我们可以做这样的近似
   
   ## 最后上代码：

```cpp
#include<cstdio>
#include<queue>
#include<cmath>
using namespace std;

const int inf=0x7fffffff/2;

const int maxn=5010;

int n,s,t,o,A,B,C,cnt,head[maxn],isin[maxn],intime[maxn];

double k,x,l,r=10,mid,dis[maxn];

double min(double a,double b){
	return a<b?a:b;
}

struct Know{
	int pe;
	double dis;
}know[maxn];

struct Edge{
	int f,t,next,kind;
	double k,w;
}edge[maxn];

void addedge(int f,int t,double w,int kind,double k){
	edge[++cnt].t=t;
	edge[cnt].f=f;
	edge[cnt].w=w;
	edge[cnt].kind=kind;
	edge[cnt].k=k;
	edge[cnt].next=head[f];
	head[f]=cnt;
}

bool spfa(double num){
	queue<int>q;
	for(int i=0;i<=n;++i) dis[i]=-inf,intime[i]=0,isin[i]=0;
	q.push(n+1);
	isin[n+1]=1;
	dis[n+1]=0;
	++intime[n+1];
	while(!q.empty()){
	    int fp=q.front();
	    q.pop();
	    isin[fp]=0;
	    for(int i=head[fp];i;i=edge[i].next){
	    	int tp=edge[i].t;
	    	double w;
	    	if(edge[i].kind==0) w=edge[i].w;
	    	if(edge[i].kind==1) w=log2(edge[i].k-num);
			if(edge[i].kind==2) w=-log2(edge[i].k+num);
			if(dis[tp]<dis[fp]+w){
				dis[tp]=dis[fp]+w;
				if(!isin[tp]){
					q.push(tp);
					isin[tp]=1;
					++intime[tp];
					if(intime[tp]>=n+1) return false; 
				}
			} 
		}
	
	}
	return true;
}

int main(){
	
	scanf("%d%d%d",&n,&s,&t); 
	
	for(int i=1;i<=s;++i){
		scanf("%d%d%d%lf",&o,&A,&B,&k);
	    addedge(B,A,0,o,k);
	    if(o==1) r=min(r,k);
	}
	
	for(int i=1;i<=t;++i){
		scanf("%d%lf",&C,&x);
		addedge(0,C,log2(x),0,0);
		addedge(C,0,-log2(x),0,0);
	}
	
	for(int i=0;i<=n;++i) addedge(n+1,i,0,0,0);
	
	
	if(spfa(0)){
		printf("%d",-1);
		return 0;
	}
	
	while(r-l>1e-5){
		mid=(r+l)/2;
		if(spfa(mid)) r=mid;
		else l=mid;
	}
	
	printf("%lf",l);
	
	return 0;
} 
```






---

## 作者：Hehe_0 (赞：6)

​	

#### 前言

​	差分约束变形题，但是感觉我的写的比较友好（比较入门

### 引：

差分约束系统 : 给定n个变量和m个不等式，每个不等式形如 $ x[i] - x[j] \leq a[k] $  ,去求 $ x[n-1] - x[0] $ 最大值。在这之中我们将这个不等式和最短路的松弛操作联系起来 ，对于不等式  $ x[i] - x[j] \leq a[k] $  我们连一条 j 到 i 的边，边权为 a[k]。 

对数运算 ： $ log_a(m * n) = log_am + log_a n  $ , $ log_a(m/n)=log_am-log_an $

### 题意：

$$
\begin{cases}
A > B * (k-t)\\
A > B * \frac {1}{k+t} \\
\end{cases}
$$

求 $ t_{max} $ 

### 解：

乘变加，减变除。

借log就可以转化为：

$ log_2(A) > log_2( B )+log_2(k-t)  $

$ log_2( A ) > log_2(B) -log_2(k+t)  $ 

 上列式子就可这样连边：
$add(B,A,k-t) $     $ add(B,A,1.0/(k+t)) $

然后建一个虚拟点0 $add(i,0,1.0/st[i])$       $add(0,i,st[i])$

之后二分 t   （ 无解：t=0 时不等式仍有解 ）

如果有环，调大 t 接着跑

#### 注：

边权是要乘法，所以初权为1;double的使用 ；判断合法；n+2最短路有正环



---

## 作者：Kalium (赞：6)

# P4926 [1007]倍杀测量者题解

## 前言：

本题接开了freopen，文件名是歌名，有兴趣听一下。

## 题意：

告诉你 k 个人的成绩，叫你求一个 t，使得：

$dis_A > dis_B * (k - t)$。

$dis_A > dis_B * \dfrac{1}{k + t}$。

$dis_A$ 表示 A 这个人的成绩。

## 思路：

明显求 t 不好求，得用二分来搞。

差分柿子已经给出，连边很显然为：

对于第一个柿子：

$(B, A, k - t)$。

对于第二个柿子：

$(B, A, 1.0 / (k + t))$。

那么对于输入的成绩，我们用一个超级源点 0 连接，即为：

$(A, B, score_i)$ 和 $(B, A, 1.0 / score_i)$。

那么如果连完图还是不连通呢？

好办，全部点都入队一遍。

接下来，我们只需要判断出有环即可，因为只要有环，意味着必然有人会女装，然后将 t 调大再跑即可。

## 细节：

注意是double。

在超级源点连边的时候，要判断出 $score_i$ 不为 0 才行。

因为我们是乘法边权，所以 $dis_i$ 一开始要为 1。

## 代码：


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>

const int N = 1e3 + 7;

using namespace std;

int n, m, k;

double score[N];

struct Edge {
	int to, next;
	double w;
} edge[N << 1 | 1]; 

int head[N], cnt;

struct Graph {
	int opt, u, v;
	double w;
} g[N]; 

double dis[N];

int in[N];

bool exist[N];

inline void addedge(int u, int v, double w) {
	edge[++ cnt].to = v;
	edge[cnt].w = w;
	edge[cnt].next = head[u];
	head[u] = cnt;
}

inline double mina(double a, double b) {
	if (a < b)
		return a;
	return b;
} 

inline bool spfa(double t) {
	memset(head, -1, sizeof(head));
	memset(edge, 0, sizeof(edge));
	cnt = 0;
	
	for (int i = 1; i <= m; i ++) {
		if (g[i].opt == 1)
			addedge(g[i].v, g[i].u, g[i].w - t);
		else
			addedge(g[i].v, g[i].u, 1.0 / (g[i].w + t));
	}
	
	for (int i = 1; i <= n; i ++) {
		if (score[i])
			addedge(0, i, score[i]), addedge(i, 0, 1.0 / score[i]);
	} 
	
	queue <int> q;
	
	memset(in, 0, sizeof(in));
	memset(exist, 0, sizeof(exist));
	exist[0] = 1, in[0] = 1;
	
	for (int i = 0; i <= n; i ++) dis[i] = 1, q.push(i);
	
	while (! q.empty()) {
		int u = q.front();
		
		q.pop();
		
		for (int i = head[u]; ~i; i = edge[i].next) {
			int v = edge[i].to;
			
			if (dis[v] < dis[u] * edge[i].w) {
				dis[v] = dis[u] * edge[i].w;
				
				if (! exist[v]) {
					exist[v] = 1;
					q.push(v);
					in[v] ++;
					
					if (in[v] > n + 1) return 0;
				}
			}
		}
		
		exist[u] = 0;
	}
	
	return 1;
}

int main() {
	freopen("Next yo me.in", "r", stdin);
	freopen("Next yo me.out", "w", stdout);
	
	double t = -1, l = 1e-6, r = 10000000;
	
	scanf("%d %d %d", &n, &m, &k);
	
	for (int i = 1, op, u, v, w; i <= m; i ++) {
		scanf("%d %d %d %lf", &g[i].opt, &g[i].u, &g[i].v, &g[i].w);
		
		if (g[i].opt == 1)
			r = mina(r, 1.0 * g[i].w);
	}
	
	for (int i = 1, id; i <= k; i ++) {
		double idx;
		
		scanf("%d %lf", &id, &idx);
		
		score[id] = idx;
	}
	
	const double eps = 1e-12;
	
	while (l + eps < r) {
		double mid = (l + r) / 2;
		
		if (! spfa(mid))
			t = l = mid;
		else
			r = mid;
	} 
	
	if (t == -1)
		printf("-1\n");
	else
		printf("%0.10lf\n", t);
	
	fclose(stdin);
	fclose(stdout);
	
	return 0;
}
```

$Atlantic.$

---

## 作者：A_Đark_Horcrux (赞：4)

做了一个世纪终于做出来了……

## 差分约束+二分。

$\texttt{<1> 差分约束部分}$

观察题目描述部分：

>当一位选手A的分数不小于选手B的分数 $k(k>0)$ 倍时，我们称选手A **“ k 倍杀”了选手B，选手B被选手A“ k 倍杀”** 了

看到“不小于”这样的限制条件，想起差分约束qwq

设选手 $\text{A}$ 得分为 $C_A$ ，选手 $\text{B}$ 得分为 $C_B$ ，

- $\text{A}$ 说“我没‘k倍杀’选手 $\text{B}$ ，我就女装”$(o=1)$  $\Rightarrow$ 不满足 $C_A\geq C_B*(k-T)$  ，则 $\text{A}$ 女装

- $\text{A}$ 说“选手 $\text{B}$ ‘k倍杀’我，我就女装” $(o=2)$ $\Rightarrow$ 不满足 $C_A \geq C_B * \dfrac{1}{k+T}$ ，则 $\text{A}$ 女装

那根据差分约束的操作，

- 若$o=1$ ，从 $\text{B}$ 向 $\text{A}$ 建一条边权为 $k-T$ 的边；

- 若$o=2$ ，从 $\text{B}$ 向 $\text{A}$ 建一条边权为 $\dfrac{1}{k+T}$ 的边。

差分约束时还得注意：

__1.如果不保证图联通，必须先建立超级节点。__

此处不能简单地向每一个点建边，因为只有已知分数的选手所代表的节点才能作为判断的起点。因此，如果某位选手 $X$ 分数已知，我们从 $0$ 向 $X$ 建一条边权为 $C_X$ 的边，根据题目规则，我们还要相应地 从 $X$ 向 $0$ 建一条边权为 $\dfrac{1}{C_X}$ 的边。

__2.建图剪枝__

在建图的时候如果遇到不合法的情况得跳出来。这题中不合法的情况有一种，那就是已知了 $C_A$ 和 $C_B$ ，但是不满足输入的关系。判断一下即可qwq

至此，本题最难的部分已经完成了！！

接下来就是差分约束的基本操作了，跑最长路，找负环即可。这题中路径的长度是每条边的乘积，可以像[P2384](https://www.luogu.com.cn/problem/P2384)那样转化为对数计算，但由于边权都很小，还出现小于1的情况，估摸着乘起来不会很大吧，直接全部乘起来即可qwq

最后还有一个坑点：由于跑的是乘积最长路，__dis数组每一位要初始化为1！！！！__ 我在这卡了好久TAT

```cpp
int opt[N],x[N],y[N],c[N],cnt[N];//分别为题目描述中的o,A,B,已知分数，判负环用的cnt数组
db z[N],dis[N];//题目描述中的k，以及路径长度
...//不必要的快读等
il void init()//初始化，该清空的清空，该赋值的赋值
{
	memset(a,0,sizeof(a));
	memset(h,0,sizeof(h));
	memset(b,0,sizeof(b));
	memset(cnt,0,sizeof(cnt));
	for(i=0;i<=n;i++) dis[i]=1;//dis数组每一位要初始化为1！！！！！！
	while(!q.empty()) q.pop();
	s=0;
}
il bool spfa(db T)//找负环部分
{
	init();
	for(int i=1;i<=m;i++)
	{
		if(c[x[i]]&&c[y[i]]&&(opt[i]==1&&c[x[i]]<c[y[i]]*(z[i]-T)
        	||opt[i]==2&&c[x[i]]*(z[i]+T)<c[y[i]])) return 1;//如果关系不合法直接return掉
		if(opt[i]==1) build(y[i],x[i],z[i]-T);
		else build(y[i],x[i],1.0/(z[i]+T));//否则按规则建边
	}
	for(int i=1;i<=t;i++)
		if(c[i])
			build(i,0,1.0/c[i]),build(0,i,c[i]);//给超级点建边
	dis[0]=1,b[0]=1,cnt[0]++,q.push(0);//素质四连
	while(!q.empty())
	{
		int now=q.front();
		q.pop(); b[now]=0;
		for(int i=h[now];i;i=a[i].next)
		{
			int y=a[i].to;
			if(dis[y]<dis[now]*a[i].dis)//乘法最长路
			{
				dis[y]=dis[now]*a[i].dis;
				if(!b[y])
				{
					cnt[y]++;
					if(cnt[y]>n) return 1;//有负环，return 1
					b[y]=1,q.push(y);
				}
			}
		}
	} 
	return 0;//没有负环，return 0
}
```
$\texttt{<2> 二分部分}$

> Scarlet想要确定最大的实数 $T$ 使得赛后一定有选手收Flag女装

这种“使答案存在的最大值”的描述，不难想到二分吧qwq

二分 $T$ 然后判断即可。

由于 $k\leq 10$ ，$r$ 的初始值赋为 $10$ 即可qwq

```
	db l=0,r=10,ans=-1;//因为答案不小于0，ans初始值赋为-1
	while(r-l>1e-7)//保险，精度高一点
	{
		db mid=(l+r)/2.0;
		if(spfa(mid)) ans=mid,l=mid;
		else r=mid;
	}
	if(ans==-1) puts("-1");
	else printf("%.10lf",ans);//输出
   //完结撒花awa
```

---

## 作者：斜揽残箫 (赞：3)

###【题目大意】

某地的机房要集体女装，但是教练不想让他们女装，放松了限制，但出题人想至少要有一个人女装，求减去的最大限制使得至少有一个人女装。

咳咳，下面才是正题：
###【解题思路】

#### **1 . 总体思路**

因为题目中说出了 **不小于** ，说明要列不等式，可要用差分约束来解决。

本题要求出最大值 $T$ 来满足有人女装，直接求 $T$ 肯定不好求，又因为要求出最大值，考虑二分来解决。

根据题目要求列出不等式，每次分出一个 $T$ 值，根据这个 $T$ 值进行连边，跑一遍最长路，如果存在环路就说明合法，可以增加减去的 $T$ 值，反之减少，最后得出答案。

#### **2 . 条件分析**

根据题目，有两种情况 ：

+ **我没 $k$ 倍杀选手 $X$，我就女装**
+ **选手 $Y$ 把我 $k$ 倍杀我就女装**
所以在教练更改以后同学 $A$ 要女装的条件分别为 :
$$A < B \times (k - T) \\  A < B \times \frac{1}{(k + T)}$$
根据上面两个式子可以根据差分约束来连边。

+ 第一种情况从 $B$ 向 $A$ 连一条边权为 $k - T$ 的边。
+ 第二种情况从 $B$ 向 $A$ 连一条边权为 $ \dfrac{1}{k + T}$ 的边。

要保证图联通，所以建立一个超级源点 $0$ ，要保证根据已有同学的成绩来作为判断的条件，所以要根据已有同学的成绩连边，连边时注意要两种情况都连边。

例如当知道 $C$  的成绩为 $10$ 时，从 $0$ 向 $C$ 建立一条边权为 $10$ 的边。还要从 $C$ 向 $0$ 建立一条边权为 $\dfrac{1}{10}$ 的边。

这时候基本上都分析完了， 开始二分建图求最大 $T$。

#### **3 . 二分建图**

二分不用说了吧...   注意精度开大点即可。

#### **4 . 我的错误**

被 $n$ 个错误卡炸的我决定诉说一下

+ 写二分精度的时候 $EPS$ 要定义为 $double$ ，否则一直死循环。
+ 因为是乘积最短路，$dis$ 数组要附初值为 $1$；
+ 千万别用 $memset$ 附初值为 $1$，就我傻傻的调了半天也没看出来。
+ 多组数据记着清空；

这些错误也就卡了我半天...

### 【Code】
```cpp
#include<cstdio>
#include<queue>
#include<iostream>
#include<cstring>
#define M 1000010
#define N 1010
#define qaq cout<<"可行QAQ"<<endl
#define INF 0x3f3f3f3f
using namespace std;
const int mod1 = 19260817;
const int mod2 = 19660813;
const double EPS = 1e-7;//确保精度 
/*================================================*/

int n,m,cnt,t;
struct node{
  int next;
  int to;
  double dis;
}e[N << 1];
struct nod{
  int pos;
  int u;
  int v;
  double val;
}bian[N << 1];
int head[N];
double w[N];
int vis[N];
int in[N];//入队次数
int id[N]; 

/*================================================*/

inline int read()
{
	int s = 0, f = 0;char ch = getchar();
	while (!isdigit(ch)) f |= ch == '-', ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

void add(int from,int to,double dis)
{
  e[++ cnt].to = to;
  e[cnt].dis = dis;
  e[cnt].next = head[from];
  head[from] = cnt;
  return;
}

bool check(double T)
{
  queue <int> qp;
  while(qp.size()) qp.pop();
  for(int i = 1;i <= n;i ++) w[i] = 1;
    // 有时候当你一直输出 0 时 ，看看这个 。。。 
  memset(head,0,sizeof(head));
  memset(vis,0,sizeof(vis));
  memset(in,0,sizeof(in));
  cnt = 0;
  // 数据清空
  for(int i = 1;i <= m;i ++) {//连边 
    if(id[bian[i].u] && id[bian[i].v] && ((bian[i].pos == 1 && id[bian[i].u] < id[bian[i].v] * (bian[i].val - T)) 
    || (bian[i].pos == 2 && id[bian[i].u] < id[bian[i].v] / (bian[i].val + T )))) return true; //剪枝 
    if(bian[i].pos == 1) add(bian[i].v ,bian[i].u ,bian[i].val - T);
    // x < y * (k - T) ;
    else add(bian[i].v ,bian[i].u ,1.0 / (bian[i].val + T));
    // x < y * 1 / (k + T);
  }
  for(int i = 1;i <= t;i ++) {
  // 由已知数据来建立超级源点， 所有的情况建立在这之上 
    if(id[i]) {
      add(0,i,id[i]);
      add(i,0,1.0 / id[i]); 
    }
  }
  w[0] = 1;
  vis[0] = 1;
  in[0] = 1;//入队次数 
  qp.push(0);
  while(!qp.empty()) {
    int x = qp.front();
    qp.pop();
    vis[x] = false;
    for(int i = head[x];i; i = e[i].next) {
      int y = e[i].to;
      if(w[y] < w[x] * e[i].dis) {
        w[y] = w[x] * e[i].dis;
        if(!vis[y]) {
          vis[y] = true;
          qp.push(y);
          ++ in[y];
          if(in[y] >= n + 1) return true;
        }
      }
    }
  }
  return false;
}
/*=================================================*/

signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
  n = read(); m = read(); t = read();
  double l = 0.0, r = 100.0; 
  for(int i = 1;i <= m;i ++) {
    bian[i].pos = read();
    bian[i].u = read();
    bian[i].v = read();
    bian[i].val = read() * 1.0;// 储存边的情况 
    // 因为之后的连边并不是 k 而是 （k - T） 
  }
  for(int i = 1;i <= t;i ++) {
    int iid,pts;
    iid = read(); pts = read();
    id[iid] = pts;//已有的成绩。 
  }
  double ans = -1;
  int iii = 0;
  while(r - l > EPS) {
    double mid = (r + l) / 2.0;
    if(check(mid)) {
      l = mid + EPS;
      ans = mid;
    }
    else r = mid - EPS;
    //cout << r <<" " << l <<" "<<iii ++ << endl;
  }
  if(ans == -1) printf("-1");
  else printf("%.10lf",ans);
  return 0;
}
```
这玩意跑的并不快，如果你想冲入 $50 ms$ 以内，开始我们的优化 ：

**1. 基本优化**

+ $SPFA$ 优化 ——— $SLF$ 。  $LLL$ 优化我没试。

+ 剪枝 ： 已知两个人成绩，且知道两者之间的女装关系符合条件一或条件二，可以直接返回，因为这时存在环路。

**2 . 玄学优化**

一般来说不靠谱... 考试千万别用。

+ 减少一下二分区间；

+ 减少一下精度；

+ 判断环的时候，如果入队次数大于 $n + 1$ 改为 $\sqrt{n + 1}$，或者 $\sqrt{\sqrt{n + 1}}$; 这个思想还是我从 [P3084](https://www.luogu.com.cn/problem/P3084) 最后一个点学来的。这玩意看 $RP$ ，开方次数过多会导致判断出错，一般来说进了很多次队列就很有可能是环。

于是完美的从 $270ms$ 卡到了 $27ms$ 到了最优解 。

优化后的代码就不贴了。

---

## 作者：ofbwyx (赞：1)

## 题目分析

题中所述，一个选手不需要女装的条件为「A 成功 $k-T$ 倍杀 B」和「A 没有成功被 B $k+T$ 倍杀」。

令 $s[A]$ 为选手 A 的得分，条件为 $s[A] \ge s[B] \times (k-T)$ 和 $s[A] \ge s[B] \times \dfrac{1}{k+T}$。

由于需要有选手女装，我们需要找到最大的 $T$ 使不等式组无解。我们可以通过差分约束实现判断不等式组是否有解，二分寻找最大的 $T$。

不过，我们在跑差分约束之前可以先把不等式两边同时取 log，将其变为加减法。两个不等式分别转换为 $\log_2(s[A]) - \log_2(s[B]) \ge \log_2(k-T)$ 和 $\log_2(s[A]) - \log_2(s[B]) \ge - \log_2(k+T)$。

## 实现

### 连边

我们需要储存边的种类、选手得分（若已知）、倍杀中的 k，在差分约束中根据边的种类计算出边权。

两种 flag 所对应的边权即为两个不等式的右项。若没有发生倍杀（即因为已知得分连边），直接将边权定为选手得分。

### 已知得分

我们再创造一个超级原点，将已知得分的选手与这个点连边（两条，一正一负，同上文所述不等式）。预先将其进行 $\log_2$ 的运算。

### 有无解

若差分约束中出现负环说明此不等式组无解，符合题目要求。将二分中的 `l=mid`。否则将 `r=mid`。

若 $T$ 为 $0$ 时不等式组仍成立，则题目无解。

### 具体实现

（代码中注释应该很详细了，有注释版本正好一百行。）

```cpp
#include<bits/stdc++.h>
using namespace std;

inline int read(){
	int w=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		w=w*10+ch-48;
		ch=getchar();
	}
	return w*f;
}

#define MAXN 1005

int n,s,t;
double l,r=10.0;

struct node{
	int v,nxt;
	int op;//边类型 
	double w,k;//已知得分，倍杀 
}e[MAXN*4];
int cnt=0,head[MAXN];
void build(int op,int u,int v,double w,double k){
	e[++cnt].op=op,e[cnt].v=v;
	e[cnt].w=w,e[cnt].k=k;
	e[cnt].nxt=head[u],head[u]=cnt;
}
//建图
//五个参数分别为 边的类型（倍杀还是被倍杀），边的起点，边的终点 
//选手得分（若已知，否则为0），倍杀的 k 

double dis[MAXN];
int inq[MAXN],c[MAXN];

bool spfa(double t){
	queue<int>q;
	for(int i=0;i<=n;i++)dis[i]=-1e9,c[i]=0,inq[i]=0;
	//记得清空数组
	dis[n+1]=0,inq[n+1]=1,c[n+1]++;
	q.push(n+1);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		inq[u]=0;
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].v;
			double w=e[i].w;//选手已知的得分 
			if(e[i].op==1)w=log2(e[i].k-t);//若为第一种 flag 
			if(e[i].op==2)w=-log2(e[i].k+t);//第二种 flag 
			if(dis[v]<dis[u]+w){//正常的跑差分约束 
				dis[v]=dis[u]+w;
				if(!inq[v]){
					inq[v]=1,c[v]++;
					q.push(v);
					if(c[v]>=n+1)return 0;//不等式组无解 
					//由于有两个超级原点，一个点入队大于等于 n+1 次才可判断无解 
				}
			}
		}
	}
	return 1;//不等式组有解 
}

int main(){
	n=read(),s=read(),t=read();
	for(int i=1;i<=s;i++){
		int op=read(),a=read(),b=read(),k=read();
		build(op,b,a,0,k);//倍杀
		if(op==1)r=(double)fmin(r,(double)k);//二分的上界 
	}
	for(int i=1;i<=t;i++){//已知选手得分 
		int c=read();
		double x=(double)read();
		build(0,0,c,log2(x),0);
		build(0,c,0,-log2(x),0);
		//连两条边到超级原点 
	}
	for(int i=0;i<=n;i++)build(0,n+1,i,0,0);
	//另一个超级原点保证图的连通 
	
	if(spfa(0)){
		printf("-1");
		return 0;
	}//T=0 时仍有解，说明题目无解 
	
	while(r-l>1e-5){//由于精度要求不高，无需使用相减判断 
		double mid=(r+l)/2.0;
		if(spfa(mid))r=mid;
		else l=mid;
	}//二分找到答案 
	
	printf("%lf",l);
	return 0;
}
```

## 后记

### 注意事项

- 一些数据需要用浮点数存。

- 由于差分约束中边权可能为负，`dis` 数组需要初始化为一个极小的数（如 $1e9$）。

- 跑 `spfa` 时注意清空数组。

### 后记的后记

若发现错误请私信我（毕竟我太菜了，难免出错）。

这道题我断断续续调了差不多一个多月，算是第一道紫题（也是第一篇紫题题解）。

---

## 作者：zplqwq (赞：1)

啊不是，这题精度也太..好过了。

这题其实挺简单的，只要想好怎么建边，跑SPFA即可。

首先题目给出以下不等式：

- $s_a > s_b \times (k_i -T)$

- $s_a \times (k_i +T) > s_b $

这一看！欸咋那么像差分约束呢。

那么第一个问题，怎么连边。

我不是很会跑乘法，所以我把它转换成 $\log$ 跑加法。

对于第一个式子，我们可以转换成：$\log_2(s_{a_i}) + \log_2(s_{b_i} + \log_2(k_i -t)$

对于第二个式子，我们可以转换成：$\log_2(s_{a_i}) > \log_2(s_{b_i}) - \log_2(k_i+t)$

然后加边就出来了。

因为这题对精度要求很低，所以我们可以直接连。

每次记录 $k$ 的值，然后对于 $t$ 分类讨论。

```cpp
	for(int i=0;i<=n;i++)
	{
		add(n+1,i,0,3);	
	} 
	for(int i=1,opt,a,b;i<=s;i++)
	{
		cin>>opt>>a>>b>>x;
		add(b,a,x,opt);
		if(opt==1)
		{
			r=min(r,x); 
		}
	}
	for(int i=1,c;i<=t;i++) 
	{
		c=read();
		x=read();
		add(0,c,log2(x),3);
		add(c,0,-log2(x),3);	
	}
```

无解的话就是在 $t=0$ 且上面那个式子还有解。

后面 SPFA 操作就很套路了。

至于求最大的值，二分答案一下就好了。

如果需要的话可以私信我要完整版代码，但感觉没什么好讲的。



---

## 作者：raincity (赞：0)

## 分析
这道题显然不好直接求出 $T$ 值。

显然，如果 $T=T'$ 时有人nz，那么当 $T<T'$ 的时候肯定也有人 nz，说明这道题的答案具有单调性，可以考虑二分转换成判断问题。

接下来需要实现函数 $check(mid)$。

不妨假设 $T=mid$ 时没有人女装，为了方便，设第 $i$ 个选手的成绩是 $score_i$，那么会有一些限制如下：

对于每一个 $o=1$ 的 flag，有：$score_a \ge score_b \times (mid-k)$。

对于每一个 $o=2$ 的 flag，有：$score_a \times (mid+k) > score_b$。

只需知道是否存在满足条件的 $score$（别忘了还有一些 $score$ 已知）。

变一下形：$\dfrac{score_a}{score_b} \ge  (mid-k)$ 和 $\dfrac{score_a}{score_b}>\dfrac{1}{mid+k}$

反正这道题的精度要求不高，直接都当做大于等于好像也没什么问题~~事实上是我不知道差分约束怎么处理严格不等号~~

那么对于 $\dfrac{score_x}{score_y}\ge z$，由 $y$ 向 $x$ 连一条权值为 $z$ 的边，对于已知 $score$ 的点 $i$，由虚拟节点 0（强制让 $score_0=1$）向 $i$ 连 $score_i$ 的边，再由 $i$ 向 0 连 $\dfrac{1}{score_i}$的边，如果存在一个环上面的边权乘积大于1就不能满足，也就是会有人 nz；否则就可能没有人 nz。

## 解决
$\texttt{Talk is cheap, show me your code!(}$

```cpp
// Problem: P4926 [1007]倍杀测量者
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P4926
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <map>

using namespace std;

const int N = 1005, M = 2005;
int n, m, c, tot;
double dis[N], edge[M];
int nxt[M], ver[M], head[N];
int cnt[N], val[N];
int score[N];
char vis[N];
queue <int> Q;

struct NZ_Flag {
    int op, a, b, k;
}flag[N];

inline char SPFA() {
    memset(vis, 1, sizeof(vis));
    memset(cnt, 0, sizeof(cnt));
    memset(val, 0, sizeof(val));
    for (int i = 0; i <= n; i++) dis[i] = 1, Q.push(i);
    while (!Q.empty()) {
        int cur = Q.front();
        Q.pop();
        vis[cur] = 0;
        for (int i = head[cur]; i; i = nxt[i]) {
            int to = ver[i];
            double w = edge[i];
            if (dis[to] < dis[cur] * w) {
                dis[to] = dis[cur] * w, val[to] = val[cur] + 1;
                if (val[to] > n)
                    return 1;
                if (!vis[to]) {
                    vis[to] = 1, Q.push(to);
                    cnt[to]++;
                    if (cnt[to] > n)
                        return 1;
                }
            }
        }
    }
    return 0;
}

template <class file>
inline void read(file &ret) {
    ret = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9') ch = getchar();
    while (ch >= '0' && ch <= '9') ret = ret * 10 + ch - '0', ch = getchar();
}

inline void addedge(int x, int y, double z) { 
    ver[++tot] = y, edge[tot] = z;
    nxt[tot] = head[x], head[x] = tot; 
}

inline char check(double mid) {
    memset(head, 0, sizeof(head)), tot = 0;
    for (int i = 1; i <= m; i++) {
        if (flag[i].op == 1)
            addedge(flag[i].b, flag[i].a, flag[i].k - mid);
        else
            addedge(flag[i].b, flag[i].a, 1.0 / (mid + flag[i].k));
    }
    for (int i = 1; i <= n; i++)
        if (score[i])
            addedge(0, i, score[i]), addedge(i, 0, 1.0 / score[i]);
    return SPFA();
}

int main() {
    read(n), read(m), read(c);
    double l = 1e-6, r = 10, ans = -1;
    for (int i = 1; i <= m; i++) {
        read(flag[i].op), read(flag[i].a), read(flag[i].b), read(flag[i].k);
        if (flag[i].op == 1)
            r = min(r, 1.0 * flag[i].k);
    }
    while (c--) {
        int x, y;
        read(x), read(y);
        score[x] = y;
    }
    for (int i = 1; i <= 50; i++) {
        double mid = (l + r) / 2;
        if (check(mid))
            l = ans = mid;
        else
            r = mid;
    }
    printf("%.4lf\n", ans);
    return 0;
}
```

#### THE END

---


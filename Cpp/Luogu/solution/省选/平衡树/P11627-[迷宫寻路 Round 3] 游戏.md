# [迷宫寻路 Round 3] 游戏

## 题目描述

小 L 正在玩游戏，游戏地图是一颗 $n$ 个节点的树，定义一条树上路径的长度为路径上所有边的边权之和，路径可以重复经过点和边。特别的，若路径不包含任何边，则其长度为 $0$。

小 L 会选择一个点作为必经点 $t$，接着，小 L 会设置每条边的边权，使得边的边权构成一个 $1$ 到 $n-1$ 的**排列**。

定义：小 L 的得分为 $\sum_{1 \leq u,v \leq n} \operatorname{dist}(u,v)$，其中 $\operatorname{dist}(u,v)$ 为在经过必经点 $t$ 的前提下，长度**最小的**从 $u$ 到 $v$ 的路径的长度。

小 L 希望最大化自己的得分，请你解答以下问题：

第一问：求他得分的**最大值**对 $998244353$ 取模的值。

第二问：求若要最大化他的得分，小 L 应该选择的必经点 $t$ 和小 L 每条边应设置的边权。


## 说明/提示

**本题采用捆绑测试。**

对于所有数据，$1\le n\le 10^5$。

| 子任务编号 | $n\leq$ | 特殊性质 1 | 特殊性质 2 | 分数 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $50$ | 否 | 否 | $10$ |
| $1$ | $1000$ | 否 | 否 | $20$ |
| $2$ | $10^5$ | 是 | 否 | $10$ |
| $3$ | $10^5$ | 否 | 是 | $10$ |
| $4$ | $10^5$ | 否 | 否 | $50$ |

特殊性质 1：存在一个对点重标号的方案，使得第 $i$ 条边为 $(1,i+1)$。

特殊性质 2：存在一个对点重标号的方案，使得第 $i$ 条边为 $(i,i+1)$。


## 样例 #1

### 输入

```
5
1 2
1 3
2 4
2 5```

### 输出

```
280
3
3 4 1 2```

## 样例 #2

### 输入

```
7
5 1
1 7
6 2
2 1
4 5
3 2```

### 输出

```
1106
4
5 1 2 4 6 3```

## 样例 #3

### 输入

```
10
3 6
7 3
8 10
5 9
9 1
4 8
1 8
2 3
6 10```

### 输出

```
5240
5
4 1 6 9 8 2 7 3 5```

## 样例 #4

### 输入

```
10
1 2
1 3
3 4
3 5
2 6
6 7
7 8
8 9
9 10```

### 输出

```
5660
10
4 3 1 2 5 6 7 8 9```

## 样例 #5

### 输入

```
20
5 18
16 11
6 15
7 14
8 7
10 20
3 4
14 6
9 8
18 11
17 4
11 10
4 11
2 13
13 12
12 15
15 20
19 9
1 8```

### 输出

```
79480
19
1 2 14 16 17 12 3 15 18 7 4 11 9 5 8 10 13 19 6```

## 样例 #6

### 输入

```
10
7 8
3 2
6 7
2 10
8 3
4 1
9 2
1 3
5 7
```

### 输出

```
4340
5
8 6 1 2 7 3 4 5 9 ```

## 样例 #7

### 输入

```
见附件```

### 输出

```
见附件```

# 题解

## 作者：Genius_Star (赞：3)

### 思路：

容易发现在树上，必须经过点 $t$ 的最短路径长度 $\operatorname{dist}(u, v) = \operatorname{dis}(u, t) + \operatorname{dis}(v, t)$。

故有：

$$\begin{aligned} \sum_{u = 1}^n \sum_{v = 1}^n \operatorname{dist}(u, v) &= \sum_{u = 1}^n \sum_{v = 1}^n \operatorname{dis}(u, t) + \operatorname{dis}(v, t) \\ &= 2n \sum_{u = 1}^n \operatorname{dis}(u, t) \end{aligned}$$

故我们只需要最大化：

$$\sum_{u = 1}^n \operatorname{dis}(u, t)$$

钦定 $t$ 为跟，则原式化为：

$$\sum_{u = 1}^n dep_t$$

容易预处理出 $cnt_i$ 表示 $i$ 这条边被经过的次数，设 $w_i$ 表示边权，则要最大化：

$$\sum_{i = 1}^{n - 1} cnt_i w_i$$

由于 $w$ 是一个排列，故考虑贪心即可，按照 $cnt$ 的值从大到小分配 $(n - 1) \to 1$。

这样就可以做到 $O(N^2)$。

考虑 $cnt_i$ 本质是什么？设 $i$ 这条边为 $(u, v)$，且以 $t$ 为根时 $v$ 较深一些，故有：

$$cnt_i = siz_v$$

故有式子为：

$$\sum_{i = 1}^{n - 1} siz_{v_i} w_i$$

由于我们需要枚举 $t$，故考虑换根 dp。

设从 $fa_u$ 换到 $u$，发现修改了 $siz$ 的点很少，只有 $u, fa_u$ 这两个点；其中 $siz_{fa_u} \gets siz_{fa_u} - siz_u, siz_u \gets n$。

即相当于在原来 $\{siz_i\}$ 集合中删除 $siz_u$，加入新的 $siz'_{fa_u}$。

故我们现在只需要做单点修改，全局下面式子的最大值：

$$\sum_{i = 1}^{n - 1} siz_{v_i} w_i$$

考虑维护值域线段树 $[1, n]$，对于每个区间 $[l, r]$ 维护有多少个 $siz_i$ 在这里面（设有 $cnt$ 个），以及这些 $siz$ 的和 $sum$，以及考虑 $w$ 是 $1 \sim cnt$ 的
排列时的最大值。

合并两个区间 $cnt_l, sum_l, ans_l, cnt_r, sum_r, ans_r$ 时，显然有：

$$cnt = cnt_l + cnt_r$$

$$sum = sum_l + sum_r$$

对于右区间的 $w$，显然要由 $1 \sim cnt_r$ 的排列变为 $cnt_l + 1 \sim cnt_l + cnt_r + 1$ 的排列，即 $w$ 整体添加了 $cnt_l$，故：

$$ans = ans_l + ans_r + cnt_l sum_r$$

时间复杂度为 $O(N \log N)$。

总体认为下位紫，最后我认为并不好想到值域线段树的做法，比较显然的应该是楼下老哥的平衡树做法。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define lowbit(x) x & (-x)
#define pi pair<ll, ll>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
const int N = 1e5 + 10;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
struct St{
	int data;
	int id;
	inline bool operator<(const St&rhs)const{
		if(data ^ rhs.data)
		  return data > rhs.data;
		return id > rhs.id;
	}
}A[N];
struct Node{
	int l, r;
	int cnt;
	ll sum, ans;
}X[N << 2];
ll ans;
int n, id;
int siz[N], p[N], w[N];
vector<pair<int, int>> E[N];
inline void add(int u, int v, int id){
	E[u].push_back({v, id});
	E[v].push_back({u, id});
}
inline void pushup(int k){
	X[k].cnt = X[k << 1].cnt + X[k << 1 | 1].cnt;
	X[k].sum = X[k << 1].sum + X[k << 1 | 1].sum;
	X[k].ans = X[k << 1].ans + X[k << 1 | 1].ans + 1ll * X[k << 1].cnt * X[k << 1 | 1].sum;
}
inline void build(int k, int l, int r){
	X[k].l = l, X[k].r = r;
	if(l == r)
	  return ;
	int mid = (l + r) >> 1;
	build(k << 1, l, mid);
	build(k << 1 | 1, mid + 1, r);
}
inline void update(int k, int i, int v){
	if(X[k].l == i && i == X[k].r){
		X[k].cnt += v;
		X[k].sum += v * i;
		if(v == 1)
		  X[k].ans += 1ll * X[k].cnt * i;
		else
		  X[k].ans -= 1ll * (X[k].cnt + 1) * i;
		return ;
	}
	int mid = (X[k].l + X[k].r) >> 1;
	if(i <= mid)
	  update(k << 1, i, v);
	else
	  update(k << 1 | 1, i, v);
	pushup(k);
}
inline void dfs1(int u, int fa){
	siz[u] = 1;
	for(auto t : E[u]){
		int v = t.fi, w = t.se;
		if(v == fa)
		  continue;
		p[v] = w;
		dfs1(v, u);
		siz[u] += siz[v];
	}
}
inline void dfs2(int u, int fa){
	for(auto t : E[u]){
		int v = t.fi;
		if(v == fa)
		  continue;
		int pre = siz[v];
		update(1, siz[v], -1);
		update(1, n - siz[v], 1);
		siz[u] -= siz[v];
		siz[v] = n;
		if(X[1].ans > ans){
			ans = X[1].ans;
			id = v;
		}
		else if(X[1].ans == ans)
		  id = min(id, v);
		dfs2(v, u);
		siz[v] = pre;
		siz[u] = n;
		update(1, n - siz[v], -1);
		update(1, siz[v], 1);
	}
}
int main(){
	n = read();
	for(int u, v, i = 1; i < n; ++i){
		u = read(), v = read();
		add(u, v, i);
	}
	build(1, 1, n);
	dfs1(1, 1);
	for(int i = 2; i <= n; ++i)
	  update(1, siz[i], 1);
	ans = X[1].ans;
	dfs2(1, 1);
	write(2ll * n * ans);
	putchar('\n');
	write(id);
	putchar('\n');
	dfs1(id, id);
	int l = 0;
	for(int i = 1; i <= n; ++i){
		if(i == id)
		  continue;
		A[++l] = {siz[i], p[i]};
	}
	sort(A + 1, A + n);
	for(int i = 1; i < n; ++i)
	  w[A[i].id] = n - i;
	for(int i = 1; i < n; ++i){
		write(w[i]);
		putchar(' ');
	}
	return 0;
}
```

---

## 作者：Colinxu2020 (赞：3)

先考虑枚举必经点 $t$，注意到题目给出的是一个无根树，考虑确定无根树的根，因为有根树上路径长度的公式为 $dis_{i,j}=dep_i+dep_j-dep_{\operatorname{lca}(i,j)} \times 2$，而从 $u$ 到 $v$ 经过必经点 $t$ 的路径长度为 $dist_{i,j}=dis_{i,t}+dis_{t,j}$，带入得到 $dist_{i,j}=dep_i+dep_t-2 \times dep_{\operatorname{lca}(i,t)}+dep_j+dep_t-2 \times dep_{\operatorname{lca}(j,t)}$，这个式子非常复杂，但我们可以发现其中很多项在 $t$ 为根时都为 $0$（尤其是含 $\operatorname{lca}$ 的几项），因此不妨令根为 $t$，原式子变化为 $dist_{i,j}=dep_i+dep_j$，带入题目给出的式子得到得分为 $\sum\sum dep_i+dep_j$，拆贡献可以得到得分为 $2 \times n \times \sum dep_i$，如果你不明白为什么，可以看下面的推导过程：
$$
\sum_{i=1}^n\sum_{j=1}^n dep_i+dep_j=\sum_{i=1}^n\sum_{j=1}^n dep_i+\sum_{i=1}^n\sum_{j=1}^n dep_j=\sum_{i=1}^n\sum_{j=1}^ndep_i+\sum_{j=1}^n\sum_{i=1}^ndep_j\\
=\sum_{i=1}^ndep_j \times \sum_{j=1}^n1+\sum_{j=1}^ndep_j \times \sum_{i=1}^n1=\sum_{i=1}^ndep_i \times n+\sum_{j=1}^ndep_j \times n = 2 \times n \times \sum dep_i
$$




下面给出一些定义：$dep_i$ 为以 $t$ 为根时 $t$ 到 $i$ 的简单路径的边权和，$sz_i$ 为以 $t$ 为根时 $i$ 的子树大小，$w_i$ 为第 $i$ 条边的权值（$w_0=0$），$e_i$ 为连接以 $t$ 为根时 $i$ 与 $i$ 的父亲的边的编号（$e_t=0$），$ans$ 为以 $t$ 为根的答案。

考虑确定边权，因为修改一个边权会影响很多的 $dep_i$，不妨再次对 $dep_i$ 拆贡献到每一条边，可以得到 $\sum dep_i=\sum sz_i \times w_{e_i}$（原因为从 $t$ 到 $i$ 的路径中经过 $e_i$ 这条边的节点恰有 $sz_i$ 个，因此恰好影响 $sz_i$ 个节点），依据这个式子，考虑贪心的赋权值，给 $sz_i$ 最大的节点的 $e_i$ 赋最大的权值，给 $sz_i$ 最小的节点的 $e_i$ 赋最小的权值，为经典贪心模型，可以通过微扰法证明。

已经确定边的权值后，将权值带入，继续转化可以得到 $\sum dep_i = \sum_{i \neq t}rk_{sz_i} \times sz_i$，其中 $rk_i$ 代表 $sz_i$ 是所有的子树大小中第 $rk_i$ 小的。据此可以 $O(N^2)$ 的获得 $30$ 分。

考虑增量的转移 $t$，考虑换根 $dp$，先令 $t=1$ 跑一边深搜，求出每个节点的子树大小和初始答案（排序后按上面的式子计算即可）。考虑换根过程，设原根为 $u$，新根为 $v$，我们要求 $v \in u_{children}$，可以发现换根后 $sz_u \gets sz_u-sz_v, sz_v \gets n$，受影响的子树大小只有 $O(1)$ 个（$2$ 个），修改操作不方便我们维护排名（细节较多，但实际上也可以），把修改拆成插入和删除，转化为插入 $sz_u-sz_v,n$，移除 $n,sz_v$，发现两个 $n$ 抵消了，无需加以考虑，变为插入 $sz_u-sz_v$ 移除 $sz_v$，分析添加一个数 $sz_u-sz_v$ 的影响，发现所有满足 $sz_j \gt sz_u-sz_v$ 的 $j$ 的排名都增加了 $1$，再计算其本身的影响，因此 $ans \gets ans+ \sum_{j} sz_j[sz_j \gt sz_u-sz_v]+(sz_u-sz_v) \times rk_{sz_u-sz_v}$，删除元素是类似的，此处不再赘述。

直接维护这个过程必然超时，考虑数据结构优化，因为我们需要在插入、删除时动态维护一个点的排名，因此考虑平衡树，又因为我们需要实现在平衡树上基于排名的区间求和，所以可以使用 Splay 或是 FHQ-Treap，我这里使用了 FHQ-Treap。

另外的，考虑题目第二问要求字典序最小，考虑到我们仍然需要最大的总得分，而我们又希望边的编号最小的点边权也最小，因此我们认为子树大小一样的节点中编号更小的更小，来让他们在不影响得分的前提下获得一个更小的权值，我们考虑给每个节点的子树大小加权 $e_i$，如果 $sz_i=sz_j$ 且 $e_i \gt e_j$，我们认为 $sz_i \gt sz_j$ 即可。

注意事项：

1. 不要忘记 $\times 2 \times n$；
2. BST 不要忘记初始化总和（我因为这个调了一整天）；
3. 边不要算重；
4. 注意算出一条边属于他的哪个端点，应该选择在 $w_i=1$ 的意义下深度较深的那个。
5. 最后可以再整体 `dfs` 一次，以便输出方案。

参考代码：

```cpp
#include<iostream>
#include<random>
#include<vector>
#include<cassert>
using namespace std;

#define int long long
const int maxn=1e5+10,mod=998244353;
int n,sz[maxn],ans,gans,pos,dep[maxn],anss[maxn];
vector<pair<int,int>> grp[maxn];

random_device rd;
mt19937 myrand(rd());


struct node{
    int val,sz,ls,rs,sum,idx; unsigned pri;
    
    node(){
        sz=pri=ls=rs=val=sum=idx=0;
    }
    node(int v, int id){
        val=sum=v; idx=id;
        pri=myrand();
        sz=1;
        ls=rs=0;
    }
};
struct bst{
    int rt,sz,cnt;
    node tree[maxn*6];

    void pushup(int k){
        tree[k].sz=tree[tree[k].ls].sz+tree[tree[k].rs].sz+1;
        tree[k].sum=tree[tree[k].ls].sum+tree[tree[k].rs].sum+tree[k].val;
        assert(1<=k&&k<=sz);
    }
    
    void split(int cur, int k, int v, int& rt1, int& rt2){
        if(!cur){
            rt1=rt2=0;
            return;
        }
        if(k<tree[cur].val||(k==tree[cur].val&&v<tree[cur].idx)){
            split(tree[cur].ls, k, v, rt1, rt2); 
            tree[cur].ls=rt2;
            pushup(cur);
            rt2=cur;
        }else{	
            split(tree[cur].rs, k, v, rt1, rt2);
            tree[cur].rs=rt1;
            pushup(cur);
            rt1=cur;
        }
    }
    void splitrk(int cur, int k, int& rt1, int& rt2){
        assert(k>=0&&k<=cnt);
        if(!cur){
            rt1=rt2=0;
            return;
        }
        if(k<=tree[tree[cur].ls].sz){
            rt2=cur;
            splitrk(tree[cur].ls, k, rt1, tree[cur].ls); 
            pushup(cur);
        }else{
            rt1=cur;
            splitrk(tree[cur].rs, k-tree[tree[cur].ls].sz-1, tree[cur].rs, rt2);
            pushup(cur);
        }
    }
    int merge(int a, int b){
        if(!a)return b;
        if(!b)return a;	
        assert(a!=b);
        if(tree[a].pri<tree[b].pri){
            tree[a].rs=merge(tree[a].rs, b);
            pushup(a);
            return a;
        }else{
            tree[b].ls=merge(a, tree[b].ls);
            pushup(b);
            return b;
        }
    }
    int rank(int v, int idx){
        int rt1, rt2;
        split(rt, v, idx-1, rt1, rt2);
        int ans=tree[rt1].sz+1;
        rt=merge(rt1, rt2);
        return ans;
    }
    void insert(int v, int idx){
        int rt1, rt2;
        split(rt, v, idx, rt1, rt2);
        tree[++sz]=node(v, idx); ++cnt;
        rt=merge(merge(rt1,sz),rt2);
    }	
    void erase(int v, int idx){
        int rt1,rt2,rt3,rt4;
        split(rt,v,idx,rt1,rt2);
        split(rt1,v,idx-1,rt3,rt4);
        assert(rt4&&tree[rt4].val==v&&tree[rt4].idx==idx);
        rt4=merge(tree[rt4].ls, tree[rt4].rs);
        rt=merge(merge(rt3, rt4), rt2); --cnt;
    }
    
    int qsum(int l, int r){
        int rt1, rt2, rt3, rt4;
        assert(l<=r&&l>=0&&r<=cnt);
        splitrk(rt, r, rt1, rt2);
        splitrk(rt1, l-1, rt3, rt4);
        int ans=tree[rt4].sum;
        rt=merge(merge(rt3, rt4), rt2);
        return ans;
    }
} tr;

void dfs1(int cur, int pa){
    sz[cur]=1; dep[cur]=dep[pa]+1;
    for(auto x:grp[cur])if(x.first!=pa)dfs1(x.first,cur),sz[cur]+=sz[x.first],tr.insert(sz[x.first], x.second);
}
void del(int x, int p){
    ans-=x*tr.rank(x,p);
    if(tr.rank(x,p)<tr.cnt)ans-=tr.qsum(tr.rank(x,p)+1, tr.cnt);
    tr.erase(x,p);
}
void add(int x, int p){
    ans+=x*tr.rank(x,p);
    if(tr.rank(x,p)<=tr.cnt)ans+=tr.qsum(tr.rank(x,p), tr.cnt);
    tr.insert(x,p);
}
int maxx(int x, int y){ return dep[x]>dep[y]?x:y; }
void dfs2(int cur, int pa){
    if(ans>gans||(ans==gans&&cur<pos))gans=ans,pos=cur;
    for(auto e:grp[cur])if(e.second!=pa){
        int v=e.first,x=sz[cur],y=sz[v],z=ans;
        sz[cur]-=sz[v]; sz[v]=n;
                
        del(y, e.second);
        add(sz[cur], pa);
        
        dfs2(v,e.second);
        
        tr.erase(sz[cur], pa);
        tr.insert(y, e.second);
        sz[cur]=x; sz[v]=y; ans=z;
    }
}


signed main(){
    cin>>n;
    for(int i=1;i<n;i++){
        int u,v; cin>>u>>v;
        grp[u].push_back({v,i});
        grp[v].push_back({u,i});
    }
    dfs1(1,0);
    for(int u=1;u<=n;u++)for(auto e:grp[u])if(e.first>u)ans+=sz[maxx(e.first, u)]*tr.rank(sz[maxx(e.first, u)], e.second);
    dfs2(1,0);
    cout<<gans%mod*2*n%mod<<endl<<pos<<endl;
    tr.sz=tr.cnt=tr.rt=0;
    dfs1(pos, 0);
    for(int u=1;u<=n;u++)for(auto e:grp[u])if(e.first>u)anss[e.second]=tr.rank(sz[maxx(e.first, u)], e.second);
    for(int i=1;i<n;i++)cout<<anss[i]<<' '; cout<<endl;
}
```

---

## 作者：qczrz6v4nhp6u (赞：1)

### Solution

考虑以 $t$ 为根。拆贡献，每条边有一个贡献系数，显然可以贪心将大边权分给系数大的边。

考虑一下这个系数是怎么回事。有两种贡献，一种是 ${\rm lca}(u,v)\to t$ 上的边，贡献为 $2$；另一种是 $u\to v$ 上的边，贡献为 $1$。那么一条边 $(x,fa_x)$ 的贡献系数就是 $2\times siz_x^2+2\times siz_x\times(n-siz_x)=2\times n\times siz_x$。

那就是说看谁 $siz_x$ 大给谁多，现在考虑维护。假设我们已经维护了以 $p$ 为根的信息并希望通过边 $(p,q)$ 转移到 $q$，不难发现只有 $siz_p$ 与 $siz_q$ 会发生改变。那么一遍 dfs 再随便上个什么数据结构做就好了。

### Code

```cpp
bool Mst;
#include<bits/stdc++.h>
using namespace std;
using ui=unsigned int;
using ll=long long;
using ull=unsigned long long;
using i128=__int128;
using u128=__uint128_t;
using pii=pair<int,int>;
#define fi first
#define se second
constexpr int N=1e5+5,mod=998244353;
int n;vector<pii> Gr[N];
ll ans;
struct BIT{
	ll c[N];
	inline void upd(int x,ll v){
		for(;x<=n;x+=x&-x)c[x]+=v;
	}
	inline ll ask(int x){
		ll res=0;
		for(;x;x-=x&-x)res+=c[x];
		return res;
	}
};
BIT d0,d1;
inline void modify(int u,int v){
	if(u==v)return;
	ans-=1ll*u*d0.ask(u);
	d0.upd(u,-1);
	d1.upd(u,-u);
	ans+=d1.ask(u)-d1.ask(v);
	d0.upd(v,1);
	d1.upd(v,v);
	ans+=1ll*v*d0.ask(v);
}
int siz[N],w[N];pii tmp[N];
void dfs1(int x,int fa){
	siz[x]=1;
	for(auto &o:Gr[x])
		if(o.fi!=fa)
			w[o.fi]=o.se,dfs1(o.fi,x),siz[x]+=siz[o.fi];
}
pair<ll,int> Ans;
void dfs2(int x,int fa){
	Ans=max(Ans,make_pair(ans,-x));
	for(auto &o:Gr[x])
		if(o.fi!=fa){
			modify(siz[o.fi],n-siz[o.fi]);
			dfs2(o.fi,x);
			modify(n-siz[o.fi],siz[o.fi]);
		}
}
int val[N];
bool Med;
int main(){
	cerr<<abs(&Mst-&Med)/1048576.0<<endl;
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		Gr[u].emplace_back(v,i);
		Gr[v].emplace_back(u,i);
	}
	dfs1(1,0);
	for(int i=1;i<=n;i++)tmp[i]=make_pair(siz[i],w[i]);
	sort(tmp+1,tmp+n+1);
	for(int i=1;i<n;i++){
		ans+=1ll*tmp[i].fi*i;
		d0.upd(tmp[i].fi,1);
		d1.upd(tmp[i].fi,tmp[i].fi);
	}
	dfs2(1,0);
	cout<<Ans.fi%mod*2*n%mod<<'\n'<<-Ans.se<<'\n';
	dfs1(-Ans.se,0);
	for(int i=1;i<=n;i++)tmp[i]=make_pair(siz[i],w[i]);
	sort(tmp+1,tmp+n+1);
	for(int i=1;i<n;i++)val[tmp[i].se]=i;
	for(int i=1;i<n;i++)cout<<val[i]<<" \n"[i==n-1];
	return 0;
}
```

---

## 作者：SamHJD (赞：1)

$u$ 到 $v$ 必须经过 $t$ 的最短路实际就是以 $t$ 为根时 $u,v$ 的带权深度和，于是当 $t$ 和边权均确定时，此时答案为 $2\times n\times \sum dep_u$。统计每条边的贡献，$(u,v)$ 的贡献即为深度较深的点的子树大小乘边权乘 $2n$，所以确定 $t$ 后可以按照 $siz_u$ 排名贪心设定边权，一个点父边的边权即为其子树大小的排名。

考虑用换根去枚举 $t$，变化一次根只会影响 $O(1)$ 个点的子树大小，同时一段 $siz$ 的排名会变化 $1$，后者求出修改位置的排名后可直接将答案减去或加上这一段的 $siz$ 和。排名可用树状数组维护。

```cpp
#include <bits/stdc++.h>
#define int long long
#define rep(i,k,n) for(int i=k;i<=n;++i)
#define per(i,n,k) for(int i=n;i>=k;--i)
using namespace std;
template<typename T>
inline void read(T &x){
    x=0;int f=1;char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c-'0');
    x*=f;
}
template<typename T,typename ...Args>
inline void read(T &x,Args &...rest){read(x);read(rest...);}
const int N=1e5+10,MOD=998244353;
int n,siz[N],now,tmp[N],t,tot,ans,f[N];
namespace BIT{//求排名的
    int t[N];
    int lowbit(int x){return x&-x;}
    void add(int x,int k){if(x==0)return;for(int i=x;i<=n;i+=lowbit(i))t[i]+=k;}
    int sum(int x){int res=0;for(int i=x;i;i-=lowbit(i))res+=t[i];return res;}
}
namespace BIT2{//求siz和的
    int t[N];
    int lowbit(int x){return x&-x;}
    void add(int x,int k){if(x==0)return;for(int i=x;i<=n;i+=lowbit(i))t[i]+=k;}
    int sum(int x){int res=0;for(int i=x;i;i-=lowbit(i))res+=t[i];return res;}
}
vector<int> g[N];
void init(int u,int fa){
    siz[u]=1;f[u]=fa;
    for(auto v:g[u]) if(v!=fa) init(v,u),siz[u]+=siz[v];
}
void del(int x){
    now-=x*BIT::sum(x)+(BIT2::sum(n)-BIT2::sum(x));
    BIT::add(x,-1);BIT2::add(x,-x);
}
void add(int x){
    BIT::add(x,1);BIT2::add(x,x);
    now+=x*BIT::sum(x);
    now+=BIT2::sum(n)-BIT2::sum(x);
}
void dfs(int u,int fa){
    if(ans<now) ans=now,t=u;
    else if(ans==now&&t>u) t=u;
    for(auto v:g[u]){
        if(v==fa) continue;
        int tmpnow=now;
        del(siz[v]);add(n-siz[v]);
        dfs(v,u);
        del(n-siz[v]);add(siz[v]);
        now=tmpnow;
    }
}
vector<pair<int,pair<int,int> > > e;
int cnt[N];
signed main(){
    read(n);tot=0;
    rep(i,1,n-1){
        int u,v;read(u,v);
        g[u].push_back(v);
        g[v].push_back(u);
        e.push_back({u,{v,i}});
    }
    init(1,0);
    rep(i,1,n) tmp[i]=siz[i];
    sort(tmp+1,tmp+n+1);
    rep(i,1,n){
        ans+=tmp[i]*i;
        BIT::add(tmp[i],1);BIT2::add(tmp[i],tmp[i]);
    }
    t=1;ans-=n*n;now=ans;
    dfs(1,0);
    printf("%lld\n",ans%MOD*2ll*n%MOD);
    printf("%lld\n",t);
    init(t,0);
    memset(BIT::t,0,sizeof(BIT::t));
    rep(i,1,n) BIT::add(siz[i],1);
    for(auto E:e){
        int u=E.first,v=E.second.first;
        if(f[v]==u) swap(u,v);
        printf("%lld ",BIT::sum(siz[u]-1)+cnt[siz[u]]+1);
        cnt[siz[u]]++;
    }
    return 0;
}
```

---

## 作者：jiangyixuan_eason (赞：0)

设 $t$ 为根，那两点之间的距离就是 $dep$ 的和。根据上述内容，发现每条边经过的次数就是以 $t$ 为根，较深点子树的大小乘上 $2n$ 。这样就实现了固定 $t$ 。因为我们固定了 $t$ ，所以根据交换不等式很明显是按 $siz$ 排序，然后就按升序赋 $1$ 到 $n$ 的权就行了。也就是假设我们知道了 $t$ 就可以随便构造了。

说了这么多，大家应该明白，只要知道了只要求出了 $\sum isiz_{i}^{′}$ 最大的 $t$ ，这道题基本就做完了。

可以考虑换根。发现如果从上面一个点挪下去当新根，那么 $\left \{siz_i \right \}$ 就是在加一个数删一个数。

明白了这些，就可以用权值线段树维护，然后就结束了。

---

## 作者：Erine (赞：0)

赛时懒得写，现在也懒得写。不写了。

这个什么 $t$ 看起来很扯淡啊，你不妨 $t$ 为根，那么两个点距离直接就是 $dep$ 之和。

所以每条边被经过的次数是以 $t$ 为根，较深点子树大小 $\times 2n$。

那么固定了 $t$ 之后根据交换不等式显然是按 $siz$ 排序，然后从小往大赋 $1\sim n$ 的权。

也就是假设我们知道了最终的 $t$，就可以随便构造。

怎么知道使得 $\sum isiz'_i$ 最大的 $t$ 呢？考虑换根，发现从上面一个点挪下去当新根，呃这个 $\{siz_i\}$ 不过也就是在加一个数删一个数。

然后权值线段树就可以瞎维护了，对吧、这题就做完了，线对。

---


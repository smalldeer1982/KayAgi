# Gty的妹子树

## 题目背景

我曾在弦歌之中听过你，


檀板声碎，半出折子戏。


舞榭歌台被风吹去，


岁月深处尚有余音一缕……



Gty 神(xian)犇(chong)从来不缺妹子……


他来到了一棵妹子树下，发现每个妹子有一个美丽度……


由于Gty很哲♂学，他只对美丽度大于某个值的妹子感兴趣。


他想知道某个子树中美丽度大于 $k$ 的妹子个数。


某个妹子的美丽度可能发生变化……


树上可能会出现一只新的妹子……


## 题目描述

维护一棵初始有 $n$ 个节点的有根树（根节点为 $1$），树上节点编号为 $1 \sim n$，每个点有一个权值 $w_i$。


支持以下操作：

- `0 u x` 询问以 $u$ 为根的子树中，严格大于 $x$ 的值的个数。

- `1 u x`  把 $u$ 节点的权值改成 $x$。

- `2 u x`  添加一个编号为“当前树中节点数+1”的节点，其父节点为 $u$，其权值为 $x$。

**本题强制在线。**   
所有输入的 $u,x$ 都需要异或 $\text{last}$ 才是真正的输入。   
其中 $\text{last}$ 为上一次询问的答案，定义初始 $\text{last} = 0$。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n,m \le 30000$，$1\le u \le n$，$0 \le w_i,x < 2^{31}$。


## 样例 #1

### 输入

```
2
1 2
10 20
1
0 1 5
```

### 输出

```
2
```

## 样例 #2

### 输入

```
2
1 2
10 20
1
0 1 10
```

### 输出

```
1
```

# 题解

## 作者：Parabola (赞：20)

### Part0.题外话

总算搞出来这一道题了

从上午8:30做到下午2:30

饭都没吃

累死我了

~~不过想到明天能去买轻小说就敲开心~~

这篇题解是一边做饭一边写出来的

另外，窝的做法是目前(2019/2/15)所有题解内中最优复杂度

不知道还有没有神仙能够更快

### Part1.前置知识

分块、分块、还有分块

好吧其实还有一个并查集

### Part2.BB了那么久总算开始了

首先这一题的所谓「树分块」的做法是错误的，可以被菊花图卡掉

所以要换种方法分块

回答一个询问，就是把初始答案与每一个操作带来的影响所整合起来

到这一题上，假设窝们对于初始那棵树（没执行过任何一次修改操作的）进行一次dfs算出dfs序后

树上问题就成了序列问题

那么以$u$为根的子树所对应的区间就是$[dfn[u] , dfn[u] + sz[u] - 1]$

(dfn代表dfs序）

所以可以拿个数据结构来维护初始树

记`T1`为这个数据结构的单次查询复杂度，`T2`为构造复杂度

那接下来窝们只需要回答每一个修改操作对询问操作的影响了

第一个问题 **操作1如何影响询问**

操作1是一个点权修改

那它想影响一个询问，必须是修改这个子树里的点权

操作2是一个建一个新的子节点，他只需要在这棵子树里建的就会影响了

综上，我们现在得到的思路是这样的

先用一个数据结构维护初始状态，接着对于每一个询问，扫一次它前面所有的修改操作，如果发现能够影响答案，那就将答案改变

但这样复杂度是不对的，因为这和暴力没什么区别

要不我们每`T`次操作之后，将初始状态提前一次？

你可能没有理解这句话，就是说每`T`次操作之后，我们把执行T次操作得到的新树作为新的初始状态

换句话来说，每`T`次操作，重新dfs+建数据结构一次

这个时候你就发现，每一次询问往后面扫的不是`M`次了，而是`M/T`次

你很聪明知道`T`应该取 $\sqrt{M}$

综上，我们要实现的操作只剩下两个了

1.写一个数据结构能够维护区间rank（就是区间$[l,r]$有多少个比$c$大）

2.判断一个点是否在一个子树中

看到1窝们就想到主席树，2的话因为有修改，我们可以用倍增

$O(N * \log N * \sqrt{M})$，但是这样不是最优的

瓶颈在于倍增与主席树的构造上

主席树构造时间复杂度是$O(N * \log N)$，一共要暴力构造$\sqrt{M}$次。时间复杂度$O(N * \log N * \sqrt{M})$

由于对于每一个询问操作我们都要往前扫$\sqrt{M}$个修改并且每个修改花$\log N$的时间倍增，最后再加上一个主席树$\log N$查询。

每一次询问的复杂度是$O(\log N * \sqrt{M} + \log N)$

总复杂度 $O(M * (\log N * \sqrt{M} + \log N))$

极大的复杂度不平衡。

为什么一定要倍增呢？

路径压缩难道忘了吗？

均摊复杂度分析难道忘了吗？

我们将倍增换成加了路径压缩的暴力，再配合一下欧拉序

均摊分析一下复杂度

不就成了$O(M * \sqrt{N})$了吗

再把主席树换成一个块内维护有序的分块，构造时间为$O(N * \log{\sqrt{N}})$

总复杂度为$O(N * \sqrt{M} * \log{\sqrt{N}})$

还有许多小细节，可以看看代码

### Part3. Code

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<vector>
#include<cstring>
using namespace std;

const int MAXN = 60000 + 5;

vector <int> G[MAXN];

int n , m , num , f[MAXN] , sz[MAXN] , val[MAXN] , dfn[MAXN] , tp[MAXN];
int real_node , all_node;

namespace DFS{
    int dfs_clock , st[MAXN] , ed[MAXN];
    void dfs(int u , int fa) {
        sz[u] = 1 , f[u] = fa , dfn[u] = num++ , st[u] = ++dfs_clock; 
        for(int i = 0 , v ; i < (int)G[u].size() ; ++i) {
            if((v = G[u][i]) == fa) continue;
            dfs(v , u);
            sz[u] += sz[v];
        }
        ed[u] = ++dfs_clock;
    }
    inline bool check(int u , int v) { //节点v是否在以u为根的子树中 
        return st[u] <= st[v] && ed[v] <= ed[u];
    }
    void rebuild() {
        num = dfs_clock = 0;
        dfs(1 , 0);
    }
} 

namespace BLOCK{
    int SIZE , j , cnt , A[MAXN] , b[MAXN] , ord[MAXN / 100][MAXN / 100];
    void rebuild() {
        for(int i = 0 ; i < cnt ; ++i) memset(ord[i] , 0 , sizeof ord[i]);
        memset(ord[cnt] , 0 , sizeof ord[cnt]);
        SIZE = (int)sqrt(all_node + 0.5);
        j = 0 , cnt = 0;
        for(int i = 1 ; i <= all_node ; ++i) A[dfn[i]] = val[i];
        for(int i = 0 ; i < all_node ; ++i) {
            if(j == SIZE) j = 0 , ++cnt; 
            ord[cnt][j] = A[i] , b[i] = cnt;
            ++j;
        }
        for(int i = 0 ; i < cnt ; ++i) sort(ord[i] , ord[i] + SIZE);
        sort(ord[cnt] , ord[cnt] + j);
    }
    int query(int l , int r , int c) {
        int lb = b[l] , rb = b[r] , res = 0;
        if(lb == rb) {
            for(int i = l ; i <= r ; ++i) if(A[i] > c) ++res;
            return res;
        }
        for(int i = l ; i < (lb + 1) * SIZE ; ++i) if(A[i] > c) ++res;
        for(int i = rb * SIZE ; i <= r ; ++i) if(A[i] > c) ++res;
        for(int i = lb + 1 ; i < rb ; ++i) res += ord[i] + SIZE - upper_bound(ord[i] , ord[i] + SIZE , c);
        return res;
    }
}

struct Node{
    int opt , u , x , lst;
    Node(int opt = 0 , int u = 0 , int x = 0 , int lst = 0) : opt(opt) , u(u) , x(x) , lst(lst) {}
};
vector <Node> v;

inline int real(int u) {return u <= real_node;} 
inline int Get(int v) {
    if(real(f[v])) return f[v];
    return tp[v] = Get(f[v]);
}
inline bool check(int u , int v) {
    if(real(u) ^ real(v)) {
        if(real(v) == 1) return false;
        if(!tp[v]) tp[v] = Get(v);
        return DFS::check(u , tp[v]);
    }
    else {
        if(real(u) == 1) return DFS::check(u , v);
        while(!real(f[v])) {
            if(v == u) return true;
            v = f[v];
        }
        return v == u;
    }
}

int main() {
    int last_ans = 0;
    scanf("%d" , &n);
    for(int i = 1 , u , vv ; i < n ; ++i) {
        scanf("%d %d" , &u , &vv);
        G[u].push_back(vv); G[vv].push_back(u);
    }
    for(int i = 1 ; i <= n ; ++i) scanf("%d" , val + i);
    real_node = all_node = n;
    DFS::rebuild();
    BLOCK::rebuild();
    scanf("%d" , &m);int SIZE = (int)sqrt(m + 0.5) + 1 , j = 0;
    while(m--) {
        int opt , u , x;
        scanf("%d %d %d" , &opt , &u , &x);
        if(j == SIZE) {
            memset(tp , 0 , sizeof tp);
            for(int i = 0 ; i < (int)v.size() ; ++i) 
                if(v[i].opt == 2) G[v[i].lst].push_back(++real_node);
            DFS::rebuild(); BLOCK::rebuild();
            v.clear();
            j = 0;
        }
        u ^= last_ans , x ^= last_ans;
        if(opt == 0) {
            int ans = BLOCK::query(dfn[u] , dfn[u] + sz[u] - 1 , x);
            for(int i = 0 ; i < (int)v.size() ; ++i) {
                if(check(u , v[i].u)) {
                    if(v[i].opt == 1) {
                        if(v[i].lst > x && v[i].x <= x) --ans;
                        if(v[i].lst <= x && v[i].x > x) ++ans;
                    }
                    if(v[i].opt == 2)
                        ans += v[i].x > x;
                }
            }
            printf("%d\n" ,	last_ans = ans); 
        }
        else if(opt == 1) {
            v.push_back(Node(opt , u , x , val[u]));
            val[u] = x;
        }
        else {
            v.push_back(Node(opt , ++all_node , x , u));
            val[all_node] = x; f[all_node] = u;
        }
        ++j;
    }
    return 0;
} 
```

---

## 作者：Haishu (赞：16)

### 正确的树分块做法
这是一种本题对所有树都适用的树分块做法。
___
### 前置：优化思路
树分块的瓶颈在于，当树为菊花图时，访问的联通块比较多。本质上说，单次询问访问了许多边，个数为$O(n)$。

所以想办法使得不再访问那么多边。
### 正题：做法
我们对原树进行分块，一定要保证是块内连通，设块的大小为$O(S)$。

我们再建一棵树，这棵树是原树边集为原边集去掉连接块与块之间的边，剩下的边。也就是说，原树形成了森林，每一棵树就是一个块。我们可以叫它“块森林”。

我们定义连接块与块之间的边称为**虚边**，块内的边称为**实边**。以1为根后，原树就有了父子关系。定义如果一个点的儿子与其之间的边为虚边，那么这个儿子叫**虚儿子**，否则叫**实儿子**。就像这样。

![](https://cdn.luogu.com.cn/upload/image_hosting/t99i4gs0.png)

接下来，我们在每个点$x$都挂一个可重集合$Set(x)$。集合内保存的是该点**所有虚子树中所有节点的权值**。

- 对于点1，$Set(1)=\{value[7]\}$.
- 对于点2，$Set(2)=\{value[4],value[5],value[6]\}$.

我们定义$fa[x]$表示x的原树的父亲节点，$top[x]$表示x所在块内的深度最小的点（显然唯一）。$size[x]$表示编号为x的节点所在块的节点数量。我们接下来要频繁用到它们。

至于分块的方式，我使用的是bfs分块（证明处介绍），尚不明确是否所有块内联通式分块均能保证复杂度。

**至此，数据结构部分完结，下面开始讲具体要如何操作。**

注：块的大小为S，读入u，x。
- 操作2：加入一个节点u，令其权值为x

如果$fa[u]$的块的大小$size[fa[u]]\leq S-1$,那么我们将u并入$fa[u]$所在的块.如果$fa[u]$的块的大小$size[fa[u]]= S$,那么我们将u单独分一块.这很显然,就是普通树分块的方法.

得到新节点的块归属之后，接下来是这段操作，也是最为关键的操作，请读者仔细理解。
```cpp
int data=value[u];
while (true) {
	u=fa[top[u]];
	if (u) set[u].insert(data);
	else break;
}
```
它表示的意思是，对于u，其到根路径上会经过一些块的内部。对于每一个经过的块，我们将它在这条路径上深度最深的节点所在的可重集合中插入u的权值。

![](https://cdn.luogu.com.cn/upload/image_hosting/e8ohn3i9.png)

有什么作用呢？即将呈现。

- 操作0：询问节点u子树内权值大于x的节点个数

我们遍历**u所在的块内且在u子树内的点**。对于遍历到的每一个点v，我们在v的可重集合内（也就是一颗平衡树中）查到权值大于x的节点个数，再根据v自身的权值是否大于x决定答案要不要再加上1。对于遍历到的每一个点利用上句方法算出的答案求和即为操作（0，u，x）的答案。

![](https://cdn.luogu.com.cn/upload/image_hosting/wp3i0c20.png)

我们先前定义过：

>我们在每个点$x$都挂一个可重集合$Set(x)$。集合内保存的是该点**所有虚子树中所有节点的权值**。

是不是一目了然了？我们不再需要去扫描每一个节点的虚子树，而是在原树基础上新建的“块森林”中的那棵块树上dfs统计答案。

- 操作1：修改权值

联想刚才的操作2，这里会变得十分简单。
```cpp
//操作(1,u,x)
int data=value[u];
while (true) {
	u=fa[top[u]];
	if (u) set[u].delete(data),set[u].insert(x);
	else break;
}
```
做完了。

### 最为重要的部分：时空复杂度与证明
设块的大小为$S$且始终为定值，节点总数$n$可能随着操作而变化，但是定格在每个时刻$n$肯定是不变的。

- “bfs”分块


我自己口胡的方法和名字，未上网考证是否已出现过。
具体是这样做：我们先从一棵树的根开始bfs，选前$S$个点，然后将它们删掉，这棵树树裂变成森林。再对森林从每一颗树的根重复以上操作。

- 引理1：bfs分块后，对于一条虚边，其上端父亲节点所在的块大小必为$S$。

根据刚才的分块方式，假设虚边上端父亲节点所在块的大小小于$S$，那么这条虚边下端儿子节点定然会在初始分块时或操作进行时分给其父亲所在的块，故这条边是实边，与假设不符。

- 定理1：bfs分块后，操作1与操作2的while循环次数不超过$\left\lfloor\dfrac{n}{S}\right\rfloor$。

这也许是一个重要性质。具体地说，虽然无法保证块的总数为$O(\frac{n}{S})$，但是可以保证任意一个节点到根的路径上仅仅会经过最多$\left\lceil\dfrac{n}{S}\right\rceil$个块，其中当前节点$x$所在的块大小为$0\lt size[x] \leq S$，其余的块的大小为$S$。

证明如下：假设对于一个点，其到根路径上存在块的数量$M\geq \left\lceil\dfrac{n}{S}\right\rceil+1$，则存在虚边条数至少为$\left\lceil\dfrac{n}{S}\right\rceil$。根据引理1，至少存在$\left\lceil\dfrac{n}{S}\right\rceil$个大小为S的块。去掉这$\left\lceil\dfrac{n}{S}\right\rceil$个大小为S的块，剩余块数$M - \left\lceil\dfrac{n}{S}\right\rceil \geq 1$,则剩余的节点总数$X\gt 0$。则此时至少存在$\left\lceil\dfrac{n}{S}\right\rceil\times S+X \geq n+X \gt n$个节点。而此时节点数量先前被设为$n$，故假设不成立。再根据代码，循环次数为$M-1\leq\left\lceil\dfrac{n}{S}\right\rceil-1 \leq \left\lfloor\dfrac{n}{S}\right\rfloor$，所以即定理1成立。

- 定理2：设本题的节点总数为$N=O(n+m)$，本题可以在时间复杂度为$O(N\sqrt{N}\;logN)$以及空间复杂度为$O(N\sqrt{N})$下完成。

证明：首先是时间复杂度。根据定理1，每个节点的权值会被插入$O(\dfrac{N}{S})$次，插入及查询区间内权值个数可用平衡树实现。单次询问时间复杂度为$O(SlogN)$，插入的时间复杂度为$O(\dfrac{N}{S}logN)$。

然后是空间复杂度。由于插入$O(\dfrac{N}{S})$次，平衡树空间复杂度为$O(N)$，故空间复杂度$O(\dfrac{N^2}{S})$。

当取$S=\sqrt{N}$时，定理2成立。
___
**总结**

《Gty的妹子树》中，普通的树分块算法已经基本被宣告完蛋。但是我们如果尝试优化其短处，并尝试继续抢救，也许会发现许多新的道理与思路。

新人第一次写证明，有问题还请大家指出。特别鸣谢[双管荧光灯](https://www.luogu.com.cn/user/13185)WCAu巨佬提供定理1的证明思路的方向。希望有大佬能够给出任意的块内联通式树分块能否保证复杂度的判断和证明。

~~[代码呢？？？](https://www.cnblogs.com/Algebra-hy/p/12177281.html)~~

---

## 作者：Mr_Spade (赞：11)

为什么这道题没有题解啊，那不如我来贡献一发吧。

做完之后去网上搜了一下其它做法，发现居然要树分块，这不是超麻烦的吗。所以我们可以考虑另一种分块方法：对**时间**分块。

对时间分治是需要离线的，但是对时间分块是可以在线的。

我们先可以考虑静态的情况，如果这道题是静态的询问，那么我们只要根据dfs序列建一棵归并树(线段树的一种，每个节点保存这个区间的权值排序过以后的序列)，再进行区间查询就可以了。

那么如果在查询之前进行过若干次修改的话，我们可以暴力扫描一遍这些修改，对查询的答案计算贡献。分两种修改讨论：

如果是修改点权，我们只要先查询这个点是否在被查询的点的子树内，再查询它的修改对答案是否有影响就可以了。

如果是添加一个点，也是类似的，查询是否在这棵子树内以及是否对答案有影响即可。

那么如何查询一个点是否在被查询点的子树内呢？我们可以在添加点的时候预先进行倍增处理这个点向上跳$2^i$层的祖先，这样只要用倍增数组往上跳就可以查询了。

综合一下之前的讨论，如果我们在查询之前的修改不超过$\sqrt m$次时，就在归并树上查询后暴力扫描修改计算贡献；如果修改超过了$\sqrt m$次时，我们只要根据修改重建一下归并树就可以清除掉这些修改，可以发现归并树的重建不会超过$\sqrt m$次。

来分析一下复杂度，为了省事我们把$n$和$m$看成是同阶的，瓶颈显然在暴力扫描计算贡献和归并树的重建上，计算贡献时，最多扫描$O(\sqrt n)$次修改，每次需要$O(\log n)$的复杂度(倍增)，所以这部分的复杂度是$O(n\sqrt n \log n)$。而重建归并树每次是$O(n\log n)$的，一共$O(\sqrt n)$次，因此这部分的复杂度也是$O(n\sqrt n \log n)$。

因此复杂度是$O(n\sqrt n \log n)$，通过了这道题。

细节可以参考代码注释

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<vector>
using std::upper_bound;
using std::merge;
using std::vector;
inline int read()
{
	int res=0;
	char x;
	while((x=getchar())<'0'||x>'9');
	for(;x>='0'&&x<='9';x=getchar())
		res=res*10+x-'0';
	return res;
}
inline void write(int x)
{
	if(x>=10)
		write(x/10);
	putchar(x%10+'0');
	return;
}
const int N=1e5+5,LGN=25;
int n,m,unit,tot,idx,lastans;
int w[N],wi[N],id[N],deep[N],size[N];
int p[N][LGN];//倍增数组
int v[N<<1],first[N],next[N<<1];
struct cell
{
	int opt,u,x,y;
};
vector<cell> V;
struct node
{
	int l,r;
	vector<int> V;
}sgt[N<<2];
void build(int now,int l,int r)//构建归并树
{
	sgt[now].l=l;sgt[now].r=r;
	sgt[now].V.clear();
	if(l==r)
	{
		sgt[now].V.push_back(wi[l]);
		return;
	}
	int mid=(l+r)>>1;
	build(now<<1,l,mid);
	build(now<<1|1,mid+1,r);
	sgt[now].V.resize(r-l+1);
	merge(sgt[now<<1].V.begin(),sgt[now<<1].V.end(),sgt[now<<1|1].V.begin(),sgt[now<<1|1].V.end(),sgt[now].V.begin());
	return;
}
int query(int now,int l,int r,int k)//查询
{
	if(sgt[now].l>r||sgt[now].r<l)
		return 0;
	if(sgt[now].l>=l&&sgt[now].r<=r)
		return sgt[now].V.end()-upper_bound(sgt[now].V.begin(),sgt[now].V.end(),k);
	return query(now<<1,l,r,k)+query(now<<1|1,l,r,k);
}
inline void add_edge(int from,int to)
{
	tot+=2;
	v[tot+1]=from;v[tot]=to;
	next[tot]=first[from];first[from]=tot;
	next[tot+1]=first[to];first[to]=tot+1;
	return;
}
void dfs(int now,int father)//dfs，用于在重建归并树之前更新一些数据
{
	register int go;
	id[now]=++idx;size[now]=1;
	wi[id[now]]=w[now];/*这个是为了方便建归并树*/p[now][0]=father;
	for(go=first[now];go;go=next[go])
		if(v[go]!=father)
		{
			deep[v[go]]=deep[now]+1;
			dfs(v[go],now);
			size[now]+=size[v[go]];
		}
	return;
}
inline bool anc(int u,int v)//查询v是否在u的子树内
{
	int res=v;
	register int i;
	if(deep[v]<deep[u])
		return 0;
	for(i=20;~i;i--)
		if((deep[v]-deep[u])>>i&1)
			res=p[res][i];
	return res==u;
}
inline void rebuild()//更新并重建
{
	V.clear();
	idx=0;dfs(1,0);
	build(1,1,n);
	return;
}
signed main()
{
	int from,to;
	int u,x,res;
	register int i,j;
	n=read();
	for(i=1;i<=n-1;i++)
	{
		from=read();to=read();
		add_edge(from,to);
	}
	for(i=1;i<=n;i++)
		w[i]=read();
	idx=0;dfs(1,0);
	for(i=1;i<=n;i++)
		for(j=1;j<=20;j++)
			p[i][j]=p[p[i][j-1]][j-1];
	build(1,1,n);
	m=read();unit=ceil(sqrt(m)*5);//块大小
	while(m--)
		switch(read())
		{
			case 0:
				u=read()^lastans;x=read()^lastans;
				res=query(1,id[u],id[u]+size[u]-1,x);
				for(i=0;i<(int)V.size();i++)
					if(V[i].opt==1)
					{
						if(((V[i].x>x)^(V[i].y>x))&&anc(u,V[i].u))
							res+=(V[i].y>x)?1:-1;
					}
					else
					{
						if((V[i].y>x)&&anc(u,V[i].u))
							res++;
					}
				write(lastans=res);putchar('\n');
				break;
			case 1:
				u=read()^lastans;x=read()^lastans;
				V.push_back(cell{1,u,w[u],x});w[u]=x;
				if((int)V.size()>=unit)
					rebuild();
				break;
			case 2:
				u=read()^lastans;x=read()^lastans;
				V.push_back(cell{2,n+1,u,x});
				add_edge(u,++n);
				w[n]=x;deep[n]=deep[u]+1;
				p[n][0]=u;
				for(i=1;i<=20;i++)
					p[n][i]=p[p[n][i-1]][i-1];
				if((int)V.size()>=unit)
					rebuild();
				break;
		}
	return 0;
}
```

---

## 作者：command_block (赞：7)

这道题细节巨多，然而数据很魔性（几个最大的点没有1,2操作），导致主席树+暴力能过，希望有大佬吧数据多造几个……

不得不说这道题还是挺经典的。

首先，不考虑1,2操作，如果只有询问的话，这道题就是一个十分simple的dfs序主席树。

如果您无法完成上述操作，建议看看这两道题：

[P3834 【模板】可持久化线段树 1（主席树）](https://www.luogu.org/problemnew/show/P3834)

[P2633 Count on a tree](https://www.luogu.org/problemnew/show/P2633)

接下来考虑加上操作1,2，一个很naive的想法就是：每次暴力重构主席树。

但这样肯定不划算，我们考虑把一些操作暂存起来，先不重构。

但问题在于我们还得回答询问，我们可以计算这些修改对询问的贡献（至于怎么算请见代码）。

具体方法是：先判断是否满足权值限制，再判断是否在子树内。

如果积压的修改过多则重构。

说起来简单，写起来还是有很多细节：

- 为了卡常数采用了离散化，要分清离散化前后的值。

- 该清零的别忘记

- 可能修改还在积压中的新节点的值

- 同一个节点修改两次

总的来说，这道题囊括了{时间分块思想，dfs序，主席树，倍增求父}等知识，还是勉强算作码农题……

~~码风极端不良，代码仅供参考~~

```cpp
#include<algorithm>
#include<cstdio>
#include<vector>
#define MaxN 60500
using namespace std;
inline int read()
{
  register int X=0;
  register char ch=0;
  while(ch<48||ch>57)ch=getchar();
  while(ch>=48&&ch<=57)X=X*10+(ch^48),ch=getchar();
  return X;
}
int n,m,w[MaxN];
vector<int> g[MaxN];
struct Node
{int l,r,c;}a[MaxN*20];
int tn,to,rt[MaxN];
inline void up(int num)
{a[num].c=a[a[num].l].c+a[a[num].r].c;}
void add(int l,int r,int num)
{
  if(l==r){a[++tn].c=a[num].c+1;return ;}
  int mid=(l+r)>>1;
  if (to<=mid){
    add(l,mid,a[num].l);
    tn++;a[tn].r=a[num].r;a[tn].l=tn-1;
  }else {
    add(mid+1,r,a[num].r);
    tn++;a[tn].l=a[num].l;a[tn].r=tn-1;
  }up(tn);
}
int wfl;
int query(int l,int r,int num1,int num2)
{
  if (wfl<=l)return a[num2].c-a[num1].c;
  int mid=(l+r)>>1;
  if (wfl<=mid)
   return a[a[num2].r].c-a[a[num1].r].c
         +query(l,mid,a[num1].l,a[num2].l);
  return query(mid+1,r,a[num1].r,a[num2].r);
}
int in[MaxN],out[MaxN],tim,b[MaxN];
int dis[MaxN],f[MaxN][17];
void dfs(int num,int fa)
{
  f[num][0]=fa;
  for (int j=1;j<=15;j++)
   f[num][j]=f[f[num][j-1]][j-1];
  b[in[num]=++tim]=w[num];
  for (int i=0;i<g[num].size();i++)
   if (g[num][i]!=fa){
   	 dis[g[num][i]]=dis[num]+1;
     dfs(g[num][i],num);
   }
  out[num]=tim;
}
struct Data
{int pos,x;}
t[MaxN];
int lastn,tot;
int xx[MaxN];
void build()
{
  for (int i=1;i<=lastn;i++)w[i]=xx[w[i]];
  //这里要还原 
  for (int i=1;i<=tot;i++)
   w[t[i].pos]=t[i].x;
  tot=0;
  for (int i=1;i<=n;i++)xx[i]=w[i];
  sort(xx+1,xx+n+1);
  for (int i=1;i<=n;i++)
   w[i]=lower_bound(xx+1,xx+n+1,w[i])-xx;
  for (int i=1;i<=tn;i++)
    a[i]=(Node){0,0,0};
  tn=tim=0;//该清零的别忘记 
  dfs(1,0);
  for (int i=1;i<=n;i++)
   {to=b[i];add(1,n,rt[i-1]);rt[i]=tn;}
  lastn=n;
}
bool snt(int x,int y)
{
  int dep=dis[y]-dis[x];
  if (dep<0)return 0;
  int k=15;
  while(k>-1){
  	while(dep>=(1<<k)){
      dep-=(1<<k);
      y=f[y][k];
  	}k--;
  }return y==x;
}
int lastans;
int main()
{
  n=read();
  xx[0]=0;dis[0]=-1;
  for (int i=1,f,t;i<n;i++){
  	f=read();t=read();
  	g[f].push_back(t);
    g[t].push_back(f);
  }for (int i=1;i<=n;i++)w[i]=read();
  build();
  m=read();
  for (int i=1,u,x,op;i<=m;i++){
  	op=read();u=read()^lastans;x=read()^lastans;
  	if (op==0){
  	  int ans=0;
  	  wfl=upper_bound(xx,xx+lastn+1,x)-xx;
  	  if (u<=lastn)
        ans=query(1,lastn,rt[in[u]-1],rt[out[u]]);
  	  for (int i=lastn+1;i<=n;i++)
  	    if (w[i]>x&&snt(u,i))ans++;
	  for (int i=1,p;i<=tot;i++){
  	  	p=t[i].pos;
  	  	if (in[u]<=in[p]&&out[p]<=out[u])
  	  	  if (t[i].x<=x&&w[p]>=wfl)ans--;
  	  	  else if (t[i].x>x&&w[p]<wfl)ans++;
  	  	  //注意这里的wfl 
  	  }printf("%d\n",lastans=ans);
  	}if (op==1){
  	  if (u>lastn)w[u]=x;//这里要注意 
  	  else {
  	  	bool flag=0;
		for (int j=1;j<=tot;j++)
  	  	 if (t[j].pos==u)
  	  	  {t[j].x=x;flag=1;break;}
  	  	//这里也要注意 
  	    if (!flag)t[++tot]=(Data){u,x};
  	  }
  	}if (op==2){
  	  g[u].push_back(++n);
      g[n].push_back(u);
  	  f[n][0]=u;
      for (int j=1;j<=15;j++)
        f[n][j]=f[f[n][j-1]][j-1];
      w[n]=x;
      dis[n]=dis[u]+1;
  	}if (tot+(n-lastn)*20>=10000)build();
  }return 0;
}
```

---

## 作者：namespace_std (赞：6)

翻了一下题解区发现好像没有块状链表的题解...那我就写一发吧。

记分块大小为 $T$ ，不妨令 $n,m$ 同级，此算法的时间复杂度为

- 询问： $O(\frac{N}{T}\log_2n+\log_2^2n) $ 。
- 增加节点： $O(\log_2n+T)$ 。
- 修改权值： $O(T)$ 。

在 $T$ 取 $\sqrt{n\log_2n}$ 时有最优时间复杂度 $O(n(\sqrt{n\log_2n}+\log^2n))$ 。

空间复杂度为 $O(n\log_2n)$。

接下来进入正题。

####  块状链表

- 定义

块状链表，通俗地说，就是一种结合了分块和链表两种数据结构优势的数据结构。

它可以做到 $O(\sqrt{n})$ 在任意位置 插入/删除 元素、$O(\sqrt{n})$ （或者 $O(1)$） 定位一个元素、以及维护当前序列上的一些东西。

- 实现

> 链表结构（本题）
> 
> `int pii::p` 值域为 $[1,...,sz]$ ，表示块内的 $dfs$ 序。
> 
> `int pii::v` $p$ 对应的节点的权值。
> 
> `int pii::Id` $p$ 对应的节点在原树上的标号。
> 
> `pii v[][]` 用来存储每个块的信息。（不要跟上文的 $v$ 弄混！）
> 
> `int sz[]` 每个块的 $ size$ 。
> 
> `int Nx[]` 表示某一个块在 $ dfs$ 序上的后继，为0表示是最后一个块。
> 
> `int Las[]` 记录一个块内 $ dfn$ 最大的节点。
> 
> `int bel[]` 记录一个树上的节点所属的块标号。
> 
> 对于这道题而言，我们可以随时保证块中所有 `pii` 的权值 $v$ 单调递增，方法参见下文。

> `void split(x)`（核心操作）
> 
> 目的：将块 $x$ 分裂成两块。
> 
> 开一个新块，记其为 $New$ ，然后修改 $Nx[New]=Nx[x],Nx[x]=New$。
> 
> 记 $mid=sz[x]/2$ 。
> 
> 将 $v[x][i]$ 中 $p$ 值大于 $mid$ 的减去 $mid$ ，并分到新块中。
> 
> 重计算受影响的 $sz[]$ 、 $Las[]$ 和 $bel[]$ 。
> 
> 由于原本 $v[x][i]$ 的权值就单调递增，分裂为两个子序列，均匀分配给两个块之后也一定满足单调性。

```cpp
void split(int x)
{
	Nx[++total]=Nx[x],Nx[x]=total;
	int spl=sz[x]>>1;
	Las[total]=Las[x];
	register int i,p=0;
	for(i=1;i<=sz[x];i++)
	{
		pii t=v[x][i];
		if(t.p==spl)Las[x]=t.Id;
		if(t.p>spl)t.p-=spl,v[total][++sz[total]]=t,bel[t.Id]=total;
		else v[x][++p]=t;
	}sz[x]=p;
}
```

回到这题上，我们发现我们的每个询问是在树的dfs序上，因此就比较适合用块状链表维护。

1. 如何处理询问？

我们随时保证每个块内的结构体的权值单调递增，这样询问一个整块时就可以在 $O(\log_2n)$ 使用 二分/upper_bound 求出解。

显而易见的是，通过 $bel$ 数组，我们能快速定位询问的左端点（因为询问的区间左端点就是询问点所在位置）。

我们发现，我们接下来能通过判断一个块的 $ Las $ 是否在询问点的子树内，来 $O(\frac{n}{T}\log_2n)$ 求出询问区间的右端点在哪个块上。

由于新建一个节点，不会影响其他点的 $fa$ ，所以可以倍增维护每个点的 $2^k$ 级 $fa$ 从而在 $O(\log_2n)$ 时间内判断一个点是否在另一个点的子树中。

对于两侧的散块，直接暴力计算贡献是 $O(T\log_2n)$的，复杂度将退化到 $O((\frac{n}{T}+T)\log_2n) = O(\sqrt{n}\log_2n)$。

考虑优化这个算法。

我们发现，散块中在询问点子树内的点一定在 $dfs$ 序上是连续的一段，并且你已经知道了这些散块在询问点子树内的点的左端点。（如果询问左端点和右端点在同一个块内，那么左端点就是询问的左端点，否则左端点显然是 $dfs$ 序最小的节点）

因此，我们就可以进行~~令人感到愉悦的~~二分。

二分右端点，复杂度降到了 $O(\log_2^2n)$ 。

此时，我们成功把询问复杂度优化到了  $O(\frac{n}{T}\log_2n+T+\log^2n)$ ，最优为 $O(\sqrt{n\log_2n}+\log^2n)$ 。

2. 如何处理添加节点？

添加节点时，用同上的方法定位父节点所在块与其准确位置。

我们可以不妨假设添加的节点的 $dfs$ 序成为了其父节点的 $dfs$ 序 $+1$ 。

这样相当于所有 $dfs$ 序大于父节点的 $dfs$ 序都增加 $1$。

我们不难发现，只有父节点所属块的一部分 $p$ 受到了影响。

暴力更新这些 $p$ ，然后插入新的节点，同时用插入排序的方式将块内的权值顺序更新。

另外，不要忘了求一下新插入节点的 $fa$ 数组。

复杂度 $O(T+\log_2n)$ 。

不要直接 $sort$ ，不然复杂度会退化至  $O(T\log_2n)$ 。

3. 如何处理节点权值修改？

我们仍然可以定位这个节点，然后暴力修改。

修改之后，把这个点丢出来进行插入排序。

复杂度 $O(T)$ 。

于是，我们在 $O(n(\sqrt{n\log_2n}+\log^2n))$ 的时间内通过了此题。

P.S. 如果复杂度证明不正确，可以私信我。

（此算法常数并不小，有时候还跑不过 $O(n\sqrt{n}\log_2n)$ 的时间分块...）

以下是完整代码：

```cpp
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
struct pii
{int p,v,Id;};
bool operator<(const pii x,const pii y)
{return x.v<y.v;}
pii v[2222][2222];
int sz[111111],Nx[111111],Las[111111];
int rank(pii x,int p)
{return v[p]+sz[p]+1-std::upper_bound(v[p]+1,v[p]+sz[p]+1,x);}  //二分整块
int n,m,blo=360,last=0,total=1;
std::vector<int>w[111111];
int g[111111],bel[111111];
void split(int x)  //分裂块 x 
{
	Nx[++total]=Nx[x],Nx[x]=total;
	int spl=sz[x]>>1;
	Las[total]=Las[x];
	register int i,p=0;
	for(i=1;i<=sz[x];i++)
	{
		pii t=v[x][i];
		if(t.p==spl)Las[x]=t.Id;
		if(t.p>spl)t.p-=spl,v[total][++sz[total]]=t,bel[t.Id]=total;
		else v[x][++p]=t;
	}sz[x]=p;
}
int dep[111111],fa[111111][22];
#define lowbit(x) (x&-x)
int rv[111111];
bool isin(int x,int y)  //判断 x 是否在 y 子树内
{
	register int i=dep[x]-dep[y];
	if(i<0)return 0;
	for(;i;i-=lowbit(i))x=fa[x][rv[lowbit(i)]];
	return x==y;
}
int rev(int x,int r,int p)  //暴力统计块 x 的答案 
{
	int L=0,D=1,R=sz[p]+1;
	register int i;
	for(i=1;i<R;i++)v[0][v[p][i].p]=v[p][i];
	for(i=1;i<R;i++)if(v[0][i].Id==r){D=L=i;break;}
	while(L+1<R)  //二分询问子树的右端点
	{
		int mid=(L+R)>>1;
		if(isin(v[0][mid].Id,r))L=mid;
		else R=mid;
	}int ret=0;
	for(i=D;i<R;i++)ret+=v[0][i].v>x;
	return ret;
}
int query(int p,int x)
{
	int ans=0,in=0;
	for(register int i=1;i;i=Nx[i])
	{
		if(bel[p]==i)in=1,ans+=rev(x,p,i);
		else if(in)
		{
			if(!isin(Las[i],p)){ans+=rev(x,p,i);break;}
			else ans+=rank(pii{0,x,0},i);
		}
	}return ans;
}
void insert(int f,int d)  //插入新的节点
{
	int vc=bel[f],cg=0;n++;
	pii verd=pii{0,d,n};
	register int i;
	fa[n][0]=f,dep[n]=dep[f]+1,bel[n]=vc;
	for(i=0;fa[n][i];i++)fa[n][i+1]=fa[fa[n][i]][i];
	for(i=1;i<=sz[vc];i++)if(v[vc][i].Id==f){i=v[vc][i].p+1;break;}
	verd.p=i;
	for(i=1;i<=sz[vc];i++)if(v[vc][i].p>=verd.p)v[vc][i].p++,cg=1;
	if(!cg)Las[vc]=n;
	for(i=1;i<=sz[vc];i++)
		if(v[vc][i].v>verd.v){pii gg=verd;verd=v[vc][i],v[vc][i]=gg;}
	v[vc][++sz[vc]]=verd;
	if(sz[vc]>blo*2)split(vc);
}
void modify(int x,int d)  //修改点权
{
	int vc=bel[x];
	register int i;
	for(i=1;i<=sz[vc];i++)
		if(v[vc][i].Id==x){v[vc][i].v=d;break;}
	pii tp;
	for(i=2;i<=sz[vc];i++)
		if(v[vc][i]<v[vc][i-1])
			tp=v[vc][i],v[vc][i]=v[vc][i-1],v[vc][i-1]=tp;
	for(i=sz[vc];i^1;i--)
		if(v[vc][i]<v[vc][i-1])
			tp=v[vc][i],v[vc][i]=v[vc][i-1],v[vc][i-1]=tp;
}
int ss=0;
void dfs(int p=1,int f=0)  //预处理初始树
{
	fa[p][0]=f,dep[p]=dep[f]+1,ss++;
	int GG=blo*1.9;
	if(ss>GG)ss-=GG,Nx[total]=total+1,total++;
	v[total][++sz[total]]=pii{ss,g[p],p},bel[p]=total;
	register int i;
	for(i=0;fa[p][i];i++)fa[p][i+1]=fa[fa[p][i]][i];
	for(auto t:w[p])if(t^f)dfs(t,p);
}
void precalc()
{
	dfs();
	for(register int i=1;i<=total;i++)
		Las[i]=v[i][sz[i]].Id,std::sort(v[i]+1,v[i]+sz[i]+1);
}
void solve()
{
	int o,u,x;
	scanf("%d%d%d",&o,&u,&x),u^=last,x^=last;
	if(o&1)modify(u,x);
	else if(o&2)insert(u,x);
	else printf("%d\n",last=query(u,x));
}
int main()
{
	register int i;
	for(i=0;i<=16;i++)rv[(1<<i)]=i;
	scanf("%d",&n);
	for(i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y),w[x].push_back(y),w[y].push_back(x);
	}for(i=1;i<=n;i++)scanf("%d",g+i);
	precalc(),scanf("%d",&m);
	for(i=1;i<=m;i++)solve();
}
```

---

## 作者：ErkkiErkko (赞：5)

###分析：###

都说这道提的经典做法之一是树分块，但为什么没人写这个做法的题解呢？

块状树与树链剖分的思想有些类似，都是将树进行适当的划分。块状树借用了分块的思想，通过把一个树分成若干块以实现更快的树上查询和修改。

我们可以通过一遍dfs实现对树的分块，具体方法是：令根节点所在块为第0块，然后向下dfs，如果一个节点的父亲节点所在块的大小小于你预设的SIZE（块的大小），那么就可以让这个节点与其父节点在同一块中，如果一个节点的父亲节点所在块的大小等于你预设的SIZE，那么对于这个节点，我们可以新建一个块。

对于每一个块，我们可以用一个vector维护这个块内节点的权值，并维护起有序性，即保证vector内元素**单调不降**（原因稍后会提到），维护方法类似于冒泡排序。

对于查询操作，我们可以通过从子树根节点dfs实现，类似**散块暴力，整块维护**的思想（注意这里要实现两个dfs函数dfsans()和dfsblock()，分别对应散块的查询和整块的查询）。整块的查询，我们可通过upper_bound()二分实现，这也是为什么要保证vector内元素单调不降。

对于修改操作，我们可以直接维护vector，然后更改w[u]即可（注意顺序）。

对于插入操作，类似于一开始dfs对树分块时的方法，根据父亲节点所在块的大小决定是否新建块。

###代码：###

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cctype>
#include <cstring>
#include <algorithm>
#include <vector>
#include <set>
using namespace std;
struct ios{
    inline char read(){
        static const int IN_LEN=1<<18|1;
        static char buf[IN_LEN],*s,*t;
        return (s==t)&&(t=(s=buf)+fread(buf,1,IN_LEN,stdin)),s==t?-1:*s++;
    }
    template <typename _Tp> inline ios & operator >> (_Tp&x){
        static char c11,boo;
        for(c11=read(),boo=0;!isdigit(c11);c11=read()){
            if(c11==-1)return *this;
            boo|=c11=='-';
        }
        for(x=0;isdigit(c11);c11=read())x=x*10+(c11^'0');
        boo&&(x=-x);
        return *this;
    }
}io;
const int MAXN=60005;
const int SIZE=305;
int n,m,w[MAXN],head[MAXN],bhead[MAXN],ecnt,becnt,tot,fa[MAXN],belong[MAXN];
struct Edge{
	int to,nxt;
}e[MAXN<<1];
struct BlockEdge{
	int to,nxt;
}be[MAXN<<1];
struct Block{
	vector<int> a;
	Block(){
		a.clear();
	}
	inline void ins(int x){
		a.push_back(x);
		for(int i=a.size()-1;i;i--)
			if(a[i-1]>a[i]) swap(a[i-1],a[i]);
			else break;
	}
	inline void upd(int x,int k){
		int pos=lower_bound(a.begin(),a.end(),x)-a.begin();
		a[pos]=k;
		for(int i=pos;i;i--)
			if(a[i-1]>a[i]) swap(a[i-1],a[i]);
			else break;
		for(int i=pos;i<a.size()-1;i++)
			if(a[i]>a[i+1]) swap(a[i],a[i+1]);
			else break;
	}
	inline int query(int x){
		return a.end()-upper_bound(a.begin(),a.end(),x);
	}
}bl[MAXN];
inline void add_edge(int bg,int ed){
	ecnt++;
	e[ecnt].to=ed;
	e[ecnt].nxt=head[bg];
	head[bg]=ecnt;
}
inline void add_blockedge(int bg,int ed){
	becnt++;
	be[becnt].to=ed;
	be[becnt].nxt=bhead[bg];
	bhead[bg]=becnt;
}
void dfs(int x,int pre){
	fa[x]=pre;
	if(bl[belong[pre]].a.size()==SIZE){
		belong[x]=++tot;
		bl[tot].ins(w[x]);
		add_blockedge(belong[pre],tot);
	}
	else{
		belong[x]=belong[pre];
		bl[belong[x]].ins(w[x]);
	}
	for(int i=head[x];i;i=e[i].nxt){
		int ver=e[i].to;
		if(ver==pre) continue;
		dfs(ver,x);
	}
}
int dfsblock(int x,int k){
	int ans=bl[x].query(k);
	for(int i=bhead[x];i;i=be[i].nxt){
		int ver=be[i].to;
		ans+=dfsblock(ver,k);
	}
	return ans;
}
int dfsans(int x,int k){
	int ans=(w[x]>k?1:0);
	for(int i=head[x];i;i=e[i].nxt){
		int ver=e[i].to;
		if(ver==fa[x]) continue;
		if(belong[ver]==belong[x]) ans+=dfsans(ver,k);
		else ans+=dfsblock(belong[ver],k);
	}
	return ans;
}
int main(){
	io>>n;
	for(int i=1;i<n;i++){
		int u,v;io>>u>>v;
		add_edge(u,v);
		add_edge(v,u);
	}
	for(int i=1;i<=n;i++)
		io>>w[i];
	dfs(1,0);
	io>>m;
	int lastans=0;
	while(m--){
		int opt,u,x;
		io>>opt>>u>>x;
		u^=lastans,x^=lastans;
		if(opt==0){
			lastans=dfsans(u,x);
			printf("%d\n",lastans);
		}
		else if(opt==1){
			bl[belong[u]].upd(w[u],x);
			w[u]=x;
		}
		else{
			w[++n]=x;
			add_edge(u,n);
			fa[n]=u;
			if(bl[belong[u]].a.size()==SIZE){
				belong[n]=++tot;
				bl[tot].ins(w[n]);
				add_blockedge(belong[u],tot);
			}
			else{
				belong[n]=belong[u];
				bl[belong[n]].ins(w[n]);
			}
		}
	}
	return 0;
}
```

我为了卡常写了fread()......

---

## 作者：chenxinyang2006 (赞：4)

来一个时间 $O(m \sqrt n)$，空间 $O(n)$ 的解法
  
首先先讲一下如何 $O(n)$ 预处理，$O(\sqrt n)$ 在线查询区间 $[l,r]$ 内有多少个数 $\le x$
  
对序列、值域都按照块长 $\sqrt n$ 进行分块，注意值域是从小到大排序后，每 $\sqrt n$ 个划分一块，因此两个相同的数可能在不同的块中
  
计 $s_{i,j}$ 为前 $i$ 个块有多少个数落在第 $j$ 个值域块，这部分不难 $O(n)$ 预处理
  
记 $l,r$ 落在 $fl,fr$ 块，$x$ 落在 $fx$，先算出 $\sum\limits_{i=1}^{fx-1} s_{fr - 1,i} - s_{fl,i}$
  
然后扫一遍两个边角块，算出有多少个数 $\le x$
  
接下来对于第 $fx$ 个值域块，扫一遍其中的每个值，计算有多少个数满足条件，且**当前未被计数**，也就是不在边角块
  
接下来回到本问题
  
对时间轴分块的问题就不赘述了，唯一的问题就是 $O(1)$ 查询两个点是否有祖辈关系
  
我们称最后一次重构前加入的点为旧点，新加入的点为新点
  
如果这两个点都是旧点，那么根据 dfs 序可以直接判断
  
如果两个点都是新点，相邻两次重构间只会有 $O(n)$ 对这样的关系，可以在加入 $x$ 点后不断往上跳，每次记下 $x$ 的祖先中哪些是新点，只会跳 $O(\sqrt n)$ 次
  
如果一个是旧点，一个是新点，唯一的情况就是旧点是新点的祖先，记录旧点往上跳到的第一个新点，如果这两个点存在祖辈关系，那么这对点也存在祖辈关系
  
最后提个小事：你会发现 $O(n)$ 重构的前提是你有排序后的数组，这个可以每次归并来维护

似乎是因为常数太大，这个理论复杂度比较优秀的算法成功拿下次劣解

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <unordered_set>
#include <vector>
#define ll long long
using namespace std;

struct range_rank_query{
	int n;
	int a[100005];
	struct num{
		int id,val;
	}b[100005];//从小到大排序 
	int s[350][350];
	#define S 317
	#define from(x) ((x - 1) / S + 1)
	#define L(x) (x * S - S + 1)
	#define R(x) (x * S)
	void init(){
		memset(s,0,sizeof(s));
		for(int i = 1;i <= n;i++) s[from(b[i].id)][from(i)]++;
		for(int i = 1;i <= from(n);i++){
			for(int j = 1;j <= from(n);j++){
				s[i][j] += s[i - 1][j];
			}
		}
	}
	int slv(int r,int v){
		int x = 0;
		for(int i = 17;i >= 0;i--) if(x + (1 << i) <= n && b[x + (1 << i)].val <= v) x += 1 << i;
		int fr = from(r),fx = from(x),ans = 0;
		for(int i = 1;i <= fx - 1;i++) ans += s[fr - 1][i];
		for(int i = L(fr);i <= r;i++) ans += a[i] <= v;
		for(int i = L(fx);i <= x;i++) ans += from(b[i].id) < fr;
		return ans;
	}
	int query(int l,int r,int x) {return (r - l + 1) - (slv(r,x) - slv(l - 1,x));}
}DS;
int n,m;
int a[100005];

int ecnt;
int head[200005];
struct eg{
	int to,nxt;
}edge[200005];

void make(int u,int v){
	edge[++ecnt].to = v;
	edge[ecnt].nxt = head[u];
	head[u] = ecnt;
}

int cnt,f[100005],dfn[100005],siz[100005],tag[100005],cg[100005],tp[100005];

void dfs(int now,int fa){
	dfn[now] = ++cnt;
	f[now] = fa;
	siz[now] = 1;
	for(int i = head[now];i;i = edge[i].nxt){
		if(edge[i].to == fa) continue;
		dfs(edge[i].to,now);
		siz[now] += siz[edge[i].to];
	}
}

struct num{
	int id,val;
}b[100005],c[100005],d[100005];

bool cmp(num a,num b){
	return a.val < b.val;
}

struct opt{
	int id,w,val;
};
vector <opt> Q;
unordered_set <ll> anc;

int solve(int u,int x){
	int ans = DS.query(dfn[u],dfn[u] + siz[u] - 1,x);
	for(int i = 0;i < Q.size();i++){
		int v = Q[i].id;
		//u 为 v 的祖先 
		if(tag[u] && tag[v]){
			if(dfn[u] <= dfn[v] && dfn[v] <= dfn[u] + siz[u] - 1 && Q[i].w > x) ans += Q[i].val;
		}else if(tag[u] && !tag[v]){
			v = tp[v];
			if(dfn[u] <= dfn[v] && dfn[v] <= dfn[u] + siz[u] - 1 && Q[i].w > x) ans += Q[i].val;
		}else if(!tag[u] && !tag[v]){
			if(anc.count((ll)u * 200000 + v) && Q[i].w > x) ans += Q[i].val;
		}
	}
	return ans;
}

void modify(int u,int x){
	cg[u] = 0;
	Q.push_back({u,a[u],-1});
	Q.push_back({u,x,1});
	a[u] = x;
}

void add(int u,int x){
	++n;
	f[n] = u;
	make(u,n);
	if(tag[u]) tp[n] = u;
	else tp[n] = tp[u];
	a[n] = x;
	b[n] = {n,x};
	Q.push_back({n,x,1});
	int v = n;
	while(!tag[v]){
		anc.insert((ll)v * 200000 + n);
		v = f[v];
	}
}

void rebuild(){
	int l1 = 0,l2 = 0,l = 0;
	for(int i = 1;i <= n;i++){
		if(cg[b[i].id]) c[++l1] = b[i];
		else d[++l2] = {b[i].id,a[b[i].id]};
	}
	sort(d + 1,d + l2 + 1,cmp);
	int i = 1,j = 1;
	while(i <= l1 && j <= l2){
		if(c[i].val < d[j].val){
			b[++l] = c[i++];
		}else{
			b[++l] = d[j++];
		}
	}
	while(i <= l1) b[++l] = c[i++];
	while(j <= l2) b[++l] = d[j++];
	cnt = 0;
	dfs(1,0);
	DS.n = n;
	for(int i = 1;i <= n;i++){
		DS.a[dfn[i]] = a[i];
		DS.b[i].val = b[i].val;
		DS.b[i].id = dfn[b[i].id];
	}
	DS.init();
	Q.clear();
	anc.clear();
	for(int i = 1;i <= n;i++){
		tp[i] = 0;
		tag[i] = cg[i] = 1;
	}
}

int main(){
	scanf("%d",&n);
	for(int i = 1;i < n;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		make(u,v);make(v,u);
	}
	for(int i = 1;i <= n;i++) scanf("%d",&a[i]);
	for(int i = 1;i <= n;i++) b[i] = {i,a[i]};
	dfs(1,0);
	sort(b + 1,b + n + 1,cmp);
	DS.n = n;
	for(int i = 1;i <= n;i++){
		DS.a[dfn[i]] = a[i];
		DS.b[i].val = b[i].val;
		DS.b[i].id = dfn[b[i].id];
	}
	DS.init();
	for(int i = 1;i <= n;i++) tag[i] = 1;
	for(int i = 1;i <= n;i++) cg[i] = 1;
	scanf("%d",&m);
	int op,u,x,last = 0;
	for(int i = 1;i <= m;i++){
		scanf("%d%d%d",&op,&u,&x);
		u ^= last;x ^= last;
		if(op == 0){
			last = solve(u,x);
			printf("%d\n",last);
		}else if(op == 1){
			modify(u,x);
		}else{
			add(u,x);
		}
		if(Q.size() == 300) rebuild();
	}
	return 0;
}
```


---

## 作者：muller (赞：3)

分块吧！这题的分块不是给树分块，而是程序分块，就没了！

好像3操作数据里并没有，而且数据范围没道100000吧，所以直接水！

就是询问套套主席树，其他瞎搞，暴力+卡常就可以跑过了，非常开心吧！

然后要注意不能离散化，同时要当心有0

所以直接在0 - 2 ^ 30 搞一下即可！（chairman tree大法好）

呵呵，我这篇博客其实和我在P2166写的博客差不多吧

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 60005, M = (N << 1), P = (1 << 30);
int n, ecnt, val[N], to[M], nxt[M], fir[N];
template <class T> void cmax(T &x, T y) {x = x > y ? x : y;}
template <class T> void cmin(T &x, T y) {x = x < y ? x : y;}
template <class T> void rd(T &x) {
	char c = getchar(); int f = 1; x = 0;
	for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
	for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
	x *= f;
}
void ae(int u, int v) {to[++ecnt] = v; nxt[ecnt] = fir[u]; fir[u] = ecnt;}
namespace subtask1 {
	int ls[N * 60], rs[N * 60], size[N * 60], Rt[N], siz[N], dfn[N], idx = 0, tot = 0, ans = 0;
	struct Segment_Tree {
		#define mid (l + r >> 1)
		#define lc ls[rt]
		#define rc rs[rt] 
		void modify(int rt, int pre, int l, int r, int x) {
			size[rt] = size[pre] + 1;
			if (l == r) return; lc = ls[pre], rc = rs[pre];
			if (x <= mid) modify(lc = ++tot, ls[pre], l, mid, x);
			else modify(rc = ++tot, rs[pre], mid + 1, r, x); 			
		}
		int query(int rt, int pre, int l, int r, int x) {
			if (l == r) return size[rt] - size[pre];
			if (x < mid) return size[rc] - size[rs[pre]] + query(lc, ls[pre], l, mid, x);
			return query(rc, rs[pre], mid + 1, r, x);
		}
	} T;
	void dfs(int u, int f) {
		int i; dfn[u] = ++idx, siz[u] = 1; T.modify(Rt[idx] = ++tot, Rt[idx - 1], 1, P, val[u]);
		for (i = fir[u]; i; i = nxt[i]) {
			int v = to[i];
			if (v != f) dfs(v, u), siz[u] += siz[v];
		}
	}
	void solve() {
		int Q; rd(Q); dfs(1, 0);
		while (Q--) {
			int opt, x, y; rd(opt); rd(x); rd(y); x ^= ans, y ^= ans;
			printf("%d\n", ans = T.query(Rt[dfn[x] + siz[x] - 1], Rt[dfn[x] - 1], 0, P, y));
		}
	}
};
namespace subtask2 {
	int fa[N], k, ans = 0;
	void dfs(int u, int f) {
		int i; fa[u] = f;
		for (i = fir[u]; i; i = nxt[i]) {
			int v = to[i];
			if (v != f) dfs(v, u); 
		}
	}
	void work(int u) {
		int i; ans += val[u] > k;
		for (i = fir[u]; i; i = nxt[i]) {
			int v = to[i];
			if (v != fa[u]) work(v);
		}
	}
	void solve() {
		int Q; rd(Q); dfs(1, 0);
		while (Q--) {
			int opt, x, y; rd(opt); rd(x); rd(y); x ^= ans, y ^= ans;
			if (!opt) ans = 0, k = y, work(x), printf("%d\n", ans);
			if (opt == 1) val[x] = y;
			if (opt == 2) val[++n] = y, fa[n] = x, ae(x, n);
		}
	}
}
int main() {
	int i; rd(n);
	for (i = 1; i < n; ++i) {
		int u, v; rd(u); rd(v);
		ae(u, v); ae(v, u);
	}
	for (i = 1; i <= n; ++i) rd(val[i]);
	if (n == 30000) subtask1 :: solve();
	else subtask2 :: solve();
	return 0;
}

```

---

## 作者：ExplodingKonjac (赞：2)

### [【原题链接】](https://www.luogu.com.cn/problem/P2137)

## 解题思路

~~其实我是跟着平衡树的标签找到这里，然后写了一发块状链表。~~

好像题解区里唯一一个块状链表题解和我的思路也不太一样。

首先这题需要维护子树操作，所以需要使用 dfs 序转化为序列问题，这样单点修改和子树查询都可以用（树套树？）维护。

考虑一下给节点 $u$ 添加一个儿子后 dfs 序会变成什么样。假设我们对于每个节点用两个位置 $lb_u,\ rb_u$ 来记录其在 dfs 序中的区间左右端点，那么我们就是在 $lb_u$ 的后面（当然也可以是 $rb_u$ 的前面）插入一对新的 $lb_v,\ rb_v$。

既然有了插入操作，你可以选择写平衡树套线段树，并且毫无疑问地爆时间爆空间。

但是我们有一个很优秀的支持插入的数据结构——块状链表。

插入操作不再赘述。对于每一个块，维护其本身代表的序列 $a$，以及排序后的序列 $b$。整块查询时，可以用 $\text{upper\_bound}$ 在 $b$ 中找到第一个大于 $x$ 的位置 $pos$，该块的贡献就是 $size-pos+1$。

零散块就直接在 $a$ 数组中暴力计算。

现在只剩下最后一个问题：由于 dfn 序列是不断变化的，我们怎么知道 $lb_u,\ rb_u$ 的位置标号呢？嗯，分块当然可以直接维护，但是我选择了再用一棵 $\text{Splay}$ 维护位置。

## 代码实现

```
#include <bits/stdc++.h>
using namespace std;

/*
  省略100多行的快读快写，即后面的qin、qout
  【广告】https://www.luogu.com.cn/blog/explodingkonjac/fast-io
*/

typedef long long LL;
int n,m,zt[60005],w[30005];
struct Edge{ int to,nxt; }e[60005];
int cnt,hd[30005];
inline void addEdge(int u,int v)
	{ e[++cnt]=(Edge){v,hd[u]},hd[u]=cnt; }
void dfs(int u,int fa)
{
	zt[++cnt]=u;
	for(int i=hd[u];i;i=e[i].nxt)
		if(e[i].to!=fa)
			dfs(e[i].to,u);
	zt[++cnt]=-u;
}
struct SplayNode
{
	int siz;
	SplayNode *ch[2],*fa;
	SplayNode(): siz(1)
		{ ch[0]=ch[1]=fa=nullptr; }
}*rt;
typedef SplayNode *pNode;
#define which(i) (i->fa->ch[1]==i)
inline void pushup(pNode i)
{
	i->siz=1;
	if(i->ch[0])	i->siz+=i->ch[0]->siz;
	if(i->ch[1])	i->siz+=i->ch[1]->siz;
}
inline void rotate(pNode i)
{
	pNode f=i->fa,gf=f->fa;
	bool x=which(i);
	i->fa=gf;
	if(gf)	gf->ch[which(f)]=i;
	f->ch[x]=i->ch[!x];
	if(f->ch[x])	f->ch[x]->fa=f;
	i->ch[!x]=f,f->fa=i;
	pushup(f),pushup(i);
}
inline void splay(pNode x,pNode y=nullptr)
{
	for(pNode f;(f=x->fa)!=y;rotate(x))
		if(f->fa!=y)
			rotate(which(f)==which(x)?f:x);
	if(!y)	rt=x;
}
pNode insert(int k)
{
	pNode i=rt,x;
	while(true)
	{
		int sz=i->ch[0]?i->ch[0]->siz:0;
		if(sz>=k)	i=i->ch[0];
		else
			if(!(k-=sz+1))
			{
				x=new SplayNode,x->ch[1]=i->ch[1],x->fa=i;
				if(i->ch[1])	i->ch[1]->fa=x;
				return i->ch[1]=x,pushup(x),splay(x),x;
			}
			else	i=i->ch[1];
	}
}
int getRank(pNode i)
	{ return splay(i),(i->ch[0]?i->ch[0]->siz:0)+1; }
pNode lb[60005],rb[60005];
void build1(int l,int r,pNode &i=rt,pNode f=nullptr)
{
	if(l<=r)
	{
		i=new SplayNode,i->fa=f;
		int mid=(l+r)>>1;
		(zt[mid]>0?lb[zt[mid]]:rb[-zt[mid]])=i;
		build1(l,mid-1,i->ch[0],i);
		build1(mid+1,r,i->ch[1],i);
		pushup(i);
	}
}
int SIZE;
struct Block
{
	int cnt,*a,*b;
	Block *nxt;
	Block(): cnt(0),nxt(nullptr)
		{ a=new int[SIZE+5],b=new int[SIZE+5]; }
	inline bool full()
		{ return cnt==SIZE; }
	inline void update()
		{ memcpy(b+1,a+1,cnt*4),sort(b+1,b+cnt+1); }
}*head;
void build2(Block *&i,int j=1)
{
	i=new Block;
	for(;j<=2*n && !i->full();j++)
		i->a[++i->cnt]=zt[j]>0?w[zt[j]]:-1;
	i->update();
	if(j<=2*n)	build2(i->nxt,j);
}
Block *find(int &x)
{
	Block *i=head;
	for(;i->cnt<x;x-=i->cnt,i=i->nxt);
	return i;
}
void insert(int p,int x)
{
	Block *i=find(p),*j;
	if(i->full())
	{
		j=i->nxt;
		if(!j || j->full())
			i->nxt=new Block,i->nxt->nxt=j,j=i->nxt;
		for(int k=++j->cnt;k>1;k--)	j->a[k]=j->a[k-1];
		j->a[1]=(p==SIZE)?x:i->a[SIZE];
		j->update();
	}
	else	i->cnt++;
	for(int k=i->cnt;k>p+1;k--)	i->a[k]=i->a[k-1];
	i->a[p+1]=x,i->update();
}
int main()
{
	qin>>n,SIZE=sqrt(n);
	int x,y,ans=0;
	for(int i=1;i<n;i++)	qin>>x>>y,addEdge(x,y),addEdge(y,x);
	for(int i=1;i<=n;i++)	qin>>w[i];
	cnt=0,dfs(1,0),build1(1,2*n),build2(head);
	qin>>m;
	while(m--)
	{
		int opt,l,r;
		Block *i,*j;
		qin>>opt>>x>>y,x^=ans,y^=ans;
		if(opt==0)
		{
			ans=0;
			l=getRank(lb[x]),r=getRank(rb[x]),i=find(l),j=find(r);
			if(i==j)
				for(int k=l;k<=r;k++)	ans+=(i->a[k]>y);
			else
			{
				for(int k=l;k<=i->cnt;k++)	ans+=(i->a[k]>y);
				while((i=i->nxt)!=j)
					ans+=i->cnt-(upper_bound(i->b+1,i->b+i->cnt+1,y)-i->b)+1;
				for(int k=1;k<=r;k++)	ans+=(j->a[k]>y);
			}
			qout.writeln(ans);
		}
		else if(opt==1)
		{
			l=getRank(lb[x]),i=find(l);
			i->a[l]=y,i->update();
		}
		else
		{
			l=getRank(lb[x]),++n;
			insert(l,-1),rb[n]=insert(l);
			insert(l,y),lb[n]=insert(l);
		}
	}
	return qout.flush(),0;
}
```


---

## 作者：sjie (赞：2)

楼下把修改操作分块已经讲得十分清楚了;

这里给出一个同样是将修改操作分块但是不用归并树的方法: 

dfs序+主席树 

先求一遍dfs序, 每一个节点都建立一颗主席树,根据dfs序连接上一颗树; 

首先对于查询,如果没有修改操作,我们可以直接查询u的rt[last[u]]-rt[dfn[u]-1]的比x大的个数

再暴力查询此时块内的操作1和操作2的x,看是否大于当前查询的x,在用倍增判断操作1和操作2的点是否在此时查询的子树内，将答案修改 

每当修改操作大于block(分块的大小)我们就暴力重建dfs序和所有主席树(dfs序 O(n),主席树O(nlog(n)));
然后这题就结束了;

优化:这题卡常卡的我心力憔悴

1.暴力重建树的常数过大,可以把分块的大小 调大,来减少重建的次数;

2.求倍增数组时,只要第一次求dfs序的时候求即可,每次操作2的时候直接求该点的倍增数组;

注意:

1.由于我的主席树是每次查询都query(rt[last[u]],rt[dfn[u]-1],1,n,x+1);

但是操作2的时候会把n增大,使得查询出错,可以先用变量维护操作2影响的n,重建树的时候再把n更新;

2.每次重建树要清空主席树数组等该清空的变量; 

------------

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#define ll long long
#define rr read()
using namespace std;
const int M=60009;
int n,m,nn,num=0,id=0,block,sz=0,blocknow=0,ans=0,ld=0;
int head[M],son[M],f[M],tid[M],top[M],dep[M],last[M],wei[M],rt[M],yuan[M];
int b[M];
int sum[M*20],ls[M*20],rs[M*20];
int d[M][23];
struct P{
    int to,ne;
    P(int t1=0,int t2=0):to(t1),ne(t2){}
}e[M<<1];
struct Q{
    int o,u,x,yuan;
    Q(int t1=0,int t2=0,int t3=0,int t4=0):o(t1),u(t2),x(t3),yuan(t4){}
}q[M];
struct V{
    int val,id;
    bool operator < (const V&o)const{
        return val<o.val;
    }
}a[M],c[M];
inline int read(){
    int rex=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){rex=rex*10+ch-'0';ch=getchar();}
    return rex*f;
}
inline void add(int u,int v){
    e[++num]=P(v,head[u]);head[u]=num;
    e[++num]=P(u,head[v]);head[v]=num;
}
void zdfs(int u,int fa){
    dep[u]=dep[fa]+1;f[u]=fa;son[u]=1;
    d[u][0]=fa;
    if(blocknow==1)for(int i=1;i<=17;++i){
        d[u][i]=d[d[u][i-1]][i-1];
    }
    for(int i=head[u];i;i=e[i].ne){
        int v=e[i].to;
        if(v==fa)continue;
    		zdfs(v,u);son[u]+=son[v];
    		if(son[v]>son[wei[u]])wei[u]=v;
    }
}
void qdfs(int u,int tp){
    tid[u]=++id;top[u]=tp;last[u]=tid[u]+son[u]-1;
    yuan[tid[u]]=u;
    if(wei[u])qdfs(wei[u],tp);
    for(int i=head[u];i;i=e[i].ne){
        int v=e[i].to;
        if(v==wei[u]||v==f[u])continue;
    		qdfs(v,v);
    }
}
void build(int&root,int la,int l,int r,int now){
    if(!root)root=++sz;
    sum[root]=sum[la]+1;
    if(l==r)return;
    int mid=(l+r)>>1;
    if(now<=mid){build(ls[root],ls[la],l,mid,now);rs[root]=rs[la];}
    else {build(rs[root],rs[la],mid+1,r,now);ls[root]=ls[la];}
}
int query(int root,int la,int l,int r,int x){
    if(l==r){if(c[l].val>=x)return sum[root]-sum[la];return 0;}
    int mid=(l+r)>>1,rex=0;
    if(c[mid+1].val>=x){
        rex=sum[rs[root]]-sum[rs[la]];
        if(ls[root])rex+=query(ls[root],ls[la],l,mid,x);
    }
    else {if(rs[root])rex=query(rs[root],rs[la],mid+1,r,x);}
    return rex;
}
inline void rebuild(){
    blocknow++;
    memset(rt,0,sizeof(rt));
    memset(sum,0,sizeof(sum));
    memset(ls,0,sizeof(ls));
    memset(rs,0,sizeof(rs));
    sz=0;id=0;ld=0;n=nn;
    zdfs(1,0);qdfs(1,1);
    for(int i=1;i<=n;++i)c[i]=a[i];
    sort(c+1,c+n+1);
    for(int i=1;i<=n;++i)b[c[i].id]=i;
    for(int i=1;i<=n;++i){
        build(rt[i],rt[i-1],1,n,b[yuan[i]]);
    }
}
inline int lca(int x,int y){
    if(dep[x]<dep[y])swap(x,y);
    for(int i=17;i>=0;--i){
        if(dep[d[x][i]]>=dep[y])x=d[x][i];
    }
    if(x==y)return x;
    for(int i=17;i>=0;--i){
        if(dep[d[x][i]]!=dep[d[y][i]])x=d[x][i],y=d[y][i];
    }
    return d[x][0];
}
inline void update(int u,int fa){
    d[u][0]=fa;
    dep[u]=dep[fa]+1;
    for(int i=1;i<=17;++i){
        d[u][i]=d[d[u][i-1]][i-1];
    }
}
int main(){
    nn=rr;
    for(int i=1,u,v;i<nn;++i){
        u=rr;v=rr;add(u,v);
    }
    for(int i=1;i<=nn;++i)a[i].val=rr,a[i].id=i;
    m=rr;
    block=sqrt(m*5);
    rebuild();
    for(int i=1,o,u,x;i<=m;++i){
        o=rr;u=rr^ans;x=rr^ans;
        if(o==0){
            if(tid[u]>0)ans=query(rt[last[u]],rt[tid[u]-1],1,n,x+1);
            else ans=0;
            for(int j=1;j<=ld;++j){
                if(q[j].o==1){
                    if(((q[j].yuan>x)^(q[j].x>x))&&lca(u,q[j].u)==u)
                    ans+=(q[j].x>x)?1:-1;
                }
                if(q[j].o==2){
                    if(lca(q[j].yuan,u)!=u)continue;
                    if(q[j].x>x)ans++;
                }
            }
            printf("%d\n",ans);
        }
        if(o==1){
            q[++ld]=Q(o,u,x,a[u].val);a[u].val=x;
            if(ld>block)rebuild();
        }
        if(o==2){
            q[++ld]=Q(o,u,x,nn+1);
            nn++;a[nn].val=x;a[nn].id=nn;
            add(nn,u);
            update(nn,u);
            if(ld>block)rebuild();
        }
    }
    return 0;
}
```

---

## 作者：AubRain (赞：2)

## 分块的主席树做法：

分块不是对树分块，**我们要对代码分块**！

对于没有 $1,2$ 操作的做法：在 $dfn$ 序上建主席树，每次询问就相当于问一个区间中严格大于一个值的数有多少个。~~随便做水水水~~

可是有了修改和加节点操作该怎么办呢？

每次修改点权的时候就直接修改就行了，每次加节点的时候就直接加就行了，每次询问的时候 $dfs$ 一遍子树就行了。

我管这个方法叫 **暴力**

于是你就有了 $80$ 分，不过前两个点 $T$ 飞了

~~不过我才不会告诉你，前两个点只有30000次询问操作！~~

于是我们就有了两个~~优秀~~做法！

~~合并两个代码即可AC~~


（前两个点加起来只有50+ms，跑的贼快）

**代码：**

```c
#include<bits/stdc++.h>
#define N 40005
#define M N*30
#define R register
#define mid ((l+r)>>1)
using namespace std;

inline bool rd(int &X)
{
    X=0;char ch=0;
    while(!isdigit(ch))ch=getchar();
    while( isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return 1;
}

int n,m,K,dfn[N],tot;
int a[N],ans,pd,x,y,w[N];
int head[N],cnt,fa[N],size[N];
struct nd{int nxt,to;}e[N<<1];
int rt[N],sum[M],ls[M],rs[M],num;
#define For(x) for(R int y,i=head[x];(y=e[i].to);i=e[i].nxt)

inline void add(int x,int y){
  e[++cnt]=(nd){head[x],y};head[x]=cnt;
  e[++cnt]=(nd){head[y],x};head[y]=cnt;
}
void dfs1(R int x){
  dfn[x]=++tot;w[tot]=a[x];size[x]=1;
  For(x) if(y!=fa[x])
    fa[y]=x,dfs1(y),size[x]+=size[y];
}
void dfs(R int x){
  ans+=a[x]>K; For(x) if(y!=fa[x]) dfs(y);
}
void ins(R int r1,int &p,R int x,int l=1,int r=1e7){
  sum[p=++num]=sum[r1]+1;ls[p]=ls[r1];rs[p]=rs[r1]; if(l==r) return ;
  x<=mid ? ins(ls[r1],ls[p],x,l,mid) : ins(rs[r1],rs[p],x,mid+1,r);
}
int ask(R int r1,int p,R int x,int l=1,int r=1e7){
  if(l==r or !p) return 0;
  return x<=mid ? ask(ls[r1],ls[p],x,l,mid)+sum[rs[p]]-sum[rs[r1]] : ask(rs[r1],rs[p],x,mid+1,r);
}
void work()
{
  for(R int i=1;i<=n;i++)
    ins(rt[i-1],rt[i],w[i]);
  while(m--)
    rd(pd),rd(x),rd(y),x^=ans,y^=ans,
    printf("%d\n",ans=ask(rt[dfn[x]-1],rt[dfn[x]+size[x]-1],y));
}
signed main()
{
  for(R int x,y,i=rd(n);i<n;i++)
    rd(x),rd(y),add(x,y);
  for(R int i=1;i<=n;i++) rd(a[i]);
  rd(m);dfs1(1);
  if(n==30000) return work(),0;
  while(m--) {
    rd(pd),rd(x),rd(y);
    x^=ans;y^=ans;
    if(pd==1) a[x]=y;
    if(pd==2) a[++n]=y,add(fa[n]=x,n);
    if(pd==0) K=y,ans=0,dfs(x),printf("%d\n",ans);
  }
}
```

---

## 作者：xudaxia (赞：0)

询问的化我们可以建主席树。然后修改？，树套树。。。，最后插入？炸了。
所以我们对操作进行分块。  
我们先对整棵树建一个主席树。修改，插入我们先记录下来。然后询问的时候先对主席树查询，然后暴力遍历我们记录下来的修改插入操作。每$\sqrt{m}$次操作后我们重新构建一个主席树。这样我们保证了重建主席树和询问的总复杂度为$O(nlogn\sqrt{m})$然后就把这道题解决了。    
有一个难办的事就是如何记录修改和插入的操作。可以使每次询问的时候我们可以知道修改和插入是否在$u$的子树中以便我们判断是否要让这些修改和询问产生贡献。因为没考虑到可以询问插入的节点，在多次尝试后我决定维护一个$f[i][j]$代表i向上跳$i^j$的深度到达的节点。处理询问的时候我们对于每一个修改和插入都跳到和u一个深度看是否相等。  
当然还要记录一些常规的信息比如这个点被修改之前的权值什么的。。。
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=101000;
int head[N],cnt;
int n,m,ans,a[N],b[N],CNT,more;
int be[N],ed[N],dep[N],fa[N][25],tot,id[N],top,w[N],from[N];
int root[N],ch[N*20][2],sum[N*20],num;
struct edge{
    int to,nxt;
}e[N*2];
inline void add_edge(int u,int v){
    cnt++;
    e[cnt].nxt=head[u];
    e[cnt].to=v;
    head[u]=cnt;
}
inline void add(int l,int r,int x,int pre,int &now){
	now=++num;
	sum[now]=sum[pre]+1;
	ch[now][0]=ch[pre][0];
	ch[now][1]=ch[pre][1];
	if(l==r)return;
	int mid=(l+r)>>1;
	if(x>mid)add(mid+1,r,x,ch[pre][1],ch[now][1]);
	else add(l,mid,x,ch[pre][0],ch[now][0]);
}
inline int check(int l,int r,int L,int R,int pre,int now){
	if(l==L&&r==R)return sum[now]-sum[pre];
	int mid=(l+r)>>1;
	if(L>mid)return check(mid+1,r,L,R,ch[pre][1],ch[now][1]);
	else if(R<=mid)return check(l,mid,L,R,ch[pre][0],ch[now][0]);
	else return check(l,mid,L,mid,ch[pre][0],ch[now][0])+check(mid+1,r,mid+1,R,ch[pre][1],ch[now][1]); 
}
inline void dfs(int u,int f){
    be[u]=++tot;
    dep[u]=dep[f]+1;
    add(1,n,lower_bound(b+1,b+1+n,a[u])-b,root[be[u]-1],root[be[u]]);
    fa[u][0]=f;
    for(int i=1;i<=20;i++)fa[u][i]=fa[fa[u][i-1]][i-1];
    for(int i=head[u];i;i=e[i].nxt){
        int v=e[i].to;
        if(v==f)continue;
        dfs(v,u);
    }
    ed[u]=tot;
}
inline bool judge(int x,int to){
	for(int i=20;i>=0;i--)
		if(dep[fa[x][i]]>=dep[to])x=fa[x][i];
	if(x==to)return true;
	else return false;
}
inline int read(){
    int sum=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){sum=(sum<<1)+(sum<<3)+ch-'0';ch=getchar();}
    return sum*f;
}
int main(){
    n=read();
    for(int i=1;i<n;++i){
        int u=read(),v=read();
        add_edge(u,v);add_edge(v,u);
    }
    for(int i=1;i<=n;++i)a[i]=read();
    m=read();
    int Block=sqrt(m*25);
    while(m--){
        int type=read(),u=read()^ans,x=read()^ans;
        if(CNT==0){
            tot=0;top=0;num=0;n+=more;more=0;
            for(int i=1;i<=n;i++)b[i]=a[i];
            sort(b+1,b+1+n);
            dfs(1,1);
        }
        if(type==0){
        	if(u<=n){
            	int tmp=upper_bound(b+1,b+1+n,x)-b;
            	if(tmp<=n)ans=check(1,n,tmp,n,root[be[u]-1],root[ed[u]]);
            	else ans=0;
            }
			else ans=0;
            for(int i=1;i<=top;++i)
                if(judge(id[i],u)){
                    if(from[i]>x)ans--;
                    if(w[i]>x)ans++;
                }
            for(int i=n+1;i<=n+more;++i){
            	if(judge(i,u)){
            		if(w[i]>x)ans++;
            	}
            }
            printf("%d\n",ans);
            CNT++;
        }
        else if(type==1){
            ++top;
            w[top]=x;from[top]=a[u];id[top]=u;
            ++CNT;
            a[u]=x;
        }
        else{
            ++more;
			add_edge(n+more,u);
			add_edge(u,n+more);
			a[n+more]=x;
            fa[n+more][0]=u;dep[n+more]=dep[u]+1;
            for(int i=1;i<=20;i++)fa[n+more][i]=fa[fa[n+more][i-1]][i-1];
            w[n+more]=x;
            ++CNT;
        }
      	if(CNT==Block)CNT=0;
    }
    return 0;
}
```

---


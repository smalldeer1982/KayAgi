# 数列

## 题目描述

维护一个数列,共 $7$ 种操作:

I. `INSERT x n a1 a2 .. an` 在第 $x$ 个数后插入 $n$ 个数分别为 $a_1\dots a_n$。

II. `DELETE x n` 删除第 $x$ 个数开始的 $n$ 个数。

III. `REVERSE x n` 翻转第 $x$ 个数开始的 $n$ 个数的区间。

IV. `MAKE-SAME x n t` 将第 $x$ 个数开始的 $n$ 个数统一改为 $t$。

V. `GET-SUM x n` 输出第 $x$ 个数开始的 $n$ 个数的和。

VI. `GET x` 输出第 $x$ 个数的值。

VII. `MAX-SUM x n` 输出第 $x$ 个数开始的 $n$ 个数的最大连续子序列和。

## 说明/提示

共 $20$ 组数据，每组数据随机生成，  
保证每个时刻数列里的数不超过 $200000$ 个，  
任何一个输入的数字均在 $-1000\sim1000$之间，结果不超过 $2^{30}$。

第 $1\sim2$ 组 $\quad1\le N\le 5$，$1\le M\le 10$。

第 $3\sim4$ 组 $\quad1\le N\le 10$，$1\le M\le 20$。

第 $5\sim6$ 组 $\quad1\le N \le 20$，$1\le M\le 50$。

第 $7\sim8$ 组 $\quad1\le N\le 50$，$1\le M\le 100$。

第 $9\sim10$ 组 $\quad1\le N\le 100$，$1\le M\le 500$。

第 $11\sim12$ 组 $\quad 1\le N\le 1000$，$1\le M\le 1000$。

第 $13\sim14$ 组 $\quad1\le N\le 5000$，$1\le M\le 2000$。

第 $15\sim16$ 组 $\quad1\le N\le 10^4$，$1\le M\le 5000$。

第 $17\sim18$ 组 $\quad1\le N\le 10^5$，$1\le M\le 10^4$。

第 $19\sim20$ 组 $\quad1\le N\le 2\times 10^5$，$1\le M\le 2\times 10^4$。

## 样例 #1

### 输入

```
9 8
2 -6 3 5 1 -5 -3 6 3
GET-SUM 5 4
MAX-SUM 1 9
INSERT 8 3 -5 7 2
DELETE 12 1
MAKE-SAME 3 3 2
REVERSE 3 6
GET 5
MAX-SUM 1 11```

### 输出

```
-1
10
-5
10```

# 题解

## 作者：破忆 (赞：15)

## 【题意】
维护一个序列

支持插入、删除、翻转、覆盖、求和、求最大子段和操作
## 【分析】
经典数据结构题

没什么思维难度，直接上$fhq-treap$吧

### 明确需要维护的信息

翻转和覆盖，需要打两个懒标记

求和需要区间和

求最大子段和需要区间最大前缀、最大后缀与最大子段和

还有随机键值、区间大小、左右子树

```cpp
struct fhq_treap{
	int rand,siz,rev,cov,son[2],val;
	LL max,s,l,r;
}t[maxt];

```

### 上传信息、下发标记

线段树和平衡树的基本操作，比较套路

```cpp
IN void pushup(RE int k){
	t[k].siz=t[ls].siz+t[rs].siz+1;
	t[k].s=t[ls].s+t[rs].s+t[k].val;
	t[k].l=max(t[ls].l,max(0ll,t[ls].s+t[k].val+t[rs].l));
	t[k].r=max(t[rs].r,max(0ll,t[rs].s+t[k].val+t[ls].r));
	t[k].max=max((LL)t[k].val,t[ls].r+t[k].val+t[rs].l);
	if(ls) t[k].max=max(t[k].max,t[ls].max);
	if(rs) t[k].max=max(t[k].max,t[rs].max);
}
```
```cpp
IN void pushdown(RE int k){
	if(t[k].cov!=INF){
		LL c=t[k].cov;
		if(ls) cov(ls,c);
		if(rs) cov(rs,c);
		t[k].cov=INF;
	}
	if(t[k].rev){
		if(ls) rev(ls);
		if(rs) rev(rs);
		t[k].rev=0;
	}
}
```
### fhq-treap合并、分裂板子
```cpp
int merge(RE int x,RE int y){
	if(!x||!y) return x+y;
	if(t[x].rand<t[y].rand){
		pushdown(x);
		t[x].son[1]=merge(t[x].son[1],y);
		pushup(x);
		return x;
	}
	else{
		pushdown(y);
		t[y].son[0]=merge(x,t[y].son[0]);
		pushup(y);
		return y;
	}
}
```
```cpp
void splits(RE int now,RE int k,RE int &x,RE int &y){
	if(!now){
		x=y=0;
		return;
	}
	pushdown(now);
	if(k<=t[t[now].son[0]].siz){
		y=now;
		splits(t[y].son[0],k,x,t[y].son[0]);
		pushup(y);
	}
	else{
		x=now;
		splits(t[x].son[1],k-t[t[x].son[0]].siz-1,t[x].son[1],y);
		pushup(x);
	}
	pushup(now);
}
```
### 插入与删除

插入仿照线段树建树方式，而不是逐个插入，可以更平衡

删点时把没用的点存入栈，以便下次使用
```cpp
IN int build(RE int k){
	RE int now=top?stk[top--]:++cnt;
	t[now].rand=rand();
	t[now].cov=INF;
	t[now].rev=0;
	t[now].son[0]=t[now].son[1]=0;
	t[now].max=t[now].s=t[now].val=k;
	t[now].l=t[now].r=max(k,0);
	t[now].siz=1;
	return now;
}
int build(RE int l,RE int r){
	if(l==r) return build(read());
	int x=build(l,mid),y=build(mid+1,r);
	return merge(x,y);
}
```
```cpp
void del(RE int k){
	if(ls) del(ls);
	if(rs) del(rs);
	stk[++top]=k;
}
IN void del(RE int l,RE int r){
	RE int x,y,z;
	splits(rt,r,x,z);
	splits(x,l-1,x,y);
	del(y);
	rt=merge(x,z);
}
```
### 覆盖与翻转

分离出待操作区间，然后打上标记，顺便更新信息
```cpp
IN void cov(RE int k,RE int c){
	t[k].cov=t[k].val=c;
	t[k].s=(LL)t[k].siz*c;
	t[k].l=t[k].r=max(0ll,t[k].s);
	t[k].max=max((LL)c,t[k].s);
}

IN void cover(RE int l,RE int r,RE int c){
	RE int x,y,z;
	splits(rt,r,x,z);
	splits(x,l-1,x,y);
	cov(y,c);
	rt=merge(merge(x,y),z);
}
```
```cpp
IN void rev(RE int k){
	if(!k) return;
	swap(t[k].l,t[k].r);
	swap(t[k].son[0],t[k].son[1]);
	t[k].rev^=1;
}
IN void reverse(RE int l,RE int r){
	RE int x,y,z;
	splits(rt,r,x,z);
	splits(x,l-1,x,y);
	rev(y);
	rt=merge(merge(x,y),z);
}
```
### 询问

分离出区间输出即可
```cpp
IN LL query(RE int l,RE int r){
	RE int x,y,z;
	splits(rt,r,x,z);
	splits(x,l-1,x,y);
	RE LL ret=t[y].s;
	rt=merge(merge(x,y),z);
	return ret;
}
```
```cpp
IN LL maxs(RE int l,RE int r){
	RE int x,y,z;
	splits(rt,r,x,z);
	splits(x,l-1,x,y);
	LL ret=t[y].max;
	rt=merge(merge(x,y),z);
	return ret;
}
```
## 算法
fhq-treap
## 提醒
细节多，代码长

以下几个地方值得注意

> 翻转时要交换最大前缀和最大后缀


> 下传标记时，先覆盖再翻转


> 建树时，先提取出子树再合并，不能写成这样，否则会有意想不到的错误
```cpp
merge(build(l,mid),build(mid+1,r))
```


> 若没有覆盖标记时，懒标记应该设置成一个不可能出现的值，设成-1,0之类的就完了


> 记得开longlong


## 代码
```cpp
#include<bits/stdc++.h>
#define LL long long
#define ls t[k].son[0]
#define rs t[k].son[1]
#define mid (l+r>>1)
#define IN inline
#define RE register
using namespace std;
const int maxt=5e5+5,INF=1<<30;
int n,m;
int top,stk[maxt];
int cnt,rt;
char z[15];
struct fhq_treap{
	int rand,siz,rev,cov,son[2],val;
	LL max,s,l,r;
}t[maxt];
IN int read(){
	RE int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
IN void rev(RE int k){
	if(!k) return;
	swap(t[k].l,t[k].r);
	swap(t[k].son[0],t[k].son[1]);
	t[k].rev^=1;
}
IN void cov(RE int k,RE int c){
	t[k].cov=t[k].val=c;
	t[k].s=(LL)t[k].siz*c;
	t[k].l=t[k].r=max(0ll,t[k].s);
	t[k].max=max((LL)c,t[k].s);
}
IN void pushup(RE int k){
	t[k].siz=t[ls].siz+t[rs].siz+1;
	t[k].s=t[ls].s+t[rs].s+t[k].val;
	t[k].l=max(t[ls].l,max(0ll,t[ls].s+t[k].val+t[rs].l));
	t[k].r=max(t[rs].r,max(0ll,t[rs].s+t[k].val+t[ls].r));
	t[k].max=max((LL)t[k].val,t[ls].r+t[k].val+t[rs].l);
	if(ls) t[k].max=max(t[k].max,t[ls].max);
	if(rs) t[k].max=max(t[k].max,t[rs].max);
}
IN void pushdown(RE int k){
	if(t[k].cov!=INF){
		LL c=t[k].cov;
		if(ls) cov(ls,c);
		if(rs) cov(rs,c);
		t[k].cov=INF;
	}
	if(t[k].rev){
		if(ls) rev(ls);
		if(rs) rev(rs);
		t[k].rev=0;
	}
}
void splits(RE int now,RE int k,RE int &x,RE int &y){
	if(!now){
		x=y=0;
		return;
	}
	pushdown(now);
	if(k<=t[t[now].son[0]].siz){
		y=now;
		splits(t[y].son[0],k,x,t[y].son[0]);
		pushup(y);
	}
	else{
		x=now;
		splits(t[x].son[1],k-t[t[x].son[0]].siz-1,t[x].son[1],y);
		pushup(x);
	}
	pushup(now);
}
int merge(RE int x,RE int y){
	if(!x||!y) return x+y;
	if(t[x].rand<t[y].rand){
		pushdown(x);
		t[x].son[1]=merge(t[x].son[1],y);
		pushup(x);
		return x;
	}
	else{
		pushdown(y);
		t[y].son[0]=merge(x,t[y].son[0]);
		pushup(y);
		return y;
	}
}
IN int build(RE int k){
	RE int now=top?stk[top--]:++cnt;
	t[now].rand=rand();
	t[now].cov=INF;
	t[now].rev=0;
	t[now].son[0]=t[now].son[1]=0;
	t[now].max=t[now].s=t[now].val=k;
	t[now].l=t[now].r=max(k,0);
	t[now].siz=1;
	return now;
}
void del(RE int k){
	if(ls) del(ls);
	if(rs) del(rs);
	stk[++top]=k;
}
int build(RE int l,RE int r){
	if(l==r) return build(read());
	int x=build(l,mid),y=build(mid+1,r);
	return merge(x,y);
}
IN void del(RE int l,RE int r){
	RE int x,y,z;
	splits(rt,r,x,z);
	splits(x,l-1,x,y);
	del(y);
	rt=merge(x,z);
}
IN void cover(RE int l,RE int r,RE int c){
	RE int x,y,z;
	splits(rt,r,x,z);
	splits(x,l-1,x,y);
	cov(y,c);
	rt=merge(merge(x,y),z);
}
IN void reverse(RE int l,RE int r){
	RE int x,y,z;
	splits(rt,r,x,z);
	splits(x,l-1,x,y);
	rev(y);
	rt=merge(merge(x,y),z);
}
IN LL query(RE int l,RE int r){
	RE int x,y,z;
	splits(rt,r,x,z);
	splits(x,l-1,x,y);
	RE LL ret=t[y].s;
	rt=merge(merge(x,y),z);
	return ret;
}
IN LL maxs(RE int l,RE int r){
	RE int x,y,z;
	splits(rt,r,x,z);
	splits(x,l-1,x,y);
	LL ret=t[y].max;
	rt=merge(merge(x,y),z);
	return ret;
}
int main(){
	freopen("P2710.in","r",stdin);
	freopen("P2710.out","w",stdout);
	n=read(),m=read();
	rt=build(1,n);
	for(RE int i=1;i<=m;i++){
		scanf("%s",z);
		if(z[0]=='I'){
			RE int pos=read(),tot=read();
			RE int x,y;
			splits(rt,pos,x,y);
			rt=merge(merge(x,build(pos,pos+tot-1)),y);
		}else
		if(z[0]=='D'){
			RE int pos=read(),tot=read();
			del(pos,pos+tot-1);
		}else
		if(z[0]=='R'){
			RE int pos=read(),tot=read();
			reverse(pos,pos+tot-1);
		}else
		if(z[2]=='K'){
			RE int pos=read(),tot=read(),c=read();
			cover(pos,pos+tot-1,c);
		}else
		if(z[1]=='A'){
			RE int pos=read(),tot=read();
			printf("%lld\n",maxs(pos,pos+tot-1));
		}else
		if(strlen(z)>4){
			RE int pos=read(),tot=read();
			printf("%lld\n",query(pos,pos+tot-1));
		}
		else{
 			RE int pos=read();
			printf("%lld\n",query(pos,pos));
		}
	}
	return 0;
}
```
最后

# 保持一个平和的心态

---

## 作者：Refined_heart (赞：12)

蒟蒻的第一道$Splay$黑题，写一遍题解来复习下。

[R_h](https://www.cnblogs.com/h-lka/p/11516445.html)

题意很明显，要维护许多区间有关的操作。在$splay$中维护区间信息的方法也是和线段树差不多，可以维护标记的。这里提一下：

对于区间$[l,r]$，我们要对它们进行操作，首先是要得到它们（端点）在$splay$树上的位置，即代码中的$Kth$函数。然后，我们可以把$l-1$转到根，
$r+1$转到根的右儿子，这样$r+1$的左儿子就是我们要进行操作的区间了。

把它们转化一下，我们要旋转的区间就变成了$[l,r+2]$.

那一个一个操作来吧。

$Insert$

嗯，笔者直接暴力依次插入的。其实还有更好的办法，笔者学习中，有时间会补。把每一个节点插入到$x+1$的位置就好了。

$Delete$

这个比较简单，直接把上面的操作区间（注意是我们的操作区间而不是题目给的编号）和上面一样操作，之后把$R$的左子树删掉就行了。

下面，均以$L=Kth(l),R=Kth(r+2)$

$Reverse$

$Splay$基本操作，直接对要修改的区间打上标记，维护一下$pushup$和$pushdown$即可。本题维护的标记很多，注意一下。

这里修改的区间也像上面一样，转到根在打标记。

$MAKE-SAME$

区间覆盖，打上标记即可，注意这个标记的优先级比$rev$高，因为区间都覆盖了，值都一样就没必要翻转了。

$GET-SUM$

树上维护区间和$sum$即可。

$GET$

单点查询，直接输出$tr[Kth(x+1)].val$即可。

$MAX-SUM$

区间最大子段和，带修改，本题难点。

这里学习一下$nlogn$的方法。

树上维护$ls,rs,ms$,分别表示前缀最大段和，后缀最大段和以及本区间的最大子段和。

那么我们可以维护它们了。具体看代码吧。在$pushup$部分。

$Code:$

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<string>
using namespace std;
const int inf=2147483647;
int n,m,id,rt;
inline int read(){
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		s=(s<<1)+(s<<3)+(ch^48);
		ch=getchar();
	}
	return s*w;
}
char opt[20];
struct node{
	int ch[2],val,sum,rev;
	int tag,fa,ls,ms,rs,siz;
}tr[500010];
inline void swap(int &x,int &y){x^=y^=x^=y;}
inline void pushup(int x){
	int lc=tr[x].ch[0],rc=tr[x].ch[1];
	tr[x].sum=tr[x].val+tr[lc].sum+tr[rc].sum;
	tr[x].siz=tr[lc].siz+tr[rc].siz+1;
	tr[x].ls=max(tr[lc].ls,tr[lc].sum+tr[x].val+tr[rc].ls);//注意子段和的维护 
	tr[x].rs=max(tr[rc].rs,tr[lc].rs+tr[rc].sum+tr[x].val);//可以自己理解一下，比较难描述 
	tr[x].ms=max(tr[lc].ms,max(tr[rc].ms,tr[lc].rs+tr[x].val+tr[rc].ls));
	//前缀就等于左孩子的前缀 和左孩子的全部加上x的值加上右孩子的前缀的max 
	//后缀就等于右孩子的后缀 和左孩子的后缀加上x的值加上右孩子的全部的max
	//上面的全部即sum
	//那么区间最大子段和就是代码上所说的
	//等于左孩子的最大子段和，右孩子的最大子段和，左孩子后缀加x的值加右孩子前缀的最大值。 
} 
inline void pushdown(int x){
	int lc=tr[x].ch[0],rc=tr[x].ch[1];
	if(tr[x].tag!=-inf){
		int p=tr[x].tag;
		if(lc){
			tr[lc].val=tr[lc].tag=p;
			tr[lc].sum=p*tr[lc].siz;
			if(p>=0)tr[lc].ls=tr[lc].rs=tr[lc].ms=tr[lc].sum;
			else tr[lc].ls=tr[lc].rs=0,tr[lc].ms=p;
		}
		if(rc){
			tr[rc].val=tr[rc].tag=p;
			tr[rc].sum=p*tr[rc].siz;
			if(p>=0)tr[rc].ls=tr[rc].rs=tr[rc].ms=tr[rc].sum;
			else tr[rc].ls=tr[rc].rs=0,tr[rc].ms=p;
		}
		tr[x].tag=-inf,tr[x].rev=0;
	}
	if(tr[x].rev){
		tr[x].rev=0;
		tr[lc].rev^=1;
		tr[rc].rev^=1;
		swap(tr[lc].ls,tr[lc].rs);
		swap(tr[rc].ls,tr[rc].rs);
		swap(tr[lc].ch[0],tr[lc].ch[1]);
		swap(tr[rc].ch[0],tr[rc].ch[1]);
	}
}
inline void rotate(int x){
	int y=tr[x].fa,z=tr[y].fa,k=tr[y].ch[1]==x;
	tr[z].ch[tr[z].ch[1]==y]=x;tr[x].fa=z;
	tr[y].ch[k]=tr[x].ch[k^1];tr[tr[x].ch[k^1]].fa=y;
	tr[x].ch[k^1]=y;tr[y].fa=x;pushup(y);pushup(x);
}
inline void splay(int x,int g){
	while(tr[x].fa!=g){
		int y=tr[x].fa,z=tr[y].fa;
		if(z!=g)
			(tr[y].ch[0]==x)^(tr[z].ch[0]==y)?rotate(x):rotate(y);
		rotate(x);
	}
	if(!g)rt=x;
}
inline int Kth(int x){
	int u=rt;
	if(!x)return 0;
	while(u){
		pushdown(u);
		int y=tr[u].ch[0];
		if(tr[y].siz>=x)u=y;
		else{
			x-=tr[y].siz+1;
			if(!x)return u;
			u=tr[u].ch[1];
		}
	}
	return 0;
}
inline void Ins(int x,int val){
	int F=Kth(x);splay(F,0);
	int p=++id;
	tr[p].siz=1;tr[p].val=tr[p].sum=val;
	tr[p].ms=val;tr[p].rev=0;tr[p].tag=-inf;
	tr[p].fa=F;tr[p].siz=1;
	if(val>=0)tr[p].ls=tr[p].rs=val;
	if(F){
		tr[p].ch[1]=tr[F].ch[1];
		tr[tr[F].ch[1]].fa=p;
		tr[F].ch[1]=p;pushup(p);
		pushup(F);
	}
	splay(p,0);
}
inline void change(int x,int y){
	int L=Kth(x),R=Kth(y+2);
	splay(L,0);splay(R,L);
	int g=tr[R].ch[0];
	if(tr[g].tag==-inf){
		tr[g].rev^=1;
		swap(tr[g].ls,tr[g].rs);
		swap(tr[g].ch[0],tr[g].ch[1]);
	}
	pushup(R);pushup(L);
}
inline int Get(int x,int y){
	int L=Kth(x),R=Kth(y+2);
	splay(L,0);splay(R,L);
	return tr[tr[R].ch[0]].sum;
}
inline void Del(int x,int y){
	int L=Kth(x),R=Kth(y+2);
	splay(L,0);splay(R,L);
	tr[R].ch[0]=0;
	pushup(R);pushup(L);
}
inline void Make(int x,int y,int z){
	int L=Kth(x),R=Kth(y+2);
	splay(L,0);splay(R,L);
	int g=tr[R].ch[0];
	tr[g].val=z;tr[g].tag=z;
	tr[g].sum=tr[g].siz*z;
	if(z>=0)tr[g].ls=tr[g].rs=tr[g].ms=tr[g].sum;
	else tr[g].ls=tr[g].rs=0,tr[g].ms=z;
	pushup(R);pushup(L);
}
inline int Get_pos(int x){
	return tr[Kth(x+1)].val;
}
int main(){
	tr[0].ms=-99999999;
	n=read(),m=read();
	Ins(0,-99999999);
	for(int i=1,x;i<=n;++i){
		scanf("%d",&x);
		Ins(i,x);
	}
	int x,y,l,r,tot;
	Ins(n+1,-99999999);
	while(m--){
		cin>>opt;
		if(opt[0]=='I'){
			x=read(),tot=read();
			for(int i=1;i<=tot;++i){
				x++;
				y=read();
				Ins(x,y);
			}
		}
		else if(opt[0]=='R'){
			l=read(),r=read();
			r=l+r-1;
			change(l,r);
		}
		else if(opt[0]=='G'){
			if(strlen(opt)>4){
				l=read(),r=read();
				r=l+r-1;
				if(r<l){
					printf("0\n");
					continue;
				}
				else printf("%d\n",Get(l,r));
			}
			else{
				x=read();
				printf("%d\n",Get_pos(x));
			}
		}
		else if(opt[0]=='D'){
			l=read(),r=read();
			r=l+r-1;
			Del(l,r);
		}
		else if(opt[0]=='M'){
			if(opt[2]=='K'){
				l=read(),r=read(),x=read();
				r=l+r-1;
				Make(l,r,x);
				continue;
			}
			else{
				l=read(),r=read();
				r=l+r-1;
				int L=Kth(l),R=Kth(r+2);
				splay(L,0);splay(R,L);
				cout<<tr[tr[R].ch[0]].ms<<endl;
			}
		}
	}
	return 0;
}
```
笔者对于$Splay$的认识也不够到位，若有错误或问题请评论指出，不胜感激。

---

## 作者：command_block (赞：4)

~~Leafy Tree终于翻身了!~~

## Leafy Tree大法吼！

Leafy Tree在我的印象中，一直是一个比较冷门的东西。

我与Leafy Tree的故事：[Link](https://www.luogu.org/paste/r6ljp3iv)(Link里面的文章可能有助于理解本文)

我几乎没有看到有大佬拿Leafy Tree来做区间树的题。

~~我的Leafy Tree题解也总是咕咕~~

不过这道题有一句话：“数据随机生成”

这就很妙了，我们很容易证明$SLT$在随机数据下是$O(mlogn)$的。

这东西和线段树有极大的相似性，pushup和ladd都相当的好写！

代码超短的！

跑的超快的（虽然自带2的大常数，而且没快读）！

(码风极端不良，仅用于作Leafy Tree研究的参考)

```cpp
#include<algorithm>
#include<cstdio>
#define Maxn 500500
using namespace std;
int n,m;
struct Node{
  int l,r,c,x,ls,rs,s;
  //c:大小域; x:区间和; 
  //ls:左边开始的最大子区间和;
  //rs:右边开始的最大子区间和; 
  //s:最大子区间和;
  bool tag,fi;int fill;
  //tag:是否反转;
  //fi:是否覆盖;
  inline void ladd()
  {
    swap(ls,rs);
    swap(l,r);
    tag^=1;
    //辅助推翻转懒标记
  }
  inline void _fill(int num)
  {
    x=c*num;
    if (num>0)
      ls=rs=s=c*num;
    else ls=rs=s=num;
    fill=num;
    fi=1;
    //辅助推覆盖懒标记
  }
}a[Maxn<<1];
int wfc,wfl,wfr,tn,root;
int top,rubbish[Maxn<<1];
inline int create()
{
  if (!top)return ++tn;
  int pos=rubbish[top--];
  a[pos].l=a[pos].r=a[pos].c=a[pos].fill=0;
  a[pos].x=a[pos].s=a[pos].ls=a[pos].rs=0;
  a[pos].fi=a[pos].tag=0;
  return pos;
  //含有垃圾回收
}
//pushup
inline void up(int num)
{
  int l=a[num].l,r=a[num].r;
  a[num].c=a[l].c+a[r].c;
  a[num].x=a[l].x+a[r].x;
  a[num].ls=max(a[l].x+a[r].ls,a[l].ls);
  a[num].rs=max(a[r].x+a[l].rs,a[r].rs);
  a[num].s=max(a[l].s,max(a[r].s,a[l].rs+a[r].ls));
}
//下推懒标记
inline void ladd(int num)
{
  if (a[num].fi){
  	a[num].fi=a[num].tag=0;
    a[a[num].l]._fill(a[num].fill);
    a[a[num].r]._fill(a[num].fill);
  }
  if (a[num].tag){
    a[num].tag=0;
    a[a[num].l].ladd();
    a[a[num].r].ladd();
  }
}
int tl,tr,tm,left[2550],middle[2550],right[2550];
//把树分裂成三个森林
void spilt(int l,int r,int num)
{
  if (r<wfl)left[++tl]=num;
  else if (wfl<=l&&r<=wfr)middle[++tm]=num;
  else if (wfr<l)right[++tr]=num;
  else {
  	ladd(num);
    int mid=l+a[a[num].l].c-1;
    spilt(l,mid,a[num].l);
    spilt(mid+1,r,a[num].r);
    rubbish[++top]=num;
  }
}
int _marge(int x,int y)
{
  if (!x||!y)return x+y;
  int num=create();
  a[num].l=x;a[num].r=y;
  up(num);
  return num;
}
int t[10500],ttn;
//三个森林合成一棵树
void marge()
{
  ttn=0;
  for (int i=1;i<=tl;i++)t[ttn++]=left[i];
  for (int i=1;i<=tm;i++)t[ttn++]=middle[i];
  for (int i=1;i<=tr;i++)t[ttn++]=right[i];
  while(ttn>1){
    for (int i=0;i<((ttn+1)>>1);i++)
     t[i]=_marge(t[i<<1],t[i<<1|1]);
    for (int i=(ttn+1)>>1;i<=ttn;i++)t[i]=0;
    ttn=(ttn+1)>>1;
  }root=t[0];
}
int xx[Maxn];
//建立平衡二叉树
void build(int l,int r,int num)
{
  //printf("%d %d %d\n",l,r,num);
  if (l==r){
    a[num].ls=a[num].rs=a[num].s=a[num].x=xx[l];
    a[num].c=1;
    return ;
  }int mid=(l+r)>>1;
  build(l,mid,a[num].l=create());
  build(mid+1,r,a[num].r=create());
  up(num);
}
Node ans[2550];
int tans;
//把区间的对应点COPY出来
void query(int l,int r,int num)
{
  ladd(num);
  if (wfl<=l&&r<=wfr){
    ans[++tans]=a[num];
    return ;
  }int mid=l+a[a[num].l].c-1;
  if (wfl<=mid)query(l,mid,a[num].l);
  if (wfr>mid)query(mid+1,r,a[num].r);
}
//回收某棵子树
void del(int num)
{
  if (!num)return ;
  rubbish[++top]=num;
  del(a[num].l);
  del(a[num].r);
}
char ord[10];
int main()
{
  scanf("%d%d",&n,&m);
  for (int i=1;i<=n;i++)scanf("%d",&xx[i]);
  build(1,n,root=tn=1);
  for (int i=1;i<=m;i++){
    scanf("%s%d",ord,&wfl);

    //GET
    if (ord[0]=='G'&&ord[3]==0){
      wfr=wfl;tans=0;
      query(1,a[root].c,root);
      printf("%d\n",ans[1].x);

    }else if (ord[0]=='I'){
      //INSERT
      scanf("%d",&wfr);
      for (int i=1;i<=wfr;i++)
        scanf("%d",&xx[i]);
      int rt=create();
      build(1,wfr,rt);

      wfr=wfl;
      tl=tr=tm=0;
      spilt(1,a[root].c,root);
      middle[++tm]=rt;
      marge();
 
    }else if (ord[0]=='D'||ord[0]=='R'||(ord[0]=='M'&&ord[2]=='K')){
 
      scanf("%d",&wfr);
      wfr=wfl+wfr-1;
      tl=tr=tm=0;
      spilt(1,a[root].c,root);
      if (ord[0]=='D'){
	    for (int i=1;i<=tm;i++)del(middle[i]);
	    tm=0;//DEL
      }else if (ord[0]=='R'){
      	for (int i=1;i<=tm;i++)xx[i]=middle[i];
        for (int i=1;i<=tm;i++){
          middle[i]=xx[tm-i+1];
          a[middle[i]].ladd();
        }//REVERSE
      }else if (ord[0]=='M'&&ord[2]=='K'){
        int tmp;
        scanf("%d",&tmp);
        for (int i=1;i<=tm;i++)
         a[middle[i]]._fill(tmp);
        //MAKE-SAME
      }marge();

    }else if ((ord[0]=='M'&&ord[2]=='X')||(ord[0]=='G'&&ord[3]!=0)){
      //MAX-SUM & GET-SUM
      scanf("%d",&wfr);
      wfr=wfl+wfr-1;
      tans=0;
      query(1,a[root].c,root);
      for (int i=2;i<=tans;i++){
        int l=i-1,r=i,num=i;
        ans[num].s=max(ans[l].s,max(ans[r].s,ans[l].rs+ans[r].ls));
        ans[num].ls=max(ans[l].x+ans[r].ls,ans[l].ls);
        ans[num].rs=max(ans[r].x+ans[l].rs,ans[r].rs);
        ans[num].x=ans[l].x+ans[r].x;
      }if (ord[0]=='M'&&ord[2]=='X')printf("%d\n",ans[tans].s);
      else printf("%d\n",ans[tans].x);
    }
  }return 0;
}
```

一开始垃圾桶开小了调了一年……

[AC记录](https://www.luogu.org/recordnew/show/17381916)

---

## 作者：Illusory_dimes (赞：3)

（这是个[双倍经验](https://www.luogu.com.cn/problem/P2042)呀！
### 题目描述
维护一个可以支持插入、删除、翻转、区间赋值、求和、求值和求最大子段和操作的序列。（真·简洁）

### solution
基本不用什么神奇操作，平衡树硬上就行。（我用的 Splay ）

不太一样的是建树可以模仿线段树建法（据说会快一点）

------------

其中，

1.翻转，区间赋值来打两种标记。

2.求最大子段和要设最大子段和，最大前缀和最大后缀三种变量。（不太清楚的可以先去做做[小鲦逛公园](https://www.luogu.com.cn/problem/P4513)）

------------

再注意一下，

1.下传标记时，先区间赋值再翻转。

（因为区间赋值改变 $val$ ，翻转改变 $id$ ， $id$ 要影响 $val$ ）

2.翻转时，最大前缀和最大后缀要交换。

（因为翻转后，后面的到了前面，前面的到了后面，顺序改变了）

3.平时讲的把一个区间 $[l,r]$ 拉出来是通过把区间外前面的第一个点拉到根后再将区间外后面的第一个点拉到根右孩子树的根上。

实际操作时下标要集体右移一位，因为如果区间为整个数组时要把 $0$ 拉到根上去，那不就乱了吗！

其实上述情况打[文艺平衡树](https://www.luogu.com.cn/problem/P3391)的时候就有了，但再次注意的是这题输入的 $posi$ 和 $tot$ 也要在表示区间的时候进行下标的转化。

------------

具体的看看代码吧（马蜂可看，比较清奇，但是长死了，有点烦）

```cpp
#include<bits/stdc++.h>
#define ls(i) spl[i].ch[0]//左孩子
#define rs(i) spl[i].ch[1]//右孩子
#define fa(i) spl[i].fa//粑粑
#define val(i) spl[i].val//点权值
#define num(i) spl[i].num//子树权值和
#define siz(i) spl[i].siz//字数大小
#define lzy(i) spl[i].lzy//翻转标记
#define mdf(i) spl[i].mdf//区间赋值标记
#define mx(i) spl[i].mx//最大子段和
#define lmx(i) spl[i].lmx//最大前缀
#define rmx(i) spl[i].rmx//最大后缀
//看把孩子逼的
#define reg register
using namespace std;
typedef long long ll;
const int N=1e6+10;
const int INF=0x3f3f3f3f;
int n,m,root,cnt,a[N],id[N];
char s[24];
queue<int> que;
struct Splay{int ch[2],fa,val,num,siz,lzy,mdf,mx,lmx,rmx;}spl[N];
inline int imax(int a,int b){return a>b?a:b;}
inline int read(){
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline void pushup(int now){
	siz(now)=siz(ls(now))+siz(rs(now))+1;
	num(now)=num(ls(now))+num(rs(now))+val(now);
	int plu=rmx(ls(now))+lmx(rs(now))+val(now);
	mx(now)=imax(imax(mx(ls(now)),mx(rs(now))),plu);
	lmx(now)=imax(lmx(ls(now)),lmx(rs(now))+num(ls(now))+val(now));
	rmx(now)=imax(rmx(rs(now)),rmx(ls(now))+num(rs(now))+val(now));
}
inline void pushdown(int now){
	if(mdf(now)){
		mdf(now)=lzy(now)=0;
		if(ls(now)){
			mdf(ls(now))=1;val(ls(now))=val(now);
			num(ls(now))=siz(ls(now))*val(ls(now));
		}
		if(rs(now)){
			mdf(rs(now))=1;val(rs(now))=val(now);
			num(rs(now))=siz(rs(now))*val(rs(now));
		}
		if(val(now)>0){
			if(ls(now))mx(ls(now))=lmx(ls(now))=rmx(ls(now))=num(ls(now));
			if(rs(now))mx(rs(now))=lmx(rs(now))=rmx(rs(now))=num(rs(now));
		}
		else {
			if(ls(now))mx(ls(now))=val(ls(now)),lmx(ls(now))=rmx(ls(now))=0;
			if(rs(now))mx(rs(now))=val(rs(now)),lmx(rs(now))=rmx(rs(now))=0;
		}
	}
	if(lzy(now)){
		lzy(ls(now))^=1;lzy(rs(now))^=1;lzy(now)^=1;
		swap(ls(ls(now)),rs(ls(now)));
		swap(ls(rs(now)),rs(rs(now)));
		swap(lmx(ls(now)),rmx(ls(now)));
		swap(lmx(rs(now)),rmx(rs(now)));
	}
}
inline void rotate(int now){
	int nxt=fa(now),nnt=fa(nxt);
	int k1=rs(nxt)==now,k2=rs(nnt)==nxt;
	int pre=spl[now].ch[k1^1];
	spl[nnt].ch[k2]=now;	fa(now)=nnt;
	spl[nxt].ch[k1]=pre;	fa(pre)=nxt;
	spl[now].ch[k1^1]=nxt;	fa(nxt)=now;
	pushup(nxt);pushup(now);
}//虽然肯定会跑得慢，但真tm好看
inline void splay(int now,int S){
	while(fa(now)!=S){
		int nxt=fa(now),nnt=fa(nxt);
		int k1=rs(nxt)==now,k2=rs(nnt)==nxt;
		if(nnt!=S)(k1^k2)?rotate(now):rotate(nxt);
		rotate(now);
	}
	if(!S)root=now;
}
inline void build(int lt,int rt,int mi){
	if(lt>rt)return ;
	int mid=(lt+rt)>>1,now=id[mid],pre=id[mi];
	if(lt==rt){
		siz(now)=1;
		if(a[lt]>0)mx(now)=lmx(now)=rmx(now)=a[lt];
		else mx(now)=a[lt],lmx(now)=rmx(now)=0;
	}
	else {
		build(lt,mid-1,mid);
		build(mid+1,rt,mid);
	}
	val(now)=a[mid];fa(now)=pre;
	pushup(now);
	spl[pre].ch[mid>=mi]=now;
}
inline int find(int now,int siz){
	pushdown(now);
	int sizz=siz(ls(now));
	if(siz<=sizz)return find(ls(now),siz);
	else if(siz==sizz+1)return now;
	else return find(rs(now),siz-sizz-1);
}
inline void insert(int now,int sum){
	for(int i=1;i<=sum;++i){
		a[i]=read();
		if(!que.empty()){
			id[i]=que.front();
			que.pop();
		}
		else {
			id[i]=++cnt;
		}
	}
	build(1,sum,0);
	int mid=(1+sum)>>1,it=id[mid];
	int lt=find(root,now+1);
	int rt=find(root,now+2);
	splay(lt,0);splay(rt,lt);
	ls(rt)=it;fa(it)=rt;
	pushup(rt);pushup(root);
}
inline void split(int now){
	if(!now)return ;
	split(ls(now));split(rs(now));
	que.push(now);
	ls(now)=rs(now)=val(now)=num(now)=siz(now)=0;
	lzy(now)=mdf(now)=mx(now)=lmx(now)=rmx(now)=0;
}
inline int divid(int lt,int rt){
	lt=find(root,lt);rt=find(root,rt);
	//一定要返回去看，因为这些坐标是提前对应好的
	splay(lt,0);splay(rt,lt);
	return ls(rt);
}
inline void delet(int lt,int rt){
	int now=divid(lt,rt),nxt=fa(now);
	split(now);
	ls(nxt)=0;
	pushup(nxt);pushup(root);
}
inline void modify(int lt,int rt,int val){
	int now=divid(lt,rt),nxt=fa(now);
	mdf(now)=1;val(now)=val;
	num(now)=siz(now)*val(now);
	if(val>0)mx(now)=lmx(now)=rmx(now)=num(now);
	else mx(now)=val,lmx(now)=rmx(now)=0;
	pushup(nxt);pushup(root);
}
inline void reverse(int lt,int rt){
	int now=divid(lt,rt),nxt=fa(now);
	if(!mdf(now)){
		lzy(now)^=1;
		swap(ls(now),rs(now));
		swap(lmx(now),rmx(now));
		pushup(nxt);pushup(root);
	}
}
inline int getsum(int lt,int rt){
	int now=divid(lt,rt);
	return num(now);
}
inline int getmxs(int lt,int rt){
	lt=find(root,lt);rt=find(root,rt);
	//一定要返回去看，因为这些坐标是提前对应好的
	splay(lt,0);splay(rt,lt);
	return mx(ls(rt));
}
inline int getnum(int lt){
	lt=find(root,lt+1);
	return val(lt);
}
int main(){
	n=read();m=read();
	for(int i=2;i<=n+1;++i){
		a[i]=read();id[i]=i;
	}
	mx(0)=a[1]=a[n+2]=-INF;id[1]=1;id[n+2]=n+2;
	//因为不能存0，所以集体右移一位了
	build(1,n+2,0);cnt=n+2;root=(cnt+1)>>1;
	while(m--){
		scanf("%s",s);
		if(s[0]=='I'){
			int posi=read(),tot=read();
			insert(posi,tot);
		}
		else if(s[0]=='D'){
			int posi=read(),tot=read();
			delet(posi,posi+tot+1);
		}
		else if(s[2]=='K'){
			int posi=read(),tot=read(),c=read();
			modify(posi,posi+tot+1,c);
		}
		else if(s[0]=='R'){
			int posi=read(),tot=read();
			reverse(posi,posi+tot+1);
		}
		else if(s[0]=='G'&&s[3]=='-'){
			int posi=read(),tot=read();
			printf("%d\n",getsum(posi,posi+tot+1));
		}
		else if(s[0]=='M'&&s[3]=='-'){
			int posi=read(),tot=read();
			printf("%d\n",getmxs(posi,posi+tot+1));
		}
		else {
			int posi=read();
			printf("%d\n",getnum(posi));
		}
	}
	return 0;
}
```

### 忠告：做这题的时候，佛系一点总不会错（为什么放最后呀。。）

---

## 作者：VenusM1nT (赞：3)

平衡树。看了一下，一共 $3$ 篇题解，两篇写的是 $\text{Splay}$，只有一篇是 $\text{FHQ Treap}$，而且用的还是万恶的**指针**，我这种完全不会指针的就超级懵逼了。万幸的是及时发现这道题和 [`P2042 [NOI2005]维护数列`](https://www.luogu.org/problemnew/show/P2042) 是基本一样的（其实刚开始看题面就发现了），只是要把 $\text{MAX-SUM}$ 这个操作稍微改一下，然后加一个很无脑的 $\text{GET}$ 操作就行了。

注意点：

 1. 写一个垃圾桶防止爆内存
 2. 用快读
 3. $\text{Split}$ 的时候按照 $siz$ 来 $\text{Split}$
 
其他就没什么了，就是下传标记的时候比较多，别的就是一些基本操作了。

```cpp
#include<bits/stdc++.h>
#define MAXN 500005
#define inf 2e9
using namespace std;
struct FHQTreap
{
	int son[2],siz,val,maxn,lmax,rmax,rev,sum,cov,key;
}t[MAXN];
queue <int> q;
int n,m,root,a[MAXN],siz,stk[MAXN],top;
template <typename T> void Read(T &x)
{
    int fu=1;
    x=0;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') fu=-1;
    for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch-48);
    x*=fu;
}
int NewNode(int val)
{
	int x;
	if(!q.empty())
	{
		x=q.front();
		q.pop();
	}
	else x=++siz;
	t[x].son[0]=t[x].son[1]=t[x].rev=0;
	t[x].cov=inf;
	t[x].key=rand();
	t[x].siz=1;
	t[x].val=t[x].sum=t[x].maxn=val;
	t[x].lmax=t[x].rmax=max(val,0);
	return x;
}
void Update(int x)
{
	if(t[x].son[0] && t[x].son[1])
	{
		t[x].siz=t[t[x].son[0]].siz+t[t[x].son[1]].siz+1;
		t[x].sum=t[t[x].son[0]].sum+t[t[x].son[1]].sum+t[x].val;
		t[x].maxn=max(t[t[x].son[0]].maxn,t[t[x].son[1]].maxn);
		t[x].maxn=max(t[x].maxn,t[t[x].son[0]].rmax+t[t[x].son[1]].lmax+t[x].val);	
		t[x].lmax=max(t[t[x].son[0]].lmax,t[t[x].son[0]].sum+t[t[x].son[1]].lmax+t[x].val);
		t[x].rmax=max(t[t[x].son[1]].rmax,t[t[x].son[1]].sum+t[t[x].son[0]].rmax+t[x].val);
	}
	else if(t[x].son[0])
	{
		t[x].siz=t[t[x].son[0]].siz+1;
		t[x].sum=t[t[x].son[0]].sum+t[x].val;
		t[x].maxn=max(t[t[x].son[0]].maxn,t[t[x].son[0]].rmax+t[x].val);
		t[x].lmax=max(t[t[x].son[0]].lmax,t[t[x].son[0]].sum+t[x].val);
		t[x].lmax=max(t[x].lmax,0);
		t[x].rmax=max(t[t[x].son[0]].rmax+t[x].val,0);
	}
	else if(t[x].son[1])
	{
		t[x].siz=t[t[x].son[1]].siz+1;
		t[x].sum=t[t[x].son[1]].sum+t[x].val;
		t[x].maxn=max(t[t[x].son[1]].maxn,t[t[x].son[1]].lmax+t[x].val);
		t[x].rmax=max(t[t[x].son[1]].rmax,t[t[x].son[1]].sum+t[x].val);
		t[x].rmax=max(t[x].rmax,0);
		t[x].lmax=max(t[t[x].son[1]].lmax+t[x].val,0);
	}
	else
	{
		t[x].siz=1;
		t[x].sum=t[x].maxn=t[x].val;
		t[x].lmax=t[x].rmax=max(t[x].val,0);
	}
}
void reverse(int x)
{
	swap(t[x].son[0],t[x].son[1]);
	swap(t[x].lmax,t[x].rmax);
	t[x].rev^=1;
}
void Change(int x,int val)
{
	t[x].val=val;
	t[x].sum=t[x].siz*val;
	t[x].lmax=t[x].rmax=max(t[x].sum,0);
	t[x].maxn=max(t[x].sum,t[x].val);
	t[x].cov=val;
}
void PushDown(int x)
{
	if(t[x].rev)
	{
		if(t[x].son[0]) reverse(t[x].son[0]);
		if(t[x].son[1]) reverse(t[x].son[1]);
	}
	if(t[x].cov!=inf)
	{
		if(t[x].son[0]) Change(t[x].son[0],t[x].cov);
		if(t[x].son[1]) Change(t[x].son[1],t[x].cov);
	}
	t[x].rev=0;
	t[x].cov=inf;
}
int BuildFHQTreap(int sum)
{
	memset(stk,0,sizeof(stk));
	top=0;
	int x,lat;
	for(int i=1;i<=sum;i++)
	{
		x=NewNode(a[i]);
		lat=0;
		while(top && t[stk[top]].key>t[x].key)
		{
			Update(stk[top]);
			lat=stk[top];
			stk[top--]=0;
		}
		if(top) t[stk[top]].son[1]=x;
		t[x].son[0]=lat;
		stk[++top]=x;
	}
	while(top) Update(stk[top--]);
	return stk[1];
}
int Merge(int x,int y)
{
	if(x) PushDown(x);
	if(y) PushDown(y);
	if(!x || !y) return x+y;
	if(t[x].key<t[y].key)
	{
		t[x].son[1]=Merge(t[x].son[1],y);
		Update(x);
		return x;
	}
	else
	{
		t[y].son[0]=Merge(x,t[y].son[0]);
		Update(y);
		return y;
	}
}
void Split(int rt,int pos,int &x,int &y)
{
	if(!rt) x=y=0;
	else
	{
		PushDown(rt);
		if(t[t[rt].son[0]].siz>=pos)
		{
			y=rt;
			Split(t[rt].son[0],pos,x,t[rt].son[0]);
		}
		else
		{
			x=rt;
			Split(t[rt].son[1],pos-t[t[rt].son[0]].siz-1,t[rt].son[1],y);
		}
		Update(rt);
	}
}
void Recycle(int x)
{
	if(!x) return;
	q.push(x);
	Recycle(t[x].son[0]);
	Recycle(t[x].son[1]);
}
void Insert()
{
	int pos,sum,x,y;
	Read(pos);
	Read(sum);
	for(int i=1;i<=sum;i++) scanf("%d",&a[i]);
	int rt=BuildFHQTreap(sum);
	Split(root,pos,x,y);
	root=Merge(Merge(x,rt),y);
}
void Delete()
{
	int pos,sum,ax,ay,bx,by;
	Read(pos);
	Read(sum);
	Split(root,pos-1,ax,bx);
	Split(bx,sum,ay,by);
	root=Merge(ax,by);
	Recycle(ay);
}
void Modify()
{
	int pos,sum,val,ax,ay,bx,by;
	Read(pos);
	Read(sum);
	Read(val);
	Split(root,pos-1,ax,bx);
	Split(bx,sum,ay,by);
	Change(ay,val);
	root=Merge(ax,Merge(ay,by));
}
void Reverse()
{
	int pos,sum,ax,ay,bx,by;
	Read(pos);
	Read(sum);
	Split(root,pos-1,ax,bx);
	Split(bx,sum,ay,by);
	reverse(ay);
	root=Merge(ax,Merge(ay,by));
}
void GetSum()
{
	int pos,sum,ax,ay,bx,by;
	Read(pos);
	Read(sum);
	Split(root,pos-1,ax,bx);
	Split(bx,sum,ay,by);
	printf("%d\n",t[ay].sum);
	root=Merge(ax,Merge(ay,by));
}
void GetPoint()
{
	int pos,x,y,z;
	Read(pos);
	Split(root,pos,x,z);
	Split(x,pos-1,x,y);
	printf("%d\n",t[y].val);
	root=Merge(Merge(x,y),z);
}
void GetMax()
{
	int pos,sum,ax,ay,bx,by;
	Read(pos);
	Read(sum);
	Split(root,pos-1,ax,bx);
	Split(bx,sum,ay,by);
	printf("%d\n",t[ay].maxn);
	root=Merge(ax,Merge(ay,by));
}
int main()
{
	Read(n);
	Read(m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	root=BuildFHQTreap(n);
	for(int i=1;i<=m;i++)
	{
		string s;
		cin>>s;
		if(s=="INSERT") Insert();
		else if(s=="DELETE") Delete();
		else if(s=="MAKE-SAME") Modify();
		else if(s=="REVERSE") Reverse();
		else if(s=="GET-SUM") GetSum();
		else if(s=="GET") GetPoint();
		else if(s=="MAX-SUM") GetMax();
	}
	return 0;
}
```

---

## 作者：KobeBeanBryantCox (赞：1)

# P2710 数列 题解

---------------

[题目传送门](https://www.luogu.com.cn/problem/P2042)。

# 块状链表！！！

虽然是块状链表但是比大多数平衡树都跑得快！

-------------

## 题意

略。

-------------

## 思路

首先我们想到了平衡树。

但是~~为了显得与众不同一点~~，我偏偏就要用块状链表。

首先块状链表的常规操作读者们在[这里](https://blog.csdn.net/qq_30115697/article/details/90046629)看吧，我参考了这里的写法（这篇文章不是我写的，侵权请联系删除）。

考虑剩下几个操作。

首先根据[这个题](https://www.luogu.com.cn/problem/SP1716)类似的操作，每个块要记录 $\texttt{sum,lis,llis,rlis}$，表示块和、LIS、从左往右的 LIS 和从右往左的 LIS。

分裂和合并的时候需要对块暴力重新计算上述东西，复杂度正确是因为我们一次修改只会至多两次分裂和合并。

然后要给每一个块打上 $\texttt{rev}$ 和 $\texttt{cov}$ 标记，下传的时候规定 $\texttt{cov}$ 优先级高。

考虑翻转。

把散块分裂成两个，然后就变成全部都是整块了。

整块打翻转标记，并且颠倒顺序即可。

考虑求 LIS。

同样的把散块分裂成两个，然后就变成全部都是整块了。

然后不是很好描述，看代码吧（其中所有整块的编号保存在 $vec$ 中，$ans$ 即为答案）：

```cpp
int ans=a[vec[0]].lis,maxx=a[vec[0]].rlis;
for(int i=1;i<vec.size();i++)
{
	ans=max(ans,max(a[vec[i]].lis,maxx+a[vec[i]].llis));
	maxx=max(maxx+a[vec[i]].sum,a[vec[i]].rlis);
}
return ans;
```

求和和查询区间和就是整块加，散块暴力即可，不需要分裂块。

有一个单点查，其实等价于区间查，长度为 $1$ 而已。

然后注意特判每一个操作，在同一个块内的情况，暴力修改即可。

块的大小取 $B=\sqrt n$，时间复杂度大约是 $O(n\sqrt n)$，常数比平衡树小得多。

------------

## AC 代码

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
int in()
{
	int k=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
	return k*f;
}
void out(int x)
{
	if(x<0)putchar('-'),x=-x;
	if(x<10)putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
const int N=2e5+10,B=447;
struct block_list
{
	struct node
	{
		int siz,nex;int s[B<<2];
		int sum,lis,llis,rlis;
		int rev,cov;
		node(){cov=2e9;} // 注意不能是 0
	}a[B<<2];
	int bin[N],tot;
	int newnode(){return bin[tot--];}
	void del(int x)
	{
		bin[++tot]=x;
		a[x].siz=a[x].sum=a[x].lis=a[x].llis=a[x].rlis=0,a[x].nex=-1;
		a[x].rev=0,a[x].cov=2e9;
	}
	block_list()
	{
		for(int i=1;i<N;i++)bin[++tot]=N-i;
		a[0].nex=-1;
	}
	int pos(int &p)
	{
		int x=0;
		for(;x!=-1&&a[x].siz<p;x=a[x].nex)p-=a[x].siz;
		return x;
	}
	void pushdown(int x)
	{
		if(a[x].cov!=2e9)
		{
			for(int i=0;i<a[x].siz;i++)a[x].s[i]=a[x].cov;
			a[x].cov=2e9,a[x].rev=0;
			return;
		}
		if(!a[x].rev)return;
		for(int i=0,j=a[x].siz-1;i<j;i++,j--)swap(a[x].s[i],a[x].s[j]);
		a[x].rev=0;
	}
	void pushup(int x)
	{
		a[x].sum=a[x].lis=a[x].llis=a[x].rlis=0;
		int n=a[x].siz;
		if(n==0)return;
		for(int i=0;i<n;i++)a[x].sum+=a[x].s[i];
		a[x].llis=a[x].s[0];
		for(int i=1,ss=a[x].s[0]+a[x].s[1];i<n;i++,ss+=a[x].s[i])a[x].llis=max(a[x].llis,ss);
		a[x].rlis=a[x].s[n-1];
		for(int i=n-2,ss=a[x].s[n-1]+a[x].s[n-2];i>=0;i--,ss+=a[x].s[i])a[x].rlis=max(a[x].rlis,ss);
		a[x].lis=a[x].s[0];
		for(int i=1,ss=a[x].s[0];i<n;i++)ss=max(ss,0)+a[x].s[i],a[x].lis=max(a[x].lis,ss);
	}
	void add(int x,int y,int len,int *s)
	{
		if(y!=-1)
		{
			pushdown(y);
			a[y].siz=len,a[y].nex=a[x].nex;
			memcpy(a[y].s,s,len*sizeof(int));
			pushup(y);
		}
		a[x].nex=y;
	}
	void merge(int x,int y)
	{
		pushdown(x),pushdown(y);
		memcpy(a[x].s+a[x].siz,a[y].s,a[y].siz*sizeof(int));
		a[x].siz+=a[y].siz,a[x].nex=a[y].nex,pushup(x),del(y);
	}
	void split(int x,int pos)
	{
		if(x==-1||pos==a[x].siz)return;
		int t=newnode();
		pushdown(x);
		add(x,t,a[x].siz-pos,a[x].s+pos);
		a[x].siz=pos,pushup(x);
	}
	void insert(int x,int len,int *s)
	{
		if(len==0)return;
		int now=pos(x),nex=now,tot=0,t=-1;
		split(now,x);
		for(;tot+B<=len;tot+=B)
		{
			t=newnode();
			add(nex,t,B,s+tot);
			nex=t;
		}
		if(tot<len)t=newnode(),add(nex,t,len-tot,s+tot);
		if(nex!=0&&t!=-1&&a[nex].siz+a[t].siz<=B)merge(nex,t);
		if(t!=-1&&a[t].nex!=-1&&a[t].siz+a[a[t].nex].siz<=B)merge(t,a[t].nex);
		if(now!=0&&a[now].nex!=-1&&a[now].siz+a[a[now].nex].siz<=B)merge(now,a[now].nex);
	}
	void erase(int x,int len)
	{
		if(len==0)return;
		int now=pos(x);split(now,x-1);
		int nex=a[now].nex;len--;
		for(;nex!=-1&&len>=a[nex].siz;nex=a[nex].nex)len-=a[nex].siz;
		if(nex!=-1)split(nex,len+1),nex=a[nex].nex;
		for(int i=a[now].nex;i!=nex;i=a[now].nex)a[now].nex=a[i].nex,del(i);
		for(;nex!=-1&&a[now].siz+a[nex].siz<=B;nex=a[nex].nex)merge(now,nex);
	}
	void modify(int p1,int len,int v)
	{
		if(len==0)return;
		int p2=p1+len-1;
		int bl=pos(p1),br=pos(p2);
		if(bl==br)
		{
			pushdown(bl);
			for(int i=p1-1;i<p2;i++)a[bl].s[i]=v;
			pushup(bl);return;
		}
		for(int i=a[bl].nex;i!=br;i=a[i].nex)
		{
			a[i].cov=v;
			a[i].sum=v*a[i].siz;
			if(v<0)a[i].lis=a[i].llis=a[i].rlis=v;
			else a[i].lis=a[i].llis=a[i].rlis=a[i].sum;
		}
		pushdown(bl),pushdown(br);
		for(p1--;p1<a[bl].siz;p1++)a[bl].s[p1]=v;
		for(p2--;p2>=0;p2--)a[br].s[p2]=v;
		pushup(bl),pushup(br);
	}
	void reverse(int p1,int len)
	{
		if(len==0)return;
		int p2=p1+len-1;
		int bl=pos(p1),br=pos(p2);
		if(bl==br)
		{
			pushdown(bl);
			for(int i=p1-1,j=p2-1;i<j;i++,j--)swap(a[bl].s[i],a[bl].s[j]);
			pushup(bl);return;
		}
		split(bl,p1-1),split(br,p2);
		int nowl=a[bl].nex,nowr=br;br=a[br].nex;
		vector<int>vec;
		a[bl].nex=-1;
		for(int i=nowl;i!=br;)
		{
			a[i].rev^=1;
			swap(a[i].llis,a[i].rlis);
			vec.push_back(i);
			int t=a[i].nex;
			a[i].nex=-1,i=t;
		}
		for(int i=bl,j=vec.size()-1;j>=0;i=a[i].nex,j--)a[i].nex=vec[j];
		a[vec[0]].nex=br;
		if(a[bl].siz+a[a[bl].nex].siz<=B)merge(bl,a[bl].nex);
		if(!vec.empty()&&br!=-1&&a[vec[0]].siz+a[br].siz<=B)merge(vec[0],br);
	}
	int querysum(int p1,int len)
	{
		if(len==0)return 0;
		int p2=p1+len-1,ans=0;
		int bl=pos(p1),br=pos(p2);
		if(bl==br)
		{
			pushdown(bl);
			for(int i=p1-1;i<p2;i++)ans+=a[bl].s[i];
			return ans;
		}
		for(int i=a[bl].nex;i!=br;i=a[i].nex)ans+=a[i].sum;
		pushdown(bl),pushdown(br);
		for(p1--;p1<a[bl].siz;p1++)ans+=a[bl].s[p1];
		for(p2--;p2>=0;p2--)ans+=a[br].s[p2];
		return ans;
	}
	int querylis(int p1,int len)
	{
		int p2=p1+len-1;
		int bl=pos(p1),br=pos(p2);
		if(bl==br)
		{
			pushdown(bl);
			int ans=a[bl].s[p1-1],maxx=ans;
			for(int i=p1;i<p2;i++)
			{
				maxx=max(maxx,0)+a[bl].s[i];
				ans=max(ans,maxx);
			}
			return ans;
		}
		split(bl,p1-1),split(br,p2);
		int nowl=a[bl].nex,nowr=br;br=a[br].nex;
		vector<int>vec;
		for(int i=nowl;i!=br;i=a[i].nex)vec.push_back(i);
		if(vec.empty())return 0;
		if(vec.size()==1)return a[vec[0]].lis;
		int ans=a[vec[0]].lis,maxx=a[vec[0]].rlis;
		for(int i=1;i<vec.size();i++)
		{
			ans=max(ans,max(a[vec[i]].lis,maxx+a[vec[i]].llis));
			maxx=max(maxx+a[vec[i]].sum,a[vec[i]].rlis);
		}
		if(a[bl].siz+a[a[bl].nex].siz<=B)merge(bl,a[bl].nex);
		if(br!=-1&&a[nowr].siz+a[br].siz<=B)merge(nowr,br);
		return ans;
	}
}seq;
int tmp[N];
int main()
{
	int n=in(),m=in();
	for(int i=0;i<n;i++)tmp[i]=in();
	seq.insert(0,n,tmp);
	while(m--)
	{
		string s="";char c=getchar();
		while(!isalpha(c))c=getchar();
		while(isalpha(c)||c=='-')s.push_back(c),c=getchar();
		int pos=0,tot=0;
		if(s!="GET")pos=in(),tot=in();
		if(s=="INSERT")
		{
			for(int i=0;i<tot;i++)tmp[i]=in();
			seq.insert(pos,tot,tmp);
		}
		else if(s=="DELETE")seq.erase(pos,tot);
		else if(s=="MAKE-SAME")seq.modify(pos,tot,in());
		else if(s=="REVERSE")seq.reverse(pos,tot);
		else if(s=="GET-SUM")out(seq.querysum(pos,tot)),putchar('\n');
		else if(s=="GET")out(seq.querysum(in(),1)),putchar('\n');
		else out(seq.querylis(pos,tot)),putchar('\n');
	}
	return 0;
}
```

其实挺难调的，细节超多。

有个[双倍经验](https://www.luogu.com.cn/article/h4hlps39)，也差不多。

--------------

如果有错误或者不清楚欢迎评论或私信指出。

---

## 作者：Rui_R (赞：1)

提供一份以指针实现的Splay题解。

题意：需要维护维护7种操作：插入一个区间，区间删除，区间反转，区间赋值，区间求和，单点求和，区间最大子段和。

我们一个一个研究。

首先，**插入一个区间**。要是真就一个一个往里面塞，既不优雅也不优秀，恐怕要原地升天。我们可以把要插入的区间先建成一颗Splay，再把新建的Splay的根结点塞到它该去的地方。这样复杂度就下来了。

具体的，采用类似线段树的方法， **二分建树** ，$O(n)$得到一颗**完美**的Splay。

接着将目标结点 $pos$ 伸展至根，将 $pos+1$ 伸展至根的右儿子。

然后将得到的完美Splay的根结点，塞到 $pos+1$ 的左儿子处，解决。

**删除一个区间：** 正常来说，若目标区间为$(l,r)$，只需要把$(l-1)$伸展至根，再将$(r+1)$伸展至根的右儿子，再把$(r+1)$的左儿子标空即可。但如果只是这样，有可能会炸空间。毕竟没有回收删掉的点，若出现多次大范围插入和删除，空间大概就炸了。

因此，还需要一次深搜来回收利用区间$(l,r)$内的点。如果你是非指针选手，可以开一个垃圾桶数组来回收利用这些点的编号，新建点时优先将垃圾桶内点的编号赋给点。而对于指针选手来说，直接```delete now;```系统就会认为可以再次使用该空间。

通过上述的时间换空间，解决。

**区间反转：** 对于每个结点维护一个标记（在我的代码中被称作Crimson），意为这个点的所有子结点都需要反转，每次遇到一个被标记的点时，先下传标记（即将其左右孩子Crimson取反，因为反转两次等于没反转，同时分别交换它左右孩子的左右孩子）

具体实现就是通过伸展$(l-1)$,$(r+1)$来得到目标区间的子树，并给目标区间子树的根结点打上标记且交换其左右孩子。解决。

**区间赋值：** 大致与区间反转相同，也是通过维护标记的方式进行。不过下传标记时其优先级高于反转，因为都变成一样的了，还需要什么反转呢？当然要翻也可以，不过没有意义。

得到目标区间的子树后将其根结点的权值改掉，并给它打上标记，意为其下面所有点都应该被改掉。解决。

**区间求和：** 没什么好说的，对于每个结点维护以其为根的子树的权值和。通过伸展得到目标区间后输出代表目标区间的子树的权值和。解决。单点求和同理。

**区间最大子段和：** 用分治的思想。

我们知道对于一个结点now,其代表的区间是由他自己，他左儿子代表的区间，他右儿子代表的区间组成的。那么对于每个结点维护一下三个值：$prel,prer,res$

$prel$：从该结点代表区间的最左边开始的最大连续子段和。

$prer$: 从该结点代表区间的最右边开始的最大连续子段和。

$res:$ 在该结点代表的区间中的最大连续字段和。

显然，对于一个结点来说，其$res$有三种可能：左孩子的$res$，右孩子的$res$，左孩子的$prer$加上右孩子的$prel$加上该结点本身的价值。

而对于$prel$有```prel=max(prel,now->l->sum+now->val+r->prel);```

$prer$类似。按照上述思路去维护$prel$，$prer$，$res$，最终答案为目标区间根结点的$res$。

**要注意区间反转会导致$prel,prer$交换。**

题目未指明其区间最大子段和是否能为空，我默认不能。代码能够通过此题。实测若能为空会WA。

这道题就是上述所有操作的大杂烩，写起来细节繁杂琐碎，着实不容易。若能通过此题，相信对平衡树的熟练度会有很大提升。

另外，这道题数据比较善良，不会出现$n=0$这种丧心病狂的情况。请放心。而他的兄弟P2042维护数列，就是另外一个故事了......

$\text{Talk is cheap,show me your code.}$
```
#include <cstdio>

const int maxn=2e5+5,inf=1e9+7;
#define null 0

struct IO{
	IO(){};char c;
	inline char gc(){
		static char buf[maxn],*p1=buf,*p2=buf;
		return p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;
	}
	inline IO&operator>>(int &_){
		_=0;bool f=1;c=gc();while(c<'0'||c>'9'){if(c=='-') f=0; c=gc();}
		while(c>='0'&&c<='9'){_=_*10+c-48;c=gc();}if(!f) _=-_;return *this;
	}
	inline IO&operator<<(int x){
		if(!x){putchar(48);putchar('\n');return *this;}
		static int wt[40],len;len=0;if(x<0){putchar('-');x=-x;}
		for(;x;x/=10){wt[++len]=x%10;}
		while(len){putchar(wt[len--]+48);}
		putchar('\n');return *this;
	}
	inline IO&operator>>(char s[]){
		c=gc();int len=0;while(c==' '||c=='\n'||c=='\r') c=gc();
		while(c!=' '&&c!='\n'&&c!='\r'&&c!='\0'){s[++len]=c;c=gc();}
		s[++len]='\0';return *this;
	}
	inline IO&operator<<(char s[]){
		for(int i=1;s[i]!='\0';i++) putchar(s[i]);
		putchar('\n');return *this;
	}
}io;

inline int max(int a,int b){
	return a>b?a:b;
}

template<typename T> inline void swap(T &a,T &b){
	T tmp=a;a=b;b=tmp;
}

struct node{
	node *son[2],*fa;
	int val,size;
	bool Crimson,tag;int res,pre_l,pre_r,sum;//Crimson意为其孩子是否需要反转，tag意为其孩子是否需要赋值
	node(int _val=0){
		son[0]=son[1]=fa;
		val=_val;size=1;
		Crimson=tag=res=pre_l=pre_r=0;
	}
	inline node* &lc(){return son[0];}
	inline node* &rc(){return son[1];}
	bool which(){return fa->rc()==this;}
	void push_down(){
		node *now=this;
		if(now==null) return;
		if(now->tag){//其孩子需要赋值
			if(now->lc()){
				now->lc()->tag=1,now->lc()->val=now->val,now->lc()->sum=now->lc()->size*now->val;
				if(val>=0) lc()->pre_l=lc()->pre_r=lc()->res=lc()->sum;
				else lc()->pre_l=lc()->pre_r=0,lc()->res=val;//本题解默认不能取空
			}//下传标记
			if(now->rc()){
				now->rc()->tag=1,now->rc()->val=now->val,now->rc()->sum=now->rc()->size*now->val;
				if(val>=0) rc()->pre_l=rc()->pre_r=rc()->res=rc()->sum;
				else rc()->pre_l=rc()->pre_r=0,rc()->res=val;
			}//下传标记
			now->tag=now->Crimson=0;//不再需要反转
		}
		if(now->Crimson){
			if(now->lc()) now->lc()->Crimson^=1;
			if(now->rc()) now->rc()->Crimson^=1;//下传
			if(lc()) swap(lc()->lc(),lc()->rc()),swap(lc()->pre_l,lc()->pre_r);
			if(rc()) swap(rc()->lc(),rc()->rc()),swap(rc()->pre_l,rc()->pre_r);//注意！！反转后pre_l,pre_r需交换！！
			now->Crimson=0;
		}
	}
	void update(){
		size=(lc()?lc()->size:0)+(rc()?rc()->size:0)+1;//更新大小
		sum=(lc()?lc()->sum:0)+(rc()?rc()->sum:0)+val;//更新权值和
		pre_l=max(lc()?lc()->pre_l:0,(lc()?lc()->sum:0)+val+(rc()?rc()->pre_l:0));
		pre_r=max(rc()?rc()->pre_r:0,(rc()?rc()->sum:0)+val+(lc()?lc()->pre_r:0));//更新pre_l,pre_r
		res=val+(lc()?lc()->pre_r:0)+(rc()?rc()->pre_l:0);
		res=max(max((lc()?lc()->res:-inf),(rc()?rc()->res:-inf)),res);//注意！！没有儿子时其res应被视作-inf而不是0！毕竟不能为空。
	}
	void init(){
		son[0]=son[1]=fa=null;
		size=1;Crimson=tag=res=pre_l=pre_r=sum=0;
	}
};

int n,m,a[maxn];

struct Splay{
	node *rt;
	Splay():rt(null){}
	node *build(int l,int r,node *FA){
		if(l>r) return null;
		int mid=(l+r)>>1;
		node *now=new node;now->init();now->val=a[mid];now->fa=FA;now->res=now->val;
		now->lc()=build(l,mid-1,now);
		now->rc()=build(mid+1,r,now);
		return now->update(),now;
	}//线段树式建树
	void rotate(node *now){
		node *FA=now->fa;bool pos=!now->which();
		FA->push_down(),now->push_down();
		FA->son[!pos]=now->son[pos];if(now->son[pos]) now->son[pos]->fa=FA;
		now->fa=FA->fa;if(now->fa) now->fa->son[FA->which()]=now;
		FA->fa=now;now->son[pos]=FA;
		FA->update(),now->update();if(now->fa==null) rt=now;
	}
	void splay(node *now,node *to=null){
		for(node *FA=now->fa;(FA=now->fa)!=to;rotate(now))
		if(FA->fa!=to) rotate(FA->which()==now->which()?FA:now);
	}//Splay基操
	node* find(int key){//找到下标为第key大的结点
		node *now=rt;
		while(1){
			now->push_down();
			int ls=(now->lc()?now->lc()->size:0);
			if(ls+1==key){splay(now);return now;}
			if(key<=ls) now=now->lc();
			else key-=ls+1,now=now->rc();
		}
	}
	node* split(int l,int r){//得到区间l，r的根
		node *L=find(l-1),*R=find(r+1);
		splay(L,null),splay(R,L);
		return R->lc();
	}
	void recycle(node *now){
		if(now==null) return;
		recycle(now->lc()),recycle(now->rc());
		delete now;//回收
	}
	void del(int l,int r){
		node *now=split(l,r);node *FA=now->fa;
		recycle(now);FA->lc()=null;//注意别写反，要是先标null在回收就出事了
		FA->update();FA->fa->update();
	}
	void modify(int l,int r,int key){//区间赋值
		node *now=split(l,r);
		now->val=key,now->tag=1,now->sum=key*now->size;
		if(key>=0) now->pre_l=now->pre_r=now->res=now->sum;
		else now->pre_l=now->pre_r=0,now->res=key;//默认不为空
		now->fa->update();rt->update();
	}
	void reserve(int l,int r){//区间反转
		node *now=split(l,r);
		if(now->tag==0){//要是区间赋值过，那么反转没有意义
			now->Crimson^=1;
			swap(now->pre_l,now->pre_r);
			swap(now->lc(),now->rc());
			now->fa->update();rt->update();
		}
	}
	int query_sum(int l,int r){
		node *now=split(l,r);
		return now->sum;
	}
	int query_maxx(int l,int r){
		node *now=split(l,r);
		return now->res;
	}
}s;

void insert(Splay &goal,int l,int r){
	node *L=goal.find(l),*R=goal.find(l+1);
	goal.splay(L,null),goal.splay(R,L);
	Splay tmp;
	R->lc()=tmp.build(l,r,R);//将tmp建成一颗完美Splay并插入l,l+1之间
	R->lc()->update();goal.splay(R);
}

int main(){
	io>>n>>m;
	for(int i=2;i<=n+1;i++) io>>a[i];a[1]=-inf,a[n+2]=-inf;//这里要是-inf！！因为子段不为空
	s.rt=s.build(1,n+2,null);//注意，要在第一个元素前和最后一个元素后各加一个元素
	//不然在处理区间(1,..)或(..,n)时会去旋转不存在的元素，从而喜提RE
	for(int i=1;i<=m;i++){
		char opt[50];io>>opt;
		int l,r;
		if(opt[1]=='I'){
			io>>l>>r;r+=l-1;
			for(int i=l+1;i<=r+1;i++) io>>a[i];
			insert(s,l+1,r+1);
		}
		if(opt[1]=='D'){
			io>>l>>r;r+=l-1;
			s.del(l+1,r+1);
		}
		if(opt[1]=='M'&&opt[3]=='K'){
			io>>l>>r;r+=l-1;
			int x;io>>x;
			s.modify(l+1,r+1,x);
		}
		if(opt[1]=='R'){
			io>>l>>r;r+=l-1;
			s.reserve(l+1,r+1);
		}
		if(opt[1]=='G'){
			if(opt[4]){
				io>>l>>r;r+=l-1;
				io<<s.query_sum(l+1,r+1);
			}
			else{
				io>>l;
				io<<s.query_sum(l+1,l+1);
			}
		}
		if(opt[1]=='M'&&opt[3]=='X'){
			io>>l>>r;r+=l-1;
			io<<s.query_maxx(l+1,r+1);
		}
	}
	return 0;
}//希望能够帮到您。
```

---

## 作者：蒟蒻初音ミク (赞：1)

# 广告

[蒟蒻的blog](https://www.luogu.com.cn/blog/111990/)

# 正文

# 传说中的Splay

双倍经验：[[NOI2005]维护数列](https://www.luogu.org/problem/P2042)

# 前置芝士：

## 0、变量：

上代码：
```cpp
#define L(x) tree[x].ch[0]
#define R(x) tree[x].ch[1]
#define V(x) tree[x].val
#define S(x) tree[x].sum
#define F(x) tree[x].fa
#define inf 10000001
#define N 1000000

struct node{
	int ch[2],//左右儿子
   fa,//父亲
   sum,//子树和
   size,//子树节点数
   val,//这个点的权值
   lmax,//前缀最大子段和
   rmax,//后缀最大子段和
   zmax,//总最大子段和
   lazy_rev,//旋转懒标记
   lazy_cov;//覆盖懒标记
	inline void clear(){ch[0]=ch[1]=fa=lazy_rev=0;lazy_cov=inf;}//清空函数
}tree[N+10];
```


首先，对于splay的基本操作：

## 1、splay（伸展操作）

其实说白了就是把某一个节点转到根节点而已，重点是rotate函数。

上代码：

```cpp
inline void splay(int x,int goal)
{
	int y,z;
	while(F(x)!=goal)
	{
		y=F(x),z=F(y);
		if(z!=goal)(R(z)==y)^(R(y)==x)?rotate(x):rotate(y);
		rotate(x);
	}
	up(x);
	if(!goal)root=x;//这里一定不要忘了更新root
}
```

## 2、rotate函数

含义：把x节点变成他的父亲节点的父亲，他原来的父亲节点变成他的儿子。

（即旋转操作）

上代码：

```cpp
inline void rotate(int x)
{
	int y=F(x),z=F(y),k=R(y)==x,w=tree[x].ch[k^1];
	down(y),down(x);//注意懒标记
	if(z)tree[z].ch[R(z)==y]=x;
	tree[x].ch[k^1]=y;tree[y].ch[k]=w;
	if(w)F(w)=y;F(y)=x;F(x)=z;
	up(y);up(x);
}
```
~~（码风过于丑陋）~~

## 3、kth查询操作

其实就是一个二叉搜索树的查询排名的函数。

上代码：

```cpp
inline int kth(int t,int k)
{
	down(t);//注意懒标记
	if(tree[L(t)].size>=k)return kth(L(t),k);
	else if(tree[L(t)].size+1==k)return t;
	else return kth(R(t),k-tree[L(t)].size-1);
}
```

## 4、回收空间

因为这道题插入的数有很多，而我们有空间限制，所以我们要回收空间。（即把每一个Delete操作删除的节点回收利用起来）

```cpp
int rub[N+10],top=0;//装被删除的节点

inline int rubbish(){return top?rub[top--]:++tot;}
```

## 5、split分离区间

其实原理非常简单：
![](https://cdn.luogu.com.cn/upload/image_hosting/ve7qf30x.png)
然后我们就成功地把[3,4]区间用一个子树表示出来了。

```cpp
inline int split(int k,int len)
{
	int x=kth(root,k),y=kth(root,k+len+1);
   //因为我的splay在最开始处理边界的时候在开头插入了一个-inf，所以整个数组都向后移动了一格
	splay(x,0);splay(y,x);
	return L(y);//返回值为区间所表示子树的根节点
}
```

## 6、pushup

就是我们splay里面更新父亲节点的操作，但是这里维护的信息较多，所以单独拉出来说一下。

```cpp
inline void up(int t)
{
	int l=L(t),r=R(t);
	S(t)=S(l)+V(t)+S(r);//更新子树和
	tree[t].size=tree[l].size+tree[r].size+1;//更新子树节点数
	tree[t].lmax=max(tree[l].lmax,S(l)+V(t)+tree[r].lmax);//更新
	tree[t].rmax=max(tree[r].rmax,S(r)+V(t)+tree[l].rmax);
	tree[t].zmax=max(max(tree[l].zmax,tree[r].zmax),tree[l].rmax+V(t)+tree[r].lmax);
	F(l)=F(r)=t;
}
```



上面是基本操作。

接下来是这道题的解法。

# 正文：

## 1、insert

其实这个我们完全可以暴力合并，但是这个样子时间复杂度为O(n*logn)，会炸掉。（因为有4000000个数）

所以我们要把插入变成O(n)的。（即总时间复杂度为插入数的个数）

怎么变呢？？？我们就把插入的数O(n)地变成一个二叉树，然后直接接到原来的splay里面。

```cpp
inline void build(int l,int r,int fa)
{
	int mid=l+r>>1,now=id[mid],pre=id[fa];tree[now].clear();
	if(l==r)
	{
		V(now)=S(now)=tree[now].zmax=a[mid];
		tree[now].size=1;
		tree[now].lmax=tree[now].rmax=max(a[mid],0);
	}
	V(now)=a[mid];
	if(l<mid)build(l,mid-1,mid);
	if(mid<r)build(mid+1,r,mid);
	up(now);
	tree[pre].ch[mid>=fa]=now;
}

inline void insert(int k,int len)
{
	for(re int i=1;i<=len;++i)scanf("%d",&a[i]);//读入
	for(re int i=1;i<=len;++i)id[i]=rubbish();//从回收站里面找一个没用的点来作为这个点的id
	build(1,len,0);int z=id[(1+len)>>1];
	int x=kth(root,k+1),y=kth(root,k+2);
	splay(x,0);splay(y,x);
	tree[y].ch[0]=z;up(y);up(x);
}
```

## 2、delete

删除操作，我们就先split出这个区间，然后把这个区间回收掉，再更新父亲节点。

```cpp
inline void remove(int t)
{
	if(L(t))remove(L(t));
	if(R(t))remove(R(t));
	tree[t].clear();rub[++top]=t;//清空+回收
}

inline void erase(int k,int len)
{
	int x=split(k,len),y=F(x);
	remove(x);tree[y].ch[0]=0;//把这个点清除掉
   	up(y);up(F(y));
}
```

## 3、reverse

翻转，我们就split出来，然后翻转就行了。

```cpp
inline void rev(int t)
{
	swap(tree[t].ch[0],tree[t].ch[1]);swap(tree[t].lmax,tree[t].rmax);tree[t].lazy_rev^=1;
}

inline void reverse(int k,int len)
{
	int x=split(k,len),y=F(x);
	rev(x);up(y);up(F(y));
}
```

## 4、make-same

这个就是我们cover覆盖操作，还是一样，split出来然后覆盖。

```cpp
inline void cov(int t,int x)
{
	if(!t)return;
	V(t)=tree[t].lazy_cov=x;
	S(t)=tree[t].size*x;
	tree[t].lmax=tree[t].rmax=max(0,S(t));
	tree[t].zmax=max(x,S(t));
}

inline void cover(int k,int len,int val)
{
	int x=split(k,len),y=F(x);
	cov(x,val);up(y);up(F(y));
}
```


## 5、get-sum

这个就是一个查询区间和的操作，还是一样，直接split+printf

```cpp
inline void query(int k,int len)
{
	int x=split(k,len);
	printf("%d\n",tree[x].sum);
}
```

# 尾声

最后上总代码：

## code

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

#define re register
#define ll long long
#define inf 10000002
#define L(x) tree[x].ch[0]
#define R(x) tree[x].ch[1]
#define V(x) tree[x].val
#define S(x) tree[x].sum
#define F(x) tree[x].fa
#define N 1000000

struct node{
	int ch[2],fa,sum,size,val,lmax,rmax,zmax,lazy_rev,lazy_cov;
	inline void clear(){ch[0]=ch[1]=fa=lazy_rev=0;lazy_cov=inf;}
}tree[N+10];int tot,root;

int rub[N+10],top=0;

inline int rubbish(){return top?rub[top--]:++tot;}

inline void rev(int t)
{
	swap(tree[t].ch[0],tree[t].ch[1]);swap(tree[t].lmax,tree[t].rmax);tree[t].lazy_rev^=1;
}

inline void cov(int t,int x)
{
	if(!t)return;
	V(t)=tree[t].lazy_cov=x;
	S(t)=tree[t].size*x;
	tree[t].lmax=tree[t].rmax=max(0,S(t));
	tree[t].zmax=max(x,S(t));
}

inline void down(int t)
{
	if(tree[t].lazy_rev)
	{
		rev(tree[t].ch[0]);rev(tree[t].ch[1]);
		tree[t].lazy_rev=0;
	}
	if(tree[t].lazy_cov!=inf)
	{
		cov(tree[t].ch[0],tree[t].lazy_cov);cov(tree[t].ch[1],tree[t].lazy_cov);
		tree[t].lazy_cov=inf;
	}
}

inline void up(int t)
{
	int l=L(t),r=R(t);
	S(t)=S(l)+V(t)+S(r);
	tree[t].size=tree[l].size+tree[r].size+1;
	tree[t].lmax=max(tree[l].lmax,S(l)+V(t)+tree[r].lmax);
	tree[t].rmax=max(tree[r].rmax,S(r)+V(t)+tree[l].rmax);
	tree[t].zmax=max(max(tree[l].zmax,tree[r].zmax),tree[l].rmax+V(t)+tree[r].lmax);
	F(l)=F(r)=t;
}

inline void rotate(int x)
{
	int y=F(x),z=F(y),k=R(y)==x,w=tree[x].ch[k^1];
	down(y),down(x);
	if(z)tree[z].ch[R(z)==y]=x;
	tree[x].ch[k^1]=y;tree[y].ch[k]=w;
	if(w)F(w)=y;F(y)=x;F(x)=z;
	up(y);up(x);
}

inline void splay(int x,int goal)
{
	int y,z;
	while(F(x)!=goal)
	{
		y=F(x),z=F(y);
		if(z!=goal)(R(z)==y)^(R(y)==x)?rotate(x):rotate(y);
		rotate(x);
	}
	up(x);
	if(!goal)root=x;
}

inline int kth(int t,int k)
{
	down(t);
	if(tree[L(t)].size>=k)return kth(L(t),k);
	else if(tree[L(t)].size+1==k)return t;
	else return kth(R(t),k-tree[L(t)].size-1);
}

inline int split(int k,int len)
{
	int x=kth(root,k),y=kth(root,k+len+1);
	splay(x,0);splay(y,x);
	return L(y);
}

int a[N+10],id[N+10];

inline void build(int l,int r,int fa)
{
	int mid=l+r>>1,now=id[mid],pre=id[fa];tree[now].clear();
	if(l==r)
	{
		V(now)=S(now)=tree[now].zmax=a[mid];
		tree[now].size=1;
		tree[now].lmax=tree[now].rmax=max(a[mid],0);
	}
	V(now)=a[mid];
	if(l<mid)build(l,mid-1,mid);
	if(mid<r)build(mid+1,r,mid);
	up(now);
	tree[pre].ch[mid>=fa]=now;
}

inline void insert(int k,int len)
{
	for(re int i=1;i<=len;++i)scanf("%d",&a[i]);
	for(re int i=1;i<=len;++i)id[i]=rubbish();
	build(1,len,0);int z=id[(1+len)>>1];
	int x=kth(root,k+1),y=kth(root,k+2);
	splay(x,0);splay(y,x);
	tree[y].ch[0]=z;up(y);up(x);
}

inline void remove(int t)
{
	if(L(t))remove(L(t));
	if(R(t))remove(R(t));
	tree[t].clear();rub[++top]=t;
}

inline void erase(int k,int len)
{
	int x=split(k,len),y=F(x);
	remove(x);tree[y].ch[0]=0;up(y);up(F(y));
}

inline void cover(int k,int len,int val)
{
	int x=split(k,len),y=F(x);
	cov(x,val);up(y);up(F(y));
}

inline void reverse(int k,int len)
{
	int x=split(k,len),y=F(x);
	rev(x);up(y);up(F(y));
}

inline void query(int k,int len)
{
	int x=split(k,len);
	printf("%d\n",tree[x].sum);
}

int n,m;

int main()
{
	scanf("%d%d",&n,&m);
	tree[0].zmax=-inf;a[1]=a[n+2]=-inf;
	for(re int i=1;i<=n;++i)scanf("%d",&a[i+1]);
	for(re int i=1;i<=n+2;++i)id[i]=rubbish();
	build(1,n+2,0);root=id[(n+3)>>1];
	char opt[10];int x,len,y;
	for(re int i=1;i<=m;++i)
	{
		scanf(" %s",opt);
		if(opt[0]=='M'&&opt[2]=='X')
		{
			scanf("%d%d",&x,&len);
			int t=split(x,len);
			printf("%d\n",tree[t].zmax);
			continue;
		}
		if(opt[0]=='G'&&strlen(opt)==3)
		{
			scanf("%d",&x);
			query(x,1);
			continue;
		}
		scanf("%d%d",&x,&len);
		if(opt[0]=='I')insert(x,len);
		else if(opt[0]=='D')erase(x,len);
		else if(opt[0]=='M'&&opt[2]=='K')scanf("%d",&y),cover(x,len,y);
		else if(opt[0]=='R')reverse(x,len);
		else if(opt[0]=='G'&&opt[3]=='-')query(x,len);
		else if(opt[0]=='G')query(x,1);
	}
	return 0;
}
```


# 后记

以后像这种很裸的平衡树的题一定要小心卡内存和代码细节~~（因为这种一般码量就是200行左右吧，如果哪个地方写错了的话，debug。。。）~~

Bingo~~

---

## 作者：良月澪二 (赞：1)

这种码农题

要的是可读性

没做过[维护数列](https://www.luogu.org/problemnew/show/P2042#sub)的就先不要做这个题了

有什么好说的？

没什么好说的

**用的fhq**

默认会了的人来看

瞅一瞅操作怎么写就好了
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <complex>
#include <algorithm>
#include <climits>
#include <queue>
#include <map>
#include <ctime>
#include <set>
#include <vector>
#include <iomanip>
#define A 1000010
#define B 2010
#define SIZ(x) (x ? x->siz : 0)
#define SUM(x) (x ? x->sum : 0)
#define LX(x) (x ? x->lx : -A)
#define RX(x) (x ? x->rx : -A)
#define MX(x) (x ? x->mx : -A)

using namespace std;
typedef long long ll;
int n, m, opt, xx, yy, zz, top;

struct TreapNode {
	TreapNode *lc, *rc;
	TreapNode() {}
	int siz, cv, val, rev, tag, lx, rx, mx, sum;
	TreapNode *update() {
		siz = SIZ(lc) + SIZ(rc) + 1;
		sum = SUM(lc) + SUM(rc) + val;
		lx = max(LX(lc), SUM(lc) + max(0, LX(rc)) + val);
		rx = max(RX(rc), SUM(rc) + max(0, RX(lc)) + val);
		mx = max(0, LX(rc)) + max(0, RX(lc)) + val;
		mx = max(mx, max(MX(lc), MX(rc)));
		return this;
	}
	void reverse() {
		swap(lc, rc);
		swap(lx, rx);
		rev ^= 1;
	}
	void cover(int x) {
		val = x;
		sum = x * siz;
		lx = rx = mx = max(sum, x);
		tag = x;
	}
	void down() {
		if (rev) {
			if (lc) lc->reverse();
			if (rc) rc->reverse();
			rev = 0;
		}
		if (tag != 2014) {
			if (lc) lc->cover(tag);
			if (rc) rc->cover(tag);
			tag = 2014;
		}
	}
}pool[A], *root, *tail = pool, *rec[A];
typedef TreapNode* Tr;
void recycle(Tr x) {
	rec[++top] = x;
}
void clear(Tr x) {
	if (x->lc) clear(x->lc);
	if (x->rc) clear(x->rc);
	recycle(x);
}
Tr newnode(int k) {
	Tr x;
	if (top) x = rec[top--];
	else x = tail++;
	x->cv = rand();
	x->val = x->sum = x->lx = x->rx = x->mx = k;
	x->siz = 1;
	x->lc = x->rc = NULL;
	x->rev = 0;
	x->tag = 2014;
	return x;
}
Tr merge(Tr x, Tr y) {
	if (!x) return y;
	if (!y) return x;
	if (x->cv < y->cv) {
		x->down();
		x->rc = merge(x->rc, y);
		x->update();
		return x;
	}
	else {
		y->down();
		y->lc = merge(x, y->lc);
		y->update();
		return y;
	}
}
void split(Tr now, int k, Tr &x, Tr &y) {
	if (!now) {
		x = y = NULL;
		return;
	}
	now->down();
	if (SIZ(now->lc) < k) {
		split(now->rc, k - SIZ(now->lc) - 1, x, y);
		now->rc = NULL;
		now->update();
		x = merge(now, x);
	}
	else {
		split(now->lc, k, x, y);
		now->lc = NULL;
		now->update();
		y = merge(y, now);
	}
}
Tr build(int a[], int lenth) {
	static Tr sta[A], pre, x;
	int cnt = 0;
	for (int i = 1; i <= lenth; i++) {
		x = newnode(a[i]);
		pre = NULL;
		while (cnt and sta[cnt]->cv > x->cv) {
			pre = sta[cnt]->update();
			sta[cnt--] = NULL;
		}
		if (cnt) sta[cnt]->rc = x;
		x->lc = pre;
		sta[++cnt] = x;
	}
	while (cnt) sta[cnt--]->update();
	return sta[1];
}
int tmp[A], a[A];
Tr insert(int pos, int lenth) {
	Tr x, y, tmpp;
	split(root, pos, x, y);
	for (int i = 1; i <= lenth; i++) scanf("%d", &tmp[i]);
	tmpp = build(tmp, lenth);
	return merge(merge(x, tmpp), y);
}
Tr dele(int l, int r) {
	Tr x, y, p, q;
	split(root, l - 1, x, y);
	split(y, r - l + 1, p, q);
	if (p) clear(p);
	return merge(x, q);
}
Tr mss(int l, int r, int val) {
	Tr x, y, p, q;
	split(root, l - 1, x, y);
	split(y, r - l + 1, p, q);
	if (p) p->cover(val);
	return merge(x, merge(p, q));
}
void asksum(int l, int r) {
	Tr x, y, p, q;
	split(root, l - 1, x, y);
	split(y, r - l + 1, p, q);
	int ans = 0;
	if (p) ans = SUM(p);
	root = merge(x, merge(p, q));
	printf("%d\n", ans);
}
Tr rever(int l, int r) {
	Tr x, y, p, q;
	split(root, l - 1, x, y);
	split(y, r - l + 1, p, q);
	if (p) p->reverse();
	return merge(x, merge(p, q));
}
void askmax(int l, int r) {
	Tr x, y, p, q;
	split(root, l - 1, x, y);
	split(y, r - l + 1, p, q);
	int ans = 0;
	if (p) ans = MX(p);
	root = merge(x, merge(p, q));
	printf("%d\n", ans);
}
void askpoint(int pos) {
	Tr x, y, z;
	split(root, pos, x, z);
	split(x, pos - 1, x, y);
	root = merge(merge(x, y), z);
	printf("%d\n", y->val);
}
int check(string a) {
	if (a == "INSERT") return 1;
	if (a == "DELETE") return 2;
	if (a == "REVERSE") return 3;
	if (a == "MAKE-SAME") return 4;
	if (a == "GET-SUM") return 5;
	if (a == "GET") return 6;
	if (a == "MAX-SUM") return 7;
	return 0;
}

int main() {
	srand(time(0));
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	root = build(a, n);
	while (m--) {
		string c;
		cin >> c;
		switch(check(c)) {
			case 0 : ;
			case 1 : scanf("%d%d", &xx, &yy); root = insert(xx, yy); break;
			case 2 : scanf("%d%d", &xx, &yy); root = dele(xx, xx + yy - 1); break;
			case 3 : scanf("%d%d", &xx, &yy); root = rever(xx, xx + yy - 1); break;
			case 4 : scanf("%d%d%d", &xx, &yy, &zz); root = mss(xx, xx + yy - 1, zz); break;
			case 5 : scanf("%d%d", &xx, &yy); asksum(xx, xx + yy - 1); break;
			case 6 : scanf("%d", &xx); askpoint(xx); break;
			case 7 : scanf("%d%d", &xx, &yy); askmax(xx, xx + yy - 1); break;
			default : break;
		}
	}
	return 0;
}
```

---

## 作者：斯德哥尔摩 (赞：1)

这题看上去很眼熟。。。

没错就是——[P2042[NOI2005]维护数列](https://www.luogu.org/problemnew/show/P2042)

~~于是如果做完了此题，可以稍稍修改一下代码去AC那题。~~

好，步入正题：

首先，要会一个很牛的黑科技——splay

可以先做 [P3369 【模板】普通平衡树](https://www.luogu.org/problemnew/show/P3369) 和 [P3391 【模板】文艺平衡树](https://www.luogu.org/problemnew/show/P3391) 

然后你会发现你已经会了此题的核心。。。

首先，对于原序列，我们如果一个一个读入，然后插入，那么效率就是O(nlogn),而splay的常数本身就很大，所以考虑一个优化，就是把原序列一次性读入后，直接类似线段树的build，搞一个整体建树，即不断的将当前点维护的区间进行二分，到达单元素区间后，就把对应的序列值插入进去，这样，我们一开始建的树就是一个非常平衡的树，可以使后续操作的常数更小，并且建树整个复杂度只是O(2n)的。

细节处理：

由于本题数据空间卡的非常紧，我们就需要用时间换空间，直接开4000000 * logm的数据是不现实的，但是由于题目保证了同一时间在序列中的数字的个数最多是500000，所以我们考虑一个回收机制，把用过但是已经删掉的节点编号记录到一个队列或栈中，在新建节点时直接把队列中的冗余编号搞过来就好了。

剩下的不会可以看看我的CSDN博客（我把两题的核心算法都写在了一篇博客里）：

[洛谷P2042 [NOI2005]维护数列](http://blog.csdn.net/yangrui2002/article/details/79568863)

[安利一下个人博客。](https://www.luogu.org/blog/49998/)

附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<queue>
#define MAXN 500010//其实2*10^5已经够了，只是想开大一点
#define MAX 999999999
using namespace std;
queue<int> q;//循环使用
int n,m,size=1,root,val[MAXN];
struct node{//这就是 splay
    int f,s,flag,set,son[2];
    int v,w,sum,suml,sumr;
}a[MAXN];
inline int read(){//读优
    int date=0,w=1;char c=0;
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
    return date*w;
}
inline void clean(int rt){//清空
    a[rt].son[0]=a[rt].son[1]=a[rt].f=a[rt].s=a[rt].flag=a[rt].v=a[rt].w=0;
    a[rt].sum=a[rt].suml=a[rt].sumr=-MAX;
}
inline void pushup(int rt){//上传
    if(!rt)return;
    a[rt].s=a[a[rt].son[0]].s+a[a[rt].son[1]].s+1;
    a[rt].w=a[a[rt].son[0]].w+a[a[rt].son[1]].w+a[rt].v;
    a[rt].suml=max(a[a[rt].son[0]].suml,a[a[rt].son[0]].w+a[rt].v+max(0,a[a[rt].son[1]].suml));
    a[rt].sumr=max(a[a[rt].son[1]].sumr,a[a[rt].son[1]].w+a[rt].v+max(0,a[a[rt].son[0]].sumr));
    a[rt].sum=max(a[rt].v+max(0,a[a[rt].son[0]].sumr)+max(0,a[a[rt].son[1]].suml),max(a[a[rt].son[0]].sum,a[a[rt].son[1]].sum));
}
inline void pushdown(int rt){//下传
    if(!rt)return;
    if(a[rt].set!=-MAX){
        if(a[rt].son[0]){
            a[a[rt].son[0]].set=a[a[rt].son[0]].v=a[rt].set;
            a[a[rt].son[0]].w=a[rt].set*a[a[rt].son[0]].s;
            a[a[rt].son[0]].suml=a[a[rt].son[0]].sumr=a[a[rt].son[0]].sum=max(a[a[rt].son[0]].set,a[a[rt].son[0]].w);
        }
        if(a[rt].son[1]){
            a[a[rt].son[1]].set=a[a[rt].son[1]].v=a[rt].set;
            a[a[rt].son[1]].w=a[rt].set*a[a[rt].son[1]].s;
            a[a[rt].son[1]].suml=a[a[rt].son[1]].sumr=a[a[rt].son[1]].sum=max(a[a[rt].son[1]].set,a[a[rt].son[1]].w);
        }
        a[rt].set=-MAX;
        a[rt].flag=0;//有了全部修改标记就不用翻转
    }
    if(a[rt].flag){
        if(a[rt].son[0]){
            a[a[rt].son[0]].flag^=1;
        	swap(a[a[rt].son[0]].suml,a[a[rt].son[0]].sumr);
            swap(a[a[rt].son[0]].son[0],a[a[rt].son[0]].son[1]);
        }
        if(a[rt].son[1]){
            a[a[rt].son[1]].flag^=1;
        	swap(a[a[rt].son[1]].suml,a[a[rt].son[1]].sumr);
            swap(a[a[rt].son[1]].son[0],a[a[rt].son[1]].son[1]);
        }
        a[rt].flag^=1;
    }
}
inline int newnode(int x){//建立新节点
    int rt;
    if(q.empty())rt=size++;
    else{//循环使用
        rt=q.front();
        q.pop();
    }
    a[rt].v=x;
    a[rt].suml=a[rt].sumr=a[rt].sum=-MAX;
    a[rt].flag=0;a[rt].set=-MAX;
    return rt;
}
inline void turn(int rt,int k){//旋转
    int x=a[rt].f,y=a[x].f;
    pushdown(x);pushdown(rt);
    a[x].son[k^1]=a[rt].son[k];
    if(a[rt].son[k])a[a[rt].son[k]].f=x;
    a[rt].f=y;
    if(y)a[y].son[a[y].son[1]==x]=rt;
    a[x].f=rt;
    a[rt].son[k]=x;
    pushup(x);pushup(rt);
}
void splay(int rt,int ancestry){//伸展
    while(a[rt].f!=ancestry){
        int x=a[rt].f,y=a[x].f;
        if(y==ancestry)turn(rt,a[x].son[0]==rt);
        else{
            int k=a[y].son[0]==x?1:0;
            if(a[x].son[k]==rt){turn(rt,k^1);turn(rt,k);}
            else{turn(x,k);turn(rt,k);}
        }
    }
    if(ancestry==0)root=rt;
}
int kth(int rt,int k){//找第k大值
    if(a[rt].s<k)return 0;
    while(1){
        pushdown(rt);//标记下传
        int y=a[rt].son[0];
        if(k>a[y].s+1){
            rt=a[rt].son[1];
            k-=a[y].s+1;
        }
        else if(k<=a[y].s)rt=y;
        else return rt;
    }
}
int buildtree(int l,int r){//建树
    if(l>r)return 0;
    int rt,mid=l+r>>1,lson=0,rson=0;
    lson=buildtree(l,mid-1);
    rt=newnode(val[mid]);
    rson=buildtree(mid+1,r);
    a[rt].son[0]=lson;
    a[rt].son[1]=rson;
    if(lson)a[lson].f=rt;
    if(rson)a[rson].f=rt;
    pushup(rt);
    return rt;
}
inline void split(int front,int next){//取出区间
    splay(front,0);splay(next,front);
}
inline void insert(int rt,int x,int y){//插入
    int front=kth(rt,x+1),next=kth(rt,x+2);
    split(front,next);
    int k=a[next].son[0];
    rt=buildtree(1,y);
    a[next].son[0]=rt;a[rt].f=next;
    pushup(next);pushup(front);
}
void delete_x(int rt){//递归删除
    if(!rt)return;
    q.push(rt);//不要忘了
    if(a[rt].son[0])delete_x(a[rt].son[0]);
    if(a[rt].son[1])delete_x(a[rt].son[1]);
    clean(rt);//一定是最后！！！
}
inline void remove(int rt,int l,int r){//删除
    int front=kth(rt,l),next=kth(rt,r+2);
    split(front,next);
    int k=a[next].son[0];
    if(k)delete_x(k);
    a[next].son[0]=0;
    pushup(next);pushup(front);
}
void reverge(int rt,int l,int r){//翻转
    int front=kth(rt,l),next=kth(rt,r+2);
    split(front,next);
    int k=a[next].son[0];
    if(!k)return;
    a[k].flag^=1;
    swap(a[k].son[0],a[k].son[1]);
    swap(a[k].suml,a[k].sumr);
    pushup(next);pushup(front);
}
void same(int rt,int l,int r,int x){//全部修改
    int front=kth(rt,l),next=kth(rt,r+2);
    split(front,next);
    int k=a[next].son[0];
    if(!k)return;
    a[k].set=a[k].v=x;
    a[k].w=x*a[k].s;
    a[k].suml=a[k].sumr=a[k].sum=max(x,a[k].w);
    pushup(next);pushup(front);
}
int main(){
    int x,y,k;
    char ch[20];
    n=read();m=read();
    for(int i=1;i<=n;i++)val[i]=read();
    val[0]=val[n+1]=0;
    clean(0);clean(n+1);
    root=buildtree(0,n+1);//多加了两个哨兵节点
    while(m--){//以下就是处理部分，比较基础
        scanf("%s",ch);x=read();
        switch(ch[0]){
            case 'I':{
                y=read();
                for(int i=1;i<=y;i++)val[i]=read();
                insert(root,x,y);
                break;
            }
            case 'D':y=read();remove(root,x,x+y-1);break;
            case 'R':y=read();reverge(root,x,x+y-1);break;
            case 'G':{
                if(ch[3]=='-'){
                    y=read();
    				int front=kth(root,x),next=kth(root,x+y+1);
                    split(front,next);
                    int k=a[next].son[0];
                    printf("%d\n",a[k].w);
                }
                else printf("%d\n",a[kth(root,x+1)].v);
                break;
            }
            case 'M':{
                y=read();
                if(ch[4]=='-'){
                	k=read();
                	same(root,x,x+y-1,k);
                }
                else{
    				int front=kth(root,x),next=kth(root,x+y+1);
                    split(front,next);
                    int k=a[next].son[0];
                    printf("%d\n",a[k].sum);
                }
                break;
            }
        }
    }
    return 0;
}//终于敲完了（215行，累死我了。。。）

```

---

## 作者：that_lemon (赞：0)

>区间操作集大成者……？

>可能吧……

by某位不愿意透露姓名的巨学
***
本题需要实现：
- INSERT
- DELETE
- REVERSE
- MAKE-SAME
- GET-SUM
- GET
- MAX-SUM

共七个操作

全部操作都涉及到序列

于是我们考虑使用splay或者FHQ-treap实现

这里使用FHQ-treap
***
前置芝士
- FHQ-treap

蛤？不会？左转度娘/必应娘/谷歌娘

- 区间翻转

左转P3391题解区，包教包会，不会不要钱~~本来就不要钱吧~~

- 最大子段和

左转P4513
***
非必要
- 笛卡尔树建树

实际上不用这个方法用暴力插入也能过，但可能需要卡卡常

- 卡常技巧
***
0.初始定义
```cpp
struct note {
	int val;//节点权值
	int rd;//优先值
	int siz;//子树大小
	int ch[2];//左右儿子
	int tag;//翻转标记
	int cvr;//make-same标记
	int sum;//区间和
	int lmax,rmax,mmax;//最大子段和
	note() {
		ch[0]=ch[1]=val=siz=sum=tag=0;
		cvr=inf;
	}
	inline void clear() {
		ch[0]=ch[1]=val=siz=sum=tag=0;
		cvr=inf;
	}
};
```
***
-1.信息上传，标记下放
```cpp
inline void up(int o) {
	int ls=t[o].ch[0],rs=t[o].ch[1];
	t[o].siz=t[ls].siz+t[rs].siz+1;
	t[o].sum=t[o].val+t[ls].sum+t[rs].sum;
	t[o].lmax=max(0,max(t[ls].lmax,t[ls].sum+t[rs].lmax+t[o].val));
	t[o].rmax=max(0,max(t[rs].rmax,t[rs].sum+t[ls].rmax+t[o].val));
	t[o].mmax=max(t[o].val,t[ls].rmax+t[rs].lmax+t[o].val);
	if (ls) {
		t[o].mmax=max(t[o].mmax,t[ls].mmax);
	}
	if (rs) {
		t[o].mmax=max(t[o].mmax,t[rs].mmax);
	}
}
inline void flip(int o) {
	swap(t[o].ch[0],t[o].ch[1]);
	swap(t[o].lmax,t[o].rmax);
	t[o].tag^=1;
}
inline void cvr(int o,int val) {
	t[o].cvr=t[o].val=val;
	t[o].sum=t[o].siz*val;
	t[o].mmax=max(t[o].val,t[o].sum);
	t[o].lmax=t[o].rmax=max(0,t[o].sum);
}
inline void down(int o) {
	int ls=t[o].ch[0],rs=t[o].ch[1];
	if (t[o].tag) {
		if (ls) {
			flip(ls);
		}
		if (rs) {
			flip(rs);
		}
	}
	if (t[o].cvr!=inf) {
		if (ls) {
			cvr(ls,t[o].cvr);
		}
		if (rs) {
			cvr(rs,t[o].cvr);
		}
	}
	t[o].tag=0;
	t[o].cvr=inf;
}
```
***

1.插入操作

第一个要实现的操作，然而并不是最简单的

我们可以选择暴力插入，但……

这样子做的时间复杂度是O(qlogn)的，其中q为插入序列中数的个数

如何优化？

笛卡尔树建树！

自行度娘具体方法，这里直接给出代码
```cpp
inline int build(int len,int a[]) {
	top=0;
	int temp=new_node(a[1]);
	stk[++top]=temp;
	for(int i=2;i<=len;i++) {
		int last=0;
		int cur=new_node(a[i]);
		while(top&&t[stk[top]].rd>t[cur].rd) {
			up(stk[top]);
			last=stk[top];
			stk[top--]=0;
		}
		t[cur].ch[0]=last;
		up(cur);
		if (top) {
			t[stk[top]].ch[1]=cur;
			up(stk[top]);
		}
		stk[++top]=cur;
	}
	while(top) {
		up(stk[top--]);
	}
	return stk[1];
}
```
返回的是新建树的根

有了这个函数，insert就非常好写了
```cpp
inline void insert(int pos,int len,int a[]) {
	int root1=build(len,a);
	int x,y;
	split(root,pos,x,y);
	root=merge(merge(x,root1),y);
}
```
时间复杂度O(q+logn),其中q为序列中数的个数
***
2.delete操作

把要删除的区间提取出来直接中序历删除即可

注意垃圾回收
```cpp
void recycle(int o) {
	int ls=t[o].ch[0],rs=t[o].ch[1];
	if (!o) {
		return;
	}
	if (ls) {
		recycle(ls);
	}
	trash.push(o);
	if (rs) {
		recycle(rs);
	}
}

inline void remove(int pos,int len) {
	int x,y,z,u;
	split(root,pos+len-1,x,y);
	split(x,pos-1,z,u);
	recycle(u);
	root=merge(z,y);
}
```
时间复杂度O(logn+q)
***
3.REVERSE操作

左转文艺平衡树

注意标记下放
```cpp
inline void reverse(int pos,int len) {
	int x,y,z,u;
	split(root,pos+len-1,x,y);
	split(x,pos-1,z,u);
	t[u].tag^=1;
	swap(t[u].lmax,t[u].rmax);
	swap(t[u].ch[0],t[u].ch[1]);
	root=merge(merge(z,u),y);
	return;
}
```
时间复杂度O(logn)
***
4.MAKE-SAME操作

全场最烦操作（因为要手动更新
```cpp
inline void cover(int pos,int len,int val) {
	int x,y,u,z;
	split(root,pos+len-1,x,y);
	split(x,pos-1,z,u);
	t[u].val=t[u].cvr=val;
	t[u].sum=val*t[u].siz;
	t[u].lmax=t[u].rmax=max(0,t[u].sum);
	t[u].mmax=max(t[u].val,t[u].sum);
	t[u].tag=0;
	root=merge(merge(z,u),y);
}
```
时间复杂度O(logn)
***
5.三大询问

因为代码都很无脑就放一起了

```cpp
inline int get_sum(int pos,int len) {
	int x,y,z,u;
	split(root,pos+len-1,x,y);
	split(x,pos-1,z,u);
	int ans=t[u].sum;
	root=merge(merge(z,u),y);
	return ans;
}
inline int get_max_sum(int pos,int len) {
	int x,y,z,u;
	split(root,pos+len-1,x,y);
	split(x,pos-1,z,u);
	int ans=t[u].mmax;
	root=merge(merge(z,u),y);
	return ans;
}
inline int ask_point(int pos) {
	int x,y,z,u;
	split(root,pos,x,y);
	split(x,pos-1,z,u);
	int ans=t[u].val;
	root=merge(merge(z,u),y);
	return ans;
}
```
时间复杂度O(logn)
***
最后，让我们看看核心函数：merge和split
```cpp
void split(int x,int k,int &a,int &b) {
	if (!x||!k) {
		a=0;
		b=x;
		return;
	}
	down(x);
	if (k>t[t[x].ch[0]].siz) {
		a=x;
		split(t[x].ch[1],k-t[t[x].ch[0]].siz-1,t[x].ch[1],b);
		up(x);
	} else {
		b=x;
		split(t[x].ch[0],k,a,t[x].ch[0]);
		up(x);
	}
}
int merge(int x,int y) {
	if (x) {
		down(x);
	}
	if (y) {
		down(y);
	}
	if (!x||!y) {
		return x^y;
	}
	if (t[x].rd<t[y].rd) {
		t[x].ch[1]=merge(t[x].ch[1],y);
		up(x);
		return x;
	} else {
		t[y].ch[0]=merge(x,t[y].ch[0]);
		up(y);
		return y;
	}
}
```
遵循原则：用时间换安全

具体来讲，在写这两个函数的时候，能上传下放就上传下放，保障安全
***
最后的最后，一点个人感想

前前后后调了半个寒假，还是很有收获的

up,down,merge,split四个核心函数一定要好好理解，不然一出bug就……

放总体代码 ~~我知道你们只想看这个~~

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cstdlib>
#include <ctime>
#include <queue>
#include <string>
using namespace std;

inline int Random() {
	return (rand()<<15)|rand();
}

inline void read(int &x) {
	x=0;
	int f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if (ch=='-') {
			f=-1;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	x*=f;
}

queue<int> trash;//????????
int root;//???????
const int inf=2e9;

struct note {
	int val;//??
	int rd;//???????
	int siz;//?????
	int ch[2];//???????
	int tag;//????????
	int cvr;//????????
	int sum;//???
	int lmax,rmax,mmax;//??????
	note() {
		ch[0]=ch[1]=val=siz=sum=tag=0;
		cvr=inf;
	}
	inline void clear() {
		ch[0]=ch[1]=val=siz=sum=tag=0;
		cvr=inf;
	}
};

int stk[500010],top;

struct fhq_treap {
	note t[200010];
	int cnt;
	//??????
	inline int q_malloc() {
		int x;
		return (!trash.empty()) ? (x=trash.front(),t[x].clear() , trash.pop() , x) : (++cnt);
	}
	//??????
	inline int new_node(int val) {
		int x=q_malloc();
		t[x].val=t[x].sum=t[x].mmax=val;
		t[x].lmax=t[x].rmax=max(0,val);
		t[x].rd=Random();
		t[x].siz=1;
		return x;
	}
	//?????
	inline void up(int o) {
		int ls=t[o].ch[0],rs=t[o].ch[1];
		t[o].siz=t[ls].siz+t[rs].siz+1;
		t[o].sum=t[o].val+t[ls].sum+t[rs].sum;
		t[o].lmax=max(0,max(t[ls].lmax,t[ls].sum+t[rs].lmax+t[o].val));
		t[o].rmax=max(0,max(t[rs].rmax,t[rs].sum+t[ls].rmax+t[o].val));
		t[o].mmax=max(t[o].val,t[ls].rmax+t[rs].lmax+t[o].val);
		if (ls) {
			t[o].mmax=max(t[o].mmax,t[ls].mmax);
		}
		if (rs) {
			t[o].mmax=max(t[o].mmax,t[rs].mmax);
		}
	}
	//????
	inline void flip(int o) {
		swap(t[o].ch[0],t[o].ch[1]);
		swap(t[o].lmax,t[o].rmax);
		t[o].tag^=1;
	}
	//????????????
	inline void cvr(int o,int val) {
		t[o].cvr=t[o].val=val;
		t[o].sum=t[o].siz*val;
		t[o].mmax=max(t[o].val,t[o].sum);
		t[o].lmax=t[o].rmax=max(0,t[o].sum);
	}
	//?????
	inline void down(int o) {
		int ls=t[o].ch[0],rs=t[o].ch[1];
		if (t[o].tag) {
			if (ls) {
				flip(ls);
			}
			if (rs) {
				flip(rs);
			}
		}
		if (t[o].cvr!=inf) {
			if (ls) {
				cvr(ls,t[o].cvr);
			}
			if (rs) {
				cvr(rs,t[o].cvr);
			}
		}
		t[o].tag=0;
		t[o].cvr=inf;
	}
	//???
	//len:??????a[]:?????????
	//?????????
	inline int build(int len,int a[]) {
		top=0;
		int temp=new_node(a[1]);
		stk[++top]=temp;
		for(int i=2;i<=len;i++) {
			int last=0;
			int cur=new_node(a[i]);
			while(top&&t[stk[top]].rd>t[cur].rd) {
				up(stk[top]);
				last=stk[top];
				stk[top--]=0;
			}
			t[cur].ch[0]=last;
			up(cur);
			if (top) {
				t[stk[top]].ch[1]=cur;
				up(stk[top]);
			}
			stk[++top]=cur;
		}
		while(top) {
			up(stk[top--]);
		}
		return stk[1];
	}
	//??????
	//a???????
	//b???????
	//x???????????
	//k??????????
	void split(int x,int k,int &a,int &b) {
		if (!x||!k) {
			a=0;
			b=x;
			return;
		}
		down(x);
		if (k>t[t[x].ch[0]].siz) {
			a=x;
			split(t[x].ch[1],k-t[t[x].ch[0]].siz-1,t[x].ch[1],b);
			up(x);
		} else {
			b=x;
			split(t[x].ch[0],k,a,t[x].ch[0]);
			up(x);
		}
	}
	//??????
	//x??????????
	//y??????????
	int merge(int x,int y) {
		if (x) {
			down(x);
		}
		if (y) {
			down(y);
		}
		if (!x||!y) {
			return x^y;
		}
		if (t[x].rd<t[y].rd) {
			t[x].ch[1]=merge(t[x].ch[1],y);
			up(x);
			return x;
		} else {
			t[y].ch[0]=merge(x,t[y].ch[0]);
			up(y);
			return y;
		}
	}
	//?????
	void recycle(int o) {
		int ls=t[o].ch[0],rs=t[o].ch[1];
		if (!o) {
			return;
		}
		if (ls) {
			recycle(ls);
		}
		trash.push(o);
		if (rs) {
			recycle(rs);
		}
	}
	//?????
	//pos??????
	//len????????
	//a[]???
	inline void insert(int pos,int len,int a[]) {
		int root1=build(len,a);
		int x,y;
		split(root,pos,x,y);
		root=merge(merge(x,root1),y);
	}
	//??????
	//pos???????????
	//len????????
	inline void remove(int pos,int len) {
		int x,y,z,u;
		split(root,pos+len-1,x,y);
		split(x,pos-1,z,u);
		recycle(u);
		root=merge(z,y);
	}
	//??????
	//pos???????????
	//len????????
	inline void reverse(int pos,int len) {
		int x,y,z,u;
		split(root,pos+len-1,x,y);
		split(x,pos-1,z,u);
		t[u].tag^=1;
		swap(t[u].lmax,t[u].rmax);
		swap(t[u].ch[0],t[u].ch[1]);
		root=merge(merge(z,u),y);
		return;
	}
	//?????
	//pos??????????
	//len???????
	//val?????
	inline void cover(int pos,int len,int val) {
		int x,y,u,z;
		split(root,pos+len-1,x,y);
		split(x,pos-1,z,u);
		t[u].val=t[u].cvr=val;
		t[u].sum=val*t[u].siz;
		t[u].lmax=t[u].rmax=max(0,t[u].sum);
		t[u].mmax=max(t[u].val,t[u].sum);
		t[u].tag=0;
		root=merge(merge(z,u),y);
	}
	inline int get_sum(int pos,int len) {
		int x,y,z,u;
		split(root,pos+len-1,x,y);
		split(x,pos-1,z,u);
		int ans=t[u].sum;
		root=merge(merge(z,u),y);
		return ans;
	}
	inline int get_max_sum(int pos,int len) {
		int x,y,z,u;
		split(root,pos+len-1,x,y);
		split(x,pos-1,z,u);
		int ans=t[u].mmax;
		root=merge(merge(z,u),y);
		return ans;
	}
	inline int ask_point(int pos) {
		int x,y,z,u;
		split(root,pos,x,y);
		split(x,pos-1,z,u);
		int ans=t[u].val;
		root=merge(merge(z,u),y);
		return ans;
	}
};

fhq_treap ft;
int n,m;

inline void read_str(char p[]) {
	char ch=getchar();
	int len=0;
	while(!isalpha(ch)&&ch!='-') {
		ch=getchar();
	}
	while(isalpha(ch)||ch=='-') {
		p[len++]=ch;
		ch=getchar();
	}
}

int a[4000010];

int main() {
	srand((unsigned)time(0));
	read(n),read(m);
	for(int i=1;i<=n;i++) {
		read(a[i]);
	}
	root=ft.build(n,a);
	int pos,len,val;
	string s;
	for(int i=1;i<=m;i++) {
		cin>>s;
		if (s=="INSERT") {
			read(pos),read(len);
			for(int i=1;i<=len;i++) {
				read(a[i]);
			}
			ft.insert(pos,len,a);
		} else if(s=="DELETE") {
			read(pos),read(len);
			ft.remove(pos,len);
		} else if (s=="REVERSE") {
			read(pos),read(len);
			ft.reverse(pos,len);
		} else if (s=="MAKE-SAME") {
			read(pos),read(len),read(val);
			ft.cover(pos,len,val);
		} else if (s=="MAX-SUM"){
			read(pos),read(len);
			printf("%d\n",ft.get_max_sum(pos,len));
		} else if (s=="GET-SUM") {
			read(pos),read(len);
			printf("%d\n",ft.get_sum(pos,len));
		} else {
			read(pos);
			printf("%d\n",ft.ask_point(pos));
		}
	}
	return 0;
}


```

---

## 作者：ezoixx118 (赞：0)

一道复杂的二叉平衡树，因为有区间操作，所以用splay写，注意细节。

翻转操作并不是将他暴力翻转，只是开一个bool变量标记。

(debug函数请忽略。。。。。。。)

···cpp

   
 
   
   
   
      
   
   
   
   
   
  
   
 
   
 
   
```cpp
#include<iostream>
#include<iomanip>
#include<stack>
#include<queue>
#include<list>
#include<vector>
#include<map>
#include<set>
#include<string>
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<cstring>
#define ull unsigned long long
#define ll long long
#define inf 200009
#define INF 2147483647
using namespace std;
struct Splay{
    int val;//值 
    int siz,son[2],fa;//儿子大小 儿子节点 父节点 
    int maxsub,maxl,maxr,sumv;//最大子序列维护 左儿子最大序列 右儿子最大序列  和维护 (类似线段树) 
    int p,set;//翻转标记 makesame操作标记 
}t[inf];
int arr[inf];
int len,root;
queue <int> q;//循环使用被del的数组空间，防止mle 
void debug(){
    printf("\nDEBUG\n");
    for (int i=0;i<=len;i++){
        printf("%d: fa=%d son[0]=%d son[1]=%d l=%d r=%d max=%d sum=%d p=%d set=%d\n",i,t[i].fa,t[i].son[0],t[i].son[1],t[i].maxl,t[i].maxr,t[i].maxsub,t[i].sumv,t[i].p,t[i].set);
    } 
} 
void pushup(int u){//类似线段树的pushup、pushdown 
    if (!u){
        return;
    }
    t[u].maxl=max(t[t[u].son[0]].maxl,t[t[u].son[0]].sumv+t[u].val+max(0,t[t[u].son[1]].maxl));
    t[u].maxr=max(t[t[u].son[1]].maxr,t[t[u].son[1]].sumv+t[u].val+max(0,t[t[u].son[0]].maxr));
    t[u].maxsub=max(t[u].val+max(0,t[t[u].son[0]].maxr)+max(0,t[t[u].son[1]].maxl),max(t[t[u].son[0]].maxsub,t[t[u].son[1]].maxsub));
    //最大子序列维护公式 
    t[u].sumv=t[t[u].son[0]].sumv+t[t[u].son[1]].sumv+t[u].val;
    t[u].siz=t[t[u].son[0]].siz+t[t[u].son[1]].siz+1;
    return;
}
void pushdown(int u){
    if (!u){
        return;
    }
    if (t[u].p){
        int revu=t[u].son[0];
        if (revu){
            swap(t[revu].son[0],t[revu].son[1]);
            swap(t[revu].maxl,t[revu].maxr);
            t[revu].p^=1;
        }
        revu=t[u].son[1];
        if (revu){
            swap(t[revu].son[0],t[revu].son[1]);
            swap(t[revu].maxl,t[revu].maxr);
            t[revu].p^=1;
        }
        t[u].p=0;
    }
    if (t[u].set!=-INF){
        int covu=t[u].son[0];
        if (covu){
            t[covu].set=t[covu].val=t[u].set;
            t[covu].sumv=t[covu].set*t[covu].siz;
            t[covu].maxl=t[covu].maxr=t[covu].maxsub=max(t[covu].set,t[covu].sumv);
        }
        covu=t[u].son[1];
        if (covu){
            t[covu].set=t[covu].val=t[u].set;
            t[covu].sumv=t[covu].set*t[covu].siz;
            t[covu].maxl=t[covu].maxr=t[covu].maxsub=max(t[covu].set,t[covu].sumv);
        }
        t[u].set=-INF;
    }
    return;
}
void rotate(int u,int p){//splay的旋转，具体操作请看博客 
    int v=t[u].fa;
    t[v].son[!p]=t[u].son[p];
    t[t[v].son[!p]].fa=v;
    t[u].son[p]=v;
    t[u].fa=t[v].fa;
    t[t[v].fa].son[t[t[v].fa].son[1]==v]=u;
    t[v].fa=u;
    pushup(v);
    pushup(u);
    return;
}
void splay(int u,int to){
    while(t[u].fa!=to){
       // debug();
        if (t[t[u].fa].fa==to){
            rotate(u,t[t[u].fa].son[0]==u);
        }
        else{
            int f=t[u].fa,grandf=t[f].fa;
            int p=(t[grandf].son[0]==f);
            if (t[f].son[p]==u){
                rotate(u,!p);
                rotate(u,p);
            }
            else{
                rotate(f,p);
                rotate(u,p);
            }
        }
        pushup(u);
//        debug();
    }
    if (to==0){
        root=u;
    }
    return;
}
int newtree(int v){// 循环使用被del的数组空间，防止mle 
    int u;
    if (q.empty()){
        len++;
        u=len;
    }
    else{
        u=q.front();
        q.pop();
    }
    t[u].val=v;
    t[u].maxl=t[u].maxr=t[u].maxsub=-INF;
    t[u].p=0;
    t[u].set=-INF;
    return u;
}
int build(int l,int r){//建树 
    if (l>r){
        return 0;
    }
    int mid=(l+r)/2,lson=0,rson=0;
    lson=build(l,mid-1);
    int u=newtree(arr[mid]);
    rson=build(mid+1,r);
    if (lson){
        t[u].son[0]=lson;
        t[lson].fa=u;
    }
    if (rson){
        t[u].son[1]=rson;
        t[rson].fa=u;
    }
    pushup(u);
//    debug();
    return u;
}
int getnum(int k){//找第k个数 
    int u=root;
    while(1){
        pushdown(u);
        if (k==t[t[u].son[0]].siz+1){
            break;
        }
        else if (k<=t[t[u].son[0]].siz){
            u=t[u].son[0];
        }
        else{
            k=k-t[t[u].son[0]].siz-1;
            u=t[u].son[1];
        }
    }
    return u;
}
void reverse(int l,int r){//旋转操作 
    l=getnum(l);
    r=getnum(r+2);
    splay(l,0);
    splay(r,l);
    int revu=t[r].son[0];
    if (!revu){
        return;
    }
    swap(t[revu].son[0],t[revu].son[1]);
    swap(t[revu].maxl,t[revu].maxr);
    t[revu].p^=1;
    pushup(r);
    pushup(l);
    return;
}
void insert(int k,int l,int r){//插入操作 
    splay(getnum(k+2),0);
    splay(getnum(k+1),root);
    int u=build(l,r);
    t[t[root].son[0]].son[1]=u;
    t[u].fa=t[root].son[0];
    pushup(t[root].son[0]);
    pushup(root);
    return;
}
void del(int &u){ 
    if (!u){
        return;
    }
    q.push(u);
    t[u].fa=0;
    del(t[u].son[0]);
    del(t[u].son[1]);
    t[u].maxsub=t[u].maxl=t[u].maxr=-INF;
    u=0;
    return; 
}
void find_del(int l,int r){//删除操作
    l=getnum(l);
    r=getnum(r+2);
    splay(l,0);
    splay(r,root);
    del(t[r].son[0]);
    pushup(r);
    pushup(l);
    return;
}
void setnum(int l,int r,int v){//makesame操作 
    l=getnum(l);
    r=getnum(r+2);
    splay(l,0);
    splay(r,l);
    int covu=t[r].son[0];
    if (!covu){
        return;
    }
    t[covu].set=t[covu].val=v;
    t[covu].sumv=v*t[covu].siz;
    t[covu].maxl=t[covu].maxr=t[covu].maxsub=max(v,t[covu].sumv);
    pushup(r);
    pushup(l);
    return;
}
int querymax(int l,int r){//两个询问操作 
    l=getnum(l);
    r=getnum(r+2);
    splay(l,0);
    splay(r,root);
    return t[t[r].son[0]].maxsub;
}
int querysum(int l,int r){
    l=getnum(l);
    r=getnum(r+2);
    splay(l,0);
    splay(r,root);
    return t[t[r].son[0]].sumv;
}
int main(){
    int n,m,x,y,z;
    char s[15];
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++){
        scanf("%d",&arr[i]);
    }
    arr[0]=arr[n+1]=0;
    t[0].maxl=t[0].maxr=t[0].maxsub=-INF;
    root=build(0,n+1);
//  debug();
    for (int i=0;i<m;i++){
        scanf("%s",&s);
        if (s[0]=='I'){
            scanf("%d%d",&x,&y);
            for (int i=1;i<=y;i++){
                scanf("%d",&arr[i]);
            }
            insert(x,1,y);
        }
        else if (s[0]=='D'){
            scanf("%d%d",&x,&y);
            find_del(x,x+y-1);
        }
        else if (s[0]=='M' && s[2]=='K'){
            scanf("%d%d%d",&x,&y,&z);
            setnum(x,x+y-1,z);
        }
        else if (s[0]=='R'){
            scanf("%d%d",&x,&y);
            reverse(x,x+y-1);
        }
        else if (s[0]=='G' && s[3]=='-'){
            scanf("%d%d",&x,&y);
            printf("%d\n",querysum(x,x+y-1));
        }
        else if (s[0]=='G'){
            scanf("%d",&x);
            printf("%d\n",t[getnum(x+1)].val);
        }
        else{
            scanf("%d%d",&x,&y);
            printf("%d\n",querymax(x,x+y-1));
        }
//      debug();
    }
}
···
```

---


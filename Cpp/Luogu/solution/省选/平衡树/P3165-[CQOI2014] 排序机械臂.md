# [CQOI2014] 排序机械臂

## 题目描述

为了把工厂中高低不等的物品按从低到高排好序，工程师发明了一种排序机械臂。它遵循一个简单的排序规则，第一次操作找到高度最低的物品的位置 $P_1$，并把左起第一个物品至 $P_1$ 间的物品 (即区间 $[1,P_1]$ 间的物品) 反序；第二次找到第二低的物品的位置 $P_2$，并把左起第二个至 $P_2$ 间的物品 (即区间 $[2,P_2]$ 间的物品) 反序……最终所有的物品都会被排好序。

![样例说明](https://cdn.luogu.com.cn/upload/pic/15642.png)

上图给出有六个物品的示例，第一次操作前，高度最低的物品在位置 $4$，于是把第一至第四的物品反序；第二次操作前，第二低的物品在位罝六，于是把第二至六的物品反序……

你的任务便是编写一个程序，确定一个操作序列，即每次操作前第 $i$ 低的物品所在位置 $P_i$，以便机械臂工作。需要注意的是，如果有高度相同的物品，必须保证排序后它们的相对位置关系与初始时相同。

## 说明/提示

$N \le 100000$

$P_i \le 10^7$

## 样例 #1

### 输入

```
6
3 4 5 1 6 2```

### 输出

```
4 6 4 5 6 6```

# 题解

## 作者：hs_black (赞：43)

## FHQ Treap解法

这道题当然用好写的fhq解决啦(~~其实是不会splay~~)

一开始, 感觉无法同时权值分裂又排名分裂

所以我按排名分裂, 维护子树最小值, 设计一个类似求第k大的函数,  找出区间最小值的位置

详见代码, 还是很好懂的(除get_rk函数, 其他部分和文艺平衡树一样)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<ctime>

using namespace std;

template <typename T>
void read(T &x) {
	x = 0; bool f = 0;
	char c = getchar();
	for (;!isdigit(c);c=getchar()) if (c=='-') f = 1;
	for (;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c^48);
	if (f) x=-x;
}

const int N = 100050;
int tag[N], siz[N];
int son[N][2], rnd[N];
int val[N], mn[N];

struct node {
	int pos, num;
	bool operator < (const node &i) const {
		if (num != i.num) return num < i.num;
		return pos < i.pos;
	}
}a[N];
int n;

int rt, x, y, z;
int tot;
int build(int x) {
	val[++tot] = x, mn[tot] = x, siz[tot] = 1;
	rnd[tot] = rand(); return tot;
}

int Mn(int x,int y) {return x < y ? x : y;}

void update(int x) {
	siz[x] = siz[son[x][0]] + siz[son[x][1]] + 1;
	mn[x] = val[x]; 
	if (son[x][0]) mn[x] = Mn(mn[son[x][0]], mn[x]);
	if (son[x][1]) mn[x] = Mn(mn[son[x][1]], mn[x]);
}

void spread(int x) {
	if (!tag[x]) return;
	swap(son[x][0], son[x][1]);
	if (son[x][0]) tag[son[x][0]] ^= 1;
	if (son[x][1]) tag[son[x][1]] ^= 1;
	tag[x] = 0;
}

int merge(int x,int y) {
	if (!x || !y) return x | y;
	if (rnd[x] < rnd[y]) {
		spread(x);
		son[x][1] = merge(son[x][1], y);
		update(x); return x;
	}
	spread(y);
	son[y][0] = merge(x, son[y][0]);
	update(y); return y;
}

void split(int now,int k,int &x,int &y) {
	if (!now) {
		x = y = 0; return;
	}
	spread(now);
	if (siz[son[now][0]] < k) {
		x = now;
		split(son[x][1], k - siz[son[x][0]] - 1, son[x][1], y);
	}
	else y = now, split(son[y][0], k, x, son[y][0]);
	update(now);
}

//找出最小值的排名
int get_rk(int x) {
	int k = 1; //初始排名
	while (1) {
		spread(x);
		if (son[x][0] && mn[son[x][0]] == mn[x]) 
      		x = son[x][0]; //在左子树
		else if (son[x][1] && mn[son[x][1]] == mn[x]) 
        	k += siz[son[x][0]] + 1, x = son[x][1]; //在右子树
		else return k + siz[son[x][0]]; //在当前节点
	}
}

int v[N];
int main() {
	read(n);
	for (int i = 1;i <= n; i++) {
		read(a[i].num); a[i].pos = i;
	}
	sort(a + 1, a + n + 1);
	for (int i = 1;i <= n; i++)
	v[a[i].pos] = i;
	for (int i = 1;i <= n; i++) 
		rt = merge(rt, build(v[i]));
	for (int i = 1;i <= n; i++) {
		int k = get_rk(rt);
		split(rt, k, x, y);
		split(x, k-1, x, z);
		tag[x] ^= 1;
		rt = merge(x, y);
		printf ("%d ", k + i - 1);
	}
	return 0;
}
/*
7
1 8 6 5 3 5 2

*/
```



---

## 作者：Victorique (赞：26)

这样看来，splay的实现这个题的还没有数组版本，那蒟蒻掏出了自己弱弱的代码。

首先明白一个事，这个题主体是在让你干什么。这个题明显，要维护一个数据结构，让这个数据结构实现区间翻转和   查询工作。

区间翻转应该都会了吧。不会的请左转去文艺平衡树那个模板题。我这里主要介绍一下建树的操作和查询。

可以发现，那个模板题建树的时候数字是完全有序的，所以可以直接建树。这个题由于给了一个高度，所以不能这么干，然而我们可以使用结构体，以高度为第一关键字，下标为第二关键字sort一下，然后高度就没用了，我们执行模板里的翻转操作即可。

然后我们要求的是什么，一个排名，没错。那么想一下，如果我们把要求的那个点直接旋转到根节点，然后求出它的左子树大小+1是不是就可以了，省去了很多功夫。然而要注意的是，我们因为一开始设置了哨兵节点，所以最后还要-1.

剩下的就没什么很困难的了，不明白的再仔细看看代码吧。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#define re register
#define maxn 1000007
#define ll long long
#define ls rt<<1
#define rs rt<<1|1
#define inf 1000000007
using namespace std;
int ch[100001][2],f[maxn],cnt[maxn],key[maxn],size[maxn],mark[maxn],root,sz,data[maxn];
struct po
{
	int id,k;
}a[maxn];
inline int read()
{
    int x=0,c=1;
    char ch=' ';
    while((ch>'9'||ch<'0')&&ch!='-')ch=getchar();
    while(ch=='-')c*=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-'0',ch=getchar();
    return x*c;
}
bool cmp(po x,po y)
{
    if(x.k<y.k)
    return 1;
    else if(x.k==y.k)
    return x.id<y.id;
    return 0;
}
inline int get(int x)
{
    return ch[f[x]][1]==x;
}
inline void update(int x)
{
	size[x]=size[ch[x][1]]+size[ch[x][0]]+1;
}
inline void pushdown(int x)
{
    if(mark[x]){
        if(ch[x][0]) mark[ch[x][0]]^=1;
        if(ch[x][1]) mark[ch[x][1]]^=1;
        swap(ch[x][0],ch[x][1]);
        mark[x]=0;
    }
}
inline void rotate(int x)
{
    int y=f[x],z=f[y];
    int kind=get(x);
    pushdown(y);pushdown(x);
    ch[y][kind]=ch[x][kind^1];f[ch[y][kind]]=y;
    ch[x][kind^1]=y;f[y]=x;f[x]=z;
    if(z){
        ch[z][ch[z][1]==y]=x;
    }
    update(y);update(x);
}
inline void splay(int x,int tar)
{
    for(re int fa;(fa=f[x])!=tar;rotate(x)){
		pushdown(f[fa]);pushdown(fa);pushdown(x);
    	if(f[fa]!=tar)
    	    rotate(get(x)==get(fa)?fa:x);
	}
    if(!tar) root=x;
}
inline void build(int l,int r,int fa)
{
   if(l>r) return;
    int mid=l+r>>1;
    if(mid<fa) ch[fa][0]=mid;
    else ch[fa][1]=mid;
    size[mid]=1;f[mid]=fa;
    if(l==r) return;
    build(l,mid-1,mid);
    build(mid+1,r,mid);
    update(mid);
}
inline int findx(int x)
{
    int now=root;
    while(1){
		if(mark[now])
		pushdown(now);
        if(x<=size[ch[now][0]]&&ch[now][0])
        now=ch[now][0];
        else {
            x-=size[ch[now][0]]+1;
            if(x==0) return now;
            else now=ch[now][1];
        }
    }
}
int main()
{
    int n;
    cin>>n;
    for(re int i=2;i<=n+1;i++){
        a[i].k=read();
        a[i].id=i;
    }
    a[1].id=1,a[1].k=-inf;
    a[n+2].id=n+2,a[n+2].k=inf;
    sort(a+1,a+n+3,cmp);
    build(1,n+2,0);
    root=n+3>>1;
    for(re int i=2;i<=n;i++){
        splay(a[i].id,0);
        int ans=size[ch[root][0]]+1;
        printf("%d ",ans-1);
        int x1=findx(i-1);
		int y1=findx(ans+1);
        splay(x1,0);splay(y1,x1);
        mark[ch[ch[root][1]][0]]^=1;
    }
    cout<<n;
}
```

---

## 作者：TheLostWeak (赞：14)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/BZOJ3506.html)

**大致题意：** 给你$n$个数。第一次找到最小值所在位置$P_1$，翻转$[1,P_1]$，第二次找到剩余数中最小值所在位置$P_2$，翻转$[2,P_2]$，以此类推。求$P_1,P_2,...,P_n$的值。

------

### 初始化

这题应该是一道比较裸的$Splay$题。

关于$Splay$可以查看这篇博客：[简析平衡树（三）——浅谈Splay](https://www.cnblogs.com/chenxiaoran666/p/Splay.html)。

首先，我们将原数组排序一遍，记下**每一次操作的位置**。

有一个细节，题目要求**相同值要先取位置靠前的**（没注意到这点结果狂$WA$不止）。

然后便是建树。

注意，$Splay$建树的过程中我们一般会在序列左右各加一个多余节点，方便后面取出一段区间进行操作。

------

### 操作

每一次操作，我们把要操作的位置先$Splay$到根，然后就可以得出答案即为此时**左子树的$Size$**，记其为$ans$。

注意是$Size$而不是$Size+1$，要考虑到我们在序列左边加的那个多余节点已经使$Size$比实际存在的节点个数多$1$了。

然后，按照题目要求，我们要翻转区间$[i,ans]$。（关于这一操作的具体过程可以看这道题：[【洛谷3391】【模板】文艺平衡树（Splay）](https://www.luogu.org/problemnew/show/P3391)）

直接将$i$号节点和$ans+2$号节点分别旋到根节点和根节点的右儿子，然后翻转根节点的右儿子的左儿子即可。

------

### 代码

```cpp
#include<bits/stdc++.h>
#define Type template<typename I>
#define N 100000
#define swap(x,y) (x^=y^=x^=y)
#define INF 1e9
using namespace std;
int n;
struct Data
{
    int pos,val;
    inline friend bool operator < (Data x,Data y) {return x.val^y.val?x.val<y.val:x.pos<y.pos;}
}a[N+5];
class Class_FIO
{
    private:
        #define Fsize 100000
        #define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,Fsize,stdin),A==B)?EOF:*A++)
        #define pc(ch) (FoutSize^Fsize?Fout[FoutSize++]=ch:(fwrite(Fout,1,Fsize,stdout),Fout[(FoutSize=0)++]=ch))
        #define Isi(x) (typeid(x).name()==typeid(1).name())
        #define Isc(x) (typeid(x).name()==typeid('a').name())
        int Top,FoutSize;char ch,*A,*B,Fin[Fsize],Fout[Fsize],Stack[Fsize];
    public:
        Class_FIO() {A=B=Fin;}
        Type inline void read(I& x) {x=0;while(!isdigit(ch=tc()));while(x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));}
        Type inline void write(I x)
        {
            if(Isi(x)) {while(Stack[++Top]=x%10+48,x/=10);while(Top) pc(Stack[Top--]);}
            if(Isc(x)) pc(x);
        }
        template<typename I,typename... A> inline void read(I& x,A&... y) {read(x),read(y...);}
        template<typename I,typename... A> inline void write(I x,A... y) {write(x),write(y...);}
        inline void clear() {fwrite(Fout,1,FoutSize,stdout),FoutSize=0;}
}F;
class Class_Splay//Splay
{
    private:
        #define SIZE N
        #define PushUp(x) (node[x].Size=node[node[x].Son[0]].Size+node[node[x].Son[1]].Size+1)
        #define Rever(x) (swap(node[x].Son[0],node[x].Son[1]),node[x].Rev^=1)
        #define PushDown(x) (node[x].Rev&&(Rever(node[x].Son[0]),Rever(node[x].Son[1]),node[x].Rev=0))
        #define Which(x) (node[node[x].Father].Son[1]==x)
        #define Connect(x,y,d) (node[node[x].Father=y].Son[d]=x)
        #define Split(x,y) (Splay(get_pos(x),rt),Splay(get_pos((y)+2),node[rt].Son[1]),node[node[rt].Son[1]].Son[0])
        int rt;
        struct Tree
        {
            int Size,Rev,Father,Son[2];
        }node[SIZE+5];
        inline void Rotate(int x,int& k)
        {
            register int fa=node[x].Father,pa=node[fa].Father,d=Which(x);PushDown(fa),PushDown(x),
            (fa^k?node[pa].Son[Which(fa)]=x:k=x),node[x].Father=pa,Connect(node[x].Son[d^1],fa,d),Connect(fa,x,d^1),PushUp(fa),PushUp(x);
        }
        inline void Splay(int x,int& k) {register int fa;while(x^k) fa=node[x].Father,fa^k&&(Rotate(Which(x)^Which(fa)?x:fa,k),0),Rotate(x,k);}
        inline void Build(int l,int r,int& rt)
        {
            register int mid=l+r>>1;
            if(node[rt=mid].Size=1,!(l^r)) return;
            l<mid&&(Build(l,mid-1,node[rt].Son[0]),node[node[rt].Son[0]].Father=rt),
            r>mid&&(Build(mid+1,r,node[rt].Son[1]),node[node[rt].Son[1]].Father=rt),
            PushUp(rt);
        }
        inline int get_pos(int rk)
        {
            register int x=rt;
            while(x) 
            {
                if(PushDown(x),node[node[x].Son[0]].Size>=rk) x=node[x].Son[0];
                else if(!(rk-=node[node[x].Son[0]].Size+1)) return x;
                else x=node[x].Son[1];
            }
        }
    public:
        inline void Init(int len) {Build(1,len+2,rt);}
        inline int GetAns(int x) 
        {
            register int k,ans;
            Splay(a[x].pos+1,rt),ans=node[node[rt].Son[0]].Size,k=Split(x,ans),Rever(k);//找到ans，然后翻转
            return ans;//返回答案
        }
        #undef SIZE
}Splay;
int main()
{
    register int i,p;
    for(F.read(n),i=1;i<=n;++i) F.read(a[a[i].pos=i].val);//读入
    for(sort(a+1,a+n+1),Splay.Init(n),i=1;i<=n;++i) F.write(p=Splay.GetAns(i),' ');//初始化排序+依次操作
    return F.clear(),0;
}
```





---

## 作者：HenryHuang (赞：13)

## FHQ_Treap 太神辣

蒟蒻初学FHQ_Treap,于是来到了这道略显板子的题目

因为Treap既满足BST的性质，又满足Heap的性质，所以，对于这道题目，我们可以将以往**随机出的额外权值转化为每一个位置的高度**，这样我们就可以利用小根堆的性质，甚至连$Split$操作都可以省略掉，就可以AC这道题目

步骤：
1.首先找到现在的根节点，即当前高度最低的位置

2.根据Treap的性质，我们只需要将其左子树打一个反转的标记，然后将根节点删除，将其左右两个子树合并，那么，新的子节点就是我们接下来需要的第2小高度的位置

3.重复1，2操作，这个题目就完结撒花辣！！

但是高度有可能是相同的，题目中又要求取靠前的那一个，于是我们将所有的数乘上n，再加上i，这样就可以有效避免这一个问题。

~~愿望总是美好的~~

----

[CQOI2014]排序机械臂愉快的过掉了，但另外一道相同的题目却过不了（robotic sort）。然后，有dalao指出，这样的做法，只要数据是单调的，就会被卡成$O(n^2)$

于是，通过查阅资料，我们可以使用一种神奇的方法——笛卡尔树优化建树，这样就可以有效避免这个问题。

对于$Treap$来说，我们可以将每一个节点的信息简化为一个二元组$(val,rand)$，意义一看便知

我们按照val的顺序进行插入，而在本题中，val即初始位置1~n,所以不用重新排序。

我们可以维护一个单调栈，从而有效解决这个问题。

对于每一个节点，我们将栈中大于当前节点rand值的节点全部弹出，将他们挂在当前节点的左儿子上，然后再把连同当前节点一起的这一棵树挂在弹完所有值之后的栈顶节点的右儿子上，这样就可以构建出一颗相对平衡的Treap。

用通俗的话讲，对于当前节点u，我们只考虑将其放在最右边的这一条链上，如果他比所有节点的rand值都大，那么当然顺理成章的放在最右边，如果没有，我们就考虑同时维护BST与Heap的性质，于是就有了我们上面的做法。

贴代码啦~

```cpp
//短短70行解决战斗
#include<bits/stdc++.h>
using namespace std;
const long long maxn=5e5+10;
long long inline read()
{
    long long x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
long long son[maxn][2],val[maxn],rnd[maxn],siz[maxn],cnt,rt,tag[maxn];
inline void upd(long long t){siz[t]=siz[son[t][0]]+siz[son[t][1]]+1;}
inline void down(long long x)
{
    if(tag[x])
    {
        swap(son[x][0],son[x][1]);
        if(son[x][0]) tag[son[x][0]]^=1;
        if(son[x][1]) tag[son[x][1]]^=1;
        tag[x]=0;
    }
}
inline long long init(long long x,long long qaq)
{
    ++cnt,val[cnt]=x,siz[cnt]=1,rnd[cnt]=qaq;
    return cnt;
}
inline long long merge(long long x,long long y)
{
    if(!x||!y) return x+y;
    if(rnd[x]<rnd[y])
    {
        down(x),son[x][1]=merge(son[x][1],y),upd(x);
        return x;
    }
    else
    {
        down(y),son[y][0]=merge(x,son[y][0]),upd(y);
        return y;
    }
}
struct cc{
    long long num,id;
}a[maxn];
int main()
{
    srand(time(0));
    long long opt,n,m,l,r,x,y,z;
    stack<int> q;
    scanf("%lld",&n);
    for(int i=1;i<=n;++i)
    {
        scanf("%lld",&rnd[i]),rnd[i]=rnd[i]*n+i,val[i]=i,siz[i]=1;
        while((!q.empty())&&rnd[i]<rnd[q.top()])
            son[i][0]=q.top(),q.pop(),upd(son[i][0]);
        if(!q.empty()) son[q.top()][1]=i;
        q.push(i);
    }
    while(!q.empty()) rt=q.top(),upd(q.top()),q.pop();
    for(int i=1;i<=n;++i)
    {
        down(rt);
        printf("%lld ",siz[son[rt][0]]+i);
        l=son[rt][0],r=son[rt][1];
        son[rt][0]=son[rt][1]=0;
        tag[l]^=1;
        rt=merge(l,r);
    }
    return 0;
}
```

---

## 作者：xryjr233 (赞：13)

大致就是要我们支持以下操作:

1.查询区间最小值

2.翻转一个区间

看到翻转自然就想到了Splay。

对于一个点,我们记录以下信息:

结构体v:它所对应的区间上的下标和高度(用于确定大小,也可以不开结构体,使用离散化)

结构体mn:它和它的子树中v的最小值

整数f:它的父亲

数组(其实是2个数)c[2]:它的左/右儿子

整数(0/1)tag:它和它的子树是否有被整体翻转

整数sz:它的子树的大小

我们第$i$次查询区间$[i,n]$中的最小值,记录它的位置$id$输出它,并把第$i$个数到第$id$个数的子区间翻转。

就变成了Splay模板题。

code:

~~有一些Pushdown是没有必要的,保险起见还是写了。~~

```cpp
#include<bits/stdc++.h>
using namespace std;
struct T{
	int h,id;
	bool operator >(T y)const{
		if(h!=y.h){
			return h>y.h;
		}
		return id>y.id;
	}
	bool operator <(T y)const{
		if(h!=y.h){
			return h<y.h;
		}
		return id<y.id;
	}
	bool operator ==(T y){
		return h==y.h&&id==y.id;
	}
}a[100010];
struct node{
	int f,c[2],tag,sz;
	T mn,v;
}t[100010];
int n,rt,cnt,p;

void Upd(int x){
	t[x].mn=min(t[x].v,min(t[t[x].c[0]].mn,t[t[x].c[1]].mn));
	t[x].sz=t[t[x].c[0]].sz+t[t[x].c[1]].sz+1;
}
void Psd(int x){
	if(t[x].tag){
		swap(t[x].c[0],t[x].c[1]);
		if(t[x].c[0])t[t[x].c[0]].tag^=1;
		if(t[x].c[1])t[t[x].c[1]].tag^=1;
		t[x].tag=0;
	}
}
void Build(int &x,int f,int l,int r){
	if(l>r){
		return;
	}
	x=++cnt;
	t[x].f=f;
	t[x].sz=r-l+1;
	int mid=(l+r)/2;
	t[x].v=a[mid];
	t[x].mn=a[mid];
	Build(t[x].c[0],x,l,mid-1);
	Build(t[x].c[1],x,mid+1,r);
	Upd(x);
}
void Rotate(int x){
	int y=t[x].f,z=t[y].f;
	Psd(y);
	Psd(x);
	int c=t[y].c[1]==x,gc=t[z].c[1]==y;
	t[z].c[gc]=x;
	t[x].f=z;
	t[y].c[c]=t[x].c[c^1];
	t[t[x].c[c^1]].f=y;
	t[x].c[c^1]=y;
	t[y].f=x;
	Upd(y);
	Upd(x);
}
void Splay(int x,int f){
	while(t[x].f!=f){
		int y=t[x].f,z=t[y].f;
		Psd(y);
		Psd(z);
		if(z==f){
			Rotate(x);
		}else{
			int c=t[y].c[1]==x,gc=t[z].c[1]==y;
			if(c==gc){
				Rotate(y);
			}else{
				Rotate(x);
			}
			Rotate(x);
		}
	}
	if(!f){
		rt=x;
	}
}
int Find_N(int x){//查找Splay维护的序列的第x个数
	int nw=rt;
	while(nw){
		Psd(nw);
		if(t[t[nw].c[0]].sz+1==x){
			return nw;
		}
		if(t[t[nw].c[0]].sz>=x){
			nw=t[nw].c[0];
		}else{
			x-=t[t[nw].c[0]].sz+1;
			nw=t[nw].c[1];
		}
	}
}
int Find_Min(int l){//查找l到n的区间最小值
	int kkk=0;
	if(l!=1){
		Splay(Find_N(l-1),0);
		Psd(rt);
		int nw=t[rt].c[1];
		while(nw){
			Psd(nw);
			if((!t[nw].c[0]&&!t[nw].c[1])||(t[nw].mn==t[nw].v)){
				return kkk+t[t[nw].c[0]].sz+l;
			}
			if(t[t[nw].c[0]].mn>t[t[nw].c[1]].mn){
				kkk+=t[t[nw].c[0]].sz+1;
				nw=t[nw].c[1];
			}else{
				nw=t[nw].c[0];
			}
		}
	}else{
		int nw=rt;
		while(nw){
			Psd(nw);
			if((!t[nw].c[0]&&!t[nw].c[1])||(t[nw].mn==t[nw].v)){
				return kkk+t[t[nw].c[0]].sz+l;
			}
			if(t[t[nw].c[0]].mn>t[t[nw].c[1]].mn){
				kkk+=t[t[nw].c[0]].sz+1;
				nw=t[nw].c[1];
			}else{
				nw=t[nw].c[0];
			}
		}
	}
}
void Flip(int l,int r){//翻转区间[l,r]
	if(l==1){
		if(r==n){
			t[rt].tag^=1;
		}else{
			Splay(Find_N(r+1),0);
			Psd(rt);
			t[t[rt].c[0]].tag^=1;
		}
	}else if(r==n){
		Splay(Find_N(l-1),0);
		Psd(rt);
		t[t[rt].c[1]].tag^=1;
	}else{
		int L=Find_N(l-1);
		int R=Find_N(r+1);
		Splay(L,0);
		Splay(R,L);
		Psd(L);
		Psd(R);
		t[t[R].c[0]].tag^=1;
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i].h);
		a[i].id=i;
	}
	t[0].mn.h=1e9;
	Build(rt,0,1,n);
	for(int i=1;i<n;i++){
		p=Find_Min(i);
		printf("%d ",p);
		Flip(i,p);
	}
	printf("%d",n);
	return 0;
}
```

---

## 作者：Sol1 (赞：7)

一年以前，我看到这题，想到：这个东西你要在一个区间树上面查最小值……这玩意没法做啊（当时啥也不会）……

~~然后就把这题给扔了……~~

~~一年后回来看：这不 sb 题吗……~~

所以就在这里详细介绍一下区间树的思想吧。

首先你显然是要写个东西去维护区间翻转区间求 $\min$ 和其位置，如果认为每一个节点只能维护自己的信息就废掉了。。。

但是每一个节点由于只有两个孩子，所以如果维护的信息可以 $O(x)$ 合并，那么就可以 $O(x)$ 由孩子的子树信息递推到自己的子树信息，以此来达到维护**节点的子树对应的区间**的信息的目的。

既然这样，就可以通过 Treap 的合并和分裂/Splay 的向根旋转来 $O(x\log n)$ 得到一段区间内的信息。

这个思想其实可以类比线段树来理解。

回到这题，发现这个题要维护最小值，这个信息显然是 $O(1)$ 合并。

那么查最小值的位置就很容易了：我们只需要在树上 dfs，每次比较左子的最小值 $v_l$、自己的**节点值** $v_0$、右子的最小值 $v_r$，如果 $v_l$ 最小，那么直接递归查询左子树即可；如果 $v_0$ 最小，返回左子树的大小 $+1$，即该节点对应的排名；如果 $v_r$ 最小，返回递归查询右子树的结果加左子树的大小 $+1$，因为左子树和自己都整体比右子树靠前，所以要全部加入排名。

查出位置 $k$ 之后，将整个区间 $[L,R]$ 分解为 $[L,k-1]$、$[k,k]$、$[k+1,R]$，然后翻转 $[L,k-1]$，把 $[L,k-1]$ 和 $[k+1,R]$ 合并就可以了。

但是还有一个小问题：不能改变相对顺序。

这个问题只需要把所有的数 $\times n$ 然后沿出现次数依次往后加就可以。比如 $1,3,2,4,3,4$ 变成 $6,18,12,24,19,25$。

这样这题就做完啦~

因为合并是 $O(1)$，所以时间复杂度为 $O(n\log n)$，空间为 $O(n)$。

上代码~

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline long long qread() {
	register char c = getchar();
	register long long x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline long long Abs(const long long& x) {return (x > 0 ? x : -x);}
inline long long Max(const long long& x, const long long& y) {return (x > y ? x : y);}
inline long long Min(const long long& x, const long long& y) {return (x < y ? x : y);}

#define Getsize(p) (p ? p->siz : 0)
#define Getmn(p) (p ? p->mn : 0x3f3f3f3f3f3f3f3f)//注意空节点的 min 值要取 +INF
struct Node {
	long long val, mn, siz, rnd;
	bool revtag;
	Node *l, *r;
	Node() {
		l = r = NULL;
		revtag = val = mn = siz = rnd = 0;
	}
	inline void Update() {
		siz = Getsize(l) + Getsize(r) + 1;
		mn = Min(Getmn(l), Min(Getmn(r), val));//合并左右区间
	}
    //很套路的下放翻转标记
	inline void Pushdown() {
		if (revtag) {
			if (l) l->revtag ^= 1;
			if (r) r->revtag ^= 1;
			swap(l, r);
			revtag = 0;
		}
	}
};
Node nd[100005];
int top;
struct Treap {
	Node *_root;
    //创建新节点
	inline Node* New(long long val) {
		Node *p = &nd[top++];
		p->val = val;
		p->mn = val;//新节点是叶子节点，所以子树最小值就是自己的值
		p->siz = 1;
		p->rnd = rand();
		return p;
	}
    //非常模板的合并分裂
	inline void split(Node *p, int spk, Node *&lt, Node *&rt) {
		if (!p) {
			lt = rt = NULL;
			return;
		}
		p->Pushdown();
		if (Getsize(p->l) < spk) {
			lt = p;
			split(p->r, spk - Getsize(p->l) - 1, p->r, rt);
		} else {
			rt = p;
			split(p->l, spk, lt, p->l);
		}
		p->Update();
	}
	inline Node* merge(Node *lt, Node *rt) {
		if (!lt) return rt;
		if (!rt) return lt;
		if (lt->rnd < rt->rnd) {
			lt->Pushdown();
			lt->r = merge(lt->r, rt);
			lt->Update();
			return lt;
		} else {
			rt->Pushdown();
			rt->l = merge(lt, rt->l);
			rt->Update();
			return rt;
		}
	}
    //查询排名
	inline int Query(Node *p) {
		if (!p) return 0;
		p->Pushdown();//注意要下放标记
		if (Getmn(p->l) < Getmn(p->r) && Getmn(p->l) < p->val) return Query(p->l);//左子树最小，递归查询左树
		else if (Getmn(p->l) > p->val && p->val < Getmn(p->r)) return Getsize(p->l) + 1;//自己最小，直接返回自己的排名
		else return Query(p->r) + Getsize(p->l) + 1;//右子树最小，递归查询右树，然后更新排名
	}
};
Treap tr;
int n, cnt[10000005];

inline void Read() {
	n = qread();
	for (register int i = 1;i <= n;i++) {
		register long long x = qread(), tmp = cnt[x];
		cnt[x]++;
		x = x * n + tmp;//处理输入值
		tr._root = tr.merge(tr._root, tr.New(x));
	}
}

inline void Solve() {
	for (register int i = 1;i <= n;i++) {
		register int k = tr.Query(tr._root);//查询最小值位置
		printf("%d ", k + i - 1);//因为前面有 i-1 个节点被删除了，所以输出时要加回来
        //提取区间
		Node *p1, *p2, *p3;
		tr.split(tr._root, k - 1, p1, p2);
		tr.split(p2, 1, p2, p3);
        //翻转，注意判空
		if (p1) p1->revtag ^= 1;
        //合并回来
		tr._root = tr.merge(p1, p3);
	}
}

int main() {
	Read();
	Solve();
	#ifndef ONLINE_JUDGE
	while (1);
	#endif
	return 0;
}
```


---

## 作者：hl666 (赞：7)

这题作为一道十分经典的**平衡树维护序列**的问题，自然是值得一做的了。

写完翻了下题解发现都是写**Splay**的dalao，少有的暴力**FHQ_Treap**党还是用**指针**实现的。

所以这里略微讲解下数组实现的FHQ_Treap好了，感觉写起来比Splay舒服些。

首先我们要抽象化一下题意：给你$n$个数，第$i$次操作在$[i,n]$中找到最小值的位置$p_i$，并**翻转**$[i,p_i]$。最后输出所有$p_i$的值。

然后我们考虑转化问题（因为貌似FHQ_Treap不能同时支持**基于权值**的```split```和**基于排名**的分裂）。

所以离散化是必须的，尤其注意这里不能直接对数组排序（因为会有**权值相等**的点）。

然后我们记一下每个值原来的位置，再考虑对一个**基本序列**（即初始时为$1,2,3,\dots,n$）进行翻转。

手动推导一下我们发现其实就是先找出每次操作位置的**排名**，然后再基本序列上不停翻转区间即可。

由于FHQ_Treap树高期望$\log$的特性，所以我们查询排名的时候可以直接暴力从一个点跳到根然后反着算回来。

最后提一下那种以权值为保证堆性质的值的做法是**错误**的！这样会导致树高不平衡，一旦遇到单调的数据就卡到$O(n^2)$了。

CODE

```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
#define RI register int
#define CI const int&
#define Tp template <typename T>
using namespace std;
const int N=100005;
struct data
{
    int val,id;
    inline friend bool operator <(const data& A,const data& B)
    {
        return A.val<B.val||(A.val==B.val&&A.id<B.id);
    }
}a[N]; int n,rk;
class FileInputOutput
{
    private:
        static const int S=1<<21;
        #define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,S,stdin),A==B)?EOF:*A++)
        #define pc(ch) (Ftop<S?Fout[Ftop++]=ch:(fwrite(Fout,1,S,stdout),Fout[(Ftop=0)++]=ch))
        char Fin[S],Fout[S],*A,*B; int Ftop,pt[15];
    public:
        Tp inline void read(T& x)
        {
            x=0; char ch; while (!isdigit(ch=tc()));
            while (x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));
        }
        Tp inline void write(T x)
        {
            if (!x) return (void)(pc('0'),pc(' ')); RI ptop=0;
            while (x) pt[++ptop]=x%10,x/=10; while (ptop) pc(pt[ptop--]+48); pc(' ');
        }
        inline void Fend(void)
        {
            fwrite(Fout,1,Ftop,stdout);
        }
        #undef tc
        #undef pc
}F;
class FHQ_Treap
{
    private:
        struct treap
        {
            int ch[2],size,dat,fa; bool rev;
            inline treap(CI Dat=0,CI Size=0)
            {
                ch[0]=ch[1]=rev=fa=0; dat=Dat; size=Size;
            }
        }node[N]; int tot,rt,seed,stack[N],top;
        #define lc(x) node[x].ch[0]
        #define rc(x) node[x].ch[1]
        #define fa(x) node[x].fa
        inline int rand(void)
        {
            return seed=(int)seed*482711LL%2147483647;
        }
        inline void swap(int& x,int& y)
        {
            int t=x; x=y; y=t;
        }
        inline void rever(CI x)
        {
            swap(lc(x),rc(x)); node[x].rev^=1;
        }
        inline void pushup(CI x)
        {
            node[x].size=node[lc(x)].size+node[rc(x)].size+1; fa(lc(x))=fa(rc(x))=x;
        }
        inline void pushdown(CI x)
        {
            if (node[x].rev) rever(lc(x)),rever(rc(x)),node[x].rev=0;
        }
        inline void merge(int& now,int x,int y)
        {
            if (!x||!y) return (void)(now=x|y); if (node[x].dat>node[y].dat)
            pushdown(x),now=x,merge(rc(now),rc(x),y),pushup(x); else
            pushdown(y),now=y,merge(lc(now),x,lc(y)),pushup(y);
        }
        inline void split(int now,int& x,int& y,int rk)
        {
            if (!now) return (void)(x=y=0); pushdown(now); if (node[lc(now)].size<rk)
            x=now,split(rc(now),rc(x),y,rk-node[lc(now)].size-1); else
            y=now,split(lc(now),x,lc(y),rk); pushup(now);
        }
    public:
        FHQ_Treap() { seed=233; }
        inline void insert(CI val)
        {
            node[++tot]=treap(rand(),1); merge(rt,rt,tot);
        }
        inline void reverse(RI l,RI r)
        {
            int x,y,z; split(rt,x,y,l-1); split(y,y,z,r-l+1);
            rever(y); merge(y,y,z); merge(rt,x,y);
        }
        inline int get_rk(int now)
        {
            stack[top=1]=now; for (int t=now;fa(t);t=fa(t))	stack[++top]=fa(t);
            while (top) pushdown(stack[top--]); int ret=node[lc(now)].size;
            for (;now;now=fa(now)) if (now==rc(fa(now))) ret+=node[lc(fa(now))].size+1;
            return ret+1;
        }
        #undef lc
        #undef rc
}T;
int main()
{
    //freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
    RI i; for (F.read(n),i=1;i<=n;++i) F.read(a[i].val),a[i].id=i;
    for (sort(a+1,a+n+1),i=1;i<=n;++i) T.insert(i); for (i=1;i<=n;++i)
    rk=T.get_rk(a[i].id),F.write(rk),T.reverse(i,rk); return F.Fend(),0;
}
```



---

## 作者：wuzhoupei (赞：6)

![Peipei](http://img.blog.csdn.net/20180120093509502?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJldGVuZF9mYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


还是我的Logo  >\_<


看别的题解好长好难理解

那我们写个短的

首先 这是一个平衡树

这个题要求是 查询第 k 小并反转某个区间

所以呢

# **fhq Treap** 啊

我们权值为输入的下标，  建一个fhq Treap

然后以该点的权值作为优先级，使之成为小根堆

这样当前 Treap 的堆顶就是当前最小值

于是我们就直接取堆顶，  然后删除

至于旋转， 我们在删除之前

在堆顶的左子树中打上 lazy 标记就好了

然后删掉堆顶

因为我们是按照位置为权值，那么左子树的所有点都在当序列中前节点的左侧

即需要翻转的地方


所以我们就写一个甚至只需要 merge 的 fhq Treap 就好了

棒棒哒


```cpp
#include <bits/stdc++.h>
#define II long long
#define IL inline
#define R register
#define I 123456
#define PI 100000
using namespace std;

IL void of(R II &a) {
    R char c=getchar(); R II w=1, p=0;
    while (c<'0' || c>'9') { if(c=='-') w=-1; c=getchar(); }
    while (c>='0' && c<='9') { p=p*10+c-'0'; c=getchar(); }
    a=w*p;
}

/* -------------------- Peipei -------------------- */

II n,root;

struct owo { II l,r,w,ra,siz,lazy; } Tr[I];
IL void up(R II o) { Tr[o].siz=Tr[Tr[o].l].siz+Tr[Tr[o].r].siz+1; }
IL void updata(R II o) {
    if(Tr[o].lazy) {
        R II l=Tr[o].l, r=Tr[o].r;
        swap(Tr[o].l,Tr[o].r);
        if(l) Tr[l].lazy^=1;
        if(r) Tr[r].lazy^=1;
        Tr[o].lazy=0;
    }
}

IL II merge(R II l,R II r) {
    if(l*r==0) return l+r;
    if(Tr[l].ra<Tr[r].ra) {
        updata(l);
        Tr[l].r=merge(Tr[l].r,r);
        up(l); return l;
    } else {
        updata(r);
        Tr[r].l=merge(l,Tr[r].l);
        up(r); return r;
    }
}


int main()
{
//    freopen("1.in","r",stdin);
    
    of(n);
    for(R II i=1,x;i<=n;i++) {
        of(x); x=x*PI+i;
        Tr[i]=(owo) {0,0,i,x,1,0};
        root=merge(root,i);
    }    
    
    for(R II i=1,l,r;i<=n;i++)
    {
        updata(root);
        printf("%lld ",Tr[Tr[root].l].siz+i);
        l=Tr[root].l; r=Tr[root].r;
        Tr[root].l=Tr[root].r=0;
        Tr[l].lazy^=1;
        root=merge(l,r);
    }
    exit(0);
}
```

是不是特别短？？！

【滑稽】


---

## 作者：CDFLS_mao_zx (赞：5)

# P3195 机械臂排序   
写了一下午题不想写了，于是来一发题解  。  
首先我们要搞清楚这道题要我们干什么    。
## 题意  
给你一个序列，n次操作，第i次操作找到i-1之后最小的数的位置，将i到这里做翻转，问每次操作所找到的那个位置。  
为什么是最小值，因为每一次操作你翻转区间时都将i-1之后的最小值翻到i了，所以i+1次操作要找序列中i+1小值就一定是i之后的最小值。
## 心路历程
做了文艺平衡树的板子后跳到这道题，一时不知道怎么搞查询操作，然后。。。   
参考了网上大佬们题解后终于有了一点点思路，然后是让人发疯的调试。  
我暂时放下，然后教练讲了LCT，对splay的理解深了几分，最后才做出来 。 
## 思考过程&&思路
这道题要我们做区间翻转操作，哪种数据结构可以快速实现呢？  
毫无疑问平衡树。  
具体怎么做？  
我个人比较喜欢splay，所以本题解是splay版。  
我们以一个数在数列中的位置为关键值将其插入splay，所以splay的中须遍历就是这个数列。   
怎样翻转？？    
我们只需要将代表着这个区间的splay整颗翻转。   
也就是说将这颗splay所有非叶子节点的节点的左右子树交换。  
大家可以自己画图思考一下。  
我就不给图了。   
我们怎样将一个区间提出来呢。  
我们维护每个点的size，也就是子树大小。  
然后我们将这个区间左端点前一个点（设其为x）splay到根，右端点后一个点（设其为y）splay为x的右儿子，因为y的关键值比x大，所以y一定是x右儿子。   
   想想splay的性质，每个节点右子树的所有点关键值大于该点，左子树的所有点关键值小于该点，所以y的左子树的所有点的关键值都小于y而且大于x，又因为我们每个关键值只对应一个点，所以这个区间所有点都包含在y的左子树。  
为什么是所有点呢？？   
因为x到根了，所以x的左子树关键值都小于x，y右子树的关键值都大于y，所以关键值大于x小于y的点都在y的左子树上。  
我们对给出的数列以高度为第一关键字，位置为第二关键字升序排序。  
然后我们就得到了每个点的实际数值。    
我们设计一个叫size_rt的函数，来找当前数列第x个数所在节点的编号。   
```cpp
int size_rt(int u,int x)
{
	push_down(u);//我们翻转整颗子树是不可能暴力翻转，所以只翻转一个点
	//用lazy标记来表示一个点儿子是否已翻转，要访问儿子时就要push_down
	//一个点左子树的点数量代表在这颗子树所代表的序列中它之前的点的数量 
	//右子树点的数量同理
   while(a[a[u].son[0]].size+1!=x)//如果当前点不是数列中的第x个点 
	{
	if(a[a[u].son[0]].size>=x) 
	u=a[u].son[0];
	else
	{
		x-=1+a[a[u].son[0]].size;//左子树中没有这个点，就要在右子树中找 
		u=a[u].son[1];
	}
	push_down(u);
	}
	return u;
}
```     
我写成递归吧。  
```cpp
int size_rt(int u,int x)
{
	push_down(u);
	if(a[a[u].son[0]].size+1==x)
	return u;
	if(a[a[u].son[0]].size>=x)
	return size_rt(a[u].son[0],x);
	return size_rt(a[u].son[1],x-1-a[a[u].son[0]].size);
}
```


再设计一个叫find的函数，用来找i-1之后的实际数值最小值所在节点编号。  
```
//while循环版 
int find(int u)
{
	while(a[u].val!=a[u].mi)
	{
		push_down(u);
		if(a[a[u].son[0]].mi==a[u].mi)
		u=a[u].son[0];
		else
		u=a[u].son[1];
	}
	return u;
}
//递归版
//int find(int u)
//{
//	if(a[u].val==mi)
//	return u;
//	push_down(u);
//	if(a[a[u].son[1]].mi==a[u].mi)//我们保证每个关键值只有一个 
//	return find(a[u].son[1]);
//	return find(a[u].son[0]);
//} 
```  
这两个函数用来做甚？？   
现在考虑查询。  
我们查询时先得到序列中第i-1个点所在节点的编号。  
把这个节点splay到根，再在它的右子树上查最小值所在的节点的编号（设其为a）
也就是查i-1之后的最小值所在节点的编号。  
将a spaly到到根，a在序列中的位置就是a左儿子的size+1。  
用find找到a右边的那个点在splay中的编号，提出要翻转的区间进行翻转操作，这就是一次完整的查询了。

所有的操作都讲完了，这道题也就只剩打字啦啦啦。 
```
int quert(int x)//有人问我为啥是quert，
//因为我第一次学线段树是将query打成了quert，
//然后发现ert三个字母在键盘上是连续的，顺手，所以。。。
{
	int u;
	splay(x,0);
	u=find(a[x].son[1]);
	splay(u,0);
	int tt=a[a[u].son[0]].size+1;//记录位置。
        //splay时儿子会变，所以要提前记。
	u=size_rt(root,tt+1);
	splay(x,0);
	splay(u,x);//提区间。
	fz(a[u].son[0]);
	return tt-1;//为什么是减一代码中解释。
}
```
## 完整代码  
```
#include<bits/stdc++.h>
using namespace std;
int i,j,k,m,n,s,t,root,js,st[100100];
const int N=1e6+10;
struct tree{
	int son[2],fa,val,mi,sum,size;
	tree()
	{
		son[0]=son[1]=fa=0;
		size=1;
		mi=2e9;//一定要赋初值，不然最小值会变0。
	}
}a[N];
struct fu{
	int num,rank;
}b[N];
int lazy[N],tid[N];
bool cmp(fu aa,fu bb)
{
	if(aa.num!=bb.num)
	return aa.num<bb.num;
	return aa.rank<bb.rank;
}
void push_up(int rt)
{
	if(rt==0)
	return;
	a[rt].mi=min(min(a[a[rt].son[0]].mi,a[a[rt].son[1]].mi),a[rt].val);
	a[rt].size=a[a[rt].son[1]].size+a[a[rt].son[0]].size+1;
}
void fz(int rt)
{
	if(rt==0)
	return;
	swap(a[rt].son[0],a[rt].son[1]);
	lazy[rt]^=1;
}
void push_down(int rt)
{
	if(lazy[rt]==0)
	return;
	fz(a[rt].son[0]);
	fz(a[rt].son[1]);
	lazy[rt]=0;
}
void xz(int x)
{
	int y=a[x].fa,z=a[y].fa;
	int o=a[y].son[1]==x,b=a[x].son[o^1];
	a[x].fa=z;
	if(z)
	a[z].son[a[z].son[1]==y]=x;
	a[x].son[o^1]=y;
	a[y].fa=x;
	a[y].son[o]=b;
	if(b)
	a[b].fa=y;
	push_up(y);//注意这里的顺序。
	push_up(x);
}
void splay(int x,int c)
{
	int top=0;
	int y=a[x].fa;
	st[++top]=x;
	while(y)
	st[++top]=y,y=a[y].fa;
	while(top)
	push_down(st[top--]);//我们splay时没保证所有点都pushdown过了
	//所以要预先处理，我是先学了LCT才意识到的。
	y=a[x].fa;
	for(;y!=c;)
	{
		if(a[y].fa!=c)
		xz(((a[a[y].fa].son[1]==y)^(a[y].son[1]==x))==0?y:x);
		xz(x);
		y=a[x].fa;
	}
	if(c==0)
	root=x;//换根。
}
void add(int u,int x)
{
	// 我们是严格顺序加点。
	while(a[u].son[1]!=0)//加点操作，往右儿子放就行。
	u=a[u].son[1];
	a[u].son[1]=++js;
	a[js].fa=u;
	a[js].val=x;
	a[js].mi=x;
	splay(js,0);//保证复杂度并向上更新。
}
//这是while循环版。
//int size_rt(int u,int x)
//{
//	push_down(u);//我们翻转整颗子树是不可能暴力翻转，所以只翻转一个点。
//	//用lazy标记来表示一个点儿子是否已翻转，要访问儿子时就要push_down。
//	//一个点左子树的点数量代表在这颗子树所代表的序列中它之前的点的数量 。
//	while(a[a[u].son[0]].size+1!=x)//如果当前点不是数列中的第x个点。
//	{
//	if(a[a[u].son[0]].size>=x) 
//	u=a[u].son[0];
//	else
//	{
//		x-=1+a[a[u].son[0]].size;//左子树中没有这个点，就要在右子树中找。
//		u=a[u].son[1];
//	}
//	push_down(u);
//	}
//	return u;
//}
//这是递归版。
int size_rt(int u,int x)
{
	push_down(u);
	if(a[a[u].son[0]].size+1==x)
	return u;
	if(a[a[u].son[0]].size>=x)
	return size_rt(a[u].son[0],x);
	return size_rt(a[u].son[1],x-1-a[a[u].son[0]].size);
}
//while循环版 
int find(int u)
{
	while(a[u].val!=a[u].mi)
	{
		push_down(u);
		if(a[a[u].son[0]].mi==a[u].mi)
		u=a[u].son[0];
		else
		u=a[u].son[1];
	}
	return u;
}
//递归版
//int find(int u)
//{
//	if(a[u].val==mi)
//	return u;
//	push_down(u);
//	if(a[a[u].son[1]].mi==a[u].mi)//我们保证每个关键值只有一个 
//	return find(a[u].son[1]);
//	return find(a[u].son[0]);
//} 
int quert(int x)
{
	int u;
	splay(x,0);
	u=find(a[x].son[1]);
	splay(u,0);
	int tt=a[a[u].son[0]].size+1;
	u=size_rt(root,tt+1);
	splay(x,0);
	splay(u,x);
	fz(a[u].son[0]);
	return tt-1;//因为有哨兵节点
	//所以点比实际多一个 
}
int main()
{
//	freopen("data.in","r",stdin);
	a[0].size=0;
	scanf("%d",&n);
	for(i=1;i<=n;i++)	
	{
		scanf("%d",&b[i].num);
		b[i].rank=i;
	}
	sort(b+1,b+n+1,cmp);//排序，离散化 
	for(i=1;i<=n;i++)
	tid[b[i].rank]=i;//tid[i]表示i位置的离散后数值 
	add(root,1e9);//加两个哨兵节点，预防find时find出去了 
	for(i=1;i<=n;i++)
	add(root,tid[i]);
	add(root,1e9);
	for(i=1;i<=n;i++)
	{
		int yt=size_rt(root,i);
		printf("%d ",quert(yt));
	}
	return 0;
}
```








---

## 作者：Melacau (赞：5)

# **fhq treap 无旋treap**

##题意简析

你需要维护一个序列，支持区间翻转与查询区间最小。

##解题思路

由于区间最小实际上每一次就是对应的整个数列的第k小，因此可以直接预处理解决，接下来考虑如何找到这个点，可以直接用一个指针解决，然后就是简单的无旋treap操作：


给定一个平衡树上节点，求它在当前序列中的下标，首先我们先将这个点到平衡树根节点的标记下传，使用递归解决，然后就直接根据BST的性质查找即可。


其余的就是按照题意进行区间rotate，这是无旋treap的简单操作之一，不多赘述。


代码中还有很多东西是可以优化的，例如不需要存储val，可以舍弃已经有序的区间等，如果你能做到的话，应该是轻松Rank1的节奏？

```cpp
#include <stdio.h>
#include <algorithm>
#define r register
#define MN 100005
#define getchar() (S==TT&&(TT=(S=BB)+fread(BB,1,1<<15,stdin),TT==S)?EOF:*S++)
char BB[1<<15],*S=BB,*TT=BB;
inline int in(){
    r int x=0; r bool f=0; r char c;
    for (;(c=getchar())<'0'||c>'9';f=c=='-');
    for (x=c-'0';(c=getchar())>='0'&&c<='9';x=(x<<3)+(x<<1)+c-'0');
    return f?-x:x;
}
namespace Treap{
    inline int Rand(){
        static int x=23333;
        return x^=x<<13,x^=x>>17,x^=x<<5;
    }
    struct node{
        node *ls,*rs,*fa;
        int val,sz,pri;bool rev;
        inline void reverse(){std::swap(ls,rs);if (ls) ls->rev^=1;if (rs) rs->rev^=1;rev=0;}
        inline void pushdown(){if (rev) reverse();}
        inline void combine(){
            sz=1;if (ls) sz+=ls->sz,ls->fa=this;
            if (rs) sz+=rs->sz,rs->fa=this;
        }
        node(int val):val(val){sz=1,pri=Rand(),rev=0,fa=ls=rs=NULL;}
    }*root,*pos[MN];    
    struct Droot{node *a,*b;};
    inline int Size(node *x){return x?x->sz:0;}
    node *merge(node *a,node *b){
        if (!a) return b;if (!b) return a;
        if (a->pri<b->pri){
            a->pushdown();
            a->rs=merge(a->rs,b);
            a->combine();return a;
        }else{
            b->pushdown();
            b->ls=merge(a,b->ls);
            b->combine();return b;
        }
    }
    Droot split(node *x,int k){
        if (!x) return (Droot){NULL,NULL};
        r Droot y;x->pushdown();
        if (k<=Size(x->ls)){
            y=split(x->ls,k);
            x->ls=y.b;x->combine();y.b=x;
        }else{
            y=split(x->rs,k-Size(x->ls)-1);
            x->rs=y.a;x->combine();y.a=x;
        }return y;
    }
    inline void Rotate(node *x){if (!x) return;Rotate(x->fa);x->pushdown();}
    inline int getpos(node *x){
        Rotate(x);r int res=Size(x->ls)+1;
        while (x->fa!=NULL){
            if (x->fa->rs==x) res+=Size(x->fa->ls)+1;x=x->fa;
        }return res;
    }
    inline int Get_Ans(int k){    
        r int ord=getpos(pos[k]);
        Droot x=split(root,ord);
        Droot y=split(x.a,k-1);
        y.b->rev^=1;root=merge(merge(y.a,y.b),x.b);
        return ord;
    }
}using namespace Treap;
struct things{
    int ord,val;
    inline bool operator <(const things &b)const{
        return val<b.val||(val==b.val&&ord<b.ord);
    }
}a[MN];int n,val[MN],rnk[MN];
void init(){
    n=in();
    for (int i=1; i<=n; ++i) val[i]=in(),a[i].ord=i,a[i].val=val[i];
    std::sort(a+1,a+n+1);for (r int i=1; i<=n; ++i) rnk[a[i].ord]=i;
    for (r int i=1; i<=n; ++i){
        pos[rnk[i]]=new node(val[i]);
        root=merge(root,pos[rnk[i]]);
    }
}
void solve(){for (r int i=1; i<=n; ++i) printf("%d ",Get_Ans(i));}
int main(){init();solve();return 0;}
```
[本人blog传送门](http://www.cnblogs.com/Melacau/p/BZOJ3506.html)，还请支持owo.


---

## 作者：zyh2015 (赞：4)

本题需要维护一个序列，支持区间翻转、区间查找。


Splay练手题。


第k大元素的位置可以预处理出来，但是每一次排序之后位置会发生变化，怎么找到那个元素呢


用一个指针数组来保存所在结点就好啦


Query函数用来计算一个元素在序列中的位置


```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cstdlib>
#define N 100005
using namespace std;
struct Point{
    int ord,v;
    Point(int x=0,int y=0):ord(x),v(y){}
    bool operator < (const Point &rhs) const{return (v<rhs.v) || (v==rhs.v && ord<rhs.ord);}
};
struct Node{
    Node *ch[2],*pa;
    Point v;
    int s;
    bool flip;
    Node(int ,int);
    int cmp(int x){
        if(x==(ch[0]->s+1)) return -1;
        return x<ch[0]->s+1 ? 0 : 1;
    }
    void maintain(){
        s=ch[0]->s+ch[1]->s+1;
        return ;
    }
    void pushdown(){
        if(!flip) return ;
        flip=false;
        swap(ch[0],ch[1]);
        ch[0]->flip=!ch[0]->flip;
        ch[1]->flip=!ch[1]->flip;
        return ;
    }
}*null,*root,*pos[N];
Node :: Node(int x=0,int y=0){s = null ? 1 : 0; ch[0]=ch[1]=pa=null; v=Point(x,y); flip=false;}
void Rotate(Node* &o,int d){
    Node *k=o->ch[d^1];
    o->ch[d^1]=k->ch[d]; k->ch[d]->pa=o;
    k->ch[d]=o; k->pa=o->pa; o->pa=k;
    o->maintain(); k->maintain();
    o=k;
    return ;
}
void Splay(Node* &o,int k){
    o->pushdown();
    int d=o->cmp(k);
    if(d==1) k-=o->ch[0]->s+1;
    if(d!=-1){
        Node *p=o->ch[d];
        p->pushdown();
        int d2=p->cmp(k);
        if(d2==1) k-=p->ch[0]->s+1;
        if(d2!=-1){
            Splay(p->ch[d2],k);
            if(d==d2) Rotate(o,d^1);
            else Rotate(o->ch[d],d);
        }
        Rotate(o,d^1);
    }
    return ;
}
Node* Merge(Node *l,Node *r){
    Splay(l,l->s);
    l->ch[1]=r;
    l->maintain();
    r->pa=l;
    return l;
}
int Query(Node* x,Node*& las){
    int cach=0;
    if(x->pa!=null) cach+=Query(x->pa,x);
    x->pushdown();
    if(x->ch[1]==las) cach+=x->ch[0]->s+1;
    return cach;
}
Point seq[N];
int pre[N],fi[N];
int main(){
    null=new Node();
    null->ch[0]=null->ch[1]=null->pa=null;
    int n;
    scanf("%d",&n);
    root=null;
    for(int i=1;i<=n;i++) scanf("%d",&pre[i]) , seq[i]=Point(i,pre[i]);
    sort(seq+1,seq+1+n);
    for(int i=1;i<=n;i++) fi[seq[i].ord]=i;
    for(int i=1;i<=n;i++){
        Node *y=new Node(i,pre[i]);
        y->ch[0]=y->ch[1]=y->pa=null;
        pos[fi[i]]=y;
        if(i==1) root=y;
        else root=Merge(root,y);
    }
    for(int i=1;i<=n;i++){
        int cach=Query(pos[i],pos[i]->ch[1]);
        if(i!=n) printf("%d ",cach+i-1);
        else printf("%d",cach+i-1);
        if(root->s==cach) root->flip=!root->flip;
        else {
            Splay(root,cach+1);
            root->ch[0]->flip=!root->ch[0]->flip;
        }
        Splay(root,1);
        Node *r=root->ch[1];
        delete root;
        root = r ;
        root->pa=null;
    }
    printf("\n");
    return 0;
}
```

---

## 作者：Isonan (赞：2)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P3165)

~~Fhq Treap吼啊！！~~

这题很明显要用平衡树进行查询排名和区间翻转。

我们发现每次查询的都是当前权值最小的点，于是我们考虑能不能把fhq treap的key值改变一下，变成当前该点的高度。

因为fhq treap满足堆的性质，这样每次要查询的点就一定是当前的根节点。

至于区间翻转，只要把根节点的左子树打上懒标，然后把根节点删掉（这样就可以保证接下来要查询的点是新的根节点），删除可以参照左偏树，把左右子树合并就可以了。

PS：注意高度相等时特判~~（什么？！不是说好了‘高低不等’的吗？）~~

代码：

```cpp
#include <cstdio>

int ch[100001][2],size[100001];
long long val[100001];
int tem,root,n;
bool lazy[100001];
inline void swap(int &a,int &b){a^=b^=a^=b;}
inline void spread(int x){
    if(lazy[x]){
        swap(ch[x][0],ch[x][1]);
        if(ch[x][0])lazy[ch[x][0]]^=1;
        if(ch[x][1])lazy[ch[x][1]]^=1;
        lazy[x]=0;
    }
}
inline void pushup(int x){if(x)size[x]=size[ch[x][0]]+size[ch[x][1]]+1;}
int merge(int x,int y){
    if(!x||!y)return x^y;
    if(val[x]<val[y]){
        spread(x);
        ch[x][1]=merge(ch[x][1],y);
        pushup(x);
        return x;
    }
    else{
        spread(y);
        ch[y][0]=merge(x,ch[y][0]);
        pushup(y);
        return y;
    }
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%lld",val+i);
        val[i]*=100000;
        val[i]+=i;
        size[i]=1;
        root=merge(root,i);
    }
    for(int i=1;i<=n;i++){
        spread(root);
        printf("%d ",size[ch[root][0]]+i);
        if(ch[root][0])lazy[ch[root][0]]^=1;
        root=merge(ch[root][0],ch[root][1]);
    }
    putchar('\n');
}
```

---

## 作者：斯德哥尔摩 (赞：1)

表示楼下的几篇题解并没有看懂，于是自己来一发。。。

区间翻转当然splay！来一发结构体无指针splay。。。

~~（如果你真的要用 fhq treap 我也不会拦着你）~~

#### 预处理

我们会发现一个问题：高度是无序的，而splay中要求有序，否则kth不能正确求解。

怎么办呢？？？

又发现，不需要求高度，只要求位置。

所以，我们用结构体存入 高度 与 下标，按高度排序，然后就可以把高度丢一边了~~（一波sao操作）~~。

记得头尾添加两个哨兵节点。。。

#### 建树

正常 nlogn 可能会被卡常，所以，类似于线段树的建树，分此节点与左右儿子节点。

代码：见下方 splay::buildtree。

#### 区间第k大

正常kth~~（别跟我说不会）~~

代码：见下方 splay::kth。

#### 区间翻转

首先，需要把所求的节点（即排序前下标为id的节点） splay 到 root 。

那么答案就是root左孩子的节点个数（因为有哨兵节点，所以+1-1抵消）,记为s。

然后，取出 [i+1 , s+1] 这段区间，即：

将i节点 splay 到根，s+2节点 splay 到i的右节点。

再将s+2的左孩子打上翻转标记即可。

代码：见下方 splay::reserve。

##### 如果你已经看完上方所有问题，这还有最后一个问题：

#### 标记下传

将左右孩子翻转标记打上，此节点标记清空，交换左右孩子。

但是仅有这样不行，还要在 kth 中循环的开头每次一下 pushdown。

然而还不全对——splay每次也要 pushdown （三个点都要!）。

代码：见下方 splay::pushdown。

如果你已经看完上方所有问题，但是并不能AC，并且确定代码，没有思路错误，看代码吧。

附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define MAXN 100010
#define MAX 999999999//最值
using namespace std;
int n,size=1,root=0;
struct node{
    int x,id;
}b[MAXN];
namespace splay{//我就喜欢用 namespace 封装
    struct Splay{
        int f,s,flag,son[2];
        int v;//这个可有可无（若删去，下面也有要删的。。。）
    }a[MAXN];
    inline void clean(int rt){//清空节点
        a[rt].son[0]=a[rt].son[1]=a[rt].f=a[rt].s=a[rt].flag=a[rt].v=0;
    }
    inline void pushup(int rt){//上传
        if(!rt)return;
        a[rt].s=a[a[rt].son[0]].s+a[a[rt].son[1]].s+1;
    }
    inline void pushdown(int rt){//标记下传
        if(!rt||!a[rt].flag)return;//记得这句
        a[a[rt].son[0]].flag^=1;a[a[rt].son[1]].flag^=1;a[rt].flag^=1;
        swap(a[rt].son[0],a[rt].son[1]);
    }
    inline void turn(int rt,int k){//旋转
        int x=a[rt].f,y=a[x].f;
        a[x].son[k^1]=a[rt].son[k];
        if(a[rt].son[k])a[a[rt].son[k]].f=x;
        a[rt].f=y;
        if(y)a[y].son[a[y].son[1]==x]=rt;
        a[x].f=rt;
        a[rt].son[k]=x;
        pushup(x);pushup(rt);
    }
    void splay(int rt,int ancestry){//伸展
        while(a[rt].f!=ancestry){
            int x=a[rt].f,y=a[x].f;
            pushdown(y);pushdown(x);pushdown(rt);//每次都要下传
            if(y==ancestry)turn(rt,a[x].son[0]==rt);
            else{
                int k=a[y].son[0]==x?1:0;
                if(a[x].son[k]==rt){turn(rt,k^1);turn(rt,k);}
                else{turn(x,k);turn(rt,k);}
            }
        }
        if(ancestry==0)root=rt;
    }
    inline int newnode(int x){//建立新节点
        int rt=size++;
        clean(rt);
        a[rt].v=x;a[rt].s=1;
        return rt;
    }
    int buildtree(int l,int r){//建树
        if(l>r)return 0;
        int mid=l+r>>1,lson=0,rson=0;
        lson=buildtree(l,mid-1);
        int rt=newnode(b[mid].x);
        rson=buildtree(mid+1,r);
        a[rt].son[0]=lson;
        a[rt].son[1]=rson;
        if(lson)a[lson].f=rt;
        if(rson)a[rson].f=rt;
        pushup(rt);//一定要有这句！
        return rt;
    }
    int kth(int rt,int k){//第k大值
        if(a[rt].s<k)return 0;
        while(1){
            pushdown(rt);//下传
            int y=a[rt].son[0];
            if(k>a[y].s+1){
                k-=a[y].s+1;
                rt=a[rt].son[1];
            }
            else if(k<=a[y].s)rt=y;
            else return rt;
        }
    }
    inline void reverge(int i){//区间翻转
        splay(b[i].id+1,0);//记得加1（有哨兵节点）
        int s=a[a[root].son[0]].s;
        printf("%d ",s);
        int front=kth(root,i),next=kth(root,s+2);
        splay(front,0);splay(next,front);
        a[a[next].son[0]].flag^=1;//打上标记
    }
}
inline int read(){//读优
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
bool cmp(const node &x,const node &y){
    if(x.x==y.x)return x.id<y.id;
    return x.x<y.x;
}
void init(){//预处理+读入+工作
    n=read();
    for(int i=1;i<=n;i++){
        b[i].x=read();
        b[i].id=i;
    }
    b[0].x=-MAX;b[0].id=1;
    b[n+1].x=MAX;b[n+1].id=n+1;//两个哨兵节点
    sort(b+1,b+n+1,cmp);
    root=splay::buildtree(0,n+1);
    for(int i=1;i<=n-1;i++)splay::reverge(i);
    printf("%d\n",n);//最后一个一定是 n
}
int main(){//主函数So easy！
    init();
	return 0;
}

```

---

## 作者：2018LZY (赞：0)

【前置题目】[文艺平衡树](https://www.luogu.org/problemnew/show/P3391)

贴一个本人的代码。
```cpp
//用中序遍历表示序列，通过对树的对称翻转实现中序遍历（即序列）的改变。
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1e5+10;
struct trnode
{
	int d,c,f,son[2];//d表示原序列对应的数，伸展树并不按d来排名,n值为1，不必把多个节点压成一个点。 
	bool v;//翻转标记。1则要翻转。这样实际上是为了实现lazy操作。 
}tr[N];int root,len,n,m;
void update(int x)
{
	int lc=tr[x].son[0],rc=tr[x].son[1];
	tr[x].c=tr[lc].c+tr[rc].c+1;
}
void bt(int &x,int f,int l,int r)//build tree
{
	if(l>r){x=0;return;}
	int m=(l+r)>>1;
	x=++len;tr[len].d=m;tr[len].c=1;tr[len].f=f;tr[len].v=0;
	bt(tr[x].son[0],x,l,m-1);
	bt(tr[x].son[1],x,m+1,r);
	tr[x].c=tr[tr[x].son[0]].c+tr[tr[x].son[1]].c+1;
}
void rotate(int x,int w)
{
	int f=tr[x].f,ff=tr[f].f,r,R;
	
	r=tr[x].son[w];R=f;
	tr[R].son[1^w]=r;
	if(r)tr[r].f=R;
	
	r=x;R=ff;
	if(tr[R].son[0]==f)tr[R].son[0]=r;else tr[R].son[1]=r;
	tr[r].f=R;
	
	r=f;R=x;
	tr[R].son[w]=r;
	tr[r].f=R;
	
	update(f);
	update(x);
}
void splay(int x,int rt)
{
	while(tr[x].f!=rt)
	{
		int f=tr[x].f,ff=tr[f].f;
		if(ff==rt)
		{
			if(tr[f].son[0]==x)rotate(x,1);else rotate(x,0);
		}
		else
		{
			     if(tr[ff].son[0]==f&&tr[f].son[0]==x)rotate(f,1),rotate(x,1);
			else if(tr[ff].son[1]==f&&tr[f].son[1]==x)rotate(f,0),rotate(x,0);
			else if(tr[ff].son[0]==f&&tr[f].son[1]==x)rotate(x,0),rotate(x,1);
			else if(tr[ff].son[1]==f&&tr[f].son[0]==x)rotate(x,1),rotate(x,0);
		}
	}
	if(!rt)root=x;
}
void wh(int x)//维护
{
	int &lc=tr[x].son[0],&rc=tr[x].son[1];
	swap(lc,rc);
	tr[x].v=0;
	tr[lc].v^=1;
	tr[rc].v^=1;
}
int findnum(int k)//找排名为k，即中序遍历排第k的编号 
{
	int x=root;
	while(1)
	{
		if(tr[x].v)wh(x);
		int lc=tr[x].son[0],rc=tr[x].son[1];
		if(tr[lc].c>=k)x=lc;
		else if(tr[lc].c+1>=k)break;
		else k-=tr[lc].c+1,x=rc;
	}
	return x;
}
void fz(int l,int r)//对中序遍历排名为l~r的序列进行处理。 
{
	int x=findnum(l-1),y=findnum(r+1);
	splay(x,0);splay(y,x);
	tr[tr[y].son[0]].v^=1;
}
#define g getchar()
void qr(int &x)
{
	char c=g;x=0;
	while(!('0'<=c&&c<='9'))c=g;
	while('0'<=c&&c<='9')x=x*10+c-'0',c=g;
}
void write(int x)//快写 
{
	if(x/10)write(x/10);
	putchar(x%10+'0');
}
void pri(int x)//中序遍历。
{
	if(!x)return;
	if(tr[x].v)wh(x);
	pri(tr[x].son[0]);
	if(tr[x].d!=0)write(tr[x].d),putchar(' ');
	pri(tr[x].son[1]);
}
int main()
{
	qr(n);qr(m);
	bt(tr[0].son[0],0,0,n+1);//多加两个边界点。 
	root=tr[0].son[0];
	tr[len].d=0;//设定边界
	while(m--)
	{
		int l,r;qr(l);qr(r);
		l++;r++;
		fz(l,r);
	}
	pri(root);
	puts("");
	return 0;
}

```


【简明题意】

$有n次操作,第i次操作为找到并输出[i,n]中最小值所处的位置P_i(相同值时取原位置小的)$

【吐槽】

我一开始用两棵平衡树维护——一棵维护值，一棵维护位置，结果做了两天才做出来。看看题解，发现只用一棵树就够了。	QwQ

【思路】

#### 1.按值sort,求出每次应处理的标号(同一个数的标号始终不变，这个要看代码理解）。
#### 2.把要处理的点splay上去，输出左子树的节点数即可。(在两端塞了哨兵结点，所以不要+1）
#### 3.记得翻转。
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define g getchar()
#define lc tr[x].son[0]
#define rc tr[x].son[1]
using namespace std;
void qr(int &x)
{
	char c=g;bool v=(x=0);
	while(!( ('0'<=c&&c<='9') || c=='-' ))c=g;
	if(c=='-')v=1,c=g;
	while('0'<=c&&c<='9')x=x*10+c-'0',c=g;
	if(v)x=-x;
}
void write(int x)
{
	if(x/10)write(x/10);
	putchar(x%10+'0');
}
const int N=1e5+10;
struct node
{
	int x,id;//值和标号
	bool operator <(node b)const{return x==b.x?id<b.id:x<b.x;}
	//重载运算符——高逼格的操作——当然也可以在外面打cmp 
}a[N];int n;
struct trnode
{
	int c,f,son[2];//c为子树结点总数，f为父节点，son为子节点 
	bool v;//翻转标记 
}tr[N];int root;
void update(int x){tr[x].c=tr[lc].c+tr[rc].c+1;}//更新 
void bt(int &x,int f,int l,int r)//递归建树 
{
	if(l>r){x=0;return;}
	x=(l+r)>>1;
	//这里的标号对应序列中标号-1的位置(如树上2号点对于序列1号位置)——方便处理 
	tr[x].f=f;tr[x].v=0;
	bt(tr[x].son[0],x,l,x-1);
	bt(tr[x].son[1],x,x+1,r);
	update(x);
}
void rotate(int x,int w)//旋转
{
	int f=tr[x].f,ff=tr[f].f,r,R;
	
	r=tr[x].son[w];R=f;
	tr[R].son[1-w]=r;
	if(r)tr[r].f=R;
	
	r=x;R=ff;
	tr[R].son[tr[R].son[1]==f]=r;
	tr[r].f=R;
	
	r=f;R=x;
	tr[R].son[w]=r;
	tr[r].f=R;
	
	update(f);
	update(x);
}
void splay(int x,int rt)
{
	if(!x)return;
	while(tr[x].f!=rt)
	{
		int f=tr[x].f,ff=tr[f].f;
		if(ff==rt)rotate(x,tr[f].son[0]==x);
		else
		{
				 if(tr[ff].son[0]==f&&tr[f].son[0]==x)rotate(f,1),rotate(x,1);
			else if(tr[ff].son[1]==f&&tr[f].son[1]==x)rotate(f,0),rotate(x,0);
			else if(tr[ff].son[0]==f&&tr[f].son[1]==x)rotate(x,0),rotate(x,1);
			else if(tr[ff].son[1]==f&&tr[f].son[0]==x)rotate(x,1),rotate(x,0);
		}
	}
	if(!rt)root=x;
}
int findnum(int k)//找排名为k的标号
{
	int x=root;
	while(1)
	{
		if(tr[x].v)
		{
			tr[x].v=0;swap(lc,rc);
			tr[lc].v^=1;tr[rc].v^=1;
		}
		if(tr[lc].c>=k)x=lc;
		else if(tr[lc].c+1>=k)break;
		else k-=tr[lc].c+1,x=rc;
	}
	return x;
}
void wh(int x)//递归维护翻转
{
	if(!x)return;
	wh(tr[x].f);
	if(tr[x].v)
	{
		tr[x].v=0;swap(lc,rc);
		tr[lc].v^=1;tr[rc].v^=1;
	}
}
void fz(int l,int r)
{
	l=findnum(l-1);r=findnum(r+1);
	splay(l,0);splay(r,l);
	tr[tr[r].son[0]].v^=1;
}
int find_rank(int x)
{
	wh(x);splay(x,0);
	write(tr[tr[x].son[0]].c);putchar(' ');
	return tr[tr[x].son[0]].c;
}
int main()
{
	qr(n);
	for(int i=1;i<=n;i++)qr(a[i].x),a[i].id=i;
	sort(a+1,a+n+1);
	bt(tr[0].son[0],0,1,n+2);root=tr[0].son[0];//多加两个哨兵节点 
	for(int i=1;i<=n;i++)
	{
		fz(i+1,find_rank(a[i].id+1)+1);
	}
	return 0;
}
```


---

## 作者：ZPC2048 (赞：0)

### 看起来没有大佬发布有删除操作的版本，我在这里就献丑了....(~~福利~~[Splay习题地址，我的代码思路参考这个大佬的QAQ](https://www.cnblogs.com/kuangbin/archive/2013/04/21/3034081.html))

**PS：原题有多组数据，但本题没有，请注意区分。~~别抄错了~~**



------------


## 大体的思路分为以下几步：

### 1. 找到第i小的节点

### 2. 将其旋转到根，得到其左子树大小，即其位置

### 3. 将根节点的左子树翻转（注：我们会删除掉第i小的节点，所以没有必要将其翻转）

### 4. 删除根节点，返回第1步

这里需要区分两个概念：即节点本身的大小和节点的位置。**splay维护的是节点的位置而不是节点的大小**

节点按位置插入splay中将会打乱其大小的有序性（~~什么，你说题目输入无序？请使用sort~~），所以我们需要一个东西保存某个值对应的splay树中的节点编号，以便于后续的操作。这里可以选择`pair`或者自己写个结构体。

**PS:本解法无需哨兵节点！~~当然你加我也没意见，不过复杂度上升很高的说~~**

下面是蒟蒻的代码QAQ，部分解释将于代码注释给出

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int MAXN = 100000 + 10;

struct Node{//保存节点的大小和位置。
    int id, data;//id->位置;data->大小
    Node(int id = 0, int data = 0):
        id(id), data(data){};
    bool operator < (const Node &A)const{
        if(data == A.data) return id < A.id;
        return data < A.data;
    }
};

struct SplayTree{
    int child[MAXN][2], father[MAXN];
    int size[MAXN], lazy[MAXN];
    int root;
    Node node[MAXN];
    inline int build(int l, int r){//建树操作
        if(l > r) return 0;
        if(l == r){
            size[l] = 1;
            child[l][0] = child[l][1] = lazy[l] = 0;
            return l;
        }
        int mid = (l + r) >> 1;
        lazy[mid] = 0;
        if((child[mid][0] = build(l, mid - 1))) father[child[mid][0]] = mid;//这里与常规的newNode操作不同，因为要保证splay中节点的编号和上面的node中的id一致，具体情况可自行思考
        if((child[mid][1] = build(mid + 1, r))) father[child[mid][1]] = mid;
        pushup(mid);
        return mid;
    }
    inline int chk(int x){
        return child[father[x]][1] == x;
    }
    inline void pushup(int x){
        size[x] = size[child[x][0]] + size[child[x][1]] + 1;
    }
    inline void pushdown(int x){
        if(!lazy[x]) return;
        int lson = child[x][0], rson = child[x][1];
        if(lson){
            lazy[lson] ^= 1;
            swap(child[lson][0], child[lson][1]);
        }
        if(rson){
            lazy[rson] ^= 1;
            swap(child[rson][0], child[rson][1]);
        }
        lazy[x] = 0;
    }
    inline void rotate(int x){
        int f = father[x], gf = father[f];
        pushdown(f); pushdown(x);//这两句貌似没毛用？
        int xk = chk(x), w = child[x][xk ^ 1];
        if(gf) child[gf][chk(f)] = x;
        father[x] = gf;
        father[f] = x, child[x][xk ^ 1] = f;
        father[w] = f, child[f][xk] = w;
        pushup(f); pushup(x);
    }
    inline void splay(int x, int goal = 0){//因为我们有删除操作，而splay涉及到左右儿子的问题，所以操作前先pushdown
        pushdown(x);
        while(father[x] != goal){
            int f = father[x];
            if(father[f] == goal){
                pushdown(f); pushdown(x);
                rotate(x);
            }
            else{
                pushdown(father[f]); pushdown(f); pushdown(x);
                if(chk(f) == chk(x)) rotate(f);
                else rotate(x);
                rotate(x);
            }
            
        }
        pushup(x);
        if(!goal) root = x;
    }
    inline int pre(int now){//搜索某一节点的上一位置
        pushdown(now);
        while(child[now][1]){
            now = child[now][1];
            pushdown(now);
        }
        return now;
    }
    inline int rank(int k){
        splay(k);
        return size[child[root][0]];
    }
    inline void reverse(int now){//根节点左子树的就是需要翻转的节点，无需再splay其他节点取区间
        if(!now) return;
        lazy[now] ^= 1;
        swap(child[now][0], child[now][1]);
    }
    inline void del(){//关键操作之一
        if(!child[root][0]){//根节点就是位置最小的节点，直接将右子树根节点拽上来作为根节点
            root = child[root][1];
            father[root] = 0;
        }
        else{//找到根节点的上一个节点，并将其作为根节点，正确性请自己证...
            int front = pre(child[root][0]);
            splay(front, root);
            child[front][1] = child[root][1]; 
            father[child[root][1]] = front;
            root = front;
            father[root] = 0;
            pushup(root);
        }
    }
}A;

int main()
{
    int n;
    scanf("%d", &n);
    A.root = A.build(1, n);
    for(int i = 1; i <= n; ++i){
        scanf("%d", &A.node[i].data);
        A.node[i].id = i;//为每一个点分配位置id
	}
    sort(A.node + 1, A.node + n + 1);//以data为第一关键字，id为第二关键字可保证data相同的节点相对位置不发生改变
    for(int i = 1; i < n; ++i){
        printf("%d ", A.rank(A.node[i].id) + i);//因为之前有被删除的节点，所以rank要加i
        A.reverse(A.child[A.root][0]);
        A.del();
    }
    printf("%d\n", n);
    return 0;
}
```

---


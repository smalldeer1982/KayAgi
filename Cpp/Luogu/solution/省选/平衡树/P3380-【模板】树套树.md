# 【模板】树套树

## 题目描述

您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：

1. 查询 $k$ 在区间内的排名；
2. 查询区间内排名为 $k$ 的值；
3. 修改某一位置上的数值；
4. 查询 $k$ 在区间内的前驱（前驱定义为严格小于 $x$，且最大的数，**若不存在输出 `-2147483647`**）；
5. 查询 $k$ 在区间内的后继（后继定义为严格大于 $x$，且最小的数，**若不存在输出 `2147483647`**）。

对于一组元素，一个数的排名被定义为严格比它小的元素个数加一，而排名为 $k$ 的数被定义为“将元素从小到大排序后排在第 $k$ 位的元素值”。

## 说明/提示

$1\le n,m\le5\times 10^4$，序列中的值在任何时刻 $\in[0,10^8]$。

题目来源：bzoj3196 / Tyvj1730，在此鸣谢。

此数据为洛谷原创。**（特别提醒：此数据不保证操作 4、5 一定存在，故请务必考虑不存在的情况。）**

## 样例 #1

### 输入

```
9 6
4 2 2 1 9 4 0 1 1
2 1 4 3
3 4 10
2 1 4 3
1 2 5 9
4 3 9 5
5 2 8 5```

### 输出

```
2
4
3
4
9```

# 题解

## 作者：shadowice1984 (赞：88)

大家好，我非常喜欢暴力数据结构，于是我就用分块过了这道题。

# 并且可能比大多数人的树套树都块

~~其实这题就是P4119的弱化版~~

## 本体题解

这题让我们实现4个操作，区间kth，区间前驱，区间后继，区间查询排名

那么如果你对基本的数据结构足够熟练的话会知道这些其实可以这些问题都可以用可持久化线段树在$O(log(n))$的时间内解决

但是这题还多一个操作，那就是单点修改点权，此时我们的问题可能就会变得比较辣手了，该怎么解决这个问题呢?

~~树状数组套权值线段树，此题完结~~

当然这可能也是这道题的树套树解法之一，而且跑的并不慢

~~但是我们就是喜欢分块~~

在这道题的一篇题解当中介绍了一种乱七八糟的二分+分块做法……

问题来了，**分块这个算法和二分法根本不契合**

为什么我们在可持久化线段树上会使用二分法？因为线段树这个东西本身就和二分的算法流程相当像，所以我们在线段树上使用二分就可以在$O(logn)$的时间内出解

但是现在支持二分的底层数据结构变成了分块，众所周知，二分的思想是分治,而分块的思想是暴力之间的平衡，这两个算法之间明显不搭调，因此我们的复杂度会凭空多个log出来变成了$O(\sqrt{N} logn)$

那么对于kth问题我们其实还有一个算法是基于对值域分块的算法

假设我们现在需要知道一些数字中的第k大,并且仅仅要求在$O(\sqrt{N})$的时间内出解，我们可以采取这样一种算法，将值域分成$O(\sqrt{N})$块

然后设两个数组$cnt1(i)$表示第i个值域块有几个点，$cnt2(i)$表示第i这个值出现了多少次

那么我们思路就是暴力的for循环

对于查询元素排名的操作，假设这个元素在第i块而值为x，我们先暴力的把$cnt1(1)$到$cnt1(i-1)$的值加到答案当中去,然后再把和x在同一个值域块的数字加到答案中去，这个东西可以查$cnt2$得到

对于查询kth的操作，我们枚举这个元素在第几块，这个可以从左到右扫一遍$cnt1$得到，将kth定位在某一个块内之后，在这个值域块内从左到右扫一遍，通过查$cnt2$就可以得知kth到底是哪个元素了

对于查询前驱和后继的操作，我们通过查$cnt2$可以查询它自己值域块有没有它的前驱和后继，如果有的话直接输出结果，否则找到这个点左侧或者右侧第一个非空的块然后在这个块内暴力找前驱后继即可

这样我们就在$O(\sqrt{N})$的时间内解决了这个问题

你可能会问，这东西有什么用呢？二分直接完爆这个垃圾算法

但是不知道你发现没有发现一个事实，二分法要求我们快速回答这个问题

**在这个数字集合当中有几个数字比x大**

但是刚才的算法我们仅仅需要回答这个问题

**在这个数字集合当中有几个数字恰好为x，以及在这个数字集合当中有几个数字恰好落在了第i个值域块里**

显然维护这两个信息的难度是相当不一样的

_________________

现在让我们来考虑如何用分块来解决这道题

首先将整个序列分成$O(\sqrt{N})$块，然后将出现的值全部离散化这样值域也变成$O(N+M)$级别的了，然后将值域分成$O(\sqrt{N+M})$块

接下来我们打两个表出来$cnt1(i,j)$表示前i块落在第j个值域块的数字有几个,$cnt2(i,j)$表示前i个块值恰好为j的数字有几个，这两个表显然可以在$O(N\sqrt{N})$的时间内预处理出来

那么修改的时候相当简单，把x改成y就直接暴力修改这两个表就行了，复杂度显然$O(\sqrt{N})$

对于其他的询问操作，其实我们就是想要得到这个区间的cnt1和cnt2数组长什么样,那么我们可以暴力的处理出来边角点的cnt1和cnt2数组，然后对于第i个块和第j块之间的cnt1和cnt2数组我们可以用$cnt1(j,...)-cnt1(i-1,...)$和$cnt2(j,...)-cnt2(i-1,...)$来得到，这样我们就可以在$O(\sqrt{N+M})$的时间内解决这个问题了，至于4个操作的具体流程已经在上面写的相当清楚了此处就不在赘述，如果还不明白可以看我代码

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<map>
using namespace std;const int N=5*1e4+10;const int M=1e5+10;
const int B=260;const int B2=300;int a[N];//维护的表格 
int cnt1[N/B+3][M/B2+3];int cnt2[N/B+3][M];int n;int m;int bi[N];int bi1[M];
int tr1[M];int tr2[M];map <int,int> mp;int S;int Pr[M];int Pl[M];int val[M];
inline int frk(int l,int r,int va)//查询元素的排名 
{
    int p1=bi[l];int p2=bi[r];int ret=0;
    if(p1==p2){for(int i=l;i<=r;i++)ret+=(a[i]<va);return ret+1;}
    for(int i=l;bi[i]==p1;i++)ret+=(a[i]<va);
    for(int i=r;bi[i]==p2;i--)ret+=(a[i]<va);p2--;
    for(int i=1;i<bi1[va];i++)ret+=cnt1[p2][i];
    for(int i=1;i<bi1[va];i++)ret-=cnt1[p1][i];
    for(int i=va-1;bi1[i]==bi1[va];i--)ret+=cnt2[p2][i];
    for(int i=va-1;bi1[i]==bi1[va];i--)ret-=cnt2[p1][i];return ret+1;
}
inline int ckth(const int& p1,const int& p2,int k)//辅助函数，查询kth 
{
    int ret=B2;int cur=0;
    for(int t=1;cur<k;ret+=B2,t++)cur+=cnt1[p2][t]-cnt1[p1][t]+tr1[t];ret-=B2;
    for(;cur>=k;ret--)cur-=cnt2[p2][ret]-cnt2[p1][ret]+tr2[ret];return ret+1;
}
inline int cpre(const int& p1,const int& p2,int k)//辅助函数，查询前驱 
{
    for(int i=k-1;bi1[i]==bi1[k];i--)
        if(cnt2[p2][i]-cnt2[p1][i]+tr2[i])return i;
    int p;for(p=bi1[k]-1;(cnt1[p2][p]-cnt1[p1][p]+tr1[p])==0;p--);
    for(int i=Pr[p];;i--)if(cnt2[p2][i]-cnt2[p1][i]+tr2[i])return i;
}
inline int csuf(const int& p1,const int& p2,int k)//辅助函数，查询后继 
{
    for(int i=k+1;bi1[i]==bi1[k];i++)
        if(cnt2[p2][i]-cnt2[p1][i]+tr2[i])return i;
    int p;for(p=bi1[k]+1;(cnt1[p2][p]-cnt1[p1][p]+tr1[p])==0;p++);
    for(int i=Pl[p];;i++)if(cnt2[p2][i]-cnt2[p1][i]+tr2[i])return i;
}
# define ins(x) tr1[bi1[x]]++,tr2[x]++
# define del(x) tr1[bi1[x]]--,tr2[x]--
inline int calc(int l,int r,int k,int(*f)(const int& p1,const int& p2,int k))//这里用了个函数指针 
{
    int p1=bi[l];int p2=bi[r];int ret=0;//直接处理出区间的cnt1,cnt2数组 
    if(p1==p2)
    {
        for(int i=l;i<=r;i++)ins(a[i]);ret=f(p1,p2,k);
        for(int i=l;i<=r;i++)del(a[i]);return val[ret];
    }
    for(int i=l;bi[i]==p1;i++)ins(a[i]);
    for(int i=r;bi[i]==p2;i--)ins(a[i]);ret=f(p1,p2-1,k);
    for(int i=l;bi[i]==p1;i++)del(a[i]);
    for(int i=r;bi[i]==p2;i--)del(a[i]);return val[ret];//记得还原回离散化之前的值 
}
inline void modify(int pos,int y)//暴力修改 
{
    int p=bi1[a[pos]];for(int i=bi[pos];i<=bi[n];i++)cnt1[i][p]--;
    p=a[pos];for(int i=bi[pos];i<=bi[n];i++)cnt2[i][p]--;
    p=bi1[y];for(int i=bi[pos];i<=bi[n];i++)cnt1[i][p]++;
    for(int i=bi[pos];i<=bi[n];i++)cnt2[i][y]++;a[pos]=y;
}
struct opt{int tp;int l;int r;int k;}op[N];
int main()
{
    scanf("%d%d",&n,&m);mp[-2147483647]=1;mp[2147483647]=1;
    for(int i=1;i<=n;i++)scanf("%d",&a[i]),mp[a[i]]=1;
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&op[i].tp);
        if(op[i].tp!=3)scanf("%d%d%d",&op[i].l,&op[i].r,&op[i].k);
        else scanf("%d%d",&op[i].l,&op[i].k);if(op[i].tp!=2)mp[op[i].k]=1;	
    }
    S=mp.size();map <int,int> :: iterator it,it1;//离散化 
    for(it=mp.begin(),it1=it,++it1;it1!=mp.end();++it,++it1)it1->second+=it->second;
    for(it=mp.begin();it!=mp.end();++it)val[it->second]=it->first;
    for(int i=1;i<=n;i++)a[i]=mp[a[i]];
    for(int i=1;i<=m;i++)if(op[i].tp!=2)op[i].k=mp[op[i].k];
    for(int i=1;i<=n;i++)bi[i]=(i-1)/B+1;for(int i=1;i<=S;i++)bi1[i]=(i-1)/B2+1;
    for(int i=1;i<=S;i++)Pr[bi1[i]]=i;for(int i=S;i>=1;i--)Pl[bi1[i]]=i;
    for(int i=1;i<=n;i++)
    {
        int p=bi1[a[i]];for(int j=bi[i];j<=bi[n];j++)cnt1[j][p]++;
        p=a[i];for(int j=bi[i];j<=bi[n];j++)cnt2[j][p]++;
    }ins(1);ins(S);//插入哨兵 
    for(int i=1;i<=m;i++)
        switch(op[i].tp)
        {
            case 1:{printf("%d\n",frk(op[i].l,op[i].r,op[i].k));break;}
            case 2:{printf("%d\n",calc(op[i].l,op[i].r,op[i].k+1,ckth));break;}
            case 3:{modify(op[i].l,op[i].k);break;}
            case 4:{printf("%d\n",calc(op[i].l,op[i].r,op[i].k,cpre));break;}
            case 5:{printf("%d\n",calc(op[i].l,op[i].r,op[i].k,csuf));break;}
        }return 0;//拜拜程序~ 
}


```










---

## 作者：BFqwq (赞：71)

# P3380（树状数组套权值树写法）
直接看标题吧qaq，这不是本题的最优做法~~其实我觉得是~~

其实我喜欢叫它动态主席树~~但是有些大佬不喜欢qaq~~

~~为什么我感觉后面的动态主席树题解写的不是很简洁qaq~~

## 切入正题
在这儿默认各位已经学过静态主席树了。

（没学过的请跳转[P3834](https://www.luogu.com.cn/problem/P3834)）

在静态主席树中，我们了解了线段树的前缀和操作，

以及用一个值出现的次数来开线段树的神奇操作。

那么其实我们的问题只是在于修改而已。

考虑到线段树可以前缀和，

那么其实我们也可以用一些维护前缀和的神奇操作来维护线段树的前缀和，

比如，套一个树状数组或者线段树什么的。

那么，这个数据结构的核心思路就这样子啦~

（注：下文的$len$是离散化之后的数的个数）
## 修改
在这里我使用的是树状数组套主席树。

我们都熟悉树状数组的修改方式，

那么我们只要在外层找到需要修改那几棵权值树（或者说是主席树）。

比如我们要修改$x$号节点，

那么根据树状数组的性质，

我们只需要每次加上$lowbit(x)$就行啦。

然后进入要修改的主席树，

再按照主席树修改的操作改就结束啦~

code：
```cpp
int lb(int x){
	return x&(-x);
}
void pushup(int o){
	t[o].v=t[t[o].ls].v+t[t[o].rs].v;
}
void change(int &o,int l,int r,int k,int v){
	if(!o) o=++tot;
	if(l==r){
		t[o].v+=v;
		return ;
	}
	int mid=l+r>>1;
	if(k<=mid) change(t[o].ls,l,mid,k,v);
	else change(t[o].rs,mid+1,r,k,v);
	pushup(o);
}//主席树修改
void add(int o,int v){
	for(int i=o;i<=n;i+=lb(i)) change(rt[i],1,len,a[o],v);
} //树状数组查找修改的树
```
## 查询第k小
我们主席树的操作，

就是将第$r$棵树减去第$l-1$棵树。

得出我们需要查询的树，

那么这边也是一样的。

假设使用树状数组找到我们要查询的$r_1,r_2 \ldots r_k$和$l_1,l_2 \ldots l_k$，

那么我们只需要将所有的$r$树减去所有的$l$树，

就能得出我们要的树了。

第k小查询，get~

code：
```cpp
int query_num(int l,int r,int k){
	if(l==r) {
		return l;
	}
	int mid=l+r>>1,sum=0;
	for(int i=1;i<=cnt;i++) sum+=t[t[tem[i]].ls].v;
	for(int i=1;i<=num;i++) sum-=t[t[tmp[i]].ls].v;
   	//同主席树，所有有节点的树减去所有左节点的树
	if(k<=sum){
		for(int i=1;i<=cnt;i++) tem[i]=t[tem[i]].ls;
		for(int i=1;i<=num;i++) tmp[i]=t[tmp[i]].ls;
		return query_num(l,mid,k);
	}
	else{
		for(int i=1;i<=cnt;i++) tem[i]=t[tem[i]].rs;
		for(int i=1;i<=num;i++) tmp[i]=t[tmp[i]].rs;
		return query_num(mid+1,r,k-sum);
	}
    	//注意要所有的节点一起变成子节点
}
int find_num(int l,int r,int k){
	cnt=num=0;
	for(int i=r;i;i-=lb(i)){
		tem[++cnt]=rt[i];
	}//这些是右端点分出来的树
	for(int i=l-1;i;i-=lb(i)){
		tmp[++num]=rt[i];
	}//这些是左端点分出来的树，注意l-1
	return query_num(1,len,k);
} //先用树状数组求出需要查的树
```
## 查询排名
这一步操作就显得比较简单。

我们只要把一段区间中小于$k$的数的个数加起来再加个一就行啦。

具体的操作同查询第k小，

先预处理出需要找的树，

不同的是我们只需要在每棵树中求一个区间和就行啦~

code：
```cpp
int query_rnk(int l,int r,int k){
	if(l==r) {
		return 0;//注意这里要return 0，因为等于k是不能算进去的
	}
	int mid=l+r>>1,sum=0;
	if(k<=mid){
		for(int i=1;i<=cnt;i++) tem[i]=t[tem[i]].ls;
		for(int i=1;i<=num;i++) tmp[i]=t[tmp[i]].ls;
		return query_rnk(l,mid,k);
	}
	else{
		for(int i=1;i<=cnt;i++) sum+=t[t[tem[i]].ls].v,tem[i]=t[tem[i]].rs;
		for(int i=1;i<=num;i++) sum-=t[t[tmp[i]].ls].v,tmp[i]=t[tmp[i]].rs;
		return sum+query_rnk(mid+1,r,k);
	}
}//一个线段树的求和操作，求出1-k-1位置的和
//其实也可以每棵树查一次，在这里我喜欢所有的树一起查
int find_rnk(int l,int r,int k){
	cnt=num=0;
	for(int i=r;i;i-=lb(i)){
		tem[++cnt]=rt[i];
	}
	for(int i=l-1;i;i-=lb(i)){
		tmp[++num]=rt[i];
	}
	return query_rnk(1,len,k)+1;
    //不要忘记加1qaq
}
```
## 查询前驱
其实，这个操作我们可以用上面的两个操作来完成。

假设这个数的排名是$rk$，那么$rk-1$名的数，是不是就是它的前驱呢~

当然有一个特判：

假设$rk$已经等于$1$了，那么就是不存在前驱的情况

那么前驱就这么结束啦~

code：
```cpp
int find_pri(int l,int r,int k){
	int rk=find_rnk(l,r,k)-1;
	if(rk==0) return 0;
    	//因为我前面减一已经减好了，所以特判的时候判是否等于0
	return find_num(l,r,rk);
}
```
## 查询后继
其实是一个道理呢~

但是这里就涉及到一个排名是多少的问题。

如果假设后继的排名是$rk$，

那么$k$的排名不一定是$rk-1$，

因为可能有数的排名相同。

其实也没有关系。

我们看到排名操作，其实我们查询排名的时候，

仅仅是查询了小于$k$的数，然后加了$1$。

那么其实哪怕这个数不存在，

我们查询排名的时候也不会出问题。

也就是说，我们查询$k+1$的排名

由于小于等于$k$的数就是$rk-1$个

所以返回的排名就一定是$rk$。

因此，我们只需要查询$k+1$的排名，

就可以得到其后继的排名。

然后，再查一次第$k$小就结束啦~

code：
```cpp
int find_nxt(int l,int r,int k){
	if(k==len) return len+1;
    	//为了防止越界，我增加了一个特判
    	//要是已经是最大值了，那么它就不可能有后继
	int rk=find_rnk(l,r,k+1);
	if(rk==r-l+2) return len+1;
	return find_num(l,r,rk);
}
```
## 复杂度
可以看到，我们任意的一次操作，

都是在树状数组上先查询了一次，

再到线段树上查询了一次，

两个$\log$加起来，就是$n \log ^2 n$。

如果是线段树套平衡树的话，

其大部分操作也是这个复杂度，

但是在查询第$k$小时还要多乘一个$\log$。

对于空间，其实我们可以发现，

每次修改的时候，我们仅需要改至多$\log n$棵树，

而每棵树又只要改一条链，所以又是一个$log$。

于是，空间也是$n \log ^2 n$级别的复杂度，

完全可以承受。

时间和空间都是上界，

特别是空间，一般的数据根本不可能达到这么高。

~~然后洛谷的数据又水~~

## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read(){
	register int x=0;
	register bool f=0;
	register char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=50005;
int len=0;
const int inf=2147483647;
struct seg{
	int v,ls,rs;
}t[maxn*100];
int rt[maxn],n,m,tot,tem[maxn],tmp[maxn],cnt,num;
int lsh[maxn<<1],a[maxn];
struct cz{
	int a,b,c,d;
}q[maxn];
int lb(int x){
	return x&(-x);
}
void pushup(int o){
	t[o].v=t[t[o].ls].v+t[t[o].rs].v;
}
void change(int &o,int l,int r,int k,int v){
	if(!o) o=++tot;
	if(l==r){
		t[o].v+=v;
		return ;
	}
	int mid=l+r>>1;
	if(k<=mid) change(t[o].ls,l,mid,k,v);
	else change(t[o].rs,mid+1,r,k,v);
	pushup(o);
}
void add(int o,int v){
	for(int i=o;i<=n;i+=lb(i)) change(rt[i],1,len,a[o],v);
} 
int query_num(int l,int r,int k){
	if(l==r) {
		return l;
	}
	int mid=l+r>>1,sum=0;
	for(int i=1;i<=cnt;i++) sum+=t[t[tem[i]].ls].v;
	for(int i=1;i<=num;i++) sum-=t[t[tmp[i]].ls].v;
	if(k<=sum){
		for(int i=1;i<=cnt;i++) tem[i]=t[tem[i]].ls;
		for(int i=1;i<=num;i++) tmp[i]=t[tmp[i]].ls;
		return query_num(l,mid,k);
	}
	else{
		for(int i=1;i<=cnt;i++) tem[i]=t[tem[i]].rs;
		for(int i=1;i<=num;i++) tmp[i]=t[tmp[i]].rs;
		return query_num(mid+1,r,k-sum);
	}
}
int find_num(int l,int r,int k){
	cnt=num=0;
	for(int i=r;i;i-=lb(i)){
		tem[++cnt]=rt[i];
	}
	for(int i=l-1;i;i-=lb(i)){
		tmp[++num]=rt[i];
	}
	return query_num(1,len,k);
} 
int query_rnk(int l,int r,int k){
	if(l==r) {
		return 0;
	}
	int mid=l+r>>1,sum=0;
	
	if(k<=mid){
		for(int i=1;i<=cnt;i++) tem[i]=t[tem[i]].ls;
		for(int i=1;i<=num;i++) tmp[i]=t[tmp[i]].ls;
		return query_rnk(l,mid,k);
	}
	else{
		for(int i=1;i<=cnt;i++) sum+=t[t[tem[i]].ls].v,tem[i]=t[tem[i]].rs;
		for(int i=1;i<=num;i++) sum-=t[t[tmp[i]].ls].v,tmp[i]=t[tmp[i]].rs;
		return sum+query_rnk(mid+1,r,k);
	}
}
int find_rnk(int l,int r,int k){
	cnt=num=0;
	for(int i=r;i;i-=lb(i)){
		tem[++cnt]=rt[i];
	}
	for(int i=l-1;i;i-=lb(i)){
		tmp[++num]=rt[i];
	}
	return query_rnk(1,len,k)+1;
}
int find_pri(int l,int r,int k){
	int rk=find_rnk(l,r,k)-1;
	if(rk==0) return 0;
	return find_num(l,r,rk);
}
int find_nxt(int l,int r,int k){
	if(k==len) return len+1;
	int rk=find_rnk(l,r,k+1);
	if(rk==r-l+2) return len+1;
	return find_num(l,r,rk);
}
signed main(){
		n=read();m=read();
		tot=cnt=num=0;
		for(int i=1;i<=n;i++){
			a[i]=read();
			lsh[++len]=a[i];
		}
		for(int i=1;i<=m;i++){
			q[i].a=read();q[i].b=read();q[i].c=read();
			if(q[i].a!=3) q[i].d=read();
			else lsh[++len]=q[i].c;
			if(q[i].a==4 || q[i].a==5) lsh[++len]=q[i].d;
		}
		sort(lsh+1,lsh+len+1);
		len=unique(lsh+1,lsh+len+1)-lsh-1;//离散化
		for(int i=1;i<=n;i++){
			a[i]=lower_bound(lsh+1,lsh+1+len,a[i])-lsh;
			add(i,1);
		}
		lsh[0]=-inf;
		lsh[len+1]=inf;
        	//为了前驱和后继用。
		for(int i=1;i<=m;i++){
			if(q[i].a==3){
				add(q[i].b,-1);
				a[q[i].b]=lower_bound(lsh+1,lsh+1+len,q[i].c)-lsh;
				add(q[i].b,1);
			}
			if(q[i].a==1){
				q[i].d=lower_bound(lsh+1,lsh+1+len,q[i].d)-lsh;
				printf("%d\n",find_rnk(q[i].b,q[i].c,q[i].d));
			}
			if(q[i].a==2){
				printf("%d\n",lsh[find_num(q[i].b,q[i].c,q[i].d)]);
			}
			if(q[i].a==4){
				q[i].d=lower_bound(lsh+1,lsh+1+len,q[i].d)-lsh;
				printf("%d\n",lsh[find_pri(q[i].b,q[i].c,q[i].d)]);
			}
			if(q[i].a==5){
				q[i].d=lower_bound(lsh+1,lsh+1+len,q[i].d)-lsh;
				printf("%d\n",lsh[find_nxt(q[i].b,q[i].c,q[i].d)]);
			}
		}
	return 0;
}

```
qaq完整的代码就是这样啦~

祝各位WC/NOI/CSP2020加油qaq

要是已经退役的那就祝高考加油吧qaq

---

## 作者：Soulist (赞：34)

~~线段树套$Splay$~~

区别于线段树，这道题要求统计区间$k$大，区间某个数的前驱什么的。

所以用树套树，我们对线段树的每个节点开一棵平衡树。

对线段树的每个节点记一个$root$，表示这个点对应的平衡树的根节点。

我们看看$5$个操作怎么解决的？

操作$1:$我们用线段树去找区间，遇到某个合法区间后，把这个区间内比数$x$小的数统计出来，最后输出其$+1$就是排名了

操作$2:$我们$2$分一个值，然后对这个值跑操作$1$。以此法判断这个值是否满足排名为$k$

操作$3:$假设我们要把$wh$上的点从$a[wh]$改为$k$，那么就在线段树上找，每遇到一个节点，都在其对应的平衡树中删掉$a[wh]$，然后插入$k$，最后当区间满足$l == r == wh$时就把$a[wh]$改为$k$

操作$4:$在线段树上依次找节点，每次找到合法区间后用$Splay$求前驱，对所有前驱取$max$

操作$5:$在线段树上依次找节点，每次找到合法区间后用$Splay$求后继，对所有前驱取$min$

代码献上：

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9'){
    	if(cc == '-') flus = -flus;
		cc = getchar();
	}
	while(cc >= '0' && cc <= '9')
	    cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const int N = 5e4 + 5;
#define ls(x) t[x].son[0]
#define rs(x) t[x].son[1]
#define inf 2147483647
#define il inline
struct Splay{
	int size, tot, val, son[2], fa; 
}t[N * 50];
struct Seg_tree{
	int l, r, root;
}tr[N * 4];
int a[N], n, m, cnt;
//Splay

il void pushup(int x) {
	t[x].size = t[ls(x)].size + t[rs(x)].size + t[x].tot;
} 
il void turn(int x) {
	int f = t[x].fa, ff = t[f].fa, qwq = (t[f].son[1] == x);
	t[ff].son[(t[ff].son[1] == f)] = x, t[x].fa = ff;
	t[t[x].son[qwq ^ 1]].fa = f; t[f].son[qwq] = t[x].son[qwq ^ 1];
	t[x].son[qwq ^ 1] = f; t[f].fa = x;
	pushup(f); pushup(x);
}
il void Splay( int x, int goal, int node ) {
	while( t[x].fa != goal ) {
		int f = t[x].fa, ff = t[f].fa;
		if(ff != goal) (t[ff].son[1] == f) ^ (t[f].son[1] == x) ? turn(f) : turn(x);
		turn(x); 
	}
	if( goal == 0 ) tr[node].root = x;
}
il int init( int v, int fa ) {
	t[++cnt].val = v, t[cnt].fa = fa, t[cnt].tot = 1;
	pushup(cnt); return cnt;
}
il void insert( int x, int node ) {
	int u = tr[node].root, fa = 0;
	if(!u) { u = init(x, 0), tr[node].root = u; return ;}
	while( u && (t[u].val != x) ) fa = u, u = t[u].son[t[u].val < x];
	if(x == t[u].val && u) t[u].tot ++;
	else {
		u = init(x, fa);
		if(fa) t[fa].son[t[fa].val < x] = u;
	}
	Splay( u, 0, node ); 
}
il void find( int x, int node ) {
	int u = tr[node].root;  if(!u) return ;
	while( t[u].son[t[u].val < x] && t[u].val != x) 
		u = t[u].son[t[u].val < x];
	Splay( u, 0, node );
}
il int Next( int x, int qwq, int node ) {//qwq为0，后继，1则前驱 
	find(x, node); int u = tr[node].root;
	if((qwq && t[u].val < x) || (!qwq && t[u].val > x)) return u;
	u = t[u].son[qwq ^ 1];
	while(t[u].son[qwq]) u = t[u].son[qwq];
	return u;
}
il void Del( int x, int node ) {
	int u = tr[node].root, pre = Next(x, 1, node), nxt = Next(x, 0, node);
	Splay(nxt, 0, node); Splay(pre, nxt, node);
	int wh = t[pre].son[1];
	if(t[wh].tot > 1) -- t[wh].tot, Splay(wh, 0, node);
	else t[pre].son[1] = 0;
	pushup(pre); 
}
//seg_tree
il void build( int node, int l, int r ) {
	insert(inf, node); insert(-inf, node);
	if(l == r) return ;
	int mid = (l + r) >> 1;
	build(node * 2, l, mid ); build(node * 2 + 1, mid + 1, r);
}
il void seg_insert( int node, int l, int r, int k, int val ) {
	int mid = (l + r) >> 1;
	insert(val, node);
	if(l == r) return ;
	if( mid >= k )  seg_insert(node * 2, l, mid, k, val);
	else seg_insert(node * 2 + 1, mid + 1, r, k, val);
} 
il int seg_rank( int node, int l, int r, int k, int ql, int qr ) {
	if(l > qr || r < ql) return 0;
	if(l >= ql && r <= qr) {
		find( k, node );  int u = tr[node].root;
		if( t[u].val >= k ) return t[ls(u)].size - 1;
		else return t[ls(u)].size + t[u].tot - 1; 
	}
	int mid = (l + r) >> 1;
	return seg_rank(node * 2, l, mid, k, ql, qr) + seg_rank(node * 2 + 1, mid + 1, r, k, ql, qr);
}
il void seg_update(int node, int l, int r, int wh, int val) {
	Del(a[wh], node), insert(val, node);
	if ( l == r && l == wh )  { a[wh] = val; return ; }
	int mid = ( l + r ) >> 1;
	if(mid >= wh) seg_update(node * 2, l, mid, wh, val);
	else seg_update(node * 2 + 1, mid + 1, r, wh, val);
}
il int seg_Pre(int node, int l, int r, int ql, int qr, int k) { 
	if(l > qr || r < ql) return -inf;
	if(l >= ql && r <= qr)  return t[Next(k, 1, node)].val;
	int mid = (l + r) >> 1;
	return max(seg_Pre(node * 2, l, mid, ql, qr, k), seg_Pre(node * 2 + 1, mid + 1, r, ql, qr, k));
}
il int seg_Nxt(int node, int l, int r, int ql, int qr, int k) {
	if(l > qr || r < ql) return inf;
	if(l >= ql && r <= qr)  return t[Next(k, 0, node)].val;
	int mid = (l + r) >> 1;
	return min(seg_Nxt(node * 2, l, mid, ql, qr, k), seg_Nxt(node * 2 + 1, mid + 1, r, ql, qr, k));
}
il int seg_Kth(int ql, int qr, int k) {
	int l = 0, r = 1e8, mid, check, ans;
	while(l <= r) {
		mid = (l + r) >> 1;
		check = seg_rank(1, 1, n, mid, ql, qr) + 1;
		if( check > k ) r = mid - 1;
		else l = mid + 1, ans = mid;
	}
	return ans;
}
signed main()
{
	n = read(), m = read(); 
	build(1, 1, n); int opt, l, r, k;
	for( int i = 1; i <= n; ++ i )  a[i] = read(), seg_insert(1, 1, n, i, a[i]);
	for( int i = 1; i <= m; ++ i ) {
		opt = read(), l = read(), r = read();
		if(opt == 1)  k = read(), printf("%d\n", seg_rank(1, 1, n, k, l, r) + 1);
		if(opt == 2)  k = read(), printf("%d\n", seg_Kth(l, r, k));
		if(opt == 3)  seg_update(1, 1, n, l, r);
		if(opt == 4)  k = read(), printf("%d\n", seg_Pre(1, 1, n, l, r, k));
		if(opt == 5)  k = read(), printf("%d\n", seg_Nxt(1, 1, n, l, r, k));
	}
	return 0;
}
```

---

## 作者：__ryp__ (赞：19)

本题有一个非常好的性质：没强制在线。所以我们可以离线下来搞。

具体怎么做呢？本题的核心就是点修、区间第 $k$ 大、区间求排名。我们知道，CDQ 分治和整体二分分别可以很方便并且快速地解决区间排名以及区间第 $k$ 大问题。那么我们分别用这两种算法做不同的操作就可以了。

还剩下前驱和后继，怎么处理？某个数的前驱，可以先算出严格小于这个数的数量 $k$，然后求第 $k$ 大。某个数的后继，可以算出小于等于这个数的数量 $k$，然后求第 $k + 1$ 大。

这时我们发现，我们需要将这两个操作组合起来。我们可以把询问拆开，先跑 CDQ 分治，得到 $k$，然后再跑整体二分，得到最后的结果。

实现起来细节不特别多，主要是主函数中拼接操作的部分不怎么好写。

但是跑起来飞快，没怎么卡常就跑到最优解第二页。

[代码](https://www.luogu.com.cn/paste/y5f6pe2f)

---

## 作者：chenxinyang2006 (赞：7)

这个题最经典的做法是线段树套平衡树，当然线段树套线段树显然时间复杂度更优一点，是$log(n) ^ 2$的

那么众所周知，数据结构可以改成分块来维护，那么这个题可不可以呢？

实际上当然是可以的，而且如果套得合适，可以做到仍然是一个$\sqrt n$的复杂度，而不是什么鬼畜的$(\sqrt n) ^ 2$

整体思路仿照权值线段树套区间线段树，改为权值分块套区间分块

**对于一个连续的权值块，维护每个点的数在这个权值块的出现次数**

**对于每个权值点，也要维护每个点的数在这个权值的出现次数**

* 对于操作一，从左向右扫过每个符合条件(右端点$ \le k$)的权值块，每次累加在$[l,r]$里的点的数量，然后再查询零散的部分

* 对于操作二，从左向右扫过每个权值块，当在$[l,r]$里的点累计$\ge k$的时候，暴力扫一遍最后那个块

* 对于操作三，修改权值块里的内容和权值点里的内容

* 对于操作四，查询出有$rnk$个数$< k$，然后找排名为$rnk$的数，当$rnk = 0$时，输出$-inf$

* 对于操作五，查询出有$rnk$个数$\le k$，然后找排名为$rnk + 1$的数，当$rnk = r - l + 1$时，输出$inf$

那么问题来了，内部用什么东西维护呢？我们需要快速查询$[l,r]$的和，或者修改(次数较少)一个点的值

你当然可以用动态开点线段树来做，这样写起来方便，但是这样带个$log(n)$，复杂度不太好

所以内部要使用分块维护，每次维护一个前缀和，这样就是区间修改、单点查询，可以轻松做到修改$O(\sqrt n)$，查询$O(1)$

但是问题来了，我们要维护每个权值点的信息，每个权值点都开这个空间$O(n)$的分块数组显然要凉

所以你得搞一个动态开点分块，每次只有在修改零散块的信息的时候，才建出这个零散块，这样就可以控制空间

当你辛辛苦苦写完、调完，交上去时，你就会发现：

![](https://cdn.luogu.com.cn/upload/image_hosting/xopjvmy6.png))

直接MLE，彻底去世

所以你就得开始卡空间

我也不太想写卡空间的过程了，反正很艰难，直接放最后的AC代码：

```cpp
#include <cstdio>
#include <cstring>
#include <map>
#include <algorithm>
#include <queue>
using namespace std;
int n,m;
int p[50005];//用于存原数组每个位置的信息

#define us unsigned short 

queue <int> que;//这个是可用内存分配池，是循环的，存每个可用内存块的起点 
us arr[22700005];//可用内存池，就是底层分块用的，因为n = 50000，所以每个值域肯定至多只有50000个数，unsigned short勉强存的下

#define BLOCK_LEN 223//底层块长 

struct array{//稍微封装下，否则太难写
	us tag[226];//每个块的加法tag，也是unsigned short勉强存的下 
	int T[226];//存每个块的内存块的起点 - 块的左端点，这样写是为了方便 
	#define Bfrom(x) ((x % BLOCK_LEN == 0) ? (x / BLOCK_LEN) : (x / BLOCK_LEN + 1))
	#define BL(x) (((x) - 1) * BLOCK_LEN + 1)
	#define BR(X) ((x) * BLOCK_LEN)
	inline void init(){
		memset(T,0x3f,sizeof(T));//表示都不存在 
	}
	inline void maintain(int x){//分配内存 
		if(T[x] == 0x3f3f3f3f){
			T[x] = que.front() - BL(x) + 1;
			que.pop();
		} 
	} 
	inline void del(int x){//判定这个块有没有必要存在，如果都为空，就可以释放内存 
		register int i;
		for(i = BL(x);i <= BR(x);++i){
			if(arr[T[x] + i]) return;
		}
		que.push(T[x]);//把这个块丢进可用内存里，如果用new、delete，估计会TLE 
		T[x] = 0x3f3f3f3f;//标记为不存在
	}
	inline void upload(int l,int r,int k){//[l,r]区间加k 
	    register int i;
		int x = Bfrom(l),y = Bfrom(r); 
		if(x == y){//简单的判两端点同块 
			maintain(x);
			for(i = T[x] + l;i <= T[x] + r;++i){//T[x] + i就是i在内存池里的位置，很方便 
				arr[i] += k;
			}
			del(x);
			return;
		}
		if(BL(x) != l){//判左端点，没有必要判右端点，因为本题中所有r = n 
			maintain(x);
			for(i = T[x] + l;i <= T[x] + BR(x);++i){
				arr[i] += k;
			}
			del(x);
			x++;
	    }
		for(i = x;i <= y;++i){//中间打tag，不多说 
			tag[i] += k;
		}
	} 
	inline int query(int id){//简单的单点查询 
		int x = Bfrom(id);
		if(T[x] != 0x3f3f3f3f) return arr[T[x] + id] + tag[x];
		return tag[x];
	}
}value[100005],sum[320];//value是值域点，sum是值域块 

namespace OFFLINE{
	int tmp[100005];//离散化用的临时数组 
	
	int lis[100005];//lis[i]表示i离散化前的数 
	map <int,int> R;//R[i]表示i离散化后的数 
	int val_len;
	struct ask{//存每个修改
		int opt,l,r,k;
	}Q[50005]; 
    void input(){
    	register int i;
    	scanf("%d%d",&n,&m);
		for(i = 1;i <= n;++i){
			scanf("%d",&p[i]);
		}
		for(i = 1;i <= m;++i){
			scanf("%d",&Q[i].opt);
			if(Q[i].opt != 3){
				scanf("%d%d%d",&Q[i].l,&Q[i].r,&Q[i].k);	
			}else{
				scanf("%d%d",&Q[i].l,&Q[i].k);
			}
		}
	}
	void sol(){//离散化 
		register int i;
		for(i = 1;i <= n;++i){
			tmp[i] = p[i];
		}
		for(i = 1;i <= m;++i){
			tmp[n + i] = Q[i].k; 
		}
		sort(tmp + 1,tmp + n + m + 1);
		for(i = 1;i <= n + m;++i){
			if(i == 1 || tmp[i] != tmp[i - 1]){
				lis[++val_len] = tmp[i];
				R[tmp[i]] = val_len;
			}
		}
	}	
};
using namespace OFFLINE; 

#define len 320//值域分块的块长 

#define from(x) ((x % len == 0) ? (x / len) : (x / len + 1))
#define L(x) (((x) - 1) * len + 1)
#define R(X) ((x) * len)

inline int rnk(int l,int r,int k){
	register int i;
	int x = from(k);
	int ans = 0;
	for(i = 1;i < x;++i){//值域块扫一遍 
		ans += sum[i].query(r) - sum[i].query(l - 1);
	}
	for(i = L(x);i <= k;++i){//值域点 
		ans += value[i].query(r) - value[i].query(l - 1);
	}
	return ans;
}

inline int kth(int l,int r,int k){
	register int x,i;
	int tmp;
	for(x = 1;x <= from(val_len);++x){
		tmp = sum[x].query(r) - sum[x].query(l - 1);
		if(k > tmp){
			k -= tmp;	
		}else{//说明[l,r]的kth在这个值域块内 
			break;
		}
	}
	for(i = L(x);i <= R(x);++i){
		tmp = value[i].query(r) - value[i].query(l - 1);
		if(k > tmp){
			k -= tmp;
		}else{
			return i;
		}
	}
}

inline void modify(int id,int val){
	value[p[id]].upload(id,n,-1);//撤销之前的点 
	sum[from(p[id])].upload(id,n,-1);//注意两层都要修改
	value[val].upload(id,n,1);//加入新点 
	sum[from(val)].upload(id,n,1);
	p[id] = val;
}

inline int pre(int l,int r,int k){
	int tmp = rnk(l,r,k - 1);
	if(tmp == 0) return -2147483647;
	return lis[kth(l,r,tmp)];
}

inline int nxt(int l,int r,int k){
	int tmp = rnk(l,r,k);
	if(tmp == (r - l + 1)) return 2147483647;
	return lis[kth(l,r,tmp + 1)];
}

int main(){
	register int i;
	input();
	sol();
	for(i = 1;i <= val_len;++i){
		value[i].init();//每个都要init一下，否则会无法判断是否块存在 
	}
	for(i = 1;i <= from(val_len);++i){
		sum[i].init();
    }
    for(i = 1;i <= 100000;++i){//易证明，有效的块一直至多只有2n个(值域块n个，值域点n个) 
    	que.push((i - 1) * BLOCK_LEN);
	}
	for(i = 1;i <= n;++i){
		p[i] = R[p[i]];//这里注意下 
		value[p[i]].upload(i,n,1);
		sum[from(p[i])].upload(i,n,1);
	}
	for(i = 1;i <= m;++i){
		if(Q[i].opt == 1) printf("%d\n",rnk(Q[i].l,Q[i].r,R[Q[i].k] - 1) + 1);//注意很多都要离散化 
		else if(Q[i].opt == 2) printf("%d\n",lis[kth(Q[i].l,Q[i].r,Q[i].k)]);
		else if(Q[i].opt == 3) modify(Q[i].l,R[Q[i].k]);
		else if(Q[i].opt == 4) printf("%d\n",pre(Q[i].l,Q[i].r,R[Q[i].k]));
		else if(Q[i].opt == 5) printf("%d\n",nxt(Q[i].l,Q[i].r,R[Q[i].k]));
	}
	return 0;
}
```

结果最后也没有跑过二分套线段树再套splay的$log(n) ^ 3$

还是菜，最后的战果如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/euvtpsx4.png)

不过还是想向大家普及一下这个做法，毕竟分块套分块，只要套得合适(外层$O(\sqrt n)$的内层$O(1)$，外层$O(1)$的内层$O(\sqrt n)$)，还是可以做到和树套树复杂度**差不多**的

最后，推荐大家不要写这个屑做法，写一下，调一年，还tm跑不过树套树。就算要写这个，也推荐大家看[shadowice1984的解法](https://www.luogu.com.cn/blog/ShadowassIIXVIIIIV/solution-p3380)，比我常数小

---

## 作者：xukuan (赞：5)

树套树之线段树套fhqtreap的解法

在阅读本篇题解之前，我们认为你已经掌握了线段树和平衡树

我们看一下这题的操作：
1. 查询k在区间内的排名
2. 查询区间内排名为k的值
3. 修改某一位值上的数值
4. 查询k在区间内的前驱(前驱定义为严格小于x，且最大的数，若不存在输出-2147483647)
5. 查询k在区间内的后继(后继定义为严格大于x，且最小的数，若不存在输出2147483647)

相比普通平衡树而言的区别：
1. 所有查找在区间上进行
2. 不再有增删操作，增加了一个修改操作

那么，对于每一个区间，我们用一颗fhq_treap来维护

那么怎么快速查找区间呢？

用线段树

那么，线段树套fhqtreap的思路就清晰了

**来看线段树的各种信息：**
- 点信息：当前节点对应的fhq_treap
- 区间信息：当前区间对应的fhq_treap
- 目标信息：整颗fhq_treap

**那么fhq_treap维护什么：**

~~套路的很，~~值，左儿子，右儿子，随机优先级，值，子树大小

变量命名偏向《算法竞赛进阶指南》 李煜东 著

**代码**
```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

const ll N=50010,M=1e7,INF=2147483647;
ll n,m,tot,a[N];
struct fhqtreap{
    ll val,size,rnd,lson,rson;
}tree[M];

inline ll read(){
    ll x=0,tmp=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-') tmp=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
    return tmp*x;
}

inline void write(ll x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    ll y=10,len=1;
    while(y<=x){
        y=(y<<3)+(y<<1);
        len++;
    }
    while(len--){
        y/=10;
        putchar(x/y+48);
        x%=y;
    }
}

struct fhqTreap{//fhqtreap
    ll root;
    inline void pushup(ll x){
        tree[x].size=tree[tree[x].lson].size+tree[tree[x].rson].size+1;
    }
    ll merge(ll x,ll y){
        if(!x||!y) return x|y;
        if(tree[x].rnd<tree[y].rnd){
            tree[x].rson=merge(tree[x].rson,y);
            pushup(x);
            return x;
        }
        else{
            tree[y].lson=merge(x,tree[y].lson);
            pushup(y);
            return y;
        }
    }
    void split(ll x,ll val,ll &u,ll &v){
        if(!x){
            u=v=0;
            return;
        }
        if(tree[x].val<=val){
            u=x;
            split(tree[x].rson,val,tree[u].rson,v);
        }
        else{
            v=x;
            split(tree[x].lson,val,u,tree[v].lson);
        }
        pushup(x);
    }
    inline ll New(ll val){
        tree[++tot].val=val;
        tree[tot].rnd=rand();
        tree[tot].size=1;
        return tot;
    }
    inline void Insert(ll val){
        ll x,y,z;
        split(root,val,x,y);
        root=merge(x,merge(New(val),y));
    }
    inline void Delete(ll val){
        ll x,y,z;
        split(root,val,x,z);
        split(x,val-1,x,y);
        y=merge(tree[y].lson,tree[y].rson);
        root=merge(x,merge(y,z));
    }
    inline ll getrankbyval(ll val){
        ll x,y;
        split(root,val-1,x,y);
        ll ans=tree[x].size+1;
        root=merge(x,y);
        return ans;
    }
    inline void build(ll l,ll r){
        for(ll i=l; i<=r; i++) Insert(a[i]);
    }
    ll getvalbyrank(ll x,ll rank){
        if (rank<=tree[tree[x].lson].size) return getvalbyrank(tree[x].lson,rank);
        if (rank==tree[tree[x].lson].size+1) return tree[x].val;
        return getvalbyrank(tree[x].rson,rank-tree[tree[x].lson].size-1);
    }
    inline ll getprev(ll val){
        ll x,y;
        split(root,val-1,x,y);
        ll ans;
        if(tree[x].size) ans=getvalbyrank(x,tree[x].size);
        else ans=-INF;
        root=merge(x,y);
        return ans;
    }
    inline ll getnext(ll val){
        ll x,y;
        split(root,val,x,y);
        ll ans;
        if(tree[y].size) ans=getvalbyrank(y,1);
        else ans=INF;
        root=merge(x,y);
        return ans;
    }
}treap[N<<2];

struct SegmentTree{//线段树
    void build(ll p,ll l,ll r){
        treap[p].build(l,r);
        if(l==r) return;
        ll mid=(l+r)>>1;
        build(p<<1,l,mid);
        build(p<<1|1,mid+1,r);
    }
    ll getrankbyval(ll p,ll L,ll R,ll l,ll r,ll val){
        if(R<l||L>r) return 0;
        if(l<=L&&R<=r) return treap[p].getrankbyval(val)-1;
        ll mid=(L+R)>>1;
        return getrankbyval(p<<1,L,mid,l,r,val)+getrankbyval(p<<1|1,mid+1,R,l,r,val);
    }
    inline ll getvalbyrank(ll l,ll r,ll rank){
        ll L=0,R=1e8,ans=-1;
        while(L<=R){
            ll mid=(L+R)>>1;
            if(getrankbyval(1,1,n,l,r,mid)+1<=rank){
                ans=mid;
                L=mid+1;
            }
            else R=mid-1;
        }
        return ans;
    }
    void update(ll p,ll L,ll R,ll x,ll val){
        treap[p].Delete(a[x]);
        treap[p].Insert(val);
        if(L==R) return;
        ll mid=(L+R)>>1;
        if(x<=mid) update(p<<1,L,mid,x,val);
        else update(p<<1|1,mid+1,R,x,val);
    }
     ll getprev(ll p,ll L,ll R,ll l,ll r,ll val){
        if(R<l||L>r) return -INF;
        if(l<=L&&R<=r) return treap[p].getprev(val);
        ll mid=(L+R)>>1;
        return max(getprev(p<<1,L,mid,l,r,val),getprev(p<<1|1,mid+1,R,l,r,val));
    }
    ll getnext(ll p,ll L,ll R,ll l,ll r,ll val){
        if(R<l||L>r) return INF;
        if(l<=L&&R<=r) return treap[p].getnext(val);
        ll mid=(L+R)>>1;
        return min(getnext(p<<1,L,mid,l,r,val),getnext(p<<1|1,mid+1,R,l,r,val));
    }
}Tree;

int main(){
    cin>>n>>m;
    for(ll i=1; i<=n; i++) a[i]=read();
    Tree.build(1,1,n);
    while(m--){
        ll opt=read();
        switch(opt){
            case 1:{
                ll l=read(),r=read(),k=read();
                write(Tree.getrankbyval(1,1,n,l,r,k)+1); putchar('\n');
                break;   
            }
            case 2:{
                ll l=read(),r=read(),k=read();
                write(Tree.getvalbyrank(l,r,k)); putchar('\n');  
                break;  
            }
            case 3:{
                ll p=read(),k=read();
                Tree.update(1,1,n,p,k);
                a[p]=k;
                break;
            }
            case 4:{
                ll l=read(),r=read(),k=read();
                write(Tree.getprev(1,1,n,l,r,k)); putchar('\n');
                break;
            }
            case 5:{
                ll l=read(),r=read(),k=read();
                write(Tree.getnext(1,1,n,l,r,k)); putchar('\n');    
                break;
            }
        }
    }
    return 0;
}
```

---

## 作者：wtyqwq (赞：5)

- [P3380 【模板】树套树](https://www.luogu.com.cn/problem/P3380)

- 解题思路：分块套值域分块。
  
  首先对下标进行分块。每块的长度为 $\lfloor \sqrt{n} \rfloor$。
  
  同时对值域进行分块。设有 $(n+m)$ 个不同的数值，离散化之后，将值域分成 $\sqrt{n+m}$ 个块。
  
  接下来，我们预处理两个表：
  
  - $\text{C1}(i,j)$ ：表示按下标分块的前 $i$ 个块内有多少个数（离散化后）落在第 $j$ 个值域块。
  
  - $\text{C2}(i,j)$ ：表示按下标分块的前 $i$ 个块内有多少个数为 $j$。
  
  仔细想一想，这样的话，在单点修改和查询的时候，我们就可以完美地实现暴力与暴力之间的平衡。
  
  具体每个操作的处理方式如下：
  
  - 修改操作：将下标为 $p$ 的数修改为 $v$。
    
      令 $v$ 所在的值域块的编号为 $\text{pos}$，按下标分一共有 $\text{num}$ 个块，$\text{BEL}(i)$ 表示第 $i$ 个值所在值域块的编号, $\text{bel}(i)$ 表示下标 $i$ 所在下标块的编号，$a_i$ 表示离散化之后的数列。
  
      对于第 $i$ 个下标块（$i\in [\text{bel}(p),\text{num}]$），进行如下操作：
    
      ```cpp
      ++C1[i][BEL[v]], ++C2[i][v], --C1[i][BEL[a[p]], --C2[i][a[p]];
      ```
      最后，别忘了更新 $a$ 数组。
      
  - 查询排名操作：
      
      令查询区间为 $[l, r]$，查询 $k$ 的排名（$k$ 经过离散化），即比 $k$ 小的数的数量 $+1$ 的值。
      
      如果 $\text{bel}(l) = \text{bel}(r)$，我们直接暴力统计区间 $[l, r]$ 内有几个数（离散化后）比 $k$ 小即可。
      
      否则，边角暴力统计（和上面类似），中间部分靠我们维护的 $\text{C1}$ 和 $\text{C2}$ 数组快速累加：
      
      ```cpp
      //中间快速累加部分代码：
	for (int i = 1; i < BEL[k]; ++i) ret += C1[bel[r] - 1][i] - C1[bel[l]][i];
	for (int i = L[BEL[k]]; i < k; ++i) ret += C2[bel[r] - 1][i] - C2[bel[l]][i]; //L(i)表示第i个值域块的左端点。
      ```
      
      最后返回 $\text{ret+1}$ 即可。
      
  - 查询第 $k$ 小操作：
  
      令查询区间为 $[l, r]$。和后面的前驱、后继操作，我们都需临时维护两个数组 $\text{Cnt}$ 和 $\text{cnt}$。$\text{Cnt}(i)$ 表示在查询区间的边角部分中，落在第 $i$ 个值域块的数有多少个，$\text{cnt}(i)$ 表示在查询区间的边角部分中，值恰好为 $i$ 的数有多少个（经过离散化）。在求出返回答案，别忘了将其清零。
      
      ```cpp
      void Add(int x, int y) {//统计     a[x...y] 中的信息
	      for (int i = x; i <= y; ++i) ++Cnt[BEL[a[i]]], ++cnt[a[i]];
      }
      void Minus(int x, int y) {//恢复初始状态
	      for (int i = x; i <= y; ++i) --Cnt[BEL[a[i]]], --cnt[a[i]];
      }
     ```
      有了 $\text{C1},\text{C2},\text{Cnt},\text{cnt}$ 这四个数组，我们可以先确定答案在哪个值域块，再在那个值域块中求出精确的答案。这样，复杂度完美地停留在 $\sqrt{n+m}$。
      
      查询第 $k$ 小代码：

       ```
		inline int Get(int x, int y, int k) {//返回 a[x...y] 中第 k+1 大的值。
			int P1 = bel[x], P2 = bel[y], A = 1, B, cur = 0;//A表示答案在哪个值域块，B表示答案具体的值。先确定A，后求B。
			if (P1 == P2) {//查询区间在同一个块中。
				Add(x, y);
				for (; k >= Cnt[A]; ++A) k -= Cnt[A];
				for (B = L[A]; k >= cnt[B]; ++B) k -= cnt[B];
				Minus(x, y);
				return val[B];
			}
			Add(x, r[P1]), Add(l[P2], y);//求出 Cnt,cnt 数组。
			for (; k >= (cur = Cnt[A] + C1[P2 - 1][A] - C1[P1][A]); ++A) k -= cur;//确定答案在哪个值域块。
			for (B = L[A]; k >= (cur = cnt[B] + C2[P2 - 1][B] - C2[P1][B]); ++B) k -= cur;//精确答案。
			Minus(x, r[P1]), Minus(l[P2], y);
			return val[B];
		}       
       ```

   - 查询前驱、后继操作：只需不断向前或向后找到第一个满足条件的即可。思维难度较低，但是细节比较繁琐，实现时一定要非常注意。
  
------------
```cpp
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include <algorithm>
#define N 50005
#define LEN (1 << 9)
#define _R register
#define INF 0x7FFFFFFF
using namespace std;
char Buf[1 << 24], *S(Buf), *T(Buf);
#define getchar() (S == T && (T = (S = Buf) + fread(Buf, 1, 1 << 24, stdin), S == T) ? EOF : *S++)
inline int input() {
    _R int x(0), f(0);
    _R char c(getchar());
    while (!isdigit(c)) f |= (c == '-'), c = getchar();
    while (isdigit(c)) x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
    return f ? -x : x;
}
int a[N << 1], val[N << 1];
int bel[N], BEL[N << 1];
int len, num, Len, Num, n, m; 
int C1[LEN][LEN], C2[LEN][N << 1];
int L[LEN], R[LEN], l[LEN], r[LEN];
struct Oper { int F, S, E, opt; };
Oper d[N];
struct Data {
	int pos, val;
	inline Data() {}
	inline Data(int POS, int VAL) : pos(POS), val(VAL) {}
};
Data b[N << 1];
inline bool cmp(const Data &A, const Data &B) { return A.val < B.val; }
inline void Init_Data() {
	n = input(), m = input();
	int cnt = n, tot = 0;
	for (int i = 1; i <= n; ++i) b[i] = Data(i, input());
	for (int i = 1; i <= m; ++i) {
		int opt = d[i].opt = input();
		int F = input(), S = input(), T;
		if (opt == 3)
			d[i].F = F, d[i].E = ++cnt, b[cnt] = Data(cnt, S);
		else {
			T = input(), d[i].F = F, d[i].S = S;
			if (opt != 2)
				d[i].E = ++cnt, b[cnt] = Data(cnt, T); 
			else
				d[i].E = T;
		}
	}
	sort(b + 1, b + cnt + 1, cmp);
	for (int i = 1; i <= cnt; ++i)
		if (i == 1 || b[i].val != b[i - 1].val)
			val[a[b[i].pos] = ++tot] = b[i].val;
		else
			val[a[b[i].pos] = tot] = b[i].val;
	len = sqrt(n), num = n / len;
	Len = sqrt(tot), Num = tot / Len;
	for (int i = 1; i <= n; ++i) bel[i] = (i - 1) / len + 1;
	for (int i = 1; i <= tot; ++i) BEL[i] = (i - 1) / Len + 1;
	for (int i = 1; i <= num; ++i) l[i] = r[i - 1] + 1, r[i] = l[i] + len - 1;
	if (r[num] != n)
		++num, l[num] = r[num - 1] + 1, r[num] = n;
	for (int i = 1; i <= Num; ++i) L[i] = R[i - 1] + 1, R[i] = L[i] + Len - 1;
	if (R[Num] != tot)
		++Num, L[Num] = R[Num - 1] + 1, R[Num] = tot;
	for (_R int i = 1; i <= num; ++i) {
		for (_R int j = l[i], lim = r[i]; j <= lim; ++j) ++C2[i][a[j]], ++C1[i][BEL[a[j]]];
		for (_R int j = 1; j <= tot; ++j) C2[i][j] += C2[i - 1][j];
		for (_R int j = 1; j <= Num; ++j) C1[i][j] += C1[i - 1][j];
	}
}
inline int Rank(int x, int y, int val) {
	int P1 = bel[x], P2 = bel[y], ret = 0, pos = BEL[val];
	if (P1 == P2) {
		for (_R int i = x; i <= y; ++i) ret += (a[i] < val);
		return ret + 1;
	}
	for (_R int i = x; i <= r[P1]; ++i) ret += (a[i] < val);
	for (_R int i = l[P2]; i <= y; ++i) ret += (a[i] < val);
	for (_R int i = 1; i < pos; ++i) ret += C1[P2 - 1][i] - C1[P1][i];
	for (_R int i = L[pos]; i < val; ++i) ret += C2[P2 - 1][i] - C2[P1][i];
	return ret + 1;
}
int Cnt[LEN], cnt[N << 1];
inline void Add(int x, int y) {
	for (_R int i = x; i <= y; ++i) ++Cnt[BEL[a[i]]], ++cnt[a[i]];
}
inline void Minus(int x, int y) {
	for (_R int i = x; i <= y; ++i) --Cnt[BEL[a[i]]], --cnt[a[i]];
}
inline int Get(int x, int y, int k) {
	int P1 = bel[x], P2 = bel[y], A = 1, B, cur = 0;
	if (P1 == P2) {
		Add(x, y);
		for (; k >= Cnt[A]; ++A) k -= Cnt[A];
		for (B = L[A]; k >= cnt[B]; ++B) k -= cnt[B];
		Minus(x, y);
		return val[B];
	}
	Add(x, r[P1]), Add(l[P2], y);
	for (; k >= (cur = Cnt[A] + C1[P2 - 1][A] - C1[P1][A]); ++A) k -= cur;
	for (B = L[A]; k >= (cur = cnt[B] + C2[P2 - 1][B] - C2[P1][B]); ++B) k -= cur;
	Minus(x, r[P1]), Minus(l[P2], y);
	return val[B];
}
inline void Modify(int pos, int x) {
	int P = a[pos], BP = BEL[P], BN = BEL[x];
	for (_R int i = bel[pos]; i <= num; ++i) ++C1[i][BN], ++C2[i][x], --C1[i][BP], --C2[i][P];
	a[pos] = x;
}
inline int Pre(int x, int y, int k) {
	int P1 = bel[x], P2 = bel[y], pos = BEL[k], A = pos - 1, B = k - 1;
	if (P1 == P2) {
		Add(x, y);
		while (B >= L[pos] && cnt[B] == 0) --B;
		if (B == L[pos] - 1) {
			while (Cnt[A] == 0 && A >= 1) --A;
			if (A == 0) {
				Minus(x, y);
				return -INF;
			}
			for (B = R[A]; (!cnt[B]) && (B > L[A]); --B);
		}
		Minus(x, y);
		return val[B];
	}
	Add(x, r[P1]), Add(l[P2], y);
	while (B >= L[pos] && cnt[B] + C2[P2 - 1][B] - C2[P1][B] == 0) --B;
	if (B == L[pos] - 1) {
		while (Cnt[A] + C1[P2 - 1][A] - C1[P1][A] == 0 && A >= 1) --A;
		if (A == 0) {
			Minus(x, r[P1]), Minus(l[P2], y);
			return -INF;
		}
		for (B = R[A]; (cnt[B] + C2[P2 - 1][B] - C2[P1][B] == 0) && (B > L[A]) ; --B);
	}
	Minus(x, r[P1]), Minus(l[P2], y);
	return val[B];
}
inline int Nex(int x, int y, int k) {
	int P1 = bel[x], P2 = bel[y], pos = BEL[k], A = pos + 1, B = k + 1;
	if (P1 == P2) {
		Add(x, y);
		while (B <= R[pos] && cnt[B] == 0) ++B;
		if (B == R[pos] + 1) {
			while (Cnt[A] == 0 && A <= Num) ++A;
			if (A == Num + 1) {
				Minus(x, y);
				return INF;
			}
			for (B = L[A]; (!cnt[B]) && (B < R[A]); ++B);
		}
		Minus(x, y);
		return val[B];
	}
	Add(x, r[P1]), Add(l[P2], y);
	while (B <= R[pos] && cnt[B] + C2[P2 - 1][B] - C2[P1][B] == 0) ++B;
	if (B == R[pos] + 1) {
		while (Cnt[A] + C1[P2 - 1][A] - C1[P1][A] == 0 && A <= Num) ++A;
		if (A == Num + 1) {
			Minus(x, r[P1]), Minus(l[P2], y);
			return INF;
		}
		for (B = L[A]; (cnt[B] + C2[P2 - 1][B] - C2[P1][B] == 0) && (B < R[A]); ++B);
	}
	Minus(x, r[P1]), Minus(l[P2], y);
	return val[B];
}
int main() {
	Init_Data();
	for (int i = 1; i <= m; ++i) {
		if (d[i].opt == 1)
			printf("%d\n", Rank(d[i].F, d[i].S, a[d[i].E]));
		else if (d[i].opt == 2)
			printf("%d\n", Get(d[i].F, d[i].S, d[i].E - 1));
		else if (d[i].opt == 3)
			Modify(d[i].F, a[d[i].E]);
		else if (d[i].opt == 4)
			printf("%d\n", Pre(d[i].F, d[i].S, a[d[i].E]));
		else
			printf("%d\n", Nex(d[i].F, d[i].S, a[d[i].E]));
	}
	return 0;
}
```
- 算法标签：分块（分块套值域分块），排序，离散化。

- 时间复杂度：$O((n+m)\sqrt{n+m})$。

- 空间复杂度：$O((n+m)\sqrt{n})$。

- 期望得分：$100$ 分。[提交记录](https://www.luogu.com.cn/record/34212939)。

- 备注：这是一份在评测机不断变慢后仍然进了最优解前 $20$ 的代码。

---

## 作者：day_dream (赞：4)

&emsp;这题可以用树状数组套可持久化线段树做的呀！

&emsp;如果没有修改操作，那么一个主席树就做完了，但是这题多了个修改操作。
每一次修改操作相当于值域线段树上一条链-1，另一条链+1，并且对所有后面的树都有影响，由此我们想到可以用树状数组来维护修改操作。

&emsp;每一个树状数组的点相当于一个可持久化线段树，一开始什么也没有。对于每一次修改操作，我们向在序列上一样，对于相应的点在原数的位置-1，在修改成的数的位置+1。询问的时候，我们要把对应的点算上，每次将它们一起向左(向右)跳，统计答案就ok了。

&emsp;当然，这其中还有一个令人难受的操作，就是找前驱后继。在一棵普通的可持久化线段树上，我们可以直接向左(向右)跳，如果找不到答案再向另一个方向跳。但是在这题，我们同时还要让我们树状数组维护的树上的节点向左(向右)跳，所以我们必需要再每层先记录树状数组维护的当前的节点编号，当我们找不到时再向另一个方向跳。

>具体的看代码吧，我表达太差了

```
#include<algorithm>
#include<cstdio>
using namespace std;
int n,m,sl,fh,tot,rt_num,a[50010],s[100010];
int S[50010],L[50010],R[50010],rt[50010];
struct ask
{
    int t,l,r,k;
}q[50010];
struct seg
{
    int siz,sn[2];
}tre[8000010];
char gc()
{
    static char buf[1<<16],*P,*Q;
    if(P==Q){Q=(P=buf)+fread(buf,1,1<<16,stdin);if(P==Q)return EOF;}
    return *P++;
}
int rd()
{
    sl=0;fh=1;
    char ch=gc();
    while(ch<'0'||'9'<ch) {if(ch=='-') fh=-1; ch=gc();}
    while('0'<=ch&&ch<='9') sl=sl*10+ch-'0',ch=gc();
    return sl*fh;
}
void build(int &no,int l,int r)
{
    no=++rt_num;
    if(l==r) return ;
    int mid=(l+r)>>1;
    build(tre[no].sn[0],l,mid);
    build(tre[no].sn[1],mid+1,r);
}
void update(int &no,int l,int r,int x,int val)
{
    tre[++rt_num]=tre[no];no=rt_num;
    tre[no].siz+=val;
    if(l==r) return ;
    int mid=(l+r)>>1;
    if(x<=mid) update(tre[no].sn[0],l,mid,x,val);
    else update(tre[no].sn[1],mid+1,r,x,val);
}
int sum(int x,int T[],int k)
{
    int ret=0;
    for(int i=x;i;i-=(i&-i)) ret+=tre[tre[T[i]].sn[k]].siz;
    return ret;
}
int rank(int x,int y,int lr,int rr,int l,int r,int t)
{
    if(l==r) return 0;
    int mid=(l+r)>>1;
    if(t<=mid)
    {
        for(int i=x;i;i-=(i&-i)) L[i]=tre[L[i]].sn[0];
        for(int i=y;i;i-=(i&-i)) R[i]=tre[R[i]].sn[0];
        return rank(x,y,tre[lr].sn[0],tre[rr].sn[0],l,mid,t);
    }
    else
    {
        int k=sum(y,R,0)-sum(x,L,0)+tre[tre[rr].sn[0]].siz-tre[tre[lr].sn[0]].siz;
        for(int i=x;i;i-=(i&-i)) L[i]=tre[L[i]].sn[1];
        for(int i=y;i;i-=(i&-i)) R[i]=tre[R[i]].sn[1];
        return rank(x,y,tre[lr].sn[1],tre[rr].sn[1],mid+1,r,t)+k;
    }
}
int kth(int x,int y,int lr,int rr,int l,int r,int k)
{
    if(l==r) return l;
    int mid=(l+r)>>1,t=sum(y,R,0)-sum(x,L,0)+tre[tre[rr].sn[0]].siz-tre[tre[lr].sn[0]].siz;
    if(k<=t)
    {
        for(int i=x;i;i-=(i&-i)) L[i]=tre[L[i]].sn[0];
        for(int i=y;i;i-=(i&-i)) R[i]=tre[R[i]].sn[0];
        return kth(x,y,tre[lr].sn[0],tre[rr].sn[0],l,mid,k);
    }
    else
    {
        for(int i=x;i;i-=(i&-i)) L[i]=tre[L[i]].sn[1];
        for(int i=y;i;i-=(i&-i)) R[i]=tre[R[i]].sn[1];
        return kth(x,y,tre[lr].sn[1],tre[rr].sn[1],mid+1,r,k-t);
    }
}
void change(int x,int y,int val) {for(int i=x;i<=n;i+=(i&-i)) update(S[i],1,tot,y,val);}
int findpre(int x,int y,int lr,int rr,int l,int r,int t)
{
    if(l==r) return l;
    int mid=(l+r)>>1;
    if(t<=mid)
    {
        int k=sum(y,R,0)-sum(x,L,0)+tre[tre[rr].sn[0]].siz-tre[tre[lr].sn[0]].siz;
        if(!k) return -1;
        for(int i=x;i;i-=(i&-i)) L[i]=tre[L[i]].sn[0];
        for(int i=y;i;i-=(i&-i)) R[i]=tre[R[i]].sn[0];
        return findpre(x,y,tre[lr].sn[0],tre[rr].sn[0],l,mid,t);
    }
    else
    {
        int k=sum(y,R,1)-sum(x,L,1)+tre[tre[rr].sn[1]].siz-tre[tre[lr].sn[1]].siz;
        int ql[50010],qr[50010];
        for(int i=x;i;i-=(i&-i)) ql[i]=L[i],L[i]=tre[L[i]].sn[1];
        for(int i=y;i;i-=(i&-i)) qr[i]=R[i],R[i]=tre[R[i]].sn[1];
        if(k) k=findpre(x,y,tre[lr].sn[1],tre[rr].sn[1],mid+1,r,t);else k=-1;
        if(k!=-1)return k;
        k=sum(y,qr,0)-sum(x,ql,0)+tre[tre[rr].sn[0]].siz-tre[tre[lr].sn[0]].siz;
        for(int i=x;i;i-=(i&-i)) L[i]=tre[ql[i]].sn[0];
        for(int i=y;i;i-=(i&-i)) R[i]=tre[qr[i]].sn[0];
        if(k) return findpre(x,y,tre[lr].sn[0],tre[rr].sn[0],l,mid,t);
        return -1;
    }
}
int findsub(int x,int y,int lr,int rr,int l,int r,int t)
{
    if(l==r) return l;
    int mid=(l+r)>>1;
    if(t<=mid)
    {
        int k=sum(y,R,0)-sum(x,L,0)+tre[tre[rr].sn[0]].siz-tre[tre[lr].sn[0]].siz;
        int ql[50010],qr[50010];
        for(int i=x;i;i-=(i&-i)) ql[i]=L[i],L[i]=tre[L[i]].sn[0];
        for(int i=y;i;i-=(i&-i)) qr[i]=R[i],R[i]=tre[R[i]].sn[0];
        if(k) k=findsub(x,y,tre[lr].sn[0],tre[rr].sn[0],l,mid,t);else k=-1;
        if(k!=-1) return k;
        k=sum(y,qr,1)-sum(x,ql,1)+tre[tre[rr].sn[1]].siz-tre[tre[lr].sn[1]].siz;
        for(int i=x;i;i-=(i&-i)) L[i]=tre[ql[i]].sn[1];
        for(int i=y;i;i-=(i&-i)) R[i]=tre[qr[i]].sn[1];
        if(k) return findsub(x,y,tre[lr].sn[1],tre[rr].sn[1],mid+1,r,t);
        return -1;
    }
    else
    {
        int k=sum(y,R,1)-sum(x,L,1)+tre[tre[rr].sn[1]].siz-tre[tre[lr].sn[1]].siz;
        if(!k) return -1;
        for(int i=x;i;i-=(i&-i)) L[i]=tre[L[i]].sn[1];
        for(int i=y;i;i-=(i&-i)) R[i]=tre[R[i]].sn[1];
        return findsub(x,y,tre[lr].sn[1],tre[rr].sn[1],mid+1,r,t);
    }
}
int main()
{
    n=rd();m=rd();tot=n;
    for(int i=1;i<=n;++i) s[i]=a[i]=rd();
    for(int i=1;i<=m;++i)
    {
        q[i].t=rd();
        if(q[i].t==3) q[i].l=rd(),s[++tot]=q[i].k=rd();
        else if(q[i].t==2) q[i].l=rd(),q[i].r=rd(),q[i].k=rd();
        else q[i].l=rd(),q[i].r=rd(),s[++tot]=q[i].k=rd();
    }
    sort(s+1,s+tot+1);tot=unique(s+1,s+tot+1)-s-1;
    build(rt[0],1,tot);
    for(int i=1;i<=n;++i)
    {
        rt[i]=rt[i-1];a[i]=lower_bound(s+1,s+tot+1,a[i])-s;
        update(rt[i],1,tot,a[i],1);
    }
    for(int i=1;i<=n;++i) S[i]=rt[0];
    int x,l,r;
    for(int i=1;i<=m;++i)
    {
        if(q[i].t==1)
        {
            x=lower_bound(s+1,s+tot+1,q[i].k)-s;l=q[i].l-1;r=q[i].r;
            for(int j=l;j;j-=(j&-j)) L[j]=S[j];
            for(int j=r;j;j-=(j&-j)) R[j]=S[j];
            printf("%d\n",rank(l,r,rt[l],rt[r],1,tot,x)+1);
        }
        else if(q[i].t==2)
        {
            l=q[i].l-1;r=q[i].r;
            for(int j=l;j;j-=(j&-j)) L[j]=S[j];
            for(int j=r;j;j-=(j&-j)) R[j]=S[j];
            printf("%d\n",s[kth(l,r,rt[l],rt[r],1,tot,q[i].k)]);
        }
        else if(q[i].t==3)
        {
            change(q[i].l,a[q[i].l],-1);
            a[q[i].l]=lower_bound(s+1,s+tot+1,q[i].k)-s;
            change(q[i].l,a[q[i].l],1);
        }
        else if(q[i].t==4)
        {
            x=lower_bound(s+1,s+tot+1,q[i].k)-s-1;l=q[i].l-1;r=q[i].r;
            for(int j=l;j;j-=(j&-j)) L[j]=S[j];
            for(int j=r;j;j-=(j&-j)) R[j]=S[j];
            x=findpre(l,r,rt[l],rt[r],1,tot,x);
            if(x==-1) puts("-2147483647");
            else printf("%d\n",s[x]);
        }
        else
        {
            x=lower_bound(s+1,s+tot+1,q[i].k)-s+1;l=q[i].l-1;r=q[i].r;
            for(int j=l;j;j-=(j&-j)) L[j]=S[j];
            for(int j=r;j;j-=(j&-j)) R[j]=S[j];
            x=findsub(l,r,rt[l],rt[r],1,tot,x);
            if(x==-1) puts("2147483647");
            else printf("%d\n",s[x]);
        }
    }
    return 0;
}
```

---

## 作者：gorokokoro (赞：4)

最经典的，直接上线段树套平衡树就可以了。

操作 $2$ 是比较麻烦的，因为区间的 $k$ 值是不能够合并的。

但是如果二分最终的答案，就转变成了和操作 $1$ 相同的问题了（但是要判断相等的情况）。

因为有了二分，所以时间复杂度 $O(N\log^3N)$ 。稳稳的 $1000\text{ms}$ 过了（逃

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#pragma GCC optimize("O3")
#define N 50020
#define M 100000000
#define INFINITE 2147483647
using namespace std;

class Node
{
public:
    Node *s[2];
    int v;
    int e;
    int w;
    int z;

    Node(int _v, int _e, int _w, int _z) : v(_v), e(_e), w(_w), z(_z)
    {
        s[0] = s[1] = NULL;

        return;
    }

    int Size(int k)
    {
        return s[k] ? s[k] -> z : 0;
    }

    void Update(void)
    {
        z = Size(0) + Size(1) + w;

        return;
    }
};

class Treap
{
public:
    Node *r;

    void RotateTreap(Node *&x, int k)
    {
        Node *t;

        t = x -> s[!k];
        x -> s[!k] = t -> s[k];
        t -> s[k] = x;

        x -> Update();
        t -> Update();
        x = t;

        return;
    }

    void InsertTreap(Node *&x, int v, int w = 1)
    {
        if(!x)
            x = new Node(v, rand(), w, w);
        else if(x -> v == v)
            x -> w += w;
        else if(x -> v < v)
        {
            InsertTreap(x -> s[1], v, w);
            if(x -> s[1] -> e < x -> e)
                RotateTreap(x, 0);
        }
        else
        {
            InsertTreap(x -> s[0], v, w);
            if(x -> s[0] -> e < x -> e)
                RotateTreap(x, 1);
        }
        x -> Update();

        return;
    }

    void RemoveTreap(Node *&x, int v)
    {
        Node *t;
        int k;

        if(x -> v == v)
        {
            if(x -> w > 1)
                x -> w --;
            else
            {
                if(!x -> s[0])
                {
                    t = x;
                    x = x -> s[1];

                    delete t;
                    return;
                }
                if(!x -> s[1])
                {
                    t = x;
                    x = x -> s[0];

                    delete t;
                    return;
                }
                k = x -> s[0] -> e < x -> s[1] -> e;
                RotateTreap(x, k);
                RemoveTreap(x -> s[k], v);
            }
        }
        else
        {
            k = x -> v < v;
            RemoveTreap(x -> s[k], v);
            if(x -> s[k] && x -> s[k] -> e < x -> e)
                RotateTreap(x, x -> s[k] -> e < x -> e);
        }
        x -> Update();

        return;
    }

    int RankTreap(Node *x, int v)
    {
        int o;

        for(o = 0;x;)
            if(x -> v == v)
            {
                //printf("G %d\n", x -> Size(0));
                return o + x -> Size(0);
            }
            else if(x -> v < v)
            {
                o += x -> Size(0) + x -> w;
                x = x -> s[1];
            }
            else
                x = x -> s[0];

        return o;
    }

    int CountTreap(Node *x, int v)
    {
        while(x)
        {
            if(x -> v == v)
                return x -> w;
            x = x -> s[x -> v < v];
        }

        return 0;
    }

    int PrevTreap(Node *x, int v)
    {
        int o;

        for(o = -INFINITE;x;)
            if(x -> v >= v)
                x = x -> s[0];
            else
            {
                o = max(o, x -> v);
                x = x -> s[1];
            }

        return o;
    }

    int SuffTreap(Node *x, int v)
    {
        int o;

        for(o =  INFINITE;x;)
            if(x -> v <= v)
                x = x -> s[1];
            else
            {
                o = min(o, x -> v);
                x = x -> s[0];
            }

        return o;
    }

    void MergeTreap(Node *x)
    {
        if(!x)
            return;
        MergeTreap(x -> s[0]);
        MergeTreap(x -> s[1]);
        InsertTreap(r, x -> v, x -> w);

        return;
    }

    void OutputTreap(Node *x)
    {
        if(!x)
            printf("-1");
        else
        {
            putchar('(');
            OutputTreap(x -> s[0]);
            putchar(')');

            printf("%d",x -> v);

            putchar('(');
            OutputTreap(x -> s[1]);
            putchar(')');
        }

        return;
    }
};

class Segment
{
public:
    Treap f[N * 4];

    void BuildSegment(int *x, int i, int l, int r)
    {
        if(l >= r)
        {
            f[i].r = NULL;
            f[i].InsertTreap(f[i].r, x[l]);

            return;
        }

        BuildSegment(x, i * 2, l, (l + r) / 2);
        BuildSegment(x, i * 2 + 1, (l + r) / 2 + 1, r);
        f[i].r = NULL;
        f[i].MergeTreap(f[i * 2].r);
        f[i].MergeTreap(f[i * 2 + 1].r);
        /*for(int t = l;t <= r;t ++)
            f[i].InsertTreap(f[i].r, x[t]);*/
        /*if(f[i * 2].r -> z > f[i * 2 + 1].r -> z)
        {
            f[i] = f[i * 2];
            f[i].MergeTreap(f[i * 2 + 1].r);
        }
        else
        {
            f[i] = f[i * 2 + 1];
            f[i].MergeTreap(f[i * 2].r);
        }*/

        return;
    }

    int RankSegment(int i, int l, int r, int s, int t, int v)
    {
        if(r < s || l > t)
            return 0;
        if(l >= s && r <= t)
            return f[i].RankTreap(f[i].r, v);

        return RankSegment(i * 2, l, (l + r) / 2, s, t, v) + RankSegment(i * 2 + 1, (l + r) / 2 + 1, r, s, t, v);
    }

    int CountSegment(int i, int l, int r, int s, int t, int v)
    {
        if(r < s || l > t)
            return 0;
        if(l >= s && r <= t)
        {
            //printf("[%d - %d] < %d have %d\n", l, r, v, f[i].RankTreap(f[i].r, v));
            //f[i].OutputTreap(f[i].r);
            return f[i].RankTreap(f[i].r, v) + f[i].CountTreap(f[i].r, v);
        }

        return CountSegment(i * 2, l, (l + r) / 2, s, t, v) + CountSegment(i * 2 + 1, (l + r) / 2 + 1, r, s, t, v);
    }

    int PrevSegment(int i, int l, int r, int s, int t, int v)
    {
        if(r < s || l > t)
            return -INFINITE;
        if(l >= s && r <= t)
            return f[i].PrevTreap(f[i].r, v);

        return max(PrevSegment(i * 2, l, (l + r) / 2, s, t, v), PrevSegment(i * 2 + 1, (l + r) / 2 + 1, r, s, t, v));
    }

    int SuffSegment(int i, int l, int r, int s, int t, int v)
    {
        if(r < s || l > t)
            return  INFINITE;
        if(l >= s && r <= t)
            return f[i].SuffTreap(f[i].r, v);

        return min(SuffSegment(i * 2, l, (l + r) / 2, s, t, v), SuffSegment(i * 2 + 1, (l + r) / 2 + 1, r, s, t, v));
    }

    void SetSegment(int *x, int i, int l, int r, int p, int v)
    {
        if(l > p || r < p)
            return;
        if(l == p && r == p)
        {
            f[i].RemoveTreap(f[i].r, x[p]);
            f[i].InsertTreap(f[i].r, v   );

            return;
        }

        f[i].RemoveTreap(f[i].r, x[p]);
        f[i].InsertTreap(f[i].r, v   );
        SetSegment(x, i * 2, l, (l + r) / 2, p, v);
        SetSegment(x, i * 2 + 1, (l + r) / 2 + 1, r, p, v);

        return;
    }

    int KthSegment(int s, int t, int k, int n, pair<int, int> v)
    {
        int l, m, r;

        for(l = v.first - 1, r = v.second;l + 1 < r;)
        {
            //printf("%d : %d\n", (l + r) / 2, CountSegment(1, 0, n - 1, s, t, m = (l + r) / 2));
            if(CountSegment(1, 0, n - 1, s, t, m = (l + r) / 2) >= k)
                r = m;
            else
                l = m;
        }

        return r;
    }
};

class Segwin
{
private:
    int n;
    int f[N * 4];
    int g[N * 4];

public:
    void BuildSegwin(int n, int *x)
    {
        int i;

        this -> n = n;
        for(i = 0;i < n;i ++)
            f[i + n] = g[i + n] = x[i];
        for(i = n - 1;i > -1;i --)
        {
            f[i] = min(f[i << 1], f[i << 1 | 1]);
            g[i] = max(g[i << 1], g[i << 1 | 1]);
        }

        return;
    }

    pair<int, int> MixSegwin(int s, int t)
    {
        pair<int, int> o;

        for(o = make_pair(INFINITE, -INFINITE), s += n, t += n + 1;s < t;s >>= 1, t >>= 1)
        {
            if(s & 1)
            {
                o.first  = min(o.first , f[s]);
                o.second = max(o.second, g[s]);
                s ++;
            }
            if(t & 1)
            {
                t --;
                o.first  = min(o.first , f[t]);
                o.second = max(o.second, g[t]);
            }
        }

        return o;
    }

    void SetSegwin(int p, int v)
    {
        for(p += n, f[p] = g[p] = v;p >>= 1;)
        {
            f[p] = min(f[p << 1], f[p << 1 | 1]);
            g[p] = max(g[p << 1], g[p << 1 | 1]);
        }

        return;
    }
};

int a[N];
Segment f;
Segwin g;

int main()
{
    int n, m, p, l, r, k;
    int i;

    scanf("%d %d", &n, &m);
    for(i = 0;i < n;i ++)
        scanf("%d", &a[i]);

    f.BuildSegment(a, 1, 0, n - 1);
    g.BuildSegwin(n, a);
    while(m --)
    {
        scanf("%d %d %d", &p, &l, &r);
        if(p != 3)
        {
            l --;
            r --;
            scanf("%d", &k);
        }

        if(p == 1)
            printf("%d\n", f.RankSegment(1, 0, n - 1, l, r, k) + 1);
        if(p == 2)
            printf("%d\n", f.KthSegment(l, r, k, n, /*make_pair(0, M)*/g.MixSegwin(l, r)));
            //printf("%d\n", f.CountSegment(1, 0, n - 1, l, r, k));
        if(p == 3)
        {
            f.SetSegment(a, 1, 0, n - 1, -- l, r);
            g.SetSegwin(l, r);
            a[l] = r;
        }
        if(p == 4)
            printf("%d\n", f.PrevSegment(1, 0, n - 1, l, r, k));
        if(p == 5)
            printf("%d\n", f.SuffSegment(1, 0, n - 1, l, r, k));
    }

    return 0;
}
```

---


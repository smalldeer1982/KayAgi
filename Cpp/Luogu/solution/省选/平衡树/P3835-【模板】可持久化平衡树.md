# 【模板】可持久化平衡树

## 题目背景

本题为题目 **普通平衡树** 的可持久化加强版。

**数据已经经过强化**

**感谢@Kelin 提供的一组hack数据**


## 题目描述

您需要写一种数据结构（可参考题目标题），来维护一个可重整数集合，其中需要提供以下操作（ **对于各个以往的历史版本** ）：


1、 插入 $x$

2、 删除 $x$（若有多个相同的数，应只删除一个，**如果没有请忽略该操作**）


3、 查询 $x$ 的排名（排名定义为比当前数小的数的个数 $+1$）


4、查询排名为 $x$ 的数


5、 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数，**如不存在输出** $-2^{31}+1$ ）


6、求 $x$ 的后继（后继定义为大于 $x$，且最小的数，**如不存在输出** $2^{31}-1$ ）


**和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本。（操作3, 4, 5, 6即保持原版本无变化）**

每个版本的编号即为操作的序号（版本0即为初始状态，空树）


## 说明/提示

【数据范围】   
对于 $28\%$ 的数据，$ 1 \leq n \leq 10 $；   
对于 $44\%$ 的数据，$ 1 \leq n \leq 2\times {10}^2 $；   
对于 $60\%$ 的数据， $ 1 \leq n \leq 3\times {10}^3 $；   
对于 $84\%$ 的数据， $ 1 \leq n \leq {10}^5 $；   
对于 $92\%$ 的数据， $ 1 \leq n \leq 2\times {10}^5 $；   
对于 $100\%$ 的数据， $ 1 \leq n \leq 5 \times  10^5 $ , $|x_i| \leq {10}^9$，$0 \le v_i < i$，$1\le \text{opt} \le 6$。

**经实测，正常常数的可持久化平衡树均可通过，请各位放心**



样例说明：

共 $10$ 次操作，$11$ 个版本，各版本的状况依次是：

0.  $[]$

1.  $[9]$

2.  $[3, 9]$

3.  $[9, 10]$

4.  $[3, 9]$

5.  $[9, 10]$

6.  $[2, 9, 10]$

7.  $[2, 9, 10]$

8.  $[2, 10]$

9.  $[2, 10]$

10.  $[3, 9]$


## 样例 #1

### 输入

```
10
0 1 9
1 1 3
1 1 10
2 4 2
3 3 9
3 1 2
6 4 1
6 2 9
8 6 3
4 5 8```

### 输出

```
9
1
2
10
3```

# 题解

## 作者：小粉兔 (赞：61)

### 题意简述：

题面说的很清楚了。

### 题解：

考虑建立一棵每个节点都表示一个版本的树。

以初始版本 $0$ 为根。对于第 $i$ 个操作，从 $v_i$ 向 $i$ 连一条边，而边权则是 $opt_i$ 和 $x_i$ 的二元组，表示经过这条边上操作，可以达到下一个状态。

考虑使用权值树状数组维护操作。只需要实现单点加，查询前缀和以及树状数组上二分的操作即可。

树状数组提前插入 $-2147483647$ 和 $2147483647$ 两个数，方便统计。

因为权值范围太大，所以先离散化权值，再插入树状数组。

只需要从结点 $0$ 开始 DFS ，进入子树时执行操作，退出子树时撤销操作即可。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

const int INF = 0x7fffffff;
const int MQ = 500010;

int N, Q;
int faz[MQ], opt[MQ], a[MQ], b[MQ];
int Ans[MQ];

int eh[MQ], nxt[MQ], to[MQ], tot;
inline void ins(int x, int y) {
	nxt[++tot] = eh[x]; to[tot] = y; eh[x] = tot;
}

int B[MQ];
inline void Add(int i, int x) { for (; i <= N; i += i & -i) B[i] += x; }
inline int Qur(int i) { int A = 0; for (; i; i -= i & -i) A += B[i]; return A; }
inline int BS(int x) { int p = 0; for (int j = 1 << 18; j; j >>= 1) if ((p | j) <= N && B[p | j] <= x) x -= B[p |= j]; return p;}

void DFS(int u, int o, int x) {
	int ok = 1;
	if (o == 1) Add(x, 1);
	if (o == 2) {
		if (Qur(x) == Qur(x - 1)) ok = 0;
		else Add(x, -1);
	}
	if (o == 3) Ans[u] = Qur(x - 1);
	if (o == 4) Ans[u] = b[BS(x) + 1];
	if (o == 5) Ans[u] = b[BS(Qur(x - 1) - 1) + 1];
	if (o == 6) Ans[u] = b[BS(Qur(x)) + 1];
	
	for (int i = eh[u]; i; i = nxt[i])
		DFS(to[i], opt[to[i]], a[to[i]]);
	
	if (o == 1) Add(x, -1);
	if (o == 2 && ok) Add(x, 1);
}

int main() {
	scanf("%d", &Q);
	for (int i = 1; i <= Q; ++i) {
		scanf("%d%d%d", &faz[i], &opt[i], &a[i]);
		if (opt[i] != 4)
			b[++N] = a[i];
	} b[++N] = -INF, b[++N] = INF;
	sort(b + 1, b + N + 1);
	N = unique(b + 1, b + N + 1) - b - 1;
	for (int i = 1; i <= Q; ++i) {
		ins(faz[i], i);
		if (opt[i] != 4)
			a[i] = lower_bound(b + 1, b + N + 1, a[i]) - b;
	}
	Add(1, 1), Add(N, 1);
	DFS(0, 0, 0);
	for (int i = 1; i <= Q; ++i) {
		if(opt[i] > 2)
			printf("%d\n", Ans[i]);
	}
	return 0;
}
```

---

## 作者：yijan (赞：34)

以rope实现的，很简单的可持久数组。  
由于只是个数组，开5e5个显然会炸空间，所以这是篇部分分的题解。

rope是什么？STL的内置的可持久化的数组。其最为方便的就是可以O1复制原来的数组。事实上rope的内置实现也是平衡树，由于只需要复制根结点，O1可以做到复制历史版本。

然而这个东西不开O2会被卡T四个点！

实现思路非常简单，对于一个新的操作，先复制其上一个操作的版本（O1！）然后进行操作。

我们保证每个版本中的数字都是有序的，然后每次插入需要二分寻找插入位置，二分寻找删除位置，二分寻找前驱后缀，对于查排名就更简单了，由于是有序的，直接 begin() + rank 就可以得到。为了实现方便，选择使用STL中的lowerbound和upperbound，很慢是肯定的。对于题目中范围不大不需要太优秀的时候可以采用这种方法，四十行不到实现可持久平衡树。

科普一下rope基本操作（百度貌似有点难找）：
```cpp
#include<ext/rope>
using namespace __gnu_cxx;//rope的命名空间
rope<type> R;
R.push_back(a) //往后插入
R.insert(pos,a)//在pos位置插入a，pos是一个迭代器。
R.erase(pos,n)//在pos位置删除n个元素。
R.replace(pos,x)//从pos开始替换成x
R.substr(pos,x)//从pos开始提取x个。
//多数时候定义rope用指针（方便可持久化） 所以上面的点多数时候要换成->
```
如何进行复制？很简单，一句话：  
```cpp
rope<type>* R[1000];
R[i] = new rope<type>(*R[v]);
```
在上部分分代码前先说一下如何对其优化空间，我们发现查询操作对原数组不改变，于是可以开个bac数组查询操作直接映射到查询前的版本（两个版本一样），就可以少开写空间。但是~~yijan太懒了~~懒得写。。于是只有一个80分代码贴在这里：
```cpp
/*Heroes Never Die!*/
#include "ext/rope"
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
using namespace __gnu_cxx;
#define MAXN 500006
rope<int> *nums[MAXN];int n;
int main(){
    cin >> n;
    nums[0] = new rope<int>();
    for(int i=1;i<=n;++i){
        static int v,opt,x;
        scanf("%d%d%d",&v,&opt,&x);
        nums[i] = new rope<int>(*nums[v]);
        if(opt == 1)
            nums[i]->insert(lower_bound(nums[i]->begin(),nums[i]->end(),x)-nums[i]->begin(),x);
        if(opt == 2){
            auto it = lower_bound(nums[i]->begin(),nums[i]->end(),x);
            if(*it == x) nums[i]->erase(it-nums[i]->begin(),1);
        }
        if(opt == 3)
            printf("%d\n",(int)(lower_bound(nums[i]->begin(),nums[i]->end(),x)-nums[i]->begin()) + 1);
        if(opt == 4)
            printf("%d\n",*(nums[i]->begin() + x - 1));
        if(opt == 5){
            auto it = lower_bound(nums[i]->begin(),nums[i]->end(),x);
            if(it == nums[i]->begin() - 1) puts("-2147483647");
            else --it,printf("%d\n",*it);
        }
        if(opt == 6){
            auto it = upper_bound(nums[i]->begin(),nums[i]->end(),x);
            if(it == nums[i]->end()) puts("2147483647");
            else printf("%d\n",*it);
        }
    }
}
```

---

## 作者：GGN_2015 (赞：26)

”一道可持久化数据结构的题，如果不强制在线，那么它八成不是一道真正的可持久化数据结构的题。“ —— GGN_2015

惊奇地发现这道题其实并不需要任何可持久化数据结构。

我们只需要建立一颗”时光树“（我们暂且这样称呼它）。如果i时刻的平衡树是由$v_i$时刻发展而来的，那么我们就令”时光树“上i号结点的父亲为$v_i$。0号结点显然是整棵”时光树“的根结点。

维护一棵平衡树（我写的是treap），最开始的时候这是一棵空树。在”时光树“上DFS，每进入结点i时就在平衡树中进行操作i（修改数据结构或储存查询的结果），然后再依次DFS结点i的每个儿子。退出结点i时，就”撤销“这个结点对数据结构的修改。例如当$opt_i = 1$时，我们向数据结构中插入了元素$x_i$，离开结点i时，我们再把$x_i$从数据结构中删除。

比较特殊的是：当$opt_i = 2$时，删除是可能失败的。如果删除失败的话，我们在回溯的时候要特判（就是说不要把本就没被成功删除的$x_i$插入回数据结构中）。

附上代码之前先作出一个声明：我的treap的代码不支持可重集合，所以我用了一个类似pair的数据结构来储存元素（第一维存储元素的值，第二维记录操作的编号），这样可以保证treap中没有重复的元素。另外，我懒得写前去和后继的查询，所以我的”前驱“和”后继“查询是利用”排名“和”第k大“查询间接实现的。（我觉得这样写treap更好调试一些）

```cpp
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;

struct item {int val, id;};
bool operator < (item A, item B) {
	if(A.val != B.val) return A.val < B.val;
	return A.id < B.id;
}
bool operator == (item A, item B) {
	return A.val==B.val && A.id==B.id;
}

const int maxn = (500000 + 6)*2;
namespace treap {
	int ch[maxn][2], rnd[maxn], siz[maxn]; item key[maxn]; int ncnt;
	queue<int> Q;
	void maintain(int x) {
		siz[x] = 1 + siz[ch[x][0]] + siz[ch[x][1]];
	}
	int newnode() {
		if(!Q.empty()) {
			int x = Q.front(); Q.pop();
			ch[x][0] = ch[x][1] = rnd[x] = siz[x] = 0; key[x] = (item){0, 0};
			return x;
		}
		return ++ ncnt;
	}
	void rotate(int& x, int d) {
		int k = ch[x][d^1]; ch[x][d^1] = ch[k][d]; ch[k][d] = x;
		maintain(x); x = k; maintain(k);
	}
	void insert(int& x, item v) {
		if(x == 0) {
			x = newnode(); rnd[x] = rand(); siz[x] = 1; key[x] = v;
			return;
		}
		int d = v < key[x] ? 0 : 1; insert(ch[x][d], v);
		maintain(x);
		if(rnd[x] > rnd[ch[x][d]]) rotate(x, d^1);
	}
	int rnk(int x, item v) {
		if(x == 0) return 1;
		int lsiz = 1 + siz[ch[x][0]];
		if(v == key[x]) return lsiz;
		if(v < key[x]) return rnk(ch[x][0], v);
		else           return rnk(ch[x][1], v) + lsiz;
	}
	item kth(int x, int k) {
		if(x==0 || k<=0 || k>siz[x])
			return k<=0 ? (item){-2147483647, 0} : (item){2147483647, 0};
		int lsiz = 1 + siz[ch[x][0]];
		if(lsiz == k) return key[x];
		if(k < lsiz) return kth(ch[x][0], k);
		else         return kth(ch[x][1], k-lsiz);
	}
	int LSIZ(int x) {return 1 + siz[ch[x][0]];}
	void erase(int& x, int k) {
		if(x == 0) return; /// 删除元素时一定要特判检测是否相等
		int lsiz = 1 + siz[ch[x][0]];
		if(lsiz == k) {
			if(ch[x][0]==0 || ch[x][1]==0) {
				int tmp = x; x = ch[x][0] + ch[x][1]; Q.push(tmp);
				ch[tmp][0] = ch[tmp][1] = siz[tmp] = rnd[tmp] = 0;
				key[tmp] = (item){0, 0};
			}else {
				if(rnd[ch[x][0]] > rnd[ch[x][1]]) {
					rotate(x, 0); erase(ch[x][0], LSIZ(ch[x][0]));
				}else {
					rotate(x, 1); erase(ch[x][1], LSIZ(ch[x][1]));
				}
				maintain(x);
			}
			return;
		}else {
			if(k < lsiz) erase(ch[x][0], k);
			else         erase(ch[x][1], k-lsiz);
			maintain(x);
		}
	}
}

int root = 0, V[maxn], OPT[maxn], X[maxn], ANS[maxn];
namespace tree {
	vector<int> nxt[maxn];
	void addedge(int f, int t) {nxt[f].push_back(t);}
	void dfs(int x) {
		bool delsuc = 0; /// 记录删除操作是否成功
		if(OPT[x]) { /// 有操作
			if(OPT[x] == 1) { /// 插入一个元素
				treap::insert(root, (item){X[x], x});
			}else if(OPT[x] == 2) { /// 删除一个元素
				int rnk = treap::rnk(root, (item){X[x], 0}); /// 查询这个元素的排名
				int get = treap::kth(root, rnk).val; /// 得到这个元素(可能为+-inf)
				if(get == X[x]) { /// 可以删除
					treap::erase(root, rnk); delsuc = 1;
				}
			}else if(OPT[x] == 3) { /// 查排名
				ANS[x] = treap::rnk(root, (item){X[x], 0});
			}else if(OPT[x] == 4) { /// 查第k大
				ANS[x] = treap::kth(root, X[x]).val;
			}else if(OPT[x] == 5) { /// prev
				int rnk = treap::rnk(root, (item){X[x], 0}) - 1;
				int get = treap::kth(root, rnk).val;
				ANS[x] = get;
			}else if(OPT[x] == 6) { /// next
				int rnk = treap::rnk(root, (item){X[x], 0x7f7f7f7f});
				int get = treap::kth(root, rnk).val;
				ANS[x] = get;
			}
		}
		for(int i = 0; i < (int)nxt[x].size(); i ++) {
			int t = nxt[x][i]; dfs(t); /// 递归计算
		}
		if(OPT[x] == 1) { /// 回滚插入操作
			int rnk = treap::rnk(root, (item){X[x], 0}); /// 一定有
			treap::erase(root, rnk);
		}
		if(OPT[x]==2 && delsuc) {
			treap::insert(root, (item){X[x], x});
		}
	}
}

int main() {
	//freopen("nontime.in", "r", stdin);
	int n; scanf("%d", &n);
	for(int i = 1; i <= n; i ++) {
		scanf("%d%d%d", &V[i], &OPT[i], &X[i]);
		tree::addedge(V[i], i);
	}
	tree::dfs(0);
	for(int i = 1; i <= n; i ++) {
		if(OPT[i]>=3) {
			printf("%d\n", ANS[i]);
		}
	}
	return 0;
}
```

---

## 作者：stripe_python (赞：7)

现有的在线题解：FHQ-Treap、01-Trie、WBLT、线段树、替罪羊（复杂度是假的），和 [**有旋 Treap**](https://www.luogu.com.cn/article/6sbyh6lw)。

那么，既然有旋 Treap 可持久化，同样使用旋转维护平衡的 AVL 树也可以可持久化。

先介绍 AVL 树的原理：AVL 树每个节点维护树高 $high$，需要通过旋转操作保证 $|high_l-high_r| \le 1$。可以证明，满足这一性质的 AVL 树高为严格 $O(\log n)$。

AVL 树的节点定义如下：

```cpp
template <class T>
struct AVLTreeNode {
	T val;
	AVLTreeNode<T> *left, *right;
	long cnt, size, high;
	
	AVLTreeNode() :
	val(T()), left(nullptr), right(nullptr), cnt(1), size(1), high(1) {}
	
	AVLTreeNode(const T& v) :
	val(v), left(nullptr), right(nullptr), cnt(1), size(1), high(1) {}
	
	AVLTreeNode<T>* pushup() {
		size = cnt + (left ? left->size : 0) + (right ? right->size : 0);
		high = std::max(left ? left->high : 0, right ? right->high : 0) + 1;
		return this;
	}
};
```

每一次旋转、插入、删除时，我们复制一份 AVL 节点，见代码：

```cpp
static node* left_rotate(node* p) {
    // 左旋节点 p
    node *q = p->left;
    p->left = copy(p->left);   // Added
    p->left = q->right, q->right = p, p->pushup();
    return q->pushup();
}
static node* right_rotate(node* p) {
    // 右旋节点 p
    node *q = p->right;
    p->right = copy(p->right);   // Added
    p->right = q->left, q->left = p, p->pushup();
    return q->pushup();
}
static node* left_right_rotate(node* p) {
    p->left = right_rotate(p->left);
    return left_rotate(p);
}
static node* right_left_rotate(node* p) {
    p->right = left_rotate(p->right);
    return right_rotate(p);
}
```

以下是完整版代码，对于普通 AVL 模板添加的地方做了标记。其实 AVL 也挺好写的。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5;

// AVL 树节点类，维护树高high
// AVL 树通过旋转保证 |left->high - right->high| <= 1
template <class T>
struct AVLTreeNode {
	T val;
	AVLTreeNode<T> *left, *right;
	long cnt, size, high;
	
	AVLTreeNode() :
	val(T()), left(nullptr), right(nullptr), cnt(1), size(1), high(1) {}
	
	AVLTreeNode(const T& v) :
	val(v), left(nullptr), right(nullptr), cnt(1), size(1), high(1) {}
	
	AVLTreeNode<T>* pushup() {
		size = cnt + (left ? left->size : 0) + (right ? right->size : 0);
		high = std::max(left ? left->high : 0, right ? right->high : 0) + 1;
		return this;
	}
};

template <class T, class Cmp = std::less<T>> 
struct AVLTree {
	using node = AVLTreeNode<T>;
	Cmp cmp = Cmp();
	node *roots[N];
	
	static node* copy(node* cur) {   // 复制节点
		node *res = nullptr;
		if (cur) res = new node, *res = *cur;
		return res;
	}
	
	static node* get_min(node* cur) {
		node *x = cur;
		while (x && x->left) x = x->left;
		return x;
	}
	static node* get_max(node* cur) {
		node *x = cur;
		while (x && x->right) x = x->right;
		return x;
	}
	
	static node* left_rotate(node* p) {
		// 左旋节点 p
		node *q = p->left;
		p->left = copy(p->left);   // Added
		p->left = q->right, q->right = p, p->pushup();
		return q->pushup();
	}
	static node* right_rotate(node* p) {
		// 右旋节点 p
		node *q = p->right;
		p->right = copy(p->right);   // Added
		p->right = q->left, q->left = p, p->pushup();
		return q->pushup();
	}
	static node* left_right_rotate(node* p) {
		p->left = right_rotate(p->left);
		return left_rotate(p);
	}
	static node* right_left_rotate(node* p) {
		p->right = left_rotate(p->right);
		return right_rotate(p);
	}
	static long get_high(node* p) {return p ? p->high : 0;}
	
	void insert(node*& cur, const T& val) {
		if (!cur) {
			cur = new node(val);
			return;
		}
		if (val == cur->val) {
			cur->cnt++, cur->pushup();
			return;
		}
		if (cmp(val, cur->val)) {
			cur->left = copy(cur->left);    // Added
			insert(cur->left, val), cur->pushup();
			if (get_high(cur->left) - get_high(cur->right) >= 2) {
				cur = cmp(val, cur->left->val) ? 
				left_rotate(cur) : left_right_rotate(cur);
			}
		} else {
			cur->right = copy(cur->right);   // Added
			insert(cur->right, val), cur->pushup();
			if (get_high(cur->right) - get_high(cur->left) >= 2) {
				cur = cmp(val, cur->right->val) ? 
				right_left_rotate(cur) : right_rotate(cur);
			}
		}
		cur->pushup();
	}
	
	bool remove_node(node*& cur) {
		if (!cur) return false;
		if (cur->cnt > 1) {
			cur->cnt--, cur->pushup();
			return true;
		}
		if (cur->left && cur->right) {
			node* replace = this->get_min(cur->right);
			cur->cnt = replace->cnt, cur->val = replace->val;
			replace->cnt = 1;
			remove(cur->right, replace->val), cur->pushup();
			if (get_high(cur->left) - get_high(cur->right) >= 2) {
				cur = (get_high(cur->left->left) >= get_high(cur->left->right)) ?
				left_rotate(cur) : left_right_rotate(cur);
			}
		} else {
			cur = cur->left ? cur->left : cur->right;
		}
		if (cur) cur->pushup();
		return true;
	}
	bool remove(node*& cur, const T& val) {
		if (!cur) return false;
		if (val == cur->val) return remove_node(cur);
		bool res;
		if (cmp(val, cur->val)) {
			cur->left = copy(cur->left);   // Added
			res = remove(cur->left, val), cur->pushup();
			if (get_high(cur->right) - get_high(cur->left) >= 2) {
				cur = get_high(cur->right->right) >= get_high(cur->right->left) ? 
				right_rotate(cur) : right_left_rotate(cur);
			}
		} else {
			cur->right = copy(cur->right);   // Added
			res = remove(cur->right, val), cur->pushup();
			if (get_high(cur->left) - get_high(cur->right) >= 2) {
				cur = get_high(cur->left->left) >= get_high(cur->left->right) ? 
				left_rotate(cur) : left_right_rotate(cur);
			}
		}
		if (cur) cur->pushup();
		return res;
	}
	
	int rank(node* cur, const T& val) const {
		if (!cur) return 1;
		int left_size = cur->left ? cur->left->size : 0;
		if (val == cur->val) return left_size + 1;
		if (cmp(val, cur->val)) return rank(cur->left, val);
		return rank(cur->right, val) + left_size + cur->cnt;
	}
	T kth(node* cur, int k) const {
		if (!cur) return T();
		int left_size = cur->left ? cur->left->size : 0;
		if (left_size >= k) return kth(cur->left, k);
		if (left_size < k - cur->cnt) return kth(cur->right, k - left_size - cur->cnt);
		return cur->val;
	}

	T predecessor(node *root, const T& val) const {
		node *cur = root;
		T res = -numeric_limits<T>::max();
		while (cur) {
			if (cmp(cur->val, val)) res = cur->val, cur = cur->right;
			else cur = cur->left;
		}
		return res;
	}
	T successor(node *root, const T& val) const {
		node *cur = root;
		T res = numeric_limits<T>::max();
		while (cur) {
			if (cmp(val, cur->val)) res = cur->val, cur = cur->left;
			else cur = cur->right;
		}
		return res;
	}
};

AVLTree<int> avl;
int q, v, opt, x;

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	cin >> q;
	avl.roots[0] = nullptr;
	for (int i = 1; i <= q; i++) {
		cin >> v >> opt >> x;
		avl.roots[i] = avl.copy(avl.roots[v]);
		if (opt == 1) avl.insert(avl.roots[i], x);
		else if (opt == 2) avl.remove(avl.roots[i], x);
		else if (opt == 3) cout << avl.rank(avl.roots[i], x) << '\n';
		else if (opt == 4) cout << avl.kth(avl.roots[i], x) << '\n';
		else if (opt == 5) cout << avl.predecessor(avl.roots[i], x) << '\n';
		else if (opt == 6) cout << avl.successor(avl.roots[i], x) << '\n';
		//cerr << prettify(avl.roots[i]) << endl;
	}
	return 0;
}
```

---

## 作者：registerGen (赞：4)

首先感谢 @wangrx 大佬帮我卡常！！

---

看到题解里没有指针实现的 fhq-Treap，那我就来一发吧。

可持久化 fhq-Treap 的核心是它的两个基层操作——分裂和合并。

其它的操作按照不可持久的 fhq-Treap 写就行了。

可持久化**数据结构**的核心思想是：尽可能新建更少的结点记录新版本的信息，同时保留住历史版本的结点信息。可持久化 fhq-Treap 也不例外。

fhq-Treap 的可持久化：

已知有:

```cpp
typedef std::pair<Node*,Node*> droot;
```

对于分裂操作:

```cpp
droot split(Node* x,int k)
{
	if(!x)return droot(NULL,NULL);
	droot res;
	if(siz(x->ls)>=k)
	{
		res=split(x->ls,k);
		// 我们新建一个结点，并将 x 的信息复制到它身上。
		Node* p=new Node;
		copy(p,x);
		// 下面是对 p 进行 fhq-Treap 的正常操作
		p->ls=res.second;
		p->pushup();
		res.second=p;
	}
	else
	{
		res=split(x->rs,k-siz(x->ls)-1);
		// 同理
		Node* p=new Node;
		copy(p,x);
		p->rs=res.first;
		p->pushup();
		res.first=p;
	}
	return res;
}
```

对于合并操作：

```cpp
Node* merge(Node* x,Node* y)
{
	if(!x)return y;
	if(!y)return x;
	if(x->w<y->w)
	{
		Node* p=new Node;
		// 我们新建一个结点，并将 x 的信息复制到它身上。
		copy(p,x);
		// 下面是对 p 进行 fhq-Treap 的正常操作
		p->rs=merge(p->rs,y);
		p->pushup();
		return p;
	}
	else
	{
		Node* p=new Node;
		// 同理
		copy(p,y);
		p->ls=merge(x,p->ls);
		p->pushup();
		return p;
	}
}
```

由此可见，对于可持久化 fhq-Treap 的基层操作，每更改一个结点就要分值一个新的结点出来，**否则你修改的就是历史版本上的结点！！！**

---

核心部分就讲到这里，下面给出完整代码。

时间复杂度 $O(n\log n)$，空间复杂度 $O(n\log n)$，常数较大。

写代码时要注意一些 C++ 语言上的细节（因为用的是指针）。

无注释的代码看[这里](https://www.luogu.com.cn/paste/r6mtf9k5)。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstdlib>

const int N=5e5;
const int LOGN=20;
const int INF=2147483647;

struct Node
{
	int v,w;
	Node *ls,*rs;
	int siz;
	
	Node(){}
	
	Node(int _v):v(_v),w(rand()),ls(NULL),rs(NULL),siz(1){}
	
	inline void pushup()
	{
		siz=(ls?ls->siz:0)+(rs?rs->siz:0)+1;
	}
};

typedef std::pair<Node*,Node*> droot;

Node* root[N+10];
int n;

// 以下为卡常部分

#define SIZ 1000000

inline char gc()
{
	static char buf[SIZ],*p1,*p2;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,SIZ,stdin),p1==p2)?EOF:*p1++;
}

#undef SIZ

inline void read(int& x)
{
	x=0;int f=0;char c=gc();
	while(c<'0'||c>'9')f|=(c=='-'),c=gc();
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=gc();
	if(f)x=-x;
}

// @wangrx 大佬教我的卡常技巧：重载 new 运算符
// 下面的话引自 @wangrx
// new 是系统在给你分配内存，速度肯定不敢恭维
// 这么写相当于手动分配内存，但是 delete 就用不了了
// 亲测有用

char pool[1<<30],*ptop=pool+(1<<30);

void* operator new(size_t size)
{
	return ptop-=size;
}

// 以上为卡常部分
// 以下为 fhq-Treap 部分

inline int siz(Node* x)
{
	return x?x->siz:0;
}

inline void copy(Node*& p,Node* x) // 不能直接赋值，而且要引用，否则就和没改一样
{
	p->v=x->v;
	p->w=x->w;
	p->ls=x->ls;
	p->rs=x->rs;
	p->siz=x->siz;
}

droot split(Node* x,int k)
{
	if(!x)return droot(NULL,NULL);
	droot res;
	if(siz(x->ls)>=k)
	{
		res=split(x->ls,k);
		Node* p=new Node;
		copy(p,x);
		p->ls=res.second;
		p->pushup();
		res.second=p;
	}
	else
	{
		res=split(x->rs,k-siz(x->ls)-1);
		Node* p=new Node;
		copy(p,x);
		p->rs=res.first;
		p->pushup();
		res.first=p;
	}
	return res;
}

Node* merge(Node* x,Node* y)
{
	if(!x)return y;
	if(!y)return x;
	if(x->w<y->w)
	{
		Node* p=new Node;
		copy(p,x);
		p->rs=merge(p->rs,y);
		p->pushup();
		return p;
	}
	else
	{
		Node* p=new Node;
		copy(p,y);
		p->ls=merge(x,p->ls);
		p->pushup();
		return p;
	}
}

int queryrk(Node*& rt,int k)
{
	if(!rt)return 0;
	return k<=rt->v?queryrk(rt->ls,k):queryrk(rt->rs,k)+siz(rt->ls)+1;
}

int querykth(Node*& rt,int k) // 要加引用，才能真正修改 rt，以下同理
{
	droot x=split(rt,k-1);
	droot y=split(x.second,1);
	Node* res=y.first;
	rt=merge(merge(x.first,y.first),y.second);
	return res->v;
}

void insert(Node*& rt,int v)
{
	int k=queryrk(rt,v);
	droot x=split(rt,k);
	Node* now=new Node(v);
	rt=merge(merge(x.first,now),x.second);
}

void erase(Node*& rt,int v)
{
	int k=queryrk(rt,v);
	droot x=split(rt,k);
	droot y=split(x.second,1);
	if(y.first->v!=v)return;
	rt=merge(x.first,y.second);
}

int querypre(Node*& rt,int v)
{
	int k=queryrk(rt,v);
	droot x=split(rt,k-1);
	droot y=split(x.second,1);
	Node* res=y.first;
	rt=merge(merge(x.first,y.first),y.second);
	return res->v;
}

int querysuc(Node*& rt,int v)
{
	int k=queryrk(rt,v+1);
	droot x=split(rt,k);
	droot y=split(x.second,1);
	Node* res=y.first;
	rt=merge(merge(x.first,y.first),y.second);
	return res->v;
}

// 以上为 fhq-Treap 部分，没有什么奇奇怪怪的操作对吧

int main()
{
#ifndef ONLINE_JUDGE
	freopen("data.in","r",stdin);
	freopen("data.out","w",stdout);
#endif 
	srand(20070414U);
	read(n);
	insert(root[0],INF);
	insert(root[0],-INF);
	for(int q=1;q<=n;q++)
	{
		int ver,opt,x;
		read(ver),read(opt),read(x);
		root[q]=root[ver]; // 可持久化基本操作
		if(opt==1)insert(root[q],x);
		if(opt==2)erase(root[q],x);
		if(opt==3)printf("%d\n",queryrk(root[q],x)); // 其实是 queryrk(root[q],x)+1-1，注意 +1，-1 的细节问题
		if(opt==4)printf("%d\n",querykth(root[q],x+1)); // 注意 +1，-1 的细节问题
		if(opt==5)printf("%d\n",querypre(root[q],x));
		if(opt==6)printf("%d\n",querysuc(root[q],x));
	}
	return 0;
}
```

---

## 作者：pyqpyq (赞：3)

话说你们是对指针版的主席树有什么意见吗？

为什么题解里面的主席树没一个是用指针的？

那我就发一波吧……

20200121 UPD:更正了一个严重错误
# 大致思路
前置芝士：[主席树](https://www.luogu.com.cn/problem/P3834)

~~众所周知~~权值线段树可以维护一个可重集，并在 $O(logn)$ 的时间复杂度内完成全局第 $k$ 大、前缀和、插入、删除等事情，可以替代一些普通平衡树。

所以我们可以写一棵权值线段树来完成此题。每个节点维护的是当前节点所代表的**数值区间**的数的个数。

由于题目要求可持久化，所以我们可以写主席树节省空间，不必每个操作再建一颗。

数据范围 $|x_i|\le10^9$ 告诉我们要离散化（当然可以写动态开点权值线段树，然而我不会……）
# 代码分析
~~懒得写注释直接讲吧~~
## 变量定义
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	int data;
	node*left,*righ;
}*root[500011];
struct opts
{
	int numb,from,opti,frnu,gonu;
} czli[500011];
int n,a,b,stef[500011];
bool cmp1(opts a,opts b)
{
	return a.frnu<b.frnu;
}
bool cmp2(opts a,opts b)
{
	return a.numb<b.numb;
}
```

```node``` 是权值线段树的节点。```data``` 是此节点维护的**数值**区间内的数的个数，```left``` 和 ```righ``` 是左右子节点的指针。```root``` 是每次操作后树根的指针。

```opts``` 用来离散化。```numb``` 是操作序号，```from```、```opti``` 和 ```frnu``` 是题目给出的 $v_i$、$opt_i$ 和 $x_i$，```gonu``` 是离散化后此结构体代表的数。

```n``` 就是题目给出的 $n$，```a``` 和 ```b``` 是离散化后 ```gonu``` 的最大值和最小值（所以 ```a``` 衡为 $1$），```stef``` 维护每个 ```gonu``` 所代表的 ```frnu```。

```cmp1``` 和 ```cmp2``` 在以后排序中使用。
## 离散化
```cpp
scanf("%d",&n);
for(int i=1; i<=n; czli[i].numb=++i)
	scanf("%d%d%d",&czli[i].from,&czli[i].opti,&czli[i].frnu);
sort(czli+1,czli+n+1,cmp1);
for(int i=1; i<=n; ++i)
	stef[czli[i].gonu=czli[i-1].gonu+(czli[i].frnu!=czli[i-1].frnu)]=czli[i].frnu;
root[0]=build(a=czli[1].gonu,b=czli[n].gonu);
sort(czli+1,czli+n+1,cmp2);
```
~~大家都会吧那我不说了。~~

可能有人会问 ```build``` 是什么，它在后面：
## 建树
```cpp
node*build(int l,int r)
{
	node*s=new node;
	s->data=0;
	if(l==r)
		s->left=s->righ=NULL;
	else if(l!=r)
	{
		s->left=build(l,l+r>>1);
		s->righ=build((l+r>>1)+1,r);
	}
	return s;
}
```
由于一开始可重集里没数，所以这里建了一颗 ```data``` 全是 $0$ 的树。

因为我们的结构体里没存节点代表的**数值**区间，所以这里以及接下来的**数值**区间都由传参的形式给出。
## 操作1&2
```cpp
inline int maxn(int a,int b)
{
	return a>b?a:b;
}
node*opt1_2(node*f,int x,int l,int r,int k)
{
	node*s=new node;
	if(l==x&&x==r)
	{
		s->left=s->righ=NULL;
		s->data=maxn(f->data+k,0);
	}
	else if(l<=x&&x<=l+r>>1)
	{
		s->left=opt1_2(f->left,x,l,l+r>>1,k);
		s->righ=f->righ;
		s->data=s->left->data+s->righ->data;
	}
	else if((l+r>>1)+1<=x&&x<=r)
	{
		s->left=f->left;
		s->righ=opt1_2(f->righ,x,(l+r>>1)+1,r,k);
		s->data=s->left->data+s->righ->data;
	}
	return s;
}
```
我们会发现操作 $1$ 和操作 $2$ 十分像，所以我们可以把它们合并到一起，以 ```k``` 区分，```k``` 为 $1$ 时为操作 $1$，```k``` 为 $-1$ 时为操作 $2$。

第 $1$ 个 ```if``` 处理递归到叶节点，第 $2$ 个 ```else if``` 处理往左子树递归，第 $3$ 个 ```else if``` 处理往右子树递归。（下同）

由于有时操作 $2$ 的数可以不存在，此时 ```s``` 的 ```data``` 为 $0$，所以发现叶节点的 ```data``` 为 $-1$
时要及时赋为 $0$。

```f``` 是原树上的此时要建的节点所对应的节点的指针。不理解的可以看图：
![主席树](https://cdn.luogu.com.cn/upload/image_hosting/kyahf30y.png)

再不理解就去做[模板](https://www.luogu.com.cn/problem/P3834)吧……
## 操作3&4
```cpp
int opt3(node*f,int x,int l,int r)
{
	if(l==x&&x==r)
		return 1;
	else if(l<=x&&x<=l+r>>1)
		return opt3(f->left,x,l,l+r>>1);
	else if((l+r>>1)+1<=x&&x<=r)
		return f->left->data+opt3(f->righ,x,(l+r>>1)+1,r);
}
int opt4(node*f,int x,int l,int r)
{
	if(l==r)
		return l;
	else if(1<=x&&x<=f->left->data)
		return opt4(f->left,x,l,l+r>>1);
	else if(f->left->data+1<=x&&x<=f->data)
		return opt4(f->righ,x-f->left->data,(l+r>>1)+1,r);
}
```
注意 ```opt3``` 的返回值是在以 ```f``` 为根的子树中查询 ```x``` 的排名。 

而且 ```opt4``` 中的 ```x``` 表示的是在以 ```f``` 为根的子树中查找第 $x$ 大的数，而非全局。
## 操作5&6
```cpp
int help(node*f,int x,int l,int r)
{
	if(l==x&&x==r)
		return f->data;
	else if(l<=x&&x<=l+r>>1)
		return help(f->left,x,l,l+r>>1);
	else if((l+r>>1)+1<=x&&x<=r)
		return help(f->righ,x,(l+r>>1)+1,r);
}
int opt5(node*f,int x,int l,int r)
{
	int s=opt3(f,x,l,r)-1;
	if(s==0)
		return INT_MIN;
	else
		return opt4(f,s,l,r);
}
int opt6(node*f,int x,int l,int r)
{
	int s=opt3(f,x,l,r)-1,p=help(f,x,l,r);
	if(s==r)
		return INT_MAX;
	else
		return opt4(f,s+p+1,l,r);
}
```
```help``` 用来找 ```x``` 出现了多少次。

具体思路是找到此数的排名，然后返回比它排名小或大的数。

（话说我刚开始把操作 $6$ 写成[这样](https://www.luogu.com.cn/record/30259012)和[这样](https://www.luogu.com.cn/record/30297820)$AC$了？管理加强一下数据吧……）
## 汇总
```cpp
int k;
for(int i=1; i<=n; ++i)
{
	if(czli[i].opti==1)
		root[i]=opt1_2(root[czli[i].from],czli[i].gonu,a,b,1);
	else if(czli[i].opti==2)
		root[i]=opt1_2(root[czli[i].from],czli[i].gonu,a,b,-1);
	else if(czli[i].opti==3)
		printf("%d\n",opt3(root[i]=root[czli[i].from],czli[i].gonu,a,b));
	else if(czli[i].opti==4)
		printf("%d\n",stef[opt4(root[i]=root[czli[i].from],czli[i].frnu,a,b)]);
	else if(czli[i].opti==5)
		printf("%d\n",(k=opt5(root[i]=root[czli[i].from],czli[i].gonu,a,b))==INT_MIN?INT_MIN:stef[k]);
	else if(czli[i].opti==6)
		printf("%d\n",(k=opt6(root[i]=root[czli[i].from],czli[i].gonu,a,b))==INT_MAX?INT_MAX:stef[k]);
}
```
也不用说了吧。

注意操作 $4$ 的 $x$ 是 ```frnu``` 而不是 ```gonu``` ，我就在这被坑了。（其实操作 $4$ 压根不用离散化，只是我懒不想单独拿出来。）
# 最后
完整代码请自己把上面的合起来，这里不放了。

指针的优点是符合自然语言习惯，使用方便（至少我这么觉得）。

缺点是用 ```new``` 开节点常数大（听说），但过这道板子绰绰有余了。（我管最慢点 $1.67s$ 叫绰绰有余？）

完结撒花\\(^o^)/ 

---

## 作者：xzz_cat6 (赞：2)

[这里有 AVL 全家桶](https://www.luogu.com.cn/article/3wq2o5fy)

# 【模板】可持久化平衡树
本文将介绍 AVL 树的基础操作，和可持久化。

在读本文之前，默认读者已经会 BST（二叉搜索树）的全部操作。
## 基础部分
如果你会 AVL 树的基础操作，请跳过此部分。
### AVL 树的定义与性质
1. 空二叉树是一个 AVL 树。
   
2. 如果 T 是一棵 AVL 树，那么其左右子树也是 AVL 树，并且 $|h(ls) - h(rs)| \leq 1$，h 是其左右子树的高度。
 
3. 树高为 $O(\log n)$。

4. 定义平衡因子 $BF=h(ls) - h(rs)$。

5. 一个树平衡，当且仅当这个树满足性质 3。

由于性质二，其在实现二叉搜索树时，时间复杂度为对数级别的，下文有详细证明。
### AVL 树的平衡维护
AVL 树为了保证性质二，利用旋转操作维护平衡，这也是其与 BST 唯一的不同点。
#### 旋转
```rotate()``` 操作是把某个给定节点上移一个位置，并保证**二叉搜索树**的性质不改变（如下图），建议参照代码理解。

![](https://oi-wiki.org/ds/images/splay-rotate.svg)

```cpp
void rotate(int &u,bool f){
  int v=ch[u][f];
  ch[u][f]=ch[v][!f];
  ch[v][!f]=u;
  pushup(u),pushup(v),u=v;
}
```
#### 维护平衡
如果对于某一个节点，性质 2 不再满足，由于我们每次只插入/删除一个节点，对树高的影响不超过 1，因此该节点的平衡因子的绝对值至多为 2。由于对称性，我们在此只讨论左子树的高度比右子树大 2 的情况，即下图中 $h(B)-h(E)=2$。此时，还需要根据 $h(D)$ 和 $h(C)$ 的大小关系分两种情况讨论。需要注意的是，由于我们是自底向上维护平衡的，因此对节点 D 的所有后代来说，性质 2 仍然是被满足的。

![](https://cdn.luogu.com.cn/upload/image_hosting/pzdjy1oj.png)

情况 1：如上图，发现 D 的树高比 C 的树高大，此时只需要旋转 B 到 A 处，即左旋 A。旋转完后如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/tyuen1qz.png)

---

![](https://cdn.luogu.com.cn/upload/image_hosting/pf0xgvc5.png)

情况 2：如上图，发现 D 的树高比 C 的树高要小，手模一下发现不能直接左旋 A，否则仍然不平衡。此时需要先右旋 B，再左旋 A，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/btiq846d.png)

代码：
```cpp
void maintain(int &u){
    int chk=BF(u);
    if(chk>1){
      if(BF(ls(u))<=0)	rotate(ls(u),1);
      rotate(u,0);
    }
    else if(chk<-1){
      if(BF(rs(u))>=0)	rotate(rs(u),0);
      rotate(u,1);
    }
    else if(u)	pushup(u);
}
```
### 基本操作
#### 变量和宏定义

建议先跳过此部分，后文中遇到了变量再来这里对照。
|变量名|含义|
|:-:|:-:|
| $rt$ |根|
| $tot$ |节点数|
| $ls,ch[0]$ |左儿子|
| $rs,ch[1]$ |右儿子|
| $siz$ |子树内节点个数|
| $h$ |子树树高|
| $val$ |节点权值|
| $BF$ |子树平衡因子|

#### 新建空节点
空节点权值为 $x$。
```cpp
int newnode(int x){
    int u=++tot;
    val[u]=x,siz[u]=h[u]=1,ls(u)=rs(u)=0;
    return u;
}
```
#### 维护父节点信息
```cpp
void pushup(int u){
		siz[u]=siz[ls(u)]+siz[rs(u)]+1;
		h[u]=max(h[ls(u)],h[rs(u)])+1;
}
```
#### 旋转
即上文的 ```rotate()``` 和 ```maintain()``` 函数。
#### 插入节点
与 BST（二叉搜索树）的插入操作基本相同，只不过要用递归实现，每次插入后维护平衡。当我们插入一个节点，如果这个点的权值大于当前点的权值，就要去搜索右子树，反之搜索左子树。
```cpp
void insert(int &u,int w){
    if(!u)	return void(u=newnode(w));
    if(val[u]<w)	insert(rs(u),w);
    else	insert(ls(u),w);
    maintain(u);//维护平衡
}
```
#### 删除节点
先找到这个节点，之后如果删除节点最多有一个儿子，那么我们用它的儿子顶替它，否则和后继交换，返回时维护平衡。
```cpp
void del(int &u,int w){
    if(!u)	return;
    if(val[u]==w){
      int v=u;
      if(ls(u)&&(v=rs(u))){
        while(ls(v))	v=ls(v);
        val[u]=val[v],del(rs(u),val[v]);
      }
      else	u=ls(u)?ls(u):rs(u);
    }
    else if(val[u]<w)	del(rs(u),w);
    else	del(ls(u),w);
    maintain(u);
}
```
#### 查询第k小
等价于 BST，只需要判断出当前排名在树的哪个部分即可，类似于权值线段树。
```cpp
int kth(int x){
    int u=rt,tmp=0;
    while(u){
      if((tmp=siz[ls(u)]+1)==x)	return val[u];
      else	u=((tmp>x)?ls(u):(x-=tmp,rs(u)));
    }
    return -1;
}
```
#### 查询排名
等价于 BST，直接计算该子树中小于 $val$ 的节点个数加一。
```cpp
int qrk(int x){
    int ans=1,u=rt;
    while(u){
      if(val[u]<x)	ans+=siz[ls(u)]+1,u=rs(u);
      else	u=ls(u);
    }
    return ans;
}
```
#### 查询前驱和后继
利用二叉搜索树的性质求即可，类似于线段树二分。
```cpp
int pre(int x){
    int u=rt,ans=1-(1<<31);
    while(u){
      if(val[u]>=x)	u=ls(u);
      else	ans=val[u],u=rs(u);
    }
    return ans;
}
int nxt(int x){
    int u=rt,ans=(1<<31)-1;
    while(u){
      if(val[u]<=x)	u=rs(u);
      else	ans=val[u],u=ls(u);
    }
    return ans;
}
```
到这里就可以做一道[模板题](https://www.luogu.com.cn/problem/P3369)了，如果还不会建议先敲一遍，[代码](https://note.ms/jdioqwhfwifgigfieqofgeripqgfeiwfreq)。

### 复杂度证明
设 $f_n$ 为高度为 $n$ 的 AVL 树所包含的最少节点数，则有
$$ 
f_n=
\begin{cases}
1&(n=1)\\
2&(n=2)\\
f_{n-1}+f_{n-2}+1& (n>2)
\end{cases}
$$
根据常系数非齐次线性差分方程的解法，$\{f_n+1\}$ 是一个斐波那契数列。这里 $f_n$ 的通项为： 
$$
f_n=\frac{5+2\sqrt{5}}{5}\left(\frac{1+\sqrt{5}}{2}\right)^n+\frac{5-2\sqrt{5}}{5}\left(\frac{1-\sqrt{5}}{2}\right)^n-1
$$
斐波那契数列以指数的速度增长。对于树高 $n$ 有：
$$
n<\log_{\frac{1+\sqrt{5}}{2}} (f_n+1)<\frac{3}{2}\log_2 (f_n+1)
$$
因此 AVL 树的高度为 $O(\log f_n)$，这里的 $f_n$ 为结点数。

## 可持久化
考虑每一个修改操作之后新建一颗平衡树，那么此时只需要在查询对应的平衡树上查询，这样子保证了正确性，但是时空复杂度均爆炸。

考虑到有很多的节点其实不参与修改，节点维护的信息也不发生变化，于是对于这样的节点，直接继承信息，如下图，假设 $A$ 是新插入节点。

![](https://cdn.luogu.com.cn/upload/image_hosting/s0x4qlfz.png)

于是每当要改变树的形态时，比如：改变子树大小，子树高度，标记和左右子树时，就复制一份节点。以插入为例，注释行即为复制操作，由于树高是对数级别的，所以每次只会新建对数级别的点。

# Code
```cpp
#include<bits/stdc++.h>
#define N 500005
using namespace std;
int q,rt[N];
struct operate{
	#define BF(u) (h[ch[u][0]]-h[ch[u][1]])
	#define ls(u) (ch[u][0])
	#define rs(u) (ch[u][1])
	int tot,ch[N<<5][2],siz[N<<5],val[N<<5],h[N<<5];
	int newnode(int x){
		int u=++tot;
		val[u]=x,siz[u]=h[u]=1,ls(u)=rs(u)=0;
		return u;
	}
	int copy(int x){
		int u=++tot;
		val[u]=val[x],siz[u]=h[u]=siz[x],ls(u)=ls(x),rs(u)=rs(x);
		return u;
	}
	void pushup(int u){
		siz[u]=siz[ls(u)]+siz[rs(u)]+1;
		h[u]=max(h[ls(u)],h[rs(u)])+1;
	}
	void rotate(int &u,bool f){
		int v=copy(ch[u][f]);
		ch[u][f]=ch[v][!f];
		ch[v][!f]=u;
		pushup(u),pushup(v),u=v;
	}
	void maintain(int &u){
		int chk=BF(u);
		if(chk>1){
			if(BF(ls(u))<=0)	rotate(ls(u),1);
			rotate(u,0);
		}
		else if(chk<-1){
			if(BF(rs(u))>=0)	rotate(rs(u),0);
			rotate(u,1);
		}
		else if(u)	pushup(u);
	}
	void insert(int &u,int w){
		if(!u)	return void(u=newnode(w));
		else	u=copy(u);
		if(val[u]<w)	insert(rs(u),w);
		else	insert(ls(u),w);
		maintain(u);
	}
	void del(int &u,int w){
		if(!u)	return;
		u=copy(u);
		if(val[u]==w){
			int v=u;
			if(ls(u)&&(v=rs(u))){
				while(ls(v))	v=ls(v);
				val[u]=val[v],del(rs(u),val[v]);
			}
			else	u=ls(u)?ls(u):rs(u);
		}
		else if(val[u]<w)	del(rs(u),w);
		else	del(ls(u),w);
		maintain(u);
	}
	int kth(int u,int x){
		int tmp=0;
		while(u){
			if((tmp=siz[ls(u)]+1)==x)	return val[u];
			else	u=((tmp>x)?ls(u):(x-=tmp,rs(u)));
		}
		return -1;
	}
	int qrk(int u,int x){
		int ans=1;
		while(u){
			if(val[u]<x)	ans+=siz[ls(u)]+1,u=rs(u);
			else	u=ls(u);
		}
		return ans;
	}
	int pre(int u,int x){
		int ans=1-(1<<31);
		while(u){
			if(val[u]>=x)	u=ls(u);
			else	ans=val[u],u=rs(u);
		}
		return ans;
	}
	int nxt(int u,int x){
		int ans=(1<<31)-1;
		while(u){
			if(val[u]<=x)	u=rs(u);
			else	ans=val[u],u=ls(u);
		}
		return ans;
	}
}T;
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>q;
	for(int i=1;i<=q;i++){
		int op,x,id;
		cin>>id>>op>>x,rt[i]=rt[id];
		switch(op){
			case 1:T.insert(rt[i],x);break;
			case 2:T.del(rt[i],x);break;
			case 3:cout<<T.qrk(rt[i],x)<<'\n';break;
			case 4:cout<<T.kth(rt[i],x)<<'\n';break;
			case 5:cout<<T.pre(rt[i],x)<<'\n';break;
			case 6:cout<<T.nxt(rt[i],x)<<'\n';break;
		}
	}
	return 0;
}
```

---


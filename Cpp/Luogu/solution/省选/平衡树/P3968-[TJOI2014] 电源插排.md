# [TJOI2014] 电源插排

## 题目描述

小 M 的实验室有很多电源插排。这些插排的编号从 $1$ 到 $n$，由左向右排成一排。

每天早晨，这些插排都是没有被使用的。每当一个学生来到实验室，他就将自己的笔记本电源插到某一个未被使用的插排上。

实验室的同学们都很奇怪，他们完成这个过程是这样的：首先，他们找到还没有被使用的插排的最长区间。

如果有多个区间长度相同，他们就选择最靠右的那个。然后将自己的电源插到该区间的中间。

如果区间长度是偶数，他们同样选择靠右的那个。当一个同学离开实验室时,他会将自己的电源拔出来。

数据保证每一个同学来到实验室时，至少有一个空的插排。

需要计算在区间 $[l,r]$ 已经有多少个插排被使用了。

## 说明/提示

#### 数据规模与约定

对于 $30\%$ 的数据，$n \le 10^5，q \le 10^3$；

对于 $100\%$ 的数据，$1\le n \le 10^9,1\le q \le 10^5,0\le k \le 10^9,1\le l\le r\le n$。

## 样例 #1

### 输入

```
7 10
1
2
3
0 1 2
0 4 7
0 2 5
20
0 6 6
99
0 4 6```

### 输出

```
1
2
2
1
3```

# 题解

## 作者：Froggy (赞：9)

set,动态开点线段树¿¿¿ 为什么不挑战一下动态开点 $\operatorname{FHQ \ Treap}$ ¿¿¿

这样写代码难度很高,但未尝不是锻炼代码能力的一种方法, [大雾]
~~(珂能我写复杂了,常数巨大,吸氧才过)~~

其实这道题csp2019前一天就写了一上午,写呱了,心态炸了,期末考试完了拐回头重构代码,终于A了

---

由于是动态开点平衡树,所以每个节点记录一个区间 $(l,r)$

`len` 为该节点代表的区间长度,即 $r-l+1$

`siz` 为以该节点为根的子树所构成的区间大小 **(注意区分上面两个,否则写着写着就混淆了)**


### 询问操作

好办,`val` 记录该节点被使用的插排个数, `sum` 以该节点为根的子树被使用的插排个数

更新节点信息的时候这样就好了

```
t[k].siz=t[ls].siz+t[rs].siz+t[k].len;
t[k].sum=t[ls].sum+t[rs].sum+t[k].val;
```

询问的时候把区间分裂出来输出sum

---

重点是----

### 插入/删除操作

要找到长度最大的连续一段空插座 $(mxl,mxr)$

需要维护 `maxlen` 即 $mxr-mxl+1$

和要插的位置`mid` 即 $(mxl+mxr+1)/2$

如果维护了这两个,那么就不需要维护`mxl`和`mxr`了.

`lmax`和`rmax`,即最左/右边连续空插座的个数

举个例子:

比如一段插座长这样:(1表示有电源插入,0表示空)

`110100001000`

那么lmax=0, rmax=3, maxlen=4 ,mid=(5+8+1)/2

要插入的位置就很显然了: `t[root].mid`

还需要开个`map::vis`方便下一次删除

现在考虑如何维护:

维护`lmax`和`rmax`很套路,不说了

分别取左右子树的maxlen的最大值

当`t[k].val==0`的时候还要特殊讨论:

跨节点k的一段空插座长度为 `t[k].len+t[ls].rmax+t[rs].lmax`

更新一下就好了啦~

```cpp
inline void update(int k){
	#define ls t[k].ch[0]
	#define rs t[k].ch[1]
	t[k].siz=t[ls].siz+t[rs].siz+t[k].len;
	t[k].maxlen=0;
	t[k].sum=t[ls].sum+t[rs].sum+t[k].val;
	t[k].lmax=t[ls].lmax;
	t[k].rmax=t[rs].rmax;
	if(ls){//从左子树更新
		t[k].maxlen=t[ls].maxlen;
		t[k].mid=t[ls].mid;
	}
	if(t[k].val==0){ //跨左右子树讨论
		if(t[ls].sum==0){
			t[k].lmax=t[ls].lmax+t[k].len+t[rs].lmax;
		}
		if(t[rs].sum==0){
			t[k].rmax=t[ls].rmax+t[k].len+t[rs].rmax;
		}
		int len=t[k].len+t[ls].rmax+t[rs].lmax;
		if(len>=t[k].maxlen){
			t[k].maxlen=len;
			t[k].mid=(t[k].l-t[ls].rmax+t[k].r+t[rs].lmax+1)>>1;
		}
	}
	if(t[rs].maxlen>=t[k].maxlen){ //从右子树更新
		t[k].maxlen=t[rs].maxlen;
		t[k].mid=t[rs].mid;
	}
	#undef ls
	#undef rs
}
```

*code:*

```cpp
#include<iostream>
#include<cstdio>
#include<map>
#include<cstdlib>
using namespace std;
#define N 100010
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    return x*f;
}
map<int,int> mp,vis;
int n,Q,root,cnt;
struct node{
	int ch[2],key,l,r,val,sum,siz,len;
	int mid,lmax,rmax,maxlen;
}t[N<<3];
inline int NewNode(int l,int r){
	int k=++cnt;
	t[k].key=rand();
	t[k].l=l,t[k].r=r;
	t[k].mid=(l+r+1)>>1;
	t[k].ch[0]=t[k].ch[1]=0;
	t[k].val=t[k].sum=0;
	t[k].maxlen=t[k].siz=t[k].len=t[k].lmax=t[k].rmax=r-l+1;
	mp[r]=k;
	return k; 
}
inline void update(int k){
	#define ls t[k].ch[0]
	#define rs t[k].ch[1]
	t[k].siz=t[ls].siz+t[rs].siz+t[k].len;
	t[k].maxlen=0;
	t[k].sum=t[ls].sum+t[rs].sum+t[k].val;
	t[k].lmax=t[ls].lmax;
	t[k].rmax=t[rs].rmax;
	if(ls){
		t[k].maxlen=t[ls].maxlen;
		t[k].mid=t[ls].mid;
	}
	if(t[k].val==0){
		if(t[ls].sum==0){
			t[k].lmax=t[ls].lmax+t[k].len+t[rs].lmax;
		}
		if(t[rs].sum==0){
			t[k].rmax=t[ls].rmax+t[k].len+t[rs].rmax;
		}
		int len=t[k].len+t[ls].rmax+t[rs].lmax;
		if(len>=t[k].maxlen){
			t[k].maxlen=len;
			t[k].mid=(t[k].l-t[ls].rmax+t[k].r+t[rs].lmax+1)>>1;
		}
	}
	if(t[rs].maxlen>=t[k].maxlen){
		t[k].maxlen=t[rs].maxlen;
		t[k].mid=t[rs].mid;
	}
	#undef ls
	#undef rs
}
int Merge(int l,int r){
	if(!l||!r)return l+r;
	if(t[l].key<t[r].key){
		t[l].ch[1]=Merge(t[l].ch[1],r);
		update(l);
		return l;
	}
	else{
		t[r].ch[0]=Merge(l,t[r].ch[0]);
		update(r);
		return r;
	}
}
void Split(int k,int data,int &l,int &r){
	if(!k){
		l=r=0;
		return;
	}
	if(t[k].r<=data){
		l=k;
		Split(t[k].ch[1],data,t[k].ch[1],r);
	}
	else{
		r=k;
		Split(t[k].ch[0],data,l,t[k].ch[0]);
	}
	update(k);
}
inline void New(int pos){
	int k=mp.lower_bound(pos)->second;
	int x=t[k].l,y=t[k].r;
	if(x==y&&x==pos)return;
	int l,p,r;
	Split(root,y,l,r);
	Split(l,x-1,l,p);
	mp.erase(t[k].r);
	if(pos>x){
		l=Merge(l,NewNode(x,pos-1));
	}
	if(y>pos){
		r=Merge(NewNode(pos+1,y),r);
	} 
	root=Merge(Merge(l,NewNode(pos,pos)),r);
}
inline int Query(int x,int y){
	New(x),New(y);
	int l,p,r;
	Split(root,y,l,r);
	Split(l,x-1,l,p);
	int ans=t[p].sum;
	root=Merge(Merge(l,p),r);
	return ans;
}
inline void Delete(int pos){
	int l,p,r;
	Split(root,pos,l,r);
	Split(l,pos-1,l,p);
	t[p].val=t[p].sum=0;
	t[p].mid=pos,t[p].maxlen=t[p].lmax=t[p].rmax=t[p].len;
	root=Merge(Merge(l,p),r);
}
inline void Change(int pos){
	New(pos);
	int l,p,r;
	Split(root,pos,l,r);
	Split(l,pos-1,l,p);
	t[p].val=t[p].sum=1;
	t[p].mid=t[p].maxlen=t[p].lmax=t[p].rmax=0;
	root=Merge(Merge(l,p),r);
}
int main(){
	n=read(),Q=read();
	root=NewNode(1,n);
	while(Q--){
		int x=read();
		if(x==0){
			int l=read(),r=read();
			printf("%d\n",Query(l,r));
		}
		else{
			if(vis.count(x)){
				Delete(vis[x]);
				vis.erase(x);
			}
			else{
				vis[x]=t[root].mid;
				Change(t[root].mid);
			}
		}
	}
	return 0;
}
```

[*Froggy's blog*](https://www.luogu.org/blog/1445353309froggy/)

#### 呱!!






---

## 作者：pikabi (赞：9)

平衡树大法好！

这里我使用码量小~~写の香~~的 Fhq_Treap.



------------


题面已经讲得很清楚了，每次修改某一节点上的状态，并查询区间内状态为 $1$ 的节点个数，我们曰此状态为 $ok$ .

看到 $n_{max} = 10^9$，我们不免联想到[NOIp D2 T3 列队](https://www.luogu.com.cn/problem/P3960) ，**其思想也正是裂开区间**。所以我们保存每一个区间的左右端点，为 $l\_loc$ 和 $r\_loc$ ，并保存长度为 $len$ . 初始只有一个节点，其 $l\_loc$ 和 $r\_loc$ 分别为 $1$ 和 $n$ 。用 $Split\_New$ 来使当前区间裂为两个区间-->

```cpp
inline void Split_New(int p, int now){//p为当前节点的位置，now为目标到左端点的距离
	if(a[p].len <= now) return ; //包含在右端点中，直接退出
	int u = a[p].l_loc + now - 1;//裂之
	int v = New(u + 1, a[p].r_loc );
	a[p].r_loc = u;
	a[p].len = now;
	a[p].mid = (a[p].l_loc + a[p].r_loc + 1) >> 1;
	a[p].r = Merge(v, a[p].r );
	update(p);
}
```


解题的关键在于**如何维护下一次将要被占用的节点**。看到这里我们不免联想到[P2042 [NOI2005]维护数列](https://www.luogu.com.cn/problem/P2042)。用 $l\_maxn$ ，$ r\_maxn$ 分别保存以之为其根节点 $ok$ 为 0 最长前缀长度和后缀长度， $maxn$ 保存其最长总长度，**每次选取最长的 $maxn$ 继承或更新将要被占用的节点**，用 $to\_loc$ 来保存。同时被占用的节点总数都可以用 $tot$ 来保存。这些操作都可在 update 中被完成-->

```cpp
inline void update(int p){
	if(!p) return ;
	a[p].size = a[a[p].l ].size + a[a[p].r ].size + a[p].len ;
	a[p].maxn = 0;
	a[p].tot = a[a[p].l ].tot + a[a[p].r ].tot + a[p].ok ;
	a[p].l_maxn = a[a[p].l ].l_maxn ;
	a[p].r_maxn = a[a[p].r ].r_maxn ;
	if(a[p].l){
		a[p].maxn = a[a[p].l ].maxn;
		a[p].to_loc = a[a[p].l ].to_loc ;
	}
	if(!a[p].ok ){
		if(!a[a[p].l ].tot )
		a[p].l_maxn = a[a[p].l ].l_maxn + a[p].len + a[a[p].r ].l_maxn ;
		if(!a[a[p].r ].tot )
		a[p].r_maxn = a[a[p].r ].r_maxn + a[p].len + a[a[p].l ].r_maxn;
		int len = a[p].len + a[a[p].l ].r_maxn + a[a[p].r ].l_maxn ;
		if(len >= a[p].maxn ){
			a[p].maxn = len;
			a[p].to_loc = (a[p].l_loc - a[a[p].l ].r_maxn + a[p].r_loc + a[a[p].r ].l_maxn + 1 ) >> 1;
		}
	}
	if(a[a[p].r ].maxn >= a[p].maxn ){
		a[p].maxn = a[a[p].r ].maxn;
		a[p].to_loc = a[a[p].r ].to_loc ;
	}
}
```

其余均用 Fhq_Treap 正常操作即可。

code -->

```cpp
#include <cstdio>
#include <map>
#include <algorithm>
#include <ctime>
#include <cctype>
#include <cstdlib>
#define PT 520

using namespace std;

struct node{
	int l, r;
	int dat, size;
	int l_loc, r_loc, val, ok;
	int l_maxn, r_maxn, maxn;
	int tot, to_loc, len;
}a[1000006];

map <int, int> ma;

int n, q, rt, tot, x, y, z;

int read() {        
    int s = 0, f = 1;        
    char ch = getchar();        
    while(!isdigit(ch)) {        
        if(ch == '-') f = -1;        
        ch = getchar();        
    }        
    while(isdigit(ch)) {        
        s = s * 10 + ch - '0';        
        ch = getchar();        
    }        
    return s * f;        
}        

inline void update(int p){
	if(!p) return ;
	a[p].size = a[a[p].l ].size + a[a[p].r ].size + a[p].len ;
	a[p].maxn = 0;
	a[p].tot = a[a[p].l ].tot + a[a[p].r ].tot + a[p].ok ;
	a[p].l_maxn = a[a[p].l ].l_maxn ;
	a[p].r_maxn = a[a[p].r ].r_maxn ;
	if(a[p].l){
		a[p].maxn = a[a[p].l ].maxn;
		a[p].to_loc = a[a[p].l ].to_loc ;
	}
	if(!a[p].ok ){
		if(!a[a[p].l ].tot )
		a[p].l_maxn = a[a[p].l ].l_maxn + a[p].len + a[a[p].r ].l_maxn ;
		if(!a[a[p].r ].tot )
		a[p].r_maxn = a[a[p].r ].r_maxn + a[p].len + a[a[p].l ].r_maxn;
		int len = a[p].len + a[a[p].l ].r_maxn + a[a[p].r ].l_maxn ;
		if(len >= a[p].maxn ){
			a[p].maxn = len;
			a[p].to_loc = (a[p].l_loc - a[a[p].l ].r_maxn + a[p].r_loc + a[a[p].r ].l_maxn + 1 ) >> 1;
		}
	}
	if(a[a[p].r ].maxn >= a[p].maxn ){
		a[p].maxn = a[a[p].r ].maxn;
		a[p].to_loc = a[a[p].r ].to_loc ;
	}
}

inline int New(int l, int r){
	a[++tot].dat = rand();
	a[tot].l_loc = l;
	a[tot].r_loc = r;
	a[tot].ok = a[tot].tot = 0;
	a[tot].len = a[tot].size = r - l + 1;
	update(tot);
	return tot;
}

inline int Merge(int xx, int yy){
	if(!xx || !yy) return xx + yy;
	if(a[xx].dat < a[yy].dat ){
		a[xx].r = Merge(a[xx].r , yy);
		update(xx);
		return xx;
	}
	a[yy].l = Merge(xx, a[yy].l );
	update(yy);
	return yy;
}

inline void Split_New(int p, int now){
	if(a[p].len <= now) return ;
	int u = a[p].l_loc + now - 1;
	int v = New(u + 1, a[p].r_loc  );
	a[p].r_loc = u;
	a[p].len = now;
	a[p].to_loc = (a[p].l_loc + a[p].r_loc + 1) >> 1;
	a[p].r = Merge(v, a[p].r );
	update(p);
}

inline void Split(int p, int now, int &x, int &y){
	if(!p) x = y = 0;
	else {
		if(a[a[p].l ].size >= now){
			y = p;
			Split(a[p].l , now, x, a[p].l );
		}
		else {
			Split_New(p, now - a[a[p].l ].size );
			x = p;
			Split(a[p].r , now - a[a[p].l ].size - a[p].len , a[p].r, y);
		}
		update(p);
	}
}

int main(){
	srand((unsigned)time(0));
	n = read(), q = read();
	rt = New(1, n);
	a[rt].to_loc = (2 + n) >> 1;
	for(int i = 1; i <= q; i++){
		int k;
		k = read();
		if(!k){
			int u, v;
			u = read(), v = read();
			Split(rt, v, x, z);
			Split(x, u - 1, x, y);
			printf("%d\n",a[y].tot );
			rt = Merge(Merge(x, y), z);
		}
		else {
			if(ma.count(k) ){
				int u = ma[k];
				ma.erase(k); 
				Split(rt, u, x, z);
				Split(x, u - 1, x, y);
				a[y].ok = 0;
				a[y].tot = 0;
				a[y].to_loc = u;
				a[y].maxn = a[y].l_maxn = a[y].r_maxn = a[y].len ;
				rt = Merge(x, Merge(y, z));
			}
			else {
				int u = a[rt].to_loc ;
				ma[k] = u;
				Split(rt, u, x, z);
				Split(x, u - 1, x, y);
				a[y].ok = 1;
				a[y].tot = 1;
				a[y].to_loc = a[y].maxn = a[y].l_maxn = a[y].r_maxn = 0;
				rt = Merge(x, Merge(y, z));
			}
		}
	}
} 
```

如果~~打得太丑被卡~~，那就开O2或者用hash替掉map吧！

完结撒花✿✿ヽ(°▽°)ノ✿

---

## 作者：ycyaw (赞：8)

$update:$ 修改了代码，修正了代码在某些数据下会$RE$的情况。

只能说$STL$大法吼啊！

对于插入操作，用一个$multiset$，以$len$为第一关键字，右端点$r$为第二关键字排序，直接取出$begin()$即可，然后把分裂所得的左右两端重新加入。

对于删除操作，记录一下这个编号上一次插入进来的位置，我们再开一个以左端点$l$为关键字的$multiset$，然后$multiset$内二分找到该位置左右的两端区间然后合并，再插入$multiset$即可。

注意，我们操作了其中一个$multiset$，另一个中的元素也要更新，时刻保持两个$multiset$内元素相同。删除操作直接用$multiset$的$erase$和$find$函数。

对于输出答案，我是把询问以及操作离线下来，然后离散化用树状数组计算，实现也比较方便。

代码中$s1,node1$是上述第一个$multiset$，$s2,node2$是上述第二个$multiset$。

$Code \ Below:$
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define int long long
#define hh puts("")
#define pc putchar
#define ite multiset<node2>::iterator
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
//char buf[1<<21],*p1=buf,*p2=buf;
using namespace std;
const int N=1000005;
int n,m,q,tr[N],tot,b[N],cnt,top;
struct node1{
    int l,r,len;
    friend bool operator < (node1 A,node1 B){
        return A.len>B.len||(A.len==B.len&&A.r>B.r);
    }
};
struct node2{
    int l,r,len;
    friend bool operator < (node2 A,node2 B){
        return A.l<B.l;
    }
};
struct work{
    int pos,v,tm;
}a[N];
struct que{
    int l,r,tm;
}qs[N];
multiset<node1> s1;
multiset<node2> s2;
map<int,int> ma;
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=(ret<<3)+(ret<<1)+ch-'0';ch=getchar();}
    return ret*ff;
}
void write(int x){if(x<0){x=-x,pc('-');}if(x>9) write(x/10);pc(x%10+48);}
void writeln(int x){write(x),hh;}
void writesp(int x){write(x),pc(' ');}
int lowbit(int x){
    return x&(-x);
}
void add(int x,int v){
    while(x<=m){
        tr[x]+=v;
        x+=lowbit(x);
    }
}
int query(int x){
    int res=0;
    while(x){
        res+=tr[x];
        x-=lowbit(x);
    }
    return res;
}
signed main(){
    n=read(),q=read();
    s1.insert((node1){1,n,n});
    s2.insert((node2){1,n,n});
    for(int i=1;i<=q;i++){
        int x=read();
        if(x==0){
            int l=read(),r=read();
            b[++cnt]=l,b[++cnt]=r;
            qs[++tot]=(que){l,r,i};
        }
        else{
            if(ma[x]){
                int pos=ma[x];
                a[++top]=(work){pos,-1,i};
                ma[x]=0;
                ite R=s2.upper_bound((node2){pos,0,0});
                ite L=--R;
                ++R;
                node2 LL=*L,RR=*R;
                node2 nw=(node2){LL.l,RR.r,RR.r-LL.l+1};
                s2.erase(R);
                s2.erase(L);
                s2.insert(nw);
                s1.erase(s1.find((node1){LL.l,LL.r,LL.len}));
                s1.erase(s1.find((node1){RR.l,RR.r,RR.len}));
                s1.insert((node1){nw.l,nw.r,nw.len});
            }
            else{
                node1 t=*s1.begin();
                s1.erase(s1.find(t));
                s2.erase(s2.find((node2){t.l,t.r,t.len}));
                int l=t.l,r=t.r,mid=(l+r+1)/2;
                ma[x]=mid;
                b[++cnt]=mid;
                a[++top]=(work){mid,1,i};
                s1.insert((node1){l,mid-1,mid-l});
                s1.insert((node1){mid+1,r,r-mid});
                s2.insert((node2){l,mid-1,mid-l});
                s2.insert((node2){mid+1,r,r-mid});
            }
        }
    }
    sort(b+1,b+cnt+1);
    m=unique(b+1,b+cnt+1)-b-1;
    int now=1;
    for(int i=1;i<=tot;i++){
        while(now<=top&&a[now].tm<=qs[i].tm){
            a[now].pos=lower_bound(b+1,b+m+1,a[now].pos)-b;
            add(a[now].pos,a[now].v);
            now++;
        }
        qs[i].l=lower_bound(b+1,b+m+1,qs[i].l)-b;
        qs[i].r=lower_bound(b+1,b+m+1,qs[i].r)-b;
        writeln(query(qs[i].r)-query(qs[i].l-1));
    }
    return 0;
}
```


---

## 作者：GNAQ (赞：4)

~~楼上几位太菜了~~ 我可以纯动态开点线段树

线段树上维护一下当前结点代表的区间的

1. 左面最长连续段

2. 右面最长连续段

3. 中间最长连续段（注意是严格中间，不包含 [1] [2]）并且记录这个连续段在哪里 ( `lpos` , `rpos` )

然后合并结点就是大讨论

再顺便记一下这个结点里面有多少激活的插头。回答要用。

然后插入的时候对线段树根节点的 [1] [2] [3] 按照大小再次大讨论即可。

然后就是这种数据结构，剩下没啥好讲的，实现上的细节没法细讲，看代码吧（捂脸

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<map>
#define ll long long
using namespace std;

int n,m,opt;
map<int,int> show;

template<typename int_t>
void readx(int_t& x)
{
	x=0; int_t k=1; char ch=0;
	while (ch<'0' || ch>'9') { ch=getchar(); if (ch=='-') k=-1; }
	while (ch>='0' && ch<='9') { x=x*10+ch-'0'; ch=getchar(); }
	x*=k;
}

namespace SGT
{
	#define LCH tree[inx].ch[0]
	#define RCH tree[inx].ch[1]
	
	struct Seg_Tree
	{
		int ch[2],val;
		int lsiz,rsiz,msiz;
		int lpos,rpos;
		
		Seg_Tree() { val=rsiz=msiz=lpos=rpos=ch[0]=ch[1]=0; }
		
	}tree[2200010];
	int lx,rx,_pos,_val,tsiz,root=1;
	
	Seg_Tree Empty_Node(int l,int r)
	{
		Seg_Tree ret;
		ret.lpos=l; ret.rpos=r;
		ret.lsiz=ret.rsiz=ret.msiz=(r-l+1);
		return ret;
	}
	
	Seg_Tree Update(Seg_Tree A,Seg_Tree B,int al,int ar,int bl,int br)
	{
		Seg_Tree C;
		
		C.lsiz=A.lsiz;
		if (A.lsiz==ar-al+1) C.lsiz=A.lsiz+B.lsiz;
		C.rsiz=B.rsiz;
		if (B.rsiz==br-bl+1) C.rsiz+=A.rsiz;
		
		// Update Part
		C.msiz=A.rsiz+B.lsiz;
		C.lpos=ar-A.rsiz+1;
		C.rpos=bl+B.lsiz-1;
		// Case 2
		if (A.msiz>C.msiz)
		{
			C.msiz=A.msiz;
			C.lpos=A.lpos;
			C.rpos=A.rpos;
		}
		//Case 3
		if (B.msiz>=C.msiz)
		{
			C.msiz=B.msiz;
			C.lpos=B.lpos;
			C.rpos=B.rpos;
		}
		return C;
	}
	
	void Init(int siz) { tree[++tsiz]=Empty_Node(1,siz); }
	
	void Upd(int& inx,int l,int r)
	{
		if (!inx) inx=++tsiz;
		if (l==_pos && l==r)
		{
			if (_val) tree[inx].lpos=tree[inx].rpos=-1;
			else tree[inx].lpos=tree[inx].rpos=l;
			tree[inx].lsiz=tree[inx].rsiz=tree[inx].msiz=_val^1;
			tree[inx].val=_val;
			return;
		}
		int mid=(l+r)>>1;
		if (_pos<=mid) Upd(LCH,l,mid);
		else Upd(RCH,mid+1,r);
		
		// Update nodes
		int lch=LCH,rch=RCH;
		tree[inx]=Update(lch?tree[lch]:Empty_Node(l,mid),
						 rch?tree[rch]:Empty_Node(mid+1,r),
						 l,mid,mid+1,r);
		LCH=lch; RCH=rch;
		tree[inx].val=tree[LCH].val+tree[RCH].val;
	}
	
	int Qry(int& inx,int l,int r)
	{
		if (!inx) return 0;
		if (l>=lx && r<=rx) return tree[inx].val;
		int mid=(l+r)>>1,ret=0;
		if (lx<=mid) ret+=Qry(LCH,l,mid);
		if (rx>mid) ret+=Qry(RCH,mid+1,r);
		return ret;
	}
	
	#undef LCH
	#undef RCH
};

int main()
{
	readx(n); readx(m);
	SGT::Init(n);
	
	for (int i=1;i<=m;i++)
	{
		readx(opt);
		if (!opt)
		{
			readx(SGT::lx); readx(SGT::rx);
			printf("%d\n",SGT::Qry(SGT::root,1,n));
		}
		else
		{
			if (!show[opt])
			{
				if (SGT::tree[1].rsiz>=max(SGT::tree[1].msiz,SGT::tree[1].lsiz)) // case 1: right
					SGT::_pos=(n-SGT::tree[1].rsiz+1) + SGT::tree[1].rsiz/2;
					
				else if (SGT::tree[1].msiz>=SGT::tree[1].lsiz) // case 2: mid
					SGT::_pos=SGT::tree[1].lpos + ( SGT::tree[1].rpos-SGT::tree[1].lpos+1 )/2;
				
				else // case 3: left
					SGT::_pos=1 + SGT::tree[1].lsiz/2;
				
				SGT::_val=1; show[opt]=SGT::_pos;
				SGT::Upd(SGT::root,1,n);
			}
			else
			{
				SGT::_val=0; SGT::_pos=show[opt];
				SGT::Upd(SGT::root,1,n);
				show[opt]=0;
			}
		}
	}
}
```

---

## 作者：_Fontainebleau_ (赞：3)

这里提供一种**线段树+map** 的做法。

容易发现这道题其实就是 [Hotel](https://www.luogu.com.cn/problem/P2894) 的加强版。

那么借用 Hotel 这道题的思想，此题我们需要用线段树维护的是
- 最长连续空插排数量
- 从左开始的最长连续空插排数量
- 从右开始的最长连续空插排数量
- 最长连续空插排的中间位置
- 被使用的插排数量

前三个需要维护的信息是这种**最长连续xx序列**很常见的一个思路。
类似的题除了 Hotel 还有一个 [Step](https://www.luogu.com.cn/problem/P6492)，有兴趣的可以先去做一做。

最后一个信息是赤裸裸的区间加。

惟一的难点就是这个**最长连续空插排的中间位置**了。不过如果用脑子想一想，似乎也不是很难。我们已经知道了左区间从右开始的最长连续插排数量，以及右区间从左开始的连续插排数量。那么画一个图就知道了：

![](https://cdn.luogu.com.cn/upload/image_hosting/cgsx3omg.png)

（图中 $rmx$ 表示从右开始的最长连续空插排数量， $lmx$ 表示从左开始）

放一下 pushup 部分的代码：

```cpp
inline void pushup(int u,int l,int r)
{
	int mid=(l+r)>>1;
	used[u]=used[ls[u]]+used[rs[u]];
	lmx[u]=lmx[ls[u]];
	if((mid-l+1)==mx[ls[u]])	lmx[u]+=lmx[rs[u]];
	rmx[u]=rmx[rs[u]];
	if((r-mid)==mx[rs[u]])	rmx[u]+=rmx[ls[u]];
	mx[u]=0;
	if(mx[rs[u]]>mx[u])	mx[u]=mx[rs[u]],m[u]=m[rs[u]];
	if(lmx[rs[u]]+rmx[ls[u]]>mx[u])	mx[u]=lmx[rs[u]]+rmx[ls[u]],m[u]=mid-rmx[ls[u]]+1 +(mx[u]>>1);
	if(mx[ls[u]]>mx[u])	mx[u]=mx[ls[u]],m[u]=m[ls[u]];
   //m-最长连续空插排的中间位置
   //mx-最长连续空插排数量
   //used-被使用的插排数量
}
```
那么 map 用在哪里呢？

用在 $k$ 那里，用来记录 $k$ 号学生使用的电源插排。

放一下此处代码

```cpp
while(m--)
{
	int k=read();
	if(!k)
	{
		int l=read(),r=read();
		printf("%d\n",t.query(rt,1,n,l,r));
	}
	else
	{
		if(mp[k])	t.modify(rt,1,n,mp[k],0),mp[k]=0;
		else	mp[k]=t.m[rt],t.modify(rt,1,n,mp[k],1);
	}
}
```

大家不妨结合代码理解一下我说的东西。

[完整代码](https://www.luogu.com.cn/paste/1tw4362o)，可能有一些实现细节，需要的可以康康。

---

## 作者：_AyachiNene (赞：2)

set 加线段树做法。
# 思路：
操作本质上是把一个线段分成两段和合并两个线段，并找最长线段。直接用 set 维护连续段和最大值即可。具体的，用 set 维护二元组 $(l,r)$ 表示一个区间，再用一个二元组维护 $(len,p)$ 表示区间长度和起点。加入操作就找出最长段，并按提议模拟一下，再修改下两个 set 的值。合并就找一下合并位置的前驱和后继判断能否合并，再更新 set 的值即可。题目还要求求和，用动态开点线段树维护即可。
# Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO
{
	char buff[1<<21],*p1=buff,*p2=buff;
	char getch(){return p1==p2&&(p2=((p1=buff)+fread(buff,1,1<<21,stdin)),p1==p2)?EOF:*p1++;}
	template<typename T>void read(T &x){char ch=getch();int fl=1;x=0;while(ch>'9'||ch<'0'){if(ch=='-')fl=-1;ch=getch();}while(ch<='9'&&ch>='0'){x=x*10+ch-48;ch=getch();}x*=fl;}
	template<typename T>void read_s(T &x){x="";char ch=getch();while(!(ch>='a'&&ch<='z')&&!(ch>='A'&&ch<='Z'))ch=getch();while((ch>='a'&&ch<='z')||(ch>='A'&&ch<='Z')){x+=ch;ch=getch();}}
	template<typename T,typename ...Args>void read(T &x,Args& ...args){read(x);read(args...);}
	char obuf[1<<21],*p3=obuf;
	void putch(char ch) {if(p3-obuf<(1<<21))*p3++=ch;else fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=ch;}
	char ch[100];
	template<typename T>void write(T x) {if(!x)return putch('0');if(x<0)putch('-'),x*=-1;int top=0;while(x)ch[++top]=x%10+48,x/=10;while(top)putch(ch[top]),top--;}
	template<typename T,typename ...Args>void write(T x,Args ...args) {write(x);putch(' ');write(args...);}
	void put(string s){for(int i=0;i<s.size();i++)putch(s[i]);}
	void flush(){fwrite(obuf,p3-obuf,1,stdout);}
}
using namespace IO;
int n,m;
namespace Nene
{
	struct segt
	{
		int l,r,val;
	}t[100005*30];
	#define mid (l+r>>1)
	int cnt,rt;
	void insert(int x,int v,int &root,int l=1,int r=n)
	{
		if(!root) root=++cnt;
		if(l==r) return t[root].val+=v,void();
		if(x<=mid) insert(x,v,t[root].l,l,mid);
		else insert(x,v,t[root].r,mid+1,r);
		t[root].val=t[t[root].l].val+t[t[root].r].val;
	}
	int query(int x,int y,int root,int l=1,int r=n)
	{
		if(!root) return 0;
		if(l>=x&&r<=y) return t[root].val;
		int res=0;
		if(x<=mid) res+=query(x,y,t[root].l,l,mid);
		if(y>mid) res+=query(x,y,t[root].r,mid+1,r);
		return res;
	}
}using namespace Nene;
#define pii pair<int,int>
#define fi first
#define se second
set<pii>mx,s;
map<int,int>mp;
int main()
{
//	freopen("114514.in","r",stdin);
//	freopen("114514.out","w",stdout);
	read(n,m);
	s.insert({1,n});
	mx.insert({n,n});
	while(m--)
	{
		int x;read(x);
		if(x==0)
		{
			int l,r;read(l,r);
			write(query(l,r,rt)),putch('\n');
		}
		else
		{
			if(mp[x]) 
			{
				int p=mp[x];
//				cout<<x<<" "<<p<<" "<<query(6,9,rt)<<endl;
				insert(p,-1,rt);
				int l,r;l=r=p;
				auto it=s.lower_bound({p,p});
				if(it!=s.end()&&it->fi==p+1)
				{
					r=it->se;
					mx.erase({it->se-it->fi+1,it->se});s.erase(it);
				}
				it=s.lower_bound({p,p});
				if(it!=s.begin())
				{
					--it;
					if(it->se==p-1)
					{
						l=it->fi;
						mx.erase({it->se-it->fi+1,it->se});s.erase(it);
					}
				}
				mp[x]=0;
//				cout<<x<<" "<<p<<" "<<l<<' '<<r<<endl;
				s.insert({l,r});mx.insert({r-l+1,r});
			}
			else
			{
				auto it=mx.end();--it;
				int p=(2*it->se-it->fi+2)/2;
				mp[x]=p;insert(p,1,rt);
				it=s.upper_bound({p,p});--it;
				int l=it->fi,r=it->se;s.erase(it);mx.erase({r-l+1,r});
				if(l!=p) s.insert({l,p-1}),mx.insert({p-l,p-1});
				if(p!=r) s.insert({p+1,r}),mx.insert({r-p,r});
//				cout<<x<<" "<<p<<" "<<query(6,9,rt)<<"faq\n";
			}
		}
	}
	flush();
	return 0;
}
/*
50 10
29
25
35
1
3
0 1 9
25
1
43
0 6 9
0
0

26
*/
```

---

## 作者：foryou_ (赞：2)

区间问题，优先考虑线段树，$O(q \log n)$ 的时间复杂度可以承受。

具体的，我们维护五条信息：

- 区间内被使用插排个数 $used$。

- 区间内的左端最长连续空插排 $lmx$。

- 区间内的右端最长连续空插排 $rmx$。

- 区间内的最长连续空插排 $mx$。

- 区间内的最长连续空插排的中间位置 $m$。

在 `pushup` 中，$used$ 可以直接加，$lmx,rmx,mx,m$ 套路地更新即可。  

对于同学的到来 / 离去，我们使用一个 `map` 存储其插排的位置并进行单点修改即可。

但是，普通线段树一般需要开 $4N$ 空间，但此题无法承受，于是我们使用动态开点线段树即可。

值得注意的是，因为同学们总会选右边的，所以 `pushup` 时需要从右至左地更新 $mx,m$，具体见[代码](https://www.luogu.com.cn/paste/okw23ccd)。

综上，本题让我们学会了线段树处理区间问题的常见思路（维护 $lmx,rmx$），以及通过使用动态开点线段树节省空间。

---

## 作者：lzyqwq (赞：1)

七夕大家都有 npy 陪而我这种哥布林只能瞎几把写点数据结构题了。

> - 七夕这天，喜鹊在天空架起了桥梁，让牛郎和织女相遇。
> - 具体来说，天空有 $n$ 个位置，一开始没有一个位置上有喜鹊。您作为掌管爱情的月老，需要执行 $q$ 次操作，一次操作会先给出一个参数 $k$。
> - 若 $k\ne 0$，则其表示一只喜鹊的编号。若喜鹊 $k$ 暂未出现在鹊桥上，则它会找到鹊桥中最长的连续没有喜鹊的区间。若有多个最长的区间则选择最右边的。设选择的区间为 $[l,r]$，然后，这只喜鹊会选择去到 $\left\lfloor\dfrac{l+r+1}{2}\right\rfloor$ 这个位置。若喜鹊 $k$ 已经在鹊桥上，则它会从原来的位置飞走，原来的位置变为空。
> - 若 $k=0$，则您还会收到两个参数 $l,r$，您要回答区间 $[l,r]$ 内有多少只喜鹊。
> - $n\le 10^9$，$q\le 10^5$。

考虑动态开点线段树。记树上的一个点为 $(x,l,r)$，其中 $x$ 为点编号，$[l,r]$ 为其对应的区间。考虑维护一个 $0/1$ 序列，分别表示这个位置上无 / 有喜鹊。

在一个节点上维护以下信息：

- $\text{lmx}$：最长的全 $0$ 前缀长度。
- $\text{rmx}$：最长的全 $0$ 后缀长度。
- $\text{mx}$：最长全 $0$ 区间长度。
- $\text{pos}$：最右边的最长全 $0$ 区间的左端点。
- $\text{tot}$：区间 $1$ 个数。

然后瞎几把合并即可。由于是动态开点，因此对于形如 $(0,l,r)$ 这样的 **空** 节点，信息要临时计算，否则信息已经存储在开出来的节点上。

对于修改，再用一个 `map` 维护第 $k$ 只喜鹊的位置信息即可。

时空复杂度均为 $\mathcal{O}(q\log n)$。


```cpp
#include <bits/stdc++.h>
template<class T> void read(T &x) {
    x = 0; T f = 1; char c = getchar();
    for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
    for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - 48; x *= f;
}
template<class T> void write(T x) {
    if (x > 9) write(x / 10); putchar(x % 10 + 48);
}
template<class T> void print(T x, char ed = '\n') {
    if (x < 0) putchar('-'), x = -x; write(x), putchar(ed);
}
using namespace std; const int N = 100005; int n, q; map<int, int> mp;
struct node {
    int l, r, lmx, rmx, mx, pos, tot;
    node(int a = 0, int b = 0, int c = 0, int d = 0,
         int e = 0, int f = 0, int g = 0) {
        l = a; r = b; lmx = c; rmx = d; mx = e; pos = f; tot = g;
    }
    node operator+(const node &o) const {
        node ans; ans.l = l; ans.r = o.r; ans.tot = tot + o.tot;
        ans.lmx = lmx + (lmx == r - l + 1 ? o.lmx : 0);
        ans.rmx = o.rmx + (o.rmx == o.r - o.l + 1 ? rmx : 0);
        ans.mx = max({mx, o.mx, rmx + o.lmx});
        ans.pos = (o.mx == ans.mx ? o.pos :
                   rmx + o.lmx == ans.mx ? r - rmx + 1 : pos);
        return ans;
    }
};
struct Seg {
    node a[N << 5]; int ls[N << 5], rs[N << 5], rt, cnt;
    node info(int x, int l, int r) {
        return x ? a[x] : node(l, r, r - l + 1, r - l + 1, r - l + 1, l, 0);
    }
    void mdf(int &x, int l, int r, int k, int v) {
        if (!x) x = ++cnt; int m = l + r >> 1;
        if (l == r) {
            a[x] = v ? node(l, l, 0, 0, 0, 0, 1) : node(l, l, 1, 1, 1, l, 0);
            return;
        }
        if (k <= m) mdf(ls[x], l, m, k, v); else mdf(rs[x], m + 1, r, k, v);
        a[x] = info(ls[x], l, m) + info(rs[x], m + 1, r);
    }
    node qry(int x, int l, int r, int ql, int qr) {
        if (ql <= l && r <= qr) return info(x, l, r); int m = l + r >> 1;
        if (qr <= m) return qry(ls[x], l, m, ql, qr);
        if (ql > m) return qry(rs[x], m + 1, r, ql, qr);
        return qry(ls[x], l, m, ql, qr) + qry(rs[x], m + 1, r, ql, qr);
    }
} tr;
signed main() {
    read(n); read(q);
    for (int k, l, r, lp, rp; q--;) {
        read(k);
        if (k) {
            if (mp[k]) tr.mdf(tr.rt, 1, n, mp[k], 0), mp[k] = 0;
            else {
                node t = tr.info(tr.rt, 1, n); mp[k] = (t.pos << 1) + t.mx >> 1;
                tr.mdf(tr.rt, 1, n, mp[k], 1);
            }
        } else read(l), read(r), print(tr.qry(tr.rt, 1, n, l, r).tot);
    }
    return 0;
}
```

---

## 作者：Unnamed114514 (赞：1)

**FHQ-Treap+set+map**，目前题解区好像没有这个做法？

首先容易想到用 `set` 来维护每个可以选择的区间，那么我们每次就取出 `set` 中的第一个维护，这一部分按照题意模拟即可。

对于到来一个人，我们找到第一个区间后，得到分割点，然后把分割后的两个线段加入 `set` 即可。

若离开了一个人，考虑维护一下这个人选取的点的前驱 $l$ 和后继 $r$，那么此时这个人离开，那么就是把这个人选取的左右两个区间合并，然后得到一个新的区间 $(l,r)$，此时我们只需要在 `set` 里面删除原来的区间并且加入合并的区间。

对于查询，运用差分的思想，将问题转化成 $\le r$ 的中选择的数量再减去 $\le l-1$ 中选择的数量，即用 $r+1$ 的排名减去 $l$ 的排名。

前驱、后继、排名，容易想到用平衡树维护。~~诶这几个操作好像也可以用 `multiset` 维护？~~

呃，刚刚测了一下，`multiset` 好像不支持迭代器直接相减，所以还是乖乖打平衡树吧。

---

## 作者：SuperJvRuo (赞：1)

楼上说，标算应该是线段树+```set```。我写的就是```std::set```+```std::map```+动态开点线段树。

s1维护各个空区间的左右端点，s2维护区间的长度和左端点，map记录学生对应的插排。插入时，从s2中找出最大区间长度，修改s1和s2；删除时，从s1中找出两侧的区间，修改s1和s2。查询时用动态开点线段树统计答案。

祝NOIp2018rp++！

```
#include<cstdio>
#include<cctype>
#include<utility>
#include<set>
#include<map>
#define PII std::pair<int,int>
#define IT std::set<PII>::iterator

int Read()
{
	int x=0;char c=getchar();
	while(!isdigit(c))
	{
		c=getchar();
	}
	while(isdigit(c))
	{
		x=x*10+(c&15);
		c=getchar();
	}
	return x;
}

std::set<PII> s1;
std::set<PII> s2;
std::map<int,int> stu;

int Insert()
{
	int l=s2.rbegin()->second;
	int r=s2.rbegin()->second+s2.rbegin()->first-1;
	int pos=(l+r+1)>>1;//坑点，记得这个加1
	s2.erase(--s2.end());
	s1.erase(PII(l,r));
	if(l!=pos)
	{
		s1.insert(PII(l,pos-1));
		s2.insert(PII(pos-1-l+1,l));
	}
	if(r!=pos)
	{
		s1.insert(PII(pos+1,r));
		s2.insert(PII(r-pos,pos+1));
	}
	return pos;
}

void Erase(int pos)
{
	IT back=s1.lower_bound(PII(pos,pos));
	IT front=back;
	--front;
	int l=pos,r=pos;
	if(front->second==pos-1)
	{
		l=front->first;
		s2.erase(PII(front->second-front->first+1,front->first));
		s1.erase(front);
	}
	if(back->first==pos+1)
	{
		r=back->second;
		s2.erase(PII(back->second-back->first+1,back->first));
		s1.erase(back);
	}
	s1.insert(PII(l,r));
	s2.insert(PII(r-l+1,l));
}

struct seg
{
	int l,r,sum;
	int ch[2];
} tree[3000005];
int size=1;

void Add(int pos,int val,int L,int R,int idx)
{
	if(L==R)
		tree[idx].sum+=val;
	else
	{
		int mid=(L+R)>>1;
		if(pos<=mid)
		{
			if(!tree[idx].ch[0])
				tree[idx].ch[0]=++size;
			Add(pos,val,L,mid,tree[idx].ch[0]);
		}
		else
		{
			if(!tree[idx].ch[1])
				tree[idx].ch[1]=++size;
			Add(pos,val,mid+1,R,tree[idx].ch[1]);
		}
		tree[idx].sum=tree[tree[idx].ch[0]].sum+tree[tree[idx].ch[1]].sum;
	}
}

int Query(int l,int r,int L,int R,int idx)
{
	if(l<=L&&R<=r)
		return tree[idx].sum;
	else
	{
		int mid=(L+R)>>1;
		int ans=0;
		if(l<=mid)
		{
			if(!tree[idx].ch[0])
				tree[idx].ch[0]=++size;
			ans+=Query(l,r,L,mid,tree[idx].ch[0]);
		}
		if(r>mid)
		{
			if(!tree[idx].ch[1])
				tree[idx].ch[1]=++size;
			ans+=Query(l,r,mid+1,R,tree[idx].ch[1]);
		}
		return ans;
	}
}

int main()
{
	int n=Read(),q=Read();
	s1.insert(PII(1,n));
	s2.insert(PII(n,1));
	int k,l,r,pos;
	while(q--)
	{
		k=Read();
		if(!k)
		{
			l=Read(),r=Read();
			printf("%d\n",Query(l,r,1,n,1));
		}
		else
		{
			if(stu[k]==0)
			{
				pos=stu[k]=Insert();
				Add(pos,1,1,n,1);
			}
			else
			{
				Erase(pos=stu[k]);
				Add(pos,-1,1,n,1);
				stu[k]=0;
			}
		}
	}
	return 0;
}
```

---

## 作者：KinNa_Sky (赞：0)

看了一眼题解区大家的 FHQ-treap 怎么长得线段数模线段数样的（指维护了区间的前后缀最长 $0$ 段）。

其实在这个题里平衡树的 `pushup` 是**一个点**从左右子树里合并信息，合并三部分加了两个空段，很好维护的。只需维护当前点位置，子树内最大位置和最小位置就好了。

而且不用分讨。

```cpp
void Node::pushup() {
	res = max(t[l].res, t[r].res);
	siz = t[l].siz + t[r].siz + 1;
	mx = mn = val;
	if (l) mx = max(mx, t[l].mx), mn = min(mn, t[l].mn);
	if (r) mx = max(mx, t[r].mx), mn = min(mn, t[r].mn);
	if (l) res = max(res, PII(val - t[l].mx - 1, t[l].mx + 1));
	if (r) res = max(res, PII(t[r].mn - val - 1, val + 1));
}
```

其中 `res` 是第一维区间长度第二维左端点位置的 `pair`。

剩下的是普通平衡树，可以用 `map` 来记录每个人插在哪了。

[完整代码](https://www.luogu.com.cn/paste/kb9mph5o)。

---

## 作者：JimmyLee (赞：0)

# 题意

维护一个 $01$ 串，初始均为 $0$，支持：

- 单点将 $1$ 修改为 $0$。
- 查询区间中 $1$ 的个数。
- 查询最长且最靠右的连续 $0$ 段的靠右的中点，并将其改为 $1$。

# 分析

第一个操作和第二个操作显然使用动态开点线段树维护。

我们只需要解决第三个操作。

我们用平衡树存储连续的 $0$ 段的左右端点。

维护两棵平衡树，一棵按区间的左端点从小到大排序，另一棵以区间长度为第一关键字，左端点为第二关键字从大到小排序。

询问的时候只需要在第二棵平衡树中取出其最大的元素。

考虑修改操作带来的影响。

单点修改为 $1$ 会导致一段连续的 $0$ 段断开成为至多 $2$ 段。

分类讨论处理一下段的分裂情况。

单点修改为 $0$ 会导致至多两段连续的 $0$ 段合并为同一段。

在第一棵树上二分找出插入点前后的连续段，同样分类讨论一下段的合并情况。

时间复杂度 $O(q\log n+q\log q)$。

---

发现平衡树只需要支持查前驱后继，所以可以使用 `set` 实现。

可以向 `set` 中加入两个哨兵区间 $[-1,-2],[n+2,n+1]$ 以避免越界分类讨论。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;

struct SegT
{
    struct node
    {
        uint32_t sum;
        node *lc, *rc;
        node() {lc=rc=0; sum=0;}
    }*rt;

    #define mid ((l+r)>>1)
    #define lson x->lc, l, mid
    #define rson x->rc, mid+1, r

    void modify(node *&x, int l, int r, int p, int v)
    {
        if(!x) x=new node;
        x->sum+=v;
        if(l==r) return;
        if(p<=mid) modify(lson, p, v);
        if(p>mid)  modify(rson, p, v);
    }

    uint32_t query(node *x, int l, int r, int L, int R)
    {
        if(!x) return 0;
        if(L<=l&&r<=R) return x->sum;
        uint32_t ret=0;
        if(L<=mid) ret+=query(lson, L, R); 
        if(R>mid)  ret+=query(rson, L, R); 
        return ret;
    }
}tr;

struct itv
{
    int l, r;
    int pos() {return (l+r+1)>>1;}
    itv(int L, int R) {l=L, r=R;}
};

#define len(x) (x.r-x.l+1)

struct cmp1{bool operator()(itv a, itv b)const{return a.l<b.l;}};
struct cmp2{bool operator()(itv a, itv b)const{return len(a)==len(b)?a.l>b.l:len(a)>len(b);}};

set<itv, cmp1> s1;
set<itv, cmp2> s2;
map<int, int> pos;

void emplace(int x, int y) {s1.emplace(x, y), s2.emplace(x, y);}
void emplace(itv &x) {s1.emplace(x), s2.emplace(x);}
void erase(itv &x) {s1.erase(x), s2.erase(x);}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int n, q, l, r, k;
    cin>>n>>q;
    emplace(1, n);
    emplace(-1, -2);
    emplace(n+2, n+1);
    while(q--)
    {
        cin>>k;
        if(!k)
            cin>>l>>r, 
            cout<<tr.query(tr.rt, 1, n, l, r)<<'\n';
        else
        {
            if(!pos[k])
            {
                auto seg=*s2.begin();
                erase(seg);
                int p=seg.pos();
                pos[k]=p;
                tr.modify(tr.rt, 1, n, p, 1);
                if(p!=seg.l) emplace(seg.l, p-1);
                if(p!=seg.r) emplace(p+1, seg.r);
            }
            else
            {
                int p=pos[k];
                pos[k]=0;
                tr.modify(tr.rt, 1, n, p, -1);
                auto it=s1.lower_bound({p, 0});
                auto seg2=*it, seg1=*--it;
                if(seg1.r==p-1&&seg2.l==p+1)
                    erase(seg1), erase(seg2),
                    emplace(seg1.l, seg2.r);
                else if(seg1.r==p-1) erase(seg1), emplace(seg1.l, p);
                else if(seg2.l==p+1) erase(seg2), emplace(p, seg2.r);
                else emplace(p, p);
            }
        }
    }
}
```

---

## 作者：Fzrcy (赞：0)

首先用动态开点线段树维护所有插排的使用情况，然后用两个 `set` 维护所有的没有被使用的插排的区间。

在第一个 `set`  $X$ 中，区间以区间长度为第一关键字（从大到小）、区间左端点为第二关键字排序（从大到小）排序，第二个 `set`  $Y$ 则按照区间左端点排序（从小到大）。

每进来一个学生时直接在 $X$ 的第一个迭代器中找即可，每有一个学生离开时直接在 $Y$ 中找到与其相邻的没有被使用的插排的区间，合并即可。

实现细节请看代码。

```cpp
// qwq
#include <bits/stdc++.h>
using namespace std;
namespace Work{
    constexpr int N=1e5+7;
    struct SegTree{
        int lc[N*32*3],rc[N*32*3],cnt,s[N*32*3];
        void ins(int& k,int l,int r,int x,int v){
            if(!k)k=++cnt;s[k]+=v;if(l==r)return;int mid=l+r>>1;
            if(x<=mid)ins(lc[k],l,mid,x,v);
            else ins(rc[k],mid+1,r,x,v);
        }
        int qr(int k,int l,int r,int x,int y){
            if(!k||l>=x&&r<=y)return s[k];int mid=l+r>>1,e=0;
            if(x<=mid)e+=qr(lc[k],l,mid,x,y);
            if(y>mid) e+=qr(rc[k],mid+1,r,x,y);
            return e;
        }
    }Tr;
    struct info{
        int l,len;
        bool operator < (const info& b)const
            {return len!=b.len?len>b.len:l>b.l;}
    };
    struct Info{
        int l,len;
        bool operator < (const Info& b)const
            {return l<b.l;}
    };
    set<info> Set;
    set<Info> SET;
    map<int,int>P;
    int rt,n,m;
    int inspos(){
        info it=*Set.begin();
        SET.erase({it.l,it.len});
        Set.erase(Set.begin());
        int r=it.l+it.len-1,l=it.l,mid=l+r+1>>1;
        if(l<mid)Set.insert({l,mid-l}),SET.insert({l,mid-l});
        if(mid<r)Set.insert({mid+1,r-mid}),SET.insert({mid+1,r-mid});
        Tr.ins(rt,1,n,mid,1);
        return mid;
    }
    void delpos(int mid){
        auto it=SET.lower_bound({mid,0});
        int r=(it!=SET.end()&&(it->l)==mid+1?it->len:0);
        int l=0;
        if(it!=SET.begin()){
            --it;
            if((it->l)+(it->len)==mid)
                l=it->len;
        }
        if(l)Set.erase({mid-l,l}),SET.erase({mid-l,l});
        if(r)Set.erase({mid+1,r}),SET.erase({mid+1,r});
        Set.insert({mid-l,l+r+1});
        SET.insert({mid-l,l+r+1});
        Tr.ins(rt,1,n,mid,-1);
    }
    int main(){
        cin>>n>>m;
        Set.insert({1,n});
        SET.insert({1,n});
        while(m--){
            int op,x,y;
            cin>>op;
            if(op){
                if(P[op]){
                    delpos(P[op]);
                    P[op]=0;
                }
                else{
                    P[op]=inspos();
                }
            }
            else{
                cin>>x>>y;
                cout<<Tr.qr(rt,1,n,x,y)<<'\n';
            }
        }
        return 0;
    }
}
int main(){
    Work::main();
    return 0;
}
```



---

## 作者：Genius_Z (赞：0)

眼瞎调了$40$分钟（

很容易想到我们可以用类似珂朵莉树的思想用平衡树维护这个最长的区间，以区间长度为第一关键字，左端点为第二关键字逆序排序。但是如果只维护长度的话我们将无法合并区间，那么我们需要再维护一棵平衡树来辅助合并，以左端点为第一关键字，以区间长度为第二关键字正序排序。每次修改时需要在这两棵平衡树里同时进行插入和删除。

当然也可以直接在线段树上维护这个最长区间，不过比起这个要麻烦一些。

由于$k$非常大所以再用个$map$进行映射。

查询直接通过动态开点权值线段树做即可，时空复杂度为$\Theta(n\log n)$

坑点：如果区间长度是偶数，会选择靠右的那个中点。

$\Large Code:$

```cpp
#define ls(x) t[x].child[0]
#define rs(x) t[x].child[1]
struct node {
	int l, len;
	node(int l, int len) : l(l), len(len) {}
	bool operator<(const node& f) const { return len == f.len ? l > f.l : len > f.len; }
};
struct snode {
	int l, len;
	snode(int l, int len) : l(l), len(len) {}
	bool operator<(const snode& f) const { return l == f.l ? len < f.len : l < f.l; }
};
set<node> s1;
set<snode> s2;
map<int, int> mp;
struct Node {
	int child[2], w;
} t[40000001];
int cnt;
inl void insert(int& k, int l, int r, int p, int w) {
	if (!k) k = ++cnt;
	if (l == r) return (void)(t[k].w += w);
	re mid = l + r >> 1;
	p <= mid ? insert(ls(k), l, mid, p, w) : insert(rs(k), mid + 1, r, p, w);
	t[k].w = t[ls(k)].w + t[rs(k)].w;
}
inl int query(int k, int l, int r, int x, int y) {
	if (l >= x && r <= y) return t[k].w;
	re mid = l + r >> 1, ans = 0;
	if (x <= mid) ans = query(ls(k), l, mid, x, y);
	if (y > mid) ans += query(rs(k), mid + 1, r, x, y);
	return ans;
}
signed main() {
	re n = read<int>(), m = read<int>(), k, x, y, mid, rt = 0;
	s1.insert(node(1, n)), s2.insert(snode(1, n));
	while (m--) {
		k = read<int>();
		if (k) {
			if (mp.find(k) == mp.end()) {
				x = s1.begin()->l, y = x + s1.begin()->len - 1, mid = x + y >> 1;
				if (!((y - x + 1) & 1))mid++;
				insert(rt, 1, n, mid, 1);
				s2.erase(snode(x, s1.begin()->len)), s1.erase(s1.begin()), mp[k] = mid;
				if (mid > x) s1.insert(node(x, mid - x)), s2.insert(snode(x, mid - x));
				if (mid < y) s1.insert(node(mid + 1, y - mid)), s2.insert(snode(mid + 1, y - mid));
			}
			else {
				x = mp[k], mp.erase(k), k = x;
				insert(rt, 1, n, k, -1);
				set<snode>::iterator itr = s2.lower_bound(snode(x, 1)), itl;
				if (itr != s2.begin()) {
					itl = prev(itr);
					if (itl->l + itl->len + 1 == itr->l) {
						re l = itl->l, len = itl->len + itr->len + 1;
						s1.erase(node(l, itl->len)), s1.erase(node(itr->l, itr->len)), s1.insert(node(l, len));
						s2.erase(itl), s2.erase(itr), s2.insert(snode(l, len));
					}
					else {
						s2.insert(snode(k, 1)), s1.insert(node(k, 1));
					}
				}
				else {
					if (k == itr->l - 1) {
						re l = itr->l, len = itr->len + 1;
						s1.erase(node(l, len - 1)), s1.insert(node(k, len));
						s2.erase(s2.begin()), s2.insert(snode(k, len));
					}
					else {
						s1.insert(node(k, 1)), s2.insert(snode(k, 1));
					}
				}
			}
		}
		else {
			x = read<int>(), y = read<int>();
			printf("%d\n", query(1, 1, n, x, y));
		}
	}
}
```



---

## 作者：jzqjzq (赞：0)

估计标算是线段树+set

一种真的不用仔细想的做法是：

用一个set维护最长的连续区间，再用一个set维护已被用的位置集合

对于插入，把最长区间拿出来，在中间插入，更新一下第一个set

对于删除，把左右对应区间拿出来合并，删除原区间

对于询问我们的想法是把小于等于r的第一个元素和大于等于l的第一个元素中间的元素个数找出来

然后发现set的迭代器不资瓷相减QAQ

所以只能老老实实地打平衡树了
```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <iostream>
#include <ctime>
#include <map>
#include <queue>
#include <cstdlib>
#include <string>
#include <climits>
#include <set>
#include <vector>
#include <complex>
using namespace std;
inline int read(){
	int k=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){k=k*10+ch-'0';ch=getchar();}
	return k*f;
}
inline void write(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);putchar(x%10+'0');
}
inline void writeln(int x){
	write(x);puts("");
}
map<int,int>mp;
int n,Q,cnt=0;
int b[100010];
struct ppap{int x,l;};
bool operator <(ppap a,ppap b){return a.l==b.l?a.x>b.x:a.l>b.l;}
set<ppap>s;
struct tree{int v,pri,ls,rs,s;}t[200010];
int Cnt=0,rt=0;
inline void pushup(int x){t[x].s=t[t[x].ls].s+t[t[x].rs].s+1;}
inline int tnew(int v){
	Cnt++;t[Cnt].v=v;t[Cnt].ls=t[Cnt].rs=0;t[Cnt].pri=rand();
	t[Cnt].s=1;return Cnt;
}
inline void split(int nod,int v,int &x,int &y){
	if(!nod)x=y=0;
	else{
		if(t[nod].v<=v)x=nod,split(t[nod].rs,v,t[nod].rs,y);
		else y=nod,split(t[nod].ls,v,x,t[nod].ls);
		pushup(nod);
	}
}
inline int merge(int x,int y){
	if(x*y==0)return x+y;
	if(t[x].pri<t[y].pri){
		t[x].rs=merge(t[x].rs,y);
		pushup(x);return x;
	}else{
		t[y].ls=merge(x,t[y].ls);
		pushup(y);return y;
	}
}
inline int smin(int x){
	while(t[x].ls)x=t[x].ls;
	return t[x].v;
}
inline int smax(int x){
	while(t[x].rs)x=t[x].rs;
	return t[x].v;
}
int main()
{
	srand(19260817);
	n=read();Q=read();
	s.insert((ppap){0,n});
	int p=tnew(0),q=tnew(n+1);
	rt=merge(p,q);
	while(Q--){
		int op=read();
		if(op==0){
			int l=read(),r=read(),x=0,y=0;
			split(rt,l-1,x,y);int ans=t[x].s;
			rt=merge(x,y);split(rt,r,x,y);
			ans=t[x].s-ans;rt=merge(x,y);
			writeln(ans);
		}else{
			if(!mp[op])mp[op]=++cnt;
			op=mp[op];
			if(!b[op]){
				int x=0,y=0;
				ppap now=*s.begin();
				s.erase(s.begin());
				b[op]=now.x+1+now.l/2;
				split(rt,b[op],x,y);
				int qa=smin(y);
				s.insert((ppap){now.x,b[op]-now.x-1});
				s.insert((ppap){b[op],qa-b[op]-1});
				int p=tnew(b[op]);
				rt=merge(merge(x,p),y);
			}else{
				int x=0,k=0,y=0;
				split(rt,b[op],k,y);
				split(k,b[op]-1,x,k);
				int qa=smin(y),qb=smax(x);
				rt=merge(x,y);
				s.erase((ppap){qb,b[op]-qb-1});
				s.erase((ppap){b[op],qa-b[op]-1});
				s.insert((ppap){qb,qa-qb-1});
				b[op]=0;
			}
		}
	}
	return 0;
}
```

---


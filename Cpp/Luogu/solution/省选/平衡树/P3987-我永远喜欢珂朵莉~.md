# 我永远喜欢珂朵莉~

## 题目背景

http://sukasuka-anime.com/

戒不掉的珂毒

出不动的分块

 ![](https://cdn.luogu.com.cn/upload/pic/11191.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/11192.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/11193.png) 

哦对了有没有想买BD的珂学家啊？支持一下墨鱼吧~

或者有没有人想来手办众筹啊？


## 题目描述

给珂朵莉一个长为 $n$ 的非负数序列 $a$，支持以下两个操作：

- $\verb!1 l r x!$：把区间 $[l,r]$ 中所有 $x$ 的倍数除以 $x$。
- $\verb!2 l r!$：查询区间 $[l,r]$ 内元素的和。

珂朵莉很可爱，所以你要帮珂朵莉写这个题。


## 说明/提示

### 数据范围及约定

$1 \le n , m \le 10^5$，$0 \le a_i \le 5\times 10^5$，$1 \le x \le 5\times 10^5$。


## 样例 #1

### 输入

```
5 3
1 2 3 4 5
2 1 5
1 1 5 2
2 1 5```

### 输出

```
15
12```

# 题解

## 作者：noip (赞：154)

可以发现一个数最多被/log次（无视掉1和0的情况）

瓶颈在于如何找出所有该被/的数而不在于如何维护

500000以内的有最多约数的数有200个约数

然后可以用平衡树来维护

把每个i插入ai的所有约数对应的平衡树里面

每次区间[l,r]中x的倍数/x的时候

则在第x个平衡树里面把区间[l,r]截出来然后DFS这个子树

边DFS边删掉里面所有ai/x后不为x倍数的下标i

平衡树访问连续size个数的复杂度为logn+size的

总复杂度O( nd + mlog^2n ) , 空间O( nd )，d为值域内最大约数个数，即200


PS.似乎莫名其妙的被链表暴力过了。。。非常无法理解

其实类似复杂度的做法很多，平衡树做法空间和时间常数都不太好

还有很多ndlogn的做法，我只卡了一部分

因为std用的平衡树很奇怪，在这个题里面处于很大的劣势。。。


---

## 作者：JRzyh (赞：48)

BIT做法

---

一个trick：
>每次 $a_i\div k$，最多需要 $\log~a$ 次 $a$ 就会变成 $1$。

可以试着自行理解，不理解的看这：

$k\ge 2$ 所以说每次最少会使 $a_i$ 折半，所以最多需要 $\log~a$ 次 $a$ 就会变成 $1$ 。

所以说修改的复杂度最多就 $O(n\log a_i)$ 。

所以说只要把查询复杂度控制在单次 $O(\log n)$ 就行。

区间求和，单次 $O(\log n)$ ，想到了什么？

**树状数组！**

可是……修改到底怎么改呢？

前文说过，修改的复杂度最多就 $O(n\log a_i)$ ，所以我们可以直接找到要修改的数，**单点修改**（而不是区间）

最大的问题，如何找到要修改的数？

开 $500000$ 个 vector，第 $i$ 个 vector 表示包含因数 $i$ 的元素的下标，可以使其有序，使用二分法（STL里的lower_bound和upper_bound）找到起点和终点，暴力遍历其间的元素，暴力除，暴力在BIT中修改即可。

但是要注意：**删除已经不包含因数 $i$ 的元素**

怕什么，直接暴力找用erase函数。

思路没了。

---

**别着急去写代码** ~~（您还没点赞呢）~~

erase正向删数会出现问题！

删除一个数后后面的数下标都会 $-1$，所以删第二个的时候那里已经不是要删的数了。

处理方法简单，反向删数，不会影响到之后删的数。

ACcode:

```cpp
#include<bits/stdc++.h> 
using namespace std;
//
long long read()
{
    long long in=0;short f=1;
    char c=getchar();
    while (c>'9'||c<'0')
    {if(c=='-') f=-1;c=getchar();break;} 
    while (c>='0'&&c<='9') 
    {in=in*10+c-'0';c=getchar();}
    return in*f;
}
void write(long long x)  
{  
    if (x==0){putchar('0');return;}
    if(x<0) {putchar('-');x=-x;}
    if(x<10) {putchar(x+'0');return;}
    short num=0; char c[30];
    while(x) c[++num]=(x%10)+48,x/=10;
    while(num) putchar(c[num--]);
}
//快读快写 
#define lowbit(x) (x&(-x))
long long tree[100008];
int n;
long long get_sum(int wh)
{
	long long ans=0;
	for(;wh;wh-=lowbit(wh)) ans+=tree[wh];
	return ans;
}
void add(int wh,long long v)
{
	for(;wh<=n;wh+=lowbit(wh)) tree[wh]+=v;
}
//树状数组 
#define vit vector<int>::iterator
int a[100008],m;
vector<int>ys[500008];
vector<vit>t;
int main()
{
	n=read();m=read();
	for(register int i=1;i<=n;i++)
	{
		a[i]=read();
		for(register int j=1;j*j<=a[i];j++)
		{
			if(a[i]%j==0)
			{
				ys[j].push_back(i);
				if(a[i]!=j*j) ys[a[i]/j].push_back(i);  
			}
		}
		add(i,a[i]);
	}
	while(m--)
	{
		short opt=read();
		switch(opt)
		{
			case 1:
			{
				int l=read(),r=read(),x=read();
				t.clear();
				if(x==1||ys[x].empty()) continue;
				vit l2=lower_bound(ys[x].begin(),ys[x].end(),l);
				vit r2=upper_bound(ys[x].begin(),ys[x].end(),r);
				if(l2==ys[x].end()) continue;
				for(vit it=l2;it!=r2;it++)
				{
					if(a[*it]%x!=0) continue;
					add(*it,-(a[*it]-a[*it]/x));
					a[*it]/=x;
					if(a[*it]%x!=0) t.push_back(it);
				}
				if(!t.empty()) 
				{
					for(int i=t.size()-1;i>=0;i--) ys[x].erase(t[i]);
				}
				break;
			}
			case 2:
			{
				int l=read(),r=read();
				write(get_sum(r)-get_sum(l-1));
				putchar('\n');
				break;
			}
		}
	}
	return 0;
}
```
快去AC加强版：[P5610](https://www.luogu.com.cn/problem/P5610)

[My solution](https://www.luogu.com.cn/blog/242524/solution-p5610)

~~点赞，点赞，一定要点赞~~


---

## 作者：hsfzLZH1 (赞：41)

```
在太阳西斜的这个世界里，置身天上之森。

等这场战争结束之后，不归之人与望眼欲穿的众人，人人本着正义之名。

长存不灭的过去；逐渐消逝的未来。

我回来了，纵使日薄西山，即便看不到未来，此时此刻的光辉，盼君勿忘。

            ————世界上最幸福的女孩 珂朵莉
```

$ $

# 我永远喜欢珂朵莉~

## 题目大意

给定一个长度为 $n$ 的非负整数序列 $a_i$ 和以下两种操作：

1. 给定一个区间 $[l,r]$ 和一个整数 $x$ ，令 $a_l,a_{l+1},...,a_r$ 中所有 $x$ 的倍数除以 $x$ 。

2. 给定区间 $[l,r]$ ，求 $\sum_{i=l}^r a_i$ 的值。

## 解题思路

~~这是 lxl 出的题，然而却不是分块或玄学凸包~~

~~这是关于珂朵莉的题，然而却不是 Chtholly Tree~~

当 $x\neq 1$ 时，发现当一个数满足倍数条件时，其最少会被除以二，即减少一半，容易证明，一个数 $a$ 会被最多除 $O(log_2~a)$ 次，所以所有数总共最多会被除 $O(\sum_{i=1}^n log_2 ~a)$ 次。

假如我们每次操作能在 **均摊** $O(1)$ 或 **单次** $O(\log_2 n)$ 的时间复杂度内取出所有满足条件的数，暴力修改，用线段树或树状数组维护当前 $a$ 的值并支持查询区间和，即可通过此题。

现在的问题是，我们需要在以上描述的时间复杂度内找到区间内这样的一些数。

我们尝试用另一种方式描述要求的下标，先预处理出所有 **有约数** 为 $k$ 的下标位置，将其塞进一个编号为 $k$ 的平衡树中，平衡树中从小到大维护的是 $a_i$ 为 $k$ 的倍数的所有下标 $i$ 。预处理的时间复杂度为 $O(n\sqrt {\max\{a_i\}})$ 。

当我们要维护一个区间 $[l,r]$ 中为 $x$ 的倍数的所有值时，我们取出平衡树中值的范围在 $[l,r]$ 之间的所有元素。本人实现本题所用的平衡树为 FHQ Treap ，在代码实现中即为两次 ```split``` 操作取出中间的一段，遍历这棵 BST ，将所有对应的数除以 $x$ ，如果其仍满足继续存在的条件（除之后的数仍为 $x$  的倍数），则继续将其并入平衡树中。

将一个子树中所有可以并入平衡树中的值并入平衡树的操作为：取出这些平衡树中的结点，一次性 $O(n)$ 建树将其作为中间值和值域在 $[1,l-1]$ 和 $[l+1,r]$ 的两棵子树 ```merge``` 在一起。

然而，在将一个值除以 $x$ 后，可能会导致其除以另一个值时不能除尽。在遍历到这个节点时，我们不对其进行处理，直接不将其并入平衡树中即可，复杂度仍然能够保证。

在 **一些优化** 都进行的情况下，此题的时间复杂度为 $O(n\sqrt {\max\{a_i\}} +m\log_2 n\log_2 \max\{a_i\})$ 。

## 一些优化

在建树时，由于 FHQ Treap 是棵 **笛卡尔树** ，我们可以在 $O(n)$ 的时间复杂度内进行建树。（ $n$ 为将要建树的结点数）

或者你可以像本人代码实现中一样，**利用 FHQ Treap 的随机优先级只是为了使```merge```操作更加随机的性质，类似线段树的方法建树，并随机赋值优先级，仍然能保证建树（ $O(n)$ ）和其他操作的时间复杂度（ $O(\log_2n)$ ）** 。

在维护一个单点修改和区间查询和的数据结构时，我们可以使用常数更小的 **树状数组** 。

在添加了上述优化后，本人的代码就跑到了满分为 $100$ 分的全部点都评测（即一并评测了后来添加的总共 $26$ 个点）的 **第二名** 。

## 代码展示

```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#define L (o<<1)
#define R (o<<1|1)
using namespace std;
const int maxn=500010;
int n,m,a[maxn],op,l,r,x;
vector<int>g[maxn];
const int ddd=40000010;
struct FHQ
{
    int rt[maxn],cnt,lc[ddd],rc[ddd],siz[ddd],val[ddd];
    void print(int o)
    {
        if(!o)return;
        print(lc[o]);
        printf("%d ",val[o]);
        print(rc[o]);
    }
    void maintain(int o){siz[o]=siz[lc[o]]+siz[rc[o]]+1;}
    int build(int l,int r,int*p)
    {
        if(l>r)return 0;
        int mid=(l+r)>>1,v=p[mid],ret=newnode(v);
        lc[ret]=build(l,mid-1,p);
        rc[ret]=build(mid+1,r,p);
        maintain(ret);
        return ret;
    }
    int merge(int x,int y)
    {
        if(x==0||y==0)return x+y;
        maintain(x);maintain(y);
        if(rand()<rand())
        {
            rc[x]=merge(rc[x],y);
            maintain(x);return x;
        }
        else
        {
            lc[y]=merge(x,lc[y]);
            maintain(y);return y;
        }
    }
    void split_val(int o,int k,int&x,int&y)
    {
        if(!o){x=y=0;return;}
        if(val[o]<=k)x=o,split_val(rc[o],k,rc[o],y);
        else y=o,split_val(lc[o],k,x,lc[o]);
        maintain(o);
    }
    void split_siz(int o,int k,int&x,int&y)
    {
        if(!o){x=y=0;return;}
        if(siz[lc[o]]>=k)y=o,split_siz(lc[o],k,x,lc[o]);
        else x=o,split_siz(rc[o],k-siz[lc[o]]-1,rc[o],y);
        maintain(o);
    }
    int newnode(int v)
    {
        cnt++;
        lc[cnt]=rc[cnt]=0;
        val[cnt]=v;
        siz[cnt]=1;
        return cnt;
    }
}st;
typedef long long ll;
/*
struct segtree
{
    ll sum[maxn];
    void build(int o,int l,int r)
    {
        if(l==r){sum[o]=a[l];return;}
        int mid=(l+r)>>1;
        build(L,l,mid);
        build(R,mid+1,r);
        sum[o]=sum[L]+sum[R];
    }
    void update(int o,int l,int r,int x,int v)
    {
        if(l==r){sum[o]=v;return;}
        int mid=(l+r)>>1;
        if(x<=mid)update(L,l,mid,x,v);
        if(x>=mid+1)update(R,mid+1,r,x,v);
        sum[o]=sum[L]+sum[R];
    }
    ll query(int o,int l,int r,int ql,int qr)
    {
        if(r<ql||l>qr)return 0;
        if(ql<=l&&r<=qr)return sum[o];
        int mid=(l+r)>>1;
        return query(L,l,mid,ql,qr)+query(R,mid+1,r,ql,qr);
    }
}sg;
*/
#define lowbit(x) (x&(-x))
struct bit
{
    ll sum[maxn];
    void upd(int o,int v){for(int i=o;i<=n;i+=lowbit(i))sum[i]+=v;}
    ll query(int o){ll ret=0;for(int i=o;i;i-=lowbit(i))ret+=sum[i];return ret;}
}sg;
int cur,q[maxn];
void dfs(int x,int v)
{
    if(!x)return;
    if(st.lc[x])dfs(st.lc[x],v);
    if(a[st.val[x]]%v==0)sg.upd(st.val[x],-a[st.val[x]]),a[st.val[x]]/=v,sg.upd(st.val[x],a[st.val[x]]);
    if(a[st.val[x]]%v==0)q[++cur]=st.val[x];
    if(st.rc[x])dfs(st.rc[x],v);
}
void del(int x,int l,int r)
{
    int a,b,c;
    st.split_val(st.rt[x],r,b,c);
    st.split_val(b,l-1,a,b);
    cur=0;int t=0;dfs(b,x);
    t=st.build(1,cur,q);
    st.rt[x]=st.merge(a,st.merge(t,c));
}
inline int read()
{
    int ret=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')ret=((ret+(ret<<2))<<1)+ch-'0',ch=getchar();
    return ret;
}
inline void write(ll x)
{
    if(x<10){putchar('0'+x);return;}
    write(x/10);putchar('0'+(x%10));
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=n;i++)a[i]=read();
    for(int i=1;i<=n;i++)sg.upd(i,a[i]);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j*j<=a[i];j++)if(a[i]%j==0)
        {
            g[j].push_back(i);
            //st.rt[j]=st.merge(st.rt[j],st.newnode(i));
            if(j*j!=a[i])g[a[i]/j].push_back(i);
            //st.rt[a[i]/j]=st.merge(st.rt[a[i]/j],st.newnode(i));
        }
    }
    for(int i=1;i<=500000;i++)
    {
        cur=0;
        for(vector<int>::iterator it=g[i].begin();it!=g[i].end();it++)q[++cur]=*it;
        st.rt[i]=st.build(1,cur,q);
    }
    while(m--)
    {
        op=read();l=read();r=read();
        if(op==2)write(sg.query(r)-sg.query(l-1)),putchar('\n');
        else
        {
            x=read(); 
            if(x>1)del(x,l,r);
            //printf("sg:");sg.print(1,1,n);printf("\n");
        }
    }
    return 0;
}
```

---

## 作者：千反田 (赞：18)

## ~~前言的前言~~

算是在初一结束之前做了一道$Ynoi$的毒瘤题了吧。。。

也算了却了一个心愿吧。

## 前言

作为一个珂学家看到这题就立了个$flag$要$A$掉它

然后这题交了49遍才过~~这么浪费评测机资源会不会被打~~ 

换了三四种方法

最后被最后一个点卡了十几次

后来一怒之下把能换$int$的$long long$换了就过了(~~大雾~~)

## 正文

#### 前置芝士：线段树 $vector$ $iterator$ 

一开始我是根据官方题解的方法来做的

然而本蒟蒻不会平衡树 

只能暴力分解因子再暴力查询

结果不断卡常还是只有$43-58 pts$

~~因为我比较喜欢线段树所以我写的线段树~~

```cpp
#pragma GCC optimize("O3")
#pragma GCC optimize("Ofast")//请忽略这部分
#include<bits/stdc++.h>
#define rint register int
#define N 100005
#define Num 500005
typedef long long ll;
ll input[N],n,m;
std::vector<ll> f[Num];//存储每个数的因子
inline ll read(){//快读
    ll x=0;
    char ch=getchar();
    while(!isdigit(ch))
     ch=getchar();
    while(isdigit(ch))
     x=(x<<3)+(x<<1)+(ch^48),
      ch=getchar();
    return x;
}
namespace Segment_Tree{//线段树模板
    struct Tree{
        ll l,r,val;
    }tree[N<<2];
    void build(ll index,ll l,ll r){
        tree[index].l=l;
    	tree[index].r=r;
        if(l==r){
            tree[index].val=input[l];
    		return;
    	}
        ll mid=l+r>>1;
    	build(index<<1,l,mid);
    	build(index<<1|1,mid+1,r);
    	tree[index].val=tree[index<<1].val+tree[index<<1|1].val;
    	return;
    }
    void sub(ll index,ll dis,ll k){
    	tree[index].val-=k;
        if(tree[index].l==tree[index].r)
         return;
        if(dis<=tree[index<<1].r)
         sub(index<<1,dis,k);
        if(dis>=tree[index<<1|1].l)
         sub(index<<1|1,dis,k);
    }
    ll ask(ll index,ll l,ll r){
    	if(tree[index].l>=l&&tree[index].r<=r)
    	  return tree[index].val;
    	ll mid=tree[index].l+tree[index].r>>1,ans=0;
    	if(l<=mid)
    	 ans+=ask(index<<1,l,r);
        if(r>mid)
    	 ans+=ask(index<<1|1,l,r);
        return ans;
    }
}
using namespace Segment_Tree;
inline void trace(ll num){//暴力分解因子
    ll top=std::sqrt(num);
    for(rint i=2;i<=top;++i){
        if(num%i)
         continue;
        f[num].push_back(i);
    }
    ll count=f[num].size();
    for(rint i=count;i<count*2;++i)
     f[num].push_back(num/f[num][i-count]);
    f[num].push_back(num);
    return;
}
inline void find(ll l,ll r,ll k){//区间除
    if(k==1)
     return;
    for(rint i=l;i<=r;++i){
        ll key=INT_MAX;
        for(rint j=0;j<f[input[i]].size();++j){//暴力查找
            if(f[input[i]][j]==k){
                key=j;
                break;
            }
        }
        if(key==INT_MAX)
         continue;
        ll t=input[i];
        input[i]/=k;
        sub(1,i,t-input[i]);//线段树单点修改
    }
    return;
}
int main(){
    //freopen("input.txt","r",stdin);
    for(rint i=2;i<=500000;++i)
     trace(i); //分解因子
    n=read(),m=read();
    for(rint i=1;i<=n;++i)
     input[i]=read();
    build(1,1,n);
    for(rint i=1;i<=m;++i){
        ll q=read();
        switch(q){
            case 1:{
                //printf("it's question 1.\n");
                ll l=read(),r=read(),k=read();
                find(l,r,k);
                break;
            }
            case 2:{
                //printf("it's question 2.\n");
                ll l=read(),r=read();
                printf("%lld\n",ask(1,l,r));
                break;
            }
        }
    }
}
```

然后接下来一整天本蒟蒻都在考虑怎么优化

离线分解也莫名其妙T掉

平衡树我又不会

只能换一种做法

于是我把希望寄托于：

## vector

对于每一个$input[i]$，我们开一个$vector$，它们的值都是$input[i]$的因子，**即$f[i][j]$存的是所有是i的j倍数的数在原数组中的下标**，在输入的时候直接与处理好

但是如果暴力枚举还是会T掉

这是我们就要引进两个$STL$自带函数：

$lower$ $bound$

$upper$ $bound$

$lower$ $bound$和$upper$  $bound$都是利用二分查找的方法在一个排好序的数组中进行查找的。

在从小到大的有序数组中，

$lower$ $bound(begin,end,num)$：从数组的$begin$位置到$end-1$位置二分查找第一个大于或等于$num$的数字，找到返回该数字的地址，不存在则返回$end$。

$upper$ $bound(begin,end,num)$：从数组的$begin$位置到$end-1$位置二分查找第一个大于$num$的数字，找到返回该数字的地址，不存在则返回$end$。

这和这里有什么关系呢？

#### $lower$ $bound(f[k].begin(),f[k].end(),l)$到$upper$ $bound(f[k].begin(),f[k].end(),r)$刚好就是这个要改变的区间！

但是因为$lower$ $bound$ 和 $upper$ $bound$ 返回的是一个地址，所以要用$iterator$($STL$迭代器，珂以理解为$STL$的指针)来存储

除完之后我们要删除其他消失的因子

这时我们就要引进一个神奇的东西：$vector$自带的$erase$

但是$erase$正向删数会出现问题(删除一个数后后面的数下标都会 $-1$)，所以要反向删数，这个其他题解已近讲得很清楚了，这里不再赘述。

至此我们有了满分的$AC$代码：

# 祭上代码

```cpp
#pragma GCC optimize("O3")
#pragma GCC optimize("O2")
#pragma GCC optimize("Ofast")//同上
#include<bits/stdc++.h>
#define rint register int
#define N 100005
#define Num 500005
typedef long long ll;
int input[N],n,m;
std::vector<int> f[Num];//存储因子
std::vector<int>::iterator p1,p2,it;
std::vector<std::vector<int>::iterator> del;//存储要删除的数
inline void write(ll x){//快写
     if(x>9) 
      write(x/10);
     putchar(x%10+'0');
}
inline int read(){//快读
    int x=0;
    char ch=getchar();
    while(!isdigit(ch))
     ch=getchar();
    while(isdigit(ch))
     x=(x<<3)+(x<<1)+(ch^48),
      ch=getchar();
    return x;
}
namespace Segment_Tree{//线段树模板
    struct Tree{
        int l,r;
        ll val;
    }tree[N<<2];
    void build(int index,int l,int r){
        tree[index].l=l;
    	tree[index].r=r;
        if(l==r){
            tree[index].val=input[l];
    		return;
    	}
        int mid=l+r>>1;
    	build(index<<1,l,mid);
    	build(index<<1|1,mid+1,r);
    	tree[index].val=(ll)(tree[index<<1].val+tree[index<<1|1].val);
    	return;
    }
    void sub(int index,int dis,int k){
    	tree[index].val-=k;
        if(tree[index].l==tree[index].r)
         return;
        if(dis<=tree[index<<1].r)
         sub(index<<1,dis,k);
        if(dis>=tree[index<<1|1].l)
         sub(index<<1|1,dis,k);
    }
    ll ask(int index,int l,int r){
    	if(tree[index].l>=l&&tree[index].r<=r)
    	  return tree[index].val;
    	int mid=tree[index].l+tree[index].r>>1;
        ll ans=0;
    	if(l<=mid)
    	 ans+=ask(index<<1,l,r);
        if(r>mid)
    	 ans+=ask(index<<1|1,l,r);
        return ans;
    }
}
using namespace Segment_Tree;
inline void trace(int index,int num){//分解因子
    for(rint i=1;i*i<=num;++i){
        if(num%i)
         continue;
        f[i].push_back(index);
        if(num/i^i)
         f[num/i].push_back(index);
    }
}
inline void find(int l,int r,int k){
    if(k==1||f[k].empty()) //剪枝
     return;
    p1=std::lower_bound(f[k].begin(),f[k].end(),l);
    p2=std::upper_bound(f[k].begin(),f[k].end(),r);//查找区间
    if(p1==f[k].end())//剪枝
     return;
    del.clear();
    for(it=p1;it!=p2;++it){//暴力更新因子
        if(input[*it]%k)
         continue;
        int val=input[*it],w=val/k;
        sub(1,*it,input[*it]-input[*it]/k);
        input[*it]/=k;
        val=input[*it];
        if(val%k)
         del.push_back(it);
    }
    for(rint i=del.size()-1;i>0;--i)
     f[k].erase(del[i]); //暴力删除数
}
int main(){
    n=read(),m=read();
    for(rint i=1;i<=n;++i)
     input[i]=read(),trace(i,input[i]);//读入顺便处理
    build(1,1,n);//建树
    while(m--){
        int q=read();
        switch(q){
            case 1:{
                int l=read(),r=read(),k=read();
                find(l,r,k);
                break;
            }
            case 2:{
                int l=read(),r=read();
                write(ask(1,l,r));
                putchar('\n');
                break;
            }
        }
    }
}
```
$7.30$ $update$ 修改了一个小错误，增加了一些说明

---

## 作者：zx2003 (赞：15)

首先正如官方题解所述“瓶颈在于如何找出所有该被/的数而不在于如何维护”。

考虑离线来完成这一步。对于每个操作$(id=这是第几个询问，l,r,x)$，在$l$处添加$x$（具体操作是用一个`set<int> e[A+5];`，并`e[x].insert(id)`）然后在$r+1$处添加$x$的删除标记。这样就可以知道每个数受哪些询问的影响。

然后对于一个$a_i$，将它的因子（在500000以内最多200个）对于的`set<int>`的`\*begin()`取出来，以询问的先后顺序为关键字建立一个堆。然后模拟$a_i$不断除到1的情况，如果当前堆顶的数对应的x仍然是$a_i$的因子，那么就把堆顶的迭代器++后扔回堆中，否则弹掉堆顶，这样做预处理时n\*(建立大小为d的堆的时间+d次pop+(logw等于19)次push)的复杂度。

如果直接用普通的堆，那么是$ndlogd$。实测常数不是太大的话，是能AC的，~~尽管出题人扬言有空了要卡掉这种算法~~。

注意到pop的次数远大于push的次数，考虑快速($O(n)$)建立，快速($单次O(1)$)pop，慢速（单次$O(logn)$）push的数据结构。

然而这是不存在的，因为基于比较的排序是$O(nlogn)$的，而值域又是500000。

如果不考虑快速建立，那么平衡树是不错的选择，对于每个节点维护指向前驱后继的指针即可。

其实平衡树在原序列有序的情况下也能$O(n)$建立，然而每次直接`sort`会多log。

对于这一点，把所有元素离线下来（离线套离线，离线算法的子算法仍要离线，有趣），然后基数排序即可。

就这样，基数排序+平衡树+`set`+`vector`+树状数组总算达到了std的复杂度，然而已经不想写了。

据说原始平衡树版本的std有4到5K，可能不比我这种算法好多少？

可是分块版本的std又快又短。

我这种算法也只能是娱乐大众了。

下面是我原始的$ndlogd$的代码


```cpp
#pr\
agma GCC optimize("O2")
#include<vector>
#include<set>
#include<cstdio>
#include<cctype>
#include<queue>
using namespace std;
typedef long long ll;
inline void read(int&x){
    char c=getchar();
    for(;!isdigit(c);c=getchar());
    for(x=0;isdigit(c);c=getchar())x=x*10+c-48;
}
const int N=100005,A=500000;
vector<int> d[A+5],b[N];
vector<pair<int,int> > op[N];
set<int> e[A+5];
set<int>::iterator it;
int n,i,m,l[N],r[N],x[N],o[N],a[N],y,j,k,z;
ll s[N];
inline void add(int i,int x){for(;i<=n;i+=i&-i)s[i]+=x;}
inline ll query(int i){register ll ans=0;for(;i;i-=i&-i)ans+=s[i];return ans;}
struct node{
    int id;
    set<int>::iterator it;
    bool operator<(const node&rhs)const{
        return *it>*rhs.it;
    }
}xx;
struct pq{
    static const int N=450;
    int l[N],r[N],rt,d[N],q[N],t,w,t2;
    node v[N];
    int merge(int x,int y){
        if(!x || !y)return x|y;
        if(v[x]<v[y])t2=x,x=y,y=t2;
        r[x]=merge(r[x],y);
        if(d[r[x]]>d[l[x]])t2=l[x],l[x]=r[x],r[x]=t2;
        d[x]=d[r[x]]+1;
        return x;
    }
    inline void ini(){t=1,w=0;}
    inline void pb(const node&x){
        v[++w]=x;l[w]=r[w]=0;d[w]=1;q[w]=w;
    }
    inline void ini2(){
        for(;t<w;t+=2)q[++w]=merge(q[t],q[t+1]);rt=q[w];
    }
    const node& top(){return v[rt];}
    inline void pop(){rt=merge(l[rt],r[rt]);}
    inline bool empty(){return !rt;}
    inline bool push(const node&x){
        v[++w]=x;l[w]=r[w]=0;d[w]=1;rt=merge(rt,w);
    }
}qq;
int main(){
    //freopen("1.txt","r",stdin);freopen("2.txt","w",stdout);
    read(n),read(m);
    for(i=1;i<=n;++i)read(a[i]),add(i,a[i]);
    for(i=2;i<=A;++i)
        for(j=i;j<=A;j+=i)d[j].push_back(i);
    for(i=1;i<=m;++i){
        read(o[i]);read(l[i]);read(r[i]);
        if(o[i]==1)read(x[i]),b[l[i]].push_back(i),b[r[i]+1].push_back(i);
    }
    for(i=1;i<=n;++i){
        for(j=0;j<(int)b[i].size();++j){
            y=b[i][j];
            if(i==l[y])e[x[y]].insert(y);
                else e[x[y]].erase(y);
        }
        qq.ini();
        for(j=0;j<(int)d[a[i]].size();++j){
            y=d[a[i]][j];
            if(!e[y].empty())qq.pb((node){y,e[y].begin()});
        }
        qq.ini2();
        for(y=a[i];!qq.empty() && y>1;){
            xx=qq.top();qq.pop();
            it=xx.it;j=*it;
            if(y%x[j]==0){
                y/=x[j];
                op[j].push_back(make_pair(i,y));
                if(++it!=e[xx.id].end())qq.push((node){xx.id,it});
            }
        }
    }
    for(i=1;i<=m;++i){
        for(j=0;j<(int)op[i].size();++j){
            y=op[i][j].first,z=op[i][j].second;
            add(y,z-a[y]);a[y]=z;
        }
        if(o[i]==2)printf("%lld\n",query(r[i])-query(l[i]-1));
    }
    return 0;
}
                    
                    
```


---

## 作者：rui_er (赞：14)

本题是 P5610 的离线版双倍经验，使用该题做法删除在线的异或即可。

---

本题的难点主要在于如何快速找到需要修改的数。

我们可以使用并查集来维护对于每个质数我们需要修改的数的位置等信息，快速求出需要修改的最左侧，然后通过一种类似于指针的结构依次遍历，即可完成修改。

我们还需要一个数据结构来维护整串序列，并且因为有修改，需要支持单点改和区间查，可以使用常数小还好写的树状数组。

至此，我们便得出了一种解法。在此基础上再卡亿点点常数即可。

---

总结一下：我们维护并查集和树状数组，并查集用来快速求出所有需要修改的点，树状数组进行修改。

因为我们在程序最开始需要对所有数进行分解质因数，因此我们的复杂度为 $O(n\sqrt{x}+n\log{n}\times\alpha(n))$。

---

主要代码（已删除调试部分）：

```cpp
namespace BIT {
	ll s[N];
	void modify(int u, int x) {for(;u<=n;u+=u&(-u)) s[u] += x;}
	ll query(ll u) {ll res = 0; for(;u;u-=u&(-u)) res += s[u]; return res;}
}
namespace DSU {
	vector<int> fa[N], fa2[N];
	int find(int u, int v) {return (v == ll(fa2[u].size()) || v == fa2[u][v]) ? v : fa2[u][v] = find(u, fa2[u][v]);}
}
using DSU::fa;
using DSU::fa2;

void init() {
	n = read(); m = read();
	for(int i=1;i<=n;i++) {
		a[i] = read();
		int _ = sqrt(a[i]);
		for(int j=1;j<=_;j++) {
			if(!(a[i] % j)) {
				fa[j].push_back(i);
				fa2[j].push_back(fa2[j].size());
				if(j * j < a[i]) {
					fa[a[i]/j].push_back(i);
					fa2[a[i]/j].push_back(fa2[a[i]/j].size());
				}
			}
		}
		BIT::modify(i, a[i]);
	}
}
void modify(int l, int r, int x) {
	int pos = lower_bound(fa[x].begin(), fa[x].end(), l) - fa[x].begin();
	for(int i=DSU::find(x,pos);i<ll(fa[x].size())&&fa[x][i]<=r;i=DSU::find(x,i+1)) {
		if(!(a[fa[x][i]] % x)) {
			int _ = fa[x][i];
			BIT::modify(_, a[_]/x-a[_]);
			a[_] /= x;
		}
		if(a[fa[x][i]] % x) fa2[x][i] = i + 1;
	}
}
ll query(int l, int r) {return BIT::query(r) - BIT::query(l-1);}
```

---

## 作者：devout (赞：12)


> 在太阳西斜的这个世界里，置身天上之森。
> 等这场战争结束后，不归之人和望眼欲穿的人们，人人本着正义之名。
> 长存不灭的过去，逐渐消逝的未来。
> 我回来了，纵使日薄西山，即便看不到未来，
> 此时此刻的光辉，盼君勿忘。
> ——世上最幸福的女孩
#### 我永远喜欢珂朵莉~
5.20来切信仰题！

****

考虑操作$1$，每次把一个区间内$x$的倍数除以$x$
- 当$x=1$的时候，显然什么都不用做
- 当$x\geq 2$的时候，一个数最坏情况下只会被除$\log$次（每次都除$2$）就会变成$1$，然后就不能再除了

所以一共操作次数最多只有$n\log r$ 次，其中$r=\max\{a_i\}$，即值域

那么接下来我们就需要考虑如何快速的找出区间内是$x$的倍数的数

我们发现，对于任意$a_i\leq 5\times 10^5$，他最多最多只能有$\sqrt{a_i}$个因数，所以我们考虑给每一个因数建立一棵平衡树储存所有的满足$a_i$是这个因数的倍数的$i$，那么查询的时候直接$\text{FHQ Treap}$按照区间$split$就可以

这些平衡树的建立我们可以提前利用$O(n\sqrt{r})$的时间进行预处理

那么接下来我们需要一种数据结构能够支持 单点修改、区间查询 那么这个时候我们就可以想到建立树状数组来维护这个东西

最多删除$n\log r$次，每次需要花费$\log n$的时间

那么均摊下来的复杂度就是$O(n\sqrt r+n\log n\log r)$，空间复杂度是$O(n\sqrt r)$

在$n=10^5,r=5\times 10^5$，时限$4s$，空间限制$1.22GB$（这是个什么数？？？）的情况下**看上去**可以通过（Ynoi，你懂的

同时为了追求效率，我们应该每次建树的时候建出一棵笛卡尔树，否则会有几个点T掉，每次就把需要新建的部分存到数组里面然后暴力建树就可以（下面的$build$部分），这样就保证了建树是严格的$O(n)$而不会有多出来的$\log$

****
做法很简单，但是坑还是不少，这里简单列几个我掉进去的坑吧

- 我们在预处理的时候为了方便可以拿一个$vector$存相应的下标然后再扔到平衡树里，但是这个时候我们必须保证$vector$单调递增
- 在遍历区间的时候，我们即使是除也需要先判断能不能除尽（$12$分很可能就是挂在这里了），因为比如说有个$4$，他先除了个$2$，接下来又要除$4$，那么这个时候他不是$4$的倍数了，但是他还在$4$那棵平衡树里面
****
卡常的话，其实这题也不怎么卡啦...

如果最后两个点T了可以看看是不是写了`# define int long long`，就把树状数组开longlong就够了，~~能快三分之一~~

写完这题顺便还可以把大学给A了

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=5e5+5;
const int M=34e6+5;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n,m,top;
int a[N];
int root[N],tot;
int q[N],len;
int son[M][2],siz[M],val[M];
ll bit[N];
int bin[M],binsiz;
vector<int> fac[N];

void add(int o,int x){
    for(;o<=n;o+=o&-o)bit[o]+=x;
}  

ll ask(int o){
    ll res=0;
    for(;o;o-=o&-o)res+=bit[o];
    return res;
}

int newnode(int x){
    int u=(!binsiz)?++tot:bin[binsiz--];
    siz[u]=1;
    val[u]=x;
    return u;
}

void update(int x){
    siz[x]=siz[son[x][0]]+siz[son[x][1]]+1;
}

int build(int l,int r){
    if(l>r)return 0;
    int mid=l+r>>1;
    int u=newnode(q[mid]);
    son[u][0]=build(l,mid-1);
    son[u][1]=build(mid+1,r);
    return update(u),u;
}

int merge(int u,int v){
    if(!u||!v)return u|v;
    int rt;
    if(rand()<rand())son[rt=u][1]=merge(son[u][1],v);
    else son[rt=v][0]=merge(u,son[v][0]);
    return update(rt),rt;
}

void split(int o,int &u,int &v,int k){
    if(!o){u=v=0;return;}
    if(val[o]<=k)split(son[u=o][1],son[o][1],v,k);
    else split(son[v=o][0],u,son[o][0],k);
    update(o);
}

void del(int &rt,int x){
    int lft,mid,rht;
    split(rt,lft,rht,x);
    split(lft,lft,mid,x-1);
    rt=merge(lft,rht);
}

void dfs(int u,int k){
    if(!u)return;
    if(son[u][0])dfs(son[u][0],k);
    if(a[val[u]]%k==0)add(val[u],-a[val[u]]+a[val[u]]/k),a[val[u]]/=k;
    if(a[val[u]]%k==0)q[++len]=val[u];
    if(son[u][1])dfs(son[u][1],k);
    bin[++binsiz]=u;
    son[u][0]=son[u][1]=siz[u]=val[u]=0;
}

int main()
{
    srand(time(0));
    read(n),read(m);
    Rep(i,1,n)read(a[i]),top=max(top,a[i]),add(i,a[i]);
    Rep(i,1,n)
        for(int j=1;j*j<=a[i];j++)
            if(a[i]%j==0){
                fac[j].push_back(i);
                if(a[i]/j!=j)fac[a[i]/j].push_back(i);
            }
    Rep(i,2,top){
        len=0;
        for(vector<int>::iterator it=fac[i].begin();it!=fac[i].end();it++)
            q[++len]=*it;
        root[i]=build(1,len);
    }
    Rep(i,1,m){
        int opt,l,r,k;
        read(opt),read(l),read(r);
        if(opt==1){
            read(k);
            if(k==1)continue;
            int lft,mid,rht;
            split(root[k],lft,rht,r);
            split(lft,lft,mid,l-1);
            len=0;
            dfs(mid,k);
            mid=build(1,len);
            root[k]=merge(merge(lft,mid),rht);
        }
        else printf("%lld\n",ask(r)-ask(l-1));
    }
    return 0;
}
```


---

## 作者：浮尘ii (赞：12)

这是对官方题解的一个补充（貌似目前题解里就我按照官方题解思路来的）。

首先看到官方题解（见最底下的题解），直接对其进行模拟，可以有以下程序：


```cpp
int main()
{
    cin >> N >> M;
    for(int i = 1, j; i <= N; ++i) {
        scanf("%d", A + i);
        Modify(i, A[i]);
        for(j = 2; j * j < A[i]; ++j)
            if(A[i] % j == 0)
                S[j].insert(i), S[A[i] / j].insert(i);
        if(j * j == A[i])
            S[j].insert(i);
        S[A[i]].insert(i);
    }

    for(int o, l, r, x; M--; ) {
        scanf("%d%d%d", &o, &l, &r);
        if(o == 2)
            printf("%lld\n", Query(r) - Query(l - 1));
        else {
            scanf("%d", &x);
            for(set<int>::iterator it = S[x].lower_bound(l); it != S[x].end() && *it <= r; ) {
                int    i = *it, &t = A[i];
                if(t % x) {
                    S[x].erase(it++);
                    continue;
                }
                if(t / x % x)
                    S[x].erase(it++);
                else
                    ++it;
                Modify(i, t / x - t);
                t /= x;
            }
        }
    }

    return 0;
}
```
其中，S[]为set<int>，Modify和Query为树状数组的函数。

这样，可以拿到44~56pts.


接着我们考虑优化。

①把set改成手写平衡树（我用的是treap）。

②我们发现并不是所有的因子都要用到，只需要用到题目中需要查询的因子。故离线由500000棵优化为m棵。

③IO优化等各种卡常技巧。（#pragma GCC optimize(2) (划掉)）

这样，我们就可以拿到88~92pts.


然后，我们再考虑优化：

④分解因数的时候，并不需要每次都枚举到$\sqrt{a_i}$，我们可以先预处理出每个数的因子，根据调和级数，时间复杂度约为$O(m ln number)$.

⑤我们可以发现，每棵平衡树插入的序列是可以提前确定的，故我们不需要对每个元素进行insert，我们先把每棵平衡树的元素预处理出来（因数分解时记录，并且可以保证有序），接着用$O(size)$进行build即可。


通过这几个优化，即可通过此题。（为了减小题解的代码长度，我删除了IO优化和内存池等内容的代码）


```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <algorithm>

using namespace std;

typedef long long    ll;
const size_t        MaxN = 100005, MaxNumber = 500005;

int        N, M;
int        A[MaxN], O[MaxN], L[MaxN], R[MaxN], X[MaxN], X0[MaxN], Cnt;
int        ID[MaxNumber];
vector<int>    Fac[MaxNumber];
ll        C[MaxN];

//treap
struct node {
    int    key, fix;
    node    *ch[2];

    node(int val, int last): key(val), fix(last + rand())
    { ch[0] = ch[1] = nullptr; }
} *root[MaxN];

inline void rotate(node *&o, const int& d)
{
    node    *u = o->ch[d];
    o->ch[d] = u->ch[d ^ 1], u->ch[d ^ 1] = o;
    o = u;
}

vector<int>    Treap[MaxN];
void build(node *&o, const vector<int>& a, const int& l, const int& r, const int& last)
{
    if(l > r)
        return;
    int    m = l + r >> 1;
    o = new node(a[m], last);
    
    build(o->ch[0], a, l, m - 1, o->fix);
    build(o->ch[1], a, m + 1, r, o->fix);
}

vector<int>    buf;
void DFS(node *o, const int& l, const int& r)
{
    if(!o)
        return;
    if(o->key < l)
        DFS(o->ch[1], l, r);
    else if(o->key > r)
        DFS(o->ch[0], l, r);
    else
        buf.push_back(o->key), DFS(o->ch[0], l, r), DFS(o->ch[1], l, r);
}

void erase(node *&o, const int& val)
{
    if(!o)
        return;
    if(o->key == val) {
        if(!o->ch[0])
            o = o->ch[1];
        else if(!o->ch[1])
            o = o->ch[0];
        else {
            int    d = o->ch[1]->fix < o->ch[0]->fix;
            rotate(o, d);
            erase(o->ch[d ^ 1], val);
        }
    } else {
        int    d = val > o->key;
        erase(o->ch[d], val);
    }
}
//treap end

void modify(int x, const int& val)
{
    for(; x <= N; x += x & -x)
        C[x] += val;
}

ll query(int x)
{
    ll    ret = 0;
    for(; x; x ^= x & -x)
        ret += C[x];
    return ret;
}

int main()
{
    srand(19260817U);

    cin >> N >> M;
    for(int i = 1; i <= N; ++i) {
        scanf("%d", A + i);
        modify(i, A[i]);
    }

    for(int i = 1; i <= M; ++i) {
        scanf("%d%d%d", O + i, L + i, R + i);
        if(O[i] == 1) {
            scanf("%d", X + i);
            X0[++Cnt] = X[i];
        }
    }

    sort(X0 + 1, X0 + Cnt + 1);
    Cnt = unique(X0 + 1, X0 + Cnt + 1) - X0;
    for(int i = 1; i != Cnt; ++i) {
        int    &t = X0[i];
        if(t == 1)
            continue;
        ID[t] = i;
        for(int j = t; j <= 500000; j += t)
            Fac[j].push_back(i);
    }

    for(int i = 1; i <= N; ++i)
        for(auto j: Fac[A[i]])
            Treap[j].push_back(i);
    for(int i = 1; i != Cnt; ++i)
        build(root[i], Treap[i], 0, Treap[i].size() - 1, -2147483648);

    buf.reserve(N);
    for(int i = 1; i <= M; ++i) {
        int    &o = O[i], &l = L[i], &r = R[i], &x = X[i];
        if(o == 2)
            printf("%lld\n", query(r) - query(l - 1));
        else {
            int    k = ID[x];
            buf.clear();
            DFS(root[k], l, r);
            for(auto i: buf) {
                int    &t = A[i];
                if(t % x) {
                    erase(root[k], i);
                    continue;
                }
                if(t / x % x)
                    erase(root[k], i);
                modify(i, t / x - t);
                t /= x;
            }
        }
    }

    return 0;
}
```

---

## 作者：chenzida (赞：11)

![](http://www.akuziti.com/mb/cache/159670583162239.png)

**我永远喜欢珂朵莉！**

___________________

考虑到一个数 $x$ 如果被除了一次，那么一定会 $< \frac{x}{2}$，所以每一个数 $a[i]$ 被除的次数一定会 $<\log a[i]$，所以我们采用单点修改而不是区间修改（因为每次修改能够被整除的点所需要的时间为 $O(n\log n)$，是能过的）。

然后这题就结束了？不！远远没有。我们还不知道一个区间中有哪些点能够被读入的 $x$ 整除。那我们能怎么办呢？


我们可以对每一个 $x\in (2,\sqrt{\max{a[i]}})$ 都开一棵平衡树，会开一个 $root$ 数组，其中以  $rt[x]$ 为根平衡树中所有的数都是能够被 $x$ 整除的。而这个平衡树，我们选择使用 fhqtreap，因为它比 splay 更快，众所周知， Ynoi 卡常十分严重（虽然这题不是很卡常数）。

当我们要修改时，我们先读入 $l,r,x$，然后我们，把以 $rt[x]$ 为根的平衡树分裂（split）一下，分成三部分，$1-(l-1),l-r,(r+1)-n$。

然后我们找到中间（也就是 $l-r$）那一部分，并且将这以部分中的元素都找到。

接下来，我们需要一个能够单点修改、区间求和的数据结构，并且越快越好，那就是树状数组了~

总的复杂度是 $O(n\sqrt{\max{a[i]}}+n\log n\log(\max{a[i]}))$，应该是勉强能过的

几个细节：

1.树状数组那里要开 $long\ long$

2.我们一定要特判是否能够整除，比如一个24除完6之后它就不再是3的倍数了，但它还在3的那棵平衡树中。

3.这题由于要开很多棵平衡树，空间卡的很死，所以必须要进行“废物利用”，即将已经被删除的点的下标回收起来，用 $re$ 数组储存，然后用一个模拟栈的方式重新利用。

4.一定要判一下 `if(k==1) continue;`要不然会 $T$ 掉。

下面请见完整代码，如果还有不懂的可以看注释

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int NR=5e5+10;
const int MR=34e6+10;
int n,m; 
int mx=0;//找到a[i]中的最大值
int tot,len;//分别表示目前的总节点数以及建树的时候的长度 
int a[NR],q[NR];//分别表示读入的a[i]已经建树时的那个数组 
int rt[NR],son[MR][2];//rt[x]就是我解释中的rt，也就是那个能整除x的平衡树的根 
int val[MR],siz[MR];//val[u]表示u对应在a[i]数组的下标，siz表示fhq中的子树的结点数 
int re[MR],resiz;//re回收结点的数组，resiz是这个数组中都几个待回收的结点 
ll c[NR];//这个数树状数组的数组 
vector<int> ys[NR];//用一个vector统计因数 

int lowbit(int x){//树状数组标配lowbit 
	return x&(-x);
}

void add(int x,ll val)//树状数组单点修改函数 
{
	while(x<=n)
	{
		c[x]+=val;
		x+=lowbit(x);
	}
}

ll query(int x)//查询区间和 
{
	ll ans=0;
	while(x)
	{
		ans+=c[x];
		x-=lowbit(x);
	}
	return ans;
}

int newnode(int x)//新建一个结点 
{
	int u;
	if(resiz) u=re[resiz--];//如果有待回收的点，就废物利用 
	else u=++tot;//否则结点总是+1 
	val[u]=x;siz[u]=1;//初始化 
	return u;
}

void update(int x){//计算x的siz值 
	siz[x]=siz[son[x][0]]+siz[son[x][1]]+1;
}

int build(int l,int r)//用O(n)建树，否则可能会TLE 
{
	if(r<l) return 0;
	int mid=(l+r>>1);
	int u=newnode(q[mid]);//新建一个u结点 
	son[u][0]=build(l,mid-1);//建左子树 
	son[u][1]=build(mid+1,r);//建右子树 
	update(u);//计算u的siz 
	return u;
}

void split(int x,int &u,int &v,int k)//fhqtreap的分裂函数 
{
	if(!x){u=v=0;return;}
	if(val[x]<=k) split(son[u=x][1],son[x][1],v,k);
	else split(son[v=x][0],u,son[x][0],k);
	update(x);
}

int merge(int u,int v)//fhq的合并函数 
{
	if(!u||!v) return u|v;
	int root;
	if(rand()<rand()) son[root=u][1]=merge(son[u][1],v);
	else son[root=v][0]=merge(u,son[v][0]);
	update(root);
	return root;
}

void dfs(int u,int k)//处理操作1 
{
	if(!u) return;//如果到了叶子，直接return 
	if(son[u][0]) dfs(son[u][0],k);//如果它有左儿子，则将它左儿子里的点也除一下k 
	if(a[val[u]]%k==0)//如果能整除k 
	{
		add(val[u],-a[val[u]]+a[val[u]]/k);//直接改变一下这个值 
		a[val[u]]/=k;//除一下，方便之后判断是否能够整除k 
	}
	if(a[val[u]]%k==0) q[++len]=val[u];//如果仍然能整除，重新加入平衡树 
	if(son[u][1]) dfs(son[u][1],k);//如果它有右儿子，则将它右儿子里的点也除一下k 
	re[++resiz]=u;//待回收的点增加一个 
	son[u][0]=son[u][1]=0;//情况这些点 
	siz[u]=val[u]=0;
}

int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	srand(15402533);
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
		mx=max(mx,a[i]);
		add(i,a[i]);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j*j<=a[i];j++)
		{
			if(a[i]%j==0)
			{
				ys[j].push_back(i);
				if(j*j!=a[i]) ys[a[i]/j].push_back(i);
				//将因数加入这个vector 
			}
		}
	}
	for(int i=2;i<=mx;i++)
	{
		len=0;
		for(vector<int>::iterator it=ys[i].begin();it!=ys[i].end();it++)
			q[++len]=*it;
		rt[i]=build(1,len);
		//将vector里的元素建树 
	}
	for(int i=1;i<=m;i++)
	{
		int op=read(),l=read(),r=read();
		if(op==1)
		{
			int k=read();
			if(k==1) continue;
			int a,b,c;
			split(rt[k],a,c,r);
			split(a,a,b,l-1);
			//分裂成三部分 
			len=0;
			dfs(b,k);
			//dfs修改 
			b=build(1,len);
			rt[k]=merge(merge(a,b),c);
			//合并 
		}
		else
		{
			ll ans=query(r)-query(l-1);
			printf("%lld\n",ans);
			//输出答案 
		}
	}
	return 0;
}

```

---

## 作者：BEYOND_DELIBERATE (赞：8)

其实这道题有一种暴力std解法，我们吧每个操作都用差分-前缀和的方式处理，对于每个数查询它被哪些操作覆盖了。

从左到右扫描，将操作的序号插入x的set中，这样就从小到大了

显然一个数的因子数是sqrt（5e5）

那么我们只需要把它的因子对应的操作序号丢进堆里每次拿一个最小的来处理了，每次取完一个数，将它的下一个数丢进去（set中已经自动将序号排序了）

复杂度：

$$ \mathcal{O(Nlog^2N + N * logN * log(sqrt(N))) + N * logN *logN} $$


---

## 作者：_HMZ_ (赞：6)

在太阳西斜的这个世界里，置身天上之森。等这场战争结束之后，不归之人与望眼欲穿的众人， 人人本着正义之名，长存不灭的过去、逐渐消逝的未来。我回来了，纵使日薄西山，即便看不到未来，此时此刻的光辉，盼君勿忘。——世界上最幸福的女孩 珂朵莉

注：感谢wxw大佬提供的hack数据，这题数据实在很奇葩。

## 解题思路：

这道题需要维护区间除法，普通的线段树肯定是做不到的，可是像wxw大佬那样的卡常又不会。

但！是！这可是一道信仰题，怎么可以轻易放弃！

于是我们发挥瞎搞精神，线段树能做到的得做，不能做到的也得给我做（线段树：我招谁惹谁了我）。

既然区间除法不行，那单点除法肯定是行的，现在问题就转化为了在一个区间内如何快速找到 $x$ 的倍数。

暴力肯定不可行，那么我们就可以预处理一下，开 $n$ 个动态数组 $e$。

$e_i$ 表示能被 $i$ 整除的所有数的编号，编号肯定是递增的，就方便我们二分了。

每次遇到除法，就在 $e_x$ 里头找第一个大于等于 $l$ 和最后一个小于等于 $r$ 的数字，在这个区间内暴力单点修改。

但是有个问题，修改完之后有可能就不是 $x$ 的倍数了，所以这里要引进一个玄学优化。

每次记录操作 $1$ 除以 $x$ 的次数，如果次数很多，每操作一次就将不是 $x$ 的倍数的删除掉，这样以后暴力修改能快点。

事实上 $500000$ 大概除个 $19$ 次 $2$ 就差不多到 $1$ 了，时间复杂度上完全能接受。

## AC代码：

```cpp
#include<iostream>
#include<vector>
#include<cstdio>
using namespace std;
#define int long long 
namespace in { //快读模板
#ifdef faster
	char buf[1 << 21], * p1 = buf, * p2 = buf;
	inline int getc() { return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++; }
#else
	inline int getc() { return getchar(); }
#endif
	template <typename T>inline void read(T& t) {
		t = 0; int f = 0; char ch = getc(); while (!isdigit(ch)) { if (ch == '-')f = 1; ch = getc(); }
		while (isdigit(ch)) { t = t * 10 + ch - 48; ch = getc(); }if (f)t = -t;
	}
	template <typename T, typename... Args> inline void read(T& t, Args&... args) { read(t); read(args...); }
}
vector<int> e[500005];
int n, m, a[500005], t[500005], tree[2000005];
struct node
{
	int op, u, v, w;
}s[500005];
inline int find1(int now, int x)//二分
{
	int l = 0, r = e[x].size() - 1, ans = -1, mid;
	while (l <= r)
	{
		mid = (l + r) >> 1;
		if (e[x][mid] >= now)
		{
			ans = mid;
			r = mid - 1;
		}
		else l = mid + 1;
	}
	return ans;
}
inline int find2(int now, int x)
{
	int l = 0, r = e[x].size() - 1, ans = -1, mid;
	while (l <= r)
	{
		mid = (l + r) >> 1;
		if (e[x][mid] <= now)
		{
			ans = mid;
			l = mid + 1;
		}
		else r = mid - 1;
	}
	return ans;
}
inline void cf(int now, int x)//这里是预处理，将符合条件的数放进动态数组里
{
	for (register int i = 1; i * i <= now; ++i)
	{
		if (now % i == 0)
		{
			e[i].push_back(x);
			if (i * i != now)
				e[now / i].push_back(x);
		}
	}
}
inline void build(int now, int l, int r)//线段树基本操作
{
	if (l == r)
	{
		tree[now] = a[l];
		return;
	}
	int mid = (l + r) / 2;
	build(now * 2, l, mid);
	build(now * 2 + 1, mid + 1, r);
	tree[now] = tree[now * 2] + tree[now * 2 + 1];
}
inline void update(int now, int l, int r, int k, int x)
{
	if (l > k || r < k)
		return;
	if (l == k && r == k)
	{
		tree[now] /= x;
		return;
	}
	int mid = (l + r) / 2;
	update(now * 2, l, mid, k, x);
	update(now * 2 + 1, mid + 1, r, k, x);
	tree[now] = tree[now * 2] + tree[now * 2 + 1];
}
inline int query(int now, int l, int r, int x, int y)
{
	if (l > y || r < x)
		return 0;
	if (x <= l && r <= y)
		return tree[now];
	int mid = (l + r) / 2, res;
	res = query(now * 2, l, mid, x, y) + query(now * 2 + 1, mid + 1, r, x, y);
	return res;
}
inline void divide(int l, int r, int x)
{
	int head = find1(l, x), tail = find2(r, x);
	if (head == -1)
		return;
	for (register int i = head; i <= tail; ++i)
	{
		int now = e[x][i];
		if (a[now] % x == 0)
			a[now] /= x, update(1, 1, n, now, x);
		else if (t[x] >= 10000)//这里就是玄学优化
	    	e[x].erase(e[x].begin() + i), --i,--tail;
	}
}
signed main()
{
	in::read(n, m);
	for (register int i = 1; i <= n; ++i)
	{
		in::read(a[i]);
		cf(a[i], i);
	}
	build(1, 1, n);
	for (register int i = 1; i <= m; ++i)
	{
		in::read(s[i].op);
		if (s[i].op == 1)
		{
			in::read(s[i].u, s[i].v, s[i].w);
			++t[s[i].w];
		}
		else
			in::read(s[i].u, s[i].v);
	}
	for (register int i = 1; i <= m; ++i)
	{
		if (s[i].op == 1)
		{
			if (s[i].w == 1)
				continue;
			divide(s[i].u, s[i].v, s[i].w);
			--t[s[i].w];
		}
		else
			printf("%lld\n", query(1, 1, n, s[i].u, s[i].v));
	}
	return 0;
}
```


---

## 作者：Sai0511 (赞：6)

#### 首先纪念一下此题交了20遍就是因为一个小问题而导致挂了。。于是我要发个题解纪念一下。            
其实楼下已经有过$vector$的题解了，可是我认为真的讲的好难懂啊，我看了好几遍才看懂。。于是这里就给大家一个自认为比较好懂的题解。         
### 前置知识：        
树状数组：这个洛谷有模板，自己学习一下就好了。       
动态数组$(vector)$：这个，，再不会就自己上网查一下吧，有好多文章。            
### 我的思路：        
期望得分:$0\sim15$算法:模拟，暴力，这里代码就不给出来了，相信大家都会写。        
**满分算法（$100$分算法）**：         
①：平衡树，已经被人讲烂了，这里就不说了。      
②: $vector$:  
首先我们假设输进来的数组为$a$  
#### 对于$opt$为$1$的操作：   
那么我们可以开$MAXN$个$vector$类型的数组$yz$，
**$yz[i]$里存的东西代表能够整除$i$的数的下标**。
又假设输进来的区间最左值为$l$,最右值为$r$,查找的倍数为$div$的倍数     
这时我们只需要在$yz[div]$里查找是否含有$l$和$r$。    
这里的$C++$自带一个lower_bound和upper_bound函数，用来找一个数在这个数组里的出现的最小下标和最大下标。     
可是我们又要删数，那怎么办？**于是我们就又可以定义一个类型为$vector$迭代器**类型的$vector$类型$t$，用来在执行完$1$操作后将已经不是$div$的倍数的数删掉。          
#### 注意，$vector$的$erase$要慎用，为什么？       
比如，现在有$4$个数：      
```
1 2 7 5
```
现在我们要把$7$和$5$删掉，那么$t$数组里存的就是$0$和$1$，第一次时，$5$被删掉了。    
数列变成了：     
```
1 2 7
```      
这个时候$t$数组里还有一个$1$,那么就删掉了$2$,而不是$7$，这个时候就会出问题：             
#### 可是为什么在这里$vector$就是能用的呢？因为$yz$数组里的元素一定是从小到大排好序了的，所以$t$数组倒着删就一定不会出问题。
好了，1操作就这么点东西
### 那么我们再看2操作：     
2操作真没什么好说的，，开个树状数组乱搞就行了。。
## 话不多说，看代码：         
```cpp
#include<bits/stdc++.h>
#define MAXN 100010
#define Vit vector<int>::iterator
#define ll long long
#define MAXV 500010
using namespace std;
ll m,i,j,x,y,w,opt,z;
ll a[MAXN],n;
ll tree[MAXN];
vector<int> yz[MAXV];
Vit l,r,it;
vector<Vit> t;
namespace Fastio{
    ll read(){//快速输入
   	    ll x=0;char c=getchar();
        while(!isdigit(c)) c=getchar();
        while(isdigit(c)){x=x*10+c-48;c=getchar();}
        return x;
	}
    void write(ll x){//快速输出
        if(x/10>0) write(x/10);
        putchar(x%10+48);
        return;
    }
}
using namespace Fastio;
namespace Tree{//树状数组
    ll lowbit(ll x){return x&-x;}
    // lowbit函数
	void add(ll x,ll v,ll n){
    //修改某个元素的值，其实不是add的有意思，懒的改了
        while(x<=n){
            tree[x]+=v;
            x+=lowbit(x);
        }
        return;
    }
    ll sum(int x){//求1~x的数列的和
        ll ans=0;
        while(x!=0){
            ans+=tree[x];
            x-=lowbit(x); 
        }
        return ans;
    }
}
using namespace Tree;
int main(){
    n=read();m=read();
    for(i=1;i<=n;i++){
    	a[i]=read();
    	j=1;
      	for(j=1;j*j<=a[i];j++){
        //一个数/2的因子个数不可能超过这个数的sqrt
    		if(a[i]%j){continue;}
        //a[i]%j>0,代表不整除    
 			yz[j].push_back(i);//放入下标i
			if(a[i]/j!=j) yz[a[i]/j].push_back(i);	
        //注意，当一个数是平方时，这样子sqrt(a[i])就被放了两遍，就会出问题    
		}
		add(i,a[i],n);
	}
	while(m--){
		opt=read();
		if(opt==1){
			x=read();y=read();z=read();
			t.clear();
			if(x>y) swap(x,y);
            //这个其实完全不需要，懒得改了
			if(z==1||yz[z].empty()) continue;
			l=lower_bound(yz[z].begin(),yz[z].end(),x);
			r=upper_bound(yz[z].begin(),yz[z].end(),y);
			if(l==yz[z].end()) continue;
			//cout << *l <<' '<<*r << endl;
			for(it=l;it!=r; ++it){
				int k=a[*it];
				if(k%z) continue;
				int w=k/z;
				add(*it,-(k-w),n);
                //修改树状数组的值
				a[*it]/=z;
				k=a[*it];
				if(k%z) t.push_back(it);
                //当这个数除完之后已经不是div的倍数时，放入t数组
			}
			if(!t.empty())
            //如果这句话不写就会RE= =，调了20几次就是这句话。。
			for(i=t.size()-1;i>0;i--) yz[z].erase(t[i]);   //从yz数组里删去
		}
		else{
			x=read();y=read();
			write(sum(y)-sum(x-1));
			printf("\n");
		}
    }
    return 0;
}
```       
**注意，不保证此代码在任何时候都能过，因为有的时候评测人多评测机跑的慢，人少的时候跑得快。~~但是开了O2一定能过QAQ~~**




---

## 作者：critnos (赞：5)

事实上这道题的正解是 vector 。。。

你会发现导致 vector 复杂度不对的是删除操作。

其实可以同时建一个并查集，然后在删除数的时候合并一下。

在寻找的时候随便二分一下，然后利用并查集快速跳过被删除的数。

这样时间复杂度和平衡树是一样的，常数小，码量小。

本来我打算在加强版 P5610 发的，但是被 fz 抢先了。。。

---

## 作者：___new2zy___ (赞：4)

## 题解 P3987 【我永远喜欢珂朵莉~】

题目传送门：

https://www.luogu.org/problemnew/show/P3987

一道神仙毒瘤珂学卡常题。。。交了$17$发终于$A$了

~~（但是死活找不到哪里被我改对了）~~

写完之后为了纪念一下，就发了这篇题解

~~（感觉我的思路很多都和楼下一样QAQ）~~

先来扯一点没用的

其实本来学长打算下午给我们考一套模拟赛题目的。。。

题目一发下来就发现$T1$是这个题，于是机房同学们集体鸽掉了学长的模拟赛（雾）

但是作为珂学家的我没有鸽！还是依然写掉了这个题~~（结果写了一下午，也是醉了）~~

很早以前就想写掉这个题，但是一看平衡树的标签就吓得不轻。。。

但是~~现在还不会平衡树的我~~终于用非平衡树做法写完了！

咳咳。。。不说没用的，直接开讲！

前面的$5$个点(#$1$~#$5$)都是给的暴力分，乱搞一下就好了，这里不讲

直接来讲满分做法好了（这里用的是$vector$做法）

**操作$1$每次都要找出操作区间中$x$的倍数并除掉$x$**

emmm。。。发现如果再用暴力的做法来朴素的查找，效率十分低下

不妨换个思路

想必有人肯定已经做过这道题了吧：[P4168 [Violet]蒲公英](https://www.luogu.org/problemnew/show/P4168)

（没有做过的同学可以先往下看，以后再做）

做这题之前，我先做掉了这题，因此想到了下面的~~xjb写~~算法

蒲公英这题的第二种做法就和本题有着异曲同工之妙

什么意思呢？

在《蒲公英》那道题中，第二种做法的**思想是将元素的所有出现位置都按升序存在一个数组中，之后回答每次询问$[l,r]$只需要在每个元素对应的数组中二分出那些恰好在$l$和$r$内的元素**，从而得到该元素$A[i]$在区间$[l,r]$内的出现次数，即$num=upper$_$bound(A[i],r)-lower$_$bound(A[i],l)$


那么到了这道题上，我们也可以这样来做

不妨对于每一个元素$A[i]$，我们若干个数组，这若干个数组的键值都是$A[i]$的因子，即**数组$T[i]$存的是所有是$i$的倍数的数在原数组中的下标**

**同时我们保证每一个$T$数组内部都是有序（升序）的**

对于每一个操作$1$ $l$ $r$ $x$，都有如下的操作：

我们直接**在$x$对应的$T$数组内部进行二分查找**，找到那些恰好处于$[l,r]$的元素，直接将他们除掉$x$(即$A[*it]/=x$)，同时**对于这些除掉$x$的新数，如果发现它不再是$x$的倍数**(也可以理解成$x$不再是新$A[*it]$的因子)**就将新$A[*it]$从$x$所对应的$T$数组中删去**

但是现在问题又来了，**如何从$x$所对应的$T$数组中删去一个数呢？**

别忘了我们使用的是一个非常神奇的东西，叫做$vector$。$vector$内部自带了一个函数叫做$vector.erase()$，它可以将一个数从该$vector$数组中删去

那好了，现在问题就解决了，我们可以开始~~水掉~~解决这道题了（雾）

还没完！哪能那么简单让你这么$A$掉一道紫题？？？

$vector.erase()$函数的神奇之处在于，不仅可以帮你删掉一些数，还可以把你卡死

如果直接正向删数，就会像我一样$WA$好多次

$Why?$

**$vector.erase()$函数删掉一个数之后原其后剩下的数回会整体向$0$方向平移一个单位**

这又是什么意思呢？

其实最开始我也是错了很多次，最后~~乱改~~才$A$掉的

写完之后来翻了一下题解，发现楼下的一位神仙给出了一个例子：

（引用楼下的例子）

如果我们的某一个$T$数组中存的是这样的序列：

$1$ $2$ $7$ $5$

假设现在我们要删掉$7$和$5$

那么对应的删除下标为$1$和$0$

正向来删除数的话，我们应该先删掉$0$位置的元素，即$5$

那么现在变成了$1$ $2$ $7$，此时我们还要删掉$7$

但是如果删掉$1$位置的元素，那么就会删掉$2$，而不是$7$

因此**正向删数就会出问题**

但是再回来考虑这道题，我们**已经保证了每一个$T$数组内部都是有序（升序）的**

因此我们**不能正向删数，但是反向删数就没问题**

（如果还是不懂，可以按照上面的例子模拟一下）

那么到了这里操作$1$也就算讲完了吧

操作$2$嘛。。。就是查询区间和，用树状数组和线段树都可以搞

同时注意一下，**每个数$A[i]$在除掉$x$之后，要直接在线段树或树状数组对应的位置进行单点修改，由于$A[i]$除掉了$x$，因此修改$A[i]$贡献就是$-(A[i]-A[i]/x)$**

那么就没啥了吧，下面放一波代码

PS：请忽略一些奇怪的变量名，比如树状数组BLT，应为BIT

~~（因为我最开始学的时候就记错了$233$）~~

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<vector>
#define re register
using namespace std;
typedef long long ll;
char IN[1<<17],*SS=IN,*TT=IN;
inline char gc(){return (SS==TT&&(TT=(SS=IN)+fread(IN,1,1<<17,stdin),SS==TT)?EOF:*SS++);}
inline int read()//fread一发入魂 
{
    int now=0,f=1;re char c=gc();
    for(;!isdigit(c);c=='-'&&(f=-1),c=gc());
    for(;isdigit(c);now=now*10+c-'0',c=gc());
    return now*f;}
const int maxn=100003;
const int maxk=500003;
int n,Q,A[maxn];
vector<int> T[maxk];
vector<int>::iterator pos1,pos2,it;
vector<vector<int>::iterator > be_to_del;
namespace BLT//树状数组 
{
	ll tr[maxn];
	inline int lowbit(int x){return x&(-x);}
	inline void add(int x,int k){while(x<=n)tr[x]+=k,x+=lowbit(x);}
	inline ll sum(int x,ll s=0){while(x)s+=tr[x],x-=lowbit(x);return s;}
	inline ll query(int l,int r){return sum(r)-sum(l-1);}
}
using namespace BLT;
inline void work(int pos,int x)//把x的位置存入其因子的对应T数组中 
{
	for(re int i=1;i<=sqrt(x);i++)
		{
			if(x%i)continue;
			T[i].push_back(pos);
			if(x/i!=i)T[x/i].push_back(pos);
			//注意平方数的判断 
		}
}
inline void Clean()
{
    vector<vector<int>::iterator> tmp;
    swap(tmp,be_to_del);
}
inline void change(int l,int r,int k)
{
	if(k==1||T[k].empty())return ;
	pos1=lower_bound(T[k].begin(),T[k].end(),l);
	pos2=upper_bound(T[k].begin(),T[k].end(),r);
	Clean();
	for(it=pos1;it!=pos2;++it)//暴力更新 
		{
			if(A[*it]%k)continue;
            add(*it,-(A[*it]-A[*it]/k)),A[*it]/=k;
            if(A[*it]%k)be_to_del.push_back(it);
            //把不再是k的倍数的数都丢进待删除数组 
		}
	if(be_to_del.empty())return ;
	for(re int i=be_to_del.size()-1;i>=0;i--)
		T[k].erase(be_to_del[i]);//倒序删除数 
}
int main()
{
	n=read(),Q=read();
	for(re int i=1;i<=n;i++)
		A[i]=read(),add(i,A[i]),work(i,A[i]);
	while(Q--)
		{
			int flag=read();
			if(flag==1)
				{
					int x=read(),y=read(),k=read();
					change(x,y,k);
				}
			else if(flag==2)
				{
					int x=read(),y=read();
					printf("%lld\n",query(x,y));
				}
		}
	return 0;
}
```
可能写完之后才发现这题是多么的珂学~~毒瘤~~（大雾）

到这里就没什么了，感谢你的阅读！

最后~~无耻的~~推一波我的$blog$：

https://www.luogu.org/blog/new2zy/

拜拜~~~








---

## 作者：feicheng (赞：3)

## $\text{Preface}$

前几天做了这道题，讲课就讲了一下，决定来写一篇题解。

我永远喜欢珂朵莉~

有没有大佬教教我怎么卡过 P5610 啊/kk。

## [$\text{Description}$](https://www.luogu.com.cn/problem/P3987)

给定 $n$ 个数，有如下两个操作：

`1 l r x` 给 $[l,r]$ 内中 $x$ 的倍数除以 $x$。

`2 l r ` 查区间和。

$1 \le n,m \le 10^5,1\le a_i,x \le 5\times 10^5$

## [$\text{Solution}$](https://www.luogu.com.cn/paste/905ygoyd)

我们如果将操作变成：对于 $[l,r]$ 的数除以 $x$（下取整），那这道题就会非常好做。因为可以证明的是一个数最多除以 $\log$ 次就可以除到 $0$，所以直接暴力修改，线段树维护区间和区间最大值即可。

所以我们的问题实际在于如何精准的找出一个区间内 $[l,r]$ 的 $x$ 的倍数。

这个时候我们回头看一眼空间限制：1.22GB，再看一眼值域: $x\in [1,500000]$。

我们可以暴力的对每一个数都建一棵平衡树（其结构有点类似于不借助原树结构而直接重新建树的可持久化平衡树）。

这里我使用的是 fhq-treap。

我们先预处理，将每一个 $a_i$ 的因子所在的平衡树编号中插入 $i$ 这个位置，在这里推荐用 $\Theta(n)$ 地建树（毕竟是 lxl 的题），具体怎么建树可以看链接里的代码。

对于操作 $1$，我们 dfs $x$ 对应的平衡树，如果某个节点对应的值是 $x$ 的倍数，就直接暴力修改。同时对于每一个节点检验其是否是 $x$ 的倍数，如果不是就删除该节点。

但是这里有个问题：既然这个节点在 $x$ 对应的平衡树里，难道不应该是因为他是 $x$ 的倍数才可以吗？

其实并不是这样子：假设我先进行区间除以 $4$，再进行区间除以 $2$，而在区间除以 $2$ 的时候有的节点已经被除以 $4$，可能就不再是 $2$ 的倍数了，这一步起到了一个特判的作用，同时保证了正确性。

对于操作 $2$，直接用树状数组统计即可。

细节见代码。

---

## 作者：2018heyuyang (赞：3)

### 这里给出几种强力的剪枝操作

目前跑到所有$100$分里的第二名，时间：$2019/09/18$

设输入进来的是$a$数组

1. 开一个$50$万的$vector$，我用$sta$表示

2. 把$a[i]$分解，求出它的所有$>=2$的**约数**（包括它自己）

3. **对于每个$a[i]$，如果它含有一个约数$x$**，那么就把 $i$ 丢进$sta[x]$里

4. 执行完上面的操作后，可以知道，**若$sta[x]$里面有一个值 $i$ ，则$a[i]$为$x$的倍数**

5. 建$50$万颗平衡树（我用的$splay$，注意空间开大点，我开了$3000$万）

6. 从$1$到$n$，把$sta[i]$里头的数值（即一堆$a$数组的下标）丢进平衡树里

7. 用树状数组（单点修，区间查）维护$a$数组的区间和

8. 输入$m$个操作，若操作为区间求和，直接树状数组输出即可

9. 若操作为区间修改，除以的数为$x$，则找到第$x$颗平衡树，再找到 $l$ 的前驱 $lc$，找到 $r$ 的后继 $rc$（注意 $l$ 和 $r$ 是值，$lc$ 和 $rc$ 是平衡树里点的编号）；把 $lc$ 翻到根节点， $rc$ 翻到 $lc$ 右孩子，那么 $rc$ 的左子树就包含着(你要除的(那些数(的下标))) ~~滑稽断句~~

10. 遍历 $rc$ 的左子树，取出所有的下标，对一个值为 $i$ 的下标，又进行下列操作

11. 若$a[i]$不是$x$的倍数，则删掉这个点（平衡树的点），否则把 $a[i]$ 除以 $x$ 并修改树状数组的值，若 $a[i]$ 除完后不再是 $x$ 的倍数，则删掉这个点

为什么一开始就要判$a[i]$是不是$x$的倍数呢，就比如数字$6$，除完一个$2$，剩个$3$，显然，它已经不是$6$的倍数了，但第$6$颗平衡树里还保留着这个节点，所以……你懂得啦

**好的，上面是基本操作，不加剪枝优化会T，T到飞起**

剪枝1：在分解约数的时候，舍弃$O(\sqrt n)$的分解方法，改为用线筛预处理，$O(logn)$分解质因数，再用递归组合约数的方法

剪枝2：删平衡树的点时先用栈存起来，操作结束后再删掉

剪枝3：不需要建$50$万颗平衡树，用一个$bool$数组记录有没有建过这棵树，等到修改操作的时候再建树即可

注意事项：

$ $ $ $ -1. 代码打整齐，好调一些

0. 背好你的平衡树板子

1. $RE$的同学可能是因为数组开太小了

2. $a$数组里面有一些值为$0$或$1$的，要跳过

3. 除以 $x$ 时，若 $x$为$1$，跳过

4. 除以 $x$ 时，若 $sta[x]$为空，跳过

5. 建平衡树时多插入两个哨兵节点，防玄学$RE$

6. 加上$fread$以获得更快的速度

7. 十年$OI$一场空，不开$long$ $long$见祖宗

最后上代码，复杂度$O(nlog^2n)+$巨大常数

```cpp
#include<cstdio>
#include<vector>
#define R register
using namespace std;
typedef long long ll;
int v[500005],pri[100005],tp=0;
void find()
{
	for(int i=2;i<=500000;i++)
	{
		if(!v[i])
		{
			pri[++tp]=i;v[i]=i;
		}
		for(int j=1;j<=tp&&i*pri[j]<=500000;j++)
		{
			v[i*pri[j]]=pri[j];
			if(i%pri[j]==0)break;
		}
	}
}
int n,m,tmp=0;
int a[100005];ll sum[100005];
inline int lowbit(int x){return x&-x;}
inline void add(int x,ll k){while(x<=n){sum[x]+=k;x+=lowbit(x);}}
inline ll getsum(int x){ll ans=0;while(x){ans+=sum[x];x-=lowbit(x);}return ans;}
vector<int>sta[500005];
struct node
{
	int d,f,son[2];
}tr[30000005];int len=0,rt[500005];
inline void rotate(int x,int w)
{
	int f=tr[x].f,ff=tr[tr[x].f].f;
	
	tr[f].son[1-w]=tr[x].son[w];
	if(tr[x].son[w]!=0)tr[tr[x].son[w]].f=f;
	
	tr[x].son[w]=f;tr[f].f=x;
	
	if(tr[ff].son[0]==f)tr[ff].son[0]=x;
	else tr[ff].son[1]=x;
	tr[x].f=ff;
}
inline void splay(int now,int x,int rot)
{
	while(tr[x].f!=rot)
	{
		int f=tr[x].f,ff=tr[tr[x].f].f;
		if(rot==ff)
		{
			if(tr[f].son[0]==x)rotate(x,1);
			else rotate(x,0);
		}
		else
		{
				 if(tr[f].son[0]==x&&tr[ff].son[0]==f){rotate(f,1);rotate(x,1);}
			else if(tr[f].son[1]==x&&tr[ff].son[1]==f){rotate(f,0);rotate(x,0);}
			else if(tr[f].son[0]==x&&tr[ff].son[1]==f){rotate(x,1);rotate(x,0);}
			else if(tr[f].son[1]==x&&tr[ff].son[0]==f){rotate(x,0);rotate(x,1);}
		}
	}
	if(rot==0)rt[now]=x;
}
inline int findip(int now,int d)
{
	int x=rt[now];
	while(tr[x].d!=d)
	{
		if(d<tr[x].d)
		{
			if(tr[x].son[0]==0)break;
			x=tr[x].son[0];
		}
		else
		{
			if(tr[x].son[1]==0)break;
			x=tr[x].son[1];
		}
	}
	return x;
}
inline int findqianqu(int now,int d)
{
	int x=findip(now,d);splay(now,x,0);
	if(tr[x].d>=d&&tr[x].son[0]!=0)
	{
		x=tr[x].son[0];
		while(tr[x].son[1]!=0)x=tr[x].son[1];
	}
	return x;
}
inline int findhouji(int now,int d)
{
	int x=findip(now,d);splay(now,x,0);
	if(tr[x].d<=d&&tr[x].son[1]!=0)
	{
		x=tr[x].son[1];
		while(tr[x].son[0]!=0)x=tr[x].son[0];
	}
	return x;
}
int b[100005],cnt;//垃圾桶数组 
inline void del(int now,int x)
{
	splay(now,x,0);
	int p=tr[x].son[0];
	while(tr[p].son[1]!=0)p=tr[p].son[1];
	splay(now,p,x);
	int rc=tr[x].son[1];
	tr[p].f=0;rt[now]=p;
	tr[p].son[1]=rc;tr[rc].f=p;
}
void dfs(int now,int x)
{
	if(a[tr[x].d]%now)b[++cnt]=x;
	else
	{
		a[tr[x].d]/=now;
		add(tr[x].d,1ll*a[tr[x].d]*(1-now));
		if(a[tr[x].d]%now)b[++cnt]=x;
	}
	if(tr[x].son[0])dfs(now,tr[x].son[0]);
	if(tr[x].son[1])dfs(now,tr[x].son[1]);
}
void fuck(int now,int l,int r)
{
	int lc=findqianqu(now,l),rc=findhouji(now,r);
	splay(now,lc,0);splay(now,rc,lc);
	cnt=0;
	if(tr[rc].son[0])dfs(now,tr[rc].son[0]);
	for(R int i=1;i<=cnt;i++)del(now,b[i]);
}
void build(int l,int r)
{
	int mid=l+r>>1;
	int cow=++len;tr[cow].d=b[mid];
	if(l<mid){tr[cow].son[0]=len+1;tr[len+1].f=cow;build(l,mid-1);}
	if(mid<r){tr[cow].son[1]=len+1;tr[len+1].f=cow;build(mid+1,r);}
}
void bt(int now)
{
	b[cnt=1]=0;
	for(R int i=0;i<sta[now].size();i++)b[++cnt]=sta[now][i];
	b[++cnt]=n+1;
//	for(int i=2;i<cnt;i++)printf("%d ",b[i]);puts("");
	rt[now]=len+1;
	build(1,cnt);
}
inline void ins(int now,int x){sta[now].push_back(x);}
#define g (p1==p2&&(p2=(p1=buf)+fread(buf,1,size,stdin),p1==p2)?EOF:*p1++)
const int size=1<<20;
char buf[size],*p1=0,*p2=0;
inline int read()
{
	R int s=0;R char c=g;
	while(c<48)c=g;
	while(47<c)s=(s<<1)+(s<<3)+(c^48),c=g;
	return s;
}
void print(ll x)
{
	if(x>9)print(x/10);
	putchar(x%10+48);
}
struct fuc
{
	int z,t;
}sb[23];int tot;
void bfs(int p,int last,int t,int ss)
{
	ins(ss,p);
	if(t<sb[last].t)bfs(p,last,t+1,ss*sb[last].z);
	for(int i=last+1;i<=tot;i++)bfs(p,i,1,ss*sb[i].z);
}
bool uke[500005];
int main()
{
	find();
	n=read();m=read();
	for(R int i=1;i<=n;i++)
	{
		a[i]=read();add(i,1ll*a[i]);
		if(tmp<a[i])tmp=a[i];
		if(a[i]<2)continue;
		int j=a[i];
		if(v[j]==j){ins(j,i);continue;}
		tot=1;sb[1].z=v[j];sb[1].t=1;
		while(v[j]!=j)
		{
			if(v[j/v[j]]==sb[tot].z)sb[tot].t++;
			else{sb[++tot].z=v[j/v[j]];sb[tot].t=1;}
			j/=v[j];
		}
		for(int k=1;k<=tot;k++)bfs(i,k,1,sb[k].z);
	}
	while(m--)
	{
		R int cz=read(),l=read(),r=read();
		if(cz==1)
		{
			R int x=read();
			if(x>1&&sta[x].size())
			{
				if(!uke[x]){uke[x]=1;bt(x);}
				fuck(x,l,r);
			}
		}
		else print(getsum(r)-getsum(l-1)),puts("");
	}
	return 0;
}
```


---

## 作者：EDT_ (赞：3)

这题很珂学啊～

这里提供一种用暴力卡过的方法

因为一个数的因数个数并不会很多，用`std::set`维护每个因子的倍数出现的位置，

执行操作的时候直接暴力`lower_bound`找出对应的位置然后判断是否删除就可以了，区间和用一个树状数组维护一下就行。

就如题解里面所说，这样是过不了的，我开了`O2`也只得到了`39`分

这个时候别人说要手写平衡树然后在树里面`DFS`删除..而且需要各种各种卡常，想想就好麻烦

其实STL是很强大的

直接把`std::set`换成`std::vector`然后就可以辣。

因为按照顺序把数插入`std::vector`删除也是顺着删除，所以`vector`自然有序

虽然想到`vector.erase()`的复杂度貌似很爆炸。。

而`std::vector`是一个神奇的东西，就可以卡过了。。

大概是删除的东西也不会很多，数据的因子比较分散造成的吧

出题人也没有卡这个毒瘤做法呢。。。

貌似复杂度很爆炸，特别是每次`erase`竟然是O(因子个数)的，要卡其实很好卡掉的QAQ

但是这个比其它5KB，6KB甚至更长的代码好写多了吧

因为没有`O2`STL会慢一点，我也没怎么特意去卡常，所以会T后两个点。。

开`O2`可以把最后一个点用`3960ms`卡过去。。。

[代码](https://www.luogu.org/paste/h9k1arud)

---

## 作者：云浅知处 (赞：2)

算是[大学](https://www.luogu.com.cn/problem/P5610)那题的弱化版？时限放到了 4s，也不强制在线了qwq

~~其实是大学那题把我卡没了/kk~~

------------

# Description

给一个长为 $n$ 的序列 $A$，有 $m$ 次操作，需要支持：

- 给区间 $[l,r]$ 内所有 $x$ 的倍数除以 $x$
- 区间求和

$1\le n,m\le10^5,0\le A_i\le5\times10^5,1\le x\le5\times10^5$。

------------

# Solution

区间求和就不多说了吧qwq。

这里主要说一下第一种操作。

看到操作后立马感觉懒标记之类的基本不可能......

所以咋办/fad

我们考虑一个数不管除以个什么东西，都会至少减半。

所以对于 $A_i$，顶多给它除个 $\log A_i$ 次就会变成 $1$，然后就不是任何数的倍数，除以 $1$ 也不会再变，不用再去管他了。

所以用一种类似 [GSS4](https://www.luogu.com.cn/problem/SP2713) 那道的思想，我们直接找到每个需要修改的数，一个一个修改。

ps：那题我也写了[题解](https://www.luogu.com.cn/blog/wwwluogucn/solution-sp2713)，欢迎参观qwq

然后这题的难点就在于：怎么快速找到应该修改的数啊orz。

这不像 GSS4，那个给定了是一个区间内的所有数，但是这题修改的可不是整个区间啊qwq......

如果暴力扫一遍修改区间显然不可能。

之前看到这题之后就直接卡到了这里，然后弃疗了qwq。

直到某谷网校第三次tg模拟赛的时候出了某个题，大概也是约数相关的，于是学到了用冰茶姬来处理约数个数的好办法qwq（

（题目保密，想看题目请左转报名秋令营）

所以我们回来说说这道题该怎么处理。

由于 $A_i$ 和 $x$ 的范围只有 $5\times10^5$，所以我们直接用 DS，对于每一个 $k$，处理出序列 $A$ 中所有 $k$ 的倍数的位置。

这个很好处理，直接输入的时候随便搞一下就行了。

那么我们看看要对这个数据结构进行什么操作：

- 由于除以 $k$ 可能会导致这个数不再是 $k$ 的倍数，所以需要支持删除操作。
- 由于限定了要在 $[l,r]$ 中找数，所以还需要支持 `lower_bound`。
- 然后显然要支持单点查询。

此时答案已经呼之欲出了：直接 Splay 或者 Treap 之类的平衡树硬搞就行了！

那么我们对于 $1\le k\le 5\times10^5$ 的所有 $k$，建一棵平衡树维护就行了。

也就是说，建 $5\times 10^5$ 棵平衡树。

然而我说过，我用的是冰茶姬，那么冰茶姬该怎么搞呢qwq

我们在我们维护的这个序列（**注意，是我们维护的这个序列，也就是 $k$ 的所有倍数这个，而不是原序列 $A$**）中，对每个位置，预处理出它的下一个没有被删除的位置 `it`。

显然初始每个 `it` 都指向自己。

然后 `lower_bound` 的时候直接用这些 `it` 来处理就行了，这些 `it` 可以直接用冰茶姬维护。

~~所以说和某谷网校的那个模拟题没啥联系，冰茶姬的处理方式都不一样~~

这样的话就没什么问题了qwq。

最后提一嘴复杂度：预处理复杂度是 $O(n\sqrt{A})$，单次操作显然是 $O(\log n)$，所以总复杂度为：$O(n\sqrt{A}+m\log n)$。

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<cstring>
#include<cctype>
#include<iostream>

#define MAXN 100005
#define LL long long
#define RE register
#define int long long

using namespace std;

inline LL qread(){
	RE char ch=getchar();
	RE LL x=0,f=1;
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-48;
		ch=getchar();
	}
	return x*f;
}

int a[MAXN];
int n,m;
LL c[MAXN];
vector<int>it[500005];

vector<int>fa[500005];
inline int find(int x,int v){
	if(v==fa[x].size()||v==fa[x][v])return (v);
	return (fa[x][v]=find(x,fa[x][v]));
}

struct BIT{
	inline int lowbit(int x){
		return x&(-x);
	}
	
	inline void modify(int x,LL k){
		for(RE int i=x;i<=n;i+=lowbit(i)){
			c[i]+=k;
		}
	}
	
	inline LL Sum(int x){
		LL ans=0;
		for(RE int i=x;i;i-=lowbit(i)){
			ans+=c[i];
		}
		return ans;
	}
};
BIT tree;

inline void pre(){
	n=qread();
	m=qread();
	for(RE int i=1;i<=n;i++){
		a[i]=qread();
		tree.modify(i,a[i]);
	}
	for(RE int i=1;i<=n;i++){
		for(RE int j=1;j*j<=a[i];j++){
			if(a[i]%j==0){
				it[j].push_back(i);
				fa[j].push_back(fa[j].size());
				if(j*j!=a[i]){
					it[a[i]/j].push_back(i);
					fa[a[i]/j].push_back(fa[a[i]/j].size());
				}
			}
		}
	}
}

inline void change(int l,int r,int x){
	int pos=find(x,lower_bound(it[x].begin(),it[x].end(),l)-it[x].begin());
	while(pos<it[x].size()&&it[x][pos]<=r){
		int u=it[x][pos];
		if(a[u]%x==0){
			tree.modify(u,a[u]/x-a[u]);
			a[u]/=x;
		}
		if(a[u]%x!=0)fa[x][pos]=pos+1;
		pos=find(x,pos+1);
	}
}

signed main(void){
	
	pre();
	LL ans=0;
	while(m--){
		int op,l,r;
		op=qread();
		l=qread();
		r=qread();
		if(l>=r)swap(l,r);
		if(op==1){
			LL x=qread();
			if(x==1)continue;
			change(l,r,x);
		}
		else{
			ans=tree.Sum(r)-tree.Sum(l-1);
			printf("%lld\n",ans);
		}
	}
	
	return 0;
}
```

---

## 作者：lemir3 (赞：2)

~~然而我喜欢奈芙莲.~~

题目意思很好懂,就是一个区间除和一个区间求和.

考虑用splay每次旋转出要操作的区间,打标记求解.

但是发现这个标记没法维护,但是发现数的大小只有5e6,可以对每一个数字建一颗平衡树,里面插入的点是原序列上被这个数字整除的数的下标,平衡树按照下标排序,操作中的要除以这个数直接用这个数的平衡树旋转出要除的区间即可,求和使用树状数组求解.

先找出操作区间的左端点在除数对应的树上的前驱和右端点在树上的后继,把前驱旋转到根,把后继旋转到前驱的下面,因为后继一定大于前驱,所以后继这个点在前驱的右儿子上,很显然后继的左儿子就全部包含了在操作区间内的点了.

然后在后继的左儿子这颗子树上进行dfs,直接在原序列上除以操作的数,并在树状数组上更改一下.如果除以了这个数之后这个原序列上的数不被这个数整除了,就把它从这个数字对应的splay上删掉,为了防止影响递归结构,我们可以在回溯的时候判断是否删除,要删的话就将它的儿子节点不断上旋,把它旋到叶子节点上直接删除即可.

对于建树,我们可以直接预处理出原序列上哪些位置的数被某个数整除,然后插入这个数对应的splay上,按照原序列下标处理的话预处理出的位置是有序的,所以可以直接递归建立一颗完美的splay.

## 代码

```cpp
#define lxl int
#define R register
#define INF 0x3f3f3f3f
#define debug(x) printf("debug:%d\n",x)
#define debugf(x) printf("debug:%llf\n",x)
#define lowbit(x) (x&-x)
const lxl maxn=40000010,maxm=500010,maxt=100010;
lxl n,m,NodeCnt,MaxA;
lxl root[maxm],a[maxt],fa[maxn],c[maxn][2],size[maxn],val[maxn],q[maxn];
long long t[maxt];
std::vector<lxl>v[maxm];
inline void modify(lxl x,lxl val){for(;x<maxt;x+=lowbit(x))t[x]+=val;}
inline long long query(lxl x)
{
	long long sum=0;
	for(;x;x-=lowbit(x))sum+=t[x];
	return sum;
}
struct _Spaly
{
	inline void rotate(lxl x)
	{
		lxl y=fa[x],z=fa[y],d=c[y][1]==x;
		c[z][c[z][1]==y]=x;
		fa[x]=z,fa[y]=x,fa[c[x][d^1]]=y;
		c[y][d]=c[x][d^1],c[x][d^1]=y;
		PushUp(y),PushUp(x);
	}
	inline void spaly(lxl x,lxl goal,lxl id)
	{
		while(fa[x]!=goal)
		{
			lxl y=fa[x],z=fa[y];
			if(fa[y]!=goal)rotate((c[y][0]==x)^(c[z][0]==y)?x:y);
			rotate(x);
		}
		if(!goal)root[id]=x;
	}
	inline void PushUp(lxl x){size[x]=size[c[x][0]]+size[c[x][1]]+1;}
	lxl suc(lxl x,lxl v)
	{
		lxl tmp;
		if(!x)return v;
		if(v<=val[x])return suc(c[x][0],v);
		else
		{
			tmp=suc(c[x][1],v);
			if(tmp==v)tmp=x;
			return tmp;
		}
	}
	lxl aft(lxl x,lxl v)
	{
		lxl tmp;
		if(!x)return v;
		if(v>=val[x])return aft(c[x][1],v);
		else
		{
			tmp=aft(c[x][0],v);
			if(tmp==v)tmp=x;
			return tmp;
		}
	}
	inline void div(lxl id,lxl l,lxl r)
	{
		if(!size[root[id]])return;
		l=suc(root[id],l),r=aft(root[id],r);
		spaly(l,0,id),spaly(r,l,id);
		if(!c[r][0])return;
		dfs(c[r][0],id);
	}
	void dfs(lxl now,lxl id)
	{
		if(!(a[val[now]]%id))modify(val[now],a[val[now]]/id-a[val[now]]),a[val[now]]/=id;
		if(c[now][0])dfs(c[now][0],id);
		if(c[now][1])dfs(c[now][1],id);
		if(a[val[now]]%id)del(now);
		PushUp(now);
	}
	inline void del(lxl now)
	{
		while(true)
		{
			if(c[now][0])rotate(c[now][0]);
			else if(c[now][1])rotate(c[now][1]);
			else break;
		}
		c[fa[now]][c[fa[now]][1]==now]=0;
		--size[fa[now]],fa[now]=0,size[now]=0;
	}
	void build(lxl id,lxl &t,lxl l,lxl r,lxl from)
	{
		if(l>r)return;
		if(!t)t=++NodeCnt;
		lxl mid=(l+r)>>1;
		fa[t]=from,val[t]=q[mid];
		if(l==r){size[t]=1;return;}
		build(id,c[t][0],l,mid-1,t),build(id,c[t][1],mid+1,r,t);
		PushUp(t);
	}
}splay;
inline lxl read()
{
	char c=getchar();
	lxl f=1,x=0;
	for(;!isdigit(c);c=getchar())(c=='-')&&(f=-1);
	for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
	return f*x;
}
int main(void)
{
	n=read(),m=read();
	for(R int i(1);i<=n;++i)
	{
		a[i]=read(),modify(i,a[i]),MaxA=std::max(a[i],MaxA);
		for(R int j(1);j*j<=a[i];++j)
			if(!(a[i]%j))
			{
				v[j].push_back(i);
				if(j*j!=a[i])v[a[i]/j].push_back(i);
			}
	}
	for(R int i(1);i<maxm;++i)
	{
		lxl cur=0;
		for(std::vector<lxl>::iterator it=v[i].begin();it!=v[i].end();++it)q[++cur]=*it;
		q[0]=-INF,q[cur+1]=INF;
		splay.build(i,root[i],0,cur+1,0);
	}
	for(R int i(1);i<=m;++i)
	{
		lxl opt=read(),l=read(),r=read(),x;
		if(opt==1)
		{
			x=read();
			if(x>1)splay.div(x,l,r);
		}
		else printf("%lld\n",query(r)-query(l-1));
	}
	return 0;
}

```

---

## 作者：Jμdge (赞：2)

~~我 tm  RE 这么久是因为 a 数组开大了 10 倍爆内存？~~



---


既然没人写 FHQ treap 我就来一发？

我们考虑江每个询问离线回答（但并不是莫队）

之所以江询问拷下来其实是要记录要除的 v 

记录下所有的 v 之后我们就可以江原序列中是 v 倍数的数拉出来玩平衡树

然后顺序处理每次询问

我们考虑暴力地在关于 v 的那棵平衡树里面找节点并更新答案，如果说某个节点除去 v 之后不再是 v 的倍数就江它删除，对此我们可以用一个栈维护要删除的节点

然后我们发现有可能一个数在别的平衡树中除去了 v ，但现在我们又在另一棵平衡树中找到了它，那么我们只需在第一次除去 v 的时候江 $a_i$ 同时除去 v ，第二次找到他的时候判断一下是否能被 v 整除即可


总体思路很暴力，但是超级难调的啊 $mmp$ 不开 $O_2$ 好像还会 T 上天（我真是...）

然后就是注意数组开的大小...不然又 $T$ 又 $M$ 的....


```cpp
//by Judge
#include<bits/stdc++.h>
#pragma GCC optimize("Ofast")
#define fp(i,a,b) for(int i=(a),I=(b)+1;i<I;++i)
#define ll long long
using namespace std;
const int N=1e5+3,M=1e6+3;
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline void cmax(int& a,int b){if(a<b)a=b;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(ll x,char chr='\n'){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=chr;
} int n,m,mx,a[N],vis[M];
vector<int> V[M]; stack<int> st;
struct que{int op,l,r,v;}q[N]; //询问
namespace BIT{ ll f[M]; //板子，没毒
	#define lowbit(x) (x&-x)
	inline void update(int x,int v){for(;x<=n;x+=lowbit(x)) f[x]+=v;}
	inline ll query(int x,ll s=0){for(;x;x^=lowbit(x)) s+=f[x]; return s;}
} using namespace BIT;
namespace FHQTreap{ int rt[M],stk[M],tot;  //板子，treap 连 siz 都不带的
	inline int Rand(){static int seed=703; return seed=int(seed*48271%(~0u>>1));}
	struct node{ int ls,rs,pos,val; inline void init(int x){ls=rs=0,pos=Rand(),val=x;}}t[M<<6];
	inline int newnode(int x){return t[++tot].init(x),tot;}
	inline int build(int x,int n){
		int top=0,rt,now,pre;
		stk[++top]=rt=newnode(V[x][0]);
		fp(i,1,n){ now=newnode(V[x][i]),pre=0;
			for(;t[stk[top]].pos>t[now].pos;pre=stk[top--]);
			if(top) t[stk[top]].rs=now;
			t[now].ls=pre,stk[++top]=now;
			if(top==1) rt=now;
		} return rt;
	}
	int merge(int x,int y){ if(!x||!y) return x|y;
		if(t[x].pos<t[y].pos) return t[x].rs=merge(t[x].rs,y),x;
		else return t[y].ls=merge(x,t[y].ls),y;
	}
	void split(int rt,int k,int& x,int& y){
		if(!rt) return x=y=0,void();
		if(t[rt].val<=k) split(t[x=rt].rs,k,t[rt].rs,y);
		else split(t[y=rt].ls,k,x,t[rt].ls);
	}
	inline void delet(int& rt,int x){ int a,b;
		split(rt,x-1,rt,a),split(a,x,a,b),rt=merge(rt,b);
	}
	void dfs(int x,int& v){ if(!x) return ;
		dfs(t[x].ls,v),dfs(t[x].rs,v);
		int& nw=a[t[x].val];
		if(!(nw%v)) update(t[x].val,nw/v-nw),nw/=v;
		if(nw%v) st.push(t[x].val);
	}
} using namespace FHQTreap;
int main(){ n=read(),m=read();
	fp(i,1,n) update(i,a[i]=read()),cmax(mx,a[i]);
	fp(i,1,m){ q[i].op=read(); //把所有询问记录
		q[i].l=read(),q[i].r=read();
		if(q[i].op&1) vis[q[i].v=read()]=1;
	}
	fp(i,1,n){ int nw=a[i]; //筛出所有数的约数
		fp(j,1,sqrt(nw)) if(!(nw%j)){
			if(vis[j]&&j>1) V[j].push_back(i);
			if(vis[nw/j]&&j*j<nw) V[nw/j].push_back(i);
		}
	}
	fp(i,2,mx) if(V[i].size()) //暴力江所有要用到的 约数 建树
		rt[i]=build(i,V[i].size()-1);
	fp(i,1,m) if(q[i].op&2) print(query(q[i].r)-query(q[i].l-1));
	else if(q[i].v>1){ int& nw=rt[q[i].v],a,b,c; //顺序处理询问
		split(nw,q[i].l-1,a,b),split(b,q[i].r,b,c);
		dfs(b,q[i].v),nw=merge(a,merge(b,c));
		for(int p;!st.empty();st.pop())
			p=st.top(),delet(nw,p);
	} return Ot(),0;
}
```

---

## 作者：Demoe (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P3987)

## 题意

- 非负整数序列，支持 区间和查询 和 区间所有某数倍数除以其。

## Sol

~~大学弱化版 不卡常~~

考虑一个数的因数个数不超过 $2\sqrt{a_i}$，不妨对每个因数开链表，记录其倍数位置。

考虑每个数最多能被操作 $\log{a_i}$ 次，我们每次暴力修改链表就行了。

区间和可以写个 BIT，毕竟常数小。（

总复杂度 $O(n\sqrt{a_i}+n\log n\log {a_i})$。

```cpp
// wish to get better qwq

#include<bits/stdc++.h>
#define re register int
#define pb push_back

using namespace std;
typedef long long ll;

template <typename T> void rd(T &x){
	int fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(ll x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}

// ---------- IO ---------- //

const int N=5e5+5;
int n,m,a[N];
vector<int> f[N],fa[N];

ll sum[N],ans;

inline int lowbit(int x){return x&(-x);}

inline void add(int x,ll k){
	while(x<=n) sum[x]+=k,x+=lowbit(x);
}

inline ll query(int x){
	ll s=0;
	while(x) s+=sum[x],x-=lowbit(x);
	return s;
}

// ---------- BIT ---------- //

inline int found(int pos,int x){
	if(x>=fa[pos].size()) return x;
	return fa[pos][x]==x?fa[pos][x]:fa[pos][x]=found(pos,fa[pos][x]);
}

// ---------- DSU ---------- //

int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(n);rd(m);
	for(re i=1;i<=n;++i){
		rd(a[i]);add(i,a[i]);
		for(re j=1;j*j<=a[i];++j)
			if(a[i]%j==0){
				f[j].pb(i);fa[j].pb(fa[j].size());
				if(j*j!=a[i]) f[a[i]/j].pb(i),fa[a[i]/j].pb(fa[a[i]/j].size());
			}
	}
	int op,l,r,x;
	for(re i=1;i<=m;++i){
		rd(op);rd(l);rd(r);
		if(op==1){
			rd(x);
			if(x==1) continue;
			int st=lower_bound(f[x].begin(),f[x].end(),l)-f[x].begin();
			for(re j=found(x,st);j<f[x].size()&&f[x][j]<=r;j=found(x,j+1)){
				if(a[f[x][j]]%x==0) add(f[x][j],a[f[x][j]]/x-a[f[x][j]]),a[f[x][j]]/=x;
				if(a[f[x][j]]%x!=0) fa[x][j]=found(x,j+1);
			}
		}
		else wr(ans=query(r)-query(l-1)),puts("");
	}
	return 0;
}

// ---------- Main ---------- //
```

不卡常竟然能过。（

!["duliu!"](https://cdn.luogu.com.cn/upload/image_hosting/ciegxbap.png)

我们考虑卡常。（

把数组全部改成指针即可。（

注意细节，不要 $<=$ 写成 $<$。（

会 RE 飞。（

```cpp
// wish to get better qwq

#include<bits/stdc++.h>
#define re register int
#define pb push_back
#define lb lower_bound
#define ub upper_bound

using namespace std;
typedef long long ll;

template <typename T> void rd(T &x){
	int fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(ll x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}

// ---------- IO ---------- //

const int N=5e5+5;
int n,m,a[N],cnt[N],maxn,*p[N],node[N*505],*tp=node;

ll sum[N],ans;

inline int ma(int x,int y){return x<y?y:x;}

inline void add(int x,ll k){
	while(x<=n) sum[x]+=k,x+=x&(-x);
}

inline ll query(int x){
	ll s=0;
	while(x) s+=sum[x],x^=x&(-x);
	return s;
}

// ---------- BIT ---------- //

struct DSU{
	int *fa;
	inline void init(int n){for(re i=0;i<n;++i) fa[i]=i;}
	inline int found(int x){return fa[x]==x?x:fa[x]=found(fa[x]);}
}nxt[N];

// ---------- DSU ---------- //

inline void modify(int l,int r,int x){
	l=lb(p[x],p[x]+cnt[x],l)-p[x];
	r=ub(p[x],p[x]+cnt[x],r)-p[x]-1;
	if(l>r) return ;
	for(re nw=nxt[x].found(l);nw<=r;nw=nxt[x].found(nw+1)){
		int t=p[x][nw];
		if(a[t]%x==0) add(t,a[t]/x-a[t]),a[t]/=x;
		if(nw>=r) break;
		if(a[t]%x) nxt[x].fa[nw]=nxt[x].found(nw+1);
	}
}

int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(n);rd(m);
	for(re i=1;i<=n;++i){
		rd(a[i]);add(i,a[i]);
		cnt[a[i]]++;maxn=ma(maxn,a[i]);
	}
	for(re i=1;i<=maxn;++i)
		for(re j=i+i;j<=maxn;j+=i) cnt[i]+=cnt[j];
	for(re i=1;i<=maxn+1;++i)
		if(cnt[i]){
			p[i]=tp;tp+=cnt[i];
			nxt[i].fa=tp;nxt[i].init(cnt[i]);
			tp+=cnt[i];cnt[i]=0;
		}
	for(re i=1;i<=n;++i){
		for(re j=1;j*j<=a[i];++j)
			if(a[i]%j==0){
				p[j][cnt[j]++]=i;
				if(j*j!=a[i]) p[a[i]/j][cnt[a[i]/j]++]=i;
			}
	}
	int op,l,r,x;
	for(re i=1;i<=m;++i){
		rd(op);rd(l);rd(r);
		if(op==1){
			rd(x);
			if(x==1) continue;
			modify(l,r,x);
		}
		else wr(ans=query(r)-query(l-1)),puts("");
	}
	return 0;
}

// ---------- Main ---------- //
```

---

## 作者：wrpwrp (赞：1)

首先声明：  
我是按照官方题解写的，所以并没有什么好的思路，跟官方题解一样  
就是对每个数字维护一颗平衡树，每棵树存其倍数的下标，然后暴力维护就好了，复杂度(ndlogd)  
那么我写这篇题解干什么呢？？  
是因为我在写这道题的时候一开始使用了set，（结果被卡了，常数大得一批），在我不停优化下也只能过45分（此时代码长度2k）于是很多和我一样的童鞋们就开始手写平衡树了，但是作为一个平衡树的初学者往往总是很难从一棵树扩展到多棵，所以我在这里提供一种很easy的方法，让不用指针的同学也可以轻松做到。于是我们可以用vector维护数组，并且封装成类（八角帽的）这样我们可以很轻松地实现了。于是就可以给像我一样一开始望而却步的同学们一个比较清晰的模板。 由于splay是自适应的树，所以在我们去对一个区间遍历的时候复杂度其实很低，所以我们可以在遍历的时候直接查询后继，此处加一个inf会比较好处理，详情见代码即可  

set版本:
```cpp
#include <cstdio>
#include <set>

using namespace std;

#define R register
#define ll long long

inline int read()
{
	#define C getchar()
	int x=0;char a=C;
	for(;a>'9'||a<'0';a=C);
	for(;a>='0'&&a<='9';a=C)
	x=(x<<1)+(x<<3)+(a^48);
	return x;
}

const int inf=0x7f7f7f7f;
const int MAXN=1e5+10;
const int MAXNUM=5e5+10;

int n,m,a[MAXN];
set<int> st[MAXNUM];

inline void insert(int ad)
{
	int t=a[ad];
	st[t].insert(ad);
	for(R int i=2;i*i<=a[ad];i++)
	{
		if(t%i==0)
		{
			st[i].insert(ad);
			if(i*i!=t)
				st[t/i].insert(ad);
		}
	}
}

ll tr[MAXN];

inline int lowbit(int x) {return x&-x;}
inline void chg(int x,ll y)
{
	for(;x<=n;x+=lowbit(x))
	tr[x]+=y;
}

inline ll find(int x)
{
	ll ans=0;
	for(;x;x-=lowbit(x))
		ans+=tr[x];
	return ans;
}

inline ll query(int x,int y)
{
	return find(y)-find(x-1);
}

inline void work(int l,int r,int x)
{
	#define IT set<int>::iterator
	R IT it=st[x].lower_bound(l);
	for(;it!=st[x].end()&&*it<=r;)
	{
		int t=*it;
		if(a[t]%x!=0) 
		{
			IT tt=it;
			it++;
			st[x].erase(tt);
			continue;
		}
		chg(t,-a[t]);
		a[t]/=x;
		chg(t,a[t]);
		IT tt=it;
		it++;
		if(a[t]%x!=0) st[x].erase(tt);
	}
}

int main()
{
	n=read();m=read();
	for(R int i=1;i<=n;i++) a[i]=read();
	for(R int i=1;i<=n;i++) insert(i);
	for(R int i=1;i<=n;i++) chg(i,a[i]);
	R int opt,l,r,x;
	for(R int i=1;i<=m;i++)
	{
		opt=read();l=read();r=read();
		if(opt==1)
		{
			x=read();
			if(x==1||x==0) continue;
			work(l,r,x);
		}
		else printf("%lld\n",query(l,r));
	}
	return 0;
}
```



splay的版本（上面的好像多个log）
```cpp
#include <cstdio>
#include <vector>

#define R register
#define ll long long

using std::vector;

const int inf=0x7f7f7f7f;
const int MAXN=1e5+10;
const int MAXNUM=5e5+10;

inline int read();

class Splay
{
	private:
		int rt,tot;
		struct Node
		{
			int ch[2],siz,val,fa,cnt;
		};
		vector<Node> t;
		inline int New(int x);
		inline int get(int x);
		inline void splay(int x);
		inline void clear(int x);
		inline void update(int x);
		inline void rotate(int x);
		inline int  get(int x,int y);
		inline void connect(int x,int y,int chk);
		inline void splay(int x,int goal);
	public:
		Splay();
		inline int Pre();		
		inline int Nxt();		
		inline int rk(int k);		
		inline int pre(int k);		
		inline int nxt(int k);
		inline int kth(int k);	
		inline void del(int k);
		inline void insert(int k);
		inline int size();
		inline void solve(int l,int r,int x);
		inline void dfs(int now,int x);
};

class BIT
{
	private:
		ll c[MAXN];
		inline int lowbit(int x);
	public:
		int n;
		inline void add(int x,int y);
		inline ll find(int x);
		inline ll query(int x,int y);
};

int n,m,a[MAXN];
int st[MAXN];
int top;
BIT bit;
Splay Tree[MAXNUM];

inline void ins(int ad)
{
	int t=a[ad];
	Tree[t].insert(ad);
	for(R int i=2;i*i<=t;i++)
	{
		if(t%i==0)
		{
			Tree[i].insert(ad);
			if(i*i!=t)
				Tree[t/i].insert(ad);
		}
	}
}

int main()
{
	n=read();m=read(); bit.n=n;
	for(R int i=1;i<=n;i++)
	{
		a[i]=read();
		bit.add(i,a[i]);
		ins(i);
	}
	int opt,l,r,x;
	for(R int i=1;i<=m;i++)
	{
		opt=read();l=read();r=read();
		if(opt==2)
		{
			printf("%lld\n",bit.query(l,r));
		}
		else
		{
			x=read();
			if(x==1||x==0) continue;
			Tree[x].solve(l,r,x);
		}
	}
	return 0;
}

inline int read()
{
    #define C getchar()
    char a=C;int x=0,f=1;
    for(;a>'9'||a<'0';a=C) if(a=='-') f=-1;
    for(;a>='0'&&a<='9';a=C) x=x*10+a-'0';
    return x*f;
    #undef C
}

#define ls(x) t[x].ch[0]
#define rs(x) t[x].ch[1]
#define fa(x) t[x].fa
#define cnt(x) t[x].cnt
#define siz(x) t[x].siz
#define val(x) t[x].val

inline int Splay::size()
{
	return t[rt].siz;
}

inline int Splay::New(int x)
{
	Node tmp;
	tmp.val=x;
	tmp.cnt=1;
	tmp.siz=1;
	tmp.fa=tmp.ch[1]=tmp.ch[0]=0;
	t.push_back(tmp);
	tot++;
	return tot;
}

inline int Splay::get(int x)
{
	return x==rs(fa(x));
}

inline int Splay::get(int x,int y)
{
	return x==rs(y);
}

inline void Splay::update(int x)
{
	siz(x)=siz(ls(x))+siz(rs(x))+cnt(x);
}

inline void Splay::connect(int x,int y,int chk)
{
	t[y].ch[chk]=x;
	fa(x)=y;
}

inline void Splay::rotate(int x)
{
	int y=fa(x);int z=fa(y);
	int chk=get(x);
	connect(t[x].ch[chk^1],y,chk);
	connect(y,x,chk^1);
	if(z) connect(x,z,get(y,z));
	else fa(x)=0;
	update(y);
}

inline void Splay::splay(int x)
{
	for(R int f=fa(x);f;rotate(x),f=fa(x))
	if(fa(f)) rotate(get(x)==get(f)?f:x);
	rt=x;
}

inline void Splay::splay(int x,int goal)
{
	for(R int f=fa(x);f!=goal;rotate(x),f=fa(x))
	if(fa(f)!=goal) rotate(get(x)==get(f)?f:x);
	if(goal==0)
	rt=x;
}

inline void Splay::clear(int x)
{
	fa(x)=siz(x)=cnt(x)=ls(x)=rs(x)=val(x)=0;
}

Splay::Splay()
{
	rt=tot=0;
	Node tmp;
	tmp.val=0;
	tmp.cnt=0;
	tmp.siz=0;
	tmp.fa=tmp.ch[1]=tmp.ch[0]=0;
	t.push_back(tmp);
}

inline void Splay::insert(int k)
{
	if(!rt)
	{
		rt=New(k);
		update(rt);
		return;
	}
	int x=rt,f=0;
	while(1)
	{
		if(val(x)==k)
		{
			cnt(x)++;
			splay(x);
			return ;
		}
		f=x;x=t[x].ch[k>val(x)];
		if(!x)
		{
			x=New(k);
			connect(x,f,k>val(f));
			splay(x);
			return ;
		}
	}
}

inline int Splay::rk(int k)
{
	int res=0,x=rt;
	while(1)
	{
		if(k<val(x)) x=ls(x);
		else
		{
			res+=siz(ls(x));
			if(k==val(x)) {splay(x);return res+1;}
			res+=cnt(x);x=rs(x);
		}		
	}
}

inline int Splay::kth(int k)
{
	int x=rt;
	while(1)
	{
		if(k<=siz(ls(x))) x=ls(x);
		else
		{
			k-=cnt(x)+siz(ls(x));
			if(k<=0) return val(x);
			x=rs(x);
		}	
	}
}

inline int Splay::Pre()
{
	int x=ls(rt);
	while(rs(x)) x=rs(x);
	return x;
}

inline int Splay::Nxt()
{
	int x=rs(rt);
	while(ls(x)) x=ls(x);
	return x;
}

inline void Splay::del(int k)
{
	rk(k);
	if(cnt(rt)>1)
	{
		cnt(rt)--;
		update(rt);
		return;
	}
	if(!ls(rt)&&!rs(rt))
	{
		clear(rt);
		rt=0;
	return;
	}
	if(!ls(rt))
	{
		int x=rt;
		rt=rs(x);
		fa(rt)=0;
		clear(x);
		return;
	}
	if(!rs(rt))
	{
		int x=rt;
		rt=ls(x);
		fa(rt)=0;
		clear(x);
		return;
	}
	int x=rt,tmp=Pre();
	splay(tmp);
	connect(rs(x),tmp,1);
	clear(x);
	update(rt);
}

inline int Splay::pre(int k)
{
	insert(k);
	int res=Pre();
	del(k);
	return val(res);
}

inline int Splay::nxt(int k)
{
	insert(k);
	int res=Nxt();
	del(k);
	return val(res);
}

inline void Splay::solve(int l,int r,int x)
{
	insert(-inf);insert(inf);
	insert(l);
	int LL=Pre();
	del(l);
	insert(r);
	int RR=Nxt();
	del(r);//printf("%d %d\n",val(LL),val(RR));
	splay(LL,0);
	splay(RR,LL);
	top=0;
	dfs(ls(rs(rt)),x);
	for(R int i=1;i<=top;i++)
	del(st[i]);
}

inline void Splay::dfs(int now,int x)
{
	if(now==0) return;
	if(a[val(now)]%x==0)
	{
		bit.add(val(now),-a[val(now)]);
		a[val(now)]/=x;
		bit.add(val(now),a[val(now)]);
	}
	if(ls(now)) dfs(ls(now),x);
	if(rs(now)) dfs(rs(now),x);
	if(a[val(now)]%x) 
	{
		st[++top]=val(now);
	}
}

inline int BIT::lowbit(int x) 
{
	return x&-x;
}

inline void BIT::add(int x,int y)
{
	for(;x<=n;x+=lowbit(x)) c[x]+=y;
}

inline ll BIT::find(int x)
{
	ll ans=0;
	for(;x;x-=lowbit(x)) ans+=c[x];
	return ans;
}

inline ll BIT::query(int x,int y)
{
	return find(y)-find(x-1);
}
```



---

## 作者：xfrvq (赞：0)

[P3987 我永远喜欢珂朵莉~](/problem/P3987)

蒟蒻的第一道 Ynoi /cy，也是罕见的没有分块的 Ynoi。

## 思路

首先，在 $1\sim 500000$，一个数最多有 $200$ 多个因数。对于 $1\sim 500000$，可以建平衡树，维护含有这个因数的数的下标。（我用的是 FHQ）

对于修改，考虑在 $x$ 的平衡树里，分裂出 $l\sim r$ 的区间，然后对这棵子树进行 dfs。在 dfs 里，删除所有整除完 $x$ 后不能继续整除 $x$ 的节点。

对于查询，考虑建一个 线段树/树状数组 维护 $a$ 数组，dfs 时删除子树节点顺便进行修改，然后区间查询即可。

## 坑点

细节极多。

### 建树

+ FHQ 和线段树非常像，可以仿照线段树 $\mathcal O(n)$ 建树。
+ 暴力进行质因数分解/cy

---

### 修改

+ dfs 删除，记得先递归左子树，在进行删除，再递归右子树，这是因为BST 左子树 $\lt$ 根 $\lt$ 右子树。
+ dfs 删除，一个数可能整除完一个 $x$ 后无法再整除下一个 $x$，此时直接删掉。
+ dfs 删除，要判是 $x$ 的倍数而不是 $x^2$ 的倍数，如果满足后者，应该重新加进平衡树里。

由于有些数删除后又要重新加进平衡树里，因此考虑 dfs 时删完全部的数，顺便记录哪些数整除后还要放回树里。

+ 删除完后，还要用记录下来的数建树，因此可以用 $\mathcal O(n)$ 建树函数。

但是，许多节点都需要被删除再加进，浪费了极大的空间，本来 $500000$ 以内的数因数总个数只有 $7\times 10^6$，然后我开到了 $2\times 10^7$ /kk。

+ 空间卡的很紧，修改要判 $x=1$（这会让你 MLE）

---

### last

`long long` 不开是不行的，开是没问题的。什么 MLE nmsl。  

## Code

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<vector>
#define int long long
const int maxn = 5e5 + 1;
const int max_size = 2e7 + 1;
int n,m;
std::vector<int> value[maxn];
int a[maxn],tmp[maxn],len = 0;
int lc[max_size],rc[max_size],id[max_size],heap[max_size],siz[max_size],cnt = 0,rt[maxn];// 把所有 FHQ 都开在一起
int new_node(int i){
	siz[++cnt] = 1;
	id[cnt] = i;
	heap[cnt] = rand();
	return cnt;
}
void push_up(int i){
	siz[i] = 1 + siz[lc[i]] + siz[rc[i]];
}
int build(int l,int r){ // O(n) 建树
	if(l > r) return 0;
	int mid = l + r >> 1,i = new_node(tmp[mid]);
	lc[i] = build(l,mid - 1);
	rc[i] = build(mid + 1,r);
	push_up(i);
	return i;
}
int merge(int x,int y){
	if(!x || !y) return x + y;
	if(heap[x] < heap[y]){
		rc[x] = merge(rc[x],y);
		push_up(x);
		return x;
	} else {
		lc[y] = merge(x,lc[y]);
		push_up(y);
		return y;
	}
}
void split(int i,int k,int& x,int& y){
	if(!i) x = y = 0;
	else {
		if(id[i] <= k){
			x = i;
			split(rc[i],k,rc[i],y);
		} else {
			y = i;
			split(lc[i],k,x,lc[i]);
		}
	}
}
// 以上都是常规
int T[maxn];// 树状数组码量小，常数好！！
void update(int i,int x){
	for(;i <= n;i += (i & -i)) T[i] += x;
}
int query(int i){
	int ret = 0;
	for(;i;i -= (i & -i)) ret += T[i];
	return ret;
}
// --------
void dfs(int p,int x){
	if(!p) return;
	dfs(lc[p],x);// 先搜左边
	if(a[id[p]] % x == 0){
		update(id[p],-a[id[p]]);
		a[id[p]] /= x;
		update(id[p],a[id[p]]);// dfs时顺便更新树状数组
	}
	if(a[id[p]] % x == 0)
		tmp[++len] = id[p];// x^2 的倍数记录起来
	dfs(rc[p],x);// 最后搜右边
}
void update(int l,int r,int a){
	int x,y,z;
	split(rt[a],r,x,z);// 把>r的分走
	split(x,l - 1,x,y);// 把<l的分走
	len = 0;
	dfs(y,a);
	int k = build(1,len);// 重新建树
	rt[a] = merge(merge(x,k),z);// 是merge(x,k)
}
int query(int l,int r){// 树状数组
	return query(r) - query(l - 1);
}
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i = 1;i <= n;++i){
		scanf("%lld",a + i);
		update(i,a[i]);
		for(int j = 1;j * j <= a[i];++j)
			if(a[i] % j == 0){
				value[j].push_back(i);
				if(j * j != a[i]) value[a[i] / j].push_back(i);
			}// 暴力分解
	}
	for(int i = 1;i < maxn;++i){
		len = 0;
		for(int j = 0;j < value[i].size();++j) tmp[++len] = value[i][j];
		rt[i] = build(1,len);// 建树
	}
	while(m--){
		int opt,l,r;
		int x;
		scanf("%lld%lld%lld",&opt,&l,&r);
		if(opt == 1){
			scanf("%lld",&x);
			if(x != 1) update(l,r,x);// 判x=1
		} else printf("%lld\n",query(l,r));
	}
	return 0;
}
```

---

## 作者：Taduro (赞：0)

这题的思路有点像总统选举那个题，对每个因子建棵平衡树，维护能被它整除的数的位置。

除的时候在这个因子的平衡树上暴力dfs这个区间，模拟题目描述

如果区间中一个数被除了后不能整除这个因子，就把他删除。

之后单点修改可以用树状数组。

以及一些许许多多的细节。。。

比如可以只对询问出现的因子建平衡树，所以可以离线把一个因子的倍数位置放到一个vector里之后一块建

比如建树一定要用build而不是暴力insert，因为这题好像有1e7+个节点。

再比如不能在dfs的时候直接删除，那样破坏树的结构，所以要把删除的数放到一个栈里。

平衡树空间3e7似乎很稳。

关于内存池：没多大必要，如果要用内存池就得在询问的时候建树。。。

用的splay，在一个luogu特别卡的晚上跑到了约11900s，然而第二天早上怎么卡常都没有之前快了。

```c++
#include<vector>
#include<cstdio>
#include<iostream>
#define ll long long
#define re register
using namespace std;
inline char gc(){
	static char buf[1<<23],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<23,stdin),p1==p2)?EOF:*p1++;
}
inline int init(){
	re char c=gc();re int a=0,w=1;
	while((c<'0'||c>'9')&&c-'-')c=gc();
	if(c=='-')w=-w,c=gc();
	while(c>='0'&&c<='9')a=(a<<3)+(a<<1)+(c^48),c=gc();
	return a*w;
}
inline void pc(re char c,re int p=0){
	static char buf[1<<23],*p1=buf;
	if(p){fwrite(buf,1,p1-buf,stdout);return ;}
	*p1++=c;
	if(p1==buf+(1<<23))fwrite(buf,1,1<<23,stdout),p1=buf;
}
void write(re ll x){
	if(x>9)write(x/10);
	pc(x%10+'0');
}
inline char getc(){
	char c=gc();
	while(!isupper(c)) c=gc();
	return c;
}
struct tree{
	int num,val,fa,ch[2];
}t[50260817];
struct ques{
	int x,p,l,r;
}q[100001];
ll c[100001];
int a[100001],cut[500001],n,tot,m,o[500001],maxn;
vector<int> num[500001];
inline int lowbit(int x){return x&(-x);}
inline void add(int x,int y){while (x<=n) c[x]+=y,x+=lowbit(x);}
inline ll query(int x){ll num=0;while (x) num+=c[x],x-=lowbit(x);return num;}
struct Splay{
	int rt;
	inline void rotate(int x){
		int y=t[x].fa,z=t[y].fa,f=(t[y].ch[1]==x);
		t[x].fa=z; t[z].ch[t[z].ch[1]==y]=x;
		t[t[x].ch[f^1]].fa=y; t[y].ch[f]=t[x].ch[f^1];
		t[x].ch[f^1]=y; t[y].fa=x;
	}
	inline void splay(int x,int goal){
		int y,z;
		while (t[x].fa!=goal){
			y=t[x].fa,z=t[y].fa;
			if (z!=goal)
				if ((t[y].ch[1]==x)^(t[z].ch[1]==y)) rotate(x); else rotate(y);
			rotate(x);
			}
		if (!goal) rt=x;
	}
//	inline void ins(int x,int z){
//		int u=rt; printf("%d %d %d\n",x,z,rt);
//		while (t[u].ch[x>t[u].val]) u=t[u].ch[x>t[u].val];
//		int y=++tot;
//		t[u].ch[x>t[u].val]=y; t[y].num=z;
//		t[y].val=x; t[y].fa=u; splay(y,0);
//	}
	inline void find(int x){
		int u=rt;
		while (t[u].val!=x&&t[u].ch[x>t[u].val]) u=t[u].ch[x>t[u].val];
		splay(u,0);
	}
	inline int nex(int x,int f){
		find(x);
		if (t[rt].val<=x&&!f) return rt;
		if (t[rt].val>=x&&f) return rt;
		int y=t[rt].ch[f];
		while (t[y].ch[f^1]) y=t[y].ch[f^1];
		return y;
	}
	inline void del(int x){
		int u=nex(x-1,0),v=nex(x+1,1);
		splay(u,0); splay(v,u);
		t[v].ch[0]=0; t[t[v].ch[0]].fa=0;
	}
	void dfs(int x){
		if (t[x].ch[0]) dfs(t[x].ch[0]);
		if (t[x].ch[1]) dfs(t[x].ch[1]);
		int u=t[x].val;
		if (a[u]%t[x].num==0){
			int z=a[u]/t[x].num;
			add(u,z-a[u]); a[u]=z;
		}
		else{
			cut[++cut[0]]=u; return;
		}
	}
	inline void arrange(int l,int r){
		int u=nex(l-1,0),v=nex(r+1,1);
		splay(u,0); splay(v,u);
		if (t[v].ch[0])
			dfs(t[v].ch[0]);
		for (int i=1; i<=cut[0]; i++) del(cut[i]);
		cut[0]=0;
	}	
	inline void print(int x){
		if (t[x].ch[0]) print(t[x].ch[0]);
		printf("id:%d num:%d val:%d fa:%d ch0:%d ch1:%d\n"
			,x,t[x].num,t[x].val,t[x].fa,t[x].ch[0],t[x].ch[1]);
		if (t[x].ch[1]) print(t[x].ch[1]);
	}
	inline void debug(){print(rt);}
	inline int build(int l,int r,int fa,int x){
		if (l>r) return 0;
		int y=++tot,mid=(l+r)>>1;
		t[y].val=num[x][mid];
		t[y].fa=fa; t[y].num=x;
		t[y].ch[0]=build(l,mid-1,y,x);
		t[y].ch[1]=build(mid+1,r,y,x);
		return y;
	}
}sp[500001];
int main(){
	n=init(),m=init();
	for (int i=1; i<=n; i++){
		a[i]=init();
		add(i,a[i]); maxn=max(maxn,a[i]);
	}
	for (int i=1; i<=m; i++){
		q[i].p=init(),q[i].l=init(),q[i].r=init();
		if (q[i].p==1){
			q[i].x=init();
			if (q[i].x>maxn) continue;
			if (q[i].x!=1) o[q[i].x]=1;
		}
	}
	for (int i=1; i<=maxn; i++){
		if (o[i]) num[i].push_back(-2e9);
//		if (o[i]) sp[i].ins(-2e9,i),sp[i].ins(2e9,i);
//		sp[i].debug();
	}
	for (int i=1; i<=n; i++){
		for (int j=1; j*j<=a[i]; j++){
			if (a[i]%j!=0) continue;
			if (!a[i]) continue;
			if (o[j]) num[j].push_back(i);
			if (a[i]/j!=j&&o[a[i]/j]) num[a[i]/j].push_back(i);
		}
	}
	for (int i=1; i<=maxn; i++){
		if (o[i]){
			num[i].push_back(2e9);
			sp[i].rt=sp[i].build(0,num[i].size()-1,0,i);
		}
	}
	// sp[8].debug();
	for (int i=1; i<=m; i++){
		if (q[i].p==1){
			if (q[i].x==1) continue;
			if (q[i].x>maxn) continue;
			sp[q[i].x].arrange(q[i].l,q[i].r);
		}
		else write(query(q[i].r)-query(q[i].l-1)),pc('\n');
	}
	pc(' ',1);
	return 0;
}
```



---


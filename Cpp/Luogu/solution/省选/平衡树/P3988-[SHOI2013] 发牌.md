# [SHOI2013] 发牌

## 题目描述

在一些扑克游戏里，如德州扑克，发牌是有讲究的。一般称呼专业的发牌手为荷官。荷官在发牌前，先要销牌（burn card）。所谓销牌，就是把当前在牌库顶的那一张牌移动到牌库底，它用来防止玩家猜牌而影响游戏。

假设一开始，荷官拿出了一副新牌，这副牌有 $N$ 张不同的牌，编号依次为 $1$ 到 $N$。由于是新牌，所以牌是按照顺序排好的，从牌库顶开始，依次为 $1,2,\cdots,N$，$N$ 号牌在牌库底。为了发完所有的牌，荷官会进行 $N$ 次发牌操作，在第 $i$ 次发牌之前，他会连续进行 $R_i$ 次销牌操作，$R_i$ 由输入给定。请问最后玩家拿到这副牌的顺序是什么样的？

举个例子，假设 $N=4$，则一开始的时候，牌库中牌的构成顺序为 $1,2,3,4$。

- 假设 $R_1=2$，则荷官应该连销两次牌，将 $1$ 和 $2$ 放入牌库底，再将 $3$ 发给玩家。目前牌库中的牌顺序为 $4,1,2$。
- 假设 $R_2=0$，荷官不需要销牌，直接将 $4$ 发给玩家，目前牌库中的牌顺序为 $1,2$。
- 假设 $R_3=3$，则荷官依次销去了 $1,2,1$，再将 $2$ 发给了玩家。目前牌库仅剩下一张牌 $1$。
- 假设 $R_4=2$，荷官在重复销去两次 $1$ 之后，还是将 $1$ 发给了玩家，这是因为 $1$ 是牌库中唯一的一张牌。

## 说明/提示

#### 数据规模与约定

对于 $100 \%$ 的数据，$0 \le R_i < N$。  

| 测试点编号 | $N=$ | 测试点编号 | $N=$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $5\times 10^3$ | $6$ | $3\times 10^5$ |
| $2$ | $10^4$ |  $7$ | $4\times 10^5$ |
| $3$ | $5\times 10^4$ | $8$ | $5\times 10^5$ |
| $4$ | $10^5$ | $9$ | $6\times 10^5$ |
| $5$ | $2\times 10^5$ | $10$ | $7\times 10^5$ |

## 样例 #1

### 输入

```
4
2
0
3
2```

### 输出

```
3
4
2
1```

# 题解

## 作者：MeowScore (赞：14)

[传送门 qwq](https://www.luogu.com.cn/problem/P3988)

本题解使用 FHQ-Treap。

显然我们要把问题转化为平衡树擅长的序列问题。

首先你需要掌握“按照大小对平衡树进行分裂”，模板：[P3391 【模板】文艺平衡树](https://www.luogu.com.cn/problem/P3391)。这样分裂下来一棵树，其中序遍历就是其代表的序列。

初始序列为 $1,2,3,…,n$。聪明的你一定可以通过举例或是画图等方法发现，对于一次操作，给出 $R$，其实就是把序列的前 $R$ 个数截下来搬到序列末尾。$R$ 如果大于等于剩余牌的数量，要对这个数量取膜。显然正确性没有问题。

那么每次操作，我们按大小分裂出前 $R$ 个点，也就是平衡树中序遍历的前 $R$ 个点，也就是当前序列中前 $R$ 张牌的编号，然后将分裂的两颗树合并，注意由于是把这一段放到末尾，所以 merge 传参数的时候千万别写反。~~写反的话裂完原样合并你写个寂寞~~。这时候发一张牌，也就是序列的第一个数，也就是平衡树中序遍历的第一个数，所以直接按大小分裂出大小为 $1$ 的一棵树，编号即这张牌。然后根节点直接赋值为分出来的另一棵树的根，因为发完牌这个数我们就不要了。

$700000$ 的数据范围，数组别开小，~~出题人累死荷官。~~


```
#include<bits/stdc++.h>
using namespace std;
int read(){
	int ss=0,ww=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')
			ww=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		ss=ss*10+ch-'0';
		ch=getchar();
	}
	return ss*ww;
}
int n,m;
const int N=700100;
int root,cnt,ls[N],rs[N],sz[N],c[N];
int newnode(){
	cnt++;
	c[cnt]=rand();
	sz[cnt]=1;
	return cnt;
}
int x,y,z;
void upd(int r){
	sz[r]=sz[ls[r]]+sz[rs[r]]+1;
}
void split(int r,int k,int &x,int &y){
	if(!r){
		x=0;
		y=0;
		return;
	}
	if(sz[ls[r]]>=k){
		y=r;
		split(ls[r],k,x,ls[r]);
	}
	else{
		x=r;
		split(rs[r],k-sz[ls[r]]-1,rs[r],y);
	}
	upd(r);
}
int merge(int r1,int r2){
	if(!r1||!r2)
		return r1+r2;
	if(c[r1]<=c[r2]){
		rs[r1]=merge(rs[r1],r2);
		upd(r1);
		return r1;
	}
	else{
		ls[r2]=merge(r1,ls[r2]);
		upd(r2);
		return r2;
	}
}
int main(){
	n=read();
	for(int i=1;i<=n;i++)
		root=merge(root,newnode());
	int rest=n;
	for(int i=1;i<=n;i++){
		int a;
		a=read();
		a%=rest;
		rest--;
		if(a){
			split(root,a,x,y);
			root=merge(y,x);
		}
		split(root,1,x,y);
		printf("%d\n",x);
		root=y;
	}
	return 0;
}
```

---

## 作者：YoungLove (赞：13)

[Youngsc](https://youngscc.github.io/)

** 一波题解 **  
** 先开一个树状数组记录每一种牌的数量（0或1） **  
** 对于询问的消$k$次之后牌堆顶的牌我们可以转化为询问从当前牌堆顶的牌起第$k\ mod\ sum+1$张牌是谁并删除掉它后将其下一张视作牌堆顶 **  
** 那么我们分两类讨论**  
** 如果当前牌堆顶到牌$n$的牌总数大于$k\ mod\ sum+1$，那么我们只需在牌顶到$n$之间二分第$k\ mod\ sum+1$张牌**  
** 否则二分$1$到牌堆顶$-1$之间的第（$k\ mod\ sum+1$-后边多的那些牌）张**  

** 十分拗口，就上代码吧 **  

```cpp
# include <bits/stdc++.h>
# define R register
# define N 700010
# define inf 2000101900
# define LL long long

using namespace std;

int n,t[N],nxt[N],pre[N],p,tot,now=1;

template <typename T> inline void in(R T &a){
    R char c = getchar();R T x=0,f=1;
    while(!isdigit(c)) {if(c == '-') f=-1; c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0',c = getchar();
    a=x*f;
}

template <typename T> inline void maxx(R T& a,const T b){a<b? a=b:0;}

inline void add(R int x,R int sum){
    while (x <= n) t[x] += sum,x += x&-x;
}

inline int qury(R int x){
    R int ret = 0;
    while (x) ret += t[x],x -= x&-x;
    return ret;
}

inline int search(R int l,R int r,R int sum){
    R int ret = 0;
    while (l <= r)
    {
        // printf("%d %d \n",l,r);
        R int mid = l+r>>1;
        if (qury(mid) >= sum) ret = mid,r = mid-1;
        else l = mid+1;
    }
    // printf(">>>>>>%d\n",ret);
    return ret;
}

inline int yg(){
    // freopen("worma.in","r",stdin);
    // freopen("worma.out","w",stdout);
    in(n);
    for (R int i=1; i<=n; ++i) t[i] = i&-i,pre[i] = i-1,nxt[i] = i+1; \\链表方便寻找下一张牌
    pre[1] = n,nxt[n] = 1;
    R int now = 1; \\当前牌堆顶
    tot = n;
    for (R int i=1; i<=n; ++i)
    {
        in(p);
        // printf("%d>>>\n",now);
        p %= tot; \\tot表示牌堆里剩下的牌数
        p++;
        R int sum = qury(n)-qury(now-1); \\
        if (p > sum) printf("%d\n",now = search(1,now-1,p-sum))\\查询前边，减去后边多出来的sum;
        else printf("%d\n",now = search(now,n,p+qury(now-1))) \\由于是在树状数组里二分，所以将牌堆顶前边的数量都加上;
        pre[nxt[now]] = pre[now];
        nxt[pre[now]] = nxt[now];
        add(now,-1);\\删掉这张牌
        now = nxt[now];\\牌堆顶是下一张
        tot--;
    }
    return 0;
}

int youngsc = yg();

int main(){;}

```


---

## 作者：_Diu_ (赞：9)

题目[传送门](https://www.luogu.com.cn/problem/P3988)

树状数组+二分+吸氧过了。

## 树状数组

看到这一道题有弹出操作（发牌）和循环操作（洗牌），

第一反应就是树状数组。

我们可以维护张牌是否被发出，

那维护这个有什么用呢。

假设当前第一张牌是 $L$，

则我们要的是第 $L+R$ 张牌。

那么我们只需要二分求出和小于等于 $R$ 的最小的那张牌并弹出。

但是 $R\le n$，就是说有可能这个荷官~~纱~~无聊循环洗牌。

那么作为~~中国特色社会主义的接班人~~一名合格的 OIer，

我们应该帮助荷官减少工作量，

设当前牌堆剩余排数为 $sum$，

则让 $R\%=sum$，

这样就可以保证二分不会出问题。

```cpp
bool check(int x,int y,int a){
	if(x<=y)return (query(y)-query(x-1))<=a;
	return (query(n)-query(x-1)+query(y))<=a;
}

for(int i=1;i<=n;i++){
	scanf("%lld",&a);
	a%=(n-i+1);
	int l=L,r=l+n;
	while(l+1<r){
		int mid=(l+r)/2;
		if(check(L,(mid-1)%n+1,a))l=mid;
		else r=mid;
	}
	L=l%n+1;
	add(L,1);
	printf("%lld\n",L);
}
```

## code

上完整代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=7e5+10;
int n,a,c[N],L=1;
int lowbit(int x){
	return x&-x;
}
void add(int i,int s){
	while(i<=n)c[i]+=s,i+=lowbit(i);
}
int query(int i){
	int s=i;
	while(i)s-=c[i],i-=lowbit(i);
	return s;
}
bool check(int x,int y,int a){
	if(x<=y)return (query(y)-query(x-1))<=a;
	return (query(n)-query(x-1)+query(y))<=a;
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a);
		a%=(n-i+1);
		int l=L,r=l+n;
		while(l+1<r){
			int mid=(l+r)/2;
			if(check(L,(mid-1)%n+1,a))l=mid;
			else r=mid;
		}
		L=l%n+1;
		add(L,1);
		printf("%lld\n",L);
	}
}
```

记得开吸氧！

---

## 作者：虚心竹gulu (赞：8)

和楼下一样，查询区间滴 $k$ 大值。

我用的是线段树。

每次发的牌 = (牌库顶的数 + $R_i$) % 当前的牌数

然后再把发过的牌删掉。

这题是权值线段树的模板吗？

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
template <typename T>
void read(T &x)
{
    x = 0;
    char ch = getchar();
    int f = 1;
    while (!isdigit(ch))
    {
        if (ch == '-')
            f = -1;
        ch=getchar();
    }
    while (isdigit(ch))
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    x = x * f;
}
int n;
int sum[3000006];
void build(int k, int l, int r) // 建树
{
    if (l == r)
    {
        sum[k] = 1;
        return;
    }
    int mid = (l + r) >> 1;
    build(k << 1, l, mid);
    build(k << 1 | 1, mid + 1, r);
    sum[k] = sum[k << 1] + sum[k << 1 | 1];
}
int query(int p, int l, int r, int x)
{
    sum[p]--;
    if (l == r)
    {
        return l;
    }
    int mid = (l + r) >> 1;
    if (x <= sum[p << 1])
        return query(p << 1, l, mid, x);
    else
        return query(p << 1 | 1, mid + 1, r, x - sum[p << 1]);
}
int main()
{
    register int i;
    read(n);// 数据比较多，要用快读
    build(1, 1, n);
    int x, y = 0;
    for (i = n; i >= 1; --i)
    {
        read(x);
        y = (y + x) % i;
        printf("%d\n", query(1, 1, n, y + 1));
    }
    return 0;
}
```


---

## 作者：feicheng (赞：6)

## [Description](https://www.luogu.com.cn/problem/P3988)

有 $n$ 张牌，一开始从 $1\sim n$ 排列，有 $n$ 次操作，每次把 $R$ 张牌移到最尾，求每次发牌过后队首的牌，并且删掉这张牌

## Solution

考虑用 fhq-treap 求解，因为 fhq-treap 有着强大的处理区间的能力，所以我们直接模拟题面的要求即可：

对于移到最尾的操作，我们考虑用按 siz 分裂的 fhq-treap，数里的权值就是牌的编号，队首即对 rnk=1分裂即可，并且顺便我们可以直接通过转移根节点来实现删牌的操作，可谓是一举两得。

美中不足的就是常数略大，需吸氧

## Code

已加入防抄袭片段，请自重

```cpp
/*If you are full of hope,you will be invincible*/
#include <ctime>
#include <cstdio>
#include <random>
#include <cstring>
#include <iostream>
#include <algorithm>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#include<ext/pb_ds/priority_queue.hpp>
#define ri register int
typedef long long ll;
std::mt19937 hpy(time(nullptr)+(unsigned long long)(new char));
namespace IO{
	constexpr int HL=1<<20;
	char buf[HL],*t1=buf,*t2=buf;
	#ifndef ONLINE_JUDGE
	#define getc() getchar()
	#else
	#define getc() t1==t2&&(t2=(t1=buf)+fread(buf,1,HL,stdin),t1==t2)?EOF:*t1++
	#endif
	template <typename Tp>
	inline void read(Tp &x) {
		x = 0;int f = 1;char ch = getc();
		for(;!isdigit(ch);ch=getc()) if(ch=='-') f = 0;
		for(;isdigit(ch);ch=getc()) x=(x<<3)+(x<<1)+(ch^48);
		x=f?x:-x;
	}
	template <typename Tp,typename ...Rp>
	inline void read(Tp &x,Rp&... rst) {
		read(x),read(rst...);
	}
	char buff[HL],*T=buff;
	void flush(){fwrite(buff,1,T-buff,stdout);T=buff;}
	inline void putc(char ch){if(T==buff+HL)flush();*T++=ch;}
	template<typename Tp>
	inline void print(Tp x){if(x<0)putc('-'),x=-x;if(!x)return putc('0')void();
	static int st[20],tp;while(x)st[++tp]=x%10,x/=10;while(tp)putc(st[tp]^48),--tp;}
	template<typename T,typename ...Args> inline void print(const char ch,T x,Args ...args) {
        print(x,ch);print(args...,ch);
    }
}
using IO::read;
using IO::print;
using IO::putc;
constexpr int inf = 0x3f3f3f3f,N = 7e5 + 10;
struct node{int l,r,siz,key,val;}t[N];
int n,m,cnt,root,R;
inline int newnode(const int x) {return t[++cnt].val = x,t[cnt].key=hpy(),t[cnt].siz=1,cnt;}
inline void update(const int x){t[x].siz = t[t[x].l].siz + t[t[x].r].siz + 1;}
void Split(const int now,const int rnk,int &x,int &y) {
	if(!now) return x=y=0,void();
	if(t[t[now].l].siz < rnk) {
		x = now;
		Split(t[now].r,rnk-t[t[now].l].siz-1,t[now].r,y);
	} else{ 
		y = now;
		Split(t[now].l,rnk,x,t[now].l);
	}
	update(now);
}
int Merge(const int x,const int y) {
	if(!x || !y) return x + y;
	if(t[x].key < t[y].key) {
		t[x].r = Merge(t[x].r,y);
		return update(x),x;
	} else {
		t[y].l = Merge(x,t[y].l);
		return update(y),y;
	}
}

int main() {
   	read(n);
   	for(ri i = 1;i <= n;++i ) root = Merge(root,newnode(i));
   	while(n--) {
   		int rnk,x,y;read(rnk);
   		rnk %= t[root].siz;//前R张牌至少要比总牌数要少（如果多的话相当于是轮回）
   		if(rnk) Split(root,rnk,x,y)，root = Merge(y,x);
   		Split(root,1,x,y);
   		print(t[x].val,'\n')，root = y;//转移根节点
   	}
    return IO::flush(),0;
}
```



---

## 作者：Nemlit (赞：4)

这道题去年联赛就在写此题，省选前尝试用平衡树，都无果，现在重拾此题

不难发现排的相对顺序不会发生改变，而且每一个$R$的实际意义其实是查询当前排名为第$R$的数

我们定义当前牌顶为$x$，每一次操作其实是查询往x后的$R$个数

我们可以先查询x是现在第几大（令此为p），然后就意味着求出$p+R$大的数，注意需要对当前数取模

查出后更新$x$，并且把这个数删掉即可

发现以上所有操作都可以用权值线段树/平衡树实现，复杂度为$O(NlogN)$

## $Code:$
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i , a , b) for(int i = (a) , i##Limit = (b) ; i <= i##Limit ; ++ i)
#define ls k * 2
#define rs k * 2 + 1
#define maxn 700007
int n, sum[maxn << 2], now;
il void build(int k, int l, int r) {
	if(l == r) return (void)(sum[k] = 1);
	int mid = (l + r) >> 1;
	build(ls, l, mid), build(rs, mid + 1, r), sum[k] = sum[ls] + sum[rs];
}
il void modify(int k, int l, int r, int ll, int v) {
	if(l == r) return (void)(sum[k] += v);
	int mid = (l + r) >> 1;
	if(ll <= mid) modify(ls, l, mid, ll, v);
	else modify(rs, mid + 1, r, ll, v);
	sum[k] = sum[ls] + sum[rs];
}
il int query(int k, int l, int r, int ll) {
	if(ll == 0) return 0;
	if(l == r) return 1;
	int mid = (l + r) >> 1;
	if(ll > mid) return query(rs, mid + 1, r, ll) + sum[ls];
	return query(ls, l, mid, ll);
}
il int K_th(int k, int l, int r, int b) {
	if(l == r) return l;
	int mid = (l + r) >> 1, pax = sum[ls];
	if(pax >= b) return K_th(ls, l, mid, b);
	return K_th(rs, mid + 1, r, b - pax);
}
signed main() {
	n = read(), now = 1, build(1, 1, n);
	rep(i, 1, n) {
		int r = (read() + now) % (n - i + 1), t;
		if(r == 0) r = n - i + 1;
		printf("%d\n", t = K_th(1, 1, n, now = r)), modify(1, 1, n, t, -1);
	}
	return 0;
}

```

---

## 作者：zhengrunzhe (赞：4)

Splay  (+O2...)

常数巨大

用Splay找到1-x的区间

把它接到最后面

然后找到排名第一的数

输出后删除

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=700001;
struct tree
{
    int value,size,fa,son[2];
    inline tree(){size=value=fa=son[0]=son[1]=0;}
    inline void create(int key){size=1;value=key;}
}t[N];
int root,size;
inline void pushup(tree &p)
{
	p.size=1;
	if (p.son[0])p.size+=t[p.son[0]].size;
	if (p.son[1])p.size+=t[p.son[1]].size;
}
inline bool relation(int p)
{
    return t[t[p].fa].son[1]==p;
}
inline void connect(int p,int fa,bool which)
{
    if (p)t[p].fa=fa;
    if (fa)t[fa].son[which]=p,pushup(t[fa]);
}
inline void rotate(int p)
{
    int fa=t[p].fa;
    bool dir=relation(p);
    connect(p,t[fa].fa,relation(fa));
    connect(t[p].son[dir^1],fa,dir);
    connect(fa,p,dir^1);
    pushup(t[fa]);pushup(t[p]);
}
inline void splay(int p)
{
    for (int fa;fa=t[p].fa;rotate(p))
        if (t[fa].fa)
            rotate(relation(p)==relation(fa)?fa:p);
    root=p;
}
inline int find_rank(int ranking)
{
    int p=root;
    while (1)
        if (ranking<=t[t[p].son[0]].size)p=t[p].son[0];
        else
        {
            ranking-=t[t[p].son[0]].size+1;
            if (!ranking)return p;
            p=t[p].son[1];
        }
}
int build(int fa,int l,int r)
{
	int mid=l+r>>1,p=++size;
	t[p].create(mid);t[p].fa=fa;
	if (l<mid)t[p].son[0]=build(p,l,mid-1);
	if (r>mid)t[p].son[1]=build(p,mid+1,r);
	return pushup(t[p]),p;
}
inline int reverse(int pos)
{
	if (pos) //不为0才销牌
	{
		splay(find_rank(pos)); //找到第pos张牌并选到根 这样它的左子树便是[1,pos)，右子树是(pos,t[root].size]
		int rt=root;
		root=t[rt].son[1];t[root].fa=0;//它的右儿子作为新根
		t[rt].son[1]=0;pushup(t[rt]);
		splay(find_rank(t[root].size)); //把最后一张牌旋转至根
		connect(rt,root,1); //把[1,pos]接到最后去
	}
	int first=find_rank(1),ans=t[first].value;
	splay(first); //找到牌顶的牌并旋到根
	if (t[first].son[1])t[root=t[first].son[1]].fa=0; //设置新根
	return ans;
}
int n;
int main()
{
	scanf("%d",&n);
	root=build(0,1,n);
	while (n--)
	{
		int r;
		scanf("%d",&r);
		printf("%d\n",reverse(r%t[root].size)); //模上总牌数
	}
	return 0;
}
```

---

## 作者：Strelitzia (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P3988)

---

$\text{fhq-treap}$ 没有开 O2 或快读。

可能是测评姬波动。

注意到削牌操作就是将一个区间接到一个区间后，不就是裸的 $\text{fhq-treap}$ 吗？

注意削牌次数可能大于当前牌数，注意取模。

```cpp
#include <ctime>
#include <cstdio>
#include <algorithm>
using namespace std;

template<typename T>T Max(T x,T y) {return x > y ? x : y;}

const int N = 7e5 + 5;

struct node {
	int l,r,sz,key,val;
}fhq[N];

int n,m;
int cnt,root,root1,root2,root3;

int newnode(int val) {
	fhq[++ cnt].key = rand();
	fhq[cnt].val = val;
	fhq[cnt].sz = 1;
	return cnt;
}

void update(int now) {
	fhq[now].sz = fhq[fhq[now].l].sz + fhq[fhq[now].r].sz + 1;
}

void split(int now,int sz,int &x,int &y) {
	if (!now)
		x = y = 0;
	else {
		if (fhq[fhq[now].l].sz < sz) {
			x = now;
			split(fhq[now].r,sz - fhq[fhq[now].l].sz - 1,fhq[now].r,y);
		}
		else {
			y = now;
			split(fhq[now].l,sz,x,fhq[now].l);
		}
		update(now);
	}
}

int merge(int x,int y) {
	if (!x || !y)
		return x | y;
	if (fhq[x].key < fhq[y].key) {
		fhq[x].r = merge(fhq[x].r,y);
		update(x);
		return x;
	}
	else {
		fhq[y].l = merge(x,fhq[y].l);
		update(y);
		return y;
	}
}

int main () {
	scanf("%d",&n);
	int x;
	for (int i = 1 ; i <= n ; ++ i)
		root = merge(root,newnode(i));
	for (int i = 1 ; i <= n ; ++ i) {
		scanf("%d",&x);
		x %= (n - i + 1);
		if (x == 0) {
			split(root,1,root1,root2);
			printf("%d\n",fhq[root1].val);
			root = root2;
		}
		else {
			split(root,x,root1,root2);
			split(root2,1,root2,root3);
			printf("%d\n",fhq[root2].val);
			root = merge(root3,root1);
		}
	}
	return 0;
}
```

---

## 作者：斯德哥尔摩 (赞：3)

[P3988 [SHOI2013]发牌](https://www.luogu.org/problemnew/show/P3988)

## 先说一点题外话：

这种题目，怎么能没有线段树的题解呢？

弄得我好方啊。。。

然而我写了个线段树，调了$2h$，发现我就是个沙茶，竟然把$s$敲成了$k$。。。

这样下去吃草药丸。。。

## 步入正题：

首先应该看出这是个求整个区间的第$k$大值。

这种题目$Splay,Treap$乱搞啊。。。

但是$n<=7\times 10^5$，这。。。铁定$TLE$啊。。。

然后我们想，还有什么可以求第$k$大值呢？

没错！**主席树**！

但是这题不用主席树，因为只要求整个区间的第$k$大值，所以用个**权值线段树**就好辣！

假设当前的牌堆顶为$k$，现在要销牌$x$次，一共有$sum$张牌。

那么我们要发的那张牌就是第$(k+x)\mod sum$张牌。

注意：如果$(k+x)\mod sum==0$，那么要发的就是第$sum$张牌。

然后在权值线段树中把发过的那张牌删掉就好。

记得用一点常数优化之类的东西。。。

还有，我的权值线段树极度压行，还有一大堆宏定义，要仔细看哦！

[有空到本蒟蒻的博客里坐坐哦！](https://www.cnblogs.com/Yangrui-Blog/p/9526427.html)

附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define LSON rt<<1
#define RSON rt<<1|1
#define DATA(x) a[x].data
#define LSIDE(x) a[x].l
#define RSIDE(x) a[x].r
#define WIDTH(x) (RSIDE(x)-LSIDE(x)+1)
#define MAXN 1000010
using namespace std;
int n,m;
struct Segment_Tree{
	int data,l,r;
}a[MAXN<<2];
inline int read(){
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
void buildtree(int l,int r,int rt){//建树
	LSIDE(rt)=l;RSIDE(rt)=r;DATA(rt)=WIDTH(rt);
	if(l==r)return;
	int mid=l+r>>1;
	buildtree(l,mid,LSON);
	buildtree(mid+1,r,RSON);
}
void update(int k,int rt){//删除
	DATA(rt)--;
	if(LSIDE(rt)==RSIDE(rt))return;
	int mid=LSIDE(rt)+RSIDE(rt)>>1;
	if(k<=mid)update(k,LSON);
	else update(k,RSON);
}
int query(int k,int rt){//第k大
	if(LSIDE(rt)==RSIDE(rt))return LSIDE(rt);
	if(k<=DATA(LSON))return query(k,LSON);
	else return query(k-DATA(LSON),RSON);
}
void work(){
	int x,s,k=1;
	while(n--){
		x=read();
		k=(k+x)%DATA(1);
		if(!k)k=DATA(1);//记得要特判
		s=query(k,1);//求的是第k大
		printf("%d\n",s);
		update(s,1);//删除的是第k大的值！
	}
}
void init(){
	n=read();
	buildtree(1,n,1);
}
int main(){
	init();
	work();
    return 0;
}

```

---

## 作者：MloVtry (赞：3)

平衡树暴力模拟。

相当于把一个区间从前面移动到后面。
这里使用了非旋Treap。

代码（-O2）

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define N 700005
using namespace std;
int read()  //读入优化
{
    int out=0,flag=1;
    char c=getchar();
    while(c<48||c>57) {if(c=='-') flag=-1;c=getchar();}
    while(c>=48&&c<=57)
    {
        out=out*10+c-48;
        c=getchar();
    }
    return out*flag;
}
struct node
{
    int key,fhq;
    int l,r,siz;
    node()
    {
        l=r=siz=0;
        key=fhq=0;
    }
    void Ned(int i)
    {
        key=i;fhq=rand();siz=1;
    }
}tre[N];
int n,rot;
void update(int now)
{
    tre[now].siz=tre[tre[now].l].siz+1+tre[tre[now].r].siz;
}
void split(int now,int k,int &x,int &y)
{
    if(!now)
    {
        x=y=0;return;
    }
    if(tre[tre[now].l].siz>=k)
        y=now,split(tre[now].l,k,x,tre[now].l);
    else
        x=now,split(tre[now].r,k-tre[tre[now].l].siz-1,tre[now].r,y);
    update(now);
}
int merage(int x,int y)
{
    if(x*y==0) return x+y;
    if(tre[x].fhq<tre[y].fhq)
    {
        tre[x].r=merage(tre[x].r,y);
        update(x);return x;
    }
    else
    {
        tre[y].l=merage(x,tre[y].l);
        update(y);return y;
    }
}

int main()
{
    n=read();
    srand(n*n*233+666);
	for(int i=1;i<=n;++i)
    {
        tre[i].Ned(i);rot=merage(rot,i);
    }
    for(int i=1;i<=n;++i)
    {
        int it=read()%tre[rot].siz;
        int x,y;
        if(it)
        {
            split(rot,it,x,y);
            merage(y,x);
        }
        split(rot,1,x,y);
        printf("%d\n",tre[x].key);
        rot=y;
    }
    return 0;
}
```

---

## 作者：SpeMars (赞：2)

~~首先这道题我们先手玩一下数据找找灵感~~。

这道题翻译成人话就是:

每次取出当前序列 $p$ 小值并输出，再从剩下的数中删除这个数。

对于这道题，我们先设 $res$ 为当前牌堆的牌的数目。

$p$ 为当前牌顶要求序列第 $p$ 小值, $lp$ 为上一次的 $p$(初始为1)。

$p$ = $(lp+Ri)$ $mod$ $res$。

但是当 $p=0$ 时，我们要把 $p$ 的值改为 $res$。

接下来树状数组+二分就可以了。

## CODE:

```cpp
#include<cstdio>
#define lowbit(x) (x&(-x))
using namespace std;
const int N=1e6+10;
int n,c[N];
int ri,res,p,l,r,mid,ans;
void add(int i,int k){
	for(;i<=n;i+=lowbit(i))c[i]+=k;
	return;
}
int query(int i){
	int s=0;
	for(;i>0;i-=lowbit(i))s+=c[i];
	return s;
}
int main(){
	scanf("%d",&n);
	p=1,res=n;
	for(int i=1;i<=n;++i)add(i,1);
	for(int i=1;i<=n;++i){
		scanf("%d",&ri);
		p=(p+ri)%res;
		if(!p)p=res;
		--res;
		l=1,r=n;
		for(;l<=r;){
			mid=((l+r)>>1);
			if(query(mid)>=p)ans=mid,r=mid-1;
			else l=mid+1;
		}
		printf("%d\n",ans);
		add(ans,-1);
	}
	return 0;
}
```

---

## 作者：白鲟 (赞：2)

## 前言
（跳过这一环节）
## 题意简述
多次询问，对于每次询问，在前一次询问的基础上，将前 $r_i-1$ 个元素置于序列末，并回答此时序列的第一个元素。
## 题目分析
很显然，如果真的按照题目的要求移动元素，铁定会超时……那么我们尝试不移动元素，而是计算出要查询的元素在原始数列中的位置。经过尝试，可以发现只需要在原始数列中将上一次答案位置向后移动 $r_i$ 个位置，若超出当前序列尾端则返回首端，便可以得到此次答案所在的位置。即 $location=(last\_location+r_i-1) \mod size+1$，$location$ 初始值为 $1$。  

那么这时只需要查询对应位置的元素即可。我们需要一个数据结构，维护插入元素、删除元素以及查询第 $k$ 大的数。很显然，二叉查找树和权值线段树（树状数组）满足要求。此题由于没有删除后的插入，可以直接通过原始数据构造接近完美平衡的树，故不需要写平衡树。由于~~写这篇题解的人比较懒~~树状数组好写，他使用了树状数组实现。  

容易想到把树状数组当作桶来用，建立权值意义上的树状数组。插入和删除都很好办。对于查询，由于满足单调性，可以使用倍增。因为树状数组的每个结点维护的区间是 $[x-lowbit(x)+1,x]$，倍增恰好符合树状数组的存储规律。在倍增的时候，注意需要累计经过的结点的 $sum$ 值（根据每个结点维护的信息可以得出）。总时间复杂度为 $\operatorname{O}(n\log n)$。
## 代码
完全没压行，但超短的！
```cpp
#include<cmath>
#include<cstdio>
using namespace std;
int n,target=1,r[700001],sum[700001];
inline int lowbit(int x)
{
	return x&(-x);
}
void add(int x,int value)
{
	while(x<=n)
	{
		sum[x]+=value;
		x+=lowbit(x);
	}
	return;
}
int at(int x)
{
	int now=0,rank=0;
	for(int i=log2(n);i>=0;--i)
		if(now+(1<<i)<=n&&rank+sum[now+(1<<i)]<x)
		{
			now+=(1<<i);
			rank+=sum[now]; 
		} 
	return now+1;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		add(i,1);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&r[i]);
		target=(target+r[i]-1)%(n-i+1)+1;
		int t=at(target);
		printf("%d\n",t);
		add(t,-1);
	}
	return 0;
}
```

---

## 作者：cirnovsky (赞：2)

看到好像没有splay的题解，来补一波~~

找到1-x的区间，然后转到后面，在删除第一个就好了

~~需吸氧~~

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
#include <utility>
#include <cctype>
#define mid (l + r >> 1)

using namespace std;

const int SIZE = 7e5 + 5;
struct SPLAY {
	int siz;
	int val;
	int ch[2];
	int fa;
} T[SIZE];
int root, n, R[SIZE], tot;

inline void update(int u) {
	T[u].siz = T[T[u].ch[0]].siz + T[T[u].ch[1]].siz + 1;
}

inline int make(int l, int r, int fa) {
	int u = ++tot;
	T[u].siz = 1;
	T[u].val = mid;
	T[u].ch[0] = T[u].ch[1] = 0;
	T[u].fa = fa;
	if (mid > l) T[u].ch[0] = make(l, mid - 1, u);
	if (mid < r) T[u].ch[1] = make(mid + 1, r, u);
	update(u);
	return u;
}

inline void rotate(int x) {
	int y = T[x].fa;
	int z = T[y].fa;
	int w = T[y].ch[1] == x;
	T[z].ch[T[z].ch[1] == y] = x;
	T[x].fa = z;
	T[y].ch[w] = T[x].ch[w ^ 1];
	T[T[x].ch[w ^ 1]].fa = y;
	T[x].ch[w ^ 1] = y;
	T[y].fa = x;
	update(y), update(x);
}

inline void splay(int x, int goal) {
	for (; T[x].fa ^ goal; rotate(x)) {
		int y = T[x].fa;
		int z = T[y].fa;
		if (z ^ goal)
			T[y].ch[1] ^ x ^ T[z].ch[1] ^ y ? rotate(x) : rotate(y);
	}
	if (!goal) root = x;
}

inline int getRank(int x) {
	int u = root;
	while (233) {
		if (x <= T[T[u].ch[0]].siz) u = T[u].ch[0];
		else {
			x -= T[T[u].ch[0]].siz + 1;
			if (!x) return u;
			u = T[u].ch[1];
		}
	}
}

inline int getcard(int x) {
	if (x) {
		splay(getRank(x), 0);
		int u = root;
		root = T[u].ch[1];
		T[root].fa = 0;
		T[u].ch[1] = 0;
		update(u);
		splay(getRank(T[root].siz), 0);
		if (u) T[u].fa = root;
		if (root) T[root].ch[1] = u, update(root);
	}
	int ranker = getRank(1);
	int res = T[ranker].val;
	splay(ranker, 0);
	if (T[ranker].ch[1])
		T[root = T[ranker].ch[1]].fa = 0;
	return res;
}

signed main() {
	scanf("%d", &n);
	root = make(1, n, 0);
	for (int i = 1; i <= n; ++i) {
		scanf("%d", &R[i]);
		printf("%d\n", getcard(R[i] % T[root].siz));
	}
	return 0;
}
```

---

## 作者：cqbzhyf (赞：1)

[题面](https://www.luogu.com.cn/problem/P3988)

首先看题发现暴力可拿部分分……

于是先打了暴力。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int num=0,ch=0;
	char c=getchar();
	while(!isdigit(c))ch|=(c=='-'),c=getchar();
	while(isdigit(c))num=(num<<1)+(num<<3)+(c^48),c=getchar();
	return ch?-num:num;
}
inline void write(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)write(x/10);
	putchar(x%10+'0');
}
int n;
queue<int>C;
signed main(){
//	freopen("card.in","r",stdin);
//	freopen("card.out","w",stdout);
	n=read();
	for(int i=1;i<=n;++i)C.push(i);
	for(int i=1;i<=n;++i){
		int x=read();x%=n-i+1;
		while(x--){C.push(C.front());C.pop();}
		write(C.front()),puts("");C.pop();
	}
	return 0;
}

```

---

然后再看题目，发现最开始牌是正序，再加上暴力时的取模操作，联想到**权值线段树求第 $k$ 大**。

于是维护了一个权值线段树，每次输入更新 $k$ 的值。

注意要修改权值线段树的值域，因为每次要弹出一个数，剩下的就是处理细节了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum[3000005],k;
inline int read(){
	int num=0,ch=0;
	char c=getchar();
	while(!isdigit(c))ch|=(c=='-'),c=getchar();
	while(isdigit(c))num=(num<<1)+(num<<3)+(c^48),c=getchar();
	return ch?-num:num;
}
inline void write(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)write(x/10);
	putchar(x%10+'0');
}
inline void build(int p,int l,int r){
    if(l==r){sum[p]=1;return;}
    int mid=l+r>>1;
    build(p<<1,l,mid);
    build(p<<1|1,mid+1,r);
    sum[p]=sum[p<<1]+sum[p<<1|1];
}
inline int query(int p,int l,int r,int x){
    --sum[p];
    if(l==r)return l;
    int mid=l+r>>1;
    if(x<=sum[p<<1])return query(p<<1,l,mid,x);
    else return query(p<<1|1,mid+1,r,x-sum[p<<1]);
}
signed main(){
	n=read(),build(1,1,n);
    for(int i=n;i;--i)k=(k+read())%i,write(query(1,1,n,k+1)),puts("");
    return 0;
}

```

---

## 作者：KSToki (赞：1)

废话：蒟蒻好久没有发过题解了，，，
# 正文
看到这道题首先想到的~~一定是暴力的解法：模拟~~，但是显然是过不了n=700000这么大的数据的。用数学思维稍加思考，就可以发现这道题的大意是：
```cpp
求数列中第（cnt=(cnt+r)%i）小的数，其中cnt初值为1，i为当前牌库中剩余的牌数量
求出答案后将答案从数列中去除
```
简单地拿样例举个栗子：

第一次：cnt=1，r=2，i=4，求出第3小的数即3，将3从数列中删除

第二次：cnt=3，r=0，i=3，此时计算出要求第0小的数，特殊处理将cnt赋值为i，相当于求第3小的数即4，将4从数列中删除

第三次：cnt=3，r=3，i=2，此时计算出要求第0小的数，同上，答案为2，删除2

第四次：cnt=2，r=2，i=1，虽然此时显然只剩1，但仍按上述方法执行，答案为1，删除1

那么我们需要怎样的数据结构呢？没错，最~~简单易懂的~~权值线段树，求整体第k大，则可以得到下面这段核心代码：
```cpp
for(int i=n;i>0;--i)//i表示牌库中牌的数量
{
	scanf("%d",&r);//题目描述中的ri
	cnt=(cnt+r)%i;
	if(cnt==0) cnt=i;
	int pos=query(1,1,n,cnt);//查询第cnt大的数
	update(1,1,n,pos);//将pos从数列中删除，相当于将该位置的权值-1
	printf("%d\n",pos);
}
```
什么？你还不知道权值线段树怎么用，下面简单的介绍一下：

顾名思义，权值线段树是一种特殊的线段树，唯一不同的是它的节点表示一个区间的数出现的次数。就比如这道题它的叶节点的初始值都为一，操作便和普通线段树一样啦，父节点的值是左儿子和右儿子值之和。

于是我们愉快地敲出代码：
```cpp
#include<bits/stdc++.h>
#define lc (k<<1)
#define rc ((k<<1)|1)
#define mid ((l+r)>>1)
using namespace std;
int n,r,cnt=1,sum[3000005];//sum要开4倍大
void build(int k,int l,int r)//建树
{
	if(l==r)//到达叶节点
	{
		sum[k]=1;
		return;
	}
	build(lc,l,mid);//建左子树
	build(rc,mid+1,r);//建右子树
	sum[k]=sum[lc]+sum[rc];//更新值
}
void update(int k,int l,int r,int pos)
{
	if(l>pos||r<pos)//范围内没有pos，直接跳出
	    return;
	if(l==r&&l==pos)//到达pos叶节点
	{
		--sum[k];//权值-1，即删除
		return;
	}
	update(lc,l,mid,pos);
	update(rc,mid+1,r,pos);
	sum[k]=sum[lc]+sum[rc];//更新
}
int query(int k,int l,int r,int v)
{
	if(l==r)
	    return l;//到达叶节点，此时找到的就是答案
	if(sum[lc]>=v)//左子树中数出现的次数大于等于v个，那第v大一定在左子树中
	    return query(lc,l,mid,v);
	else//否则一定在右子树中
	    return query(rc,mid+1,r,v-sum[lc]);//注意要减掉左子树的sum
}
int main()
{
	scanf("%d",&n);
	build(1,1,n);//建树
	for(int i=n;i>0;--i)//i表示牌库中牌的数量
	{
		scanf("%d",&r);//题目描述中的ri
		cnt=(cnt+r)%i;
		if(cnt==0) cnt=i;
		int pos=query(1,1,n,cnt);//查询第cnt大的数
		update(1,1,n,pos);//将pos从数列中删除，相当于将该位置的权值-1
		printf("%d\n",pos);
	}
	return 0;
}
```
~~蒟蒻写题解不易，求管理通过~~

---

## 作者：Tekim (赞：1)

思路比较好想，就是把一个区间的牌移到最后，然后删掉牌首，然后我们模拟一下发现直接每次维护删除的位置取个%就可以了，线段树维护儿子数量，数学难度不到高中水平，没啥好说明的，管理员非要我再讲点废话才让通过，这代码都看不懂啥意思建议不要打省选了。
```
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define lson o<<1
#define rson (o<<1)|1
using namespace std;
const int maxn=7e5+7;
int n,now=1,son[maxn*8];
void build_tree(int o,int l,int r)
{
	son[o]=r-l+1;if(l==r) return ;int mid=(l+r)/2;
	build_tree(lson,l,mid);build_tree(rson,mid+1,r);
}
int find_it_del(int o,int l,int r,int rank)
{
	int sum=son[lson],mid=(l+r)/2;son[o]--;if(l==r) return l; 
	if(rank<=sum)  return find_it_del(lson,l,mid,rank);
	else return find_it_del(rson,mid+1,r,rank-sum);
}
int main()
{
	scanf("%d",&n);
	build_tree(1,1,n);
	for(int i=1;i<=n;++i)
	{
		int x;scanf("%d",&x);now=(now+x-1)%(n-i+1)+1;
		int p1=find_it_del(1,1,n,now);
		printf("%d\n",p1);
	}
	return 0;
}
```


---

## 作者：Unnamed114514 (赞：0)

我们可以知道，这个操作是环状的，所以我们可以破环为链。

然后，我们可以知道：在操作当前元素 $s$ 次后，该序列就会回到原样，所以第 $k$ 次操作的答案就是第 $\sum\limits_{i=1}^kr_i$。

又因为抽走之后要删除，所以说就是要实现一个支持删除、查询排名的数据结构，这里采用的是 Treap。
```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
const int maxn=7e5+5;
int tot,root;
struct Treap{
	int l,r,val,dat,cnt,size;
}a[maxn];
inline int read(){
	int res=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
		ch=getchar();
	while(ch>='0'&&ch<='9'){
		res=(res<<1)+(res<<3)+(ch^'0');
		ch=getchar();
	}
	return res;
}
inline int New(int val){
	a[++tot].val=val;
	a[tot].dat=rand();
	a[tot].cnt=a[tot].size=1;
	return tot;
}
inline void Update(int p){
	a[p].size=a[a[p].l].size+a[a[p].r].size+a[p].cnt;
}
inline void Build(){
	New(-inf),New(inf);
	root=1,a[1].r=2;
	Update(root);
}
int GetVal(int p,int rank){
	if(p==0)
		return inf;
	if(a[a[p].l].size>=rank)
		return GetVal(a[p].l,rank);
	if(a[a[p].l].size+a[p].cnt>=rank)
		return a[p].val;
	return GetVal(a[p].r,rank-a[a[p].l].size-a[p].cnt);
}
inline void Zig(int &p){
	int q=a[p].l;
	a[p].l=a[q].r,a[q].r=p,p=q;
	Update(a[p].r),Update(p);
}
inline void Zag(int &p){
	int q=a[p].r;
	a[p].r=a[q].l,a[q].l=p,p=q;
	Update(a[p].l),Update(p);
}
void Insert(int &p,int val){
	if(!p){
		p=New(val);
		return;
	}
	if(val==a[p].val){
		++a[p].cnt,Update(p);
		return;
	}
	if(val<a[p].val){
		Insert(a[p].l,val);
		if(a[p].dat<a[a[p].l].dat)
			Zig(p);
	} else{
		Insert(a[p].r,val);
		if(a[p].dat<a[a[p].r].dat)
			Zag(p);
	}
	Update(p);
}
void Remove(int &p,int val){
	if(p==0)
		return;
	if(val==a[p].val){
		if(a[p].cnt>1){
			a[p].cnt--,Update(p);
			return;
		}
		if(a[p].l||a[p].r){
			if(a[p].r==0||a[a[p].l].dat>a[a[p].r].dat)
				Zig(p),Remove(a[p].r,val);
			else
				Zag(p),Remove(a[p].l,val);
			Update(p);
		} else
			p=0;
		return;
	}
	val<a[p].val?Remove(a[p].l,val):Remove(a[p].r,val);
	Update(p);
}
int n=read(),s=1;
int main(){
	Build();
	for(int i=1;i<=n;++i)
		Insert(root,i);
	for(int i=n,a;i;--i){
		s=(s+read())%i;
		if(!s)
		    s=i;//因为平衡树是从 1 开始标号的
		printf("%d\n",GetVal(root,s+1));
		Remove(root,GetVal(root,s+1));
	}
	return 0;
}
```

---

## 作者：Others (赞：0)

这题真的生艹。

# Solution

约瑟夫加强版，首先可以想到用链表，然后一个一个跳，这是 $O(n^2)$ 的。

然后用一点数据结构快速跳，这东西投射到序列上就是一个 $01$ 序列，然后从当前的位置往后跳 $R\mod n$ 个数，如果可以快速的找到第 $R\mod n$ 个数就行了，想到权值线段树的第 $kth$，这题就是把板板了，小心会跳到前面，所以复制一遍数组就行了。

还有一种方法，卡卡常应该能过（理论算是 $O(2\times10^8)$），就是二分下一个发的牌，用树状数组维护中间有多少个数，$O(n\log^2n)$ 的复杂度，这种做法由于我多复制了几遍暴力代码对拍被覆盖掉了......还有，二分可以用倍增代替，复杂度一样，常数小些。

喷一下数据，我随机的数据用权值线段树跑出来 $3s$，上面居然过了。

上一份 $25min$ 艹出来的代码：

```cpp
#include <bits/stdc++.h>
#define il inline
#define lowbit(x) (x&-x)
using namespace std;
il int qr() {
	int x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)) f|=c=='-',c=getchar();
	while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return f?~(x-1):x;
}
const int N=700005;
int nxt[N],lst[N],n,k,mid,tmp;
struct node {
	int l,r,sum;
}tr[N<<2];
il void Del(int x) {
	lst[nxt[x]]=lst[x],nxt[lst[x]]=nxt[x];
}
void build(int l,int r,int p) {
	tr[p].l=l,tr[p].r=r,tr[p].sum=r-l+1;
	if(l==r) return ;
	int mid=l+r>>1;
	build(l,mid,p<<1),build(mid+1,r,p<<1|1);
}
void del(int x,int p) {
	if(tr[p].l==tr[p].r) {
		tr[p].sum--;
		return ;
	}
	int mid=tr[p].l+tr[p].r>>1;
	if(x<=mid) del(x,p<<1);
	else del(x,p<<1|1);
	tr[p].sum--; 
}
int ask(int l,int r,int p) {
	if(l<=tr[p].l&&tr[p].r<=r) return tr[p].sum;
	int mid=tr[p].l+tr[p].r>>1,tot=0;
	if(l<=mid) tot+=ask(l,r,p<<1);
	if(r>mid) tot+=ask(l,r,p<<1|1);
	return tot;
}
int getk1(int k,int lim,int p) {
	if(tr[p].l==tr[p].r) return tr[p].l;
	int mid=tr[p].l+tr[p].r>>1;
	if(mid>=lim) return getk1(k,lim,p<<1);
	if(tr[p<<1].sum<k) {
		k-=tr[p<<1].sum;
		return getk1(k,lim,p<<1|1);
	}
	return getk1(k,lim,p<<1);
}
int getk2(int k,int lim,int p) {
//	printf("%d %d %d %d %d\n",k,lim,p,tr[p].l,tr[p].r);
	if(tr[p].l==tr[p].r) return tr[p].l;
	int mid=tr[p].l+tr[p].r>>1;
	if(mid<lim) return getk2(k,lim,p<<1|1);
	if(tr[p<<1|1].sum<k) {
		k-=tr[p<<1|1].sum;
		return getk2(k,lim,p<<1);
	}
	return getk2(k,lim,p<<1|1);
}
int main() {
	freopen("card.in","r",stdin);
	freopen("card.out","w",stdout);
	n=qr(),lst[1]=n,nxt[1]=2,lst[n]=n-1,nxt[n]=1;
	for(int i=2;i<n;i++) lst[i]=i-1,nxt[i]=i+1;
	build(1,n,1);
	for(int i=n,now=1,tmp;i;i--) {
		k=qr()%i+1,tmp=ask(now,n,1);
		if(tmp<k) k-=tmp,now=getk1(k,now-1,1);
		else now=getk2(tmp-k+1,now,1);
		printf("%d\n",now);
		del(now,1),Del(now),now=nxt[now];
	}
	return 0;
}
```

---

## 作者：TulipeNoire (赞：0)

对于这个题，我们的流程是每一次向后找 $r_i$ 个。我们又发现这个牌相当于是个环状的结构，所以破环为链，在链上维护一棵线段树，每一次向后找 $r_i$ 个，找到的即为答案，是线段树基本操作。再删除对应元素，也是线段树基本操作。详见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1400005;
inline int read() {
	int res=0;
	char c=getchar();
	while (c<'0'||c>'9') c=getchar();
	while (c>='0'&&c<='9') res=(res<<3)+(res<<1)+(c^48),c=getchar();
	return res;
}
void write(int x) {
	if (!x) return;
	write(x/10);
	putchar(x%10+48);
	return;
}
int n,now,val[N<<2];
inline void pushup(int p) {
	val[p]=val[p<<1]+val[p<<1|1];
	return;
}
void build(int p,int l,int r) {
	if (l==r) {
		val[p]=1;
		return;
	}
	int mid=l+r>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	pushup(p);
	return;
}
void upd(int p,int l,int r,int x) {
	if (l==r) {
		val[p]--;
		return;
	}
	int mid=l+r>>1;
	if (x<=mid) upd(p<<1,l,mid,x);
	else upd(p<<1|1,mid+1,r,x);
	pushup(p);
	return;
}
int sum(int p,int l,int r,int L,int R) {
	if (L<=l&&r<=R) return val[p];
	int mid=l+r>>1,res=0;
	if (L<=mid) res+=sum(p<<1,l,mid,L,R);
	if (R>mid) res+=sum(p<<1|1,mid+1,r,L,R);
	return res;
}
int get(int p,int l,int r,int k) {
	if (l==r) return l;
	int mid=l+r>>1;
	if (val[p<<1]>=k) return get(p<<1,l,mid,k);
	return get(p<<1|1,mid+1,r,k-val[p<<1]);
}
int main() {
	n=read();
	build(1,1,n<<1);
	now=1;
	for (int i=1;i<=n;i++) {
		int x;
		x=read();
		x%=(n-i+1);//环状结构，模一下，不知道需不需要
		if (i!=1) x++;//细节，自己画着推一下
		int res=sum(1,1,n<<1,1,now);
		now=get(1,1,n<<1,res+x);//往后找，res是补全用的
		if (now>n) now-=n;//保证下次寻找不会越界
		write(now);
		putchar('\n');
		upd(1,1,n<<1,now),upd(1,1,n<<1,now+n);//删除
	}
	return 0;
}
```

---

## 作者：lemondinosaur (赞：0)

[传送门](https://www.luogu.com.cn/problem/P3988)

---
# 分析
~~fake：此题不就是链表模拟题吗，我一开始还真这么想~~

貌似链表什么用都没有，根据题意很清楚，要找一个支持删除和查询区间第$k$大的数据结构

解释一下为什么题目可以转换为查询区间第$k$大，

如果记录一下上一次删除的位置（这里指的是排名）和总牌数，是不是可以从$上一次删除位置+kth$对总牌数取模以重新找到下一次查询的排名，这样周而复始

那这个数据结构要找什么呢~~平衡树~~

平衡树当然可以，但是我目前只敲过模板，所以还是算了

也可以用线段树，维护区间未被删除的数的个数，查询第$k$大时，如果左区间未被删除的数的个数不小于在当前区间的排名，那么往左边走，否则往右边走

时间复杂度是$O(n \log n)$。（当然可以用树状数组+倍增解决，时间复杂度相同）

~~然而跑得比多带一个log的树状数组+二分还要慢~~

---
# 代码

```cpp
#include <cstdio>
#include <cctype>
#define rr register
using namespace std;
int w[2800011],n;
inline signed iut(){
	rr int ans=0; rr char c=getchar();
	while (!isdigit(c)) c=getchar();
	while (isdigit(c)) ans=(ans<<3)+(ans<<1)+(c^48),c=getchar();
	return ans;
}
void print(int ans){
    if (ans>9) print(ans/10);
    putchar(ans%10+48);
}
inline void build(int k,int l,int r){
    if (l==r) {w[k]=1; return;}
    rr int mid=(l+r)>>1;
    build(k<<1,l,mid),build(k<<1|1,mid+1,r);
    w[k]=w[k<<1]+w[k<<1|1];
}
inline void update(int k,int l,int r,int x){
    if (l==r) {w[k]=0; return;}
    rr int mid=(l+r)>>1;
    if (x<=mid) update(k<<1,l,mid,x);
        else update(k<<1|1,mid+1,r,x);
    w[k]=w[k<<1]+w[k<<1|1];
}
inline signed kth(int k,int l,int r,int x){
    if (l==r) return l;
    rr int mid=(l+r)>>1;
    if (w[k<<1]>=x) return kth(k<<1,l,mid,x);
        else return kth(k<<1|1,mid+1,r,x-w[k<<1]);
}
signed main(){
    n=iut(),build(1,1,n);
    for (rr int i=1,now=1;i<=n;++i,putchar(10)){
        rr int t=(iut()+now)%w[1],del; if (!t) t=w[1];
        print(del=kth(1,1,n,now=t)),update(1,1,n,del);
    }
    return 0;
}
```

---

## 作者：localhost (赞：0)

提供一个简洁的fhq-treap做法(当然可以换成其他更快的平衡树)

直接模拟，把平衡树当做可以$\Theta(\log n)$访问并删除任意位置的链表

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(3)
const int N=700011;
#define ls c[rt][0]
#define rs c[rt][1]
int n,q,sz[N],c[N][2],val[N],rnd[N],rev[N],RT=0,cnt=0;
int gi(){char c;int x=0;while((c=getchar_unlocked())<'0'||'9'<c);while('0'<=c&&c<='9')x=x*10+c-48,c=getchar_unlocked();return x;}
int ne(int v){
    val[++cnt]=v;
    sz[cnt]=1;
    rnd[cnt]=rand()<<15|rand();
    return cnt;
}
void pu(int rt){sz[rt]=sz[ls]+sz[rs]+1;}
void sl(int rt,int k,int &x,int &y){
    if(!rt)return (void)(x=y=0);
    if(sz[ls]>=k)y=rt,sl(ls,k,x,ls);
    else x=rt,sl(rs,k-sz[ls]-1,rs,y);
    pu(rt);
}
int mg(int x,int y){
    if(!x||!y)return x+y;
    if(rnd[x]<rnd[y]){
        c[x][1]=mg(c[x][1],y);
        pu(x);return x;
    }
    else{
        c[y][0]=mg(x,c[y][0]);
        pu(y);return y;
    }
}
int get(int p){
    int x,y,z,t;
    sl(RT,p,x,z);
    sl(x,p-1,x,y);
    t=val[y];
    RT=mg(mg(x,mg(c[y][0],c[y][1])),z);
    return t;
}
int main(){
    srand(time(0));
    int n=gi(),cur=1;
    for(int i=1;i<=n;++i)RT=mg(RT,ne(i));
    for(int i=1;i<=n;++i){
        cur=(cur+gi()-1)%(n-i+1)+1;//顶部牌所在位置
        printf("%d\n",get(cur));
    }
}
```

---

## 作者：ButterflyDew (赞：0)

看了沙茶数据范围，我就放弃了平衡树，毕竟我这种人丑常数大的选手？

然后开始思考线段树或者树状数组，yy了好一会儿才想出一个沙茶的做法，写了以后发现题解好像没有我这么写的，就来口胡一下。

在线段树上维护每个点左边还有多少个元素存在。

每次询问的时候，有一个上次开始的删去的位置$s$(初始为$0$)，然后统计一下$s$前面有多少个元素，判断这次删掉的是在$s$左边还是右边。

假设每次输入的是$d$，如果在$s$左边，就$d-$右边元素个数，在右边就$d+$左边元素个数，然后直接在线段树上二分找就可以了。

------

**Code:**

```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
using std::max;
const int N=7e5+10;
int read()
{
	int x=0;char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) x=x*10+c-'0',c=getchar();
	return x;
}
int sum[N],n,s;
void add(int x){while(x<=n)++sum[x],x+=x&-x;}
int ask(int x){int ret=0;while(x)ret+=sum[x],x-=x&-x;return ret;}
int mx[N<<2],tag[N<<2];
#define ls id<<1
#define rs id<<1|1
void build(int id,int l,int r)
{
	mx[id]=r;
	if(l==r)return;
	int mid=l+r>>1;
	build(ls,l,mid),build(rs,mid+1,r);
}
void pushdown(int id)
{
	if(tag[id])
	{
		mx[ls]+=tag[id],mx[rs]+=tag[id];
		tag[ls]+=tag[id],tag[rs]+=tag[id];
		tag[id]=0;
	}
}
void query(int id,int l,int r,int k)
{
	if(l==r) {printf("%d\n",s=l),mx[id]=0,add(l);return;}
	pushdown(id);
	int mid=l+r>>1;
	if(mx[ls]>=k) query(ls,l,mid,k);
	else query(rs,mid+1,r,k);
}
void change(int id,int l,int r,int p)
{
	if(l>=p){--mx[id],--tag[id];return;}
	pushdown(id);
	int mid=l+r>>1;
	if(p<=mid) change(ls,l,mid,p);
	change(rs,mid+1,r,p);
	mx[id]=max(mx[ls],mx[rs]);
}
int main()
{
	n=read();
	build(1,1,n);
	for(int rig,lef,r,i=n;i;i--)
	{
		r=read()%i;
		lef=s-ask(s);//左边个数
		rig=i-lef;//右边个数
		if(rig<=r) r-=rig;//左边
		else r+=lef;
		query(1,1,n,r+1);
		change(1,1,n,s);
	}
	return 0;
}
```

---


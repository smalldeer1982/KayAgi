# [NOI2003] 文本编辑器

## 题目描述

很久很久以前，$DOS3.x$ 的程序员们开始对 $EDLIN$ 感到厌倦。于是，人们开始纷纷改用自己写的文本编辑器⋯⋯

多年之后，出于偶然的机会，小明找到了当时的一个编辑软件。进行了一些简单的测试后，小明惊奇地发现：那个软件每秒能够进行上万次编辑操作（当然，你不能手工进行这样的测试） ！于是，小明废寝忘食地想做一个同样的东西出来。你能帮助他吗？

为了明确目标，小明对“文本编辑器”做了一个抽象的定义:

文本：由 $0$ 个或多个 ASCII 码在闭区间 [$32$, $126$] 内的字符构成的序列。

光标：在一段文本中用于指示位置的标记，可以位于文本首部，文本尾部或文本的某两个字符之间。


文本编辑器：由一段文本和该文本中的一个光标组成的，支持如下操作的数据结构。如果这段文本为空，我们就说这个文本编辑器是空的。

| 操作名称  | 输入文件中的格式  | 功能  |
| :------------ | :------------ | :------------ |
| $\text{Move}(k)$  | Move k  |  将光标移动到第 $k$ 个字符之后，如果 $k=0$，将光标移到文本开头 |
| $\text{Insert}(n,s)$  | Insert n s  | 在光标处插入长度为 $n$ 的字符串 $s$，光标位置不变$n\geq1$|
| $\text{Delete}(n)$  | Delete n  | 删除光标后的 $n$ 个字符，光标位置不变，$n \geq 1$  |
| $\text{Get}(n)$  | Get n  |输出光标后的 $n$ 个字符，光标位置不变，$n \geq 1$   |
| $\text{Prev}()$  | Prev  | 光标前移一个字符  |
| $\text{Next}()$  | Next |  光标后移一个字符 |


你的任务是：

- 建立一个空的文本编辑器。

- 从输入文件中读入一些操作并执行。

- 对所有执行过的 `GET` 操作，将指定的内容写入输出文件。


## 样例 #1

### 输入

```
15
Insert 26
abcdefghijklmnop
qrstuv wxy
Move 15
Delete 11
Move 5
Insert 1
^
Next
Insert 1
_
Next
Next
Insert 4
.\/.
Get 4
Prev
Insert 1
^
Move 0
Get 22

```

### 输出

```
.\/.
abcde^_^f.\/.ghijklmno
```

# 题解

## 作者：HenryHuang (赞：33)

求管理员让过

先推广一下 

# [MY BLOG](https://www.cnblogs.com/HenryHuang-Never-Settle/p/10803406.html)


---

我们考虑这样的一个问题

给你一个序列，要求你支持插入，删除，查询单点值

如果用数组，查询O(1),插入删除最坏O(n)

如果用链表，插入删除O(1),查询最坏O(n)

如果用平衡树……

~~不要跟我说平衡树~~

那么我们是否可以考虑:将一个一个的数组以链表的形式串起来,这样是否会提高操作的效率，又是否会降低一些操作的效率呢？

![](https://i.loli.net/2019/05/02/5ccaea7489faa.png)

可以手动模拟一下各种操作

块状链表就是这样一个略显暴力的算法

但其复杂度较为优秀，所以在很多地方的应用都非常广

用一句话说叫“弱弱联合”

码量~~稍~~大，但极易理解，打着打着就打出两百~~K~~行

先介绍一下比较基本的操作吧

### Spilt
当一个块的长度过大，我们就可以考虑将其分裂成两个较小的块。

在处理类似于插入或者删除这类操作时，我们可以先从当前位置将其分裂成两个块，这样就可以十分方便的进行操作了。

![](https://i.loli.net/2019/05/02/5ccaeb4da07e5.png)

### Merge

同理,就是$Split$的逆运算。

### 部分Maintain

看到很多代码对于每一次操作都遍历一遍整个链表，其实大可不必。

姑且称其为部分maintain吧，我也不知道叫什么。

在进行操作时，我们可能会使得一些块过大，一些块过小。

所以我们需要通过$Spilt$或者$Merge$来调整。

我们发现，在进行操作时所需要考虑的需要维护的块:区间前的那一块与区间开头块；区间末尾块与区间后的那一块。

这样做**可能**会使得块状链表没有在经过完整maintain操作时平衡，但会**大大减少**维护时的常数，而平衡程度也可以接受。

一般采用的维护方法：保证相邻两块大小加起来大于$\sqrt{n}$,但每块大小不超过$\sqrt{n}$，这样可以较好的维护平衡，同时不用考虑当块较大时的$Split$操作，可以使块的数量控制在$[\sqrt{n},\sqrt{2n}]$

这是作者经过权衡后得出的做法，实测复杂度优秀，复杂度为$O(1)$。

---

然后，我们切入正题。

### Insert

查找光标块内的位置，在此位置将块分裂，然后将字符串**一块一块**地插入

### Delete

同理

### Get

不许要分裂，直接利用$memcpy$函数，对其进行复制粘贴即可

代码中有较详细注释，贴代码

```cpp
#include<bits/stdc++.h>
using namespace std;
char xch,xB[1<<15],*xS=xB,*xTT=xB;
#define getc() (xS==xTT&&(xTT=(xS=xB)+fread(xB,1,1<<15,stdin),xS==xTT)?0:*xS++)
inline int read()
{
    int x=0,f=1;char ch=getc();
    while(ch<'0'|ch>'9'){if(ch=='-')f=-1;ch=getc();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getc();}
    return x*f;
}//为了使程序跑得更快所使用的读入优化 
const int maxn=2e3+10;
struct node{
    int nex,siz;//每一块数组的后继以及大小 
    char a[maxn<<1];
}b[maxn<<2];
int pool[maxn<<2],cnt,curpos;//内存池、指针以及当前光标位置 
inline int modi(){return pool[cnt++];}//内存分配 
inline void dele(int x){pool[--cnt]=x;}//内存回收 
inline void init()
{
    for(int i=1;i<(maxn<<2);++i) pool[i]=i;//维护内存池，动态分配回收内存 
    cnt=1;
    b[0].siz=0,b[0].nex=-1;//新建一个0号节点，方便操作 
}
inline void add(int x,int y,int num,char c[])//在第x块后添加一个编号为y的块，长度为num 
{
    if(y!=-1)
    {
        b[y].nex=b[x].nex,b[y].siz=num;
        memcpy(b[y].a,c,num);
    }
    b[x].nex=y;
}
inline void merge(int x,int y)//将第x块和第y块合并 
{
    memcpy(b[x].a+b[x].siz,b[y].a,b[y].siz);
    b[x].siz+=b[y].siz,b[x].nex=b[y].nex;
    dele(y);
}
inline void split(int cur,int pos)//将第cur块从pos处分割 
{
    if(cur==-1||pos==b[cur].siz) return ;
    add(cur,modi(),b[cur].siz-pos,b[cur].a+pos);
    b[cur].siz=pos;
}
inline int pos(int &x)//寻找当前光标所在的块和块内位置 
{
    int now=0;
    while(now!=-1&&x>b[now].siz) x-=b[now].siz,now=b[now].nex;
    return now;
}
inline void insert(int p,int num,char c[])//在p位置之后插入长度为num的字符串 
{
    int now=pos(p);
    split(now,p);
    int tot=0,nb,st=now;
    while(tot+maxn<=num)//维护块状链表平衡 
    {
        nb=modi();
        add(now,nb,maxn,c+tot);
        tot+=maxn;
        now=nb;
    }
    if(num-tot)
        nb=modi(),add(now,nb,num-tot,c+tot);
    if(b[now].siz+b[nb].siz<maxn&&nb!=-1)//不用对整个链表进行判断，部分maintain 
    	merge(now,nb),nb=b[now].nex;
    if(b[st].siz+b[b[st].nex].siz<maxn&&b[st].nex!=-1)//同理 
    	merge(st,b[st].nex);
//    maintain();
}
inline void erase(int p,int num)//在p位置之后删除长度为num的字符串
{
    int now=pos(p);
    split(now,p);
    int nex=b[now].nex;
    while(nex!=-1&&num>b[nex].siz)
        num-=b[nex].siz,nex=b[nex].nex;
    split(nex,num);
    nex=b[nex].nex;
    for(int i=b[now].nex;i!=nex;i=b[now].nex)
        b[now].nex=b[i].nex,dele(i);
    while(b[now].siz+b[nex].siz<maxn&&nex!=-1)//不用对整个链表进行判断，部分maintain 
    	merge(now,nex),nex=b[now].nex;
//    maintain();
}
char ans[20000000];
inline void get(int p,int num)//输出p位置后长度为num的字符串
{
    int cur=pos(p);
    int tot=b[cur].siz-p;
    if(num<tot) tot=num;
    memcpy(ans,b[cur].a+p,tot);
    int now=b[cur].nex;
    while(now!=-1&&num>=tot+b[now].siz)
    {
        memcpy(ans+tot,b[now].a,b[now].siz);
        tot+=b[now].siz,now=b[now].nex;
    }
    if(num-tot>0&&now!=-1)
        memcpy(ans+tot,b[now].a,num-tot);
    ans[num]='\0';//为了不清空，用\0结束 
    printf("%s\n",ans);
}
inline char opt()
{
	char c=getc();
	while(c!='M'&&c!='I'&&c!='D'&&c!='G'&&c!='P'&&c!='N') c=getc();
	return c;
}//为了不与读入优化冲突 
int main()
{
//	freopen("3.in","r",stdin);
//	freopen("3.ans","w",stdout);
    init();
    int m;

    scanf("%d",&m);
    for(int i=1;i<=m;++i)
    {
        switch(opt())
        {
            case 'M':curpos=read();break;
            case 'I':
                int tmp;
                tmp=read();
                for(int i=0;i<tmp;++i)
                {
                    ans[i]=getc();
                    if(ans[i]<32||ans[i]>126) --i;
                }
                insert(curpos,tmp,ans);
                    break;
            case 'D':
                tmp=read();
                erase(curpos,tmp);
                break;
            case 'G':
                tmp=read();
                get(curpos,tmp);
                break;
            case 'P':--curpos;break;
            case 'N':++curpos;break;
        }
    }
    return 0;
}
```








---

## 作者：hyfhaha (赞：17)

# S~~p~~lay大法吼啊

就像楼上大佬说的，Splay是序列之王，所以解决这种问题简直是毫无问题啊。

首先，如果你做过[**P2042** [NOI2005]维护数列](https://www.luogu.org/problemnew/show/P2042)那么这道题简直是小菜一碟，如果没有做过也不要紧，看这里[区间树Splay——[NOI2005]维护数列](https://www.cnblogs.com/hyfhaha/p/10749519.html)，好吧，如果你实在是不想做那道毒瘤题，也不要紧，我一样会在这里详细地讲清楚步骤的QwQ。

首先是对区间树Splay的一个介绍，直接引用了自己的blog

# 区间树Splay介绍

做过“普通平衡树”的都知道，在“普通平衡树”里，Splay是按照权值来排序的，所以能维护数的关系。那么现在到了维护区间上的操作了，也就不能按权值来排序了。

区间树，我们按照的是序列中的**编号**来排序。

我们可以发现，序列中的第**k**个点，在Splay中也是第**k**大的。（按编号排序嘛

所以我们想要查找序列中第**k**个位置，就直接找**Splay**中的第**k**大就可以了。

所以“普通平衡树”里的**Splay**操作，**rotate**操作和**kth**操作都是可以直接照搬的（一样的，只是维护编号而已

那么我们怎么在Splay中找到一个区间[x,y]呢？

我们可以考虑Splay的性质，将 **x** Splay上根，再将 **y** Splay上到x的右节点，那么我们得出的 **y** 的左子树就是我们要的[x,y]区间。

之后我们想对这个区间做什么就可以直接对那颗子树做了。 

上面就是区间树Splay的一些介绍

### 代码中的一些宏定义

```cpp
#define L(node) (tree[node].ch[0])		//替左儿子
#define R(node) (tree[node].ch[1])		//替右儿子
#define F(node) (tree[node].fa)			//替父亲
#define V(node) (tree[node].val)		//替权值
#define S(node) (tree[node].size)		//替子树大小
```

## 定义

```cpp
struct kkk{
	int ch[2],size,fa;	//基本信息，左右儿子，子树大小和父亲
	char val;						//当前的信息
	void clear(){ch[0]=ch[1]=fa=0;}	//清空
}tree[maxn];
```



# 操作剖析

这里让我们维护一个光标，其实就是维护我们要在序列中操作的位置。至于怎么维护，开个变量就可以啦，可以说是没有什么脑子了。代码中的GB就是光标啦QvQ！

然后我们来处理一下边界，要知道区间树Splay的边界是必要的，所以怎么加这个边界也是一个问题，其实我们可以直接运用“维护数列”那道题的方法，只不过刚开始不用再输入数而已。

然后插入操作写在insert函数里了

删除操作写在eraser里了

查询操作写在query里了

这里先放一下主函数：

```cpp
int main(){
	scanf("%d",&m);n=0;
	a[1]=a[n+2]=-inf;
	for(int i=1;i<=n+2;i++)id[i]=i;	//边界,n=0所以其实就是1和2两个边界而已
	build(1,n+2,0);	//一样只有1和2两个边界
	cnt=n+2;root=(n+3)>>1;	//一样发现cnt就是2，root就是1
	for(int i=1;i<=m;i++){
		scanf("%s",mode);
		if(mode[0]=='P'){GB--;continue;}	//维护光标左移
		if(mode[0]=='N'){GB++;continue;}	//维护光标右移
		scanf("%d",&len);
		if(mode[0]=='M')GB=len;				//维护光标移动
		if(mode[0]=='I')insert(GB,len);		//插入，已经自动默认是GB后面了，所以不用+1
		if(mode[0]=='D')eraser(GB+1,len);	//删除，GB+1是GB的后面
		if(mode[0]=='G')query(GB+1,len);	//查询，一样要+1
		//printf("PRINT:"); print(root);printf("\n");
	}
	return 0;
}
```

## 1.基本操作 Splay,rotate,kth

这个就不用怎么说了吧，大家在做平衡树Splay都写过的啦！一样的！

## 2.将指定区间找出来 split操作

和上面讲的区间树一样，先找到区间[l,r]的kth，计**l**的kth为**x**，**r**的kth为**y**。

然后Splay(x,0);Splay(y,x); （直接上代码解释）

最后返回**y**的**左儿子**就是指定区间

代码：

```cpp
int split(int k,int len){	//找到那个区间的位置
	int x=kth(k),y=kth(k+len+1);
	Splay(x,0);Splay(y,x);
	return L(y);						//返回的即是区间在Splay树上的位置
}
```

## 3.建一颗平衡的Splay，build操作

一开始我们要构造一颗有初始信息的Splay，一个一个insert显然很慢，所以我们写一个build，可以将一段序列建成一颗平衡的Splay的操作。

其实写起来和**线段树**差不多，注意是以**编号**排序来建树。

```cpp
void build(int begin,int end,int pre){
	int mid=(begin+end)>>1;int node=id[mid],fa=id[pre];
	if(begin==end){tree[node].size=1;tree[node].val=a[begin];}	//一样的赋值信息
	if(begin<mid)build(begin,mid-1,mid);		//左儿子建树
	if(end>mid)build(mid+1,end,mid);				//右儿子建树
	tree[node].val=a[mid];tree[node].fa=fa;		//赋值信息
	pushup(node);				//更新一下size
	tree[fa].ch[mid>=pre]=node;
}
```

## 4.插入insert操作

这玩意的输入要注意一下啦！

这里题目要求的是在GB位置后插入一段长为len的序列

如果我们还是一个一个插入，仍然很慢，所以我们可以直接把插入的序列build成一颗平衡的子树，最后直接在GB后插入建成的子树就可以了。

```cpp
void insert(int k,int len){
	for(int i=1;i<=len;i++){
		a[i]=getchar();			//读入注意一下
		if(a[i]=='\n'||a[i]=='\r')--i;
	}
	for(int i=1;i<=len;i++)id[i]=rublish();	//从垃圾桶里拿编号，减少空间
	build(1,len,0);				//build成一颗完全二叉树
	int z=id[(len+1)>>1];
	int x=kth(k+1),y=kth(k+2);
	Splay(x,0);Splay(y,x);
	tree[z].fa=y; tree[y].ch[0]=z;	//将树插到原树上
	pushup(y); pushup(x);	//更新
}
```

## 5.删除操作 eraser

这个就更简单了，直接找到那个区间，然后让那个子树的父亲将左儿子清为0就可以了。

但是，为了节省空间，我们加入了一个垃圾回收的操作，就是将删除的节点重新利用起来，以节省空间

所以我们还要遍历一遍子树将那颗子树的节点扔进垃圾桶里

```cpp
int rublish(){				//垃圾回收
	if(top==0)return ++cnt;
	int node=rub[top--];
	return node;
}
void remove(int node){		//将一个子树清空
	if(L(node))remove(L(node));		//继续清空左子树
	if(R(node))remove(R(node));		//继续清空右子树
	rub[++top]=node; tree[node].clear();	//清空并仍进垃圾桶，定义里有
}
void eraser(int x,int len){			//删除区间
	int node=split(x,len),y=F(node);//找到该区间
	remove(node);tree[y].ch[0]=0;	//删除该区间，子树清空
	pushup(y);pushup(F(y));			//维护信息
}
```

## 6.查询 query

找到那个区间，然后遍历整个树，输出答案。

```cpp
void print(int node){
	if(L(node))print(L(node));	//往左儿子走
	printf("%c",tree[node].val);//输出当前的信息
	if(R(node))print(R(node));	//往右儿子走
}
void query(int x,int len){
	int node=split(x,len);			//找到该区间
	print(node);printf("\n");		//中序遍历输出
}
```

## 7.更新pushup

更新size就好了，这里大家总知道怎么更新吧

# 总代码

```cpp
#include<bits/stdc++.h>
#define maxn 700001
#define inf 0
#define L(node) (tree[node].ch[0])
#define R(node) (tree[node].ch[1])
#define F(node) (tree[node].fa)
#define S(node) (tree[node].size)
#define V(node) (tree[node].val)
using namespace std;
struct kkk{
	int ch[2],size,fa;
	char val;
	void clear(){ch[0]=ch[1]=fa=0;}
}tree[maxn];
int id[maxn],rub[maxn],n,m,x,len,y,top,cnt,root,GB;
char mode[21],a[maxn];
int rublish(){
	if(top)return rub[top--];
	return ++cnt;
}
void pushup(int node){tree[node].size=tree[L(node)].size+tree[R(node)].size+1;}
void rotate(int node){
	int fa=F(node);
	int gfa=F(fa);
	int z=tree[fa].ch[1]==node;
	tree[gfa].ch[tree[gfa].ch[1]==fa]=node; tree[node].fa=gfa;
	tree[fa].ch[z]=tree[node].ch[z^1]; tree[tree[node].ch[z^1]].fa=fa;
	tree[node].ch[z^1]=fa; tree[fa].fa=node;
	pushup(fa); pushup(node);
}
void Splay(int node,int goal){
	while(tree[node].fa!=goal){
		int fa=F(node);
		int gfa=F(fa);
		if(gfa!=goal)
		((tree[gfa].ch[1]==fa)==(tree[fa].ch[1]==node))?rotate(fa):rotate(node);
	 	rotate(node);
	}
	if(!goal)root=node;
}
int kth(int x){
	int node=root;
	while(1){
		if(tree[L(node)].size>=x)node=L(node);
		else{x-=tree[L(node)].size;
			if(x==1) return node;
			x--;node=R(node); 
		}
	}
}
void build(int begin,int end,int pre){
	int mid=(begin+end)>>1;int node=id[mid],fa=id[pre];
	if(begin==end){tree[node].size=1;tree[node].val=a[begin];}
	if(begin<mid)build(begin,mid-1,mid);
	if(end>mid)build(mid+1,end,mid);
	tree[node].val=a[mid];tree[node].fa=fa;
	pushup(node);
	tree[fa].ch[mid>=pre]=node;
}
int split(int k,int len){
	int x=kth(k),y=kth(k+len+1);
	Splay(x,0);Splay(y,x);
	return L(y);
}
void insert(int k,int len){
	for(int i=1;i<=len;i++){
		a[i]=getchar();
		if(a[i]=='\n'||a[i]=='\r')--i;
	}
	for(int i=1;i<=len;i++)id[i]=rublish();
	build(1,len,0);
	int z=id[(len+1)>>1];
	int x=kth(k+1),y=kth(k+2);
	Splay(x,0);Splay(y,x);
	tree[z].fa=y; tree[y].ch[0]=z;
	pushup(y); pushup(x);
}
void remove(int node){
    if(L(node))remove(L(node));
    if(R(node))remove(R(node));
    rub[++top]=node; tree[node].clear();
}
void eraser(int x,int len){
	int node=split(x,len),fa=F(node);
	tree[fa].ch[0]=0;remove(node);
	pushup(fa); pushup(F(fa));
}
void print(int node){
	if(L(node))print(L(node));
	printf("%c",tree[node].val);
	if(R(node))print(R(node));
}
void query(int x,int len){
	int node=split(x,len);
	print(node);printf("\n");
}
int main(){
	scanf("%d",&m);
	a[1]=a[n+2]=-inf;
	for(int i=1;i<=n+2;i++)id[i]=i;
	build(1,n+2,0);
	cnt=n+2;root=(n+3)>>1;
	for(int i=1;i<=m;i++){
		scanf("%s",mode);
		if(mode[0]=='P'){GB--;continue;}
		if(mode[0]=='N'){GB++;continue;}
		scanf("%d",&len);
		if(mode[0]=='M')GB=len;
		if(mode[0]=='I')insert(GB,len);
		if(mode[0]=='D')eraser(GB+1,len);
		if(mode[0]=='G')query(GB+1,len);
		//printf("PRINT:"); print(root);printf("\n");
	}
	return 0;
}
```

# 后记

还是推荐大家去做一下“维护数列”那道题，比这道题不知道高明到哪里去了。

~~我和它谈笑风生~~

---

## 作者：litble (赞：14)

两种做法都介绍一下。

# 块状链表

优点是代码写起来比写splay爽一些，而且更为直观（本蒟蒻的代码只有90分）

块状链表是一个个数组块，用链表穿起来得到的结果，解决了普通数组插入的困难和普通链表查询的困难，一种根号复杂度的数据结构。

插入的时候要记得当导致块过大的时候就要分裂，查询的时候要记得去除大小为0的块，以及每次移动光标的时候去移动记录光标在块状链表位置的两个指针会更快一些。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define ksz 2000
int T,b1=1,b2,cn=1,gb,len;
struct node{char a[2300];int sz,pre,nxt;} p[7005];
void move() {//移动光标，即查询操作，暴力找块大小即可
    int pos;scanf("%d",&pos);
    b1=p[0].nxt;int tot=0;
    while(tot+p[b1].sz<pos) tot+=p[b1].sz,b1=p[b1].nxt;
    b2=pos-tot;
}
void ins() {//插入操作
    char ch;int d1=b1,d2=b2;
    while(len--) {
        ch=getchar();while(ch<32||ch>126) ch=getchar();
        if(p[d1].sz==ksz) {//注意不要让块变得太大了
            ++cn,p[cn].pre=d1,p[cn].nxt=p[d1].nxt;
            p[p[d1].nxt].pre=cn,p[d1].nxt=cn;
            for(int i=d2+1;i<=p[d1].sz;++i) p[cn].a[++p[cn].sz]=p[d1].a[i];
            p[d1].sz=d2,d1=cn,d2=0;
        }
        for(int i=p[d1].sz;i>d2;--i) p[d1].a[i+1]=p[d1].a[i];
        ++p[d1].sz,p[d1].a[++d2]=ch;
    }
}
void del() {//删除操作
    int d1=b1,d2=b2;
    while(len) {//切记不要一个一个的删，太慢了！
        int kl=p[d1].sz-d2;
        if(len>kl) len-=kl,p[d1].sz=d2,d1=p[d1].nxt,d2=0;
        else {
            for(int i=d2+len+1;i<=p[d1].sz;++i) p[d1].a[i-len]=p[d1].a[i];
            p[d1].sz-=len,len=0;
        }
    }
}
//去除为0的块是非常非常重要的
void query() {//查询操作
    int d1=b1,d2=b2;
    while(len) {//也不要一个一个地输出
        while(!p[d1].sz)
        p[p[d1].pre].nxt=p[d1].nxt,p[p[d1].nxt].pre=p[d1].pre,d1=p[d1].nxt;
        int kl=p[d1].sz-d2;
        if(len>kl) {
            for(int i=d2+1;i<=p[d1].sz;++i) putchar(p[d1].a[i]);
            len-=kl,d1=p[d1].nxt,d2=0;
        }
        else {
            for(int i=1;i<=len;++i) putchar(p[d1].a[i+d2]);
            len=0;
        }
    }
    puts("");
}
void move_front() {
    if(b2) --b2;
    else {
        b1=p[b1].pre;
        while(!p[b1].sz)
        p[p[b1].pre].nxt=p[b1].nxt,p[p[b1].nxt].pre=p[b1].pre,b1=p[b1].nxt;
        b2=p[b1].sz-1;//!!!
    }
}
void move_next() {
    if(b2<p[b1].sz) ++b2;
    else {
        b1=p[b1].nxt,b2=1;
        while(!p[b1].sz)
        p[p[b1].pre].nxt=p[b1].nxt,p[p[b1].nxt].pre=p[b1].pre,b1=p[b1].nxt;
    }
}
int main()
{
    char ch[10];
    scanf("%d",&T),p[0].nxt=1;
    while(T--) {
        scanf("%s",ch);
        if(ch[0]=='M') move();
        else if(ch[0]=='I') scanf("%d",&len),ins();
        else if(ch[0]=='D') scanf("%d",&len),del();
        else if(ch[0]=='G') scanf("%d",&len),query();
        else if(ch[0]=='P') move_front();
        else move_next();
    }
    return 0;
}
```
# splay

优点是快，万能。缺点就是代码打得浑身难受。

身为序列之王的splay，不会被这种题目难倒。如果你是首次接触splay，[卖个安利](http://blog.csdn.net/litble/article/details/74612868 )

那么此题涉及的splay操作就是查询第k个数，插入，删除，和输出。对于熟练splay的人应该不难，可以看代码的注释。

总之，如果要对一个区间进行操作，就把区间左端点的左边那个点splay到根，右端点右边那个点splay到根的右儿子，然后对根的右儿子的左子树进行操作。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2100000;
int T,GB,len,rot,trs,sss;
int son[N][2],f[N],siz[N];char c[N],s[N];
void up(int x) {siz[x]=siz[son[x][0]]+siz[son[x][1]]+1;}
int is(int x) {return son[f[x]][1]==x;}
void spin(int x,int &mb) {//旋转操作
    int fa=f[x],g=f[fa],t=is(x);
    if(fa==mb) mb=x;
    else son[g][is(fa)]=x;
    f[fa]=x,f[x]=g,f[son[x][t^1]]=fa;
    son[fa][t]=son[x][t^1],son[x][t^1]=fa;
    up(fa),up(x);
}
void splay(int x,int &mb) {//splay操作
    while(x!=mb) {
        if(f[x]!=mb) {
            if(is(x)^is(f[x])) spin(x,mb);
            else spin(f[x],mb);
        }
        spin(x,mb);
    }
}
int find(int x,int kth) {//查找第k个数
    if(siz[son[x][0]]+1==kth) return x;
    if(siz[son[x][0]]>=kth) return find(son[x][0],kth);
    return find(son[x][1],kth-siz[son[x][0]]-1);
}
void build(int l,int r,int fa,int fnum,char *s) {//建树
    if(l>r) return;
    int mid=(l+r)>>1,t;
    ++sss,t=sss;
    if(l!=r) build(l,mid-1,t,0,s),build(mid+1,r,t,1,s);
    c[t]=s[mid],f[t]=fa,son[fa][fnum]=t,up(t);
}
void print(int x) {//按照左根右的顺序进行输出
    if(son[x][0]) print(son[x][0]);
    putchar(c[x]);
    if(son[x][1]) print(son[x][1]);
}
int main()
{
    char ch[20];int x,y,l,r;
    scanf("%d",&T);
    ch[0]=ch[1]=ch[2]=c[0]=' ',rot=1,build(1,2,0,0,ch);
    while(T--) {
        scanf("%s",ch);
        if(ch[0]=='M') scanf("%d",&GB);//GB:光标位置
        else if(ch[0]=='I') {
            scanf("%d",&len),trs+=len,s[0]=' ';
            for(int i=1;i<=len;++i) {
                s[i]=getchar();
                if(s[i]=='\n'||s[i]=='\r') --i;
            }
            x=find(rot,GB+1),y=find(rot,GB+2);
            splay(x,rot),splay(y,son[x][1]),build(1,len,y,0,s);//先建立一棵子树后再插入，保证平衡
        }
        else if(ch[0]=='D') {
            scanf("%d",&len),len=min(len,trs-GB),trs-=len;
            x=find(rot,GB+1),y=find(rot,GB+len+2);
            splay(x,rot),splay(y,son[x][1]),son[y][0]=0;//删除区间，不用垃圾回收
        }
        else if(ch[0]=='G') {
            scanf("%d",&len),len=min(len,trs-GB);
            x=find(rot,GB+1),y=find(rot,GB+len+2);
            splay(x,rot),splay(y,son[x][1]),print(son[y][0]),puts("");//输出
        }
        else if(ch[0]=='P') --GB;
        else if(ch[0]=='N') ++GB;
    }
    return 0;
}
```

---

## 作者：sherlock55341 (赞：13)

# 非旋Treap做法
驚了，居然沒人用Treap做  
我趕緊水上一篇非旋Treap做法  i
本人手賤，用下面的Splay的題解比了一下速度，Splay780ms,Treap1680ms  
但是由於Treap不消耗腦細胞而且好寫很多，並且並不耽誤AC  
所以還是學一學比較好  
非旋Treap基本操作及概念詳見我的博客  
維護前驅後繼等的做法：[非旋Treap維護普通平衡樹的基本操作](http://blog.csdn.net/assass_cannotin/article/details/79309828)
區間翻轉：[ 非旋Treap的區間翻轉（文藝平衡樹）](http://blog.csdn.net/assass_cannotin/article/details/79311113)  
維修數列：[Treap永不旋轉！！！[維修數列]](http://blog.csdn.net/assass_cannotin/article/details/79313901)  
這道題很簡單，只要掌握到區間建樹的$O(n)$做法就可以解決了 
建樹方法在第三篇文章  
AC代碼  
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
template<class a,class b>class Pair
{
public:
  a first;
  b second;
  Pair(){}
  Pair(a x,b y){first=x,second=y;}
};
inline void read(int &x)
{
  int s=0,w=1;
  char c=getchar();
  while(c<'0'||c>'9')c=getchar();
  while(c>='0'&&c<='9')
  {
    s=(s<<3)+(s<<1)+c-'0';
    c=getchar();
  }
  x=s*w;
}
int seed=2333;
inline int Random(){return seed=seed*seed+seed+1;}
struct node
{
  int val,size,key;
  node *son[2];
  node(int k);
  ~node();
  inline void push_up()
  {
    size=son[0]->size+son[1]->size+1;
  }
}*nil=new node(0),*Root,*stack[1024*1024+5];
node::node(int k)
{
  val=k,key=Random(),size=1,son[0]=son[1]=nil;
}
node::~node()
{
  if(son[0]!=nil)delete son[0];
  if(son[1]!=nil)delete son[1];
}
node *merge(node *a,node *b)
{
  if(a==nil)return b;
  if(b==nil)return a;
  if(a->key<b->key)
  {
    a->son[1]=merge(a->son[1],b);
    a->push_up();
    return a;
  }
  else
  {
    b->son[0]=merge(a,b->son[0]);
    b->push_up();
    return b;
  }
}
Pair<node*,node*>split(node *root,int k)
{
  if(root==nil)return Pair<node*,node*>(nil,nil);
  Pair<node*,node*>p;
  if(root->son[0]->size>=k)
  {
    p=split(root->son[0],k);
    root->son[0]=p.second;
    root->push_up();
    p.second=root;
    return p;
  }
  else
  {
    p=split(root->son[1],k-root->son[0]->size-1);
    root->son[1]=p.first;
    root->push_up();
    p.first=root;
    return p;
  }
}
node *build(int n)
{
  int top=0;
  for(int i=1;i<=n;i++)
  {
    char c=getchar();
    while(c<32||c>126||c=='\r'||c=='\n')c=getchar();
    node *temp=new node(int(c)),*last=nil;
    while(top&&temp->key<stack[top]->key)
    stack[top]->push_up(),last=stack[top],stack[top--]=nil;
    if(top)stack[top]->son[1]=temp;
    temp->son[0]=last,stack[++top]=temp;
  }
  while(top)stack[top--]->push_up();
  return stack[1];
}
void print(node *root)
{
  if(root==nil)return ;
  print(root->son[0]),putchar(char(root->val)),print(root->son[1]);
}
int pos,t,sum;
char opt[10];
int main()
{
  nil->size=0,Root=nil;
  read(t);
  while(t--)
  {
    scanf("%s",opt);
    if(opt[0]=='M')read(sum),pos=sum;
    else if(opt[0]=='I')
    {
      read(sum);
      Pair<node*,node*>a=split(Root,pos);
      Root=merge(merge(a.first,build(sum)),a.second);
    }
    else if(opt[0]=='D')
    {
      read(sum);
      Pair<node*,node*>a=split(Root,pos),b=split(a.second,sum);
      Root=merge(a.first,b.second);
      delete b.first;
    }
    else if(opt[0]=='G')
    {
      read(sum);
      Pair<node*,node*>a=split(Root,pos),b=split(a.second,sum);
      print(b.first),putchar(10);
      Root=merge(a.first,merge(b.first,b.second));
    }
    else if(opt[0]=='P')pos--;
    else pos++;
  }
}

```
可能是我寫醜了  
完結  
注：本文章作者是個地地道道的大陸人，漢字使用姿勢不對請對此有研究的同胞指正

---

## 作者：AThousandSuns (赞：9)

## splay裸题。
看到区间插入删除，想到splay。

但是在说splay之前先说几个别的坑点。

（另外我的splay是跟[rtldalao](https://www.luogu.org/blog/user19027/solution-p3369)学的，代码可能有点异样但大家应该看得懂的）

---
### 1.insert的输入
我的输入方法是这样的：一开始输入了一个长度，接下来一直读入字符，如果是合法字符就接到临时字符串末尾，如果输入的合法字符已经够了，那么直接退出。

至于毒瘤的空格和换行符的问题，不用管，题面里说了，合法 $\text{ASCII}$ 值在 $[32,126]$。只要判断 $\text{ASCII}$ 即可。
```cpp
strcpy(ins,"");
flag=false;	//初始化
scanf("%d",&x);	//长度
for(int i=0;i<x;i++){
	char ch=getchar();	//一直读入
	if(ch>=32 && ch<=126) flag=true;	//如果读到合法字符，那后面的空格都是合法的，否则可能是非法的（flag）
	if(!flag || ch<32 || ch>126){	//如果不合法
		i--;continue;	//读到的字符数--
	}
    ins[i]=ch;	//放到末尾
}
```
### 2.光标的设置
光标可以强行 $O(1)$ 模拟，也不会对splay的后续操作发生影响。至于从0还是从1开始我们待会会讲。
### 3.内存的设置
由于总共只会插入2097152个字符，所以splay的节点个数和临时字符串大小只需要开这么大。（或许是数据水吧，我开2000200就过了）

接下来开始重头戏。

---
### 1.insert操作
假设光标在 $x$ 处，字符串长度为 $len$。

那么仿照模板（其实大多数题目都是这样），将排名为 $x-1$ 的点splay到根，$x$ 的点splay到根的右儿子，然后在根的右儿子的左儿子build一颗完美的splay。可以再把这个子树splay到根上以确定随机性，但是顶多也就多2的高度，所以可以不splay。

好的，假设 $x=0$ 怎么办？

一般来说解决方法都是头尾加哨兵元素，然后就可以避免查询排名为非正数的点了。在这里我们加入哨兵元素后，splay的应该是排名为 $x$ 和 $x+1$ 的点。光标位置一开始设成1而不是0。

（从前我试着偷懒，不splay上去就在下面操作，然后发现特别难实现，好不容易写出来的又wa了……大家千万不要这样，有区间操作最好就splay上去再弄）
```cpp
Splay():cnt(0),pos(1){	//初始化以及两个哨兵元素（'\n'）
    memset(e,0,sizeof(e));
    root=addnode('\n',0);
    e[root].son[1]=addnode('\n',root);
}
int build(char *str,int fa,int l,int r){	//完美splay
    int mid=l+r>>1;
    char ch=str[mid-1];
    int x=addnode(ch,fa);	//自己
    if(l<mid) e[x].son[0]=build(str,x,l,mid-1);
    if(mid<r) e[x].son[1]=build(str,x,mid+1,r);	//递归
    pushup(x);
    return x;
}
void insert(int len,char *str){
    int l=kth(pos),r=kth(pos+1);
    splay(l,0);
    splay(r,l);	//寻找节点然后splay
    e[e[root].son[1]].son[0]=build(str,e[root].son[1],1,len);	//建造完美splay
    pushup(e[root].son[1]);pushup(root);
}
```
### 2.move,prev,next操作
也就move注意一下，光标改成 $x+1$ 而不是 $x$。其他没什么好说的。
```cpp
inline void move(int x){pos=x+1;}
inline void prv(){pos--;}
inline void nxt(){pos++;}
```
### 3.delete操作
同样的道理，把 $x$ splay到根， $(x+len-1)+2=x+len+1$ splay到根的右儿子，把根的右儿子的左儿子直接断掉关系。
```cpp
void remove(int len){
    int l=kth(pos),r=kth(pos+len+1);
    splay(l,0);
    splay(r,l);	//寻找节点然后splay
    e[e[root].son[1]].son[0]=0;	//断掉关系
    pushup(e[root].son[1]);pushup(root);
}
```
### 4.get操作
把 $x$ splay到根， $(x+len-1)+2=x+len+1$ splay到根的右儿子，然后输出根的右儿子的左儿子的中序遍历。
```cpp
void output(int x){	//中序遍历
    if(e[x].son[0]) output(e[x].son[0]);	//左儿子
    if(e[x].val!='\n') putchar(e[x].val);	//自己
    if(e[x].son[1]) output(e[x].son[1]);	//右儿子
}
void get(int len){
    int l=kth(pos),r=kth(pos+len+1);
    splay(l,0);
    splay(r,l);	//寻找节点然后splay
    output(e[e[root].son[1]].son[0]);	//中序遍历输出
    putchar(10);
}
```
---
大致就这些啦，那么就上代码，刚刚没有详解过的地方都加了注释。开O2总用时756ms，空间42.08MB，不开O2总用时1164ms。虽说不是很优秀，~~但是看着题解没有这么详细的，于是就~~写一篇题解帮帮大家。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct Splay{
    #define root e[0].son[1]
    struct node{	//节点
        char val;
        int size,fa,son[2];
    }e[2100000];
    int cnt,pos;
    inline void pushup(int x){	//上传节点信息
        e[x].size=e[e[x].son[0]].size+e[e[x].son[1]].size+1;
    }
    inline int atson(int x){	//是左儿子还是右儿子
        return e[e[x].fa].son[1]==x;
    }
    inline void connect(int x,int fa,int type){	//建立关系（注：并不断开矛盾的关系）
        e[x].fa=fa;
        e[fa].son[type]=x;
    }
    inline int addnode(char val,int fa){	//添加节点
        e[++cnt].val=val;
        e[cnt].size=1;
        e[cnt].fa=fa;
        return cnt;
    }
    void rotate(int x){	//旋转
        int fa=e[x].fa,ffa=e[fa].fa;
        int type=atson(x),ttype=atson(fa);
        int B=e[x].son[type^1];
        connect(B,fa,type);connect(fa,x,type^1);connect(x,ffa,ttype);
        pushup(fa);pushup(x);
    }
    void splay(int at,int to){
        if(!to) root=at;
        while(e[at].fa!=to){
            int fa=e[at].fa;
            if(e[fa].fa!=to) rotate(atson(at)^atson(fa)?at:fa);
            rotate(at);
        }
    }
    Splay():cnt(0),pos(1){
        memset(e,0,sizeof(e));
        root=addnode('\n',0);
        e[root].son[1]=addnode('\n',root);
    }
    inline void move(int x){pos=x+1;}
    int build(char *str,int fa,int l,int r){
        int mid=l+r>>1;
        char ch=str[mid-1];
        int x=addnode(ch,fa);
        if(l<mid) e[x].son[0]=build(str,x,l,mid-1);
        if(mid<r) e[x].son[1]=build(str,x,mid+1,r);
        pushup(x);
        return x;
    }
    int kth(int x){
        int now=root;
        while(now){
            int sum=e[e[now].son[0]].size+1;
            if(x==sum) return now;
            if(x<sum) now=e[now].son[0];
            else{
                x-=sum;
                now=e[now].son[1];
            }
        }
    }
    void insert(int len,char *str){
        int l=kth(pos),r=kth(pos+1);
        splay(l,0);
        splay(r,l);
        e[e[root].son[1]].son[0]=build(str,e[root].son[1],1,len);
        pushup(e[root].son[1]);pushup(root);
    }
    void remove(int len){
        int l=kth(pos),r=kth(pos+len+1);
        splay(l,0);
        splay(r,l);
        e[e[root].son[1]].son[0]=0;
        pushup(e[root].son[1]);pushup(root);
    }
    void output(int x){
        if(e[x].son[0]) output(e[x].son[0]);
        if(e[x].val!='\n') putchar(e[x].val);
        if(e[x].son[1]) output(e[x].son[1]);
    }
    void get(int len){
        int l=kth(pos),r=kth(pos+len+1);
        splay(l,0);
        splay(r,l);
        output(e[e[root].son[1]].son[0]);
        putchar(10);
    }
    inline void prv(){pos--;}
    inline void nxt(){pos++;}
}sp;
int t;
char op[7],ins[2100000];
int main(){
    scanf("%d",&t);
    while(t--){
        strcpy(ins,"");
        int x;
        bool flag=false;
        scanf("%s",op);
        switch(op[0]){	//哪个操作
            case 'M':	//move
                scanf("%d",&x);sp.move(x);break;
            case 'I':	//insert
                scanf("%d",&x);
                for(int i=0;i<x;i++){
                    char ch=getchar();
                    if(ch>=32 && ch<=126) flag=true;
                    if(!flag || ch<32 || ch>126){
                        i--;continue;
                    }
                    ins[i]=ch;
                }
                sp.insert(x,ins);break;
            case 'D':	//delete
                scanf("%d",&x);sp.remove(x);break;
            case 'G':	//get
                scanf("%d",&x);sp.get(x);break;
            case 'P':	//prev
                sp.prv();break;
            case 'N':	//next
                sp.nxt();break;
        }
    }
}
```

---

## 作者：EndSaH (赞：8)

[日常推广博客](https://endsah.cf)

# 前言

本篇题解提供两种解法：**暴力**和**块状链表**。

重点不在这里，而在于：

**全部用 $\text{STL}$ 实现**。

另附上一个网站：[cppreference.com](https://zh.cppreference.com)，在对于语言和 $\text{STL}$ 的操作有疑问或者忘记了，可以去这里查。

众所周知，虽然 $\text{STL}$ 在不开 $O_2$ 的情况下效率欠佳，但是封装好的各类操作使得其**代码复杂度极低，易于调试**。

# 题解

## 暴力

首先，要对`std::vector`各项基本操作有所了解。

题目中所给的 6 个操作，都可以直观的用`std::vector`实现。

`std::vector`有两个成员函数：`erase`和`insert`。

[std::vector.insert()](https://zh.cppreference.com/w/cpp/container/vector/insert)

[std::vector.erase()](https://zh.cppreference.com/w/cpp/container/vector/erase)

看到里面的插入区间和区间删除没？

实际上，插入和删除的最坏复杂度是 $O(n)$ 的（一直在头部插删），这也就是说它暴力的原因。

具体细节（边界问题等），详见[暴力代码](https://www.luogu.org/paste/liu5d12e)。

## 块状链表

就是块内是数组，每个块之间用链表连接的数据结构。

链表插入 $O(1)$，访问 $O(n)$；数组插入 $O(n)$，访问 $O(1)$。

块状链表，正是一个中间产物，都是 $O(\sqrt n)$。

这里只是小小的介绍一下概念，具体的应该有 $\text{dalao}$ 的题解写得比我更好，不再献丑。

链表套数组？还要动态？

`std::list`套`std::vector`啊！

什么麻烦的回收内存，整段后移数组操作，有了封装好的函数，还怕什么？

在这里，~~鬼迷心窍的~~我~~莫名奇妙地~~选择了`std::forward_list`作为`std::list`的替代品，因为`std::forward_list`是单向链表而`std::list`是双向，也许会快一些emmm（也许....

（顺带警告：不是 $\text{C++11}$ 会 $\text{CE}$）

放上几个要用的`std::forward_list`的成员函数，自己去 cppreference 看去：

`insert_after(), erase_after(), before_begin()`

其他细节和边界处理其实也挺多的，具体看[块状链表代码](https://www.luogu.org/paste/ivmvw8f1)。

如果你不想用`std::forward_list`而想用`std::list`，这里有[另一份代码](https://www.luogu.org/paste/qfzhwyip)。

# 总结

关于 $\text{STL}$，一定要记住：

**左闭右开**！！！**左闭右开**！！！**左闭右开**！！！

其实你要是认真的写了代码并推了边界条件，你就会发现**左闭右开，下标从 $0$ 开始**是一个多么友好的东西。

我的代码里**根本就没有**什么`+1-1`，边界条件需要想想，但是实际上你可以按直觉一遍打过去，基本不会错。这也是 $\text{STL}$ 的优越之处。

顺便说一句，隔壁加强版（带翻转操作）[[AHOI2006]文本编辑器](https://www.luogu.org/problemnew/show/P4567)用`std::vector`实现的暴力是最优解2333333（翻转直接`std::reverse`）

大概就讲到这里吧- -

$\huge\text{Thanks for your consideration!}$

---

## 作者：sunrzily (赞：7)

看了题解区的众多大神都没有用黑科技，于是自己就来水一发 STL 的解法。


[~~\ STL 大法好/~~](https://www.luogu.com.cn/problem/P4008)

------------
![在这里插入图片描述](https://img-blog.csdnimg.cn/e6e0428301214b43ac067c70c9dd9f7b.png)

正规解法块状链表，这里采取的是黑科技解法。

rope 是扩展 STL 库中的一个数据结构——可持久化平衡树，相比较 set，它更适合区间插入和删除。这里用来解此题，就显得十分~~傻瓜~~容易了。

头文件： ```#include <ext/rope>```

命名空间： ```using namespace __gnu_cxx;```

基本操作：

```insert(pos, s)``` 将字符串 s 插入 pos 位置

```erase(pos, num)``` 从 pos 开始删除 num 个字符

```copy(pos, len, s)``` 从 pos 开始 len 个字符用 s 代替

```substr(pos, len)``` 提取 pos 开始的 len 个字符

```at(x)``` 访问第 x 个元素

几乎跟题目一模一样！

更开心的是， rope 在 NOI 中是允许使用的（ hooray ）！

于是代码就十分简单了：

```cpp
#include <bits/stdc++.h>
#include <ext/rope>

using namespace __gnu_cxx;
using namespace std;

rope <char> editor;

char ch;
string oper;
int pos, n, rela;

int main()
{
	cin.tie(0);
	cout.tie(0);
	
	scanf("%d", &n);
	
	while(n--)
	{
	    cin >> oper;
	    scanf("%d", &rela);
	    
		if(oper =="Insert"){
		    int pos1 = pos;
			while(rela)
			{
				ch = getchar();
				if((int)ch >= 32 && (int)ch <= 126){
				    editor.insert(pos1, ch);
				    rela--;
				    pos1++;
				}
			}
        }
        
        else if(oper =="Move"){
        	pos = rela;
        }
        
        else if(oper =="Next"){
            pos++;
        }
        
        else if(oper =="Prev"){
        	pos--;
        }
        
        else if(oper =="Get"){
        	cout << editor.substr(pos, rela) << endl;
        }
        
        else if(oper =="Delete"){
        	editor.erase(pos, rela);
        }
	}
	return 0;
}
```
rope 的可持久化

一般，我们可以利用 rope 底层可持久化的机制，进行 $O(1)$ 回退。也就是我们只需要回退根节点的版本，我们就可以很顺利地访问当时的所有节点了。故回退复杂度为 $O(1)$。

可持久化 rope 的初始化：

```cpp
rope<char>*ver[100];
ver[0]=new rope<char>();
```

可持久化 rope 建立新版本和回退旧版本：
```cpp
ver[i]=new rope<char>(*ver[i-1]); //从版本 i-1 建立新版本 i
ver[i]=ver[i-1] //版本 i 回退为版本 i-1
```
双倍经验  [P4567 【AHOI2006】 文本编辑器](https://www.luogu.com.cn/problem/P4567)。

此题是上题的升级版，因为要实现 rotate 操作，所以存储两个 rope，一正一反。

代码基本相同，略。

---

## 作者：shijunfeng00 (赞：6)

这里同样也是非旋Treap的做法  
只不过使用了数组而非指针  
~~指针虽然跑得快.但是容易写挂~~  
非旋Treap真的很好写,思维量和代码量都不算大  
我第一次用Insert暴力插入字符串.成功的T掉了两个点  
然后我的第二的想法就是把要插入的字符串先生成一棵树,但仍然是Insert暴力  
然后在合并..所以还是T掉了,复杂度不正确,卡常数作用有限  
正确的方法应该是O(N)中序建树,O(logN)插入  
建树方法类似于笛卡尔建树.直接就是一颗满足条件的Treap  
然后就是一些细节问题,比如输入字符串忽略换行,这里我卡了那么一下  
最后还是用getchar来扫描,,直到输入了符合条件的字符串退出  
操作都比较常规,和正常的非旋Treap除了多了个Build外没什么区别  
只要把Merge和Split写正确,其他操作是~~无脑split和merge就行~~很容易想出来的

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#define MAXN 1200*1200*3
using namespace std;
struct node{int val,key,size,l,r;}t[MAXN];
int root,tot,n,cursor,N,stk[MAXN];
char s[MAXN];
inline void update(int now){t[now].size=t[t[now].l].size+t[t[now].r].size+1;}
inline int NEW(int val){t[++tot]=(node){val,rand(),1,0,0};return tot;}
inline void getstring_immutable(char*s,int maxlen) 
{
	char ch=getchar();
	int len=0;
	while(len<maxlen)
	{
		if(ch>=32&&ch<=128)s[len++]=ch;
		ch=getchar();
	}
}
inline void split(int now,int&x,int&y,int rank)          
{
	if(!now){x=y=0;return;}
	if(t[t[now].l].size>=rank)y=now,split(t[now].l,x,t[y].l,rank);
	else x=now,split(t[now].r,t[x].r,y,rank-t[t[now].l].size-1);
	update(now);
}
inline void merge(int&now,int x,int y)
{
	if(!x||!y){now=x+y;return;}
	if(t[x].key<t[y].key)now=x,merge(t[now].r,t[x].r,y);
	else now=y,merge(t[now].l,x,t[y].l);
	update(now);
}
inline int build(char *a,int k)
{
    int tp=0;
    for(int i=0;i<k;i++) 
	{
        NEW(a[i]);int lst=0;
        while(tp&&t[stk[tp]].key>t[tot].key)update(stk[tp]),lst=stk[tp--];
        if(tp)t[stk[tp]].r=tot;
        t[tot].l=lst;
        stk[++tp]=tot;
    }
    while(tp)update(stk[tp--]);
    return stk[1]; 
}
inline void Delete(int l_pos,int r_pos)
{
	r_pos+=l_pos;
	int x=0,y=0,z=0;              
	split(root,x,y,r_pos);
	split(x,x,z,l_pos);
	merge(root,x,y);
}
inline void print_tree(int now)
{
	if(t[now].l)print_tree(t[now].l);
	printf("%c",t[now].val);
	if(t[now].r)print_tree(t[now].r);
}
void print(int l_pos,int r_pos)
{
	r_pos+=l_pos;
	int x=0,y=0,z=0;              
	split(root,x,y,r_pos);
	split(x,x,z,l_pos);
	print_tree(z);
	merge(x,x,z);
	merge(root,x,y);
}
void magic()
{ 
	string Input; //刚开始我用了char Input[]...
	cin>>Input;
	if(Input=="Move")cin>>cursor;
	if(Input=="Insert")
	{
		int len;
		cin>>len;
		getstring_immutable(s,len);
		int x=0,y=0,z=build(s,len);
		split(root,x,y,cursor);
		merge(x,x,z);
		merge(root,x,y);
	}
	if(Input=="Delete")
	{
		int lenth;cin>>lenth;
		Delete(cursor,lenth);
	}
	if(Input=="Get")
	{
		int num;cin>>num;
		print(cursor,num);
		putchar('\n');
	}
	if(Input=="Prev")
	{
		cursor--;
		if(cursor<0)cursor=0;
	}
	if(Input=="Next")
	{
		cursor++;
		if(cursor>t[root].size)cursor=t[root].size;
	}
}
int main()
{
	NEW(2147483647);
	t[root].size=0;
	cin>>N;
	for(int i=1;i<=N;i++)magic();
}
```

---

## 作者：Orion545 (赞：3)

splay是好文明【雾


如果你还没有接触过splay，或者对splay的区间操作不熟悉的，[安利一波自己的blog](http://www.cnblogs.com/dedicatus545/p/8227459.html)


### 【广告】本题题解：[Dedicatus545](http://www.cnblogs.com/dedicatus545/p/8377866.html)


言归正传，这道题在看明白题意以后就是裸的，因此这里不讲具体的做法了（可以在注释里看）


这篇题解主要讲几个需要注意的点


### 字符读入的问题

这是一个大坑点。


本题的数据，经过本蒟蒻24h含泪调试，确定为是在Windows下生成，Linux下评测的


这就意味着换行，由\r\n完成，而不是\n


如果你是用getchar读入数据的，那么你要注意了，不仅是ASCII码值为10的\n需要忽略，值为13的\r也要忽略


（其实\r这东西到底干嘛用的？？）


### 数据范围的坑点

这题一个明显的特征就是数据范围的描述暧昧不清


一看就是陈年老题23333


需要注意：虽然输出可能不多，但是一次性插入的字符数量可以高达2000000个


没错，6个0


因此一定要开够临时数组和splay数组的大小......


### 一个小技巧

插入一个串的时候，先递归把这个串构建成一棵平衡树，再“接”到splay好的根节点的右儿子的左儿子那里


效率++


Code:
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
int n,cnt=0,root=0,mouse=0;//mouse就是当前光标的位置
int fa[3000010]={0},ch[3000010][2]={0},siz[3000010]={0};
char w[3000010]={0};
//被数据范围吓怕了，开了1.5倍......
void update(int x){siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+1;}
int get(int x){return ch[fa[x]][1]==x;}
void rotate(int x){
    int f=fa[x],ff=fa[f],son=get(x);
    ch[f][son]=ch[x][son^1];
    if(ch[f][son]) fa[ch[f][son]]=f;
    fa[f]=x;ch[x][son^1]=f;
    fa[x]=ff;
    if(ff) ch[ff][ch[ff][1]==f]=x;
    update(f);update(x);
}
void splay(int x,int to){
//    cout<<"splay "<<x<<ends<<" "<<endl;
    if(x==to||fa[x]==to) return;
    if(to==0) root=x;
    for(int f;(f=fa[x])&&(f!=to);rotate(x)){
        if(fa[f]!=to)
            rotate(get(x)==get(f)?f:x);
    }
    update(x);
}
int rank(int x,int pos){//求排名为x的点
//    cout<<"rank "<<x<<ends<<siz[pos]<<ends<<siz[ch[pos][0]]<<ends<<pos<<endl;
//    if(pos==0) system("pause");
    if(siz[ch[pos][0]]+1==x){
        splay(pos,0);return pos;
    }
    if(siz[ch[pos][0]]>=x) return rank(x,ch[pos][0]);
    else return rank(x-siz[ch[pos][0]]-1,ch[pos][1]);
}
char s[2000010]={0};
int build(int l,int r,int f){//把一个给定区间建成平衡树
    if(l>r) return 0;
//    cout<<"build "<<l<<ends<<r<<ends<<f<<endl; 
    int mid=(l+r)>>1,cur=++cnt;
    fa[cur]=f;w[cur]=s[mid];
    ch[cur][0]=build(l,mid-1,cur);
    ch[cur][1]=build(mid+1,r,cur);
    update(cur);return cur;
}
void insert(int l,int len){//插入一段区间
    int x=rank(l,root),y=rank(l+1,root);
    splay(x,0);splay(y,root);
    ch[y][0]=build(1,len,y);
    update(y);update(x);
}
void del(int l,int r){//删除区间
    int x=rank(l,root),y=rank(r+2,root);
    splay(x,0);splay(y,root);
    ch[y][0]=0;update(y);update(x);
}
void dfs(int x){//中序遍历
    if(!x) return;
    dfs(ch[x][0]);
    printf("%c",w[x]);
    dfs(ch[x][1]);
}
void print(int l,int len){//输出
    int x=rank(l,root),y=rank(l+len+1,root);
    splay(x,0);splay(y,root);
    dfs(ch[y][0]);puts("");
}
int main(){
    int i,j,t1;char op[10];char c;
    n=read();
    root=++cnt;w[cnt]=0;siz[cnt]=2;
    ch[cnt][1]=cnt+1;cnt++;fa[cnt]=cnt-1;w[cnt]=0;siz[cnt]=1;
    mouse=1;
    //本题中需要在序列两边插入两个“哨兵”，防止splay越界，故mouse也是考虑了哨兵以后的值（从一开始）
    for(i=1;i<=n;i++){
        scanf("%s",op);
        if(op[0]=='I'){
            t1=read();
            for(j=1;j<=t1;j++){
                c=getchar();
                while(c=='\n'||c=='\r') c=getchar();//超级大坑
                s[j]=c;
            }
            insert(mouse,t1);
        }
        if(op[0]=='D'){
            t1=read();
            del(mouse,mouse+t1-1);
        }
        if(op[0]=='G'){
            t1=read();
            print(mouse,t1);
        }
        if(op[0]=='M'){
            t1=read();
            mouse=t1+1;
        }
        if(op[0]=='N') mouse++;
        if(op[0]=='P') mouse--;
    }
}
```

---

## 作者：attack (赞：2)

作为题目提供者，先来水一发题解

本题可以说是平衡树的裸题，随便打打标记就能过了

不过在此提供一种块状链表的做法

块状链表，就是数组和链表的结合体

他的思想是对于每一个链表中的节点，都保存一个数组

剩下的就是暴力咯

时间复杂度:$\sqrt{n}$

        
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
const int MAXN=2000000+10;
const int BlockSize=3000 + 100,BlockNum=3000 + 10;
int Cur=0,head,tot;
char str[MAXN];
struct Block
{
    int size,nxt;
    bool rev;
    char a[BlockSize];
    void Clear()
    {
        size=0;nxt=-1,rev=0;
    }
}B[BlockNum];
queue<int>q;//鐢ㄤ竴涓?槦鍒楁潵缁存姢褰撳墠鏈夊摢浜涘潡
int NewNode()
{
    int t=q.front();q.pop();
    B[t].Clear();
    return t;
}
inline void Pre()
{
    while(q.size()!=0)    q.pop();
    for(int i=0;i<BlockNum;i++) q.push(i);
    head = NewNode();
}
void Find(int &idx,int &cur)
{
    while(idx!=-1&&cur>B[idx].size) cur-=B[idx].size,idx=B[idx].nxt;
}
void Pushdown(int idx)
{
    if(B[idx].rev) 
    {
    //    for(int i=0;i<B[idx].size;i++)
    //        cout<<B[idx].a[i];cout<<endl;
        reverse(B[idx].a,B[idx].a+B[idx].size);
    //    for(int i=0;i<B[idx].size;i++)
    //        cout<<B[idx].a[i];cout<<endl;
        B[idx].rev=0;
    }
}
inline void Split(int idx,int cur)
{
    if(idx==-1||cur==B[idx].size)    return ;
    Pushdown(idx);
    int tot=NewNode();
    memcpy(B[tot].a,B[idx].a+cur,sizeof(char) * (B[idx].size-cur) );
    B[tot].size=B[idx].size-cur;
    B[idx].size=cur;
    B[tot].nxt=B[idx].nxt;
    B[idx].nxt=tot;
}
void Delet(int idx)
{
    q.push(idx);
}
void Merge(int idx)
{
    for(int i=idx;i!=-1;i=B[i].nxt)
        for(int j=B[i].nxt;j!=-1;j=B[j].nxt)
        {
            if(B[i].size+B[j].size<=BlockSize)
            {
                Pushdown(i);
                Pushdown(j);
                memcpy(B[i].a+B[i].size,B[j].a,sizeof(char) * B[j].size);
                B[i].size+=B[j].size;B[i].nxt=B[j].nxt;
                Delet(j);
            }
            else break;
        }
}
inline void Insert(int cur,int x,char *str)
{
    int idx=head;
    Find(idx,cur);
    Split(idx,cur);
    int i=0;//宸茬粡鍔犲叆鐨勪釜鏁?
    while(i<x)
    {
        int Limit=min(BlockSize,x-i);
        int tot=NewNode();
        memcpy(B[tot].a,str+i,sizeof(char) * Limit);
        B[tot].size=Limit;
        B[tot].nxt=B[idx].nxt;
        B[idx].nxt=tot;
        idx=B[idx].nxt;
        i+=Limit;
    }
    Merge(head);
}
void Print(int k, int n, char *str)
{
    int idx = head;
    Find(idx, k);
    int len = 0;
    for(int i = idx; i != -1 && n > 0; i = B[i].nxt)
    {
        Pushdown(i);
        int Limit = min(n, B[i].size - k);
        memcpy(str + len, B[i].a + k, sizeof(char) * Limit);
        len += Limit, n -= Limit;
        k = 0;
    }
    str[len] = '\0';
    puts(str);
}
void Rever(int l,int r)
{
    int idx=head;
    Find(idx,l);
    Split(idx,l);
    int Start=idx,StartNxt=B[idx].nxt;
    idx=head;
    Find(idx,r);
    Split(idx,r);
    int EndNxt=B[idx].nxt;
    int Tmp[BlockNum],cnt=0;
    for(int i=StartNxt;i!=EndNxt;i=B[i].nxt)
        B[i].rev^=1,Tmp[++cnt]=i;
    Tmp[++cnt]=Start;Tmp[0]=EndNxt;
    for(int i=cnt;i>=1;i--)
        B[Tmp[i]].nxt=Tmp[i-1];
    Merge(head);
}
void Dele(int l,int r)
{
    int idx=head;
    Find(idx,l);
    Split(idx,l);
    int Start=idx,StartNxt=B[idx].nxt;
    idx=head;
    Find(idx,r);
    Split(idx,r);
    int EndNxt=B[idx].nxt;
    for(int i=StartNxt;i!=EndNxt;i=B[i].nxt)    Delet(i);
    B[Start].nxt=EndNxt;
    Merge(head);
}
int main()  
{
    #ifdef WIN32
    freopen("a.in","r",stdin);
    #else
    #endif
    int N;scanf("%d",&N);
    char opt[20];
    Pre();
    while(N--)
    {
        scanf("%s",opt);
        if(opt[0]=='M') 
            scanf("%d",&Cur);
        else if(opt[0]=='I')
        {
            int len;
            scanf("%d", &len);
            int i = 0;
            while(i < len) {char ch = getchar();if(ch >= 32 && ch <= 126) str[i++] = ch;}
            str[i++]='\0';
            Insert(Cur,len,str);
        }
        else if(opt[0]=='D')
        {
            int x;
            scanf("%d",&x);
            Dele(Cur,Cur+x);
        }
        else if(opt[0]=='R')
        {
            int x;
            scanf("%d",&x);
            Rever(Cur,x+Cur);
        }
        else if(opt[0]=='G')    
        {
            int x;
            scanf("%d",&x);
            Print(Cur,x,str);
        }
        else if(opt[0]=='P')    Cur--;
        else if(opt[0]=='N')    Cur++;
    }
    return 0;
}
```

---

## 作者：iodwad (赞：1)

[Welcome to my Blog](https://zcdhj.org)

Splay 维护序列。

对于每种操作，将对应的区间提取出来，然后操作即可。

要注意数据是在 Windows 下生成的，所以在读字符串的时候除了 `\n` 还要判断`\r`。

希望这里的代码能对指针党有帮助 qwq

```cpp
#include <iostream>
#include <iostream>
#include <cstdio>

const int MAXN = 2100000;

int n, nowCursor, Len;
char Str[MAXN | 1];

namespace Splay {
    struct Tree {
        struct Splay {
            char val;
            int size;
            Splay *ch[2], *father;
            Splay() {}
            Splay(char _val, Splay *_father) : val(_val), size(1), father(_father) { ch[0] = ch[1] = NULL; }
        } *root;
        inline int size(Splay *o) { return o ? o -> size : 0; }
        inline void pushup(Splay *o) { o -> size = 1 + size(o -> ch[0]) + size(o -> ch[1]); }
        inline int relation(Splay *o) { return o -> father ? o -> father -> ch[1] == o : 0; }
        inline void connect(Splay *x, Splay *y, int relation) {
            if(x) x -> father = y;
            if(y) y -> ch[relation] = x;
        }
        inline void rotate(Splay *o) {
            Splay *p = o -> father, *q = p -> father;
            int wson = relation(o);
            connect(o, q, relation(p));
            connect(o -> ch[wson ^ 1], p, wson);
            connect(p, o, wson ^ 1);
            pushup(p);
            pushup(o);
        }
        inline void splay(Splay *o, Splay *goal) {
            if(!o) return;
            while(o -> father != goal) {
                Splay *p = o -> father;
                if(p -> father != goal) relation(o) ^ relation(p) ? rotate(o) : rotate(p);
                rotate(o);
            }
            if(!goal) root = o;
        }
        inline Splay *kth(int k) {
            Splay *o = root;
            while(1) {
                if(size(o -> ch[0]) + 1 == k) return o;
                else if(size(o -> ch[0]) >= k) o = o -> ch[0];
                else {
                    k -= size(o -> ch[0]) + 1;
                    o = o -> ch[1];
                }
            }
            return NULL;
        }
        inline void build(Splay *&o, Splay *fa = NULL, int l = 1, int r = Len) {
            if(l > r) return;
            int mid = (l + r) >> 1;
            o = new Splay(Str[mid], fa);
            build(o -> ch[0], o, l, mid - 1);
            build(o -> ch[1], o, mid + 1, r);
            pushup(o);
        }
        inline void out(Splay *o) {
            if(!o) return;
            out(o -> ch[0]);
            if(o -> val != '\n') putchar(o -> val);
            out(o -> ch[1]);
        }
        inline void remove(Splay *&o) {
            if(!o) return;
            remove(o -> ch[0]);
            remove(o -> ch[1]);
            delete o;
            o = NULL;
        }
        inline void Insert() {
            scanf("%d", &Len);
            for(int i = 1; i <= Len; ++i) {
                char ch = getchar();
                while(ch == '\n' || ch == '\r') ch = getchar();
                Str[i] = ch;
            }
            Splay *o1 = kth(nowCursor), *o2 = kth(nowCursor + 1);
            splay(o1, NULL);
            splay(o2, o1);
            Splay *ptr;
            build(ptr);
            connect(ptr, root -> ch[1], 0);
            pushup(root -> ch[1]);
            pushup(root);
        }
        inline void Delete() {
            scanf("%d", &Len);
            Splay *o1 = kth(nowCursor), *o2 = kth(nowCursor + Len + 1);
            splay(o1, NULL);
            splay(o2, o1);
            remove(root -> ch[1] -> ch[0]);
            pushup(root -> ch[1]);
            pushup(root);
        }
        inline void Get() {
            scanf("%d", &Len);
            Splay *o1 = kth(nowCursor), *o2 = kth(nowCursor + Len + 1);
            splay(o1, NULL);
            splay(o2, o1);
            out(root -> ch[1] -> ch[0]);
            printf("\n");
        }
    } tree;
}

using namespace Splay;

int main() {
    int t;
    scanf("%d", &t);
    Str[1] = Str[2] = '\n';
    tree.build(tree.root, NULL, 1, 2);
    nowCursor = 1;
    while(t--) {
        char opt[10];
        scanf("%s", opt);
        if(*opt == 'M') scanf("%d", &nowCursor), ++nowCursor;
        else if(*opt == 'I') tree.Insert();
        else if(*opt == 'D') tree.Delete();
        else if(*opt == 'G') tree.Get();
        else if(*opt == 'P') --nowCursor;
        else ++nowCursor;
    }
    return 0;
}
```

---

## 作者：zhengrunzhe (赞：1)

提供指针Splay

用Splay维护序列 支持区间操作的文艺平衡树

分析一下几个操作

记录光标位置:cursor

1.Move(pos)把光标移动到第pos个字符后：cursor=pos

2.Insert(len,str) 在光标后添加一串长为len的字符串str

利用build函数 将串str建成一棵Splay

找到光标cursor所指的字符 splay至根

找到cursor+1所指的字符 splay至cursor的右儿子处

此时cursor+1的左儿子指向新Splay的根

注意添加边界节点

3.Delete(tot)在光标后删除tot个字符

利用split函数 用与Insert类似的处理

找到要处理的区间[cursor+1,cursor+tot]

4.Get(tot)输出光标后tot个字符

同理找到要查看的区间

写个中序遍历函数遍历一遍即可

5.Prev() 光标左移：cursor--

5.Next() 光标右移：cursor++
```cpp
#include<queue>
#include<cstdio>
using namespace std;
namespace Splay
{
	struct tree
	{
		int size;
		char value;
		tree *son[2],*fa;
		inline tree(char ch)
		{
			size=1;
			value=ch;
			fa=son[0]=son[1]=NULL;
		}
		inline void pushup()
		{
			size=1;
			if (son[0])size+=son[0]->size;
			if (son[1])size+=son[1]->size;
		}
	}*root;
	inline bool relation(tree *p)
	{
		if (p&&p->fa)return p->fa->son[1]==p;
	}
	inline void connect(tree *&p,tree *&fa,bool which)
	{
		if (p)p->fa=fa;
		if (fa)fa->son[which]=p;
	}
	inline void rotate(tree *&p)
	{
		tree *fa=p->fa;
		bool lr=relation(p);
		connect(p,fa->fa,relation(fa));
		connect(p->son[lr^1],fa,lr);
		connect(fa,p,lr^1);
		fa->pushup();p->pushup();
	}
	inline void splay(tree *&p,tree *goal)
	{
		for (tree *fa;(fa=p->fa)!=goal;rotate(p))
			if (fa->fa!=goal)
				rotate(relation(fa)==relation(p)?fa:p);
		if (goal==NULL)root=p;
	}
	tree *build(tree *fa,char *data,int l,int r) //建立一棵表示串data的Splay
	{
		int mid=(l+r)>>1;
		tree *p=new tree(data[mid]);
		p->fa=fa;
		if (l<mid)p->son[0]=build(p,data,l,mid-1);
		if (r>mid)p->son[1]=build(p,data,mid+1,r);
		p->pushup();
		return p;
	}
	inline tree *find_rank(int ranking) //找到排名为ranking的字符
	{
		ranking++; //因为加了边界
		tree *p=root;
		while (1)
			if (p->son[0]&&ranking<=p->son[0]->size)
				p=p->son[0];
			else
			{
				ranking-=(p->son[0]?p->son[0]->size:0)+1;
				if (!ranking)return p;
				p=p->son[1];
			}
	}
	inline tree *split(int l,int r) //找出要处理的区间[l,r]
	{
		tree *pre=find_rank(l-1),*nxt=find_rank(r+1);
		splay(pre,NULL);splay(nxt,pre);
		return nxt->son[0];
	}
	void check(tree *p)  //中序遍历
	{
		if (p->son[0])check(p->son[0]);
		printf("%c",p->value);
		if (p->son[1])check(p->son[1]);
	}
}using namespace Splay;
int cursor,n; //cursor:光标
inline void Move(int pos)
{
	cursor=pos;
}
inline void Insert(int pos,int tot,char *insertion)
{
	tree *x=find_rank(pos),*y=find_rank(pos+1);
	splay(x,NULL);splay(y,x);
	tree *inserted_root=build(NULL,insertion,1,tot); //以待插入字符串建立新Splay，根为inserted_root
	connect(inserted_root,root->son[1],0); //连接上去
	root->son[1]->pushup();root->pushup();
}
inline void Delete(int pos,int tot)
{
	tree *p=split(pos+1,pos+tot);
	root->son[1]->son[0]=NULL;
	queue<tree*>del;del.push(p); //防止指针MLE 把区间内所有的指针都给delete掉
	while (del.size())
	{
		tree *cut=del.front();del.pop();
		if (cut->son[0])del.push(cut->son[0]);
		if (cut->son[1])del.push(cut->son[1]);
		delete cut;
	}
	root->son[1]->pushup();
	root->pushup();
}
inline void Get(int pos,int tot)
{
	tree *p=split(pos+1,pos+tot);
	check(p);
	puts("");
}
inline void Prev()
{
	cursor--;
}
inline void Next()
{
	cursor++;
}
int main()
{
	char SET[2];SET[0]=31;SET[1]=127;
	root=build(NULL,SET,0,1); //添加边界
	scanf("%d",&n);
	while (n--)
	{
		char opt[6];scanf("%s",opt);
		switch(opt[0])
		{
			case 'M':
			{
				int pos;
				scanf("%d",&pos);
				Move(pos);
				break;
			}
			case 'I':
			{
				int tot;scanf("%d",&tot);
				char insertion[tot+1];
				for (int i=1;i<=tot;i++)
				{
					char ch=getchar();
					while (ch=='\n'||ch=='\r')ch=getchar();
					insertion[i]=ch;
				}
				Insert(cursor,tot,insertion);
				break;
			}
			case 'D':
			{
				int tot;
				scanf("%d",&tot);
				Delete(cursor,tot);
				break;
			}
			case 'G':
			{
				int tot;
				scanf("%d",&tot);
				Get(cursor,tot);
				break;
			}
			case 'P':Prev();break;
			case 'N':Next();break;
		}
	}
	return 0;
}
```

---

## 作者：localhost (赞：1)

这题比[P4567 [AHOI2006]文本编辑器](https://www.luogu.org/problemnew/show/P4567)少了一个反转，不过输入格式正常了一些。

既然没人给fhq的题解我就来写一篇吧。

经典的fhq区间操作，感觉常数很大QwQ。

除掉一坨快读，我的码风应该还算可以的QwQ

欢迎来我的博客学fhq treap

[fhq treap教程](https://3088482189.github.io/2018/12/29/1/)
```cpp
#include<bits/stdc++.h>
namespace ZDY{
    #pragma GCC optimize(3)
    #define il __inline__ __attribute__ ((always_inline))
    #define rg register
    #define ll long long
    #define db double
    #define sht short
    #define MB template <class T>
    #define Fur(i,x,y) for(int i=x;i<=y;i++)
    #define Fdr(i,x,y) for(int i=x;i>=y;i--)
    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)
    #define clr(x,y) memset(x,y,sizeof(x))
    #define cpy(x,y) memcpy(x,y,sizeof(x))
    #define fin(s) freopen(s".in","r",stdin)
    #define fout(s) freopen(s".out","w",stdout)
    #define fcin ios::sync_with_stdio(false)
    #define l2(n) (int(log2(n)))
    #define inf 0x3f3f3f3f
    MB T ABS(T x){return x>0?x:-x;}
    MB T MAX(T x,T y){return x>y?x:y;}
    MB T MIN(T x,T y){return x<y?x:y;}
    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}
    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}
}using namespace ZDY;using namespace std;
namespace IO{const char* ln="\n";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;
#define N 2100000
int n,m;
#define ls c[rt][0]
#define rs c[rt][1]
int sz[N],rnd[N],rev[N],c[N][2],RT,cnt,POS=0;
char val[N];
int ra(){static int seed=233;return seed=(int)seed*482711LL%2147483647;}
il void pu(int rt){sz[rt]=sz[ls]+sz[rs]+1;}
il void pd(int rt){
    if(rev[rt]){
        SWAP(ls,rs);
        rev[ls]^=1;rev[rs]^=1;
        rev[rt]=0;
    }
}
int ne(char v){
    val[++cnt]=v;
    sz[cnt]=1;rnd[cnt]=ra();
    return cnt;
}
void sl(int rt,int k,int &x,int &y){
    if(!rt){x=y=0;return;}
    pd(rt);
    if(sz[ls]>=k)y=rt,sl(ls,k,x,ls);
    else x=rt,sl(rs,k-sz[ls]-1,rs,y);
    pu(rt);
}
int mg(int x,int y){
    if(!x||!y)return x+y;
    pd(x);pd(y);
    if(rnd[x]<rnd[y]){
        c[x][1]=mg(c[x][1],y);
        pu(x);
        return x;
    }
    else{
        c[y][0]=mg(x,c[y][0]);
        pu(y);
        return y;
    }
}
void dfs(int rt){
    if(!rt)return;
    pd(rt);
    dfs(ls);out.pt(val[rt]);dfs(rs);
}
int main(){
    in>>n;
    char opt[10];
    int len,x,y,z;
    while(n--){
        in>>opt;
        if(opt[0]=='M')in>>POS;
        if(opt[0]=='I'){
            in>>len;
            sl(RT,POS,x,y);
            Fur(i,1,len){
                char ch=in.gc();
                while(ch<32||ch>126)ch=in.gc();
                x=mg(x,ne(ch));
            }
            RT=mg(x,y);
        }
        if(opt[0]=='R'){
            in>>len;
            sl(RT,POS+len,x,z);sl(x,POS,x,y);
            rev[y]^=1;
            RT=mg(x,mg(y,z));
        }
        if(opt[0]=='D'){
            in>>len;
            sl(RT,POS+len,x,z);sl(x,POS,x,y);
            RT=mg(x,z);
        }
        if(opt[0]=='G'){
            in>>len;
            sl(RT,POS+len,x,z);sl(x,POS,x,y);
            dfs(y);out<<ln;
            RT=mg(x,mg(y,z));
        }
        if(opt[0]=='P')POS--;
        if(opt[0]=='N')POS++;
    }
}

```


---

## 作者：libra9z (赞：1)

~~最近好久不发blog了，感觉有点颓废，一直在打[$Slay One$](https://slay.one)。。。~~

### [原题描述](https://www.luogu.org/problemnew/show/P4008)

#### 这题很容易地珂以想到直接模拟肯定过不去（毕竟是一个紫题么。。。）

### $\color{red}\text{于是，我们珂以用平衡树维护（}$~~滑稽，看神仙们的题解的~~$\color{red}\text{）}$

~~**神仙们都用$splay$，而我这只蒟蒻只会非旋$treap$。**~~

**考虑到非旋$treap$的普通$split$操作的依据是大小关系，而我们现在是要维护序列，在位置上操作，所以$split$操作的依据要改为位置**

##### （原先的$split$）：
```cpp
void split(treap_node *now, value_type k, 
/*value*/   treap_node *&a, treap_node *&b) {
  if (now == null) a = b = null;
  else { // it isn't a null node
    if (now -> val <= k) // in value
      a = now, split(a -> ch[1], k, a -> ch[1], b);
    else // split the right son of the left son of the node
      b = now, split(b -> ch[0], k, a, b -> ch[0]);
    // split the left son of the right son of the node
    now -> pushup(); // pushup the node
  } // split with value
} // fhq treap split value
```

##### （现在的$split$）：
```cpp
void split(treap_node *now, int k, 
/*location*/treap_node *&a, treap_node *&b) {
  if (now == null) a = b = null;
  else { // it isn't a null node
    if (now -> ch[0] -> size >= k) // in location
      b = now, split(b -> ch[0], k, a, b -> ch[0]);
    else // split the left son of the right son of the node
      a = now, split(a -> ch[1], k - now -> ch[0] -> size - 1, a -> ch[1], b);
    // split the right son of the left son of the node
    now -> pushup(); // pushup the node
  } // split with location
} // fhq treap split location
```

###### ~~别问我那里来的这么多注释，我只是敲习惯了而已！！~~

**接着，还要再考虑$Insert$时候如何作。**

#### **珂以用一个栈维护。如果当前插入的节点的修正值小于栈顶端的节点的修正值的话，就弹出栈顶端的节点，并且进行上推。**

**把当前节点插入进去之后，最后从栈的顶端到栈尾一直上推，最后的一个节点代表这个区间的子树，最后在插入到非旋$treap$内部。**

###### ~~至此，这道题大功告成！！~~

#### 最后放一下我的~~又丑又长~~的代码：

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define Maxn 3 << 20 | 5

#ifdef ONLINE_JUDGE
static char _in_buf[100000], *_in_p1 = _in_buf, *_in_p2 = _in_buf;
#define getchar() (_in_p1 == _in_p2 && (_in_p2 = (_in_p1 = _in_buf) + fread(_in_buf, 1, 100000, stdin), _in_p1 == _in_p2) ? EOF : *_in_p1 ++)
#endif
inline int read() {
  int now = 0, f = 0; register char c = getchar();
  while ((c < 48 || c > 57) && ~c && c != '-') c = getchar();
  if (!~c) throw ~0; (c == '-') && ((f = 1), c = getchar());
  for (; c > 47 && c < 58; now = (now << 3) + (now << 1) + c - '0', c = getchar());
  return f ? -now : now;
} // fast reader

typedef char value_type;
struct treap_node {
  treap_node *ch[2];
  int size, fix;
  value_type val;
  ~treap_node();
  treap_node(value_type v);
  inline void pushup() {
    size = ch[0] -> size + ch[1] -> size + 1;
  } // push from down to up
} *null = new treap_node(0), *root;
treap_node :: treap_node(value_type k = 0) {
  val = k, fix = rand();
  size = 1, ch[0] = ch[1] = null;
} // construct function
treap_node :: ~treap_node() {
  if (ch[0] != null) delete ch[0];
  if (ch[1] != null) delete ch[1];
  if (this != null) delete this;
} // explict function
struct __INIT_ROOT__ {
  __INIT_ROOT__() {
    srand(time(NULL));
    null -> size = 0, root = null;
  } // init the treap
} __init_root__;
treap_node *merge(treap_node *a, treap_node *b) {
  if (a == null) return b;
  if (b == null) return a;
  if (a -> fix < b -> fix) {
    a -> ch[1] = merge(a -> ch[1], b);
    a -> pushup(); return a;
  } else { // random merge
    b -> ch[0] = merge(a, b -> ch[0]);
    b -> pushup(); return b;
  } // merge with random value
} // fhq treap merge
void split(treap_node *now, int k, 
/*location*/treap_node *&a, treap_node *&b) {
  if (now == null) a = b = null;
  else { // it isn't a null node
    if (now -> ch[0] -> size >= k) // in location
      b = now, split(b -> ch[0], k, a, b -> ch[0]);
    else // split the left son of the right son of the node
      a = now, split(a -> ch[1], k - now -> ch[0] -> size - 1, a -> ch[1], b);
    // split the right son of the left son of the node
    now -> pushup(); // pushup the node
  } // split with location
} // fhq treap split location
void print_treap(treap_node *p) {
  if (p == null) return;
  print_treap(p -> ch[0]); // print left son
  putchar(p -> val); // print now value
  print_treap(p -> ch[1]); // print right son
} // print the sequence

treap_node *stk[Maxn]; // stack we used in insert
int top, pos = 0; // stack top and position
int main() {
  for (int q = read(), x; q --; ) {
    register char ch, op;
    while ((ch = getchar()) <= 32 || ch > 126);
    for (op = ch; (ch = getchar()) > 32 && ch < 127; );
    if (op == 'I') { // Insert operation
      for (x = read(), top = 0; x --; ) {
        while ((ch = getchar()) < 32 || ch > 126);
        treap_node *tmp = new treap_node(ch), *last = null;
        while (top && tmp -> fix < stk[top] -> fix) // find the node to have the greater fix value
          stk[top] -> pushup(), last = stk[top], stk[top --] = null;
        if (top) stk[top] -> ch[1] = tmp; // if it isn't empty
        tmp -> ch[0] = last, stk[++ top] = tmp; // prev link and next link
      } while (top) stk[top --] -> pushup(); // pushup operation
      treap_node *a, *b; split(root, pos, a, b); // split in pos-th
      root = merge(merge(a, stk[1]), b); // insert and merge
    } else if (op == 'M') pos = read();
    else if (op == 'P') -- pos;
    else if (op == 'N') ++ pos;
    else if (op == 'D') { // Delete operation
      treap_node *a, *b, *c;
      split(root, pos, a, b); // split the pos-th 
      split(b, read(), b, c); // split the next k-th
      root = merge(a, c); // delete and merge
    } else if (op == 'G') {
      treap_node *a, *b, *c;
      split(root, pos, a, b); // split in pos-th
      split(b, read(), b, c); // split in k-th
      print_treap(b), putchar('\n'); // print in recursion
      root = merge(merge(a, b), c); // merge originally
    } else throw "Bad operation!!"; // Debug
  }
  return 0;
}
```


**如果神仙们还觉得这题太水了，珂以去尝试[这题](https://www.luogu.org/problemnew/show/P4567)**

---

## 作者：羚羊WANG (赞：0)

用块状链表即可。
```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
//#define gc() getchar()
#define MAXIN 100000
#define gc() (SS==TT&&(TT=(SS=IN)+fread(IN,1,MAXIN,stdin),SS==TT)?EOF:*SS++)
const int N=1024*1024*2+5;
const int MaxSize=/*1700*/4500,MaxNum=/*1700*2*/N*2/MaxSize+100;

int num,nxt[MaxNum],sz[MaxNum],pool[MaxNum];
char data[MaxNum][MaxSize],str[N],IN[MAXIN],*SS=IN,*TT=IN;

inline int read() {
	int now=0,f=1;
	register char c=gc();
	for(; !isdigit(c); c=gc()) if(c=='-') f=-1;
	for(; isdigit(c); now=now*10+c-'0',c=gc());
	return now*f;
}

inline int New_Block() {
	return pool[++num];
}
inline void Del_Block(int v) {
	pool[num--]=v;
}
void Init() {
	for(int i=1; i<MaxNum; ++i) pool[i]=i;
	sz[0]=0, nxt[0]=-1;//新建一个0节点，方便 表头就是0
}
void Merge(int cur,int Nxt) {
	memcpy(data[cur]+sz[cur],data[Nxt],sz[Nxt]);
	nxt[cur]=nxt[Nxt], sz[cur]+=sz[Nxt];
	Del_Block(Nxt);
}
void Maintain() {
	for(int cur=0,Nxt=nxt[0]; ~cur; cur=nxt[cur],Nxt=nxt[cur])
		while((~Nxt) && sz[cur]+sz[Nxt]<=MaxSize)
			Merge(cur,Nxt), Nxt=nxt[cur];//最好不用nxt[Nxt]，因为已经合并、删掉了，虽然不影响答案，但还是不该写
}
int Get_Index(int &pos) { //找到pos所在的块，并将pos定位为块内位置
	int cur=0;
	while((~cur) && pos>sz[cur])//把cur定位到某一块的末尾，不用下一块开头了(pos>=sz)
		pos-=sz[cur], cur=nxt[cur];
	return cur;
}
void Update(int cur,int Nxt,int len,char *s) { //给新的块Nxt设置数据及指针
	nxt[Nxt]=nxt[cur], nxt[cur]=Nxt, sz[Nxt]=len;
	memcpy(data[Nxt],s,len);
}
void Split(int cur,int pos) {
	if(cur==-1||pos==sz[cur]) return;//不能判!pos！因为后边会直接用nxt[cur]，不分裂会跳过该块；而在=sz时不分是没问题的
	int Nxt=New_Block();
	Update(cur,Nxt,sz[cur]-pos,data[cur]+pos);
	sz[cur]=pos;
}
void Insert(int pos,int len) {
	int cur=Get_Index(pos),sum=0,Nxt;
	Split(cur,pos);
	while(sum+MaxSize<=len) {
		Nxt=New_Block();
		Update(cur,Nxt,MaxSize,str+sum);//先分成尽可能多的整块
		sum+=MaxSize, cur=Nxt;
	}
	if(len-sum)//剩余的单独放到一块
		Nxt=New_Block(), Update(cur,Nxt,len-sum,str+sum);
	Maintain();
}
void Erase(int pos,int len) {
	int cur=Get_Index(pos),Nxt;
	Split(cur,pos);
	Nxt=nxt[cur];//because of here
	while((~Nxt) && len>sz[Nxt])
		len-=sz[Nxt], Del_Block(Nxt), Nxt=nxt[Nxt];
	Split(Nxt,len);
	Del_Block(Nxt), nxt[cur]=nxt[Nxt];
	Maintain();
}
void Get_Data(int pos,int len) {
	int cur=Get_Index(pos),sum=sz[cur]-pos;
	if(len<sum) sum=len;
	memcpy(str,data[cur]+pos,sum);
	cur=nxt[cur];
	while((~cur) && sum+sz[cur]<=len)
		memcpy(str+sum,data[cur],sz[cur]), sum+=sz[cur] ,cur=nxt[cur];
	if((~cur) && len-sum)
		memcpy(str+sum,data[cur],len-sum);
	str[len]='\0';
	printf("%s\n",str);
}
inline char Get_opt() {
	register char c=gc();
	while(c!='M'&&c!='I'&&c!='D'&&c!='G'&&c!='P'&&c!='N') c=gc();
	return c;
}

int main() {
	Init();
	int t=read(),pos=0,len;
	char s[10];
	while(t--) {
		switch(Get_opt()) {
			case 'M':
				pos=read();
				break;
			case 'I':
				len=read();
				for(int i=0; i<len; ++i) {
					str[i]=gc();
					if(str[i]<32||str[i]>126) --i;
				}
				Insert(pos,len);
				break;
			case 'D':
				len=read(),Erase(pos,len);
				break;
			case 'G':
				len=read(),Get_Data(pos,len);
				break;
			case 'P':
				--pos;
				break;
			case 'N':
				++pos;
				break;
		}
	}

	return 0;
}
```


---

## 作者：jbc392 (赞：0)

# 块状链表及其应用

思路楼上已经说的很清楚了

看代码注释

代码很丑

```
#include<cstdio>
#include<cctype>
#include<cstring>
//#define gc() getchar()
#define MAXIN 100000
#define gc() (SS==TT&&(TT=(SS=IN)+fread(IN,1,MAXIN,stdin),SS==TT)?EOF:*SS++)
const int N=1024*1024*2+5;
const int MaxSize=/*1700*/4500,MaxNum=/*1700*2*/N*2/MaxSize+100;

int num,nxt[MaxNum],sz[MaxNum],pool[MaxNum];
char data[MaxNum][MaxSize],str[N],IN[MAXIN],*SS=IN,*TT=IN;

inline int read() {
    int now=0,f=1;
    register char c=gc();
    for(; !isdigit(c); c=gc()) if(c=='-') f=-1;
    for(; isdigit(c); now=now*10+c-'0',c=gc());
    return now*f;
}

inline int New_Block() {
    return pool[++num];
}
inline void Del_Block(int v) {
    pool[num--]=v;
}
void Init() {
    for(int i=1; i<MaxNum; ++i) pool[i]=i;
    sz[0]=0, nxt[0]=-1;//新建一个0节点，方便 表头就是0
}
void Merge(int cur,int Nxt) {
    memcpy(data[cur]+sz[cur],data[Nxt],sz[Nxt]);
    nxt[cur]=nxt[Nxt], sz[cur]+=sz[Nxt];
    Del_Block(Nxt);
}
void Maintain() {
    for(int cur=0,Nxt=nxt[0]; ~cur; cur=nxt[cur],Nxt=nxt[cur])
        while((~Nxt) && sz[cur]+sz[Nxt]<=MaxSize)
            Merge(cur,Nxt), Nxt=nxt[cur];//最好不用nxt[Nxt]，因为已经合并、删掉了，虽然不影响答案，但还是不该写
}
int Get_Index(int &pos) { //找到pos所在的块，并将pos定位为块内位置
    int cur=0;
    while((~cur) && pos>sz[cur])//把cur定位到某一块的末尾，不用下一块开头了(pos>=sz)
        pos-=sz[cur], cur=nxt[cur];
    return cur;
}
void Update(int cur,int Nxt,int len,char *s) { //给新的块Nxt设置数据及指针
    nxt[Nxt]=nxt[cur], nxt[cur]=Nxt, sz[Nxt]=len;
    memcpy(data[Nxt],s,len);
}
void Split(int cur,int pos) {
    if(cur==-1||pos==sz[cur]) return;//不能判!pos！因为后边会直接用nxt[cur]，不分裂会跳过该块；而在=sz时不分是没问题的
    int Nxt=New_Block();
    Update(cur,Nxt,sz[cur]-pos,data[cur]+pos);
    sz[cur]=pos;
}
void Insert(int pos,int len) {
    int cur=Get_Index(pos),sum=0,Nxt;
    Split(cur,pos);
    while(sum+MaxSize<=len) {
        Nxt=New_Block();
        Update(cur,Nxt,MaxSize,str+sum);//先分成尽可能多的整块
        sum+=MaxSize, cur=Nxt;
    }
    if(len-sum)//剩余的单独放到一块
        Nxt=New_Block(), Update(cur,Nxt,len-sum,str+sum);
    Maintain();
}
void Erase(int pos,int len) {
    int cur=Get_Index(pos),Nxt;
    Split(cur,pos);
    Nxt=nxt[cur];//because of here
    while((~Nxt) && len>sz[Nxt])
        len-=sz[Nxt], Del_Block(Nxt), Nxt=nxt[Nxt];
    Split(Nxt,len);
    Del_Block(Nxt), nxt[cur]=nxt[Nxt];
    Maintain();
}
void Get_Data(int pos,int len) {
    int cur=Get_Index(pos),sum=sz[cur]-pos;
    if(len<sum) sum=len;
    memcpy(str,data[cur]+pos,sum);
    cur=nxt[cur];
    while((~cur) && sum+sz[cur]<=len)
        memcpy(str+sum,data[cur],sz[cur]), sum+=sz[cur] ,cur=nxt[cur];
    if((~cur) && len-sum)
        memcpy(str+sum,data[cur],len-sum);
    str[len]='\0';
    printf("%s\n",str);
}
inline char Get_opt() {
    register char c=gc();
    while(c!='M'&&c!='I'&&c!='D'&&c!='G'&&c!='P'&&c!='N') c=gc();
    return c;
}

int main() {
    Init();
    int t=read(),pos=0,len;
    char s[10];
    while(t--) {
        switch(Get_opt()) {
            case 'M':
                pos=read();
                break;
            case 'I':
                len=read();
                for(int i=0; i<len; ++i) {
                    str[i]=gc();
                    if(str[i]<32||str[i]>126) --i;
                }
                Insert(pos,len);
                break;
            case 'D':
                len=read(),Erase(pos,len);
                break;
            case 'G':
                len=read(),Get_Data(pos,len);
                break;
            case 'P':
                --pos;
                break;
            case 'N':
                ++pos;
                break;
        }
    }
    return 0;
}
```
[可以看看这道题](https://wenku.baidu.com/view/217f2d66ddccda38376baf67.html)

---


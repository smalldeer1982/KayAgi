# [SDOI2016] 生成魔咒

## 题目描述

魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 $1,2$ 拼凑起来形成一个魔咒串 $[1,2]$。

一个魔咒串 $S$ 的非空字串被称为魔咒串 $S$ 的生成魔咒。

例如 $S=[1,2,1]$ 时，它的生成魔咒有 $[1],[2],[1,2],[2,1],[1,2,1]$ 五种。$S=[1,1,1]$ 时，它的生成魔咒有 $[1],[1,1],[1,1,1]$ 三种，最初 S 为空串。  

共进行 $n$ 次操作，每次操作是在 $S$ 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 $S$ 共有多少种生成魔咒。


## 说明/提示

#### 数据规模与约定   
对于 $10\%$ 的数据，保证 $1 \le n \le 10$；  
对于 $30\%$ 的数据，保证 $1 \le n \le 100$；  
对于 $60\%$ 的数据，保证 $1 \le n \le 10^3$；   
对于 $100\%$ 的数据，保证 $1 \le n \le 10^5$，$1 \leq x_i \leq 10^9$。


## 样例 #1

### 输入

```
7
1 2 3 3 3 1 2```

### 输出

```
1
3
6
9
12
17
22```

# 题解

## 作者：xht (赞：38)

题目地址：[P4070 [SDOI2016]生成魔咒](https://www.luogu.org/problemnew/show/P4070)

相信看到题目之后很多人跟我的思路是一样的——

肯定要用 **SA**（[P3809 【模板】后缀排序](https://www.luogu.org/problemnew/show/P3809)）

肯定要会求**本质不同的子串个数**（[P2408 不同子串个数](https://www.luogu.org/problemnew/show/P2408)）

然后？就不会了......

瓶颈在哪儿？

你会发现每往后添加一个字符，整个 **sa** 数组只会插入一个数，要维护不难

但是 **height** 会**无规律变化**，这就导致无法高效维护

怎么办呢？

# 倒置字符串

我们将整个字符串倒置过来

显然**本质不同的子串个数**不会变化

而每往前添加一个字符串， **height** 的变化是 $O(1)$ 的

那么，问题就变得简单很多了

具体实现请看代码注释

```
#include <bits/stdc++.h>
#define ll long long
#define si set<int>::iterator
using namespace std;
const int N = 1e5 + 6;
int n, m, a[N], b[N];
int sa[N], rk[N], tp[N], tx[N], he[N], st[N][20];
ll ans;
set<int> s;

inline void tsort() {//基数排序 
	for (int i = 1; i <= m; i++) tx[i] = 0;
	for (int i = 1; i <= n; i++) ++tx[rk[i]];
	for (int i = 1; i <= m; i++) tx[i] += tx[i-1];
	for (int i = n; i; i--) sa[tx[rk[tp[i]]]--] = tp[i];
}

inline bool pd(int i, int w) {
	return tp[sa[i-1]] == tp[sa[i]] && tp[sa[i-1]+w] == tp[sa[i]+w];
}

inline void SA() {//后缀数组板子 
	for (int i = 1; i <= n; i++) {
		rk[i] = a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b;
		tp[i] = i;
	}
	tsort();
	for (int w = 1, p = 0; p < n; m = p, w <<= 1) {
		p = 0;
		for (int i = 1; i <= w; i++) tp[++p] = n - w + i;
		for (int i = 1; i <= n; i++)
			if (sa[i] > w) tp[++p] = sa[i] - w;
		tsort();
		swap(rk, tp);
		rk[sa[1]] = p = 1;
		for (int i = 2; i <= n; i++)
			rk[sa[i]] = pd(i, w) ? p : ++p;
	}
	int p = 0;
	for (int i = 1; i <= n; i++) {
		if (p) --p;
		int j = sa[rk[i]-1];
		while (a[i+p] == a[j+p]) ++p;
		he[rk[i]] = p;
	}
}

inline void ST() {//构造ST表 
	for (int i = 1; i <= n; i++) st[i][0] = he[i];
	int w = log(n) / log(2);
	for (int k = 1; k <= w; k++)
		for (int i = 1; i <= n; i++) {
			if (i + (1 << k) > n + 1) break;
			st[i][k] = min(st[i][k-1], st[i+(1<<(k-1))][k-1]);
		}
}

inline int get(int l, int r) {//求l~r之间的最小值（即l-1与r的lcp） 
	int k = log(r - l + 1) / log(2);
	return min(st[l][k], st[r-(1<<k)+1][k]);
}

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
		b[i] = a[i];
	}
	//离散化
	sort(b + 1, b + n + 1);
	m = unique(b + 1, b + n + 1) - (b + 1);
	reverse(a + 1, a + n + 1);//倒置字符串
	SA();//求sa,rk,height数组
	ST();//ST表
	for (int i = n; i; i--) {//倒序考虑
		s.insert(rk[i]);//以rk为关键字插入set
		si it = s.find(rk[i]);//找到插入的位置
		int k = 0;//存最长lcp
		if (it != s.begin()) {//找前驱，注意特判
			int p = *(--it);
			k = get(p + 1, rk[i]);
			++it;
		}
		++it;
		if (it != s.end()) {//找后继，注意特判 
			int p = *it;
			k = max(k, get(rk[i] + 1, p));
		}
		ans += n + 1 - i - k;//加上新生成的子串 
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：hehelego (赞：26)

前面已经又两三个题解提到了使用SAM的玩法了, 具体而言就是一句话.  
> 考虑新建的后缀状态是$q$  
> ~~经过神奇的分类讨论论证,各种parent树上操作,产生了状态分裂,修改了trans的指向,修正了parent之后.~~  
> 贡献是$\text{maxlen}_q-\text{maxlen}_{\text{parent}(q)}$.  

这里给出一个看起来比较有说服力的正确性证明.  

首先,我们先来考虑 $S$的本质不同的子串 如何统计.  
直接考虑扔上$\text{SAM}(S)$,把子串$T$扔到里面去,由于是子串$\text{tr}(q_s,T)=q_0\neq \text{null}$  
如果两个子串$T_1,T_2$是本子不同的,即$T_1\neq T_2$,那我们一定有 $\text{len}(T_1)\neq \text{len}(T_2)$ 或 $\text{tr}(q_s,T_1)\neq \text{tr}(q_s,T_2)$,  
若不然,经过长度相等的路径,到达相同的状态,设$q_0=\text{tr}(q_s,T_1)$,在$q_0$状态的right集合中随便取出一个元素$r$,有$T_1\!=\!T_2=S[r-\text{len}+1,r]$  
写出这个只是搬运了定义的式子,仍然不知道它是什么意思?
我这里给出一个解释,考虑一个长度确定为$|T|$的子串,如果我们知道一个$x\in right(T)$, 那么取出"以位置$x$结尾,长度为$|T|$的串$S[x-|T|+1,x]$",它一定等于$T$.
这里$T_1,T_2$长度一致, 又有一样的$\text{right}$集合, 随便从right中找一个元素, 向前取 $T_1$ 个字符, 得到子串$T_0$, 就有$T_1=T_0=T_2$.

这说明 $\text{SAM}(S)$中, **$q_s$起始的不同路径和$S$的本质不同子串 一一对应** 这个性质非常重要,在$\text{kth}(T),\text{rank}(T)$(指字典序)相关的问题中有很多应用.  

然后来考虑怎么数路径,SAM上面的性质是"两条路径要么终点不同,要么长度不同",我们可以枚举终点状态,然后考虑到达此状态的路径,其长度有多少种可能.  
比如考虑走到$q$的子串,我们发现到达状态$q$的所有路径长度形成一个连续区间.  

所有走到$q$的子串,其$\text{right}$集合是相同的,从$R_q$中任意取出一个位置$r$,  
考察$S[r,r],S[r-1,r],S[r-2,r], \ldots S[1,r]$  
会发现$\text{right}(S[r,r])\supset \text{right}(S[r-1,r])\supset \text{right}(S[r-2,r])\supset \ldots \text{right}(S[1,r])$  
(简单来说,就是长度越短,越容易多次出现. 如果$r'\in \text{right}(S[r-i,r])$那么$r'\in \text{right}(S[r-i+1,r])$,因为后者是前者的后缀).  
如果存在到达$q$,长度为$i$的路径与长度为$j$的路径,其中$i<j$,会有$\text{right}(S[r-j+1,r])=\text{right}(S[r-i+1,r])$按照前面的单调性关系,以$j$结尾长度为$i+1,i+2\ldots j-1$的子串,right会和它们一样,这些子串也应当对应一些SAM上从$q_s$走到$q$的路径,其长度覆盖了$[i+1,j-1]$.

于是, 答案就写成这样, 其中$[\text{maxlen}_{\text{parent}(q)}+1,\text{maxlen}_q]$就是那个长度区间.

$$
\sum_{q\in \text{SAM}(S)}\text{maxlen}_q-\text{maxlen}_{\text{parent}(q)}
$$

------

然后我们再来考虑插入字符,从$\text{SAM}(S)$到$\text{SAM}(Sc)$时发生的变化.直观的说,新增加的(在$S$中不出现的)子串,都是以$n+1$结尾的.形式化的讲,他们都对应于$\text{tr}(q_s,T)=\text{nq}$的$T$,这里需要先考虑一个性质  
(原谅我不能说明白为啥要考虑这个性质...只能说这个性质是在考虑SAM中加字符时状态的$\text{right}$改变时需要用的...可以说你不仔细看SAM的理论直接被板子是肯定不知道的)  

如果两个串$T_1,T_2$,在$S$中,$\text{right}(T_1)\neq \text{right}(T_2)$那么$Sc$中就不会有$\text{right}(T_1)=\text{right}(T_2)$,这个东西只能正向推,反向是不正确的.这个性质说明,**添加字符,不会导致SAM上的状态合并**,回顾:状态是$\text{right}$等价类.  

然后有什么帮助呢? 这个性质说明, 新增贡献在且仅在在$\text{nq}$上面.  

其他状态统计到的子串总和会是$S$中本质不同的子串,$Sc$中仍然是本质不同的.  
$\text{tr}(q_s,T)=\text{nq}$的$T$,肯定不会在其他状态上被统计...emm,显然是这样.然后就做完了.

------

然后我们来讲做法(指本题),emm....直接做,每次添加字符后答案加上$\text{maxlen}_q-\text{maxlen}_{\text{parent}(q)}$...具体实现窝就懒得给代码了233333.

------

~~即使是板子题,也要仔细从基本性质开始推导出做法,这样在赛场,巨大压力下,你才能稳稳地把基础性质应用的题目做出来.~~  
对,就是这样,所以我们下面去看NOI2018 name一题吧.


---

## 作者：MCAdam (赞：9)

[题目](https://www.luogu.com.cn/problem/P4070)

首先对于一个字符串，它正着和倒着的本质不同的字符串是相同的。注意到，每次往后面插入一个字符，前面所有的后缀都会加一个字符。如果插到前面的话，就只会增加一个新的后缀。

所以，先把读入的字符串离散化，然后构造倒着的$SA,rank,height$。

我们倒着枚举$i$（因为前面反过来了），它增加了$len-i+1$个子串，要减去它和之前插入的后缀的重复数。因为插入的后缀的$SA$并不连续，所以我们要找到和当前最像的后缀，也就是寻找离$rank[i]$最近的。所以要一个数据结构支持查询前后缀（注意区分这里的前后缀和字符串的后缀）。

**对于$j,k(rank[j]<rank[k])$，$suf(j)$和$suf(k)$的最长公共前缀为$\min\limits_{i=rank[j]+1}^{rank[k]}height[i]$**

除了要维护前后缀，我们还需要一个$ST$表，因为两个后缀不一定挨在一起。

对于$i$的前缀$pre$和后缀$nxt$，前缀和后缀之前已经减掉$LCP$,所以要加回来，然后再减去$LCP(pre,i)$和$LCP(i,nxt)$

即$ans_i=ans_{i+1}+(len-i+1)-LCP(pre,i)-LCP(i,nxt)+LCP(pre,nxt)$

这样就能做到$O(n\,\log_2n)$

然后我闲着无聊，手打了一个$splay$

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#define ll long long
using namespace std;
const int N=1e5+10;
const int INF=1e9;
int len,size=1e5;
int val[N],tmp[N],SA[N],rk[N],cnt[N],height[N],f[N][20];
struct tree//splay,当然也可以用set或者树状数组 
{
	int tot,root;
	int fa[N],son[N][2];
	int val[N];
	int size[N];
	tree(){ root=tot=0; }
	inline int get(int p)
	{ 
		return son[fa[p]][0]==p?0:1; 
	}
	inline void pushup(int p)
	{ 
		if(p) size[p]=size[son[p][0]]+size[son[p][1]]+1; 
	}
	inline void rotate(int p)
	{
		int f=fa[p],r=get(p);
		if(fa[f]) son[fa[f]][get(f)]=p;
		fa[p]=fa[f];
		if(son[p][r^1]) fa[son[p][r^1]]=f;
		son[f][r]=son[p][r^1];
		fa[f]=p,son[p][r^1]=f;
		pushup(f),pushup(p);
	}
	inline void splay(int p)
	{
		while(fa[p])
		{
			if(fa[fa[p]]&&get(p)==get(fa[p])) rotate(fa[p]);
			rotate(p);
		}
	}
	inline int newnode(int &p,int f,int num)
	{
		if(p==0)
		{
			p=++tot;
			val[p]=num;
			fa[p]=f;
			size[p]=1;
			return p;
		}
		if(val[p]==num){ size[p]++; return p; }
		int pos=(num<val[p]?newnode(son[p][0],p,num):newnode(son[p][1],p,num));
		pushup(p);
		return pos;
	}
	inline void insert(int num)
	{
		int p=newnode(root,0,num);
		splay(p),root=p;
	}
	inline int findpre()
	{
		int p=son[root][0];
		while(son[p][1]) p=son[p][1];
		return val[p];
	}
	inline int findnxt()
	{
		int p=son[root][1];
		while(son[p][0]) p=son[p][0];
		return val[p];
	}
}t;
inline void binsort()//基数排序 
{
	for(int i=0;i<=size;i++) cnt[i]=0;
	for(int i=1;i<=len;i++) cnt[rk[i]]++;
	for(int i=1;i<=size;i++) cnt[i]+=cnt[i-1];
	for(int i=len;i>=1;i--) SA[cnt[rk[tmp[i]]]--]=tmp[i];
}
inline void get_SA()//求出SA,rank数组 
{
	for(int i=1;i<=len;i++)
		rk[i]=val[i],tmp[i]=i;
	binsort();
	for(int l=1;l<=len;l<<=1)
	{
		int p=0;
		for(int i=len-l+1;i<=len;i++)
			tmp[++p]=i;
		for(int i=1;i<=len;i++)
			if(SA[i]>l) tmp[++p]=SA[i]-l;
		binsort(),swap(rk,tmp);
		rk[SA[1]]=p=1;
		for(int i=2;i<=len;i++)
			rk[SA[i]]=(tmp[SA[i]]==tmp[SA[i-1]]&&tmp[SA[i]+l]==tmp[SA[i-1]+l])?p:++p;
		if(p==len) break; size=p;
	}
}
inline void get_height()//求出height数组 
{
	int pre=1;
	for(int i=1;i<=len;i++)
	{
		if(pre) pre--;
		while(val[i+pre]==val[SA[rk[i]-1]+pre]) pre++;
		height[rk[i]]=pre;
	}
}
inline int query(int l,int r)//查询区间最小值 
{
	int k=log2(r-l+1);
	return min(f[l][k],f[r-(1<<k)+1][k]);
}
int main()
{
	ll ans=0;
	scanf("%d",&len);
	for(int i=len;i>=1;i--)
	{
		scanf("%d",&val[i]);
		tmp[i]=val[i];
	}
	sort(tmp+1,tmp+len+1);
	int n=unique(tmp+1,tmp+len+1)-(tmp+1);
	for(int i=1;i<=len;i++)
		val[i]=lower_bound(tmp+1,tmp+n+1,val[i])-tmp;//离散化 
	for(int i=1;i<=len;i++)
		tmp[i]=0;
	get_SA(),get_height();
	for(int i=1;i<=len;i++)//预处理ST表 
		f[i][0]=height[i];
	for(int l=1;l<=log2(len);l++)
		for(int i=1;i<=len-(1<<l)+1;i++)//注意这里的结束条件 
			f[i][l]=min(f[i][l-1],f[i+(1<<(l-1))][l-1]);
	for(int i=len;i>=1;i--)
	{
		t.insert(rk[i]);
		int pre=t.findpre(),nxt=t.findnxt();
		if(pre) ans-=query(pre+1,rk[i]);//减去公共的 
		if(nxt) ans-=query(rk[i]+1,nxt);
		if(pre&&nxt) ans+=query(pre+1,nxt);//把之前减的加回来 
		ans+=len-i+1,printf("%lld\n",ans);//注意还有len-i+1 
	}
	return 0;
}
```


---

## 作者：秋日私语 (赞：8)

[更好的阅读体验点这里](https://blog.csdn.net/A_Comme_Amour/article/details/79987498)

题解
-

这道题还是比较好的； 这里提供后缀数组的解法。
要求出每一个前缀本质不同的后缀的个数，那么我们可以把原序列倒过来，然后实际上就是对于每一个后缀求与其它后缀不重复的前缀个数，也即是后缀长度减去height值；
求出某一个后缀对答案的贡献之后，他不应该停留在元序列中对后续答案的求解产生影响，所以应该把它删除；
在实现方式上，可以使用链表，与平衡树的操作有些类似

代码
-

```
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
#define ll long long
const int maxn=1e6+10;
const int inf=1e9;

int n,m=200,x[maxn],y[maxn],c[maxn],sa[maxn],rnk[maxn],height[maxn];
int s[maxn];

void build_sa()
{
	for (int i=0; i<m; i++) c[i]=0;
	for (int i=0; i<n; i++) c[x[i]=s[i]]++;
	for (int i=1; i<m; i++) c[i]+=c[i-1];
	for (int i=n-1; i>=0; i--) sa[--c[x[i]]]=i;
	
	for (int k=1; k<=n; k<<=1)
	{
		int p=0;
		for (int i=n-k; i<n; i++) y[p++]=i;
		for (int i=0; i<n; i++) if (sa[i]>=k) y[p++]=sa[i]-k;
		
		for (int i=0; i<m; i++) c[i]=0;
		for (int i=0; i<n; i++) c[x[i]]++;
		for (int i=1; i<m; i++) c[i]+=c[i-1];
		for (int i=n-1; i>=0; i--) sa[--c[x[y[i]]]]=y[i];
		
		swap(x,y);//又忘记了swap 
		p=1; x[sa[0]]=0;
		for (int i=0; i<n; i++)
			x[sa[i]] = y[sa[i-1]]==y[sa[i]] && ((sa[i-1]+k>=n?-1:y[sa[i-1]+k])==(sa[i]+k>=n?-1:y[sa[i]+k])) ?p-1:p++;
		if (p>n) break;
		m=p;
	}
}

void build_height()
{
	for (int i=0; i<n; i++) rnk[sa[i]]=i;
	int k=0; height[0]=0;
	for (int i=0; i<n; i++)
	{
		if (!rnk[i]) continue;
		if (k) k--;
		int j=sa[rnk[i]-1];
		while (i+k<n && j+k<n && s[i+k]==s[j+k]) k++;
		height[rnk[i]]=k;
	}
}

void debug(int *A,int len) {for (int i=0; i<len; i++) printf("%d ",A[i]);}

int tmp[maxn],a[maxn],pre[maxn],next[maxn];
ll ans[maxn];
int main()
{
	scanf("%d",&n);
	for (int i=0; i<n; i++) scanf("%d",&a[i]);
	for (int i=0; i<n; i++) tmp[i]=a[i];
	sort(tmp,tmp+n);
	int nn=unique(tmp,tmp+n)-tmp;
	for (int i=0; i<n; i++)
		a[i]=lower_bound(tmp,tmp+nn,a[i])-tmp+1;
	for (int i=0; i<n; i++) s[i]=a[n-i-1];
	build_sa();
	build_height();
	
	for (int i=0; i<n-1; i++) next[i]=i+1;
	for (int i=1; i<n; i++) pre[i]=i-1;
	for (int i=0; i<n; i++)
	{
		int rk=rnk[i];
		int now=n-i-max(height[rk],height[next[rk]]);
		ans[i]=(ll)now;
		height[next[rk]]=min(height[next[rk]],height[rk]);
		height[rk]=0;
		if (rk) next[pre[rk]]=next[rk];
		pre[next[rk]]=pre[rk];//相当于在平衡树中删除了一个元素 
	}
	for (int i=n-1; i>=0; i--) ans[i]+=ans[i+1];
	for (int i=n-1; i>=0; i--) printf("%lld\n",ans[i]);
	return 0;
}
```


---

## 作者：ADay (赞：6)

[更好的阅读体验](https://www.cnblogs.com/aday526/p/solution-p4070.html)  


## 后缀树题解

### Solution

在建后缀树的 $\mathsf{Ukkonen}$ 算法中，是在线插入字符的，所以能很好地解决此问题。

我们知道，一个字符串的本质不同子串就是其后缀树上所有边长之和，那么只要在每次插入时考虑有哪些边会变化即可。

因为后缀树是压缩 $\mathsf{Trie}$，所以每次插入只有叶子节点的边会改变。

- 当插入成功时，会有分裂节点产生，此时会多一条边长为 $1$ 的边。
- 当插入失败时，若要新建节点，也会多一条边长为 $1$ 的边。

那么在这两处更新答案即可。

### Code

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
const int N=2e5+5,inf=1e8;
long long cnt,ans;
struct Suffix_Tree{
	int n,tot,now,rem,link[N],s[N],len[N],st[N];
	__gnu_pbds::gp_hash_table<int,int>ch[N];
	Suffix_Tree():n(0),tot(1),now(1),rem(0){len[0]=inf;}
	int node(int p,int l){link[++tot]=1;st[tot]=p;len[tot]=l;return tot;}
	void ins(int x){
		s[++n]=x;rem++;
		for(int lst=1;rem;){
			while(rem>len[ch[now][s[n-rem+1]]])
				rem-=len[now=ch[now][s[n-rem+1]]];
			int &v=ch[now][s[n-rem+1]],c=s[st[v]+rem-1];
			if(!v||x==c){//插入失败
				link[lst]=now;lst=now;
				if(!v)v=node(n,inf),cnt++;//要新建节点
				else break;
			}else{//插入成功
				int u=node(st[v],rem-1);
				ch[u][c]=v;ch[u][x]=node(n,inf);cnt++;//分裂节点
				st[v]+=rem-1;len[v]-=rem-1;
				link[lst]=v=u;lst=u;
			}if(now==1)rem--;else now=link[now];
		}
	}
}T;
int n,x;
int main(){
    for(scanf("%d",&n);n--;printf("%lld\n",ans+=cnt))
        scanf("%d",&x),T.ins(x);
	return 0;
}
```



---

## 作者：skylee (赞：5)

题目大意：

按顺序在一个序列的末尾插入数字，每次求出插入后能得到的本质不同的子串个数。

思路：

每次在SAM后加入这个数字，每次新出现的本质不同的子串个数就等于new\_p->len-new\_p->link->len。

由于数字范围比较大，可以考虑离散化或者map。

事实上也可以用hash，不过实践证明会比map还慢很多，内存也浪费很多。

另外需要注意开long long。

```cpp
#include<map>
#include<cstdio>
#include<cctype>
inline int getint() {
    char ch;
    while(!isdigit(ch=getchar()));
    int x=ch^'0';
    while(isdigit(ch=getchar())) x=(((x<<2)+x)<<1)+(ch^'0');
    return x;
}
class SuffixAutomaton {
    private:
        struct State {
            State *link;
            std::map<int,State*> go;
            int len;
            State(const int l) {
                link=NULL;
                len=l;
            }
        };
        State *root,*last;
        long long ans;
        void extend(const int w) {
            State *p=last,*new_p=new State(last->len+1);
            while(p!=NULL&&!p->go.count(w)) {
                p->go[w]=new_p;
                p=p->link;
            }
            if(p==NULL) {
                new_p->link=root;
            } else {
                State *q=p->go[w];
                if(q->len==p->len+1) {
                    new_p->link=q; 
                } else {
                    State *new_q=new State(p->len+1);
                    new_q->go=q->go;
                    new_q->link=q->link;
                    q->link=new_p->link=new_q;
                    while(p!=NULL&&p->go[w]==q) {
                        p->go[w]=new_q;
                        p=p->link;
                    }
                }
            }
            last=new_p;
            ans+=new_p->len-new_p->link->len;
        }
    public:
        SuffixAutomaton() {
            root=last=new State(0);
        }
        long long query(const int w) {
            extend(w);
            return ans;
        }
};
SuffixAutomaton sam;
int main() {
    for(int n=getint();n;n--) printf("%lld\n",sam.query(getint()));
    return 0;
}
```

---

## 作者：Polaris_Dane (赞：5)

永远没有人讲后缀树

~~受迫害的后缀数据结构~~

答案就是后缀树所有边的长度之和

因为相同的都被压缩了，每一条边上的每一个字符都对应一个子串

我们知道后缀树的构建算法是在线的

所以可以直接更新答案

我们思考一下每次插入的时候那些边的长度会增加就可以了

只有那些意义会自动变化的边，即叶节点才会

我们只需要记录叶节点个数就可以了

新建节点$+1$，分裂节点$+1$

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<set>
#include<queue>
#include<map>
#include<unordered_map>
#define M 100010
#define inf 2e9
#define LL long long
const int mod=998244353;
using namespace std;
inline int read(){
	int f=1,x=0;char s=getchar();
	while (!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while (isdigit(s)){x=(x<<1)+(x<<3)+(s^48),s=getchar();}
	return x*f;
}
int n,strl,a[M],b[M],cnt;
LL ans;
char str[M]; 
struct Suffix_Tree{
	int	link[M<<1],len[M<<1],start[M<<1],tot,rem,now,s[M<<1];
	unordered_map<int,int> ch[M<<1];
	inline void reset(void){
		len[0]=inf,tot=1,n=rem=0,now=1;	
	}
	inline int New(int st,int le){
		start[++tot]=st,len[tot]=le,link[tot]=1;return tot;
	}
	inline void extend(int x){
		s[++n]=x,++rem;
		for (int last=1;rem;){
			while (rem>len[ch[now][s[n-rem+1]]])
				rem-=len[now=ch[now][s[n-rem+1]]];
			int &v=ch[now][s[n-rem+1]],c=s[start[v]+rem-1];
			if (!v||x==c){
				link[last]=now,last=now;
				if (!v) v=New(n-rem+1,inf),cnt++;
				else break;
			}
			else{
				int u=New(start[v],rem-1);
				ch[u][c]=v,ch[u][x]=New(n,inf),cnt++;
				start[v]+=rem-1,len[v]-=rem-1;
				link[last]=v=u,last=u;
			}
			if (now==1) --rem;else now=link[now];
		}
	}
}tree;
signed main(void){
//	freopen("my.in","r",stdin);
	tree.reset();int k=read();
	for (register int i=1;i<=k;++i) b[i]=a[i]=read();
	sort(b+1,b+k+1);
	for (register int i=1;i<=k;++i) a[i]=lower_bound(b+1,b+k+1,a[i])-b;
	for (strl=1;strl<=k;++strl){
		tree.extend(a[strl]);ans+=cnt;
		printf("%lld\n",ans);
	}
	return 0;
}

```


---

## 作者：Elegia (赞：5)

Update：感谢 @kevinshuai 发现的错误，在拷贝数组进行离散化的时候发生了错位导致一些数中不含有 0 的数据实际上是会被判错误的，现在已经改正。

这是一道用后缀自动机可以秒杀的题，但是也可以作为后缀数组的练手题。


有一些学习资料如《后缀数组：处理字符串的有力工具》中就论述了，对于一个字符串，其本质不同的子串数量是其全部子串数量减去 $\mathrm{height}$ 值之和，即 $\frac{n(n+1)}2 - \sum \mathrm{height}(i)$ 。大家也可以自己思考一下，举几个例子试一试，就能明白这是为什么。


考虑到每次从后面插入一个字符，这个字符串的 $\mathrm{sa}$ 数组其实是会不断变动的。但是如果每次从头插，就仅仅是增加了一个新的后缀，所以我们考虑把这个字符串翻转过来看。


这时，只有插入的那个新后缀紧邻的 $\mathrm{height}$ 值发生了改变，注意到这个值是可以直接在整段字符串的后缀数组中查到的，即 $\mathrm{lcp}(\mathrm{prev}(i), \mathrm{post}(i))$ 。


可以用平衡树来维护查找前后相邻字符串，总复杂度 $\Theta(n\log n)$ 。


注：然而这个问题其实是可以以几乎 $\mathcal O(n)$ 的效率做完的。


\* 用DC3/诱导排序完成后缀数组的构建。

\* 用离线方法维护相邻字符串，如并查集（这里是 $\Theta(n\alpha(n))$ 的，姑且当做线性）。

\* 用离线方法进行 RMQ ，如笛卡尔树 + LCA 。


```cpp
#include <cstdio>
#include <cstring>

#include <algorithm>
#include <set>

using namespace std;

typedef long long ll;
typedef set<int> set_t;

const int N = 100010;

struct {
    int a, b, id;
} p[N], q[N];

struct node {
    int l, r, d;
    node *ls, *rs;

    int query(int l, int r) const;
};

int n;
int a[N], sa[N], rk[N], cnt[N], sorted[N], h[N], height[N];

node* build(int l, int r);

int main() {
    ll hsum = 0;
    scanf("%d", &n);
    for (int i = n; i; --i)
        scanf("%d", &a[i]);
    copy(a + 1, a + n + 1, sorted + 1);
    sort(sorted + 1, sorted + n + 1);
    for (int i = 1; i <= n; ++i)
        a[i] = rk[i] = lower_bound(sorted + 1, sorted + n + 1, a[i]) - sorted;
    for (int l = 1; l <= n; l <<= 1) {
        memset(cnt, 0, sizeof(cnt));
        for (int i = 1; i <= n; ++i) {
            p[i].id = i;
            p[i].a = rk[i];
            p[i].b = (i + l) > n ? 0 : rk[i + l];
            ++cnt[p[i].b];
        }
        for (int i = 1; i <= n; ++i)
            cnt[i] += cnt[i - 1];
        for (int i = n; i; --i)
            q[cnt[p[i].b]--] = p[i];
        memset(cnt, 0, sizeof(cnt));
        for (int i = 1; i <= n; ++i)
            ++cnt[q[i].a];
        for (int i = 1; i <= n; ++i)
            cnt[i] += cnt[i - 1];
        for (int i = n; i; --i)
            p[cnt[q[i].a]--] = q[i];
        for (int i = 1; i <= n; ++i) {
            rk[p[i].id] = rk[p[i - 1].id];
            if (p[i].a != p[i - 1].a || p[i].b != p[i - 1].b)
                ++rk[p[i].id];
        }
    }
    for (int i = 1; i <= n; ++i)
        sa[rk[i]] = i;
    for (int i = 1; i <= n; ++i) {
        h[i] = h[i - 1] - 1;
        if (h[i] < 0)
            h[i] = 0;
        while (a[i + h[i]] == a[sa[rk[i] - 1] + h[i]])
            ++h[i];
    }
    for (int i = 1; i <= n; ++i)
        height[rk[i]] = h[i];
    node* seg = build(1, n);
    set<int> st;
    for (int i = n; i; --i) {
        set_t::iterator iter = st.insert(rk[i]).first, pre = iter, pst = iter;
        if (iter != st.begin()) {
            --pre;
            hsum += seg->query(*pre + 1, rk[i]);
            if (++pst != st.end()) {
                hsum += seg->query(rk[i] + 1, *pst);
                hsum -= seg->query(*pre + 1, *pst);
            }
        } else if (++pst != st.end())
            hsum += seg->query(rk[i] + 1, *pst);
        printf("%lld\n", (ll)(n - i + 1) * (n - i + 2) / 2 - hsum);
    }
    return 0;
}

node* build(int l, int r) {
    static node pool[N * 2];
    static node* top = pool;
    node* p = top;
    ++top;
    p->l = l;
    p->r = r;
    if (l == r) {
        p->d = height[l];
        return p;
    }
    int mid = (l + r) / 2;
    p->ls = build(l, mid);
    p->rs = build(mid + 1, r);
    p->d = min(p->ls->d, p->rs->d);
    return p;
}

int node::query(int l, int r) const {
    if (this->l == l && this->r == r)
        return d;
    if (r <= ls->r)
        return ls->query(l, r);
    if (l >= rs->l)
        return rs->query(l, r);
    return min(ls->query(l, ls->r), rs->query(rs->l, r));
}
```

---

## 作者：GoPoux4 (赞：4)

求本质不同字串个数。

虽然有后缀数组的标签，但是这种动态添加字符的操作最好用SAM。

---

SAM中的每一个节点都代表了一个等价类，而一个等价类是在原串 $s$ 中结束位置（即 $endpos(t)$ ) 相同的字串 $t$ 的集合。

容易得知：SAM中任意两个节点代表的等价类没有交集，且其并集为原串 $s$ 所有字串构成的集合。

对于SAM中的一个状态 $v$ ，它代表了一个等价类。记 $len(v)$ 为其中**最长**的一个字符串的长度，记 $minlen(v)$ 为**最短**的子串的长度。则这个等价类中的元素个数为 $len(v)-minlen(v)$ 。由SAM的性质可知： $minlen(v)=len(link(v))$ 。

则本质不同字串个数为：

$$
\sum_{v \in SAM} len(v)-len(link(v))
$$

每次添加一个字符后都重新计算答案，时间复杂度 $O(n^2)$，只有60pt。

在改变 $link(v)$ 时更新答案， $O(n)$ 可以通过本题。

---

由于字符集 $|\Sigma|$ 有 $10^9$ ，所以用 ${\rm{map}}$ 来存边。

Code：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <map>
#define maxn 100005
#define R register
#define INF 0x3f3f3f3f
using namespace std;
typedef long long lxl;

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

int n;
int las=1,tot=1;
lxl ans;

struct state
{
	int len,link;
	std::map<int, int> mp;
}S[maxn<<1];

inline void insert(int c)
{
	int p=las,np=las=++tot;
	S[np].len=S[p].len+1;
	while(p&&!S[p].mp[c]) S[p].mp[c]=np,p=S[p].link;
	if(!p) S[np].link=1,ans+=1ll*(S[np].len-S[S[np].link].len);
	else
	{
		int q=S[p].mp[c];
		if(S[q].len==S[p].len+1) S[np].link=q,ans+=1ll*(S[np].len-S[S[np].link].len);
		else
		{
			int nq=++tot;
			S[nq]=S[q];
			S[nq].len=S[p].len+1;
			ans+=(S[nq].len-S[S[nq].link].len);
			ans+=(S[S[q].link].len-S[q].len);
			S[q].link=S[np].link=nq;
			ans+=(S[q].len-S[S[q].link].len);
			ans+=(S[np].len-S[S[np].link].len);
			while(p&&S[p].mp[c]==q) S[p].mp[c]=nq,p=S[p].link;
		}
	}
}

int main()
{
	n=read();
	for(int i=1;i<=n;++i)
	{
		insert(read());
		printf("%lld\n",ans);
	}
	return 0;
}

```


---

## 作者：tzc_wk (赞：3)

安利个人 blog：https://www.cnblogs.com/ET2006/

……动态 SA？

首先我们知道在字符串后头添加一个字符是不容易求出字典序的变化的。于是考虑把整个字符串翻转过来，这样在整个字符串后面添加一个字符就等价于在翻转后的字符串中添加一个后缀，这样就好维护多了。

接下来考虑怎样求出答案，我们知道，一个字符串 $s$ 本质不同的子串个数为 $\dfrac{|s|(|s|+1)}{2}-\sum\limits_{i=2}^{|s|}ht_i$。而显然将字符串倒置之后，本质不同的子串个数不会发生变化。于是考虑**对整个 $s$ 的翻转串**做一遍后缀数组。考虑长度为 $l$ 的前缀，显然它在翻转的字符串中对应一段长度为 $l$ 的后缀，故它的所有后缀应当为反转字符串中起始位置分别为 $n-l+1,n-l+2,\dots,n$ 的后缀。假设这 $l$ 个后缀的 $rk$ 从小到大分别为 $x_1,x_2,\dots,x_l$，那么该后缀的 $ht'_i=\min\limits_{j=x_{i-1}+1}^{x_i}ht_j$，用 ```std::set``` 维护即可。具体见代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define fill0(a) memset(a,0,sizeof(a))
#define fill1(a) memset(a,-1,sizeof(a))
#define fillbig(a) memset(a,63,sizeof(a))
#define pb push_back
#define ppb pop_back
#define mp make_pair
template<typename T1,typename T2> void chkmin(T1 &x,T2 y){if(x>y) x=y;}
template<typename T1,typename T2> void chkmax(T1 &x,T2 y){if(x<y) x=y;}
typedef pair<int,int> pii;
typedef long long ll;
namespace fastio{
	#define FILE_SIZE 1<<23
	char rbuf[FILE_SIZE],*p1=rbuf,*p2=rbuf,wbuf[FILE_SIZE],*p3=wbuf;
	inline char getc(){return p1==p2&&(p2=(p1=rbuf)+fread(rbuf,1,FILE_SIZE,stdin),p1==p2)?-1:*p1++;}
	inline void putc(char x){(*p3++=x);}
	template<typename T> void read(T &x){
		x=0;char c=getchar();T neg=0;
		while(!isdigit(c)) neg|=!(c^'-'),c=getchar();
		while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
		if(neg) x=(~x)+1;
	}
	template<typename T> void recursive_print(T x){if(!x) return;recursive_print(x/10);putc(x%10^48);}
	template<typename T> void print(T x){if(!x) putc('0');if(x<0) putc('-'),x=~x+1;recursive_print(x);}
	void print_final(){fwrite(wbuf,1,p3-wbuf,stdout);}
}
using namespace fastio;
const int MAXN=1e5;
const int LOG_N=18;
int n,a[MAXN+5],key[MAXN+5],uni[MAXN+5],num=0;
int getpos(int x){
	int l=1,r=num;
	while(l<=r){
		int mid=(l+r)>>1;
		if(uni[mid]==x) return mid;
		else if(uni[mid]>x) r=mid-1;
		else l=mid+1;
	}
}
int sa[MAXN+5],rk[MAXN+5],buc[MAXN+5],seq[MAXN+5],ht[MAXN+5];
pii x[MAXN+5];int st[MAXN+5][LOG_N+2];ll ans=0;
void getsa(){
	int vmax=num,gr=0;
	for(int i=1;i<=n;i++) buc[a[i]]++;
	for(int i=1;i<=vmax;i++) buc[i]+=buc[i-1];
	for(int i=n;i;i--) sa[buc[a[i]]--]=i;
	for(int i=1;i<=n;i++){
		if(a[sa[i]]!=a[sa[i-1]]) gr++;
		rk[sa[i]]=gr;
	} vmax=gr;
	for(int k=1;k<=n;k<<=1){
		for(int i=1;i<=n;i++){
			if(i+k<=n) x[i]=mp(rk[i],rk[i+k]);
			else x[i]=mp(rk[i],0);
		} memset(buc,0,sizeof(buc));gr=0;int num=0;
		for(int i=n-k+1;i<=n;i++) seq[++num]=i;
		for(int i=1;i<=n;i++) if(sa[i]>k) seq[++num]=sa[i]-k;
		for(int i=1;i<=n;i++) buc[x[i].fi]++;
		for(int i=1;i<=vmax;i++) buc[i]+=buc[i-1];
		for(int i=n;i;i--) sa[buc[x[seq[i]].fi]--]=seq[i];
		for(int i=1;i<=n;i++){
			if(x[sa[i]]!=x[sa[i-1]]) gr++;
			rk[sa[i]]=gr;
		} vmax=gr;if(vmax==n) break;
	}
}
void getht(){
	int k=0;
	for(int i=1;i<=n;i++){
		if(rk[i]==1) continue;if(k) --k;
		int j=sa[rk[i]-1];
		while(i+k<=n&&j+k<=n&&a[i+k]==a[j+k]) k++;
		ht[rk[i]]=k;
	}
}
void buildst(){
	for(int i=1;i<=n;i++) st[i][0]=ht[i];
	for(int i=1;i<=LOG_N;i++) for(int j=1;j+(1<<i)-1<=n;j++)
		st[j][i]=min(st[j][i-1],st[j+(1<<i-1)][i-1]);
}
int query(int l,int r){
	int k=log2(r-l+1);
	return min(st[l][k],st[r-(1<<k)+1][k]);
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),key[i]=a[i];
	reverse(a+1,a+n+1);sort(key+1,key+n+1);
	for(int i=1;i<=n;i++) if(key[i]!=key[i-1]) uni[++num]=key[i];
	for(int i=1;i<=n;i++) a[i]=getpos(a[i]);
	getsa();getht();buildst();set<int> st;st.insert(0);st.insert(n+1);
	for(int i=n;i;i--){
		st.insert(rk[i]);
		set<int> ::iterator it=st.find(rk[i]);
		int pre=*--it;++it;
		int nxt=*++it;--it;
//		printf("%d %d %d\n",pre,nxt,rk[i]);
		ans-=query(pre+1,nxt);ans+=query(pre+1,rk[i]);ans+=query(rk[i]+1,nxt);
		print(1ll*(n-i+1)*(n-i+2)/2-ans);putc(10);
	} print_final();
	return 0;
}
```

---

## 作者：iodwad (赞：3)

首先一个串的不相同字串个数为 $\sum\limits_{i=1}^n n-i-height_i+1$，比较容易理解。

发现这个在后面加字符对于后缀数组非常不友好，于是考虑把整个串反转，然后再把添加操作反过来看成是删除操作，那么可以看成每次删除一个后缀，这个只会对一个位置的 height 数组产生影响，用一个链表来维护。

```cpp
#include <bits/stdc++.h>

#define mp std::make_pair
#define pb push_back

typedef long long LL;

const int MAXN = 1e5;

int n;
int a[MAXN | 1], b[MAXN | 1], L[MAXN | 1], R[MAXN | 1];
LL ans[MAXN | 1];

inline int read() {
  register int x = 0, v = 1;
  register char ch = getchar();
  while (!isdigit(ch)) {
    if (ch == '-') v = -1;
    ch = getchar();
  }
  while (isdigit(ch)) {
    x = x * 10 + ch - '0';
    ch = getchar();
  }
  return x * v;
}

namespace SA {
  int tax[MAXN | 1], rnk[MAXN | 1], tp[MAXN | 1], height[MAXN | 1], sa[MAXN | 1];
  void Q_sort(int lim) {
    for (int i = 1; i <= lim; ++i) tax[i] = 0;
    for (int i = 1; i <= n; ++i) ++tax[rnk[i]];
    for (int i = 1; i <= lim; ++i) tax[i] += tax[i - 1];
    for (int i = n; i >= 1; --i) sa[tax[rnk[tp[i]]]--] = tp[i];
  }
  void get_SA() {
    int m = n;
    for (int i = 1; i <= n; ++i) {
      rnk[i] = a[i];
      tp[i] = i;
    }
    Q_sort(m);
    for (int w = 1, p = 0; p < n; m = p, w <<= 1) {
      p = 0;
      for (int i = 1; i <= w; ++i) tp[++p] = n - i + 1;
      for (int i = 1; i <= n; ++i) if (sa[i] > w) tp[++p] = sa[i] - w;
      Q_sort(m);
      std::swap(rnk, tp);
      rnk[sa[1]] = p = 1;
      for (int i = 2; i <= n; ++i) 
        rnk[sa[i]] = (tp[sa[i - 1]] == tp[sa[i]] && tp[sa[i - 1] + w] == tp[sa[i] + w]) ? p : ++p;
    }
  }
  void get_HE() {
    for (int i = 1; i <= n; ++i) {
      int j = height[rnk[i - 1]];
      if (j) --j;
      while (a[sa[rnk[i] - 1] + j] == a[i + j]) ++j;
      height[rnk[i]] = j;
    }
  }
}

using namespace SA;

int main() 
  n = read();
  for (int i = n; i >= 1; --i) a[i] = b[i] = read();
  std::sort(b + 1, b + 1 + n);
  int m = std::unique(b + 1, b + 1 + n) - b - 1;
  for (int i = 1; i <= n; ++i) a[i] = std::lower_bound(b + 1, b + 1 + m, a[i]) - b;
  get_SA();
  get_HE();
  for (int i = 1; i <= n; ++i) {
    if (i > 1) L[i] = i - 1;
    if (i < n) R[i] = i + 1;
    ans[1] += n - sa[i] - height[i] + 1;
  }
  int Lest = 1;
  for (int i = 1; i < n; ++i) {
    int tmp = rnk[i];
    ans[i + 1] = ans[i] - (n - i + 1 - height[tmp]) - (n - sa[R[tmp]] - height[R[tmp]] + 1);
    height[R[tmp]] = std::min(height[R[tmp]], height[tmp]);
    ans[i + 1] += n - sa[R[tmp]] - height[R[tmp]] + 1;
    if (tmp > 1) R[L[tmp]] = R[tmp];
    else Lest = R[tmp];
    if (tmp < n) L[R[tmp]] = L[tmp];
    L[tmp] = R[tmp] = 0;
  }
  for (int i = n; i >= 1; --i) printf("%lld\n", ans[i]);
  return 0;
}
```


---

## 作者：MikeDuke (赞：3)

嗯？题目“强制”在线

那就使用在线的**SAM**吧

在插入一个字符时，产生的新的子串只有新插入节点的各个**前缀**

在新加入节点时，这个节点的$endpos$显然**只有他自己**

不光是这样，比**这个节点所表示的后缀**短1个字符的**后缀**$endpos$也只有他自己；短2个字符的同样成立，短3个字符的同样成立……

很明显，以上的这些后缀都是加入一个字符后产生的**新的、不重复的**子串，也就是答案要求的子串

当**所枚举的后缀**比**新建节点表示的后缀**短$len[newnode] - len[link[newnode]]$时，发现此时该后缀的$endpos$**不只有自己**了，到此为止

那么，每加入一个字符，就产生了$len[newnode] - len[link[newnode]]$个新的子串

全部代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

#define M 1000005

inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
	while (isdigit(ch)) { (x *= 10) += ch - '0'; ch = getchar(); }
	return x * f;
}

int n, last = 1, cnt = 1;
int link[M], len[M], siz[M], a[M], c[M];

map<int, int> ch[M];

long long ans;
char s[M];

inline void extend(int c)
{
	int p = last, cur = ++cnt; last = cur;
	len[cur] = len[p] + 1, siz[cur] = 1;
	while (p && !ch[p].count(c)) ch[p][c] = cur, p = link[p];
	if (!p)
	{
		link[cur] = 1;
	}
	else
	{
		int q = ch[p][c];
		if (len[q] == len[p] + 1)
		{
			link[cur] = q;
		}
		else
		{
			int clone = ++cnt;
			ch[clone] = ch[q];
			len[clone] = len[p] + 1, link[clone] = link[q], link[q] = link[cur] = clone;
			while (p && ch[p][c] == q) ch[p][c] = clone, p = link[p];
		}
	}
	ans += len[cur] - len[link[cur]]; // 在这里更新ans
}

signed main()
{
	int n = read();
	for (int i = 1; i <= n; i++)
	{
		extend(read());
		printf("%lld\n", ans);
	}

  return 0;
}

---

## 作者：Demoe (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/P4070)

## $\text{Description}$

- 给定一个序列，求本质不同子串个数。

- 强制在线。

## $\text{Solution}$

考虑到本质不同子串计数，我们可以想到把序列转换成字符串来做。

~~不懂有没有 Hash 做法，但我没胡出来。~~

维护子串信息，很容易想到 SAM。

但是 $x_i$ 范围很大诶我们不能直接开个 $2\times 10^5\times 10^9$ 的数组去记录转移。

但是 SAM 有性质**状态数不超过 $2n-1$，转移数不超过 $3n-4$**。

因此直接开 map 记录就行了。

~~然后我们拓扑排一下直接跑出每个点 $\text{endpos}$ 等价类大小就行了。~~

啊这是强制在线的啊，那没事了。

考虑每次新插入一个字符的增量。

SAM 有性质每个等价类中的子串长度**恰好覆盖一个整数区间**。

于是每次增量即为 $len_i-len_{link_i}$，其中 $i$ 表示新加的状态。

## $\text{Code}$

```cpp
const int N=2e6+5;
int n;

struct Suffix_Automaton{
	int tot,lst,maxlen[N],minlen[N],link[N],siz[N],in[N];ll cntd;queue<int> q;map<int,int> to[N];
	Suffix_Automaton(){tot=lst=1;}
	inline void insert(int ch){
		re nw=++tot,p=lst;siz[nw]=1;maxlen[nw]=maxlen[lst]+1;
		while(p&&!to[p][ch]) to[p][ch]=nw,p=link[p];
		if(!p) link[nw]=1;
		else{
			int t=to[p][ch];
			if(maxlen[p]+1==maxlen[t]) link[nw]=t;
			else{
				int cp=++tot;maxlen[cp]=maxlen[p]+1;to[cp]=to[t];
				while(p&&to[p][ch]==t) to[p][ch]=cp,p=link[p];
				link[cp]=link[t];link[t]=link[nw]=cp;
			}
		}
		lst=nw;cntd+=maxlen[nw]-maxlen[link[nw]];
	}
	inline void topo(){
		for(re i=2;i<=tot;++i) ++in[link[i]];
		for(re i=1;i<=tot;++i) if(!in[i]) q.push(i);
		while(!q.empty()){
			int x=q.front();q.pop();
			siz[link[x]]+=siz[x];
			if(!(--in[link[x]])) q.push(link[x]);
		}
	}
	inline ll count(){
		/*topo();return siz[1]-1;*/return cntd;
	}// 原串不同子串个数
}SAM;

// ---------- Suffix Automaton ---------- //

int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(n);
	for(re i=1;i<=n;++i){int x;rd(x);SAM.insert(x);wr(SAM.count());puts("");}
	return 0;
}

// ---------- Main ---------- //

```

---

## 作者：asuldb (赞：2)

这是一道$SA$的练手好题

建议做之前先去做一下[2408](https://www.luogu.org/problemnew/show/P2408)

之后你就肯定会做这道题了

首先上面那道题的答案就是

$$\sum_{i=1}^nn+1-sa[i]-het[i]$$

就是对于每一个后缀求出其能产生的子串，之后减掉和之前本质相同的子串

对于这个题，我们需要求出所有前缀的本质不同的子串个数

先无脑敲上$sa$和$het$的板子，之后我们只需要往里面动态添加后缀就好了

但是如果正着处理的话会有一个非常显然的问题，也就是我们加进去一个后缀，但是这个后缀和之前的一些后缀形成的$lcp$长度超过当前的长度，会导致我们很难计算

所以我们需要把字符串倒过来，之后每次往里面添加一个后缀就只相当于往里面添加了一个字符

反置字符串显然不会令子串变得不相等，于是我们可以完美解决这个问题

之后我们维护上面的那个柿子就好了，由于我们插入的$sa$值并不连续，所以我们不能直接用$het$，而是$het$的最小值

于是我们用一个$st$表来查询$het$的最小值，之后每插入一个点相当于要断裂一个原来存在的排名连续的后缀，所以还需要一个$set$来找前驱和后继

代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<set>
#define re register
#define LL long long
#define maxn 100005
#define set_it std::set<int>::iterator
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
inline int read()
{
	re char c=getchar();int x=0;
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return x;
}
int a[maxn],rk[maxn],tp[maxn],tax[maxn],sa[maxn],het[maxn],b[maxn],to[maxn];
int St[maxn][18],log_2[maxn];
int n,m,sz;LL ans=1;
std::set<int> s;
inline void qsort()
{
	for(re int i=0;i<=m;i++) tax[i]=0;
	for(re int i=1;i<=n;i++) tax[rk[i]]++;
	for(re int i=1;i<=m;i++) tax[i]+=tax[i-1];
	for(re int i=n;i;--i) sa[tax[rk[tp[i]]]--]=tp[i];
}
inline int Pre(int x)
{
    s.insert(x); set_it i=s.find(x);
    if(i==s.begin()) return -1; --i; return *i;
}
inline int Nxt(int x) {set_it i=s.find(x);++i;if(i==s.end()) return -1;return *i;}
inline int find(int x)
{
	int l=1,r=sz;while(l<=r)
	{
		int mid=l+r>>1;if(b[mid]==x) return mid;
		if(b[mid]<x) l=mid+1;else r=mid-1;
	}return 0;
}
inline int ask(int l,int r) {int k=log_2[r-l+1];return min(St[l][k],St[r-(1<<k)+1][k]);}
int main()
{
	n=read();for(re int i=n;i;--i) a[i]=read(),b[i]=a[i];
	std::sort(b+1,b+n+1);m=sz=std::unique(b+1,b+n+1)-b-1;
	for(re int i=1;i<=n;i++) a[i]=find(a[i]);
	for(re int i=1;i<=n;i++) rk[i]=a[i],tp[i]=i;
	qsort();
	for(re int w=1,p=0;p<n;w<<=1,m=p)
	{
		p=0;
		for(re int i=1;i<=w;i++) tp[++p]=n-w+i;
		for(re int i=1;i<=n;i++) if(sa[i]>w) tp[++p]=sa[i]-w;
		qsort();for(re int i=1;i<=n;i++) std::swap(rk[i],tp[i]);
		rk[sa[1]]=p=1;
		for(re int i=2;i<=n;i++) rk[sa[i]]=(tp[sa[i-1]]==tp[sa[i]]&&tp[sa[i-1]+w]==tp[sa[i]+w])?p:++p;
	}
	int k=0;
	for(re int i=1;i<=n;i++)
	{
		if(k) --k;
		int j=sa[rk[i]-1];
		while(a[i+k]==a[j+k]) ++k;
		het[rk[i]]=k;
	}
	for(re int i=2;i<=n;i++) log_2[i]=1+log_2[i>>1];
	for(re int i=1;i<=n;i++) St[i][0]=het[i];
	for(re int j=1;j<=17;j++)
		for(re int i=1;i+(1<<j)-1<=n;i++)
			St[i][j]=min(St[i][j-1],St[i+(1<<(j-1))][j-1]);puts("1");s.insert(rk[n]);
	for(re int i=n-1;i;--i)
	{
		ans+=n-i+1;
		int x=Pre(rk[i]);
		if(x!=-1) {int t=ask(x+1,rk[i]);ans+=to[x],ans-=t;to[x]=t;}
		x=Nxt(rk[i]);
		if(x!=-1) to[rk[i]]=ask(rk[i]+1,x),ans-=to[rk[i]];
		printf("%lld\n",ans);
	}
	return 0;
}

```

---

## 作者：Warriors_Cat (赞：1)

[题面传送门](https://www.luogu.com.cn/problem/P4070)。

> 题意：问一个字符串的所有前缀的本质不同子串个数。

可以算是一个 SAM 练手题吧，[不会 SAM 先往这边走。](https://www.luogu.com.cn/problem/P3804)

---

### $Solution:$

我们考虑每次把一个节点丢进 SAM 所产生的贡献。

根据 SAM 的性质，每次新增一个节点 $p$，它的贡献实际上就是 $len_p - minlen_p + 1$，又有 $minlen_p = len_{fail_p} + 1$，于是每次多一个节点的时候加上 $len_p - len_{fail_p}$ 即可。

很显然 SAM 是个在线算法，因此可以这么搞。

注意到本题字符集很大，因此需要用 `map` 来存 `nxt` 数组。

over，时间复杂度为 $O(n\log n)$，$\log$ 为 map 的复杂度。

### $Code:$

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <queue>
#include <map>
#include <set>
using namespace std;
#define ll long long
#define ull unsigned long long
#define fi first
#define se second
#define dingyi int mid = l + r >> 1, ls = p << 1, rs = p << 1 | 1
#define y0 y_csyakioi_0
#define y1 y_csyakioi_1
#define rep(i, x, y) for(int i = x; i <= y; ++i)
#define per(i, x, y) for(int i = x; i >= y; --i)
#define repn(i, x, y, z) for(int i = x; i <= y; i += z)
#define pern(i, x, y, z) for(int i = x; i >= y; i -= z)
inline int read(){
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
	return x * f;
}
const int N = 200010;
int n, len[N], fail[N], tail, tot, a[N];
map <int, int> nxt[N]; ll ans;
inline void SAMinit(){ fail[0] = -1; tail = tot = 0; }
inline void SAMadd(int c){
	len[++tot] = len[tail] + 1; int p = tail; tail = tot;
	for(; p != -1 && !nxt[p][c]; p = fail[p]) nxt[p][c] = tail;
	if(p == -1){ fail[tail] = 0; ans += len[tail] - len[fail[tail]]; return; } int q = nxt[p][c];
	if(len[q] == len[p] + 1){ fail[tail] = q; ans += len[tail] - len[fail[tail]]; return; }
	len[++tot] = len[p] + 1; fail[tot] = fail[q]; nxt[tot] = nxt[q];
	for(; p != -1 && nxt[p][c] == q; p = fail[p]) nxt[p][c] = tot;
	fail[tail] = fail[q] = tot; ans += len[tail] - len[fail[tail]];
}
inline void mian(){
	n = read(); rep(i, 1, n) a[i] = read(); SAMinit();
	rep(i, 1, n){ SAMadd(a[i]); printf("%lld\n", ans); }
}
signed main(){ int qwq = 1; while(qwq--) mian(); return 0; }
```


---

## 作者：ubsan (赞：1)

题意:

 - 给你一个序列，动态加入数，在每一次加入后求[本质不同的字串个数](https://www.luogu.com.cn/problem/P2408)
	
题解：

如果会用 SAM 做上边提到的那道题，那这道题就简单了，因为 SAM 本来就是在线算法，直接输出答案即可。

#### 如何求本质不同的字串个数

考虑 SAM 的 Right 集合所对应的子串包括原串所有本质不同的子串，而且由于 Sam 的性质 $Min(x)$ 和 $Max(x)$之间是没有交集的，所有我们可以直接求 $\sum Max(x) - Min(x) +1$即可。

code:

```cpp
//
// Created by swift on 2020/7/21.
//

#include<bits/stdc++.h>
#define int long long
using namespace std;
int len;
struct SAM{
    struct node{
        unordered_map<int,int>go;
        int fail,val,ans;
    }a[400000];
    int cnt=1,last=1;
    int tmp[400000];
    int id[400000];
    int ans;
    int solve(){
        return ans;
    }
    void add(int x){
        int p=last;
        int np=++cnt;
        a[np].val=a[p].val+1;
        a[np].ans=1;
        last=np;
        while(p&&a[p].go[x]==0){
            a[p].go[x]=np;
            p=a[p].fail;
        }
        if(!p){a[np].fail=1;ans+=a[np].val-a[a[np].fail].val;return;}
        int q=a[p].go[x];
        if(a[q].val==a[p].val+1){
            a[np].fail=q;
            ans+=a[np].val-a[a[np].fail].val;
            return;
        }
        int nq=++cnt;
        a[nq].val=a[p].val+1;
        a[nq].go=a[q].go;
        a[nq].fail=a[q].fail;
        a[q].fail=nq;
        a[np].fail=nq;
        while(p&&a[p].go[x]==q){
            a[p].go[x]=nq;
            p=a[p].fail;
        }
        ans+=a[np].val-a[a[np].fail].val;//求和
    }
}sam;
signed main(){
    scanf("%lld",&len);
    for(int i=0;i<len;i++){
        int a;
        scanf("%lld",&a);
        sam.add(a);
        printf("%lld\n",sam.solve());
    }
    return 0;
}
```


---

## 作者：Jμdge (赞：1)

这道题吼啊，板子题

# noteskey


本来不知道每次插入之后怎么更新多出来多少本质不同的子串，然后看了看题解据说是 $len[np]-len[fa[np]]$? 于是就稀里糊涂的背了个板子 A 掉了

# code

基本就是板子题吧...

```
//by Judge
#include<bits/stdc++.h>
#define R register
#define ll long long
using namespace std;
const int M=2e5+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(ll x,char chr='\n'){
    if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
} ll ans;
struct SAM{ int cnt,las; SAM(){cnt=las=1;}
	map<int,int> to[M]; arr fa,len;
	inline void insert(R int c){
		R int p=las,np=las=++cnt; len[np]=len[p]+1;
		for(;p&&!to[p].count(c);p=fa[p]) to[p][c]=np;
		if(!p) fa[np]=1;
		else{ int q=to[p][c];
			if(len[q]==len[p]+1) fa[np]=q;
			else{ int nq=++cnt;
				fa[nq]=fa[q],fa[q]=fa[np]=nq;
				to[nq]=to[q],len[nq]=len[p]+1;
				for(;p&&to[p][c]==q;p=fa[p]) to[p][c]=nq;
			}
		} ans+=len[np]-len[fa[np]];
	}
}p;
int main(){
	for(R int n=read(),x;n;--n)
		x=read(),p.insert(x),print(ans);
	return Ot(),0;
}
```


---

## 作者：crescentic (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P4070)

后缀树组解法~

## Desprition

每次在字符串末尾添加一个字符，求新字符串的不同子串的个数。

## Solution

如果没做过[P2408](https://www.luogu.com.cn/problem/P2408)的可以先去康康那道题。

这套题其实就是 P2408 的加强版，多了一个**加操作**。

因为是用后缀数组做，如果我们每次在末尾添加一个字符，就相当于在改变了每个后缀的基础上再添加了一个新后缀，这样的算法显然是不理想的。

所以我们考虑**逆操作**，每次要在末尾加，我们就反其道而行之，把它加在**开头**。这样的话，每次**只会多增加一个新后缀而不会对其他后缀造成影响**。以此类推，如果我们能将末尾的修改操作转化为在开头的修改操作，就可以达到优化的效果。

那么，在转一转聪明的小脑袋瓜，你会发现：如果我们将序列**翻转**过来，每次删掉开头的字符，就可以实现逆操作了，是不是很神（$bai$）奇（$chi$）?


继续考虑如何实现删除操作。

首先了解：

> 所有后缀的前缀的集合就是该字符串的子串集合。


因此，一个后缀对答案造成的影响其实就是他的前缀和，但是需要除去它与它在按**字典序排序后**的后面一个后缀的**最长公共子序列**的长度（因为公共的那一部分另一个后缀也出现了，所以不能多减）。

但是我们在操作过程中需要记录当前后缀前面和后面的后缀信息，所以需要用到两个数组 $u[i]$ 和 $d[i]$ 记录上下边界的编号。

最后就是具体的删除操作了：

为表示方便，后文将**当前要删除的后缀**表示为 $x$ ， $x$ 的**下届**表示为 $y$。

因为删边造成的影响与 $x$ 和 $y$ 有关，然而删除 $x$ 后， $y$ 的上界信息也会发生改变，所以可能会造成 $height_{rk_y}$ 的变化，因此要先将 $x$ 和 $y$ 对答案的贡献都删去，继而更新 $height_{rk_y}$ 的大小，最后再加回 $y$ 的贡献，更新与 $x$ 相关的上下界信息。

具体实现看代码，有详细注释的啦~

还有就是因为数据范围太过毒瘤，就得要先**离散化**哦！

## Code

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
#define ll long long
#define il inline
const int N = 1e5 + 5;
int n,m,s[N],sa[N],b[N],rk[N],height[N],cnt[N],x[N],y[N],u[N],d[N];
ll ans[N],res;
il void getsa() {//模板 
	int i,k,j,num;
	for(i = 1; i <= n; i ++) cnt[x[i] = s[i]] ++;
	for(i = 2; i <= m; i ++) cnt[i] += cnt[i - 1];
	for(i = n; i; i --) sa[cnt[x[i]]--] = i;
	for(k = 1; k <= n; k <<= 1) {
		num = 0;
		for(i = n - k + 1; i <= n; i ++) y[++num] = i;
		for(i = 1; i <= n; i ++) {
			if(sa[i] > k) y[++num] = sa[i] - k;
		}
		for(i = 1; i <= m; i ++) cnt[i] = 0;
		for(i = 1; i <= n; i ++) cnt[x[i]] ++;
		for(i = 2; i <= m; i ++) cnt[i] += cnt[i - 1];
		for(i = n; i; i --) sa[cnt[x[y[i]]]--] = y[i], y[i] = 0;
		swap(x,y);
		x[sa[1]] = num = 1;
		for(i = 2; i <= n; i ++) {
			x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]) ? num : ++num;
		}
		if(num == n) break;
		m = num;
	}
} 
il void get_height() {//还是模板
	int i,j,k;
	for(i = 1; i <= n; i ++) rk[sa[i]] = i;
	for(i = 1, k = 0; i <= n; i ++) {
		if(rk[i] == 1) continue;
		if(k) k--;
		j = sa[rk[i] - 1];
		while(i + k <= n && j + k <= n && s[i + k] == s[j + k]) k ++;
		height[rk[i]] = k;
	}
}
il void read(int &x) {
	x = 0;
	char  c = getchar();
	while(c < '0' || c > '9') c = getchar();
	while(c <= '9' && c >= '0') x = x * 10 + c - '0', c = getchar();
} 
il void write(ll x) {
	if(x < 0) {x = -x; putchar('-');};
	if(x > 9) write(x / 10);
	putchar(x % 10 + '0');
}
int main() {
	int i,j,k;
	read(n);
	for(i = n; i; i --) read(s[i]), b[i] = s[i];
	sort(b + 1,b + 1 + n);
	m = unique(b + 1,b + 1 + n) - b - 1;
	for(i = n; i; i --) s[i] = lower_bound(b + 1,b + 1 + m,s[i]) - b;//离散化 
	getsa(), get_height();
	for(i = 1; i <= n; i ++) {
		res += n - sa[i] + 1 - height[i];//先算出总值 
		u[i] = i - 1, d[i] = i + 1;//当前后缀的上下界，也就是它上面的后缀编号，和下面的编号 
	}
	d[0] = 1, u[n + 1] = n;//初始化 
	for(i = 1; i <= n; i ++) {//开始删边 
		ans[i] = res;//存值 
		k = rk[i], j = d[k];//删边造成的影响与它自己和它的下届有关。 
		res -= n - sa[k] + 1 - height[k];//减去两个的影响 
		res -= n - sa[j] + 1 - height[j];//
		height[j] = min(height[j],height[k]);//重新给下界的height赋值 
		res += n - sa[j] + 1 - height[j];//记得加回来 
		d[u[k]] = d[k], u[d[k]] = u[k];//因为删除操作，所以当前下届的上届就是当前上届，当前上届的下界就是当前下界 
	}
	for(i = n; i; i --) write(ans[i]),puts("");//反向操作 
	return 0;
}

```



---

## 作者：Celtic (赞：0)

$SAM$ 板子题。

如果会 $SAM$ 的话很容易得到 $ans=\sum len_i-len_{fail_i}$ 。

由于 $SAM$ 是在线使用增量法构造的，所以我们每新建一次结点，处理完它的 $fail$ 指针后就把当前的答案加上这个结点的贡献。要更改一个节点的 $fail$ 指针时，先减去它原来的贡献，更改后再加上新的贡献，最后输出答案即可。

$\sf{Code}$

```cpp
#include<bits/stdc++.h>
#define PI acos(-1)
#define N 201001
#define MAX 100015
#define re register
#define inf 1e18
using namespace std;
typedef long long ll;
typedef double db;
const ll mod=1000000007,maxn=10000000000; 
inline void read(re ll &ret)
{
    ret=0;re char c=getchar();re bool pd=false;
    while(!isdigit(c)){pd|=c=='-';c=getchar();}
    while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}
    ret=pd?-ret:ret;
    return;
}
ll n,a[N],las,cnt,ans;
struct node
{
	ll len,fail;
	map<ll,ll>nxt;
}sam[N];
signed main()
{
	read(n);
	sam[las].len=0,sam[las].fail=-1;
	for(re int i=1;i<=n;i++)
	{
		read(a[i]);
		re ll now=++cnt;
		sam[now].len=sam[las].len+1;
		while(las!=-1&&sam[las].nxt.find(a[i])==sam[las].nxt.end())
		{
			sam[las].nxt[a[i]]=now;
			las=sam[las].fail;
		}
		if(las==-1)
		{
			sam[now].fail=0;
			las=now;
		}
		else
		{
			re ll p=las,q=sam[las].nxt.find(a[i])->second;
			if(sam[q].len==sam[p].len+1)
			{
				sam[now].fail=q;
				las=now;
			}
			else
			{
				re ll tmp=++cnt;
				sam[tmp]=sam[q];
				sam[tmp].len=sam[las].len+1;
				sam[now].fail=tmp;
				ans-=sam[q].len-sam[sam[q].fail].len;
				sam[q].fail=tmp;
				ans+=sam[q].len-sam[sam[q].fail].len;
				ans+=sam[tmp].len-sam[sam[tmp].fail].len;
				while(las!=-1&&sam[las].nxt.find(a[i])->second==q)
				{
					sam[las].nxt[a[i]]=tmp;
					las=sam[las].fail;
				}
				las=now;
			}
		}
		ans+=sam[now].len-sam[sam[now].fail].len;
		printf("%lld\n",ans);
	}
	exit(0);
}
```


---

## 作者：文文殿下 (赞：0)

字符集大小为1e9.............使用 map 吧

统计本质不同的子串个数是SAM的经典应用之一

本质不同的子串个数其实就是$\sum max(x)-min(x)+1$

所以我们新建结点 $np$ 时统计它的答案即可

根据我们统计的式子，显然新建节点$nq$的时候，不会对答案造成影响。

```cpp
#include<cstdio>
#include<cstring>
#include<map>
typedef long long ll;
const int maxn = 2e5+20;
int par[maxn],mx[maxn],tr[maxn][26],Right[maxn],c[maxn],id[maxn];
char A[maxn>>1];
int tot=0;
std::map<int,int> M;
int cnt = 1,last = 1;
ll ans = 0;
void extend(int x) {
	int np = ++cnt,p = last;
	Right[np]=1;
	mx[np]=mx[p]+1;
	last=np;
	while(p&&!tr[p][x]) tr[p][x]=np,p=par[p];
	if(!p) par[np]=1;
	else {
		int q = tr[p][x];
		if(mx[q]==mx[p]+1) {
			par[np]=q;
		}
		else {
			int nq = ++cnt;
			mx[nq]=mx[p]+1;
			memcpy(tr[nq],tr[q],sizeof tr[nq]);
			par[nq]=par[q];
			par[q]=par[np]=nq;
			while(p&&tr[p][x]==q) tr[p][x]=nq,p=par[p];
		}
	}
	ans+=mx[np]-mx[par[np]];
	return;
}
int n,k,t;
inline void topsort() {
	for(int i = 1;i<=cnt;++i) ++c[mx[i]];
	for(int i = 1;i<=n;++i) mx[i]+=mx[i-1];
	for(int i = 1;i<=cnt;++i) id[c[mx[i]]--]=i;
	for(int i = cnt;i;--i) Right[par[id[i]]]+=Right[id[i]];
	return;
}
int ch;
int main() {
	scanf("%d",&n);
	for(int i = 1;i<=n;++i) {
		scanf("%d",&ch);
		if(M[ch]==0) {
			M[ch]=++tot;
		}
		extend(M[ch]);
		printf("%lld\n",ans);
	}
	return 0;
}

```

---


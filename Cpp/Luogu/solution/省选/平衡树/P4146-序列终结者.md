# 序列终结者

## 题目背景

网上有许多题，就是给定一个序列，要你支持几种操作：A、B、C、D。一看另一道题，又是一个序列要支持几种操作：D、C、B、A。尤其是我们这里的某人，出模拟试题，居然还出了一道这样的，真是没技术含量……

这样我也出一道题，我出这一道的目的是为了让大家以后做这种题目有一个“库”可以依靠，没有什么其他的意思。

这道题目就叫序列终结者吧。


## 题目描述

给定一个长度为N的序列，每个序列的元素是一个整数（废话）。要支持以下三种操作：

1. 将$[L,R]$这个区间内的所有数加上$V$。
2. 将$[L,R]$这个区间翻转，比如`1 2 3 4`变成`4 3 2 1`。
3. 求$[L,R]$这个区间中的最大值。

最开始所有元素都是$0$。


## 说明/提示

$N \le 50000,M \le 100000$。


## 样例 #1

### 输入

```
4 4
1 1 3 2
1 2 4 -1
2 1 3
3 2 4```

### 输出

```
2```

# 题解

## 作者：PurpleWonder (赞：21)

通过平衡树来维护区间操作的一道比较像模板的题目。

看见楼上的几位大佬用的都是splay，补一发fhq_treap的题解好了。

```cpp
#include<cstdio>
#include<iostream>
#define ls(x) t[x].ch[0]
#define rs(x) t[x].ch[1]
using namespace std;

struct node{
    int size,key,val,cx,add,tur,ch[2],maxn;
}t[100010];
//size:子树大小 key:随机生成的key值 val:当前位置的值 cx:在数组中的位置（好像后面没用到？） add:加法的延迟标记 tur:旋转的延迟标记 ch：左右儿子（用ls（x）与rs（x）表示） maxn:区间的最大值 
int n,m,gs,rt;
int seed=623; 
int com,l,r,zhi;

inline int rand(){
    return seed=(int)((seed*1000000007ll)%0x7fffffff);
}
//从下向上推时，需要同时更新两个值：最大值与子树大小 
inline void push_up(int x){
    t[x].size=t[ls(x)].size+t[rs(x)].size+1;
    t[x].maxn=t[x].val;
    //防止在最大值为负值时访问到空节点（空节点处最大值为0） 
    if(ls(x))t[x].maxn=max(t[x].maxn,t[ls(x)].maxn);
    if(rs(x))t[x].maxn=max(t[x].maxn,t[rs(x)].maxn);
}
//向下推同样需要维护两个值：加的lazy标记与旋转的lazy标记 
inline void push_down(int x){
    if(t[x].tur){
        if(ls(x))t[ls(x)].tur^=1;
        if(rs(x))t[rs(x)].tur^=1;
        ls(x)^=rs(x)^=ls(x)^=rs(x);
        t[x].tur=0;
    }
    if(t[x].add){
        if(ls(x)){//防止给0节点加上奇奇怪怪的值 
            t[ls(x)].add+=t[x].add;
            t[ls(x)].val+=t[x].add;
            t[ls(x)].maxn+=t[x].add;
        }
        if(rs(x)){
            t[rs(x)].add+=t[x].add;
            t[rs(x)].val+=t[x].add;
            t[rs(x)].maxn+=t[x].add;
        }
        t[x].add=0;
        update(x);
    }
}
//正常的分离/合并 
int merge(int x,int y){
    int now;
    push_down(x);push_down(y);
    if(!x || !y)return x|y;
    if(t[x].key<t[y].key){
        now=x,rs(x)=merge(t[x].ch[1],y);
    }
    else now=y,ls(y)=merge(x,t[y].ch[0]);
    push_up(now);
    return now;
}

void split(int root,int bz,int &x,int &y){
    if(!root){x=y=0;return;}
    push_down(root);
    if(t[ls(root)].size>=bz)y=root,split(ls(root),bz,x,ls(y));
    else x=root,split(rs(root),bz-t[ls(root)].size-1,rs(x),y);
    push_up(root);
}

inline void insert(int x){
    t[++gs].key=rand();
    t[gs].val=x;
    t[gs].cx=gs;
    t[gs].maxn=x;
    t[gs].size=1;
    rt=merge(rt,gs);
}
//对l-r这段区间进行操作时，只需要先把l-r这段区间单独分离出来，再在分出来的区间的根节点上加lazy标记即可 
inline void update1(int l,int r,int zhi){
    int x,y,z;
    split(rt,l-1,x,y);
    split(y,r-l+1,y,z);
    t[y].maxn+=zhi;
    t[y].add+=zhi;
    t[y].val+=zhi;
    rt=merge(merge(x,y),z);
}

inline void update2(int l,int r){
    int x,y,z;
    split(rt,l-1,x,y);
    split(y,r-l+1,y,z);
    t[y].tur^=1;
    rt=merge(merge(x,y),z);
}

inline void query(int l,int r){
    int x,y,z;
    split(rt,l-1,x,y);
    split(y,r-l+1,y,z);
    printf("%d\n",t[y].maxn);
    rt=merge(merge(x,y),z);
}

int main(){
    scanf("%d %d",&n,&m); 
    for(int i=1;i<=n;i++){
        insert(0);
    }
    while(m--){
        scanf("%d",&com);
        if(com==1){scanf("%d %d %d",&l,&r,&zhi),update1(l,r,zhi);}
        else if(com==2){scanf("%d %d",&l,&r),update2(l,r);}
        else if(com==3){scanf("%d %d",&l,&r),query(l,r);}
    }
    return 0;
}
```

---

## 作者：VenusM1nT (赞：12)

平衡树。操作涉及区间加、区间反转、区间最大值，如果没有区间反转可以直接无脑线段树，但是有区间反转，考虑平衡树，我还是写了 $\text{FHQ Treap}$，操作都很无脑，但有一个注意点，就是区间操作的 $\text{FHQ Treap}$ 在 $\text{Split}$ 的时候要按照 $siz$ 来，以及在 $\text{Split}$ 右子树的时候要把 $pos$ 减去左子树的 $siz+1$。

```cpp
#include<bits/stdc++.h>
#define MAXN 50005
using namespace std;
struct FHQTreap
{
	int son[2],siz,val,key,add,rev,maxn;
}t[MAXN];
int n,m,siz,root;
void Update(int rt)
{
	t[rt].siz=t[t[rt].son[0]].siz+t[t[rt].son[1]].siz+1;
	t[rt].maxn=t[rt].val;
	if(t[rt].son[0]) t[rt].maxn=max(t[rt].maxn,t[t[rt].son[0]].maxn);
	if(t[rt].son[1]) t[rt].maxn=max(t[rt].maxn,t[t[rt].son[1]].maxn);
}
void PushDown(int rt)
{
	if(t[rt].rev)
	{
		if(t[rt].son[0]) t[t[rt].son[0]].rev^=1;
		if(t[rt].son[1]) t[t[rt].son[1]].rev^=1;
		swap(t[rt].son[0],t[rt].son[1]);
		t[rt].rev=0;
	}
	if(t[rt].add)
	{
		if(t[rt].son[0])
		{
			t[t[rt].son[0]].add+=t[rt].add;
			t[t[rt].son[0]].val+=t[rt].add;
			t[t[rt].son[0]].maxn+=t[rt].add;
		}
		if(t[rt].son[1])
		{
			t[t[rt].son[1]].add+=t[rt].add;
			t[t[rt].son[1]].val+=t[rt].add;
			t[t[rt].son[1]].maxn+=t[rt].add;
		}
		t[rt].add=0;
		Update(rt);
	}
}
int NewNode(int val)
{
	t[++siz].siz=1;
	t[siz].val=val;
	t[siz].key=rand();
	t[siz].maxn=val;
	return siz;
}
int Merge(int x,int y)
{
	if(x) PushDown(x);
	if(y) PushDown(y);
	if(!x || !y) return x+y;
	if(t[x].key<t[y].key)
	{
		t[x].son[1]=Merge(t[x].son[1],y);
		Update(x);
		return x;
	}
	else
	{
		t[y].son[0]=Merge(x,t[y].son[0]);
		Update(y);
		return y;
	}
}
void Split(int rt,int pos,int &x,int &y)
{
	if(!rt) x=y=0;
	else
	{
		PushDown(rt);
		if(t[t[rt].son[0]].siz>=pos)
		{
			y=rt;
			Split(t[rt].son[0],pos,x,t[rt].son[0]);
		}
		else
		{
			x=rt;
			Split(t[rt].son[1],pos-t[t[rt].son[0]].siz-1,t[rt].son[1],y);
		}
		Update(rt);
	}
}
void Insert(int val)
{
	int x,y;
	Split(root,val,x,y);
	root=Merge(Merge(x,NewNode(val)),y);
}
void Modify(int pos,int sum,int val)
{
	int x,y,z;
	Split(root,pos-1,x,y);
	Split(y,sum,y,z);
	t[y].val+=val;
	t[y].maxn+=val;
	t[y].add+=val;
	root=Merge(Merge(x,y),z);
}
void Reverse(int pos,int sum)
{
	int x,y,z;
	Split(root,pos-1,x,y);
	Split(y,sum,y,z);
	t[y].rev^=1;
	root=Merge(Merge(x,y),z);
}
void Query(int pos,int sum)
{
	int x,y,z;
	Split(root,pos-1,x,y);
	Split(y,sum,y,z);
	printf("%d\n",t[y].maxn);
	root=Merge(Merge(x,y),z);
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++) Insert(0);
	for(int i=1;i<=m;i++)
	{
		int opt,x,y,z;
		scanf("%d %d %d",&opt,&x,&y);
		if(opt==1)
		{
			scanf("%d",&z);
			Modify(x,y-x+1,z);
		}
		else if(opt==2) Reverse(x,y-x+1);
		else if(opt==3) Query(x,y-x+1);
	}
	return 0;
}
```

---

## 作者：Garen (赞：11)

#### 这道题对于像我这样只做过两道模板题的splay初学者来说真的是毒瘤爆了，细节挺多，但是不得不说我学到了很多，特意写题解纪念一下。

---

这道题要求我们要支持三个操作：**区间加**，**区间翻转**和**区间最大值**。看到区间翻转条件反射地就要想到**splay**。

splay的基本操作像rotate、splay、kth（第k大）什么的就不讲了，都找到这道题了起码也会吧。

### split操作
这个操作的存在使splay能够维护序列。比如我们要想得到$[l,r]$这个区间，我们就寻找$l-1$这个结点，把它splay到根节点的位置，之后再寻找$r+1$这个结点，把它splay到$l-1$那个结点的右子树位置（你也只能把它旋到右子树位置）。按照二叉排序树的性质，左儿子小于根节点小于右儿子，大于$l-1$的结点在它的右边，小于$r+1$的结点在它的左边，那么$[l,r]$这个区间不就是根节点的右儿子的左儿子了吗？
### 区间加
对于区间加，我们用到类似于线段树的**lazy思想**。pushdown的时候就把左右儿子（前提是有左右儿子）的**懒标记**、**最大值**和**结点值**加上去即可。当我们下访结点的时候就去pushdown一下，这样复杂度很好。

### 区间翻转
区间翻转就是splay的常规操作了，同样也是一种lazy思想。我们只要把需要区间翻转的结点的左右子树交换，同时也给左右儿子（前提是有）打懒标记，之后pushdown的时候也继续进行下去就可以了。也算是基本操作就不讲太多。

### 区间最大值
这个东西也容易维护，只需要在pushup的时候维护一下即可。查询的时候找到对应结点直接输出结点的最大值。

### 建树

建树这个过程个人认为是比较值得注意的。这里用到的建树方法也类似于线段树，以此来建立一颗很平衡的二叉排序树，而不是我们平常见到的单点插入，因此建树过程连splay操作都用不到，节省时间。

弄个草图给大家看看，比如我们建立$[1,8]$的平衡树，建出来是这个样子的：
```
        4
       / \
      2   6
     / \ / \
    1  3 5  7
```
具体参见代码，看看也应该会懂的，类似于线段树。

### 细节

~~AC和WA的距离往往就在于细节。~~

splay维护区间的时候一般都会建立$[1,n+2]$的结点，然后用$[2,n-1]$的结点表示序列，也就是下标移了一位。剩余两个点即是虚拟结点。要是不加虚拟节点的话**会凉的**。

本题需要维护区间最大值，那么我们的**两个虚拟结点1和n+2的原始值就应该是负无穷**！不能让虚拟结点串入我们的序列之中。

有一个不明白的点，楼上的题解也都提醒大家了：**结点0的最大值也要是负无穷**！蒟蒻不知道原理，恳请dalao告诉小弟。

别的地方就没有问题了。我的代码自认为跑得还不错，开O2跑了目前的第三名。代码奉上：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn = 50005;
const int INF = 99999999;
int read()//快读
{
	int ans = 0, s = 1;
	char ch = getchar();
	while(ch > '9' || ch < '0')
	{
		if(ch == '-') s = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9')
	{
		ans = ans * 10 + ch - '0';
		ch = getchar();
	}
	return s * ans;
}
struct Splay
{
	int fa, ch[2], size;//常规splay
	int lazy, rev, maxl, val;//区间加标记、翻转标记、最大值、结点值
} s[maxn];
int n, m, root, a[maxn];
void pushup(int x)
{
	s[x].size = s[s[x].ch[0]].size + s[s[x].ch[1]].size + 1;
	s[x].maxl = max(s[x].val, max(s[s[x].ch[0]].maxl, s[s[x].ch[1]].maxl));//注意左右子树不包含自己
}
void pushdown(int x)//这里在传lazy的时候也顺便完成子结点的修改
{
	if(s[x].lazy)
	{
		if(s[x].ch[0])
		{
			s[s[x].ch[0]].lazy += s[x].lazy;
			s[s[x].ch[0]].maxl += s[x].lazy;
			s[s[x].ch[0]].val += s[x].lazy;
		}
		if(s[x].ch[1])
		{
			s[s[x].ch[1]].lazy += s[x].lazy;
			s[s[x].ch[1]].maxl += s[x].lazy;
			s[s[x].ch[1]].val += s[x].lazy;
		}
		s[x].lazy = 0;
	}
	if(s[x].rev)
	{
		if(s[x].ch[0])
		{
			s[s[x].ch[0]].rev ^= 1;
			swap(s[s[x].ch[0]].ch[0], s[s[x].ch[0]].ch[1]);
		}
		if(s[x].ch[1])
		{
			s[s[x].ch[1]].rev ^= 1;
			swap(s[s[x].ch[1]].ch[0], s[s[x].ch[1]].ch[1]);
		}
		s[x].rev = 0;
	}
}
int identify(int x)
{
	return s[s[x].fa].ch[1] == x;
}
void connect(int son, int fa, int k)
{
	s[son].fa = fa;
	s[fa].ch[k] = son;
}
void rotate(int x)
{
	int y = s[x].fa;
	int z = s[y].fa;
	int yk = identify(x);
	int zk = identify(y);
	int b = s[x].ch[yk ^ 1];
	connect(b, y, yk);
	connect(y, x, yk ^ 1);
	connect(x, z, zk);
	pushup(y); pushup(x);
}
void splay(int x, int goal)
{
	while(s[x].fa != goal)
	{
		int y = s[x].fa;
		int z = s[y].fa;
		if(z != goal) identify(x) == identify(y) ? rotate(y) : rotate(x);
		rotate(x);
	}
	if(goal == 0) root = x;
}
int kth(int k)//平衡树第k大，这里就是第k个数
{
	int now = root;
	while(2333)
	{
		pushdown(now);//下访结点要pushdown
		int left = s[now].ch[0];
		if(s[left].size + 1 < k)
		{
			k -= s[left].size + 1;
			now = s[now].ch[1];
		}
		else if(s[left].size >= k) now = left;
		else return now;
	}
}
int build(int l, int r, int fa)//建树，返回mid，个人认为较方便
{
	if(l > r) return 0;//没有
	if(l == r)
	{
		s[l].fa = fa;
		s[l].maxl = s[l].val = a[l];
		s[l].size = 1;
		return l;
	}
	int mid = (l + r) >> 1;
	s[mid].ch[0] = build(l, mid - 1, mid);//这里直接完成左右子树的赋值
	s[mid].ch[1] = build(mid + 1, r, mid);//注意子树不包含自身
	s[mid].val = a[mid];
	s[mid].fa = fa;
	pushup(mid);//得到size和maxl
	return mid;
}
int split(int l, int r)
{
	l = kth(l); r = kth(r + 2);//注意下标都向右移了一位
	splay(l, 0); splay(r, l);
	return s[s[root].ch[1]].ch[0];
}
void update(int l, int r, int v)//操作1
{
	int now = split(l, r);
	s[now].lazy += v;
	s[now].maxl += v;
	s[now].val += v;
	pushup(s[root].ch[1]);
	pushup(root);
}
void reverse(int l, int r)//操作2
{
	int now = split(l, r);
	s[now].rev ^= 1;
	swap(s[now].ch[0], s[now].ch[1]);
	pushup(s[root].ch[1]);
	pushup(root);
}
int querymax(int l, int r)//操作3
{
	return s[split(l, r)].maxl;
}
int main()
{
	n = read(), m = read();
	a[1] = a[n + 2] = s[0].maxl = -INF;//细节。。。
	root = build(1, n + 2, 0);//直接获得根
	int k, l, r, v;
	while(m--)
	{
		k = read(), l = read(), r = read();
		if(k == 1)
		{
			v = read();
			update(l, r, v);
		}
		else if(k == 2) reverse(l, r);
		else if(k == 3) printf("%d\n", querymax(l, r));
	}
	return 0;//88
}
```

---

## 作者：George1123 (赞：6)

# 题解-序列终结者
这是模板，所有平衡树的题差不多都是模板。

**参考资料**
> 暂无

**[博客中原文](https://blog.csdn.net/KonnyWen/article/details/104582119)**

---

## $\color{#000}\texttt{Introduction}$

蒟蒻初学平衡树一日，做此题耗时五，虽错不奇，记此文以典为人，以堑为己。

---
## $\color{#000}\texttt{Description}$

> [序列终结者](https://www.luogu.com.cn/problem/P4146)
> 有一个 $N$ 个数的序列 $a_1,a_2,...,a_n$ 刚开始时都为 $0$，有 $M$ 个操作如下：
> 1. 将 $[L,R]$ 这个区间内的所有数加上 $V$。
> 2. 将 $[L,R]$ 这个区间翻转，比如 $1,2,3,4$ 变成 $4,3,2,1$。
> 3. 求 $[L,R]$ 这个区间中的最大值。
> 数据范围：$1\le N\le 5\times 10^4$，$1\le M\le 10^5$。

---
## $\color{#000}\texttt{Solution}$
**区间翻转**操作就说明要用 $\texttt{Splaytree}$ 了（[速学平衡树](https://blog.csdn.net/KonnyWen/article/details/104565245)）。用结构体 $(node)\{d,v\}$ 作为每个节点的值，表示值为 $v$，原序列中下标为 $d$。如果用平衡树的中序遍历表示数列，那么找到区间 $[L,R]$，**只需先把 $L$ 的下标前驱节点 $pre$ 旋到根节点，再把 $R$ 的下标后继节点 $nex$ 旋到根节点（$pre$）的右子树，那么这时 $nex$ 的左子树就是 $[L,R]$ 区间对应的节点**。

然后翻转呢就是在 $nex$ 的左儿子上打个标记 $mk$，下次要操作它了就较换它的两个子树，然后标记下传。

怎么区间加数呢？同理通过翻转 $pre$ 和 $nex$ 得到 $[L,r]$ 区间对应节点是 $nex$ 的左子树，然后在 $nex$ 的左二子上打下标记 $ad+=V$，并把它的值加上 $V$。下次要操作它的时候再在它的子树上 $+V$，然后标记下传即可。

取区间最大值也是同理，每个节点 $x$ 记录 $node$ 类型的 $mx_x$ 表示 $x$ 的子树中 $v$ 最大的节点值 $node$。用 $\texttt{pushup}$ 函数和子树大小数组一起算。要询问的时候同样是翻转 $pre$ 和 $nex$，然后输出 $nex$ 的左儿子的 $mx$ 的 $v$ 值。

---

## $\color{#000}\texttt{Code}$
代码实现的时候有个很重要的细节，**因为序列中的数很可能减成负数，所以 $\texttt{pushup}$** $mx$ 的时候要判断是否有子树，否则 $mx$ 会等于空子树的值。

 

```cpp
#include <bits/stdc++.h>
using namespace std;

//&Start
#define lng long long
const int inf=0x3f3f3f3f;
const lng Inf=1e16;

//&Debug
int open(0);
#define Debug if(open)
queue<int> B;
void debug(const char s[]){
	printf("--------%s--------\n",s);
	while(B.size()){printf("%d%c",B.front(),"\n "[B.size()>1]);B.pop();}
}

//&Splay
struct node{//即节点值，d为下标，v为值
	int d,v;
	friend bool operator<(node x,node y){return x.d<y.d;}
	friend bool operator>(node x,node y){return x.d>y.d;}
	friend node operator+=(node&x,int y){x.v+=y;return x;}
	friend node max(node x,node y){return (x.v>y.v)?x:y;}
}; 
template<int N,class T>struct Splaytree{
	int sz,rt,sm[N],ad[N],mk[N],fa[N],ch[N][2],q[N];
	T key[N],mx[N];
	//就是模板和标记
	bool dire(int x){return ch[fa[x]][1]==x;}
	void pushup(int x){
		sm[x]=sm[ch[x][0]]+sm[ch[x][1]]+1;
		mx[x]=key[x];
		//判断是否有子树，否则出锅
		if(ch[x][0]) mx[x]=max(mx[x],mx[ch[x][0]]);
		if(ch[x][1]) mx[x]=max(mx[x],mx[ch[x][1]]);
	}
	void pushdown(int x){
		//像线段树一样的pushdown
		int &ls=ch[x][0],&rs=ch[x][1];
		if(mk[x]){if(ls) mk[ls]^=1;if(rs) mk[rs]^=1;swap(ls,rs);mk[x]=0;}
		if(ad[x]){
			if(ls){ad[ls]+=ad[x];key[ls]+=ad[x];mx[ls]+=ad[x];}
			if(rs){ad[rs]+=ad[x];key[rs]+=ad[x];mx[rs]+=ad[x];}
			ad[x]=0;
		}
	}
	void connect(int x,int f,bool d){if(x) fa[x]=f;if(f) ch[f][d]=x;}
	int newnode(T v,int f){fa[++sz]=f;mx[sz]=key[sz]=v;sm[sz]=1;return sz;}
	void rotate(int x){
		int f=fa[x],ff=fa[f],dx=dire(x),df=dire(f);
		pushdown(x);pushdown(f);
		connect(ch[x][dx^1],f,dx);connect(f,x,dx^1);connect(x,ff,df);
		pushup(f);pushup(x);
	}
	void splay(int x,int ff){
		int len=0;
		for(int i=x;i;i=fa[i]) q[++len]=i;
		for(int i=len;i>=1;i--) pushdown(q[i]);
		for(int f;(f=fa[x])!=ff;rotate(x))
			if(fa[f]!=ff) rotate(dire(x)==dire(f)?f:x);
		if(!ff) rt=x;
	}
	void insert(T v){
		int x=rt,f=0;
		while(x){f=x;x=ch[f][v>key[f]];}
		if(f) ch[f][v>key[f]]=sz+1;
		splay(newnode(v,f),0);
	}
	int kth(int k){
		for(int x=rt;pushdown(x),1;) 
			if(k<=sm[ch[x][0]]) x=ch[x][0];
			else {k-=sm[ch[x][0]]+1;if(!k) return x;x=ch[x][1];}
		return inf;
	}
	//翻转区间，打标记mk
	void flip(int pre,int nex){splay(pre,0);splay(nex,rt);mk[ch[nex][0]]^=1;}
	//区间加V，打标记ad+=V（因为mx的值必然+V，所以先+V）
	void add(int pre,int nex,int y){
		splay(pre,0);splay(nex,rt);
		key[ch[nex][0]]+=y;mx[ch[nex][0]]+=y;ad[ch[nex][0]]+=y;
	}
	//求区间最大值（返回node值）
	T fmax(int pre,int nex){splay(pre,0);splay(nex,rt);return mx[ch[nex][0]];}
};

//&Main
const int N=5e4+10;
int n,m;
Splaytree<N,node> F;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) F.insert((node){i,0});
	F.insert((node){-inf,0});
	F.insert((node){inf,0});
	for(int i=1,h,l,r,v;i<=m;i++){
		scanf("%d%d%d",&h,&l,&r);
		if(h==1){
			scanf("%d",&v);
			F.add(F.kth(l),F.kth(r+2),v);
		} else if(h==2){
			F.flip(F.kth(l),F.kth(r+2));
		} else if(h==3)
			printf("%d\n",F.fmax(F.kth(l),F.kth(r+2)).v);
		Debug{//这部分是调试代码
			for(int i=1;i<=F.sz;i++) B.push(F.fa[i]);
			debug("fa");
			for(int i=1;i<=F.sz;i++) B.push(F.ch[i][0]);
			debug("ls");
			for(int i=1;i<=F.sz;i++) B.push(F.ch[i][1]);
			debug("rs");
			for(int i=1;i<=F.sz;i++) B.push(F.key[i].d);
			debug("id");
			for(int i=1;i<=F.sz;i++) B.push(F.key[i].v);
			debug("val");
			for(int i=1;i<=F.sz;i++) B.push(F.mx[i].v);
			debug("mx");
			for(int i=1;i<=F.sz;i++) B.push(F.ad[i]);
			debug("add");
			for(int i=1;i<=F.sz;i++) B.push(F.mk[i]);
			debug("mk");
		}
	}
	return 0;
}
```
---

我还是太蒻了，**祝大家学习愉快！**



---

## 作者：iodwad (赞：5)

很明显可以用 Splay 来维护对不对

就是每次将待操作区间提取出来，然后打上标记，记得下穿标记。

然而自己还是写的不熟练，竟然调了半个小时。。。这里总结下我犯过的sb错误

- `return o -> father ? o -> father -> ch[1] == o;` ---> `return o ?  o -> father -> ch[1] == o;`
- 没有下传标记
- 只更新了最大值，没有更新当前结点的值

希望这里的代码对指针党有帮助 qwq

```cpp
#include <iostream>
#include <cstdio>

const int INF = -1e9;

int n, m;

namespace Splay {
    struct Tree {
        struct Splay {
            int val, size, maxv, lazy;
            bool rev;
            Splay *ch[2], *father;
            Splay() {}
            Splay(int _val, Splay *_father) : val(_val), size(1), maxv(_val), lazy(0), rev(0), father(_father) { ch[0] = ch[1] = NULL; }
        } *root;
        inline int size(Splay *o) { return o ? o -> size : 0; }
        inline int maxv(Splay *o) { return o ? o -> maxv : INF; }
        inline void pushup(Splay *o) {
            o -> size = size(o -> ch[0]) + 1 + size(o -> ch[1]);
            o -> maxv = std::max(std::max(maxv(o -> ch[0]), maxv(o -> ch[1])), o -> val);        
        }
        inline void pushdown(Splay *o) {
            Splay *&ls = o -> ch[0], *&rs = o -> ch[1];
            if(o -> lazy) {
                if(ls) {
                    ls -> val += o -> lazy;
                    ls -> maxv += o -> lazy;
                    ls -> lazy += o -> lazy;
                }
                if(rs) {
                    rs -> val += o -> lazy;
                    rs -> maxv += o -> lazy;
                    rs -> lazy += o -> lazy;
                }
                o -> lazy = 0;
            }
            if(o -> rev) {
                if(ls) ls -> rev ^= 1;
                if(rs) rs -> rev ^= 1;
                std::swap(ls, rs);
                o -> rev = 0;
            }
        }
        inline int relation(Splay *o) { return o -> father ? o -> father -> ch[1] == o : 0; }
        inline void connect(Splay *x, Splay *y, int relation) {
            if(x) x -> father = y;
            if(y) y -> ch[relation] = x;
        }
        inline void rotate(Splay *o) {
            Splay *p = o -> father, *q = p -> father;
            int wson = relation(o);
            connect(o, q, relation(p));
            connect(o -> ch[wson ^ 1], p, wson);
            connect(p, o, wson ^ 1);
            pushup(p);
            pushup(o);
        }
        inline void splay(Splay *o, Splay *goal) {
            if(!o) return;
            while(o -> father != goal) {
                Splay *p = o -> father;
                if(p -> father != goal) relation(o) ^ relation(p) ? rotate(o) : rotate(p);
                rotate(o);
            }
            if(!goal) root = o;
        }
        inline Splay *kth(int k) {
            Splay *o = root;
            while(1) {
                pushdown(o);
                if(size(o -> ch[0]) + 1 == k) return o;
                else if(size(o -> ch[0]) >= k) o = o -> ch[0];
                else {
                    k -= size(o -> ch[0]) + 1;
                    o = o -> ch[1];
                }
            }
            return NULL;
        }
        inline void build(Splay *&o, Splay *fa, int l, int r) {
            if(l > r) return;
            int mid = (l + r) >> 1;
            o = new Splay((mid == 1 || mid == n + 2) ? INF : 0, fa);
            build(o -> ch[0], o, l, mid - 1);
            build(o -> ch[1], o, mid + 1, r);
            pushup(o);
        }
        inline void Add(int l, int r, int val) {
            ++l;
            ++r;
            Splay *o1 = kth(l - 1), *o2 = kth(r + 1);
            splay(o1, NULL);
            splay(o2, o1);
            root -> ch[1] -> ch[0] -> val += val;
            root -> ch[1] -> ch[0] -> maxv += val;
            root -> ch[1] -> ch[0] -> lazy += val;
            pushup(root -> ch[1]);
            pushup(root);
        }
        inline void Reverse(int l, int r) {
            ++l;
            ++r;
            Splay *o1 = kth(l - 1), *o2 = kth(r + 1);
            splay(o1, NULL);
            splay(o2, o1);
            root -> ch[1] -> ch[0] -> rev ^= 1;
        }
        inline void Max(int l, int r) {
            ++l;
            ++r;
            Splay *o1 = kth(l - 1), *o2 = kth(r + 1);
            splay(o1, NULL);
            splay(o2, o1);
            printf("%d\n", root -> ch[1] -> ch[0] -> maxv); 
        }
    } tree;
}

inline int read() {
    register int x = 0, v = 1;
    register char ch = getchar();
    while(!isdigit(ch)) {
        if(ch == '-') v = -1;
        ch = getchar();
    }
    while(isdigit(ch)) {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * v;
}

using namespace Splay;

int main() {
    n = read();
    m = read();
    tree.build(tree.root, NULL, 1, n + 2);
    while(m--) {
        int opt = read();
        if(opt == 1) {
            int l = read(), r = read(), val = read();
            tree.Add(l, r, val);
        } else if(opt == 2) {
            int l = read(), r = read();
            tree.Reverse(l, r);
        } else if(opt == 3) {
            int l = read(), r = read();
            tree.Max(l, r);
        }
    }
    return 0;
}
```



---

## 作者：Agakiss (赞：4)

原题地址：[序列终结者](https://www.luogu.org/recordnew/show/19802000)

(做了这道题就不能再作序列题了呀qaq)

fhq treap大法好啊！

标记下传的进阶之题

和会有负数，初始化要-INF（敲重点!）

建议下传之前先更改值，才可以保证如果有标记仍未传完，当前答案也是对的

贴代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<ctime>
#include<algorithm>
using namespace std;
#define MAXN 100010
int n, m, root, cnt;
struct node {
    int l, r, val, max, key, size, tag, add;
} t[MAXN];
inline int read() {
    int s = 0, w = 1;
    char c = getchar();
    for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
    for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
    return s * w;
}
inline int New(int val) {
    t[++cnt].val = val, t[cnt].key = rand() * rand(), t[cnt].size = 1;
    return cnt;
}
inline void update(int now) {
    t[0].add = 0;
    t[0].val = 0;
    t[0].max = -2e9;
    t[now].size = t[t[now].l].size + t[t[now].r].size + 1;
    t[now].max = max(t[now].val, max(t[t[now].l].max, t[t[now].r].max));
}
inline void pushdown(int now) {
    t[0].add = 0;
    t[0].val = 0;
    t[0].max = -2e9;
    if (t[now].tag) {
        swap(t[now].l, t[now].r);
        t[t[now].l].tag ^= 1, t[t[now].r].tag ^= 1;
        t[now].tag = 0;
    }
    if (t[now].add) {
        t[t[now].l].add += t[now].add, t[t[now].r].add += t[now].add;
        t[t[now].l].val += t[now].add, t[t[now].r].val += t[now].add;
        t[t[now].l].max += t[now].add, t[t[now].r].max += t[now].add;
        t[now].add = 0;
    }
}
inline void Split(int now, int w, int &u, int &v) {
    if (!now) u = v = 0;
    else {
        pushdown(now);
        if (t[t[now].l].size < w)
            u = now, Split(t[now].r, w - t[t[now].l].size - 1, t[now].r, v);
        else
            v = now, Split(t[now].l, w, u, t[now].l);
        update(now);
    }
}
inline int Merge(int u, int v) {
    if (!u || !v) return u + v;
    if (t[u].key < t[v].key) {
        pushdown(u);
        t[u].r = Merge(t[u].r, v);
        update(u);
        return u;
    }
    else {
        pushdown(v);
        t[v].l = Merge(u, t[v].l);
        update(v);
        return v;
    }
}
int main() {
    n = read(), m = read();
    for (register int i = 1; i <= n; i++)
        root = Merge(root, New(0));
    while (m--) {
        int opt, l, r, v, x, y, z;
        opt = read();
        if (opt == 1) {
            l = read(), r = read(), v = read();
            Split(root, r, x, y);
            Split(x, l - 1, x, z);
            t[z].add += v;
            t[z].val += v;
            t[z].max += v;
            root = Merge(Merge(x, z), y);
        }
        if (opt == 2) {
            l = read(), r = read();
            Split(root, r, x, y);
            Split(x, l - 1, x, z);
            t[z].tag ^= 1;
            root = Merge(Merge(x, z), y);
        }
        if (opt == 3) {
            l = read(), r = read();
            Split(root, r, x, y);
            Split(x, l - 1, x, z);
            printf("%d\n", t[z].max);
            root = Merge(Merge(x, z), y);
        }
    }
    return 0;
}
```


---

## 作者：yizimi远欣 (赞：3)

### 题目描述

给定一个长度为N的序列，每个序列的元素是一个整数（废话）。要支持以下三种操作：

将[L,R]这个区间内的所有数加上V。

将[L,R]这个区间翻转，比如1 2 3 4变成4 3 2 1。

求[L,R]这个区间中的最大值。

最开始所有元素都是0。

### 输入输出格式

#### 输入格式：
第一行两个整数N，M。M为操作个数。

以下M行，每行最多四个整数，依次为K，L，R，V。K表示是第几种操作，如果不是第1种操作则K后面只有两个数。

#### 输出格式：
对于每个第3种操作，给出正确的回答。

### 输入输出样例

输入样例#1：

    4 4
    1 1 3 2
    1 2 4 -1
    2 1 3
    3 2 4
输出样例#1：

    2
   
### 说明

	N≤50000,M≤100000。
    
### 主要思路：FHQ Treap区间操作

算是一道模板题吧。主要是在维护区间加和区间翻转上。

重点就是打标记。其实区间翻转的标记方式在文艺平衡树那道题里面有用到过。就是在做一个标记，标记区间是否翻转。然后在有标记的节点上交换左右子树即可。部分代码如下：
```cpp
// z[rt].col表示区间加的懒标记
// z[rt].coll表示区间翻转的懒标记
// z[rt].ch[0]表示rt节点的左子树
// z[rt].ch[1]表示rt节点的右子树
// 这个代码是下方标记的函数
inline void push_col(int rt) {
	if(z[rt].col) {
		if(z[rt].ch[0]) { // 分类讨论
			z[z[rt].ch[0]].col += z[rt].col;
			z[z[rt].ch[0]].maxx += z[rt].col;
			z[z[rt].ch[0]].w += z[rt].col;
		}
		if(z[rt].ch[1]) {
			z[z[rt].ch[1]].col += z[rt].col;
			z[z[rt].ch[1]].maxx += z[rt].col;
			z[z[rt].ch[1]].w += z[rt].col;
		}
		z[rt].col = 0; // 最后去掉标记
	}
	if(z[rt].coll) { 
		if(z[rt].ch[0]) z[z[rt].ch[0]].coll ^= 1;
		if(z[rt].ch[1]) z[z[rt].ch[1]].coll ^= 1;
		swap(z[rt].ch[0], z[rt].ch[1]); // 交换
		z[rt].coll = 0; // 去标记
	}
}
```
要注意的是在split和merge时加上push_col和update的操作。

### code：

附带debug代码。

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <ctime>
#include <queue>
#include <map>
#include <vector>
using namespace std;
#define go(i, j, n, k) for(int i = j; i <= n; i += k) 
#define fo(i, j, n, k) for(int i = j; i >= n; i -= k)
#define rep(i, x) for(int i = h[x]; i; i = e[i].nxt)
#define mn 50010
#define inf 1 << 30
#define ll long long
inline int read(){
    int x = 0, f = 1; char ch = getchar();
    while(ch > '9' || ch < '0') { if(ch == '-') f = -f; ch = getchar(); }
    while(ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
} 
struct tree{
    int ch[2], pri, sze, w;
    int maxx;
    int col, coll;
} z[mn];
inline void update(int rt) {
    z[rt].sze = 1;
    z[rt].maxx = z[rt].w;
    if(z[rt].ch[0]) {
        z[rt].sze += z[z[rt].ch[0]].sze;
        z[rt].maxx = max(z[rt].maxx, z[z[rt].ch[0]].maxx);
    }
    if(z[rt].ch[1]) {
        z[rt].sze += z[z[rt].ch[1]].sze;
        z[rt].maxx = max(z[rt].maxx, z[z[rt].ch[1]].maxx);
    }
}
inline void push_col(int rt) {
    if(z[rt].col) {
        if(z[rt].ch[0]) {
            z[z[rt].ch[0]].col += z[rt].col;
            z[z[rt].ch[0]].maxx += z[rt].col;
            z[z[rt].ch[0]].w += z[rt].col;
        }
        if(z[rt].ch[1]) {
            z[z[rt].ch[1]].col += z[rt].col;
            z[z[rt].ch[1]].maxx += z[rt].col;
            z[z[rt].ch[1]].w += z[rt].col;
        }
        z[rt].col = 0;
// 		update(rt);
    }
    if(z[rt].coll) {
        if(z[rt].ch[0]) z[z[rt].ch[0]].coll ^= 1;
        if(z[rt].ch[1]) z[z[rt].ch[1]].coll ^= 1;
        swap(z[rt].ch[0], z[rt].ch[1]);
        z[rt].coll = 0;
    }
}
int cnt;
inline int newnode(int w = 0) {
    z[++cnt].maxx = w;
    z[cnt].w = w;
    z[cnt].pri = rand();
    z[cnt].sze = 1;
    z[cnt].col = z[cnt].coll = 0;
    return cnt;
} 
inline int merge(int x, int y) {
    if(!x || !y) return x + y;
    if(z[x].pri < z[y].pri) {
        push_col(x);
        z[x].ch[1] = merge(z[x].ch[1], y);
        update(x);
        return x;
    } else {
        push_col(y);
        z[y].ch[0] = merge(x, z[y].ch[0]);
        update(y);
        return y;
    }
}
inline void split(int rt, int k, int &x, int &y) {
    if(!rt) x = y = 0;
    else {
        push_col(rt);
        if(k <= z[z[rt].ch[0]].sze) {
            y = rt, split(z[rt].ch[0], k, x, z[rt].ch[0]);
        } else {
            x = rt, split(z[rt].ch[1], k - z[z[rt].ch[0]].sze - 1, z[rt].ch[1], y);
        }
        update(rt);
    }
}
inline void debug(int rt) {
    if(!rt) return;
    if(z[rt].ch[0]) debug(z[rt].ch[0]);
    printf("%d %d %d %d\n", z[rt].w, z[rt].maxx, z[rt].pri, z[rt].sze);
    if(z[rt].ch[1]) debug(z[rt].ch[1]);
    
}
int n, m, rot, xx, yy, zz;
int main() {
    n = read(), m = read();
    go(i, 1, n, 1) {
        rot = merge(rot, newnode(0));
    }
    go(i, 1, m, 1) {
        int s = read(), l = read(), r = read(), v;
        if(s == 1) {
            v = read();
            split(rot, r, xx, zz);
            split(xx, l - 1, xx, yy);
            z[yy].col += v;
            z[yy].maxx += v;
            z[yy].w += v;
            rot = merge(merge(xx, yy), zz);
        } else if(s == 2) {
            split(rot, r, xx, zz);
            split(xx, l - 1, xx, yy);
            z[yy].coll ^= 1;
            rot = merge(merge(xx, yy), zz);
        } else if(s == 3) {
            split(rot, r, xx, zz);
            split(xx, l - 1, xx, yy);
            printf("%d\n", z[yy].maxx);
            rot = merge(merge(xx, yy), zz);
        }
    }
//	debug(rot);
    return 0;
}
```

---

## 作者：Cloud_Shadow (赞：2)

[题解第一时间发布在本人的博客](https://www.lzoi.org/article.php?id=234e0808881970854f0804bb13faca73)

这道题和文艺平衡树有点相似 就是多了区间加上某个值
其实做法很简单 就是把区间提取出来 然后下放标记

在树中加入两个辅助节点 但这两个辅助节点的区间最大值标记得是-inf
这两个点中序遍历的排名就是1和n+1

提取区间: 现将排名为x的旋转到根节点 再把排名为y+2的点旋转到x的右儿子
y+2的左儿子那颗树就是要求的区间了

区间加: 先提取区间 再区间的根节点修改值 然后下放修改标记 查询时再修改

区间翻转: 先提取区间 然后下放翻转标记 查询时再翻转

废话就那么多 下面上代码 306行。。。 (有二十多行是调试遗留下来的233)
```cpp
#include <bits/stdc++.h>
using namespace std;

const int INF=233333333;

namespace _Splay{
    class SplayNode{
        public:
            
            SplayNode *L,*R,*F;
            int key,tag,size,maxc,data;
            
            SplayNode(int k){
            	data=0;
            	maxc=0;
                tag=0;
                key=k;
                L=R=F=NULL;
            }
            
            void RightRotate();
            void LeftRotate();
            SplayNode* Find(int k);
            SplayNode* Insert(int k);
    };

    void PushUp(SplayNode *G){
        if(G->L==NULL&&G->R==NULL){
        	G->size=1;
        	G->maxc=G->key;
        }else if(G->L==NULL){
        	G->size=G->R->size+1;
			G->maxc=G->R->maxc;
        }else if(G->R==NULL){
            G->size=G->L->size+1;
			G->maxc=G->L->maxc;
        }else{
            G->size=G->L->size+G->R->size+1;
        	G->maxc=max(G->L->maxc,G->R->maxc);
		}
        G->maxc=max(G->key,G->maxc);
    }
    
    void PushDown(SplayNode *G){
        if(G->tag){
			swap(G->L,G->R);
            if(G->L!=NULL){
                G->L->tag^=1;
            }
            if(G->R!=NULL){
                G->R->tag^=1;
            }
            G->tag^=1;            	
		}
		if(G->data){
			if(G->L!=NULL){
				G->L->data+=G->data;
				G->L->key+=G->data;
				G->L->maxc+=G->data;
			}
			if(G->R!=NULL){
				G->R->data+=G->data;
				G->R->key+=G->data;
				G->R->maxc+=G->data;				
			}
			G->data=0;
		}
    }
    
    void Splay(SplayNode *X,SplayNode *S){
        SplayNode *SF=S->F;
        while(X->F!=SF){
            SplayNode *Y=X->F; 
            SplayNode *Z=Y->F; 
        	if(Z==SF){
                if(Y->L==X){
                    X->RightRotate();
                }else{
                    X->LeftRotate();
                }
        	}else{
                if(Y->L==X&&Z->L==Y){
                    Y->RightRotate();
                    X->RightRotate();
                }
                if(Y->R==X&&Z->R==Y){
                    Y->LeftRotate();
                    X->LeftRotate();
                }
                if(Y->L==X&&Z->R==Y){
                    X->RightRotate();
                    X->LeftRotate();
                }
                if(Y->R==X&&Z->L==Y){
                    X->LeftRotate();
                    X->RightRotate(); 
                }				
            } 
        }
    }	 
    
    void SplayNode::RightRotate(){
        SplayNode *y=this->F;
        this->F=y->F;
        if(F!=NULL){
            if(F->L==y){
                F->L=this;
            }else{
                F->R=this;
            }
        }
        if(R!=NULL){
            R->F=y;
        }
        y->L=R;
        y->F=this;
        this->R=y;
        PushUp(y);PushUp(this);
    }

    void SplayNode::LeftRotate(){
        SplayNode *y=this->F;
        this->F=y->F;
        if(F!=NULL){
            if(F->L==y){
                F->L=this;
            }else{
                F->R=this;
            }
        }
        if(L!=NULL){
            L->F=y;
        }
        y->R=L;
        y->F=this;
        this->L=y;
        PushUp(y);PushUp(this);
    }	

    SplayNode* SplayNode::Find(int k){
        PushDown(this);		
//    	printf("%d %dth! %d \n",this->key,k,this->size);
    	if(this->L==NULL){
//    		printf("233333?\n");
    		if(k==1){
    			return this;
            }
            if(R==NULL){
                return NULL;
            }
            return R->Find(k-1);
        }else{
            if(this->L->size+1==k){
                return this;
            }
            if(k<this->L->size+1){
//            	printf("L!!!!!!!!");
                return L->Find(k);
            }else{
                if(R==NULL){
                    return NULL;
                }
                return R->Find(k-this->L->size-1);
            }		
        }

    }
    
    SplayNode* SplayNode::Insert(int k){
        if(k<=key){
            if(L==NULL){
                L=new SplayNode(k);
                L->F=this;
                return L; 
            }else{
                return L->Insert(k);
            }
        }else{
            if(R==NULL){
                R=new SplayNode(k);
                R->F=this;
                return R; 
            }else{
                return  R->Insert(k); 
            }
        }
    }
    
    SplayNode *Root,*Fx,*Fy;int cnt;
    
    void AddSum(int x,int y,int val){
//    	printf("find root = %d\n",Root->key);
        SplayNode *TempA=Root->Find(x);
//       printf("find %d = %d\n",y+1,TempA->key);
        Splay(TempA,Root);
        Root=TempA;
        SplayNode *TempB=Root->Find(y+2);
//        printf("find %d = %d",x-1,TempB->key);
        Splay(TempB,Root->R);
        //Root=TempB;
        Root->R->L->data+=val; 
        Root->R->L->key+=val;
        Root->R->L->maxc+=val;
    }
    
    void Turn(int x,int y){
//    	printf("find root = %d\n",Root->key);
        SplayNode *TempA=Root->Find(x);
//       printf("find %d = %d\n",y+1,TempA->key);
        Splay(TempA,Root);
        Root=TempA;
        SplayNode *TempB=Root->Find(y+2);
//        printf("find %d = %d",x-1,TempB->key);
        Splay(TempB,Root->R);
        //Root=TempB;
        Root->R->L->tag^=1; 
    }
    
    int GetMax(int x,int y){
//    	printf("find root = %d\n",Root->key);
        SplayNode *TempA=Root->Find(x);
//       printf("find %d = %d\n",y+1,TempA->key);
        Splay(TempA,Root);
        Root=TempA;
        SplayNode *TempB=Root->Find(y+2);
//        printf("find %d = %d",x-1,TempB->key);
        Splay(TempB,Root->R);
        //Root=TempB;
        return Root->R->L->maxc; 
    }    
    
    void SplayInsert(int k){
        if(!cnt){
            Root=new SplayNode(k);
            Root->size=1;
        }else{
            SplayNode *Temp=Root->Insert(k);
            Splay(Temp,Root);
            Root=Temp;
            PushUp(Root);
        }
        cnt++;
    }
    

    void Print(SplayNode *G){
        PushDown(G);
        if(G->L!=NULL){
            Print(G->L);
        }
        if(G!=Fx&&G!=Fy){
/*        if(G->L)
        	printf("L= %d ",G->L->key);
        if(G->R)
        	printf("R= %d ",G->R->key);
        printf("key=%d size=%d\n",G->key,G->size);
            
        //*/
            printf("%d ",G->key);
        }
        if(G->R!=NULL){
            Print(G->R);
        }
    }
}

int n,m;

int main(){
    scanf("%d%d",&n,&m);
    for(int i=0;i<=n+1;i++){
        _Splay::SplayInsert(0);
    }
/*    _Splay::SplayNode *T=_Splay::Root->Find(4);
    _Splay::Splay(T,_Splay::Root);
    _Splay::Root=T;
    cout<<T->L->size<<" "<<T->R->size<<endl;*/
    _Splay::Fx=_Splay::Root->Find(1); 
    _Splay::Fx->maxc=-INF;
    _Splay::Fy=_Splay::Root->Find(n+2);
	_Splay::Fy->maxc=-INF;
    //cout<<_Splay::Root->size<<endl;
    //_Splay::Print(_Splay::Root);
    //cout<<endl;
    for(int i=1;i<=m;i++){
        int id,x,y,val;
        scanf("%d",&id);
        if(id==1){
        	scanf("%d%d%d",&x,&y,&val);
        	_Splay::AddSum(x,y,val);
		}else if(id==2){
	        scanf("%d%d",&x,&y);
        	_Splay::Turn(x,y);		
		}else if(id==3){
	        scanf("%d%d",&x,&y);
        	//cout<<_Splay::GetMax(x,y)<<endl;
			printf("%d\n",_Splay::GetMax(x,y));				
		}
		//cout<<" id="<<id<<" x="<<x<<" y="<<y<<" val="<<val<<endl;
        //_Splay::Print(_Splay::Root);
        //cout<<endl; 
    }
   //_Splay::Print(_Splay::Root);
    return 0;	
}

```
指针写的 是不是看起来很爽 2333

---

## 作者：elijahqi (赞：2)

(http://www.elijahqi.win/2018/01/22/bzoj1251-%E5%BA%8F%E5%88%97%E7%BB%88%E7%BB%93%E8%80%85/%20%E2%80%8E)

http://blog.csdn.net/elijahqi/article/details/79128002

Description


网上有许多题，就是给定一个序列，要你支持几种操作：A、B、C、D。一看另一道题，又是一个序列 要支持几种操作：D、C、B、A。尤其是我们这里的某人，出模拟试题，居然还出了一道这样的，真是没技术含量……这样 我也出一道题，我出这一道的目的是为了让大家以后做这种题目有一个“库”可以依靠，没有什么其他的意思。这道题目 就叫序列终结者吧。 【问题描述】 给定一个长度为N的序列，每个序列的元素是一个整数（废话）。要支持以下三种操作： 1. 将[L,R]这个区间内的所有数加上V。 2. 将[L,R]这个区间翻转，比如1 2 3 4变成4 3 2 1。 3. 求[L,R]这个区间中的最大值。 最开始所有元素都是0。

Input

第一行两个整数N，M。M为操作个数。 以下M行，每行最多四个整数，依次为K，L，R，V。K表示是第几种操作，如果不是第1种操作则K后面只有两个数。

Output

对于每个第3种操作，给出正确的回答。

Sample Input

4 4
1 1 3 2

1 2 4 -1

2 1 3
3 2 4


Sample Output

2
【数据范围】



N<=50000，M<=100000。

平衡树 splay的一些基本操作 注意0号节点的max1需要给-inf

```cpp
#include<cstdio>
#include<algorithm>
#define N 55000
#define inf 0x3f3f3f3f 
using namespace std;
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
inline int read(){
    int x=0,f=1;char ch=gc();
    while(ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=gc();}
    while(ch<='9'&&ch>='0') x=x*10+ch-'0',ch=gc();
    return x*f;
}
int size[N],n,max1[N],c[N][2],rev[N],tag[N],fa[N],v[N],root,m;
inline void update(int x){
    size[x]=size[c[x][0]]+size[c[x][1]]+1;
    max1[x]=max(max(max1[c[x][0]],max1[c[x][1]]),v[x]);
}
inline void pushdown(int x){
    int l=c[x][0],r=c[x][1];
    if (tag[x]){
        if (l) tag[l]+=tag[x],max1[l]+=tag[x],v[l]+=tag[x];
        if (r) tag[r]+=tag[x],max1[r]+=tag[x],v[r]+=tag[x];tag[x]=0;
    }
    if (rev[x]){
        if (l) rev[l]^=1,swap(c[l][1],c[l][0]);
        if (r) rev[r]^=1,swap(c[r][1],c[r][0]);rev[x]=0;
    }
}
inline void build(int f,int l,int r){
    if (l>r) return;
    if (l==r){size[l]=1;fa[l]=f;c[f][l>f]=l;return;}
    int mid=l+r>>1;build(mid,l,mid-1);build(mid,mid+1,r);
    fa[mid]=f;c[f][mid>f]=mid;update(mid);
}
inline int find(int x,int sz){
    pushdown(x);
    int l=c[x][0],r=c[x][1];
    if (size[l]+1==sz) return x;
    if (sz<=size[l]) return find(l,sz);else return find(r,sz-size[l]-1);
}
inline void rotate(int x,int &tar){
    int y=fa[x],z=fa[y];
    int l=c[y][1]==x,r=l^1;
    if (y==tar) tar=x;else c[z][c[z][1]==y]=x;
    fa[c[x][r]]=y;fa[y]=x;fa[x]=z;
    c[y][l]=c[x][r];c[x][r]=y;update(y);update(x);
}
inline void splay(int x,int &tar){
    while(x!=tar){
        int y=fa[x],z=fa[y];
        if (y!=tar){
            if ((c[y][0]==x)^(c[z][0]==y)) rotate(x,tar);else rotate(y,tar);
        }rotate(x,tar);
    }
}
inline int split(int x,int y){
    int xx=find(root,x),yy=find(root,y);
    splay(yy,root);splay(xx,c[root][0]);return c[xx][1];
}
inline void print(int x){
    if (c[x][0]) print(c[x][0]);
    printf("%d %d %d %d %d %d %d\n",x,c[x][0],c[x][1],v[x],max1[x],tag[x],rev[x]);
    if (c[x][1]) print(c[x][1]);
}
int main(){
    freopen("bzoj1251.in","r",stdin);
    n=read();m=read();build(0,1,n+2);root=n+3>>1;
    max1[0]=-inf;
    for (int i=1;i<=m;++i){
        int op=read();//print(root);puts("fds");
        if (op==1){
            int x=read(),y=read(),vv=read();
            int tmp=split(x,y+2);tag[tmp]+=vv;v[tmp]+=vv;max1[tmp]+=vv;
        }
        if (op==2){
            int x=read(),y=read();
            int tmp=split(x,y+2);rev[tmp]^=1;swap(c[tmp][0],c[tmp][1]);
        }    
        if (op==3){
            int x=read(),y=read();
            int tmp=split(x,y+2);printf("%d\n",max1[tmp]);
        }
    }
    return 0;
}

```

---

## 作者：Captain_Paul (赞：1)

作为一个平衡树萌新，能AC这道题也是很不容易

思路主要参考了P2042维护数列题解中I_AM_HelloWord大佬的讲解

建立哨兵节点1和n+2，将操作序列整体后移一位

之后建树，在建树中预处理平衡树各个节点的val和maxn

接下来分析题目中的三种操作

对一个区间进行操作，可以看成从左端点L开始连续处理R-L+1的点

于是我们用一个split操作找到在平衡树中序遍历中实际需要操作的区间

然后在reverse，change和getmax操作中直接调用即可

对于每一种操作分别维护反转标记，加法标记，区间最大值

由于每一次操作都要用到find

所以直接在find函数中下传标记就可以了

ps:maxn[0]要初始化为-inf，inf一定要开极大值 ~~（否则就会像我一样WA）~~

丑陋的代码：

```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#define ls ch[now][0]
#define rs ch[now][1]
using namespace std;
const int N=1e5+5,inf=2147483640;
int n,m,cnt,root,a[N],tag[N],maxn[N],ch[N][2],val[N],f[N],size[N],id[N];
bool rev[N];
inline int read()
{
	int x=0,w=1;
	char c=getchar();
	while (!isdigit(c)&&c!='-') c=getchar();
	if (c=='-') c=getchar(),w=-1;
	while (isdigit(c))
	{
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return x*w;
}
inline bool get(int x)
{
	return ch[f[x]][1]==x;
}
inline void update(int now)
{
	size[now]=size[ls]+size[rs]+1;
	maxn[now]=max(val[now],max(maxn[ls],maxn[rs]));
}
inline void pushdown(int now)
{
	if (rev[now])
	{
		if (ls) rev[ls]^=1,swap(ch[ls][0],ch[ls][1]);
		if (rs) rev[rs]^=1,swap(ch[rs][0],ch[rs][1]);
		rev[now]=0;
	}
	if (tag[now])
	{
		if (ls) tag[ls]+=tag[now],maxn[ls]+=tag[now],val[ls]+=tag[now];
		if (rs) tag[rs]+=tag[now],maxn[rs]+=tag[now],val[rs]+=tag[now];
		tag[now]=0;
	}
}
void build(int l,int r,int p)
{
	int mid=(l+r)>>1,now=mid,pre=p;
	if (l==r)
	{
		maxn[now]=a[l];
		size[now]=1; rev[now]=0;
	}
	if (l<mid) build(l,mid-1,mid);
	if (mid<r) build(mid+1,r,mid);
	val[now]=a[mid]; f[now]=pre;
	update(now); ch[pre][mid>=p]=now;
}
inline void rotate(int x,int &k)
{
	int y=f[x],z=f[y],t=get(x),w=ch[x][t^1];
	if (y==k) k=x; else ch[z][ch[z][1]==y]=x;
	ch[y][t]=w; if (w) f[w]=y;
	ch[x][t^1]=y; f[y]=x; f[x]=z;
	update(y); update(x);
}
inline void splay(int x,int &k)
{
	while (x!=k)
	{
		int y=f[x],z=f[y];
		if (y!=k) rotate(get(y)==get(x)?y:x,k);
		rotate(x,k);
	}
}
int find(int now,int k)
{
	pushdown(now);
	if (size[ls]==k-1) return now;
	if (size[ls]>=k) return find(ls,k);
	return find(rs,k-size[ls]-1);
}
inline int split(int x,int tot)
{
	int l=find(root,x),r=find(root,tot+2);
	splay(l,root); splay(r,ch[root][1]);//找到[x+1,x+tot]
	return ch[r][0];
}
inline void reverse(int x,int y)
{
	int now=split(x,y),z=f[now];
	rev[now]^=1; swap(ls,rs);
	update(z); update(f[z]);
}
inline void change(int x,int y,int v)
{
	int now=split(x,y),z=f[now];
	val[now]+=v; tag[now]+=v; maxn[now]+=v;
	update(z); update(f[z]);
}
inline int getmax(int x,int y)
{
	return maxn[split(x,y)];
}
int main()
{
	n=read(),m=read(); maxn[0]=a[1]=a[n+2]=-inf;
	root=(n+3)>>1; build(1,n+2,0);
	while (m--)
	{
		int opt=read(),x=read(),y=read();
		if (opt==1) change(x,y,read());
		if (opt==2) reverse(x,y);
		if (opt==3) printf("%d\n",getmax(x,y)); 
	}
	return 0;
}
```

---


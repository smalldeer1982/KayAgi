# 千山鸟飞绝

## 题目描述

话说有一天 doyouloveme 和 vfleaking 到山里玩。谁知 doyouloveme 刚刚进山，所有的鸟儿竟被他的神犇气场给惊得全部飞走了。vfleaking 顿时膜拜不已。

这时鸟王用鸟语说道：「!@#\$%…?」，安抚了一下众鸟的情绪。鸟王生性好斗，作出了一个决定：要排鸟布阵把刚才吓到它们的人类赶出山去。

每只鸟都有一个编号，都有一个威武值。每秒钟鸟王都会发一个命令，编号为 $v$ 的鸟飞到 $(x,y)$ 去（坐标系原点是山顶，坐标单位为鸟爪）。鸟飞得很快，一秒之内就飞到了，可以看作是瞬间移动。如果编号为 $v$ 的鸟和编号为 $u$ 的鸟某一时刻处在同一位置，它们就会互相鼓励，增加各自的士气值和团结值。一只鸟的士气值等于此刻与它处在同一位置的鸟中的威武值的最大值，团结值等于此刻与它处在同一位置的鸟的只数。如果每一时刻都没有鸟与它处在同一位置，则士气值和团结值都为 $0$。要注意自己不能鼓励自己，计算士气值和团结值时不能算上自己。

$t$ 秒钟后，doyouloveme 目测出了现在每只鸟的战斗力，于是感叹了一句：「不妙，我们得走了。」

正所谓团结的鸟儿一个顶俩，所以 doyouloveme 这样描述战斗力：一只鸟战斗力值等于它在 $0$ 到 $t$ 秒中士气值的最大值与团结值的最大值的乘积。注意不是乘积的最大值，而是最大值的乘积。

vfleaking 很想知道现在每只鸟的战斗力，但是他当然不会啦，于是他把这个任务交给了你来完成。


## 说明/提示

对于 $100\%$ 的数据，$1≤n≤30000$，$0≤t≤300000$，坐标为整数，均在 $[-2^{31},2^{31})$ 内。

威武值为不超过 $2^{31}-1$ 的非负整数。

## 样例 #1

### 输入

```
5
1 1 1
3 1 2
4 4 4
2 0 1
2 2 3
5
1 1 2
2 4 4
2 4 3
3 0 1
5 0 1```

### 输出

```
3
4
6
8
8```

## 样例 #2

### 输入

```
5
1803632939 1051911108 963670239
296082233 384714041 782958792
1706221977 1051911108 963670239
1890039364 -1429456864 794782986
1152753107 1932597483 1442217530
10
3 -1429456864 794782986
2 -1429456864 794782986
4 -1429456864 794782986
4 2062723523 -411953943
5 -1429456864 794782986
4 1051911108 963670239
4 1051911108 963670239
1 1051911108 963670239
1 1051911108 963670239
5 -1429456864 794782986```

### 输出

```
1890039364
3780078728
3780078728
3607265878
3412443954```

# 题解

## 作者：whx2009 (赞：15)

## 本题思路：
这道题不要看他是紫题，其实很好写。

我们先考虑一种可以支持删除与求最大值和节点数的算法，这里我用的平衡树。我们可以用 map 把坐标离散化，然后针对每一个坐标开一棵平衡树。把每一只鸟作为一个节点，以鸟的标号（输入顺序）建平衡树。这样的好处是可以直接在鸟的节点上记录最大的士气值与团结值。

然后我们知道求的是士气值的最大值与团结值的最大值的乘积，因为二者之间没有联系，我们就可以分开来看。

先看士气值，我们知道士气值是当前位置除了自己以外的最大威武值，这个还是很好维护的，移动时先分裂出当前节点，合并到他去的位置的平衡树上。合并的时候分别把两棵平衡树（可能有节点，我们在这里把节点看成一棵树）的最大值分别打在另一棵的懒标记上，分裂合并时下传更新最大士气值即可。

再来看团结值，这个更简单，直接在合并后再写一个懒标传下去即可（注意减一）。
## 初始赋值：
这里提一下，假设每一只鸟都先在一个互不重复的坐标集上，按照移动到初始位置的方式就和上面一样了。
## 本题代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define ls tr[p].ch[0]
#define rs tr[p].ch[1]
using namespace std;
map<pair<int,int>,int>mp;
int a[30005];
struct f{int ch[2],siz,ma,id,ans1,ans2,add1,add2,rnd;}tr[30005];
void wei1(int p,int k){tr[p].ans1=max(tr[p].ans1,k),tr[p].add1=max(tr[p].add1,k);}
void wei2(int p,int k){tr[p].ans2=max(tr[p].ans2,k),tr[p].add2=max(tr[p].add2,k);}
void wei(int p){
	tr[p].siz=tr[ls].siz+tr[rs].siz+1;
	tr[p].ma=max(a[tr[p].id],tr[ls].ma);
	tr[p].ma=max(tr[rs].ma,tr[p].ma);
}
void chuan(int p){
	if(tr[p].add1){wei1(ls,tr[p].add1),wei1(rs,tr[p].add1);tr[p].add1=0;}
	if(tr[p].add2){wei2(ls,tr[p].add2),wei2(rs,tr[p].add2);tr[p].add2=0;}
}
void split(int p,int &x,int &y,int k){
	if(!p){x=y=0;return;}
	if(tr[p].add1||tr[p].add2) chuan(p);
	if(tr[p].id<=k){x=p;split(rs,rs,y,k);wei(x);}
	else y=p,split(ls,x,ls,k),wei(y);
}
void merge(int &p,int x,int y){
	if(!x||!y){p=x+y;return;}
	if(tr[x].add1||tr[x].add2) chuan(x);
	if(tr[y].add1||tr[y].add2) chuan(y);
	if(tr[x].rnd<=tr[y].rnd) p=x,merge(rs,rs,y);
	else p=y,merge(ls,x,ls);
	wei(p);
}
int root[330005],cnt;
int add(int id){
	tr[++cnt].id=id;tr[cnt].ma=a[id],tr[cnt].siz=1;
	tr[cnt].rnd=rand();return cnt;
}
void merge1(int &x,int y){
	wei1(y,tr[x].ma),wei1(x,tr[y].ma);
	int xx,yy;
	split(x,xx,yy,tr[y].id);
	merge(xx,xx,y);
	merge(x,xx,yy);
	wei2(x,tr[x].siz-1);
}
int top=0;
int u[30005],v[30005];
signed main(){
	int n;cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		int x,y;cin>>x>>y;u[i]=x,v[i]=y;
		if(mp[make_pair(x,y)]==0)mp[make_pair(x,y)]=++top;
		int id=mp[make_pair(x,y)];
		merge1(root[id],add(i));
	}
	int m;cin>>m;
	for(int i=1;i<=m;i++){
		int id,xx,yy;cin>>id>>xx>>yy;
		int nowid=mp[make_pair(u[id],v[id])];
		int x,y,z;
		if(mp[make_pair(xx,yy)]==0) mp[make_pair(xx,yy)]=++top;
		split(root[nowid],x,y,id);split(x,x,z,id-1);merge(root[nowid],x,y);
		merge1(root[mp[make_pair(xx,yy)]],z);u[id]=xx,v[id]=yy;
	}
	for(int i=1;i<=n;i++){
		int nowid=mp[make_pair(u[i],v[i])];
		int x,y,z;
		split(root[nowid],x,y,i);split(x,x,z,i-1);
		merge(root[nowid],x,y);
		cout<<tr[z].ans1*tr[z].ans2<<'\n';
	}
	return 0;
}
```

---

## 作者：yinianxingkong (赞：7)

# [luogu P4200 千山鸟飞绝](https://www.luogu.com.cn/problem/P4200)

## 前言

这题调了我三天啊qwq，基本全靠自己做的（题解看不懂太蒻了\kk），但其实做完感觉并不是很难？

本题解使用 `fhq-treap`，`splay` 党请自行跳过……

## 解法分析

题目意思是给一个平面直角坐标系和一些有权值的点，每个时间点会动一个点，求每个点在每个时间点中对应位置中除了它以外的最大权值，和每个时间点中对应位置中除了它以外的最大点个数的乘积（注意，是**最大值的乘积**）。

首先发现需要支持查询最大值和插入删除，很容易想到平衡树。

然后这个坐标实在是太大，肯定不能直接用，所以要离散化。

而在中间操作时，我们肯定不能暴力更新一个位置的所有点（可以被卡成 $O(n^2)$），这就需要打懒标记（这也是不用 `set` 的原因）。

那么，我们只需要先离线离散化一下，然后写一个权值平衡树进行插入删除查询最值，最后输出答案即可。时间复杂度是离散化加上 `fhq-treap` 复杂度的期望 $O((n+m)log(n+m))$。

## 实现

还是有点细节的……

我采用的方法是平衡树维护一个值和编号的二元组，方便 `split` 出来（这里因为不会新加入节点，可以直接用数组下标代替编号，减少码量）。

标记开两个，分别表示权值和结点数的标记，下传取 $\max$ 即可。

然后开两个答案数组分别存最大权值和最大结点数，这样因为最大值的性质，下传标记时直接对应取 $\max$ 就好了。

这里有一些我犯过的 `SB` 错误：

- 第一，一定要注意算值时不能算自己，所以应该先把原树打上标记再加入结点。

- 第二，`split` 时一定要先判权值，再判编号。

- 第三，`split` 和 `merge` 时都一定要下传标记和向上维护。

- 第四，查找最大值函数一定要判结点存不存在，没有就返回 $0$。

- 第五，最后一定要 `dfs` 一遍，把标记下传完。

- 第六，输出时一定要开 `long long`！

~~可能只有我会犯这些错吧~~

## 代码

效率挺高，有 `fast_io` 时很快：

[记录](https://www.luogu.com.cn/record/141405275)

用普通快读快输时也不错：

[记录](https://www.luogu.com.cn/record/141409555)

哪怕 `scanf+printf` 也稳坐 `rk2`：

[记录](https://www.luogu.com.cn/record/141409868)

代码如下（码风清奇请见谅\kk）：
```cpp
#include<bits/stdc++.h>
//#define int long long
using namespace std;
namespace TYX_YNXK{
	#define il inline
	#define bl bool
	#define ll long long
	#define vd void
	#define N 30005
	#define M 300005
	#define pii pair<int,int>
	#define MP make_pair
	#define fi first
	#define se second 
	#define INF 0x3f3f3f3f
	#define DEBUG cout<<"You are right,but you are wrong"<<'\n'
	#define END cout<<"You are right,but you are right now"<<'\n'
	//以上是 气势磅礴 的宏定义，可以不用 
	int rt[N+M],tl,tm,tr;
	int n,QWQ,m,mx[N][2],val[N],zb[N];
	pii b[N+M],s[N];
	struct que{
		int v,x,y;
	}q[M];
	struct node{
		int son[2],sz,v;
		ll rd;
		int mxw,mxs;
		node(int a1=0,int a2=0,int a3=0,int a4=0,ll a5=0,int a6=0,int a7=0){
			son[0]=a1,son[1]=a2,sz=a3,v=a4,rd=a5,mxw=a6,mxs=a7;
		}
	}t[N];
	il vd pushup(int k){
		t[k].sz=t[t[k].son[0]].sz+1+t[t[k].son[1]].sz;
	}
	il vd change(int k,int a1,int a2){
		if(!k) return;
		mx[k][0]=max(mx[k][0],a1);
		t[k].mxw=max(t[k].mxw,a1);
		mx[k][1]=max(mx[k][1],a2);
		t[k].mxs=max(t[k].mxs,a2);
	}
	//change操作即打标记，一定记住要判k不为0！ 
	il vd pushdown(int k){
		if(!k) return;
		change(t[k].son[0],t[k].mxw,t[k].mxs);
		change(t[k].son[1],t[k].mxw,t[k].mxs);
		t[k].mxw=t[k].mxs=0;
	}
	vd split(int k,int &l,int &r,int v,int pos=INF){
		if(!k) return l=r=0,void(0);
		pushdown(k);
		if((t[k].v==v)?(k<=pos):(t[k].v<v)) l=k,split(t[l].son[1],t[l].son[1],r,v,pos);
		else r=k,split(t[r].son[0],l,t[r].son[0],v,pos);
		pushup(k);
	}
	//split操作在模板基础上多维护了编号信息，但也很好理解 
	int merge(int l,int r){
		if((!l)||(!r)) return l|r;
		if(t[l].rd<=t[r].rd){
			pushdown(l);
			t[l].son[1]=merge(t[l].son[1],r);
			pushup(l);
			return l;
		}
		pushdown(r);
		t[r].son[0]=merge(l,t[r].son[0]);
		pushup(r);
		return r;
	}
	il int find(int v,int k){
		if(!k) return 0;
		while(1){
			if(v==t[t[k].son[0]].sz+1) return t[k].v;
			if(v>t[t[k].son[0]].sz+1) v-=t[t[k].son[0]].sz+1,k=t[k].son[1];
			else k=t[k].son[0];
		}
	}
	//find因为懒得写最大值，所以直接第k小了\kk 
	vd dfs(int k){
		if(!k) return;
		pushdown(k);
		dfs(t[k].son[0]),dfs(t[k].son[1]);
	}
	signed main(){
		srand((unsigned ll)time(NULL));
//		srand(0);
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			int w,x,y;
			scanf("%d%d%d",&w,&x,&y);
			val[i]=w;
			s[i]=MP(x,y);
			b[++m]=MP(x,y);
		}
		scanf("%d",&QWQ);
		for(int i=1;i<=QWQ;i++){
			int v,x,y;
			scanf("%d%d%d",&v,&x,&y);
			q[i]=(que){
				v,x,y
			};
			b[++m]=MP(x,y);
		}
		sort(b+1,b+1+m);
		m=unique(b+1,b+1+m)-b-1;
		for(int i=1;i<=n;i++){
			int p=lower_bound(b+1,b+1+m,s[i])-b;
			zb[i]=p;
			int mx_w=find(t[rt[p]].sz,rt[p]),mx_s=t[rt[p]].sz;
			change(rt[p],val[i],mx_s);
			t[i]=node(0,0,1,val[i],rand());
			change(i,mx_w,mx_s);
			split(rt[p],tl,tr,val[i]);
			rt[p]=merge(tl,merge(i,tr));
		}
		for(int i=1;i<=QWQ;i++){
			int v=q[i].v,p=lower_bound(b+1,b+1+m,MP(q[i].x,q[i].y))-b;
			split(rt[zb[v]],tl,tr,val[v],v);
			split(tl,tl,tm,val[v]-1,v-1);
			rt[zb[v]]=merge(tl,tr);
			t[tm]=node(0,0,1,val[tm],t[tm].rd,0,0);
			zb[v]=p;
			int mx_w=find(t[rt[p]].sz,rt[p]),mx_s=t[rt[p]].sz;
			change(rt[p],val[v],mx_s);
			change(tm,mx_w,mx_s);
			split(rt[p],tl,tr,val[v]);
			rt[p]=merge(tl,merge(tm,tr));
		}
		for(int i=1;i<=m;i++){
			dfs(rt[i]);
		}
		for(int i=1;i<=n;i++){
			printf("%lld\n",1ll*mx[i][0]*mx[i][1]);
		}
		return 0;
	}
}
signed main(){
	TYX_YNXK::main();
	return 0;
}
```

## 后记

欢迎 `hack`！

---

## 作者：tangyigeng (赞：7)

### 简要题意
一个平面直角坐标系中有一些值，维护在同一个坐标的值的最大值和个数最大值。
### 分析
这道题有插入、删除、查找，所以是显然的平衡树。

因为每个坐标的鸟都要维护，所以肯定是二维数组套平衡树（数组的值存每个平衡树的根），注意到数据范围太大了，所以得用 map 存。

一只鸟只有两种操作：离开这个位置，加入到另一个位置。题目要求威武值的最大值和处在同一位置的鸟的只数的最大值，注意到把一只鸟从这个位置删除并不会影响最大值，只有加入会影响最大值，所以只需在加入的时候打个懒标记就行了。

最后输出一下一下最大值与团结值的最大值的乘积。

### 代码
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<random>
#include<map>
#define ls(x) treap[x].lson
#define rs(x) treap[x].rson
using namespace std;
namespace AKIOI{
	const int N = 1e6, inf = 2e9;
	struct node{
		int id, max_w, size, pri, lson, rson, laze_m, laze_u;
	} treap[N + 10];
	struct bird{
		int x, y, w, max_m, max_u;
	} b[N + 10];
	int n, m;
	int cnt;
	map<pair<int, int> , int> Root;
	random_device R;
	mt19937 G(R());
	int rd(int l, int r){
		return uniform_int_distribution<int>(l, r)(G);
	}
	void newnode(int &u, int id){
		u = ++cnt;
		treap[u].id = id;
		treap[u].max_w = b[id].w;
		treap[u].size = 1;
		treap[u].pri = rd(-inf, inf);
	}
	void push_down(int u){
		if(treap[u].laze_m){
			treap[ls(u)].laze_m = max(treap[ls(u)].laze_m, treap[u].laze_m);
			b[treap[ls(u)].id].max_m = max(b[treap[ls(u)].id].max_m, treap[u].laze_m);
			treap[rs(u)].laze_m = max(treap[rs(u)].laze_m, treap[u].laze_m);
			b[treap[rs(u)].id].max_m = max(b[treap[rs(u)].id].max_m, treap[u].laze_m);
			treap[u].laze_m = 0;
		}
		if(treap[u].laze_u){
			treap[ls(u)].laze_u = max(treap[ls(u)].laze_u, treap[u].laze_u);
			b[treap[ls(u)].id].max_u = max(b[treap[ls(u)].id].max_u, treap[u].laze_u);
			treap[rs(u)].laze_u = max(treap[rs(u)].laze_u, treap[u].laze_u);
			b[treap[rs(u)].id].max_u = max(b[treap[rs(u)].id].max_u, treap[u].laze_u);
			treap[u].laze_u = 0;
		}
	}
	void push_up(int u){
		treap[u].size = treap[ls(u)].size + treap[rs(u)].size + 1;
		treap[u].max_w = max(max(treap[ls(u)].max_w, treap[rs(u)].max_w), b[treap[u].id].w);
	}
	void merge(int &u, int root_l, int root_r){
		if(!root_l || !root_r)
			return void(u = root_l | root_r);
		if(treap[root_l].pri >= treap[root_r].pri){
			u = root_l;
			push_down(u);
			merge(rs(root_l), rs(root_l), root_r);
		}
		else{
			u = root_r;
			push_down(u);
			merge(ls(root_r), root_l, ls(root_r));
		}
		push_up(u);
	}
	void split_w(int u, int &root_l, int &root_r, int cri){
		if(!u)
			return void(root_l = root_r = 0);
		push_down(u);
		if(b[treap[u].id].w <= cri){
			root_l = u;
			split_w(rs(root_l), rs(root_l), root_r, cri);
		}
		else{
			root_r = u;
			split_w(ls(root_r), root_l, ls(root_r), cri);
		}
		push_up(u);
	}
	void split_id(int u, int &root_l, int &root_r, int cri){
		if(!u)
			return void(root_l = root_r = 0);
		push_down(u);
		if(treap[u].id <= cri){
			root_l = u;
			split_id(rs(root_l), rs(root_l), root_r, cri);
		}
		else{
			root_r = u;
			split_id(ls(root_r), root_l, ls(root_r), cri);
		}
		push_up(u);
	}
	void ins(int i){
		int rt = Root[make_pair(b[i].x, b[i].y)], w_root_l, w_root_r, w_root_l_l, w_root_l_r, son;
		newnode(son, i);
		b[i].max_m = max(b[i].max_m, treap[rt].max_w);
		treap[rt].laze_m = max(treap[rt].laze_m, b[i].w);
		b[treap[rt].id].max_m = max(b[treap[rt].id].max_m, b[i].w);
		split_w(rt, w_root_l, w_root_r, b[i].w);
		split_w(w_root_l, w_root_l_l, w_root_l_r, b[i].w - 1);
		int id_root_l, id_root_r;
		split_id(w_root_l_r, id_root_l, id_root_r, i - 1);
		merge(id_root_r, son, id_root_r);
		merge(w_root_l_r, id_root_l, id_root_r);
		merge(w_root_l, w_root_l_l, w_root_l_r);
		merge(rt, w_root_l, w_root_r);
		treap[rt].laze_u = max(treap[rt].laze_u, treap[rt].size - 1);
		b[treap[rt].id].max_u = max(b[treap[rt].id].max_u, treap[rt].size - 1);
		Root[make_pair(b[i].x, b[i].y)] = rt;
	}
	void dlt(int i){
		int rt = Root[make_pair(b[i].x, b[i].y)], w_root_l, w_root_r, w_root_l_l, w_root_l_r;
		split_w(rt, w_root_l, w_root_r, b[i].w);
		split_w(w_root_l, w_root_l_l, w_root_l_r, b[i].w - 1);
		int id_root_l, id_root_r, id_root_l_l, id_root_l_r;
		split_id(w_root_l_r, id_root_l, id_root_r, i);
		split_id(id_root_l, id_root_l_l, id_root_l_r, i - 1);
		merge(w_root_l_r, id_root_l_l, id_root_r);
		merge(w_root_l, w_root_l_l, w_root_l_r);
		merge(rt, w_root_l, w_root_r);
		Root[make_pair(b[i].x, b[i].y)] = rt;
	}
	void laze(int u){
		if(!u)
			return;
		push_down(u);
		laze(ls(u));
		laze(rs(u));
	}
	pair<int, int> ans[N << 2];
	int main(){
		scanf("%d", &n);
		for(int i = 1; i <= n; i++){
			int w, x, y;
			scanf("%d%d%d", &w, &x, &y);
			b[i] = (bird){x, y, w};
			ins(i);
		}
		scanf("%d", &m);
		while(m--){
			int v, x, y;
			scanf("%d%d%d", &v, &x, &y);
			dlt(v);
			b[v].x = x, b[v].y = y;
			ins(v);
		}
		for(int i = 1; i <= n; i++)
			ans[i] = make_pair(b[i].x, b[i].y);
		sort(ans + 1, ans + n + 1);
		for(int i = 1; i <= n; i++)
			if(i == 1 || ans[i] != ans[i - 1])
				laze(Root[ans[i]]);
		for(int i = 1; i <= n; i++)
			printf("%lld\n", 1LL * b[i].max_m * b[i].max_u);
		return 0;
	}
}
int main(){
	return AKIOI::main();
}
```


---

## 作者：一E孤行 (赞：6)

~~一道平衡树的好题~~

在普通平衡树的基础上，保存了其他的一些信息：目前最大的鸟数，曾经最大的鸟数（次大值） 目前最大的威武值，曾经最大的威武值（次大值）。

针对每个坐标，我们进行离散化（数字太大了），然后对每个坐标，我们建立一颗平衡树进行维护。每次加入新鸟的时候记得更新次大值和最大值（有点线段树那味了）

AC　Code

```cpp
#include<cstdio>
#include<queue>
#include<algorithm>
#include<cstring>
using namespace std;
#define lc ch[now][0]
#define rc ch[now][1]
const int maxn=3e4+100,maxt=3e5+1000;
int cnt,n,m,sub[maxn];
struct bbb{
    int w,x,y;
    void Insert()
    {
        scanf("%d%d%d",&w,&x,&y);
    }
}a[maxn],q[maxt];
struct aaa{
    int x,y;
    friend bool operator<(aaa a,aaa b)
    {
        return a.x!=b.x?a.x<b.x:a.y<b.y;
    }
    friend bool operator==(aaa a,aaa b)
    {
        return a.x==b.x&&a.y==b.y;
    }
}p[maxt+maxn];
struct Treap{
    int rt[maxt+maxn],ch[maxn][2],fix[maxn],w[maxn],Size[maxn],mx[maxn],mx_Size[maxn],mx_w[maxn],add_w[maxn],add_Size[maxn];
    int New(int np,int v)
    {
        w[np]=mx[np]=v,Size[np]=1;
        fix[np]=rand();
        return np;
    }
    void pushup(int now)
    {
        Size[now]=1;
        if(lc)Size[now]+=Size[lc];
        if(rc)Size[now]+=Size[rc];

        mx[now]=w[now];
        if(lc)mx[now]=max(mx[now],mx[lc]);
        if(rc)mx[now]=max(mx[now],mx[rc]);
    }
    void pushdown(int now)
    {
        mx_Size[lc]=max(mx_Size[lc],add_Size[now]);
        mx_Size[rc]=max(mx_Size[rc],add_Size[now]);
        add_Size[lc]=max(add_Size[lc],add_Size[now]);
        add_Size[rc]=max(add_Size[rc],add_Size[now]);
        add_Size[now]=0;
        mx_w[lc]=max(mx_w[lc],add_w[now]);
        mx_w[rc]=max(mx_w[rc],add_w[now]);
        add_w[lc]=max(add_w[lc],add_w[now]);
        add_w[rc]=max(add_w[rc],add_w[now]);
        add_w[now]=0;
    }
    int merge(int A,int B)
    {
        pushdown(A);pushdown(B);
        if(A*B==0)return A+B;
        if(fix[A]<fix[B])
        {
            ch[A][1]=merge(ch[A][1],B);
            pushup(A);
            return A;
        }
        else
        {
            ch[B][0]=merge(A,ch[B][0]);
            pushup(B);
            return B;
        }
    }
    void split(int now,int v,int &A,int &B)
    {
        pushdown(now);
        if(!now)
        {
            A=B=0;
            return;
        }
        if(v<now)
        {
            B=now;
            split(lc,v,A,lc);
        }
        else
        {
            A=now;
            split(rc,v,rc,B);
        }
        pushup(now);
    }
    int find(int now,int v)
    {
        while(now)
        {
            pushdown(now);
            if(now==v)break;
            now=ch[now][v>now];
        }
        return now;
    }
    void outs()
    {
        for(int i=1;i<=2;i++)
        {
        	printf("%d %d\n",i,Size[i]);
        }
        printf("\n");
    }
}tp;
void add1(int i,int t)
{
    int A,B,C;
    C=tp.New(i,a[i].w);
    if(tp.rt[t])
    {
        tp.mx_w[tp.rt[t]]=max(tp.mx_w[tp.rt[t]] , a[i].w);
        tp.add_w[tp.rt[t]]=max(tp.add_w[tp.rt[t]], a[i].w);
        tp.mx_Size[tp.rt[t]]=max(tp.mx_Size[tp.rt[t]] , tp.Size[tp.rt[t]]);
        tp.add_Size[tp.rt[t]]=max(tp.add_Size[tp.rt[t]], tp.Size[tp.rt[t]]);
        tp.mx_w[i]=max(tp.mx_w[i] , tp.mx[tp.rt[t]]);
        tp.mx_Size[i]=max(tp.mx_Size[i] , tp.Size[tp.rt[t]]);
    }
    tp.split(tp.rt[t],i,A,B);
    tp.rt[t]=tp.merge(tp.merge(A,C),B);
    sub[i]=t;
}
void add2(int i,int t)
{
    int A,B,C;
    tp.split(tp.rt[sub[i]],i-1,A,B);
    tp.split(B,i,C,B);
    tp.rt[sub[i]]=tp.merge(A,B);
    if(tp.rt[t])
    {
        tp.mx_w[tp.rt[t]]=max(tp.mx_w[tp.rt[t]] , a[i].w);
        tp.add_w[tp.rt[t]]=max(tp.add_w[tp.rt[t]], a[i].w);
        tp.mx_Size[tp.rt[t]]=max(tp.mx_Size[tp.rt[t]] , tp.Size[tp.rt[t]]);
        tp.add_Size[tp.rt[t]]=max(tp.add_Size[tp.rt[t]], tp.Size[tp.rt[t]]);
        tp.mx_w[i]=max(tp.mx_w[i] , tp.mx[tp.rt[t]]);
        tp.mx_Size[i]=max(tp.mx_Size[i] , tp.Size[tp.rt[t]]);
    }
    tp.split(tp.rt[t],i,A,B);
    tp.rt[t]=tp.merge(tp.merge(A,i),B);
    sub[i]=t;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
	    a[i].Insert(),p[i].x=a[i].x,p[i].y=a[i].y;
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
	    q[i].Insert(),p[i+n].x=q[i].x,p[i+n].y=q[i].y;
    cnt=n+m;
    sort(p+1,p+cnt+1);
    cnt=unique(p+1,p+cnt+1)-p-1;
    int t;
    for(int i=1;i<=n;i++)
    {
        t=lower_bound(p+1,p+cnt+1,(aaa){a[i].x,a[i].y})-p;
        add1(i,t);
    }
    for(int i=1;i<=m;i++)
    {
        t=lower_bound(p+1,p+cnt+1,(aaa){q[i].x,q[i].y})-p;
        add2(q[i].w,t);
    }
    for(int i=1;i<=n;i++)
    {
        tp.find(tp.rt[sub[i]],i);
        printf("%lld\n",1ll*tp.mx_w[i]*tp.mx_Size[i]);
    }
    return 0;
}
```


---

## 作者：DaydreamWarrior (赞：3)

[也许更好的阅读体验](https://rainlycoris.github.io/#/post/23)

## 分析

首先对于每个坐标开一颗平衡树，要维护的东西需要全局取 max，但是自己不能取。

士气值和团结值在一个点没加进去之前是好算的，直接是坐标内部的点威武值的最大值和点的个数。

然后就是要更新坐标上的所有点，先给平衡树的根节点打上标记，打完之后再把点加进去。

现在这个点的标记就不会打在自己身上了。

## 代码

```cpp
const int N = 30005,M = 330005;
__gnu_pbds::gp_hash_table<ull,int> ha;
int anss[N],anst[N];
multiset<int> st[M];
int w[N],p[N];
int n;

namespace FHQtreap{
    mt19937 myrand(233);
    class fhqtreap{
        private:
            class tree{
                public:
                    int val,l,r;
                    unsigned int pri;
                    int tags,tagt;
            }tr[N];

            vector<int> pool;
            int idx;
            int create(int val_){
                int u = -1;
                if(pool.empty())
                    u = ++idx;
                else{
                    u = pool.back();
                    pool.pop_back();
                }
                tr[u] = {val_,0,0,(unsigned int)myrand(),0,0};
                return u;
            }
            void recycle(const int &u){pool.push_back(u);}

            void pushdown(int u){
                anss[tr[tr[u].l].val] = max(anss[tr[tr[u].l].val],tr[u].tags);
                anst[tr[tr[u].l].val] = max(anst[tr[tr[u].l].val],tr[u].tagt);
                anss[tr[tr[u].r].val] = max(anss[tr[tr[u].r].val],tr[u].tags);
                anst[tr[tr[u].r].val] = max(anst[tr[tr[u].r].val],tr[u].tagt);
                tr[tr[u].l].tags = max(tr[tr[u].l].tags,tr[u].tags);
                tr[tr[u].l].tagt = max(tr[tr[u].l].tagt,tr[u].tagt);
                tr[tr[u].r].tags = max(tr[tr[u].r].tags,tr[u].tags);
                tr[tr[u].r].tagt = max(tr[tr[u].r].tagt,tr[u].tagt);
                tr[u].tags = tr[u].tagt = 0;
            }
            int root[M];
        public:
            int& operator [] (const int &x){return root[x];}
            void split(int u,int c,int &x,int &y){
                if(!u){
                    x = y = 0;
                    return;
                }
                pushdown(u);
                if(tr[u].val<=c){
                    x = u;
                    split(tr[u].r,c,tr[u].r,y);
                }
                else{
                    y = u;
                    split(tr[u].l,c,x,tr[u].l);
                }
            }
            int merge(int x,int y){
                if(!x||!y)
                    return x|y;
                if(tr[x].pri>tr[y].pri){
                    pushdown(x);
                    tr[x].r = merge(tr[x].r,y);
                    return x;
                }
                pushdown(y);
                tr[y].l = merge(x,tr[y].l);
                return y;
            }
            void insert(int r,int c){
                int x,y;
                split(root[r],c,x,y);
                root[r] = merge(merge(x,create(c)),y);
            }
            void erase(int r,int c){
                int x,y,z;
                split(root[r],c-1,x,y);
                split(y,c,y,z);
                if(y){
                    recycle(y);
                    y = merge(tr[y].l,tr[y].r);
                }
                root[r] = merge(merge(x,y),z);
            }
            void tag(int x,int s,int t){
                if(!x)
                    return;
                pushdown(x);
                anss[tr[x].val] = max(anss[tr[x].val],s);
                anst[tr[x].val] = max(anst[tr[x].val],t);
                tr[x].tags = max(tr[x].tags,s);
                tr[x].tagt = max(tr[x].tagt,t);
            }
            void down(int x){
                if(!x)
                    return;
                pushdown(x);
                down(tr[x].l);
                down(tr[x].r);
            }
    };
}
FHQtreap::fhqtreap tr;

int h(int x,int y){
    ull w = (((1ull<<31)+x)<<32)+((1ull<<31)+y);
    if(!ha[w])
        ha[w] = ha.size();
    return ha[w];
}

void insert(int x){
    if(!st[p[x]].empty())
        anss[x] = max(anss[x],*prev(st[p[x]].end()));
    anst[x] = max({anst[x],(int)st[p[x]].size()});
    tr.tag(tr[p[x]],w[x],(int)st[p[x]].size());
    tr.insert(p[x],x);
    st[p[x]].insert(w[x]);
}

void move(int x,int np){
    tr.erase(p[x],x);
    st[p[x]].erase(st[p[x]].find(w[x]));
    p[x] = np;
    insert(x);
}

signed main(){
    n = in();
    for(int k=1;k<=n;k++){
        w[k] = in();
        int x = in(),y = in();
        p[k] = h(x,y);
        insert(k);
    }
    int t = in();
    while(t--){
        int v = in(),x = in(),y = in();
        move(v,h(x,y));
    }
    for(int k=ha.size();k;k--)
        tr.down(tr[k]);
    for(int k=1;k<=n;k++)
        out(1ll*anss[k]*anst[k],'\n');
    return 0;
}
```

## 后话

至少 2023.04.17 我还是最优解。

---

## 作者：Melancholy_ (赞：3)

[在博客食用更佳](https://blog.csdn.net/weixin_50624971/article/details/121027071)

题目十分阴间……

是一道练习平衡树的好题。

我们可以看到题目描述得天花乱坠，其实只需要对于每只鸟所在的坐标维护一颗 `splay` 就好了。

注意是对每只鸟所在的坐标，不是每个坐标。

我们需要维护的信息是最大团结值和 $siz$ 和最大威武值和 $val$。

为此需要维护两个懒标记，一个记录 $siz$，一个记录 $val$。

然后在 `splay` 的过程中下传标记维护即可。

数据范围过大，所以需要用 `map` 来存坐标。

还有一处小细节，就是 `rotate` 的时候最后更新 $x$,$y$ 节点信息的时候一定要先更新 $y$ ！！！

因为此时 $y$ 已经变成 $x$ 的儿子，显然要先更新儿子……

~~我之前一直先更新的 $x$……~~

~~可能是普通平衡树模板数据水了吧~~  


```cpp
#include<bits/stdc++.h>
#define ll long long
#define pii pair<int,int>
#define mp make_pair
using namespace std;
const int maxn=3e5+5;
int siz[maxn],f[maxn],son[maxn][2],val[maxn],tot_size,root[maxn],a[maxn];
int laz1[maxn],laz2[maxn],ans1[maxn],ans2[maxn],q[maxn],num,w[maxn];
map<pii,int>vis;
inline ll read()
{
	ll ret=0;char son=' ',c=getchar();
	while(!(c<='9'&&c>='0')) son=c,c=getchar();
	while(c<='9'&&c>='0') ret=(ret<<1)+(ret<<3)+c-'0',c=getchar();
	return son=='-'?-ret:ret;
}
int get(int x) {return x==son[f[x]][1];}
void clear(int x) {son[x][1]=son[x][0]=siz[x]=f[x]=val[x]=laz1[x]=laz2[x]=0;}
void update(int x)
{
	siz[x]=siz[son[x][1]]+siz[son[x][0]]+1;
	val[x]=max(max(val[son[x][1]],val[son[x][0]]),w[x]);
}
void rotate(int x)
{
	int y=f[x],z=f[y],type=get(x);
	son[y][type]=son[x][type^1];
	f[son[x][type^1]]=y;
	son[x][type^1]=y;
	f[y]=x,f[x]=z;
	if(z) son[z][y==son[z][1]]=x;
	update(y);update(x);
}
void pushdown(int x)
{
	int k1=laz1[x],k2=laz2[x];
	for(int i=0;i<=1;i++)
	{
		if(son[x][i])
		{
			int j=son[x][i];
			ans1[j]=max(ans1[j],k1);
            ans2[j]=max(ans2[j],k2);
            laz1[j]=max(laz1[j],k1);
            laz2[j]=max(laz2[j],k2);
		}
	}
	laz1[x]=laz2[x]=0;
}
void splay(int x,int &rt)
{
	int top=0;
	for(int fa=x;fa;fa=f[fa]) q[++top]=fa;
    while(top) pushdown(q[top--]);
	for(int fa;fa=f[x];rotate(x)) if(f[fa]) rotate(get(fa)==get(x)?fa:x);
	rt=x;
}
int find_pre(int p)
{
	int now=son[root[p]][0];
    while(son[now][1]) now=son[now][1];
    return now;
}
void del(int p,int x)
{
	splay(x,root[p]);
    int now=root[p];
    if(!son[now][0]&&!son[now][1])
    {
        clear(now);
        root[p]=0;
        return;
    }
    for(int i=0;i<=1;i++)
    {
    	if(!son[now][i])
    	{
	        root[p]=son[now][i^1];
	        f[root[p]]=0;
	        clear(now);
	        return;
    	}
    }
    x=find_pre(p);
    splay(x,root[p]);
    f[son[now][1]]=x;
    son[x][1]=son[now][1];
    clear(now);
    update(root[p]);
}
void insert(int &p,int x,int fa)
{
    if(!p)
    {
        p=x,f[p]=fa,val[p]=w[p],siz[p]=1;
        return;
    }
    pushdown(p);
    if(!son[p][0]) insert(son[p][0],x,p);
    else insert(son[p][1],x,p);
}
int main()
{
	int n=read();
	for(int i=1;i<=n;i++)
	{
		w[i]=read();
		int x=read(),y=read();
		if(!vis.count(mp(x,y))) vis[mp(x,y)]=++num;
        int k=vis[mp(x,y)];
        a[i]=k;
        ans1[i]=max(ans1[i],val[root[k]]);
        ans2[i]=max(ans2[i],siz[root[k]]);
        insert(root[k],i,0);
        splay(i,root[k]);
        laz1[root[k]]=max(laz1[root[k]],w[i]);
        laz2[root[k]]=max(laz2[root[k]],siz[root[k]]-1);
	}
	int t=read();
	while(t--)
	{
		int i=read(),x=read(),y=read();
		if(!vis.count(mp(x,y))) vis[mp(x,y)]=++num;
        int k=vis[mp(x,y)],pre=a[i];
        a[i]=k;
        del(pre,i);
        ans1[i]=max(ans1[i],val[root[k]]);
        ans2[i]=max(ans2[i],siz[root[k]]);
        insert(root[k],i,0);
        splay(i,root[k]);
        laz1[root[k]]=max(laz1[root[k]],w[i]);
        laz2[root[k]]=max(laz2[root[k]],siz[root[k]]-1);
	}
	for(int i=1;i<=n;i++)
	{
		splay(i,root[a[i]]);
		printf("%lld\n",1ll*ans1[i]*ans2[i]);
	}
	return 0;
}
```


---

## 作者：kkksc03wzl (赞：2)

## 前言 ##
下面的题解介绍了如何通过 STL+O2 优化水过本题，如果您想学习正经算法，请划走。。


# 进入正题 #

## STEP0 题意重现 ##
本题要求维护出每一只鸟从第 $0$ 到 $t$ 时刻所经过的坐标的中，**其他鸟** 的数量的最大值以及 **其他鸟** 中威武值的最大值。

## STEP1 基本想法 ##
题目中的坐标范围很大，可以很自然地想到把坐标离散化。我们把输入中出现的坐标离线下来，以 $x$ 坐标为第一关键字，$y$ 坐标为第二关键字，排序后给每个坐标一个编号。

因为每个坐标可能有多只鸟，还要支持实时插入和删除，我们能想到对于每一个坐标维护一个以 bird 为类型的 set。同时，用 set 维护还有一个好处，我们可以很方便地取出每一只鸟除自己外的最大威武值。

于是我们有了一个初步的思路：首先，把坐标离散化；然后把每一只鸟的初始信息（包括坐标编号，威武值）打个包扔进 set 里；接着对于每一个坐标上，把其所有鸟的答案初始化；最后进行 $q$ 次命令，对于第 $i$ 次命令，更新一下对应鸟的坐标编号，把它插入 set 里，更新它所在坐标里的鸟的答案。


## STEP2 注意&卡常小优化 ##
	
 1、bird 类型里的重载运算符要注意不仅仅对 $w$ 排序，同时也要对它作为一只鸟的编号进行排序，这样才能保证使用 set 时能够唯一确定每一只鸟。
 
 2、在进行 $q$ 次命令时，如果直接每一次暴力更新，吸氧气也会 TLE。其实如果数据保证随机，就已经过了。但是出题人有意要卡死我们。所以我们考虑在什么情况下会被卡炸。显然，如果把一直往同一个坐标位置放鸟，我们又暴力更新，最坏就退化成 $O(qn)$ 了。所以我们给他加一个特判，在某些情况下其实不更新，等到必须更新时一起更新就可以。（类似于线段树懒标记的思想）显然，如果下一次没有把鸟往当前位置上移动，或者说下一次要移动当前位置的鸟，又或者当前是最后一次命令，我们就不得不更新了。因为以上几种情况都有可能因为没及时更新答案而导致答案变更劣。
 
 ## STEP3 CODE ##
 ```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<set>
using namespace std;
struct node{
	int x,y;
	bool operator<(const node t)const{return x==t.x?y<t.y:x<t.x;}
	bool operator==(const node t)const{return x==t.x&&y==t.y;}// 后面使用了unique，但是好像不用去重也行 
}nod[330005];
struct bird{
	int id,w,bid;// id为鸟离散化后的坐标编号，w为威武值，bid为它作为一只鸟的编号 
	node t;// 鸟的坐标 
	bool operator<(const bird t)const{return w!=t.w?w<t.w:bid<t.bid;}// 两个维度，唯一确定一只鸟 
}a[30005];
struct A{int mx_tj=0,mx_sq=0;}ans[30005];// 答案 
struct query{
	int u;// 命令的鸟的编号 
	node t;// 命令到达的坐标 
}ask[300005];
int tot;
set<bird>st[330005];
void update(int i){//更新编号为 i 的坐标 
	if(st[i].size()<=1){return;} // 如果坐标上鸟的个数小于两个，无需更新 
	set<bird>::iterator it=st[i].begin(),it2=st[i].end();
	it2--;int tmp=st[i].size()-1;
	for(; it!=st[i].end(); it++){
		ans[it->bid].mx_tj=max(ans[it->bid].mx_tj,tmp);
		if(it!=it2)ans[it->bid].mx_sq=max(it2->w,ans[it->bid].mx_sq);// 如果最大值不是自己，那就直接用最大值更新 
		else it2--,ans[it->bid].mx_sq=max(it2->w,ans[it->bid].mx_sq);// 否则用不严格次大值更新
	}
}
int main(){
	// 离散化 & 输入 
	int n,q;
	scanf("%d",&n);
	for(int i=1; i<=n; i++){
		scanf("%d%d%d",&a[i].w,&a[i].t.x,&a[i].t.y);
		a[i].bid=i;
		nod[++tot]=a[i].t;
	}
	scanf("%d",&q);
	for(int i=1; i<=q; i++){
		scanf("%d%d%d",&ask[i].u,&ask[i].t.x,&ask[i].t.y);
		nod[++tot]=ask[i].t;
	}
	sort(nod+1,nod+1+tot);
	tot=unique(nod+1,nod+1+tot)-nod-1;
	
	
	//初始化 
	for(int i=1; i<=n; i++){
		a[i].id=lower_bound(nod+1,nod+1+tot,a[i].t)-nod;
		st[a[i].id].insert(a[i]);
	}
	for(int i=1; i<=tot; i++)update(i);
	
	//模拟每一次命令 
	for(int i=1; i<=q; i++){
		int id=lower_bound(nod+1,nod+1+tot,ask[i].t)-nod;
		if(id==a[ask[i].u].id){continue;}
		st[a[ask[i].u].id].erase(a[ask[i].u]);
		
		//更新鸟 
		a[ask[i].u].id=id;
		a[ask[i].u].t=ask[i].t;
		
		
		st[id].insert(a[ask[i].u]);
		
		//卡常小优化 
		if(i==q)update(id);
		else{
			int idd=lower_bound(nod+1,nod+1+tot,ask[i+1].t)-nod;
			if(id!=idd||a[ask[i+1].u].id==id)update(id);
		}
		
	}for(int i=1; i<=n; i++)printf("%lld\n",ans[i].mx_sq*1ll*ans[i].mx_tj);
	return 0;
} 
```


---

## 作者：OIer_ACMer (赞：2)

~~早起的鸟儿有虫吃，早上山的人类被鸟揍。~~

------------
## 警钟敲烂：
这道题不要以为十分简单就轻视因为，鸟儿不是好惹的（在计算威力值时会炸空间）！！！

------------
## 大致思路：
首先，这道题由于涉及到了两种值：威力值和团结值，所以我们要开个 pair 类型的 map 数组 $mp$，第一个表示这个点的坐标，第二个则表示目前这个点的编号。

之后，我们要在输入的同时计算这个坐标有多少只鸟在这里守候，如果没有，则新建一个点，否则比较最大的威力值并统计团结值（也就是这个点鸟的数量）。接着，我们就要考虑一下**怎么构建平衡树**？由于我们已经知道每只鸟的坐标时时刻刻都在发生变化，所以我们不如就把每只鸟所在的坐标维护一颗 splay 树就好了。因此，我们就可以在统计完各只鸟坐标的情况后就直接进行插入操作，将这个点的情况插入到 splay 树中，并进行相应的翻转操作。

至于 $\operatorname{rotate}$ 函数和 $\operatorname{get},\operatorname{get}$ 之类的模板函数我就不再讲，至于 $\operatorname{pushdown}$ 函数，懂得都懂，就跟线段树一个方法，将 $ans1$ 数组和 $ans2$ 数组中的值直接通过 $lazy$ 懒标记下传或上传上去就可以了。

最终，经过不断的翻转、删除、新建等操作，我们会得到每只鸟的威力值与团结值，之后的操作就很简单，循环输出 $ans1$ 与 $ans2$ 数组各个位置的乘积就可以了，不过要注注，在输出之前我们还要再翻转一次，因为有时到了最后平
衡树并不平衡，所以多多翻转百利而无一害。还有一处小细节，就是 $\operatorname{rotate}$ 的时候最后更新 $x,y$ 节点信息的时候**一定要先更新** $y$！！！因为此时 $y$ 已经变成 $x$ 的儿子（因为翻转了嘛），显然要先更新儿子。

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 3e5 + 5;
int siz[maxn], f[maxn], son[maxn][2], val[maxn], tot_size, root[maxn], a[maxn];
int laz1[maxn], laz2[maxn], ans1[maxn], ans2[maxn], q[maxn], num, w[maxn];
map<pair<int, int>, int> mp;
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
int get(int x)
{
    return x == son[f[x]][1];
}
void clear(int x)
{
    son[x][1] = son[x][0] = siz[x] = f[x] = val[x] = laz1[x] = laz2[x] = 0;
}
void update(int x)
{
    siz[x] = siz[son[x][1]] + siz[son[x][0]] + 1;
    val[x] = max(max(val[son[x][1]], val[son[x][0]]), w[x]);
}
void rotate(int x)
{
    int y = f[x], z = f[y], type = get(x);
    son[y][type] = son[x][type ^ 1];
    f[son[x][type ^ 1]] = y;
    son[x][type ^ 1] = y;
    f[y] = x, f[x] = z;
    if (z)
    {
        son[z][y == son[z][1]] = x;
    }
    update(y);
    update(x);
}
void pushdown(int x)
{
    int k1 = laz1[x], k2 = laz2[x];
    for (int i = 0; i <= 1; i++)
    {
        if (son[x][i])
        {
            int j = son[x][i];
            ans1[j] = max(ans1[j], k1);
            ans2[j] = max(ans2[j], k2);
            laz1[j] = max(laz1[j], k1);
            laz2[j] = max(laz2[j], k2);
        }
    }
    laz1[x] = laz2[x] = 0;
}
void splay(int x, int &root)
{
    int top = 0;
    for (int fa = x; fa; fa = f[fa])
    {
        q[++top] = fa;
    }
    while (top)
    {
        pushdown(q[top--]);
    }
    for (int fa; fa = f[x]; rotate(x))
    {
        if (f[fa])
        {
            rotate(get(fa) == get(x) ? fa : x);
        }
    }
    root = x;
}
int find_pre(int p)
{
    int now = son[root[p]][0];
    while (son[now][1])
    {
        now = son[now][1];
    }
    return now;
}
void del(int p, int x)
{
    splay(x, root[p]);
    int now = root[p];
    if (!son[now][0] && !son[now][1])
    {
        clear(now);
        root[p] = 0;
        return;
    }
    for (int i = 0; i <= 1; i++)
    {
        if (!son[now][i])
        {
            root[p] = son[now][i ^ 1];
            f[root[p]] = 0;
            clear(now);
            return;
        }
    }
    x = find_pre(p);
    splay(x, root[p]);
    f[son[now][1]] = x;
    son[x][1] = son[now][1];
    clear(now);
    update(root[p]);
}
void insert(int &p, int x, int fa)
{
    if (!p)
    {
        p = x, f[p] = fa, val[p] = w[p], siz[p] = 1;
        return;
    }
    pushdown(p);
    if (!son[p][0])
    {
        insert(son[p][0], x, p);
    }
    else
    {
        insert(son[p][1], x, p);
    }
}
int main()
{
    int n = read();
    for (int i = 1; i <= n; i++)
    {
        w[i] = read();
        int x = read(), y = read();
        if (!mp.count(make_pair(x, y)))
        {
            mp[make_pair(x, y)] = ++num;
        }
        int k = mp[make_pair(x, y)];
        a[i] = k;
        ans1[i] = max(ans1[i], val[root[k]]);
        ans2[i] = max(ans2[i], siz[root[k]]);
        insert(root[k], i, 0);
        splay(i, root[k]);
        laz1[root[k]] = max(laz1[root[k]], w[i]);
        laz2[root[k]] = max(laz2[root[k]], siz[root[k]] - 1);
    }
    int q;
    q = read();
    while (q--)
    {
        int i = read(), x = read(), y = read();
        if (!mp.count(make_pair(x, y)))
        {
            mp[make_pair(x, y)] = ++num;
        }
        int k = mp[make_pair(x, y)], pre = a[i];
        a[i] = k;
        del(pre, i);
        ans1[i] = max(ans1[i], val[root[k]]);
        ans2[i] = max(ans2[i], siz[root[k]]);
        insert(root[k], i, 0);
        splay(i, root[k]);
        laz1[root[k]] = max(laz1[root[k]], w[i]);
        laz2[root[k]] = max(laz2[root[k]], siz[root[k]] - 1);
    }
    for (int i = 1; i <= n; i++)
    {
        splay(i, root[a[i]]);
        cout << 1ll * ans1[i] * ans2[i] << endl;
    }
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/121916435)

---

## 作者：FreeTimeLove (赞：2)

## 一、题意

给定二维平面上的 $n$ 个带权点，每一时刻改变一个点的坐标，最后问对于**每一个**点，在**每一时刻内**与其坐标相同的**其他**点的**个数的最大值** $a$ 和**权值最大值的最大值** $b$ 之**积**。

## 二、思路

读题可以发现有点的**坐标**个数是 $\mathrm O(n)$ 的，考虑对每个有点的坐标建一棵平衡树维护此坐标上点的**编号**与**权值**及每个点**在此坐标上**的 $a$ 与 $b$，用 map 存储坐标与平衡树编号之间的映射。那么改变点的坐标可以拆分为一次删除加一次插入。

维护一个点的 $a$，即维护自**插入此点以来**平衡树**大小**的最大值**减一**；维护 $b$，即维护自**插入此点以来**平衡树上除此点外权值的最大值。由于一个点可能成为一棵平衡树内**权值最大**的点，因此我们维护自**插入此点以来**平衡树最大值的最大值、最大值的个数与严格次大值的最大值。

插入一个点时，为了不让插入此点**之前**的最优状态影响此节点及之后的答案，我们求出平衡树当前的最大值及其个数、次大值与大小，对整棵平衡树打上懒标记，相当于整体更新**此坐标**所有点的答案；在删除一个节点前，我们查询此节点**在此坐标**的答案，并更新此点最终的答案。

注意最后需要再查询一遍每个节点在**对应坐标**的答案。

### AC code

```cpp
//written_by_FTL
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<vector>
#include<map>
#define ll long long
#define LD long double
#define i7 __int128
#define re return
#define con continue
using namespace std;
const int N=30005;
int rd(){
	int ans=0,f=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')f^=(ch=='-'),ch=getchar();
	while(ch>='0'&&ch<='9')ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();
	re f?-ans:ans;
}
int n,m,a[N],u,x,y,num;
ll maxn[N][2],INF=0x3f3f3f3f3f3f3f3f;
struct xxs{//坐标
	int x,y;
	bool operator <(const xxs &a)const{
		if(x==a.x)re y<a.y;
		re x<a.x;
	}
}p[30005];
map<xxs,int>mp;
struct node{
	int mx,ms,sc,s;
}ans,zz={0,0,0,0};
node mg(node a,node b){
	node c;
	if(a.mx>b.mx)c.mx=a.mx,c.ms=a.ms;
	else if(a.mx<b.mx)c.mx=b.mx,c.ms=b.ms;
	else c.mx=a.mx,c.ms=a.ms>b.ms?a.ms:b.ms;
	c.sc=a.sc>b.sc?a.sc:b.sc;
	c.s=a.s>b.s?a.s:b.s;
	re c;
}
struct bird{//点的值与编号
	ll w;int n;
	bool operator <(const bird &x)const{
		if(w==x.w)re n<x.n;
		re w<x.w;
	}
};
namespace SPT{
	#define t d[v]
	#define tx d[vx]
	#define vf t.f
	#define vl t.c[b]
	#define vr t.c[b^1]
	#define tf d[vf]
	#define tl d[vl]
	#define tr d[vr]
	#define z lz[v]
	#define zl lz[vl]
	#define zr lz[vr]
	#define rt d[i-1].c[1]
	int num=330000,x[2],b=0;
	struct data{
		int c[2]={0},s=0,f;bird w;node al=zz;
	}d[1330000];
	struct lazy{
		node m=zz;
	}lz[1330000];
	int nw(bird k){
		int v=++num;
		t.s=1,t.w=k,t.al={0,0,0,0};re v;
	}
	int gt(int v){re v==tf.c[1];}
	void pu(int v){t.s=tl.s+tr.s+1;}
	void cn(int v,int vx,int b){vl=vx,tx.f=v;}
	void ro(int v){
		int b=gt(v),f=vf;
		cn(f,vr,b),cn(tf.f,v,gt(f)),cn(v,f,b^1);
		pu(f);
	}
	void pd(int v){
		if(z.m.mx||z.m.ms||z.m.sc||z.m.s){
			zl.m=mg(z.m,zl.m),zr.m=mg(z.m,zr.m);
			t.al=mg(z.m,t.al),z.m=zz;
		}
	}
	void sp(int v,int p){
		while(vf!=p){
			if(tf.f!=p)ro(gt(vf)==gt(v)?vf:v);
			ro(v);
		}pu(v);
	}
	bool sk(bird k,int i){//查询非严格前驱和严格后继
		x[0]=x[1]=0;
		int v=rt,b;
		while(v)pd(v),b=k<t.w,x[b]=v,v=vr;
		re d[x[0]].c[1];
	}
	bird kth(int k,int i){
		int v=rt;
		while(k!=tl.s){
			if(k<tl.s)v=vl;
			else k-=tl.s+1,v=vr;
		}
		re t.w;
	}
	int rk(bird k,int i){
		int v=rt,ans=0;
		while(v&&(k.w!=t.w.w||k.n!=t.w.n)){
			if(k<t.w)v=vl;
			else ans+=tl.s+1,v=vr;
		}
		re ans+tl.s;
	}
	void ins(int i,bird k){
		int b=sk(k,i),v=nw(k);
		cn(x[b],v,b^1),sp(v,i-1);
		node tmp;
		tmp.s=d[rt].s-3;
		tmp.mx=kth(tmp.s+1,i).w;
		tmp.ms=tmp.s+1-(rk({tmp.mx,0},i)-1);
		tmp.sc=kth(tmp.s+1-tmp.ms,i).w;
		lz[rt].m=mg(lz[rt].m,tmp);
	}
	void del(int i,bird k){	
		int b=sk(k,i),v=x[b];
		if(b)d[x[0]].w=d[x[1]].w,d[x[0]].al=d[x[1]].al;
		cn(vf,vl,gt(v));sp(vf,i-1);
	}
	node qry(int i,bird k){
		sk(k,i);
		re d[x[0]].al;
	}
	void init(int i){
		rt=nw({-1,0});
		int v=rt;
		vf=i-1;
		cn(v,nw({INF,0}),1);
	}
	#undef t
}
int main(){
	n=rd();
	for(int i=1;i<=n;i++){
		a[i]=rd(),x=rd(),y=rd();
		p[i]={x,y};
		if(mp.find(p[i])==mp.end())mp[p[i]]=++num,SPT::init(num);
		SPT::ins(mp[p[i]],{a[i],i});
	}
	m=rd();
	for(int i=1;i<=m;i++){
		u=rd(),x=rd(),y=rd();
		int tmp=mp[p[u]];
		ans=SPT::qry(tmp,{a[u],u}); 
		maxn[u][0]=max(maxn[u][0],(ll)ans.s);
		if(a[u]==ans.mx&&ans.ms==1)maxn[u][1]=max(maxn[u][1],(ll)ans.sc);
		else maxn[u][1]=max(maxn[u][1],(ll)ans.mx);
		SPT::del(tmp,{a[u],u});
		p[u]={x,y};
		if(mp.find(p[u])==mp.end())mp[p[u]]=++num,SPT::init(num);
		SPT::ins(mp[p[u]],{a[u],u});
	} 
	for(int i=1;i<=n;i++){
		ans=SPT::qry(mp[p[i]],{a[i],i});
		maxn[i][0]=max(maxn[i][0],(ll)ans.s);
		if(a[i]==ans.mx&&ans.ms==1)maxn[i][1]=max(maxn[i][1],(ll)ans.sc);
		else maxn[i][1]=max(maxn[i][1],(ll)ans.mx);
		printf("%lld\n",maxn[i][0]*maxn[i][1]);
	}
	re 0;
}
```

### $\text{The End.}$

---

## 作者：kkxacj (赞：1)

#### 前言

此题解写的为 `FHQ` 平衡树，并且默认读者已经能够完成模板题，对 `FHQ` 平衡树有一定的理解。

[P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)

[P3369 【模板】普通平衡树 FHQ 题解 ](https://www.luogu.com.cn/article/06dba236)

#### 思路

首先很显然的是先离散化所有输入给出的位置，这样**方便储存**。

其次根据题目，我们需要动态维护离散化后位置 $x$ 里的最大值和点的个数。每次移动等同于一次删点和加点，容易想到平衡树维护。

先考虑加点的情况，注意题面所说**计算士气值和团结值时不能算上自己**，所以在加入前就给加入的位置打上标记，分别是这个点的权值和这个位置的点的个数，注意**不算上自己**，自己的初始最大值就赋为位置里的点的最大权值，最大点个数就为这个位置的点的个数，为了方便查找第 $i$ 个点以方便之后的删除，我们直接**以下标建平衡树**。

至于标记下传，只要在**每次删除前，合并前都下传**，就不会遇到传输错误问题了。

对于删除，我们先对删除的这个点求最大士气值和团结值，然后删除掉，加入新的位置就行了。

移动结束后，将每个点删除然后求最大士气值和团结值，最后输出就行了。

**code**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define getchar() (p1 == p2 && (p2 = (p1 = buf1) + fread(buf1, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf1[1 << 23], *p1 = buf1, *p2 = buf1, ubuf[1 << 23], *u = ubuf;
namespace IO
{
	template<typename T>
	void read(T &_x){_x=0;int _f=1;char ch=getchar();while(!isdigit(ch)) _f=(ch=='-'?-1:_f),ch=getchar();while(isdigit(ch)) _x=_x*10+(ch^48),ch=getchar();_x*=_f;}
	template<typename T,typename... Args>
	void read(T &_x,Args&...others){Read(_x);Read(others...);}
	const int BUF=20000000;char buf[BUF],to,stk[32];int plen;
	#define pc(x) buf[plen++]=x
	#define flush(); fwrite(buf,1,plen,stdout),plen=0;
	template<typename T>inline void print(T x){if(!x){pc(48);return;}if(x<0) x=-x,pc('-');for(;x;x/=10) stk[++to]=48+x%10;while(to) pc(stk[to--]);}
}
using namespace IO;
const int N = 6e5+10;
int n,t,z,x,y,f[N],a[N],v[N],root[N],ans[N],ans1[N],cnt,fl,fr,fz,o,o1,o2;
int sum[N],sum1[N];
map<pair<int,int>,int>mp;
struct w
{
	int w,x;
}c[N];
struct w1
{
	int siz,l,r,key,val;
	int ad,ad1;
	//ad为最大士气值标记，ad1为最大团结值标记
	int mx,mx1,mx2,mx3;//标记下传喵 
	//mx为最大士气值,mx1为最大团结值,mx3为点权,mx2为子树最大点权 
}b[N<<1];
inline int insert(int z,int x,int y){b[++cnt].siz = 1,b[cnt].key = rand(),b[cnt].mx3 = b[cnt].mx2 = c[z].w,b[cnt].val = z,b[cnt].mx = x,b[cnt].mx1 = y; return cnt;}
//新建一个点，附上一些初值 
inline void push_up(int p){b[p].siz = b[b[p].l].siz+b[b[p].r].siz+1; b[p].mx2 = max(b[p].mx3,max(b[b[p].l].mx2,b[b[p].r].mx2));}
inline void push(int p)//标记下传 
{
	b[b[p].l].mx = max(b[b[p].l].mx,b[p].ad),b[b[p].r].mx = max(b[b[p].r].mx,b[p].ad);
	b[b[p].l].mx1 = max(b[b[p].l].mx1,b[p].ad1),b[b[p].r].mx1 = max(b[b[p].r].mx1,b[p].ad1);
	b[b[p].l].ad = max(b[b[p].l].ad,b[p].ad),b[b[p].r].ad = max(b[b[p].r].ad,b[p].ad);
	b[b[p].l].ad1 = max(b[b[p].l].ad1,b[p].ad1),b[b[p].r].ad1 = max(b[b[p].r].ad1,b[p].ad1);
	b[p].ad = b[p].ad1 = 0;
}
void spilt(int p,int &l,int &r,int v)
{
	if(!p)
	{
		l = r = 0;
		return;
	}
	push(p); 
	if(b[p].val <= v)
	{
		l = p; spilt(b[p].r,b[p].r,r,v);
		push_up(l);
		return; 
	}
	else 
	{
		r = p; spilt(b[p].l,l,b[p].l,v);
		push_up(r);
		return; 
	}
}
int merge(int l,int r)//直接默认b[l].val <= b[r].val 
{
	if(!l || !r) return l+r;
	if(b[l].key <= b[r].key)
	{
		push(l); 
		b[l].r = merge(b[l].r,r);
		push_up(l);
		return l;
	} 
	else
	{
		push(r); 
		b[r].l = merge(l,b[r].l);
		push_up(r);
		return r;
	}
}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n); srand(time(0));
	for(int i = 1;i <= n;i++) 
	{
		read(c[i].w),read(x),read(y);
		if(!mp[make_pair(x,y)]) mp[make_pair(x,y)] = ++cnt;//离散化 
		c[i].x = mp[make_pair(x,y)]; o = b[root[c[i].x]].siz,o2 = b[root[c[i].x]].mx2;
		b[root[c[i].x]].mx = max(b[root[c[i].x]].mx,c[i].w),b[root[c[i].x]].mx1 = max(b[root[c[i].x]].mx1,o);
		b[root[c[i].x]].ad = max(b[root[c[i].x]].ad,c[i].w),b[root[c[i].x]].ad1 = max(b[root[c[i].x]].ad1,o);//打标记 
		spilt(root[c[i].x],fl,fr,i-1);//按下标建方便删除 
		root[c[i].x] = merge(merge(fl,insert(i,o2,o)),fr);
		//add
	}
	read(t);
	for(int i = 1;i <= t;i++) 
	{
		read(z),read(x),read(y);
		if(!mp[make_pair(x,y)]) mp[make_pair(x,y)] = ++cnt;
		spilt(root[c[z].x],fl,fr,z-1); spilt(fr,fr,fz,z);
		ans[z] = max(ans[z],b[fr].mx),ans1[z] = max(ans1[z],b[fr].mx1);
		root[c[z].x] = merge(fl,fz); 
		//del
		o1 = mp[make_pair(x,y)]; o = b[root[o1]].siz,o2 = b[root[o1]].mx2;
		b[root[o1]].mx = max(b[root[o1]].mx,c[z].w),b[root[o1]].mx1 = max(b[root[o1]].mx1,o);
		b[root[o1]].ad = max(b[root[o1]].ad,c[z].w),b[root[o1]].ad1 = max(b[root[o1]].ad1,o);
		spilt(root[o1],fl,fr,z-1);
		root[o1] = merge(merge(fl,insert(z,o2,o)),fr),c[z].x = o1;
		//add 
	}
	for(int i = 1;i <= n;i++)
	{
		spilt(root[c[i].x],fl,fr,i-1); spilt(fr,fr,fz,i); 
		ans[i] = max(ans[i],b[fr].mx),ans1[i] = max(ans1[i],b[fr].mx1);
		root[c[i].x] = merge(fl,fz); 
	}
	for(int i = 1;i <= n;i++) print(ans[i]*ans1[i]),pc('\n');
	flush();
	return 0;
}
```

---

## 作者：CQBZ_ZJYjoe (赞：1)

# 思路分析
本题题目中询问次数 $1 \le t \le 300000$，显然可以离散化坐标，又因为本题需要维护**最大值的乘积**，于是可以想到分开维护。

对于移动操作，可以开 $N+M$ 颗平衡树，每个节点代表一只鸟，再使用懒标记维护最大士气值与最大团结值即可。

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,w[30005],a[300005],b[300005],x[30005],y[30005],v[300005],rt[330005],cnt[330005],tot;
long long ans[30005];
struct Node
{
    int ls,rs,val,maa,mab,siz,fa,taga,tagb,id;
    //maa 最大士气 mab 最大团结 taga 士气懒标记 tagb 团结懒标记
}tmp;
vector<Node> tr[330005];
void update(int s,int x)
{
    tr[s][x].siz=tr[s][tr[s][x].ls].siz+tr[s][tr[s][x].rs].siz+1;
}
void pushdown(int s,int x)
{
    //更新
    if (tr[s][x].taga)
    {
        tr[s][tr[s][x].ls].maa=max(tr[s][tr[s][x].ls].maa,tr[s][x].taga);
        tr[s][tr[s][x].rs].maa=max(tr[s][tr[s][x].rs].maa,tr[s][x].taga);
        tr[s][tr[s][x].ls].taga=max(tr[s][tr[s][x].ls].taga,tr[s][x].taga);
        tr[s][tr[s][x].rs].taga=max(tr[s][tr[s][x].rs].taga,tr[s][x].taga);
        tr[s][x].taga=0;
    }
    if (tr[s][x].tagb)
    {
        tr[s][tr[s][x].ls].mab=max(tr[s][tr[s][x].ls].mab,tr[s][x].tagb);
        tr[s][tr[s][x].rs].mab=max(tr[s][tr[s][x].rs].mab,tr[s][x].tagb);
        tr[s][tr[s][x].ls].tagb=max(tr[s][tr[s][x].ls].tagb,tr[s][x].tagb);
        tr[s][tr[s][x].rs].tagb=max(tr[s][tr[s][x].rs].tagb,tr[s][x].tagb);
        tr[s][x].tagb=0;
    }
}
bool getson(int s,int x)
{
    return tr[s][tr[s][x].fa].rs==x;
}
void rotate(int s,int x)
{
    int fa=tr[s][x].fa;
    if (getson(s,x)==0)
    {
        if (getson(s,fa)==0)
            tr[s][tr[s][fa].fa].ls=x;
        else 
            tr[s][tr[s][fa].fa].rs=x;
        tr[s][x].fa=tr[s][fa].fa;
        tr[s][fa].fa=x;
        tr[s][fa].ls=tr[s][x].rs;
        tr[s][tr[s][x].rs].fa=fa;
        tr[s][x].rs=fa;
    }
    else 
    {
        if (getson(s,fa)==0)
            tr[s][tr[s][fa].fa].ls=x;
        else 
            tr[s][tr[s][fa].fa].rs=x;
        tr[s][x].fa=tr[s][fa].fa;
        tr[s][fa].fa=x;
        tr[s][fa].rs=tr[s][x].ls;
        tr[s][tr[s][x].ls].fa=fa;
        tr[s][x].ls=fa;
    }
    update(s,fa);
    update(s,x);
}
void splay(int s,int x,int y)
{
    if (!y)
        rt[s]=x;
    while (tr[s][x].fa!=y)
    {
        int fa=tr[s][x].fa,gfa=tr[s][tr[s][x].fa].fa;
        if (gfa!=y)
        {
            if (getson(s,fa)==getson(s,x))
                rotate(s,fa);
            else 
                rotate(s,x);
        }
        rotate(s,x);
    }
}
void ins(int s,int u,int x,int id,int maa,int mab,int fa)
{
    if (!u)
    {
        tr[s].push_back(tmp);
        tr[s][++cnt[s]].val=x;
        tr[s][cnt[s]].maa=maa;
        tr[s][cnt[s]].id=id;
        tr[s][cnt[s]].siz=1;
        tr[s][cnt[s]].fa=fa;
        if (x<tr[s][fa].val)
            tr[s][fa].ls=cnt[s];
        else 
            tr[s][fa].rs=cnt[s];
        if (cnt[s]==1)
            rt[s]=cnt[s];
        splay(s,cnt[s],0);
        tr[s][cnt[s]].mab=max(mab,tr[s][cnt[s]].siz-3);
        return ;
    }
    pushdown(s,u);
    if (x<tr[s][u].val)
        ins(s,tr[s][u].ls,x,id,maa,mab,u);
    else 
        ins(s,tr[s][u].rs,x,id,maa,mab,u);
    update(s,u);
}
int rk(int s,int x)
{
    int u=rt[s],sum=0,fa=0;
    while (u)
    {
        pushdown(s,u);
        if (tr[s][u].val<x)
        {
            sum+=tr[s][tr[s][u].ls].siz+1;
            fa=u;
            u=tr[s][u].rs;
        }
        else 
        {
            fa=u;
            u=tr[s][u].ls;
        }
    }
    splay(s,fa,0);
    return sum;
}
int kth(int s,int x,int d)
{
    pushdown(s,x);
    if (tr[s][tr[s][x].ls].siz+1==d)
    {
        splay(s,x,0);
        return x;
    }
    if (tr[s][tr[s][x].ls].siz+1>d)
        return kth(s,tr[s][x].ls,d);
    else 
        return kth(s,tr[s][x].rs,d-tr[s][tr[s][x].ls].siz-1);
}
pair<int,int> del(int s,int x)
{
    int t=rk(s,x);
    int l=kth(s,rt[s],t),r=kth(s,rt[s],t+2);
    splay(s,l,0);
    splay(s,r,l);
    pair<int,int> tmp;
    tmp.first=tr[s][tr[s][r].ls].maa;
    tmp.second=tr[s][tr[s][r].ls].mab;
    //记录之前的最大值
    tr[s][r].ls=0;
    update(s,r);
    update(s,l);
    return tmp;
}
void inorder(int s,int x)
{
    if (!x)
        return ;
    pushdown(s,x);
    ans[tr[s][x].id]=1ll*tr[s][x].maa*tr[s][x].mab;
    //下传标记并计算答案
    inorder(s,tr[s][x].ls);
    inorder(s,tr[s][x].rs);
}
map<pair<int,int>,int> mp;
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n;
    for (int i=1;i<=n;i++)
    {
        cin>>w[i]>>x[i]>>y[i];
        if (!mp[{x[i],y[i]}])
            mp[{x[i],y[i]}]=++tot;
    }
    cin>>m;
    for (int i=1;i<=m;i++)
    {
        cin>>v[i]>>a[i]>>b[i];
        if (!mp[{a[i],b[i]}])
            mp[{a[i],b[i]}]=++tot;
    }
    tmp.siz=tmp.fa=tmp.ls=tmp.rs=tmp.taga=tmp.tagb=tmp.val=tmp.maa=tmp.mab=tmp.id=0;
    for (int i=1;i<=tot;i++)
    {
        tr[i].push_back(tmp);
        ins(i,rt[i],-0x7f7f7f7f7f7f7f7f,0,0,0,0);
        ins(i,rt[i],0x7f7f7f7f7f7f7f7f,0,0,0,0);
    }
    for (int i=1;i<=n;i++)
        ins(mp[{x[i],y[i]}],rt[mp[{x[i],y[i]}]],w[i],i,0,0,0);
    for (int i=1;i<=tot;i++)
    {
        if (tr[i][rt[i]].siz<=2)
            continue;
        int a=kth(i,rt[i],tr[i][rt[i]].siz-1),b=kth(i,rt[i],tr[i][rt[i]].siz-2);
        splay(i,a,0);
        splay(i,b,a);
        tr[i][rt[i]].maa=max(tr[i][rt[i]].maa,tr[i][tr[i][rt[i]].ls].val);
        tr[i][rt[i]].mab=max(tr[i][rt[i]].mab,tr[i][rt[i]].siz-3);
        tr[i][rt[i]].taga=max(tr[i][rt[i]].taga,tr[i][rt[i]].val);
        tr[i][rt[i]].tagb=max(tr[i][rt[i]].tagb,tr[i][rt[i]].siz-3);
        // cerr<<tr[i][rt[i]].maa<<' '<<tr[i][rt[i]].mab<<' '<<tr[i][rt[i]].taga<<' '<<tr[i][rt[i]].tagb<<'\n';
    }
    for (int i=1;i<=m;i++)
    {
        int tmp=mp[{x[v[i]],y[v[i]]}];
        auto t=del(tmp,w[v[i]]);
        x[v[i]]=a[i];
        y[v[i]]=b[i];
        tmp=mp[{x[v[i]],y[v[i]]}];
        ins(tmp,rt[tmp],w[v[i]],v[i],t.first,t.second,0);
        int a=kth(tmp,rt[tmp],tr[tmp][rt[tmp]].siz-1),b=kth(tmp,rt[tmp],tr[tmp][rt[tmp]].siz-2);
        splay(tmp,a,0);
        splay(tmp,b,a);
        tr[tmp][rt[tmp]].maa=max(tr[tmp][rt[tmp]].maa,tr[tmp][tr[tmp][rt[tmp]].ls].val);
        tr[tmp][rt[tmp]].mab=max(tr[tmp][rt[tmp]].mab,tr[tmp][rt[tmp]].siz-3);
        tr[tmp][rt[tmp]].taga=max(tr[tmp][rt[tmp]].taga,tr[tmp][rt[tmp]].val);
        tr[tmp][rt[tmp]].tagb=max(tr[tmp][rt[tmp]].tagb,tr[tmp][rt[tmp]].siz-3);
        // cerr<<tmp<<' '<<tr[tmp][rt[tmp]].id<<' '<<tr[tmp][tr[tmp][rt[tmp]].ls].val<<' '<<tr[tmp][rt[tmp]].maa<<' '<<tr[tmp][rt[tmp]].mab<<' '<<tr[tmp][rt[tmp]].taga<<' '<<tr[tmp][rt[tmp]].tagb<<'\n';
    }
    for (int i=1;i<=tot;i++)
        inorder(i,rt[i]);
    for (int i=1;i<=n;i++)
        cout<<ans[i]<<'\n';
    return 0;
}
```

# 重点错误
1. 一开始需要更新士气与团结值。
2. 需要开 $M+N$ 个树。
3. 在 $ins$、$rk$、$kth$ 中都需要传递标记。
4. 记得开long long。

---

## 作者：huhangqi (赞：0)

首先这个两维的位置完全就是干扰，直接离散化即可。

然后就是如何处理问题，我们发现每当有一只鸟飞到一个位置，就需要得到这个位置的最大武力值和鸟的数量，同时将自己的数值传入其中。

那么这直接暴力跑肯定超时。

那么比较明显的是，对于这种需要大量修改的情况，我们可以使用懒惰标记不断下传，那么我们明显可以建立平衡树，对值进行修改和查询。

那么我们直接以每个鸟为节点，每个位置存储一个根，最后在平衡树上修改即可。

我这边使用的是 fhq-treap，用下标来建树，这样可以防止删除的鸟错误。

处理出每棵树的大小和最大值，下传标记即可。

还需要注意的是标记可能没有传完，需要在最后全部传一遍。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=4e5+5;
int n,m,w[N],v[N],cnt,x[N],y[N],res1[N],res2[N];
pair<int,int> xx[N],yy[N],tmp[N];
struct TH{
	int rt[N],val[N],c[N],ch[N][2],id,siz[N],mx[N],tag1[N],tag2[N];
	void pushdown(int p){
		if(tag1[p]){
			res1[p]=max(res1[p],tag1[p]);
			if(ch[p][0])tag1[ch[p][0]]=max(tag1[ch[p][0]],tag1[p]);
			if(ch[p][1])tag1[ch[p][1]]=max(tag1[ch[p][1]],tag1[p]);
			tag1[p]=0;
		}
		if(tag2[p]){
			res2[p]=max(res2[p],tag2[p]);
			if(ch[p][0])tag2[ch[p][0]]=max(tag2[p],tag2[ch[p][0]]);
			if(ch[p][1])tag2[ch[p][1]]=max(tag2[p],tag2[ch[p][1]]);
			tag2[p]=0;
		}
	}
	pair<int,int> split(int p,int v){
		if(!p)return {0,0};
		pushdown(p);
		if(p<=v){
			auto tmp=split(ch[p][1],v);
			ch[p][1]=tmp.first;
			pushup(p);
			return {p,tmp.second};
		}
		else {
			auto tmp=split(ch[p][0],v);
			ch[p][0]=tmp.second;
			pushup(p);
			return {tmp.first,p};
		}
	}
	void pushup(int p){
		mx[p]=max(mx[ch[p][0]],max(mx[ch[p][1]],val[p]));
		siz[p]=siz[ch[p][0]]+siz[ch[p][1]]+1;
	}
	int merge(int u,int v){
		if(!u||!v)return u|v;
		if(c[u]<c[v]){
			pushdown(u);
			ch[u][1]=merge(ch[u][1],v);
			pushup(u);
			return u;
		}
		else {
			pushdown(v);
			ch[v][0]=merge(u,ch[v][0]);
			pushup(v);
			return v;
		}
	}
	void insert(int x,int v){
		id++;
		c[id]=rand();
		val[id]=v;
		mx[id]=v;
		siz[id]=1;
		add(id,x,v);
	}
	void del(int x,int p,int v){
		auto a=split(rt[x],p);
		auto b=split(a.first,p-1);
		rt[x]=merge(b.first,a.second);
		siz[p]=1;
		tag1[p]=tag2[p]=0;
	}
	void add(int p,int x,int v){
		if(rt[x]){
			pushdown(rt[x]);
			pushup(rt[x]);
			res1[p]=max(res1[p],mx[rt[x]]);
			tag1[rt[x]]=max(tag1[rt[x]],v);
		}
		auto a=split(rt[x],p);
		rt[x]=merge(a.first,merge(p,a.second));
		tag2[rt[x]]=max(tag2[rt[x]],siz[rt[x]]);
	}
	void query(int p){
		if(!p)return;
		pushdown(p);
		query(ch[p][0]);
		query(ch[p][1]);
		pushup(p);
	}
}tp;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>w[i]>>xx[i].first>>xx[i].second;
		tmp[++cnt]=xx[i];
	}
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>v[i]>>yy[i].first>>yy[i].second;
		tmp[++cnt]=yy[i];
	}
	sort(tmp+1,tmp+cnt+1);
	cnt=unique(tmp+1,tmp+cnt+1)-tmp-1;
	for(int i=1;i<=n;i++)x[i]=lower_bound(tmp+1,tmp+cnt+1,xx[i])-tmp;
	for(int i=1;i<=m;i++)y[i]=lower_bound(tmp+1,tmp+cnt+1,yy[i])-tmp;
	for(int i=1;i<=n;i++)tp.insert(x[i],w[i]);
	for(int i=1;i<=m;i++){
		if(x[v[i]]==y[i])continue;
		tp.del(x[v[i]],v[i],w[v[i]]);
		x[v[i]]=y[i];
		tp.add(v[i],x[v[i]],w[v[i]]);
	}
	for(int i=1;i<=cnt;i++)tp.query(tp.rt[i]);
	for(int i=1;i<=n;i++)cout<<res1[i]*(res2[i]-1)<<endl;
	return 0;
}

``````

---

## 作者：qwer6 (赞：0)

## Description

现在有 $n$ 只鸟，每一只鸟有一个威武值 $w_i$，并且初始位置为 $(x_i,y_i)$，定义一只鸟的在一个时刻的团结值为这个时刻和它处于同一个位置的鸟的数量，在一个时刻的士气值为这个时刻和它处于同一个位置的鸟的最大威武值，注意：无论是团结值还是士气值都**不计算**这只鸟本身。

同时还有 $t$ 个时刻，发出一个形如 $(v,x,y)$ 的指令，表示将标号为 $v$ 的鸟移动到 $(x,y)$ 这个位置。

现在询问**包括初始时刻在内**的所有时刻中，每一只鸟**士气值的最大值**和**团结值的最大值**的乘积。

## Solution

我们首先把操作离线，将所有涉及到的坐标离散化，方便我们接下来的操作，当然，由于这里不强制要求大小关系在离散化后依然相同，所以使用一个 map 去记录也是可以的。

然后我们考虑一次操作对于每一只鸟的影响，对于移动到 $(x,y)$ 的这只鸟 $v$，如果 $(x,y)$ 这个位置上本来就有 $m$ 只鸟，他们的威武值的最大值为 $mx$，那么我们就使用 $m$ 更新 $v$ 的团结值，使用 $mx$ 更新 $v$ 的士气值，反之，同样使用 $m$ 更新这 $m$ 只鸟的团结值，用 $w_v$ 更新这 $m$ 只鸟的士气值。使用 $m$ 更新团结值的原因是，这只鸟加入之后，这个位置上就有 $m+1$ 只鸟了，每一只鸟去掉自己之后，这个时刻的士气值都是 $m$。

单点更新我们可以直接 $O(1)$ 操作，但是更新 $m$ 只鸟的操作难道要 $O(m)$ 的暴力更新吗？

显然我们需要一个其他的数据结构去维护这 $n$ 只鸟的士气值和团结值，要求这个数据结构支持删除，插入一个节点，区间更新权值。

我们可以想到平衡树，不会平衡树的可以去翻翻 OI Wiki，这是[模板题]((https://www.luogu.com.cn/problem/P3369))。

这里我的维护方法可能比较清奇，首先使用一棵平衡树维护每一个位置上的鸟的威武值，用来查询上面说到的 $mx$，再使用另外一棵平衡树去维护每一只鸟的最大士气值和团结值。

关于怎么用第二棵平衡树维护每一只鸟的最大士气值和团结值，我的思路是将平衡树节点的权值设为这个节点维护的鸟的编号，修改时直接修改对应编号的鸟的权值，修改直接打懒标记即可。

注意士气值和团结值的最大值都要计算初始时刻，否则只能拿到 $20$ Pts！

## Code

不要问我为什么两棵平衡树一个写的是有旋 Treap，另一个写的是无旋 Treap，问就是我不知道有旋 Treap 的标记什么时候下放。

```c++
/*by qwer6*/
/*略去缺省源和快读快写*/
const int N=30005,M=3e5+5;
int n,t,tot;
int w[N],x[N],y[N],rt1[N+M],rt2[N+M],pos[N];
pii tmp[N+M];
mt19937 ran(838412064);
struct Query{
	int v,x,y;
}q[M];
struct Treap1{
	#define Siz(x) (x==0?0:siz[x])
	#define Mx(x) (x==0?0:mx[x])
	int num,top;
	int val[N],cnt[N],siz[N],st[N],ch[N][2],mx[N];
	unsigned int c[N];
	void New(int &p,int v){
		if(!top)p=++num;
		else p=st[top--];
		val[p]=mx[p]=v,c[p]=ran();
		cnt[p]=siz[p]=1;
		ch[p][0]=ch[p][1]=0;
	}
	void pushup(int p){
		siz[p]=Siz(ch[p][0])+Siz(ch[p][1])+cnt[p];
		mx[p]=max({val[p],Mx(ch[p][0]),Mx(ch[p][1])});
	}
	void ratote(int &p,bool opt){
		int x=ch[p][opt];
		ch[p][opt]=ch[x][opt^1];
		ch[x][opt^1]=p;
		pushup(ch[p][opt]),pushup(ch[x][opt^1]);
		p=x;
	} 
	void insert(int &p,int v){
		if(!p)return New(p,v);
		if(val[p]==v)cnt[p]++;
		else if(v>val[p]){
			insert(ch[p][1],v); 
			if(c[p]>c[ch[p][1]])ratote(p,1);
		}else{
			insert(ch[p][0],v);
			if(c[p]>c[ch[p][0]])ratote(p,0);
		}
		pushup(p);
	}
	void delet(int &p,int v){
		if(!p)return ;
		if(val[p]==v){
			cnt[p]--;
			siz[p]--;
			if(cnt[p])return ;
			st[++top]=p;
			if(ch[p][0]==0&&ch[p][1]==0)return void(p=0);
			if(ch[p][0]==0){
				p=ch[p][1];
				pushup(p);
				return ;
			}
			if(ch[p][1]==0){
				p=ch[p][0];
				pushup(p);
				return ;
			}
			int tmp=p;
			if(c[ch[p][0]]<c[ch[p][1]])ratote(p,0);
			else ratote(p,1);
			pushup(p);
			int now=tmp,pre=p;
			while(ch[now][0]&&ch[now][1]){
				if(c[ch[now][0]]<c[ch[now][1]])ratote(now,0);
				else ratote(now,1);
				pushup(now);
				if(val[ch[pre][0]]==v)ch[pre][0]=now;
				else ch[pre][1]=now;
				pre=now;
				now=tmp;
			}
			if(val[ch[pre][0]]==v)ch[pre][0]=ch[now][0]|ch[now][1];
			else ch[pre][1]=ch[now][0]|ch[now][1];
			pushup(pre);
		}else if(v>val[p]){
			delet(ch[p][1],v);
			pushup(p);
		}else{
			delet(ch[p][0],v);
			pushup(p);
		}	
	}
	#undef Siz
	#undef Mx
}treap1;
struct Treap2{
	#define Siz(x) (x==0?0:siz[x])
	int num,top;
	int val[N],mx1[N],mx2[N],siz[N],tag1[N],tag2[N],st[N],cnt[N],ch[N][2];
	unsigned int c[N];
	void New(int &p,int v){
		if(top)p=st[top--];
		else p=++num;
		val[p]=v,c[p]=ran();
		siz[p]=1,cnt[p]=1;
		tag1[p]=tag2[p]=0;
		ch[p][0]=ch[p][1]=0;
	}
	void pushup(int p){
		siz[p]=Siz(ch[p][0])+Siz(ch[p][1])+cnt[p];
	}
	void Tag(int p,int v1,int v2){
		tomax(mx1[val[p]],v1);
		tomax(mx2[val[p]],v2);
		tomax(tag1[p],v1);
		tomax(tag2[p],v2);
	}
	void pushdown(int p){
		if(ch[p][0])Tag(ch[p][0],tag1[p],tag2[p]);
		if(ch[p][1])Tag(ch[p][1],tag1[p],tag2[p]);
		tag1[p]=tag2[p]=0;
	}
	pii split(int p,int v){
		if(!p)return {0,0};
		pushdown(p);
		if(val[p]<=v){		
			pii tmp=split(ch[p][1],v);
			ch[p][1]=tmp.first;
			pushup(p);
			return {p,tmp.second};
		}else{
			pii tmp=split(ch[p][0],v);
			ch[p][0]=tmp.second;
			pushup(p);
			return {tmp.first,p};
		}
	}
	int merge(int x,int y){
		if(x==0&&y==0)return 0;
		if(x==0)return y;
		if(y==0)return x;
		pushdown(x),pushdown(y);
		if(c[x]<c[y]){
			ch[x][1]=merge(ch[x][1],y);
			pushup(x);
			return x;
		}else{
			ch[y][0]=merge(x,ch[y][0]);
			pushup(y);
			return y;
		}
	}
	int insert(int p,int v){
		pii tmp1=split(p,v-1);
		pii tmp2=split(tmp1.second,v);
		if(tmp2.first!=0)cnt[tmp2.first]++;
		else New(tmp2.first,v);
		return merge(tmp1.first,merge(tmp2.first,tmp2.second));
	}
	int delet(int p,int v){
		pii tmp1=split(p,v-1);
		pii tmp2=split(tmp1.second,v);
		if(tmp2.first)st[++top]=tmp2.first;
		return merge(tmp1.first,tmp2.second);
	}
	void push(int p,bool opt=0){
		if(!p)return ;
		pushdown(p);
		push(ch[p][0],opt),push(ch[p][1],opt);
	}
    #undef Siz
}treap2;
signed main(){
	read(n);
	for(int i=1;i<=n;i++){
		read(w[i]),read(x[i]),read(y[i]);
		tmp[i]={x[i],y[i]};
	}
	read(t);
	for(int i=1;i<=t;i++){
		read(q[i].v),read(q[i].x),read(q[i].y);
		tmp[i+n]={q[i].x,q[i].y};
	}	
	sort(tmp+1,tmp+n+t+1);
	tot=unique(tmp+1,tmp+n+t+1)-tmp-1;	
	for(int i=1,now;i<=n;i++){//注意计算初始时刻的士气值和团结值！
		now=lower_bound(tmp+1,tmp+tot+1,pii{x[i],y[i]})-tmp;
		if(rt1[now]){
			tomax(treap2.mx1[i],treap1.mx[rt1[now]]);
			tomax(treap2.mx2[i],treap1.siz[rt1[now]]);
			treap2.Tag(rt2[now],w[i],treap1.siz[rt1[now]]);
		}
		treap1.insert(rt1[now],w[i]);
		rt2[now]=treap2.insert(rt2[now],i);
		pos[i]=now;
	}
	for(int i=1,now,pre,idx;i<=t;i++){
		idx=q[i].v;
		now=lower_bound(tmp+1,tmp+tot+1,pii{q[i].x,q[i].y})-tmp;
		pre=pos[idx];
		treap1.delet(rt1[pre],w[idx]);
		rt2[pre]=treap2.delet(rt2[pre],idx);
		if(rt1[now]){
			tomax(treap2.mx1[idx],treap1.mx[rt1[now]]);
			tomax(treap2.mx2[idx],treap1.siz[rt1[now]]);
			treap2.Tag(rt2[now],w[idx],treap1.siz[rt1[now]]);
		}
		treap1.insert(rt1[now],w[idx]);
		rt2[now]=treap2.insert(rt2[now],idx);
		pos[idx]=now;
	}
	for(int i=1;i<=tot;i++)
		treap2.push(rt2[i]);
	for(int i=1;i<=n;i++)//注意虽然单个值不会爆 int，但是乘起来非常有可能会爆 int
		write(1ll*treap2.mx1[i]*treap2.mx2[i]),Nxt;
}
```

---

## 作者：Musity (赞：0)

# Splay 做法

把每个出现过的坐标都当做是一个集合，即停留在这个位置的鸟的集合，发现本题需要进行这样的操作：

1. 把一个元素从一个集合移到另一个集合（也就是删除和插入）
2. 维护一个元素的“士气值”的历史最大值以及“团结值”的历史最大值。

集合中插入一个元素 $x$ 时，只需知道插入前的“威武值”最大值和集合大小即可更新 $x$ 的两个信息。但集合的其它元素仍需要用上面两个值更新，想到 splay 中插入完后 $x$ 在**根节点**的位置，又想到线段树中可以由**父节点向下打延迟标记**来更新大块区间，于是就想到把此时的集合大小以及 $x$ 的“威武值”作为延迟标记先存着，不影响复杂度。

由于不同的鸟可以有一样的“威武值”。如果用“威武值”作为键值，首先难通过键值找到所有对应的鸟，其次不同时间进来的的鸟都存在同一个节点里，而节点存的延迟标记只是想给插入时就已经在的鸟更新而已，这样行不通。

所以可以把**鸟的编号作为键值**，这样一个节点对应一只鸟，更新整个集合时后来再加入的节点也不影响。插入一个数时先 splay 到树根，用延迟标记即可完成更新整棵树，此时树中还差根节点没更新，集合大小本来就有，而维护集合“威武值”的最大值怎么做呢？再放个 `multiset` 解决。

# 代码

建多棵树时可以共用同一份数组，每棵树有自己的根。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 4e5+5; 

int n, m, cnt, w[N], b[N], ans[N], Ans[N];
int tot, fa[N], sz[N], vl[N], stg[N], vtg[N], ch[N][3];
map<pair<int, int>, int> mp;

void update(int &x, int y) { // x = max(x, y);
	if (y > x) x = y;
}
int get(int x, int y) { // 给出一个坐标对应的数
	pair<int, int> pr = make_pair(x, y);
	if (mp.find(pr) == mp.end()) mp[pr] = ++cnt;
	return mp[pr]; 
}

struct Splay{
	int rt; multiset<int> s; 
	
	int  judge(int x) {return x == ch[fa[x]][1];}
	void renew(int x) {sz[x] = sz[ch[x][0]]+sz[ch[x][1]]+1;}
	void clear(int x) {fa[x]=sz[x]=vl[x]=stg[x]=vtg[x]=ch[x][0]=ch[x][1] = 0;}
	
	int  newnode(int val) {vl[++tot] = val; sz[tot] = 1; return tot;}
	void connect(int x, int y, int o) {
		if (x) fa[x] = y;
		if (y) ch[y][o] = x, renew(y);
	}

	void Spread(int x, int *tag, int *arr) {
		if (tag[x]) {
			int lx = ch[x][0], rx = ch[x][1];
			if (lx) 
				update(arr[vl[lx]], tag[x]),
				update(tag[lx], tag[x]);
			if (rx)
				update(arr[vl[rx]], tag[x]),
				update(tag[rx], tag[x]);
			tag[x] = 0;
		}
	}
	void spread(int x) {
		Spread(x, vtg, ans);
		Spread(x, stg, Ans);
	}
	
	void rotate(int x) { 
		int y = fa[x], z = fa[y], o = judge(x), O = judge(y);
		connect(ch[x][o^1], y, o);
		connect(y, x, o^1);
		connect(x, z, O);
	}
	void splay(int x) {
		// splay 是从下往上走，此时标记未下传
		stack<int>  s;
		for (int f = x; f; s.push(f), f = fa[f]);
		while(s.size()) spread(s.top()), s.pop(); 
		for (int f = fa[x]; f = fa[x], f; rotate(x))
			if (fa[f]) rotate(judge(x) == judge(f) ? f: x);
		rt = x;
	}
	
	int find(int val) { // 找到编号为 val 的节点并 splay 到根 
		int x = rt; 
		while (x && val != vl[x]) 
			spread(x), x = ch[x][val > vl[x]];
		if (x) splay(x);
		return x;
	}
	int pre() {
		int x = ch[rt][0];
		while (ch[x][1]) 
			spread(x), x = ch[x][1];
		splay(x);			
		return x; 
	}
	void insert(int val) {
		if (sz[rt]) 
			update(ans[val], *(--s.end())),
			update(Ans[val], sz[rt]);
		s.insert(w[val]);
		// 编号一定不同，插入就简单了，二分查找到空位就行了 
		int x = rt, f = 0; 
		if (!rt) return (void)(rt = newnode(val));
		while (x) {
			spread(x); f = x; 
			x = ch[x][val > vl[x]];			
		}
		x = newnode(val);
		connect(x, f, val > vl[f]);
		splay(x);
		// 延迟标记
		stg[x] = max(stg[x], sz[x]-1); 
		vtg[x] = max(vtg[x], w[val]);
	}
	void erase(int val) {
		s.erase(s.find(w[val]));
		
		int x = find(val), y;
		spread(x);
		if (!ch[x][0] && !ch[x][1]) 
			rt = 0;
		else if (!ch[x][0] || !ch[x][1]) // 这个地方一定要把 fa[rt] 清空 ！！否则后面rotate会错
			rt = ch[x][0] + ch[x][1], fa[rt] = 0;
		else // x 的前驱 splay 到根时，x 只剩下右儿子 
			y = pre(), connect(ch[x][1], y, 1);
		clear(x);
	}
}T[N];
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n;
	for (int i = 1, x, y; i <= n; i++) {
		cin >> w[i] >> x >> y; 
		b[i] = get(x, y); // bi 存着第 i 只鸟在哪个 splay树（坐标）上。
		T[b[i]].insert(i);
	} 
	cin >> m;
	for (int i = 1, u, x, y; i <= m; i++) {
		cin >> u >> x >> y;
		T[b[u]].erase(u);
		b[u] = get(x, y);
		T[b[u]].insert(u);
	}
	for (int i = 1; i <= n; i++) {
		T[b[i]].find(i);
		cout << (long long)ans[i]*Ans[i] << '\n';
	}
	return 0;
}
```

---


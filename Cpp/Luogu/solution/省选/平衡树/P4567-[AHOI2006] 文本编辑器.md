# [AHOI2006] 文本编辑器

## 题目描述

这些日子，可可不和卡卡一起玩了，原来可可正废寝忘食的想做一个简单而高效的文本编辑器。你能帮助他吗？为了明确任务目标，可可对“文本编辑器”做了一个抽象的定义： 

- `Move k`：将光标移动到第 $k$ 个字符之后，如果 $k=0$，将光标移到文本第一个字符之前。
- `Insert n (换行) S`：在光标后插入长度为 $n$ 的字符串 $S$，光标位置不变，$n \ge 1$。
- `Delete n`：删除光标后的 $n$ 个字符，光标位置不变，$n \ge 1$。
- `Rotate n`：反转光标后的 $n$ 个字符，光标位置不变，$n \ge 1$。
- `Get`：输出光标后的一个字符，光标位置不变。
- `Prev`：光标前移一个字符。
- `Next`：光标后移一个字符。


下面是几个定义：

- 文本：由 $0$ 个或多个字符构成的序列。这些字符的 ASCII 码在闭区间 $[32, 126]$ 内，也就是说，这些字符均为可见字符或空格。
- 光标：在一段文本中用于指示位置的标记，可以位于文本的第一个字符之前，文本的最后一个字符之后或文本的某两个相邻字符之间。
- 文本编辑器：为一个可以对一段文本和该文本中的一个光标进行如下七条操作的程序。如果这段文本为空，我们就说这个文本编辑器是空的。 

编写一个程序：
1. 建立一个空的文本编辑器。
2. 从输入文件中读入一些操作指令并执行。
3. 对所有执行过的 `GET` 操作，将指定的内容写入输出文件。

## 说明/提示

对输入数据我们有如下假定：
1. `MOVE` 操作不超过 $5\times 10^4$ 个，`INSERT`, `DELETE` 和 `ROTATE` 操作作的总个数不超过 $6\times 10^3$，`GET` 操作不超过 $2\times 10^4$ 个，`PREV` 和 `NEXT` 操作的总个数不超过 $2\times 10^4$。
2.  所有 `INSERT` 插入的字符数之和不超过 $2M$（$1M=2^{20}$)。
3. `DELETE` 操作、`ROTATE` 操作和 `GET` 操作执行时光标后必然有足够的字符。`MOVE`、`PREV`、`NEXT` 操作不会把光标移动到非法位置。
4. 输入文件没有错误。

## 样例 #1

### 输入

```
10
Insert 13
Balanced eert
Move 2
Delete 5
Next
Insert 7
 editor
Move 0
Get
Move 11
Rotate 4
Get```

### 输出

```
B
t```

# 题解

## 作者：EndSaH (赞：19)

[日常安利博客](https://endsah.cf)

# $\text{Foreword}$

**这里不是正解！！！ 这里不是正解！！！**

虽说如此，截止到此篇题解发出时间，我的程序仍是最优解第一。~~并且拉了原先第一还不少~~

其实原本只是想试试能不能过掉[[NOI2003]文本编辑器](https://www.luogu.org/problemnew/show/P4008)的，过了之后听同学说这边有个带翻转加强版，于是就来试了试...

然后就A了？然后就最优解第一？？？

满脸问号.jpg

# $\text{Solution}$

题意就不解释了...赤裸裸的数据结构

你可以尝试各类操作，比如 $\text{Splay、FHQ}$、块状链表$\cdots$

这些我都不再赘述，前面也有人讲了。

但如果真的到了考场上，这些复杂又难调的数据结构无疑会耗费大量的时间。

再认真的看看数据范围：

> $\text{MOVE}$ 操作不超过 $50000$ 个，$\text{INSERT, DELETE, ROTATE}$ 操作的总个数不超过 $6000$，$\text{GET}$ 操作不超过 $20000$ 个， $\text{PREV, NEXT}$ 操作的总个数不超过 $20000$。

暴力，真的就会 $\text{TLE}$ 吗？

如果开启 $O_2$，$\text{vector}$ 带来的极致速度，还是值得我们一试的。

其实最重要的还是，**太好码了**！

记当前光标位置为 $pos$，当前文本为 $T$，临时文本为 $temp$。那么各个操作分别为：

$\text{Move}\ k$：`pos = k;`

$\text{Insert}\ n\ s$：将 $s$ 每个字符依次读入放入 $temp$，然后`T.insert(T.begin() + pos, temp.begin(), temp.end());`

$\text{Delete}\ n$：`T.erase(T.begin() + pos, T.begin() + pos + n);`

$\text{Rotate}\ n$：`std::reverse(T.begin() + pos, T.begin() + pos + n);`

$\text{Get}$：`putchar(T[pos]);`

$\text{Prev}$：`--pos;`

$\text{Next}$：`++pos;`

有没有直观感受到码量？

于是花 $\text{20min}$ 时间码完之后，我满怀着希望一交...

...当然是因为细节问题爆零了- -（因用了`assert`，全部 $\text{RE}$）

想详见细节怎么处理的，请看代码（在下面）- -

[$\Huge\text{Code}$](https://www.luogu.org/paste/knyyi070)

$\text{Thanks for your consideration!}$

---

## 作者：wanggk (赞：8)

题解区好像暂时没有块状链表的题解。

从弱化版 P4008 过来的，建议先做弱化版，这篇题解是在弱化版的基础上讲的。 ~~（相同操作的部分还是那边的题解更清晰）~~。

## 思路

对文本分块，这里块长取了 $2000$ 左右，每块存储：

- 当前块中的字符串（我用的是 `char` 数组存）。
- 块的大小，即字符串长度（$sz$）。
- 翻转标记，类似于一些数据结构的懒标记（`tag==1` 表示需要翻转一次）。
  - 是否处于翻转的状态对**整块插入、整块删除**没有影响。
  - 整块翻转时只需要在块上打标记即可。
  - 涉及到对**具体某一块**修改时，需要先下放标记再修改。这一部分基本上是在分裂和合并的函数中实现的。
- 前驱块和后继块（$pre$ 和 $nxt$），弱化版只需要记录后继就可以了。

## 具体操作

接下来是题目要求的操作（括号内的英文对应代码）：

### 光标移动

涉及到 `Move` `Prev` `Next` 操作，只需要直接对全局变量 $pos$（光标位置）赋值就可以了。

### 查询（fd）
这一部分和弱化版是一样的。

对于光标位置，返回一个 `pair<int,int>`，两个元素分别表示块的编号、块内位置。

### 分裂（split）与合并（merge）

不论是分裂还是合并，在分裂或合并前都需要将块**转正（结构体中的 `rev` 函数）**：如果 `tag==1`，则翻转整块的字符串并清空懒标记。如果是合并，需要将前后两块都转正 ~~（好像是废话）~~。

然后分裂就是在后面新加一个块，维护好它的信息，合并就是删除一个块。这部分和弱化版是一样的。

### 插入（Insert）和删除（Delete）

这一部分和弱化版是一样的，因为我们已经把下方标记的部分放到 `split` 函数和 `merge` 函数里去了。

### 翻转（Rotate）

这部分是全新的操作。总体是和删除函数相似的，不同的地方在于，我们不是直接删掉那些定位到的块，而是 **在块上打好翻转的标记并（用一个数组）依次记录下它们的编号，再倒序遍历数组，把它们插回去**。即，块与块之间的顺序倒过来，并将每一块翻转。

### 查询（Get）

这里只需要查询光标后的一个字符就可以了。定位到光标位置的**后一个字符（而不是光标）** 之后，我们免去 `split` 操作，并调用一次 `a[id].rev()` 将这一块**转成正的**，输出对应字符就可以了。

## 一些细节

- 这题的读入和输出好像有点坑，关于换行符和题目中不存在的操作。
- 注意及时 `merge` 以保证时间复杂度。
- 如果链表的最后是 $-1$ 结束，注意边界，避免调用 $a_{-1}$。
- 分裂合并的过程中随时更新 $sz$ 的大小和对应块的字符串，在具体的块上单点操作时记得先下放标记。

## Code

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define For(i,il,ir) for(int i=(il);i<=(ir);++i)
#define Fr(i,il,ir) for(int i=(il);i<(ir);++i)
#define Forr(i,ir,il) for(int i=(ir);i>=(il);--i)
using namespace std;
typedef pair<int,int> pii;
template<typename T>
inline void rd(T& x){
    bool f=0;x=0;char ch=getchar();
    while(ch<'0'||ch>'9'){ if(ch=='-') f=1; ch=getchar(); }
    while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    if(f) x=-x;
}
template<typename T,typename... Args>
void rd(T& first,Args&... args){ rd(first),rd(args...); }
const int B=2010;

struct node{
    bool tag;
    char ch[B<<1];
    int pre,nxt,sz;
    void rev(){ if(tag) reverse(ch+1,ch+1+sz),tag^=1; }
    void mdf(int x,int y,int z){ pre=x,nxt=y,sz=z; }
    void add(char c){ ch[++sz]=c; }
}a[B<<2];

int delv[B<<2];
int mxuse,deltot;
int newnode(){
    int id=deltot?delv[deltot--]:++mxuse;
    a[id].tag=0;return id;
}
void del(int x){ a[x].tag=0;delv[++deltot]=x; }

pii fd(int p){
    int sum=0;
    if(p==0) return mk(1,0);
    for(int u=1;~u;sum+=a[u].sz,u=a[u].nxt)
        if(sum<p&&p<=sum+a[u].sz)
            return mk(u,p-sum);
}
void split(pii x){
    a[x.fi].rev();
    int y=newnode();
    a[y].mdf(x.fi,a[x.fi].nxt,a[x.fi].sz-x.se);
    memcpy(a[y].ch+1,a[x.fi].ch+x.se+1,a[y].sz);
    a[x.fi].nxt=y,a[x.fi].sz=x.se;
}
void merge(int id){
    int y=a[id].nxt;
    if(y==-1||a[id].sz+a[y].sz>B||a[y].sz==0) return;
    a[id].rev(),a[y].rev();
    memcpy(a[id].ch+a[id].sz+1,a[y].ch+1,a[y].sz);
    a[id].nxt=a[y].nxt,a[id].sz+=a[y].sz;
    del(y);
}
int insblock(int lst)
{
    int x=newnode();
    a[x].mdf(lst,a[lst].nxt,0);
    if(~a[lst].nxt) a[a[lst].nxt].pre=x;
    a[lst].nxt=x;
    return x;
}

int n;
int pos,len;
void Insert()
{
    pii t=fd(pos);
    if(t.se<a[t.fi].sz) split(t);
    int id=t.fi;
    For(i,1,len)
    {
        if(i%B==1) id=insblock(id);
        char c=getchar();while((c<32||c>126)&&c!='\n'&&c!='\r') c=getchar();
        a[id].add(c);
    }
    merge(id);merge(t.fi);
}
void Delete()
{
    pii t=fd(pos);
    if(t.se<a[t.fi].sz) split(t);
    int id=t.fi;
    while(len>0)
    {
        int y=a[id].nxt;
        if(a[y].sz>len) split({y,len});
        a[id].nxt=a[y].nxt,len-=a[y].sz,del(y);
    }
    merge(t.fi);
}
int tmp[B<<1],totid=0;
void Rotate()
{
    pii t=fd(pos);
    if(t.se<a[t.fi].sz) split(t);
    int head=t.fi,tail=a[head].nxt,id=t.fi;totid=0;
    while(len>0)
    {
        int y=a[id].nxt;
        if(a[y].sz>len) split({y,len});
        a[y].tag^=1,len-=a[y].sz,id=y;
        tmp[++totid]=y,tail=a[y].nxt;
    }
    Forr(i,totid,1){
        a[head].nxt=tmp[i];
        a[tmp[i]].pre=head;
        head=tmp[i];
    }
    a[head].nxt=tail;
    merge(head),merge(t.fi);
    if(~tail) a[tail].pre=head;
}
void Get()
{
    pii t=fd(pos);
    int id=t.fi,i=t.se;
    if(i==a[id].sz) id=a[id].nxt,i=0;
    a[id].rev();++i;
    putchar(a[id].ch[i]);
    if(a[id].ch[i]!='\n'&&a[id].ch[i]!='\r') putchar('\n');
}
signed main()
{
    rd(n);a[newnode()].nxt=-1;
    while(n--)
    {
        char op=getchar();
        while(op!='M'&&op!='I'&&op!='D'&&op!='G'&&op!='P'&&op!='N'&&op!='R'){
            op=getchar();
            if(op==EOF) return 0;
        }
        if(op=='M') rd(pos);
        else if(op=='I') rd(len),Insert();
        else if(op=='D') rd(len),Delete();
        else if(op=='R') rd(len),Rotate();
        else if(op=='G') Get();
        else if(op=='P'||op=='N') getchar(),getchar(),getchar(),pos+=(op=='P'?-1:1);
    }
    return 0;
}
```

宣传：[数据生成器](https://www.luogu.com.cn/discuss/994886)。

---

## 作者：command_block (赞：6)

[原题传送门](https://www.luogu.org/problemnew/show/P4567)

毒瘤题。

一看题面:**这不是Splay/Treap乱搞题吗?**

于是乎乱搞28,WA两页多……

总结了一下,本题的坑主要在输入,也就是**数据有些不严谨**。

题目中关于文本的定义

```
文本：由0个或多个字符构成的序列。这些字符的ASCII码在闭区间[32, 126]内，也就是说，这些字符均为可见字符或空格。
```

事实证明,**回车也算文本内容**。

按照这样定义的话,样例是没问题的。

输出回车的时候不用输出两个回车,只要一个即可(见代码)。

剩下的一个坑:数据中有**名称不对的操作**,应当忽略。

其余就是区间树基本操作,什么插入删除翻转之类。

区间树模板见:[P3391 【模板】文艺平衡树（Splay）](https://www.luogu.org/problemnew/show/P3391)

**Code:**

```cpp
#include<algorithm>
#include<cstdio>
#define MaxNum 2000010
using namespace std;
int m,len;
char ord[10];
struct Node
{int l,r,c,g;char x;bool tag;};
struct Fhq_Treap
{
  int tn,root,p;
  bool liv;
  Node a[MaxNum];
  inline void ladd(int num){
    if (a[num].tag){
      a[a[num].r].tag^=1;
      a[a[num].l].tag^=1;
      swap(a[num].l,a[num].r);
      a[num].tag=0;
    }
  }
  inline void up(int num)
  {a[num].c=a[a[num].l].c+a[a[num].r].c+1;}
  inline void create(int x)
  {
    a[++tn].x=x;
    a[tn].g=(rand()<<4)^rand();
    a[tn].c=1;
  }
  int marge(int x,int y){
    if (!x||!y)return x+y;
    if (a[x].g<a[y].g){
      ladd(x);a[x].r=marge(a[x].r,y);
      up(x);return x;
    }else{
      ladd(y);a[y].l=marge(x,a[y].l);
      up(y);return y;
    }
  }
  void split(int num,int to,int &x,int &y){
    if (!num)x=y=0;
    else {
      ladd(num);
      int mid=a[a[num].l].c+1;
      if (to>mid)
       {x=num;split(a[x].r,to-mid,a[x].r,y);}
      else {y=num;split(a[y].l,to,x,a[y].l);}
      up(num);
    }
  }
  void push(int len){
    getchar();
    int l,mid=0,r;
    for (int j=0;j<len;j++){
      create(getchar());
	  mid=marge(mid,tn);
    }split(root,p,l,r);
  	root=marge(marge(l,mid),r);
  }
  void change(int len){
  	int l,mid,r;
  	split(root,p+len,l,r);
  	split(l,p,l,mid);
  	a[mid].tag^=1;
  	root=marge(marge(l,mid),r);
  }
  void del(int len){
  	int l,mid,r;
  	split(root,p+len,l,r);
  	split(l,p,l,mid);
  	root=marge(l,r);
  }
  void get(){
  	int x,mid,y;
    split(root,p+1,x,y);
  	split(x,p,x,mid);
  	if (a[mid].x!='\n')
	  putchar(a[mid].x);
	putchar('\n');
  	root=marge(marge(x,mid),y);
  }
}t;
int main()
{
  scanf("%d",&m);
  t.p=1;
  for (int i=1;i<=m;i++){
    scanf("%s",ord);
    if (ord[0]=='I'){
      scanf("%d",&len);
      t.push(len);
    }else if (ord[0]=='M'){
      scanf("%d",&t.p);t.p++;
    }else if (ord[0]=='N')t.p++;
    else if (ord[0]=='P')t.p--;
    else if (ord[0]=='D'){
      scanf("%d",&len);
      t.del(len);
    }else if (ord[0]=='G')t.get(); 
    else if (ord[0]=='R'){
      scanf("%d",&len);
      t.change(len);
    }
  }return 0;
}
```

---

## 作者：TheLostWeak (赞：6)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/BZOJ1269.html)

**大致题意：** 让你维护一个字符串，有插入字符串、删除区间、反转区间和输出单个字符操作。

### $Splay$

这应该是一道比较简单的$Splay$题（虽然因为各种细节我调了很久）。

我们可以考虑用一个变量$k$来记录光标的位置，然后用$Splay$维护。

关于用$Splay$维护区间详见这篇博客中关于维护序列的部分：[简析平衡树（三）——浅谈Splay](https://www.cnblogs.com/chenxiaoran666/p/Splay.html#模板2洛谷3391模板文艺平衡树)。

下面是对各操作实现的简单概括，具体实现见代码。

#### $Move$操作

更新$k$即可。

#### $Insert$操作

首先，将给你的字符串先建成一棵树，记其根为$p$。

然后，将第$k-1$个节点$Splay$到根，第$k+1$个节点$Splay$到根的右儿子，此时根节点的右儿子的左儿子就是第$k$个节点。

再就可以将$p$作为这个节点的右儿子了（千万注意，要先$PushDown$这个节点再操作，不然会旋转子树）。

但还要注意维护$Size$，一个简单的方法是将$p$直接旋到根即可。

#### $Delete$操作

设删除的区间为$[l,r]$。

则将第$l-1$个节点$Splay$到根，第$r+1$个节点$Splay$到根的右儿子，然后将根节点的右儿子的左儿子赋值为$0$，并$PushUp$根节点的右儿子和根即可。

#### $Rotate$操作

实际上我感觉这个操作应叫$Reverse$操作。。。

和$Delete$操作差不多吧，只不过是把清零改成翻转，且不用$PushUp$罢了。

#### $Get$操作

将第$k-1$个节点$Splay$到根，第$k+1$个节点$Splay$到根的右儿子，此时根节点的右儿子的左儿子就是第$k$个节点。

返回其权值即可。

#### $Prev$操作

$--k$即可。

#### $Next$操作

$++k$即可。

### 关于此题的一些坑点

1. 这可能是我的$Splay$的问题，一开始在序列的前后需各加两个而不是一个字符作为辅助字符。
2. 数据有毒。虽然题目中的合法字符集不包括回车符，但数据里的确有，所以读入字符串时应读入$n$个字符。
3. 依然是回车的问题，如果查询时得到的答案是回车符，则不能再换行。
4. 不要漏掉任何一个$PushUp$和$PushDown$，牢记：多写不会$WA$！这点常数不会$TLE$！

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define swap(x,y) (x^=y^=x^=y)
#define hl_AK_NOI true
using namespace std;
class FastIO
{
    private:
        #define FS 100000
        #define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
        #define tn(x) (x<<3)+(x<<1)
        #define D isdigit(c=tc())
        char c,*A,*B,FI[FS];
    public:
        I FastIO() {A=B=FI;}
        Tp I void read(Ty& x) {x=0;W(!D);W(x=tn(x)+(c&15),D);}
        Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
        I void reads(string& x) {x="";W(isspace(c=tc()));W(x+=c,!isspace(c=tc())&&~c);}
        I void readc(char& x) {x=tc();}
}F;
class Splay//Splay
{
    private:
        #define PU(x) (O[x].Sz=O[O[x].S[0]].Sz+O[O[x].S[1]].Sz+1)//上传子树信息，更新Size
        #define Re(x) (swap(O[x].S[0],O[x].S[1]),O[x].R^=1)//翻转一个子树
        #define PD(x) (O[x].R&&(Re(O[x].S[0]),Re(O[x].S[1]),O[x].R=0))//下传翻转标记
        #define Wh(x) (O[O[x].F].S[1]==x)//查询是父节点的哪一个儿子
        #define Co(x,y,d) (O[O[x].F=y].S[d]=x)//连接两个节点
        #define Sp(x,y) (S(GV((x)-1),rt),S(GV((y)+1),O[rt].S[1]),O[O[rt].S[1]].S[0])//抠出一个区间
        static const int SZ=2097152;int rt,tot;struct node {char V;int Sz,R,F,S[2];}O[SZ+5];
        I void Ro(CI x,int& k)//Rotate操作
        {
            RI f=O[x].F,p=O[f].F,d=Wh(x);PD(p),PD(f),PD(x),(f^k?O[p].S[Wh(f)]:k)=x,
            O[x].F=p,Co(O[x].S[d^1],f,d),Co(f,x,d^1),PU(f),PU(x);
        }
        I void S(CI x,int& k) {RI f;W(x^k) f=O[x].F,f^k&&(Ro(Wh(x)^Wh(f)?x:f,k),0),Ro(x,k);PU(x);}//Splay操作
        I int GV(RI rk)//求出排名为k的节点的编号
        {
            RI x=rt;W(hl_AK_NOI)//hl_AK_NOI=true
            {
                if(PD(x),O[O[x].S[0]].Sz>=rk) x=O[x].S[0];//如果左儿子Size大于等于rk，说明答案在左子树（记得先PushDown）
                else if(rk-=O[O[x].S[0]].Sz+1) x=O[x].S[1];//如果rk减去左儿子与当前节点的Size和后大于0，就说明答案在右子树
                else return x;//否则，说明答案在当前节点
            }
        }
    public:
    	I void Init() {rt=Build(0,3,"€€€€");}//初始化（好不容易找到的一个既能显示又不在合法字符集内的字符）
        int Build(CI l,CI r,Con string& s)//建树
        {
            RI x=++tot,t,mid=l+r>>1;O[x].V=s[mid],//二分
            l^mid&&(t=Build(l,mid-1,s),Co(t,x,0)),r^mid&&(t=Build(mid+1,r,s),Co(t,x,1));//处理两个儿子
            return PU(x),x;//返回当前节点编号
        }
        I void Insert(CI x,CI p) {RI k=Sp(x+2,x+2);PD(k),Co(p,k,1),S(p,rt);}//插入
        I void Delete(CI x,CI y) {Sp(x+2,y+2)=0,PU(O[rt].S[1]),PU(rt);}//删除
        I void Rever(CI x,CI y) {RI k=Sp(x+2,y+2);Re(k);}//翻转
        I char Query(CI x) {return O[Sp(x+2,x+2)].V;}//询问
}S;
int main()
{
    RI Qtot,i,x,k=0;Reg string op,s;Reg char c;S.Init(),F.read(Qtot);W(Qtot--)
    {
        F.reads(op);switch(op[0])
        {
            case 'M':F.read(x),k=x;break;//移动光标
            case 'I'://插入
                for(F.read(x),s="",i=0;i^x;++i) F.readc(c),s+=c;//注意应读入n个字符
                S.Insert(k,S.Build(0,x-1,s));
            break;
            case 'D':F.read(x),S.Delete(k+1,k+x);break;//删除
            case 'R':F.read(x),S.Rever(k+1,k+x);break;//翻转
            case 'G':putchar(c=S.Query(k+1)),c^'\n'&&putchar('\n');break;//询问，注意特判回车
            case 'P':--k;break;case 'N':++k;break;//前移和后移
        }
    }return 0;
}
```



---

## 作者：crashed (赞：3)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P4567)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;平衡树的模板题。这里使用的是非旋$Treap$。由于这道题用平衡树维护的是文本，所以只需要考虑文字之间的相对顺序，因此之后所有对于树的$split$操作指的都是按照排名进行$split$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不难想到用一个变量$p$存下来光标前面一个字符的下标（下标从$1$开始）。下面考虑对于题目中各个操作的处理：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$1.Move,Prev,Next$：对于这三个操作，修改$p$即可。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$2.Delete$：设文本为$S$。把树分成三个部分，一个为$x$树，对应$[1,p]$的文本；一个为$y$树，对应要删除的$(p,p+n]$的文本；还有一个为$z$树，对应$(p+n,|S|]$的文本。于是乎$y$树就是要删除的部分。我们直接将$x$树和$z$树合成新树即可。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$3.Rotate$：同上，把需要修改的部分提出来，打标记。然后在拆分、修改的操作的时候下传标记即可。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$4.Get$：相当于求文本中第$p+1$小的值。套板子。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$5.Insert$：先把书分成两个部分，一个为$x$树，对应$[1,p]$；另一个为$z$树，对应$(p,|S|]$。下面有两种处理方法。一种是把要插入的串暴力一个一个字符地插入到$x$树，然后合并$x$和$z$，时间是可以过的，但是显然效率很低；另一种是对于要插入的串建立一颗$y$树，再把$x,y,z$合并起来。~~因为我很懒，~~ 我用的第一种方法。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于出题人很恶心，插入的时候有可能出现换行符也需要插入，所以需要严格地按照输入的$n$来插入而不是用$scanf$之类的。同时，如果$Get$需要输出换行符，就只需要输出一个。    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后你就发现这道黑题就被这样愉快地~~水过去~~解决了。  
# 代码
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>

#define random myRandom

const int MAXSIZ = 1024 * 1024 * 2 + 5;

template<typename _T>
void read( _T &x )
{
    x = 0;char s = getchar();int f = 1;
    while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
    while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
    x *= f;
}

template<typename _T>
void write( _T x )
{
    if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
    if( 9 < x ){ write( x / 10 ); }
    putchar( x % 10 + '0' );
}

template<typename _T>
void swapp( _T &x, _T &y ) { _T t = x; x = y, y = t; }

int ch[MAXSIZ][2], aux[MAXSIZ], siz[MAXSIZ];
char val[MAXSIZ], S[MAXSIZ];
bool rot[MAXSIZ];
int nsiz, mpos = 0, rt;

void srd() { int a, *aa = &a; srand( ( unsigned long long ) aa ); }
int random() { return rand() * rand(); }
int newNode( const char c ) { aux[++ nsiz] = random(), siz[nsiz] = 1, val[nsiz] = c, rot[nsiz] = false; return nsiz; }
void upt( const int u ) { siz[u] = siz[ch[u][0]] + siz[ch[u][1]] + 1; }
void swp( const int u ) { swapp( ch[u][0], ch[u][1] ), rot[u] ^= 1; }
void normalize( const int u )
{
	if( ! rot[u] ) return ;
	swp( ch[u][0] ), swp( ch[u][1] );
	rot[u] = false;
}

void splitRnk( const int u, const int k, int &x, int &y )
{
	if( ! u ) { x = y = 0; return ; }
	normalize( u );
	if( k <= siz[ch[u][0]] ) y = u, splitRnk( ch[u][0], k, x, ch[u][0] );
	else x = u, splitRnk( ch[u][1], k - siz[ch[u][0]] - 1, ch[u][1], y );
	upt( u );
}

int merg( const int u, const int v )
{
	if( ! u || ! v ) return u + v;
	if( aux[u] < aux[v] ) { normalize( u ), ch[u][1] = merg( ch[u][1], v ), upt( u ); return u; }
	else { normalize( v ), ch[v][0] = merg( u, ch[v][0] ), upt( v ); return v; }
}

void insert( const char *buf )
{
	int l = strlen( buf ), y;
	splitRnk( rt, mpos, rt, y );
	for( int i = 0 ; i < l ; i ++ ) rt = merg( rt, newNode( buf[i] ) );
	rt = merg( rt, y );
}

void del( const int length )
{
	int x, y;
	splitRnk( rt, mpos, rt, x ), 
	splitRnk( x, length, x, y );
	rt = merg( rt, y );
}

void rotate( const int length )
{
	int x, y;
	splitRnk( rt, mpos, rt, x ), splitRnk( x, length, x, y );
	swp( x ), rt = merg( merg( rt, x ), y );
}

char Get()
{
	int u = rt, k = mpos + 1;
	while( true )
	{
		normalize( u );
		if( k <= siz[ch[u][0]] ) u = ch[u][0];
		else if( k <= siz[ch[u][0]] + 1 ) return val[u];
		else k -= siz[ch[u][0]] + 1, u = ch[u][1];
	}
}

int main()
{
	srd();
	char op[10];
	int N, k;
	read( N );
	while( N -- )
	{
		scanf( "%s", op );
		if( op[0] == 'M' ) { read( mpos ); }
		if( op[0] == 'I' )
		{
			read( k );
			for( int i = 0 ; i < k ; i ++ ) S[i] = getchar();
			insert( S );
			for( int i = 0 ; i < k ; i ++ ) S[i] = '\0';
		}
		if( op[0] == 'D' ) read( k ), 
		del( k );
		if( op[0] == 'R' ) read( k ), rotate( k );
		if( op[0] == 'G' ) 
		{
			char tmp; putchar( tmp = Get() );
			if( tmp ^ '\n' ) putchar( '\n' );
		}
		if( op[0] == 'P' ) mpos --;
		if( op[0] == 'N' ) mpos ++;
	}
	return 0;
}
```

---

## 作者：HansLimon (赞：3)

# 注意，非正解
###### rope大法好

[如果你不会rope](http://iwo.im/?q=C%2B%2B%20rope)
之后我会写一篇rope的博客的(~~咕咕咕~~)
### Part 1
我们先看看有哪些操作能直接(或者稍经思考)解决
- Move ${\color{lightgreen}\text{OK}}$
- Insert ${\color{lightgreen}\text{OK}}$
- Delete ${\color{lightgreen}\text{OK}}$
- Rotate ${\color{red}\text{NO}}$
- Get ${\color{lightgreen}\text{OK}}$
- Prev ${\color{lightgreen}\text{OK}}$
- Next ${\color{lightgreen}\text{OK}}$

这么看来好像只有$rotate$有一点问题(~~小声bb~~)
### Part 2
关于光标：

我们模拟一个cnt代表光标，用以执行Move、Prev、Next及Get指令，如下
```cpp
reader>>k//慢读qwq
if (inst[0] == 'M')cnt = k;
```
```cpp
else if (inst[0] == 'P'/* == "Prev"*/)cnt --;
else if (inst[0] == 'N'/* == "Next"*/)cnt ++;
```
### Part 3
关于插入删除：
```cpp
reader>>k;
......OTHER CODES.....
else if (inst[0] == 'I'){
	for (register int i = 0;i < k;i ++){
		goal[i] = getchar();
	}
	goal[k] = '\0';
	a.insert(cnt, goal);//a就是我们的rope
}
```

但是为了便于rotate操作，我们可以考虑再来一个倒着记录的rope b，因此插入语句应该这样：
```cpp
reader>>k;
......OTHER CODES.....
else if (inst[0] == 'I'){
	register int length = a.size();
	for (register int i = 0;i < k;i ++){
		bac[k - i - 1] = goal[i] = getchar();//bac是当前S反过来的char数组
	}
	goal[k] = bac[k] = '\0';
	a.insert(cnt, goal);
	b.insert(length - cnt, bac);
}
```
同理，删除操作如下
```cpp
else if (inst[0] == 'D'){
	register int length = a.size();
	a.erase(cnt, k);
	b.erase(length - cnt - k, k);
}
```
### Part 4
现在剩下的就是恶心的$rotate$了

由于rope里面的链式操作使得我们不能直接删除再插入，而STL自带的函数常数又太大。所以我们要换条路子。

最开始我的想法其实是把rotate换成Get、Next、Delete这三个指令的组合，每一次从b中Get一个到临时的char数组中然后再Next，重复K次，最后再插回去。
###### 感觉这样应该能慢到飞起
所以想了想觉得应该额外来一个临时的rope tmp，用substr方法一系列瞎操作，详见代码，感觉应该挺好理解：
```cpp
else if (inst[0] == 'R'){
	register int length = a.size();
	tmp = a.substr(cnt, k);//取出来
	a = a.substr(0, cnt) + b.substr(length - cnt - k, k) + a.substr(cnt + k, length - cnt - k);//两端不变，中间把b对应位置移过来
	b = b.substr(0, length - cnt - k) + tmp + b.substr(length - cnt, cnt);//一样qwq
}
```
嗯 o\(\*￣▽￣\*\)o 就酱\~
### Part 5
快乐的放码时间：
```cpp
#include <cstdio>
#include <ext/rope>

const int N = 1<<22 + 7;
int n, k, cnt;
char now, inst[N], goal[N], bac[N];
struct readers{
	char now;
	bool state;
	readers operator >>(int &goal){
		goal = 0;
		state = true;
		while (now = getchar(), now < 48 || now > 57)state = now^45;
		while (48 <= now && now <= 57){
			goal = (goal<<1) + (goal<<3) + (now^48);
			now = getchar();
		}
		if (!state)goal = -goal;
		return *this;
	}
}reader;
__gnu_cxx::rope<char> a, b, tmp;

int main(){
	reader>>n;
	while (n --){
		/*bef:*/scanf("%s", inst);
//		if (inst[0] == 10)goto bef;
//		printf("inst:"), puts(inst);
		if (inst[0] == 'I'/*"Insert"*/ || inst[0] == 'M'/* == "Move"*/ || inst[0] == 'D'/* == "Delete"*/ || inst[0] == 'R'/* == "Rotate"*/){
			reader>>k;
			if (inst[0] == 'M')cnt = k;
			else if (inst[0] == 'I'){
				register int length = a.size();
				for (register int i = 0;i < k;i ++){
					bac[k - i - 1] = goal[i] = getchar();
				}
				goal[k] = bac[k] = '\0';
				a.insert(cnt, goal);
				b.insert(length - cnt, bac);
			}else if (inst[0] == 'D'){
				register int length = a.size();
				a.erase(cnt, k);
				b.erase(length - cnt - k, k);
			}else if (inst[0] == 'R'){
				register int length = a.size();
				tmp = a.substr(cnt, k);
				a = a.substr(0, cnt) + b.substr(length - cnt - k, k) + a.substr(cnt + k, length - cnt - k);
				b = b.substr(0, length - cnt - k) + tmp + b.substr(length - cnt, cnt);
			}
		}else if (inst[0] == 'P'/* == "Prev"*/)cnt --;
		else if (inst[0] == 'N'/* == "Next"*/)cnt ++;
		else if (inst[0] == 'G'/* == "Get"*/){
			putchar(a[cnt]);
			if (a[cnt] != 10)putchar(10);
		}
	}	
	return 0;
}
```
本来是想挖个坑的，想让你们体验一下刚开始我用string的痛qwq

### Part 6
还有一点，可能有人不是很清楚Get操作那里，因为

${\color{red}\text{换行符也是可见字符啊qwq}}$(详情请见**输入格式**)

但是输出的时候只输出一行，所以如果已经输出了换行的话就不能再来换行了qwq

---

## 作者：Huami360 (赞：3)

$Splay$裸题。。

和$NOI$那道文本编辑器差不多，就是多了个翻转。

坑点：

1、回车算文本内容，并且可能作为答案输出，此时，不需要再另外输出一个回车。

2、至于前面的题解说的数据有名称不对的操作，实测并没有，放心跑就好了。

要注意的地方

$NOI$那道文本编辑器，可以直接记录光标的下标。但本题最好别那么做，因为翻转操作的存在，若直接对下标$splay$，会导致有些懒标记发生错误。所以本题应该记录光标在平衡树中是第几大，每次通过找第$k$大来找到他，避免不必要的麻烦。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
inline int read(){
    int s = 0, w = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-')w = -1;ch = getchar();}
    while(ch >= '0' && ch <= '9') s = s * 10 + ch - '0',ch = getchar();
    return s * w;
}
const int MAXINSERTLEN = 2100000;
struct SplayTree{
    char val;
    int ch[2], fa, size, lazy;
}t[MAXINSERTLEN];
char str[MAXINSERTLEN], s[MAXINSERTLEN];
int num, root, n, len;
void pushup(int u){
    t[u].size = t[t[u].ch[0]].size + t[t[u].ch[1]].size + 1;
}
void pushdown(int u){
	if(t[u].lazy){
	  t[t[u].ch[0]].lazy ^= 1;
	  t[t[u].ch[1]].lazy ^= 1;
	  swap(t[u].ch[0], t[u].ch[1]);
	  t[u].lazy = 0; 
    }
}
void rotate(int x){
    int y = t[x].fa; int z = t[y].fa; int k = t[y].ch[1] == x;
    t[z].ch[t[z].ch[1] == y] = x; t[x].fa = z;
    t[y].ch[k] = t[x].ch[k ^ 1]; t[t[x].ch[k ^ 1]].fa = y;
    t[x].ch[k ^ 1] = y; t[y].fa = x;
    pushup(y); pushup(x);
}
void Splay(int x, int goal){
    while(t[x].fa != goal){
      int y = t[x].fa; int z = t[y].fa;
      if(z != goal)
        (t[z].ch[0] == y) ^ (t[y].ch[0] == x) ? rotate(x) : rotate(y);
      rotate(x);
    }
    if(goal == 0) root = x;
}
int build(int l, int r){
    int id = ++num;
    int mid = (l + r) >> 1;
    t[id].val = str[mid];
    if(mid > l){
      t[id].ch[0] = build(l, mid - 1);
      t[t[id].ch[0]].fa = id;
    }
    if(mid < r){
      t[id].ch[1] = build(mid + 1, r);
      t[t[id].ch[1]].fa = id;
    }
    pushup(id);
    return id;
}
inline int findKth(int k){
    int u = root;
    while(1){
      pushdown(u);
      if(t[t[u].ch[0]].size >= k) u = t[u].ch[0];
      else if(t[t[u].ch[0]].size == k - 1) return u;
      else k -= t[t[u].ch[0]].size + 1, u = t[u].ch[1];
    }
}
char opt;
int cur;
int main(){
    n = read();
    root = cur = ++num; t[num].val = 1;
    t[++num].fa = cur; t[num].val = 1;
    t[cur].ch[1] = num; t[num].size = 1; t[cur].size = 2;
    for(int i = 1; i <= n; ++i){
       scanf("%s", s); opt = s[0];
       if(opt == 'I'){
         len = read();
         for(int i = 1; i <= len; ++i)
            str[i] = getchar();
         Splay(findKth(cur), 0);
         Splay(findKth(cur + 1), root);
         t[t[root].ch[1]].ch[0] = (len = build(1, len));
         t[len].fa = t[root].ch[1];
         Splay(t[t[root].ch[1]].ch[0], 0);
       }
       else if(opt == 'G'){
       	 int ans = findKth(cur + 1);
       	 putchar(t[ans].val);
         if(t[ans].val != '\n') putchar('\n');
       }
       else if(opt == 'M')
         cur = read() + 1;
       else if(opt == 'P')
         --cur;
       else if(opt == 'N')
         ++cur;
       else if(opt == 'D'){
         len = read();
         Splay(findKth(cur), 0);
         Splay(findKth(t[t[root].ch[0]].size + 2 + len), root);
         t[t[root].ch[1]].ch[0] = 0;
       }
       else if(opt == 'R'){
         len = read();
         Splay(findKth(cur), 0);
         Splay(findKth(t[t[root].ch[0]].size + 2 + len), root);
         t[t[t[root].ch[1]].ch[0]].lazy ^= 1;
       }
    }
    return 0;
}

```

---

## 作者：kouylan (赞：2)

## 题解 P4567 【[AHOI2006]文本编辑器】

### 【题意】
对于一个初始的空串，有如下几种操作：
1. 插入；
2. 删除；
3. 翻转；
4. 移动光标；
5. 查询。

我们要实现这些操作。

### 【分析】
看到有插入、删除、反转，就能马上想到用平衡树（在此使用**fhq_treap**）。我们来一个一个的解决这些操作。

**设光标所在位置为$p$，操作长度为$m$**。

**1. 插入**

要在$p$处插入一个长度为$m$字符串$s$。

首先我们先按照$p$为大小，分裂成两棵子树$x, y$，我们只需要依次合并$x, s$和$y$即可。但是我们不能一个字符一个字符的插入（不然会TLE），所以我们要用[笛卡尔树](https://blog.csdn.net/code92007/article/details/94591571)先把$s$建成一个treap。
```cpp
int build(int m)
{
	char ch;
	while(m)
	{
		if((ch=getchar())=='\n' || ch=='\r')
			continue; //忽略换行符
		m--;
		int cnt=newnode(ch),lst=0;
		while(top && t[sk[top]].key>=t[cnt].key) //单调栈维护
		{
			update(sk[top]);
			lst = sk[top--];
		}
		if(top)
			t[sk[top]].r = cnt;
		t[cnt].l = lst;
		sk[++top] = cnt;
	}
	while(top)
		update(sk[top--]);
	return sk[1]; //树根
}

void insert(int p,int m)
{
	int x,y;
	split(root,p,x,y); //按p的大小分裂
	root = merge(merge(x,build(m)),y); //合并
}
```

**2. 删除**

普通平衡树的删除方法即可。

```cpp
void remove(int p,int m)
{
	int x,y,z;
	split(root,p,x,y); 
	split(y,m,y,z); //y就是要删除的区间(子树)
	root = merge(x,z);
}
```

**3. 翻转**

可以参考[文艺平衡树](https://www.luogu.com.cn/problem/P3391)。

我们只需对需要操作的区间（子树）的树根打上懒标记（类似于线段树）。注意懒标记要下传。

```cpp
void pushdown(int now)
{
	if(t[now].laz)
	{
		swap(t[now].l,t[now].r); //翻转, 即交换左右子树
		t[t[now].l].laz ^= 1;
		t[t[now].r].laz ^= 1;
	}
	t[now].laz = 0;
}

void reverse(int p,int m)
{
	int x,y,z;
	split(root,p,x,y);
	split(y,m,y,z);
	t[y].laz ^= 1; //y就是要翻转的区间(子树)
	root = merge(merge(x,y),z);
}
```

**4. 移动光标**

只需对$p$进行修改即可。

**5. 查询**

类似于反转，分裂出查询区间（子树）$y$，输出值即可。

下面是AC代码。
```cpp
/*
luogu P4567
*/
#include <bits/stdc++.h>
using namespace std;

int q,l;
int cnt,root;
int top,sk[2100000];
struct fhqtreap{
	int l,r;
	int siz,laz;
	int key;
	char v;
}t[2100000];

int newnode(char v)
{
	t[++cnt].v = v;
	t[cnt].siz = 1;
	t[cnt].key = rand();
	return cnt;
}

void update(int now)
{
	t[now].siz = t[t[now].l].siz+t[t[now].r].siz+1;
}

void pushdown(int now)
{
	if(t[now].laz)
	{
		swap(t[now].l,t[now].r);
		t[t[now].l].laz ^= 1;
		t[t[now].r].laz ^= 1;
	}
	t[now].laz = 0;
}

void split(int now,int siz,int &x,int &y)
{
	if(!now)
	{
		x = y = 0;
		return;
	}
	pushdown(now);
	if(t[t[now].l].siz+1<=siz)
	{
		x = now;
		split(t[now].r,siz-t[t[now].l].siz-1,t[now].r,y);
	}
	else
	{
		y = now;
		split(t[now].l,siz,x,t[now].l);
	}
	update(now);
}

int merge(int x,int y)
{
	if(!x || !y)
		return x+y;
	if(t[x].key>=t[y].key)
	{
		pushdown(x);
		t[x].r = merge(t[x].r,y);
		update(x);
		return x;
	}
	else
	{
		pushdown(y);
		t[y].l = merge(x,t[y].l);
		update(y);
		return y;
	}
}

int build(int m)
{
	char ch;
	while(m)
	{
		if((ch=getchar())=='\n' || ch=='\r')
			continue;
		m--;
		int cnt=newnode(ch),lst=0;
		while(top && t[sk[top]].key>=t[cnt].key)
		{
			update(sk[top]);
			lst = sk[top--];
		}
		if(top)
			t[sk[top]].r = cnt;
		t[cnt].l = lst;
		sk[++top] = cnt;
	}
	while(top)
		update(sk[top--]);
	return sk[1];
}

void insert(int p,int m)
{
	int x,y;
	split(root,p,x,y);
	root = merge(merge(x,build(m)),y);
}

void remove(int p,int m)
{
	int x,y,z;
	split(root,p,x,y);
	split(y,m,y,z);
	root = merge(x,z);
}

void reverse(int p,int m)
{
	int x,y,z;
	split(root,p,x,y);
	split(y,m,y,z);
	t[y].laz ^= 1;
	root = merge(merge(x,y),z);
}

void get(int p,int m)
{
	int x,y,z;
	split(root,p,x,y);
	split(y,m,y,z);
	cout<<t[y].v;
	if(t[y].v!='\n' && t[y].v!='\r')
		cout<<endl;
	root = merge(merge(x,y),z);
}

int main()
{
	srand(time(NULL));
	cin>>q;
	while(q--)
	{
		string oper;
		cin>>oper;
		if(oper=="Insert")
		{
			int x;
			scanf("%d",&x);
			insert(l,x);
		}
		else if(oper=="Delete")
		{
			int x;
			scanf("%d",&x);
			remove(l,x);
		}
		else if(oper=="Move")
		{
			int x;
			scanf("%d",&x);
			l = x;
		}
		else if(oper=="Prev")
			l--;
		else if(oper=="Next")
			l++;
		else if(oper=="Rotate")
		{
			int x;
			scanf("%d",&x);
			reverse(l,x);
		}
		else if(oper=="Get")
			get(l,1);
	}
	
	return 0;
}
```

祝大家AC愉快！

---

## 作者：_liet (赞：1)

emmmmmmmmmm……似乎没人写题解……

那我就来补一篇好了。

其实就是个 Splay 板子题，本身没什么特别难的地方，基本粘上板子就差不多了。

另外样例里面 `Insert 7` 下面那个 `editor`，前面其实有个空格，不然就只有六个字符了……

剩下的直接看代码吧。

```cpp
/* 假装这里有头文件 */

char str[MAXN]; // 用来放输入的字符串的数组
int pos = 1;    // 用来记录光标位置

struct Node {
    Node *ch[2];
    int s, flip;
    char v;

    int cmp(int k) const {
        int d = k - ch[0]->s;
        if (d == 1) return -1;
        return d <= 0 ? 0 : 1;
    }
    void maintain() {
        s = ch[0]->s + ch[1]->s + 1;
    }
    void pushdown() {
        if (flip) {
            flip = 0;
            swap(ch[0], ch[1]);
            ch[0]->flip = !ch[0]->flip;
            ch[1]->flip = !ch[1]->flip;
        }
    }
};

Node *null = new Node();
Node *root;

/////////////////// 以下为 Splay 常规操作 ///////////////////

void rotate(Node* &o, int d) {
    Node *k = o->ch[d^1];
    o->ch[d^1] = k->ch[d];
    k->ch[d] = o;
    o->maintain();
    k->maintain();
    o = k;
}

void splay(Node* &o, int k) {
    o->pushdown();
    int d = o->cmp(k);
    if (d == 1) {
        k -= o->ch[0]->s + 1;
    }
    if (d != -1) {
        Node *p = o->ch[d];
        p->pushdown();
        int d2 = p->cmp(k);
        int k2 = (d2 == 0 ? k : k - p->ch[0]->s - 1);
        if (d2 != -1) {
            splay(p->ch[d2], k2);
            if (d == d2) {
                rotate(o, d^1);
            } else {
                rotate(o->ch[d], d);
            }
        }
        rotate(o, d^1);
    }
}

Node* merge(Node *left, Node *right) {
    splay(left, left->s);
    left->ch[1] = right;
    left->maintain();
    return left;
}

void split(Node *o, int k, Node* &left, Node* &right) {
    splay(o, k);
    left = o;
    right = o->ch[1];
    o->ch[1] = null;
    left->maintain();
}

Node* build(int l, int r) {
    if (l >= r) return null;
    int mid = (l + r) / 2;
    Node *n = build(l, mid);
    Node *o = new Node();
    o->v = str[mid];
    o->flip = o->s = 0;
    o->ch[0] = n;
    o->ch[1] = build(mid + 1, r);
    o->maintain();
    return o;
}

/////////////////// 以上为 Splay 常规操作 ///////////////////


void insert(int n) { // 插入
    Node *tmp = build(0, n);
    Node *left, *right;
    split(root, pos, left, right);
    root = merge(merge(left, tmp), right);
}


void erase(int n) { // 删除
    Node *left, *mid, *right, *o;
    split(root, pos, left, o);
    split(o, n, mid, right);
    root = merge(left, right);
}

void flip(int k) { // 反转
    Node *left, *mid, *right, *o;
    split(root, pos, left, o);
    split(o, k, mid, right);
    mid->flip ^= 1;
    root = merge(merge(left, mid), right);
}

int main() {
    char op[10];
    int n, k;
    root = build(0, 1);

    scanf("%d", &n);
    while (n--) {
        scanf("%s", op);
        switch (op[0]) {
            case 'M': scanf("%d", &k); pos = k + 1; break;
            case 'D': scanf("%d", &k); erase(k); break;
            case 'R': scanf("%d", &k); flip(k); break;
            case 'P': pos--; break;
            case 'N': pos++; break;
            case 'G':
                splay(root, pos + 1);
                // 这里如果直接 printf("%c\n", root->v) 的话就只有 28 分了
                putchar(root->v);
                if (root->v != '\n') putchar('\n');
                break;
            case 'I':
                scanf("%d", &k);
                getchar();
                for (int i = 0; i < k; i++) {
                    str[i] = getchar();
                }
                str[k] = '\0';
                insert(k);
                break;
            default: break;
        }
    }

    return 0;
}
```

---

## 作者：zhylj (赞：0)

为了更好的阅读体验，你可以前往我的博客：[https://www.cnblogs.com/zhylj/p/10381075.html](https://www.cnblogs.com/zhylj/p/10381075.html)

### 题目

这些日子，可可不和卡卡一起玩了，原来可可正废寝忘食的想做一个简单而高效的文本编辑器。你能帮助他吗？为了明确任务目标，可可对“文本编辑器”做了一个抽象的定义： 

- `Move k`：将光标移动到第 $k$ 个字符之后，如果 $k=0$ , 将光标移到文本第一个字符之前。(**注意是 cur = k 不是 cur += k**)
- `Insert n （换行） S`：在光标后插入长度为n的字符串S，光标位置不变，$n\ge 1​$。
- `Delete n`：删除光标后的 $n$ 个字符，光标位置不变，$n\ge 1$。
- `Rotate n`：反转光标后的 $n​$ 个字符，光标位置不变，$n\ge 1​$。
- `Get`：输出光标后的一个字符，光标位置不变。
- `Prev`：光标前移一个字符。
- `Next`：光标后移一个字符。

下面是几个定义：

- 文本：由0个或多个字符构成的序列。这些字符的 ASCII 码在闭区间 [32, 126] 内，也就是说，这些字符均为可见字符或空格。
- 光标：在一段文本中用于指示位置的标记，可以位于文本的第一个字符之前，文本的最后一个字符之后或文本的某两个相邻字符之间。
- 文本编辑器：为一个可以对一段文本和该文本中的一个光标进行如下七条操作的程序。如果这段文本为空，我们就说这个文本编辑器是空的。 

编写一个程序：

1. 建立一个空的文本编辑器。
2. 从输入文件中读入一些操作指令并执行。
3. 对所有执行过的 Get 操作，将指定的内容写入输出文件。

### 分析

发现一堆人的 Splay 是用 split 和 merge 做的, 然而我觉得既然写了 Splay, 为什么不用 Splay 呢?

~~试图掩盖我不会写这两操作的事实~~

重点在 Delete/Insert/Rotate 操作上.(下方 $c$ 为光标的后一个字符的位置)

- Insert n S: 把 $c - 1$ 和 $c$ 分别旋转到根节点和根节点的右孩子, 此时根节点的右孩子的左孩子就代表了区间 $(c-1, c)$, 显然该区间为空, 用之前的建树去做就可以了.
- Delete n: 把 $c - 1$ 和 $c + n$ 旋转到根节点的右孩子, 此时根节点的右孩子的左孩子就代表了区间 $(c - 1, c + n )$, 即 $[c, c + n - 1]$, 随便删除即可.
- Rotate n: 把 $c - 1$ 和 $c + n$ 旋转到根节点的右孩子, 此时根节点的右孩子的左孩子就代表了区间 $(c - 1, c + n )$, 即 $[c, c + n - 1]$, 随便翻转即可.

然后随便写写就好了, 似乎也没有考虑讨论中说的毒瘤输入就过了...

### 代码

跑的似乎还很快? ($1.8\ s$).

```cpp
#include <bits/stdc++.h>

#define fa(x) t[x].fa
#define siz(x) t[x].siz
#define val(x) t[x].val
#define tag(x) t[x].tag
#define child(x, y) t[x].child[y]
#define rt t[1].child[1]

const int kMaxSize = 2e6 + 5;

struct node {
	int child[2], fa, siz; char val; bool tag;
} t[kMaxSize];
int cnt = 2;
inline void Cnct(int c, int f, int p) {fa(c) = f; child(f, p) = c;}
inline void Updata(int x) {siz(x) = siz(child(x, 0)) + siz(child(x, 1)) + 1;}
inline bool Which(int x) {return x == child(fa(x), 1);}
inline int NewNode(char val, int fa) {fa(cnt) = fa; val(cnt) = val; return cnt++;}
void PushTag(int x) {
	if(tag(x)) {
		child(x, 0) ^= child(x, 1) ^= child(x, 0) ^= child(x, 1);
		tag(child(x, 0)) ^= 1; tag(child(x, 1)) ^= 1;
		tag(x) = false;
	}
}
void Rotate(int &x) {
	int gfa = fa(fa(x)); bool p = Which(x), pfa = Which(fa(x));
	Cnct(child(x, p ^ 1), fa(x), p); Cnct(fa(x), x, p ^ 1); Cnct(x, gfa, pfa);
	Updata(child(x, p ^ 1)); Updata(x);
}
void Splay(int cur, int to = 1) {
	for(; fa(cur) != to; Rotate(cur)) {
		if(fa(fa(cur)) != to)
			Which(cur) == Which(fa(cur)) ? Rotate(fa(cur)) : Rotate(cur);
	}
}
void Build(int &cur, int fa, int l, int r, std::string &a) {
	if(l <= r) {
		int mid = (l + r) >> 1;
		cur = NewNode(a[mid], fa);
		Build(child(cur, 0), cur, l, mid - 1, a);
		Build(child(cur, 1), cur, mid + 1, r, a);
		Updata(cur);
	}
}
void Output(int cur = rt) {
	if(!cur) return;
	PushTag(cur);
	Output(child(cur, 0));
	if(val(cur)) printf("%c", val(cur));
	Output(child(cur, 1));
}
int FindKth(int k) {
	for(int cur = rt, tot = 0; ; tot++) {
		PushTag(cur);
		if(k == siz(child(cur, 0)) + 1) return cur;
		else if(k <= siz(child(cur, 0))) cur = child(cur, 0);
		else k -= siz(child(cur, 0)) + 1, cur = child(cur, 1);
	}
}
void Reverse(int x, int n) {
	Splay(FindKth(x - 1)); Splay(FindKth(x + n), rt);
	tag(child(child(rt, 1), 0)) ^= 1;
}
void Insert(int x, int ptr) { 
	Splay(FindKth(x - 1)); Splay(FindKth(x), rt);
	Cnct(ptr, child(rt, 1), 0);
	Updata(child(rt, 1)); Updata(rt);
}
void Delete(int x, int n) {
	Splay(FindKth(x - 1)); Splay(FindKth(x + n), rt);
	child(child(rt, 1), 0) = 0;
	Updata(child(rt, 1)); Updata(rt);
}

using std::cout;
using std::cin;

int q, curt = 2; std::string s;
int main() {
	std::ios::sync_with_stdio(false);
	cin >> q;
	s[1] = s[2] = 0;
	Build(rt, 1, 1, 2, s);
	while(q--) {
		std::string opt, str; int n;
		cin >> opt;
		if(opt == "Move") {
			cin >> n;
			if(n == 0) curt = 2;
			else curt = n + 2;
		} else if(opt == "Insert") {
			cin >> n;
			cin.ignore();
			getline(cin, str);
			str = " " + str;
			int ptr;
			Build(ptr, 1, 1, n, str);
			Insert(curt, ptr);
		} else if(opt == "Delete") {
			cin >> n;
			Delete(curt, n);
		} else if(opt == "Rotate") {
			cin >> n;
			Reverse(curt, n);
		} else if(opt == "Get") {
			int ptr = FindKth(curt);
			Splay(ptr);
			cout << val(ptr) << std::endl;
		} else if(opt == "Prev") curt--;
		else if(opt == "Next") curt++;
	}
	return 0;

}
```

---


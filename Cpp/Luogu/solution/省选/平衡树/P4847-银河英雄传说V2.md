# 银河英雄传说V2

## 题目背景

小H昨天看到了luogu P1196这一题，触发了他内心中对英雄的感慨/雾。可是无奈他不会这一题，只好去请教小W。在讲完那一题之后，小W灵机一动——不如改一下这道题吧。

于是，一个很水的签到题出现了。

## 题目描述

某dalao：把题目说简单一点，方便让我一分钟A掉！

于是小W只好把题意简化一下：

给定n个长度为1的序列，第i个序列中有一个元素，值为ai，接下来有三种操作：

1. `M x y`，表示把x所在的序列放到y所在的序列之后。如果x,y已经在同一个序列，则不进行操作。
2. `D x`，表示把x所在的序列中从x处断开，也就是把x及x之后的元素单独取出来作为一个序列。
3. `Q x y`，表示查询x到y之间（包括x和y）所有元素的值之和。如果x和y不在同一个序列之中，输出-1.

## 说明/提示

（出题人非常良心地给了一个大一点的样例！）

样例1解释：

首先有5个序列（一个横排为一个序列），排列如下：
```
1
2
3
4
5
```

第一个操作将1放到4的后面，变成
```
2
3
4,1
5
```

第二个操作将3放到2后面，变成
```
2,3
4,1
5
````

然后查询第5个元素到第2个元素之间的和，由于不存在，输出-1；

将3所在的序列加到4所在的序列后面，变成
```
4,1,2,3
5
```

接下来变成了5,4,1,2,3，也就是所有元素都在1个序列了，因此接下来的两个合
并操作没有用了，然后把1之后的数字删除，变成：

```
1,2,3
5,4
```

查询2到2，输出2的值，也就是55352；

查询2到1，输出2+1的值，也就是113122.


![Luogu](https://cdn.luogu.com.cn/upload/pic/30577.png)

~~为了避免某些乱搞（可能避免不了）~~，**前5个点按照传统方式计分，每个测试点10分；后五个点为subtask，必须全部通过才能得分，否则不得分。**

对于所有数据，1<=x,y<=n，1<=ai<=10^9

## 样例 #1

### 输入

```
5 10
57770 55352 18768 21847 79100 
M 1 4
M 3 2
Q 5 2
M 3 4
M 3 5
M 4 4
M 3 1
D 1
Q 2 2
Q 2 1
```

### 输出

```
-1
55352
113122
```

## 样例 #2

### 输入

```
30 100
2193 75245 24438 95450 96514 84854 15292 9488 37488 940 52991 15190 64052 17398 80379 77861 88717 34751 16783 88345 27612 21748 79776 43058 35590 49064 45012 37206 70870 30643 
M 18 26
M 28 27
M 25 4
M 12 22
M 26 15
M 3 1
M 20 20
M 7 21
M 18 29
M 21 26
M 29 10
M 27 23
M 30 28
M 22 10
M 13 21
M 1 23
M 25 9
M 29 27
M 23 25
M 11 12
M 1 4
M 26 14
M 26 9
D 4
M 16 8
M 16 20
M 4 27
M 9 20
M 11 1
M 19 8
Q 12 7
M 5 10
D 20
Q 29 2
Q 9 15
M 29 21
D 5
M 23 8
M 6 6
D 23
D 6
Q 4 8
D 21
Q 29 23
Q 19 4
M 21 21
M 20 25
M 27 29
D 2
Q 7 2
M 7 15
Q 11 18
D 26
Q 21 18
M 22 11
M 12 12
M 20 15
M 22 4
D 20
M 4 5
M 12 2
Q 27 20
M 30 2
M 28 9
M 20 11
M 10 21
M 12 24
Q 14 14
M 6 29
Q 13 18
Q 10 3
Q 23 3
D 4
M 27 13
M 6 23
M 7 14
Q 12 17
M 18 25
Q 2 19
D 3
D 9
Q 2 16
Q 3 8
Q 4 10
D 24
M 21 4
Q 17 15
Q 19 7
Q 1 24
Q 9 18
D 12
M 4 16
M 27 21
D 26
M 5 14
M 15 19
M 21 26
M 18 27
Q 21 8
Q 18 13
```

### 输出

```
52230
-1
-1
254468
291078
112233
-1
231636
62363
-1
17398
178645
25378
219268
-1
419122
347453
-1
-1
-1
274542
-1
269126
-1
178645
```

# 题解

## 作者：p_b_p_b (赞：14)

### 题外话

这题各位dalao都说是裸的LCT，就我一个人想到splay。。。

然后出题人也只想到LCT，而且跑得巨快，于是比赛时时限是1s。。。

又因为我是蒟蒻，自带大常数，竟然比LCT还慢。。。哭死

结果出题人善良地~~在比赛时卡我常数~~在赛后把时限调到2s



------------

### 正题

这题我一眼平衡树，又因为treap不熟，于是写了splay

一开始对于每个元素都建一棵splay。

若合并：

{

	设x合并到y后面

	朴素做法：
    
    x=getfa(x);y=getfa(y);
    if (x==y) return;
	while (rs[B]) B=rs[B];
	fa[A]=B;rs[B]=A;
	splay(A,0);

	卡常：加启发式即可
}

断开：

{

	splay(x,0);
    fa[ls[x]]=0;ls[x]=0;
    pushup(x)
    
}

查询：

{

	if (x==y) return a[x];
	fx=getfa(x);fy=getfa(y);
    if (fx!=fy) return -1;
    splay(x,0);splay(y,x);
    return rs[x]==y?a[x]+a[y]+sum[ls[y]]:a[x]+a[y]+sum[rs[y]];
    
}

完。



------------

### 代码

```cpp
#include<bits/stdc++.h>
#define sz 201010
using namespace std;
typedef long long ll;
struct FastIO
{
	inline FastIO& operator>>(int& x)
	{
		x=0;char f=0,ch=getchar();
		while(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();
		while(ch<='9'&&ch>='0') x=x*10+ch-48,ch=getchar();
		return x=(f?-x:x),*this;
	}
	inline FastIO& operator>>(ll& x)
	{
		x=0;char f=0,ch=getchar();
		while(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();
		while(ch<='9'&&ch>='0') x=x*10+ch-48,ch=getchar();
		return x=(f?-x:x),*this;
	}
	inline FastIO& operator>>(double& x)
	{
		x=0;char f=0,ch=getchar();
		double d=0.1;
		while(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();
		while(ch<='9'&&ch>='0') x=x*10+ch-48,ch=getchar();
		if(ch=='.')
		{
			ch=getchar();
			while(ch<='9'&&ch>='0') x+=d*(ch^48),d*=0.1,ch=getchar();
		}
		return x=(f?-x:x),*this;
	}
}read;

void file()
{
	#ifndef ONLINE_JUDGE
	freopen("a.txt","r",stdin);
	#endif
}

ll a[sz];

struct hh{int fa,dep,ch[2];ll sum;}tr[sz];

int getfa(int x){while (tr[x].fa) x=tr[x].fa;return x;}
void pushup(int x)
{
	tr[x].sum=tr[tr[x].ch[0]].sum+tr[tr[x].ch[1]].sum+a[x];
	tr[x].dep=max(tr[tr[x].ch[0]].dep,tr[tr[x].ch[1]].dep)+1;
}
bool get(int x){return tr[tr[x].fa].ch[1]==x;}
void rotate(int x)
{
	int y=tr[x].fa,z=tr[y].fa;
	int k=get(x),w=tr[x].ch[!k];
	if (z) tr[z].ch[get(y)]=x;tr[x].ch[!k]=y;tr[y].ch[k]=w;
	if (w) tr[w].fa=y;tr[x].fa=z;tr[y].fa=x;
	pushup(y);pushup(x);
}
void splay(int x,int to)
{
	while (tr[x].fa!=to)
	{
		int y=tr[x].fa;
		if (tr[y].fa!=to) rotate(get(x)==get(y)?y:x);
		rotate(x);
	}
}
void connect(int x,int y) //head[x]->tail[y]
{
	x=getfa(x);y=getfa(y);
	if (x==y) return;
	if (tr[x].dep>tr[y].dep)
	{
		while (tr[x].ch[0]) x=tr[x].ch[0];
		tr[x].ch[0]=y;tr[y].fa=x;
		splay(y,0);
	}
	else
	{
		while (tr[y].ch[1]) y=tr[y].ch[1];
		tr[y].ch[1]=x;tr[x].fa=y;
		splay(x,0);
	}
}
void cut(int x)
{
	splay(x,0);
	tr[tr[x].ch[0]].fa=0;tr[x].ch[0]=0;
	pushup(x);
}
ll query(int x,int y)
{
	if (x==y) return a[x];
	int fx=getfa(x),fy=getfa(y);
	if (fx!=fy) return -1;
	splay(x,0);splay(y,x);
	int ls=tr[y].ch[0],rs=tr[y].ch[1];
	return get(y)?tr[ls].sum+a[x]+a[y]:tr[rs].sum+a[x]+a[y];
}
int main()
{
	file();
	int n,m,i,x,y;
	read>>n>>m;
	for (i=1;i<=n;i++) read>>a[i];
	for (i=1;i<=n;i++) pushup(i);
	while (m--)
	{
		char ch;cin>>ch;
		if (ch=='M') read>>x>>y,connect(x,y);
		else if (ch=='D') read>>x,cut(x);
		else read>>x>>y,printf("%lld\n",query(x,y));
	}
}
```



------------

### 吐槽

出题人太恶心啦！！这份代码最慢的点跑了1200ms，比赛时时限1000ms！！！我的ＡＣ没啦！！！

---

## 作者：韵城小管家 (赞：11)

算是一道不错的非旋treap练手的题目吧。
读完题后，应该能想到题目就是要分裂合并一些序列，
于是就可以想到非旋treap啦！

首先要解决一个问题：如何表示x所在的序列呢？
代表一个序列的肯定是这个序列的树的根节点，
那么只要沿着x向上跳，一直跳到根结点就行啦！
不要担心，非旋treap的深度大约是log的，
所以找一次根节点就是log的了。

那么我们就要维护节点之间的父子关系，
应该不难想到，父子关系在merge和split的时候会改变，
那么每次merge之后就要维护merge完的节点的父亲，
每次split再单独记录split的两个节点的父亲，
这里可能比较绕（毕竟是在一个递归函数里），
看代码就好了。

那么如何得到节点在树中的排名呢？
这个在维护完父亲节点之后就非常简单了。
设排名为k，那么k先加上该节点的左子树大小，
然后一直往上跳，如果当前节点是右子树，
那么k加上左子树大小再加1，如果是左子树就不用加了（想想为什么？）
一直处理到根节点就可以返回k了。

现在来处理操作！

M操作直接分别get到x和y的根节点，然后合并他们就行了。

D操作先查询x的排名，在排名处split一下x的根节点就行了。

Q操作将x，y这段区间从根节点中split出来，直接查询即可。

代码：
```
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cstdlib>
using namespace std;
typedef long long ll;
const int N=200005;
struct FHQTREAP{
	int ls,rs,siz,rnd,fa;
	ll sum,val;
}tr[N];
#define lt tr[u].ls
#define rt tr[u].rs
void pushup(int u){
	tr[u].sum=tr[lt].sum+tr[u].val+tr[rt].sum;
	tr[u].siz=tr[lt].siz+1+tr[rt].siz;
}
int merge(int u,int v){
	if(!u||!v) return u^v;
	if(tr[u].rnd>tr[v].rnd){
		rt=merge(rt,v);
		tr[rt].fa=u;
		pushup(u);
		return u;
	}
	else{
		tr[v].ls=merge(u,tr[v].ls);
		tr[tr[v].ls].fa=v;
		pushup(v);
		return v;
	}
}
void split(int u,int k,int &x,int &y,int fx,int fy){
	if(!u){
		x=y=0;return;
	}
	if(k<=tr[lt].siz){
		y=u;
		split(lt,k,x,lt,fx,u);
	}
	else{
		x=u;
		split(rt,k-1-tr[lt].siz,rt,y,u,fy);
	}
	if(x) tr[x].fa=fx;
	if(y) tr[y].fa=fy;
	pushup(u);
}
int ances(int u){
	return (!tr[u].fa)?u:ances(tr[u].fa);
}
int getrnk(int u){
	int k=tr[lt].siz;
	while(tr[u].fa){
		if(tr[tr[u].fa].rs==u)
			k+=tr[tr[tr[u].fa].ls].siz+1;
		u=tr[u].fa;
	}
	return k+1;
}
int n,m;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld",&tr[i].val);
		tr[i].sum=tr[i].val;
		tr[i].fa=0;
		tr[i].rnd=rand();
		tr[i].siz=1;
	}
	while(m--){
		char opr[5];
		scanf("%s",opr);
		if(opr[0]=='M'){
			int u,v;
			scanf("%d%d",&u,&v);
			int au=ances(u),av=ances(v);
			if(au!=av)
				merge(av,au);
		}
		else if(opr[0]=='D'){
			int u;
			scanf("%d",&u);
			int k=getrnk(u);
			int x,y;
			split(ances(u),k-1,x,y,0,0);
		}
		else{
			int u,v;
			scanf("%d%d",&u,&v);
			int au=ances(u),av=ances(v);
			if(au!=av)
				printf("-1\n");
			else{
				int ku=getrnk(u);
				int kv=getrnk(v);
				if(ku>kv){
					swap(u,v);
					swap(ku,kv);
				}
				int x,y,z;
				split(au,kv,x,z,0,0);
				split(x,ku-1,x,y,0,0);
				printf("%lld\n",tr[y].sum);
				merge(merge(x,y),z);
			}
		}
	}
	return 0;
}
```

---

## 作者：qwaszx (赞：7)

做完这题内心:???这么暴力复杂度是对的吗???这题真的能LCT做吗???

~~反正能过就行~~

首先这题维护的$LCT$里全都是实链，没有虚链，我也不知道能拿来干什么

因为序列是有顺序的，所以并不可以换根

1. 把$x$所在序列$X$接到$y$所在序列$Y$上

先$findroot$判断是否在同一个$Splay$里，然后暴力找到$X$的队首、$Y$的队尾，把这两个连起来，然后在$X$的队尾那个地方$access$一下更新信息，总之暴力无比，我也不知道复杂度对不对

2. 断边

$splay$完直接断左儿子

3. 区间和

不能$findroot$就改成前缀和，然后维护一下$size$判断哪个在前面，然后暴力$splay$完查询.已经不知道多少个$splay$了.

这题因为维护的是很多条链所以直接$Splay/FHQ\ Treap$是一个更好的选择...我觉得$Splay$已经快被玩坏了...

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define nroot(x) (ch[f[x]][0]==x||ch[f[x]][1]==x)
using namespace std;
const int N=4e5;
long long s[N];
int f[N],size[N],ch[N][2],n,m,w[N];
void pushup(int x){s[x]=s[ch[x][0]]+s[ch[x][1]]+w[x];size[x]=size[ch[x][0]]+size[ch[x][1]]+1;}
void rotate(int x)
{
	int y=f[x],z=f[y],wh=ch[y][1]==x,w=ch[x][wh^1];
	if(nroot(y))ch[z][ch[z][1]==y]=x;
	ch[x][wh^1]=y,ch[y][wh]=w;
	f[x]=z,f[y]=x,f[w]=y;pushup(y);
}
void splay(int x)
{
	while(nroot(x))
	{
		int y=f[x],z=f[y];
		if(nroot(y))rotate((ch[y][1]==x)^(ch[z][1]==y)?x:y);
		rotate(x);
	}
	pushup(x);
}
void access(int x){for(int y=0;x;x=f[y=x])splay(x),ch[x][1]=y,pushup(x);}
void Link(int x,int y)
{
	splay(x);int tt=x;while(ch[x][0])x=ch[x][0];
	int t=y;splay(y);while(ch[t][0])t=ch[t][0];
	if(x==t)return;
	while(ch[y][1])y=ch[y][1];
	splay(x),f[x]=y;while(ch[tt][1])tt=ch[tt][1];access(tt);	
}
void cut(int x){splay(x),ch[x][0]=f[ch[x][0]]=0;pushup(x);}//直接断
long long query(int x,int y)
{
	splay(x);int tx=x,szx=size[ch[x][0]];long long sx=s[ch[x][0]];int wx=w[x];//splay完左儿子就是不含本身的前缀和
	while(ch[tx][0])tx=ch[tx][0];
	splay(y);int ty=y,szy=size[ch[y][0]];long long sy=s[ch[y][0]];int wy=w[y];
	while(ch[ty][0])ty=ch[ty][0];
	return tx==ty?(szx<szy?sy+wy-sx:sx+wx-sy):-1;//记size判断
} 
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",w+i),size[i]=1;
	for(int i=1;i<=m;i++)
	{
		int x,y;char st[2];
		scanf("%s%d",st+1,&x);
		switch(st[1])
		{
			case 'M':scanf("%d",&y),Link(x,y);break;
			case 'D':cut(x);break;
			case 'Q':scanf("%d",&y),printf("%lld\n",query(x,y));break;
		}
	}
 } 
 ```

---

## 作者：万万没想到 (赞：6)

原题传送门：[P4847 银河英雄传说V2](https://www.luogu.com.cn/problem/P4847)

解题思路：

大繁至简，我们可以先手模一下过程，开始的时候一共有 $n$ 个分散的序列，每个序列的大小是 $1$ ，初识时第 $i$ 序列里的唯一一个元素的值是 $val_i$ ，这个元素的标记值是 $i$ ，是不变的。

第一个操作是将标记值为 $x$ 所在的整个序列移动到标记值为 $y$ 的序列后面并合并两个序列，如果标记值为 $x$ 和标记值为 $y$ 所在的是同一个序列，则不需要进行此操作。

第二个操作是将标记值为 $x$ 所在的序列分裂成两部分，前一部分是 $x$ 之前的，后一部分是 $x$ 及 $x$ 以后的，注意，序列并不是按照标记值排序，而是按照分裂合并后的顺序排序，如 $15\ 14\ 13\ 12\ 11$ 的标记值是 $1\ 2\ 3\ 4\ 5$ 将标记值为 $1$ 的元素所在序列移到标记值为 $5$ 的元素所在的序列后面并合并，所呈现出的元素 $val$ 序列是 $14\ 13\ 12\ 11\ 15$ ，此时最后两个元素在同一序列内，如果要分裂标记值为 $5$ 的序列，那么分裂后的仍是 $14\ 13\ 12\ 11\ 15$ ，但最后两个元素已不在同一个序列内了。

第三个操作是查询同一个序列内标记值为 $x$ 的元素到标记值为 $y$ 的元素的和，如上面的例子，当标记值为 $5\ 1$ 的序列元素值为 $11\ 15$ 我们查询 $5\ 1$ 和 $1\ 5$ 是等价的，当然如果两个标记值不在同一序列内就输出 $-1$ 。

接下里我们提炼一下，在里面出现频率最多的除了标记值就是分裂、合并，再品味一下，分裂，合并，序列，查询。

### fhq-treap!

如果你不知道fhq-treap是什么，给出一篇luogu日报。

[洛谷日报第43期 [Chanis]不用旋转的treap？——fhq treap](https://www.luogu.org/blog/Chanis/fhq-treap)

如果你对fhq-treap的性质不甚明了，给出自己的一篇博客，里面第一篇就是fhq-treap。

[论算法及数据结构](https://www.luogu.com.cn/blog/85514/lun-ping-heng-shu)

如果你认真阅读并理解了，相信你已经对fhq-treap有一定的理解了，不论我们怎么分裂合并fhq-treap，只有好好地pushup，就可以保证平衡树维护结点的正确性。

那么这一题就是fhq-treap的普通操作了，初始情况下我们有 $n$ 颗大小为 $1$ 的平衡树，合并就正常合并，分裂就正常分裂，但我们需要注意的是合并的标记值所在的序列而非标记值所在的元素，所以一个序列的代表就是它的根节点，我们不需要记录它，记录了反而复杂度更大，只需要维护每一个结点的父亲，一直往上跳，就可以找到根节点，需要注意的是，根节点的父亲为 $0$ ，由于平衡树的树深大概是 $\log(n)$ 的，所以可以很优秀地找到树根并合并。

我们要分裂时如何分裂，我们需要找到标记值为 $x$ 的元素是这个序列中的第几个，只需要一直往上跳父亲就好了，因为一个子树的根节点排名大于左子树的排名，先加上左子树大小加一，如果这个点是其父亲右儿子，则加上父亲的左子树大小加一，否则不加，再跳到父亲，直到根节点就可以了。

注意！进行分裂操作时虽然每个节点的值保证正确，但父亲必须是在其有父亲的情况下才会pushup，所以分裂出的两个子树的根节点的父亲不会清零，需要手动清零。

然后这题就没了，最后提醒：不开longlong见祖宗，开了longlong返回int照样见祖宗（别问我怎么知道的。）

代码如下：

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int maxn=2e5+5;
int n,m,cnt,x,y,z;
struct node{
	int ls,rs,fa,val,siz,rnd;
	LL sum;
}tree[maxn];
void new_node(int i,int v){
	tree[i].siz=1,tree[i].sum=tree[i].val=v,tree[i].rnd=rand();
}
void pushup(int now){
	tree[now].siz=tree[tree[now].ls].siz+tree[tree[now].rs].siz+1;
	tree[now].sum=tree[tree[now].ls].sum+tree[tree[now].rs].sum+tree[now].val;
	tree[tree[now].ls].fa=tree[tree[now].rs].fa=now;
}
void split(int now,int k,int &x,int &y){
	if(!now){x=y=0;return;}
	if(k<=tree[tree[now].ls].siz)y=now,split(tree[now].ls,k,x,tree[now].ls);
	else x=now,split(tree[now].rs,k-tree[tree[now].ls].siz-1,tree[now].rs,y);
	pushup(now);
}
int merge(int u,int v){
	if(!u||!v)return u|v;
	if(tree[u].rnd<tree[v].rnd){
		tree[u].rs=merge(tree[u].rs,v);
		pushup(u);
		return u;
	}
	else{
		tree[v].ls=merge(u,tree[v].ls);
		pushup(v);
		return v;
	}
}
int get(int now){
	while(tree[now].fa)now=tree[now].fa;
	return now;
}
void mymerge(int a,int b){
	a=get(a),b=get(b);
	if(a!=b)merge(b,a);
}
int mykth(int now){
	int cnt=tree[tree[now].ls].siz+1;
	while(now){
		if(tree[tree[now].fa].rs==now)cnt+=(tree[tree[tree[now].fa].ls].siz+1);
		now=tree[now].fa;
	}
	return cnt;
}
void mysplit(int a){
	int root=get(a);
	a=mykth(a);
	split(root,a-1,x,y);
	tree[x].fa=0,tree[y].fa=0;
}
LL query(int a,int b){
	int tmpx=get(a),tmpy=get(b);
	if(tmpx!=tmpy)return -1;
	int c=mykth(a),d=mykth(b);
	if(c>d)swap(c,d);
	split(tmpx,d,x,z);
	split(x,c-1,x,y);
	LL tmpz=tree[y].sum;
	merge(merge(x,y),z);
	return tmpz;
}
int main(){
	srand((unsigned)time(NULL));
	int a,b;
	char opt[5];
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		scanf("%d",&a);
		new_node(i,a);
	}
	for(int i=1;i<=m;++i){
		scanf("%s%d",opt,&a);
		if(opt[0]=='M'){
			scanf("%d",&b);
			mymerge(a,b);
		}
		else if(opt[0]=='D'){
			mysplit(a);
		}
		else{
			scanf("%d",&b);
			printf("%lld\n",query(a,b));
		}	
	}
	return 0;
}
```


---

## 作者：GKxx (赞：6)

这是一篇由懒人GKxx写的懒人题解。

先简单看一眼操作：合并，分裂，区间和查询，非常的模板。而且这里的合并是把一个序列整体接在另一个序列后面，所以根本不需要启发式合并，只要正常的平衡树合并即可。对于非旋treap，就是正常的merge操作；对于splay，只要把两个树根$X,Y$找到，在$X$树中找到最靠右的点转到根，把$Y$接到右孩子上就好了。

分裂其实也是裸的平衡树分裂，如果是非旋treap的话得先查询结点$x$的排名，再按排名分裂；splay就直接把$x$splay到根，把右孩子断了即可。

查询就正常提取区间即可。

但是由于我实在是太懒了，所以我写的不是纯种的splay，而是单旋的spaly。这都能不被卡，不得不说出题人是真的良心。。。

为什么写spaly呢。。。考虑这样一个操作：

```cpp
spaly(x); spaly(y);
```

如果x和y在同一棵子树里，那么这行代码执行完之后，x一定是y的左孩子或右孩子。双旋是没有这样的性质的。

于是我就借助这个性质简化了部分代码。

仅供参考，正式考试时写spaly小心被卡。。。

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>

template <typename T> inline void read(T& x) {
    int f = 0, c = getchar(); x = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) x = x * 10 + c - 48, c = getchar();
    if (f) x = -x;
}
template <typename T, typename... Args>
inline void read(T& x, Args&... args) {
    read(x); read(args...); 
}
template <typename T> void write(T x) {
    if (x < 0) x = -x, putchar('-');
    if (x > 9) write(x / 10);
    putchar(x % 10 + 48);
}
template <typename T> void writeln(T x) { write(x); puts(""); }

typedef long long LL;
const int maxn = 2e5 + 207;
int fa[maxn], ch[maxn][2], value[maxn];
LL sum[maxn];
int n, m;

inline int iden(int x) {
	return ch[fa[x]][0] == x ? 0 : (ch[fa[x]][1] == x ? 1 : -1);
}
inline void update(int x) {
    sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + value[x];
}
inline void rotate(int x) {
    int d = iden(x), y = fa[x];
    if (~iden(y)) ch[fa[y]][iden(y)] = x;
    fa[x] = fa[y];
    if ((ch[y][d] = ch[x][d ^ 1])) fa[ch[x][d ^ 1]] = y;
    fa[ch[x][d ^ 1] = y] = x;
    update(y); update(x);
}
inline void spaly(int x) {
    while (fa[x]) rotate(x);
}
inline void merge(int x, int y) {
    if (x == y) return;
    spaly(x); spaly(y);
    if (ch[y][0] == x || ch[y][1] == x) return;
    int z = x;
    while (ch[z][1]) z = ch[z][1];
    spaly(z);
    fa[ch[z][1] = y] = z;
    update(z);
}
inline void split(int x) {
    spaly(x);
    fa[ch[x][1]] = 0;
    ch[x][1] = 0;
    update(x);
}
inline LL query(int x, int y) {
    if (x == y) return value[x];
    spaly(x); spaly(y);
    if (ch[y][0] == x) return sum[ch[x][1]] + value[x] + value[y];
    else if (ch[y][1] == x) return sum[ch[x][0]] + value[x] + value[y];
    else return -1;
}

int main() {
    read(n, m);
    for (int i = 1; i <= n; ++i) read(value[i]), sum[i] = value[i];
    for (int i = 1; i <= m; ++i) {
        int c = getchar(); while (isspace(c)) c = getchar();
        if (c == 'M') {
            int x, y; read(x, y);
            merge(x, y);
        } else if (c == 'D') {
            int x; read(x);
            split(x);
        } else {
            int x, y; read(x, y);
            writeln(query(x, y));
        }
    }
    return 0;
}
```

---

## 作者：Prean (赞：6)

# 题目大意
维护若干个序列，资瓷一下操作：

1. 将两个序列拼接在一起

2. 将一个序列从某处断开

3. 查询两点之间权值和

又看这个题目，就是在银河英雄传说的基础上面加了可以断开的操作，而且并查集本质是一座森林，在比线性还要快的时间内维护森林，想到LCT。

而且这道题的确是LCT。。。不过由于题目的特殊性，每颗Splay维护的是一条链，并不需要Access操作。

并且，Splay和rotate操作也不需要改动。（因为题目的特殊性，这道题没有虚边）

要拼接到一起，我们只需要寻找一个节点末尾和另一个节点的根节点，连接即可。

所以有了以下两个操作：
```cpp
inline int findroot(int u){
    Splay(u);
    while(chi[u][0])u=chi[u][0];
    Splay(u);
    return u;
}
inline int findleaf(int u){
    Splay(u);
    while(chi[u][1])u=chi[u][1];
    Splay(u);
    return u;
}
```
看函数名也能看懂这两个函数在干嘛吧qwq

因为是维护的是一条链，所以并不需要Access操作，直接Splay就完了QAQ

然后就是连接和断开操作了，特别板子：
```cpp
inline void link(int u,int v){
    if(findroot(u)==findroot(v))return;
    connect(findroot(u),findleaf(v),1);
}
inline void cut(int u){
    Splay(u);
    f[chi[u][0]]=0;
    chi[u][0]=0;
}
```
看到没有，代码如此简洁。

然后链上求和，直接前缀和减前缀和，最后判断一下哪个节点深度更浅，加上该节点的权值。（因为被算掉了QAQ）

因为没有负权，并不需要Splay判断左子树大小，直接比较前缀和即可。

这部分代码：
```cpp
inline ll Sum(int u){
    Splay(u);
    return siz[chi[u][0]]+val[u];
}
inline ll Query(int u,int v){
    if(findroot(u)!=findroot(v))return -1;
    ll a=Sum(u),b=Sum(v);
    if(a>b)return a-b+val[v];
    else return b-a+val[u];
}
```
说了这么多，最后做一道填空题吧：三年（       ）一场空，不开（       ）见祖宗。

代码给一下吧：
```cpp
#include<iostream>
const int M=2e5+5;
typedef long long ll;
int f[M],chi[M][2];
ll val[M],siz[M];
int n,m;
inline bool son(int u){
    return chi[f[u]][1]==u;
}
inline void connect(int u,int v,bool son){
    f[u]=v;chi[v][son]=u;
}
inline void update(int u){
    siz[u]=siz[chi[u][0]]+siz[chi[u][1]]+val[u];
}
inline void rotate(int x){
    int y=f[x],z=f[y],f1=son(x),f2=son(y);
    connect(chi[x][!f1],y,f1);
    connect(x,z,f2);
    connect(y,x,!f1);
    update(y);
}
inline void Splay(int u){
    for(int v;v=f[u];rotate(u))if(f[v]){
        rotate(son(u)^son(v)?u:v);
    }
    update(u);
}
inline int findroot(int u){
    Splay(u);
    while(chi[u][0])u=chi[u][0];
    Splay(u);
    return u;
}
inline int findleaf(int u){
    Splay(u);
    while(chi[u][1])u=chi[u][1];
    Splay(u);
    return u;
}
inline void link(int u,int v){
    if(findroot(u)==findroot(v))return;
    connect(findroot(u),findleaf(v),1);
}
inline void cut(int u){
    Splay(u);
    f[chi[u][0]]=0;
    chi[u][0]=0;
}
inline ll Sum(int u){
    Splay(u);
    return siz[chi[u][0]]+val[u];
}
inline ll Query(int u,int v){
    if(findroot(u)!=findroot(v))return -1;
    ll a=Sum(u),b=Sum(v);
    if(a>b)return a-b+val[v];
    else return b-a+val[u];
}
signed main(){
    int i;
    std::cin>>n>>m;
    for(i=1;i<=n;++i)std::cin>>val[i];
    for(i=1;i<=m;++i){
        char s;int u,v;
        std::cin>>s;
        if(s=='M'){
            std::cin>>u>>v;
            link(u,v);
        }
        if(s=='Q'){
            std::cin>>u>>v;
            std::cout<<Query(u,v)<<'\n';
        }
        if(s=='D'){
            std::cin>>u;
            cut(u);
        }
    }
}
```
不过这道题还可以用FHQ直接做，思路也很好想。不过要注意维护父指针QAQ

---

## 作者：_luanyi_ (赞：5)

一眼下去 LCT。  
~~原谅我 LCT 调了整整一天。~~  
可以发现，本题其实就是有 $n$ 个点，每个点有一个权值，需要支持以下三种操作：
 - 将两条链合并为一条链；
 - 将一条链断为两条链；
 - 判断两点连通性及求两点之间路径上的点权值和。

像这种又断边又连边动态维护树上信息，可以试试 LCT。  
由于本题每个节点最多一个孩子（因为是链），所以 LCT 没有虚边。  

***

接下来考虑每一个操作。
 - 合并：先判断是否连通，分别去找两个节点所在链的最深的点（LCT 上表现为所在 splay 的根节点一直跳右儿子能跳到的最远的点）和最浅的点（LCT 上表现为所在 splay 的根节点一直跳左儿子能跳到的最远的点），直接 `link` 即可。
 - 断边：只给一个参数，需要自行去找链上上一个节点。在 LCT 上有一个 trick :把它 splay 为当前 splay 的根，它的左子树就是需要分离的部分（链上深度都比它本身小），直接断边即可。
 - 查询：先判断连通性，考虑维护从链顶到该节点路径上点权值和（也就是维护前缀和，在 LCT 上表现为维护左子树的和加上本身节点权值），两个节点前缀和作差得到答案。  
 
***

需要注意的点：
 - `long long`
 - 如果你的代码去除了 `access` 等有关虚子树一类的操作，务必注意 `link` 的时候连双向边，`cut` 的时候断双向边，注意先 `f[ls (p)] = 0` ，再 `ls (p) = 0` 。~~（血泪史）~~  
 
***

**code**  

```cpp
#include <bits/stdc++.h>
#define fq(i,a,b) for (int i = (a); i <= (b); i++)
#define fnq(i,a,b) for (int i = (a); i < (b); i++)
#define nfq(i,a,b) for (int i = (a); i >= (b); i--)
#define nfnq(i,a,b) for (int i = (a); i > (b); i--)
#define fqs(i,a,b,c) for (int i = (a); i <= (b); i += (c))
#define fnqs(i,a,b,c) for (int i = (a); i < (b); i += (c))
#define nfqs(i,a,b,c) for (int i = (a); i >= (b); i -= (c))
#define nfnqs(i,a,b,c) for (int i = (a); i > (b); i -= (c))
#define elif else if
using namespace std;
#define int long long

inline int rd () {
	int f = 1;
	char ch = getchar ();
	while (!isdigit (ch)) (ch == '-' ? (f = -1) : 0), ch = getchar ();
	int num = 0;
	while (isdigit (ch)) num = num * 10 + ch - '0', ch = getchar ();
	return num * f;
}
#define d rd ()

// 不支持虚子树有关的 LCT
const int maxn = 200200;
int ch[maxn][2], f[maxn], sum[maxn], val[maxn], tag[maxn];
#define ls(p) ch[p][0]
#define rs(p) ch[p][1]
void push_up (int p) {sum[p] = sum[ls (p)] + sum[rs (p)] + val[p];}
bool isroot (int p) {return p && ls (f[p]) != p && rs (f[p]) != p;}
void rev (int p) {swap (ls (p), rs (p)); tag[p] ^= 1;}
void push_down (int p) {if (tag[p]) {if (ls (p)) rev (ls (p)); if (rs (p)) rev (rs (p)); tag[p] = 0;}}
int which (int p) {return ch[f[p]][1] == p;}
void connect (int p, int fa, int w) {ch[fa][w] = p, f[p] = fa;}
void rotate (int p) {
	int fa = f[p], ffa = f[fa], wp = which (p), wfa = which (fa), pson = ch[p][wp ^ 1];
	if (!isroot (fa)) connect (p, ffa, wfa); else f[p] = ffa;
	connect (pson, fa, wp); connect (fa, p, wp ^ 1); push_up (fa); push_up (p);
}
void push_all (int p) {if (!isroot (p)) push_all (f[p]); push_down (p);}
void splay (int p) {
	push_all (p);
	for (int fa; fa = f[p], !isroot (p); rotate (p)) if (!isroot (fa))
		rotate (which (fa) == which (p) ? fa : p);
}
int find (int p, int w) {
	splay (p); push_down (p);
	while (ch[p][w]) push_down (ch[p][w]), p = ch[p][w];
	splay (p); return p; 
}
#define findroot(p) find(p, 0)
#define findleaf(p) find(p, 1)
void cut (int p) {splay (p); f[ls (p)] = 0; ls (p) = 0; push_up (p);}
int sm (int p) {splay (p); return sum[ls (p)] + val[p];}
signed main () {
	int n = d, m = d;
	fq (i, 1, n) val[i] = d;
	while (m--) {
		char op[10]; scanf ("%s", op);
		if (op[0] == 'M') {
			int x = d, y = d;
			// link 放 main 里面了
			if (findroot (x) != findroot (y))
				f[findroot (x)] = findleaf (y), rs (findleaf (y)) = findroot (x), push_up (findleaf (y));
		} elif (op[0] == 'D') cut (d); 
		else {
			int x = d, y = d;
			if (findroot (x) != findroot (y)) puts ("-1");
			else {
				int vx = sm (x), vy = sm (y);
				printf ("%lld\n", (vx > vy ? vx - vy + val[y] : vy - vx + val[x]));
			}
		}
	}
	return 0;
}
```


---

## 作者：cheng2010 (赞：4)

# 题解：P4847 银河英雄传说V2

## 前言：
这道题是我第一道~~误交~~看过题面的紫题，就写一篇题解纪念一下吧。

## 一、题意
1. 将两段区间合并为一条区间；
2. 将一段区间分裂为两段区间；
3. 判断两点连通性及求两点之间路径上的点权值和。

## 二、思路
分裂？合并？FHQ_treap！

但是，treap 都是认父不认子，而操作都是对于某个节点，怎么办？

考虑维护每个节点的父亲，操作时，不断往上跳找根。

现在就来看看具体的过程吧！

- ##### 操作一

找到两个节点的根，直接合并。

- ##### 操作二
找到 $x$ 在子树中的排名，再按大小分裂。

- ##### 操作三
在分裂、合并时，维护一下区间和。

## 三、code
```cpp
#include<bits/stdc++.h>
#define tp_rt Tree.root
#define int long long//图省事
#define INF 21474836470000000
using namespace std;
const int N=1e6+7;
int n,m;
struct FHQ_treap
{
	int lson,rson,siz,rnd,val,sum;
	int fa; 
}tree[N];
struct FHQ_TREAP
{
	int cnt;
	int root;
	inline void change(int x)
	{
		tree[x].siz=tree[tree[x].lson].siz+tree[tree[x].rson].siz+1;
		tree[x].sum=tree[x].val;
		if(tree[x].lson) tree[x].sum+=tree[tree[x].lson].sum,tree[tree[x].lson].fa=x;
		if(tree[x].rson) tree[x].sum+=tree[tree[x].rson].sum,tree[tree[x].rson].fa=x;
	}
	inline int get_rt(int x)
	{
		while(tree[x].fa) x=tree[x].fa;
		return x;
	}
	inline void split_siz(int now,int key,int &x,int &y)
	{
		if(!now)
		{
			x=y=0;
			return;
		}
		if(tree[tree[now].lson].siz+1<=key)
		{
			x=now;
			split_siz(tree[now].rson,key-1-tree[tree[now].lson].siz,tree[now].rson,y);
		}
		else
		{
			y=now;
			split_siz(tree[now].lson,key,x,tree[now].lson);
		}
		change(now);
	}
	inline int merge(int x,int y)
	{
		if(!x||!y) return x|y;
		if(tree[x].rnd<tree[y].rnd)
		{
			tree[x].rson=merge(tree[x].rson,y);
			change(x);
			return x; 
		}
		tree[y].lson=merge(x,tree[y].lson);
		change(y);
		return y;
	}
	inline int kth(int now)
	{
		int cnt=tree[tree[now].lson].siz+1;
		while(now)
		{
			if(tree[tree[now].fa].rson==now)
			{
				cnt+=(tree[tree[tree[now].fa].lson].siz+1);
			}
			now=tree[now].fa;
		}
		return cnt;
	}
}Tree;
signed main()
{
	srand(time(NULL));
	scanf("%lld %lld",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&tree[i].val);
		tree[i].sum=tree[i].val;
		tree[i].siz=1;
		tree[i].rnd=rand();
	}
	while(m--)
	{
		char opt;
		int x,y;
		cin>>opt;
		scanf("%lld",&x);
		if(opt=='M')
		{
			scanf("%lld",&y);
			int r1=Tree.get_rt(x);
			int r2=Tree.get_rt(y);
			if(r1!=r2) Tree.merge(r2,r1);//记得是插入到后面
		}
		else if(opt=='D')
		{
			int rt=Tree.get_rt(x),r1,r2;
			x=Tree.kth(x);
			Tree.split_siz(rt,x-1,r1,r2);
			tree[r1].fa=0;
			tree[r2].fa=0;
		}
		else if(opt=='Q')
		{
			scanf("%d",&y);
			int rt_x=Tree.get_rt(x),rt_y=Tree.get_rt(y),r1,r2,r3;
			if(rt_x!=rt_y)
			{
				puts("-1");
				continue;
			}
			int siz_x=Tree.kth(x);
			int siz_y=Tree.kth(y);
			if(siz_x>siz_y) swap(siz_x,siz_y);
			Tree.split_siz(rt_x,siz_y,r1,r3);
			Tree.split_siz(r1,siz_x-1,r1,r2);
			printf("%lld\n",tree[r2].sum);
			Tree.merge(Tree.merge(r1,r2),r3);
		}
	}
}
```

---

## 作者：yijan (赞：2)

裸的平衡树（原本想找lct的题做结果看到这个评分有误+完全不需要lct的题。。

但是有题解中提到splay的常数貌似写炸了（维护了个dep）。。~~我写splay其实也是因为不会treap~~

但其实splay写这个还是很优秀的吧，代码长度不到2k，加了读优后不吸氧500ms+，吸氧才不到300ms。。空间才5.1m（最优解第一页貌似没看到空间更小的了？

------

solution:

把x的序列放在y之后，先splay x再splay y，如果此时x不是根，显然y和x在一棵树上。然后直接找y为根的树上最右边的节点u（直接用系统栈递归一下就好了），把u和x连边然后递归回来的时候pushup一下。（这里貌似由于深度不深，经尝试递归比自己写栈还快）

cut操作，直接把xsplay到根，然后把x和左儿子的连边切断，最后pushup

询问操作，如果x和y一样直接返回val[x]（废话），否则先splayx，记录左子树的子树和，再splay y，记录左子树的子树和。同样如果splay y之后x本身还是树的根，显然它们不再一个树上，不考虑。否则看看x和y谁左子树小，类似地做个前缀和的差就好了。

Code:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
#define MAXN 200006
int n , m;

int read() {
    char ch = ' '; int x = 0;
    while( ch > '9' || ch < '0' ) ch = getchar();
    while( ch <= '9' && ch >= '0' ) { x *= 10,x += ch - '0',ch = getchar(); }
    return x;
}

int ch[MAXN][2] , fa[MAXN] , val[MAXN];
ll sw[MAXN];

inline void pushup( int x ) {
    sw[x] = sw[ch[x][0]] + sw[ch[x][1]] + val[x];
}
inline void rotate( int u ) {
    int f = fa[u] , g = fa[f] , w = ch[f][1] == u , k = ch[u][w^1];
    if( g ) ch[g][ch[g][1]==f] = u; ch[u][w^1] = f , ch[f][w] = k;
    if( k ) fa[k] = f; fa[f] = u , fa[u] = g;
    pushup( f ) , pushup( u );
}
inline void splay( int u ) {
    int f , g;
    while( fa[u] ) {
        f = fa[u] , g = fa[f];
        if( g ) rotate( ( (ch[g][1]==f) ^ (ch[f][1]==u) ) ? u : f );
        rotate( u );
    }
}
void update( int x , int y ) {
    if( ch[x][1] ) update( ch[x][1] , y );
    else ch[x][1] = y , fa[y] = x;
    pushup( x );
}
inline void pb( int x , int y ) {
    if( x == y ) return;
    splay( x ) , splay( y );
    if( fa[x] ) return;
    update( y , x );
}
inline void cut( int x ) {
    splay( x );
    fa[ch[x][0]] = 0 , ch[x][0] = 0;
    pushup( x );
}
inline ll que( int x , int y ) {
    if( x == y ) return (ll)val[x];
    ll resx , resy;
    splay( x ) , resx = sw[ch[x][0]];
    splay( y ) , resy = sw[ch[y][0]];
    if( !fa[x] ) return -1;
    if( resx > resy ) return resx - resy + val[x];
    else return resy - resx + val[y];
}

int main() {
// 	freopen("input","r",stdin);
    cin >> n >> m;
    for( int i = 1 ; i <= n ; ++ i ) val[i] = read();
    char opt[3]; int x , y;
    while( m-- ) {
        scanf("%s",opt);
        if( opt[0] == 'M' ) {
            x = read() , y = read();
            pb( x , y );
        } else if( opt[0] == 'D' ) {
            x = read();
            cut( x );
        } else if( opt[0] == 'Q' ) {
            //cout << ch[1][0] << endl;
            x = read() , y = read();
            printf("%lld\n",que( x , y ));
        } 
    }
}//qwq
```



---

## 作者：devout (赞：2)

这道题有合并和分裂，可以联想到是一个$fhq\ treap$的题，当然用$splay$也是可以做的 ~~而且是不是splay更好写~~

先说常数大的$splay$

显然我们需要维护每个点所在子树的根，并查集是不行的，因为不能路径压缩，所以直接一直无脑往上跳就好了，反正复杂度还是一个$\log$

`M x y`因为合并后排名$x$一定都比$y$大，所以我们找到$y$里面排名最大的，然后把$x$整体接过来，然后再转上去就好

```cpp
void link(int x,int y){// x->y
    int u=y;
    while(son[u][1])u=son[u][1];
    son[u][1]=x,fa[x]=u;
    splay(x,0);
}
```

`D x`把$x$转到根，然后断掉左儿子就可以

```cpp
void cut(int x){
    splay(x,0);
    son[x][0]=fa[son[x][0]]=0;
    update(x);
}
```

`Q x y`这个很简单，正常的区间查询。把$x$转到根，$y$转到根的右儿子，右儿子的左儿子维护一个$sum$就可以。但是因为这题$x$，$y$谁在前谁在后不知道，所以分三种情况讨论（$x=y$需要特判）

```cpp
ll query(int x,int y){//[x,y]
    splay(x,0),splay(y,x);
    return sum[son[y][0]]+a[x]+a[y];
}

in main
    if(s[0]=='Q'){
        read(y);
        if(getfa(x)!=getfa(y)){puts("-1");continue;}
        int rkx=rnk(x),rky=rnk(y);
        if(rkx==rky)printf("%d\n",a[x]);
        else if(rkx<rky)printf("%lld\n",query(x,y));
        else printf("%lld\n",query(y,x));
    }
```

求$rnk$什么的都很简单，不说了

我的代码跑了$1.30s$（无氧），成功的被各种吊打。

****

接下来说一下$fhq\ treap$的做法

因为需要求根，所以我们需要维护一个每个点父亲节点

`M x y`找到$x,y$各自的根，然后$merge(y,x)$要把$x$接在$y$后面！！！

`D x`找到$x$的位置，然后**按照排名**$split(root(x),a,b,rnk(x)-1)$

`Q x y`先把排名$[1,rky]$的部分拎出来，然后在把$[rkx,rky]$的部分拎出来，求出答案再合并回去就好

但是这个父亲节点非常的恶心，怎么更新呢？这里我用的是一种无脑做法，改一下$update$

```cpp
void update(int x){
    siz[x]=siz[son[x][0]]+siz[son[x][1]]+1;
    sum[x]=sum[son[x][0]]+sum[son[x][1]]+val[x];
    if(son[x][0])fa[son[x][0]]=x;
    if(son[x][1])fa[son[x][1]]=x;
    if(son[fa[x]][0]!=x&&son[fa[x]][1]!=x)fa[x]=0;
}
```

这样就可以在$merge,split$的时候更新了，还不用乱七八糟的判断

然后就是代码了，这个代码不开$O2$是跑了$700+ms$，成功吊打$splay$/kk

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=2e5+5;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n,m;
int fa[N],son[N][2],siz[N],val[N],treap[N];
ll sum[N];
int rt,a,b,c;

void update(int x){
    siz[x]=siz[son[x][0]]+siz[son[x][1]]+1;
    sum[x]=sum[son[x][0]]+sum[son[x][1]]+val[x];
    if(son[x][0])fa[son[x][0]]=x;
    if(son[x][1])fa[son[x][1]]=x;
    if(son[fa[x]][0]!=x&&son[fa[x]][1]!=x)fa[x]=0;
}

int merge(int u,int v){
    if(!u||!v)return u|v;
    int rt;
    if(treap[u]<treap[v])son[rt=u][1]=merge(son[u][1],v);
    else son[rt=v][0]=merge(u,son[v][0]);
    return update(rt),rt;
}

void split(int o,int &u,int &v,int k){
    if(!o){u=v=0;return;}
    int rank=siz[son[o][0]]+1;
    if(rank<=k)split(son[u=o][1],son[o][1],v,k-rank);
    else split(son[v=o][0],u,son[o][0],k);
    update(o);
}

int getfa(int x){
    while(fa[x])x=fa[x];
    return x;
}

int rnk(int x){
    int res=siz[son[x][0]]+1;
    while(fa[x]){
        if(son[fa[x]][1]==x)res+=siz[son[fa[x]][0]]+1;
        x=fa[x];
    }
    return res;
}

int main()
{
    srand(19260817);//一般这里可以设成自己的生日(雾
    read(n),read(m);
    Rep(i,1,n){
        read(val[i]);
        sum[i]=val[i];
        fa[i]=son[i][0]=son[i][1]=0;
        siz[i]=1;
        treap[i]=rand();
    }
    Rep(i,1,m){
        char opt[10];
        int x,y;
        scanf("%s",opt);
        read(x);
        if(opt[0]=='M'){
            read(y);
            x=getfa(x),y=getfa(y);
            if(x!=y)merge(y,x);
        }
        if(opt[0]=='D'){
            int fx=getfa(x),rank=rnk(x);
            split(fx,a,b,rank-1);
        }   
        if(opt[0]=='Q'){
            read(y);
            int fx=getfa(x),fy=getfa(y);
            if(fx!=fy){puts("-1");continue;}
            int rx=rnk(x),ry=rnk(y);
            if(rx>ry)swap(rx,ry);
            split(fx,a,c,ry);
            split(a,a,b,rx-1);
            printf("%lld\n",sum[b]);
            merge(merge(a,b),c);
        }
    }
    return 0;
}
```


---

## 作者：warzone (赞：1)

这是一道练习**带父指针** $\text{Splay}$ 的好题
### 为什么要带父指针
一般情况下，我们只需要平衡树实现二叉查找的功能，这个每种平衡树都可以做到   
另外很多时候，我们希望用平衡树实现和线段树一样的序列操作，  
这里OI中几乎全部通过 $\text{Splay,fhq-treap}$ 实现，  
尤其是 $\text{fhq-treap}$，实现方便，便于可持久化

但是，当序列操作是基于节点而不是序号的时候（如LCT），  
就必须带上父指针，而 $\text{Splay}$ 的带父指针实现则更加容易

### 带父指针 $\text{Splay}$ 的实现
带上父指针后，$\text{Splay}$ 的常数和码量将翻一倍，因此打的时候要非常的谨慎  
首先建好所需要的结构体
```cpp
typedef long long ll;
typedef unsigned int word;
struct splay{
	ll sum;
	word value,size;
	splay *l,*r,*fa;
	inline void pushup(){
		size=1,sum=value;
		if(l) size+=l->size,sum+=l->sum;
		if(r) size+=r->size,sum+=r->sum;
	}\\通过子节点更新父节点数据
}p[200010];
```
然后是左旋和右旋，注意修改节点的父指针(包括根节点)
```cpp
#define lcycle(root) do{			\
	register splay* oldroot=(root);	\
	register splay* oldr=(root)->r;	\
	register splay* oldrl=oldr->l;	\
	oldr->fa=oldroot->fa,(root)=oldr;		\
	(root)->l=oldroot,oldroot->fa=(root);	\
	if((root)->l->r=oldrl) oldrl->fa=(root)->l;	\
	(root)->l->pushup(),(root)->pushup();	\
}while(0)
#define rcycle(root) do{			\
	register splay* oldroot=(root);	\
	register splay* oldl=(root)->l;	\
	register splay* oldlr=oldl->r;	\
	oldl->fa=oldroot->fa,(root)=oldl;	\
	(root)->r=oldroot,oldroot->fa=(root);	\
	if((root)->r->l=oldlr) oldlr->fa=(root)->r;	\
	(root)->r->pushup(),(root)->pushup();	\
}while(0)
//注意这里传入的是根节点(不是被旋转的节点)，而且是传址调用
```
然后就是喜闻乐见的伸展操作了  
这里最大的难点是旋转时**必须传入父亲指向儿子的指针**，才可以保证同步修改  
```cpp
#define f(a) ((a)->fa)
#define pos(a) (f(a)->l==(a)? f(a)->l:f(a)->r)
//由原指针获取父亲指向儿子的指针
#define lsp()	\
	if(rff->l==f(root)){		\
		if(f(root)->l==root) rcycle(rff);	\
		else lcycle(rff->l);	\
		rcycle(rff);	\
	}	\
	else{	\
		if(f(root)->r==root) lcycle(rff);	\
		else rcycle(rff->r);	\
		lcycle(rff);	\
	}
//对于三个节点的链的伸展，注意旋转时传父亲指向儿子的指针
//lsp=link of splay(逃
inline void Splay(splay *root){
	while(f(root))
		if(f(f(root))){
			if(f(f(f(root)))){
				register splay*& rff=pos(f(f(root)));
				lsp();
			}//如果旋转不是根节点，就一定要改成父亲指向儿子的指针
			else{
				register splay* rff=f(f(root));
				lsp();
			}//否则的话直接传指针就是了
		}else if(root->fa->l==root){
			root=root->fa;rcycle(root);
		}else{root=root->fa;lcycle(root);}
     //对于最后两个节点的链，特判
}
```
最终的操作就很容易了

- `M x,y` 伸展 $p_x,p_y$ 到根，$p_y$ 左旋到最右端，接上 $p_x$  
	（必须是左旋，因为有 `pushup()`)
- `D x` 伸展 $p_x$ 到根，丢掉左儿子，`pushup()`
- `Q x y` 首先判定并调整先后顺序，在丢掉左右不需要的部分，输出答案后再接回来  
（注意接回来时考虑多余部分为空的情况） 


### 最终代码 
不开 O2 502ms，8.68MB  
开 O2 288ms，8.47MB 是目前最快的

```cpp
#include<string.h>
#include<stdio.h>
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int word;
struct READ{
	char c;
	inline READ(){c=getchar();}
	template<typename type>
	inline READ& operator >>(type & num){
		while('0'>c||c>'9') c=getchar();
		num=0;
		while('0'<=c&&c<='9'){
			num=(num<<1)+(num<<3)+(c-'0');
			c=getchar();
		}
		return *this;
	}
};//快读(同cin) 
class WRITE{
	private:
		char out[1<<20],*top;
	public:
		inline WRITE(){top=out;}
		inline ~WRITE(){
			if(top!=out) fwrite(out,1,top-out,stdout);}
		inline WRITE& operator <<(char c){
			*top=c;
			if(++top==out+(1<<20))
				fwrite(top=out,1,1<<20,stdout);
			return *this;
		}
		inline WRITE& operator <<(ull num){
			if(num==0) return *this;
			return *this<<num/10<<(char)(num%10+'0');
		}
		template<typename type>
		inline WRITE& operator <<(type num){
			if(num==0) return *this<<'0';
			if(num>0) return *this<<(ull)(num);
			return *this<<'-'<<(ull)(-num);
		}
}cout;//快写(同cout) 
struct splay{
	ll sum;
	word value,size;
	splay *l,*r,*fa;
	inline void pushup(){
		size=1,sum=value;
		if(l) size+=l->size,sum+=l->sum;
		if(r) size+=r->size,sum+=r->sum;
	}
}p[200010];
#define lcycle(root) do{	\
	register splay* oldroot=(root);	\
	register splay* oldr=(root)->r;	\
	register splay* oldrl=oldr->l;	\
	oldr->fa=oldroot->fa,(root)=oldr;		\
	(root)->l=oldroot,oldroot->fa=(root);	\
	if((root)->l->r=oldrl) oldrl->fa=(root)->l;	\
	(root)->l->pushup(),(root)->pushup();	\
}while(0)
#define rcycle(root) do{	\
	register splay* oldroot=(root);	\
	register splay* oldl=(root)->l;	\
	register splay* oldlr=oldl->r;	\
	oldl->fa=oldroot->fa,(root)=oldl;	\
	(root)->r=oldroot,oldroot->fa=(root);	\
	if((root)->r->l=oldlr) oldlr->fa=(root)->r;	\
	(root)->r->pushup(),(root)->pushup();	\
}while(0)
//旋转操作 
#define f(a) ((a)->fa)
#define pos(a) (f(a)->l==(a)? f(a)->l:f(a)->r)
#define lsp()	\
	if(rff->l==f(root)){		\
		if(f(root)->l==root) rcycle(rff);	\
		else lcycle(rff->l);	\
		rcycle(rff);	\
	}	\
	else{	\
		if(f(root)->r==root) lcycle(rff);	\
		else rcycle(rff->r);	\
		lcycle(rff);	\
	}
inline void Splay(splay *root){
	while(f(root))
		if(f(f(root))){
			if(f(f(f(root)))){
				register splay*& rff=pos(f(f(root)));
				lsp();
			}
			else{
				register splay* rff=f(f(root));
				lsp();
			}
		}else if(root->fa->l==root){
			root=root->fa;rcycle(root);
		}else{root=root->fa;lcycle(root);}
}
//伸展操作 
inline void merge(splay *rootl,splay* rootr){
	while(rootl->r) lcycle(rootl);
	rootl->r=rootr,rootr->fa=rootl,rootl->pushup();
}
//合并操作 
int main(){
	register READ cin;
	word n,m;cin>>n>>m;
	for(register int i=1;i<=n;i++){
		cin>>p[i].value;
		p[i].sum=p[i].value,p[i].size=1;
	}
	
	for(register word x,y;m;m--){
		while('A'>cin.c||cin.c>'Z') cin.c=getchar();
		if(cin.c=='M'){
			cin>>x>>y;
			if(x==y) continue;
			Splay(p+x),Splay(p+y);
			if(p[x].fa) continue;
			merge(p+y,p+x);
		}
		else if(cin.c=='D'){
			cin>>x,Splay(p+x);
			if(p[x].l) p[x].l->fa=0,p[x].l=0,p[x].pushup();
		}
		else if(cin.c=='Q'){
			cin>>x>>y;
			if(x==y) cout<<p[x].value<<'\n';
			else{
				Splay(p+x);
				register word xid=p[x].l? p[x].l->size:0;
				Splay(p+y);
				if(p[x].fa==0) cout<<'-'<<'1'<<'\n';
				else{
					register word yid=p[y].l? p[y].l->size:0;
					if(xid>yid) n=x,x=y,y=n,Splay(p+y);
					register splay* right=p[y].r;
					if(right) right->fa=0;
					p[y].r=0,p[y].pushup(),Splay(p+x);
					cout<<(p[x].l? p[x].sum-p[x].l->sum:p[x].sum)<<'\n';
					Splay(p+y);
					if(right) right->fa=p+y;
					p[y].r=right,p[y].pushup();
				}
			} 
		}
	}
	return 0;
}
```

---

## 作者：Aleph1022 (赞：1)

我们先看看原题的做法，dsu 边带权对吧。  
再看这道题。序列？平衡树！

仔细观察这几个操作，发现不是 Splay 和 FHQ Treap 的常规操作。  
如果实现需要一些奇怪的处理。  
算一算复杂度是对的。

M 操作，就直接按照维护序列的方式把 $y$ 所在序列合并到 $x$ 所在序列中。  
D 操作，让我们想到分裂操作，但是它给出的是结点编号而非排名，所以可以写一个函数求一下某结点的排名。  
Q 操作，配合求结点排名的操作就很容易了，然后注意区间不一定 $l \le r$。

这些操作因为没有直接给定根节点，Splay 的话就直接 Splay 一下，FHQ Treap 就得找根。  
这又让我们联想到并查集，但是很不幸的是，由于第二个操作，不能路径压缩。  
不过，由于平衡树本来的期望树高就是 $\log{n}$ 的，复杂度有保障。

然后不开 O2 也只要 500+ms，比较稳，  
听说还有 Splay 跑不进一秒的……

代码：
```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#define ls(p) tree[p].lson
#define rs(p) tree[p].rson
using namespace std;
const int N = 2e5;
int n,m;
struct node
{
    long long val,sum;
    int rnd,sz;
    int lson,rson,fa;
} tree[N + 10];
inline int get(int p)
{
    return tree[p].fa == p ? p : get(tree[p].fa);
}
inline void up(int p)
{
    tree[p].sz = tree[ls(p)].sz + 1 + tree[rs(p)].sz;
    tree[p].sum = tree[ls(p)].sum + tree[p].val + tree[rs(p)].sum;
    if(ls(p))
        tree[ls(p)].fa = p;
    if(rs(p))
        tree[rs(p)].fa = p;
}
void split(int p,int k,int &x,int &y)
{
    if(!p)
    {
        x = y = 0;
        return ;
    }
    if(tree[ls(p)].sz < k)
        x = p,split(rs(p),k - tree[ls(p)].sz - 1,rs(p),y);
    else
        y = p,split(ls(p),k,x,ls(p));
    tree[x].fa = x,tree[y].fa = y;
    up(p);
}
int merge(int x,int y)
{
    if(!x || !y)
        return x | y;
    if(tree[x].rnd < tree[y].rnd)
    {
        rs(x) = merge(rs(x),y);
        up(x);
        return x;
    }
    else
    {
        ls(y) = merge(x,ls(y));
        up(y);
        return y;
    }
}
int getrank(int p)
{
    int ret = tree[ls(p)].sz + 1;
    while(tree[p].fa ^ p)
    {
        if(rs(tree[p].fa) == p)
            ret += tree[ls(tree[p].fa)].sz + 1;
        p = tree[p].fa;
    }
    return ret;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(register int i = 1;i <= n;++i)
        scanf("%lld",&tree[i].val),tree[i].sum = tree[i].val,tree[i].rnd = rand(),tree[i].sz = 1,tree[i].fa = i;
    char op;
    int a,b;
    while(m--)
    {
        scanf(" %c",&op);
        if(op == 'M')
        {
            scanf("%d%d",&a,&b);
            int fa = get(a),fb = get(b);
            if(fa ^ fb)
                merge(fb,fa);
        }
        else if(op == 'D')
        {
            scanf("%d",&a);
            int fa = get(a),x,y;
            split(fa,getrank(a) - 1,x,y);
        }
        else
        {
            scanf("%d%d",&a,&b);
            if(get(a) ^ get(b))
                puts("-1");
            else
            {
                int fa = get(a);
                int l = getrank(a),r = getrank(b);
                int x,y,z;
                split(fa,r,x,z);
                split(x,l - 1,x,y);
                printf("%lld\n",tree[y].sum);
                fa = merge(merge(x,y),z);
            }
        }
    }
}
```

---

## 作者：JimmyLee (赞：0)

# 题意

>给定 $n$ 个长度为 $1$ 的序列，第 $i$ 个序列中有一个元素，值为 $a_i$，接下来有三种操作：
>
>1. `M x y`，表示把 $x$ 所在的序列放到 $y$ 所在的序列之后。如果 $x,y$ 已经在同一个序列，则不进行操作。
>2. `D x`，表示把 $x$ 所在的序列中从 $x$ 处断开，也就是把 $x$ 及 $x$ 之后的元素单独取出来作为一个序列。
>3. `Q x y`，表示查询 $x$ 到 $y$ 之间（包括 $x$ 和 $y$）所有元素的值之和。如果 $x$ 和 $y$ 不在同一个序列之中，输出 `-1`。
>

# 分析

看到操作有分裂以及合并，考虑使用 FHQ Treap。

但是发现普通的 FHQ Treap 好像不支持按节点分裂。

 所以我们对它进行一些修改，**让节点额外维护它的父亲节点**。

考虑如何维护父亲节点。

我们可以在 `push_up()` 中维护父亲节点，将两个子节点的父节点设为自己。

```cpp
node* push_up()
{
    siz=1;
    sum=v;
    if(lc) siz+=lc->siz, sum+=lc->sum, lc->fa=this;
    if(rc) siz+=rc->siz, sum+=rc->sum, rc->fa=this;
    return this;
}
```

但是分裂后的两根节点没有被更新，可能保存有错误的父节点指针。

分裂后或者合并后我们手动将它的父亲节点设为 $0$ 即可。

维护了父亲节点，我们可以很容易地得到节点在中序遍历中的位置：

```cpp
uint32_t find_pos(node *x)
{
    uint32_t res=siz(x->lc)+1;
    while(x->fa)
    {
        if(x->fa->rc==x) res+=siz(x->fa->lc)+1;
        x=x->fa;
    }
    return res;
}
```

同时也能快速找到根节点：

```cpp
node *find_fa(node *x)
{
    while(x->fa) x=x->fa;
    return x;
}
```

剩下的操作就很简单了，都是 FHQ Treap 基本操作。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 200005

namespace Treap
{
    mt19937 rnd(time(0));

    struct node
    {
        int64_t v;
        uint64_t id;
        int64_t siz=1;
        node *lc=0, *rc=0, *fa=0;
        int64_t add=0, sum=0;
        node(int va, uint64_t d): v(va), id(d) {sum=v;}

        void push_down()
        {
            if(!add) return;
            if(lc) lc->sum+=add*lc->siz, lc->add+=add, lc->v+=add;
            if(rc) rc->sum+=add*rc->siz, rc->add+=add, rc->v+=add;
            add=0;
        }

        node* push_up()
        {
            siz=1;
            sum=v;
            if(lc) siz+=lc->siz, sum+=lc->sum, lc->fa=this;
            if(rc) siz+=rc->siz, sum+=rc->sum, rc->fa=this;
            return this;
        }
    };

    node* new_node(int v) {return new node(v, rnd());}

    #define siz(x) (x?x->siz:0)

    void split(node *x, int s, node *&l, node *&r)
    {
        if(!x) return l=r=0, void();
        x->push_down();
        if(siz(x->lc)<s) l=x, split(x->rc, s-siz(x->lc)-1, x->rc, r);
        else             r=x, split(x->lc, s, l, x->lc);
        x->push_up();
    }

    node* merge(node *x, node *y)
    {
        if(!x||!y) return x?x:y;
        if(x->id<y->id)
        {
            x->push_down();
            x->rc=merge(x->rc, y);
            return x->push_up();
        }
        else
        {
            y->push_down();
            y->lc=merge(x, y->lc);
            return y->push_up();
        }
    }

    node *find_fa(node *x)
    {
        while(x->fa) x=x->fa;
        return x;
    }

    
    uint32_t find_pos(node *x)
    {
        uint32_t res=siz(x->lc)+1;
        while(x->fa)
        {
            if(x->fa->rc==x) res+=siz(x->fa->lc)+1;
            x=x->fa;
        }
        return res;
    }
}

Treap::node *rt[maxn];

int main()
{
    int n, m;
    cin>>n>>m;
    for(int i=1, t;i<=n;i++) 
        cin>>t, rt[i]=Treap::new_node(t);
    while(m--)
    {
        char op;
        int x, y;
        cin>>op>>x;
        if(op=='M') 
        {
            cin>>y;
            auto fx=Treap::find_fa(rt[x]);
            auto fy=Treap::find_fa(rt[y]);
            if(fy==fx) continue;
            merge(fy, fx)->fa=0;
        }
        if(op=='D')
        {
            auto fx=Treap::find_fa(rt[x]);
            uint32_t rnk=Treap::find_pos(rt[x]);
            Treap::node *a, *b;
            Treap::split(fx, rnk-1, a, b);
            if(a) a->fa=0;
            if(b) b->fa=0;
        }
        if(op=='Q')
        {
            cin>>y;
            auto fx=Treap::find_fa(rt[x]);
            auto fy=Treap::find_fa(rt[y]);
            if(fx!=fy) cout<<-1<<'\n';
            else
            {
                uint32_t l=Treap::find_pos(rt[x]);
                uint32_t r=Treap::find_pos(rt[y]);
                if(l>r) swap(l, r);
                Treap::node *a, *b, *c;
                Treap::split(fx, l-1, a, b);
                Treap::split(b, r-l+1, b, c);
                int64_t ans=b->sum;
                merge(merge(a, b), c)->fa=0;
                cout<<ans<<'\n';
            }
        }
    }
}
```

---

## 作者：Pwtking (赞：0)

[传送门](https://www.luogu.com.cn/problem/P4847)

主要思想：合并平衡树！

（以下所有代码内容中 ```key``` 代表该节点权值，```val``` 代表键值）

初始状态下我们可以把每个节点作为一个平衡树，接下来按照题意进行合并即可（这点其他题解说的很清楚。）

因为如果记录每一个平衡树的根的话非常难维护，所以我们不妨不记录每棵树的根节点，当用到根节点的时候直接现找。

为了更方便的找一棵树的根和某个节点的位置以及其他更多信息，我们记录每个节点的父节点。

- 如何更新父节点：

在 ```push up``` 的时候顺带上传即可：

```cpp
inline void pushup(ll pos) {
	tree[pos].siz=tree[tree[pos].l].siz+tree[tree[pos].r].siz+1;
	tree[pos].sum=tree[tree[pos].l].sum+tree[tree[pos].r].sum+tree[pos].key;
	if (tree[pos].l) tree[tree[pos].l].fa=pos;
	if (tree[pos].r) tree[tree[pos].r].fa=pos;
}
```
- ```split``` 之后每个节点的父节点需要重新初始化如下：

```cpp
inline void split(ll pos,ll x,ll &l,ll &r) {
	if (!pos) {l=r=0;return;}
	ll u=tree[tree[pos].l].siz+1;
	if (u<=x) {
		l=pos;
		split(tree[l].r,x-u,tree[l].r,r);
	}
	else {
		r=pos;
		split(tree[r].l,x,l,tree[r].l);
	}
	tree[l].fa=l,tree[r].fa=r;
	pushup(pos);
}
```
- 如何通过父节点信息找到该节点对应树的根：

```cpp
inline ll getfa(ll pos) {
	while (tree[pos].fa!=pos) pos=tree[pos].fa;
	return pos;
}
```
- 如何通过父节点找到该节点处在该树的位置：
```cpp
inline ll getrank(ll pos) {
	ll cnt=tree[tree[pos].l].siz+1;
	while (tree[pos].fa!=pos) {
		if (tree[tree[pos].fa].r==pos) cnt+=tree[tree[tree[pos].fa].l].siz+1;
		pos=tree[pos].fa;
	}
	return cnt;
}
```


------------

- 以下内容为一些初学的人设计，目的以理解平衡树 ```merge``` 的本质。


接下来介绍一道和这题很像但不一样的题：[[HNOI2012] 永无乡](https://www.luogu.com.cn/problem/P3224)。

这道题的思路也是平衡树合并，但是这道题合并时需要启发式合并，为什么现在不用？

这就要说到两种 ```split``` 的方式了：

我们都知道一般 ```split``` 有这两种形式：

1. 第一种：

```cpp
ll u=tree[tree[pos].l].siz+1;
if (u<=x) {
	l=pos;
	split(tree[pos].r,x-u,tree[pos].r,r);
	pushup(l);
}
```
2. 第二种：

```cpp
if (tree[pos].key<=x) {
	l=pos;
	split(tree[l].r,x,tree[l].r,r);
}
```

因为[[HNOI2012] 永无乡](https://www.luogu.com.cn/problem/P3224)中节点维护的是该数的大小，所以为了保证我们日后仍能顺利地查询到某个数的排名，所以我们要把它拆开放到合适的位置；

而此题要求将 $x$ 序列放到 $y$ 序列之后，我们直接 merge，虽然这样不保证以后分裂的时候左边权值和一定大于右边的权值和，但是注意到我判断分裂方式的语句是：

```cpp
ll u=tree[tree[pos].l].siz+1;
if (u<=x) 
```
即我是通过判断左子树大小来进行分裂的，**与权值无关**，所以我们可以以此来**假装**我们修改了权值来达到一样的效果。

- 要点：把  $x$ 加到 $y$ 后，是：$merge(y,x)$；



------------
完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define inf 0x7fffffff
const ll maxn=300010;
ll tot,n,root,dl,dr,temp,m;
ll v[maxn];
struct node {ll siz,l,r,key,val,fa,sum;}tree[maxn<<1];
inline void pushup(ll pos) {
	tree[pos].siz=tree[tree[pos].l].siz+tree[tree[pos].r].siz+1;
	tree[pos].sum=tree[tree[pos].l].sum+tree[tree[pos].r].sum+tree[pos].key;
	if (tree[pos].l) tree[tree[pos].l].fa=pos;
	if (tree[pos].r) tree[tree[pos].r].fa=pos;
}
inline ll getrand(ll x) {
	tree[++tot].siz=1;tree[tot].key=tree[tot].sum=x;tree[tot].val=rand();
	tree[tot].fa=tot;
	return tot;
} 
inline void split(ll pos,ll x,ll &l,ll &r) {
	if (!pos) {l=r=0;return;}
	ll u=tree[tree[pos].l].siz+1;
	if (u<=x) {
		l=pos;
		split(tree[l].r,x-u,tree[l].r,r);
	}
	else {
		r=pos;
		split(tree[r].l,x,l,tree[r].l);
	}
	tree[l].fa=l,tree[r].fa=r;
	pushup(pos);
}
inline ll merge(ll l,ll r) {
	if (!l||!r) return l|r;
	if (tree[l].val<=tree[r].val) {
		tree[l].r=merge(tree[l].r,r);
		pushup(l);
		return l;
	}
	else {
		tree[r].l=merge(l,tree[r].l);
		pushup(r);
		return r;
	}
}
inline ll getfa(ll pos) {
	while (tree[pos].fa!=pos) pos=tree[pos].fa;
	return pos;
}
inline ll getrank(ll pos) {
	ll cnt=tree[tree[pos].l].siz+1;
	while (tree[pos].fa!=pos) {
		if (tree[tree[pos].fa].r==pos) cnt+=tree[tree[tree[pos].fa].l].siz+1;
		pos=tree[pos].fa;
	}
	return cnt;
}
inline ll in() {
    char a=getchar();
	ll t=0,f=1;
	while(a<'0'||a>'9') {if (a=='-') f=-1;a=getchar();}
    while(a>='0'&&a<='9') {t=(t<<1)+(t<<3)+a-'0';a=getchar();}
    return t*f;
}
signed main() {
	n=in(),m=in();
	for (ll i=1;i<=n;++i) {
		v[i]=in();
		getrand(v[i]);
	}
	for (ll i=1;i<=m;++i) {
		char opt;
		cin>>opt;
		if (opt=='M') {
			ll x=in(),y=in();
			ll fx=getfa(x),fy=getfa(y);
			if (fx==fy) continue;
			merge(fy,fx);
		}
		else if (opt=='D') {
			ll x=in();
			ll fa=getfa(x);
			split(fa,getrank(x)-1,dl,dr);
		}
		else {
			ll x=in(),y=in();
			ll fx=getfa(x),fy=getfa(y);
			if (fx!=fy) {
				puts("-1");
				continue;
			}
			ll rx=getrank(x),ry=getrank(y);
			if (rx>ry) swap(rx,ry);
			split(fx,rx-1,dl,dr);
			split(dr,ry-rx+1,temp,dr);
			printf("%lld\n",tree[temp].sum);
			merge(dl,merge(temp,dr));
		}
	}
	return 0;
}
```







---

## 作者：JoaoFelix (赞：0)

没有LCT的题解QAQ！简单地描述一下LCT的做法

orz waaadreamer！

这道题的出题人非常的神仙，说这道题是签到题，并且思维难度很低，实现难度较高qwq

然而我却怎么也想不到LCT的做法，只会平衡树的做法！

但是~~个人感觉实现起来非常简单~~

这个出题人yy出来了一种不换根的LCT，复杂度~~好像~~很对！

做法具体是维护用LCT维护一段序列的左端点和右端点，然后以便Link操作！

可是怎么维护呢？

既然是不换根，那么我们可以按照从左到右的关键字（把这个关键字当为深度）插入LCT，然后LCT满足每个splay里面的root节点（即关键字最小的，就是findroot里面找的root）维护的就是左端点！

右端点的维护方式就是在根节点记录一个tail代表这整个splay的右端点，然后我们查询右端点的时候只需要查询根节点root的tail就行！
（之所以可以这么做，是因为这个LCT跟普通的LCT不同，ta不换根）

最后，我们来讲讲这个不换根的LCT的Link，Cut，Query函数！

Link:
```cpp
inline void Link(int x, int y) {
	x = findroot(x); y = findroot(y);
	if (x == y) return;
	splay(x); fa[x] = tail[y]; tail[y] = tail[x];
}
```
好像和普通的LCT差不多，就是不makeroot，我们直接将x向y的tail节点，就是y的最后一个节点连一条虚边（因为虚边是满足x的val大于tail[y]的）

因此我们这么连接肯定是符合splay中关键字的顺序的，并且起到连接效果！

然后我们更新 tail[y] = tail[x] 即可！

Cut：
```cpp
inline void Cut(int x) {
	int r = findroot(x);
	if (r == x) return;
	int tmp = ch[x][0];
	while (ch[tmp][1]) tmp = ch[tmp][1];
	tail[x] = tail[r]; tail[r] = tmp;
	fa[ch[x][0]] = 0; ch[x][0] = 0; 
}
```
C我们先判断这个点在序列里本来就是第一个，那么操作等价于无效！

然后我们找到x的在这个splay中的前驱！

这个前驱就是x在这个序列中的前一个数！

这样序列已经被分为两段！

前面那段：

root为r，tail[r] = tmp（tmp为前驱，也就是前面那段的最后一个数）;


后面那段：

root为x，tail[x] = tail[r]（最后一个数为原来的tail）;

Query：
```cpp
inline LL Query(int x, int y) {
	int r1 = findroot(x); LL p = Sum[x];
	int r2 = findroot(y);
	if (r1 != r2) return -1;
	p -= Sum[y];
	if (p < 0) swap(x, y);
	return abs(p) + v[y];
}
```
我们可以类似前缀和来求和

我们对于x，y分别求出这段序列的first到当前这个数的和

（考虑findroot就是access再splay，于是当前的sum[x]保留的就是整个splay里面的和，即为这段序列的first到x这个数的和）

然后作差减一下，在加一个v[x]或v[y]即可，这点小细节判一下就好了！

总之：感觉不换根的LCT比普通的LCT短好多呀，但是处理的问题会有局限性！

代码：

```cpp
namespace LinkCutTree {
	
	int ch[MAXN][2], fa[MAXN], stk[MAXN], rev[MAXN], tail[MAXN]; LL Sum[MAXN], v[MAXN];
	
	inline bool get(int x) { return ch[fa[x]][0] == x || ch[fa[x]][1] == x; }
	inline bool pos(int x) { return ch[fa[x]][1] == x; }
	inline void update(int x) { Sum[x] = Sum[ch[x][0]] + Sum[ch[x][1]] + v[x]; }
	inline void rotate(int x) {
		int y = fa[x], z = fa[y], k = pos(x), tmp = ch[x][!k];
		if (get(y)) ch[z][pos(y)] = x;
		ch[x][!k] = y; ch[y][k] = tmp;
		if (tmp) fa[tmp] = y;
		fa[y] = x; fa[x] = z; update(y); update(x); update(z);
	}
	inline void splay(int x) {
		while (get(x)) {
			int y = fa[x], z = fa[y];
			if (get(y)) rotate(pos(x) != pos(y) ? x : y);
			rotate(x);
		}
		update(x);
	}
	
	inline void access(int x) {
		for (int y = 0; x; y = x, x = fa[x]) {
			splay(x); ch[x][1] = y; fa[y] = x; update(x);
		}
	}
	inline int findroot(int x) {
		access(x); splay(x);
		while (ch[x][0]) x = ch[x][0];
		return x;
	}
	inline void Link(int x, int y) {
		x = findroot(x); y = findroot(y);
		if (x == y) return;
		splay(x); fa[x] = tail[y]; tail[y] = tail[x];
	}
	inline void Cut(int x) {
		int r = findroot(x);
		if (r == x) return;
		int tmp = ch[x][0];
		while (ch[tmp][1]) tmp = ch[tmp][1];
		tail[x] = tail[r]; tail[r] = tmp;
		fa[ch[x][0]] = 0; ch[x][0] = 0; 
	}
	inline LL Query(int x, int y) {
		int r1 = findroot(x); LL p = Sum[x];
		int r2 = findroot(y);
		if (r1 != r2) return -1;
		p -= Sum[y];
		if (p < 0) swap(x, y);
		return abs(p) + v[y];
	}
	
}
using namespace LinkCutTree;
```




---

## 作者：眠ㅤㅤㅤ (赞：0)

这个或许可能大概还算是 $LCT...$ $(?$ 

注意到此题序列是有序的 ➡ 所以不能换跟

$Link(X,Y)$ 只涉及到 $X$ 所在链的链首节点和 $Y$ 所在链的链尾节点，寻找链首链尾只需要 $Splay$ 后往一端走就行了 $(LCT$ 是以结点深度来维护平衡树的$)$，
在$X.F$ 与 $Y$ 接上之后 进行一次 $Access$ 操作，对整条链的信息更新

$Cut$ 直接断开

$Que$ 中用 $(X$链首 $=$ $Y$链首$)$ $?$ 来判断是否在同一条链上，统计答案的时候用前缀和的思想，但我们并不知道 $X$ 与 $Y$ 在链上$ $ $($即$Splay$上$)$ $ $的位置那个更靠前，所以答案出现负数的时候就是反过来了，答案等于 $0$ 的时候也一样，此时是 $X$ 与 $Y$ 相邻。


```cpp
#include <bits/stdc++.h>
constexpr auto Inf = 0x3F3F3F3F;
typedef long long LL;
using namespace std;

namespace IO {
    inline LL read() {
        LL o = 0, f = 1; char c = getchar();
        while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar(); }
        while (c > '/' && c < ':') { o = o * 10 + c - '0'; c = getchar(); }
        return o * f;
    }
    inline char recd() {
        char o; while ((o = getchar()) != 'M' && o != 'D' && o != 'Q'); return o;
    }
}
using namespace IO;

const int SIZE = 1E6 + 7;

struct Node {
    int son[2], Fa; LL w, Sum;
} Node[SIZE]; int N, M;

inline int which(int now) {
    return now == Node[Node[now].Fa].son[1];
}

inline void pushup(int now) {
    Node[now].Sum = Node[Node[now].son[0]].Sum + Node[Node[now].son[1]].Sum + Node[now].w;
}

inline int Isroot(int now) {
    return now != Node[Node[now].Fa].son[0] && now != Node[Node[now].Fa].son[1];
}

void Rot(int now) {
    int F = Node[now].Fa, FF = Node[F].Fa, w = which(now);
    Node[F].son[w] = Node[now].son[!w]; if (Node[now].son[!w]) Node[Node[now].son[!w]].Fa = F;
    Node[now].Fa = FF; if (!Isroot(F)) Node[FF].son[which(F)] = now;
    Node[now].son[!w] = F, Node[F].Fa = now; pushup(F), pushup(now);
}

void Splay(int now) {
    for (int F = Node[now].Fa; !Isroot(now); Rot(now), F = Node[now].Fa)
        if (!Isroot(F))
            which(F) ^ which(now) ? Rot(now) : Rot(F);
    pushup(now);
}

void Access(int now) {
    for (int pos = 0; now; pos = now, now = Node[now].Fa)
        Splay(now), Node[now].son[1] = pos, pushup(now);
}

int Fake_Fndroot(int now, int o) {
    Splay(now);
    while (Node[now].son[o]) now = Node[now].son[o];
    return now;
}

void Lnk(int X, int Y) {
    int L = Fake_Fndroot(X, 0);
    if (L == Fake_Fndroot(Y, 0)) return;
    int R = Fake_Fndroot(Y, 1);
    Splay(L), Node[L].Fa = R;
    Access(Fake_Fndroot(X, 1));
}

void Cut(int now) {
    Splay(now); Node[now].son[0] = Node[Node[now].son[0]].Fa = 0; pushup(now);
}

LL Ask(int X, int Y) {
    if (Fake_Fndroot(X, 0) != Fake_Fndroot(Y, 0)) return -1;
    LL ans = 0;
    Splay(X), ans -= Node[Node[X].son[0]].Sum;
    Splay(Y), ans += Node[Node[Y].son[0]].Sum + Node[Y].w;
    if (ans <= 0) {
        ans = 0;
        Splay(Y), ans -= Node[Node[Y].son[0]].Sum;
        Splay(X), ans += Node[Node[X].son[0]].Sum + Node[X].w;
    } return ans;
}

int main() {
    N = read(), M = read();
    for (int pos = 1; pos <= N; pos++) Node[pos].Sum = Node[pos].w = read();
    char o; int L, R;
    while (M--) {
        o = recd(), L = read();
        if (o == 'M')
            R = read(), Lnk(L, R);
        else if (o == 'D')
            Cut(L);
        else
            R = read(), printf("%lld\n", Ask(L, R));
    }
}


```


---

## 作者：Memory_of_winter (赞：0)

[我的博客](https://www.cnblogs.com/Memory-of-winter/p/10331946.html)

**题目大意：**有$n(n\leqslant2\times10^5)$个序列，有$m(m\leqslant2\times10^5)$个操作，分三种：

1. $M\;x\;y$：把$x$所在的序列放在$y$所在序列之后
2. $D\;x$：把$x$所在的序列从它前面断开
3. $Q\;x\;y$：询问若$x,y$在同一序列中，它们之间的元素和

**题解：**平衡树，合并就正常合并，注意是把$x$放到$y$后，关于找$x$所在的序列，就记录每个节点的父亲，直接向上跳父亲就可以了，在分裂时注意维护父亲。

求元素的排名就看一下它是不是它父亲的右儿子，是的话把它兄弟的大小加上。

询问就记录一个区间和即可。



**C++ Code：**

```cpp
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#define maxn 200010

namespace Treap {
	int pri[maxn], lc[maxn], rc[maxn], fa[maxn], sz[maxn], V[maxn];
	long long S[maxn];
	int ta, tb, tmp, res;
	inline void nw(int pos, int x) {
		pri[pos] = rand();
		S[pos] = V[pos] = x;
		lc[pos] = rc[pos] = fa[pos] = 0;
		sz[pos] = 1;
	}
	inline int update(int rt) {
		const int lc = Treap::lc[rt], rc = Treap::rc[rt];
		if (lc) fa[lc] = rt;
		if (rc) fa[rc] = rt;
		sz[rt] = sz[lc] + sz[rc] + 1;
		S[rt] = S[lc] + S[rc] + V[rt];
		return rt;
	}
	void split(int rt, int k, int &x, int &y) {
		if (!rt) x = y = 0;
		else {
			if (sz[lc[rt]] >= k) {
				split(lc[rt], k, x, lc[rt]);
				fa[x] = fa[rt] = 0;
				y = update(rt);
			} else {
				split(rc[rt], k - sz[lc[rt]] - 1, rc[rt], y);
				fa[rt] = fa[y] = 0;
				x = update(rt);
			}
		}
	}
	int merge(int x, int y) {
		if (!x || !y) return x | y;
		if (pri[x] < pri[y]) { rc[x] = merge(rc[x], y); return update(x); }
		else { lc[y] = merge(x, lc[y]); return update(y); }
	}
	inline int gtrnk(int x) {
		res = sz[lc[x]] + 1;
		while (x) {
			if (rc[fa[x]] == x) res += sz[lc[fa[x]]] + 1;
			x = fa[x];
		}
		return res;
	}
	inline int gtrt(int x) {
		while (fa[x]) x = fa[x];
		return x;
	}

	inline void Merge(int x, int y) {
		x = gtrt(x), y = gtrt(y);
		if (x == y) return ;
		merge(y, x);
	}
	inline void Split(int x) {
		int rk = gtrnk(x); x = gtrt(x);
		split(x, rk - 1, ta, tb);
	}
	inline void query(int x, int y) {
		int root = gtrt(x);
		if (root != gtrt(y)) {
			puts("-1");
			return ;
		}
		int rkx = gtrnk(x), rky = gtrnk(y);
		if (rkx > rky) std::swap(rkx, rky);
		split(root, rky, ta, tb);
		split(ta, rkx - 1, ta, tmp);
		printf("%lld\n", S[tmp]);
		merge(ta, merge(tmp, tb));
	}
}

int n, m;

int main() {
	srand(20040826);
	scanf("%d%d", &n, &m);
	for (int i = 1, x; i <= n; ++i) {
		scanf("%d", &x);
		Treap::nw(i, x);
	}
	while (m --> 0) {
		char op;
		int x, y;
		scanf("%1s%d", &op, &x);
		switch (op) {
			case 'M':
				scanf("%d", &y);
				Treap::Merge(x, y);
				break;
			case 'D':
				Treap::Split(x);
				break;
			case 'Q':
				scanf("%d", &y);
				Treap::query(x, y);
		}
	}
	return 0;
}

```



---


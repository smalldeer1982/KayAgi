# [THUPC 2019] 不等式

## 题目描述

> 时光回到 2017 年 6 月 7 日。午后，阳光正好。
>
> 现在的你，在考场中笔耕不辍。在刷刷声中，你填写着交给从前和未来的自己的答卷。
> 
> 像无数次训练过的那样，你直接跳到了这张数学试卷的最后一道大题，二选一的题目直接选择了后者。快速地掠过了题目描述，紧缩的眉头渐渐放松。
> 
> 「稳了。」
>
> 你一刻也不敢停留，又向你的梦想靠近了一小步。

已知两个 $n$ 维实向量 $\vec{a}=(a_1,a_2,\dots,a_n),\vec{b}=(b_1,b_2,\dots,b_n)$，定义 $n$ 个定义域为 $\mathbb{R}$ 函数 $f_1,f_2,\dots,f_n$：

$$f_k(x)=\sum_{i=1}^{k} \lvert a_ix+b_i\rvert \quad (k=1,2,\dots,n)$$

现在，对于每个 $k=1,2,\dots,n$，试求 $f_k$ 在 $\mathbb{R}$ 上的最小值。可以证明最小值一定存在。

## 说明/提示

### 样例解释

$f_1(x)=\lvert x+1\rvert$，显然在 $x=-1$ 处取到最小值 $0$；

$f_2(x)=\lvert x+1\rvert +\lvert x+2\rvert$，可以证明其在 $[-2,-1]$ 中任意位置取到最小值 $1$。

##### 后记

后来，全国三卷的考生们又回想起了被参数方程支配的恐惧。

##### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。

## 样例 #1

### 输入

```
2
1 1
1 2```

### 输出

```
0.00000
1.00000```

# 题解

## 作者：hehezhou (赞：8)

### 题意
给定$\{a_n\}$,$\{b_n\}$  
求$\sum_{i=1}^k|a_ix+b_i|$ 的最小值$(\forall k\in[1,n])$

首先根据~~小学~~数学知识，我们把它转化为:
$$\sum_{i=0}^k|a_i|*|x+\frac{b_i}{a_i}|$$

考虑实际意义，一条数轴上有$m$个点，要求数轴上一点，使该点到各点的距离和最小  
~~显然，~~ 当这个点为第$\frac{m+1}2$个点时为一个最优解(即中位数)

然后用平衡树维护中位数，并统计答案即可(当然你用两个堆也可以)

注意总个数可能爆$int$

#### Talk is cheap, show me the code.

码风很丑，大佬轻喷

```cpp
#include <bits/stdc++.h>
using namespace std;
// 以下平衡树(无旋treap)
struct node {
    int rnd, cnt, ls, rs;
    long long size;
    double sum, key;
} t[500010];
inline int newnode(double key, int cnt) {
    static int Cnt = 0;
    t[++Cnt] = node{rand(), cnt, 0, 0, (long long)cnt, key * cnt, key};
    return Cnt;
}
inline void up(int x) {
    t[x].size = t[t[x].ls].size + t[t[x].rs].size + t[x].cnt;
    t[x].sum = t[t[x].ls].sum + t[t[x].rs].sum + t[x].key * t[x].cnt;
}
inline int merge(int a, int b) {
    if(a == 0 || b == 0) return a | b;
    if(t[a].rnd < t[b].rnd) return t[a].rs = merge(t[a].rs, b), up(a), a;
    return t[b].ls = merge(a, t[b].ls), up(b), b;
}
inline void split_key(int now, double k, int &x, int &y) {
    if(now == 0) x = y = 0;
    else if(t[now].key > k) y = now, split_key(t[now].ls, k, x, t[y].ls), up(y);
    else x = now, split_key(t[now].rs, k, t[x].rs, y), up(x);
}
inline void split_rank(int now, long long k, int &x, int &y) {
    if(now == 0) x = y = 0;
    else if(t[t[now].ls].size >= k) y = now, split_rank(t[now].ls, k, x, t[y].ls), up(y);
    else x = now, split_rank(t[now].rs, k - t[t[now].ls].size - t[now].cnt, t[x].rs, y), up(x);
}
inline double get_max(int now) {
    if(t[now].rs) return get_max(t[now].rs);
    return t[now].key;
}
//平衡树结束
int n, a[500010], b[500010], rt;
double lala;
int main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) scanf("%d", a + i);
    for(int i = 1; i <= n; i++) scanf("%d", b + i);
    for(int i = 1; i <= n; i++) {
        if(a[i] < 0) a[i] = -a[i], b[i] = -b[i]; //加绝对值
        int x, y;
        if(a[i] == 0) lala += abs(b[i]); //特判
        else {
            double add = -1.0 * b[i] / a[i];
            split_key(rt, add, x, y);
            rt = merge(merge(x, newnode(add, a[i])), y);
        }
        double mid;
        split_rank(rt, (t[rt].size + 1) / 2, x, y);
        mid = get_max(x);
        printf("%.10lf\n", lala + mid * t[x].size - t[x].sum + t[y].sum - mid * t[y].size);
        rt = merge(x, y);
    }
    return 0;//完结撒花
}
```


---

## 作者：devout (赞：3)

**description**

对于给定的$\{a_i\},\{b_i\}$，定义
$$f_k(x)=\begin{matrix}\sum_{i=1}^k\end{matrix}\operatorname{abs}(a_ix+b_i)$$

对于每一个$k$，求$f_k(x)$的最小值
****
**solution**

首先考虑$a_i=1$的时候，也就是我们要求$\min\{\sum |x+b_i|\}$

$|x+b_i|$的几何意义就是在数轴上，$x$到$-b_i$这个点的距离

那么~~根据初一数学的芝士~~，$x$取所有$-b_i$的时候可以取到最小值

那么当$a_i=-1$的时候呢？每一个式子变成了$|-x+b_i|=|x-b_i|$，也就是数轴上$x$到$b_i$的距离

这样的话我们还是把一个式子对应成了一个点

当$|a_i|\neq1$时，也就是式子是最基本的$|a_ix+b_i|$时，我们转化一下，变成$|a_i||x+\frac{b_i}{a_i}|$，注意外面$a_i$的绝对值不能丢

这个式子相当于$a_i$倍的$x$到$-\frac{b_i}{a_i}$的距离，相当于把它转化成了$a_i$个点

这样的话类比$a_i=1$的时候的方法，利用一个线段树维护这道题就轻松解决了

注意因为坐标可能出现分数，所以我们需要先算出每个式子转化成的坐标离散化之后再进行建树

细节还是挺多的，注意需要考虑$a_i=0$的情况

****
**code**

```cpp
#include <bits/stdc++.h>
using namespace std;
# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)
# define int long long
# define double long double 

const int N=1e6+5;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n;
int a[N],b[N];
double x[N],lsh[N];
int pos[N],tot,add;

struct node{
    int l,r,cnt;
    double sum;
}seg[N<<2];

# define lc (u<<1)
# define rc (u<<1|1)

void pushup(int u){
    seg[u].cnt=seg[lc].cnt+seg[rc].cnt;
    seg[u].sum=seg[lc].sum+seg[rc].sum;
}

void build(int u,int l,int r){
    seg[u].l=l,seg[u].r=r;
    if(l==r)return;
    int mid=l+r>>1;
    build(lc,l,mid);
    build(rc,mid+1,r);
}

void update(int u,int x,int k,double xc){
    if(seg[u].l==seg[u].r){
        seg[u].cnt+=k;
        seg[u].sum+=xc*k;
        return;
    }
    int mid=seg[u].l+seg[u].r>>1;
    if(x<=mid)update(lc,x,k,xc);
    else update(rc,x,k,xc);
    pushup(u);
}

int kth(int u,int k){
    if(seg[u].l==seg[u].r)return seg[u].l;
    if(seg[lc].cnt>=k)return kth(lc,k);
    else return kth(rc,k-seg[lc].cnt);
}

int qcnt(int u,int l,int r){
    if(l>r)return 0;
    if(seg[u].l>=l&&seg[u].r<=r)return seg[u].cnt;
    int mid=seg[u].l+seg[u].r>>1;
    int res=0;
    if(l<=mid)res+=qcnt(lc,l,r);
    if(r>mid)res+=qcnt(rc,l,r);
    return res;
}

double query(int u,int l,int r){
    if(l>r)return 0;
    if(seg[u].l>=l&&seg[u].r<=r)return seg[u].sum;
    int mid=seg[u].l+seg[u].r>>1;
    double res=0;
    if(l<=mid)res+=query(lc,l,r);
    if(r>mid)res+=query(rc,l,r);
    return res;
}

signed main()
{
    read(n);
    Rep(i,1,n)read(a[i]);
    Rep(i,1,n)read(b[i]);
    Rep(i,1,n)x[i]=lsh[i]=-1.0*b[i]/a[i];
    sort(lsh+1,lsh+n+1);
    int sz=unique(lsh+1,lsh+n+1)-lsh-1;
    Rep(i,1,n)pos[i]=lower_bound(lsh+1,lsh+sz+1,x[i])-lsh;
    build(1,1,sz);
    Rep(i,1,n){
        if(!a[i])add+=abs(b[i]);
        else update(1,pos[i],abs(a[i]),x[i]),tot+=abs(a[i]);
        int to=kth(1,tot+1>>1);
        printf("%Lf\n",(lsh[to]*qcnt(1,1,to-1)-query(1,1,to-1))+(query(1,to+1,sz)-lsh[to]*qcnt(1,to+1,sz))+add);
    }
    return 0;
}
```


---

## 作者：TheLostWeak (赞：3)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/LOJ6620.html)

**大致题意：** 给你两个长度为$n$的数组$a_i$和$b_i$，定义$f_k(x)=\sum_{i=1}^k|a_ix+b_i|$，对于$k=1\sim n$的每个$f_k$，求$f_k$的最小值。

### 前言

懒得写平衡树，于是就想了个线段树做法。

我承认我的码风比较诡异，但我觉得我的想法应该还是挺好理解的吧。

还有，题目没有特殊说明不存在$a_i=0$的情况，~~但数据中确实不存在这样的情况~~，我的做法遇上这种情况可能要加一些特殊处理，~~然而我懒得写了~~。


### 前置知识

先考虑一个简单的问题：

> $Problem\ 1$：
>
> 给你一个长度为$n$的数组$b_i$，求$\sum_{i=1}^n|x+b_i|$的最小值。

显然根据初中数学可知，当$x$取$b_i$的**中位数**的相反数时，这个式子取最小值。

再考虑一个升级版的问题：

> $Problem\ 2$：
>
> 给你两个长度为$n$的数组$a_i$和$b_i$，求$\sum_{i=1}^n|a_ix+b_i|$的最小值。（假定任意$a_i>0$）

这看似复杂，实际上不难发现，$|a_ix+b_i|=a_i|x+\frac{a_i}{b_i}|$，也就是一个$|a_ix+b_i|$可以拆成$a_i$个$|x+\frac{a_i}{b_i}|$。

然后按上面$Problem\ 1$的方法做即可。

虽说上面我们假定$a_i>0$，但实际上对于$a_i<0$的情况，我们可以同时将$a_i$和$b_i$变为其相反数，这样就能满足$a_i>0$了。

### 前置处理

我们可以发现，这道题要我们做的，其实就是每次加入一组$a_i$和$b_i$，维护$Problem\ 2$的答案。

假如我们把$|a_ix+b_i|$拆成$a_i$个$|x+\frac{a_i}{b_i}|$，由于$a_i<10^5$，显然最后数的个数的规模是难以接受的。

但如果我们能够开一个数组$p$，以$\frac{a_i}{b_i}$为下标，那么我们实际上每次只要把$p_{\frac{a_i}{b_i}}$加上$a_i$就能很方便地维护数组。

可是，以一个实数为下标显然是不可能的。因此，我们就需要在处理询问前先将$\frac{a_i}{b_i}$给离散化。

注意，为了防止挂精度，推荐在排序比较分数大小时可以先交叉相乘再比较，避免出现除法。

### 线段树

设我们求出中位数的值是$e$，且其在离散化后的值是$k$，那么答案就是：

$$(e\times\sum_{i=1}^kp_i-\sum_{i=1}^k p_i\times Fact_i)+(\sum_{i=k}^n p_i\times Fact_i-p_k\times\sum_{i=k}^np_i)$$

其中$Fact_i$表示$i$所表示的真实值。

则我们需要一个数据结构，能够实现四种操作：单点修改、求中位数、求区间$\sum p_i$和求区间$\sum p_i\times Fact_i$。

于是我们就想到线段树。

注意求区间$\sum p_i\times Fact_i$看似棘手，但由于我们是单点修改，因此我们只要对于每个位置维护两个值即可。

特殊地，根据先前定义我们可知，每次加入一组$a_i,b_i$，设$t$为$\frac {b_i}{a_i}$离散化后的值，那么我们会将$p_{t}$加上$a_i$，那么$p_t\times Fact_t$其实就是加上了$a_i\times Fact_t=a_i\times \frac{b_i}{a_i}=b_i$。

而对于求中位数，其实我们如果维护$g=\sum p_i$，那么中位数就是第$\lfloor\frac{g+1}2\rfloor$个数。

然后，我们在线段树上二分，便可以找到中位数离散化后的值$k$，进而就可以得到$e$了。

至于具体实现，可见代码。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 500000
#define LL long long
#define DB double
#define abs(x) ((x)<0?-(x):(x))
using namespace std;
int n,a[N+5],b[N+5],s[N+5],p[N+5];
I bool cmp(CI x,CI y) {return 1LL*b[x]*a[y]<1LL*b[y]*a[x];}
class FastIO
{
	private:
		#define FS 100000
		#define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
		#define tn (x<<3)+(x<<1)
		#define D isdigit(c=tc())
		int f;char c,*A,*B,FI[FS];
	public:
		I FastIO() {A=B=FI;}
		Tp I void read(Ty& x) {x=0,f=1;W(!D) f=c^'-'?1:-1;W(x=tn+(c&15),D);x*=f;}
}F;
class SegmentTree//线段树
{
	private:
		#define PT CI l=1,CI r=n,CI rt=1
		#define LT l,mid,rt<<1
		#define RT mid+1,r,rt<<1|1
		#define PU(x) (T[x]=T[x<<1]+T[x<<1|1],S[x]=S[x<<1]+S[x<<1|1])
		LL T[N<<2],S[N<<2];
	public:
		I void Upt(CI x,Con LL& y,Con LL& z,PT)//单点修改
		{
			if(l==r) return (void)(T[rt]+=y,S[rt]+=z);int mid=l+r>>1;
			x<=mid?Upt(x,y,z,LT):Upt(x,y,z,RT),PU(rt);
		}
		I int Qmid(Con LL& rk,PT)//求中位数
		{
			if(l==r) return l;int mid=l+r>>1;
			return rk<=T[rt<<1]?Qmid(rk,LT):Qmid(rk-T[rt<<1],RT);
		}
		I LL Qtot(CI x,CI y,PT)//区间求和1
		{
			if(x<=l&&r<=y) return T[rt];int mid=l+r>>1;
			return (x<=mid?Qtot(x,y,LT):0)+(y>mid?Qtot(x,y,RT):0);
		}
		I LL Qsum(CI x,CI y,PT)//区间求和2
		{
			if(x<=l&&r<=y) return S[rt];int mid=l+r>>1;
			return (x<=mid?Qsum(x,y,LT):0)+(y>mid?Qsum(x,y,RT):0);
		}
}S;
int main()
{
	RI i,k;LL g=0;DB e,w;for(F.read(n),i=1;i<=n;++i) F.read(a[i]);for(i=1;i<=n;++i) F.read(b[i]);//读入
	for(i=1;i<=n;++i) a[i]<0&&(a[i]=-a[i],b[i]=-b[i]),s[i]=i;sort(s+1,s+n+1,cmp);//方便起见，将a[i]取正
	for(k=0,i=1;i<=n;++i) (!k||(1LL*b[s[k]]*a[s[i]])^(1LL*b[s[i]]*a[s[k]]))&&(s[++k]=s[i]),p[s[i]]=k;//离散化，排序后去重
	for(i=1;i<=n;++i)
	{
		S.Upt(p[i],a[i],b[i]),k=S.Qmid((g+=a[i])+1>>1),e=1.0*b[s[k]]/a[s[k]];//线段树上查询中位数
		w=(e*S.Qtot(1,k)-S.Qsum(1,k))+(S.Qsum(k,n)-e*S.Qtot(k,n)),printf("%.8lf\n",w);//利用线段树查询所需信息计算答案
	}return 0;
}
```

---

## 作者：EuphoricStar (赞：2)

首先特判 $a_i = 0$，然后：

$\begin{aligned} f_k(x) & = \sum\limits_{i = 1}^k |a_i x + b_i| \\ & = \sum\limits_{i = 1}^k a_i |x + \frac{b_i}{a_i}| \end{aligned}$

默认 $a_i > 0$，若不满足则 $a_i, b_i$ 同时取相反数即可。

然后这个东西就变成了，数轴上 $-\frac{b_i}{a_i}$ 位置上有 $a_i$ 个点，找一个点使这个点到所有点的距离最小。

根据小学奥数，取所有 $-\frac{b_i}{a_i}$ 的中位数（设为 $p$）最优。然后把 $p$ 代入上面式子，拆绝对值即可。

使用树状数组求中位数和维护 $\sum a_i, \sum b_i$，复杂度 $O(n \log n)$。

```cpp
// Problem: P5381 [THUPC2019] 不等式
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5381
// Memory Limit: 500 MB
// Time Limit: 3000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<ll, ll> pii;

struct frac {
	ll x, y;
	frac(ll a = 0, ll b = 1) {
		if (b < 0) {
			a = -a;
			b = -b;
		}
		x = a;
		y = b;
	}
};

inline bool operator < (const frac &a, const frac &b) {
	return a.x * b.y < a.y * b.x;
}

inline bool operator == (const frac &a, const frac &b) {
	return a.x * b.y == a.y * b.x;
}

const int maxn = 500100;

ll n, tot;
frac lsh[maxn];
struct node {
	ll a, b;
} a[maxn];

struct BIT {
	ll c[maxn];
	
	inline void update(int x, ll d) {
		for (int i = x; i <= tot; i += (i & (-i))) {
			c[i] += d;
		}
	}
	
	inline ll query(int x) {
		ll res = 0;
		for (int i = x; i; i -= (i & (-i))) {
			res += c[i];
		}
		return res;
	}
	
	inline int kth(ll k) {
		ll s = 0;
		int p = 0;
		for (int i = 18; ~i; --i) {
			if (p + (1 << i) <= tot && s + c[p + (1 << i)] < k) {
				s += c[p + (1 << i)];
				p += (1 << i);
			}
		}
		return p + 1;
	}
} t1, t2;

void solve() {
	scanf("%lld", &n);
	for (int i = 1; i <= n; ++i) {
		scanf("%lld", &a[i].a);
	}
	for (int i = 1; i <= n; ++i) {
		scanf("%lld", &a[i].b);
		if (a[i].a < 0) {
			a[i].a = -a[i].a;
			a[i].b = -a[i].b;
		}
		if (a[i].a) {
			lsh[++tot] = frac(-a[i].b, a[i].a);
		}
	}
	sort(lsh + 1, lsh + tot + 1);
	tot = unique(lsh + 1, lsh + tot + 1) - lsh - 1;
	ll s = 0, r = 0;
	for (int i = 1; i <= n; ++i) {
		if (a[i].a) {
			int k = lower_bound(lsh + 1, lsh + tot + 1, frac(-a[i].b, a[i].a)) - lsh;
			t1.update(k, a[i].a);
			t2.update(k, a[i].b);
		} else {
			r += abs(a[i].b);
		}
		s += a[i].a;
		int t = t1.kth((s + 1) / 2);
		frac p = lsh[t];
		db res = t1.query(t) * (1. * p.x / p.y) + t2.query(t);
		res += -(t1.query(tot) - t1.query(t)) * (1. * p.x / p.y) - (t2.query(tot) - t2.query(t));
		printf("%.6lf\n", res + r);
	}
}

int main() {
	int T = 1;
	// scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}
```


---

## 作者：wosile (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/solution/P5381)

## P5381 [THUPC2019] 不等式

~~（是我就把这题改成强制在线）~~

首先，我们有 $|ax+b|=|-ax-b|=|a||x+\dfrac{b}{a}|$。

考虑很经典的，$\sum_{i=1}^k|x+d_i|\;(d_i\le d_{i+1})$ 的几何意义是什么。很明显，在数轴上，$|x+d_i|$ 就是 $x$ 到 $-d_i$ 的距离。那么，$\sum_{i=1}^k|x+d_i|$ 就是我们在数轴上每个 $-d_i$ 的位置都放一个点，$x$ 到它们的距离和。

结论是，$\sum_{i=1}^k|x+d_i|$ 在 $x=-d_{\lceil \frac{k}{2} \rceil}$ 取到最小值。感性理解一下，$x$ 往左挪，它右边的点 $(-d_i)$ 的 $|x+d_i|$ 就会增大，左边的 $|x+d_i|$ 就会减小。所以 $x$ 肯定是往点多的方向移动更好，就移动到中位数就行了。

$\sum_{i=1}^k|a_ix+b_i|=\sum_{i=1}^k|a_i||x+\dfrac{b_i}{a_i}|$ 就相当于在每一个 $-\dfrac{b_i}{a_i}$ 放 $|a_i|$ 个点而不是一个点，同样找到一个左右两侧点的个数相同的 $x$ 就可以求最小值了。

所以我们需要一个数据结构维护一个 $(a_i,b_i)$ 的序列并且支持：

- 保持按 $-\dfrac{b_i}{a_i}$ 排序；

- 插入；

- 查询带权 $(a_i)$ 中位数；

- 给定 $x$，可以求 $\sum_{i=1}^k|a_ix+b_i|$。

对于求值操作，对于 $-\dfrac{b_i}{a_i}$ 在 $x$ 的两侧的 $(a_i,b_i)$，分别维护 $\sum a$ 和 $\sum b$ 即可。

写个平衡树就可以解决，我这里用的是 FHQ-Treap，跑得很慢，但是还有比我更慢的。

注意 $a=0$ 的特判， `long long` 和 `double`。

时间复杂度 $O(nlogn)$，空间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
typedef long long ll;
int tr[500005][2],pri[500005];
ll sa[500005],sb[500005];
int a[500005],b[500005];
double z[500005];
int tot=0;
int rt=0;
//fhq treap
int newnode(int ta,int tb){
	++tot;
	a[tot]=sa[tot]=ta;
	b[tot]=sb[tot]=tb;
	pri[tot]=rand();
	tr[tot][0]=tr[tot][1]=0;
	z[tot]=(double)tb/-ta;
	return tot;
}
void pushup(int x){
	sa[x]=sa[tr[x][0]]+sa[tr[x][1]]+a[x];
	sb[x]=sb[tr[x][0]]+sb[tr[x][1]]+b[x];
}
void split(int x,double v,int &tx,int &ty){
	if(x==0){
		tx=ty=0;
		return;
	}
	if(z[x]<=v){
		tx=x;
		split(tr[x][1],v,tr[x][1],ty);
	}
	else{
		ty=x;
		split(tr[x][0],v,tx,tr[x][0]);
	}
	pushup(x);
}
int merge(int x,int y){
	if(x==0 || y==0)return x+y;
	if(pri[x]<pri[y]){
		tr[x][1]=merge(tr[x][1],y);
		pushup(x);
		return x;
	}
	else{
		tr[y][0]=merge(x,tr[y][0]);
		pushup(y);
		return y;
	}
}
double query(int x,ll ca){
	if(ca<=sa[tr[x][0]])return query(tr[x][0],ca);
	if(ca<=sa[tr[x][0]]+a[x])return z[x];
	return query(tr[x][1],ca-sa[tr[x][0]]-a[x]);
}
int ina[500005],inb[500005];
void output(int x){
	//调试
	if(!x)return;
	output(tr[x][0]);
	printf("%d %d %.4lf\n",a[x],b[x],z[x]);
	output(tr[x][1]);
}
int main(){
	srand(0114507537);//生日
	scanf("%d",&n);
	ll reb=0;
	for(int i=1;i<=n;i++)scanf("%d",&ina[i]);
	for(int i=1;i<=n;i++)scanf("%d",&inb[i]);
	for(int i=1;i<=n;i++){
		double tz;
		int ta=ina[i],tb=inb[i];
		if(ta<0)ta=-ta,tb=-tb;
		int tx,ty;
		if(ta==0)reb+=abs(tb);//注意有abs()
		else{
			double tz=(double)tb/-ta;
			split(rt,tz,tx,ty);
			rt=merge(merge(tx,newnode(ta,tb)),ty);
		}
		tz=query(rt,(sa[rt]+1)/2);//x
		split(rt,tz,tx,ty);
		printf("%.10lf\n",reb+tz*sa[tx]+sb[tx]-sb[ty]-tz*sa[ty]);//零点在 tz 两侧的分别计算
		rt=merge(tx,ty);
	}
	return 0;
}
```

---

## 作者：_Fontainebleau_ (赞：0)

### 题意

- 给定两个长度为 $n$ 的数组 $a_i,b_i$，定义 $\displaystyle f_k(x)=\sum_{i=1}^k \left|a_ix+b_i\right|$，对于每一个 $k=1,2,\ldots,n$，求 $f_k$ 的最小值。
- $1\le{n}\le5\times10^5,\left|a_i\right|,\left|b_i\right|<10^5$。

### 做法

首先我们有这样一个结论:

对于 $\displaystyle \sum_{i=1}^n |x-a_i|$ ，在 $x$ 取 $a_i$ 的中位数时，有最小值。

稍加推广，就有：

对于 $\sum_{i=1}^n\left|a_ix+b_i\right|,(a_i\not=0)$，$\left|a_ix+b_i\right|=\left|a_i\right|\left|x+\dfrac{b_i}{a_i}\right|$，看作是 $|a_i|$ 个 $\left|x+\dfrac{b_i}{a_i}\right|$。然后问题就被转化成了原先的结论。

注意最后的坐标可能会有分数，所以我们可以采取离散化的方式解决这个问题。

设中位数对应的离散化后的值是 $v$，离散化数组为 $k_i$ 则 

$\displaystyle f_k(m)=\left(k_v\times\sum_{i=1}^{v}a_i-\sum_{i=1}^v{k_i\times a_i}\right)+\left({\sum_{i=k}^n{k_i\times a_i}}-k_v\times\sum_{i=k}^n{a_i}\right)$

我们考虑用线段树来维护这个东西。这个线段树需要支持 单点修改，区间求和，第 k 大 两个操作，维护个数和总和。

求中位数只需要查询排名为 $\displaystyle \left\lfloor\frac{\sum_{i=1}^{k}a_i}2\right\rfloor$ 的数即可。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define double long double
using namespace std;
int n,a[500005],b[500005],B,cnt,pos[500005];
double x[500005],lsh[500005];
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
#define ls(x) x<<1
#define rs(x) x<<1|1
struct SMT{
	int sz[2000006],cnt;
	double sum[2000006];
	inline void pushup(int p){sz[p]=sz[ls(p)]+sz[rs(p)],sum[p]=sum[ls(p)]+sum[rs(p)];}
	void modify(int p,int l,int r,int x,int num,double val)
	{
		if(l==r){sz[p]+=num,sum[p]+=val*num;return;}
		int mid=(l+r)>>1;
		if(x<=mid)	modify(ls(p),l,mid,x,num,val);
		else	modify(rs(p),mid+1,r,x,num,val);
		pushup(p);
	}
	int kth(int p,int l,int r,int k)
	{
		if(l==r)	return l;
		int mid=(l+r)>>1; 
		if(sz[ls(p)]>=k)	return kth(ls(p),l,mid,k);
		else	return kth(rs(p),mid+1,r,k-sz[ls(p)]);
	}
	int qnum(int p,int l,int r,int x,int y)
	{
		if(x>y)	return 0;
		if(x<=l&&r<=y)	return sz[p];
		int mid=(l+r)>>1,ans=0;
		if(x<=mid)	ans+=qnum(ls(p),l,mid,x,y);
		if(y>mid)	ans+=qnum(rs(p),mid+1,r,x,y);
		return ans;
	}
	double qval(int p,int l,int r,int x,int y)
	{
		if(x>y)	return 0;
		if(x<=l&&r<=y)	return sum[p];
		int mid=(l+r)>>1;double ans=0;
		if(x<=mid)	ans+=qval(ls(p),l,mid,x,y);
		if(y>mid)	ans+=qval(rs(p),mid+1,r,x,y);
		return ans;
	}
}T;
signed main()
{
	n=read();
	for(int i=1;i<=n;i++)	a[i]=read();
	for(int i=1;i<=n;i++)	b[i]=read();
	for(int i=1;i<=n;i++)	x[i]=lsh[i]=-1.0*b[i]/a[i];
	sort(lsh+1,lsh+1+n);
	B=unique(lsh+1,lsh+1+n)-lsh-1;
	for(int i=1;i<=n;i++)	pos[i]=lower_bound(lsh+1,lsh+B+1,x[i])-lsh;
	for(int i=1;i<=n;i++)
	{
		cnt+=abs(a[i]),T.modify(1,1,B,pos[i],abs(a[i]),x[i]);
		int t=T.kth(1,1,B,(cnt+1)>>1);
		printf("%Lf\n",(lsh[t]*T.qnum(1,1,B,1,t-1)-T.qval(1,1,B,1,t-1))+(T.qval(1,1,B,t+1,B)-lsh[t]*T.qnum(1,1,B,t+1,B)));
	}
	return 0;
}
```



---


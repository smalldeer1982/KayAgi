# 【模板】线段树分裂

## 题目描述

给出一个可重集 $a$（编号为 $1$），它支持以下操作：

`0 p x y`：将可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值移动到一个新的可重集中（新可重集编号为从 $2$ 开始的正整数，是上一次产生的新可重集的编号+1）。

`1 p t`：将可重集 $t$ 中的数放入可重集 $p$，且清空可重集 $t$（数据保证在此后的操作中不会出现可重集 $t$）。

`2 p x q`：在 $p$ 这个可重集中加入 $x$ 个数字 $q$。

`3 p x y`：查询可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值的个数。

`4 p k`：查询在 $p$ 这个可重集中第 $k$ 小的数，不存在时输出 `-1`。

## 说明/提示

对于 $30\%$ 的数据，$1\leq n \leq {10}^3$，$1 \le m \le {10}^3$；  
对于 $100\%$ 的数据，$1 \le n \le 2 \times {10}^5$，$1 \le x, y, q \le m \le 2 \times {10}^5$。保证数据合法。

不开 `long long` 见祖宗！！

---

题面 by @[Limit](https://www.luogu.com.cn/user/86625)

std by @[Limit](https://www.luogu.com.cn/user/86625)（线段树分裂）

验题 by @[Froggy](https://www.luogu.com.cn/user/100285)（平衡树，不过合并的复杂度假掉了，倒数第二个测试点就是 hack 数据）

数据 by @[Froggy](https://www.luogu.com.cn/user/100285)

## 样例 #1

### 输入

```
5 12
0 0 0 0 0
2 1 1 1
2 1 1 2
2 1 1 3
3 1 1 3
4 1 2
2 1 1 4
2 1 1 5
0 1 2 4
2 2 1 4
3 2 2 4
1 1 2
4 1 3```

### 输出

```
3
2
4
3
```

# 题解

## 作者：ix35 (赞：142)

 线段树合并&分裂

网上找线段树合并/分裂的博客，讲得很清楚的也不多，某些部分只有自己 yy 一下了。

前置芝士：权值线段树，动态开点线段树。

在以下讨论中，我们设值域都为 $[1,n]$ 中的整数。

先定义代码中的一些东西：

$ch[i][0]$ 表示 $i$ 的左子结点，$ch[i][1]$ 表示 $i$ 的右子结点，$val[i]$ 表示 $i$ 点维护的值（出现了多少个该值域中的数）

------

 一、线段树合并

有时我们需要整合两棵权值线段树的信息，这个整合的过程称为线段树合并。我们以最简单的合并为例：将两棵树相加。

两棵树如何相加呢？在权值线段树上，每个点维护了一个当前区间中数的个数，而数的个数是可以相加的，这个合并的过程可以理解为：把两个可重集合并，对应的权值线段树上发生的过程。而相加的原理很简单，两棵同构的线段树，只需要对应位置相加即可，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/lersbjt4.png)

注意动态开点线段树上某些点是缺的，其值当然是 $0$。

如何合并两棵线段树呢？

暴力是很简单的，我们枚举 $1$ 到 $n$，将第二棵树中对应位置上的值在第一棵树上做单点修改即可。

这个方法可以用启发式合并进一步优化，但只能适用于一些特殊情况（比如说如果带了分裂或者一个值在多棵树上出现，启发式合并就歇菜了）。

------

而我们可以递归处理线段树合并，设我们现在要合并的是以 $x,y$ 为根的两棵子树，要确保它们在线段树上处于同一位置（即它们是两棵树上代表同一区间的点）。

如果 $x,y$ 其中一个为 $0$ （也就是某个权值线段树上没有这个位置的点），无需合并，返回另一个非 $0$ 的点即可。

否则，我们先合并 $x,y$ 的左右子结点，再根据两子结点的信息整合得到 $x,y$ 合并的结果。

线段树合并一般有两种写法：新建结点和不新建结点。但是两者原理是一样的。

新建结点的写法：

   新建一个结点 $p$ 作为 $x,y$ 合并的结果。将 $ch[x][0]$ 和 $ch[y][0]$ 的合并结果记为 $sl$，$ch[x][1]$ 和 $ch[y][1]$ 的合并结果记为 $sr$，令 $sl,sr$ 分别为 $p$ 的两个子结点，对 $p$ 做一次 pushup​ 即可得到结果。此后 $x,y$ 就没有用的，可以回收（节省空间的方法）。但是有时 $x,y$ 的信息不能丢，这时就不能回收。
   
   （这里原先的代码有点问题，先删了）

不新建结点的写法：

   如果一个点合并完就可以扔掉，那还可以写得更加简便，直接将 $x$ 作为合并后的结果，将 $y$ 的值加到 $x$ 上即可（直接对应位置相加），甚至不需要 pushup，但是注意，如果 $x=0$，返回的是 $y$，所以比较保险的写法是 $x=merge(x,y)$。

   事实上这里我们连当前区间的左右端点 $l,r$ 也可以去掉，因为到叶结点后 $ch[x][i]$ 自然是 $0$，自然会返回。

```cpp
int merge (int x,int y) {
   	if (!x||!y) {return x+y;}     // 只有一边有点，不用合并
   	val[x]+=val[y];               // 信息整合
   	ch[x][0]=merge(ch[x][0],ch[y][0]);
   	ch[x][1]=merge(ch[x][1],ch[y][1]);
   	del(y);                       // 垃圾回收
   	return x;
}
```

这东西看着很一般，复杂度怎么样呢？

单独讨论一次合并的复杂度没有什么意义，如果两棵树都是满的，复杂度就到 $O(n)$ 了，所以一般从均摊角度来讨论。

------

如果现在有 $m$ 棵线段树（每棵树初始只有一个位置有权值），经过若干次合并最后变成 $1$ 棵，此过程的复杂度是多少呢？

例题：[P4556](https://www.luogu.com.cn/problem/P4556)，[P5298](https://www.luogu.com.cn/problem/P5298)

不说具体怎么做了，这些题都有很完整的题解，我就分析一下复杂度（这些题都符合上面提到的模型）。

一开始有 $m$ 棵树，只有一个位置有权值，所以一棵树上结点数量为 $O(\log n)$，$m$ 棵树的结点总数也就是 $O(m\log n)$。

分析上面的代码，发现每一次进入 merge 函数，要么停止递归，要么继续递归并有一个点被垃圾回收。显然停止递归的 merge 次数与继续递归的 merge 次数同阶（不继续递归的情况是从递归的情况出来的，不会超过其两倍的数量）。

因此整个过程的复杂度就等于继续递归的 merge 函数进入次数的复杂度（每一次执行 merge 在不考虑递归时复杂度 $O(1)$），也就等同于被删除的结点个数，是不超过 $O(m\log n)$ 的（有点像势能分析？）。

注意复杂度本身和是否回收结点没有关系，只是借以分析而已。

所以整个过程的复杂度也就是 $O(m\log n)$。

但是线段树合并的复杂度不总是对的，不过本题中 $1$ 操作的复杂度我不知道是否是均摊 $\log n$ 的，希望有人能证明/证伪一下。

------

二、线段树分裂

将一个可重集前 $k$ 小的数与之后的数分成两个集合，那么对应的权值线段树就要裂成两棵权值线段树。

举个栗子：将 $[1,3]$ 和 $[4,4]$ 分开（这里为了方便直接用权值描述了，一般是按照第 $k$ 小的位置来的）：

![](https://cdn.luogu.com.cn/upload/image_hosting/g0vypgpq.png)

暴力当然也很简单，找到第 $k$，后面的值新建一棵树，在原树上减掉即可。

然而我们可以仿照 FHQ Treap 的套路，实现 $O(\log n)$ 的分裂。

设我们现在要将以 $x$ 为根的树分裂成 $x,y$ 为根的这两棵树（$y$ 本来是不存在的，传引用），以第 $k$ 小为界，前 $k$ 小在 $x$，之后的在 $y$。

首先看 $x$ 的左子树的值 $v$，如果 $v<k$，那么左侧依然归 $x$（不需要处理），递归右侧即可，注意 $k$ 变成了 $k-v$。

如果 $v=k$，那么左边归 $x$，右边归 $y$ 即可。

如果 $v>k$，那么右边归 $y$，递归左侧即可。

看完结构后看权值，$x$ 的新权值当然是 $k$，那么 $y$ 的权值也就是 $x$ 原先的权值减去 $k$ 了。

可以发现，如果 $v\ge k$，那么 $y$ 的右子结点都是需要赋值的，下面的代码直接归到了同一句里（else 所在的那一句）：

```cpp
void split (int x,int &y,ll k) {
	y=newnod();
	ll v=val[ch[x][0]];
	if (k>v) {split(ch[x][1],ch[y][1],k-v);}
	else {swap(ch[x][1],ch[y][1]);}         // 右子树归 y，x 的右子树变成 0
	if (k<v) {split(ch[x][0],ch[y][0],k);}
	val[y]=val[x]-k;
	val[x]=k;
	return;
}
```

这个每次只递归一边，复杂度是 $O(\log n)$ 没啥问题。

------

三、这道题

每个操作分别来看。

将 $[x,y]$ 分裂出来：先分出 $[1,x-1]$，再从 $[x,n]$ 中分出 $[x,y]$ 和 $[y+1,n]$，最后把 $[1,x-1]$ 和 $[y+1,n]$ 合并。我注意到 std 不是这样的，std 的分裂写的就是分裂出一个区间，我在这里用了一次合并，但是复杂度是对的，稍后会证明复杂度为 $O(\log n)$；

将 $t$ 树合并入 $p$ 树：单次合并即可，不确定复杂度，但是不超过 $2\times 10^3$ 次总没问题的；

$p$ 树中插入 $a$ 个 $q$：单点修改，复杂度 $O(\log n)$；

查询 $[x,y]$ 中数的个数：区间求和，复杂度 $O(\log n)$；

查询第 $k$ 小：经典操作，复杂度 $O(\log n)$。

最后说一下 $0$ 操作的复杂度：

两次分裂是 $O(\log n)$ 没问题，主要看合并。注意合并的两个区间没有交集，我们就看一看每一层会涉及几个点。

对于第 $1$ 层：总共就 $1$ 个点...

对于第 $i$ 层：如果第 $i-1$ 层只递归下来 $1$ 个点（设为 $u$），再设 $x$ 和 $y$ 为 $u$ 的左右子结点。如果前一棵树占了 $x,y$ 两个点，那么因为后一棵树占的区间严格在前一棵树之后，所以只会占 $y$，那么需要递归的只有 $y$，反过来的话同理需要递归的只有 $x$，所以第 $i$ 层也只需要递归 $1$ 个点。

每一层只往下递归一个点，复杂度就是 $O(\log n)$ 了。

代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=200010;
int n,m,tot,cnt,seq=1,op,x,y,z,bac[MAXN<<5],ch[MAXN<<5][2],rt[MAXN];
ll val[MAXN<<5];
int newnod () {return (cnt?bac[cnt--]:++tot);}
void del (int p) {
	bac[++cnt]=p,ch[p][0]=ch[p][1]=val[p]=0;
	return;
}
void modify (int &p,int l,int r,int pos,int v) {
	if (!p) {p=newnod();}
	val[p]+=v;
	if (l==r) {return;}
	int mid=(l+r)>>1;
	if (pos<=mid) {modify(ch[p][0],l,mid,pos,v);}
	else {modify(ch[p][1],mid+1,r,pos,v);}
	return;
}
ll query (int p,int l,int r,int xl,int xr) {
	if (xr<l||r<xl) {return 0;}
	if (xl<=l&&r<=xr) {return val[p];}
	int mid=(l+r)>>1;
	return query(ch[p][0],l,mid,xl,xr)+query(ch[p][1],mid+1,r,xl,xr);
}
int kth (int p,int l,int r,int k) {
	if (l==r) {return l;}
	int mid=(l+r)>>1;
	if (val[ch[p][0]]>=k) {return kth(ch[p][0],l,mid,k);}
	else {return kth(ch[p][1],mid+1,r,k-val[ch[p][0]]);}
}
int merge (int x,int y) {
	if (!x||!y) {return x+y;}
	val[x]+=val[y];
	ch[x][0]=merge(ch[x][0],ch[y][0]);
	ch[x][1]=merge(ch[x][1],ch[y][1]);
	del(y); 
	return x;
}
void split (int x,int &y,ll k) {
	if (x==0) {return;}
	y=newnod();
	ll v=val[ch[x][0]];
	if (k>v) {split(ch[x][1],ch[y][1],k-v);}
	else {swap(ch[x][1],ch[y][1]);}
	if (k<v) {split(ch[x][0],ch[y][0],k);}
	val[y]=val[x]-k;
	val[x]=k;
	return;
}
int main () {
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) {
		scanf("%d",&x);
		modify(rt[1],1,n,i,x);
	}
	for (int i=1;i<=m;i++) {
		scanf("%d",&op);
		if (op==0) {
			scanf("%d%d%d",&x,&y,&z);
			ll k1=query(rt[x],1,n,1,z),k2=query(rt[x],1,n,y,z);
			int tmp=0;
			split(rt[x],rt[++seq],k1-k2);
			split(rt[seq],tmp,k2);
			rt[x]=merge(rt[x],tmp);
		} else if (op==1) {
			scanf("%d%d",&x,&y);
			rt[x]=merge(rt[x],rt[y]);
		} else if (op==2) {
			scanf("%d%d%d",&x,&y,&z);
			modify(rt[x],1,n,z,y);
		} else if (op==3) {
			scanf("%d%d%d",&x,&y,&z);
			printf("%lld\n",query(rt[x],1,n,y,z));
		} else if (op==4) {
			scanf("%d%d",&x,&y);
			if (val[rt[x]]<y) {printf("-1\n");continue;}
			printf("%d\n",kth(rt[x],1,n,y));
		}
	}
	return 0;
}
```



---

## 作者：cyffff (赞：82)

## 浅谈线段树分裂 
## $\text{Part -1}$ 目录
- $\text{Part 0}$ 前言
- $\text{Part 1}$ 介绍
- $\text{Part 2}$ 实现
- $\text{Part 3}$ 应用
- $\text{Part 4}$ 后记
- $\text{Part 5}$ 参考

## $\text{Part 0}$ 前言
- Q：有什么数据结构是支持用合并&分裂查询答案信息的呢？
- A：$\text{fhq-Treap}$
- Q：还有吗？
- A：当然，线段树。

前置芝士：[权值线段树](https://www.luogu.com.cn/blog/bfqaq/qian-tan-quan-zhi-xian-duan-shu)、[线段树合并](https://www.luogu.com.cn/blog/styx-ferryman/xian-duan-shu-ge-bing-zong-ru-men-dao-fang-qi)

约定：$val_x$ 为节点 $x$ 的权值， $ls(x),rs(x)$ 分别为 $x$ 节点的左儿子、右儿子。

$\text{An Interesting Fact}$：$\text{URL}$ 中的 $\text{segment}$ 打错了。
## $\text{Part 1}$ 介绍
线段树分裂，顾名思义就是将线段树分裂开。为了维护线段树合并所维护的可重集，我们需要将权值线段树中前 $k$ 小的位置和其余数分在两颗权值线段树上进行维护。

具体怎么分裂呢？我们来看一张图：

![sum](https://cdn.luogu.com.cn/upload/image_hosting/77dv4pwn.png?x-oss-process=image/resize,m_lfit,h_170,w_225)![l](https://cdn.luogu.com.cn/upload/image_hosting/z08dbgcz.png?x-oss-process=image/resize,m_lfit,h_170,w_225)![right](https://cdn.luogu.com.cn/upload/image_hosting/a9fm6he1.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

最左边的线段树即可按 $[1,3]$ 和 $[4,4]$ 分裂成右边两颗线段树。

（wtcl 不会画树请谅解）
## $\text{Part 2}$ 实现
怎么实现？

~~我会暴力 $O(n)$！~~

回顾 $\text{Part 0}$，我们将线段树分裂与 $\text{fhq-Treap}$ 对比，现在我们也可以参考 $\text{fhq-Treap}$ 的分裂方法。

考虑函数 $\text{split}(x,y,k)$ 分裂线段树上以 $x$ 为根节点的子树，另一颗线段树为 $y$，其中定义 $v=val_{ls(x)}$。

- $v<k$，左端不需要修改，直接执行 $\text{split}(rs(x),rs(y),k-v)$。
- $v=k$，那么我们发现左子树正好包含前 $k$ 个，于是直接将右子树归给 $y$，即${rs(y)=rs(x),rs(x)=0}$。
- $v>k$，右子树全部大于 $k$，直接归给 $y$，接着递归左子树，执行 $\text{split}(ls(x),ls(y),k)$。

代码很好写，贴一下：
```cpp
inline void split(int x,int &y,ll k){
	if(!x) return ;
	y=newnode();
	ll v=val[son[x][0]];
	if(k>v)
		split(son[x][1],son[y][1],k-v);
	else
		swap(son[x][1],son[y][1]);
	if(k<v)
		split(son[x][0],son[y][0],k);
	val[y]=val[x]-k;
	val[x]=k;
}
```
我们发现上述三种情况都是每层只递归 $O(1)$ 次，复杂度 $O(\log n)$。
## $\text{Part 3}$ 应用
### 例1 P5494 【模板】线段树分裂
[$\text{Link}$](https://www.luogu.com.cn/problem/P5494)

简化题意：维护一些可重集支持以下操作：

- $\text{cut}(p,x,y)$，将可重集 $p$ 中在 $[x,y]$ 范围中的数移动到一个新的可重集中。
- $\text{copy}(p,t)$，将可重集 $t$ 中的数放入可重集 $p$ 并删除 $t$。
- $\text{insert}(p,x,q)$，向可重集 $p$ 中放入 $x$ 个数字 $q$。
- $\text{query}(p,x,y)$，统计可重集 $p$ 中在 $[x,y]$ 范围中的数的个数。
- $\text{queryk}(p,k)$，查询可重集 $p$ 中第 $k$ 小的数。

每个操作分析一下：

$\text{copy}$ 可以直接 $p=\text{merge}(p,t)$，也就是直接合并线段树。

$\text{insert}$ 可以直接在 $p$ 中单点修改，复杂度 $O(\log n)$。

$\text{query}$，直接区间求和，复杂度 $O(\log n)$。

$\text{queryk}$，求全局第 $k$ 小，复杂度 $O(\log n)$。

$\text{cut}$，考虑将 $[1,x-1],[x,y],[y+1,n]$ 三段 $\text{split}$ 出来，将 $[1,x-1],[y+1,n]\,\,\text{merge}$ 回去即可。

然后是证一下合并的复杂度：

$\text{insert}$ 在线段树中只会新建 $O(1)$ 个叶子，则对于两棵树合并只会造成 $O(\log n)$ 的影响，则总的复杂度是 $O(n\log n)$ 的。

对于 $\text{cut}$ 操作，单次复杂度 $O(\log n)$，如果分裂出来 $x$ 个叶结点，则减少了此后 $O(x\log n)$ 的合并复杂度。如果合并被分裂出来的复杂度增加则需要插入重新补充叶结点，转化为 $\text{insert}$ 的影响。

时间复杂度 $O(n\log n)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=4e5+10;
int n,m;
struct Segment_Tree{
	int son[N*20][2],rt[N],cnt,rtc=1;
	ll val[N*20];
	int pool[N*20],delcnt;
	#define ls (son[rt][0])
	#define rs (son[rt][1])
	inline int newnode(){
		return delcnt?pool[delcnt--]:++cnt;
	}
	inline void del(int rt){
		pool[++delcnt]=rt;
		ls=rs=val[rt]=0;
	}
	inline void modify(int &rt,int l,int r,int p,int v){
		if(!rt)
			rt=newnode();
		val[rt]+=v;
		if(l==r) return ;
		int mid=l+r>>1;
		if(p<=mid)
			modify(ls,l,mid,p,v);
		else
			modify(rs,mid+1,r,p,v);
	}
	inline ll query(int rt,int l,int r,int L,int R){
		if(R<l||r<L)
			return 0;
		if(L<=l&&R>=r)
			return val[rt];
		int mid=l+r>>1;
		return query(ls,l,mid,L,R)+query(rs,mid+1,r,L,R);
	}
	inline int queryk(int rt,int l,int r,int v){
		if(l==r) return l;
		int mid=l+r>>1;
		if(val[ls]>=v)
			return queryk(ls,l,mid,v);
		else
			return queryk(rs,mid+1,r,v-val[ls]);
	}
	inline int merge(int a,int b){
		if(!a||!b) return a+b;
		val[a]+=val[b];
		son[a][0]=merge(son[a][0],son[b][0]);
		son[a][1]=merge(son[a][1],son[b][1]);
		del(b);
		return a;
	}
	inline void split(int x,int &y,ll k){
    	if(!x) return ;
    	y=newnode();
    	ll v=val[son[x][0]];
    	if(k>v)
    		split(son[x][1],son[y][1],k-v);
    	else
    		swap(son[x][1],son[y][1]);
    	if(k<v)
    		split(son[x][0],son[y][0],k);
    	val[y]=val[x]-k;
    	val[x]=k;
    }
}t;
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		int x=read();
		t.modify(t.rt[1],1,n,i,x);
	}
	for(int i=1;i<=m;i++){
		int opt=read();
		switch(opt){
			case 0:{
				int x=read(),y=read(),z=read();
				ll q1=t.query(t.rt[x],1,n,1,z),q2=t.query(t.rt[x],1,n,y,z);
				int a=0;
				t.split(t.rt[x],t.rt[++t.rtc],q1-q2);
				t.split(t.rt[t.rtc],a,q2);
				t.rt[x]=t.merge(t.rt[x],a);
				break;
			}
			case 1:{
				int x=read(),y=read();
				t.rt[x]=t.merge(t.rt[x],t.rt[y]);
				break;
			}
			case 2:{
				int x=read(),y=read(),z=read();
				t.modify(t.rt[x],1,n,z,y);
				break;
			}
			case 3:{
				int x=read(),y=read(),z=read();
				write(t.query(t.rt[x],1,n,y,z));
				putc('\n');
				break;
			}
			case 4:{
				int x=read(),y=read();
				if(t.val[t.rt[x]]<y) write(-1);
				else write(t.queryk(t.rt[x],1,n,y));
				putc('\n');
				break;
			}
		}
	}
	flush();
}
```
（我所有代码中的快读快写都删掉了，需要的可以在[$\text{ P7809 }$](https://www.luogu.com.cn/problem/P7809)找到。）
### 例2 P2824 [HEOI2016/TJOI2016]排序
[$\text{Link}$](https://www.luogu.com.cn/problem/P2824)

简化题意：维护一个 $[1,n]$ 的排列，$m$ 次操作，每次操作区间升序或者降序排序，最后求位置 $p$ 上的数。

考虑排序之后合并可以用权值线段树简单合并。

考虑用珂朵莉树维护有序区间，$\text{sort}(l,r,op)$ 可以直接先 $\text{split}'(r+1),\text{split}'(l)$（注意 $\text{split}'$ 是珂朵莉树上的分裂操作），可以将两边的区间 $\text{split}$ 开，再在珂朵莉树中间区间的线段树 $\text{merge}$ 起来即可。

时间复杂度感性分析一下每次分裂多出来 $O(1)$ 级别的区间，总共合并是 $O(n+m)$ 级别的，所以时间复杂度为 $O(n\log n)$（$n,m$ 同级）。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=4e5+10;
int n,m;
struct Segment_Tree{
	int son[N*20][2],rt[N],cnt,rtc=1;
	ll val[N*20];
	int pool[N*20],delcnt;
	#define ls (son[rt][0])
	#define rs (son[rt][1])
	inline int newnode(){
		return delcnt?pool[delcnt--]:++cnt;
	}
	inline void del(int rt){
		pool[++delcnt]=rt;
		ls=rs=val[rt]=0;
	}
	inline void modify(int &rt,int l,int r,int p){
		if(!rt){
			rt=newnode();
		}
		val[rt]=1;
		if(l==r) return ;
		int mid=l+r>>1;
		if(p<=mid) modify(ls,l,mid,p);
		else modify(rs,mid+1,r,p);
	}
	inline int merge(int a,int b){
		if(!a||!b) return a+b;
		val[a]+=val[b];
		son[a][0]=merge(son[a][0],son[b][0]);
		son[a][1]=merge(son[a][1],son[b][1]);
		del(b);
		return a;
	}
	inline void split(int &x,int y,int v,int p){
		if(val[y]==v) return ;
		x=newnode();
		val[x]=val[y]-v;
		val[y]=v;
		ll q=val[son[x][0]];
		if(v<=val[son[y][p]]){
			split(son[x][p],son[y][p],v,p);son[x][!p]=son[y][!p],son[y][!p]=0;
		}else{
			split(son[x][!p],son[y][!p],v-val[son[y][p]],p);
		}
	}
	inline int query(int rt,int l,int r){
		if(l==r) return l;
		int mid=l+r>>1;
		return ls?query(ls,l,mid):query(rs,mid+1,r);
	}
}t;
#define sit set<node>::iterator
struct node{
	int l,r;
	mutable int v;
	node(int L,int R=-1,int V=0):l(L),r(R),v(V){}
	friend bool operator<(const node& a,const node &b){
		return a.l<b.l;
	}
};
set<node>a;
inline sit split(int p){
	sit it=a.lower_bound(node(p));
	if(it!=a.end()&&it->l==p)
		return it;
	it--;
	int l=it->l,r=it->r,v=it->v;
	a.erase(it);
	t.split(t.rt[p],t.rt[l],p-l,v);
	a.insert(node(l,p-1,v));
	return a.insert(node(p,r,v)).first;
}
int main(){
	n=read(),m=read();
	a.insert(node(n+1,n+1,0));
	for(int i=1;i<=n;i++){
		t.modify(t.rt[i],0,n,read());
		a.insert(node(i,i,0));
	}
	while(m--){
		int opt=read(),l=read(),r=read();
		sit R=split(r+1),L=split(l);
		L->v=opt;
		for(sit i=++L;i!=R;i++)t.merge(t.rt[l],t.rt[i->l]);
		a.erase(L,R);
	}
	int q=read();
	split(q+1),split(q);
	printf("%d\n",t.query(t.rt[q],0,n));
	flush();
}
```
### 例3 CF558E A Simple Task
[$\text{Link}$](https://www.luogu.com.cn/problem/CF558E)

简化题意：维护一个字符串，$m$ 次操作，每次操作区间升序或者降序排序，最后求整个字符串。

我们发现这道题和上一道题基本一样，于是把代码一粘，改几下，发现过不了样例！

于是我们发现上一道题的序列是 $[1,n]$ 的一个排列，这道题的却是有重复的。

怎么处理呢？我们可以强行将 $[1,26]$ 的一个序列“离散化”成 $[1,n]$ 的排列，我们可以用 $\text{pair}$ 进行离散化。

离散化：
```cpp
int d[N],e[N];
pair<int,int>c[N];
for(int i=1;i<=n;i++){
	c[i]=make_pair(d[i]=getc()-'a'+1,i);
}
sort(c+1,c+n+1);
for(int i=1;i<=n;i++){
	int k=lower_bound(c+1,c+n+1,make_pair(d[i],i))-c;
	e[k]=d[i];
}
```
要完整代码可以点 [$\text{Here}$](https://www.luogu.com.cn/paste/ztiz3sk1)。
## $\text{Part 4}$ 后记
写这篇文章加深了我对线段树分裂的理解，因为线段树分裂考到的次数很少，所以没有找到多少题做例子，非常感谢你看到这里，我有些东西写得不够好、不够严谨，或者有其他例题，你们可以帮忙指出，万分感谢！
## $\text{Part 5}$ 参考
[题解 P6012 【【模板】线段树分裂】 - ix35](https://www.luogu.com.cn/blog/ix-35/solution-p6012)

[题解 P2824 【[HEOI2016/TJOI2016]排序】 - 一扶苏一](https://www.luogu.com.cn/blog/fusu2333/solution-p2824)

- $\text{upd 2021.7.4}$：感谢 [dying](https://www.luogu.com.cn/user/85593) 和 [GuidingStar](https://www.luogu.com.cn/user/75840) 指出合并的复杂度证明问题。如果仍错误请继续指出！
- $\text{upd 2021.7.28}$：对部分代码的实现进行修改，更能看了。
- $\text{upd 2021.8.21}$：$\text{fixed a typo}$。
- $\text{upd 2021.8.27}$：$\text{added\&fixed something}$。
- $\text{upd 2021.8.28}$：$\text{fixed something}$。

---

## 作者：Limit (赞：43)

(因为没有认证,所以这道题就由[Froggy](https://www.luogu.com.cn/user/100285)上传)
线段树分裂用到的地方确实并不多,luogu上以前也没有这道模板题,所以就出了一道,实在是想不出怎么出模板了,所以这道题可能可以用一些其他的算法水过去.

# 前置芝士

1. [线段树](https://baike.baidu.com/item/线段树/10983506?fr=aladdin): 本题中用到的是权值线段树(查询每个数在序列中出现的次数,序列中第k大的数等操作).
2. 线段树合并: ~~为了增加一下码量才放上的~~.

# 线段树分裂
既然是模板题,这个自然才是重点.
以下这样一颗线段树:

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200121180206699.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N4eV9fb3J6,size_16,color_FFFFFF,t_70)

需要将橙色线段覆盖的部分分裂出来,需要建一颗新的树,当一个节点所代表的区间与需要分裂的区间有交时需要开一个新的节点(绿色部分),原来的树中需要将那些整个被分裂的部分直接接到新的树下面,并且将于原来的树的边断开(红色部分),可以发现被断开的边最多只会有$\log_2N$条,所以最终每次分裂的时间复杂度就是$\log_2N$(证明方法与区间修改为$N\log_2N$相同).

# 代码
```cpp
#include<bits/stdc++.h>
#define rap(i,first,last) for(int i=first;i<=last;++i)
//线段树标准define
#define Lson (tree[now].lson)
#define Rson (tree[now].rson)
#define Middle ((left+right)>>1)
#define Left Lson,left,Middle
#define Right Rson,Middle+1,right
#define Now nowleft,nowright
using namespace std;
const int maxN=6e5+7;//因为有分裂,需要大一点的空间
int N,M;
struct Tree//线段树中每一个节点
{
	int lson,rson;//动态开点,记录左右儿子
	long long sum;//区间和
}tree[maxN*4];
int cnt=0;
//一下是一个空间回收,可以将在线段树合并后没有用的点回收,更好地利用空间
int tot=0;//删掉的节点的个数
int rubbish[maxN*4];//用来放删掉的节点的编号
void Del(int &now)//删除一个节点
{
	tree[now].lson=tree[now].rson=tree[now].sum=0;//先清空
	rubbish[++tot]=now;//放入垃圾桶
	now=0;
}
int New()//得到一个新的节点
{
	if(tot)return rubbish[tot--];//垃圾桶不是空的就从垃圾桶上面拿一个
	return ++cnt;//垃圾桶是空的就拿一个全新的节点
}
//空间回收代码结束
int arr[maxN];//开始读入的数组
void PushUp(int now)//合并信息
{
	tree[now].sum=tree[Lson].sum+tree[Rson].sum;
}
void Build(int &now,int left=1,int right=N)//建树
{
	if(!now)now=New();//得到一个新节点
	if(left==right)
	{
		tree[now].sum=arr[left];//叶节点直接赋值
		return;
	}
	Build(Left);//建左子树
	Build(Right);//建右子树
	PushUp(now);//合并信息
}
void Merge(int &tree1,int &tree2,int left=1,int right=N)//线段树合并,将tree2合并到tree1上
{
	if(!tree1||!tree2)//如果当前这棵树只有其中一颗树有就可以直接赋值
	{
		tree1+=tree2;
		return;
	}
	if(left==right)//叶节点就直接合并
	{
		tree[tree1].sum+=tree[tree2].sum;
		Del(tree2);//删掉tree2
		return;
	}
	Merge(tree[tree1].lson,tree[tree2].lson,left,Middle);//继续合并
	Merge(tree[tree1].rson,tree[tree2].rson,Middle+1,right);
	Del(tree2);//删掉tree2
	PushUp(tree1);//合并信息
}
void Split(int &tree1,int &tree2,int nowleft,int nowright,int left=1,int right=N)//线段树分裂(将tree1中nowleft~nowright部分分裂到tree2中)
{
	if(right<nowleft||nowright<left)return;//没有被覆盖就直接返回
	if(!tree1)return;//如果tree1没有自然也没有用了
	if(nowleft<=left&&right<=nowright)//被完全覆盖时
	{
		tree2=tree1;
		tree1=0;//把边断开
		return;
	}
	if(!tree2)tree2=New();//得到一个新节点
	Split(tree[tree1].lson,tree[tree2].lson,Now,left,Middle);//左右子树继续分裂
	Split(tree[tree1].rson,tree[tree2].rson,Now,Middle+1,right);
	PushUp(tree1);//合并两数信息
	PushUp(tree2);
}
void UpData(int num,int add,int &now,int left=1,int right=N)//单点修改(不多讲)
{
	if(num<left||num>right)return;
	if(!now)now=New();
	if(left==right)
	{
		tree[now].sum+=add;
		return;
	}
	UpData(num,add,Left);
	UpData(num,add,Right);
	PushUp(now);
}
long long QuerySum(int nowleft,int nowright,int now,int left=1,int right=N)//查询区间和(不多讲)
{
	if(nowright<left||right<nowleft)return 0;
	if(!now)return 0;
	if(nowleft<=left&&right<=nowright)
	{
		return tree[now].sum;
	}
	return QuerySum(Now,Left)+QuerySum(Now,Right);
}
int QueryKth(long long k,int now,int left=1,int right=N)//查询区间第k大(不多讲)
{
	if(k<=0)return -1;
	if(left==right)return left;
	if(tree[Lson].sum>=k)return QueryKth(k,Left);
	return QueryKth(k-tree[Lson].sum,Right);
}
int root[maxN];//记录每一个序列的线段树的根节点
int cnttree=1;//序列的编号
int main()
{
	scanf("%d%d",&N,&M);
	rap(i,1,N)scanf("%d",&arr[i]);
	Build(root[1]);//以root[1]建树
	int check,p,t,x,y,k,q,kth;
	rap(i,1,M)
	{
		scanf("%d",&check);
		if(check==0)
		{
			scanf("%d%d%d",&p,&x,&y);
			Split(root[p],root[++cnttree]/*建一颗新树*/,x,y);//分裂
		}
		if(check==1)
		{
			scanf("%d%d",&p,&t);
			Merge(root[p],root[t]);//合并
		}
		if(check==2)
		{
			scanf("%d%d%d",&p,&x,&q);
			UpData(q,x,root[p]);//修改
		}
		if(check==3)
		{
			scanf("%d%d%d",&p,&x,&y);
			printf("%lld\n",QuerySum(x,y,root[p]));//区间和
		}
		if(check==4)
		{
			scanf("%d%d",&p,&k);
			if(QuerySum(1,N,root[p])<k)kth=-1;//区间和都没有k自然是不会有第k大了
			else
			kth=QueryKth(k,root[p]);
			printf("%d\n",kth);
		}
	}
}
```

---

## 作者：DaydreamWarrior (赞：34)

[或许更好的阅读体验](https://rainlycoris.github.io/posts/P5494/)

这是一篇平衡树合并题解，平衡树合并的复杂度 __并不是假的__，本题复杂度 $O(n \log n)$，更通用的可以证明到 $O(\log^2 n)$，比如支持序列 __全局加全局取膜__。

平衡树比线段树适用性更广，常数也不大（未卡常无旋 treap 用时 615ms），注意下文 $n,V$ 不分。

## 平衡树合并

先不考虑分裂，单说合并。

现在要合并 $x,y$ 两棵树，选根节点堆值大的当根（假设是 $x$），把 $y$ 的子树按照 $x$ 的键值裂开（这里的裂开就是 treap 的 split），裂开的两瓣和 $x$ 的左右儿子递归下去合并。

```cpp
int Merge(int x,int y){
    if(!x||!y)
        return x|y;
    if(tr[x].pri<tr[y].pri)
        swap(x,y);
    int l,r;
    split(y,tr[x].v,l,r);
    tr[x].l = Merge(tr[x].l,l);
    tr[x].r = Merge(tr[x].r,r);
    pushup(x);
    return x;
}
```

明显是把小的树裂开更优，但是堆值大大概率就是树大的，下文也默认此情况（主要是带有随机的不会分析）。

其实这里存在一个合不合并相同结点的问题，其实是 __要合并__ 的，因为 treap 的复杂度依赖于树和堆的唯一性，如果存在相同结点那么可能会失去性质（比如全部都一样，可以在不违反树和堆的情况下出来一条链），对于一般的 treap 不存在此问题，因为自带了一个插入时间的比较。__注意这里代码没写__。

现在分析平衡树合并的复杂度，设第一棵树大小为 $a$，第二棵为 $b$，不难发现单次合并的复杂度 __上界__ 为 $O(\min(a,b)\log(\frac{\max(a,b)}{\min(a,b)}))$，大概是把小的树每个节点都拿去切割大的树，由于 finger search 所以切割复杂度为 $\log(\frac{\max(a,b)}{\min(a,b)})$。总复杂度为 $O(n \log n)$。

为什么说是上界，因为在两颗树值域重合少的时候复杂度和值域段数 $k$ 有关，合并一次的复杂度为 $O(k \log n)$。

值域段数是指把所有值排序后相邻两个值属于不同树的个数。

## 本题的复杂度分析

可以直接用森林的值域段数作为势能，一次 split 会增加 $1$，一次 $O(k\log n)$ 的合并会减少 $k$，所以时间复杂度为 $O(n \log n)$。

可以把合并的过程看作填空，split 过的地方就是空的分割线。

$$
{[-----][\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ][\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ][\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ][-----]}
$$

$][$ 的地方就是 split 过的地方，$[--]$ 的地方就是填上了的位置，也就是已经合并好了的连续段。

$$
{[-----][\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ][-----][\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ][-----]}
$$

那现在填上了，代价是 $O(2\log n)$，第二个 $][$ 的左边被用过了，第三个的右边被用过了。

一个 split 的左右会各被填一次，填一次的代价为 $O(\log n)$。

通过这个方法分析无 split 的 merge 也能得到 $O(n\log n)$ 的时间复杂度。

## 更通用的复杂度分析

定义势能为 $\varphi(T)=\sum\log(v_{i+1}-v_i)$，也就是 $T$ 相邻的两个值的差的 $\log$ 之和。

合并 $A$ 和 $B$，有 $k$ 段值域：

$$
\begin{aligned}
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ _{<-d_1->}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ _{<--d_2-->}\ \ \ \ \ \ \ \ \ \ _{<--d_3-->}\ \ \ \ \ \ \ \ \ \ _{<---d_4--->}\\
&A = \{_{[--a_1--]}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ _{[-a_2-]}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ _{[--a_3--]}&\}\\
&B = \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ _{[---b_1---]}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ _{[-b_2-]}&\}
\end{aligned}
$$

形如 $_{[-----]}$ 的是一段值域，形如 $_{<--d_i-->}$ 的是值域之间的距离且距离为 $d_i$。

合并后 $\Delta\varphi=\varphi(A)+\varphi(B)-\varphi(A\cup B)$，有
$$
\Delta\varphi=\log(d_1+b_1+d_2)+\log(d_2+a_2+d_3)+\dots+\log(d_{k-1}+a_{\frac{k}{2}}+d_k)-(\log d_1+\dots+\log d_k)
$$

前面的把 $\log(+a_i+)$ 的放在一起就是根据定义算的 $\varphi(A)$，后面的则是由于两段值域不交合并会产生新的势能，势能大小为 $\log$ 值域的距离也就是 $\log(d_i)$。

显然有
$$
\Delta\varphi\geq\log(d_1+d_2)+\log(d_2+d_3)+\dots+\log(d_{k-1}+d_k)-(\log d_1+\dots+\log d_k)
$$

因为 $\log$ 函数是上凸的，可得 $\log(\frac{a+b}{2})\geq \frac{\log a+\log b}{2}$，把 $\log$ 里的 $\frac{1}{2}$ 拿出来可得
$$
\log(a+b)\geq 1+\frac{\log a+\log b}{2}
$$

那么把 $\log(d_{i-1}+d_i)$ 全部拆开，可得
$$
\Delta\varphi\geq k-1-\frac{d_1+d_k}{2}
$$

忽略常数可得
$$
\Delta\varphi\geq k-O(\log V)
$$

也就是说最多做 $n \log V$ 次 split，总复杂度为 $O(n \log V \log n)$。

## 势能变化

一次分裂会减少 $\log V$ 的势能。

一次合并如果增加就至多增加 $\log V$ 的势能（原因可以看上面的式子）。

那么最多就只有 $n\log V$ 的势能，而 $\Delta \varphi$ 最大就是把这些势能都减少完，所以总复杂度为 $O(n \log n \log V)$。

## 代码

```cpp
const int N = 200005;
int n,m;

mt19937 myrand(713);
class fhqtreap{
    private:
        struct{int l,r,v,s,siz;unsigned pri;} tr[2*N];
        int rt[N];
        int idx;
        
        int create(int v,int s){tr[++idx] = {0,0,v,s,s,myrand()};return idx;}
        void pushup(int u){tr[u].siz = tr[tr[u].l].siz+tr[tr[u].r].siz+tr[u].s;}
    public:
        int& operator [] (const int &x){return rt[x];}
        void split(int u,int c,int &x,int &y){
            if(!u){
                x = y = 0;
                return;
            }
            if(tr[u].v<=c){
                x = u;
                split(tr[u].r,c,tr[x].r,y);
            }
            else{
                y = u;
                split(tr[u].l,c,x,tr[y].l);
            }
            pushup(u);
        }
        void split_rk(int u,int c,int &x,int &y){
            if(!u){
                x = y = 0;
                return;
            }
            if(tr[tr[u].l].siz+tr[u].s<=c){
                x = u;
                split_rk(tr[u].r,c-tr[tr[u].l].siz-tr[u].s,tr[x].r,y);
            }
            else{
                y = u;
                split_rk(tr[u].l,c,x,tr[y].l);
            }
            pushup(u);
        }
        int merge(int x,int y){
            if(!x||!y)
                return x|y;
            if(tr[x].pri>tr[y].pri){
                tr[x].r = merge(tr[x].r,y);
                pushup(x);
                return x;
            }
            tr[y].l = merge(x,tr[y].l);
            pushup(y);
            return y;
        }
        int Merge(int x,int y){
            if(!x||!y)
                return x|y;
            if(tr[x].pri<tr[y].pri)
                swap(x,y);
            int l,r;
            split(y,tr[x].v,l,r);
            tr[x].l = Merge(tr[x].l,l);
            tr[x].r = Merge(tr[x].r,r);
            pushup(x);
            return x;
        }
        void insert(int &u,int c,int s){
            int x,y;
            split(u,c,x,y);
            u = merge(merge(x,create(c,s)),y);
        }
        int kth(int &u,int K){
            int x,y;
            split_rk(u,K-1,x,y);
            int p = y;
            while(tr[p].l)
                p = tr[p].l;
            u = merge(x,y);
            return p?tr[p].v:-1;
        }
        int count(int &u,int l,int r){
            int x,y,z;
            split(u,l-1,x,y);
            split(y,r,y,z);
            int ans = tr[y].siz;
            u = merge(merge(x,y),z);
            return ans;
        }
        void move(int &x,int &y,int l,int r){
            int a,b,c;
            split(x,l-1,a,b);
            split(b,r,b,c);
            y = b;
            x = merge(a,c);
        }
}tr;

signed main(){
    n = in,m = in;
    for(int k=1;k<=n;k++)
        tr.insert(tr[1],k,in);
    int idx = 1;
    while(m--){
        int op = in,p = in;
        if(!op){
            int x = in,y = in;
            tr.move(tr[p],tr[++idx],x,y);
        }
        else if(op==1){
            int t = in;
            tr[p] = tr.Merge(tr[p],tr[t]);
        }
        else if(op==2){
            int x = in,q = in;
            tr.insert(tr[p],q,x);
        }
        else if(op==3){
            int x = in,y = in;
            out(tr.count(tr[p],x,y),'\n');
        }
        else
            out(tr.kth(tr[p],in),'\n');
    }
    return 0;
}
```

### 全局加全局取膜

全局加不影响势能。

如果取模的过程中把树分成了 $k$ 段，合并后产生了至多 $(k-1) \log v$ 的势能，但是 $v$ 也会变成 $\dfrac{v}{k}$。把 $\log v$ 提到外面来，显然每轮最劣的 $k$ 都是一样的，因为这是一个递归的问题。原问题变成了 $k$ 使得 $k\log_k n$ 最大。解得最小值取 $e$，最大值为 $n$。所以增加的势能最大为 $n \log v$。

所以总复杂度为 $O(n \log n\log v)$。

### 通用性

确实这东西很能拓展，只要不咋影响势能都可以把合并当作基本操作，比如加、除、取膜、开根、翻转。

其实全局取膜作用与值域区间也是对的，值域区间完全可以把它当成两个独立的序列分别操作后再 merge 起来，分别操作也就是 $(n-m)\log v+m \log v= n\log v$，完全不影响。最后只是常数段的 merge 新增的 $\log v$ 的势能。所以只会增加总共 $n \log v$ 的势能，别的同理。

### 参考

[https://codeforces.com/blog/entry/108601](https://codeforces.com/blog/entry/108601)

---

## 作者：lfxxx (赞：23)

来一发 $O(\log n)$ 线性空间的解法。

考虑通过只维护线段树叶子节点的虚树的方法压缩空间，考虑记录下每个节点的编号，然后通过异或完求最低位的 $1$ 的方式求出 LCA 的深度，然后记录下 LCA 右端点的编号。在回收节点的时候可以释放储存右端点编号的空间，但是这里为了方便就不这样做了。

具体维护方法看下面的代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 4e5+114;
int tot;
stack<int> brush;
struct Node{
    int ls,rs;
    int sum;
    int l,r;
}tree[maxn<<1];
int clone(){
    int New;
    if(brush.size()>0){
        New=brush.top();
        brush.pop();
    }
    else{
        New=++tot;
    }
    tree[New].l=tree[New].r=tree[New].sum=tree[New].ls=tree[New].rs=0;
    return New;
}
int root[maxn],val[maxn],lg[maxn];
inline int w(int x){
	int l=1,r=(1<<18),v=1,res=0;
	while(l!=r){
		int mid=(l+r)>>1;
		if(x<=mid){
			r=mid;
		}
		else{
			l=mid+1;
			res+=v;
		}
		v<<=1;
	}
	return res;
}
inline pair<int,int> LCA(int u,int v){
	if(val[u]==0) val[u]=w(u);
	if(val[v]==0) val[v]=w(v);
	int f=val[u]^val[v];
	f=f&(-f);
	int len=1<<(18-lg[f]);
	int pos=(u-1)/len+1;
	val[(pos-1)*len+1]=(f-1)&val[u];
	return make_pair((pos-1)*len+1,pos*len);
}
inline void pushup(int x){
    tree[x].sum=tree[tree[x].ls].sum+tree[tree[x].rs].sum;
}
inline void add(int x,int pos,int v){
    int mid=(tree[x].l+tree[x].r)>>1;
    if(pos<=mid){
        if(tree[x].ls==0){
            int y=clone();
            tree[x].ls=y;
            tree[y].sum+=v;
            tree[y].l=tree[y].r=pos;
            pushup(x);
            return ;
        }
        else{
            if(tree[tree[x].ls].l==tree[tree[x].ls].r){
                if(tree[tree[x].ls].l==pos){
                    tree[tree[x].ls].sum+=v;
                    pushup(x);
                    return ;
                }
                pair<int,int> lca=LCA(pos,tree[tree[x].ls].l);
                int y=clone();
                tree[y].l=lca.first;
                tree[y].r=lca.second;
                int A=y;
                int B=tree[x].ls;
                int z=clone();
                tree[z].sum+=v;
                tree[z].l=tree[z].r=pos;
                int C=z;
                tree[x].ls=A;
                if(tree[B].l>tree[C].l) swap(B,C);
                tree[A].ls=B;
                tree[A].rs=C;
                pushup(A);
                pushup(x);
                return ;
            }
            else{
                if(pos>tree[tree[x].ls].r||pos<tree[tree[x].ls].l){
                    pair<int,int> lca=LCA(pos,tree[tree[x].ls].l);
                    int y=clone();
                    tree[y].l=lca.first;
                    tree[y].r=lca.second;
                    int A=y;
                    int B=tree[x].ls;
                    int z=clone();
                    tree[z].sum+=v;
                    tree[z].l=tree[z].r=pos;
                    int C=z;
                    tree[x].ls=A;
                    if(tree[B].l>tree[C].l) swap(B,C);
                    tree[A].ls=B;
                    tree[A].rs=C;
                    pushup(A);
                    pushup(x);
                }
                else{
                    add(tree[x].ls,pos,v);
                    pushup(x);
                    return ;
                }
            }
        }
    }
    else{
        if(tree[x].rs==0){
            int y=clone();
            tree[x].rs=y;
            tree[y].sum+=v;
            tree[y].l=tree[y].r=pos;
            pushup(x);
            return ;
        }
        else{
            if(tree[tree[x].rs].l==tree[tree[x].rs].r){
                if(tree[tree[x].rs].r==pos){
                    tree[tree[x].rs].sum+=v;
                    pushup(x);
                    return ;
                }
                pair<int,int> lca=LCA(pos,tree[tree[x].rs].l);
                int y=clone();
                tree[y].l=lca.first;
                tree[y].r=lca.second;
                int A=y;
                int B=tree[x].rs;
                int z=clone();
                tree[z].sum+=v;
                tree[z].l=tree[z].r=pos;
                int C=z;
                tree[x].rs=A;
                if(tree[B].l>tree[C].l) swap(B,C);
                tree[A].ls=B;
                tree[A].rs=C;
                pushup(A);
                pushup(x);
                return ;
            }
            else{
                if(pos<tree[tree[x].rs].l||pos>tree[tree[x].rs].r){
                    pair<int,int> lca=LCA(pos,tree[tree[x].rs].l);
                    int y=clone();
                    tree[y].l=lca.first;
                    tree[y].r=lca.second;
                    int A=y;
                    int B=tree[x].rs;
                    int z=clone();
                    tree[z].sum+=v;
                    tree[z].l=tree[z].r=pos;
                    int C=z;
                    tree[x].rs=A;
                    if(tree[C].l>tree[B].l) swap(C,B);
                    tree[A].ls=C;
                    tree[A].rs=B;
                    pushup(A);
                    pushup(x);
                }
                else{
                    add(tree[x].rs,pos,v);
                    pushup(x);
                    return ;
                }
            }
        }
    }
}
inline int query(int x,int l,int r){
    int lt=tree[x].l;
    int rt=tree[x].r;
    if(x==0) return 0;
    if(rt<l||r<lt){
        return 0;
    }
    if(l<=lt&&rt<=r){
        return tree[x].sum;
    }
    int res=0,mid=(lt+rt)>>1;
    res+=query(tree[x].ls,l,r);
    res+=query(tree[x].rs,l,r);     
    return res;
}
int merge(int a,int b){
    if(a==0||b==0) return a+b;
    if((tree[a].r-tree[a].l+1)<(tree[b].r-tree[b].l+1)) swap(a,b);
    if(tree[a].l==tree[b].l&&tree[a].r==tree[b].r){
        if(tree[a].l==tree[a].r){
            tree[a].sum+=tree[b].sum;
            brush.push(b);
            return a;
        }
        int L=tree[b].ls,R=tree[b].rs;
        brush.push(b);
        tree[a].ls=merge(tree[a].ls,L);
        tree[a].rs=merge(tree[a].rs,R);
        pushup(a);
        return a;
    }   
    if(tree[a].l<=tree[b].l&&tree[b].r<=tree[a].r){
        int mid=(tree[a].l+tree[a].r)>>1;
        if(tree[b].l<=mid) tree[a].ls=merge(tree[a].ls,b);
        else tree[a].rs=merge(tree[a].rs,b);
        pair<int,int> lca=LCA(tree[tree[a].ls].l,tree[tree[a].rs].l);
        tree[a].l=lca.first,tree[a].r=lca.second;
        pushup(a);
        return a;
    }
    if(tree[a].l>tree[b].l) swap(a,b);
    if(tree[a].r<tree[b].l){
    	pair<int,int> lca=LCA(tree[a].l,tree[b].l);
    	int y=clone();
    	tree[y].l=lca.first;
    	tree[y].r=lca.second;
    	tree[y].ls=a;
    	tree[y].rs=b;
    	pushup(y);    	
    	return y;
	}
	else{
        int L=tree[b].ls,R=tree[b].rs;
        brush.push(b);
        tree[a].ls=merge(tree[a].ls,L);
        tree[a].rs=merge(tree[a].rs,R);
        pushup(a);
        return a;
	}
}
inline void maintain(int &x){    
    if(tree[x].l!=1||tree[x].r!=(1<<18)){
        int y=clone();
        tree[y].l=1,tree[y].r=(1<<18);
        int mid=(tree[y].l+tree[y].r)>>1;
        if(!x){
            x=y;
            return ;
        }
        if(tree[x].r<=mid){
            tree[y].ls=x;
        }
        else{
            tree[y].rs=x;
        }
        pushup(y);
        x=y;
    }
    return ;
}
inline void split(int &x,int &y,int l,int r){
    if(!x) return ;
    int lt=tree[x].l,rt=tree[x].r;
    if(rt<l||r<lt) return ;
    if(l<=lt&&rt<=r){
        y=x;
        x=0;
        return ;
    }
    if(!y) y=clone();
    split(tree[x].ls,tree[y].ls,l,r);
    split(tree[x].rs,tree[y].rs,l,r);
    if(tree[y].ls==0&&tree[y].rs==0){
        brush.push(y);
        y=0;
    }
    else if(tree[y].ls==0){
        brush.push(y);
        y=tree[y].rs;
    }
    else if(tree[y].rs==0){
        brush.push(y);
        y=tree[y].ls;
    }
    else{
        pair<int,int> lca=LCA(tree[tree[y].ls].l,tree[tree[y].rs].l);
        tree[y].l=lca.first,tree[y].r=lca.second;
        pushup(y);
    }
    if(tree[x].ls==0&&tree[x].rs==0){
        brush.push(x);
        x=0;
    }
    else if(tree[x].ls==0){
        brush.push(x);
        x=tree[x].rs;
    }
    else if(tree[x].rs==0){
        brush.push(x);
        x=tree[x].ls;
    }
    else{
        pair<int,int> lca=LCA(tree[tree[x].ls].l,tree[tree[x].rs].l);
        tree[x].l=lca.first,tree[x].r=lca.second;
        pushup(x);
    }
    return ;
}
inline int kth(int x,int k){
    if(tree[x].l==tree[x].r) return tree[x].l;
    if(k<=tree[tree[x].ls].sum) return kth(tree[x].ls,k);
    else return kth(tree[x].rs,k-tree[tree[x].ls].sum);
} 
void init(int pos){
    root[pos]=clone();
    tree[root[pos]].l=1;
    tree[root[pos]].r=(1<<18);
}
int n,m;
int cnt;
signed main(){
ios::sync_with_stdio(0);
cin.tie(0);
cout.tie(0);
for(int i=0;i<=18;i++) lg[1<<i]=i;
cin>>n>>m;
cnt++;
init(cnt);
for(int i=1;i<=n;i++){
    int x;
    cin>>x;
    add(root[cnt],i,x);
}
while(m--){
    int opt;
    cin>>opt;
    if(opt==0){
        int x,y,z;
        cin>>x>>y>>z;
        cnt++;
        split(root[x],root[cnt],y,z);
        maintain(root[x]);
        maintain(root[cnt]);
    }
    else if(opt==1){
        int x,y;
        cin>>x>>y;
        root[x]=merge(root[x],root[y]);
        maintain(root[x]);
    }
    else if(opt==2){
        int x,y,z;
        cin>>x>>y>>z;
        add(root[x],z,y);
    }
    else if(opt==3){
        int x,y,z;
        cin>>x>>y>>z;
        cout<<query(root[x],y,z)<<'\n';
    } 
    else{
        int x,y;
        cin>>x>>y;
        if(tree[root[x]].sum<y){
            cout<<"-1\n";
        }
        else{
            cout<<kth(root[x],y)<<'\n';
        }
    }
}
return 0;
}
```


---

## 作者：gxy001 (赞：12)

模板题，要求维护权值线段树合并，分裂，单项插入，区间查询，找第 $k$ 小。

权值线段树的节点 $[l,r]$ 维护的信息有，他的左孩子和右孩子，区间内元素个数。

### 单项插入

---

权值线段树基本操作，此题不用离散化。

```cpp
void update(int const &p,int const &v,int &x,int const &l=1,int const &r=n){
	if(!x) x=newnode();//动态开点
	tr[x].v+=v;
	if(l==r) return;
	int mid=(l+r)>>1;
	if(p<=mid) update(p,v,tr[x].ls,l,mid);
	else update(p,v,tr[x].rs,mid+1,r);
}
```

### 区间查询

---

也是基本操作，注意的是动态开点线段树在找到空节点后就可以返回了。

```cpp
long long query(int const &pl,int const &pr,int const &x,int const &l=1,int const &r=n){
	if(!x) return 0;
	if(pl==l&&pr==r) return tr[x].v;
	int mid=(l+r)>>1;
	if(pr<=mid) return query(pl,pr,tr[x].ls,l,mid);
	else if(pl>mid) return query(pl,pr,tr[x].rs,mid+1,r);
	else return query(pl,mid,tr[x].ls,l,mid)+query(mid+1,pr,tr[x].rs,mid+1,r);
}
```

### 找第 $k$ 小

---

在线段树上二分，如果左孩子的元素个数大于等于 $k$，说明第 $k$ 小在左子树内；否则，在右子树内。

```cpp
int kth(long long const &p,int const &x,int const &l=1,int const &r=n){
	if(tr[x].v<p) return -1;
	if(l==r) return l;
	int mid=(l+r)>>1;
	if(tr[tr[x].ls].v>=p) return kth(p,tr[x].ls,l,mid);
	else return kth(p-tr[tr[x].ls].v,tr[x].rs,mid+1,r);
}
```

### 线段树合并

---

线段树合并有两种写法，这里写的是将一棵树合并到另一颗上的写法。对于 $t$ 中没有的节点不用遍历；对于 $p$ 中没有但 $t$ 中有的，可以直接把该节点挂在 $p$ 上。（$p,t$ 的含义见题目）

```cpp
void merge(int &x1,int &x2,int const &l=1,int const &r=n){
	if(!x2) return;
	if(!x1){x1=x2;x2=0;return;}
	tr[x1].v+=tr[x2].v;
	int mid=(l+r)>>1;
	merge(tr[x1].ls,tr[x2].ls,l,mid);
	merge(tr[x1].rs,tr[x2].rs,l,mid);
	delnode(x2);//垃圾回收
}
```

### 线段树分裂

终于到正题了，线段树分裂是线段树合并的逆操作。对于待分裂区域与其他区域的公有节点，复制一份；对于独有节点，直接拿过来挂上去；最后记得 `pushup`。 

```cpp
void split(int const &pl,int const &pr,int &x1,int &x2,int const &l=1,int const &r=n){
	if(pl==l&&pr==r){
		x2=x1;
		x1=0;
		return;
	}
	if(!x2) x2=newnode();
	int mid=(l+r)>>1;
	if(pr<=mid) split(pl,pr,tr[x1].ls,tr[x2].ls,l,mid);
	else if(pl>mid) split(pl,pr,tr[x1].rs,tr[x2].rs,mid+1,r);
	else split(pl,mid,tr[x1].ls,tr[x2].ls,l,mid),split(mid+1,pr,tr[x1].rs,tr[x2].rs,mid+1,r);
	tr[x1].v=tr[tr[x1].ls].v+tr[tr[x1].rs].v;//pushup
	tr[x2].v=tr[tr[x2].ls].v+tr[tr[x2].rs].v;
}
```

### ~~可回收垃圾(~~

---
新建节点和删除节点，开个垃圾桶，回收废弃节点。

```cpp
int newnode(){
	if(tp!=lj)return *--tp;
	else return ++cnt;
}
void delnode(int &x){
	*tp++=x;
	tr[x].v=tr[x].ls=tr[x].rs=0;
	x=0;
}
```

## 时间复杂度证明

- 单点修改：由于线段树的二分结构，深度为 ${\log_2n}$，每层只访问 $1$ 个节点，所以时间复杂度为 $\mathrm {O(\log_2n)}$。

- 区间查询：称被询问区间完整包含的节点为完整节点，被部分包含的为边缘节点，则每一层最多只访问 $2$ 个边缘节点，位于区间边缘；最多访问 $2$ 个完整节点，因为完整节点的兄弟一定不是完整节点。原因是，若一个节点的两个孩子均为完整节点，则该节点为完整节点，不会访问其孩子。所以一层最多访问 $4$ 节点，时间复杂度 $\mathrm{O(\log_2n)}$

- 找第 $k$ 小：每层只会访问 $1$ 个节点，时间复杂度为 $\mathrm {O(\log_2n)}$。

- 线段树合并：显然，我们每次只会访问重合节点，那么单次合并的时间复杂度就可以认为是较小树的节点个数，那么显然，多次合并的总复杂度为总点数级别，$\mathrm {O(n\log_2n)}$。

  - 注：不能简单的认为其复杂度为单次合并的最坏复杂度乘询问次数。感性理解，在本题中，显然我们可以花费一次询问使树的节点加一条链，让合并的复杂度增大，但也会失去一次进行线段树合并的机会，这样就保证了其总复杂度不会过高。（很玄学，我也不会更严谨的证明，希望有大佬教我）
  
- 线段树分裂：我们可以看到，这个操作访问的节点和区间查询是一致的，复制边缘节点，直接拿走完整节点。时间复杂度 $\mathrm{O(\log_2n)}$

### 完整代码

[**link**](https://www.luogu.com.cn/paste/wu1u7lxp)

---

## 作者：chenxinyang2006 (赞：10)

- 闲话

  线段树又有新板子了，这是好的
  
  ~~但我开始写后，连续爆零了6次，我太菜了~~

  这次要支持的操作分别是：

  1.线段树分裂

  2.线段树合并

  3.单点加

  4.区间求和

   5.全局kth，也就是线段树内二分
 
   2 ~ 5 操作都是比较常见的，主要说一下1操作怎么办

- 线段树分裂

   ![](https://cdn.luogu.com.cn/upload/image_hosting/r4rqjq0p.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

   比如你有这颗线段树（节点上写的是区间和），然后你要把 $[2,4]$ 分裂出来

  那么应该有这几个步骤：

  1.找出要分裂的几个子树的根，也就是 9,5,6 节点

  2.删去原线段树上这几个区间的贡献

  3.把新线段树上层的一些节点建好，（指pushup），然后指向分裂出的子树的根

  分裂完是这样的，红色节点表示新建，红色边表示新连：（编号神隐了）
  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/v4scop7y.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

  感觉超级像主席树
  
  也确实可以学习主席树的做法，用一个数组来存每颗线段树的根

- 合并复杂度分析

  因为线段树合并的复杂度貌似挺玄学的，我来普及一下线段树合并的复杂度分析
 
  仅当两颗线段树在相同的节点都有值时，合并才需要花费时间，否则可以直接返回有值的一边

  也就是说，合并一次，总节点数量减少1

  一操作会在新线段树上，增加 $\log n$ 个节点

  三操作会增加一条链的节点，也是 $\log n$ 个

  所以总节点数不超过 $n + m \log n$，合并总复杂度不超过 $n + m \log n$
  
code：

```cpp
#include <cstdio>
#define ll long long
#define ls tree[rt].l
#define rs tree[rt].r
int n,m;
int c = 1;
int T[200005];

int cnt;
struct node{
	ll val;
	int l,r;
}tree[400005 << 5];

int Q(int &x) {if(x == 0) x = ++cnt;}

void pushup(int rt){
	tree[rt].val = tree[ls].val + tree[rs].val;
}

int build(int l,int r){
	int rt = ++cnt;
	if(l == r){
		scanf("%lld",&tree[rt].val);
		return rt;
	}
	int mid = l + r >> 1;
	ls = build(l,mid);
	rs = build(mid + 1,r);
	pushup(rt);
	return rt;
}

int spilt(int Q,int l,int r,int L,int R){
    int rt = ++cnt;
    if(l == L && r == R){
    	tree[rt] = tree[Q];
    	tree[Q].val = tree[Q].l = tree[Q].r = 0;
    	return rt;
	}
	int mid = l + r >> 1;
	if(R <= mid){
		ls = spilt(tree[Q].l,l,mid,L,R);
	}else if(L > mid){
		rs = spilt(tree[Q].r,mid+1,r,L,R);
	}else{
		ls = spilt(tree[Q].l,l,mid,L,mid);
		rs = spilt(tree[Q].r,mid+1,r,mid+1,R);
	}
	pushup(rt);pushup(Q);
	return rt;
}

int merge(int x,int y){
	if(!x) return y;
	if(!y) return x;
	int rt = ++cnt;
	tree[rt].val = tree[x].val + tree[y].val;
	ls = merge(tree[x].l,tree[y].l);
	rs = merge(tree[x].r,tree[y].r);
	return rt;
}

void upload(int rt,int l,int r,int id,int C){
	tree[rt].val += C;
	if(l == r){
		return;
	}
	int mid = l + r >> 1;
	if(id <= mid){
		Q(ls);
		upload(ls,l,mid,id,C);
	}else{
		Q(rs);
		upload(rs,mid+1,r,id,C);
	}
}

ll query(int rt,int l,int r,int L,int R){
	if(l == L && r == R){
		return tree[rt].val;
	}
	int mid = l + r >> 1;
	if(R <= mid){
		return query(ls,l,mid,L,R);
	}else if(L > mid){
		return query(rs,mid+1,r,L,R);
	}else{
		return query(ls,l,mid,L,mid) + query(rs,mid+1,r,mid+1,R);
	}
}

int kth(int rt,int l,int r,ll k){
	if(l == r){
		return l;
	}
	int mid = l + r >> 1;
	if(tree[ls].val >= k){
		return kth(ls,l,mid,k);
	}else{
		return kth(rs,mid+1,r,k - tree[ls].val);
	}
}

int main(){
	scanf("%d%d",&n,&m);
	T[1] = build(1,n);
	int opt,p,x,y;
	for(int i = 1;i <= m;i++){
		scanf("%d%d",&opt,&p);
		if(opt == 0){
			scanf("%d%d",&x,&y);
			T[++c] = spilt(T[p],1,n,x,y);
		}else if(opt == 1){
			scanf("%d",&x);
			T[p] = merge(T[p],T[x]);
		}else if(opt == 2){
			scanf("%d%d",&x,&y);
			upload(T[p],1,n,y,x);
		}else if(opt == 3){
			scanf("%d%d",&x,&y);
			printf("%lld\n",query(T[p],1,n,x,y));
		}else{
			ll k;
			scanf("%lld",&k);
			if(query(T[p],1,n,1,n) < k) printf("-1\n");
			else printf("%d\n",kth(T[p],1,n,k));
		}
	}
	return 0;
}
```

这个线段树分裂的复杂度是比平衡树优秀的，平衡树貌似又少了个优势

---

## 作者：EnofTaiPeople (赞：9)

### Part 0：前言
01trie 将数字的二进制表示转化为字符插入到字典树，从而可以在树上二分，实现类似平衡树的查询功能，被称为常数、码量优秀，容易调试的平衡树，时空复杂度均为 $O(n\log_2C)$，$C$ 为值域，以下均同。

本不想写题解，但可爱的 ydq [写了](https://mfeitveer.blog.luogu.org/solution-p5494)，于是就介绍一下,事实证明他没用 `fread` 码量还是比我大。

### Part 1：01trie 的合并

合并的本质是对于两颗 $trie$ 求和，过程如下：
1. 若两棵树有一棵为空，返回非空的树；
2. 否则，新建一个节点，大小为两树大小和（大小指叶子数量，下同）；
3. 递归将左右儿子合并，接给新建节点；
4. 返回新建节点。

代码实现（将 $y$ 合并给 $x$）：
```cpp
void Meg(int &x,int y,int w=W){
	if(!x||!y)return void(x|=y);
	sz[x]+=sz[y];
	if(w--){
		Meg(t[x][0],t[y][0],w);
		Meg(t[x][1],t[y][1],w);
	}
}
```
考虑分析时间复杂度，由于每一次同时拥有（即进入了第二步）的节点都会从两个减少到一个，而节点数是 $O(n\log_2C)$ 的，所以总复杂度是 $O(n\log_2C)$ 的。

### Part 2：01trie 的分裂

分裂的本质是像 fhq 一样将一棵 01trie 按值域分为两棵 01trie，过程如下：
1. 走到空子树，直接返回零；
2. 考虑值域上这一位是否为一，将左子树全部分给左边或将右子树分给右边；
3. 未被直接分配的一棵子树继续递归。

代码实现：
```cpp
void Spt(int &x,int &y,int nod,int w=W){
	if(!nod)return void(x=y=0);
	if(w--){
		if((val>>w)&1){
			x=nod,y=++cnt,Spt(t[x][1],t[y][1],t[x][1],w);
		}else{
			y=nod,x=++cnt,Spt(t[x][0],t[y][0],t[y][0],w);
		}
		sz[x]=sz[t[x][0]]+sz[t[x][1]];
		sz[y]=sz[t[y][0]]+sz[t[y][1]];
	}else x=nod,y=0;
}
```
由于每次分裂只会增加 $O(\log_2C)$ 个节点，所以是 总复杂度 $O(n\log_2C)$ 的。

而本题值域为 $n$，操作数为 $m$，所以总复杂度为 $O((n+m)\log_2n)$。

附上 AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5,T=7e6+7,W=20;
char buf[N+5],*p1,*p2,c;
typedef long long ll;
#define int ll
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2)?EOF:*p1++)
inline ll read(){
    ll x,f=1;for(c=gc;c<48;c=gc)if(c=='-')f=-f;
    for(x=0;c>47;x=x*10+(48^c),c=gc);return x*f;
}
namespace trie_01{
	int t[T][2],cnt,val,dc;
	ll sz[T];
	void Ins(int &x,int w=W){
		if(!x)x=++cnt;sz[x]+=dc;
		if(w--)Ins(t[x][(val>>w)&1],w);
	}
	void Meg(int &x,int y,int w=W){
		if(!x||!y)return void(x|=y);
		sz[x]+=sz[y];
		if(w--){
			Meg(t[x][0],t[y][0],w);
			Meg(t[x][1],t[y][1],w);
		}
	}
	void Spt(int &x,int &y,int nod,int w=W){
		if(!nod)return void(x=y=0);
		if(w--){
			if((val>>w)&1){
				x=nod,y=++cnt,Spt(t[x][1],t[y][1],t[x][1],w);
			}else{
				y=nod,x=++cnt,Spt(t[x][0],t[y][0],t[y][0],w);
			}
			sz[x]=sz[t[x][0]]+sz[t[x][1]];
			sz[y]=sz[t[y][0]]+sz[t[y][1]];
		}else x=nod,y=0;
	}
	struct Trie{
		int rt;
		inline void insert(int x,int ct){
			val=x,dc=ct,Ins(rt);
		}
		inline void join(Trie &y){Meg(rt,y.rt);}
		inline int split(int l,int r){
			int L,R;val=l-1,Spt(L,rt,rt),val=r;
			Spt(rt,R,rt),Meg(L,R);swap(rt,L);return L;
		}
		inline ll rank(int d){
			int res=0,w=W,x=rt;
			while(w--)
				if((d>>w)&1)res+=sz[t[x][0]],x=t[x][1];
				else x=t[x][0];
			return res;
		}
		inline int gval(ll rk){
			if(rk<1||rk>sz[rt])return -1;
			int res=0,w=W,k,x=rt;
			while(w--){
				k=sz[t[x][0]];
				if(rk<=k)x=t[x][0];
				else rk-=k,x=t[x][1],res|=1<<w;
			}return res;
		}
	}tr[N];
} // namespace trie_01
using trie_01::tr;
ll n,q,cnt=1;
signed main(){
	ll op,x,l,r,k;
	n=read(),q=read();
	for(x=1;x<=n;++x)tr[1].insert(x,read());
	while(q--){
		op=read();
		switch(op){
			case 0:x=read(),l=read(),r=read(),tr[++cnt].rt=tr[x].split(l,r);break;
			case 1:x=read(),k=read(),tr[x].join(tr[k]);break;
			case 2:x=read(),k=read(),l=read(),tr[x].insert(l,k);
			break;
			case 3:x=read(),l=read(),r=read();
			printf("%lld\n",tr[x].rank(r+1)-tr[x].rank(l));break;
			case 4:x=read(),k=read();printf("%d\n",tr[x].gval(k));
			default:break;
		}
	}
	return 0;
}
```

---

## 作者：JK_LOVER (赞：8)

## 说在前面的：
本文主要说明权值线段树的合并 $(merge)$ 和分裂 $(split)$ 。主要是起抛砖引玉的作用。本文参考的代码较多，若代码雷同请勿在意。若格式炸了，请见[博客](https://www.luogu.com.cn/blog/xzc/quan-zhi-xian-duan-shu)
。
## 线段树基本问题
作为我们较先接触的数据结构，大体的用途例如：区间修改，单点修改，区间查询。想必大家也应该会了，这里不做多的介绍。
## 空间问题
一般线段树开 $4\times n$ 的空间其原因在于：线段树是一颗完全二叉树。以下是拙劣的证明：
由于线段树深度为 $\ulcorner \log_{2} n\urcorner$ 所以一共就有 $2^{\ulcorner \log_2 n \urcorner+1}-1$ 个节点， $\frac{2^{\ulcorner \log_2 n \urcorner+1}-1}{n}$ 的最大值在 $n=2^k-1$ 是取到，所以 
$$
\frac{2^{\ulcorner \log_2 n \urcorner+1}-1}{n}=\frac{2^{\log k+2}-1}{2^k-1} = \frac{2^k \times 4-1}{2^k-1} = 4+ \frac{3}{2^k-1}
$$
所以一般线段树开四倍空间是为了安全。而熟练以后就可以尝试使用动态开点线段树。
## 时间问题
一般线段树的时间复杂度是由树高确定的，所以这也解释了线段树 $O(\log n)$ 的单次查询或修改。
# 权值线段树
权值线段树，你可以理性理解为一个由线段树实现的 $\text{桶}$ 。每一个节点保存的是值大小在管辖区间中的个数，那么叶节点的编号也就是这个值的个数。
## 查询第 K 小值
有了权值线段树我们就可以利用它做一些操作 。查询第 K 小的值，写法与平衡树差不多，都是与左子树比较大小来决定向左还是向右。
```cpp
int kth(int x,int l,int r,int k)
{
	if(l==r) {return l;}
	int mid=l+r>>1;
	if(sum[lc[x]]>=k) return kth(lc[x],l,mid,k);
	return kth(rc[x],mid+1,r,k-sum[lc[x]]);
} 
```
## 删除\插入一个数
删除和插入就例如普通线段树的单点修改(其实质也的确是这样的) 。删除就是将管辖这个值的所有节点的大小都减一。插入同理。
```cpp
int insert(int x,int l,int r,int p,int v)
{
	if(!x) x = ++cnt;
	if(l == r){
		sum[x]+=v;
		return x;
	}
	int mid=l+r>>1;
	if(p<=mid) lc[x] = insert(lc[x],l,mid,p,v);
	else rc[x] = insert(rc[x],mid+1,r,p,v); 
	pushup(x);
	return x;
}
```
## 可持久化
说完了权值线段树，就引入新的操作：可持久化 。可持久化最经典的操作就是查询区间第 K 小。有了可持久化线段树也可以变形为可持久化数组，可持久化并查集。

## 查询区间第 K 小
区间第 K 小，你可以看做为 $sum_R-sum_{L-1}$ 中的第 K 小。其实可持久化线段树解决的问题，一般也形容前缀和的形式的问题或者一些需要查询历史状态的题。可持久线段树的查询与权值线段树十分相像。

```cpp
int query(int p,int q,int l,int r,int x) {
    if(l==r) return l;
    int k=sum[lc[p]]-sum[lc[q]];
    if(x<=k) return query(lc[p],lc[q],l,mid,x);
    else return query(rc[p],rc[q],mid+1,r,x-k);
}
```

## 合并(merge)
有时候我们往往需要将多颗权值线段树合并，所以也就有了这个操作。合并，你可以看作将一颗线段树复制到另一颗上。

- 如果双方都有这个节点那么直接相加。
- 如果只有一方有这个节点那么可以直接返回，因为子节点肯定也没了。(这也是合并操作的复杂度为 $O(n\log n)$ )的原因。
```cpp
int merge(int a,int b,int l,int r)
{
	if(!a||!b) return a|b;
	if(l==r) 
	{
		sum[a]+=sum[b];
		return a;
	}
	int mid=l+r>>1;
	lc[a] = merge(lc[a],lc[b],l,mid);
	rc[a] = merge(rc[a],rc[b],mid+1,r);
	pushup(a);
	return a;
}
```
可以发现在合并时，线段树是两边都要递归的。如果没有
~~~
if(!a||!b) return a|b;
~~~
那么线段树合并是一个 $O(n \log n)$ 的函数，细思极恐。我们考虑分析权值线段树合并的时间复杂度
### 时间复杂度

如果一开始我们要插入 $k$ 个值，那么这个空的权值线段树就会增加 $k \log k$ 个节点，每次增加一个节点的复杂度是 $O(1)$ 的，那么 $n$ 颗值域无重合的权值线段树就可以在合并时，做到 $O(n\log n)$ 。但那如果是 $n$ 颗全满的权值线段树合并......$O(n^2\log n)$ 。可以看出权值线段树合并的时间复杂度与插入节点有关。但目前来看在 $10^5$ 的随机数据下，跑得还算快。

## 分裂(split)

有时候我们需要将一颗权值线段树分成多颗。说个实话这样的题还是有点少，重点应该是上文的合并(merge)。这里的分裂基本是按 @ix35
大佬的代码实现的，由衷的感谢他。

- 分裂与查询第 K 小类似，如果是按个数分。
- 我们可以按照 FHQ treap 的 split 来理解，如果右子树应该全为 $Y$ 的，就把右子树全给 $Y$，然后直接向左递归。如果右子树有只有一部分应该为 $Y$ 的，那么就应该向右递归。如果在此刚好平分，那就你一半，我一半，然后退出。
- 分完后的大小 $X$ 就是原大小减去分出去的 ，$Y$ 的大小就是分出去的大小。

```cpp
int split(int x,int y,int k)
{
	y = ++cnt;
	int v = sum[lc[x]];
	if(k > v){
		rc[y] = split(rc[x],rc[y],k-v);//要不起，只能向右。 
	}
	else if(k == v){swap(rc[x],rc[y]);}//你一半，我一半 。 
	else 
	{
		swap(rc[x],rc[y]);//先把右子树给你 。 
		lc[y] = split(lc[x],lc[y],k);//再向左 。 
	}
	sum[y] = sum[x] - k;
	sum[x] = k;
	return y;
}
```
### 总结
权值线段树是一种非常小巧的数据结构，我认为是非常有必要学习的。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 200100;
const int size = 100000;
#define int long long
struct node{
	int lc[N*40],rc[N*40],sum[N*40],cnt;
	node(){cnt=0;}
	void pushup(int x)
	{
		sum[x] = sum[lc[x]]+sum[rc[x]];
	}
	int merge(int a,int b,int l,int r)
	{
		if(!a||!b) return a|b;
		if(l==r) 
		{
			sum[a]+=sum[b];
			return a;
		}
		int mid=l+r>>1;
		lc[a] = merge(lc[a],lc[b],l,mid);
		rc[a] = merge(rc[a],rc[b],mid+1,r);
		pushup(a);
		return a;
	}
	int split(int x,int y,int k)
	{
		y = ++cnt;
		int v = sum[lc[x]];
		if(k > v){
			rc[y] = split(rc[x],rc[y],k-v);//要不起，只能向右。 
		}
		else if(k == v){swap(rc[x],rc[y]);}//你一半，我一半 。 
		else 
		{
			swap(rc[x],rc[y]);//先把右子树给你 。 
			lc[y] = split(lc[x],lc[y],k);//再向左 。 
		}
		sum[y] = sum[x] - k;
		sum[x] = k;
		return y;
	}
	int insert(int x,int l,int r,int p,int v)
	{
		if(!x) x = ++cnt;
		if(l == r){
			sum[x]+=v;
			return x;
		}
		int mid=l+r>>1;
		if(p<=mid) lc[x] = insert(lc[x],l,mid,p,v);
		else rc[x] = insert(rc[x],mid+1,r,p,v); 
		pushup(x);
		return x;
	}
	int kth(int x,int l,int r,int k)
	{
		if(l==r) {return l;}
		int mid=l+r>>1;
		if(sum[lc[x]]>=k) return kth(lc[x],l,mid,k);
		return kth(rc[x],mid+1,r,k-sum[lc[x]]);
	} 
	int query(int x,int l,int r,int L,int R)
	{
		if(r<L||l>R) return 0;
		if(L<=l&&r<=R) return sum[x];
		int mid = l+r>>1;
		return query(lc[x],l,mid,L,R)+query(rc[x],mid+1,r,L,R);
	}
}T;
int read(){
	int x=0,f=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return f?-x:x;
}
int rt[N],n,m,cnt=1;
signed main () {
	n=read();m=read();
	for(int i = 1;i <= n;i++)
	{
		int a=read();
		rt[1] = T.insert(rt[1],1,n,i,a);
	}
	for(int i = 1;i <= m;i++)
	{
		int opt=read();
		if(opt==0){
			int x=read(),y=read(),z=read();
			int k1=T.query(rt[x],1,n,1,z),k2=T.query(rt[x],1,n,y,z);
			int tmp=0;
			rt[++cnt]=T.split(rt[x],rt[cnt],k1-k2);
			tmp = T.split(rt[cnt],tmp,k2);
			rt[x]=T.merge(rt[x],tmp,1,n);
		}
		if(opt==1)
		{
			int x=read(),y=read();
			rt[x]=T.merge(rt[x],rt[y],1,n);
		}
		if(opt==2)
		{
			int x=read(),y=read(),z=read();
			T.insert(rt[x],1,n,z,y);
		}
		if(opt==3)
		{
			int x=read(),y=read(),z=read();
			int ans=T.query(rt[x],1,n,y,z);
			printf("%lld\n",ans);
		}
		if(opt==4)
		{
			int x=read(),y=read();
			if(T.sum[rt[x]]<y) puts("-1");
			else printf("%lld\n",T.kth(rt[x],1,n,y));
		}
	}
	return 0;
}
	
```
### 例题(大多数是关于merge的)
[P4556 [Vani有约会]雨天的尾巴 /【模板】线段树合并](https://www.luogu.com.cn/problem/P4556)

[P3224 [HNOI2012]永无乡](https://www.luogu.com.cn/problem/P3224)

[P3834 【模板】可持久化线段树 1（主席树）](https://www.luogu.com.cn/problem/P3834)

---

## 作者：王大神——A001 (赞：6)

## 线段树分裂
- 数据结构
- 平衡树
- 线段树

[传送门](https://www.luogu.com.cn/problem/P5494)

### 整体思路
- 实现动态开点
- 建树（根节点为 1）
- 实现操作一：分裂（开点）
- 实现操作二：合并（合并，删点）
- 实现废点回收（再利用）
- 实现操作三：插入（叶子结点加权）
- 实现操作四：查找区间数的个数（线段树区间和）
- 实现操作五：根据排名找原数（Splay）

#### 各变量意义
```cpp
const int o_o=6e5+10;//数组大小 
int n,m;//序列长度，操作次数 
struct po{
	int l,r;//线段树节点左右边界 
	long long s_m;//区间和 
}t_r[o_o<<2];
int x_p=0;//所有节点个个数（包括垃圾桶中的点） 
int s_m=0;//垃圾桶中可用的点 
int r_s[o_o<<2];//节点垃圾桶 
int r_t[o_o];//记录每个序列的线段树根节点 
int x_t=1;//新可重集序号 
int a_a[o_o];//原序列 
```

#### 实现动态开点&废点回收（再利用）
动态开点用来即时给新节点赋予编号。由于本题空间范围较紧迫，要进行废点的回收利用。

我们要再开一个数组专门用废弃的点，要新时的时，先不开新点，先废物利用。（新开一个记录废点的数组要比直接开两个存点数组优的多）。

```cpp
void d_l(int &k){//删除节点 
	t_r[k].l=t_r[k].r=t_r[k].s_m=0;//清空数据 
	r_s[++s_m]=k;//放入垃圾桶 
	k=0;//节点编号清空 
}
int n_w(){//赋新节点编号 
	if(s_m)return r_s[s_m--];//垃圾桶中有可用的，先回收利用 
	return ++x_p;//造新点 
}
```

#### 建树
线段树基础操作。（需要复习的可以看[这里](https://wdsa001.github.io/2021/09/16/xian-duan-shu/)）。

```cpp
void u_p(int k){//更新节点信息 
	t_r[k].s_m=t_r[t_r[k].l].s_m+t_r[t_r[k].r].s_m;
}
void b_t(int &k,int l=1,int r=n){
	if(!k)k=n_w();//不存在节点，赋予编号 
	if(l==r){
		t_r[k].s_m=a_a[l];//叶节点赋值 
		return;
	}
	int m_i=(l+r)>>1; 
	b_t(t_r[k].l,l,m_i);//左子树 
	b_t(t_r[k].r,m_i+1,r);//右子树 
	u_p(k);//更新节点信息 
}
```

#### 实现操作一：分裂
分裂的主要思路在于动态开点和值的转移（将原值附在新树上同时**清空**原点（不是删除））。

**注意更新被分裂的线段树节点的值！**

```cpp
void n_t(int &t_1,int &t_2,int x,int y,int l=1,int r=n){//建新树，分裂 
	if(r<x||y<l)return;//不在范围内，返回 
	if(!t_1)return;//树不存在，返回 
	if(x<=l&&r<=y){//在范围内 
		t_2=t_1;//节点赋值 
		t_1=0;//原节点清空 
		return;
	}
	if(!t_2)t_2=n_w();//节点不存在，建新点 
	int m_i=(l+r)>>1;
	n_t(t_r[t_1].l,t_r[t_2].l,x,y,l,m_i);//左子树分裂 
	n_t(t_r[t_1].r,t_r[t_2].r,x,y,m_i+1,r);//右子树分裂 
	u_p(t_1);//更新节点 
	u_p(t_2);//更新节点 
}
```

#### 实现操作二：合并
合并的思路与分裂的思路很像但区别在于，节点要删除。原因在于题干：（数据保证在此后的操作中不会出现可重集 $t$）。

所以，这些空出来的节点就可以直接回收了。**不仅要删叶节点，要删所有的节点**。

```cpp
void b_g(int &t_1,int &t_2,int l=1,int r=n){//线段树合并 
	if(!t_1||!t_2){//有一棵不存在 
		t_1+=t_2;//直接赋值 
		return;
	}
	if(l==r){//是叶节点，合并 
		t_r[t_1].s_m+=t_r[t_2].s_m;
		d_l(t_2);//删掉被合并的节点（叶子结点） 
		return;
	}
	int m_i=(l+r)>>1;
	b_g(t_r[t_1].l,t_r[t_2].l,l,m_i);//左子树合并 
	b_g(t_r[t_1].r,t_r[t_2].r,m_i+1,r);//右子树合并 
	d_l(t_2);//删掉被合并的节点（区间节点） 
	u_p(t_1);//更新节点信息 
}
```

#### 实现操作三：插入
找到子叶编号为 $q$ 的叶子，将他的权值（或者说个数）加上 $x$ 即可。

```cpp
void a_d(int n_m,int v,int &k,int l=1,int r=n){
	if(n_m<l||n_m>r)return;//不在范围内返回 
	if(!k)k=n_w();//节点不存在，新建节点 
	if(l==r){//找到叶子结点 
		t_r[k].s_m+=v;//加权（增加数量） 
		return;
	}
	int m_i=(l+r)>>1;
	a_d(n_m,v,t_r[k].l,l,m_i);//左子树维护 
	a_d(n_m,v,t_r[k].r,m_i+1,r);//右子树维护 
	u_p(k);//更新节点信息 
}
```

#### 实现操作四：查找区间数的个数
线段树区间和操作。

```cpp
long long s_a(int x,int y,int k,int l=1,int r=n){
	if(y<l||r<x)return 0;//区间外，返回 
	if(!k)return 0;//节点不存在，返回 
	if(x<=l&&r<=y)return t_r[k].s_m;//被范围包含，返回个数 
	int m_i=(l+r)>>1;
	return s_a(x,y,t_r[k].l,l,m_i)+s_a(x,y,t_r[k].r,m_i+1,r);//返回左右子树符合要求的和（此节点的子树总贡献） 
}
```

#### 实现操作五：根据排名找原数
本操作用到了平衡树的思想，如果左区间的大小比 $k$ 大，那么排名为 $k$ 的值一定在其中，否则减去左子树的大小（左边的数排名一定比它小），跳到右子树继续找。

```cpp
int f_k(long long p_k,int k,int l=1,int r=n){
	if(p_k<=0)return -1;//未找到，直接返回 
	if(l==r)return l;//找到节点，返回值 
	int m_i=(l+r)>>1;
	if(t_r[t_r[k].l].s_m>=p_k)return f_k(p_k,t_r[k].l,l,m_i);//左子树的数量超过 k 的排名数，一定在左子树 
	return f_k(p_k-t_r[t_r[k].l].s_m,t_r[k].r,m_i+1,r);//减去左子树的数的数量，在右子树继续找 
}
```


### 代码
```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cstdlib>
#include<queue>
#include<vector>
using namespace std;
long long r_r(){//快读 
	long long k=0,f=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(isdigit(c)){
		k=(k<<1)+(k<<3)+(c^48);
		c=getchar();
	}
	return k*f;
}
const int o_o=6e5+10;//数组大小 
int n,m;//序列长度，操作次数 
struct po{
	int l,r;//线段树节点左右边界 
	long long s_m;//区间和 
}t_r[o_o<<2];
int x_p=0;//所有节点个个数（包括垃圾桶中的点） 
int s_m=0;//垃圾桶中可用的点 
int r_s[o_o<<2];//节点垃圾桶 
int r_t[o_o];//记录每个序列的线段树根节点 
int x_t=1;//新可重集序号 
int a_a[o_o];//原序列 
void d_l(int &k){//删除节点 
	t_r[k].l=t_r[k].r=t_r[k].s_m=0;//清空数据 
	r_s[++s_m]=k;//放入垃圾桶 
	k=0;//节点编号清空 
}
int n_w(){//赋新节点编号 
	if(s_m)return r_s[s_m--];//垃圾桶中有可用的，先回收利用 
	return ++x_p;//造新点 
}
void u_p(int k){//更新节点信息 
	t_r[k].s_m=t_r[t_r[k].l].s_m+t_r[t_r[k].r].s_m;
}
void b_t(int &k,int l=1,int r=n){
	if(!k)k=n_w();//不存在节点，赋予编号 
	if(l==r){
		t_r[k].s_m=a_a[l];//叶节点赋值 
		return;
	}
	int m_i=(l+r)>>1; 
	b_t(t_r[k].l,l,m_i);//左子树 
	b_t(t_r[k].r,m_i+1,r);//右子树 
	u_p(k);//更新节点信息 
}
void b_g(int &t_1,int &t_2,int l=1,int r=n){//线段树合并 
	if(!t_1||!t_2){//有一棵不存在 
		t_1+=t_2;//直接赋值 
		return;
	}
	if(l==r){//是叶节点，合并 
		t_r[t_1].s_m+=t_r[t_2].s_m;
		d_l(t_2);//删掉被合并的节点（叶子结点） 
		return;
	}
	int m_i=(l+r)>>1;
	b_g(t_r[t_1].l,t_r[t_2].l,l,m_i);//左子树合并 
	b_g(t_r[t_1].r,t_r[t_2].r,m_i+1,r);//右子树合并 
	d_l(t_2);//删掉被合并的节点（区间节点） 
	u_p(t_1);//更新节点信息 
}
void n_t(int &t_1,int &t_2,int x,int y,int l=1,int r=n){//建新树，分裂 
	if(r<x||y<l)return;//不在范围内，返回 
	if(!t_1)return;//树不存在，返回 
	if(x<=l&&r<=y){//在范围内 
		t_2=t_1;//节点赋值 
		t_1=0;//原节点清空 
		return;
	}
	if(!t_2)t_2=n_w();//节点不存在，建新点 
	int m_i=(l+r)>>1;
	n_t(t_r[t_1].l,t_r[t_2].l,x,y,l,m_i);//左子树分裂 
	n_t(t_r[t_1].r,t_r[t_2].r,x,y,m_i+1,r);//右子树分裂 
	u_p(t_1);//更新节点 
	u_p(t_2);//更新节点 
}
void a_d(int n_m,int v,int &k,int l=1,int r=n){
	if(n_m<l||n_m>r)return;//不在范围内返回 
	if(!k)k=n_w();//节点不存在，新建节点 
	if(l==r){//找到叶子结点 
		t_r[k].s_m+=v;//加权（增加数量） 
		return;
	}
	int m_i=(l+r)>>1;
	a_d(n_m,v,t_r[k].l,l,m_i);//左子树维护 
	a_d(n_m,v,t_r[k].r,m_i+1,r);//右子树维护 
	u_p(k);//更新节点信息 
}
long long s_a(int x,int y,int k,int l=1,int r=n){
	if(y<l||r<x)return 0;//区间外，返回 
	if(!k)return 0;//节点不存在，返回 
	if(x<=l&&r<=y)return t_r[k].s_m;//被范围包含，返回个数 
	int m_i=(l+r)>>1;
	return s_a(x,y,t_r[k].l,l,m_i)+s_a(x,y,t_r[k].r,m_i+1,r);//返回左右子树符合要求的和（此节点的子树总贡献） 
}
int f_k(long long p_k,int k,int l=1,int r=n){
	if(p_k<=0)return -1;//未找到，直接返回 
	if(l==r)return l;//找到节点，返回值 
	int m_i=(l+r)>>1;
	if(t_r[t_r[k].l].s_m>=p_k)return f_k(p_k,t_r[k].l,l,m_i);//左子树的数量超过 k 的排名数，一定在左子树 
	return f_k(p_k-t_r[t_r[k].l].s_m,t_r[k].r,m_i+1,r);//减去左子树的数的数量，在右子树继续找 
}
int main(){
	n=r_r(),m=r_r();
	for(int i=1;i<=n;i++)a_a[i]=r_r();//读入序列 
	b_t(r_t[1]);//以 1 为根节点建树 
	for(int i=1;i<=m;i++){
		int op=r_r();
		if(op==0){
			int p=r_r(),x=r_r(),y=r_r();
			n_t(r_t[p],r_t[++x_t],x,y);//建新树 
		}else if(op==1){
			int p=r_r(),t=r_r();
			b_g(r_t[p],r_t[t]);//合并可重集 
		}else if(op==2){
			int p=r_r(),x=r_r(),q=r_r();
			a_d(q,x,r_t[p]);//加数字 
		}else if(op==3){
			int p=r_r(),x=r_r(),y=r_r();
			printf("%lld\n",s_a(x,y,r_t[p]));//查询范围内数的个数 
		}else {
			int a_s=0;
			int p=r_r(),k=r_r();
			if(s_a(1,n,r_t[p])<k)a_s=-1;//总数不够 k 个，不存在第 k 小 
			else a_s=f_k(k,r_t[p]);//查找第 k 小 
			printf("%d\n",a_s);
		}
	}
	return 0;
}
```


---

## 作者：dying (赞：5)

# 【题解】线段树分裂
[博客传送门](https://dying.blog.luogu.org/post-ti-xie-xian-duan-shu-fen-lie)

~~这里竟然没有指针题解，赶快水一发~~

**有合并复杂度证明！！！**

先吐槽一句：其他图片感觉用处不大，蒟蒻学习的时候看图永远看不懂，代码一看就懂
## 前置芝士：**动态开点线段树**

首先介绍一下我用指针时为了防止RE的小技巧
```cpp
struct node{
    int val;
    node*son[2];
};
node*null=new node();

*null=(node){0,{null,null}};

node*New(){node*p=new node;*p={0,null,null};return p;}
```
这样就避免了RE，写代码将会方便很多，比如```push_up()```就可以直接```p->val=p->son[0]->val+p->son[1]->val;```~~（但这样会让你内存访问不那么连续，一道题可能会慢个一两毫秒）~~

**一定要记住手动定义的 $null$ 不能在 ```new``` 的括号里赋值，那时的 $null$ 是空指针，后果就是 $null$ 的左右儿子就将被赋值为空指针！这道题影响不大，只要查询时时刻判了指针是否为 $null$ 就没问题，但平衡树之类的就特别容易RE**

本人喜欢```struct```，所以除了上面放的那段代码和主函数，其他都封起来了
```cpp
struct split_segment_tree{
    int n;//这个树的值域范围
    node*root;
    node*New(){node*p=new node;*p={0,null,null};return p;}
    split_segment_tree(){root=New();}//构造函数，每新建一个这个结构体就会先执行这个函数
    void de(node*&p){//递归删除
    	if(p==null)return;//null不能删除（毕竟是保命神器）
    	de(p->son[1]),de(p->son[0]);
    	delete p;
    }
    ~split_segment_tree(){de(root);}//析构函数，在delete时会调用这个函数
    inline void build(int length){n=length;}//别慌，这个不是真正的build，为减少码量，我没写build
    inline void push_up(node*p){
        p->val=p->son[0]->val+p->son[1]->val;
    }
    inline int size(){return root->val;}
};
```
为了节省空间，我定义的指针```split_segment_tree*T[200010];```
## 分裂操作
骨架和线段树区间操作没什么区别

废话不多说，上代码
```cpp
	void spt(int l,int r,int left,int right,node*&p,node*&q){//q要引用传参，p不需要，但我喜欢hhh
		if(p==null)return; //原树什么都没有，直接返回
		if(l<=left&&right<=r){q=p,p=null;return;}//如果全部包含，直接换节点（这是分裂，不是复制，分裂原树节点就会消失，不会冲突）
		//这后面就和区间加法一样了
		if(q==null)q=New();//其实q肯定是空的，不需要判断
		int mid=left+right>>1;
		if(l<=mid)spt(l,r,left,mid,p->son[0],q->son[0]);
		if(r>mid)spt(l,r,mid+1,right,p->son[1],q->son[1]);
		push_up(q),push_up(p);//不要忘了两棵树都要push_up！！！
	}
	inline void split(split_segment_tree*&T2,int l,int r,int lenth){
		T2=new split_segment_tree;//构建一颗新树（上边写了构造函数，会新建一个根节点）
		T2->build(lenth);//确定范围
		spt(l,r,1,n,root,T2->root);//分裂操作
	}
    
```
看他和区间加法长得多像，时间复杂度是$O(\log_2n)$就不再赘述了
## 合并操作
~~我更愿意把它叫做吞并，毕竟有一方会直接死掉~~

代码更简单

code：
```cpp
	void mge(node*&p,node*&q){//不用引用，但我喜欢
		if(q==null)return;//被吞的一方什么都没有，一点都不好吃
		if(p==null){p=q,q=null;return;}//自己没有，直接连根抢完
		mge(p->son[0],q->son[0]),mge(p->son[1],q->son[1]);
		p->val+=q->val;//自己儿子抢的记个数
	}
	void merge(split_segment_tree*T2){
		mge(root,T2->root);
		delete T2;//写了析构函数，会释放所有内存
	}
```
重点！聪明的你，一定看出来问题来了，线段树节点最多有 $2n$ 个，那这段代码最坏情况就是 $O(n)$ 的，或许还带大常数，那岂不是直接T飞？

然鹅合并并不会影响总复杂度，证明：

>**证明成立条件：合并每个叶子结点最多带来的合并负担是 $O(\log_2n)$**

>初始状态有只有一棵树可能是满的，其他全是空树，所以刚开始不存在一大堆满树合并，之后呢？

>注意这道题的其他操作：

>- **单点**插入

>>一次插入时间复杂度$O(\log_2n)$,最多只会新建1个叶子节点，给一次合并带来的负担最多只有$O(\log_2n)$，而且要达到$O(\log_2n)$还需要满足另一棵树的对应的叶子节点在，如果有一方是空的，就直接```return```掉了。所以对于两颗空树需要插入两次，因为开始只有一棵树是满的，它和其他树进行合并如果每个节点如果会带来负担，也需要一次插入操作。所以如果这次操作复杂度为$O(x\log_2n)$的话，至少进行了 $x$ 次插入操作（如果没有其他操作的话），其复杂度可以均摊在每一个插入操作上，不至于影响总复杂度。

>- 分裂

>>至于分裂，复杂度$O(\log_2n)$，重点在于，分裂后原树被分裂的叶子节点就不在了，所以再合并时被分裂掉的叶子将不会占用时间，所以分裂不会对一次合并产生影响！！！合并被分裂的叶子节点会花费时间当且仅当在此位置再进行插入时，复杂度同样可以均摊在插入上。

>- 查询

>>这个就不用我说了吧，连个懒标记都没有，不会新建节点，整棵树都不会改变，肯定没有影响。

>综上，```merge```操作不会影响总时间复杂度，证毕。

## kth
这个在其他题中出现较多，特别是树套树的题目。
```cpp
	int gal(int k,int l,int r,node*p){
		if(l==r)return l;//递归到叶子结点，直接返回值
		int mid=l+r>>1;
		if(p->son[0]->val>=k)return gal(k,l,mid,p->son[0]);//如果左子树比k大，那第k大的数一定在左子树（这是权值线段树！！！）
		else return gal(k-p->son[0]->val,mid+1,r,p->son[1]);//搜索右子树（记得减k！！！）
	}
	inline int get_val(int k){return k>size()?-1:gal(k,1,n,root);}
	//如果比size都大，直接返回-1
```
## 插入和查询
这个就和普通权值线段树一模一样了，不再赘述

查询的代码放一下，里面有个要提示的东西
```cpp
	int sch(int l,int r,int left,int right,node*p){
		if((l<=left&&right<=r)||p==null)return p->val;//如果这里没判断null，而且之前null的子节点还是空的（0x0）的话，RE是跑不了的。
		int mid=left+right>>1,ans=0;
		if(l<=mid)ans=sch(l,r,left,mid,p->son[0]);
		if(r>mid)ans+=sch(l,r,mid+1,right,p->son[1]);
		return ans;
	}
	inline int search(int l,int r){return sch(l,r,1,n,root);}
```
## 简洁的main
```cpp
signed main(){
	*null=(node){0,{null,null}};
	T[1]=new split_segment_tree;
	T[1]->build(n);
	for(int i=1;i<=n;i++){
		int a=read();
		if(a)T[1]->insert(i,a);//没有就不用加了，其实这不一定比build要慢
	}
	while(m--){
		int op=read(),p=read();
		switch(op){
			case 0:{
				int l=read(),r=read();
				T[p]->split(T[++idx],l,r,n);
				break;
			}
			case 1:{
				int t=read();
				T[p]->merge(T[t]);
				break;
			}
			case 2:{
				int x=read(),q=read();
				T[p]->insert(q,x);
				break;
			}
			case 3:{
				int x=read(),y=read();
				print(T[p]->search(x,y)),putchar('\n');
				break;
			}
			case 4:{
				int k=read();
				print(T[p]->get_val(k)),putchar('\n');
				break;
			}
		}
	}
	return~EOF;
}
```
$\color{Red}{\text{完结撒花}}$！！！

---

## 作者：WaterSun (赞：2)

UPD 2024-3-11：修改了错误的代码。

# 思路

## Part 1 线段树合并

我们将两棵线段树上相同的信息整合到一棵线段树上的过程被称为线段树合并。

以最简单的相加为例，在权值线段树上，每一个节点维护了一个区间的数的数量，对于两棵同构的线段树，显然最终合并出的线段树的相对应的节点权值为两数的权值之和。

特别的，因为我们采用动态开点的方式建树，因此有可能某一个节点只存在于一棵树，我们让最终的线段树的对应节点直接用这一个节点的值即可。

我们发现如果我们要将 $x,y$ 这两棵线段树合并，发现当一个节点合并之后直接删除更加简洁，直接将 $y$ 的值转移到 $x$ 上即可。

```cpp
inline int merge(int x,int y,int l,int r){
    if (!x || !y) return x + y;
    if (l == r){
        tr[x].sum += tr[y].sum; delnode(y);
        return x;
    }
    int mid = l + r >> 1;
    ls(x) = merge(ls(x),ls(y),l,mid); rs(x) = merge(rs(x),rs(y),mid + 1,r);
    delnode(y); pushup(x);
    return x;
}
```

## Part 2 线段树分裂

将一个可重集前 $k$ 小的数与其它数分为两个集合，那么这就对应了将一棵权值线段树分裂为两棵权值线段树的过程，我们称为线段树分裂。

我们模仿 FHQ-Treap 的分裂过程，现在我们要把 $x$ 这棵线段树按照前 $k$ 小分裂为 $x,y$ 两棵线段树。

设左子树的权值和为 $v$，简单分讨一下：

1. 如果 $v < k$，则左子树依旧归 $x$，递归处理右子树。

2. 如果 $v = k$，则左子树归 $x$，右子树归 $y$。

3. 如果 $v > k$，则右子树归 $y$，递归处理左子树。

然后 $x$ 的权值显然为 $k$，$y$ 的权值显然为 $x$ 原来的权值减去 $k$。

```cpp
inline void split(int x,int &y,int k){
	if (!x) return;
	y = newnode();
	int v = tr[ls(x)].sum;
	if (k > v) split(rs(x),rs(y),k - v);
	else swap(rs(x),rs(y));//注意到当 v >= k 时 y 都需要更新，所以直接归为这一行了
	if (k < v) split(ls(x),ls(y),k);
	tr[y].sum = tr[x].sum - k; tr[x].sum = k;
}
```

这样分裂，每一次都是递归一次，复杂度显然是 $\Theta(\log n)$ 级别的。

## Part 3 本题

### 操作 0

令 $k_1$ 表示 $p$ 中 $1 \sim y$ 的权值和，$k_2$ 表示 $x \sim y$ 的权值和。

我们可以先将 $p$ 按照 $k_1 - k_2$ 分裂为 $p$ 和 $s$ 两个集合，然后再将 $s$ 按照 $k_2$ 分裂为 $s$ 和 $t$ 两个集合，最后将 $p,t$ 合并即可。

$s$ 即为我们的目标集合。

### 操作 1

直接将 $p,t$ 合并即可。

### 操作 2

直接在 $p$ 中 $q$ 的位置的权值加 $x$ 即可。

### 操作 3 & 4

直接查询即可。

## Part 4 时间复杂度分析

对于普通的插入、查询、分裂显然都是 $\Theta(\log n)$，只要问题在于合并。

发现，如果卡满就是将所有点都合并起来，这最多是只有 $\Theta(n)$ 级别个点的，因此合并函数总复杂度是 $\Theta(n \log n)$ 的。

# Code

```cpp
#include <bits/stdc++.h>
#define re register
#define int long long

using namespace std;

const int N = 2e5 + 10;
int n,q,num = 1,rt[N];

inline int read(){
    int r = 0,w = 1;
    char c = getchar();
    while (c < '0' || c > '9'){
        if (c == '-') w = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9'){
        r = (r << 3) + (r << 1) + (c ^ 48);
        c = getchar();
    }
    return r * w;
}

struct seg{
    #define ls(u) (tr[u].l)
    #define rs(u) (tr[u].r)

    int idx;
    vector<int> d;

    struct node{
        int l,r,sum;
    }tr[N << 5];

    inline int newnode(){
        if (d.empty()) return ++idx;
        int t = d.back(); d.pop_back();
        return t;
    }

    inline void delnode(int u){
        d.push_back(u); tr[u] = {0,0,0};
    }

    inline void pushup(int u){
        tr[u].sum = tr[ls(u)].sum + tr[rs(u)].sum;
    }

    inline int insert(int u,int l,int r,int x,int k){
        if (!u) u = newnode();
        if (l == r) return tr[u].sum += k,u;
        int mid = l + r >> 1;
        if (x <= mid) ls(u) = insert(ls(u),l,mid,x,k);
        else rs(u) = insert(rs(u),mid + 1,r,x,k);
        pushup(u); return u;
    }

	inline int merge(int x,int y,int l,int r){
		if (!x || !y) return x + y;
        if (l == r){
            tr[x].sum += tr[y].sum; delnode(y);
            return x;
        }
        int mid = l + r >> 1;
		ls(x) = merge(ls(x),ls(y),l,mid); rs(x) = merge(rs(x),rs(y),mid + 1,r);
        delnode(y); pushup(x);
		return x;
	}

    inline void split(int x,int &y,int k){
        if (!x) return;
        y = newnode();
        int v = tr[ls(x)].sum;
        if (k > v) split(rs(x),rs(y),k - v);
        else swap(rs(x),rs(y));
        if (k < v) split(ls(x),ls(y),k);
        tr[y].sum = tr[x].sum - k; tr[x].sum = k;
    }

    inline int query_sum(int u,int l,int r,int ql,int qr){
        if (ql <= l && r <= qr) return tr[u].sum;
        int res = 0;
        int mid = l + r >> 1;
        if (ql <= mid) res += query_sum(ls(u),l,mid,ql,qr);
        if (qr > mid) res += query_sum(rs(u),mid + 1,r,ql,qr);
        return res;
    }

    inline int query_kth(int u,int l,int r,int k){
        if (l == r) return l;
        int mid = l + r >> 1;
        if (k <= tr[ls(u)].sum) return query_kth(ls(u),l,mid,k);
        else return query_kth(rs(u),mid + 1,r,k - tr[ls(u)].sum);
    }

    #undef ls
    #undef rs
}T;

signed main(){
    n = read(),q = read();
    for (re int i = 1;i <= n;i++){
        int x; x = read();
        rt[1] = T.insert(rt[1],1,n,i,x);
    }
    while (q--){
        int op; op = read();
        if (!op){
            int p,x,y,tmp = 0;
            p = read(),x = read(),y = read();
            int a = T.query_sum(rt[p],1,n,1,y),b = T.query_sum(rt[p],1,n,x,y);
            T.split(rt[p],rt[++num],a - b); T.split(rt[num],tmp,b);
            rt[p] = T.merge(rt[p],tmp,1,n);
        }
        else if (op == 1){
            int p,t;
            p = read(),t = read();
            rt[p] = T.merge(rt[p],rt[t],1,n);
        }
        else if (op == 2){
            int p,k,x;
            p = read(),k = read(),x = read();
            rt[p] = T.insert(rt[p],1,n,x,k);
        }
        else if (op == 3){
            int p,x,y;
            p = read(),x = read(),y = read();
            printf("%lld\n",T.query_sum(rt[p],1,n,x,y));
        }
        else{
            int p,k;
            p = read(),k = read();
            if (T.tr[rt[p]].sum < k) puts("-1");
            else printf("%lld\n",T.query_kth(rt[p],1,n,k));
        }
    }
    return 0;
}
```

---

## 作者：Utilokasteinn (赞：2)

## [Link](https://www.luogu.com.cn/problem/P5494)

线段树分裂板子题。也是线段树合并的板子题。

前置知识：权值线段树。

先讲线段树合并。顾名思义，线段树合并就是将两颗线段树合并成一颗。一般来说，我们合并的是权值线段树。

例如我们有两个可重集 $a$ 和 $b$，分别建出权值线段树 $A$ 和 $B$。其中$A$ 的节点 $p$ 存放 $a$ 中值在 $[l_p,r_p]$ 中的个数，$B$ 同理。

那我们若将两个集合合并在一起，只需要将表示该集合的线段合并在一起。那么怎么合并呢？

假设两个可重集的值在 $[1,v]$ 之间，那么每颗线段树共有 $2v-1$ 个节点，若暴力合并，也就是对应节点的值暴力相加，那么时间复杂度是 $O(v)$ 的。显然会超时。

实际上，在线段树 $A$ 中，会有大量的空节点，没有值在该节点表示的值域中。那我们只需要将有内容的节点合并即可。

若对应节点 $p$ 和 $p'$ 合并，分类一下（一下有/没有指内容）

- $A$ 有 $B$ 没有，该节点直接为 $p$。

- $A$ 没有 $B$ 有，新建一个节点赋为 $p'$ 给 $A$，然后递归 $p'$ 的左右儿子继续合并。

- $A,B$ 都没有，赋 $0$。

- $A,B$ 都有，递归左右儿子。最后合并。

------------
线段树分裂，顾名思义，就是将一颗线段树分裂成两颗。

例如我们有一个可重集 $a$，我们需要将 $a$ 分裂成 $a'$ 和 $b$，其中 $b$ 中的数在 $[l,r]$ 之间，$a$ 中没有数在 $[l,r]$ 之间。

我们建一颗权值线段树表示 $A$。要分裂出 $A'$ 和 $B$ 出来。

直接从根节点开始访问。

在节点 $p$ 时，若 $l<=l_p$ 且 $r_p<=r$，那么直接接到线段树 $B$ 上。删除线段树 $A$ 中该节点。

若不完全包含，递归左右儿子。

若完全不包含，直接返回。

~~合并和分裂的时间复杂度不会算，但是能过就是了。~~

现在看一下题目，共 $5$ 个操作。

操作 $0$，直接分裂。

操作 $1$，线段树合并。

操作 $2$，线段树单点修改。

操作 $3$，线段树区间查询。

操作 $4$，权值线段树中查询第 $k$ 小，不会的可以去看一下普通平衡树的题解，里面有线段树求第 $k$ 小。

时空复杂度都不会算……

一个技巧，因为这题合并后会合并后会清空一颗线段树，所以可以设一个 $vector$ 来存那些废掉的节点，然后动态开点的时候优先从废节点中取。若没有才新建。

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline int read()
{
	int s=0;char c=getchar();
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())
		s=s*10+c-'0';
	return s;
}
int v,m,tot=1,tot1,root[200005];
struct segment_tree{
	ll cnt;
	int ls,rs;
}s[200005*32];
vector<int>rubbish;
inline int New()
{
	if(!rubbish.empty())
	{
		int temp=rubbish.back();
		rubbish.pop_back();
		return temp;
	}
	return ++tot1;
}
inline void del(int &p)
{
	s[p].ls=s[p].rs=s[p].cnt=0;
	rubbish.push_back(p);
	p=0;
}
inline void push_up(int p)
{
	s[p].cnt=s[s[p].ls].cnt+s[s[p].rs].cnt;
}
void build(int l,int r,int &p)
{
	if(!p)p=New();
	if(l==r)
	{
		s[p].cnt=read();
		return;
	}
	int mid=(l+r)/2;
	build(l,mid,s[p].ls);
	build(mid+1,r,s[p].rs);
	push_up(p);
}
void split(int ql,int qr,int l,int r,int &p1,int &p2)
{
	if(ql>r||qr<l||!p1)return;
	if(ql<=l&&r<=qr)
	{
		p2=p1;
		p1=0;
		return;
	}
	if(!p2)p2=New();
	int mid=(l+r)/2;
	split(ql,qr,l,mid,s[p1].ls,s[p2].ls);
	split(ql,qr,mid+1,r,s[p1].rs,s[p2].rs);
	push_up(p1),push_up(p2);
}
void merge(int l,int r,int &p1,int &p2)
{
	if(!p1||!p2)
	{
		p1+=p2;
		return;
	}
	if(l==r)
	{
		s[p1].cnt+=s[p2].cnt;
		del(p2);
		return;
	}
	int mid=(l+r)/2;
	merge(l,mid,s[p1].ls,s[p2].ls);
	merge(mid+1,r,s[p1].rs,s[p2].rs);
	del(p2);
	push_up(p1);
}
void update(int pos,int k,int l,int r,int &p)
{
	if(pos<l||r<pos)return;
	if(!p)p=New();
	if(l==r)
	{
		s[p].cnt+=k;
		return;
	}
	int mid=(l+r)/2;
	update(pos,k,l,mid,s[p].ls),update(pos,k,mid+1,r,s[p].rs);
	push_up(p);
}
ll query_cnt(int ql,int qr,int l,int r,int p)
{
	if(ql>r||qr<l||!p)return 0;
	if(ql<=l&&r<=qr)
		return s[p].cnt;
	int mid=(l+r)/2;
	return query_cnt(ql,qr,l,mid,s[p].ls)+query_cnt(ql,qr,mid+1,r,s[p].rs);
}
int query_kth(int k,int l,int r,int p)
{
	if(l==r)return l;
	int mid=(l+r)/2;
	if(s[s[p].ls].cnt>=k)return query_kth(k,l,mid,s[p].ls);
	return query_kth(k-s[s[p].ls].cnt,mid+1,r,s[p].rs);
}
int main()
{
	v=read(),m=read();
	build(1,v,root[1]);
	while(m--)
	{
		int op=read();
		if(op==0)
		{
			int x=read(),l=read(),r=read();
			split(l,r,1,v,root[x],root[++tot]);
		}
		if(op==1)
		{
			int x=read(),y=read();
			merge(1,v,root[x],root[y]);
		}
		if(op==2)
		{
			int x=read(),k=read(),num=read();
			update(num,k,1,v,root[x]);
		}
		if(op==3)
		{
			int x=read(),l=read(),r=read();
			printf("%lld\n",query_cnt(l,r,1,v,root[x]));
		}
		if(op==4)
		{
			int x=read(),k=read();
			if(s[root[x]].cnt<k)printf("-1\n");
			else printf("%d\n",query_kth(k,1,v,root[x]));
		}
	}
	return 0;
}
```


---

## 作者：JiaY19 (赞：2)

[可能更好的阅读体验](https://www.cnblogs.com/mfeitveer/p/16554748.html)

很久之前写的题目了，写一篇题解来回忆一下。

### 线段树合并与分裂

线段树是一个非常有意思的数据结构，它支持很多的操作，包括分裂与合并。

### 合并

[例题：P4556 [Vani有约会]雨天的尾巴 /【模板】线段树合并](https://www.luogu.com.cn/problem/P4556)

首先，支持合并的操作的线段树，出于空间与时间的考虑，需要写动态开点线段树。

考虑如何合并两颗线段树。

![](https://cdn.luogu.com.cn/upload/image_hosting/qc0l1tki.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/vszdh20b.png)

首先会遍历到第一个节点，发现两棵线段树都有，那么就将维护的东西合并。

然后到第二个节点，同理，接着，发现第一棵线段树没有 $(1,2)$ 号节点，那么直接接上，无需遍历。

然后合并 $(3,3)$，接上 $(4,5)$，这就是大概的算法流程。

总结一下。

1. 遍历到一个节点，若有一方没有，则直接接上。

2. 否则，继续遍历，合并信息。

3. 当然，合并完后没有用的节点需要删除。

```cpp
inline int merge(int p1 , int p2 , int l , int r)
{
    if(!p1 || !p2) return p1 + p2;
    t[p1].val += t[p2].val;
    if(l == r) { del(p2); return p1; }
    t[p1].l = merge(t[p1].l , t[p2].l , l , (l + r) / 2);
    t[p1].r = merge(t[p1].r , t[p2].r , (l + r) / 2 + 1 , r);
    del(p2); return p1;
}

```

### 分裂

[例题：P5494 【模板】线段树分裂](https://www.luogu.com.cn/problem/P5494)

一般来讲，线段树的分裂是将前 $\text{k}$ 个节点分到一颗线段树上，其余的分裂到另一棵线段树上。

我们可以考虑一个和 $\text{FHQ treap}$ 相似的过程。

1. 若此时被分裂的线段树的左儿子子树大小大于等于 $\text{k}$，那么就可以将整个右儿子送给第二棵线段树。

2. 若左儿子子树大小还大于 $\text{k}$ 那么就要到左儿子处继续分裂。

3. 若左儿子子树大小小于 $\text{k}$ 那么就要到右儿子处继续分裂。

```cpp
inline void split(int x , int &y , int k)
{
	if(!x) return; y = new_node(); int val = t[t[x].son[0]].sum;
	if(val < k) split(t[x].son[1] , t[y].son[1] , k - val);
	else swap(t[x].son[1] , t[y].son[1]);
	if(val > k) split(t[x].son[0] , t[y].son[0] , k);
	t[y].sum = t[x].sum - k , t[x].sum = k;
}

```

### 时间复杂度

#### 合并

我知道的，大概有两种证明方法。

第一种是我们知道所有的节点一共有 $n\log n$ 个。

而我们每次合并都只会合并两方都有的节点，并且删掉其中之一。

故最多只会删除 $n\log n$ 次，复杂度为 $O(n \log n)$。

第二种可能只是第一种的另一个说法。

我们发现每一次合并都会有叶子节点，~~一句废话~~。

可以发现每次会需要 $O(\log n)$。

而只有 $n$ 个叶子节点，故复杂度为 $O(n \log n)$。

仔细想一想，两种都是一个原理。

#### 分裂

分裂的复杂度就比较好证了。

可以发现，每一次分裂的操作与查询的操作很像。

可以说与查找第 $k$ 个数简直一模一样。

故时间复杂度 $O(n \log n)$

### 关于此题

总体来说，线段树的合并与分裂只要掌握思路代码实现比较简单。

最后附上此题代码。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 200010;

int n, m, cnt, top, tot, stk[N * 32], root[N];

struct Tree
{
    int sum, son[2];
} t[N * 32];

inline int read()
{
    int asd = 0, qwe = 1; char zxc;
    while (!isdigit(zxc = getchar())) if (zxc == '-') qwe = -1;
    while (isdigit(zxc)) asd = asd * 10 + zxc - '0', zxc = getchar();
    return asd * qwe;
}

inline void del(int x)
{
    if (!x)
        return;
    t[x].sum = t[x].son[0] = t[x].son[1] = 0;
    stk[++top] = x;
}

inline int new_node()
{
    return (top ? stk[top--] : ++cnt);
}

inline void update(int &p, int l, int r, int k, int val)
{
    if (!p)
        p = new_node();
    t[p].sum += val;
    if (l == r)
        return;
    int mid = (l + r) / 2;
    if (mid >= k)
        update(t[p].son[0], l, mid, k, val);
    else
        update(t[p].son[1], mid + 1, r, k, val);
}

inline int merge(int x, int y)
{
    if (!x || !y)
        return x + y;
    t[x].sum += t[y].sum;
    t[x].son[0] = merge(t[x].son[0], t[y].son[0]);
    t[x].son[1] = merge(t[x].son[1], t[y].son[1]);
    del(y);
    return x;
}

inline void split(int x, int &y, int k)
{
    if (!x)
        return;
    y = new_node();
    int val = t[t[x].son[0]].sum;
    if (val < k)
        split(t[x].son[1], t[y].son[1], k - val);
    else
        swap(t[x].son[1], t[y].son[1]);
    if (val > k)
        split(t[x].son[0], t[y].son[0], k);
    t[y].sum = t[x].sum - k, t[x].sum = k;
}

inline int ask1(int p, int l, int r, int ql, int qr)
{
    if (!p || l > qr || r < ql)
        return 0;
    if (ql <= l && r <= qr)
        return t[p].sum;
    int mid = (l + r) / 2;
    return ask1(t[p].son[0], l, mid, ql, qr) + ask1(t[p].son[1], mid + 1, r, ql, qr);
}

inline int ask2(int p, int l, int r, int k)
{
    if (l == r)
        return l;
    if (t[t[p].son[0]].sum >= k)
        return ask2(t[p].son[0], l, (l + r) / 2, k);
    else
        return ask2(t[p].son[1], (l + r) / 2 + 1, r, k - t[t[p].son[0]].sum);
}

signed main()
{
    n = read(), m = read(), tot = 1;
    for (int i = 1; i <= n; i++)
    {
        int x = read();
        if (x)
            update(root[1], 1, n, i, x);
    }
    for (int i = 1; i <= m; i++)
    {
        int opt = read();
        if (opt == 0)
        {
            ++tot;
            int p = read(), x = read(), y = read(), tmp = 0;
            int k1 = ask1(root[p], 1, n, 1, y);
            int k2 = ask1(root[p], 1, n, x, y);
            split(root[p], root[tot], k1 - k2);
            split(root[tot], tmp, k2);
            root[p] = merge(root[p], tmp);
        }
        if (opt == 1)
        {
            int x = read(), y = read();
            root[x] = merge(root[x], root[y]);
        }
        if (opt == 2)
        {
            int p = read(), x = read(), q = read();
            update(root[p], 1, n, q, x);
        }
        if (opt == 3)
        {
            int p = read(), x = read(), y = read();
            printf("%lld\n", ask1(root[p], 1, n, x, y));
        }
        if (opt == 4)
        {
            int p = read(), k = read();
            if (t[root[p]].sum < k)
                puts("-1");
            else
                printf("%lld\n", ask2(root[p], 1, n, k));
        }
    }
    return 0;
}

```

---

## 作者：Others (赞：1)

线段树板板系列

# 前置芝士

线段树（~~不会你还来做这个题干嘛~~），**动态开点**。

# Solution

先显然的看出这题维护的是权值线段树，然后就是一些操作。

**操作 1：**

操作 0 需要，所以先讲。这个线段树合并很巧的一点是动态开点中总结点个数不会超过 $O(m\log n)$，所以遍历每一个对应的两个结点，若有一个为空，返回另一个，否则确定一个为合并后的根结点继续递归。

```cpp
int merge(int p,int q,int l,int r) {
	if(!p) return q;if(!q) return p;
	if(l==r) {tr[p].sum+=tr[q].sum;return p;}
	tr[p].lc=merge(tr[p].lc,tr[q].lc,l,l+r>>1);
	tr[p].rc=merge(tr[p].rc,tr[q].rc,(l+r>>1)+1,r);
	pushup(p);
	return p;
}
```

**操作 0：**

搞定线段树分裂就行了（这题的关键所在），我们只需要知道把一个线段树分裂成两半就是将其中一条链“分开”，递归这条链就 OK 了，完全没有技术含量（模拟）。

对于这个操作，考虑分裂左端点和右端点，再将右边和左边合并就行了，**注意合并时**这两个区间是“分开的”（没有交集），即使用 `merge(p,q,l,r)` 时遍历的是结点管理区间包含操作的区间的结点（$\{p|l_p\le x\le y\le r_p\}$），这样的结点数不超过 $O(\log n)$，所以这样“暴力”复杂度是没问题的。

**split 函数**

```cpp
int split(int p,int x,int l,int r) {
	if(l==r) return p;
	int tmp=New();
	int mid=l+r>>1;
	if(x<=mid&&tr[p].lc) tr[tmp].lc=split(tr[p].lc,x,l,mid),tr[tmp].rc=tr[p].rc,tr[p].rc=0,(tr[p].lc==tr[tmp].lc)&&(tr[p].lc=0);
	else if(tr[p].rc) tr[tmp].rc=split(tr[p].rc,x,mid+1,r),(tr[p].rc==tr[tmp].rc)&&(tr[p].rc=0);
	pushup(p),pushup(tmp);
	return tmp;
}
```
**主函数 Code**

```cpp
p=read(),x=read(),y=read(),rt[++root]=split(rt[p],x,1,n);
if(y==n) continue;
Tmp=split(rt[root],y+1,1,n),rt[p]=merge(rt[p],Tmp,1,n);
```

操作 $2,3,4$ 就是简单的单点加，区间和和 $kth$ 问题，不再赘述。

**总 Code**

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace IO{//by cyffff
	char ibuf[(1<<20)+1],*iS,*iT;
	#define ll long long
	#if ONLINE_JUDGE
	#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
 	#else
	#define gh() getchar()
	#endif
	inline ll read(){
		char ch=gh();
		ll x=0;
		char t=0;
		while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();
		while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
		return t?-x:x;
	}
	void write(ll x) {
		if(x<0) putchar('-'),x=~(x-1);
		if(x>=10) write(x/10);
		putchar(x%10^48);
	}
}
using IO::read;
using IO::write;
const int N=200005;
struct node {
	int lc,rc;ll sum;
}tr[N<<5];
int tot=0,n,m,rt[N],root,op,p,x,y,Tmp;
inline int New() {tr[++tot]=(node){0,0,0};return tot;}
inline void pushup(int p) {tr[p].sum=tr[tr[p].lc].sum+tr[tr[p].rc].sum;}
void build(int p,int l,int r) {
	if(l==r) {tr[p].sum=read();return ;}
	tr[p].lc=New(),tr[p].rc=New();
	build(tr[p].lc,l,l+r>>1),build(tr[p].rc,(l+r>>1)+1,r),pushup(p);
}
void add(int p,int x,int delta,int l,int r) {
	if(l==r) {tr[p].sum+=delta;return ;}
	if((l+r>>1)>=x) (tr[p].lc==0)&&(tr[p].lc=New()),add(tr[p].lc,x,delta,l,l+r>>1);
	else (tr[p].rc==0)&&(tr[p].rc=New()),add(tr[p].rc,x,delta,(l+r>>1)+1,r);
	pushup(p);
}
int merge(int p,int q,int l,int r) {
	if(!p) return q;if(!q) return p;
	if(l==r) {tr[p].sum+=tr[q].sum;return p;}
	tr[p].lc=merge(tr[p].lc,tr[q].lc,l,l+r>>1);
	tr[p].rc=merge(tr[p].rc,tr[q].rc,(l+r>>1)+1,r);
	pushup(p);
	return p;
}
int split(int p,int x,int l,int r) {
	if(l==r) return p;
	int tmp=New();
	int mid=l+r>>1;
	if(x<=mid&&tr[p].lc) tr[tmp].lc=split(tr[p].lc,x,l,mid),tr[tmp].rc=tr[p].rc,tr[p].rc=0,(tr[p].lc==tr[tmp].lc)&&(tr[p].lc=0);
	else if(tr[p].rc) tr[tmp].rc=split(tr[p].rc,x,mid+1,r),(tr[p].rc==tr[tmp].rc)&&(tr[p].rc=0);
	pushup(p),pushup(tmp);
	return tmp;
}
ll ask(int p,int l,int r,int s,int t) {
	if(s>r||t<l||!p) return 0;
	if(s<=l&&r<=t) return tr[p].sum;
	return ask(tr[p].lc,l,l+r>>1,s,t)+ask(tr[p].rc,(l+r>>1)+1,r,s,t);
}
int kth(int p,int k,int l,int r) {
	if(l==r) return l;
	if(tr[p].lc&&tr[tr[p].lc].sum>=k) return kth(tr[p].lc,k,l,l+r>>1);
	(tr[p].lc)&&(k-=tr[tr[p].lc].sum);
	return kth(tr[p].rc,k,(l+r>>1)+1,r);
}
int main() {
	n=read(),m=read(),tr[rt[++root]=++tot]=(node){0,0,0},build(1,1,n);
	while(m--) {
		op=read();
		if(op==0) {
			p=read(),x=read(),y=read(),rt[++root]=split(rt[p],x,1,n);
			if(y==n) continue;
			Tmp=split(rt[root],y+1,1,n),rt[p]=merge(rt[p],Tmp,1,n);
		}else if(op==1) {
			x=read(),y=read(),rt[x]=merge(rt[x],rt[y],1,n);
		}else if(op==2) {
			p=read(),x=read(),y=read(),add(rt[p],y,x,1,n);
		}else if(op==3) {
			p=read(),x=read(),y=read(),write(ask(rt[p],1,n,x,y)),putchar('\n');
		}else {
			p=read(),x=read();
			if(tr[rt[p]].sum<x) {
				putchar('-'),putchar('1'),putchar('\n');
				continue;
			}
			write(kth(rt[p],x,1,n)),putchar('\n');
		}
	}
	return 0;
}

```

---

## 作者：Milthm (赞：0)

### 题目描述

给出一个可重集 $a$（编号为 $1$），它支持以下操作：

`0 p x y`：将可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值移动到一个新的可重集中（新可重集编号为从 $2$ 开始的正整数，是上一次产生的新可重集的编号+1）。

`1 p t`：将可重集 $t$ 中的数放入可重集 $p$，且清空可重集 $t$（数据保证在此后的操作中不会出现可重集 $t$）。

`2 p x q`：在 $p$ 这个可重集中加入 $x$ 个数字 $q$。

`3 p x y`：查询可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值的个数。

`4 p k`：查询在 $p$ 这个可重集中第 $k$ 小的数，不存在时输出 `-1`。

____

线段树分裂合并，顾名思义，就是一个分裂合并的过程。

首先，本题一看就是要建一个值域线段树，而且要用动态开点。然后分别思考每一个操作：

#### $0$ 操作：

这是一个分裂操作，也是本题中比较重要的操作：

思路为（假设当前拿到 $x$，要分裂到 $y$ 里）：

1. 如果 $x$ 没了，直接 `return`。
2. 如果当前区间在范围内，就将 $x$ 分裂给 $y$。
3. 否则如果 $y$ 没了，新建一个节点 $y$。
4. 向 $x$ 和 $y$ 的左子树和右子树递归。
5. 把两个点都 `pushup` 一下。

代码：

```cpp
void split(int &x,int &y,int l,int r,int ql,int qr){
	if(!x)return;
	if(ql<=l&&r<=qr){
		y=x;x=0;return;
	}
	if(!y)y=getnew();
	if(ql<=mid)split(lc[x],lc[y],l,mid,ql,qr);
	if(qr>mid)split(rc[x],rc[y],mid+1,r,ql,qr);
	pushup(x);pushup(y);
}
```

#### $1$ 操作

这是一个合并操作。

思路为（假设要合并的两个节点是 $x$ 和 $y$，函数要返回的值是合并后 $x$ 的新编号）：

1. 如果 $x$ 没了就返回 $y$，$y$ 没了就返回 $x$。可以简化为如果 $x$ 和 $y$ 有一个没了就返回 $x+y$。

2. 把 $y$ 的值加到 $x$ 上。
3. 让左右子树分别递归。
4. 删除 $y$。

注意这里第 $4$ 步删除会浪费很多空间。为了不爆空间，所以我们删节点是这样删的：

```cpp
void del(int x){
	store[++top]=x;lc[x]=rc[x]=sum[x]=0;
}
```

相当于开了一个删除栈，把删掉的节点放进去。

则对应的新加节点方式为：

```cpp
int getnew(){
	return (top?store[top--]:++tot);
}
```

相当于从被删除的节点里拿一个出来。

合并的代码：

```cpp
int merge(int x,int y){
	if(!x||!y)return x+y;
	sum[x]+=sum[y];
	lc[x]=merge(lc[x],lc[y]);
	rc[x]=merge(rc[x],rc[y]);
	del(y);return x;
}
```

#### $2$ 操作

这是一个单点修改操作，直接修改就可以。

代码：

```cpp
void update(int &x,int l,int r,int k,int v){
	if(!x)x=getnew();
	if(l==r){
		sum[x]+=v;return;
	}
	if(k<=mid)update(lc[x],l,mid,k,v);
	else update(rc[x],mid+1,r,k,v);
	pushup(x);
}
```

#### $3$ 操作

这是一个查询操作，直接查询就可以。

代码：

```cpp
int query(int x,int l,int r,int ql,int qr){
	if(!x)return 0;
	if(ql<=l&&r<=qr)return sum[x];
	int ans=0;
	if(ql<=mid)ans+=query(lc[x],l,mid,ql,qr);
	if(qr>mid)ans+=query(rc[x],mid+1,r,ql,qr);
	return ans;
}
```

#### $4$ 操作

同样是经典的第 $k$ 小查询，直接线段树上二分即可。

代码：

```cpp
int kth(int x,int l,int r,int k){
	if(l==r)return l;
	if(k<=sum[lc[x]])return kth(lc[x],l,mid,k);
	return kth(rc[x],mid+1,r,k-sum[lc[x]]);
}
```

判无解：如果整棵树都没有 $k$ 大，那肯定无解。代码：

```cpp
if(sum[rt[p]]<x)cout<<"-1\n";
```

否则输出答案即可。
____

这样你就实现了线段树的合并与分裂！

### 完整代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define mid ((l+r)>>1)
#define N 200005
using namespace std;
int read(){
	char c=getchar();int ans=0;
	while(!isdigit(c))c=getchar();
	while(isdigit(c))ans=ans*10+c-'0',c=getchar();
	return ans;
}
int n,m,lc[N*32],rc[N*32],rt[N*32],store[N*32],sum[N*32];
int tot,cnt,top;
int getnew(){
	return (top?store[top--]:++tot);
}
void del(int x){
	store[++top]=x;lc[x]=rc[x]=sum[x]=0;
}
void pushup(int x){
	sum[x]=sum[lc[x]]+sum[rc[x]];
}
void update(int &x,int l,int r,int k,int v){
	if(!x)x=getnew();
	if(l==r){
		sum[x]+=v;return;
	}
	if(k<=mid)update(lc[x],l,mid,k,v);
	else update(rc[x],mid+1,r,k,v);
	pushup(x);
}
int merge(int x,int y){
	if(!x||!y)return x+y;
	sum[x]+=sum[y];
	lc[x]=merge(lc[x],lc[y]);
	rc[x]=merge(rc[x],rc[y]);
	del(y);return x;
}
void split(int &x,int &y,int l,int r,int ql,int qr){
	if(!x)return;
	if(ql<=l&&r<=qr){
		y=x;x=0;return;
	}
	if(!y)y=getnew();
	if(ql<=mid)split(lc[x],lc[y],l,mid,ql,qr);
	if(qr>mid)split(rc[x],rc[y],mid+1,r,ql,qr);
	pushup(x);pushup(y);
}
int query(int x,int l,int r,int ql,int qr){
	if(!x)return 0;
	if(ql<=l&&r<=qr)return sum[x];
	int ans=0;
	if(ql<=mid)ans+=query(lc[x],l,mid,ql,qr);
	if(qr>mid)ans+=query(rc[x],mid+1,r,ql,qr);
	return ans;
}
int kth(int x,int l,int r,int k){
	if(l==r)return l;
	if(k<=sum[lc[x]])return kth(lc[x],l,mid,k);
	return kth(rc[x],mid+1,r,k-sum[lc[x]]);
}
signed main(){
	rt[++cnt]=++tot;
	n=read();m=read();
	for(int i=1;i<=n;++i)update(rt[1],1,n,i,read());
	while(m--){
		int op,p,x,y;
		op=read();
		if(op==0){
			p=read();x=read();y=read();
			rt[++cnt]=++tot;split(rt[p],rt[cnt],1,n,x,y);
		}
		else if(op==1){
			p=read();x=read();rt[p]=merge(rt[p],rt[x]);
		}
		else if(op==2){
			p=read();x=read();y=read();update(rt[p],1,n,y,x);
		}
		else if(op==3){
			p=read();x=read();y=read();
			printf("%lld\n",query(rt[p],1,n,x,y));
		}
		else{
			p=read();x=read();
			if(sum[rt[p]]<x)cout<<"-1\n";
			else printf("%lld\n",kth(rt[p],1,n,x));
		}
	}
	return 0;
}
```


---

## 作者：cjwdyzxfblzs (赞：0)

看到题解区并没有关于指针的写法的题解，我来发一发。

之所以选择指针写法，主要是可以省去节点回收这一步骤（太懒了）。

线段树分裂是什么？？？

顾名思义，就是把一颗权值线段树分裂成两颗权值线段树。

这里的分裂可以类比 fhq_treap 的分裂方式。

保留前 $k$ 个元素：

- 如果 $k < lson \rightarrow size$，递归左子树分裂，并且取走整颗的右子树。

- 如果 $k = lson \rightarrow size$，分裂开左右子树。

- 如果 $k > lson \rightarrow size$，递归右子树分裂。

代码是这样子的：

```cpp
void split(node *now, node *&y, int k) {
    if (now == nullptr) return;
    y = new node();
    int siz = now->lz();
    if (siz < k) split(now->rs, y->rs, k - siz);
    else std::swap(now->rs, y->rs);
    if (siz > k) split(now->ls, y->ls, k);
    y->sum = now->sum - k;
    now->sum = k;
}
```

观察代码发现每次递归只对一边递归，所以复杂度可以到达 $O(\log{n})$ 。

（指针搞不好会出现“段错误”，可以使用 assert 辅助调试）

代码：

```cpp
#include <bits/stdc++.h>
#define int long long
int rd() {
    int x = 0, f = 1; char ch = getchar();
    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
    while (isdigit(ch)) { x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar(); }
    return x * f;
}
void wt(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) wt(x / 10);
    putchar(x % 10 + 48);
}
const int N = 1e6;
int n, m, a[N];
struct node {
    node *ls, *rs; int sum;
    node () { ls = rs = nullptr; sum = 0; }
    node (int sum) : sum(sum) { ls = rs = nullptr; }
    inline int lz() { return (ls == nullptr ? 0 : ls->sum); }
    inline int rz() { return (rs == nullptr ? 0 : rs->sum); }
    inline int sm() { return (this == nullptr ? 0 : sum); }
};
node *root[N]; int rt = 1;
void insert(node *&now, int l, int r, int pos, int val) {
    if (now == nullptr) now = new node();
    // assert(now != nullptr);
    now->sum += val;
    if (l == r) return;
    int mid = (l + r) >> 1;
    if (pos <= mid)
        insert(now->ls, l, mid, pos, val);
    else 
        insert(now->rs, mid + 1, r, pos, val);
}
int querysiz(node *&now, int l, int r, int ql, int qr) {
    if (now == nullptr) return 0;
    // assert(now != nullptr);
    if (ql <= l && r <= qr) return now->sum;
    int mid = (l + r) >> 1, ans = 0;
    if (ql <= mid) ans += querysiz(now->ls, l, mid, ql, qr);
    if (qr > mid) ans += querysiz(now->rs, mid + 1, r, ql, qr);
    return ans;
}
void split(node *now, node *&y, int k) {
    if (now == nullptr) return;
    y = new node();
    // assert(now != nullptr), assert(y != nullptr);
    int siz = now->lz();
    if (siz < k) split(now->rs, y->rs, k - siz);
    else std::swap(now->rs, y->rs);
    if (siz > k) split(now->ls, y->ls, k);
    y->sum = now->sum - k;
    now->sum = k;
}
node *merge(node *now, node *y, int l, int r) {
    if (now == nullptr || y == nullptr) 
        return !now ? y : now;
    // assert(now != nullptr), assert(y != nullptr);
    if (l == r) return now;
    now->sum += y->sum;
    int mid = (l + r) >> 1;
    now->ls = merge(now->ls, y->ls, l, mid);
    now->rs = merge(now->rs, y->rs, mid + 1, r);
    delete y;
    return now;
}
int querykth(node *now, int l, int r, int k) {
    // assert(now != nullptr);
    if (l == r) return l;
    int mid = (l + r) >> 1, siz = now->lz();
    if (k <= siz) return querykth(now->ls, l, mid, k);
    return querykth(now->rs, mid + 1, r, k - siz);
}
auto main() -> signed
{
    n = rd(), m = rd();
    for (int i = 0; i <= 100000; i ++ ) root[i] = new node();
    // assert(root[1] != nullptr);
    for (int i = 1; i <= n; i ++ ) insert(root[1], 1, n, i, rd());
    while (m -- )
    {
        int op = rd();
        if (op == 0) {
            int p = rd(), x = rd(), y = rd();
            int siz1 = querysiz(root[p], 1, n, 1, y);
            int siz2 = querysiz(root[p], 1, n, x, y);
            split(root[p], root[ ++ rt], siz1 - siz2);
            split(root[rt], root[0], siz2);
            // assert(root[rt] != nullptr and root[p] != nullptr and root[0] != nullptr);
            root[p] = merge(root[p], root[0], 1, n);
        }
        else if (op == 1) {
            int p = rd(), t = rd();
            // assert(root[p] != nullptr);
            root[p] = merge(root[p], root[t], 1, n);
        }
        else if (op == 2) {
            int p = rd(), x = rd(), q = rd();
            // assert(root[p] != nullptr);
            insert(root[p], 1, n, q, x);
        }
        else if (op == 3) {
            int p = rd(), x = rd(), y = rd();
            // assert(root[p] != nullptr);
            std::cout << querysiz(root[p], 1, n, x, y) << std::endl;
        }
        else if (op == 4) {
            int p = rd(), x = rd();
            // assert(root[p] != nullptr);
            if (root[p]->sum < x) puts("-1");
            else std::cout << querykth(root[p], 1, n, x) << std::endl;
        }   
    }
    return 0;
}
```

---

## 作者：SrsgPrince_ (赞：0)

# Luogu P5494 【模板】线段树分裂 Solution

题目传送门：[Luogu P5494 【模板】线段树分裂](https://www.luogu.com.cn/problem/P5494)。

推荐在我的 [博客](https://www.luogu.com.cn/blog/fy123333/LuoguP5494Solution) 中查看。

## 题目描述 Hint

给出一个可重集 $a$（编号为 $1$），它支持以下操作：

1. `0 p x y`：将可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值移动到一个新的可重集中（新可重集编号为从 $2$ 开始的正整数，是上一次产生的新可重集的编号+1）。
2. `1 p t`：将可重集 $t$ 中的数放入可重集 $p$，且清空可重集 $t$（数据保证在此后的操作中不会出现可重集 $t$）。
3. `2 p x q`：在 $p$ 这个可重集中加入 $x$ 个数字 $q$。
4. `3 p x y`：查询可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值的个数。
5. `4 p k`：查询在 $p$ 这个可重集中第 $k$ 小的数，不存在时输出 `-1`。

数据范围：$1 \leq n \leq 2 \times 10^5, 1 \leq x,y,q \leq m \leq 2 \times 10^5$。

首先后面四个操作，第二个是合并线段树，第三个是单点修改，第四个是区间求和，第五个是求第 $k$ 小。第一个操作是将 $[x, y]$ 分裂出来，具体做法在思路部分会讲。

## 思路 Solution

首先先说一下线段树合并，这个操作是为了整合两棵线段树维护的信息，如果两棵树相加，那么就把对应节点的权值相加就行，如果一棵树上的点是缺的，那么这个点的权值就是 $0$。我们合并线段树的目的是什么呢？如果是普通的线段树，那么完全没必要合并，但是如果出现一些特例，比如一棵树因为动态开点的时候开不满，开成链，那这个复杂度 $O(n)$ 是不可接受的，那么在这种情况下我们就不能把它们分开来。

那么怎么合并呢，我们直接把一个节点的值加到对应的另一个节点上去，然后把这个点直接 $\operatorname{deleteNode()}$ 就可以了，如果有些题目出现动态开点导致有链的情况，还可以使用另外一种方法，在两棵线段树上同时 $\operatorname{dfs()}$，然后判断两棵线段树左儿子是否有两个子节点，如果有就往里 $\operatorname{dfs()}$，反之可以看要加进另一棵树的树有没有左儿子，没有那就不用加了，如果被加的那棵树没有左儿子的话，直接把空的区间替换成那个要加进另一颗树的树的左儿子就行了，右儿子同理，但是这道题说实话不需要用到，直接加节点值就行了。这里先给出直接加值的合并的代码。

```cpp
inline int merge(register int lft, register int rgt) {
     if (!lft || !rgt)
         return lft + rgt;
     val[lft] += val[rgt];
     chd[0][lft] = merge(chd[0][lft], chd[0][rgt]);
     chd[1][lft] = merge(chd[1][lft], chd[1][rgt]);
     deleteNode(rgt);
     return lft;
 }
```

如果不是特别有概念的话可以看下面的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5snxlf8m.png)

接下来就是分裂，和合并差不多，就是把一棵树分裂成两棵，分别维护信息（通常是前 $k$ 小，例如本题）。线段树分裂可以在某种程度上说是线段树合并的逆运算。下面给出线段树分裂的图。

![](https://cdn.luogu.com.cn/upload/image_hosting/4ymvjrhf.png)

那么想想分裂怎么实现，首先我们把分裂线段树上以 $x$ 为根节点的子树，并让另一棵树为 $y$ 的函数为 $split(x, y, rnk)$。这里我们需要分类讨论一下。

1. 如果 $val_{lson(x)} < rnk$，那么左侧不用动，直接递归右侧，执行 $split(rson(x), rson(y), rnk - val{lson(x)})$，这里注意是 $rnk - val_{lson(x)}$，要减掉左侧子树的大小。
2. 如果 $val_{lson(x)} = rnk$，那么直接把右子树并给 $y$，那么就是 $rson(y) = rson(x)$，然后把 $rson(x)$ 赋为 $0$。
3. 如果 $val_{lson(x)} > rnk$，不用动右侧，直接递归左侧，执行 $split(lson(x), lson(y), rnk)$ 就行了。

复杂度是 $O(\log n)$。

那么再来看题目，第一个操作就是先分裂 $[1, x-1]$，然后再从剩下的 $[x, n]$ 中分裂出 $[x, y]$ 和 $[y+1, n]$，最后合并 $[y+1, n]$。剩下的四种操作在上个部分说过，复杂度都是 $O(\log n)$。总的复杂度就是 $O(n \log n)$。

放上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2e5 + 10;
int n, m, tot, cnt, seq = 1;
int opt, x, y, z;
int bac[maxn << 5], chd[2][maxn << 5], root[maxn];
long long val[maxn << 5];
inline int newNode() {
    return (cnt ? bac[cnt--] : ++tot);
}
inline void Delete(int p) {
    bac[++cnt] = p;
    chd[0][p] = chd[1][p] = val[p] = 0;
    return;
}
inline void update(int &p, int lft, int rgt, int pos, int v) {
    if (!p) 
        p = newNode();
    val[p] += v;
    if (lft == rgt) 
        return void();
    int mid = (lft + rgt) >> 1;
    if (pos <= mid) 
        update(chd[0][p], lft, mid, pos, v);
    else 
        update(chd[1][p], mid+1, rgt, pos, v);
    return;
}
inline int findKth(int p, int lft, int rgt, int k) {
    if (lft == rgt) 
        return lft;
    int mid = (lft + rgt) >> 1;
    if (val[chd[0][p]] >= k) 
        return findKth(chd[0][p], lft, mid, k);
    else 
        return findKth(chd[1][p], mid+1, rgt, k-val[chd[0][p]]);
}
inline long long query(int p, int l, int r, int lft, int rgt) {
    if (rgt < l || r < lft)
        return 0;
    if (lft <= l && r <= rgt) 
        return val[p];
    int mid = (l + r) >> 1;
    return query(chd[0][p], l, mid, lft, rgt) + query(chd[1][p], mid+1, r, lft, rgt);
}
inline int merge(int x, int y) {
    if(!x || !y) return (x + y);
    val[x] += val[y];
    chd[0][x] = merge(chd[0][x], chd[0][y]);
    chd[1][x] = merge(chd[1][x], chd[1][y]);
    Delete(y);
    return x;
}
inline void split(int x, int &y, long long pos) {
    if (x == 0) 
        return;
    y = newNode();
    long long v = val[chd[0][x]];
    if (v < pos) 
        split(chd[1][x], chd[1][y], pos - v); // 左子树大小小于 pos 的时候，递归进入右子树，并且将 pos 减去左子树大小
    else 
        swap(chd[1][x], chd[1][y]); 
    if (pos < v) 
        split(chd[0][x], chd[0][y], pos); // 左子树大小大于 k 的时候，递归进入左子树，k 不变
    val[y] = val[x] - pos;
    val[x] = pos;
    return;
}
signed main() {
    quickRead<int, int>(n, m);
    for (int i = 1; i <= n; ++i) {
        quickRead<int>(x);
        update(root[1], 1, n, i, x);
    }
    for (int i = 1; i <= m; ++i) {
        quickRead<int>(opt);
        if (opt == 0) {
            quickRead<int, int, int>(x, y, z);
            long long k1 = query(root[x], 1, n, 1, z), k2 = query(root[x], 1, n, y, z);
            int tmp = 0;
            split(root[x], root[++seq], k1-k2);
            split(root[seq], tmp, k2);
            root[x] = merge(root[x], tmp);
        }
        else if (opt == 1) {
            quickRead<int, int>(x, y);
            root[x] = merge(root[x], root[y]);
        }
        else if (opt == 2) {
            quickRead<int, int, int>(x, y, z);
            update(root[x], 1, n, z, y);
        }
        else if (opt == 3) {
            quickRead<int, int, int>(x, y, z);
            printf("%lld\n", query(root[x], 1, n, y, z));
        }
        else if (opt == 4) {
            quickRead<int, int>(x, y);
            if(val[root[x]] < y)  {
                quickWrite("-1\n");
                continue;
            }
            quickWrite(findKth(root[x], 1, n, y), '\n');
        }
    }
    return 0;
}
```


---


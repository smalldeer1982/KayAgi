# [蓝桥杯 2016 国 A] 圆圈舞

## 题目描述

春天温暖的阳光照耀着大地，正是草原上的小动物们最快乐的时候。小动物们在草原上开了一个舞会，欢度这美好的时光。

舞会上最重要的一个环节就是跳圆舞曲，$n$ 只小动物手拉手围成一大圈，随着音乐跳起来。在跳的过程中，小动物们可能会变换队形。它们的变换方式是动物 A 松开自己右手，动物 B 松开自己的左手，动物 A 和 B 手拉到一起，而它们对应的松开的手（如果有的话）也拉到一起。

例如，假设有 $10$ 只小动物，按顺序围成一圈，动物 $1$ 的右手拉着动物 $2$ 的左手，动物 $2$ 的右手拉着动物 $3$ 的左手，依次类推，最后动物 $10$ 的右手拉着动物 $1$ 的左手。如果通过动物 $2$ 和 $8$ 变换队形，则动物 $2$ 的右手拉着动物 $8$ 的左手，而对应的动物 $3$ 的左手拉着动物 $7$ 的右手，这样形成了 `1-2-8-9-10` 和 `3-4-5-6-7` 两个圈。如果此时通过动物 $2$ 和 $6$ 变换队形，则将形成 `1-2-6-7-3-4-5-8-9-10` 一个大圈。注意，如果此时通过动物 $1$ 和 $2$ 变换队形，那么队形不会改变，因为动物 $1$ 的右手和动物 $2$ 的左手松开后又拉到一起了。

在跳舞的过程中，每个动物 $i$ 都有一个欢乐值 $H_i$ 和一个感动值 $F_i$。

如果两个动物在一个圈中，欢乐值会彼此影响，产生欢乐能量。如果两个动物 $i, j(i\neq j)$ 在同一个大小为 $t$ 的圈中，而动物 $i$ 在动物 $j$ 右手的第 $p$ 个位置（动物 $j$ 右手的第 $1$ 个位置就是动物 $j$ 右手所拉着的动物，而第 $2$ 个位置就是右手第 $1$ 个位置的动物右手拉着的动物，依次类推），则产生的欢乐能量为 $(t-p)\times H_j\times F_i$。在跳舞的过程中，动物们的欢乐值和感动值有可能发生变化。

圆舞曲开始的时候，所有的动物按编号顺序围成一个圈，动物 $n$ 右手的第 $i$ 个位置正好是动物 $i$。现在已知小动物们变换队形的过程和欢乐值、感动值变化的过程，求每次变换后所有动物所产生的欢迎能量之和。

## 说明/提示

对于 $20\%$ 的数据，$2\le n,m\le100$。

对于 $30\%$ 的数据，$2\le n,m\le1000$。

另有 $20\%$ 的数据，只有 $k=1$ 的操作且 $H_i$，$F_i$ 均为 $1$。

另有 $20\%$ 的数据，只有 $k=1$ 或 $2$ 的操作且 $F_i$ 均为 $1$。

对于 $100\%$ 的数据，$2\le n,m\le10^5$，$0\le H_i,F_i\le10^9$，$1\le k\le3$，$k=1$ 时 $1\le p,q\le n$ 且 $p\neq q$，$k=2$ 或 $3$ 时 $1\le p\le n$ 且 $0\le q\le10^9$。

## 样例 #1

### 输入

```
10
1 1
1 1
1 1
1 1
1 1
1 1
1 1
1 1
1 1
1 1
9
1 2 8
1 2 6
2 8 10
3 5 10
1 1 2
1 2 1
2 5 5
1 4 8
1 4 5```

### 输出

```
100
450
855
1341
1341
811
923
338
923```

# 题解

## 作者：251Sec (赞：2)

思维难度不高，但是难写的一批。

考虑一个环内的贡献，设环内的点为 $1 \sim c$，则贡献为：

$$\sum_{i=1}^n F_i \left(\sum_{j=1}^{i-1}H_j(c-i+j)-\sum_{i=j+1}^c H_j(i-j)\right)$$

简单推一下这个式子，就可以得到它等于：

$$\sum_{i=1}^c F_i \sum_{j=1}^c jH_j-\sum_{i=1}^c iF_i \sum_{j=1}^c H_j+c\sum\limits_{i=1}^{c}\sum\limits_{j=1}^{i-1}F_iG_j$$

我们可以尝试对一个环维护出 $\sum F_i,\sum iF_i, \sum H_j, \sum jH_j, \sum\limits_{i>j} F_iG_j$ 这些东西，就可以算答案了。可以发现这些东西作为区间信息是可以合并的：前面四个的合并比较显然，第五个东西可以参考 CDQ 分治的思想，即将左边和右边内部的贡献加起来再加上左边对右边的贡献。

看一下操作：后面两种操作是平凡的单点修改，考虑第一种操作。手玩一下，发现如果操作的两个点属于同一个环，那么这个环会裂成两个；如果两个点不属于同一个环，那么环会合并在一起。分讨一下，可以得到，我们需要这样一个数据结构：

- 支持单点修改。
- 支持区间分裂合并。
- 支持查询上面提到的那一堆东西。

可以发现 FHQ Treap 完美满足这个条件，所以写一棵 FHQ Treap 维护即可。

最后放上我写的史山。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int P = 1e9 + 7;
mt19937 rnd(251251);
namespace Treap {
    struct Node {
        int ls, rs;
        int siz, pri, prt;
        ll f, h, sf, sh, tf, th, fh;
        ll ans;
        Node() {}
        Node(ll _f, ll _h) {
            f = _f; h = _h;
            sf = tf = f;
            sh = th = h;
            siz = 1; pri = rnd();
        }
    } f[100005];
    int tcn;
    void Pushup(Node &s, const Node &ls, const Node &rs) {
        s.sf = (ls.sf + rs.sf + s.f) % P;
        s.sh = (ls.sh + rs.sh + s.h) % P;
        s.tf = (ls.tf + rs.tf + rs.sf * (ls.siz + 1) % P + s.f * (ls.siz + 1) % P) % P;
        s.th = (ls.th + rs.th + rs.sh * (ls.siz + 1) % P + s.h * (ls.siz + 1) % P) % P;
        s.fh = (ls.fh + rs.fh + s.h * rs.sf % P + s.f * ls.sh % P + ls.sh * rs.sf % P) % P;
        s.siz = ls.siz + rs.siz + 1;
        s.ans = (s.sf * s.th % P - s.sh * s.tf % P + s.siz * s.fh % P + P) % P;
    }
    int NewNode(ll f, ll h) {
        int p = ++tcn;
        Treap::f[p] = Node(f, h);
        return p;
    }
    void Split(int p, int rk, int &x, int &y) {
        if (!p) {
            x = y = 0;
            return;
        }
        if (f[f[p].ls].siz + 1 <= rk) {
            x = p;
            Split(f[p].rs, rk - f[f[p].ls].siz - 1, f[p].rs, y);
        } else {
            y = p;
            Split(f[p].ls, rk, x, f[p].ls);
        }
        f[f[p].ls].prt = f[f[p].rs].prt = p;
        f[p].prt = 0;
        Pushup(f[p], f[f[p].ls], f[f[p].rs]);
    }
    int Merge(int x, int y) {
        if (!x || !y) return x | y;
        if (f[x].pri >= f[y].pri) {
            f[x].rs = Merge(f[x].rs, y);
            Pushup(f[x], f[f[x].ls], f[f[x].rs]);
            f[f[x].ls].prt = f[f[x].rs].prt = x;
            f[x].prt = 0;
            return x;
        } else {
            f[y].ls = Merge(x, f[y].ls);
            Pushup(f[y], f[f[y].ls], f[f[y].rs]);
            f[f[y].ls].prt = f[f[y].rs].prt = y;
            f[y].prt = 0;
            return y;
        }
    }
    int Rank(int p) {
        int rk = f[f[p].ls].siz + 1;
        while (p) {
            if (p == f[f[p].prt].rs) rk += f[f[f[p].prt].ls].siz + 1;
            p = f[p].prt;
        }
        return rk;
    }
    void ModifyF(int p, int i, ll w) {
        int x = 0, y = 0, z = 0;
        Split(p, i, x, z);
        Split(x, i - 1, x, y);
        f[y].f = f[y].sf = f[y].tf = w;
        Merge(Merge(x, y), z);
    }
    void ModifyH(int p, int i, ll w) {
        int x = 0, y = 0, z = 0;
        Split(p, i, x, z);
        Split(x, i - 1, x, y);
        f[y].h = f[y].sh = f[y].th = w;
        Merge(Merge(x, y), z);
    }
    int Find(int u) {
        return f[u].prt ? Find(f[u].prt) : u;
    }
}
using namespace Treap;
int n, m;
ll ans;
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        ll f, h;
        scanf("%lld%lld", &h, &f);
        if (i == 1) NewNode(f, h);
        else Merge(Find(1), NewNode(f, h));
    }
    ans = f[Find(1)].ans;
    scanf("%d", &m);
    while (m--) {
        int op, p, q;
        scanf("%d%d%d", &op, &p, &q);
        if (op == 1) {
            int x = Find(p), y = Find(q);
            if (x == y) {
                ans -= f[x].ans;
                int rp = Rank(p), rq = Rank(q);
                if (rp < rq) {
                    int a, b, c;
                    Split(x, rq - 1, b, c);
                    Split(b, rp, a, b);
                    int ac = Merge(a, c);
                    ans += f[ac].ans + f[b].ans;
                }
                else {
                    int a, b, c;
                    Split(x, rp, b, c);
                    Split(b, rq - 1, a, b);
                    int ac = Merge(a, c);
                    ans += f[ac].ans + f[b].ans;
                }
            }
            else {
                ans -= f[x].ans + f[y].ans;
                int rp = Rank(p), rq = Rank(q);
                int a, b, c, d;
                Split(x, rp, a, b);
                Split(y, rq - 1, c, d);
                int r = Merge(Merge(a, d), Merge(c, b));
                ans += f[r].ans;
            }
            
        }
        else if (op == 2) {
            ans -= f[Find(p)].ans;
            ModifyH(Find(p), Rank(p), q);
            ans += f[Find(p)].ans;
        }
        else {
            ans -= f[Find(p)].ans;
            ModifyF(Find(p), Rank(p), q);
            ans += f[Find(p)].ans;
        }
        ans = (ans % P + P) % P;
        printf("%lld\n", ans);
    }
    return 0;
}
```

---

## 作者：Moeebius (赞：1)

> 非常好码量题，使我的键盘冒火星子！
>
> 警告：下文大多数推导使用 0-index.

考虑一个大小为 $n$ 的环 $\mathrm{C}$。记 $H_i,F_i$ 为环上第 $i$ 个小动物的欢乐值和感动值，发现题目中的柿子可以进行如下转换：

$$
\begin{aligned}
\text{Val(C)} \\
=&\sum _{i=0} ^{n-1} H_i \sum _{j=1}^{n-1}F_{i+j\text{ mod }{n}}\cdot (n-j) \\
=&\sum _{i=0} ^{n-1} F_i \sum _{j=\red{0}}^{n-1}H_{i+j\text{ mod }{n}}\cdot j \\
=& \sum _{i=0} ^{n-1} F_i (\sum _{j=i}^{n-1} H_j (j-i)+\sum _{j=0} ^{i-1} H_j(n-i+j)) \\
=& \sum _{i=0} ^{n-1} F_i (-i\sum _{j=0} ^{n-1}H_j + \sum_{j=0}^{n-1}jH_j + n\sum_{j=0}^{i-1}H_j) \\
=& (\sum _{i=0} ^{n-1} F_i)\cdot(\sum _{i=0} ^{n-1} jH_j) - (\sum _{i=0} ^{n-1} iF_i)\cdot(\sum _{i=0} ^{n-1} H_j) + n\sum _{i=0}^{n-1} \sum _{j=0}^{i-1}F_iH_j
\end{aligned}
$$

发现我们只要维护 $\sum{H_i},\sum{iH_i}, \sum{F_i}, \sum{iF_i}, \sum_{i>j}{F_iH_j}$ 即可。合并是简单的。

---

考虑变换队形操作带来的影响。记点 $p$ 在环上是第 $\text{id}(p)$ 个点，假设通过 $x,y$ 变换队形，分 $3$ 类讨论：

$\text{Type A:}$

> $x,y$ 位于同一环中，且 $y$ 在 $x$ 右手方向。

![](https://cdn.luogu.com.cn/upload/image_hosting/pe8hgbu4.png?x-oss-process=image/resize,m_lfit,h_200)
![](https://cdn.luogu.com.cn/upload/image_hosting/a17dv04v.png?x-oss-process=image/resize,m_lfit,h_200)

$$\text{[change 1,4]}$$

相当于把环上 $(\text{id}(x),\text{id}(y))$ 之间的点拉出来新建一个环，环上剩下点成一个环。

$\text{Type B:}$

> $x,y$ 位于同一环中，且 $y$ 在 $x$ 左手方向。

![](https://cdn.luogu.com.cn/upload/image_hosting/pe8hgbu4.png?x-oss-process=image/resize,m_lfit,h_200)
![](https://cdn.luogu.com.cn/upload/image_hosting/1h8ksm5w.png?x-oss-process=image/resize,m_lfit,h_200)

$$\text{[change 4,1]}$$

相当于把环上 $[\text{id}(y),\text{id}(x)]$ 之间的点拉出来新建一个环，环上剩下点成一个环。


$\text{Type C:}$
> $x,y$ 位于两个环中。

![](https://cdn.luogu.com.cn/upload/image_hosting/m7tknn2u.png?x-oss-process=image/resize,m_lfit,h_120)
![](https://cdn.luogu.com.cn/upload/image_hosting/3wfwqfss.png?x-oss-process=image/resize,m_lfit,h_120)

$$\text{[change 1,6]}$$

相当于把两个环合并成一个，按照 $\blue{[0,\text{id}(x)]}\rightarrow \red{[\text{id}(y),n_y)} \rightarrow \red{[0, \text{id}(y))} \rightarrow \blue{(\text{id}(x), n_x)}$ 的顺序。

---

综上所述，我们需要一个支持维护区间信息，和快速分裂合并的数据结构，同时支持 $\text{findRoot}$ 和 $\text{rank}$ 操作。发现平衡树就很适合。

实现细节：

- 如果你写的是 FHQ-Treap，本题需要维护 `father`。
- 如果你写的是 Splay，大多数操作有着更优雅的实现（单点改单点 rank 都可以直接 splay 到根做）
- 注意 $\sum{iH_i}, \sum{iF_i}$ 合并时可能的下标变换。
- 注意区间的开闭。
- 注意 0-index 还是 1-index。
- 本题样例有一定强度，过了样例可能就过了（？）

---

Code:

```cpp
#include <bits/stdc++.h>

using namespace std;

#define il inline
#define fi first
#define se second
#define For(i, j, k) for (int i = (j); i <= (k); ++i)
#define ForDown(i, j, k) for (int i = (j); i >= (k); --i)

using ll = long long;
using uint = unsigned int;
using pii = pair<int, int>;

namespace {
constexpr ll MAXN = 1e5 + 5, mod = 1e9 + 7;

int cnt = 0;
mt19937 rnd(random_device{}());

struct Node {
  int fa, lc, rc;
  uint prio, sz;
  ll f, h, h1, h2, f1, f2, cross; // fi, hi, sigma hi, sigma i*hi, sigma fi, sigma i*fi, sigma [i>j] fi*hj 
  Node(ll _h = 0, ll _f = 0)
      : fa(0), lc(0), rc(0), prio(rnd()), sz(0), f(_f), h(_h), h1(0), h2(0),
        f1(0), f2(0), cross(0) {}
} T[MAXN];

#define Cmp(p, q) (T[p].prio > T[q].prio || T[p].prio == T[q].prio && (p) > (q))
#define lc(p) (T[p].lc)
#define rc(p) (T[p].rc)
#define fa(p) (T[p].fa)

il void pushUp(int p) {
  assert(p);
  (T[p].h1 = T[lc(p)].h1 + T[p].h + T[rc(p)].h1) %= mod;
  (T[p].f1 = T[lc(p)].f1 + T[p].f + T[rc(p)].f1) %= mod;
  (T[p].h2 = T[lc(p)].h2 + T[p].h * T[lc(p)].sz + T[rc(p)].h2 +
             T[rc(p)].h1 * (T[lc(p)].sz + 1)) %= mod; // 注意下标变换
  (T[p].f2 = T[lc(p)].f2 + T[p].f * T[lc(p)].sz + T[rc(p)].f2 +
             T[rc(p)].f1 * (T[lc(p)].sz + 1)) %= mod;
  (T[p].cross = T[lc(p)].cross + T[rc(p)].cross + T[lc(p)].h1 * T[rc(p)].f1 +
                T[p].h * T[rc(p)].f1 + T[p].f * T[lc(p)].h1) %= mod;
  T[p].sz = T[lc(p)].sz + T[rc(p)].sz + 1;
}
il void upd(int p, int q, int ch) {
  if (fa(q))
    ((lc(fa(q)) == q) ? lc(fa(q)) : rc(fa(q))) = 0;
  int &o = ((!ch) ? lc(p) : rc(p));
  fa(o) = 0, o = q, fa(q) = p;
}
il int merge(int p, int q) {
  if (!p || !q)
    return p | q;
  if (Cmp(p, q)) {
    int u = merge(rc(p), q);
    return upd(p, u, 1), pushUp(p), p;
  } else {
    int u = merge(p, lc(q));
    return upd(q, u, 0), pushUp(q), q;
  }
}
il pii split(int p, int k) {
  if (!p)
    return {};
  else if (T[lc(p)].sz >= k) {
    auto [x, y] = split(lc(p), k);
    upd(p, y, 0), pushUp(p);
    return {x, p};
  } else if (T[lc(p)].sz + 1 == k) {
    int y = rc(p);
    upd(p, 0, 1), pushUp(p);
    return {p, y};
  } else {
    auto [x, y] = split(rc(p), k - T[lc(p)].sz - 1);
    upd(p, x, 1), pushUp(p);
    return {p, y};
  }
}
il void updH(int p, ll nh) {
  T[p].h = nh;
  while (p)
    pushUp(p), p = fa(p);
}
il void updF(int p, ll nf) {
  T[p].f = nf;
  while (p)
    pushUp(p), p = fa(p);
}
il int find(int p) { // 找根
  while (fa(p))
    p = fa(p);
  return p;
}
il uint rank(int p) { // 单点 rank
  uint ans = T[lc(p)].sz + 1;
  while (fa(p)) {
    int u = fa(p);
    if (rc(u) == p)
      ans += T[lc(u)].sz + 1;
    p = u;
  }
  return ans;
}
il int newNode(pii val) { return T[++cnt] = {val.fi, val.se}, cnt; }
il void build(pii *st, pii *ed) { // 线性建树（即笛卡尔树建树方法）
  int n = ed - st;
  stack<int> cur;
  for (pii *i = st; i != ed; i++) {
    int p = newNode(*i), pre = -1;
    while (!cur.empty() && Cmp(p, cur.top()))
      pre = cur.top(), cur.pop();
    if (~pre)
      upd(p, pre, 0);
    if (!cur.empty())
      upd(cur.top(), p, 1);
    cur.emplace(p);
  }
  while (cur.size() > 1)
    cur.pop();
  assert(cur.size() == 1);
  function<void(int)> dfs = [&](int x) {
    if (!x)
      return;
    dfs(lc(x)), dfs(rc(x));
    pushUp(x);
  };
  dfs(cur.top());
  // debug(cur.top());
}
il ll getVal(int p) { // 求答案
  return (T[p].f1 * T[p].h2 % mod - T[p].f2 * T[p].h1 % mod +
          T[p].cross * T[p].sz % mod + mod) %
         mod;
}

int n, q;
pii a[MAXN];
ll Ans = 0;

void Main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n;
  For(i, 1, n) { cin >> a[i].fi >> a[i].se; }
  build(a + 1, a + 1 + n), Ans = getVal(find(1));
  cin >> q;
  while (q--) {
    int op, x, y;
    cin >> op >> x >> y;
    switch (op) {
    case 1: {
      int p = find(x), q = find(y), rk1 = rank(x), rk2 = rank(y);
      if (p == q) {
        Ans -= getVal(p);
        if (rk1 < rk2) { // Type A
          auto [o1, o2] = split(p, rk1);
          auto [o3, o4] = split(o2, rk2 - rk1 - 1);
          int o5 = merge(o1, o4);
          Ans += getVal(o5) + getVal(o3);
        } else { // Type B
          auto [o1, o2] = split(p, rk2 - 1);
          auto [o3, o4] = split(o2, rk1 - rk2 + 1);
          int o5 = merge(o1, o4);
          Ans += getVal(o5) + getVal(o3);
        }
      } else { // Type C
        Ans -= getVal(p) + getVal(q);
        auto [o1, o2] = split(p, rk1);
        auto [o3, o4] = split(q, rk2 - 1);
        int o5 = merge(merge(o1, o4), merge(o3, o2));
        Ans += getVal(o5);
      }
      break;
    }
    case 2:
      Ans -= getVal(find(x));
      updH(x, y);
      Ans += getVal(find(x));
      break;
    case 3:
      Ans -= getVal(find(x));
      updF(x, y);
      Ans += getVal(find(x));
      break;
    }
    Ans = (Ans % mod + mod) % mod;
    cout << Ans << '\n';
  }
}
} // namespace
```

---


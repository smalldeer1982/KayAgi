# [HNOI2012] 与非

## 题目背景

如果你能提供题面或者题意简述，请直接在讨论区发帖，感谢你的贡献。


## 题目描述

NAND（与非）是一种二元逻辑运算，其运算结果为真当且仅当两个输入的布尔值不全为真。NAND运算的真值表如下（1表示真，0表示假）:

 ![](https://cdn.luogu.com.cn/upload/pic/7851.png) 

两个非负整数的NAND是指将它们表示成二进制数，再在对应的二进制位进行NAND运算。由于两个二进制数的长度可能不等，因此一般约定一个最高位K，使得两个数的二进制表示都不 超过K位，不足K位的在高位补零。给定N个非负整数A1,A2......AN和约定位数K，利用NAND运算与括号，每个数可以使用任意次，请你求出范围[L,R]内可以被计算出的数有多少个。


## 说明/提示

样例1中，(3 NAND 4) NAND (3 NAND 5) = 1，5 NAND 5 = 2，3和4直接可得。


## 样例 #1

### 输入

```
3  3 1 4
3  4 5```

### 输出

```
4```

# 题解

## 作者：Salamander (赞：21)

与非($nand$)是非常强大的位运算，可以表示出其他所有的位运算：
	
$not\ A=A\ nand\ A$
	
$A\ and\ B=not\ (A\ nand\ B)$
	
$A\ or\ B=(not\ A)\ nand\ (not\ B)$
	
$A\ xor\ B=(A\ and\ not\ B)\ or\ (not\ A\ and\ B)$
	
所以相当于是这$n$个数之间可以做任何位运算。
	
然后我们考虑一下位与位之间的限制。如果这$n$个数中每个数的第$i$位和第$j$位都相同，那么这$n$个数无论怎么运算，最后得到的答案中第$i$位和第$j$位一定相同。我们在数位dp的时候从高位到低位考虑，确定了当前位后把必须和它相同的位也标记一下，就可以求出$[1,n]$中能运算出的数的个数。
	
$~$
	
为什么这样是对的?其他没有互相限制的位置上就一定可以任意取$0$或$1$了吗?
	
$~$
	
类似于线性基的思想，我们可以构造这样一种方案：通过一些运算把某一位上只留下一个$1$，其他的数在这一位上都为$0$，最后用它们或起来就可以构造出任意一个数。对于第$i$位，假设没有限制，那么我们把这一位上为$0$的数全都取反，然后全部与起来，得到的数这一位上肯定是$1$；同时由于这一位没有限制，所以不会有其他位置上再出现一个$1$，因为如果还出现$1$就表每一个数中那一位与第$i$位都相等，于是就产生了限制，矛盾。所以对于没有限制的位，我们一定可以构造出一个只有这一位上为$1$的数。对于几个必须相等的位，这样可以构造出一个只有这几位为$1$的数。
	
于是我们可以把$n$个数构造出一个类似这样的东西，假设最左边第$1$位，那么下面这个东西中间的限制就是第$3$位和第$5$位必须相等，第$8$位和第$9$位必须相等。
```
10000000
01000000
00101000
00010000
00000100
00000011
```
	
利用这样的东西，我们通过他们之间的或运算，就可以构造出原来$n$个数所能构造出的所有数，所以数位dp就可以直接做了。首先暴力求出哪些位必须相等。
	
复杂度应该是$O(nk^2)$。

```cpp
#include<vector>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

#define For(i,_beg,_end) for(int i=(_beg),i##end=(_end);i<=i##end;++i)
#define Rep(i,_beg,_end) for(int i=(_beg),i##end=(_end);i>=i##end;--i)

template<typename T>T Max(const T &x,const T &y){return x<y?y:x;}
template<typename T>T Min(const T &x,const T &y){return x<y?x:y;}
template<typename T>int chkmax(T &x,const T &y){return x<y?(x=y,1):0;}
template<typename T>int chkmin(T &x,const T &y){return x>y?(x=y,1):0;}
template<typename T>void read(T &x){
	T f=1;char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
	for(x=0;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';
	x*=f;
}

typedef long long LL;
const int maxn=1010;
int n,k,c[65],tmp[65];
LL a[maxn],L,R;
vector<int>pos[65];

LL Dfs(LL n,int x,bool lim){
	if(x<0)return 1;
	if(!lim){
		int cnt=0;
		memcpy(tmp,c,sizeof c);
		Rep(i,x,0) if(tmp[i]==-1){
			cnt++;
			For(j,0,pos[i].size()-1) tmp[pos[i][j]]=1;
		}
		return 1LL<<cnt;
	}
	LL res=0;
	if(c[x]==-1){
		For(i,0,(n>>x)&1){
			For(j,0,pos[x].size()-1) c[pos[x][j]]=i;
			res+=Dfs(n,x-1,lim&(i==((n>>x)&1)));
		}
		For(j,0,pos[x].size()-1) c[pos[x][j]]=-1;
		return res;
	}
	else{
		if(c[x]&&lim&&!((n>>x)&1))return 0;
		return Dfs(n,x-1,lim&(c[x]==((n>>x)&1)));
	}
}
LL Solve(LL x){
	memset(c,-1,sizeof c);
	if(x<0)return 0;
	return Dfs(x,k-1,(x>>k)?0:1);
}

int main(){
	read(n);read(k);read(L);read(R);
	For(i,1,n) read(a[i]);
	Rep(i,k-1,1) Rep(j,i-1,0){
		bool flag=true;
		For(p,1,n) if(((a[p]>>i)&1)^((a[p]>>j)&1)){
			flag=false;
			break;
		}
		if(flag) pos[i].push_back(j);
	}
	printf("%lld\n",Solve(R)-Solve(L-1));
	return 0;
}
```

---

## 作者：Kewth (赞：17)

这题不要用线性基，却要用到线性基的思想，  
与非可以转换为与和非和或。  
将 n 个数用 log(maxvalue) 个数表示，  
且用这 log 个数部分按位或可以得到原数列部分与非的所有结果。  
其中第 k 个数满足二进制第 k 位为 1 ，二进制大于 k 位都为 0 。  
很像线性基，因此接下来我就叫它线性基了。

构造方式是通过按位与和非，  
x 对线性基第 k 位的贡献是 &= x (x 第 k 位为 1) 或者 &= ~x （反之），

举例：

	00101
	01011
	01111

压缩成（按位与线性基？）：

	10000
	01010
	00100
	00000
	00001

然后求 1 ~ r 内的方案数，用数位 DP 的思路去扫一遍线性基。  
若 r 当前这位为 1 ，考虑结果的这一位，  
若为 0 ，则后面不再有限制，随便选，方案是 2^x ；
（ x 是后面非零线性基的数量）
若为 1 ，则必须选当前线性基这一位，后面继续限制，继续扫即可。

不得不说这题的代码太精练了，而且有许多需要注意的细节。

具体的细节等在代码的注释里：

```cpp
#include <bits/stdc++.h>

typedef long long lolong;
const int maxn = 10050, maxm = 62;
lolong a[maxn];
lolong Ji[maxm];
int suf_sum[maxm];

void num2(lolong x, int m) {
	/* assert((x >> m) == 0); */
	for(int k=m-1; k>=0; k--)
		std::clog << (x >> k & 1);
	std::clog << std::endl;
}

lolong query(lolong x, int m) { // 1 到 x 的方案数
	if(x < 0) return -1; // 额外去除 0 的贡献
	/* num2(x, m); */
	if(x > (1ll << m) - 1)
		return (1ll << suf_sum[m - 1]) - 1;
	lolong res = 0, used = 0;
	for(int k=m-1; k>=0; k--)
		if(x >> k & 1) {
			// 当前为 0 ，后面随意
			if(k and not (used >> k & 1))
				res += (1ll << suf_sum[k - 1]) - 1; // 不包括 0
			// 当前为 1 ，必须用 Ji[k]
			if(Ji[k]) {
				used |= Ji[k];
				if(used > x) break;
				res ++; // 只用 Ji[k] 和 used
			} else if(not(used >> k & 1))
				break; // 当前只能为 0 ，接下来不用考虑
			/* std::clog << res << std::endl; */
		}
	return res;
}

int main() {
	int n, m;
	lolong l, r;
	std::cin >> n >> m >> l >> r;
	for(int i=0; i<n; i++)
		std::cin >> a[i];
	lolong orsum = 0;
	for(int k=m-1; k>=0; k--)
		if(not (orsum >> k & 1)) {
			lolong &now = Ji[k];
			now = (1ll << m) - 1;
			for(int i=0; i<n; i++)
				if(a[i] >> k & 1)
					now &= a[i];
				else
					now &= ~ a[i];
			orsum |= now;
			assert(now >> k & 1);
			suf_sum[k] = 1;
		}
	for(int k=1; k<m; k++)
		suf_sum[k] += suf_sum[k - 1];
	/* for(int k=m-1; k>=0; k--) */
	/* 	num2(Ji[k], m); */
	/* std::clog << std::endl; */
	std::cout << query(r, m) - query(l - 1, m) << std::endl;
}
```



---

## 作者：kczno1 (赞：6)


a nand b=not (a and b)

由于每个数可以用任意次

取a=b=a，有a nand a=not (a and a)=not a

所以我们能not了


not (a nand b)=a and b

所以我们能and了


可以发现 nand 和 用and和not两个操作 是等价的。


于是可以发现一个性质

对于第i位和第j位，如果所有数a的第i位和第j位相同，那么最后nand出的数的第i位和第j位相同。

对于所有这样的位的集合，我们要么让里面所有位都为1，要么让他们都为0。


所以就可以从高到低枚举每一位做了。

具体的

如果枚举到的位为0 则不管

如果为1

如果我们不能选这一位 接下来就可以任意选而不会超也不会重复 所以方案数+=1<<num (num为接下来的集合的个数) return

如果能选  要么不选，那么+=1<<num-1 要么将集合中的数全部选了，再接着枚举后面

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
const int N=1005,K=60;
int n,k,i,j;
ll a[N];
ll lk[K],now,full;
int num[K];

ll qiu(ll x)
{
    if(x>=full) return 1LL<<num[k-1];
    ll ans=0;
    for(i=k-1;x>=0&&i>=0;--i)
    {
        if((x>>i)&1) 
        {
            if(lk[i]) { ans+=1LL<<num[i]-1;x-=lk[i]; }
            else {ans+=1LL<<num[i];break;}
        }
    }
    ans+=x==0;
    return ans;
}

int main()
{ freopen("1.in","r",stdin);freopen("1.out","w",stdout);
    ll l,r;
    scanf("%d%d%lld%lld",&n,&k,&l,&r);full=(1LL<<k)-1;
    for(i=1;i<=n;++i) scanf("%lld",a+i);
    ll have=0;
    for(i=k-1;i>=0;--i) 
    if(!((have>>i)&1)) 
    { 
       ll now=full;
       for(j=1;j<=n;++j)
       if((a[j]>>i)&1) now&=a[j];
       else now&=~a[j];
       lk[i]=now;num[i]=1;
       have|=now;
    }
    for(i=1;i<k;++i) num[i]+=num[i-1];
    printf("%lld\n",qiu(r)-qiu(l-1));
}
```

---

## 作者：zzw4257 (赞：2)

### 题意
>定义与非(析舍)操作为$A↑B=⌐(A∧B)=⌐A∨⌐B$
给出$n$个$<2^k$数$\{a_i\}$求其在$[l,r]$区间用与非任意运算的到的值的个数
### Solution
首先不常规的一点，我们要知道与非的内涵

实际上轻易发现$A↑A=⌐A,⌐(A↑B)=A∧B,(A∧⌐B)=A∨B$

我们可以用与非代替所有位运算操作

因此**只要不是原本$n$个数都相同的位置，其余数可以随意选取**

因此考虑按照位置必须相同为联通关系，分成若干($m$个)联通块，可以用类并查集(或者说类线性基)来解决

就是用$p_i$作为与第$i$位相同位数的二进制状态/与第$i$位相同位数的代表

(两种理解分别对应线性基与并查集)，

这东西要"离散化"(即只被表示一次)
然后对于计数就是数位$dp$,我们每次就尝试或上一个联通块的所有点(荣辱一体)，成功就加上$2^{m-size}$

```cpp
#include<bits/stdc++.h>
#define re register
#define N 1001
using namespace std;
typedef long long ll;
int n,k,num[61];
ll l,r,a[N],p[61];
inline ll Query(re ll x){
	re int i;re ll res=0;if(x>=((1ll<<k)-1))return 1ll<<num[k-1];
	for(i=k-1;(~i)&&x>=0;--i)if((x>>i)&1){if(p[i])res+=1ll<<num[i]-1,x-=p[i];else {res+=1ll<<num[i];break;}}
	res+=(x==0);
	return res;
}
int main(void){
	re int i,j;re ll x,sta=0;scanf("%d%d%lld%lld",&n,&k,&l,&r);
	for(i=1;i<=n;++i)scanf("%lld",a+i);
	for(i=k-1;~i;--i)if(!((sta>>i)&1)){
		x=(1ll<<k)-1;
		for(j=1;j<=n;++j)((a[j]>>i)&1)?x&=a[j]:x&=(~a[j]);
		p[i]=x;num[i]=1;sta|=x;
	}
	for(i=1;i<k;++i)num[i]+=num[i-1];
	printf("%lld\n",Query(r)-Query(l-1));
	return 0;
}
```

---


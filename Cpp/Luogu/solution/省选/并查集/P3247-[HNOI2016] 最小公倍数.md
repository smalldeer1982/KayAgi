# [HNOI2016] 最小公倍数

## 题目描述

给定一张 $N$ 个顶点 $M$ 条边的无向图(顶点编号为 $1,2,\ldots,n$)，每条边上带有权值。所有权值都可以分解成 $2^a\times 3^b$ 的形式。

现在有 $q$ 个询问，每次询问给定四个参数 $u,v,a$ 和 $b$，请你求出是否存在一条顶点 $u$ 到 $v$ 之间的路径，使得路径依次经过的边上的权值的最小公倍数为 $2^a\times 3^b$。

注意：路径可以不是简单路径。

下面是一些可能有用的定义，如果与其它地方定义不同，在本题中以下面的定义为准：  

最小公倍数： $ k $ 个数 $ a_1 , a_2, \ldots, a_k $ 的最小公倍数是能被每个 $a_i$ 整除的最小正整数。

路径：顶点序列 $ P \colon P_1,P_2,\ldots,P_k $ 是一条路径，当且仅当 $k \geq 2$，且对于任意 $ 1 \leq i < k $ ，节点 $ P_i $ 和 $ P_{i+1} $ 之间都有边相连。 

简单路径：如果路径 $ P \colon P_1,P_2,\ldots,P_k $ 中，对于任意 $ 1 \leq s \neq t \leq k $ 都有 $ P_s \neq P_t $ ，那么称 $P$ 为简单路径。


## 说明/提示

$1\le n,q\le 5\times 10^4$，$1\leq m\leq 10^5$，$0\leq a,b\leq 10^9$。

## 样例 #1

### 输入

```
4 5
1 2 1 3
1 3 1 2
1 4 2 1
2 4 3 2
3 4 2 2
5
1 4 3 3
4 2 2 3
1 3 2 2
2 3 2 2
1 3 4 4```

### 输出

```
Yes 
Yes 
Yes 
No 
No```

# 题解

## 作者：jiangly (赞：48)

#### 题意

给定一张 $n$ 个点 $m$ 条边的无向图 ($1\le n\le 5\cdot10^4$, $1\le m\le 10^5$)，每条边有两个权值 $a_e$, $b_e$。有 $q$ 次询问，每次询问两个点之间是否存在一条（不一定简单的）路径使得路径上两种边权的最大值分别等于给定值。

#### 题解

容易发现有用的边满足两种权值都不超过询问，把有用的边加入之后检查两个点是否在同一个连通块以及两种权值的最大值是否分别等于询问的值即可。

先将边按照 $a_e$ 排序并分块。把每个询问放到最后一个满足下列条件的块：前面块的 $a_e$ 都不超过询问的 $a$。这样对每个询问有用的边就只有前面的块和它所在的块。

依次处理每个块，由于前面块的 $a_e$ 都不超过询问的 $a$，所以只需要考虑 $b$。把前面块的所有边和当前块的询问都按照 $b$ 排序，处理每个询问的时候把不超过询问的 $b$ 的边都加入即可。用路径压缩和启发式合并的并查集维护，每次操作时间复杂度 $O(\alpha(n))$。

对于块内的边，暴力将所有有用的边加入，进行一次 BFS 即可回答询问。

设块大小为 $B$，时间复杂度为 $O((qB+\frac{m^2}B)\alpha(n))$。取 $B=O(\frac{m}{\sqrt q})$，则时间复杂度为 $O(m\sqrt q\alpha(n))$。

#### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 50'000, M = 100'000, Q = 50'000;
struct Edge {
    int u, v, a, b;
};
struct Query {
    int u, v, a, b, id;
};
int fa[N], mxa[N], mxb[N];
Edge edge[M];
vector<Query> query[M];
vector<tuple<int, int, int>> e[N];
int id[N], stk[N], que[N];
bool ans[Q], vis[N], used[N];
int find(int x) {
    while (fa[x] >= 0 && fa[fa[x]] >= 0)
        x = fa[x] = fa[fa[x]];
    return fa[x] >= 0 ? fa[x] : x;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, m, q;
    cin >> n >> m;
    memset(id, -1, n * sizeof(int));
    for (int i = 0; i < m; ++i) {
        cin >> edge[i].u >> edge[i].v >> edge[i].a >> edge[i].b;
        --edge[i].u;
        --edge[i].v;
    }
    sort(edge, edge + m, [&](const Edge &lhs, const Edge &rhs) {
        return lhs.a < rhs.a;
    });
    cin >> q;
    int sz = 1.5 * m / sqrt(q);
    int blocks = (m + sz - 1) / sz;
    for (int i = 0; i < q; ++i) {
        int u, v, a, b;
        cin >> u >> v >> a >> b;
        --u;
        --v;
        int j = 0;
        while (j + 1 < blocks && edge[sz * j + sz - 1].a <= a)
            ++j;
        query[j].push_back(Query{u, v, a, b, i});
    }
    for (int bl = 0; bl < blocks; ++bl) {
        memset(fa, -1, n * sizeof(int));
        memset(mxa, -1, n * sizeof(int));
        memset(mxb, -1, n * sizeof(int));
        int i = 0;
        sort(edge, edge + sz * bl, [&](const auto &lhs, const auto &rhs) {
            return lhs.b < rhs.b;
        });
        sort(query[bl].begin(), query[bl].end(), [&](const auto &lhs, const auto &rhs) {
            return lhs.b < rhs.b;
        });
        for (auto &&q : query[bl]) {
            while (i < sz * bl && edge[i].b <= q.b) {
                int u = find(edge[i].u);
                int v = find(edge[i].v);
                if (u != v) {
                    if (fa[u] > fa[v])
                        swap(u, v);
                    fa[u] += fa[v];
                    mxa[u] = max(mxa[u], mxa[v]);
                    mxb[u] = max(mxb[u], mxb[v]);
                    fa[v] = u;
                }
                mxa[u] = max(mxa[u], edge[i].a);
                mxb[u] = max(mxb[u], edge[i].b);
                ++i;
            }
            int stkTop = 0;
            int u = find(q.u);
            used[u] = true;
            stk[stkTop++] = u;
            int v = find(q.v);
            if (u != v) {
                used[v] = true;
                stk[stkTop++] = v;
            }
            for (int j = sz * bl; j < m && j < sz * (bl + 1); ++j) {
                if (edge[j].a <= q.a && edge[j].b <= q.b) {
                    int u = find(edge[j].u);
                    int v = find(edge[j].v);
                    if (!used[u]) {
                        used[u] = true;
                        stk[stkTop++] = u;
                    }
                    if (!used[v]) {
                        used[v] = true;
                        stk[stkTop++] = v;
                    }
                    e[u].emplace_back(v, edge[j].a, edge[j].b);
                    e[v].emplace_back(u, edge[j].a, edge[j].b);
                }
            }
            int queL = 0, queR = 0;
            que[queR++] = u;
            vis[u] = true;
            int ma = -1, mb = -1;
            while (queL < queR) {
                int u = que[queL++];
                ma = max(ma, mxa[u]);
                mb = max(mb, mxb[u]);
                for (auto &&ed : e[u]) {
                    int v, a, b;
                    tie(v, a, b) = ed;
                    ma = max(ma, a);
                    mb = max(mb, b);
                    if (!vis[v]) {
                        vis[v] = true;
                        que[queR++] = v;
                    }
                }
            }
            ans[q.id] = vis[v] && ma == q.a && mb == q.b;
            for (int j = 0; j < stkTop; ++j) {
                int u = stk[j];
                used[u] = vis[u] = false;
                e[u].clear();
            }
        }
    }
    for (int i = 0; i < q; ++i)
        cout << (ans[i] ? "Yes" : "No") << "\n";
    return 0;
}
```



---

## 作者：Rainybunny (赞：18)

# 题目

&emsp;&emsp;[luogu](https://www.luogu.com.cn/problem/P3247).

# 题解

&emsp;&emsp;玄学离线 + 秩优化并查集。  

&emsp;&emsp;很有收获的一道题qwq。  

&emsp;&emsp;根据 $\operatorname{lcm}$ 的定义，题意可以转化为每条边有边权 $(a_e,b_e)$，给定询问 $(u,v,a,b)$，问是否存在一条从 $u$ 到 $v$ 的路径（可以非简单路径），使得 $\max\{a_e\}=a$ 且 $\max\{b_e\}=b$。

&emsp;&emsp;不难想到离线：按特定的顺序加入图上的边，并在过程中求解答案。  

&emsp;&emsp;对于本题的某组询问 $(u,v,a,b)$，我们只需要**在保证图上所有 $a_e\le a,b_e\le b$** 的情况下，用并查集维护连通性和联通块最大权值即可。

&emsp;&emsp;接下来是重头戏：离线的方式。

- 第一步，边以 $a_e$ 为键值排序，询问以 $b$ 为键值排序。  

- 第二步，将边分块并枚举块，设当前块 $a_e$ 的范围为 $[a_l,a_r)$，则取出所有 $a\in[a_l,a_r)$ 的询问，我们将解决这些询问。

- 第三步，考虑到分块枚举之后，当前块之前的 $a_e$ 一定有 $a_e\le a$，那么这些边的 $a_e$ 其实已经无关紧要了。重新把这些边按 $b_e$ 排序。

- 第四步，枚举每个符合要求的询问，我们必须保证上文的条件。于是，依次加入当前块之前的边，直到 $b_e>b$。接着，暴力加入当前块内所有 $a_e\le a,b_e\le b$ 边。利用并查集求出当前答案，最后**回退到加入当前块的边之前的状态**，而并非直接清空（询问的 $b$ 有序）。

    &emsp;&emsp;回退操作，只需要用秩优化并查集再加一个栈记录修改即可。

    &emsp;&emsp;设块的大小为 $k$，则复杂度 $\Theta(km\log_2m+qk\log_2k)$（可能有误qwq，欢迎指正。

    &emsp;&emsp;~~翻一翻题解发现，~~ 当 $k=\sqrt{m\log_2n}$ 时取得复杂度平衡。

## 代码

```cpp
#include <cmath>
#include <cstdio>
#include <algorithm>

#define aiskey( type ) []( const type x, const type y ) { return x.a ^ y.a ? x.a < y.a : x.b < y.b; }
#define biskey( type ) []( const type x, const type y ) { return x.b ^ y.b ? x.b < y.b : x.a < y.a; } 

inline int rint () {
	int x = 0; char s = getchar ();
	for ( ; s < '0' || '9' < s; s = getchar () );
	for ( ; '0' <= s && s <= '9'; s = getchar () ) x = x * 10 + ( s ^ '0' );
	return x;
}

template<typename Tp>
inline void wint ( Tp x ) {
	if ( x < 0 ) putchar ( '-' ), x = ~ x + 1;
	if ( 9 < x ) wint ( x / 10 );
	putchar ( x % 10 ^ '0' );
}

const int MAXN = 5e4, MAXM = 1e5;
int n, m, q, ans[MAXN + 5];

inline bool chkmax ( int& a, const int b ) { return a < b ? a = b, true : false; }

struct Edge {
	int u, v, a, b;
	inline void read () { u = rint (), v = rint (), a = rint (), b = rint (); }
} eset[MAXM + 5];

struct Query {
	int u, v, a, b, id;
	inline void read ( const int i ) { u = rint (), v = rint (), a = rint (), b = rint (), id = i; }
} qry[MAXM + 5], now[MAXM + 5];

struct DSU {
	int fa[MAXN + 5], mxa[MAXN + 5], mxb[MAXN + 5], rnk[MAXN + 5];
	int rcnt, ru[MAXN + 5], rv[MAXN + 5], ra[MAXN + 5], rb[MAXN + 5], rr[MAXN + 5];
	inline void clear ( const int n ) {
		for ( int i = 1; i <= n; ++ i ) {
			fa[i] = i, rnk[i] = 1;
			mxa[i] = mxb[i] = -1;
		}
	}
	inline int find ( int x ) { for ( ; x ^ fa[x]; x = fa[x] ); return x; }
	inline bool unite ( const int x, const int y, const int a, const int b ) {
		int u = find ( x ), v = find ( y );
		if ( rnk[v] > rnk[u] ) u ^= v ^= u ^= v;
		++ rcnt;
		ru[rcnt] = u, rv[rcnt] = v, ra[rcnt] = mxa[u], rb[rcnt] = mxb[u], rr[rcnt] = rnk[u];
		if ( u ^ v ) {
			fa[v] = u, rnk[u] += rnk[v];
			chkmax ( mxa[u], mxa[v] ), chkmax ( mxb[u], mxb[v] );
		}
		chkmax ( mxa[u], a ), chkmax ( mxb[u], b );
		return u ^ v;
	}
	inline void regress () {
		for ( int& i = rcnt; i; -- i ) {
			fa[rv[i]] = rv[i];
			mxa[ru[i]] = ra[i], mxb[ru[i]] = rb[i], rnk[ru[i]] = rr[i];
		}
	}
} dsu;

int main () {
	n = rint (), m = rint ();
	for ( int i = 1; i <= m; ++ i ) eset[i].read ();
	q = rint ();
	for ( int i = 1; i <= q; ++ i ) qry[i].read ( i );
	std :: sort ( eset + 1, eset + m + 1, aiskey ( Edge ) );
	std :: sort ( qry + 1, qry + q + 1, biskey ( Query ) );
	int blk = sqrt ( m * log2 ( n ) );
	for ( int i = 1; i <= m; i += blk ) {
		dsu.clear ( n );
		int qcnt = 0;
		for ( int j = 1; j <= q; ++ j ) {
			if ( eset[i].a <= qry[j].a && ( i + blk > m || qry[j].a < eset[i + blk].a ) ) {
				now[++ qcnt] = qry[j];
			}
		}
		if ( ! qcnt ) continue;
		std :: sort ( eset + 1, eset + i, biskey ( Edge ) );
		for ( int j = 1, k = 1; j <= qcnt; ++ j ) {
			for ( ; k < i && eset[k].b <= now[j].b; ++ k ) {
				dsu.unite ( eset[k].u, eset[k].v, eset[k].a, eset[k].b );
			}
			dsu.rcnt = 0;
			for ( int t = i; t < i + blk && t <= m; ++ t ) {
				if ( eset[t].a <= now[j].a && eset[t].b <= now[j].b ) {
					dsu.unite ( eset[t].u, eset[t].v, eset[t].a, eset[t].b );
				}
			}
			int u = dsu.find ( now[j].u ), v = dsu.find ( now[j].v );
			ans[now[j].id] = u == v && dsu.mxa[u] == now[j].a && dsu.mxb[u] == now[j].b;
			dsu.regress ();
		}
	}
	for ( int i = 1; i <= q; ++ i ) puts ( ans[i] ? "Yes" : "No" );
	return 0;
}
```



---

## 作者：Kelin (赞：15)

## [题意](https://blog.csdn.net/BeNoble_/article/details/79777757)

给你一张图,每条边有两个权值$a,b$

每次询问是否存在一个$u\to v$的路径,满足$max\{a\}=A,max\{b\}=B$

---

## 写在前面

对于这种有两种限制的题目

一般的套路就是条件按照第一种权值为关键字排序,询问按照第二种关键字排序

然后给条件分块,然后对于一个块只把第一关键字符合条件的询问放进去

在把当前块前面的点按照第二关键字排序

这样当前块前面的点都是符合当前询问点对于第一关建字条件的

而且第二关键字都是单调的,所以就可以$two-pointer$扫一下

然后对于每个询问,暴力处理一下当前块的贡献

---

## 题解

考虑这道题,可以看出只有边权$a\le A,b\le B$的边才有用

一个简单的想法就是把所有满足条件的边加进去,然后用并查集判断两点是否联通,并且联通块内最大值是否合法

根据上面说的我们可以把边按照$a$从小到大排序,询问按照$b$从小到大排序

对于一个块$[i,i+Size]$我们把询问的$A$在$[val_a[i],val_a[i+Size])$之间的询问放进去

然后把$[1,i)$的边按照$b$从小到大排序,$two-pointer$边扫边加边(用并查集维护连通性和最大值)

对于一个询问暴力把$[i,i+Size)$内满足$val_a\le A,val_b\le B$的边加进去

然后用并查集判断是否合法

处理完一个询问后再暴力把这些边删掉

所以并查集不能路径压缩,而且还要用一个桶子把这些边都存下(存联通块合并前的状态)

这种写法当$Size=\sqrt{m\log n}$时最优~~手玩出来的~~

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
const int N=1e5+5;
typedef int arr[N];
struct eg{
    int u,v,a,b,k;
    inline void in(){sd(u),sd(v),sd(a),sd(b);}
}a[N],b[N],c[N],d[N];
int n,m,q,Top;arr fa,sz,Am,Bm,ans;
inline bool cpa(const eg a,const eg b){return a.a==b.a?a.b<b.b:a.a<b.a;}
inline bool cpb(const eg a,const eg b){return a.b==b.b?a.a<b.a:a.b<b.b;}
int gf(int x){return fa[x]==x?x:gf(fa[x]);}
inline void merge(int u,int v,int a,int b){
    u=gf(u),v=gf(v);if(sz[u]>sz[v])swap(u,v);
    d[++Top]={u,v,Am[v],Bm[v],sz[v]};
    if(u^v)fa[u]=v,sz[v]+=sz[u],
        cmax(Am[v],Am[u]),cmax(Bm[v],Bm[u]);
    cmax(Am[v],a),cmax(Bm[v],b);
}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    sd(n),sd(m);
    fp(i,1,m)a[i].in();
    sd(q);
    fp(i,1,q)b[i].in(),b[i].k=i;
    sort(a+1,a+m+1,cpa);sort(b+1,b+q+1,cpb);
    register int Sz=sqrt(m*log2(n)),i,j,k,l;
    for(i=1;i<=m;i+=Sz){
        fp(j,1,n)fa[j]=j,Am[j]=Bm[j]=-1,sz[j]=1;
        int Sum=0;
        fp(j,1,q)if(a[i].a<=b[j].a&&
            (b[j].a<a[i+Sz].a||i+Sz>m))c[++Sum]=b[j];
        if(!Sum)continue;if(i^1)sort(a+1,a+i,cpb);
        for(j=k=1;j<=Sum;++j){
            for(;k<i&&a[k].b<=c[j].b;++k)
                merge(a[k].u,a[k].v,a[k].a,a[k].b);
            Top=0;
            for(l=i;l<i+Sz&&l<=m;++l)
                if(a[l].a<=c[j].a&&a[l].b<=c[j].b)
                    merge(a[l].u,a[l].v,a[l].a,a[l].b);
            int u=gf(c[j].u),v=gf(c[j].v);
            ans[c[j].k]=(u==v&&Am[u]==c[j].a&&Bm[u]==c[j].b);
            fd(l,Top,1){
                u=d[l].u,v=d[l].v;fa[u]=u;
                Am[v]=d[l].a,Bm[v]=d[l].b,sz[v]=d[l].k;
            }Top=0;
        }
    }
    fp(i,1,q)puts(ans[i]?"Yes":"No");
return 0;
}

```

---

## 作者：lhm_ (赞：10)

题意可以转化为是否能找一条从$u$到$v$的路径，经过的边的$a$和$b$的最大值恰好都是询问所给定的值。

若只有$a$的限制，可以将询问离线，对边和询问都从小到大排序，然后双指针维护当前合法的边，用并查集维护连通块的最值和连通性。

现在有$a$和$b$的限制，考虑对边分块，先对所有边按$a$从小到大排序，对所有询问按$b$从小到大排序。

考虑当前枚举到的一个块及其之前块对询问的贡献。对所有询问找到$a$大小恰好在当前块范围内的询问，对当前块之前的整块按$b$从小到大排序，这样就能保证在当前块之前的所有边的$a$都小于等于现在找到的这些询问，然后这些边对$b$都有序，因为已经事先已经对询问排过序，所以可以像只有一个限制时一样，对当前块之前的整块进行双指针维护对当前询问合法的边。

对于零散块内的边，可以直接暴力枚举，如果合法就加入，当考虑到下一个询问时，对于零散块内加入的边要执行删除，所以用可撤销并查集来维护即可。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 200010
using namespace std;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,m,qu,S,top;
int ans[maxn],fa[maxn],de[maxn],va[maxn],vb[maxn];
struct node
{
    int x,y,a,b,id;
}e[maxn],q[maxn],t[maxn];
bool cmp1(const node &x,const node &y)
{
    if(x.a==y.a) return x.b<y.b;
    return x.a<y.a;
}
bool cmp2(const node &x,const node &y)
{
    if(x.b==y.b) return x.a<y.a;
    return x.b<y.b;
}
struct Node
{
    int x,y,deep,a,b;
}st[maxn];
int find(int x)
{
    return fa[x]==x?x:find(fa[x]);
}
void merge(int x,int y,int a,int b)
{
    x=find(x),y=find(y);
    if(de[x]<de[y]) swap(x,y);
    st[++top]=(Node){x,y,de[x],va[x],vb[x]};
    va[x]=max(va[x],a),vb[x]=max(vb[x],b);
    if(x==y) return;
    fa[y]=x,de[x]=max(de[x],de[y]+1);
    va[x]=max(va[x],va[y]),vb[x]=max(vb[x],vb[y]);
}
bool query(int id)
{
    int x=find(t[id].x),y=find(t[id].y);
    if(x!=y) return false;
    if(va[x]!=t[id].a||vb[x]!=t[id].b) return false;
    return true;
}
void del(int id)
{
    int x=st[id].x,y=st[id].y;
    fa[y]=y,de[x]=st[id].deep,va[x]=st[id].a,vb[x]=st[id].b;
}
int main()
{
    read(n),read(m),S=sqrt(m*log2(n));
    for(int i=1;i<=m;++i)
        read(e[i].x),read(e[i].y),read(e[i].a),read(e[i].b);
    read(qu);
    for(int i=1;i<=qu;++i)
        read(q[i].x),read(q[i].y),read(q[i].a),read(q[i].b),q[i].id=i;
    sort(e+1,e+m+1,cmp1),sort(q+1,q+qu+1,cmp2);
    for(int i=1;i<=m;i+=S)
    {
        int tot=0,pos=1;
        for(int j=1;j<=n;++j) fa[j]=j,va[j]=vb[j]=-1,de[j]=0;
        for(int j=1;j<=qu;++j)
            if(q[j].a>=e[i].a&&(q[j].a<e[i+S].a||i+S>m))
                t[++tot]=q[j];
        if(!tot) continue;
        if(i!=1) sort(e+1,e+i,cmp2);
        for(int j=1;j<=tot;++j)
        {
            while(pos<i&&e[pos].b<=t[j].b)
                merge(e[pos].x,e[pos].y,e[pos].a,e[pos].b),pos++;
            top=0;
            for(int k=i;k<i+S&&k<=m;++k)
                if(e[k].a<=t[j].a&&e[k].b<=t[j].b)
                    merge(e[k].x,e[k].y,e[k].a,e[k].b);
            ans[t[j].id]=query(j);
            while(top) del(top--);
        }
    }
    for(int i=1;i<=qu;++i)
    {
        if(ans[i]) puts("Yes");
        else puts("No");
    }
    return 0;
}
```

---

## 作者：Saliеri (赞：7)

一个神奇的科技：$\text{KDT 分治}$。

___

先转化一下问题，一个询问的条件能被满足，当且仅当（设这次询问给出的为 $s,t,A,B$），将所有满足 $a \leq A,b \leq B$ 的边加入之后：

- $s,t$ 在图上联通。

- $s,t$ 所在的联通块内 $\max a = A,\max b = B$。

看起来不是很好维护。

为简单起见，我们先来考虑一维的情况，即只存在 a 这一个限制。

可以发现，每一条边都影响的是询问 a 值是**一段**后缀上的询问。

接下来就很套路：每一条边有其影响区间，可以离线 -> **线段树分治**。

简单介绍一下，线段树分治的思想就是，通过线段树结构，将每一段影响区间拆到 $\log $ 个区间上，然后在线段树上 DFS，进入子树时加上边，回溯时撤销，到达叶子时回答询问。

这样就可以变删除为撤销，而仅仅多支付了一个 $O(\log n) $ 的复杂度。

本题中用带撤销并查集，维护连通性，联通块内 $\max a,\max b$ 即可。

重新回到二维情况，发现我们所需要做的，所谓的影响区间概念依旧不变，仅仅是将线段树的一维结构扩展到二维而已。

二维数据结构 —— 方便写的自然就是 KDT 了。

那么这个问题就变得很简单了——我们仿照线段树分治的形式在 KDT 上 Cover 边，最后 DFS 一遍求答案。

从 KDT 的复杂度分析，一个二维区间最多被挂在 $O(\sqrt n)$ 个
KDT节点上。

总时间复杂度 $O(n\sqrt n \log n)$，空间复杂度 $O(n\sqrt n)$。

tips：好像可以通过将所有操作一起处理，不提早 Cover 而做到 $O(n\log n)$ 的空间复杂度，有兴趣自己尝试吧。

因为时空限制都比较松所以可以过。

___

注意事项：

- 因为 KDT 并不是一个 Leafy 的数据结构，所以可能会单独在一个点而非他的整个子树上 cover 上一条边，所以开两个 vector 记即可。

- 为了空间着想，请尽量在 vector 中少存一些东西。

- 即使是一条边的两个端点已经在一个联通块内，也要更新这个联通块的 $\max a,\max b$，并需要将其在回溯时撤销。

___

代码：

~~思维和代码难度在我看来都比操作分块低一个档次……~~

```cpp

#include <cstdio>
#include <vector>
#include <algorithm>
using std::min;using std::max;
char gc(){static char buf[1<<16],*S,*T;if(T==S){T=(S=buf)+fread(buf,1,1<<16,stdin);if(T==S) return EOF;}return *S++;}
#define getchar gc
inline int re(){
	char c;
	while((c=getchar())>'9'||c<'0');
	int res = c-'0';
	while((c=getchar())>='0'&&c<='9')res = res*10+c-'0';
	return res;
}
const int maxn = 2e5+5,inf = 0x3f3f3f3f;
int n,m,q,root,xb,yb,ins,ans[maxn];
struct Edge{int x,y,a,b;}e[maxn];
struct point{int s,t,x,y,id;}p[maxn];
bool cmpx(point a,point b){return a.x<b.x;}
bool cmpy(point a,point b){return a.y<b.y;}
int ch[maxn][2],xp[maxn][2],yp[maxn][2];
void pushup(int x){
	xp[x][0] = min(p[x].x,min(xp[ch[x][0]][0],xp[ch[x][1]][0]));
	yp[x][0] = min(p[x].y,min(yp[ch[x][0]][0],yp[ch[x][1]][0]));
	xp[x][1] = max(p[x].x,max(xp[ch[x][0]][1],xp[ch[x][1]][1]));
	yp[x][1] = max(p[x].y,max(yp[ch[x][0]][1],yp[ch[x][1]][1]));
}
int build(int l,int r,int d){
	if(l>r)return 0;
	int mid = l+r>>1;
	std :: nth_element(p+l,p+mid,p+r+1,d?cmpy:cmpx);
	ch[mid][0] = build(l,mid-1,d^1),ch[mid][1] = build(mid+1,r,d^1);
	return pushup(mid),mid;
}
int fa[maxn],siz[maxn],maxa[maxn],maxb[maxn],top;
struct Back{int ty,x,y,prxa,prxb;};
Back st[maxn];
int getfa(int x){return fa[x] == x ? x : getfa(fa[x]);}
std :: vector <int> opt[maxn],sub[maxn];
void cover(int u){
	if(xp[u][1]<xb||yp[u][1]<yb)return ;
	if(xp[u][0]>=xb&&yp[u][0]>=yb)return sub[u].push_back(ins),void();
	if(p[u].x>=xb&&p[u].y>=yb)opt[u].push_back(ins);
	cover(ch[u][0]),cover(ch[u][1]);
}
void trymerge(int x,int y,int a,int b){
	int fx = getfa(x),fy = getfa(y);
	if(fx != fy){
		if(siz[fx] < siz[fy])fx ^= fy ^= fx ^= fy;
		st[++top] = (Back){1,fx,fy,maxa[fx],maxb[fx]};
		siz[fx] += siz[fy],fa[fy] = fx,maxa[fx] = max(max(maxa[fx],maxa[fy]),a),maxb[fx] = max(max(maxb[fx],maxb[fy]),b);
	}
	else if(maxa[fx] < a || maxb[fx] < b){
		st[++top] = (Back){0,fx,fx,maxa[fx],maxb[fx]};
		maxa[fx] = max(maxa[fx],a),maxb[fx] = max(maxb[fx],b);
	}
}
void getans(int u){
	if(!u)return ;
	int nowtop = top,fx,fy;
	for(int i=0;i<sub[u].size();++i)trymerge(e[sub[u][i]].x,e[sub[u][i]].y,e[sub[u][i]].a,e[sub[u][i]].b);
	getans(ch[u][0]),getans(ch[u][1]);
	for(int i=0;i<opt[u].size();++i)trymerge(e[opt[u][i]].x,e[opt[u][i]].y,e[opt[u][i]].a,e[opt[u][i]].b);
	fx = getfa(p[u].s),fy = getfa(p[u].t);
	if(fx == fy && maxa[fx] == p[u].x && maxb[fx] == p[u].y)ans[p[u].id] = 1;
	else ans[p[u].id] = 0;
	while(nowtop != top){
		if(st[top].ty == 1){
			siz[st[top].x] -= siz[st[top].y],fa[st[top].y] = st[top].y;
			maxa[st[top].x] = st[top].prxa,maxb[st[top].x] = st[top].prxb,--top;
		}
		else maxa[st[top].x] = st[top].prxa,maxb[st[top].x] = st[top].prxb,--top;
	}
}
int main(){
	xp[0][0] = yp[0][0] = inf,xp[0][1] = yp[0][1] = -inf;
	n = re(),m = re(); 
	for(int i=1;i<=n;++i)fa[i] = i,siz[i] = 1,maxa[i] = maxb[i] = -1;
	for(int i=1;i<=m;++i)
		e[i].x = re(),e[i].y = re(),e[i].a = re(),e[i].b = re();
	q = re();
	for(int i=1;i<=q;++i)
		p[i].s = re(),p[i].t = re(),p[i].x = re(),p[i].y = re(),p[i].id = i;
	root = build(1,q,0);
	for(int i=1;i<=m;++i)xb = e[i].a,yb = e[i].b,ins = i,cover(root);
	getans(root);
	for(int i=1;i<=q;++i)puts(ans[i]?"Yes":"No");
	return 0;
}
```

---

## 作者：crashed (赞：4)

# 题目
&emsp;&emsp;[点这里](https://www.luogu.com.cn/problem/P3247)看题目。  
# 分析
&emsp;&emsp;一类比较经典的分块优化暴力的思路。  
&emsp;&emsp;问题实际上是查询，当$a\le Qa, b\le Qb$的所有边都插入了图之后，$u,v$是否连通，并且$u,v$的连通块里面是否同时存在$a=Qa$和$b=Qb$的边。  
&emsp;&emsp;以上信息可以用并查集来维护。    
&emsp;&emsp;问题的瓶颈是，如何快速地提取出需要的边。  
&emsp;&emsp;我们不妨考虑这样一个算法：  
&emsp;&emsp;将边按照$a$排序并且分块处理，块的大小是$T$。对于当前块$[i,i+T)$，我们处理$Qa$在$[a_i,a_{i+T})$之间的询问。  
&emsp;&emsp;现在考虑处理掉$b$。发现对于$[1,i)$的边，当前询问只要求它$b\le Qb$。因此我们可以让$[1,i)$的边按照$b$来排序，并且让所有询问按照$Qb$来排序。这样对于$[1,i)$的边，$b$的限制就可以用指针方便地维护了。  
&emsp;&emsp;再考虑$[i,i+T)$的边，由于它们的数量比较少，所以我们可以直接暴力插入合法边，查询完之后再删除。由于这里存在并查集的删除操作，因此我们需要用到可回退的并查集，配合秩优化。  
&emsp;&emsp;时间复杂度：  
&emsp;&emsp;&emsp;&emsp;多次排序：$O(\frac{m^2}T\log_2m)$；  
&emsp;&emsp;&emsp;&emsp;块外边：$O(\frac{m^2}T\log_2n)$；  
&emsp;&emsp;&emsp;&emsp;块内边：$O(TQ\log_2n)$。    
&emsp;&emsp;总时间大概是......$O(\frac{m^2}T\log_2n+\frac{mQ}T\log_2n)$。  
&emsp;&emsp;根据均值不等式可以得到，$T=\sqrt{\frac{m^2}Q}$是比较 OK 的吧......   
&emsp;&emsp;但是经过评测，**当$T=\sqrt{m\log_2n}$的时候**是比较优秀的。  
# 代码
```cpp
#include <cmath>
#include <cstdio>
#include <algorithm>
using namespace std;

const int MAXN = 1e5 + 5, MAXM = 2e5 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

template<typename _T>
void swapp( _T &x, _T &y )
{
	_T t = x; x = y, y = t;
}

struct element
{
	int u, v, a, b, s;
	element() { u = v = a = b = s = 0; }
	void get() { read( u ), read( v ), read( a ), read( b ); }
	element( const int U, const int V, const int A, const int B, const int S ) { u = U, v = V, a = A, b = B, s = S; }
}E[MAXM], q[MAXN], lst[MAXM];

int fa[MAXN], siz[MAXN], mxA[MAXN], mxB[MAXN];
int seq[MAXM];
int N, M, Q, blk, top;
bool ans[MAXN];

void upt( int &x, const int v ) { x = MAX( x, v ); }
bool cmp1( const element &x, const element &y ) { return x.a < y.a; }
bool cmp2( const element &x, const element &y ) { return x.b < y.b; }
int findSet( const int u ) { return u == fa[u] ? u : findSet( fa[u] ); }
void makeSet( const int n ) { for( int i = 1 ; i <= n ; i ++ ) fa[i] = i, siz[i] = 1, mxA[i] = mxB[i] = -1; }

void unionSet( int u, int v, const int A, const int B )
{
	u = findSet( u ), v = findSet( v );
	if( siz[u] > siz[v] ) swapp( u, v );
	lst[++ top] = element( u, v, mxA[v], mxB[v], siz[v] );
	if( u ^ v ) 
		fa[u] = v, siz[v] += siz[u], 
		upt( mxA[v], mxA[u] ), upt( mxB[v], mxB[u] );
	upt( mxA[v], A ), upt( mxB[v], B );
}

bool chk( int u, int v, const int A, const int B )
{
	u = findSet( u ), v = findSet( v );
	return u == v && mxA[u] == A && mxB[u] == B;
}

int main()
{
	read( N ), read( M );
	for( int i = 1 ; i <= M ; i ++ ) E[i].get();
	read( Q ), blk = sqrt( M * log2( N ) );
	for( int i = 1 ; i <= Q ; i ++ ) q[i].get(), q[i].s = i;
	sort( E + 1, E + 1 + M, cmp1 );
	sort( q + 1, q + 1 + Q, cmp2 );
	int tot = 0, p, cur;
	for( int i = 1 ; i <= M ; i += blk )
	{
		makeSet( N ), tot = 0;
		if( i > 1 ) std :: sort( E + 1, E + i, cmp2 );
		for( int k = 1 ; k <= Q ; k ++ )
			if( E[i].a <= q[k].a && ( q[k].a < E[i + blk].a || i + blk > M ) )
				seq[++ tot] = k;
		p = 1;
		for( int k = 1 ; k <= tot ; k ++ )
		{
			cur = seq[k];
			for( ; p < i && E[p].b <= q[cur].b ; p ++ ) 
				unionSet( E[p].u, E[p].v, E[p].a, E[p].b );
			top = 0;
			for( int j = i ; j < i + blk && j <= M ; j ++ )
				if( E[j].a <= q[cur].a && E[j].b <= q[cur].b )
					unionSet( E[j].u, E[j].v, E[j].a, E[j].b );
			ans[q[cur].s] = chk( q[cur].u, q[cur].v, q[cur].a, q[cur].b );
			while( top )
			{
				int u = lst[top].u, v = lst[top].v; fa[u] = u;
				mxA[v] = lst[top].a, mxB[v] = lst[top].b, siz[v] = lst[top].s;
				top --;
			}
		}
	}
	for( int i = 1 ; i <= Q ; i ++ ) puts( ans[i] ? "Yes" : "No" );
	return 0;
}
```

---

## 作者：ywy_c_asm (赞：3)

这题除了分块，同样可以用k-d tree乱搞，~~虽然时间和空间都极为垃圾~~

首先对于这题的关键就是$a$和$b$可以看做两个**维度**，然后我们就想象成一个二维平面，每个边和询问都能表示成一个二维平面上的点$(a,b)$，那么我们的询问就是，在这个点$(a,b)$的左下方（含边界）矩形区域内的所有边，是否能够构成一个连通块使得$s$和$t$都在里面并且最大的$a$和$b$都正好是$a$和$b$。

看到有关维度的询问我们不难想到分治，可是这题的统计答案比较恶心，需要用并查集，而这个的贡献就不能独立了，所以你会发现无论是CDQ还是线段树分治都做不了这题，甚至连样例都过不去~~别问我咋知道的~~

但是我们是在一个**二维平面**上统计的啊，刚才说的那两个垃圾分治的缺点就是只能分掉一维，还有一维没法处理。为啥我们不能用能够处理多维问题的k-d tree呢？

然后我们想到了k-d tree，我们尝试把所有边建一个树，然后每个询问去$O(\sqrt n)$跑一遍找出所有可行边的子树。哎呀，都说了这玩意对答案的贡献没法独立，还是做不了。

额……其实咱们别忘了线段树分治中有一种常用技巧就是对询问建树然后修改放到祖先上的一条链，这样就能够保证在树上dfs的时候到了每个叶节点上的询问的时候就只能看见影响到他的修改了，并且并查集是可以按照栈序$O(logn)$撤销的。我们把这玩意搬到k-d tree上来，就好了。

这玩意时空开销极大，时间上~~只要你并查集按秩合并别写错~~还是能稍微跑过去的，空间的花费就更大了……要过掉这题你需要一些比较毒瘤的卡空间技巧……反正我把点存成unsigned short就擦边卡过去了……

上代码~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
namespace ywy{
	inline int get(){
		int n=0;char c;while((c=getchar())||23333){
			if(c>='0'&&c<='9')break;if(c=='-')goto s;
		}n=c-'0';while((c=getchar())||23333){
			if(c>='0'&&c<='9')n=n*10+c-'0';else return(n);
		}s:while((c=getchar())||23333){
			if(c>='0'&&c<='9')n=n*10-c+'0';else return(n);
		}
	}
	int ints[200001],size[200001],mxa[200001],mxb[200001];
	inline int find(int n){
		while(ints[n]!=n){
			n=ints[n];tot++;
		}
		return(n);
	}
	typedef struct _pt{
		int a;int b;int id;int s;int t;
	}pt;
	pt memchi[200001];
	int bkaa[200001],bkab[200001],bksz[200001],bktz[200001],bkmxaa[200001];
	int bkmxab[200001],bkmxba[200001],bkmxbb[200001];
	typedef struct _b{
		unsigned short s;unsigned short t;int a;int b;int id;
	}bian;
	bian bians[200001];
	vector<bian> vec[100001];
	int cmpa(const _pt &a,const _pt &b){
		return(a.a<b.a);
	}
	int cmpb(const _pt &a,const _pt &b){
		return(a.b<b.b);
	}
	int lef[200001],rgh[200001],gn=1;
	int mina[200001],minb[200001],maxa[200001],maxb[200001];
	int build(int l,int r,int d){
		int tree=gn;gn++;if(l==r){
			mina[tree]=maxa[tree]=memchi[l].a;minb[tree]=maxb[tree]=memchi[l].b;return(tree);
		}
		int mid=(l+r)>>1;nth_element(memchi+l,memchi+mid,memchi+1+r,d?cmpa:cmpb);
		lef[tree]=build(l,mid,d^1);rgh[tree]=build(mid+1,r,d^1);
		mina[tree]=min(mina[lef[tree]],mina[rgh[tree]]);
		minb[tree]=min(minb[lef[tree]],minb[rgh[tree]]);
		maxa[tree]=max(maxa[lef[tree]],maxa[rgh[tree]]);
		maxb[tree]=max(maxb[lef[tree]],maxb[rgh[tree]]);return(tree);
	}
	bian num;
	void insert(int l,int r,int tree){
		if(maxa[tree]<num.a||maxb[tree]<num.b)return;
		if(mina[tree]>=num.a&&minb[tree]>=num.b){
			vec[tree].push_back(num);return;
		}int mid=(l+r)>>1;insert(l,mid,lef[tree]);insert(mid+1,r,rgh[tree]);
	}
	unsigned char anss[100001];
	void dfs(int l,int r,int tree){
		for(register int i=0;i<vec[tree].size();i++){
			int aa=find(vec[tree][i].s),ab=find(vec[tree][i].t);
			bkaa[vec[tree][i].id]=aa;
			bkab[vec[tree][i].id]=ab;
			bksz[vec[tree][i].id]=size[aa];
			bktz[vec[tree][i].id]=size[ab];
			bkmxaa[vec[tree][i].id]=mxa[aa];
			bkmxab[vec[tree][i].id]=mxb[aa];
			bkmxba[vec[tree][i].id]=mxa[ab];
			bkmxbb[vec[tree][i].id]=mxb[ab];
			mxa[aa]=max(mxa[aa],vec[tree][i].a);
			mxb[aa]=max(mxb[aa],vec[tree][i].b);
			if(aa==ab)continue;if(size[aa]>size[ab])swap(aa,ab);
			size[ab]+=size[aa];ints[aa]=ab;
			mxa[ab]=max(mxa[ab],mxa[aa]);mxb[ab]=max(mxb[ab],mxb[aa]);
		}
		int mid=(l+r)>>1;if(l==r){
			int aa=find(memchi[l].s),ab=find(memchi[l].t);
			if(aa==ab&&mxa[aa]==memchi[l].a&&mxb[ab]==memchi[l].b)anss[memchi[l].id]=1;
		}
		else dfs(l,mid,lef[tree]),dfs(mid+1,r,rgh[tree]);
		for(register int i=vec[tree].size()-1;i>=0;i--){
			int aa=bkaa[vec[tree][i].id],ab=bkab[vec[tree][i].id];
			ints[aa]=aa;ints[ab]=ab;
			size[aa]=bksz[vec[tree][i].id];size[ab]=bktz[vec[tree][i].id];
			mxa[aa]=bkmxaa[vec[tree][i].id];mxa[ab]=bkmxba[vec[tree][i].id];
			mxb[aa]=bkmxab[vec[tree][i].id];mxb[ab]=bkmxbb[vec[tree][i].id];
		}
	}
	void ywymain(){
		int n=get(),m=get();
		for(register int i=1;i<=n;i++)ints[i]=i,size[i]=1,mxa[i]=mxb[i]=-1234567;
		for(register int i=1;i<=m;i++)bians[i].s=get(),bians[i].t=get(),bians[i].a=get(),bians[i].b=get(),bians[i].id=i;;
		int q=get();
		for(register int i=1;i<=q;i++){
			memchi[i].s=get();memchi[i].t=get();
			memchi[i].a=get();memchi[i].b=get();memchi[i].id=i;
		}
		int root=build(1,q,1);
		for(register int i=1;i<=m;i++){
			num=bians[i];insert(1,q,root);
		}
		dfs(1,q,root);
		for(register int i=1;i<=q;i++){
			if(anss[i])printf("Yes\n");else printf("No\n");
		}
	}
}
int main(){
	ywy::ywymain();return(0);
}
```

---

## 作者：Aftglw (赞：2)

### [HNOI2016]最小公倍数

`分块，并查集`

思路前面的题解已经说得很清楚了，我来说说具体的实现

1. 对边（按 $a$ 为关键字）和询问（按 $b$ 为关键字）分别排序
2. 边分块处理，找出当前块内所有的询问一起处理
3. 对于每一个块的询问：
   1. 对于前面块内的边，$a$ 肯定比当前询问小，所以按 $b$ 排序，一条条加入并查集，直到超过询问的b（这一步可以双指针维护，就不用标记了）
   2. 暴力遍历该块，找到符合要求的边，加入并查集，同时标记
   3. 并查集判联通，最大值，最小值，得到询问答案
   4. 清空此次询问带标记的并查集操作（栈记录），进入下一个询问
4. 清空并查集，进入下一个块

细节：

- 初始化最大 $a,b$ 赋为 $-1$，因为 $0\le a,b \le 10^9$
- 边界处理，比如最后一个块

优化：

- 发现瓶颈在于访问每个块时对前面的 $b$ 排序，而前面大部分的 $b$ 又是有序的，所以可以归并排序以降低时间复杂度

```cpp
#include <bits/stdc++.h>
#define re register
// #define int long long
#define pair pair<int, int>
//#define File(a) freopen(a".in", "r", stdin), freopen(a".out", "w", stdout);
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;
using namespace std;
inline int read()
{
    re int x = 0, f = 0;
    re char ch = getchar();
    while (!isdigit(ch)) {if (ch == '-') f = 1; ch = getchar();}
    while (isdigit(ch)) {x = (x << 3) + (x << 1) + ch - 48; ch = getchar();}
    return f ? -x : x;
}
inline string getstr()
{
    string res = "";
    re char ch = getchar();
    while (isspace(ch)) ch = getchar();
    while (!isspace(ch)) res.push_back(ch), ch = getchar();
    return res;
}
const int N = 5e4 + 4, M = 1e5 + 5;
int n, m, Q, ans[N];
struct edge
{
    int fr, to, a, b;
}e[M];
struct query
{
    int fr, to, a, b, id;
}q[N];
template<typename T> inline bool cmpa(const T &x, const T &y) {return x.a < y.a;}
template<typename T> inline bool cmpb(const T &x, const T &y) {return x.b < y.b;}
int fa[N], siz[N], mxa[N], mxb[N];
stack<tuple<int, int, int, int, int> > st;
inline void init()
{
    for (re int i = 1; i <= n; ++i)
        fa[i] = i, siz[i] = 1, mxa[i] = mxb[i] = -1;
}
inline int getfa(int u)
{
    while (fa[u] != u) u = fa[u];
    return u;
}
inline void Merge(int u, int v, const int &a, const int &b, const bool &del)
{
    u = getfa(u), v = getfa(v);
    if (siz[u] > siz[v]) swap(u, v);
    if (del) st.push(make_tuple(u, v, mxa[v], mxb[v], siz[v]));
    mxa[v] = max(mxa[v], a), mxb[v] = max(mxb[v], b);
    if (u == v) return;
    fa[u] = v, siz[v] += siz[u];
    mxa[v] = max(mxa[u], mxa[v]), mxb[v] = max(mxb[u], mxb[v]);
}
inline void delet()
{
    while (!st.empty())
    {
        int u, v, a, b, s;
        tie(u, v, a, b, s) = st.top(); st.pop();
        fa[u] = u, siz[v] = s, mxa[v] = a, mxb[v] = b;
    }
}
signed main()
{
    n = read(), m = read();
    for (re int i = 1; i <= m; ++i) e[i] = {read(), read(), read(), read()};
    Q = read();
    for (re int i = 1; i <= Q; ++i) q[i] = {read(), read(), read(), read(), i};
    sort(e + 1, e + m + 1, cmpa<edge>);
    sort(q + 1, q + Q + 1, cmpb<query>);
    const int len = sqrt(m * log2(n)); int siz = 0;
    static int *l = new int [m / len + 5], *v = new int [m + 5];
    for (re int i = 1; i <= m; i += len) l[++siz] = i;
    l[siz + 1] = m + 1, e[m + 1].a = 0x7fffffff, e[m + 1].b = 0x7fffffff;
    for (re int i = 1; i <= siz; ++i)
    {
        init();
        int cnt = 0;
        for (re int j = 1; j <= Q; ++j)
            if (q[j].a >= e[l[i]].a && q[j].a < e[l[i + 1]].a) v[++cnt] = j;
        if (!cnt) continue;
        sort(e + 1, e + l[i], cmpb<edge>);
        for (re int j = 1, k = 1; j <= cnt; ++j)
        {
            int now = v[j];
            while (k < l[i] && e[k].b <= q[now].b) Merge(e[k].fr, e[k].to, e[k].a, e[k].b, 0), ++k;
            for (re int x = l[i]; x < l[i + 1] && x <= m; ++x)
            {
                if (e[x].a > q[now].a) break;
                if (e[x].b <= q[now].b) Merge(e[x].fr, e[x].to, e[x].a, e[x].b, 1);
            }
            int u = getfa(q[now].fr), v = getfa(q[now].to);
            if (u == v && mxa[u] == q[now].a && mxb[u] == q[now].b) ans[q[now].id] = 1;
            delet();
        }
    }
    for (re int i = 1; i <= Q; ++i) puts(ans[i] ? "Yes" : "No");
    return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：2)

分块好题。          
      
不说分块还真没想到怎么分块。刚开始拿到这道题还有点疑惑，在 Kruscal 重构树上面走偏了很远才发现一行关键字：         

```注意：路径可以不是简单路径。```       

之后就瞬间会了 $O(m ^ 2)$ 做法：对于每个询问把可以连的边(即边值 a,b 都不超过查询值 a,b )都连了然后判断一下三个条件：          

- 两点是否连通        

- u 点是否可以走到边权有 a , b 那么大的边。

- v 点是否可以走到边权有 a , b 那么大的边。      

这样就是 $O(m ^ 2)$ 的了。         

先考虑简化一下询问，如果只有 a 的话我们直接把查询和边按 a 排序然后双指针做一遍即可。         

现在顺着这个思路，我们还是先考虑对询问 a 排序，现在我们如果还是按照双指针的套路来做就有点难了。          

我们不难想到，在只有 a 的情况我们排序双指针跳其实是在利用前面的状态，这里我们不妨也利用好前面的状态。            

考虑分块，每个块后面处理一系列询问：当前询问的 a 值严格大于等于块中的所有 a 值的最大值并且严格小于下一个块中的 a 值的最大值。       

这样的话，我们要处理的询问就只有块前面的所有边和后面一个零散块的边。              

我们接着思考：如果我们前面又有一个按 b 排好序的边数组，那么我们是不是直接用类似归并的思想，把后面的查询也按 b 排好序，然后用双指针来解决前面的操作（具体而言就是两个指针比 b 的大小，每次往后一个查询即相对应的挪动前一个双指针来加边），每个查询做完前面的操作后我们再去遍历一遍后面的零散块后查询答案，之后用一个栈来回退(即把被更新的节点之前的状态记录一下然后还原一下) 。         

PS：之前喷同学的题解写的太丑现在看来我自己也没写的好到哪里去。    

由于涉及回退操作，所以我们只能按秩合并并查集，时间复杂度在块长取 $\sqrt {n \log n}$ 时为 $O(n \sqrt n \log n)$ 。        

实现的话，我们直接先把查询按 b 排好序一个个往里面放即可。       

关于优化操作，我们完全可以把并查集看成一个缩点过程，把这部分答案维护好之后我们就只用把后面零散块的边暴力拿来建图之后做一遍 BFS ，但一定要注意得用 flag 打边是否走过的标记而不是点是否走过的标记。这样的话不涉及并查集回退操作时间复杂度为 $O(q \sqrt m \alpha(n))$ 。       

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
using namespace std;
const int Len = 2e5 + 5 , SIZE = 1025;
int n,m,q,top,fa[Len],maxa[Len],maxb[Len],dep[Len],t,sizt,L[SIZE],R[SIZE],lsh[SIZE],lshtot,Print[Len]; 
struct node
{
	int u,v,a,b,pst;
}edge[Len],qsk[Len];
struct Node
{
	int u,v,dep,a,b;
	Node(){u = 0 , v = 0 , dep = 0 , a = 0 , b = 0;}
	Node(int U,int V,int DEP,int A,int B){u = U , v = V , dep = DEP , a = A , b = B;}
}stk[Len];
bool cmpa(node x,node y){return x.a < y.a;}
bool cmpb(node x,node y){return x.b < y.b;}
vector<int> v[Len];
void makeSet(int x){for(int i = 1 ; i <= x ; i ++) fa[i] = i , dep[i] = 0 , maxa[i] = maxb[i] = -1;}
inline int findSet(int x){return fa[x] == x ? fa[x] : findSet(fa[x]);}
inline void unionSet(int x,int y,int A,int B)
{
	int u = findSet(x) , v = findSet(y);
	if(dep[u] < dep[v]) swap(u , v);
	stk[++ top] = (Node){u , v , dep[u] , maxa[u] , maxb[u]};
	maxa[u] = max(maxa[u] , A) , maxb[u] = max(maxb[u] , B); 
	if(u == v) return;
	fa[v] = u , dep[u] = max(dep[u] , dep[v] + 1) , maxa[u] = max(maxa[u] , maxa[v]) , maxb[u] = max(maxb[u] , maxb[v]);
}
inline void del(int Id)
{
	int u = stk[Id].u , v = stk[Id].v;
	fa[v] = v , dep[u] = stk[Id].dep , maxa[u] = stk[Id].a , maxb[u] = stk[Id].b;
}
int main()
{
	//freopen("1.in","r",stdin);
	scanf("%d %d",&n,&m);
	t = max(1 , (int)sqrt(m * log(m))) , sizt = m / t;
	for(int i = 1 ; i <= m ; i ++) scanf("%d %d %d %d",&edge[i].u,&edge[i].v,&edge[i].a,&edge[i].b);
	sort(edge + 1 , edge + 1 + m , cmpa);
	for(int i = 1 ; i <= sizt ; i ++) L[i] = (i - 1) * t + 1 , R[i] = i * t;
	if(R[sizt] < m) R[sizt] = m;
	for(int i = 1 ; i <= sizt ; i ++) lsh[++ lshtot] = edge[L[i]].a;
	scanf("%d",&q);//我们可以直接扔去
	for(int i = 1 ; i <= q ; i ++){scanf("%d %d %d %d",&qsk[i].u,&qsk[i].v,&qsk[i].a,&qsk[i].b);qsk[i].pst = i;}
	sort(qsk + 1 , qsk + 1 + q , cmpb);
	for(int i = 1 ; i <= q ; i ++) 
	{
		int idx = upper_bound(lsh + 1 , lsh + 1 + lshtot , qsk[i].a) - lsh;
		idx --;
		if(!idx) Print[qsk[i].pst] = 0;
		else v[idx].push_back(i);
	}
	//for(int i = 1 ; i <= sizt ; i ++) sort(edge + L[i] , edge + R[i] + 1 , cmpb);
	for(int i = 1 ; i <= sizt ; i ++)
	{
		int idx = 1;
		makeSet(n);
		if(i != 1) sort(edge + 1 , edge + L[i] , cmpb);
		for(int j = 0 ; j < v[i].size() ; j ++)
		{
			while(idx < L[i] && edge[idx].b <= qsk[v[i][j]].b){unionSet(edge[idx].u , edge[idx].v , edge[idx].a , edge[idx].b) ; idx ++;}
			top = 0;
			for(int k = L[i] ; k <= R[i] ; k ++) if(edge[k].a <= qsk[v[i][j]].a && edge[k].b <= qsk[v[i][j]].b){unionSet(edge[k].u , edge[k].v , edge[k].a , edge[k].b);}
			int nowu = findSet(qsk[v[i][j]].u) , nowv = findSet(qsk[v[i][j]].v);
			if(nowu == nowv && maxa[nowu] == qsk[v[i][j]].a && maxb[nowu] == qsk[v[i][j]].b) Print[qsk[v[i][j]].pst] |= 1;
			while(top) del(top --);
		}
	}
	for(int i = 1 ; i <= q ; i ++) (Print[i] == 1) ? puts("Yes") : puts("No"); 
	return 0;
}
```

---

## 作者：GoldenPotato137 (赞：2)

[戳我获得更好的阅读体验qwq](https://www.goldenpotato.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/luogu-p3247-hnoi2016%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/)

---
# Solution
这是一道妙题。

首先，~~根据常识~~，题面要我们求的是找一条从s,t的路径，使得路径上$max\ a=a,max\ b=b$。

这咋求呢？我们会发现，**我们要求的路径本质上是一个连通块，连通块可以考虑用并查集处理**。
接下来考虑对a分块，先把所有的边按照$a$来排序，再分块，每个块里连的所有边保证$<=a_{[size*x]}$，如下图所示：
![AuMb0e.png](https://s2.ax1x.com/2019/03/19/AuMb0e.png)

接下来，我们考虑把所有询问按照**b从小到大**排序去一个个计算，每计算一个询问之前，把$b<=q[i].b$的边全部都对应地塞到联通快里面去(根据我们之前分块的定义，每条边说要塞入的并查集一定为从某个连通块开始一直往后到最后一个块为止)。

接下来，我们对应的去找最大的$a<=q[i].a$的连通块，然后把一些还零散在外面的边全部塞到那个连通块里面，**这个连通块里面所有的边一定能保证$a<=q[i].a,b<=q[i].b$**，我们只需要对应的看看$u,v$是否联通，它们所在的连通块的$max\_a,max\_b$是否满足要求即可。

我们每做完一个操作后，必须把之前连的零散的边给撤销掉。因此，我们这里必须用**按秩合并的并查集**。我们可以通过用一个栈/队列记录所有的修改操作(改fa/改max)一个一个改回去即可。

因为我们这里有$\sqrt m$个块，每次操作的零散边不超过$\sqrt m$条，因此总复杂度应该是$O(n \cdot \sqrt m)$

---
# Code
**数据生成器**

[在这里w](https://www.goldenpotato.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/luogu-p3247-hnoi2016%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/)

**请注意特判(0,0)边构成自环的情况，我因为这个破事WA了半天**
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstdlib>
#include<algorithm>
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=50000+100;
const int M=100000+100;
const int Q=1000;
struct line
{
    int s,t,a,b,ans,no;
    friend bool operator < (line x,line y)
    {
        return x.a<y.a;
    }
}l[M],l2[M],q[N];
bool cmp1(line x,line y)
{
    return x.a<y.a;
}
bool cmp2(line x,line y)
{
    return x.b<y.b;
}
bool cmp3(line x,line y)
{
    return x.no<y.no;
}
int n,m,K,block[Q];//block[i]:记录第i块的a值
struct SIT
{
    int type,x,num1,num2;//type=0:改fa;type=1:改max
}mstack[N];
int top;
struct UnF
{
    int fa[N],size[N],MAX_a[N],MAX_b[N];
    int FindFather(int x)
    {
        if(fa[x]==0) return x;
        return FindFather(fa[x]);
    }
    void Merge(int x,int y,int a,int b,bool type)//type=0：不撤回;=1:要撤回
    {
        int fa1=FindFather(x),fa2=FindFather(y);
        if(size[fa1]>size[fa2]) 
            swap(x,y),swap(fa1,fa2);
        if(type==1)
            mstack[++top].type=1,mstack[top].x=fa2,
            mstack[top].num1=MAX_a[fa2],mstack[top].num2=MAX_b[fa2];
        MAX_a[fa2]=max(max(MAX_a[fa2],MAX_a[fa1]),a);
        MAX_b[fa2]=max(max(MAX_b[fa2],MAX_b[fa1]),b);	
        if(fa1==fa2)
            return;
        if(type==1)
            mstack[++top].type=0,mstack[top].x=fa1,mstack[top].num1=fa2,mstack[top].num2=size[fa1];
        fa[fa1]=fa2,size[fa2]+=size[fa1];
    }
    void Undo()
    {
        for(;top>0;top--)
        {
            if(mstack[top].type==0)
                fa[mstack[top].x]=0,size[mstack[top].num1]-=mstack[top].num2;
            else
                MAX_a[mstack[top].x]=mstack[top].num1,
                MAX_b[mstack[top].x]=mstack[top].num2;
        }
    }
    int Query(int x,int y,int a,int b)
    {
        if(x==y and a==0 and b==0)
            return size[FindFather(x)]!=1;
        int fa=FindFather(x);
        if(FindFather(x)!=FindFather(y)) return false;
        if(MAX_a[fa]!=a or MAX_b[fa]!=b)
            return false;
        return true;
    }
}unf[Q];
int main()
{
    int t=clock();
    n=read(),m=read();
    for(int i=1;i<=m;i++)
    {
        l[i].s=read(),l[i].t=read(),l[i].a=read(),l[i].b=read();
        l2[i]=l[i];
    }
    K=read();
    for(int i=1;i<=K;i++)
        q[i].s=read(),q[i].t=read(),q[i].a=read(),q[i].b=read(),q[i].no=i;
        
    int size=int(sqrt(m*20)),cnt=m/size;		
    for(int i=0;i<=cnt;i++)
        for(int j=1;j<=n;j++)
            unf[i].size[j]=1;
    sort(l+1,l+1+m,cmp1);
    sort(l2+1,l2+1+m,cmp1);
    for(int i=0;i<=m/size;i++)
        block[i]=l[i*size].a;
    sort(q+1,q+1+K,cmp2);
    sort(l+1,l+1+m,cmp2);
    
    int to=1;//记录当前执行到第to条边
    for(int i=1;i<=K;i++)
    {
        //cerr<<i<<endl;
        for(;l[to].b<=q[i].b and to<=m;to++)
        {
            int begin=lower_bound(block,block+1+cnt,l[to].a)-block;
            for(int j=begin;j<=cnt;j++)
                unf[j].Merge(l[to].s,l[to].t,l[to].a,l[to].b,0);
        }
        int t=upper_bound(block,block+1+cnt,q[i].a)-block-1;
        line tmp;tmp.a=block[t];
        for(int j=upper_bound(l2+1,l2+1+m,tmp)-l2;j<=m and l2[j].a<=q[i].a;j++)
            if(l2[j].b<=q[i].b)
                unf[t].Merge(l2[j].s,l2[j].t,l2[j].a,l2[j].b,1);
        q[i].ans=unf[t].Query(q[i].s,q[i].t,q[i].a,q[i].b);
        unf[t].Undo();
    }
    
    sort(q+1,q+1+K,cmp3);
    for(int i=1;i<=K;i++)
        if(q[i].ans==1)
            printf("Yes\n");
        else
            printf("No\n");
    cerr<<clock()-t<<endl;
    return 0;
}

```










---

## 作者：ShaunWang (赞：2)

##分块 + 并查集启发式合并

思路很简单,就是找到所有a,b都小于等于某个询问的边然后并查集合并,维护每个集合的a,b的最大值看是否等于询问的a,b.

直接暴力显然会超时,于是考虑分块,显然分成根号n块.

先整体把边按a排序,询问先读进来后按b排序,然后对于每一块的边按b排序,然后进行并查集的合并操作

值得注意的是,由于要撤销操作(分块处理,处理完一块后要“处理作案痕迹”)故这里的并查集不能使用压缩路径,否则难以实现撤销undo操作,而只能使用并查集的启发式合并,即按秩合并(这样子的话效率似乎是均摊O(lgn)？？？)并记录操作,然后撤销即可.


PS:这题本来4s时限结果LG上一开始是1s时限卡了我几次....


又臭又长的代码如下:

```cpp
/*
    Programed By Harry·Shaun·Wang
    2016.12.4 
*/
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cmath>
#define MAXN 50005
#define MAXM 100005
#define MAXQ 50005
#define union Union
using namespace std;
inline int getint()
{
    int x=0;
    char c=getchar();
    while(c<'0' || c>'9') c=getchar();
    while(c>='0' && c<='9')
    {
        x=x*10+c-48;
        c=getchar();
    }
    return x;
}
struct Edge
{
    int from,to;
    int a,b;
    int index;
    Edge& input(int i)
    {
        from=getint(),to=getint();
        a=getint(),b=getint();
        index=i;
        return *this;
    }
};
struct Operation
{
    int from,to;
    int father,size;
    int maxa,maxb;
};
int n,m,q,l;
Edge E[MAXM],Q[MAXQ],S[MAXN];
Operation O[MAXQ];
int f[MAXN],size[MAXN];
int maxa[MAXN],maxb[MAXN];
int top,sum;
int ans[MAXQ];
inline bool cmpa(const Edge &x,const Edge &y)
{
    if(x.a!=y.a) return x.a<y.a;
    else return x.b<y.b;
}
inline bool cmpb(const Edge &x,const Edge &y)
{
    if(x.b!=y.b) return x.b<y.b;
    else return x.a<y.a;
}
inline int max(int a,int b,int c)
{
    if(a<b) a=b;
    if(a<c) a=c;
    return a;
}
inline int find(int x)
{
    while(x!=f[x]) x=f[x];
    return x;
}
inline void union(int x,int y,int a,int b)
{
    x=find(x),y=find(y);
    if(size[x]>size[y]) swap(x,y);
    ++sum;
    O[sum].from=x,O[sum].to=y;
    O[sum].maxa=maxa[y],O[sum].maxb=maxb[y];
    O[sum].father=f[x],O[sum].size=size[y];
    if(x==y)
    {
        maxa[x]=max(maxa[x],a); 
        maxb[x]=max(maxb[x],b); 
        return;
    }
    f[x]=y;
    size[y]+=size[x];
    maxa[y]=max(maxa[x],maxa[y],a);
    maxb[y]=max(maxb[x],maxb[y],b);
}
inline void undo()
{
    while(sum) 
    {
        f[O[sum].from]=O[sum].father; 
        size[O[sum].to]=O[sum].size;
        maxa[O[sum].to]=O[sum].maxa;
        maxb[O[sum].to]=O[sum].maxb;
        --sum;
    }
}
int main()
{
    n=getint(),m=getint();
    for(int i=1; i<=m; ++i) E[i].input(i);
    q=getint();
    for(int i=1; i<=q; ++i) Q[i].input(i);
    stable_sort(E+1,E+m+1,cmpa),stable_sort(Q+1,Q+q+1,cmpb);
    l=sqrt(m);
    for(int i=1; i<=m; i+=l)
    {
        top=0;
        for(int j=1; j<=q; ++j)
            if(Q[j].a>=E[i].a && (i+l>m || Q[j].a<E[i+l].a))
                S[++top]=Q[j];
        stable_sort(E+1,E+i,cmpb);
        for(int j=1; j<=n; ++j)
        {
            f[j]=j;
            size[j]=1;
            maxa[j]=maxb[j]=-1;
        }
        for(int j=1,k=1; j<=top; ++j)
        {
            for(; k<i && E[k].b<=S[j].b; ++k)
                union(E[k].from,E[k].to,E[k].a,E[k].b);
            sum=0;
            for(int o=i; o<i+l && o<=m; ++o)
                if(E[o].a<=S[j].a && E[o].b<=S[j].b)
                    union(E[o].from,E[o].to,E[o].a,E[o].b);
            int x=find(S[j].from),y=find(S[j].to);
            ans[S[j].index]=(x==y && maxa[x]==S[j].a && maxb[x]==S[j].b);
            undo();
        }
    }
    for(int i=1; i<=q; ++i)
        if(ans[i]) puts("Yes");
        else puts("No");
    return 0;
}
```

---

## 作者：_sunkuangzheng_ (赞：0)

**【题目分析】**

转化后的题意：给你一张 $n(n \le 5 \times 10^4)$ 个点 $m(m \le 10^5)$ 条边的无向图，每条边有边权 $a_i,b_i$，$q(q \le 5 \times 10^4)$ 次询问，每次给定 $u,v,a,b$，问是否存在一条 $u$ 到 $v$ 的路径（可以不是简单路径），使得经过的边中，$\max\{a_i\} = a,\max\{b_i\} = b$。~~相信切紫题的您不可能不会这一步~~。

你可能想不到什么好的 poly-log 解法，再结合数据范围，也许就能猜到需要分块。我们先把所有边按照 $a_i$ 大小分块，那么显然每个询问 $q_i$ 都可以根据 $q_{i,a}$ 的大小分到一个块内，且前面的整块的边只要满足 $b_i \le q_{i,b}$ 都可以连接。

我们发现对 $a_i$ 排序后 $b_i$ 和 $q_{b,i}$ 的大小关系不好确定，因此我们重新将边按照 $b_i$ 每个块内排序。为了让整块内可选边的数量具有单调性，我们将询问离线，把询问按照 $q_{i,b}$ 排序。

接下来，我们把同一个块内的询问归类处理，使用并查集维护连通性。那么下面我们假设正在处理整块 $i$ 内的 $k$ 个询问 $q_1,q_2,\ldots,q_k$。

因为询问和边都是按照 $b_i$ 排序的，我们对于每个整块 $j$ 维护一个位置 $p_j$ 表示块内 $1 \sim p_j$ 的位置都是可以选的。显然 $p_j$ 只会单调不降。然后散块里的边暴力加边。但是加边会对下次询问造成影响，所以并查集需要支持撤销。维护一个记录操作的栈即可。并查集合并时，我们需要额外记录每个连通块内，两种边权的最大值。

请注意每次更换我们正在处理的整块时，所有数组都需要初始化。

分析时间复杂度，设块长为 $B$，初始化的复杂度 $\mathcal O(n \cdot\dfrac{m}{B})$，遍历整块的复杂度 $\mathcal O(q \cdot 
\dfrac{m}{B} \cdot \log m)$，遍历散块的复杂度 $\mathcal O(q \cdot B \cdot \log m)$，平衡后取 $B = \sqrt {m \log n}$，时间复杂度 $\mathcal O(q \sqrt{m \log n} \log m)$。虽然极限数据下理论值达到了 $10^9$，但是常数小跑不满加上长时限，还是可以轻松通过的。

**【代码】**

注意并查集撤销时，$x = y$ 的情况需要特判，否则 $siz_x$ 会变成 $0$。

注意 $n=1$ 的情况，块长和 $1$ 取 $\max$。

```cpp
/**
 *    author: sunkuangzheng
 *    create: 23.09.2023 10:36:35
**/
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e6+5;
int t,n,m,Q,id[maxn],bl[maxn],br[maxn],ms1[maxn],ms2[maxn],ms[maxn],fa[maxn],siz[maxn],p[5005],ans[maxn];
struct edge{int u,v,a,b,id;}g[maxn],q[maxn];
bool cmp(edge a,edge b){return a.a < b.a;}
bool cmpp(edge a,edge b){return a.b < b.b;}
int fd(int x){return x == fa[x] ? x : fd(fa[x]);}
struct op{int x,y,m1,m2;};
vector<edge> c[5005];stack<op> st;
void mg(int x,int y,int a,int b,int fg){
    x = fd(x),y = fd(y);
    if(siz[x] < siz[y]) swap(x,y);
    if(x != y) siz[x] += siz[y],fa[y] = x;
    if(fg) st.emplace(x,y,ms1[x],ms2[x]);
    ms1[x] = max(ms1[x],max(ms1[y],a)),ms2[x] = max(ms2[x],max(ms2[y],b));
}int main(){
    ios::sync_with_stdio(0),cin.tie(0);cin >> n >> m;
    for(int i = 1;i <= m;i ++) cin >> g[i].u >> g[i].v >> g[i].a >> g[i].b;
    sort(g+1,g+m+1,cmp);cin >> Q;
    int ll = max(sqrt(m * log2(n)),1),tot = (m + ll - 1) / ll;
    for(int i = 1;i <= m;i ++) id[i] = (i - 1) / ll + 1;
    for(int i = 1;i <= tot;i ++) bl[i] = (i - 1) * ll + 1,br[i] = min(m,bl[i] + ll - 1),ms[i] = g[br[i]].a,sort(g+bl[i],g+br[i]+1,cmpp);
    for(int i = 1;i <= Q;i ++) cin >> q[i].u >> q[i].v >> q[i].a >> q[i].b,q[i].id = i;
    sort(q+1,q+Q+1,cmp);int pp = 1;
    for(int i = 1;i <= Q;c[min(pp,tot)].push_back(q[i ++])) while(q[i].a >= ms[pp] && pp <= tot) pp ++;
    for(int i = 1;i <= tot;i ++){
        sort(c[i].begin(),c[i].end(),cmpp);
        for(int j = 1;j <= n;j ++) 
            fa[j] = j,siz[j] = 1,ms1[j] = -1,ms2[j] = -1;
        for(int j = 1;j <= tot;j ++) p[j] = bl[j];
        for(auto [u,v,a,b,id] : c[i]){
            for(int j = 1;j < i;j ++)
                while(b >= g[p[j]].b && p[j] <= br[j]) 
                    mg(g[p[j]].u,g[p[j]].v,g[p[j]].a,g[p[j]].b,0),p[j] ++;
            for(int j = bl[i];j <= br[i];j ++) 
                if(g[j].a <= a && g[j].b <= b) mg(g[j].u,g[j].v,g[j].a,g[j].b,1);
            ans[id] = (fd(u) == fd(v) && ms1[fd(u)] == a && ms2[fd(u)] == b);
            while(st.size()) {
                auto [x,y,w1,w2] = st.top();st.pop();
                if(x != y) fa[y] = y,siz[x] -= siz[y];
                ms1[x] = w1,ms2[x] = w2;
            }
        }
    }for(int i = 1;i <= Q;i ++) cout << (ans[i] ? "Yes\n" : "No\n");
}
```

---


# [SCOI2016] 萌萌哒

## 题目描述

一个长度为 $n$ 的大数，用 $S_1S_2S_3 \cdots S_n$表示，其中 $S_i$ 表示数的第 $i$ 位, $S_1$ 是数的最高位。告诉你一些限制条件，每个条件表示为四个数，$l_1,r_1,l_2,r_2$，即两个长度相同的区间，表示子串 $S_{l_1}S_{l_1+1}S_{l_1+2} \cdots S_{r_1}$ 与 $S_{l_2}S_{l_2+1}S_{l_2+2} \cdots S_{r_2}$ 完全相同。

比如 $n=6$ 时，某限制条件 $l_1=1,r_1=3,l_2=4,r_2=6$ ，那么 $123123$，$351351$ 均满足条件，但是 $12012$，$131141$ 不满足条件，前者数的长度不为 $6$ ，后者第二位与第五位不同。问满足以上所有条件的数有多少个。

## 样例 #1

### 输入

```
4 2
1 2 3 4
3 3 3 3```

### 输出

```
90```

# 题解

## 作者：shadowice1984 (赞：93)

关于各种神奇的倍增法
### 倍增
其实倍增法不仅局限于快速幂，后缀数组，ST表，求lca之类的特定算法，而是用来解决一类特定问题的。

##### 倍增原理

看似玄学的倍增其实源于两个数学等式

1.2^n=2^(n-1)+2^(n-1)

2.N=sigma(pi\*2^i) \[i∈(0,+∞)] {中pi为N的二进制第i位}

想必任何一个知道二进制的人都明白上述两个等式吧……

而倍增法的唯一要求的是，被称之为“+”的运算满足结合律(有些人也成操作满足可合并性)

具体来讲，倍增法用到的地方一般是，我们现在要询问/修改一些东西，然后我们发现操作具有合并性，之后呢，我们对于每个大小为2^i的东西预处理出来一个答案，等到询问的时候，就将询问的东西大小用二进制表达，将预处理出来的每个东西合并起来就得到了答案

常用的两类二进制拆分代码

```C
for(int i=0;p;p>>=1,i++){/*do sth*/}
```
```C
for(int i=20;p>0;i--){if(p>po[i]){p-=po[i]}/*do sth*/}
```
其中上面一个适用于p已知的情况(比如倍增求lca，跳到深度相等的那段代码)

下面的一个适用于p未知，但是可以比较p和某个值的大小，以及可以做相减运算
(比如lca第二段，两个点一起向上跳，但是不知道lca的深度的情况，但是我们用这个代码在未知lca深度的情况下对lca深度做了二进制拆分)

然后我们来结合这道题讲一下如何魔改倍增法，因为这个玩意和dp，分治法都很像，都是根据某一个问题的性质设计了类似的"方法"，根本不是有板子的算法，所以我们要具体问题具体分析……

### 本题题解

首先我们发现题目中给了我们一些区间相等的关系，之后我们发现，如果从子串的思路想会进入死胡同，因为串都没给你哪里来的后缀数据结构？

发现这道题本质上是个计数问题，我们考虑枚举每个点可以取的值，发现有些其他点必须和他取值一样，否则不满足题意区间相等的要求，(这里其实做了一步转化，区间相等<\-\->对应点相等)

那么我们就有办法维护这个相等关系了,直接并查集维护复杂度O(n^2)，30pts get√，最后的答案为9\*10^(num-1) num为并查集个数，因为最高位是不可以取零的

然后发现是传统暴力的复杂度不均衡问题，我们的处理询问，是O(N^2)的但是，我们的查找，仅仅是O(N)的……所以我们要平衡这个扭曲的复杂度，使得询问查找都变成O(NlogN)

那么怎么办呢，并查集的并操作具有可合并性，所以我们可以考虑上倍增。

我们可以将一个点拆成logN个点，分别代表从点i开始，长度为2^k的子串
那么当我们处理两个区间相等的关系时，对区间做二进制拆分，拆成log个区间，分别并起来即可

当然我们这样做修改是省心了，但是同时查询的时候也会带来一些麻烦……因为，我们要求的信息是最底层的，只能是长度为1的区间，而不能有奇奇怪怪的区间
不过没关系，我们这时运用等式1，拆分并查集

具体来讲，我们从最长的区间开始逐个枚举，每次查找他和他的父亲，然后把它和父亲都劈成两半，前一半和前一半连边，后一半和后一半连边即可，这样相当于把较长区间并查集拆成两个一半的并查集

最后我们就有了一些关于那些点相等的信息，直接计算并查集个数即可

```C
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;ll mod=1e9+7;
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=(a*a)%mod){if(p&1)r=(r*a)%mod;}return r;}
const int N=100010;int n;int tr[20][N];int log[N];int ctt;//用来给各个区间编号
inline void createlog()//这里打表log其实并没咋用……
{int i=1;for(int j=2;j<=n;j++){if(j==(1<<(i+1)))i++;log[j]=i;}}
struct bcj//只写了路径压缩，理论来讲是log^2N的，但是路径压缩的均摊复杂度常数小于1……
{
	int fa[20*N];
	inline void ih(){for(int i=1;i<=ctt;i++)fa[i]=i;}
	inline int f(int x){return fa[x]=(fa[x]==x)?x:f(fa[x]);}
	inline void u(int x,int y){fa[f(x)]=f(y);}
}s;int m;int siz;bool book[N];
inline void dtr(int v,int& y){v%=n;y=v?v:n;}//解编号函数
int main()
{
	scanf("%d%d",&n,&m);createlog();
	for(int i=0;i<=log[n];i++)
	{for(int j=1;j<=n;j++){tr[i][j]=++ctt;}}//分配编号
	s.ih();
	for(int i=1;i<=m;i++)
	{
		int l;int r;int len;int d;
		scanf("%d%d%d%d",&l,&r,&len,&d);
		d=len-l;len=r-l+1;//len区间长度,d偏移量
		for(int k=0;len;len>>=1,k++)//这里的二进制拆分可能用了些位运算的奇技淫巧~
		{
			if(len&1)
			{
				int p1=l+((len>>1)<<(k+1));int p2=p1+d;
				s.u(tr[k][p1],tr[k][p2]);//把对应区间并起来
			}
		}
	}
	for(int i=log[n];i>=1;i--)
	{
		for(int j=1;j+(1<<i)-1<=n;j++)//分裂并查集
		{
			int fa=s.f(tr[i][j]);if(fa==tr[i][j]){continue;}int y;dtr(fa,y);//前一半后一半连边
			s.u(tr[i-1][j],tr[i-1][y]);s.u(tr[i-1][j+(1<<(i-1))],tr[i-1][y+(1<<(i-1))]);
		}
	}
	for(int i=1;i<=n;i++)//计算并查集个数
	{
		int fa=s.f(tr[0][i]);int y;dtr(fa,y);
		if(!book[y]){book[y]=true;siz++;}
	}
	printf("%lld",(9*po(10,siz-1))%mod);return 0;//拜拜程序~
}

```



---

## 作者：emptysetvvvv (赞：82)

## 并查集 $\mathcal{ST}$表

### 背景

小萌新$\varnothing$清晰的记得教练讲过此题，只怨她自己太不努力了，模拟赛时一点也写不出来，难过。

### 思路

- 题目的限制条件是某些位置必须填一样的数字，先考虑最朴素的可行方法，对于区间 $[l_1,r_1]$ 和 $[l_2,r_2]$，我们一一把对应位置加入同一集合，即合并 $l_1+i$ 和 $l_2+i$，其中 $0\leqslant i\leqslant r_1-l_1+1$。同一集合内的所有位置，填的数字必须相同，故设 $S$ 为集合数量，则 $ans=9\cdot \displaystyle10^{S-1}$，这是由于每个集合可以填 $0$至$9$ 共有$10$种选择，含最高位的集合不能选$0$ 只有$9$种选择。复杂度 $O(n^2\log n)$。

- 考虑优化，相信很多人看到此题想到的是 在线段树上做并查集，仅仅实现难度就有点大。容易发现，既然不需要在线询问，我们自然而然的想到了$\mathtt{st}$表。

总思路：**将询问区间拆分成 若干个小区间（不多于 $\log n$ 个），将 区间与区间 合并，最后计算答案时 将区间的信息下放到点上。**

具体的来讲：**$fa[i][k]$ 表示【左端点为 位置 $i$，长度为 $2^k$ 的区间】所在集合的根 的左端点**

>举个例子，初始所有的 $fa[i][k]=i(k\in[0,\log n])$，将区间 $[5,8]$ 合并到区间 $[1,4]$上后，有 $fa[5][2]=1$（区间 $[1,4]$ 的左端点）。

**最终计算答案时，将所有层的对应端点合并即可，做法是将每层和他的上层合并 即将 $[i][k-1]$ 与 $[find(i,k)][k-1]$ 合并，将 $[i+2^{k-1}][k-1]$ 与 $[find(i,k)+2^{k-1}][k-1]$ 合并**。详见代码。复杂度 $O(n\log^2 n)$。

### 代码

```cpp
#include <cmath>
#include <cstdio>
#include <iostream>
using namespace std;
const int maxn = 100005, mod = 1000000007;
int n, m, fa[maxn][18], ans;
int find(int x, int k) {
	return fa[x][k] == x ? x : fa[x][k] = find(fa[x][k], k);
}
void merge(int x, int y, int k) {
	x = find(x, k), y = find(y, k);
	if(x != y) fa[x][k] = y;
}
int main() {
	scanf("%d %d", &n, &m);
	const int maxk = floor(log2(n));
	for(int i = 1; i <= n; ++i)
		for(int k = 0; k <= maxk; ++k)
			fa[i][k] = i;			
	for(int i = 1, l1, r1, l2, r2; i <= m; ++i) {
		scanf("%d %d %d %d", &l1, &r1, &l2, &r2);
		for(int k = maxk; ~k; --k)
			if(l1+(1<<k)-1 <= r1) merge(l1, l2, k), l1 += 1<<k, l2 += 1<<k;
	}	
	for(int k = maxk; k; --k)
		for(int i = 1; i+(1<<k)-1 <= n; ++i) {
			int pos = find(i, k);
			merge(i, pos, k-1), merge(i+(1<<k-1), pos+(1<<k-1), k-1);
		}
	for(int i = 1; i <= n; ++i)
		if(fa[i][0] == i) ans = !ans ? 9 : ans * 10ll % mod;
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：Cry_For_theMoon (赞：46)

&emsp;&emsp;[传送门](https://www.luogu.com.cn/problem/P3295)

&emsp;&emsp;尝试写一篇能让初学倍增的新人可以看懂的题解QwQ

&emsp;&emsp;$O(nm)$ 30pts的并查集做法是橙题水平，不必赘述。

&emsp;&emsp;显然从优化合并区间开始考虑

&emsp;&emsp;并查集的合并**是满足结合律**的，就是说如果区间 $A$ 和 $B$ 合并，令 $A'$ 是 $A$ 的一个子区间， $B'$ 是 $B$ 的一个子区间，那么合并 $A,B$ 可以看作合并 $A',B'$，合并 $(A-A'),(B-B')$；最后两者合并。也就是两个区间合并，分别拆成两个子区间，第一个区间和第二个区间拆出来的第一个子区间合并，拆出来的第二个子区间合并，然后两个合并完了以后再合并。**拆出来的两个子区间可以有交集，但是它们的并集必须是原区间**。非常绕，但这是这道题乃至许多能用倍增优化的题目的一个重要性质

&emsp;&emsp;倍增显然是针对 $2^k$ 来进行的，根据上面的性质，合并两个长度为 $l$ 的区间，是可以拆成四个长度为 $k$ 的区间的，满足 $k$ 是最大的满足 $2^k <= l$ 的整数。这样对于每个区间，它们拆出来的两个子区间的交集都等于原来的区间。这个方法在 st 表里也出现过，证明稍微想一下就明白了。

&emsp;&emsp;问题变成了若干个长度为 $2^k$ 的区间合并。既然长度是 $2^k$ 了，不妨不向下传递，直接设 $f(i,k)$ 是以 $i$ 为起点长度为 $2^k$ 的区间在并查集上的父亲，这样其实就开了 $\log_2n$ 个并查集。每次合并的时候直接合并 $f(i,k)$ 和 $f(j,k)$ 就可以了

&emsp;&emsp;最后我们求的显然是 $k=0$ 这一层祖先不同的数量，所以合并完之后还要考虑怎么向下传递，即把向上合并的过程转化成向下拆分的过程。因为合并**只在同一层进行（即 $k$ 相等）**，那么若存在两个不同的 $i,j$ 满足 $find(i,k) = find(j,k)$，说明它们在第 $k$ 层的祖先相同，即它们**连通**。连通这个概念在很多题解中都有提及，我们可以将其两个区间连通视作两个区间**必须完全相同**（就是题目中的约束）。

&emsp;&emsp;根据一开始的结合律，两个区间合并（合并完自然连通，连通一定是因为合并，两者可以视作等价），这两个区间祖先相同可以变成**它们拆分后得到的四个子区间**祖先相同。那么**合并四个子区间就可以了**，既然这里区间长度是 $2$  的指数，子区间长度应该直接就是 $2^{k-1}$。其实我们发现和上面的区间合并差不多，只是这里长度比较好做。此时我们发现就把上一层的信息传递到了下一层。

&emsp;&emsp;最后传递到第一层（$k=0$），统计这一层几个祖先不相同的，设数量为 $cnt$，答案就是 $9\,*\,10^{cnt-1}$，这是因为第一位不能选 $9$。

```cpp
//SCOI,2016
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
const int MAXN=1e5+10,MODER=1e9+7;
int n,m,fa[MAXN][30],power[30],vis[MAXN];
int l1,l2,r1,r2,cnt;
long long ans;
int find(int x,int k){
	if(fa[x][k] == x)return x;
	return fa[x][k] = find(fa[x][k],k); 
}
long long getpow(int n){
	if(n==0)return 1;
	if(n==1)return 10;
	long long tmp = getpow(n/2);
	tmp = (tmp*tmp) % MODER;
	if(n&1){
		tmp = (tmp*10)%MODER;
	}
	return tmp;
}
int main(){
	scanf("%d%d",&n,&m);
	power[0] = 1;
	for(int i=1;i<=20;i++){
		power[i] = power[i-1]<<1;
	}
	for(int idx=0;power[idx]<=n;idx++){
		for(int i=1;i+power[idx]-1<=n;i++){
			fa[i][idx] = i; //这里并查集按层，每一层祖先互不相同即可 
		}
	}
	for(int i=1;i<=m;i++){
		scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
		int idx = log(r1-l1+1)/log(2);
		int fl1 = find(l1,idx);
		int fl2 = find(l2,idx);
		fa[fl1][idx] = fl2;
		int fr1 = find(r1-power[idx]+1,idx);
		int fr2 = find(r2-power[idx]+1,idx);
		fa[fr1][idx] = fr2;
	}
	for(int idx=log(n)/log(2);idx>=1;idx--){
		//拆分每个区间
		for(int i=1;i+power[idx]-1<=n;i++){
			int f = find(i,idx);
			if(f==i)continue;
			int fa1 = find(i,idx-1);
			int fa2 = find(f,idx-1);
			fa[fa1][idx-1] = fa2;
			fa1 = find(i+power[idx-1],idx-1);
			fa2 = find(f+power[idx-1],idx-1);
			fa[fa1][idx-1] = fa2;
		}
	}
	for(int i=1;i<=n;i++){
		int f = find(i,0);
		if(!vis[f]){
			cnt++;
			vis[f] = 1;
		}
	} 
	ans = (9 * getpow(cnt-1) )%MODER;
	printf("%lld\n",ans);
	return 0;
} 
```


---

## 作者：hs_black (赞：28)

#### [P1502]("https://www.luogu.org/problem/P1502")

## st表 + 并查集

回顾:**st表**

f\[i][j] 为序列中 i ~ i + $2^j$ - 1中的最大(小)值

预处理 f\[i][0] = $a_i$ , f\[i][j+1] = max(f\[i][j], f\[i + (1 << j)][j]) 

查询 : 对于区间[l, r], 我们将它分解为[l, $2^k$], 和[r - $2^k$ + 1, r]两个区间, 它们可能会有重叠, 但取max并不会影响区间最值

回到本题: 

![](https://cdn.luogu.com.cn/upload/image_hosting/qosysovx.png)

如图, 由题意将[l1, r1]\(黑), [l2, r2]\(绿)合并

应用st表思想

![](https://cdn.luogu.com.cn/upload/image_hosting/7xf7k8g6.png)

可以看成将两个红色区间合并, 两个橙色区间合并, 有重复并不影响答案, 因为他只是维护了等量关系

合并可以利用并查集维护

最后枚举从大到小枚举len, 将大区间的等量关系下放到两个小区间上, 最后统计答案即可

代码:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N = 100050;
int f[N][25];
int read(void) {
	int x = 0;
	char c = getchar();
	while (!isdigit(c)) c = getchar();
	while (isdigit(c)) {
		x = (x << 3) + (x << 1) + c - '0';
		c = getchar();
	}
	return x;
}
int n, m;
int find(int x,int y) {
	if (f[x][y] == x) return x;
	return f[x][y] = find(f[x][y], y);
} //找爹
inline void merge(int x,int y,int len) {
	int fx = find(f[x][len], len), fy = find(f[y][len], len);
	f[f[fx][len]][len] = fy;
} //合并
int lo[N];
const int P = 1e9+7;
int main() {
	n = read(), m = read();
	lo[0] = -1;
	for (int i = 1;i <= n; i++) lo[i] = lo[i/2]+1; // 预处理log2(k)
	for (int i = 1;i <= n; i++) 
		for (int j = 0;j <= 21; j++) 
			f[i][j] = i;
	while (m--) {
		int l1 = read(), r1 = read(), l2 = read(), r2 = read();
		int len = lo[r1 - l1 + 1];
		merge(l1, l2, len); //分成两个小区间
		l1 = r1 - (1 << len) + 1, l2 = r2 - (1 << len) + 1;
		merge(l1, l2, len);
	}
	for (int len = 21;len >= 1; len--) {
		for (int i = 1;i + (1 << len) - 1 <= n; i++) {
			int fa = find(i, len);
			if (fa != i) {
				merge(i, fa, len-1); //大区间分裂成两个小区间
				merge(i + (1 << (len-1)), fa + (1 << (len-1)), len - 1);
			}
		}
	}
	long long ans = 0;
	for (int i = 1;i <= n; i++) {
		if (f[i][0] == i) {
			if (ans == 0) ans = 9;
			else ans = ans * 10 % P;
		}
	}
	cout << ans % P << endl;
	return 0;
}
```



---

## 作者：埃罗芒阿老师· (赞：21)

思路:{


自己写的时候脑抽了。。。。竟然以为是一个后缀数组的逆序问题。。。。。


我们想，对于一个位置，和他连接的必然值和他相同，这让我们想到了并查集。


那最后乘法原理得出的解就是9\*10^(连通块的个数-1)(最高位为0的情况排除！)


然而数据范围给力。考虑优化。数据范围得知大致为O(nlogn)，嗯想到辣倍增


处理f[i][j]为i---i+2^j-1的所属连通块，在每次限制的时候，倍增修改一下。


最后把大的推广到小的，即f[i][j]->f[i][j-1]和f[i+(1<<j)][j-1]，


再查询一下连通块数量都可以辣！！！！真是妙极辣！！！！！


```cpp
}
#include<bits/stdc++.h>
#define RG register
#define il inline
#define N 100010
#define MOD 1000000007
#define LL long long
using namespace std;
int f[21][N],n,m,cnt;LL Ans=9;
int find(int x,int y){if(f[y][x]!=x)f[y][x]=find(f[y][x],y);return f[y][x];}
void merge(int x,int y,int len){
  if(find(x,len)!=find(y,len))
    f[len][f[len][x]]=f[len][y];
}
int main(){
  scanf("%d%d",&n,&m);for(int j=0;j<=20;++j)for(int i=1;i<=n;++i)f[j][i]=i;
  for(int i=1;i<=m;++i){
    int a,b,c,d;scanf("%d%d%d%d",&a,&b,&c,&d);
    for(int j=20;j!=-1;j--)
      if(a+(1<<j)-1<=b)merge(a,c,j),a+=1<<j,c+=1<<j;
  }
  for(int j=20;j;j--)
    for(int i=1;i+(1<<j)-1<=n;++i)
      merge(i,find(i,j),j-1),
    merge(i+(1<<(j-1)),f[j][i]+(1<<(j-1)),j-1);
  for(int i=1;i<=n;++i)if(find(i,0)==i)cnt++;
  for(int i=1;i<cnt;++i)Ans*=10,Ans%=MOD;cout<<Ans;
  return 0;
}
```

---

## 作者：lsj2009 (赞：17)

### Solution

lxl 上课讲的做法，题解区里竟然没有/jy

我们考虑开一个并查集，将所有的 $k\in [0,r1-l1]$ 将 $l1+k$ 和 $l2+k$ merge 在一起。

这样子直接做最差是 $\Theta(nq)$ 的，显然过不去。

考虑优化。我们发现，复杂度浪费在了，有一些点本来已经是相同的了，但是我们又把他 merge 了一遍，所以浪费了大量时间。我们考虑对序列进行哈希，每次二分找到最近的不相同的节点，然后把他们 merge 起来，再把所有和他们位置相同的节点的哈希值改掉。

我们考虑使用线段树动态维护哈希值，并查集启发式合并，由于每个节点都只会被合并 $\log$ 次，然后每次需要花费 $\log$ 的代价更改哈希值，所以复杂度是 $\Theta(q\log^2{n})$。

这个做法比题解区里大部分做法要强的一点是可以支持在线时时询问和修改，但是常数太大，我的实现在吸氧情况下最慢点跑了 900ms。

### Code

```cpp
#include<bits/stdc++.h>
//#define int long long
#define ll long long
#define ull unsigned long long
#define ld long double
#define PII pair<int,int>
#define INF 0x3f3f3f3f
#define INFLL 0x3f3f3f3f3f3f3f3f
#define chkmax(a,b) a=max(a,b)
#define chkmin(a,b) a=min(a,b)
#define rep(k,l,r) for(int k=l;k<=r;++k)
#define per(k,r,l) for(int k=r;k>=l;--k)
#define cl(f,x) memset(f,x,sizeof(f))
using namespace std;
const int N=1e5+5,MOD=1e9+7;
const ull base=1145141;
ull p[N];
int fa[N],n,m;
vector<int> vec[N];
struct node {
    int l,r; ull val;
}; node tree[N<<2];
#define ls(k) (k<<1)
#define rs(k) (k<<1|1)
void push_up(int k) {
    tree[k].val=tree[ls(k)].val*p[tree[rs(k)].r-tree[rs(k)].l+1]+tree[rs(k)].val;
}
void build(int k,int l,int r) {
    tree[k].l=l; tree[k].r=r;
    if(l==r) {
        tree[k].val=l;
        return;
    }
    int mid=(l+r)>>1;
    build(ls(k),l,mid);
    build(rs(k),mid+1,r);
    push_up(k);
}
void update(int k,int qx,int val) {
    if(tree[k].l==tree[k].r) {
        tree[k].val=val;
        return;
    }
    if(qx<=tree[ls(k)].r)
        update(ls(k),qx,val);
    else
        update(rs(k),qx,val);
    push_up(k);
}
int query(int k,int ql,int qr) {
    if(ql<=tree[k].l&&tree[k].r<=qr)
        return tree[k].val;
    if(qr<tree[rs(k)].l)
        return query(ls(k),ql,qr);
    else if(ql>tree[ls(k)].r)
        return query(rs(k),ql,qr);
    else
        return query(ls(k),ql,qr)*p[min(tree[k].r,qr)-tree[rs(k)].l+1]+query(rs(k),ql,qr);
}
void init() {
    p[0]=1;
    rep(i,1,n)
        p[i]=p[i-1]*base;
    rep(i,1,n)
        fa[i]=i,vec[i].push_back(i);
    build(1,1,n);
}
int find(int x) {
    if(fa[x]!=x)
        fa[x]=find(fa[x]);
    return fa[x];
}
void merge(int u,int v) {
    u=find(u); v=find(v);
    if(u==v)
        return;
    if(vec[u].size()<vec[v].size())
        swap(u,v);
    for(auto x:vec[v]) {
        update(1,x,u);
        vec[u].push_back(x);
    }
    fa[v]=u;
    vec[v].clear();
}
int get_diff(int l1,int r1,int l2,int r2) {
    int l=1,r=r1-l1+1,ans=-1;
    while(l<=r) {
        int mid=(l+r)>>1;
        if(query(1,l1,l1+mid-1)!=query(1,l2,l2+mid-1))
            ans=mid,r=mid-1;
        else
            l=mid+1;
    }
    return ans;
}
signed main() {
    scanf("%d%d",&n,&m);
    init();
    while(m--) {
        int l1,r1,l2,r2;
        scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
        while(true) {
            int val=get_diff(l1,r1,l2,r2);
            if(val==-1)
                break;
            merge(l1+val-1,l2+val-1);
            l1+=val; l2+=val;
        }
    }
    int ans=9;
	bool flag=false;
    rep(i,1,n) {
        if(find(i)==i) {
			if(flag)
				ans=ans*10ll%MOD;
			flag=true;
		}
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Tgotp (赞：11)

令$f[i][j]$表示区间$[i,i+ 2^j-1]$的编号

两区间编号相同则区间相同

显然对于一个限制$(l_1,r_1,l_2,r_2)$

令$k = log_{2}\ {r_1-l_1 + 1}$

可以化为区间$[l_1,l_1+2^k-1],[r_1-2^k+1,r_1]$分别与区间$[l_2,l_2+2^k-1],[r_2-2^k+1,r_2]$相同

考虑两相同区间在拆分之后也还是相同，即要保证对于不同位置拆开以后得到的区间编号仍然相同，那么考虑从大到小枚举$j$，每次将区间$[i,i+2^j-1]$分为$[i,i+2^{j-1}-1],[i+2^{j-1},i+2^j-1]$，记录一下这两区间编号，因为枚举的$j$,区间相同的标号也一定相同，那么递推一下就能得到答案

c++代码如下：
```c++

#include<bits/stdc++.h>
#define rep(i,x,y) for(register int i = x;i <= y; ++ i)
#define repd(i,x,y) for(register int i = x;i >= y; -- i)
using namespace std;
typedef long long ll;
template<typename T>inline void read(T&x)
{
	char c;int sign = 1;x = 0;
	do { c = getchar(); if(c == '-') sign = -1; }while(!isdigit(c));
	do { x = x * 10 + c - '0'; c = getchar(); }while(isdigit(c));
	x *= sign;
}

const int N = 1e5 + 50,M = 4e6 + 50,mod = 1e9 + 7;
int lg[N];
int f[N][21];
int ch[M][2];
int p[M],vis[M];
int cnt,n,m;

inline int get_fa(int x) { return p[x] == x ? x : p[x] = get_fa(p[x]); }

int main()
{
	read(n); read(m);
	rep(i,2,n) lg[i] = lg[i>>1] + 1;
	rep(i,1,M-50) p[i] = i;
	rep(i,1,m)
	{
		int l1,r1,l2,r2;
		read(l1); read(r1); read(l2); read(r2);
		if(l1 == l2) continue;

		int k = lg[r1 - l1 + 1];

		++ cnt;
		if(f[l1][k]) p[get_fa(f[l1][k])] = cnt;
		if(f[l2][k]) p[get_fa(f[l2][k])] = cnt;
		f[l1][k] = cnt; f[l2][k] = cnt;

		++ cnt;
		if(f[r1-(1<<k)+1][k]) p[get_fa(f[r1-(1<<k)+1][k])] = cnt;
		if(f[r2-(1<<k)+1][k]) p[get_fa(f[r2-(1<<k)+1][k])] = cnt;
		f[r1-(1<<k)+1][k] = cnt; f[r2-(1<<k)+1][k] = cnt;
	}

	repd(j,20,1) rep(i,1,n) if(f[i][j])
	{
		f[i][j] = get_fa(f[i][j]);
		if(!ch[f[i][j]][0]) 
			ch[f[i][j]][0] = ++ cnt,
			ch[f[i][j]][1] = ++ cnt;

		if(f[i][j-1]) p[get_fa(f[i][j-1])] = get_fa(ch[f[i][j]][0]);
		if(f[i+(1<<j-1)][j-1]) p[get_fa(f[i+(1<<j-1)][j-1])] = get_fa(ch[f[i][j]][1]);

		f[i][j-1] = get_fa(ch[f[i][j]][0]);
		f[i+(1<<j-1)][j-1] = get_fa(ch[f[i][j]][1]);
	}

	int ans = 9,num = 0;
	rep(i,1,n) if(!f[i][0]) f[i][0] = ++ cnt;
	vis[get_fa(f[1][0])] = 1;
	rep(i,1,n) if(!vis[get_fa(f[i][0])])
		vis[get_fa(f[i][0])] = 1,
		ans = 1ll * ans * 10 % mod;

	cout << cnt<< ' ' << num << endl;

	printf("%d\n",ans);

	return 0;
}
```


---

## 作者：Unnamed114514 (赞：11)

首先，将 $[l_1,r_1]=[l_2,r_2]$ 转化为 $\forall i\in[0,r_1-l_1),s{l_1+i}=s{l_2+i}$。

注意到这个等式可以用并查集维护，令集合个数为 $k$，答案就是 $9\times10^{k-1}$。时间复杂度最坏是 $O(n^2)$，考虑优化。

首先容易想到将小的查询合并，从而得到大的查询块。所以考虑分块，令块长为 $T$。

注意到如果直接对序列分块，每次查询散落在块中的不同位置，整块会被分割，直接维护整块较难。

所以我们可以略微修改一下我们分块的做法：从每个点都扩展 $T$ 个元素作为一个块，可以考虑整块和散块都开一个并查集维护。

那么此时我们可以直接从每个询问的左端点开始往右跳整块，整块之间合并，剩下的小块之间也要合并，时间复杂度为 $O(\frac{nm}{T})$。

注意到一个点所在的散块是一个集合，在对应的整块中还有 $T$ 个集合。

我们可以直接合并一个元素和它所在的整块中所对应的元素所在的集合，时间复杂度 $O(nT)$。

$n,m$ 同阶，所以时间复杂度为 $O(\frac{n^2}{T}+nT)$，均摊复杂度，$T=\sqrt{n}$，时间复杂度 $O(n\sqrt{n})$。

---

## 作者：Infiltrator (赞：8)

[$\Large\color{#FFBBFF}\textit{Tian-Xing's blog}$](https://Tian-Xing.github.io)

------------

# Description

[传送门](https://www.luogu.com.cn/problem/P3295)

------------

# Solution

首先先考虑如果限制不是区间，而是告诉你两个位置的字符相等的做法。

这样的话，我们可以把相等的位置加进一些集合里，最后答案就是$9 \times 10 ^ {num - 1}$，其中$num$代表不同的集合个数，这个可以简单地用并查集维护连通性。

那么如果是两个区间的话，考虑最暴力的做法，直接把区间里对应的点加进一个集合然后按单点跑，这样肯定是过不了的，考虑优化。

首先发现区间相等这个性质满足结合律，即

$$Merge(l1, r1, l2, r2) = Merge(Merge(l3, r3, l4, r4), Merge(l5, r5, l6, r6))$$

其中满足

$$[l3, r3] \cup [l4, r4] = [l1, r1]$$

$$[l5, r5] \cup [l6, r6] = [l2, r2]$$

这样的话我们就不用一个一个枚举区间里的位置加进并查集，而是可以像$st$表一样将每两个区间拆成四个$2$的幂次的形式的区间的并，将这四个区间分别加入两个并查集。

所有的区间都拆完之后我们发现现在维护连通性的都是$2$的幂长度的区间，而我们需要的是长度为$1$的区间的连通信息。这样我们可以考虑将区间下放，将每个区间拆成两个等长的区间，发现对于一个并查集里的任意一个区间，只把它和这个集合的代表元素拆开就行。

所以每一层最多下放$n$个区间，一共有$\log_n$层，那么复杂度就是$O(nlog_n)$的。当然这里没有考虑并查集的复杂度。

------------

# Code

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

const int N = 100000;
const int MOD = 1000000007;

int n, m, fa[N + 50][25], lg[N + 50], ans;

int Ksm(int a, int b)
{
	int tmp = 1;
	b = b % (MOD - 1);
	while (b)
	{
		if (b & 1) tmp = 1LL * tmp * a % MOD;
		a = 1LL * a * a % MOD;
		b >>= 1;
	}
	return tmp;
}

int Find(int x, int k)
{
	return fa[x][k] == x ? x : fa[x][k] = Find(fa[x][k], k);
}

void Merge(int l1, int l2, int k)
{
//	cout << l1 << " " << l2 << " " << k << endl;
	int fu = Find(l1, k), fv = Find(l2, k);
	if (fu == fv) return;
	fa[fu][k] = fv;
	return;
}

void Pushdown()
{
	for (int j = lg[n]; j >= 1; j--)
		for (int i = 1; i + (1 << j) <= n; i++)
		{
			int x = Find(i, j);
			if (x == i) continue;
	//		cout << i << " " << x << endl;
			Merge(i, x, j - 1);
			Merge(i + (1 << j - 1), x + (1 << j - 1), j - 1);
		}
	return;
}

int main()
{
	scanf("%d%d", &n, &m);
	lg[0] = -1;
	for (int i = 1; i <= n; i++) lg[i] = lg[i >> 1] + 1;
	for (int i = 1; i <= n; i++)
		for (int j = 0; j <= lg[n]; j++)
			fa[i][j] = i;
	for (int i = 1, l1, l2, r1, r2; i <= m; i++)
	{
		scanf("%d%d%d%d", &l1, &r1, &l2, &r2);
		int length = r1 - l1 + 1;
		Merge(l1, l2, lg[length]);
		Merge(r1 - (1 << lg[length]) + 1, r2 - (1 << lg[length]) + 1, lg[length]); 
	}
	Pushdown();
	for (int i = 1; i <= n; i++) if (fa[i][0] == i) ans++;
	printf("%d", 9LL * Ksm(10, ans - 1) % MOD);
	return 0;
} 
```

---

## 作者：hzoi_liuchang (赞：8)


## 分析

如果暴力解决的话就是使用并查集把位数相同的数位并在一起。比如区间[1,2]和区间[3,4]的数字完全相同，那么我们就把1和3并在一起，在把2和4并在一起，这样它们的祖先相同，就相当于把它们绑定在了一起，同一个祖先它们的数字必定相同。这样我们只要最后统计独立的并查集的个数就可以了。我们设个数为n，这样最终的方案数就是9$\times$10$^{n-1}$，因为除了最高位，所有位的数字都可以取到0~9

但是这样的效率是不能接受的，我们可以使用倍增的思想优化，我们定义fa[x][y]为以x为起点长度为2$^y$的父亲，这样的话，读入解决了。那么最后的统计呢，我们再逐层下放至长度为1的区间就可以了，下放的时候不要忘了将每一层和它的上一层合并。

## 代码

``` cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=100010,mod=1e9+7;
int fa[22][maxn];
int zhao(int xx,int yy){
	if(fa[yy][xx]==xx) return xx;
	return fa[yy][xx]=zhao(fa[yy][xx],yy);
}
void bing(int xx,int yy,int l){
	if(zhao(xx,l)!=zhao(yy,l))fa[l][fa[l][xx]]=fa[l][yy];
}
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=0;i<=20;i++){
		for(int j=1;j<=n;j++){
			fa[i][j]=j;
		}
	}
	for(int i=1;i<=m;i++){
		int aa,bb,cc,dd;
		scanf("%d%d%d%d",&aa,&bb,&cc,&dd);
		for(int j=20;j>=0;j--){
			if(aa+(1<<j)-1<=bb){
				bing(aa,cc,j);
				aa+=1<<j,cc+=1<<j;
			}
		}
	}
	for(int i=20;i;i--){
		for(int j=1;j+(1<<i)-1<=n;j++){
			bing(j,zhao(j,i),i-1);
			bing(j+(1<<(i-1)),fa[i][j]+(1<<(i-1)),i-1);
		}
	}
	int cnt=0;
	for(int i=1;i<=n;i++){
		if(zhao(i,0)==i) cnt++;
	}
	long long ans=9;
	for(int i=1;i<cnt;i++) ans*=10,ans%=(long long)mod;
	printf("%lld\n",ans);
	return 0;
}
```



---

## 作者：LoganC (赞：4)

我们用ST表，f[i,j]表示[i,i+2^j-1]这一段。

那么初始时每一段单独成一个集合。

对于一个限制可以拆成log 份，然后进行集合合并。

然后呢，如果任意ST[s,t]和ST[i,j]属于同一集合，那么ST[s,t-1]与ST[i,j-1]以及ST[s+2^(t-1)-1,t-1]和f[i+2^(j-1)-1,j-1]都应该属于同一集合。

为了满足这个限制，只要最后再一层一层的做，把下一层的合并了即可。

合并注意必须让编号大的合进编号小的里。

统计答案就很简单啦，答案是9\*10^(集合个数-1)，具体看代码。





    
            
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 1e9 + 7;
const int LGN = 18;
const int maxn = 100000 + 20;
int n,m,l1,l2,r1,r2;
int cnt=0,fa[maxn*LGN],ST[maxn][20],sta[maxn*LGN];
int read(){
    int ret = 0;char c = getchar();
    while(c<'0' || c> '9')    c=getchar();
    while(c>='0'&&c<='9')    ret=ret*10+c-'0',c=getchar();
    return ret;
}
int find(int x){
    return fa[x]==x ? x : fa[x] = find(fa[x]);
}
void merge(int l1,int l2,int k){
    int f1 = find(ST[l1][k]);    int f2 = find(ST[l2][k]);
    if(f1>f2)    swap(f1,f2);     
    fa[f2] = f1;
}
int main(){
    n=read();    m=read();
    if(n==1)    printf("10\n");
    else{
        for(int j=0;j<=LGN;j++)
            for(int i=1;i+(1<<j)-1<=n;i++)
                ST[i][j] = ++cnt , sta[cnt] = i , fa[cnt] = cnt;  
        for(int i=1;i<=m;i++){
            l1 = read();    r1 = read();    l2 = read();    r2 = read();
            for(int j = LGN; j >= 0; j--){
                if(l1+(1<<j)-1<=r1){
                    merge(l1,l2,j);    
                    l1 += (1<<j) ;    l2 += (1<<j) ;
                }
            }
        }
        for(int j = LGN ; j >=1 ;j--)
            for(int i=1 ; i + (1<<j) -1 <= n; i++ )    {
                int f = find(ST[i][j]);    int s = sta[f];         
                merge(i,s,j-1);    
                merge(i+(1<<j-1),s+(1<<j-1),j-1);
            }
        int ans = 9;
        for(int i=2;i<=n;i++)
            if(fa[ST[i][0]]==ST[i][0])    {
            ans = 1ll * ans * 10 % mod;                
        }
        printf("%d\n",ans);    
    }
    return 0;    
}
```

---

## 作者：红色OI再临 (赞：3)

# SCOI2016萌萌哒题解



[题目链接](https://www.luogu.org/problem/P3295)

------


### 思路

这个题目大概就是给你一些限制，使区间相等，那么一个很巧妙的思路就是将区间限制转化为两个店在一个并查集里

我们要求的是只有一位的并查集的个数，答案为$9*10^{t-1}$
（ t我们要求的是只有一位的并查集的个数)

但直接操作复杂度过大

于是~~有人~~想到了倍增

`f[i][j]`表示区间[$i$ , $i+2^{j-1}-1$]所在的并查集

最开始时记录每个大区间的左右儿子

输入 `l1` `l2` `r1` `r2`时像ST表一样合并

再分别处理每个大区间，如果`f[i][j]`和`f[a][b]`在一个并查集里，那么他们的左右儿子也在一个并查集里，我们就能将大区间合并信息下传为左右儿子的合并（左儿子与左儿子合并，右儿子与右儿子合并）

最后统计`f[i][0]`的并查集个数即可

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define re register int
#define ll long long
#define MN 1000050
#define mod 1000000007
using namespace std;
int bcj[MN*22],f[MN][22],lc[MN*22],rc[MN*22],lg[MN];
int n,m,k,ltk,cnt;
int find(int x){
	if(x==bcj[x])return x;
	bcj[x]=find(bcj[x]);
	return bcj[x];
}
void merge(int x,int y){
	int t1=find(x),t2=find(y);
	if(t1!=t2)bcj[t2]=t1;
}
int main(){
	scanf("%d%d",&n,&m);
	for(re i=2;i<=n;i++)
		lg[i]=lg[i/2]+1;	
	for(re j=lg[n];j>=0;j--)
		for(re i=1;i+(1<<j)-1<=n;i++){
				f[i][j]=++cnt;
				bcj[cnt]=cnt;
		}//给大区间编号
	for(re j=1;j<=lg[n];j++)
		for(re i=1;i+(1<<j)-1<=n;i++){
			lc[f[i][j]]=f[i][j-1];
			rc[f[i][j]]=f[i+(1<<(j-1))][j-1];
		}//统计左右儿子
	for(re i=1;i<=m;i++){
		int a1,a2,a3,a4;
		scanf("%d%d%d%d",&a1,&a2,&a3,&a4);
		int l=lg[a2-a1+1];
		merge(f[a1][l],f[a3][l]);
		merge(f[a2-(1<<l)+1][l],f[a4-(1<<l)+1][l]);
	}//像st表一样合并
	for(re i=1;i<=cnt;i++){
		if(!lc[i]||!rc[i])continue;
		int t1=find(i);
		if(t1!=i){
			merge(lc[t1],lc[i]);
			merge(rc[t1],rc[i]);
			//如果f[i][j]与f[a][b]同属一个联通块，那么他们左右儿子也同属一个联通块
		}
	}
	ltk=n;
	//先假设每个位置都是独立的联通块，如果联通再减
	for(re i=1;i<=n;i++){
		if(find(f[i][0])!=f[i][0])
			ltk--;
	}
	ll ans=9;
	for(re i=1;i<ltk;i++)
		ans=(ans%mod*10)%mod;
		printf("%lld",ans%mod);
	return 0;
}
```


---

## 作者：于丰林 (赞：3)

题目大意：给出一个不定大数，给出一些限制条件，形如：区间l1,r1与l2,r2两个区间中所有的数相等，询问共有多少种合法的大数？

n<=1e5,m<=1e5

30分：

对于给出的区间限定条件，暴力枚举每一个点，利用并查集维护有相等关系的点，最后统计并查集个数，答案就是：9*10^(并查集个数-1)　　因为第一个数不为零（他可不是序列。。。

时间复杂度：并查集看作常数，那么总复杂度O(nm)，一个暴力。。。

100分：

观察暴力做法，发现维护点之间的对应关系时，暴力枚举的速度实在是太慢，但是我们还是需要知道每一个点的对应关系，所以我们考虑倍增加速。

我们在读入区间时利用二进制拆分将区间分解，再利用并查集合并，通过预处理，利用st表的思想（也不是st表，比较像而已。。。）维护f[i][j]，表示从i开始往后2^j这个区间。

那么我们紧接着枚举base（base是2的指数），每一次将区间分一半，再将利用并查集合并，最后还是查询并查集个数（枚举st[i][0]（代表每一个点））

时间复杂度：倍增确实是一个好东西，二进制拆分mlogn，区间平分nlogn，总复杂度nlogn(渐近复杂度)

最后：附上本题代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#define mod 1000000007
#define LL long long    
using namespace std;

int n,m;
LL fa[10000005],cnt,ans;
LL st[1000005][25],start[10000005];

int find(int x)
{
    if(fa[x]==x) return x;
    return fa[x]=find(fa[x]);
}
void merge(int l1,int l2,int base)
{
    int f1=find(st[l1][base]),f2=find(st[l2][base]);
    if(f1>f2) swap(f1,f2);
    fa[f2]=f1;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int j=0;j<=log2(n)+1;j++)
    {
        for(int i=1;i<=n;i++)
        {
            st[i][j]=++cnt;
            start[cnt]=i;
            fa[cnt]=cnt;
        }
    }
    for(int i=1;i<=m;i++)
    {
        int l1,r1,l2,r2;
        scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
        for(int base=log2(n)+1;base>=0;base--)
        {
            if(l1+(1<<base)-1<=r1)
            {
                merge(l1,l2,base);
                l1+=(1<<base);
                l2+=(1<<base);
            }
        }
    }
    for(int base=log2(n)+1;base>=1;base--)
    {
        for(int i=1;i+(1<<base)-1<=n;i++)
        {
            int f=find(st[i][base]),sta=start[f];
            merge(i,sta,base-1);
            merge(i+(1<<(base-1)),sta+(1<<(base-1)),base-1);
        }
    }
    ans=9;
    for(int i=2;i<=n;i++)
    {
        if(fa[st[i][0]]==st[i][0])
        {
            ans*=10;
            ans%=mod;
        }
    }
    printf("%lld\n",ans%mod);
    return 0;
}
```


---

## 作者：caidzh (赞：1)

经过思考，放弃从字符串角度考虑

从每个数字的取值角度考虑，如果说规定某些数应该相等，那么这些数字对于答案的贡献就是$10$（乘法原理），接下来我们考虑怎么维护哪些数应该相等，由于相等关系具有传递性，我们可以使用并查集来维护

定义最终连通块个数为$i$，答案就是$9\times 10^{i-1}$

可是暴力合并时间复杂度为$O(nm)$，不能过，怎么办？

利用倍增的思想，将$[x,x+2^i-1]$这一段单独提出作为一个新点，这样合并的时候只需要二进制拆分区间长度即可

如何统计答案？考虑现在的一个连通关系$[x,fa(x)]$，我们同时将$x$与$fa(x)$拆成两半，然后两者左区间相连，右区间相连，实际上并不用拆分，因为一个区间的$\frac{1}{2}$已经是一个单独提出的点了

下面的代码记录了一个区间（点）的左儿子和右儿子，类似线段树
```
#include<bits/stdc++.h>
#define int LL
#define LL long long
using namespace std;
int inline read(){
    int num=0,neg=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')neg=-1;c=getchar();}
    while(isdigit(c)){num=(num<<3)+(num<<1)+c-'0';c=getchar();}
    return num*neg;
}
const int maxn=100010,mod=1e9+7;
int n,m,fa[maxn*30],ans,id[maxn][20],tot,ls[maxn*30],rs[maxn*30];
int Pow(int x,int y){int ans=1;while(y){if(y&1)ans=ans*x%mod;x=x*x%mod;y>>=1;}return ans;}
int Find(int x){return fa[x]==x?x:fa[x]=Find(fa[x]);}
void Merge(int x,int y){x=Find(x);y=Find(y);fa[x]=y;}
signed main()
{
	n=read();m=read();
	for(int i=19;i>=0;i--)for(int x=1;x+(1<<i)-1<=n;x++)id[x][i]=++tot;
	for(int i=19;i>=1;i--)
		for(int x=1;x+(1<<i)-1<=n;x++){
			ls[id[x][i]]=id[x][i-1];
			rs[id[x][i]]=id[x+(1<<i-1)][i-1];
		}
	for(int i=1;i<=tot;i++)fa[i]=i;
	for(int i=1;i<=m;i++){
		int l1=read(),r1=read(),l2=read(),r2=read();int len=r1-l1+1;
		for(int j=19;j>=0;j--)if(len>=(1<<j)){Merge(id[l1][j],id[l2][j]);l1=l1+(1<<j);l2=l2+(1<<j);len-=(1<<j);}
	}
	for(int i=19;i>=1;i--)
		for(int j=1;j+(1<<i)-1<=n;j++){
			int x=Find(id[j][i]);Merge(ls[id[j][i]],ls[x]);Merge(rs[id[j][i]],rs[x]);
		}
	for(int i=1;i<=n;i++)if(id[i][0]==Find(id[i][0]))ans++;
	printf("%lld",9*Pow(10,ans-1)%mod);return 0;
}
```


---

## 作者：ezoixx174 (赞：1)

#### 题目链接
[BZOJ4569](https://www.lydsy.com/JudgeOnline/problem.php?id=4569)

#### 解法：倍增+并查集
先想暴力的做法。每次读入$l_1,r_1,l_2,r_2$，令$i$从$0$枚举到$r_1-l_1$，然后用并查集合并$l_1+i$和$l_2+i$，最后统计并查集中联通块的个数$s$，答案即为$9×10^{s-1}$。
但是这样会TLE。
对暴力进行优化。更改并查集中数组$f$的含义，令$f_{x,k}$表示从$x$到$x+2^k-1$这两段的共同编号，亦即若$f_{x,k}=f_{y,k}$则表示$f_x,\dots,f_{x+2^k-1}$和$f_y,\dots,f_{y+2^k-1}$这两段数每项分别处于相同的联通块中。合并时用倍增的处理方式（参考ST表）。

#### 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>

using namespace std;

const long long p=1000000007ll;
long long ans=1ll;
int n,m,l1,l2,r1,r2,f[17][100001];
bool flag=false;

int find(int x,int k){
	return f[k][x]==x?x:f[k][x]=find(f[k][x],k);
}

void merge(int x,int y,int k){
	if(y>100000)return;
	int fx=find(x,k),fy=find(y,k);
	if(fx!=fy)f[k][fx]=fy;
}

void update(int a,int b,int c,int d){
	int k=(int)log2(b-a+1);
	merge(a,c,k),merge(b-(1<<k)+1,d-(1<<k)+1,k);
}

int main(){
	scanf("%d%d",&n,&m);int l=(int)log2(n);
	for(int i=1;i<=n;++i)for(int k=0;k<17;++k)f[k][i]=i;
	for(int i=1;i<=m;++i)scanf("%d%d%d%d",&l1,&r1,&l2,&r2),update(l1,r1,l2,r2);
	for(int i=l;i;--i)for(int j=1;j<=n-(1<<i)+1;++j){int f=find(j,i);merge(j,f,i-1),merge(j+(1<<i-1),f+(1<<i-1),i-1);}
	for(int i=1;i<=n;++i)if(find(i,0)==i)(ans*=(flag?10:((flag=true),9)))%=p;
	printf("%lld",ans);
}
```

---

## 作者：bztMinamoto (赞：1)

更好的阅读体验->[这里](https://www.cnblogs.com/bztMinamoto/p/9812565.html)

思路太妙了啊……

容易才怪想到暴力，把区间内的每一个数字用并查集维护相等，然后设最后总共有$k$个并查集，那么答案就是$9*10^{k-1}$（因为第一位不能为0）

考虑倍增。我们设$f[i][j]$表示区间$[i,i+2^j-1]$，那么我们可以把原区间给拆成$log$个区间，然后维护这些区间的连通性

然而我们最后需要的是最底层的，也就是单独的节点的连通性。那么我们考虑如何将连通性向下传递。如果$f[i][j]$和$f[a][b]$连通，那么$f[i][j-1]$和$f[a][b-1]$一定连通（前半部分区间），$f[i+2^{j-1}][j-1]$和$f[a+2^{b-1}][b-1]$也一定连通

ps：连通性肯定都在同一层，所以实际上上面的$j$和$b$一般都是相等的

然后只要最后判最底层有几个并查集就好了
```
//minamoto
#include<iostream>
#include<cstdio>
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
const int N=1e5+5,mod=1e9+7;
int fa[N*17],id[N][21],num[N*17],log[N*17],bin[21],is[N*17],h[N*17],tot=0,cnt;
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
void merge(int x,int y){
	x=find(x),y=find(y);
	if(h[x]<h[y]) fa[x]=y;
	else if(h[x]>h[y]) fa[y]=x;
	else fa[x]=y,++h[y];
}
int ksm(int b){
	int res=9,a=10;
	while(b){
		if(b&1) res=1ll*res*a%mod;
		a=1ll*a*a%mod,b>>=1;
	}
	return res;
}
int main(){
//	freopen("testdata.in","r",stdin);
	int n=read(),m=read();
	bin[0]=1;for(int i=1;i<=16;++i) bin[i]=bin[i-1]<<1;
	for(int j=0;j<=16;++j) for(int i=1;i<=n;++i) id[i][j]=++tot,num[tot]=i,fa[tot]=tot,h[tot]=1;
	while(m--){
		int l1=read(),r1=read(),l2=read(),r2=read();
		for(int i=16;i>=0;--i) if(l1+bin[i]-1<=r1){
			merge(id[l1][i],id[l2][i]),l1+=bin[i],l2+=bin[i];
		}
	}
	for(int j=16;j;--j) for(int i=1;i+bin[j]-1<=n;++i){
		int x=find(id[i][j]),a=num[x];
		merge(id[a][j-1],id[i][j-1]),merge(id[a+bin[j-1]][j-1],id[i+bin[j-1]][j-1]);
	}
	for(int i=1;i<=n;++i)
	if(find(id[i][0])==id[i][0]) ++cnt;
	printf("%d\n",ksm(cnt-1));
	return 0;
}
```

---


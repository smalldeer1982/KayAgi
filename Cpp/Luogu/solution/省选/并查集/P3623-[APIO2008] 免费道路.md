# [APIO2008] 免费道路

## 题目描述

新亚（New Asia）王国有 $N$ 个村庄，由 $M$ 条道路连接。其中一些道路是鹅卵石路，而其它道路是水泥路。保持道路免费运行需要一大笔费用，并且看上去王国不可能保持所有道路免费。为此亟待制定一个新的道路维护计划。

国王已决定保持尽可能少的道路免费，但是两个不同的村庄之间都应该一条且仅由一条免费道路的路径连接。同时，虽然水泥路更适合现代交通的需要，但国王也认为走在鹅卵石路上是一件有趣的事情。所以，国王决定保持刚好 $K$ 条鹅卵石路免费。

举例来说，假定新亚王国的村庄和道路如图 3(a) 所示。如果国王希望保持两 条鹅卵石路免费，那么可以如图 3(b) 中那样保持道路 $(1, 2)$，$(2, 3)$，$(3, 4)$ 和 $(3, 5)$ 免费。该方案满足了国王的要求，因为：
1. 两个村庄之间都有一条由免费道路组成的路径。
2. 免费的道路已尽可能少。
3. 方案中刚好有两条鹅卵石道路 $(2, 3)$ 和 $(3, 4)$。

 ![](https://cdn.luogu.com.cn/upload/pic/4393.png) 

图 3：(a) 新亚王国中村庄和道路的一个示例。实线标注的是水泥路，虚线标注的是鹅卵石路。(b) 一个保持两条鹅卵石路免费的维护方案。图中仅标出了免费道路。


给定一个关于新亚王国村庄和道路的述以及国王决定保持免费的鹅卵石道路数目，写一个程序确定是否存在一个道路维护计划以满足国王的要求，如果存在则任意输出一个方案。

## 说明/提示

### 数据范围

对于 $100\%$ 的数据。保证 $1 \le N \le 2 \times 10^4$，$1 \le M \le 10^5$，$0 \le K \le N-1$。

## 样例 #1

### 输入

```
5 7 2 
1 3 0 
4 5 1 
3 2 0 
5 3 1 
4 3 0 
1 2 1 
4 2 1```

### 输出

```
3 2 0 
4 3 0 
5 3 1 
1 2 1 ```

# 题解

## 作者：Gypsophila (赞：58)

看了下题解第一篇，为什么要跑三遍kruskal呢？只跑两遍不就好了？


------------
题意：一个图边权为$0$或$1$，求一个生成树使得边权和为$k$。

（这里要注意这里说的$0$边其实是输入中给的$1$边，所以我是用题目中所说的编写代码，但文字题解中我还是用的上面这种更好理解的方式）

这道题是对kruskal算法的一个透彻使用。

题目中说要保留$k$条边，也许你会认为可以随便加，但是有一些$1$边是要必须保留的。这样才能保证图的连通性。

先以$0$边优先做一遍kruskal（就是从小到大排序），把必须要加入的$1$边个数算出。

再做一遍kruskal，先把那些必须加的加入，然后再加$1$边使得达到$k$条，然后就一直加$0$边了。

在上述过程中，有两种无解的情况：
- 图不练通
- 必须要加的边超过$k$

代码：
```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <algorithm>
#define no_solution printf("no　solution\n");
using namespace std;
　　　　　　　　　　　　　　　　　　
const int MAXN　=　20200;
const int　MAXM　=　100100;
int n,　m,　k,　fa[MAXN],　tot,　cnt;
struct edge {　　
    int u,　v,　w;　　　　
}e[MAXM], ans[MAXM];　　
bool cmp1(edge e1, edge e2) {
    return e1.w > e2.w;
}
bool cmp2(edge e1, edge e2) {
    return e1.w < e2. w;
}
int find(int x) {
    if(fa[x] == x) return x;
    else return fa[x] = find(fa[x]);
}
bool Union(int x, int y) {
    x = find(x), y = find(y);
    if(x == y) return false;
    fa[x] = y;
    return true;
}
void init() {
    cnt = tot = 0;
    for(int i = 1; i <= n; i++) fa[i] = i;
}
void check() {
    int tmp = find(1);
    for(int i = 2; i <= n; i++) {
        int f = find(i);
        if(f != tmp) {
            no_solution;
            exit(0);
        }
        tmp = f;
    }
}
int main()
{
    scanf("%d%d%d", &n, &m, &k);
    for(int i = 1; i <= m; i++) scanf("%d%d%d", &e[i].u, &e[i].v, &e[i].w);
    init(); sort(e + 1, e + m + 1, cmp1);
    for(int i = 1; i <= m; i++)
    	if(Union(e[i].u, e[i].v) && e[i].w == 0)
    			tot++, e[i].w = -1;
                
    if(tot > k) {
        no_solution;
        return 0;
    }
    check();
    init(); sort(e + 1, e + m + 1, cmp2);
    
    for(int i = 1; i <= m; i++) {
        int f1 = find(e[i].u), f2 = find(e[i].v);
        if(f1 == f2) continue;
        if(e[i].w == 1 || tot < k) {
            ans[++cnt] = e[i]; fa[f1] = f2;
            if(e[i].w < 1)
            	tot++, e[i].w = 0;
        }
    }
    if(tot　<　k) {
        no_solution;
        return　0;
    }
    check(　　);
    for(int i　=　1; i　<=　cnt; i++) {
        if(ans[i].w　==　-1)　ans[i].w = 0;
        printf("%d　%d　%d\n", ans[i].u, ans[i].v, ans[i].w);
    }
 	return 0;
}
```
不要试图复制我的代码，你会因为一些奇怪的空格花式CE

---

## 作者：Vomega (赞：30)

并查集

要求一棵有k条石子边的生成树（废话）。看起来所有的边都可以取舍，但实际上有些边是必须保留的。

不妨先把所有的水泥路都先保留着，再把石子路一条条往上加，用并查集判联通性。

此时如果有石子路可以加入的话，由于所有的水泥路都已经加上了，说明这些石子路是必须保留的，就可以直接保存在答案数组里了。

同理再求出所有必须保留的水泥路。

如果在上述求解过程中，发现石子路或水泥路的必须保留数量超出限制，必然无解。或者发现图不联通，也无解。

两次处理之后，剩下边无论怎么选都是等价的，只要控制数量符合要求就可以了。

所以要跑三遍并查集。

末尾不用检查是否合法也过了。。。应该是我在前面已经判断了吧。

代码如下

'''cpp
```cpp
#include <iostream>
using namespace std;
int read(){
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    return x;
}
struct edge{
    int u,v,o;
}e[150000];
int fa[200000],n,m,k,tot,tot1,tot2,res,ans[200000][3];
void init(){
    for(int i=1;i<=n;i++) fa[i]=i;
}
int get(int x){
    return x==fa[x]?x:fa[x]=get(fa[x]);
}
bool same(int x,int y){
    return get(x)==get(y);
}
void merge(int x,int y){
    int fax=get(x),fay=get(y);
    fa[fax]=fay;
}
int main(){
    n=read(),m=read(),k=read();
    init();
    for(int i=1;i<=m;i++){
        e[i].u=read();
        e[i].v=read();
        e[i].o=read();
        if(e[i].o) if(!same(e[i].u,e[i].v)) merge(e[i].u,e[i].v),res++;
    }
    for(int i=1;i<=m;i++){
        if(!e[i].o){
            int x=e[i].u,y=e[i].v;
            if(!same(x,y)) merge(x,y),ans[++tot][0]=x,ans[tot][1]=y,ans[tot][2]=0,res++;
            if(tot1>k){
                cout<<"no solution";
                return 0;
            }
        }
    }
    tot1=tot;
    if(res!=n-1){
        cout<<"no solution";
        return 0;
    }
    init();
    for(int i=1;i<=m;i++){
        if(!e[i].o){
            int x=e[i].u,y=e[i].v;
            if(!same(x,y)) merge(x,y);
        }
    }
    for(int i=1;i<=m;i++){
        if(e[i].o){
            int x=e[i].u,y=e[i].v;
            if(!same(x,y)) merge(x,y),ans[++tot][0]=e[i].u,ans[tot][1]=e[i].v,ans[tot][2]=1,tot2++;
            if(tot2>n-1-k){
                cout<<"no solution";
                return 0;
            }
        }
    }
    init();
    for(int i=1;i<=tot;i++){
        int x=ans[i][0],y=ans[i][1];
        merge(x,y);
    }
    for(int i=1;i<=m;i++){
        int x=e[i].u,y=e[i].v;
        if(e[i].o&&tot2<n-1-k&&!same(x,y)){
            merge(x,y);
            ans[++tot][0]=x,ans[tot][1]=y,ans[tot][2]=1;
            tot2++;
        }
        if(!e[i].o&&tot1<k&&!same(x,y)){
            merge(x,y);
            ans[++tot][0]=x,ans[tot][1]=y,ans[tot][2]=0;
            tot1++;
        }
    }
    for(int i=1;i<n;i++) printf("%d %d %d\n",ans[i][0],ans[i][1],ans[i][2]);
    return 0;
}
'''
```

---

## 作者：奏者！ (赞：20)

给大家推荐个新思路---WQS二分（~~博主是个什么沙雕~~）


第一次看到这个题第一反应就是二分（~~什么鬼？？？~~）脑膜了一下效率尚可就写了一下试试，意外发现可行。。。

所以写篇题解纪念下QWQ

**另外前置知识 [WQS二分模板（套路）题 TREE]大家可以写一下再过来，挺简单的，
下面也会讲怎么做那一道题**(https://www.luogu.org/problemnew/show/P2619)

这种~~沙雕~~特殊二分有一个非常明显的特征，打个小比方：
打一个包裹，里面必须包含n个符合某种特征的东西，且让这个包裹尽可能小（听起来很像背包，但蒟蒻我暂时没有碰过背包的题QWQ，做这个题还是第一次应用WQS二分QAQ）

先提一下WQS二分的模板题，给你一个图，但图中的边有一些特殊，边有的是黑边，有的是白边，要求让我们建一颗最小生成树，但里面必须包含n条白边。

看起来有些小头疼，但我们可以耍些小手段来达到目的，**如果我们给白边加上或减去一个值（我们现在叫它为偏移量），来控制建的最小生成树中白边的数量，很明显这个偏移量满足单调性（若偏移量小于当前偏移量，最小生成树中的白边一定会增多，大于则反之），所以我们可以应用二分来解，最后建出来的树只要减去（偏移量 * 白边数量）即可。**
~~（突然把TREE的题解水过去了）~~

**现在回到这个题上来，这个题与WQS模板题唯一的差距就是这个题里的边没有边权**那不是更好么？对树最小的要求还没有了，**~~这简直爽到！~~**

咳咳！**既然没有边权，我们就自己加上边权怎么办？当然是随机化啊！**

```c
e[i].w=rand()%101; //随机给一个边权
```

之后的思路也很明确了，直接把QWQ二分照打就好了
```cpp
if(count==k) break; //count为这一次跑最小生成树的白边（鹅卵石路）计数，因为题目只要求答案能跑就行， 所以找到直接退出就好

if(count>k) r=mid-1; 

else if(count<k) l=mid+1; //这俩行上面讲过了
```
下面就贴一下代码好了，顺便如果有大佬用这个方法过了请务必@蒟蒻我，一直被第五个点卡着QAQ
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring> 
using namespace std;
struct node{
	int u,v,w,cl;      //起点，终点，权值，颜色 
}e[1000000];

struct Node{
	int u1,v1,w1,cl1;  //同上 因为考虑到在边上加减偏移量会很麻烦且容易出错，所以我们用俩套边 
}e1[1000000];          //第一套边来存初始边的各项值，第二套边用来跑最小生成树，记得每次都要初始化 

int solve[1000000],tail=0,f[1000000];

int fr(int x){
	return x==f[x]?x:f[x]=fr(f[x]);
}

bool cmp(Node a,Node b){
	return a.w1<b.w1;
}

//void kruskal
int n,m,k;
int main(){
	srand(19260817);
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++){
		cin>>e[i].u>>e[i].v>>e[i].cl;
		e[i].w=rand()%101;
	}
	int l=-1000,r=1000,count=0,bian=0;   //count就是跑最小生成树 
	while(l<=r){
		
		int mid=(l+r)/2;
		
		//各种初始化 
		 
		kruskal(mid);                   //皮一下，最小生成树各位大佬自己写喽 
		
		if(count==k) break;
		if(count>k) r=mid-1;
		else if(count<k) l=mid+1;
	}
	if(count!=k||bian!=n-1){
		cout<<"no solution";
		return 0;
	}
    for(int i=0;i<tail;i++){
		cout<<e1[solve[i]].u1<<" "<<e1[solve[i]].v1<<" "<<e1[solve[i]].cl1<<endl;
	}
	return 0;                          //我爱return 0,return 0爱我 
}		
```
这个写法跑的最慢的点是7ms左右，还是可以接受的

感谢各位看官，求管理员大大过了吧QWQ

---

## 作者：SpXace (赞：13)

kruskal~~（好）~~水题！！！ 交了我二三十遍才过（luogu评测机您辛苦了，回头给你加个内存条哈）

大体思路两遍kruskal，第一遍先尽可能加水泥边，加完后若不联通，加鹅卵石路，注意这些鹅卵石路是必须加的，因此打上标记。

第二遍先将第一次标记的加入生成树，然后继续加鹅卵石路，直到k条，注意这里加完要判断是否小于k条，若小于则不成立，否则一直加水泥路即可。


```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define LL long long
#define rep(i, a, b) for(int i = a; i <= b; ++i)
#define per(i, a, b) for(int i = a; i >= b; --i)
#define clr(a,b)  memset((a),b,sizeof(a))
using namespace std;
inline int Read(){
	int s = 0, w = 1; char ch = getchar();
	while(ch < '0' || ch > '9')   { if(ch == '-') w = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9') { s = (s << 3) + (s << 1) + (ch ^ 48); ch = getchar(); }
	return s * w;
}
const int MX = 100010;
int N,M,k,aa = 0,es = 0,fa[MX],cnt = 0;
struct Edge{
	int x,y;
};
struct node{
	int x,y,z;
}Ans[MX];
Edge wa[MX],er[MX];
bool vis[MX];
int find(int x) {
	if(fa[x] == x) return x;
	return fa[x] = find(fa[x]);
}
void krus1() {
	clr(vis,0);
	int tot = 0,num = 0;
	rep(i, 1, N) fa[i] = i;
	rep(i, 1, aa) {
		int a = find(wa[i].x);
		int b = find(wa[i].y);
		if(a != b) {
			fa[a] = b;
			tot++;
		}
	}
	rep(i, 1, es) {
		int a = find(er[i].x);
		int b = find(er[i].y);
		if(a != b) {
			vis[i] = 1;
			tot++; num++;
			fa[a] = b;
			if(tot == N - 1) break; 
		}
	}
	if(tot < N - 1 || num > k) {
		puts("no solution"); 
		exit(0);
	}
	return;
}
void krus2() {
	int tot = 0;
	rep(i, 1, N) fa[i] = i;
	rep(i, 1, es) {
		if(vis[i] == 0) continue;
		if(tot == k) break;
		int a = find(er[i].x);
		int b = find(er[i].y);
		if(a != b) {
			Ans[++cnt] = (node){er[i].x,er[i].y,0};
			tot++;
			fa[a] = b;
		}
	}
	rep(i, 1, es) {
		if(tot == k) break;
		if(vis[i] == 1) continue;
		int a = find(er[i].x);
		int b = find(er[i].y);
		if(a != b) {
			Ans[++cnt] = (node){er[i].x,er[i].y,0};
			fa[a] = b;
			tot++;
			if(tot == k) break;
		}
	}
	if(tot < k) {
		puts("no solution"); 
		exit(0);
	}
	rep(i, 1, aa) {	
		int a = find(wa[i].x);
		int b = find(wa[i].y);
		if(a != b) {
			tot++;
			fa[a] = b;
			Ans[++cnt] = (node){wa[i].x,wa[i].y,1};
		}
	}
	return;
}
int main() {
	N = Read(), M = Read(), k = Read();
	rep(i, 1, M) {   
		int u = Read(), v = Read(), w = Read();
		if(w == 1) wa[++aa].x = u, wa[aa].y = v;
		else er[++es].x = u, er[es].y = v;
	}
	krus1();
	krus2();
	rep(i, 1, cnt) 	printf("%d %d %d\n", Ans[i].x,Ans[i].y,Ans[i].z);
	return 0;
}
```

---

## 作者：Kan_kiz (赞：6)

[[APIO2008]免费道路](https://www.luogu.org/problemnew/show/P3623)


[博客食用不知道会不会更佳](https://www.cnblogs.com/Kan-kiz/p/10783561.html)

压缩一下这题的题意。就是求原图的一个生成树，使得这个生成树里有$k$条$0$边和&n-k-1$条$$1$边。


### 中心思路：三遍$Kruscal$。


还是非常好写的qwq

###为了好理解，接下来我们将鹅卵石路称为$1$边，水泥路称为$0$边。代码中$a[]$是存储1边的数组，$b[]$是存储$0$边的数组。$at$是$1$边的条数，$bt$是$0$边的条数。

### $Kruscal$：第一遍

首先将所有的$0$边的两端点加到同一个连通分量中。

像这样 qwq：
```cpp
    for (int i=1;i<=bt;i++)
    {
        f[find(b[i].u)]=find(b[i].v);
    }
```
就是假设将所有的$0$边都连接起来，那么会有哪些点是连通的。

接着跑一遍$Kruscal$。

```cpp
for (int i=1,xx,yy;i<=at;i++)
    {
        xx=find(a[i].u); yy=find(a[i].v);
        if (xx!=yy)
        {
            f[xx]=yy;
            answer[++ans]=a[i];
        }
    }
``` 

这个时候加入的$1$边有什么特性呢？？

很显然（是的），这个时候加入的$1$边必定存在于一个正确答案中。因为少了这些边，图就无法连通。（即图的关键边）

这个时候其实已经找到正确答案的一小部分边啦。于是我们可以开一个新的$fw[]$数组，是专门针对最终答案的一个并查集存父亲的数组。

在上面的程序里加一句：
```cpp
fw[found(a[i].u)]=found(a[i].v);
```

也就是：
```cpp
    for (int i=1,xx,yy;i<=at;i++)
    {
        xx=find(a[i].u); yy=find(a[i].v);
        if (xx!=yy)
        {
            f[xx]=yy;
            answer[++ans]=a[i];
            fw[found(a[i].u)]=found(a[i].v);
        }
    }
```

题目中还有提到一点，要判断是否无解。

我们知道我们需要$k$条$1$边，那么如果关键$1$边超过了$k$条，那么就无解了。

于是我们加个计数。

```cpp
    int asum=0;

    for (int i=1;i<=bt;i++)
    {
        f[find(b[i].u)]=find(b[i].v);
    }

    for (int i=1,xx,yy;i<=at;i++)
    {
        xx=find(a[i].u); yy=find(a[i].v);
        if (xx!=yy)
        {
            asum++;
            f[xx]=yy;
            answer[++ans]=a[i];
            fw[found(a[i].u)]=found(a[i].v);
        }
    }

    if (asum>k)
    {
        printf("no solution");
        return 0;
    }
```

### $Kruscal$：第二遍

和上述道理差不多。同样的方法，找到关键$0$边。如果关键$0$边条数$>n-k-1$，无解。

```cpp
    int bsum=0;
    
    for (int i=1;i<=at;i++)
    {
        f[find(a[i].u)]=find(a[i].v);
    }

    for (int i=1,xx,yy;i<=bt;i++)
    {
        xx=find(b[i].u); yy=find(b[i].v);
        if (xx!=yy)
        {
            bsum++;
            f[xx]=yy;
            answer[++ans]=b[i];
            fw[found(b[i].u)]=fw[found(b[i].v)];
        }
    }

    if (bsum>n-k-1)
    {
        printf("no solution");
        return 0;
    }
```

### $Kruscal$：第三遍（&第四遍）

既然已经找完所有的关键边了，那就~~随便~~塞边做生成树吧（就是裸的$Kruscal$）

```cpp
    for (int i=1,xx,yy;i<=at;i++)
    {
        if (asum==k)
        {
            break;
        }
        xx=found(a[i].u); yy=found(a[i].v);
        if (xx!=yy)
        {
            asum++;
            fw[xx]=yy;
            answer[++ans]=a[i];
        }
    }
    if (asum<k)
    {
        printf("no solution");
        return 0;
    }
    for (int i=1,xx,yy;i<=bt;i++)
    {
        if (bsum==n-k-1)
        {
            break;
        }
        xx=found(b[i].u); yy=found(b[i].v);
        if (xx!=yy)
        {
            bsum++;
            fw[xx]=yy;
            answer[++ans]=b[i];
        }
    }
    if (bsum<n-k-1)
    {
        printf("no solution");
        return 0;
    }
```

加个无解判断。如果$1$边或者$0$边没有达到目标数量（$k$和$n-k-1$），那么无解。


## 完整程序
（如果码风不适请见谅qwq）
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
using namespace std;
int n,m,k;
struct qwq
{
    int u,v,w;
}a[233333],b[233333];
int at=0,bt=0;

int f[23333],fw[23333];

void Init()
{
    for (int i=1;i<=n;i++)
    {
        f[i]=i;
    }
}

void INIT()
{
    for (int i=1;i<=n;i++)
    {
        fw[i]=i;
    }
}

int find(int q)
{
    if (f[q]==q) return q;
    return f[q]=find(f[q]);
}
int found(int q)
{
    if (fw[q]==q) return q;
    return fw[q]=found(fw[q]);
}


qwq answer[233333];
int ans=0;

void die()
{
    printf("no solution");
    exit(0);
}

int main()
{
    scanf("%d%d%d",&n,&m,&k);
    qwq qwqvqwqvqwq;
    for (int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&qwqvqwqvqwq.u,&qwqvqwqvqwq.v,&qwqvqwqvqwq.w);
        if (qwqvqwqvqwq.w)
        {
            b[++bt]=qwqvqwqvqwq;
        }
        else
        {
            a[++at]=qwqvqwqvqwq;
        }
    }
    Init();
    INIT();
    
    int asum=0;
    
    for (int i=1;i<=bt;i++)
    {
        f[find(b[i].u)]=find(b[i].v);
    }
    for (int i=1,xx,yy;i<=at;i++)
    {
        xx=find(a[i].u); yy=find(a[i].v);
        if (xx!=yy)
        {
            asum++;
            f[xx]=yy;
            answer[++ans]=a[i];
            fw[found(a[i].u)]=found(a[i].v);
        }
    }
    if (asum>k)
    {
        die();
    }
    
    Init();
    int bsum=0;
    
    for (int i=1;i<=at;i++)
    {
        f[find(a[i].u)]=find(a[i].v);
    }
    for (int i=1,xx,yy;i<=bt;i++)
    {
        xx=find(b[i].u); yy=find(b[i].v);
        if (xx!=yy)
        {
            bsum++;
            f[xx]=yy;
            answer[++ans]=b[i];
            fw[found(b[i].u)]=fw[found(b[i].v)];
        }
    }
    if (bsum>n-k-1)
    {
        die();
    }
    for (int i=1,xx,yy;i<=at;i++)
    {
        if (asum==k)
        {
            break;
        }
        xx=found(a[i].u); yy=found(a[i].v);
        if (xx!=yy)
        {
            asum++;
            fw[xx]=yy;
            answer[++ans]=a[i];
        }
    }
    if (asum<k)
    {
        die();
    }
    for (int i=1,xx,yy;i<=bt;i++)
    {
        if (bsum==n-k-1)
        {
            break;
        }
        xx=found(b[i].u); yy=found(b[i].v);
        if (xx!=yy)
        {
            bsum++;
            fw[xx]=yy;
            answer[++ans]=b[i];
        }
    }
    if (bsum<n-k-1)
    {
        die();
    }
    for (int i=1;i<=ans;i++)
    {
        printf("%d %d %d\n",answer[i].u,answer[i].v,answer[i].w);
    }
    return 0;
}
```

---

## 作者：hytree (赞：4)

## WQS二分的做法
### 前言:  

其实一开始不知道自己的做法是WQS二分的,后来翻了翻题解,发现原来这种写法叫WQS二分,就把这个名词拿出来了,显得自己的题解很高端QAQ.而且正好唯一一篇WQS题解挂了一个点而且代码还没给完,就有了这篇题解啦.QAQ  

### 思路分析:
做过[TREE](https://www.luogu.org/problemnew/show/P2619) 的人可能会和我一样很快想到这个做法,那道题还要求最小的权值,但这道题不用,~~所以这是一个简化版的TREE~~.  

**边权的设定:**
边权就直接 $rand$就可以了啦QaQ,但是记得要赋的大一点,因为有金钩巨佬给出结论说边权相同的话有可能出问题,似乎此题另一篇题解就是这样挂的.  

**具体实现:**

那么我们就想$TREE$一样的二分最小权值,若达到了一个偏移量使的我们免费的鹅卵石路的数量达到了$k$,就直接$break$,并输出方案即可.

**一些补充:**
即得二分的边界大一点,因为我们是在二分最后生成树的权值,所以我们的端点要尽量的大,然后我们在$Kruskal$中把偏移量$mid$加到所有鹅卵石边上即可.

### Code:

$Talk\ is \ cheap ,\ show \ you \ the \ code$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define re register
#define il inline
int aka,n,m,k,kx,ky,d,cnt,tot,ans[100010],fa[100010];
struct ROAD{int u,v,c,w,id;}r[100010],rr[100010];
il void add(int u,int v,int col,int id){rr[++cnt]=(ROAD){u,v,col,rand()%1000000,id};}
il int getfa(int x){return fa[x]==x?x:fa[x]=getfa(fa[x]);}
il bool cmp(ROAD a,ROAD b){return (a.w<b.w)||(a.w==b.w&&a.c<b.c);}
il int pd(int mid)
{
	memcpy(r,rr,sizeof(rr));
	for(re int i=1;i<=n;++i) fa[i]=i;
	aka=n-1;tot=0;re int hyt=0;//这是一个有故事的变量名....
	for(re int i=1;i<=m;++i) if(!r[i].c) r[i].w+=mid;
	sort(r+1,r+m+1,cmp);
	for(re int i=1;i<=m;++i)
	{
		if(!aka) break;
		re int u=r[i].u,v=r[i].v;re int FA=getfa(u),FB=getfa(v);
		if(FA!=FB){ans[++tot]=r[i].id;if(!r[i].c) hyt++;fa[FA]=FB;aka--;}
        //记得存边的id,我就是因为忘了存id挂了好几次QAQ
	}
	return hyt;
}
int main()
{
	cin>>n>>m>>k;srand(0);
	for(re int i=1;i<=m;++i)
	scanf("%d%d%d",&kx,&ky,&d),add(kx,ky,d,i);
	re int left=-10000000,right=10000000,ace=0;
	while(left<=right)
	{
		re int mid=left+right>>1;
		ace=pd(mid);
		if(ace==k) break;
		if(ace>k) left=mid+1;
		if(ace<k) right=mid-1;
	}
	if(ace!=k){puts("no solution");return 0;}
	for(re int i=1;i<=tot;++i) 
	printf("%d %d %d\n",rr[ans[i]].u,rr[ans[i]].v,rr[ans[i]].c);
	return 0;
}
```

---

## 作者：封禁用户 (赞：4)

使用Kruskal的思想（废话）
首先将所有水泥路加入生成树所有鹅卵石路加入生成树
这是加入生成树的鹅卵石都是必须加入的
在鹅卵石基础上再加入其他树
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef pair<int, int> PII;
#define fi first
#define se second
#define MP make_pair
const int N = 200000;
struct data
{
	int a, b;
} a[N], b[N];

int f[N], n, m, K, lena, lenb, visa[N], visb[N];

int sf(int u)
{
	return f[u] == u ? u : f[u] = sf(f[u]);
}

int main()
{
	scanf("%d%d%d", &n, &m, &K);
	for (int i = 1; i <= m; i++)
	{
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		if (w == 0)
			b[++lenb] = (data){u, v};
		else
			a[++lena] = (data){u, v};
		// a 水泥路
		// b 鹅卵石路 
	}
	if (lenb < K)
		return puts("no solution"), 0;
	// 鹅卵石路不足K条 无解 
	for (int i = 1; i <= n; i++) f[i] = i;
	for (int i = 1; i <= lena; i++)
		if (sf(a[i].a) != sf(a[i].b))
			f[sf(a[i].a)] = sf(a[i].b);
	// 把水泥路加入生成树 
	int tmp = 0;
	for (int i = 1; i <= lenb; i++)
		if (sf(b[i].a) != sf(b[i].b))
		{
			visb[i] = 1;
			// visb[i] 表示鹅卵石路i是否被取 
			tmp++;
			// tmp 已经取的鹅卵石路数量 
			f[sf(b[i].a)] = sf(b[i].b);
		}
	if (tmp > K)
		return puts("no solution"), 0;
	// 如果必须要取的鹅卵石路超过K条 无解 
	for (int i = 1; i < n; i++)
		if (sf(i) != sf(i + 1))
			return puts("no solution"), 0;
	// 如果加入所有边，图还不联通，无解 
	for (int i = 1; i <= n; i++) f[i] = i;
	for (int i = 1; i <= lenb; i++)
		if (visb[i])
			f[sf(b[i].a)] = sf(b[i].b);
	// 把所有必须取的鹅卵石路加入生成树 
	for (int i = 1; i <= lenb && tmp < K; i++)
		if (!visb[i])
			if (sf(b[i].a) != sf(b[i].b))
			{
				visb[i] = 1;
				tmp++;
				// tmp 已经取的鹅卵石路数量 
				f[sf(b[i].a)] = sf(b[i].b);
			}
	// 把鹅卵石路加到K条为止 
	if (tmp < K)
		return puts("no solution"), 0;
	for (int i = 1; i <= lena; i++)
		if (sf(a[i].a) != sf(a[i].b))
		{
			visa[i] = 1;
			f[sf(a[i].a)] = sf(a[i].b);
		}
	// 加入水泥路，使整个图联通 
	for (int i = 1; i <= lena; i++)
		if (visa[i])
			printf("%d %d %d\n", a[i].a, a[i].b, 1);
	for (int i = 1; i <= lenb; i++)
		if (visb[i])
			printf("%d %d %d\n", b[i].a, b[i].b, 0);
}
```

---

## 作者：Minakami_Yuki (赞：3)

生成树太蔡了来练一练。

# 题目链接

[P3623 [APIO2008]免费道路](https://www.luogu.org/problem/P3623)

# 题意简述

给你一张图，边权为$0$或$1$，求权值为$k$的生成树。

# 解题思想

我们先把边权为0的边优先加入生成树，然后可以得到一些边权为1的必须加入生成树的边，对它们打上标记。

然后再把边权为1的边优先加入生成树，并且要优先加入有标记的边，然后当边权为1的边加到$k$条时就跳到边权为0的边加完剩下的生成树就行了。

判定无解需要考虑生成树权值是否为k和是否构成生成树。

注意题目中读入的0和1是反的...

要求输出的0和1也是反的...

# 参考代码

```cpp
#include <cstdio>
#include <algorithm>

using std::sort;

const int N = 2e4 + 5;
const int M = 1e5 + 6;

int n, m, k, cnt;
int fa[N];

int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);}

struct edge {
	int x, y, z, mark;
} e[M];

inline bool cmp1(edge a, edge b) {
	return a.z < b.z;
}

inline bool cmp2(edge a, edge b) {
	if(a.z == b.z) return a.mark > b.mark;
	return a.z > b.z;
}

int main() {
	scanf("%d%d%d", &n, &m, &k);
	for(register int i = 1; i <= m; i++) {
		int x, y, z;
		scanf("%d%d%d", &x, &y, &z);
		e[i] = edge{x, y, 1 - z};
	}
	for(register int i = 1; i <= n; i++) fa[i] = i;
	sort(e + 1, e + m + 1, cmp1);
	for(register int i = 1; i <= m; i++) {
		int x = e[i].x, y = e[i].y;
		if(find(x) == find(y)) continue;
		fa[find(x)] = find(y), cnt++;
		if(e[i].z) e[i].mark = 1;
		if(cnt == n - 1) break;
	}
	cnt = 0;
	sort(e + 1, e + m + 1, cmp2);
	for(register int i = 1; i <= n; i++) fa[i] = i;
	for(register int i = 1; i <= m; i++) {
		if(e[i].mark) {fa[find(e[i].x)] = find(e[i].y); cnt++, k--; continue;}
		if(find(e[i].x) == find(e[i].y)) continue;
		fa[find(e[i].x)] = find(e[i].y);
		cnt++;
		e[i].mark = 1;
		if(e[i].z) k--;
		if(!k) for(; e[i].z; i++);
		if(cnt == n - 1) break;
	}
	if(k) return puts("no solution"), 0;
	for(register int i = 1; i <= m; i++) {
		if(e[i].mark) k++;
	}
	if(k < n - 1) return puts("no solution"), 0;
	for(register int i = 1; i <= m; i++) {
		if(e[i].mark) printf("%d %d %d\n", e[i].x, e[i].y, 1 - e[i].z);
	}
	return 0;
}
```



---

## 作者：Johnson_sky (赞：2)

简单的并查集，一定要注意讨论清除无解的情况（因为这个错了好多次）；另一定要把答案存起来再判断一次是否联通，否则也会WA，代码如下：








```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int n,m,k,fx,fy,num;
int f[100010],t[100010],v[100010];
int fa[20010];
int assss[5][100010];
int now;char ch;
inline int get_num()
{
    now=0;ch=getchar();
    while(ch<'0' || ch>'9')ch=getchar();
    while(ch>='0' && ch<='9')
    {
        now=(now<<1)+(now<<3)+ch-'0';
        ch=getchar();
    }
    return now;
}
inline void init()
{
    for(int i=1;i<=n;i++)fa[i]=i;
}
inline int find(int x)
{
    if(fa[x]==x)return x;
    else return fa[x]=find(fa[x]);
}
inline void merge(int x,int y)
{
    fx=find(x);
    fy=find(y);
    fa[fy]=fx;
}
void godie()
{
    puts("no solution");
    exit(0);
}
int main()
{
    n=get_num();m=get_num();k=get_num();
    if(n==1)godie();//无解
    init();
    for(int i=1;i<=m;i++)
    {
        f[i]=get_num();t[i]=get_num();v[i]=get_num();
        if(v[i]==1 && find(f[i])!=find(t[i]))merge(f[i],t[i]);
        if(v[i]==0)num++;
    }
    if(num<k)godie();//无解
    num=0;
    for(int i=1;i<=m;i++)
    {
        if(v[i]==0 && find(f[i])!=find(t[i]))
        {
            if(num==k)godie();
            merge(f[i],t[i]);num++;
            swap(f[num],f[i]);swap(t[num],t[i]);swap(v[num],v[i]);
        }
    }
    for(int i=2;i<=n;i++)
    {
        if(find(i)!=find(i-1))godie();
    }
    init();
    num=0;
    for(int i=1;i<=m;i++)
    {
        if(num==k)break;
        if(v[i]==0 && find(f[i])!=find(t[i]))
        {
            merge(f[i],t[i]);
            assss[1][++num]=f[i];
            assss[2][num]=t[i];
            assss[3][num]=v[i];
        }
    }
    if(num<k)godie();//无解
    for(int i=1;i<=m;i++)
    {
        if(v[i]==1 && find(f[i])!=find(t[i]))
        {
            merge(f[i],t[i]);
            assss[1][++num]=f[i];
            assss[2][num]=t[i];
            assss[3][num]=v[i];
        }
    }
    for(int i=2;i<=n;i++)
    {
        if(find(i)!=find(i-1))godie();//无解
    }
    for(int i=1;i<=num;i++)
    {
        if(i!=1)putchar('\n');
        printf("%d %d %d",assss[1][i],assss[2][i],assss[3][i]);
    }
    return 0;
}
```

---

## 作者：Plozia (赞：1)

宣传博客->[link](https://blog.csdn.net/BWzhuzehao/article/details/116269343)

最小生成树好题。

下面规定鹅卵石路长度为 1，水泥路长度为 0，则题中要求的是一棵边权为 $k$ 的生成树。

这道题一开始的时候我会认为边权为 1 的边可以随便加，毕竟根据样例来看，删这一条换另一条并没有什么问题。

于是就有一种做法是先选好 $k$ 条 1 边，然后剩下的 0 边随意加。

然而根据下面这张图，你就会发现上述做法有问题：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210429160525888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JXemh1emVoYW8=,size_16,color_FFFFFF,t_70)

如果此时 $k=1$，而你又挑选了 $(1,3)$ 的话……

此时图根本不连通！

因此，有一些边是一定要加的。

那么怎么知道哪些边一定要加呢？

考虑对图做一遍最小生成树，记录一下加入到最小生成树的 1 边数量，这些 1 边就是一定要加的，因为如果删了这些边就不合法了。

然后呢？先加入这些必须加的 1 边，然后在剩下的所有 1 边中加边直到加满，这些边是可以随便选的。最后拿 0 边补齐即可。

无解情况：

- 必须加的 1 边大于 $k$。
- 总共的 1 边不足 $k$。

代码：

```cpp
/*
========= Plozia =========
    Author:Plozia
    Problem:P3623 [APIO2008]免费道路
    Date:2021/4/22
========= Plozia =========
*/

#include <bits/stdc++.h>

typedef long long LL;
const int MAXN = 20000 + 10, MAXM = 100000 + 10;
int n, m, k;
struct node { int x, y, z; } a[MAXM];
struct Union
{
    int fa[MAXN];
    void init() { for (int i = 1; i <= n; ++i) fa[i] = i; }
    int gf(int x) { return (fa[x] == x) ? x : fa[x] = gf(fa[x]); }
    void hb(int x, int y) { if (gf(x) != gf(y)) fa[fa[x]] = fa[y]; }
}u;

int read()
{
    int sum = 0, fh = 1; char ch = getchar();
    for (; ch < '0' || ch > '9'; ch = getchar()) fh -= (ch == '-') << 1;
    for (; ch >= '0' && ch <= '9'; ch = getchar()) sum = (sum << 3) + (sum << 1) + (ch ^ 48);
    return sum * fh;
}
bool cmp1(const node &fir, const node &sec) { return fir.z < sec.z; }
bool cmp2(const node &fir, const node &sec) { return fir.z > sec.z; }

int main()
{
    n = read(), m = read(), k = read();
    for (int i = 1; i <= m; ++i) a[i].x = read(), a[i].y = read(), a[i].z = read() ^ 1;
    std::sort(a + 1, a + m + 1, cmp1);
    u.init(); int tmp, sum;
    tmp = 0, sum = n;
    for (int i = 1; i <= m; ++i)
    {
        if (u.gf(a[i].x) != u.gf(a[i].y))
        {
            u.hb(a[i].x, a[i].y);
            if (a[i].z == 1) a[i].z = -1, ++tmp;
            --sum; if (sum == 1) break ;
        }
    }
    if (tmp > k) { printf("no solution\n"); return 0; }
    if (sum != 1) { printf ("no solution\n"); return 0; }
    std::sort(a + 1, a + m + 1, cmp2);
    u.init(); sum = n;
    for (int i = 1; i <= m; ++i)
        if (a[i].z == -1) { --sum; u.hb(a[i].x, a[i].y); }
    for (int i = 1; i <= m; ++i)
    {
        if (sum == 1) break ;
        if (a[i].z == -1) continue ;
        if (tmp == k && a[i].z == 1) continue ;
        if (u.gf(a[i].x) != u.gf(a[i].y))
        {
            u.hb(a[i].x, a[i].y);
            if (a[i].z == 1) ++tmp, a[i].z = -1;
            if (a[i].z == 0) a[i].z = -2;
            --sum; if (sum == 1) break ;
        }
    }
    if (tmp != k) { printf("no solution\n"); return 0; }
    for (int i = 1; i <= m; ++i)
    {
        if (a[i].z == -2) printf("%d %d 1\n", a[i].x, a[i].y);
        if (a[i].z == -1) printf("%d %d 0\n", a[i].x, a[i].y);
    }
    return 0;
}
```

---

## 作者：Soulist (赞：0)

讲一下为什么可以这样做$($ 指三遍 Kruskal $)$

保留必选中的$0$边之后，对于其他的边有$0$边和$1$边等价

于是三遍 Kruskal 就是对的了$...$

~~因为这样发题解好像不太好，所以附上一个wqs二分的做法~~

给每条边随机一个权值后，做法同$P2619$

然后这样可能会WA，因为实现过程中存在二分时边权相等以至于最后答案错误的情况

所以随机权值够大，尽量使之不相等即可就好了

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const int N = 2e5 + 5 ; 
int n, m, K, fa[N], num, idnex ;
struct E {
	int fr, ed, w, col, id, us ; 
} e[N], s[N] ;
bool cmp( E x, E y ) {
	return x.w < y.w ; 
}
int fd( int x ) {
	return ( x == fa[x] ) ? x : fa[x] = fd(fa[x]) ; 
} 
void merge( int x, int y ) {
	int u = fd(x), v = fd(y) ; 
	if( u != v ) fa[u] = v, ++ num ; 
}
bool check( int x ) {
	rep( i, 1, n ) fa[i] = i ; int cnt = 0 ;
	rep( i, 1, m ) if( e[i].col == 0 ) e[i].w += x ; 
	sort( e + 1, e + m + 1, cmp ) ;
	rep( i, 1, m ) {
		int u = e[i].fr, v = e[i].ed ;
		int ux = fd(u), vx = fd(v) ; e[i].us = 0 ;
		if( ux != vx ) fa[ux] = vx, cnt += ( e[i].col == 0 ), e[i].us = 1 ; 
	}
	rep( i, 1, m ) if( e[i].col == 0 ) e[i].w -= x ; 
	idnex = cnt ; 
	return cnt >= K ; 
}
bool cmp2( E x, E y ) {
	return x.id < y.id ; 
}
signed main()
{
	srand(19260817) ; 
	n = read(), m = read(), K = read() ;  
	rep( i, 1, n ) fa[i] = i ; 
	rep( i, 1, m ) e[i].id = i, e[i].fr = read(), e[i].ed = read(), e[i].col = read(), merge( e[i].fr, e[i].ed ) ; 
	rep( i, 1, m ) e[i].w = i + 1ll * rand() * rand() % 23333 ; int flag = 0 ; 
	if( num != n - 1 ) puts("no solution") ; 
	else {
		int l = - m, r = m, mid ;  
		while( l <= r ) {
			mid = ( l + r ) >> 1 ; 
			if( check(mid) ) {
				if( idnex == K ) {
					rep( j, 1, m ) s[j] = e[j], flag = 1 ; 
					break ; 
				}
				l = mid + 1 ; 
			} 
			else r = mid - 1 ; 
		}
	}
	int used = 0 ;
	if( flag == 0 ) puts("no solution") ; 
	else rep( i, 1, m ) if( s[i].us ) printf("%d %d %d\n", s[i].fr, s[i].ed, s[i].col ) ;
	return 0 ;
}

```

---

## 作者：orzws (赞：0)

这一题是一题比较有难度的生成树，它不仅仅只是考虑价值，还要考虑数量。我也借鉴了一下其他题解的思路，但其他题解不够清晰，我就汇总一下。

一开始很难想到要怎么做，这里我说一下思路。我们可以先把水泥路都铺下去，然后如果有地方没有连接，那么中间就一定要石子路。

然后把必要石子路铺上，这个时候就不用去考虑其他的石子路了，能铺上就铺上。

之后就可以铺水泥路，用水泥路把所有的地方连接在一起，然后就可以了。记得要特判无解的情况。

在我的代码里我是把石子路和水泥路分开来储存的，这样比较容易区分和使用。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int father[20005],ans[100005][3],number=0,tot,t1,t2;
struct p {
	int data,from,to;
} a1[100005],a2[100005];
int find(int x) {
	if(x != father[x]) father[x] = find(father[x]);
	return father[x];
}
bool cmp(const p &x,const p &y) {
	if(x.data > y.data) return true;
	return false;
}
int main() {
	int n,m,u;
	cin >> n >> m >> u;
	for(int i = 1; i <= n; i++) father[i] = i;
	int a,b,c;
	for(int i = 1; i <= m; i++) {
		cin >> a >> b >> c;
		if(c == 0)
			t1++,a1[t1].data = c,a1[t1].from = a,a1[t1].to = b;
		if(c == 1)
			t2++,a2[t2].data = c,a2[t2].from = a,a2[t2].to = b;
	}
	int r1,r2;
	if(t1 < u) {
		cout << "no solution";
		return 0;
	}//cout << "GG" << endl;
	for(int i = 1; i <= t2; i++) {
		r1 = find(a2[i].from);
		r2 = find(a2[i].to);
		if(r1 != r2) {
			father[r1] = r2;
		}
	}
	for(int i = 1; i <= t1; i++) {
		r1 = find(a1[i].from);
		r2 = find(a1[i].to);
		if(r1 != r2) {
			father[r1] = r2;
			number++;
			ans[number][0] = a1[i].from ;
			ans[number][1] = a1[i].to;
			ans[number][2] = a1[i].data;
		}
	}
	if(number > u) {
		cout << "no solution";
		return 0;
	}
	for(int i = 1; i <= n; i++) father[i] = i;
	for(int i = 1; i <= number; i++)
		father[find(ans[i][0])] = find(ans[i][1]);
	for(int i = 1; i <= t1; i++) {
		r1 = find(a1[i].from);
		r2 = find(a1[i].to);
		if(r1 != r2 && number < u) {
			father[r1] = r2;
			number++;
			ans[number][0] = a1[i].from ;
			ans[number][1] = a1[i].to;
			ans[number][2] = a1[i].data;
		}
	}
	if(number < u) {
		cout << "no solution";
		return 0;
	}
	for(int i = 1; i <= n; i++) father[i] = i;
	for(int i = 1; i <= number; i++)
		father[find(ans[i][0])] = find(ans[i][1]);
	for(int i = 1; i <= t2; i++) {
		int r1 = find(a2[i].from);
		int r2 = find(a2[i].to);
		if(r1 != r2) {
			father[r1] = r2;
			ans[++number][0] = a2[i].from;
			ans[number][1] = a2[i].to;
			ans[number][2] = a2[i].data;
		}
	}
	int l = 0;
	for(int i = 1; i <= n ; i++) {
		if(father[i] == i) {
			if(l == 0) l++;
			else {
				cout << "no solution";
				return 0;
			}
		}
	}
	for(int i = 1; i <= number; i++)
		cout << ans[i][0] << " " << ans[i][1] << " " << ans[i][2] << endl;
}
```


---

## 作者：nofind (赞：0)

题意:https://www.luogu.org/problem/P3623

先不考虑石子路,将水泥路加入,这时如果图不连通,再加入石子路,这时加入的石子路是必须加入的

将所有必须加入的石子路加入后,其他的就可以随便加了,优先将石子路加入到K,之后加水泥路

注意一点：https://www.luogu.org/discuss/show/154262

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=20010;
const int maxm=100010;
int n,m,K,cnt,tot,num;
int fa[maxn];
bool check[maxm];
struct Edge{int u,v,w;}E[maxm],ans[maxn];
inline bool cmp1(Edge x,Edge y){return x.w<y.w;}
inline bool cmp2(Edge x,Edge y){return x.w>y.w;}
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
int main()
{
	scanf("%d%d%d",&n,&m,&K);
	int tmp=0;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&E[i].u,&E[i].v,&E[i].w);
		E[i].w^=1;
		if(E[i].w)tmp++;
	}
	if(tmp<K){puts("no solution");return 0;}
	for(int i=1;i<=n;i++)fa[i]=i;
	sort(E+1,E+m+1,cmp1);
	for(int i=1;i<=m;i++)
	{
		if(E[i].w)break;
		int x=find(E[i].u),y=find(E[i].v);
		if(x==y)continue;
		fa[x]=y;tot++;
	}
	sort(E+1,E+m+1,cmp2);
	for(int i=1;i<=m;i++)
	{
		if(!E[i].w)break;
		int x=find(E[i].u),y=find(E[i].v);
		if(x==y)continue;
		check[i]=1;ans[++cnt]=E[i];fa[x]=y;num++,tot++;
	}
	if(tot<n-1||num>K){puts("no solution");return 0;}
	for(int i=1;i<=n;i++)fa[i]=i;
	for(int i=1;i<=cnt;i++)
	{
		int x=find(ans[i].u),y=find(ans[i].v);
		fa[x]=y;
	}
	for(int i=1;i<=m;i++)
	{
		if(check[i]||(num==K&&E[i].w))continue;
		int x=find(E[i].u),y=find(E[i].v);
		if(x==y)continue;
		fa[x]=y;ans[++cnt]=E[i];
		if(E[i].w)check[i]=1,num++;
	}
	if(num<K){puts("no solution");return 0;}
	for(int i=1;i<=cnt;i++)printf("%d %d %d\n",ans[i].u,ans[i].v,ans[i].w^1);
	return 0;
}
```


---


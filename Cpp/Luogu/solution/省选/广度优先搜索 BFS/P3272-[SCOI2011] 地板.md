# [SCOI2011] 地板

## 题目描述

lxhgww 的小名叫“小 L”，这是因为他总是很喜欢 L 型的东西。

小 L 家的客厅是一个 $r\times c$ 的矩形，现在他想用 L 型的地板来铺满整个客厅，客厅里有些位置有柱子，不能铺地板。

现在小 L 想知道，用 L 型的地板铺满整个客厅有多少种不同的方案？

需要注意的是，如下图所示，L 型地板的两端长度可以任意变化，但不能长度为 $0$。

![](https://cdn.luogu.com.cn/upload/pic/4636.png)

铺设完成后，客厅里面所有没有柱子的地方都必须铺上地板，但同一个地方不能被铺多次。

## 说明/提示

#### 数据规模与约定
| 测试点编号 | 数据限制 |
| :----------: | :----------: |
| $1\sim 2$ | $1\le r\times c\le 25$ |
| $3\sim 5$ | $1\le r\times c\le 100$ 并且 （$r=2$ 或者 $c=2$） |
| $6\sim 10$ | $1\le r\times c\le 100$ |

## 样例 #1

### 输入

```
2 2
*_
__```

### 输出

```
1```

## 样例 #2

### 输入

```
3 3
 ___
 _*_
 ___```

### 输出

```
8```

# 题解

## 作者：Orion545 (赞：14)

## 广告

[蒟蒻的blog](http://www.cnblogs.com/dedicatus545/p/8630522.html)

内有多道插头dp题目，配合使用口感更佳～

## 思路：

[没学过插头dp的可以看这里](http://www.cnblogs.com/dedicatus545/p/8638869.html)

这个L形......第一眼看上去真的是丧病啊

但是仔细想想，实际上也就是拿一堆路径铺满一个棋盘，这个路径还是有限制的

那还有什么好说的，插头dp上啊【雾】

 

首先。我们定义这道题中的一个插头代表着从这个格子往插头指向的方向可以伸展一个L形

但是整张图上的所有插头不可能只有一种，因此我们要分析，可以继续延伸的L形都有哪些限制呢？

我们知道，L形的一个特点就是拐了一个弯，而且只拐了一个弯，因此我们可以定义这样的两种插头：

插头1代表一个还没有拐过弯的L形的延伸，插头2则代表一个已经拐过弯的L形的延伸

这样我们解决了定义问题，接下来看如何分类讨论

 

#### 第一种情况：当前状态下，当前格子上方和左方都没有插头

这时我们需要找一个L形来把这个格子填上，那么我们可能有三种决策：

　　决策一：给这个格子加一个二号下插头和一个二号右插头，此时这个格子是一个新的L形的拐角

　　决策二：给这个格子加一个一号下插头，此时相当于构建了一个先向下再向右的L形，从当前格子开始

　　决策三：给这个格子加一个一号右插头，此时相当于构建了一个先向右再向下的L形，从当前格子开始

 

#### 第二种情况：当前状态下，当前格子上方有一个一号下插头，左方没有插头

这时相当于上面有一个L形的未拐弯的一边伸过来了，有两种决策：

　　决策一：L形不拐弯，继续向下延伸，当前格子只有一个一号下插头

　　决策二：L形在当前格子拐弯，L形向右延伸，当前格子只有一个二号右插头

 

#### 第三种情况：当前状态下，当前格子左方有一个一号右插头，上方没有插头

与第二种情况类似，故不赘述

 

#### 第四种情况：当前状态下，当前格子上方有一个二号下插头，左方没有插头

这时相当于上面有一个L形的拐过弯的一边伸过来了，有两种决策：

　　决策一：L形继续延伸，当前格子有一个二号下插头

　　决策二：L形在当前格子终止，当前格子没有插头

决策二时注意，如果当前处在最后一个没有障碍的格子，那么需要统计入最终答案

 

#### 第五种情况：当前状态下，当前格子左方有一个二号右插头，上方没有插头

与第四种情况类似，故不赘述

 

#### 第六种情况：当前状态下，当前格子左方和上方都有一号插头

此时相当于两条“臂”伸了过来，在当前格子相交，应该合并成一个L形

当前格子相当于一个L形的拐弯处，没有插头

 

我们发现，情况一和情况六已经覆盖了四种L形的摆放方式，同时也不会有一个二号插头一个一号插头或者两个二号插头的情况出现——它们被上文的六种情况限制了

故这种分类讨论方式可以覆盖所有情况

#### 状态可以用四进制表示（比较快），因为状态数较多，放到哈希表里面，滚动数组处理即可

 
## Code:
 
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define hash deep_dark_fantasy
#define ll long long
#define MOD 20110520
using namespace std;
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
int n,m,x[150][150],cur,pre,ex,ey;
int st[2][300010];ll ans[2][300010],re;
int tot[2],bit[20],state[300010],st_tot,hash=300000;
struct edge{
    int to,next;
}a[300010];
void insert(int now,ll val){
    int p=now%hash;
    for(int i=state[p];i;i=a[i].next){
        if(st[cur][a[i].to]==now){
            ans[cur][a[i].to]+=val;
            ans[cur][a[i].to]%=MOD;return;
        }
    }
    tot[cur]++;
    a[++st_tot].to=tot[cur];
    a[st_tot].next=state[p];
    state[p]=st_tot;st[cur][tot[cur]]=now;ans[cur][tot[cur]]=val%MOD;
}
void dp(){
    int i,j,k,down,right,now;ll val;
    cur=0;tot[cur]=1;ans[cur][1]=1;st[cur][1]=0;
    for(i=1;i<=n;i++){
        for(j=1;j<=tot[cur];j++) st[cur][j]<<=2;
        for(j=1;j<=m;j++){
            memset(state,0,sizeof(state));st_tot=0;
            pre=cur;cur^=1;tot[cur]=0;
            for(k=1;k<=tot[pre];k++){
                now=st[pre][k];val=ans[pre][k];
                right=(now>>bit[j-1])%4;down=(now>>bit[j])%4;
                if(!x[i][j]){//障碍格子
                    if(!down&&!right){
                        insert(now,val);continue;
                    }
                }
                if(!right&&!down){//第一种情况
                    if(x[i+1][j]&&x[i][j+1])
                        insert(now+((1<<bit[j-1])<<1)+((1<<bit[j])<<1),val);
                    if(x[i+1][j]) insert(now+(1<<bit[j-1]),val);
                    if(x[i][j+1]) insert(now+(1<<bit[j]),val);
                }
                if(right==1&&!down){//第三种情况
                    if(x[i][j+1]) insert(now-(1<<bit[j-1])+(1<<bit[j]),val);
                    if(x[i+1][j]) insert(now+(1<<bit[j-1]),val);
                }
                if(down==1&&!right){//第二种情况
                    if(x[i+1][j]) insert(now-(1<<bit[j])+(1<<bit[j-1]),val);
                    if(x[i][j+1]) insert(now+(1<<bit[j]),val);
                }
                if(right==2&&!down){//第五种情况
                    if(i==ex&&j==ey) re+=val,re%=MOD;
                    if(x[i][j+1]) insert(now-((1<<bit[j-1])<<1)+((1<<bit[j])<<1),val);
                    insert(now-((1<<bit[j-1])<<1),val);
                }
                if(down==2&&!right){//第四种情况
                    if(i==ex&&j==ey) re+=val,re%=MOD;
                    if(x[i+1][j]) insert(now-((1<<bit[j])<<1)+((1<<bit[j-1])<<1),val);
                    insert(now-((1<<bit[j])<<1),val);
                }
                if(down==1&&right==1){//第六种情况
                    if(i==ex&&j==ey) re+=val,re%=MOD;
                    insert(now-(1<<bit[j-1])-(1<<bit[j]),val);
                }
            }
        }
    }
}
int main(){//这道题的读入没有保证n>=m，所以我写了一个判断，来保证n>=m，具体操作就是把图旋转了九十度
    int i,j;char ch;
    n=read();m=read();
    for(i=1;i<=20;i++) bit[i]=i<<1;
    if(n>m){
        for(i=1;i<=n;i++){
            for(j=1;j<=m;j++){
                ch=getchar();
                while(ch!='*'&&ch!='_') ch=getchar();
                x[i][j]=(ch=='_');
                if(x[i][j]) ex=i,ey=j;
            }
        }
    }
    else{
        swap(n,m);
        for(i=m;i>0;i--){
            for(j=1;j<=n;j++){
                ch=getchar();
                while(ch!='*'&&ch!='_') ch=getchar();
                x[j][i]=(ch=='_');
                if(x[j][i]&&((j>ex)||(j==ex&&i>ey))) ex=j,ey=i;
            }
        }
    }
    dp();
    printf("%lld",re);
}
```



---

## 作者：ISYRHH (赞：8)


## [SCOI2011]地板

------------

&emsp;最近在 **透 彻**dp，刚切完隔壁[世界树](https://www.luogu.com.cn/problem/P3233)，有被恶心到……

&emsp;于是就来学了插头dp调整调整心情，这是继板子后的第二道题（算是一道比较水的插头 $dp$？）……写的不好，望见谅...

------------


## 题意分析

&emsp;题目理解一下就是用L型的几条线覆盖一个方格（废话）

&emsp;（有一说一也没什么好分析的，棋盘，方案数,L型的线，插头dp搞就完了，于是我们直接进入思想）

------------


## 解法

&emsp;先不谈怎么构造状态，我们考虑一下什么对我当前的决策有影响

&emsp;决策到当前的一格。

![](https://i.loli.net/2021/05/07/5ifDu3l4vWcg69t.png)

&emsp;对当前和以后的决策，只可能收到上面的一行的影响。

![](https://i.loli.net/2021/05/07/e2mbwINB19CVSAY.png)

&emsp;所以我们可以统计上一行状态相同的方案数，合并到一起转移。

&emsp;另外我们定义状态为上一行的地砖是否会想以后的格子蔓延（即所谓的插头），将上一行格子是否会蔓延压成二进制存在数组里统计方案。

&emsp;（对于当前一格左侧的格子既可能往下蔓延，也可能往右蔓延，我们将其分为两部分存储状态，所以7个格子实际上是8位）

&emsp;对于上面的7个格子，对应的二进制（或许是更多进制？）位分别为：

&emsp;第0位，第1位，第2,3位，第4位，第5位，第6位，第7位。

&emsp;然后再来看一个情况：

&emsp;如果我们默认状态只有两种，即向相邻的格子转移和不向相邻的格子转移，对于以下的两种情况，我们的状态是相同的。

![](https://z3.ax1x.com/2021/05/07/g3q0un.png)

![](https://z3.ax1x.com/2021/05/07/g3LpUf.png)

&emsp;这两种情况的状态存起来都会是00010001，很明显，他们以后的决策是不同的

&emsp;（第一种很明显必须在未来和一个横向蔓延的地砖汇合，而第二种当前格的明显不能往右蔓延……）

&emsp;所以我们要想一个办法将这两种情况区别开：

&emsp;&emsp;1. 对于蔓延的方向是背离地砖的折点的，我们将它的状态记为 $2$，这块地砖随时可以停止蔓延，并且不能转弯。

&emsp;&emsp;2. 对于蔓延的方向是向着地砖的折点的我们将它的状态记为 $1$，以后这块地砖必定要和一块不同方向蔓延的地砖汇合。

&emsp;这样我们就得到了这道题的基本思想，另外对于状态的存储也由二进制变成了三进制（为了方便位运算，代码实现中直接用四进制存储）

&emsp;然后我们就可以开始考虑状态转移的主体部分，即对于当前格分情况讨论：

&emsp;(这一大串if也是插头dp最恶臭的部分）

&emsp;对于当前格有影响的只有左边的格子向右的插头和上面格子向下的插头，分别记为n1,n2。

### 1. 当前格为柱子：

&emsp;我们不能在柱子上铺设地砖，故当且仅当n1,n2都为0时状态有效，柱子也不可能产生插头所以n1,n2转移后仍为0。

### 2. 当前格为空地：

&emsp;(1)$n1=0$,$n2=0$

&emsp;&emsp;没有插头连接当前格子，因为题目要求空地一定要被覆盖，所以我们有三种选择（即三种转移）：

&emsp;&emsp;（这里假设转移可行，即转移的格子为空地，代码中要加上判断）

##### &emsp;&emsp;&emsp;1. 将当前格作为折点，向下和向右都添加插头1。

##### &emsp;&emsp;&emsp;2. 向下蔓延寻找一块地砖的折点，添加插头2。

##### &emsp;&emsp;&emsp;3. 向右蔓延寻找一块地砖的折点，添加插头2。

&emsp;&emsp;（具体转移略，利用位运算乱搞即可）

&emsp;(2)$n1=1$,$n2=0$

&emsp;&emsp;左侧的一个背离折点的插头连接当前格子，我们可以接着蔓延出去，或者就此停住：

&emsp;&emsp;（$n1=0$,$n2=1$铜）

##### &emsp;&emsp;&emsp;1. 向右添加插头1。

##### &emsp;&emsp;&emsp;2. 不添加任何插头。

#### (3)n1=2,n2=0

&emsp;&emsp;左侧的一个指向折点的插头连接当前格子，我们可以接着蔓延出去，或者将此节点作为折点，向下蔓延：

&emsp;&emsp;（$n1=0$,$n2=2$铜）

##### &emsp;&emsp;&emsp;1. 向右添加插头 $2$。

##### &emsp;&emsp;&emsp;2. 向下添加插头 $1$。

#### (3)$1!=0$,$2!=0$

&emsp;&emsp;一块空地只能被一个插头覆盖，故只有当两个插头都为 $2$时，我们可以将此节点作为折点，此时状态可行。

&emsp;&emsp;否则状态一定不可行，直接舍弃

##### &emsp;&emsp;&emsp;1. 不添加任何插头（$n1=2$,$n2=2$)。

------------

## 代码

&emsp;将以上所有内容实现成代码，就得到了这道题的AC代码

```cpp
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cstring>
#define mo 499979
#define moo 20110520
using namespace std;
long long n,m,now,jc[20],siz[2],dp[1500000][2],yj[1500000][2],lst[500000],ei,ej,ans,nxt[1500000];
char s[110];
bool table[110][110];
void ylc(long long &a,long long &b)
{
    long long x=a;
    a=b,b=x;
}
void inst(long long yjj,long long dpp)
{
    long long u=yjj%mo+1;
    for(long long i=lst[u];i;i=nxt[i])
    {
        if(yj[i][now]==yjj)
        {
            dp[i][now]=(dp[i][now]+dpp)%moo;
            return;
        }
    }
    yj[++siz[now]][now]=yjj;
    dp[siz[now]][now]=dpp;
    nxt[siz[now]]=lst[u];
    lst[u]=siz[now];
}
//将二进制表示为yjj，方案数为dpp的状态加入dp数组。
//为了避免遍历过程中过多的无用状态（事实上三进制的状态是跑不满的），这里写了一个hash，将二进制表示转化为dp中的siz编号。
int main()
{
    scanf("%lld%lld",&n,&m);
    if(n<m)
    {
        for(long long i=1;i<=n;i++)
        {
            cin>>s+1;
            for(long long j=1;j<=m;j++)
            {
                if(s[j]=='_')
                {
                    table[j][i]=true;
                    ei=j,ej=i;
                }
            }
        }
        ylc(n,m);
    }
    else
    {
        for(long long i=1;i<=n;i++)
        {
            cin>>s+1;
            for(long long j=1;j<=m;j++)
            {
                if(s[j]=='_')
                {
                    table[i][j]=true;
                    ei=i,ej=j;
                }
            }
        }
    }
    //为了使状态数尽可能小，将较小的一维作为横向。
    jc[0]=1;
    for(long long i=1;i<=19;i++)
    {
        jc[i]=(jc[i-1]<<2);
    }
    //预处理4进制下的第n位。
    siz[now]=1,dp[1][now]=1,yj[1][now]=0;
    //又臭又长的状态转移
    for(long long i=1;i<=n;i++)
    {
        for(long long j=1;j<=siz[now];j++)
        {
            yj[j][now]<<=2;
        }
        for(long long j=1;j<=m;j++)
        {
            memset(lst,0,sizeof(lst));
            long long pst=now;now^=1;
            // printf("%lld\n",siz[pst]);
            siz[now]=0;
            for(long long k=1;k<=siz[pst];k++)
            {
                // if(k==4)system("pause");
                long long nyj=yj[k][pst],ndp=dp[k][pst],n1=((nyj>>((j-1)<<1))&3),n2=((nyj>>(j<<1))&3);
                if(table[i][j])
                {
                    if(!n1&&!n2)
                    {
                        if(table[i][j+1])
                        {
                            inst(nyj+(jc[j]<<1),ndp);
                        }
                        if(table[i+1][j])
                        {
                            inst(nyj+(jc[j-1]<<1),ndp);
                        }
                        if(table[i+1][j]&&table[i][j+1])
                        {
                            inst(nyj+jc[j]+jc[j-1],ndp);
                        }
                        continue;
                    }
                    if(!n1&&n2==1)
                    {
                        if(i==ei&&j==ej)
                        {
                            ans+=ndp;
                            continue;
                        }
                        inst(nyj-jc[j],ndp);
                        if(table[i+1][j])
                        {
                            inst(nyj-jc[j]+jc[j-1],ndp);
                        }
                        continue;
                    }
                    if(!n1&&n2==2)
                    {
                        if(table[i+1][j])
                        {
                            inst(nyj-(jc[j]<<1)+(jc[j-1]<<1),ndp);
                        }
                        if(table[i][j+1])
                        {
                            inst(nyj-jc[j],ndp);
                        }
                        continue;
                    }
                    if(n1==1&&!n2)
                    {
                        if(i==ei&&j==ej)
                        {
                            ans+=ndp;
                            continue;
                        }
                        inst(nyj-jc[j-1],ndp);
                        if(table[i][j+1])
                        {
                            inst(nyj-jc[j-1]+jc[j],ndp);
                        }
                        continue;
                    }
                    if(n1==2&&!n2)
                    {
                        if(table[i+1][j])
                        {
                            inst(nyj-jc[j-1],ndp);
                        }
                        if(table[i][j+1])
                        {
                            inst(nyj-(jc[j-1]<<1)+(jc[j]<<1),ndp);
                        }
                        continue;
                    }
                    if(n1==2&&n2==2)
                    {
                        if(i==ei&&j==ej)
                        {
                            ans+=ndp;
                            continue;
                        }
                        inst(nyj-(jc[j-1]<<1)-(jc[j]<<1),ndp);
                        continue;
                    }
                    continue;
                }
                else
                {
                    if(!n1&&!n2)
                    {
                        inst(nyj,ndp);
                    }
                    continue;
                }
            }
        }
    }
    //输出答案……
    printf("%lld",ans%moo);
    return 0;
}
```
&emsp;&emsp;（p.s.为了优化时间复杂度的同时不会被卡空间，实现中用了一个hash，根据注释应该能读懂)
## **end**

---

## 作者：LittleMoMol (赞：5)

### 前言
做这道题前建议先把模板消化掉，见下行

- [P5056 【模板】插头dp](https://www.luogu.com.cn/problem/P5056)

这个题是插头 DP 的应用，相对于模板题来说变化还是挺大的。

[欢迎博客食用](https://www.cnblogs.com/LittleMoMol-kawayi/p/solution_LuoGu_P3272.html)

### 初步分析

最大的区别莫过于它最后不是要求成环，不过动态规划嘛，就这德行……

我们依旧采用**四进制**来维护每一行的状态，并且每条**已遍历和未遍历的分界线**的数依旧是 $x \in \{0,1,2\}$，只不过对应的意义变了。

$x=0$ 表示该边没有插头，$x=1$ 表示该边有插头且所扑的地毯到目前为止**没有拐弯**，$x=2$ 表示该边有插头且所扑的地毯到目前为止**拐且只拐了一次弯**。

那么问题就好解决了，只要细心想，转移方程就迎刃而解了。

### 用图像来解释状态转移方程

在放图之前，在这里我想列一个列表，希望能够清楚地呈现出各种情况。

令 $x$ 表示某个方格左边插头状态，$x$ 表示某个方格上边插头状态，

1. $(i,j)$ 是障碍物，此时如果 $x=0,\ y=0$，那么可以加入新状态（和原状态一样，不用变化）；否则无解~~（显然）~~，不用管它。
2. $x=0,\ y=0$ 有三种转移方程，详情见下图。
3. $x=0,\ y=1$ 有二种转移方程，详情见下图。
4. $x=1,\ y=0$ 有二种转移方程，详情见下图。
5. $x=0,\ y=2$ 有二种转移方程，详情见下图。
6. $x=2,\ y=0$ 有二种转移方程，详情见下图。
7. $x=1,\ y=1$ 在这里必须封口。为什么？如果不封口，那么 $x,y$ 中必定有一个**一次也没拐弯且前路已断**，今生不可能再次被访问到，那么它就不符合要求。
8. $\begin{cases} x=1,\ y=2 \\ x=2,\ y=1 \\ x=2,\ y=2 \end{cases}$ 的情况是**不可能出现**的，因为这三种情况已将被前面几种情况覆盖了！（看了 @Orion545 大佬的题解才明白这一点）

那么接下来，对于第二到第六种情况……上图~

第二种

![](https://cdn.luogu.com.cn/upload/image_hosting/w8d7i5h2.png)

第三、四种

![](https://cdn.luogu.com.cn/upload/image_hosting/r8rfx2el.png)

第五种、六种

![](https://cdn.luogu.com.cn/upload/image_hosting/vc6vpmlj.png)

---

### 细节/实现

手写哈希表可提高速度，用滚动数组省空间。

### Code
``` cpp
#include <iostream>
#include <cstring>
#include <string>

using namespace std;

const int N = 180000, M = N * 2 + 7, mod = 20110520;

int n, m, end_x, end_y;
int maze[110][110], q[2][N], cnt[2];
int h[2][M], v[2][M];

int find_pos(int cur, int x)
{
	int t = x % M;
	while (h[cur][t] != -1 && h[cur][t] != x)
		if ( ++ t == M) t = 0;
	return t;
}

void add(int cur, int state, int w)
{
	int t = find_pos(cur, state);
	if (h[cur][t] == -1)
	{
		h[cur][t] = state;
		v[cur][t] = w;
		q[cur][ ++ cnt[cur]] = t;
	}
	else v[cur][t] = (v[cur][t] + w) % mod;
}

int get(int state, int k)
{
	return (state >> (k * 2)) & 3;
}

int stt(int k, int v)
{
	return v * (1 << (k * 2));
}

void rap()
{
	swap(n, m);
	swap(end_x, end_y);
	for (int i = 1; i <= n; i ++ )
		for (int j = 1; j < i; j ++ )
			swap(maze[i][j], maze[j][i]);
	return;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	
	cin >> n >> m;
	for (int i = 1; i <= n; i ++ )
	{
		string s;
		cin >> s;
		s = ' ' + s;
		for (int j = 1; j <= m; j ++ )
			if (s[j] == '_')
			{
				maze[i][j] = 1;
				end_x = i;
				end_y = j;
			}
	}
	
	if (n < m) rap();
	
	int ans = 0;
	memset(h, -1, sizeof h);
	int cur = 0;
	add(cur, 0, 1);
	
	for (int i = 1; i <= n; i ++ )
	{
		for (int j = 1; j <= cnt[cur]; j ++ )
			h[cur][q[cur][j]] <<= 2;
		
		for (int j = 1; j <= m; j ++ )
		{
			int lst = cur;
			cur ^= 1;
			cnt[cur] = 0;
			memset(h[cur], -1, sizeof h[cur]);
			
			for (int k = 1; k <= cnt[lst]; k ++ )
			{
				int state = h[lst][q[lst][k]];
				int w = v[lst][q[lst][k]];
				int x = get(state, j - 1);
				int y = get(state, j);
				
				if (!maze[i][j])
				{
					if (!x && !y) add(cur, state, w);
				}
				else if (!x && !y)
				{
					if (maze[i][j + 1]) add(cur, state + stt(j, 1), w);
					if (maze[i + 1][j]) add(cur, state + stt(j - 1, 1), w);
					if (maze[i][j + 1] && maze[i + 1][j]) add(cur, state + stt(j, 2) + stt(j - 1, 2), w);
				}
				else if (!x && y == 1)
				{
					if (maze[i + 1][j]) add(cur, state - stt(j, y) + stt(j - 1, y), w);
					if (maze[i][j + 1]) add(cur, state + stt(j, 1), w);
				}
				else if (x == 1 && !y)
				{
					if (maze[i][j + 1]) add(cur, state - stt(j - 1, x) + stt(j, x), w);
					if (maze[i + 1][j]) add(cur, state + stt(j - 1, 1), w);
				}
				else if (!x && y == 2)
				{
					if (i == end_x && j == end_y) ans = (ans + w) % mod;
					else if (maze[i + 1][j]) add(cur, state - stt(j, y) + stt(j - 1, y), w);
					add(cur, state - stt(j, y), w);
				}
				else if (x == 2 && !y)
				{
					if (i == end_x && j == end_y) ans = (ans + w) % mod;
					else if (maze[i][j + 1]) add(cur, state - stt(j - 1, x) + stt(j, x), w);
					add(cur, state - stt(j - 1, x), w);
				}
				else if (x == 1 && y == 1)
				{
					if (i == end_x && j == end_y) ans = (ans + w) % mod;
					add(cur, state - stt(j - 1, x) - stt(j, y), w);
				}
			}
		}
	}
	
	cout << ans << endl;
	
	return 0;
}
```

### 后语

这代码我调了许久……

参考资料：[AcWing 2644. 地板（算法进阶课）](https://www.acwing.com/video/2087/)

完结撒花！

---

## 作者：Union_Find (赞：2)

看着插头 dp 找到这里的，就写了。

# 分析

看到 $r \times c \le 100$，很快想到 $\min(r,c) \le 10$，可以用插头 dp。

这题我们考虑 L 形状的分类，其实就是有拐弯过了和尚未拐弯，我们分别设为插头 $1$ 和插头 $2$，如果没有就是 $0$。

# 分讨

1. 有障碍，直接跳过。
2. 没有左插头和下插头，可以单独向下或向右建一个插头 $1$，也可以从右往下建一个拐弯的插头。
3. 只有一个插头 $1$，可以顺着方向下去，仍然是插头 $1$，或者拐弯建插头 $2$。
4. 只有一个插头 $2$，只能顺下去或停下。
5. 右插头是 $1$，下插头也是 $1$，只能在这里连上。

为什么没有一个插头 $1$ 和一个插头 $2$或者两个插头 $2$，因为插头 $2$ 会在上一步停下，就包含在情况 $3$ 和 $4$ 中了。

注意，如果情况 $4$ 和 $5$ 所在的格子是最后一个可行格子，要统计答案并停下。

# Code

这里建议用哈希表，并用 $4$ 进制和滚动数组，跑更快且好写。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
il ll rd(){
	ll s = 0, w = 1;
	char ch = getchar();
	for (;ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (;ch >= '0' && ch <= '9'; ch = getchar()) s = ((s << 1) + (s << 3) + ch - '0');
	return s * w;
}
const int P = 20110520;
int n, m, a[105][105], st[2][5000010], p, en[2], maxx, maxy;
ll f[2][5000010], ans;
char s[105];
struct hash_table{
	int head[9000010], nxt[9000010];
	const int M = 360007;
	il void add(int x, ll k){
		for (int i = head[x % M + 1]; i; i = nxt[i]) if (st[p][i] == x) return f[p][i] = (f[p][i] + k) % P, void(0);
		nxt[++en[p]] = head[x % M + 1], head[x % M + 1] = en[p], st[p][en[p]] = x, f[p][en[p]] = k;
	}il void init(){memset(head, 0, sizeof head);en[p] = 0;}
}H;
il int pos(int x, int pk){return (x >> (pk << 1)) & 3;}
il int bin(int x){return (1 << (x << 1));}
int main(){
	n = rd(), m = rd();
	for (int i = 1; i <= n; i++){
		scanf ("%s", s + 1);
		for (int j = 1; j <= m; j++)
			a[i][j] = (s[j] == '_'), maxx = (a[i][j] ? i : maxx), maxy = (a[i][j] ? j : maxy);
	}
	en[p] = f[p][1] = 1;
	if (n < m){
		for (int i = 1; i <= m; i++) for (int j = 1; j <= i; j++) swap(a[i][j], a[j][i]);
		swap(maxx, maxy), swap(n, m);
	}
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= en[p]; j++) st[p][j] <<= 2;
		for (int j = 1; j <= m; j++){
			p ^= 1, H.init();
			for (int k = 1; k <= en[p ^ 1]; k++){
				int s = st[p ^ 1][k], pright = pos(s, j - 1), pdown = pos(s, j);
				ll t = f[p ^ 1][k];
				if (!a[i][j]){
					if (!pright && !pdown) H.add(s, t);
				}else if (!pright && !pdown){
					if (a[i][j + 1]) H.add(s + bin(j), t);
					if (a[i + 1][j]) H.add(s + bin(j - 1), t);
					if (a[i + 1][j] && a[i][j + 1]) H.add(s + (bin(j) << 1) + (bin(j - 1) << 1), t);
				}else if (!pright && pdown == 1){
					if (a[i + 1][j]) H.add(s - bin(j) + bin(j - 1), t);
					if (a[i][j + 1]) H.add(s + bin(j), t);
				}else if (pright == 1 && !pdown){
					if (a[i + 1][j]) H.add(s + bin(j - 1), t);
					if (a[i][j + 1]) H.add(s + bin(j) - bin(j - 1), t);
				}else if (!pright && pdown == 2){
					if (maxx == i && maxy == j) ans = (ans + t) % P;
					else if (a[i + 1][j]) H.add(s - (bin(j) << 1) + (bin(j - 1) << 1), t);
					H.add(s - (bin(j) << 1), t);
				}else if (pright == 2 && !pdown){
					if (maxx == i && maxy == j) ans = (ans + t) % P;
					else if (a[i][j + 1]) H.add(s + (bin(j) << 1) - (bin(j - 1) << 1), t);
					H.add(s - (bin(j - 1) << 1), t);
				}else if (pright == 1 && pdown == 1){
					if (maxx == i && maxy == j) ans = (ans + t) % P;
					H.add(s - bin(j) - bin(j - 1), t);
				}
			}
		} 
	}printf ("%lld\n", ans);
	return 0;
}

```

---

## 作者：hh20080501hh (赞：2)

# 题目
[题面戳我哦](https://www.luogu.com.cn/problem/P3272)

题意简述：有形如 $L$ 的地板和一块矩形地面，在矩形地面上有些位置是 $* $ 有些位置是 $_ $，对于星星位置，不能铺地板。问有多少种铺地板的方案。其中对于每一个地板，必须要拐一个弯，即不能是一条直线。

# 分析

**如果不会插头 DP 模板，请先学习再来看本题解，本题解默认读者都会插头 DP 的模板！**

[插头 DP 模板指路](https://www.luogu.com.cn/problem/P5056)

看到求方案数，我们很容易想到用 DP 来解决，再瞄一眼数据范围，容易想到是插头或者状压。状压不是很容易表示这道题的状态，所以我们选择使用插头 DP。

由于这道题中地板能且仅能拐一个弯，所以我们可以这样设计状态：

- 用 $0$ 表示没有地板。
- 用 $1$ 表示有地板，且这个地板没有拐过弯。
- 用 $2$ 表示有地板，且这个地板已经拐过弯了。

所以我们的状态需要用三进制来存。由于四进制更快更好写，我们用四进制来写。

我们开始分类讨论：

为了方便表示，我们规定：$i$ 表示行数，$j$ 表示列数，且下标都是从 $1$ 开始。$x$ 表示左插头状态，$y$ 表示右插头状态。$g_{i,j}$ 表示是否能铺地板，其中 $1$ 为可以铺地板。$state$ 为当前状态表示，$w$ 为当前状态的方案数。

1. 当前 $g_{i,j}$ 为 $0$，那么这个格子不能有插头，我们继承上一个状态。即 `insert (cur , state , w);`

以下情况中 $g_{i,j}$ 为 $1$。

2. 当 $x=0$ 且 $y=0$ 时，我们有三种情况：
	+ 我们选择往下伸插头，那么我们 `insert (cur , state+build(j-1 , 1) , w);`
   + 我们选择往右伸插头，那么我们 `insert (cur , state+build(j , 1) , w);`
   + 我们两个方向都伸插头，那么我们 `insert (cur , state+build(j-1 , 2)+build(j , 2) , w);`
3. 当 $x=0$ 且 $y=1$ 时，我们有两种情况：
	+ 我们选择往下延伸上插头，那么我们 `insert (cur , state+build(j-1 , 1)-build(j , 1) , w);`
   + 我们选择往右延伸，也就是拐个弯，那么我们要把状态从 $1$ 转换成 $2$。即 `insert (cur , state+build(j , 1) , w);`
4. 当 $x=1$ 且 $y=0$ 时，同情况三。
5. 当 $x=1$ 且 $y=1$ 时，也就是说两个没有拐过弯的插头相遇了！他们会接在一起，变成一个拐弯的。注意，如果这个格子是最后一个可以铺地板的格子时，我们需要更新答案。即：
```cpp
if (end_x==i && end_y==j)
{
	res = (res+w)%mod;
}
insert (cur , state-build(j-1 , 1)-build(j , 1) , w);
```
6. 当 $x=2$ 且 $y=0$ 时，左插头是拐了弯的地板，那要么就这样终止左插头对应的地板，要么往右延伸。同时，如果这个格子是最后一个铺地板的格子，我们也要更新答案。即：
```cpp
if (end_x==i && end_y==j)
{
	res = (res+w)%mod;
}				
if (j+1<=m && g[i][j+1])
{
	insert (cur , state-build(j-1 , 2)+build(j , 2) , w);
}
insert (cur , state-build(j-1 , 2) , w);
```
7. 当 $x=0$ 且 $y=2$ 时，同情况六。
8. 当 $x=2$ 且 $y=1$ 时，左插头对应的地板已经拐过弯了，而上插头也需要插进来，这样会冲突，所以这种情况不合法。
9. 当 $x=1$ 且 $y=2$ 时，同上。
10. 当 $x=2$ 且 $y=2$ 时，同上。
# 代码
稍微有点细节：
- 进行状态转移时，转到的新格子是可以铺地板的。如上文情况三中往下延伸插头，那么 $g_{i+1,j}$ 是一个能铺地板的格子，不然不能转移。
- 进行状态转移时，因为需要判断是否能铺，所以可能会造成数组越界，记得不能让数组越界了。
- 由于我们插头 DP 是以行来枚举的，但是极限情况下可能是一个长为 $50$ 宽为 $2$ 的矩形，那么我们状态就要存十进制下一百位，这个大小会爆掉。其次这样状态数会很多很多，时间复杂度上也没有保证，所以我们需要交换一下 $r$ 和 $c$，并且把矩形旋转九十度。

下面放出代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 2e5 , M = N*2+7 , mod = 20110520;

int n , m;	//用n和m来代替r和c
int g[110][110] , g1[110][110];
int q[2][N] , cnt[2];
int v[2][M] , h[2][M];
int end_x , end_y;

int find (int cur , int state)	//哈希表找位置
{
	int t = state%M;
	while (h[cur][t]!=-1 && h[cur][t]!=state)
	{
		if (++t==M) t = 0;
	}
	return t;
}

void insert (int cur , int state , int w)	//哈希表插入
{
	int t = find (cur , state);
	if (h[cur][t]==-1)
	{
		h[cur][t] = state , v[cur][t] = w;
		q[cur][++cnt[cur]] = t;
	}
	else 
	{
		v[cur][t] = (v[cur][t]+w)%mod;
	}
}

int get (int state , int k)	//找到第k位
{
	return (state>>(k*2))&3;
}

int build (int k , int x)	//构造出第k位值为x的数
{
	return x*(1<<(k*2));
}

signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);
	
	cin >> n >> m;
	for (int i=1 ; i<=n ; i++)
	{
		string s;
		cin >> s;
		for (unsigned int j=0 ; j<s.size() ; j++)
		{
			if (s[j]=='_')
			{
				g1[i][j+1] = 1;
				g[i][j+1] = 1;
				end_x = i , end_y = j+1;
			}
		}
	} 
	if (end_x==0 && end_y==0)	//特判全是不能选的
	{
		cout << "1\n";
		return 0;
	}
	if (n<m)	//旋转矩形，交换n和m
	{
		for (int i=1 ; i<=m ; i++)
		{
			for (int j=1 ; j<=n ; j++)
			{
				g[i][j] = g1[j][i];
			}
		}
		swap (n , m) , swap (end_x , end_y);
	}
	
	int res = 0;
	memset (h , -1 , sizeof h);
	int cur = 0;
	insert (cur , 0 , 1);
	for (int i=1 ; i<=n ; i++)
	{
		for (int j=1 ; j<=cnt[cur] ; j++)//换行
		{
			h[cur][q[cur][j]]<<=2;
		}
		for (int j=1 ; j<=m ; j++)
		{
			int last = cur;
			cur ^= 1 , cnt[cur] = 0;
			memset (h[cur] , -1 , sizeof h[cur]);
			for (int k=1 ; k<=cnt[last] ; k++)
			{
				int state = h[last][q[last][k]] , w = v[last][q[last][k]];
				int x = get (state , j-1) , y = get (state , j);
				if (!g[i][j])	//情况1
				{
					insert (cur , state , w);
				}
				else if (x==0 && y==1)	//情况3
				{
					if (i+1<=n && g[i+1][j])
					{
						insert (cur , state+build(j-1 , 1)-build(j , 1) , w);
					}
					if (j+1<=m && g[i][j+1])
					{
						insert (cur , state+build(j , 1) , w);
					}
				}
				else if (x==1 && y==0)	//情况4
				{
					if (j+1<=m && g[i][j+1])
					{
						insert (cur , state-build(j-1 , 1)+build(j , 1) , w);
					}
					if (i+1<=n && g[i+1][j])
					{
						insert (cur , state+build(j-1 , 1) , w);
					}
				}
				else if (x==1 && y==1)	//情况5
				{
					if (end_x==i && end_y==j)
					{
						res = (res+w)%mod;
					}
					insert (cur , state-build(j-1 , 1)-build(j , 1) , w);
				}
				else if (x==2 && y==0)	//情况6
				{
					if (end_x==i && end_y==j)
					{
						res = (res+w)%mod;
					}				
					if (j+1<=m && g[i][j+1])
					{
						insert (cur , state-build(j-1 , 2)+build(j , 2) , w);
					}
					insert (cur , state-build(j-1 , 2) , w);
				}
				else if (x==0 && y==2)	//情况7
				{
					if (end_x==i && end_y==j)
					{
						res = (res+w)%mod;
					}
					if (i+1<=n && g[i+1][j])
					{
						insert (cur , state-build(j , 2)+build(j-1 , 2) , w);
					}
					insert (cur , state-build(j , 2) , w);
				}
				else if (x==0 && y==0)	//情况2
				{
					if (j+1<=m && g[i][j+1])
					{
						insert (cur , state+build(j , 1) , w);
					}
					if (i+1<=n && g[i+1][j])
					{
						insert (cur , state+build(j-1 , 1) , w);
					}
					if (i+1<=n && j+1<=m && g[i+1][j] && g[i][j+1])
					{
						insert (cur , state+build(j-1 , 2)+build(j , 2) , w);
					}
				}
			}
		}
	}
	cout << res << '\n';
	return 0;
}

```

---

## 作者：Conan15 (赞：1)

## 前言

[更坏的阅读体验](https://www.acwing.com/solution/content/265193/)。\
先学了模板，发现模板甚至比这题难……\
终于会独立完成插头 DP 啦哈哈哈！\
如果你对插头 DP 一无所知，请出门右转至 [【模板】插头 DP](https://www.luogu.com.cn/problem/P5056)。

## 观察性质

由于 $1 \leq r \times c \leq 100$，所以 $1 \leq \min(r, c) \leq 10$。考虑使用插头 DP。

此题于模板题的不同之处主要有如下两点：

1. 影响 `L` 形的主要因素是**转弯次数**。
2. 本题**不需要维护连通性**。

综合这两点，可以想到这样的状压：$0$ 代表无插头，$1$ 代表**没有转过弯**的插头，$2$ 代表**转过弯**的插头。\
对于其它和模板题相似的部分这里就不再赘述，直接讲解如何转移。

## 状态转移

如下图，为了表示方便，设当前方格的左插头是 $x$，上插头是 $y$。

![屏幕截图 2025-01-30 214822.png](https://cdn.acwing.com/media/article/image/2025/01/30/86777_e9684ed9df-屏幕截图-2025-01-30-214822.png) 

显然每个插头有 $3$ 种状态，有 $2$ 个插头，同时加上这个格子本身是障碍物，总共有 $3^2 + 1 = 10$ 种情况要讨论。\
下文的二元组 $(x', y')$ 表示这种转移需要把原状态中 $(x, y)$ 的位置替换为 $(x', y')$。

1. 障碍物：如果格子本身是障碍物，当 $x=0, y=0$ 的时候，直接继承上一个状态即可。
2. $x=0, y=0$：往下走 $(1, 0)$、往右走 $(0, 1)$、同时建立右下插头 $(2, 2)$。
3. $x=0, y=1$：可以往下走 $(1, 0)$，或者往右走 $(0, 2)$。（注意往右走会形成 `L` 所以要赋值为 $2$）
4. $x=1, y=0$：与上一条同理。
5. $x=0, y=2$：往下走 $(2, 0)$、停下来 $(0, 0)$。
6. $x=2, y=0$：和上一条同理。
7. $x=1, y=1$：汇集在此处形成一个 `L`，下面不能再延伸插头。$(0, 0)$。
8. 其余 $3$ 种情况：显然会产生至少两个 `L`，与题意矛盾。

## 注意事项

1. 数组开太小也会导致最后一个测试点 TLE。
2. 统计答案，仅当这种决策会导致完整的 `L` 形成，同时当前在**最后一个合法点**。
3. 一定要画图自己推！一定要画图自己推！一定要画图自己推！

## 代码

省略了 `Modint` 部分，另外写法比较抽象。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1.8e5 + 15, M = 3.6e5 + 7, K = 115;
const int mod = 20110520;

typedef Modint<long long, mod> Mint;    //记得自定义 mod

int n, m, ex, ey;

char ch[K][K];
int mp[K][K], q[2][M], cnt[2];
int h[2][M];
Mint v[2][M];
Mint ans = 0;

inline void rev() {
    swap(n, m), swap(ex, ey);
    for (register int i = 1; i <= n; i++)
        for (register int j = 1; j < i; j++) swap(ch[i][j], ch[j][i]), swap(mp[i][j], mp[j][i]);
}

inline int find(int t, int x) {
    int pos = x % M;
    while (h[t][pos] != -1 && h[t][pos] != x) {
        pos++;
        if (pos == M) pos = 0;
    }
    return pos;
}
inline void insert(int t, int S, Mint w) {
    int pos = find(t, S);
    if (h[t][pos] == -1) {
        h[t][pos] = S, v[t][pos] = w;
        q[t][++cnt[t]] = pos;
    } else v[t][pos] += w;
}

inline int get(int S, int k) { return (S >> (k << 1)) & 3; }
inline int up(int k, int v) { return v * (1 << (k << 1)); }


int main() {
    scanf("%d%d", &n, &m);
    for (register int i = 1; i <= n; i++) scanf("\n %s", ch[i] + 1);
    for (register int i = 1; i <= n; i++)
        for (register int j = 1; j <= m; j++)
            if (ch[i][j] == '_') {
                mp[i][j] = 1;
                ex = i, ey = j;
            }
    if (n < m) rev();
    
    memset(h, -1, sizeof h); cnt[0] = cnt[1] = 0;
    int t = 0;
    insert(t, 0, 1);
    
    for (register int i = 1; i <= n; i++) {
        for (register int j = 1; j <= cnt[t]; j++) h[t][q[t][j]] <<= 2;
        for (register int j = 1; j <= m; j++) {
            t ^= 1;
            memset(h[t], -1, sizeof h[t]), cnt[t] = 0;
            for (register int k = 1; k <= cnt[t ^ 1]; k++) {
                int S = h[t ^ 1][q[t ^ 1][k]];
                Mint w = v[t ^ 1][q[t ^ 1][k]];
                int x = get(S, j - 1), y = get(S, j);
                if (!mp[i][j]) {    //1. 障碍
                    if (x == 0 && y == 0) insert(t, S, w);
                } else if (x == 0 && y == 0) {
                    int T1 = S + up(j - 1, 1), T2 = S + up(j, 1), T3 = S + up(j - 1, 2) + up(j, 2);
                    if (mp[i + 1][j]) insert(t, T1, w);
                    if (mp[i][j + 1]) insert(t, T2, w);
                    if (mp[i][j + 1] && mp[i + 1][j]) insert(t, T3, w);
                } else if (x == 0 && y == 1) {
                    int T1 = S + up(j - 1, 1) - up(j, 1), T2 = S + up(j, 1);
                    if (mp[i + 1][j]) insert(t, T1, w);
                    if (mp[i][j + 1]) insert(t, T2, w);
                } else if (x == 1 && y == 0) {
                    int T1 = S + up(j, 1) - up(j - 1, 1), T2 = S + up(j - 1, 1);
                    if (mp[i][j + 1]) insert(t, T1, w);
                    if (mp[i + 1][j]) insert(t, T2, w);
                } else if (x == 0 && y == 2) {
                    int T1 = S - up(j, 2), T2 = S - up(j, 2) + up(j - 1, 2);
                    insert(t, T1, w);
                    if (mp[i + 1][j]) insert(t, T2, w);
                    
                    if (i == ex && j == ey) ans += w;
                } else if (x == 2 && y == 0) {
                    int T1 = S - up(j - 1, 2), T2 = S - up(j - 1, 2) + up(j, 2);
                    insert(t, T1, w);
                    if (mp[i][j + 1]) insert(t, T2, w);
                    
                    if (i == ex && j == ey) ans += w;
                } else if (x == 1 && y == 1) {
                    int T = S - up(j - 1, 1) - up(j, 1);
                    insert(t, T, w);
                    if (i == ex && j == ey) ans += w;
                }
            }
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：Rorschachindark (赞：1)

# 地板
[题目传送门](https://www.luogu.com.cn/problem/P3272)
## 题目大意
现在有一个$n\times m$的一张图，有些格有障碍，要用$\text L$型的地板将所有没有障碍的格子填满。请您求出方案数。
## 思路
第一道自己码出来的插头dp题目纪念一下。

首先需要定义插头，这里我们可以发现的是，一个$\text L$型的地板能且只能转一次弯，所以利用这个性质，我们就可以定义插头了。插头就是是否拐了弯，可以用$1,2$表示，所以用$4$进制就好了。

之后的转移很简单就不讲了，可以自己想一下或者看我的代码。

不过，这样的时间复杂度是$\Theta(nm3^{m})$的，显然$n,m\leq 100$，就$\text {GG}$了。但是我们发现最小的那个数一定不会大于$\sqrt {100}=10$，所以在$n<m$的时候可以把$n,m$换一下再搞。于是时间复杂度就是$\Theta(100\times 3^{10}\approx 6\times 10^6)$。
## $\text {Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define bits(x) ((x)<<1)
#define Int register int
#define bigmod 20110520
#define INF 0x7f7f7f7f

template <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}
template <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}
template <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}

struct Hash_Table{
#define mod 590027
	int dp[1 << 24],top,cnt,state[1 << 24];
	struct edge{
		int v,nxt;
	}e[600005];
	int head[600005];
	void Init(){
		top = cnt = 0;
		memset (head,0,sizeof (head));
	}
	void Insert_into_hash_table (int bit,int val){
		int key = bit % mod;
		for (Int i = head[key];i;i = e[i].nxt){
			int v = e[i].v;
			if (state[v] == bit){
				dp[v] = (dp[v] + val) % bigmod;
				return ;
			}
		}
		++ cnt;
		state[cnt] = bit,dp[cnt] = val;
		e[++ top] = edge {cnt,head[key]};head[key] = top;
	}
#undef mod
}HT[2]; 

int n,m;
int Map[105][105];

void Put_in_data (){
	read (n,m);
	if (n >= m){
		for (Int i = 1;i <= n;++ i){
			char s[105] = {};
			scanf ("%s",s + 1);
			for (Int j = 1;j <= m;++ j)
				Map[i][j] = (s[j] == '_');
		}				
	}
	else{
		swap (n,m);
		for (Int i = 1;i <= m;++ i){
			char s[105] = {};
			scanf ("%s",s + 1);
			for (Int j = 1;j <= n;++ j)
				Map[j][i] = (s[j] == '_'); 
		}
	}
}

void Solve_this_problem (){
	int inv = 1,las = 0;
	HT[inv].Insert_into_hash_table (0,1);
	for (Int i = 1;i <= n;++ i){
		for (Int j = 1;j <= HT[inv].cnt;++ j) HT[inv].state[j] <<= 2;
		for (Int j = 1;j <= m;++ j){
			swap (inv,las);
			HT[inv].Init();
			for (Int k = 1;k <= HT[las].cnt;++ k){
				int nowsta = HT[las].state[k],nowans = HT[las].dp[k];
				int be_right = (nowsta >> (2 * (j - 1))) % 4,be_down = (nowsta >> (2 * j)) % 4;
				if (!Map[i][j]){
					if (!be_right && !be_down)
						HT[inv].Insert_into_hash_table (nowsta,nowans); 
				}
				else if (!be_right && !be_down){
					if (Map[i + 1][j] && Map[i][j + 1]) HT[inv].Insert_into_hash_table (nowsta + 2 * (1 << bits (j - 1)) + 2 * (1 << bits (j)),nowans);
					if (Map[i + 1][j]) HT[inv].Insert_into_hash_table (nowsta + (1 << bits (j - 1)),nowans); 
					if (Map[i][j + 1]) HT[inv].Insert_into_hash_table (nowsta + (1 << bits (j)),nowans);
				}
				else if (!be_right && be_down == 1){
					if (Map[i][j + 1]) HT[inv].Insert_into_hash_table (nowsta + (1 << bits (j)),nowans);
					if (Map[i + 1][j]) HT[inv].Insert_into_hash_table (nowsta - (1 << bits (j)) + (1 << bits (j - 1)),nowans);  
				}
				else if (!be_right && be_down == 2){
					if (Map[i + 1][j]) HT[inv].Insert_into_hash_table (nowsta - 2 * (1 << bits (j)) + 2 * (1 << bits (j - 1)),nowans);
					HT[inv].Insert_into_hash_table (nowsta - 2 * (1 << bits (j)),nowans);  
				}
				else if (be_right == 1 && !be_down){
					if (Map[i][j + 1]) HT[inv].Insert_into_hash_table (nowsta - (1 << bits (j - 1)) + (1 << bits (j)),nowans);
					if (Map[i + 1][j]) HT[inv].Insert_into_hash_table (nowsta + (1 << bits (j - 1)),nowans);  
				}
				else if (be_right == 2 && !be_down){
					if (Map[i][j + 1]) HT[inv].Insert_into_hash_table (nowsta - 2 * (1 << bits (j - 1)) + 2 * (1 << bits (j)),nowans);
					HT[inv].Insert_into_hash_table (nowsta - 2 * (1 << bits (j - 1)),nowans);  
				}
				else if (be_right == 1 && be_down == 1)
					HT[inv].Insert_into_hash_table (nowsta - (1 << bits (j - 1)) - (1 << bits (j)),nowans);
			}
		}
	}
	int count = 0;
	for (Int i = 1;i <= HT[inv].cnt;++ i){
		int nowsta = HT[inv].state[i],nowans = HT[inv].dp[i];
		if (nowsta == 0) count = (count + nowans) % bigmod;
	} 
	write (count),putchar ('\n');
}

signed main(){
	Put_in_data ();
	Solve_this_problem ();
	return 0;
}
```

---

## 作者：Priestess_SLG (赞：0)

插头 dp 入门题，（建议先做这题然后再做 ~~5066~~ 5056）。仍然是套路的搞一个轮廓线然后按照顺序处理每一个轮廓线打折的地方。假设当前枚举到 $(i,j)$ 格子，左插头为 $p$，上插头为 $q$。

这里定义插头 $x$ 的状态：

+ $x=0$，表示该方向无插头。
+ $x=1$，表示该方向插头还没有打折。
+ $x=2$，表示该方向插头已经打折了。

那么开始分类讨论（第 $i$ 条需要满足其自身成立且 $j\in [1,i)$ 使得第 $j$ 条不成立才会执行）：

+ $(i,j)$ 位置为障碍，则该位置不能被覆盖，必须满足 $x=0,y=0$ 才可转移，转移保留原来的状态即可。
+ $x=0,y=0$，则可以 $(i,j)$ 单独向右延申，单独向下延申，以当前结点为支点同时向右下两个方向延申三种转移，分类在轮廓线上更新即可。
+ $x=0,y=1$，则其上面已经有一个没有打折过的转移了，可以继续往下面转移，也可以打一下折往右边转移，同样在轮廓线上更新即可。
+ $x=0,y=2$，则其上面已经有一个打过折的转移了，可以在 $(i,j)$ 点直接停下，也可以继续往下延申，同样在轮廓线上更新即可。
+ $x=1,y=0$，则其左面已经有一个没有打过折的转移了，可以继续往右面转移，也可以打一下折往下面转移，同样在轮廓线上更新即可。
+ $x=1,y=1$，则其上面和左面同时都有一个未打过折的转移，那么其在 $(i,j)$ 相遇直接合并状态以 $(i,j)$ 为支点形成一个满血的 L，在轮廓线上删去这两个插头即可。
+ $x=1,y=2$，十分不合法。
+ $x=2,y=0$，则其左面已经有一个打过折的转移了，可以在 $(i,j)$ 点直接停下，也可以继续往左延申，同样在轮廓线上更新即可。
+ $x=2,y=1$，十分不合法。
+ $x=2,y=2$，十分不合法。

直接暴力分讨上面所有的转移情况即可。

```cpp
// #pragma GCC optimize(3,"Ofast","inline","unroll-loops")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>
#define int long long
using namespace std;
const int N = 400010;
const int inf = 2e9;
const int mod = 20110520;
using ull = unsigned long long;
template<class _T>
using treap = __gnu_pbds::tree<_T, __gnu_pbds::null_type, less_equal<_T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;
using POD = pair<double, double>;
template<const signed _N, const signed _M>
struct HashTable {
    int idx, ID[_M], sum[_M], h[_N], ne[_M];
    void Mahiro() {
        idx = 0, memset(h, -1, sizeof h);
    }
    void ins(int x, int val) {
        int id = x % _N;
        for (int i = h[id]; ~i; i = ne[i])
            if (ID[i] == x) {(sum[i] += val) %= mod; return;}
        ne[++idx] = h[id], h[id] = idx, ID[idx] = x, sum[idx] = val;
    }
    int query(int x) {
        int id = x % _N;
        for (int i = h[id]; ~i; i = ne[i])
            if (ID[i] == x) return sum[i];
        return 0;
    }
};
template<const signed _N, const signed _M>
void swp(HashTable<_N, _M> &a, HashTable<_N, _M> &b) {
    swap(a.idx, b.idx);
    for (int i = 0; i < _M; ++i)
        swap(a.ID[i], b.ID[i]), swap(a.sum[i], b.sum[i]), swap(a.ne[i], b.ne[i]);
}
inline int getpos(int i, int j) {
    return i >> (j + j - 2) & 3;
}
inline int modpos(int i, int j, int k) {
    return i ^ (getpos(i, j) << (j + j - 2)) ^ (k << (j + j - 2));
}
HashTable<289063, N*2> ht[2];
inline int getl(int i, int j, int m) {
    int cnt = 0;
    for (int k = j; k; --k) {
        int o = getpos(i, k);
        if (o == 1) --cnt;
        else if (o == 2) ++cnt;
        if (!cnt) return k;
    } return -1;
}
inline int getr(int i, int j, int m) {
    int cnt = 0;
    for (int k = j; k <= m + 1; ++k) {
        int o = getpos(i, k);
        if (o == 1) ++cnt;
        else if (o == 2) --cnt;
        if (!cnt) return k;
    } return -1;
}
char s[150][150], t[150][150];
signed main() {
    // freopen("debug.err", "w", stderr);
    cin.tie(0)->sync_with_stdio(false);
    cout << fixed << setprecision(15);
    srand(time(0));
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j) cin >> s[i][j];
    if (n < m) {
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= m; ++j) t[i][j] = s[i][j];
        for (int i = 1; i <= m; ++i)
            for (int j = 1; j <= n; ++j) s[i][j] = t[j][i];
        n ^= m ^= n ^= m;
    }
    int tx = 0, ty = 0;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j)
            if (s[i][j] != '*') tx = i, ty = j;
    // cout << "End " << tx << ' ' << ty << '\n';
    if (!tx && !ty) {
        cout << "1\n";
        return 0;
    }
    for (int o = 0; o < 2; ++o) ht[o].Mahiro();
    ht[0].ins(0, 1);
    int pre = 0, nxt = 1, sum = 0;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            for (int k = 1; k <= ht[pre].idx; ++k) {
                const int state = ht[pre].ID[k], dp = ht[pre].sum[k];
                int p = getpos(state, j), q = getpos(state, j + 1);
                // cerr << "Wa " << i << ' ' << j << ' ' << k << ' ' << p << ' ' << q << ' ' << dp << '\n';
                if (s[i][j] == '*') {
                    if (!p && !q) ht[nxt].ins(state, dp);
                } else {
                    if (!p && !q) {
                        if (j < m && s[i][j + 1] != '*') ht[nxt].ins(modpos(state, j + 1, 1), dp);
                        if (i < n && s[i + 1][j] != '*') ht[nxt].ins(modpos(state, j, 1), dp);
                        if (i < n && j < m && s[i + 1][j] != '*' && s[i][j + 1] != '*') ht[nxt].ins(modpos(modpos(state, j, 2), j + 1, 2), dp);
                    } else if (!p && q == 1) {
                        if (j < m && s[i][j + 1] != '*') ht[nxt].ins(modpos(state, j + 1, 2), dp);
                        if (i < n && s[i + 1][j] != '*') ht[nxt].ins(modpos(modpos(state, j, 1), j + 1, 0), dp);
                    } else if (!p && q == 2) {
                        if (i == tx && j == ty) sum = (sum + dp) % mod;
                        else if (i < n && s[i + 1][j] != '*') ht[nxt].ins(modpos(modpos(state, j, 2), j + 1, 0), dp);
                        ht[nxt].ins(modpos(state, j + 1, 0), dp);
                    } else if (p == 1 && !q) {
                        if (i < n && s[i + 1][j] != '*') ht[nxt].ins(modpos(state, j, 2), dp);
                        if (j < m && s[i][j + 1] != '*') ht[nxt].ins(modpos(modpos(state, j, 0), j + 1, 1), dp);
                    } else if (p == 1 && q == 1) {
                        if (i == tx && j == ty) sum = (sum + dp) % mod;
                        ht[nxt].ins(modpos(modpos(state, j, 0), j + 1, 0), dp);
                    } else if (p == 2 && !q) {
                        if (i == tx && j == ty) sum = (sum + dp) % mod;
                        else if (j < m && s[i][j + 1] != '*') ht[nxt].ins(modpos(modpos(state, j + 1, 2), j, 0), dp);
                        ht[nxt].ins(modpos(state, j, 0), dp);
                    }
                }
            }
            ht[pre].Mahiro();
            pre ^= nxt ^= pre ^= nxt;
        }
        for (int k = 1; k <= ht[pre].idx; ++k) {
            int state = ht[pre].ID[k], dp = ht[pre].sum[k];
            if (!getpos(state, m + 1)) ht[nxt].ins(state << 2, dp);
        }
        ht[pre].Mahiro();
        pre ^= nxt ^= pre ^= nxt;
    }
    cout << sum << '\n';
    return 0;
}
// 喵喵

```

---

## 作者：翼德天尊 (赞：0)

> 给定一个 $r\times c$ 的棋盘，用若干任意大小的 L 型砖铺满地板，求方案数。有的地方不能铺。
>
> $1\le r\times c\le 100$

考虑注意到本题特殊的数据范围，其实就是限制了 $\min(r,c)\le 10$。于是我们 $r$ 和 $c$ 中将较小的一个作为轮廓线即可保证复杂度。 

然后套插头 dp 一般步骤解题。

首先题目要求用 L 铺满地板，而每一个 L 都需要且只能拐一次，于是对于每一个插头，显然有三种状态：$0$ 表示没有插头，$1$ 表示该插头还没有拐过，$2$ 表示该插头已经拐过了。故轮廓线用四进制数表示即可。

其次考虑转移。对于每一个格子：

- 若为障碍格，则四个插头都没有。
- 若没有左插头和上插头，则需要新建一个 L 型的砖，而由于该格本身就是一个拐点，所以右插头和下插头都为 $2$。
- 若左插头和上插头有其一，延伸插头即可。除此之外，如果该插头为 $1$，则可以选择将该格作为拐点；若该插头为 $2$，则可以考虑在该格停止向右向下延伸。

- 若左插头和上插头都有，则只能在两个插头都为 $1$ 的时候合并插头。

利用 hash 表依次转移即可。

```cpp
h[now].insert(0,1);
for (int i=1;i<=n;i++){
	for (int j=1;j<=m;j++){
		bool la=now;now^=1;
		h[now].clear();
		for (int k=1;k<=h[la].tot;k++){
			int p=h[la].val[k];
			ll v=h[la].sum[k];
			if (j==1){
				if ((p>>(m<<1))%4!=0) continue;
				p<<=2;
			}
			int now1=(p>>(j-1<<1))%4,now2=(p>>(j<<1))%4;
			if (!a[i][j]){
				if (!now1&&!now2) h[now].insert(p,v);
				continue;
			}
			if (!now1&&!now2){
				h[now].insert(p^(1<<(j-1<<1)),v);
				h[now].insert(p^(1<<(j<<1)),v);
				h[now].insert(p^(2<<(j-1<<1))^(2<<(j<<1)),v);
			}else if (now1&&!now2){
				h[now].insert(p^(now1<<(j-1<<1))^(now1<<(j<<1)),v);
				if (now1==1) h[now].insert(p^(1<<(j-1<<1))^(2<<(j-1<<1)),v);
				else h[now].insert(p^(now1<<(j-1<<1)),v);
			}else if (now2&&!now1){
				h[now].insert(p^(now2<<(j-1<<1))^(now2<<(j<<1)),v);
				if (now2==1) h[now].insert(p^(1<<(j<<1))^(2<<(j<<1)),v);
				else h[now].insert(p^(now2<<(j<<1)),v);
			}else if (now1&&now2){
				if (now1==1&&now2==1) h[now].insert(p^(now1<<(j-1<<1))^(now2<<(j<<1)),v);
			}
		}
	}
}
```

---

## 作者：aaaaaaaawsl (赞：0)

### 题目大意

给定一个网格图，使用 L 型的砖不重叠的铺满这个图，有些格子不能铺砖，问方案数。

--------------

### 题目分析

看到这道题，我们可以把一个 L 型砖里的所有格子看做是联通的。每个 L 砖之间互不影响，所以可以想到插头 DP。下面看看要求联通的格子的要求：

- 要求在一个 L 砖的格子必须上下或左右相邻，且不能在格子外面。

- 必须是一个 L 型，也就是必须有一个且只有一个拐点。

- L 型的长度不限。

- 可以铺任意多个砖。

与模板题不同的是，这道题 __不__ 要求满足限制的联通块只有一个，所以我们可以在决策过程中增加新的联通块。但是，每个连通块 __只能有并且必须有__ 一个拐点。由这两条性质，我们可以设计出每一个插头的表示。

插头 DP 本质上是状压 DP， 不过由于要处理连通性，所以引入插头这一概念，来表示某一边界的状态，本题的插头分为 $0$，$1$，$2$。表示没有插头，当前的插头没有拐，当前的插头已经拐了。考虑到计算机里的位运算便捷又高效，我们把一个状态 像状压一样用一个二进制数来表示。但是要表示出 $0$，$1$，$2$，所以我们 __用两位二进制数来表示一个插头，来实现最少需要三进制数才能实现的功能__ 。这是大多数插头 DP 题解和博客没有提到的关于四进制，三进制的本质。 

另一个的插头 DP 的疑惑点是关于插头转移时的描述，状态表示的是 __轮廓线__ 上的插头状态，而不是 __格子__ 上的。$m$ 个格子的一行，轮廓线长度为 $m + 1$。在处理到第 j 个格子的时候，它的左插头指的是轮廓线上第 $j$ 个插头。上插头指的是轮廓线上第 $j + 1$ 个插头。这个格子转移完，将轮廓线翻下来，他的下插头是轮廓线上第 $j$ 个插头，右插头是轮廓线上第 $j + 1$ 个插头。这是状态转移的关键，请结合其他博客的图理解我说的话。

下面分类讨论状态的转移。

对于当前正在决策的这个格子：

- 当它没有左插头，上插头：
	
    如果这个格的下一个格合法，那么我们可以新建一个向下的1插头。
    
    如果这个格的右一个格合法，那么我们可以新建一个向下的1插头。
    
    如果这个格下、右格都合法， 那么我们可以新建一个向下的2插头，向右的2插头作为拐点。
    
- 当它没有左插头，有上插头：

	当上插头为 2，只能向下建 2 插头或者结束这一个砖。
    此时如果在结束点，统计答案。
    
   当上插头为 1，可以向下建 1插头，或者向右建 2 插头。

- 当它没有上插头，有左插头：
	
   同上， 请自证，在此不多复述。
   
- 当它有上插头，下插头
	
   若上插头，下插头都为 1，表示它们在这个格合并。
   此时如果在结束点，统计答案。
   
   如果都为 2，是不合法状态，不需要考虑。
   
更新状态的时候，记得想着轮廓线，是否要删掉原先的插头，以及怎么添加新插头。

由于我们是逐行考虑去枚举每一格，所以如果列比行大，在这题的数据范围下会超时，我们在输入的时候预处理一下即可。

-----------

code :

``` cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int Mod = 20110520;
const int N = 20;
const int M = 300010;

int n, m, ans;
int a[150][150];
char s;
int que[2][M], val[2][M];
int tw[N], cnt[2];
int ei, ej;
int now;
int last, num;

int Next[M * 10], head[M * 10];
int idx;
void Zip(int bit, int num){
	long long u = bit % Mod + 1;
	for(int i = head[u]; i; i = Next[i]){
		if(que[now][i] == bit){
			val[now][i] = (val[now][i] + num) % Mod;
			return;
		}
	}
	Next[++ cnt[now]] = head[u];
	head[u] = cnt[now];
	que[now][cnt[now]] = bit;
	val[now][cnt[now]] = num % Mod;
}

void dp(){
	cnt[now] = 1;
	val[now][1] = 1;
	que[now][1] = 0;
	for(int i = 1; i <= n; ++ i){
		for(int j = 1; j <= cnt[now]; ++ j) que[now][j] <<= 2;
		for(int j = 1; j <= m; ++ j){
			memset(head, 0, sizeof head);
			last = now; now ^= 1;
			cnt[now] = 0;
			for(int k = 1; k <= cnt[last]; ++ k){
				int bit = que[last][k], num = val[last][k];
				int b1 = (bit >> ((j - 1) * 2)) % 4, b2 = (bit >> (j * 2)) % 4;
				if(!a[i][j]){
					if(!b1 && !b2) Zip(bit, num);
				}
				
				else if(!b1 && !b2){
					if(a[i + 1][j] && a[i][j + 1]) Zip(bit + tw[j - 1] * 2 + tw[j] * 2, num);
					if(a[i + 1][j]) Zip(bit + tw[j - 1], num);
					if(a[i][j + 1]) Zip(bit + tw[j], num); 
				}
				
				else if(b1 && !b2){
					if(b1 == 1){
						if(a[i][j + 1]) Zip(bit - tw[j - 1] + tw[j], num);
						if(a[i + 1][j]) Zip(bit + tw[j - 1], num);
					}
					if(b1 == 2){
						if(a[i][j + 1]) Zip(bit - tw[j - 1] * 2 + tw[j] * 2, num); 
						Zip(bit - tw[j - 1] * 2, num); // 结束
						if(i == ei && j == ej) ans = (ans + num) % Mod;
					}
				}
				
				else if(!b1 && b2) {
					if(b2 == 1){
						if(a[i + 1][j]) Zip(bit - tw[j] + tw[j - 1], num);
						if(a[i][j + 1]) Zip(bit + tw[j], num);
					}
					if(b2 == 2){
						if(a[i + 1][j]) Zip(bit - tw[j] * 2 + tw[j - 1] * 2, num);
						Zip(bit - tw[j] * 2, num); // 结束 
						if(i == ei && j == ej) ans = (ans + num) % Mod;
					}
				}
				
				else if(b1 == 1 && b2 == 1){
					if(i == ei &&  j == ej) ans = (ans + num) % Mod; 
					Zip(bit - tw[j - 1] - tw[j], num);
				}
			}
		}
	}
}

signed main(){
	scanf("%d%d", &n, &m);
	if(n>=m){
        for(int i = 1; i <= n; ++ i){
            for(int j = 1; j <= m; ++ j){
                char ch = getchar();
                while(ch != '*' && ch != '_') ch = getchar();
                a[i][j] = (ch == '_');
                if(a[i][j]) ei = i, ej = j;
            }
        }
    }
    else{
        swap(n, m);
        for(int i = m; i > 0; -- i){
            for(int j = 1;j <= n; ++ j){
                char ch = getchar();
                while(ch != '*' && ch != '_') ch = getchar();
                a[j][i] = (ch == '_');
                if(a[j][i] && ((j > ei) || (j == ei && i > ej))) ei = j, ej = i;
            }
        }
    }
	tw[0] = 1;
	for(int i = 1; i <= 11; ++ i) tw[i] = tw[i - 1] << 2;
	dp();
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：Hanx16Kira (赞：0)

# [SCOI2011]地板

[Luogu P3272](https://www.luogu.com.cn/problem/P3272)

## Solution

心态写崩了的一道题，不过既然是插头 DP，那还是值得写一写的。如果你不知道插头 DP，请移步[模板题](https://www.luogu.com.cn/problem/P5056)。

与模板题不相同的是，本题的路径是 L 型的，所以就不能够按照模板中插头的定义来做，这时候我们就需要将插头的定义进行更改：$1$ 表示没到转折点的时候的插头，$2$ 表示过了转折点后的插头，$0$ 则是无插头。如果你对插头 DP 足够的熟悉，其实到了这里就可以尝试自己先推一推转移的方程了。如果你推完了，或者说是对插头 DP 并不熟，那就接着往下看吧：

为了方便书写，定义 $isR$ 为当前格子左侧轮廓线的插头，$isD$ 为当前格子上侧轮廓线的插头。

### 分类讨论

#### 1. 当前格子为障碍格

很明显，这种情况的处理方式与模板题相同，如果当前格子不具有左插和上插（$isR=isD=0$），那么就是一个合法的状态，可以进行转移。

#### 2. 左插和上插都为 $1$（$isD=isR=1$）

$$
\begin{matrix}
 & \downarrow_1\\
\rightarrow_1 & \square
\end{matrix}
$$

当前格子肯定只有一种选择，就是作为 L 的拐点，所以下一个状态就是将这两个插头删除（组成了 L 型，这两个插头也就不存在了）：

$$
\begin{matrix}
&\downarrow_1\\
\rightarrow_1 & \square &0\\
&0
\end{matrix}
$$

#### 3. 左插上插都不存在（$isR=isD=0$）

$$
\begin{matrix}
 & 0\\
0 & \square
\end{matrix}
$$

当前格子此时可以作为 L 型的一个起点，也就是说右插为 $1$ 或是下插为 $1$：

$$
\begin{matrix}
&0\\
0& \square & \rightarrow_1\\
&0
\end{matrix}
$$ 
或者是

$$
\begin{matrix}
&0\\
0&\square & 0\\
&\downarrow_1
\end{matrix}
$$

同时也可以作为 L 型的拐点，右插为 $2$ 并且下插为 $2$：

$$
\begin{matrix}
&0\\
0& \square & \rightarrow_2\\
&\downarrow_2
\end{matrix}
$$

#### 4. 左插为 $1$，上插为 $0$（$isR=1,isD=0$）

$$
\begin{matrix}
& 0\\
\rightarrow_1 & \square
\end{matrix}
$$

当前格子此时可以作为 L 型一条边上的一部分，即右插为 $1$：

$$
\begin{matrix}
&0\\
\rightarrow_1&\square & \rightarrow_1\\
&0
\end{matrix}
$$

也可以作为 L 型的拐点，即下插为 $2$：

$$
\begin{matrix}
& 0\\
\rightarrow_1 & \square &0\\
& \downarrow_2
\end{matrix}
$$

#### 5. 左插为 $0$，上插为 $1$（$isR=0,isD=1$）

此种情况与第 $4$ 种近乎相同，就不再赘述。

#### 6. 左插为 $2$，上插为 $0$（$isR=2,isD=0$）

$$
\begin{matrix}
&0\\
\rightarrow_2 & \square
\end{matrix}
$$

当前格子此时可以作为 L 型的另一边继续拓展，即右插为 $2$：

$$
\begin{matrix}
&0\\
\rightarrow_2 & \square & \rightarrow_2\\
&0
\end{matrix}
$$

也可以作为这条边的终点，即不具有下插和右插：

$$
\begin{matrix}
&0\\
\rightarrow_2 & \square & 0\\
&0
\end{matrix}
$$

#### 7. 左插为 $0$，上插为 $2$（$isR=0,isD=2$）

这种情况与第 $6$ 种大体相同。

另外需要注意题目输入中只给出了 $r\times c$ 的大小，并没有给出具体某一维的大小，所以需要将小的那一维来进行状态压缩，以避免超过 $64$ 位限制。因为 $r \times c\le 100$，所以可以知道如果压缩小的一维，最多只会只有 $10$ 位（我采用的四进制压缩）。

为了减少无用的状态数，可以选用哈希表来优化空间。但即使如此也会因为格子数较多而导致空间极大，所以可以采用滚动数组的办法来优化。

### Code

代码中的状态转移部分是与上面分类的情况按顺序一一对应的，所以代码中就不会再进行解释了。

```c++
#include<bits/stdc++.h>
#define int long long
#define mem(a,b) memset(a,b,sizeof a)
using namespace std;
template<typename T> void read(T &k)
{
	k=0;T flag=1;char b=getchar();
	while (!isdigit(b)) {flag=(b=='-')?-1:1;b=getchar();}
	while (isdigit(b)) {k=k*10+b-48;b=getchar();}
	k*=flag;
}
template<typename T> void write(T k) {if (k<0) {putchar('-'),write(-k);return;}if (k>9) write(k/10);putchar(k%10+48);}
template<typename T> void writewith(T k,char c) {write(k);putchar(c);}
int n,m;
bool mp[105][105];
int pre=1,cur=0;//用于滚动
const int _MAXN=6e5,mod=20110520,HSIZE=590027;
int f[2][_MAXN+5],bits[105],ex,ey;
int state[2][_MAXN+5],tot[2],ptr[_MAXN+5],at=0;
struct HASH{
	int pre,to;
}H[_MAXN+5];
void modify(int sta,int val)//加入Hash表
{
	int key=sta%HSIZE;
	for (int i=ptr[key];i;i=H[i].pre)
		if (state[cur][H[i].to]==sta)//有这个状态
		{
			f[cur][H[i].to]=(f[cur][H[i].to]+val)%mod;//最开始这个地方取模写成对hash大小取模了，检查了一个小时……
			return;
		}
	tot[cur]++;//没有这个状态，加入hash表
	state[cur][tot[cur]]=sta;
	f[cur][tot[cur]]=val%mod;
	H[++at].to=tot[cur];
	H[at].pre=ptr[key];
	ptr[key]=at;
}
int Fans=0;
void init() {for (int i=1;i<=100;i++) bits[i]=i<<1;}//方便取对应位置
void PlugDP()
{
	tot[cur]=1;f[cur][1]=1;state[cur][1]=0;
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=tot[cur];j++) state[cur][j]<<=2;//将轮廓线下移
		for (int j=1;j<=m;j++)
		{
			swap(cur,pre);//滚动数组
			at=0,tot[cur]=0;mem(ptr,0);//清空hash表
			for (int k=1;k<=tot[pre];k++)
			{
				int nowans=f[pre][k],nowsta=state[pre][k];
				int isR=(nowsta>>bits[j-1])%4,isD=(nowsta>>bits[j])%4;
				if (!mp[i][j])//1
				{
					if ((!isD) && (!isR)) modify(nowsta,nowans);
				}
				else if (isR==1 && isD==1)//2
				{
					if (i==ex && j==ey) Fans=(Fans+nowans)%mod;
					modify(nowsta-(1<<bits[j])-(1<<bits[j-1]),nowans);
				}
				else if ((!isR) && (!isD))//3
				{
					if (mp[i+1][j]) modify(nowsta+(1<<bits[j-1]),nowans);
					if (mp[i][j+1]) modify(nowsta+(1<<bits[j]),nowans);
					if (mp[i+1][j] && mp[i][j+1]) modify(nowsta+2*(1<<bits[j-1])+2*(1<<bits[j]),nowans);
				}
				else if (isR==1 && (!isD))//4
				{
					if (mp[i][j+1]) modify(nowsta-(1<<bits[j-1])+(1<<bits[j]),nowans);
					if (mp[i+1][j]) modify(nowsta+(1<<bits[j-1]),nowans);
				}
				else if ((!isR) && isD==1)//5
				{
					if (mp[i+1][j]) modify(nowsta-(1<<bits[j])+(1<<bits[j-1]),nowans);
					if (mp[i][j+1]) modify(nowsta+(1<<bits[j]),nowans);
				}
				else if ((!isR) && isD==2)//6
				{
					if (i==ex && j==ey) Fans=(Fans+nowans)%mod;
					if (mp[i+1][j]) modify(nowsta-2*(1<<bits[j])+2*(1<<bits[j-1]),nowans);
					modify(nowsta-2*(1<<bits[j]),nowans);
				}
				else if (isR==2 && (!isD))//7
				{
					if (i==ex && j==ey) Fans=(Fans+nowans)%mod;
					if (mp[i][j+1]) modify(nowsta-2*(1<<bits[j-1])+2*(1<<bits[j]),nowans);
					modify(nowsta-2*(1<<bits[j-1]),nowans);
				}
			}
		}
	}
}
signed main()
{
	init();
	read(n),read(m);
	if (n>=m)//如果m小就不转矩阵
	{
		for (int i=1;i<=n;i++)
		{
			char st[105];scanf("%s",st+1);
			for (int j=1;j<=m;j++) if (st[j]=='_') mp[i][j]=1;
		}
	}
	else //将n转到m的位置
	{
		swap(n,m);
		for (int i=1;i<=m;i++)
		{
			char st[105];scanf("%s",st+1);
			for (int j=1;j<=n;j++) if (st[j]=='_') mp[j][i]=1;
		}
	}
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			if (mp[i][j]) ex=i,ey=j;//转置后寻找最后一个非障碍点来统计答案，因为我最开始就是这个点找错了所以就直接提到读入外面来统一寻找了
	PlugDP();
	writewith(Fans,'\n');
	return 0;
}

```

---

## 作者：Aryper (赞：0)

[SCOI2011]地板

[Github Blog](http://onlypath.github.io/2022/03/25/P3272/)。

仍然是比较弱的插头 DP。。。

不过分类讨论已经有够麻烦的了。。。

可能有人觉得这个状态不太好搞，因为这个状态要保证每个地毯只拐一次，每个地毯还必须有拐。

我们定义红（1）和黑（2）两种插头，分别表示没有拐过和拐过，用 0 表示没有插头伸出。

然后我们的插头类型大概就是这么几种：

![插头种类](https://cdn.luogu.com.cn/upload/image_hosting/z40cgp0u.png)

然后这个箭头表示会往指向的格子产生一个插头，然后那个格子必须要接上这个箭头才能转移。如果没有产生插头，对于该格子来说与 0 是等价的。

要知道的是，1 类插头可以接 2 类插头中带拐的（比如 2 中第四、五和七）；而 2 类只能接 2 类中不带拐的（并且 2 类才可以接终止插头）。

L 形一共分成四类，每一类的组成如上。

然后就是巨大多分类讨论，和一般的插头 DP 就没什么区别了。。。

每个讨论的格式基本都是：

1. 该格子的头上是什么插头。

2. 知道了头上的插头情况，讨论左侧插头情况，看这个格子能塞什么插头。

3. 根据所塞插头的情况转移。

定义状态 $f(i,j,s,k)$，其中 $s$ 是一个三进制数，表示轮廓线上向下的插头情况，$k$ 是轮廓线侧向的插头情况。

时间复杂度 $O(nm3^m)$（$m$ 取 $\min\{n,m\}$，可以通过顺时针旋转整个网格来达到优化）。

代码：
```cpp
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
namespace Ehnaev{
  inline ll read() {
    ll ret=0,f=1;char ch=getchar();
    while(ch<48||ch>57) {if(ch==45) f=-f;ch=getchar();}
    while(ch>=48&&ch<=57) {ret=(ret<<3)+(ret<<1)+ch-48;ch=getchar();}
    return ret*f;
  }
  inline void write(ll x) {
    static char buf[22];static ll len=-1;
    if(x>=0) {do{buf[++len]=x%10+48;x/=10;}while(x);}
    else {putchar(45);do{buf[++len]=-(x%10)+48;x/=10;}while(x);}
    while(len>=0) putchar(buf[len--]);
  }
}using Ehnaev::read;using Ehnaev::write;

const ll L=10,N=1e2,M=6e5,mo=20110520;

ll n,m;
ll a[N+5][N+5],f[2][L+5][M+5][3];
char s[N+5][N+5];

inline ll Pow(ll b,ll p) {ll r=1;for(;p;b*=b,p>>=1) if(p&1) r*=b;return r;}
inline ll Kch_i(ll s,ll x) {for(ll i=1;i<x;i++) s/=3ll;return s%3ll;}
inline ll Kass_i(ll s,ll x,ll y) {
  ll tmp1=Pow(3ll,x-1);ll tmp2=tmp1*3ll;return s/tmp2*tmp2+s%tmp1+y*tmp1;
}

int main() {

  n=read();m=read();
  for(ll i=1;i<=n;i++) {scanf("%s",s[i]+1);}
  if(n<m) {
    swap(n,m);
    for(ll i=1;i<=n;i++) {
      for(ll j=1;j<=m;j++) {
        a[i][j]=(s[j][i]=='_');
      }
    }
  }
  else {
    for(ll i=1;i<=n;i++) {
      for(ll j=1;j<=m;j++) {
        a[i][j]=(s[i][j]=='_');
      }
    }
  }

  ll tmp=Pow(3ll,m);f[0][m][0][0]=1;
  for(ll i=1;i<=n;i++) {
    for(ll p=0;p<tmp;p++) {
      ll tmp1=Kch_i(p,1),tmp2;
      if(tmp1==0) {
        if(a[i][1]) {
          tmp2=Kass_i(p,1,2);
          f[i&1][1][tmp2][2]=(f[i&1][1][tmp2][2]+f[(i-1)&1][m][p][0])%mo;
          tmp2=Kass_i(p,1,1);
          f[i&1][1][tmp2][0]=(f[i&1][1][tmp2][0]+f[(i-1)&1][m][p][0])%mo;
          f[i&1][1][p][1]=(f[i&1][1][p][1]+f[(i-1)&1][m][p][0])%mo;
        }
        else {
          f[i&1][1][p][0]=(f[i&1][1][p][0]+f[(i-1)&1][m][p][0])%mo;
        }
      }
      if(tmp1==1) {
        if(a[i][1]) {
          tmp2=Kass_i(p,1,0);
          f[i&1][1][tmp2][2]=(f[i&1][1][tmp2][2]+f[(i-1)&1][m][p][0])%mo;
          f[i&1][1][p][0]=(f[i&1][1][p][0]+f[(i-1)&1][m][p][0])%mo;
        }
      }
      if(tmp1==2) {
        if(a[i][1]) {
          tmp2=Kass_i(p,1,0);
          f[i&1][1][tmp2][0]=(f[i&1][1][tmp2][0]+f[(i-1)&1][m][p][0])%mo;
          f[i&1][1][p][0]=(f[i&1][1][p][0]+f[(i-1)&1][m][p][0])%mo;
        }
      }
    }
    for(ll j=2;j<=m;j++) {
      for(ll p=0;p<tmp;p++) {
        ll tmp1=Kch_i(p,j),tmp2;
        if(tmp1==0) {
          if(a[i][j]) {
            tmp2=Kass_i(p,j,1);
            f[i&1][j][tmp2][0]=(f[i&1][j][tmp2][0]+f[i&1][j-1][p][0])%mo;
            tmp2=Kass_i(p,j,2);
            f[i&1][j][tmp2][0]=(f[i&1][j][tmp2][0]+f[i&1][j-1][p][1])%mo;
            f[i&1][j][tmp2][2]=(f[i&1][j][tmp2][2]+f[i&1][j-1][p][0])%mo;
            f[i&1][j][p][0]=(f[i&1][j][p][0]+f[i&1][j-1][p][2])%mo;
            f[i&1][j][p][1]=(f[i&1][j][p][1]
            +f[i&1][j-1][p][1]+f[i&1][j-1][p][0])%mo;
            f[i&1][j][p][2]=(f[i&1][j][p][2]+f[i&1][j-1][p][2])%mo;
          }
          else {
            f[i&1][j][p][0]=(f[i&1][j][p][0]+f[i&1][j-1][p][0])%mo;
          }
        }
        if(tmp1==1) {
          if(a[i][j]) {
            tmp2=Kass_i(p,j,0);
            f[i&1][j][tmp2][0]=(f[i&1][j][tmp2][0]+f[i&1][j-1][p][1])%mo;
            f[i&1][j][tmp2][2]=(f[i&1][j][tmp2][2]+f[i&1][j-1][p][0])%mo;
            f[i&1][j][p][0]=(f[i&1][j][p][0]+f[i&1][j-1][p][0])%mo;
          }
        }
        if(tmp1==2) {
          if(a[i][j]) {
            tmp2=Kass_i(p,j,0);
            f[i&1][j][tmp2][0]=(f[i&1][j][tmp2][0]+f[i&1][j-1][p][0])%mo;
            f[i&1][j][p][0]=(f[i&1][j][p][0]+f[i&1][j-1][p][0])%mo;
          }
        }
      }
    }
    for(ll j=1;j<=m;j++) {
      for(ll p=0;p<tmp;p++) {
        f[(i-1)&1][j][p][0]=f[(i-1)&1][j][p][1]=f[(i-1)&1][j][p][2]=0;
      }
    }
  }

  write(f[n&1][m][0][0]);

  return 0;
}
```

---

## 作者：MSqwq (赞：0)

### 题外话
超喜欢 $lxhgww$ 啊啊啊啊啊啊
### 题解
一道变异了的插头dp题  
~~我终于可以告别插头dp啦233333……此人已疯~~  
这道题的难点在于将插头dp的插头的定义进行修改。
$0$：无插头  
$1$：有插头且当前格子所在的地板能再转弯。  
$2$：有插头且当前格子所在的地板不能再转弯。  
有了这些就可以按照插头dp的思想进行分情况讨论了：  
```
1.00-->22 或 10 或 01
2.11-->00
3.10-->20 或 01
   20-->00 或 02
4.01-->10 或 02
   02-->00 或 20
```
最终把所有情况枚举累加即可。  
PS：第二种情况的 $11$ 转换成了 $00$ 实质上是 $11$ 相交的地方变成了这块地板的转折点（也可以理解为两块地板并在了一起）
代码也就很傻逼了：  
```
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
using namespace std;
const int N=60010,P=20110520;
int n,m;
char a[110][110],b[110][110];
int f[2][15][3][60010];
int pw[110];
inline void turn()
{
  swap(n,m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)b[i][j]=a[j][i];
  memcpy(a,b,sizeof(b));
}
void add(int &x,int y){if((x+=y)>=P) x-=P;}
int cg(int s,int p,int t){return((s/pw[p])*3+t)*pw[p-1]+s%pw[p-1];}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
    scanf("%s",a[i]+1);
	if(n<m)turn();
	pw[0]=1;
	for(int i=1;i<=m;i++)pw[i]=pw[i-1]*3;
	int st=0; 
	f[st][0][0][0]=1;
	for(int i=1;i<=n;i++,st^=1)
	{
		for(int j=0;j<pw[m];j++)add(f[st][0][0][j],f[st^1][m][0][j]);
    	memset(f[st^1],0,sizeof(f[st^1]));
    	for(int j=0;j<m;j++)
    	{
	    	for(int S=0;S<pw[m];S++)
	    	{
		   	 	for(int t=0;t<3;t++)
				{
			    	int s=(S/pw[j])%3,cur=f[st][j][t][S];
			    	if(cur==0)continue;
			    	int(*nxt)[N]=f[st][j+1];
			    	if(a[i][j+1]=='*')
					{
			    		if(s!=0||t!=0)continue;
			    		add(nxt[0][cg(S,j+1,0)],cur);
			    	}
			    	else
					{
				        if(s==0&&t==0)add(nxt[0][cg(S,j+1,1)],cur),add(nxt[1][cg(S,j+1,0)],cur),add(nxt[2][cg(S,j+1,2)],cur);
				        if(t==1&&s==0)add(nxt[1][cg(S,j+1,0)],cur),add(nxt[0][cg(S,j+1,2)],cur);
				        if(t==2&&s==0)add(nxt[2][cg(S,j+1,0)],cur),add(nxt[0][cg(S,j+1,0)],cur);
				        if(s==1&&t==0)add(nxt[0][cg(S,j+1,1)],cur),add(nxt[2][cg(S,j+1,0)],cur);
				        if(s==2&&t==0)add(nxt[0][cg(S,j+1,2)],cur),add(nxt[0][cg(S,j+1,0)],cur);
				        if(s==1&&t==1)add(nxt[0][cg(S,j+1,0)],cur);
					}	    		
			}

			}    		
		}

	}
	printf("%d",f[st^1][m][0][0]);
}
```


---

## 作者：封禁用户 (赞：0)

我们先分析题意，不难发现，这是一道插头 DP 题。

首先，我们定义这道题中的一个插头代表着从这个格子往插头指向的方向可以伸展一个 L 形。

但是整张图上的所有插头不可能只有一种，因此我们要分析，可以继续延伸的 L 形都有哪些限制呢？

我们知道，L 形的一个特点就是拐了一个弯，而且只拐了一个弯，因此我们可以定义这样的两种插头：

插头 $1$ 代表一个还没有拐过弯的 L 形的延伸，插头 $2$ 则代表一个已经拐过弯的 L 形的延伸。

这样我们解决了定义问题，接下来分类讨论，经分析，大致分为 $6$ 种。

1. 当前状态下，当前格子上方和左方都没有插头。
2. 当前状态下，当前格子上方有一个一号下插头，左方没有插头。
3. 当前状态下，当前格子左方有一个一号右插头，上方没有插头。
4. 当前状态下，当前格子上方有一个二号下插头，左方没有插头.
5. 当前状态下，当前格子左方有一个二号右插头，上方没有插头。
6. 当前状态下，当前格子左方和上方都有一号插头。

我们再观察这六种情况，情况一和情况六已经覆盖了四种 L 形的摆放方式，同时也不会有一个二号插头一个一号插头或者两个二号插头的情况出现——它们被上文的六种情况限制了。所以这种分类讨论方式可以覆盖所有情况。最后，我们为了**速度更快**，可以将每一种状态给存入[**哈希表**](https://blog.csdn.net/u011109881/article/details/80379505)，滚动数组处理就行了。

代码太长，在这里就不放了，感谢大家的阅读！

---


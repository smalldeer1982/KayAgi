# 【模板】二分图最大权完美匹配

## 题目背景

> $\rm Love ~of ~my ~life$
>
> $\rm U~are~far~from~me$
> 
> $\rm U've ~ turned ~ me ~ on$
> 
> $\rm and ~ now ~ I ~ try ~ to ~ catch ~ up ~ with ~ you$
>
> $\rm Love ~ of ~ my ~ life ~ can't ~ you ~ see$
>
> $\rm I'll ~ always ~ try, ~ always ~ try$
>
> $\rm U ~ are ~ the ~ brightest ~ star ~ to ~ me$
> 
> $\rm No ~ matter ~ others ~ don't ~ know$
>
> $\rm what ~ it ~ means ~ to ~ me$
>
> ——  An adaptation of _Love of My Life_ by Queen


这是一道夹带私货的模板题。

## 题目描述

给定一张二分图，左右部均有 $n$ 个点，共有 $m$ 条带权边，且保证有完美匹配。

求一种完美匹配的方案，使得最终匹配边的边权之和最大。

## 说明/提示

#### 数据规模与约定
- 对于 $10\%$ 的数据，满足 $n\leq 10$。
- 对于 $30\%$ 的数据，满足 $n\leq 100$。
- 对于 $60\%$ 的数据，满足 $n\leq 500$，且保证数据随机 。
- 对于 $100\%$ 的数据，满足 $1\leq n\leq 500$，$1\leq m\leq n^2$，$-19980731\leq h \leq 19980731$ 。且保证没有重边。

数据由善于出锅的出题人耗时好久制造完成。

善良的杨村花提醒你，别忘了仔细观察一下边权范围哦~

善良的杨村花又提醒你，你的复杂度可能只是「看起来」很对哦~

## 样例 #1

### 输入

```
5 7
5 1 19980600
4 2 19980587
1 3 19980635
3 4 19980559
2 5 19980626
1 2 -15484297
4 5 -17558732
```

### 输出

```
99903007
5 4 1 3 2 
```

# 题解

## 作者：Singercoder (赞：139)

# 序言

+ km算法的学习过程可谓艰辛，各种奇怪的hack层出不穷，而网络资料给出的debug也不是很全面。特此写下本篇题解供各oier参考。
+ 后记的相关内容总结了km算法在应用时的一些小技巧，和一些有趣的hack及其应对方式。（因为本蒟蒻的确被卡了很多次，求大神轻喷。）
+ 鸣谢：$ltao$。没有他，我不可能见到这些神奇的hack与debug，也无法得到有效且及时的质疑与纠正。

# 算法介绍

+ 算法简介：km算法（Kuhn－Munkres算法），是一种在二分图上求解最大权完美匹配的算法，用邻接矩阵存图即可。相比费用流较高的复杂度，km算法有着更为优秀的效率，但局限性在于只能做匹配，而不像费用流那样灵活可变。

+ 前置知识：匈牙利算法的**bfs**写法（附上[匈牙利和km算法的bfs模板](https://www.luogu.com.cn/blog/SingerCoder/post-tu-lun-er-fen-tu-pi-pei-xiong-ya-li-yu-km-mu-ban)，可供参考，欢迎交流）

+ km算法的核心思路在于：

  + 定义顶标$lx[i],ly[i]$，则对于每一条边，都有性质$lx[u]+ly[v]>=e[u][v]$。
  + 当且仅当$lx[u]+ly[v]=e[u][v]$时，我们称该边为**相等边**。
  + 所有点和所有相等边所组成的子图称为**相等子图**。
  + 核心算法：**贪心地**将増广所需的边中，边权最大的那些边变成相等边，即逐渐扩大相等子图。
  + 核心性质：扩大相等子图至其刚好有完美匹配时，该匹配即为原图的最大权完美匹配（很好理解，因为扩大相等子图的过程是贪心的）

  由此，我们便能将km算法简单地理解为：匈牙利算法+扩大相等子图

+  顶标的设计是km的精髓，这里参考ltao的定义：

  > $lx[i]$左部点的顶标
  >
  > $ly[i]$右部点的顶标
  >
  > $vx[i]$左部点遍历标记
  >
  > $vy[i]$右部点遍历标记
  >
  > $px[i]$左部点匹配
  >
  > $px[i]$右部点匹配
  >
  > $slack[i]$对于指向右部点$i$的所有边，$min(lx[u]+ly[i]-e[u][i])$的值，即松弛量（初始化为inf）
  >
  > PS:当slack[i]=0，表示对于右部点i，相等子图中有一条指向它的边

  而修改顶标的思路可以具体看代码，核心语句如下（copy的是下面bfs正解的过程）：

  ```cpp
  	if(vx[i])lx[i]-=d;//对于vx[i]=0的情况我们根本没有讨论，实际上也并不需要讨论
  	if(vy[i])ly[i]+=d;else slack[i]-=d;
  ```

  这样修改的目的是保证已在相等子图中的边两侧顶标和不变，同时通过左部点顶标的减小实现向相等子图中拉进新相等边的目的。

  如果还不是很理解可以画个图，对于原图中某条边：

  1. $vx[u]=0,vy[v]=0$，则$slack[v]$不变（未遍历到的=>不修改）
  2. $vx[u]=1,vy[v]=1$，则$slack[v]$不变（已遍历到的=>该边为相等边=>修改后依旧为相等边）
  3. $vx[u]=0,vy[v]=1$，则$slack[v]+=d$（未知该边是否为相等边=>若非相等边则依旧非；若为相等边，则会被拉出相等子图，但既然$vy[i]=1$，则本次増广必然不会用到这条边，拉出也无所谓；况且通过u去找非匹配的v也不方便。因此不必而且不便于体现在程序中。而初学者也不必深究，不处理即可）
  4. $vx[u]=1,vy[v]=0$，则$slack[v]-=d$（该边非相等边=>修改后可能为相等边=>可能提供新増广路。很重要，这是扩大相等子图的原理）

  这里提供[ltao's blog](https://www.cnblogs.com/zhltao/p/12549489.html)以加深理解。他充分讨论了修改顶标对所有边产生的影响，还提出了关于序号3的一些非常重要的观点，本篇题解在后记中也会提到。

# 模板分析（[p6577](https://www.luogu.com.cn/problem/P6577)）
首先提示坑点：
1. 边权最小约-1e7，所以如果要添加虚边将图补成完全图，记得初始边权设为$-inf$。（不补全而直接忽视不存在边在本题也可行，依照个人习惯即可）
2. 权值和需要用`long long`​存储。

直接打出匈牙利dfs写法+扩大相等子图的模板，初学者一定要先练熟这个。

```cpp
const int MAXN=510;

int n,m;
int e[MAXN][MAXN];

int lx[MAXN],ly[MAXN],py[MAXN],d;
bool vx[MAXN],vy[MAXN];

bool dfs(int u)
{
	vx[u]=1;
	for(int i=1;i<=n;++i)if(!vy[i])
	{
		if(lx[u]+ly[i]==e[u][i])
		{
			vy[i]=1;
			if(!py[i] || dfs(py[i]))
			{
				py[i]=u;
				vy[i]=1;
				return 1;
			}
		}
		else d=min(d,lx[u]+ly[i]-e[u][i]);
	}
	return 0;
}

int main()
{
	for(int i=1;i<=n;++i)
	{
		while(1)
		{
			memset(vx,0,sizeof(vx));
			memset(vy,0,sizeof(vy));
			d=inf;
			if(dfs(i))break;
			for(int j=1;j<=n;++j)
			{
				if(vx[j])lx[j]-=d;
				if(vy[j])ly[j]+=d;
			}
		}
	}
}
```

~~结果成功tle~~，不得不说卡km+dfs的题目真的不多。

我们简单分析一下复杂度：

+ 每次扩大相等子图最少只能加入一条相等边，也就是最多会进行$n^2$次扩大相等子图。
+ 每次扩大相等子图后都需要进行dfs増广，单次复杂度可达$n^2$。

也就是说，km+dfs的复杂度完全可以卡到$n^4$。

------

考虑如何优化，我们不难发现每次扩大相等子图之后，都要从増广起点重新开始dfs，这个过程是有明显的时间浪费的。

能不能在扩大相等子图之后，保留上次状态呢？

答案是可行的，我们只需要换用bfs写法：**在每次扩大子图后，都记录一下新加入的相等边所为我们提供的新増广方向，然后从此处继续寻找増广路即可**。

扩大相等子图复杂度：

+ 每次扩大相等子图最少只能加入一条相等边，也就是最多会进行$n^2$次扩大相等子图。
+ 每次扩大相等子图复杂度$n$，无需额外増广，从上次起点继续増广即可。

増广复杂度：

+ 每个左部点需要1次増广，共有$n$个左部点。
+ 单次増广复杂度可达$n^2$。

由此可见，通过简单的**状态延续**策略，我们成功将km算法的复杂度降到了$n^3$。

```cpp
const int MAXN=510;

int n,m;
int e[MAXN][MAXN];

int lx[MAXN],ly[MAXN],slack[MAXN];
int px[MAXN],py[MAXN],pre[MAXN];
bool vx[MAXN],vy[MAXN];

queue<int> q;
void aug(int v)
{
	int t;
	while(v)
	{
		t=px[pre[v]];
		px[pre[v]]=v;
		py[v]=pre[v];
		v=t;
	}
}
void bfs(int s)
{
	memset(vx,0,sizeof(vx));
	memset(vy,0,sizeof(vy));
	fill(slack+1,slack+n+1,inf);
	
	while(!q.empty())q.pop();
	q.push(s);
	
	while(1)
	{
		while(!q.empty())
		{
			int u=q.front();q.pop();
			vx[u]=1;
			for(int i=1;i<=n;++i)if(!vy[i])
			{
				if(lx[u]+ly[i]-e[u][i]<slack[i])
				{
					slack[i]=lx[u]+ly[i]-e[u][i];
					pre[i]=u;
					if(slack[i]==0)
					{
						vy[i]=1;
						if(!py[i]){aug(i);return;}
						else q.push(py[i]);
					}
				}
			}
		}
		int d=inf;
		for(int i=1;i<=n;++i)if(!vy[i])d=min(d,slack[i]);
		for(int i=1;i<=n;++i)
		{
			if(vx[i])lx[i]-=d;
			if(vy[i])ly[i]+=d;else slack[i]-=d;
		}
		for(int i=1;i<=n;++i)if(!vy[i])
		{
			if(slack[i]==0)
			{
				vy[i]=1;
				if(!py[i]){aug(i);return;}
				else q.push(py[i]);
			}
		}
	}
}

int main()
{
	for(int i=1;i<=n;++i)bfs(i);
}
```

还有一种迭代bfs的写法，是榜一$Wendigo$大神所采用的，可能不像队列写法这么易懂，但码量明显大幅下降。

另外$Wendigo$还提到迭代写法可以卡到$n^4$，但在下不是很理解该怎样构造数据，也不清楚队列写法是否同样可以hack，希望评论区有大神可以解答。

这两篇博客分别使用的是[队列写法](https://www.cnblogs.com/GerynOhenz/p/9458006.html)和[迭代写法](https://blog.csdn.net/c20182030/article/details/73330556)，供参考。

# 后记

$ltao$在他的题解注释中有一个非常隐蔽的伏笔：

> //这个其实是有一点小问题的，但是没啥大问题

~~说的这么玄学谁能明白啊~~

## 1.虚点虚边的添加

因为出题人保证了数据存在完备匹配，所以就算不是完全二分图也可以大胆去跑km。

但有些题目需要特判无解情况，即不存在完美匹配；

还有些题目告诉你，就算非完美匹配也无所谓，为了让权值和最大可以允许某些点无匹配而孤独终生。

这类题目就要求选手对km算法拥有比较清晰的理解，那么请你思考一下，分别应该如何应对？

ok揭晓答案。

首先无论哪种情况，我们都要保证左部点个数小于等于右部点个数，通过为右部点添加**虚点**来实现。

然后，我们要将原本不存在的边连成**虚边**。

对于需要特判无解的题目，我们需要极力避免选择虚边，也就是将虚边边权设为$-inf$，如果被迫选了$-inf$的边就输出无解。

对于允许非完美匹配的题目，我们允许选取虚边，也就是将虚边边权设为0即可。

这样，我们就可以在完全二分图上跑km求解。（当然对于无解，你也可以选择只加一个虚点作为退路，跑一般二分图的km，如果该虚点被匹配则必然无解）

不过这只是一种个人比较喜欢的通用策略，对于特判无解的那种题目，还有一种常见策略：

即当$d$很大时，说明某个$slack[i]$很大，无法扩大子图，也就是无解。但为什么这个很大不是$inf$呢？原因在于我们bfs写法为了加速就必须修改顶标同时修改$slack[]$，可能会改变$slack[]=inf$的值，非常不方便判无解。

还有人会说用dfs时如果无解，能保证$d=inf$。但这种写法慢是一方面，另一方面就是我将要提到的死循环hack。

## 2.可能的死循环hack

dfs写法直接判$d=inf$无解，是有死循环风险的。

这个简单的小hack能坑到很多初学者（包括我），下面详细说一下。

借用ltao的话来说：一共有最多$n^2$条边，却只有$2n$的顶标，这就好像要用$2n$个元来满足$n^2$个方程成立，很明显是存在方程组无解的可能性的！

而体现在原图中便是**不是所有边都能成为相等边**，而**相等子图可能如何设置顶标也无法等于原图**！

而体现在算法中，就是总有一些边，我们无论如何也拉不进来，或者拉进一些边的同时拉出一些边。（将相等边拉出相等子图的原理，就是上文提到的$vx[u]=0,vy[v]=1$所导致的结果）

这就会导致这样一种可能的后果：由于dfs的鼠目寸光，我们会先从u遍历到某条非相等边<u,v>，并记录下$d=lx[u]+ly[v]-e[u][v]$；然后在后续的遍历过程中，我们通过其他路径遍历到了v点。 此时，$vx[u]=vy[v]=1$，可$0<d<inf$，我们一方面拉不进这条边，另一方面判不出来无解，只能陷入死循环。（[hdu2426的discuss](http://acm.hdu.edu.cn/discuss/problem/post/reply.php?postid=39470&messageid=1&deep=0)中就有大神造出了这样hack）

那为什么bfs写法就能防止死循环？

因为bfs写法不是在遍历过程中直接记录$d$，而是走遍所有能遍历的点后，用$slack[]$来计算$d$。而且bfs写法判无解通常用虚点虚边，也就能避免死循环情况出现。

---

upd:对hdu2426的hack原理没看太明白的，可以去看看[ltao](https://www.luogu.com.cn/blog/lov-kyn/solution-p6577)的题解，有我依此做的一个配图样例。（~~我就不在这里贴出来了~~）

---

## 作者：Rainy7 (赞：75)

- **前言**

  哇终于有这题模板了！！
  
  ~~然后我太开心了可能，又是忘改空间，又是忘开longlong，开完longlong又是忘改改inf，改了inf又忘记初始化要改，改了初始化又顺手把n打成了m....~~
  
  ~~我以前一直把[P3967 [TJOI2014]匹配](https://www.luogu.com.cn/problem/P3967)当成模板做。~~
  
  作者还特别良心的卡掉了假的 $O(n^3)$ ！！
  
  **以下部分改变自[我自己的「二分图」学习笔记](https://www.luogu.com.cn/blog/Rainy7/post-er-fen-tu-xue-xi-bi-ji)。**

------------

- **KM算法**
  
  给定一个二分图，两边的点数都为 $n$ ，给出若干条边，每条边有一个权值，求最大的完美匹配的值。
  
  KM针对的是**带权的完美匹配**，就是说二分图两边的数量必须相等，即最大匹配数为 $n$ 。
  
  其实KM的复杂度和边没太多关系，所以**如果两点没有连边的话，可以假设这两点的边的权值为 $0$ 。**
  
  首先，每个点有一个**顶标**，就是有一个值。
  
  假设点 $u$ 的顶标为 $l(u)$ 。
  
  对于任意一条边 $(u,v)$ ，**必须满足 $l(u)+l(v) \ge w(u,v)$ ,其中$w$表示边权**。
  
  **当一条边满足 $l(u)+l(v)=w(u,v)$ 时，就可以把这条边加入二分图中。**
  
  如果该图可以**跑出完美匹配**，那么此时的完美匹配的边权值和的即为结果。
  
  ~~似乎很简单的样子，~~ 那么怎么确定顶标的值呢。
  
  因为不能直接确定，那算法流程大概是这样子：确认顶标的值->跑匹配->如果匹配数为 $n$ ,结束；否则->修改顶标->跑匹配.....
  
  那初始的时候顶标该如何确定呢？
  
  假设二分图左边的顶标为 $ex(i)$ ，右边的顶标为 $ey(i)$ 。
  
  因为要满足 $ex(x)+ey(y) \ge w(x,y)$，那我们不妨直接**设 $ex(i)$ 全部为 $0$，$ey(i)$ 为所连边的最大值**。
  
  调整顶标过程中，其实目的就是要不断的加入新的边，也就是使更多的边满足 $ex(i)+ey(j)=w(i,j)$ 。
  
  那么接下来找一条边 $(i,j)$ ，使其**满足 $i$ 不在二分图最大匹配中，而 $j$ 在二分图最大匹配中**。
  
  我们希望这条边加入二分图匹配，就要使这条边满足条件，即**顶标和要减少 $d=ex(i)+ey(j)-w(i,j)$ 。**
  
  因为此时点 $j$ 在二分图最大匹配中，如果改变顶标肯定会影响其他边，所以干脆草率一点，**对于在二分图最大匹配中的任意点 $i$ ,将 $ex(i)+d$ 或 $ey(i)-d$ 。**
  
  为了防止修改完导致部分顶标不满足 $ex(x)+ey(y) \ge w(x,y)$ ，我们每次找的 $d$ 要尽量小。
  
  ok，解决了，算一下复杂度。
  
  每次找边复杂度为 $O(n^2)$ ，二分图最大匹配的复杂度为 $O(n^2)$ ，也就是说总复杂度为 $O(n^4)$ 。
  
  ~~有一说一，这是真的慢。~~
  
  考虑优化，至少优化到 $O(n^3)$ 啊！！
  
  每次找一遍 $d$ 太慢了，所以我们开个数组：
  
  $$slack[j]= \min (ex(i)+ey(j)-w(i,j))$$
  
  每次查询的时候就降了一维，$slack$ 修改只要在**跑增广路的时候修改**就好了。
  
  代码：
  ```cpp
  #include<iostream>
  #include<cstdio>
  #include<cmath>
  #include<cstring>
  using namespace std;
  typedef long long ll;
  const ll Maxn=505;
  const ll inf=1e18;
  ll n,m,map[Maxn][Maxn],matched[Maxn];
  ll slack[Maxn],ex[Maxn],ey[Maxn];//ex,ey顶标
  bool visx[Maxn],visy[Maxn];
  bool match(ll x)
  {	
      visy[x]=1;
      for(ll i=1;i<=n;i++)
      {	
          if(visx[i])continue;
          ll gap=ex[i]+ey[x]-map[x][i];
          if(gap==0)
          {	
              visx[i]=1;
              if(!matched[i]||match(matched[i]))
              {	
                  matched[i]=x;
                  return 1;
              }
          }
          else slack[i]=min(slack[i],gap);
      }
      return 0;
  }
  ll KM()
  {	
      memset(matched,0,sizeof(matched));
      memset(ex,0,sizeof(ex));
      for(ll i=1;i<=n;i++)
      {	
          ey[i]=map[i][1];
          for(ll j=2;j<=n;j++)
              ey[i]=max(ey[i],map[i][j]);

      }
      for(ll i=1;i<=n;i++)
      {	
          for(ll j=1;j<=n;j++)slack[j]=inf;
          while(1)
          {	
              memset(visx,0,sizeof(visx));
              memset(visy,0,sizeof(visy));
              if(match(i))break;
              ll d=inf;
              for(ll j=1;j<=n;j++)
                  if(!visx[j])d=min(d,slack[j]);
              for(ll j=1;j<=n;j++)
              {	
                  if(visy[j])ey[j]-=d;
                  if(visx[j])ex[j]+=d;
                  else slack[j]-=d;
              }
          }
      }
      ll res=0;
      for(ll i=1;i<=n;i++)
          res+=map[matched[i]][i];
      return res;
  }
  int main()
  {	
      scanf("%lld%lld",&n,&m);
      for(ll i=1;i<=n;i++)
          for(ll j=1;j<=n;j++)
              map[i][j]=-inf;
      for(ll i=1;i<=m;i++)
      {	
          ll u,v,w;
          scanf("%lld%lld%lld",&u,&v,&w);
          map[u][v]=w;
      }
      printf("%lld\n",KM());
      for(ll i=1;i<=n;i++)
          printf("%lld ",matched[i]);
      printf("\n");
      return 0;
  }
  ```
  
  然后就会发现，哎不对啊这个 $O(n^3)$ 是假的啊。
  
  ~~只要数据够duliu，~~ 匹配的部分跑到 $O(n^2)$ ，那么复杂度依然没有降到 $O(n^3)$ 。
  
  所以这份代码只有 $50$ 分。
  
  接下来就会发现，因为我们每次**只修改一条边**，也就是说**dfs跑匹配**的时候，有一部分和之前**是一样的**。
  
  所以我们**把dfs改成bfs**，就可以实现真正的 $O(n^3)$ 。
  
  ```cpp
  #include<iostream>
  #include<cstdio>
  #include<cmath>
  #include<cstring>
  using namespace std;
  typedef long long ll;
  const ll Maxn=505;
  const ll inf=1e18;
  ll n,m,map[Maxn][Maxn],matched[Maxn];
  ll slack[Maxn],pre[Maxn],ex[Maxn],ey[Maxn];//ex,ey顶标
  bool visx[Maxn],visy[Maxn];
  void match(ll u)
  {	
      ll x,y=0,yy=0,delta;
      memset(pre,0,sizeof(pre));
      for(ll i=1;i<=n;i++)slack[i]=inf;
      matched[y]=u;
      while(1)
      {	
          x=matched[y];delta=inf;visy[y]=1;
          for(ll i=1;i<=n;i++)
          {	
              if(visy[i])continue;
              if(slack[i]>ex[x]+ey[i]-map[x][i])
              {	
                  slack[i]=ex[x]+ey[i]-map[x][i];
                  pre[i]=y;
              }
              if(slack[i]<delta){delta=slack[i];yy=i;}
          }
          for(ll i=0;i<=n;i++)
          {	
              if(visy[i])ex[matched[i]]-=delta,ey[i]+=delta;
              else slack[i]-=delta;
          }
          y=yy;
          if(matched[y]==-1)break;
      }
      while(y){matched[y]=matched[pre[y]];y=pre[y];}
  }
  ll KM()
  {	
      memset(matched,-1,sizeof(matched));
      memset(ex,0,sizeof(ex));
      memset(ey,0,sizeof(ey));
      for(ll i=1;i<=n;i++)
      {	
          memset(visy,0,sizeof(visy));
          match(i);
      }
      ll res=0;
      for(ll i=1;i<=n;i++)
          if(matched[i]!=-1)res+=map[matched[i]][i];
      return res;
  }
  int main()
  {	
      scanf("%lld%lld",&n,&m);
      for(int i=1;i<=n;i++)
          for(int j=1;j<=n;j++)
              map[i][j]=-inf;
      for(ll i=1;i<=m;i++)
      {	
          ll u,v,w;
          scanf("%lld%lld%lld",&u,&v,&w);
          map[u][v]=w;
      }
      printf("%lld\n",KM());
      for(ll i=1;i<=n;i++)
          printf("%lld ",matched[i]);
      printf("\n");
      return 0;
  }
  ```
  

------------

$$\text{by Rainy7}$$

---

## 作者：ix35 (赞：68)

之前写的有锅，现在修正并整理，重发一下。

## 二分图最大权匹配

对于给定二分图 $G=(V,E)$，每条边有一个权值 $w_i$，我们想要找出一组匹配，使得其中包含的所有边权值和最大，称为**二分图最大权匹配。**

注意，如果给定的 $E$ 不包含所有可能的边，那么最大权匹配**不一定**是最大匹配。

为了求解这个问题，让我们再次借助线性规划工具：

$$\max \sum\limits_{i=1}^m w_ix_i$$

$$s.t. \begin{cases}
\sum\limits_{i=1}^mw(j,i)x_i\leq 1 \\ x_i\ge 0
\end{cases}$$

其中 $w(j,i)$ 表示边 $i$ 是否以点 $j$ 为端点，其实这个问题就是在最大匹配的基础上加上了每条边的权值 $w_i$。

仍旧将它对偶，得到：

$$\min\sum\limits_{j=1}^n y_j $$

$$s.t. \begin{cases}
\sum\limits_{j=1}^n w(j,i)y_j\ge w_i \\ y_j\ge 0
\end{cases}$$

我们将对偶问题中的变量 $y_j$ 称为顶点 $j$ 的**顶标**，那么问题转化成了：

**最小顶标和问题：给定二分图，给每个点一个顶标，使得每条边两端点的顶标和不小于边权，且所有点顶标和最小。**

不过，再次我们需要做一些补充：

- 在上面的线性规划证明中，我们要求 $w_i\ge 0$，即边权非负。
- 但是，如果存在 $w_i<0$，那么应该不能直接套用上面的方法证明（顶标有可能是负数，不满足线性规划的条件），我们稍后叙述算法时也将证明：存在 $w_i<0$ 时，下面的算法也能够通过最小顶标和问题解出一种最大权的完美匹配。

接下来我们将介绍 KM 算法，KM 算法通过解决最小顶标和问题，可以求出给定二分图的一组权值和最大的**完美匹配**。

在叙述算法过程前，先说说怎么将原先的问题（最大权匹配）转化成最大权完美匹配：

- 如果要求 $w_i\ge 0$ 的最大权匹配，那么我们只需要将所有不存在的边视为边权为 $0$ 的边，如果左右两部点数不相等则补为相等，就转化成了最大权完美匹配问题；
- 如果要求存在 $w_i<0$ 的最大权完美匹配（当然也可以是权值都非负的），就将不存在的边权值设为 $-\infty$；
- 如果要求存在 $w_i<0$ 的最大权匹配，那么当然是把所有负权边删掉，变成非负情况。

我们将左部点 $i$ 的顶标称为 $A_i$，右部点 $j$ 的顶标称为 $B_j$，我们要求 $A_i+B_j\ge d(i,j)$，其中 $d(i,j)$ 为 $i,j$ 之间的边权（按照上面的方法补全为完全二分图）。

**相等子图**定义为所有满足 $A_i+B_j=d(i,j)$ 的边构成的子图。

**命题：相等子图中若存在完美匹配，则这组完美匹配是原图的一个最大权完美匹配。**

证明：考虑这组完美匹配的边权和，根据相等子图定义应当是 $\sum A_i+\sum B_j$，而对于原图中任意的一组完美匹配，由于 $d(i,j)\leq A_i+B_j$，所以边权和不超过 $\sum A_i+\sum B_j$，所以这组完美匹配是最大的。

接下来考虑：如果相等子图中没有完美匹配，尝试通过调整顶标使得相等子图中的最大匹配变大，从而最终形成完美匹配。

假设此时左侧有点 $x$ 在相等子图的最大匹配中为非匹配点，从 $x$ 开始尝试在相等子图中寻找增广路（由于是最大匹配了所以必然无法找到），然后我们将访问到的左部点顶标减小 $\Delta$，右部点顶标增大 $\Delta$，考虑这样做的影响：

- 对于匹配边，两边必然都访问到或都不访问到，因此 $A_i+B_j$ 不变，仍然属于相等子图；
- 对于某个以访问到的左部点为一端的非匹配边，由于 $A_i$ 减小，有可能被新加入相等子图中。

所以这么做不会影响原先匹配，但可以增加新的边进入相等子图，从而继续增广，而我们只要取 $\Delta$ 为所有以左部的被访问到的点为一端的边 $(i,j)$ 中最小的 $A_i+B_j-d(i,j)$ 即可，这样至少加进了一条边（但 $\Delta$ 不能大于这个值，否则不符合顶标的要求）。

于是我们首先任意设定初始合法顶标（如右部点都为 $0$，左部点都为相连边权最大值），每次加入一个左部点，按照上面要求尝试在相等子图中增广，如果成功则直接增大匹配，否则按照上述过程进行顶标调整，直接实现这一算法就得到了基于 DFS 的 KM 算法，复杂度较高。

考虑优化这一算法，我们下面介绍一种 **slack 优化的基于 BFS 的 KM 算法**。

- 在每次加入一个左部点，尝试增广时，模拟匈牙利算法求增广路的过程，而对于右部每个点 $y$，记录 $slack_y$ 表示这一轮已经访问的左侧点 $x$ 中，$A_x+B_y-d(x,y)$ 的最小值。

- 当我们访问到一个左部点时，先用它更新所有右部点的 $slack$ 值，接下来我们取出右部 $slack$ 最小的一个点，将其值设为 $\Delta$，然后将当前已经访问的左部点顶标减小 $\Delta$，当前已访问的右部点顶标增加 $\Delta$，并更新 $slack$ 数组（实际上就是每个点的 $slack$ 也需要减小 $\Delta$）。

- 下一个访问的左部点将是刚才取出的右部点的匹配点，这就是一个寻找增广路的过程，而当那个右部点是非匹配点时，我们已经找到了一条增广路。
- 重复上述过程，依次加入所有左部点，最后就求出了最小顶标和问题的解，也就是最大权完美匹配的方案。

---

```cpp
void bfs (int x) {
	memset(vis,0,sizeof(vis));
	memset(s,0x3f,sizeof(s));
	memset(pre,0,sizeof(pre));
	cur=pn=0,mat[0]=x;
	while (1) {
		x=mat[cur];
		ll dis=INF;
		vis[cur]=1;
		for (int i=n+1;i<=n+n;i++) {
			if (vis[i]) {continue;}
			ll tmp=w[i]+w[x]-d[x][i-n];
			if (tmp<s[i]) {s[i]=tmp,pre[i]=cur;}
			if (s[i]<dis) {dis=s[i],pn=i;}
		}
		w[mat[0]]-=dis,w[0]+=dis;
		for (int i=n+1;i<=n+n;i++) {
			if (vis[i]) {w[i]+=dis,w[mat[i]]-=dis;}
			else {s[i]-=dis;}
		}
		cur=pn;
		if (!mat[cur]) {break;}
	}
	while (cur) {
		mat[cur]=mat[pre[cur]];
		cur=pre[cur];
	}
	return;
}
```


---

## 作者：George1123 (赞：58)

## KM 算法

[$\Huge\color{#f0e046}\tt My~Cnblogs$](https://www.cnblogs.com/Wendigo/p/12983311.html)

可能需要先去学学匈牙利算法等二分图相关知识。

---
> [模板题-洛谷P6577 【模板】二分图最大权完美匹配](https://www.luogu.com.cn/problem/P6577)

> 给 $n$ 和 $m$ 与边 $u_i,v_i,w_i(1\le i\le m)$。有一个二分图，两边各 $n$ 个点，共 $m$ 条边，保证有完美匹配，求完美匹配最大边权之和。

> 数据范围：$1\le n\le 500$，$1\le m\le \frac{n\times (n-1)}{2}$，$-19980731\le w_i \le 19980731$，无重边。

---
卡网络流以及一切复杂度 $> \Theta(n^3)$ 的算法，卡不掉怪良心出题人。

---
- **奇奇怪怪的定义**

**顶标**：两边点都有的标记（左 $a_i$ 右 $b_j$）满足 $a_i+b_j\ge w_{i,j}$，不唯一。

**相等边**：$a_i+b_j=w_{i,j}$ 的边 $(i,j)$。

**相等子图**：相等边构成的子图。

**交错树**：增广路径形成的树。

> $\tt KM$ 算法的结论：$\color{#f00}{\texttt{当每个相等子图完备匹配时，二分图得到最大匹配。}}$

因为显然，因为这个时候不可能有比它更优的匹配。

---
- **奇奇怪怪的算法**

很明显，**并不是所有** 的顶标分配方案都能使“每个相等子图完备匹配”的。

但是，**找到一个可行的** 顶标分配方案是很简单的，所以可以找到一种顶标分配然后找增广路的同时调整。

然后在发现相等子图的完备匹配后就匹配。

**具体流程：**

$(1)$ 分配可行顶标，并对每个节点执行 $(2),(3),(4)$。

$(2)$ **匈牙利算法**找增广。

$(3)$ 找不到增广路（相等子图匹配）就调整顶标。

$(4)$ 重复 $(2),(3)$ 直到找到增广路。

---
- **代码**

分析一下代码可知**实际时间复杂度** $\Theta(n^4)$。

```cpp
//Data
const ll N=500;
ll n,m,e[N+7][N+7];

//KM
ll mat[N+7],d[N+7],va[N+7],vb[N+7],ak[N+7],bk[N+7];
ll Dfs(ll u){
	va[u]=1;
	for(ll v=1;v<=n;v++)if(!vb[v]){
		if(ak[u]+bk[v]-e[u][v]==0){
			vb[v]=1;
			if(!mat[v]||Dfs(mat[v])) return mat[v]=u,1;
		} else d[v]=min(d[v],ak[u]+bk[v]-e[u][v]);
	}
	return 0;
} 
ll KM(){
	fill(ak+1,ak+n+1,-INF);
	for(ll u=1;u<=n;u++)
		for(ll v=1;v<=n;v++) ak[u]=max(ak[u],e[u][v]);
	for(ll u=1;u<=n;u++){
		while(true){
			fill(va+1,va+n+1,0);
			fill(vb+1,vb+n+1,0);
			fill(d+1,d+n+1,INF);
			if(Dfs(u)) break;
			ll c=INF;
			for(ll v=1;v<=n;v++)if(!vb[v]) c=min(c,d[v]);
			for(ll v=1;v<=n;v++)if(va[v]) ak[v]-=c;
			for(ll v=1;v<=n;v++)if(vb[v]) bk[v]+=c;			
		}
	}
	ll res=0;
	for(ll v=1;v<=n;v++) res+=e[mat[v]][v];	
	return res;
}

//Main
int main(){
	scanf("%lld%lld",&n,&m);
	for(ll u=1;u<=n;u++)
		for(ll v=1;v<=n;v++) e[u][v]=-INF; 
	for(ll i=1;i<=m;i++){
		ll u,v,w;
		scanf("%lld%lld%lld",&u,&v,&w);
		e[u][v]=max(e[u][v],w);
	}
	printf("%lld\n",KM());
	for(ll u=1;u<=n;u++) printf("%lld ",mat[u]);puts("");
	return 0;
}
```
---
这时候可以得 $50$ 分，剩余的 $\tt TLE$。

> **废话**：不得不佩服出题人！大部分人的 $\tt KM$ 算法都是上面这么写的，要知道还有 $\Theta(n^3)$ 的 $\tt KM$，得找遍全网吧！我找了一个下午终于找到了，希望写了这篇文章后，大家就不需要像我这么累了！

---
- **奇奇怪怪的优化**

就是把 $\tt Dfs$ 换成 $\tt Bfs$。本质和上面代码是一样的。

每个左边的点只会进队、搜索一次。$\tt p$ 数组记录的是增广交错树。

这个 $\tt Bfs$ 是迭代写的，所以不需要 $\tt queue$。

---
- **代码**

随机数据下是 $\Theta(n^3)$，听说可以卡成 $\Theta(n^4)$。但是这样卡貌似没意义。

```cpp
//Data
const int N=500;
int n,m,e[N+7][N+7];

//KM
int mb[N+7],vb[N+7],ka[N+7],kb[N+7],p[N+7],c[N+7];
int qf,qb,q[N+7];
void Bfs(int u){
    int a,v=0,vl=0,d;
    for(int i=1;i<=n;i++) p[i]=0,c[i]=inf;
    mb[v]=u;
    do {
        a=mb[v],d=inf,vb[v]=1;
        for(int b=1;b<=n;b++)if(!vb[b]){
            if(c[b]>ka[a]+kb[b]-e[a][b])
                c[b]=ka[a]+kb[b]-e[a][b],p[b]=v;
            if(c[b]<d) d=c[b],vl=b;
        }
        for(int b=0;b<=n;b++)
            if(vb[b]) ka[mb[b]]-=d,kb[b]+=d;
            else c[b]-=d;
        v=vl;
    } while(mb[v]);
    while(v) mb[v]=mb[p[v]],v=p[v];
}
ll KM(){
    for(int i=1;i<=n;i++) mb[i]=ka[i]=kb[i]=0;
    for(int a=1;a<=n;a++){
    	for(int b=1;b<=n;b++) vb[b]=0;
		Bfs(a);
	}
	ll res=0;
	for(int b=1;b<=n;b++) res+=e[mb[b]][b];
	return res;
}

//Main
int main(){
	n=ri,m=ri;
	for(int a=1;a<=n;a++)
		for(int b=1;b<=n;b++) e[a][b]=-inf;
	for(int i=1;i<=m;i++){
		int u=ri,v=ri,w=ri;
		e[u][v]=max(e[u][v],w);
	}
	printf("%lld\n",KM());
	for(int u=1;u<=n;u++) printf("%d ",mb[u]);puts("");
	return 0;
}
```
---
是不是看起来特别玄学？$\tt KM$ 这种偏僻又难懂的算法，或许还是背板子好。

对了，然后就能 $\tt AC$ 了。

---
**祝大家学习愉快！**

---

## 作者：Yanami_Anna (赞：52)

upd on 2023.10.27：感谢[提醒](https://www.luogu.com.cn/discuss/690711)，现在代码已能够顺利通过。

upd on 2024.1.8：增加网络单纯形费用流，同时修改了 EK 费用流的卡常技巧 4 中的错误。

KM？狗都不学。

卡我费用流？卡啊！怎么不卡了？？？？

首先这种最大权完美匹配的题，首先是完美匹配然后再是最大权，我们伟大的费用流正好可以解决这一类的问题，你只需要源点向左部点连 $(1,0)$ 的边，左部点向右部点连 $(1,-w)$ 的边，右部点向汇点连 $(1,0)$ 的边然后跑最小费用最大流就可以轻松解决这个问题了。

可惜总有不知好歹的模板题喜欢逆时代的潮流出能够卡掉我们伟大费用流的弱智数据范围，我们身为正义的化身，网络流算法的传教士，当然要制止这种恶心所有人的行为，在费用流的铁拳之下没有什么算法还能够优化！！！！

这里隆重请出我们费用流卡常一哥，原始对偶算法！！！！！！！

他的原理是这样的，如果你写过约翰逊全源最短路应该比较清楚，我们面对弱智负边权是怎么粉碎负边权的阴谋的，没错，我们给每个点赋了一个势能 $h$，这个势能约翰逊是直接设成单源最短路的路径长度的，然后把有向边 $(u,v,w)$ 的边权变成 $w+h_u-h_v$，根据三角不等式可以证明出这样操作后所有边权非负并且两点间的最短路的变化只和两个点的势能有关，那我们这样子跑一个迪杰斯特拉就整个能把最短路直接算出来了。

我们平时费用流写的都是 EK，然后把里面的 bfs 换成贝尔曼福德找一下最短的增广路，这样一次增广的时间复杂度是最坏 $O(nm)$ 的，这个时间复杂度非常废物，我们怎么能屈服于负数边权的淫威之下，看我们首先跑一遍贝尔曼福德，然后直接赋值势能更换边权，残量网络已然是我迪杰斯特拉的天下！！！堆优化只会影响我增广的速度，直接丢掉，我 $O(n^2)$ 的找最短增广路之后时间复杂度就已经是伟大的 $O(n^3)$ 了！

但是费用流有一点不一样，他残量网络时刻在变化，可恶的反边，可惜就算你图再怎么变我伟大的小常数迪杰斯特拉也能在增广之后完成点势能的更新，怎么做呢？

我们增广一次顺手求出了所有点到源点的距离，而点势能的更新？根本不在乎，我们直接给所有势能加一个最短路的长度，然后直接更新边权，这样做就是对的，这世间，还有什么能够阻挡！！！！！还有什么能够阻挡我们的费用流算法！！！！！！！！！

时间复杂度 $O(n^3)$，可能还有一点小常数不过没有人在乎，这就是网络流算法的魅力，KM 算法这种又生硬难写又晦涩难懂的逆时代浪潮的算法迟早被淹没在费用流恐怖的实力之下！！！

下面是一些卡常小技巧。

1. 如果你拥有封装 class 的好习惯，请把他丢掉，因为 class 会比较慢。
2. 如果你拥有链式前向星建图的好习惯，请把他丢掉，直接用 vector 建图，邻接矩阵存流量和费用会更快。
3. 如果你拥有 `#define int long long` 的好习惯，请把他丢掉，因为这个东西巨慢无比。
4. 如果你拥有小值域变量开 int 的好习惯，请把他丢掉，short 运算速度比 int 快。
5. 如果你拥有写 scanf 和 printf 的好习惯，请把他丢掉，写个快读吧。
6. $n^2$ 的 dijkstra 算法需要遍历所有点，实际上这并不需要，有一些标记过的点我们并不在乎，用双向链表优化他。

大概就是上面这样。

```cpp
#include <bits/stdc++.h>
using namespace std;
int read()
{
   int s = 0, w = 1;
   char ch = getchar();
   while (ch < '0' || ch > '9')
   {
      if (ch == '-')
      {
         w = -1;
      }
      ch = getchar();
   }
   while (ch >= '0' && ch <= '9')
   {
      s = s * 10 + ch - '0';
      ch = getchar();
   }
   return s * w;
}

int match[505];
int cnt = 1;
vector<int> ljb[1005];
int cost[1005][1005];
bool flow[1005][1005];
long long anscost;
inline void addedge(int u, int v, int fl, int co)
{
   cnt++;
   flow[u][v] = fl;
   cost[u][v] = co;
   ljb[u].push_back(v);
   return;
}
inline void Add(int u, int v, int fl, int co)
{
   addedge(u, v, fl, co);
   addedge(v, u, 0, -co);
   return;
}
bool in[1005];
long long dis[1005];
int S, T, N;
inline void SPFA()
{
   for (int i = 1; i <= N; i++)
   {
      dis[i] = 1e18;
   }
   dis[S] = 0;
   queue<int> q;
   q.push(S);
   while (!q.empty())
   {
      int t = q.front();
      // printf("%lld\n",t);
      q.pop();
      in[t] = false;
      for (int i = 0; i < ljb[t].size(); ++i)
      {
         int v = ljb[t][i];
         int fl = flow[t][v];
         int co = cost[t][v];
         if (fl && dis[t] + co < dis[v])
         {
            dis[v] = dis[t] + co;
            if (!in[v])
            {
               q.push(v);
               in[v] = true;
            }
         }
      }
   }
   return;
}
int pre[1005];
bool vis[1005];
long long h[1005];
int Pre[1005];
int Nxt[1005];
inline bool dijkstra()
{
   int fvv = N;
   Nxt[0] = 1;
   for (int i = 1; i <= N; ++i)
   {
      vis[i] = false;
      dis[i] = 1e18;
      Pre[i] = i - 1;
      Nxt[i] = i + 1;
   }
   dis[S] = 0;
   while (fvv--)
   {
      int cur = 0;
      for (int i = Nxt[0]; i <= N; i = Nxt[i])
      {
         if (!vis[i])
         {
            if (!cur)
               cur = i;
            else if (dis[i] < dis[cur])
            {
               cur = i;
            }
         }
      }
      vis[cur] = true;
      Nxt[Pre[cur]] = Nxt[cur];
      Pre[Nxt[cur]] = Pre[cur];
      for (int j = 0; j < ljb[cur].size(); ++j)
      {
         int v = ljb[cur][j];
         int fl = flow[cur][v];
         int co = cost[cur][v] + h[cur] - h[v];
         if (fl && dis[cur] + co < dis[v])
         {
            dis[v] = dis[cur] + co;
            pre[v] = cur;
         }
      }
   }
   return dis[T] < 1000000000000000000ll;
}
inline void EK()
{
   SPFA();
   for (int i = 1; i <= N; i++)
   {
      h[i] = dis[i];
   }
   long long cnt = 0;
   while (dijkstra())
   {
      int now = T;
      for (int i = 1; i <= N; i++)
         h[i] += dis[i];
      cnt = 0;
      while (pre[now])
      {
         flow[pre[now]][now] = false;
         flow[now][pre[now]] = true;
         cnt += cost[pre[now]][now];
         now = pre[now];
      }
      anscost += cnt;
   }
   return;
}
int n, m;
signed main()
{
   n = read(), m = read();
   S = 2 * n + 1;
   T = 2 * n + 2;
   N = 2 * n + 2;
   int u, v, w;
   for (int i = 1; i <= m; i++)
   {
      u = read(), v = read(), w = read();
      Add(u, v + n, 1, -w);
   }
   for (int i = 1; i <= n; i++)
   {
      Add(S, i, 1, 0);
      Add(i + n, T, 1, 0);
   }
   EK();
   printf("%lld\n", -anscost);
   for (int i = n + 1; i <= 2 * n; i++)
   {
      for (int j = 0; j < ljb[i].size(); ++j)
      {
         int v = ljb[i][j];
         if (v == T)
            continue;
         if (flow[i][v])
         {
            match[i - n] = v;
            break;
         }
      }
   }
   for (int i = 1; i <= n; i++)
   {
      printf("%d ", match[i]);
   }
   return 0;
}
```

---

这个题如果用 EK 或者 dinic 那就只能卡到这个水平，但是费用流又不是只有这个水平，我们还可以使用网络单纯形来跑费用流。

这个算法可以从 [这里](https://codeforces.com/blog/entry/94190) 和 [这里](https://www.luogu.com.cn/blog/firecode/wang-lao-dan-chun-xing-zhuan-shuo-zui-kuai-fei-yong-liu) 学习，我太菜了感觉讲不明白就不献丑了。

用这个跑这个题然后加个快读就随手最优解了。（截止于 2024.1.8）

甩了第二的 KM 整整 150ms，KM 算法没有未来！

![](https://pic.imgdb.cn/item/659b9c2f871b83018a09170b.jpg)

```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
inline int read()
{
	int d=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9') {if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9') {d=d*10+c-48;c=getchar();}
	return d*f;
}

class SimpleX{
   public:
   const int inf=1e12;
   int head[1005];
   int nxt[502005];
   short from[502005];
   short to[502005];
   short flow[502005];
   int cost[502005];
   int cnt=1;
   void addedge(int u,int v,int fl,int co){
      cnt++;
      to[cnt]=v;
      from[cnt]=u;//
      nxt[cnt]=head[u];
      head[u]=cnt;
      flow[cnt]=fl;
      cost[cnt]=co;
      return;
   }
   void Add(int u,int v,int fl,int co){
      addedge(u,v,fl,co);
      addedge(v,u,0,-co);
      return;
   }

   short fa[1005];
   int fe[1005];
   int tag[1005];
   int pos;
   void gettree(int cur){
      tag[cur]=pos;
      for(int i=head[cur];i;i=nxt[i]){
         int v=to[i];
         if(tag[v]||!flow[i])continue;
         fa[v]=cur;
         fe[v]=i;
         gettree(v);
      }
   }
   int pushflow(int id){
      pos++;
      int u=from[id],v=to[id];
      int lca=u;
      while(lca){
         tag[lca]=pos;
         lca=fa[lca];
      }
      lca=v;
      while(tag[lca]!=pos){
         tag[lca]=pos;
         lca=fa[lca];
      }
      int p=2,minflow=flow[id],del;
      for(int now=u;now^lca;now=fa[now]){
         int eg=fe[now];
         if(flow[eg]<minflow){
            p=0;
            minflow=flow[eg];
            del=now;
         }
      }
      for(int now=v;now^lca;now=fa[now]){//
         int eg=fe[now]^1;
         if(flow[eg]<minflow){
            p=1;
            minflow=flow[eg];
            del=now;
         }
      }
      int C=0;
      for(int now=u;now^lca;now=fa[now]){
         int eg=fe[now];
         flow[eg]-=minflow;
         flow[eg^1]+=minflow;
         C=(C+minflow*cost[eg]);
      }
      for(int now=v;now^lca;now=fa[now]){
         int eg=fe[now]^1;
         flow[eg]-=minflow;
         flow[eg^1]+=minflow;
         C=(C+minflow*cost[eg]);
      }
      flow[id]-=minflow;
      flow[id^1]+=minflow;
      C=(C+minflow*cost[id]);
      if(p==2){
         return C;
      }
      if(p)swap(u,v);
      int Le=id^p,Lu=v;
      while(Lu!=del){
         Le^=1;
         tag[u]=0;
         swap(fe[u],Le);
         int need=fa[u];
         fa[u]=Lu;
         Lu=u;
         u=need;
      }
      return C;
   }
   int dep[1005];
   int getdep(int x){
      if(tag[x]==pos)return dep[x];
      tag[x]=pos;
      return dep[x]=getdep(fa[x])+cost[fe[x]];
   }
   pair<int,int> getflow(int s,int t){
      Add(t,s,inf,-inf);
      pos++;
      gettree(t);
      fa[t]=0;
      pos++;
      tag[t]=pos;
      bool flag=true;
      while(flag){
         flag=false;
         for(int i=2;i<=cnt;i++){
            int u=from[i],v=to[i];
            if(!flow[i])continue;
            if(cost[i]+getdep(u)-getdep(v)<0){
               flag=true;
               pushflow(i);
            }
         }
      }
      long long ansflow=flow[cnt];
      long long anscost=0;
      for(int i=2;i<=cnt;i+=2){
         anscost=anscost+flow[i^1]*cost[i];
      }
      return make_pair(ansflow,anscost+(ansflow*inf));
   }
}G;
int n,m;
int pre[505];
signed main(){
   n=read(),m=read();
   for(int i=1;i<=m;i++){
      int u,v,w;
      u=read(),v=read(),w=read();
      G.Add(u,v+n,1,-w);
   }
   int s=2*n+1,t=2*n+2;
   for(int i=1;i<=n;i++){
      G.Add(s,i,1,0);
      G.Add(i+n,t,1,0);
   }
   printf("%lld\n",-G.getflow(s,t).second);
   for(int i=2;i<=G.cnt;i+=2){
      if(G.flow[i^1]){
         if(G.from[i]==s||G.to[i]==t)continue;
         pre[G.to[i]-n]=G.from[i];
      }
   }
   for(int i=1;i<=n;i++){
      printf("%lld ",pre[i]);
   }
   puts("");
   return 0;
}
```

---

## 作者：zac2010 (赞：13)

## 二分图的最大权完美匹配

不妨先看一些定义：

  * 顶标

    全称为“顶点标记值”。记左部点 $i$ 的顶标为 $lx_i$，右部点 $j$ 的顶标为 $ly_j$，那么要求顶标要满足 $lx_i+ly_j \ge w(i,j)$，其中 $w(i,j)$ 表示 $i$ 到 $j$ 那条边的边权。

  * 相等子图

    即原图中满足 $lx_i+ly_j = w(i,j)$ 的边构成的子图。

    * 结论：若相等子图中存在完美匹配，则这个完美匹配就是二分图的带权最大完美匹配。
    * 证明：完美匹配的边权和为 $(\sum_{i=1}^{n}lx_i)+(\sum_{i=1}^{n}ly_i)$。由于 $\forall i,j$，$lx_i+ly_j \ge w(i,j)$，故而整张二分图中，不存在有其他匹配的边权值和大于当前匹配的边权之和。

我们利用上述结论，成功的把问题转换为了：求一组合适的顶标，使得相等子图存在完美匹配。

  有一种做法就是对于每一个 $i$，调整顶标使得有新边加入以达到能在相等子图里找到增广路、匹配的目的。若每一个 $i$ 都在上一个的基础上执行了这样的操作，便能得到一种完美匹配的方法。

* 不妨宏观匈牙利算法来明确一些性质：每次从未匹配边开始，以未匹配边、匹配边交错的形式形成一颗**交错树**，其中左部节点沿非匹配边访问到右部节点，右部节点沿匹配边找到原来匹配的左部节点。且未找到增广路之前，不会改变已有的匹配。

  假设目前的相等子图里找不到增广路了，我们需要一种调整顶标的方法，使得原图中存在的边现在有，且至少一条原来没有的边新图有了。

* 调整方法：我们还是设左部节点为 $i$，右部节点为 $j$。之后把所有的所有访问到过的 $lx_i$ 加上 $v$、$ly_j$ 减去 $v$。

  进一步转化为如何求一个合适的 $v$，使得满足上述条件。

  因为左部节点的访问是被动的（即被右部节点沿匹配边访问到），且考虑 $i \notin \text{交错树},j \notin \text{交错树}$ 没有意义（$\notin \text{交错树}$ 的顶标都没有变化），所以我们只用考虑 $i \in \text{交错树}$，且只用考虑有连边的 $i,j$。

  分情况来讨论：

  * $j \in \text{交错树}$。

    那么连接两点的这条边显然是匹配边，那么两边一个加 $v$，一个减 $v$，显然 $lx_i+ly_j=w(i,j)$，依旧是新相等子图中的边。

  * $j \notin \text{交错树}$。

    在所有访问过的 $lx$ 加 $v$，$ly$ 减 $v$ 之后满足顶标的性质——$lx_i+ly_j \ge w(i,j)$，当且仅当 $v \le lx_i+ly_j-w(i,j)$。若在所有的 $lx_i+ly_j-w(i,j)$ 中取最小的值作为 $v$ 的值，那么就能达成“既满足顶标的性质，又能至少有一条边加入新相等子图”。

具体的，有以下步骤：

  * 枚举点 $i$

    思想在于不断通过调整顶标加入边以使得 $i$ 能找到匹配。

    故重复以下过程直至 $i$ 找到匹配。

    * 进行寻找增广路同时获得合适的 $v$。
    
   		时间复杂度 $O(n+m)$。
    * 调整顶标。
    
    	时间复杂度 $O(n)$。

时间复杂度 $O(n(n+m))=O(n^2+nm)$。

```cpp
#include <bits/stdc++.h>
#define FL(i, a, b) for(int i = (a); i <= (b); i++)
#define FR(i, a, b) for(int i = (a); i >= (b); i--)
using namespace std;
typedef long long ll;
const int N = 510; const ll INF = 1e17;
int n, m, vis[N], pre[N], match[N];
ll lx[N], ly[N], w[N][N], slack[N];
void aug(int s){
    int p, id = 0, q; ll v; match[0] = s;
    FL(i, 1, n) slack[i] = INF, pre[i] = 0;
    while(match[q]){
        p = match[q = id], vis[q] = 1, v = INF;
        FL(i, 1, n) if(!vis[i]){
            if(slack[i] > lx[p] + ly[i] - w[p][i])
                slack[i] = lx[p] + ly[i] - w[p][i], pre[i] = q;
            if(slack[i] < v) v = slack[id = i];
        }
        FL(i, 0, n){
            if(vis[i]) lx[match[i]] -= v, ly[i] += v;
            else slack[i] -= v;
        }
    }
    for(; q; q = pre[q]) match[q] = match[pre[q]];
}
ll KM(){
    FL(i, 1, n){
        lx[i] = -INF, ly[i] = 0;
        FL(j, 1, n) lx[i] = max(lx[i], w[i][j]);
    }
    FL(i, 1, n) memset(vis, 0, sizeof(vis)), aug(i);
    ll ret = 0; FL(i, 1, n) ret += lx[i] + ly[i];
    return ret;
}
int main(){
    scanf("%d%d", &n, &m);
    FL(i, 1, n) FL(j, 1, n) w[i][j] = -INF; 
    FL(i, 1, m){
        int u, v; ll c;
        scanf("%d%d%lld", &u, &v, &c);
        w[u][v] = max(w[u][v], c);
    }
    printf("%lld\n", KM());
    FL(i, 1, n) printf("%d ", match[i]);
    return 0;
}
```
## 二分图的最大权匹配

注意到这个模型和上述的二分图最大权完美匹配的差别为：它不要求是完美匹配。故而考虑删去所有负权边，再把不存在边的点对之间连上权值为 $0$ 的边。最后跑 $\text{KM}$ 即可。

---

## 作者：GK0328 (赞：11)

[我的博客](https://www.cnblogs.com/GK0328/p/13674314.html)

# KM算法

**KM算法**用来解决**二分图最大权完美匹配**问题，是对**匈牙利算法**算法的改进

具体思路是，假设左边的节点有一个顶标$ex_i$，右边的节点有一个顶标$ey_i$

我们要求顶标对于任意一条边，满足$ex_i+ey_j \ge w_{i,j}$，当$ex_i+ey_j=w_{i,j}$，可以连接边$edge(i,j)$。所以取到二分图完美匹配时，边权之和为$\sum_{i=1}^n ex_i+\sum_{i=1}^n ey_i$

我们需要在满足完美匹配的同时，尽量让顶标和最大

首先我们先寻找顶标和上限（这时候不要求完美匹配），很容易找到可行解

$$

\forall i \in x,ex_i=\max _{edge(i,j)} w_{i,j} 

$$
$$

\forall i \in y,ey_i=0

$$

显然不可能有比这个更优的解

但是不一定存在这样的解，我们先不处理，像原来一样一个一个点寻找增广路，只不过经过一条边$edge(i,j)$的条件多了一个限制$ex_i+ey_j=w_{i,j}$

然后我们发现没有完全匹配怎么办？

定义：$matched_x$为$x$集中已匹配的点，$matched_y$为$y$集中已匹配的点，$not\_matched_y$为$y$集中未匹配的点

我们需要降低顶标和，但是为了求最大权完美匹配，我们必须让顶标减小的值尽可能小，也就是说，我们要找到一个$not\_matched_y$集中的点$j$，满足$\min ex_i+ey_j-w_{i,j}(i \in matched_x)$值最小，然后让这条边也加入可能的边集中，这样可以保证不会漏掉更优答案

显然，我们降低顶标后，原来$matched_y$集中的点仍然可以匹配，同时有更多的点可以被匹配

设顶标减小值为$del$，我们要扩大可匹配边集

$$
\forall i \in match_x,ex_i-=del
$$
$$
\forall i \in match_y,ey_i+=del
$$

首先，$\forall i \in match_x,ex_i-=del$，表明$match_x$降低了标准，可以去匹配差为$ex_i+ey_j-w_{i,j}=del$的较次点了，同时由于$\forall i \in match_y,ey_i+=del$，$match_x$集中点与$match_y$集中点的和不变，仍然可以匹配

如何求$del$呢，暴力求太慢，记$slack_i(i \in not\_matched_y)$为与$i$连边的$del$的最小值，可以在匹配过程中同时处理，具体见代码

$dfs$版$KM$

时间复杂度：$O(n^2 m)$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define N 505
#define M 250005
#define INF 9990365505
#define ll long long
using namespace std;
int n,m,x,y,z,t,tim=0,tot,visx[N],visy[N],fr[N],mch[N],nxt[M],d1[M],d2[M];
ll ex[N],ey[N],slack[N];
void add(int x,int y,int z)
{
    tot++;
    d1[tot]=y;
    d2[tot]=z;
    nxt[tot]=fr[x];
    fr[x]=tot;
}
bool dfs(int u)
{
    if (visx[u]==tim)
        return false;
    visx[u]=tim;
    for (int i=fr[u];i;i=nxt[i])
    {
        int v=d1[i];
        ll del=ex[u]+ey[v]-d2[i];
        if (!del)
        {
            visy[v]=tim;
            if (!mch[v] || dfs(mch[v]))
            {
                mch[v]=u;
                return true;
            }
        } else
            slack[v]=min(slack[v],del);
    }
    return false;
}
void KM()
{
    for (t=1;t<=n;t++)
    {
        for (int i=1;i<=n;i++)
            slack[i]=INF;
        for (;;)
        {
            tim++;
            if (dfs(t))
                break;
            ll del=INF;
            for (int i=1;i<=n;i++)
                if (visy[i]!=tim)
                    del=min(del,slack[i]);
            for (int i=1;i<=n;i++)
            {
                if (visx[i]==tim)
                    ex[i]-=del;
                if (visy[i]==tim)
                    ey[i]+=del; else
                    slack[i]-=del;
            }
        }
    }
    ll ans=0;
    for (int i=1;i<=n;i++)
        ans+=ex[i]+ey[i];
    printf("%lld\n",ans);
    for (int i=1;i<=n;i++)
        printf("%d ",mch[i]);
    putchar('\n');
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
        ex[i]=-INF,ey[i]=0;
    for (int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
        ex[x]=max(ex[x],(ll)z);
    }
    KM();
    return 0;
}
```

结果$T$了。。。

我们可以发现，在$dfs$中，每降低一次顶标，我们又开始从头开始搜索增广路了，有大量的重复信息，其实我们只需要遍历那些新加入的$slack_i=0(i \in not\_matched_y)$的节点就好了，因为它们才是可能找到增广路的节点

于是我们有了$bfs$的做法

在$bfs$过程中，如果$slack$要修改，那么我们直接修改它的前驱就好了，因为前驱不会对接下来的路径产生干扰

每个节点最多入队一次，时间复杂度$O(m)$

$bfs$版$KM$

时间复杂度：$O(nm)$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define N 505
#define M 250005
#define INF 9990365505
#define ll long long
using namespace std;
int n,m,x,y,z,tot,tim,l,r,q[N],fr[N],nxt[M],d1[M],d2[M];
int pre[N],visx[N],visy[N],mchx[N],mchy[N];
ll ex[N],ey[N],slack[N];
void add(int x,int y,int z)
{
    tot++;
    d1[tot]=y;
    d2[tot]=z;
    nxt[tot]=fr[x];
    fr[x]=tot;
}
void modify(int cur)
{
    for (int x=cur,lst;x;x=lst)
        lst=mchx[pre[x]],mchx[pre[x]]=x,mchy[x]=pre[x];
}
void bfs(int cur)
{
    for (int i=1;i<=n;i++)
        slack[i]=INF,pre[i]=0;
    l=1,r=0;
    q[++r]=cur;
    ++tim;
    for (;;)
    {
        while (l<=r)
        {
            int u=q[l];
            l++;
            visx[u]=tim;
            for (int i=fr[u];i;i=nxt[i])
            {
                int v=d1[i],cost=d2[i];
                if (visy[v]==tim)
                    continue;
                ll del=ex[u]+ey[v]-cost;
                if (del<slack[v])
                {
                    slack[v]=del;
                    pre[v]=u;
                    if (!del)
                    {
                        visy[v]=tim;
                        if (!mchy[v])
                        {
                            modify(v);
                            return;
                        }
                        q[++r]=mchy[v];
                    }
                }
            }
        }
        ll del=INF;
        for (int i=1;i<=n;i++)
            if (visy[i]!=tim)
                del=min(del,slack[i]);
        l=1,r=0;
        for (int i=1;i<=n;i++)
        {
            if (visx[i]==tim)
                ex[i]-=del;
            if (visy[i]==tim)
                ey[i]+=del; else
                slack[i]-=del;
        }
        for (int i=1;i<=n;i++)
            if (visy[i]!=tim && !slack[i])
            {
                visy[i]=tim;
                if (!mchy[i])
                {
                    modify(i);
                    return;
                }
                q[++r]=mchy[i];
            }
    }
}
void KM()
{
    for (int i=1;i<=n;i++)
        bfs(i);
    ll ans=0;
    for (int i=1;i<=n;i++)
        ans+=ex[i]+ey[i];
    printf("%lld\n",ans);
    for (int i=1;i<=n;i++)
        printf("%d ",mchy[i]);
    putchar('\n');
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
        ex[i]=-INF,ey[i]=0;
    for (int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
        ex[x]=max(ex[x],(ll)z);
    }
    KM();
    return 0;
}
```

---

## 作者：_edge_ (赞：10)

据说这题是 KM 的模板？我偏要用费用流！

各位如果想学习模板的千万千万不要看我，这里只是提出一种思想而已。

由于二分图是可以最大流得到一个答案的，所以带权的二分图匹配可以利用费用流来做到最大/最小带权匹配。

具体的过程是这样的，首先源点向左部点连出流量为 $1$，费用为 $0$ 的边，左部点向右部点连出流量为 $1$，费用为边权的，右部点向汇点连流量为 $1$，费用为 $0$ 的边。

形状长的和下面差不多。

![](https://cdn.luogu.com.cn/upload/image_hosting/r1ckbsfx.png)

由于网络流是优先保证最大流，所以它已经是能够匹配完成的，然后再是费用最大，所以就是对的。

然后就是 …… 最头疼的时间问题了，由于本题 $n=500$，正常费用流是 $O(nmf)$，这里 $f$ 为最大流也就是 $n$，所以是 $O(n^4)$ 的。

于是我们需要考虑优化，费用流有一种特殊技巧是可以先跑 SPFA，搞出一个类似差分的修改掉边权之后跑 Dijkstra 就是对的了。

具体参考[这里](https://www.luogu.com.cn/problem/P5905)。

于是如果我们用复杂度为 $O(n^2)$ 的 Dijkstra，整体复杂度应该为 $O(n^3)$。

但是但是，由于点数会乘 $2$，加上 Dijkstra 的常数因素还是通过不了本题，于是我们需要点常数优化的小技巧。

首先，这里不要用链式前向星，因为这东西找的会比较慢，尝试邻接矩阵+vector，这样是常数比较优秀的，还有一个就是 Dijkstra 前面找最小值那部分可以用链表维护，具体的就是更新过的都塞到一个链表里面，这样复杂度也是对的，并且常数能优化一下。

再一个就是不要开 long long ，然后就大概 900ms 通过本题了。

下面的代码去掉了缺省源，如果有想要完整代码的可以私信我。

```cpp
#include <bits/stdc++.h>
#define pb push_back
using namespace std;
const int INF=3e5+5;
const int INFN=1005;
int n,m,pre[INFN],pre1[INFN],S,T,ans[INFN];
int Map[INFN][INFN],fl[INFN][INFN];
vector <int> e[INFN];
void add_edge(int x,int y,int z,int zz) {
	if (Map[x][y]>1e9) e[y].pb(x);
	if (Map[y][x]>1e9) e[x].pb(y);
	Map[x][y]=zz;Map[y][x]=-zz;
	fl[x][y]=z;fl[y][x]=0;
}

queue <int> q;
int vis[INFN];
long long h[INFN],res,dis_[INFN];
void SPFA(int s) {
	memset(dis_,63,sizeof dis_);
	q.push(s);dis_[s]=0;
	while (q.size()) {
		int x=q.front();q.pop();vis[x]=0;
		for (int v:e[x]) {
			if (fl[x][v] && dis_[v]>dis_[x]+Map[x][v]) {
				dis_[v]=dis_[x]+Map[x][v];
				if (!vis[v]) 
					q.push(v),vis[v]=1;
			}
		}
	}
	for (int i=1;i<=n*2+2;i++) h[i]=dis_[i];
}
namespace Sub{
	struct _node_data{
		int l,r,v;
	}aa[INF];
	int vis1[INF],tot,s,t;
	void del(int x) {
		if (x==s) s=aa[x].r;
		if (x==t) t=aa[x].l;
		aa[aa[x].l].r=aa[x].r;
		aa[aa[x].r].l=aa[x].l;
	}
	void add(int x) {
		++tot;
		aa[tot].v=x;
		aa[t].r=tot;
		aa[tot].l=t;
		t=tot;
	}
	int Dijkstra(int ss) {
		memset(dis_,63,sizeof dis_);
		memset(vis,0,sizeof vis);
		tot=0;
		add(0);s=tot;t=tot;
		dis_[ss]=0;add(ss);
		while ("If the world loves me") {
			int Min=-1,Min1=0;
			for (int it=s;;it=aa[it].r) {
				if (Min==-1 || dis_[aa[it].v]<dis_[Min]) Min=aa[it].v,Min1=it;
				if (it==t) break;
			}
			if (Min==-1 || Min==0) break;
//			cout<<Min<<" qwe?\n";
			del(Min1);
			int x=Min;
			for (int v:e[x]) {
				if (fl[x][v] && dis_[v]>dis_[x]+Map[x][v]+h[x]-h[v]) {
					pre[v]=x;
					dis_[v]=dis_[x]+Map[x][v]+h[x]-h[v];
					if (!vis[v]) {
						add(v);
						vis[v]=1;
					}
				}
			}
		}
		return dis_[T]<1e17;
	}
}
signed main()
{
	memset(Map,63,sizeof Map);
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for (int i=1;i<=m;i++) {
		int x=0,y=0,z=0;
		cin>>x>>y>>z;
		add_edge(x,y+n,1,-z);
	}
	S=2*n+1;T=S+1;
	for (int i=1;i<=n;i++) add_edge(S,i,1,0);
	for (int i=1;i<=n;i++) add_edge(i+n,T,1,0);
	
	SPFA(S);
//	Sub::Dijkstra(S);
	while (Sub::Dijkstra(S)) {
		for (int i=1;i<=n*2+2;i++) 
			if (dis_[i]<1e17) h[i]+=dis_[i];
		int li=1e9;
		for (int i=T;i!=S;i=pre[i]) li=min(li,fl[pre[i]][i]);
		for (int i=T;i!=S;i=pre[i]) fl[pre[i]][i]-=li,fl[i][pre[i]]+=li;
		res+=li*h[T];
	}
	cout<<-res<<"\n";
	for (int x=1;x<=n;x++)
		for (int y=n+1;y<=n*2;y++)
			if (!fl[x][y] && Map[x][y]<1e9) {ans[y-n]=x;break;}
	for (int i=1;i<=n;i++) cout<<ans[i]<<" ";
//	cout<<"\n";
	return 0;
}
```


---

## 作者：BinDir0 (赞：7)


KM 算法，全名 Kuhn-Munkres 算法，可以在 $O(n^3)$​ 时间内求出二分图的最大权完美匹配。

该算法的核心思想是给每个点一个顶标 $l_i$，使得 $\forall(u,v),l_u+l_v\ge w_{u,v}$，匹配时只考虑满足 $l_u+l_v=w_{u,v}$ 的边 $u,v$，这样可以使得匹配时仅考虑这些边，不用考虑边权跑出来的完美匹配一定是最大权完美匹配。证明考虑任意一个完美匹配权值为 $\sum w(u,v)\le\sum l$，而我们按照上述方法跑出来的匹配权值为 $\sum l$。

考虑如何实现。我们先初始化一组顶标，使得其满足上述条件，一种可行的初始化方案是令右部点的顶标 $l_v=0$，左部点的顶标 $l_u=\max_v w_{u,v}$。这之后，我们只考虑所有点和满足 $l_u+l_v=w_{u,v}$​ 的边，我们称这样的一个子图为“相等子图”，考虑在其中找匹配。

仿照找最大匹配的方法，我们考虑每次新加一个左部点进入匹配。加入一个左部点 $u$ 时，我们从 $u$ 开始跑一遍匈牙利算法找匹配，若找到匹配则继续考虑下一个左部点，若未找到匹配则说明当前相等子图已经无法找到完美匹配，此时我们要设法扩大它，于是我们考虑调整顶标。

注意到此时从 $u$ 开始通过走未匹配、匹配、未匹配...的交错路我们可以到达部分左部点，将这些路径提出来可以得到一棵树，我们称之为交错树。定义在交错树上的左/右部点分别为点集 $S,T$，不在交错树上的点类似定义为 $S',T'$​。

下图是一个例子，其中红色点是 $u$​​​，红色边是匹配中的边，所有边都是相等子图中的边。在这个例子中，交错树是一条链（左 4 到左 3）。

![](https://cdn.fzoi.top/upload/user/c20200605/22022212507365.png)

我们发现：一定没有 $S-T'$ 的边，不然交错树会增长或者甚至找到匹配；$S'-T$​​ 的边一定是非匹配边，否则该左部点将可以被 $u$ 走到，从而进入 $S$​。

考虑一种调整的操作：设定一个常数 $a$​​，给 $S$​​ 中的顶标 $-a$​​，$T$​​ 中的顶标 $+a$​​​，则该操作会造成以下效果：

- $S-T,S'-T'$ 的边不受影响。
- $S'-T$​​ 的边 $l_u+l_v$​ 增大，可能会有边被移出相等子图。
- $S-T'$ 的边 $l_u+l_v$ 减小，可能有边被加入相等子图。

然而此时我们选的这个 $a$ 需要使得我们做完这次操作后仍然对于所有边有 $l_u+l_v\ge w_{u,v}$。第一种影响不用考虑，第二种影响的 $l_u+l_v$​​​​ 只增不减，于是也不用考虑，只用考虑第三种影响。为了使调整后的顶标仍然满足条件，我们取 $a=\min\{l_u+l_v-w_{u,v}\mid u\in S,v\in T'\}$ 即可。

调整后会有新右部点加入，我们考虑这个右部点：

- 如果其是未匹配点，则我们已经找到了一条增广路。
- 如果其与 $S'$ 中的点匹配了，则我们的 $S,T$ 集合与交错树均被扩大，我们继续重复刚才的过程即可。

可以发现，在最多 $n$ 次操作后，我们一定可以找到一个未匹配点，于是此时匹配完成，继续考虑下一个左部点即可。

实现时直接维护交错树即可，因为交错树中的边是只增不删的。

除此之外，为了保证复杂度，我们还需要对每个 $T'$​​ 中的节点维护一个松弛量 $slack_v=\min \{l_u+l_v-w_{u,v}\mid u\in S\}$​​，每次求 $a$​​ 的值时暴力枚举每一个 $T'$​​​ 中的点，找到最小的 $slack_v$，令 $a$ 等于其值，并把 $v$​ 和其匹配点（如果有）加入交错树即可，而无需再将能从之直接到达的点加入：因为若 $v$ 的匹配点 $x$ 还能到达其他右部点 $y$，则说明有 $l_x+l_y-w_{x,y}=0$，根据定义有 $slack_y=0$​，于是在接下来的操作中 $y$ 会先被加入。

时间复杂度：需要执行 $O(n)$ 次加入左部点操作，每次操作需要跑一遍 $O(n^2)$ 的匈牙利算法，每次需要将 $O(n)$ 个左部点加入交错树中，每加入一个左部点需要 $O(n)$ 用当前加入的点对每个右部点计算 $slack$；每次操作要调整 $O(n)$ 次顶标，每调整一次顶标要修改 $O(n)$ 个点的顶标和 $slack$，于是时间复杂度是严格 $O(n^3)$。

对于更一般的情况的处理：

- 若原图左右部点数量相等但并不保证有完美匹配，需分情况讨论：
  - 若只要求最大权或是允许部分点不匹配等情况，可以把原图补成完全图，其中连的虚边边权均为 0；
  - 若要求最大匹配，有两种方法：一种是网上介绍的多的方法是补成完全图，其中边权为负无穷；一种是我口胡的（不知道对不对），可以先把原图跑一遍最大匹配看看是否有完美匹配。

- 若左右部点数量不等，可以通过补虚点的方式使左右部点数量相等，然后用上面的方法做。





code（洛谷模板题）：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n , m , x , y , z , fp[1100] , par[1100] , fa[1100] , mn[1100] , ok = 0;
int fst[1100] , nex[550000] , v[550000] , tot , mxpar[1100] , f[550][550];
long long l[1100] , slack[1100] , ans , val[550000];
vector< int > id , lp , rp;
void add( int a , int b , long long c )
{
	nex[++tot] = fst[a]; fst[a] = tot;
	v[tot] = b; val[tot] = c;
}
int match( int u )
{
	id.push_back(u);
	for(int i = fst[u] ; i ; i = nex[i] )
	{
		if(l[u] + l[v[i]] != val[i] || fa[v[i]]) continue;
		if(!fp[v[i]]) 
		{
			par[u] = v[i]; par[v[i]] = u; fp[u] = fp[v[i]] = 1;
			ans += l[v[i]];
			return 1;
		}
		else
		{
			if(fa[v[i]] = u , fa[par[v[i]]] = v[i] , match(par[v[i]])) 
			{
				par[v[i]] = u; par[u] = v[i]; fp[u] = fp[v[i]] = 1;
				return 1;
			}
		}
	}
	return 0;
}
long long KM( vector< int > &lp , vector< int > &rp )
{
	ans = 0;
	int t = n + n;
	while(lp.size() < rp.size()) 
	{
		lp.push_back(++t);
		for(int i : rp) add(t , i , 0);
	}
	while(lp.size() > rp.size()) 
	{
		rp.push_back(++t);
		for(int i : lp) add(i , t , 0);
	}
	for(int i : lp) fp[i] = l[i] = par[i] = 0;
	for(int i : rp) fp[i] = l[i] = par[i] = 0;
	for(int i : lp)
		for(int e = fst[i] ; e ; e = nex[e] ) l[i] = max(l[i] , (long long)val[e]);
	for(int i : lp)
	{
		for(int u : lp) fa[u] = 0 , slack[u] = 1e16;
		for(int u : rp) fa[u] = 0 , slack[u] = 1e16;
		slack[0] = 1e16;
		fa[i] = -1; 
		if(match(i)) 
		{ 
			ans += l[i] , id.clear(); 
			continue; 
		}
		while(1)
		{
			for(int j : id)
				for(int e = fst[j] ; e ; e = nex[e] )
					if(slack[v[e]] > l[j] + l[v[e]] - val[e])
						slack[v[e]] = l[j] + l[v[e]] - val[e] , mn[v[e]] = j;
			id.clear();
			int u = 0;
			for(int j : rp)
				if(slack[j] < slack[u] && !fa[j]) u = j;
			int w = slack[u];
			for(int j : lp)
				if(fa[j]) l[j] -= w , ans -= w;
			ans += w;
			for(int j : rp)
			{
				if(fa[j]) l[j] += w , ans += w;
				else slack[j] -= w;
			}
			if(!fp[u])
			{
				ans += l[u] + l[i]; 
				int las = u; u = mn[u]; 
				while(u != -1)
				{
					if(las)
					{
						par[las] = u; par[u] = las; fp[u] = fp[las] = 1;
						las = 0;
					}
					else las = u;
					u = fa[u];
				}
				break;
			}
			fa[u] = mn[u]; int v = par[u]; fa[v] = u;
			id.push_back(v);
		}
	}
	return ans;
}
int main()
{
//	freopen("1.in" , "r" , stdin);
//	freopen("1.out" , "w" , stdout);
	scanf("%d%d" , &n , &m);
	for(int i = 1 ; i <= m ; i++ )
	{
		scanf("%d%d%d" , &x , &y , &z); f[x][y] = 1; z += 19980731;
		add(x , y + n , z); 
	}
	for(int i = 1 ; i <= n ; i++ )
		for(int j = n + 1 ; j <= n + n ; j++ )
			if(!f[i][j - n]) add(i , j , -1e12);
	for(int i = 1 ; i <= n ; i++ ) lp.push_back(i);
	for(int i = n + 1 ; i <= n + n ; i++ ) rp.push_back(i);
	printf("%lld\n" , KM(lp , rp) - 19980731ll * n);
	for(int i = n + 1 ; i <= n + n ; i++ ) 
	{
		if(par[i] <= n && f[par[i]][i - n]) printf("%d " , par[i]);
		else printf("0 ");
	}
	return 0;
}
/*
*/
```











---

## 作者：_121017_ (赞：6)

# 题目简介
二分图最大完备匹配的模板题。
# 思路
由于本题要求最大完备匹配，所以一般的匈牙利（增广路）算法肯定是行不通的，那么我们怎么求最大完备匹配呢？

其实，我们只需要维护左部点的顶标 $la_{i}$，和右部点的顶点 $ra_{i}$ 即可。对于每次找增广路，都有满足 $la_{i}+ra_{i}\ge w_{i,j}$，当且仅当 $la_{i}+ra_{i}= w_{i,j}$ 时，我们把 $w_{i,j}$ 作为可行的增广路。我们把每次遍历过的节点称之为交错树。我们尝试维护一个 $delta$，如果我们把交错树中的每一个左部点减去 $delta$，右部点加上 $delta$ 会发生什么呢？有两种情况。

- 1. 当左部点 $x$ 与右部点 $y$ 都在交错树中时，顶标之和不变。对于所有顶标不变的匹配，我们称之为相等子图。

- 2. 当只有左部点 $x$ 在交错树中时，顶标之和减小，那么我们可能就多了一条可行的增广路。

看到这里，我们不难发现求最大完备匹配其实就是不断扩大相等子图的过程，这就是大名鼎鼎的 $KM$ 算法。
# code：
```cpp
#include<bits/stdc++.h>
#define int long long
#define ri register int
#define N 505
#define INF 0x7f7f7f7f
using namespace std;
int n,m;
int la[N],ra[N],w[N][N],vis[N],slack[N],match[N],pre[N]; 
void bfs(int u){
	int x,y=0,yy=0,delta;
	memset(pre,0,sizeof(pre));
	for(ri i=1;i<=n;i++) slack[i]=INF;
	match[y]=u;
	while(1){
		x=match[y],delta=INF,vis[y]=1;
		for(ri i=1;i<=n;i++){
			if(vis[i]){
				continue;
			}
			if(slack[i]>la[x]+ra[i]-w[x][i]){
				slack[i]=la[x]+ra[i]-w[x][i];
				pre[i]=y;
			}
			if(slack[i]<delta) delta=slack[i],yy=i; 
		}
		for(ri i=0;i<=n;i++){
			if(vis[i]){
				la[match[i]]-=delta;
				ra[i]+=delta;
			}else{
				slack[i]-=delta;//由于本题卡O(n4)，所本题需要用到bfs版的KM
			}
		} 
		y=yy;
		if(match[y]==-1){
			break;
		}
	}
	while(y){
		match[y]=match[pre[y]];
		y=pre[y];
	}
}
int KM(){
	memset(match,-1,sizeof(match));
	memset(la,0,sizeof(la));
	memset(ra,0,sizeof(ra));
	for(ri i=1;i<=n;i++){
		memset(vis,0,sizeof(vis));
		bfs(i);
	}
	int ans=0;
	for(ri i=1;i<=n;i++){
		if(match[i]!=-1){
			ans+=w[match[i]][i];
		}
	}
	return ans;
}
signed main(){
	cin>>n>>m;
	for(ri i=1;i<=n;i++){
		for(ri j=1;j<=n;j++){
			w[i][j]=-INF;
		}
	}
	for(ri i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		cin>>w[u][v];
	}
	cout<<KM()<<endl;
	for(ri i=1;i<=n;i++){
		cout<<match[i]<<" ";
	}
	return 0;
}


```


---

## 作者：Anita_Hailey (赞：6)

# P6577 【模板】二分图最大权完美匹配

## 序

啊，今天在学校和 qs 闹了点矛盾。

## 正文

### 一些吐槽

首先这个题写的很清楚，我们要做二分图最大权匹配，那么，首先会有几个想法，（在我不会 KM 之前

- 最大费用流
- ~~np枚举~~

接下来，这题数据达到了505，绝对是卡死了 **ek**, **zkw**, 或许 dijkstra 可以水一水？没试过，但是用网络瘤做匹配真的是毒瘤。

### bfs 过程

Singercoder 跟我说，他总是不理解这种算法，~~我只想说 ：“巧了”~~，其实对于我们这种蒟蒻来说，还是bfs，之后牢记就好了吧。~~毕竟是大龄选手了~~

**不要看百度百科，那玩意错了，Singercoder 把他 hack 了**

首先是一个贪心的过程，把点分为左部点和右部点，其中每个点都有一个顶标。

理解为找对象？噢，那就很清楚了（

我们约定：

- $lx[i]$ 左部点的顶标
- $ly[i]$ 右部点的顶标
- $visx[i]$ 左边的 $i$ 点是否遍历到了
- $visy[i]$ 右边的 $i$ 点是否遍历到了
- $link[i]$ 就是右部点对应的左部点的标号
- $mat[i]$ 反之
- $slack[i]$ 松弛量

给出一个定义，叫做相等子图。啥意思？ 对于左部点里的 $u$ 和右部点里的 $v$ 如果 $lx[ u ] + ly[ v ] = mp[ u ][ v ]$ ，那么 $mp[u][v]$ 就是相等子图里的边，~~由于把他理解为搞对象~~，所以每个点会先第一招跟他边权最大的点，让这些边能进入相等子图，所以初始的时候左部点的顶标定为 $lx[ i ] = \max_{1\le j \le n}\{mp[ i ][ j ]\}$，而我们的 $ly[i]$ 就是 $0$，然后考虑对于每一个点做增广，这叫做交替增广路。可能还是dfs的好理解？

这里挂一个 dfs 的[学习资料](https://blog.csdn.net/chenshibo17/article/details/79933191)qwq

所以，在这道题上，会挂，因为他的复杂度事实上是 $O(n^4)$ 的，其原因在于每次不行更改点权之后还要在重走一遍增广路，所以改为 BFS 就可以，做到真正的 $O(n^3)$ 于是，我们可以搞出来。以下的 bfs过程

其实就是一个把 dfs 变成 BFS 的过程，但是由于要增广路取反的原因，所以要记录前驱

给点小建议，在有些题里要是没有完备匹配 KM 可是会死循环的。所以，大胆加虚点吧，少年。

```c++
void
BFS( int s )
{
	int delta;
	std::memset( slack, 63, sizeof slack );
	std::fill( visx + 1, visx + 1 + n, 0 );
	std::fill( visy + 1, visy + 1 + n, 0 );
  // 初始化
	std::queue < int > q;
	while( !q.empty( ) ) q.pop( );
	q.push( s );
	while( true )
	{
		while( !q.empty( ) )
		{
			int fr = q.front( );
			q.pop( );
			visx[ fr ] = 1;
			For( i, 1, n )
			{
        // 跟正常的 KM 差不多，但是需要记录前驱
				if( visy[ i ] ) continue;
				delta = lx[ fr ] + ly[ i ] - mp[ fr ][ i ];
				if( !delta )
				{
					visy[ i ] = 1;
					pre[ i ] = fr;
					if( !link[ i ] ) return AUG( i );// AUG 函数就是交替取反
					q.push( link[ i ] );
				}
				else if( slack[ i ] > delta ) slack[ i ] = delta, pre[ i ] = fr;
			}
		}
		delta = 0x3f3f3f3f;
    // 找到最小的松弛量
		For( i, 1, n ) if( !visy[ i ] ) delta = std::min( delta, slack[ i ] );
		For( i, 1, n )
		{
			if( visx[ i ] ) lx[ i ] -= delta;
			if( visy[ i ] ) ly[ i ] += delta;
			else slack[ i ] -= delta;
      // 这个其实是有一点小问题的，但是没啥大问题
		}
		For( i, 1, n )
		{
      // 修改点权然后入队
			if( !visy[ i ] && !slack[ i ] )
			{
				visy[ i ] = 1;
				if( !link[ i ] ) return AUG( i );
				q.push( link[ i ] );
			}
		}
	}
	return;
}
```



然后坑就来了。这个题，有负权。于是我们的 mp 要初始化为 -INF...lz就因为这个 WA 的哭了

[全部代码](https://paste.ubuntu.com/p/xg6pSq8PxJ/)

## 嵬

准备中考ing

对了[这个题](https://www.luogu.com.cn/problem/P6061)也是 KM，而且跑的不是很慢。


**update:**

这是一个大改

> 给点小建议，在有些题里要是没有完备匹配 KM 可是会死循环的。所以，大胆加虚点吧，少年。

这在扯淡。跟Singercoder聊了一下，发现很玄学的事情

比如我们看下面这个图

**应Singercoder要求，将一些文字打码**

![](https://cdn.luogu.com.cn/upload/image_hosting/cbna00ff.png)

Singercoder 的样例

这里的实边是是相爱的 couple，而除了标注的边之外都是在相等子图里的边是垂涎是爱慕是求之不得，所以我们从那个 ~~Singer~~ Single 开始增广，

以下均属于情景带入：


Singercoder:就这单身狗，先追求上面那个,
他和1号说，哥，女神让我好不

zhltao:啊！

Singercoder:1号冥思苦想，他觉得和single每日交情不错
,然后就吊着他,告诉他，自己有备胎，你等等,然后1号这个渣男，就去找4号女.

zhltao:啊？

Singercoder:可人家4号女过的可好了.

zhltao:而可不是吗

Singercoder:注意，在此之前，这是重点,1号男和4号女的关系不是那么好
(不在子图里)

zhltao:敲黑板

Singercoder:于是1号男决定为好兄弟单身狗搞事情,他决定培养感情

zhltao:于是记录了一个delta

Singercoder:然后，大家都知道，1号男失败了
他努力过

zhltao:对

Sinegrcoder:于是不后悔
但是single不行啊
他就去找3号女
和3号男说，哥，女神让我好不

zhltao:嗬！

Singercoder:然后又一通操作,
但是这里有个非常重要的细节,
就是4号女又在路径上了,
这个4号女啊，看起来弱不禁风，小家碧玉,但她和3个男生有很奇妙的关系,
这种关系看起来无所谓,
但是啊，但是,
她，就是凶手啊.

zhltao:这

Singercoder:是那个让single苦苦追求，以致死循环，永世不得匹配的罪魁祸首,孤独者自作自受的诅咒,
没有它就没有无尽的追求与失败

Singercoder:
我们分析一下是什么导致了single的痛苦,
第一次，1号男去找4号女,
因为他们关系不好，所以4号女没被标记，而是记录delta,
这个delta不等于0，很重要
,
第二次，single向下探求，这次经过了4号女，而且是完全穿过♂,
这个很重要,
这一穿过，就会导致,
vy[4]=1

zhltao:所以死了。

来这就是传说中 dfs 死循环的魅力。。


---

## 作者：Z1qqurat (赞：4)

## 二分图最大权完美匹配

简单地讲讲 KM 算法。重点在于对代码的诠释而不是对理论，概念，算法流程的解说，因为我在学习过程中深受代码所困。如果有其他需求建议移步其他题解。

### 基本理论&算法流程

首先有一个问题转化：我们给每个点一个顶标，左部点顶标为 $lx_i$，右部点顶标为 $ly_j$，对于每条边 $(i, j)$，都要满足$w(i, j) \le lx_i + ly_j$。当我们满足$w(i, j) = lx_i + ly_j$ 的边组成的子图是一个包含所有点的完美匹配时，我们就找到了最大权完美匹配，权值和为 $\sum\limits_{i = 1} ^ {n} (lx_i + ly_i)$。

现在我们需要在满足顶标合法（即$w(i, j) \le lx_i + ly_j$）的情况下不断调整顶标，使相等子图（即由满足$w(i, j) = lx_i + ly_j$ 的边与点组成的子图）边数增加。为了保证合法性，我们考虑先设 $lx_i = \max\limits_{j = 1}^{n} w(i, j)$，这需要先把二分图补全，不存在的边边权设为 $-\infty$ 即可。

接下来我们从每个左部点 $s$ 出发，寻找一条增广路。方便起见我们将 $match_0$ 设为 $s$。当前右部点为 $y$，其匹配的左部点为 $x$，$slack_i$ 表示以 $i$ 为右部点的边中 $lx_i + ly_j - w(i, j)$ 最小的。我们找到一条长为 $l$ 的增广路，使其前 $l - 1$ 条边已经满足 $w(i, j) = lx_i + ly_j$，现在设第 $l$ 条边为 $(a, b)$，$v = lx_a + ly_b - w(a, b)$。那么我们将增广路上所有左部点的 $lx_i$ 减 $v$，所有右部点的 $ly_j$ 加上 $v$，那么这一条增广路是满足条件的了。但是这样对顶标的修改可能影响到一些之前匹配好并且相等了的边的合法性，所以我们更加直接地，将所有匹配的左部点以及起点 $s$ 的 $lx_i$ 都下调 $v$，所有已匹配的右部点的 $ly_j$ 都上调 $v$，这样就可以保证正确性了。最后我们将增广路上的匹配边和未匹配边做一个切换，相等子图中边数 $+1$，完成了一次增广。

### 代码分步解说

接下来我们来仔细解释一下各部分代码，这也是我认为各大题解有所欠缺的地方了。题解中代码是在编写本题解时直接打的，均未编译/提交，食用需谨慎。

* 首先是补全二分图还有顶标的初始化：

  ```cpp
  scanf("%d %d", &n, &m);
  for (int i = 1; i <= n; ++i) {
      for (int j = 1; j <= n; ++j) w[i][j] = -inf;
  }
  for (int i = 1; i <= m; ++i) {
      int u, v, w; scanf("%d %d %d", &u, &v, &w);
      //注意是单向边
      w[u][v] = max(w[u][v], (ll)w); //最大权匹配自然边权越大越好
  }
  for (int i = 1; i <= n; ++i) {
      lx[i] = -inf, ly[i] = 0;
      for (int j = 1; j <= n; ++j) lx[i] = max(lx[i], w[i][j]);
  }
  ```

  

* 接下来是对 $s$ 的增广，首先有一些初始化：

  ```cpp
  int x = 0, y = 0, id = 0; ll v = inf; match[0] = s; //id是增广路中上一个右部点，x和y分别是目前匹配边的左右点
  for (int i = 1; i <= n; ++i) slack[i] = inf, pre[i] = 0;
  ```

  然后不停地从 $y$ 开始向左找一条匹配边 $(x, y)$，从 $x$ 开始往右找未匹配边。先给个代码：

  ```cpp
  while(match[y]) {
      y = id, x = match[y], vis[y] = 1, v = inf; //vis表示已被匹配
  	for (int i = 1; i <= n; ++i) { //从x开始往右找到一个需要调整的v最小的未匹配点x
      	if(slack[i] > lx[x] + ly[i] - w[x][i]) {
          	slack[i] = lx[x] + ly[i] - w[x][i];
          	pre[i] = y; //这时候可以选择i为增广路上下一个右部点
  		}
      	if(slack[i] < v) {
          	v = slack[i], id = i; //此时i为目前调整量最小的未匹配点，将i加入增广路
  		}
  	}
  	for (int i = 0; i <= n; ++i) {
          if(vis[i]) lx[match[i]] -= v, ly[i] += v; //调整匹配点&s的顶标，为了调整s，i从0开始（match[0]=s）
          else slack[i] -= v;
  	}
  }
  while(y) match[y] = match[pre[y]], y = pre[y]; //将增广路上匹配边和未匹配边切换，相等子图边数+1
  ```

* 敲黑板！现在是我认为最难理解的部分。如果你仔细观察代码，可以画出这样的图：			![](https://pic.imgdb.cn/item/64f699d0661c6c8e54903335.png)

​			 诶我的增广路为什么有偶数条边？还有中间那个 $0$ 怎么会是！

* 首先，那条 $(s, 0)$ 的绿边是一条辅助边，只是为了方便我们求出增广路，硬生生将其凑成偶数条边。

* 其次，红边是我们的未匹配边，刚好与我们每次从 $x$ 出发找一条 $v$ 最小的未匹配边对应。

* 最后，橙边就是已匹配边，也就是 $(x, y)$，我们的绿边在代码中也是这样处理的。所以我们只需要将橙边切换为红边就可以了，只用改变 $match$ 的值。

于是我们就理解了 KM 的代码是怎么工作的了！以上只是作者根据一些简洁的题解代码自行理解得来，若有错误请指出！

代码写得有点丑就不放完整的了，具体可以参考分步解说中的代码/一些别的题解中的代码。

---

## 作者：Somusomunia (赞：2)

# KM 算法
## Step 1
最大权匹配嘛，所以我们就可以想到让每个点都选择与自己相连的边中权值最大的那一条边。
同时，由于边权的问题不是特别好处理，所以我们可以想到，把边权的问题转化成点权的问题。

**所以，问题就来了，怎么处理呢？**

在 KM 算法中有一个加做顶标的东西用来处理点权与边权的问题，其中，一条选择了的边的边权，用该边的左右两个节点的点权之和来表示。

由于我们一开始贪心地选择了每个节点中边权最大的那一条边，同时，为了方便处理，我们只对左边的点赋为与该点相连的边中权值最大的那一条边的权值，而对右边的点全部赋为 $0$。
```cpp
for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) lx[i]=max(lx[i],e[i][j]);//lx 为顶标数组
```
## Step 2
但是，这样一看就很明显是假的，所以我们应该思考如何对点权进行调整。

这时候，我们就需要用到匹配了，在 KM 算法中，我们钦定，只有左右点权之和与该边相等的边属于匹配边，其余的都不算匹配边。

在用 bfs 匹配的过程中（注意：如果你不用 bfs 的话，有可能会 TLE 哦），如果发现一个点没有可以匹配的边了，这就说明，这样匹配是有问题的，这时，我们就要对这条路径进行松弛，对该路径上的每一个左点权减一，对每一个右点权加一。由于我们匹配时的出发点与结束点均在左边（即匹配的路径是一条增广路），因此可以保证，整个图的权值之和是降低了的。


这样做，**既保障了边权并未变动**，**还可使重新匹配的时候**，左节点可以与较小的边进行匹配，这就是 KM 算法的精髓所在。

但是，我们会发现，有可能路径上的点的两条边权值差可能会很大，加一减一效率过低，所以我们在这里就要引入 $slack$ 数组，以及 $mi$ 变量，分别来记录点权之和与边权的差值，以及这个差值的最小值.通过直接加减这个最小的差值就可以提高效率。

如果在匹配的时候发现匹配的点没有下一个匹配的点，就说明这条路径上已经匹配结束，并将该条路径上的点全部连接起来，并打上标记，并结束这次匹配。
```cpp
void link(int o){
	while(o){
		pxp=px[pre[o]],px[pre[o]]=o;
      		py[o]=pre[o],o=pxp;
	}
}
```

如果有可匹配的下一个点且下一个点未被访问，那么将这个点加入队列。
```cpp
if(!py[i]){
	link(i);
	return ;
}
if(!visx[py[i]]) q.push(py[i]); 
```

在 bfs 完一遍之后，就可以执行上面提到过的松弛操作，降低效率之后重新进行匹配，并将顶标修改后匹配且未被访问过的左节点加入队列，用来进行下一次匹配（注意：这里也要处理匹配结束的情况），直到匹配合法。
```cpp
void bfs(int o){
	fill(slack+1,slack+n+1,inf);
	memset(visx,false,sizeof(visx)),memset(visy,false,sizeof(visy));
	while(!q.empty()) q.pop();
	q.push(o);
	while(1){
		while(!q.empty()){
			t=q.front();q.pop();
			visx[t]=true;
			for(int i=1;i<=n;i++){
				if(visy[i]) continue;
				if(slack[i]>lx[t]+ly[i]-e[t][i]){
					slack[i]=lx[t]+ly[i]-e[t][i];
                    			//更新 slack
					pre[i]=t;
                    			//pre为前驱数组，即和该右节点匹配的左节点
					if(slack[i]) continue;
					visy[i]=true;
					if(!py[i]){
						link(i);
                        			//连通并打上标记
						return ;
					}
					if(!visx[py[i]]) q.push(py[i]); 
                    			//如果该节点对应的左节点为被访问则将该节点对应的左节点入队
				}
			}
		}
		mi=inf;
		for(int i=1;i<=n;i++) if(!visy[i]) mi=min(mi,slack[i]);//更新 mi
		for(int i=1;i<=n;i++){
        		//更新顶标以及 slack
			if(visx[i]) lx[i]-=mi;
			if(visy[i]) ly[i]+=mi;
			else slack[i]-=mi;
		}
		for(int i=1;i<=n;i++){
			if(!visy[i]&&!slack[i]){
            			//将为被匹配与未被访问的右节点的对应合法左节点入队
				visy[i]=true;
				if(!py[i]){
					link(i); 
					return ;
				}
				if(!visx[py[i]]) q.push(py[i]);
			}	
		}
	}
}
```
只要以每个点出发，都 bfs 一遍，那么答案就等于左右节点的顶标之和.每个点所对应的匹配的点就是 $py$ 数组中的数据。
```cpp
for(int i=1;i<=n;i++) bfs(i);
for(int i=1;i<=n;i++) ans+=lx[i]+ly[i];
cout<<ans<<"\n";
for(int i=1;i<=n;i++) cout<<py[i]<<" ";	    
```
### 最后是完整代码
#### [代码](https://www.luogu.com.cn/paste/33hnz1dk)

---

## 作者：Leasier (赞：2)

1. 用途

给定一张有完美匹配的二分图，求其权最大完美匹配。

2. 流程

考虑给左右部每个点都分配一个**顶标**，设左部点的顶标为 $x_i$，右部点的顶标为 $y_i$，则其需要满足：

- $\forall (u, v, w) \in E$，$x_u + y_v \geq w$。

设**松弛量** $slack_v = \displaystyle\min_{(u, v, w) \in E} (x_u + y_v - w)$。

我们称满足 $x_u + y_v - w = 0$ 的边 $(u, v, w)$ 为**相等边**，相等边构成的子图为**相等子图**。这里每一条相等边都表示一个匹配。

当相等子图的点集为左右部点的并集时我们便求出了最大权完美匹配，则现在所求转化为 $\displaystyle\sum_{i = 1}^n (x_i + y_i)$。

考虑从一个符合条件的初始顶标开始，贪心地逐渐扩展相等子图并修改相关顶标，直到找到最大权完美匹配。

比如说我们初始钦定 $x_u$ 为 $u$ 所有出边的权值最大值，$y_u = 0$。

现在我们考虑进行一次 dfs 增广，找到增广路则增广，否则我们考虑修改顶标。

设左右部点与交错树（即增广失败时的 dfs 树）点集的交为 $S, T$，两者余下部分分别为 $S', T'$。

考虑将 $i \in S$ 的 $x_i$ 减少 $\Delta$，再将 $i \in T$ 的 $y_i$ 增加 $\Delta$，设 $u$ 为左部点、$v$ 为右部点，则：

- $u \in S, v \in T$：$x_u, y_u$ 都减少 $\Delta$。
- $u \in S, v \not\in T$：$x_u$ 减少 $\Delta$，$y_u$ 不变。
- $u \not\in S, v \in T$：不存在。
- $u \not\in S, v \not\in T$：不变。

令 $\Delta = \displaystyle\min_{i \text{ in the right } \not\in T}^n slack_i$（这里取最小值是因为这样才能继续满足条件），则：

- 若 $i \in S$，令 $x_i \leftarrow x_i - \Delta$。
- 若右部的 $i \not\in T$，令 $slack_i \leftarrow slack_i - \Delta$；否则，令 $y_i \leftarrow y_i + \Delta$。

进行这样一次修改后，我们便让匹配边集大小增加了 $1$。

直接 dfs 实现是 $O(n^4)$ 的（当然随机数据下表现与 $O(n^3)$ 相近），这里我们改成 bfs 即可做到 $O(n^3)$。

3. 实现：[P6577 【模板】二分图最大权完美匹配](https://www.luogu.com.cn/problem/P6577)

注意顶标绝对值的上限为 $O(n \max |h|)$，在这道题中可以卡到接近 $10^{10}$，记得开 long long。

代码：
```cpp
#include <iostream>
#include <queue>
#include <cstdio>

using namespace std;

typedef long long ll;

typedef struct {
	int nxt;
	int end;
	int dis;
} Edge;

int cnt = 0, tm = 0;
int head[507], link1[507], link2[507], pre[507], vis1[507], vis2[507];
ll val1[507], val2[507], slack[507];
Edge edge[250007];
queue<int> q;

inline void add_edge(int start, int end, int dis){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
	edge[cnt].dis = dis;
}

inline bool update(int x){
	vis2[x] = tm;
	if (link2[x] != 0){
		vis1[link2[x]] = tm;
		q.push(link2[x]);
		return false;
	}
	while (x != 0){
		link2[x] = pre[x];
		swap(x, link1[pre[x]]);
	}
	return true;
}

inline ll km(int n){
	ll ans = 0;
	for (register int i = 1; i <= n; i++){
		link1[i] = link2[i] = 0;
	}
	for (register int i = 1; i <= n; i++){
		val1[i] = 0x8000000000000000ll;
		for (register int j = head[i]; j != 0; j = edge[j].nxt){
			val1[i] = max(val1[i], (ll)edge[j].dis);
		}
		val2[i] = 0;
	}
	for (register int i = 1; i <= n; i++){
		tm++;
		while (!q.empty()) q.pop();
		for (register int j = 1; j <= n; j++){
			pre[j] = 0;
			slack[j] = 0x7fffffffffffffffll;
		}
		q.push(i);
		vis1[i] = tm;
		while (true){
			bool flag = false;
			while (!q.empty()){
				int cur = q.front();
				q.pop();
				for (register int j = head[cur]; j != 0; j = edge[j].nxt){
					int x = edge[j].end;
					if (vis2[x] != tm){
						ll y = val1[cur] + val2[x] - edge[j].dis;
						if (slack[x] > y){
							pre[x] = cur;
							if (y != 0){
								slack[x] = y;
							} else if (update(x)){
								flag = true;
								break;
							}
						}
					}
				}
				if (flag) break;
			}
			if (flag) break;
			ll delta = 0x7fffffffffffffffll;
			for (register int j = 1; j <= n; j++){
				if (vis2[j] != tm) delta = min(delta, slack[j]);
			}
			for (register int j = 1; j <= n; j++){
				if (vis1[j] == tm) val1[j] -= delta;
				if (vis2[j] != tm){
					slack[j] -= delta;
				} else {
					val2[j] += delta;
				}
			}
			flag = false;
			for (register int j = 1; j <= n; j++){
				if (vis2[j] != tm && slack[j] == 0 && update(j)){
					flag = true;
					break;
				}
			}
			if (flag) break;
		}
	}
	for (register int i = 1; i <= n; i++){
		ans += val1[i] + val2[link1[i]];
	}
	return ans;
}

int main(){
	int n, m;
	scanf("%d %d", &n, &m);
	for (register int i = 1; i <= m; i++){
		int y, c, h;
		scanf("%d %d %d", &y, &c, &h);
		add_edge(y, c, h);
	}
	cout << km(n) << endl;
	for (register int i = 1; i <= n; i++){
		cout << link2[i] << " ";
	}
	return 0;
}
```

---

## 作者：Foreverxxx (赞：2)

广告：[一名 Blink 的博客](https://foreverxxx.blog.luogu.org/)

本篇题解是博主在学习 KM 算法以及学习各种题解后总结归纳得来，可能会有不少的错误，欢迎大家指正！

### 一些定义

* 完美匹配：

> 若图中的一个匹配，包括了图中的所有点，则称这个匹配为完美匹配。完美匹配使图中所有点都为匹配点。------- 百度百科

* 二分图完美匹配：二分图中，每一个左部点正好匹配到一个右部点，该二分图的最大匹配即为完美匹配，匹配数为 $n$。

* 二分图最大权完美匹配：二分图的完美匹配的 $n$ 条边的权值最大。

**前置芝士**：匈牙利算法、二分图最大匹配。

如果对上述算法并不熟悉建议右转 [P3386 【模板】二分图最大匹配](https://www.luogu.com.cn/problem/P3386) 进行学习。

### KM 算法简介

KM 算法，能够优秀的效率下求解二分图的最大权完美匹配，一般用邻接矩阵存储图即可，一般有 DFS 和 BFS 两种写法。

### 一些变量的含义

> edge[i][j] 表示第 $i$ 个节点到第 $j$ 个节点之间的边的权值，即邻接矩阵。

> matched[i] 表示第 $i$ 个右部点当前匹配到的左部点。

> lx[i] 表示第 $i$ 个左部点的顶标，具体作用下面会说。

> ly[i] 表示第 $i$ 个右部点的顶标，具体作用下面会说。

> visx[i] 表示第 $i$ 个左部点的遍历标记。

> visy[i] 表示第 $i$ 个右部点的遍历标记。

### 核心思路

* 一些定义

1. 相等边： 满足 $lx[u]+ly[v]=w_{u,v}$ 的边。

2. 相等子图： 由相等边组成的图。

对于一条边，其中左部点为 $u$，右部点为 $v$，初始顶标满足 $lx_u+ly_v \ge w_{u,v}$。在寻找最大权匹配时，我们尝试寻找增广路，如果找不到增广路，则调整顶标，重复寻找增广路并修改顶标，直到找到每个点均找到匹配。

其中，找增广路可以使用匈牙利算法。

那我们应该如何修改顶标？

我们选择运用贪心的思路，将一个点增广所需的边中，最大的边变为相等边，逐渐扩大相等子图。

先看代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
    int sss=0,www=1;
    char chh=getchar();
    while(chh<'0'||chh>'9'){
        if(chh=='-') www=-1;
        chh=getchar();
    }
    while(chh>='0'&&chh<='9'){
        sss=sss*10+chh-'0';
        chh=getchar();
    }
    return sss*www;
}
int n,m;
int edge[505][505];//邻接矩阵存边权
int lx[505],ly[505];//左部点和有部点的顶标 
int matched[505],delta;//delta是针对所有点的 
bool visx[505],visy[505];//左部点以及右部点的遍历标记
bool find(int now){
    visx[now]=true;//标记左部点已经进行了增广路的寻找操作
    for(register int i=1;i<=n;i++){//枚举所有右部点
        if(!visy[i]){//如果此右部点还没有被匹配
        //以前的已经被匹配的不能被修改，否则就不是最大权匹配了
            if(lx[now]+ly[i]==edge[now][i]){//这条边为相等边
                visy[i]=true;//标记找到了匹配
                if(!matched[i]||find(matched[i])){//进行增广路的寻找
                    matched[i]=now;
                    return true;
                }
            }
            else delta=min(delta,lx[now]+ly[i]-edge[now][i]);//更新delta，注意要取min
        }
    }
    return false;
}
int KM(){
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=n;j++){
			lx[i]=max(lx[i],edge[i][j]);//初始化顶标左部点顶标最大
			//至于为什么只需要初始化左部点，参考https://www.cnblogs.com/wenruo/p/5264235.html的图文解析，便于理解
		}
	}
    for(register int i=1;i<=n;i++){
        while(true){
        //在找到这个点的最大权匹配的过程中
        //我们在delta尽量小的前提下（为了找到最大权匹配）
        //不断尝试寻找可行的最大权匹配
            memset(visx,0,sizeof(visx));
            memset(visy,0,sizeof(visy));
            delta=1e18;//初始化delta最大，方便找增广路时取min
            if(find(i)) break;//找到增广路立即退出
            for(register int j=1;j<=n;j++){
                if(visx[j]) lx[j]-=delta;//提供新的增广路 
                if(visy[j]) ly[j]+=delta;
            }
        }
    }
    int ans=0;//统计完美匹配的权值和
    for(register int i=1;i<=n;i++){
        ans+=edge[matched[i]][i];
    }
    return ans;
}
signed main(){
    n=read(),m=read();
    memset(edge,-0x3f,sizeof edge);//题目中有负边权，所以初始所有边权负无穷
    int u,v,w;
    for(register int i=1;i<=m;i++){
        u=read(),v=read(),w=read();
        edge[u][v]=max(edge[u][v],w);
    }
    printf("%lld\n",KM());
    for(register int i=1;i<=n;i++){
        printf("%lld ",matched[i]);
    }
    return 0;
}
```
在上面的代码中，$delta$ 表示该节点增广所需的边中，$lx_i+ly_j-edge_{i,j}$ 的最小值，然后我们枚举左部点以及右部点，进行修改。

对于修改代码：

```cpp
for(register int j=1;j<=n;j++){
	if(visx[j]) lx[j]-=delta;//提供新的增广路 
	if(visy[j]) ly[j]+=delta;
}
```
可以参考 [KM 算法模拟](https://www.cnblogs.com/wenruo/p/5264235.html) 进行理解。

上述算法是 KM 算法的 DFS 版本，时间复杂度可以达到 $O(n^4)$。

具体分析，一个点寻找最大匹配，$delta$ 可能会被更新 $n$ 次才能找到最大权匹配，而匈牙利算法寻找增广路时间复杂度是 $O(n^2)$ 的，所以总时间复杂度可以达到 $O(n^4)$。

那我们应该如何去优化？

我们发现，在每个点寻找增广路的过程中，我们每个点都要重新从起点开始进行增广过程，这个过程是非常耗时间的。所以我们考虑利用一个数组 $pre$ 记录**每次扩大子图**后扩大的相等边，下次直接从这里开始进行增广。

这样，我们一共会扩大相等子图 $n$ 次，每次匈牙利算法增广的时间复杂度为 $O(n^2)$，那么现在的时间复杂度就降低为了 $O(n^3)$。

我们可以考虑用队列进行 BFS，但题解区第二位大佬 [George1123](https://www.luogu.com.cn/user/118365#main) 提供的迭代方法让我大开眼界（主要是代码量短）。

迭代写法的思路其实与 DFS 有一些不同，可能理解起来需要一些时间（一定要先把 DFS 写法搞懂再看迭代版本！）。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sss=0,www=1;
	char chh=getchar();
	while(chh<'0'||chh>'9'){
		if(chh=='-') www=-1;
		chh=getchar();
	}
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss*www;
}
int n,m;
long long edge[505][505];
int matched[505];//记录右部点所匹配的左部点 
int visy[505];
int lx[505],ly[505];//lx表示左部点的顶标，ly表示右部点的顶标 
int pre[505];
long long slack[505];
void bfs(int want_match){
    int now,new_match=0;
	int x=0;//0点初始化 
    memset(pre,0,sizeof pre);//重新建立交错树（因为每一次要重新找增广路） 
    memset(slack,0x3f,sizeof slack);//初始化松弛量 
    matched[x]=want_match;//初始化0点匹配到了u这个左部点 
    do {
        now=matched[x];//找到当前寻找匹配的左部点 
		long long delta=1e18;//delta记录寻找的增广路路径的松弛量 
		visy[x]=true;
		//标记本轮已经在这个点找过增广路，和匈牙利算法中vis数组同理 
        for(register int i=1;i<=n;i++){//枚举右部点 
        	if(!visy[i]){//找到了一个还没有尝试找增广路的右部点 
            	if(slack[i]>lx[now]+ly[i]-edge[now][i]){
					//找到了一个匹配点
					//可以通过https://www.cnblogs.com/wenruo/p/5264235.html加深理解 
					//优化DFS进行的find操作 
	            	slack[i]=lx[now]+ly[i]-edge[now][i];
					pre[i]=x;//记录交错树(BFS对DFS的优化) 
				}
	            if(slack[i]<delta){
	        		delta=slack[i];//更新delta 
					new_match=i;
				}
	        }
		}
        for(register int i=0;i<=n;i++){//因为初始化的是0，所以说必须从0开始修改顶标 
        	if(visy[i]){
        		lx[matched[i]]-=delta;//i点匹配到的左部点的顶标减去delta 
				ly[i]+=delta;//i点的顶标加上delta
				//和DFS版本同理 
			}
            else slack[i]-=delta;//进行松弛操作 
		}
        x=new_match;//下一个访问的左部点即刚才取出的右部点的匹配点
        //此处x指代找到的右部点 
    } while(matched[x]);
    while(x) matched[x]=matched[pre[x]],x=pre[x];//交错树还原操作 
}
long long KM(){
    memset(matched,0,sizeof matched);
    memset(lx,0,sizeof lx);
    memset(ly,0,sizeof ly);
    for(register int i=1;i<=n;i++){
    	memset(visy,0,sizeof visy);//每次重新进行增广 
		bfs(i);
	}
	long long ans=0;
	for(register int i=1;i<=n;i++)
		ans+=(long long)edge[matched[i]][i];//正常的统计答案 
	return ans;
}
int main(){
	n=read(),m=read();
	memset(edge,-0x3f,sizeof edge);//赋初值为负无穷，因为题目边权有负数 
	for(register int i=1;i<=m;i++){
		int u=read(),v=read(),w=read();
		edge[u][v]=max(edge[u][v],(long long)w);
	}
	printf("%lld\n",KM());
	for(register int i=1;i<=n;i++) 
		printf("%d ",matched[i]);
	return 0;
}
```

---

## 作者：Jordan_Pan (赞：1)

# 匈牙利算法

题意：求最大权完美匹配和方案。

## Part 0

Kuhn-Munkres 算法，即 KM 算法、匈牙利算法，可以解决此~~毒瘤~~题。

您做到了这道紫题，因此我假定您已经知道了[二分图](https://oi-wiki.org/graph/bi-graph/)，[图的匹配](https://oi-wiki.org/graph/graph-matching/graph-match/)，以及[二分图完美匹配](https://oi-wiki.org/graph/graph-matching/graph-match/#完美匹配)的定义。

标准的解法参见 [OI-wiki](https://oi-wiki.org/graph/graph-matching/bigraph-weight-match/)。

如果您~~和我一样~~既没看懂 OI-wiki，也没看懂其他题解，欢迎您欣赏~~我的大作~~。

## Part 1
###### dfs 大法好！
直接暴搜，获得 $9pts$ 的高分。
## Part 2
###### 蒟蒻初学网络流
新建一个源点和一个汇点，源点向所有左部点连一条流量为 $1$，费用为 $0$ 的边，每个右部点向汇点连一条流量为 $1$，费用为 $0$ 的边，每条题目给的边连一条流量为 $1$，费用为 $-w$ 的边。

EK+SPFA 跑最小费用最大流，获得 $46pts$ 的高分。

其他题解甚至把这种方法优化到了可以通过此题，但是 wtcl，并不会优化的方法。
## Part 3
###### 初步尝试，不想看请跳过
先列出定义：

**可行顶标**：给每个结点 $i$ 分配一个权值 $l_i$，对于所有边 $(x,y)$，满足 $w(x,y)\le l_x+l_y$。

什么意思呢？

每条边的边权都要小于它的两个端点的顶标之和。

我们发现，如果把右部点的顶标设为 $0$，左部点的顶标设为与它相接的所有边的最大权值，刚好可以满足需要。

**相等子图**：在一组可行顶标下原图的生成子图，包含所有点但只包含满足 $w(x,y)=l_x+l_y$ 的边  $(x,y)$。

接下来是一个~~高深的~~定理：

**对于某组可行顶标，如果其相等子图存在完美匹配，那么该匹配就是原二分图的最大权完美匹配。**

**证明**：根据定义，相等子图的完美匹配覆盖了所有点，其完美匹配就是所有点的顶标和。同时，每条边的边权都要小于它的两个端点的顶标之和，所以该匹配就是最大权完美匹配。

那么，我们的目标就是不断调整可行顶标，使得相等子图的边变多，成为完美匹配。

我们现在有了一个相等子图，如何往里加边呢？

**增广路**：始于非匹配点且终于非匹配点（除了起始的点）的由匹配边与非匹配边交错而成的路径。

翻译成人话，就是：

增广路上非匹配边比匹配边的数量多一。我们把增广路上的非匹配边和匹配边反转，就可以把增广路两端的非匹配点纳入匹配点，同时匹配边数量加一。

这个过程就叫**增广**。

请看[增广路定理](https://oi-wiki.org/graph/graph-matching/augment/)。

于是，我们的思路就是：从左部的一个非匹配点出发，不断找增广路进行增广，直到出现完美匹配。

但是，如果一直找不到增广路，最后就会扩展出一棵**匈牙利树**，又叫交错树。

我们把匈牙利树中在左部的点集称为 $S$，在右部的点集称为 $T$，其余部分分别称为 $S'$，$T'$。

我们发现，此时 $S$ 到 $T'$、$S'$ 到 $T$ 没有匹配边（一个点只能匹配一条边），$S$ 到 $T'$ 没有非匹配边（否则可以纳入匈牙利树）。或者说，$S'$ 到 $T$ 没有边，$S'$ 到 $T$ 只有非匹配边。

我们希望给 $S$ 中所有点的顶标减去 $a$，$T$ 中所有点的顶标加上 $a$，使得原图中没有边退出的同时，$S$ 到 $T'$ 有新边加入相等子图。这里 $a$ 应取 $\min\{l_x+l_y-w(x,y)|x\in S,y\in T'\}$，这样刚好使 $(x,y)$ 这条边加入子图。

（~~怎么样，很清晰吧~~ 自行画图理解一下）

## Part 4
###### 我知道您懒得画图
有了理论，让我们模拟一下吧！~~（图有亿点丑）~~如果您有哪一步不理解，请回看**Part 3**部分。

![1](https://cdn.luogu.com.cn/upload/image_hosting/14heaurb.png)

首先，初始化结点顶标：把右部点的顶标设为 $0$，左部点的顶标设为与它相接的所有边的最大权值。

$l_1=6,l_2=5,l_3=5,l_4=3,$

$l_5=0,l_6=0,l_7=0,l_8=0$

生成相等子图并求出它的最大匹配：

![2](https://cdn.luogu.com.cn/upload/image_hosting/13qdc38g.png)

发现左部点中 $4$ 还未匹配，从 $4$ 号点开始，沿匹配边-非匹配边-···的交替路线扩展出匈牙利树：

![3](https://cdn.luogu.com.cn/upload/image_hosting/8oz09ldt.png)

得到 $S=\{3,4\}$，$S'=\{1,2\}$；$T=\{8\}$，$T'=\{5,6,7\}$：

![4](https://cdn.luogu.com.cn/upload/image_hosting/hr28jt0x.png)

接下来，我们要重复以下操作：

再看原图，找到 $a=min\{l_x+l_y-w(x,y)|x\in S,y\in T'\}=1$ 并修改顶标：

$l_1=6,l_2=5,l_3=4,l_4=2,$

$l_5=0,l_6=0,l_7=0,l_8=1$

此时 $(3,7)$ 加入子图。

我们遇到了第一种情况：$7$ 号点已经匹配，于是我们把 $7$ 号点加入 $T$，把与它匹配的 $2$ 号点加入 $S$。

![5](https://cdn.luogu.com.cn/upload/image_hosting/u9bgxjcd.png)

再看原图，找到 $a=min\{l_x+l_y-w(x,y)|x\in S,y\in T'\}=2$ 并修改顶标：

$l_1=6,l_2=3,l_3=2,l_4=0,$

$l_5=0,l_6=0,l_7=2,l_8=3$

此时 $(2,6)$ 加入子图。

![6](https://cdn.luogu.com.cn/upload/image_hosting/g97cubbz.png)

我们遇到了第二种情况：$6$ 号点未匹配，于是我们找到了一条增广路 $4-8-3-7-2-6$，对它增广：

![7](https://cdn.luogu.com.cn/upload/image_hosting/22t0c3d2.png)

相等子图出现完美匹配，算法结束。答案即为 $16$。

~~这份图解清晰易懂，连我这个超级大蒟蒻都看懂了！~~

## Part 5
###### 上代码
让我们来分析一下复杂度。

每次修改顶标都要遍历左部点和右部点，找到 $a$ 的值又需要遍历左部点和右部点，总共是 $O(n^4)$。然而，$n\le500$，~~成功T飞~~。

优化的方法是，定义**松弛量** $slack_y=\min\{l_x+l_y-w(x,y)\}$，于是 $a$ 的计算就优化为 $a=\min\{slack_y|y\in T'\}$。

$slack_y$ 的更新方法是，如果 $y$ 在 $T'$ 中，就把 $slack_y$ 减去 $a$（因为 $S$ 中的点的顶标都减掉了 $a$，而加入的边只可能在 $S$ 和 $T'$ 之间）。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int _=505;
int n,m;
long long w[_][_];//邻接矩阵建图 
long long lx[_],ly[_];//顶标 
long long slack[_];//松弛量 
bool s[_],t[_];//S集和T集 
int match[_];//右部点的对应点 
void init(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			w[i][j]=-INT_MAX;//初始化矩阵 
	for(int i=1,x,y,h;i<=m;i++){
		scanf("%d%d%d",&x,&y,&h);
		w[x][y]=h;
	}//建图 
	for(int i=1;i<=n;i++){
		ly[i]=match[i]=0;
		lx[i]=-INT_MAX;
		for(int j=1;j<=n;j++)
			lx[i]=max(lx[i],w[i][j]);
	}//初始化顶标 
}
bool dfs(int i){
	s[i]=1;//加入匈牙利树 
	for(int j=1;j<=n;j++){
		if(t[j])continue;
		if(lx[i]+ly[j]==w[i][j]){
			t[j]=1;//加入匈牙利树 
			if(!match[j]||dfs(match[j])){
				//未匹配或可继续扩展 
				match[j]=i;//匹配 
				return 1;
			}
		}
		else
			slack[j]=min(slack[j],lx[i]+ly[j]-w[i][j]);
	}
	return 0;
}
void chg(){
	long long a=INT_MAX;
	for(int j=1;j<=n;j++)
		if(!t[j])
			a=min(a,slack[j]);
			//计算修改的值 
	for(int i=1;i<=n;i++){
		if(s[i])lx[i]-=a;
		if(t[i])ly[i]+=a;
		else slack[i]-=a;
		//修改松弛量 
	}//修改顶标 
}
void KM(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)
			slack[j]=INT_MAX; 
		while(1){
			for(int j=1;j<=n;j++)
				s[j]=t[j]=0;//初始化S,T
			if(dfs(i))break;
			else chg();
		}
	}
}
void print(){
	long long ans=0;
	for(int j=1;j<=n;j++)
		ans+=w[match[j]][j];
	printf("%lld\n",ans);
	for(int j=1;j<=n;j++)
		printf("%d ",match[j]);
}
int main(){
	init();
	KM();
	print();
	return 0;
}
```
然而，神奇的事情发生了！

![114514](
https://cdn.luogu.com.cn/upload/image_hosting/rsutnpvm.png)

神奇的数据把 $O(n^3)$ 卡到了 $O(n^4)$！
~~这份代码不辱使命，拿到了 $45pts$ 的高分！！！~~

## Part 6
###### 真正的 $O(n^3)$
我们发现，dfs 的过程中，很多边被重复遍历了很多次，大大降低了速度。

如果我们把 dfs 改成 bfs 呢？（借鉴了一下[Singercoder大佬](https://www.luogu.com.cn/user/239241)的代码部分。）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int _=505;
int n,m;
long long w[_][_];//邻接矩阵建图 
long long lx[_],ly[_];//顶标 
long long slack[_];//松弛量 
bool s[_],t[_];//S集和T集 
int match[_];//右部点的对应点 
int pre[_][2];//记录匈牙利树 
void init(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			w[i][j]=-1e12;//初始化矩阵 
	for(int i=1,x,y,h;i<=m;i++){
		scanf("%d%d%d",&x,&y,&h);
		w[x][y]=h;
	}//建图 
	for(int i=1;i<=n;i++){
		ly[i]=match[i]=0;
		lx[i]=-1e12;
		for(int j=1;j<=n;j++)
			lx[i]=max(lx[i],w[i][j]);
	}//初始化顶标 
}
void chg(int j){
	//0表示右对左，1表示左对右 
	while(j){
		int i=pre[pre[j][0]][1];
		pre[pre[j][0]][1]=j;
		match[j]=pre[j][0];
		j=i;
	}
}
void bfs(int b){
	for(int i=1;i<=n;i++){
		s[i]=t[i]=pre[i][0]=0;
		slack[i]=1e12;
	}
	queue<int>q;
	q.push(b);
	while(1){
		while(!q.empty()){
			int i=q.front();
			q.pop();
			s[i]=1;
			for(int j=1;j<=n;j++){
				if(t[j])continue;
				if(slack[j]>lx[i]+ly[j]-w[i][j]){
					slack[j]=lx[i]+ly[j]-w[i][j];
					pre[j][0]=i;//记录匈牙利树 
					if(!slack[j]){//可以加入子图 
						t[j]=0;//加入T集 
						if(!match[j]){
							//遇到未匹配点，必须增广！
							chg(j);
							return;
						} 
						else//已匹配，必须入队！ 
							q.push(match[j]);
					}
				}
			}
		}
		long long a=1e12;
		for(int j=1;j<=n;j++)
			if(!t[j])
				a=min(a,slack[j]);//计算修改值
		for(int i=1;i<=n;i++){
			if(s[i])lx[i]-=a;
			if(t[i])ly[i]+=a;
			else slack[i]-=a;
		}
		for(int j=1;j<=n;j++){
			if(t[j])continue;
			if(!slack[j]){
				t[j]=1;
				if(!match[j]){
					chg(j);
					return;
				}
				else q.push(match[j]);
			}
		}
	}
}
void KM(){
	for(int i=1;i<=n;i++)
		bfs(i);
}
void print(){
	long long ans=0;
	for(int j=1;j<=n;j++)
		ans+=w[match[j]][j];
	printf("%lld\n",ans);
	for(int j=1;j<=n;j++)
		printf("%d ",match[j]);
}
int main(){
	init();
	KM();
	print();
	return 0;
}
```

终于结束了！

## Part 7

THE END

---

## 作者：王大神——A001 (赞：1)

前置知识：

[匈牙利算法（`DFS` 和 `BFS`）](https://wdsa001.github.io/2021/12/25/er-fen-tu-pi-pei-dai-quan-wan-mei-pi-pei/#toc-heading-5)

## 二分图最大完美匹配
$KM$ 算法。

[传送门](https://www.luogu.com.cn/problem/P6577)

题目让我们找最大权值的完美匹配，注意是完美匹配的情况下，边权最大。

由于节点的数量非常少，所以可以直接开一个数组维护边权。开一个二维数组将边的初始信息存入。

每个节点进行匹配，将当前点加进来后，遍历整张图边的最大值，记录，接着次大值……直到没有增广路了结束。一路上节点要记录是从哪个节点增广来的，最后要换配（更新匹配的节点），因为最后还要输出匹配的编号。

### 代码思路

- 初始化，读入基本信息。

- 将每个节点进行匹配。

- 找到图上当前的最大边权。

- 根据最大边权，处理增广路。

- 去掉最大权值的边，继续找最大边权，重复上一步。

- 统计权值，输出。

### 代码

```cpp
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<queue>
#include<vector>
#include<stack>
using namespace std;
long long r_r(){//快读 
	long long k=0,f=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(isdigit(c)){
		k=(k<<1)+(k<<3)+(c^48);
		c=getchar(); 
	}
	return k*f;
}
const long long o_o=1e3+10;
const long long m_a=1e18;
long long n,m;
long long m_p[o_o][o_o];//建立点点之间的边权 
long long b_d[o_o];//存储匹配的编号 
long long s_s[o_o];//到节点的最小值 
long long p_r[o_o];//记录增广的节点（从那个点来的）
long long m_x[o_o];//匹配点集权值 
long long m_y[o_o];//被匹配点集权值 
bool b_b[o_o];//标记是否遍历过 
void f_i(long long u){
	//初始化 
    long long k_k=0;//记录当前处理的节点的编号 
	long long l_t=0;//记录最优路径的编号 
	long long x,m_i;//当前处理的节点，最小值 
    memset(p_r,0,sizeof(p_r));//初始化 
    for(long long i=1;i<=n;i++)s_s[i]=m_a;//初始化 
    b_d[0]=u;//从当前节点开始 
    
    while(1){
        x=b_d[k_k];//找到匹配的节点 
		m_i=m_a;//初始化最小值 
		b_b[k_k]=1;//标记 
        for(long long i=1;i<=n;i++){//枚举所有被匹配的节点 
            if(b_b[i])continue;//被标记过 
            if(s_s[i]>m_x[x]+m_y[i]-m_p[x][i]){//更新最小值	
            	//这里边的权值取的是相反数，所以权值越大，值越小 
            	
                s_s[i]=m_x[x]+m_y[i]-m_p[x][i];//更新最小值 
                p_r[i]=k_k;//记录来的点 
            }
            if(s_s[i]<m_i){
				m_i=s_s[i];//更新最小值 
				l_t=i;//记录编号 
			}
        }
        for(long long i=0;i<=n;i++){//枚举所有节点 
            if(b_b[i]){//标记过的节点 
            	m_x[b_d[i]]-=m_i;//匹配节点加上最大边权 
				m_y[i]+=m_i;//被匹配节点减去最大边权 
			}else s_s[i]-=m_i;//所有节点加上最大边权
			//加上最大边权，下次的边权一定小于等于这个边权，可以继续找次大边权 
        }
        k_k=l_t;//处理记录的编号最优边的增广路 
        if(b_d[k_k]==-1)break;//没有增广路，退出循环 
    }
    while(k_k){//回溯（换配）
		b_d[k_k]=b_d[p_r[k_k]];//更新匹配编号 
		k_k=p_r[k_k];//往回找 
	}
}
long long k_m(){
	//初始化 
    memset(b_d,-1,sizeof(b_d));//未匹配过的节点的值是 -1 
    memset(m_x,0,sizeof(m_x));
    memset(m_y,0,sizeof(m_y));
    
    for(long long i=1;i<=n;i++){
        memset(b_b,0,sizeof(b_b));//清空标记 
        f_i(i);//匹配 i 节点 
    }
    long long r_s=0;
    for(long long i=1;i<=n;i++)
        if(b_d[i]!=-1)r_s+=m_p[b_d[i]][i];//统计权值 
    return r_s;
}
int main(){	
	n=r_r(),m=r_r();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)m_p[i][j]=-m_a;//初始化 
    for(long long i=1;i<=m;i++){
        long long u=r_r(),v=r_r(),w=r_r();
        m_p[u][v]=w;//边赋权值 
    }
    printf("%lld\n",k_m());//计算最大权值 
    for(long long i=1;i<=n;i++)//输出匹配结果 
        printf("%lld ",b_d[i]);
    puts("");
    return 0;
}
```



---

## 作者：MoonCake2011 (赞：0)

摘自本作者的[网络流与二分图详解](https://www.luogu.com.cn/article/kw6klidj)。

# KM 算法

[正片开始](https://www.luogu.com.cn/problem/P6577)。

想用正常的费用流跑的人可以洗洗睡了，过不去。

KM 算法可以解决在有**完备匹配**下的二分图带权匹配。

完备匹配是二分图左右都是 $n$ 个点且最大匹配为 $n$ 个点的匹配。

我这里以编号 $1$ 到 $n$ 的为左部点，$n+1$ 到 $2n$ 为右部点。

## 顶点标记值

简称顶标 $l$，一个点的顶标满足对于所有边 $l_x+l_y\ge w(x,y)$。

## 相等子图

所有 $l_x+l_y=w(x,y)$ 的边所构成的子图。

定理：如果相等子图存在原图的完备匹配，那么这个完备匹配就是二分图带权最大匹配。

此完备匹配的权值和为 $\sum_{i=1}^{2n} l_i$。

因为 $l_x+l_y\ge w(x,y)$，所以这一定最优。

## 交错树

在匈牙利算法中，从一个节点寻找然后匹配失败所遍历的树被称为交错树。

交错树一定是匹配边和非匹配边交错的，故得名。

~~大杂居，小聚居，交错居住。（bushi~~

## KM 算法流程

假设最开始左部点的 $l$ 为与它相连的边的权值最大值，右部点 $l$ 为 $0$。

就是尝试不断扩大相等子图。

先看一下普通的匈牙利算法流程，是每个点挨个遍历，然后用 `dfs` 判断是否能配。

我们的配对的过程中尝试去修改顶标。

尝试将交错树上所有左部点的顶标减去一个值 $\Delta$，右部点加上 $\Delta$。

对于一条匹配边，按照上面的方法修改，它绝对还是一个在相等子图里的边。

对于一条非匹配边，它的左部点如果减少 $\Delta$，那么右部点可能不增加 $\Delta$，而右部点 增加 $\Delta$，左部点必须减少 $\Delta$（因为交错树是由左部点访问的匈牙利算法弄出来的）。

于是所有非匹配边 $l_x+l_y$ 一定减少，所以说相等子图大小增加。

$\Delta$ 可以在所有 $i$ 在交错树里，$j$ 不在交错树里的边 $(i,j)$ 的 $l_i+l_j-w(i,j)$ 最小值作为 $\Delta$。

这样就可以完美达成条件。

于是时间复杂度就是 $O(n^2m)$ 的了。

接着，一个优化，就是之前遍历过的交错树可以不遍历（遍历相等子图里的没用），于是加上这个时间复杂度 $O(n^3)$ 的，可以过题。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,e;
int head[1010],to[250010],val[250010],nxt[250010],tot;
inline void add(int u,int v,int w){
	to[++tot]=v,val[tot]=w;
	nxt[tot]=head[u];
	head[u]=tot;
}
int mat[1010];
bool vis[1010];
int l[1010],upd[1010],fa[1010];
inline bool dfs(int x,int f){
	vis[x]=1;
	for(int i=head[x];i;i=nxt[i])
		if(!vis[to[i]]){
			if(l[x]+l[to[i]]==val[i]){
				vis[to[i]]=1,fa[to[i]]=f;
				if(!mat[to[i]] || dfs(mat[to[i]],to[i])){
					mat[to[i]]=x;
					return 1;
				}
			}
			else if(upd[to[i]]>l[x]+l[to[i]]-val[i]) upd[to[i]]=l[x]+l[to[i]]-val[i],fa[to[i]]=f;
		}
	return 0;
}
inline int KM(){
	for(int i=1;i<=n;i++){
		l[i]=-1e15,l[i+n]=0;
		for(int j=head[i];j;j=nxt[j]) l[i]=max(l[i],val[j]);
	}
	for(int i=1;i<=n;i++){
		memset(vis,0,sizeof vis);
		memset(fa,0,sizeof fa);
		memset(upd,0x3f,sizeof upd);
		int p=0;mat[0]=i;
		while(mat[p]){
			int del=1e18;
			if(dfs(mat[p],p)) break;
			for(int j=n+1;j<=2*n;j++) if(!vis[j] && upd[j]<del) del=upd[j],p=j;
			for(int j=1;j<=n;j++) if(vis[j]) l[j]-=del;
			for(int j=n+1;j<=2*n;j++) if(vis[j]) l[j]+=del;else upd[j]-=del;
			vis[p]=1;
		}
		while(p){
			mat[p]=mat[fa[p]];
			p=fa[p];
		}
	}
	int ans=0;
	for(int i=n+1;i<=2*n;i++) for(int j=head[mat[i]];j;j=nxt[j]) if(to[j]==i) ans+=val[j];
	return ans;
}
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
	cin>>n>>e;
	for(int i=1;i<=e;i++){
		int u,v,w;
		cin>>u>>v>>w;
		add(u,v+n,w);
	}
	cout<<KM()<<"\n";
	for(int i=1;i<=n;i++) cout<<mat[n+i]<<" ";
	return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### KM 算法：

先给出一些**定义**：

- **顶标**：

  - 全称为**顶点标记值**。

  - 记左部点 $i$ 的**顶标**为 $lx_i$，右部点 $j$ 的**顶标**为 $ly_j$。

  - 若存在 $i \to j$ 这条边，那么**顶标**要满足 $lx_i+ly_j \ge w(i,j)$，其中 $w(i,j)$ 表示 $i \to j$ 的边权。

- **相等子图**：

  - 满足 $lx_i+ly_j=w(i,j)$ 的边构成的子图。

------

首先有一个**定理**：

- 若相等子图中存在**完美匹配**，则这个完美匹配就是二分图的**带权最大完美匹配**。

------

给出如下**证明**：

- 若相等子图存在**完美匹配**，那么此时的边权之和为：

$$\sum_{i=1}^n lx_i + ly_i$$

- 对于其它**非相等子图**的**完美匹配**，那么边权之和为：

$$\sum_{i=1}^n w(u_i,v_i)$$

- 又因为 $lx_{u_i}+ly_{v_i} \ge w(u_i,v_i)$，则必满足：

$$\sum_{i=1}^n lx_i + ly_i \ge \sum_{i=1}^n w(u_i,v_i)$$

-------

应用上述的定理，我们将问题转化为：

- 求一组**合适**的顶标，使得相等子图存在完美匹配。

如何求顶标是一个问题，考虑初始时：

- 令 $lx_i = \max\limits_{(i,x) \in E} w(i,x),ly_j=0$。

然后仿照找最大匹配的方法，即跑一遍匈牙利。

此时对于边 $i \to j$ 若不满足 $lx_i + ly_j = w(i,j)$，则该边不是相等子图里的边，就处于**封印**状态，不能走。

若当前左部点找到了匹配，则继续考虑下一个左部点；若未找到匹配则说明当前相等子图已经**无法找到**完美匹配，于是我们考虑**调整**顶标。

------

设当前没找到匹配的点为 $u$，注意到从 $u$ 开始走**交错路**可以到达部分的左部点。

将这些路径提出来可以得到一棵树，我们称之为**交错树**。

定义在交错树上的左/右部点分别为点集 $S,T$，不在交替树上的点集为 $S^′,T^′$。

交替树有这样两个**性质**：

- 一定没有 $S \to T^′$ 的边；不然交替树会**增长**或者找到**增广路**。

- $S^′ \to T$ 的边一定是**非匹配边**；否则该左部点将可以被 $u$ 走到，从而成为 $S$ 中的点。

-------

现在考虑**调整**操作：令 $S$ 中的顶标都减 $a$，$T$ 中的顶标都加 $a$。

此时会造成以下这些**效果**：

- 对于 $S \to T$ 的边：$lx_i - a + ly_j +a = lx_i + ly_j$，那么**不受影响**。

- 对于 $S^′ \to T^′$ 的边：点的顶标值**不变**。

- 对于 $S^′ \to T$ 的边：顶标和**增大**，可能会有边被移出相等子图。

- 对于 $S \to T^′$ 的边：顶标和**减少**，可能会有边加入相等子图。

现在我们需要找到一个**合适**的 $a$，需要使得我们做完这次操作后仍然对于**所有边**有 $lx_i + ly_j \ge w(i,j)$。

因为效果 $1,2,3$ 的每条边的顶标和都不会**下降**，则我们只需要考虑效果 $4$；注意到会使得原来顶标和由 $lx_i + ly_j$ 变为 $lx_i - a + ly_j$。

那么若要满足 $lx_i - a + ly_j \ge w(i,j)$，那么 $a$ 的值最小为 $lx_i + ly_j - w(i,j)$。

则 $a$ 的**最小取值**为：

$$\min\limits_{i \in S,j \in T^′,(i,j) \in E} lx_i + ly_j - w(i,j)$$

-----

还需要考虑有**新的边**加入，即有新的 $T^′$ 中的点加入：

- 如果其是**未匹配点**，则我们已经找到了一条**增广路**。

- 如果已经与 $S^′$ 中的点匹配了，那么交替树还可以经过此点**继续扩大**，我们继续重复刚才的过程即可。

可以发现，在最多 $n$ 次操作后，我们一定可以找到一个**未匹配点**，于是此时匹配完成，继续考虑下一个左部点即可。

跑匈牙利的时候还需要维护一个：

$$s_i = \min\limits_{i \in T^′,j \in S, (i,j) \in E} lx_i + ly_j - w(i,j)$$

最后求 $a$ 的时候找到 $T^′$ 中 $s$ 的**最小值**即可，不需要遍历所有边。

------

对于有**删边**的情况，不用考虑，因为不会影响到交替树。

-----

有 $n$ 个左部点，交替树最多增加到 $n$ 个点，每次匈牙利最多跑 $n^2$，总时间复杂度为 $O(N^4)$。

### `dfs` 代码：

```cpp
ll n,m,u,v,w,ans;
ll s[N],a[N],b[N],lx[N],ly[N];
bool fx[N],fy[N]; 
vector<pair<ll,ll>> E[N];
inline void add(ll u,ll v,ll w){
	E[u].push_back({v,w});
}
inline bool dfs(ll u){
	fx[u]=1;
	for(auto t:E[u]){
		ll v=t.first,w=t.second;
		if(!fy[v]){
			if(lx[u]+ly[v]==w){
				fy[v]=1;
				if(!a[v]||dfs(a[v])){
					ans-=b[v];
					a[v]=u,b[v]=w;
					ans+=b[v];
					return 1;
				}
			}
			else
			  s[v]=min(s[v],lx[u]+ly[v]-w);
		}
	}
	return 0;
}
inline void KM(){
	full(lx+1,lx+n+1,-INF);
	full(ly+1,ly+n+1,0);
	for(int u=1;u<=n;u++)
	  for(auto t:E[u])
	    lx[u]=max(lx[u],t.second);
	for(int i=1;i<=n;i++){
		while(1){
			full(fx+1,fx+n+1,0);
			full(fy+1,fy+n+1,0);
			full(s+1,s+n+1,INF);
			if(dfs(i))
			  break;
			ll a=INF;
			for(int j=1;j<=n;j++)
			  if(!fy[j])
			    a=min(a,s[j]);
			for(int j=1;j<=n;j++){
				if(fx[j])
				  lx[j]-=a;
				if(fy[j])
				  ly[j]+=a;
			}
		}
	}
}
```

-----

考虑优化。

因为每次会遍历大量**重复的信息**，不需要每次都跑匈牙利。

考虑 `bfs`，先令 $a_0 = u$，然后将 $0$ 加入队列，表示要将**队头的顶点**进行增广。

设 $x$ 为队头，找到其匹配的左部点 $u=a_x$，然后遍历所有与 $u$ 相连的点 $v$。

- 若 $s_v < lx_u + ly_v - w(u,v)$，则需要更新 $s_v$，然后需要**记录交替树**，即令 $fa_v = u$。

- 若 $s_v < a$，则更新 $a = s_v,id=v$。

先将顶标进行调整，然后需要令 $s_i \to s_i - a$。

再将 $id$ 加入队列，表示下一次从 $id$ 寻找增广路。

若最后的 $id$ 没有匹配的，那么利用 $fa$ 进行**回溯**，将匹配边与非匹配边**调换**一下即可。

因为队列中每个点至多加入一次，每个点最多要遍历其它所有点寻找 $id$，则总时间复杂度为 $O(N^3)$。

**注意需要先补成完全图。**

### `bfs` 代码：

```cpp
ll n,m,u,v,w,ans;
ll s[N],a[N],lx[N],ly[N],fa[N];
ll W[N][N];
bool f[N]; 
inline void bfs(ll h){
	ll x=0,u=0,id=0,t;
	a[x]=h;
	while(a[x]){
		f[x]=1;
		u=a[x];
		t=INF;
		for(int v=1;v<=n;v++){
			if(f[v])
			  continue;
			if(s[v]>lx[u]+ly[v]-W[u][v]){
				s[v]=lx[u]+ly[v]-W[u][v];
				fa[v]=x;
			}
			if(s[v]<t){
				t=s[v];
				id=v;
			}
		}
        for(int i=0;i<=n;i++){
        	if(f[i]){
        		lx[a[i]]-=t;
				ly[i]+=t;
			}
            else
			  s[i]-=t;
		}
		x=id;
	}
	while(x){
		a[x]=a[fa[x]];
		x=fa[x];
	}
}
inline void KM(){
	full(a+1,a+n+1,0);
	full(lx+1,lx+n+1,0);
	full(ly+1,ly+n+1,0);
	for(int i=1;i<=n;i++){
		full(f+1,f+n+1,0);
		full(fa+1,fa+n+1,0);
		full(s+1,s+n+1,INF);
		bfs(i);
	}
	for(int i=1;i<=n;i++)
	  ans+=W[a[i]][i];
}
int main(){
//	freopen("A.in","r",stdin);
//	freopen("A.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	  full(W[i]+1,W[i]+n+1,-INF);
	while(m--){
		u=read(),v=read(),w=read();
		W[u][v]=w;
	}
	KM();
	write(ans);
	putchar('\n');
	for(int i=1;i<=n;i++){
		write(a[i]);
		putchar(' ');
	}
	return 0;
}
```

---


# [APIO2013] 道路费用

## 题目描述

幸福国度可以用 $N$ 个城镇（用 $1$ 到 $N$ 编号）构成的集合来描述，这些城镇 最开始由 $M$ 条双向道路（用 $1$ 到 $M$ 编号）连接。城镇 $1$ 是中央城镇。保证一个人从城镇 $1$ 出发，经过这些道路，可以到达其他的任何一个城市。这些道路都是收费道路，道路 $i$ 的使用者必须向道路的主人支付 $c_i$ 分钱的费用。已知所有的这些 $c_i$ 是互不相等的。最近有 $K$ 条新道路建成，这些道路都属于亿万富豪 $\text{Mr. Greedy}$。$\text{Mr. Greedy}$ 可以决定每条新道路的费用（费用可以相同），并且他必须在明天宣布这些费用。

两周以后，幸福国度将举办一个盛况空前的嘉年华！大量的参与者将沿着这些道路前往中央城镇。共计 $p_j$ 个参与者将从城镇 $j$ 出发前往中央城镇。这些人只会沿着一个选出的道路集合前行，并且这些选出的道路将在这件事的前一天公布。根据一个古老的习俗，这些道路将由幸福国度中最有钱的人选出，也就是 $\text{Mr. Greedy}$。同样根据这个习俗，$\text{Mr. Greedy}$ 选出的这个道路集合必须使所有选出道路的费用之和最小，并且仍要保证任何人可以从城镇 $j$ 前往城镇 $1$（因此， 这些选出的道路来自将费用作为相应边边权的“最小生成树”）。如果有多个这样的道路集合，$\text{Mr. Greedy}$ 可以选其中的任何一个，只要满足费用和是最小的。

$\text{Mr. Greedy}$ 很明确地知道，他从 $K$ 条新道路中获得的收入不只是与费用有关。一条道路的收入等于所有经过这条路的人的花费之和。更准确地讲，如果 $p$ 个人经过道路 $i$，道路 $i$ 产生的收入为 $c_i \times p$ 的积。注意 $\text{Mr. Greedy}$ 只能从新道路收取费用，因为原来的道路都不属于他。

$\text{Mr. Greedy}$ 有一个阴谋。他计划通过操纵费用和道路的选择来最大化他的收入。他希望指定每条新道路的费用（将在明天公布），并且选择嘉年华用的道路（将在嘉年华的前一天公布），使得他在 $K$ 条新道路的收入最大。注意 $\text{Mr. Greedy}$ 仍然需要遵循选出花费之和最小的道路集合的习俗。

你是一个记者，你想揭露他的计划。为了做成这件事，你必须先写一个程序来确定 $\text{Mr. Greedy}$ 可以通过他的阴谋获取多少收入。

## 说明/提示

在样例中，$\text{Mr. Greedy}$ 应该将新道路 $(1,3)$ 的费用设置为 $5$ 分钱。在这个费用下，他可以选择道路 $(3,5),(1,2),(2,4),(1,3)$ 来最小化总费用，这个费用为 $14$。 从城镇 $3$ 出发的 $30$ 个人和从城镇 $5$ 出发的 $50$ 个人将经过新道路前往城镇 $1$，因此他可以获得为 $(30+50)×5=400$ 分钱的最好收入。

如果我们这样做，将新道路 $(1,3)$ 的费用设置为 $10$ 分钱。根据传统的限制，$\text{Mr. Greedy}$ 必须选择 $(3,5),(1,2),(2,4),(2,3)$，因为这是唯一费用最小的集合。 因此，在嘉年华的过程中道路 $(1,3)$ 将没有任何收入。


我们将使用以下 $5$ 类测例测试你的程序。

1. （国际 $16$ 分，国内 $15$ 分）$N ≤ 10,M ≤ 20,K = 1$；

2. （国际 $18$ 分，国内 $20$ 分）$N ≤ 30,M ≤ 50, K ≤ 10$；

3. （国际 $22$ 分，国内 $20$ 分）$N ≤ 10^3,M ≤ 5\times 10^3,K ≤ 10$;

4. （国际 $22$ 分，国内 $20$ 分）$N ≤ 10^5,M ≤ 3\times 10^5, K ≤ 15$；

5. （国际 $22$ 分，国内 $25$ 分）$N ≤ 10^5，M ≤ 3\times 10^5, K ≤ 20$。

**update: 2024/07/04 删除了两个测试点，并且改为捆绑。**

## 样例 #1

### 输入

```
5 5 1 
3 5 2 
1 2 3 
2 3 5 
2 4 4 
4 3 6 
1 3 
10 20 30 40 50```

### 输出

```
400```

# 题解

## 作者：UltiMadow (赞：10)

发现 $k$ 很小，只有 $20$，那么这题复杂度大概率和 $2^k$ 有关

考虑枚举加入新边的集合，如果直接跑最小生成树的话会 T，需要优化

容易发现每次最小生成树重复加入的边数会很多，于是可以考虑哪些边是一定会加入

我们先把 $k$ 条边全部加入，接下来跑一边最小生成树，原图上的边如果在这个最小生成树里那么就是一定会加入的边，设这个边集为 $\mathcal S$（由于题目条件里有边权互不相同，于是这个最小生成树唯一）

接下来把这些边组成的连通块缩成一个点，有 $k+1$ 个点，再用原图边跑一遍这 $k+1$ 个点上的最小生成树，得到的边集（设为 $\mathcal T$）即为可能出现在之后的最小生成树里的边

现在在枚举边集的时候跑的最小生成树只要在缩点后的图上把枚举的边集加入再用刚才得到的边集跑最小生成树就行了

接下来需要计算每个新边的边权最大值

对于一棵生成树 $\mathscr T$，和一个不在 $\mathscr T$ 上的边 $e$，如果把 $e$ 加到 $\mathscr T$ 上，那么一定会出现一个环。如果环上存在一条边的边权比 $e$ 的边权大，则 $\mathscr T$ 一定不是最小生成树

我们可以用这个性质来约束边权

对于 $\mathcal T$ 中的一条边 $e: u\to v$，它可以约束树上 $u\to v$ 路径上所有的边的边权都需要小于等于它的边权

于是这个可以用一个 lca 搞定，当然这里只有 $k+1$ 个点，所以暴力爬树就行

最后还要计算每条边有多少人通过，这个用一遍 dfs 求子树大小就可以求出来了

代码比较烦，但是细节还是比较少的 ~~（所以为什么我一个 `;` 写成 `,` 还能得 35pts 啊）~~

时间复杂度 $\mathcal O(m\log m+2^kk^2)$

code:
```cpp
#include<bits/stdc++.h>
#define MAXN 300010
#define MAXK 30
#define int long long
using namespace std;
int n,m,K,tot,a[MAXN];
struct Node{int fr,to,val;}e[MAXN],ne[MAXN],que[MAXN];
bool cmp(Node a,Node b){return a.val<b.val;}
int f[MAXN],g[MAXN];
int getf(int x){return f[x]==x?x:f[x]=getf(f[x]);}
int getg(int x){return g[x]==x?x:g[x]=getg(g[x]);}
int col[MAXN],cnt,val[MAXK];
void kruskal(){
	for(int i=1;i<=n;i++)f[i]=g[i]=i;
	sort(e+1,e+m+1,cmp);
	for(int i=1;i<=K;i++){
		int u=ne[i].fr,v=ne[i].to;
		int a=getf(u),b=getf(v);
		if(a==b)continue;
		f[a]=b;
	}
	for(int i=1;i<=m;i++){
		int u=e[i].fr,v=e[i].to;
		int a=getf(u),b=getf(v);
		if(a==b)continue;
		f[a]=b;
		a=getg(u),b=getg(v);
		if(a<b)swap(a,b);g[a]=b;
	}
	for(int i=1;i<=n;i++){
		if(getg(i)==i)col[i]=++cnt,val[cnt]=a[i];
		else col[i]=col[getg(i)],val[col[i]]+=a[i];
	}
	for(int i=1;i<=K;i++){
		int u=ne[i].fr,v=ne[i].to;
		ne[i]=(Node){col[u],col[v],0};
	}
	for(int i=1;i<=m;i++){
		int u=e[i].fr,v=e[i].to,w=e[i].val;
		int a=getg(u),b=getg(v);
		if(a==b)continue;
		que[++tot]=(Node){col[u],col[v],w};
		if(a<b)swap(a,b);g[a]=b;
	}
}
struct tnode{int to,nxt;}Edge[MAXK<<1];
int cnt_Edge,Head[MAXK];
void Add_Edge(int u,int v){
	Edge[++cnt_Edge]=(tnode){v,Head[u]};
	Head[u]=cnt_Edge;
}
int fa[MAXK],dep[MAXK],mn[MAXK],sz[MAXK];
void dfs(int u,int fat){
	fa[u]=fat;dep[u]=dep[fat]+1;sz[u]=val[u];
	for(int i=Head[u];i;i=Edge[i].nxt){
		int v=Edge[i].to;if(v==fat)continue;
		dfs(v,u);sz[u]+=sz[v];
	}
}
void update(int u,int v,int w){
	while(u!=v){
		if(dep[u]>dep[v])swap(u,v);
		mn[v]=min(mn[v],w);v=fa[v];
	}
}
signed main(){
	scanf("%lld%lld%lld",&n,&m,&K);
	for(int i=1;i<=m;i++){
		int u,v,w;scanf("%lld%lld%lld",&u,&v,&w);
		e[i]=(Node){u,v,w};
	}
	for(int i=1;i<=K;i++){
		int u,v;scanf("%lld%lld",&u,&v);
		ne[i]=(Node){u,v,0};
	}
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	kruskal();int ans=0,rt=col[1];
	for(int s=0;s<(1<<K);s++){
		memset(Head,0,sizeof(Head));cnt_Edge=0;
		memset(fa,0,sizeof(fa));memset(dep,0,sizeof(dep));
		memset(mn,0x3f,sizeof(mn));memset(sz,0,sizeof(sz));
		for(int i=1;i<=cnt;i++)f[i]=i;bool fl=false;
		for(int i=1;i<=K;i++){
			if(!((s>>(i-1))&1))continue;
			int u=ne[i].fr,v=ne[i].to;
			int a=getf(u),b=getf(v);
			if(a==b){fl=true;break;}
			f[a]=b;Add_Edge(u,v);Add_Edge(v,u);
		}if(fl)continue;
		for(int i=1;i<=tot;i++){
			int u=que[i].fr,v=que[i].to;
			int a=getf(u),b=getf(v);
			if(a==b)continue;
			f[a]=b;Add_Edge(u,v);Add_Edge(v,u);
		}dfs(rt,0);
		for(int i=1;i<=tot;i++){
			int u=que[i].fr,v=que[i].to,w=que[i].val;
			update(u,v,w);
		}int res=0;
		for(int i=1;i<=K;i++){
			if(!((s>>(i-1))&1))continue;
			int u=ne[i].fr,v=ne[i].to;
			if(dep[u]<dep[v])swap(u,v);
			res+=mn[u]*sz[u];
		}ans=max(ans,res);
	}printf("%lld",ans);
	return 0;
}
```

---

## 作者：lhm_ (赞：5)

不难想到可以$2^k$去枚举$k$条新边的选择方案，然后加入原图中的边来使图连通，用当前方案的收益去更新答案，但是这样复杂度过不去。

可以先把$k$条新边都连上，然后再加入边权从小到大排序过后的原图的边，直到图连通。后加入的原图的边在任何一个新边的选择方案都是要加入的，因为找这些边时是选了所有$k$条新边，其他方案只会比这时选择更少的新边，所以为保证连通，这些后加入的边肯定是要选择的，可能还要加入更多的原图中的边，同时这些边是按边权排序后的，所以也能满足题目中最小生成树的要求。

根据原图中边权互不相同，所以这些后加入的边的集合是唯一的。因为这些后加入的边是必选的，所以可以把只考虑这些边的连通块缩成点，发现缩点后的数量最多为$k+1$。

上面也说到，可能在一个新边的选择方案中，还需加入更多的原图中的边，这些边就是使这$k+1$个点连通的边，把这$k$条边记录下来，作为处理选择方案时的备选边。

然后就可以按之前的做法来处理了，$2^k$去枚举$k$条新边的选择方案，然后加入这$k$条备选边来使图连通，然后用当前方案的收益去更新答案。

具体实现加边判断连通性和缩点时用并查集比较方便。

总复杂度为$O(m \log m + 2^k k^2)$。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 3000010
#define inf 1000000000
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,m,k,root,cnt,tot;
ll ans,sum;
int id[maxn],fa[maxn],de[maxn];
ll p[maxn],pe[maxn],siz[maxn],mi[maxn];
bool flag;
struct edge
{
    int to,nxt;
}e[maxn];
int head[maxn],edge_cnt;
void add(int from,int to)
{
    e[++edge_cnt]=(edge){to,head[from]};
    head[from]=edge_cnt;
}
struct Edge
{
    int x,y,v;
}e1[maxn],e2[maxn],e3[maxn];
bool cmp(const Edge &a,const Edge &b)
{
    return a.v<b.v;
}
struct node
{
    int f[maxn];
    int find(int x)
    {
        return f[x]==x?x:f[x]=find(f[x]);
    }
    void merge(int x,int y)
    {
        x=find(x),y=find(y);
        if(x==y) return;
        f[x]=y;
    }
}A,B;
void dfs(int x,int fath)
{
    fa[x]=fath,de[x]=de[fath]+1,siz[x]=pe[x];
    for(int i=head[x];i;i=e[i].nxt)
    {
        int y=e[i].to;
        if(y==fath) continue;
        dfs(y,x),siz[x]+=siz[y];
    }
}
int main()
{
    read(n),read(m),read(k);
    for(int i=1;i<=n;++i) A.f[i]=B.f[i]=i;
    for(int i=1;i<=m;++i)
        read(e1[i].x),read(e1[i].y),read(e1[i].v);
    sort(e1+1,e1+m+1,cmp);
    for(int i=1;i<=k;++i)
        read(e2[i].x),read(e2[i].y);
    for(int i=1;i<=n;++i) read(p[i]);
    for(int i=1;i<=k;++i) A.merge(e2[i].x,e2[i].y);
    for(int i=1;i<=m;++i)
    {
        int x=e1[i].x,y=e1[i].y;
        if(A.find(x)==A.find(y)) continue;
        A.merge(x,y),B.merge(x,y);
    }
    for(int i=1;i<=n;++i)
        if(B.find(i)==i)
            id[i]=++tot;
    root=id[B.find(1)],A=B;
    for(int i=1;i<=n;++i) pe[id[B.find(i)]]+=p[i];
    for(int i=1;i<=m;++i)
    {
        int x=e1[i].x,y=e1[i].y;
        if(B.find(x)==B.find(y)) continue;
        B.merge(x,y),e3[++cnt]=e1[i];
    }
    for(int i=1;i<=k;++i) e2[i].x=id[A.find(e2[i].x)],e2[i].y=id[A.find(e2[i].y)];
    for(int i=1;i<=cnt;++i) e3[i].x=id[A.find(e3[i].x)],e3[i].y=id[A.find(e3[i].y)];
    for(int S=0;S<(1<<k);++S)
    {
        edge_cnt=sum=flag=0;
        for(int i=1;i<=tot;++i) A.f[i]=i,head[i]=0,mi[i]=inf;
        for(int i=1;i<=k;++i)
        {
            if(!(S&(1<<(i-1)))) continue;
            int x=e2[i].x,y=e2[i].y;
            if(A.find(x)==A.find(y))
            {
                flag=true;
                break;
            }
            A.merge(x,y),add(x,y),add(y,x);
        }
        if(flag) continue;
        for(int i=1;i<=cnt;++i)
        {
            int x=e3[i].x,y=e3[i].y;
            if(A.find(x)==A.find(y)) continue;
            A.merge(x,y),add(x,y),add(y,x);
        }
        dfs(root,0);
        for(int i=1;i<=cnt;++i)
        {
            int x=e3[i].x,y=e3[i].y;
            ll v=e3[i].v;
            while(x!=y)
            {
                if(de[x]<de[y]) swap(x,y);
                mi[x]=min(mi[x],v),x=fa[x];
            }
        }
        for(int i=1;i<=k;++i)
        {
            if(!(S&(1<<(i-1)))) continue;
            int x=e2[i].x,y=e2[i].y;
            if(de[x]<de[y]) swap(x,y);
            sum+=mi[x]*siz[x];
        }
        ans=max(ans,sum);
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：lgswdn_SA (赞：4)

考虑对于新边集最后在生成树上的的边集 $E$，我们可以把这 $|E|$ 条边加入生成树 $T$ 后再对旧边做 Kruskal，求出这种情况下的最小生成树的其他边。我们对于不在生成树上的边 $e\not\in T$，一定有 $T$ 上的路径 $(u,v)$ 上所有边的边权都 $\le w_e$。这样我们就能确定每一条 $\in E$ 的边的边权最大值。然后树形 DP 一下每条边会被多少人经过。这个算法是 $O(2^k nm)$ 的。

我们发现对于不同的 $E$，其 $T$ 很大一部分是一样的，还有一些旧边根本不会被用到。我们考虑在一开始的时候（$E=$ 所有新边的集合），计算出在这种情况下（用尽新边）哪些旧边是在 MST 内的。显然这些边无论 $E$ 是什么，都会包括在 MST 内，设这个集合为 $S_0$。我们将 $S_0$ 中的边进行缩成一个点。现在总共有 $k+1$ 个点。我们在缩点过后的旧边做一次 MST，会得到 $k$ 条边，设其为 $S_1$。容易证明，所点过后的图的旧边中只有 $S_1$ 中的边才可能成为 MST 上的边。所以我们将边数缩到了 $O(k)$。复杂度 $O(2^kk^2+m\log m)$。

代码比较烦。就不建议看我的丑陋的大常数的代码了（

```cpp
#include<bits/stdc++.h>
#define int long long
#define upm(a,b) a=min(a,b)
#define rep(i,a,b) for(register int i=(a);i<=(b);i++)
#define per(i,a,b) for(register int i=(a);i>=(b);i--)
using namespace std;
const int N=900009;

inline long long read() {
    register long long x=0, f=1; register char c=getchar();
    while(c<'0'||c>'9') {if(c=='-') f=-1; c=getchar();}
    while(c>='0'&&c<='9') {x=(x<<3)+(x<<1)+c-48,c=getchar();}
    return x*f;
}

int n,m,k,p[N],cnt,tcn,ans,tot,st;
bool t[N];

vector<int>pt,te[N];
void add(int u,int v) {te[u].push_back(v), te[v].push_back(u);}

struct edge {int u,v,w;} e[N],et[N],eg[N];
bool cmp(const edge &a,const edge &b) {return a.w<b.w;}

int id[N];
int find(int i) {return i==id[i]?i:id[i]=find(id[i]);}
void merge(int u,int v) {id[find(u)]=find(v);}

void kruskal() {
	rep(i,1,m) t[i]=0;
	sort(e+1,e+m+1,cmp);
	rep(i,1,m) {
		int u=find(e[i].u), v=find(e[i].v);
		t[i]=(u!=v), merge(u,v);
	}
}

int f[N],d[N],fa[N],sum[N],fae[N],mx[N];
void dfs(int u,int faa) {
	sum[u]=p[u], fa[u]=faa, d[u]=d[faa]+1;
	for(auto v:te[u]) if(v!=faa) {
		dfs(v,u);
		sum[u]+=sum[v];
	}
}
void upd(int u,int v,int w) {
	if(d[u]<d[v]) swap(u,v);
	while(d[u]>d[v]) upm(mx[fae[u]],w), u=fa[u];
	while(u!=v) upm(mx[fae[u]],w), upm(mx[fae[v]],w), u=fa[u], v=fa[v];
}

signed main() {
	n=read(), m=read(), k=read();
	rep(i,1,m) {
		int u=read(), v=read(), w=read();
		e[i]=(edge){u,v,w};
	}
	rep(i,1,k) e[m+i].u=read(), e[m+i].v=read();
	rep(i,1,n) p[i]=read(), id[i]=i;
	rep(i,m+1,m+k) merge(e[i].u,e[i].v);
	kruskal();
	
	rep(i,1,n) id[i]=i;
	rep(i,1,m) if(t[i]) merge(e[i].u,e[i].v);
	rep(i,1,n) {
		if(find(i)==i) pt.push_back(i);
		else p[id[i]]+=p[i];
	}
	st=find(1);
	rep(i,1,m+k) e[i].u=find(e[i].u), e[i].v=find(e[i].v);
	kruskal();
	rep(i,1,m) if(t[i]) eg[++tot]=(edge){e[i].u,e[i].v,e[i].w};
	rep(i,1,tot) e[i]=eg[i];
	rep(i,1,k) e[i+tot]=e[i+m];
	m=tot;
	
	rep(s,0,(1<<k)-1) {
		for(auto i:pt) id[i]=i, te[i].clear();
		rep(i,1,k) if((1<<i-1)&s) merge(e[i+m].u,e[i+m].v);
		kruskal();
		rep(i,1,k) {
			if((1<<i-1)&s) add(e[i+m].u,e[i+m].v), t[i+m]=1;
			else t[i+m]=0;
		}
		int ecnt=0;
		rep(i,1,m+k) ecnt+=t[i];
		if(ecnt>pt.size()-1) continue;
		rep(i,1,m) if(t[i]) add(e[i].u,e[i].v);
		dfs(st,0);
		rep(i,1,m+k) if(t[i]) {
			int u=e[i].u, v=e[i].v;
			if(fa[u]==v) fae[u]=i;
			else fae[v]=i;
			mx[i]=(i<=m?0:1000000000);
		}
		int res=0;
		rep(i,1,m) if(!t[i]) upd(e[i].u,e[i].v,e[i].w);
		rep(i,m+1,m+k) if(t[i]) res+=(sum[fa[e[i].u]==e[i].v?e[i].u:e[i].v])*mx[i];
		ans=max(ans,res);
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：CYZZ (赞：3)

# [P3639](https://www.luogu.com.cn/problem/P3639)
不知道教练为啥把这题放在缩点专题里，明明是很好的最小生成树练习题。
## 题意
有一个 $m$ 条原边和 $k$ 条新边组成的图，你可以自定义 $k$ 条新边的权值。使得该图的最小生成树中，新边产生的贡献最大，求出这个最大的贡献。
## 思路
直接计算新边的初始权值显然不好做，考虑枚举选出的新边，然后计算最大贡献。

如果每次直接跑最小生成树，时间复杂度至少 $\mathcal{O(2^km\log m)}$，考虑优化。

注意到，每次求最小生成树都会加入一个固定的边集 $E$。考虑求出 $E$，避免重复加入。

先把 $k$ 条新边加入并查集，然后用原图跑 kruskal 直到图联通。再把所有的新边删除，得到刚好 $k+1$ 个连通块，这就是边集 $E$。（证明：如果 $E$ 中的某条边 $u$ 不在最终的最小生成树中，那么它一定会被另一条原边 $v$ 替代，那么在刚刚的生成树中也可以用 $v$ 替代 $u$，所以矛盾。）

然后我们就可以把 $k+1$ 个连通块缩成 $k+1$ 个点，再用原图跑 kruskal 求出最小生成树 $E'$。此时只有 $E'$ 里的 $k$ 条边和 $k$ 条新边可以组成最终的最小生成树。

这样我们就可以把边的数量降为 $2\times k$ 个，时间复杂度降为 $\mathcal{O(2^kk\log k)}$，可以通过。

现在我们考虑如何计算新边的边权，可以利用最小生成树的一个性质：

> 对于每个不在最小生成树上的边 $(u,v)$，满足生成树中 $u\rightarrow v$ 上的每一条边的边权小于 $(u,v)$ 的边权。

我们可以用每一条不在生成树上的原边约束新边的权值，由于 $k$ 很小，直接暴力跳祖先即可。

代码比较长，但是结构清晰。
## 代码
[代码在这里](https://www.luogu.com.cn/paste/0pcazwxw)

由于本人太菜了，所以有表达~~特别~~不严谨的地方欢迎指出。

---

## 作者：xyc1719 (赞：2)

[安利一下自己csdn的博客](https://blog.csdn.net/xyc1719)

大意是说，调整k条特殊边边的值，并在原图的基础上构建最小生成树。使得经过所有特殊边的值之和最大。

感谢dasxxx学长指出题目要素(加上新边，两点之间最多只有一条边)，请各位在理解下文解法时特别注意，如果没有这一要求是不能设计如下算法的。在此安利一下[HGEEK首席程序员的博客](https://www.hgeek.cn/dasxxx/)。

**大致解法：**
先缩点。可以知道，对答案有贡献的只有k条新边。先将k条边进行最小生成树，再构建一棵完成的最小生成树。
除去那些新边会产生k+1个连通块，而这连通块中的边的连接方法对答案是没有贡献的，起到主要贡献的是连接这些连通块的新边。当然也会有k条原边可以替代它们。

先进行暴力枚举k条边的选或者不选，总共$2^k $种状态。用选定的新边将连通块相连，不足的部分用原边代替。那么在这棵树中主要是求到每个点的人数和所有新边的最大值。每点人数用树上前缀和即可；求新边最值需要借用kruskal的思想，即在树上从u到v的路径中的所有边权必须小于等于新加进的边，不然就可以用新边代替之，如此约束每条新边的值即可。

code:
```cpp
#include<bits/stdc++.h>
typedef long long ll;
const int INF=1<<30;
using namespace std;
ll ans;
int n,m,K,top,cnt,st;
int fa[100005],fa2[100005],p[100005];
struct edgege{
	int u,v,w;
}e[300005],ne[25],q[300005];
struct data{
	int v,nxt;
}edge[50];
int ag[25],dep[100005],head[100005],mn[100005];
ll val[100005],sum[100005];
bool mark[300005];
void insert(int u,int v)
{
	edge[++cnt]=(data){v,head[u]};head[u]=cnt;
	edge[++cnt]=(data){u,head[v]};head[v]=cnt;
}
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
int find2(int x){return x==fa2[x]?x:fa2[x]=find2(fa2[x]);}
bool operator<(edgege a,edgege b){return a.w<b.w;}
void dp(int x)
{
	sum[x]=val[x];
	for(int i=head[x];i;i=edge[i].nxt)
		if(edge[i].v!=fa2[x])
		{
			dep[edge[i].v]=dep[x]+1;
			fa2[edge[i].v]=x;
			dp(edge[i].v);
			sum[x]+=sum[edge[i].v];
		}
}
void solve()
{
	cnt=0;
	for(int i=1;i<=K+1;i++)
	{
		int p=ag[i];
		head[p]=fa2[p]=0;
		fa[p]=p;mn[p]=INF;
	}
	for(int i=1;i<=K;i++)
		if(mark[i])
		{
			int x=find(ne[i].u),y=find(ne[i].v);
			if(x==y)return;
			fa[x]=y;
			insert(ne[i].u,ne[i].v);
        }//将新边加入MST 
	for(int i=1;i<=K;i++)
	{
		int x=find(q[i].u),y=find(q[i].v);
		if(x!=y)fa[x]=y,insert(q[i].u,q[i].v);
	}//构建完整的MST 
	dp(st);//树上前缀和(人数)
	for(int i=1;i<=K;i++)
	{
		int u=q[i].u,v=q[i].v;
		if(dep[u]>dep[v])swap(u,v);
		while(dep[v]>dep[u])mn[v]=min(mn[v],q[i].w),v=fa2[v];
		while(u!=v)
		{
            mn[v]=min(mn[v],q[i].w);
            mn[u]=min(mn[u],q[i].w);
            u=fa2[u];v=fa2[v];
        }
	}//退化版lca 
	ll res=0;
	for(int i=1;i<=K;i++)
		if(mark[i])
		{
			int u=ne[i].u,v=ne[i].v;
			if(dep[u]>dep[v])swap(u,v);
			res+=mn[v]*sum[v];
		}
	ans=max(res,ans);
}
void dfs(int x)
{//选边的状态枚举 
	if(x>K)
	{
		solve();return;
	}
	mark[x]=0;dfs(x+1);
	mark[x]=1;dfs(x+1);
}
int main()
{
	scanf("%d%d%d",&n,&m,&K);
	for(int i=1;i<=m;i++)
		scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
	sort(e+1,e+m+1);
	for(int i=1;i<=K;i++)
		scanf("%d%d",&ne[i].u,&ne[i].v);
	for(int i=1;i<=n;i++)
		scanf("%d",&p[i]);
	for(int i=1;i<=n;i++)
		fa[i]=fa2[i]=i;
    for(int i=1;i<=K;i++)
		fa[find(ne[i].u)]=find(ne[i].v);//新边的缩点 
	for(int i=1;i<=m;i++)
	{
		int u=e[i].u,v=e[i].v;
		if(find(u)!=find(v))//一定会借助其他边连接的两点 
		{
			fa[find(u)]=fa[find(v)];
			fa2[find2(u)]=fa2[find2(v)];
		}
	}
	//这里find合并成了一棵树
	//find2是K+1块 
	st=find2(1);//初始1所在集合 
	for(int i=1;i<=n;i++)
	{
		val[find2(i)]+=p[i];//每块的人数 
		if(find2(i)==i)ag[++ag[0]]=i;//每个缩点(集合)的编号
	}
	for(int i=1;i<=K;i++)
		ne[i].u=find2(ne[i].u),ne[i].v=find2(ne[i].v); 
	for(int i=1;i<=m;i++)
		e[i].u=find2(e[i].u),e[i].v=find2(e[i].v);
	//重构边，负责连块 
	for(int i=1;i<=m;i++)
	{
		int p=find2(e[i].u),q=find2(e[i].v);
		if(p!=q)mark[i]=1,fa2[p]=q;
	}
	for(int i=1;i<=m;i++)
		if(mark[i])q[++top]=e[i];//取那些有用的边
	memset(mark,0,sizeof(mark));
	dfs(1);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：xyc1719 (赞：2)

**来源：钱桥_toll.pptx**

算法一：向最小生成树中逐一加边，替换原路径上权值最大的边。当k>1时，不能保证正确性！举例：

![钱桥toll](https://cdn.luogu.com.cn/upload/pic/32387.png)

时间复杂度：O(k*m)
期望的分：15分~？
___

算法二：暴力枚举使用哪些边，让选中的边尽可能大

共2k种情况，对于每一种情况：
        Step 1：构造最终的最小生成树，优先使用选中的边
        Step2：确定选中边的权值——经过它的最小值

时间复杂度O(m*logm + 2k*m*k)
期望的分：35分
___
算法三：先缩点，再通过算法二处理

选中的边为0~20条，Step 1中构造的最小生成树有n-1条。
结论：有很多点是一定“粘”在一起的。怎样缩点？

初始化构造最小生成树，其中，优先使用k条边。
形成的k+1个连通块可分别缩为一个点。

初始化构造最小生成树（优先使用k条边）
形成的k+1个连通块可分别缩为一个点

再求这k+1个点的最小生成树，（不使用k条边）
得到k+1个点，k条边的一张图

通过算法二求解这张图
时间复杂度：O(m*logm + 2k*k2)
期望得分：90~100分 （数据为阶梯分布）

___
95分代码：
```cpp
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 101010, M = 301010, K = 22;

int n, m, k, cn = 0;
long long ans = 0, maxL, ssize;
int cost[N], father[N], color[N];
long long size[N] = {0};

long long get_max(long long a, long long b)
{
    if (a > b) return a; else return b;
}
long long get_min(long long a, long long b)
{
    if (a < b) return a; else return b;
}

class Road
{
public :
    int x, y, w, flag, ans;
    Road (int x, int y, int w = 0, int flag = 0) 
        : x(x), y(y), w(w), flag(flag) {}
};

Road * road[M], 
     * road_sp[K];

class Node;

class Edge
{
public :
    Node * target;
    Edge * next;
    int flag;
    /*Edge(Node * target, Edge * next, int flag) :
        target(target), next(next), flag(flag) {};
    ~Edge()
    {
        if (next) delete next;
    }*/
};

class Node
{
public :
    Edge * head;
    Node * father;
    long long size, deep, flag;
    /*
    Node (long long size) :
        size(size), head(0), father(0), deep(0), flag(0) {}
    ~Node()
    {
        if (head) delete head;
    }
    */
};

Node * node[K];

Node * my_node[1010]; int my_node_count;
Edge * my_edge[1010]; int my_edge_count;

Node * get_node(long long size)
{
    Node * now = my_node[my_node_count ++];
    now->size = size;
    now->head = 0;
    now->father = 0;
    now->deep = 0;
    now->flag = 0;
    return now;
}

Edge * get_edge(Node * target, Edge * next, int flag)
{
    Edge * now = my_edge[my_edge_count ++];
    now->target = target;
    now->next = next;
    now->flag = flag;
    return now;
}

void newedge(Node * x, Node * y, int flag)
{
    Edge * e1 = get_edge(y, x->head, flag),
         * e2 = get_edge(x, y->head, flag);
    x->head = e1; y->head = e2;
}

bool cmp_w(const Road * a, const Road * b)
    {return a->w < b->w;}

void init()
{
    for (int i=0; i<1010; i++)
    {
        my_edge[i] = new Edge();
        my_node[i] = new Node();
    }
    scanf("%d%d%d", &n, &m, &k);
    int x, y, w;
    for (int i=0; i<m; i++)
    {
        scanf("%d%d%d", &x, &y, &w);
        road[i] = new Road(x, y, w);
    }
    for (int i=0; i<k; i++)
    {
        scanf("%d%d", &x, &y);
        road_sp[i] = new Road(x, y);
    }
    for (int i=1; i<=n; i++)
        scanf("%d", cost+i);
}

int get_father(int x)
{
    int head = x;
    while (father[head] != head) head = father[head];
    while (x != head)
    {
        int tmp = father[x];
        father[x] = head;
        x = tmp;
    }
    return head;
}

void select()
{
    sort(road, road+m, cmp_w);
    for (int i=1; i<=n; i++) father[i] = i;
    for (int i=0; i<m; i++)
    {
        int x = get_father(road[i]->x),
            y = get_father(road[i]->y);
        if (x != y)
        {
            road[i]->flag = 1;
            father[x] = y;
        }
    }
    m = 0;
    for (int i=0; m<n-1; i++)
        if (road[i]->flag) road[m++] = road[i];
}

void check_select()
{
    printf("m = %d\n", m);
    for (int i=0; i<m; i++)
        printf("x = %d y = %d w = %d\n", road[i]->x, road[i]->y, road[i]->w);
}

void build()
{
    for (int i=1; i<=n; i++) father[i] = i;
    for (int i=0; i<k; i++)
    {
        int x = get_father(road_sp[i]->x),
            y = get_father(road_sp[i]->y);
        if (x != y) father[x] = y;
    }
    for (int i=0; i<m; i++)
    {
        int x = get_father(road[i]->x),
            y = get_father(road[i]->y);
        if (x != y)
            father[x] = y;
        else
            road[i]->flag = 0;
    }
    for (int i=1; i<=n; i++) father[i] = i;
    for (int i=0; i<m; i++)
        if (road[i]->flag)
        {
            int x = get_father(road[i]->x),
                y = get_father(road[i]->y);
            father[x] = y;
        }
    for (int i=1; i<=n; i++)
        if (father[i] == i)
            color[i] = cn++;
    for (int i=1; i<=n; i++)
    {
        color[i] = color[get_father(i)];
        size[color[i]] += cost[i];
    }
    m = 0;
    for (int i=0; i<n-1; i++)
        if (!road[i]->flag) road[m++] = road[i];
}

void check_build()
{
    for (int i=0; i<cn; i++)
    {
        printf("Color %d :", i);
        for (int j=1; j<=n; j++)
            if (color[j] == i) printf("%d ", j);
        printf("  size = %I64d\n", size[i]);
    }
    printf("sp edge:\n");
    for (int i=0; i<k; i++)
        printf("x = %d  y = %d\n", color[road_sp[i]->x], color[road_sp[i]->y]);
    printf("other edge:\n");
    for (int i=0; i<m; i++)
        printf("x = %d  y = %d w = %d\n", color[road[i]->x], color[road[i]->y], road[i]->w);
}

long long work(Node * & x, int w)
{
    long long s = 0;
    if (x->flag)
    {
        //road_sp[x->flag-1]->ans = w;
        s = x->size * w;
        x->flag = 0;
        ssize -= x->size;
    }
    x = x->father;
    return s;
}

void dfs(Node * now)
{
    for (Edge * e = now->head; e!=0; e=e->next)
    {
        if (!e->target->deep)
        {
            e->target->deep = now->deep + 1;
            e->target->flag = e->flag;
            e->target->father = now;
            dfs(e->target);
            if (e->flag) ssize += e->target->size;
            now->size += e->target->size;
        }
    }
}

void clear_road_sp()
{
    for (int i=0; i<k; i++) road_sp[i]->ans = 9999999;
}

void print_road_sp(long long s)
{
    return ;
    printf("%I64d ", s);
    for (int i=0; i<k; i++) printf("%d ", road_sp[i]->ans);
    printf("\n", s);
}

long long get_ans()
{
    my_node_count = 0;
    my_edge_count = 0;
    for (int i=0; i<cn; i++) node[i] = get_node(size[i]);
    for (int i=0; i<cn; i++) father[i] = i;
    for (int i=0; i<k; i++)
        if (road_sp[i]->flag)
        {
            int x = get_father(color[road_sp[i]->x]),
                y = get_father(color[road_sp[i]->y]);
            if (x == y) return 0;
            father[x] = y;
            newedge(node[color[road_sp[i]->x]], node[color[road_sp[i]->y]], i+1);
        }
    maxL = 0;
    for (int i=0; i<m; i++)
    {
        int x = get_father(color[road[i]->x]),
            y = get_father(color[road[i]->y]);
        if (x != y)
        {
            road[i]->flag = 0;
            father[x] = y;
            newedge(node[color[road[i]->x]], node[color[road[i]->y]], 0);
        }
        else
        {
            if (road[i]->w > maxL) maxL = road[i]->w;
            road[i]->flag = 1;
        }
    }
    
    node[color[1]]->deep = 1;
    ssize = 0;
    dfs(node[color[1]]);
    long long s = 0;
    //clear_road_sp();
    for (int i=0; i<m; i++)
    {
        if (ssize * maxL + s < ans) break;
        if (road[i]->flag)
        {
            Node * x = node[color[road[i]->x]],
                 * y = node[color[road[i]->y]];
            int c = 0;
            while (x != y)
                if (x->deep > y->deep) s += work(x, road[i]->w); else s += work(y, road[i]->w);
        }
    }
    //if (ssize != 0) printf("A = %I64d\n", ssize);
    //print_road_sp(s);
    for (int i=1; i<=cn; i++) delete node[i];
    return s;
}

void dfs(int now)
{
    if (now == k)
    {
        ans = get_max(get_ans(), ans);
        return ;
    }
    road_sp[now]->flag = 1;
    dfs(now+1);
    road_sp[now]->flag = 0;
    dfs(now+1);
}

int main()
{
freopen("toll.in", "r", stdin);
    freopen("toll.out", "w", stdout);
    init();
    select();
    //check_select();
    build();
    //check_build();
    dfs(0);
    
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Chenyichen0420 (赞：1)

## 题目大意

给你一张原图 $G^\prime=(V,E_1)$，再给你一些边 $E_2$，其中 $E_1$ 的边边权确定，$E_2$ 中的边的边权由你自己定。这时我们令 $E=E_1\cup E_2$，则 $E$ 中每一个边的起始点均已确定。问你，如果在 $G=(V,E)$ 中生成出一个指定的最小生成树（毕竟最小生成树可以有多个），那么这棵树上属于 $E_2$ 的边的边权之和最大为多少。

## 思路分析

当你对一道题目无从下手时，我们就要观察数据范围。观察到： $k\le20$。这是一个突破口，这么小的数字多半与 $2^k$ 挂钩。

顺势出现一个思路：枚举每一条边有没有出现在最小生成树中。虽然复杂度不对（等会儿分析），但是讲一下：枚举 $2^k$ 种情况，对于每一种，先将所有已经选择的边加入最小生成树中（特判此时已经有环的情况，直接舍弃），然后对整张图跑一遍最小生成树。最后用上最小生成树的性质对被选择的边进行约束，即可求出答案。

性质：最小生成树再加上任意一条边都会形成一个环。假定这条边的边权为 $a$，那么所有环上的边的边权都小于等于 $a$。

分析一下复杂度：最外层 $2^k$ 枚举，中间最小生成树，如果先排好了序的话每次是 $m$，总的时间复杂度大于 $O(2^km)$，大概是 $10^{11}$，显然不可行。

考虑优化。首先给出一个结论：当我们先将 $E_2$ 所有的边加入到最小生成树中（有环就不管，反正对 kruskal 没有影响），再跑最小生成树的话，加的那些 $E_1$ 的边一定在所有情况下的最小生成树中。

证明一下：我们先将点分为两类：被选中的 $E_1$ 连同的点 $V_1$ 和其余的点 $V_2$。在 $E_2$ 的限制下，$V_2$ 中的点必然会形成若干个连通块。

那么显然 $E_2$ 在 $V_2$ 中产生的限制不会影响到 $V_1$，也就是说在 $V_1$ 当中 $E_1$ 所形成的最小生成树必然是最优的。

其次，因为 $E_2$ 在 $V_2$ 中的限制，所有从 $V_2$ 的点连向 $V_2$ 的点且不连通两个连通块的 $E_1$ 中的边都会被舍弃，但是这些边当且仅当 $E_2$ 的限制改变时才可能被加入最小生成树，所以不一定出现在所有情况下的最小生成树中。

最后是从 $V_1$ 的点连向 $V_2$ 的点或连通两个连通块的 $V_2$ 的点的 $E_1$ 中的边。这些边以最优的方式联通了这些东西，那么在 $E_2$ 的限制变少的情况下，这些东西也不会变得更劣。毕竟 $E_2$ 的限制改变只会影响连通块内的内容。

当然了，以上的证明只是本人的感性理解的证明，并不严谨，不过对于绝大部分的情况都是没有问题的。

这时候，我们可以干一件事：把所有被选中的 $E_1$ 连通起来的点缩成一个大点。因为这些边一定要选，而且不包含 $E_2$ 中的边，所以不会对答案造成任何影响。

此时，图中就只会剩下 $k+1$ 个点。

最后，我们再用开始的思路进行求解就行了。因为只剩下了 $k+1$ 个点，因此我们不需要对最小生成树的限制与求解这一步进行任何优化，直接使用 $k^2$ 的暴力更新就行了。

注意数据范围，不开 `long long` 见祖宗。

总复杂度：$O(m\log m+2^kk^2)$。

### 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline void tmin(int& l, const int& r) {
	(l > r) && (l = r);
}
inline void tmax(int& l, const int& r) {
	(l < r) && (l = r);
}
struct edge {
	int l, r, v;
	edge(int li = 0, int ri = 0, int vi = 0) :
		l(li), v(vi), r(ri) {}
}tmp; vector<edge>e, nee, ne; vector<int>che[30];
class MSS {
	int fa[100005];
public:
	int find(const int& p) {
		return (fa[p] != p ? fa[p] = find(fa[p]) : p);
	}
	inline void set(const int& v) {
		for (int i = 1; i <= v + 1; ++i) fa[i] = i;
	}
	inline bool merge(const int& l, const int& r) {
		return (find(l) != find(r) ? fa[find(l)] = find(r), 1 : 0);
	}
	inline bool isit(const int& v) const{
		return fa[v] == v;
	}
}mstt, mss;
int n, m, k, a[100005], blk[100005], vl[30];
int ans, cnt, dep[30], fa[30], siz[30], mv[30];
inline void newmap() {
	for (int i = 1; i <= n; ++i)
		if (mstt.isit(i)) blk[i] = ++cnt;
	for (int i = 1; i <= n; ++i)
		blk[i] = blk[mstt.find(i)], vl[blk[i]] += a[i];
	for (int i = 0; i != k; ++i)
		nee[i] = edge(blk[nee[i].l], blk[nee[i].r], 0);
	for (int i = 0; i != m; ++i)
		if (mstt.merge(e[i].l, e[i].r))
			ne.emplace_back(edge(blk[e[i].l], blk[e[i].r], e[i].v));
}
inline void dfs(const int& p, const int& f) {
	dep[p] = dep[f] + 1; fa[p] = f; siz[p] = vl[p];
	for (int i = 0; i != che[p].size(); ++i)
		if (che[p][i] != f) dfs(che[p][i], p), siz[p] += siz[che[p][i]];
}
inline void cldfs() {
	memset(dep, 0, sizeof dep); memset(fa, 0, sizeof fa);
	memset(siz, 0, sizeof siz); dfs(blk[1], 0);
}
inline void chg(int l, int r, const int& v) {
	while (l != r) {
		if (dep[l] > dep[r]) swap(l, r);
		tmin(mv[r], v); r = fa[r];
	}
}
signed main() {
	ios::sync_with_stdio(0);
	cin >> n >> m >> k;
	for (int i = 1, l, r, v; i <= m; ++i)
		cin >> l >> r >> v,
		e.emplace_back(edge(l, r, v));
	mss.set(n); mstt.set(n);
	for (int i = 1, l, r; i <= k; ++i)
		cin >> l >> r, mss.merge(l, r),
		nee.emplace_back(edge(l, r, 0));
	for (int i = 1; i <= n; ++i) cin >> a[i];
	sort(e.begin(), e.end(), [&](const edge& l, const edge& r) {
		return l.v < r.v;
		});
	for (int i = 0; i != m; ++i)
		if (mss.merge(e[i].l, e[i].r))
			mstt.merge(e[i].l, e[i].r);
	newmap();
	for (int chs = 0, tmp; chs != (1ll << k); ++chs) {
		mss.set(cnt); bool ctn = 0; tmp = 0;
		for (int i = 1; i <= cnt; ++i) che[i].clear();
		for (int i = 0; i != k; ++i)
			if (chs & (1ll << i))
				if (mss.merge(nee[i].l, nee[i].r))
					che[nee[i].l].emplace_back(nee[i].r),
					che[nee[i].r].emplace_back(nee[i].l);
				else { ctn = 1; break; }
		if (ctn) continue;
		for (int i = 0; i != ne.size(); ++i)
			if (mss.merge(ne[i].l, ne[i].r))
				che[ne[i].l].emplace_back(ne[i].r),
				che[ne[i].r].emplace_back(ne[i].l);
		cldfs(); memset(mv, 0x3f, sizeof mv);
		for (int i = 0; i != ne.size(); ++i)
			chg(ne[i].l, ne[i].r, ne[i].v);
		for (int i = 0; i != k; ++i)
			if (chs & (1ll << i))
				tmp += siz[(dep[nee[i].l] > dep[nee[i].r] ? nee[i].l : nee[i].r)] *
				mv[(dep[nee[i].l] > dep[nee[i].r] ? nee[i].l : nee[i].r)];
		tmax(ans, tmp);
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：under_the_time (赞：0)

## 题意

> 给定一张 $n$ 个点 $m+k$ 条边的无向图，点有点权 $p_x$，边有边权 $c(u,v)$。在原图的最小生成树中，对于一条边 $(u,v)$，它产生的贡献为 $c(u,v)\times p_x$，其中的点 $x$ 在树上到 $1$ 的路径中必须含有 $(u,v)$ 这条边。
>
> 你可以自定义其中指定的 $k$​ 条边的边权，使得这些边产生的贡献最大，求这些边的贡献之和。如果边不在最小生成树中则贡献为 $0$。
>
> $k\le20,n\le10^5,m\le3\times10^5$。保证边权互不相同。

## 解法

$k$ 只有 $20$，所以我们可以 $O(2^k)$ 枚举 $k$ 中的哪几条边最终被放进了最小生成树中，然后算出这几条边边权最多可以取多少，使得这些边全部都在树中。其他自定义的边我们可以将它们的权值设为 $+\infty$，不做考虑。

设当前枚举到的边集为 $K'$，已经给定边权的边集为 $M$，待定边权的边集为 $K$。想让最小生成树中一定包含 $K'$，可以在算最小生成树时将 $K'$ 中的边提前加入树中（也需要保持树结构），然后才按照边权大小考虑 $M$ 中的边。

对于 $K'$ 中边的边权上界，可以利用一个最小生成树的性质：对于一条非树边 $(u,v)$，那么如果将其加入树中一定会形成环，而**环上树边的权值都小于等于 $c(u,v)$**，否则 $(u,v)$ 就会变成树边。所以在算完生成树后，枚举 $M$ 中每条非树边 $(u,v)$，$u\to lca$ 和 $v\to lca$ 两条链上属于 $K'$ 的边的边权都必须小于等于 $c(u,v)$​​。

计算贡献就以 $1$ 为根遍历整棵最小生成树即可，具体见实现。但这样复杂度为 $O(2^km+m\log m)$（提前排好序），瓶颈在于每次都必须把 $M$ 中的边全部考虑完。

设想一下，如果把 $K$ 中的边全提前加入树中，此时树上属于 $M$ 的边最少，那么这些属于 $M$ 的边（边集记为 $M'$），不论你怎么选 $K'$，**$M'$ 中的边一定都会在最小生成树上**。其他情况下，如果 $M'$ 中的某几条边不在最小生成树上，那么说明有更优的 $M$ 中的边可以替代，那么这些更优的边就会在 $M'$ 中替代这几条边。

所以我们可以先算出 $M'$，因为边权互不相同，所以 $M'$ 是确定的。对于其中边组成的一个连通块，即使选择不一样的 $K'$，最小生成树中这个连通块的部分选择的边就是不变的。所以我们就可以把这么多个连通块缩成一个点，每次跑最小生成树就不再需要考虑这个点的内部边的情况了。

$M'$ 可以认为是将 $K$ 全放进最小生成树中，算完整棵树后再把 $K$ 全部删掉后剩下的边，所以一共有 $K+1$​ 个连通块。我们在删除 $K$ 后对 $M$ 中的边继续跑最小生成树，把树构建完整。此时新加的连接着两个不同连通块的 $k$ 条边（相当于替代了原来 $K$ 中边的作用），就可以和每轮枚举的 $K'$ 中的边组成最终的最小生成树了。

于是，每轮最小生成树还需要考虑的边就只剩下了 $2k$ 条。

## 实现

首先第一遍 `Kruskal` 跑出 $M'$，开两个并查集 $F,G$，缩点也可以利用并查集 $G$，在加完 $K$ 中的边后再加的边就是组成连通块的边，对于这些边在合并完 $F$ 后另外再把 $G$ 也合并了。由于我们只关心 $K'$ 中边的贡献，所以每个连通块内部的边的贡献是不重要的，只需要记录连通块内点的点权之和。

缩完点后，用并查集 $G$ 继续跑 `Kruskal`，记录这一轮 `Kruskal` 新加的边（边两端的点都代表一个连通块，记为 $newE$），然后就可以开始枚举 $K'$ 了。我们用一个 $S$ 表示当前 $K'$ 的选择，如果 $S$ 二进制第 $i$ 位为 $1$ 则说明 $K$ 中第 $i$ 条边被选进 $K'$。

也是先将 $K'$ 提前加入树中，再将 $newE$ 中的边加入树中，并记录这些边是否是树边。我们将 $(u,v)$ 这条边的贡献记录在 $u,v$ 中深度更深的点上。在树上跑 `dfs` 算出每个点的深度和子树中点的点权之和，然后枚举 $newE$ 中的非树边，把 $u\to lca$ 和 $v\to lca$ 上点所代表的边的上界进行更新。由于 $k$ 不大所以可以暴力跳祖先。

对于点 $u$，我们令子树点权之和为 $siz_u$，$u$ 连接其父亲的这条边边权上界为 $mx_u$。然后对于每条 $K'$ 中的边 $(u,v)$，这条边对本轮答案产生的贡献即为 $u,v$ 中深度较大的点的 $siz$ 与 $mx$ 之积。

## 代码

```cpp
// 先将k条边全部加入后跑最小生成树
// 去掉k条边后缩点
// 然后就可以2^k跑
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn = 2e5 + 5, maxm = 1e6 + 5;
const int maxk = 50;
struct Edge { int w,u,v; } E[maxm],K[maxn];
int n,m,k;
int F[maxn], G[maxn];
int find(int u, bool op = true) { 
    if (op) return u == F[u] ? u : F[u] = find(F[u], true); 
    else return u == G[u] ? u : G[u] = find(G[u], false);
}
void unite(int u, int v, bool op = true) {
    if (op) F[u] = v;
    else G[u] = v;
}
void Kruskal1() {
    for (int i = 1;i <= n;i ++) F[i] = G[i] = i;
    for (int i = 1,u,v;i <= k;i ++) {
        u = find(K[i].u), v = find(K[i].v);
        if (u != v) unite(u,v);
    }
    sort(E + 1,E + m + 1,[&](const Edge &x,const Edge &y) { return x.w < y.w; });
    for (int i = 1,u,v;i <= m;i ++) {
        u = find(E[i].u), v = find(E[i].v);
        if (u == v) continue;
        unite(u,v); 
        u = find(E[i].u, false), v = find(E[i].v, false); 
        if (u != v) unite(u,v,false);
    }
}
int tot = 0, b[maxn]; ll sum[maxk];
ll p[maxn];
void Build() {
    for (int i = 1;i <= n;i ++) 
        if (find(i,false) == i)
            sum[b[i] = ++ tot] = p[i];
    for (int i = 1;i <= n;i ++) {
        int f = find(i,false);
        if (f == i) continue;
        sum[b[i] = b[f]] += p[i];
    }
}
Edge newE[maxm]; int cnt = 0;
void Kruskal2() {
    for (int i = 1,u,v;i <= m;i ++) {
        u = find(E[i].u,false), v = find(E[i].v,false);
        if (u == v) continue;
        newE[++ cnt] = Edge{E[i].w,b[E[i].u],b[E[i].v]};
        unite(u,v,false); 
    }
}
vector<int> mp[maxk];
void addEdge(int u,int v) { mp[u].push_back(v); }
int fa[maxk],dep[maxk]; ll siz[maxk];
void dfs(int u,int f) {
    dep[u] = dep[fa[u] = f] + 1;
    siz[u] = sum[u];
    for (auto v : mp[u]) {
        if (v == f) continue;
        dfs(v,u); siz[u] += siz[v];
    }
}
ll mx[maxk];
void update(int u,int v,ll w) {
    if (dep[u] < dep[v]) swap(u,v);
    while (dep[u] > dep[v])
        mx[u] = min(mx[u], w), u = fa[u];
    while (u != v) {
        mx[u] = min(mx[u], w);
        mx[v] = min(mx[v], w);
        u = fa[u], v = fa[v];
    }
}
bool vis[maxk];
void Kruskal(int s) {
    memset(vis,false,sizeof(vis));
    for (int i = 1;i <= tot;i ++){
        F[i] = i;
        mp[i].clear();
    }
    for (int i = 1;i <= k;i ++) 
        if ((s >> (i - 1)) & 1) {
            int u = find(b[K[i].u]), v = find(b[K[i].v]);
            unite(u,v); 
            addEdge(b[K[i].u],b[K[i].v]); 
            addEdge(b[K[i].v],b[K[i].u]);
        }
    for (int i = 1;i <= cnt;i ++) {
        int u = find(newE[i].u), v = find(newE[i].v);
        if (u == v) continue;
        unite(u,v); vis[i] = true;
        addEdge(newE[i].u,newE[i].v); 
        addEdge(newE[i].v,newE[i].u); 
    }
}
ll ans = 0;
int main() {
    scanf("%d%d%d",&n,&m,&k);
    for (int i = 1;i <= m;i ++) 
        scanf("%d%d%d",&E[i].u,&E[i].v,&E[i].w);
    for (int i = 1;i <= k;i ++)
        scanf("%d%d",&K[i].u,&K[i].v), K[i].w = 0;
    for (int i = 1;i <= n;i ++)
        scanf("%lld",&p[i]);
    Kruskal1(); Build(); Kruskal2();
    for (int s = 0;s < (1ll << k);s ++) {
        Kruskal(s);
        memset(dep,0,sizeof(dep));
        memset(siz,0,sizeof(siz));
        dfs(b[1],0); ll res = 0;
        memset(mx,0x3f3f,sizeof(mx));
        for (int i = 1;i <= cnt;i ++)
            if (!vis[i]) update(newE[i].u, newE[i].v, (ll)newE[i].w);
        for (int i = 1;i <= k;i ++)
            if ((s >> (i - 1)) & 1) {
                int u = b[K[i].u], v = b[K[i].v];
                if (dep[u] < dep[v]) swap(u,v);
                res += mx[u] * siz[u];
            }
        ans = max(ans,res);
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：zhangxy__hp (赞：0)

$k\le 20$，考虑 $O(2^k)$ 暴力枚举加入的边。但是边数很大，时间复杂度很高无法承受。

考虑在一开始强制选这 $k$ 条边，然后跑最小生成树，此时加入的边就是一定会加入的边。设这个边集为 $S$。

将 $S$ 连接的连通块缩成点，点数为 $O(k)$。再在原图上对这些点跑最小生成树，设加入的边集为 $T$，则 $T$ 为加入那 $k$ 条边后有可能在最小生成树中的边。数量也为 $O(k)$。

然后暴力枚举强制加入的边，用 $T$ 跑出最小生成树，再用 $T$ 中的非树边限制强制加入的边即可。具体地，对于一条非树边 $(u,v)$，树上 $u$ 到 $v$ 的路径中的所有边都应该大于等于这条非树边的边权。暴力跳父亲即可。

考虑统计答案，只需要计算通过每条边的人数，用 dfs 计算子树权值和即可。

时间复杂度 $O(m\log m+2^kk^2)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define il inline
#define pii pair<int,int>
#define mp make_pair
#define fir first
#define sec second
#define pb push_back
using namespace std;
namespace asbt{
namespace cplx{bool begin;}
const int maxn=3e5+5;
int n,m,k,a[maxn],bel[maxn];
bool vis[maxn];
vector<int> dk;
vector<pii> e[maxn];
struct edge{
	int u,v,w;
	il bool operator<(const edge &x)const{
		return w<x.w;
	}
}em[maxn],ek[maxn];
vector<edge> et;
int fa[maxn],sz[maxn],ans;
int mxe[maxn],dep[maxn],tof[maxn];
il void init(){
	for(int i=1;i<=n;i++){
		fa[i]=i,sz[i]=1;
	}
}
il int find(int x){
	return x!=fa[x]?fa[x]=find(fa[x]):x;
}
il void merge(int u,int v){
	u=find(u),v=find(v);
	if(u==v){
		return ;
	}
	if(sz[u]>sz[v]){
		sz[u]+=sz[v],fa[v]=u;
	}
	else{
		sz[v]+=sz[u],fa[u]=v;
	}
}
il void dfs(int u){
	dep[u]=dep[fa[u]]+1;
	sz[u]=a[u];
	for(pii i:e[u]){
		int v=i.fir,w=i.sec;
		if(v!=fa[u]){
			fa[v]=u;
			tof[v]=w;
			dfs(v);
			sz[u]+=sz[v];
		}
	}
}
il void solve(int S){
	for(int u:dk){
		fa[u]=u,sz[u]=1,e[u].clear();
	}
	for(int i=1,u,v;i<=k;i++){
		if(S>>(i-1)&1){
			u=bel[ek[i].u],v=bel[ek[i].v];
			if(find(u)==find(v)){
				return ;
			}
			merge(u,v);
			e[u].pb(mp(v,-i));
			e[v].pb(mp(u,-i));
		}
	}
	for(int i=0;i<et.size();i++){
		vis[i]=0;
	}
	for(int i=0,u,v,w;i<et.size();i++){
		u=et[i].u,v=et[i].v,w=et[i].w;
		if(find(u)!=find(v)){
			merge(u,v);
			vis[i]=1;
			e[u].pb(mp(v,w));
			e[v].pb(mp(u,w));
		}
	}
	for(int i=1;i<=k;i++){
		mxe[i]=INT_MAX;
	}
	for(int u:dk){
		dep[u]=tof[u]=fa[u]=sz[u]=0;
	}
	dfs(bel[1]);
//	puts("666");
	for(int i=0,u,v,w;i<et.size();i++){
//		cout<<i<<"\n";
		if(vis[i]){
			continue;
		}
		u=et[i].u,v=et[i].v,w=et[i].w;
		if(dep[u]<dep[v]){
			swap(u,v);
		}
//		cout<<dep[u]<<" "<<dep[v]<<"\n";
		while(dep[u]>dep[v]){
//			puts("666");
			if(tof[u]<0){
				mxe[-tof[u]]=min(mxe[-tof[u]],w);
			}
			u=fa[u];
		}
		while(u!=v){
			if(tof[u]<0){
				mxe[-tof[u]]=min(mxe[-tof[u]],w);
			}
			if(tof[v]<0){
				mxe[-tof[v]]=min(mxe[-tof[v]],w);
			}
			u=fa[u],v=fa[v];
		}
	}
	for(int u:dk){
		if(tof[u]<0){
			tof[u]=-mxe[-tof[u]];
		}
	}
	int res=0;
	for(int u:dk){
		if(tof[u]<0){
			res-=tof[u]*sz[u];
		}
	}
	ans=max(ans,res);
}
namespace cplx{
	bool end;
	il double usdmem(){return (&begin-&end)/1048576.0;}
}
signed main(){
//	cout<<cplx::usdmem();
	ios::sync_with_stdio(0),cin.tie(0);
//	freopen("toll5.in","r",stdin);
	cin>>n>>m>>k;
//	cout<<n<<" "<<m<<" "<<k<<"\n";
	for(int i=1;i<=m;i++){
		cin>>em[i].u>>em[i].v>>em[i].w;
	}
	init(),sort(em+1,em+m+1);
	for(int i=1;i<=k;i++){
		cin>>ek[i].u>>ek[i].v;
		merge(ek[i].u,ek[i].v);
	}
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1,u,v;i<=m;i++){
		u=em[i].u,v=em[i].v;
		if(find(u)!=find(v)){
			merge(u,v);
			vis[i]=1;
		}
	}
	init();
	for(int i=1,u,v;i<=m;i++){
		if(vis[i]){
			u=find(em[i].u);
			v=find(em[i].v);
			if(sz[u]>sz[v]){
				sz[u]+=sz[v];
				a[u]+=a[v];
				fa[v]=u;
			}
			else{
				sz[v]+=sz[u];
				a[v]+=a[u];
				fa[u]=v;
			}
		}
	}
	for(int i=1;i<=n;i++){
		bel[i]=find(i);
		if(bel[i]==i){
			dk.pb(i);
		}
	}
	init();
	for(int i=1,u,v,w;i<=m;i++){
		u=bel[em[i].u],v=bel[em[i].v],w=em[i].w;
		if(find(u)!=find(v)){
			et.pb((edge){u,v,w});
			merge(u,v);
		}
	}
	for(int S=0;S<1<<k;S++){
//		cout<<bitset<15>(S)<<"\n";
		solve(S);
	}
	cout<<ans;
	return 0;
}
}
signed main(){return asbt::main();}
/*
100000 299989 12
*/
```

---


# [SHOI2011] 扫雷机器人

## 题目描述

扫雷是陆军战场上一项重要的而危险的任务。为此， AL 军工厂专门研制了一种扫雷机器人。这种机器人是专门针对直线形雷阵设计的。所谓直线形雷阵，就是所有的地雷都埋在同一条直线上。例如图中黑点表示的雷阵就是直线形雷阵。

![0](https://cdn.luogu.com.cn/upload/pic/20066.png)

AL 军工厂生产的扫雷机器人的排雷方法只有一种，那就是安全引爆。每次，机器人在所有探测到的地雷中选择一颗引爆。被引爆的地雷会接连引爆不超过他的爆炸威力范围的其它地雷，这些被间接引爆的地雷还能引起进一步的连锁爆炸。例如图中，用一个圆的半径表示地雷的爆炸威力。如果引爆 $2$ 号雷， $1$ 、 $2$ 号雷都会爆炸；如果引爆 $3$ 号雷， $4$ 颗地雷全都会爆炸；而如果引爆 $4$ 号雷，那就只有它一颗爆炸。

虽然是机器人，但引爆也是危险的。所以，扫雷机器人的订购人希望机器人能在实战中采取引爆次数尽可能少的炸毁所有地雷的排雷方案。于是 AL 军工厂想就此方面对机器人进行测试。为了评估机器人的表现， AL 军工厂打算事先计算出：在一个直线形雷阵（即输入的雷阵）中，如果随机进行引爆，完成排雷工作所需要引爆次数的期望；并将这个值与机器人的实际排雷方案相比较，来评估他的表现。

所谓“随机进行引爆”是指，每次在所有没有被引爆的地雷中等概率的随机选择一个进行引爆。当这一次引爆引发的连环爆炸结束后，如果还有地雷没有被引爆，则重复上面的操作，直到所有地雷都被引爆为止。

## 说明/提示

**提示**

本题的试题目录下有 $10$ 个额外的输入样例文件 ``robot20111.in~robot201110.in`` ，以及它们对应的输出样例文件 ``robot20111.out~robot201110.out`` 。这些数据符合本题中关于数据规模的全部约定，但它们不是最终的测试数据。

**[下载地址](https://pan.baidu.com/s/1Q5X52FMH38UYvmrEsVsEkA)**，密码：ypbv。

**评分方式**

在每个测试点，如果您的输出是 $YourAns$ ，而标准答案是 $StdAns$ ，那么：

-    当 $ |YourAns-StdAns| \le 0.0001$ 时，该测试点得 $10$ 分。

-    当 $0.01 \ge |YourAns-StdAns| > 0.0001$ 时，该测试点得 $6$ 分。

-    当 $0.5 \ge |YourAns-StdAns| > 0.01$ 时，该测试点得 $2$ 分。

-    否则得 $0$ 分。

**数据范围**

测试点 $1$：$n \le 20$。

测试点 $2$：$n \le 200$ ，且任意方案都保证引爆次数不超过 $20$。

测试点 $3$：$n \le 200$。

测试点 $4 \sim 5$：$n \le 4000$ ，且任意方案都保证引爆次数不超过 $20$。

测试点 $6 \sim 10$：$n \le 4000$。

## 样例 #1

### 输入

```
4
0 1
2 2
8 7
11 2```

### 输出

```
2.3333```

## 样例 #2

### 输入

```
3
-10 10
0 1
10 10```

### 输出

```
2.3333```

## 样例 #3

### 输入

```
2
1 10
2 100```

### 输出

```
1.0000
```

## 样例 #4

### 输入

```
9
1 10
2 10
3 10
4 10
5 10
6 10
7 10
8 10
1000 2000```

### 输出

```
1.8889```

# 题解

## 作者：DaiRuiChen007 (赞：9)

# 洛谷 P4637 题解

[$\text{Link}$](https://www.luogu.com.cn/problem/P4637)

## 思路分析

非常强的思维题，推理过程相当精彩

考虑求出期望的过程：

1. 每种引爆地雷的顺序，共有 $n!$ 种情况
2. 对于每种顺序，计算出其中**实际**引爆的地雷个数，也就是所有没有在之前被引爆的地雷个数
3. 将每种方案中**实际**引爆的地雷个数当成操作次数，乘上概率 $\dfrac1{n!}$，求和计算期望

由于期望具有线性性，所以我们可以考虑计算每个地雷对答案的贡献，也就是说，对于每个地雷，求出其会在多少种方案中被实际引爆

求出所有可以导致第 $i$ 个地雷被引爆（直接或间接）的地雷集合，设为 $\mathbf S_i$，那么 $i$ 第一个被引爆，当且仅当所有 $\mathbf S_i$ 中的地雷都在 $i$ 之后被引爆，

所以问题就转化成了：对于第 $i$ 个元素，求出在所有排列中，满足 $i$ 是 $\mathbf S_i$ 中所有元素里的第一个的情况总数

由于其他的元素在哪里并不重要，所以我们只需要考虑 $\mathbf S_i$ 中的元素之间的**相对关系**，不难得到满足 $i$ 恰好是其中第一个数的方案数占所有方案数的比例为：$\dfrac{(|\mathbf S_i|-1)!}{|\mathbf S_i|!}=\dfrac{1}{|\mathbf S_i|}$，因此在所以排列中，第 $i$ 颗地雷被实际引爆的次数应该是 $\dfrac{n!}{|\mathbf S_i|}$ 次，这也是第 $i$ 颗地雷对答案的贡献

套用期望的计算公式可以得到：
$$
\begin{aligned}
\text{Answer}
&=\dfrac{1}{n!}\sum_{i=1}^n\dfrac{n!}{|\mathbf S_i|}\\
&=\sum_{i=1}^n\dfrac1{|\mathbf S_i|}
\end{aligned}
$$
所以问题就转化成求所有的 $|\mathbf S_i|$

可以将所有地雷向其能够直接引爆的点连一条边，我们需要求出对于每个点 $i$，有多少个点能够到达 $i$

考虑缩点，在 DAG 上做拓扑排序转移一个用 `bitset` 维护的 $\mathbf S_i$ 即可

注意:如果我们直接在原图上做 $n$ 次 BFS，复杂度在完全图上会退化到 $\Theta(n^3)$


时间复杂度 $\Theta(n^2)$

## 代码呈现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=4001;
int p[MAXN],d[MAXN];
vector <int> edge[MAXN],g[MAXN];
bool vis[MAXN];
bitset <MAXN> f[MAXN];
int low[MAXN],dfn[MAXN],dfncnt,sk[MAXN],siz[MAXN],bel[MAXN],deg[MAXN],top,scc;
bool ins[MAXN],link[MAXN][MAXN];
inline void tarjan(int p) {
	low[p]=dfn[p]=++dfncnt;
	ins[p]=true; sk[++top]=p;
	for(int v:edge[p]) {
		if(!dfn[v]) {
			tarjan(v);
			low[p]=min(low[p],low[v]);
		} else if(ins[v]) low[p]=min(low[p],low[v]);
	}
	if(low[p]==dfn[p]) {
		++scc;
		int k;
		do {
			k=sk[top--];
			bel[k]=scc;
			f[scc].set(k);
			++siz[scc];
			ins[k]=false;
		} while(k!=p);
	}
}
signed main() {
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d%d",&p[i],&d[i]);
	for(int i=1;i<=n;++i) {
		for(int j=1;j<=n;++j) {
			if(abs(p[i]-p[j])<=d[i]) {
				edge[i].push_back(j);
			}
		}
	}
	for(int i=1;i<=n;++i) if(!dfn[i]) tarjan(i);
	for(int i=1;i<=n;++i) {
		for(int j:edge[i]) {
			if(bel[i]==bel[j]||link[bel[i]][bel[j]]) continue;
			g[bel[i]].push_back(bel[j]);
			link[bel[i]][bel[j]]=true;
			++deg[bel[j]];
		}
	}
	queue <int> q;
	for(int i=1;i<=scc;++i) {
		if(!deg[i]) {
			q.push(i);
		}
	}
	while(!q.empty()) {
		int p=q.front();
		q.pop();
		for(int v:g[p]) {
			f[v]|=f[p];
			--deg[v];
			if(!deg[v]) q.push(v);
		}
	}
	double res=0;
	for(int i=1;i<=n;++i) res+=1.0/((int)f[bel[i]].count());
	printf("%.4lf\n",res);
	return 0;
}
```

---

## 作者：Fishing_Boat (赞：5)

去年暑假的一场模拟赛最后一题，当时看都没看，今天翻题时翻到的，做了感觉不是很难。

考虑期望的线性性质。一个地雷有贡献的情况当且仅当所有可以引爆这个地雷的地雷中，这个地雷是第一个被引爆的。设可以引爆第 $i$ 个地雷的地雷个数为 $cnt_i$，则答案为 $\sum\limits_{i=1}^{n}\frac{1}{cnt_i}$。我们可以暴力的枚举每个点能引爆的地雷，时间复杂度 $O(n^3)$。[code](https://www.luogu.com.cn/record/113509707)

虽然上面的代码已经可以过掉了，但复杂度显然不对。我们可以提前预处理出所有地雷引爆后左右能引爆的最远距离，然后暴力统计，时间复杂度 $O(n^2)$。

## 代码 ##
```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
//#define ll long long
#define cmax(a,b) a=max(a,b)
#define cmin(a,b) a=min(a,b)
#define rst(a,x) memset(a,x,sizeof(a))
#define ls p<<1
#define rs p<<1|1
#define FAST ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);

using namespace std;

int n,a[4005],d[4005],cnt[4005],vis[4005],L[4005],R[4005],id[4005];
double ans;
vector <int> G[4005];

bool cmp(int x,int y){
	return a[x]<a[y];
}

int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i]>>d[i],id[i]=i;
	sort(id+1,id+n+1,cmp);
	for(int x=1;x<=n;x++){
		int i=id[x];
		L[i]=a[i]-d[i];R[i]=a[i]+d[i];
		int ll=x,rr=x;
		while(1){
			int l=id[ll-1],r=id[rr+1];
			if(l&&L[i]<=a[l]){
				ll--;
				cmin(L[i],a[l]-d[l]);
				cmax(R[i],a[l]+d[l]);
				continue;
			}
			if(r&&R[i]>=a[r]){
				rr++;
				cmin(L[i],a[r]-d[r]);
				cmax(R[i],a[r]+d[r]);
				continue;
			}
			break;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(L[j]<=a[i]&&a[i]<=R[j]) cnt[i]++;
		}
		ans+=1.0/cnt[i];
	}
	printf("%.4f",ans);
	return 0;
}
```

---


# 【模板】最小树形图

## 题目背景

这是一道模板题。

## 题目描述

给定包含 $n$ 个结点， $m$ 条有向边的一个图。试求一棵以结点 $r$ 为根的最小树形图，并输出最小树形图每条边的权值之和，如果没有以 $r$ 为根的最小树形图，输出 $-1$。

## 说明/提示

**样例 $1$ 解释**

最小树形图中包含第 $2$， $5$， $6$ 三条边，总权值为 $1 + 1 + 1 = 3$

**样例 $2$ 解释**

最小树形图中包含第 $3$， $5$， $6$ 三条边，总权值为 $2 + 1 + 1 = 4$

**样例 $3$ 解释**

无法构成最小树形图，故输出 $-1$ 。

**数据范围**

对于所有数据，$1 \leq u, v \leq n \leq 100$, $1 \leq m \leq 10^4$​​, $1 \leq w \leq 10^6$​​。

## 样例 #1

### 输入

```
4 6 1
1 2 3
1 3 1
4 1 2
4 2 2
3 2 1
3 4 1```

### 输出

```
3```

## 样例 #2

### 输入

```
4 6 3
1 2 3
1 3 1
4 1 2
4 2 2
3 2 1
3 4 1```

### 输出

```
4```

## 样例 #3

### 输入

```
4 6 2
1 2 3
1 3 1
4 1 2
4 2 2
3 2 1
3 4 1```

### 输出

```
-1```

# 题解

## 作者：封禁用户 (赞：63)

## 写在前面的话

1. 作者水平不够，如果看不懂，差不多就是我错了
1. 本文**主要**是补充$tarjan$优化朱刘算法这个黑科技，因为大多数人都说只要暴力朱刘就够了，如果不把这个东西介绍出来，它永远也不会成为考点
1. 本文会顺便**简单**介绍朱刘，因为网上的证明比较少，它也是tarjan优化的前提，另外感觉其他题解一上来就是一堆生僻的名词，很劝退
1. 我想我已经开始逐级改变了我写题解的目的了，不再是为了自己的复习或者巩固，学的再好也会忘记,只落得悲伤与痛苦了，而是为了能够真正介绍知识给大家了，一个人的意志很薄弱，而人民的力量是无限的。
1. 作者不可能介绍到所有前置知识，部分还得自行根据需要查询相关资料,因此需要有一定基础的人阅读本文
1. 一切都将逝去，唯有修涵永生。

## 契约

1. $(N^i)$表示注释$i$
1. $in[x]$表示$x$的入边的最小边权;
1. $pre[x]$表示$x$的入边，边权为$in[x]$的另外一端。
1. $d[x]$表示左偏树中$x$的距离
1. $a[x]$表示左偏树中$x$的点权
1. $l[x]$表示二叉树中，$x$的左儿子，同样的道理可以定义$r[x]$
1. $dep[x]$表示有根树中$x$的深度，$dep[\text{根}]$是$0$还是$1$无所谓
1. $sz[x]$表示有根树中以$x$为根的子树大小
1. 图论的时间复杂度分析中，默认$n$表示点数，$m$表示边数
1. 部分二元组$(u,v)$默认表示$u$连向$v$的一条边
1. 部分三元组$(u,v,w)$默认表示表示$u$连向$v$的边权为$w$的边
1. 接下来所有的套路都是在无重边的基础之上，因为重边你可以特判掉，选最小的那条即可。

## 朱刘算法

1. 考虑树形图的性质，每个点都有唯一的入边（根节点除外，以后讨论入边，都不考虑根节点），于是我们提出这样一个算法，强制选择每个点边权最小的入边，这样如果不存在环，我们**肯定**得到了最小的树形图。
1. 考虑如何处理环，有一条性质，因为这个环是由最小的入边所形成的环，因此**存在**一棵最小树形图，只缺少了环上的一条边，而且缺少的这条边所指向的点的入边必在**该棵**最小树形图上$(N^1)$。
1. 我们想要这个环缩成一个点$cnt$，而且要表现环上的每条边选与不选，对于进入环上的每条边$(u,v,w)$,$v$为环上的点,$u$非环上的点，令$w-=in[v]$，然后$v=cnt$，答案强制选上环上的边权，然后删除环上所有的内部连边$(N^2)$,把这个环缩成一个点，递归进行。
1. 每次形成一个环会至少少一个点，时间复杂度$O(nm)$。

---

$(N_1)$:

可以这样考虑证明，假设存在一棵最小树形图$T$,从$T$出发，肯定可以走到环上的某个点，假设走到了$x_0$，此时$x_0$已经有入边了，假设环长$L$,从$x_0$开始，顺时针给环上的点标号$x_0,x_1,x_2,...,x_{L-1}$,此时我们考虑$x_1$,对于$pre[x_1]$,我们可以删掉最小树形图上的$(pre[x_1],x_1)$，连上$(x_0,x_1)$,这样肯定不会变劣答案,可以证明的是，这样得到的还是一棵最小树形图,意味着环上$(x_0,x_1)$的边权等于$in[x_1]$,然后用同样的方法考虑$(x_1,x_2)$,依次类推，我们发现我们环上唯一不能选的边只有$(x_{L-1},x_0)$。

$(N_2)$:

这是一个常见贪心技巧，不知道的人应该仔细理解，自己给出证明。

## 左偏树

### 外节点

定义：二叉树中，一个节点没有左儿子或者右儿子就叫做外节点，或者理解为儿子个数小于等于1。

### 左偏树的距离

定义：在左偏树中，一个节点$x$的子树中，找到深度最大的外节点$y$，那么$dep[y]-dep[x]$就叫做左偏树中$x$到$y$的距离，以后谈距离省略左偏树，特别地空节点距离为$-1$。

### 左偏树

定义：如果一棵二叉树满足以下性质

1. 二叉堆（以后默认为小根堆进行讨论）
1. 对于任意一个节点$x$，有$d[l[x]]\geq d[r[x]]$

我们就把这个二叉树叫做左偏树。

### 左偏树的性质

1. $d[x]=d[r[x]]+1$
1. 对于任意一个$x$，$d[x]\leq log(n)$($n$为左偏树的大小)$(N_3)$

---

$(N_3)$


考虑一个节点$x$，会对哪些节点的距离产生贡献，数学归纳可得，如果他对$y$产生了贡献，那么$y$是以满二叉树为基础上建立的二叉树，故$y$的深度每次减$1$,$sz[y]$至少扩大两倍，故得证。

### 左偏树的操作

1. 合并:定义函数$merge(x,y)$为合并以$x$为根的左偏树和以$y$为根的左偏树，返回值为新的树根，如果$a[x]>a[y]$就交换$x,y$，然后递归进行$a[x].r[x]=merge(r[x],y)$，此时如果$d[l[x]]<d[r[x]]$就交换$l[x],r[x]$,最后令$d[x]=d[r[x]]+1$,$return\ x$，时间复杂度为$log(n)$,$(N_4)$
1. 删除：删除$x$，直接$merge(l[x],r[x])$即可，也告诉我们，可以在$log(n)$的时间复杂度删除树上任意一个节点，前提是找得到。
1. 加入一个节点，其实把一个节点看作一棵树，就和$1$一样了。

---

$(N_4)$

时间复杂度证明，其实每次递归发现$d[x],d[y]$其中至少有一个减少了$1$,因此时间复杂度为$O(log(sz[x])+log(sz[y]))$，**也侧面告诉我们不能启发式合并**。

### [模板](https://www.luogu.com.cn/problem/P3377)

## tarjan优化朱刘

### 算法流程

1. 朱刘相当于最小生成树中$B$字开头的算法,而现在介绍的优化，其实相当于$prim$。
1. 枚举每个**原图**中的节点$x$，然后不停地把边$(pre[x],x)$加入最小树形图，答案累加$in[x]$，在某一时刻发现出现了环，删除该环内部所有边，然后暴力把每个指向该环的边$(u,v)$，令边权减去$in[v]$,然后将这个环缩成一个点,然后迭代进行，直至到达根节点$r$，这样还是$O(nm)$。
1. 考虑优化，我们对于每个点$x$建一棵左偏树$T_x$，然后我们就可以在$O(1)$的时间复杂度查询一个节点的最小入边，缩环的时候直接合并左偏树即可，边权减打标记即可,因此我们需要很好的实现标记下放，一次对环的合并我们不妨及做$log(n)$，每个节点属于哪个环可以用并查集路径压缩+按秩合并，删除节点可以用延迟删除$(N_5)$，那么最终时间复杂度不难分析的出来是$O(m+nlog(n))$。

---

$(N_5)$


如果我没记错的话，应该也叫懒惰删除法


### 参考代码


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#define il inline
#define ri register
#define Size 100050
using namespace std;
int fa[Size],cnt,is[Size];
il int find(int);
il void read(int&),Union(int,int);
struct leftist{
	struct point{
		int l,r,d,v,t,to;
	}a[Size]={{0,0,-1,0,0,0}};
	int r[Size];
	il void merge(int&x,int&y){
		if(!x||!y){x^=y;return;}
		if(a[x].v>a[y].v)x^=y^=x^=y;
		a[y].t-=a[x].t,a[y].v-=a[x].t;
		merge(a[x].r,y);
		if(a[a[x].l].d<a[a[x].r].d)
			a[x].l^=a[x].r^=a[x].l^=a[x].r;
		a[x].d=a[a[x].r].d+1;
	}
	il void spread(int&p){
		a[a[p].l].t+=a[p].t,a[a[p].r].t+=a[p].t;
		a[a[p].l].v+=a[p].t,a[a[p].r].v+=a[p].t;
		a[p].t=0;
	}
	il void pop(int&x){
		spread(x),merge(a[x].l,a[x].r),x=a[x].l;
	}
	il point*top(int&x){
		while(r[x]&&!(find(a[r[x]].to)^x))pop(r[x]);
		if(!r[x])puts("-1"),exit(0);
		a[r[x]].to=find(a[r[x]].to);
		return &a[r[x]];
	}
}L;
int pre[Size];
int main(){
	int n,m,r,ans(0);leftist::point*temp;
	read(n),read(m),read(r),cnt=n,is[r]=r;
	for(int i(1),u,v,w;i<=m;++i)
		read(u),read(v),read(w),
			L.a[i]={0,0,0,w,0,u},
			L.merge(L.r[v],u=i);
	for(int i(1);i<=n<<1;++i)fa[i]=i;
	for(int i(1),j(i);i<=n;j=++i)
		while(!is[j]){
			while(!is[j])
				is[j]=i,j=(temp=L.top(j))->to,
					ans+=temp->v;if(is[j]^i)break;
			while(~is[j])
				is[j]=-1,j=pre[j]=(temp=L.top(j))->to,
					temp->t-=temp->v,temp->v=0;++cnt;
			while(is[j]^i)is[j]=i,Union(j,cnt),j=pre[j];
			j=cnt;
		}return printf("%d",ans),0;
}
il void Union(int u,int v){
	if((u=find(u))^(v=find(v)))
		L.merge(L.r[v],L.r[u]),fa[u]=v;
}
il int find(int x){
	return x^fa[x]?fa[x]=find(fa[x]):x;
}
il void read(int&x){
	x^=x;ri char c;while(c=getchar(),c<'0'||c>'9');
	while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
}
```


## 扩展知识

1. 求没有确定的根的树形图:建立一个超级根$r$，以它为根跑算法,只要将$r$向原图每个点连接一条权值大于原图中所有边的边权的边，这样选这些边肯定不划算，因此只会选择一条。
1. 判无解的奇技淫巧:从小到大依次枚举每个点$i$,加入边$(i,(i+1)\%n+1,+\infty)$,这样如果你最后得到的答案为$+\infty$，那么就无解了。


## 写在后面的话

既然你会$O(E+nlog(n))$，是不是也想谴责luogu为什么放暴力朱刘过了吗？

---

## 作者：lgswdn_SA (赞：52)

### 1 DAG的最小树形图  

一个树形图中，除了r点其他点都**只有一个入边**  

那么对于一个DAG，只要我们**对于每一个点选出最小的入边**，那么这一定是个树形图（显然，易证

那么算法就非常的简单

```cpp
for(int i=1;i<=n;i++,des=r){
	for(int j=1;j<=n;j++)
		if(e[i][j]<e[i][des]&&i!=j)
			des=j;
	ans+=e[i][des];
}
```

### 2 环的最小树形图
这个问题十分傻，显然，从r开始绕一圈少一条边就行了

### 3 真正的最小树形图
这个东西叫做朱刘算法  
好像伟大的图论专家塔扬先生有一种更好的方法，不过太烦了，没必要研究这种黑科技
![](https://cdn.luogu.com.cn/upload/image_hosting/yiueg28r.png)

我们看到，我们用DAG的算法把边分为了两种，红边就是要选的边，蓝边是因为比红边长而被抛弃的边，然后黄色的是个红边组成的环


如果我们一开始用DAG的贪心算出来的图就是一个一个DAG，那么皆大欢喜，这个环没有影响，直接输出即可  

![](https://cdn.luogu.com.cn/upload/image_hosting/6xzclqjq.png)
（这是一个逆时针的环）  

> 1处理环

那么有环呢？

一旦有个环，那么这个环在选出来的图上肯定不会被其他点连接

那我们肯定要把其中一条边换成环外边

那么如果有环，我们就把贪心算出来的那个所谓的“树形图”上的环**缩成一个点**，环外边指向这个所称的点

为了方便统计，由于我们确信环外边的长度$\ge$环内边的长度，那么我们ans先加上这个环的边权和，然后指向环的边边权设为**自己的长度-所连向的环内点在环中指向的点的边的长度**

用那张图解释一下：  

左上角的那个点，指向它的那条边，边权设为自己的长度，减去左上角的点到左下角的点的边的长度

有什么好处呢？

![](https://cdn.luogu.com.cn/upload/pic/22858.png)
(引用一下别人的别人的别人的题解的图，这张图实在太好用了，放这里做参考)

这样，我们以后再选到这条边，就**直接把它加到ans里面**，就得到了这个环和连接这个环的边的所需长度了

为什么呢？易证，易得，显然如此，  

假设环内去除的边权为$x$，连向这个环的边权为$y$，环的长度为$k$，那么这个环+连向这个环用的总长度应该是$k-x+y$，转换一下就是$k+(y-x)$，其中$y-x$就是那条连线环的边的边长

> 2 找环

说一遍，我不想TARJAN


**fa[u]**：$u$的入边另一个点，也就是$u$的“父亲”  
**tp[u]**：相当于并查集路径压缩的数组，代表$u$的当前最早前驱  
**lp[u]**：代表u是哪个环上的。如果lp=0，那么代表这个点目前还不是环上的

遍历每个节点$u$，然后沿着fa一路逆向走，直到根或者前驱是自己的点（路径压缩）或是环上点（一个点不可能处于两个环）。

如果最后走到了根，代表目前这个点还不是环上点

如果最后走到了前驱是自己的点$v$，分类讨论：

- lp[v]不是0，代表它已经是另一个环的节点，一个节点不可能同时处于两个环，不用设置新环

- lp[v]是0，代表这是发现的一个新环，给环上的每个点的id都标记上
```cpp
for(int u=1,v=1;u<=n;u++,v=u){
	while(v!=root&&tp[v]!=u&&!lp[v]) tp[v]=u,v=fa[v];
	if(v!=root&&!lp[v]){
		lp[v]=++tot;
		for(int k=fa[v];k!=v;k=fa[k]) lp[k]=tot;
	}
}
```

> 3 循环结束时间

总体的算法流程：对于每一次，求出所谓的“带环最小树形图”，然后把环缩点，修改边权

何时结束？

我们知道，一旦他是一个没有环的树形图，那么就是一个树形图了（雾

总的来说，一旦没有环，那么**所有点都能到**，那么就OK了，直接退出循环

**撒花HORRAY**

### 算法流程
对于每一次循环：  

1. 贪心找出所谓的“最小带环树形图”，（就是上面的万能图的红边）  
顺便记录一下自己是从哪里来的（入边的起点）  
2. 把所有选出的边加到ans里面  
3. 找环记录环，统计数量  
4. 如果没环，代表完成了，退出循环  
5. 把所有不是环上的点全部设置为自己是一个独立环（大小为1的新环）  
6. 重新设置边权&缩点
7. 完成缩点，重新设置n和root，然后初始化

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=109,M=10009; 
struct edge{int u,v,w;}e[M]; //用边表存储 

int n,m,root,mn[N],fa[N],tp[N],lp[N],tot,ans;
int zl(){
	while(1){
		for(int i=1;i<=n;i++) mn[i]=1e9,fa[i]=tp[i]=lp[i]=0;
		
		for(int i=1,u,v,w;i<=m;i++) //Step 1
			if(e[i].u!=e[i].v&&(w=e[i].w)<mn[v=e[i].v])
				mn[v]=w,fa[v]=e[i].u;
		mn[root]=0;
		for(int u=1;u<=n;u++){ans+=mn[u];if(mn[u]==1e9)return -1;} //Step 2
		
		for(int u=1,v=1;u<=n;u++,v=u){ //Step 3
			while(v!=root&&tp[v]!=u&&!lp[v]) tp[v]=u,v=fa[v];
			if(v!=root&&!lp[v]){
				lp[v]=++tot;
				for(int k=fa[v];k!=v;k=fa[k]) lp[k]=tot;
			}
		}
		if(!tot) return ans; //Step 4
		for(int i=1;i<=n;i++) if(!lp[i]) lp[i]=++tot; //Step 5
		
		for(int i=1;i<=m;i++) //Step 6
			e[i].w-=mn[e[i].v],e[i].u=lp[e[i].u],e[i].v=lp[e[i].v];
		n=tot, root=lp[root], tot=0; //Step 7
	}
}

int main(){
	scanf("%d%d%d",&n,&m,&root);
	for(int i=1,u,v,w;i<=m;i++)
		scanf("%d%d%d",&u,&v,&w),e[i]=(edge){u,v,w};
	printf("%d",zl());
	return 0;
}
```
最后说一下个人的想法：

最小树形图在联赛中并不常见，但是zl算法却有一个很重要的思想：见到有向有环图，可以想到缩点，然后利用DAG的特性去做题，因为许多算法在 DAG 上可以有更优/更方便的解。



---

## 作者：i207M (赞：51)

## 题意

给定一张**有向图**，求出以给定节点为根的最小树形图；树形图的定义是，从根节点出发可以到达所有其他点（所以图首先要联通）

## 实现

![](https://cdn.luogu.com.cn/upload/pic/22858.png)

![](https://cdn.luogu.com.cn/upload/pic/22859.png)

总的来说：

1. 求最短弧集合E；

2. 判断集合E中有没有有向环，如果有转步骤3，否则转4；

3. 收缩点，把有向环收缩成一个点，并且对图重新构建，包括边权值的改变和点的处理，之后再转步骤1；

4. //展开收缩点，求得最小树形图；

　　(1)求最短弧集合E0.

　　从所有以Vi(i ≠ 0)为终点的弧中取一条最短的,若对于点i,没有入边,则不存在最小树形图,算法结束;如果能取,则得到由n个点和n-1条边组成的图G的一个子图G',这个子图的权值一定是最小的,但是不一定是一棵树.
  
```
		for(ri i=1; i<=n; ++i) ine[i]=inf;  // 初始化
		for(ri i=1; i<=m; ++i)
		{
			int u=e[i].u,v=e[i].v;
			if(u!=v&&e[i].w<ine[v])  // 遍历所有边，对每个点找到最小的入边
				ine[v]=e[i].w,pre[v]=u;
		}
```

**找到以每个点为终点的边的最小值并记录；根没有入边；被缩的点忽略；如果从一个点没有入边，一定不存在树形图；**

　　(2)检查E0.

　　若E0没有有向环且不包含收缩点,则计算结束,E0就是G以V0为根的最小树形图,若E0没有有向环,但是存在收缩点,转到步骤(4),若E0含有有向环,则转入步骤(3).
  
如果没有环，那么选出来的就是树形图；否则就要缩点；

```
		for(ri i=1; i<=n; ++i) vis[i]=id[i]=0;
		for(ri i=1; i<=n; ++i)
		{
			if(i==root) continue;
			ans+=ine[i];
			int v=i;
			while(vis[v]!=i&&!id[v]&&v!=root)  // 找环
			{
				vis[v]=i;
				v=pre[v];
			}
			if(!id[v]&&v!=root)
			{
				id[v]=++cnt;  // 把环上的店标记为同一点
				for(ri u=pre[v]; u!=v; u=pre[u])
					id[u]=cnt;
			}
		}
```

**一定要记录cnt或开一个bool数组记录走过的边，不然可能疯狂走环；**

　　(3)收缩G中的有向环.

　　把G中的环C收缩成点u,对于图G中两端都属于C的边就会被收缩掉,其他弧仍然保留,得到一个新的图G1,G1中以收缩点为终点的弧的长度要变化,变化的规则是:设点v在环C中,且环中指向v的边的权值为w,点v'不在环C中,则对于G中的每一条边<v', v>,在G1中有边<v', u>和其对应,且权值WG1(<v', u>) = WG(<v', v>) - w;对于图G中以环C中的点为起点的边<v', v>,在图G1中有边<u, v'>,则WG1(<u, v'>) = WG(<v', v>).有一点需要注意,在这里生成的图G1可能存在重边.

　　对于图G和G1:

　　<1>:如果图G1中没有以v0为根的最小树形图,则图G也没有.

　　<2>:如果G1中有一v0为根的最小树形图,则可按照步骤(4)的展开方法得到图G的最小树形图.

　　所以,应该对于图G1代到(1)中反复求其最小树形图,直到G1的最小树形图u求出.
  
**缩环的时候记得加入答案，环上的出边直接接上，入边要注意，选一条入边相当于删掉一条环边，所以加入入边的权值为$w-ine[v]$**

　　(4)展开收缩点.
  
## 扩展：无根树的树形图

~~以写挂了的HDU2121为例~~

不限定根结点的树形图，我们可以虚拟一个0号根节点，并向各个点连一条权值为$sum(w)+1$的边，因为权值很大，所以最终结果一定只包含一条这样的边；但是如果答案大于$sum+sum+1$，其实是无解的，这样相当于两个点不联通，只好多选一条大边；否则答案是$ans-sum-1$

如果要输出编号最小的根节点，多解的情况一定是有环，而超级源点最后选择的一条出边一定就是最优解（多加的边按照点的编号排序）；所以我们就在找边的时候加上一句就好了；

```
if (u == root) pos = i;
```

那么答案即为pos-m-1（pos为边的编号）

## 易错

1.非常重要，不然T飞：在判环时一定要加上cnt计数，并在cnt>n时break；否则就开一个bool数组记录是否经过该点；不然可能会有一个环然后就在里面不停转；

2.缩点时，变量名不要写错……

## 代码

```
struct Edge
{
	int u,v,w;
} e[M];
const int inf=2e9;
int n,m,root;
int pre[N],ine[N];
int vis[N],id[N];
int zhuliu()
{
	int ans=0;
	while(1)
	{
		for(ri i=1; i<=n; ++i) ine[i]=inf;  // 初始化
		for(ri i=1; i<=m; ++i)
		{
			int u=e[i].u,v=e[i].v;
			if(u!=v&&e[i].w<ine[v])  // 遍历所有边，对每个点找到最小的入边
				ine[v]=e[i].w,pre[v]=u;
		}
		for(ri i=1; i<=n; ++i)  // 判定无解
			if(i!=root&&ine[i]==inf) return -1;
		int cnt=0;
		for(ri i=1; i<=n; ++i) vis[i]=id[i]=0;
		for(ri i=1; i<=n; ++i)
		{
			if(i==root) continue;
			ans+=ine[i];
			int v=i;
			while(vis[v]!=i&&!id[v]&&v!=root)  // 找环
			{
				vis[v]=i;
				v=pre[v];
			}
			if(!id[v]&&v!=root)
			{
				id[v]=++cnt;  // 把环上的店标记为同一点
				for(ri u=pre[v]; u!=v; u=pre[u])
					id[u]=cnt;
			}
		}
		if(cnt==0) break; // 无环，得到解
		for(ri i=1; i<=n; ++i)
			if(!id[i]) id[i]=++cnt;
		for(ri i=1; i<=m; ++i)
		{
			int u=e[i].u,v=e[i].v;
			e[i].u=id[u],e[i].v=id[v];
			if(id[u]!=id[v]) e[i].w-=ine[v]; // 修改边权
		}
		root=id[root];
		n=cnt;
	}
	return ans;
}
```

---

## 作者：KiDDOwithTopTree (赞：13)

~~估值快没了，赶紧写篇题解水水。~~

[传送门](https://www.luogu.com.cn/problem/P4716)。

本文将会讲到 $\texttt{Tarjan}$ 的优化朱刘算法。这种方法是我从所看过的博客中理解的，有可能有些地方我理解错了，请在评论区或私信中提出。

大家都知道朱刘算法可以做到 $O(nm)$ 求最小树形图，那有没有更快的做法呢？$\texttt{Tarjan}$ 的优化朱刘算法便可以做到 $O((n+m)\log m)$ 求最小树形图。

这个算法是对朱刘的优化，那么我们来看看朱刘算法主要有哪些步骤：

1. 求最短弧集。
2. 找环并缩环。
3. 判定无解。

#### 1. 维护最短弧集：

设以 $x$ 为终点的边的集合为 $E_x$，$E_x$ 中边权最小值为 $E_{x_{\min}}$。

在朱刘算法中关于最短弧集的操作有一下几种：

1. 查找 $E_{x_{\min}}$。
2. 找到一个环，把一个环内的节点 $a_1,a_2,...,a_k$ 缩为 $p$，把集合 $E_{a_x}$ 中所有值减去 $E_{a_{x_{\min}}}$，把 $E_{a_{x_{\min}}}$ 从集合 $E_{a_x}$ 中删去，把集合 $E_{a_1},E_{a_2},...,E_{a_k}$ 合并为 $E_p$。

我们把这些东西抽象化，那就变为 $3$ 种操作：

1. 查询最小值。
2. 整体减一个数。
3. 合并几个集合。

根据这些，我们可以发现，**可并堆**这种数据结构可以十分优秀地维护这些操作。

#### 2. 找环与缩环：

朱刘算法中结束的标志是没有环，但是这个条件未免过于苛刻，很难快速判断。那么我们干脆直接把它进阶，变为**缩成一个点**，也就是**整张图没有边**。

但是原图不可能一定强连通，那么我们需要强行使其变为强连通，就是加 $n$ 条边权为 $INF$ 的边。

我们用一个**栈**进行存储，每次将栈顶 $x$ 的**最短弧的起点** $y$ 压入栈。如果 $y$ 不在栈中，压入即可；否则说明找到一个环，在栈中把环弹出，把环缩为一个点 $p$。

在加答案时如果终点是 $r$ 或含有 $r$ 的环，那么这条边不能计入答案。因为最小树形图 $r$ 没有入边。

因为要找一个点被收缩多次后的新点，所以需要一个并查集来维护。

#### 3. 判定无解：

因为边权为 $INF$ 的边是新加入的，如果答案大于 $INF$ 则说明我们用了新加的边，也就是说原图无法形成最小树形图，即无解。

代码只有 $99$ 行，带有注释，请放心食用：
```cpp
#include<iostream>
#include<cstring>
using namespace std;
#define int long long
const int N=1e6+10,INF=0x3f3f3f3f;
struct ltt_node{
	int lson,rson;
	int val,tag;
	int from,to;
	int dis;
};
struct leftist_tree{
	ltt_node ltt[N];
	int tot;
	inline int newnode(int val,int from,int to){
		tot++;
		ltt[tot].val=val;
		ltt[tot].from=from;
		ltt[tot].to=to;
		return tot;
	}
	inline void pushdown(int now){
		int ls=ltt[now].lson,rs=ltt[now].rson;
		ltt[ls].val+=ltt[now].tag;
		ltt[rs].val+=ltt[now].tag;
		ltt[ls].tag+=ltt[now].tag;
		ltt[rs].tag+=ltt[now].tag;
		ltt[now].tag=0;
	}
	int merge(int x,int y){
		if(!x||!y) return x+y;
		pushdown(x),pushdown(y);
		if(ltt[x].val>ltt[y].val) swap(x,y);
		ltt[x].rson=merge(ltt[x].rson,y);
		if(ltt[ltt[x].rson].dis>ltt[ltt[x].lson].dis)
			swap(ltt[x].lson,ltt[x].rson);
		ltt[x].dis=ltt[ltt[x].rson].dis+1;
		return x;
	}
	int del(int rt){
		pushdown(rt);
		int ls=ltt[rt].lson;
		int rs=ltt[rt].rson;
		return merge(ls,rs);
	}
};//左偏树基本操作
leftist_tree ltt;
int root[N],fa[N];
int sta[N],top;
bool vis[N];
inline int find(int x){
	return x==fa[x]?x:fa[x]=find(fa[x]);
}//并查集，用于查找一个点被收缩多次后的新点
signed main(){
	int n,m,r;
	cin>>n>>m>>r;
	for(int i=1;i<=m;i++){
		int x,y,z;
		cin>>x>>y>>z;
		int lp=ltt.newnode(z,x,y);//新建一个左偏树节点，边从x到y，边权为z
		root[y]=ltt.merge(root[y],lp);//插入到y的左偏树中
	}
	for(int i=1;i<=n;i++){
		int x=i,y=i%n+1;
		int p=ltt.newnode(INF,x,y);
		root[y]=ltt.merge(root[y],p);
	}//加入n条边强行使其强连通
	for(int i=1;i<=2*n;i++) fa[i]=i;//算上收缩的点共有2n个点
	sta[++top]=r,vis[r]=true;
	int ans=0,cnt=n;
	while(root[sta[top]]){//还有边
		int lp=root[sta[top]];
		ltt_node tmp=ltt.ltt[lp];
		int u=find(tmp.from);
		if(u==sta[top]){
			root[sta[top]]=ltt.del(root[sta[top]]);
			continue;
		}//自环
		if(!vis[u]){
			sta[++top]=u;
			vis[u]=true;
			continue;
		}//不构成环，加入即可
		int p=++cnt;//把环缩为p
		while(vis[u]){//u还没被弹出
			int v=sta[top--];//环上的节点
			vis[v]=false,fa[v]=p;//这个点缩成了p
			int val=ltt.ltt[root[v]].val;//最短弧的边权
			ltt.ltt[root[v]].tag-=val;//懒标记
			int x=find(ltt.ltt[root[v]].to);
			ans+=(x!=find(r))*val;//如果x等于r，说明这条边通向r，不能选
			root[v]=ltt.del(root[v]);//删掉最短弧
			root[p]=ltt.merge(root[p],root[v]);//合并到p的左偏树上
		}//把整个环找出来
		sta[++top]=p;
		vis[p]=true;//把p加入
	}
	cout<<(ans>=INF?-1:ans)<<'\n';
}
```

总共有 $2n$ 个点，合并的时复为 $O(n\log m)$，每条边都会访问一次，每次访问要 $O(\log m)$，时复为 $O(m\log m)$，总时复为 $O((n+m)\log m)$。

参考资料：

[OI Wiki-最小树形图](https://oi-wiki.org/graph/dmst/)。

[yybakioi 的博客-题解 P4716 【【模板】最小树形图】](https://www.luogu.com.cn/blog/xiaojiji/solution-p4716)。

---

## 作者：qiminghaonan (赞：0)

# 正文

树形图（Directed Spanning Tree），如果你比较喜欢大词也可称为 arborescence，是指有向图的外向生成树。最小树形图问题，就是给定边带权的有向图和一个特殊节点 $r$，求权值最小的以 $r$ 为根的树形图。本文通过将该问题转化为线性规划问题给出一个求解最小树形图的算法。

首先，指向 $r$ 的边是完全无用的，我们假设不存在这样的边，于是可以将最小树形图问题通过数学语言表示如下：给定图 $G = (V, A)$，用 $a = (u, v)$ 表示 $u$ 到 $v$ 的有向边，$c_a$ 表示边权，变量 $x_a = [a~\text{被选中}]$

$$OPT = \min \sum_{a \in A} c_ax_a$$

限制条件：

$$
\begin{aligned}
&\sum_{a \in \delta^-(S)} x_a \geq 1 \kern{3.5em}
&&\forall S \subseteq V \setminus \{r\} \\
&\sum_{a \in \delta^-(\{v\})} x_a = 1 
&&\forall v \in V \setminus \{r\} \\
&x_a \in \{0, 1\}
&&\forall a \in A
\end{aligned}
$$

其中，$\delta^-(S) = \{(u, v)\in A | u \notin S, v \in S\}$。

不难证明，某子图是可行解当且仅当它满足限制条件。

上述问题并不是线性规划问题。不过，如果假定 $c_a \geq 0$（显然若存在负权边可以将所有边权作一平移除去之）， 我们可以注意到两个性质：

- 第二条限制可以去除。根据第一条限制，选择指向一个点的边仍须不少于一条，但选多条一定不会更优，因为若某解要求选多条，说明该解有环，不优。
- 第三条限制可以放松为 $x_a \geq 0$，因为选一条边“半次”或者超过一次不会更优。（想想网络流问题，我们从来就只考虑那些每条边上流量均为整数的解，尽管可能存在同样最优，流量却不全为整数的解）

于是问题变为一个线性规划问题：

$$LP = \min \sum_{a \in A} c_ax_a$$

限制条件：

$$
\begin{aligned}
&\sum_{a \in \delta^-(S)} x_a \geq 1 \kern{3.5em}
&&\forall S \subseteq V \setminus \{r\} \\
&x_a \geq 0
&&\forall a \in A
\end{aligned}
$$

注意到这个问题的限制数量仍然是指数级的，难以直接求解。相反，我们可以通过某种巧妙方法构造一组解。那么，如何证明该解最优呢？这需要用到**互补松弛定理**。构造对偶问题：

$$LP^\prime = \max \sum_{S \subseteq V \setminus \{r\}} y_S$$

限制条件：

$$
\begin{aligned}
&\sum_{S|a \in \delta^-(S)} y_S \leq c_a \kern{3.5em}
&&\forall a \in A \\
&y_S \geq 0
&&\forall S \subseteq V \setminus \{r\}
\end{aligned}
$$

互补松弛定理表明，令 $T$ 表示原始问题的解对应的边集，则构造的一对可行解都达到最优当且仅当：

 - $y_S > 0 \implies |T \cap \delta^-(S)| = 1 $
 - $a \in T \implies \sum_{S|a \in \delta^-(S)} y_S = c_a$

算法的大致思路是：先构造一对满足第二个最优性条件的可行解，再从 $T$ 中删除一些边，以使得它满足第一个最优性条件。

算法伪代码如下：

1. 初始化 $T \leftarrow \varnothing$，所有 $y_S \leftarrow 0$。
3. 当 $T$ 中不存在 $r$ 到所有点的路径：
    1. 选择一个 $(V \setminus \{r\}, T)$ 的强连通分量 $S$ 满足 $|T \cap \delta^-(S)| = 0$ 。[N1]
    2. 增大 $y_S$ 直到某个形如 $\sum_{S|a_k \in \delta^-(S)} y_S \leq c_{a_k}$ 的约束由松变紧。[N2]
    3. $T \leftarrow T \cup \{a_k\}$。
3. 按加入顺序的倒序枚举所有 $a_k \in T$：
    1. 若 $T \leftarrow T \setminus \{a_k\}$ 后，$T$ 中仍存在 $r$ 到所有点的路径，则立刻进行此操作。
4. 返回 $T$。

[N1] 这样的强连通分量一定能选出。否则，沿某强连通分量的入边一直溯源，一定会进入环路，与强连通分量的极大性矛盾。

[N2] 若不存在这样的约束，说明原图中没有指向 $S$ 的边，算法立刻结束并返回“无解”。

首先需要证明，此算法返回的 $T$ 是一棵树形图。既然 $T$ 中存在 $r$ 到所有点的路径，只需证明所有点的入度不超过 $1$。事实上，如若不然，假设 $(u_0, v), (u_1, v), \dots, (u_k, v) \in T$（依加入次序），$(u_k, v)$ 没有被移除说明所有 $r \rightarrow u_i, i < k$ 的路径都经过 $v$，于是 $(u_i, v)$ 就是多余的，将会被移除，矛盾。

其次，不难证明此算法的运行过程中，所有限制条件和第二个最优性条件始终满足。下证第一个最优性条件同样满足：

如若不然，假设存在 $y_S > 0, |T \cap y_S| > 1$，则 $S$ 曾是强连通分量。令 $T \cap y_S = \{(u_0, v_0), (u_1, v_1), \dots, (u_k, v_k)\}$（仍依加入次序），则 $(u_0, v_0)$ 是选择 $S$ 的时候加入 $T$ 的；$(u_t, v_t)$ 加入时，$S \cup \{u_0\}$ 是某更大的强连通分量的一部分。于是，$(u_k, v_k)$ 未被删除说明此时 $r \rightarrow v_k$ 的所有简单路径都经过 $u_k$，而不经过 $u_0$。这表明，之后考虑删除 $(u_0, v_0)$ 时 $(u_0, v_0)$ 会被删除，因为存在路径 $r \overset{V \setminus \{u_0\}}{\rightarrow} v_k \overset{S}{\rightarrow} v_0$，矛盾。

话说了这么多，上述算法仍然非常抽象，怎么具体实现呢？首先注意到，对偶问题的变量虽多，但是并不需要真的保存它们的值，只需要维护所有约束还能收紧多少即可。进一步注意到，所有约束都“附着”在对应的边进入的强连通分量上，并且同步收紧，并且强连通分量是一个不断合并的过程，每次取出剩余量最小的作为答案，即可想到用可并堆（需额外支持堆中所有元素集体偏移，这个打 tag 即可）维护约束的状态。

其次，怎么确定当前要处理的强连通分量也是有讲究的。第一种思路类似于最小生成树的 Bor&#x016f;vka [N3] 算法，按照轮次进行，每轮“同时”选出所有尚未与 $r$ 连通的强连通分量并找到它们约束最紧的入边。我们惊讶地发现：这正是所谓 Tarjan 优化朱刘算法的思路，而上面的推导则恰为之提供了正确性证明。

[N3] `Bor&#x016f;vka`

第二种思路，也是我采用的思路（虽然相比之下略显笨拙），则类似于 Prim 算法，不断找到当前强连通分量的入边，直到发生两种情况之一：其一，遇到了从根可达的点，那么再去找尚不可达的点；其二，成环了，缩点之后继续找。

最后，怎么除去那些多余的边呢？其实，如果想解决模板题，并不需要知道哪些边需要被除去，这是由**强对偶定理**保证的：如果原始问题有最优解，那么对偶问题也有最优解，并且最优解的目标函数值相等。换句话说，只要把每次加上的 $y_S$ 求和就是最小树形图的边权和。

但是，如果题目要求输出方案呢？事实上，以 $r$ 为起点在 $T$ 上运行 Prim 算法，边权为这条边加入 $T$ 的时间戳，保留的边即为方案。正确性证明如下：

容易看出，这个问题中边权互不相同，故 Prim 算法得到的树唯一，记作 $T^\prime$。若按算法原始描述执行得到的答案不同于 $T^\prime$，则存在某个时刻，从 $T$ 中第一次删除了属于 $T^\prime$ 的边 $(u, v)$ 。考虑此时任一路径 $r \overset{T}{\rightarrow} v$，记它和 $r \overset{T^\prime}{\rightarrow} v$ 的最后一个除 $v$ 之外的公共点为 $w$。那么 $w \overset{T}{\rightarrow} v$ 中包含一条权值大于 $(u, v)$ 的边。但是，这条边会先于 $(u, v)$ 被考虑删除，而且删除是会成功的，因为此时 $T^\prime \subseteq T$ ，删除这条边不影响可达性，矛盾。

还应当补充一句：直接在原图上运行 Prim 算法不能得到最小树形图。反例如下：

![这是一张图](https://cdn.luogu.com.cn/upload/image_hosting/f86yo18w.png)

直观理解 Prim 算法的错误原因，大概是它缺乏“全局视野”，不知道 $1 \rightarrow 3$ 的边“必选”而将之压在堆底。

# 代码

无论是否需要输出方案，算法的时间复杂度瓶颈都在可并堆相关操作，为 $\Omicron(m \log m)$。这里给出显式构造方案的代码。

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
int const N = 10005;
struct pairing_heap {
  int n;
  struct node {
    int val, lc, rs, tag;
  } tr[N];
  void init() {
    n = 0;
  }
  int newnode(int x = 0) {
    tr[++n] = {x, 0, 0, 0};
    return n;
  }
  void pushdown(int x) {
    tr[x].val += tr[x].tag;
    if (tr[x].lc) tr[tr[x].lc].tag += tr[x].tag;
    if (tr[x].rs) tr[tr[x].rs].tag += tr[x].tag;
    tr[x].tag = 0;
  }
  void decrease_subtree(int x, int val) {
    tr[x].tag -= val;
    pushdown(x);
  }
  int top(int x) {
    return tr[x].val;
  }
  void merge(int& x, int y) {
    if (!x || !y) {
      x += y;
      return;
    }
    if (tr[x].val > tr[y].val) swap(x, y);
    tr[y].rs = tr[x].lc;
    tr[x].lc = y;
  }
  void merge_right(int& x) {
    pushdown(x);
    pushdown(tr[x].rs);
    int y = tr[tr[x].rs].rs, z = tr[x].rs;
    tr[tr[x].rs].rs = 0;
    tr[x].rs = 0;
    merge(x, z);
    if (y) {
      merge_right(y);
      merge(x, y);
    }
  }
  void pop(int& x) {
    x = tr[x].lc;
    merge_right(x);
  }
  void insert(int& x, int val) {
    int y = newnode(val);
    merge(x, y);
  }
  bool empty(int x) {
    return x == 0;
  }
} hp;
int n, m, r, rt[N], id[N], ecnt; // id is UFDS for scc
struct edge {
  int u, v, c;
} e[N];
vector<int> scc_stk;
vector<pair<int, int>> to[N]; 
bool ok[N], in_stk[N], vst[N];
int getroot(int x) {
  return id[x] == x ? x : (id[x] = getroot(id[x]));
}
void unite(int x, int y) {
  id[getroot(y)] = getroot(x);
}
void add_edge(int x) {
  to[e[x].u].push_back({-ecnt, x});
  ecnt++;
}
int prim(int x) {
  int ans = 0;
  priority_queue<pair<int, int>> q;
  q.push({0, 0});
  e[0] = {x, x, 0};
  while (!q.empty()) {
    auto [t, i] = q.top();
    q.pop();
    if (vst[e[i].v]) continue;
    vst[e[i].v] = true;
    ans += e[i].c;
    for (const auto &t : to[e[i].v]) q.push(t);
  }
  return ans;
}
bool presolve() {
  for (int i = 1; i <= n; i++) id[i] = i;
  ok[r] = true;
  for (int i = 1; i <= n; i++) {
    if (ok[getroot(i)]) continue;
    scc_stk.push_back(i);
    in_stk[i] = true;
    while (true) {
      int cur = scc_stk.back();
      if (hp.empty(rt[cur])) return false;
      int selected_edge = rt[cur];
      int remcost = hp.top(rt[cur]);
      int nxt = getroot(e[selected_edge].u);
      hp.pop(rt[cur]);
      if (nxt == cur) continue;
      add_edge(selected_edge);
      hp.decrease_subtree(rt[cur], remcost);
      if (ok[nxt]) {
        for (auto t : scc_stk) {
          ok[t] = true;
        }
        break;
      }
      if (in_stk[nxt]) {
        while (scc_stk.back() != nxt) {
          unite(nxt, scc_stk.back());
          hp.merge(rt[nxt], rt[scc_stk.back()]);
          scc_stk.pop_back();
        }
      } else {
        scc_stk.push_back(nxt);
        in_stk[nxt] = true;
      }
    }
    scc_stk.clear();
  }
  return true;
}
int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  hp.init();
  cin >> n >> m >> r;
  for (int i = 1; i <= m; i++) {
    cin >> e[i].u >> e[i].v >> e[i].c;
    hp.insert(rt[e[i].v], e[i].c);
  }
  if (presolve()) cout << prim(r) << endl;
  else cout << "-1\n";
}
```

# 参考资料

本文的前半部分证明来自 [MIT lecture notes on the arborescence problem](https://math.mit.edu/~goemans/18433S07/arborescence.pdf) 。

---


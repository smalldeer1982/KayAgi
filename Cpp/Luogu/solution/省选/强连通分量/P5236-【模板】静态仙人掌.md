# 【模板】静态仙人掌

## 题目背景

这是一道静态仙人掌(Block Forest Data Structure)的模板题。   
如果您不知道什么是仙人掌，那么此处给出无向仙人掌图的定义：  
>任意一条边至多只出现在一条简单回路的无向连通图称为仙人掌。

## 题目描述

给你一个有 $n$ 个点和 $m$ 条边的仙人掌图，和 $q$ 组询问  
每次询问两个点 $u,v$，求两点之间的最短路。

保证输入数据没有重边。

## 说明/提示

**样例1解释：**  
样例1中的仙人掌是这个样子的：  
![](https://cdn.luogu.com.cn/upload/pic/52854.png)   
询问有两个，分别是询问 $1\rightarrow 9$ 和 $5\rightarrow 7$ 的最短路  
显然答案分别为 $5$ 和 $6$。

**数据范围：**   
$1\le n,q \le 10000$      
$1\le m \le 20000$   
$1\le w \le 10^5$     

保证输入数据没有重边。

请注意时限为 $300\text{ms}$      


## 样例 #1

### 输入

```
9 10 2
1 2 1
1 4 1
3 4 1
2 3 1
3 7 1
7 8 2
7 9 2
1 5 3
1 6 4
5 6 1
1 9
5 7```

### 输出

```
5
6```

## 样例 #2

### 输入

```
9 10 3
1 2 1
2 3 1
2 4 4
3 4 2
4 5 1
5 6 1
6 7 2
7 8 2
8 9 4
5 9 2
1 9
5 8
3 4```

### 输出

```
7
5
2```

# 题解

## 作者：NaCly_Fish (赞：67)

这里写一种正经一点的解法吧：在线圆方树  
****  
既然是圆方树的模板，那我们就要建树 (废话)  

圆方树的建点、连边规则是这样的：  
1、原图中的点都是圆点   
2、对于每个环，新建一个方点；这个方点和环上其它圆点连成菊花图   
3、对于不在环上的两个圆点，保留原图中的边  
根据仙人掌的性质，易证不存在相邻的两个方点。  

别忘了，我们还要确定树的边权。  
从一个点开始dfs，对于$u\rightarrow v$的边：   
- 若$u,v$都是圆点，则权值为原图中边权  
- 若$u$为方点，则权值为$v$到$u$父亲的最短路  
- 否则权值为$0$  

只是这么说，可能还不够清楚，放两张图来你们直观感受一下：  
第一张这是原图，用红色加粗表示的是非树边  
![](https://cdn.luogu.com.cn/upload/pic/53087.png)  
对于每个环，建一个方点，然后圆方树就搞好了：  
![](https://cdn.luogu.com.cn/upload/pic/53088.png)

****  
现在我们建好了树，就要考虑用它来求解啦qwq  
和普通的求树上路径一样，我们在求$u\rightarrow v$的最短路时，要求出$\text{lca}(u,v)$，设其为$p$。  
我们进行分类讨论：  

- 若$p$为圆点，那答案就是树上这两点的距离  
- 若$p$为方点，则需要找出$p$的两个儿子$A,B$，分别是$u$和$v$的祖先。由于$A,B$在一个环上，所以$\text{dis}(A,B)$可以直接求(两种情况取$\text{min}$)。此时答案为$\text{dis}(A,B)+\text{dis}(A,u)+\text{dis}(B,v)$  

这题的主要思路大概就是这样了。  
不过你也许会问：怎么找$p$的儿子$A,B$啊？  
如果你用的是倍增，那很简单。在找$\text{lca}(u,v)$是顺便求出来就好了。  
如果你用树剖，这里就稍微麻烦一点。  
考虑$p$的儿子，只有两种情况：轻儿子或重儿子。  
如果一个点是轻儿子，说明这个儿子是一个重链的顶点，从沿着重链一直向上跳就找到了。  
如果在向上跳的过程中，发现跳过了$p$，那么要找的儿子就是重儿子。  
时间复杂度$\Theta(q\log n)$

参考代码：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
#define ll long long
#define N 40003
using namespace std;

struct edge{
    int v,w;
    edge(int v=0,int w=0):v(v),w(w){}
};

vector<edge> g[N],adj[N];
int dfn[N],low[N],fa[N];
int top[N],son[N],size[N],dep[N],b[N],sum[N],dis[N];
int n,m,q,cnt,ext;

inline void read(int &x);
void print(int x);
void tarjan(int u,int f);
inline int min(int x,int y);
inline void solve(int u,int v,int w);
void dfs1(int u,int f);
void dfs2(int u,int f);
inline int lca(int u,int v); 
inline int find(int u,int f); //找到是u祖先的f的儿子

signed main(){
    int u,v,p,w,A,B,ans;
    read(n),read(m),read(q);
    ext = n; //ext 为 extra 的简写,表示额外的节点
    for(int i=1;i<=m;++i){
        read(u),read(v),read(w);
        g[u].push_back(edge(v,w));
        g[v].push_back(edge(u,w));
    }
    tarjan(1,0); //找环的同时建树
    dfs1(1,0);
    dfs2(1,1); //树剖的两遍dfs
    while(q--){
        read(u),read(v);
        p = lca(u,v);
        if(p<=n) ans = dis[u]+dis[v]-(dis[p]<<1); //编号不大于n的节点,即是圆点
        else{
            A = find(u,p),B = find(v,p); //找到儿子A,B
            ans = dis[u]+dis[v]-dis[A]-dis[B];
            if(sum[A]<sum[B]) swap(A,B); //防止出现负数,这里要swap一下
            ans += min(sum[A]-sum[B],sum[p]+sum[B]-sum[A]);
        }
        print(ans);
        putchar('\n');
    }
    return 0;
}

inline int find(int u,int f){
    int res;
    while(top[u]!=top[f]){
        res = top[u];
        u = fa[top[u]];
    }
    return u==f?res:son[f]; 
}

inline int lca(int u,int v){
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        u = fa[top[u]];
    }
    return dep[u]<dep[v]?u:v;
}

void dfs1(int u,int f){
    fa[u] = f;
    dep[u] = dep[f]+1;
    size[u] = 1;
    int v,t = -1,l = adj[u].size();
    for(int i=0;i<l;++i){
        v = adj[u][i].v;
        if(v==f) continue;
        dis[v] = dis[u]+adj[u][i].w;
        dfs1(v,u);
        size[u] += size[v];
        if(size[v]>t){
            t = size[v];
            son[u] = v;
        }
    }
}

void dfs2(int u,int f){
    top[u] = f;
    if(son[u]==0) return;
    dfs2(son[u],f);
    int v,l = adj[u].size();
    for(int i=0;i<l;++i){
        v = adj[u][i].v;
        if(v==fa[u]||v==son[u]) continue;
        dfs2(v,v);
    }
}

void tarjan(int u,int f){
    dfn[u] = low[u] = ++cnt;
    int v,w,l = g[u].size();
    for(int i=0;i<l;++i){
        v = g[u][i].v;
        if(v==f) continue; //求点双时不能走到父亲
        w = g[u][i].w;
        if(!dfn[v]){
            fa[v] = u,b[v] = w; //把u->v的边权存到v上
            tarjan(v,u);
            low[u] = min(low[u],low[v]);
        }
        else low[u] = min(low[u],dfn[v]);
        if(low[v]<=dfn[u]) continue;
        //圆点之间的连边,保留原图中数据
        adj[u].push_back(edge(v,w));
        adj[v].push_back(edge(u,w));
    }
    for(int i=0;i<l;++i){
        v = g[u][i].v;
        if(fa[v]==u||dfn[v]<=dfn[u]) continue; 
        //找到非树边,然后建方点并连边
        solve(u,v,g[u][i].w);
    }
}

inline void solve(int u,int v,int w){
    //参数w为非树边的边权
    ++ext;
    int pw,pre = w,i = v;
    while(i!=fa[u]){
        sum[i] = pre;
        pre += b[i];
        i = fa[i];
    }
    sum[ext] = sum[u]; //把整个环的边权和存到方点上
    sum[u] = 0;
    i = v;
    while(i!=fa[u]){
        pw = min(sum[i],sum[ext]-sum[i]);
        //找最短路,建树边
        adj[ext].push_back(edge(i,pw));
        adj[i].push_back(edge(ext,pw));
        i = fa[i];
    }
}

inline int min(int x,int y){
    return x<y?x:y;
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){           
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}
```

---

## 作者：mydcwfy (赞：50)

## 0. 前置知识

本蒟蒻也是最近学习这个 ~~巨毒瘤~~ 的算法，好多地方也是一头雾水，仔细想了几个晚自习后，有些恍然大悟，于是写了这篇题解。

需要的东西：Tarjan（似乎没有具体的模板）。

就是一个求边强连通分量的算法，一会我们要利用它并改进为我们所用。

还有一颗看完我的博客的心\~\~

## 1. 圆方树

其实，圆方树就是将环的作用转化为一棵树的作用，使原来的图变为了新图，许多性质没有变化，但处理树会简单许多。

以例题为例：[题目传送门](https://www.luogu.com.cn/problem/P5236)

想一想，怎样将环变为树的样子？

回归定义的一个特殊性质：

> 任意一条边至多只出现在一条简单回路的无向连通图称为仙人掌。

翻译成人话（？），就是原图由一些边不相交的环和另外的边构成。

首先，可以想到的是，将一个环缩为一个点，将整个图缩为一棵树（因为无向图中只有树和环两种形状，没有第三种，又因为没有环套环（边重合），所以一定变为一棵树）。

但是，环内的边和点间的距离就没法统计了。

我们假设任意一个点为根，那么一定会有一个点距离根节点最近。

来看一个图（ ~~盗的例题的图~~ ）

![](https://cdn.luogu.com.cn/upload/pic/52854.png)

假设七号点为根，那么，对于 "1-2-3-4" 的环，三号点距离根节点最近。

我们设最近的点具有 "A" 性质。

下面，我们证明一个东西：环内的点到根节点一定经过环内具有 "A" 性质的点。

显然，如果不经过该点的话，就不可能达到根节点。

那么，如果在树中，该点如果想向上走的话，必须经过该环的 "A" 节点。

我们就可以考虑将这种关系转化为树的节点之间的关系。

环内的节点通向 "A" 节点只可能有两条路径：顺时针和逆时针。

又由于对于每一个点，长的一条路肯定用不上，那么我们只需要存到 "A" 节点的最短距离即可。

那么，原图很大程度上就等价于新图了。

但是，对于一些题来说，我们需要判断原来的边还是环中的边变换过来的。

那么，我们可以使用 "圆方树"。

假设原来的点叫做圆点，新建的点叫做方点。

对于环内的节点，我们可以新建一个方点，向 "A" 的点连接一条权值为 0 的边，在从新点到其他点连接原来应有的权值。

现在，我们判断是不是原来的边，只需判断是不是有新建的点即可。

举个例子，上面的仙人掌建为圆方树（7 号是根节点）是：

![](https://cdn.luogu.com.cn/upload/image_hosting/lhd1whrx.png)

## 2. Tarjan 算法及变形

我们刚才讨论的范围，是在能求简单环的基础上，现在，我们的问题是，如何才能找到所有的简单环？

可能大家都会想到，直接用 Tarjan 算法，就可以去求了。

但是，有一个问题：Tarjan 求的是边双联通分量，即去掉任意一条边后，原图仍然联通，那么，原图的 "123456"6 个点，满足该要求，但他们并不属于同一个简单环，怎么办呢？

于是，需要我们改进该算法。

首先，我们回顾一下原算法。

```cpp
//来自本人缩点模板题
void Tarjan(int x)
{
	dfn[x]=low[x]=++tot;
	st[++top]=x, ins[x]=true;
	for (int i=h[x];~i;i=ne[i])
    	if (!dfn[e[i]])
    	{
    		Tarjan(e[i]);
			low[x]=min(low[x],low[e[i]]);
    	}
		else if (ins[e[i]]) low[x] = min(low[x], dfn[e[i]]);
	if (low[x]!=dfn[x]) return;
	cnt++;int now;
	do{
		now=st[top--];
		ins[now]=0; 
		bel[now]=cnt;
	}while (now!=x);
	return ;
}
```

原算法中，只要还在栈中，我们都将所有归为一个边双联通分量。

但是，现在，如果我们还遇到这种情况的话，就应该一个一个的处理为一个一个的简单环，而不是揉在一起。

所以，当我们遇到 $low[e[i]]<dfn[x]$ 的时候，我们直接倒回去，就可以倒推出一整个环的情况了。

请注意，此时 $x$ 也为其中的点。

具体来说，我们遇到这种情况时，直接 $\operatorname{build-round-square}(x,e[i],w)$，表示从 $e[i]$ 倒推，直到 $x$ 为 "A" 点，其中 $(x,e[i])$ 的权值为 $w$。

具体来说，我们遇到了这样的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/vuo9hei8.png)

~~（好像少标了一条边的权值）~~

我们知道，Tarjan 算法建了一棵搜索树，在树上进行计算。

如图，黑边就是搜索树的边，而红边就是非树边。

肉眼可见，有两个环。

对于每个节点，我们维护他在搜索树中的父亲，还有到父亲的距离。

如果相连的节点在他的下面（即不是父亲），并且他的父亲不是该节点，说明有另外一条路径（树边）可达他的儿子，我们就可以 $\operatorname{build-round-square}(x,e[i],w)$ 了。

举个例子，搜索完 1 节点后，我们找连接点，找到 5 号点，发现满足上面的性质，于是就 $\operatorname{build-round-square}(1,5,2)$ 即可以了。

如果你还感到费解，请看前面的例图，加以理解。

如果你对传参有不理解，看一下代码就知道了。

于是，我们就可以得到这样的代码：

```cpp
void add(int h[],int a,int b,int c)
{
    e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}

void build_round_square(int x,int y,int w)
{
    int sum=w;
    for (int i=y;i!=x;i=fa[i])
    {
        // cout<<i<<' ';
        s[i]=sum;
        sum+=fw[i];
    }
    stot[x]=s[x]=sum;
    add(h2,x,++square_node,0);
    for (int i=y;i!=x;i=fa[i])
    {
        stot[i]=sum;
        add(h2,square_node,i,min(s[i],stot[i]-s[i]));
    }
}

void tarjan(int x,int from)
{
    dfn[x]=low[x]=++tot;
    for (int i=h1[x],j;~i;i=ne[i])
        if (!dfn[j=e[i]])
        {
            fa[j]=x,fw[j]=w[i];
            tarjan(j,i);
            low[x]=min(low[x],low[j]);
            if (low[j]>dfn[x]) add(h2,x,j,w[i]);
        }
        else if (i!=(from^1)) low[x]=min(low[x],dfn[e[i]]);
    for (int i=h1[x],j;~i;i=ne[i])
        if (dfn[j=e[i]]>dfn[x]&&fa[j]!=x)
            build_round_square(x,j,w[i]);
}
```

## 3. 回归本题

#### 1）题意

1. 给定一个仙人掌图，有 $Q$ 次询问，询问 $u$ 和 $v$ 之间的最短路。
2. $n,q\leq10^4,m\leq2*10^4,w\leq10^5$。

#### 2）具体算法

前面的东西是总体的仙人掌转圆方树的算法，对于不同的题来说，肯定也会有一些细节不同。

当然，仙人掌的题的大概思路是：

1. 将仙人掌转化为圆方树。
2. 结合其他树的算法（树链剖分，点分治等），将本题树的写法写好。
3. 分情况，看是圆点还是方点，进行算法调整。

本题也是如此。

考虑树上怎么做。

很明显，使用倍增算法，将一个节点的 $2^k$ 次祖先存储下来。

再利用前缀和的思想，答案即为：$ans=d[a]+d[b]-2d[lca]$。

现在，我们考虑分类讨论。

首先，假设 $lca$ 是圆点，直接按上面求即可（因为会在原来的点相会）。

假设 $lca$ 是方点呢？

这说明，当到了 $lca$ 的前一层时，两个点是在同一个环上。

对于每一个节点，可以存储一个前缀和 $s[]$，即从 "A" 性质的点按同一个方向（指一个环中是同一个方向）走到该点的距离。

特别地，"A" 性质的点记为环的总权值。

那么，现在我们可以将环间的记录表示为（$x$ 表示 $a$ 到环里的节点，$y$ 表示 $b$ 到环里的节点）：$d=\min(\operatorname{abs}(s[x],s[y]),stot[x]-\operatorname{abs}(s[x],s[y]))$。

现在我们就可以完美的解决了。

## 4. 代码

还会有一些细节从代码中呈现。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=2e4+10,M=1e5+10,L=14;

int h1[N],h2[N],e[M],ne[M],w[M],idx,square_node;
/*
h1,h2分别表示原图和新图的节点的头指针
square_node表示新建的点 
*/
int dfn[N],low[N],tot;//Tarjan 算法 
int stot[N],s[N],fa[N],fw[N];
/*
stot表示所在环的总权值
s是前缀和 
fa即为搜索树中的父亲
fw表示到父亲的距离 
*/
int f[N][L+1],depth[N],dis[N];//倍增算法 
int n,m,q,A,B;//A,B表示走到同一个环中的节点 

void add(int h[],int a,int b,int c)
{
    e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}

void build_round_square(int x,int y,int w)
{
    int sum=w;
    for (int i=y;i!=x;i=fa[i])
    {
        // cout<<i<<' ';
        s[i]=sum;
        sum+=fw[i];
    }
    stot[x]=s[x]=sum;//注意s[x]要赋值为总权值 
    add(h2,x,++square_node,0);
    for (int i=y;i!=x;i=fa[i])
    {
        stot[i]=sum;
        add(h2,square_node,i,min(s[i],stot[i]-s[i]));
    }
}

void tarjan(int x,int from)
{
    dfn[x]=low[x]=++tot;
    for (int i=h1[x],j;~i;i=ne[i])
        if (!dfn[j=e[i]])
        {
            fa[j]=x,fw[j]=w[i];
            tarjan(j,i);
            low[x]=min(low[x],low[j]);
            if (low[j]>dfn[x]) add(h2,x,j,w[i]);
        }
        else if (i!=(from^1)) low[x]=min(low[x],dfn[e[i]]);
    for (int i=h1[x],j;~i;i=ne[i])
        if (dfn[j=e[i]]>dfn[x]&&fa[j]!=x)//Tarjan算法改进 
            build_round_square(x,j,w[i]);
}

void dfs(int x,int fa)//倍增算法预处理 
{
    depth[x]=depth[fa]+1;
    f[x][0]=fa;
    for (int i=1;i<=L;++i) f[x][i]=f[f[x][i-1]][i-1];
    for (int i=h2[x];~i;i=ne[i])
        if (e[i]!=fa)
        {
            dis[e[i]]=dis[x]+w[i];
            dfs(e[i],x);
        }
}

int LCA(int a,int b)
{
    if (depth[a]<depth[b]) swap(a,b);
    for (int i=L;i>=0;--i)
        if (depth[f[a][i]]>=depth[b]) a=f[a][i];
    if (a==b) return a;
    for (int i=L;i>=0;--i)
        if (f[a][i]!=f[b][i]) a=f[a][i],b=f[b][i];
    A=a,B=b;
    return f[a][0];
}

int main()
{
    memset(h1,-1,sizeof h1);
    memset(h2,-1,sizeof h2);
    scanf("%d %d %d",&n,&m,&q);
    int a,b,c;
    while (m--)
    {
        scanf("%d %d %d",&a,&b,&c);
        add(h1,a,b,c);add(h1,b,a,c);
    }
    square_node=n;
    tarjan(1,-1);
    dfs(1,0);
    while (q--)
    {
        scanf("%d %d",&a,&b);
        int lca=LCA(a,b);
        if (lca<=n) printf("%d\n",dis[a]+dis[b]-2*dis[lca]);
        else{
            int res=dis[a]-dis[A]+dis[b]-dis[B];
            res+=min(abs(s[A]-s[B]),stot[A]-abs(s[A]-s[B]));
            printf("%d\n",res);
        }
    }
    return 0;
}
```



---

## 作者：liu_yi_tong (赞：49)

这应该是联赛以前图论领域最大的毒瘤了吧。
感觉不会再有比这个更难的了。
圆方树很好理解，把每一个环上的点间联边拆掉，再向代表这个环的方点建边，这样就能构成一棵树，我们叫它圆方树。
圆方树有广义的版本，用来处理一般无向图的的问题。
这里所说的是狭义的圆方树，只用来处理仙人掌上问题。
这两种圆方树有啥区别呢？主要区别就是一个只有两个点的点双联通分量要不要建方点的区别。（这只是我口胡出来的比较明显的特征）
我们处理[静态仙人掌](https://www.luogu.com.cn/problem/P5236)这个问题时候，用的就是后面这个比较狭义的圆方树。
题目也挺好理解的，就是给一个仙人掌，求两点距离。
方法就是把仙人掌转化成圆方树，然后通过LCA来求两点间距离。
那么这道题主要的处理难点在于：
1.新图之间的边权该如何处理。
2.求出lca之后怎么求出答案。
我们一一分析：
1.新图上只有两种边：
* 如果是圆-圆边，我们选择直接保留边权。
* 如果是方-圆边，我们再次分类：
    * 如果是方点和它的父亲的连边，我们把权值设置为0.
    * 如果是方点和其子结点的连边，我们把权值设置为这个子结点到方点父亲的最短距离长度。（简单环上两点最短距离可 $O(1)$ 求）

2.基于以上的定义，我们已经可以绘制出新的图出来，那么我们考虑如何求树上连点距离。
* 直接LCA肯定是不行的，例如同一个环内的两点，他们的LCA是方点，而他们的距离却不是到方点的距离和。
* 我们需要分类讨论：
    * 我们根据上面的边权定义可以知道，一个圆点和他的祖先圆点之间的距离一定是原图上两圆点之间的距离。
    * 简单证明：（我们把一个环里的方点叫父亲结点，它的父亲就是爷爷结点了）
        * 如果这两个点在一个环内，那么那个祖先一定是这个环上的爷爷，否则不可能成为祖先关系。那么这两点间在新图上距离就是子孙圆点-方点-爷爷圆点，权值则是子孙结点到爷爷结点的最短距离，这与我们的定义相吻合。
        * 如果这两个点不在同一个环内，那么他们的距离为子孙结点-子孙结点环内的爷爷结点-环与环之间的连边-第二个环上的与第一个环的爷爷相连的点-第二个环的爷爷…………这样一直下去，我们的最开始选的那个祖先结点一定是某个环的爷爷，或是与某个爷爷相连的点，无论哪种情况，权值都是对的（爷-孙权值是对的，环环之间的连边一定是圆-圆边，权值也是原来的）
        * 其他情况可以自己模拟一下，大多数会与仙人掌的性质不符而错误，最终只剩下这两种情况。
    * 所以如果两个点的LCA是圆点，那么他们的距离就是各自到LCA的距离，与平常的树上距离是一个求法。
    * 如果两个的LCA是方点，那么他们的距离是什么呢？
        * 如果两个点的LCA是方点，那么某一个点的祖先中的LCA之前的那个祖先（也就是某个点到LCA这条链上的LCA的儿子结点）一定是与LCA这个方点在同一个环里面的。那么我们的最短距离就是：假设a，b是两个待求点，A，B是他们在LCA的环上距离他们最近的两个点（就是上面说的那个祖先），最后结果就是a到A的距离+b到B的距离+A到B的最短距离，由于a,b,A,B都是圆点，a到A，b到B距离可以直接求，剩下A到B的距离就是简单环上两点间最短距离，可以 $O(1)$ 求。

3.这就是求仙人掌图上两点间距离的方法了，最后我们看看处理细节。
主要有三个难处理的地方：
* 简单环上两点间的最短距离预处理方法
    * 我们用到前缀和的思想来处理这个问题。
    * 我们对于一个环，从一个点出发，设他为起点，随便定一个时针顺序，把这个点到环上下一个点的边权加到下一个点的sum数组里，最后处理结果时候对于环上两点u,v答案是``` min(sum[u]-sum[v],sumtot-sum[u]+sum[v]);```即u到v之间的边权与这个环上除u到v之间的边权以外的边权和。因为一个简单环上两点间只有两条路可走， $sum[u]$ 表示从起点到u的边权和， $sum[v]$ 表示起点到v的边权和，``` sum[u]-sum[v] ```就是v到u的边权和， $sumtot$ 是整个环的边权和，```sumtot-sum[u]+sum[v]就是这个环上剩下的边权```
* 如何求一个点某个祖先前面那个祖先（就是处理方点时候的那个祖先的找法）
    * 我习惯用树链剖分求LCA，所以这里说一下这种求LCA方法下的找祖先方法，如果是用倍增求LCA，据说处理会更简单一些。
    * 我们假设已经知道了u,rt,要找u到rt这条链上rt前面的那个结点。
    * 我们考虑，如果u，rt在一条重链上，那么他们的top相同，但是u和rt又不相同，所以直接```return son[rt]```即可,如果top不同，那就一直往上跳```x=fa[top[x]]```,直到top相同，如果u和rt相同，那就说明我们要找的答案是rt的一个轻儿子，记录下上一个top是谁就ok了。
* tarjan函数的细节处理
    * 这是和之前的简单环处理相结合使用的。
    * 直接放个代码吧，有注释哒：
```cpp
void tarjan(int u,int f){
	dfn[u]=low[u]=++Time;
	for(int i=head[u];i;i=edge[i].next){
		int v=edge[i].to;
		if(!dfn[v]){
			fa[v]=u;
			res[v]=edge[i].val;
	//这个操作是记录一下每个点可能的环上的上一个结点，这里默认v的父亲是u，v上保存一下u到v的边权。
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
		}else if(v!=f){
			low[u]=min(low[u],dfn[v]);
		}
		if(low[v]>dfn[u]){
			add2(u,v,edge[i].val);
			add2(v,u,edge[i].val);
		}
	//如果low[v]>dfn[u]而u与v还是相连的，那他们一定是圆-圆边，直接把原边权加入新图
	}
	for(int i=head[u];i;i=edge[i].next){
		int v=edge[i].to;
		if(fa[v]==u||dfn[v]<=dfn[u])continue;
	//如果u是某个环的起点，那他一定连接这某个环的两个点（由于仙人掌的性质，u必须也只能连接两个点）。
	//这两个点一个点是从u点出发的，他的fa值是u，剩下一个是转了一圈回来的，他一定在u之后被遍历。
	//我们要在这里找那个转了一圈回来的点（他fa值不为u，一定是由某个u的子结点遍历到的）。
		clac(u,v,edge[i].val);
	//这里u是起点，也是这个环的爷爷结点
	}
}
void clac(int u,int v,int val){
	//这里u是起点，也是这个环的爷爷结点
	belongcnt++;
	//每clac一次就有一个环。
	int preval=val,i=v;
	//这个环上其他的边权已经被保存在各个点上了，只剩下这个目前的val，它是这个环上的最后一个边权。
	while(i!=fa[u]){
		sum[i]=preval;
		//通过跳fa遍历这个环上的某一个点，并记录sum
		preval+=res[i];
		i=fa[i];
	}
	sum[belongcnt+n]=sum[u];
	//方点的sum值代表整个环的权值和，相当于我上文所说的那个sumtot
	//默认方点的是大于n的，之后好处理
	i=v;
	sum[u]=0;
	//爷爷到自己的最短距离是0
	int pw;
	while(i!=fa[u]){
		pw=min(sum[i],sum[belongcnt+n]-sum[i]);
		//由于起点是爷爷结点，所以sum[i]就是i到爷爷结点的边权和
		//找每个点到u，也就是这个环上爷爷结点的最短距离。
		add2(belongcnt+n,i,pw);
		add2(i,belongcnt+n,pw);
		i=fa[i];
	}
}
```
全码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+10;
int n,m,q;
struct E{
	int to,next,val;
}edge[maxn],edge2[maxn];
int head[maxn],tot;
int head2[maxn],tot2;
void add(int from,int to,int val){
	edge[++tot].to=to;
	edge[tot].val=val;
	edge[tot].next=head[from];
	head[from]=tot;
}
void add2(int from,int to,int val){
	edge2[++tot2].to=to;
	edge2[tot2].val=val;
	edge2[tot2].next=head2[from];
	head2[from]=tot2;
}
int low[maxn],dfn[maxn],Time,belongcnt;
int fa[maxn],res[maxn],deepval[maxn],sum[maxn];
void clac(int u,int v,int val);
void tarjan(int u,int f){
	dfn[u]=low[u]=++Time;
	for(int i=head[u];i;i=edge[i].next){
		int v=edge[i].to;
		if(!dfn[v]){
			fa[v]=u;
			res[v]=edge[i].val;
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
		}else if(v!=f){
			low[u]=min(low[u],dfn[v]);
		}
		if(low[v]>dfn[u]){
			add2(u,v,edge[i].val);
			add2(v,u,edge[i].val);
		}
	}
	for(int i=head[u];i;i=edge[i].next){
		int v=edge[i].to;
		if(fa[v]==u||dfn[v]<=dfn[u])continue;
		clac(u,v,edge[i].val);
	}
}
void clac(int u,int v,int val){
	belongcnt++;
	int preval=val,i=v;
	while(i!=fa[u]){
		sum[i]=preval;
		preval+=res[i];
		i=fa[i];
	}
	sum[belongcnt+n]=sum[u];
	i=v;
	sum[u]=0;
	int pw;
	while(i!=fa[u]){
		pw=min(sum[i],sum[belongcnt+n]-sum[i]);
		add2(belongcnt+n,i,pw);
		add2(i,belongcnt+n,pw);
		i=fa[i];
	}
}
int size[maxn],deep[maxn],son[maxn];
void dfs1(int u,int f){
	fa[u]=f;size[u]=1;
	for(int i=head2[u];i;i=edge2[i].next){
		int v=edge2[i].to;
		if(v==fa[u])continue;
		deep[v]=deep[u]+1;
		deepval[v]=deepval[u]+edge2[i].val;
		dfs1(v,u);
		size[u]+=size[v];
		if(size[v]>size[son[u]])son[u]=v;
	}
}
int top[maxn];
void dfs2(int u,int tp){
	top[u]=tp;
	if(son[u])dfs2(son[u],tp);
	for(int i=head2[u];i;i=edge2[i].next){
		int v=edge2[i].to;
		if(v==fa[u]||v==son[u])continue;
		dfs2(v,v);
	}
}
int lca(int x,int y){
	while(top[x]!=top[y]){
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		x=fa[top[x]];
	}
	if(deep[x]>deep[y])swap(x,y);
	return x;
}
int find(int x,int rt){
	int res;
	while(top[x]!=top[rt]){
		res=top[x];
		x=fa[top[x]];
	}	
	if(x==rt)return res;
	else return son[rt];
}
int solve(int x,int y,int LCA){
	if(LCA<=n){
		return deepval[x]+deepval[y]-2*deepval[LCA];
	}else{
		int X=find(x,LCA),Y=find(y,LCA);
		int ans=deepval[x]-deepval[X]+deepval[y]-deepval[Y];
		
		if(sum[X]<sum[Y])swap(X,Y);
		int Min=min(sum[X]-sum[Y],sum[LCA]-sum[X]+sum[Y]);
		return ans+Min;
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=m;i++){
		int from,to,val;
		scanf("%d%d%d",&from,&to,&val);
		add(from,to,val);
		add(to,from,val);
	}
	tarjan(1,0);
	dfs1(1,0);
	dfs2(1,1);
	for(int i=1;i<=q;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		int LCA=lca(x,y);
		printf("%d\n",solve(x,y,LCA));
	}
	return 0;
}
```

---

## 作者：Su_Zipei (赞：19)

## 广义圆方树

很久之前写过这题，不过不是用的圆方树，今天打算复习圆方树，所以来写一下这个题。

看到题解中圆方树的写法和我之前写的好像不大一样，貌似都有一种边叫圆-圆边，而在我理解的圆方树中任意一个圆点不和圆点相邻，任意一个方点不和方点相邻，也就是形状相同的不相邻，然后我人就傻了，BDFS了一下发现我的写法是广义圆方树的写法？~~果然之前没好好学~~。

但是感觉这两种写法好像又都差不多，在处理环上是一样的，对于每一个环，断开原来的边，和方点建边，边权要好好想一下，个人感觉这是圆方树比较关键的地方，定义一个环的根为这个环上 $dfn$ 序最小的点，那么每个点和方点之间的边权就是这个点和环的根的最短距离，怎么求最短距离？可以在 $dfs$ 的时候维护一个距离数组，那么对于在一个环上的两点，要么直接是两点的距离数组作差，要么是上边那条路径的补集，用环的长度去减就可以了。

所以现在建树方面就只剩下环长需要求了，对于仙人掌来说，在搜索树上一个点最多只会有一条反祖边，不然就不满足定义了，于是可以记录反祖边的权值，再加上距离数组做差的值就是环长，具体可以看一下代码，说不大清楚。

大体是上边那样，但是有两个细节，一是因为是广义圆方树，所以一个方点可能不对应一个环，而是对应着两点一线，那么把它扩成一个环即可，具体做法就是假装有一条重边。另一个是  $tarjan$
的时候记录反祖边时要判断 $dfn$ 序的大小关系，而不是直接判断有没有访问过，这貌似挺显然的但是我最开始挂了，~~wtcl~~。

最后就是查询了，查询需要注意的是如果 $lca$ 是方点的时候需要考虑最后一步的走法，因为是在一个环上走，特判一下即可。

```
#include<map>
#include<cassert>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1e5+10;
#define rint register int
struct Edge{
	int to,nxt,val;
}e[N<<1],e2[N<<1];
int h[N],idx;
void Ins(rint a,rint b,rint c){
	e[++idx].to=b;e[idx].nxt=h[a];
	e[idx].val=c;h[a]=idx;
}
int h2[N],idx2;
void Ins2(rint a,rint b,rint c){
	e2[++idx2].to=b;e2[idx2].nxt=h2[a];
	e2[idx2].val=c;h2[a]=idx2;
}
int stk[N],tp,dfn[N],low[N],Time,val[N],dis[N],dis2[N],r[N],fang;
void tarjan(rint u,rint fa){
	stk[++tp]=u;
	dfn[u]=low[u]=++Time;
	for(rint i=h[u];i;i=e[i].nxt){
		rint v=e[i].to;
		if(v==fa)continue;
		if(!dfn[v]){
			val[v]=e[i].val;
			dis[v]=dis[u]+e[i].val;
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
			if(low[v]>=dfn[u]){
				++fang;
				r[fang]=val[stk[tp]]+dis[stk[tp]]-dis[u];
				while(1){
					rint x=stk[tp--];
					rint tmp=dis[x]-dis[u];
					tmp=min(tmp,r[fang]-tmp);
					Ins2(x,fang,tmp);Ins2(fang,x,tmp);
					if(x==v)break;
				}
				Ins2(u,fang,0);
				Ins2(fang,u,0);
			}
		}else if(dfn[v]<dfn[u]){
			val[u]=e[i].val,low[u]=min(low[u],dfn[v]);
		}
	}
}
int p[N][22],d[N];
void dfs(rint u,rint fa){
	for(rint i=0;p[u][i];i++)
		p[u][i+1]=p[p[u][i]][i];
	for(rint i=h2[u];i;i=e2[i].nxt){
		rint v=e2[i].to;
		if(v==fa)continue;
		dis2[v]=dis2[u]+e2[i].val;
		p[v][0]=u;
		d[v]=d[u]+1;
		dfs(v,u);
	}
}
int n,m,q;
pair<int,int> lca(rint x,rint y){
	if(d[x]<d[y])swap(x,y);
	for(rint dt=d[x]-d[y],i=0;dt;dt>>=1,i++)
		if(dt&1)x=p[x][i];
	if(x==y)return make_pair(x,-1);
	for(rint i=15;~i;i--)
		if(p[x][i]!=p[y][i])x=p[x][i],y=p[y][i];
	if(p[x][0]<=n)return make_pair(p[x][0],-1);
	else return make_pair(x,y);
}
int main(){
	scanf("%d%d%d",&n,&m,&q);
	fang=n;
	for(rint i=1;i<=m;i++){
		rint a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		Ins(a,b,c);Ins(b,a,c);
	}
	tarjan(1,0);
	dfs(1,0);
	while(q--){
		rint u,v;
		scanf("%d%d",&u,&v);
		pair<int,int> pi=lca(u,v);
		if(pi.second==-1)printf("%d\n",dis2[u]+dis2[v]-2*dis2[pi.first]);
		else {
			rint tmp=abs(dis[pi.first]-dis[pi.second]);
			tmp=min(tmp,r[p[pi.first][0]]-tmp);
			printf("%d\n",dis2[u]+dis2[v]-dis2[pi.first]-dis2[pi.second]+tmp);
		}
	}
	return 0;
}

```

---

## 作者：shiroi (赞：11)

### Description

给定一棵仙人掌，求仙人掌两点间的最短路。

### Solution

由于本题是静态仙人掌的模板题，我们可以考虑用动态仙人掌来解决问题。

常见的动态树数据结构思想均是将任意的树通过各种方法映射成一棵平衡的树来方便地进行维护。LCT 利用 splay 维护树的每一条链剖分，再用虚边将其粘在一起来表示整棵树的结构。类比 LCT，可以构造出 Link-Cut Cactus，即利用 splay 维护仙人掌的链剖分。

下图中的仙人掌定义红色边为实边，黑色边为虚边。类似 LCT，每个节点的 preferred-child 以实边相连。对于一个环，定义其父亲 $\rm A$ 为环上的离仙人掌的根最近的节点，其重儿子 $\rm B$ 为环上最后一次 $\rm access$ 访问到的节点。$\rm A,B$ 间的最短路以实边相连，环上其他节点构成的链上也以实边相连，称之为**额外链**。额外链两端与 $\rm A,B$ 链之间的边为虚边。

![](https://s1.ax1x.com/2020/07/21/UTPnUg.png)

由于需要维护仙人掌上边的信息，可以在每条边上建立一个点来表示边的信息。

注意在执行 $\rm access$ 操作时会首先将与儿子节点间的边都变为虚边， $\rm access$ 节点 $\rm A$ 之后会首先将链上和 $\rm A$ 相连的边变为虚边，但这条边的信息仍然记录在维护 $\rm A,B$ 链的 splay 上。此时需要特判维护。

![UTiioF.png](https://s1.ax1x.com/2020/07/21/UTiioF.png)

类似 LCT 的 $\rm access$ 操作， `access(x)` 会将 $x$ 到根的最短路径上的边全部变为实边。访问到节点 $x$ 时首先判断其在splay上的前一条边是否在环上，如果不在环上就按 LCT 方法直接处理。

当 $x$ 在环上时，需要对额外链特殊处理。将环上 $\rm A,B$ 链两端都断开，然后将 $\rm A,B$ 链与额外链链接起来。之后将 $x$ 设为 splay 的根，并选择长度较短的一边链接作为新的 $\rm A,B$ 链，另一边作为额外链。

换根操作类似 LCT 的换根维护翻转标记。考虑 $\rm access$ 打翻转标记后会导致路径上经过的环 $\rm A,B$ 节点互换，并且额外链方向也会收到影响变为相反。因此对于 $\rm access$ 到的每一个环都需要检查 $\rm A,B$ 的顺序是否相反，如相反就将其交换并且给额外链再打一个反转标记。

之后的操作维护方式和LCT类似。本题中需要实现连边操作和查询两点间最短路。

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read()
{
    int x=0,f=1,c=getchar();
    while(c<48) c=='-'&&(f=-1),c=getchar();
    while(c>47) x=x*10+c-'0',c=getchar();
    return x*f;
}

const int MAXN = 1200005;
int fa[MAXN],ch[MAXN][4],val[MAXN];
int s[MAXN],rev[MAXN],flag[MAXN],st[MAXN];
int n,m,q,tot;

inline void pushr(int x)
{swap(ch[x][0],ch[x][1]),rev[x]^=1;}

inline void pushup(int x)
{
    s[x]=val[x],flag[x]=bool(ch[x][2]);
    if(ch[x][0])
    {
        s[x]+=s[ch[x][0]];
        flag[x]|=flag[ch[x][0]];
    }
    if(ch[x][1])
    {
        s[x]+=s[ch[x][1]];
        flag[x]|=flag[ch[x][1]];
    }
    if(ch[x][2])
        s[x]+=min(s[ch[x][2]],s[ch[x][3]]);
}

inline void pushdown(int x)
{
    if(!rev[x]) return;
    pushr(ch[x][0]); pushr(ch[x][1]);
    if(ch[x][2]) pushr(ch[x][2]),pushr(ch[x][3]);
    rev[x]=0;
}

inline bool notroot(int x)
{return fa[x]&&(ch[fa[x]][0]==x || ch[fa[x]][1]==x);}

inline int chk(int x)
{return ch[fa[x]][2]==x ? 2 : 3;}

inline void init(int x,int y)
{
    val[x]=s[x]=y; rev[x]=flag[x]=0;
    fa[x]=ch[x][0]=ch[x][1]=ch[x][2]=ch[x][3]=0;
}

inline void rotate(int x)
{
    int y=fa[x],z=fa[y];
    int k=ch[y][1]==x,w=ch[x][k^1];
    if(notroot(y)) fa[ch[z][ch[z][1]==y]=x]=z;
    else if(z && ch[z][2]) fa[ch[z][chk(y)]=x]=z;
    else fa[x]=z; fa[ch[y][k]=w]=y;
    fa[ch[x][k^1]=y]=x; pushup(y);
}

inline void splay(int x,int rt=0)
{
    int y=x,z=0; st[++z]=y;
    while(notroot(y)) st[++z]=y=fa[y];
    while(z) pushdown(st[z--]);
    while(notroot(x))
    {
        y=fa[x],z=fa[y];
        if(y==rt) break;
        if(notroot(y) && z!=rt)
            rotate(ch[z][1]==y^ch[y][1]==x ? x : y);
        rotate(x);
    }
    pushup(x);
}

inline void evert(int y,int x)
{
    splay(y); pushdown(x);
    int d=chk(x),p=ch[y][1];
    while(ch[p][0]) pushdown(p),p=ch[p][0];
    splay(p,y); ch[y][1]=0;
    fa[ch[y][d]=ch[x][0]]=y; ch[x][0]=0;
    pushr(ch[x][1]); fa[ch[p][1]=ch[x][1]]=p;
    ch[x][1]=0; fa[ch[p][0]=ch[y][d^1]]=p;
    fa[ch[y][d^1]=p]=y; pushup(p); pushup(y);
}

inline void access(int x)
{
    for(int y=0; x; x=fa[x])
    {
        splay(x);
        if(fa[x] && ch[fa[x]][2]) evert(fa[x],x);
        ch[x][1]=y; pushup(x); y=x;
    }
}

inline void makeroot(int x)
{access(x),splay(x),pushr(x);}

inline void split(int x,int y)
{makeroot(x),access(y),splay(y),splay(x,y);}

inline void link(int x,int y,int k)
{
    int p=tot++; init(p,k); split(x,y);
    if(fa[x]!=y) return fa[x]=p,fa[p]=y,void();
    if(!flag[y])
    {
        int z=tot++; init(z,0); fa[ch[z][2]=p]=z;
        fa[ch[z][3]=ch[x][1]]=z; fa[ch[x][1]=z]=x;
        pushup(z); pushup(x); pushup(y);
    }
}

inline int dist(int x,int y)
{split(x,y); return s[y];}

int main(int argc, char const *argv[])
{
    n=read(); m=read(); q=read(); tot=n+1;
    int x,y,w;
    for(int i=1; i<=m; ++i)
    {
        x=read(); y=read(); w=read();
        link(x,y,w);
    }
    while(q--)
        x=read(),printf("%d\n",dist(x,read()));
    return 0;
}

```

---

## 作者：LittleMoMol (赞：8)

## P5236 【模板】静态仙人掌

### 前言
我认为仙人掌是比较综合的题，涉及到了边双连通分量、最近公共祖先（甚至有些题目会用到树链剖分、动态树等等）。

所以呢，请先把下面的题掌握了再看此题

- [P8436 【模板】边双连通分量](https://www.luogu.com.cn/problem/P8436)
- [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)

[博客食用](https://www.cnblogs.com/LittleMoMol-kawayi/p/solution-LuoGu-P5236.html)

### 圆方树
因为仙人掌是有环的，这就导致求最短路的时候及其不方便，那么不妨将仙人掌做一个变形，变成一棵树，然后再进行操作，似乎就可做了。

这里引进“圆方树”，正如它的名字，圆方树中有“圆点”和“方点”两种点。圆方树该怎么建？看下面的图

![](https://cdn.luogu.com.cn/upload/image_hosting/mq4fy4pz.png)

你会发现一些有趣的性质：
- 圆方树的圆点 = 仙人掌的总点数
- 圆方树的方点 = 仙人掌的总环数

那么，圆方树具体是怎么建立的呢？

1. 选取任意一个点为圆方树的跟。
2. 如果该点在某一个环上，那么建立一个新的方点，并使该点向方点连一条权值为 0 的**有向边**，并把该点叫做这个环的“头”，再将环上其他点变成圆点，从方点依次向它们连一条权值为 k 的**有向边**。（k 是什么详见下文）
3. 如果该点不在某一个环上，那么建立若干个新的圆点，并使该点向新圆点连一条权值为 k 的**有向边**，这些新的圆点的数量是还没有遍历过的且与该点相邻的点的数量（其实说白了就是形态不变，从仙人掌那里复制过来建到圆方树里）
4. 将这些新建的点再执行第 2 步，直到所有点均被便利。

k 表示：仙人掌中该点到这个点所在环的“头”的最短距离。

### 如何维护信息

如果我们在一颗**普通的树**上要求最短路，考虑用**树上差分**,维护每个点到树根的距离，然后对于两个树上点 $a,b$ 的距离，求出它们的最近公共祖先 $p$，然后答案为 $dist[a]+dist[b]-2dist[p]$。

不过圆方树并不是这么单纯的，它需要进行分类讨论。
- 若两个点的最近公共祖先是一个圆点，那么上述求法是完全没有问题的
- 若两个点的最近公共祖先是一个方点，说明这两个点的最近公共最先在一个环上，这个就有点棘手了

对于第二个情况，我放个图可能更形象。

![](https://cdn.luogu.com.cn/upload/image_hosting/k0rtviky.png)

你会发现此时 $a,b$ 的最短距离应该为：**蓝色虚线+粉红色**或者**蓝色虚线+棕色**，那么这两种情况取最小值就是答案。

不过问题又来了，如何快速查询每个环上的两点间的距离呢，我们可以用前缀和来实现！特殊地，把每个环的“头”当作前缀和的第一个数，然后顺时针或者逆时针遍历环即可。

最后就是一堆细节了 hh

### Code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 12010, M = N * 3;

int n, m, Q, new_n;
int h1[N], h2[N], e[M], w[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int s[N], stot[N], fu[N], fw[N], fe[M];
int fa[N][14], depth[N], dist[N];
int A, B;

void add(int h[], int a, int b, int c)
{
	e[idx] = b;
	w[idx] = c;
	ne[idx] = h[a];
	h[a] = idx ++ ;
	
	return;
}

void build_circle(int x, int y, int z)
{
	int sum = z;
	for (int k = y; k != x; k = fu[k])
	{
		s[k] = sum;
		sum += fw[k];
	}
	s[x] = stot[x] = sum;
	add(h2, x, ++ new_n, 0);
	for (int k = y; k != x; k = fu[k])
	{
		stot[k] = sum;
		add(h2, new_n, k, min(s[k], sum - s[k]));
	}
	
	return;
}

void tarjan(int u, int from)
{
	dfn[u] = low[u] = ++ timestamp;
	for (int i = h1[u]; ~i; i = ne[i])
	{
		int j = e[i];
		if (!dfn[j])
		{
			fu[j] = u;
			fw[j] = w[i];
			fe[j] = i;  //fe[j]存储j由那条边下来，这样可以处理重边问题
			tarjan(j, i);
			low[u] = min(low[u], low[j]);
			if (dfn[u] < low[j]) add(h2, u, j, w[i]);
		}
		else if (i != (from ^ 1)) low[u] = min(low[u], dfn[j]);
	}
	
	for (int i = h1[u]; ~i; i = ne[i])
	{
		int j = e[i];
		if (dfn[u] < dfn[j] && fe[j] != i)
			build_circle(u, j, w[i]);
	}
	
	return;
}

void dfs_lca(int u, int father)
{
	depth[u] = depth[father] + 1;
	fa[u][0] = father;
	for (int k = 1; k <= 13; k ++ )
		fa[u][k] = fa[fa[u][k - 1]][k - 1];
	for (int i = h2[u]; ~i; i = ne[i])
	{
		int j = e[i];
		dist[j] = dist[u] + w[i];
		dfs_lca(j, u);
	}
	
	return;
}

int lca(int a, int b)
{
	if (depth[a] < depth[b]) swap(a, b);
	
	for (int k = 13; k >= 0; k -- )
		if (depth[fa[a][k]] >= depth[b])
			a = fa[a][k];
	
	if (a == b) return a;
	
	for (int k = 13; k >= 0; k -- )
		if (fa[a][k] != fa[b][k])
		{
			a = fa[a][k];
			b = fa[b][k];
		}
	A = a, B = b;
	
	return fa[a][0];
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	
	cin >> n >> m >> Q;
	new_n = n;
	memset(h1, -1, sizeof h1);
	memset(h2, -1, sizeof h2);
	while (m -- )
	{
		int a, b, c;
		cin >> a >> b >> c;
		add(h1, a, b, c);
		add(h1, b, a, c);
	}
	tarjan(1, -1);
	
	dfs_lca(1, 0);
	
	while (Q -- )
	{
		int a, b;
		cin >> a >> b;
		int p = lca(a, b);
		if (p <= n) cout << dist[a] + dist[b] - 2 * dist[p] << endl;
		else
		{
			int da = dist[a] - dist[A];
			int db = dist[b] - dist[B];
			int l = abs(s[A] - s[B]);
			int r = stot[A] - l;
			int dm = min(l, r);
			cout << da + dm + db << endl;
		}
	}
	
	return 0;
}
```

### 后语

挺麻烦的，但是理解了的话~~就好背了~~，敲代码多是一件~~美逝~~！

完结撒花~

---

## 作者：Smokey_Days (赞：7)

按照我们之前的经验，仙人掌上问题往往可以通过圆方树转化为树上问题。
我们发现，最短路在树上是一种非常容易解决的问题。只需预处理到根节点的长度然后死命跑LCA就可以了。
但是在一般图上，最短路的实时处理就会变得很困难。
我们可以尝试通过给圆方树上的边赋上特别的边权来处理这个问题。

对于圆-圆边，赋边权为原边权，这是容易理解的。
对于方点到它的父亲圆点的边，赋边权为0，对于圆点到它的父亲方点的边，赋边权为这个圆点到这个方点的父亲圆点的最短距离。 

这时候我们会遇到一个问题，就是Tarjan找环的时候找不到返祖边的边权。
解决方案是记录每一个到根节点在dfs树上的距离，然后当我们找到一个环一路找爸爸并统计长度即可。

然后是计算答案，我们发现，如果询问的两个点的最近公共祖先是一个方点，那么它们的答案不能用普通方法计算。
我一开始的想法是尝试直接用某个节点到父亲方点的边权直接计算答案，但这样会导致答案错误，原因是它无法正确地区分两个点位于圆环的同一侧还是不同侧的情况。
故而，我们需要保存原来的距离它的父亲方点的靠某一侧的距离，故而当lca是方点的时候特殊判断计算即可。 
```cpp
#include<iostream>
#include<cstdio>
#define Fv(H,A,X) for(int A=H[X];A;A=e[A].nxt)


typedef long long ll;

inline ll Min(ll A,ll B){
    return A<B?A:B;
}
inline int Min(int A,int B){
	return A<B?A:B;
}
inline ll Abs(ll A){
	return A>0?A:-A;
}
inline void Swap(int &A,int &B){
    A^=B^=A^=B;
}

struct ee{
    int v;
    ll w;
    int nxt;
}e[200005];
int h0[10005],h[20005],et=0;
inline void Eadd(int *H,int U,int V,ll W){
    e[++et]=(ee){V,W,H[U]};
    H[U]=et;
}
inline void add(int *H,int U,int V,ll W){
    Eadd(H,U,V,W);
    Eadd(H,V,U,W);
}
int dfn[20005],lw[20005],cnt=0,dep[20005],fa[20005][30];
ll dis[20005],sz[20005];
int nm=0;
int st[20005],tp=0;
inline void dfs0(int X){
    dfn[X]=lw[X]=++cnt;
    Fv(h0,i,X){
    	if(e[i].v==fa[X][0]){
    		continue;
		}
        if(!dfn[e[i].v]){
            fa[e[i].v][0]=X;
            dis[e[i].v]=dis[X]+e[i].w;
            dfs0(e[i].v);
            lw[X]=Min(lw[X],lw[e[i].v]);
    	}else{
			lw[X]=Min(lw[X],dfn[e[i].v]);
			if(e[i].v!=fa[X][0]&&dfn[e[i].v]<dfn[X]){
                ++nm;
                add(h,nm,e[i].v,0);
                ll len=e[i].w;
                for(int j=X;j^e[i].v;j=fa[j][0]){
                	len+=dis[j]-dis[fa[j][0]];
                }
                sz[nm]=len;
                ll nw=e[i].w;
                for(int j=X;j^e[i].v;j=fa[j][0]){
                    add(h,nm,j,Min(nw,len-nw));
                    sz[j]=nw; 
                    nw+=dis[j]-dis[fa[j][0]];
                }
            }
        }
        if(lw[e[i].v]>dfn[X]){
        	add(h,X,e[i].v,e[i].w);
		} 
    }
}

inline void dfs1(int X,int FA){
    dep[X]=dep[FA]+1;
    fa[X][0]=FA;
    Fv(h,i,X){
        if(e[i].v!=FA){
            dis[e[i].v]=dis[X]+e[i].w;
            dfs1(e[i].v,X);
        }
    }
}

int n,m,q;

inline ll calc(int X,int Y){
    int XX=X,YY=Y,lca;
    while(dep[XX]<dep[YY]){
        Swap(XX,YY);
    }
    for(int i=20;~i;--i){
        if(dep[XX]-(1<<i)>=dep[YY]){
            XX=fa[XX][i];
        }
    }
    if(XX==YY){
        lca=XX;
    }else{
        for(int i=20;~i;--i){
            if(fa[XX][i]!=fa[YY][i]){
                XX=fa[XX][i];
                YY=fa[YY][i];
            }
        }
        lca=fa[XX][0];
    }
    ll RT=dis[X]+dis[Y]-(dis[lca]<<1);
    if(lca>n){
        ll P=dis[XX]-dis[lca],Q=dis[YY]-dis[lca];
        RT-=(P+Q);
        RT+=Min(sz[lca]-Abs(sz[XX]-sz[YY]),Abs(sz[XX]-sz[YY]));
    }
    return RT;
}



void init(){
    scanf("%d%d%d",&n,&m,&q);
    nm=n;
    int u,v;
	ll w;
    for(int i=1;i<=m;++i){
        scanf("%d%d%lld",&u,&v,&w);
        add(h0,u,v,w);
    }
    fa[1][0]=0;
    dfs0(1);
    for(int i=1;i<=nm;++i){
        dep[i]=0,dis[i]=0;
    }
    dfs1(1,0);
    for(int j=1;j<=20;++j){
        for(int i=1;i<=nm;++i){
            fa[i][j]=fa[fa[i][j-1]][j-1];
        }
    }
    int x,y;
    for(int i=1;i<=q;++i){
        scanf("%d%d",&x,&y);
        printf("%lld\n",calc(x,y));
    }
}
int main(){
    init();
    return 0;
}


```


---

## 作者：Tenshi (赞：5)

基于 `yxc` 大佬讲解的**圆方树**的学习笔记。



## 问题

https://www.acwing.com/problem/content/362/

https://www.acwing.com/problem/content/2866/

https://www.luogu.com.cn/problem/P5236

这三题本质完全一样，是~~三倍经验~~。

题意是：给出 $n$ 点 $m$ 边的**仙人掌图**，对任意两点最短路进行查询。

>  无向仙人掌图的定义：任意一条边至多只出现在一条简单回路的无向连通图称为仙人掌。

比如下面绿色的三个图就是仙人掌，而黑色的不是。特别注意一下两个点如果存在两条不同连边也算（即下图第二个仙人掌）。



## 圆方树

因为仙人掌这样的图比较特殊，我们可以比较高效地求出任意两点间的最短路。

这里引入**圆方树**来解决。

> 网上很多资料将其作为无向图构建，而 `yxc` 大佬讲解中当作是**外向树**构建。在这个问题中两种构建方式不会影响求解，本文将其构建为**外向树**。

![](https://cdn.luogu.com.cn/upload/image_hosting/jlp373te.png)

### 构建

> 记读入的图为**原图**，构建的圆方树为**新图**。

首先，新图保留着原图的**点集**，这些点记为**圆点**。

将**原图**任意一个点（实现中指定 $1$ 号点即可）作为根节点，然后在**原图**跑一遍 dfs。

每当找到一个环的时候（使用 tarjan 算法维护），将进入环的点（也就是边双的根节点）记为**头节点**，然后在**新图**上对加一个**方点**，并让头节点向这个方点连边，边权为 $0$，同时，方点向其它点 $u$ 连边，边权为原图中的 $u$ 到根节点的**最短距离**。

下面使原图与对应新图（圆方树）的一个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/iqrlcxdh.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/wiclwqpk.png)

### 应用

构建完圆方树后，就不难用其来求两点 $u,v$ 最短路了：

- 当两点 $u,v$ 的最近公共祖先（LCA）为**圆点**时，答案就是圆方树上两点的距离，即：$dis[u, v] = d[u] + d[v] - 2d[lca(u, v)]$。（$d[u]$ 为 $u$ 到根节点的距离）
- 而当两点的 LCA 为**方点**时，记 $u,v$ 分别与环交于 $U,V$，注意到 $U,V$ 之间的距离有两种，我们需要取其中较短的，记为 $dis(u, v)_{\min}$，那么答案为 $dis(u, v)_{\min} + dis(u, U) + dis(v, V)$。

## 实现

```cpp
#include<bits/stdc++.h>
using namespace std;

#define debug(x) cerr << #x << ": " << (x) << endl
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define dwn(i,a,b) for(int i=(a);i>=(b);i--)
#define pb push_back
#define all(x) (x).begin(), (x).end()

#define x first
#define y second
using pii = pair<int, int>;
using ll = long long;

inline void read(int &x){
    int s=0; x=1;
    char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-')x=-1;ch=getchar();}
    while(ch>='0' && ch<='9') s=(s<<3)+(s<<1)+ch-'0',ch=getchar();
    x*=s;
}

const int N=2e4+5, M=1e5+5;

int n, m, Q, nwn; // nwn 是圆方树的点数

struct Edge{
	int to, w, next;
}e[M];

int h1[N], h2[N], tot;

void add(int *h, int u, int v, int w){
	e[tot].to=v, e[tot].w=w, e[tot].next=h[u], h[u]=tot++;
}

int scir[N], s[N]; // scir[u] 代表 u 所在的环的边权和，s[u] 代表 u 所在环的前缀和（可以理解为固定一个起点并顺时针/逆时针方向）的长度。
int fu[N], fw[N], fe[N]; // 分别记录 dfs 过程中 dfs 树上 u 点的父节点、u 和父节点的边权，u 和父节点所对应的边的编号。

void build_cir(int x, int y, int W){
	int S=W;
	for(int u=y; u!=x; u=fu[u]){
		s[u]=S;
		S+=fw[u];
	}
	s[x]=scir[x]=S;
	++nwn;
	for(int u=y; u!=x; u=fu[u]){
		scir[u]=S;
		add(h2, nwn, u, min(S-s[u], s[u]));
	}
	add(h2, x, nwn, 0);
}

int dfn[N], low[N], ts;

void dfs(int u, int from){
	dfn[u]=low[u]=++ts;
	for(int i=h1[u]; ~i; i=e[i].next){
		int go=e[i].to;
		if(!dfn[go]){
			fu[go]=u, fw[go]=e[i].w, fe[go]=i;
			dfs(go, i);
			low[u]=min(low[u], low[go]);
			if(dfn[u]<low[go]) add(h2, u, go, e[i].w);
		}
		else if(i!=(from^1)) low[u]=min(low[u], dfn[go]);
	}	
	
	for(int i=h1[u]; ~i; i=e[i].next){ // 把 u 作为边双的根节点所对应的环一一找出来并建立圆方树。
		int go=e[i].to;
		if(dfn[u]<dfn[go] && fe[go]!=i) build_cir(u, go, e[i].w);
	}
}

int fa[N][15], d[N], dep[N];
void get_lca(int u, int p){
	dep[u]=dep[p]+1, fa[u][0]=p;
	rep(i,1,14) fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int i=h2[u]; ~i; i=e[i].next){
		int go=e[i].to;
		d[go]=d[u]+e[i].w;
		get_lca(go, u);
	}
}

int U, V;
int lca(int u, int v){ // 推荐使用倍增法求 lca，因为能够比较方便地找到 lca 的两个儿子
	if(dep[u]<dep[v]) swap(u, v);
	dwn(i,14,0) if(dep[fa[u][i]]>=dep[v]) u=fa[u][i];
	if(u==v) return u;
	dwn(i,14,0) if(fa[u][i]!=fa[v][i]) u=fa[u][i], v=fa[v][i];
	U=u, V=v;
	return fa[U][0];
}

int main(){
	memset(h1, -1, sizeof h1);		
	memset(h2, -1, sizeof h2);		
	
	cin>>n>>m>>Q;
	nwn=n;
	rep(i,1,m){
		int u, v, w; read(u), read(v), read(w);
		add(h1, u, v, w), add(h1, v, u, w);
	}
	
	dfs(1, -1);
	get_lca(1, 0);
	while(Q--){
		int u, v; read(u), read(v);
		int p=lca(u, v);
		if(p<=n){
			cout<<d[u]+d[v]-(d[p]<<1)<<endl;
		}
		else{
			int du=d[u]-d[U], dv=d[v]-d[V];
			int t=abs(s[U]-s[V]);
			cout<<(du+dv+min(t, scir[U]-t))<<endl;
		}
	}
	
	return 0;
}
```



---

## 作者：Jayun (赞：5)

# 题目大意：

现在给出一个仙人掌图（即每条边最多只出现在一个环里），给出多个询问，每个询问求出两点的最短距离。

# 正文：

## 概述：

仙人掌是图，由于时空限制，直接求多源最短路径会超时超空，所以我们通过 **圆方树** 来将其转化为树上问题。

## 圆方树：

关于圆方树，要讲得通俗易懂，原图里每个节点都是原点，将每个环里加入一个方点，方点直接连向环内各个节点，如图：

![](https://s1.ax1x.com/2020/08/18/dMFt6x.png)

这个建方点的操作用 Tarjan 做就行了！

```cpp
inline void solve (int u, int v, int w)   //建方点 
{
	++ext;
	int minn, pre = w, i = v;
	while (i != f[u][0])
	{
		sum[i] = pre;
		pre += b[i];
		i = f[i][0];
	}
	sum[ext] = sum[u];
	sum[u] = 0;
	i = v;
	while(i != f[u][0])
	{
		minn = min(sum[i], sum[ext] - sum[i]);
		add_(ext, i, minn);
		add_(i, ext, minn);
		i = f[i][0];
	}
}

void Tarjan(int u, int fa)
{
	dfn[u] = low[u] = ++cnt;
	for (int i = head[u]; i; i = e[i].next)  //Tarjan 模板 
	{
		int v = e[i].to, w = e[i].w;
		if(v == fa) continue;
		if(!dfn[v])
		{
			f[v][0] = u;
			b[v] = w;
			dis[v] = dis[u] + w;
			Tarjan(v, u);
			low[u] = min(low[u], low[v]);
		}
		else low[u] = min(low[u], dfn[v]);
		if(low[v] <= dfn[u]) continue;    // 建圆点 
		add_(u, v, w);
		add_(v, u, w);
	}
	for (int i = head[u]; i; i = e[i].next)  //找到非树边（环），建方点 
	{
		int v = e[i].to;
		if(f[v][0] == u || dfn[v] <= dfn[u]) continue;  
		solve(u, v, e[i].w);
	}
}

```

---

对于剩下的问题——两点距离，先找到 $u,v$ 的最近公共祖先 $a$，$a$ 是圆点直接求。如果是方点：

![](https://s1.ax1x.com/2020/08/18/dMZMFS.png)

假设 $u,v$ 父亲分别是 $A,B$，发现如果是方点，答案就是 $\operatorname{dis}(A,B)+\operatorname{dis}(u,A)+\operatorname{dis}(v,B)$。

```cpp
ll lca (int X, int Y)
{
	int Lca, x = X, y = Y;
	if (d[x] > d[y])
	{
		int t = x;
		x = y;
		y = t;
	}
	for (int i = 20; i >= 0; i--)
		if (d[f[y][i]] >= d[x])
			y = f[y][i];
	if (x == y) Lca = x;
	else
	{
		for (int i = 20; i >= 0; i--)
			if (f[x][i] != f[y][i])
			{
				x = f[x][i];
				y = f[y][i];
			}
		Lca = f[y][0];
	}
	ll calc = dis[X] + dis[Y] - (dis[Lca] << 1);
	if(Lca > n)
	{
		calc -= (dis[x] - dis[Lca]) + (dis[y] - dis[Lca]);
		calc += min(abs(sum[y] - sum[x]), sum[Lca] - abs(sum[y] - sum[x]));
	}
	return calc;
}
```

# 全部代码：

初始图和圆方树记得分着存。

```cpp

struct edge
{
	int from, to, next, w;
}e[M], ne[M];
int head[N], h[N], tot, total;

void add(int u, int v, int w)
{
	e[++tot] = (edge){u, v, head[u], w}, head[u] = tot;
}
void add_(int u, int v, int w)
{
	ne[++total] = (edge){u, v, h[u], w}, h[u] = total;
}

int dfn[N], low[N], f[N][22], cnt, d[N], b[N]; //b[u]表示u到父节点的价值 
ll dis[N], sum[N];
inline void solve (int u, int v, int w)   //建方点 
{
	++ext;
	int minn, pre = w, i = v;
	while (i != f[u][0])
	{
		sum[i] = pre;
		pre += b[i];
		i = f[i][0];
	}
	sum[ext] = sum[u];
	sum[u] = 0;
	i = v;
	while(i != f[u][0])
	{
		minn = min(sum[i], sum[ext] - sum[i]);
		add_(ext, i, minn);
		add_(i, ext, minn);
		i = f[i][0];
	}
}

void Tarjan(int u, int fa)
{
	dfn[u] = low[u] = ++cnt;
	for (int i = head[u]; i; i = e[i].next)  //Tarjan 模板 
	{
		int v = e[i].to, w = e[i].w;
		if(v == fa) continue;
		if(!dfn[v])
		{
			f[v][0] = u;
			b[v] = w;
			dis[v] = dis[u] + w;
			Tarjan(v, u);
			low[u] = min(low[u], low[v]);
		}
		else low[u] = min(low[u], dfn[v]);
		if(low[v] <= dfn[u]) continue;    // 建圆点 
		add_(u, v, w);
		add_(v, u, w);
	}
	for (int i = head[u]; i; i = e[i].next)  //找到非树边（环），建方点 
	{
		int v = e[i].to;
		if(f[v][0] == u || dfn[v] <= dfn[u]) continue;  
		solve(u, v, e[i].w);
	}
}

queue<int> que;

void dfs (int x, int fa)
{
	d[x] = d[fa] + 1;
	f[x][0] = fa; 
	for (int i = h[x]; i; i = ne[i].next)
	{
		int y = ne[i].to;
		if(y == fa) continue;
		dis[y] = dis[x] + ne[i].w;
		dfs (y, x);
	}
	 
} 

ll lca (int X, int Y)
{
	int Lca, x = X, y = Y;
	if (d[x] > d[y])
	{
		int t = x;
		x = y;
		y = t;
	}
	for (int i = 20; i >= 0; i--)
		if (d[f[y][i]] >= d[x])
			y = f[y][i];
	if (x == y) Lca = x;
	else
	{
		for (int i = 20; i >= 0; i--)
			if (f[x][i] != f[y][i])
			{
				x = f[x][i];
				y = f[y][i];
			}
		Lca = f[y][0];
	}
	ll calc = dis[X] + dis[Y] - (dis[Lca] << 1);
	if(Lca > n)
	{
		calc -= (dis[x] - dis[Lca]) + (dis[y] - dis[Lca]);
		calc += min(abs(sum[y] - sum[x]), sum[Lca] - abs(sum[y] - sum[x]));
	}
	return calc;
}

int main()
{
	scanf ("%d%d", &n, &m);
	ext = n;
	for (int i = 1; i <= m; ++i)
	{
		int u, v, w;
		scanf ("%d%d%d", &u, &v, &w);
		add(u, v, w);
		add(v, u, w);
	}
	f[1][0] = 0;
	Tarjan(1, 0);
	for (int i = 1; i <= ext; i++)
		d[i] = 0, dis[i] = 0;
	dfs(1, 0);
	for (int j = 1; j <= 20; j++)
		for (int i = 1; i <= ext; i++)
			f[i][j] = f[f[i][j - 1]][j - 1];
	scanf ("%d", &q);
	for (int i = 1; i <= q; ++i)
	{
		int x, y;
		scanf ("%d%d", &x, &y);
		printf("%lld\n", lca(x, y));
	}
	return 0;
}

```

---

## 作者：zhy12138 (赞：4)

这题是个圆方树板子

考虑把原图的点当做圆点，每一个环中间建一个方点

抓住一号点把仙人掌提起来，然后从一个环的顶点向方点连长为0的边，方点向环上其它点连长为这个点到顶点的距离的边

其实就是把一个环上的点到顶点的距离归到这个环的顶点上

这样你自下而上穿过这个环的算得的距离就是在树上的距离

所以询问就是在圆方树上求路径距离，特判一下如果lca是方点，也就是需要从左往右穿过环的距离

这个距离可以记录点在环上按一个方向走的距离和环的总长求解

这篇题解主要讲一些要处理的细节问题

**以下内容都是我自己yy的，也不知道对不对，但是它过了你谷的数据，所以如果有大神hack了我麻烦告诉我，毕竟我太菜了/kk**

# 关于重边产生的环的处理
这题数据里没有保证没有重边，但是我看前几篇题解似乎在tarjan里都是传的父节点的标号，然后强制不让tarjan往父节点走

但是这样显然就无法计算到大小为2的环了，当然这道题是求最短距离，还可以把边去重取最短的

我的想法是记录边的编号，然后强制不走过来的边，这样重边也可以被算到了

# 如何把一个环拿出来

这个地方我之前是从环的顶点出发，暴力枚举边，一个点一个点地找，特地写了个函数，特别麻烦，而且复杂度好像是错的？

我们知道tarjan过程中栈里存的点是按环上顺序排布的，那我们有没有什么办法在按顺序取出点的同时取出边呢？

我的想法是在每个点上维护一个标记表示环上遍历到它的边的长度，这样一个点就对应一条边，按顺序取点就是按顺序取边

想象一下tarjan其实实在dfs树上遍历，走到树边就递归，走到非树边就更新一下`low[]`

那么我们这个标记也是基于这个思路维护，对于一条边$ (u \rightarrow v,l) $

+ 若其为非树边就把 $v$ 的标记更新为 $l$
	
  因为这样的非树边一定对应了一个环，这条边就是把在dfs树上把这个环合上的边

+ 若其为树边就在递归完以后把 $v$ 的标记更新为 $l$

  这里在递归完以后更新是因为 $v$ 在作为环上的一个点的同时可能是若干个环的顶点，所以它的标记可能被更新过

似乎跟神鱼写的差不多？

这样实现就不需要写一个跟tarjan一样长的连边函数了

下面放一下代码
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<iomanip>
#include<cstring>
#include<algorithm>
#include<ctime>
#define ll long long
using namespace std;
int read()
{
	int kkk=0,x=1;
	char c=getchar();
	while((c<'0' || c>'9') && c!='-') c=getchar();
	if(c=='-') c=getchar(),x=-1;
	while(c>='0' && c<='9') kkk=kkk*10+(c-'0'),c=getchar();
	return kkk*x;
}
int n,m,q,head[MAXN*2],tot=1,headn[MAXN*2],totn;
struct node
{
	int to,nextn,l;
}a[MAXN*2*2],an[MAXN*2];
void ADD(int from,int to,int l)
{
	a[++tot].to=to,a[tot].nextn=head[from],a[tot].l=l;
	head[from]=tot;
}
void ADDn(int from,int to,int l)
{
	an[++totn].to=to,an[totn].nextn=headn[from],an[totn].l=l;
	headn[from]=totn;
}
int size[MAXN],fa_len[MAXN],len[MAXN];
int dfn[MAXN],low[MAXN],tim,z[MAXN],top;
void tarjan(int u,int from)
{
	dfn[u]=low[u]=++tim;
	z[++top]=u;
	for(int i=head[u];i!=0;i=a[i].nextn)
	{
		int v=a[i].to;
		if(!dfn[v])
		{
			tarjan(v,i);
			low[u]=min(low[u],low[v]);
			fa_len[v]=a[i].l;
			if(low[v]==dfn[u])
			{
				++n;
				int las=0,cnt=1,mem=totn;
				size[n]=fa_len[u];
				ADDn(u,n,0);
				do
				{
					las=z[top--];
					ADDn(n,las,len[las]=size[n]);
					size[n]+=fa_len[las];
					++cnt;
				}while(las!=v);
				for(int j=mem+1;j<=totn;++j) an[j].l=min(an[j].l,size[n]-an[j].l);
			}
			else if(low[v]>dfn[u]) --top,ADDn(u,v,a[i].l);
		}
		else if(i!=(from^1)) low[u]=min(low[u],dfn[v]),fa_len[v]=a[i].l;
	}
}
int deep[MAXN],jump[MAXN][22],dis[MAXN][22];
void format(int u,int fa)
{
	deep[u]=deep[fa]+1;
	int LOG=log2(deep[u]);
	jump[u][0]=fa;
	for(int i=1;i<=LOG;++i)
	{
		jump[u][i]=jump[jump[u][i-1]][i-1];
		dis[u][i]=dis[u][i-1]+dis[jump[u][i-1]][i-1];
	}
	for(int i=headn[u];i!=0;i=an[i].nextn)
	{
		int v=an[i].to;
		if(v==fa) continue;
		dis[v][0]=an[i].l;
		format(v,u);
	}
}
int ans;
int LCA(int &x,int &y)
{
	if(deep[x]<deep[y]) swap(x,y);
	int C=deep[x]-deep[y],LOG=log2(C);
	for(int i=0;i<=LOG;++i) if(C&(1<<i)) ans+=dis[x][i],x=jump[x][i];
	if(x==y) return x;
	LOG=log2(deep[x]);
	for(int i=LOG;i>=0;--i) if(jump[x][i]!=jump[y][i])
	{
		ans+=dis[x][i]+dis[y][i];
		x=jump[x][i],y=jump[y][i];
	}
	return jump[x][0];
}
int main()
{
	n=read(),m=read(),q=read();
	for(int i=1;i<=m;++i)
	{
		int u=read(),v=read(),l=read();
		ADD(u,v,l);
		ADD(v,u,l);
	}
	int tmp=n;
	for(int i=1;i<=tmp;++i) if(!dfn[i]) tarjan(i,0);
	format(1,0);
	while(q--)
	{
		ans=0;
		int x=read(),y=read(),lca=LCA(x,y);
		if(lca>tmp) printf("%d\n",ans+min(abs(len[x]-len[y]),size[lca]-abs(len[x]-len[y])));
		else if(x==y) printf("%d\n",ans);
		else printf("%d\n",ans+dis[x][0]+dis[y][0]);
	}
	return 0;
}
```

---

## 作者：紬文德斯 (赞：4)

题目链接[https://www.luogu.org/problemnew/show/P5236](https://www.luogu.org/problemnew/show/P5236)

Tip:在[我的洛谷博客](https://www.luogu.org/blog/TsumugiWenders/luogu-p5236-mu-ban-jing-tai-xian-ren-zhang-yuan-fang-shu-post)里阅读效果极佳

(番外话)好了好了圆方树搞定了 打程序全程靠概念 yy 加上各种判断 感觉自己打的很毒瘤就是了 不过也就 4KBytes 不到

感谢 @Harry_bh 提供的 hack 数据 让我受益匪浅~~(虽然到现在还是本机AC提交RE)~~

感谢@NaCly_Fish 和 @142857cs 提供的建议和各类帮助 以及耐心地解决本紬的低智商问题emmm

还有能不能把这题给弄成 提高+/省选- 啊各位 这板子真的没黑题那么难

话说打圆方树我用的是树剖嘛 像我这种会树剖不会倍增 会线段树不会树状数组的 实在是很少见了 ~~然而下周就要退役了~~

而且我的代码太奇怪了感觉肯定很有问题 可能....会乱讲一通

## 构造

搬一下 ImmortalCO 的课件里面的几句话

考虑为边设定边权，先随便取一个圆点当根，所有圆圆边的边权和 原图中一致

对于每一条圆方边： 如果它是方点的父边，则定义它的边权为 0，否则定义其边权为 「这个圆点到方点的父亲的最短路的长度」

现在，如果两点的 LCA 是圆点，则两点的最短路就是两点的圆方树上带权距离（所有环都在已经决定了走较短一侧）

否则，我们还需要考虑 LCA 这个环走哪一侧，用树链剖分或倍增 求出询问的两个点分别是在这个方点的哪两个子树中（即求出是环上的哪两个点），然后环上取较短的一侧


这里我参(zhao)照(ban)了 [仙人掌图II](https://www.luogu.org/problemnew/show/P4244)这道题目的大佬们的遍历方法 然后在找到环的时候 将其 环权值 赋值到 即将连接的方点上

我们没必要每个点转一次环环 沿环遍历的同时 我们是从一边到达该点的 记录下来 循环完一圈后整个环的权值也记录下来了 然后再一个点一个点将 之前那段路的权值 和 环减去那段路的值 取 min 即可

下放一下这段代码

```cpp
void getcir(int x,int y) {
	int len = tep[y] - tep[x] + 1,t = len; //len记录环上点数 t是指针
	ll lon = 0; //lon记录当前走的边的权值和
	for (int p = y ; p != x ; p = ta[p]) bot[t--] = p; bot[t] = x; //通过父亲数组取点
	for (int h = 1 ; h < len ; )
	for (int a = est[bot[h]],b = e[a].to ; ; a = e[a].ne,b = e[a].to)
		if (b == bot[h + 1]) {lon = lon + e[a].v,dis[++h] = lon; break;}
	for (int a = est[y],b = e[a].to ; ; a = e[a].ne,b = e[a].to)
		if (b == x) {lon = lon + e[a].v; break;} //搜环权值
	cir[++m] = lon; //记录环权值
	for (int a = 1 ; a <= len ; ++ a) addf(bot[a],m,min(lon - dis[a],dis[a]));
} //(上面)圆方加边
void tarjan(int p) { //用tarjan找环
	dfn[p] = low[p] = ++tnt;
	for (int a = est[p],b = e[a].to ; a ; a = e[a].ne,b = e[a].to)
	if (b != ta[p]) {
		!dfn[b] ? tep[b] = tep[p] + 1,ta[b] = p,tarjan(b),low[p] = min(low[p],low[b])
				: low[p] = min(low[p],dfn[b]);
		if (low[b] > dfn[p]) addf(p,b,e[a].v);
	}
	for (int a = est[p],b = e[a].to ; a ; a = e[a].ne,b = e[a].to)
		if (ta[b] != p && dfn[p] < dfn[b]) getcir(p,b);
}
```


那么构造说完了 我们来讲

## 建树
@142857cs 提供了树上前缀和的思路 感觉很好但我太顽固了实在是不想打~~(而且打了这就不是树剖题解了)~~ 于是树剖加上线段树存权值

就是树剖模板的两个dfs啦 不过注意在 dfs1里要加上边权化点权 如果不会树剖边化点的可以去看看[这个板子题](https://www.luogu.org/problemnew/show/P4114)

直接放代码了 这是两个深搜

```cpp
void dfs1(int p) {
	dep[p] = dep[fa[p]] + 1,++siz[p];
	for (int a = fst[p],b = f[a].to ; a ; a = f[a].ne,b = f[a].to)
		if (b != fa[p]) {
		v[b] = f[a].v,fa[b] = p,dfs1(b),siz[p] += siz[b];//这里的v就是边化点
		if (siz[son[p]] < siz[b]) son[p] = b;
	}
}
void dfs2(int p,int an) { //an就是ancestor了,由于一些重名的原因..
	top[p] = an;
	id[p] = ++tot;
	oid[tot] = p;
	if (!son[p]) return;
	dfs2(son[p],an);
	for (int a = fst[p],b = f[a].to ; a ; a = f[a].ne,b = f[a].to)
		if (b != fa[p] && b != son[p]) dfs2(b,b);
}
```

这是一个建树

```cpp
void build(int l,int r,int len) {
	if (l == r) {tr[len] = v[oid[l]]; return;}
	int mid = (l + r) >> 1;
	build(l,mid,len << 1);
	build(mid + 1,r,len << 1 | 1);
	tr[len] = tr[len << 1 | 1] + tr[len << 1];
}
```

## 查询

查询着实是毒瘤

考虑方点圆点？不止！

这里再次感谢 @Harry_bh 让误入歧途的我改过自新步入正轨

因为方点下面跳的两个点可能是两轻边呢=-= 那么下面来讲讲

**lca 为圆点**

直接搜索搜完了看看顶上那个点序号是不是大于 n 就好了

**lca 为方点**

首先我们要减去方点连的两圆点的权值

因为点权记录的是这个圆点到方点的父亲的最短路的长度 我们最后又不一定要跑到方点父亲那里 我们可以绕啊

然后下面来说说边的问题 首先我们需要两个前驱

如果两个都是轻边 那么可以通过前驱来记录

如果其中一个是重边 那么我们就要把从重边跳上来的那个点的前驱改成 lca 的 重儿子 不然都不知道掉到哪里去了

那放一下代码 首先是求 lca 的

```cpp
ll out(int x,int y) {
	int fx = x,fy = y;//前驱 这个不赋值都可以
	ll ans = 0;
	while (top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]]) swap(x,y),swap(fx,fy);
		ans += get(1,m,1,id[top[x]],id[x]);
		fx = top[x],x = fa[top[x]];
	} //跳树剖
	if (x != y) {
		if (dep[x] > dep[y]) swap(x,y),swap(fx,fy);
		ans += get(1,m,1,id[x] + 1,id[y]);
	} //记录终焉路径
	if (x <= n) return ans; //lca为圆点赶快退掉
	if (fy[fa] != fx[fa]) fy = son[x]; //把重链上的点提上来
	ans = ans - v[fx] - v[fy]; //减去多余路径
	if (tep[fx] > tep[fy]) swap(fx,fy); //这个因为父亲数组的原因要按dep排
	return ans + geft(fx,fy,cir[x]);
}
```

然后是 get 和 geft 这两个东西

get 就是线段树找连续一段的权值 这个树剖模板里有的 不多加阐述

geft 其实就是找两点的最短路径啦 某hkr 说这个也可以搞前缀记录 不过我太懒了 每个询问又跑了一遍环 于是变得超级慢

所以应该是会被 hack 的 因为假如查询的环大 我这个要跑大半圈......

注释放代码里面吧

```cpp
ll get(int l,int r,int len,int i,int j) {
	if (i <= l && r <= j) return tr[len];
	int mid = (l + r) >> 1; ll ans = 0;
	if (i <= mid) ans += get(l,mid,len << 1,i,j);
	if (mid < j) ans += get(mid + 1,r,len << 1 | 1,i,j);
	return ans;
}
ll geft(int x,int y,int cirdis) { //cirdis是环的总权值 之前tarjan的时候记录了的
	ll ans = 0;
	for (int p = y ; p != x ; p = ta[p]) //通过父亲找到两点距离
	for (int a = est[p],b = e[a].to ; a ; a = e[a].ne,b = e[a].to)
	if (b == ta[p]) {ans = ans + e[a].v; break;}
	return min(cirdis - ans,ans); //取最小 因为两条路嘛
}
```

好了 接下来是总代码 随便加点注释吧

```cpp
#include <algorithm>
#include <cstring>
#include <cstdio>
#define N 20010
#define M 100010
#define ll long long
#define swap std::swap
inline int re() {
	int x = 0; char w = getchar();
	while (w < '0' || w > '9') w = getchar();
	while ('0' <= w && w <= '9') x = x * 10 + w - 48,w = getchar();
	return x;
}
struct edge{int ne,to; ll v;}e[M],f[M];
int est[N],fst[N],dfn[N],low[N],tep[N],bot[N],ta[N],fr[N]; //这些是找环用的
int siz[N],son[N],dep[N],top[N],oid[N],fa[N],id[N]; //这些是树剖用的 名字比较像
int tr[N << 2],v[N];
int tot,tnt,n = re(),m = re(),q = re();
ll cir[N],dis[N];
template <typename T> T min(T x,T y) {return x < y ? x : y;}
void adde(int x,int y,int z) {
	e[++tot].ne = est[x],e[tot].to = y,e[tot].v = z,est[x] = tot;
	e[++tot].ne = est[y],e[tot].to = x,e[tot].v = z,est[y] = tot;
}
void addf(int x,int y,ll z) {
	f[++tot].ne = fst[x],f[tot].to = y,f[tot].v = z,fst[x] = tot;
	f[++tot].ne = fst[y],f[tot].to = x,f[tot].v = z,fst[y] = tot;
}
void getcir(int x,int y) {
	int len = tep[y] - tep[x] + 1,t = len;
	ll lon = 0;
	for (int p = y ; p != x ; p = ta[p]) bot[t--] = p; bot[t] = x;
	for (int h = 1 ; h < len ; )
	for (int a = est[bot[h]],b = e[a].to ; ; a = e[a].ne,b = e[a].to)
		if (b == bot[h + 1]) {lon = lon + e[a].v,dis[++h] = lon; break;}
	for (int a = est[y],b = e[a].to ; ; a = e[a].ne,b = e[a].to)
		if (b == x) {lon = lon + e[a].v; break;}
	cir[++m] = lon;
	for (int a = 1 ; a <= len ; ++ a) addf(bot[a],m,min(lon - dis[a],dis[a]));
} //找环加方点 顺便记录环长度
void tarjan(int p) {
	dfn[p] = low[p] = ++tnt;
	for (int a = est[p],b = e[a].to ; a ; a = e[a].ne,b = e[a].to)
	if (b != ta[p]) {
		!dfn[b] ? tep[b] = tep[p] + 1,ta[b] = p,tarjan(b),low[p] = min(low[p],low[b])
				: low[p] = min(low[p],dfn[b]);
		if (low[b] > dfn[p]) addf(p,b,e[a].v);
	}
	for (int a = est[p],b = e[a].to ; a ; a = e[a].ne,b = e[a].to)
		if (ta[b] != p && dfn[p] < dfn[b]) getcir(p,b);
}
void dfs1(int p) {
	dep[p] = dep[fa[p]] + 1,++siz[p];
	for (int a = fst[p],b = f[a].to ; a ; a = f[a].ne,b = f[a].to)
		if (b != fa[p]) {
		v[b] = f[a].v,fa[b] = p,dfs1(b),siz[p] += siz[b];
		if (siz[son[p]] < siz[b]) son[p] = b;
	}
}
void dfs2(int p,int an) {
	top[p] = an;
	id[p] = ++tot;
	oid[tot] = p;
	if (!son[p]) return;
	dfs2(son[p],an);
	for (int a = fst[p],b = f[a].to ; a ; a = f[a].ne,b = f[a].to)
		if (b != fa[p] && b != son[p]) dfs2(b,b);
}
void build(int l,int r,int len) {
	if (l == r) {tr[len] = v[oid[l]]; return;}
	int mid = (l + r) >> 1;
	build(l,mid,len << 1);
	build(mid + 1,r,len << 1 | 1);
	tr[len] = tr[len << 1 | 1] + tr[len << 1];
}
ll get(int l,int r,int len,int i,int j) {
	if (i <= l && r <= j) return tr[len];
	int mid = (l + r) >> 1; ll ans = 0;
	if (i <= mid) ans += get(l,mid,len << 1,i,j);
	if (mid < j) ans += get(mid + 1,r,len << 1 | 1,i,j);
	return ans; //线段树查询链上权值和
}
ll geft(int x,int y,int cirdis) {
	ll ans = 0;
	for (int p = y ; p != x ; p = ta[p])
	for (int a = est[p],b = e[a].to ; a ; a = e[a].ne,b = e[a].to)
	if (b == ta[p]) {ans = ans + e[a].v; break;}
	return min(cirdis - ans,ans);
} //找环上距离通过之前的ta数组找较深点的父亲跳上去 然后取最小值
ll out(int x,int y) {
	int fx = x,fy = y; //记前驱
	ll ans = 0;
	while (top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]]) swap(x,y),swap(fx,fy);
		ans += get(1,m,1,id[top[x]],id[x]);
		fx = top[x],x = fa[top[x]];
	} //跳树剖
	if (x != y) {
		if (dep[x] > dep[y]) swap(x,y),swap(fx,fy);
		ans += get(1,m,1,id[x] + 1,id[y]);
	}
	if (x <= n) return ans; //如果lca是圆点就跳出去
	if (fy[fa] != fx[fa]) fy = son[x];
	ans = ans - v[fx] - v[fy]; //如果是方点就去掉方点下面两点权值
	if (tep[fx] > tep[fy]) swap(fx,fy);
	return ans + geft(fx,fy,cir[x]); //跑环
}
int main() {
	for (int z,y,x ; m > 0 ; -- m) x = re(),y = re(),z = re(),adde(x,y,z);
	m = n,tot = 0,tarjan(1),dfs1(1),tot = 0,dfs2(1,1),build(1,m,1); //m到后来是存圆方树上点数的
	for (int y1,x1 ; q > 0 ; -- q) x1 = re(),y1 = re(),printf("%lld\n",out(x1,y1));
	return 0;
}
```

---

## 作者：Rainsleep (赞：3)

## 前言

这有可能是我写过最长的一篇题解，本篇文章中将会花费大量笔墨讲解仙人掌的定义、转化、以及处理。

本篇文章由于笔者太菜了，所以如果出现错误欢迎各位同学斧正~

**前置芝士：最近公共祖先，边双联通分量，~~圆方树~~**

## $\text{Solution}$

仙人掌的定义题面已经给出了，即：
>任意一条边至多只出现在一条简单回路的无向连通图称为仙人掌。

![](https://cdn.luogu.com.cn/upload/image_hosting/y9xho92v.png)

仙人掌大概长成上面这个样子，也确实很类似于现实中仙人掌的模样，不难发现其每一个环都是一个 **边双联通分量**，这也便于我们后文的 $\text{tarjan}$ 算法。

我们知道树（或森林）有很好的性质，并且容易通过很多常见数据结构维护，而一般图则没有那么好的性质，所以有时我们可以 **把一般图上的某些问题转化到树上考虑**。

引入一种数据结构，常用于处理仙人掌上的问题。

## 圆方树

圆方树是一个专门用来处理仙人掌问题的特殊图，由仙人掌转化而来，圆方树是一棵树，其内的点可以分为两类：
+ 圆点
+ 方点

对于仙人掌转化为圆方树的过程，我们先任取一个点作为 **根节点**，定义每个仙人掌的环内离根节点最近的点为 **顶点**。从根节点开始做 $\text{tarjan}$ 算法，每当遇到一个环时，圆方树会破坏原来的环，并建立出一个方点，将环内所有除顶点外的点向方点连接一条边，其权重为该点到顶点的最短路，而顶点则与方点建立一条权重为 $0$ 的边。

![](https://cdn.luogu.com.cn/upload/image_hosting/yxoorjtc.png)

图中标红的为顶点，蓝色字体为各边上的权值。

我们惊喜的发现一件事情，即在将仙人掌转化为圆方树后，其任意两点间的最短路，仍然 **不变**！

我们回忆一下在一般树上我们是如何求得的两点距离。

我们利用 **前缀和** 的思想，先是求出两点到 **根节点** 的距离，再利用 $\text{LCA}$ 减去距离中的冗余部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/zxxf65ox.png)

例如上图中两个标红的点到根的距离再减去两倍的绿色（覆盖在边上的那条）部分，即为两点间的距离。

这启发了我们，在圆方树上该结论仍然成立吗？

我们需要分别来讨论，设所求距离两点分别为 $(u,v)$，$p=\text{LCA(u, v)}$，则有如下讨论：

+ $p$ 为圆点

我们发现不在环上的两点之间的边，是不会被方点管理的，而这些边也是唯一确定，即 **无论如何都必须要经过的** 边，而在环上的边，最短路径也通过方点管理确定了，所以最后的总距离即为：
+ $u$ 点到所在环顶点的最短路 $+$ $u$ 所在环顶点到 $v$ 所在环顶点的距离（唯一确定）$+\ v$ 点到所在环顶点的最短路。

而我们在建立圆方树时，圆点与方点间的距离恰好就是 **最短路**，由此得出我们的结论在 $p$ 为圆点时是仍然成立的。

+ $p$ 为方点

我们发现，当 $p$ 为方点时，**一定是两者的 $\text{LCA}$ 最终汇聚到了一个环内。**

![](https://cdn.luogu.com.cn/upload/image_hosting/4wjd25m4.png)

红色两点即为所求距离的两点，不难发现此时的距离要分为三段来求。

![](https://cdn.luogu.com.cn/upload/image_hosting/v071hup9.png)

有的同学觉得即使是方点也能直接求出，但事实上由于方点管理的是 **到顶点** 的最短路，所以没办法直接求出。

我们回顾倍增求 $\text{LCA}$ 的过程，其实就是优化了一步一步向上跳的过程，而我们发现最终两者一定会跳到蓝色点的位置，因为此时两者父亲就为 $\text{LCA}$，于是我们就顺利的得到了环上两点的编号。

---

在圆方树中，如果将一个环看成一个点，那么整张图实际上就是由多个桥连接的多个边双，而这些桥在圆方树中 **不变**。

### 代码实现

以上都是思路部分，但是仙人掌难就难在其特有的细节上，我们的顺序大概是这样：

1. 根据给定信息建出 **仙人掌** 的图。
2. $\text{tarjan}$ 算法找出所有的环，并建立圆方树。
3. dfs 预处理倍增求 $\text{LCA}$。
4. 回答每一个询问，并根据 $p$ 的不同，分别处理答案。

---

![](https://cdn.luogu.com.cn/upload/image_hosting/6vtj8946.png)

在建圆方树时，我们总是会用到 **每个点到顶点的最短路**。~~你当然可以每个点跑一遍最短路。~~ 这里我们用一种取巧的办法，利用前缀和，统计出环内的目前遍历到的总权值和，那么第一条路就是从顶点开始遍历到当前点的边权值前缀和，另外一条路径就是环上总权值和 $-$ 当前前缀和。

剩下的就是代码啦：

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 12100, M = N * 3;

//tarjan
int low[N], dfn[N], ts = 0;
//lca
int d[N], depth[N], fa[N][14];
//圆方树
int s[N], stot[N], fe[N], fw[N], fu[N]; // 环内前缀和 所在环的总权值和 转移过来的父边 父边的权值 父亲编号
int new_n; // 方点编号
int A, B; // 当lca为方点时 上述环上两点的编号
//Edge
struct Edge
{
    int to, nxt;
    int w;
} edges[M];
int idx = 0, h1[N], h2[N]; // 仙人掌表头 圆方树表头
// other..
int n, m, Q;

//一些常数优化
inline int min(int a, int b)
{
    return a < b ? a : b;
}

inline int abs(int x)
{
    return x < 0 ? -x : x;
}

inline void link(int h[], int from, int to, int w)
{
    ++ idx;
    edges[idx] = {to, h[from], w};
    h[from] = idx;
    return ;
}

inline void build_circle(int from, int to, int w)
{
    ++ new_n; // 每多一个环 就需要建立一个方点
    int sum = w;
    //统计环上的权值和
    for(int k(to);k != from; k = fu[k])
    {
        s[k] = sum;
        sum += fw[k];
    }
    s[from] = stot[from] = sum; 
    link(h2, from, new_n, 0); // 建立方点 权值为0
    for(int k(to);k != from; k = fu[k])
    {
        stot[k] = sum;
        link(h2, new_n, k, min(s[k], sum - s[k]));
    }
    return ;
}

inline void tarjan(int cur, int from)
{
    low[cur] = dfn[cur] = ++ ts;
    int fromp = from & 1 ? from + 1 : from - 1;
    for(int i(h1[cur]);i;i = edges[i].nxt)
    {
        int to = edges[i].to;
        int w = edges[i].w;
        if(!dfn[to])
        {
            fe[to] = i, fw[to] = w, fu[to] = cur;
            tarjan(to, i);
            low[cur] = min(low[cur], low[to]);
            if(dfn[cur] < low[to]) // 该边为桥 是圆方树中不在环内的边
                link(h2, cur, to, w);
        }
        else if(i != fromp)
            low[cur] = min(low[cur], dfn[to]);
    }
    //找出所有以cur为顶点的简单环 建出圆方树
    for(int i(h1[cur]);i;i = edges[i].nxt)
    {
        int to = edges[i].to;
        int w = edges[i].w;
        if(dfn[cur] < dfn[to] and fe[to] != i)
            build_circle(cur, to, w);
    }
}

inline void dfs(int cur, int pa) //圆方树内 倍增lca的预处理
{
    depth[cur] = depth[pa] + 1;
    fa[cur][0] = pa;
    for(int i(1);i <= 13; ++ i)
        fa[cur][i] = fa[fa[cur][i - 1]][i - 1];
    for(int i(h2[cur]);i;i = edges[i].nxt)
    {
        int to = edges[i].to;
        int w = edges[i].w;
        d[to] = d[cur] + w;
        //只有单向边 不用考虑指向父节点
        dfs(to, cur);
    }
    return ;
}

inline int lca(int from, int to)
{
    if(depth[from] < depth[to])
        swap(from, to);
    int d = depth[from] - depth[to];
    for(int i(0);i <= 13; ++ i)
    {
        if(d & 1)
            from = fa[from][i];
        d >>= 1;
    }
    if(from == to) // 在一条链上
        return from;
    for(int i(13);i >= 0; -- i)
    {
        if(fa[from][i] == fa[to][i])
            continue;
        from = fa[from][i];
        to = fa[to][i];
    }
    A = from, B = to;
    return fa[from][0];
}

int main()
{
    scanf("%d %d %d", &n, &m, &Q);
    new_n = n;
    for(int i(1);i <= m; ++ i)
    {
        int a, b, c;
        scanf("%d %d %d", &a, &b, &c);
        link(h1, a, b, c), link(h1, b, a, c);
    }
    tarjan(1, -1);
    dfs(1, 0);
    while(Q -- )
    {
        int a, b;
        scanf("%d %d", &a, &b);
        int p = lca(a, b);
        if(p <= n) // lca为圆点
            printf("%d\n", d[a] + d[b] - (d[p] << 1));
        else
        {
            //方点距离分为三段处理
            int da = d[a] - d[A], db = d[b] - d[B];
            int l = abs(s[A] - s[B]);
            int dm = min(l, stot[A] - l);
            printf("%d\n", da + db + dm);
        }
    }
    return 0;
}
```




---

## 作者：AubRain (赞：3)

没有用圆方树，不过本质差不太多。

目前最优解，可能很快就不是了

**建图方式：** 对于一个环，就把所有环上的点接到环上深度最低的那个点上面去。然后就是一颗树了。

然后 $dis$表示从 $1$ 到 $x$ 的最短距离，$SPFA$ 求出。建树之前求出。

然后 $Dis$ 表示建树之前，$1$ 到 $x$在 $dfs$ 树上的距离。这个是为了能快速求环上两点之间的距离。

然后建树，倍增。

首先先对于询问 $x,y$ ，如果 $lca$ 是 $x$ 或者$y$ 就返回 $dis[x]-dis[y]$ 

否则如果 $lca(x,y)$ 不是环上的点，就是 $dis[x]+dis[y]-2*dis[lca]$ 

否则就是环上的情况。

因为倍增的时候判的是深度，而一个环上深度一样。

对了还要维护每个点属于那个环，还有每个环的环长。然后就有两种走法，返回最小值就行了。

细节好像还挺多的，也不是很好实现。不过代码不长。



**代码：**

```cpp
#pragma GCC target("avx,sse2,sse3,sse4,popcnt")
#pragma GCC optimize("O2,Ofast,inline,unroll-all-loops,-ffast-math")
#include<bits/stdc++.h>
#define N 10005
#define M 80005
using namespace std;

inline void rd(int &X){
    X=0;char ch=0;
    while(!isdigit(ch))ch=getchar();
    while( isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
}

int n,m,q,cnt=1,tot,num;
int head[N],dis[N],v[N];
struct nd{int nxt,to,v;}e[M];
int d[N],Dis[N],vis[M],pre[N],sum[M],c[N],f[N][15];
#define For(x) for(int y,i=head[x];(y=e[i].to);i=e[i].nxt)

inline void add(int x,int y,int v){
    e[++cnt]={head[x],y,v};head[x]=cnt;
    e[++cnt]={head[y],x,v};head[y]=cnt;
}

void SPFA(){
    queue<int> q;q.push(1);
    memset(dis,0x3f,sizeof dis);dis[1]=dis[0]=0;
    while(q.size()){
        int x=q.front();q.pop();v[x]=0;
        For(x) if(dis[y]>dis[x]+e[i].v){
            dis[y]=dis[x]+e[i].v;
            if(!v[y]) v[y]=1,q.push(y);
        }
    }
}
void work(int x,int rt){
    if(x==rt) return ;
    add(rt,x,0);vis[pre[x]]=vis[pre[x]^1]=1;
    sum[num]+=e[pre[x]].v;c[x]=num;work(e[pre[x]^1].to,rt);
}
void dfs(int x){
    v[x]=++tot;
    For(x) if(i^pre[x]^1)
        if(!v[y]) pre[y]=i,Dis[y]=Dis[x]+e[i].v,dfs(y);
        else if(v[y]<v[x]) {
            sum[++num]=e[i].v;
            vis[i]=vis[i^1]=1; work(x,y);
        }
}
void dfs2(int x){
    for(int i=1;i<=14;i++)
        f[x][i]=f[f[x][i-1]][i-1];
    For(x) if(!vis[i] and y!=f[x][0])
        d[y]=d[x]+1,f[y][0]=x,dfs2(y);
}
int ask(int x=0,int y=0){
    rd(x);rd(y);
    if(d[x]<d[y]) swap(x,y);
    int X=x,Y=y;
    for(int i=14;~i;i--)
        if(d[f[x][i]]>=d[y])
            x=f[x][i];
    if(x==y) return dis[X]-dis[Y];
    for(int i=14;~i;i--)
        if(f[x][i]!=f[y][i])
            x=f[x][i],y=f[y][i];
    if(c[x] and c[x]==c[y]){
        int now=sum[c[x]],L=abs(Dis[x]-Dis[y]);
        return min(L,now-L)+dis[X]-dis[x]+dis[Y]-dis[y];
    }return dis[X]+dis[Y]-2*dis[f[x][0]];
}
signed main(){
    rd(n);rd(m);rd(q);
    for(int x,y,v,i=1;i<=m;i++)
        rd(x),rd(y),rd(v),add(x,y,v);
    SPFA();dfs(1);dfs2(1);
    while(q--) printf("%d\n",ask());
}

```

---

## 作者：0xyz (赞：1)

看见仙人掌图，我觉得有很大概率是用圆方树做。

### 1. 构建圆方树

圆方树的构建：我们把一个图的所有点双连通分量缩成方点，圆点就是原来的点，圆点向其在原图中所在的点双连通分量对应的方点连边，就构成了圆方树。

圆方树的性质：
1. 是一棵树。
2. 圆点只和方点相邻，方点只和圆点相邻。
3. 点的个数至多为原图中点个数的两倍减一。

具体怎么写呢？我们在求点双连通分量的时候，就可以顺便求出圆方树。在找到点双连通分量的时候，新建节点，让点双上所有点都与它连边即可。

```cpp
void tar(int x){
	low[x]=dfn[x]=++c;s[++t]=x;
	for(auto y:v[x])
		if(!dfn[y]){
			tar(y);low[x]=min(low[x],low[y]);
			if(low[y]==dfn[x]){
				k++;
				do{e[s[t]].Z(k);e[k].Z(s[t]);}while(s[t--]!=y);
				e[x].Z(k);e[k].Z(x);
			}
		}else low[x]=min(low[x],dfn[y]);
}
```

### 2. 本题做法

注意到我们是要求最短路，所以大致思路就是把图改成圆方树，赋上特定的边权，然后研究树上两点距离。我们考虑如何给圆方树赋值。我们可以处理出以 $1$ 为根时每个方点 $x$ 的父亲圆点 $f_x$，然后所有在这个点双里的点到 $1$ 号节点的路径都必须经过 $f_x$，这是因为两个点双最多只有一个公共点。

所以我们将这个点双里的圆点和 $x$ 之间的边权设置为该圆点到 $f_x$ 的最短路，然后仙人掌上两点的最短路可以转化为一些这种最短路的和。这个最短路怎么求呢？注意到仙人掌“一条边最多只在一个简单回路上”的性质，每一个点双都必定是一个环。那么我们把每个环分别遍历，对于每个点 $y$，预处理出它与 $f_x$ 一个方向的距离以及环的长度，然后 $y$ 距离 $f_x$ 的最短路就是两个方向距离的最小值。这里具体实现，我是用了 `map`，$a_{\{i,x\}}$ 记录一个点 $i$ 在不在点双 $x$ 上，记录好后就用这个遍历，$p_{\{i,x\}}$ 记录一个方向上 $i$ 距离 $f_x$ 的距离。特别地，$p_{\{f_x,x\}}$ 记录的是 $x$ 所对应的环的长度。遍历的时候，记得特判大小为 $2$ 的点双。因为每个点双都是环，所以我们知道所有点双的大小之和为 $m$，从而两个 `map` 中都只会有 $m$ 个元素，这一部分时间复杂度 $O(m\log m)$。

然后就是查询 $u,v$ 之间最短路了。我们分类讨论圆方树上 $u,v$ 的最近公共祖先是圆点还是方点。如果是圆点，那么答案就是沿途的所有边权之和。如果是方点，那么我们在进行倍增求最近公共祖先 $lc$ 时可以分别求出 $lc$ 在 $u,v$ 方向的儿子节点 $U,V$，那么答案就是 $u$ 到 $U$ 的边权和加上 $v$ 到 $V$ 的边权和再加上 $U$ 到 $V$ 在环上的两段距离中较小的一段。

### 3. 代码

```cpp
#include<bits/stdc++.h>
#define Z push_back
#define F first
#define S second
using namespace std;
const int _=2e4+5;
int l[_],d[_],s[_],f[15][_],dep[_],dis[_],z[_],c,t,n,m,q,k;
vector<pair<int,int> >e[_],v[_];
map<pair<int,int>,int>a,p;
void tar(int x){
	l[x]=d[x]=++c;s[++t]=x;
	for(auto i:v[x])
		if(!d[i.F]){
			tar(i.F);l[x]=min(l[x],l[i.F]);
			if(l[i.F]==d[x]){
				k++;
				do{e[s[t]].Z({k,0});e[k].Z({s[t],0});}while(s[t--]!=i.F);
				e[x].Z({k,0});e[k].Z({x,0});
			}
		}else l[x]=min(l[x],d[i.F]);
}
void dfs0(int x,int fa){
	f[0][x]=fa;
	for(int i=1;i<=14;i++)f[i][x]=f[i-1][f[i-1][x]];
	for(auto i:e[x])
		if(i.F!=fa)dfs0(i.F,x);
}
void dfs1(int x,int fa,int op,int ds){
	p[{x,op}]=p[{fa,op}]+ds;
	if(x==f[0][op])return;
	for(auto i:v[x])
		if((i.F!=fa||z[op]==2)&&a[{i.F,op}])dfs1(i.F,x,op,i.S);
}
void dfs2(int x,int ds){
	dep[x]=dep[f[0][x]]+1;dis[x]=dis[f[0][x]]+ds;
	for(auto i:e[x])
		if(i.F!=f[0][x])dfs2(i.F,i.S);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>q;k=n;
	for(int i=1,x,y,z;i<=m;i++)cin>>x>>y>>z,v[x].Z({y,z}),v[y].Z({x,z});
	tar(1);dfs0(1,0);
	for(int i=n+1;i<=k;i++)
		for(auto j:e[i])a[{j.F,i}]=1,z[i]++;
	for(int i=n+1;i<=k;i++)
		for(auto j:v[f[0][i]])
			if(a[{j.F,i}]){
				dfs1(j.F,f[0][i],i,j.S);
				break;
			}
	for(int i=1;i<=k;i++)
		for(auto &j:e[i])
			if(i<=n)j.S=min(p[{i,j.F}],p[{f[0][j.F],j.F}]-p[{i,j.F}]);
			else j.S=min(p[{j.F,i}],p[{f[0][i],i}]-p[{j.F,i}]);
	dfs2(1,0);
	for(int x,y,X,Y,o,C;q;q--){
		cin>>x>>y;X=x;Y=y;
		if(dep[x]>dep[y])swap(x,y);
		for(int i=14;~i;i--)
			if(dep[f[i][y]]>=dep[x])y=f[i][y];
		if(x==y)cout<<abs(dis[X]-dis[Y])<<'\n';
		else{
			for(int i=14;~i;i--)
				if(f[i][x]!=f[i][y])x=f[i][x],y=f[i][y];
			C=f[0][x];
			if(C<=n)cout<<dis[X]+dis[Y]-2*dis[C]<<'\n';
			else o=abs(p[{x,C}]-p[{y,C}]),cout<<dis[X]-dis[x]+dis[Y]-dis[y]+min(o,p[{f[0][C],C}]-o)<<'\n';
		}
	}
	return 0;
}
```

总时间复杂度 $O((n+q)\log n+m\log m)$，空间复杂度 $O(n\log n+m)$。

---

## 作者：Great_Influence (赞：1)

圆方树模板题。不会圆方树的可以看[这篇博客](https://www.luogu.org/blog/user7035/yuan-fang-shu)。仙人掌的建树和一般图的建树是一样的。

这道题除了圆方树构建以外，还需要额外维护每个点到最高点某个固定方向的距离。这个在建树的过程中顺便算一下就可以了。

因为是搬的板子因此 $lca$ 用 $tarjan$ 求的。当数据较大时会出现明显优势。

时间复杂度 $O(n+q)$ (并查集复杂度不清楚因此也许是 $O(n\log n +q)$的)。

代码:

```cpp
#include<bits/stdc++.h>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define pb push_back
#define mp make_pair
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
    const uint32 Buffsize=1<<15,Output=1<<23;
    static char Ch[Buffsize],*S=Ch,*T=Ch;
    inline char getc()
	{
		return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
	}
    static char Out[Output],*nowps=Out;
    
    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

    template<typename T>inline void read(T&x)
	{
		x=0;static char ch;T f=1;
		for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
		x*=f;
	}

    inline void readint(int&x)
	{
		x=0;register char ch;
		for(ch=getc();!isdigit(ch);ch=getc());
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
	}

	template<typename T>inline void write(T x,char ch='\n')
	{
		if(!x)*nowps++='0';
		if(x<0)*nowps++='-',x=-x;
		static uint32 sta[111],tp;
		for(tp=0;x;x/=10)sta[++tp]=x%10;
		for(;tp;*nowps++=sta[tp--]^48);
		*nowps++=ch;
	}
}
using namespace IO;

inline void file()
{
#ifndef ONLINE_JUDGE
	FILE*HEL=freopen("water.in","r",stdin);
	FILE*IOS=freopen("water.out","w",stdout);
#endif
}

const int MAXN=2e4+7,MAXQ=1e4+7;

static int n,m,Q;

static struct graph
{
	struct edge
	{
		int v;
		ll w;
		int nxt;
	}p[MAXN<<1];

	int e,head[MAXN];

	inline void add(int u,int v,ll w){p[++e]=(edge){v,w,head[u]},head[u]=e;}
}p,q;

static struct quer
{
	int u,v;
}ask[MAXQ];

vector<int>quer[MAXN];

inline void init()
{
	readint(n),readint(m),readint(Q);
	static int u,v,w;
	Rep(i,1,m)readint(u),readint(v),readint(w),p.add(u,v,w),p.add(v,u,w);
	Rep(i,1,Q)
	{
		readint(ask[i].u),readint(ask[i].v);
		quer[ask[i].u].pb(i),quer[ask[i].v].pb(i);
	}
}

static int tt,dfn[MAXN],low[MAXN],dfs_clock,sta[MAXN],tp;

static int cir[MAXN],Le[MAXN],pt;

static ll len[MAXN],idst[MAXN];

static int w[MAXN],dst[MAXN];

void tarjan(int u,int fr,int ds=0)
{
	dfn[u]=low[u]=++dfs_clock,sta[++tp]=u,dst[tp]=ds;
	for(register int i=p.head[u];i;i=p.p[i].nxt)
	{
		int v=p.p[i].v;
		if(v==fr)continue;
		if(dfn[v]){if(dfn[v]<low[u])low[u]=dfn[v],w[v]=p.p[i].w;}
		else
		{
			tarjan(v,u,p.p[i].w);
			Chkmin(low[u],low[v]);
			if(low[v]>=dfn[u])
			{
				q.add(u,++tt,0);
				pt=0;
				do{len[tt]+=dst[tp],cir[++pt]=sta[tp],Le[pt]=dst[tp--];}
					while(sta[tp+1]^v);
				if(pt>1)len[tt]+=w[u];
				cir[pt+1]=0;
				Repe(i,pt,1)
				{
					idst[cir[i]]=idst[cir[i+1]]+Le[i];
					if(pt==1)q.add(tt,cir[i],len[tt]);
					else
					q.add(tt,cir[i],min(idst[cir[i]],len[tt]-idst[cir[i]]));
				}
			}
			else Chkmin(low[u],low[v]);
		}
	}
}

static ll dpt[MAXN];

void getdpt(int u)
{
	for(register int i=q.head[u];i;i=q.p[i].nxt)
	{
		int v=q.p[i].v;
		dpt[v]=dpt[u]+q.p[i].w;
		getdpt(v);
	}
}

static struct dsu
{
	int fa[MAXN];

	inline void init(){Rep(i,1,tt)fa[i]=i;}

	int Find(int u){return u==fa[u]?u:fa[u]=Find(fa[u]);}

	inline void combine(int u,int v){u=Find(u),v=Find(v);if(u^v)fa[u]=v;}
}now,fr;

static ll ans[MAXQ];

static int vis[MAXN],curd[MAXN];

void tarjan2(int u)
{
	vis[u]=1;
	for(register int i=q.head[u];i;i=q.p[i].nxt)
	{
		int v=q.p[i].v;
		curd[u]=v,tarjan2(v);
		now.combine(v,u);
	}
	for(register int v:quer[u])
	{
		int x=ask[v].u^ask[v].v^u;
		if(vis[x]==1)
		{
			int lca=now.Find(x);
			if(lca<=n)ans[v]=dpt[u]+dpt[x]-2*dpt[lca];
			else
			{
				register int pr1=fr.Find(x),pr2=curd[lca];
				ans[v]=dpt[u]+dpt[x]-dpt[pr1]-dpt[pr2]
					+min(abs(idst[pr1]-idst[pr2])
					,len[lca]-abs(idst[pr1]-idst[pr2]));
			}
		}
	}
	for(register int i=q.head[u];i;i=q.p[i].nxt)
	{
		int v=q.p[i].v;
		fr.combine(v,u);
	}
}

inline void solve()
{
	tt=n,tarjan(1,0);
	now.init(),fr.init();
	getdpt(1),tarjan2(1);
	Rep(i,1,Q)
	{
		write(ans[i]);
		if(i%100000==0)flush();
	}
	flush();
}

int main()
{
    file();
    init();
    solve();
    return 0;
}
```

---

## 作者：Tobiichi_Origami (赞：0)


**前置知识：** $tarjan$(割边)、$LCA$。

### 题目大意：

给定一棵仙人掌，让你求这棵仙人掌上两点之间的最短路。

------------

### 解题思路：

在我们开始学习静态仙人掌之前，先需要了解仙人掌到底是一个什么东西：

![](https://cdn.luogu.com.cn/upload/image_hosting/zekz4ohk.png)

如上图，仙人掌是一个无向连通图，**任意一条边最多只能出现在一个环**当中。

因为仙人掌是一个图，我们可以按照传统思想求多源最短路，但是会爆。所以我们用**圆方树**来将其转化成一棵树再来解决。

**圆方树：**

圆方树是一个**有向有根树**，从父节点连向子节点，并且这个树当中有两种点，**圆点**与**方点**。

圆点就是之前在**仙人掌中的点**。

而方点需要我们先将每个环的边全部断开，再找出每个环的**根**，具体可以用 $tarjan$ 求出。然后向方点连接一条有向边**权值为 $0$**，之后在方点向这个环的**其他点**连接一条有向边，因为我们要找的是最短路，所以将权值设为这个点到根的**最小权值**。

而不在任何一个环当中的边边权不变，并且是一个割边，但是也都变成**有向边**。

因为这是一个有根树，所以我们将 $1$ 设为这个圆方树的**根**。

最后保证与原仙人掌中的路径权值相等。

以上图为例，将它转化为一棵圆方树

![](https://cdn.luogu.com.cn/upload/image_hosting/jy29spnh.png)

当我们构建完圆方树后，就可以将最短路转化为求这两个点的**最近公共祖先**与他们之间的权值

![](https://cdn.luogu.com.cn/upload/image_hosting/qlec03k5.png)

- 以上图为例，当他们的最近公共祖先为**圆点**时，也就表示该路径与原图中路径权值相等且最近公共祖先存在于原图当中，所以就不用改变，即：$dis(u,v)=dis[u]+dis[v]-2×dis[lca(u,v)]$。

![](https://cdn.luogu.com.cn/upload/image_hosting/8g3x7w68.png)

- 以上图为例，当他们的最近公共祖先为**方点**时，也就表示他们的最近公共祖先并不存在于原图当中，所以我们需要回到原图当中找到两边到达最近公共祖先之前的最后一个点，即**方点与两条路径相交的两个孩子**，我们用 $A$ 和 $B$ 来表示。现在 $A$ 与 $B$ 在他们所属的环内只有两条路径，我们需要一个**前缀和数组**来存储他们的权值和。因为我们要求最短路，我们也就要求两条路径的最小值最后加上 $u$ 和 $v$ 分别到 $A$ 和 $B$ 的路径权值。

剩下的也就没什么了，对代码的解释的都在注释里了
 
### 贴代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct edge{
	int to,next,w;
}ed[1000001];
int he[1000001],tot;
int he2[1000001];
int dfn[1000001];
int low[1000001],idx;
int s[1000001],stot[1000001];//表示权值的前缀和与每个环内的权值和
int fa[1000001],fw[1000001];//父亲和与父亲之间的权值
int f[1000001][15];
int dep[1000001];
int dis[1000001];//与根的权值
int qwq,homo,num;//方点的两个儿子以及方点个数
int n,m,q;
void insert(int u,int v,int w)//建仙人掌
{
	ed[tot].to=v;
	ed[tot].w=w;
	ed[tot].next=he[u];
	he[u]=tot++;
}
void insert2(int u,int v,int w)//建圆方树
{
	ed[tot].to=v;
	ed[tot].w=w;
	ed[tot].next=he2[u];
	he2[u]=tot++;
}
void build(int u,int v,int w)
{
	int sum=w;//从记录的这条边算起
	for(int i=v;i!=u;i=fa[i])
	{
		s[i]=sum;//前缀和吗每次加上它到它父亲那条边的权值
		sum+=fw[i];更新sum
	}
	s[u]=stot[u]=sum;//因为u还没有被记录，所以赋值为更新完的sum。此时，sum加完环内所有权值。
	insert2(u,++num,0);//向方点连边。因为是多余的点，所以num++
	for(int i=v;i!=u;i=fa[i])
	{
		stot[i]=sum;//每个点都在这个环内
		insert2(num,i,min(s[i],sum-s[i]));//向方点连一条最短路径，分别是一个优弧和劣弧
	}
	return ;
}
void tarjan(int u,int from)//割边
{
	dfn[u]=low[u]=++idx;
	for(int i=he[u];i!=-1;i=ed[i].next)
	{
		int v=ed[i].to;
		if(!dfn[v])
		{
			fa[v]=u;fw[v]=ed[i].w;
			tarjan(v,i);
			low[u]=min(low[u],low[v]);
			if(low[v]>dfn[u])
				insert2(u,v,ed[i].w);//这条边是割边，直接在圆方树中建边
		}
		else if(i!=(from^1)) 
			low[u]=min(low[u],dfn[v]);
	}
	for(int i=he[u];i!=-1;i=ed[i].next)
	{
		int v=ed[i].to;
		if(dfn[u]<dfn[v]&&fa[v]!=u)//表示v在以u为根的分量中，且这条边不在圆方树中，从u出去的边
			build(u,v,ed[i].w);//建立方点再连接
	}
	return ;
}
void dfs(int u,int father)//预处理
{
	dep[u]=dep[father]+1;
	f[u][0]=father;
	for(int i=1;(1<<i)<=dep[u];i++)
		f[u][i]=f[f[u][i-1]][i-1];
	for(int i=he2[u];i!=-1;i=ed[i].next)
	{
		int v=ed[i].to;
		dis[v]=dis[u]+ed[i].w;
		dfs(v,u);
	}
	return ;
}
int LCA(int from,int to)//求LCA
{
	if(dep[from]<dep[to])
		swap(from,to);
	int deep=dep[from]-dep[to];
	for(int i=0;i<=13;i++)
	{
		if(deep&1)
			from=f[from][i];
		deep>>=1;
	}
	if(from==to) return to;
	for(int i=13;i>=0;i--)
		if(f[from][i]!=f[to][i])
		{
			from=f[from][i];
			to=f[to][i];
		}
	qwq=from;homo=to;
	return f[from][0];
}
int main()
{
	memset(he,-1,sizeof(he));
	memset(he2,-1,sizeof(he2));
	scanf("%d %d %d",&n,&m,&q);num=n;//圆方树中至少有n个点
	while(m--)
	{
		int x,y,z;
		scanf("%d %d %d",&x,&y,&z);
		insert(x,y,z);
		insert(y,x,z);
	}
	tarjan(1,0);
	dfs(1,0);
	while(q--)
	{
		int x,y;
		scanf("%d %d",&x,&y);
		int lca=LCA(x,y);
		if(lca<=n) 
			printf("%d\n",dis[x]+dis[y]-dis[lca]*2);//从源点到x+从源点到y-2*从源点到lca（不会建议画图）
		else
		{
			int p=dis[x]-dis[qwq];
			int q=dis[y]-dis[homo];
			int minx=min(abs(s[qwq]-s[homo]),stot[qwq]-abs(s[qwq]-s[homo]));//一条路径与整个环内权值和减去的路径的最小值
			printf("%d\n",p+q+minx);//输出
		}
	}
	return 0;
}
```


---

## 作者：Polaris_Australis_ (赞：0)

[题面](https://www.luogu.com.cn/problem/P5236)

## 题意

$n$ 个点 $m$ 条无向边的仙人掌，$q$ 组询问，每组给定 $u,v$，求 $u,v$ 两点距离。

## 做法

首先如果是一棵树，假设 $dist(x)$ 为 $x$ 到根节点的距离，则答案为 $dist(u)+dist(v)-2\times dist(\text{LCA}(u,v))$。

现在变成了仙人掌，可以先建出圆方树，就变成了树形结构，一样跳 $\text{LCA}$，如果 $\text{LCA}$ 是圆点，就和上面的树的结果是一样的，如果是方点，则找到两点跳 $\text{LCA}$ 的过程中经过的两个环上点，计算环上两点间的距离，可以预处理出环上的点到环顶点的距离，假设为 $d(x)$，环周长设为 $len$，则环上两点 $x,y$ 的距离为 $\min(|d(x)-d(y)|,len-|d(x)-d(y)|)$。

## 代码

```cpp
// Problem: P5236 【模板】静态仙人掌
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5236
// Memory Limit: 125 MB
// Time Limit: 300 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
using namespace std;
namespace Std {
int n, m, head[20010][2], nxt[80010], to[80010], cnt, dfn[20010], fa[20010],
    tot, num, len[80010], q, dep[20010], d[20010][20], f[20010][20], top[20010],
    lenh[20010], dis[20010];
bool mark[20010];
inline void add(int x, int y, int z, bool t) {
  to[++cnt] = y;
  len[cnt] = z;
  nxt[cnt] = head[x][t];
  head[x][t] = cnt;
}
void dfs(int x, int y) {
  dfn[x] = ++tot;
  fa[x] = f[x][0] = y;
  for (int i = head[x][0]; i; i = nxt[i]) {
    if (to[i] == y) continue;
    if (!dfn[to[i]]) {
      mark[x] = 0;
      dis[to[i]] = dis[x] + len[i];
      d[to[i]][0] = len[i];
      dfs(to[i], x);
      if (!mark[x]) add(x, to[i], len[i], 1);
    } else {
      if (dfn[to[i]] > dfn[x]) continue;
      int u = x;
      ++num;
      lenh[num] = dis[x] - dis[to[i]] + len[i];
      while (u != to[i]) {
        f[u][0] = num;
        d[u][0] = min(dis[u] - dis[to[i]], lenh[num] - dis[u] + dis[to[i]]);
        add(num, u, d[u][0], 1);
        u = fa[u];
        mark[u] = 1;
      }
      f[num][0] = to[i];
      d[num][0] = 0;
      add(to[i], num, 0, 1);
    }
  }
}
void dfs2(int x) {
  for (int i = head[x][1]; i; i = nxt[i]) {
    dep[to[i]] = dep[x] + 1;
    dfs2(to[i]);
  }
}
void init(void) {
  for (int i = 1; i < 20; ++i) {
    for (int j = 1; j <= num; ++j) {
      f[j][i] = f[f[j][i - 1]][i - 1];
      d[j][i] = d[j][i - 1] + d[f[j][i - 1]][i - 1];
    }
  }
}
int query(int x, int y) {
  int u = x, v = y, ans = 0;
  if (dep[u] < dep[v]) swap(u, v);
  for (int i = 19; ~i; --i) {
    if (dep[f[u][i]] < dep[v]) continue;
    ans += d[u][i];
    u = f[u][i];
  }
  if (u != v) {
    for (int i = 19; ~i; --i) {
      if (f[u][i] == f[v][i]) continue;
      ans += d[u][i] + d[v][i];
      u = f[u][i], v = f[v][i];
    }
    if (u != v) {
      if (dep[u] == dep[v]) {
        ans += d[u][0] + d[v][0];
        u = f[u][0], v = f[v][0];
      } else {
        if (dep[u] > dep[v]) {
          ans += d[u][0];
          u = f[u][0];
        } else {
          ans += d[v][0];
          v = f[v][0];
        }
      }
    }
  }
  if (u > n) {
    ans = 0;
    for (int i = 19; ~i; --i) {
      if (dep[f[x][i]] > dep[u]) {
        ans += d[x][i];
        x = f[x][i];
      }
      if (dep[f[y][i]] > dep[u]) {
        ans += d[y][i];
        y = f[y][i];
      }
    }
    ans += min(abs(dis[x] - dis[y]), lenh[u] - abs(dis[x] - dis[y]));
  }
  return ans;
}
int main() {
  scanf("%d%d%d", &n, &m, &q);
  num = n;
  int u, v, w;
  for (int i = 1; i <= m; ++i) {
    scanf("%d%d%d", &u, &v, &w);
    add(u, v, w, 0);
    add(v, u, w, 0);
  }
  dep[1] = 1;
  dfs(1, 0);
  dfs2(1);
  init();
  for (int i = 1; i <= q; ++i) {
    scanf("%d%d", &u, &v);
    printf("%d\n", query(u, v));
  }
  return 0;
}
}  // namespace Std
int main() { return Std::main(); }
```


---


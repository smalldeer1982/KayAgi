# 邮箱题

## 题目背景

邮箱，一种历史悠久的接信箱子。西方的邮箱以红色为主，东方的邮箱以绿色为主。

## 题目描述

有一张 $n$ 个点和 $m$ 条边构成的**有向**图。每个点内都有一把另一个点的钥匙，$i$ 号点内有 $k_i$ 号点的钥匙。你能进入一个点当且仅当你有该点的钥匙。保证 $k_i$ 构成排列。

只要进入了一个点，就获得了这个点内有的钥匙。一旦获得钥匙就不会被消耗。

现在你拿到了 $i$ 号点的钥匙并到了 $i$ 号点。你需要对每个 $i$ 求出：

1. 有多少点能被你到达。
2. 有多少点能被你到达并返回起点 $i$。

**请注意：给出的边均是有向边！**

## 说明/提示

**【样例解释】**

以下是第一组数据的解释：（图中括号内的内容为点上的钥匙编号）

![](https://cdn.luogu.com.cn/upload/image_hosting/hrserkw2.png)

1. $1$ 能到达的结点集合为 $\{1,2,3,4\}$，$1$ 能到达且能返回 $1$ 的结点集合为 $\{1,2,3,4\}$；
2. $2$ 能到达的结点集合为 $\{2,3\}$，$2$ 能到达且能返回 $2$ 的结点集合为 $\{2\}$；
3. $3$ 能到达的结点集合为 $\{3\}$，$3$ 能到达且能返回 $3$ 的结点集合为 $\{3\}$；
4. $4$ 能到达的结点集合为 $\{4\}$，$4$ 能到达且能返回 $4$ 的结点集合为 $\{4\}$。

这是一个合法的遍历过程：从 $1$ 开始，初始钥匙为 $2$，到达结点 $2$ 并获得钥匙 $3$，到达结点 $3$ 并获得钥匙 $4$，回到结点 $1$，到达结点 $4$ 并获得钥匙 $1$，到达结点 $3$，回到结点 $1$。

**【数据范围】**

对于 $100\%$ 的数据，满足 $n \ge 3$，$m\ge 0$，$\sum n\le 1.5\times{10}^6$，$\sum m\le 3\times{10}^6$，$1 \le T\le 2\times{10}^4$，$1 \le x, y \le n$，保证图中不含重边或自环。

**本题采用捆绑测试且开启子任务依赖！**

|子任务|对 $n$ 的约束|对 $m$ 的约束|分值|依赖|
|-|-|-|-|-|
|1|$n\le 6$|$m\le 12$|$20$|\ |
|2|$\sum n^3\le {10}^7$|$\sum m^3\le 2\times {10}^7$|$25$|\ |
|3|$\sum n^2\le {10}^8$|$\sum m^2\le {10}^8$|$25$|子任务 1、2|
|4|||$30$|子任务 1、2、3|

## 样例 #1

### 输入

```
3
4 5
2 3 4 1
1 2
2 3
3 1
1 4
4 3
5 6
2 3 4 5 1
1 2
2 3
3 4
4 5
5 2
4 1
3 2
2 3 1
1 2
1 3
```

### 输出

```
4 4
2 1
1 1
1 1
5 5
5 5
3 1
2 1
1 1
2 1
1 1
1 1
```

# 题解

## 作者：Alex_Wei (赞：18)

[P9150 邮箱题](https://www.luogu.com.cn/problem/P9150)

好久没见到这么小清新的图论题了。上次见到还是在 [上次](https://www.luogu.com.cn/problem/P8456)。

首先，因为进入一个点时必然有该点的钥匙，而钥匙的数量不会超过进入的点的数量 $+1$，所以在任意时刻，接下来新进入的点是固定的，且该点的钥匙在上一个新进入的点内。因此，如果从 $i$ 号点出发，只需在已经进入的点的基础上，依次考虑 $k_i, k_{k_i}, \cdots$ 是否可达。

考虑当前点 $j$ 以及从 $i$ 不断跳 $k_i$ 到 $j$ 的序列 $a = \{i, k_i, k_{k_i},\cdots, j\}$。我们探究 $k_j$ 可达的充要条件：

- $k_j\notin a$。这等价于 $k_j \neq i$，因为 $k$ 形成排列。
- 考虑路径上最靠近 $j$ 的 $k_j$ 的入边，即最大的 $p$ 使得 $a_p\to k_j$，$a_p$ 存在且 $j$ 可以回到 $a_p$。

如何判定条件二呢？因为 $a_i$ 可达 $a_{i + 1}$，所以只需在每次往序列中加入 $a_p = j$，即新进入点 $j$ 时，考虑其所有 “返祖边” $a_p\to a_q$（$p > q$），则 $a_q\sim a_p$ 之间所有点强连通。枚举 $k_j$ 的入边 $u\to k_j$，若 $u\in a$ 且 $u$ 和 $j$ 强连通，则 $k_j$ 可达。

用并查集维护强连通分量的合并过程，我们得到了 $\mathcal{O}(n ^ 2\alpha)$ 的做法。

因为 $k$ 形成排列，所以我们将 $k$ 上的所有环拎出来单独考虑。

首先断环成链，将环复制两份得到序列 $c$。我们认为一个点的 $k$ 值为其后继，则每个点的前一份复制品在链上的答案就是它在环上的答案。因为从后面的点出发，不会到达前面的点，所以我们从后往前加入计算每个点的答案。

若从 $x$ 出发可达 $y$，从 $y$ 出发可达 $z$，则从 $x$ 出发可达 $z$，因为从 $x$ 出发到达 $y$ 之后，一定拥有 $y$ 号点的钥匙。因此，可达性具有传递性，可以用若干条链描述。

设 $c_{i + 1}\sim c_{L}$ 的答案已知，计算 $c_i$ 的答案，则整个过程相当于不断尝试合并第一条链和第二条链。设第一条链的末尾为 $c_p$，第二条链的开头为 $c_{p + 1}$，根据朴素做法中的判定条件，考虑 $c_{p + 1}$ 的最靠近 $c_p$ 且落在 $c_i\sim c_p$ 上的入边 $c_u\to c_{p + 1}$（$i\leq u\leq p$ 且 $u$ 最大），若 $c_u$ 存在且和 $c_p$ 强连通，则可以合并，否则无法合并。

用两个并查集分别维护可达链和强连通分量，预处理每个点在链上最靠近它且在它前方的入点的位置即可。

问题来了，合并两条可达链的时候，强连通分量该怎么合并？虽然产生贡献的返祖边数量总数只有 $\mathcal{O}(m)$，但我们不能直接枚举第二条链上的所有返祖边，因为这样无法跳过不产生贡献的返祖边。一个解决方案是，对每个可达链，维护所有终点编号不小于 $i$ 且 **还没考虑过** 的返祖边。合并两条链时，统计第二条链维护的所有返祖边的影响，并将它们全部删除。这样，新链的返祖边集合就等于第一条链的返祖边集合，不需要启发式合并。

至此已经得到 $\mathcal{O}(n\alpha)$ 的做法，但是不优美。

我们注意到，如果两条链可以合并，那么第一条链的开头，即当前的 $c_i$ 一定产生了贡献，否则在加入 $c_i$ 之前这两条链就已经可以合并了。而如果 $c_i$ 要产生贡献，一定将第一条链的末尾 $c_p$ 所在的强连通分量扩大了，这说明 $c_i$ 和 $c_p$ 在同一强连通分量，即 **第一条链整体是一个强连通分量**。这样，对于每条链，只需维护编号最大的有还未统计过的返祖边的节点，因为这些返祖边具体指向哪些点是不重要的，反正它们在同一个强连通分量，而每个起始点都相当于将 $c_i$ 到该起始点的强连通分量全部合并，所以我们只关心编号最大的起始点。

此外，有了该性质，在判定是否可以合并两条链时，也可以维护每个点 $c_{p + 1}$ 是否被之前 $c_i\sim c_p$ 的某个点指向，代替计算每个点的最近前驱的位置，但这样就要存正向边了。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;

bool Mbe;
constexpr int N = 3e6 + 5;
void cmax(int &x, int y) {x = x > y ? x : y;}

int n, m, k[N], a1[N], a2[N];
bool vis[N]; // vis 表示是否被访问过
int c, cyc[N], in[N], val[N], pre[N]; // in 表示结点在环上的编号，val 表示结构编号最大的有返祖边的分量，pre 表示结点的最近前驱入边位置
vector<int> e[N];
struct dsu {
  int fa[N];
  int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);}
  void merge(int a, int b) {fa[find(b)] = find(a);}
} cy, ch; // 维护环（强连通分量）和链的并查集

void solve() {
  cin >> n >> m;
  for(int i = 1; i <= n; i++) e[i].clear();
  memset(vis, 0, n + 2);

  for(int i = 1; i <= n; i++) cin >> k[i];
  for(int i = 1; i <= m; i++) {
    int u, v;
    cin >> u >> v;
    e[v].push_back(u);
  }

  for(int i = 1; i <= n; i++) {
    if(vis[i]) continue;
    int p = i;
    while(!in[p]) cyc[++c] = p, in[p] = c, p = k[p];
    for(int j = c * 2; j; j--) {
      cy.fa[j] = ch.fa[j] = j, val[j] = pre[j] = 0;
      int id = cyc[j > c ? j - c : j];
      for(int it : e[id]) {
        if(!in[it]) continue;
        it = in[it];
        if(it + c < j) it += c;
        if(it > j) it -= c;
        pre[j] = max(pre[j], it);
        if(it < j) it += c;
        if(it <= c * 2) cmax(val[ch.find(it)], cy.find(it));
      }
      while(1) {
        while(1) {
          int cyid = cy.find(j), chid = ch.find(j);
          if(cyid < val[chid]) cy.merge(cyid + 1, cyid);
          else break;
        }
        int cyid = cy.find(j), chid = ch.find(j);
        val[chid] = 0;
        if(chid == c * 2 || cyid != chid || pre[chid + 1] < j) break;
        ch.merge(chid + 1, chid);
      }
      a1[id] = min(c, ch.find(j) - j + 1);
      a2[id] = min(c, cy.find(j) - j + 1);
    }
    for(int i = 1; i <= c; i++) in[cyc[i]] = 0, vis[cyc[i]] = 1;
    c = 0;
  }
  for(int i = 1; i <= n; i++) cout << a1[i] << " " << a2[i] << "\n";
}

bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin); 
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif
  int T;
  cin >> T;
  while(T--) solve();
  cerr << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n";
  return 0;
}
```

---

## 作者：syzf2222 (赞：18)

题意：

有一张 $n$ 个点和 $m$ 条边构成的**有向**图，每个点有一把钥匙 $k_i$。你能进入一个点当且仅当你有对应点的钥匙。
保证 $k_i$ 是排列。
现在你拿到了 $i$ 号点的钥匙并到了 $i$ 号点。你需要对每个 $i$ 求出你最多能到几个点。

$n\le 1.5\times 10^6, m\le 3\times 10^6$

---

枚举从哪个点开始，下一个能走到的新点是固定的。我们考虑抽出 $i \to k_i$ 的每个环分别计算答案。



## 暴力的做法

考虑一个暴力做法。

我们枚举一个起点，计算它的答案。

从起点开始，贪心向外拓展。拓展到点 $i$ 时，检查是否有到 $i+1$ 的边，如果存在，就考虑 $i+1$ 的每条回溯边，将一个后缀合并，接下来拓展点 $i+1$。

（一个可能的拓展流程。）

![](https://cdn.luogu.com.cn/upload/image_hosting/vjazdavx.png)

为了方便后面的叙述，我们定义一个**强连通分量**，它表示得到这个分量起点对应的钥匙，并从这个点开始行走，可以经过分量中的每个点而回到开头。

那么上面的暴力可以描述为：

1. 首先，将起点作为一个单独的强连通分量插入栈。
2. 我们来拓展最后一个强连通分量，记 $x$ 表示下一个应该被拓展的点。如果最后一个强连通分量存在边能到达 $x$，我们就进入第三步。否则就退出这个过程。
3. 找到最前的，$x$ 存在边能到达的强连通分量，然后将一个强连通分量的后缀合并为同一个强连通分量。（如上图的第四步。）

总复杂度 $O(n^2)$，可以得到 $70$ 分。



## 更加优秀的做法

我们考虑如果求得了 $x$ 的答案，是否能快速计算 $x-1$ 的答案。显然如果 $x$ 能走到 $y$，那么所有能抵达 $x$ 的点也能走到 $y$。尝试均摊，下面我们进行一些定义：

定义一个**强联通结构**是由若干个**强连通分量**组成的序列，其中从某个**强连通分量**出发，可以到达这个及这个以后的每个**强连通分量**内部的点。也就是说，上面的暴力其实在维护一个强连通结构。

于是，我们可以类似的维护若干个**强连通结构**来帮助我们计算答案。

（下图中，我们将模拟，已求出 $2\dots 6$ 的答案，现在求 $1$ 号点的答案的过程。）

![](https://cdn.luogu.com.cn/upload/image_hosting/zz8aagx4.png)

令 $pre_i$ 表示所有有到点 $i$ 的边的点中，编号最大的点。

如果我们要计算一个新点 $x$ 的答案，做以下几步：

1. 新建一个**强连通结构**，内部仅包含一个**强连通分量**即它自己，然后进入第二步。
2. 我们来检查是否需要合并最前的两个**强连通结构**。（此时，第一个强连通结构一定只包含一个**强连通分量**。）令 $y$ 为下一个**强连通结构**的开头，只需考虑 $pre_y$ 和 $x$ 的大小关系即可。如果成功合并则进入第三步，否则退出这个流程。
3. 我们来合并最前面的**强连通结构**的一些**强连通分量**。我们枚举这个**强连通结构**最前的第一个强连通分量的每个入边，然后将一个前缀合并（如上图的第三步。）此时，如果这个**强连通结构**内部只有一个**强连通分量**了，就说明可能和下一个**强连通结构**合并了，返回第二步操作。否则退出这个流程。

上面的操作，朴素实现的复杂度为 $O(nm)$。如果使用启发式合并等方法维护，总复杂度可能为 $O(n\log n)$。

事实上，适当使用桶来记录返祖边，即可简单完成维护。

我们来分析时间复杂度，注意到只需要执行 $O(n)$ 次插入桶和查询桶最大值的操作，由于查找桶的编号需要使用并查集，因此总复杂度 $O(n\alpha(n))$。

---

## 作者：lizhous (赞：12)

这是一个走路题。

先考虑第一问。

假设现在在点 $u$，那么下一个能走到的新点只能是 $p_u$。因为新钥匙只有一把，所以这是显然的。

因为上述结论，走路其实就是在走置换环，能走到的点也是环上连续的。那么拉出每个置换环单独考虑。

套路的，我们可以找任意一个点断环为链，然后把这个链复制一遍。即这个链是 $now$ 长 $len$，那么 $now_i=now_{i+\frac{len}{2}}$。

视角转化到链上。问题转化为对于每个点 $u$ 求出它能走到的最远的点 $ans_u$。

> 结论：对于一个起始点 $u$，如果能走到 $v$，那么一定能走到 $ans_v$。

钥匙和边是固定的，所以之前能走的现在一定能走。

这个结论启发我们倒着处理 $ans$。

对于一个起始点 $u$，暴力往后跳，每次跳到 $v$ 就直接跳到 $ans_v$。这样复杂度是对的，因为对于一个点 $u$，它现在可以走到 $u+1$，那么它未来也一定可以走到，也就是说每个相邻的点只会被真正跳过一次，其他时候都会被优化掉。

那么现在问题就转化为满足什么条件下点 $u$ 能到点 $u+1$。

视角来到固定起始点后，定义点 $u$ 最远向前能走到点 $a_u$，最近能从点 $las_u$ 走到点 $u$。

> 结论：点 $u$ 能走到点 $u+1$ 当且仅当 $a_u\le las_{u+1}$。

因为对于 $v< u$，$v$ 一定能走到 $v+1$，所以结论是显然的。

接下来考虑快速维护这两个数组。

观察到 $las$ 不会随着起点改变而改变，那么就先扫一遍所有边，求出 $las$。

因为相邻点都有连边，所以一个强连通分量必然是由一个区间的所有点组成。而 $u$ 与 $a_u$ 必然强连通，所以 $a_u$ 的值就是 $u$ 所在强连通分量的最左点。

向后的边贡献 $las$，向前的边挂在前面的点上，类似扫描线一样不停加边。一个边 $(u,v)$ 会把两点之间所有强连通分量合并，那扫一遍每个点只会被合并一次，时间复杂度正确。

第二问不难发现就是起点所在强连通分量的大小，顺便维护即可。

就这样做完了，我代码史山。

---

## 作者：all_for_god (赞：5)

[P9150 邮箱题](https://www.luogu.com.cn/problem/P9150)

这个题卡了我一整个下午。主要是感觉题解都写的比较形式化，不是很直观，对于我这种抽象思维比较差的人来说简直就是天书。（当然是我太菜了）
所以个人花了比较多的图来辅助理解。

## 思路
### 初步观察
首先我们观察到钥匙这个性质本身是相对强的。如果我们拿到了某个点的钥匙，其下一步能走的点是确定的。但是这个题烦就烦在除了钥匙的限制以外还有一个原图的限制。
比如下面的情况：（注意这个是原图）

![](https://cdn.luogu.com.cn/upload/image_hosting/x93m9we2.png)

假设每个点 $u$ 有 $u+1$ 的钥匙，4 有 1 的钥匙。这个时候从 1 开始走就可以到达所有点。因为我们可以在 3 拿到 4 的钥匙后转一圈再到 4。
因此我们考虑把 $1,2,3$ 这种可以相互到达的结构称为一个**强联通分量**。

由于钥匙的限制是一一对应的，因此如果我们从某一个点开始一直令 $u\gets k_u$，那么最终一定会回到原来的出发点，也就是 $k$ 序列将原图划分为了很多个环。我们将这个环断开复制一遍，我们就将这个东西所形成的序列称为 $stk$。例如，上图中唯一的一个 $stk$ 序列为 $\{1,2,3,4,1,2,3,4 \}$。注意我们会将环断开复制一次，这个可以算是经典操作。同时，这个 $stk$ 与原图无关，只是由给定的 $k$ 数组来划分的。一定要分清楚 $stk$ 形成的环与原图的差别，否则很容易将自己弄晕。

然后我们考虑在 $stk$ 序列上进行统计答案。由于我们已经断环为链了，因此这个序列上的某个点只能向右一步一步走。

因此，如果我们已经知道了一串后缀的点最多可以走多少点，那我们在统计前面的点的答案的时候这些后缀的点能走到的最多走多少点一定不会变。因此我们考虑从后向前统计答案。

我们继续延续前面维护强联通分量的思路。可以发现一个强联通分量在 $stk$ 上一定是连续的。我们同时维护最多可以在 $stk$ 数组上向右走到哪个点。可以发现这个东西在 $stk$ 上也是一段连续的区间，同时这个区间里的所有点能够走到的最远的点是相同的。也就是说强联通分量以及最多可以走多远的区间又将 $stk$ 数组划分开来。例如下面是一个例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/15edimba.png)


其中方块代表这是一个强联通分量，而区间表示这个区间内的所有点最远都只能到达这个区间的右端点。可以发现一个区间一定完整包含若干个强联通分量。注意，$stk$ 上一个单独的位置也可以作为一个强联通分量或者一个区间。

同时我们发现，区间右端点与某个点的距离以及这个点所在强联通分量的大小分别就是我们要求的两个问的答案。因此我们去考虑从右往左动态维护区间与强联通分量的信息。

### 区间合并
我们先考虑插入一个点 $u$ 后其是否可以合并进与其相邻的区间里。

![](https://cdn.luogu.com.cn/upload/image_hosting/oy1k0qrv.png)

我们可以发现，$u$ 作为一个单独的点的时候，能够合并进与其相邻的那个区间（也就是可以走到下一个点）当且仅当 $u$ 向 $u$ 在 $stk$ 上的下一个点有连边才可以。我们设 $u$ 在 $stk$ 上的位置为 $i$，即 $stk_{i+1}$ 被 $stk_i$ 连向。

由于每一个区间在 $stk$ 上一定是连续的，因此我们对于每一个点都维护一个**连向自己的点的位置的最大值**，我们设为 $pre_i$。这样，如果 $u$ 是单独一个点，要合并有 $pre_{i+1}=i$。

假设 $u$ 已经合并进了区间里面。现在我们来探究相对长的区间如何合并起来。

![](https://cdn.luogu.com.cn/upload/image_hosting/2gc3pchc.png)

（我们先不管强联通分量是如何合并的）
我们假设这个区间的最靠右的点是 $fa_i$。当然，这个东西用的并查集快速查找。
那前两个相邻的区间可以合并的充要条件就变成了：$pre_{fa_i+1}\ge i \wedge $ **整个区间都是一个强联通分量**。如上图。请注意 $pre$ 之类的“连边”都是原图上的连边。
这个东西的意思是，只要 $fa_i+1$ 这个点被 $[i,fa_i]$ 之间的任意一个点连了，那由于强联通分量里面任意的两个点都可以互相到达，所以才可以走完当前区间拿到 $stk_{fa_i+1}$ 的钥匙之后再走到下一个区间去。注意，$fa_i$ 本身向 $fa_i+1$ 就有连边是不可能的，因为如果有边那一开始就会合并进后边的区间。

由于单独一个点本身也算是整个区间都是强联通分量，因此第一个情况可以合并进第二种情况里。

### 强联通分量合并
现在考虑一个区间内的前两个强联通分量可不可以合并。

![](https://cdn.luogu.com.cn/upload/image_hosting/kp7nfcm6.png)

我们维护每一个区间中有类似返祖边的最远的强联通分量，记为 $loc$。这个同样可以用并查集将信息挂到区间右端点上。
然后例如上面的图。如果有这样的向前面连的边，那么显然前三个强联通分量都可以合并成一个。当然，注意这个返祖边的标记是一次性的，记得清空。

然后就做完了。
### 统计答案
最后统计答案的时候就是直接用并查集查找区间和强联通分量的右端点即可。显然当前点是当前所在区间和强联通分量的左端点。

## code
细节奇多。注意实现的时候维护区间的并查集和维护强联通分量的并查集要分清楚。
同时，由于 $k$ 是将原图划分为多个环，因此我们对于每个环都要去处理。
在实现的时候，我们将原图的边通过 `vector` 挂在了被指向的点上，也就是我们记录的实际上是**反边**，这个在理解代码时要注意。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e6+7;
int n,m,k[N],id[N],vis[N],cnt,stk[N],loc[N],pre[N],ans1[N],ans2[N];//意义基本与题解一样
vector <int> q[N];
struct node{
	int fa[N];
	int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
	void merge(int x,int y){x=find(x),y=find(y);fa[x]=y;}
};node huan;node lian;//huan 和 lian 分别维护强联通分量和区间的右端点

void calc(int beg){
	while(!vis[beg]){stk[++cnt]=beg,id[beg]=cnt,vis[beg]=1;beg=k[beg];}//标记环上的所有点
	for(int i=2*cnt;i>=1;i--){
		int u=stk[(i-1)%cnt+1];huan.fa[i]=lian.fa[i]=i;pre[i]=loc[i]=0;//另类的初始化别忘了
		for(int v:q[u]){
			if(id[v]){
				v=id[v];v=v>i?v-cnt:v;v=v+cnt<i?v+cnt:v;
				pre[i]=max(pre[i],v);v=v<i?v+cnt:v;
				if(v<=cnt*2) loc[lian.find(v)]=max(loc[lian.find(v)],huan.find(v));//找最右端的有返祖边的强联通分量
			}
		}
		while(1){
			while(1){
				int p1=huan.find(i),p2=lian.find(i);
				if(p1<loc[p2])huan.merge(p1,p1+1);else break;  //合并强联通分量
			}
			int p1=huan.find(i),p2=lian.find(i);loc[p2]=0;
			if(p1!=p2||pre[p2+1]<i||p2==2*cnt)break;           //注意这里如果链的右端点已经是区间右端点了也可以跳了
			lian.merge(p2,p2+1);                               //合并区间
		}
		ans1[u]=min(cnt,lian.find(i)-i+1);ans2[u]=min(cnt,huan.find(i)-i+1);//统计答案。由于复制了两次，显然最后一次更新的答案最优（可以统计的区间更长）
	} 
}
void init1(){
	for(int i=1;i<=cnt;i++)id[stk[i]]=0,stk[i]=0;  //注意每次操作后清空序列
	cnt=0;
}
void solve(){
	cin>>n>>m;for(int i=1;i<=n;i++) cin>>k[i];
	for(int i=1,u,v;i<=m;i++) cin>>u>>v,q[v].push_back(u);  //记录的是反边！！！
	for(int i=1;i<=n;i++) if(!vis[i]) calc(i),init1();
	for(int i=1;i<=n;i++) cout<<ans1[i]<<' '<<ans2[i]<<'\n',q[i].clear(),vis[i]=0;//多测不清空，原地见祖宗
}
signed main(){
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;cin>>T;while(T--) solve();
}

```

---

## 作者：lalaouye (赞：3)

感觉是一道很好的图论题。

首先，每个点只有一个钥匙，意味着我们点集的加入顺序是固定的。我们考虑暴力枚举每个起点，维护一个栈，考虑栈顶的强连通分量是否能连到下一个目标，如果能连到，就判断是否可以缩出新的强连通分量。

这样子我们就能暴力求出每个点作为起点的答案了。

显然，如果 $x$ 能到达 $y$，$y$ 能到达 $z$，则 $x$ 能到达 $z$。这启发我们尝试均摊。由于 $k$ 是一个排列，所以我们可以对每个环分别处理。我们断环成链，显然不影响正确性。将原本的环变为 $a_1\rightarrow\cdots\rightarrow a_n\rightarrow a_1\rightarrow\cdots\rightarrow a_n$，然后从后往前考虑。如果我们当前在 $a_i$，已经求出了 $a_{i+1}$ 到 $a_n$ 的答案，尝试利用前面求到的信息快速求出答案。我们对于这个序列的一个后缀可以分成若干个区间，每个区间相当于一个链结构，这个结构由若干个强连通分量组成，实际上这个结构就是用暴力做法中栈维护出来的结构。然后对于 $a_i$ 所在的结构，我们需要不断地向后合并这些结构，具体怎么做呢？

理清楚思路，我们现在需要合并结构，并且要合并链结构中的强连通分量，先考虑链结构如何合并。若当前 $a_i$ 所在的链结构包括了序列区间 $[i,p]$，如果我们想向前合并，则需要满足存在 $a_{p+1}$ 的一个前驱在前面的链结构末尾的强连通分量中，为了判断显然我们可以贪心的找到前驱的编号最大值，现在需要考虑维护强连通分量。首先，链和强连通分量我们都可以使用并查集维护。然后我们可以注意到一个事实，如果当前 $a_i$ 所在的链结构可以继续合并，那这个结构一定只存在一个强连通分量。

如何证明呢？我们考虑为什么加入 $a_i$ 可以进行这么多次合并，说白了是因为我们相较于之前白白增加了 $a_i$ 这个钥匙，所以 $a_i$ 一定会产生贡献，如果当前这个结构不知有一个强连通分量，即除了 $a_i$ 还有别的强连通分量，那么我们早就可以把链给合并了。

这样，我们只需要对于每一条链结构维护编号最大的有返祖边的点即可合并强连通分量。具体操作中，我们先将当前链进行强连通分量合并，然后如果这条链只存在一个强连通分量那么就继续往后合并，合并中判断 $a_{p+1}$ 的前驱最大值是否在范围内，然后合并即可。

时间复杂度 $\mathcal{O}(n\alpha(n))$。

---

## 作者：binbin_200811 (赞：1)

# [P9150 邮箱题](https://www.luogu.com.cn/problem/P9150)

[Alex_Wei](https://www.luogu.com.cn/user/123294) 做法妙。

## 思路

首先我们可以建出两张图，一张是按照题目的要求形成的有向图，一张是由有向边 $(i,k_i)$ 形成的钥匙图。

在钥匙图中，每个点有且仅有一入度一出度，其形成了若干个环。

考虑当前点 $i$，模拟题目过程不断跳点，跳出的序列为 $a=\{i,k_i,k_{k_i},\dots,j \}$。对于 $k_j$ 的可到达性我们进行探究。

1. $k_j \neq i$。
2. 其次存在一个 $p$ 使得原图中存在边 $(p\to k_j)$，且 $j$ 可到达 $p$。

如何判定条件 2 呢？由于 $a_i$ 可到达 $a_{i+1}$，每次序列拓展 $a_p=j$ 时，考虑 $p$ 的返租边 $a_p\to a_q(q<p)$，则 $a_q$ 到 $a_p$ 之间强连通，使用并查集维护强连通块，加入 $k_j$ 时枚举边 $u\to k_j$ 找是否有 $u\in a$ 且 $u$ 与 $j$ 强连通。

复杂度 $O(nm\alpha)$。

这么跑肯定会炸，发现处理环的过程中会经过大量重复的点，能否利用已经求出的点的贡献呢？

将环复制两倍，破环为链，链上前一个点的答案就是该点的答案，如果答案统计时超过了环的长度，那么答案就为环长。

设现在的链为 $c$，如果 $c_{i+1}\sim c_L$ 的答案已经求出，那么钥匙图上会形成若干条链，表示链头开始可以走到链尾；原图上是若干个子图，这些子图间可能有边相连，但由于根据题目条件这两个子图互不可达，这里仍然认为是两个子图；也就是一个子图对应一条钥匙图上的链。

对子图中的强连通分量进行缩点，发现最终缩成了一条链。

下文不加特殊说明，均有以下几点约定：

1. 链均指子图缩点形成的链。

2. $c_u\to c_v$ 表示用 $c_u\sim c_v$ 中的点形成的子图缩点后形成的链。

3. 单个 $c_u$ 仍表示一个破环为链后 $c$ 序列的**一个**点。

4. $c_i$ 视为新加入的点。
5. 点 $c_u$ 的编号为 $u$。

新加入点 $c_i$ 就相当于判断 $c_i\to c_i$ 能否和 $c_{i+1}\to c_p$ 合并，合并之后再次判断 $c_i\to c_p$ 能否和 $c_{p+1}\to c_{p`}$ 合并，不断重复链合并，直到无法进行下一次合并。

对于链 $c_i \to c_p$ 和 $c_{p+1}\to c_{p`}$，根据朴素做法的判断条件，找到 $c_u$ 与 $c_p$ 强连通且存在边 $c_u\to c_{p+1}$（这里是原图中的有向边），就可以合并链。

$c_u$ 换一个角度找会更方便，找存在边 $c_u\to c_{p+1}(u\in[i,p])$ 的最大的 $u$，判断 $c_u,c_p$ 是否共一个强连通分量，因为显然如果存在 $v<u$ 且 $c_v,c_p$ 属于同一个强连通分量，$c_u,c_p$ 也属于同一个强连通分量。

合并链之后，作为一条新的链首先要进行缩点，我们不可能枚举第二条链上所有的返祖边（即满足 $i<j$ 且村子于原图的边 $c_j\to c_i$）。一个好的想法是，对于 $c_i \to c_p$，维护所有终点编号不小于 $i$ 且未考虑过的返祖边，合并时直接暴力跑第二条链上返祖边的影响然后合并即可。

这样就结束了吗？

仔细思考合并的过程，如果 $c_i \to c_p$ 能和 $c_{p+1}\to c_{p`}$ 合并，一定是由于 $c_i$ 带来的新变化使得这两条链可以合并，否则这两条链在 $c_i$ 加入之前就合并为一条链了。

影响链合并的因素只有 $c_u$，所以说 $c_i$ 的加入带来了新的可以选择的 $c_u$，而 $c_u$ 与 $c_p$ 共一个强连通分量，可以证明 $c_i$ 与 $c_p$ 共一个强连通分量。

这样子对于每一条链，维护编号最大还有未贡献的返祖边的节点 $c_x$，这些返祖边的终点 $u$ 满足 $u\in c$ 且 $i\leq k(c_k=u)$，最后把新链头 $c_i\sim c_x$ 合并为同一个点即可。

实现时建出反边，每次用 $c_i$ 更新后面的链即可。

---


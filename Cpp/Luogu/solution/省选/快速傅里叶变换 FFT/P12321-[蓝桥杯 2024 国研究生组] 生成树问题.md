# [蓝桥杯 2024 国研究生组] 生成树问题

## 题目描述

给定 $n$ 个点，编号 $1$ 至 $n$，任意两点 $x, y$ 之间均有且仅有一条边。如果 $x \cdot y$ 为完全平方数（也即存在整数 $z$ 满足 $z^2 = x \cdot y$），那么其边权为 $1$，否则为 $0$。

小蓝想要得到一棵生成树，其除 $1$ 以外的每个点都有一个编号小于自己的点与其相邻。求小蓝想得到的所有生成树中，边权和为 $0$ 至 $n-1$ 的分别各有多少种，请输出答案对 $998244353$ 取模的结果。

## 说明/提示

### 评测用例规模与约定

- 对于 $60\%$ 的评测用例，$n \leq 5000$；
- 对于 $85\%$ 的评测用例，$n \leq 10^5$；

对于所有评测用例，$1 \leq n \leq 3 \times 10^5$。

## 样例 #1

### 输入

```
4```

### 输出

```
4
2
0
0```

# 题解

## 作者：Amidst (赞：8)

## 思路

考虑每条满足 $xy$ 为完全平方数的边 $(x,y)$，其贡献都为 $1$，考虑设计一种母函数区分边权为 $0$ 和 $1$ 带来的贡献，不妨令

$$f_i=\sum\limits_{1\le j < i} [\sqrt{ij} \in \mathbb Z]$$

即 $f_i$ 表示小于 $i$ 的数中与 $i$ 相乘能得到完全平方数的数的个数。

则显然有一种母函数的设计

$$F(i)=f_ix+i-f_i-1$$

即自己不能给自己带来贡献，$f_i$ 带来 $1$ 的贡献，$i-f_i-1$ 的部分带来 $0$ 的贡献。

于是可以列出答案的母函数

$$F_{ans}(n)=\prod\limits_{i=2}^n F(i)$$

观察这个形式，由母函数的定义及基本性质可以得到

$$ans_i=[x^i]F_{ans}(n)$$

于是考虑 $f$ 怎么求。利用惊人的注意力可以发现这是个积性函数，欧拉筛预处理即可。

我们利用分治思想和 FFT 求出 $F_{ans}(n)$（可能是一种分治 FFT？）。

考虑时间复杂度，利用 Master 定理，

$$T(n)=2T(\frac{n}{2})+O(n\log n)=O(n^{\log_22}\log^{1+1}n)=O(n\log^2n)$$

**注意常数优化**。

## 代码

**卷积长度不要太大**。

```cpp
#include <bits/stdc++.h>
//#include <bits/extc++.h>
namespace fastio
{
#ifdef ONLINE_JUDGE
	namespace __getchar
	{
		char buf[1<<24],*p1=buf,*p2=buf;
		inline char getchar() {return (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<23,stdin),p1==p2))?EOF:(*p1++);}
	}
	using __getchar::getchar;
#endif
	inline int read(int &x) {unsigned s=0;int f=1; char ch=getchar(); while(!isdigit(ch)) {if(ch=='-') f=-f; ch=getchar();} while(isdigit(ch)) {s=(s<<3)+(s<<1)+(ch^48); ch=getchar();} return x=s*f;}
	inline unsigned read(unsigned &x) {unsigned s=0; char ch=getchar(); while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) {s=(s<<3)+(s<<1)+(ch^48); ch=getchar();} return x=s;}
	inline long long read(long long &x) {unsigned long long s=0; long long f=1; char ch=getchar(); while(!isdigit(ch)) {if(ch=='-') f=-f; ch=getchar();} while(isdigit(ch)) {s=(s<<3)+(s<<1)+(ch^48); ch=getchar();} return x=s*f;}
	inline unsigned long long read(unsigned long long &x) {unsigned long long s=0; char ch=getchar(); while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) {s=(s<<3)+(s<<1)+(ch^48); ch=getchar();} return x=s;}
	inline char read(char &x) {x=getchar(); while(x=='\0'||x=='\r'||x=='\n'||x==' ') x=getchar(); return x;}
	inline int read(char *x) {int i=0; char ch=getchar(); while(ch=='\0'||ch=='\r'||ch=='\n'||ch==' ') ch=getchar(); while(ch!='\0'&&ch!='\r'&&ch!='\n'&&ch!=' '&&ch!=EOF) {x[i++]=ch; ch=getchar();} x[i]='\0'; return i;}
	inline int read(std::string &x) {x=""; int i=0; char ch=getchar(); while(ch=='\0'||ch=='\r'||ch=='\n'||ch==' ') ch=getchar(); while(ch!='\0'&&ch!='\r'&&ch!='\n'&&ch!=' '&&ch!=EOF) {x+=ch; i++; ch=getchar();} return i;}
	inline void write(int x) {if(x<0) {putchar('-'); write(0-x/10); putchar(48-x%10); return;} if(x<10) putchar(x+48); else {write(x/10); putchar(x%10+48);}}
	inline void write(unsigned x) {if(x<10) putchar(x+48); else {write(x/10); putchar(x%10+48);}}
	inline void write(long long x) {if(x<0) {putchar('-'); write(0-x/10); putchar(48-x%10); return;} if(x<10) putchar(x+48); else {write(x/10); putchar(x%10+48);}}
	inline void write(unsigned long long x) {if(x<10) putchar(x+48); else {write(x/10); putchar(x%10+48);}}
	inline void write(char x) {putchar(x);}
	inline void write(char *x) {char *tmp=x; while(*x!=EOF&&*x!='\0') putchar(*x++); x=tmp;}
	inline void write(const char *x) {while(*x!=EOF&&*x!='\0') putchar(*x++);}
	inline void write(std::string x) {for(char c:x) putchar(c);}
	template<typename _Tp,typename ...Args>
	inline void read(_Tp &x,Args &...args) {read(x); read(args...);}
	template<typename _Tp>
	inline void read(std::initializer_list<_Tp> &x) {for(auto i:x) read(i);}
	template<typename _Tp,typename ...Args>
	inline void write(_Tp x,Args ...args) {write(x); write(args...);}
	template<typename _Tp>
	inline void write(std::initializer_list<_Tp> x) {for(auto i:x) write(i);};
}
using namespace fastio;
//#define int long long
#define G 3
#define mod 998244353
#define __BEGIN_MULTITEST__ \
	signed T; \
	scanf("%d",&T); \
	while(T--) \
	{
#define __END_MULTITEST__ }
using namespace std;
//using namespace __gnu_cxx;
//using namespace __gnu_pbds;
namespace ntt
{
	inline int quick_pow(int a,int b)
	{
		int ret=1;
		while(b)
		{
			if(b&1)
				ret=1ll*ret*a%mod;
			a=1ll*a*a%mod;
			b>>=1;
		}
		return ret; 
	}
	int g[1100005],invlim[1100005];
	void initNTT(int lim)
	{
		g[0]=1;
		g[1]=quick_pow(G,(mod-1)/lim);
		for(int i=2;i<=lim;i++)
			g[i]=1ll*g[i-1]*g[1]%mod;
	}
	void initinv(int lim)
	{
		invlim[0]=invlim[1]=1;
		invlim[2]=499122177;
		for(int i=4;i<=lim;i<<=1)
			invlim[i]=1ll*invlim[i>>1]*invlim[2]%mod;
	}
	void NTT(int f[],int rev[],int lim,int type)
	{
		if(!lim) return;
		for(int i=0;i<=lim;i++)
			if(i<rev[i])
				swap(f[i],f[rev[i]]);
		for(int k=1,tmp=lim>>1;k<lim;k<<=1,tmp>>=1)
			for(int i=0;i<lim;i+=(k<<1))
				for(int j=0,s=0;j<k;j++,s+=tmp)
				{
					int x=f[i|j],y=1ll*g[s]*f[i|j|k]%mod;
					f[i|j]=(x+y)%mod;
					f[i|j|k]=(x-y+mod)%mod;
				}
		if(type==-1)
		{
			f[0]=1ll*f[0]*invlim[lim]%mod;
			for(int i=1;i<=(lim>>1);i++)
			{
				f[i]=1ll*f[i]*invlim[lim]%mod;
				if(i!=(lim>>1))
				{
					f[lim-i]=1ll*f[lim-i]*invlim[lim]%mod;
					swap(f[i],f[lim-i]);
				}
			}
		}
	}
}
namespace sieve
{
	int f[300005],p[300005];
	bool np[300005];
	void Euler(int n)
	{
		int cnt=0;
		np[1]=f[1]=1;
		for(int i=2;i<=n;i++)
		{
			if(!np[i])
			{
				p[++cnt]=i;
				f[i]=1;
			}
			for(int j=1;j<=cnt&&i*p[j]<=n;j++)
			{
				np[i*p[j]]=1;
				if(i%p[j]==0)
				{
					f[i*p[j]]=f[i/p[j]]*p[j];
					break;
				}
				f[i*p[j]]=f[i]*f[p[j]];
			}
		}
		for(int i=1;i<=n;i++)
			f[i]--;
	}
}
using namespace ntt;
using namespace sieve;
int tmp[524289],tmpb[524289],rev[524289];
int lenans=0;
namespace cdqfft
{
	void Multiply(int tmp[],int tmpb[],int rev[],int lim)
	{
		if(lim<=32)
		{
			int res[33]={0};
			for(int i=0;i<=lim&&tmp[i];i++)
				for(int j=0;j<=lim&&tmpb[j];j++)
					res[i+j]=(res[i+j]+1ll*tmp[i]*tmpb[j]%mod)%mod;
			memcpy(tmp,res,sizeof(int)*33);
			return;
		}
		initNTT(lim);
		NTT(tmp,rev,lim,1);
		NTT(tmpb,rev,lim,1);
		for(int i=0;i<=lim;i++)
			tmp[i]=1ll*tmp[i]*tmpb[i]%mod;
		NTT(tmp,rev,lim,-1);
	}
	void cdqFFT(int l,int r,int lim,int L)
	{
		if(l==r)
		{
			tmp[0]=l-f[l]-1;
			tmp[1]=f[l];
			if(f[l])
				lenans++;
			return;
		}
		int mid=l+r>>1;
		memset(tmp,0,sizeof(int)*(lim+1));
		const int N=lim+1;
		int *tmpc=new int[N];
		memcpy(tmpc,tmpb,sizeof(int)*(lim+1));
		cdqFFT(l,mid,lim>>1,L-1);
		memcpy(tmpb,tmp,sizeof(int)*(lim+1));
		memset(tmp,0,sizeof(int)*(lim+1));
		cdqFFT(mid+1,r,lim>>1,L-1);
		for(int i=0;i<=lim;i++)
			rev[i]=(rev[i>>1]>>1)|((i&1)<<L);
		Multiply(tmp,tmpb,rev,lim);
		memcpy(tmpb,tmpc,sizeof(int)*(lim+1));
		delete tmpc;
	}
}
int n;
using namespace cdqfft;
signed main()
{
//	__BEGIN_MULTITEST__
#ifndef ONLINE_JUDGE
	freopen("P12321.in","r",stdin);
	freopen("P12321.out","w",stdout);
#endif
	read(n);
	if(n==1)
		return 0*printf("1\n");
	Euler(n);
	int lim=1,L=-1,len=n;
	while(lim<len)
	{
		lim<<=1;
		L++;
	}
	initinv(lim);
	cdqFFT(2,n,lim,L);
	for(int i=0;i<n;i++)
		write(tmp[i],'\n');
//	__END_MULTITEST__
	return 0;
}
```

---

## 作者：Starrykiller (赞：3)

显然每条边是独立的。

$\forall 2\le i\le n$，计算出 $\displaystyle f(i)=\sum_{1\le j\lt i} [i\cdot j\text{ is a perfect square}]$。这是容易的。

边权和 $=i$ 的答案即为 $\displaystyle [z^i] \prod_{2\le i\le n} (i-1-f(i)+f(i)\cdot z)$。考虑分治地乘，时间复杂度即为 $T(n)=2T(n/2)+\Theta(n\log n)=\Theta(n\log^2 n)$。

---

## 作者：Purslane (赞：2)

# Solution

相当于给每个点选一个父亲，父亲编号小于他。

设每个点和 $u_i$ 个小于他的点有代价为 $1$ 的边。则我们只需要求出 $F(x) = \prod_{i=2}^n (i-u_i + u_i x)$。

上分治 NTT 即可，复杂度 $O(n \log^2 n)$。

代码不想写。

---

## 作者：_biLang_ (赞：0)

# 分析
以 $1$ 为根，点 $k$ 的父亲即唯一一个编号小于自己的与其相邻的点。
记
$$f_k = |\{fa_k : 1 \leq fa_k \leq k - 1,\sqrt{k \cdot fa_k} \in \N \}|$$
考虑点 $k$ 与 $fa_k$ 连边产生的贡献的生成函数。$k$ 贡献为 $1$ 时 $fa_k$ 有 $f_k$ 种取法，贡献为 $0$ 时 $fa_k$ 有 $k - 1 - f_k$ 种取法。因此点 $k$ 的生成函数即为
$$F_k = f_k \cdot x + (k - 1 - f_k)$$
答案的生成函数即为
$$F = \prod_{k = 2}^n F_k$$
分治地合并 $F_k$，使用 Master Theorem 知
$$T(n) = 2 \cdot T \Big({n \over 2}\Big) + \Theta(n \log n) = \Theta(n \log^2 n)$$
至于 $f_k$，记 $k$ 的标准分解 $k = p_1^{\alpha_1} \cdot p_2^{\alpha_2} \cdots p_t^{\alpha_t}$，记
$$fact_k = \prod_{2 \nmid \alpha_i} p_i$$
则
$$\sqrt{k \cdot m} \in \N \iff \exist \ a \ \mathrm{s.t.} \ m = fact_k \cdot a^2$$
$a$ 可从 $1$ 遍历至 $\sqrt{k \over {fact_k}} - 1$，即
$$f_k = \sqrt{k \over {fact_k}} - 1$$
$fact$ 通过线性筛求，转移为
$$fact_{k \cdot p} =
\begin{cases}
fact_k \over p & p \mid fact_k, \\
fact_k \cdot p & p \nmid fact_k.
\end{cases}$$
# AC code
```cpp
#include <bits/stdc++.h>

namespace io
{
  char buf[1 << 20], *p1(buf), *p2(buf), c, f;
#define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2) ? EOF : *p1++)
  
  template <typename _Tp> inline void read(_Tp& x)
  { x = 0; while (f = (c == '-'), !isdigit(c = gc())); while (x = (x << 1) + (x << 3) + (c ^ 48), isdigit(c = gc())); f && (x = -x); }
  
  template <typename _Tp, typename... Args> inline void read(_Tp& x, Args&... args) { read(x), read(args...); }
  
  char pbuf[1 << 20], *pp(pbuf), sta[30], *top(sta);
#define flush() (fwrite(pbuf, 1, pp - pbuf, stdout), pp = pbuf)
#define pc(c) (pp - pbuf == 1 << 20 ? flush() : 0, *pp++ = (c))
  
  template <typename _Tp> inline void write(_Tp x)
  { while (*top++ = x % 10 ^ 48, x /= 10); while (pc(*--top), top != sta); pc('\n');}
  
  struct flusher { inline ~flusher(void) { flush(); } } ioflush;
} // namespace io

using io::read;
using io::write;

using u32 = unsigned;
using u128 = unsigned __int128;

constexpr u32 N(3e5+1), p(998244353), g(3), ig(332748118); constexpr u128 e(1), L((e << 84) / p);

inline u32 mod(const u128& x) { return x - (x * L >> 84) * p; }

u32 n, pri[N], pcnt, fact[N], rev[N << 1]; std::bitset<N> np;

struct mint { u32 x; inline mint(const u32& _ = 0) : x(_) { } };
inline mint operator + (const mint& a, const mint& b) { return (a.x + b.x < p) ? (a.x + b.x) : (a.x + b.x - p); }
inline mint operator - (const mint& a, const mint& b) { return (a.x < b.x) ? (a.x + p - b.x) : (a.x - b.x); }
inline mint operator * (const mint& a, const mint& b) { return mod(e * a.x * b.x); }
inline mint fpow(mint x, u32 y)
{ mint res(1); while (y) { if (y & 1) res = res * x; x = x * x, y >>= 1; } return res; }

using poly = std::vector<mint>;

inline u32 rev_init(const u32& n)
{
  u32 len(1), lg(0); while (len <= n) len <<= 1, lg++;
  for (u32 i(0); i < len; i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << lg - 1); return len;
}

inline void NTT (poly& A, const u32& len, const u32& op)
{
  A.resize(len); for (u32 i(0); i < len; i++) if (i < rev[i]) std::swap(A[i], A[rev[i]]);
  for (u32 m(1), i, k; m < len; m <<= 1)
  {
    static mint g0, gn, x, y; g0 = fpow(op ? g : ig, (p - 1) / (m << 1));
    for (i = 0, gn = 1; i < len; i += (m << 1), gn = 1) for (k = 0; k < m; k++, gn = gn * g0)
    { x = A[i + k], y = gn * A[i + m + k], A[i + k] = x + y, A[i + m + k] = x - y; }
  }
  if (!op) { mint inv(fpow(len, p - 2)); for (mint& a : A) a = a * inv; }
}

inline poly operator * (poly A, poly B)
{
  u32 n(A.size() + B.size() - 1), len(rev_init(n)); poly res; res.resize(len);
  NTT(A, len, 1), NTT(B, len, 1); for (u32 i(0); i < len; i++) res[i] = A[i] * B[i];
  NTT(res, len, 0), res.resize(n); return res; 
}

poly f[N], ans; u32 tot;

inline poly calc(const u32& L, const u32& R)
{ if (L == R) return f[L]; return calc(L, L + R >> 1) * calc((L + R >> 1) + 1, R); }

signed main(void)
{
#ifndef ONLINE_JUDGE
  freopen("in.txt", "r", stdin), freopen("out.txt", "w", stdout);
#endif
  
  u32 k, i, sqrt, c0, c1; mint coef(1);
  
  read(n);
  
  for (k = 2; k <= n; k++)
  {
    if (!np[k]) pri[++pcnt] = k, fact[k] = k;
    for (i = 1; i <= pcnt && k * pri[i] <= n; i++)
    {
      np.set(k * pri[i]);
      fact[k * pri[i]] = (fact[k] % pri[i]) ? (fact[k] * pri[i]) : (fact[k] / pri[i]);
      if (!(k % pri[i])) break;
	}
  }
  
  for (k = 2; k <= n; k++)
  {
    c1 = std::sqrt(k / fact[k]) - 1, c0 = k - 1 - c1;
	c1 ? (f[++tot] = {c0, c1}, 0) : (coef = coef * c0, 0);
  }
  
  if (!tot) { write(coef.x); for (i = 1; i < n; i++) write(0); return 0; }
  
  ans = calc(1, tot); for (i = 0; i < ans.size(); i++) write((coef * ans[i]).x); for (i = ans.size(); i < n; i++) write(0);
  
  return 0;
}

```

---


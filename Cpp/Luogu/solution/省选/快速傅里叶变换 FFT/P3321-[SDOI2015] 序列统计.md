# [SDOI2015] 序列统计

## 题目描述

小C有一个集合 $S$，里面的元素都是小于 $m$ 的非负整数。他用程序编写了一个数列生成器，可以生成一个长度为 $n$ 的数列，数列中的每个数都属于集合 $S$。  

小C用这个生成器生成了许多这样的数列。但是小C有一个问题需要你的帮助：给定整数 $x$，求所有可以生成出的，且满足数列中所有数的乘积 $\bmod \ m$ 的值等于 $x$ 的不同的数列的有多少个。  

小C认为，两个数列 $A$ 和 $B$ 不同，当且仅当 $\exists i \text{ s.t. } A_i \neq B_i$。另外，小C认为这个问题的答案可能很大，因此他只需要你帮助他求出答案对 $1004535809$ 取模的值就可以了。


## 说明/提示

【样例说明】

可以生成的满足要求的不同的数列有(1,1,1,1)、(1,1,2,2)、(1,2,1,2)、(1,2,2,1)、(2,1,1,2)、(2,1,2,1)、(2,2,1,1)、(2,2,2,2)。

【数据规模和约定】

对于 $10\%$ 的数据，$1\le n \le 1000$；   
对于 $30\%$ 的数据，$3 \le m \le 100$；    
对于 $60\%$ 的数据，$3 \le m \le 800$；   
对于 $100\%$ 的数据，$1 \le n \le 10^9$，$3 \le m \le 8000$，$1\le x < m$。   
$m$ 为质数，输入数据保证集合 $S$ 中元素不重复。


## 样例 #1

### 输入

```
4 3 1 2
1 2```

### 输出

```
8```

# 题解

## 作者：ZigZagKmp (赞：151)

## 题目大意
给定一个集合$S$，$\forall x\in S,s\in [0,m-1]$，求从这个集合$S$中选取$n$个数，使得乘积为$x$的方案数。

## 算法分析
这其实是一类非常经典的问题。

### 引入例题1

给定一个集合$S$，$\forall x\in S,s\in [1,n]$，在这个集合中选取2个数（可以重复），使得加和为$A$的方案数。

不难想到可以从数值角度入手，我们运用桶思想，设在集合中$i$这个数字出现了$h(i)$次，则不难得到答案为

$$\sum_{i=1}^Ah(i)\times h(A-i)$$

显然这个可以$O(n)$求解，具体实现不再赘述。

当然这个式子符合多项式卷积的一般形式，所以也可以$O(n\log n)$求解。（不过一道普及组难度的题目被搞成这样好吗）

### 引入例题2
给定一个集合$S$，$\forall x\in S,s\in [1,n]$，在这个集合中选取3个数（可以重复），使得加和为$A$的方案数。

类比于上一道例题，不难得到答案为

$$\sum_{i=1}^A\sum_{j=1}^{A-i}h(i)\times h(j)\times h(A-i-j)$$

时间复杂度是$O(n^2)$，似乎不是很好。

这个能不能优化呢？

$$1+2=3$$

选取3个数可以看作在选取1个数的集合$S_1$和选取2个数的集合$S_2$中分别选取1个数。

我们可以先求出选取2个数的方案，记从$S$中选取2个数加和为$i$的方案数为$h_2(i)$，则不难得到答案为
$$\sum_{i=1}^Ah(i)\times h_2(A-i)$$

那如何快速求出$h_2$呢？

由上一道例题可得
$$h_2(x)=\sum_{i=1}^xh(i)\times h(x-j)$$
这是标准的卷积形式，可以使用`FFT/NTT`快速求出$h_2$，时间复杂度为$O(n\log n)$。

推荐题目：
- `【bzoj3513】[MUTC2013]idiots`
- `【bzoj3771】Triple`

### 引入例题3
给定一个集合$S$，$\forall x\in S,s\in [1,n]$，在这个集合中选取$k$个数（可以重复），使得加和为$A$的方案数。

类比于例题2，不难得到一种方法：设$h_t(i)$表示从集合中选取$t$个数加和为$i$的方案数，则有如下的递推式：
$$h_t(x)=\sum_{i=1}^nh_{t-1}(i)\times h(x-i)$$

这样时间复杂度是$O(km\log m)$，还有一定的优化空间。

考虑倍增，设$h_t(i)$表示从集合中选取$2^t$个数加和为$i$的方案数。选取$2^t$个数相当于在选取$2^{t-1}$个数的集合中选取2个数，则不难得到如下的递推式：
$$h_t(x)=\sum_{i=1}^nh_{t-1}(i)\times h_{t-1}(x-i)$$
这样预处理出$h_t$，把$k$二进制拆解，类比于快速幂，可以在$O(m\log m\log k)$的时间复杂度下实现。

核心代码如下：
```cpp
ans[0]=1;//初始化
for(int i=30;~i;i--){
    if((k>>i)&1){
    	mul(h[i],ans,ans);
    }
}
```

### 引入例题4
给定一个集合$S$，$\forall x\in S,s\in [0,n-1]$，在这个集合中选取$k$个数（可以重复），使得加和在$\bmod \ n$意义下为$A$的方案数。

和上一题相比，这一题需要的是模意义下的加法，因此核心算法和上一题一样，只是有一个细节要注意：多项式乘法后，需要把$\ge n$的那些项累加到对应模运算以后的位置，因为这些也是可能的方案，对答案有贡献。

可能用代码表示会更加清楚：
```cpp
void mul(int *f,int *g,int *ans){
	f-->tmp1
    g-->tmp2//复制两个数组，保证f,g本身对应的数组不发生改变
    ntt(tmp1,1);ntt(tmp2,1);
    for(int i=0;i<N;i++)tmp1[i]=tmp1[i]*tmp2[i]%mod;
    ntt(tmp1,-1);
	// 以上为ntt常规操作
    for(int i=0;i<n;i++)ans[i]=tmp1[i];
    for(int i=n;i<N;i++)ans[i%n]=(ans[i%n]+tmp1[i])%mod;//这就是上述的变化
}
```

### 回到原题
引入例题4和原题之间只有一步之遥，唯一的变化是加法变成了乘法。（变量名不统一这类的就不考虑了）

这里我们把**乘法变成加法**！

回想初等函数，我们发现有2种函数可以实现乘法与加法的互化：指数函数和对数函数。

这里略讲一下指数函数和对数函数，防止有些同学没学过。

----

指数函数，形如$f(x)=a^x,a\ge 0,a\neq1$，根据幂运算性质，不难得到：$f(x+y)=f(x)\times f(y)$。

取对数运算，对于$a^x=N$，则有$\log_aN=x$，根据$a^x\times a^y=a^{x+y}$，不难得出$\log_aa^x+\log_aa^y=\log_aa^{x+y}=\log_a(a^x\times a^y)$，推广可得$\log_ax+\log_ay=\log_a(x\times y)$。

对数函数，形如$f(x)=\log_ax,a\ge 0,a\neq 1,x>0$，根据对数运算相关性质，不难得到$f(xy)=f(x)+f(y)$。

指数函数可以使**加法转化为乘法**，对数函数可以使**乘法转化为加法**。

----

但是指对运算都是在实数域上的，而本题是在模意义下的，怎么处理呢？

模意义下的指数/对数？

求指数还是很容易的，随便以一个数为底（设为$a$），在模意义下求出$a^x,x\in[1,m-1]$，那么根据对数的定义，则可令$\log_a(a^x\bmod m)=x$，这样建立映射关系。

看上去似乎没有问题？

我们举一个例子，如果$m=7,a=2$，那么$a^1 \equiv  a^4\equiv 2 \ (\bmod\  m)$，那么$\log_a(2)=?$

我们发现这种映射关系必须是**一一对应**的，因此并不是随便取一个数为底就可以的。

我们需要找到一个底数$a$，使得$a^1,a^2,\cdots,a^{m-1}$在$\bmod \ m$意义下互不相同。

注意：这里没有包含$a^0$，这是因为在$\bmod \ m$意义下不存在一个数$x$使得$a^x\equiv 0(\bmod \ m)$，因此实际上只有$m-1$个可对应位置，在本题中$S$集合中的$0$对答案无贡献，故忽略$a^0$。

这个东西似乎很熟悉啊，这好像就是原根。

对于$p$的原根$g$，满足$g^1,g^2,\cdots,g^{p-1}$在$\bmod \ p$意义下互不相同。

因此我们只需要找到$m$的一个原根，即可把乘法转化为加法。

综上，我们得到这一题的解决方法：

1. 求出$m$的原根，并把集合$S$中的数$x$转化为$\log_gx$。
2. 求出$h_t$，含义与上面引入例题的类似，其中$h_0(i)$表示集合$S$中满足$\log_gx=i$数的数量。
3. 将$n$进行二进制拆分，并做多项式卷积，求出在去过对数的集合中选取$n$个数加和为$i$的方案数为$ans(i)$。
4. 对于输入的$X$，答案即为$ans(\log_gX)$。

时间复杂度为$O(m\log m\log n)$

## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 100005
#define maxm 2000005
#define inf 0x3f3f3f3f
#define int long long
#define mod 1004535809
#define local
template <typename Tp> void read(Tp &x){
	int fh=1;char c=getchar();x=0;
	while(c>'9'||c<'0'){if(c=='-'){fh=-1;}c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c&15);x%=mod;c=getchar();}x*=fh;
}
int ksm(int B,int P,int Mod){int ret=1;while(P){if(P&1)ret=1ll*ret*B%Mod;B=1ll*B*B%Mod;P>>=1;}return ret;}

namespace Poly{
	const int Gmod=3,invG=334845270;
	int a[maxn],b[maxn];
	int tr[21][maxn];
	int Wn[2][21];
	int LG[maxn];
	int inv[maxn];
	void preprocess(int maxN){
		for(int i=0;(1<<i)<=maxN*2;i++)LG[1<<i]=i;
		for(int i=0;(1<<i)<=maxN*2;i++){
			Wn[0][i]=ksm(invG,(mod-1)/(1<<(i+1)),mod);
			Wn[1][i]=ksm(Gmod,(mod-1)/(1<<(i+1)),mod);
			int N=(1<<i);
			for(int j=0;j<N;j++)tr[i][j]=((tr[i][j>>1]>>1)|((j&1)?(N>>1):0));
		}
		inv[1]=1;
		for(int i=2;i<=maxN*2;i++)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	}
	void ntt(int *f,int N,int typ){
		for(int i=0;i<N;i++)if(i<tr[LG[N]][i])swap(f[i],f[tr[LG[N]][i]]);
		for(int len=1;len<N;len<<=1){
			int wn=Wn[typ==1][LG[len]];
			for(int i=0;i<N;i+=(len<<1)){
				int buf=1;
				for(int j=0;j<len;j++,buf=1ll*buf*wn%mod){
					int FL=f[i+j],FR=1ll*f[i+j+len]*buf%mod;
					f[i+j]=(FL+FR)%mod;
					f[i+j+len]=(FL-FR)%mod;
				}
			}
		}
		if(typ==-1){
			int invN=inv[N];
			for(int i=0;i<N;i++)f[i]=1ll*f[i]*invN%mod;
		}
		for(int i=0;i<N;i++)f[i]=(f[i]+mod)%mod;
	}
	void mul(int *ff,int *gg,int *ans,int n,int m,int mod_x){
		int N;
		for(N=1;N<n+m-1;N<<=1);
		for(int i=0;i<n;i++)a[i]=ff[i];for(int i=n;i<N;i++)a[i]=0;
		for(int i=0;i<m;i++)b[i]=gg[i];for(int i=m;i<N;i++)b[i]=0;
		ntt(a,N,1);ntt(b,N,1);
		for(int i=0;i<N;i++)a[i]=1ll*a[i]*b[i]%mod;
		ntt(a,N,-1);
		for(int i=0;i<mod_x;i++)ans[i]=a[i];
		for(int i=mod_x;i<N;i++)ans[i%n]=(ans[i%n]+a[i])%mod;//这里即为模意义下的的特殊之处，对应引入例题4
		for(int i=mod_x;i<N;i++)ans[i]=0;
	}//多项式问题要注意及时清零，否则可能会有一些比较难调试出来的错误
}

int n,m;
int P,S;
int h[maxn];
int f[35][maxn],g[maxn];
void Ksm(int p){
	g[0]=1;
	for(int i=32;~i;i--){
		if((p>>i)&1)
		Poly::mul(f[i],g,g,m-1,m-1,m-1);
	}
}//二进制拆分，类比于快速幂
int dtol[maxn],ltod[maxn];
//dtol指真数到对数的映射
//ltod指对数到真数的映射（也是指数到幂的映射）
//本题中ltod没有太大作用
bool check(int gg,int x){
	int tmp[8005]={0};
	for(int i=0,tep=1;i<x-1;i++,tep=1ll*tep*gg%x){
		tmp[tep]++;
		if(tmp[tep]>1)return 0;
	}
	return 1;
}//这个是最暴力的原根判定方法，但因为一个质数最小的原根普遍较小，且本题 m 的范围也比较小，因此暴力判断足矣
void get_G(int x){
	int GGG;
	for(int i=2;i<x;i++){
		if(check(i,x)){
			GGG=i;break;
		}
	}
	for(int i=0,tep=1;i<x-1;i++,tep=1ll*tep*GGG%x){
		dtol[tep]=i;ltod[i]=tep;
	}//构造对数表
}
signed main(){
	int X;
	read(n);read(m);Poly::preprocess(m<<2);
	get_G(m);
	read(X);read(S);
	for(int i=1,a;i<=S;i++){
		read(a);
		if(!a)continue;h[dtol[a]]++;
	}
	for(int i=0;i<m;i++)f[0][i]=h[i];
	for(int i=1;i<=32;i++){
		Poly::mul(f[i-1],f[i-1],f[i],m-1,m-1,m-1);
	}//倍增求出f（即为分析中的ht）
	Ksm(n);
	printf("%lld\n",g[dtol[X]]);
	return 0;
}

```

##  写在最后
这道题目或许是不少同学接触多项式之后遇到的前几道题目，而题解区的部分题解对刚接触多项式的同学不很友好，过于简洁。故作此题解，同时也对这一类问题稍作总结。

---

## 作者：何俞均 (赞：27)

广告：食用[$blog$](https://www.cnblogs.com/heyujun/p/10360050.html)体验更佳

### 前置芝士：原根

我们先看一下对于一个数$p$，它的原根$g$有什么性质(好像就是定义)：

> $g^0\%p,g^1\%p,g^2\%p...g^{p-2}\%p$恰好等于$[1,p]$中所有数。

那么怎么求呢？

> 对$\varphi(p)$分解质因数，得到$\varphi(p)=p_1^{a_1}p_2^{a_2}p_3^{a_3}...p_n^{a_n}$
从$2$~$(p-1)$枚举$g$，如果满足$g$对于$\forall p_i$，有$$g^{\frac {\varphi(p)}{p_i}}\neq1\;mod\;p$$
则该数是个原根,$break$，否则$continue$

### 关于此题：

有了上面的铺垫，我们想一想这题怎么做。

设$f[i][j]$表示选了$i$个数，乘积$\%m$为$j$的方案数，
则有转移：
$$f[2*i][c]=\sum_{a*b\%m=c}f[i][a]*f[i][b]$$
这时候我们复杂度是$O(m^2logn)$的，跑不过去，而转移次数已经无法优化了，想办法优化转移。

观察这个转移，如果它的判断条件为$(a+b)\%m=c$，我们不就可以卷起来了吗？

想想什么能把乘法换成加法？对数！！！

但是因为是模意义下的对数，所以我们取个原根就行了。

$\therefore$ 设$C=log_gc\%m,A=log_ga\%m,B=log_gb\%m$。

则有转移：

$$f[2*i][C]=\sum_{(A+B)\%m=c}f[i][A]*f[i][B]$$

那么就可以用$NTT$搞了，

注意最后要$f[i][j]+=f[i][j+m-1]$，因为你每次卷起来后$m$~$(2m-2)$项都是要算贡献的。

注意：集合中$\%m=0$的数也要判一下。

代码
```cpp
#include <iostream> 
#include <cstdio> 
#include <cstdlib> 
#include <cstring> 
#include <cmath> 
#include <algorithm> 
#include <map> 
using namespace std; 
inline int gi() { 
    register int data = 0, w = 1; 
    register char ch = 0; 
    while (!isdigit(ch) && ch != '-') ch = getchar(); 
    if (ch == '-') w = -1, ch = getchar(); 
    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); 
    return w * data; 
}
int fpow(int x, int y, int mod) { 
    int res = 1; 
    while (y) {
        if (y & 1) res = 1ll * res * x % mod; 
        x = 1ll * x * x % mod; 
        y >>= 1; 
    } 
    return res; 
} 
const int Mod = 1004535809, G = 3, iG = fpow(G, Mod - 2, Mod); 
int GetRoot(int x) { 
    int fact[10000], tot = 0; 
    int phi = x - 1; 
    for (int i = 2; i * i <= phi; i++) {
        if (phi % i == 0) {
            fact[++tot] = i; 
            while (phi % i == 0) phi /= i; 
        } 
    } 
    if (phi > 1) fact[++tot] = phi; 
    phi = x - 1; 
    for (int i = 2; i <= phi; i++) { 
        bool flg = 1; 
        for (int j = 1; j <= tot && flg; j++) 
            if (fpow(i, phi / fact[j], x) == 1) flg = 0; 
        if (flg) return i; 
    } 
    return -1; 
}
const int MAX_M = 2.4e4 + 5; 
int Limit, rev[MAX_M]; 
void NTT(int *p, int op) { 
    for (int i = 0; i < Limit; i++) if (i < rev[i]) swap(p[i], p[rev[i]]); 
    for (int i = 1; i < Limit; i <<= 1) {
        int rot = fpow(op == 1 ? G : iG, (Mod - 1) / (i << 1), Mod); 
        for (int j = 0; j < Limit; j += (i << 1)) { 
            int w = 1; 
            for (int k = 0; k < i; k++, w = 1ll * w * rot % Mod) { 
                int x = p[j + k], y = 1ll * w * p[i + k + j] % Mod; 
                p[j + k] = (x + y) % Mod, p[i + j + k] = (x - y + Mod) % Mod; 
            } 
        } 
    }
    if (op == -1) {
        int inv = fpow(Limit, Mod - 2, Mod); 
        for (int i = 0; i < Limit; i++) p[i] = 1ll * p[i] * inv % Mod;
    } 
} 
map<int, int> mp; 
int N, M, X, S, F[MAX_M], H[MAX_M]; 
void mul(int *A, int *B, int *C) {
    static int res[MAX_M], a[MAX_M], b[MAX_M];
    for (int i = 0; i < Limit; i++) a[i] = A[i], b[i] = B[i]; 
    NTT(a, 1), NTT(b, 1); 
    for (int i = 0; i < Limit; i++) a[i] = 1ll * a[i] * b[i] % Mod; 
    NTT(a, -1); 
    for (int i = 0; i < M - 1; i++) res[i] = (a[i] + a[i + M - 1]) % Mod; 
    for (int i = 0; i < M - 1; i++) C[i] = res[i]; 
}
int main () { 
    N = gi(), M = gi(), X = gi(), S = gi(); 
    int g = GetRoot(M); for (int i = 0; i < M - 1; i++) mp[fpow(g, i, M)] = i; 
    for (int i = 1, x; i <= S; i++) { 
        x = gi() % M; 
        if (x) F[mp[x % M]]++; 
    } 
    H[mp[1]] = 1;
    int p = 0; 
    for (Limit = 1; Limit <= 2 * M; Limit <<= 1, ++p) ; 
    for (int i = 0; i < Limit; i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (p - 1)); 
    while (N) { 
        if (N & 1) mul(H, F, H); 
        mul(F, F, F); 
        N >>= 1; 
    } 
    printf("%d\n", H[mp[X]]); 
    return 0; 
} 
```

---

## 作者：硫代硫酸钠 (赞：16)

~~多项式快速幂了解一下~~

预备知识:

1.如果在$mod$ $p$意义下有$g \in N^+$,使得$g^0,g^1...g^{p-2}$各不相同,称$g$是$p$的一个原根.

一般来讲一个素数的原根都很小所以可以暴力求
```cpp
int G(int s)
{
	int q[1010]={0};
	rep(i,2,s-2) if ((s-1)%i==0) q[++q[0]]=i;
	for (int i=2;;i++)
	{
		bool B=1;
		for (int j=1;j<=q[0]&&B;j++) if (ksm(i,q[j],s)==1) B=0;
		if (B) return i;
	}
	return -1;
}
```
~~可以看到楼主zz地写了个死循环~~

2.生成函数

如果原问题是:数列中所有数的**和**mod M的值等于x,那么我们可以找一个多项式:

$F(x)=\sum\limits_{i=0}^{n} dir(i)x^i$

其中如果$i\in S$,$dir(i)=1$,否则$dir(i)=0$

然后我们~~惊喜地~~发现, 方案数是$(F(x))^n$次数为x那一项的系数.

那么本题的乘积怎么解决呢?

只要把每个数变成原根就好了呀!

本蒟蒻写的NTT不卡常!而且不开O2也不慢的样子.

```
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
#include<cctype>
#include<cstdlib>
#include<algorithm>
#include<ctime>
#include<stack>
#include<queue>
#include<map>
#define size 3000010
#define ll long long
#define db double
#define il inline
#define rint register int
#define gc getchar()
#define rep(i,s,n) for (register int i=s;i<=n;i++)
#define drep(i,n,s) for (register int i=n;i>=s;--i)
#ifdef WIN32
#define ld "%I64d"
#else
#define ld "%lld"
#endif
#define Mod 1004535809

using namespace std;

il ll r()
{
    char c; ll x,f=1;
    for (c=gc;!isdigit(c);c=gc) if (c=='-') f=-1; x=c-'0';
    for (c=gc;isdigit(c);c=gc) x=x*10+c-'0'; return x*f;
}


ll F1[size],F0[size],c[size],A[size],po[size],pv[size];
int Lg,L,l1,l2,rev[size],n,m,S,X,g,pg[size];

il ll ksm(ll x,ll y,ll mod)
{
    ll res=1;
    while (y)
    {
        if (y&1) res=(res*x)%mod;
        x=x*x%mod;
        y>>=1;
    }
    return res;
}

int G(int s)
{
    int q[1010]={0};
    rep(i,2,s-2) if ((s-1)%i==0) q[++q[0]]=i;
    for (int i=2;;i++)
    {
        bool B=1;
        for (int j=1;j<=q[0]&&B;j++) if (ksm(i,q[j],s)==1) B=0;
        if (B) return i;
    }
    return -1;
}

void Rader(int tmp)
{
    Lg=0,L=1; while (L<tmp) L<<=1,Lg++; L<<=1,Lg++;
    rep(i,0,L-1)
        for (int t=i,j=1;j<=Lg;j++)
            rev[i]<<=1,rev[i]|=t&1,t>>=1;
    ll I=ksm(3,Mod-2,Mod);
    for (int i=1;i<=L;i<<=1) po[i]=ksm(3,(Mod-1)/i,Mod),pv[i]=ksm(I,(Mod-1)/i,Mod);
}

void dft(ll F[],int sgn)
{
    rep(i,0,L-1) A[i]=F[rev[i]];
    rep(i,0,L-1) F[i]=A[i];
    for (int i=2;i<=L;i<<=1)
    {
        ll wi=po[i]; if (sgn==-1) wi=pv[i];
        for (int k=0;k<L;k+=i)
        {
            ll ww=1,x=0,y=0;
            rep(j,0,i/2-1)
            {
                x=F[k+j]; y=ww*F[k+j+i/2]%Mod;
                F[k+j]=(x+y)%Mod; F[i/2+j+k]=(x-y+Mod)%Mod;
                ww=(ww*wi)%Mod;
            }
        }
    }
    if (sgn==-1)
    for (ll I=ksm(L,Mod-2,Mod),i=0;i<L;i++) F[i]=(F[i]*I)%Mod;
}

void Ksm(int y)
{
    F1[0]=1;
    while (y)
    {
        dft(F0,1);
        if (y&1)
        {
            dft(F1,1); rep(i,0,L-1) F1[i]=(F1[i]*F0[i])%Mod;
            dft(F1,-1);
            drep(i,L-1,m-1)  F1[i-m+1]=(F1[i-m+1]+F1[i])%Mod,F1[i]=0;
        }
        rep(i,0,L-1) F0[i]=(F0[i]*F0[i])%Mod;
        dft(F0,-1);
        drep(i,L-1,m-1)  F0[i-m+1]=(F0[i-m+1]+F0[i])%Mod,F0[i]=0;
        y>>=1;
    }
}


int main()
{
    n=r(); m=r(); X=r(); S=r(); 
    g=G(m);
    ll Q=1,qx;
    rep(i,1,m-2) Q=Q*g%m,pg[Q]=i;
    rep(i,1,S)
    {
        qx=r(); if (qx) F0[pg[qx]]=1;
    }
    Rader(m);
    Ksm(n);printf("%lld\n",F1[pg[X]]);
    return 0;
}


```

好啦就是这样,祝SDOI 2018 ++RP!

---

## 作者：Kelin (赞：16)

## [题意](https://blog.csdn.net/BeNoble_/article/details/79929605)

$a_i\in S,$求$\prod_{i=1}^na_i\equiv x\mod m$的方案数

$m\in P,m\le8000,n\le10^9,x\in[1,m-1]$

---

## 题解

设$f[i][j]$为$\prod_{k=1}^ia_k\equiv j\mod m$的方案数

那么有

$$f[i+1][j]=\sum_{ab\equiv j\mod m}f[i][a]f[i][b]$$

~~取个对数$\ln a+\ln b=\ln j$这样似乎就是卷积了~~

考虑到$m$是一个质数$,$然后注意到质数的原根$g$满足

$g^0,g^1,\ldots g^{m-2}$在模$m$的意义下可以取遍$[1,m-1]$所有数

设$g^A\equiv a\mod m,$因为$A$和$a$是一一对应的$,$不妨用$A$来替代$a$

那么有

$$f[i+1][J]=\sum_{g^Ag^B\equiv g^J\mod m}f[i][A]f[i][B]$$

$$\Rightarrow f[i+1][J]=\sum_{g^{A+B}\equiv g^J\mod m}f[i][A]f[i][B]$$

根据费马小定理$a^b\equiv a^{b\mod P-1}\mod P$

$$\Rightarrow f[i+1][J]=\sum_{g^{A+B\mod m-1}=g^J}f[i][A]f[i][B]$$

$$\Rightarrow f[i+1][J]=\sum_{A+B\equiv J\mod m-1}f[i][A]f[i][B]$$

设$g[J]=\sum\limits_{A+B=J}f[i][A]f[i][B]$

$$\Rightarrow f[i][J]=g[J]+g[J+m-1]$$

因为这是个卷积并且每一层的转移都是一样的$,$所以可以直接用多项式快速幂算

注意集合中有$0,$直接判掉即可

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=1e5+5,P=1004535809,G=3;
typedef int arr[N];
typedef long long ll;
int n,m,M,K,X,pw;arr a,b,c,pos,R,wn;
inline int pls(int a,int b){return a+=b,a<P?a:a-P;}
inline int sub(int a,int b){return a-=b,a<0?a+P:a;}
inline int fpm(int a,int b,const int P){int x=1;for(;b;b>>=1,a=(ll)a*a%P)if(b&1)x=(ll)x*a%P;return x;}
inline void init(){for(int i=0,j=0;i<K;++i){R[i]=j;for(int l=K>>1;(j^=l)<l;l>>=1);}}
inline void dft(int*a,int ty=1){
    fp(i,0,K-1)if(i>R[i])swap(a[i],a[R[i]]);
    for(int i=2;i<=K;i<<=1){
        int d=i>>1,o;wn[1]=ty==1?fpm(G,(P-1)/i,P):fpm(G,P-1-(P-1)/i,P);
        fp(i,2,d-1)wn[i]=(ll)wn[i-1]*wn[1]%P;
        for(int*x=a;x!=a+K;x+=i)fp(k,0,d-1)
            o=(ll)x[k+d]*wn[k]%P,x[k+d]=sub(x[k],o),x[k]=pls(x[k],o);
    }if(ty^1){
        const int inv=fpm(K,P-2,P);
        fp(i,0,K-1)a[i]=(ll)a[i]*inv%P;
    }
}
inline void calc(int*a){fp(i,0,m-1)a[i]=pls(a[i],a[i+m]);}
inline void Sqr(int*a){
    dft(a);fp(i,0,K-1)a[i]=(ll)a[i]*a[i]%P;
	dft(a,-1);calc(a);fp(i,m,K-1)a[i]=0;
}
inline void Mul(int*a,int*b){
    fp(i,0,m)c[i]=b[i];dft(a),dft(c);
    fp(i,0,K-1)a[i]=(ll)a[i]*c[i]%P;
    dft(a,-1);calc(a);fp(i,m,K-1)a[i]=c[i]=0;
}
inline void Fpm(int*x,int*a,int b){for(;b;b>>=1,Sqr(a))if(b&1)Mul(x,a);}
inline int Gg(const int P){
    static int s[N],t=0;bool fg;int Phi=P-1;
    fp(i,2,sqrt(Phi))if(Phi%i==0)s[++t]=i,Phi/i!=i?s[++t]=Phi/i:0;
    fp(i,2,Phi){fg=1;
        fp(j,1,t)if(fpm(i,s[j],P)==1){fg=0;break;}
        if(fg)return i;
    }return -1;
}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    sd(pw),sd(m),sd(X),sd(n);wn[0]=1;
    K=1;while(K<m)K<<=1;K<<=1;init();
    int p=1,g=Gg(m);fp(i,1,m-2)pos[(p*=g)%=m]=i;
    while(n--)sd(p),p?++b[pos[p]]:0;M=2*(--m);
    a[0]=1;Fpm(a,b,pw);we(a[pos[X]]);
return Ot(),0;
}
```

---

## 作者：kczno1 (赞：8)

a\*b mod m=x 将a,b,x都用原根g^i代替 就能换成加法

之后用f[i]表示和达到i的方案数

两个状态的合并就是做卷积

快速幂优化fft即可

怎么求质数p的原根?

就是将p-1分解质因数

因为g一般不会太大，所以可以暴力枚举原根g

之后枚举所有质因数，判断(g^((p-1)/质因数))%p是否都不等于1

如果都不等于1 g就是原根

注意如果S里有元素0 就删掉它

```cpp
#include<bits/stdc++.h>

const int N=1<<14,D=1004535809;
typedef long long ll;
int n,m,i,j,x,y;

int mi(int x,int y,int D)
{
    int ans=1;
    while(y)
    {
        if(y&1)ans=(ll)ans*x%D;
        x=(ll)x*x%D;y>>=1;
    }
    return ans;
}
int get_g(int p)
{
    static int may[100],top;
    top=0;
    int x=p-1;
    for(i=2;i*i<=x;++i) 
    if(!(x%i))
    {
        may[++top]=(p-1)/i;
        while(!(x%i)) x/=i;
    }
    if(x>1)may[++top]=(p-1)/x;
    
    int y;
    for(i=2;;++i)
    {
      for(j=1;y=may[j];++j) 
      if(mi(i,y,p)==1) break;
      if(!y) return i; 
    }
}

const int WN=mi(3,(D-1)/N,D),niv=mi(N,D-2,D);
int dy[8000];
ll a[N],b[N],*ans,temp[N],qa[N],qb[N],*wn;

int d;
void fft(int n=N,int s=0,int len=1)
{
    if(n==1)return ;
    int m=n>>1;
    fft(m,s,len<<1);fft(m,s+len,len<<1);
    int p=s,i;
    for(i=0;i<m;++i,p+=len<<1)
    {
        ll del=wn[i*len]*ans[p+len]%D;
        temp[i]=(ans[p]+del)%D;
        temp[i+m]=(ans[p]-del)%D;
    }
    p=s;
    for(i=0;i<n;++i,p+=len) ans[p]=temp[i];
}
void cheng(ll *b,ll *a)//b<-b*a
{
    for(i=0;i<N;++i) b[i]=b[i]*a[i]%D;
    ans=b;wn=qb;fft();
    for(i=0;i<N;++i) b[i]=b[i]*niv%D;
    for(i=d;i<(d<<1);++i) 
    {
               b[i-d]=(b[i-d]+b[i])%D;
               b[i]=0;
    }
}

int main()
{
    freopen("1.in","r",stdin);//freopen("")
    
    int goal,s;
    scanf("%d%d%d%d",&n,&m,&goal,&s);
    
    int g=get_g(m),now=1;
    d=m-1;
    for(i=0;i<d;++i,now=now*g%m) dy[now]=i;
    while(s--) { scanf("%d",&now);if(now)a[dy[now]]=1; }
    
    qa[0]=qb[0]=1;for(i=1;i<N;++i) qb[N-i]=qa[i]=qa[i-1]*WN%D;
    b[dy[1]]=1;
    while(n)
    {
      wn=qa;ans=a;fft();
      if(n&1) 
      {
          ans=b;fft();
        cheng(b,a);
      }
      cheng(a,a);
      n>>=1;
    }
    
    printf("%lld\n",(b[dy[goal]]+D)%D);
}
```

---

## 作者：览遍千秋 (赞：4)

## 问题描述

小 C 有一个集合 $S$，里面的元素都是小于 $M$ 的非负整数。他用程序编写了一个数列生成器，可以生成一个长度为 $N$ 的数列，数列中的每个数都属于集合 $S$。

小 C 用这个生成器生成了许多这样的数列。但是小 C 有一个问题需要你的帮助：给定整数 $x$，求所有可以生成出的，且满足数列中所有数的乘积 $\bmod M$ 的值等于 $x$ 的不同的数列的有多少个。小 C 认为，两个数列 $\{A_i\}$ 和 $\{B_i\}$ 不同，当且仅当至少存在一个整数 $i$，满足 $A_i \neq B_i$。另外，小 C 认为这个问题的答案可能很大，因此他只需要你帮助他求出答案 $\mod 1004535809$ 的值就可以了。

[BZOJ3992](https://www.lydsy.com/JudgeOnline/problem.php?id=3992)

[LG3321](https://www.luogu.com.cn/problem/P3321)

---

## 题解

一道好题！

### 第一类部分分 - $O(nm^2)$ $\mathrm{DP}$

设 $dp[i][j]$ 代表选取了 $i$ 个之后，膜 $M$ 为 $j$ 的方案数。

转移方程： $dp[i][j]=\sum\limits_{k=1}^{|S|}{\sum\limits_{p=0}^{M-1}{dp[i-1][S_k \times p \bmod M]}}$

边界条件： $dp[1][j]=[j \in S]$

时间复杂度 $O(nm^2)$ ，期望得分 $10$ 分。

### 第二类部分分 - $O(m^2 \log_2 n)$ $\mathrm{DP}$

设 $f[i][j]$ 代表选取 $2^i$ 个之后，膜 $M$ 为 $j$ 的方案数。

预处理 $f$ 之后，可以类似于快速幂地求解。

### 正解

对于第二类部分分，发现在 $\sum$ 下是 $A \times B = C$ ，不是很好处理。

考虑对其取对数，令 $a=log_g A$，则为 $a+b=c$ ，卷积形式，可以用 NTT 优化。

至于映射关系，在膜 $M$ 意义下，根据原根的性质，取对数可以转化为 $g^{a} \bmod M$ ， $a$ 的取值范围为 $[0,M-1)$ 。

然后 NTT 的一些实现细节，还需要再想想。

---

## $\mathrm{Code}$

### 10pts

```cpp
#include<bits/stdc++.h>
using namespace std;

template <typename Tp>
void read(Tp &x){
	x=0;char ch=1;int fh=1;
	while(ch!='-'&&(ch>'9'||ch<'0')) ch=getchar();
	if(ch=='-') fh=-1,ch=getchar();
	while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	x*=fh;
}

const int maxS=8000+7;
const int mod=1004535809;

int n,m,x,S;
int a[maxS];

void Init(void){
	read(n);read(m);read(x);read(S);
	for(int i=1;i<=S;i++) read(a[i]);
}

int dp[1007][maxS];

void Work(void){
	for(int i=1;i<=S;i++) dp[1][a[i]]++;
	for(int i=2;i<=n;i++){
		for(int j=1;j<=S;j++){
			for(int k=0;k<m;k++){
				int p=(long long)k*a[j]%m;
				dp[i][p]=(dp[i][p]+dp[i-1][k])%mod;
			}
		}
	}
	printf("%d\n",dp[n][x]);
}

int main(){
	Init();Work();
	return 0;
}
```

### 60pts

```cpp
#include<bits/stdc++.h>
using namespace std;

template <typename Tp>
void read(Tp &x){
	x=0;char ch=1;int fh=1;
	while(ch!='-'&&(ch>'9'||ch<'0')) ch=getchar();
	if(ch=='-') fh=-1,ch=getchar();
	while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	x*=fh;
}

const int maxS=8000+7;
const int mod=1004535809;

int n,m,x,S;
int a[maxS];
int dp[maxS],opt[maxS];
//bool exist[maxS];

void Init(void){
	read(n);read(m);read(x);read(S);
	for(int i=1;i<=S;i++) read(a[i]),dp[a[i]]=1;
}

int tmp[maxS];

int power(int x,int p,int mod){
	int res(1);
	while(p){
		if(p&1) res=(long long)res*x%mod;p>>=1;
		x=(long long)x*x%mod;
	}
	return res;
}

void mul(int *f,int *g,int *res){
	for(int i=0;i<m;i++){
	//	if(!exist[i]) continue;
		for(int j=0;j<m;j++){
			int p=(long long)i*j%m;
			tmp[p]=(tmp[p]+(long long)f[i]*g[j]%mod)%mod;
		}
	}
	for(int i=0;i<m;i++) res[i]=tmp[i],tmp[i]=0;
}

void fpow(int p){
	while(p){
		if(p&1) mul(dp,opt,opt);
		mul(dp,dp,dp);p>>=1;
	}
}

void Work(void){
	opt[1]=1;fpow(n);
	printf("%d\n",opt[x]);
}

int main(){
	Init();
	Work();
	return 0;
}
```

### 100pts

```cpp
#include<bits/stdc++.h>
using namespace std;

template <typename Tp>
void read(Tp &x){
	x=0;char ch=1;int fh=1;
	while(ch!='-'&&(ch>'9'||ch<'0')) ch=getchar();
	if(ch=='-') fh=-1,ch=getchar();
	while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	x*=fh;
}

const int maxS=16000+7;
const int mod=1004535809;

int n,m,x,S;
int a[maxS];
int dp[maxS<<1],opt[maxS<<1];

int power(int x,int p,int mod){
	int res(1);
	while(p){
		if(p&1) res=(long long)res*x%mod;p>>=1;
		x=(long long)x*x%mod;
	}
	return res;
}

bool check(int g,int p){
	int q=p-1;
	for(int i=2;(long long)i*i<=q;i++){
		if(q%i==0&&(power(g,i,p)==1||power(g,q/i,p)==1)) return false;
	}
	return true;
}

int getG(int k){
	for(int i=2;i<=100;i++) if(check(i,k)) return i;
	return -1;
}

int pos[maxS];
int Gm,Gd=3;
int invG=power(Gd,mod-2,mod);

int tr[maxS<<1];
int lim;

void NTT(int *f,int type){
	for(int i=0;i<lim;i++) if(i<tr[i]) swap(f[i],f[tr[i]]);
	for(int dlen=2;dlen<=lim;dlen<<=1){
		int len=dlen>>1,w;
		if(type==1) w=power(Gd,(mod-1)/dlen,mod);
		else w=power(invG,(mod-1)/dlen,mod);
		for(int k=0;k<lim;k+=dlen){
			int buf=1;
			for(int l=0;l<len;l++){
				int LF=f[k+l],RF=(long long)buf*f[len+k+l]%mod;
				f[k+l]=(LF+RF)%mod,f[k+l+len]=(LF-RF+mod)%mod;
				buf=(long long)buf*w%mod;
			}
		}
	}
	if(type==-1){
		int inv=power(lim,mod-2,mod);
		for(int i=0;i<lim;i++) f[i]=(long long)f[i]*inv%mod;
	}
}

void Init(void){
	read(n);read(m);read(x);read(S);
	Gm=getG(m);
//	printf("** GM = %d , invG = %d\n",Gm,invG);
	for(int i=0;i<m-1;i++){
		int Pos=power(Gm,i,m);
		pos[Pos]=i;
	}
	for(int i=1;i<=S;i++){
		read(a[i]);
		if(a[i]) dp[pos[a[i]]]++;
	}
//	for(int i=1;i<=m;i++){
//		printf("%d %d\n",dp[i],pos[i]);
//	}
}

int tmp[maxS],FF[maxS<<1],GG[maxS<<1];

void mul(int *f,int *g,int *res){
	for(int i=0;i<lim;i++) FF[i]=f[i],GG[i]=g[i];
	NTT(FF,1);NTT(GG,1);
	for(int i=0;i<lim;i++) FF[i]=(long long)FF[i]*GG[i]%mod;
	NTT(FF,-1);
	for(int i=0;i<m-1;i++) res[i]=(FF[i]+FF[i+m-1])%mod;
}

void fpow(int p){
	while(p){
		if(p&1) mul(opt,dp,opt);
		mul(dp,dp,dp);p>>=1;
	}
}

void Work(void){
	for(lim=1;lim<=m*2;lim<<=1);
//	printf("** lim = %d\n",lim);
	for(int i=0;i<lim;i++) tr[i]=(tr[i>>1]>>1)|((i&1)?lim>>1:0);
	opt[pos[1]]=1;fpow(n);
	printf("%d\n",opt[pos[x]]);
}

int main(){
//	printf("**%d\n",getG(12289)); 
	Init();
	Work();
	return 0;
}
```

---

## 作者：hl666 (赞：4)

一道不错的**多项式**好题。还涉及了一些数论内容。

首先我们看到题目是求**乘积**模$m$的方案数，考虑到这种方案数我们一般都可以用**生成函数**来做。

但显然卷积的下标有加（**FFT,NTT**等）有位运算（**FWT**）但是没有乘法的。~~除非您十分dalao自己发明一个卷积算法~~

所以我们考虑**化乘为加**，我们注意到$m$是一个不大的指数，那么意味这我们可以利用同余系下的一大利器——**原根**

关于原根的主要性质，其实就是原根$g$，满足$g^0,g^1\dots g^{m-2}$模$m$后各不相同。

所以我们可以暴力找出原根（可以参考[dalao's blog](https://blog.csdn.net/zhouyuheng2003/article/details/**80163139**)），然后把每一个数转化为原根的**幂指数**

这样我们把两个数相乘时其实就是**指数相加**，那么直接**多项式快速幂**即可。

但是注意到这里的下标其实是在模意义下的，并且根据**欧拉定理**我们还可以知道指数模的是$m-1$（不是$m$！），这个我们在做完**NTT**时把跑到后面的项手动加到前面去就可以了。

复杂度$O(m\log^2 n)$，实测跑得非常快。

CODE

```cpp
#include<cstdio>
#define RI register int
using namespace std;
const int M=8005,mod=1004535809;
int n,m,tar,s,t,x,root,A[M<<2],rg[M],rst[M],cnt;
inline int quick_pow(int x,int r,int p=mod,int mul=1)
{
    for (;r;r>>=1,x=1LL*x*x%p) if (r&1) mul=1LL*mul*x%p; return mul;
}
inline int get_root(int x)
{
    RI i; for (i=2;i<=x-2;++i) if ((x-1)%i==0)
    rg[++cnt]=i; for (i=2;;++i)
    { 
        bool flag=1; for (RI j=1;j<=cnt;++j)
        if (quick_pow(i,rg[j],x)==1) { flag=0; break; }
        if (flag) return i;
    }
}
inline void inc(int& x,int y)
{
    if ((x+=y)>=mod) x-=mod;
}
inline void dec(int& x,int y)
{
    if ((x-=y)<0) x+=mod;
}
class Poly_Solver
{
    private:
        int rev[M<<2],T[M<<2],lim,p;
        inline void init(int n)
        {
            for (lim=1;lim<=n;lim<<=1,++p);
            for (RI i=0;i<lim;++i) rev[i]=(rev[i>>1]>>1)|((i&1)<<p-1);
        }
        inline void swap(int& x,int& y)
        {
            int t=x; x=y; y=t;
        }
        inline void NTT(int *f,int opt)
        {
            RI i; for (i=0;i<lim;++i) if (i<rev[i]) swap(f[i],f[rev[i]]);
            for (i=1;i<lim;i<<=1)
            {
                int m=i<<1,D=quick_pow(3,opt==1?(mod-1)/m:mod-1-(mod-1)/m);
                for (RI j=0;j<lim;j+=m)
                {
                    int W=1; for (RI k=0;k<i;++k,W=1LL*W*D%mod)
                    {
                        int x=f[j+k],y=1LL*f[i+j+k]*W%mod;
                        f[j+k]=f[i+j+k]=x; inc(f[j+k],y); dec(f[i+j+k],y);
                    }
                }
            }
            if (opt==-1)
            {
                int Inv=quick_pow(lim,mod-2);
                for (i=0;i<lim;++i) f[i]=1LL*f[i]*Inv%mod;
            }
        }
        inline void mul_self(int *A)
        {
            RI i; for (NTT(A,1),i=0;i<lim;++i)
            A[i]=1LL*A[i]*A[i]%mod;
            NTT(A,-1); for (i=lim-1;i>=m-1;--i) inc(A[i-m+1],A[i]),A[i]=0;
        }
        inline void mul(int *A,int *B)
        {
            RI i; for (NTT(A,1),NTT(B,1),i=0;i<lim;++i) A[i]=1LL*A[i]*B[i]%mod;
            NTT(A,-1); NTT(B,-1); for (i=lim-1;i>=m-1;--i) inc(A[i-m+1],A[i]),A[i]=0;
        }
    public:
        inline int pow(int *A,int r,int tar)
        {
            for (init(m<<1),T[0]=1;r;r>>=1,mul_self(A))
            if (r&1) mul(T,A); return T[tar];
        }
}P;
int main()
{
    RI i; scanf("%d%d%d%d",&n,&m,&tar,&s); root=get_root(m);
    for (x=i=1;i<=m-2;++i) rst[x=1LL*x*root%m]=i;
    for (i=1;i<=s;++i) scanf("%d",&x),x&&(A[rst[x]]=1);
    return printf("%d\n",P.pow(A,n,rst[tar])),0;
}
```

---

## 作者：Doingdong (赞：3)

离散傅里叶变换公式
![](https://img-blog.csdn.net/20140903142657745)

逆变换
![](https://img-blog.csdn.net/20140903142801393)

w满足的w^n==1，在快速数论变换来说，原根g可以看成是w，**g^((p-1)/n)**相当于w^1

所以p-1必须是n的倍数，而n又通常是2的幂次方，所以p-1是2的幂次方

[luoguP3321/学校oj1455](https://www.luogu.org/problemnew/show/P3321#sub)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define rep(i,j,k) for(int i=j;i<=k;++i)
char cch;
inline int rd(){
	int x=0,fl=1;
	cch=getchar();
	while(cch>'9'||cch<'0'){
		if(cch=='-') fl=-1;
		cch=getchar();
	}
	while(cch>='0'&&cch<='9') x=(x<<1)+(x<<3)+cch-'0',cch=getchar();
	return x*fl; 
}
int kpow(int a,int b,int m ){
	int re=1;
	while(b){
		if(b&1) re=1ll*re*a%m ;
		a=1ll*a*a%m ,b>>=1;
	}
	return re;
}
int q[8000],tot;
int get(int m){
	int x=m-1;
	for(int i=2;i*i<=x;++i) if(x%i==0){
		q[++tot]=i;
		while(x%i==0) x/=i; 
	}
	if(x>1) q[++tot]=x;
	for(int i=2;;++i){
		bool bl=1;
		rep(j,1,tot) if(kpow(i,(m-1)/q[j],m)==1){bl=0;break;}
		if(bl) return i;
	}
}
const int mod=1004535809;
int fpow(int a,int b){
	int re=1;
	while(b){
		if(b&1) re=1ll*re*a%mod;
		a=1ll*a*a%mod,b>>=1;
	}
	return re;
}
int rev[32009],g,n,m;
void ntt(int a[],int len,int op){
	int mid,t1,t2;
	for(int i=0;i<len;++i) if(i<rev[i]) swap(a[i],a[rev[i]]);
	int wn,w1;
	for(int i=2;i<=len;i<<=1){
		mid=i>>1;wn=fpow(3,(mod-1)/i);if(op==-1) wn=fpow(wn,mod-2);
		for(int j=0;j<len;j+=i){
			w1=1;
			for(int k=0;k<mid;++k){
				t1=a[j+k],t2=1ll*a[j+mid+k]*w1%mod;
				a[j+k]=( t1+t2 )%mod,a[j+mid+k]=1ll*(t1-t2+mod)%mod;
				w1=1ll*w1*wn%mod;
			}
		}
	}
	if(op==-1){
		int inv=fpow(len,mod-2);
		for(int i=0;i<len;++i) a[i]=1ll*a[i]*inv%mod;
	}
}
int re[32009],a[32009],d[8000],len;
void ffpow(int b){
    re[0]=1;
    while (b){
        ntt(a,len,1);
        if (b&1){
            ntt(re,len,1);for(int i=0;i<len;++i) re[i]=1ll*re[i]*a[i]%mod;
            ntt(re,len,-1);
            for(int i=len-1;i>=m-1;--i)  re[i-m+1]=(re[i-m+1]+re[i])%mod,re[i]=0;
        }
        for(int i=0;i<len;++i) a[i]=1ll*a[i]*a[i]%mod;
        ntt(a,len,-1);
        for(int i=len-1;i>=m-1;--i)  a[i-m+1]=(a[i-m+1]+a[i])%mod,a[i]=0;
        b>>=1;
    }
}

int main(){
	int x,sn,si;
	n=rd(),m=rd(),x=rd(),sn=rd();
	g=get(m);
	int xx=m-2,y=1;
	rep(i,1,xx) y=1ll*y*g%m,d[y]=i;
	rep(i,1,sn){
		si=rd();
		if(si) a[d[si]]=1;//一定要特判 0，不然只能在学校oj上通过， 
	}
	len=2;
	while(len<=m) len<<=1;
	len<<=1;
	for(int i=0;i<len;++i) rev[i]=(rev[i>>1]>>1)|((i&1)*(len>>1));
	ffpow( n);
	printf("%d\n",re[d[x]]);
}
```

---

## 作者：LastKismet (赞：0)

# Sol
首先，乘法可以通过对数运算转换为加法。这样可以把这道题变化为一个经典套路。

由于要取模，我们需要保证范围内每个数的对数唯一，显然可以使用原根为底数。找原根暴力判即可。

定义 $ans_{i,j}$ 表示选 $i$ 个和为 $j$ 的答案，不难想到 $ans_i$ 可以由 $ans_{i-1}$ 卷积而来。卷积部分是最基本的，这里就不放多余的公式了。

但 $n$ 有 $10^9$ 欸，所以不能一层一层卷了，考虑倍增法，$ans_{i,j}$ 表示选 $2^i$ 个和为 $j$ 的答案。使用 FFT/NTT 优化卷积转移即可。

最后复杂度 $O(m\log n\log m)$。

# Code
```cpp
const int N=8005,M=8005,T=35;

int n,m,x,s,G;
int tcnt[M],lg[M];
inline bool check(int i){
    repl(i,0,m)tcnt[i]=0;
    mint r(1,m);
    repl(j,0,m-1){
        ++tcnt[r.x];
        if(tcnt[r.x]>1)return 0;
        r*=i;
    }
    return 1;
}
inline void init(){
    repl(i,2,m)if(check(i)){G=i;break;}
    mint r(1,m);
    repl(j,0,m-1)lg[r.x]=j,r*=G;
}

namespace NTT{
    const mint p=0,g=3,gi=334845270;
    typedef vec<mint> poly;
    vec<int> r;
    void ntt(int lim,poly &a,int type){
        a.resize(lim);
        repl(i,0,lim)if(i<r[i])swap(a[i],a[r[i]]);
        for(int mid=1;mid<lim;mid<<=1){
            mint w1=((~type)?g:gi)^((p-1)/(mid<<1));
            for(int j=0;j<lim;j+=(mid<<1)){
                mint w=1;
                repl(k,0,mid){
                    mint x=a[j+k],y=w*a[j+mid+k];
                    a[j+k]=x+y;
                    a[j+mid+k]=x-y;
                    w=w*w1;
                }
            }
        }
    }
    poly operator*(poly a,poly b){
        int lim=1,l=0,len=a.size()+b.size()-1;
        while(lim<a.size()+b.size())lim<<=1,l++;
        r.resize(lim);
        repl(i,0,lim)r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
        ntt(lim,a,1);ntt(lim,b,1);
        repl(i,0,lim)a[i]=a[i]*b[i];
        ntt(lim,a,-1);
        a.resize(len);
        mint inv=(mint)lim^(p-2);
        repl(i,0,a.size())a[i]*=inv;
        repl(i,m-1,a.size())a[i%(m-1)]+=a[i];
        a.resize(m-1);
        return a;
    }
    poly operator+(poly a,poly b){
        if(a.size()<b.size())a.resize(b.size());
        repl(i,0,b.size())a[i]=a[i]+b[i];
        return a;
    }
    poly operator-(poly a,poly b){
        if(a.size()<b.size())a.resize(b.size());
        repl(i,0,b.size())a[i]=a[i]-b[i]+p;
        return a;
    }
}
using namespace NTT;


int tt;
poly v[T];
poly ans;

inline void Main(){
    read(n,m,x,s);
    init();
    tt=__lg(n);
    v[0].resize(m-1);
    rep(i,1,s){
        int a;read(a);if(!a)continue;
        a=lg[a];
        ++v[0][a];
    }
    rep(t,1,tt)v[t]=v[t-1]*v[t-1];
    ans.resize(m-1);ans[0]=1;
    rep(t,0,tt)if(n&1<<t)ans=ans*v[t];
    put(ans[lg[x]]);
}
```

---


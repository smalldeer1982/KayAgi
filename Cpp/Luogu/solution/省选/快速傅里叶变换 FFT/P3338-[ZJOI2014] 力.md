# [ZJOI2014] 力

## 题目描述

给出 $n$ 个数 $q_1,q_2, \dots q_n$，定义

$$F_j~=~\sum_{i = 1}^{j - 1} \frac{q_i \times q_j}{(i - j)^2}~-~\sum_{i = j + 1}^{n} \frac{q_i \times q_j}{(i - j)^2}$$

$$E_i~=~\frac{F_i}{q_i}$$

对 $1 \leq i \leq n$，求 $E_i$ 的值。


## 说明/提示

【数据范围】   
对于 $30\%$ 的数据，$n \leq 1000$；   
对于 $50\%$ 的数据，$n \leq 6 \times 10^4$；   
对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$0 < q_i < 10^9$。

## 样例 #1

### 输入

```
5
4006373.885184
15375036.435759
1717456.469144
8514941.004912
1410681.345880```

### 输出

```
-16838672.693
3439.793
7509018.566
4595686.886
10903040.872```

# 题解

## 作者：基地A_I (赞：228)

[博客园食用通道](https://www.cnblogs.com/BaseAI/p/12042061.html)

# 题目地址

[洛谷P3338](https://www.luogu.com.cn/problem/P3338)

# Solution

第一道FFT的应用AC祭！

我们要求:

$$E_j=\frac{F_j}{q_j}=\sum_{i<j}\frac{q_i}{(i-j)^2}-\sum_{i>j}\frac{q_i}{(i-j)^2}$$

（$q_j$ 直接在除法的时候消掉了qwq）

- ## Step 0 卷积是什么？

首先我们要有明确的目标，我们要把上面的式子推成卷积的形式，我们就要来回顾一下卷积是什么。卷积的形式如下：

$$C_k=\sum_{i=0}^{k}A_i*B_{k-i}$$

- ## Step 1 直接推式子

有了目标，我们就好来推式子了（~~推式子真好玩~~），下面给出推理的重要步骤，尽量没有繁琐的步骤，读者可以自己思考一下。

$$E_j=\sum_{i<j}\frac{q_i}{(i-j)^2}-\sum_{i>j}\frac{q_i}{(i-j)^2}$$

改变一下 $\sum$ 的上下标表示形式，原式变成

$$\sum_{i=1}^{j-1}\frac{q_i}{(i-j)^2}-\sum_{i=j+1}^{n}\frac{q_i}{(i-j)^2}$$

如果 $i=j$ 也累加进去，对答案不影响，所以式子变成

$$\sum_{i=1}^{j}\frac{q_i}{(i-j)^2}-\sum_{i=j}^{n}\frac{q_i}{(i-j)^2}$$


- ## Step 2 转化

设 $f[i]=q_i,g[i]=\frac{1}{i^2}$ ，所以原式变成

$$\sum_{i=1}^{j}f[i]*g[j-i]-\sum_{i=j}^{n}f[i]*g[i-j]$$

令 $f[0]=0,g[0]=0$，则原式变成

$$\sum_{i=0}^{j}f[i]*g[j-i]-\sum_{i=j}^{n}f[i]*g[i-j]$$

**这时我们发现，左边已经是一个卷积的形式，所以我们直接来推右边**

将 $\sum_{i=j}^{n}f[i]*g[i-j]$ 展开，发现：

$$f[j]*g[0]+f[j+1]*g[1]+...+f[j+(n-j)]*g[n-j]$$

所以我们可以将原式写成

$$\sum_{i=0}^{n-j}f[j+i]*g[i]$$

- ## Step 3 继续转化

引入 $f'[i]=f[n-i]$ ，实际上这是一种翻转的套路。则原式可写为

$$\sum_{i=0}^{n-j}f'[n-(j+i)]*g[i]$$

即

$$\sum_{i=0}^{n-j}f'[n-j-i]*g[i]$$

令 $t = n-j$，则原式等于

$$\sum_{i=0}^{t}f'[t-i]*g[i]$$

**至此，我们成功的把两个式子化成了卷积！！！**

总结一下：

$$E_j=\sum_{i=0}^{j}f[i]*g[j-i]-\sum_{i=0}^{t}f'[t-i)]*g[i]$$

- ## Step 4 $FFT$加速卷积

设有多项式 $A(x)=\sum_{i=0}^{n}f[i]$ , $B(x)=\sum_{i=0}^{n}g[i]$ , $C(x)=\sum_{i=0}^{n}f'[i]$,

我们令 $L(x)=A(x)*B(x)$ , $R(x)=C(x)*B(x)$

所以 $Ans[i]=l_i - r_{n-i}$ （$l_i,r_i$ 分别是多项式 $L(x)$ 和 $R(x)$ $x^i$ 的系数）

- ## Step 5 读到这里，你和暴力选手还没有差别 (逃

> 世界上卡你精度的办法有千千万万种。                ----By me

注意 $g[i]=\frac{1}{i^2}$

楼主在处理这里的时候写的是 ``1.0/(i*i*1.0)``，交上去只有 $30pts$。

在题解中看到大佬们处理这里时用的 ``(double)(1.0 / i / i)``，改一下后，$100pts$。

**如果大家对处理精度问题有什么独特的见解，记得和我分享分享QwQ**

# Code

Talk is cheap.Show me the code.

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read() {
	int x=0,f=1; char ch=getchar();
	while(ch<'0' || ch>'9') { if(ch=='-') f=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') { x=(x<<3)+(x<<1)+(ch^48); ch=getchar(); }
	return x * f;
}
const int N = 400007;
const double pi = acos(-1.0);
int n;
int rev[N];
struct CP {
	double x,y;
	CP operator + (CP el) { return (CP)<%x+el.x , y+el.y%>; }
	CP operator - (CP el) { return (CP)<%x-el.x , y-el.y%>; }
	CP operator * (CP el) { return (CP)<%x*el.x-y*el.y , x*el.y+y*el.x%>; }
}a[N],b[N],c[N];
void FFT(CP *A,int n,int flag) {
	for(int i=0;i<n;++i) if(i < rev[i]) swap(A[i],A[rev[i]]);
	for(int mid=1;mid<n;mid<<=1) {
		CP Wn = (CP)<%cos(2*pi/(mid<<1)) , flag*sin(2*pi/(mid<<1))%>;
		for(int i=0;i<n;i+=(mid<<1)) {
			CP W = (CP)<%1 , 0%>;
			for(int j=0;j<mid;++j,W=(W*Wn)) {
				CP tmp0 = A[i+j], tmp1 = W*A[i+mid+j];
				A[i+j] = tmp0 + tmp1;
				A[i+mid+j] = tmp0 - tmp1;
			}
		}
	}
	if(flag == -1) {
		for(int i=0;i<n;++i) A[i].x /= n;
	}
}
int main()
{
	//freopen("Li.txt","r",stdin);
	//freopen("My.out","w",stdout);
	n = read();
	for(int i=1;i<=n;++i) {
		scanf("%lf",&a[i].x);
		c[n-i].x = a[i].x;
		b[i].x = (double)(1.0 / i / i);
	}
	int lim = 1, L = 0; while(lim <= (n<<1)) lim <<= 1, ++L;
	for(int i=0;i<lim;++i) rev[i] = (rev[i>>1]>>1) | ((i&1)<<(L-1));
	FFT(a,lim,1), FFT(b,lim,1), FFT(c,lim,1);
	for(int i=0;i<lim;++i) a[i] = a[i]*b[i], c[i] = c[i]*b[i];
	FFT(a,lim,-1), FFT(c,lim,-1);
	for(int i=1;i<=n;++i)
		printf("%.3lf\n",a[i].x-c[n-i].x);
	return 0;	
}
/*
5
4006373.885184
15375036.435759
1717456.469144
8514941.004912
1410681.345880

-16838672.693
3439.793
7509018.566
4595686.886
10903040.872
*/
```

# Summary

推理过程大部分是我自己的手推，和其他大佬不同请见谅，~~毕竟条条大路通罗马呗~~。

过程中的转折点就是我推不动的时候，所这个题目让我学会了：

- 卷积 (雾 ，~~要把式子推成卷积形式~~

- 巧设数组代替抽象的数学式子

- 翻转序列的技巧

我多项式还是太菜了呢，赶紧去做题吧！QAQ

**各位看官看到我这个多项式小白写了这么多，不妨点个赞吧qwq！**

---

## 作者：dormantbs (赞：39)

$$ E_j = \frac{F_j}{q_j} = \sum_{i < j} \frac{q_i}{(i - j) ^ 2} -\sum_{i > j}\frac{q_i}{(i - j) ^ 2}$$
设
$$ f[i] = q_i,g[i] = \frac{1}{i^2} $$
则原式变成
$$ \sum_{i < j} f[i]g[j - i] -\sum_{i > j} f[i]g[j - i]$$
即
$$ \sum_{i = 0}^{j - 1}f[i]g[j-i] - \sum_{i = j + 1}^{n}f[i]g[j-i]$$
设$f'$ 表示$f$ 反向后的值，则原式可写成
$$ \sum_{i = 0}^{j - 1}f[i]g[j - i] - \sum_{i = 0}^{j - 1}f'[i]g[j-i]$$
容易看出来这就是个卷积的形式，直接FFT求即可
```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>

using namespace std;

const int N = 3e5 + 5;
const double PI = acos(-1);

class _comp {
	public:
		double r, i;
    
		_comp(double r = 0.0, double i = 0.0) :
			r(r), i(i) {}

		friend _comp operator + (_comp a, _comp b) {
			return _comp(a.r + b.r, a.i + b.i);
		}

		friend _comp operator - (_comp a, _comp b) {
			return _comp(a.r - b.r, a.i - b.i);
		}

		friend _comp operator * (_comp a, _comp b) {
			return _comp(a.r * b.r - a.i * b.i, a.r * b.i + a.i * b.r);
		}
} f[N], g[N];

int r[N], n, fn;
double p[N], q[N], t[N], a[N], b[N];

inline int init() {
	int log_n = 0, fn;
	for(fn = 1; fn < (n << 1); fn <<= 1) ++log_n;
	for(int i = 0; i < fn; ++i)
	  r[i] = (r[i >> 1] >> 1) | ( (i & 1) << (log_n - 1) );
	return fn;
}

inline void fft(_comp *a, int n, int op) {
	for(int i = 0; i < n; ++i)
	  if(i < r[i]) swap(a[i], a[ r[i] ]);

	for(int i = 1; i < n; i <<= 1) {
		_comp wn = _comp( cos(PI / i), op * sin(PI / i) );
		for(int p = i << 1, j = 0; j < n; j += p) {
			_comp w = _comp(1, 0);
			for(int k = 0; k < i; ++k, w = w * wn) {
				_comp x = a[j + k], y = w * a[i + j + k];
				a[j + k] = x + y, a[i + j + k] = x - y;
			}
		}
	}
}

inline void work(double *a, double *b, double *res) {
	for(int i = 0; i < fn; ++i)
	  f[i].r = a[i], g[i].r = b[i],
	  f[i].i = 0, g[i].i = 0;

	fft(f, fn, 1), fft(g, fn, 1);
	for(int i = 0; i < fn; ++i)
	  f[i] = f[i] * g[i];

	fft(f, fn, -1);
	for(int i = 1; i <= n; ++i)
		res[i] = f[i].r / fn;
}

int main() {
	if(fopen("test.in", "r")) {
		freopen("test.in", "r", stdin);
		freopen("test.out", "w", stdout);
	}
	
	scanf("%d", &n);
	fn = init();
	for(int i = 1; i <= n; ++i) {
	  scanf("%lf", &p[i]);
	  t[i] = (double)(1.0 / i / i);
	  q[i] = p[i];
	}
	
	reverse(p + 1, p + n + 1);

	work(q, t, a);
	work(p, t, b);

	for(int i = 1; i <= n; ++i)
	  printf("%.3lf\n", a[i] - b[n - i + 1]);
}

```

---

## 作者：poorpool (赞：22)

我发现我的构造方法好像不太一样而且比较显然？……先读入 $q$ 数组（下表从零开始）。

记 $i < j$ 时，$a_{i-j}=-1/i^2$；$i > j$ 时，$a_{i-j}=1/i^2$；$i = j$ 时，$a_{i-j}=0$。

答案 $E_i=\sum_{j=0}^{n-1}a_{i-j}q_j$，可以用 FFT 优化，于是就做完了……吗？

发现 $a$ 的下标可能会为负，那我们就整体平移一下，使得 $E_i=\sum_{j=0}^{n-1}a_{i-j+n-1}q_j$，那么答案就是 $E$ 数组的 $0+n-1 \ldots n-1+n-1$ 项了。（原先是 $0 \ldots n-1$ 项）

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
int n, lim=1, limcnt, rev[524305];
double q[100005];
const double PI=acos(-1.0);
struct Complex{
	double x, y;
	Complex(double u=0.0, double v=0.0){
		x = u; y = v;
	}
	Complex operator+(const Complex &u)const{
		return Complex(x+u.x, y+u.y);
	}
	Complex operator-(const Complex &u)const{
		return Complex(x-u.x, y-u.y);
	}
	Complex operator*(const Complex &u)const{
		return Complex(x*u.x-y*u.y, x*u.y+y*u.x);
	}
}a[524305], b[524305];
void fft(Complex a[], int opt){
	for(int i=0; i<lim; i++)
		if(i<rev[i])
			swap(a[i], a[rev[i]]);
	for(int i=2; i<=lim; i<<=1){
		int tmp=i>>1;
		Complex wn=Complex(cos(2*PI/i), opt*sin(2*PI/i));
		for(int j=0; j<lim; j+=i){
			Complex w=Complex(1.0, 0.0);
			for(int k=0; k<tmp; k++){
				Complex tmp1=a[j+k], tmp2=w*a[j+k+tmp];
				a[j+k] = tmp1 + tmp2;
				a[j+k+tmp] = tmp1 - tmp2;
				w = w * wn;
			}
		}
	}
	if(opt==-1)
		for(int i=0; i<lim; i++)
			a[i].x /= lim;
}
int main(){
	cin>>n;
	for(int i=0; i<n; i++)
		scanf("%lf", &b[i].x);
	for(int i=-n+1; i<=n-1; i++){
		if(i<0)
			a[i+n-1].x = -1.0 / i / i;
		else if(i==0)
			a[i+n-1].x = 0;
		else
			a[i+n-1].x = 1.0 / i / i;
	}
	while(lim<=3*(n-1))	lim <<= 1, limcnt++;
	for(int i=0; i<lim; i++)
		rev[i] = (rev[i>>1]>>1) | ((i&1)<<(limcnt-1));
	fft(a, 1);
	fft(b, 1);
	for(int i=0; i<lim; i++)
		a[i] = a[i] * b[i];
	fft(a, -1);
	for(int i=0; i<n; i++)
		printf("%.12f\n", a[i+n-1].x);
	return 0;
}
```



---

## 作者：Orion545 (赞：10)

# 广告

### [蒟蒻のblog](http://www.cnblogs.com/dedicatus545/p/8830852.html)

# 正文

把要求的公式列出来：

### $E_i=\frac{F_i}{q_i}=\sum_{j=1}^i\frac{q_j}{\left(i-j\right)^2}-\sum_{j=i+1}^n\frac{q_j}{\left(i-j\right)^2}$

令$x_i=\frac1{i^2}$，那么

### $E_i=\sum_{j=1}^iq_jx_{i-j}-\sum_{j=i+1}^nq_jx_{j-i}$

那我们再令$p_i=q_{n-i+1}$，那么

### $E_i=\sum_{j=1}^iq_jx_{i-j}-\sum_{j=i+1}^np_{n-j}x_{j-i}$

此时我们发现式子的左侧和右侧都是一个卷积的形式

那么，我们就可以用FFT来维护这个过程了

将数列$q_i$,$p_i$,$x_i$作为多项式$A$,$B$,$C$的系数

将他们用fft乘起来，得到的$A\ast C$,$B\ast C$的系数做差，就是$E_i$的值

# Code:

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
struct complex{
    double x,y;
    complex(double xx=0,double yy=0){x=xx;y=yy;}
    complex operator +(const complex &b){return complex(b.x+x,b.y+y);}
    complex operator -(const complex &b){return complex(-b.x+x,-b.y+y);}
    complex operator *(const complex &b){return complex(x*b.x-y*b.y,x*b.y+y*b.x);}
}A[410010],B[410010],C[410010];
const double pi=acos(-1.0);
int n,limit=1,cnt=0,r[410010];
void fft(complex *a,double type){
    int i,mid,j,k,R;complex w,wn,x,y;
    for(i=0;i<limit;i++) if(i<r[i]) std::swap(a[i],a[r[i]]);
    for(mid=1;mid<limit;mid<<=1){
        wn=complex(cos(pi/mid),type*sin(pi/mid));
        for(R=mid<<1,j=0;j<limit;j+=R){
            w=complex(1,0);
            for(k=0;k<mid;k++,w=w*wn){
                x=a[j+k];y=w*a[j+k+mid];
                a[j+k]=x+y;
                a[j+k+mid]=x-y;
            }
        }
    }
}
int main(){
    scanf("%d",&n);int i;
    for(i=1;i<=n;i++) scanf("%lf",&A[i].x),B[n+1-i].x=A[i].x;
    for(i=1;i<=n;i++) C[i].x=(1.0/double(i))/double(i);
    
    while(limit<=(n<<1)) limit<<=1,cnt++;
    for(i=0;i<limit;i++) r[i]=((r[i>>1]>>1)|((i&1)<<(cnt-1)));
    
    fft(A,1);fft(B,1);fft(C,1);
    for(i=0;i<=limit;i++) A[i]=A[i]*C[i],B[i]=B[i]*C[i];
    fft(A,-1);fft(B,-1);
    for(i=0;i<=limit;i++) A[i].x/=limit,B[i].x/=limit;
    
    for(i=1;i<=n;i++) printf("%.4lf\n",-B[n+1-i].x+A[i].x);
}
```

---

## 作者：GoldenPotato137 (赞：5)

蒟蒻博客：[QwQ](https://www.cnblogs.com/GoldenPotato/p/10288217.html)

---
# Solution

~~写到脑壳疼，我好菜啊~~


我们来颓柿子吧

$F_j=\sum_{i<j}\frac{q_i*q_j}{(i-j)^2}-\sum_{i>j}\frac{q_i*q_j}{(i-j)^2}$

$q_j$与$i$没有半毛钱关系，提到外面去

$F_j=q_j*\sum_{i<j}\frac{q_i}{(i-j)^2}-q_j*\sum_{i>j}\frac{q_i}{(i-j)^2}$

左右同时除以$q_j$

$E_j=\sum_{i=1}^{j-1}\frac{q_i}{(i-j)^2}-\sum_{i=j+1}^{n}\frac{q_i}{(i-j)^2}$

我们设$f(i)=q(i),g(i)=\frac{1}{i^2}$，有

$E_j=\sum_{i=1}^{j-1}f(i)*g(i-j)-\sum_{i=j+1}^{n}f(i)*g(i-j)$

因为$g(i)$是个偶函数，因此有：

$E_j=\sum_{i=1}^{j-1}f(i)*g(j-i)-\sum_{i=j+1}^{n}f(i)*g(i-j)$

这时候，我们显然可以发现左边那个式子是个卷积，右边的这样一波化简就也变成了卷积形式：
![](https://cdn.luogu.com.cn/upload/pic/48846.png)

卷积用FFT快速计算即可

**时间复杂度$O(nlogn)$**

---
# Code
```cpp
//Luogu P3338 [ZJOI2014]力
//Jan,18th,2019
//FFT加速卷积
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<complex>
using namespace std;
typedef complex <double> cp;
const double PI=acos(-1);
const int M=100000+100;
const int N=8*M;
inline cp omega(int K,int n)
{
	return cp(cos(2*PI*K/n),sin(2*PI*K/n));
}
void FFT(cp a[],int n,bool type)
{
	static int len=0,num=n-1,t[N];
	while(num!=0) len++,num/=2;
	for(int i=0,j;i<=n;i++)
	{
		for(j=0,num=i;j<len;j++)
			t[j]=num%2,num/=2;
		reverse(t,t+len);
		for(j=0,num=0;j<len;j++)
			num+=t[j]*(1<<j);
		if(i<num) swap(a[i],a[num]);
	}
	for(int l=2;l<=n;l*=2)
	{
		int m=l/2;
		cp x0=omega(1,l);
		if(type==true) x0=conj(x0);
		for(int j=0;j<n;j+=l)
		{
			cp x=cp(1,0);
			for(int k=0;k<m;k++,x*=x0)
			{
				cp temp=x*a[j+k+m];
				a[j+k+m]=a[j+k]-temp;
				a[j+k]=a[j+k]+temp;
			}
		}
	}
}
int n,m;
double q[N];
cp f[N],g[N],f2[N];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%lf",&q[i]);
		
	for(int i=1;i<=n;i++)
		g[i]=(1.0/i/i);
	m=1;
	while(m<2*n) m*=2;
	for(int i=1;i<m;i++)
		f[i]=q[i],f2[i]=q[i];
	
	FFT(g,m,false);
	FFT(f,m,false);
	reverse(f2+1,f2+n+1);
	FFT(f2,m,false);
	for(int i=0;i<m;i++)
		f[i]*=g[i],f2[i]*=g[i];
	FFT(f,m,true);
	FFT(f2,m,true);
	
	for(int i=1;i<=n;i++)
		printf("%lf\n",(f[i].real()-f2[n-i+1].real())/m);
	return 0;
}

```

[1]:https://www.luogu.org/problemnew/show/P3338
[2]:https://www.lydsy.com/JudgeOnline/problem.php?id=3527






---

## 作者：MikukuOvO (赞：4)

学了$FFT$也快有两个月了，一直没有碰到可以用$FFT$优化的题目，今天终于碰到了，写篇题解来纪念下。

首先我们观察式子:

$E_j= \sum_{i=1}^{j-1} \frac{q_i}{(i-j)^2}-\sum_{i=j+1}^n \frac{q_i}{(i-j)^2}$

我们定义$f[i]=q[i]$（~~为了好看~~），$g[i]=\frac{1}{i^2}$，那么我们可以将原式写成：

$E_j= \sum_{i=1}^{j-1} f[i] \times g[j-i]-\sum_{i=j+1}^n f[i] \times g[i-j]$

考虑到$f[0]=0,g[0]=0$，那么这个式子与原式等价:

$E_j= \sum_{i=0}^{j} f[i] \times g[j-i]-\sum_{i=j}^n f[i] \times g[i-j]$

考虑将右边的式子变形：

$E_j= \sum_{i=0}^{j} f[i] \times g[j-i]-\sum_{i=0}^{n-j} f[i+j] \times g[i]$

考虑到左边的式子已经是卷积的形式，那么右边只是与之反向，考虑将$f$数组$reverse$。

$E_j= \sum_{i=0}^{j} f[i] \times g[j-i]-\sum_{i=0}^{n-j} rev[n-(i+j)] \times g[i]$

我们换元：$t=n-j$。


$E_j= \sum_{i=0}^{j} f[i] \times g[j-i]-\sum_{i=0}^{t} rev[t-i] \times g[i]$

至此，我们就将左右两边化成了卷积的形式，分别$fft$即可。


---

## 作者：Huami360 (赞：3)

这篇题解是写给~~像我这样~~刚学$FFT$就来写这题的人。

如果你~~像我一样~~看不懂题解，这篇可能会给你帮助。

首先一个数列作为多项式都表示的是系数，比如$a$数组表示的是
$$a_0+a_1x+a_2x^2+\cdots+a_nx^n$$
这样的多项式。

然后，为什么
$$\sum_{j=1}^{i-1}\frac{q_j}{(i-j)^2}$$
能用卷积表示呢？

因为卷积的第$i$项表示$x^i$项的系数，设$A\times B=C$，则有

$$c_i=\sum\limits_{j+k=i}a_j\times b_k$$

是不是和上面的式子很像呢？

所以令$A[i]=q[i],B[i]=\frac{1}{i^2}$，$A\times B$得到的$C[i]$就是$\sum_{j=1}^{i-1}\frac{q_j}{(i-j)^2}$

后面的就同理了。

---

## 作者：Quank123Wip (赞：2)

$$F_j=\sum_{i=1}^{j-1}\frac{q_i\times q_j}{(i-j)^2}-\sum_{i=j+1}^{n}\frac{q_i\times q_j}{(i-j)^2}$$

$$E_i=\frac{F_i}{q_i}$$

展开可得

$$E_i=\sum_{i=1}^{j-1}\frac{q_i}{(i-j)^2}-\sum_{i=j+1}^{n}\frac{q_i}{(i-j)^2}$$

不妨设

$$A(i)=\sum_{j=1}^{i}\frac{q_j}{(j-i)^2}$$

$$B(i)=\sum_{j=i+1}^{n}\frac{q_j}{(j-i)^2}$$

原式变为

$$E_i=A(i)-B(i)$$

若有

$$q'_i=q_{n-i+1}$$

(即反转序列)

则易知

$$B(i)=\sum_{j=1}^{n-i}\frac{q'_{j}}{(j-i)^2}$$

设

$$g(i)=\frac{1}{i^2}$$

则有

$$A(i)=\sum_{j=1}^{i}g(j-i)\times q_i$$

$$B(i)=\sum_{j=1}^{n-i}g(j-i)\times q'_i$$

故可以通过$\text{FFT}$来加速求出$A(x)$与$B(x)$的时间

$O(n)$预处理$g(x),q'$,$O(n\log n)$求出$A(x),B(x)$，$O(n)$得出$E_i(1\leq i\leq n)$，故渐进时间复杂度为$O(n\log n)$,对于$100000$的数据应该能过了

代码(代码已经经过clang-format格式化，若有阅读不适请见谅)
```cpp
#include <bits/stdc++.h>
//#include<bits/extc++.h>
using std::cerr;
using std::cin;
using std::cout;
using std::endl;
using std::swap;
const double Pi = acos(-1.0);
struct complex
{
    double x, y;
    complex(double a = 0, double b = 0)
    {
        x = a, y = b;
        return;
    }
} a[1000010], b[1000010];
complex operator+(complex a, complex b)
{
    return complex(a.x + b.x, a.y + b.y);
}
complex operator-(complex a, complex b)
{
    return complex(a.x - b.x, a.y - b.y);
}
complex operator*(complex a, complex b)
{
    return complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}
int n;
int l, r[10000010];
int Limit = 1;
void FFT(complex *A, int flag)
{
    for (int i = 0; i < Limit; i++)
        if (i < r[i])
            swap(A[i], A[r[i]]);
    for (int j = 1; j < Limit; j <<= 1)
    {
        complex Wn(cos(Pi / j), flag * sin(Pi / j));
        for (int k = 0; k < Limit; k += (j << 1))
        {
            complex W(1, 0);
            for (int q = 0; q < j; q++, W = W * Wn)
            {
                complex x = A[k + q], y = W * A[j + k + q];
                A[k + q] = x + y;
                A[j + k + q] = x - y;
            }
        }
    }
}
inline void init_fft()
{
    while (Limit <= (n << 1))
        Limit <<= 1, l++;
    for (int i = 0; i < Limit; i++)
        r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
}
inline void mul(double *a, double *b, double *result)
{
    static bool inited = false;
    if (!inited)
        init_fft(), inited = true;
    for (int i = 0; i < Limit; i++)
        ::a[i].x = a[i], ::b[i].x = b[i], ::a[i].y = ::b[i].y = 0;
    FFT(::a, 1);
    FFT(::b, 1);
    for (int i = 0; i < Limit; i++)
        ::a[i] = ::a[i] * ::b[i];
    FFT(::a, -1);
    for (int i = 0; i < Limit; i++)
        result[i] = ::a[i].x / Limit;
}
double q[100010 << 2], rev_q[100010 << 2], g[100010 << 2], A[100010 << 2], B[100010 << 2];
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%lf", q + i),
            g[i] = 1.0 / (double)i / (double)i;
    memcpy(rev_q, q, sizeof rev_q);
    std::reverse(rev_q + 1, rev_q + 1 + n);
    mul(g, q, A);
    mul(g, rev_q, B);
    for (int i = 1; i <= n; i++)
        printf("%.4lf\n", A[i] - B[n - i + 1]);
}
```

---

## 作者：hongzy (赞：2)

定义式：

$$E_j=\frac{F_j}{q_j}$$

$$E_j=\frac{\sum_{i<j} \frac{q_iq_j}{(i-j)^2} -\sum_{i>j} \frac{q_iq_j}{(i-j)^2}}{q_j}$$

每项都有$q_j$，直接除掉

$$E_j=\sum_{i<j} \frac{q_i}{(i-j)^2} -\sum_{i>j} \frac{q_i}{(i-j)^2}$$

令$f(i)=q_i$，$g(i)=\frac{1}{i^2}$

$$E_j=\sum_{i<j} f(i)g(j-i) -\sum_{i>j} f(i)g(i-j)$$

把$f$反向得到$f'$，则：

$$E_j=\sum_{i<j} f(i)g(j-i) -\sum_{i<j} f'(i)g(j-i)$$

这是卷积的形式，可以使用$FFT$，丢上板子.

```cpp
#include <algorithm>
#include <complex>
#include <cstdio>
using namespace std;

typedef complex<double> comp_t;

const int N = (1 << 19) + 10;
const double PI = acos(-1);

int n, lim, l, r[N];
double f[N], g[N], a[N], b[N];

void fft(comp_t * a, int type) {
	for(int i = 0; i < lim; i ++)
		if(i < r[i]) swap(a[i], a[r[i]]);
	for(int i = 1; i < lim; i <<= 1) {
		comp_t x(cos(PI / i), type * sin(PI / i));
		for(int j = 0; j < lim; j += (i << 1)) {
			comp_t y(1, 0);
			for(int k = 0; k < i; k ++, y *= x) {
				comp_t p = a[j + k], q = y * a[j + k + i];
				a[j + k] = p + q, a[j + k + i] = p - q;
			}
		}
	}
}

comp_t tmpa[N], tmpb[N];

void transform(double * a, double * b, double * ans) {
	for(int i = 0; i < lim; i ++)	
		tmpa[i] = a[i], tmpb[i] = b[i];
	fft(tmpa, 1), fft(tmpb, 1);
	for(int i = 0; i < lim; i ++) tmpa[i] *= tmpb[i];
	fft(tmpa, -1);
	for(int i = 1; i <= n; i ++) 
		ans[i] = tmpa[i].real() / lim;
}

int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; i ++) {
		scanf("%lf", &f[i]);
		g[i] = 1.0 / i / i;
	}
	for(lim = 1; lim <= (n << 1); lim <<= 1) ++ l;
	
	for(int i = 0; i < lim; i ++)
		r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
	
	transform(f, g, a);
	reverse(f + 1, f + n + 1); //翻转 
	transform(f, g, b);
	
	for(int i = 1; i <= n; i ++)
		printf("%.3f\n", a[i] - b[n - i + 1]);
	return 0;
}
```

---

## 作者：mulberror (赞：1)

# 题目链接
[【BZOJ】](https://www.lydsy.com/JudgeOnline/problem.php?id=3527)  
[【洛谷】](https://luogu.org/problemnew/show/P3338)  
[【我的博客】](https://www.cnblogs.com/chhokmah/p/10785747.html)
# 题解
首先我们需要对这个式子进行化简，否则对着这么大一坨东西只能暴力。。。  

-----
$$F_i=\sum_{j<i} \frac{q_iq_j}{(i-j)^2}-\sum_{j>i} \frac{q_iq_j}{(i-j)^2}$$  
根据题目给出的定义，带入$E$中  
$$E_i=\sum_{j=1}^{i-1}\frac{q_j}{(i-j)^2}-\sum_{j=i+1}^{n}\frac{q_j}{(j-i)^2}$$ 
形式稍微改变了一下，本质一样  
需要处理这个分母上的两个不好看的小东西  
设$f_i=\frac{1}{i^2}$  
那么可以得到原式变成
$$E_i=\sum^{i-1}_{j=1}q_jf_{i-j}-\sum^n_{j=i+1}q_jf_{j-i}$$    
将这个式子拆成两部分    
先讨论$-$号前面一部分   
可以发现，减号前一部分就是一个卷积的形式，那么直接`FFT`套上去就可以了。[【FFT学习笔记（万字大篇）】](https://www.cnblogs.com/chhokmah/p/10658101.html)    
对于后一部分，认真观察可以发现  
形式和前一部分非常相似，其实就是相反了一下。  
我们将原来的数组倒序存储一下，和前一部分做一样的`FFT`就可以了。

# 代码
```cpp
#include <bits/stdc++.h>
#define ms(a, b) memset(a, b, sizeof(a))
#define ll long long
#define ull unsigned long long
#define ms(a, b) memset(a, b, sizeof(a))
#define inf 0x3f3f3f3f
#define db double
#define Pi acos(-1)
#define eps 1e-8
#define N 400005
using namespace std;
template <typename T> T sqr(T x) { return x * x; }
template <typename T> void read(T &x) {
    x = 0; T fl = 1; char ch = 0;
    for (; ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') fl = -1;
    for (; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
    x *= fl;
}
template <typename T> T power(T x, T y, T mod) { T res = 1;  for (; y; y >>= 1) { if (y & 1) res = (res * x) % mod; x = (x * x) % mod; } return res; }
template <typename T> void write(T x) { if (x < 0) x = -x, putchar('-'); if (x > 9) write(x / 10); putchar(x % 10 + '0'); }
template <typename T> void writeln(T x) { write(x); puts(""); }
struct Complex {
    db x, y;
    Complex (db xx = 0, db yy = 0) { x = xx; y = yy; }
    Complex operator + (Complex B) { return Complex(x + B.x, y + B.y); }
    Complex operator - (Complex B) { return Complex(x - B.x, y - B.y); }
    Complex operator * (Complex B) { return Complex(x * B.x - y * B.y, x * B.y + y * B.x); }
}a[N], b[N], c[N], d[N];
int r[N];
int n, m, limit, l;
void FFT(Complex *a, int type) {
    for (int i = 0; i < limit; i ++) if (i < r[i]) swap(a[i], a[r[i]]);
    for (int mid = 1; mid < limit; mid <<= 1) {
        Complex wn(cos(Pi / mid), type * sin(Pi / mid));
        for (int R = mid << 1, j = 0; j < limit; j += R) {
            Complex w(1, 0);
            for (int k = 0; k < mid; k ++, w = w * wn) {
                Complex x = a[j + k], y = w * a[j + mid + k];
                a[j + k] = x + y; a[j + mid + k] = x - y;
            }
        } 
    }
    if (type == -1) for (int i = 0; i < limit; i ++) a[i].x /= 1.0 * limit;
}
int main() {
    read(n);
    for (int i = 1; i <= n; i ++) {
        db x; scanf("%lf", &x);
        a[i].x = c[n - i + 1].x = x; b[i].x = d[i].x = 1.0 / sqr(i * 1.0);
    }
    limit = 1; while (limit <= (n << 1)) limit <<= 1, l ++;
    for (int i = 0; i < limit; i ++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
    FFT(a, 1); FFT(b, 1);
    for (int i = 0; i < limit; i ++) a[i] = a[i] * b[i];
    FFT(a, -1);
    FFT(c, 1); FFT(d, 1);
    for (int i = 0; i < limit; i ++) c[i] = c[i] * d[i];
    FFT(c, -1);
    for (int i = 1; i <= n; i ++) printf("%.3lf\n", a[i].x - c[n - i + 1].x);
    return 0;
}

```

---

## 作者：kczno1 (赞：1)

f1=0\*q1+(-1/1^2)\*q2+(-1/2^2)\*q3..(-1/(n-1)^2)\*qn

f2=(1/1^2)\*q1+0\*q2+(-1/1^2)\*q3..

对于系数1/(n-1)^2..1/2^2,1/1^2,0,-1/1^2,-1/2^2..-1/(n-1)^2

发现fi就是fi-1往左移了一位

再翻转一下，就可以用fft了

```cpp
#include<bits/stdc++.h>

const int N=1<<19;
int n,i;
struct fushu
{
    double x,y;
    friend fushu operator +(const fushu &p1,const fushu &p2)
    {
        return (fushu){p1.x+p2.x,p1.y+p2.y};
    }
    friend fushu operator -(const fushu &p1,const fushu &p2)
    {
        return (fushu){p1.x-p2.x,p1.y-p2.y};
    }
    friend fushu operator *(const fushu &p1,const fushu &p2)
    {
        return (fushu){p1.x*p2.x-p1.y*p2.y,p1.x*p2.y+p1.y*p2.x};
    }
}a[N],b[N],*ans=a,wn[N],temp[N];

double sqr(const double &x)
{
    return x*x;
}

const double pi=acos(-1),WN=2*pi/N;
void init_wn()
{
    for(i=0;i<N;++i) wn[i]=(fushu){cos(WN*i),sin(WN*i)};
}
void rev_wn()
{
    for (i=0;i<N;++i) wn[i].y=-wn[i].y;
}

void fft(int n=N,int s=0,int len=1)
{
    if(n==1)return ;
    int m=n>>1;
    fft(m,s,len<<1);fft(m,s+len,len<<1);
    
    int p=s;
    for(i=0;i<m;++i,p+=len<<1)
    {
        fushu del=ans[p+len]*wn[i*len];
        temp[i]=ans[p]+del;
        temp[i+m]=ans[p]-del;
    }
    
    for(i=0;i<n;++i) ans[s+i*len]=temp[i];
}

int main()
{
    freopen("1.in","r",stdin);
    scanf("%d",&n);--n;
    for(i=0;i<=n;++i) scanf("%lf",&a[i].x);
    for(i=0;i<n;++i) b[i].x=-1/sqr(n-i);
    for(i=n+1;i<=n<<1;++i) b[i].x=1/sqr(i-n);
    
    init_wn();
    ans=a;fft();
    ans=b;fft();
    for(i=0;i<N;++i) a[i]=a[i]*b[i];
    rev_wn();
    ans=a;fft();
    for(i=n;i<=n<<1;++i) printf("%.3lf\n",ans[i].x/N);
}
```

---

## 作者：magolor (赞：1)

强烈吐槽时间：时限是3s!3s!3s! @kkksc03

FFT,这里有简化版的vector和complex库，如果对时间要求不高可以使用。





```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <complex>
#include <cmath>
#include <vector> 
using namespace std;
const int MAXN = (1<<19);
const double PI = acos(-1.);
typedef std::complex<double> Complex;
typedef vector<double> Polynomial;
inline void FFT(Complex P[], int n, int tag)
{
    Complex root,per,t;
    for(register int i = 1, j = 0, s; i < n-1; (i<j ? swap(P[i],P[j]) : void(0)), i++)
        for(s = n; j^=s>>=1, ~j&s; );
    for(register int d = 0, m, i, j; (1<<d) < n; d++)
        for(m = (1<<d), per = Complex(cos(PI/m*tag),sin(PI/m*tag)), i = 0; i < n; i += (m<<1))
            for(root = Complex(1,0), j = 0; j < m; j++)
                t = root*P[i+j+m], P[i+j+m] = P[i+j]-t, P[i+j] += t, root *= per;
    return;
}
Complex A[MAXN+5], B[MAXN+5];
Polynomial operator *(const Polynomial &Ax, const Polynomial &Bx)
{
    int n, p = Ax.size(), q = Bx.size();
    for(n = 1; n <= p+q-2; n <<= 1);
    for(register int i = 0; i < n; i++)
        A[i] = (i<p ? Ax[i] : 0), B[i] = (i<q ? Bx[i] : 0);
    FFT(A,n,1), FFT(B,n,1);
    for(register int i = 0; i < n; A[i] *= B[i], i++);
    FFT(A,n,-1);
    Polynomial Cx(p+q-1);
    for(register int i = 0, m = Cx.size(); i < m; i++)
        Cx[i] = A[i].real()/n; 
    return Cx;
}
int n, m;
double x[MAXN+5];
Polynomial Ax,Bx,Cx;
int main()
{
    scanf("%d",&n), m = (n<<1)-1;
    Ax.resize(n), Bx.resize(m);
    for(register int i = 0; i < n; i++)
        scanf("%lf",x+i);
    for(register int i = 0; i < n; i++)
        Ax[i] = x[i];
    for(register int i = 0; i < n-1; i++)
        Bx[i] = -1./(n-1-i)/(n-1-i);
    for(register int i = n; i < m; i++)
        Bx[i] =  1./(i-n+1)/(i-n+1);
    Cx = Ax*Bx;
    for(register int i = n-1; i < m; i++)
        printf("%0.7lf\n",Cx[i]); 
     return 0;
}

```

---

## 作者：crashed (赞：0)

# 题目  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P3338)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$F$的形式看着有些复杂；既然题目要求我们求出$E$，我们就直接看一看$E$长什么亚子：  
$$E_i=\sum_{j<i}\frac{q_j}{(i-j)^2}-\sum_{j>i}\frac{q_j}{(i-j)^2}$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑前半部分：  
$$E_i'=\sum_{j<i}q_j\frac1{(i-j)^2}$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想办法配出两个函数来。令$f(i)=q_i$，$g(i)=\frac1{i^2}$，则有：  
$$E_i'=\sum_{j=1}^{i-1}f(j)g(i-j)$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就可以发现$E'$是一个卷积的形式，可以使用$FFT$。对于后面那一半，将$q$倒过来之后再做一遍，减掉就可以了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总时间就是$O(n\log_2n)$。  
# 代码
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>

#define double long double

const double eps = 1e-6, PI = acos( -1 );
const int MAXN = 2e5 + 5;

template<typename _T>
void read( _T &x )
{
    x = 0;char s = getchar();int f = 1;
    while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
    while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
    x *= f;
}

template<typename _T>
void write( _T x )
{
    if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
    if( 9 < x ){ write( x / 10 ); }
    putchar( x % 10 + '0' );
}

template<typename _T>
void swapp( _T &x, _T &y )
{
	_T t( x ); x = y, y = t;
}

template<typename _T>
_T sqr( _T x )
{
	return x * x;
}

typedef struct complex
{
	double r, i;
	complex(){} complex( const double R, const double I = 0 ) { r = R, i = I; }
	complex operator + ( const complex & b ) const { return complex( r + b.r, i + b.i ); }
	complex operator - ( const complex & b ) const { return complex( r - b.r, i - b.i ); }
	complex operator * ( const complex & b ) const { return complex( r * b.r - i * b.i, r * b.i + i * b.r ); }
	complex operator / ( const double & b ) const { return complex( r / b, i / b ); }
	void operator += ( const complex & b ) { *this = *this + b; }
	void operator -= ( const complex & b ) { *this = *this - b; }
	void operator *= ( const complex & b ) { *this = *this * b; }
	void operator /= ( const double & b ) { *this = *this / b; }
}comp;

comp A[MAXN << 2], B[MAXN << 2], C[MAXN << 2];
double q[MAXN], res[MAXN];
int N, len;

void init( const bool type ) 
{ 
	for( int i = 0 ; i <= len ; i ++ ) A[i] = B[i] = 0;
	for( int i = 1 ; i <= N ; i ++ ) B[i] = 1.0 / i / i, A[i] = q[type ? i : N - i + 1];
}

void FFT( comp *coe, const int len, const int type )
{
	int lg2 = log2( len );
	for( int i = 0, rev ; i < len ; i ++ )
	{
		rev = 0;
		for( int j = 0 ; j < lg2 ; j ++ ) rev |= ( ( i >> j ) & 1 ) << ( lg2 - j - 1 );
		if( rev < i ) swapp( coe[rev], coe[i] );
	}
	comp wp, w, we, wo;
	for( int s = 2, p ; s <= len ; s <<= 1 )
	{
		p = s >> 1, wp = comp( cos( type * PI / p ), sin( type * PI / p ) );
		for( int i = 0 ; i < len ; i += s )
		{
			w = comp( 1, 0 );
			for( int j = 0 ; j < p ; j ++, w *= wp )
			{
				we = coe[i + j], wo = coe[i + j + p];
				coe[i + j] = we + wo * w, coe[i + j + p] = we - wo * w;
			}
		}
	}
	if( ~ type ) return ;
	for( int i = 0 ; i <= len ; i ++ ) coe[i] /= len;
}

void times( comp *ret, const int la, const int lb )
{
	for( int i = 0 ; i <= len ; i ++ ) ret[i] = 0;
	FFT( A, len, 1 ), FFT( B, len, 1 );
	for( int i = 0 ; i <= len ; i ++ ) ret[i] = A[i] * B[i];
	FFT( ret, len, -1 );
}

int main()
{
	read( N );	
	len = 1 << int( ceil( log2( N << 1 ) ) );
	if( len == N << 1 ) len <<= 1;
	for( int i = 1 ; i <= N ; i ++ ) scanf( "%Lf", &q[i] );
	init( true );
	times( C, N, N );
	for( int i = 1 ; i <= N ; i ++ ) res[i] += C[i].r;
	init( false ); 
	times( C, N, N );
	for( int i = 1 ; i <= N ; i ++ ) printf( "%.3Lf", ( res[i] - C[N - i + 1].r + eps ) ), putchar( '\n' );
	return 0;
}
```

---

## 作者：FlyInTheSky (赞：0)

 [$$ \Large \texttt{My Blog} $$](http://blog.flyinthesky.win/bzoj3675/)

------------

设$f(i)=q_i, g(i)=\frac 1{i^2}$

则
$$E_j=\sum\limits_{i=1}^{j-1} f(i)g(i-j) - \sum\limits_{i=j+1}^{n} f(i)g(i-j)$$

因为$g(i)$为偶函数，则
$$E_j=\sum\limits_{i=1}^{j-1} f(i)g(j-i) - \sum\limits_{i=j+1}^{n} f(i)g(i-j)$$

那么前面是一个卷积形式，后面可以翻转$f(i)$后变为另一个卷积形式，FFT 计算即可。

```c++
#include<cstdio> 
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<map>
#include<vector>
#define ms(i, j) memset(i, j, sizeof i)
#define LL long long
#define db double
#define fir first
#define sec second
#define mp make_pair
using namespace std;

namespace flyinthesky {

	const int MAXN = 300000 + 5;
	const db PI = acos(-1);

	struct C {
		db r, i;
		C() {r = i = 0;}
		C(db x, db y) {r = x, i = y;}
		C operator + (C &x) {return C(r + x.r, i + x.i);}
		C operator - (C &x) {return C(r - x.r, i - x.i);}
		C operator * (C &x) {return C(r * x.r - i * x.i, x.i * r + x.r * i);}
		void operator += (C &x) {r += x.r, i += x.i;}
		void operator *= (C &x) {
			db tr = r, ti = i;
			r = tr * x.r - ti * x.i;
			i = x.i * tr + x.r * ti;
		}
	} f[MAXN], g[MAXN];
	
	int m, n, r[MAXN];
	db p[MAXN], q[MAXN], a[MAXN], b[MAXN], gg[MAXN];

	void FFT(C *a, int op) {
		for (int i = 0; i < n; ++i)
			if (i < r[i]) swap(a[i], a[r[i]]);
		for (int i = 1; i < n; i <<= 1) {
			C Wn = C(cos(PI / i), sin(PI / i) * op);
			for (int j = 0; j < n; j += (i << 1)) {
				C w = C(1, 0), *a0 = a + j, *a1 = a0 + i;
				for (int k = 0; k < i; ++k) {
					C t = *a1 * w;
					*a1 = *a0 - t, *a0 += t;
					++a0, ++a1, w *= Wn;
				}
			}
		}
	}
	void pro(db *tf, db *tg, db *ret) {
		for (int i = 0; i < n; ++i) 
			f[i].r = tf[i], g[i].r = tg[i], f[i].i = 0, g[i].i = 0;
		FFT(f, 1), FFT(g, 1);
		for (int i = 0; i < n; ++i) f[i] *= g[i];
		FFT(f, -1);
		for (int i = 0; i <= m; ++i) ret[i] = (fabs(f[i].r) / n);
	}

    void clean() {
    	ms(r, 0);
	}
    int solve() {

    	clean();
    	scanf("%d", &n);
    	for (int i = 1; i <= n; ++i) {
    		scanf("%lf", &p[i]);
    		q[i] = p[i], gg[i] = 1.0 / i / i;
		}
		
		reverse(q + 1, q + 1 + n);
		
		int l = 0;
		for (m = n, n = 1; n <= m + m; n <<= 1, ++l);
		
		for (int i = 0; i < n; ++i) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
		
		pro(p, gg, a);
		pro(q, gg, b);
		
		for (int i = 1; i <= m; ++i) printf("%.5f\n", a[i] - b[m - i + 1]);

        return 0;
    }
}
int main() {
    flyinthesky::solve();
    return 0;
}
```

---

## 作者：zyh2015 (赞：0)

来自我的博客：http://blog.csdn.net/YihAN\_Z/article/details/54342753

给出n个数qi，求![这里写图片描述](http://img.blog.csdn.net/20170111133834655?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWWloQU5fWg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


n<=100000

暴力需要O(n2)的时间，想到用FFT加速（有规律的）乘法[^1]。

构造两个多项式

![这里写图片描述](http://img.blog.csdn.net/20170111135239893?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWWloQU5fWg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

![这里写图片描述](http://img.blog.csdn.net/20170111135642006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWWloQU5fWg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

将两个多项式相乘，其中第n项到第2n-1项即为答案


```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
#define N 600000
using namespace std;
const double pi=acos(-1),DFT=2.0,IDFT=-2.0;
struct Complex {
    double x,y;
    Complex(const double& a=0.0,const double& b=0.0) : x(a),y(b) {}
    Complex operator + (const Complex& rhs) const {return Complex(x+rhs.x,y+rhs.y); }
    Complex operator - (const Complex& rhs) const {return Complex(x-rhs.x,y-rhs.y); }
    Complex operator * (const Complex& rhs) const {return Complex(x*rhs.x-y*rhs.y,x*rhs.y+y*rhs.x); }
}a[N],b[N],c[N];
int n,len,pos[N];
void init() {
    len=1;
    while(len<n*2) len*=2;
    for(int i=1;i<len;i++) {
        pos[i]=pos[i/2]/2;
        if(i&1) pos[i]|=len/2;
    }
    return ;
}
void FFT(Complex x[],double mode) {
    for(int i=0;i<len;i++)
        if(i<pos[i])
            swap(x[i],x[pos[i]]);
    for(int i=2;i<=len;i*=2) {
        int step=i/2;
        Complex wm(cos(2*pi/i),sin(mode*pi/i));
        for(int j=0;j<len;j+=i) {
            int limit=j+step;
            Complex w(1,0);
            for(int k=j;k<limit;k++) {
                Complex l=x[k],r=w*x[k+step];
                x[k]=l+r; x[k+step]=l-r;
                w=w*wm;
            }
        }
    }
    if(mode==IDFT)
        for(int i=0;i<len;i++)
            x[i].x/=len;
    return ;
}
int main() {
    scanf("%d",&n);
    init();
    for(int i=0;i<n;i++) scanf("%lf",&a[i].x);
    for(int i=0;i<n-1;i++) b[i].x=-1.0/(n-i-1)/(n-i-1);
    for(int i=n;i<n*2-1;i++) b[i].x=1.0/(i-n+1)/(i-n+1);
    FFT(a,DFT); FFT(b,DFT);
    for(int i=0;i<len;i++) c[i]=a[i]*b[i];
    FFT(c,IDFT);
    for(int i=n-1;i<n*2-1;i++) printf("%f\n",c[i].x);
    return 0;
}
```

[^1]:除法与乘法本质上相同。


---


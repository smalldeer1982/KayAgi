# [AHOI2017/HNOI2017] 礼物

## 题目描述

我的室友最近喜欢上了一个可爱的小女生。马上就要到她的生日了，他决定买一对情侣手环，一个留给自己，一个送给她。每个手环上各有 $n$ 个装饰物，并且每个装饰物都有一定的亮度。

但是在她生日的前一天，我的室友突然发现他好像拿错了一个手环，而且已经没时间去更换它了！他只能使用一种特殊的方法，将其中一个手环中所有装饰物的亮度增加一个相同的非负整数 $c$。并且由于这个手环是一个圆，可以以任意的角度旋转它，但是由于上面装饰物的方向是固定的，所以手环不能翻转。需要在经过亮度改造和旋转之后，使得两个手环的差异值最小。

在将两个手环旋转且装饰物对齐了之后，从对齐的某个位置开始逆时针方向对装饰物编号 $1 \sim n$，其中 $n$ 为每个手环的装饰物个数， 第 $1$ 个手环的 $i$ 号位置装饰物亮度为 $x_i$，第 $2$ 个手环的 $i$ 号位置装饰物亮度为 $y_i$，两个手环之间的差异值为（参见输入输出样例和样例解释）：

$$\sum_{i=1}^{n} (x_i-y_i)^2$$

麻烦你帮他计算一下，进行调整（亮度改造和旋转），使得两个手环之间的差异值最小，这个最小值是多少呢？

## 说明/提示

【样例解释】

需要将第一个手环的亮度增加 $1$，第一个手环的亮度变为：$2,3,4,5,6$

旋转一下第二个手环。对于该样例，是将第二个手环的亮度 $6,3,3,4,5$ 向左循环移动一个位置，使得第二手环的最终的亮度为：$3,3,4,5,6$。

此时两个手环的亮度差异值为 $1$。

【数据范围】

对于 $30\%$ 的数据，$n \le 500$，$m \le 10$；

对于 $70\%$ 的数据，$n \le 5000$；

对于 $100\%$ 的数据，$1 \le n \le 50000$, $1 \le x_i,y_i \le m \le 100$。

## 样例 #1

### 输入

```
5 6
1 2 3 4 5
6 3 3 4 5```

### 输出

```
1```

# 题解

## 作者：Orion545 (赞：40)

# 广告

### [蒟蒻のblog](http://www.cnblogs.com/dedicatus545/p/8831000.html)

# 正文

首先，有一个结论：两个手环增加非负整数亮度，等于其中一个增加一个整数亮度（可以为负）

我们令增加量为$x$，旋转以后的原数列为$\{a\}\{b\}$那么现在的费用就是：

### $\sum_{i=1}^n\left(a_i+x-b_i\right)^2$

我们把第i项拿出来拆开，得到：

### $\left(a_i+x-b_i\right)^2=a_i^2+b_i^2+x^2+2a_ix-2a_ib_i-2b_ix$

那么原式变成了

### $\sum_{i=1}^na_i^2+\sum_{i=1}^nb_i^2+nx^2+2x\left(\sum_{i=1}^na_i-\sum_{i=1}^nb_i\right)-2\sum_{i=1}^na_ib_i$

我们发现，这个式子除了最后一项之外都是确定的QwQ

那么我们只要令最后一项最大，那么就可以得到最小的费用值了

### 现在问题转化为求$\sum_{i=1}^na_ib_i$的最大值

等等，这个形式......

我们把数列$\{a\}$反过来，变成

### $\sum_{i=1}^na_{n-i+1}b_i$

这不是一个卷积吗~

所以把反过来的数列$\{a\}$倍长，和数列$\{b\}$卷积，得到的项里面的第n+1到n\*2项的最大值，就是$\sum_{i=1}^na_ib_i$的最大值

然后把前面的不变项加上，就是答案了

Code：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define ll long long
#define inf 1e15
using namespace std;
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
struct complex{
    double x,y;
    complex(double xx=0,double yy=0){x=xx;y=yy;}
    complex operator +(const complex &b){return complex(x+b.x,y+b.y);}
    complex operator -(const complex &b){return complex(x-b.x,y-b.y);}
    complex operator *(const complex &b){return complex(x*b.x-y*b.y,x*b.y+y*b.x);}
}A[400010],B[400010];
const double pi=acos(-1.0);
int n,m,limit=1,cnt=0,r[400010];
void fft(complex *a,double type){
    int i,j,mid,k;complex x,y,w,wn;
    for(i=0;i<limit;i++) if(i<r[i]) swap(a[i],a[r[i]]);
    for(mid=1;mid<limit;mid<<=1){
        wn=complex(cos(pi/mid),type*sin(pi/mid));
        for(j=0;j<limit;j+=(mid<<1)){
            w=complex(1,0);
            for(k=0;k<mid;k++,w=w*wn){
                x=a[j+k];y=w*a[j+k+mid];
                a[j+k]=x+y;a[j+k+mid]=x-y;
            }
        }
    }
}
ll a1=0,a2=0,b1=0,b2=0,ans=inf;
int a[100010],b[100010];
int main(){
    ll i,j;
    n=read();m=read();
    for(i=1;i<=n;i++){
        a[i]=read();
        a1+=a[i]*a[i];a2+=a[i];
    }
    for(i=1;i<=n;i++){
        b[i]=read();
        b1+=b[i]*b[i];b2+=b[i];
    }
    for(i=1;i<=n;i++){
        A[i].x=A[i+n].x=a[i];
        B[i].x=b[n-i+1];
    }
    
    while(limit<=(n*3)) limit<<=1,cnt++;
    for(i=0;i<limit;i++) r[i]=((r[i>>1]>>1)|((i&1)<<(cnt-1)));
    
    fft(A,1);fft(B,1);
    for(i=0;i<=limit;i++) A[i]=A[i]*B[i];
    fft(A,-1);
    for(i=0;i<=limit;i++) A[i].x=(ll)(A[i].x/limit+0.5);
    
    for(i=1;i<=n;i++){
        for(j=-m;j<=m;j++){
            ans=min(ans,a1+b1+j*j*n+2ll*j*(a2-b2)-2ll*(ll)A[i+n].x);
        }
    }
    printf("%lld",ans);
}
```

---

## 作者：hongzy (赞：22)

$\text{FFT}$经典题

**题意**

给定数列$a,b$，$b$可以循环移动，选择整数$c$，求$\sum_{i=1}^n(a_i-b_i+c)^2$最小值

**题解**

化简式子：

$$\sum_{i=1}^n(a_i-b_i+c)^2$$

$$=\sum_{i=1}^n(a_i-b_i)^2+c^2+2c(a_i-b_i)$$

$$=\sum_{i=1}^n a_i^2+b_i^2-2a_ib_i+c^2+2a_ic-2b_ic$$

$$=\sum_{i=1}^na_i^2+\sum_{i=1}^nb_i^2-2\sum_{i=1}^na_ib_i+nc^2+2c\sum_{i=1}^n(a_i-b_i)$$

前面两项是定值，后面两项是关于$c$的二次函数，求对称轴，找到对称轴最近的两个整数坐标比较一下。于是任务变为最大化$\sum_{i=1}^na_ib_i$。

这玩意先破环为链，即$b_{i+n}=b_i$，就不用管环了

考虑把移动$k$位时候的答案：$\sum_{i=1}^n a_ib_{i+k}$

这种形式非常卷积，因为翻转$a$数组后：$\sum_{i=1}^n a_{n-i+1}b_{i+k}$

就可以$\text{FFT}$卷积了，然后卷积完了扫一遍求个$\max	$

```cpp
#include <algorithm>
#include <complex>
#include <cstdio>
#include <cmath>
using namespace std;

typedef long long ll;
typedef complex<double> cex;

const int N = 1e6 + 10;
const double PI = acos(-1);

int n, m, a[N], b[N];
ll ans, t, res[N], mx;

int r[N];
void fft(cex *c, int lim, int type)  {
	for(int i = 1; i < lim; i ++)
		if(i < r[i]) swap(c[i], c[r[i]]);
	for(int n = 1; n < lim; n <<= 1) {
		cex x(cos(PI / n), type * sin(PI / n));
		for(int i = 0; i < lim; i += (n << 1)) {
			cex y(1, 0);
			for(int k = 0; k < n; k ++, y *= x) {
				cex p = c[i + k], q = y * c[i + k + n];
				c[i + k] = p + q; c[i + k + n] = p - q;
			}
		}
	}
}

void _transform(int *a, int *b, int n, int m, ll *ans) {
	static cex f[N], g[N];
	int lim = 1, l = 0;
	for(int i = 1; i <= n; i ++) f[i].real(a[i]);
	for(int i = 1; i <= m; i ++) g[i].real(b[i]);
	for(n += m; lim <= n + m; lim <<= 1) l ++;
	for(int i = 1; i < lim; i ++)
		r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
	fft(f, lim, 1), fft(g, lim, 1);
	for(int i = 0; i < lim; i ++) f[i] *= g[i];
	fft(f, lim, -1);
	for(int i = 1; i <= n; i ++)
		ans[i] = (ll)(0.5 + f[i].real() / lim);
}

int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i ++) scanf("%d", &a[i]);
	for(int i = 1; i <= n; i ++) scanf("%d", &b[i]);
	for(int i = 1; i <= n; i ++) {
		ans += a[i] * a[i] + b[i] * b[i]; t += b[i] - a[i];
	}
	int c1 = floor(t * 1.0 / n), c2 = ceil(t * 1.0 / n);
	ans += min(n * c1 * c1 - 2 * c1 * t, n * c2 * c2 - 2 * c2 * t);
	
	for(int i = 1; i <= n; i ++) b[i + n] = b[i];
	reverse(a + 1, a + n + 1);
	_transform(a, b, n, n << 1, res);
	ll tmp = 0;
	for(int i = 0; i <= n; i ++)
		tmp = max(tmp, res[i + n + 1]);
	ans -= (tmp << 1);
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：shadowice1984 (赞：15)

容我说一句，这道题FFT的精度损失实在是太大了QAQ
eps开到1e-2，不然大数据会损失很多精度
##  教你背FFT板子
fft的话，第一就是oi完全不需要理解它的原理，只需要知道它能干什么以及怎么写，第二就是代码不存在各种被魔改的可能，所以我们可以考虑只记结论，然后忽略证明（啦啦啦~）

首先我们要知道FFT是干什么用的/快速多项式乘法/当然也可以快速高精乘

下面是预备芝士~

#### 多项式的表示
 _(注:以下全部为了方便理解，部分表述不是很严谨，请见谅)_ 
 
 首先我们知道对于一个最高次系数为n的多项式，有一个显而易见的表示方法就是
 从常数项写起，把每一项的系数都写出来，如果不存在就填0，这个看起来显而易见的方法就是多项式的**系数表示**，(当然也可以看成一个n+1维向量)
 
 但是呢，初中老师会告诉你，待定系数法是可以解出一个多项式所有系数的，并且，我们知道，n个未知数至少需要n个方程才能解出来，因此，我们发现如果把这个多项式代n个值进去，得到n个数对(n,f(n))，我们是可以通过待定系数法还原这个多项式的，这一堆数对被称为多项式的**点值表示**(ps,一般来讲，如果我们代的是同一套数的话，可以用一个一维数组表示点值，即只存函数值)
 
####  求值与插值
从多项式的系数表示向点值表示的转化，叫做**求值**，而从多项式的点值表示向系数表示的转化，叫做**插值**

首先我们求值我们还是会的，直接代入，算法复杂度O(n^3)

插值我们也会，待定系数法，高斯削元，算法复杂度O(n^3)

于是我们有了一个复杂度爆炸的算法

然后你仔细翻高中数学课本，你会发现有个算法叫**秦九韶算法**(国外的话叫霍纳法则)，可以O(n)求多项式的值，好了O(n^2)求值

之后我们发现啊，待定系数法的方程组，非常的有规律，所以国外有个叫拉格朗日的兄弟帮你解好了，名字叫**拉格朗日插值公式**，通过它我们可以O(n^2)插值

 _(这里我就不写了，你也不会需要它的，毕竟O(n^2)的公式没啥好看的)_ 
 
 好了但问题是，既然两种形态切换这么费劲，为什么我们要引入点值表达呢？
 
 #### 点值表达的优越性
 
 看似费劲的点值表达，有一个能够完爆系数表达的优点
 
 大家都知道，初中和高中老师教给我们的多项式乘法，是O(n^2)的，但是这并不意味这多项式的乘法真的就这么慢，只是因为系数表达的局限性，导致算法复杂度奇高
 
 如果是两个以点值形式表达的多项式呢？，那么乘积的函数值等于函数值的乘积，直接对应相乘即可，O(n)的复杂度不知到快到到哪里去了
 
 只是有一个问题，一般来讲，我们的实际应用中多半用不到点值表达，有意义的，是笨拙的系数表达。
 
 但是我们在切换形态时的算法，是O(n^2)的，所以我们无法在这两种形式之间谈笑风生，这就是我们需要fft的原因了
 
 #### fft到底是干什么的
 一句话，快速求值，插值，算法复杂度nlogn
 
#### fft的原理
我们发现点值表达是灵活的，只要你开心，代什么数都行

然后有人证明了，只要有这样一类数，他们连续乘一圈，能够乘回来，那么我们就可以快速求出多项式的值了，(乘一圈的说法可以暂时不用理解)

抱歉，这样的数在实数范围内不存在的

但是复数范围内有，它们被称为**n次单位复数根**，即方程w^n=1的解

(这里先介绍一下复数运算，一个复数可以看成是一个二维平面中的线段，复数的乘法规则是“幅角相加，模长相乘”)

其实我们就会发现，就是一个线段，它转n下，可以转回1，并且转一圈，再转一格，会产生一个新的线段，转n下，可以转回1，并且转两圈，最后一个转n-1圈可以转会1，但是也是转n下，最后一个解是1，它转n下，转n圈，可以回到1

注意，这其中的一个解,wn，就是幅角是2π/n的那个线段，有这样一个神奇的性质，其他的解，都可以表示为wn的若干次幂(还是用转圈来理解，每次拨一小格)

接下来一帮人就发现，对于一个次数为n-1的多项式，我们依次代入 wn^0,wn^1,wn^2,wn^3……的话，所得的函数值会有一个神奇的性质

设你代入的多项式为f(x)，如果我们把所有**偶数次**的项都拉出来，同时**次数减半**，设这样得到的多项式记为f1(x)，如果我们把所有**奇数次**的项都拉出来，**次数也减半**(向下取整)，记为f2(x)

则会有这样一个神奇的性质:

1.f(wn^i)=f1(w\[n/2]^i)+wn^i\*f2(wn^i)

2.f(wn^(i+n/2))=f1(w\[n/2]^2^i)-wn^i\*f2(wn^i)

上述两个式子都要求i<n/2

我们发现这是一个绝佳的递归式，因为f1,f2也是可以递归计算的因此，而如果多项式的次数被降到了常数项，我们代入w0后求的值，恰好就是常数项本身！

那么我们可以尝试列出一个递归版fft的算法流程，注意fft要求多项式的次数为2的整数幂，所以我们对于一个不是2的整数幂的多项式，我们要在高位补零

1把这个多项式进行奇偶分拆，偶放左边，奇放右边

2.递归计算偶数和奇数

3.合并，return

我们发现，如果以一种奇妙的操作，将原多项式系数重新排布，使得每一个系数，都在它递归的最后位置，那么我们就可以化递归为迭代，一个递归层一个递归层的计算，从而减少大量常数

那么我们发现，设原来第i个位置的系数，它在递归到终点时被分配到了p位置

那么我们会发现，p刚好时i的二进制位反转以后的数

所以我们预处理出来每个二进制位的反转即可

接下来就可以迭代fft了

且慢，我们刚讲完求值，插值呢？

好吧，这里提供一个非常不靠谱的记忆方法，你在求值的时候，相当于将wn顺时针拧了一圈，把一个系数表达拧成了点值表达，所以插值的时候逆时针拧一圈就行了，具体来讲，wn设为-wn即可,但是插值之后所有的系数会膨胀n倍，所以记得除以n

对了，wn的实部是cos(2π/n)虚部是sin(2π/n)

好了fft就讲完了
## 怎么做这道题

令xi=ai-bi,需要提升或下调r的亮度

那么总代价为sigma((xi+r)^2)=sigma(xi^2)+2r\*sigma(xi)+n\*r^2

发现sigma(xi)即使在旋转的时候也保持不变，那么后边的东西，就是一个二次函数的最小值，可以O(1)求出

那么现在就是最小化sigma((ai-bi)^2)=sigma(ai^2+bi^2)-2\*sigma(aibi)

其中sigma(ai^2+bi^2)不随旋转改变，所以就是求sigma(aibi)的最大值

那么我们可以构造一下乘法，将b数组倍长，a数组反向，那么a\*b中的一些位就是sigma(aibi)在旋转后的结果，之后就可以在其中做一个最大值就可以找到了

上代码~(说了这么多其实代码很短)

```C
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
typedef long long ll;
typedef double db;
const db pi=acos(-1.0);
const db eps=1e-2;
struct cmp//虚数类 
{
	db r;db i;cmp(db a=0.0,db b=0.0){r=a;i=b;} 
	friend cmp operator +(cmp a,cmp b){return cmp(a.r+b.r,a.i+b.i);}
	friend cmp operator -(cmp a,cmp b){return cmp(a.r-b.r,a.i-b.i);}
	friend cmp operator *(cmp a,cmp b){return cmp(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);}
	friend cmp operator /(cmp a,db b){return cmp(a.r/b,a.i/b);}
}a[400010],b[400010];int r[400010];int len=1;int n; 
inline void clacr(int len,int n)//预处理二进制反转的数组 
{for(int i=0;i<n;i++){r[i]=r[i>>1]>>1|((i&1)<<len);}}
inline void fft(cmp *tp,int n,int op)//op表示向正方向拧和反方向拧 
{
	for(int i=0;i<n;i++){if(i<r[i]){swap(tp[i],tp[r[i]]);}}//把所有东西放到递归的终点 
	for(int k=1;k<n;k<<=1)//枚举递归轮次 
	{
		for(int s=0;s<n;s+=2*k)//每次跳2*k块 
		{
			cmp now(1,0);cmp rt(cos(pi/k),op*sin(pi/k));//计算这一轮要用的wn 
			for(int i=s;i<s+k;i++,now=now*rt)//按照公式递推 
			{cmp ev=tp[i];cmp od=tp[i+k];tp[i]=ev+now*od;tp[i+k]=ev-now*od;}
		}
	}
	if(op==-1){for(int i=0;i<n;i++){tp[i]=tp[i]/n;}}//插值的话要除以n 
}
inline void fit(cmp *tp,int n){for(int i=0;i<n;i++){tp[i].r=(ll)(tp[i].r+eps);}}//处理计算中的精度损失 
ll light=0x7fffffff;ll mid;ll delta;ll sig;ll ma;int m;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=0;i<n;i++){scanf("%lf",&a[i].r);}
	for(int i=0;i<n;i++){scanf("%lf",&b[i].r);}
	for(int i=0;i<n;i++){sig+=a[i].r*a[i].r+b[i].r*b[i].r;}//计算各类要用的值 
	for(int i=0;i<n;i++){delta+=a[i].r-b[i].r;}
	mid=-(delta/n);
	for(int i=-1;i<=1;i++)//二次函数的对称轴可能不是整数，所以左右各取一次试试 
	{light=min(light,2*delta*(mid+i)+n*(mid+i)*(mid+i));}
	for(int i=0;2*i<n;i++){swap(a[i],a[n-i-1]);}//反转a 
	for(int i=0;i<n;i++){b[i+n]=b[i];}  //倍长b 
	for(;(1<<len)<3*n;len++);n=(1<<len);//由于最后的次数是3*n（n+2n）所以处理出3n个点值 
	clacr(len-1,n);fft(a,n,1);fft(b,n,1); //求值 
	for(int i=0;i<n;i++){a[i]=a[i]*b[i];} //乘 
	fft(a,n,-1);fit(a,n);                 //插值 
	for(int i=0;i<n;i++){ma=max((ll)(a[i].r),ma);}//求最大值 
	printf("%lld",light+sig-2*ma);return 0;//拜拜程序~ 
}
```








---

## 作者：Soulist (赞：12)

拆式子套路题

注意到$c$可以加在$a$上也可以加在$b$上，所以等价于可以给序列$a$上加上一个大小任意的$c$

我们把式子一拆：

$$\sum_{i=1}^n(a_i-b_i+c)^2$$

$$\sum_{i=1}^na_i^2+b_i^2+c^2+2a_i*c-2*b_i*c-2*a_ib_i$$

$$\sum_{i=1}^n(a_i^2+b_i^2)+2*(\sum_{i=1}^na_i-b_i)c+n*c^2-2*\sum_{i=1}^na_i*b_i$$

选定那个$x$可以二次函数算

于是交换顺序对答案造成的影响只有最后这一坨

$$\sum_{i=1}^na_i*b_i$$

目标是最大化它

如果你和我一样的$naive$可能会想起来一个定理，把两个排序后两两乘起来最大，然而这样不行，因为相对关系不能改变（只能旋转）

我们尝试构造新的一组$a$满足：

$$a_i'=a_{n-i}$$

于是原问题就转化成为，求解：

$$\sum_{i=1}^na_{n-i}'*b_i$$

此处$b$序列可以旋转

我们惊人的发现它是一个卷积的形式

接下来考虑$b$的旋转

你发现我们可以令$c$为$a'$与$b$进行卷积运算得到的结果

那么$c_x=\sum_{i=0}^xa'_{x-i}*b_i$

如果令$b_0=0,a_{n+1,n+2...n+n}=0$

就有：

$$c_n=\sum_{i=1}^na_{n-i}'*b_i$$

$$c_{n+1}=\sum_{i=1}^na_{n-i}'b_{i+1}$$

你发现我们只需要令$b_{n+1}=b_1$，就能通过$c_{n+1}$表示旋转一位后卷积的结果了

同理我们令$b_{n+k}=b_k$

于是就只要做一遍快乐的$NTT$就行了$qwq$

因为卷积最大的结果是$100*100*50000=5*10^8$，所以可以用$998244353$

------------

坑点：

$C++$是默认的向$0$取整，此处计算合适的$x$要四舍五入，所以要分类讨论$...$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
#define LL long long
#define int long long
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const LL P = 998244353 ; 
const LL Gi = 332748118 ; 
const LL G = 3 ; 
const int N = 400000 + 5 ;
int n, m, limit, L, R[N] ; 
LL A[N], B[N], Ans, K, X, Inv ;
LL fpow( LL x, LL k ) {
	LL base = x, ans = 1 ; 
	while( k ) {
		if( k & 1 ) ans *= base, ans %= P ; 
		base *= base, base %= P, k >>= 1 ;  
	}
	return ans ; 
}
void init( int x ) {
	limit = 1, L = 0 ;
	while( limit <= x ) limit <<= 1, ++ L ; 
	for( int i = 0; i < limit; ++ i ) R[i] = ( R[i >> 1] >> 1 ) | ( ( i & 1 ) << ( L - 1 ) ) ;
	Inv = fpow( limit, P - 2 ) ;
}
void NTT( LL *a, int type ) {
	for( int i = 0; i < limit; ++ i )
	if( i < R[i] ) swap( a[i], a[R[i]] ) ;
	for( int k = 1; k < limit; k <<= 1 ) {
		LL dg = fpow( ( type == 1 ) ? G : Gi, ( P - 1 ) / ( k << 1 ) ); 
		for( int i = 0; i < limit; i += ( k << 1 ) )
		for( LL j = i, g = 1; j < i + k; ++ j, g = ( g * dg ) % P ) {
			LL Nx = a[j], Ny = ( a[j + k] * g ) % P;
			a[j] = ( Nx + Ny ) % P, a[j + k] = ( Nx - Ny + P ) % P ; 
		}
	}
	if( type != 1 ) rep( i, 0, limit ) a[i] = a[i] * Inv % P ; 
}
signed main()
{
	n = read(), m = read() ; 
	rep( i, 1, n ) A[n - i] = read(), Ans += A[n - i] * A[n - i], K += A[n - i] ;
	rep( i, 1, n ) B[n + i] = B[i] = read(), Ans += B[i] * B[i], K -= B[i] ;
	K *= 2 ; double toX = -1.0 * K / n / 2 ;
	if( toX > 0 ) X = (LL)( toX + 0.5 ) ;
	else X = (LL)( toX - 0.5 ) ; 
	init( 3 * n ), Ans += X * X * n + K * X ;
	NTT( A, 1 ), NTT( B, 1 ) ; 
	rep( i, 0, limit ) A[i] = A[i] * B[i] % P ;
	NTT( A, -1 ) ; LL Rr = 0 ; 
	for( int i = n; i <= 2 * n + 1; ++ i ) Rr = max( Rr, A[i] ) ;
	printf("%lld\n", Ans - 2 * Rr ) ;
	return 0 ;
}
```

---

## 作者：panda_2134 (赞：7)

（这应该是步骤最全的题解了233）  
考虑到公式可能出问题，我就贴图片好了
（洛谷图床压了图，重新传一次)

-------------------

## 推导过程
![Formula](https://raw.githubusercontent.com/panda2134/panda2134.github.io/master/img/Gift.png)
## 代码
```cpp
#include <bits/stdc++.h>
#define PI M_PI
using namespace std;

typedef long long int64;

typedef std::complex<double> cmplx;

const int MAXN = 4e5;

namespace FFT {
	inline cmplx get_rt(int step, bool inv) {
		return !inv ? cmplx(cos(2*PI / step), sin(2*PI / step))
					: cmplx(cos(2*PI / step), -sin(2*PI / step));
	}
	void fft(int len, cmplx* A, bool inv) {
		static int R[MAXN+10];
		for(int i = 1; i < len; i++)
			R[i] = ((R[i>>1]>>1) | (len>>(i&1))) & (len-1);
		for(int i = 0; i < len; i++)
			if(R[i] > i) swap(A[i], A[R[i]]);
		for(int step = 1; step < len; step <<= 1)
			for(int i = 0; i < len; i += (step<<1)) {
				cmplx omega = 1, rt = get_rt(step<<1, inv);
				for(int j = 0; j < step; j++, omega *= rt) {
					cmplx t = omega * A[i+j+step];
					A[i+j+step] = A[i+j] - t;
					A[i+j] = A[i+j] + t;
				}
			}
		if(inv)
			for(int i = 0; i < len; i++) A[i] /= len;
	}
	void conv(int64* A, int64* B, int64* C, int deg) {
		static cmplx CA[MAXN+10], CB[MAXN+10], CC[MAXN+10];
		int len;
		for(len = 1; len <= ((deg + 1) << 1); len <<= 1);
		fill(CA, CA + len, 0);
		fill(CB, CB + len, 0);
		fill(CC, CC + len, 0);
		for(int i = 0; i <= deg; i++) {
			CA[i] = A[i], CB[i] = B[i];
		}
		fft(len, CA, false); fft(len, CB, false);
		for(int i = 0; i < len; i++)
			CC[i] = CA[i] * CB[i];
		fft(len, CC, true);
		for(int i = 0; i < len; i++)
			C[i] = int64(real(CC[i]) + 0.5);
	}
}

using FFT::conv;
int64 n, m, SumY, SumY2, SumC, SumC2, C[MAXN+10], Y[MAXN+10], T[MAXN+10];

inline int readint() {
	int f=1, r=0; char c=getchar();
	while(!isdigit(c)) { if(c=='-')f=-1; c=getchar(); }
	while(isdigit(c)) { r=r*10+c-'0'; c=getchar(); }
	return f*r;
}

void Init() {
	n = readint(); m = readint();
	for(int i = 0; i < n; i++) C[i] = C[i+n] = readint();
	for(int i = 1; i <= n; i++) Y[i] = readint();
	reverse(C, C+n); reverse(C+n, C+2*n);
	conv(C, Y, T, 2*n);
	for(int i = 1; i <= n; i++) {
		SumY += Y[i];
		SumY2 += Y[i] * Y[i];
	}
	for(int i = 0; i < n; i++) {
		SumC += C[i];
		SumC2 += C[i] * C[i];
	}
}

void Work() {
	int64 Ans = LLONG_MAX;
	for(int a = 0; a <= n-1; a++) {
		int64 CurP, CurAns = LLONG_MAX, CoeA, CoeB, CoeC;
		CoeA = n;
		CoeB = 2*SumC - 2*SumY;
		CoeC = SumY2 + SumC2 - 2*T[n + a];
		CurP = (-CoeB) / (2*CoeA);
		for(int P = max(-m, CurP - 10); P <= min(m, CurP + 10); ++P)
			CurAns = min(CurAns, CoeA * P * P + CoeB * P + CoeC);
		Ans = min(Ans, CurAns);
	}
	cout << Ans;
}

int main() {
	Init(); Work();
	return 0;
}
```

---

## 作者：rehtorbegnaro (赞：5)

首先我们要有一个简单粗暴的暴力。

$$\min\limits_{x=0}^{n-1}\min\limits_{c_{1}=0,c_{2}=0}^{m}\sum\limits_{i=0}^{n-1}(A_{i}+c_{1}-B_{(i+x)\%n}-c_{2})^{2}$$

因为我们关心的只是两个数的差的平方，我们完全可以将$c_{1}$和$c_{2}$这两个非负整数合并成一个整数$c$。

$$\min\limits_{x=0}^{n-1}\min\limits_{c=-m}^{m}\sum\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\%n}+c)^{2}$$

我们仔细观察一下那个$\Sigma$。

$$\begin{aligned}&\sum\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\%n}+c)^{2}\\=&\sum\limits_{i=0}^{n-1}(A_{i}^{2}+B_{(i+x)\%n}^{2}+c^{2}-2A_{i}B_{(i+x)\%n}+2cA_{i}-2cB_{(i+x)\%n})\\=&\sum\limits_{i=0}^{n-1}A_{i}^{2}+\sum\limits_{i=0}^{n-1}B_{i}^{2}+nc^{2}+2c(\sum\limits_{i=0}^{n-1}A_{i}-\sum\limits_{i=0}^{n-1}B_{i})-2\sum\limits_{i=0}^{n-1}A_{i}B_{(i+x)\%n}\end{aligned}$$

首先$\Sigma A_{i}^{2}$和$\Sigma B_{i}^{2}$可以看成是常数项。

$nc^{2}+2c(\Sigma A_{i}-\Sigma B_{i})$可以看成是一个关于$c$的二次函数，令$k=(\Sigma A_{i}-\Sigma B_{i})$，我们知道它在$c=-\frac{k}{n}$处取得最小值。但是根据题意，$c$应当是一个整数，因此我们需要将$c=\lfloor -\frac{k}{n}\rfloor$和$c=\lceil -\frac{k}{n}\rceil$两者都代入原式，然后取较小值。

然后我们想要求出$\Sigma A_{i}B_{(i+x)\%n}$的最大值，加上上面那两项就是最终答案了。首先这个取模不好搞，我们把它拆开。

$$\sum\limits_{i=0}^{n-x-1}A_{i}B_{i+x}+\sum\limits_{i=0}^{x-1}A_{i-x+n}B_{i}$$

然后我们看到这个东西好像卷积啊，但是卷积要求两个下标加起来是常数，这个下标是加上一个数没办法卷积啊。

然后一想，我们可以倒过来搞啊。

定义$F^{R}(x)$是将$F(x)$的系数数组翻转过来得到的新多项式。于是我们可以将上式写成

$$\begin{aligned}&\sum\limits_{i=0}^{n-x-1}A_{i}B^{R}_{n-x-1-i}+\sum\limits_{i=0}^{x-1}A^{R}_{x-1-i}B_{i}\\=&(AB^{R})_{n-x-1}+(A^{R}B)_{x-1}\end{aligned}$$

然后套一波多项式乘法的板子，扫一遍系数求个最大值就行了。需要注意的是当$x=0$的时候就只有$(AB^{R})_{n-1}$一项。

代码去我[blog](https://challestend.github.io/luogu-p3723-solution/)里找吧（

看了一圈题解发现就我用NTTemmmmmm……

---

## 作者：Sai0511 (赞：5)

一道神题233。。。其实要是把思路想通了也不是很难。  
### 正文部分：         
设经过了各种操作之后的数列为$A$与$B$，总增加量为$x$。  
那么第$i$项所造成的影响就是      
$(A_i+x-B_i)^2=A_i^2+x^2+B_i^2+2A_ix-2A_iB_i-2xB_i^2$
然而$A$手环加上相等于$B$手环减去，所以$m$的范围变为$-100\sim100$         
那么我们可以轻松的得到这两个数列的总影响：

$\sum_{i=1}^{i=n}(A_i+x-B_i)^2$

尝试把这个式子展开，成为：     

$\sum_{i=1}^{i=n}A_i^2+\sum_{i=1}^{i=n}B_i^2+n*x^2+2x(\sum_{i=1}^{i=n}A_i-\sum_{i=1}^{i=n}B_i)-2\sum_{i=1}^{i=n}A_iB_i$     

这时发现除了最后一项其他项全是固定的，所以我们只需要让最后一项最大即可，可以用$fft$来求解：    
### My code
```cpp
#include <bits/stdc++.h>
#define il inline
#define gc getchar
#define FI "gift"
const int MAXN = 4e6 + 10;
const int INF = 0x7f7f7f7f;
const double pi = acos(-1);
using namespace std;
il int read() {
    int res = 0;char c;bool sign = 0;
    for(c = gc();!isdigit(c);c = gc()) sign |= c == '-';
    for(;isdigit(c);c = gc()) res = (res << 1) + (res << 3) + (c ^ 48);
    return sign ? -res : res;
}
il void FileIO() {
    freopen(FI".in","r",stdin);
    freopen(FI".out","w",stdout);
    return;
}
struct Cpx {
    double r,i;
    Cpx(){}
    Cpx(double x,double y) {
        r = x,i = y;
    }
    Cpx operator + (const Cpx& x) const {
        return Cpx(r + x.r,i + x.i);
    }
    Cpx operator - (const Cpx& x) const {
        return Cpx(r - x.r,i - x.i);
    }
    Cpx operator * (const Cpx& x) const {
        return Cpx(r * x.r - i * x.i,r * x.i + i * x.r);
    }
    void operator *= (Cpx& x) {
        *this = *this * x;
        return;
    }
}a[MAXN],b[MAXN];
int n,m,i,j,k,R[MAXN],_a[MAXN],_b[MAXN];
int sqr_a,sqr_b,sum_a,sum_b,li,x,ans = INF;
il void fft(Cpx a[MAXN],int f) {
    int i,j,k;
    for(i = 0;i < li;i++) {
        if(i < R[i]) swap(a[i],a[R[i]]);
    }
    for(i = 1;i < li;i <<= 1) {
        Cpx wn(cos(pi / i),f * sin(pi / i));
        for(j = 0;j < li;j += (i << 1)) {
            Cpx w(1,0);
            for(k = 0;k < i;k++,w *= wn) {
                Cpx x = a[j + k],y = w * a[j + k + i];
                a[j + k] = x + y;a[j + k + i] = x - y;
            }
        }
    }
    return;
}
int main() {
    // FileIO();
    n = read();m = read();
    for(i = 1;i <= n;i++) {
        _a[i] = read();
        sqr_a += _a[i] * _a[i];
        sum_a += _a[i];
    }
    for(i = 1;i <= n;i++) {
        _b[i] = read();
        sqr_b += _b[i] * _b[i];
        sum_b += _b[i];
    }
    for(i = 1;i <= n;i++) {
        a[i].r = a[i + n].r = _a[i];
        b[i].r = _b[n - i + 1];
    }
    int t = 0;li = 1;while(li <= n*3) li <<= 1,t++;
    for(i = 0;i <= li;i++) {
        R[i] =(R[i >> 1] >> 1 | ((i & 1) << (t - 1)));
    }
    fft(a,1);fft(b,1);
    for(i = 0;i <= li;i++) a[i] *= b[i];
    fft(a,-1);
    for(i = 0;i <= li;i++) {
        a[i].r = (int)(a[i].r / li + 0.5);
    }
    for(i = 1;i <= n;i++) {
        for(x = -m;x <= m;x++) {
            int tmp = sqr_a + sqr_b + n * x * x;
            tmp += 2 * x *(sum_a - sum_b);
            ans = min(ans,tmp - 2 * (int)a[i + n].r);
        }
 	}
 	printf("%lld",1LL * ans);
}
```

---

## 作者：南方不败 (赞：4)

## 知识点：
FFT，NTT

## 题意：
给两个环，可以转但是不可以翻，要求给其中一个环每个元素加上一个非负整数，求每一项差的平方之和最小。

## 解法：
任意一个环加上一个非负整数相当于其中一个环加上一个整数。列出式子（$x\in Z$，是我们要加上的那个数）：$\displaystyle\sum_{i=1}^{n}(a_i-b_i+x)^2=\displaystyle\sum_{i=1}^{n}(a_i^2+b_i^2+x^2+2a_ix-2b_ix-2a_ib_i)=\displaystyle\sum_{i=1}^{n}a_i^2+\displaystyle\sum_{i=1}^{n}b_i^2+nx^2+2x\displaystyle\sum_{i=1}^{n}(a_i-b_i)-2\displaystyle\sum_{i=1}^{n}a_ib_i$。所以最后一项是个卷积，卷一下求最大值即可（因为倍长过a，所以找最大值从第n+1到2n项找，原式卷起来有效的就是那些地方）。中间两项是个二次函数，求一下顶点左右的两个整数即可，前两项是常数。

## 备注：
这种题见到环先破环成链，倍长变成序列，卷出来的答案必定在n+1到2n项（想想原来的是什么，现在的是什么）。然后就都是套路了。

## 代码：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;

typedef long long ll;
const int maxn=400010,mod=998244353,G=3,invG=332748118;
int n,m,a[maxn],b[maxn],c[maxn],r[maxn],ta[maxn],tb[maxn];
ll ans;

int read()
{
	int x=0;
	char c=getchar();
	while (c<48||c>57)
		c=getchar();
	while (c>=48&&c<=57)
		x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return x;
}

int qp(int a,int b)
{
	int res=1;
	for (;b;b>>=1)
	{
		if (b&1)
			res=1ll*res*a%mod;
		a=1ll*a*a%mod;
	}
	return res;
}

int init(int len)
{
	int N,i,j;
	for (N=1;N<len;N<<=1);
	j=(N>>1);
	for (i=1;i<=N-2;i++)
		r[i]=(r[i>>1]>>1)|((i&1)*j);
	return N;
}

void ntt(int *f,int N,bool pos)
{
	int i,j,k,len,t,tmp,w;
	for (i=1;i<=N-2;i++)
		if (i<r[i])
			swap(f[i],f[r[i]]);
	for (k=2;k<=N;k<<=1)
	{
		len=(k>>1);
		tmp=qp(pos?G:invG,(mod-1)/k);
		for (j=0;j<N;j+=k)
		{
			w=1;
			for (i=j;i<j+len;i++)
			{
				t=1ll*w*f[i+len]%mod;
				f[i+len]=f[i]-t;
				if (f[i+len]<0)
					f[i+len]+=mod;
				f[i]=f[i]+t;
				if (f[i]>=mod)
					f[i]-=mod;
				w=1ll*w*tmp%mod;
			}
		}
	}
	if (!pos)
	{
		int invN=qp(N,mod-2);
		for (i=0;i<N;i++)
			f[i]=1ll*f[i]*invN%mod;
	}
}

void poly_mul(int *A,int n,int *B,int m,int *C,int lim=0)
{
	int i,N=init(n+m-1);
	memcpy(ta,A,n*4);
	fill(ta+n,ta+N,0);
	memcpy(tb,B,m*4);
	fill(tb+m,tb+N,0);
	ntt(ta,N,1),ntt(tb,N,1);
	for (i=0;i<N;i++)
		C[i]=1ll*ta[i]*tb[i]%mod;
	ntt(C,N,0);
	memset(ta,0,N*4+4);
	memset(tb,0,N*4+4);
	if (lim)
		fill(C+lim,C+N,0);
}

int main()
{
	int n=read(),i=read(),p=0,q=0,tmp=0,x;
	for (i=0;i<n;i++)
		a[i]=a[i+n]=read(),ans+=a[i]*a[i];
	for (i=0;i<n;i++)
		b[i]=read(),ans+=b[i]*b[i],q+=a[i]-b[i];
	q*=2,p=n;
	reverse(b,b+n);
	poly_mul(a,n*2,b,n,c,n*2);
	for (i=n;i<n*2;i++)
		tmp=max(tmp,c[i]);
	tmp*=2;
	ans-=tmp;
	x=(int)floor((-1.0*q)/(2.0*p));
	tmp=1ll*x*x*p+1ll*x*q;
	x=(int)ceil((-1.0*q)/(2.0*p));
	ans+=1ll*min(1ll*tmp,1ll*x*x*p+1ll*x*q);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Nemlit (赞：3)

~~被某大佬指出这是多项式板子！？~~

我们假设我们原始数列是$a_i, c_i$， 旋转后的数列是$a_i, b_i$，我们的增加量为x

$$\sum_{i = 1}^n(a_i - b_i + x)^2$$

拆开平方得：

$$\sum_{i = 1}^na_i^2+b_i^2+x^2+2*x*a_i-2*x*b_i-2*a_i*b_1$$

把这些东西分下类：

$$x^2*n+(\sum_{i=1}^na_i^2+b_i^2)+2*x*(\sum_{i = 1}^n a_i+b_i)+2*(\sum_{i = 1}^na_i*b_i)$$

发现$x$只有$[-100, 100]$，我们考虑枚举x，然后就只有最后一堆是未知的

我们考虑怎么求最后一堆：两个值乘在一起的和，是不是和多项式有关系呢？

但这并不是一个卷积的形式，但我们考虑把b反向，原式就变成了：$\sum_{i=1}^na_i*b_{n-i+1}$

于是我们就可与愉快的用多项式来做这道题了。[不会多项式？戳戳看？](https://www.cnblogs.com/bcoier/p/11644303.html)

把a数组倍长，把b数组反向，于是这道题的式子就成了：$\sum_{i=1}^na_{i+k}c_{n-i+1}$，然后多项式的第$n+1-2*n$就分别代表$k$取$0-n-1$的值了
## $Code:$
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define int long long
const double pi = acos(-1);
#define inf 12345678900000000
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define maxn 300005
struct node {
	double x, y;
}a[maxn], b[maxn];
il node operator + (node a, node b) { return (node){a.x + b.x, a.y + b.y}; }
il node operator - (node a, node b) { return (node){a.x - b.x, a.y - b.y}; }
il node operator * (node a, node b) { return (node){a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x}; }
int n, m, lim, r[maxn], ans = inf, sum1, sum2, Ans = -inf;
il void FFT(node *a, int f, int len) {
	rep(i, 0, len - 1) if(r[i] > i) swap(a[r[i]], a[i]);
	for(re int mid = 1; mid < len; mid <<= 1) {
		node base = (node){cos(pi / mid), f * sin(pi / mid)};
		for(re int p = mid * 2, j = 0; j < len; j += p) {
			node w = (node){1, 0};
			for(re int k = 0; k < mid; ++ k, w = w * base) {
				node x = a[j + k], y = a[j + k + mid] * w;
				a[j + k] = x + y, a[j + k + mid] = x - y;
			}
		}
	}
}
signed main() {
	n = read(), m = read();
	rep(i, 1, n) a[i].x = a[i + n].x = read();
	rep(i, 1, n) b[n - i + 1].x = read();
	rep(i, 1, n) sum1 += a[i].x * a[i].x + b[i].x * b[i].x, sum2 += a[i].x - b[i].x;
	while((1 << lim) <= 3 * n) ++ lim;
	rep(i, 0, (1 << lim)) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (lim - 1));
	FFT(a, 1, (1 << lim)), FFT(b, 1, (1 << lim));
	rep(i, 0, (1 << lim)) a[i] = a[i] * b[i];
	FFT(a, -1, (1 << lim));
	rep(x, -m, m) ans = min(ans, x * x * n + sum1 + 2 * x * sum2);
	rep(i, n + 1, 2 * n) Ans = max(Ans, (int)(a[i].x / (1 << lim) + 0.5));
	printf("%lld", ans - 2 * Ans);
	return 0;
}
```

---

## 作者：DOTime (赞：3)

http://www.cnblogs.com/D-O-Time/p/7954847.html

因为可以加上一个常数C，说是非负整数，但其实A手环加上，就等于B手环减去，于是把m范围扩充到[-100,100]即可。


然后所求变为：


$$\sum (x_i-y_i+C)$$


接着拆开，可以得到：


$$\sum(x_i^2+y_i^2+C^2)+2*C*\sum(x_i-y_i)+2*\sum(x_i*y_i)$$


然后发现这些有常量，可变的C所对应的x和y是常数，而与顺序有关的xi\*yi又是与C无关的。所以我们可以先求出的最大值xi\*yi。如果我们将B手环在输入之后反转一下，可以发现当翻转前A与B发生错位之时，每一个错位都可以对应反转之后的B与A的FFT的乘积的各个项的系数。


然后再枚举C从[-m,m]那么答案就出来了。


不会FFT的就去学吧。


```cpp
 1 #include<cmath>
 2 #include<cstdio>
 3 #include<complex>
 4 #include<iostream>
 5 #include<algorithm>
 6 #define C complex<double>
 7 #define pf(a) ((a)*(a))
 8 using namespace std;
 9 const int MAXN=1000000,INF=0x3f3f3f3f;
10 const double pi=acos(-1.0);
11 int n,m,L,G,Max,Val,ans=INF,sum1,sum2;
12 int R[MAXN],V[MAXN];
13 C A[MAXN],B[MAXN];
14 inline int gi(){int res; scanf("%d",&res); return res;}
15 void FFT(C *a,int p)
16 {
17   for(int i=0;i<n;i++)if(i<R[i])swap(a[i],a[R[i]]);
18   for(int i=1;i<n;i<<=1)
19     {
20       C wn(cos(pi/i),sin(p*pi/i)),x,y;
21       for(int j=0;j<n;j+=(i<<1))
22         {
23           C w(1,0);
24           for(int k=0;k<i;k++,w*=wn)
25             {
26               x=a[j+k],y=w*a[j+k+i];
27               a[j+k]=x+y;
28               a[j+k+i]=x-y;
29             }
30         }
31     }
32 }
33 int main()
34 {
35   freopen("gift.in","r",stdin);
36   freopen("gift.out","w",stdout);
37   n=gi();Max=gi(); n--;
38   for(int i=0;i<=n;i++)A[i]=gi();
39   for(int i=0;i<=n;i++)B[i]=gi();
40   for(int i=0;i<=n;i++)
41     {
42       sum1+=pf(A[i].real())+pf(B[i].real());
43       sum2+=A[i].real()-B[i].real();
44     }
45   m=n+n; reverse(B,B+n+1);
46   for(n=1;n<=m;n<<=1)L++;L--;
47   for(int i=0;i<n;i++)R[i]=(R[i>>1]>>1)|((i&1)<<L);
48   FFT(A,1); FFT(B,1);
49   for(int i=0;i<=n;i++)A[i]*=B[i];
50   FFT(A,-1);
51   for(int i=0;i<=m;i++)V[i]=(int)(A[i].real()/n+0.5);
52   n=m/2; Val=V[n];
53   for(int i=0;i<=n-1;i++)
54     if(Val<V[i]+V[n+i+1])
55       Val=V[i]+V[n+i+1];
56   Val*=2;
57   for(int c=-Max;c<=Max;c++)
58     ans=min(ans,sum2*2*c+(n+1)*c*c-Val);
59   printf("%d\n",ans+sum1);
60   return 0;
61 }
```

---

## 作者：徐致远 (赞：1)


[本蒟蒻的Blog](https://www.chnxuzhiyuan.cn/2019/10/21/%E3%80%8CAH2017HNOI2017%E3%80%8D%E7%A4%BC%E7%89%A9-Solution/)

### 题解

首先来看下题目里的式子：
$$
\sum_{i=1}^{n}{(x_i-y_i+c)^2}=\sum_{i=1}^{n}{x_i^2+y_i^2+c^2-2x_iy_i+2cx_i-2cy_i}
$$
其中$\sum x_i^2+y_i^2$为定值，$\sum c^2+2cx_i-2cy_i-2x_iy_i$在确定了$c$的值之后也是定值，并且c的值非常小可以暴枚，所以只需要考虑$\sum x_iy_i$。

由于是一个环，按照套路，可以先将$x_i$复制一遍。

设$C_i$为旋转了$i$个单位后$\sum x_iy_i$的值，有：
$$
C_i=\sum_{j=1}^{n}{x_{i+j}y_j}
$$

这个式子不是很好看，于是我们把$y$（$x$也行）倒过来，那么就有：
$$
C_i=\sum_{j=1}^{n}{x_{i+j}y_{n-j+1}}
$$
然后不难发现，$x$与$y$下标之和为$n+i+1$的数将被乘起来然后对$C_i$造成贡献，所此时以$C_i$就等于多项式$x_1\cdot x+x_2\cdot x^2+\cdots x_n\cdot x^n$与$y_1\cdot x+y_2\cdot x^2+\cdots y_n\cdot x^n$卷积卷起来之后$x^{i+n+1}$项的系数。

然后NTT求个卷积然后取个最小值就行了。

### 代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long LL;
const int maxn=50005,TT=998244353;
int n,m,r[maxn<<3],X[maxn],Y[maxn],A[maxn<<3],B[maxn<<3],C[maxn<<3],ans=2e9;
inline int read()
{
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
inline int QP(int a,int b)
{
	int ret=1,w=a;
	while(b)
	{
		if(b&1) ret=(LL)ret*w%TT;
		w=(LL)w*w%TT;b>>=1;
	}
	return ret;
}
inline void NTT(int* A,int limit,int typ)
{
	for(int i=0;i<limit;i++)
		if(i<r[i])
			swap(A[i],A[r[i]]);
	for(int mid=1;mid<limit;mid<<=1)
	{
		int gn=QP(3,(TT-1)/(mid<<1));
		if(typ<0) gn=QP(gn,TT-2);
		for(int j=0;j<limit;j+=mid<<1)
		{
			int g=1;
			for(int k=0;k<mid;k++,g=(LL)g*gn%TT)
			{
				int x=A[j+k],y=(LL)g*A[j+k+mid]%TT;
				A[j+k]=(x+y)%TT;
				A[j+k+mid]=(x-y+TT)%TT;
			}
		}
	}
	if(typ<0)
	{
		int inv=QP(limit,TT-2);
		for(int i=0;i<limit;i++) A[i]=(LL)A[i]*inv%TT;
	}
}
inline int Calc(int c){int ret=0;for(int i=1;i<=n;i++)ret+=X[i]*X[i]+Y[i]*Y[i]+c*c+2*X[i]*c-2*Y[i]*c;return ret;}
inline void Solve()
{
	for(int i=1;i<=n;i++) A[i]=A[i+n]=X[i];
	for(int i=1;i<=n;i++) B[i]=Y[i];
	reverse(A+1,A+1+n*2);
	int limit=1,l=0;
	while(limit<=n+n+m){limit<<=1;l++;}
	for(int i=0;i<limit;i++)
		r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	NTT(A,limit,1);
	NTT(B,limit,1);
	for(int i=0;i<limit;i++) C[i]=(LL)A[i]*B[i]%TT;
	NTT(C,limit,-1);
	for(int c=-m;c<=m;c++)
		if(Calc(c)<ans)
			ans=Calc(c);
	int tep=0;
	for(int i=1;i<=n;i++)
		if(C[n+i]>tep)
			tep=C[n+i];
	ans-=2*tep;
}
int main()
{
	n=read();m=read();
	for(int i=1;i<=n;i++) X[i]=read();
	for(int i=1;i<=n;i++) Y[i]=read();
	Solve();
	printf("%d\n",ans);
	return 0;
}
```



---

## 作者：撤云 (赞：1)

[$blog$](https://www.cnblogs.com/hbxblog/p/10328890.html)
### $Solution$  

应为我们可以将任意一个数列加上一个非负整数，即可以变为将一个数列加上一个整数(可以为负),我们将这个整数设为$z$.所以要求的式子的变为：  
$$\sum_{i=1}^{n}(x_i-y_i+z)^2$$  
首先来化简一下式子  
$$\sum_{i=1}^{n}(x_i-y_i+z)^2$$  
$$\sum_{i=1}^{n}x_i^2+\sum_{i=1}^{n}y_i^2+\sum_{i=1}^{n}z_i^2+2z\sum_{i=1}^{n}(x_i-y_i)-2\sum_{i=1}^{n}x_i*y_i$$  

我们可以发现不管如何变化$\sum_{i=1}^{n}x_i^2+\sum_{i=1}^{n}y_i^2$的值都不会变.  

然后再看看$\sum_{i=1}^{n}z_i^2+2z\sum_{i=1}^{n}(x_i-y_i)$显然这是一个关于$z$的二次函数.最小值可以$O(1)$算出但是注意一下$z$必须是整数而且可以为负,所以需要将$-\frac{x_i-y_i}{n}$向上和向下取整并带入式子取最小值.  

所以我们现在只需要算出$2\sum_{i=1}^{n}x_i*y_i$的最大值即可.
这个如何去算,将$y$变成链,在进行一次$fft$在取一个最大值就好了

### $Code$
``` cpp
#include<bits/stdc++.h>
#define int long long
#define rg register
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return f*x;
}
const int N=3000001;
const double pi=3.14159265358979323846;
struct node {
    double x,y;
    node operator + (node z)const {
        return (node){x+z.x,y+z.y};
    }
    node operator - (node z)const {
        return (node){x-z.x,y-z.y};
    }
    node operator * (node z)const {
        return (node){x*z.x-y*z.y,y*z.x+x*z.y};
    }
}f[N],g[N];
int r[N],limit=1;
void fft(node *a,int opt){
    for(int i=0;i<=limit;i++)
        if(i<r[i])
            swap(a[i],a[r[i]]);
    for(int i=1;i<limit;i<<=1){
        node w=(node){cos(pi/i),opt*sin(pi/i)};
        for(int j=0;j<limit;j+=i<<1){
            node l=(node){1,0};
            for(int k=j;k<j+i;k++){
                node p=l*a[k+i];
                a[k+i]=a[k]-p;
                a[k]=a[k]+p;
                l=l*w;
            }
        }
    }
}
int a[N],b[N];
main(){
    int n=read(),k=read(),l=0,m=n,js=0,ans=0;
    for(int i=1;i<=n;i++)
        a[i]=f[i].x=read(),f[i+n].x=f[i].x,js+=a[i],ans+=a[i]*a[i];
    for(int i=1;i<=n;i++)
		b[i]=read(),js-=b[i],ans+=b[i]*b[i];
	reverse(b+1,b+n+1);
	for(int i=1;i<=n;i++)
		g[i].x=b[i];
	int A=-floor(js*1.0/n),B=-ceil(js*1.0/n);
	ans+=min(A*A*n+2*A*js,B*B*n+2*B*js);
	n*=2;
	while(limit<=n+m)
        limit<<=1,l++;
    for(int i=0;i<limit;i++)
        r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
    fft(f,1),fft(g,1);
    for(int i=0;i<=limit;i++)
        f[i]=f[i]*g[i];
    fft(f,-1);
	int maxx=0;
    for(int i=m;i<=n+1;i++)
		maxx=max((int)(f[i].x/limit+0.5),maxx);
	printf("%lld",ans-2*maxx);
}

```

---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P3723)看题目。
# 分析
### $30pts$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到$m$这么小，不难想到枚举其中一个环增加的$c$。然后枚举另一个环的起始位置，与第一个环暴力计算答案，取最小值。时间$O(n^2m)$。  
### $70pts$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先剖环，也就是把序列复制一遍到尾巴。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大力拆式子：  
$$\sum_{i=1}^n((x_i+c)-y_i)^2$$  
$$=\sum_{i=1}^n((x_i+c)^2-2(x_i+c)y_i+y_i^2)$$  
$$=\sum_{i=1}^n(x_i+c)^2-2\sum_{i=1}^n(x_i+c)y_i+\sum_{i=1}^ny_i^2$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令$p=\sum_{i=1}^n(x_i+c)^2,q=\sum_{i=1}^ny_i^2$。在一次加上$c$之后的计算中，这两个都可以$O(n)$算出来。  
$$\text{原式}=p+q-2\sum_{i=1}^nx_iy_i$$  
$$\therefore \min_{0\le j<n}\left\{\sum_{i=1}^n((x_i+c)-y_{i+j})^2\right\}=p+q-2\max_{0\le j<n}\left\{\sum_{i=1}^n(x_i+c)y_{i+j}\right\}$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个式子就是当$c$固定的时候的最小差异值。枚举$c$，问题就变成了如何解决后面那一大堆。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对于$x$总体加上一个$c$，那么就有：  
$$\sum_{i=1}^n(x_i+c)y_{i}=\sum_{i=1}^nx_iy_{i}+c\sum_{i=1}^ny_i$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于$\sum_{i=1}^ny_i$不变，所以$c\sum_{i=1}^ny_i$也不变。  
$$\therefore \min_{0\le j<n}\left\{\sum_{i=1}^n((x_i+c)-y_{i+j})^2\right\}=p+q-2\left(\max_{0\le j<n}\left\{\sum_{i=1}^nx_iy_{i+j}\right\}+c\sum_{i=1}^ny_i\right)$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个故事告诉我们，只需要预处理$\max_{0\le j<n}\{\sum_{i=1}^nx_iy_{i+j}\}$就可以了。预处理完了之后就可以$O(mn)$解决这个问题。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;暴力$O(n^2+mn)$，就有$70pts$了。  
### $100pts$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看一下我们要求的东西：  
$$\max_{0\le j<i}\left\{\sum_{i=1}^nx_iy_{i+j}\right\}$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;令$f(j)=\sum_{i=1}^nx_iy_{i+j}$，实际上就要求$\max_{0\le j<i}\{f(j)\}$。假如我们可以高效地求出$f$，这个问题就解决了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$y_{i+j}$看起来有一些奇怪不是吗？把$y$整体倒过来得到$y'$。新下标关系让我们想到了卷积。考虑通过卷积的变换得到我们需要的$f$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设卷积的结果$f'(j)=\sum_{i=0}^jx_iy_{j-i}'$举个例子找规律，样例：  
![gift.png](https://i.loli.net/2019/12/19/hxtOznYE2McoIQb.png)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一排小数字对应下标；第二排的大数字对应第一个手环上的数（已展开）；第三排的大数字对应第二个手环上的数（已展开）。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;红色线和深蓝色线表示的是$f'(8)$中各项对应关系。天蓝色线和粉红色线表示的是$f'(3)$中各项对应关系。绿色线划定了$f'(3)$的范围。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现$f'(8)$中似乎包含了$f(2)$的对应关系，但是还有多的部分——也就是第二排大数字上标号为$6,7,8$的位置，它们被多计算了。不过，这样的对应关系在$f'(3)$中已经被计算好了，所以可以直接减掉。所以我们可以先$FFT$，再用这个规律计算出$f$，取$\max$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后的时间复杂度就是$O(n\log_2n+nm)$。  
# 代码
```cpp
#include <cmath>
#include <cstdio>
#include <iostream>

typedef long long LL;

const double PI = acos( -1 );
const LL INF = 0x3f3f3f3f3f3f3f3f;
const int MAXN = 100005;

template<typename _T>
void read( _T &x )
{
    x = 0;char s = getchar();int f = 1;
    while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
    while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
    x *= f;
}

template<typename _T>
void write( _T x )
{
    if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
    if( 9 < x ){ write( x / 10 ); }
    putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}


typedef struct complex
{
	double r, i;
	complex(){} complex( const double R, const double I = 0 ) { r = R, i = I; }
	complex operator + ( const complex & b ) const { return complex( r + b.r, i + b.i ); }
	complex operator - ( const complex & b ) const { return complex( r - b.r, i - b.i ); }
	complex operator * ( const complex & b ) const { return complex( r * b.r - i * b.i, r * b.i + i * b.r ); }
	complex operator / ( const double & b ) const { return complex( r / b, i / b ); }
	void operator += ( const complex & b ) { *this = *this + b; }
	void operator -= ( const complex & b ) { *this = *this - b; }
	void operator *= ( const complex & b ) { *this = *this * b; }
	void operator /= ( const double & b ) { *this = *this / b; }
}comp;

comp A[MAXN << 2], B[MAXN << 2], C[MAXN << 2];
LL negt[MAXN];
int a[MAXN << 1], b[MAXN << 1];
LL mxNeg, sumA, sumB;
int N, M;

LL sqr( const LL x ) { return x * x; }

LL cal( const int x, const bool type )
{
	LL sa = 0, sb = 0;
	for( int i = 1 ; i <= N ; i ++ ) sa += sqr( a[i] + type * x ), sb += sqr( b[i] + ( 1 - type ) * x );
	return sa - 2 * ( mxNeg + ( type ? sumB * x : sumA * x ) ) + sb;
}

void FFT( comp *coe, const int len, const int type )
{
	int lg2 = log2( len );
	for( int i = 0, rev ; i < len ; i ++ )
	{
		rev = 0;
		for( int j = 0 ; j < lg2 ; j ++ ) rev |= ( ( i >> j ) & 1 ) << ( lg2 - j - 1 );
		if( rev < i ) std :: swap( coe[rev], coe[i] );
	}
	comp wp, w, we, wo;
	for( int s = 2, p ; s <= len ; s <<= 1 )
	{
		p = s >> 1, wp = comp( cos( type * PI / p ), sin( type * PI / p ) );
		for( int i = 0 ; i < len ; i += s )
		{
			w = comp( 1, 0 );
			for( int j = 0 ; j < p ; j ++, w *= wp )
			{
				we = coe[i + j], wo = coe[i + j + p];
				coe[i + j] = we + wo * w, coe[i + j + p] = we - wo * w;
			}
		}
	}
	if( ~ type ) return ;
	for( int i = 0 ; i <= len ; i ++ ) coe[i] /= len;
}

void times( const int la, const int lb )
{
	int K = la + lb;
	int len = 1 << int( ceil( log2( K ) ) );
	if( len == K ) len <<= 1;
	FFT( A, len, 1 ), FFT( B, len, 1 );
	for( int i = 0 ; i <= len ; i ++ ) C[i] = A[i] * B[i];
	FFT( C, len, -1 );
}

int main()
{
	LL res = INF;
	read( N ), read( M );
	for( int i = 1 ; i <= N ; i ++ ) read( a[i] ), a[i + N] = a[i], sumA += a[i];
	for( int i = 1 ; i <= N ; i ++ ) read( b[i] ), b[i + N] = b[i], sumB += b[i];
	for( int i = 1 ; i <= N << 1 ; i ++ ) A[i] = a[i], B[i] = b[( N << 1 ) - i + 1];
	times( N * 2 + 1, N * 2 + 1 );
	for( int i = N ; i <= N << 1 ; i ++ ) 
		mxNeg = MAX( mxNeg, ( LL ) round( C[i].r - C[i - N].r ) );
	for( int i = 0 ; i <= M ; i ++ ) res = MIN( res, cal( i, true ) );
	for( int i = 0 ; i <= M ; i ++ ) res = MIN( res, cal( i, false ) );
	write( res ), putchar( '\n' );
	return 0;
}
```

---

## 作者：VenusM1nT (赞：0)

$\textbf{FFT}$.  
~~模数原根不是 3 甚至没有模数的多项式题都是屑【半恼】~~  
感谢这道题让我复习了 FFT 的写法（  
首先两个手环都加亮度就等价于一个手环加减亮度，考虑加减的亮度为 $\ell$，则最后的差异值为
$$\sum_{i=1}^n(a_i-b_i+\ell)^2$$
考虑拆开其中一项，则得：
$$a_i^2+b_i^2+\ell^2+2\times a_i\times \ell-2\times b_i\times \ell-2\times a_i\times b_i$$
那么原式可以被转化为：
$$\sum_{i=1}^n(a_i^2+b_i^2)+n\times \ell^2+2\times \ell\times \sum_{i=1}^n(a_i-b_i)-2\times \sum_{i=1}^n(a_i\times b_i)$$
这时我们发现如果 $\ell$ 确定，那么整个式子除了最后一项的值我们都可以很简单地求出来。答案要求最小化差异值，那么我们只要让 $\sum(a_i\times b_i)$ 最大就可以了。这个最大值可以用卷积求出。  
（没有模数被迫使用 FFT，很难受）  
（%%% lhx 神仙）
```cpp
#include<bits/stdc++.h>
#define N 100005
#define MAXN 400005
#define reg register
#define inl inline
#define int long long
#define db double
using namespace std;
struct Complex
{
	db x,y;
	friend Complex operator + (const Complex &x,const Complex &y)
	{
		return ((Complex){x.x+y.x,x.y+y.y});
	}
	friend Complex operator - (const Complex &x,const Complex &y)
	{
		return ((Complex){x.x-y.x,x.y-y.y});
	}
	friend Complex operator * (const Complex &x,const Complex &y)
	{
		return ((Complex){x.x*y.x-x.y*y.y,x.x*y.y+x.y*y.x});
	}
}f[MAXN],g[MAXN];
const db Pi=acos(-1.0);
int n,m,lim,maxn,rev[MAXN],a[N],b[N];
inl void FFT(reg Complex *A,reg int opt)
{
	for(reg int i=0;i<lim;i++) if(i<rev[i]) swap(A[i],A[rev[i]]);
	for(reg int mid=1;mid<lim;mid<<=1)
	{
		reg Complex Wn=((Complex){cos(Pi/(db)mid),(db)opt*sin(Pi/(db)mid)});
		for(reg int j=0;j<lim;j+=(mid<<1))
		{
			reg Complex W=((Complex){1,0});
			for(reg int k=0;k<mid;k++,W=W*Wn)
			{
				reg Complex x=A[j+k],y=W*A[j+k+mid];
				A[j+k]=x+y;
				A[j+k+mid]=x-y;
			}
		}
	}
}
signed main()
{
	reg int A=0,suma=0,B=0,sumb=0;
	scanf("%lld %lld",&n,&m);
	for(reg int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		A+=a[i]*a[i];
		suma+=a[i];
	}
	for(reg int i=1;i<=n;i++)
	{
		scanf("%lld",&b[i]);
		B+=b[i]*b[i];
		sumb+=b[i];
	}
	for(reg int i=1;i<=n;i++)
	{
		f[i].x=a[i];
		f[i+n].x=a[i];
		g[i].x=b[n-i+1];
	}
	lim=1;
	maxn=0;
	while(lim<=(n*3))
	{
		lim<<=1;
		maxn++;
	}
	for(reg int i=0;i<lim;i++) rev[i]=((rev[i>>1]>>1)|((i&1)<<maxn-1));
	FFT(f,1);
	FFT(g,1);
	for(reg int i=0;i<=lim;i++) f[i]=f[i]*g[i];
	FFT(f,-1);
	for(reg int i=0;i<=lim;i++) f[i].x=(int)(f[i].x/(db)lim+0.5);
	reg int Ans=1e18;
	for(reg int i=1;i<=n;i++)
	{
		for(reg int j=-m;j<=m;j++) Ans=min(Ans,A+B+j*j*n+j*(suma-sumb)*2-(int)f[i+n].x*2);
	}
	printf("%lld\n",Ans);
	return 0;
}
```

---

## 作者：Ryan_ (赞：0)


式子化简一下，发现最后只跟 Σ xi*yi 有关

第二个序列反转，就可以用FFT优化

 

# 注意：

循环会想到将序列复制一遍，但只能复制一个序列，

若n=4，第一个序列为1 2 3 4,，第二个序列为5 6 7 8

只复制第一个序列，1 2 3 4 1 2 3 4

当i=5时，f[i]=2*0+1*0+4*8+3*7+2*6+1*5

如果第二个序列也复制，那么上面*0的地方将会出错





```
#include<cmath>
#include<cstdio>
#include<iostream>
#include<algorithm>

using namespace std;

const int N=(1<<18)+2;

const double pi=acos(-1);

int a[N],b[N];

struct Complex 
{
    double x,y;
    Complex(double x_=0,double y_=0):x(x_),y(y_){}
    Complex operator + (Complex P)
    {
        return Complex(x+P.x,y+P.y);
    }
    Complex operator - (Complex P)
    {
        return Complex(x-P.x,y-P.y);
    }
    Complex operator * (Complex P)
    {
        return Complex(x*P.x-y*P.y,x*P.y+y*P.x);
    }
};
typedef Complex E;

E A[N],B[N];
int rev[N];

int f[N];

void read(int &x)
{
    x=0; char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) { x=x*10+c-'0'; c=getchar(); }
}

void fft(E *a,int len,int ty)
{
    for(int i=0;i<len;++i)
        if(i<rev[i]) swap(a[i],a[rev[i]]);
    for(int i=1;i<len;i<<=1)
    {
        E wn(cos(pi/i),ty*sin(pi/i));
        for(int p=i<<1,j=0;j<len;j+=p)
        {
            E w(1,0);
            for(int k=0;k<i;++k,w=w*wn)
            {
                E x=a[j+k],y=a[j+k+i]*w;
                a[j+k]=x+y; a[j+k+i]=x-y;
            }
        }
    }
    if(ty==-1)
    {
        for(int i=0;i<len;++i) a[i].x=a[i].x/len+0.5;
    }
}

int main()
{
    int n,m;
    read(n); read(m);
    long long sum2=0,sum=0;
    for(int i=1;i<=n;++i) 
    {
        read(a[i]);
        sum+=a[i];
        sum2+=a[i]*a[i];
    }
    for(int i=1;i<=n;++i) 
    {
        read(b[i]);
        sum-=b[i];
        sum2+=b[i]*b[i];
    }
    for(int i=0;i<n;++i) A[i].x=a[i+1];
    for(int i=0;i<n;++i) A[n+i].x=a[i+1];
    for(int i=n,j=0;i;--i,++j) B[j].x=b[i];
    int num=3*n-3,len=1,bit=0;
    while(len<num) len<<=1,bit++;
    for(int i=0;i<len;++i) rev[i]=(rev[i>>1]>>1)|((i&1)<<bit-1);
    fft(A,len,1);
    fft(B,len,1);
    for(int i=0;i<len;++i) A[i]=A[i]*B[i];
    fft(A,len,-1);
    long long ab=0;
/*    ab=A[n-1].x;
    for(int i=0;i<n-1;++i) 
        ab=max(ab,(long long)A[i+n].x+(long long)A[i].x);
*/
    for(int i=0;i<n;++i) ab=max(ab,(long long)A[i+n-1].x);
    ab<<=1;
    long long mi=2e18;
    for(int c=-m;c<=m;++c) mi=min(mi,1LL*n*c*c+1LL*2*c*sum);
    cout<<sum2-ab+mi;
}
```


---

## 作者：kkxhh (赞：0)

推导可得

$ \sum_{0}^{n-1}(a_{i}-b_{i}+c)^{2} $

$ =\sum_{0}^{n-1}(a_{i}^{2}+b_{i}^{2})+nc^{2}+2c\sum_{0}^{n-1}(a_{i}-b_{i})-2\sum_{0}^{n-1}a_{i}b_{i} $

于是我们可以发现第一项是个常数，第二项和第三项一起是一个二次函数的表达式，套用公式 $ f(x)_{min}= f(-\frac{b}{2a}) $ 对 $-\frac{b}{2a}$ 四舍五入即可

那么第四项该怎么怎么处理呢

我们可以将 $a$ 数组翻转，使 $ a'_{n-1-i}=a_{i} $

我们令 $ z_{k}=\sum_{0}^{n-1}a_{i}b_{(i+k)\%n} $ 

则 $ z_{k}==\sum_{0}^{n-1}a'_{n-1-i}b_{(i+k)\%n} $

我们发现这是一个卷积的形式，实际上不需要将 $b$ 数组倍长，$z_{k}$ 的值就是运算后的第 $k-1$ 和第 $n+k-1$ 项的和（ $z_{0}$ 对应 $k==n$）。最后对所有 $z_{k}$ 取 $max$ 再从 $ans$ 中减去即可

代码如下

（数组开 $131100$ 是因为 $2^{17}=131072>100000$）

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

typedef struct complex{
    double a,b;
    complex() {}
    complex(double _a,double _b):a(_a),b(_b) {}
    complex operator + (complex x) {return complex(a+x.a,b+x.b);}
    complex operator - (complex x) {return complex(a-x.a,b-x.b);}
    complex operator * (complex x) {return complex(a*x.a-b*x.b,a*x.b+b*x.a);}
}complex;

const double Pi=acos(-1.0);
complex a[131100],b[131100];
int n,m,limit=1,r[131100],l;
double ans,c,maxs=0;

void FFT(complex *a,int type){
    for(int i=0;i<limit;i++) if(i<r[i]) swap(a[i],a[r[i]]);
    for(int len=1;len<limit;len<<=1){
        complex w(cos(Pi/len),type*sin(Pi/len));
        for(int i=0;i<limit;i+=(len<<1)){
            complex k(1.0,0);
            for(int j=0;j<len;j++,k=k*w){
                complex x=a[i+j],y=k*a[i+j+len];
                a[i+j]=x+y; a[i+j+len]=x-y;
            }
        }
    }
    if(type==-1) for(int i=0;i<limit;i++) a[i].a/=limit;
}

inline int read(){
    int num=0,k=1; char c=getchar();
    while(c>'9' || c<'0') k=(c=='-')?0:k,c=getchar();
    while(c>='0' && c<='9') num=num*10+c-'0',c=getchar();
    return k?num:-num;
}

int main(){
    n=read(),m=read();
    while(limit<=2*n) limit<<=1,l++;
    for(int i=0;i<limit;i++) r[i]=((r[i>>1]>>1)|((i&1)<<(l-1)));
    for(int i=0;i<n;i++) a[i].a=read();
    for(int i=0;i<n;i++) b[i].a=read();
    for(int i=0;i<n;i++) c+=(b[i].a-a[i].a),ans+=a[i].a*a[i].a+b[i].a*b[i].a;
    c=floor(c/n+0.5);
    for(int i=0;i<n;i++) ans+=2*c*(a[i].a-b[i].a);
    ans+=n*c*c;
    for(int i=0;n-1-i>i;i++) swap(a[i].a,a[n-1-i].a);
    FFT(a,1); FFT(b,1);
    for(int i=0;i<limit;i++) a[i]=a[i]*b[i];
    FFT(a,-1);
    for(int i=0;i<n;i++) maxs=max(maxs,a[i].a+a[i+n].a);
    ans-=2*maxs;
    printf("%.0f",ans);
    return 0;
}

```

---

## 作者：HomuraCat (赞：0)

似乎是一道法法塔(FFT)的套路题呢

我们首先考虑这个$+c$怎么处理

$$\sum_{i=1}^n(x_i-y_i+c)^2=nc^2+2c\sum_{i=1}^n(x_i-y_i)+\sum_{i=1}^n(x_i^2+y_i^2)-2\sum_{i=1}^n x_iy_i$$

显然这是一个关于$c$的二次函数，最小值取

$c=-\frac{\sum_{i=1}^n(x_i-y_i)}n$

然后发现这个展开式前面的项都很好算，就最后一项比较麻烦

我们可以把最后一项看成卷积的形式，翻转一下$b$数组，那样就可以用法法塔快速计算了

旋转操作的话就是移动$b$数列然后和$a$卷积，实现上可以把$a$数组复制一遍，然后用现在的$a$数组和$b$数组卷积，取答案中$n+1$~$2n$位的最大就行

连着爆了两次95分，原因是负小数取整需要再减1，然后c就算错了qwq，这个细节要注意的啦

```cpp
#include<bits/stdc++.h>
#define N 3000005
#define fo(i, a, b) for (R int i = (a); i <= (b); ++i)
#define in inline
#define R register
const double pi = acos(-1);
int a[N], b[N], len, len1, len2, n, m;
struct complex{
    double real, imag;
    in void conj ()
    {
        imag = -imag;
    }
    friend in complex operator * (const complex &x, const complex &y)
    {
        return (complex) {x.real * y.real - x.imag * y.imag, x.real * y.imag + x.imag * y.real};
    }
    friend in complex operator + (const complex &x, const complex &y)
    {
        return (complex) {x.real + y.real, x.imag + y.imag};
    }
    friend in complex operator - (const complex &x, const complex &y)
    {
        return (complex) {x.real - y.real, x.imag - y.imag};
    }
}c1[N], c2[N], omega[N];
in void dft(complex *c, int len)
{
    int k = 0;
    while ((1 << k) < len) ++k;
    --k;
    fo (i, 0, len)
    {
        int g = 0;
        fo (j, 0, k)
            if ((1 << j) & i) g |= (1 << k - j);
        if (i < g) std::swap(c[i], c[g]);
    }
    for (int l = 2; l <= len; l <<= 1)
    {
        int mid = l >> 1;
        for (complex *p = c; p != c + len; p += l)
            for (int i = 0; i < mid; ++i)
            {
                complex tmp = omega[len / l * i] * p[mid + i];
                p[mid + i] = p[i] - tmp;
                p[i] = p[i] + tmp;
            }
    }
}
inline long long flor (double x)
{
    if (x > 0)
        return (long long) x;
    else
        return (long long) (x - 1.0);
}
int main()
{
    scanf("%d %d", &n, &m);
    fo (i, 1, n) scanf("%d", &a[i]); 
    fo (i, 1, n) scanf("%d", &b[i]);
    long long sum = 0, c;
    long long ans = 0;
    fo (i, 1, n) sum += a[i] - b[i];
    c = flor(- 1.0 * sum / n + 0.5);
    fo (i, 1, n)
        ans += a[i] * a[i] + b[i] * b[i];
    ans += 1ll * n * c * c + 1ll * 2 * c * sum;
    std::reverse(b + 1, b + n + 1);
    fo (i, 1, n) a[i + n] = a[i];
    int len = 1;
    while (len <= n * 3) len = len << 1;
    fo (i, 1, n << 1) c1[i - 1].real = a[i];
    fo (i, 1, n) c2[i - 1].real = b[i];
    fo (i, 0, len)
        omega[i] = (complex) {cos(2 * pi * i / len), sin(2 * pi * i / len)};
    dft(c1, len);
    dft(c2, len);
    fo (i, 0, len)
        c1[i] = c1[i] * c2[i];
    fo (i, 0, len)
        omega[i].conj();
    dft(c1, len);
    sum = 0;
    fo (i, n - 1, 2 * n - 1)
        sum = std::max(sum, (long long) ((c1[i].real + 0.5) / len));
    printf("%lld", ans - sum * 2);
}
```

---

## 作者：xryjr233 (赞：0)

设第一个串为$a$,第二个串为$b$。 

不妨让我们的所有操作对$b$进行。

如果我们将$b$逆时针转动$j(0\le j<n)$个单位,那么与$a_i$对应的装饰物就是$b_{i+j}$了。

注:在本文中,数组下标从1开始。对于$b$,当数组下标大于数组长度,我们将其对数组长度取余。

我们对$b$进行了$j(0\le j<n)$次逆时针旋转,增加了$c(-m\le c\le m)$的亮度,设$ans_x$表示$j=x$时的答案,那么

$ans_j=\sum_{i=1}^n(a_i-b_{i+j}-c)^2$

$ans_j=\sum_{i=1}^n[a_i^2+b_{i+j}^2-2c(a_i-b_{i+j})-2a_ib_{i+j}+c^2]$

$ans_j=\sum_{i=1}^na_i^2+\sum_{i=1}^nb_{i+j}^2-2c(\sum_{i=1}^na_i-\sum_{i=1}^nb_{i+j})+ nc^2-2\sum_{i=1}^na_ib_{i+j}$

$ans_j=\sum_{i=1}^na_i^2+\sum_{i=1}^nb_i^2-2c(\sum_{i=1}^na_i-\sum_{i=1}^nb_i)+nc^2-2\sum_{i=1}^na_ib_{i+j}$

发现只有最后一项与$j$有关,且该项与$c$无关。

考虑求$\sum_{i=1}^na_ib_{i+j}$。

我们翻转$b$。则原式变为

$\sum_{i=1}^na_ib_{n+j-i+1}$

发现上式是卷积的形式。

这样看不明显,但是如果我们认为当$i>n$,$a_i=0$,那原式等价于

$\sum_{i=1}^{n+j}a_ib_{n+j-i+1}$

就很明显了。

所以我们设当$j=x$,原式值为$v_{n+j}$,那么我们可以用$FFT$求出$v$,由于$v_{n+j}$越大,$ans_j$越小,当$0\le j<n$,$n\le n+j<2n$,所以原式的最大值为$max_{i=n}^{2n-1}v_i$。

我们枚举$c$,即可求得其他项的答案,。

时间复杂度$O(nm\log n)$

code:

注:方便进行$FFT$,代码中下标从0开始。

code:

```cpp
#include<bits/stdc++.h>
#define VAL(x) (int)(fabs(x.re)/(N*1.0)+0.5)
using namespace std;
const int INF=2e9;
const double pi=acos(-1);
struct com{
	double re,in;
}f[300010],f1[300010],f2[300010],cpy[300010];
com operator+(const com &x,const com &y){
	return (com){x.re+y.re,x.in+y.in};
}
com operator-(const com &x,const com &y){
	return (com){x.re-y.re,x.in-y.in};
}
com operator*(const com &x,const com &y){
	return (com){x.re*y.re-x.in*y.in,x.re*y.in+x.in*y.re};
}
int n,m,N=1,a,b,a1,b1,a2,b2,mx;
long long ans=INF;
void FFT(com *f,int l,int len,int op){
	if(len<2)return;
	int nl=len>>1,tmp=l-1;
	for(int i=l;i<l+len;++i)cpy[i]=f[i];
	for(int i=l;i<l+nl;++i)f[i]=cpy[++tmp],f[i+nl]=cpy[++tmp];
	FFT(f,l,nl,op),FFT(f,l+nl,nl,op);
	com w=(com){cos(pi/(1.0*nl)),sin(pi/(1.0*nl)*op)},nw=(com){1,0},t;
	for(int i=l;i<l+nl;++i,nw=nw*w)t=nw*f[i+nl],cpy[i]=f[i]+t,cpy[i+nl]=f[i]-t;
	for(int i=l;i<l+len;++i)f[i]=cpy[i];
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)scanf("%d",&a),f1[i-1]=(com){a,0},a1+=a,a2+=a*a;//len(f1)=n
	for(int i=1;i<=n;++i)scanf("%d",&b),f2[n-i]=f2[n-i+n]=(com){b,0},b1+=b,b2+=b*b;//len(f2)=2n
	//len(f)=3n-1
	while(N<3*n-1)N<<=1;
	FFT(f1,0,N,1),FFT(f2,0,N,1);
	for(int i=0;i<N;++i)f[i]=f1[i]*f2[i];
	FFT(f,0,N,-1);
	//f[x]=sum(0<=i<=x)f1[i]*f2[x-i]
	for(int i=n-1;i<2*n-1;++i)mx=max(mx,VAL(f[i]));
	for(int i=-m;i<=m;++i)ans=min(ans,1ll*n*i*i+2*i*(a1-b1));
	printf("%lld",ans+a2+b2-2*mx);
	return 0;
}
```

---

## 作者：GoldenPotato137 (赞：0)

蒟蒻博客：[QwQ](https://www.cnblogs.com/GoldenPotato/p/10296961.html)（戳我获得更好的阅读体验w）

---
# Solution

~~调得我头大，我好菜啊~~

好吧，我们来颓柿子吧：
我们可以只旋转其中一个手环。对于亮度的问题，因为可以在两个串上增加亮度，我们也可以看做是可以为负数的。


所以说，我们可以假设我们旋转$B$串，上下要加上的亮度差为$p$,可以直接拍出一个最暴力的柿子：
设$f(x)$表示$B$串以$x$为开头的差异值，有：
$f(x)=\sum_{i=0}^{x-1}(B[i]-A[i+n-x]+p)^2+\sum_{i=x}^{n-1}(B[i]-A[i-x]+p)^2$

大力展开化简后有：
$f(x)=\sum_{i=0}^{n-1}A[i]^2+\sum_{i=0}^{n-1}B[i]^2+n*p^2-2p\sum_{i=0}^{n-1}(A[i]-B[i])-2\sum_{i=0}^{x-1}(B[i]*A[i+n-x])-2\sum_{i=x}^{n-1}(B[i]*A[i-x])$

前两项$\sum_{i=0}^{n-1}A[i]^2+\sum_{i=0}^{n-1}B[i]^2$显然$O(n)$预处理出来

中间两项$n*p^2-2p\sum_{i=0}^{n-1}(A[i]-B[i])$是一个关于$p$的二次函数，我们找最小值就好。（因为这题$m$非常小，我们也可以暴力枚举），复杂度$O(1)$或$O(m)$。

最后两项$-2\sum_{i=0}^{x-1}(B[i]*A[i+n-x])-2\sum_{i=x}^{n-1}(B[i]*A[i-x])$看起来非常像卷积，但是并不是，因此我们得做点处♂理。


蒟蒻本人是这样处理的：
首先，后面那个循环范围是肯定没法卷的，因此我们先把后面的循环处理一下得：
$-2\sum_{i=0}^{x-1}(B[i]*A[i+n-x])-2\sum_{i=0}^{n-x-1}(A[i]*B[i+x])$

然后我们可以考虑把前面那项的$A$反转(这样可以处理掉$n$来方便卷积)，把后面那项的$B$反转(这样可以制造$n$与$\sum$对应)
$-2\sum_{i=0}^{x-1}(B[i]*A'[x-1-i])-2\sum_{i=0}^{n-x-1}(A[i]*B'[n-1-i-x])$


哦豁，卷积，搞定。

时间复杂度$O(n*logn)$

---
# Code

~~我什么时候才能一次性写对FFT啊~~
```cpp
//Luogu P3723 [AH2017/HNOI2017]礼物
//Jan,20th,2019
//颓柿子+FFT加速计算
#include<iostream>
#include<cstdio>
#include<cmath>
#include<complex>
#include<algorithm>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int M=50000+100;
const int N=M*4;
const double PI=acos(-1);
typedef complex <double> cp;
inline cp omega(int K,int n)
{
	return cp(cos(2*PI*K/n),sin(2*PI*K/n));
}
void FFT(cp a[],int n,bool type)
{
	static int tmp[N],num=n-1,len=0;
	while(num!=0) num/=2,len++;
	for(int i=0,j;i<=n;i++)
	{
		for(j=0,num=i;j<len;j++)
			tmp[j]=num%2,num/=2;
		reverse(tmp,tmp+len);
		for(j=0,num=0;j<len;j++)
			num+=tmp[j]*(1<<j);
		if(i<num) swap(a[i],a[num]);
	}
	for(int l=2;l<=n;l*=2)
	{
		cp x0=omega(1,l);
		if(type==true) x0=conj(x0);
		int m=l/2;
		for(int j=0;j<n;j+=l)
		{
			cp x(1,0);
			for(int k=0;k<m;k++,x*=x0)
			{
				cp temp=x*a[j+k+m];
				a[j+k+m]=a[j+k]-temp;
				a[j+k]=a[j+k]+temp;
			}
		}
	}
}
int n,m,a[N],b[N];
cp B1[N],A1[N],B2[N],A2[N];
long long ans;
int main()
{
	freopen("3723.in","r",stdin);
	
	n=read(),m=read();
	for(int i=0;i<n;i++)
		a[i]=read();
	for(int i=0;i<n;i++)
		b[i]=read();
	
	long long dif=0;
	for(int i=0;i<n;i++)
		ans+=a[i]*a[i]+b[i]*b[i],dif+=a[i]-b[i];
	long long t_ans=0x3f3f3f3f*0x3f3f3f3f;
	for(int i=-m;i<=m;i++)
		t_ans=min(t_ans,n*i*i-2*i*dif);
	ans+=t_ans;
	
	int t=1;
	while(t<2*n) t*=2;
	reverse(a,a+n);
	for(int i=0;i<n;i++)
		A1[i]=a[i],B1[i]=b[i];
	FFT(A1,t,false);
	FFT(B1,t,false);
	for(int i=0;i<t;i++)
		A1[i]*=B1[i];
	FFT(A1,t,true);
	for(int i=0;i<t;i++)
		A1[i].real()/=t;
		
	reverse(a,a+n);
	reverse(b,b+n);
	for(int i=0;i<n;i++)
		A2[i]=a[i],B2[i]=b[i];
	FFT(A2,t,false);
	FFT(B2,t,false);
	for(int i=0;i<t;i++)
		A2[i]*=B2[i];
	FFT(A2,t,true);
	for(int i=0;i<t;i++)
		A2[i].real()/=t;
	
	t_ans=(long long)(2*floor(A2[n-1].real()+0.5));
	for(int i=1;i<n;i++)
		t_ans=max(t_ans,(long long)(2*floor(A1[i-1].real()+A2[n-i-1].real()+0.5)));
	ans-=t_ans;
	printf("%lld",ans);
	return 0;
}

```









---

## 作者：tiandong123 (赞：0)

~~第一次自己做出的fft题目，开心~~

题意:求$\sum^{n}_{i=1}(xi-yi)^2$的最大值，可以让$x$或$y$整体加上一个数或者把一个数列向左转一位。

一个显然的结论，如果两个数列同时操作的话，那么等同于对一个数列操作。所以我们默认用$x$操作

假设，我们现在把$x$数列加上了$a$，那么原式＝$\sum^{n}_{i=1}(xi-yi+a)^2$其中$a$是任意整数。

然后暴力展开

下面的$\sum$均表示$\sum^{n}_{i=1}$

原式=$\sum{xi}^2+\sum{yi}^2-2*\sum{xiyi}+2a\sum{xi-yi}+\sum{a^2}$

所以，当$x$和$y$数列是确定的时候，显然$\sum{xi}^2+\sum{yi}^2$是固定的，$2a(\sum{xi}-\sum{yi})+\sum{a^2}$的最小值是固定的,就是二次函数的对称轴。

那么问题就转化成了求$\sum{xiyi}$的最大值

因为数列可以左移，所以我们考虑把数列倍长。

那么我们的问题就变成了求$min(\sum_{i=1+j}^{1+j+n})(j\in[0,n])$

考虑匹配的每一位的下标的和相等，所以我们要把这个倍长数列翻转，为了让它满足$fft$的形式。（$fft$翻转例题[戳这里](https://www.luogu.org/problemnew/show/P4173))

代码如下

```
#include<bits/stdc++.h>
using namespace std;
#define maxn 400008*2
int l=1,tmp=0;
int n,m;
struct c{
    double r,i;
    c (){}
    c (double rr,double ii){r=rr,i=ii;}
    c operator + (const c &x){return c(r+x.r,i+x.i);}
    c operator - (const c &x){return c(r-x.r,i-x.i);}
    c operator * (const c &x){return c(r*x.r-i*x.i,r*x.i+i*x.r);}
    c operator / (const int &x){return c(r/x,i/x);}
};
c w[maxn];
int r[maxn];
c x[maxn];
c y[maxn];
int sum_x=0;
int sum_y=0;
int sum_x_2=0;
int sum_y_2=0;
int ans=0;
const double pi=3.1415926535;
void init(int tmp){
    for(int i=0;i<l;i++){
        w[i]=c(cos(2.0*pi*i/l),sin(2.0*pi*i/l));
        r[i]=(r[i>>1]>>1)|((i&1)<<(tmp-1));
    }
}
void FFT(c a[],int type){
    for(int i=0;i<l;i++)if(i>r[i])swap(a[i],a[r[i]]);
    for(int len=1,t=l>>1;len<l;len<<=1,t>>=1){
        for(int i=0;i<l;i+=(len<<1)){
            for(int j=0;j<len;j++){
                c ww=w[t*j];
                ww.i*=type;
                c x=a[i+j];
                c y=a[i+j+len]*ww;
                a[i+j]=x+y;
                a[i+j+len]=x-y;
            }
        }
    }
    if(type==-1)for(int i=0;i<l;i++)a[i]=a[i]/l;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++){
        scanf("%lf",&x[i].r);
        sum_x+=x[i].r;
        sum_x_2+=x[i].r*x[i].r;
    }
    for(int i=0;i<n;i++){
        scanf("%lf",&y[i].r);
        sum_y+=y[i].r;
        sum_y_2+=y[i].r*y[i].r;
    }
    double delta=sum_x-sum_y;
    ans+=sum_x_2+sum_y_2;
    int a=round(-delta/(double)n);
    ans+=a*delta*2+n*a*a;
    for(int i=0;i<n/2;i++)swap(y[i],y[n-i-1]);
    for(int i=n;i<n+n;i++)y[i]=y[i-n];
    int A=n,B=2*n;
    tmp=0,l=1;
    for(;l<A+B;l<<=1,tmp++);
    init(tmp);
    FFT(x,1),FFT(y,1);
    for(int i=0;i<l;i++)x[i]=x[i]*y[i];
    FFT(x,-1);
    int MIN=0;
    for(int i=n-1;i<3*n;i++)MIN=max(MIN,int(x[i].r+0.5));
    ans-=MIN*2;
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：何俞均 (赞：0)

广告：食用[$blog$](https://www.cnblogs.com/heyujun/p/10334711.html)体验更佳

首先我们将$c$看作一个可以为负的整数，那么我们就可以省去讨论在哪个手环加$c$的繁琐步骤了

设我们当前已经选好了手环的顺序

则
$$Ans=\sum_{i=1}^n(x_i-y_i+c)^2$$
$$=\sum_{i=1}^nx_i^2+\sum_{i=1}^ny_i^2+n*c^2+2c\sum_{i=1}^n(x_i-y_i)-2\sum_{i=1}^nx_i*y_i$$

实际上，因为前面都是定值($C$的取值可以枚举)，所以要求

$$\sum_{i=1}^nx_i*y_i$$

最大就行了。

我们将$y_i$反向，那么原式就是一个卷积。

这里有个很巧妙的$trick$：将$y$再倍长一下，取$x*y$中第$n+1$到$2n$项的最小值即可，这样

就很巧妙地模拟了翻转的过程

代码

```cpp
#include <iostream> 
#include <cstdio> 
#include <cstdlib> 
#include <cstring> 
#include <cmath> 
#include <algorithm> 
using namespace std; 
inline int gi() {
	register int data = 0, w = 1;
	register char ch = 0;
	while (!isdigit(ch) && ch != '-') ch = getchar(); 
	if (ch == '-') w = -1, ch = getchar();
	while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar();
	return w * data; 
}
const double PI = acos(-1.0);
const int MAX_N = 2000005; 
struct Complex { double x, y; } a[MAX_N], b[MAX_N]; 
inline Complex operator + (const Complex &l, const Complex &r) { return (Complex){l.x + r.x, l.y + r.y}; }
inline Complex operator - (const Complex &l, const Complex &r) { return (Complex){l.x - r.x, l.y - r.y}; }
inline Complex operator * (const Complex &l, const Complex &r) { return (Complex){l.x * r.x - l.y * r.y, l.y * r.x + l.x * r.y}; } 
int n, m, N, M, s1[MAX_N], s2[MAX_N], r[MAX_N], res[MAX_N]; 
void FFT(Complex *p, int op) { 
	for (int i = 0; i < N; i++) if (i < r[i]) swap(p[i], p[r[i]]); 
	for (int i = 1; i < N; i <<= 1) {
		Complex rot = (Complex){cos(PI / i), op * sin(PI / i)};
		for (int tmp = i << 1, j = 0; j < N; j += tmp) { 
			Complex w = (Complex){1, 0}; 
			for (int k = 0; k < i; k++, w = w * rot) { 
				Complex x = p[j + k], y = w * p[i + j + k]; 
				p[j + k] = x + y, p[i + j + k] = x - y; 
			} 
		} 
	} 
} 
void Prepare () { 
	N = n - 1, M = n + n - 1; 
	for (int i = 0; i <= N; i++) a[i].x = s1[i + 1]; 
	for (int i = 0; i < n; i++) b[i].x = s2[n - i]; 
	for (int i = 0; i < n; i++) b[i + n] = b[i];
	int P = 0; 
	for (M += N, N = 1; N <= M; N <<= 1, ++P) ; 
	for (int i = 0; i < N; i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (P - 1)); 
	FFT(a, 1), FFT(b, 1); 
	for (int i = 0; i < N; i++) a[i] = a[i] * b[i]; 
	FFT(a, -1); 
	for (int i = 0; i <= M; i++) res[i] = (int)(a[i].x / N + 0.5); 
} 
int main () {
	n = gi(), m = gi(); 
	for (int i = 1; i <= n; i++) s1[i] = gi(); 
	for (int i = 1; i <= n; i++) s2[i] = gi(); 
	Prepare(); 
	int p1 = 0, p2 = 0, ans = 1e9, tmp1 = 0, tmp2 = 0, tt = -1e9;
	for (int i = 1; i <= n; i++) p1 += s1[i] * s1[i], p2 += s2[i] * s2[i], tmp1 += s1[i], tmp2 += s2[i]; 
	for (int i = n - 1; i < n + n; i++) tt = max(tt, res[i]); 
	for (int C = -m; C <= m; C++) {
		int tot = p1 + p2 + n * C * C + 2 * C * (tmp1 - tmp2) - 2 * tt; 
		ans = min(tot, ans); 
	} 
	printf("%d\n", ans); 
	return 0; 
} 
```

---

## 作者：xyz32768 (赞：0)

可以想到，先旋转到最优方案，再枚举亮度。

而关键在于怎样求旋转到的最优方案。

把差异值的式子展开得到：

$\sum_{i=1}^n(x_i-y_i)^2=\sum_{i=1}^n(x_i^2+y_i^2)-2\sum_{i=1}^nx_iy_i$。

所以目标就是让$\sum_{i=1}^nx_iy_i$最大。

此时可以发现，如果旋转第一个环之后第一个环的第$1$个是原来第一个环的第$k$个，那么容易得出此时的差异值为：

$\sum_{i=1}^{n-k+1}x_{k+i-1}y_i+\sum_{i=1}^{k-1}x_iy_{n-k+i+1}$。

如果分别把第一个环和第二个环翻转，并把环看作多项式，那么可以发现$\sum_{i=1}^{n-k+1}x_{k+i-1}y_i$和$\sum_{i=1}^{k-1}x_iy_{n-k+i+1}$都是两个多项式的乘积中一个系数的值，这个可以做两遍FFT求出。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <bits/stdc++.h> 
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
typedef complex<double> cyx;
const int N = 2e5 + 5, INF = 0x3f3f3f3f; const double pi = acos(-1.0);
int n, m, a[N], b[N], rev[N], lef[N], rig[N], ff, tmp[N];
cyx A[N], B[N];
void FFT(int n, cyx *y, int op) {
    int i, j, k;
    for (i = 0; i < n; i++) if (i < rev[i]) swap(y[i], y[rev[i]]);
    for (k = 1; k < n; k <<= 1) {
        cyx x(cos(pi / k), op * sin(pi / k));
        for (i = 0; i < n; i += (k << 1)) {
            cyx w(1, 0);
            for (j = 0; j < k; j++) {
                cyx u = y[i + j], v = w * y[i + j + k];
                y[i + j] = u + v; y[i + j + k] = u - v;
                w = w * x;
            }
        }
    }
}
void solve() {
    int i, tot = 0; ff = 1;
    while (ff <= (n << 1) - 2) ff <<= 1, tot++;
    memset(rev, 0, sizeof(rev));
    for (i = 0; i <= ff; i++)
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << tot - 1);
    FFT(ff, A, 1); FFT(ff, B, 1); for (i = 0; i <= ff; i++)
        A[i] = A[i] * B[i]; FFT(ff, A, -1);
}
int main() {
    int i, sum = 0, pos = 0, now = INF, ans = INF, sm = 0;
    n = read(); m = read(); for (i = 1; i <= n; i++) a[i] = read(),
    sum += a[i] * a[i]; for (i = 1; i <= n; i++) b[i] = read(),
    sum += b[i] * b[i]; for (i = 0; i < n; i++) A[i] = a[n - i],
    B[i] = b[i + 1]; solve(); for (i = 1; i <= n; i++)
        rig[i] = ((int) (A[n - i].real() / ff + 0.5));
    for (i = 0; i <= ff; i++) A[i] = B[i] = 0;
    for (i = 0; i < n; i++) A[i] = a[i + 1], B[i] = b[n - i];
    solve(); for (i = 1; i <= n; i++)
        lef[i] = ((int) (A[i - 1].real() / ff + 0.5));
    for (i = 1; i <= n; i++) {
        int x = sum - (lef[i - 1] + rig[i] << 1);
        if (x < now) now = x, pos = i;
    }
    if (pos > 1) {
        for (i = pos; i <= n; i++) tmp[i] = a[i];
        for (i = n; i >= n - pos + 2; i--) a[i] = a[i - n + pos - 1];
        for (i = pos; i <= n; i++) a[i - pos + 1] = tmp[i];
    }
    for (i = 1; i <= n; i++) sm += a[i] - b[i];
    for (i = -100; i <= 100; i++)
        ans = min(ans, now + n * i * i + 2 * sm * i);
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：DZYO (赞：0)

From:DZYO的博客<http://blog.csdn.net/qq\_35649707/article/details/78076863>


题意:

给两个序列$a_i,b_i$,可以对b序列进行右移或者整体加减$c$,最小化$$\sum_i(x_i-y_i-c_i)^2$$.


题解:

标准FFT裸题,真不敢相信这是T3的题..


首先对原式展开,得:

$$\sum\_i x\_i^2+

\sum\_iy\_i^2+n\*c^2-2\*c(x\_i-y\_i)-\sum\_i2x\_iy\_i$$


然后有一堆常数,问题转化为求$2x_iy_i$最小,把$y$数组反过来,直接FFT即可.

最后直接二次函数最小值.注意有一点坑的是这个极值不一定在整数域取得,所以要取相邻两三个点算一算取最小值.

Code:http://paste.ubuntu.com/25605289/



---

## 作者：Tyw_ei (赞：0)

我的题解：


1.首先这个题肯定要卷积，因为很裸的多项式乘法


2.然后就是推推公式，因为有n种对位方式，所以肯定少不了n的枚举


3.就是在把公式展开后，会发现有几项和题目中的c没有关系，然后直接对c枚举，可以找到最合适的c


4.然后卷积就FFT搞搞

![](https://latex.codecogs.com/gif.latex?%5Csum\_%7Bi%3D1%7D%5E%7Bn%7D%28X\_%7Bi%7D-Y\_%7Bi&plus;x%7D%29%5E2);

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream> 
#include <complex>
#define pi 3.14159265358979
#define INF 2147483647
#define CD complex<double>
using namespace std;

int sa,m,s,bit,mini,suma,sumb,rev[500100];
CD a[500010],b[500010];

int read(){
    int rtn=0;char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch))rtn=rtn*10+ch-'0',ch=getchar();
    return rtn;
}

void get_rev(){
     for(int i=0;i<(1<<bit);i++)
         rev[i]=(rev[i>>1]>>1)|((i&1)<<(bit-1));
}

void FFT(CD *A,int n,int dft){
    for(int i=0;i<n;i++)if(i<rev[i])swap(A[i],A[rev[i]]);
    for(int step=1;step<n;step<<=1){
        CD dx=exp(CD(0,dft*pi/step));
        for(int j=0;j<n;j+=step<<1){
            CD x(1,0);
            for(int k=j;k<j+step;k++){
                CD p1=A[k];
                CD p2=x*A[k+step];
                A[k]=p1+p2;
                A[k+step]=p1-p2;
                x*=dx;
            }
        }
    }
    if(dft==-1)for(int i=0;i<n;i++)A[i]/=n;
}

int main()
{
    scanf("%d%d",&sa,&m);
    for(int i=0;i<sa;i++)a[i]=read(),suma+=a[i].real()*a[i].real(),sumb+=a[i].real();
    for(int i=0;i<sa;i++)b[sa-i-1]=read(),suma+=b[sa-i-1].real()*b[sa-i-1].real(),sumb-=b[sa-i-1].real();
    s=2,bit=1;
    while(s<2*sa-1)s<<=1,bit++;
    get_rev();
    FFT(a,s,1);
    FFT(b,s,1);
    for(int i=0;i<s;i++)a[i]*=b[i];
    FFT(a,s,-1);
    for(int i=0;i<sa-1;i++)a[i]+=a[i+sa];
    int compare=INF,ans=INF;
    for(int i=-m;i<=m;i++)
        if(suma+sumb*2*i+i*i*sa<compare)compare=suma+sumb*2*i+i*i*sa;
    for(int i=0;i<sa;i++){
        ans=min(ans,compare-2*((int)(a[i].real()+0.5)));
    }
    printf("%d",ans);
    return 0;
}
```

---


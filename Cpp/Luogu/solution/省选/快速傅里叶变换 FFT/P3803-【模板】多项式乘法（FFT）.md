# 【模板】多项式乘法（FFT）

## 题目背景

这是一道多项式乘法模板题。

注意：本题并不属于中国计算机学会划定的提高组知识点考察范围。

## 题目描述

给定一个 $n$ 次多项式 $F(x)$，和一个 $m$ 次多项式 $G(x)$。

请求出 $F(x)$ 和 $G(x)$ 的乘积。

## 说明/提示

保证输入中的系数大于等于 $0$ 且小于等于 $9$。

对于 $100\%$ 的数据：$1 \le n, m \leq {10}^6$。

## 样例 #1

### 输入

```
1 2
1 2
1 2 1```

### 输出

```
1 4 5 2```

# 题解

## 作者：attack (赞：527)

# [更好的阅读体验点这里](http://www.cnblogs.com/zwfymqz/p/8244902.html)




# 多项式

## 系数表示法

设$A(x)$表示一个$n-1$次多项式

则$A(x)=\sum_{i=0}^{n} a_i * x^i$

例如：$A(3)=2+3*x+x^2$

利用这种方法计算多项式乘法复杂度为$O(n^2)$

（第一个多项式中每个系数都需要与第二个多项式的每个系数相乘）

## 点值表示法

将$n$互不相同的$x$带入多项式，会得到$n$个不同的取值$y$

则该多项式被这$n$个点$(x_1,y_1),(x_2,y_2),\dots,(x_n,y_n)$唯一确定

其中$y_i=\sum_{j=0}^{n-1} a_j*x_i^j$

例如：上面的例子用点值表示法可以为$(0,2),(1,5),(2,12)$

利用这种方法计算多项式乘法的时间复杂度仍然为$O(n^2)$

（选点$O(n)$，每次计算$O(n)$）

 

我们可以看到，两种方法的时间复杂度都为$O(n^2)$，我们考虑对其进行优化

对于第一种方法，由于每个点的系数都是固定的，想要优化比较困难

对于第二种方法，貌似也没有什么好的优化方法，不过当你看完下面的知识，或许就不这么想了

 

#　复数

在介绍复数之前，首先介绍一些可能会用到的东西

## 向量

同时具有大小和方向的量

在几何中通常用带有箭头的线段表示

## 圆的弧度制

等于半径长的圆弧所对的圆心角叫做1弧度的角，用符号rad表示，读作弧度。用弧度作单位来度量角的制度叫做弧度制

公式:

$1^{\circ }=\dfrac{\pi}{180}rad$

$180^{\circ }=\pi rad$

## 平行四边形定则

平行四边形定则：AB+AD=AC

## 复数

### 定义

设$a,b$为实数，$i^2=-1$，形如$a+bi$的数叫负数，其中$i$被称为虚数单位，复数域是目前已知最大的域

在复平面中，$x$代表实数，$y$轴（除原点外的点）代表虚数，从原点$(0,0)$到$(a,b)$的向量表示复数$a+bi$

模长：从原点$(0,0)$到点$(a,b)$的距离，即$\sqrt{a^2+b^2}$

幅角：假设以逆时针为正方向，从$x$轴正半轴到已知向量的转角的有向角叫做幅角

### 运算法则

加法：

因为在复平面中，复数可以被表示为向量，因此复数的加法与向量的加法相同，都满足平行四边形定则（就是上面那个）

乘法：

几何定义：复数相乘，模长相乘，幅角相加

代数定义：$$(a+bi)*(c+di)$$

$$=ac+adi+bci+bdi^2$$

$$=ac+adi+bci-bd$$

$$=(ac-bd)+(bc+ad)i$$

 

单位根

下文中，默认$n$为$2$的正整数次幂

在复平面上，以原点为圆心，$1$为半径作圆，所得的圆叫单位圆。以圆点为起点，圆的$n$等分点为终点，做$n$个向量，设幅角为正且最小的向量对应的复数为$\omega_n$，称为$n$次单位根。

根据复数乘法的运算法则，其余$n-1$个复数为$\omega_n^2,\omega_n^3,\ldots,\omega_n^n$

注意$\omega_n^0=\omega_n^n=1$（对应复平面上以$x$轴为正方向的向量）

那么如何计算它们的值呢？这个问题可以由欧拉公式解决$$\omega_{n}^{k}=\cos\ k *\frac{2\pi}{n}+i\sin k*\frac{2\pi}{n}$$

 

单位根的幅角为周角的$\dfrac{1}{n}$

在代数中，若$z^n=1$，我们把$z$称为$n$次单位根

单位根的性质

$\omega _{n}^{k}=\cos k\dfrac{2\pi}{n}+i\sin k\dfrac {2\pi }{n}$（即上面的公式）
$\omega _{2n}^{2k}=\omega _{n}^{k}$
证明：

$$\omega _{2n}^{2k}=\cos 2k*\frac{2\pi}{2n}+i\sin2k*\frac{2\pi}{2n}$$

$$=\omega _{n}^{k}$$

$\omega _{n}^{k+\frac{n}{2}}=-\omega _{n}^{k}$
$$\omega _{n}^{\frac{n}{2}}=\cos\frac{n}{2}*\frac{2\pi}{n}+i\sin\frac{n}{2}*\frac{2\pi}{n}$$

$$=\cos \pi+i\sin\pi$$

$$=-1$$

$\omega _{n}^{0}=\omega _{n}^{n}=1$
 讲了这么多，貌似跟我们的正题没啥关系啊。。

 OK！各位坐稳了，前方高能！

# 快速傅里叶变换

我们前面提到过，一个$n$次多项式可以被$n$个点唯一确定。

那么我们可以把单位根的$0$到$n-1$次幂带入，这样也可以把这个多项式确定出来。但是这样仍然是$O(n^2)$的呀！

我们设多项式$A(x)$的系数为$(a_o,a_1,a_2,\ldots,a_{n-1})$

那么$$A(x)=a_0+a_1*x+a_2*{x^2}+a_3*{x^3}+a_4*{x^4}+a_5*{x^5}+ \dots+a_{n-2}*x^{n-2}+a_{n-1}*x^{n-1}$$

将其下标按照奇偶性分类

$$A(x)=(a_0+a_2*{x^2}+a_4*{x^4}+\dots+a_{n-2}*x^{n-2})+(a_1*x+a_3*{x^3}+a_5*{x^5}+ \dots+a_{n-1}*x^{n-1})$$

设

 

$$A_1(x)=a_0+a_2*{x}+a_4*{x^2}+\dots+a_{n-2}*x^{\frac{n}{2}-1}$$

$$A_2(x)=a_1*x+a_3*{x}+a_5*{x^2}+ \dots+a_{n-1}*x^{\frac{n}{2}-1}$$

那么不难得到

$$A(x)=A_1(x^2)+xA_2(x^2)$$

我们将$\omega_n^k (k<\frac{n}{2}) $代入得

$$A(\omega_n^k)=A_1(\omega_n^{2k})+\omega_n^kA_2(\omega_n^{2k})$$

$$=A_1(\omega_{\frac{n}{2}}^{k})+\omega_n^kA_2(\omega_{\frac{n}{2}}^{k})$$

同理，将$\omega_n^{k+\frac{n}{2}}$代入得

$$A(\omega_n^{k+\frac{n}{2}})=A_1(\omega_n^{2k+n})+\omega_n^{k+\frac{n}{2}}(\omega_n^{2k+n})$$

$$=A_1(\omega_n^{2k}*\omega_n^n)-\omega_n^kA_2(\omega_n^{2k}*\omega_n^n)$$

$$=A_1(\omega_n^{2k})-\omega_n^kA_2(\omega_n^{2k})$$

 

大家有没有发现什么规律？

没错！这两个式子只有一个常数项不同！

那么当我们在枚举第一个式子的时候，我们可以$O(1)$的得到第二个式子的值

又因为第一个式子的$k$在取遍$[0,\frac{n}{2}-1]$时，$k+\frac{n}{2}$取遍了$[\frac{n}{2},n-1]$

所以我们将原来的问题缩小了一半！

而缩小后的问题仍然满足原问题的性质，所以我们可以递归的去搞这件事情！

直到多项式仅剩一个常数项，这时候我们直接返回就好啦

 

## 时间复杂度：

不难看出FFT是类似于线段树一样的分治算法。

因此它的时间复杂度为$O(nlogn)$

 

# 快速傅里叶逆变换

不要以为FFT到这里就结束了。

我们上面的讨论是基于点值表示法的。

但是在平常的学习和研究中很少用点值表示法来表示一个多项式。

所以我们要考虑如何把点值表示法转换为系数表示法，这个过程叫做傅里叶逆变换

 

$(y_0,y_1,y_2,\dots,y_{n-1})$为$(a_0,a_1,a_2,\dots,a_{n-1})$的傅里叶变换（即点值表示）

设有另一个向量$(c_0,c_1,c_2,\dots,c_{n-1})$满足

$$c_k=\sum_{i=0}^{n-1}y_i(\omega_n^{-k})^i$$

即多项式$B(x)=y_0,y_1x,y_2x^2,\dots,y_{n-1}x^{n-1}$在$\omega_n^{0},\omega_n^{-1},\omega_n^{-2},\dots,\omega_{n-1}^{-(n-1)}$处的点值表示

emmmm又到推公式时间啦

$(c_0,c_1,c_2,\dots,c_{n-1})$满足
$$c_k=\sum_{i=0}^{n-1}y_i(\omega_n^{-k})^i$$

$$=\sum_{i=0}^{n-1}(\sum_{j=0}^{n-1}a_j(\omega_n^i)^j)(\omega_n^{-k})^i$$

$$=\sum_{i=0}^{n-1}(\sum_{j=0}^{n-1}a_j(\omega_n^j)^i)(\omega_n^{-k})^i$$

$$=\sum_{i=0}^{n-1}(\sum_{j=0}^{n-1}a_j(\omega_n^j)^i(\omega_n^{-k})^i)$$

$$=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_j(\omega_n^j)^i(\omega_n^{-k})^i$$

$$=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_j(\omega_n^{j-k})^i$$

$$=\sum_{j=0}^{n-1}a_j(\sum_{i=0}^{n-1}(\omega_n^{j-k})^i)$$

 

设$S(x)=\sum_{i=0}^{n-1}x^i$

将$\omega_n^k$代入得

$$S(\omega_n^k)=1+(\omega_n^k)+(\omega_n^k)^2+\dots(\omega_n^k)^{n-1}$$

当$k!=0$时

等式两边同乘$\omega_n^k$得

$$\omega_n^kS(\omega_n^k)=\omega_n^k+(\omega_n^k)^2+(\omega_n^k)^3+\dots(\omega_n^k)^{n}$$

两式相减得

$$\omega_n^kS(\omega_n^k)-S(\omega_n^k)=(\omega_n^k)^{n}-1$$

$$S(\omega_n^k)=\frac{(\omega_n^k)^{n}-1}{\omega_n^k-1}$$

$$S(\omega_n^k)=\frac{(\omega_n^n)^{k}-1}{\omega_n^k-1}$$

$$S(\omega_n^k)=\frac{1-1}{\omega_n^k-1}$$

观察这个式子，不难看出它分母不为0，但是分子为0

因此，当$K!=0$时，$S(\omega^{k}_{n})=0$

那当$k=0$时呢？

很显然，$S(\omega^{0}_{n})=n$

 

继续考虑刚刚的式子

$$c_k=\sum_{j=0}^{n-1}a_j(\sum_{i=0}^{n-1}(\omega_n^{j-k})^i)$$
当$j!=k$时，值为$0$
当$j=k$时，值为$n$
因此，
$$c_k=na_k$$
$$a_k=\frac{c_k}{n}$$

这样我们就得到点值与系数之间的表示啦

 

# 理论总结

至此，FFT的基础理论部分就结束了。

我们来小结一下FFT是怎么成功实现的

 

首先，人们在用系数表示法研究多项式的时候遇阻

于是开始考虑能否用点值表示法优化这个东西。

然后根据复数的两条性质（这个思维跨度比较大）得到了一种分治算法。

最后又推了一波公式，找到了点值表示法与系数表示法之间转换关系。

 

emmmm

其实FFT的实现思路大概就是

系数表示法—>点值表示法—>系数表示法


 

当然，再实现的过程中还有很多技巧

我们根据代码来理解一下

 

# 递归实现

递归实现的方法比较简单。

就是按找我们上面说的过程，不断把要求的序列分成两部分，再进行合并

在c++的STL中提供了现成的complex类，但是我不建议大家用，毕竟手写也就那么几行，而且万一某个毒瘤卡STL那岂不是很ＧＧ？

 
```
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
const int MAXN=2*1e6+10;
inline int read()
{
    char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const double Pi=acos(-1.0);
struct complex
{
    double x,y;
    complex (double xx=0,double yy=0){x=xx,y=yy;}
}a[MAXN],b[MAXN];
complex operator + (complex a,complex b){ return complex(a.x+b.x , a.y+b.y);}
complex operator - (complex a,complex b){ return complex(a.x-b.x , a.y-b.y);}
complex operator * (complex a,complex b){ return complex(a.x*b.x-a.y*b.y , a.x*b.y+a.y*b.x);}//不懂的看复数的运算那部分 
void fast_fast_tle(int limit,complex *a,int type)
{
    if(limit==1) return ;//只有一个常数项
    complex a1[limit>>1],a2[limit>>1];
    for(int i=0;i<=limit;i+=2)//根据下标的奇偶性分类
        a1[i>>1]=a[i],a2[i>>1]=a[i+1];
    fast_fast_tle(limit>>1,a1,type);
    fast_fast_tle(limit>>1,a2,type);
    complex Wn=complex(cos(2.0*Pi/limit) , type*sin(2.0*Pi/limit)),w=complex(1,0);
    //Wn为单位根，w表示幂
    for(int i=0;i<(limit>>1);i++,w=w*Wn)//这里的w相当于公式中的k 
        a[i]=a1[i]+w*a2[i],
        a[i+(limit>>1)]=a1[i]-w*a2[i];//利用单位根的性质，O(1)得到另一部分 
}
int main()
{
    int N=read(),M=read();
    for(int i=0;i<=N;i++) a[i].x=read();
    for(int i=0;i<=M;i++) b[i].x=read();
    int limit=1;while(limit<=N+M) limit<<=1;
    fast_fast_tle(limit,a,1);
    fast_fast_tle(limit,b,1);
    //后面的1表示要进行的变换是什么类型
    //1表示从系数变为点值
    //-1表示从点值变为系数 
    //至于为什么这样是对的，可以参考一下c向量的推导过程， 
    for(int i=0;i<=limit;i++)
        a[i]=a[i]*b[i];
    fast_fast_tle(limit,a,-1);
    for(int i=0;i<=N+M;i++) printf("%d ",(int)(a[i].x/limit+0.5));//按照我们推倒的公式，这里还要除以n 
    return 0;
}
 
```
这里还有一个听起来很装B的优化—蝴蝶效应

观察合并的过程，w*a2[i] 这一项计算了两次，因为理论上来说复数的乘法是比较慢的，所以我们可以把这一项记出来
```
    for(int i=0;i<(limit>>1);i++,w=w*Wn)//这里的w相当于公式中的k 
    {
        complex t=w*a2[i];//蝴蝶效应
        a[i]=a1[i]+t,
        a[i+(limit>>1)]=a1[i]-t;//利用单位根的性质，O(1)得到另一部分     
    }

```



速度什么的才不是关键呢？

关键是我们AC不了啊啊啊

表着急，AC不了不代表咱们的算法不对，只能说这种实现方法太low了

下面介绍一种更高效的方法

 

# 迭代实现


观察一下原序列和反转后的序列

聪明的你有没有看出什么显而易见的性质？

没错！

我们需要求的序列实际是原序列下标的二进制反转！

因此我们对序列按照下标的奇偶性分类的过程其实是没有必要的

 

这样我们可以$O(n)$的利用某种操作得到我们要求的序列，然后不断向上合并就好了
```
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
const int MAXN=1e7+10;
inline int read()
{
    char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const double Pi=acos(-1.0);
struct complex
{
    double x,y;
    complex (double xx=0,double yy=0){x=xx,y=yy;}
}a[MAXN],b[MAXN];
complex operator + (complex a,complex b){ return complex(a.x+b.x , a.y+b.y);}
complex operator - (complex a,complex b){ return complex(a.x-b.x , a.y-b.y);}
complex operator * (complex a,complex b){ return complex(a.x*b.x-a.y*b.y , a.x*b.y+a.y*b.x);}//不懂的看复数的运算那部分 
int N,M;
int l,r[MAXN];
int limit=1;
void fast_fast_tle(complex *A,int type)
{
    for(int i=0;i<limit;i++) 
        if(i<r[i]) swap(A[i],A[r[i]]);//求出要迭代的序列 
    for(int mid=1;mid<limit;mid<<=1)//待合并区间的中点
    {
        complex Wn( cos(Pi/mid) , type*sin(Pi/mid) ); //单位根 
        for(int R=mid<<1,j=0;j<limit;j+=R)//R是区间的右端点，j表示前已经到哪个位置了 
        {
            complex w(1,0);//幂 
            for(int k=0;k<mid;k++,w=w*Wn)//枚举左半部分 
            {
                 complex x=A[j+k],y=w*A[j+mid+k];//蝴蝶效应 
                A[j+k]=x+y;
                A[j+mid+k]=x-y;
            }
        }
    }
}
int main()
{
    int N=read(),M=read();
    for(int i=0;i<=N;i++) a[i].x=read();
    for(int i=0;i<=M;i++) b[i].x=read();
    while(limit<=N+M) limit<<=1,l++;
    for(int i=0;i<limit;i++)
        r[i]= ( r[i>>1]>>1 )| ( (i&1)<<(l-1) ) ;
    // 在原序列中 i 与 i/2 的关系是 ： i可以看做是i/2的二进制上的每一位左移一位得来
    // 那么在反转后的数组中就需要右移一位，同时特殊处理一下复数 
    fast_fast_tle(a,1);
    fast_fast_tle(b,1);
    for(int i=0;i<=limit;i++) a[i]=a[i]*b[i];
    fast_fast_tle(a,-1);
    for(int i=0;i<=N+M;i++)
        printf("%d ",(int)(a[i].x/limit+0.5));
    return 0;
}
```


---

## 作者：attack (赞：181)

## [更好的阅读体验点这里](http://www.cnblogs.com/zwfymqz/p/8980809.html)



很久以前写过一篇FFT的题解

今天有幸学到了NTT—— 一种比FFT更好用的算法，来跟大家分享一下

## NTT

在FFT中，我们需要用到复数，复数虽然很神奇，但是它也有自己的局限性——需要用double类型计算，精度太低

那有没有什么东西能够代替复数且解决精度问题呢？

这个东西，叫**原根**


------------

原根的定义

> 设$m$是正整数，$a$是整数，若$a$模$m$的阶等于$\phi(m)$，则称$a$为模$m$的一个原根

定义中用到了群论的一些知识，不过不会也没关系，不影响接下来的学习

我们定义$P$为素数，$g$为$P$的原根


考虑原根为什么能代替单位根进行运算，(这部分可以跳过)

原因很简单，因为它具有和单位根相同的性质

在FFT中，我们用到了单位根的四条性质，而原根也满足这四条性质

1. 对于所有$\omega_n ^ t (0 \leq t \leq n - 1)$均不相同

不加证明的扔出一个定理

 若$P$为素数，假设一个数$g$是$P$的原根，那么$g^i \mod P (1<g<P,0<i<P)$的结果两两不同

不要问我为什么，因为我也不知道。。

2. $\omega_{2n} ^ {2k} = \omega_n ^ k$

通过代换可以得到

3. $\omega_n ^ { k + \frac{n}{2} } = -\omega_n ^ k$

根据费马小定理和性质1可以得到

4. $1 + \omega_n ^ k + (\omega_n ^ k) ^ 2 + \dots + (\omega_n ^ k) ^ {n - 1} = 0 $

由性质3和FFT中傅里叶逆变换的定理可以得到



------------


这样我们最终可以得到一个结论

$$\omega_n \equiv g^\frac{p-1}{n} \mod p$$

然后把FFT中的$\omega_n$都替换掉就好了

$p$建议取$998244353$，它的原根为$3$。

如何求任意一个质数的原根呢？

可以证明满足$g^r \equiv 1(\mod p)$的最小的$r$一定是$p-1$的约数

对于质数$p$，质因子分解$p-1$，若$g^{\frac{p-1}{p_i}} \neq 1 \pmod p$恒成立，$g$为$p$的原根



------------

NTT求卷积代码:

确实比FFT快了不少

```cpp
#include<cstdio>
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1<<21, stdin), p1 == p2) ? EOF : *p1++)
#define swap(x,y) x ^= y, y ^= x, x ^= y
#define LL long long 
const int MAXN = 3 * 1e6 + 10, P = 998244353, G = 3, Gi = 332748118; 
char buf[1<<21], *p1 = buf, *p2 = buf;
inline int read() { 
    char c = getchar(); int x = 0, f = 1;
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}
int N, M, limit = 1, L, r[MAXN];
LL a[MAXN], b[MAXN];
inline LL fastpow(LL a, LL k) {
	LL base = 1;
	while(k) {
		if(k & 1) base = (base * a ) % P;
		a = (a * a) % P;
		k >>= 1;
	}
	return base % P;
}
inline void NTT(LL *A, int type) {
	for(int i = 0; i < limit; i++) 
		if(i < r[i]) swap(A[i], A[r[i]]);
	for(int mid = 1; mid < limit; mid <<= 1) {	
		LL Wn = fastpow( type == 1 ? G : Gi , (P - 1) / (mid << 1));
		for(int j = 0; j < limit; j += (mid << 1)) {
			LL w = 1;
			for(int k = 0; k < mid; k++, w = (w * Wn) % P) {
				 int x = A[j + k], y = w * A[j + k + mid] % P;
				 A[j + k] = (x + y) % P,
				 A[j + k + mid] = (x - y + P) % P;
			}
		}
	}
}
int main() {
	N = read(); M = read();
	for(int i = 0; i <= N; i++) a[i] = (read() + P) % P;
	for(int i = 0; i <= M; i++) b[i] = (read() + P) % P;
	while(limit <= N + M) limit <<= 1, L++;
	for(int i = 0; i < limit; i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (L - 1));	
	NTT(a, 1);NTT(b, 1);	
	for(int i = 0; i < limit; i++) a[i] = (a[i] * b[i]) % P;
	NTT(a, -1);	
	LL inv = fastpow(limit, P - 2);
	for(int i = 0; i <= N + M; i++)
		printf("%d ", (a[i] * inv) % P);
	return 0;
}
```

## 参考资料

[Menci的博客](https://oi.men.ci/fft-to-ntt/)

[Candy?的博客](http://www.cnblogs.com/candy99/p/6641972.html)










---

## 作者：一扶苏一 (赞：165)

# 【多项式】FFT

## Preface

本文对所有 $\LaTeX$ 编译后生成的文本共有大约 $7000$ 字，其中前半部分为前置知识部分，介绍了多项式的有关概念、运算法则以及复数的概念、运算法则以及单位根有关内容，并证明了蝴蝶操作所用到的有关复数的两个重要引理公式。如果你对上述内容已经有了解，可以跳过 ``Pre-knowledge`` 部分。``Pre-knowledge`` 部分大约有 $2000$ 字。

本文部分 $\LaTeX$ 内容在 ``luogu`` 的题解界面显示可能比较丑陋，因此建议您点击 ``从Ta的博客查看`` 来进入我的 ``luogu`` 博客阅读下面的内容。

## Pre-knowledge

### 多项式

#### Definition

称一个关于 $x$ 的式子

$$f(x) = \sum_{i = 0}^{n} a_i \times x^i$$

为一个 $n$ 次多项式，其中 $a_i$ 为常数。称 $n$ 为 $f(x)$ 的次数。显然，$f(x)$ 可以看做一个关于 $x$ 的 $n$ 次函数 $y = f(x)$。

回忆初中解析几何最后一个大题的第一问，正常情况下都是给定三个点的坐标，求一个关于 $x$ 的二次曲线解析式方程。而类似的如果求一条直线的解析式，则需要给出两个点的坐标。

类似的，对于如果想要确定一个 $n$ 次函数的解析式，则需要 $n + 1$ 个点的坐标。这是因为一个 $n$ 次函数共有 $(n + 1)$ 个系数，根据某我忘了名字的基本定理，$n$ 元非无解方程组有唯一解的必要条件是有 $n$ 个本质不同的方程，因此这里需要 $(n + 1)$ 个点构造出 $(n + 1)$ 个方程，才能求出这 $(n + 1)$ 个系数。

也就是说，只要给定了 $(n + 1)$ 个点的坐标，就可以唯一确定一个 $n$ 次函数的解析式，进而也就可以确定这个多项式。

那么，给出 $(n + 1)$ 个互不相同的点的坐标来确定一个多项式的形式，称为多项式的**点值表示法**。对应的，写成 $f(x) = \sum_{i = 0}^{n} a_i \times x^i$ 形式的多项式被称为多项式的**系数表示法**。

### Operation

在进行多项式运算时，如果两个多项式的次数不一样，注意到关于多项式次数的定义中没有规定最高次项的系数不能为 $0$，因此可以认为次数较低的多项式的次数也为较高的次数多项式的次数。

如果使用点值表示法进行多项式运算，则必须保证两个多项式所给点值的横坐标一一对应相等。

以下设 $n$ 次多项式 $A(x) = \sum_{i = 0}^n a_i \times x^i$，$B(x) = \sum_{i = 0}^{n} b_i \times x^i$

多项式加减法：

两个 $n$ 次多项式 $A(x)$ 和 $B(x)$ 相加减的结果为

$$f(x)~ = ~A(x) \pm B(x)~ = ~\sum_{i = 0}^{n} (a_i \pm b_i) x^i$$

多项式乘法：

两个 $n$ 次多项式 $A(x)$ 和 $B(x)$ 相乘的结果是一个 $2n$ 次多项式

$$f(x)~=~A(x) \times B(x)~=~\sum_{i = 0}^n \sum_{j = 0}^n a_i \times b_j \times x^{i + j}$$

同时，上式显然可以写成这种形式

$$f(x) = \sum_{i = 0}^{2n} \sum_{j = 0}^{\min(i, n)} a_j \times b_{i - j} \times x^i$$

对于点值表示法，由于 $A(x) \pm B(x)$ 或 $A(x) \times B(x)$ 本身表示的就是两个多项式的值做加减乘法，因此直接将对应横坐标位置的纵坐标相加/减/乘即可。需要特别注意的是，做乘法时，需要 $A(x)$ 和 $B(x)$ 各给出 $2n$ 组点值，而不是 $n$ 组。

### 复数

#### Definition

定义常数 $i$，满足 

$$i^2 = -1$$

则所有形如 

$$z = a + b \times i,~~~a, b \in R$$ 

的数字 $z$ 构成的集合称为复数集，记为 $C$，$C$ 中的每个元素都称作复数。

对于 $z = a + bi$，称 $a$ 是 $z$ 的实部，$b$ 是 $z$ 的虚部

#### Geometric Interpretation

复平面是一个笛卡尔平面，有两条坐标轴，纵轴为虚轴，横轴为实轴，两轴相互垂直。

对于一个复数 $z = a + bi$，它在复平面上对应一个从原点指向 $(a,~b)$ 的向量。也即实轴坐标为实部值，虚轴坐标为虚部值的点。

显然复平面上从原点出发的任意一个向量也对应唯一的一个复数，也即向量 $(a, b)$ 对应一个复数 $z = a + bi$。

易证复数与复平面上从原点出发的向量是一一对应关系。

以实轴正方向为始边，$z$ 所对应的向量 $Z$ 为终边的角 $\theta$ 称为复数 $z$ 的幅角。

#### Operation

复数的模：

复数 $z= a + b_i$ 的模为其在复平面上对应向量的长度，记做$|z|$。

$$|z| = \sqrt{a^2 + b^2}$$

共轭复数：

复数 $z$ 在复平面上对应的向量关于实轴对称后对应的复数称为 $z$ 的共轭复数，记做 $\overline{z}$

$z$ 与 $\overline z$ 满足如下关系：

设 $z$ 的幅角为 $\theta_0$，$\overline z$ 的幅角为 $\theta_1$

$$\theta_0 + \theta_1 = \pi$$

$$|z| = |\overline z|$$

且两者的实部相同，虚部互为相反数。

复数加减法：

两个复数 $z_1 = a_1 + b_1i,~z_2 = a_2 + b_2 i$ 相加减的结果为

$$z_0~=~z_1 \pm z_2~=~(a_1 \pm a_2) + (b_1 \pm b_2)i$$

在复平面上，两个复数相加减的结果为他们所对应的向量按照平行四边形定则相加减

复数乘法：

两个复数 $z_1 = a_1 + b_1i,~z_2 = a_2 + b_2 i$ 相乘的结果为

$$z_0~=~z_1 \times z_2~=~(a_1 + b_1i) \times (a_2 + b_2i) = a_1a_2 + a_1b_2i + a_2b_1i + b_1b_2i^2$$

又因为

$$i^2 = -1$$

所以

$$z_0~=~(a_1a_2 - b_1b_2) + (a_1b_2 + a_2b_1) i$$

在复平面上，$z_1,~z_2,~z_0$ 所对应的幅角 $\theta_1,~\theta_2,~\theta_0$ 有如下关系：

$$\theta_0 = \theta_1 + \theta_2$$

他们的模有如下关系

$$|z_0| = |z_1| \times |z_2|$$

考虑 $z = a + b_i$ 和它的共轭复数 $\overline z = a - bi$

有

$$z \times \overline z~=~(a + bi) \times (a - bi) = a^2 + b^2$$

因此两个互为共轭复数的数之积一定是一个实数。

复数除法：

对于两个复数 $z_1 = a_1 + b_1i,~z_2 = a_2 + b_2 i$，他们相除的结果为

$$z_0 = \frac{z_1}{z_2}$$

考虑分数上下同时乘 $\overline{z_2}$，有

$$z_0~=~\frac{z_1 \overline {z_2}}{a_2^2 + b_2^2}$$

分母是一个实数，可以直接将分子的实部虚部除以分母。

复数指数幂：

有欧拉公式

$$e^{i\theta} = \cos \theta + i \sin \theta$$

其中 $e$ 是自然对数的底数

当取 $\theta = \pi$ 时，有

$$e^{i\pi} = \cos \pi + i \sin \pi$$

又因为 $\cos \pi = -1,~sin \pi = 0$

所以 
$$e^{i\pi} = -1$$

### 单位根

#### Definition

在复数域下，满足 $x^n = 1$ 的 $x$ 被称为 $n$ 次单位根

根据代数基本定理，$n$ 次单位根一共有 $n$ 个。

经过计算可得，将所有的 $n$ 次单位根按照幅角大小排列，第 $k$  $(0 \leq k < n)$ 个 $n$ 次单位根为 

$$x_k~=~e^{i \frac{2 k\pi}{n}}$$

#### Proof

$$x_n^k~=~e^{i 2 k\pi}$$

根据欧拉公式

$$e^{i2k\pi} = \cos 2k\pi + i \sin 2k\pi$$

又因为 

$$\cos 2k\pi = 1,~~\sin 2k\pi~=~0$$

所以 

$$x_n^k = e^{i\frac{2k\pi}{n}}$$

是原方程的一个解。

显然这 $n$ 个解是互不相同的，又根据代数基本定理，该方程有且仅有 $n$ 个解。因此该方程解的与 $x_k$ 一一对应。证毕。

#### Property

因为 $\sin^2 \theta + \cos^2 \theta~=~1$，所以所有的 $n$ 次单位根的模都是 $1$。

$n$ 个单位根在复平面上平分单位圆。他们与单位圆的 $n$ 等分线所在线段分别重合。

### 本原单位根

#### Definition

$0$ 到 $(n - 1)$ 次方的值能生成所有 $n$ 次单位根的 $n$ 次单位根称为为 $n$ 次本原单位根。

显然 $x_1 = e^{i \frac{2\pi}{n}}$ 是一个本原单位根。

证明上可以考虑利用复平面上单位根等分单位圆，且两复数相乘时幅角相加模相乘来证明，这里略去。

记 $n$ 次本原单位根为 $\omega_n = e^{i \frac{2\pi}{n}} = \cos \frac{2\pi}{n} + i \sin \frac{2\pi}{n}$。

$n$ 次本原单位根可能不止一个，但是下文的“本原单位根”特指 $e^{i \frac{2\pi}{n}}$

#### Property

设 $n$ 是一个正偶数，且 $n = 2m$，有：

$$(\omega_{n}^k)^2~=~\omega_m^k$$

$$\omega_n^{m + k}~=~-\omega_{n}^k$$

#### Proof

一式：

考虑两个 $\omega_n^k$ 相乘，幅角相加，为之前幅角的两倍，而模为 $1 \times 1 = 1$。

所以相乘的结果为一个幅角为 $\omega_n^k$ 幅角两倍的单位向量。容易验证 $\omega_m^k$ 的幅角是 $\omega_n^k$ 幅角的两倍，且模为 $1$。由于向量和复数是一一对应的，所以一式成立。

二式：

显然 $\omega_n^m$ 的幅角为 $\pi$。等式左边可以写成 $w_{n}^k \times w_n^m$，即为 $w_n^k$ 绕原点旋转 $\pi$ 弧度。根据平面解析几何定理，旋转前后的两个向量横纵坐标分别互为相反数。证毕。

**Pre-knowledge部分结束了。**

---

## Algorithm

考虑对两个多项式做乘法，如果运用系数表示法，显然需要 $O(n^2)$ 的时间复杂度，而如果已知两个多项式的点值表示法，则只需要 $O(n)$ 的时间复杂度。因为只需要将对应的点值纵坐标相乘就可以了。

但是我们将一个多项式从系数表示法改为点值表示法（称为求值）需要 $O(n^2)$ 的复杂度（因为每个横坐标都需要 $O(n)$ 的时间去计算），而将一个点值表示法改为系数表示法（称为插值）则需要 $O(n^3)$ 的复杂度来做高斯消元。但是只要我们将这两步都优化至低于 $O(n^2)$ 的复杂度，就可以得到一个比直接用系数表示法乘更优的做法。

而求出一个 $n$ 次多项式在每个 $n$ 次单位根下的点值的过程，被称为**离散傅里叶变换(Discrete Fourier Transform，DFT)**，而将这些点值重新插值成系数表示法的过程，叫做**离散傅里叶逆变换(Inverse Discrete Fourier Transform,IDFT)**。

以下设进行变换的多项式为 $(n - 1)$ 次多项式 $A(x) = \sum_{i = 0}^{n - 1} a_i \times x^i$。其中 $n$ 是 $2$ 的整数幂。如果不是的话，则向 $A(x)$ 的更高次数位 $n$ 补充 $a_n = 0$ ，令其成为 $n$ 次多项式，一直进行直到其次数+1的值是 $2$ 的整数幂，取 $n$ 等于其次数，$m = \frac{n}{2}$。

### DFT

考虑求出一个长度为 $n$ 数列 $\{b_i\}$，这个数列的第 $k$ 项为 $A(x)$ 在 $n$ 次单位根的 $k$ 次幂处的点值。

因此有 

$$b_k~=~\sum_{i = 0}^{n - 1} a_i \times \omega_{n}^i$$

注意上式中的 $i$ 为 $\Sigma$ 循环的循环变量，而不是 $-1$ 的二次方根。

这个过程是 $O(n^2)$ 的，我们考虑使用**快速傅里叶变换(Fast Fourier Transform，FFT)**来优化这个过程。

### FFT

我们考虑对 $A(x)$ 按照系数角标的奇偶性分类，即

$$A(x)~=~\sum_{i = 0}^{n - 1} a_i x^i~=~\sum_{i = 0}^m a_{2i} \times x^{2i} + \sum_{i = 0}^m a_{2i + 1} \times x^{2^i + 1}$$

对于上式的后半部分，提出一个 $x$，得到

$$A(x)~=~\sum_{i = 0}^{m - 1} a_{2i} x^{i2} + x\sum_{i = 0}^{m - 1} a_{2i + 1} x^{2i}~=~\sum_{i = 0}^{m - 1} a_{2i} (x^{2})^{i} + x\sum_{i = 0}^{m - 1} a_{2i + 1} (x^2)^{i}$$

设 $A_0(x)$ 是一个 $(m - 1)$ 次多项式，满足

$$A_0~=~\sum_{i = 0}^{m - 1} a_{2i} x^i$$

设 $A_1(x)$ 是一个 $(m - 1)$ 次多项式，满足

$$A_1~=~\sum_{i = 0}^{m - 1} a_{2i + 1}x^i$$

联立以上三式，可以得到

$$A(x)~=~A_0(x^2) + x \times A_1(x^2)$$

如果求出了 $A_0$ 和 $A_1$ 在各点的点值，由于上式可以 $O(1)$ 计算，所以我们可以 $O(n)$ 计算 $A(x)$ 在各个点的点值了。而求 $A_0$ 和 $A_1$ 的过程和求 $A$ 的过程完全一致，因此可以递归处理。

但是很遗憾，我们 $A_0$ 和 $A_1$ 各需要递归一次，根据主定理，这样的时间复杂度是 $O(n^2)$ 的。

但是考虑我们求的是在 $n$ 次单位根的各个幂次下的点值，根据 ``Pre-Knowledge`` 的最后一部分，我们得到了公式

$$(\omega_{n}^k)^2~=~\omega_m^k$$

$$\omega_n^{m + k}~=~-\omega_{n}^k$$

第二个式子使得我们考虑小于 $m$ 次的点值和大于 $m$ 次点值之间的关系。

对于 $0 \leq k < m$，我们有

$$A(\omega_n^k)~=~A_0((\omega_n^k)^2) + w_n^kA_1((\omega_n^k)^2)$$

根据上面的第一个公式，化简得到

$$A(\omega_n^k)~=~A_0(\omega_m^k) + w_n^kA_1(\omega_m^k)$$

这只是前半部分的次数，我们考虑后半部分次数：

$$A(\omega_n^{m + k})~=~A_0((\omega_n^{m + k})^2) + \omega_n^{m + k} A_1((\omega_n^{m + k})^2)$$

根据第二个公式，化简得到

$$A(\omega_n^{m + k})~=~A_0((w_n^k)^2)+-\omega_n^k A_1((\omega_n^k)^2)$$

再应用第一个公式得到

$$A(\omega_n^{m + k})~=~A_0(\omega_m^k) - w_n^kA_1(\omega_m^k)$$

我们惊喜的发现，大于 $m$ 次的点值可以由 $A_0$ 和 $A_1$ 在小于 $m$ 次的点值求出。只要求出了 $A_0$ 和 $A_1$ 在小于 $m$ 次的点值，就可以线性求出 $A$ 在整个 $n$ 次幂处的点值。而求 $A_0$ 和 $A_1$ 在小于 $m$ 次的点值也是可以递归求解的。

考虑时间复杂度：递推关系为 $T(n)~=~2T(n / 2) + O(n)$。因为 $O(n)~=~\Theta(n)$，所以 $T(n)~=~\Theta(n^{\log_2^2} \log n) = \Theta(n \log n)$。

由此，得到了快速计算 ``DFT`` 的办法，并证明了其时间复杂度为 $O(n \log n)$。这种方法被即为 ``FFT``。

上面推导出 $A(\omega_n^k)$ 和 $A(\omega_n^{m + k})$ 的值的式子被称为**蝴蝶操作(Butterfly Operation)**。这个名字的由来是如果将 $A$ 在各处的点值画成一个长条形的数组，在数组下面一次依次是 $n$ 次本原单位根的 $0 \sim m - 1$ 次幂，则求值过程可以画成 $\omega_n^0$ 连一条边向 $A(\omega_n^0),~A(\omega_n^{\frac{n}{2} - 1})$；而 $\omega_n^1$ 连向 $A(\omega_n^1),~A(\omega_n^\frac{n}{2})$，以此类推。画出的图形如同蝴蝶的翅膀。

### IDFT

至此，我们已经有了 $O(n \log n)$ 的算法来计算两个系数表示法的多项式相乘后的点值表示。接下来我们只需要用 $O(n \log n)$ 的时间复杂度完成插值的过程，就可以得到一个完整的 $O(n \log n)$ 的系数型多项式乘法算法了。

我们目前已知一个 $(n - 1)$ 次多项式 $A(x)~=~\sum_{i = 0}^{n - 1} a_i x^i$ 进行了离散傅里叶变换后的点值 $\{b_i\}$，即

$$b_k~=~\sum_{i = 0}^{n - 1} a_i \times \omega_n^{ik}$$

现在试图还原系数数列 $\{a_i\}$。

推导过程比较复杂，我们直接给出结论：

$$a_k~=~\frac{1}{n} \sum_{i = 0}^{n - 1} b_i \omega_n^{-ki}$$

下面证明上面这个式子是 ``DFT`` 式子(即上面计算 $b_k$ 的式子)的逆变换。

我们首先将 ``DFT`` 的式子带入 $\sum_{i = 0}^{n - 1} b_i \omega_n^{-ki}$

得到上式为

![qwq](https://cdn.luogu.com.cn/upload/image_hosting/6qzo0fls.png)

（这里使用截图的原因是你谷的多行公式渲染有点问题，建议查看大图）。

考虑分类讨论。

1、当 $j = k$ 时：

则 $j - k = 0$，因此 $\omega_{n}^{i(j - k)} = \omega_n^0 = 1$。于是 

$$\sum_{i = 0}^{n - 1} \omega_n^{i(j - k)}~=~n \times 1 = n$$

2、当 $j \neq k$ 时：

显然 $|j - k| < n$，因此 $\omega_n^{j - k} \neq 1$，则 $\sum_{i = 0}^{n - 1} \omega_n^{(j - k) i}$ 是一个公比不为 $1$ 的等比数列前缀和。根据等比数列求和公式得到

$$\sum_{i = 0}^{n - 1} \omega_n^{(j - k) i}~=~\frac{1 - \omega_n^{(n - 1)(j - k)} \times \omega_n^{j - k}}{1 - \omega_{n}^{j - k}}~=~\frac{1 - \omega_n^{n(j - k)}}{1 - \omega_{n}^{j - k}}~=~\frac{1 - (\omega_n^{(j - k)})^n}{1 - \omega_{n}^{j - k}}$$

根据复数的几何性质，易证对于所有的 $n$ 次单位根 $T$，$T^{x + n}~=~T^{x}$，其中 $x$ 为任意整数。

$\sum_{i = 0}^{n - 1} \omega_n^{(j - k) i}~=~\frac{1 - (\omega_n^{(j - k)})^0}{1 - \omega_{n}^{j - k}}~=~\frac{1 - 1}{1 - \omega_n^{j - k}}~=~0$

第二种情况的证明被称为**消去引理**。

综上讨论，当 $j \neq k$ 时，因为另一个因数是 $0$，前面的 $\sum a_j$ 不会对式子产生贡献，而 $j = k$ 时，会对答案产生 $n$ 倍的贡献。

原式可以写成

$$\sum_{i = 0}^{n - 1} b_i \omega_n^{-ki}~=~~\sum_{j = 0}^{n - 1} a_j \times \sum_{i = 0}^{n - 1} \omega_n^{i(j - k)}~=~\sum_{j = 0}^{n - 1} a_j \times [j = k] \times n~=~a_k \times n$$

将上式带入 ``IDFT`` 的式子 $a_k~=~\frac{1}{n} \sum_{i = 0}^{n -1} b_i \omega_n^{-ki}$ 的右边，得到

$$\text{右边}~=~\frac{1}{n} a_k \times n~=~a_k~=~\text{左边}$$

类似的，可以证明将 ``IDFT`` 的式子带入 ``DFT`` 也是可以使等式成立的，这里略去。

由此，我们证明了变换

$$a_k~=~\frac{1}{n} \sum_{i = 0}^{n - 1} b_i \omega_n^{-ki}$$

是 ``DFT`` 的逆变换，称为 ``IDFT``。我们可以通过这个式子求出这个多项式的系数表示法。

#### IFFT

下面的问题是如何用较低的复杂度计算 $B(x)~=~\sum_{i = 0}^{n - 1} b_i \times x^i$ 在 $w_n^{-ki}$，其中 $0 \leq k < n$ 处的点值。

而 $w_n^{-k}$ 可以看做 $n$ 次本原单位根每次逆时针旋转本原单位根幅角的弧度，因此 $\omega_n^{-k}$ 和 $\omega_n^k$ 是一一对应的。具体的，$w_n^{-k} = w_n^{k + n}$。因此我们只需要使用 ``FFT`` 的方法，求出 $B(x)$ 在 $\omega_n$ 各个幂次下的值，然后数组反过来，即令 $a_k~=~\frac{1}{n} \sum_{i = 0}^n B(w_n^{n - k})$ 即可。

这一步快速计算插值的过程叫做**快速傅里叶逆变换(Inverse Fast Fourier Transform，IFFT)**。

至此，我们得到了一个时间复杂度为 $O(n \log n)$ 的多项式乘法计算方法。

## Code

根据上面的推导，我们可以很轻松的写出 ``FFT`` 的递归形式：

```cpp
void FFT(std::complex<double> *A, int N) {
  if (N == 1) {
    return;
  }
  int M = N >> 1;
  std::complex<double> A0[M], A1[M];
  for (int i = 0; i < M; ++i) {
    A0[i] = A[i << 1];
    A1[i] = A[(i << 1) | 1];
  }
  FFT(A0, M); FFT(A1, M);
  auto W = std::complex<double>(cos(1.0 * PI / M), sin(1.0 * PI / M)), w = std::complex<double>(1.0, 0.0);
  for (int i = 0; i < M; ++i) {
    A[i] = A0[i] + w * A1[i];
    A[i + M] = A0[i] - w * A1[i];
    w *= W;
  }
}
```

以及 ``IFFT``：

```cpp
void IFFT(std::complex<double> *A, int N) {
  FFT(A, n)
  std::reverse(A + 1, A + N);
}
```

需要注意的是，因为 $\omega_n^0~=~\omega_n^n$，所以是第 $1$ 个点值和第 $N - 1$ 个交换，而不是第 $0$ 个点值和第 $N - 1$ 个交换。

## optimization

上面这个 ``FFT`` 交到 ``luogu`` 上以后只有 $77$ 分。他的复杂度显然是 $O(n \log n)$ 的，但是递归和动态开空间带来的巨大常数让他难以通过 $10^6$ 的数据。

我们考虑优化上面的代码。

首先我们注意到我们动态申请和删除了 $O(n \log n)$ 的空间，但是我们同一时刻只最多需要 $2N$ 的空间，而递归调用又是栈式的，即先申请的后删除。这意味着如果用一个数组做内存池，没有被分配的内存总是连续的，被分配的内存也总是连续的。并且分配一个数组可以 $O(1)$ 而不是 $O(size)$ 完成。

然而这个优化并没有什么卵用。

我们考虑将上面的递归改成迭代。

既然递归是自上而下的，那么我们的迭代就是一个自下而上的合并过程。当 $n = 8$ 时，我们考虑递归时调用原多项式系数下标的递归树：

```
step 1: 0 1 2 3 4 5 6 7
step 2: 0 2 4 6,  1 3 5 7
step 3: 0 4,  2 6,  1 3,  5 7
step 4: 0,  4,  2,  6,  1,  3,  5,  7
```

上表的 ``step`` 代表了递归的层数，冒号后的数字代表数字的下标。我们考察最后算的一层，也就是第 $4$ 层的二进制值：

```
000, 100, 010, 110, 001, 011, 101, 111
```

看起来还是没有头绪，但是我们将二进制值反过来

```
000, 001, 010, 011, 100, 110, 101, 111
```

我们发现上面 $8$ 个二进制的排列是单调递增的，在十进制下分别是

```
0, 1, 2, 3, 4, 5, 6, 7
```

因此我们只需要将数列 $\{a\}$ 按照下标二进制翻转后的大小排序，得到序列 $\{a'\}$。递归倒数第二层对于 $\{a\}$ 的蝴蝶操作就变成了对于 $\{a'\}$ 相邻两个数进行合并。而上面几层同理。

因此问题变成了如何在 $O(n \log n)$ 的时间内将序列按照下标二进制翻转后排序得到的序列。

显然对于任何一个数我们都可以 $O(\log n)$ 的运用进制转换来确定其二进制逆序值，但是这样因为涉及到了大量的除法和取模，常数很大，我们考虑规避这个做法。

我们考虑基数排序的操作，我们可以将一个数的数位分为两半，先对后半部分数位构成的数进行排序，然后再对前半部分数位构成的数进行排序。两个数字的前半部分数位如果相同，那么它们的先后顺序即为后半部分数位的先后顺序。这样由于后半部分本身是有序的，就可以自低位向高位对数列进行排序。

同样的，我们自低位向高位对每个数的二进制逆序排序。

初始时，序列里只有两个数

```
000, 100
```

他们逆序后为

```
000, 001
```

分别是最小的和次小的翻转值。

然后我们考虑将这两个数的第 $2$ 位(最右侧为最低位，最低位为第 $1$ 位)都置为 $1$，得到了两个数

```
010, 110
```

将这两个数也加入序列中，得到

```
000, 100, 010, 110
```

翻转值即为

```
000, 001, 010, 011
```

注意到第 $i$ 次操作的时候，加入了大于 $i$ 位的位置都是 $0$，且第 $i$ 位是 $1$ 的所有数，他们显然比序列中原来存在的大于等于 $i$ 为的位置都是 $0$ 的数要大，而比大于 $i$ 位存在 $1$ 的数小，并且去掉 $1$ 以后即为序列中原有数字的顺序。这样我们就证明了这个方法的正确性。

而我们只需要处理 $O(\log n)$ 位，每位的处理都是 $O(n)$ 的，因此总时间复杂度 $O(n \log n)$，空间复杂度 $O(n)$，事实上对于每位的处理是跑不满 $O(n)$ 的，并且规避了取模和除法操作，常数极小。

代码如下

```cpp
void MakeRev(const int N) {
  int d = N >> 1, p = 0;
  tax[p++] = 0;
  tax[p++] = d;
  for (int w = 2; w <= N; w <<= 1) {
    d >>= 1;
    for (int p0 = 0; p0 < w; ++p0) {
      tax[p++] = tax[p0] | d;
    }
  }
}
```

然后考虑通过我们得到的 ``tax`` 数组来对原数组 $A$ 进行排序。

记 $rev(i)$ 为 $i$ 二进制逆序后的值，显然 $rev(rev(i)) = i$。因此对于一个下标 $p$，设它排序后在新序列中的下标为 $q$，那么原序列下标为 $q$ 的位置在新序列的下标一定是 $p$。所以我们只需要对于所有 $rev(i) > i$ 的位置 $i$，交换 $i$ 和 $rev(i)$ 位置的值即可。

这部分操作的名字叫做**位逆序置换**。

```cpp
for (int i = 1; i < N; ++i) if (tax[i] > i) {
  std::swap(A[i], A[tax[i]]);
}
```

最后考虑迭代的蝴蝶操作过程。

对于求$A(x)$ 在 $n$ 次单位根的各幂次的点值时，$m = \frac{n}{2}$ 次单位根的各幂次在 $A_0$ 或 $A_1$ 处的点值已经被计算并存储在了 $A$ 数组中。我们令 $A_0(\omega_m^k)~=~A[k]$，$A_1(\omega_m^k)~=~A[k + m]$。那么 $A(\omega_n^k)~=~A[k] + \omega_n^k \times A[k + m]$，$A(\omega_n^{k + m})~=~A[k]~-\omega_n^k \times A[k + m]$，并将上面两个值分别存入 $A[k]$ 和 $A[k + m]$ 中即可。其中 $A(x)$ 代表多项式，$A[k]$ 代表数组。那么在更上面一层递归调用时，根据 $A_0$ 和 $A_1$的定义，当前的 $A[k]$ 即是上面一层所计算的多项式 $A'(x)$ 的导出多项式 $A'_0(x)$ 在 $\omega_n^k$ 处的点值，$A[k + m]$ 即是 $A'_1(x)$ 在 $\omega_n^k$ 处的点值。

至此，我们得到了一个迭代完成 ``FFT`` 的算法。

## Final Code

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <complex>
#include <iostream>
#include <algorithm>

const int maxn = 6000006;
const double PI = acos(-1);

int n, m, k, sm;
int tax[maxn];
std::complex<double> F[maxn], G[maxn];

void MakeRev(const int N);
void FFT(std::complex<double> *A, int N);

int main() {
  freopen("1.in", "r", stdin);
  qr(n); qr(m);
  for (int i = 0, x; i <= n; ++i) {
    x = 0; qr(x); F[i] = x;
  }
  for (int i = 0, x; i <= m; ++i) {
    x = 0; qr(x); G[i] = x;
  }
  sm = n + m; k = 1;
  while (k <= sm) k <<= 1;
  MakeRev(k);
  FFT(F, k); 
  FFT(G, k);
  for (int i = 0; i < k; ++i) {
    F[i] *= G[i];
  }
  FFT(F, k);
  std::reverse(F + 1, F + k);
  for (int i = 0; i < sm; ++i) {
    qw(int((F[i].real()) / k + 0.5), ' ', true);
  }
  qw(int(F[sm].real() / k + 0.5), '\n', true);
  return 0;
}

void FFT(std::complex<double> *A, int N) {
  for (int i = 1; i < N; ++i) if (tax[i] > i) {
    std::swap(A[i], A[tax[i]]);
  }
  for (int len = 2, M = 1; len <= N; M = len, len <<= 1) {
    std::complex<double> W(cos(PI / M), sin(PI / M)), w(1.0, 0.0);
    for (auto L = 0, R = len - 1; R <= N; L += len, R += len) {
      auto w0 = w;
      for (auto p = L, lim = L + M; p < lim; ++p) {
        auto x = A[p] + w0 * A[p + M], y = A[p] - w0 * A[p + M];
        A[p] = x; A[p + M] = y;
        w0 *= W;
      }
    }
  }
}

void MakeRev(const int N) {
  int d = N >> 1, p = 0;
  tax[p++] = 0;
  tax[p++] = d;
  for (int w = 2; w <= N; w <<= 1) {
    d >>= 1;
    for (int p0 = 0; p0 < w; ++p0) {
      tax[p++] = tax[p0] | d;
    }
  }
}
```

## Appreciation

十分感谢 @[**Dusker**](https://www.luogu.com.cn/user/26538) 抽出时间审阅这篇长文。

---

## 作者：NaCly_Fish (赞：95)

发现FFT的模板题竟然没有三次变两次优化呢qwq。。  
这里就讲一下吧。  
建议在看这篇题解之前，先理解基本的FFT。
  
  
****  
按照一般的做法，如果我们要求出$F(x)$和$G(x)$的卷积，会把它们分别FFT，然后对应每项乘起来，最后再逆FFT回来。  
来回一共进行了三次FFT，感觉这样是很不优的。  

我们可以把$G(x)$放到$F(x)$的虚部上去，求出$F(x)^2$，然后把$F(x)$的虚部取出来除$2$就是答案了qwq  
正确性的证明也很简单：  
$$\large (a+bi)^2=(a^2-b^2)+(2abi)$$  
这样我们就把常数优化到原来的$2/3$啦！  
ps：跑得比NTT还快！  

最后上代码：  
```cpp
#include<cstdio> 
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
#include<cmath>
#define ll long long
#define N 4000009
#define reg register
#define pi 3.141592653589793
using namespace std;

struct complex{
    double x,y;
    complex(double x=0,double y=0):x(x),y(y){}

    inline complex operator + (const complex b) const{
        return complex(x+b.x,y+b.y);
    }

    inline complex operator - (const complex b) const{
        return complex(x-b.x,y-b.y);
    }

    inline complex operator * (const complex b) const{
        complex res;
        res.x = x*b.x-y*b.y;
        res.y = x*b.y+y*b.x;
        return res;
    }
};

inline void read(int &x);
void print(int x);
inline void FFT(complex *a,int type,int lim);

int n,m;
complex F[N];
int rev[N];

signed main(){ 
    int qwq,t,lim = 1,l = -1;
    read(n),read(m);
    for(reg int i=0;i<=n;++i) read(t),F[i].x = t;
    for(reg int i=0;i<=m;++i) read(t),F[i].y = t; //把G(x)放到F(x)的虚部上
    t = n+m;
    n = max(n,m);
    while(lim<=(n<<1)){
        lim <<= 1;
        ++l;
    }
    for(reg int i=1;i<=lim;++i)
        rev[i] = (rev[i>>1]>>1)|((i&1)<<l);
    FFT(F,1,lim);
    for(reg int i=0;i<=lim;++i)
        F[i] = F[i]*F[i]; //求出F(x)^2
    FFT(F,-1,lim);
    for(reg int i=0;i<=t;++i){
        qwq = F[i].y/2+0.5; //虚部取出来除2，注意要+0.5，否则精度会有问题
        print(qwq);
        putchar(' ');
    }        
    return 0;
}

inline void FFT(complex *a,int type,int lim){ //没什么好说的,FFT的模板
    for(reg int i=1;i<=lim;++i){
        if(i>=rev[i]) continue;
        swap(a[i],a[rev[i]]);
    }
    reg complex rt,w,x,y;
    for(reg int mid=1;mid<lim;mid<<=1){
        reg int r = mid<<1;
        rt = complex(cos(pi/mid),type*sin(pi/mid));
        for(reg int j=0;j<lim;j+=r){
            w = complex(1,0);
            for(reg int k=0;k<mid;++k){
                x = a[j|k];
                y = w*a[j|k|mid];
                a[j|k] = x+y;
                a[j|k|mid] = x-y;
                w = w*rt;
            }
        }
    }
    if(type==1) return;
    for(reg int i=0;i<=lim;++i){
        a[i].y = a[i].y/lim;
        a[i].x = a[i].x/lim;
    }
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}
```

---

## 作者：Kevin090228 (赞：42)

## 最新最热多项式乘法常数优化

### 卷积算法

给定多项式 $F,G$ 的系数，我们需要求出 $F\times G$ 的系数。

第一步转化，我们设 $n=2^k$ 满足 $F\times G$ 的次数小于 $n$。所求的 $F\times G$ 可以等价写成 $F\times G\bmod (x^n-c)$，其中 $c$ 是任意复数。

为了求出这个值，我们通过求出 $F\times G\bmod(x^{n/2}-\sqrt c)$ 和 $F\times G\bmod(x^{n/2}+\sqrt c)$，然后用这个合并出答案。

不妨设 $A(x)$ 模 $x^{n/2}\pm\sqrt c$ 的商式为 $Q^{+}(x)$ 和 $Q^{-}(x)$，余式为 $R^{+}(x)$ 和 $R^{-}(x)$，我们有式子：
$$
(1+\dfrac{x^{n/2}}{\sqrt c})A(x)=(1+\dfrac{x^{n/2}}{\sqrt c})(Q^{-}(x)(x^{n/2}-\sqrt c)+R^{-}(x))=(1+\dfrac{x^{n/2}}{\sqrt c})R^{-}(x)+\dfrac{Q^{-}(x)}{\sqrt c}(x^n-c)
$$
对称地，我们同样有：
$$
(1-\dfrac{x^{n/2}}{\sqrt c})A(x)=(1-\dfrac{x^{n/2}}{\sqrt c})(Q^{+}(x)(x^{n/2}+\sqrt c)+R^{+}(x))=(1-\dfrac{x^{n/2}}{\sqrt c})R^{+}(x)-\dfrac{Q^{+}(x)}{\sqrt c}(x^n-c)
$$
把两式求和，可以得到：
$$
A(x)=\dfrac{(1-\dfrac{x^{n/2}}{\sqrt c})R^{+}(x)+(1+\dfrac{x^{n/2}}{\sqrt c})R^{-}(x)}{2}+\dfrac{Q^{-}(x)-Q^{+}(x)}{2\sqrt c}(x^n-c)
$$
而因为我们对 $(x^n-c)$ 取模，所以可以直接扔掉最后一项不管。至此，我们得到了一个 $O(n)$ 合并出 $F\times G\bmod (x^n-c)$ 的方法。

将整个式子递归下去处理，每一层多项式次数规模减半，个数翻倍，总共最多 $\log n$ 层，所以我们得到了一个 $O(n\log n)$ 的卷积算法。

### 算法本质

那么这个算法实际上在做什么呢？我们注意到，在上述递归算法的边界情况，即次数为 $1$ 时，我们计算出的结果是 $F$ 和 $G$ 模 $(x-\omega)$ 的余数，满足 $\omega^n=c$。我们在算法的第一步取 $c$ 等于 $1$，那么 $n$ 个 $\omega$ 值，其实就是 $n$ 次单位根。更进一步地，$F$ 和 $G$ 模 $(x-\omega)$ 的余数，其实就是它们在 $\omega$ 处的点值。所以实际上，这个递归求余式的过程，实际上就是一个 DFT 的过程。

那么相比于我们常用的 DFT/IDFT 计算方法 Cooley-Tukey，这个算法有什么优势呢？它能从常数上打败之前的 Cooley-Tukey 有什么本质的原因呢？

考虑 Cooley-Tukey 的分治实现和这个分治算法，它们的不同在于：Cooley-Tukey 每次分治将一个多项式分成奇数位和偶数位两部分，而这个算法是将多项式分成前半和后半两部分，它们的合并过程分别对应了两个不同的式子。

Cooley-Tukey 的合并：$X_k=E_k+e^{-\frac{2\pi ik}{n}}O_k$，$X_{k+n/2}=E_k-e^{-\frac{2\pi i k}n}O_k$。

新算法的合并：$X_k=L_k+cR_k$，$X_{k+n/2}=L_k-cR_k$。

它们看上去是两个类似的东西，但是新算法中的系数 $c$ 在每一层递归都是一个相同的数，而 Cooley-Tukey 中的 $e^{\frac{2\pi i k}{n}}$ 在每一层中对于不同的 $k$ 仍然是不同的值。计算 $e^{\frac{2\pi i k}{n}}$ 是 Cooley-Tukey 的瓶颈，所以将其优化成一个常数 $k$ 使这个新算法有了很大的常数优化空间。

### 一些杂谈

这个已经很快的算法，仍然有一些常数优化，例如 $n$ 的选择不一定需要固定是 $2$ 的幂，和「虚部循环」等优化，感兴趣可以查看算法发明者原帖和帖子下的评论。

和 Cooley-Tukey 一样，这个算法也可以写成带模数卷积形式，但是同样需要原根来替代单位根，所以非常不幸，并不能做任意模数。

需要注意的是，这个新算法不需要将多项式系数按位翻转。Cooley-Tukey 需要做按位翻转是因为合并 $E_k$ 和 $O_k$ 的时候我们其实希望直接将 $O_k$ 平移然后拼上去，所以需要按位翻转。而这个新算法中本来 $L_k$ 和 $R_k$ 就是一段区间了，不需要按位翻转就可以直接平移。

发明者的代码可以在两多项式次数和为 $2^{25}$，即大约 $3.3\times 10^{7}$ 级别时做到 2.5s 左右。评测的 OJ 是 judge.yosupo.jp，其评测机速度并不算特别快，所以可见这个算法常数之小。

### 引用

算法发明者的原帖：https://codeforces.com/blog/entry/117947。

Cooley-Tukey 的维基百科页面：https://en.wikipedia.org/wiki/Cooley-Tukey_FFT_algorithm。

---

## 作者：FlashHu (赞：42)

### 前言

众所周知，这FFT是用来算多项式乘法的。

对于这种常人思维难以理解的东西，就少些理解，多背板子吧！

~~因此只总结一下思路和代码，什么概念和推式子就靠巨佬们吧~~

推荐自为风月马前卒巨佬的[概念和定理都非常到位的总结](http://www.cnblogs.com/zwfymqz/p/8244902.html)

推荐ppl巨佬的[简明易懂的总结](http://www.cnblogs.com/cjoieryl/p/8206721.html)

## 多项式乘法的蹊径——点值表示法

一般我们把两个长度为$n$的多项式乘起来，就类似于做竖式乘法，一位一位地乘再加到对应位上，是$O(n^2)$的

如何优化？直接看是没有思路的，只好另辟蹊径了。

多项式除了我们常用的系数表示法$y=a_0+a_1x+a_2x^2+...+a_{n-1}x^{n-1}$以外，还可以用点值表示法。

所谓点值表示法，就是相当于用函数图像上$n$个点的坐标$(x_i,y_i)$表示一个$n$次多项式，显然这个表示是唯一的。

我们可以把系数表示转化成点值表示。点值表示下的多项式怎么相乘呢？就是选相同的$x_i$，把对应的$y_i$相乘。

当然，两个长度为$n$的多项式相乘得到的是长度为$2n-1$的多项式，需要$2n-1$个点值才能唯一表示，因此一开始两个多项式也要选$2n-1$个点表示。

举一个例子

$(x+1)(x+2)$→ → → → $x^2+3x+2$

↓$\qquad\qquad\qquad\qquad\qquad\qquad\ \ \ $↑

↓（点值）$\qquad\qquad\qquad$ （系数）↑

↓$\qquad\qquad\qquad\qquad\qquad\qquad\ \ \ $↑

$(0,1)(1,2)(2,3)$  （相乘）$\qquad\ \ \ $ ↑

$(0,2)(1,3)(2,4)$→ → → →$(0,2)(1,6)(2,12)$

可是，随意选$O(n)$个点，计算$y$是$O(n)$的，总时间还是$O(n^2)$的，把它还原成系数表达式更不轻松。

所以，如果选的点很普通，这只是一条蹊径，并不是一条捷径。

## 神奇的单位根

介绍一个神奇的东西——$n$次单位根（记为$\omega_n$）。

它是$n$个复数的集合，每一个的$n$次方都等于$1$。其中的一个是$e^{{2\pi i}\over n}$，记为$\omega_n$。

普及一下欧拉公式，$e^{\theta i}=\cos\theta+(\sin\theta)i$，$\theta$就是这个复数向量的旋转角。显然满足$(\omega_n)^n=e^{2\pi i}=1$，那么它的$k$次方$(\omega_n^k)^n=e^{2k\pi i}$也等于$1$。

于是可以看出，满足$n$次方等于$1$的复数的取值只会有$n$个，为$\omega_n^k(k\in[0,n-1])$，因为会有$\omega_n^{n+k}=\omega_n^k$。

这$n$个复数向量在单位圆上呈放射状。下面是算导的图片：

![](https://cdn.luogu.com.cn/upload/pic/23925.png)

介绍消去引理$ω^{dk}_{dn}=ω^k_n$，证明很容易的。

## DFT&IDFT

单位根有什么用呢？

看看我们把$\omega_n^k(k\in[0,n-1])$分别带入多项式求点值会发生什么就知道了。这个过程叫DFT。

假设$n$为偶数，那么我们可以把它的奇偶项分开，用两个多项式表示它

$A^{[0]}(x)=a_0+a_2x+a_4x^2+...+a_{n-2}x^{{\frac n 2}-1}$

$A^{[1]}(x)=a_1+a_3x+a_5x^2+...+a_{n-1}x^{{\frac n 2}-1}$

那么$A(x)=A^{[0]}(x^2)+xA^{[1]}(x^2)$。

注意，下面的变化用到了$ω^{2k}_n=ω^k_{\frac n 2}$，$ω^n_n=1$和$ω^{\frac n 2}_n=-1$。

首先带入单位根

$\quad A(ω^k_n)$

$=A^{[0]}(ω^{2k}_n)+ω^k_nA^{[1]}(ω^{2k}_n)$

$=A^{[0]}(ω^k_{\frac n 2})+ω^k_nA^{[1]}(ω^k_{\frac n 2})(k<\frac n 2)$

那$k\geq\frac n 2$时又会发生什么呢？把它变成$\frac n 2+k$

$\quad A(ω^{\frac n 2+k}_n)$

$=A^{[0]}(ω^{n+2k}_n)+ω^{\frac n 2+k}_nA^{[1]}(ω^{n+2k}_n)$

$=A^{[0]}(ω^{2k}_n)+ω^{\frac n 2}_nω^k_nA^{[1]}(ω^{2k}_n)$

$=A^{[0]}(ω^k_{\frac n 2})-ω^k_nA^{[1]}(ω^k_{\frac n 2})$

也就是说，如果我们要求一个长度为$n$的多项式取$\omega_n^k(k\in[0,n-1])$的$n$个点值，我们只需要求出两个长度为$n/2$的多项式取$\omega_{\frac n 2}^k(k\in[0,\frac n 2-1])$的$\frac n 2$个点值，再通过上述两个式子合并结果。这完全就是个递归过程，很容易写一个函数来计算。

可以由算法写出DFT的复杂度$T(n)=2T(\frac n 2)+O(n)=O(n\log n)$

---

当然，别忘了还原成系数表示，这个过程叫做IDFT。

蒟蒻觉得这里理解太麻烦了，因此不再证明IDFT的过程，想了解的参见其它的总结。

只需要记住，IDFT的$\omega_n$是$e^{-\frac{2\pi i}n}$，最后的结果除以$n$，其它过程同DFT，可以写在一个函数里。具体看下面的代码：

```cpp
void FFT(R complex<double>*a,R int n,R int op){//op=1为DFT，-1为IDFT
    if(!n)return;//为了方便，n的意义与上面不一样，这里的n是a0、a1的长度
    complex<double>a0[n],a1[n];
    for(R int k=0;k<n;++k)
        a0[k]=a[k<<1],a1[k]=a[k<<1|1];//奇偶项分离
    FFT(a0,n>>1,op);FFT(a1,n>>1,op);//递归处理
    R complex<double>wn(cos(PI/n),sin(PI/n)*op),w(1,0);//单位根
    for(R int k=0;k<n;++k,w*=wn)//k从到n/2
        a[k]=a0[k]+w*a1[k],a[k+n]=a0[k]-w*a1[k];
}
```
## 递归版过程

引入例题：[洛谷P3803 【模板】多项式乘法（FFT）](https://www.luogu.org/problemnew/show/P3803)

由于系数很小，我们不必担心精度的问题了（~~当然float是使不得的~~）

递归版代码：
```cpp
#include<cstdio>
#include<cmath>
#include<complex>
#include<iostream>
#define R register
#define G c=getchar()
using namespace std;
const int N=4.2e6;
const double PI=acos(-1);//自定义π
complex<double>f[N],g[N];
inline int in(){
    R char G;
    while(c<'-')G;
    return c&15;
}
void FFT(R complex<double>*a,R int n,R int op){//同上
    if(!n)return;
    complex<double>a0[n],a1[n];
    for(R int i=0;i<n;++i)
        a0[i]=a[i<<1],a1[i]=a[i<<1|1];
    FFT(a0,n>>1,op);FFT(a1,n>>1,op);
    R complex<double>W(cos(PI/n),sin(PI/n)*op),w(1,0);
    for(R int i=0;i<n;++i,w*=W)
        a[i]=a0[i]+w*a1[i],a[i+n]=a0[i]-w*a1[i];
}
int main(){
    R int n,m,i;
    scanf("%d%d",&n,&m);
    for(i=0;i<=n;++i)f[i]=in();
    for(i=0;i<=m;++i)g[i]=in();
    for(m+=n,n=1;n<=m;n<<=1);//把长度补到2的幂，不必担心高次项的系数，因为默认为0
    FFT(f,n>>1,1);FFT(g,n>>1,1);//DFT
    for(i=0;i<n;++i)f[i]*=g[i];//点值直接乘
    FFT(f,n>>1,-1);//IDFT
    for(i=0;i<=m;++i)printf("%.0f ",fabs(f[i].real())/n);//注意结果除以n，小心“-0”
    puts("");
    return 0;
}
```
好记又好写的递归版结果怎样呢？

~~Fast Fast TLE!~~只有77分。

最主要的原因在于，空间调用太多了。

## 蝴蝶操作和Rader排序

针对效率太低的问题，我们继续观察FFT实现过程中的更多特点。

观察这一句代码`a[k]=a0[k]+w*a1[k],a[k+n]=a0[k]-w*a1[k];`，在操作过程中，取出了`a0[k]`和`a1[k]`的值，通过计算又求出了`a[k]`和`a[k+n]`的值。我们把这样的一次运算叫做“蝴蝶操作”。

这样的操作有什么特点呢？我们试着将`a0`和`a1`合并成一个数组`a`，每一次蝴蝶操作后，取出了`a[k]`和`a[k+n]`的值，又求出了`a[k]`和`a[k+n]`的值。最后，整个数组都完成了求值，而并没有用到两个数组！

以$n=8$为例，看看递归过程的结构

![](https://cdn.luogu.com.cn/upload/pic/23926.png)

其实，我们完全可以递推求解！假设$a$数组已经变成了第四层的样子，先对a0和a4、a2和a6、a1和a5、a3和a7蝴蝶操作，变成第三层；再对a0和a2、a4和a6、a1和a3、a5和a7蝴蝶操作，变成第二层；最后对a0和a1、a2和a3、a4和a5、a6和a7蝴蝶操作，变成第一层，FFT就完成了，而空间复杂度仅为$O(n)$。这个过程可以用循环来控制。

剩下的问题就是把初始的数组变成最后一层的样子了。先别急着写一个递归函数暴力把位置换过去。来观察一下最后序列的编号的二进制表示`000,100,010,110,001,101,011,111`，是不是与原来`000,001,010,011,100,101,110,111`相比，每个位置上的二进制位都反过来了？这样的变化叫做Rader排序。

我们可以$O(n)$将Rader排序的映射关系求出。设$i$Rader排序后的数为$r_i$，我们可以通过$r_{\frac i 2}$递推求出，具体方法可以看看代码&动动脑筋qwq

```cpp
#include<cmath>
#include<cstdio>
#define R register
#define I inline
using namespace std;
const int N=4.2e6;
const double PI=acos(-1);
int n,r[N];
struct C{//手写complex，比STL快一点点
	double r,i;
	I C(){r=i=0;}
	I C(R double x,R double y){r=x;i=y;}
	I C operator+(R C&x){return C(r+x.r,i+x.i);}
	I C operator-(R C&x){return C(r-x.r,i-x.i);}
	I C operator*(R C&x){return C(r*x.r-i*x.i,r*x.i+i*x.r);}
	I void operator+=(R C&x){r+=x.r;i+=x.i;}
	I void operator*=(R C&x){R double t=r;r=r*x.r-i*x.i;i=t*x.i+i*x.r;}
}f[N],g[N];
I int in(){
	R char c=getchar();
	while(c<'-')c=getchar();
	return c&15;
}
I void FFT(R C*a,R int op){
	R C W,w,t,*a0,*a1;
	R int i,j,k;
	for(i=0;i<n;++i)//根据映射关系交换元素
		if(i<r[i])t=a[i],a[i]=a[r[i]],a[r[i]]=t;
	for(i=1;i<n;i<<=1)//控制层数
		for(W=C(cos(PI/i),sin(PI/i)*op),j=0;j<n;j+=i<<1)//控制一层中的子问题个数
			for(w=C(1,0),a1=i+(a0=a+j),k=0;k<i;++k,++a0,++a1,w*=W)
				t=*a1*w,*a1=*a0-t,*a0+=t;//蝴蝶操作
}
int main(){
    R int m,i,l=0;
    scanf("%d%d",&n,&m);
    for(i=0;i<=n;++i)f[i].r=in();
    for(i=0;i<=m;++i)g[i].r=in();
    for(m+=n,n=1;n<=m;n<<=1,++l);
    for(i=0;i<n;++i)r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));//递推求r
    FFT(f,1);FFT(g,1);
    for(i=0;i<n;++i)f[i]*=g[i];
    FFT(f,-1);
    for(i=0;i<=m;++i)printf("%.0f ",fabs(f[i].r)/n);
    puts("");
    return 0;
}
```

---

## 作者：Bring (赞：29)

[更好的阅读体验请点这里](https://www.cnblogs.com/BrianPeng/p/12251447.html)

### Intro:

本篇博客将会从朴素乘法讲起，经过分治乘法，到达FFT和NTT

旨在能够让读者（也让自己）充分理解其思想

---

## 朴素乘法

#### 约定：两个多项式为$A(x)=\sum_{i=0}^{n}a_ix^i,B(x)=\sum_{i=0}^{m}b_ix^i$

### Prerequisite knowledge:

初中数学知识~~（手动滑稽）~~

最简单的多项式方法就是逐项相乘再合并同类项，写成公式：

若$C(x)=A(x)B(x)$，那么$C(x)=\sum_{i=0}^{n+m}c_ix^i$，其中$c_i=\sum_{j=0}^ia_jb_{i-j}$

于是一个朴素乘法就产生了，见代码（利用某种丧心病狂的方式省了$b$数组）

```cpp
//This program is written by Brian Peng.
#pragma GCC optimize("Ofast","inline","no-stack-protector")
#include<bits/stdc++.h>
using namespace std;
#define Rd(a) (a=read())
#define Gc(a) (a=getchar())
#define Pc(a) putchar(a)
int read(){
	register int x;register char c(getchar());register bool k;
	while(!isdigit(c)&&c^'-')if(Gc(c)==EOF)exit(0);
	if(c^'-')k=1,x=c&15;else k=x=0;
	while(isdigit(Gc(c)))x=(x<<1)+(x<<3)+(c&15);
	return k?x:-x;
}
void wr(register int a){
	if(a<0)Pc('-'),a=-a;
	if(a<=9)Pc(a|'0');
	else wr(a/10),Pc((a%10)|'0');
}
signed const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);
long long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);
#define Ps Pc(' ')
#define Pe Pc('\n')
#define Frn0(i,a,b) for(register int i(a);i<(b);++i)
#define Frn1(i,a,b) for(register int i(a);i<=(b);++i)
#define Frn_(i,a,b) for(register int i(a);i>=(b);--i)
#define Mst(a,b) memset(a,b,sizeof(a))
#define File(a) freopen(a".in","r",stdin),freopen(a".out","w",stdout)
#define N (2000010)
int n,m,a[N],b,c[N];
signed main(){
	Rd(n),Rd(m);
	Frn1(i,0,n)Rd(a[i]);
	Frn1(i,0,m){Rd(b);Frn1(j,0,n)c[i+j]+=b*a[j];}
	Frn1(i,0,n+m)wr(c[i]),Ps;
	exit(0);
}
```

**Time complexity: $O(nm)$，如果$m=O(n)$，则为$O(n^2)$**

**Memory complexity: $O(n)$**

看看效果

![](https://images.cnblogs.com/cnblogs_com/BrianPeng/1640550/o_200202024540%E6%9C%B4%E7%B4%A0%E4%B9%98%E6%B3%95.PNG)

~~意料之中~~，所以必须优化

---

## 朴素分治乘法

**P.s 这一部分讲述了FFT的分治方法，与FFT还是有区别的，如果已经理解的可以跳过**

#### 约定：$n$为同时属于$A(x),B(x)$次数界的最小的$2$的正整数幂，并将两个多项式设为$A(x)=\sum_{i=0}^{n-1}a_ix^i,B(x)=\sum_{i=0}^{n-1}b_ix^i$，不存在的系数补零

**次数界**：严格$>$一个多项式次数的整数（E.g 多项式$P(x)=x^2+x+1$的次数界为$\geqslant3$的所有整数）

### Reference：

**《算法导论》**

### Prerequisite knowledge:

**分治思想**

现在来考虑如何去优化乘法

尝试将两个多项式按照未知项次数的奇偶性分开：

$A(x)=A^{[0]}(x^2)+xA^{[1]}(x^2),B(x)=B^{[0]}(x^2)+xB^{[1]}(x^2)$

其中$A^{[0]}(x)=\sum_{i=0}^{n/2-1}a_{2i}x^i,A^{[1]}(x)=\sum_{i=0}^{n/2-1}a_{2i+1}x^i$，$B^{[0]}(x)$与$B^{[1]}(x)$同理

于是两个多项式就被拆成了两个次数界为$n/2$的四个多项式啦：

**P.s 以下的公式中，用$A$表示$A(x)$，$A^{[0]}$和$A^{[1]}$分别表示$A^{[0]}(x^2)$和$A^{[1]}(x^2)$，$B$同理**

$AB=(A^{[0]}+xA^{[1]})(B^{[0]}+xB^{[1]})=A^{[0]}B^{[0]}+x(A^{[1]}B^{[0]}+A^{[0]}B^{[1]})+x^2A^{[1]}B^{[1]}$

**在此可以发现一种分治算法：把两个多项式折半，然后再递归算$4$次多项式乘法，最后合并加起来**（反正多项式加法是$O(n)$的）

**P.s 注意合并方式：$A^{[0]}$和$A^{[1]}$分别表示$A^{[0]}(x^2)$和$A^{[1]}(x^2)$，所以是交错的**，见代码

（为了省空间用了vector）

```cpp
//This program is written by Brian Peng.
#pragma GCC optimize("Ofast","inline","no-stack-protector")
#include<bits/stdc++.h>
using namespace std;
#define Rd(a) (a=read())
#define Gc(a) (a=getchar())
#define Pc(a) putchar(a)
int read(){
	register int x;register char c(getchar());register bool k;
	while(!isdigit(c)&&c^'-')if(Gc(c)==EOF)exit(0);
	if(c^'-')k=1,x=c&15;else k=x=0;
	while(isdigit(Gc(c)))x=(x<<1)+(x<<3)+(c&15);
	return k?x:-x;
}
void wr(register int a){
	if(a<0)Pc('-'),a=-a;
	if(a<=9)Pc(a|'0');
	else wr(a/10),Pc((a%10)|'0');
}
signed const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);
long long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);
#define Ps Pc(' ')
#define Pe Pc('\n')
#define Frn0(i,a,b) for(register int i(a);i<(b);++i)
#define Frn1(i,a,b) for(register int i(a);i<=(b);++i)
#define Frn_(i,a,b) for(register int i(a);i>=(b);--i)
#define Mst(a,b) memset(a,b,sizeof(a))
#define File(a) freopen(a".in","r",stdin),freopen(a".out","w",stdout)
typedef vector<int> Vct;
int n,m,s; 
Vct a,b,c;
void add(Vct&a,Vct&b,Vct&c){Frn0(i,0,c.size())c[i]=a[i]+b[i];}
void mlt(Vct&a,Vct&b,Vct&c,int n);
signed main(){
	Rd(n),Rd(m),a.resize(s=1<<int(log2(max(n,m))+1)),b.resize(s),c.resize(s<<1);
	Frn1(i,0,n)Rd(a[i]);
	Frn1(i,0,m)Rd(b[i]);
	mlt(a,b,c,s);
	Frn1(i,0,n+m)wr(c[i]),Ps;
	exit(0);
}
void mlt(Vct&a,Vct&b,Vct&c,int n){
	int n2(n>>1);
	Vct a0(n2),a1(n2),b0(n2),b1(n2),ab0(n),ab1(n),abm(n);
	if(n==1){c[0]=a[0]*b[0];return;}
	Frn0(i,0,n2)a0[i]=a[i<<1],a1[i]=a[i<<1|1],b0[i]=b[i<<1],b1[i]=b[i<<1|1];
	mlt(a0,b0,ab0,n2),mlt(a1,b1,ab1,n2);
	Frn0(i,0,n)c[i<<1]=ab0[i]+(i?ab1[i-1]:0);
	mlt(a0,b1,ab0,n2),mlt(a1,b0,ab1,n2),add(ab0,ab1,abm);
	Frn0(i,0,n-1)c[i<<1|1]=abm[i];
}
```

看看效果

![](https://images.cnblogs.com/cnblogs_com/BrianPeng/1640550/o_200202034033%E6%9C%B4%E7%B4%A0%E5%88%86%E6%B2%BB%E4%B9%98%E6%B3%95.PNG)

好像更惨……

为什么呢，因为这个算法的时间复杂度还是$O(n^2)$的，具体证明如下

$T(n)=4T(n/2)+f(n)$，其中$f(n)=O(n)$（就是$n$位加法的时间）

运用主方法，$a=4,b=2,log_ba=log_2 4=2>1$，所以$T(n)=O(n^{log_ba})=O(n^2)$

而且不仅复杂度高，常数因子也因为递归变高了

~~所以继续优化吧……~~

---

## 分治乘法

接上上一部分的内容，考虑如何优化时间复杂度

**先来一个小插曲：**如何只做$3$次乘法，求出线性多项式$ax+b$与$cx+d$的乘积

先看看结果：$(ax+b)(cx+d)=acx^2+(ad+bc)x+bd$，总共有$4$次乘法

所以如果只用$3$次乘法，那么$ad+bc$必须只能用一次乘法得到

尝试把$3$个系数加起来，就是$ac+ad+bc+bd=(a+b)(c+d)$

答案出来了，**用$3$次乘法分别算出$ac,bd$与$(a+b)(c+d)$，那么中间项系数$=(a+b)(c+d)-ac-bd$**

**回到原题目**

$AB=(A^{[0]}+xA^{[1]})(B^{[0]}+xB^{[1]})=A^{[0]}B^{[0]}+x(A^{[1]}B^{[0]}+A^{[0]}B^{[1]})+x^2A^{[1]}B^{[1]}$

于是中间项也可以使用类似的方法：$A^{[1]}B^{[0]}+A^{[0]}B^{[1]}=(A^{[0]}+A^{[1]})(B^{[0]}+B^{[1]})-A^{[0]}B^{[0]}-A^{[1]}B^{[1]}$

成功减少一次乘法运算，见代码

```cpp
//This program is written by Brian Peng.
#pragma GCC optimize("Ofast","inline","no-stack-protector")
#include<bits/stdc++.h>
using namespace std;
#define Rd(a) (a=read())
#define Gc(a) (a=getchar())
#define Pc(a) putchar(a)
int read(){
	register int x;register char c(getchar());register bool k;
	while(!isdigit(c)&&c^'-')if(Gc(c)==EOF)exit(0);
	if(c^'-')k=1,x=c&15;else k=x=0;
	while(isdigit(Gc(c)))x=(x<<1)+(x<<3)+(c&15);
	return k?x:-x;
}
void wr(register int a){
	if(a<0)Pc('-'),a=-a;
	if(a<=9)Pc(a|'0');
	else wr(a/10),Pc((a%10)|'0');
}
signed const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);
long long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);
#define Ps Pc(' ')
#define Pe Pc('\n')
#define Frn0(i,a,b) for(register int i(a);i<(b);++i)
#define Frn1(i,a,b) for(register int i(a);i<=(b);++i)
#define Frn_(i,a,b) for(register int i(a);i>=(b);--i)
#define Mst(a,b) memset(a,b,sizeof(a))
#define File(a) freopen(a".in","r",stdin),freopen(a".out","w",stdout)
typedef vector<int> Vct;
int n,m,s;
Vct a,b,c;
void add(Vct&a,Vct&b,Vct&c){Frn0(i,0,c.size())c[i]=a[i]+b[i];}
void mns(Vct&a,Vct&b,Vct&c){Frn0(i,0,c.size())c[i]=a[i]-b[i];}
void mlt(Vct&a,Vct&b,Vct&c);
signed main(){
	Rd(n),Rd(m),a.resize(s=1<<int(log2(max(n,m))+1)),b.resize(s),c.resize(s<<1);
	Frn1(i,0,n)Rd(a[i]);
	Frn1(i,0,m)Rd(b[i]);
	mlt(a,b,c);
	Frn1(i,0,n+m)wr(c[i]),Ps;
	exit(0);
}
void mlt(Vct&a,Vct&b,Vct&c){
	int n(a.size()),n2(a.size()>>1);
	Vct a0(n2),a1(n2),b0(n2),b1(n2),ab0(n),ab1(n),abm(n);
	if(n==1){c[0]=a[0]*b[0];return;}
	Frn0(i,0,n2)a0[i]=a[i<<1],a1[i]=a[i<<1|1],b0[i]=b[i<<1],b1[i]=b[i<<1|1];
	mlt(a0,b0,ab0),mlt(a1,b1,ab1);
	Frn0(i,0,n)c[i<<1]=ab0[i]+(i?ab1[i-1]:0);
	add(a0,a1,a0),add(b0,b1,b0),mlt(a0,b0,abm),mns(abm,ab0,abm),mns(abm,ab1,abm);
	Frn0(i,0,n-1)c[i<<1|1]=abm[i];
}
```

看看效果

![](https://images.cnblogs.com/cnblogs_com/BrianPeng/1640550/o_200202041742%E5%88%86%E6%B2%BB%E4%B9%98%E6%B3%95.PNG)

比朴素分治乘法好一点，但是还是没朴素乘法强，~~还是很惨~~

看看这个算法的时间复杂度：

$T(n)=3T(n/2)+f(n)$，其中$f(n)=O(n)$

运用主方法，$a=3,b=2,\log_ba=\log_2 3\approx1.58>1$，所以$T(n)=O(n^{\log_ba})=O(n^{\log_2 3})$

额那不是应该比朴素算法要好吗，这是什么情况

Reason 1. 分治乘法的常数因子太大

Reason 2. 打开$\#5$数据一看，$n=1,m=3e6$，那么$O(n^{\log_2 3})$的分治乘法也顶不过$O(nm)$的朴素乘法啊……

所以就要请上本文的主角了

---

## 快速傅里叶变换 FFT (Fast Fourier Transform)

~~Fairly Frightening Transform~~

**约定：$n$为属于$A(x),B(x)$的乘积$C(x)$次数界的最小的$2$的正整数幂（即满足$>$输入$n+m$的最小的$2$的正整数幂），并同样将两个多项式设为$A(x)=\sum_{i=0}^{n-1}a_ix^i,B(x)=\sum_{i=0}^{n-1}b_ix^i$**

### Reference：

**《算法导论》**

**[自为风月马前卒：快速傅里叶变换(FFT)详解](https://www.cnblogs.com/zwfymqz/p/8244902.html)**

### Prerequisite knowledge:

**分治思想**

**复数的基本知识**

**线性代数的基本知识**

### Part 1: 多项式的两种表示方式

#### 1. 系数表达

对一个次数界为$n$的多项式$A(x)=\sum_{i=0}^{n-1}a_ix^i$，其系数表达是向量$a=\left[\begin{matrix}a_0\\a_1\\\vdots\\a_{n-1}\end{matrix} \right]$

使用系数表达时，下列操作的时间复杂度：

1. 求值$O(n)$

2. 加法$O(n)$

3. 乘法朴素$O(n^2)$，优化$(n^{\log_2 3})$（即分治乘法）

#### 2. 点值表达

一个次数界为$n$的多项式$A(x)$的点值表达是一个有$n$个点值对所组成的集合$\{(x_0,y_0),(x_1,y_1),\cdots,(x_{n-1},y_{n-1})\}$

进行$n$次**求值**就可以把系数表达转化为点值表达，总时间$O(n^2)$，用公式表示就是：

$\left[\begin{matrix}1&x_0&x_0^2&\cdots&x_0^{n-1}\\1&x_1&x_1^2&\cdots&x_1^{n-1}\\\vdots&\vdots&\vdots&\ddots&\vdots\\1&x_{n-1}&x_{n-1}^2&\cdots&x_{n-1}^{n-1}\end{matrix} \right]\left[\begin{matrix}a_0\\a_1\\\vdots\\a_{n-1}\end{matrix} \right]=\left[\begin{matrix}y_0\\y_1\\\vdots\\y_{n-1}\end{matrix} \right]$

其中左边的矩阵表示为$V(x_0,x_1,\cdots,x_{n-1})$称为**范德蒙德矩阵**，于是可以将公式简化为$V(x_0,x_1,\cdots,x_{n-1})a=y$

使用拉格朗日公式，可以在$O(n^2)$时间将点值表达转化为系数表达，该过程称为**插值**

对于两个在相同位置求值的点值表达多项式，下列操作的时间复杂度：

1. 加法$O(n)$（只要将各个位置的$y$值相加即可）

2. 乘法$O(n)$（同理）

所以这就是使用FFT的原因：通过精心选取$x$值，可以在$O(n\log n)$时间完成求值，再$O(n)$乘法，最后$O(n\log n)$插值

傅里叶大神究竟选了什么神奇的$x$值呢，请看

###Part 2: 单位复数根及其性质

**$n$次单位复数根**是满足$\omega^n=1$的复数$\omega$，正好有$n$个，记为：

$\omega_n^k=e^{2\pi ik/n}=\cos(2\pi k/n)+i\sin(2\pi k/n)$

其中$\omega_n=e^{2\pi i/n}=\cos(2\pi /n)+i\sin(2\pi /n)$被称为**主$n$次单位根**，所有其他$n$次单位根都是$\omega_n$的幂次

可以把$n$个单位根看作是复平面上以单位圆的$n$个等分点为终点的向量，具体原因就是复数乘法“模长相乘，辐角相加”的规律

如图表示的是$8$次单位复数根在复平面上的位置

![](https://images.cnblogs.com/cnblogs_com/BrianPeng/1640550/o_2002020623258%E6%AC%A1%E5%8D%95%E4%BD%8D%E6%A0%B9.PNG)

于是就可以得到规律：$\omega_n^j\omega_n^k=\omega_n^{j+k}=\omega_n^{(j+k)\mod n}$，类似地$\omega_n^{-1}=\omega_n^{n-1}$

#### 接下来的三个引理就是FFT的重头戏啦

#### 1. 消去引理：对任何整数$n\geqslant 0,k\geqslant 0,d>0$，有$\omega_{dn}^{dk}=\omega_n^k$

**Proof: **$\omega_{dn}^{dk}=(e^{2\pi i/dn})^{dk}=(e^{2\pi i/n})^k=\omega_n^k$

#### 2. 折半引理：对任何偶数$n$和整数$k$，有$(\omega_n^k)^2=(\omega_n^{k+n/2})^2=\omega_{n/2}^k$

**Proof: **$(\omega_n^k)^2=\omega_n^{2k},(\omega_n^{k+n/2})^2=\omega_n^{2k+n}=\omega_n^{2k}$，最后用消去引理，$\omega_n^{2k}=\omega_{n/2}^k$

#### 3. 求和引理：对任何整数$n\geqslant 0$与非负整数$k:n\nmid k$，有$\sum_{j=0}^{n-1}(\omega_n^k)^j=0$

**Proof: **利用等比数列求和公式，$\sum_{j=0}^{n-1}(\omega_n^k)^j=\frac{1-(\omega_n^k)^n}{1-\omega_n^k}=\frac{1-\omega_n^{nk}}{1-\omega_n^k}=\frac{1-1}{1-\omega_n^k}=0$，为了使分母$1-\omega_n^k\neq 0$，必须满足$\omega_n^k\neq 1\implies n\nmid k$

### Part 3: 离散傅里叶变换 DFT (Discrete Fourier Transform)

**DFT**就是将次数界为$n$的多项式$A(x)$在**$n$次单位复数根**上**求值**的过程

简化一下表示方法：

$V_n=V(\omega_n^0,\omega_n^1,\cdots,\omega_n^{n-1})=\left[\begin{matrix}1&1&1&1&\cdots&1\\1&\omega_n&\omega_n^2&\omega_n^3&\cdots&\omega_n^{n-1}\\1&\omega_n^2&\omega_n^4&\omega_n^6&\cdots&\omega_n^{2(n-1)}\\1&\omega_n^3&\omega_n^6&\omega_n^9&\cdots&\omega_n^{3(n-1)}\\\vdots&\vdots&\vdots&\vdots&\ddots&\vdots\\1&\omega_n^{n-1}&\omega_n^{2(n-1)}&\omega_n^{3(n-1)}&\cdots&\omega_n^{(n-1)(n-1)}\end{matrix} \right]$

用公式表示就是$V_na=y$，也记为$y=DFT_n(a)$

另外，可以发现$[V_n]_{ij}=\omega_n^{ij}\implies y_i=\sum_{j=0}^{n-1}[V_n]_{ij}a_j=\sum_{j=0}^{n-1}\omega_n^{ij}a_j$

终于可以看看具体操作了

### Part 4: FFT

FFT利用单位根的特殊性质把DFT优化到了$O(n\log n)$

和分治乘法一样，按未知项次数的奇偶性分开：$A(x)=A^{[0]}(x^2)+xA^{[1]}(x^2)$

其中$A^{[0]}(x)=\sum_{i=0}^{n/2-1}a_{2i}x^i,A^{[1]}(x)=\sum_{i=0}^{n/2-1}a_{2i+1}x^i$

这时，求$A(x)$在$\omega_n^0,\omega_n^1,\cdots,\omega_n^{n-1}$的值变成了：

#### 1. 求$A^{[0]}(x)$与$A^{[1]}(x)$在$(\omega_n^0)^2,(\omega_n^1)^2,\cdots,(\omega_n^{n-1})^2$的值

根据**折半引理**，$(\omega_n^0)^2,(\omega_n^1)^2,\cdots,(\omega_n^{n-1})^2$中两两重复，其实就是**$n/2$个$n/2$次单位根**

所以只要对拆开的两个多项式分别做$DFT_{n/2}$即可，得到$y^{[0]}$与$y^{[1]}$

#### 2. 合并答案

$\omega_n^{n/2}=e^{2\pi i (n/2)/n}=e^{\pi i}=-1$（根据传说中的最美公式$e^{i\pi}+1=0$）

所以$\omega_n^{k+n/2}=\omega_n^k\omega_n^{n/2}=-\omega_n^k$

所以$y_i=y^{[0]}_i+\omega_n^i y^{[1]}_i,y_{i+n/2}=y^{[0]}_i-\omega_n^i y^{[1]}_i,i=0,1,\cdots,n/2-1$

具体运行时，就每次循环结束时让一个初始为$1$的变量$*\omega_n$即可

#### 递归边界：$n=1$，那么$w_1^0 a_0=a_0$，所以直接返回自身

计算一下时间复杂度

$T(n)=2T(n/2)+f(n)$，其中$f(n)=O(n)$（合并答案）

运用主方法，$a=2,b=2,\log_ba=\log_2 2=1$，所以$T(n)=O(n^{\log_ba}\log n)=O(n\log n)$~~（皆大欢喜）~~

### Part 5: 离散傅里叶逆变换

可别高兴太早，还有**插值**哦

因为$y=DFT_n(a)=V_na$，所以$a=V_n^{-1}y$，记为$a=DFT_n^{-1}(y)$

#### 定理：对$i,j=0,1,\cdots,n-1$，有$[V_n^{-1}]_{ij}=\omega_n^{-ij}/n$

**Proof: **证明$V_n^{-1}V_n=I_n$即可

$[V_n^{-1}V_n]_{ij}=\sum_{k=0}^{n-1}(\omega_n^{-ik}/n)\omega_n^{kj}=\frac{\sum_{k=0}^{n-1}\omega_n^{-ik}\omega_n^{kj}}{n}=\frac{\sum_{k=0}^{n-1}\omega_n^{(j-i)k}}{n}$

如果$i=j$，则该值$=\frac{\sum_{k=0}^{n-1}\omega_n^0}{n}=n/n=1$

否则，因为$n\nmid k$，根据**求和引理**，该值$=0/n=0$，所以构成了$I_n$

接下来$a=DFT_n^{-1}(y)=V_n^{-1}y\implies a_i=\sum_{j=0}^{n-1}[V_n^{-1}]_{ij}y_j=\sum_{j=0}^{n-1}(\omega_n^{-ij}/n)y_j=\frac{\sum_{j=0}^{n-1}\omega_n^{-ij}y_j}{n}$

比较一下DFT中$y_i=\sum_{j=0}^{n-1}\omega_n^{ij}a_j$

只要运算时把$\omega_n$换成$-\omega_n$，然后将最终答案$/n$，就把DFT变成逆DFT了

终于可以来到~~激动人心的~~实现环节了

### Part 6: 递归实现

根据前文，只要将分治乘法的代码修改一下即可

可以做到直接在原址进行FFT，就是将分开的两个多项式分置在左右两边

STL提供了现成的complex类可供使用

代码中用$iv$表示是否为逆DFT，用$o$存储主单位根，用$w$累积

**P.s **最后别忘了$/n$，而且$+0.5$为了四舍五入提高精度

```cpp
//This program is written by Brian Peng.
#pragma GCC optimize("Ofast","inline","no-stack-protector")
#include<bits/stdc++.h>
using namespace std;
#define Rd(a) (a=read())
#define Gc(a) (a=getchar())
#define Pc(a) putchar(a)
int read(){
	register int u;register char c(getchar());register bool k;
	while(!isdigit(c)&&c^'-')if(Gc(c)==EOF)exit(0);
	if(c^'-')k=1,u=c&15;else k=u=0;
	while(isdigit(Gc(c)))u=(u<<1)+(u<<3)+(c&15);
	return k?u:-u;
}
void wr(register int a){
	if(a<0)Pc('-'),a=-a;
	if(a<=9)Pc(a|'0');
	else wr(a/10),Pc((a%10)|'0');
}
signed const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);
long long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);
#define Ps Pc(' ')
#define Pe Pc('\n')
#define Frn0(i,a,b) for(register int i(a);i<(b);++i)
#define Frn1(i,a,b) for(register int i(a);i<=(b);++i)
#define Frn_(i,a,b) for(register int i(a);i>=(b);--i)
#define Mst(a,b) memset(a,b,sizeof(a))
#define File(a) freopen(a".in","r",stdin),freopen(a".out","w",stdout)
double const Pi(acos(-1));
typedef complex<double> Cpx;
#define N (2100000)
Cpx o,w,a[N],b[N],tmp[N],x,y;
int n,m,s;
bool iv;
void fft(Cpx*a,int n);
signed main(){
	Rd(n),Rd(m),s=1<<int(log2(n+m)+1);
	Frn1(i,0,n)Rd(a[i]);
	Frn1(i,0,m)Rd(b[i]);
	fft(a,s),fft(b,s);
	Frn0(i,0,s)a[i]*=b[i];
	iv=1,fft(a,s);
	Frn1(i,0,n+m)wr(a[i].real()/s+0.5),Ps;
	exit(0);
}
void fft(Cpx*a,int n){
	if(n==1)return;
	int n2(n>>1);
	Frn0(i,0,n2)tmp[i]=a[i<<1],tmp[i+n2]=a[i<<1|1];
	copy(tmp,tmp+n,a),fft(a,n2),fft(a+n2,n2);
	o={cos(Pi/n2),(iv?-1:1)*sin(Pi/n2)},w=1;
	Frn0(i,0,n2)x=a[i],y=w*a[i+n2],a[i]=x+y,a[i+n2]=x-y,w*=o;
}
```

**Time complexity: $O(n\log n)$**

**Memory complexity: $O(n)$**

看看效果

![](https://images.cnblogs.com/cnblogs_com/BrianPeng/1640550/o_200202104816%E9%80%92%E5%BD%92FFT.PNG)

性能已经超过了朴素乘法（必然的），但是还是没有AC

注意到$n,m\leqslant 1e6$，所以不仅要让时间复杂度至少$O(n\log n)$，还要保持小的常数因子，总之递归还不够快

### Part 6: 迭代实现

#### 设$l=\lceil\log_2(n+m+1)\rceil,s=2^l$，那么$A(x),B(x),A(x)B(x)$都是次数界为$s$的多项式

现在需要寻找到一种迭代的方式，使答案自底向上合并以减少常数因子

还是像递归版一样，把$A^{[0]}(x)$放在左边，$A^{[1]}(x)$放在右边

观察每一层递归时各个系数所在位置的规律，以$s=8$为例

```
0-> 0 1 2 3 4 5 6 7
1-> 0 2 4 6|1 3 5 7
2-> 0 4|2 6|1 5|3 7
end 0|4|2|6|1|5|3|7
```

没看出来？那就拆成二进制看看

```
0-> 000 001 010 011 100 101 110 111
1-> 000 010 100 110|001 011 101 111
2-> 000 100|010 110|001 101|011 111
end 000|100|010|110|001|101|011|111
```

~~显然地~~在最后一层递归时，**系数编号正好是位置编号的反转**（更准确的说是前$l$位的反转）

**一个较为感性的Proof: **因为是按照奇偶性分类，也就是说在第$i$层递归时判断的是该编号二进制第$i$位（从零开始），为$0$放左边，$1$放右边，而放右边的结果就是它的位置编号的二进制第$l-i-1$位是$1$

所以到了递归最底层，位置编号的二进制就正好是系数编号二进制前$l$位的反转啦

构造数组$r_{0..s-1}$，其中$r_i$表示$i$二进制前$l$位的反转，可以利用递推完成，具体请自己思考~~（或看代码）~~

#### 蝴蝶操作 (Butterfly Operation)

其实在递归版代码中已经出现，但是这里再详细说明一下

还记得$y_i=y^{[0]}_i+\omega_n^i y^{[1]}_i,y_{i+n/2}=y^{[0]}_i-\omega_n^i y^{[1]}_i,i=0,1,\cdots,n/2-1$吗？

但是现在不使用$y$，而是$a$直接合并

因为按照奇偶性分置在两边，所以$a^{[0]}_i=a_i,a^{[1]}_i=a_{i+n/2}$

设$x=a_i,y=\omega_n^i a_{i+n/2}$

那么新的$a_i=x+y,a_{i+n/2}=x-y$

这就是蝴蝶操作啦

有了蝴蝶操作，只要将所有系数按照$r$数组的位置排列，再迭代合并，就完成了FFT

在代码中，用$i,i_2$表示当前合并产生的和开始的序列长度，$j$表示合并序列的开头位置，$k$控制每一位的合并，上代码

```cpp
//This program is written by Brian Peng.
#pragma GCC optimize("Ofast","inline","no-stack-protector")
#include<bits/stdc++.h>
using namespace std;
#define Rd(a) (a=read())
#define Gc(a) (a=getchar())
#define Pc(a) putchar(a)
int read(){
	register int u;register char c(getchar());register bool k;
	while(!isdigit(c)&&c^'-')if(Gc(c)==EOF)exit(0);
	if(c^'-')k=1,u=c&15;else k=u=0;
	while(isdigit(Gc(c)))u=(u<<1)+(u<<3)+(c&15);
	return k?u:-u;
}
void wr(register int a){
	if(a<0)Pc('-'),a=-a;
	if(a<=9)Pc(a|'0');
	else wr(a/10),Pc((a%10)|'0');
}
signed const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);
long long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);
#define Ps Pc(' ')
#define Pe Pc('\n')
#define Frn0(i,a,b) for(register int i(a);i<(b);++i)
#define Frn1(i,a,b) for(register int i(a);i<=(b);++i)
#define Frn_(i,a,b) for(register int i(a);i>=(b);--i)
#define Mst(a,b) memset(a,b,sizeof(a))
#define File(a) freopen(a".in","r",stdin),freopen(a".out","w",stdout)
double const Pi(acos(-1));
typedef complex<double> Cpx;
#define N (2100000)
Cpx a[N],b[N],o,w,x,y;
int n,m,l,s,r[N];
void fft(Cpx*a,bool iv);
signed main(){
	Rd(n),Rd(m),s=1<<(l=log2(n+m)+1);
	Frn1(i,0,n)Rd(a[i]);
	Frn1(i,0,m)Rd(b[i]);
	Frn0(i,0,s)r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	fft(a,0),fft(b,0);
	Frn0(i,0,s)a[i]*=b[i];
	fft(a,1);
	Frn1(i,0,n+m)wr(a[i].real()+0.5),Ps;
	exit(0);
}
void fft(Cpx*a,bool iv){
	Frn0(i,0,s)if(i<r[i])swap(a[i],a[r[i]]);
	for(int i(2),i2(1);i<=s;i2=i,i<<=1){
		o={cos(Pi/i2),(iv?-1:1)*sin(Pi/i2)};
		for(int j(0);j<s;j+=i){
			w=1;
			Frn0(k,0,i2){
				x=a[j+k],y=w*a[j+k+i2];
				a[j+k]=x+y,a[j+k+i2]=x-y,w*=o;
			}
		}
	}
	if(iv)Frn0(i,0,s)a[i]/=s;
}
```

**Time complexity: $O(n\log n)$**

**Memory complexity: $O(n)$**

看看效果

![](https://images.cnblogs.com/cnblogs_com/BrianPeng/1640550/o_200202120457FFT.PNG)

~~终于……~~

到现在为止FFT的内容已经全部结束啦，下面是拓展部分

---

## Extension: 快速数论变换 NTT (Number Theoretic Transform)

虽然FFT具有优秀的时间复杂度，但因为用到了复数，不可避免会出现精度问题

如果多项式系数和结果都是一定范围非负整数，可以考虑使用NTT来优化精度和时空常数

### Reference：

**《算法导论》**

**[自为风月马前卒：快速数论变换(NTT)小结](https://www.cnblogs.com/zwfymqz/p/8980809.html)**

### Prerequisite knowledge:

**FFT**（必须知道的）

**模运算基本知识**

#### 原根的性质

现在考虑所有运算都在$mod P$意义下

设有正整数$g$，如果在$g$的次幂能够得到$<P$的任何正整数，那么称$g$是$Z_P^*$的**原根**，其中$Z_P^*$是模$P$乘法群，在这里不多作解释

**E.g **对于$P=7$，计算所有$<P$的正整数的次幂构成的集合

```
1-> {1}
2-> {1,2,4}
3-> {1,2,3,4,5,6}
4-> {1,2,4}
5-> {1,2,3,4,5,6}
6-> {1,6}
```

所以$3,5$就是$Z_7^*$的原根

在代码中，一般使用大质数$P=998244353,g=3$

原根的特点就是它的次幂以长度为$\phi(P)$循环

**E.g **$P=7,g=3$

那么$g$的次幂（从$g^0$）开始分别是：$1,3,2,6,4,5,1,3,2,6,4,5,\cdots$

这个特性和单位根非常相似

但是要完全替换单位根，还差一步

####单位根的代替品

在FFT中使用的是循环长度为$n$，且满足消去引理和求和引理的$n$次单位复数根（折半引理由消去引理推出，故不考虑）

所以为了让循环长度为$n$，我们不直接使用原根，而是原根的次幂

#### 离散对数定理：如果$g$是$Z_P^*$的一个原根，则$x\equiv y(\mod\phi(P))\iff g^x\equiv g^y(\mod P)$

**Proof: **设$x\equiv y(\mod\phi(P))$，则对某个整数$k$有$x=y+k\phi(P)$

因此$g^x\equiv g^{y+k\phi(P)} \equiv g^y (g^{\phi(P)})^k \equiv g^y 1^k \equiv g^y (\mod P)$（根据**欧拉定理**）

反过来，因为循环长度是$\phi(P)$，必定有$x\equiv y(\mod\phi(P))$

现在考虑有一个$g$的次幂$g^q$满足$g^q$的次幂以长度$n$循环

也就是说对任意整数$x\geqslant0,0<y<n$，有$g^{qx}\equiv g^{q(x+n)}\not\equiv g^{q(x+y)}(\mod P)$

即$qx\equiv q(x+n)\not\equiv q(x+y)(\mod \phi(P))$

即$0\equiv qn\not\equiv qy(\mod \phi(P))$

可得$\phi(P)|qn,\phi(P)\nmid qy$

那么为了使$q$的因数数量最小化，$q=\phi(P)/n$

此时$qy=\phi(P)y/n$

因为$y<n$，所以$qy<\phi(P)$，必定有$\phi(P)\nmid qy$

所以$q=\phi(P)/n$是可取的

那么问题来了，万一$\phi(P)/n$不是整数怎么办？

这就引出了大质数$P=998244353$的另一个性质：$\phi(P)=P-1=998244352=2^{23}\cdot 7\cdot 17$

而根据数据范围$n,m\leqslant1e6$，可知$l\leqslant 21$，所以$q$总是整数（真是一个神奇的数字）

总结一下，$g^{\phi(P)/n}=g^{\frac{P-1}{n}}$就是$\omega_n$的代替者

消去引理（只需考虑$d=2$的情况）和求和引理就请大家自己证明了（其实道理都非常相似）

最后只要把$\omega_n$替换掉，运算都改为模$P$意义下的运算即可，在算$-\omega_n$时要用到$g^{-1}=332748118$，还有最后答案别忘了$*s^{-1}$，上代码

```cpp
//This program is written by Brian Peng.
#pragma GCC optimize("Ofast","inline","no-stack-protector")
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define Rd(a) (a=read())
#define Gc(a) (a=getchar())
#define Pc(a) putchar(a)
int read(){
	register int u;register char c(getchar());register bool k;
	while(!isdigit(c)&&c^'-')if(Gc(c)==EOF)exit(0);
	if(c^'-')k=1,u=c&15;else k=u=0;
	while(isdigit(Gc(c)))u=(u<<1)+(u<<3)+(c&15);
	return k?u:-u;
}
void wr(register int a){
	if(a<0)Pc('-'),a=-a;
	if(a<=9)Pc(a|'0');
	else wr(a/10),Pc((a%10)|'0');
}
signed const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);
long long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);
#define Ps Pc(' ')
#define Pe Pc('\n')
#define Frn0(i,a,b) for(register int i(a);i<(b);++i)
#define Frn1(i,a,b) for(register int i(a);i<=(b);++i)
#define Frn_(i,a,b) for(register int i(a);i>=(b);--i)
#define Mst(a,b) memset(a,b,sizeof(a))
#define File(a) freopen(a".in","r",stdin),freopen(a".out","w",stdout)
#define P (998244353)
#define G (3)
#define Gi (332748118)
#define N (2100000)
int n,m,l,s,r[N],a[N],b[N],o,w,x,y,siv;
int fpw(int a,int p){return p?a>>1?(p&1?a:1)*fpw(a*a%P,p>>1)%P:a:1;}
void ntt(int*a,bool iv);
signed main(){
	Rd(n),Rd(m),siv=fpw(s=1<<(l=log2(n+m)+1),P-2);
	Frn1(i,0,n)Rd(a[i]);
	Frn1(i,0,m)Rd(b[i]);
	Frn0(i,0,s)r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	ntt(a,0),ntt(b,0);
	Frn0(i,0,s)a[i]=a[i]*b[i]%P;
	ntt(a,1);
	Frn1(i,0,n+m)wr(a[i]),Ps;
	exit(0);
}
void ntt(int*a,bool iv){
	Frn0(i,0,s)if(i<r[i])swap(a[i],a[r[i]]);
	for(int i(2),i2(1);i<=s;i2=i,i<<=1){
		o=fpw(iv?Gi:G,(P-1)/i);
		for(int j(0);j<s;j+=i){
			w=1;
			Frn0(k,0,i2){
				x=a[j+k],y=w*a[j+k+i2]%P;
				a[j+k]=(x+y)%P,a[j+k+i2]=(x-y+P)%P,w=w*o%P;
			}
		}
	}
	if(iv)Frn0(i,0,s)a[i]=a[i]*siv%P;
}
```

**Time complexity: $O(n\log n)$**

**Memory complexity: $O(n)$**

看看效果

![](https://images.cnblogs.com/cnblogs_com/BrianPeng/1640550/o_200202142044NTT.PNG)

时间上的提升效果不大，但是空间少了一半（因为用了int而不是complex）

### Conclusion: 

打了一天的博客终于写完了（好累）

但是对FFT和NTT的理解也加深了不少

这个算法对数学知识和分治思想的要求都很高

本蒟蒻花了近一年的时间才真正理解

如果有错误和意见请大佬多多指教

那么本篇博客就到这里啦，谢谢各位大佬的支持！ありがとう！


---

## 作者：derderhaoyue (赞：7)

# 快速傅里叶变换

## 序言 & FFT 简介

FFT，即快速傅里叶变换，是离散傅里叶变换的快速算法，可以用来显著的加快多项式乘法（将原来朴素算法的 $\Theta(n^2)$ 优化为 $\Theta(n\log(n))$），它的用处还有音频处理，图像滤波，调制解调等。

FFT 计算乘法的主要流程是先将系数表示法转化为点值表示法，然后再通过点值表示法计算完之后转化回系数表示法。

FFT 作为数论的一个重要板块，有着很多的前置知识，也有一定的思考难度，接下来就让我为大家分部分讲解 FFT 的前置知识与他本身。

## 前置知识

### 多项式的表示法

1. 系数表示法
   这种方法算得上是最常见的多项式表示法，一般的时候我们也用得最多，形如 $f(x)=\sum^{n}_{k=0}{a_kx^k}$。
   以这种方式计算多项式乘法时间复杂度为 $\Theta(n^2)$。

2. 点值表示法
   这种方法类似于初中的给几个点求函数解析式的情景，一个 $n$ 次多项式可以使用 $n+1$ 个点来表示出来，即这个多项式被点 $(x_1,y_1),(x_2,y_2),...,(x_{n+1},y_{n+1})$ 唯一表示。
   但是这样计算复杂度仍然为 $\Theta(n^2)$。

### 单位根

在讲单位根之前，我们先讲一下单位圆，单位圆就是以坐标轴为原点，半径为 1 的圆。
而单位根就是把一个圆 $n$ 等分，取这 $n$ 个点所表示的复数，就是这个圆的 $n$ 次单位根。

根据定义，找单位根的方法就呼之欲出啦：
先将一个圆 $n$ 等分，然后从 $(1,0)$（即 $\omega^1_n$）这个点开始逆时针编号，第 $k$ 个点所对应的复数为 $\omega^k_n$。

注：为了便于实现，下文中的 $n$ 将默认为 $2$

而根据复数的乘法法则可得：

$$(\omega^m_n)^k=\omega^{mk}_n$$

根据每个复数的幅角，可以计算出这个点的坐标，例如 $\omega^k_n$ 所对应的点为 $(\cos\frac{2k\pi}{n},\sin\frac{2k\pi}{n})$，也是复数 $\cos\frac{2k\pi}{n}+sin\frac{2k\pi}{n}\times i$。

接下来是单位根的性质：

1. $\omega^{2k}_{2n}=\omega^{k}_{n}$

证明：

$$\begin{aligned}\omega_{2n}^{2k} &= \cos\frac{4k\pi}{2n}+\sin\frac{4k\pi}{2n}\times i \\&= \cos\frac{2k\pi}{n}+\sin\frac{2k\pi}{n}\times i \\&= \omega_{n}^{k}\end{aligned}$$

2. $\omega^{k+n}_{n}=\omega^{k}_{n}$

证明：

$$\begin{aligned}\omega_{n}^{k + n} &= \cos\frac{2(k + n)\pi}{n} + \sin\frac{2(k + n)\pi}{n} \times i \\&= \cos(\frac{2k\pi}{n} + 2\pi) + (\sin\frac{2k\pi}{n} + 2\pi) \times i \\&= \cos\frac{2k\pi}{n} + \sin\frac{2k\pi}{n} \times i \\&= \omega_{n}^{k}\end{aligned}$$

3. $\omega^{k+\frac{n}{2}}_{n}=-\omega^{k}_{n}$

证明：

$$\begin{aligned}\omega^{k+\frac{n}{2}}_{n} &= \cos\frac{2(k+\frac{n}{2})\pi}{n}+\sin\frac{2(k+\frac{n}{2})\pi}{n}\times i \\&= \cos(\frac{2k\pi}{n}+\pi)+(\sin\frac{2k\pi}{n}+\pi)\times i \\&= -\cos\frac{2k\pi}{n}-\sin\frac{2k\pi}{n}\times i \\&= -\omega^{k}_{n}\end{aligned}$$

## FFT 推导（正确性证明）

假设一个 $n$ 次多项式：

$$F(x)=a_0+a_1\times x+a_2\times x^2\cdots a_{n-1}\times x^{n-1}$$

将它的下标按奇偶性分类，并设：

$$F_1=a_0+a_2\times x+a_4\times x^2\cdots+a_{n-2}\times x^{\frac{n}{2}-1}$$

$$F_2=a_1+a_3\times x+a_5\times x^2\cdots+a_{n-1}\times x^{\frac{n}{2}-1}$$

则有

$$F(x)=F_1(x^2)+xF_2(x^2)$$

分别将 $\omega^k_n$ 与 $\omega^{k+\frac{n}{2}}_{n}$ 代入得

$$\begin{aligned}F(\omega^k_n) &= F_1(\omega^{2k}_n)+\omega^k_nF_2(\omega^{2k}_n)\\&= F_1(\omega^{k}_{\frac{n}{2}})+\omega^k_nF_2(\omega^{k}_{\frac{n}{2}})\end{aligned}$$

和

$$\begin{aligned}
F(\omega^{k+\frac{n}{2}}_{n})&=F_1(\omega^{2k+n}_{n})+\omega^{k+\frac{n}{2}}_{n}F_2(\omega^{2k+n}_{n})\\&=F_1(\omega^{2k}_{n})-\omega^k_nF_2(\omega^{2k+n}_{n})\\&=F_1(\omega^{k}_{\frac{n}{2}})-\omega^{k}_{n}F_2(\omega^{k}_{\frac{n}{2}})\end{aligned}$$

这两个式子长得极为相像，仅有一个常数的差距，意味着我们只需要求一半便可得知另一半的结果，如果我们将 $F_1$ 与 $F_2$ 也这么递归地计算下去，就可以得到递归版的代码，由于每层递归是 $\Theta(n)$ 的并且由于每递归一次会少一半运算量，所以递归层数为 $\Theta(\log(n))$，总复杂度为 $\Theta(n\log(n))$。
但是，这样写常数巨大，十分的慢，这时候就要请出一个天才般的想法了，接下来，请观察分组前后的数组（以 $n=8$ 为例）：
前：$\{0,1,2,3,4,5,6,7\}$
后：$\{0,4,2,6,1,5,3,7\}$
好像没什么规律？
转化成二进制下试试！

$$\{(000)_2,(001)_2,(010)_2,(011)_2,(100)_2,(101)_2,(110)_2,(111)_2\}$$

$$\{(000)_2,(100)_2,(010)_2,(110)_2,(001)_2,(101)_2,(011)_2,(111)_2\}$$

这不就是将分组前的数组每个数给翻转了吗，这样，我们就可以将翻转后的数组计算出来啦。
但，为什么可以这样呢？
证明：
设 $F(m,k)$ 表示一个序列中从 $0$ 到 $2^m-1$ 中第 $k$ 个位置被分组后的位置。
现在将 $k$ 按奇偶性分类讨论：

1. 若 $k$ 为奇数，则将其右移一位，并将它的二进制表示下的第 $n-1$ 位修改成 $1$。

2. 若 $k$ 为偶数，则将其右移一位，并将它的二进制表示下的第 $n-1$ 位修改成 $0$。

于是可得：

$$\begin{aligned}F(m,k) &=(k\&1)2^{n - 1}+((k\gg1)\&1)2^{n - 2}+\cdots+((k\gg n - 1)\&1)2^{0}\\&=\sum_{i = 0}^{n - 1}((k\gg i)\&1)2^{n - i - 1}\end{aligned}$$

即将 $k$ 的二进制表示翻转。
于是就有了迭代版的代码：

```cpp
for(int mid=1;mid<lim;mid<<=1){
        complex wn(cos(pie/mid),oper*sin(pie/mid));
        for(int R=mid<<1,j=0;j<lim;j+=R){
            complex w(1,0);
            for(int k=0;k<mid;k++,w=w*wn){
                complex y=x[j+k],z=w*x[j+mid+k];
                x[j+k]=y+z;
                x[j+mid+k]=y-z;
            }
        }
    }
```

但这还没完，还有要将点值表示法转回点值表示法的步骤没有完成，这就需要 IFFT（快速傅里叶逆变换）登场了。
使用矩阵来理解 IFFT 是一种比较简单的理解方式，从矩阵的角度看我们刚才的计算，实际上就是在进行如下操作：
$$\begin{bmatrix}F_0\\F_1\\F_2\\\vdots\\F_{n-1}\end{bmatrix}=\begin{bmatrix}1&1&1&\cdots&1\\1&\omega^{1}_{n}&\omega^{2}_{n}&\cdots&\omega^{n-1}_{n}\\1&\omega^{2}_{n}&\omega^{4}_{n}&\cdots&\omega^{2(n-1)}_{n}\\\vdots&\vdots&\vdots&\ddots&\vdots\\1&\omega^{n-1}_{n}&\omega^{2(n-1)}_{n}&\cdots&\omega^{(n-1)^2}_{n}\end{bmatrix}\begin{bmatrix}a_0\\a_1\\a_2\\\vdots\\a_{n-1}\end{bmatrix}$$
现在，我们已经完成了求左边式子的值这个任务，而中间的值在多项式的点值表示法中也是一一对应的，接下来只需要在两边左乘中间矩阵的逆矩阵即可。（因为矩阵乘法不满足交换律，所以把一个矩阵乘在另一个矩阵的左边和右边结果不同，乘在左边就是左乘）
>由于这个矩阵的元素非常特殊，它的逆矩阵也有特殊的性质，就是每一项取倒数，再除以变换的长度 $n$，就能得到它的逆矩阵。

——引用自 oi wiki。
在代码实现上就是将原来 FFT 的单位根替换为它的倒数，然后计算出结果再除以 $n$ 就好了。

## 实现代码

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int M=1e7+5e3;
const double pie=acos(-1.0);
struct comp{// 手打复数，避免被卡（其实一般也没有人来卡这个吧）。
    double real,img;
    comp(double xx=0,double yy=0){
        real=xx;
        img=yy;
    }
    comp operator + (const comp b)const{ 
        return comp(real+b.real , img+b.img);
    }
    comp operator - (const comp b)const{ 
        return comp(real-b.real , img-b.img);
    }
    comp operator * (const comp b)const{ 
        return comp(real*b.real-img*b.img , real*b.img+img*b.real);
    }
}f[M],g[M];
int n,m,l,lim=1;
int r[M];
void fft(comp *F,int oper){// oper 是操作，传入 1 是FFT，-1 是 IFFT。
    for(int i=0;i<lim;i++){
        if(i>r[i]-1){
            continue;
        }
        swap(F[i],F[r[i]]);
    }
    for(int mid=1;mid<lim;mid<<=1){
        comp wn(cos(pie/mid),oper*sin(pie/mid));
        for(int R=mid<<1,j=0;j<lim;j+=R){
            comp w(1.0,0.0);
            for(int k=0;k<mid;k++,w=w*wn){
                comp y=F[j+k],z=w*F[j+mid+k];
                F[j+k]=y+z;
                F[j+mid+k]=y-z;
            }
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=0;i<=n;i++){
        scanf("%lf",&f[i].real);
    }
    for(int i=0;i<=m;i++){
        scanf("%lf",&g[i].real);
    }
    while(lim<n+m+1){
        lim<<=1;
        l++;
    }
    for(int i=0;i<lim;i++){
        r[i]=((r[i>>1]>>1)|((i&1)<<(l-1)));
    }
    fft(f,1);
    fft(g,1);
    for(int i=0;i<lim;i++){
        f[i]=f[i]*g[i];
    }
    fft(f,-1);
    for(int i=0;i<n+m+1;i++){
        printf("%d ",(int)(f[i].real/lim+0.5));// 防止精度爆炸。
    }
    return 0;
}
```

## 参考资料

[oi wiki](https://oi-wiki.org/math/poly/fft/) （部分内容参考与代码参考）。

[attcak大佬的文章](https://www.luogu.com.cn/article/n4lyqp5s) （代码参考）。

[_不会dp不改名_大佬的文章](https://ltnotfty.blog.csdn.net/article/details/143757440?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7Ebaidujs_baidulandingword%7ECtr-3-143757440-blog-114287897.235%5Ev43%5Econtrol&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7Ebaidujs_baidulandingword%7ECtr-3-143757440-blog-114287897.235%5Ev43%5Econtrol&utm_relevant_index=5) （位逆序置换证明参考）。

---

## 作者：NashChen (赞：6)

# 快速傅里叶变换
update:2020.7.29 增加了三次变两次优化

## 【预告】
* 代码奇短
* 大量公式推导
## 【前言】

在解决多项式卷积(乘法)的问题时,直接相乘的$O(n^2)$做法似乎找不到优化的余地。

这时，我们就需要寻找其它的路径来计算卷积。

众所周知,二维坐标系上横坐标互异的$n$个点可以确定一个$n-1$次函数。

与用各项系数表示多项式的系数表示法不同，用点表示一个多项式的方法叫点值表示法。

离散傅里叶变换($DFT$,$Discrete$ $Fourier$ $Transformation$)指的是多项式由系数表示法转为点值表示法的过程。

相对地，把一个多项式的点值表示法转化为系数表示法的过程，就是离散逆傅里叶变换($IDFT$)。

快速傅里叶变换($Fast$ $Fourier$ $Transformation$)指的是在执行$DFT$和$IDFT$时通过代入特殊的值加速过程的一种算法。
## 【前置知识】

1. 三角函数(不讲)

2. 复数运算(不讲)

3. 复平面及单位根(不想讲,百度有)

## 【数学推导部分】
首先,我们来看看单位根的性质

* $\omega_n^k=cos\frac{2k\pi}{n}+isin\frac{2k\pi}{n}$
   
* $\omega_{2n}^{2k}=\omega_n^k$
   
* $\omega_{n}^{k+n}=cos\frac{2(k+n)\pi}{n}+isin\frac{2(k+n)\pi}{n}=cos(\frac{2k\pi}{n}+2\pi)+isin(\frac{2k\pi}{n}+2\pi)$
   
  $=cos\frac{2k\pi}{n}+isin\frac{2k\pi}{n}=\omega_n^k$
   
* $\omega_{n}^{k+\frac{n}{2}}=cos\frac{2(k+\frac{n}{2})\pi}{n}+isin\frac{2(k+\frac{n}{2})\pi}{n}=cos(\frac{2k\pi}{n}+\pi)+isin(\frac{2k\pi}{n}+\pi)$
   
   $=-cos\frac{2k\pi}{n}-isin\frac{2k\pi}{n}=-\omega_n^k$
   
再看看这个多项式
   
   为了方便讨论,以下提及的多项式的长度$n$均为$2$的整数次幂,即多项式次数为$n-1$,不够就往高位补$0$。
   
   我们在DFT中,其实要计算的的是
   
* $F(x_0)=a_{0}+a_1x_0+a_2x_0^2+...+a_{n-2}x_0^{n-2}+a_{n-1}x_0^{n-1}$
   
   $F(x_1)=a_{0}+a_1x_1+a_2x_1^2+...+a_{n-2}x_1^{n-2}+a_{n-1}x_1^{n-1}$
   
   $F(x_2)=a_{0}+a_1x_2+a_2x_2^2+...+a_{n-2}x_2^{n-2}+a_{n-1}x_2^{n-1}$
   
   ... ...
   
   $F(x_{n-1})=a_{0}+a_1x_{n-1}+a_2x_{n-1}^2+...+a_{n-2}x_{n-1}^{n-2}+a_{n-1}x_{n-1}^{n-1}$
   
   
观察每一个$n-1$次的多项式:
   
* $F(x)=a_{0}+a_1x+a_2x^2+...+a_{n-2}x^{n-2}+a_{n-1}x^{n-1}$
   
按次数奇偶性分类,设
   
* $G(x)=a_0+a_2x+a_4x^2+...+a_{n-4}x^{\frac{n}{2}-2}+a_{n-2}x^{\frac{n}{2}-1}$
   
* $H(x)=a_1+a_3x+a_5x^2+...+a_{n-3}x^{\frac{n}{2}-2}+a_{n-1}x^{\frac{n}{2}-1}$
   
可以得到
   
* $F(x)=a_0+a_2x^2+...+a_{n-2}x^{n-2}+a_1x+a_3x^3...+a_{n-1}x^{n-1}$
   
   $=H(x^2)+xG(x^2)$
   
不妨把单位根 $\omega_n^k (k<\frac{n}{2})$ 代进去看看
   
* $F(\omega_n^k)=H(\omega_n^{2k})+\omega_n^kG(\omega_n^{2k})$
   
   $=H(\omega_{\frac{n}{2}}^k)+\omega_n^kG(\omega_{\frac{n}{2}}^k)$
   
再代一个 $\omega_{n}^{k+\frac{n}{2}}$
   
* $F(\omega_n^{k+\frac{n}{2}})=H(\omega_n^{2k+n})+\omega_n^{k+\frac{n}{2}}G(\omega_n^{2k+n})=H(\omega_n^{2k})-\omega_n^kG(\omega_n^{2k})$
   
   $=H(\omega_{\frac{n}{2}}^k)-\omega_n^kG(\omega_{\frac{n}{2}}^k)$
   
还没发现问题?我把要求的式子再列出来

------------

* $F(\omega_n^0)=H(\omega_\frac{n}{2}^0)+\omega_n^0G(\omega_\frac{n}{2}^0)$
   
* $F(\omega_n^1)=H(\omega_\frac{n}{2}^1)+\omega_n^1G(\omega_\frac{n}{2}^1)$
   
   ... ...
   
* $F(\omega_n^{\frac{n}{2}-1})=H(\omega_{\frac{n}{2}}^{\frac{n}{2}-1})+\omega_n^{\frac{n}{2}-1}G(\omega_{\frac{n}{2}}^{\frac{n}{2}-1})$
   
------------

* $F(\omega_n^\frac{n}{2})=H(\omega_\frac{n}{2}^0)-\omega_n^0G(\omega_\frac{n}{2}^0)$
   
* $F(\omega_n^{\frac{n}{2}+1})=H(\omega_\frac{n}{2}^1)-\omega_n^1G(\omega_\frac{n}{2}^1)$
   
   ... ...
   
* $F(\omega_n^{n-1})=H(\omega_{\frac{n}{2}}^{n-1})-\omega_n^{n-1}G(\omega_{\frac{n}{2}}^{n-1})$

------------

计算一半就能知道另一半的结果
  
原来$O(n^2)$的时间就会变成$O(\frac{n^2}{2})$
   
如果用递归来完成每一步这样的操作,将$G(x)$和$H(x)$的系数也这样计算,由于递归树中的每一层分类、计算的总量复杂度是$O(n)$,递归树最多$logn$层,所以这样就可以实现$O(nlogn)$计算这$n$个值了

递归式可以写出来。经过若干次分组之后,当前计算的多项式的长度变为$2^t$,设当前要计算的多项式为$G_t(x)$(也有可能是$H_t(x)$)

**每层递归**中只需要写成下面这样

$G_t(\omega_n^k)=G_{t-1}(\omega_\frac{n}{2}^k)+\omega_n^kH_{t-1}(\omega_\frac{n}{2}^k)$

$G_t(\omega_n^{k+\frac{n}{2}})=G_{t-1}(\omega_\frac{n}{2}^k)-\omega_n^kH_{t-1}(\omega_\frac{n}{2}^k)$

其中$G_0(k)=a_k\omega_n^k$，$k$为图中编号而不是下标

如下图,以$n=8$为例,每一层进行分组,按上面的结论计算,蓝色代表相加,红色代表相减

![FFT1](https://s2.ax1x.com/2019/12/23/l9Se6s.png)

不废话了,先来看看代码

顺便给出一个复数数据类型模板

```
const double pi=acos(-1.0);
struct Cplx{
	double Re,Im;
	Cplx(double p=0,double q=0):Re(p),Im(q){}
	Cplx operator + (const Cplx &a) const {return Cplx(Re+a.Re,Im+a.Im);}
	Cplx operator - (const Cplx &a) const {return Cplx(Re-a.Re,Im-a.Im);}
	Cplx operator * (const Cplx &a) const {return Cplx(Re*a.Re-Im*a.Im,Re*a.Im+Im*a.Re);}
}A[MAXN],B[MAXN],C[MAXN];
void FFT(Cplx *a,int n){
	if(n==1) return;
	int m=n>>1;Cplx a1[m],a2[m];
	for(int i=0;i<m;i++){//分类
		a1[i]=a[i<<1];
		a2[i]=a[i<<1|1];
	}
	FFT(a1,m);FFT(a2,m);//递归
	Cplx w1=Cplx(cos(2.0*pi/n),sin(2.0*pi/n)),wk=Cplx(1,0);
	for(int i=0;i<m;i++,wk=wk*w1){//计算
		a[i]=a1[i]+wk*a2[i];
		a[i+m]=a1[i]-wk*a2[i];
	}
	return;
}
```

讲了这么久,终于讲完了$DFT$,接下来就是$IDFT$

经过一波神奇的操作,$IDFT$的代码可以变得和$DFT$的代码相似度高达$84.946\%$

以下是公式推导时间

刚刚我们利用系数$a_0,a_1,...,a_{n-1}$计算出了$F(\omega_n^0),F(\omega_n^1),...,F(\omega_n^{n-1})$

相当于计算了序列$\{b_k\}$,其中$b_k=\sum\limits_{i=0}^{n-1}a_i(\omega_n^k)^i$

再尝试一下对$b_0,b_1,...,b_{n-1}$,将$\omega_n^k$换成$\omega_n^{-k}$再试一下

设一条序列$\{c_k\}$,其中$c_k=\sum\limits_{j=0}^{n-1}b_j(\omega_n^{-k})^j$

那么

$c_k=\sum\limits_{j=0}^{n-1}(\sum\limits_{i=0}^{n-1}a_i(\omega_n^j)^i)(\omega_n^{-k})^j$

$=\sum\limits_{j=0}^{n-1}(\sum\limits_{i=0}^{n-1}a_i(\omega_n^i)^j)(\omega_n^{-k})^j$

$=\sum\limits_{j=0}^{n-1}\sum\limits_{i=0}^{n-1}a_i(\omega_n^i)^j(\omega_n^{-k})^j$

$=\sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{n-1}a_i(\omega_n^i)^j(\omega_n^{-k})^j$

$=\sum\limits_{i=0}^{n-1}(a_i\sum\limits_{j=0}^{n-1}(\omega_n^{i-k})^j)$

我们先看看这条式子$S(x)=\sum\limits_{j=0}^{n-1}(\omega_n^{i-k})^j$

当$i=k$时显然有$S(x)=n$

当$i\not=k$根据单位根的几何性质显然有$S(x)=0$

所以$c_k=\sum\limits_{i=0}^{n-1}[i=k]na_i=na_k$

$a_k=\frac{c_k}{n}$

设对于序列的运算$FFT(\{a_k\})=\{\sum\limits_{k=0}^{n-1}a_k\omega_n^k\}$

$FFT^{-1}(\{a_k\})=\{\sum\limits_{k=0}^{n-1}a_k\omega_n^{-k}\}$

有$FFT^{-1}(FFT(\{a_k\}))=\{na_k\}$

至此,DFT和IDFT我们都找到了办法来实现

$Quod$ $Erat$ $Demonstrandum$
## 【递归实现代码】
先上一个AC不了模板题的递归代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;

const double pi=acos(-1.0);
const int MAXN=5000005;
struct Cplx{
	double Re,Im;
	Cplx(double p=0,double q=0):Re(p),Im(q){}
	Cplx operator + (const Cplx &a) const {return Cplx(Re+a.Re,Im+a.Im);}
	Cplx operator - (const Cplx &a) const {return Cplx(Re-a.Re,Im-a.Im);}
	Cplx operator * (const Cplx &a) const {return Cplx(Re*a.Re-Im*a.Im,Re*a.Im+Im*a.Re);}
}A[MAXN],B[MAXN],C[MAXN];
int N,M,L;
void FFT(Cplx *a,int n,int d){
	if(n==1) return;
	int m=n>>1;Cplx a1[m],a2[m];
	for(int i=0;i<m;i++){
		a1[i]=a[i<<1];
		a2[i]=a[i<<1|1];
	}
	FFT(a1,m,d);FFT(a2,m,d);
	Cplx w1=Cplx(cos(2.0*pi/n),d*sin(2.0*pi/n)),wk=Cplx(1,0);
	for(int i=0;i<m;i++,wk=wk*w1){
		a[i]=a1[i]+wk*a2[i];
		a[i+m]=a1[i]-wk*a2[i];
	}
	return;
}
void Input(){
	scanf("%d%d",&N,&M);
	for(int i=0;i<=N;i++) scanf("%lf",&A[i].Re);
	for(int i=0;i<=M;i++) scanf("%lf",&B[i].Re);
	for(L=1;L<N+M+1;L<<=1);
	return;
}
int main(){
	Input();
	FFT(A,L,1);
	FFT(B,L,1);
	for(int i=0;i<=L;i++)
		C[i]=A[i]*B[i];
	FFT(C,L,-1);
	for(int i=0;i<=N+M;i++)
		printf("%d ",(int)(C[i].Re/L+0.5));
	return 0;
}
```

## 【迭代优化】

复杂度没错,是$O(nlogn)$，为甚会TLE?

我们需要一点小小的优化

再回来看看这个图

![FFT1](https://s2.ax1x.com/2019/12/23/l9Se6s.png)

我们发现

1. 可以先把多项式的系数排成图中最下面一层的顺序,再自底向上运算

2. 计算时只会用到向下一层的数,完全可以只用同一个数组覆盖着计算

关于第一点,我们发现有一种神奇的方法可以$O(n)$计算出最底层的顺序

还是以$n=8$为例

最底层是$\{rnk_i\}=\{0,4,2,6,1,5,3,7\}$

恰好是$\{0,1,2,3,4,5,6,7\}$在二进制下的反转

像这样

$(000)_2,(001)_2,(010)_2,(011)_2,(100)_2,(101)_2,(110)_2,(111)_2$

$(000)_2,(100)_2,(010)_2,(110)_2,(001)_2,(101)_2,(011)_2,(111)_2$

根据这个原理,我们可以计算出$\{rnk_i\}$数组

先看一条式子,也许你就会$O(n)$计算$\{rnk_i\}$了

$rnk_i=rnk_\frac{n}{2}*2+[i \mod 2]$

没错!这样算就是$rnk_i=i$

只要反过来

$rnk_i=rnk_\frac{n}{2}/2+(n/2)*[i \mod 2=1]$

就行了。不信自己推

并且在将系数排成$\{rnk_i\}$时这样写

```cpp
for（int i=0;i<=n-1;i++)
	if(rnk[i]>i) swap(a[i],a[rnk[i]]);
```

就可以了

只要我们第一层循环枚举当前要合并的区间长度$n$

第二层枚举完每一个要合并的区间,其中$i$是当前处理的区间的左端点

再像递归的做法那样在$[i,i+\frac{n}{2}]$里枚举$j$

令$t1=a[j],t2=a[j+\frac{n}{2}]*\omega_n^k$

$a[j]=t1+t2,a[j+\frac{n}{2}]=t1-t2;$

详情看代码
```cpp
for(int n=2;n<=L;n<<=1){
	Cplx w1(cos(2.0*pi/n),d*sin(2.0*pi/n));
	for(int i=0;i<L;i+=n){
		Cplx wk(1,0);
		for(int j=i;j<i+(n>>1);j++,wk=wk*w1){
			Cplx t1=a[j],t2=a[j+(n>>1)]*wk;
			a[j]=t1+t2;
			a[j+(n>>1)]=t1-t2;
		}
	}
}
```

## FFT特色：三次变两次优化

将B放到A的虚部上，得到

$$a+bi$$

用FFT计算它的平方，得

$$(a+bi)^2=(a^2-b^2)+(2ab)i$$

结果的虚部/2就是答案了。别忘了除以L。

这样可以少做一次FFT，常数小。

### 【模板代码】Luogu P3803

注意一下细节就能AC了
```cpp
//Fast Fourier Transformation
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;

const int MAXN=4000005;
const double pi=acos(-1.0);
struct Cplx{
	double Re,Im;
	Cplx(double re=0,double im=0):Re(re),Im(im){}
	Cplx operator + (const Cplx &a) const {return Cplx(Re+a.Re,Im+a.Im);}
	Cplx operator - (const Cplx &a) const {return Cplx(Re-a.Re,Im-a.Im);}
	Cplx operator * (const Cplx &a) const {return Cplx(Re*a.Re-Im*a.Im,Re*a.Im+Im*a.Re);}
}A[MAXN],B[MAXN],C[MAXN];
int N,M,L,rnk[MAXN];

void Input(){
	scanf("%d%d",&N,&M);
	for(int i=0;i<=N;i++) scanf("%lf",&A[i].Re);
	for(int j=0;j<=M;j++) scanf("%lf",&B[j].Re);
	for(L=1;L<N+M+1;L<<=1);
	for(int i=1;i<L;i++){
		rnk[i]=(rnk[i>>1]>>1);
		if(i&1) rnk[i]|=(L>>1);
	}
	return;
}

void FFT(Cplx *a,int d){
	for(int i=0;i<L;i++)
		if(i<rnk[i]) swap(a[i],a[rnk[i]]);
	for(int n=2;n<=L;n<<=1){
		Cplx w1(cos(2.0*pi/n),d*sin(2.0*pi/n));
		for(int i=0;i<L;i+=n){
			Cplx wk(1,0);
			for(int j=i;j<i+(n>>1);j++,wk=wk*w1){
				Cplx t1=a[j],t2=a[j+(n>>1)]*wk;
				a[j]=t1+t2;
				a[j+(n>>1)]=t1-t2;
			}
		}
	}
	return;
}

void mul1(){
	FFT(A,1);FFT(B,1);
	for(int i=0;i<L;i++)
		C[i]=A[i]*B[i];
	FFT(C,-1);
	for(int i=0;i<=N+M;i++)
		printf("%d ",(int)(C[i].Re/L+0.5));
	return;
}

//(a+bi)^2=(a^2-b^2)+(2ab)i
void mul2(){
	for(int i=0;i<L;i++)
		A[i].Im=B[i].Re;
	FFT(A,1);
	for(int i=0;i<L;i++)
		C[i]=A[i]*A[i];
	FFT(C,-1);
	for(int i=0;i<=N+M;i++)
		printf("%d ",(int)(C[i].Im/L/2.0+0.5));
	return;
}

int main(){
	Input();
	mul2();
	return 0;
}
```

---

## 作者：Mihari (赞：5)

# 「学习笔记」FFT 快速傅里叶变换

几个星期之后，继 **扩展欧拉定理** 之后， $lj$ 大佬又给我们来了一发数论...

虽然听得心态爆炸， 但是还好的是没有 $ymx$ 大佬的飞机开得好...

至少我还没有坐飞机...

## 啥是 FFT 呀？它可以干什么？

> 首先，你需要知道 **矩阵乘法** 的相关知识。

通过 **矩阵乘法** 的知识，我们知道，对于一个 $f(x)$ 与 $g(x)$ ，如果我们用朴素的矩阵乘法计算 $f(x)\cdot g(x)$ ，时间复杂度是 $O(N^2M)$ ，但是对于这是函数，复杂度中的 $M=1$ ，那么时间复杂度为 $O(N^2)$ 。

似乎这是比较优秀的，但是看看这道 **板题** ：

[luoguOJ:P3803【模板】多项式乘法（FFT）](https://www.luogu.com.cn/problem/P3803)

嗯？ $n,m\le 10^6$ ，似乎过于太小了？~~（不要管这病句...）~~

**而 FFT 就是用来解决多项式乘法的问题的，可以把它的时间复杂度优化到 $O(nlog^n_2)$ 。**

这里引用一句话：

> 实际上，FFT 并不是直接计算多项式乘法，而是把原来的多项式 $f(x),g(x)$ 在 $O(nlog^n_2)$ 的复杂度内转换为它的 <u>点值表示</u>（后面会讲），而点值表示的多项式相乘的时间复杂度是 $O(n)$ 的。最后再用 $O(nlog_2^n)$ 的时间复杂度把所得多项式的点值表示转化为一般形式。

-----

## 必备芝士

在学习 FFT 之前，我们需要知道 **点值表示** 和 **复数** 。

### 点值表示

#### 什么是点值表示

对于一个函数 $f(x)$ ，我们可以用一个多项式表示它：

$$f(x)=a_nx^n+a_{n-1}x^{n-1}+...+a_{1}x+a_0$$

这种表达方法我们叫做 **一般形式** 。

如果熟悉，那么可以确定一个东西，如果我们有在这个函数上的 $n+1$ 个点的具体的坐标 $(x_i,y_i)$ ，那么我们就可以**唯一确定**这个函数的解析式，那么，我们也可以用这 $n+1$ 个点的具体坐标来表示这个多项式。

当然，如果知道 **拉格朗日插值法** 的大佬，或许可以更好地理解这句话。

也就是说一个多项式与一个点值表示是一一对应的。 

> 那么 FFT 完成的操作就是： 
>
> - 把已知的一个多项式转化成对应的点值表示； 
> - 把已知的点值表示转换成对应的多项式。 
>
> 复杂度都是 $O(nlog_2^n)$ 。 

#### 点值表示的乘法

那么，假设我们用 $\{x_0,x_1,x_2,...,x_n\}$ 来表示 $f(x)$ 为 $\{(x_0,f(x_0)),(x_1,f(x_1)),...,(x_n,f(x_n))\}$ ，表示 $g(x)$ 为 $\{(x_0,g(x_0)),(x_1,g(x_1)),...,(x_n,g(x_n))\}$ 。

那么我们就知道 $f(x)\cdot g(x)$ 的点值表达式为 $\{(x_0,f(x_0)\cdot g(x_0)),...,(x_n,f(x_n)\cdot g(x_n))\}$ ，其实就是对应项相乘，那么这个的时间复杂度为 $O(n)$ ，似乎可以接受。

-----

### 复数

#### 复数的定义

$Hint.$ 是 **复数(complex)** 而不是 **负数(negative)** 。

首先我们要知道 **虚数** ，即有一个很特别的数 $i$ ，满足 $i^2=-1$ ，即 $i=\sqrt{-1}$ 。

不用理解为什么，因为他本来就是特殊定义的，只需要记住就好。

然后一个复数 $a$ 可以表示为实部 $x$ 和虚部 $y\times i$ 之和—— $a=x+y\times i$ 。对于一个实数，我们可以把它放在“一维数轴”上，即数轴；那么对于一个复数，我们需要把它放在“二维数轴”，也就是直角坐标系上。

其实，我们可以把 $a$ 表示成 **向量(vector)** 的形式，即将 $a=x+y\times i$ 表示为向量 $(x,y)$ ，但是对于后面虚数的乘法，其实是不满足向量乘法的，但是这可以作为一个理解方式。

#### 复数的乘法运算

对于两个虚数 $a,b$ ，其中 $a=x+y\times i,b=x'+y'\times i$ ，计算 $ab$ 。

我们有两种方法：

1. 可以直接展开相乘： $ab=(x+yi)(x'+y'i)=(xx'-yy')+(xy'+x'y)i$ 。
2. 可以从几何角度理解：两个复数相乘等于“幅角相加，模长相乘”（但并不满足向量的运算）

更推荐就用方法一来理解。

#### 单位复数

> $Hint.$ 复数的模长 $|a|$ （这个不是绝对值），表示把它表示成向量后的长度，即 $|a|=\sqrt{x^2+y^2}$ 。

我们定义 $n$ 次单位复根 $\omega_n^i$ 为满足 $\text{z}^n=1$ 的复数 $\text{z}$ 。

>本人的理解方法：单位复根 $\omega_n^i$ 即为将一个**单位圆**分成 $n$ 分，而 $\omega_n^i$ 就是 $i$ 个这样的角拼起来。特别地， $\omega_n^0=1$ 。
>
>其实，之后的理解都可以通过 **三角函数** 有更好的理解

可以发现 $n$ 次单位复根满足以下性质（ $\omega_n^i$ 表示第 $i$ 个单位复根）：

- $|\omega_n^i|=1$ （都在单位圆上）；
-  $\omega_n^i$ 的幅角为 $\frac{2\pi i}{n}$ ；$Tab.$ 这里的 $i$ 是下标不是虚数，角度为弧度制（ $360^{\circ}$ 弧度角为 $2\pi$ ）
- 总共有 $n$ 个单位复根，记为 $\omega_n^0,\omega_n^1,\omega_n^2,...,\omega_n^{n-1}$

另外，还有一些比较明显的性质：

- $\omega_n^i\cdot\omega_n^j=\omega_n^{i+j}$ ；
- $\omega_n^{i+n}=\omega_n^i$ ；
- $\omega_n^i=\omega_{kn}^{ki}$ ；
- $\omega_n^i=-\omega_n^{i+n/2}$ （这里的“负”表示大小相等、方向相反） 

**以上这些结论都可以通过在单位圆上画出单位根来证明。**

单位复根有什么用呢？因为 $n$ 次单位复根恰好有 $n$ 个，就可以把这 $n$ 个单位复根分别代入 $n-1$ 次多项式 $f(x)$ —— 得到点值表达 $\{(\omega_n^0,f(\omega_n^0)),(\omega_n^1,f(\omega_n^1)),...,(\omega_n^{n-1},f(\omega_n^{n-1}))\}$ 。

## 傅立叶正变换

有了这些辅助知识 ~~没错，虽然你可能已经晕了，但是他们真的只是辅助知识~~ ，我们终于可以进行正题了。

所谓变换，那么一定有正也有逆，现在我我们先来掌握它的正变换。

FFT 的正变换实现，是基于对多项式进行奇偶项分开递归再合并的分治进行的。

对于 n-1 次多项式，我们选择插入 n 次单位根求出其点值表达式。

记多项式 $A(x)=a_0+a_1x+a_2x^2+...+a_{n-1}x^{n-1}$ 。

再记 $A_o(x)=a_1+a_3x+a_5x^2+...$ 。

再记 $A_e(x)=a_0+a_2x+a_4x^2+...$ 。

有 $A(x)=x*A_o(x^2)+A_e(x^2)$ 。

令 $n = 2*p$ 。则有：

$A(w_n^k)=w_n^k*A_o[(w_{n/2}^{k/2})^2]+A_e[(w_{n/2}^{k/2})^2]=w_n^k*A_o(w_p^k)+A_e(w_p^k)$ ；

$A(w_n^{k+p})=w_n^{k+p}*A_o(w_p^{k+p})+A_e(w_p^{k+p})=-w_n^k*A_o(w_p^k)+A_e(w_p^k)$

在已知  $A_o(w_p^k)$ 与  $A_e(w_p^k)$ 的前提下，可以 $O(1)$ 算出  $A(w_n^k)$ 与  $A(w_n^{k+p})$ 。

因此，假如我们递归求解 $A_o(x),A_e(x)$ 两个多项式 $p$ 次单位根的插值，就可以在 $O(n)$ 的时间内算出 $A(x)$ n 次单位根的插值。

时间复杂度是经典的 $T(n)=2*T(n/2)+O(n)=O(n\log n)$。

## 傅里叶逆变换

刚刚研究完正的，现在我们来研究逆变换，其实也比较好理解。

观察我们刚刚的插值过程，实际上就是进行了如下的矩阵乘法。

$$
\begin{bmatrix} (w_n^0)^0 & (w_n^0)^1 & \cdots & (w_n^0)^{n-1} \\ (w_n^1)^0 & (w_n^1)^1 & \cdots & (w_n^1)^{n-1} \\ \vdots & \vdots & \ddots & \vdots \\ (w_n^{n-1})^0 & (w_n^{n-1})^1 & \cdots & (w_n^{n-1})^{n-1} \end{bmatrix} \begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_{n-1} \end{bmatrix} = \begin{bmatrix} A(w_n^0) \\ A(w_n^1) \\ \vdots \\ A(w_n^{n-1}) \end{bmatrix}
$$

我们记上面的系数矩阵为 $V$ 。

对于下面定义的 $D$ ：

$$
D = \begin{bmatrix} (w_n^{-0})^0 & (w_n^{-0})^1 & \cdots & (w_n^{-0})^{n-1} \\ (w_n^{-1})^0 & (w_n^{-1})^1 & \cdots & (w_n^{-1})^{n-1} \\ \vdots & \vdots & \ddots & \vdots \\ (w_n^{-(n-1)})^0 & (w_n^{-(n-1)})^1 & \cdots & (w_n^{-(n-1)})^{n-1} \end{bmatrix}
$$

考虑 $D*V$ 的结果：

$$
(D*V)_{ij}
=\sum_{k=0}^{k<n}d_{ik}*v_{kj}
=\sum_{k=0}^{k<n}w_n^{-ik}*w_{n}^{kj}
=\sum_{k=0}^{k<n}w_n^{k(j-i)}
$$

 当 $i = j$ 时， $(D*V)_{ij}=n$ ；

 当 $i ≠ j$ 时， $(D*V)_{ij}=1+w_n^{j-i}+(w_n^{j-i})^2+...=\frac{1-(w_n^{j-i})^n}{1-w_n^{j-i}}=0$ ；

> 根据定义， $n$ 次单位根的 $n$ 次方都等于 $1$ 

所以：$\frac1n*D=V^{-1}$

 因此将这个结果代入最上面那个公式里面，有：

$$
\begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_{n-1} \end{bmatrix} = \frac1n \begin{bmatrix} (w_n^{-0})^0 & (w_n^{-0})^1 & \cdots & (w_n^{-0})^{n-1} \\ (w_n^{-1})^0 & (w_n^{-1})^1 & \cdots & (w_n^{-1})^{n-1} \\ \vdots & \vdots & \ddots & \vdots \\ (w_n^{-(n-1)})^0 & (w_n^{-(n-1)})^1 & \cdots & (w_n^{-(n-1)})^{n-1} \end{bmatrix}\begin{bmatrix} A(w_n^0) \\ A(w_n^1) \\ \vdots \\ A(w_n^{n-1}) \end{bmatrix}
$$

>“这样，逆变换 就相当于把 正变换 过程中的 $w_n^k$ 换成 $w_n^{-k}$，之后结果除以 $n$ 就可以了。”——摘自某博客。

……

 还是有点难理解。比如为什么我们不直接把 $w_n^k$ 换成 $\frac1n*w_n^{-k}$ 算了。
 实际上，因为 $w_n^{-k}=w_n^{n-k}$ ，也就是说它 ~~TM~~ 还是一个 $n$ 次单位根。所以我们插值还是正常的该怎么插怎么插。如果换成 $\frac1n*w_n^{-k}$ 它就不是一个单位根，以上性质就不满足了。

## FFT 的代码实现

我们有两个版本——递归、迭代，相信大家都也想到了吧？

毋庸置疑的，递归版本确实很好写，将 $FFT$ 的思路全部放到上面即可，但是方便也有他的坏处——递归实现常数较大，这样对于一些题就会 $T$ 飞，但是我还是写了，这里上代码了

```cpp
#include<cstdio>
#include<cmath>

#define rep(i,__l,__r) for(register int i=__l,i##_end_=__r;i<=i##_end_;++i)
#define fep(i,__l,__r) for(register int i=__l,i##_end_=__r;i>=i##_end_;--i)
#define writc(a,b) fwrit(a),putchar(b)
#define mp(a,b) make_pair(a,b)
#define ft first
#define sd second
#define LL long long
#define ull unsigned long long
#define pii pair<int,int>
#define Endl putchar('\n')
// #define FILEOI
// #define int long long

#ifdef FILEOI
    #define MAXBUFFERSIZE 500000
    inline char fgetc(){
        static char buf[MAXBUFFERSIZE+5],*p1=buf,*p2=buf;
        return p1==p2&&(p2=(p1=buf)+fread(buf,1,MAXBUFFERSIZE,stdin),p1==p2)?EOF:*p1++;
    }
    #undef MAXBUFFERSIZE
    #define cg (c=fgetc())
#else
    #define cg (c=getchar())
#endif
template<class T>inline void qread(T& x){
    char c;bool f=0;
    while(cg<'0'||'9'<c)f|=(c=='-');
    for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    if(f)x=-x;
}
inline int qread(){
    int x=0;char c;bool f=0;
    while(cg<'0'||'9'<c)f|=(c=='-');
    for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    return f?-x:x;
}
template<class T,class... Args>inline void qread(T& x,Args&... args){qread(x),qread(args...);}
template<class T>inline T Max(const T x,const T y){return x>y?x:y;}
template<class T>inline T Min(const T x,const T y){return x<y?x:y;}
template<class T>inline T fab(const T x){return x>0?x:-x;}
inline int gcd(const int a,const int b){return b?gcd(b,a%b):a;}
inline void getInv(int inv[],const int lim,const int MOD){
    inv[0]=inv[1]=1;for(int i=2;i<=lim;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
}
template<class T>void fwrit(const T x){
    if(x<0)return (void)(putchar('-'),fwrit(-x));
    if(x>9)fwrit(x/10);putchar(x%10^48);
}
inline LL mulMod(const LL a,const LL b,const LL mod){//long long multiplie_mod
    return ((a*b-(LL)((long double)a/mod*b+1e-8)*mod)%mod+mod)%mod;
}

const int MAXN=3e6;
const double Pi=acos(-1.0);

class task{
private:
    struct cplx{
        double vr,vi;//实部和虚部
        cplx(const double R=0,const double I=0):vr(R),vi(I){}//构造函数
        //------------------overload----------------//
        cplx operator + (const cplx a)const{return cplx(vr+a.vr,vi+a.vi);}//重载加法
        cplx operator - (const cplx a)const{return cplx(vr-a.vr,vi-a.vi);}
        cplx operator * (const cplx a)const{return cplx(vr*a.vr-vi*a.vi,vr*a.vi+a.vr*vi);}
        cplx operator / (const double var)const{return cplx(vr/var,vi/var);}
    };

    int n,m;
    cplx a[MAXN+5],b[MAXN+5];

    void fft(cplx* f,const int len,const short opt=1){
        //opt==-1 : FFT 的逆变换
        if(!len)return;
        cplx f0[len+5],f1[len+5];
        for(int i=0;i<len;++i)
            f0[i]=f[i<<1],f1[i]=f[i<<1|1];
        fft(f0,len>>1,opt);
        fft(f1,len>>1,opt);
        cplx w=cplx(cos(Pi/len),opt*sin(Pi/len)),buf=cplx(1,0);
        for(int i=0;i<len;++i,buf=buf*w){
            f[i]=f0[i]+buf*f1[i];
            f[i+len]=f0[i]-buf*f1[i];
        }
    }
public:
    inline void launch(){
        qread(n,m);
        rep(i,0,n)scanf("%lf",&a[i].vr);
        rep(i,0,m)scanf("%lf",&b[i].vr);
        for(m+=n,n=1;n<=m;n<<=1);
        fft(a,n>>1);
        fft(b,n>>1);
        rep(i,0,n-1)a[i]=a[i]*b[i];
        fft(a,n>>1,-1);
        rep(i,0,m)writc((int)((a[i].vr)/n+0.5),' ');
        Endl;
    }
}This;

signed main(){
#ifdef FILEOI
    freopen("file.in","r",stdin);
    freopen("file.out","w",stdout);
#endif
    This.launch();
    return 0;
}
```

似乎递归版本比较好写，现在我们来看一下迭代（递推）版本应该怎么做：

原序列： $0,1,2,3,4,5,6,7$ 

终序列： $0,4,2,6,1,5,3,7$

转换为二进制再来看看。

原序列： $000,001,010,011,100,101,110,111$

终序列： $000,100,010,110,001,101,011,111$ 

可以发现终序列是原序列每个元素的**二进制翻转**。

于是我们可以先把要变换的系数排在相邻位置，**从下往上**迭代。

这个二进制翻转过程可以自己脑补方法，只要保证时间复杂度 $O(n\log n)$ ，代码简洁就可以了。

在这里给出一个参考的方法：

我们对于每个 $i$ ，假设已知 $i-1$ 的翻转为 $j$ 。考虑不进行翻转的二进制加法怎么进行：从最低位开始，找到第一个为 $0$ 的二进制位，将它之前的 $1$ 变为 $0$ ，将它自己变为 $1$ 。因此我们可以从 $j$ 的最高位开始，倒过来进行这个过程。

这是迭代版本：

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;

#define rep(i,__l,__r) for(register int i=__l,i##_end_=__r;i<=i##_end_;++i)
#define fep(i,__l,__r) for(register int i=__l,i##_end_=__r;i>=i##_end_;--i)
#define writc(a,b) fwrit(a),putchar(b)
#define mp(a,b) make_pair(a,b)
#define ft first
#define sd second
#define LL long long
#define ull unsigned long long
#define pii pair<int,int>
#define Endl putchar('\n')
// #define FILEOI
// #define int long long

#ifdef FILEOI
    #define MAXBUFFERSIZE 500000
    inline char fgetc(){
        static char buf[MAXBUFFERSIZE+5],*p1=buf,*p2=buf;
        return p1==p2&&(p2=(p1=buf)+fread(buf,1,MAXBUFFERSIZE,stdin),p1==p2)?EOF:*p1++;
    }
    #undef MAXBUFFERSIZE
    #define cg (c=fgetc())
#else
    #define cg (c=getchar())
#endif
template<class T>inline void qread(T& x){
    char c;bool f=0;
    while(cg<'0'||'9'<c)f|=(c=='-');
    for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    if(f)x=-x;
}
inline int qread(){
    int x=0;char c;bool f=0;
    while(cg<'0'||'9'<c)f|=(c=='-');
    for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    return f?-x:x;
}
template<class T,class... Args>inline void qread(T& x,Args&... args){qread(x),qread(args...);}
template<class T>inline T Max(const T x,const T y){return x>y?x:y;}
template<class T>inline T Min(const T x,const T y){return x<y?x:y;}
template<class T>inline T fab(const T x){return x>0?x:-x;}
inline int gcd(const int a,const int b){return b?gcd(b,a%b):a;}
inline void getInv(int inv[],const int lim,const int MOD){
    inv[0]=inv[1]=1;for(int i=2;i<=lim;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
}
template<class T>void fwrit(const T x){
    if(x<0)return (void)(putchar('-'),fwrit(-x));
    if(x>9)fwrit(x/10);putchar(x%10^48);
}
inline LL mulMod(const LL a,const LL b,const LL mod){//long long multiplie_mod
    return ((a*b-(LL)((long double)a/mod*b+1e-8)*mod)%mod+mod)%mod;
}

const int MAXN=3e6;
const double Pi=acos(-1.0);

class task{
private:
    struct cplx{
        double vr,vi;//实部和虚部
        cplx(const double R=0,const double I=0):vr(R),vi(I){}//构造函数
        //------------------overload----------------//
        cplx operator + (const cplx a)const{return cplx(vr+a.vr,vi+a.vi);}//重载加法
        cplx operator - (const cplx a)const{return cplx(vr-a.vr,vi-a.vi);}
        cplx operator * (const cplx a)const{return cplx(vr*a.vr-vi*a.vi,vr*a.vi+a.vr*vi);}
        cplx operator / (const double var)const{return cplx(vr/var,vi/var);}
    };

    int n,m;
    cplx a[MAXN+5],b[MAXN+5];
    int revi[MAXN+5];

    /*
        f(w^x)
        =f0(w^{2x})+w^x*f1(w^{2x})
        =a0+a2+a4+...,a1+a3+a5+...
        =a0+a4+a8+...+a2+a6+a10...+a1+a5+a9+...+a3+a7+a11...
        =f00(w^{4x})+w^{2x}*f01(w^{4x})+w^x*f10(w^{4x})+w^3x*f11(w^{4x})
        =a0+a4+a8+...,w^{2x}*(a2+a6+a10...),w^x*(a1+a5+a9+...),w^{3x}*(a3+a7+a11...)
        f_s -> 下标将 s 反过来之后, a_i 的 i 的二进制反过来与 s 相同
                .
                .
                .
        s
        000 001 010 011 
               |反过来
               v
        000 100 010 110
        a0 a{k/2} a{3*k/4} a{k}
        a0  a4  a2  a6
    */
    /*
    void fft(cplx* f,const int len,const short opt=1){
        if(!len)return;
        cplx f0[len+5],f1[len+5];
        for(int i=0;i<len;++i)
            f0[i]=f[i<<1],f1[i]=f[i<<1|1];
        fft(f0,len>>1,opt);
        fft(f1,len>>1,opt);
        cplx w=cplx(cos(Pi/len),opt*sin(Pi/len)),buf=cplx(1,0);
        for(int i=0;i<len;++i,buf=buf*w){
            f[i]=f0[i]+buf*f1[i];
            f[i+len]=f0[i]-buf*f1[i];
        }
    }
    */
   inline void fft(cplx* f,const short opt=1){
        for(int i=0;i<n;++i)if(i<revi[i])
            swap(f[i],f[revi[i]]);
        for(int p=2;p<=n;p<<=1){
            //枚举层数
            int len=p/2;//上一层的一半的长度
            cplx tmp(cos(Pi/len),opt*sin(Pi/len));
            //单位复根
            for(int k=0;k<n;k+=p){
                cplx buf(1,0);//记录 omega 的次方
                for(int l=k;l<k+len;++l,buf=buf*tmp){
                //每次 buf 累成单位 omega
                    cplx tt=buf*f[len+l];
                    f[len+l]=f[l]-tt;
                    f[l]=f[l]+tt;
                /*
                    此处与递归版本的 FFT 中这一段是一样的:
                    f[i]=f0[i]+buf*f1[i];
                    f[i+len]=f0[i]-buf*f1[i];
                */
                }
            }
        }
        if(opt==-1)for(int i=0;i<n;++i)f[i]=f[i]/n;
        //如果是 逆变换 , 那么需要全部 /n
   }
public:
    inline void launch(){
        qread(n,m);
        rep(i,0,n)scanf("%lf",&a[i].vr);
        rep(i,0,m)scanf("%lf",&b[i].vr);
        for(m+=n,n=1;n<=m;n<<=1);
        rep(i,0,n-1)revi[i]=(revi[i>>1]>>1)|((i&1)?n>>1:0);//处理反转
        fft(a);fft(b);
        rep(i,0,n-1)a[i]=a[i]*b[i];
        fft(a,-1);
        rep(i,0,m)writc((int)(a[i].vr+0.5),' ');
        Endl;
    }
}This;

signed main(){
#ifdef FILEOI
    freopen("file.in","r",stdin);
    freopen("file.out","w",stdout);
#endif
    This.launch();
    return 0;
}
```

> 如果我可以回到过去，我一定会去当杀手。
>
> 为什么？因为我要去干翻**欧某**和**傅某某**...

## 还会有的 NTT 和三模数 NTT...

---

## 作者：小菜鸟 (赞：3)

这题...我可能是唯一一个用三种语言各写一遍的人

~~然而Pascal卡不过去~~

并且我应该是第一个用C写FFT通过的（

所以这篇题解的重点不在数学，而在如何用C愉快地食用FFT（

~~既然前面有P党卡过去发题解那这个应该也行吧~~

---

先重复一下做法：把两个多项式变换成点值表示，直接$O(n)$乘起来，然后变回系数表示就是了。。。

---

然后进正题

由于C++有面向对象、函数重载等一系列特性，复数运算很容易以优美的方式呈现

然而C既不能重载函数，也难以面向对象...

然而在研究`std::complex`的时候，我们发现它的头文件`include`了一个`complex.h`库...

于是上网学习，发现C也有复数库（其实甚至不需要库，在C99中复数已经是内建类型了）

于是就极度舒适（

---

FFT需要的基本用法：

```c
#include<complex.h>//为了方便而包含，实际可以省略，但声明变量需将complex改为_Complex

double complex a;//声明基于double的复数变量

creal(a)//取a的实部
cimag(a)//取a的虚部

a=1+2*_Complex_I//_Complex_I即是单位虚数i

//另外不担心重名可以用I代替_Complex_I

//然后不考虑可移植性的话，在GCC下提供1.0fi,1.0i,1.0li等写法

//同时从C++14开始，类似的1.0if,1.0i,1.0il是标准的虚数字面量
```

然后大量的C数学函数均有针对复数特化的泛型函数，在名字前写前缀`c`就是了

于是有了神奇的复数，我们就可以愉快地搞FFT了（

---

然后是不开IO优化卡不过去的代码

```cpp
#include<stdio.h>
#include<ctype.h>
#include<math.h>
#include<complex.h>

char gc(void)
{
    static char buf[1<<16],*p1=buf,*p2=buf;
    if(p1==p2)
    {
        p2=(p1=buf)+fread(buf,1,1<<16,stdin);
        if(p1==p2)return EOF;
    }
    return *p1++;
}

// #define gc getchar

void read(int *x)
{
    *x=0;
    char c=gc();
    while(!isdigit(c))c=gc();
    while(isdigit(c))
    {
        *x=*x*10+c-48;
        c=gc();
    }
}

void write(int x)
{
    if(x>=10)write(x/10);
    putchar(x%10+48);
}

#define N (1<<21)
#define PI 3.141592653589793238462643383

int n,m;

double complex a[N],b[N];

int rev[N];

void getrev(int n)
{
    for(int i=0;i<n;++i)
    {
        rev[i]=(rev[i>>1]>>1)|(i&1?n>>1:0);
    }
}

void fft(double complex *a,int n,int dft)
{
    for(int i=0;i<n;++i)
    {
        if(i<rev[i])
        {
            double complex temp=a[i];
            a[i]=a[rev[i]];
            a[rev[i]]=temp;
        }
    }
    for(int step=1;step<n;step<<=1)
    {
        const double complex wn=cos(PI/step)+sin(dft*PI/step)*_Complex_I;
        for(int j=0;j<n;j+=step<<1)
        {
            double complex wnk=1;
            for(int k=j;k<j+step;++k)
            {
                double complex x=a[k];
                double complex y=a[k+step]*wnk;
                a[k]=x+y;
                a[k+step]=x-y;
                wnk*=wn;
            }
        }
    }
    if(dft==-1)
    {
        double inv=1./n;
        for(int i=0;i<n;++i)a[i]*=inv;
    }
}

int main(void)
{
    read(&n),read(&m);
    for(int i=0;i<=n;++i)
    {
        int x;
        read(&x);
        a[i]=x;
    }
    for(int i=0;i<=m;++i)
    {
        int x;
        read(&x);
        b[i]=x;
    }
    int len=1;
    while(len<=n+m+1)len<<=1;
    getrev(len);
    fft(a,len,1);
    fft(b,len,1);
    for(int i=0;i<len;++i)a[i]*=b[i];
    fft(a,len,-1);
    for(int i=0;i<n+m+1;++i)
    {
        write((int)(creal(a[i])+0.5));
        putchar(' ');
    }
}
```

~~awsl为什么这题突然减小时限卡常数啊~~

警告，若编译器有`__STDC_NO_COMPLEX__`宏，则不支持复数（gcc可以放心

最后，虽然我是个C++&面向对象的死忠粉，但还是要说一句：

## C牛逼！！！

另外为什么C的语法高亮萎掉了啊求修复（被迫写`cpp`QwQ
---
### 2020.10.14更新
初赛前颓废学了一下Rust

考虑到FFT代码相对简单于是就来练练手

---

简要介绍Rust，一个安全性和效率都相当不错的新兴语言

由Mozilla的大佬创造维护

定位和C++类似，零开销，多范式

但具有更多安全的、流行的特性

基本上可以把UB扼杀在编译期

~~而且拥有比GNU STL清晰一些的标准库~~

---

这篇题解本来就不是讲思路而是讲代码的...

所以下面直接给出代码实现（PS下面有效率对比）

```rust
const P:i64=998244353;
const g:i64=3;
const gi:i64=332748118;
fn power(mut a:i64,mut b:i64)->i64
{
	let mut res:i64=1;
	while b!=0
	{
		if (b&1)!=0
		{
			res=res*a%P;
		}
		a=a*a%P;
		b>>=1;
	}
	return res;
}

fn getrev(rev:&mut Vec<usize>,len:usize)
//Rust对于所有权的控制很严格，只能用可变引用来改变外部的东西
//Rust的引用与C++的指针类似
{
	rev.clear();
	rev.push(0);
	for i in 1..len
	{
		rev.push((rev[i>>1]>>1)|(if (i&1)==0{0}else{len>>1}));
	}
}

fn ntt(arr:&mut Vec<i64>,n:usize,dft:bool,rev:&Vec<usize>)
{
	for i in 0..n
	{
		if i<rev[i]
		{
			arr.swap(i,rev[i]);//在Rust中，一个对象不能同时存在两个可变引用
			//所以直接std::mem::swap(i,rev[i])是unsafe的，需要用Vec自己的方法
		}
	}
	let mut step=1;
	while step<n
	{
		let wn:i64=power(if dft{g}else{gi},(P-1)/(step as i64*2));
		let mut j=0;
		while(j<n)
		{
			let mut wnk=1;
			for k in j..j+step
			{
				let x=arr[k];
				let y=arr[k+step]*wnk%P;
				arr[k]=(x+y)%P;
				arr[k+step]=(x-y+P)%P;
				wnk=wnk*wn%P;
			}
			j+=step*2;
		}
		step*=2;
	}
	if !dft
	{
		let inv=power(n as i64,P-2);
		for i in 0..n
		{
			arr[i]=arr[i]*inv%P;
		}
	}
}

extern "C"
{
	fn getchar()->u8;
}

fn read()->i64//rust没有原生的比较简洁的快读，不得不学习巨佬cosmicAC的
{
	let mut res=0;
	let mut ch;
	loop
	{
		unsafe
		{
			ch=getchar();
		}
		if ch>=48 && ch<=57
		{
			break;
		}
	}
	loop
	{
		res=res*10+(ch as i64)-48;
		unsafe
		{
			ch=getchar();
		}
		if ch<48 || ch>57
		{
			break;
		}
	}
	return res;
}

fn main()
{
	let n:usize=read() as usize;//Rust在safe mode里不能定义全局变量
	let m:usize=read() as usize;
	let n=n+1;
	let m=m+1;
	let mut a:Vec<i64>=Vec::new();
	let mut b:Vec<i64>=Vec::new();
	let mut len=1;
	while len<=n+m
	{
		len*=2;
	}
	for i in 0..n
	{
		let x=read();
		a.push(x);
	}
	while a.len()<len
	{
		a.push(0);
	}
	for i in 0..m
	{
		let x=read();
		b.push(x);
	}
	while b.len()<len
	{
		b.push(0);
	}
	let mut rev:Vec<usize>=Vec::new();
	for i in 0..len
	{
		rev.push(0);
	}
	getrev(&mut rev,len);
	ntt(&mut a,len,true,&rev);
	ntt(&mut b,len,true,&rev);
	let mut res:Vec<i64>=Vec::new();
	for i in 0..len
	{
		res.push(a[i]*b[i]%P);
	}
	ntt(&mut res,len,false,&rev);
	for i in 0..n+m-1
	{
		print!("{} ",res[i]);
	}
}
```
C++在使用普通快读的情况下是1.4s（有没有`fread`区别不大）

Rust是1.8s...

看来GCC开发这么多年毕竟是比rustc成熟的233

---

## 作者：Chase12345 (赞：2)

# 前置知识
## 复数
[复数](https://baike.baidu.com/item/%E5%A4%8D%E6%95%B0/254365)是形如 $a+bi$ 一类的数，其中 $a,b \in \mathbb{R},i=\sqrt {-1}$。

我们可以抽象地将复数理解为[复平面](https://baike.baidu.com/item/%E5%A4%8D%E6%95%B0%E5%B9%B3%E9%9D%A2/1650195)上的点，或者向量。

对于复数 $z=a+bi$，我们定义它的模长 $|z|$ 就是 $A$ 在复平面上距离原点的距离，也即 $|z|=\sqrt{a^2+b^2}$。

定义一个复数 $z=a+bi$，它的复共轭 $\overline{z}$ 为 $\overline{z}=a-bi$，这一点在后面会用到。

而复数[辐角](https://baike.baidu.com/item/%E8%BE%90%E8%A7%92/3340380)是指复数在复平面上对应的向量与正实轴之间的夹角。

如果你学过[向量](https://baike.baidu.com/item/%E5%90%91%E9%87%8F/1396519)，那么复数的加法、减法都可以使用[平行四边形定则](https://baike.baidu.com/item/%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2%E5%AE%9A%E5%88%99/7534360)或[三角形法则](https://baike.baidu.com/item/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%B3%95%E5%88%99/2054838)写出。

如果你没有学过，可以在我贴心提供的链接中学习。

复数的乘法如果使用代数的话就是 $(a+bi)(c+di)=(ac-bd)+(ad+bc)i$，在几何意义下就是模长相乘，辐角相加，这一点容易证明。

而复数的除法可以类比二次根式的化简，使用复共轭进行分母有理化即可。
## 单位根
我们称满足 $\omega^n=1$ 的复数 $\omega$ 称为 $n$ 次[单位根](https://baike.baidu.com/item/%E5%8D%95%E4%BD%8D%E6%A0%B9/10927387)。在复平面上，它们均匀地分布在[单位圆](https://baike.baidu.com/item/%E5%8D%95%E4%BD%8D%E5%9C%86/2487023)上。

我们定义主 $n$ 次单位根为：$\omega_n=e^{\frac{2\pi i}{n}}$，其它单位根可以表示为 $\omega_n^k$，其中 $k \in [0,n-1]$。

单位根有以下性质：
* $\omega_n^{k+n}=\omega_n^k$
* $\omega_n^{k+\frac{n}{2}}=-\omega_n^k$，当 $n$ 为偶数。
* $\omega_{dn}^{dk}=\omega_n^k$，其中 $d \in \mathbb{N^+}$。
* $\left(\omega_n^k\right)^2=\omega_{\frac{n}{2}}^{k}$，当 $n$ 为偶数。

## 多项式的表示
通常而言，我们使用形如：
$$
A(x)=a_0x^0+a_1x^1+\cdots+a_{n-1}x^{n-1}
$$
来表示一个多项式，这被称为系数表示法。

而我们要用的 FFT 是使用点值表示法的，而点值表示法，具体而言，通过多项式在 $n$ 个不同点的取值来表示多项式。即给出 $n$ 个点对 $(x_0,A(x_0)),(x_1,A(x_1)),\dots,(x_{n-1},A(x_{n-1}))$ 来表示这个多项式。

# DFT

## DFT 的定义
对于多项式 $A(x)$，我们定义它的 DFT 为在 $n$ 个 $n$ 次单位根处的取值：
$$
y_k=A(\omega_n^k)=\sum_{j=0}^{n-1} a_j \omega_n^{kj}
$$
其中 $k \in [0,n-1]$。

我们定义其逆 DFT 为
$$
a_j=\frac{1}{n} \sum_{k=0}^{n-1} y_k \omega_n^{-kj}
$$
其中 $j \in [0,n-1]$。

而 DFT 其实也可以表示为矩阵乘法，$y=F_na$，其中 $F_n$ 为 DFT 矩阵，其元素为 $(F_n)_{j,k}=\omega_n^{jk}$。

关于矩阵的一些内容，可以参考[我的文章](https://www.luogu.com.cn/article/bxgapter)。
## 逆 DFT
逆 DFT 的公式是：
$$
a_j = \frac{1}{n} \sum_{k=0}^{n-1} y_k \omega_n^{-kj}, \quad j = 0, 1, \dots, n-1 
$$
正确性证明在后面，这里不过多赘述。
# 循环卷积
对于两个序列 $a$ 和 $b$，定义它们的循环卷积 $c$ 为 $c_k=\sum_{j=0}^{k} a_j b_{k-j}$。

而[卷积定理](https://baike.baidu.com/item/%E5%8D%B7%E7%A7%AF%E5%AE%9A%E7%90%86/10440902)说明的是时域卷积定理即时域内的卷积对应频域内的乘积，即 $\mathcal{F}(a*b)=\mathcal{F}(a) \cdot \mathcal{F}(b)$。这也是 FFT 里面最重要的一个定义。通过矩阵表示法即可证明。

而容易知道的一点是：两个多项式的乘积的系数就是它们的系数的卷积。这个是 FFT 里面需要用到的性质。
# 本题的算法介绍（FFT）
讲完以上内容，终于来到了 FFT 了。

FFT 是一种优化多项式乘法的一种算法，通常运用于高精乘、信号处理、图像处理、通信系统、音频处理还有医学上都会用到（其实还有很多运用的场景，这里没有完整列出。）

FFT 是使用分治的方法将卷积的复杂度从 $O(n^2)$ 优化到 $O(n \log n)$。

主要用到的核心思想就是：
> 多项式乘积 $C(x)=A(x) \cdot B(x)$，在点值表示下对应于逐点相乘，即 $C(\omega_n^k)=A(\omega_n^k) \cdot B(\omega_n^k)$。

这样，我们可以考虑分治，每次递归处理，最后合并得到答案。这样就是 FFT 的运算过程。

复杂度就是 $T(n)=2T(\frac{n}{2}) + O(n)=O(n \log n)$。

分治策略，具体而言：对于 $n$ 次多项式 $A(x)$，假设 $n$ 为 $2$ 的幂次（如果不足可以补 $0$），我们可以将其使用分治思想分成两部分：
* 奇数项：$A_0(x)=a_0+a_2x+a_4x^2+\dots$
* 偶数项：$A_1(x)=a_1+a_3x+a_5x^2+\dots$

那么我们可以得到 $A(x)=A_0(x^2)+x \cdot A_1(x^2)$。

在 $n$ 个单位根处求值时，使用单位根的折半定理和消去定理，即可得到我们只需要计算前 $\frac{n}{2}$ 个单位根处的值：$A(\omega_n^k)=A_0(\omega_{\frac{n}{2}}^k)+\omega_n^k \cdot A_1(\omega_{\frac{n}{2}}^k)A(\omega_n^{k+\frac{n}{2}})=A_0(\omega_{\frac{n}{2}}^k)-\omega_n^k \cdot A_1(\omega_{\frac{n}{2}}^k)$。

最终的合并我们称为蝶形运算。

具体的运算过程，举个例子，如 $8$ 点 FFT。
```
Stage 1（分组 = 2）:
x0─────(+)──→ A0  
 │      (-)──→ A1  
x4─────┘ 
 
x2─────(+)──→ B0  
 │      (-)──→ B1  
x6─────┘ 
 
x1─────(+)──→ C0  
 │      (-)──→ C1  
x5─────┘ 
 
x3─────(+)──→ D0  
 │      (-)──→ D1  
x7─────┘ 
 
Stage 2（分组 = 4）:
A0─────(+)───────→ E0  
 │      (-)─W4^0─→ E2  
B0─────┘ 
 
A1─────(+)───────→ E1  
 │      (-)─W4^1─→ E3  
B1─────┘ 
 
C0─────(+)───────→ F0  
 │      (-)─W4^0─→ F2  
D0─────┘ 
 
C1─────(+)───────→ F1  
 │      (-)─W4^1─→ F3  
D1─────┘ 
 
Stage 3（分组 = 8）:
E0─────(+)───────→ X[0]  
 │      (-)─W8^0─→ X[4]  
F0─────┘ 
 
E1─────(+)─W8^1─→ X[1]  
 │      (-)─W8^3─→ X[5]  
F1─────┘ 
 
E2─────(+)─W8^2─→ X[2]  
 │      (-)─W8^6─→ X[6]  
F2─────┘ 
 
E3─────(+)─W8^3─→ X[3]  
 │      (-)─W8^7─→ X[7]  
F3─────┘
```

# 逆 FFT
这是将点值表示转换回系数表示的过程，与 FFT 过程类似，只需将单位根取共轭，并在最后除以 $n$。

举个例子：$8$ 点 IFFT：
```
Stage 1（分组 = 2）:
X0─────(+)──→ A0  
 │      (-)──→ A1  
X4─────┘ 
 
X2─────(+)──→ B0  
 │      (-)──→ B1  
X6─────┘ 
 
X1─────(+)──→ C0  
 │      (-)──→ C1  
X5─────┘ 
 
X3─────(+)──→ D0  
 │      (-)──→ D1  
X7─────┘ 
 
Stage 2（分组 = 4）:
A0─────(+)───────→ E0  
 │      (-)─W4^0─→ E2  
B0─────┘ 
 
A1─────(+)───────→ E1  
 │      (-)─W4^1─→ E3  
B1─────┘ 
 
C0─────(+)───────→ F0  
 │      (-)─W4^0─→ F2  
D0─────┘ 
 
C1─────(+)───────→ F1  
 │      (-)─W4^1─→ F3  
D1─────┘ 
 
Stage 3（分组 = 8）:
E0─────(+)───────→ x0 = (E0 + F0) / 8  
 │      (-)─W8^0─→ x4 = (E0 - F0) * 1 / 8  
F0─────┘ 
 
E1─────(+)─W8^-1─→ x1 = (E1 + F1 * (1+i)/√2) / 8  
 │      (-)─W8^-3─→ x5 = (E1 - F1 * (1+i)/√2) * (-1+i)/√2 / 8  
F1─────┘ 
 
E2─────(+)─W8^-2─→ x2 = (E2 + F2 * i) / 8  
 │      (-)─W8^-6─→ x6 = (E2 - F2 * i) * (-i) / 8  
F2─────┘ 
 
E3─────(+)─W8^-3─→ x3 = (E3 + F3 * (-1+i)/√2) / 8  
 │      (-)─W8^-7─→ x7 = (E3 - F3 * (-1+i)/√2) * (1-i)/√2 / 8  
F3─────┘
```

# 正确性证明
## 证明 DFT 的正交性

定义 DFT 的矩阵 $F_n$ 的元素为 $(F_n)_{j,k}=\omega_n^{jk}$，要证明：
$$
\sum_{k=0}^{n-1} \omega_n^{pk} \overline{\omega_n^{qk}}=n \delta_{pq}
$$
证明如下：
* 当 $p=q$ 时，$\omega_n^{(p-q)k}=1$，则结果为 $1$。
* 当 $p \neq q$ 时，可以用等比数列求和，由于 $\omega_n^n=1$，所以可以得到：

$$
\sum_{k=0}^{n-1} \omega_n^{(p-q)k}=\frac{1-\omega_n^{(p-q)n}}{1-\omega_n^{p-q}}=0
$$
证毕。

## IDFT 正确性证明
IDFT 的公式是：
$$
a_j = \frac{1}{n} \sum_{k=0}^{n-1} y_k \omega_n^{-kj}, \quad j = 0, 1, \dots, n-1 
$$
我们需要证明它的还原性。

将 DFT 的表达式代入 IDFT，可以得到：
$$
a_j^{'}=\frac{1}{n} \sum_{k=0}^{n-1} \left(\sum_{p=0}^{n-1} a_p \omega_n^{kp}\right) \omega_n^{-kj}
$$
显然可以交换求和顺序，之后利用正交性：
$$
a_j'=\sum_{p=0}^{n-1} a_p \left(\frac{1}{n} \sum_{k=0}^{n-1} \omega_n^{k(p-j)}\right)=a_j
$$
当 $p=j$ 时非 $0$。

证毕。

## IFFT 的共轭对称性的证明

我们需要证明 IFFT 不用额外多写一份代码，也即证明：
$$
\text{IFFT}(X) = \frac{1}{n} \text{conj}(\text{FFT}(\text{conj}(X)))
$$
由 IDFT 定义（如上），两边取共轭并除以 $n$，可以得到：
$$
\frac{1}{n} \text{conj}(\text{FFT}(\text{conj}(X)))_k = x_k
$$
 欸，是不是 IDFT 就可以表示为：
$$
\text{IFFT}(X) = \frac{1}{N} \text{conj}(\text{FFT}(\text{conj}(X)))
$$
这说明~~我们不用多写一份代码了~~能省略一点代码量。
# 合并部分的图例
上面如果讲得不太详细，这里给出图例：
```
Stage 1（分组 = 2）：
x0──┬──(+)──→ A0  
    │   (-)──→ A1  
x4──┘  
 
x2──┬──(+)──→ B0  
    │   (-)──→ B1  
x6──┘  
 
x1──┬──(+)──→ C0  
    │   (-)──→ C1  
x5──┘  
 
x3──┬──(+)──→ D0  
    │   (-)──→ D1  
x7──┘

Stage 2（分组 = 4）：
A0──┬──(+)───────→ E0  
    │   (-)─W4^0─→ E2  
B0──┘  
 
A1──┬──(+)───────→ E1  
    │   (-)─W4^1─→ E3  
B1──┘  
 
C0──┬──(+)───────→ F0  
    │   (-)─W4^0─→ F2  
D0──┘  
 
C1──┬──(+)───────→ F1  
    │   (-)─W4^1─→ F3  
D1──┘

Stage 3（分组 = 8）：
E0──┬──(+)──────────→ X[0]  
    │   (-)─W8^0────→ X[4]  
F0──┘  
 
E1──┬──(+)─W8^1────→ X[1]  
    │   (-)─W8^3────→ X[5]  
F1──┘  
 
E2──┬──(+)─W8^2────→ X[2]  
    │   (-)─W8^6────→ X[6]  
F2──┘  
 
E3──┬──(+)─W8^3────→ X[3]  
    │   (-)─W8^7────→ X[7]  
F3──┘  
```

# 代码实现
大概步骤是：先使用 FFT 将多项式 $A$ 和 $B$ 化为点值表示，之后将点值相乘得到乘积多项式 $C$ 的点值表示，最后对 $C$ 进行逆 FFT 即可得到 $C$ 的系数表示法。

代码虽然长，但是不难理解。
```cpp
#include <bits/stdc++.h>
using namespace std;
 
const int MAXN = 1 << 21;
const double PI = acos(-1.0);
 
struct Complex {
    double x, y;
    Complex (double _x = 0.0, double _y = 0.0) : x(_x), y(_y) {}
    Complex operator + (const Complex& b) const {
        return Complex(x + b.x, y + b.y);
    }
    Complex operator - (const Complex& b) const {
        return Complex(x - b.x, y - b.y);
    }
    Complex operator * (const Complex& b) const {
        return Complex(x * b.x - y * b.y, x * b.y + y * b.x);
    }
};
 
int rev[MAXN];
 
void init(int bit) {
    for (int i = 0; i < (1 << bit); i++) {
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (bit - 1));
    }
}
 
void fft(Complex* a, int n, int inv) {
    int bit = 0;
    while ((1 << bit) < n) bit++;
    for (int i = 0; i < n; i++)
        if (i < rev[i])
            swap(a[i], a[rev[i]]); 
    for (int mid = 1; mid < n; mid <<= 1) {
        Complex wn(cos(PI / mid), inv * sin(PI / mid));
        for (int i = 0; i < n; i += mid * 2) {
            Complex w(1, 0);
            for (int j = 0; j < mid; j++, w = w * wn) {
                Complex x = a[i + j], y = w * a[i + j + mid];
                a[i + j] = x + y;
                a[i + j + mid] = x - y;
            }
        }
    }
    if (inv == -1)
        for (int i = 0; i < n; i++)
            a[i].x /= n;
}
 
Complex A[MAXN], B[MAXN];
int output[MAXN];
 
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 0; i <= n; i++) {
        double x;
        scanf("%lf", &x);
        A[i].x = x;
    }
    for (int i = 0; i <= m; i++) {
        double x;
        scanf("%lf", &x);
        B[i].x = x;
    }
    int len = 1, bit = 0;
    while (len <= n + m) {
        len <<= 1;
        bit++;
    }
    init(bit);
    fft(A, len, 1);
    fft(B, len, 1);
    for (int i = 0; i < len; i++)
        A[i] = A[i] * B[i];
    fft(A, len, -1); 
    for (int i = 0; i <= n + m; i++)
        printf("%d ", (int)(A[i].x + 0.5)); 
    return 0;
}
```
# 扩展到复数域
其实代码中我加了复数的运算，除了 FFT 中的运算，更多的是想要加入到复数 FFT。主要是由于你 FFT 中有运算了，你还不如再写一点东西扩展到复数域岂不美哉？
# 应用
FFT 的应用有许多的内容。

举个例子，[P1919](https://www.luogu.com.cn/problem/P1919) 高精度乘法。

回顾以前的高精乘，确实是

参考代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
 
const int MAXN = 1 << 21;
const double PI = acos(-1.0);
 
struct Complex {
    double x, y;
    Complex (double _x = 0.0, double _y = 0.0) : x(_x), y(_y) {}
    Complex operator + (const Complex& b) const {
        return Complex(x + b.x, y + b.y);
    }
    Complex operator - (const Complex& b) const {
        return Complex(x - b.x, y - b.y);
    }
    Complex operator * (const Complex& b) const {
        return Complex(x * b.x - y * b.y, x * b.y + y * b.x);
    }
};
 
int rev[MAXN];
 
void init(int bit) {
    for (int i = 0; i < (1 << bit); i++)
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (bit - 1));
}
 
void fft(Complex* a, int n, int inv) {
    int bit = 0;
    while ((1 << bit) < n) bit++;
    for (int i = 0; i < n; i++)
        if (i < rev[i])
            swap(a[i], a[rev[i]]);
    for (int mid = 1; mid < n; mid <<= 1) {
        Complex wn(cos(PI / mid), inv * sin(PI / mid));
        for (int i = 0; i < n; i += mid * 2) {
            Complex w(1, 0);
            for (int j = 0; j < mid; j++, w = w * wn) {
                Complex x = a[i + j], y = w * a[i + j + mid];
                a[i + j] = x + y;
                a[i + j + mid] = x - y;
            }
        }
    }
    if (inv == -1)
        for (int i = 0; i < n; i++)
            a[i].x /= n;
}
 
Complex A[MAXN], B[MAXN];
int output[MAXN];
 
int main() {
    string a, b;
    cin >> a >> b;
    int n = a.size(),  m = b.size(); 
    if (a == "0" || b == "0") {
        cout << "0" << endl;
        return 0;
    }
    for (int i = 0; i < n; i++)
        A[n - 1 - i].x = a[i] - '0';
    for (int i = 0; i < m; i++)
        B[m - 1 - i].x = b[i] - '0';
    int len = 1, bit = 0;
    while (len < n + m) {
        len <<= 1;
        bit++;
    }
    init(bit);
    fft(A, len, 1);
    fft(B, len, 1);
    for (int i = 0; i < len; i++)
        A[i] = A[i] * B[i];
    fft(A, len, -1);
    for (int i = 0; i < len; i++)
        output[i] = (int)(A[i].x + 0.5);
    for (int i = 0; i < len; i++)
        if (output[i] >= 10) {
            output[i + 1] += output[i] / 10;
            output[i] %= 10;
        }
    int high = len - 1;
    while (high >= 0 && output[high] == 0)
        high--;
    if (high < 0)
        cout << "0";
    else
        for (int i = high; i >= 0; i--)
            cout << output[i];
    cout << endl;
    return 0;
}
```

# Update:
原本 FFT 的篇幅过于小，现在增加了 FFT 和 IFFT 的运行过程和示例，并增加了 DFT、IDFT、FFT、IFFT 的正确性证明。

---

## 作者：粥2414 (赞：1)

# 前置知识
- 复数。
- 至少高一的数学基础。
# FFT 简介
FFT，即**快速傅里叶变换**。

为方便理解，我先讲 FFT 的作用，然后再解释原理。
## 作用
~~知周所众~~，一个一元 $n$ 次多项式有两种表示方式。第一种是常见的**系数表示法**，如下：
$$
a_0+a_1x+a_2x^2+\cdots+a_nx^n
$$
还有一种是不那么常见的**点值表示法**，如下：
$$
(x_0,y_0),(x_1,y_1),(x_2,y_2),\dots,(x_n,y_n)
$$
第二种表示方法常见的例子有：用平面直角坐标系上两点确定一条直线，或者三点确定一条抛物线。它的本质就是取 $n+1$ 个不同的值带入多项式，得出结果，以此确定一个多项式。

FFT 的作用就是在 $O(n\log n)$ 的时间复杂度内将一个一元 $n$ 次多项式在两种表示法中转换。

那么如果是点值表示法的两个多项式相乘呢？首先要保证 $x_i$ 是对应相等的，然后 $y_i$ 相乘即可，时间复杂度 $O(n)$。是不是快了很多？

然而有个残酷的事情是，如果朴素的将系数表示法转换为点值表示法，即一一带入数字并计算结果，那么时间复杂度依然是 $O(n^2)$，起不到任何优化。

这时，FFT 的作用就体现出来了。它可以优化这一部分复杂度至 $O(n\log n)$，大大加快了效率。与它作用相似的还有 NTT，感兴趣的读者可以自行上网查询资料。
## 原理
FFT 通过将复数**单位根**的整数次幂带入多项式，**分治**快速求解。至于为什么选择它，自然是因为单位根具有一些美妙的性质。
### 单位根
> 数学上，$n$ 次单位根是 $n$ 次幂为1的复数。它们位于复平面的单位圆上，构成正 $n$ 边形的顶点，其中一个顶点是 $1$。

摘自[百度百科](https://baike.baidu.com/item/%E5%8D%95%E4%BD%8D%E6%A0%B9/10927387#:~:text=%E6%95%B0%E5%AD%A6%E6%9C%AF%E8%AF%AD%E6%95%B0%E5%AD%A6%E4%B8%8A%EF%BC%8Cn%E6%AC%A1%E5%8D%95%E4%BD%8D%E6%A0%B9%E6%98%AFn%E6%AC%A1%E5%B9%82%E4%B8%BA1%E7%9A%84%E5%A4%8D%E6%95%B0%E3%80%82%E5%AE%83%E4%BB%AC%E4%BD%8D%E4%BA%8E%E5%A4%8D%E5%B9%B3%E9%9D%A2%E7%9A%84%E5%8D%95%E4%BD%8D%E5%9C%86%E4%B8%8A%EF%BC%8C%E6%9E%84%E6%88%90%E6%AD%A3n%E8%BE%B9%E5%BD%A2%E7%9A%84%E9%A1%B6%E7%82%B9%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E9%A1%B6%E7%82%B9%E6%98%AF1%E3%80%82)。

什么是单位圆呢？

就是圆心为原点，半径为单位长度的圆，如图所示：

![单位圆](https://cdn.luogu.com.cn/upload/image_hosting/uenx30jg.png)

而如果我们将单位圆 $n$ 等分，且其中一个等分点在 $(1,0)$ 处，那么从实轴开始逆时针遇到的第二个点表示的复数即为单位根，设为 $\omega_n$ 。如图为 $n=8$ 时的情况：

![单位根](https://cdn.luogu.com.cn/upload/image_hosting/vjaua6dy.png)

容易发现这些点按逆时针可依次表示为 $\omega_8^0$、$\omega_8^1$、$\omega_8^2$、$\cdots$、$\omega_8^7$，而 $\omega_8^8=\omega_8^0=1$。这符合上文提到的单位根的定义。

还有两个十分重要的发现是当 $n$ 为 $2$ 的整数次幂时，$\omega_n^i=-\omega_n^{i+\frac{n}{2}}$，以及当 $n$ 为偶数时，$\omega_n^{2i}=\omega_{\frac{n}{2}}^i$,至于严格的证明~~我不会~~，可以自行上网查阅。

FFT 要求 $n$ 必须为 $2$ 的正整数次幂。即多项式最简形式的项数必须为 $2$ 的正整数次幂。
# 实现
## 递归版
这时有巨佬就要发问了，这些性质有什么用？

可以举个例子（来自 [oi-wiki](https://oi-wiki.org/math/poly/fft/#%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2)）。

设一个一元 $7$ 次多项式如下：
$$
f(x)=a_0+a_1x+a_2x^2+a_3x^3+a_4x^4+a_5x^5+a_6x^6+a_7x^7
$$
将其各项按奇偶性分为两组,并在奇数组提出一个 $x$：
$$
f(x)=(a_0+a_2x^2+a_4x^4+a_6x^6)+(a_1x+a_3x^3+a_5x^5+a_7x^7)\\
=(a_0+a_2x^2+a_4x^4+a_6x^6)+x(a_1+a_3x^2+a_5x^4+a_7x^6)\\
=g(x^2)+x\cdot h(x^2)
$$
其中 $g,h$ 的形式与 $f$ 类似，只是项数少了一半。

如果 $x=\omega_8^k$ 呢？

由上文中得到的性质可得：
$$
f(\omega_8^k)=g((\omega_8^k)^2)+\omega_8^k\cdot h((\omega_8^k)^2)\\
=g(\omega_8^{2k})+\omega_8^k\cdot h(\omega_8^{2k})\\
=g(\omega_4^k)+\omega_8^k\cdot h(\omega_4^k)
$$
$$
f(\omega_8^{k+4})=g((-\omega_8^k)^2)-\omega_8^k\cdot h((-\omega_8^k)^2)\\
=g(\omega_8^{2k})-\omega_8^k\cdot h(\omega_8^{2k})\\
=g(\omega_4^k)-\omega_8^k\cdot h(\omega_4^k)
$$
发现可以分治递归下去。
### 递归版代码
由此就得到了递归版 FFT。
```cpp
#define cpd complex<dd>//c++自带复数STL模板
cpd tmp[N];
void FFT(cpd *f, ll n) {//递归版
//f[i]表示f(w_n^i)
	if (n == 1)return; //此时的多项式内不含未知数，无需带入
	for (int i = 0; i < n; i++) {
		if (i & 1)
			tmp[i / 2 + n / 2] = f[i];
		else
			tmp[i / 2] = f[i];
	}
	for (int i = 0; i < n; i++)
		f[i] = tmp[i];
	cpd *g = f,*h = f + n / 2; //节约空间
	FFT(g, n / 2), FFT(h, n / 2);
	cpd wn = {cos(2 * pi / n), sin(2 * pi / n)}; //单位根
	//2*pi/n为弧度制中单位根的辐角大小
	cpd w = {1, 0}; //单位根的k次幂
	for (int k = 0; k < n / 2; k++) {
		cpd u = g[k], v = w * h[k];
		f[k] = u + v;
		f[k + n / 2] = u - v;
		w *= wn;
	}
}
```
## 非递归版
递归版常数巨大，效率过低，所以就有了非递归版。

首先可以发现在递归到最底层之前没有对数据本身进行任何操作，所以可以想到提前把数据放到底层的位置，然后进行合并操作。

一次完整递归如图所示，大括号表示一组的范围：

![递归](https://cdn.luogu.com.cn/upload/image_hosting/19mjhg3s.png)

可以发现递归前后的位置编号为其二进制下各位颠倒后的数。~~证明我不会~~。

于是可以先预处理出各位最后的位置，然后合并求解。

至于如何预处理，设 $rev_i$ 表示下标 $i$ 转换后的位置。当枚举到 $i$ 时，$rev_{\lfloor\frac{i}{2}\rfloor}$ 一定被求过，此时将 $rev_{\lfloor\frac{i}{2}\rfloor}$ 右移一位得到的数即为 $rev_i$ 不考虑首位的结果。然后判断 $i$ 是否为奇数决定首位即可。

原因是 $\lfloor\frac{i}{2}\rfloor$ 就相当于去掉 $i$ 的二进制末位。

其实递归版也可以这样优化，但是实现较为麻烦，而且效率依旧不及非递归版，本文不再赘述。
### 非递归版代码
然后就得到了非递归版 FFT。
```cpp
#define cpd complex<dd>
void init() {
	ll pos = 1ll << (k - 1);
	for (ll i = 1; i < len; i++) {
		rev[i] = rev[i >> 1] >> 1;
		if (i & 1)rev[i] += pos;
	}
}
inline void change(cpd f[]) {
	for (ll i = 0; i < len; i++) {
		if (i >= rev[i])continue;//防止转换两次又到原位
		swap(f[i], f[rev[i]]);
	}
}
inline void fft(cpd f[]) {//非递归版
//f[i]表示f(w_n^i)
	change(f);
	for (ll n = 2; n <= len; n <<= 1) {//枚举块的大小
		cpd wn = {cos(2 * pi / n), sin(2 * pi / n)};
		//2*pi/n为弧度制中单位根的辐角大小
		for (ll j = 0; j < len; j += n) {//遍历每一个块
			cpd w = {1, 0};
			for (ll i = j; i < j + n / 2; i++) {
				cpd g = f[i], h = w * f[i + n / 2];
				f[i] = g + h;
				f[i + n / 2] = g - h;
				w *= wn;
			}
		}
	}
}
```
# IFFT
通过上面的讲解，可能有巨佬已经发现了。我们只讲了如何从系数表示法转换为点值表示法，而没有讲如何从点值表示法转换回系数表示法。而我们最终需要的是系数表示法的结果。

那么 IFFT（**快速傅里叶逆变换**）就派上用场了。

它其实就是将公式中的 $\omega_n^k$ 替换为 $\omega_n^{-k}$，然后做一遍 FFT，再将最终得到的结果除以 $n$ 即可。

也可以理解为顺时针沿着单位圆转圈。

至于为什么这样做是对的呢？

考虑原本的多项式为：
$$
f(x)=\sum_{i=0}^{n-1}a_ix^i
$$
对其做两遍 FFT，第二遍相当于相当于将第一遍的结果视为另外一个多项式的系数，然后再做 FFT。

所以设：
$$
y_i=f(w_n^i)\\
p(x)=\sum_{i=0}^{n-1}y_ix^i
$$
将 $\omega_n^k$ 的倒数 $\omega_n^{-k}$ 带入 $p$ 可得：
$$
p(\omega_n^{-k})=\sum_{i=0}^{n-1}y_i\omega_n^{-ki}\\
=\sum_{i=0}^{n-1}\omega_n^{-ki}\sum_{j=0}^{n-1}a_j(\omega_n^{j})^i\\
=\sum_{j=0}^{n-1}a_j\sum_{i=0}^{n-1}\omega_n^{ij-ik}\\
=\sum_{j=0}^{n-1}a_j\sum_{i=0}^{n-1}(\omega_n^{j-k})^i
$$
设 $s(\omega_n^x)=\sum_{i=0}^{n-1}(\omega_n^x)^i$，当 $x=0(\mod n)$ 显然有 $s(\omega_n^x)=n$。

当 $x\neq 0(\mod n)$ 时，可得：
$$
s(\omega_n^x)=\sum_{i=0}^{n-1}(\omega_n^x)^i\\
\omega_n^xs(\omega_n^x)=\sum_{i=1}^{n}(\omega_n^x)^i
$$
错位相减，可得：
$$
(\omega_n^x-1)s(\omega_n^x)=\omega_n^n-\omega_n^0=0
$$
即：
$$
s(\omega_n^x)=0
$$
所以只有 $j=k$ 的时候，$\sum_{j=0}^{n-1}(\omega_n^{j-k})^i$ 不为 $0$，即 $\sum_{j=0}^{n-1}(\omega_n^{j-k})^i=n$。于是得：
$$
p(\omega_n^{-k})=\sum_{i=0}^{n-1}a_j\sum_{j=0}^{n-1}(\omega_n^{j-k})^i\\
=\sum_{i=0}^{n-1}a_jn
$$
由此可得，只要反着做一遍 FFT，然后将结果除以 $n$ 即可。

可以将这两个操作合二为一，只要将单位根替换为单位根的倒数（即将其纵坐标变为原来的相反数），结束时特判除以 $n$ 即可。（代码见完整代码）
# 完整代码
递归版和非递归版的代码都在这。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ull unsigned long long
#define ll long long
#define ld long double
#define dd double
//char buf[1<<23],*p1=buf,*p2=buf;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<23,stdin),p1==p2)?EOF:*p1++)
inline ll read() {
	ll x = 0, f = 1;
	char ch;
	while (((ch = getchar()) < 48 || ch > 57)&&ch!=EOF)if (ch == '-')f = -1;
	while (ch >= 48 && ch <= 57)x = x * 10 + ch - 48, ch = getchar();
	return x * f;
}
char __sta[1009], __len;
inline void write(ll x,ll bo) {
	if (x < 0)putchar('-'), x = -x;
	do __sta[++__len] = x % 10 + 48, x /= 10;
	while (x);
	while (__len)putchar(__sta[__len--]);
	if(bo==3)return;
	putchar(bo ? '\n' : ' ');
}
#define cpd complex<dd>
const ll N=4e6+9;
const dd pi=acos(-1.0);
ll n,m,len;
cpd f[N],g[N];
ll rev[N];
void init(){
	n=read(),m=read();
	for(int i=0;i<=n;i++){
		f[i]={read(),0};
	}
	for(int i=0;i<=m;i++){
		g[i]={read(),0};
	}
	len=1;
	ll k=0;
	while(len<=n*2||len<=m*2)len<<=1,k++;
	ll pos=1<<(k-1);
	for(int i=1;i<len;i++){
		rev[i]=rev[i>>1]>>1;
		if(i&1)rev[i]+=pos;
	}
}
/*————————————华丽的分割线————————————*/
inline void change(cpd f[]){
	for(int i=0;i<len;i++){
		if(i>=rev[i])continue;//防止转换两次又到原位
		swap(f[i],f[rev[i]]);
	}
}
inline void fft(cpd f[],ll on){//非递归版
	change(f);
	for(int n=2;n<=len;n<<=1){//枚举块的大小
		cpd wn={cos(2*pi/n),sin(2*pi*on/n)};
		//2*pi/n为弧度制中单位根的辐角大小
		for(int j=0;j<len;j+=n){
			cpd w={1,0};
			for(int i=j;i<j+n/2;i++){
				cpd u=f[i],v=w*f[i+n/2];
				f[i]=u+v;
				f[i+n/2]=u-v;
				w*=wn;
			}
		}
	}
	if(on==-1){
		for(int i=0;i<len;i++){
			f[i]/=len;
		}
	}
}
/*————————————华丽的分割线————————————*/
cpd tmp[N];
void FFT(cpd *f, ll n, ll on) {//递归版
//f[i]表示f(w_n^i)
	if (n == 1)return; //此时的多项式内不含未知数，无需带入
	for (int i = 0; i < n; i++) {
		if (i & 1)
			tmp[i / 2 + n / 2] = f[i];
		else
			tmp[i / 2] = f[i];
	}
	for (int i = 0; i < n; i++)
		f[i] = tmp[i];
	cpd *g = f,*h = f + n / 2; //节约空间
	FFT(g, n / 2, on), FFT(h, n / 2, on);
	cpd wn = {cos(2 * pi / n), sin(on * 2 * pi / n)}; //单位根
	//2*pi/n为弧度制中单位根的辐角大小
	cpd w = {1, 0}; //单位根的k次幂
	for (int k = 0; k < n / 2; k++) {
		cpd u = g[k], v = w * h[k];
		f[k] = u + v;
		f[k + n / 2] = u - v;
		w *= wn;
	}
}
inline void fix(cpd *f) {
	for (int i = 0; i < len; i++)f[i] /= len;
}
/*————————————华丽的分割线————————————*/
void solve(){
	for(int i=0;i<len;i++){
		f[i]*=g[i];
	}
}
void finish(){
	for(int i=0;i<=n+m;i++){
		write(f[i].real()+0.5,0);
	}
}
int main(){
	init();
//	fft(f,1),fft(g,1);
	
	FFT(f,len,1),FFT(g,len,1);
	solve();
//	fft(f,-1);
	
	FFT(f,len,-1);
	fix(f);
	finish();
	return 0;
}
```

# 参考资料
[oi-wiki](https://oi-wiki.org/math/poly/fft/)。

---


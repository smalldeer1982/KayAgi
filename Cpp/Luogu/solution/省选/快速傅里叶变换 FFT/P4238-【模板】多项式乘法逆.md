# 【模板】多项式乘法逆

## 题目背景

注意：本题并不属于中国计算机学会划定的提高组知识点考察范围。

## 题目描述

给定一个多项式 $F(x)$ ，请求出一个多项式 $G(x)$， 满足 $F(x) * G(x) \equiv 1 \pmod{x^n}$。系数对 $998244353$ 取模。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$ 0 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
5
1 6 3 4 9```

### 输出

```
1 998244347 33 998244169 1020```

# 题解

## 作者：Great_Influence (赞：59)

递归求解。

求模 $x^n$ 的逆元时，假设先求出了模 $x^{\lceil\frac{
n}{2}\rceil}$ 的逆元。

设模 $x^n$ 逆元为 $B$ ，模 $x^{\lceil\frac{n}{2}\rceil}$ 逆元为 $B'$ ，则：

$$A*B'\equiv 1\pmod {x^{\lceil\frac{z}{2}\rceil}}$$

且

$$A*B\equiv 1\pmod {x^{\lceil\frac{z}{2}\rceil}}$$

$$\therefore B'-B\equiv 0\pmod {x^{\lceil\frac{z}{2}\rceil}}$$

两边平方，则

$$(B'-B)^2\equiv 0\pmod {x^z}$$

拆项，

$$B'^2-2BB'+B^2\equiv 0\pmod {x^z}$$

左右同乘$A$,

$$AB'^2-2B'+B\equiv 0\pmod {x^z}$$

移项，得

$$B\equiv 2B'-AB'^2\pmod {x^z}$$

然后就得到了关于 $B$ 的递推式。因为从上向下递归很麻烦，所以从下向上递推。从 $x^1$ 开始推至 $x^{2^z}(2^z>=n)$ 即可。初值是 $B=\{A(0)^{-1}\}$ 。

利用 NTT 可以将多项式乘法优化至$n\log n$，利用主定理计算得总时间复杂度为$O(n\log n)$。

代码：

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
using namespace std;
template<typename T>inline void read(T &x){
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&k^'-')k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
void file(void){
    #ifndef ONLINE_JUDGE
    freopen("water.in","r",stdin);
    freopen("water.out","w",stdout);
    #endif
}
const int MAXN=1<<20;
static int n,m,rev[MAXN],a[MAXN],b[2][MAXN];
inline void init()
{
    read(n);--n;
    Rep(i,0,n)read(a[i]);
    m=n<<1;
    for(n=2;n<=m;n<<=1);
}
inline void calrev(int n,int len)
{
    Rep(i,1,n-1)rev[i]=(rev[i>>1]>>1)|((i&1)<<len);
}
const int mod=998244353,gen=3;
inline int modu(long long x)
{
    if(x<mod)return x;
    return x-x/mod*mod;
}
inline int power(int x,int y)
{
    static int sum;
    for(sum=1;y;y>>=1,x=modu(1ll*x*x))
        if(y&1)sum=modu(1ll*sum*x);
    return sum;
}
static int P[MAXN],iv[MAXN];
inline void predone(int n)
{
    static int i,j;
    for(i=1,j=2;j<=n<<1;++i,j<<=1)
    {
        P[i]=power(gen,(mod-1)/j);
        iv[i]=power(P[i],mod-2);
    }
}
inline int modulo(int x,int y){x+=y;if(x>=mod)x-=mod;return x;}
inline void NTT(int x[],int type)
{
    Rep(i,1,n-1)if(i<rev[i])swap(x[i],x[rev[i]]);
    static int i,j,k,kk,t,w,wn,tk;
    for(i=2,tk=1;i<=n;i<<=1,++tk)
    {
        kk=i>>1;
        if(type==1)wn=P[tk];
        else wn=iv[tk];
        for(j=0;j<n;j+=i)
        {
            w=1;
            for(k=0;k<kk;++k,w=modu(1ll*w*wn))
            {
                t=modu(1ll*w*x[j+k+kk]);
                x[j+k+kk]=module(x[j+k],mod-t);
                x[j+k]=module(x[j+k],t);
            }
        }
    }
    if(type==-1)
    {
        int inv=power(n,mod-2);
        Rep(i,0,n)x[i]=modu(1ll*x[i]*inv);
    }
}
static int X[MAXN],Y[MAXN];
inline void mul(int x[],int y[])
{
    memset(X,0,sizeof X);
    memset(Y,0,sizeof Y);
    Rep(i,0,n>>1)X[i]=x[i],Y[i]=y[i];
    NTT(X,1);NTT(Y,1);
    Rep(i,0,n)X[i]=modu(1ll*X[i]*Y[i]);
    NTT(X,-1);
    Rep(i,0,n)x[i]=X[i];
}
static int c[MAXN];
inline void test(int z)
{
    memset(c,0,sizeof c);
    Rep(i,0,n)c[i]=a[i];
    mul(c,b[z]);Rep(i,0,m>>1)cout<<c[i]<<' ';puts("");
}
inline void solve()
{
    static int t=0,bas=1,len=1;
    b[0][0]=power(a[0],mod-2);
    n=4;
    calrev(n,len);
    while(bas<m)
    {
        t^=1;
        memset(b[t],0,sizeof b[t]);
        Rep(i,0,bas)b[t][i]=module(b[t^1][i]<<1,0);
        mul(b[t^1],b[t^1]);
        mul(b[t^1],a);
        Rep(i,0,bas)b[t][i]=module(b[t][i],mod-b[t^1][i]);
        bas<<=1;n<<=1;++len;
        if(bas<m)calrev(n,len);
    }
    Rep(i,0,m>>1)printf("%d ",b[t][i]);
    puts("");
}
int main(void){
    file();
    init();
    predone(n);
    solve();
    //cerr<<1.0*clock()/CLOCKS_PER_SEC<<endl;
    return 0;
}

```

---

## 作者：KAMIYA_KINA (赞：19)

## 多项式求逆

### Preface

本篇与其他的题解推导略有不同，主要使用了**牛顿迭代法**，虽然最后的式子都是一样的，但是该方法泛用性更加广泛一些。

### Description

已知 $F(x)$，要求出 $G(x) * F(x) \equiv 1 \pmod{x^n}$，系数对 $998244353$ 取模。

### Solution

对这个式子进行推导，我们将一个多项式变成一个简单的未知数，然后思考这个式子。

移项

$$
F(x) - \frac{1}{G(x)} \equiv 0 \pmod{x^n}
$$

这个东西可以用牛顿迭代公式计算。（OIer 们习惯性去直接背诵这个公式）

接下来是牛顿迭代的推导，不想看的同学可以直接快进到结论。

已知一个复合多项式

$$
G(F(x)) \equiv 0 \pmod{x^n}
$$

假设已知 $F_0(x)\equiv F(x) \pmod{x^{\lceil\frac{n}{2}\rceil}}$，求 $F_1(x) \equiv F(x) \pmod{x^n}$。

根据泰勒公式，在 $F_0(x)$ 处展开 $G(F(x))$。

$$
G(F(x)) = \sum_{i=0}^{\infty}\frac{G^{(i)}(F_0(x))}{i!}(F(x)-F_0(x))^i
$$

可以发现，$ F(x)-F_0(x) \equiv 0 \pmod{x^{\lceil\frac{n}{2}\rceil}}$，所以 $(F(x)-F_0(x))^k \equiv 0 \pmod{x^n}$ 在 $k \ge 2$ 的时候成立。

因此：

$$
G(F_1(x)) \equiv G(F_0(x)) + G'(F_0(x))(F_1(x) - F_0(x)) \pmod{x^n}
$$

又 $G(F_1(x)) \equiv 0 \pmod{x^n}$，整理得到：

$$
F_1(x)=F_0(x)-\frac{G(F_0(x))}{G'(F_0(x))}
$$

许多人熟知的牛顿迭代公式就是这个玩意了，然后这个东西的应用也非常简单。

以这个题目为例：

令 $H(t)=F(x)-\frac{1}{t}$，那么就可以得到：

$$
H(G(x)) \equiv 0 \pmod{x^n}
$$

然后套入牛顿迭代公式：

$$
G_1(x)=G_0(x)-\frac{H(G_0(x))}{H'(G_0(x))}
$$

将 $H(t) = F(x) - \frac{1}{t}$ 套回去，注意这里的 $F(x)$ 表示的是一个常数，那么就可以得到：

$$
G_1(x)=G_0(x) - \frac{F(x)-\frac{1}{G_0(x)}}{\frac{1}{G_0(x)^2}}
$$

化简一下可以得到：

$$
G_1(x)=G_0(x)(2-G_0(x)F(x))
$$

打个 NTT 求解一下就可以了。注意边界情况！

### code

~~~cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long

#define FOR(i,a,b) for(int i=(a),i##i=(b);i<=i##i;i++)
#define ROF(i,a,b) for(int i=(a),i##i=(b);i>=i##i;i--)

#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
char buf[100000], *p1(buf), *p2(buf);
#define rd read()
inline int read() {
    int x = 0, f = 1;
    char ch = gc;
    while(!isdigit(ch)) {
        if(ch == '-') f = 0;
        ch = gc;
    }
    while(isdigit(ch)) {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = gc;
    }
    return f ? x : -x;
}

const int N = 3e5 + 1;
const int mod = 998244353, g = 3;

inline int ksm(int x, int y) {
    int ret = 1;
    for(; y; y >>= 1, x = x * x % mod)
        if(y & 1) ret = ret * x % mod;
    return ret;
}

int rev[N];

inline void NTT(int *a, int n, int typ) {
    for(int i = 0; i < n; i++) if(i < rev[i]) swap(a[i], a[rev[i]]);
    for(int i = 1; i < n; i <<= 1) {
        int gn = ksm(g, (mod - 1) / (i << 1));
        for(int j = 0, g0 = 1, x, y; j < n; j += (i << 1), g0 = 1) 
        for(int k = 0; k < i; k++, g0 = gn * g0 % mod) {
            x = a[j + k], y = a[i + j + k] * g0 % mod;
            a[j + k] = (x + y) % mod;
            a[i + j + k] = (x - y + mod) % mod;
        }
    }
    if(typ == 1) return ;
    int inv = ksm(n, mod - 2); reverse(a + 1, a + n);
    for(int i = 0; i < n; i++) a[i] = a[i] * inv % mod;
    return ;
}

void INV(int *b, int *a, int n) {
    if(n == 1) return b[0] = ksm(a[0], mod - 2), void();
    INV(b, a, (n + 1) >> 1);
    static int c[N];
    int len = 1, p = -1; while(len < (n << 1)) len <<= 1, p++;
    FOR(i, 1, len - 1) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << p);
    copy(a, a + n, c), fill(c + n, c + len, 0);
    NTT(c, len, 1), NTT(b, len ,1);
    FOR(i, 0, len - 1) b[i] = (2 - b[i] * c[i] % mod + mod) % mod * b[i] % mod;
    NTT(b, len, 0), fill(b + n, b + len, 0);
    return ;
}

int a[N], b[N], n;

#undef int

inline void work() {
    n = rd;
    FOR(i, 0, n - 1) a[i] = rd;
    INV(b, a, n);
    FOR(i, 0, n - 1) cout << b[i] << ' ';
    return ;
}

int main() {
    work();
    return 0;
} 
~~~

## 参考文章
* [Fuyuki 大佬](https://www.luogu.com.cn/blog/Fuyuki/dui-duo-xiang-shi-niu-dun-die-dai-suan-fa-di-yi-suo-li-xie)（修补了文中一些错误的公式）

* [超级大蒟蒻](https://www.luogu.com.cn/blog/juruo-4721/yi-suo-bei-wang) （这个人真的是太菜了）

---

## 作者：huangzirui (赞：8)

题意：

求多项式 $\ F(x)\ $ 的逆元。即求 $\ G(x)\ $ 令 $\ F(x)G(x) \equiv 1 \pmod{x^n} $

---

(算法：分治FFT)

(下面一律都把同余符号去掉了）

考虑关系式

$$F(x)G(x)=1$$

我们有：

对于所有的 $k\in [0,n]$ 

$$\sum\limits_{i+j=k}a_ib_j=[k=0]$$

对 $k=0$ 情况特殊处理后有

$$\sum\limits_{i+j=k}a_ib_j=0$$

---

考虑进行递推。

如果我们已经求出了前 $x-1$ 项，那么：

$$b_xa_0=\sum\limits_{i+j=x\ \&\&\ j \not=x}-a_ib_j$$

即：

$$b_x=\sum\limits_{i+j=x\ \&\&\ j \not=x}-a_ib_j\cdot\dfrac{1}{a_0}$$

于是分治FFT即可。时间复杂度 $Θ(n log^2n)$。

（注意卡常）

```cpp
#include<bits/stdc++.h>
#define ll long long
#define re register
using namespace std;
inline int read(){
	char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int maxn=400010;
const ll mod=998244353;
int i,j,k,n,m;
ll A[maxn],B[maxn],a[maxn],b[maxn];
ll M[25][2];
int R[maxn];
inline ll ksm(re ll sum,re int num){
	re ll ans=1;
	while(num){
		if(num&1)
			ans=ans*sum%mod;
		sum=sum*sum%mod;
		num>>=1;
	}return ans;
}
inline void NTT(int len,ll *a,bool op){
	for(re int i=0;i<=len;i++)
		if(i<R[i])swap(a[i],a[R[i]]);
	for(re int i=1,I=1;i<len;i<<=1,++I){
		ll Wn;if(op)Wn=0;else Wn=1;
//		if(op)Wn=3;else Wn=332748118;
//		Wn=ksm(Wn,(mod-1)/(i*2));
		Wn=M[I][Wn];
		for(re int j=0;j<len;j+=i<<1){
			ll w=1;
			for(re int k=0;k<i;k++,w=w*Wn%mod){
				int K=k+j;
				ll S1=a[K],S2=w*a[K+i]%mod;
				a[K]=(S1+S2)%mod;
				a[K+i]=(S1-S2+mod)%mod; 
			}
		}
	}
}
inline void solov(int len,int l,int r){
	NTT(len,A,1);NTT(len,B,1);
	for(re int i=0;i<=len;i++)A[i]=A[i]*B[i]%mod;
	NTT(len,A,0);
	for(re int i=(l+r)/2+1-l;i<=r-l;i++)A[i]=A[i]*ksm(len,mod-2)%mod;
}
ll T;
inline void work(int l,int r){
	if(l==r)return;
	int Mid=l+r>>1; 
	work(l,Mid);
	
	int x=Mid-l+1,y=n,len=1,L=0;
	while(len<=x<<1)len<<=1,++L;
	for(re int i=0;i<=len;i++)
		R[i]=(R[i>>1]>>1)+((i&1)<<L-1);
	
	B[0]=0;
	for(re int i=Mid-l+1;i<=len;i++)B[i]=0;
	for(re int i=min(len,n);i<=len;i++)A[i]=0;
	for(re int i=l;i<=Mid;i++)B[i-l]=b[i];
	for(re int i=0;i<min(len,n);i++)A[i]=a[i];
	solov(len,l,r);
	for(re int i=Mid+1;i<=r;i++)b[i]=(b[i]-A[i-l]*T%mod+mod)%mod;
	work(Mid+1,r);
	return;
}
int main(){
	cin>>n;
	for(i=1;i<=23;i++)
		M[i][0]=ksm(3,(mod-1)/(1<<i))%mod,M[i][1]=ksm(332748118,(mod-1)/(1<<i))%mod;
	for(i=1;i<=n;i++)a[i-1]=read();
	b[0]=ksm(a[0],mod-2);
	int L=1;
	T=ksm(a[0],mod-2);
	while(L<n)L<<=1;
	work(0,L-1);
	for(i=0;i<n;i++)printf("%lld ",b[i]);
	cout<<endl;
	return 0;
}
```

---

## 作者：lzyqwq (赞：4)

选自我的 [多项式与生成函数学习笔记](https://www.luogu.com.cn/article/ismqu7s9)。

> - 对于一个多项式 $A(x)=\sum\limits_{i=0}^na_ix^i$，定义 $A(x)\bmod x^m=\sum\limits_{i=0}^{m-1}a_ix^i$。特殊地，当 $m>n$ 时，$A(x)\bmod x^m=A(x)$。
> - 给出一个 $n-1$ 次多项式 $A(x)$，求出一个多项式 $B(x)$，满足 $A(x)B(x)\bmod x^n=1$。输出 $B(x)\bmod x^n$ 的各次项系数。系数对 $998244353$ 取模。
> - $n\le 10^5$。保证 $a_0\ne 0$。

首先有一些比较显然的事情：

- $(F(x)+G(x))\bmod x^n=F(x)\bmod x^n+G(x)\bmod x^n$。

  考虑和的多项式的系数就是由原来两个多项式相加而来。

- $F(x)G(x)\bmod x^n=(F(x)\bmod x^n)(G(x)\bmod x^n)\bmod x^n$。
  
  考虑 $F(x),G(x)$ 次数不低于 $x^n$ 的项在余数中没有贡献。

当 $n=1$ 时，$B(x)$ 就是一个常数，她等于 $a_0$ 的倒数。

注意到若 $F(x)\bmod x^n=1$，那么对于任意 $m<n$，都有 $F(x)\bmod x^m=1$。记 $2^k$ 为第一个不小于 $n$ 的 $2$ 的幂。考虑求出一个多项式 $B(x)$ 满足 $A(x)B(x)\bmod x^{2^k}=1$。

记 $B_{i}(x)$ 表示 $A(x)$ 在模 $x^{2^i}$ 意义下的逆（同时满足其最高次数低于 $x^{2^i}$，即自动对 $x^{2^i}$ 取模）。那么 $B_0(x)=\dfrac{1}{a_0}$。类似数学归纳法，假设我们已经求出了 $B_i$，考虑 $B_{i+1}$ 怎么求。注意到：

$$A(x)B_i(x)\bmod x^{2^i}=1\\A(x)B_{i+1}(x)\bmod x^{2^i}=1$$

那么 $A(x)(B_{i+1}(x)-B(x))\bmod x^{2^i}=0$。

由于 $A(x)\bmod x^{2^i}$ 中必然有常数项，其不为 $0$。所以 $(B_{i+1}(x)-B(x))\bmod 2^{x^i}=0$。

两边同时平方得：

$$(B_{i+1}^2(x)-2B_{i}(x)B_{i+1}(x)+B^2_{i}(x))\bmod x^{2^{i+1}}=0$$

这里直接把模数改成 $x^{2^{i+1}}$ 是因为 $(B_{i+1}(x)-B_i(x))\bmod x^{2^i}=0$，即不出现次数低于 $x^{2^i}$ 的项，因此平方后最低次项也不会低于 $x^{2^{i+1}}$。

两边再同时乘 $A(x)$，由于 $A(x)B_{i+1}(x)\bmod x^{2^{i+1}}=1$，可得：

$$\left(B_{i+1}(x)-2B_i(x)+A(x)B_i^2(x)\right)\bmod x^{2^{i+1}}=0$$

所以 $B_{i+1}(x)\bmod x^{2^{i+1}}=B_i(x)(2-A(x)B_i(x))\bmod x^{2^{i+1}}$。

那么就可以由上式推出 $B_{i+1}(x)$。NTT 计算即可。

时间复杂度 $T(n)=T\left(\dfrac{n}{2}\right)+\mathcal{O}(n\log n)=\mathcal{O}(n\log n)$。空间线性。

注意到每次递推的时候 $A(x)$ 要对 $x^{2^{i+1}}$ 取模，求出的结果也要取模。不然时间复杂度会退化为 $\mathcal{O}\left(n\log^2n\right)$。


```cpp
#include <bits/stdc++.h>
using namespace std; const int N = 1 << 21;
namespace Poly {
	using ll = long long; using poly = vector<ll>;
	const ll M = 998244353, G = 3; int R[N]; poly get(int n) { return poly(n + 1); }
	ll qp(ll x, ll y) {
		ll r = 1; for (; y; y >>= 1, x = x * x % M) if (y & 1) r = r * x % M;
		return r;
	}
	void init(int n) {
		for (int i = 0; i < n; ++i) {
			R[i] = R[i >> 1] >> 1; if (i & 1) R[i] |= n >> 1;
		}
	}
	void NTT(poly &a, int n, bool o = 0) {
		if (o) init(n);
		for (int i = 0; i < n; ++i) if (i < R[i]) swap(a[i], a[R[i]]);
		for (int i = 2; i <= n; i <<= 1) {
			ll g = qp(G, (M - 1) / i), w, u, v;
			for (int j = 0; j < n; j += i) {
				w = 1;
				for (int k = j; k < j + (i >> 1); ++k, w = w * g % M)
					u = a[k], v = w * a[k + (i >> 1)] % M,
					a[k] = (u + v) % M, a[k + (i >> 1)] = (u - v + M) % M;
			}
		}
	}
	poly operator+(poly a, poly b) {
		int n = max(a.size(), b.size()); a.resize(n); b.resize(n);
		poly c = get(n - 1); for (int i = 0; i < n; ++i) c[i] = (a[i] + b[i]) % M;
		return c;
	}
	poly operator-(poly a, poly b) {
		int n = max(a.size(), b.size()); a.resize(n); b.resize(n);
		poly c = get(n - 1);
		for (int i = 0; i < n; ++i) c[i] = (a[i] - b[i] + M) % M; return c;
	}
	poly operator*(poly a, poly b) {
		int n = a.size(), m = b.size(), L = 1; while (L < n + m - 1) L <<= 1;
		a.resize(L); b.resize(L); NTT(a, L, 1); NTT(b, L);
		for (int i = 0; i < L; ++i) a[i] = a[i] * b[i] % M; NTT(a, L);
		poly c = get(n + m - 2); ll inv = qp(L, M - 2); c[0] = a[0] * inv % M;
		for (int i = 1; i < n + m - 1; ++i) c[i] = a[L - i] * inv % M; return c;
	}
	poly mod(poly a, int n) { a.resize(n, 0); return a; }
	poly inv(poly a) {
		poly c = get(0), d = get(0); c[0] = qp(a[0], M - 2); d[0] = 2;
		for (int i = 1; (1 << i - 1) < a.size(); ++i)
			c = mod(c * (d - mod(a, 1 << i) * c), 1 << i);
		return c;
	}
}
using namespace Poly; int n; poly f, g;
int main() {
	cin.tie(0); cout.tie(0); ios::sync_with_stdio(0); cin >> n; f = get(n - 1);
	for (int i = 0; i < n; ++i) cin >> f[i], f[i] %= M; g = inv(f);
	for (int i = 0; i < n; ++i) cout << g[i] << ' '; return 0;
}
```

---

## 作者：under_the_time (赞：1)

# 多项式求逆

给定多项式 $f=\sum_{k\ge 0}a_kx^k$，定义其多项式逆 $f^{-1}$，满足 $f*f^{-1}=1$ 即它们卷积结果为一个仅包含常数项 $1$ 的多项式。逆运算满足 $(f\bmod x^n)^{-1}\bmod x^n=f^{-1}\bmod x^n$，这里 $f\bmod x^n$ 表示只保留 $f$ 的前 $n$ 项得到的多项式。一个多项式无论是有限次还是无限次，其逆都有可能是无限次多项式。一个多项式存在逆当且仅当其常数项非 $0$。

本题即为给定一个次数界为 $n$ 的多项式 $f$，求 $f^{-1}\bmod {x^n}$ 在模 $998244353$ 意义下的结果。

考虑**多项式倍增**。我们先将 $f$ 补成一个次数界为 $2$ 的幂次的多项式。假设我们已经求得 $f^{-1}$ 的前 $k$ 项系数 $\hat g=f^{-1}\bmod x^k$，现在欲求 $f^{-1}$ 的前 $2k$ 项系数 $g=f^{-1}\bmod {x^{2k}}$。当 $k=1$ 时显然 $\hat g=([x^0]f)^{-1}$。

因为 $g$ 与 $\hat g$ 的前 $k$ 项系数是相同的，于是有 $g-\hat g\equiv 0\pmod {x^k}$。对于一个前 $k$ 项系数均为 $0$ 的多项式 $h$，其平方的多项式 $h^2$ 的前 $2k$ 项系数一定为 $0$。那么就有 $(g-\hat g)^2\equiv 0\pmod {x^{2k}}$，展开得 $\hat g^2-2\hat g*g+g^2\equiv 0\pmod {x^{2k}}$；两边同时乘 $f$，由 $f*g\equiv 1\pmod {x^{2k}}$ 得到 $f\hat g^2-2\hat g+g\equiv 0\pmod {x^{2k}}$；移项即可得到 $g$ 的表达式
$$
g\equiv2\hat g-f\hat g^2\pmod{x^{2k}}
$$
由于模数是 $998244353$，我们可以使用 NTT 使得单次倍增的时间复杂度为 $O(k\log k)$。总复杂度就是 $O(1\log 1+2\log 2+4\log 4+\cdots + n\log n)=O(n\log n)$。

- 一个优化常数的技巧：注意到 $f*\hat g\equiv 1\pmod {x^k}$，也就是说 $f\hat g^2\equiv \hat g\pmod {x^k}$，那么 $g$ 的前 $k$ 项系数就是 $(2f\hat g^2-f\hat g^2)\bmod x^k=f\hat g^2\bmod x^k$；又由于 $\hat g$ 的后 $k$ 项系数均为 $0$，那么 $g$ 的后 $k$ 项系数就是 $f\hat g^2$ 的后 $k$ 项系数的相反数。
- 所以每次倍增只需求出 $f\hat g^2\bmod x^{2k}$，然后把后 $k$ 项系数取相反数即可。

```cpp
// NTT 数论变换的部分就省略了
void poly_mul(int *tmp_f, int *tmp_g, int n, int *h) {
    for (int i = 0; i < n; i ++)
        f[i] = tmp_f[i], g[i] = tmp_g[i];
    for (int i = n; i < (n << 1); i ++)
        f[i] = g[i] = 0;
    NTT(f, n << 1, 1), NTT(g, n << 1, 1);
    for (int i = 0; i < (n << 1); i ++)
        h[i] = mul(f[i], g[i]);
    NTT(h, n << 1, -1);
} void poly_sqr(int *tmp_f, int n, int *h) { // 注意到计算多项式平方的时候只需进行一次数论变换，可以优化常数
    for (int i = 0; i < n; i ++) f[i] = tmp_f[i];
    for (int i = n; i < (n << 1); i ++) f[i] = 0;
    NTT(f, n << 1, 1);
    for (int i = 0; i < (n << 1); i ++)
        h[i] = mul(f[i], f[i]);
    NTT(h, n << 1, -1);
}
int tmp1[maxn << 2];
void poly_inv(int *f, int n, int *g) { // 多项式求逆
    g[0] = divv(1, f[0]); // 求得逆的常数项
    for (int k = 2; k <= n; k <<= 1) {
        poly_sqr(g, k >> 1, tmp1), poly_mul(f, tmp1, k, g); // 求得 fg^2
        for (int i = (k >> 1); i < k; i ++) g[i] = sub(0, g[i]); // 将后 k 项系数取相反数
    }
}
```

---

## 作者：cike_bilibili (赞：1)

## 多项式乘法求逆

多项式乘法的逆元：现有 $n-1$ 次多项式 $f(x)$，若函数 $g(x)$ 满足 $f(x)g(x) \equiv 1 \pmod {x^n}$，则 $g(x)$ 是 $f(x)$ 的逆元。

这里讨论 $\bmod \ x^n$ 下的逆元。

求解逆元的算法主要依靠倍增实现，我们现在要求 $\bmod \ x^n$ 意义下的逆元，若现在我们已经得出了 $\bmod \ x^{\frac{n}{2}}$ 的逆元，考虑如何推导。

设 $f(x)g(x) \equiv 1  \pmod  {x^n}$，$f(x)g'(x) \equiv 1  \pmod {x^{\frac{n}{2}}}$，则：

$$ g(x)-g'(x) \equiv 0 \pmod {x^{\frac{n}{2}}}$$

两边同时平方：

$$g^2(x) - 2g(x)g'(x)+g'^2(x) \equiv 0 \pmod  {x^n} $$

同时乘上 $f(x)$，有：

$$g(x) - 2g'(x) + f(x)g'^2(x) \equiv 0 \pmod  {x^n}$$

移项即可得到递推式：

$$g(x) \equiv 2g'(x) - f(x)g'^2(x) \pmod  {x^n} $$

利用 NTT 快速多项式乘法即可，主定理分析即可得到时间复杂度 $O(n\log n)$。

## Code


```cpp
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
using namespace std;
inline int read(){
    int ans=0,w=1;
    char ch=getchar();
    while(ch<48||ch>57){
       if(ch=='-')w=-1;
       ch=getchar();
    }
    while(ch>=48&&ch<=57){
       ans=(ans<<1)+(ans<<3)+ch-48;
       ch=getchar();
    }
    return w*ans;
}
const int mod=998244353,gn=3,inv=332748118;
ll Pow(ll x,ll y){
    ll ans=1,push=x;
    while(y){
        if(y&1)ans=ans*push%mod;
        push=push*push%mod;
        y>>=1;
    }
    return ans;
}
int n;
int a[400005],p[400005];
int f[400005],g[400005],d1[400005],d2[400005],res[400005];
int rev[400005];
inline void init(int k){
    for(int i=0;i<(1<<k);i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<(k-1));
}
inline void NTT(int *a,int *r,int n,int opt){
    for(int i=0;i<n;i++)r[i]=a[i];
    for(int i=0;i<n;i++){
        if(i<rev[i])swap(r[i],r[rev[i]]);
    }
    for(int l=2;l<=n;l<<=1){
        int W=Pow((opt==1)?gn:inv,(mod-1)/l);
        for(int i=0;i<n;i+=l){
            int w=1;
            for(int j=i;j<i+(l>>1);j++,w=1ll*w*W%mod){
                int p=r[j],q=r[j+(l>>1)];
                r[j]=(p+1ll*w*q)%mod,r[j+(l>>1)]=(p-1ll*w*q%mod+mod)%mod;
                
            }
        }
    }
    if(opt==-1)for(int i=0;i<n;i++)r[i]=1ll*r[i]*Pow(n,mod-2)%mod;
}
inline void mul(int n,int *f,int *g,int *res){
    init(__lg(n));
    NTT(f,d1,n,1),NTT(g,d2,n,1);
    for(int i=0;i<n;i++)d1[i]=1ll*d1[i]*d2[i]%mod;
    NTT(d1,res,n,-1);
    for(int i=0;i<n;i++)d1[i]=d2[i]=0;
}
int b[400005],c[400005];
void get_inv(int n,int *f,int *res){
    memset(f,0,sizeof f);
    int len=1,m=4;
    f[0]=a[0];
    res[0]=Pow(f[0],mod-2);
    
    while(len<n){
        memset(b,0,sizeof b);
        mul(m,res,res,b);
        for(int i=len;i<2*len;i++)f[i]=a[i];
        mul(m,b,f,b);
        for(int i=len;i<2*len;i++)res[i]=(2ll*res[i]-b[i]+mod)%mod;
        
        len<<=1;m<<=1;
    }
}
signed main(){
    n=read();
    for(int i=0;i<n;i++)a[i]=read();
    get_inv(n,p,res);
    for(int i=0;i<n;i++)cout<<res[i]<<' ';
    return 0;
}
```

---

## 作者：feicheng (赞：0)

[$\text{cnblogs}$](https://www.cnblogs.com/hl-fc/p/15058515.html)

[$\text{Luogu Blogs}$](https://www.luogu.com.cn/blog/feicheng/solution-p4238)
## $\texttt{Description}$

给 $\operatorname{deg}=n$ 的多项式 $f$，求多项式 $g$，满足
$$
f*g\equiv 1 \pmod {x^n}
$$

系数对 $998244353$ 取模。

$\texttt{restrictions:}1\le n\le10^5$

## $\texttt{Solution}$

假设 $\operatorname{deg}=1$，则可以通过快速幂直接求出来，所以考虑递归。

假设我们已经求出 $h*f \equiv 1 \pmod {x^n}$，考虑如何转移到 $x^{2n}$

显然有 

$$
f*g\equiv 1\pmod {x^n}
$$

于是有

$$
f*(g-h)\equiv 0 \pmod {x^n}
$$

$$
g-h \equiv 0 \pmod {x^n}
$$

$$
(g-h)^2 \equiv 0 \pmod {x^{2n}}
$$

$$
g^2-2gh+h^2\equiv 0 \pmod {x^{2n}}
$$

同乘 $f$，有。

$$
g-2h+fh^2\equiv 0\pmod {x^{2n}}
$$

$$
g\equiv h(2+fh)\pmod {x^{2n}}
$$

即可求解。

## $\texttt{Code}$

```cpp
inline friend Poly Inv(Poly a) {
      if (a.size() == 1) {
        Poly tmp(1) ;
        return tmp[0] = ksm(a[0]),tmp ;
      }
      const int len = a.size() ;
      Poly ta = a; ta.resize((len + 1) >> 1) ;
      Poly tb = Inv(ta) ;
      Getrev(len << 1),a.resize(lim),tb.resize(lim),a.ntt(lim,1),tb.ntt(lim,1) ;
      for (int i = 0; i < lim; ++i) tb[i] = 1ll * tb[i] * (mod + 2 - 1ll * a[i] * tb[i] % mod) % mod ;
      return tb.ntt(lim,-1),tb.resize(len),tb ;
    }
```

---


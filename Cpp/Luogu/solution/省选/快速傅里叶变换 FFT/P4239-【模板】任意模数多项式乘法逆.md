# 【模板】任意模数多项式乘法逆

## 题目描述

给定一个多项式 $F(x)$ ，请求出一个多项式 $G(x)$ ， 满足 $F(x) * G(x) \equiv 1 ( \mathrm{mod\:} x^n )$
 。系数对 $10^9+7$ 取模。

## 说明/提示

$1 \leq n \leq 10^5$，$0 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
5
1 6 3 4 9```

### 输出

```
1 1000000001 33 999999823 1020```

# 题解

## 作者：yybyyb (赞：20)

这种题目，没有题解只靠自己改真的想死。。。

多项式怎么求逆请出门左转看多项式求逆的模板

这里的模数不是$998244353$了。

对于任意模数的$FFT$，也可以出门右转看$MTT$的模板题

这样我们就得到了$MTT$+多项式求逆的模板了

（真的写死人）

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define ll long long
#define ull unsigned long long
#define RG register
#define MAX 444444
#define MOD (1000000007)
const double Pi=acos(-1);
const int m=sqrt(MOD);
inline int read()
{
    RG int x=0,t=1;RG char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
int fpow(int a,int b){int s=1;while(b){if(b&1)s=1ll*s*a%MOD;a=1ll*a*a%MOD;b>>=1;}return s;}
struct Complex{double a,b;}W[MAX],A[MAX],B[MAX],C[MAX],D[MAX];
Complex operator+(Complex a,Complex b){return (Complex){a.a+b.a,a.b+b.b};}
Complex operator-(Complex a,Complex b){return (Complex){a.a-b.a,a.b-b.b};}
Complex operator*(Complex a,Complex b){return (Complex){a.a*b.a-a.b*b.b,a.a*b.b+a.b*b.a};}
int r[MAX];
void FFT(Complex *P,int N,int opt)
{
	for(int i=0;i<N;++i)if(i<r[i])swap(P[i],P[r[i]]);
	for(int i=1;i<N;i<<=1)
		for(int p=i<<1,j=0;j<N;j+=p)
			for(int k=0;k<i;++k)
			{
				Complex w=(Complex){W[N/i*k].a,W[N/i*k].b*opt};
				Complex X=P[j+k],Y=P[i+j+k]*w;
				P[j+k]=X+Y;P[i+j+k]=X-Y;
			}
	if(opt==-1)for(int i=0;i<N;++i)P[i].a/=1.0*N;
}
void Multi(int *a,int *b,int len,int *ret)
{
	for(int i=0;i<(len<<1);++i)A[i]=B[i]=C[i]=D[i]=(Complex){0,0};
	for(int i=0;i<len;++i)
	{
		a[i]%=MOD;b[i]%=MOD;
		A[i]=(Complex){(a[i]/m)*1.0,0};
		B[i]=(Complex){(a[i]%m)*1.0,0};
		C[i]=(Complex){(b[i]/m)*1.0,0};
		D[i]=(Complex){(b[i]%m)*1.0,0};
	}
	int N,l=0;
	for(N=1;N<=len;N<<=1)++l;
	for(int i=0;i<N;++i)r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	for(int i=1;i<N;i<<=1)
		for(int k=0;k<i;++k)W[N/i*k]=(Complex){cos(k*Pi/i),sin(k*Pi/i)};
	FFT(A,N,1);FFT(B,N,1);FFT(C,N,1);FFT(D,N,1);
	for(int i=0;i<N;++i)
	{
		Complex tmp=A[i]*C[i];
		C[i]=B[i]*C[i],B[i]=B[i]*D[i],D[i]=D[i]*A[i];
		A[i]=tmp;C[i]=C[i]+D[i];
	}
	FFT(A,N,-1);FFT(B,N,-1);FFT(C,N,-1);
	for(int i=0;i<len;++i)
	{
		ret[i]=0;
		ret[i]=(ret[i]+1ll*(ll)(A[i].a+0.5)%MOD*m%MOD*m%MOD)%MOD;
		ret[i]=(ret[i]+1ll*(ll)(C[i].a+0.5)%MOD*m%MOD)%MOD;
		ret[i]=(ret[i]+1ll*(ll)(B[i].a+0.5)%MOD)%MOD;
		ret[i]=(ret[i]+MOD)%MOD;
	}
}
int c[MAX],d[MAX];
void Inv(int *a,int *b,int len)
{
	if(len==1){b[0]=fpow(a[0],MOD-2);return;}
	Inv(a,b,len>>1);
	Multi(a,b,len,c);
	Multi(c,b,len,d);
	for(int i=0;i<len;++i)b[i]=(b[i]+b[i])%MOD;
	for(int i=0;i<len;++i)b[i]=(b[i]+MOD-d[i])%MOD;
}
int n,a[MAX],b[MAX];
int main()
{
	n=read();int N;
	for(int i=0;i<n;++i)a[i]=read();
	for(N=1;N<n;N<<=1);
	Inv(a,b,N);
	for(int i=0;i<n;++i)printf("%d ",b[i]);
	return 0;
}

```

---

## 作者：mrsrz (赞：8)

表示不会MTT。

于是果断三模NTT（详见任意模数NTT模板）。

结果发现负数在模意义下的同余方程组直接合并会出锅o(╥﹏╥)o

正确解法是：边求逆边CRT，每次乘完以后马上CRT转化成$\bmod 10^9+7$意义下，就不会出锅了。

时间复杂度$O(n\log n)$，然后每层递归要NTT18次，常数可想而知（吸氧能过）。

~~负数毒瘤啊o(╥﹏╥)o~~

## Code：
```cpp
#include<iostream>
#include<algorithm>
#define toll static_cast<Love##Live>
using namespace std;
typedef long long LoveLive;
const int md1=998244353,md2=1004535809,md3=469762049,N=524288,md=1e9+7;
inline LoveLive pow(LoveLive a,LoveLive b,const LoveLive&md){
	LoveLive ret=1;
	for(;b;b>>=1){
		if(b&1)ret=ret*a%md;
		a=a*a%md;
	}
	return ret;
}
const LoveLive M=toll(md1)*md2;
const int _=pow(md2%md1,md1-2,md1),__=pow(md1%md2,md2-2,md2),___=pow(M%md3,md3-2,md3);
int n,lim,a[N],b1[N],b2[N],b3[N],rev[N],B[N];
void init(int n){
	int l=-1;
	for(lim=1;lim<=n;lim<<=1)++l;
	for(int i=1;i<lim;++i)
	rev[i]=(rev[i>>1]>>1)|((i&1)<<l);
}
void NTT(int*a,int f,const int&md){
	const int gg=pow(3,md-2,md);
	for(int i=1;i<lim;++i)if(i<rev[i])swap(a[i],a[rev[i]]);
	for(int i=1;i<lim;i<<=1){
		const int gi=pow(f?3:gg,(md-1)/(i<<1),md);
		for(int j=0;j<lim;j+=i<<1){
			LoveLive g=1;
			for(int k=0;k<i;++k){
				int x=a[j+k],y=g*a[j+k+i]%md;
				a[j+k]=(x+y)%md;
				a[j+k+i]=(x-y+md)%md;
				g=g*gi%md;
			}
		}
	}
	if(!f){
		const LoveLive inv=pow(lim,md-2,md);
		for(int i=0;i<lim;++i)a[i]=inv*a[i]%md;
	}
}
inline void mul(const int*A,const int*B,int*C,const int&md,const int&sz){
	static int a[N],b[N];
	for(int i=0;i<sz;++i)a[i]=A[i];
	for(int i=0;i<sz;++i)b[i]=B[i];
	for(int i=sz;i<lim;++i)a[i]=b[i]=0;
	NTT(a,1,md),NTT(b,1,md);
	for(int i=0;i<lim;++i)C[i]=toll(b[i])*a[i]%md;
	NTT(C,0,md);
	for(int i=sz;i<lim;++i)C[i]=0;
}
inline LoveLive mul(LoveLive a,LoveLive b,const LoveLive&md){
	LoveLive ret=0;
	for(;b;b>>=1){
		if(b&1)ret=(ret+a)%md;
		a=(a<<1)%md;
	}
	return ret;
}
inline LoveLive crt(int a,int b,int c){
	LoveLive A=(mul(toll(md2)*a%M,_,M)+mul(toll(md1)*b%M,__,M))%M;
	LoveLive k=(c-A%md3+md3)%md3*___%md3;
	return (k%md*(M%md)%md+A%md)%md;
}
void INV(int n){
	if(n==1){
		*B=pow(*a,md-2,md);
		return;
	}
	INV(n+1>>1);
	init(n<<1);
	mul(a,B,b1,md1,n);
	mul(a,B,b2,md2,n);
	mul(a,B,b3,md3,n);
	for(int i=1;i<n;++i)
	b1[i]=b2[i]=b3[i]=(md-crt(b1[i],b2[i],b3[i]))%md;
	*b1=*b2=*b3=1;
	mul(b1,B,b1,md1,n);
	mul(b2,B,b2,md2,n);
	mul(b3,B,b3,md3,n);
	for(int i=0;i<n;++i)B[i]=crt(b1[i],b2[i],b3[i]);
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n;
	for(int i=0;i<n;++i)(cin>>a[i]),a[i]%=md;
	INV(n);
	for(int i=0;i<n;++i)cout<<B[i]<<" \n"[i==n-1];
	return 0;
}
```

---

## 作者：EternalEpic (赞：8)

模数是质数，可以用费马小定理求最初项的乘法逆元，可这不满足NTT的性质，不能直接用原根搞，要MTT或3模NTT，笔者这里采用的是利用复数共轭性质（三次变两次优化？）的5次FFT，比4次的稍微慢一点但好想。

不妨令：
$$a_1 = a / c$$
$$a_0 = a - a_1$$

同理：
$$b_1 = b / c$$
$$b_0 = b - b_1$$

这里取
$$c = 32767 (2^{15} - 1)$$

我们就可以拆系数保持精度FFT辣~~~

然后，朴素算法是需要调用7次FFT。这里我们可以构造复数：
$$f = a_0 + a_1i$$
$$h = a_0 - a_1i$$
$$g = b_0 + b_1i$$
所以
$$f * g = a_0b_0 + (a_1b_0 + a_0b_1)i - a_1b_1$$
$$h * g = a_0b_0 - (a_1b_0 - a_0b_1)i + a_1b_1$$
我们就可以通过两式加减来得到
$$a_0b_0 \ a_1b_1 \ a_1b_0 \ a_0b_1$$
我们实际上只需要先dft出  $f \ h \ g$ 再把两个答案数组idft即可。

参考[command_block大佬博客](https://www.luogu.com.cn/blog/command-block/solution-p4245)

然后就是倍增求乘法逆。

我们要求 $F(x)$ 的乘法逆 $G(x)$ 满足

$$F(x)G(x) \equiv 1 \pmod{x^n}$$

考虑采用倍增求解。当多项式只剩一项时直接费马小定理求解，然后倍增，（我是逆着递归的）。

假如我们已知:

$$F(x)H(x) \equiv 1 \pmod{x^{\lceil \frac{n}{2} \rceil}}$$

同时：

$$F(x)G(x) \equiv 1 \pmod{x^{\lceil \frac{n}{2} \rceil}}$$

所以：
$$G(x) - H(x)\equiv 0\pmod{x^{\lceil \frac{n}{2} \rceil}} $$

平方：
$$G(x)^2+H(x)^2-2G(x)H(x) \equiv 0 \pmod{x^n}$$

因为：
$$F(x)G(x) \equiv 1 \pmod{x^n}$$

两式相乘：
$$G(x) \equiv 2H(x)-F(x)H(x)^2 \pmod{x^n}$$

推导参考[CSDN](https://blog.csdn.net/litble/article/details/79828428)

我这里没有像别人一样补成2次幂做，直接往下递归进行，但要保证子区间严格大于 $length / 2$。

即：调用 $Inv(length + 1 >> 1, a, b)$

请注意常数，手写复数类。

我认为没必要预处理单位根，因为会浪费空间，有时还会负优化。

代码：

```cpp
enum {
	Maxn = 300005
};

namespace _MTT {
	const long double PI = acos(-1.0);
	const Complex I = Complex(1, 0);
	const int mod = 1e9 + 7;
	int lim = 1, rev[Maxn];
	Complex f[Maxn], g[Maxn], h[Maxn];
	
	inline void FFT(int limit, Complex *arr, int type) {
		for (int i = 0; i < limit; i++)
			if (i < rev[i]) swap(arr[i], arr[rev[i]]);
		for (int mid = 1; mid < limit; mid <<= 1) {
			Complex tmp(cos(PI / mid), type * sin(PI / mid));
			for (int i = 0; i < limit; i += mid << 1) { Complex w(1, 0);
				for (register int j = 0; j < mid; j++, w = w * tmp) {
					Complex x = arr[i + j], y = w * arr[i + j + mid];
					arr[i + j] = x + y, arr[i + j + mid] = x - y;
				}
			}
		}
	}

	inline void MTT(int *a, int *b, int n, int m, int *ret) {
		int c = sqrt(mod) + 1; int v = 1ll * c * c % mod; ll a0b0, a1b1, a0b1, a1b0;
		for (int i = 0; i < lim; i++) f[i] = g[i] = h[i] = Complex(0, 0);
		for (int i = 0; i < n; i++) f[i] = Complex(a[i] % c, a[i] / c), h[i] = f[i].Vary();
		for (int i = 0; i < m; i++) g[i] = Complex(b[i] % c, b[i] / c);
		FFT(lim, f, 1), FFT(lim, g, 1), FFT(lim, h, 1);
		for (int i = 0; i < lim; i++)
			g[i] = g[i] / lim, f[i] = f[i] * g[i], h[i] = h[i] * g[i];
		FFT(lim, f, -1), FFT(lim, h, -1);
		for (int i = 0; i < lim; i++) {
    		a0b0 = ll(round((f[i].x + h[i].x) / 2.0)) % mod;
    		a0b1 = ll(round((f[i].y + h[i].y) / 2.0)) % mod;
    		a1b0 = ll(round(f[i].y) - a0b1) % mod;
    		a1b1 = ll(round(h[i].x) - a0b0) % mod;
    		ret[i] = ll(a0b0 + 1ll * c * (a0b1 + a1b0) % mod) % mod;
    		ret[i] = ll(ret[i] + 1ll * v * a1b1 % mod) % mod;
    		ret[i] = ll(ret[i] + mod) % mod;
		}
	}
} using namespace _MTT;

int n;
int f0[Maxn], g0[Maxn], c[Maxn], d[Maxn];

inline int qpow(int a, int k = mod - 2) {
	int ret = 1;
	for (; k; k >>= 1, a = 1ll * a * a % mod)
		if (k & 1) ret = 1ll * ret * a % mod;
	return ret;
}

inline void Inv(int length, int *a, int *b) {
	if (length == 1) { b[0] = qpow(a[0]); return; }
	Inv(length + 1 >> 1, a, b);
	while (lim < 2 * length) lim <<= 1;
	for (int i = 0; i < lim; i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? (lim >> 1) : 0);
	MTT(a, b, length, length, c);
	MTT(c, b, length, length, d);
	for (int i = 0; i < length; i++) b[i] = (b[i] + b[i]) % mod;
	for (int i = 0; i < length; i++) b[i] = (b[i] - d[i] + mod) % mod;
}

signed main(void) {
//	file("");
	read(n);
	for (int i = 0; i < n; i++) read(f0[i]);
	Inv(n, f0, g0); for (int i = 0; i < n; i++) println(g0[i], ' ');
	fwrite(pf, 1, o1 - pf, stdout);
	return 0;
}
```


---

## 作者：xzyxzy (赞：6)

~~作为全站最短代码写个题解~~

首先多项式求逆，不会请见4938题解

然后这题模数不是NTT模数，MTT请见4245题解

所以两个多项式乘起来用MTT合并

但是我调试了两个小时，原因在于：**FFT由于不能取模，而double的位数有限，所以多项式算$AB^2$的时候，不能像NTT那样三个点值直接乘起来，会爆double，要乘完AB之后再乘B！**

另外我的MTT长得和大家的不一样，常数是他们的$\frac{8}{7}$，就是用时间长一点换代码短一点嘛


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<complex>
using namespace std;
const double Pi=acos(-1);
const int N=800100;
const int M=30000;
const int mod=1e9+7;
int n,F[N],G[N],l,r[N],tt,P1[N],P2[N];
complex<double> A1[N],A2[N],B1[N],B2[N],w[N],U[N];
int ksm(int x,int k)
{
	int s=1;for(;k;k>>=1,x=1ll*x*x%mod)
	if(k&1) s=1ll*s*x%mod; return s;			
}
void FFT(complex<double> *P,int op)
{
	for(int i=0;i<l;i++) if(i<r[i]) swap(P[i],P[r[i]]);
	for(int i=1;i<l;i<<=1)
		for(int j=0,p=i<<1;j<l;j+=p)
			for(int k=0;k<i;k++)
			{
				complex<double> W=w[l/i*k];W.imag()*=op;
				complex<double> X=P[j+k],Y=P[j+k+i]*W;
				P[j+k]=X+Y;P[j+k+i]=X-Y;
			}
}
void Work(complex<double> *A,complex<double> *B,int b)
{
	for(int i=0;i<l;i++) U[i]=A[i]*B[i]; FFT(U,-1);
	for(int i=0;i<l;i++) (P1[i]+=((long long)(U[i].real()/l+0.5)%mod*b%mod+mod)%mod)%=mod;
}
void MTT()
{
	for(int i=0;i<l;i++) A1[i].real()=P1[i]/M,B1[i].real()=P1[i]%M,A1[i].imag()=B1[i].imag()=0;
	for(int i=0;i<l;i++) A2[i].real()=P2[i]/M,B2[i].real()=P2[i]%M,A2[i].imag()=B2[i].imag()=0;
	for(int i=0;i<l;i++) P1[i]=0; FFT(A1,1);FFT(A2,1);FFT(B1,1);FFT(B2,1);
	Work(A1,A2,M*M);Work(A1,B2,M);Work(B1,A2,M);Work(B1,B2,1);
}
void GetInv(int *f,int *g,int n)
{
	if(n==1) {g[0]=ksm(f[0],mod-2);return;}
	GetInv(f,g,n>>1);
	for(tt=0,l=1;l<n*2;l<<=1) tt++;tt--;
	for(int i=0;i<l;i++) r[i]=(r[i>>1]>>1)|((i&1)<<tt),P1[i]=P2[i]=0;
	for(int i=0;i<l;i++) w[i].real()=cos(Pi/l*i),w[i].imag()=sin(Pi/l*i);
	for(int i=0;i<n;i++) P1[i]=f[i],P2[i]=g[i]; MTT(); MTT();
	for(int i=0;i<n;i++) g[i]=((2ll*g[i]%mod-P1[i])%mod+mod)%mod;
}
int main()
{
	scanf("%d",&n); for(int i=0;i<n;i++) scanf("%d",&F[i]);
	int m; for(m=1;m<n;m<<=1); GetInv(F,G,m);
	for(int i=0;i<n;i++) printf("%d ",G[i]);
}

```
~~[打个广告：博主将会出一个多项式/NTT的总结以及题单](https://www.cnblogs.com/xzyxzy/)~~

---

## 作者：ccviolett (赞：4)

虽然时间不一定是最快的，甚至比较慢（3s 左右）。

虽然长度不一定是最短的，甚至非常长。

但码风一定是很好的，给一个比较好的模板给予参考。

```cpp
/* Header {{{ */
#include <bits/stdc++.h>
using namespace std;

typedef long long readtype;
typedef long long var;
typedef long double let;

readtype read() {
  readtype a = 0, c = getchar(), s = 0;
  while (!isdigit(c)) s |= c == '-', c = getchar();
  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();
  return s ? -a : a;
}

#ifdef LOCAL_LOGGER
#define logger(...) fprintf(stderr, __VA_ARGS__)
#define abortif(v, ...) if (v) {logger("Error in Line %d, Function '%s()'.\nInfo: ", __LINE__, __FUNCTION__); logger(__VA_ARGS__); exit(0);}
#else
#define logger(...);
#define abortif(v, ...);
#endif
/* }}} */

const int N = 8e5 + 1;
const int MOD = 1e9 + 7;
const double Pi = acos(-1.0);

struct Node;

struct Node {
  // {{{
  double x, y;
  Node operator + (Node t) { return (Node) {x + t.x, y + t.y}; }
  Node operator - (Node t) { return (Node) {x - t.x, y - t.y}; }
  Node operator * (Node t) { 
    return (Node) {x * t.x - y * t.y, x * t.y + y * t.x}; 
  }
  Node operator * (double t) { return (Node) {x * t, y * t}; }
  Node operator ~ () { return (Node) {x, -y}; }

  void MTTinit(int t) { x = t >> 15, y = t & 32767; }
  // }}}
};

const Node Nullnode = (Node) {0, 0};

inline int add(int a, int b) { return (a + b >= MOD) ? (a + b - MOD) : (a + b); }
inline int mul(var a, int b) { return (a * b) % MOD; }
inline int qpow(int x, var y) {
  int res = 1;
  while (y) {
    if (y & 1) res = mul(res, x);
    x = mul(x, x);
    y >>= 1;
  }
  return res;
}
inline int inv(int t) { return qpow(t, MOD - 2); }

int limit, rev[N];
Node w[N];
Node tmp_a[N], tmp_b[N], tmp_c[N];

void InitLimit(const int need_len);
void Transform(Node *val, const int type);
void Mul(const int len_a, const int *a, const int len_b, const int *b,
    int &len_c, int *c);
void Inv(const int len, const int *a, int *b);

int tmp_va[N], tmp_vb[N];
Node tmp_d[N];

int n, f[N], g[N];

int main() {
#ifndef ONLINE_JUDGE
  freopen("P4239.in", "r", stdin);
  freopen("P4239.out", "w", stdout);
#endif
#ifdef LOCAL_LOGGER
  freopen("P4239.log", "w", stderr);
#endif
  n = read() - 1;
  for (int i = 0; i <= n; ++i) f[i] = read();
  Inv(n, f, g);
  for (int i = 0; i <= n; ++i) printf("%d ", g[i]);
  puts("");
  return 0;
}

/* ==== Makefile ==== {{{
CompileAndRun:
make Compile
make Run

Compile:
g++ -o P4239 P4239.cpp -g -Wall -DLOCAL_LOGGER

CompileUF:
g++ -o P4239 P4239.cpp -g -Wall -DLOCAL_LOGGER -fsanitize=undefined

Run:
./P4239 < P4239.in > P4239.out
==================
}}} */

void InitLimit(const int need_len) {
  if (limit > need_len) return ;
  for (limit = 1; limit <= need_len; limit <<= 1);
  for (int i = 0; i < limit; ++i)
    rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? (limit >> 1) : 0);
  for (int mid = 1; mid < limit; mid <<= 1) {
    w[mid] = (Node) {1, 0};
    for (int i = 1; i < mid; ++i) {
      if ((i & 31) == 1) 
        w[i + mid] = (Node) {cos(Pi * i / mid), sin(Pi * i / mid)};
      else
        w[i + mid] = w[i + mid - 1] * w[mid + 1];
    }
  }
}

void Transform(Node *val, const int type) {
  if (type == -1) reverse(val + 1, val + limit);
  for (int i = 0; i < limit; ++i) 
    if (i < rev[i]) swap(val[i], val[rev[i]]);
  for (int mid = 1; mid < limit; mid <<= 1) {
    int R = mid << 1;
    for (int i = 0; i < limit; i += R) {
      for (int j = 0; j < mid; ++j) {
        Node v = w[mid + j] * val[i + mid + j];
        val[i + mid + j] = val[i + j] - v;
        val[i + j] = val[i + j] + v;
      }
    }
  }
}

void Mul(const int len_a, const int *a, const int len_b, const int *b,
    int &len_c, int *c) {
  len_c = len_a + len_b;
  InitLimit(len_c);
  for (int i = 0; i <= len_a; ++i) tmp_a[i].MTTinit(a[i]);
  for (int i = 0; i <= len_b; ++i) tmp_b[i].MTTinit(b[i]);

  Transform(tmp_a, 1), Transform(tmp_b, 1);

  for (int i = 0; i < limit; ++i) {
    Node ft = ~tmp_a[i ? (limit - i) : 0], 
         f0 = (tmp_a[i] - ft) * (Node) {0, -0.5},
         f1 = (tmp_a[i] + ft) * 0.5;
    Node gt = ~tmp_b[i ? (limit - i) : 0],
    g0 = (tmp_b[i] - gt) * (Node) {0, -0.5},
    g1 = (tmp_b[i] + gt) * 0.5;
    tmp_c[i] = f1 * g1, tmp_d[i] = f0 * g1 + f1 * g0 + f0 * g0 * (Node) {0, 1};
  }
  for (int i = 0; i < limit; ++i)
    tmp_a[i] = Nullnode, tmp_b[i] = Nullnode;

  Transform(tmp_c, -1), Transform(tmp_d, -1);

  for (int i = 0; i <= len_c; ++i) {
    var v1 = (var) (tmp_c[i].x / limit + 0.5) % MOD,
        v2 = (var) (tmp_d[i].x / limit + 0.5) % MOD,
        v3 = (var) (tmp_d[i].y / limit + 0.5) % MOD;
    c[i] = ((v1 << 30) + (v2 << 15) + v3) % MOD;
    tmp_c[i] = Nullnode, tmp_d[i] = Nullnode;
  }
}

void Inv(const int len, const int *a, int *b) {
  if (!len) {
    b[0] = inv(a[0]);
    return ;
  }
  Inv(len >> 1, a, b);
  InitLimit(len << 1);
  int len_va = 0, len_vb;
  Mul(len, a, len, b, len_va, tmp_va);
  Mul(len_va, tmp_va, len, b, len_vb, tmp_vb);

  for (int i = 0; i <= len; ++i) {
    b[i] = add(add(b[i], b[i]), MOD - tmp_vb[i]);
    tmp_va[i] = 0, tmp_vb[i] = 0;
  }
}

```

---

## 作者：Parsnip (赞：3)

~~你谷竟然没有vector多项式党的题解。~~ 

那我就来提供一份参考代码好了。

首先是前置知识：[P4245](https://www.luogu.com.cn/problem/P4245)，[P4238](https://www.luogu.com.cn/problem/P4238)。

这里的话我写的是$\mathrm{MTT}$，简单来说，我们可以推出一个多项式的$\mathrm{DFT}$与 **其在复数域上每一项系数都共轭的多项式** 的$\mathrm{DFT}$构成翻转共轭的关系，即：

$$P(x)=\sum_{i=0}^{n-1}z_i x^i,Q(x)=\sum_{i=0}^{n-1}\overline{z_i}x^i$$

可以推出：

$$(\mathrm{DFT}\ P)_i=\overline{(\mathrm{DFT}\ Q)_{(n-i)\bmod n}}$$

至于推导过程，$2016$年国家集训队论文上有，许多博客上也有，我就不赘述了。

有了上面的结论我们就可以把两个多项式一个放在实部，一个放在虚部，一次$\mathrm{DFT}$求出两个多项式的单位根点值。

那么这个就可以用来优化拆位$\mathrm{FFT}$，实现值域可达$2^{30}\times 10^{16}$左右的多项式乘法，仅需$4$次$\mathrm{DFT}$，但是带有一定常数。

对于本题，我们只需拉一拉多项式求逆的板子即可。

关于精度问题，我们可以预处理单位根。容易得知单位根总共只有$O(n)$个，只要每$32$个重算一次就可以了，这样既保证时间常数不会太大，又可以保证精度，不需要用`long double`。

~~这大概是vector多项式党的春天的吧，只要你封装得够漂亮，强行二合一的题就套不死你~~

由于使用`vector`封装多项式，不开O2的话效率一般，只能跑进$20s$，开O2的话就很快，基本上可以保持在$2s$左右。

```cpp
#include <bits/stdc++.h>
using namespace std;
const long double Pi = acos(-1);
const int N = 1<<18 , Mod = 1e9 + 7;
typedef vector<int> Poly; typedef long long ll;
struct Complex
{
    double Re,Im; Complex (double R = 0,double I = 0) { Re = R , Im = I; }
    friend Complex operator + (Complex a,Complex b) { return Complex( a.Re + b.Re , a.Im + b.Im ); }
    friend Complex operator - (Complex a,Complex b) { return Complex( a.Re - b.Re , a.Im - b.Im ); }
    friend Complex operator * (Complex a,Complex b) { return Complex( a.Re*b.Re - a.Im*b.Im , a.Re*b.Im + a.Im*b.Re ); }
};
Poly rev; Complex omega[N<<1];
inline int inc(int a,int b) { return a + b >= Mod ? a + b - Mod : a + b; }
inline int dec(int a,int b) { return a - b < 0 ? a - b + Mod : a - b; }
inline int mul(int a,int b) { return 1LL * a * b % Mod; }
inline void Inc(int &a,int b) { return void( a = inc( a , b ) ); }
inline void Dec(int &a,int b) { return void( a = dec( a , b ) ); }
inline void Mul(int &a,int b) { return void( a = mul( a , b ) ); }
inline int fastpow(int a,int b) { int c = 1; for (; b; Mul(a,a) , b>>=1) if (1&b) Mul(c,a); return c; }
inline int Inv(int x) { return fastpow( x , Mod - 2 ); }
inline int Read(void)
{
    int x = 0 , w = 0; char ch = ' ';
    while ( !isdigit(ch) ) w |= ch == '-' , ch = getchar();
    while ( isdigit(ch) ) x = x * 10 + ch - 48 , ch = getchar();
    return w ? -x : x;
}
inline Complex Conj(Complex z) { return Complex( z.Re , -z.Im ); }
inline int Calc(int n) { int k = 1; while ( k < n ) k <<= 1; return k; }
inline void Flip(int n)
{
    int k = 0; while ( 1<<k < n ) ++k;
    rev.resize(n) , rev[0] = 0 , --k;
    for (int i = 1; i < n; i++)
        rev[i] = ( rev[i>>1] >> 1 ) | ( (i&1) << k );
}
inline void Init(void)
{
    for (int i = 1 , j; i < N; i <<= 1)
        for (j = 1 , omega[i] = Complex(1,0); j < i; j++)
            if ( (j&31) == 1 ) omega[i+j] = Complex( cos(Pi*j/i) , sin(Pi*j/i) );
            else omega[i+j] = omega[i+j-1] * omega[i+1];
}
inline void FFT(vector<Complex> &p,int n,int op)
{
    p.resize(n); static Complex x,y;
    for (int i = 0; i < n; i++) if ( rev[i] > i ) swap( p[rev[i]] , p[i] );
    for (int i = 1; i < n; i <<= 1) for (int j = 0; j < n; j += i<<1)
        for (int k = 0; x = p[j+k] , y = omega[i+k] * p[i+j+k] , k < i; k++)
            p[j+k] = x + y , p[i+j+k] = x - y;
    if ( op == 1 ) return void(); reverse( p.begin() + 1 , p.end() );
    for (int i = 0; i < n; i++) p[i].Re /= n , p[i].Im /= n;
}
inline Poly MTT(Poly a,Poly b)
{
    if ( !a.size() || !b.size() ) return {};
    int _n = a.size() + b.size() - 1 , n = Calc(_n); Flip(n);
    static vector<Complex> A,B,P,Q; static Complex a0,a1,b0,b1;
    A.resize(n) , B.resize(n) , P.resize(n) , Q.resize(n) , a.resize(n) , b.resize(n);
    for (int i = 0; i < n; i++)
        A[i] = Complex( a[i]>>15 , a[i] & ( (1<<15) - 1 ) ),
        B[i] = Complex( b[i]>>15 , b[i] & ( (1<<15) - 1 ) );
    FFT(A,n,1) , FFT(B,n,1) , P[0] = Conj(A[0]) , Q[0] = Conj(B[0]);
    for (int i = 1; i < n; i++) P[i] = Conj(A[n-i]) , Q[i] = Conj(B[n-i]);
    for (int i = 0; i < n; i++)
        a0 = ( A[i] + P[i] ) * Complex(0.5,0) , a1 = ( P[i] - A[i] ) * Complex(0,0.5),
        b0 = ( B[i] + Q[i] ) * Complex(0.5,0) , b1 = ( Q[i] - B[i] ) * Complex(0,0.5),
        A[i] = a0 * b0 + Complex(0,1) * a0 * b1 , B[i] = b0 * a1 + Complex(0,1) * a1 * b1;
    FFT(A,n,-1) , FFT(B,n,-1);
    static Poly c; static long long x,y,z; c.resize(_n);
    for (int i = 0; i < _n; i++)
        x = (ll)( A[i].Re + 0.5 ) % Mod , z = (ll)( B[i].Im + 0.5 ) % Mod ,
        y = (ll)( A[i].Im + B[i].Re + 0.5 ) % Mod , c[i] = ( (x<<30) + (y<<15) + z ) % Mod;
    return c;
}
inline Poly Inverse(Poly f,int n)
{
    int _n = Calc(n) , Len; static Poly g(1),h;
    f.resize(_n) , g[0] = Inv(f[0]);
    for (int i = 2; i <= _n; i <<= 1)
    {
        h.resize(i); for (int j = 0; j < i; j++) h[j] = f[j];
        h = MTT( g , MTT( g , h ) ) , g.resize(i);
        for (int j = 0; j < i; j++)
            g[j] = dec( mul( g[j] , 2 ) , h[j] );
    }
    return g.resize(n) , g;
}
int main(void)
{
    int n = Read(); Poly f(n),g; Init();
    for (int i = 0; i < n; i++) f[i] = Read();
    g = Inverse(f,n);
    for (int i = 0; i < n; i++)
        printf( "%d%c" , g[i] , " \n"[i==n-1] );
    return 0;
}

```


---

## 作者：rehtorbegnaro (赞：3)

小蒟蒻来投一份 karatsuba 的题解 qwq

karatsuba 的思想就是将 $F$ 分解成 $Ax^{p}+B$，将 $G$ 分解成 $Cx^{p}+D$，于是我们有

$$\begin{aligned}&FG\\=&(Ax^{p}+B)(Cx^{p}+D)\\=&ACx^{2p}+(AD+BC)x^{p}+BD\\=&ACx^{2p}+((A+B)(C+D)-AC-BD)x^{p}+BD\end{aligned}$$

这样我们一共需要进行 $3$ 次规模减半的多项式乘法。的时间复杂度是

$$T(n)=3T(\frac{n}{2})+O(n)$$

解得

$$T(n)=O(n^{\log_{2}3})\approx O(n\sqrt{n})$$

那么本题我们如果也用 karatsuba 算法的话，时间复杂度将会是

$$\begin{aligned}&T(n)\\=&O\left(\sum_{k=0}^{\lfloor\log_{2}n\rfloor}2^{k\log_{2}3}\right)\\=&O\left(\sum_{k=0}^{\lfloor\log_{2}n\rfloor}3^{k}\right)\\\approx&O\left(3^{\log_{2}n}\right)\\=&O\left(3^{\tfrac{\log_{3}n}{\log_{3}2}}\right)\\=&O\left(n^{\log_{2}3}\right)\end{aligned}$$

然而常数巨大并跑不过去 :(

希望哪位常数带师能够教教我怎么卡常，在此先谢过了。

代码：

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<cstdio>
#include<ctime>
#define re register
#define maxn 200000
#define maxdep 20
#define alpha 64
#define min(a,b) ((a)<=(b)?(a):(b))
#define max(a,b) ((a)>=(b)?(a):(b))

namespace cltstream{
	#define size 1048576
	char cltin[size+1],*ih=cltin,*it=cltin;
	inline char gc(){
		#ifdef ONLINE_JUDGE
			if(ih==it){
				it=(ih=cltin)+fread(cltin,1,size,stdin);
				if(ih==it)
					return EOF;
			}
			return *ih++;
		#else
			return getchar();
		#endif
	}

	char cltout[size+1],*oh=cltout,*ot=cltout+size;
	inline void pc(char c){
		if(oh==ot){
			fwrite(cltout,1,size,stdout);
			oh=cltout;
		}
		*oh++=c;
	}
	#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout
	#undef size

	template <typename _tp>
	inline void read(_tp& x){
		int sn=1;
		char c=gc();
		for(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());
		if(c==45&&c!=EOF)
			sn=-1,c=gc();
		for(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());
		x*=sn;
	}

	template <typename _tp>
	inline void write(_tp x,char text=-1){
		if(x<0)
			pc(45),x=-x;
		if(!x)
			pc(48);
		else{
			int digit[22];
			for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);
			for(;digit[0];pc(digit[digit[0]--]^48));
		}
		if(text>=0)
			pc(text);
	}
}

int A[maxdep+1][maxn+1],B[maxdep+1][maxn+1],C[maxdep+1][maxn+1],D[maxdep+1][maxn+1];
int tmp1[maxdep+1][maxn+1],tmp2[maxdep+1][maxn+1],tmp3[maxdep+1][maxn+1];
__int128 tmp[maxn+1];
int n,mod=1000000007;
int F[maxn+1],G[maxn+1];

inline int cltpow(re int x,re int n){
	re int res=1;
	for(;n;n>>=1,x=1LL*x*x%mod)
		if(n&1)
			res=1LL*res*x%mod;
	return res;
}

inline int Mod(re int x){
	return x>=mod?x-mod:x;
}

inline int Add(re int x,re int y){
	return x+y<mod?x+y:x+y-mod;
}

inline int Sub(re int x,re int y){
	return x-y>=0?x-y:x-y+mod;
}

inline void print(re int* F,re int N){
	putchar('{');
	for(re int i=0;i<=N;++i)
		printf("%d%c",F[i],i<N?',':'}');
}

void polyMul(re int* F,re int* G,re int* H,re int N,re int dep){
	if(N<=alpha){
		for(re int i=0;i<=2*N;++i)
			tmp[i]=0;
		for(re int i=0;i<=N;++i)
			for(re int j=0;j<=N;++j)
				tmp[i+j]+=1LL*F[i]*G[j];
		for(re int i=0;i<=2*N;++i)
			H[i]=tmp[i]%mod;
	}
	else{
		for(re int i=0;i<=2*N;++i){
			H[i]=A[dep][i]=B[dep][i]=C[dep][i]=D[dep][i]=0;
			tmp1[dep][i]=tmp2[dep][i]=tmp3[dep][i]=0;
		}
		re int M=N>>1;
		for(re int i=0;i<=N-M;++i){
			A[dep][i]=F[i+M];
			C[dep][i]=G[i+M];
		}
		polyMul(A[dep],C[dep],tmp1[dep],N-M,dep+1);
		for(re int i=0;i<=M-1;++i){
			B[dep][i]=F[i];
			D[dep][i]=G[i];
		}
		polyMul(B[dep],D[dep],tmp2[dep],M-1,dep+1);
		for(re int i=0;i<=M-1;++i){
			A[dep][i]=Add(A[dep][i],B[dep][i]);
			C[dep][i]=Add(C[dep][i],D[dep][i]);
		}
		polyMul(A[dep],C[dep],tmp3[dep],N-M,dep+1);
		for(re int i=0;i<=2*(N-M);++i)
			tmp3[dep][i]=Sub(tmp3[dep][i],tmp1[dep][i]);
		for(re int i=0;i<=2*(M-1);++i)
			tmp3[dep][i]=Sub(tmp3[dep][i],tmp2[dep][i]);
		for(re int i=0;i<=2*(N-M);++i)
			H[i+2*M]=Add(H[i+2*M],tmp1[dep][i]);
		for(re int i=0;i<=2*(M-1);++i)
			H[i]=Add(H[i],tmp2[dep][i]);
		for(re int i=0;i<=2*(N-M);++i)
			H[i+M]=Add(H[i+M],tmp3[dep][i]);
	}
}

void polyInv(re int* F,re int* G,re int N){
	for(re int i=0;i<=N;++i)
		G[i]=tmp1[0][i]=0;
	G[0]=cltpow(F[0],mod-2);
	for(re int k=1;k<=N;k<<=1){
		for(re int i=0;i<=2*k;++i)
			tmp1[0][i]=F[i];
		polyMul(tmp1[0],G,tmp2[0],2*k,1);
		polyMul(tmp2[0],G,tmp1[0],2*k,1);
		for(re int i=0;i<=2*k;++i)
			G[i]=Sub(Mod(2*G[i]),tmp1[0][i]);
	}
}

int main(){
	cltstream::read(n);
	for(re int i=0;i<n;++i)
		cltstream::read(F[i]);
	polyInv(F,G,n-1);
	for(re int i=0;i<n;++i)
		cltstream::write(G[i],32);
	clop();
	return 0;
}
```


---

## 作者：starcy (赞：3)

(mrsrz skip2004 orz)

三模最好用辣

由于我不会拆系数所以我来写三模了

(不会三模请出门右转[任意模数NTT](https://www.luogu.org/problemnew/show/P4245))

首先你会发现这道题直接用三模会gg

因为如果你在某一个时刻得到了一个负数(或者超出了三个模数的积)那么crt合并会挂掉

举个栗子假如某一个时刻得到了$-1$

那么对于你的三个模数都会变成$(mod-1)$的状态

然而这个时候的答案应该是$1000000006$, 模三个模数显然不可能变成$(mod-1)$

并且（据说）求逆的时候那个三次项可以爆模数乘积

所以就有一个巧妙的操作

我们当前求逆中需要计算的式子是$-AB'^2$

那么先把$AB'$用三模算出来然后$crt$合并出模$1e9+7$下的值，取负，然后转换成模三个模数下的值再和$B'$卷一次，然后再合并成模$1e9+7$的值等待下一次计算

换句话说只要你在操作的时候每次都只使用“把两个模$1e9+7$的多项式卷成新的模$1e9+7$的多项式“这一个操作那么是不会出锅的

然后就可以辣！

（虽说还是跑不过fft……窝常数太大了）

~~（另外求逆边界的时候对真模数求逆不要尝试什么三模求逆合并）~~

```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>

// io

struct istream {
	const static int ri_top = 1e7;
	char ri[ri_top], *rich = ri, *rr = ri;
	void rd() { *(rr = ri + fread(rich = ri, 1, ri_top, stdin)) = 0; }
	istream() { rd(); }
	char nch() { if (++rich >= rr) rd(); return *rich; }
	istream& operator>>(int& x) {
		while (!isdigit(*rich)) nch();
		for (x = *rich - '0'; isdigit(nch()); x = x * 10 + *rich - '0');
		return *this;
	}
} cin;
struct ostream {
	const static int wi_top = 1e7;
	char wi[wi_top], *wich = wi, *wr = wi + wi_top;
	void wrt() { fwrite(wi, 1, wich - wi, stdout); wich = wi; }
	~ostream() { wrt(); }
	ostream& nch(const char& ch) { if (wich >= wr) wrt(); *wich++ = ch; return *this; }
	ostream& operator<<(int x) {
		static char buffer[233], *p; p = buffer;
		if (!x) return nch('0');
		while (x) { *p++ = x % 10 ^ '0'; x /= 10; }
		while (p-- != buffer) nch(*p);
		return *this;
	}
	ostream& operator<<(const char& ch) { return nch(ch); }
} cout;

// io

constexpr int Mod=1000000007;
using ll=long long;
struct Z {
	static constexpr int Mod1=645922817,Mod2=897581057,Mod3=998244353;
	int a,b,c;
	Z(const int& x=0) : a(x%Mod1),b(x%Mod2),c(x%Mod3) {}
	Z(const int& a,const int& b,const int& c) : a(a),b(b),c(c) {}
	Z& up() { a+=a>>31&Mod1; b+=b>>31&Mod2; c+=c>>31&Mod3; return *this; }
	Z& operator+=(const Z& rhs) { a+=rhs.a-Mod1; b+=rhs.b-Mod2; c+=rhs.c-Mod3; return up(); }
	Z operator-(const Z& rhs) const { return Z(a-rhs.a,b-rhs.b,c-rhs.c).up(); }
	Z operator*(const Z& rhs) const {
		return Z(static_cast<ll>(a)*rhs.a%Mod1,static_cast<ll>(b)*rhs.b%Mod2,static_cast<ll>(c)*rhs.c%Mod3);
		return *this;
	}
	int val(const int& Mod) {
		ll _a=(b-a+Mod2)%Mod2*867661692ll%Mod2*Mod1+a;
		return ((c-_a%Mod3+Mod3)%Mod3*13864533%Mod3*Mod1%Mod*Mod2+_a)%Mod;
	}
};
inline int qpow(int a,int p,int Mod,int s=1) {
	for (;p;p>>=1,a=static_cast<ll>(a)*a%Mod) if (p&1) s=static_cast<ll>(s)*a%Mod;
	return s;
}
int exgcd(int a,int b,int& x,int& y) {
	if (!b) return x=1,y=0,a;
	int d=exgcd(b,a%b,y,x); y-=a/b*x; return d;
}
inline int _inv(const int& a) { int x,_; exgcd(a,Mod,x,_); return x+=x>>31&Mod; }
inline Z inv(const Z& rhs) {
	int x1,x2,x3,_; exgcd(rhs.a,Z::Mod1,x1,_); exgcd(rhs.b,Z::Mod2,x2,_); exgcd(rhs.c,Z::Mod3,x3,_);
	return Z(x1,x2,x3).up();
}
constexpr int mxlen=1<<18;
int r[mxlen],d; Z w[mxlen];
void fftinit(int len) {
	int _d=(d=__builtin_ctz(len))-1;
	for (int i=1;i<len;++i) r[i]=r[i>>1]>>1|(i&1)<<_d;
	Z wn(qpow(3,Z::Mod1>>d,Z::Mod1),qpow(3,Z::Mod2>>d,Z::Mod2),qpow(3,Z::Mod3>>d,Z::Mod3)); w[len>>1]=1;
	for (int i=(len>>1)+1;i<len;++i) w[i]=w[i-1]*wn;
	for (int i=len>>1;--i;) w[i]=w[i<<1];
}
void dft(Z a[],int len) {
	int shift=d-__builtin_ctz(len);
	for (int i=0;i<len;++i) if (i<r[i]>>shift) std::swap(a[i],a[r[i]>>shift]);
	for (int l=1;l<len;l<<=1) for (int i=0;i<len;i+=l<<1) for (int j=0;j<l;++j) {
		Z tmp(a[i+j+l]*w[j+l]); a[i+j+l]=a[i+j]-tmp; a[i+j]+=tmp;
	}
}
void idft(Z a[],int len) {
	std::reverse(a+1,a+len); dft(a,len);
	Z invn(inv(len)); for (int i=0;i<len;++i) a[i]=a[i]*invn;
}
void pinv(Z a[],Z b[],int n) {
	if (n==1) return void(*b=_inv(a->val(Mod)));
	pinv(a,b,(n+1)>>1);
	int len=1; while (len<=n*3/2) len<<=1;
	static Z c[mxlen],d[mxlen];
	__builtin_memcpy(c,a,sizeof(Z)*n); __builtin_memcpy(d,b,sizeof(Z)*n);
	for (int i=n;i<len;++i) c[i]=d[i]=0;
	dft(c,len); dft(d,len);
	for (int i=0;i<len;++i) c[i]=c[i]*d[i];
	idft(c,len);
	for (int i=0;i<len;++i) c[i]=Mod-c[i].val(Mod);
	dft(c,len);
	for (int i=0;i<len;++i) c[i]=c[i]*d[i];
	idft(c,len);
	for (int i=(n+1)>>1;i<n;++i) b[i]=c[i].val(Mod);
}
Z A[mxlen],B[mxlen];
int main() {
	int n; cin>>n;
	for (int i=0;i<n;++i) { int x; cin>>x; A[i]=x; }
	int len=1; while (len<=n*3/2) len<<=1;
	fftinit(len); pinv(A,B,n);
	for (int i=0;i<n;++i) cout<<B[i].val(Mod)<<"\n "[i!=n-1];
	return 0;
}
```

---

## 作者：legendgod (赞：2)

[P4239 任意模数多项式乘法逆](https://www.luogu.com.cn/problem/P4239)

我的做法使用 MTT 然后再套用之前的式子。

题目让我们求这个 $G$，也就是 $F$ 的逆元。
$$F(x)\times G(x) \equiv 1 \pmod {x^n} $$

> 为了书写方便，笔者的 $\frac{n}{2}$ 等价于 $\lceil\frac{n}{2}\rceil$。

我们考虑通过分治进行解决问题，假设我们已经知道了 $x^{\frac{n}{2}}$ 的答案。我们先记一个数组 $G_1$，表示 $F(x)\times G_1(x) \equiv 1 \pmod {x^\frac{n}{2}} $。


$$
\begin{aligned}
F(x)\times G(x) &\equiv 1 \pmod {x^n} \\
F(x) \times G_1(x) &\equiv 1 \pmod {x^{\frac{n}{2}}} \\
F(x) \times (G(x) - G_1(x)) &\equiv 0 \pmod {x^{\frac{n}{2}}} \\
\tt\text{我们考虑到对于 F(x) 其}&\mod x^n \text{  是不为 0 的} \\
G(x) - G_1(x) &\equiv 0 \pmod {x^{\frac{n}{2}}} \\
\text{为了将其变成 } x^n& \text{我们需要做一些变换} \\
(G(x) - G_1(x)) ^ 2 &\equiv 0 \pmod {x^n} \\
G^2(x) - G_1^2(x) - 2\times G(x)G_1(x) &\equiv 0 \pmod {x^n} \\
F(x)G^2(x) - F(x)G_1^2(x) - 2\times G(x)G_1(x)\times F(x) &\equiv 0 \pmod {x^n} \\
G(x) - 2\times G_1(x) - F(x)G_1^2(x) &\equiv 0 \pmod {x ^ n} \\

G(x) &\equiv 2 \times G_1(x) + F(x) \times G_1^2(x) \pmod {x^n} \\

G(x) & \equiv G_1(x) \times (2 - F(x)G_1(x))

\end{aligned}
$$

那么这样我们已经将问题转化成了递归问题。

对于处理两个多项式相乘 MTT 是很在行的，所以我们考虑将其分成几次进行计算。

首先我们要先计算 $F \times G_1$ 之后再将其变成 $2 - F \times G_1$ 然后保存到另外一个数组中，记为 $D$ 数组。之后再将其与 $G_1$ 再做一次 MTT 就可以得到答案。

---

细节：

- 我们进行完 $F \times G_1$ 之后，我们需要先将其取相反数，再在 $x^0$ 的系数上加上 2 即可。笔者写代码时直接将所有的系数都加上了 2 导致很长时间没调出来。

- 我们设项数为 n 我们每次进行递归的时候 n 会除以 2。但是我们进行 MTT 的时候需要取的项数为 n。

> 我们先考虑 FFT 的本质，也就是卷积，那么我们最后的答案需要取 n 个项，进行卷积的时候可能会出现 $x^{n - 2} \times x$ 这种情况，那么我们就可以理解取 n 个项的原因了吧。

---

$Code$

```cpp
#include <bits/stdc++.h>
using namespace std;
template <typename T>
void r1(T &x) {
	x = 0;
	char c(getchar());
	int f(1);
	for(; !isdigit(c); c = getchar()) if(c == '-') f = -1;
	for(; isdigit(c);c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
	x *= f;
}
#define int long long
const int maxn = 6e5 + 5;
const int maxm = maxn << 1;

typedef int room[maxn];
const int mod = 1e9 + 7/* 998244353*/;
int n, m;
struct Complex {
    double x, y;
    Complex (double tx = 0, double ty = 0) {x = tx, y = ty;}
    Complex operator + (const Complex &z) {return Complex (x + z.x, y + z.y);}
    Complex operator - (const Complex &z) {return Complex (x - z.x, y - z.y);}
    Complex operator * (const Complex &z) {return Complex (x * z.x - y * z.y, x * z.y + y * z.x);}
    Complex operator ~ () const {return Complex(x, - y);}
}w[maxn];
int rev[maxn], lim, len;
void fft(Complex *A) { // OK
    for(int i = 0; i < lim; ++ i) if(i < rev[i]) swap(A[i], A[rev[i]]);
    for(int mid = 1; mid < lim; mid <<= 1) {
        for(int j = 0; j < lim; j += (mid << 1)) {
            for(int k = 0; k < mid; ++ k)  {
                Complex x = A[j + k], y = A[j + k + mid] * w[k + mid];
                A[j + k] = x + y;
                A[j + k + mid] = x - y;
            }
        }
    }
}
Complex F[maxn], G[maxn];
const double pi = acos(-1.0);
Complex A[maxn], B[maxn];
void mtt(int *f, int *g, int *ans,int x) {
    lim = 1, len = 0;
    while(lim <= (x << 1)) lim <<= 1, ++ len;
    for(int i = 0; i < lim; ++ i) rev[i] = rev[i >> 1] >> 1 |((i & 1) << (len - 1));
    for(int i = 0; i < lim; ++ i) F[i] = G[i] = Complex(0, 0);


    for(int i = 1; i < lim; i <<= 1) {
        w[i] = Complex(1, 0);
        for(int j = 1; j < i; ++ j)
            if((j & 31) == 1) w[i + j] = Complex(cos(pi * j / i), sin(pi * j / i));
            else w[i + j] = w[i + j - 1] * w[i + 1];
    }
//    for(int i = 1; i < lim; i <<= 1) {
//        w[i] = Complex(1, 0);
//        for(int j = 1; j < i; ++ j)
//            if((j & 31) == 1) w[i + j] = Complex(cos(pi * j / i), sin(pi * j / i));
//            else w[i + j] = w[i + j - 1] * w[i + 1];
//    }

    for(int i = 0; i < x; ++ i) F[i].x = (f[i] >> 15), F[i].y = (f[i] & 32767);
    for(int i = 0; i < x; ++ i) G[i].x = (g[i] >> 15), G[i].y = (g[i] & 32767);

    fft(F), fft(G);
    for(int i = 0; i < lim; ++ i) {
        Complex q, f0, g0, f1, g1;
        q = ~F[i ?lim - i : 0], f0 = (F[i] - q) * Complex(0, -0.5), f1 = (F[i] + q) * Complex(0.5, 0);
        q = ~G[i ?lim - i : 0], g0 = (G[i] - q) * Complex(0, -0.5), g1 = (G[i] + q) * Complex(0.5, 0);
        A[i] = f1 * g1, B[i] = g0 * f1 + f0 * g1 + (f0 * g0) * Complex(0, 1);
    } // 这里和之前的表示一样
    reverse(A + 1, A + lim), reverse(B + 1, B + lim);
    fft(A), fft(B);
//    for(int i = 0; i < lim; ++ i) {
//        Complex q, f0, f1, g0, g1;
//        q = ~F[i ? lim - i : 0], f0 = (F[i] - q) * Complex(0. -0.5), f1 = (F[i] + q) * Complex(0.5, 0);
//        q = ~G[i ? lim - i : 0], g0 = (G[i] - q) * Complex(0. -0.5), f1 = (G[i] + q) * Complex(0.5, 0);
//        A[i] = f1 * g1, B[i] = g0 * f1 + f0 * g1 + (f0 * g0) * Complex(0, 1);
//    }
//    reverse(A + 1, A + lim), reverse(B + 1, B + lim);
//    fft(A), fft(B);
    double Z = 1.0 / lim;
    for(int i = 0; i < lim; ++ i) {
        ans[i] = 0;
        ans[i] = ((((int)(A[i].x * Z + 0.5) % mod << 30) + ((int)(B[i].x * Z + 0.5) % mod << 15) + ((int)(B[i].y * Z + 0.5) % mod)) % mod) % mod;
//        ans[i] = (((int)(A[i].x * Z + 0.5) % mod << 30) % mod + ((int)(B[i].x * Z + 0.5) % mod << 15) % mod + ((int)(B[i].y * Z + 0.5) % mod) ) % mod;
        ans[i] %= mod;
    }
}

int ans[maxn], a[maxn];
int ksm(int mi,int x) {
    int res(1);
    while(mi) {
        if(mi & 1) res = res * x % mod;
        x = x * x % mod;
        mi >>= 1;
    }
    return res;
}
int d[maxn], z[maxn];
void Inv(int *F,int *G,int x) { // 最高项是 的次数是 x - 1
//    printf("x = %d\n", x);
    if(x == 1) return G[0] = ksm(mod - 2, F[0]), void(); // ok

    Inv(F, G, x >> 1); // last G 是已经知道的
//    for(int i = 0; i < x; ++ i) printf("%lld ", F[i]);
//    for(int i = 0; i < x; ++ i) printf("%lld ", G[i]);
    mtt(F, G, d, x);
//    for(int i = 0; i <= x; ++ i) z[i] = 0;
//    for(int i = 0; i < (x >> 1); ++ i) z[i] = (2 - d[i] + mod) % mod;
    for(int i = 0; i < x; ++ i) z[i] = (mod - d[i]) % mod;
    z[0] = (z[0] + 2) % mod;
    mtt(G, z, d, x);
    for(int i = 0; i < x; ++ i) G[i] = d[i];
    for(int i = x; i < lim; ++ i) G[i] = 0;
}

signed main() {
	int i, j;
    r1(n);
    for(i = 0; i < n; ++ i) r1(a[i]);
    int z(1);
    while(z <= n) z <<= 1;
    Inv(a, ans, z);
    for(i = 0; i < n; ++ i) printf("%lld ", (ans[i] + mod) % mod);
	return 0;
}

```




---

## 作者：cyffff (赞：2)

[_传送门_](https://www.luogu.com.cn/problem/P4239)

板子题。
## 题意
给定 $n-1$ 次多项式 $F(x)$，求 $G(x)$ 满足 $F(x)G(x)\equiv1(\bmod x^n)$。
## 思路
既然是任意模数，将 FFT 中求多项式乘法逆的多项式乘法改为 MTT 即可，时间复杂度 $O(n\log^2n)$。

三模 NTT 似乎也可以做，而且时间复杂度为更优秀的 $O(n\log n)$，但是每一次递归要 NTT 18 次，还跑不过每次递归 FFT 8 次的 $O(n\log^2 n)$。

最后注意一个细节：做 MTT 时一定要将之前使用过的 complex 清空，不然会死得很惨。

Code:
```cpp
#define ll long long
#define ld double
const int N=4e5+10,mod=1e9+7;
const ld pi=acos(-1);
inline int qpow(int x,int y,int mod){
	int res=1;
	while(y){
		if(y&1) res=1ll*res*x%mod;
		x=1ll*x*x%mod;
		y>>=1;
	}
	return res;
}
#define complex comp
struct complex{
	ld x,y;
	complex(ld a=0,ld b=0){x=a,y=b;}
	complex neg(){
		return complex(x,-y);
	}
	friend complex operator+(const complex &a,const complex &b){
		return complex(a.x+b.x,a.y+b.y);
	}
	friend complex operator-(const complex &a,const complex &b){
		return complex(a.x-b.x,a.y-b.y);
	}
	friend complex operator*(const complex &a,const complex &b){
		return complex(a.x*b.x-a.y*b.y,a.y*b.x+a.x*b.y);
	}
};
inline void print(complex *a){
	for(int i=0;a[i].x||a[i].y||a[i+1].x||a[i+1].y;i++){
		printf("%.2Lf %.2Lf\n",a[i].x,a[i].y);
	}
}
inline void print(int *a){
	for(int i=0;a[i]||a[i+1];i++){
		printf("%d ",a[i]);
	}
	puts("");
}
struct Poly{
	int rev[N],lim;
	complex a[N],b[N],c[N],d[N],qp[N];
	int f[N],g[N],q[N],h[N],p[N];
	inline int qpow(int x,int y){
		int res=1;
		while(y){
			if(y&1) res=1ll*res*x%mod;
			x=1ll*x*x%mod;
			y>>=1;
		}
		return res;
	}
	inline void mkrv(int lm){
		int l=0;
		lim=1;
		while(lim<lm){
			lim<<=1;
			l++;
		}
		for(int i=1;i<lim;i++){
			rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
		}
		for(int i=1;i<lim;i<<=1){
			for(int j=0;j<i;j++){
				qp[lim/i*j]=comp(cos(j*pi/i),sin(j*pi/i));
			}
		}
	}
	inline void FFT(comp *a,int tpe){
		for(int i=0;i<lim;i++){
			if(i<rev[i]){
				swap(a[i],a[rev[i]]);
			}
		}
		for(int i=1;i<lim;i<<=1){
			for(int j=0;j<lim;j+=(i<<1)){
				for(int k=0;k<i;k++){
					comp t=a[i+j+k]*(tpe==1?qp[lim/i*k]:qp[lim/i*k].neg());
					a[i+j+k]=a[j+k]-t;
					a[j+k]=a[j+k]+t;
				}
			}
		}
	}
	inline void MTT(int *f,int *g,int *ans,int n){
		for(int i=0;i<lim;i++){
			a[i].x=f[i]>>15,a[i].y=f[i]&32767;
			c[i].x=g[i]>>15,c[i].y=g[i]&32767;
		}
		for(int i=n;i<lim;i++){
			a[i]=c[i]=complex();
		}
		FFT(a,1);
		FFT(c,1);
		for(int i=1;i<lim;i++){
			b[i]=a[lim-i].neg();
		}
		b[0]=a[0].neg();
		for(int i=1;i<lim;i++){
			d[i]=c[lim-i].neg();
		}
		d[0]=c[0].neg();
		for(int i=0;i<lim;i++){
			complex aa=(a[i]+b[i])*complex(0.5,0);
			complex bb=(a[i]-b[i])*complex(0,-0.5);
			complex cc=(c[i]+d[i])*complex(0.5,0);
			complex dd=(c[i]-d[i])*complex(0,-0.5);
			a[i]=aa*cc+complex(0,1)*(aa*dd+bb*cc);
			b[i]=bb*dd;
		}
		FFT(a,-1);
		FFT(b,-1);
		for(int i=0;i<lim;i++){
			int aa=(ll)(a[i].x/lim+0.5)%mod;
			int bb=(ll)(a[i].y/lim+0.5)%mod;
			int cc=(ll)(b[i].x/lim+0.5)%mod;
			ans[i]=((1ll*aa*(1<<30)+1ll*bb*(1<<15)+cc)%mod+mod)%mod;
		}
	}
	inline void Mul(int *f,int *g,int *ans,int n){
		mkrv(n<<1);
		for(int i=0;i<lim;i++){
			ans[i]=0;
		}
		MTT(f,g,ans,n);
		for(int i=n;i<lim;i++){
			ans[i]=0;
		}
	}
	inline void Inv(int *f,int *g,int n){
		if(n==1){
			g[0]=qpow(f[0],mod-2);
			return ;
		}
		Inv(f,g,n+1>>1);
		Mul(f,g,h,n);
		Mul(h,g,p,n);
		for(int i=0;i<n;i++){
			g[i]=2ll*g[i]%mod;
		}
		for(int i=0;i<n;i++){
			g[i]=(g[i]+mod-p[i])%mod;
		}
	}
	int n,m;
	inline void work(){
		n=read();
		for(int i=0;i<n;i++){
			f[i]=read();
		}
		Inv(f,g,n);
		for(int i=0;i<n;i++){
			write(g[i]);
			out[len++]=' ';
		}
	}
}w;
```
再见 qwq~

---


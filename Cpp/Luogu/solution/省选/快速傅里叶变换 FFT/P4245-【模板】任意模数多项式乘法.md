# 【模板】任意模数多项式乘法

## 题目背景

模板题，无背景

## 题目描述

给定 $2$ 个多项式 $F(x), G(x)$ ，请求出 $F(x) * G(x)$。    

**系数对 $p$ 取模**，且**不保证** $p$ 可以分解成 $p = a \cdot 2^k + 1$ 之形式。

## 说明/提示

对于 $100 \%$ 的数据，$1 \leq n, m \leq 10^5$，$0 \leq a_i, b_i \leq 10^9$，$2 \leq p \leq 10^9 + 9$。

## 样例 #1

### 输入

```
5 8 28
19 32 0 182 99 95
77 54 15 3 98 66 21 20 38```

### 输出

```
7 18 25 19 5 13 12 2 9 22 5 27 6 26```

# 题解

## 作者：Kewth (赞：47)

惊奇地发现你谷竟然没有 4 次 FFT 的 MTT 的题解。

拆系数就不说了，把两个多项式 $A(x), B(x)$ 分别拆成 $A_0(x), A_1(x)$ 和$B_0(x), B_1(x)$ 后，考虑求出它们的点值表示，也就是做 DFT 。  
朴素地做 DFT 需要 4 次，但是由于这些多项式虚部都为 0 ，可以考虑将两次 DFT 合并成一次。

例如要给两个多项式 $A, B$ 做 DFT ，考虑构造两个多项式：

$$P(x) = A(x) + i B(x)$$
$$Q(x) = A(x) - i B(x)$$

那么由于 $A, B$ 的虚部都为 0 ，$P, Q$ 的每一项系数都互为共轭，同样每一个点值也互为共轭。  
那么只需对 $P$ 做一次 DFT ，就可以通过共轭 $O(n)$ 求出 $Q$ 的点值表示。  
然后通过 $P, Q$ 的点值表示求 $A, B$ 的点值表示就是解上面的二元二次方程组，也是可以 $O(n)$ 做到的。

于是就可以用两次 DFT 求出 $A_0, A_1, B_0, B_1$ 的点值表示。

接下来需要求 $A, B$ 之间的两两乘积。直接乘出来后要对 $A_0 B_0, A_0 B_1, A_1 B_0, A_1 B_1$ 四个多项式做 IDFT 。  
并且这时候它们的虚部并不为 0 ，不能用上述的方法。

但是上述方法的思想仍可借鉴，考虑构造两个多项式：

$$P(x) = A_0(x) B_0(x) + i A_1(x) B_0(x)$$
$$Q(X) = A_0(x) B_1(x) + i A_1(x) B_1(x)$$

通过已知的点值求出此时 $P, Q$ 的点值，然后分别对 $P, Q$ 做 IDFT ，  
由于 $A_0 B_0, A_0 B_1, A_1 B_0, A_1 B_1$ 这四个多项式卷起来后的系数表示中虚部一定为 0 ，  
那么此时 $P$ 的实部和虚部就分别为 $A_0(x) B_0(x)$ 和 $A_1(x) B_0(x)$ ，
同样 $Q$ 的实部和虚部就分别为 $A_0(x) B_1(x)$ 和 $A_1(x) B_1(x)$ 。

参考实现：

```cpp
#include <cstdio>
#include <complex>
#define debug(...) fprintf(stderr, __VA_ARGS__)

typedef long long lolong;
typedef std::complex<double> complex;

inline int input() { int x; scanf("%d", &x); return x; }
inline lolong linput() { lolong x; scanf("%lld", &x); return x; }

const int maxn = 400005, maxk = 20;
const complex I(0, 1);
int R[maxn];
complex Wn[maxn];

void FFT(complex *A, int n, int t) {
	if(t == -1)
		for(int i = 1; i < n; i ++)
			if(i < (n - i))
				std::swap(A[i], A[n - i]);
	for(int i = 0; i < n; i ++)
		if(i < R[i])
			std::swap(A[i], A[R[i]]);

	for(int m = 1, l = 0; m < n; m <<= 1, l ++) {
		/* complex Wn(cos(M_PI / m), sin(M_PI / m) * t); */
		for(int i = 0; i < n; i += m << 1) {
			/* complex W = 1; */
			for(int k = i; k < i + m; k ++) {
				/* complex W(cos(M_PI / m * (k - i)), sin(M_PI / m * (k - i)) * t); */
				complex W = Wn[1ll * (k - i) * n / m];
				/* if(t == -1) W = std::conj(W); */
				complex a0 = A[k], a1 = A[k + m] * W;
				A[k] = a0 + a1;
				A[k + m] = a0 - a1;
				/* W *= Wn; */
			}
		}
	}

	if(t == -1)
		for(int i = 0; i < n; i ++)
			A[i] /= n;
}

int mod;
inline lolong num(complex x) {
	double d = x.real();
	return d < 0 ? lolong(d - 0.5) % mod : lolong(d + 0.5) % mod;
}

inline void FFTFFT(complex *a, complex *b, int len, int t) {
	for(int i = 0; i < len; i ++)
		a[i] = a[i] + I * b[i];
	FFT(a, len, t);
	for(int i = 0; i < len; i ++)
		b[i] = std::conj(a[i ? len - i : 0]);
	for(int i = 0; i < len; i ++) {
		complex p = a[i], q = b[i];
		a[i] = (p + q) * 0.5;
		b[i] = (q - p) * 0.5 * I;
	}
}

complex a0[maxn], a1[maxn], b0[maxn], b1[maxn];
/* complex a0b0[maxn], a1b0[maxn], a0b1[maxn], a1b1[maxn]; */
complex p[maxn], q[maxn];

int main() {
	int n = input(), m = input();
	mod = input();
	int M = int(sqrt(mod) + 1);

	for(int i = 0; i <= n; i ++) {
		int x = input() % mod;
		a0[i] = x / M;
		a1[i] = x % M;
	}
	for(int i = 0; i <= m; i ++) {
		int x = input() % mod;
		b0[i] = x / M;
		b1[i] = x % M;
	}

	int len = 1;
	while(len < n + m + 1)
		len <<= 1;

	for(int i = 1; i < len; i ++)
		R[i] = R[i >> 1] >> 1 | ((i & 1) * (len >> 1));

	for(int i = 0; i < len; i ++)
		Wn[i] = complex(cos(M_PI / len * i), sin(M_PI / len * i));

	FFTFFT(a0, a1, len, 1);
	FFTFFT(b0, b1, len, 1);

	for(int i = 0; i < len; i ++) {
		p[i] = a0[i] * b0[i] + I * a1[i] * b0[i];
		q[i] = a0[i] * b1[i] + I * a1[i] * b1[i];
	}

	FFT(p, len, -1);
	FFT(q, len, -1);

	for(int i = 0; i <= n + m; i ++)
		printf("%lld ", (M * M * num(p[i].real()) % mod +
				M * (num(p[i].imag()) + num(q[i].real())) % mod +
				num(q[i].imag())) % mod);
	puts("");
}
```


---

## 作者：command_block (赞：44)

一种奇怪的拆系数FFT?需要5次FFT但是推导很简单,便于记忆,常数也不大。

卷积后，能产生的最大的数也就是$mod*mod*len$,实战应用中一般是$10^9*10^9*10^5=10^{23}$。

我们只要弄一个精度够高的多项式乘法,就能做到不丢精度。

一种想法是:跑九次NTT(三次乘法),把答案用中国剩余定理合并,精度可达$10^{26}$

这种做法常数实在过大,而且$10^{26}$使用`long long`存不下,还需要一些黑科技辅助,所以不推荐。

另一种想法是:拆系数FFT。

把一个数拆成$a*2^{15}+b$的形式,那么$a,b<=2^{15}$

把$a$和$b$弄成两个多项式,这样相乘的值域是$n*mod≈10^{14}$

那么$c_1*c_2=(a_1*2^{15}+b_1)(a_2*2^{15}+b_2)$

$=a_1a_2*2^{30}+(a_1b_2+a_2b_1)2^{15}+b_1b_2$

那么就是要做$4$次多项式乘法?12次FFT?常数爆炸!

冷静分析:每个多项式只用插值一次,共4次。

点乘复杂度忽略,最后得到的四个多项式各插值一次,共4次。

这样就是8次FFT,常数还是爆炸……

我们考虑推推式子来优化:

我们有四个多项式$A1,A2,B1,B2$,求这些多项式的两两乘积。

考虑到$(a+bi)*(c+di)=a(c+di)*bi(c+di)=ac-bd+(ad+bc)i$

那么我们设复多项式$P=A1+iA2;\ Q=B1+iB2;$

那么$T1=P*Q=A1B1-A2B2+(A1B2+A2B1)i$

我们又设$P'=A1-iA2$

那么$T2=P'*Q=A1B1+A2B2+(A1B2-A2B1)i$

$T1+T2=2(A1B1+iA1B2)$,这样我们就求出了其中两个,减一减就能得到另外两个。

总的FFT次数是:3次DFT+2次IDFT=5次.

不过,值域并不是美好的$10^{14}$,而是$10^{19}$,因为在IDFT出来之前还得除以$n$……

`long double`信仰跑吧,代码并不难写。

```cpp
#include<algorithm>
#include<cstdio>
#include<cmath>
#define Maxn 100500
#define lim 32000
const long double Pi=acos(-1);
using namespace std;
inline int read()
{
  register int X=0;
  register char ch=0;
  while(ch<48||ch>57)ch=getchar();
  while(ch>=48&&ch<=57)X=X*10+(ch^48),ch=getchar();
  return X;
}
int n,m,p,tr[Maxn<<2];
struct CP
{
  long double x,y;
  CP operator + (const CP& B) const
  {return (CP){x+B.x,y+B.y};}
  CP operator - (const CP& B) const
  {return (CP){x-B.x,y-B.y};}
  CP operator * (const CP& B) const
  {return (CP){x*B.x-y*B.y,x*B.y+y*B.x};}
}P1[Maxn<<2],P2[Maxn<<2],Q[Maxn<<2];
void FFT(CP *f,int op,int n)
{
  for (int i=0;i<n;i++)
   if (i<tr[i])swap(f[i],f[tr[i]]);
  for(int p=2;p<=n;p<<=1){
    int len=p>>1;
    CP tmp=(CP){std::cos(Pi/len),op*std::sin(Pi/len)};
    for(int k=0;k<n;k+=p){
      CP buf=(CP){1,0};
      for(int l=k;l<k+len;l++){
        CP tt=buf*f[len+l];
        f[len+l]=f[l]-tt;
        f[l]=f[l]+tt;
        buf=buf*tmp;
      }//F(x)=FL(x^2)+x*FR(x^2)
       //F(W^k)=FL(w^k)+W^k*FR(w^k)
       //F(W^{k+n/2})=FL(w^k)-W^k*FR(w^k)
    }
  }
}
int ans[Maxn<<2];
int main()
{
  scanf("%d%d%d",&n,&m,&p);n++;m++;
  for (int i=0,sav;i<n;i++){
    sav=read();
    P1[i]=(CP){sav/lim,sav%lim};
    P2[i]=(CP){sav/lim,-sav%lim};
  }
  for (int i=0,sav;i<m;i++){
    sav=read();
    Q[i]=(CP){sav/lim,sav%lim};
  }
  int len=1;
  for (m=m+n-1;len<m;len<<=1);
  for (int i=1;i<len;i++)
    tr[i]=tr[i>>1]>>1|((i&1)?len>>1:0);
  FFT(P1,1,len);FFT(P2,1,len);FFT(Q,1,len);
  for (int i=0;i<len;i++){Q[i].x/=len;Q[i].y/=len;}
  for (int i=0;i<len;i++)P1[i]=P1[i]*Q[i];
  for (int i=0;i<len;i++)P2[i]=P2[i]*Q[i];
  FFT(P1,-1,len);FFT(P2,-1,len);
  for (int i=0;i<m;i++){
    long long a1b1=0,a1b2=0,a2b1=0,a2b2;
    a1b1=(long long)floor((P1[i].x+P2[i].x)/2+0.49)%p;
    a1b2=(long long)floor((P1[i].y+P2[i].y)/2+0.49)%p;
    a2b1=((long long)floor(P1[i].y+0.49)-a1b2)%p;
    a2b2=((long long)floor(P2[i].x+0.49)-a1b1)%p;
    ans[i]=((a1b1*lim+(a1b2+a2b1))*lim+a2b2)%p;
    ans[i]=(ans[i]+p)%p;
    printf("%d ",ans[i]);
  }return 0;
}
```

如果被卡,考虑预处理单位根。

目测常数是$NTT$的4倍……

---

## 作者：Prean (赞：29)

这是一个 $5$ 次 FFT 的做法，但是可以把 $4$ 次 FFT 吊起来锤。

我给同学讲了这种做法，他说这个做法吊打别的 $5$ 次 FFT，建议我发篇题解，那就发吧。。。

这种 $5$ 次 FFT 的做法不需要根据系数的关系解方程什么的，只需要设复多项式然后大力卷就行了。。。重要的是 $4$ 次 FFT 不能用转置但是这种 $5$ 次的可以。

假设我们要计算 $F(x)\times G(x)$。

设 $F(x)=A(x)+c\times B(x),G(x)=C(x)+c\times D(x)$，那么我们要求的就是：
$$A(x)C(x)+c\times(A(x)D(x)+B(x)C(x))+c^2\times B(x)D(x)$$
对比一下：
$$A(x)C(x),A(x)D(x)$$
$$B(x)C(x),B(x)D(x)$$
设 $T(x)=C(x)+i\times D(x)$，那么我们可以在 $A(x)T(x)$ 和 $B(x)T(x)$ 中找到我们需要的所有项。

需要对 $A(x),B(x),T(x)$ 做 DFT，$A(x)T(x)$ 和 $B(x)T(x)$ 做 IDFT，跑起来还是相当快的。

并且我使用这种 MTT 跑长度为 $2^{21}$ 的卷积时仍然没掉精度。
```cpp
#include<cstdio>
#include<cctype>
#include<cmath>
#define IMP(lim,act) for(int qwq=(lim),i=0;i^qwq;++i)act
typedef double db;
const int M=1<<18|5;
const db Pi=acos(-1);
int n,m,P,F[M],G[M],H[M];
struct Barrett{
	typedef unsigned long long ull;
	typedef __uint128_t LL;
	ull B,m;
	Barrett(const ull&m=2):m(m),B((LL(1)<<64)/m){}
	friend inline ull operator%(const ull&a,const Barrett&mod){
		ull r=a-mod.m*(LL(mod.B)*a>>64);return r>=mod.m?r-mod.m:r;
	}
}mod;
struct complex{
	db x,y;
	complex(const db&x=0,const db&y=0):x(x),y(y){}
	inline complex operator+(const complex&it)const{
		return complex(x+it.x,y+it.y);
	}
	inline complex operator-(const complex&it)const{
		return complex(x-it.x,y-it.y);
	}
	inline complex operator*(const complex&it)const{
		return complex(x*it.x-y*it.y,x*it.y+y*it.x);
	}
}buf[M<<1],*w[20];
inline int Getlen(const int&n){
	int len(0);while((1<<len)<n)++len;return len;
}
inline void swap(complex&a,complex&b){
	complex c=a;a=b;b=c;
}
inline int Get(const db&x){
	return((long long)(x+.5))%mod;
}
inline void init(const int&n){
	const int&m=Getlen(n);complex*now=buf;w[m]=now;now+=1<<m;
	IMP(1<<m,w[m][i]=complex(std::cos(i*Pi/(1<<m)),std::sin(i*Pi/(1<<m))));
	for(int k=m-1;k>=0&&(w[k]=now,now+=1<<k);--k)IMP(1<<k,w[k][i]=w[k+1][i<<1]);
}
inline void DFT(complex*f,const int&M){
	const int&n=1<<M;
	for(int len=n>>1,d=M-1;d>=0;--d,len>>=1)for(int k=0;k^n;k+=len<<1){
		complex*W=w[d],*L=f+(k),*R=f+(k|len),x,y;IMP(len,(x=*L,y=*R)),*L++=(x+y),*R++=*W++*(x-y);
	}
}
inline void IDFT(complex*f,const int&M){
	const int&n=1<<M;
	for(int len=1,d=0;d^M;++d,len<<=1)for(int k=0;k^n;k+=len<<1){
		complex*W=w[d],*L=f+(k),*R=f+(k|len),x,y;IMP(len,(x=*L,y=*W++**R)),*L++=(x+y),*R++=(x-y);
	}
	IMP(n,(f[i].x/=n,f[i].y/=n));for(int i=1;(i<<1)<n;++i)swap(f[i],f[n-i]);
}
inline void MTT(int*f,int*g,int*h,const int&n,const int&m,const int&LEN){
	static complex Q[M],P[M],T[M];const int&len=Getlen(n+m-1);
	IMP(n,(Q[i].x=f[i]&32767,P[i].x=f[i]>>15));IMP(m,T[i]=complex(g[i]&32767,g[i]>>15));
	DFT(Q,len);DFT(P,len);DFT(T,len);IMP(1<<len,(Q[i]=Q[i]*T[i],P[i]=P[i]*T[i]));IDFT(Q,len);IDFT(P,len);
	IMP(LEN,h[i]=(Get(Q[i].x)+(1ll*(Get(Q[i].y)+Get(P[i].x))<<15)+(1ll*Get(P[i].y)<<30))%mod);
	IMP(1<<len,Q[i]=P[i]=T[i]=complex());
}
inline int read(){
	int n(0);char s;while(!isdigit(s=getchar()));while(n=n*10+(s&15),isdigit(s=getchar()));return n;
}
inline void write(int n){
	static char s[15];int top(0);while(s[++top]=n%10^48,n/=10);while(putchar(s[top]),--top);putchar(' ');
}
signed main(){
	n=read()+1;m=read()+1;mod=Barrett(P=read());init(n+m-1);
	IMP(n,F[i]=read());IMP(m,G[i]=read());MTT(F,G,H,n,m,n+m-1);IMP(n+m-1,write(H[i]));
}
```

---

## 作者：skydogli (赞：26)

大家好，作为一名多项式菜鸡，我用karatsuba乘法通过了本题。

$\quad$众所周知，如果模数不同，NTT支持的值域只能小于模数，也就是取模对所有答案都不会产生影响，不然就只能使用三模NTT加中国剩余定理解决。而FFT支持取模操作，但是精度爆炸，入门多项式选手通常要用7、8次FFT（当然，很多神仙可以只用4次5次甚至3次）。相比于模板，这道题使用NTT和FFT的难度加大了许多。

$\quad$然而，多项式乘法并不只有这两种乘法，还有一种思路更加简单的、只靠代数转化来降低复杂度的算法：karatsuba乘法。它的原理只有短短几行：

我们把多项式$f$拆成$A\times x^p+B$,$g$拆成$C\times x^p+D$
$$f\times g$$
$$=(A\times x^p+B)\times(C\times x^p+D)$$
$$=AC\times x^{2p}+BC\times x^p+AD\times x^p+BD$$
$$=AC\times x^{2p}+(BC+AD)\times x^p+BD$$
而$BC+AD=(A+B)(C+D)-AC-BD$

所以原式$=AC\times x^{2p}+[(A+B)(C+D)-AC-BD]\times x^p+BD$

我们发现只需要3次多项式乘法和若干次加减法即可。

那这个复杂度是多少呢？

学习了[这篇博客](https://zhuanlan.zhihu.com/p/55653747)

它的递推式是$T(n)=3T(\frac{n}{2})+O(n),T(1)=1$

我们推一下：

设 
$$k=log_2n,n=2^k,f(k)=T(2^k)$$
所以
$$f(k)=3f(k-1)+2^k$$
同时除以$3^k$
$$\frac{f(k)}{3^k}=\frac{f(k-1)}{3^{k-1}}+(\frac{2}{3})^k$$
设
$$g(k)=\frac{f(k)}{3^k}$$
所以
$$g(k)=\sum_{i=1}^k{(\frac{2}{3})^i}\leq 3$$
上面可以用等比数列求和证明,带回来：
$$f(k)\leq 3^{k+1}$$
$$T(n)=f(log_2n)\leq f({3}^{log_2n+1})$$
$$=O(3^{log_2n})=O(2^{log_2 3\times log_2 n})=O(n^{log_2 3})$$

$log_23$大概是1.585，所以我们的复杂度可以近似地看成$O(n\sqrt{n})$

另外如果$n=2^k$，它的通项是$T(n)=2\times 3^k-2^{k+1}$(orz [Crazyali](https://www.luogu.com.cn/user/18215))，感兴趣的同学可以推一下。

当然，其实我们可以分更多组，复杂度可以进一步降低，但会增大常数且变换更加复杂，通常不会使用。

介绍完这个算法后，我们发现它在真正的乘法过程中没有任何的要求，也没有单位根、原根等限制，所以这题对于karatsuba乘法来说和多项式乘法模板几乎没有差别，加上这题仅$10^5$的数据范围，对karatsuba非常友好~~当然还是卡常~~

于是出现了小蒟蒻第一份代码:
```cpp

void fill(vector<LL> &f,vector<LL> &a,vector<LL> &b,int len){
	b.resize(len);a.resize(f.size()-len);
	int cnt=0;
	for(int i=0;i<len;++i)
		b[cnt++]=f[i];
	cnt=0;
	for(int i=len;i<f.size();++i)
		a[cnt++]=f[i];
}
//(a*p+b)(c*p+d)=ac*p^2+bc*p+ad*p+bd
//=ac*p^2+(ad+bc)*p+bd
//=ac*p^2+((a+b)(c+d)-ac-bd)*p+bd
void add(LL &a,LL b){((a+=b)>=Mod)?(a-=Mod):0;}
void sub(LL &a,LL b){((a-=b)<0)?(a+=Mod):0;} 
void MUL(vector<LL> &f,vector<LL> &g,vector<LL> &res){
	res.resize(f.size()+g.size()-1);
	for(int i=0;i<res.size();++i)res[i]=0;
	if(f.size()<2||g.size()<2){
		for(int i=0;i<f.size();++i)
			for(int j=0;j<g.size();++j)
				res[i+j]=(res[i+j]+f[i]*g[j])%Mod;
		return;
	}
	vector<LL>a,b,c,d,r1,r2,r3,r4;
	int len1=(f.size())/2,len2=(g.size())/2;
	a.clear();b.clear();c.clear();d.clear();
	fill(f,a,b,len1);fill(g,c,d,len2);
	r1.clear();r2.clear();r3.clear();r4.clear();
	MUL(a,c,r1);
	for(int i=0;i<r1.size();++i){
		add(res[i+len1+len2],r1[i]);
		sub(res[i+len1],r1[i]);
	}
	MUL(b,d,r4);
	for(int i=0;i<r4.size();++i){
		add(res[i],r4[i]);
		sub(res[i+len1],r4[i]);
	}
	for(int i=0;i<len1;++i)add(a[i],b[i]);
	for(int i=0;i<len2;++i)add(c[i],d[i]);
	MUL(a,c,r3);
	for(int i=0;i<r3.size();++i){
		add(res[i+len1],r3[i]);
	}
}
```
[结果](https://www.luogu.com.cn/record/29927587)

要是这样就能过，那估计也轮不上我写题解了。
- 小技巧0

这个应该不用解释吧
```cpp
#pragma GCC optimize(2) 
#pragma GCC optimize(3) 
#pragma GCC optimize("Ofast")
```
- 小技巧1

我们发现这个算法的常数还是比较大的，要好几次多项式加减法，所以我们到比较小的数据范围时可以直接暴力算。窝取的范围是30以内。
```cpp

void fill(vector<LL> &f,vector<LL> &a,vector<LL> &b,int len){
	b.resize(len);a.resize(f.size()-len);
	int cnt=0;
	for(int i=0;i<len;++i)
		b[cnt++]=f[i];
	cnt=0;
	for(int i=len;i<f.size();++i)
		a[cnt++]=f[i];
}
//(a*p+b)(c*p+d)=ac*p^2+bc*p+ad*p+bd
//=ac*p^2+(ad+bc)*p+bd
//=ac*p^2+((a+b)(c+d)-ac-bd)*p+bd
void add(register LL &a,register LL b){((a+=b)>=Mod)?(a-=Mod):0;}
void sub(register LL &a,register LL b){((a-=b)<0)?(a+=Mod):0;} 
void MUL(vector<LL> &f,vector<LL> &g,vector<LL> &res){
	res.resize(f.size()+g.size()-1);
	for(int i=0;i<res.size();++i)res[i]=0;
	if(f.size()<32||g.size()<32){
		for(int i=0;i<f.size();++i)
			for(int j=0;j<g.size();++j)
				res[i+j]=(res[i+j]+f[i]*g[j])%Mod;
		return;
	}
	vector<LL>a,b,c,d,r1,r2,r3,r4;
	int len1=(f.size())/2,len2=(g.size())/2;
	a.clear();b.clear();c.clear();d.clear();
	fill(f,a,b,len1);fill(g,c,d,len2);
	r1.clear();r2.clear();r3.clear();r4.clear();
	MUL(a,c,r1);
	for(int i=0;i<r1.size();++i){
		add(res[i+len1+len2],r1[i]);
		sub(res[i+len1],r1[i]);
	}
	MUL(b,d,r4);
	for(int i=0;i<r4.size();++i){
		add(res[i],r4[i]);
		sub(res[i+len1],r4[i]);
	}
	for(int i=0;i<len1;++i)add(a[i],b[i]);
	for(int i=0;i<len2;++i)add(c[i],d[i]);
	MUL(a,c,r3);
	for(int i=0;i<r3.size();++i){
		add(res[i+len1],r3[i]);
	}
}
```
[结果](https://www.luogu.com.cn/record/29928466)

- ~~小技巧2~~

~~可以把int改成long long~~

然后发现甚至慢了一点。

洛谷的评测机是64位，所以long long真的没有比int慢。

~~屑~~

- 小技巧3

都说vector常数大，那我改成数组？

在我神奇的本机从20s变成了6s！（本机20s交上去真有70）
```cpp
void fill(LL *f,LL *a,LL *b,int len,int sz){
	for(rint i=0;i<len;++i)
		b[i]=f[i];
	int cnt=0;
	for(rint i=len;i<sz;++i)
		a[cnt++]=f[i];
}
//(a*p+b)(c*p+d)=ac*p^2+bc*p+ad*p+bd
//=ac*p^2+(ad+bc)*p+bd
//=ac*p^2+((a+b)(c+d)-ac-bd)*p+bd
void add(register LL &a,register LL b){((a+=b)>=Mod)?(a-=Mod):0;}
void sub(register LL &a,register LL b){((a-=b)<0)?(a+=Mod):0;} 
void MUL(LL *f,LL *g,LL *res,int dep,int sz1,int sz2){
	for(int i=0;i<sz1+sz2;++i)res[i]=0;
	if(sz1<28){
		for(register int i=0;i<sz1;++i)
			for(register int j=0;j<sz2;++j)
				res[i+j]=(res[i+j]+f[i]*g[j])%Mod;
		return;
	}
	int len=sz1/2;
	fill(f,a[dep],b[dep],len,sz1);fill(g,c[dep],d[dep],len,sz2);
	MUL(a[dep],c[dep],r1[dep],dep+1,sz1-len,sz2-len);
	int L=sz1+sz2-len-len-1;
	for(int i=0;i<L;++i){
		sub(res[i+len],r1[dep][i]);
		add(res[i+(len<<1)],r1[dep][i]);
	}
	MUL(b[dep],d[dep],r4[dep],dep+1,len,len);
	for(rint i=0;i<len*2-1;++i){
		register LL tmp=r4[dep][i];
		add(res[i],tmp);
		sub(res[i+len],tmp);
	}
	for(rint i=0;i<len;++i)add(a[dep][i],b[dep][i]);
	for(rint i=0;i<len;++i)add(c[dep][i],d[dep][i]);
	MUL(a[dep],c[dep],r3[dep],dep+1,sz1-len,sz2-len);
	for(rint i=0;i<L;++i){
		add(res[i+len],r3[dep][i]);
	}
}
```
[发现毫无意义](https://www.luogu.com.cn/record/29930918)

内存调用好玄学啊，~~又想起k级祖先长剖被树剖吊打的恐惧~~

- 最暴力的操作

一直在70分徘徊好久，万念俱灰之际，看到暴力乘法：
```cpp
	for(register int i=0;i<sz1;++i)
		for(register int j=0;j<sz2;++j)
			res[i+j]=(res[i+j]+f[i]*g[j])%Mod;
	return;
```
取模好像有点多。。。。

但是long long 肯定要随时取模啊。。。

### __int128???

洛谷是64位机子来着。。。

```cpp

	if(sz1<28){
		for(register int i=0;i<sz1;++i)
			for(register int j=0;j<sz2;++j)
				qwq[i+j]+=(LL)f[i]*g[j];
		for(int i=0;i<sz1+sz2;++i)res[i]=qwq[i]%Mod,qwq[i]=0;
		return;
	}
    //qwq是__int128
```

然后提交——[???](https://www.luogu.com.cn/record/29931859)

过 了

行吧，真玄学。

最后的AC代码：
```cpp
#pragma GCC optimize(2) 
#pragma GCC optimize(3) 
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define mn 19
#define MN 200005
#define rint register int
int Mod=998244353,n,m;
__int128 qwq[59]; 
//vector<LL>F,G,ANS;
int a[mn][MN],b[mn][MN],c[mn][MN],d[mn][MN],r1[mn][MN],r4[mn][MN],r3[mn][MN],F[MN],G[MN],ANS[MN];
void fill(int *f,int *a,int *b,int len,int sz){
	for(rint i=0;i<len;++i)
		b[i]=f[i];
	int cnt=0;
	for(rint i=len;i<sz;++i)
		a[cnt++]=f[i];
}
//(a*p+b)(c*p+d)=ac*p^2+bc*p+ad*p+bd
//=ac*p^2+(ad+bc)*p+bd
//=ac*p^2+((a+b)(c+d)-ac-bd)*p+bd
void add(register int &a,register int b){((a+=b)>=Mod)?(a-=Mod):0;}
void sub(register int &a,register int b){((a-=b)<0)?(a+=Mod):0;} 
void MUL(int *f,int *g,int *res,int dep,int sz1,int sz2){
	for(int i=0;i<sz1+sz2;++i)res[i]=0;
	if(sz1<28){
		for(register int i=0;i<sz1;++i)
			for(register int j=0;j<sz2;++j)
				qwq[i+j]+=(LL)f[i]*g[j];
		for(int i=0;i<sz1+sz2;++i)res[i]=qwq[i]%Mod,qwq[i]=0;
		return;
	}
	int len=sz1/2;
	fill(f,a[dep],b[dep],len,sz1);fill(g,c[dep],d[dep],len,sz2);
	MUL(a[dep],c[dep],r1[dep],dep+1,sz1-len,sz2-len);
	int L=sz1+sz2-len-len-1;
	for(int i=0;i<L;++i){
		sub(res[i+len],r1[dep][i]);
		add(res[i+(len<<1)],r1[dep][i]);
	}
	MUL(b[dep],d[dep],r4[dep],dep+1,len,len);
	for(rint i=0;i<len*2-1;++i){
		register LL tmp=r4[dep][i];
		add(res[i],tmp);
		sub(res[i+len],tmp);
	}
	for(rint i=0;i<len;++i)add(a[dep][i],b[dep][i]);
	for(rint i=0;i<len;++i)add(c[dep][i],d[dep][i]);
	MUL(a[dep],c[dep],r3[dep],dep+1,sz1-len,sz2-len);
	for(rint i=0;i<L;++i){
		add(res[i+len],r3[dep][i]);
	}
}
inline int read(){
	int a=0;char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while('0'<=c&&c<='9'){
		a=a*10+c-48;
		c=getchar();
	}
	return a;
}
int main(){
//	freopen("qwq.in","r",stdin);
//	freopen("qwq.out","w",stdout);
	n=read();m=read();Mod=read();
	int N=max(n+1,m+1);
	for(int i=0;i<=n;++i)F[i]=read()%Mod;
	for(int i=0;i<=m;++i)G[i]=read()%Mod;
	MUL(F,G,ANS,0,N,N);
	for(int i=0;i<=n+m;++i)
		printf("%d ",ANS[i]);
	return 0;
}
```
于是决定写篇博客供大家娱乐。

另外，小蒟蒻的实现不算清真，欢迎大家提出改进建议和批评。




---

## 作者：AzusaCat (赞：12)

如果不取模，按 OI 常见数据范围来讲两个多项式相乘以后系数不超过 $10^9\times10^9\times10^5=10^{23}$，如果我们算出该多项式分别 $\bmod$ 3 个 NTT 模数下的值，我们就可以通过 CRT 合并计算出模三个模数之积的值，而这样最高精度能达到 $10^{26}$ 级别，足够应付。但是这种方法一次多项式乘法需要 9 次 DFT，比较慢。下面介绍一下比较常见的优化拆系数 FFT。

众所周知，FFT 中不用取模，只需要结果取一次模就可以了。但是这题最大的系数达到了 $10^{23}$ 级别，直接 FFT 精度不足。对此我们引出拆系数 FFT。

设 $bas$ 为一个 $\sqrt{p}$ 级别的数，$F(x),G(x)$ 为我们要进行乘法的多项式，那么我们可以把 两个多项式表示成以下形式：
$$
\begin{aligned}
F(x)=basA(x)+B(x)\\
G(x)=basC(x)+D(x)
\end{aligned}
$$
其中，$[x^n]A(x)=\lfloor \frac{[x^n]F(x)}{bas} \rfloor$，$[x^n]B(x)=[x^n]F(x)\bmod bas$，对于 $C(x),D(x)$ 同理。这样系数就被降低到了 $10^5bas^2$ 的级别。那么有
$$
\begin{aligned}
F(x)G(x)&=(basA(x)+B(x))(basC(x)+D(x))\\
&=bas^2A(x)C(x)+bas(A(x)D(x)+B(x)C(x))+B(x)D(x)
\end{aligned}
$$
这样先算出 $A(x),B(x),C(x),D(x)$ 的点值表示，然后根据乘的系数不同做三次 IDFT，这样一次多项式乘法一共要做 7 次 FFT。

我们发现 DFT 的时候虚部一开始全为 0，可以通过一些方法利用上这里，减少 DFT 次数。

首先我们要明白 DFT 的本质是 $F(w_n^k)=\sum\limits_{i=0}^nf_iw_n^{ki}$ ，假设我们现在要算出 $A(x)$ 与 $B(x)$ 的点值表示。

如果我们知道了一个数组使得 $F[k]=A(w_n^k)+iB(w_n^k)$，$G[k]=A(w_n^k)-iB(w_n^k)$，那么我们可以通过解方程组的方式知道 $A(w_n^k)$ 与 $B(w_n^k)$。

现在我们尝试推导 $F$ 与 $G$ 的关系，通过 DFT 的定义可以知道：
$$
\begin{aligned}
F[k]&=A(w_n^k)+iB(w_n^k)\\
&=\sum\limits_{j=0}^{n-1}a_iw_n^{kj}+i\sum\limits_{i=0}^nb_jw_n^{kj}\\
&=\sum\limits_{j=0}^{n-1}{n-1}(a_j+ib_j)w_n^{kj}\\
&=\sum\limits_{j=0}^{n-1}(a_j+ib_j)(\cos(X)+i\sin(X))\\
&=\sum\limits_{j=0}^{n-1}(a_j\cos(X)-b_j\sin(X))+i(b_j\cos(X)+a_j\sin(X))\\
\end{aligned}
$$
其中，$X=\frac{2\pi kj}{n}$。

同时，我们有
$$
\begin{aligned}
G[n-k]&=A(w_n^{n-k})-iB(w_n^{n-k})\\
&=A(w_n^{-k})-iB(w_n^{-k})\\
&=\sum\limits_{j=0}^{n-1}a_iw_n^{-kj}-i\sum\limits_{i=0}^nb_jw_n^{-kj}\\
&=\sum\limits_{j=0}^{n-1}{n-1}(a_j-ib_j)w_n^{-kj}\\
&=\sum\limits_{j=0}^{n-1}(a_j-ib_j)(\cos(X)-i\sin(X))\\
&=\sum\limits_{j=0}^{n-1}(a_j\cos(X)-b_j\sin(X))-i(b_j\cos(X)+a_j\sin(X))\\
\end{aligned}
$$
所以，我们发现 $F[k]$ 与 $G[n-k]$ 是共轭的（$k=0$ 时要特判一下放到 $G[0]$ 去），所以我们只需要计算出 $F$，就可以 $O(n)$ 计算出 $G$。这样只需要 2 次 FFT，就可以计算出四个多项式的点值。

然后考虑 IDFT 部分，这里也可以省一次 FFT。我们正常求 IDFT 的时候最后结果全部都在实部（不明白去看单位根反演），那么如果我们在最开始每个点值都乘上 $i$，那么最后出来的结果应该都在虚部，而且数值和放在实部上相等。我们知道 FFT 是一个线性变换，所以我们可以把要求的两个多项式分别放在实部和虚部上，然后 IDFT 之后实部和虚部上就是分别的原多项式了。这样就又省了一次 FFT，一次多项式乘法总共需要 4 次。

实际使用一般设 $bas$ 为 $2$ 的次幂，比较方便提取系数。  
这份代码实现不够精细，没有预处理单位根，导致精度不足必须开 `long double`  
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace poly
{
    long double const pi=acos(-1);
    struct comp
    {
        long double r,i;
        comp(){r=i=0;}
        comp(long double x,long double y){r=x,i=y;}
        comp conj(){return comp(r,-i);}
        friend comp operator +(comp x,comp y){return comp(x.r+y.r,x.i+y.i);}
        friend comp operator -(comp x,comp y){return comp(x.r-y.r,x.i-y.i);}
        friend comp operator *(comp x,comp y){return comp(x.r*y.r-x.i*y.i,x.i*y.r+x.r*y.i);}
    };
    typedef long long ll;
    int r[400005];
    comp a[400005],b[400005],c[400005],d[400005];
    void fft(comp *f,int n,int op)
    {
        for(int i=1;i<n;i++)r[i]=(r[i>>1]>>1)+((i&1)?(n>>1):0);
        for(int i=1;i<n;i++)if(i<r[i])swap(f[i],f[r[i]]);
        for(int len=2;len<=n;len<<=1)
        {
            int q=len>>1;
            comp wn=comp(cos(pi/q),op*sin(pi/q));
            for(int i=0;i<n;i+=len)
            {
                comp w=comp(1,0);
                for(int j=i;j<i+q;j++,w=w*wn)
                {
                    comp d=f[j+q]*w;
                    f[j+q]=f[j]-d;
                    f[j]=f[j]+d;
                }
            }
        }
    }
    void mtt(int *f,int *g,int *h,int n,int p)
    {
        for(int i=0;i<n;i++)
            a[i].r=(f[i]>>15),a[i].i=(f[i]&32767),
            c[i].r=(g[i]>>15),c[i].i=(g[i]&32767);
        fft(a,n,1),fft(c,n,1);
        for(int i=1;i<n;i++)b[i]=a[n-i].conj();
        b[0]=a[0].conj();
        for(int i=1;i<n;i++)d[i]=c[n-i].conj();
        d[0]=c[0].conj();
        for(int i=0;i<n;i++)
        {
            comp 
            aa=(a[i]+b[i])*comp(0.5,0),
            bb=(a[i]-b[i])*comp(0,-0.5),
            cc=(c[i]+d[i])*comp(0.5,0),
            dd=(c[i]-d[i])*comp(0,-0.5);
            a[i]=aa*cc+comp(0,1)*(aa*dd+bb*cc),b[i]=bb*dd;
        }
        fft(a,n,-1),fft(b,n,-1);
        for(int i=0;i<n;i++)
        {
            int 
            aa=(ll)(a[i].r/n+0.5)%p,
            bb=(ll)(a[i].i/n+0.5)%p,
            cc=(ll)(b[i].r/n+0.5)%p;
            h[i]=((1ll*aa*(1<<30)+1ll*bb*(1<<15)+cc)%p+p)%p;
        }
    }
}
using namespace poly;
int f[400005],g[400005],h[400005];
int main()
{
    int n,m,p;
    scanf("%d%d%d",&n,&m,&p);
    for(int i=0;i<=n;i++)scanf("%d",&f[i]);
    for(int i=0;i<=m;i++)scanf("%d",&g[i]);
    int lim=1;
    while(lim<=(n+m))lim<<=1;
    mtt(f,g,h,lim,p);
    for(int i=0;i<=n+m;i++)printf("%d ",h[i]);
    return 0;
}

---

## 作者：SukiYuri (赞：2)

### 鲜花

题解通道居然没有关，那我来水一发（

## 分析

首先，这一题的最大值在 $10^{23}$ 左右，因此可以暴力 CRT 合并，但是这种方法一共要做 9 次 NTT，效率是极低的。但是 FFT 精度又不够，因此我们可以拆系数，具体的，假设我们需要计算 $A(x)\times B(x)$，令 $m=\sqrt{p}$，构造多项式：
$$
A(x)=F_0(x)\cdot m+F_1(x)\\
B(x)=G_0(x)\cdot m+G_1(x)
$$
所以，
$$
A(x)\times B(x)=F_0(x)G_0(x)\cdot m^2+(F_0(x)G_1(x)+F_1(x)G_0(x))\cdot m+F_1(x)G_1(x)
$$
因此我们只需要算这四个东西的卷积就可以啦！

~~什么叫算四次卷积要 12 次 FFT~~

认真看一下好像并不需要算这么多，$F_0(x),G_0(x),F_1(x),G_1(x)$ 的点值我们只需要算一次就好了，然后我们将他们两两相乘，这样只需要 8 次 FFT 就可以啦！

但是这样还没有结束，我们发现上述多项式的系数都是实数，虚数部分是没有用到的，因此这启发我们将两次 FFT 变成一次。具体的，我们令：
$$
P(x)=F_0(x)+iF_1(x)\\
Q(x)=F_0(x)-iF_1(x)
$$
将 $P(x)$ 变为点值表示之后，我们可以 $O(n)$ 的得到 $Q(x)$ 的点值表示，简单推一下式子，设：
$$
F_0(a+bi)=\alpha_0+i\alpha_1\\
F_1(a+bi)=\beta_0+i\beta_1
$$
于是：
$$
F_0(a-bi)=\alpha_0-i\alpha_1\\
F_1(a-bi)=\beta_0-i\beta_1\\
Q(a+bi)=\alpha_0+\beta_1+i(\alpha_1-\beta_0)\\
P(a-bi)=\alpha_0-\beta_1-i(\alpha_1+\beta_0)\\
$$

~~这么简单的式子有必要推吗。~~

现在我们用了两次 FFT 得到了 $F_0(x),F_1(x),G_0(x),G_1(x)$ 的点值表示，考虑到多项式的卷积虚部为 $0$，我们再次使用上述操作，令：
$$
P(x)=F_0(x)G_0(x)+iF_0(x)G_1(x)\\
Q(x)=F_1(x)G_0(x)-iF_1(x)G_1(x)
$$
对 $P(x),Q(x)$ 各做一次 FFT，我们就得到了 4 个多项式的卷积。

## 代码

```cpp
#include "complex"
#include "cmath"
#include "iostream"
#include "vector"
#include "algorithm"
using namespace std;
typedef complex<double> cmpx;
const int maxn=4e5+5;
inline long long In(cmpx y) {
    double x=y.real();
    return x<0?(x-0.5):(x+0.5);
}
struct Poly {
    static int R[maxn],N;
    static cmpx Wn[maxn];
    vector<cmpx> F; int n;
    cmpx& operator [](const int x) {return F[x];} 
    inline void resize(const int n) {this->n=n; F.resize(n); F.shrink_to_fit();}
    inline void setN(const int n) {
        N=1; int pw=0;
        for(;N<n;N<<=1) ++pw;
        for(int i=0;i<N;++i) {
            Wn[i]=cmpx(cos(2*M_PI/N*i),sin(2*M_PI/N*i));
            R[i]=R[i>>1]>>1|(i&1)<<(pw-1);
        }
    } 
    inline void FFT(bool op) {
        for(int i=0;i<N;++i) if(R[i]>i) swap(F[R[i]],F[i]);
        for(int l=2;l<=N;l<<=1) {
            int g=(op?N/l:N-N/l);
            for(int i=0;i<N;i+=l) {
                for(int j=0,gn=0;j<l/2;++j,gn=(gn+g)%N) {
                    cmpx x=F[i+j],y=Wn[gn]*F[i+j+l/2];
                    F[i+j]=x+y;
                    F[i+j+l/2]=x-y;
                }
            }
        }
        if(op) for(cmpx& x:this->F) x/=N;
    }
    friend inline void chan(Poly& a,Poly& b) {
        a.FFT(0);
        b[0]=conj(a[0]);
        for(int i=1;i<N;++i) b[i]=conj(a[N-i]);
        for(int i=0;i<N;++i) {
            cmpx x=a[i]+b[i],y=a[i]-b[i];
            a[i]=cmpx(x.real()/2,x.imag()/2);
            b[i]=cmpx(y.imag()/2,y.real()/-2);
        }
    }
    friend Poly mul(Poly F,Poly G,const int P) {
        Poly F0,G0;
        int u=sqrt(P)+1;
        for(int i=0;i<F.n;++i) {
            int x=F[i].real();
            F[i]=cmpx(x/u,x%u);
            // F[i]=cmpx(x>>15,x&(1<<16)-1);
        }
        for(int i=0;i<G.n;++i) {
            int x=G[i].real();
            G[i]=cmpx(x/u,x%u);
            // G[i]=cmpx(x>>15,x&(1<<16)-1);
        }
        int len=F.n+G.n-1;
        F.setN(len); F.resize(N); G.resize(N);
        F0.resize(N); G0.resize(N);
        chan(F,F0); chan(G,G0);
        for(int i=0;i<N;++i) {
            F[i]=F[i]*G[i]+cmpx(0,1)*F[i]*G0[i];
            F0[i]=F0[i]*G[i]+cmpx(0,1)*F0[i]*G0[i];
        }
        F.FFT(1); F0.FFT(1);
        for(int i=0;i<N;++i) {
            long long a=In(F[i].real())%P+P,b=In(F[i].imag())%P+P,
            c=In(F0[i].real())%P+P,d=In(F0[i].imag())%P+P;
            F[i]=(u*u*a%P+u*(b+c)%P+d)%P;
        }
        F.resize(len);
        return F;
    }
}f,g;
int Poly::R[maxn]={0},Poly::N=0;
cmpx Poly::Wn[maxn]={0};
int main() {
    // freopen(".out","w",stdout);
    ios::sync_with_stdio(0);
    int n,m,p; cin>>n>>m>>p; ++n,++m;
    f.resize(n); g.resize(m);
    for(int i=0,x;i<n;++i) {
        cin>>x;
        f[i]=cmpx(x%p,0);
    }
    for(int i=0,x;i<m;++i) {
        cin>>x;
        g[i]=cmpx(x%p,0);
    }
    f=mul(f,g,p);
    for(int i=0;i<f.n;++i) cout<<int(f[i].real())<<" ";
    return 0;
}
```

---

## 作者：w33z8kqrqk8zzzx33 (赞：2)

我是一只菜鸡，学不会 NTT，所以只能用 **系数分支** 做这道题了。。。

如果直接暴力用 FFT，用 `long double` 还是0分。明显精度炸了，所以考虑如何缩小系数。

首先，设定 $C=\lceil\sqrt{P}\rceil$。

可以把 $A(x)$ 写成 $A_0(x)+C\times A_1(x)$，和 $A_0(x)$ 和 $A_1(x)$ 的系数都小于 $C$。

把 $B(x)$ 一样写成 $B_0(x)+C\times B_1(x)$。

现在，

$$A(x)B(x)=A_0(x)B_0(x)+A_0(x)B_1(x)C+A_1(x)B_0(x)C+A_1(x)B_1(x)C^2$$

这些系数缩小的时候，相乘最大结果系数是 $N(C-1)^2$，大概在 $10^{14}$ 级别，使用 `long double` 就可以过。只用 4 次多项式相乘。如果记一化 $A_0$，$A_1$，$B_0$，$B_1$ 的 DFT 和 $A_0(x)B_1(x)+A_1(x)B_0(x)$ 捆绑 IDFT，可以达到 7 次 FFT。

主要代码：

```cpp
cd a1[262144], b1[262144];
cd a2[262144], b2[262144];
cd r1[262144], r2[262144], r3[262144];
int Av[100005], Bv[100005];
ll ans[262144];

void mult(const int& as, const int& bs, const int& C, const int& P) {
	int n = as+bs-1;
	while(n - (n & (-n))) n += (n & (-n));
	constructrev(n);
	rep(i, as) {
		a1[i] = cd(Av[i] % C);
		a2[i] = cd(Av[i] / C);
	}
	rep(i, bs) {
		b1[i] = cd(Bv[i] % C);
		b2[i] = cd(Bv[i] / C);
	}
	fft(a1, n, 0); fft(a2, n, 0); fft(b1, n, 0); fft(b2, n, 0);
	rep(i, n) r1[i] = a1[i]*b1[i];
	rep(i, n) r2[i] = (a1[i]*b2[i]+a2[i]*b1[i]);
	rep(i, n) r3[i] = a2[i]*b2[i];
	fft(r1, n, 1); fft(r2, n, 1); fft(r3, n, 1);
	int V = C*C%P;
	rep(i, n) ans[i] = (((ll)round(r1[i].real())%P)+C*((ll)round(r2[i].real()))%P+V*((ll)round(r3[i].real())%P))%P;
}


```

---


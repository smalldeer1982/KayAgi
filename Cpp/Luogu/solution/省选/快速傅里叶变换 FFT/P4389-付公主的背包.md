# 付公主的背包

## 题目背景

付公主有一个可爱的背包qwq



## 题目描述

这个背包最多可以装 $10^5$ 大小的东西

付公主有 $n$ 种商品，她要准备出摊了

每种商品体积为 $v_i$，都有无限件

给定 $m$，对于 $s\in [1,m]$，请你回答用这些商品恰好装 $s$ 体积的方案数


## 说明/提示

【数据范围】  
对于 $30\%$ 的数据，$1\le n,m \le 3000$；  
对于 $60\%$ 的数据，纯随机生成；   
对于 $100\%$ 的数据， $1\le n,m \le 10^5$，$1\le v_i \le m$。

## 样例 #1

### 输入

```
2 4
1 2```

### 输出

```
1
2
2
3```

# 题解

## 作者：yybyyb (赞：101)

这题太神了，无限$orz$出题人

$30$分的部分分很显然就是一个背包。并没有什么好说的。

纯随机的数据并不知道怎么乱搞。

所以我直接写我的方法了。。。。

既然背包做不了，又是求一类计数问题的答案，再加上我最近正好再做生成函数这一套理论。这道题目就往这方面想了。

我们假设物品的数量比较少，来看看怎么做这道题目。首先每个物品的个数可以直接看成无限，那么对于一个体积为$V$的物品，我们可以直接构建生成函数。

$$A(x)=\sum_{i=0}^{\infty}[i\%V=0]x^i=\frac{1}{1-x^V}$$

显然答案就是$m$个生成函数的卷积。

如果直接做答案是$O(mn\log n)$，显然不是正确的复杂度。

我们看看怎么优化。

生成函数除了形式幂级数的形式还有封闭形式，我在$A(x)$的后面已经写出了封闭形式，所以只需要把封闭形式的卷积求出来，然后求个逆还原多项式就行了。

但是这样的复杂度是$O(2^m)$，还是$GG$

我们要考虑一个方法，能够把乘法化简。~~很自然的~~想到同时取对数之后就变成了加法，但是多项式求$\ln$的复杂度也是$O(n\log n)$的，但是我们的多项式很特殊，具体的，我们有

$$\ln(1-x^V)=-\sum_{i\ge 1}\frac{x^{Vi}}{i}$$

推导如下：

$$\begin{aligned}\ln F(x)=G(x)\\\frac{F'(x)}{F(x)}=G'(x)\\\frac{-Vx^{V-1}}{1-x^V}=G'(x)\\-\sum_{i\ge 0}Vx^{V-1+Vi}=G'(x)\\-\sum_{i \ge 0}\frac{Vx^{V+Vi}}{V+Vi}=G(x)\\-\sum_{i \ge 1}\frac{x^{Vi}}{i}=G(x)\end{aligned}$$


于是，统计每一个容量的物品个数，然后$O(m/V)$给对应的位置加上系数，这样总的复杂度是$O(n\log n)$的。

做完这一步相当于给每个封闭形式求$\ln$之后求完了和。

直接多项式$\exp$再多项式求逆之后还原多项式，输出答案即可。

提供我的大常数代码。
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define ll long long
#define RG register
#define MAX 277777
const int MOD=998244353;
const int Phi=MOD-1;
const int gr=3;
inline int read()
{
    RG int x=0,t=1;RG char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
int fpow(int a,int b)
{
    int s=1;
    while(b){if(b&1)s=1ll*s*a%MOD;a=1ll*a*a%MOD;b>>=1;}
    return s;
}
int r[MAX],N,l,M;
int Og[MAX];
void NTT(int *P,int opt,int n)
{
    for(N=1,l=0;N<n;N<<=1)++l;
    for(RG int i=0;i<N;++i)r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
    for(RG int i=0;i<N;++i)if(i<r[i])swap(P[i],P[r[i]]);
    for(RG int i=1;i<N;i<<=1)
    {
        RG int W=fpow(gr,Phi/(i<<1));Og[0]=1;
        for(RG int j=1;j<i;++j)Og[j]=1ll*Og[j-1]*W%MOD;
        for(RG int p=i<<1,j=0;j<N;j+=p)
            for(RG int k=0;k<i;++k)
            {
                RG int X=P[j+k],Y=1ll*Og[k]*P[i+j+k]%MOD;
                P[j+k]=(X+Y)%MOD;P[i+j+k]=(X+MOD-Y)%MOD;
            }
    }
    if(opt==-1)
    {
        reverse(&P[1],&P[N]);
        for(RG int i=0,inv=fpow(N,MOD-2);i<N;++i)P[i]=1ll*P[i]*inv%MOD;
    }
}
int inv[MAX];
void initinv(int N)
{
    inv[0]=inv[1]=1;
    for(RG int i=2;i<N;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
}
int A[MAX],B[MAX];
void Inv(int *a,int *b,int len)
{
    if(len==1){b[0]=fpow(a[0],MOD-2);return;}
    Inv(a,b,len>>1);
    for(RG int i=0;i<len;++i)A[i]=a[i],B[i]=b[i];
    NTT(A,1,len<<1);NTT(B,1,len<<1);
    for(RG int i=0;i<(len<<1);++i)A[i]=1ll*A[i]*B[i]%MOD*B[i]%MOD;
    NTT(A,-1,len<<1);
    for(RG int i=0;i<len;++i)b[i]=(b[i]+b[i])%MOD;
    for(RG int i=0;i<len;++i)b[i]=(b[i]+MOD-A[i])%MOD;
    for(RG int i=0;i<(len<<1);++i)A[i]=B[i]=0;
}
int C[MAX],D[MAX];
void Dao(int *a,int *b,int len)
{
    for(RG int i=1;i<len;++i)b[i-1]=1ll*i*a[i]%MOD;
    b[len]=b[len-1]=0;
}
void Jifen(int *a,int *b,int len)
{
    for(RG int i=1;i<len;++i)b[i]=1ll*a[i-1]*inv[i]%MOD;
    b[0]=0;
}
void Getln(int *a,int *b,int len)
{
    int A[MAX],B[MAX];
    memset(A,0,sizeof(A));memset(B,0,sizeof(B));
    Dao(a,A,len);
    Inv(a,B,len);
    NTT(A,1,len<<1);NTT(B,1,len<<1);
    for(RG int i=0;i<(len<<1);++i)A[i]=1ll*A[i]*B[i]%MOD;
    NTT(A,-1,len<<1);
    Jifen(A,b,len);
    for(RG int i=0;i<(len<<1);++i)A[i]=B[i]=0;
}
int E[MAX];
void Exp(int *a,int *b,int len)
{
    if(len==1){b[0]=1;return;}
    Exp(a,b,len>>1);
    for(RG int i=0;i<len;++i)D[i]=b[i];
    Getln(b,E,len);
    for(RG int i=0;i<len;++i)E[i]=(MOD-E[i]+a[i])%MOD;E[0]=(E[0]+1)%MOD;
    NTT(E,1,len<<1);NTT(D,1,len<<1);
    for(RG int i=0;i<(len<<1);++i)D[i]=1ll*D[i]*E[i]%MOD;
    NTT(D,-1,len<<1);
    for(RG int i=0;i<len;++i)b[i]=D[i];
    for(RG int i=0;i<(len<<1);++i)D[i]=E[i]=0;
}
void FastPow(int *a,int *b,int K,int len)
{
    int E[MAX];memset(E,0,sizeof(E));
    Getln(a,E,len);
    for(RG int i=0;i<len;++i)E[i]=1ll*K*E[i]%MOD;
    Exp(E,b,len);
}
int X[MAX],Y[MAX];
int n,K,TT[MAX],m;
int main()
{
    n=read();m=read();
    for(int i=1;i<=n;++i)TT[read()]++;
    int N;for(N=1;N<=m;N<<=1);initinv(N);
    for(int i=1;i<=m;++i)
        if(TT[i])
            for(int j=i;j<N;j+=i)
                X[j]=(X[j]+1ll*TT[i]*(MOD-inv[j/i]))%MOD;
    Exp(X,Y,N);memset(X,0,sizeof(X));Inv(Y,X,N);
    for(int i=1;i<=m;++i)printf("%d\n",X[i]);
    return 0;
}

```

---

## 作者：Simphoni (赞：29)

## Description
有$n(n\le 10^5)$种物品,第$i$种物品体积为$V_i$,数量为无穷多.对于$1\le v\le m(m\le 10^5)$求出从这些物品种选出一些物品体积和为$v$的方案数.
## Idea
首先一个大小为$v$的物品的选取方式可以表示为$f(x)=\sum_{i\ge 0}[i\equiv 0\pmod v]x^i=\sum_{i\ge 0}x^{vi}=\frac{1}{1-x^v}$,然而暴力将每一个多项式乘起来复杂度是$O(NMlogM)$,无法承受.  
考虑通过将这些多项式取对数后全部加起来,最后多项式exp回去.  
$ln(f(x))=g(x)$  
$g'(x)=\frac{f'(x)}{f(x)}=(1-x^v)\sum_{i\ge 1}vi\cdot x^{vi-1} =\sum_{i\ge 1}v\cdot x^{vi-1}$  
$g(x)=\sum_{i\ge 1}\frac{v}{v\cdot i}\cdot x^{v\cdot i}$.  
这样体积为$v$的物品的函数中有$n\over v$项,加法上的复杂度是$O(NlogN)$,exp的复杂度是$O(NlogN)$.如果用分治求exp,则复杂度$O(Nlog^2N)$.
## [Code](https://github.com/TheUnbeatable/Packup_Logdown/blob/master/Codes/LuoguP4389.cpp)

---

## 作者：小粉兔 (赞：28)

在博客园食用更佳：[https://www.cnblogs.com/PinkRabbit/p/10423084.html](https://www.cnblogs.com/PinkRabbit/p/10423084.html)。

### 题意简述：

有 $n$ 个物品，每个物品都有无限多，第 $i$ 个物品的体积为 $v_i$（$v_i\le m$）。

问用这些物品恰好装满容量为 $i$ 的背包的方案数，两个方案不同当且仅当存在某一个物品的选取数量不同。

你需要对 $i\in [1,m]$ 回答，答案对 $998,244,353$ 取模。

### 题解：

对于一个体积为 $v$ 的物品，它装满容量为 $x$ 的背包的方案数序列为 $a_x=[v|x]$。

例如 $v=3$ 时有序列（从 $0$ 开始）：$\{1,0,0,1,0,0,1,0,0,1,0,\cdots\}$。

它的普通生成函数为 $\frac{1}{1-x^v}$。

记答案的普通生成函数为 $F$，则有 $F=\prod_{i=1}^{n}\frac{1}{1-x^{v_i}}$。

两边取对数：$\ln F=\sum_{i=1}^{n}\ln\frac{1}{1-x^{v_i}}$。

有一个式子：$\ln\frac{1}{1-x^k}=\sum_{i=1}^{\infty}\frac{1}{i}x^{ik}$。

这个式子的证明：

记 $f(x)=\frac{1}{1-x^k}$，设 $g(x)=\ln f$。

$$\begin{aligned}g(x)&=\ln f(x)\\&=\int(\frac{\mathrm{d}}{\mathrm{d}x}\ln f)(x)\mathrm{d}x\\&=\int(\frac{f'(x)}{f(x)})\mathrm{d}x\\&=\int((1-x^k)f'(x))\mathrm{d}x\\&=\int((1-x^k)\sum_{i=1}^{\infty}k\cdot i\cdot x^{ki-1})\mathrm{d}x\\&=\int(\sum_{i=1}^{\infty}k\cdot i\cdot x^{ki-1}-\sum_{i=1}^{\infty}k\cdot i\cdot x^{ki-1}\cdot x^k)\mathrm{d}x\\&=\int(\sum_{i=1}^{\infty}k\cdot i\cdot x^{ki-1}-\sum_{i=1}^{\infty}k\cdot (i-1)\cdot x^{ki-1})\mathrm{d}x\\&=\int(\sum_{i=1}^{\infty}k\cdot x^{ki-1})\mathrm{d}x\\&=\sum_{i=1}^{\infty}\frac{1}{i}x^{ki}\end{aligned}$$

建议背一些常用式子。

那么就显而易见了：

$$\begin{aligned}\ln F&=\sum_{i=1}^{n}\sum_{j=1}^{\infty}\frac{1}{j}x^{v_{i}j}\\&=\sum_{k=1}^{m}\sum_{j=1}^{\infty}\frac{\sum_{i=1}^{n}[v_i=k]}{j}x^{kj}\end{aligned}$$

记 $b_k$ 为体积为 $k$ 的物品数量，并且我们只需要次数小于等于 $m$ 的项，有 $\ln F\equiv \sum_{k=1}^{m}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}\frac{b_k}{j}x^{kj}\pmod{x^{m+1}}$。

右边可以在 $\sum_{i=1}^{m}\frac{m}{i}=O(m\ln m)$ 的时间内得到，左边使用多项式 $\mathrm{Exp}$ 在 $O(m\log m)$ 的时间内得到，总时间复杂度 $O(m\log m)$。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

typedef long long LL;
const int Mod = 998244353;
const int G = 3, iG = 332748118;
const int MS = 1 << 19 | 7;

inline LL qPow(LL b, int e) {
	LL a = 1;
	for (; e; e >>= 1, b = b * b % Mod)
		if (e & 1) a = a * b % Mod;
	return a;
}

LL Inv[MS];

inline void Init(int N) {
	Inv[1] = 1;
	for (int i = 2; i < N; ++i) Inv[i] = -(Mod / i) * Inv[Mod % i] % Mod;
}

int Sz, R[MS]; LL InvSz;

inline void InitFNTT(int N) {
	int Bt = 0;
	for (; 1 << Bt < N; ++Bt) ;
	if (Sz == (1 << Bt)) return ;
	Sz = 1 << Bt; InvSz = -(Mod - 1) / Sz;
	for (int i = 1; i < Sz; ++i) R[i] = R[i >> 1] >> 1 | (i & 1) << (Bt - 1);
}

inline void FNTT(LL *A, int Ty) {
	for (int i = 0; i < Sz; ++i) if (R[i] < i) std::swap(A[R[i]], A[i]);
	for (int j = 1, j2 = 2; j < Sz; j <<= 1, j2 <<= 1) {
		LL gn = qPow(~Ty ? G : iG, (Mod - 1) / j2), g, X, Y;
		for (int i = 0, k; i < Sz; i += j2) {
			for (k = 0, g = 1; k < j; ++k, g = g * gn % Mod) {
				X = A[i + k], Y = g * A[i + j + k] % Mod;
				A[i + k] = (X + Y) % Mod, A[i + j + k] = (X - Y) % Mod;
			}
		}
	}
	if (!~Ty) for (int i = 0; i < Sz; ++i) A[i] = A[i] * InvSz % Mod;
}

inline void PolyInv(LL *A, int N, LL *B) {
	static LL tA[MS], tB[MS];
	B[0] = qPow(A[0], Mod - 2);
	for (int L = 1; L < N; L <<= 1) {
		int L2 = L << 1, L4 = L << 2;
		InitFNTT(L4);
		memcpy(tA, A, 8 * L2);
		memset(tA + L2, 0, 8 * (Sz - L2));
		memcpy(tB, B, 8 * L);
		memset(tB + L, 0, 8 * (Sz - L));
		FNTT(tA, 1), FNTT(tB, 1);
		for (int i = 0; i < Sz; ++i) tB[i] = (2 - tB[i] * tA[i]) % Mod * tB[i] % Mod;
		FNTT(tB, -1);
		for (int i = 0; i < L2; ++i) B[i] = tB[i];
	}
}

inline void PolyLn(LL *A, int N, LL *B) {
	static LL tA[MS], tB[MS];
	PolyInv(A, N - 1, tB);
	InitFNTT(N * 2 - 3);
	for (int i = 1; i < N; ++i) tA[i - 1] = i * A[i] % Mod;
	memset(tA + N - 1, 0, 8 * (Sz - N + 1));
	memset(tB + N - 1, 0, 8 * (Sz - N + 1));
	FNTT(tA, 1), FNTT(tB, 1);
	for (int i = 0; i < Sz; ++i) tA[i] = tA[i] * tB[i] % Mod;
	FNTT(tA, -1);
	B[0] = 0;
	for (int i = 1; i < N; ++i) B[i] = tA[i - 1] * Inv[i] % Mod;
}

inline void PolyExp(LL *A, int N, LL *B) {
	static LL tA[MS], tB[MS];
	B[0] = 1;
	for (int L = 1; L < N; L <<= 1) {
		int L2 = L << 1, L4 = L << 2;
		memset(B + L, 0, 8 * (L2 - L));
		PolyLn(B, L2, tB);
		InitFNTT(L4);
		memcpy(tA, B, 8 * L);
		memset(tA + L, 0, 8 * (Sz - L));
		for (int i = 0; i < L2; ++i) tB[i] = ((!i) - tB[i] + A[i]) % Mod;
		memset(tB + L2, 0, 8 * (Sz - L2));
		FNTT(tA, 1), FNTT(tB, 1);
		for (int i = 0; i < Sz; ++i) tA[i] = tA[i] * tB[i] % Mod;
		FNTT(tA, -1);
		for (int i = 0; i < L2; ++i) B[i] = tA[i];
	}
}

int N, M;
int buk[MS];
LL A[MS], B[MS];

int main() {
	scanf("%d%d", &N, &M);
	Init(MS);
	for (int i = 1, v; i <= N; ++i) scanf("%d", &v), ++buk[v];
	for (int i = 1; i <= M; ++i) if (buk[i]) {
		for (int j = 1; j <= M / i; ++j) {
			A[i * j] = (A[i * j] + buk[i] * Inv[j]) % Mod;
		}
	}
	PolyExp(A, M + 1, B);
	for (int i = 1; i <= M; ++i) printf("%lld\n", (B[i] + Mod) % Mod);
	return 0;
}
```

---

## 作者：Nemlit (赞：11)

~~貌似前年初中教练把这题丢到基础背包练习题当作业来着~~

首先我们对于每一个物品写出他的生成函数$S(x)$，对于一个体积为$V_i$的物品，我们有$S(x) = \sum_{j\%V_i=0}x^j$

$$S(x)=\sum_{j=0}^{\infty}x^{V_i\times j}, x^{V_i}\times S(x)=\sum_{j=1}^{\infty}x^{V_i\times j}$$

$S(x)-x^{V_i}\times S(x)=x^0=1$，所以我们有：$S(x)=\dfrac{1}{1-x^{V_i}}$

于是我们可以快乐的把所有生成函数求逆之后卷在一起，复杂度为$O(NMlogN)$

考虑优化，我们注意到：$e^{ln(S(x))}=S(x)$，这个看起来很无聊的柿子确实解题的关键，因为他把乘号变成了加号，多项式加法我们有很优秀的$O(N)$复杂度，并且看起来很好进一步优化

于是我们可以吧所有生成函数取$ln$，然后全部加起来，$exp$回去即可。

现在来考虑怎么求$ln(\dfrac{1}{1-x^{V_i}})$。根据一般套路，我们先求导：

令$G(x)=ln(\dfrac{1}{1-x^{V_i}})$，则$G'(x)=ln'(\dfrac{1}{1-x^{V_i}})$

根据对数函数的性质，我们有$ln(x^c)=c\times  ln(x)$，带入得：$G'(x)=-ln'(1-x^{V_i})=(\dfrac{V_i\times x^{V_i-1}}{1-x^{V_i}})=S(x)\times V_i\times x^{V_i-1}=V_i\times \sum_{j=0}^{\infty}x^{V_i\times j+V_i-1}$

再来把这个柿子积分回去，我们有：$G(x)=\int G'(x)=V_i\times \sum_{j=0}^{\infty}\dfrac{x^{V_i\times j+V_i}}{V_i\times j+V_i}=\sum_{j=0}^{\infty}\dfrac{x^{V_i\times j+V_i}}{j+1}=\sum_{j=1}^{\infty}\dfrac{x^{V_i\times j}}{j}$

所以我们现在的任务变成了，求出所有$\sum_{j=1}^{\infty}\dfrac{x^{V_i\times j}}{j}$的和，再进行$exp$

求和用调和级数可以保证复杂度$\rm O(NlogN)$，所以总复杂度是$\rm O(NlogN)$
### $\rm Code:$
```cpp
/* This code is written by Nemlit */
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define rep(i, a, b) for(re int i = (a); i <= (b); ++ i)
#define mod 998244353
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
il int Mul(int a, int b) { return 1ll * a * b % mod; }
il int Inc(int a, int b) { return (a += b) >= mod ? a - mod : a; }
il int Dec(int a, int b) { return (a -= b) < 0 ? a + mod : a; }
il int qpow(int a, int b) { int r = 1; while(b) { if(b & 1) r = Mul(r, a); a = Mul(a, a), b >>= 1; } return r; }
#define maxn 800005
int n, m, a[maxn], r[maxn], h[maxn], f[maxn], g[maxn], p[maxn], w[maxn], lim, l, invG, G, cnt[maxn], pax, inv[maxn];
il void NTT(int *a, int opt, int lim) {
	rep(i, 0, lim - 1) if(i > r[i]) swap(a[i], a[r[i]]);
	w[0] = 1;
	for(re int mid = 1; mid < lim; mid <<= 1) {
		int base = qpow(opt == 1 ? G : invG, (mod - 1) / (mid << 1));
		rep(j, 1, mid - 1) w[j] = Mul(w[j - 1], base);
		for(re int j = 0; j < lim; j += mid << 1) {
			rep(k, 0, mid - 1) {
				int x = a[j + k], y = Mul(w[k], a[j + k + mid]);
				a[j + k] = Inc(x, y), a[j + k + mid] = Dec(x, y);
			}
		}
	}
	if(opt == -1) rep(i, 0, lim - 1) a[i] = Mul(a[i], inv[lim]);
}
il void Inv(int *a, int *b, int n) {
	rep(i, 0, n * 4) b[i] = h[i] = 0;
	b[0] = qpow(a[0], mod - 2);
	int k = 1, lim = 2, l = 1;
	while(k <= n) {
		k <<= 1, lim <<= 1, ++ l;
		rep(i, 0, k - 1) h[i] = a[i];
		rep(i, 0, lim - 1) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
		NTT(h, 1, lim), NTT(b, 1, lim);
		rep(i, 0, lim - 1) b[i] = Dec(Mul(2, b[i]), Mul(Mul(b[i], b[i]), h[i]));
		NTT(b, -1, lim);
		rep(i, k, lim) b[i] = 0;
	}
}
il void ln(int *a, int *b, int n) {
	rep(i, 0, n * 2) b[i] = f[i] = 0;
	rep(i, 1, n - 1) b[i - 1] = Mul(a[i], i);
	Inv(a, f, n);
	int lim = 1, l = 0;
	while(lim <= n * 2) lim <<= 1, ++ l;
	rep(i, 0, lim - 1) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
	NTT(f, 1, lim), NTT(b, 1, lim);
	rep(i, 0, lim - 1) f[i] = Mul(b[i], f[i]);
	NTT(f, -1, lim), b[0] = 0;
	rep(i, 0, n - 2) b[i + 1] = Mul(f[i], inv[i + 1]);
	rep(i, n, lim - 1) b[i] = 0;
}
il void Exp(int *a, int *b, int n) {
	rep(i, 0, n * 4) b[i] = g[i] = p[i] = 0;
	int k = 1, lim = 2, l = 1;
	b[0] = 1;
	while(k <= n) {
		k <<= 1, lim <<= 1, ++ l;
		ln(b, g, k);
		rep(i, 0, k - 1) g[i] = Dec(a[i], g[i]);
		g[0] = Inc(g[0], 1);
		rep(i, 0, lim - 1) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
		NTT(b, 1, lim), NTT(g, 1, lim);
		rep(i, 0, lim - 1) b[i] = Mul(b[i], g[i]);
		NTT(b, -1, lim);
		rep(i, k, lim - 1) b[i] = 0;
	}
}
signed main() {
	n = read(), m = read(), G = 3, invG = qpow(G, mod - 2), inv[1] = 1;
	rep(i, 2, 800000) inv[i] = Mul(inv[mod % i], (mod - mod / i));
	rep(i, 0, n - 1) pax = read(), ++ cnt[pax];
	rep(i, 1, m) {
		if(!cnt[i]) continue;
		for(re int j = i; j <= m; j += i) a[j] = Inc(a[j], Mul(cnt[i], inv[j / i]));
	}
	Exp(a, p, m);
	rep(i, 1, m) printf("%d\n", p[i]);
	return 0;
}
```

---

## 作者：command_block (赞：11)

前置芝士：[NTT与多项式全家桶](https://www.luogu.org/blog/command-block/ntt-yu-duo-xiang-shi-quan-jia-tong)+生成函数OGF+(无标号计数)

这道题好像是WC2019讲义上的经典例题?

大家都直接`OGF`然后丢式子,我觉得不太友好,实际上这是一道Euler无标号计数的**模板**题。

先讲一讲这题为啥是无标号计数。

设$C[i]$为大小为$i$的物品个数,相当于我们有$C[i]$种方案得到一个大小为$i$的元素。

随后,我们要选取若干个元素使得他们的大小和为$m$,元素之间无顺序之分。

这不就是背包问题吗?所以背包问题是最经典的无标号计数。

------------

- `EGF`的 $\exp$

大家都知道,如果是有标号计数,选用`EGF`的话:
 
我们得到了单个元素的`EGF`,只要`EXP`一下就能得到这些元素生成的集合的`EGF`,这个可以泰勒展开然后观察式子。

有$\exp(F(x))=\sum\limits_{i=0}\dfrac{F(x)^i}{i!}$

注意$\dfrac{F(x)^i}{i!}$的意义 : 选择$i$个元素映射到标号上,但他们之间没有关联,顺序不用考虑。

现在是无标号计数,我们自然也想要优美的变换啦。

无标号计数中,如果两个元素大小相同且内部相同,则无法区分。

也就是说,我们考虑单独的$F[i]$,其贡献为 : $(1+x^i+x^{2i}+...)^{F[i]}$

意思就是对大小为$i$的每种方案分别建立`OGF`然后乘起来。

我们就得到了Euler变换:

$$Euler(F(x))=\prod\limits_{i=0}\Big(\dfrac{1}{1-x^i}\Big)^{F[i]}$$

那么问题来了,怎么计算这个东西?

容易想到 $\ln$ 之后变为加法,再 $\exp$ ,则有:

$$\exp\sum\limits_{i=0}\ln\Big(\dfrac{1}{1-x^i}\Big)^{F[i]}$$

- $\ln\Big(\dfrac{1}{1-x^p}\Big)^{c}$

  考虑$\ln(x^c)=c·\ln x$,次数$c$我们就暂且按下不表。
  
  先来搞$\frac{1}{1-x}$,这东西的展开是$\{1,1,1,1,1...\}$
  
  众所周知 $\ln A(x)=∫(\frac{A'(x)}{A(x)})$
  
  先对这东西求导,得到$\{1,2,3,4,5...\}=\dfrac{1}{(1-x)^2}$
  
  然后求逆,是$1-x$,乘在一起又回到了$\frac{1}{1-x}$
  
  然后是积分,得到$\{0,1,\frac{1}{2},\frac{1}{3},\frac{1}{4},...\}$
  
  也就是$\ln \frac{1}{1-x}=\sum\limits_{i=1}\dfrac{x}{i}$
  
  现在用$x^p$替换$x$得到$\ln \frac{1}{1-x^p}=\sum\limits_{i=1}\dfrac{x^{ip}}{i}$
  
  在$\!\pmod{x^n}$下也就$n/p$个有效项。
  
给出一个比较方便化简的中间结果 : $Euler(F(x))=\exp\sum\limits_{i=0}-F[i]*\ln(1-x^i)$
  
对于每个$p$暴力求和复杂度是$O(\sum_{i=1}^n\frac{n}{i})=O(nlogn)$的,随后`EXP`即可。

这题就是直接计算$Euler(C(x))$,非常的模板啊。

**Code:**

```cpp
// luogu-judger-enable-o2
#include<algorithm>
#include<cstdio>
#define mod 998244353
#define G 3
#define Maxn 100500
using namespace std;
inline int read()
{
  register int X=0;
  register char ch=0;
  while(ch<48||ch>57)ch=getchar();
  while(ch>=48&&ch<=57)X=X*10+(ch^48),ch=getchar();
  return X;
}
int n,m,r[Maxn<<2],invn,invG;
long long powM(long long a,long long t=mod-2)
{
  long long ans=1,buf=a;
  while(t){
  	if(t&1)ans=(ans*buf)%mod;
  	buf=(buf*buf)%mod;
  	t>>=1;
  }return ans;
}
void NTT(long long *f,int n,short op)
{
  for (int i=0;i<n;i++)
   if (r[i]<i)swap(f[r[i]],f[i]);
  for (int p=2;p<=n;p<<=1){
  	int len=p>>1,
  	    w=powM(op==1 ?G:invG,(mod-1)/p);
  	for (int k=0;k<n;k+=p){
  	  long long buf=1;
  	  for (int i=k;i<k+len;i++){
  	  	int sav=f[len+i]*buf%mod;
  	  	f[len+i]=(f[i]-sav+mod)%mod;
  	  	f[i]=(f[i]+sav)%mod;
  	  	buf=buf*w%mod;
  	  }
    }
  }
}
long long _g[Maxn<<2];
void times(long long *f,long long *gg,int len1,int len2,int limit)
{
  int n=1;
  for(;n<len1+len2;n<<=1);
  long long *g=_g;
  for (int i=0;i<len2;i++)g[i]=gg[i];
  for (int i=len2;i<n;i++)g[i]=0;
  invn=powM(n);
  for(int i=0;i<n;i++)
   r[i]=(r[i>>1]>>1)|((i&1)?n>>1:0);
  NTT(f,n,1);NTT(g,n,1);
  for(int i=0;i<n;++i)f[i]=(f[i]*g[i])%mod;
  NTT(f,n,-1);
  for(int i=0;i<limit;++i)f[i]=f[i]*invn%mod;
  for(int i=limit;i<n;++i)f[i]=0;
}
long long _r[Maxn<<2],_rr[Maxn<<2];
void invp(long long *f,int plen)
{
  long long *r=_r,*rr=_rr;
  int n=1;for(;n<plen;n<<=1);
  rr[0]=powM(f[0]);
  for (int len=2;len<=n;len<<=1){
  	for (int i=0;i<len;i++)
  	  r[i]=rr[i]*2%mod;
  	times(rr,rr,len/2,len/2,len);
  	times(rr,f,len,len,len);
  	for (int i=0;i<len;i++)
  	  rr[i]=(r[i]-rr[i]+mod)%mod;
  }for (int i=0;i<plen;i++)
    f[i]=rr[i];
  for (int i=0;i<n;i++)rr[i]=r[i]=0;
}
void dao(long long *f,int m)
{
  for (int i=1;i<m;i++)
   f[i-1]=f[i]*i%mod;
  f[m-1]=0;
}
void jifen(long long *f,int m)
{
  for (int i=m;i;i--)
   f[i]=f[i-1]*powM(i)%mod;
  f[0]=0;
}
long long _lns[Maxn<<2];
void lnp(long long *f,int m)
{
  long long *sav=_lns;
  for (int i=0;i<m;i++)sav[i]=f[i];
  invp(sav,m);dao(f,m);
  times(f,sav,m-1,m,m);
  jifen(f,m-1);
  for (int i=0;i<m;i++)sav[i]=0;
}
long long _xp[Maxn<<2],_xp2[Maxn<<2];
void exp(long long *f,int m)
{
  long long *s=_xp,*ss=_xp2;
  int n=1;for(;n<m;n<<=1);
  ss[0]=1;
  for (int len=2;len<=n;len<<=1){
  	for (int i=0;i<len/2;i++)s[i]=ss[i];
  	for (int i=len/2;i<len;i++)s[i]=0;
  	lnp(s,len);
  	for (int i=0;i<len;i++)
  	 s[i]=(f[i]-s[i]+mod)%mod;
  	s[0]=(s[0]+1)%mod;
  	times(ss,s,len/2,len,len);
  }for (int i=0;i<m;i++)f[i]=ss[i];
  for (int i=0;i<n;i++)s[i]=ss[i]=0;
}
long long f[Maxn<<2],inv[Maxn];
int c[Maxn];
int main()
{
  invG=powM(G);
  scanf("%d%d",&n,&m);m++;
  for (int i=0;i<n;i++)c[read()]++;
  inv[0]=inv[1]=1;
  for (int i=2;i<m;i++)
	inv[i]=(mod-mod/i)*inv[mod%i]%mod;
  for (int i=0;i<m;i++)
   if (c[i])
	for (int j=i;j<m;j+=i)
	 f[j]=(f[j]+inv[j/i]*c[i])%mod;
  exp(f,m);
  for (int i=1;i<m;i++)
    printf("%lld\n",f[i]);
  return 0;
}
```

- **附** : $Eular(F(x))=\exp\bigg(\sum\limits_{i=1}\dfrac{F(x^i)}{i}\bigg)$

其实就是这道题的正解人话换成了公式。

$$Eular(F(x))=\exp\sum\limits_{i=0}\ln\Big(\dfrac{1}{1-x^i}\Big)^{F[i]}$$

$$=\exp\sum\limits_{i=0}F[i]\sum\limits_{j=1}\dfrac{x^{ij}}{j}$$

$$=\exp\sum\limits_{j=1}\frac{1}{j}\sum\limits_{i=0}F[i]x^{ij}$$

$$=\exp\bigg(\sum\limits_{i=1}\frac{F(x^i)}{i}\bigg)$$

更多技巧请见[Link](https://www.luogu.com.cn/blog/command-block/post-shuo-xue-ji-lu-p5900-wu-biao-hao-wu-gen-shu-ji-shuo)

---

## 作者：longlongzhu123 (赞：8)

UPD：修了锅掉的图

>   Github 博客原文链接 [[Link↗]](https://longlongzhu123.github.io/sol-luogu-P4389/)

生成函数经典入门题！

## 前置知识

1.  $\displaystyle \sum _ {i = 0} ^ {\infty} x ^ i = \dfrac {1} {1 - x}$ [[Link↗]](https://longlongzhu123.github.io/math-notes/#note-3)

## 当 n = 2 时……

设 $A[i]$ 表示仅用第一种物品装满 $i$ 体积的方案数，显然 $A[i] = [v _ 1 \bmod i = 0]$。

设 $B[i]$ 表示仅用第二种物品装满 $i$ 体积的方案数，显然 $B[i] = [v _ 2 \bmod i = 0]$。

直接上 DP。设 $C[i]$ 为结果，即任意使用第一种或第二种物品，装满 $i$ 体积的方案数。DP 方程为：

$$C[i] = \displaystyle \sum _ {j + k = i} A[j] B[k] (i \le m)$$

朴素算法需要 $O(m ^ 2)$ 的时间。不过相信来这里的读者很轻松能看出来：这是个卷积的形式。

## 生成函数

设 $F(x) = 1 + x ^ {v _ 1} + x ^ {2 v _ 1} + \cdots$，即 $\displaystyle \sum _ {i = 0} ^ {\infty} x ^ {i v _ 1}$。

设 $G(x) = 1 + x ^ {v _ 2} + x ^ {2 v _ 2} + \cdots$，即 $\displaystyle \sum _ {i = 0} ^ {\infty} x ^ {i v _ 2}$。

这是把上面的卷积写成多项式形式之后的结果。

用 FFT 将两个多项式相乘，新多项式的系数刚好就是 DP 的答案。这相当于完成了一次卷积。

当然，别看式子的项数是 $\infty$，实际上我们只需要用到前 $m$ 项（把 $m$ 之后的项砍掉即可）。

这一步我们用 FFT 优化了一个特殊的 DP 方程，时间复杂度 $O(m \log m)$。

## 当 n 更大时……

上面的方法还行得通吗？

分别给 $n$ 个物品造一条多项式（$F(x), G(x), \dots$），长度都要是 $m$。耗时 $O(nm)$

逐一相乘，每次耗时 $O(m \log m)$，总共 $n$ 次乘法。总时间 $O(nm \log m)$。

别忘了 $n, m \le 10 ^ 5$……拿个 30pts 还是可以的（狗头），总比直接 DP $O(nm ^ 2)$ 强（

```
for i = 1 to n:
    for j = 0 to m, j += v[i]:
        f[i][j] += 1
ans = Poly()
for i = 1 to n:
    ans = ans * f[i] // O(m log m)
print(ans, i = 1 to m)
```

## 干嘛要相乘？

全部取 $\ln$，**加起来**，再 $\exp$ 回去。只用两次 FFT。不用一条一条相乘了。

瓶颈仍在造式子的 $O(nm)$ 上，同时相加起来也要 $O(nm)$ 时间

## 利用函数的性质

设第 $i$ 种物品的体积是 $v$，令其生成函数为 $F(x)$。

则 $F(x) = 1 + x ^ {v} + x ^ {2v} + x ^ {3v} + \cdots$

不用管 $x$ 的取值范围，我们可以只关注系数。因此我们可以大胆地令 $|x| < 1$。

$$\begin {aligned}    F(x) & = 1 + x ^ {v} + x ^ {2v} + x ^ {3v} + \cdots \\         & = 1 + (x ^ v) + (x ^ v) ^ 2 + (x ^ v) ^ 3 + \cdots \\         & = \dfrac {1} {1 - x ^ v}\end {aligned}$$

生成函数的取值是没有意义的，它的核心在于系数的变换。

## 我们要干什么？

对这 $n$ 个 $\dfrac {1} {1 - x ^ v}$ 取一遍 $\ln$，加起来，$\exp$。

## 求这个分式的 Ln

$$\begin {aligned}    \ln \dfrac {1} {1 - x ^ v} & = \ln 1 - \ln (1 - x ^ v) \\                               & = 0 - \ln (1 - x ^ v)\end {aligned}$$

诶等等……$\ln (1 - x ^ v)$ 怎么算呢？

## 大胆猜想，~~不用求证~~

别忘了我们是 OIer，可以借助程序来找找规律啊。

拷个 $\ln$ 板子来玩玩

```cpp
int main() {
  cin >> n >> v;
  a[0] = 1; a[v] = -1; // 表示函数：F(x) = 1 - x ^ v
  lim = 1;
  while (lim < n) lim <<= 1;
  Log(a, lim);
  for (int i = 0; i < lim; ++i)
    cout << a[i] << ' ';
  cout << endl;
  return 0;
}
```

试试运行结果？

![](https://i.loli.net/2020/03/29/GrCmbvS2cfjQZlN.png)

首先找到一个规律：数字只在 $v, 2v, 3v, \cdots$ 这些位置出现。

对数字敏感点吧。很明显，第 $v$ 位上的数字 $998244352 \equiv -1 \pmod {998244353}$。

那第 $2v$ 位上的 $499122176$ 是什么呢？注意到这个数字差不多是 $998244353$ 的一半。

![](https://i.loli.net/2020/03/30/5swyjbhGAlBeEZJ.png)

所以 $499122176 \equiv -\dfrac {1} {2}$

![](https://i.loli.net/2020/03/30/4WarUEQVKjsz98Y.png)

所以第 $3v$ 位上的 $665492635 \equiv -\dfrac {1} {3}$

可以继续验证第 $4v$ 位上的 $249561088 \equiv -\dfrac {1} {4}$。

大胆猜想：$\ln (1 - x ^ v) = \displaystyle \sum _ {i = 1} ^ {\infty} - \dfrac {1} {i} x ^ {iv} = - \displaystyle \sum _ {i = 1} ^ {\infty} \dfrac {1} {i} x ^ {iv}$

## 严谨证明

设 $G(x) = \ln F(x) = \ln (1 - x ^ v)$

取导数，$G'(x) = \dfrac {F'(x)} {F(x)} = \dfrac {(1 - x ^ v)'} {1 - x ^ v} = \dfrac {- v x ^ {v - 1}} {1 - x ^ v} = - v x ^ {v - 1} \dfrac {1} {1 - x ^ v}$

注意到 $\dfrac {1} {1 - x ^ v} = \displaystyle \sum _ {i = 0} ^ {\infty} x ^ {iv}$。

$$\begin {aligned}    G'(x) &= - v x ^ {v - 1} \displaystyle \sum _ {i = 0} ^ {\infty} x ^ {iv} \\          &= \displaystyle \sum _ {i = 0} ^ {\infty} - v x ^ {iv + v - 1} \\          &= \displaystyle \sum _ {i = 0} ^ {\infty} - v x ^ {(i + 1)v - 1} \\          &= \displaystyle \sum _ {i = 1} ^ {\infty} - v x ^ {iv - 1} \\\end {aligned}$$

求导。$\displaystyle \int ax ^ k = \dfrac {1} {k + 1} a x ^ {k + 1}$ [[Link↗]](https://longlongzhu123.github.io/math-notes/#note-2)。因为 $G_0 = 0$，所以 $C = 0$。

$$\begin {aligned}    \int G'(x) &= \int \displaystyle \sum _ {i = 1} ^ {\infty} - v x ^ {iv - 1} \\               &= \displaystyle \sum _ {i = 1} ^ {\infty} \int - v x ^ {iv - 1} \\               &= \displaystyle \sum _ {i = 1} ^ {\infty} - \dfrac {1} {iv} v x ^ {iv} \\               &= \displaystyle \sum _ {i = 1} ^ {\infty} - \dfrac {1} {i} x ^ {iv} \\               &= - \displaystyle \sum _ {i = 1} ^ {\infty} \dfrac {1} {i} x ^ {iv}\end {aligned}$$

证毕。

## 求 Ln 完成

结论：$\ln \dfrac {1} {1 - x ^ v} = \ln 1 - \ln (1 - x ^ v) = 0 - \left ( -\displaystyle \sum _ {i = 1} ^ {\infty} \dfrac {1} {i} x ^ {iv} \right ) = \displaystyle \sum _ {i = 1} ^ {\infty} \dfrac {1} {i} x ^ {iv}$

当然上限 $\infty$ 也是取到 $m$ 就可以了。程序上，将所有 `a[k * v[i]]`（$k \cdot v[i] \le m$）的地方加上 $\dfrac {1} {k}$。

下一步要把它们全部加起来。

好像又遇到了个问题。初始化一条多项式的时间为 $O(\dfrac {m} {v})$，最多为 $O(m)$。而我们有 $n$ 条式子要处理……

解决方案是将所有 $v$ 相同的多项式一起处理。即 $\displaystyle \sum _ {i = 1} ^ {m} \dfrac {1} {i} x ^ {iv}$ 乘上 $\mathrm {cnt} [v]$ 倍。

总时间是调和级数级别的，复杂度为 $O(m \log m)$。加上 Exp 的 $O(m \log m)$，总复杂度为 $O(m \log m)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int kMaxN = 100000 * 8 + 10; // 开足空间！
const int kMod = 998244353;
const int kPri = 3;
const int kPriInv = 332748118;
inline LL Read() {
  int get = getchar();
  LL res = 0;
  while (!isdigit(get)) get = getchar();
  while (isdigit(get)) {
    res = res * 10 + get - '0';
    get = getchar();
  }
  return res;
}
inline LL Fpow(LL x, LL k) {
  LL ans = 1;
  for (; k; k >>= 1) {
    if (k & 1) ans = ans * x % kMod;
    x = x * x % kMod;
  }
  return ans;
}
inline LL Fadd(LL x, LL y) {
  return (x += y) >= kMod ? x - kMod : x;
}
inline LL Fdec(LL x, LL y) {
  return (x -= y) < 0 ? x + kMod : x;
}
inline void RaderSort(LL* a, int n) {
  int j = 0;
  for (int i = 0; i < n; ++i) {
    if (i < j) swap(a[i], a[j]);
    for (int l = (n >> 1); (j ^= l) < l; l >>= 1)
      continue;
  }
}
inline void Ntt(LL* a, int n, bool opt) {
  RaderSort(a, n);
  LL pri = opt ? kPri : kPriInv;
  for (int len = 2; len <= n; len <<= 1) {
    LL unit = Fpow(pri, (kMod - 1) / len);
    for (int i = 0; i < n; i += len) {
      LL w = 1;
      int mid = i + (len >> 1);
      for (int j = 0; j < (len >> 1); ++j) {
        LL tmp = w * a[mid + j] % kMod;
        a[mid + j] = Fdec(a[i + j], tmp);
        a[i + j] = Fadd(a[i + j], tmp);
        w = w * unit % kMod;
      }
    }
  }
  if (!opt) {
    LL inv = Fpow(n, kMod - 2);
    for (int i = 0; i < n; ++i)
      a[i] = a[i] * inv % kMod;
  }
}
LL inv_t[kMaxN];
inline void InvIter(LL* a, LL* b, int n) {
  int lim = (n << 1);
  fill(inv_t, inv_t + lim, 0);
  copy(a, a + n, inv_t);
  Ntt(inv_t, lim, true);
  Ntt(b, lim, true);
  for (int i = 0; i < lim; ++i)
    b[i] = Fdec(2, inv_t[i] * b[i] % kMod) * b[i] % kMod;
  Ntt(b, lim, false);
  fill(b + n, b + lim, 0);
}
inline void Inv(LL* a, LL* b, int n) {
  fill(b, b + n, 0);
  b[0] = Fpow(a[0], kMod - 2);
  for (int len = 2; len <= n; len <<= 1)
    InvIter(a, b, len);
}
inline void Deri(LL* a, int n) {
  for (int i = 0; i < n - 1; ++i)
    a[i] = (i + 1) * a[i + 1] % kMod;
  a[n - 1] = 0;
}
inline void Inte(LL* a, int n) {
  for (int i = n - 2; i >= 0; --i)
    a[i + 1] = a[i] * Fpow(i + 1, kMod - 2) % kMod;
  a[0] = 0;
}
LL log_t[kMaxN];
inline void Log(LL* a, int n) {
  int lim = (n << 1);
  fill(log_t, log_t + lim, 0);
  Inv(a, log_t, n);
  Deri(a, lim);
  fill(a + n, a + lim, 0);
  Ntt(a, lim, true);
  Ntt(log_t, lim, true);
  for (int i = 0; i < lim; ++i)
    a[i] = a[i] * log_t[i] % kMod;
  Ntt(a, lim, false);
  Inte(a, n);
  fill(a + n, a + lim, 0);
}
LL exp_t[kMaxN], exp_a[kMaxN]; // 总要记得清空临时数组！
inline void ExpIter(LL* a, LL* b, int n) {
  int lim = (n << 1);
  fill(exp_t, exp_t + lim, 0);
  copy(b, b + n, exp_t);
  Log(exp_t, n);
  for (int i = 0; i < n; ++i)
    exp_t[i] = Fdec(a[i], exp_t[i]);
  Ntt(b, lim, true);
  Ntt(exp_t, lim, true);
  for (int i = 0; i < lim; ++i)
    b[i] = b[i] * (exp_t[i] + 1) % kMod;
  Ntt(b, lim, false);
}
inline void Exp(LL* a, LL* b, int n) {
  fill(b, b + n, 0); // 总要记得清空输出数组！
  b[0] = 1;  // a[0] = 0, b[0] = e ^ a[0] = e ^ 0 = 1.
  for (int len = 2; len <= n; len <<= 1)
    ExpIter(a, b, len);
}
// n：商品数
// m：输出的数量
int n, m, lim;
LL v[kMaxN];
LL cnt[kMaxN];
LL a[kMaxN], b[kMaxN];
int main() {
  n = Read(), m = Read();
  // 注意：输出时要用 [1, m]！
  for (int i = 0; i < n; ++i) {
    v[i] = Read();
    ++cnt[v[i]];
  }
  // O(mlogm)
  for (int i = 1; i <= m; ++i) {
    if (cnt[i]) {
      int cur = 0;
      for (int j = i; j <= m; j += i) {
        ++cur;
        a[j] = (a[j] + Fpow(cur, kMod - 2) * cnt[i] % kMod) % kMod;
      }
    }
  }
  lim = 1;
  while (lim < m + 10) lim <<= 1;
  Exp(a, b, lim);
  for (int i = 1; i <= m; ++i)
    printf("%lld\n", b[i]);
  return 0;
}
```


---

## 作者：wangyuchen (赞：8)

## 解法

答案显然是$n$个形如$\sum_{i \geq 1} x^{vi}$的多项式的卷积

然而直接NTT的时间复杂度是$O(nm\log n)$

我们可以把每个多项式$k$求$\ln$然后相加， 在$\exp$回去

我们设$f(x) = \sum_{i \geq 1} x^{vi}$， $g(x) = \ln(f(x))$

我们知道$f(x) = \frac{1}{1-x^v}$

于是
$$g'(x) = \frac{f'(x)}{f(x)} = \frac{f'(x))}{\frac{1}{1-x^v}} = (1-x^v)f'(x) = (1-x^v)\sum_{i \geq 1} v\times i\times x^{vi-1} = \sum_{i \geq 1} v\times [i - (i-1)]\times x^{vi-1} = \sum_{i \geq 1} v\times x^{vi-1}$$

$$g(x) = \sum_{i \geq 1} \frac{1}{i}x^{vi}$$

再跑多项式$\exp$就行了

## 代码

```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 400010;

const LL mod = 998244353LL;

inline LL power(LL a, LL n, LL mod)
{	LL Ans = 1;
	while (n)
	{	if (n & 1) Ans = (Ans * a) % mod;
		a = (a * a) % mod;
		n >>= 1;
	}
	return Ans;
}

inline LL Plus(LL a, LL b) { return a + b > mod ? a + b - mod : a + b; }

inline LL Minus(LL a, LL b) { return a - b < 0 ? a - b + mod : a - b; }

struct Mul
{	int Len;

	int rev[N];

	LL wn[N];

	void getReverse()
	{	for (int i = 0; i < Len; i++)
			rev[i] = (rev[i>>1] >> 1) | ((i&1) * (Len >> 1));
	}

	void NTT(LL * a, int opt)
	{	getReverse();
		for (int i = 0; i < Len; i++)
			if (i < rev[i]) swap(a[i], a[rev[i]]);
		int cnt = 0;
		for (int i = 2; i <= Len; i <<= 1)
		{	cnt++;
			for (int j = 0; j < Len; j += i)
			{	LL w = 1;
				for (int k = 0; k < (i>>1); k++)
				{	LL x = a[j + k];
					LL y = (w * a[j + k + (i>>1)]) % mod;
					a[j + k] = Plus(x, y);
					a[j + k + (i>>1)] = Minus(x, y);
					w = (w * wn[cnt]) % mod;
				}
			}
		}
		if (opt == -1)
		{	reverse(a + 1, a + Len);
			LL num = power(Len, mod-2, mod);
			for (int i = 0; i < Len; i++)
				a[i] = (a[i] * num) % mod;
		}
	}

	void init()
	{	for (int i = 0; i < 23; i++)
			wn[i] = power(3LL, (mod-1) / (1 << i), mod);
	}

	void getLen(int l)
	{	Len = 1;
		for (; Len <= l; Len <<= 1);
	}
} Calc;

void cpy(LL * A, LL * B, int len1, int len2)
{	for (int i = 0; i < len1; i++) A[i] = B[i];
	for (int i = len1; i < len2; i++) A[i] = 0;
}

void getInv(LL * A, LL * B, int len)
{	static LL tmp1[N], tmp2[N];
	B[0] = power(A[0], mod-2, mod);
	for (register int i = 2; i <= len; i <<= 1)
	{	Calc.Len = i << 1;
		cpy(tmp1, A, i, Calc.Len);
		cpy(tmp2, B, i >> 1, Calc.Len);
		Calc.NTT(tmp1, 1);
		Calc.NTT(tmp2, 1);
		for (register int j = 0; j < Calc.Len; j++)
			tmp1[j] = Minus(Plus(tmp2[j], tmp2[j]), tmp2[j] * tmp2[j] % mod * tmp1[j] % mod);
		Calc.NTT(tmp1, -1);
		for (register int j = 0; j < i; j++)
			B[j] = tmp1[j];
	}
}

void getDeri(LL * a, int len)
{	for (int i = 0; i < len; i++)
		a[i] = a[i+1] * (LL) (i+1) % mod;
}

void getInte(LL * a, int len)
{	for (int i = len-1; i >= 1; i--)
		a[i] = a[i-1] * power(i, mod-2, mod) % mod;
	a[0] = 0;
}

void getLn(LL * A, int len)
{	static LL tmp1[N], tmp2[N], tmp3[N];
	Calc.Len = len << 1;
	cpy(tmp1, A, len, Calc.Len);
	cpy(tmp2, A, len, Calc.Len);
	getDeri(tmp1, len);
	getInv(tmp2, tmp3, len);
	Calc.Len = len << 1;
	Calc.NTT(tmp1, 1);
	Calc.NTT(tmp3, 1);
	for (int i = 0; i < Calc.Len; i++)
		tmp1[i] = tmp1[i] * tmp3[i] % mod;
	Calc.NTT(tmp1, -1);
	for (int i = len; i < Calc.Len; i++)
		tmp1[i] = 0;
	getInte(tmp1, len);
	for (int i = 0; i < len; i++)
		A[i] = tmp1[i];
}

void getExp(LL * A, LL * B, int len)
{	static LL tmp1[N], tmp2[N];
	B[0] = 1;
	for (int i = 2; i <= len; i <<= 1)
	{	Calc.Len = i << 1;
		cpy(tmp1, B, Calc.Len, Calc.Len);
		cpy(tmp2, B, Calc.Len, Calc.Len);
		getLn(tmp1, i);
		Calc.Len = i << 1;
		for (int j = 0; j < i; j++)
			tmp1[j] = Minus(A[j], tmp1[j]);
		tmp1[0]++;
		Calc.NTT(tmp1, 1);
		Calc.NTT(tmp2, 1);
		for (int j = 0; j < Calc.Len; j++)
			tmp1[j] = (tmp1[j] * tmp2[j]) % mod;
		Calc.NTT(tmp1, -1);
		for (int j = 0; j < Calc.Len; j++)
			B[j] = tmp1[j];
	}
}

LL A[N], B[N], Ans[N];

int cnt[N];

int v[N];

int main()
{	int n, m;
	scanf("%d %d", &n, &m);
	Calc.init();
	for (int i = 1; i <= n; i++)
	{	scanf("%d", &v[i]);
		cnt[v[i]]++;
	}
	Calc.init();
	Calc.getLen(m);
	int len = Calc.Len;
	for (int i = 1; i <= m; i++)
	{	if (!cnt[i]) continue;
		for (int j = i; j <= m; j += i)
			A[j] = Plus(A[j], (LL) cnt[i] * i % mod * power(j, mod-2, mod) % mod);
	}
	getExp(A, Ans, len);
	for (int i = 1; i <= m; i++)
		printf("%lld\n", Ans[i]);
	return 0;
}
```

---

## 作者：m256i (赞：4)

无标号 $\text{Multiset}$ 构造板子题。看到题解里没一个用泰勒展开做的，就自己写了一篇题解。

设第 $i$ 个物品的组合类为 $\mathcal{A}_i$。本题答案满足**组合积**定义，因此使用无标号计数，生成函数为 OGF。

显然第 $i$ 个物品的 OGF $A_i(x)=1+x^{v_i}+x^{2v_i}+\cdots=(x^{v_i})^0+(x^{v_i})^1+(x^{v_i})^2+\cdots=\dfrac{1}{1-x^{v_i}}$。

那么本题答案的 OGF 就是：

$$F(x)=\prod_{i=1}^nA_i(x)=\prod_{i=1}^n\dfrac{1}{1-x^{v_i}}$$

这玩意怎么化简？我们考虑先 $\ln$，把乘法化成加法，再 $\exp$ 回去：

$$
\begin{aligned}
F(x)&=\prod_{i=1}^n\dfrac{1}{1-x^{v_i}}\\
&=\exp\ln\prod_{i=1}^n\dfrac{1}{1-x^{v_i}}\\
&=\exp\sum_{i=1}^n\ln\dfrac{1}{1-x^{v_i}}\\
\end{aligned}
$$

$f(x)=\ln\dfrac{1}{1-x}$ 可以直接在零点处泰勒展开。

手玩一下可以发现：

$$
\begin{aligned}
f'(x)&=\dfrac{\mathrm d\ln(1-x)^{-1}}{\mathrm d(1-x)^{-1}}\dfrac{\mathrm d(1-x)^{-1}}{\mathrm d(1-x)}\dfrac{\mathrm d(1-x)}{\mathrm dx}\\
&=(1-x)(-1)(1-x)^{-2}(-1)\\
&=(1-x)^{-1}\\
f''(x)&=\dfrac{\mathrm d(1-x)^{-1}}{\mathrm d(1-x)}\dfrac{\mathrm d(1-x)}{\mathrm dx}\\
&=(-1)(1-x)^{-2}(-1)\\
&=(1-x)^{-2}\\
f'''(x)&=\dfrac{\mathrm d(1-x)^{-2}}{\mathrm d(1-x)}\dfrac{\mathrm d(1-x)}{\mathrm dx}\\
&=(-2)(1-x)^{-3}(-1)\\
&=2(1-x)^{-3}
\end{aligned}
$$

总结出一个规律：

$$f^{(k)}(x)=(k-1)!(1-x)^{-k},n>0$$

因此在零点处进行泰勒展开：

$$
\begin{aligned}
f(x)&=\sum_{k \ge 0}\dfrac{f^{(k)}(0)}{k!}x^k\\
&=\ln\dfrac{1}{1-0}+\sum_{k \ge 1}\dfrac{(k-1)!(1-0)^{-k}}{k!}x^k\\
&=\sum_{k \ge 1}\dfrac{(k-1)!}{k!}x^k\\
&=\sum_{k \ge 1}\dfrac{x^k}{k}
\end{aligned}
$$

代回到原式子里去：

$$
\begin{aligned}
F(x)&=\exp\sum_{i=1}^n\ln\dfrac{1}{1-x^{v_i}}\\
&=\exp\sum_{i=1}^nf(x^{v_i})\\
&=\exp\sum_{i=1}^n\sum_{k \ge 1}\dfrac{x^{kv_i}}{k}\\
&=\exp\sum_{i=1}^n\sum_{v_i \mid k}\dfrac{v_ix^k}{k}
\end{aligned}
$$

由于 $\exp F(x)\equiv\exp(F(x) \bmod x^m)\pmod{x^m}$，右边的和式计算到 $m$ 次即可。单次的时间复杂度是 $\Theta\left(\dfrac{m}{v_i}\right)$。

当 $v_i$ 都很小的时候会被卡成 $\Theta(nm)$。但是加法的合并远比乘法方便，开一个桶 $a_i$ 记录每个 $v_i$ 的出现次数，最大的物品重量为 $b$，那么：

$$
\begin{aligned}
F(x)&=\prod_{i=1}^b\left(\dfrac{1}{1-x^{i}}\right)^{a_i}\\
&=\exp\sum_{i=1}^ba_i\ln\left(\dfrac{1}{1-x^i}\right)\\
&=\exp\sum_{i=1}^ba_i\sum_{k \ge 1}\dfrac{x^{ik}}{k}\\
&=\exp\sum_{i=1}^ba_i\sum_{i \mid k}\dfrac{ix^k}{k}
\end{aligned}
$$

这就是大家喜闻乐见的 $\text{P\'olya Exp}$，或者叫欧拉变换。

计算右边的时间复杂度为最劣 $\Theta(b \log b)$，由于 $b \le m$ 可以看作是 $\Theta(m \log m)$。而 $\exp$ 的复杂度取决于实现可以是 $\Theta(m \log m)$ 或小常数的 $\Theta(m \log^2 m)$。

$n$ 很大（$10^7$ 级别）而 $m$ 很小（$10^4$ 级别）且没有 NTT 模数的背包计数问题也可以用这种方法处理，写一个基于递推的 $\Theta(m^2)$ 复杂度 $\exp$ 即可。如果 $m$ 再大一点就需要任意模数 NTT 了。

---

## 作者：Jμdge (赞：2)

灰常有趣的题目...（假的背包）

乍一看完全背包，然而发现复杂度是 $O(nm)$ 的于是弃疗


实际上这题要用生成函数解...关于生成函数函数可以考虑食用 [这篇blog](https://www.cnblogs.com/RabbitHu/p/9178645.html)

我们发现每种物品没有价值，也就是说我们考虑它的体积能取到的值是 $x·v_i$ ，也就是说体积的倍数，那么转化为生成函数也就是 $1\over 1-x^{vi}$


我们考虑最的第 s 个答案是 $\prod{1\over 1-x^{vi}}$ 这个多项式的第 s 项那么我们的任务就变成了求出这个多项式

首先我们考虑化式子：

$$\begin{aligned}  &\prod{1\over 1-x^{vi}}   \\ =& {1\over \prod 1-x^{vi}}   \\=& {1\over Exp\Big({\sum Ln(1-x^{vi})}\Big)} \end{aligned}$$

也就是说我们只要对于每个物品求出对应多项式的 $Ln$ 然后加起来 $Exp$ 一下再求个逆就可以出解了

但是...关键是...这个求 Ln ？复杂度有点不大对劲啊，好像是 $n^2log~n$ 的复杂度？

瞬间沉默...

其实我们考虑 $Ln$ 的展开，首先对于 $Ln(1-x)$ 而言，我们发现它的展开式为：

$$Ln(1-x)=\sum_{i=1}^\infty (-1)^i x^i$$

现在我们把 $x$ 变成 $x^{v}$ ：

$$Ln(1-x^{v})=\sum_{i=1}^\infty (-1)^i x^{iv}   $$

那么也就是说我们可以直接得到一个物品对应多项式的 $Ln$ ，并且拿出指数小于等于 m 的项即可

然鹅这又有什么用呢？只不过减掉了一个 $log$ 罢了，复杂度照样爆炸，还不如滚回去做完全背包...

但是换一个思路，我们发现复杂度之所以是 $n^2$ 原因就是满足条件的 $i$ 是 $O(n)$ 的，如果每个物品的 $v$ 都是 $1$ 的话就跑满了

那么我们考虑把 $v$ 一样的放一起加贡献（即桶排），然后 $O(m)$ 一遍扫过去

这样的复杂度是： $O(m+{m\over 2}+{m\over 3}+...+{m\over m})=O(m(1+{1\over 2}+{1\over 3}+...+{1\over m}))=O(m~ log ~m)$

这个复杂度...可以接受了丫~

然后和最前面说的一样...




# code

最后数组要开大否则完蛋...大概开小些就 30 分了...

```cpp
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
using namespace std;
const int mod=998244353;
const int iG=332748118;
const int M=6e5+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline int dec(int x,int y){return (x-=y)<0?x+mod:x;}
inline int inc(int x,int y){return (x+=y)>=mod?x-mod:x;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(int x,char chr='\n'){
	if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
	while(z[++Z]=x%10+48,x/=10);
	while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
} int n,m,limit; arr v,a,b,r,inv;
inline int qpow(int x,int p=mod-2){ int s=1;
	for(;p;p>>=1,x=mul(x,x)) if(p&1) s=mul(s,x); return s;
}
inline void Rev(int n){ int len=-1;
	for(limit=1;limit<=n;limit<<=1)++len;
	fp(i,1,limit-1) r[i]=(r[i>>1]>>1)|((i&1)<<len);
}
inline void NTT(int* a,int tp){
	fp(i,0,limit-1) if(i<r[i]) swap(a[i],a[r[i]]);
	for(int mid=1;mid<limit;mid<<=1){
		int Gn=qpow(tp?3:iG,(mod-1)/(mid<<1));
		for(int j=0,x,y;j<limit;j+=mid<<1)
			for(int k=0,g=1;k<mid;++k,g=mul(g,Gn))
				x=a[j+k],y=mul(g,a[j+k+mid]),
				a[j+k]=inc(x,y),a[j+k+mid]=dec(x,y);
	} if(tp) return ; int inv=qpow(limit);
	fp(i,0,limit-1) a[i]=mul(a[i],inv);
}
void Inv(int* a,int* b,int n){ static arr C,D;
	if(n==1) return b[0]=inv[a[0]],void();
	Inv(a,b,n>>1),Rev(n); fp(i,0,n-1) C[i]=a[i],D[i]=b[i];
	fp(i,n,limit-1) C[i]=D[i]=0; NTT(C,1),NTT(D,1);
	fp(i,0,limit-1) C[i]=mul(C[i],mul(D[i],D[i])); NTT(C,0);
	fp(i,0,n-1) b[i]=dec(inc(b[i],b[i]),C[i]);
}
inline void Direv(int* a,int* b,int n){
	fp(i,1,n-1) b[i-1]=mul(a[i],i); b[n-1]=0;
}
inline void Inter(int* a,int* b,int n){
	fp(i,1,n-1) b[i]=mul(a[i-1],inv[i]); b[0]=0;
}
inline void Ln(int* a,int* b,int n){ static arr A,B;
	Direv(a,A,n),Inv(a,B,n),Rev(n),NTT(A,1),NTT(B,1);
	fp(i,0,limit-1) A[i]=mul(A[i],B[i]);
	NTT(A,0),Inter(A,b,limit); fp(i,0,limit-1) A[i]=B[i]=0;
}
inline void Exp(int* a,int* b,int n){
	static arr F; if(n==1) return b[0]=1,void();
	Exp(a,b,n>>1),Ln(b,F,n),Rev(n); F[0]=dec(a[0]+1,F[0]);
	fp(i,1,n-1) F[i]=dec(a[i],F[i]); NTT(F,1),NTT(b,1);
	fp(i,0,limit-1) b[i]=mul(b[i],F[i]); NTT(b,0);
	fp(i,n,limit-1) b[i]=F[i]=0;
}
int main(){ n=read(),m=read();
	Rev(m),inv[0]=inv[1]=1;
	fp(i,2,limit) inv[i]=mul(mod-mod/i,inv[mod%i]);
	fp(i,1,n) ++v[read()];
	fp(i,1,m) if(v[i]) fp(j,1,m/i)
		a[i*j]=inc(a[i*j],mul(v[i],dec(mod,inv[j])));
	Exp(a,b,limit),memset(a,0,(limit+1)<<2);
	Inv(b,a,limit); fp(i,1,m) print(a[i]);
	return Ot(),0;
}
```













---

## 作者：leozhang (赞：0)

生成函数好题

首先我们对每一种物品（设体积为$v_{i}$）构造生成函数$F(x)=\sum_{j=1}^{\infty}x^{jv_{i}}$

 那么很显然答案就是这一堆东西乘在一起

但是...这个复杂度是$O(nmlog_{2}m)$的，显然不合理

因此我们考虑优化

我们发现，如果我们把所有生成函数取对数，那么多项式乘法就可以变成多项式加法了，我们直接累计每一位上的贡献即可

可是...这种东西如果我们挨个写多项式$ln$的话还是$O(nmlog_{2}m)$...

因此我们考虑转化：

把生成函数写成$F(x)=\frac{1}{1-x^{v_{i}}}$的形式

然后求$ln$：

$lnF(x)=ln\frac{1}{1-x^{v_{i}}}=-ln(1-x^{v_{i}})$

展开这个东西的步骤：

设$v_{i}=a$

于是只需展开$-ln(1-x^{a})$即可

那么对这个东西求导得到：

$\frac{ax^{a-1}}{1-x^{a}}$

然后把下面恢复成等比数列求和的形式：

$ax^{a-1}\sum_{i=0}^{\infty}x^{ai}$

再把系数乘进去

$a\sum_{i=0}^{\infty}x^{ai+a-1}$

再积分，考虑对同一函数先求导再积分得到的就是原函数，因此：

$lnF(x)=\int a\sum_{i=0}^{\infty}x^{ai+a-1}$

也就是：

$lnF(x)=a\sum_{i=0}^{\infty}\frac{1}{ai+a}x^{ai+a}$

再把系数扔进去：

$lnF(x)=\sum_{i=0}^{\infty}\frac{1}{i+1}x^{ai+a}$

改一下枚举范围：

$lnF(x)=\sum_{i=1}^{\infty}\frac{1}{i}x^{ai}$

那么就可以直接$O(nlnm)$（即调和级数）枚举倍数计算贡献，最后多项式exp即可

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
#define uint unsigned int
#define ll long long
using namespace std;
const ll mode=998244353;
int to[(1<<20)+5];
int v[1000005];
uint inv[2000005];
uint G[1000005];
uint F[1000005];
uint Ff[1000005];
uint ig[1000005];
uint lg[1000005];
uint tg[1000005];
uint has[1000005];
int n,m;
void init()
{
	inv[0]=inv[1]=1;
	for(int i=2;i<=200000;i++)inv[i]=1ll*(mode-mode/i)*inv[mode%i]%mode;
}
uint pow_mul(uint x,uint y)
{
	uint ret=1;
	while(y)
	{
		if(y&1)ret=1ll*ret*x%mode;
		x=1ll*x*x%mode,y>>=1;
	}
	return ret;
}
uint MOD(uint x,uint y)
{
	return x+y>=mode?x+y-mode:x+y;
}
void NTT(uint *a,int len,int k)
{
	for(int i=0;i<len;i++)if(i<to[i])swap(a[i],a[to[i]]);
	for(int i=1;i<len;i<<=1)
	{
		uint w0=pow_mul(3,(mode-1)/(i<<1));
		for(int j=0;j<len;j+=(i<<1))
		{
			uint w=1;
			for(int o=0;o<i;o++,w=1ll*w*w0%mode)
			{
				uint w1=a[j+o],w2=1ll*a[j+o+i]*w%mode;
				a[j+o]=(w1+w2)%mode,a[j+o+i]=(w1+mode-w2)%mode;
			}
		}
	}
	if(k==-1)
	{
		uint Inv=pow_mul(len,mode-2);
		for(int i=1;i<(len>>1);i++)swap(a[i],a[len-i]);
		for(int i=0;i<len;i++)a[i]=1ll*a[i]*Inv%mode;
	}
}
uint A[(1<<20)+5],B[(1<<20)+5],C[(1<<20)+5];
void mul(uint *f,uint *g,int len)
{
	int lim=1,l=0;
	while(lim<=2*len)lim<<=1,l++;
	for(int i=0;i<lim;i++)A[i]=B[i]=0,to[i]=((to[i>>1]>>1)|((i&1)<<(l-1)));
	for(int i=0;i<len;i++)A[i]=f[i],B[i]=g[i];
	NTT(A,lim,1),NTT(B,lim,1);
	for(int i=0;i<lim;i++)C[i]=1ll*A[i]*B[i]%mode;
	NTT(C,lim,-1);
}
void get_inv(uint *f,uint *g,int dep)
{
	if(dep==1)
	{
		g[0]=pow_mul(f[0],mode-2);
		return;
	}
	int nxt=(dep+1)>>1;
	get_inv(f,g,nxt);
	int lim=1,l=0;
	while(lim<=2*dep)lim<<=1,l++;
	for(int i=0;i<lim;i++)A[i]=B[i]=0,to[i]=((to[i>>1]>>1)|((i&1)<<(l-1)));
	for(int i=0;i<dep;i++)A[i]=f[i];
	for(int i=0;i<nxt;i++)B[i]=g[i];
	NTT(A,lim,1),NTT(B,lim,1);
	for(int i=0;i<lim;i++)C[i]=1ll*A[i]*B[i]%mode*1ll*B[i]%mode;
	NTT(C,lim,-1);
	for(int i=0;i<dep;i++)g[i]=(2*g[i]+mode-C[i])%mode;
}
void get_ln(uint *f,uint *g,int dep)
{
	for(int i=0;i<dep;i++)ig[i]=0;
	get_inv(f,ig,dep);
	for(int i=0;i<dep-1;i++)Ff[i]=1ll*f[i+1]*(i+1)%mode;
	mul(ig,Ff,dep);
	for(int i=0;i<dep;i++)g[i+1]=1ll*C[i]*inv[i+1]%mode;
}
void get_exp(uint *f,uint *g,int dep)
{
	if(dep==1)
	{
		g[0]=1;
		return;
	}
	int nxt=(dep+1)>>1;
	get_exp(f,g,nxt);
	get_ln(g,lg,dep);
	for(int i=0;i<dep;i++)tg[i]=(f[i]+mode-lg[i])%mode;
	tg[0]++;
	mul(g,tg,dep);
	for(int i=0;i<dep;i++)g[i]=C[i];
}
inline int read()
{
	int f=1,x=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int main()
{
	init();
	n=read(),m=read();
	for(int i=1;i<=n;i++)v[i]=read(),has[v[i]]++;
	for(int i=1;i<=100000;i++)if(has[i])for(int j=1;i*j<=m;j++)G[i*j]=MOD(G[i*j],1ll*has[i]*inv[j]%mode);
	get_exp(G,F,m+1);
	for(int i=1;i<=m;i++)printf("%u\n",F[i]);
	return 0;
}
```


---


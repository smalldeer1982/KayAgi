# 【模板】多项式开根

## 题目背景

模板题，无背景

## 题目描述

给定一个 $n-1$ 次多项式 $A(x)$，求一个在 ${} \bmod x^n$ 意义下的多项式 $B(x)$，使得 $B^2(x) \equiv A(x) \pmod{x^n}$。若有多解，请取零次项系数较小的作为答案。

多项式的系数在 ${}\bmod 998244353$ 的意义下进行运算。

## 说明/提示

对于 $100 \%$ 的数据：$1 \le n \leq 10^5$，$0 \le a_i < 998244353$。

## 样例 #1

### 输入

```
3
1 2 1
```

### 输出

```
1 1 0
```

## 样例 #2

### 输入

```
7
1 8596489 489489 4894 1564 489 35789489  
```

### 输出

```
1 503420421 924499237 13354513 217017417 707895465 411020414
```

# 题解

## 作者：Owen_codeisking (赞：36)

看到新模板，过来做一下。

### 前置知识：多项式求逆 + $NTT$

设 $H^2(x)\equiv F(x)(mod\ x^{\lceil\frac n2 \rceil})$

$G(x)\equiv H(x)(mod\ x^{\lceil\frac n2 \rceil})$

$G(x)-H(x)\equiv 0(mod\ x^{\lceil\frac n2 \rceil})$

$(G(x)-H(x))^2\equiv 0(mod\ x^{\lceil\frac n2 \rceil})$

$G^2(x)-2H(x)*G(x)+H^2(x)\equiv 0(mod\ x^n)$

$F(x)-2H(x)*G(x)+H^2(x)\equiv 0(mod\ x^n)$

$G(x)=\Large \frac {F(x)+H^2(x)}{2H(x)}$

对上述式子进行多项式求逆 + $NTT$ 即可

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=400000+10;
const int mod=998244353;
const int inv2=499122177;
int n,f[maxn],g[maxn],A[maxn],B[maxn],C[maxn],D[maxn],r[maxn];

inline int read(){
	register int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return (f==1)?x:-x;
}

int fpow(int a,int b){
	int ret=1;
	for(;b;b>>=1,a=1ll*a*a%mod)
		if(b&1) ret=1ll*ret*a%mod;
	return ret;
}

void NTT(int *f,int n,int op){
	for(int i=0;i<n;i++)
		if(i<r[i]) swap(f[i],f[r[i]]);
	int buf,tmp,x,y;
	for(int len=1;len<n;len<<=1){
		tmp=fpow(3,(mod-1)/(len<<1));
		if(op==-1) tmp=fpow(tmp,mod-2);
		for(int i=0;i<n;i+=len<<1){
			buf=1;
			for(int j=0;j<len;j++){
				x=f[i+j];y=1ll*buf*f[i+j+len]%mod;
				f[i+j]=(x+y)%mod;f[i+j+len]=(x-y+mod)%mod;
				buf=1ll*buf*tmp%mod;
			}
		}
	}
	if(op==1) return ;
	int inv=fpow(n,mod-2);
	for(int i=0;i<n;i++) f[i]=1ll*f[i]*inv%mod;
}

void Inv(int *a,int *b,int n){
	b[0]=fpow(a[0],mod-2);
	int len,lim;
	for(len=1;len<(n<<1);len<<=1){
		lim=len<<1;
		for(int i=0;i<len;i++) A[i]=a[i],B[i]=b[i];
		for(int i=0;i<lim;i++) r[i]=(r[i>>1]>>1)|((i&1)?len:0);
		NTT(A,lim,1);NTT(B,lim,1);
		for(int i=0;i<lim;i++) b[i]=((2ll-1ll*A[i]*B[i]%mod)*B[i]%mod+mod)%mod;
		NTT(b,lim,-1);
		for(int i=len;i<lim;i++) b[i]=0;
	}
	for(int i=0;i<len;i++) A[i]=B[i]=0;
	for(int i=n;i<len;i++) b[i]=0;
}

void Sqrt(int *a,int *b,int n){
	b[0]=1;
	int *A=C,*B=D,len,lim;
	for(len=1;len<(n<<1);len<<=1){
		lim=len<<1;
		for(int i=0;i<len;i++) A[i]=a[i];
		Inv(b,B,lim>>1);
		for(int i=0;i<lim;i++) r[i]=(r[i>>1]>>1)|((i&1)?len:0);
		NTT(A,lim,1);NTT(B,lim,1);
		for(int i=0;i<lim;i++) A[i]=1ll*A[i]*B[i]%mod;
		NTT(A,lim,-1);
		for(int i=0;i<len;i++) b[i]=1ll*(b[i]+A[i])%mod*inv2%mod;
		for(int i=len;i<lim;i++) b[i]=0;
	}
	for(int i=0;i<len;i++) A[i]=B[i]=0;
	for(int i=n;i<len;i++) b[i]=0;
}

int main()
{
	n=read();
	for(int i=0;i<n;i++) f[i]=read();
	Sqrt(f,g,n);
	for(int i=0;i<n;i++) printf("%d ",g[i]);
	printf("\n");
	return 0;
}
```

---

## 作者：CYJian (赞：16)

# 前置知识

[NTT](https://oi.men.ci/fft-to-ntt/)(但是如果你下决心要写这道题的话NTT是不可能不会的。。)

# 小心推导

首先我们需要构造一个函数$G(f)=f^2-F(x)$，那么令$G(f) \equiv 0\ (\bmod\ x^n)$成立的解$f$也满足：$f \equiv \sqrt{F(x)}\ (\bmod\ x^n)$

然后考虑怎么求这个$f$。

这里就需要使用多项式复合了。。

## 多项式复合

> 首先我们需要知道泰勒展开。
>
> > 已知多项式$F(x)$，以及其在$x_0$的值，则该多项式在$x$的取值可表示为：
> >
> > $$F(x) = G(x_0) + \sum_{i=1}^{\infty}\frac{G^{(i)}(x_0)}{i!}(x-x_0)^i$$
> >
> > 其中$G^{(i)}(x_0)$表示对$G(x_0)$求$i$阶导数
> 
> 那么这里有什么用呢。。
> 
> 假设我们已经知道了一个多项式$f_{t-1}$使得$G(f_{t-1}) \equiv 0\ (mod\ x^{2^{t-1}})$，然后现在的问题是求一个多项式$f_t$使得$G(f_t) \equiv 0\ (mod\ x^{2^t})$

> 这样的话。。我们尝试对$G(f_t)$做个泰勒展开：

> $$G(f_t) \equiv G(f_{t-1}) + \sum_{i=1}^{\infty}\frac{G^{(i)}(f_{t-1})}{i!} \ast (f_t-f_{t-1})^i\ (mod\ x^{2^t})$$

> 然后发现这个式子好像并不是很可做的样子啊。。

> 那么冷静分析一下，发现由于有：

> $$G(f_{t}) \equiv 0\ (mod\ x^{2^{t}})$$

> 则说明$G(f_t)$除常数项外系数不为$0$的项次数大于$t$，那么我们就可以有：

> $$G(f_{t}) \equiv 0\ (mod\ x^{2^{t-1}})$$

> 又因为：

> $$G(f_{t-1}) \equiv 0\ (mod\ x^{2^{t-1}})$$

> 则可以得知：

> $f_t-f_{t-1}$的前$2^{t-1}$项均为$0$，自然而然的，$(f_t-f_{t-1})^2$的前$2^t$项均为$0$...然后范围不断扩大。

> 然后回到上面的式子，发现是在模$x^{2^t}$的意义下。那么显然的是，包含了$(f_t-f_{t-1})^x\ (x > 1)$的项都为$0$了。

> 然后我们再把上面的式子化简一下，就可以得到：

> $$G(f_t) \equiv G(f_{t-1}) + G'(f_{t-1}) \ast (f_t-f_{t-1})\ (mod\ x^{2^t})$$

> 简单多了。。

> 然后由我们要求的式子：

> $$G(f_t) \equiv 0\ (mod\ x^{2^t})$$

> 所以有：

> $$G(f_{t-1}) + G'(f_{t-1}) \ast (f_t-f_{t-1})\ \equiv 0\ (mod\ x^{2^t})$$

> 我们再变形一下：

> $$f_t=f_{t-1}-\frac{G(f_{t-1})}{G'(f_{t-1})}$$

> 这样我们就得到了一个倍增的做法了。

> 复杂度$O(nlogn)$

以上内容摘自[浅谈多项式](https://cyjian.blog.luogu.org/duoxiangshi)

好的。。现在我们将当前这个$G(f)$带入就可以得到这样的一个式子：

$$f_t=f_{t-1}-\frac{f_{t-1}^2-F(x)}{2f_{t-1}}=\frac{f_{t-1}}{2}+\frac{F(x)}{2f_{t-1}}$$

然后只需要一个多项式求逆就好了。(如果不会多项式求逆的话可以看上面的浅谈多项式。)

代码：

```
#include <bits/stdc++.h>

using namespace std;

#define reg register
#define ge getchar()
#define Re read()
#define FI "Sqrt.in"
#define FO "Sqrt.out"
#define G 3
#define MAXN 262145
#define mod 998244353
#define Inv 499122177

inline int read() {
	reg int x = 0, ch;
	while(!isdigit(ch = ge)) ;
	while(isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = ge;
	return x;
}

inline void init(reg int);
inline int ksm(reg int, reg int);
inline void NTT(reg int[], reg int);
inline void Mul(reg int[], reg int[], reg int[], reg int, reg int);
inline void GetNi(reg int[], reg int[], reg int);
inline void Sqrt(reg int[], reg int[], reg int);

int N;
int p[MAXN + 1];
int A[MAXN + 1];
int B[MAXN + 1];
int tA[MAXN + 1];
int tB[MAXN + 1];
int tC[MAXN + 1];
int tp[MAXN + 1];
int tq[MAXN + 1];

int main() {
#ifndef ONLINE_JUDGE
	freopen(FI, "r", stdin);
	freopen(FO, "w", stdout);
#endif
	reg int n = Re;
	for(reg int i = 0; i < n; i++) A[i] = Re;
	Sqrt(A, B, n);
	for(reg int i = 0; i < n; i++) printf("%d%c", B[i], " \n"[i == n - 1]);
	return 0;
}

inline void init(reg int n) {
	N = 1; while(N <= (n << 1)) N <<= 1;
	for(reg int i = 0; i < N; i++) p[i] = (p[i >> 1] >> 1) | (i & 1 ? N >> 1 : 0);
}

inline int ksm(reg int a, reg int k) {
	reg int s = 1;
	while(k) {
		if(k & 1) s = 1LL * s * a % mod;
		a = 1LL * a * a % mod;
		k >>= 1;
	}
	return s;
}

inline void NTT(reg int a[], reg int k) {
	for(reg int i = 0; i < N; i++)
		if(i < p[i]) swap(a[i], a[p[i]]);
	for(reg int l = 2; l <= N; l <<= 1) {
		reg int len = l >> 1;
		reg int delta = ksm(G, (mod - 1) / l);
		for(reg int i = 0; i < N; i += l) {
			reg int g = 1;
			for(reg int j = i; j < i + len; j++) {
				reg int tmp = 1LL * a[j + len] * g % mod;
				a[j + len] = (a[j] - tmp + mod) % mod;
				a[j] = (a[j] + tmp) % mod;
				g = 1LL * g * delta % mod;
			}
		}
	}
	if(k) return ;
	reg int prd = ksm(N, mod - 2); reverse(a + 1, a + N);
	for(reg int i = 0; i < N; i++) a[i] = 1LL * a[i] * prd % mod;
}

inline void Mul(reg int A[], reg int B[], reg int C[], reg int n, reg int m) {
	init(max(n, m));
	memcpy(tp, A, 4 * n), fill(tp + n, tp + N, 0); NTT(tp, 1);
	memcpy(tq, B, 4 * m), fill(tq + m, tq + N, 0); NTT(tq, 1);
	for(reg int i = 0; i < N; i++) C[i] = 1LL * tp[i] * tq[i] % mod; NTT(C, 0);
}

inline void GetNi(reg int A[], reg int B[], reg int n) {
	if(n == 1) { B[0] = ksm(A[0], mod - 2); return ; }
	GetNi(A, B, (n + 1) >> 1); init(n);
	memcpy(tA, A, n * 4); fill(tA + n, tA + N, 0);
	NTT(tA, 1), NTT(B, 1);
	for(reg int i = 0; i < N; i++) B[i] = 1LL * (2LL - 1LL * tA[i] * B[i] % mod + mod) * B[i] % mod;
	NTT(B, 0); fill(B + n, B + N, 0);
}

inline void Sqrt(reg int A[], reg int B[], reg int n) {
	if(n == 1) { B[0] = 1; return ; }
	Sqrt(A, B, (n + 1) >> 1); memset(tB, 0, n * 4); GetNi(B, tB, n); Mul(A, tB, tB, n, n);
	for(reg int i = 0; i < n; i++) B[i] = 1LL * (B[i] + tB[i]) * Inv% mod;
}
```

---

## 作者：ezoixx118 (赞：8)

[更好的阅读体验](https://blog.csdn.net/ezoixx118/article/details/86763688)  
即给多项式$A(x)$，求$B(x)$使$B^2(x)\equiv A(x) \pmod{x^n}$  
考虑倍增，若求得$B'^2(x)\equiv A(x)\pmod{x^{\lceil \frac{n}{2} \rceil}}$，  
并已知$B^2(x)\equiv A(x)\pmod{x^{\lceil \frac{n}{2} \rceil}}$
$$\therefore B^2(x)-B'^2(x)\equiv 0\pmod{x^{\lceil \frac{n}{2} \rceil}}$$
$$\therefore B^4(x)+B'^4(x)-2B^2(x)B'^2(x)\equiv 0\pmod{x^n}$$
$$\therefore B^4(x)+B'^4(x)+2B^2(x)B'^2(x)\equiv 4B^2(x)B'^2(x)\pmod{x^n}$$
$$\therefore B^2(x)+B'^2(x)\equiv 2B(x)B'(x)\pmod{x^n}$$
$$\therefore A(x)+B'^2(x)\equiv 2B(x)B'(x)\pmod{x^n}$$
$$\therefore B(x)\equiv \frac{A(x)+B'^2(x)}{2B'(x)}\pmod{x^n}$$
再用多项式求逆即可。  
边界：$B_0=\sqrt{A_0}=1$(二次剩余)  
代码：  
```cpp
//#pragma GCC optimize(3)
#include<iostream>
#include<iomanip>
#include<stack>
#include<queue>
#include<list>
#include<vector>
#include<set>
#include<string>
#include<algorithm>
#include<complex>
#include<cmath>
#include<cstdio>
#include<cstring>
#define ull unsigned long long
#define ll long long
#define db long double
#define inf 400002
#define infm 1000009
#define INF (int)1e9
//#define mod 100000007LL
#define pi acos(-1)
#define rd(n) {n=0;char ch;int f=0;do{ch=getchar();if(ch=='-'){f=1;}}while(ch<'0'||ch>'9');while('0'<=ch&&ch<='9'){n=(n<<1)+(n<<3)+ch-48;ch=getchar();}if(f)n=-n;}
using namespace std;

const ll mod=998244353,G=3;
ll invG;

ll Qpow(ll x,ll k){
    ll ans=1LL;
    while (k){
        if (k&1){
            ans=ans*x%mod;
        }
        x=x*x%mod;
        k/=2;
    }
    return ans;
}

ll getinv(ll x){
    return Qpow(x,mod-2);
}

int N,bit;
int rev[inf];

void FFT(ll a[],int f){
    for (int i=0;i<N;i++){
        if (rev[i]>i){
            swap(a[i],a[rev[i]]);
        }
    }
    for (int i=1;i<N;i*=2){
        ll wn=Qpow(f==1?G:invG,(mod-1)/i/2);
        for (int j=0;j<N;j+=i*2){
            ll w=1;
            for (int k=0;k<i;k++){
                ll x=a[j+k],y=a[i+j+k]*w%mod;
                a[j+k]=(x+y)%mod;
                a[i+j+k]=(x-y+mod)%mod;
                w=w*wn%mod;
            }
        }
    }
    if (f==-1){
        ll invn=getinv(N);
        for (int i=0;i<N;i++){
            a[i]=a[i]*invn%mod;
        }
    }
    return;
}

void Poly_mul(ll A[],ll B[],int n){
    N=1,bit=0;
    while (N<=n){
        N*=2;
        bit++;
    }
    for (int i=0;i<N;i++){
        rev[i]=(rev[i/2]/2)|((i&1)<<(bit-1));
    }
    FFT(A,1);
    FFT(B,1);
    for (int i=0;i<=N;i++){
        A[i]=A[i]*B[i]%mod;
    }
    FFT(A,-1);
    for (int i=n;i<=N;i++){
    	A[i]=0;
    }
    return;
}

void Poly_cal(ll A[],ll B[],int n){
    N=1,bit=0;
    while (N<n*2){
        N*=2;
        bit++;
    }
    for (int i=0;i<N;i++){
        rev[i]=(rev[i/2]/2)|((i&1)<<(bit-1));
    }
    FFT(A,1);
    FFT(B,1);
    for (int i=0;i<=N;i++){
        B[i]=B[i]*(2-A[i]*B[i]%mod+mod)%mod;
    }
    FFT(B,-1);
    for (int i=n;i<=N;i++){
    	B[i]=0;
    }
    return;
}

ll tmp[inf];

void Poly_inv(ll A[],ll ans[],int n){
    if (n==1){
        ans[0]=getinv(A[0]);
        return;
    }
    Poly_inv(A,ans,(n+1)/2);
    memset(tmp,0,sizeof(tmp));
    for (int i=0;i<n;i++){
        tmp[i]=A[i];
    }
    Poly_cal(tmp,ans,n);
    return;
}

ll C[inf],B[inf],D[inf];

void Poly_sqrt(ll A[],ll ans[],int n){
    if (n==1){
        ans[0]=1;
        return;
    }
    memset(B,0,sizeof(B));
    memset(C,0,sizeof(C));
    memset(D,0,sizeof(D));
    Poly_sqrt(A,ans,(n+1)/2);
    for (int i=0;i<n;i++){
        C[i]=ans[i]*2%mod;
        D[i]=ans[i];
        B[i]=0;
    }
    Poly_inv(C,B,n);
    Poly_mul(ans,D,n);
    for (int i=0;i<n;i++){
        ans[i]=(ans[i]+A[i])%mod;
    }
    Poly_mul(ans,B,n);
    return;
}

int n;
ll A[inf],ans[inf];

int main(){
    invG=getinv(G);
    rd(n)
    for (int i=0;i<n;i++){
        rd(A[i])
    }
    int cnt=1;
    while (cnt<=n){
        cnt*=2;
    }
    Poly_sqrt(A,ans,cnt);
    for (int i=0;i<n;i++){
        printf("%lld ",ans[i]);
    }
    puts("");
    return 0;
}
```

---

## 作者：Gauss0320 (赞：6)

已知$A(x)$,求$B(x)$满足
$$B^2(x)\equiv A(x)\pmod{x^n}$$
易得
$$B^2(x)-A(x)\equiv0\pmod{x^n}$$
设
$$G(B(x))\equiv B^2(x)-A(x)\pmod{x^n}$$
考虑到$A(x)$为常数
$$G'(B(x))=2B(x)$$
于是进行牛顿迭代
$$B(x)\equiv B_0(x)-\frac{G(B_0(x))}{G'(B_0(x)}\pmod{x^n}$$
化简一下有
$$B(x)\equiv \frac{A(x)+B_0^2(x)}{2B_0(x)}\pmod{x^n}$$
代码如下
```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
const int N = 1<<20;

const int inv2 = 499122177, P = 998244353, g = 3, gi = 332748118;
int rev[N], F[N], G[N], A[N], B[N], C[N], D[N];

int read() {
	int x = 0, f = 1; char c = getchar();
	while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
	while(c >= '0' && c <= '9') x = (x<<1) + (x<<3) + c - '0', c = getchar();
	return x * f;
}
int add(int a, int b) {
	return (a += b) >= P ? a - P : a;
}
int qpow(int a, int b) 
{
	int prod = 1;
	while(b)
	{
		if(b & 1) prod = 1LL * prod * a % P;
		a = 1LL * a * a % P;
		b >>= 1;
	}
	return (prod + P) % P;
}
void NTT(int *A, int n, int inv) 
{
	for(int i = 0; i < n; ++i)
		if(i < rev[i]) swap(A[i], A[rev[i]]);
	for(int mid = 1; mid < n; mid <<= 1) 
	{
		int tmp = qpow(inv == 1 ? g : gi, (P - 1) / (mid << 1));
		for(int j = 0; j < n; j += (mid << 1)) 
		{
			int omega = 1;
			for(int k = 0; k < mid; ++k, omega = 1LL * omega * tmp % P) 
			{
				int x = A[j + k], y = 1LL * omega * A[j + k + mid] % P;
				A[j + k] = (x + y) % P;
				A[j + k + mid] = (ll)(x - y + P) % P;
			}
		}
	}
	if(inv == 1) return;
	int invn = qpow(n, P - 2);
	for(int i = 0; i < n; ++i)
		A[i] = 1LL * A[i] * invn % P;
}
void Inv(int *a, int *b, int n) 
{
	b[0] = qpow(a[0], P - 2);
	int len, lim;
	for(len = 1; len < (n << 1); len <<= 1)
	{
		lim = len << 1;
		for(int i = 0; i < len; i++)
			A[i] = a[i], B[i] = b[i];
		for(int i = 0; i < lim; i++)
			rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? len : 0);
		NTT(A, lim, 1), NTT(B, lim, 1);
		for(int i = 0; i < lim; i++)
			b[i] = ((2LL - 1LL * A[i] * B[i] % P) * B[i] % P + P) % P;
		NTT(b, lim, -1);
		for(int i = len; i < lim; i++)
			b[i] = 0;
	}
	for(int i = 0; i < len; i++) 
		A[i] = B[i] = 0;
	for(int i = n; i < len; i++)
		b[i] = 0;
}
void Sqrt(int *a, int *b, int n)
{
	b[0] = 1;
	int *A = C, *B = D, len, lim;
	for(len = 1; len < (n<<1); len <<= 1)
	{
		lim = len << 1;
		for(int i = 0; i < len; i++)
			A[i] = a[i];
		Inv(b, B, len);
		for(int i = 0; i < lim; i++)
			rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? len : 0);
		NTT(A, lim, 1), NTT(B, lim, 1);
		for(int i = 0; i < lim; i++)
			A[i] = 1LL * A[i] * B[i] % P;
		NTT(A, lim, -1);
		for(int i = 0; i < len; i++)
			b[i] = 1LL * (b[i] + A[i]) % P * inv2 % P;
		for(int i = len; i < lim; i++)
			b[i] = 0;
	}
	for(int i = 0; i < len; i++)
		A[i] = B[i] = 0;
	for(int i = n; i < len; i++)
		b[i] = 0;
}
int main()
{
	int n = read();
	for(int i = 0; i < n; ++i)
		F[i] = read();
	Sqrt(F, G, n);
	for(int i = 0; i < n; ++i)
		printf("%d ", G[i]);
	return 0;
}
```


---

## 作者：TianTian2008 (赞：4)

记太多板子很麻烦，而多项式exp用的比较多（？），所以介绍一种用exp做开根的方法。

开根的本质是 $\frac12$ 次方，类比多项式次幂的方法，即 $F(x)^\frac12=\exp(\frac12\ln F(x))$，其中 $\frac12$ 在模 $p=998244353$ 意义下取 $499122177$ 即可。

你可能会说为什么 $\frac12$ 对 $p$ 取模是对的，按照费马小定理不应该是对 $p-1$ 取模才对吗？然而事实上，$F(x)^k=\exp(k\ln F(x))$ 这个恒等式成立与否跟取不取模没有关系，所以这里不适用费马小定理。

这样我们就只需要用exp板子就可以做开根了，省下了一个板子~

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define mod 998244353
using namespace std;
typedef long long ll;
ll n,k,fac[1000001],inv[1000001],rev[1000001],tmp1[1000001],tmp2[1000001],tmp3[1000001],tmp4[1000001],f[1000001],g[1000001];
ll ksm(ll x,ll y) {
	ll res=1;
	while(y) {
		if(y&1) res=res*x%mod;
		x=x*x%mod;
		y>>=1; 
	}
	return res;
}
void init(ll n) {
	fac[0]=1;
	for(int i=1;i<=n;++i) fac[i]=fac[i-1]*i%mod;
	inv[n]=ksm(fac[n],mod-2);
	for(int i=n;i>=1;--i) inv[i-1]=inv[i]*i%mod;
}
ll getlen(ll n) {
	ll res=1;
	while(res<n) res<<=1;
	return res;
}
void ntt(ll n,ll *f,ll p) {
	for(int i=0;i<n;++i) rev[i]=(rev[i>>1]>>1)|((i&1)?(n>>1):0);
	for(int i=0;i<n;++i)
		if(i<rev[i]) swap(f[i],f[rev[i]]);
	for(int mid=1;mid<n;mid<<=1) {
		ll len=mid<<1,omg=ksm(p,(mod-1)/len);
		for(int i=0;i<n;i+=len) {
			ll cur=1;
			for(int j=0;j<mid;++j) {
				ll f1=f[i+j],f2=cur*f[i+j+mid]%mod;
				f[i+j]=(f1+f2)%mod;
				f[i+j+mid]=(f1-f2)%mod;
				cur=cur*omg%mod;
			}
		}
	}
}
void pinv(ll n,ll *f,ll *res) {
	res[0]=ksm(f[0],mod-2);
	ll m=getlen(n);
	for(int mid=1;mid<m;mid<<=1) {
		ll len=mid<<1,len2=len<<1;
		for(int i=mid;i<len;++i) res[i]=0;
		for(int i=0;i<len;++i) {
			tmp1[i]=f[i];
			tmp2[i]=res[i];
		}
		for(int i=len;i<len2;++i) tmp1[i]=tmp2[i]=0;
		ntt(len2,tmp1,3);
		ntt(len2,tmp2,3);
		for(int i=0;i<len2;++i) tmp1[i]=tmp1[i]*tmp2[i]%mod*tmp2[i]%mod;
		ntt(len2,tmp1,332748118);
		ll div=ksm(len2,mod-2);
		for(int i=0;i<len;++i) res[i]=((res[i]<<1)-tmp1[i]*div)%mod;
	}
}
void pdao(ll n,ll *f,ll *res) {
	for(int i=1;i<n;++i) res[i-1]=f[i]*i%mod;
	res[n-1]=0;
}
void pitg(ll n,ll *f,ll *res) {
	for(int i=1;i<n;++i) res[i]=f[i-1]*inv[i]%mod*fac[i-1]%mod;
	res[0]=0;
}
void pln(ll n,ll *f,ll *res) {
	pinv(n,f,tmp3);
	pdao(n,f,tmp1);
	ll m=getlen(n<<1);
	for(int i=n;i<m;++i) tmp1[i]=tmp3[i]=0;
	ntt(m,tmp1,3);
	ntt(m,tmp3,3);
	for(int i=0;i<m;++i) tmp1[i]=tmp1[i]*tmp3[i]%mod;
	ntt(m,tmp1,332748118);
	ll div=ksm(m,mod-2);
	for(int i=0;i<n;++i) tmp1[i]=tmp1[i]*div%mod;
	pitg(n,tmp1,res);
}
void pexp(ll n,ll *f,ll *res) {
	res[0]=1;
	ll m=getlen(n);
	for(int mid=1;mid<m;mid<<=1) {
		ll len=mid<<1,len2=len<<1;
		for(int i=mid;i<len;++i) res[i]=0;
		pln(len,res,tmp4);
		for(int i=0;i<len;++i) tmp4[i]=(f[i]-tmp4[i])%mod;
		++tmp4[0];
		for(int i=len;i<len2;++i) tmp4[i]=0;
		ntt(len2,tmp4,3);
		for(int i=0;i<mid;++i) tmp1[i]=res[i];
		for(int i=mid;i<len2;++i) tmp1[i]=0;
		ntt(len2,tmp1,3);
		for(int i=0;i<len2;++i) tmp1[i]=tmp1[i]*tmp4[i]%mod;
		ntt(len2,tmp1,332748118);
		ll div=ksm(len2,mod-2);
		for(int i=0;i<len;++i) res[i]=tmp1[i]*div%mod;
	}
}
int main() {
	init(1000000);
	scanf("%lld",&n);
	for(int i=0;i<n;++i) scanf("%lld",&f[i]);
	pln(n,f,g);
	for(int i=0;i<n;++i) g[i]=g[i]*499122177%mod;
	pexp(n,g,f);
	for(int i=0;i<n;++i) printf("%lld ",(f[i]+mod)%mod);
	return 0;
}
```

---


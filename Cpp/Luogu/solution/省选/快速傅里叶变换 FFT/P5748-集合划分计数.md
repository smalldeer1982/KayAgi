# 集合划分计数

## 题目描述

一个有 $n$ 个元素的集合，将其分为任意个非空子集，求方案数。  
注意划分出的集合间是无序的，即 $\{\{1,2\},\{3\}\}$ 和 $\{\{3\},\{2,1\}\}$ 算作一种方案。

由于答案可能会很大，所以要对 $998244353$ 取模。

## 说明/提示

【数据范围】  
$T = 1000$，$1\le n \le 10^5$。

【样例解释】  
对于 $n=3$，有五种方案：$\{\{1,2,3\}\},\{\{1,2\},\{3\}\},\{\{1\},\{2,3\}\},\{\{1\},\{2\},\{3\}\},\{\{1,3\},\{2\}\}$。

本题只有一个测试点，假设你答对了 $x$ 组数据，你将得到 $\lfloor x/(T/100) \rfloor$ 分。   
如果你不能解决所有数据，也请输出 $T$ 个整数。

~~TLE不要怪我，是你常数太大了~~

## 样例 #1

### 输入

```
5
2
3
7
9
233```

### 输出

```
2
5
877
21147
53753544
```

# 题解

## 作者：iostream (赞：30)

[我的博客](https://www.cnblogs.com/bestwyj/p/11178659.html)

题意就是求 $10^5$ 以内所有贝尔数，$bell(n)$ 即将 $n$ 个有标号的球划分为若干集合的方案数。

我们设一个非空集合的指数生成函数为 $F(x)$，设答案的指数生成函数为 $G(x)$；

枚举一共用多少个集合，将这些集合组合起来，集合之间是不可区分的。
$$G(x)=\sum_{i=0}^\infty \frac{F^i(x)}{i!}$$

也就是一个 多项式exp 的形式
$$G(x)=e^{F(x)}$$

而显然有非空集合的指数生成函数
$$F(x)=e^x-1$$

那么我们就可以求出贝尔数的指数生成函数 $G(x)$ 了，注意答案乘上 $n!$。

---

## 作者：NaCly_Fish (赞：14)

设 $B_n$ 为第 $n$ 项的答案。

有一种比较 naive 的想法是用第二类斯特林数来求，即：  
$$B_n=\sum\limits_{k=0}^n\begin{Bmatrix} n \\ k \end{Bmatrix}$$  
$$=\sum\limits_{k=0}^n\sum\limits_{i=0}^k\frac{i^n}{i!}\times\frac{(-1)^{k-i}}{(k-i)!}$$
用 FFT 求出一行第二类斯特林数，都加起来就好了，，每次时间复杂度 $\Theta(n \log n)$。  

但是本题有多组数据，这样是不能通过的。  
于是考虑其递推式：  
要推到 $B_n$，最后一个元素可以选择和前面 $n-1$ 个中选 $k\space (k\in[0,n-1])$ 个分为一个集合，于是得到递推式：  
$$B_n=\sum\limits_{k=0}^{n-1}\binom{n-1}{k}B_{n-k-1}$$
$$B_{n+1}=\sum\limits_{k=0}^n\binom{n}{k}B_{n-k}$$  

根据指数型生成函数的性质，设 $B_n$ 的指数型生成函数为 $B(x)$，那么有：  

$$B'(x)=B(x)\text e^x$$
又因为 $B(0)=1$，解得 $B(x)=\text e^{\text e^x-1}$，多项式 $\exp$ 即可。


当然这个式子还可以继续往下搞，求出通项：  
$$B(x)=\frac{1}{\text e}\sum\limits_{k=0}^\infty \frac{(\text e^x)^k}{k!}$$
$$=\frac{1}{\text e}\sum\limits_{k=0}^\infty \frac{1}{k!}\sum\limits_{n=0}^\infty\frac{k^n}{n!}x^n$$

$$=\frac{1}{\text e}\sum\limits_{n=0}^\infty \left ( \sum\limits_{k=0}^\infty\frac{k^n}{k!}\right) \frac{x^n}{n!}$$
所以就能得到 
$$B_n= \frac{1}{\text e}\sum\limits_{k=0}^\infty \frac{k^n}{k!}$$  
这个式子看起来非常神奇，带一个 $\text e$，还有个级数求和，最终却能算出来一个整数。  
~~然而这个式子好像并没什么用~~

---

## 作者：xcrr (赞：13)

## 不需要多项式算法的通过方法

这道题原是一个多项式专业对口解决的题，然而看到多项式代码就头疼的蒟蒻也想通过。

### 第一阶段
其实我们可以用球盒模型相互转化解决这个问题。（如果你想一次了解各类 “球盒” 模型，可以看看 [P5824 十二重计数法](https://www.luogu.com.cn/problem/P5824) 这道题，它涵盖本文所有用到的模型）

首先，我们把这个问题化这样一个经典的模型：

> 将 $n$ 个小球放入 $n$ 个框子中的方案数。框子可以空，小球之间互不相同，框子之间互相相同。

它其实有个专门的名字叫做 bell 数。如何算它呢？我们发现，只要我们枚举装了球的框子的数量 $m$（对应本题中集合的数量），就可以把问题转化为一个新的模型，将 $n$ 个小球放入 $m$ 个框子中，每个框子都**不可以空**的方案数，小球之间互不相同，框子之间互相相同。设对于指定 $n,m$ 上述问题的答案为 $S_m^n$，原问题的答案就是 $\sum _{i=0}^m S_i^n$。

发现 $S$ 其实就是第二类斯特林数。如果不会可以看看这个题 [P1655 小朋友的球 ](https://www.luogu.com.cn/problem/P1655)。但是出现了问题，如果用我们熟知的递推法求 $S$ 可以通过 P1655，然而在这道题的数据范围下寄掉了。

所以我们需要继续转化，发现 $S$ 的答案实际上是由 “将 $n$ 个小球放入 $m$ 个框子中，每个框子都不可以空，小球、框子之间都互不相同的方案数” 除以框子的排列方案数（即 $m!$）得到的。设对于指定 $n,m$ 这个新的模型的答案为 $f_m^n$。

$f$ 的求法就比较熟悉了，设 $g_m^n$ 是在这个模型的基础上，允许框子为空的方案数，易知 $g_m^n=m^n$。

同样是枚举空框子个数 $i$，得出关系式
$$
g_m^n=\sum_{i=0}^m C_m^i f_{m-i}^n=\sum_{i=0}^m C_m^i f_i^n
$$

二项式反演得到 
$$
f_m^n=\sum_{i=0}^m (-1)^{m-i}C_m^i g_i^n=\sum_{i=0}^m (-1)^{m-i}\frac{m!i^n}{i!(m-i)!}
$$

### 第二阶段

这时在 $n,m\le 10^5$ 的范围下，我们可以算指定 $f$ 的值，也可以算 $S$ 的值，可是原问题还有一个加和，那么就会 T。所以我们看看怎么化式子。因为 $n$ 是没有变过的，以下式子里二维数组的表示我们不带 $n$。

$$  
\left.\begin{matrix} 
f_m=\sum_{i=0}^m (-1)^{m-i}\frac{m!i^n}{i!(m-i)!}
\\S_m=f_m \cdot\frac{1}{m!}
\\ans=\sum _{i=0}^m S_i
\end{matrix}\right\}

\Rightarrow ans= \sum _{i=0}^m \sum_{j=0}^i \frac{(-1)^{i-j}j^n}{j!(i-j)!}
$$
交换求和号

$$
ans= \sum _{j=0}^m \sum_{i=j}^m \frac{(-1)^{i-j}j^n}{j!(i-j)!}
=\sum _{j=0}^m \frac{j^n}{j!}\sum_{i=j}^m \frac{(-1)^{i-j}}{(i-j)!}
$$

发现后面的和式每项取值只与 $i-j$ 有关，我们换元。
$$
ans=\sum _{j=0}^m \frac{j^n}{j!}\sum_{t=0}^{m-j} \frac{(-1)^t}{t!}
$$
这样就可以了，后面的和式预处理前缀和，算整个的时候只有枚举 $j$ 的复杂度。

### 第三阶段
计算一下复杂度，发现是 $O(T\cdot n\log n)$ 的（$\log$ 来自快速幂），还是差点。所以我们要把快速幂的复杂度搞出去。

观察和式，用到快速幂的有分母的求逆元，还有分子的 $j^n$。分母逆元因为阶乘预处理了，它也就可以预处理。分子的 $j^n$ 由于是每次询问需要 $j=0\to m$ 所有的值，可以用线性筛筛出来。

就搞定了！当然常数一定要写小一点！

```cpp
//P5748
#include<bits/stdc++.h>
#define endl '\n'
#define debug cout<<" awa\n";
using ll=long long;
using ull=unsigned long long;
using ld=long double;
using namespace std;
const int mod=998244353;
int read()
{
	int x=0;char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	return x;
}

int n;
const int N=1e5+10;
int fac[N],invfac[N];
int pw(int a,int b)
{
	int ret=1;
	while(b)
	{
		if(b&1)ret=1ll*ret*a%mod;
		a=1ll*a*a%mod;
		b>>=1;
	}
	return ret;
}
void init()
{
	fac[0]=1;
	for(int i=1;i<=1e5;i++)
	fac[i]=1ll*fac[i-1]*i%mod;
	for(int i=0;i<=1e5;i++)
	invfac[i]=pw(fac[i],mod-2);
}

int b[N],s[N],pm[N],tot;
bool c[N];
inline void solve(){
	init();
	for(int i=2;i<=1e5;i++)
	{
		if(!c[i])pm[++tot]=i;
		for(int j=1;j<=tot;j++)
		{
			if(1ll*i*pm[j]>1e5||pm[j]>i)break;
			c[i*pm[j]]=1;
			if(i%pm[j]==0)break;
		}
	}
	int t;t=read();
	while(t--)
	{
		n=read();
		s[0]=0,s[1]=1;
		for(int i=2;i<=n;i++)
		{
			if(!c[i])s[i]=pw(i,n);
			for(int j=1;j<=tot;j++)
			{
				if(1ll*i*pm[j]>n||pm[j]>i)break;
				s[i*pm[j]]=1ll*s[i]*s[pm[j]]%mod;
				if(i%pm[j]==0)break;
			}
		}
		int ans=0,sum=0;
		for(int i=n;i>=0;i--)
		{
			sum=(1ll*sum+(((n-i)&1)?-1:1)*invfac[n-i])%mod;
			ans=(ans+1ll*invfac[i]*s[i]%mod*sum)%mod;
		}
		printf("%d\n",ans>=0?ans:ans+mod);
	}
}

int main()
{
	solve();
	const int _=0;
	return ~~(0^_^0);
}
```

---

## 作者：xtx1092515503 (赞：11)

# [Portal](https://www.luogu.com.cn/problem/P5748)

这里是一种分治FFT的题解~~~

定义 $f_x$ 表示将一个有 $n$ 个元素的集合进行划分的方案数。

则我们枚举第一个元素所在的集合的大小，就有

$$f_i=\sum\limits_{j=1}^i\dbinom{i-1}{j-1}\times f_{i-j}$$

将二项式系数展开，得到

$$f_i=\sum\limits_{j=1}^i\dfrac{(i-1)!}{(j-1)!\times(i-j)!}\times f_{i-j}$$

将与 $i$ 有关的项，与 $j$ 有关的项和与 $i,j$ 都有关的项分离

$$\dfrac{f_i}{(i-1)!}=\sum\limits_{j=1}^i\dfrac{1}{(j-1)!}\times\dfrac{f_{i-j}}{(i-j)!}$$

换成枚举 $j-1$

$$\dfrac{f_i}{(i-1)!}=\sum\limits_{j=0}^{i-1}\dfrac{1}{j!}\times\dfrac{f_{i-j-1}}{(i-j-1)!}$$

我们令 $F_x=\dfrac{1}{x!},G_x=\dfrac{f_x}{x!}$，于是

$$\dfrac{f_i}{(i-1)!}=\sum\limits_{j=0}^{i-1}F_jG_{i-j-1}$$

后面明显是卷积形式，于是

$$\dfrac{f_i}{(i-1)!}=(FG)_{i-1}$$

明显 $F$ 是已知多项式，$G$ 只与 $f$ 有关，于是直接分治FFT即可。

复杂度 $(n\log^2n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int n=17;
const int N=1<<20;
const int mod=998244353;
const int G=3;
int T,inv[N],fac[N],f[N],rev[N];
int ksm(int x,int y){
	int rt=1;
	for(;y;x=(1ll*x*x)%mod,y>>=1)if(y&1)rt=(1ll*rt*x)%mod;
	return rt;
}
void NTT(int *a,int tp,int LG){
	int lim=(1<<LG),invlim=ksm(lim,mod-2);
	for(int i=0;i<lim;i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<(LG-1));
	for(int i=0;i<lim;i++)if(i<rev[i])swap(a[i],a[rev[i]]);
	for(int md=1;md<lim;md<<=1){
		int rt=ksm(G,(mod-1)/(md<<1));
		if(tp==-1)rt=ksm(rt,mod-2);
		for(int stp=md<<1,pos=0;pos<lim;pos+=stp){
			int w=1;
			for(int i=0;i<md;i++,w=(1ll*w*rt)%mod){
				int x=a[pos+i],y=(1ll*w*a[pos+md+i])%mod;
				a[pos+i]=(x+y)%mod;
				a[pos+md+i]=(x-y+mod)%mod;
			}
		}
	}
	if(tp==-1)for(int i=0;i<lim;i++)a[i]=(1ll*a[i]*invlim)%mod;
}
int A[N],B[N];
void CDQ(int l,int LG){
//	printf("%d:%d\n",l,LG);
	if(!LG){if(l)f[l]=1ll*f[l]*fac[l-1]%mod;return;}
	CDQ(l,LG-1);
	int lim=(1<<LG);
	for(int i=0;i<lim;i++)A[i]=B[i]=0;
	for(int i=0;i<(lim>>1);i++)A[i]=1ll*f[l+i]*inv[l+i]%mod;
	for(int i=0;i<lim;i++)B[i]=inv[i];
	NTT(A,1,LG),NTT(B,1,LG);
	for(int i=0;i<lim;i++)A[i]=1ll*A[i]*B[i]%mod;
	NTT(A,-1,LG);
	for(int i=(lim>>1);i<lim;i++)(f[l+i]+=A[i-1])%=mod;
	CDQ(l+(lim>>1),LG-1);
}
int main(){
	f[0]=fac[0]=1;
	for(int i=1;i<(1<<n);i++)fac[i]=1ll*fac[i-1]*i%mod;
	inv[(1<<n)-1]=ksm(fac[(1<<n)-1],mod-2);
	for(int i=(1<<n)-2;i>=0;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;
	CDQ(0,n);
//	for(int i=1;i<=10;i++)printf("%d ",f[i]);puts(""); 
	scanf("%d",&T);
	for(int i=1,x;i<=T;i++)scanf("%d",&x),printf("%d\n",f[x]);
}
```


---

## 作者：传奇666666 (赞：7)

设$B_i$表示$i$个数的划分方案数。那么，通过枚举1所在的集合的大小可得$B_i=\sum_{j=1}^{i}{C_{i-1}^{j-1}B_{i-j}}$，即$B_{i+1}=\sum_{j=0}^{i}{C_i^jB_{i-j}}$。设$B_i$的指数生成函数是$B(x)$。

$B'(X)=\sum_{i \ge 0}{\frac{B_{i+1}}{i!}X^i}$，$B(x)=\sum_{i \ge 0}{\frac{B_{i}}{i!}X^i}$。联立一下这两个式子和上面的$B_i$的递推式。可以得到$B'(x)=B(x)e^x$。

所以$ln(B'(x))=ln(B(x))+x$，即$ln(\frac{B'(x)}{B(x)})=x$。又因为$ln(\frac{B'(x)}{B(x)})=ln(ln'(B(x)))$，所以$B(x)=e^{e^x+c}$。因为$B_0=1$，所以$B(0)=1$。带入得$c=-1$，所以$B(x)=e^{e^x-1}$，对$F(x)=e^x-1$做一遍$exp$就完事了。

这时候，我们会发现$F(x)$的形式其实相等简单，它就是元素个数为$i$的非空集合的指数生成函数。

所以这也启发我们从另一个方向来解决这个问题。

首先还是令$F(x)=e^x-1$。这时候，我们令答案的指数生成函数为$G(x)$。则$G(x)=\sum_{i \ge 0}{\frac{F^i(x)}{i!}}$。这是为什么呢？这本质还是在讨论每个集合选了几个元素，然后以及是哪几个元素。不过集合之间是没有区别的，所以要除以一个$i!$。

然后上面那个式子可以继续化一下，就是$G(x)=\sum_{i \ge 0}{\frac{F^i(x)}{i!}}=e^{F(x)}=e^{e^x-1}$。得到了和上面一样的结果。

---

## 作者：Spasmodic (赞：6)

设 $n$ 个元素的方案数为 $f_n$。

考虑枚举最后一个元素所在的集合的个数，可得
$$
f_n=\sum_{i=1}^{n}f_{n-i}\binom{n-1}{i-1}
$$
所以
$$
f_{n+1}=\sum_{i=0}^{n}f_{n-i}\binom{n}{i}
$$
设 $f$ 的 EGF 为 $F(x)$，则
$$
\begin{aligned}
\frac{f_{n+1}}{(n+1)!}&=\sum_{i=0}^{n}\frac{f_{n-i}}{(n-i)!}\frac{1}{(n+1)i!}\\
(n+1)\times \frac{f_{n+1}}{(n+1)!}&=\sum_{i=0}^{n}\frac{f_{n-i}}{(n-i)!}\frac{1}{(n+1)i!}\\
[x^n]F'(x)&=\sum_{i=0}^{n}[x^{n-i}]F(x)\times [x^i]e^x\\
F'(x)&=F(x)e^x\\
\frac{\mathrm dF(x)}{\mathrm dx}&=F(x)e^x\\
\frac{\mathrm dy}{\mathrm dx}&=e^xy\\
\frac{\mathrm dy}{y}&=e^x\mathrm dx\\
\int \frac{\mathrm dy}{y}&=\int e^x\mathrm dx\\
\ln y&=e^x+C\\
y&=e^{e^x+C}
\end{aligned}
$$
取 $C=-1$，得 $F(x)=e^{e^x-1}$。

多项式 exp 即可。

复杂度 $O(n\log n+T)$。

---

## 作者：too_later (赞：4)

### 题目描述

- $T$ 次询问 $B_n$（$B_n$ 为贝尔数）

- $1\le T\le 1000,1\le n\le 10^5$。

### 题目思路：

设 $G(x)$ 为 $B_i$ 的指数型生成函数。

$G(x)=\sum\limits_{n=0}^{\infty}B_n\dfrac{x^n}{n!}$

$=\sum\limits_{n=0}^{\infty}\sum\limits_{i=0}^nS(n,i)\dfrac{x^n}{n!}$

$=\sum\limits_{i=0}^{\infty}\sum\limits_{n=0}^{\infty}S(n,i)\dfrac{x^n}{n!}$

后面不就是 $S(n,i)$ 的指数生成函数形式？

$=\sum\limits_{i=0}\dfrac{(e^x-1)^i}{i!}$

$=e^{e^x-1}$

多项式板子即可。

### Code:

```cpp
#include<bits/stdc++.h>
#define I inline
#define RI register int
#define rep(i,a,b) for(RI i=a;i<=b;++i)
#define dow(i,a,b) for(RI i=a;i>=b;--i)
using namespace std;
const int N=4e5+5,mo=998244353;
int n,T,frac[N],a[N],b[N],c[N],d[N],e[N],f[N],r[N];
I int add(int a,int b) {
	return a+b>=mo?a+b-mo:a+b;
}
I int sub(int a,int b) {
	return a-b<0?a-b+mo:a-b;
}
I int mul(int a,int b) {
	return 1ll*a*b%mo;
}
I int fast(int a,int b,int mo) {
	RI sum=1;
	while(b) {
		if(b&1) sum=mul(sum,a);
		a=mul(a,a);
		b>>=1;
	}
	return sum;
}
I void NTT(int a[],int lim,int op) {
	rep(i,0,lim-1) if(r[i]>i) swap(a[r[i]],a[i]);
	for(RI i=1; i<lim; i<<=1) {
		RI now=fast(op==1?3:332748118,(mo-1)/(i<<1),mo);
		for(RI j=0; j<lim; j+=(i<<1)) {
			RI res=1;
			rep(k,0,i-1) {
				RI x=a[j+k],y=mul(res,a[j+k+i]);
				a[j+k]=add(x,y),a[j+k+i]=sub(x,y),res=mul(res,now);
			}
		}
	}
	RI now=fast(lim,mo-2,mo);
	rep(i,0,lim-1) if(op==-1) a[i]=mul(a[i],now);
}
I void inv(int a[],int b[],int n) {
	if(n==1) {
		b[0]=fast(a[0],mo-2,mo);
		return;
	}
	inv(a,b,n+1>>1);
	RI lim=1,cnt=0;
	while(lim<=(n<<1)) lim<<=1,cnt++;
	rep(i,1,lim-1) r[i]=r[i>>1]>>1|(i&1)<<cnt-1;
	rep(i,0,n-1) c[i]=a[i];
	rep(i,n,lim-1) c[i]=0;
	NTT(c,lim,1),NTT(b,lim,1);
	rep(i,0,lim-1) b[i]=mul(b[i],sub(2,mul(b[i],c[i])));
	NTT(b,lim,-1);
	rep(i,n,lim-1) b[i]=c[i]=0;
}
I void Ln(int a[],int b[],int n) {
	RI lim=1,cnt=0;
	while(lim<=(n<<1)) lim<<=1,cnt++;
	rep(i,1,lim-1) r[i]=(r[i>>1]>>1)|((i&1)<<(cnt-1));
	inv(a,f,n);
	rep(i,0,n-2) d[i]=mul(a[i+1],i+1);
	rep(i,n-1,lim-1) d[i]=0;
	NTT(d,lim,1),NTT(f,lim,1);
	rep(i,0,lim-1) b[i]=mul(d[i],f[i]);
	NTT(b,lim,-1);
	dow(i,n-1,1) b[i]=mul(b[i-1],fast(i,mo-2,mo));
	b[0]=0;
	rep(i,n,lim-1) b[i]=0;
	rep(i,0,lim-1) f[i]=0;
}
I void exp(int a[],int b[],int n) {
	if(n==1) return (void)(b[0]=1);
	exp(a,b,n+1>>1);
	Ln(b,e,n);
	RI lim=1,cnt=0;
	while(lim<=(n<<1)) lim<<=1,cnt++;
	rep(i,1,lim-1) r[i]=(r[i>>1]>>1)|((i&1)<<(cnt-1));
	rep(i,0,n-1) e[i]=sub(a[i],e[i]);
	e[0]=add(1,e[0]);
	NTT(b,lim,1),NTT(e,lim,1);
	rep(i,0,lim-1) b[i]=mul(b[i],e[i]);
	NTT(b,lim,-1);
	rep(i,n,lim-1) b[i]=e[i]=0;
}
int main() {
	n=100001;
	frac[0]=1;
	rep(i,1,n) frac[i]=mul(frac[i-1],i);
	rep(i,1,n-1) a[i]=fast(frac[i],mo-2,mo);
	exp(a,b,n);
	rep(i,0,n-1) b[i]=mul(b[i],frac[i]);
	scanf("%d",&T);
	while(T--) scanf("%d",&n),printf("%d\n",b[n]);
	return 0;
}
```

---

## 作者：木xx木大 (赞：4)

贝尔数模板题

$B_n$ 表示把 $n$ 个元素划分到任意个无序非空集合的方案数。
		
枚举划分出的集合的个数，得到 $B_n=\sum_{i=1}^n{n\brace i}$
		
考虑从原来的 $n$ 个元素中选 $i$ 个和第 $n+1$ 个元素分到一个集合，得到递推公式：$B_{n+1}=\sum_{i=0}^n{n\choose i}B_{n-i}$
		
生成单个集合的 EGF 为 $e^x-1$，那么贝尔数的 EGF 即为 $\exp(e^x-1)$

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
namespace FGF
{
	int n,m;
	const int N=4e5+5,mo=998244353,g=3,gi=(mo+1)/3;
	int inv[N],ans[N],q[N],lim,r[N],fac[N]; 
	int qpow(int x,int y)
	{
		int s=1;
		while(y)
		{
			if(y&1)s=1ll*s*x%mo;
			x=1ll*x*x%mo;
			y>>=1;
		}
		return s;
	}
	void NTT(int *y,int op)
	{	
		for(int i=0;i<lim;i++)
			if(r[i]<i)swap(y[r[i]],y[i]);
		for(int l=1;l<lim;l<<=1)
			for(int i=0,wn=qpow(op==1?g:gi,(mo-1)/(l<<1));i<lim;i+=(l<<1))
				for(int j=0,w=1;j<l;j++,w=1ll*w*wn%mo)
				{
					int tmp=(y[i+j]-1ll*w*y[i+j+l]%mo+mo)%mo;
					y[i+j]=(y[i+j]+1ll*w*y[i+j+l]%mo)%mo,y[i+j+l]=tmp;
				}
		if(op==-1)
			for(int i=0,inv=qpow(lim,mo-2);i<lim;i++)
				y[i]=1ll*y[i]*inv%mo;	
	}
	void getinv(int *ans,int *a,int n)
	{
		if(n==1){ans[0]=qpow(a[0],mo-2);return;}
		getinv(ans,a,n>>1);
		static int tmp[N];
		lim=n<<1;
		for(int i=0;i<lim;i++)r[i]=r[i>>1]>>1|(i&1)*(lim>>1);
		for(int i=0;i<n;i++)tmp[i]=a[i];
		NTT(tmp,1),NTT(ans,1);
		for(int i=0;i<lim;i++)ans[i]=1ll*ans[i]*(2ll-1ll*ans[i]*tmp[i]%mo+mo)%mo,tmp[i]=0;
		NTT(ans,-1);
		for(int i=n;i<lim;i++)ans[i]=0;
	}
	void getder(int *ans,int *a,int n)
	{
		for(int i=0;i<n-1;i++)ans[i]=1ll*a[i+1]*(i+1)%mo;
		ans[n-1]=0;
	}
	void getint(int *ans,int *a,int n)
	{
		for(int i=n-1;i;i--)ans[i]=1ll*a[i-1]*qpow(i,mo-2)%mo;
		ans[0]=0;
	}
	void getln(int *ans,int *a,int n)
	{
		static int tmp[N];
		getinv(tmp,a,n),getder(ans,a,n);
		lim=n<<1;
		for(int i=0;i<lim;i++)r[i]=r[i>>1]>>1|(i&1)*(lim>>1);
		NTT(tmp,1),NTT(ans,1);
		for(int i=0;i<lim;i++)tmp[i]=1ll*tmp[i]*ans[i]%mo,ans[i]=0;
		NTT(tmp,-1);
		getint(ans,tmp,n);
		for(int i=0;i<lim;i++)tmp[i]=0;
	}
	void getexp(int *ans,int *a,int n)
	{
		if(n==1){ans[0]=1;return;}
		getexp(ans,a,n>>1);
		static int tmp[N];
		getln(tmp,ans,n); 
		lim=n<<1;
		for(int i=0;i<lim;i++)r[i]=r[i>>1]>>1|(i&1)*(lim>>1);
		tmp[0]=(1-tmp[0]+a[0]+mo)%mo;
		for(int i=1;i<n;i++)tmp[i]=(a[i]-tmp[i]+mo)%mo;
		NTT(tmp,1),NTT(ans,1);
		for(int i=0;i<lim;i++)ans[i]=1ll*ans[i]*tmp[i]%mo,tmp[i]=0;
		NTT(ans,-1);
		for(int i=n;i<lim;i++)ans[i]=0;
	}
	void work()
	{
		scanf("%d",&m);
		for(int i=1;i<=m;i++)
			scanf("%d",&q[i]),n=max(n,q[i]);
		fac[0]=inv[1]=1;
		n++;
		for(int i=1;i<n;i++)
			fac[i]=1ll*fac[i-1]*i%mo;
		for(int i=2;i<n;i++)
			inv[i]=1ll*(mo-mo/i)*inv[mo%i]%mo;
		for(int i=2;i<n;i++)
			inv[i]=1ll*inv[i]*inv[i-1]%mo;
		for(lim=1;lim<n;lim<<=1);
		getexp(ans,inv,lim);
		for(int i=1;i<=m;i++)
			printf("%lld\n",1ll*fac[q[i]]*ans[q[i]]%mo);
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

---

## 作者：JustinRochester (赞：4)

[传送门](https://www.luogu.com.cn/problem/P5748)

---

**【分析】**
--

设 $f_n$ 表示 $n$ 个数划分成集合的方案数，能比较显然的考虑到：

考虑枚举 $1$ 所在的集合大小，假设为 $i$ ，则 $1$ 所在的集合方案数为 $\dbinom{n-1}{i-1}$ 。剩余的 $(n-i)$ 个数划分成集合的方案数为 $f_{n-i}$

因此，不难列出递推式：$\displaystyle f_n=\sum_{i=1}^n\dbinom{n-1}{i-1}f_{n-i}$

换元 $i-1\to i$ 得 $\displaystyle f_n=\sum_{i=0}^{n-1}\dbinom{n-1}{i}f_{n-i-1}$

方程两边同乘 $x^{n-1}$ 并移项，即可得到：$\displaystyle {f_n\over (n-1)!}x^{n-1}=\sum_{i=0}^{n-1}{1\over i!}x^i\cdot {f_{n-i-1}\over (n-i-1)!}x^{n-i-1}$

即 $\displaystyle {\text d\over \text dx}({f_n\over n!}x^n)=\sum_{i+j=n-1}{1\over i!}x^i\cdot {f_j\over j!}x^j$

所以设 $\{f_n\}$ 的 EGF 为 $F^e$ ，由 $\{1\}$ 的 EGF 为 $e^x$ 得

$\displaystyle {\text d\over \text dx}F^e=e^x\cdot F^e$

$\therefore \displaystyle{\text dF^e\over F^e}=e^x\text dx$

$\therefore \displaystyle \ln F^e=\int{\text dF^e\over F^e}=\int e^x\text dx=e^x+C$

$\therefore F^e=\exp(e^x+C)$

代入 $\displaystyle 1={f_1\over 1!}={({\text d\over \text dx}F^e)(0)\over 1!}=\exp(e^0+C)\cdot e^0=e^{1+C}$

$\therefore C=-1$

故序列 $\{f_n\}$ 的指数型生成函数为 $F^e=\exp(e^x-1)$

---

由 $\displaystyle e^x-1=\sum_{n\geq 1}{1\over n!}x^n$ 进行初始化，可以直接少算一次多项式指数

而 [实际](https://www.luogu.com.cn/record/46510239) 证明，预处理单位根，非递归实现多项式取逆、取对数、取指数，会加快运行速度

---

**【代码】**
--

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int LimBit=18,M=1<<LimBit<<1,MAXN=1e5+10;
int a[M],b[M];

struct NTT{
	static const int G=3,P=998244353;
	int N,na,nb,W[2][M+M],Rev[M+M],*w[2],*rev,invN,Frac[MAXN],InF[MAXN],Inv[MAXN];
	inline ll kpow(ll a,ll x) { ll ans=1; for(;x;x>>=1,a=a*a%P) if(x&1) ans=ans*a%P; return ans; }
	inline int add(int a,int b) { return (a+b>=P)?(a+b-P):(a+b); }
	inline int dis(int a,int b) { return (a-b<0)?(a-b+P):(a-b); }
	//取模意义下的加减法、快速幂

	NTT(){
		Frac[0]=1;
		for(int i=1;i<=1e5;++i) Frac[i]=(ll)Frac[i-1]*i%P;
		InF[(int)1e5]=kpow(Frac[(int)1e5],P-2);
		for(int i=1e5;i;--i) InF[i-1]=(ll)InF[i]*i%P;
		for(int i=1;i<=1e5;++i) Inv[i]=(ll)InF[i]*Frac[i-1]%P;
		//预处理阶乘、阶乘逆元、逆元

		w[0]=W[0], w[1]=W[1], rev=Rev;

		w[0][0]=w[1][0]=1;
		for(int i=1,x=kpow(G,P>>LimBit),y=kpow(x,P-2);!(i>>LimBit);++i){
			rev[i]=(rev[i>>1]>>1)|((i&1)<<LimBit-1);
			w[0][i]=(ll)w[0][i-1]*x%P,  w[1][i]=(ll)w[1][i-1]*y%P;
		}
		int *lstw[2]={w[0],w[1]};
		w[0]+=1<<LimBit, w[1]+=1<<LimBit, rev+=1<<LimBit;
		//预处理单位根

		for(int d=LimBit-1;d>=0;--d){
			for(int i=0;!(i>>d);++i){
				rev[i]=(rev[i>>1]>>1)|((i&1)<<d-1);
				w[0][i]=lstw[0][i<<1],  w[1][i]=lstw[1][i<<1];
				//折半引理
			}
			lstw[0]=w[0], lstw[1]=w[1];
			w[0]+=1<<d, w[1]+=1<<d, rev+=1<<d;
		}
	}
	inline void work(){//FFT 初始化
		w[0]=W[0]; w[1]=W[1]; rev=Rev;
		for(int d=LimBit;1<<d>N;--d)
			w[0]+=1<<d, w[1]+=1<<d, rev+=1<<d;
		invN=kpow(N,P-2);
	}
	inline void FFT(int *a,int f){
		for(int i=0;i<N;i++) if(i<rev[i]) swap(a[i],a[rev[i]]);
		for(int i=1;i<N;i<<=1)
			for(int j=0,t=N/(i<<1);j<N;j+=i<<1)
				for(int k=0,l=0,x,y;k<i;k++,l+=t)
						x=(ll)w[f][l]*a[j+k+i]%P,y=a[j+k],a[j+k]=add(y,x),a[j+k+i]=dis(y,x);
		if(f) for(int i=0;i<N;++i) a[i]=(ll)a[i]*invN%P;
	}

	inline void doit(int *a,int *b,int na,int nb){
		for(N=1;N<na+nb-1;N<<=1);
		for(int i=na;i<N;++i) a[i]=0;
		for(int i=nb;i<N;++i) b[i]=0;
		work(); FFT(a,0); FFT(b,0);
		for(int i=0;i<N;i++) a[i]=(ll)a[i]*b[i]%P;
		FFT(a,1);
	}
    inline void get_inv(int *f,int *g,int n){//取逆
		for(int i=0;i<n;++i) g[i]=a[i]=0;
        g[0]=kpow(f[0],P-2);
        int l;
        for(l=1;l<n;l<<=1){
            for(int i=0;i<(l<<1);i++) a[i]=f[i];
            N=l<<2;
            work(); FFT(a,0); FFT(g,0);
            for(int i=0;i<N;i++) g[i]=(ll)g[i]*dis(2,(ll)a[i]*g[i]%P)%P;
            FFT(g,1);
            for(int i=(l<<1);i<N;i++) g[i]=0;
        }
        for(int i=n;i<l;i++) g[i]=0;
    }
	inline void get_ddx(int *f,int *g,int n){//取导数
		for(int i=0;i<n-1;++i) g[i]=f[i+1]*(i+1ll)%P;
		g[n-1]=0;
	}
	inline void get_intdx(int *f,int *g,int n,int C=0){//取积分
		for(int i=n-1;i;--i) g[i]=(ll)f[i-1]*Inv[i]%P;
		g[0]=C;
	}
	inline void get_ln(int *f,int *g,int n,int ln0=0){//取对数
		for(int i=0;i<n;++i) g[i]=a[i]=0;
		get_inv(f,g,n);
		for(int i=0;i<n;++i) a[i]=0;
		get_ddx(f,a,n);
		doit(a,g,n,n);
		for(int i=n;i<N;++i) a[i]=0,g[i]=0;
		get_intdx(a,g,n,ln0);
	}
	inline void get_exp(int *f,int *g,int n,int exp0=1){//取指数
		g[0]=exp0;
		int l;
		for(l=1;l<n;l<<=1){
			for(int i=0;i<l<<1;++i) b[i]=0;
			get_ln(g,b,l<<1,0);
			for(int i=0;i<l<<1;++i) b[i]=dis(f[i],b[i]);
			b[0]=add(b[0],1);
			N=l<<2;
			FFT(b,0); FFT(g,0);
			for(int i=0;i<N;++i) g[i]=(ll)g[i]*b[i]%P;
			FFT(g,1);
			for(int i=l<<1;i<N;++i) g[i]=0;
		}
		for(int i=n;i<l;++i) g[i]=0;
	}
}ntt;

int F[M],G[M];
inline void prePoly(){
	for(int i=1;i<=1e5;++i) F[i]=ntt.InF[i];
	ntt.get_exp(F,G,1e5+1);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	prePoly();
	int T,N; cin>>T;
	while(T--&&cin>>N) cout<<(ll)G[N]*ntt.Frac[N]%ntt.P<<"\n";
	cout.flush();
	return 0;
}
```

---

## 作者：zifanwang (赞：2)

[传送门](https://www.luogu.com.cn/problem/P5748)

考虑先对所有的 $n$ 求出答案，每次询问 $O(1)$ 输出。

记 $f_n$ 表示 $n$ 的答案，根据题意易得：

$$f_n=\sum_{i=1}^n {n-1\choose i-1}f_{n-i}$$

组合数展开并分离系数得：

$$f_n=\sum_{i=1}^n \frac{(n-1)!}{(i-1)!}\times \frac{f_{n-i}}{(n-i)!}$$
$$\frac{f_n}{(n-1)!}=\sum_{i=1}^n \frac{f_{n-i}}{(n-i)!}\times \frac{1}{(i-1)!}$$

令 $g_n=\frac{f_n}{(n-1)!}$，得：

$$g_n=\sum_{i=1}^n \frac{g_{n-i}}{n-i}\times \frac{1}{(i-1)!}$$

这是一个卷积的形式，分治 NTT 即可。时间复杂度 $O(n\log^2n)$。

参考代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define mxn 524288
#define md 998244353
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rept(i,a,b) for(int i=a;i<b;++i)
#define drep(i,a,b) for(int i=a;i>=b;--i)
using namespace std;
int power(int x,int y){
	int ans=1;
	for(;y;y>>=1){
		if(y&1)ans=ans*x%md;
		x=x*x%md;
	}
	return ans;
}
int T,n,dp[mxn],f[mxn],g[mxn],rev[mxn],fac[mxn],ifac[mxn];
void ntt(int *a,int n,int flag){
	rept(i,0,n)if(i<rev[i])swap(a[i],a[rev[i]]);
	for(int h=1;h<n;h<<=1){
		int x,y,s=power(3,499122176/h);
		for(int j=0;j<n;j+=h<<1){
			int w=1;
			for(int k=j;k<j+h;++k){
				x=a[k],y=w*a[k+h]%md;
				a[k]=(x+y)%md;
				a[k+h]=(x-y+md)%md;
				w=w*s%md;
			}
		}
	}
	if(flag==-1){
		int p=power(n,md-2);
		reverse(a+1,a+n);
		rept(i,0,n)a[i]=a[i]*p%md;
	}
}
void solve(int l,int s,int k){
	if(s==1)return;
	solve(l,s>>1,k-1);
	rept(i,0,s>>1){
		f[i]=l+i?dp[l+i]*ifac[l+i]%md*fac[l+i-1]%md:1;
		g[i]=ifac[i];
	}
	rept(i,s>>1,s)f[i]=0,g[i]=ifac[i];
	rept(i,0,s)rev[i]=(rev[i>>1]>>1)|((i&1)<<(k-1));
	ntt(f,s,1);ntt(g,s,1);
	rept(i,0,s)f[i]=f[i]*g[i]%md;
	ntt(f,s,-1);
	rept(i,s>>1,s)dp[l+i]=(dp[l+i]+f[i-1])%md;
	solve(l+(s>>1),s>>1,k-1);
}
signed main(){
	fac[0]=1;
	rep(i,1,131072)fac[i]=fac[i-1]*i%md;
	ifac[131072]=power(fac[131072],md-2);
	drep(i,131072,1)ifac[i-1]=ifac[i]*i%md;
	dp[0]=1;
	solve(0,131072,17);
	scanf("%lld",&T);
	while(T--){
		scanf("%lld",&n);
		printf("%lld\n",dp[n]*fac[n-1]%md);
	}
	return 0;
}
```

---

## 作者：feicheng (赞：2)

## Description

[cnblogs](https://www.cnblogs.com/hl-fc/p/16044478.html)

定义 $b_n$ 为将有 $n$ 个集合的元素划分为任意个无序非空子集的方案数（贝尔数），求 $b_n\bmod {998244353}$。

多测。

$1\le n\le 10^5$，$T=10^3$。

## Solution

发现 $b_n$ 实际上是一行第二类斯特林数的和，而对于斯特林数 $\begin{Bmatrix} n \\ k\end{Bmatrix}$，有通项公式：
$$
\begin{Bmatrix} n \\ k\end{Bmatrix}=\sum_{r=1}^k(-1)^{k-r}\dfrac{r^n}{(k-r)!r!}
$$

注意到当 $k>n$ 时，$\begin{Bmatrix} n \\ k\end{Bmatrix}=0$，所以我们可以假定一个大于 $n$ 的整数 $M$，有
$$
\begin{aligned}
b_n&=\sum_{k=1}^M\sum_{r=1}^k(-1)^{k-r}\dfrac{r^{n-1}}{(k-r)!(r-1)!}\\
   &=\sum_{r=1}^M\dfrac{r^{n-1}}{(r-1)!}\sum_{k=r}^M\dfrac{(-1)^{k-r}}{(k-r)!}
\end{aligned}
$$

因为 $M$ 可以取任意比 $n$ 大的整数，我们令 $M\to+\infty$，有

$$
b_n=\dfrac{1}{{\rm e}}\sum_{r\ge 0}\dfrac{r^n}{r!}
$$

我们考虑贝尔数的 EGF $B(z)$，有：
$$
\begin{aligned}
B(z)-1&=\sum_{k\ge 1}\dfrac{b_k}{k!}z^k\\
      &=\dfrac{1}{\mathrm{e}}\sum_{k\ge 1}\dfrac{z^k}{k!}\sum_{r\ge 1}\dfrac{(r-1)^k}{(r-1)!}\\
      &=\dfrac{1}{\mathrm{e}}\sum_{r\ge 1}\dfrac{1}{r!}\sum_{k\ge 1}\dfrac{(zr)^k}{k!}\\
      &=\dfrac{1}{\mathrm{e}}\sum_{r\ge 1}\dfrac{\mathrm{e}^{rz}-1}{r!}\\
      &=\dfrac{1}{\mathrm{e}}(\mathrm{e}^{\mathrm{e}^z}-\mathrm{e})\\
      &=\mathrm e^{\mathrm e^z-1}-1
\end{aligned}
$$

即 $B(z)=\mathrm{e}^{\mathrm e^z-1}$，算一遍 $\exp$ 即可。

时间复杂度：$\mathcal O(n\log n)$。


由于一千个人有一千个多项式板子，所以就不给代码了，不过可以私信找我要代码。


---

## 作者：Tony102 (赞：2)

[Link](https://www.luogu.com.cn/problem/P5748)

[Blog阅读效果更佳](https://tony102.xyz/index.php/2021/03/25/luogu5748-%e9%9b%86%e5%90%88%e5%88%92%e5%88%86%e8%ae%a1%e6%95%b0/)


### Sol

贝尔数就是一行第二类斯特林数的和，关于贝尔数和第二类斯特林数之间一些转换关系，此处不再赘述

首先给出贝尔数的递推公式

$$B_n  = \sum_{i = 1}^{n} B_{n - i} \binom{n - 1}{i - 1}$$

组合意义显然意见，把集合划分成 $n$ 个非空子集的方案数就可以先枚举某一特定元素所在集合的大小，比如说考虑 $1$ 这个元素所在的集合是 $\binom{n - 1}{i - 1}$ 种，那么剩下的元素划分的方案数就是 $B_{n - i}$

$i - 1$ 不好搞，把枚举 $i$ 换成枚举 $i - 1$ ，就变成了

$$B_n  = \sum_{i = 0}^{n - 1} B_{n - i - 1} \binom{n - 1}{i}$$

把组合数拆开，并且把两边同时乘上 $x^{n - 1}$ ， 得到：

$$B_n x^{n - 1} = \sum_{i = 0}^{n - 1} \frac{(n-1)! x^{n-1}}{i! (n - i - 1)!} B_{n - i - 1}$$

这玩意儿你一看十分不好做，但是如果观察看见 $x^{i} \times x^{n - i - 1} = x^{n - 1}$ ，事情就简单了不少

$$B_n x^{n - 1} = \sum_{i = 0} ^{n - 1} \frac{x^{i}}{i!} \cdot \frac{B_{n - i - 1}}{(n - i - 1)!} x^{n - i - 1} \cdot (n - 1)!$$

把 $(n - 1)!$ 项除过去，现在已经变成了：

$$\frac{B_n}{(n - 1)!} x^{n - 1} = \sum_{i = 0}^{n - 1} \frac{x^{i}}{i!} \cdot \frac{B_{n - i - 1}}{(n - i - 1)!} x^{n - i - 1}$$

对其求导，得：

$$\frac{\mathrm{d}}{\mathrm{d}x} (\frac{B_n}{n!} x ^{n}) = \sum_{i + j = n - 1} \frac{x^i}{i!} x^i \cdot \frac{B_j}{j!} x^j $$

设贝尔数的 EGF 为$F(x)$ ， 上面的式子已经是一个 EGF 的形式了，所以重写变成

$$\frac{\mathrm{d} }{\mathrm{d} x} F'(x) = F(x) \cdot e^x$$

设 $u = F(x)$ ， 两边同时乘以算子 $\mathrm{d} x$

$$\mathrm{d} u = u \cdot e^x \cdot \mathrm{d} u$$

把右边的 $u$ 除过去

$$\frac{\mathrm{d} u}{u} = e^x \cdot \mathrm{d} u$$

积分得

$$\int \frac{\mathrm{d} u}{u} = \int e^x \mathrm{d} x$$

$$\ln  u = e^x + C$$

把 $x = 1$ 带入 EGF 的时候可以算出一个 $C = -1$ ，所以

$$F(x) = e^{e^x - 1}$$

因为 $e^x - 1 = \sum_{n \geq 1} \frac{1}{n!} x^n$

所以把阶乘逆元作为初始多项式再做 exp 就好了



### Code

[**Code请戳这里**](https://tony102.xyz/index.php/2021/03/25/luogu5748-%e9%9b%86%e5%90%88%e5%88%92%e5%88%86%e8%ae%a1%e6%95%b0/)

---

## 作者：PokerKing (赞：1)

## **思路**

这个问题可以使用动态规划来解决。定义 $f(n)$ 为将一个 $n$ 个元素的集合分为任意个非空子集的方案数。我们考虑最后一个元素 $n$，它可以独立成一个子集，也可以与前面的元素组成一个子集。

如果 $n$ 单独成一个子集，那么问题就变成了将前 $n-1$ 个元素分为任意个非空子集的方案数，即 $f(n-1)$。

如果 $n$ 与前面的元素组成一个子集，那么前面的 $n-1$ 个元素可以分为任意个非空子集，即 $f(n-1)$，而最后一个元素 $n$ 单独成一个子集。所以这种情况的方案数是 $2 \cdot f(n-1)$。

综合上述两种情况，可以得到递推关系式：$f(n) = f(n-1) + 2 \cdot f(n-1) = 3 \cdot f(n-1)$

初始条件为 $f(1) = 1$，因为一个元素的集合只有一种分法，即自己单独成为一个子集。

---

## 作者：EthanOI (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5748)

题解中只对显式表达式的推导进行证明，剩下的就是体力活了。

设 $[n]=\{1,2,\ldots ,n\}$ 对应的分拆方法数为 $B_n$，只需计算 $B$ 的生成函数 
$$f(x)=\sum\limits_{n=0}^{+\infty}B_nx^n.$$
最自然的想法就是考虑递推，这几乎是可以直接看出来的：对于 $[n+1]$，判断划分中元素 $n+1$ 所在集合元素个数，设为 $k+1$，其中 $0\le k\le n$。选取 $k$ 个元素的方法数为 $\binom{n}k$。剩下 $n-k$ 个元素划分数为 $B_{n-k}$，从而由加法、乘法原理 
$$B_{n+1}=\sum_{k=0}^n\binom nkB_{n-k}$$
为了凑成卷积形式，将关于 $k$ 的量从组合数中分离开，变形即得
$$(n+1)\cdot\frac{B_{n+1}}{(n+1)!}=\sum_{k=0}^n\frac{1}{k!}\cdot\frac{B_{n-k}}{(n-k)!}$$
记 $C_n=\frac {B_n}{n!}$，其生成函数 $g(x)=\sum_{n=0}^{+\infty}C_nx^n$。用上式进行累加可得
$$\begin{aligned}\sum_{n=1}^{+\infty}nC_nx^{n-1}&=\sum_{n=0}^{+\infty}\sum_{k=0}^n\frac{x^k}{k!}\cdot C_{n-k}x^{n-k}\\&=\sum_{n=0}^{+\infty}\frac {x^n}{n!}\sum_{n=0}^{+\infty}C_nx^n\end{aligned}$$
从而由级数 $\sum_{n=0}^{+\infty}\frac {x^n}{n!}=e^x$ 即得
$$g'(x)=e^xg(x)$$
转化为了微分方程问题。记 $h(x)=\ln g(x)$，两边取对数有
$$h(x)+\ln h'(x)=x+h(x)\Rightarrow h'(x)=e^x$$
这样就基本做完了。代初值有 $h(x)=e^x-1$，从而 $g(x)=e^{e^x-1}$。最后泰勒展开并代入 $B_n=n!C_n$，即可完成，好了。

**注：去 OEIS 查了一下，这个数列叫 [Bell number](https://oeis.org/A000110)，有兴趣的可以进行深层次的了解。对我而言，这种 $e^{e^x}$ 形式答案的确令人颇为惊讶。**

---

## 作者：Aveiro7 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5748)

## 题意：

一个有 $n$ 个元素的集合，将其分为任意个非空子集，求方案数。  
注意划分出的集合间是无序的，即 $\{\{1,2\},\{3\}\}$ 和 $\{\{3\},\{2,1\}\}$ 算作一种方案。

由于答案可能会很大，所以要对 $998244353$ 取模。

## 思路：

这题很明显是有关贝尔数的。

设一个非空集合的指数生成函数为 $\operatorname{F(x)}$，枚举有多少个集合，集合之间是不可区分的。

答案的生成函数显然为：

$$\operatorname{G(x)}=\sum_{i=0} \frac{\operatorname{F^i(x)}}{i!}$$

然而这就是一个 EXP。

又 $\operatorname{F(x)}=e^x-1$。

所以答案为 $\operatorname{exp(e^x-1)}$。

完结撒花！

---


# 悔改

## 题目描述

Daniel13265 有一些同样长的小木棍，他把这些木棍随意砍成两段，使得每段的长都不超过 $m$。

现在他想把小木棍拼接成原来的样子，但是却遗失了部分小木棍，而且忘记了自己开始时有多少根木棍和它们的长度。所以他打算把剩下的小木棍拼接出尽可能多的相同长度的木棍。

给出每段小木棍的长度，求出从剩下的木棍中最多能够拼接出的相同长度的木棍的个数与能拼接出来相同长度的木棍个数最多时木棍的最小可能长度。


## 说明/提示

### 样例解释

如果要拼接出尽量多的长度为 $11$ 的木棍，可以将长度为 $2$ 和 $9$ 的木棍拼接在一起，将长度为 $4$ 和 $7$ 的木棍拼接在一起。然而如果将长度为 $1$ 和 $8$ 的木棍拼接在一起，将长度为 $2$ 和 $7$ 的木棍拼接在一起，可以拼接出 $2$ 根长度为 $9$ 的木棍。  

可以发现能拼接出来相同长度的木棍个数的最大值就是 $2$，此时木棍的长度可能为 $9,10$ 或 $11$，其中最小的为 $9$。


### 数据范围

**本题采用捆绑测试。你每通过一个子任务的所有数据点，就能得到该子任务的全部分数。**

| 子任务编号 | $n\le$ | $m\le$ | 分值 |
|:-:|:-:|:-:|:-:|
| $1$ | $10$ | $10^5$ | $5$ |
| $2$ | $10^3$ | $10^3$ | $10$ |
| $3$ | $10^3$ | $10^5$ | $10$ |
| $4$ | $10^5$ | $10$ | $5$ |
| $5$ | $10^5$ | $10^3$ | $10$ |
| $6$ | $10^5$ | $10^5$ | $60$ |

对于 $100\%$ 的数据，满足 $2\le n,m\le10^5,1\le a_i\le m$。

## 样例 #1

### 输入

```
7 10
1 1 2 4 7 8 9
```

### 输出

```
2 9```

# 题解

## 作者：Daniel13265 (赞：5)

这是「Daniel13265 的公开赛」的官方题解。

---

## 子任务 $1$

直接枚举配对的木棍即可。

## 子任务 $2,4,5$

设长度为 $i$ 的木棍的个数为 $b_i$，那么 $x$ 作为最终的木棍长度最多可能出现的次数

$$f_x=\left\lfloor\frac12\sum_{i+j=x}\min\left(b_i,b_j\right)\right\rfloor$$

暴力算这个式子即可，算法时间复杂度为 $\mathcal O\left(m^2\right)$。

## 子任务 $3$

注意到上式中 $b_i\ne0$ 的 $i$ 的个数最多只有 $n$ 个，于是可以将 $b_i\neq0$ 的 $i$ 的值统计出来，再用这 $\mathcal O(n)$ 个数计算答案。时间复杂度 $\mathcal O\left(\min^2(n,m)\right)$。

## 子任务 $6$

发现上面的式子很像卷积，只是要计算 $\min$ 的卷积。

于是考虑将上式转化一下，枚举一下小于等于 $\min\left(b_i,b_j\right)$ 的数：

$$\begin{aligned}f_x&=\left\lfloor\frac12\sum_{i+j=x}\sum_{k=1}^{n}\left[b_i\geq k\right]\left[b_j\geq k\right]\right\rfloor\\&=\left\lfloor\frac12\sum_{k=1}^{n}\sum_{i+j=x}\left[b_i\geq k\right]\left[b_j\geq k\right]\right\rfloor\end{aligned}$$

然后就可以愉快地乘法卷积了~~~

但是，问题在于这么算的时间复杂度是 $\mathcal O(nm\log m)$ 的。

优化方式也不难：考虑到**子任务** $3$ 的思路，发现对于一个给定的 $t$，大于 $t$ 的 $b_i$ 的 $i$ 的个数只有 $\mathcal O\left(\min\left(\dfrac nt,m\right)\right)$ 个，于是小于等于 $t$ 的部分使用卷积，而大于 $t$ 的部分直接暴力计算即可。

这个算法的总时间复杂度为 $\mathcal O\left(tm\log m+\left(\dfrac nt\right)^2\right)$ ，当 $t=\sqrt[3]{\dfrac{n^2}{m\log m}}$ 时有最小值 $\mathcal O\left((nm\log m)^\frac23\right)$。实际上，由于卷积部分常数较大，当 $t$ 小于该值时程序运行效率更高。

---

## 作者：z7z_Eta (赞：4)

只能靠一直写各位神仙都不屑于做的谔谔题~~来荒废度日~~

数学公式错了可以[在luogu博客看](https://www.luogu.com.cn/blog/z7z-Eta/solution-p6300)

---

任意砍成两段可以认为是一种类型的生成函数的**2次方**

$s_k = \lfloor\{\sum_{i+j=k}min(a_i,a_j)\ \}/2\rfloor$

$a$是$cnt$数组, 除$2$取整已经包含了相同大小的两个拼起来的情况

答案就是$s$最大值, 暴力求复杂度是$O(m^2)$的

---

正解是一类**取min类型的卷积**到普通乘法卷积的转化

$\sum_{i+j=k}min(a_i,a_j) = \sum_{d=1}\sum_{i+j=k}[a_i\ge d][a_j\ge d]$

这样**枚举$d$**, 每次卷积就可以求了

也就是说$F_d(x)=\sum[a_i\ge d]x^i$

$s_k=\frac{1}{2}\sum_{d=1}\ [x^k]F_d^2(x)$

---

我们发现, 显然本质不同的$F_d$是$O(\sqrt{n})$级别的, 因为最坏情况是$1+2+3+4+\dots=O(D^2)$

所以**离散化$a$数组**直接卷就好了, 复杂度$O(m\sqrt{n}\log m)$, 常数不大

虽然比官方题解看起来~~屑了不少~~, 但是也许更好理解一些^QwQ^.

```cpp
// Etavioxy
#define ll long long
#define il inline
#define rep(i,s,t) for(register int i=(s);i<=(t);i++)
#define rev_rep(i,s,t) for(register int i=(s);i>=(t);i--)
#define pt(x) putchar(x)
using namespace std;
il int ci(){ register char ch; int f=1; while(!isdigit(ch=getchar())) f=ch=='-'?-1:1; register int x=ch^'0'; while(isdigit(ch=getchar())) x=(x*10)+(ch^'0'); return f*x; }
template<typename T> il bool chk_max(T&x,T y){ return (x<y?(x=y,1):0); }

const int mod = 998244353;
enum{N=270023};
il ll qpow(ll a,ll b){
	ll ans= 1; for(; b; b>>=1,a=a*a%mod) if( b&1 ){ ans= ans*a%mod; } return ans;
}
il ll inv(ll x){ return qpow(x,mod-2); }

const ll g0 = 3;
const ll invg0 = inv(g0);
int rev[N],init_rev_n;
il void init_rev(int n){
	if( n==init_rev_n ) return;
	int t = log2(n);
	init_rev_n = n;
	rep(i,1,n-1) rev[i] = (rev[i>>1]>>1)|((i&1)<<(t-1));
}
int NTT(ll*A,int n,int IDFT){
	init_rev(n);
	rep(i,1,n-1) if( i<rev[i] ) swap(A[i],A[rev[i]]);
	for(int t=1;t<n;t<<=1){
		ll w0 = qpow(IDFT==-1?invg0:g0,(mod-1)/(t*2));
		for(int i=0;i<n;i+=t*2){
			for(register int j=0,w=1;j<t;j++,w=w*w0%mod){ ll x=A[i+j], y=A[i+t+j]; A[i+j] = (x+w*y)%mod; A[i+t+j] = (x-w*y)%mod; }
		}
	}
	if( IDFT==-1 ){ ll invn = inv(n); rep(i,0,n-1) A[i] = A[i]*invn%mod; } return n;
}
il int set2(int n){ return 1<<((int)log2(n-1)+1); } // 原代码的模板都进行了压行处理

ll t[N],s[N];
int a[N],b[N];

int main(){
	int n = ci(), m = ci();
	rep(i,1,n) a[ci()]++;
	rep(i,1,m) b[i] = a[i];
	sort(b,b+m+1);
	int T = unique(b,b+m+1)-b-1;
	rep(d,1,T){
		rep(i,1,m*2) t[i] = a[i]>=b[d];
		int L = set2(m*2);
		NTT(t,L,1);
		rep(i,0,L-1) t[i] = t[i]*t[i]%mod;
		NTT(t,L,-1);
		rep(i,1,m*2) s[i] += 1ll*(b[d]-b[d-1])*((t[i]+mod)%mod);
	}
	ll ans = 0, ans2 = 0;
	rep(i,1,m*2) if( chk_max(ans,s[i]/2) ) ans2 = i;
	printf("%lld %lld\n",ans,ans2);
	return 0;
}
```

思路懂了之后, 写起来的确是道`easy-implement`题(。﹏。)


---

## 作者：wwt100127 (赞：2)

## 题目描述

给定一些长度的木棍，两两组合，求可组成的长度组成数量的最大值和此时组成的长度。

## 思路

### First
设 $c_k$ 表示长度为 $k$ 的有多少个，$ans_k$ 表示答案是 $k$ 时，数量的最大值。

显然答案即求 $ans_k$ 的最大值。

容易想到 $ans_k$ 的表示如下：

$$
ans_k = \frac{1}{2} \sum_{i+j=k} \min(c_i,c_j)
$$

（其中的 $\frac{1}{2}$ 需要注意）

设 $K$ 表示一共有多少个 $c_i \ne 0$，则时间复杂度为 $O(K^2)$。

这种方法适用于 $K$ 较小的时候（或者说，所有的 $c_i$ 都比较大的时候）。

------------

### Second

我们接着往下想。

发现 $i+j=k$ 十分像卷积。

（~~废话，标签都告诉你了~~）

但是是对 $\min(c_i,c_j)$ 求和，考虑枚举 $\min(c_i,c_j)$。

$$
ans_k = \frac{1}{2} \sum_{i+j=k} \min(c_i,c_j)\\
= \frac{1}{2} \sum_{d=1}^{n} \sum_{i+j=k} [c_i \ge d][c_j \ge d]
$$

然后发现：复杂度似乎变高了？

我知道你很急，但你先别急。

设 $K$ 表示一共有多少个 $c_i \ne 0$，则时间复杂度是 $O(Km \log m)$。

------------

### Third
如果将以上两种合并呢（类似根号分治）？

不妨：当 $i \ge s$ 时用法一，$i \le s-1$ 时用法二。

则时间复杂度变成 $O(sm \log m + \frac{n^2}{s^2})$。

当 $s  m \log m = \frac{n^2}{s^2}$，即 $s= \sqrt[3]{ \frac{n^2}{m \log m} }$ 时时间复杂度最优。

不妨设 $n$，$m$ 在同一数量级，则 $s= \sqrt[3]{\frac{n}{ \log n}}$，时间复杂度为 $O((n^4 \log^2 n )^ \frac{1}{3} )$。


------------

### Last
两部分有重复计算，减去即可。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int read(){int x=0; bool flag=1; char ch=getchar();
	while(ch<'0' || ch>'9'){if(ch=='-') flag=0;ch=getchar();}
	while(ch>='0' && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return flag? x:-x;}
void write(int x,char ch=0){if(x<0) x=-x,putchar('-');
	static short s[35],top=-1;do{s[++top]=x%10;x/=10;}while(x);
	while(~top) putchar(s[top--]+48);if(ch) putchar(ch);}
int ksm(int a,int b,int p)
{
	int ans=1%p;
	while(b)
	{
		if(b&1)
		ans=ans*a%p;
		a=a*a%p;
		b>>=1;
	}
	return ans;
}
const int N=1e6+5;
const int Max_Num=13;
const int mod=998244353;
const int INF=0x3f3f3f3f3f3f3f3fll;
const int Base=3;
const int rBase=332748118;
int n,m;
int a[N];
int ans[N];

namespace NTT
{
	int A[N],rev[N];
	int limit,Li;
	void init()
	{
		limit=1,Li=0;
		while(limit<=m*2) limit<<=1,Li++;
		for(int i=0;i<limit;i++) rev[i]=((rev[i>>1]>>1)|((i&1)<<(Li-1)));
	}
	void Clear(int A[],int n){for(int i=0;i<n;i++) A[i]=0;}
	void solve(int F[],int t)
	{
		int i,j,mid;
		for(i=0;i<limit;i++)
		{
			if(i<rev[i])
			swap(F[i],F[rev[i]]);
		}
		
		for(mid=1;mid<limit;mid<<=1)
		{
			int step=ksm(t==1? Base:rBase,(mod-1)/(mid<<1),mod);
			for(i=0;i<limit;i+=(mid<<1))
			{
				int cur=1;
				for(j=0;j<mid;j++,cur=cur*step%mod)
				{
					int x=F[i+j],y=cur*F[i+j+mid]%mod;
					F[i+j]=(x+y)%mod;
					F[i+j+mid]=(x-y+mod)%mod;
				}
			}
		}
		
		if(t==-1)
		{
			int inv=ksm(limit,mod-2,mod);
			for(i=0;i<limit;i++)
			F[i]=F[i]*inv%mod;
		}
	}
	void Just_Do_It(int k)
	{
		int i;
		Clear(A,limit);
		for(i=1;i<=m;i++) A[i]=(a[i]>=k);
		solve(A,1);
		for(i=0;i<limit;i++) A[i]=A[i]*A[i];
		solve(A,-1);
		for(i=0;i<limit;i++) ans[i]+=A[i];
	}
}

vector<int> Wzn;
signed main()
{
	int i;
	n=read(),m=read();
	for(i=1;i<=n;i++) a[read()]++;
	NTT::init();
	for(i=1;i<=Max_Num;i++) NTT::Just_Do_It(i);
	
	for(i=1;i<=m;i++)
	{
		if(a[i]>Max_Num)
		Wzn.push_back(i);
	}
	for(auto i:Wzn)
	{
		for(auto j:Wzn)
		ans[i+j]+=min(a[i],a[j])-Max_Num;
	}
	for(i=1;i<NTT::limit;i++) ans[i]/=2;
	
	int Ans[2]={0,INF};
	for(i=1;i<NTT::limit;i++)
	{
		if(Ans[0]<ans[i] || (Ans[0]==ans[i] && Ans[1]>i))
		Ans[0]=ans[i],Ans[1]=i;
	}
	write(Ans[0],' '),write(Ans[1],'\n');
	return 0;
}
```

---

## 作者：Na2PtCl6 (赞：1)

设长度为 $i$ 的木棍的个数为 $cnt_i$，用原材料最多能拼成 $f_l$ 根长度为 $l$ 的木棍。
 
容易发现，只要求出每个大于零的 $f_l$，题目就解决了。

## 三个式子，三种暴力
### 一.
对于每个 $l$ 枚举可以组成它的 $i$ 和 $j$。

 $$f_l= \left\lfloor \frac{1}{2} \sum_{i,j \in[1,m],i+j=l} \min \{ cnt_i, cnt_j \} \right\rfloor$$
 
 总的时间复杂度 $O(m^2)$。
 ### 二.
 每次从原材料里选两种长度的木棍（也有可能等长）。
 $$f_l=\left\lfloor \frac{1}{2} \sum_{i,j\in a_k,  i+j=l}\min\{cnt_i,cnt_j\}\right\rfloor$$
 总的时间复杂度 $O(n^2)$。
 ### 三.
 把第一个式子写成卷积的形式。
 $$f_l=\left\lfloor \frac{1}{2} \sum_{i+j=l} \sum_{k=1}^n  [cnt_i\geq k][cnt_j\geq k] \right      \rfloor$$
 $$\quad=\left\lfloor \frac{1}{2}  \sum_{k=1}^n \sum_{i+j=l} [cnt_i\geq k][cnt_j\geq k]        \right\rfloor$$
 
 总的时间复杂度 $O(nm\operatorname{log}m)$。
 
 ## 优化
因为对于一个给定的 $t$，大于 $t$ 的 $cnt_i$
  的 $i$ 的个数只有 $O(\min\{\dfrac nt,m\})$ 个，所以就上根号分治那套，即小于等于 $t$ 的部分使用暴力三，而大于 $t$ 的部分使用暴力二。
  
一个要注意的点是两部分的计算有重复，在跑暴力二的时候别忘了减去之前多算的贡献。
  
 总的时间复杂度是 $O(tm\operatorname{log}m+(\dfrac{n}{t})^2)$，$t=\sqrt[3]{\dfrac{2n^2}{m\operatorname{log}m}}$ 时理论上最优。最终复杂度是 $O((nm\operatorname{log}m)^\frac2 3)$ 级别的，可过。
 ## 代码
 ```cpp
 #include<bits/stdc++.h>
using namespace std;
const int maxn=400004;
const double pi=acos(-1);
int n,m,l,tmp,lim=1,maxd,tot,res1,res2;
int a[maxn],cnt[maxn],r[maxn],g1[maxn],g2[maxn],id[maxn];

struct C{
	double a,b;
	C operator + (C &y)const{
		return (C){a+y.a,b+y.b};
	}
	C operator - (C &y)const{
		return (C){a-y.a,b-y.b};
	}
	C operator * (C &y)const{
		return (C){a*y.a-b*y.b,b*y.a+a*y.b};
	}
}zv,f[maxn];

void read(int &x){
	char c=getchar();x=0;
	for(;c<'0'||c>'9';c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=x*10+c-48;
}

int _min(const int &a,const int &b){ return a<b?a:b;}

void FFT(C *s,int op){
	for(int i=0;i<lim;i++)
		if(i<r[i])
			swap(s[i],s[r[i]]);
	for(int dep=1;dep<=maxd;dep++){
		int M=1<<dep;
		C wn=(C){cos(2.0*pi/M),op*sin(2.0*pi/M)};
		for(int i=0;i<lim;i+=M){
			C w=(C){1.0,0.0};
			for(int j=0;j<M/2;j++){
				C u=w*s[i+j+M/2],v=s[i+j];
				s[i+j]=v+u;
				s[i+j+M/2]=v-u;
				w=w*wn;
			}
		}
	}
	if(op==-1)
		for(int i=0;i<lim;i++)
			s[i].a=s[i].a/lim+0.5;
}

signed main(){
	read(n),read(m);
	int T=cbrt(n*n*1.0/(m*log2(m)));
	for(int i=1;i<=n;i++){
		read(a[i]);
		cnt[a[i]]++;
	}
	while(lim<=m*2){
		maxd++;
		lim<<=1;
	}
	for(int i=0;i<lim;i++)
		r[i]=(r[i>>1]>>1)|((i&1)<<(maxd-1));
	for(int i=1;i<=T;i++){
		for(int j=1;j<=m;j++)
			f[j].a=(cnt[j]>=i)?1:0;
		FFT(f,1);
		for(int j=0;j<lim;j++)
			f[j]=f[j]*f[j];
		FFT(f,-1);
		for(int j=0;j<lim;j++)
			g1[j]+=f[j].a;
		for(int j=0;j<lim;j++)
			f[j]=zv;
	}
	for(int i=1;i<=m;i++)
		if(cnt[i]>T)
			id[++tot]=i;
	for(int i=1;i<=tot;i++)
		for(int j=1;j<=tot;j++){
			g2[id[i]+id[j]]+=_min(cnt[id[i]],cnt[id[j]]);
			g1[id[i]+id[j]]-=T;
		}
	for(int i=1;i<lim;i++){
		int g=(g1[i]+g2[i])/2;
		if(g>res1){
			res1=g;
			res2=i;
		}
	}	
	printf("%d %d\n",res1,res2);
	return 0;
}
 ```

---


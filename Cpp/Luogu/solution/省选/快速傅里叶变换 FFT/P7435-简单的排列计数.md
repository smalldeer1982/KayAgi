# 简单的排列计数

## 题目描述

设 $\text{inv}_{\pi}$ 表示排列 $\pi$ 的逆序对数。如果 $\pi$ 长度为 $n$ 则有

$$\text{inv}_{\pi}=\sum\limits_{i=1}^{n}\sum\limits_{j=i+1}^{n}[\pi_i>\pi_j]$$

给定两个正整数 $n,k$，和一个排列 $\pi^\prime$，定义一个长度为 $n$ 的排列 $\pi$ 的权值 $\text{val}_{\pi}$ 为

$$\text{val}_{\pi}=\prod\limits_{i=1}^{n}\prod_{j=i+1}^{n}\pi_i^{[\pi_{i}>\pi_j]}$$

对于 $0\leq m\leq k$ 求

$$\sum\limits_{\pi}[\text{inv}_\pi=m]\text{val}_\pi$$

其中 $\pi$ 是长度为 $n$ 的排列。

## 说明/提示

### 样例解释 1

$$\text{inv}_{(1,2,3)}=0,\text{inv}_{(1,3,2)}=1,\text{inv}_{(2,1,3)}=1,\text{inv}_{(2,3,1)}=2,\text{inv}_{(3,1,2)}=2,\text{inv}_{(3,2,1)}=3$$

$$\text{val}_{(1,2,3)}=1,\text{val}_{(1,3,2)}=3,\text{val}_{(2,1,3)}=2,\text{val}_{(2,3,1)}=6,\text{val}_{(3,1,2)}=9,\text{val}_{(3,2,1)}=18$$

所以当 $m=0$ 时答案为 $1$，$m=1$ 时为 $5$， $m=2$ 时为 $15$，$m=3$ 时为 $18$。

### 数据范围

| 子任务编号 | 分值 | $n\leq $ | $k\leq $ |
| :----------: | :----------: | :----------: | :----------: |
| Subtask 1 | $1$ | $6$ |  |
| Subtask 2 | $12$ | $40$ |  |
| Subtask 3 | $1$ | $998244352$ | $1$ |
| Subtask 4 | $16$ | $998244352$ | $10$ |
| Subtask 5 | $24$ | $2\times 10^5$ |  |
| Subtask 6 | $46$ | $998244352$ |  |

对于 $100\%$ 的数据，$2\leq n\leq 998244352$，$1\leq k\leq \min(2\times 10^5,\frac{n(n-1)}{2})。$

## 样例 #1

### 输入

```
3 3```

### 输出

```
1 5 15 18```

# 题解

## 作者：ForgotMe (赞：15)

来写一篇比较好懂的题解。

## Part-1

首先拿到这题可能并没有太大感觉，甚至只会爆搜，但是一想到这是 kals 的题肯定是多项式和生成函数来优化一个什么东西，于是可以想到 dp。

令 $dp_{i,j}$ 表示 $1\sim i$ 的排列中有 $j$ 对逆序对的 $val_{\pi}$ 的权值和。

考虑怎么转移，发现插入 $i+1$ 后多出的逆序对只与插入的位置有关，因为插进去的这个数是比原来 $1\sim i$ 都大的，于是就很好转移了。

$$
dp_{i,j}=\sum_{k=0}^{\min(i-1,j)}dp_{i-1,j-k}\times i^k
$$

然后直接转移就行，时间复杂度 $\mathcal{O}(nk^2)$，可以获得 13pts。

## Part-2
考虑优化一下这个 dp，发现是一个卷积的形式，NTT 优化即可，但是还是 13pts，没啥用。

考虑一下这个 dp 的实际意义，相当于就是现在 $1\sim n$ 这 $n$ 个数，要给每个数分配一个权值 $b_i(b_i\le i-1)$，每种方案的权值为 $\prod_{i=1}^n i^{b_i}$，求所有方案的权值之和。

这个问题看起来比较简单，很容易可以用生成函数求解。

相当于现在有 $n$ 条多项式，其中第 $i$ 条多项式为：

$$
f_i(x)=1+ix+i^2x^2+...+i^{i-1}x^{i-1}
$$

于是 $ans_k=[x^k]\prod_{i=1}^n f_i(x)$。

挨着乘还是只有 13pts，但是发现 $f_i(x)$ 是一个等比数列的形式，然后就可以得到 $f_i(x)=\dfrac{1-i^ix^i}{1-ix}$。

现在 $ans_k=[x^k]\prod_{i=1}^n \dfrac{1-i^ix^i}{1-ix}$

直接做不太好做，考虑分成分子和分母来计算。

## Part-3-分子

要求 $\prod_{i=1}^n (1-i^ix^i)$。

直接做不好做，考虑取对数最后在 exp 回来，变成 
$$
\sum_{i=1}^n \ln(1-i^ix^i)
$$

后面这一坨很熟悉啊，不是 付公主的背包？

$$
\ln(1-i^ix^i)=\sum_{j=1}\dfrac{i^{i^j}x^{ij}}{j}
$$

具体证明可以直接用复合函数的求导和泰勒展开。

然后就很简单了，直接 $\mathcal{O}(\min(n,k)\log k)$ 跑一边调和级数，然后 exp 回去就行了。

## Part-4-分母

这是最恶心的部分。

要求 $\prod_{i=1}^n (1-ix)$ ，然后求逆回去。

这东西就不能直接套用刚才的做法了，因为直接预处理会 T 掉，当然也不是不能做，可以推柿子，具体见 GuidingStar 聚聚的题解。

不能去对数，那怎么办呢？**我们要求的只是求逆回去的东西**，于是考虑求逆回去的多项式第 $i$ 项的系数，说一下我比赛时的做法：

那就是找规律 ~~（找规律 txdy）~~。

当 $n=2$ 的时候，$(1-x)(1-2x)=2x^2-3x+1$，复制一下求逆的板子，可以得到系数为 `1 3 7 15 31`，就是 $2^n-1$，不过现在还不能下结论，继续找。

当 $n=3$ 的时候，$(2x^2-3x+1)(1-3x)=-6x^3+11x^2-6x+1$，可以得到系数为 `1 6 25 90 301`，自己发现不了啥规律，于是上 oeis，可以得到这么一句话 `	Stirling numbers of second kind S(n,3).`，第二类斯特林数中的第三列！！

于是猜测 $n=k$ 时，求逆后的系数为第 $k$ 列的第二类斯特林数（从 $1$ 开始），但是这题 $n$ 这么大怎么求？

发现第 $k$ 列第二类斯特林数的 EGF 为 $k!\sum_{i=0}\dfrac{S(i,k)x^i}{i!}=(e^x-1)^k$。

考虑多项式快速幂，但是 $e^x-1$ 的常数项为 $0$，多项式快速幂后会出现 $k-1$ 个零，这题的 $n$ 贼大，根本就存不下，于是不要这个常数项来多项式快速幂，最后除以 $k!$，但是因为是 EGF,还要乘上 $i!$，最后求出的东西就是从 $S(n,n)$ 开始的第二类斯特林数，但是你会发现这个 $k$（这个 $k$ 不是给出的那个 $k$，是给出的 $n$，要求第 $n$ 列的斯特林数） 贼大，别急，我不是还要乘上 $i!$，然后一抵消差就只有给出的 $k$ 的级别了。（可能会有点绕，不懂的可以看代码）。

最后两个多项式一乘，这个题就做完了。

时间复杂度 $\mathcal{O}(k\log k)$，但是常数极大，要跑两次 exp 和一次 ln。

为了防止直接 copy，这里给出部分代码：

```cpp
signed main(){
	init();
	scanf("%d %d",&n,&k);
	fac[0]=ifac[0]=1;
	for(int i=1;i<=k+1;i++)fac[i]=mul(fac[i-1],i);
	ifac[k+1]=qkpow(fac[k+1],mod-2);
	for(int i=k;i>=1;i--)ifac[i]=mul(ifac[i+1],i+1);
	for(int i=0;i<=k;i++)A[i]=ifac[i+1];
	Polyqkpow(A,B,n,k+1);
	int now=1; 
	for(int i=0;i<=k;i++){
		B[i]=mul(B[i],now);
		now=mul(now,n+i+1);
	}
	for(int i=1;i<=min(n,k);i++){
		int res=qkpow(i,i),fuck=res;
		for(int j=1;i*j<=k;j++,fuck=mul(fuck,res)){
			AA[i*j]=dec(AA[i*j],mul(Inv[j],fuck));
		}
	}
	PolyExp(AA,BB,k+1);
	int M=((k+1)<<1),N=1,l=0;
	for(;N<=M;N<<=1,l++);
	for(int i=0;i<N;i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
	NTT(B,1,N),NTT(BB,1,N);
	for(int i=0;i<N;i++)B[i]=mul(B[i],BB[i]);
	NTT(B,-1,N);
	for(int i=0;i<=k;i++)write((B[i]+mod)%mod),printf(" ");
    return 0;
} 
```

最后说几句，一定要一个常数小的多项式板子，不然你会 T 到怀疑人生，我还是在被卡哭了后发的帖子不要脸的让 kals 开到了 900ms，然后擦线过了（（（。

**The End**。

---

## 作者：Aleph1022 (赞：11)

让我们跳过 DP，快进到生成函数
$$
\prod\limits_{i=1}^n \frac{1-(ix)^i}{1-ix}
$$

反手一个 ln / exp，
$$
\exp \sum\limits_{i=1}^n (\ln (1-(ix)^i)-\ln(1-ix))
$$

然后
$$
\begin{aligned}
\sum\limits_{i=1}^n \ln (1-(ix)^i)
&= -\sum\limits_{i=1}^n \sum\limits_{j\ge 1}\frac{(ix)^{ij}}{j}
\end{aligned}
$$

所以只需要调和级数复杂度地直接计算即可。

然后
$$
\begin{aligned}
\sum\limits_{i=1}^n \ln (1-ix)
&= -\sum\limits_{i=1}^n \sum\limits_{j\ge 1}\frac{(ix)^j}{j} \\
&= -\sum\limits_{j\ge 1} \frac{x^j}{j} \sum\limits_{i=1}^n i^j \\
&= -\sum\limits_{j\ge 1} \frac{x^j}{j(j+1)} \sum\limits_{i=0}^j \binom{j+1}i B_i (n+1)^{j-i+1}
\end{aligned}
$$

其中 $\{B_i\}$ 为伯努利数，我们知道它的 EGF 即为 $\frac x{{\rm e}^x-1}$。  
因此做一次求逆做一次卷积即可。

时间复杂度 $O(k \log k)$。

---

另外，关于 @cqbzljsqwq 提到的「规律」，我们可以在 [Elegia：「营业日志 2020.5.20」](https://blog.csdn.net/EI_Captain/article/details/106243485) 中查阅到更强的结论和 EI 给出的四个角度的证明。

---

## 作者：Karry5307 (赞：6)

### 题意
设 $\text{inv}_{\pi}$ 表示排列 $\pi$ 的逆序对数。如果 $\pi$ 长度为 $n$ 则有

$$\text{inv}_{\pi}=\sum\limits_{i=1}^{n}\sum\limits_{j=i+1}^{n}[\pi_i>\pi_j]$$

给定两个正整数 $n,k$，和一个排列 $\pi^\prime$，定义一个长度为 $n$ 的排列 $\pi$ 的权值 $\text{val}_{\pi}$ 为

$$\text{val}_{\pi}=\prod\limits_{i=1}^{n}\prod_{j=i+1}^{n}\pi_i^{[\pi_{i}>\pi_j]}$$

对于 $0\leq m\leq k$ 求

$$\sum\limits_{\pi}[\text{inv}_\pi=m]\text{val}_\pi$$

其中 $\pi$ 是长度为 $n$ 的排列。

$\texttt{Data Range:}2\leq n\leq 998244352$，$1\leq k\leq \min(2\times 10^5,\frac{n(n-1)}{2})$。

### 题解

当时忘记上传出题人题解了，现在突然想起来这件事，所以补一发。

首先考虑 DP，设 $f_{i,j}$ 表示长度为 $i$ 逆序对数量为 $j$ 的所有排列的权值之和，那么有

$$f_{i,j}=\sum\limits_{k=0}^{i-1}i^kf_{i-1,j-k}$$

设 $F_i(x)$ 表示一行的 GF，则有

$$F_i(x)=F_{i-1}(x)\left(\sum\limits_{j=0}^{i-1}i^jx^j\right)$$

注意到右边是等比数列求和的形式，也即

$$F_i(x)=F_{i-1}(x)\frac{1-i^ix^i}{1-ix}$$

所以答案的 GF 为

$$\prod\limits_{i=1}^{n}\frac{1-i^ix^i}{1-ix}$$

显然考虑分成分母和分子两部分计算，先考虑计算分子，则有

$$\ln\left(\prod\limits_{i=1}^{n}1-i^ix^i\right)=\sum\limits_{i=1}^{n}\ln(1-i^ix^i)$$

有泰勒展开式：

$$\ln(1-ax^b)=-\sum\limits_{i=1}^{\infty}\frac{a^ix^{bi}}{i}$$

直接计算，这部分时间复杂度为 $O(k\log k)$，接下来考虑分母，很明显有

$$\prod\limits_{i=1}^{n}(1-ix)=\sum\limits_{i=0}^{n}(-1)^i\begin{bmatrix}n+1\\n+1-i\end{bmatrix}x^i$$

直接计算第一类斯特林数复杂度为 $O(n\log n)$，但是有更好的做法。注意到式子可以写成这样：

$$\prod\limits_{i=1}^{n-1}(1-ix)=\sum\limits_{i=0}^{n}(-1)^{i}\begin{bmatrix}n\\n-i\end{bmatrix}x^{i}$$

考虑直接算这个东西的逆，相当于我需要凑出一个 $f_n$ 使得

$$\sum\limits_{i=0}^{n}(-1)^{n-i}\begin{bmatrix}n\\i\end{bmatrix}f_{i}=[n=0]$$

这个时候我们马上想到了两类斯特林数之间的反转公式，然而直接做显得非常不好做，考虑将右边的 $[n=0]$ 换成 $[n=k]$，则有

$$\sum\limits_{i=0}^{n}(-1)^{n-i}\begin{bmatrix}n\\i\end{bmatrix}f_{i}=[n=k]$$

这个时候直接套公式有 $f_i=\begin{Bmatrix}i\\k\end{Bmatrix}$，所以将这个东西再平移回来，即 $f_i=\begin{Bmatrix}i+k\\k\end{Bmatrix}$。

这个很明显是一列第二类斯特林数的形式，直接求即可，复杂度 $O(k\log k)$。

### 代码

代码是三年前的。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
typedef unsigned long long int ull;
const ll MAXN=524291,MOD=998244353;
ll n,kk,x,r;
ll omgs[MAXN],fact[MAXN],finv[MAXN],invf[MAXN],f[MAXN],g[MAXN];
ll h[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline ll qpow(ll base,ll exponent)
{
    ll res=1;
    while(exponent)
    {
        if(exponent&1)
        {
            res=(li)res*base%MOD;
        }
        base=(li)base*base%MOD,exponent>>=1;
    }
    return res;
}
inline void setupOmg(ll cnt)
{
    ll limit=__lg(cnt)-1;
    omgs[0]=1,omgs[1<<limit]=qpow(31,1<<(21-limit));
    for(register int i=limit;i;i--)
    {
        omgs[1<<(i-1)]=(li)omgs[1<<i]*omgs[1<<i]%MOD;
    }
    for(register int i=1;i<cnt;i++)
    {
        omgs[i]=(li)omgs[i&(i-1)]*omgs[i&-i]%MOD;
    }
}
inline void setup(ll cnt)
{
    fact[0]=fact[1]=finv[0]=invf[1]=1;
    for(register int i=2;i<=cnt;i++)
    {
        fact[i]=(li)fact[i-1]*i%MOD,invf[i]=MOD-(li)(MOD/i)*invf[MOD%i]%MOD;
    }
	finv[cnt]=qpow(fact[cnt],MOD-2);
	for(register int i=cnt-1;i;i--)
	{
		finv[i]=(li)finv[i+1]*(i+1)%MOD;
	}
}
inline ll& reduce(ll &x)
{
	return x+=x>>31&MOD;
}
inline void DIF(ll *cp,ll cnt)
{
	ll lim=__lg(cnt),len=cnt>>1,x;
	for(register int i=0;i<lim;i++,len>>=1)
	{
		for(register int *j=cp,*omg=omgs;j!=cp+cnt;j+=len<<1,omg++)
		{
			for(register int *k=j;k!=j+len;k++)
			{
				x=(li)*omg*k[len]%MOD,reduce(k[len]=*k-x),reduce(*k+=x-MOD);
			}
		}
	}
}
inline void DIT(ll *cp,ll cnt)
{
	ll lim=__lg(cnt),len=1,x,invl;
	for(register int i=0;i<lim;i++,len<<=1)
	{
		for(register int *j=cp,*omg=omgs;j!=cp+cnt;j+=len<<1,omg++)
		{
			for(register int *k=j;k!=j+len;k++)
			{
				reduce(x=*k+k[len]-MOD);
				k[len]=(li)(*k-k[len]+MOD)**omg%MOD,*k=x;
			}
		}
	}
	reverse(cp+1,cp+cnt),invl=MOD-(MOD-1)/cnt;
	for(register int i=0;i<cnt;i++)
	{
		cp[i]=(li)cp[i]*invl%MOD;
	}
}
inline void NTT(ll *cp,ll cnt,ll inv)
{
    inv==1?DIF(cp,cnt):DIT(cp,cnt);
}
inline void deriv(ll fd,ll *f,ll *res)
{
    for(register int i=1;i<fd;i++)
    {
        res[i-1]=(li)f[i]*i%MOD;
    }
    res[fd-1]=0;
}
inline void integ(ll fd,ll *f,ll *res)
{
    for(register int i=1;i<fd;i++)
    {
        res[i]=(li)f[i-1]*invf[i]%MOD;
    }
    res[0]=0;
}
inline void conv(ll fd,ll *f,ll *g,ll *res)
{
    static ll tmpf[MAXN],tmpg[MAXN];
    ll cnt=1,limit=-1;
    while(cnt<(fd<<1))
    {
        cnt<<=1,limit++;
    }
    for(register int i=0;i<cnt;i++)
    {
		tmpf[i]=i<fd?f[i]:0,tmpg[i]=i<fd?g[i]:0;
    }
    NTT(tmpf,cnt,1),NTT(tmpg,cnt,1);
    for(register int i=0;i<cnt;i++)
    {
		tmpf[i]=(li)tmpf[i]*tmpg[i]%MOD;
    }
    NTT(tmpf,cnt,-1),memcpy(res,tmpf,fd<<2);
}
inline void inv(ll fd,ll *f,ll *res)
{
	static ll tmp[MAXN],tmpr[MAXN];
	ll cnt=2,limit=0;
	tmpr[0]=res[0]=qpow(f[0],MOD-2);
	while(cnt<(fd<<1))
	{
		for(register int i=0;i<cnt;i++)
		{
			tmp[i]=f[i],tmpr[i]=i<(cnt>>1)?res[i]:0;
		}
		NTT(tmp,cnt,1),NTT(tmpr,cnt,1);
		for(register int i=0;i<cnt;i++)
		{
			tmp[i]=(li)tmp[i]*tmpr[i]%MOD;
		}
		NTT(tmp,cnt,-1),memset(tmp,0,cnt<<1),NTT(tmp,cnt,1);
		for(register int i=0;i<cnt;i++)
		{
			tmp[i]=(li)tmp[i]*tmpr[i]%MOD;
		}
		NTT(tmp,cnt,-1);
		for(register int i=(cnt>>1);i<cnt;i++)
		{
			res[i]=!tmp[i]?0:MOD-tmp[i];
		}
		cnt<<=1,limit++;
	}
	for(register int i=fd;i<cnt;i++)
	{
		res[i]=0;
	}
}
inline void lnDeriv(ll fd,ll *f,ll *res)
{
	static ll tmp[MAXN],tmp2[MAXN],tmp3[MAXN],tmp4[MAXN];
	ll cnt=1,r,invr;
	if(fd<=1)
	{
		return (void)(res[0]=(li)f[0]*qpow(f[0],MOD-2));
	}
	while(cnt<=fd)
	{
		cnt<<=1;
	}
	inv(cnt>>1,f,tmp4),deriv(fd,f,tmp),memcpy(tmp3,tmp,cnt<<1);
	for(register int i=0;i<cnt;i++)
	{
		tmp2[i]=i<(cnt>>1)?tmp4[i]:0,tmp3[i]=i<(cnt>>1)?tmp3[i]:0; 
	}
	NTT(tmp2,cnt,1),NTT(tmp3,cnt,1);
	for(register int i=0;i<cnt;i++)
	{
		res[i]=tmp3[i]=(li)tmp3[i]*tmp2[i]%MOD;
	}
	NTT(res,cnt,-1),r=MOD-(MOD-1)/cnt,invr=qpow(r,MOD-2);
	for(register int i=0;i<cnt;i++)
	{
		res[i]=tmp4[i]=i<(cnt>>1)?res[i]:0,tmp3[i]=f[i];
	}
	NTT(tmp3,cnt,1),NTT(tmp4,cnt,1);
	for(register int i=0;i<cnt;i++)
	{
		tmp3[i]=(li)tmp3[i]*tmp4[i]%MOD;
	}
	NTT(tmp3,cnt,-1),reverse(tmp3+1,tmp3+cnt);
	for(register int i=(cnt>>1);i<cnt;i++)
	{
		tmp3[i]=(tmp3[cnt-i]+MOD-tmp[i])%MOD;
	}
	for(register int i=0;i<(cnt>>1);i++)
	{
		tmp3[i]=(li)tmp3[i]*invr%MOD;
	}
	memset(tmp3,0,cnt<<1),NTT(tmp3,cnt,1);
	for(register int i=0;i<cnt;i++)
	{
		tmp3[i]=(li)tmp3[i]*tmp2[i]%MOD;
	}
	NTT(tmp3,cnt,-1);
	for(register int i=cnt>>1;i<cnt;i++)
	{
		res[i]=MOD-tmp3[i];
	}
}
inline void ln(ll fd,ll *f,ll *res)
{
	static ll der[MAXN];
	lnDeriv(fd,f,der),integ(fd,der,res);
}
inline void exp(ll fd,ll *f,ll *res)
{
    static ll texp[MAXN];
    if(fd==1)
    {
        return (void)(res[0]=1);
    }
    exp((fd+1)>>1,f,res),ln(fd,res,texp),texp[0]=(f[0]+1-texp[0]+MOD)%MOD;
    for(register int i=1;i<fd;++i)
    {
        texp[i]=(f[i]-texp[i]+MOD)%MOD;
    }
    conv(fd,texp,res,res);
}
int main()
{
    n=read(),setupOmg(524288),setup((kk=read())+5);
    for(register int i=0;i<=kk;i++)
    {
    	f[i]=finv[i+1];
	}
	ln(kk+1,f,g);
	for(register int i=0;i<=kk;i++)
	{
		g[i]=(li)g[i]*n%MOD,f[i]=0;
	}
	exp(kk+1,g,f),x=1;
	for(register int i=0;i<=kk;i++)
	{
		f[i]=(li)f[i]*x%MOD,x=(li)x*(i+n+1)%MOD,g[i]=0;
	}
	for(register int i=1;i<=min(n,kk);i++)
	{
		x=1,r=qpow(i,i);
		for(register int j=i,k=1;j<=kk;j+=i,k++)
		{
			x=(li)x*r%MOD,h[j]=(h[j]+(li)x*invf[k])%MOD;
		}
	}
	for(register int i=0;i<=kk;i++)
	{
		h[i]=!h[i]?0:MOD-h[i];
	}
	exp(kk+1,h,g),conv(kk+1,f,g,f);
	for(register int i=0;i<=kk;i++)
	{
		printf("%d ",f[i]);
	}
}
```

---

## 作者：peterwuyihong (赞：2)

颓废记录

题意：对于所有小于等于 $m$ 的 $G$，求出所有逆序对个数等于 $G$ 的排列的权值和，对于排列 $\pi$，权值和为

$$\sum_{i=1}^n\sum_{r=i+1}^n\pi_i^{[\pi_i>\pi_j]}$$

[前置芝士](https://www.luogu.com.cn/blog/Peterprpr/loj6077-2017-shan-dong-yi-lun-ji-xun-day7-ni-xu-dui-ji-lu)，即

> 注意到每次添加一个数 $a_i$ ，必然增加逆序对数量 $c_i$ ，其中 $c_i\in[0,i-1]$

于是你 $一眼$ 出来如果给定一个序列 $c_{[1,n]}$，则必然能复原出一个 $a_{[1,n]}$，他们是一一对应的。

于是你换而枚举 $c$ 数组，就是对所有满足 $\sum_{i=1}^nc_i=k$，且 $c_i\in[0,i-1]$，求出 $\sum_{i=1}^ni^{c_i}$。

转换非常高妙，根本不需要用到动态规划。

于是你构造母函数

$$(1)(1+2x)(1+3x+(3x)^2)(1+4x+(4x)^2+(4x)^3)\ldots$$

$$=\prod_{i=1}^n\frac{1-(ix)^i}{1-ix}$$

$$=\exp(\sum_{i=1}^n\ln(1-(ix)^i)-\ln(1-ix))$$

你泰勒展开一下。

$$=\exp(-\sum_{i=1}^n\sum_{j\ge1}\frac{(ix)^{ij}}{j}-\frac{(ix)^j}{j})$$

$$=\exp(-\sum_{j\ge1}j^{-1}\sum_{i=1}^n((ix)^j)^{i}-(ix)^j)$$

$$=\exp(-\sum_{j\ge1}j^{-1}(\sum_{i=1}^n((ix)^j)^{i}-(ix)^j))$$

对于这个 $((ix)^j)^i$，它是一个调和级别的，于是思索如何求后面这个东西

$$\exp(\sum_{j\ge1}j^{-1}\sum_{i=1}^n(ix)^j)=\exp(\sum_{j\ge1}\frac{x^j}{j}\sum_{i=1}^ni^j)$$

$$\exp(\sum_{j\ge1}\frac{x^j}{j}(j+1)^{-1}\sum_{i=0}^j\binom{j+1}iB_i(n+1)^{j-i+1})$$

$$\exp(\sum_{j\ge1}\frac{x^j}{j}(j+1)^{-1}(-B_{j+1}+\sum_{i=0}^{j+1}\binom{j+1}iB_i(n+1)^{j-i+1}))$$

$$\exp(\sum_{j\ge1}\frac{x^j}{j}(j+1)^{-1}(-B_{j+1}+(j+1)!\sum_{i=0}^{j+1}\frac{B_i}{i!}\frac{(n+1)^{j-i+1}}{(j-i+1)!})$$

你先把伯努利数解出来，然后这里卷积一下就行了。

```cpp
int n,k;
signed main(){
	cin>>n>>k;
	init(extend(k+5));
	poly B(k+2);
	rep(i,0,k+1)B[i]=jcinv[i+1];
	B=Inv(B);
	rep(i,0,k+1)mul(B[i],jc[i]);
	poly C(k+2),D(k+2);
	int u=1;
	rep(i,0,k+1){
		C[i]=Mul(B[i],jcinv[i]);
		D[i]=Mul(u,jcinv[i]);
		mul(u,n+1);
	}
	C=C*D;
	C.resize(k+2);
	poly ans(k+1);
	rep(i,1,min(k,n)){//注意此处的定义，i本来应该≤n的 
		int g=ksm(i,i),w=g;
		for(int j=1;i*j<=k;j++,mul(w,g))
		sub(ans[i*j],Mul(inv[j],w));
	}
	rep(j,1,k)add(ans[j],Mul(Mul(inv[j],inv[j+1]),Sub(Mul(jc[j+1],C[j+1]),B[j+1])));
	ans=Exp(ans);
	Print(ans);
}
```
中间有坑，$\text{WA}$ 了一会儿。

但是我前面 $\ln$ 的泰勒展开记错了！我把负号吃了！导致我调了一年！

上面是我的多项式板子，[安利一波](https://www.luogu.com.cn/blog/Peterprpr/mu-ban)。

---

## 作者：Argon_Cube (赞：1)

~~似乎真的是相对简单的套路题？~~

那个权值的意思就是序列中每一个逆序对较大数的乘积。

然后我们就有一个简单的暴力递推，设 $f_{n,m}$ 为长度为 $n$ 的有 $m$ 个逆序对的排列的权值和。我们枚举 $n$ 的位置，如果它后面有 $i$ 个数就会多出 $i$ 个逆序对并让排列的权值乘上 $n^i$，于是

$$f_{n,m}=\sum_{i=0}^{n-1}n^if_{n-1,m-i}$$

然后就有生成函数的形式了：

$$F_n(x)=\frac{1-(nx)^n}{1-nx}F_{n-1}(x),F_0(x)=1$$

注意到这是一个不好处理的连乘的形式，我们套路的 $\ln$  然后 $\exp$ 回去：

$$F_n(x)=\prod_{i=1}^n\frac{1-(ix)^i}{1-ix}=\exp\left(\sum_{i=1}^n\ln(1-i^ix^i)-\ln(1-ix)\right)$$

显然要把分子分母分开计算。

考虑分母，套路的将 $\ln$ 求导再积分即可直接得到每一项系数：

$$\sum_{i=1}^n-\int\frac{\mathrm d}{\mathrm dx}\ln(1-ix)\mathrm dx=\sum_{i=1}^n\int\frac{i}{1-ix}\mathrm dx=\sum_{i=1}^n i\int \sum_{j=0} i^{j}x^j=\sum_{j=1}\left(\sum_{i=1}^n i^{j}\right)\frac{x^{j}}{j}$$

难点在于如何得到自然数幂前缀和，这是一个经典问题。我们求它的 EGF：

$$\sum_{j=0}\left(\sum_{i=0}^n i^{j}\right)\frac{x^j}{j!}=\sum_{i=0}^ne^{ix}=\frac{1-e^{(n+1)x}}{1-e^x}$$

注意到上下两项常数项均为零，消去因子 $x$ 即可。一次求逆加一次乘法，$\Theta(k\log k)$。

使用与分母完全相同的方法可得到分子：

$$\sum_{i=1}^n\ln(1-(ix)^i)=-\sum_{i=1}^n \sum_{j=1} \frac{(ix)^{ij}}{j}$$

暴力计算每项系数即可 $\Theta(\min(n,k)\log k)$。

最后两个一加做一次 $\exp$ 就做完了。

---

## 作者：TianTian2008 (赞：0)

思维难度较低，关键在于如何计算多项式。

发现一个元素造成的贡献只和比它小且位置在其后的元素个数有关。不妨考虑已经有一个 $n-1$ 的排列，现在要把元素 $n$ 插入其中。若插入在当前排列最后一个元素后则新增了 $0$ 个逆序对、造成了 $\times1$ 的贡献；若插入在当前排列最后一个元素前则新增了 $1$ 个逆序对、造成了 $\times n$ 的贡献；若插入在当前排列倒数第二个元素前则新增了 $2$ 个逆序对、造成了 $\times n^2$ 的贡献；以此类推。

显然答案的生成函数是：

$\begin{aligned}
&(1)(1+2x)(1+3x+9x^2)\cdots\\
=&\prod\limits_{i=1}^n\sum\limits_{j=0}^{i-1}(ix)^j\\
=&\prod\limits_{i=1}^n\frac{1-i^ix^i}{1-ix}
\end{aligned}$

分子可以用经典套路转积为和：

$\begin{aligned}
&\prod\limits_{i=1}^n(1-i^ix^i)=\exp\sum\limits_{i=1}^n\ln(1-i^ix^i)\\
\because&\ln'(1-k^kx^k)\\
=&\frac{(1-k^kx^k)'}{1-k^kx^k}\\
=&\frac{-k^{k+1}x^{k-1}}{1-k^kx^k}\\
=&\sum\limits_{i=0}^\infty(k^kx^k)^i(-k^{k+1}x^{k-1})\\
=&-\sum\limits_{i=0}^\infty k^{k(i+1)+1}x^{k(i+1)-1}\\
\therefore&\ln(1-k^kx^k)\\
=&\int\ln'(1-k^kx^k)\text dx+C\\
=&\int(-\sum\limits_{i=0}^\infty k^{k(i+1)+1}x^{k(i+1)-1})\text dx+C\\
=&-\sum\limits_{i=0}^\infty\frac{k^{k(i+1)+1}}{k(i+1)}x^{k(i+1)}+C\\
=&-\sum\limits_{i=1}^\infty\frac{k^{ki}}{i}x^{ki}+C\\
\because&[x^0]\ln(1-k^kx^k)=\ln(1-k^k0^k)=\ln1=0\\
\therefore&C=0\\
\therefore&\ln(1-k^kx^k)=-\sum\limits_{i=1}^\infty\frac{k^{ki}}{i}x^{ki}\\
&\prod\limits_{i=1}^n(1-i^ix^i)=\exp-\sum\limits_{i=1}^n\sum\limits_{j=1}^\infty\frac{i^{ij}}jx^{ij}
\end{aligned}$

这个和式可以直接 $O(n\ln n)$ 暴力处理出来。

分母再次套用转积为和：

$\begin{aligned}
&\prod\limits_{i=1}^n\frac1{1-ix}=\exp\sum\limits_{i=1}^n\ln\frac1{1-ix}\\
\because&\ln'\frac1{1-kx}\\
=&(1-kx)(\frac1{1-kx})'\\
=&(1-kx)(-\frac{(1-kx)'}{(1-kx)^2})\\
=&\frac k{1-kx}\\
=&\sum\limits_{i=0}^\infty k^{i+1}x^i\\
\therefore&\ln\frac1{1-kx}\\
=&\int\sum\limits_{i=0}^\infty k^{i+1}x^i\text dx+C\\
=&\sum\limits_{i=1}^\infty\frac{k^i}ix^i+C\\
\because&[x^0]\ln\frac1{1-kx}=\ln\frac1{1-k\cdot0}=\ln1=0\\
\therefore&C=0\\
\therefore&\ln\frac1{1-kx}=\sum\limits_{i=1}^\infty\frac{k^i}ix^i\\
&\prod\limits_{i=1}^n\frac1{1-ix}=\exp\sum\limits_{i=1}^n\sum\limits_{j=1}^\infty\frac{i^j}jx^j
\end{aligned}$

化简到这里似乎就僵住了，因为这个和式暴力处理是 $O(n^2)$ 的。那么我们试着转化一下形式，看看能否让求和变简单：

$\begin{aligned}
\because&e^{kx}=\sum\limits_{i=0}^\infty\frac{k^i}{i!}x^i\\
\therefore&\frac{e^{kx}-1}x=\sum\limits_{i=0}^\infty\frac{\frac{k^{i+1}}{i+1}}{i!}x^i\\
\therefore&\int\frac{e^{kx}-1}x\text dx=\sum\limits_{i=1}^\infty\frac{\frac{k^i}i}{i!}x^i\\
\therefore&\sum\limits_{i=1}^n\sum\limits_{j=1}^\infty\frac{i^j}jx^j=\sum\limits_{i=1}^n\sum\limits_{j=1}^\infty([\frac{x^j}{j!}]\int\frac{e^{ix}-1}x\text dx)x^j\\
\therefore&[x^n]\sum\limits_{i=1}^n\sum\limits_{j=1}^\infty\frac{i^j}jx^j\\
=&[\frac{x^n}{n!}]\sum\limits_{i=1}^n\int\frac{e^{ix}-1}x\text dx\\
=&[\frac{x^n}{n!}]\int\frac1x\sum\limits_{i=1}^n(e^{ix}-1)\text dx\\
=&[\frac{x^n}{n!}]\int\frac1x(\frac{e^x-e^{(n+1)x}}{1-e^x}-n)\text dx
\end{aligned}$

我们成功地将原和式经过一系列变形，变为了一个等比数列求和！求出这个 $\text{EGF}$ 再转回 $\text{OGF}$，就得出了答案生成函数的分母。

（然而被卡常了，现在还过不去T_T）

---

## 作者：masterhuang (赞：0)

推销[博客](https://www.cnblogs.com/HaHeHyt/p/17624380.html)！

前置芝士：伯努利数等幂求和。其中伯努利数 $B_i$ 的生成函数为 $\frac{x}{e^x-1}$。

---
首先这种逆序对有个套路的 **dp**：令 $f_{i,j}$ 表示填了前 $i$ 个数，逆序对为 $j$，这时排列的 $val_{\pi}$ 的乘积之和。

有转移：$f_{i,j}=\sum\limits_{k=0}^{i-1} f_{i-1,j-k}i^k$，初始 $f_{0,0}=1$。

看到出题人为卡老师想到多项式。令 $f_n(x)=\sum\limits_{i=0}^m f_{n,i}x^i$，则转移变成：$f_n(x)=\sum\limits_{k=0}^{n-1} f_{n-1}(x)x^kn^k=\dfrac{f_{n-1}(x)(1-(nx)^n)}{1-nx}$。

于是 $f_n(x)=\prod\limits_{i=1}^n \dfrac{1-(ix)^i}{1-ix}$，要求其 $0\sim m$ 次项。

## 上面：

$\prod\limits_{i=1}^n (1-(ix)^i)=\exp(\sum\limits_{i=1}^n \ln(1-(ix)^i))=\exp\left(-\sum\limits_{i=1}^n\sum\limits_{j=1}^m\dfrac{(ix)^{ij}}{j}\right)$。

由于只需求其 $0\sim m$ 次项，于是枚举 $i,j$ 的复杂度为 $O(m\log m)$。总复杂度 $O(m\log m)$，因为实现精细能规避快速幂。注意 $i$ 的枚举范围时 $1\sim \min(n,m)$。

## 下面：

$\prod\limits_{i=1}^n (1-ix)^{-1}=\exp(-\sum\limits_{i=1}^n \ln(1-ix))=\exp\left(\sum\limits_{i=1}^n\sum\limits_{j=1}^m\dfrac{(ix)^j}{j}\right)$ 。

考虑令 $\exp$ 里面的式子为 $f(x)$，则 $f(x)=\sum\limits_{j=1}^m \dfrac{x^j}{j}\sum\limits_{i=1}^n i^j$。

注意到里面为等幂求和，有：$\sum\limits_{i=1}^n i^j=\frac{1}{j+1}\sum\limits_{i=0}^j\binom{j+1}{i}B_i(n+1)^{j+1-i}$。

于是 $f(x)=\sum\limits_{j=1}^m \dfrac{x^j}{j(j+1)}\sum\limits_{i=0}^j(j+1)!\times \dfrac{B_i (n+1)^{j+1-i}}{i!(j+1-i)!}=\sum\limits_{j=1}^m x^j(j-1)!\sum\limits_{i=0}^j\dfrac{B_i}{i!}\times \dfrac{(n+1)^{j+1-i}}{(j+1-i)!}$。

令 $a_i=\dfrac{B_i}{i!},b_i=\dfrac{(n+1)^{i+1}}{(i+1)!}$，则把 $a,b$ 卷积就是后半部分，最后第 $j$ 项系数乘个 $(j-1)!$ 即可。

---

注意到我们已经把分母 $-1$ 次方了，于是最后求出的分子分母两个多项式做一个卷积即可，复杂度 $O(m\log m)$，常数较大。

代码：

```cpp
#include<bits/stdc++.h>
#define fr(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);
#define LL long long
using namespace std;
const int mod=998244353,N=4e6+5;
int n,m,Bo[N],a[N],b[N],c[N],w[N],jc[N],inv[N],I[N],mmax;
inline int rd()
{
    int x=0,zf=1;char ch=getchar();
    while(ch<'0'||ch>'9') (ch=='-')and(zf=-1),ch=getchar();
    while(ch>='0'&&ch<='9') x=((x<<3)+(x<<1)+ch-'0')%mod,ch=getchar();
    return x*zf;
}
inline void wr(int x)
{
    if(x==0) return putchar('0'),putchar(' '),void();
    int num[35],len=0;
    while(x) num[++len]=x%10,x/=10;
    for(int i=len;i>=1;i--) putchar(num[i]+'0');
    putchar(' ');
}
inline int bger(int x){return x|=x>>1,x|=x>>2,x|=x>>4,x|=x>>8,x|=x>>16,x+1;}
inline int md(int x){return x>=mod?x-mod:x;}
inline int yy(int x){if(x&1) return (x+mod)>>1;return x>>1;}
inline int ksm(int x,int p){int s=1;for(;p;(p&1)&&(s=1ll*s*x%mod),x=1ll*x*x%mod,p>>=1);return s;}
inline void dao(int *a,int n){for(int i=1;i<n;i++) a[i-1]=1ll*i*a[i]%mod;a[n-1]=0;}
inline void ji(int *a,int n){for(int i=n-1;i>=1;i--) a[i]=1ll*ksm(i,mod-2)*a[i-1]%mod;a[0]=0;}
inline void init(int mmax)
{
	for(int i=1,j,k;i<mmax;i<<=1)
		for(w[j=i]=1,k=ksm(3,(mod-1)/(i<<1)),j++;j<(i<<1);j++)
			w[j]=1ll*w[j-1]*k%mod;
}
inline void DNT(int *a,int mmax)
{
	for(int i,j,k=mmax>>1,L,*W,*x,*y,z;k;k>>=1)
		for(L=k<<1,i=0;i<mmax;i+=L)
			for(j=0,W=w+k,x=a+i,y=x+k;j<k;j++,W++,x++,y++)
				*y=1ll*(*x+mod-(z=*y))* *W%mod,*x=md(*x+z);
}
inline void IDNT(int *a,int mmax)
{
	for(int i,j,k=1,L,*W,*x,*y,z;k<mmax;k<<=1)
		for(L=k<<1,i=0;i<mmax;i+=L)
			for(j=0,W=w+k,x=a+i,y=x+k;j<k;j++,W++,x++,y++)
				z=1ll* *W* *y%mod,*y=md(*x+mod-z),*x=md(*x+z);
	reverse(a+1,a+mmax);
	for(int inv=ksm(mmax,mod-2),i=0;i<mmax;i++) a[i]=1ll*a[i]*inv%mod;
}
inline void NTT(int *a,int *b,int n,int m)
{
	mmax=bger(n+m);init(mmax);
	DNT(a,mmax);DNT(b,mmax);
	for(int i=0;i<mmax;i++) a[i]=1ll*a[i]*b[i]%mod;
	IDNT(a,mmax);
}
void INV(int num,int *a,int *b)
{
	if(num==1) return b[0]=ksm(a[0],mod-2),void();INV((num+1)>>1,a,b);
	int mmax=bger(num<<1);init(mmax);static int c[N];
	for(int i=0;i<num;i++) c[i]=a[i];for(int i=num;i<mmax;i++) c[i]=0;DNT(c,mmax);DNT(b,mmax);
	for(int i=0;i<mmax;i++) b[i]=1ll*(2-1ll*c[i]*b[i]%mod+mod)%mod*b[i]%mod;IDNT(b,mmax);
	for(int i=num;i<mmax;i++) b[i]=0;
}
inline void Ln(int *a,int n){static int b[N];for(int i=0;i<bger(n<<1);i++) b[i]=0;INV(n,a,b);dao(a,n);NTT(a,b,n,n);ji(a,n);for(int i=n;i<bger(n<<1);i++) a[i]=0;}
inline void Exp(int *a,int *b,int n)
{
	if(n==1) return b[0]=1,void();
	Exp(a,b,(n+1)>>1);static int c[N];for(int i=0;i<bger(n<<1);i++) c[i]=0;
	for(int i=0;i<n;i++) c[i]=b[i];Ln(c,n);
	for(int i=0;i<n;i++) c[i]=md(mod-c[i]+a[i]);c[0]=md(c[0]+1);
	NTT(b,c,n,n);for(int i=n;i<bger(n<<1);i++) b[i]=0;
}
int main()
{
	n=rd();m=rd()+1;for(int i=jc[0]=1;i<=m;i++) jc[i]=1ll*jc[i-1]*i%mod;
	inv[m]=ksm(jc[m],mod-2);for(int i=m-1;~i;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;
	for(int i=0;i<m;i++) a[i]=inv[i+1],I[i]=ksm(i,mod-2);INV(m,a,Bo);
	for(int i=0;i<m;i++) a[i]=Bo[i],b[i]=1ll*ksm(n+1,i+1)*inv[i+1]%mod;
	NTT(a,b,m-1,m-1);for(int i=m;i<mmax;i++) a[i]=b[i]=0;
    a[0]=b[0]=0;for(int i=1;i<m;i++) a[i]=1ll*a[i]*jc[i-1]%mod,b[i]=0;
	Exp(a,b,m);for(int i=0;i<mmax;i++) a[i]=0;
	for(int i=1;i<min(m,n+1);i++) for(int j=1,w=ksm(i,i),s=w;j*i<m;j++,s=1ll*s*w%mod) a[i*j]=(a[i*j]+1ll*s*I[j])%mod;
	for(int i=1;i<m;i++) a[i]=mod-a[i];Exp(a,c,m);NTT(b,c,m-1,m-1);
	for(int i=0;i<m;i++) wr(b[i]);
	return 0;
}
```

---

## 作者：_abcd_ (赞：0)

## [[P7435] 简单的排列计数](https://www.luogu.com.cn/problem/P7435)

考虑从小到大依次将每个数插入序列，那么显然每次插入 $i$ 都可以增加 $j$ 个逆序对和 $i^j$ 的权值 $(j \in [0,i))$。那么就能直接 $\text{dp}$ 了。

考虑优化，发现每次插入 $i$ 就相当于乘上了 $\frac {1-(ix)^i}{1-ix}$。那么最后的答案就是

$$\prod\limits_{i=1}^n \frac {1-(ix)^i}{1-ix}$$
$$=\prod\limits_{i=1}^n \frac {\exp(\ln(1-(ix)^i))}{\exp(\ln(1-ix))}$$
$$=exp(\sum\limits_{i=1}^n \ln(1-(ix)^i)-\ln(1-ix))$$
$$=\exp(\sum\limits_{i=1}^n \int \frac {-i^{i+1}x^{i-1}}{1-(ix)^i}dx-\int \frac {-i}{1-ix}dx)$$
$$=\exp(\int (\sum\limits_{i=1}^n \sum\limits_{j \ge 0} -i^{i+1} x^{i-1} (ix)^{ij} - \sum\limits_{i=1}^n \sum\limits_{j \ge 0} - i(ix)^j)dx)$$
$$=\exp(\sum\limits_{i=1}^n \sum\limits_{j \ge 1} - \frac{i^{ij} x^{ij}}j + \sum\limits_{i=1}^n \sum\limits_{j \ge 1} \frac {i^j x^j}j)$$

对于前面的和式，只需要暴力算就行了，~~~~复杂度为调和级数 $O(n \log n)$。

对于后面的和式，发现

$$\sum\limits_{i=0}^n \sum\limits_{j \ge 0} \frac {(ix)^j}{j!}$$
$$\sum\limits_{i=0}^n \sum\limits_{j \ge 0} \frac {(ix)^j}{j!}$$
$$=\sum\limits_{i=0}^n e^{ix}$$
$$=\frac {1-e^{(n+1)x}}{1-e^x}$$

算出来后将 $0$ 次项置为 $0$，并且将 $i$ 次项乘上 $(i-1)!$ 就行了。最后复杂度 $O(n \log n)$。

### Code:
```cpp
#include<bits/stdc++.h>
#define ll long long
#define pn putchar('\n')
#define mset(a,x) memset(a,x,sizeof a)
#define mcpy(a,b) memcpy(a,b,sizeof a)
#define all(a) a.begin(),a.end()
#define fls() fflush(stdout)
#define int ll
#define mod 998244353
#define N 524288
#define maxn 200005
using namespace std;
int re()
{
    int x=0;
    bool t=1;
    char ch=getchar();
    while(ch>'9'||ch<'0')
        t=ch=='-'?0:t,ch=getchar();
    while(ch>='0'&&ch<='9')
        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return t?x:-x;
}
int ksm(int x,int y)
{
    int ret=1;
    while(y)
    {
        if(y&1)ret=ret*x%mod;
        x=x*x%mod,y>>=1;
    }
    return ret;
}
void dq(int &x)
{
    if(x>=mod)x-=mod;
    if(x<0)x+=mod;
}
void swap(int& x,int& y)
{
    x^=y^=x^=y;
}
namespace polynomial
{
    int gn[N<<1],gi[N<<1],rev[N<<1],iv[N+1];
    void poly_init()
    {
        for(int i=1;i<=N;i<<=1)
        {
            gn[i]=ksm(3,(mod-1)/i);
            gi[i]=ksm(gn[i],i-1);
        }
        gn[0]=gi[0]=1;
        for(int i=1;i<N<<1;i++)
        {
            int j=1<<__lg(i);
            gn[i]=gn[i-1]*gn[j]%mod;
            gi[i]=gi[i-1]*gi[j]%mod;
        }
        for(int i=2;i<=N;i<<=1)
        {
            for(int j=i;j<i<<1;j++)
            {
                rev[j]=rev[j-i>>1|i]>>1;
                if(j&1)
                    rev[j]|=i>>1;
            }
        }
        iv[0]=iv[1]=1;
        for(int i=2;i<=N;i++)
            iv[i]=(mod-mod/i)*iv[mod%i]%mod;
    }
    int getn(int n)
    {
        if(n==1)
            return 1;
        return 1<<__lg(n-1)+1;
    }
    struct Poly
    {
        int a[N];
        int& operator [] (int x)
        {
            return a[x];
        }
        void print(int n,int l=0)
        {
            for(int i=l;i<l+n;i++)
                printf("%lld ",a[i]);
            pn;
        }
        void cpy(Poly& t,int n,int l=0)
        {
            for(int i=l;i<l+n;i++)
                a[i]=t[i];
        }
        void clr(int n,int l=0)
        {
            for(int i=l;i<l+n;i++)
                a[i]=0;
        }
        void NTT(int n,int ty=1)
        {
            for(int i=0,*t=rev+n;i<n;i++,t++)
            {
                if(*t<i)
                    swap(a[i],a[*t]);
            }
            for(int i=1;i<n;i<<=1)
            {
                for(int j=0;j<n;j+=i<<1)
                {
                    int *x=(ty==1?gn:gi)+(i<<1)-1;
                    for(int k=j;k<j+i;k++,x++)
                    {
                        int l=a[k],r=*x*a[k+i]%mod;
                        a[k]=l+r,a[k+i]=l-r;
                        a[k]=a[k]>=mod?a[k]-mod:a[k];
                        a[k+i]=a[k+i]<0?a[k+i]+mod:a[k+i];
                    }
                }
            }
            if(ty==-1)
            {
                for(int i=0;i<n;i++)
                    a[i]=a[i]*iv[n]%mod;
            }
        }
        void mul(Poly& F,Poly& G,int n)
        {
            n=getn(n);
            F.NTT(n);
            G.NTT(n);
            for(int i=0;i<n;i++)
                a[i]=F[i]*G[i]%mod;
            NTT(n,-1);
        }
        void bni(Poly& t,int n)
        {
            if(n==1)
            {
                a[0]=ksm(t[0],mod-2);
                return;
            }
            clr(n>>1,n>>1);
            static Poly tni1,tni2;
            tni1.cpy(*this,n);
            tni2.cpy(t,n);
            tni1.mul(tni1,tni2,n);
            tni1.clr(n>>1);
            tni2.cpy(*this,n);
            tni1.mul(tni1,tni2,n);
            for(int i=n>>1;i<n;i++)
                dq(a[i]=-tni1[i]);
        }
        void ni(int n)
        {
            static Poly tni0;
            n=getn(n);
            tni0.cpy(*this,n);
            for(int i=1;i<=n;i<<=1)
                bni(tni0,i);
        }
        void dao(int n)
        {
            for(int i=1;i<n;i++)
                a[i-1]=i*a[i]%mod;
            a[n-1]=0;
        }
        void jf(int n)
        {
            for(int i=n-1;i;i--)
                a[i]=a[i-1]*iv[i]%mod;
            a[0]=0;
        }
        void ln(int n)
        {
            static Poly tln;
            n=getn(n);
            tln.cpy(*this,n<<1);
            tln.dao(n);
            ni(n);
            mul(*this,tln,n<<1);
            jf(n);
        }
        void exp(int n)
        {
            n=getn(n);
            static Poly texp0,texp1,texp2,texp3;
            texp0.cpy(*this,n);
            a[0]=1;
            a[1]=0;
            for(int len=2;len<=n;len<<=1)
            {
                texp1.bni(*this,len>>1);
                texp1.bni(*this,len);
                texp2.cpy(texp1,len);
                texp3.cpy(*this,len);
                texp3.dao(len);
                texp3.clr(len,len);
                texp2.clr(len,len);
                texp2.mul(texp2,texp3,len<<1);
                texp2.jf(len);
                dq(texp2[0]=1-texp2[0]);
                for(int i=1;i<len;i++)
                    dq(texp2[i]=texp0[i]-texp2[i]);
                clr(len,len);
                mul(*this,texp2,len<<1);
                clr(len,len);
                texp1.clr(len,len);
            }
        }
        void mi(int n,int m)
        {
            n=getn(n);
            ln(n);
            for(int i=0;i<n;i++)
                (a[i]*=m)%=mod;
            exp(n);
        }
    };
}
using namespace polynomial;
int n,m;
Poly F,G;
int jc[maxn],inv[maxn];
signed main()
{
    poly_init();
    m=re()+1,n=re()+1;
    jc[0]=1;
    for(int i=1;i<=n;i++)
        jc[i]=jc[i-1]*i%mod;
    inv[n]=ksm(jc[n],mod-2);
    for(int i=n;i;i--)
        inv[i-1]=inv[i]*i%mod;
    for(int i=1,cur=1;i<=n;i++)
    {
        (cur*=m)%=mod;
        F[i-1]=cur*inv[i]%mod;
        G[i-1]=inv[i];
    }
    G.ni(n);
    F.mul(F,G,n<<1);
    F[0]=0;
    for(int i=1;i<n;i++)
        (F[i]*=jc[i])%=mod;
    for(int i=1;i<n&&i<m;i++)
    {
        int t=ksm(i,i);
        for(int j=i,cur=i;j<n;j+=i)
        {
            (cur*=t)%=mod;
            dq(F[j]-=cur);
        }
    }
    for(int i=1;i<n;i++)
        (F[i]*=iv[i])%=mod;
    F.exp(n);
    for(int i=0;i<n;i++)
        printf("%lld ",F[i]);
    pn;
    return 0;
}
```

---


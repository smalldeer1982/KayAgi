# 【模板】分治 FFT

## 题目背景

也可用多项式求逆解决。

## 题目描述

给定序列 $g_{1\dots n - 1}$，求序列 $f_{0\dots n - 1}$。

其中 $f_i=\sum_{j=1}^if_{i-j}g_j$，边界为 $f_0=1$。

答案对 $998244353$ 取模。

## 说明/提示

$2\leq n\leq 10^5$，$0\leq g_i<998244353$。

## 样例 #1

### 输入

```
4
3 1 2```

### 输出

```
1 3 10 35```

## 样例 #2

### 输入

```
10
2 456 32 13524543 998244352 0 1231 634544 51```

### 输出

```
1 2 460 1864 13738095 55389979 617768468 234028967 673827961 708520894```

# 题解

## 作者：nekko (赞：124)

~~不太严谨+也许漏洞百出的题解~~

已知$\{g_{i} | i \in [1,n-1] \cap Z\}$，且$f_0=1$，同时有$f_i=\sum_{j=1}^{i}f_{i-j}g_j$

求$\{ f_i | i \in [0,n - 1] \cap Z \}$

---

不妨设$F(x)=\sum_{i=0}^{\infty}f_ix^i,G(x)=\sum_{i=0}^{\infty}g_ix^i$，且$g_0=0$

那么有$F(x)G(x)=\sum_{i=0}^{\infty}x^i\sum_{j+k=i}f_jg_k=F(x)-f_0x^0$

即$F(x)G(x) \equiv F(x)-f_0 (\bmod x^n)$

即$F(x) \equiv \frac{f_0}{1-G(x)} (\bmod x^n)$

即$F(X) \equiv (1-G(x))^{-1} (\bmod x^n)$

那么就是一个多项式求逆的模板了

---

## 作者：ljc1301 (赞：98)

~~分治fft的模板题干嘛用多项式求逆呢~~

讲一下（我理解的、可以做这道题）分治fft。

其实就是cdq分治的思路。每次求一个区间的时候，要保证这个区间左边所有值对这个区间的贡献都算出来了。每次把区间分为左右两半，先算做半段，然后用ntt计算左半段对右半段的贡献，再算右半度。

举个例子g\[1..3]=1, 1, 0，求f\[0..3]（别问我干嘛要拿这个算斐波那契数列）

刚开始，是这样的（用中括号代表要算的区间，竖线代表中间的位置）
``` plain
f =[1 0|0 0]
```
先算左边
``` plain
f =[1|0]0 0
```
左半边的长度为1，不往下递归。计算左区间对右区间的贡献。就是把1, 0和g的前两项0, 1做卷积，得到\*, 1（星号代表我们不在意这个位置），再把得到的后半段加到这个区间的右半边。操作后：
``` plain
f =[1|1]0 0
```
右半边的长度为1，不往下递归。这一步就好了，回到上一步。
``` plain
f =[1 1|0 0]
```
计算左半边对右半边的贡献。把1, 1, 0, 0和g的前四项0, 1, 1, 0做卷积，得到\*, \*, 2, 1，再把得到的后半段加到这个区间的右半边。操作后：
``` plain
f =[1 1|2 1]
```
现在开始计算右半段。
``` plain
f = 1 1[2|1]
```
左半边的长度是1，不往下递归。计算左区间对右区间的贡献。就是把2, **0**（注意这里是0）和g的**前**（不是后）两项0, 1做卷积，得到\*, 2，再把得到的后半段**加**到这个区间的右半边。操作后：
``` plain
f = 1 1[2|3]
```
右半边的长度为1，不往下递归。然后这个f数组就算好了。

代码（我是先填充成2的幂，这样好写）：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxlogn=18;
const int maxn=(1<<maxlogn)|1;
const int G0=15311432;
const int kcz=998244353;
int n,rev[maxn];
ll G[2][24],f[maxn],g[maxn],a[maxn],b[maxn];
void gcd(ll a,ll b,ll &x,ll &y)
{
    if(!b) x=1,y=0;
    else gcd(b,a%b,y,x),y-=x*(a/b);
}
inline ll inv(ll a)
{
    ll x,y;
    gcd(a,kcz,x,y);
    return (x+kcz)%kcz;
}
inline void calcrev(int logn)
{
    register int i;
    rev[0]=0;
    for(i=1;i<(1<<logn);i++)
        rev[i]=(rev[i>>1]>>1)|((i&1)<<(logn-1));
}
inline void FFT(ll *a,int logn,int flag)
{
    register int i,j,k,mid;
    register ll t1,t2,t;
    for(i=0;i<(1<<logn);i++)
        if(rev[i]<i)
            swap(a[rev[i]],a[i]);
    for(i=1;i<=logn;i++)
        for(mid=1<<(i-1),j=0;j<(1<<logn);j+=1<<i)
            for(k=0,t=1;k<mid;k++,t=t*G[flag][i]%kcz)
            {
                t1=a[j|k],t2=t*a[j|k|mid];
                a[j|k]=(t1+t2)%kcz,a[j|k|mid]=(t1-t2)%kcz;
            }
}
void solve(int l,int r,int logn)
{
    if(logn<=0) return;
    if(l>=n) return;
    int mid=(l+r)>>1,i;
    ll t=inv(r-l);
    solve(l,mid,logn-1); // 计算左区间
    calcrev(logn);
    memset(a+(r-l)/2,0,sizeof(ll)*(r-l)/2); // 拷贝左区间
    memcpy(a,f+l,sizeof(ll)*(r-l)/2); // 填充0
    memcpy(b,g,sizeof(ll)*(r-l)); // 拷贝g
    FFT(a,logn,0),FFT(b,logn,0); // 卷积
    for(i=0;i<r-l;i++) a[i]=a[i]*b[i]%kcz;
    FFT(a,logn,1);
    for(i=0;i<r-l;i++) a[i]=a[i]*t%kcz;
    for(i=(r-l)/2;i<r-l;i++)
        f[l+i]=(f[l+i]+a[i])%kcz; // 把卷积后的右半段的数加到f数组后半段
    // 可能你会注意到，这个卷积是(r-l)/2的长度卷一个r-l的长度，而我卷积时最终结果当作r-l的长度来存，这会不会有影响？注意到超出部分是(r-l)/2左右，根据fft的实现，超出部分是会重新从0开始填的，所以只会影响结果的前半段，与后半段无关
    solve(mid,r,logn-1); // 计算右区间
}
int main()
{
    int logn,i;
    G[1][23]=inv(G[0][23]=G0);
    for(i=22;i>=0;i--)
    {
        G[0][i]=G[0][i+1]*G[0][i+1]%kcz;
        G[1][i]=G[1][i+1]*G[1][i+1]%kcz;
    }
    scanf("%d",&n);
    for(logn=0;(1<<logn)<n;logn++);
    for(i=1;i<n;i++) scanf("%lld",&g[i]);
    for(i=0;i<n;i++) f[i]=!i;
    solve(0,1<<logn,logn);
    for(i=0;i<n;i++)
        printf("%lld ",(f[i]+kcz)%kcz);
    printf("\n");
    return 0;
}
```

---

## 作者：Great_Influence (赞：36)

都是求逆啊。。虽然可以理解。

分治$FFT$可以解决题目所描述的问题。

发现题目的要求类似于卷积，于是考虑使用$FFT$。

但是后面的数字基于前面的数字，无法快速计算，时间复杂度退化至$O(n^2)$。

于是我们考虑将类似的转移同时进行，来节省复杂度。

考虑利用分治。

假设我们求出了$l\to mid$的答案，要求这些点对$mid+1\to r$的影响，那么对右半边点$x$的贡献为:

$$w_x=\sum_{i=l}^{mid} f[i] * g[x-i]$$

这部分可以利用卷积来快速计算。计算完以后，答案直接加到答案数组就可以了。

需要注意的是，如果要求左边点对右边点的影响，首先整个区间以左对该区间的贡献应该先求出。所以分治过程为先分治左边，在求出中间，然后在递归右边。

时间复杂度$O(n\log^2n)$~~(被求逆$O(n\log n)$吊打)~~

有一个卡常技巧，就是可以发现你计算的时候只会用到 $md-l\sim r-l$ 的这一部分，前半部分不需要管。因此，直接用循环卷积对它进行处理，做乘法的时候不必做长度为 $1.5(r-l+1)$ 的，只需要做长度为 $r-l+1$ 的就可以了。这样常数会到原来的 $0.5\sim 0.67$ 倍(因为 $1.5(r-l+1)$ 的循环卷积通常会直接做长度为 $2(r-l+1) $ 的)。

upd:有人说要完整代码，我就放出来算了。。。

代码:
```cpp
#include<cstdio>
#include<cstdlib>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cassert>
#include<iostream>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define rep(i,a,b) for(register int i=(a);i<(b);++i)
#define pb push_back
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
	const uint32 Buffsize=1<<15,Output=1<<24;
	static char Ch[Buffsize],*S=Ch,*T=Ch;
	inline char getc()
	{
		return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
	}
	static char Out[Output],*nowps=Out;
	
	inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

	template<typename T>inline void read(T&x)
	{
		x=0;static char ch;T f=1;
		for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
		x*=f;
	}

	template<typename T>inline void write(T x,char ch='\n')
	{
		if(!x)*nowps++='0';
		if(x<0)*nowps++='-',x=-x;
		static uint32 sta[111],tp;
		for(tp=0;x;x/=10)sta[++tp]=x%10;
		for(;tp;*nowps++=sta[tp--]^48);
		*nowps++=ch;
	}
}
using namespace IO;

void file()
{
#ifndef ONLINE_JUDGE
	FILE*DSD=freopen("water.in","r",stdin);
	FILE*CSC=freopen("water.out","w",stdout);
#endif
}

const int MAXN=1<<19;

namespace poly
{
	const int mod=998244353,gen=3;
	
	static int g[23][MAXN],iv[MAXN];

	inline int power(int u,int v)
	{
		register int sm=1;
		for(;v;v>>=1,u=(uint64)u*u%mod)if(v&1)
			sm=(uint64)sm*u%mod;
		return sm;
	}

	inline void predone()
	{
		Rep(i,1,18)
		{
			g[i][0]=1,g[i][1]=power(gen,(mod-1)>>i);
			Rep(j,2,2e5)g[i][j]=(ll)g[i][j-1]*g[i][1]%mod;
		}
	}

	static int Len,rev[MAXN];

	inline void calrev()
	{
		int II=log(Len)/log(2)-1;
		Rep(i,1,Len-1)rev[i]=rev[i>>1]>>1|(i&1)<<II;
	}

	inline int ad(int u,int v){return(u+=v)>=mod?u-mod:u;}

	inline void NTT(int*F,int typ)
	{
		Rep(i,1,Len-1)if(i<rev[i])swap(F[i],F[rev[i]]);
		for(register int i=2,ii=1,t=1;i<=Len;i<<=1,ii<<=1,++t)
			for(register int j=0;j<Len;j+=i)rep(k,0,ii)
			{
				register int tt=(uint64)*(F+j+k+ii)*g[t][k]%mod;
				*(F+j+k+ii)=ad(*(F+j+k),mod-tt);
				*(F+j+k)=ad(*(F+j+k),tt);
			}
		if(typ==-1)
		{
			reverse(F+1,F+Len);
			register uint64 invn=power(Len,mod-2);
			rep(i,0,Len)*(F+i)=invn**(F+i)%mod;
		}
	}
}
using poly::power;
using poly::Len;
using poly::calrev;
using poly::NTT;
using poly::mod;
using poly::predone;
using poly::ad;

static int n,F[MAXN],G[MAXN],A[MAXN],B[MAXN];

void cdq_FFT(int*F,int*G,int l,int r)
{
	if(l==r)
	{
		if(!l)F[l]=1;
		return;
	}
	int md=(l+r)>>1;
	cdq_FFT(F,G,l,md);
	memcpy(A,F+l,sizeof(int)*(md-l+1));
	memcpy(B,G,sizeof(int)*(r-l+1));
	for(Len=2;Len<=r-l+1;Len<<=1);
	calrev();
	memset(A+md-l+1,0,sizeof(int)*(Len-(md-l)));
	memset(B+r-l+1,0,sizeof(int)*(Len-(r-l)));
	NTT(A,1),NTT(B,1);
	rep(i,0,Len)A[i]=(ll)A[i]*B[i]%mod;
	NTT(A,-1);
	Rep(i,md+1,r)F[i]=ad(F[i],A[i-l]);
	cdq_FFT(F,G,md+1,r);
}

int main()
{
	file();
	predone();
	read(n);
	rep(i,1,n)read(G[i]);
	cdq_FFT(F,G,0,n-1);
	rep(i,0,n)write(F[i],' ');
	flush();
	return 0;
}
```

---

## 作者：Memory_of_winter (赞：14)

[我的博客](https://www.cnblogs.com/Memory-of-winter/p/10127918.html)

**题目大意：**给定长度为$n-1$的数组$g_{[1,n)}$，求$f_{[0,n)}$，要求：

$$f_i=\sum_{j=1}^if_{i-j}g_j$$
$$f_0=1$$

**题解：**直接求复杂度是$O(n^2)$，明显不可以通过此题

分治$FFT$，可以用$CDQ$分治，先求出$f_{[l,mid)}$，可以发现这部分对区间的$f_{[mid,r)}$的贡献是$f_{[l,mid)}*g_{[0,r-l)}$，卷出来加到对应位置就行了，复杂度$O(n\log_2^2n)$

有同学指出我这份代码有问题，我回去看了一下，发现读入$g$数组的地方写锅了，应该是读入$g_1\sim g_{n-1}$，写成了$g_1\sim g_n$，然后因为是用了快读，没有发现问题。十分抱歉（感谢 @Lisy_03 指出错误）

**C++ Code：**

```cpp
#include <algorithm>
#include <cstdio>
#include <cctype>
namespace std {
	struct istream {
#define M (1 << 21 | 3)
		char buf[M], *ch = buf - 1;
		inline istream() {
#ifndef ONLINE_JUDGE
			freopen("input.txt", "r", stdin);
#endif
			fread(buf, 1, M, stdin);
		}
		inline istream& operator >> (int &x) {
			while (isspace(*++ch));
			for (x = *ch & 15; isdigit(*++ch); ) x = x * 10 + (*ch & 15);
			return *this;
		}
#undef M
	} cin;
	struct ostream {
#define M (1 << 21 | 3)
		char buf[M], *ch = buf - 1;
		int w;
		inline ostream& operator << (int x) {
			if (!x) {
				*++ch = '0';
				return *this;
			}
			for (w = 1; w <= x; w *= 10);
			for (w /= 10; w; w /= 10) *++ch = (x / w) ^ 48, x %= w;
			return *this;
		}
		inline ostream& operator << (const char x) {*++ch = x; return *this;}
		inline ~ostream() {
#ifndef ONLINE_JUDGE
			freopen("output.txt", "w", stdout);
#endif
			fwrite(buf, 1, ch - buf + 1, stdout);
		}
#undef M
	} cout;
}

#define maxn 131072 | 3
const int mod = 998244353, G = 3;

namespace Math {
	inline int pw(int base, int p) {
		static int res;
		for (res = 1; p; p >>= 1, base = static_cast<long long> (base) * base % mod) if (p & 1) res = static_cast<long long> (res) * base % mod;
		return res;
	}
	inline int inv(int x) {return pw(x, mod - 2);}
}

int n;
int f[maxn], g[maxn];
namespace Poly {
#define N 131072 | 3
	int s, lim, ilim, rev[N];
	int Wn[N + 1];
	inline void reduce(int &x) {x += x >> 31 & mod;}
	inline void clear(register int *l, const int *r) {
		if (l >= r) return ;
		while (l != r) *l++ = 0;
	}
	inline void init(const int n) {
		s = -1, lim = 1; while (lim <= n) lim <<= 1, s++; ilim = Math::inv(lim);
		for (int i = 1; i < lim; i++) rev[i] = rev[i >> 1] >> 1 | (i & 1) << s;
		const int t = Math::pw(G, (mod - 1) / lim);
		*Wn = 1; for (register int *i = Wn; i != Wn + lim; ++i) *(i + 1) = static_cast<long long> (*i) * t % mod;
	}

	inline void NTT(int *A, const int op = 1) {
		for (register int i = 1; i < lim; i++) if (i < rev[i]) std::swap(A[i], A[rev[i]]);
		for (register int mid = 1; mid < lim; mid <<= 1) {
			const int t = lim / mid >> 1;
			for (register int i = 0; i < lim; i += mid << 1) {
				for (register int j = 0; j < mid; j++) {
					const int W = op ? Wn[t * j] : Wn[lim - t * j];
					const int X = A[i + j], Y = static_cast<long long> (A[i + j + mid]) * W % mod;
					reduce(A[i + j] += Y - mod), reduce(A[i + j + mid] = X - Y);
				}
			}
		}
		if (!op) for (int i = 0; i < lim; i++) A[i] = static_cast<long long> (A[i]) * ilim % mod;
	}

	int A[N], B[N];
	void CDQ_NTT(const int l, const int r) {
		if (r - l < 2) return ;
		const int mid = l + r >> 1;
		CDQ_NTT(l, mid); init(r - l);
		std::copy(f + l, f + mid, A); clear(A + mid - l, A + lim);
		std::copy(g, g + r - l, B); clear(B + r - l, B + lim);
		NTT(A), NTT(B);
		for (int i = 0; i < lim; i++) A[i] = static_cast<long long> (A[i]) * B[i] % mod;
		NTT(A, 0);
		for (int i = mid; i < r; i++) reduce(f[i] += A[i - l] - mod);
		CDQ_NTT(mid, r);
	}
#undef N
}

int main() {
	std::cin >> n;
	for (int i = 1; i < n; i++) std::cin >> g[i];
	*f = 1;
	Poly::CDQ_NTT(0, n);
	for (int i = 0; i < n; i++) std::cout << f[i] << ' ';
	std::cout << '\n';
	return 0;
}

```


---

既然我代码锅了，要重新审核，就再补一篇求逆的博客吧。（然后我求逆的博客又锅了，~~这是后话~~，感谢 @Owen_codeisking 指出错误）

[我的博客](https://www.cnblogs.com/Memory-of-winter/p/10133416.html)


**题解：**发现这道题就是求$f*g=f-1$（$f-1$就是没有常数项的$f$），改写一下式子：

$$\begin{aligned}f*g\equiv f-1\pmod{x^n}\\f-f*g\equiv1\pmod{x^n}\\f*(1-g)\equiv1\pmod{x^n}\\f\equiv(1-g)^{-1}\pmod{x^n}\end{aligned}$$

就可以求逆了

**C++ Code：**

```cpp
#include <algorithm>
#include <cstdio>
#include <cctype>
namespace std {
	struct istream {
#define M (1 << 21 | 3)
		char buf[M], *ch = buf - 1;
		inline istream() {
#ifndef ONLINE_JUDGE
			freopen("input.txt", "r", stdin);
#endif
			fread(buf, 1, M, stdin);
		}
		inline istream& operator >> (int &x) {
			while (isspace(*++ch));
			for (x = *ch & 15; isdigit(*++ch); ) x = x * 10 + (*ch & 15);
			return *this;
		}
#undef M
	} cin;
	struct ostream {
#define M (1 << 21 | 3)
		char buf[M], *ch = buf - 1;
		int w;
		inline ostream& operator << (int x) {
			if (!x) {
				*++ch = '0';
				return *this;
			}
			for (w = 1; w <= x; w *= 10);
			for (w /= 10; w; w /= 10) *++ch = (x / w) ^ 48, x %= w;
			return *this;
		}
		inline ostream& operator << (const char x) {*++ch = x; return *this;}
		inline ~ostream() {
#ifndef ONLINE_JUDGE
			freopen("output.txt", "w", stdout);
#endif
			fwrite(buf, 1, ch - buf + 1, stdout);
		}
#undef M
	} cout;
}

const int mod = 998244353, G = 3;
namespace Math {
	inline int pw(int base, int p) {
		static int res;
		for (res = 1; p; p >>= 1, base = static_cast<long long> (base) * base % mod) if (p & 1) res = static_cast<long long> (res) * base % mod;
		return res;
	}
	inline int inv(int x) {return pw(x, mod - 2);}
}

inline void reduce(int &a) {a += a >> 31 & mod;}
inline long long get_reducell(long long a) {return a += a >> 63 & mod;}
namespace Poly {
#define N (262144 | 3)
	int lim, ilim, s, rev[N];
	int Wn[N + 1];
	inline void init(int n) {
		s = -1, lim = 1; while (lim <= n) lim <<= 1, s++; ilim = Math::inv(lim);
		for (register int i = 1; i < lim; i++) rev[i] = rev[i >> 1] >> 1 | (i & 1) << s;
		const int t = Math::pw(G, (mod - 1) / lim);
		*Wn = 1; for (register int *i = Wn; i != Wn + lim; ++i) *(i + 1) = static_cast<long long> (*i) * t % mod;
	}
	inline void clear(register int *l, const int *r) {
		if (l >= r) return ;
		while (l != r) *l++ = 0;
	}

	inline void NTT(int *A, const int op = 1) {
		for (register int i = 1; i < lim; i++) if (i < rev[i]) std::swap(A[i], A[rev[i]]);
		for (register int mid = 1; mid < lim; mid <<= 1) {
			const int t = lim / mid >> 1;
			for (register int i = 0; i < lim; i += mid << 1) {
				for (register int j = 0; j < mid; j++) {
					const int W = op ? Wn[t * j] : Wn[lim - t * j];
					const int X = A[i + j], Y = static_cast<long long> (A[i + j + mid]) * W % mod;
					reduce(A[i + j] += Y - mod), reduce(A[i + j + mid] = X - Y);
				}
			}
		}
		if (!op) for (register int *i = A; i != A + lim; ++i) *i = static_cast<long long> (*i) * ilim % mod;
	}

	int C[N];
	void INV(int *A, int *B, int n) {
		if (n == 1) {*B = Math::inv(*A); return ;}
		INV(A, B, n + 1 >> 1);
		init(n + n - 1);
		std::copy(A, A + n, C); clear(C + n, C + lim);
		NTT(B), NTT(C);
		for (register int i = 0; i < lim; i++) B[i] = (2 - static_cast<long long> (B[i]) * C[i] % mod + mod) % mod * B[i] % mod;
		NTT(B, 0), clear(B + n, B + lim);
	}
#undef N
}

#define maxn (262144 | 3)
int n, f[maxn], g[maxn];

int main() {
	std::cin >> n;
	*g = 1;
	for (int i = 1; i < n; i++) {
		std::cin >> g[i];
		g[i] = mod - g[i];
	}
	Poly::INV(g, f, n);
	for (int i = 0; i < n; i++) std::cout << f[i] << ' ';
	std::cout << '\n';
	return 0;
}
```

---

## 作者：ZnPdCo (赞：10)

普通分治 fft 是两个 log 的且常数较大。而多项式求逆是一个 log 的但是在一些比较复杂的分治 fft 任务中更加难想——例如，分治 fft 是多维的，转移为 $f_{p}*trans_{p,q}\to f_{q}$。

先随便揪出一篇题解看看：

> 每次把区间分为左右两半，先算左半段，然后用 fft 计算左半段对右半段的贡献，**再算右半段**。

我们发现普通分治 fft 还要递归右边是十分麻烦的，但是注意洛谷的分治 fft 模板题，下标是连续的，所以右边的转移方式和左边一样，故其实可以这么做：用 fft 计算出左半段对右半段的贡献，保留右半段，再直接乘上左边的多项式，把右半段与原本的左半段拼起来就是答案。

综上，不需要再递归右边，复杂度变为 $O(n\log n)$。

```cpp
void solve(int l, int r, poly &f, poly &g, const poly &G) {
    if (l == r) return;
    int mid = (l + r) >> 1;
    solve(l, mid, f, g, G);
    g.resize(r - l + 1);
    for (int i = mid - l + 1; i <= r - l; i++) g[i] = G[i];
    poly tmp = f * g;
    for (int i = 0; i <= mid - l; i++) tmp[i] = 0;
    tmp = tmp * f;
    f.resize(r - l + 1);
    for (int i = mid - l + 1; i <= r - l; i++) f[i] = tmp[i];
}
int main() {
    int n;
    scanf("%d", &n);
    poly g(n), f = {1}, tmp;
    for (int i = 1; i < n; i++) scanf("%d", &g[i]);
    solve(0, n - 1, f, tmp, g);
    for (int i = 0; i < n; i++) printf("%d ", f[i]);
}
```

---

## 作者：irris (赞：5)

> 给定一个形式幂级数 $G$ 在 $x^n$ 处的截断（$[x^0]G = 0$），求解形式幂级数 $F$ 在 $x^n$ 处的截断，其中满足 $F = FG + 1$。

### 多项式求逆

由于 $F = FG + 1$，所以 $(1-G) F = 1$，而 $[x^0](1 - G) = 1$，因此 $1-G$ 存在逆元，直接调用 [多项式求逆](https://www.luogu.com.cn/problem/P4238) 即可。

### 分治 NTT

分治 NTT 的主要思想还是「分治」：为了计算所有 $0 \leq j < i$ 的 $[x^j]F$ 对 $[x^i]F$ 的贡献，考虑所有 $(j, i)$ 对进行分治，假设在求解 $l \leq j < i \leq r$ 内所有 $(j, i)$ 对的贡献，那么选择 $l, r$ 的中点 $m$，随后：

- 先递归地计算 $[l, m]$ 区间内的贡献，随后，$F$ 的 $[l, m]$ 次系数已经确定；
- 再计算 $[l, m]$ 整体对 $(m, r]$ 整体的贡献；
- 最后递归地计算 $(m, r]$ 区间内的贡献，随后，$F$ 的 $(m, r]$ 次系数也被确定。

它相当于以一个 $\log n$ 的代价（区间总长度和 $\mathcal O(n\log n)$）将问题转化为「查询均在修改后」的形式，而对于这个形式，可以直接调用一次长度为 $r - l$ 的 NTT 解决（循环卷积溢出的部分我们并不关心）。

### 更进一步的分治 NTT

我们先前将分治的叉数一直设为 $2$ 叉，这导致了我们的时间复杂度只能做到 $\mathcal O(n\log^2 n)$。那么我们能不能做到更好呢？答案是可以的。

不妨考虑分为 $B$ 叉，并且假定每叉的大小都相等。考虑每两叉之间的贡献。如果直接做 $\mathcal O(B^2)$ 个 NTT，也就是 $T(n) = BT(n/B) + \mathcal O(B^2 \cdot \frac{n}{B} \log \frac{n}{B})$。这里其实还是 $\mathcal O(n\log^2 n)$ 的。但是注意到 NTT 是一个线性变换。如果我们预先处理出点值，最后相加再做同一个 IDFT，就是 $\mathcal O(B^2 \cdot \frac{n}{B} + B \cdot \frac{n}{B} \log \frac{n}{B})$ 的。取 $B = \mathcal O(\log n)$，计算可得其时间复杂度变为 $\mathcal O(\frac{n\log^2 n}{\log\log n})$，实测在 OI 常见的数据范围内，确实存在效率上的优化。

参考代码：

```cpp
const int LIM = 100;
void cdq(int l, int r) {
	if (r - l <= LIM) {
		for (int i = l; i < r; ++i) {
			for (int j = l, k = i - l; j < i; ++j, --k) 
				F[i] += G[k] * F[j];
			if (i == 0) F[i] = 1;
		}
		return;
	}
	int len = 2, wlen = 4;
	while ((len << 4) < (r - l)) len <<= 1, wlen <<= 1;
	int cnt = (r - l + len - 1) / len;
	Poly A[cnt - 1], C[cnt - 1];
	for (int i = 0; i < cnt; ++i) {
		int L = l + i * len, R = std::min(l + (i + 1) * len, r);
		for (int k = 0; k < wlen; ++k) 
			U[k] = 0;
		for (int j = 0; j < i; ++j) 
			for (int k = 0; k < wlen; ++k) 
				U[k] += A[j][k] * C[i - j - 1][k];
		IDFT(U, wlen);
		for (int j = L; j < R; ++j) 
			F[j] += U[j - L + len];
		cdq(L, R);
		if (i + 1 < cnt) {
			A[i].resize(wlen), C[i].resize(wlen);
			for (int j = 0; j < len; ++j) 
				A[i][j] = F[L + j];
			for (int j = 0; j < wlen; ++j) 
				C[i][j] = G[i * len + j];
			DFT(A[i], wlen), DFT(C[i], wlen);
		}
	}
}
```

如果你对更加理论方面的内容感兴趣，可以尝试阅读 [EI 的博客](https://www.cnblogs.com/Elegia/p/vDH07-relaxed-multiplication.html)。

---

## 作者：Union_Find (赞：2)

## 多项式求逆

化简原始式子

$$F = FG + f_0x^0 \pmod{x^n}$$
$$F = FG + 1 \pmod{x^n}$$
$$F(1-G) = 1 \pmod{x^n}$$
$$F = (1-G)^{-1} \pmod{x^n}$$

直接多项式求逆即可。

```cpp
int n;
poly f, g;
signed main(){
	n = rd() - 1, g = get(n);
	g[0] = 1;
	for (int i = 1; i <= n; i++) g[i] = (P - rd()) % P;
	f = inv(g, n);
	for (int i = 0; i <= n; i++) printf ("%d ", f[i]);
	return 0;
}
```

## 分治 NTT

好吧，言归正传，这题是分治 NTT 板子，我们考虑用分治做，用类似于 cdq 分治优化 dp 的思路来做。

首先假设分治区间为 $[l,r]$。

1. 分治处理 $[l,mid]$ 的 $f$ 值。
2. 处理 $[l,mid]$ 对 $[mid+1,r]$ 的 $f$ 的影响。
3. 分治 $[mid+1,r]$。

关键是第 $2$ 步，就是求下面的式子。

$$w_k = \sum_{i=l}^{mid} f_{i}g_{k-i}$$

可以直接 NTT 做到 $O(n\log n)$，最后主定理算一下就是 $O(n\log^2n)$ 的。

```cpp
void solve(int l, int r){
	if (l == r) return ;
	int mid = (l + r) >> 1;
	solve(l, mid), h = get(n);
	for (int i = l; i <= mid; i++) h[i] = f[i];
	h = mod(h * g, n + 1);
	for (int i = mid + 1; i <= r; i++) f[i] = (f[i] + h[i]) % P;
	solve(mid + 1, r);
}

```

然后就 T 了。毕竟常数太大了，我们来优化一下。

优化很简单，我们发现前面为 $0$ 的位置没有用，直接位移一下即可。

```cpp
void solve(int l, int r){
	if (l == r) return ;
	int mid = (l + r) >> 1;
	solve(l, mid), h = get(mid - l), t=  get(r - l);
	for (int i = l; i <= mid; i++) h[i - l] = f[i];
	for (int i = 1; i <= r - l; i++) t[i] = g[i];
	h = h * t;
	for (int i = mid + 1; i <= r; i++) f[i] = (f[i] + h[i - l]) % P;
	solve(mid + 1, r);
}
signed main(){
	n = rd() - 1, f = g = get(n);
	for (int i = 1; i <= n; i++) g[i] = rd();
	f[0] = 1, solve(0, n);
	for (int i = 0; i <= n; i++) printf ("%d ", f[i]);
	return 0;
}

```

---


# 【模板】下降幂多项式乘法

## 题目背景

模板题，无背景。

## 题目描述

给定一个 $n$ 次下降幂多项式 $A(x)$ 和 $m$ 次下降幂多项式 $B(x)$，你要求出一个 $n+m$ 次下降幂多项式 $F(x)$ 满足 $F(x)=A(x)B(x)$。

由于结果会很大，你输出的多项式的系数应对 $998244353$ 取模。

## 说明/提示

对于 $20\%$的数据，$n,m\leqslant 1000$。

对于 $100\%$ 的数据，$1\leqslant n,m\leqslant 10^5$，$a_i,b_i\in[0,998244353)$，$a_n,b_m \neq 0$。

## 提示

$x^{\underline n}=\left\{\begin{matrix}1 & n=0\\ x\times (x-1)^{\underline{n-1}} & n\geqslant 1 \end{matrix}\right.$

$\sum\limits_{i=0}^n a_ix^{\underline i},a_n\neq 0$ 是 $x$ 的 $n$ 次下降幂多项式。

容易证明 $n$ 次下降幂多项式唯一确定一个 $n$ 次多项式，所以下降幂多项式乘积的定义就是对应的多项式的乘积对应的下降幂多项式。 

## 样例 #1

### 输入

```
2 3
1 2 3
1 2 3 4
```

### 输出

```
1 8 52 148 89 12
```

# 题解

## 作者：command_block (赞：33)

lyx_cjz的《<具体数学>选讲》哪里有啊?求教大佬!!!

看mrsrz大佬的题解没看懂,然后自己推了一下,来发一篇详细一点的题解:

一种思路是把这东西转换回普通多项式,卷在一起再换回来。

不过那样子复杂度是大常数的$O(nlog^2n)$,代码又长……

毕竟下降幂多项式的次数也是有限的,我们考虑利用点值来搞事情。

下降幂多项式的**点值**和EGF有着莫大的关系。

题目给了我们两个下降幂多项式$F(x),G(x)$我们设$F[n]$为$F(x)$的第$n$项系数。

我们写出点值的EGF: $F^\#=\sum\limits_{i=0}^∞\dfrac{F(i)}{i!}x^i$

那么,先来手玩$x^{\underline{n}}$的点值EGF:

$\sum\limits_{i=0}^∞\dfrac{i^{\underline{n}}}{i!}x^i==\sum\limits_{i=0}^∞\dfrac{1}{(i-n)!}x^i=x^n\sum\limits_{i=0}^∞\dfrac{1}{i!}x^i=e^xx^n$

那么$F(n)=\sum\limits_{i=0}^∞F[i]n^{\underline{i}}$

就相当于下降幂多项式的点值的EGF为$F^\#=\sum\limits_{i=0}^∞\dfrac{x^i}{i!}\sum\limits_{j=0}^∞F[j]i^{\underline{j}}$

交换和式得到:$=\sum\limits_{j=0}^∞F[j]\sum\limits_{i=0}^∞\dfrac{x^i}{i!}i^{\underline{j}}$

$=\sum\limits_{j=0}^∞F[j]\sum\limits_{i=0}^n\dfrac{i^{\underline{j}}}{i!}x^i$

根据上文的结论$\sum\limits_{i=0}^∞\dfrac{i^{\underline{n}}}{i!}x^i=e^xx^n$,式子变为

$=\sum\limits_{i=0}^∞F[i]e^xx^i=e^x\sum\limits_{i=0}^∞F[i]x^i$

也就是说,我们把$F[]$当成普通多项式,卷上$e^x$就能得到点值的EGF啦!

点值EGF点乘就好,然后在逆运算回去,具体方法是卷上$e^{-x}$,毫无毛病。

Tips:$e^{-x}$并不用求逆,其$=\sum\limits_{i=0}^∞\dfrac{(-1)^i}{i!}x^i$

```cpp
#include<algorithm>
#include<cstdio>
#define mod 998244353
#define G 3
#define Maxn 200500
using namespace std;
int r[Maxn<<2];
long long invn,invG,fac[Maxn],inv[Maxn];
long long powM(long long a,long long t=mod-2)
{
  long long ans=1,buf=a;
  while(t){
  	if(t&1)ans=(ans*buf)%mod;
  	buf=(buf*buf)%mod;
  	t>>=1;
  }return ans;
}
void NTT(long long *f,bool op,int n)
{
  for (int i=0;i<n;i++)
    if (r[i]<i)swap(f[r[i]],f[i]);
  for (int len=1;len<n;len<<=1){
    int w=powM(op==1 ? G:invG,(mod-1)/len/2);
  	for (int p=0;p<n;p+=len+len){
  	  long long buf=1;
  	  for (int i=p;i<p+len;i++){
  	  	int sav=f[i+len]*buf%mod;
  	  	f[i+len]=f[i]-sav;
  	  	if (f[i+len]<0)f[i+len]+=mod;
  	  	f[i]=f[i]+sav;
  	  	if (f[i]>=mod)f[i]-=mod;
  	  	buf=buf*w%mod;
        }//F(x)=FL(x^2)+x*FR(x^2)
         //F(W^k)=FL(w^k)+W^k*FR(w^k)
         //F(W^{k+n/2})=FL(w^k)-W^k*FR(w^k)
    }
  }
}
void Init(int lim)
{
  inv[1]=inv[0]=fac[0]=1;
  for (int i=1;i<=lim;i++)fac[i]=fac[i-1]*i%mod;
  for (int i=2;i<=lim;i++)
  	inv[i]=inv[mod%i]*(mod-mod/i)%mod;
  for (int i=2;i<=lim;i++)inv[i]=inv[i-1]*inv[i]%mod;
}
long long s[Maxn<<2];
void FDT(long long *f,int n,bool op)
{
  if (op)
	for (int i=0;i<n;i++)s[i]=inv[i];
  else 
	for (int i=0;i<n;i++)
	  if (i&1)s[i]=mod-inv[i];
      else s[i]=inv[i];
  int len=1;for (;len<n+n;len<<=1);
  for (int i=n;i<len;i++)s[i]=0;
  for (int i=0;i<len;i++)
    r[i]=(r[i>>1]>>1)|(i&1?len>>1:0);
  NTT(f,1,len);NTT(s,1,len);
  for (int i=0;i<len;i++)f[i]=f[i]*s[i]%mod;
  NTT(f,0,len);invn=powM(len);
  for (int i=0;i<n;i++)f[i]=f[i]*invn%mod;
  for (int i=n;i<len;i++)f[i]=0;
}
int n,m;
long long f[Maxn<<2],g[Maxn<<2];
int main()
{
  scanf("%d%d",&n,&m);
  invG=powM(G);
  n++;m++;
  for (int i=0;i<n;i++)scanf("%lld",&f[i]);
  for (int i=0;i<m;i++)scanf("%lld",&g[i]);
  int cnt=n+m-1;
  Init(cnt);
  FDT(f,cnt,1);FDT(g,cnt,1);
  for (int i=0;i<cnt;i++)
	f[i]=f[i]*g[i]%mod*fac[i]%mod;
  FDT(f,cnt,0);
  for (int i=0;i<cnt;i++)printf("%lld ",f[i]);
  return 0;
}
```

---

## 作者：jun头吉吉 (赞：15)

## 题意
给出下降幂多项式 $A,B$，求下降幂多项式 $A\times B$
## 题解
宣传 [$\color{skyblue}\Large\mathbb{BLOG}$](https://chen-jia-liang.gitee.io/article/P5394.html)

首先看一下下降幂多项式的形式：

$$A(x)=\sum_{i=0}a_ix^{\underline{i}}$$

不难发现一个 $n$ 次的下降幂多项式唯一对应一个 $n$ 次一般多项式。

考虑我们在 $\rm DFT$ 中的做法，求出 $A,B$ 的 $n+m+1$ 个点值乘起来，就能唯一确定 $A\times B$。再通过 $\rm IDFT$ 把点值转换成为系数。

考虑一种从下降幂多项式到点值的线性变换 $\rm \color{d}Z\color{red}LCAK\color{d}T$ 和它的逆变换 $\rm \color{d}IZ\color{red}LCAK\color{d}T$。这种变换有两种推法，不过最终是殊途同归。
### 推法 $1$
把 $F(x)=\sum\limits_{i=0}^nf_ix^{\underline{i}}$ 转换为 $\sum\limits_{i=0}^na_ix^i$，我们不需要知道 $a_i$ 具体的值，只是一个推导过程中的中间变量。

考虑 
$$x^k=\sum_{i=0}^k\left\{\begin{matrix}
k\\ i
\end{matrix}\right\}x^{\underline{i}}$$
于是来推一波柿子
$$
\begin{aligned}
	\sum_{k=0}^na_kx^k&=\sum_{k=0}^na_k\sum_{i=0}^k\left\{\begin{matrix}k\\ i\end{matrix}\right\}x^{\underline i}\\
	&=\sum_{i=0}^n\left(\sum_{k=i}^na_k\left\{\begin{matrix}k\\ i\end{matrix}\right\}\right)x^{\underline i}\\
f_k&=\sum_{i=k}^na_i\left\{\begin{matrix}i\\ k\end{matrix}\right\}=\sum_{i=0}^na_i\left\{\begin{matrix}i\\ k\end{matrix}\right\}
\end{aligned}
$$
把第二类斯特林数展开：
$$
\begin{aligned}
f_k&=\sum_{i=0}^na_i\sum_{t=0}^k\frac{t^i}{t!}\times \frac{(-1)^{k-t}}{(k-t)!}\\
&=\sum_{t=0}^k\frac{\sum_{i=0}^na_it^i}{t!}\times \frac{(-1)^{k-t}}{(k-t)!}\\
&=\sum_{t=0}^k\frac{F(t)}{t!}\times\frac{(-1)^{k-t}}{(k-t)!}
\end{aligned}
$$
如果记 $G$ 为系数的 $\mathbf{OGF}$，$\hat{G}$ 为 $0,1,2,\ldots,n$ 点值的 $\mathbf{EGF}$,$H$ 为 $\{(-1)^i\}_{i=0}$ 的 $\mathbf{EGF}$，有：
$$G(z)=\hat{G}(z)\times H(z)\pmod{z^{n+1}}$$
不难发现有 $H(z)=e^{-z}$：
$$G(z)=e^{-z}\hat{G}(z)\pmod{z^{n+1}}\Longleftrightarrow e^zG(z)=\hat{G}(z)\pmod{z^{n+1}}$$
前者为 逆变换 $\rm \color{d}IZ\color{red}LCAK\color{d}T$,而后者为$\rm \color{d}Z\color{red}LCAK\color{d}T$
## 推法 $2$
上面的方法中间设了普通多项式作为中间变量因此过程较为繁琐，考虑直接上点值的 $\mathbf{EGF}$：
$$\hat{G}(z)=\sum_{i=0}^\infty\frac{F(i)}{i!}z^i$$
考虑函数是线性的，因此可以是每一个 $x^{\underline{n}}$ 的 $\mathbf{EGF}$ 之和。先来推 $x^{\underline{n}}$ 的 $\mathbf{EGF}$,记为 $\hat{G}_n(z)$

$$
\begin{aligned}
\hat{G}_n(z)&=\sum_{i=0}^\infty\frac{i^{\underline{n}}}{i!}z^i=\sum_{i=0}^\infty\frac1{(i-n)!}z^i=\sum_{i=0}^\infty\frac1{i!}z^{n+i}\\
&=z^n\sum_{i=0}^\infty \frac{z^i}{i!}=z^ne^z
\end{aligned}
$$
于是再来推 $\hat{G}(z)$
$$\hat{G}(z)=\sum_{i=0}^nf_i\hat{G}_i(z)=\sum_{i=0}^nf_iz^ie^z=e^z\sum_{i=0}^nf_iz^i$$
于是自然有：
$$\hat{G}(z)=e^zG(z)\pmod{z^{n+1}}$$
不言而喻一目了然
## 代码
```cpp
#include<bits/stdc++.h>
namespace in{
	char buf[1<<21],*p1=buf,*p2=buf;
	inline int getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
	template <typename T>inline void read(T& t){
		t=0;int f=0;char ch=getc();while (!isdigit(ch)){if(ch=='-')f = 1;ch=getc();}
	    while(isdigit(ch)){t=t*10+ch-48;ch = getc();}if(f)t=-t;
	}
	template <typename T,typename... Args> inline void read(T& t, Args&... args){read(t);read(args...);}
}
namespace out{
	char buffer[1<<21];int p1=-1;const int p2 = (1<<21)-1;
	inline void flush(){fwrite(buffer,1,p1+1,stdout),p1=-1;}
	inline void putc(const char &x) {if(p1==p2)flush();buffer[++p1]=x;}
	template <typename T>void write(T x) {
		static char buf[15];static int len=-1;if(x>=0){do{buf[++len]=x%10+48,x/=10;}while (x);}else{putc('-');do {buf[++len]=-(x%10)+48,x/=10;}while(x);}
		while (len>=0)putc(buf[len]),--len;
	}
}
using namespace std;
template<const int mod>
struct modint{
    int x;
    modint<mod>(int o=0){x=o;}
    modint<mod> &operator = (int o){return x=o,*this;}
    modint<mod> &operator +=(modint<mod> o){return x=x+o.x>=mod?x+o.x-mod:x+o.x,*this;}
    modint<mod> &operator -=(modint<mod> o){return x=x-o.x<0?x-o.x+mod:x-o.x,*this;}
    modint<mod> &operator *=(modint<mod> o){return x=1ll*x*o.x%mod,*this;}
    modint<mod> &operator ^=(int b){
        modint<mod> a=*this,c=1;
        for(;b;b>>=1,a*=a)if(b&1)c*=a;
        return x=c.x,*this;
    }
    modint<mod> &operator /=(modint<mod> o){return *this *=o^=mod-2;}
    modint<mod> &operator +=(int o){return x=x+o>=mod?x+o-mod:x+o,*this;}
    modint<mod> &operator -=(int o){return x=x-o<0?x-o+mod:x-o,*this;}
    modint<mod> &operator *=(int o){return x=1ll*x*o%mod,*this;}
    modint<mod> &operator /=(int o){return *this *= ((modint<mod>(o))^=mod-2);}
    template<class I>friend modint<mod> operator +(modint<mod> a,I b){return a+=b;}
    template<class I>friend modint<mod> operator -(modint<mod> a,I b){return a-=b;}
    template<class I>friend modint<mod> operator *(modint<mod> a,I b){return a*=b;}
    template<class I>friend modint<mod> operator /(modint<mod> a,I b){return a/=b;}
    friend modint<mod> operator ^(modint<mod> a,int b){return a^=b;}
    friend bool operator ==(modint<mod> a,int b){return a.x==b;}
    friend bool operator !=(modint<mod> a,int b){return a.x!=b;}
    bool operator ! () {return !x;}
    modint<mod> operator - () {return x?mod-x:0;}
    modint<mod> &operator++(int){return *this+=1;}
};
const int N=4e6+5;

const int mod=998244353;
const modint<mod> GG=3,Ginv=modint<mod>(1)/3,I=86583718;
struct poly{
    vector<modint<mod>>a;
    modint<mod>&operator[](int i){return a[i];}
    int size(){return a.size();}
    void resize(int n){a.resize(n);}
    void reverse(){std::reverse(a.begin(),a.end());}
    void print(){for(auto xx:a)printf("%d ",xx);puts("");}
};
int rev[N];
inline poly one(){poly a;a.a.push_back(1);return a;}
inline int ext(int n){int k=0;while((1<<k)<n)k++;return k;}
inline void init(int k){int n=1<<k;for(int i=0;i<n;i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<(k-1));}
inline void ntt(poly&a,int k,int typ){
    int n=1<<k;
    for(int i=0;i<n;i++)if(i<rev[i])swap(a[i],a[rev[i]]);
    for(int mid=1;mid<n;mid<<=1){
        modint<mod> wn=(typ>0?GG:Ginv)^((mod-1)/(mid<<1));
        for(int r=mid<<1,j=0;j<n;j+=r){
            modint<mod> w=1;
            for(int k=0;k<mid;k++,w=w*wn){
                modint<mod> x=a[j+k],y=w*a[j+k+mid];
                a[j+k]=x+y,a[j+k+mid]=x-y;
            }
        }
    }
    if(typ<0){
        modint<mod> inv=modint<mod>(1)/n;
        for(int i=0;i<n;i++)a[i]*=inv;
    }
}
poly operator +(poly a,poly b){
    int n=max(a.size(),b.size());a.resize(n),b.resize(n);
    for(int i=0;i<n;i++)a[i]+=b[i];return a;
}
poly operator -(poly a,poly b){
    int n=max(a.size(),b.size());a.resize(n),b.resize(n);
    for(int i=0;i<n;i++)a[i]-=b[i];return a;
}
inline poly operator*(poly a,poly b){
    int n=a.size()+b.size()-1,k=ext(n);
    a.resize(1<<k),b.resize(1<<k),init(k);
    ntt(a,k,1);ntt(b,k,1);for(int i=0;i<(1<<k);i++)a[i]*=b[i];
    ntt(a,k,-1),a.resize(n);return a;
}
inline poly operator*(poly a,modint<mod> b){for(int i=0;i<a.size();i++)a[i]*=b;return a; }
inline poly operator/(poly a,modint<mod> b){for(int i=0;i<a.size();i++)a[i]/=b;return a; }
inline poly operator-(poly a){for(int i=0;i<a.size();i++)a[i]=-a[i];return a; }
typedef modint<mod>mint;
mint fac[N],ifac[N];
void zlcakt(poly&A,int type){
	poly B;B.resize(A.size());
	if(type==1){
		for(int i=0;i<A.size();i++)B[i]=ifac[i];
		A=A*B;A.resize(B.size());
		for(int i=0;i<A.size();i++)A[i]*=fac[i];
	}else{
		for(int i=0;i<A.size();i++)A[i]*=ifac[i];
		for(int i=0;i<A.size();i++)
			if(i&1)B[i]=-ifac[i];else B[i]=ifac[i];
		A=A*B;A.resize(B.size());
	}
	//A.print();
}
poly mul(poly a,poly b){
	int n=a.size()+b.size()-1;
    a.resize(n),b.resize(n);
    zlcakt(a,1);zlcakt(b,1);
	for(int i=0;i<n;i++)a[i]*=b[i];
    zlcakt(a,-1);return a;
}
signed main(){
	fac[0]=1;for(int i=1;i<N;i++)fac[i]=fac[i-1]*i;
	ifac[N-1]=1/fac[N-1];for(int i=N-1;i;i--)ifac[i-1]=ifac[i]*i;
	poly A,B;
	int n,m;
	in::read(n,m);A.resize(n+1);B.resize(m+1);
	for(int i=0;i<=n;i++)in::read(A[i]);
	for(int i=0;i<=m;i++)in::read(B[i]);
	A=mul(A,B);
	for(int i=0;i<=n+m;i++)out::write(A[i].x),out::putc(' ');
	out::flush();
	return 0;
}
```

---

## 作者：feecle6418 (赞：10)

我们已知 $n$ 次多项式 $f(x)$ 在 $[0,n]$ 的点值，求出它的下降幂表示。

设 $f(x)=\sum\limits_{i=0}^{n}b_ix^{\underline{i}}=\sum\limits_{i=0}^{n}b_i\dfrac{x!}{(x-i)!}$

则 $\dfrac{f(x)}{x!}=\sum\limits_{i=0}^{n}b_i\dfrac{1}{(x-i)!}=b*e^x$

因此，$b=\text{EGF}(f)*e^{-x}$。

同理，下降幂表示转成点值也一样简单，卷上 $e^x$ 即可。

因此，对于本题而言，我们先将下降幂多项式转为点值，然后直接相乘（注意转化的点值带有 EGF 的系数，乘的时候要消去），然后转回来即可。

注意，因为卷积会导致次数增大，$e^x$ 和 $e^{-x}$ 的次数需要开到 $2\max(n,m)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353,g=3,invg=(mod+1)/g; 
int jc[200005]={1},ny[200005]={1},n,m,N,a[600005],b[600005],c[600005],d[600005],e[600005],tr[600005];
int C(int x,int y){
	if(x<y)return 0;
	return 1ll*jc[x]*ny[y]%mod*ny[x-y]%mod;
}
int Power(int x,int y){
	int ret=1;
	while(y){
		if(y&1)ret=1ll*ret*x%mod;
		y>>=1,x=1ll*x*x%mod;
	}
	return ret;
}
void NTT(int a[],int len,int flag){
	for(int i=0;i<len;i++)if(tr[i]<i)swap(a[i],a[tr[i]]);
	for(int i=1;i<len;i<<=1){
		int w=Power(flag==1?g:invg,(mod-1)/(i<<1));
		for(int j=0;j<len;j+=(i<<1)){
			int u=1;
			for(int k=0;k<i;k++,u=1ll*u*w%mod){
				int x=a[j+k],y=a[i+j+k];
				a[j+k]=(x+1ll*u*y)%mod,a[i+j+k]=(x-1ll*u*y%mod+mod)%mod;
			}
		}
	}
	if(flag==-1)for(int i=0,inv=Power(len,mod-2);i<len;i++)a[i]=1ll*a[i]*inv%mod; 
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=0;i<=n;i++)scanf("%d",&c[i]);
	for(int i=0;i<=m;i++)scanf("%d",&d[i]);
	N=max(n,m)*2;
	for(int i=1;i<=N;i++)jc[i]=1ll*jc[i-1]*i%mod,ny[i]=Power(jc[i],mod-2);
	for(int i=0;i<=N;i++){
		if(i&1)b[i]=mod-ny[i];
		else b[i]=ny[i];
		a[i]=ny[i];
	}
	int len=1;
	while(len<=2*N)len<<=1;
	for(int i=0;i<len;i++)tr[i]=(tr[i>>1]>>1)|((i&1)?(len>>1):0);
	NTT(a,len,1),NTT(b,len,1),NTT(c,len,1),NTT(d,len,1);
	for(int i=0;i<len;i++)c[i]=1ll*a[i]*c[i]%mod,d[i]=1ll*d[i]*a[i]%mod;
	NTT(c,len,-1),NTT(d,len,-1);
	for(int i=0;i<=N;i++)e[i]=1ll*c[i]*d[i]%mod*jc[i]%mod;
	NTT(e,len,1);
	for(int i=0;i<len;i++)e[i]=1ll*e[i]*b[i]%mod;
	NTT(e,len,-1);
	for(int i=0;i<=n+m;i++)printf("%d ",e[i]);
	return 0;
}
```

---

## 作者：mrsrz (赞：9)

设$F(x)$表示下降幂多项式$f(x)$的点值的指数生成函数，即$F(x)=\sum_{i=0}^{\infty}\frac{f(i)}{i!}x^i$。

考虑一个下降幂单项式$x^{\underline n}$，它的点值的指数生成函数为$\sum_{i=n}^{\infty}\frac{i!}{(i-n)!i!}x^i=x^ne^x$。

设$f(x)$的系数生成函数为$G(x)$，则$F(x)=e^xG(x)$。同理$G(x)=e^{-x}F(x)$。

那么先得到下降幂多项式的各点点值，再把对应点值相乘，然后再转回系数即可。

都可以通过简单的多项式乘法实现。

时间复杂度$O(n\log n)$。

更详细内容请参见lyx_cjz的《<具体数学>选讲》。

## Code：
```cpp
#include<cstdio>
#include<algorithm>
const int N=524288,md=998244353,g3=(md+1)/3;
typedef long long LL;
int n,m,A[N],B[N],fac[N],iv[N],rev[N],C[N],g[20][N],lim,M;
inline int pow(int a,int b){
    int ret=1;
    for(;b;b>>=1,a=(LL)a*a%md)if(b&1)ret=(LL)ret*a%md;
    return ret;
}
inline void upd(int&a){a+=a>>31&md;}
void init(int n){
    int l=-1;
    for(lim=1;lim<n;lim<<=1)++l;M=l+1;
    for(int i=1;i<lim;++i)
    rev[i]=((rev[i>>1])>>1)|((i&1)<<l);
}
void NTT(int*a,int f){
    for(int i=1;i<lim;++i)if(i<rev[i])std::swap(a[i],a[rev[i]]);
    for(int i=0;i<M;++i){
        const int*G=g[i],c=1<<i;
        for(int j=0;j<lim;j+=c<<1)
        for(int k=0;k<c;++k){
            const int x=a[j+k],y=a[j+k+c]*(LL)G[k]%md;
            upd(a[j+k]+=y-md),upd(a[j+k+c]=x-y);
        }
    }
    if(!f){
        const int iv=pow(lim,md-2);
        for(int i=0;i<lim;++i)a[i]=(LL)a[i]*iv%md;
        std::reverse(a+1,a+lim);
    }
}
int main(){
    scanf("%d%d",&n,&m);++n,++m;
    for(int i=0;i<20;++i){
        int*G=g[i];
        G[0]=1;
        const int gi=G[1]=pow(3,(md-1)/(1<<i+1));
        for(int j=2;j<1<<i;++j)G[j]=(LL)G[j-1]*gi%md;
    }
    for(int i=0;i<n;++i)scanf("%d",A+i);
    for(int i=0;i<m;++i)scanf("%d",B+i);
    for(int i=*fac=1;i<N;++i)
    fac[i]=fac[i-1]*(LL)i%md;
    iv[N-1]=pow(fac[N-1],md-2);
    for(int i=N-2;~i;--i)iv[i]=(i+1LL)*iv[i+1]%md;
    init(n+m<<1);
    for(int i=0;i<n+m-1;++i)C[i]=iv[i];
    NTT(A,1),NTT(B,1),NTT(C,1);
    for(int i=0;i<lim;++i)A[i]=(LL)A[i]*C[i]%md,B[i]=(LL)B[i]*C[i]%md;
    NTT(A,0),NTT(B,0);
    for(int i=0;i<lim;++i)C[i]=0;
    for(int i=0;i<n+m-1;++i)
    C[i]=(i&1)?md-iv[i]:iv[i];
    for(int i=0;i<lim;++i)A[i]=(LL)A[i]*B[i]%md*fac[i]%md;
    for(int i=n+m-1;i<lim;++i)A[i]=0;
    NTT(A,1),NTT(C,1);
    for(int i=0;i<lim;++i)A[i]=(LL)A[i]*C[i]%md;
    NTT(A,0);
    for(int i=0;i<n+m-1;++i)printf("%d%c",A[i]," \n"[i==n+m-2]);
    return 0;
}

```

---

## 作者：Pulsating_Dust (赞：3)

我们考虑类似于 fft 的思路。

也就是将其转为点值再做点值的乘法最后再转换回去。

不难证明 $n$ 次下降幂唯一对应一个 $n$ 次多项式，且可以由 $n + 1$ 组点值确定。

那么接下来有多种推导思路，它们都是殊途同归的。

## 方法一

边界条件:

显然下降幂在 $0$ 处的取值为其常数项。

考虑 $n$ 次项。

$F(n)$ 的点值只与前 $n + 1$ 项系数有关。

超过前 $n + 1$ 项的都是 $x^{\underline {n+1}}$ 的倍数而 $x^{\underline {n+1}}$ 有 $n + 1$ 个零点为 $[0,n]$。

由此考虑 $n$ 处的点值 即为

$F(n) = \sum\limits_{i=0}^n a_in^{\underline i} = \sum\limits_{i=0}^n \frac{a_in!}{(n-i)!} = n! \sum\limits_{i=0}^n \frac {a_i}{(n - i)!}$

这是一个显然的卷积形式。

考虑逆变换。

一个简单的想法是机械的反转正变换的过程。

也就是我们直接把我们正变换的过程倒着做一遍即为其逆变换。

这个做法正确性显然。

不过需要多项式求逆。

如果注意到 $\sum\limits_{i=0}^{\infty} \frac{z^i}{i!} = e^z $。

也可以直接 $\frac1{e^x} = e^{-x}$。

## 方法二

不妨考虑 $x^{\underline n}$ 点值的 $EGF$。

则有

$x^{\underline n} = \sum\limits_{i=0}^{\infty} \frac{{i}^{\underline n}z^i}{i!}$ 

不难发现其前 $n$ 项都是 $0$ 由此可得

$=\sum\limits_{i=n}^{\infty} \frac{{i}^{\underline n}z^i}{i!} = \sum\limits_{i=n}^{\infty} \frac{z^i}{(i-n)!} = z^n\sum\limits_{i=0}^{\infty} \frac{z^i}{i!} = e^z z^n$。

记下降幂 $A(x) = \sum\limits_{i=0}^n a_ix^{\underline i}$。

其点值的 $EGF$ 为 $G(x) = \sum\limits_{i=0}^n \frac{a_ix^{i}}{i!}$。

则带入可得 $G(x) = {e}^{x}A(x)$。

反之可得逆变换 $A(x) = {e}^{-x}G(x)$。

## 其他

根据以上的推导结果可知使用一次卷积即可完成点值与系数的转换。

因此我们只需要先进行两次卷积把多项式转换为点值再点乘最后再做一次卷积转换回去即可。

时间复杂度 $O(n\log n)$。

## 代码

```cpp
#include<bits/stdc++.h>

using u64=unsigned long long;
using Poly=std::vector<int>;

constexpr int mod=998244353,_g=3,N=1<<18;

constexpr int dil(int x){
    return x<0?x+mod:x;
}
constexpr int mul(int x,int y){
    return (u64)x*y%mod;
}
constexpr int bceil(int x){
    return x<2?1:2<<std::__lg(x-1);
}
constexpr int qpow(int a,int b,int r=1){
    for(;b;b>>=1,a=mul(a,a))
        b&1?r=mul(r,a):r;
    return r;
}

namespace FNTT{
    constexpr int mp2=__builtin_ctz(mod-1),G=qpow(_g,(mod-1)>>mp2),GI=qpow(G,mod-2);
    void _init(int*w,int l,int g){
        int t=std::__lg(l-1);
        l=1<<t,w[0]=1;
        for(int i=0;i<t;++i)
            w[1<<i]=qpow(g,1<<(mp2-2-i));
        for(int i=1;i<l;++i)
            w[i]=mul(w[i&(i-1)],w[i&-i]);
    }
    int w[N],wI[N];
    void init(int l){
        _init(w,l,G),_init(wI,l,GI);
    }
    void dif(int *f,int lim){
        for(int l=lim>>1,r=lim;l;l>>=1,r>>=1)
            for(int*j=f,*o=w;j!=f+lim;j+=r,++o)
                for(int*k=j,x,y;k!=j+l;++k)
                    x=dil(*k-mod),y=mul(k[l],*o),*k=x+y,k[l]=x-y+mod;
    }
    void dit(int *f,int lim){
        for(int l=1,r=2;l<lim;l<<=1,r<<=1)
            for(int*j=f,*o=wI;j!=f+lim;j+=r,++o)
                for(int*k=j,x,y;k!=j+l;++k)
                    x=*k,y=mod-k[l],*k=dil(x-y),k[l]=mul(x+y,*o);
        for(int i=0,iv=mod-(mod-1)/lim;i<lim;++i)
            f[i]=mul(f[i],iv);
    }
}

int fac[N],ifac[N];
void initfac(int n){
    fac[0]=1;
    for(int i=1;i<n;++i)
        fac[i]=mul(fac[i-1],i);
    ifac[n-1]=qpow(fac[n-1],mod-2);
    for(int i=n-1;i>0;--i)
        ifac[i-1]=mul(ifac[i],i);
}

namespace Falling_Factorial{
    void _Mul(const int*f,int n,const int*g,int m,int*h,int lim){
        using namespace FNTT;
        static int b[N<<1],c[N<<1];
        int lim2=lim<<1;
        std::fill(std::copy_n(ifac,lim,b),b+lim2,0),dif(b,lim2);
        std::fill(std::copy_n(f,n,h),h+lim2,0),dif(h,lim2);
        std::fill(std::copy_n(g,m,c),c+lim2,0),dif(c,lim2);
        for(int i=0;i<lim2;++i)
            h[i]=mul(h[i],b[i]),c[i]=mul(c[i],b[i]);
        dit(h,lim2),dit(c,lim2);
        for(int i=0;i<lim;++i)
            h[i]=mul(h[i],mul(fac[i],c[i]));
        std::fill(h+lim,h+lim2,0),dif(h,lim2);
        for(int i=0;i<lim2;++i)
            h[i]=mul(h[i],b[i^1]);
        dit(h,lim2);
    }
    Poly Mul(const Poly&f,const Poly&g){
        int u=f.size()+g.size()-1,lim=bceil(u);
        initfac(lim),FNTT::init(lim<<1);
        Poly h(lim<<1);
        return _Mul(f.data(),f.size(),g.data(),g.size(),h.data(),lim),h.resize(u),h;
    }
}

void solve(){
    int n,m;
    std::cin>>n>>m;
    Poly F(n+1),G(m+1);
    for(auto &x:F)
        std::cin>>x;
    for(auto &x:G)
        std::cin>>x;
    for(auto x:Falling_Factorial::Mul(F, G))
        std::cout<<x<<' ';
}

int main(){
    std::cin.tie(nullptr);
    std::ios::sync_with_stdio(false);
    solve();
    return 0;
}
```

---

## 作者：Z1qqurat (赞：1)

首先有一种 $\mathcal{O}(n\log^2 n)$ 的做法，就是直接将下降幂转为普通多项式，普通多项式乘法之后再转回下降幂，但是这里就用到两个模板都是黑的科技，感觉杀鸡用牛刀，考虑别的方式。

考虑两个乘数中的一个，记给出的形式是 $A_0(x)=\sum\limits_{i=0}^n a_ix^{\underline{i}}$，然后试着表示出另一个形式 $B_0(x)=\sum\limits_{i=0}^n b_ix^i$。

有 $A_0(x)=B_0(x)$。两边取 EGF，$x^n$ 的 $0\sim \infty$ 点值下 EGF 为 $\sum\limits_{i=0}^{\infty} \frac{i^{\underline{n}}}{i!}x^i=\sum\limits_{i=0}^{\infty} \frac{i!}{i!(i-n)!}x^i=x^n\sum\limits_{i=0}^{\infty} \frac{x^{i-n}}{(i-n)!}$，由于负数的阶乘定义为无穷大，所以这个东西就是 $x^n\sum\limits_{i=0}^\infty \frac{x^i}{i!}$。由于泰勒展开 $e^x=\sum\limits_{i=0}^\infty\frac{x^i}{i!}$，所以 $x^{\underline{n}}$ 的点值 EGF 就是 $e^xx^n$。

由于 EGF 的性质：

* $cF(x)$ 的 EGF 为 $c\hat{F}(x)$，其中 $c$ 为常数项。
* $F(x)+G(x)$ 的 EGF 为 $\hat{F}(x)+\hat{G}(x)$。

所以左式 $A_0(x)$ 的 EGF 为 $\sum\limits_{i=0}^n a_ix^ie^x=e^x\sum\limits_{i=0}^n a_ix^i$。记 $C_0(x)=\sum\limits_{i=0}^n a_ix^i$，那么把 $C_0(x)$ 和 $e^x$ 卷起来就是 $A_0(x)$ 的 EGF。

再看右式点值的 EGF，系数就是 $\frac{\sum\limits_{i=0}^n b_i0^i}{0!},\frac{\sum\limits_{i=0}^n b_i1^i}{1!},\frac{\sum\limits_{i=0}^n b_i2^i}{2!},\dots$。

左式等于右式，即 $\hat{B_0}(x)=e^xC_0(x)$。

回到原问题，已知 $A_0(x),C_0(x),A_1(x),C_1(x)$，试图求 $G(x)=B_0(x)B_1(x)=\sum\limits_{i=0}^m g_ix^i$。

首先可以求出 $\hat{B_0(x)},\hat{B_1}(x)$，具体就是把 $C_0(x),C_1(x),e^x$ 点值求出来，点值相乘然后 IDFT 还原系数。

接着，我们将 $\hat{B_0(x)},\hat{B_1}(x)$ 的对应系数相乘并乘上 $i!$，那么 $x^i$ 系数就是 $\frac{\sum\limits_{j=0}^n {b_0}_ji^j \sum\limits_{j=0}^n {b_1}_ji^j}{i!}$，你会发现这其实就是 $\hat{G}(x)$ 的系数了。然后因为 $\hat{G}(x)=e^xF(x)$，所以 $F(x)=e^{-x}\hat{G}(x)$，多项式乘法一下，取前 $n+m+1$ 项系数即可。

有很多实现细节。

* 发现实际上需要乘 $2$ 次，而乘一次长度翻倍，所以实际上应该把多项式的长度设为 $len=4\max(n,m)+1$，做点值的时候取 $len$ 次单位根。
* $e^x,e^{-x}$ 都可以直接用泰勒展开转化为 $len-1$ 次多项式。由于我们只取了 EGF 的前 $len$ 项，所以 $e^x,e^{-x}$ 的项数也要这样取，具体发现只需要取到 $2\max(n,m)$。

本题主要考察对 EGF 的灵活运用。共用到 $8$ 次 DFT/IDFT，使用 NTT 实现，预处理阶乘，单位根以及它们的逆元会快一些，用时 $1.99s$，精细实现可能会更快。

```cpp
#include <bits/stdc++.h>

#define ALL(v) begin(v), end(v)
#define All(v, l, r) &v[l], &v[(r) + 1]
using i64 = int64_t;
using u64 = uint64_t;
using db = double;

using std::cin;
using std::cout;

constexpr int N = 1e6 + 5;
constexpr i64 P = 998244353, g = 3;

void Add(i64 &x, i64 y) { x = x + y >= P ? x + y - P : x + y; }
i64 Pow(i64 x, int y) {
   i64 ret = 1;
   for (; y; x = x * x % P, y >>= 1)
      if (y & 1) ret = ret * x % P;
   return ret;
}

int n, m, len = 1, ilen;
std::array<int, N> rev;
std::array<i64, N> wn, iwn, fac, ifac, a, b, e;

void init(int n) {
   wn[0] = iwn[0] = fac[0] = ifac[0] = 1;
   ilen = Pow(len, P - 2);
   i64 w = Pow(g, (P - 1) / len), iw = Pow(w, P - 2);
   for (int i = 0; i < len; ++i)
      rev[i] = rev[i >> 1] / 2 + (i & 1 ? len / 2 : 0);
   for (int i = 1; i < len; ++i)
      wn[i] = wn[i - 1] * w % P, iwn[i] = iwn[i - 1] * iw % P;
   for (int i = 1; i < n; ++i) fac[i] = fac[i - 1] * i % P;

   ifac[n - 1] = Pow(fac[n - 1], P - 2);
   for (int i = n - 2; i; --i)
      ifac[i] = ifac[i + 1] * (i + 1) % P;
   std::copy_n(&ifac[0], len + 1, &e[0]);
   return ;
}

void ntt(int n, std::array<i64, N> &a, int typ) {
   for (int i = 0; i < n; ++i)
      if (i < rev[i]) std::swap(a[i], a[rev[i]]);
   
   for (int t = 2; t <= n; t <<= 1) {
      int _t = t >> 1;
      i64 w = typ == 1 ? wn[n / t] : iwn[n / t];
      for (int i = 0; i < n; i += t) {
         i64 wk = 1;
         for (int j = i; j < i + _t; ++j) {
            i64 x = a[j], y = a[j + _t] * wk % P;
            a[j] = (x + y) % P, a[j + _t] = (x - y + P) % P;
            wk = wk * w % P;
         }
      }
   }

   if (typ == -1)
      for (int i = 0; i < n; ++i) a[i] = a[i] * ilen % P;
   return ;
}

int main() {
   std::ios::sync_with_stdio(false);
   cin.tie(nullptr), cout.tie(nullptr);

   cin >> n >> m, n++, m++;
   while (len <= std::max(n, m) << 2) len <<= 1;
   for (int i = 0; i < n; ++i) cin >> a[i];
   for (int i = 0; i < m; ++i) cin >> b[i];
   init(std::max(n, m) * 2), ntt(len, e, 1);
   ntt(len, a, 1), ntt(len, b, 1);
   for (int i = 0; i < len; ++i) a[i] = a[i] * e[i] % P, b[i] = b[i] * e[i] % P;
   ntt(len, a, -1), ntt(len, b, -1);
   
   for (int i = 0; i < (n + m) << 1; ++i)
      a[i] = a[i] * b[i] % P * fac[i] % P;
   ntt(len, a, 1);
   for (int i = 0; i < len; ++i)
      e[i] = i & 1 ? (P - ifac[i]) % P : ifac[i];
   ntt(len, e, 1);
   for (int i = 0; i < len; ++i) a[i] = a[i] * e[i] % P;
   ntt(len, a, -1);
   for (int i = 0; i < n + m - 1; ++i) cout << a[i] << ' ';
   return 0;
}
```

---


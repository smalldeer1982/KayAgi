# 「LAOI-9」多维空间中的游戏

## 题目描述

小 $\mathbf A$ 和小 $\mathbf B$ 正在玩一个有趣的游戏。

游戏将在一个 $\underbrace{2\times2\times2\times\cdots\times2}_{k 个 2}$ 的 $k$ 维空间中进行。最小的节点的坐标为 $(\underbrace{0,0,0,\cdots,0}_{k个0})$，最大的节点的坐标为 $(\underbrace{1,1,1,\cdots,1}_{k个1})$。

下面是 $k=3$ 时的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/2khrowsw.png)

小 $\mathbf A$ 和小 $\mathbf B$ 各执一枚 $k$ 维空间中的点。

小 $\mathbf A$ 和小 $\mathbf B$ 轮流操作，小 $\mathbf A$ 先手。

定义一个维度为可操作的，当且仅当两个点中存在至少一个点在这个维度上的坐标不为 $0$。然后，操作方可以将两个点的某个可操作的维度的坐标置为 $0$。

如图，这是一个合法的操作：

![](https://cdn.luogu.com.cn/upload/image_hosting/8ajfdwcm.png)

这也是一个合法的操作：

![](https://cdn.luogu.com.cn/upload/image_hosting/65f0tcaa.png)

但是这不是一个合法的操作，因为两个点在这个维度上的坐标均为 $0$：

![](https://cdn.luogu.com.cn/upload/image_hosting/f00hqo6l.png)

无法操作者输。

相信大家一定发现了，我们可以将任意一个坐标编码为一个二进制数。例如对于坐标 $(0,1,1,1,0,0,1,0)$，可以编码为 $\tt 01110010$，对应十进制数 $114$。

小 $\mathbf A$ 和 $\mathbf B$ 将进行 $q$ 轮游戏。两人绝顶聪明，都想要自己赢。每一轮双方点的位置将会随机生成，进一步地，生成到编码为 $x$ 的坐标的概率为 $p_x$。

由于小 $\mathbf A$ 先手，所以每轮她们将会划定一个可落子区域 $[l,r]$，其他区域则为不可落子区域。如果小 $\mathbf A$ **初始**的点坐标编码后的值在区间 $[l,r]$ 外，则将会判为小 $\mathbf B$ 胜。（此规则对小 $\mathbf B$ 不生效，也就是即使小 $\mathbf B$ 初始的点坐标编码后的值在区间 $[l,r]$ 外，也不会直接判为小 $\mathbf A$ 胜）

现在对于第 $i$ 轮，可落子区域为 $[l_i,r_i]$，小 $\mathbf B$ 会有 $a_i$ 个询问，每个询问为当她的点被随机到编号为 $x$ 的坐标，且小 $\mathbf A$ 的点按照 $p$ 的概率随机生成时，她的胜率为多少。答案对 $998244353$ 取模。

## 说明/提示

### 样例 1 解释

对于第一组询问，当小 $\mathbf A$ 的点在编号为 $1$ 的坐标时，由于超出了可落子区域，小 $\mathbf B$ 胜；当小 $\mathbf A$ 的点在编号为 $2$ 的坐标时，小 $\mathbf A$ 胜；当小 $\mathbf A$ 的点在编号为 $3$ 的坐标时，小 $\mathbf B$ 胜。

故在模意义下，小 $\mathbf B$ 的胜率：$1+2=3$。

### 样例 2 解释

解码后，$x_{1,1}=1,x_{1,2}=2$，答案分别为 $18,18$，异或和为 $0$。

**本题目采用捆绑测试**。

| 子任务编号 | $k\le$ | $q\le$ | $a_i\le$ | 时间限制 | 特殊性质 | 分值 |
| :--------: | :----: | :----: | :------: | :------: | :------: | :--: |
|    $0$     |  $5$   |  $30$  |   $30$   |   1 秒   |   样例    | $0$  |
|    $1$     |  $1$   |  $30$  |   $30$   |   1 秒   |          | $5$  |
|    $2$     |  $2$   |  $30$  |   $30$   |   1 秒   |          | $5$  |
|    $3$     |  $10$  | $300$  |  $100$   |   1 秒   |          | $20$ |
|    $4$     |  $15$  | $100$  | $2^{15}$ |   1 秒   |  $t=1$   | $20$ |
|    $5$     |  $16$  | $1000$ |  $100$   |   1 秒   |          | $10$ |
|    $6$     |  $16$  | $2000$ |  $3000$  |   1 秒   |  $t=1$   | $10$ |
|    $7$     |  $16$  | $3000$ | $2^{15}$ |   2 秒   |  $t=1$   | $30$ |

对于 $100\%$ 数据，满足 $1\le k\le 16,1\le q\le 3000,0\le p_i<998244353,1\le a_i\le 2^{15},0\le l_i\le r_i< 2^k,0\le x_{i,j}< 2^k,t\in\{0,1\},0\le seed\le 50007$。保证 $\sum_{i=0}^{2^k-1}p_i\equiv1\pmod{998244353}$。

本题输入输出量大，请使用较快的输入输出方式。

## 样例 #1

### 输入

```
0
0
2
0 1 998244351 2
2
1 2 3
2
2 0 1
2 3```

### 输出

```
3
1 1```

## 样例 #2

### 输入

```
0
1
50007
3
1 2 3 4 5 6 7 998244326
1
2 0 7```

### 输出

```
0```

# 题解

## 作者：Argon_Cube (赞：22)

以下 $n$ 代表原题面中的 $k$。

首先这个游戏显然就是当 $\operatorname{popcount}(a\cup b)$ 为奇数时先手必胜。也就是说题目的意思是我们要对 $0\leq a<2^n$ 求

$$1-\sum_{i=l}^{r}[\operatorname{popcount}(a\cup i)\equiv 1\pmod 2]p_i=1-\frac 12\sum_{i=l}^{r}p_i-(-1)^{n-\operatorname{popcount}((2^n-1-a)\cap (2^n-1-i))}p_i$$

显然后面那个东西就是 xor-FWT 的定义式，也就是说我们只要只保留 $p_{2^n-1-r\sim 2^n-1-l}$ 然后做 FWT 就完事了，时间复杂度 $\Omicron(nq2^n)$。

然后我们发现这个东西被卡常了过不去。首先加个`fread`，接下来我们注意两个地方：

* FWT 的过程中不要取模。
* 可以发现，FWT 每做一层只有一个区间是有值的，那么如果我们当前遍历到的区间没有值就直接跳过。

这样就能做到最大点在 1.4s 内通过。

注意以下代码做的其实是 xnor-FWT。

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
#include <bitset>
#include <string>
#include <array>

#define rgall(arr) (arr).begin(),(arr).end()
#define rgcnt(arr,cnt) (arr).begin(),(arr).begin()+(cnt)
#define rgo1(arr,cnt) (arr).begin()+1,(arr).begin()+1+(cnt)
#define rgany(arr,cnt,offset) (arr).begin()+(offset),(arr).begin()+(offset)+(cnt)

using namespace std;

inline char nc()
{
	static char buf[100000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int reader()
{
	char ch=nc();
	int sum=0;
	int flag=1;
	while(!(ch>='0'&&ch<='9'))
	{
		if(ch=='-')flag=-1;
		ch=nc();
	}
	while(ch>='0'&&ch<='9')
		sum=sum*10+ch-48,ch=nc();
	return sum*flag;
}

constexpr int moder=998244353,inv_2=moder+1>>1,neg_1=moder-1;

inline int fast_mod(int x)
{
    return x-(x>=moder?moder:0);
}

array<long long,1<<16> vals,val0;

int main(int argc,char* argv[],char* envp[])
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int outflag;
    unsigned int seed;
    reader(),outflag=reader();
    if(outflag)
        seed=reader();
        // cin>>seed;
    int n=reader();
    // cin>>n;
    const int S=(1<<n)-1;
    for(int i=0;i<1<<n;i++)
        vals[i]=reader();
    int cntq=reader();
    // cin>>cntq;
    for(int q=1;q<=cntq;q++)
    {
        int cntq0,rgl,rgr;
        // cin>>cntq0>>rgl>>rgr;
        cntq0=reader(),rgl=reader(),rgr=reader();
        val0.fill(0);
        long long sum=0;
        for(int i=rgl;i<=rgr;i++)
            sum+=val0[i]=vals[i];
        for(int i=1,curl=rgl,curr=rgr;i<1<<n;curl-=i,curr+=i,i<<=1)
        {
            for(int j=0;j<1<<n;j+=i<<1)
            {
                if(j>curr||j+i+i<curl)
                    continue;
                for(int k=0;k<i;k++)
					val0[i|j|k]=-val0[j|k]-val0[i|j|k],val0[j|k]=val0[i|j|k]+val0[j|k]*2;
            }
            // for(int i=0;i<1<<n;i++)
            //     cerr<<val0[i]<<' ';
            // cerr<<endl;
        }
        int answer=0;
        for(int i=1;i<=cntq0;i++)
        {
            int a;
            if(outflag)
                a=seed*i*q*50007&S;
            else
                a=reader();
                // cin>>a;
            a=(1-(sum-val0[a])/2%moder+moder)%moder;
            if(outflag)
                answer^=a;
            else
                cout<<a<<' ';
        }
        if(outflag)
            cout<<answer;
        cout<<'\n';
    }
    return 0;
}
```

---

## 作者：ZnPdCo (赞：2)

以下认为所有 $a_i$ 均同阶，为 $O(a)$。

## 30 pts

首先观察题意，当存在一个点在一个维度上坐标不为 $0$ 时，需要对这个维度操作一次。

当这样的维度有偶数个时，需要操作偶数次，那么后手（小 $\mathbf B$）会赢。

形式化地，当两个点分别在编号为 $x$ 与 $y$ 的坐标上时，如果 $\text{popcnt}(x\lor y)\bmod 2=0$ 时，小 $\mathbf B$ 赢。

假设我们查询小 $\mathbf B$ 落在 $x$ 处的答案，也就是 $\sum_{i\not\in[l,r]}p_i+\sum_{i\in[l,r]}[\text{popcnt}(x\lor i)\bmod 2=0]p_i$。

直接 $O(2^kqa)$ 计算即可。

## 50 pts/60 pts

将上式后半部分进行转化，为：
$$
(\sum_{i\in[l,r]}(-1)^{\text{popcnt}(x\lor i)}p_i+\sum_{i\in[l,r]}p_i)/2
$$
前半部分的式子相当于将 $p$ 数组的非 $[l,r]$ 区间内的数置为零后进行 [FWT](https://oi-wiki.org/math/poly/fwt/) 的同或变换后第 $x$ 位的值。

进行一次变换的复杂度为 $O(k2^k)$。总复杂度 $O(q(k2^k+a))$。由于一些未知原因，将 FWT 写成递归的可以获得 60 pts。

## 70 pts

与正解无关。

考虑优化上面的过程。FWT 可以通过根号平衡做到单点修改与单点查询 $O(\sqrt{2^k})$，考虑使用莫队查询，则复杂度为 $O(2^k\sqrt{ q2^{k}}+q\sqrt{2^k}a)$。

进一步地，根据文章：[刚硬矩阵 (2) Walsh–Hadamard 变换的 "更快" 算法 - EntropyIncreaser](https://www.cnblogs.com/Elegia/p/matrix-rigidity-2.html) 中的算法，我们可以做到 $O(N^{0.476})$ 单点查询，单点修改的 FWT（这里记 $N=2^k$）。利用这个做法，我们可以做到更优的复杂度，甚至可以直接拿到 100 pts。

## 100 pts

考虑做一次递归 FWT 中的过程。

如果这个区间内的数全为 $0$，那么这个区间进行 FWT 变换后依旧全为 $0$，没有递归下去的必要。

如果这个区间在 $[l,r]$ 之中，那么可以在最开始预处理出答案。

如果这个区间一部分在 $[l,r]$ 之外，一部分在 $[l,r]$ 之中，那么我们递归下去正常 FWT。

于是做 FWT 的时候可以只递归一边，时间复杂度是 $O(2^n)$ 的。

时间复杂度 $O(k2^k+q(2^k+a))$。

---


# [HAOI2015] 按位或

## 题目描述

刚开始你有一个数字 $0$，每一秒钟你会随机选择一个 $[0,2^n-1]$ 的数字，与你手上的数字进行或（C++,C 的 `|`，pascal 的 `or`）操作。选择数字 $i$ 的概率是 $p_i$。保证 $0\leq p_i \leq 1$，$\sum p_i=1$ 。问期望多少秒后，你手上的数字变成 $2^n-1$。


## 说明/提示

对于 $100\%$ 的数据，$n\leq 20$。

以下为 spj 源代码。

```cpp
//liuchenrui 
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#define AC {fclose(fstd),fclose(fuser);return 0;}
#define WA {fclose(fstd),fclose(fuser);return 1;}
#define PE {fclose(fstd),fclose(fuser);return 5;}
#define eps 1e-6
int main(int const argc, char*const argv[]){
    FILE *fstd,*fuser;
    fstd=fopen(argv[2],"r");
    fuser=fopen(argv[3],"r");
    //fstd=fopen("x1.in","r");
    //fuser=fopen("x2.in","r");
    char s[30],t[30];
    if(fscanf(fuser,"%s",s+1)==-1)WA;
    fscanf(fstd,"%s",t+1);
    if(s[1]=='I' && t[1]=='I')AC;
    if(s[1]=='I' || t[1]=='I')WA;
    double p,q;
    sscanf(s+1,"%lf",&p);
    sscanf(t+1,"%lf",&q);
    if(fabs(p-q)<eps)AC
    else{
        if(fabs(p-q)/q<eps)AC;
        if(fabs(q-p)/q<eps)AC;
        if(fabs(p-q)/p<eps)AC;
        if(fabs(q-p)/p<eps)AC;
    }
    WA;
}

```

## 样例 #1

### 输入

```
2
0.25 0.25 0.25 0.25```

### 输出

```
2.6666666667```

# 题解

## 作者：shadowice1984 (赞：99)

真的套路啊……，没啥好说的，这种题知道结论就秒出然后不知道结论就直接gg了

好了让我们来讲正解吧，这就是到纯数学题，没啥好说的……

~~我知道胡乱设一坨变量然后倒来倒去非常没人性，但是数学题就是得耐下心来推式子啊……~~

# 本题题解

## 前置芝士1：min-max容斥原理

所谓min-max容斥原理，其实就是两个很简单的等式

记$max(S)$为集合S中的最大值，$min(S)$为集合S中的最小值，$|S|$为集合$S$的元素数量，那么以下两个等式成立

## $max(S)=\sum_{T\subseteq S}(-1)^{|T|+1}min(T)$

## $min(S)=\sum_{T\subseteq S}(-1)^{|T|+1}max(T)$

所谓的min-max容斥原理大概就是这两个简单的等式了，它真正暴力的地方在于我们就算根本没法进行大小比较，也可以仅通过加减法把max或者min以极其暴力的方式$O(2^n)$的枚举子集容斥出来

下面我们尝试着给出证明，这里只证明第一个等式好了，后边的可以自行推出

其实只需要证明一件事，就是除了$min(T)=max(S)$的那个值，其他的$min$值都被消掉了就可以了(这里说明一下，我们假定集合中的元素两两相异，如果存在相同的值的话，我们给其中几个加上一些eps扰动一下即可，反正不影响最值就是了)

先来说明$max(S)$的系数为什么是1，假设中S最大的元素是a，那么我们会发现只有$min({a})=max(S)$所以$max(S)$的系数必须是1

然后再说明为什么别的$min$都被消掉了，假设某个元素b的排名是k，那么$min(T)=b$当且仅当我们选出的集合是后n-k个的元素构成的集合的子集然后并上{b}得到的，我们会发现显然这样的集合有$2^{n-k}$种，而显然这其中恰有$2^{n-k-1}$中是有奇数个元素的，恰有$2^{n-k-1}$种是有偶数个元素的，两两相消自然就成0了，当然上述等式在k=n的时候不成立，但是此时剩下的刚好是最大值，所以证明完毕~

--------------------------
## 一些推导

现在我们有了非常暴力的min-max定理了，让我们来看看我们可以干一些什么事

一个令人惊讶的事实是，min-max定理在期望下成立，我们记$E(max(S))$为集合中max值的期望，那么有

## $E(max(S))=\sum_{T\subseteq S}(-1)^{|T|+1}E(min(T))$

## $E(min(S))=\sum_{T\subseteq S}(-1)^{|T|+1}E(max(T))$

好了我们现在发现如果认为某个位置变为1的步数是一个随机变量的话

那么$E(max(S))$可以认为是某个集合S中所有位置变成1的期望步数，因为最晚的位置都变成1了，所有的位置自然都变成1了

那么很现实的一个事情是，我们没法比较两个位置变成1的期望步数长短，所以我们要使用min-max容斥原理在一无所知的(也就是说没有办法比较大小)情况下的求出max来

但是我们必须有一个求出min的方式……否则min-max容斥就是白搭，也就是说我们需要求$E(min(T))$换句话说，集合T中至少有一个位置变成1的最早时间

## 前置芝士2：离散随机变量的几何分布

先说啥叫离散随机变量

离散随机变量就是一个随机变量只可以取一些特定的不连续值，比如全体正整数之类的……

那么我们描述一个离散随机变量的最朴素的方式就是列一个表……，打出每个值的概率，然后就可以描述一个离散随机变量的分布了

那么所谓的集合分布呢，就是这里有一个离散型随机变量X,满足

## $P(x==k)=(1-p)^{k-1}p (k\in N^{+})$

其中p是一个常量

然后我们就说这个离散型随机变量X服从带参数p的集合分布

然后不如让我来试着求一下一个服从几何分布的随机变量的期望？

## $E(X)=\sum_{i=1}^{+ \infty}iP(x==i)$

## $=p\sum_{i=1}^{+ \infty} i(1-p)^{i-1}$

然后我们发现这大概是一个等比数列\*等差数列的数列求和的式子

~~运用一些基本的高中数学知识~~

可以算出来是这个式子

## $E(x)=p\frac{1}{(1-(1-p)^2}=p\frac{1}{p^2}=\frac{1}{p}$

是不是很神奇？

好了有了这个我们可以做什么呢？
_________

## 另一些推导

书接上回，我们现在要求$E(min(T))$了

那么也就是说，集合T中至少有一个位置变为1的期望步数

那么我们可以发现$P(min(T)==k)$的意义就是前k-1次都没有选中这个集合中的哪怕一个数，换句话来讲，前k-1次都是选了这个集合补集的子集，然后第k次没有选这个集合补集的子集，可以列出这样一个式子,我们记P(S)为选中S子集的概率之和

## $P(min(T)==k)=P(S\oplus T)^{k-1}(1-P(S \oplus T))$

这是什么？我们发现$min(T)$服从系数为$(1-P(S\oplus T))$的几何分布！

然后期望直接套公式计算就行啦！

现在的问题是，怎么求P(T)呢？

## 前置芝士3:快速莫比乌斯变换(FMT)

简单来说，快速莫比乌斯变换就是快速傅里叶变换的一个兄弟……

只不过FFT的卷积是和卷积，就是i+j=k，而FMT的卷积是i|j=k也就是按位或卷积

但是和fft繁杂的变换式不一样，我们的FMT的变换式非常简单,记$\hat{f}(x)$为$f(x)$在FMT后的第x项系数，那么有

## $\hat{f}(x)=\sum_{T \subseteq x} f(x)$


这是什么？这就是子集和！

更加令人兴奋的是，FMT可以分治，可以分治！

分治方法和FFT的分治方式几乎一样，但是唯一的不同就是不需要二进制平摊翻转置换，也不需要虚数运算，变换公式就是

## $a_{i}=a_{i},a_{i+k}=a_{i}+a_{i+k}$

## 最后的推导

然后问题已经显而易见了，我们只要对原概率数组求一遍FMT即可求出P(T)了

然后就直接min-max容斥即可，如果分母为0的话直接输出inf即可了

所以这道非常套路的FMT+min-max容斥就做完了~对了，真的是超级好写！

上代码吧~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=1048580;typedef double db;db eps=1e-10;
int n;db a[N];db res;int up;int siz[N];
int main()
{
	scanf("%d",&n);up=(1<<n);
	for(int i=0;i<up;i++)scanf("%lf",&a[i]);
	for(int k=1;k<up;k<<=1)\\FMT板子
		for(int s=0;s<up;s+=k<<1)
			for(int i=s;i<s+k;i++)
			{db a0=a[i];db a1=a[i+k];a[i]=a0;a[i+k]=a0+a1;}
	for(int i=1;i<up;i++){siz[i]+=siz[i>>1]+(i&1);}
	for(int i=1;i<up;i++)\\min-max容斥
	{
		if(1-a[(up-1)^i]<eps){printf("INF\n");return 0;}
		db ex=1/(1-a[(up-1)^i]);if(siz[i]%2){res+=ex;}else {res-=ex;}
	}printf("%.10lf",res);return 0;\\拜拜程序~
}
```





---

## 作者：yybyyb (赞：36)

很明显直接套用$min-max$容斥。   
设$E(max\{S\})$表示$S$中最晚出现元素出现时间的期望，$min$同理。  
那么$E(max\{S\})=\sum_{T\subseteq S}(-1)^{|T|}E(min\{T\})$
考虑怎么求$E(min\{T\})$，很容易发现只需要或上了任何一位就行了。  
也就是
$$E(min\{T\})=\frac{1}{\sum_{G\cap T\neq \phi }p[G]}$$
只需要任意一个和$T$存在交的集合$G$就会产生至少一个位。  
现在的问题转换成了怎么求任何一个和$T$有交的东西。  
正难则反，求所有和$T$无交集的集合，设$x=T\oplus(2^n-1)$，也就是$T$的补集。  
显然所有的与$T$无交集的集合都是$x$的子集，那么只需要预处理子集和就好了，$FWT$实现（$FMT$是啥啊，我不会啊。。。）。  
时间复杂度$O(2^n n)$，代码短的不行。
```cpp
#include<cstdio>
int n,cnt[1<<20],N;
double P[1<<20],ans;
int main()
{
	scanf("%d",&n);N=1<<n;
	for(int i=0;i<N;++i)scanf("%lf",&P[i]),cnt[i]=cnt[i>>1]+(i&1);
	for(int i=1;i<N;i<<=1)
		for(int p=i<<1,j=0;j<N;j+=p)
			for(int k=0;k<i;++k)
				P[i+j+k]+=P[j+k];
	for(int i=1;i<N;++i)if(1-P[(N-1)^i]>1e-8)ans+=((cnt[i]&1)?1:-1)/(1-P[(N-1)^i]);
	if(ans<1e-10)puts("INF");else printf("%.10lf\n",ans);
	return 0;
}

```

---

## 作者：AThousandSuns (赞：21)

在我的博客上看效果更佳：[点这里](https://www.cnblogs.com/1000Suns/p/10388001.html)

神仙题啊……

---
首先定义 $\min(S)$ 表示 $S$ 中第一个变为 $1$ 的元素的时间。（其中 $S$ 是一个二进制数，是 $1$ 的位表示这一位计入答案）

$\max(S)$ 表示最后一个变为 $1$ 的元素的时间。这也符合 $\min$ 和 $\max$ 的定义。

（以下定义全集 $U=2^n-1$）

我们要求的就是 $E(\max(U))$。

容斥：$E(\max(U))=\sum\limits_{S\neq\varnothing}(-1)^{|S|+1}E(\min(S))$

现在问题就是求 $E(\min(S))$，就是有元素变为 $1$。

套期望的公式：$E(\min(S))=\sum\limits^{+\infty}_{i=1}iP(\min(S)=i)$

$P(\min(S)=i)$ 表示恰好在第 $i$ 秒出现 $1$ 的概率。

前 $i-1$ 秒都没有出现，所以应该是 $\sum\limits_{T\cap S=\varnothing}P(T)$。其中 $P(T)$ 表示出现的数是 $T$ 的概率。

第 $i$ 秒有出现，所以应该是 $1-\sum\limits_{T\cap S=\varnothing}P(T)$。

乘法原理，$P(\min(S)=i)=(\sum\limits_{T\cap S=\varnothing}P(T))^{i-1}(1-\sum\limits_{T\cap S=\varnothing}P(T))$

那么经过一通爆算，$E(\min(S))=\dfrac{1}{1-\sum\limits_{T\cap S=\varnothing}P(T)}$。

转换一下：$E(\min(S))=\dfrac{1}{1-\sum\limits_{T\subseteq\complement_US}P(T)}$。

现在最严峻的问题就是计算每个集合的子集和。

最裸的枚举，$O(4^n)$。

技巧一点的枚举，$O(3^n)$。

那么就要说到一个很有趣的事情了，我也是做了这题才知道的……

回想一下FWT（或者FMT）做按位或卷积的时候：

$C_i=\sum\limits_{j|k=i}A_jB_k$

令 $\widehat{C}_i=\sum\limits_{j\subseteq i}C_j$

那么就有 $\widehat{C}_i=\sum\limits_{j|k\subseteq i}A_jB_k$

也就是 $\widehat{C}_i=\sum\limits_{j\subseteq i,k\subseteq i}A_jB_k$

也就是 $\widehat{C}_i=\widehat{A}_i\widehat{B}_i$！

于是需要一种从 $A$ 到 $\widehat{A}$ 的变换还有它的逆变换。

于是就有了FWT（或者FMT）……

（所以说，FWT比FFT要好理解，那就要理解啊）

那么我们就知道了，FWT的或变换一次后新的序列就是原序列的子集和形式！

好的，时间复杂度 $O(n2^n)$。

代码：（实际上特别好写）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1111111;
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define ROF(i,a,b) for(int i=(a);i>=(b);i--)
#define MEM(x,v) memset(x,v,sizeof(x))
inline int read(){
	char ch=getchar();int x=0,f=0;
	while(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return f?-x:x;
}
int n,cnt[maxn];
double p[maxn];
void FWTor(double *A){
	for(int i=1;i<1<<n;i<<=1)
		for(int j=0,r=i<<1;j<1<<n;j+=r)
			FOR(k,0,i-1) A[i+j+k]+=A[j+k];
}
int main(){
	n=read();
	FOR(i,0,(1<<n)-1) scanf("%lf",p+i);
	FWTor(p);
	FOR(i,1,(1<<n)-1) cnt[i]=cnt[i>>1]+(i&1);
	double ans=0;
	FOR(i,1,(1<<n)-1){
		if(1-p[((1<<n)-1)^i]<1e-8) return puts("INF"),0;
		ans+=1/(1-p[((1<<n)-1)^i])*(cnt[i]&1?1:-1);
	}
	printf("%.10lf\n",ans);
}
```

---

## 作者：longlongzhu123 (赞：16)

# 前置知识

1.  min-max 容斥定理：$\max (S) = \displaystyle \sum _ {T \subseteq S} (-1) ^ {|T| - 1} \min (T)$

    该定理在期望意义下同样成立：

    $E(\max (S)) = \displaystyle \sum _ {T \subseteq S} (-1) ^ {|T| - 1} E(\min (T))$

2.  离散随机变量的几何分布

    其实就是一个很简单的结论：若对于随机变量 $X$ 满足 $P(X = k) = (1 - p) ^ {k - 1} p$，则 $E(X) = \dfrac {1} {p}$

    感性理解：你要去膜拜 **yyc**，每次膜拜有 $\dfrac {1} {100}$ 的概率能够被 yyc 不屑看上一眼（从而得到 yyc 神犇光环庇佑），则第 $k$ 次膜拜才第一次被 yyc 看上一眼的概率是：

    $$
    (1 - \dfrac {1} {100}) ^ {k - 1} \dfrac {1} {100}
    $$

    而期望 $100$ 次才第一次被 yyc 看上一眼。同样地，假如概率是 $\dfrac {1} {1000}$，则期望次数是 $1000$ 次；假如概率是 $\dfrac {a} {b}$，则期望次数是 $\dfrac {b} {a}$ 次……依此类推。

# 分析

下文 $n$ 表示二进制串的长度，$U$ 表示全集。

假设**某次所有操作结束**，你手上的数字变成 $2 ^ n - 1$ 之后，我们统计操作过程时发现第 $i$ 位在第 $k _ i$ 次操作的时候，刚好第一次变成 $1$（“被覆盖”）。

若 $S$ 表示一些二进制位的集合。记 $\max (S)$ 表示 $\max (\{ k _ i | i \in S \})$，即 $S$ 中最后一个被覆盖的位在这次操作中喜提 $0$ 转 $1$。显然 $\max (S)$ 就是 $S$ 被最终整个覆盖的时间。同理定义 $\min(S)$，则 $\min(S)$ 表示 $S$ 第一次被覆盖某个位的时间。

好好理解 $\min(S)$ 和 $\max(S)$ 的含义。根据 min-max 容斥定理，就可以得到

$$
\max(S) = \displaystyle \sum _ {T \subseteq S} (-1) ^ {|T| - 1} \min(T)
$$

放到期望意义下，“某次所有操作结束”变成“总的来说……平均起来”

$$
E(\max(S)) = \displaystyle \sum _ {T \subseteq S} (-1) ^ {|T| - 1} E(\min(T))
$$

请看这条式子的左边：$E(\max(S))$ 正是将 $S$ 整个覆盖的期望秒数。

那么答案就是 $E(\max(U))$。既然 $E(\max(S))$ 不好求（不然也不会出题让我们做 = =），我们就想办法求出 $E(\min(T))$。

# 求 E(min(T))

记 $p(S)$ 表示选择 $S$ 的概率，即题目输入。

$E(\min(T))$ 表示第一次覆盖 $T$ 中任一元素的期望操作次数。

设 $P(T)$ 表示一次操作能覆盖 $T$ 中任一元素的概率。

则

$$
E(\min(T)) = \dfrac {1} {P(T)}
$$

加法原理

$$
P(T) = \displaystyle \sum _ {S \cap T \not = \varnothing} p(S)
     = 1 - \displaystyle \sum _ {S \cap T = \varnothing} p(S)
     = 1 - \displaystyle \sum _ {S \subseteq (U - T)} p(S)
$$

记 $P'(T) = \displaystyle \sum _ {S \subseteq T} p(S)$，则 $P(T) = 1 - P'(U - T)$。

用**高维前缀和** [[Link↗]](https://longlongzhu123.github.io/math-notes/#note-1) 求 $P'(T)$。它是 $p(S)$ 的高维前缀和。

求出 $P'(T)$ 后求 $P(T)$，求 $\min(T)$，最后得到 $\max(S)$。输出 $\max(U)$。

# 代码

特判 $\min(\varnothing)$，令其等于 $0$ 以不干扰计算（不然会算出 $\inf$）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int kLen = 20 + 1;
const int kMaxN = (1 << kLen) + 10;
const double kEps = 1e-9;
inline void SubSum(double* a, int blen) {
  int n = (1 << blen);
  for (int k = 0; k < blen; ++k)
    for (int i = 0; i < n; ++i)
      if (i & (1 << k))
        a[i] += a[i ^ (1 << k)];
}
inline void SubMul(double* a, int blen) {
  int n = (1 << blen);
  for (int k = 0; k < blen; ++k)
    for (int i = 0; i < n; ++i)
      if (i & (1 << k))
        a[i] *= a[i ^ (1 << k)];
}
int blen, n, U;
double p1[kMaxN], p2[kMaxN];
inline void PrintBit(int S, int blen) {
  for (int k = 0; k < blen; ++k)
    printf("%c", (S & (1 << k)) ? '1' : '0');
}
inline void Print(double* a, int blen) {
  printf("print:\n");
  for (int S = 0; S < (1 << blen); ++S) {
    PrintBit(S, blen);
    printf(": %.3lf\n", a[S]);
  }
}
inline int Cnt(int S) {
  int ans = 0;
  for (; S; S -= (S & -S)) ++ans;
  return ans;
}
int main() {
  scanf("%d", &blen);
  n = (1 << blen);
  U = n - 1;
  for (int S = 0; S < n; ++S)
    scanf("%lf", &p1[S]);
  SubSum(p1, blen);
  for (int S = 0; S < n; ++S)
    p2[S] = p1[U - S];
  for (int S = 0; S < n; ++S) {
    if (S != 0 && 1 - p2[S] < kEps) {
      printf("INF\n");
      return 0;
    }
    p2[S] = 1.0 / (1 - p2[S]);
  }
  for (int S = 0; S < n; ++S)
    if (!(Cnt(S) & 1))
      p2[S] = -p2[S];
  p2[0] = 0;
  SubSum(p2, blen);
  printf("%.10lf\n", p2[U]);
  return 0;
}
```

---

## 作者：mrsrz (赞：12)

介绍一种乱搞做法：

令$g_{i,S}$表示进行$i$次变化后，变成$S$的概率。

那么：

$$g_{i,S}=\sum_{a|b=S}g_{i-1,a}p_b$$

转移到下一轮时，要把$g_i$的$2^n-1$项清空。

我们要求的是$\sum_{i=0}^{\infty}i\times g_i[2^n-1]$。

那么，我们暴力FWT，能算多少项算多少项，算到时间不够为止。然后把已经算好的部分加起来作为答案。

在数据比较常规的情况下就可以通过辣！当然可以出一些比较特殊的数据随手卡掉。

## Code：
```cpp
#include<cstdio>
#include<cmath>
#include<ctime>
const int N=1<<20|1;
double g[2][N],p[N];
int n;
void fwt(double*a){
    for(int i=1;i<1<<n;i<<=1)
    for(int j=0;j<1<<n;j+=i<<1)
    for(int k=0;k<i;++k)a[j+k+i]+=a[j+k];
}
void ifwt(double*a){
    for(int i=1;i<1<<n;i<<=1)
    for(int j=0;j<1<<n;j+=i<<1)
    for(int k=0;k<i;++k)a[j+k+i]-=a[j+k];
}
int main(){
    g[0][0]=1;
    scanf("%d",&n);
    for(int i=0;i<1<<n;++i)scanf("%lf",p+i);
    fwt(p);
    double ans=0;
    for(int i=1;;++i){
        if(1.*clock()/CLOCKS_PER_SEC>0.95)break;
        fwt(g[i&1^1]);
        for(int j=0;j<1<<n;++j)g[i&1][j]=g[i&1^1][j]*p[j];
        ifwt(g[i&1]);
        ans+=i*g[i&1][(1<<n)-1];
        g[i&1][(1<<n)-1]=0;
    }
    if(fabs(ans)<=1e-13)puts("INF");else
    printf("%.14f\n",ans);
    return 0;
}

```

---

## 作者：Great_Influence (赞：9)

发一个不要什么前置技能的解法。

设或结果为$S$的期望步数为$f[S]$，$S$出现的几率为$p[S]$，则

$\displaystyle f[S]=\sum_{k=1}^\infty k(P^k[S]-P^{k-1}[S])$

可以理解为$k$步得到答案的期望减去$k-1$步及以前得到答案的期望。

设$f$的莫比乌斯变换为$F$,$p$的莫比乌斯变换为$P$，则

$\displaystyle F[S]=\sum_{k=1}^\infty k(P^k[S]-P^{k-1}[S])$

$=\displaystyle-\sum_{k=1}^\infty P^k[S]$

$=\begin{cases}\displaystyle\frac{-1}{1-P[S]}(P[S]!=1)\\=0(P[S]=1)\end{cases}$

直接套用$FMT$即可。时间复杂度$O(n2^n)$。

代码:

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define For(i,a,b) for(i=(a),i<=(b);++i)
#define Forward(i,a,b) for(i=(a),i>=(b);--i)
template<typename T>inline void read(T &x)
{
    T f=1;x=0;char c;
    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())x=x*10+(c^48);
    x*=f;
}
using namespace std;

static int n,Len;

static double f[1<<20];

inline void init()
{
    read(n);Len=1<<n;
	Rep(i,0,Len-1)scanf("%lf",&f[i]);
}

inline void FMT(double *a,double type)
{
    for(register int z=1;z<Len;z<<=1)
        Rep(j,0,Len)if(z&j)a[j]+=type*a[j^z];
}

const double eps=1e-9;

inline void solve()
{
	FMT(f,1);
	Rep(i,0,Len-1)f[i]=fabs(f[i]-1)<eps?0:1.0/(f[i]-1.0);
	FMT(f,-1);
	if(f[Len-1]<eps)return (void)puts("INF");
	printf("%.8lf\n",f[Len-1]);
}

int main()
{
	freopen("FMT.in","r",stdin);
	freopen("FMT.out","w",stdout);
    init();
    solve();
    return 0;
}
```

---

## 作者：Qiiiiiii_ (赞：8)

## 前置知识：FMT (快速莫比乌斯变换)

由于本题题解中的写法基本都是 min-max 容斥，单纯使用 FMT 的题解给的解释又过于简略，所以决定给该写法一个较为详细的解释

先简单介绍一下FMT/FWT：

FMT 叫快速莫比乌斯变换，用于处理 or 卷积，其本质为高维前缀和，同时由于 and 卷积本质上与 or 基本无差（and 卷积本质为高维后缀和），所以也可以用来处理 and 卷积

而 FWT 是快速沃尔什变换，用于处理 xor 卷积，异或本质上就是二进制不进位加法，二维的 FWT 就相当于以 $2$ 的单位根进行 FFT/NTT



------------


设 $f(x)$ 为概率 $P_x$ 的集合幂级数，定义其乘法为或卷积，记 $T$ 为全集。当或操作的次数为 $k$ 时的概率：$[x^T]f^k(x)-f^{k-1}(x)$
，那么答案就是 

$$\displaystyle [x^T] \sum_{k=0}^{\infty} k(f^k(x)-f^{k-1}(x))=-[x^T]\sum_{k=0}^{\infty} f^k(x)$$ 

现在我们需要做的就是求这个式子，但由于它是无穷级数，且乘法的定义为或卷积，没有什么好的性质。


给出一条结论：对于一个**形式幂级数（多项式）** $T(x)$ ，记 $f(x)$ 为一个**集合幂级数**，记 $\hat g(x)$ 为集合幂级数 $g(x)$ 的**莫比乌斯变换**，那么 $\hat T(f(x))=T(\hat f(x))$ 。

这里的 $\hat T(f(x))$ 定义的不是很严谨，这里并不是表示 $T(x)$ 的莫比乌斯变换（对于形式幂级数做莫比乌斯变换可能没有实际意义），而是表示 $T(f(x))$ 构成的**集合幂级数的莫比乌斯变换** 。

$f(x)$ 的乘法定义为或卷积，$T(\hat f(x))$ 中 $\hat f(x)$ 的乘法定义为对应位点乘。

这个结论其实也挺好证的。由于对于集合幂级数的运算 $f(x)+g(x)$ 以及 $f(x)*g(x)$ 都可以通过先莫比乌斯变换再做 $\hat f(x)+ \hat g(x) $ 以及 $\hat f(x)*\hat g(x)$ ，然后再莫比乌斯反演回来来得到。

而莫比乌斯变换后的加法和乘法的定义都和我们正常的形式幂级数的加法和乘法定义相同，所以可以直接拿莫比乌斯变换后的值来代入形式幂级数中，再莫比乌斯反演得到待求值。

对于原题，我们设 $\displaystyle T(f(x))=-\sum_{k=0}^{\infty} f^k(x)$ 

对于这个东西，我们只需要把 $T(\hat f(x))$ 的每一项都求出来，然后做莫比乌斯变换变回来即可。由于莫比乌斯变换之后的乘法定义为点乘，所以有 

$$\displaystyle T(\hat f_S)=-\sum_{k=0}^{\infty} \hat f^k_S=-\frac{1}{1-\hat f_S} ,(\hat f_S\neq 1) $$

 $$ T(\hat f_S)=0,(\hat f_S=1) $$ 

（原式不收敛，所以等式成立）

最后再做一遍莫比乌斯反演即可。时间复杂度 $O(n2^n)$ 。


```
#include<bits/stdc++.h>
#define re register int
#define ll long long
#define dl double
#define LL inline ll
#define V inline void
#define I inline int
#define FOR(i,a,b) for(re i=(a),i##i=(b);i<=i##i;++i)
#define ROF(i,a,b) for(re i=(a),i##i=(b);i>=i##i;--i)
#define gc getchar()
//#define gc (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<18,stdin),fs==ft))?0:*fs++
using namespace std;
char *fs,*ft,buf[1<<18];
const int N=2e6+10,mo=998244353;
const dl eps=1e-8;
LL read(){
	ll p=0; bool w=0; char ch=gc;
	while(!isdigit(ch)) w=ch=='-',ch=gc;
	while(isdigit(ch)) p=p*10+ch-'0',ch=gc;
	return w?-p:p;
}
int n,tot;
LL Pow(ll x,ll y){ ll as=1; for(;y;y>>=1,x=x*x%mo) if(y&1) as=as*x%mo; return as;}
LL ck(ll x){ return x-=mo,x+=x>>63&mo;}
dl f[N];
V FMT(dl *a,int lm,dl tp){
	for(re i=1;i<lm;i<<=1)
		for(re j=0;j<lm;j+=(i<<1))
			for(re k=j;k<j+i;++k)
				a[k+i]+=a[k]*tp;
	return ;
}
V sol(){
	FMT(f,tot+1,1.0);
	FOR(i,0,tot) f[i]=fabs(f[i]-1)<eps?0:1.0/(f[i]-1.0);
	FMT(f,tot+1,-1.0);
	if(f[tot]<=eps) printf("INF");
	else printf("%.8lf",f[tot]);
	return ;
}
int main(){
	n=read(),tot=(1<<n)-1;
	FOR(i,0,tot) scanf("%lf",&f[i]);
	sol();
	return 0;
}



---

## 作者：yyyuuu (赞：7)

大家都用的FMT和FWT，而我只会高维前缀和......还是分享一下做法。

min-max容斥

把考虑的位放进一个集合，每个元素代表这一位的出现时间，答案明显是全集的max，运用min-max容斥可知 

max = sigma （奇加偶减）（ min （ 子集 ））min（子集）就是指子集中至少出现一位所需次数

怎么求min（子集）？

首先如果知道成功的概率，即选到与这个集合有交的数的概率，则期望次数 = 1 / 概率

求与集合有交的数的概率和不好求，尝试补集转化，求与集合无交的数的概率和，发现这些数都是补集的子集，高维前缀和预处理出每一个集合的子集和即可

最后注意无解的特判：当概率为0时，1/概率=无限大，再用一个数记录无限大即可，若无限大没有被容斥掉，则无解

```cpp
#include <cstdio>
#include <algorithm>
using namespace std ;

int N , cnt[1 << 20] , all , wxd ; 
double eps = 1e-12 ; 
int lowbit ( int x ) { return x & ( -x ) ; }
double g[1 << 20] , ans ;
double jd ( double x ) { return x < 0 ? -x : x ; }   
   
int main ( ) 
{
	scanf ( "%d" , &N ) ;
	for ( int i = 1 ; i < ( 1 << N ) ; i++ ) 
		{ int x = i ; while ( x ) x -= lowbit ( x ) , cnt[i]++ ; } 
	for ( int i = 0 ; i < ( 1 << N ) ; i++ ) 
		scanf ( "%lf" , &g[i] ) ; 
	for ( int t = 0 ; t < N ; t++ ) 
		for ( int tp = 0 ; tp < ( 1 << t ) ; tp++ ) 
			for ( int tn = 0 ; tn < ( 1 << ( N - t - 1 ) ) ; tn++ ) 
				g[tp + ( tn << ( t + 1 ) ) + ( 1 << t )] += g[tp + ( tn << ( t + 1 ) )] ; 
	all = ( 1 << N ) - 1 ; 
	for ( int i = 1 ; i < ( 1 << N ) ; i++ ) 
	{
		int p = -1 ; 
		if ( cnt[i] % 2 ) p = 1 ; 
		if ( jd ( 1.0 - g[all ^ i] ) < eps ) wxd += p ; 
		else ans += p * 1.0 / ( 1.0 - g[all ^ i] ) ;  
	} 
	wxd ? printf ( "INF\n" ) : printf ( "%0.10lf\n" , ans ) ; 
} 
```

---

## 作者：Soulist (赞：7)

先简单讲讲$min-max$容斥。。。


$$max(S)=\sum_{T\subseteq S}(-1)^{|T|+1}min(T)$$

$$min(S)=\sum_{T\subseteq S}(-1)^{|T|+1}max(T)$$

其实就是两个很simple的式子...

证明的话也比较简单。

首先可以注意到，集合内的最大值$max(S)$只会被计算一次

而且被计算的唯一一次是它单独存在的时候，那个集合假定是$T$(只有一个元素)，此时$min(T)=max(S)$且分配系数为$(-1)^2=1$...

而对于其他数，假设它的排名为$k$(从小往大看)，那么最小值为其的集合，数量应该是$2^{n-k}$个，显然会有一半的偶数和一半的奇数，但是它在$k=n$的时候不成立....

所以这个式子有什么用呢。

毕竟这个式子把一个简简单单的求出集合内的最大值变成了一个需要$2^n$枚举才能求出最大值了。。。

然而有趣的是这个式子给人的启示是常常有的时候你不能对集合元素进行大小比较，比如马上我们要谈到的这个式子在期望意义下成立，但是它却可以很暴力地通过最小值把集合内的最大值表示出来。

好的，接下来是魔法的开始

--------

$min-max$容斥在期望下成立...

$$E(max(S))=\sum_{T\in S}(-1)^{|T|+1}E(min(T))$$

即对于一个集合$S$，假设每个元素存在某个期望值，当然这个值是可大可小的，那么我们可以通过集合内最小的期望值把最大的期望值表示出来。

在本题中我们将$E(max(S))$视为集合$S$中的所有元素$(1)$中出现最晚的$1$的期望出现时间，而$E(min(S))$则对应位集合$S$中所有元素$(1)$中出现最早的$1$的期望出现时间

显然这两个概率其实就是集合$S$中所有元素的出现的期望时间与集合$S$中至少出现一个元素的期望时间

于是问题就是求$E(min(T))$

方便起见，我们认为$f(T)=E(min(T))$

考虑求解$f(T)$，可以发现每次操作后出现集合$T$中出现至少一个元素的概率$(e(T))$是固定的

其实就是：

$$\sum_{x\in T} p_x$$

我们认为$e(T)=\sum_{x\in T} p_x$

可以得到在第$t$次操作后出现至少一个元素的概率为：

$$e(T)(1-e(T))^{t-1}$$

同时，如果记$g(T,t)$表示对于集合$T$，在第$t$次操作后出现至少一个元素的概率，套用全期望公式，我们可以知道：

$$f(T)=\sum_{i=1}^{\infty} i g(T,i)$$

即：

$$f(T)=e(T)\sum_{i=1}^{\infty}i(1-e(T))^{i-1}$$

用等比套等差可以求得是$\dfrac{1}{e(T)}$，以下是化简过程：

$$S=\sum_{i=1}^{\infty} i(1-e(T))^{i-1}$$

$$(1-e(T))S=\sum_{i=1}^{\infty}i(1-e(T))^i$$

$$e(T)S=\sum_{i=1}^{\infty}(1-e(T))^i+1$$

$$e(T)S=\dfrac{(1-e(T))}{e(T)}+1$$

$$e(T)S=\dfrac{1}{e(T)}$$

好的我们知道了如果求出了$e(T)$那么可以很轻松的得到$f(T)=\dfrac{1}{e(T)}$

考虑求$e(T)$，显然有：

$$e(T)=\sum_{x|T\ne 0}p_x$$


不过$e(T)=\sum_{x | T\ne 0} p_x$有点难求,我们不妨求$U(T)=\sum_{x\& T=x} p_x$

那么显然$e(T)=1-U(T')$，其中$T'=T\oplus N$，其中$N$表示全集

然后我们已经可以$O(3^n)$去求解$U(T)$了...

然而这个求解过程可以被$FMT$加速

注意到：

$$U(T)=\sum_{x\& T=x}p_x \to \sum_{x\subseteq T}p_x$$

然而这个过程怎么加速呢...它可以分治

~~笔者只学过FWT，不保证FMT的描述准确...也不保证这个东西是FMT~~

考虑设$c_i$表示状态$i$经过$FMT$变化后得到的答案

即$c_i=\sum_{x\subseteq i}p_x$

显然$c_i$可以递归考虑

不妨设$n=2^k$，需要求解$c_0,c_1...c_{n-1}$

我们可以这样想象：即对于求解$c_i$，每次根据当前二进制位其为$0$还是$1$将其分开处理，然后求解其内部的答案，然后再考虑这一位是$1$的显然需要额外补上那些是$0$的。。。（好模糊。。。如果会$\rm FFT$应该可以自己yy出来

简单讲就是变换公式为：$c_i=c_i,c_{i+k}=c_i+c_{i+k}$

当然这个可以改成循环版，类似于$\rm FFT$，可以将变化复杂度做到$O(n 2^n)$。。。

于是我们就可以求出$U(T)$了...然后再套个$min-max$容斥答案就出来了！

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )
#define re register
#define int long long
int gi() {
	int cn = 0, flus = 1 ; char cc = getchar() ;
	while( cc > '9' || cc < '0' ) { if( cc == '-' ) flus = -flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' ) cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ; 
}
const int N = 1 << 21 ; 
int n, size[N] ;
double p[N], U[N], e[N], Ans ; 
signed main() {
    n = gi() ; n = ( 1 << n ) - 1 ; 
    rep( i, 0, n ) scanf("%lf", &p[i] ) ; 
    for( re int k = 1; k < n; k <<= 1 )
    for( re int i = 0; i < n; i += ( k << 1 ) )
    for( re int j = i; j < i + k; ++ j ) {
        double Nx = p[j], Ny = p[j + k] ; 
        p[j + k] = ( Nx + Ny ), p[j] = Nx ;
    }
    rep( i, 0, n ) e[i] = p[i ^ n], size[i] = ( size[i >> 1] + ( i & 1 ) ) ;
    rep( i, 1, n ) {
        if( 1 - e[i] < 1e-9 ) { puts("INF") ; exit(0) ; } 
        double ex = ( 1.0 / ( 1 - e[i] ) ) ;
        if( size[i] & 1 ) Ans += ex ; 
        else Ans -= ex ;
    }
    printf("%.6lf\n", Ans ) ;
	return 0 ; 
}
```

~~好久没写过这么奇怪的吐槽题解了。。。~~

---

## 作者：vvsv (赞：3)

令 $F_{i}(x)$ 表示在进行完 $i$ 次操作之后，得到的数为$x$的概率，$U=2^n-1$

令$N=+\infty$

$$Ans=\displaystyle\sum_{i=1}^{N}i*(F_{i}(U)-F_{i-1}(U))=N*F_{N}(U)-\displaystyle\sum_{i=0}^{N-1}F_{i}(U)$$

$$F_{i}(x)=\displaystyle\sum_{a}^{x}\displaystyle\sum_{b}^{x}[a|b=x]F_{i}(a)*p(b)$$

令$G_{i}(x)=FWT_{or}(Fi)(x)=\displaystyle\sum_{j|x=x}F_{i}(j)=G_{1}(x)^i$

$$F_{i}(x)=\displaystyle\sum_{x|j=x}G_{i}(j)*(-1)^{(count(x)-count(j))}=\displaystyle\sum_{x|j=x}G_{1}(j)^i*(-1)^{(count(x)-count(j))}$$

$$Ans=N*F_{N}(U)-\displaystyle\sum_{i=0}^{N-1}F_{i}(U)=N-\displaystyle\sum_{i=0}^{N-1}\displaystyle\sum_{U|S=U}G_{1}(S)^i*(-1)^{(count(U)-count(S))}$$

$$Ans=N-\displaystyle\sum_{i=0}^{N-1}\displaystyle\sum_{U|S=U}(-1)^{(count(U)-count(S))}*G_{1}(S)^i$$

$$Ans=N-\displaystyle\sum_{U|S=U}(-1)^{(count(U)-count(S))}*\displaystyle\sum_{i=0}^{N-1}G_{1}(S)^i$$

$$Ans=N+\displaystyle\sum_{U|S=U and U!=S}(-1)^{(count(U)-count(S))}*\frac{1}{G_1(S)-1}-\displaystyle\sum_{i=0}^{N-1}G_1(U)^i$$

$$Ans=N+\displaystyle\sum_{U|S=U and U!=S}(-1)^{(count(U)-count(S))}*\frac{1}{G_1(S)-1}-N$$

$$Ans=\displaystyle\sum_{U|S=U and U!=S}(-1)^{(count(U)-count(S))}*\frac{1}{G_1(S)-1}$$

代码：
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int maxn=(1<<20)+10;
inline int read()
{
	register int p=0,f=1;
	char ch=getchar();
	while(ch<'0' || ch>'9') {if(ch=='-')f=-1; ch=getchar();}
	while(ch>='0' && ch<='9') {p=p*10+ch-'0'; ch=getchar();}
	return p*f;
}

int lim;
namespace FWT
{
	void main(double *a,int typ)
	{
		for(int len=1;len<lim;len<<=1)
			for(int i=0;i<lim;i+=(len<<1))
				for(int j=0;j<len;j++)
					a[i+j+len]+=typ*a[i+j];
	}
}

double p[maxn];
int cnt[maxn];
int main()
{
	lim=1<<read();int xx=0;
	for(int i=1;i<lim;i++) cnt[i]=cnt[i^(i&-i)]+1;
	for(int i=0;i<lim;i++)
	{
		scanf("%lf",&p[i]);
		if(p[i]>1e-6) xx|=i;
	}
	if(xx!=lim-1) {puts("INF");return 0;}
	FWT::main(p,1);
	double ans=0;
	for(int i=0;i<lim-1;i++)
	{
		if((cnt[lim-1]-cnt[i])&1) ans-=1/(p[i]-1);
		else ans+=1/(p[i]-1);
	}
	printf("%.7lf",ans);
}
```


---

## 作者：Stump (赞：3)

来一发新科技$FMT$快速莫比乌斯变换

令$f_S=\sum_{T\subseteq S} P_T$

$f_S$显然是$S$的子集概率和

考虑

$E(S)=\sum_{i=1}^{\infty}i*(f_S^i-f_S^{i-1})=\sum_{i=1}^{\infty}f_S^i$

当$f_S\not = 1$等比数列求和，得$E(S)=\frac{1}{f_s-1}$

否则 $E(S)=0$

求$f$只需要$FMT$一下就好了

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#define rep(i,s,t) for(register int i=s;i<=t;++i)
using namespace std;
typedef double db;
const int N=1<<20;
const db eps=1e-9;
int n;
db a[N];
inline void fmt(db *a,int op){
	rep(i,0,n-1)
		rep(j,0,(1<<n)-1)
			if(j>>i&1)
				a[j]+=op*a[j^(1<<i)];
}
int main(){
	scanf("%d",&n);
	rep(i,0,(1<<n)-1)
		scanf("%lf",a+i);
	fmt(a,1);
	rep(i,0,(1<<n)-1)
		a[i]=fabs(a[i]-1)<eps?0:(1.00/(a[i]-1.00));
	fmt(a,-1);
	if(a[(1<<n)-1]<eps)puts("INF");
	else printf("%.10lf\n",a[(1<<n)-1]);
	return 0;
}
```

---

## 作者：zrzring (赞：2)

[更好的阅读体验](http://zrzring.cn/index.php/archives/682/)

题目可以转化为给定每种集合触发概率，问期望多少次可以触发全集，用$E(max(S))$表示集合$S$中最晚出现元素出现时间的期望，根据min-max容斥

$$
E(max(S)) = \sum_{S'\subseteq S} (-1)^{|S'|} \times E(min(S'))
$$

如何计算$E(min(S))$，记$S$的补集为$R$，每次$S$集合中的元素被选中的概率为

$$
\sum_{T\cap S\not = \varnothing}P(T) = 1 - \sum_{T\cap S = \varnothing}P(T) = 1 - \sum_{T\subseteq R}P(T)
$$

可以用FMT计算，若一个事件发生的概率为$p$，该事件期望重复$E$次可以发生，则有

$$
E = \sum_{i\geq 1} i(1 - p)^{i - 1}p = p\sum_{i\geq 1} i(1 - p)^{i - 1}
$$

内部是个等差数列乘一个等比数列，根据套路错位相减

$$
\begin{aligned}
S = \sum_{i\geq 1} i(1 - p)^{i - 1}\\
(1 - p)S = \sum_{i\geq 1} i(1 - p)^{i}\\
pS = 1 + \sum_{i\geq 1}(1 - p)^i
\end{aligned}
$$

根据等比数列求和公式，得出$\displaystyle E = \frac{1}{p}$，于是

$$
E(min(S)) = \frac{1}{1 - \sum_{T\subseteq R}P(T)}
$$

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <queue>

#define file(s) freopen(s".in", "r", stdin), freopen(s".out", "w", stdout);

using namespace std;

const int N = 2e6 + 10;

inline int read() {
	bool sym = 0; int res = 0; char ch = getchar();
	while (!isdigit(ch)) sym |= (ch == '-'), ch = getchar();
	while (isdigit(ch)) res = (res << 3) + (res << 1) + (ch ^ 48), ch = getchar();
	return sym ? -res : res;
}

int n, m, cnt[N];

double P[N];

int main() {
	n = 1 << read();
	for (int i = 0; i < n; i++) scanf("%lf", &P[i]), cnt[i] = cnt[i >> 1] + (i & 1);
	for (int i = 1; i < n; i <<= 1) {
		for (int j = 0; j < n; j += i << 1) {
			for (int k = j; k < j + i; k++) P[k + i] += P[k];
		}
	}
	double ans = 0;
	for (int i = 1; i < n; i++) {
		if (1 - P[n - 1 ^ i] > 1e-10) ans += (cnt[i] & 1 ? 1 : -1) / (1 - P[n - 1 ^ i]);
	}
	if (ans <= 1e-10) printf("INF"); else printf("%.10lf", ans);
	return 0;
}
```

---

## 作者：warzone (赞：1)

[可能更好的阅读体验](https://www.luogu.com.cn/blog/wangrx/solution-p3175)  

# 题意
一开始你有一个数字 $0$。  
之后每秒钟有 $p_k$ 的概率选择数 $k\in[0,2^n-1]$ 按位或上你手上的数字，直到手上的数字变成 $2^n-1$。  
求手上的数字变成 $2^n-1$ 的期望时间。

$\texttt{Data Range: }n\le 20,0\le p_k\le 1,\displaystyle\sum_{k=0}^{2^n-1}p_k=1$

# 题解
前置芝士：[FWT/FMT](https://www.luogu.com.cn/blog/wangrx/solution-p-4717)

不会 min-max 容斥，但会线性递推，于是用 矩阵推柿子 + FWT 实现 解决了这个问题。

设第 $t$ 秒手上的数字为 $k$ 的概率为 $v_{t,k}$，则有
$$\displaystyle v_{t,k}=\sum_{i|j=k}p_iv_{t-1,j}\quad (k\in[0,2^n-1)\ )$$  
$$v_{t,2^n-1}=\displaystyle\sum_{i|j=2^n-1}p_iv_{t-1,j}[j\not=2^n-1]$$

说人话，就是前 $t-1$ 秒在 $[0,2^n-1)$ 以内转移，最后一秒跳到 $2^n-1$ 。

这个转移是线性的（只有加法和乘上一个常数），可以用矩阵来描述。

具体地，设 $\vec{v}_t=\begin{bmatrix}v_{t,0}\\ v_{t,1}\\\vdots\\ v_{t,2^n-2 }\end{bmatrix}$，则 $\vec{v}_0\begin{bmatrix}1\\0\\\vdots\\0\end{bmatrix}$ 。  
- 对于 $[0,2^n-1)$ 以内转移，设 $\vec{v}_t=A\vec{v}_{t-1}$
- 对于最后一秒的转移，设 $[v_{t,2^n-1}]=B\vec{v}_{t-1}$

由此得到我们要求的答案即为

$$\sum_{t=1}^\infty t[v_{t,2^n-1}]=\sum_{t=0}^\infty(t+1)BA^t\vec{v}_0=B\displaystyle\sum_{t=0}^\infty(t+1)A^t\vec{v}_0$$
$$=B(I+2A+3A^2+\cdots)\vec{v}_0=B(I+A+A^2+\cdots)^2\vec{v}_0$$

转移 $A,B$ 可以通过与概率序列 $\vec{p}=\begin{bmatrix}p_0\\p_1\\\vdots\\ p_{2^n-1}\end{bmatrix}$ 作或卷积计算。

因为 $\forall k\in[0,2^n-1],k\operatorname{or}(2^n-1)=2^n-1$，对于转移 $A$，  
只要在整体卷完后将 $2^n-1$ 项抹去即可。

然后我们知道，FWT $F_\text{or}$ 满足线性性，即 $F_\text{or}(\vec{u}+\vec{v})=F_\text{or}(\vec{u})+F_\text{or}(\vec{v})$ 。  
设 $\vec{u}^0=\vec{v}_0,\vec{u}^n=\vec{u}^{n-1}\otimes_\text{or}\vec{u}$，对于转移 $(I+A+A^2+\cdots)$，  
实际要计算的就是 $F_\text{or}((\vec{p}^0+\vec{p}^1+\vec{p}^2+\cdots)\otimes_\text{or}\vec{u})_k$

$$=(F_\text{or}(\vec{p})_k^0+F_\text{or}(\vec{p})_k^1+F_\text{or}(\vec{p})_k^2+\cdots)F_\text{or}(\vec{u})_k$$
$$=(1-F_\text{or}(\vec{p})_k)^{-1}F_\text{or}(\vec{u})_k$$

将 $\vec{v}_0$ 代入 $\vec{u}$ 算两次，这个转移就搞好了。  
至于无解就是不收敛，用 `cmath` 库的函数 `isfinite(double)` 判就是了，具体看代码。

# Code
```cpp
#include<stdio.h>
#include<string.h>
#include<math.h>
typedef double db;
typedef unsigned int word;
struct READ{//快读
	char c,w;
	inline READ(){c=getchar();}
	template<typename type>
	inline READ& operator >>(register type& num){
		for(w=1;'0'>c||c>'9';c=getchar())
			w=c=='-'? -1:1;
		for(num=0;'0'<=c&&c<='9';c=getchar())
			num=num*10+(c-'0');
		if(c=='.'){
			c=getchar();
			for(register db i=0.1;'0'<=c&&c<='9';)
				num+=i*(c-'0'),c=getchar(),i*=0.1;
		}
		return num*=w,*this;
	}
}cin;
word size,realid[1<<20];
#define fftfor(size)												\
	for(register word floor=1;floor<1u<<(size);floor<<=1)			\
		for(register word head=0;head<1u<<(size);head+=floor<<1)	\
			for(register word i=0;i<floor;++i)//FFT 循环
#define _or(num)(	\
	num0=num[head|i],num1=num[head|i|floor],	\
	num[head|i|floor]=num1+num0)
#define or_(num)(	\
	num0=num[head|i],num1=num[head|i|floor],	\
	num[head|i|floor]=num1-num0)
db f[1<<20],g[1<<20],ans[1<<20];
int main(){
	cin>>size;
	for(register word i=0,head;head=i,i<(1<<size);++i)
		for(register word floor=0;floor<size;++floor)
			realid[i]=realid[i]<<1|(head&1),head>>=1;
	//处理翻转的 id
	for(register word i=0;i<(1u<<size);++i) 
		cin>>f[realid[i]],g[realid[i]]=f[realid[i]];
	register db num0,num1;
	f[realid[(1u<<size)-1]]=0;
	fftfor(size) _or(f),_or(g);
	for(register word i=0;i<(1u<<size);++i)
		ans[realid[i]]=1.0/((-f[i]+1)*(-f[i]+1));//转移 A
	fftfor(size) or_(ans);
	for(register word i=0;i<(1u<<size);++i)
		f[realid[i]]=ans[i];
	f[realid[(1u<<size)-1]]=0;//抹去 2^n-1
	fftfor(size) _or(f);
	for(register word i=0;i<(1u<<size);++i)
		ans[realid[i]]=f[i]*g[i];//转移 B
	fftfor(size) or_(ans);
	if(!isfinite(ans[(1u<<size)-1])) puts("INF");//无解判定
	else printf("%0.8f",ans[(1u<<size)-1]);
	return 0;
}
```

---

## 作者：徐致远 (赞：1)


[本蒟蒻的blog](https://www.chnxuzhiyuan.cn/2019/12/17/%E3%80%8CHAOI2015%E3%80%8D%E6%8C%89%E4%BD%8D%E6%88%96-Solution/)

### 题解

考虑Min-Max容斥。

设$T(i)$表示二进制数的第$i$位变成$1$的时间，那么题目里要求的就是：

$$
E(\max_{i=1}^{n}{T(i)})
$$

但是要注意，一般情况下并**没有**

$$
E(\max_{i=1}^{n}{T(i)})=\max_{i=1}^{n}{E(T(i))}
$$

并且这道题中最大值并不好求，所以这里就要用Min-Max容斥，令$S=\lbrace T(i)|i\in[1,n]\rbrace$，于是就有：

$$
E(\max(S))=\sum_{T\subseteq S}{(-1)^{|T|}E(\min(T))}
$$

考虑后面那个式子怎么求。

令$P(T)$表示选中的位的集合是$T$的子集的概率，可以用高位前缀和预处理出来。

考虑如何计算$min(T)=K$的概率。

当$min(T)=K$时，前$K-1$次选择的位的集合都是$T$的补集的子集，第$K$次则不是$T$的补集的子集。

所以概率就为$P(U\bigoplus T)^{K-1}\cdot(1-P(U\bigoplus T))$。

于是
$$
E(min(T))=\sum_{i=1}^{+\infty}{i\cdot P(U\bigoplus T)^{i-1}\cdot(1-P(U\bigoplus T))}=\frac{1}{1-P(U\bigoplus T)}
$$
然后暴力枚举$T$累加贡献即可。


### 代码

```cpp
#include<cstdio>
using namespace std;
const int maxn=(1<<20)+5;
int n,cnt[maxn];double S[maxn],ans;
int main()
{
	scanf("%d",&n);
	for(int i=0;i<(1<<n);i++){scanf("%lf",&S[i]);cnt[i]=cnt[i>>1]+(i&1);}
	for(int i=0;i<n;i++)
		for(int j=0;j<(1<<n);j++)
			if(j&(1<<i))
				S[j]+=S[j-(1<<i)];
	for(int i=0;i<(1<<n)-1;i++)
	{
		ans+=((n-cnt[i])&1?1:-1)/(1-S[i]);
		if(S[i]==1){printf("INF\n");return 0;}
	}
	printf("%lf\n",ans);
	return 0;
}
```



---

## 作者：ニヒル (赞：1)

minmax容斥又称最值反演，是一种针对集合min->max或者max->min的反演  
结论公式为  
$max\{S\}=\sum_{T\subseteq S}(-1)^{|T|+1}min\{T\}$  
$min\{S\}=\sum_{T\subseteq S}(-1)^{|T|+1}max\{T\}$  
这个应该还蛮好证明的  
我们考虑构造一个函数  
$max\{S\}=\sum_{T\subseteq S}F(|T|)min\{T\}$  
那么分析一下第$x+1$大的数字会被枚举到几次  
显然是从比他大的$x$个里任意取出若干个与他构成集合，也就是  $\sum_{i=0}^{x}{x\choose i}$个  
然后他出现的次数应该是$\sum_{i=0}^{x}{x\choose i}f(i+1)$  
显然只有第0大（最大）的才会出现次数是一，所以我们规定大函数$F(x)=[x==0]$    
$F(x)=\sum_{i=0}^{x}{x\choose i}f(i+1)$  
愉快的二项式反演一波  
$f(x+1)=\sum_{i=0}^{x}(-1)^{x-i}{x\choose i}F(i)$   
$f(x+1)=\sum_{i=0}^{x}(-1)^{x-i}{x\choose i}[i==0]$
$f(x+1)=(-1)^{x}$  
$f(x)=(-1)^{x-1}$  
但其实$(-1)^{x-1}$与$(-1)^{x+1}$也没啥差别对吧，所以最值反演按照上面表述也是正确的。  

同样的minmax容斥可以被扩展成这样子两个式子  
$lcm\{S\}=\prod_{T \subseteq S}gcd\{T\}$  
$E[max\{S\}]=\sum_{T\subseteq S}(-1)^{|T|+1}E[min\{T\}]$  

这道题要用到的就是后者。 
我们转化题意就是求全集中最后一个1出现的期望   
用minmax容斥可以转化成集合中第一个1出现的期望   
这个期望就是概率分之一，所以直接考虑概率
显然第一个1出现的概率就是1减去这个集合的补集的所有子集出现的概率和  
子集和什么的FMT就可以达到正确复杂度了  
那么这题就做完了  

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;

int lim,n;
double p[1100000],ans;
int cnt[1100000];

int main()
{
	scanf("%d",&n);
	lim=1<<n;
	for(int i=0;i<lim;i++) scanf("%lf",&p[i]);
	for(int mid=1;mid<lim;mid<<=1)
	{
		for(int i=0;i<lim;i+=(mid<<1))
		{
			for(int j=0;j<mid;j++)
			{
				p[i+j+mid]+=p[i+j];
			}
		}
	}
	for(int i=1;i<lim;i++)
	{
		cnt[i]=cnt[i>>1]+(i&1);
	}
	for(int i=1;i<lim;i++)
	{
		if(1.0-p[(lim-1)^i]<1e-9)
		{
			puts("INF");
			return 0;
		}
		ans+=((cnt[i]&1)?1.0:-1.0)*(1.0/(1.0-p[(lim-1)^i]));
	}
	printf("%.6lf",ans);
} 
```

---

## 作者：fanfansann (赞：0)



[点我看算法全家桶系列！！！](
https://fanfansann.blog.csdn.net/article/details/112974328)


---

**Weblink**

[https://www.luogu.com.cn/problem/P3175](https://www.luogu.com.cn/problem/P3175)

**Problem**

刚开始你有一个数字 $0$，每一秒钟你会随机选择一个 $[0,2^n-1]$ 的数字，与你手上的数字进行按位或。选择数字 $i$ 的概率是 $p_i$ 。保证 $0\leq p_i \leq 1$，$\sum p_i=1$ 。问期望多少秒后，你手上的数字变成 $2^n-1$。


**Solution**

分析题目，我们每次选择的数是在 $[0,2^n-1]$ 的数，进行按位或运算，显然无论如何选择，手里的数都不会大于 $2^n-1$。我们希望最后手里的数变为 $2^n-1$，即一个 $n$ 位二进制数 $x$ 中所有 $n$ 位全部变成 $1$，因此我们可以将问题抽象成，有一个 $n$ 位二进制数 $x$，开始 $n$ 位上全是 $0$，我们每次选择一个数，可以使得 $x$ 发生变化，最后 $x$ 的所有位全部变为 $1$ 的期望选择次数（时间）。

然后因为选择数字 $i$ 的概率为 $p_i$，我们每次选择数 $i$，使得该二进制数发生一些变化，直到所有二进制数全部变为 $1$，显然我们可以联想到一个类似的问题模型：有 $n\le 20$ 种牌，每种牌无限张，得到第 $i$ 种牌的概率为 $p_i$，问每张牌均至少拥有一张的期望购买次数（时间）。即 **HDU4336 Card Collector**，我们发现抽象出来问题模型之后，两个问题的模型几乎一模一样！

我们回想 **HDU4336 Card Collector** 是怎么解决的， Min - Max  容斥！

我们设 $a_i$ 为得到卡片 $i$ 的期望时间，集合 $S=\{a_i\}$。显然 $\max\{S\}$ 为得到最后一张卡片的期望时间（此时我们已经得到了所有的卡片，游戏结束），则 $\min\{S\}$ 为得到第一张卡片的期望时间。

显然有 Min - Max 容斥：


$$
\max(S)=\sum_{T\subseteq S}(-1)^{|T|+1}\min(T)
$$
$$
\min(S)=\sum_{T\subseteq S}(-1)^{|T|+1}\max(T)
$$ 

我们只需要直接爆搜计算集合 $S$ 的所有子集 $T$ 的 $\min(T)=\dfrac 1{\sum\limits_{i\in T}p_i}$ 即可在 $O(2^n)$ 的时间复杂度下求得 $\max(S)$，即为答案。

显然两个题目的模型是一模一样的，我们考虑使用 Min - Max 容斥解决本题。

类似的，我们设 $a_k$ 为二进制数 $x$ 的第 $k$ 位变为 $1$ 的期望时间，集合 $S=\{a_i\}$，显然这里的 $S$ 为全集，也就是二进制数 $x$ 的全部 $n$ 位，$S$ 的子集 $T$，表示某几位，也就是二进制数 $x$ 的 $y\le n$ 位。

显然 $\max\{S\}$ 为二进制数 $x$ 的所有位均为 $1$ 所有的期望时间， $\min\{S\}$ 为二进制数 $x$ 第一次有位数变为 $1$ 的期望时间。

$$\max(S)=\sum_{T\subseteq S}(-1)^{|T|+1}\min(T)$$ 

同样的，我们只需要计算集合 $S$ 的所有子集 $T$ 的 $\min(T)$ 即可。

显然根据期望公式有：

$$\min(T)=\sum\limits^{+\infty}_{i=1}i\times P(\min(T)=i)$$

其中 $P(\min(T)=i)$ 表示在第 $i$ 秒，集合 $T$ 中第一次出现了 $1$ 的概率，这也就意味着前 $i−1$ 秒内，每一秒，集合 $T$ 中均没有出现 $1$，即集合 $T$ 在全集 $S$ 的补集 $W$ 中出现了 $1$（$W=\complement_ST,W\cap T=\varnothing,W+T=S$，显然 $W=S\  \text{xor}\ T$，因为这里代表的是二进制数）。设每一秒为事件 $A$，显然有 $P(A)=\sum\limits_{w\subset  W}P(w)$ ，其中 $P(w)$ 表示出现的 $1$ 是在集合 $w$ 中的概率。

第 $i$ 秒，集合 $T$ 第一次出现 $1$，显然概率为 $1-P(A)=1-\sum\limits_{w\subset W}P(w)$。

显然为几何概型，期望为：
$$\begin{aligned}E(\min(T))&={\dfrac{1}{P}}&\\&=\dfrac{1}{1-\displaystyle\sum\limits_{w\subset W}P(w)},W=\complement_ST\end{aligned}$$

也就是说我们只需要计算出每个集合的子集和概率之和 $\displaystyle\sum\limits_{w\subset W}P(w)$ 即可利用  Min - Max  容斥在 $O(2^n)$ 的复杂度下计算出答案。

那么要怎么算呢？

显然如果直接枚举子集计算的话需要 $O(3^n)$，$n\le 20$，肯定要炸，所以考虑优化。

我们知道 FMT 计算按位或卷积的时候我们执行了这样一个 $O(n\log n)$ 的过程：

定义 $\text{F}(f)_n=\sum_{i\subseteq n}f_i$

$$\begin{aligned} &\text{F}(a)_n\times \text{F}(b)_n\\ &{=\sum_{i\subseteq n}a_i\sum_{j\subseteq n}b_j}\\ &{=\sum_{k\subseteq n}\sum_{i∪j=k}a_ib_j}\\ &{=\text{F}(c)_n} \end{aligned}$$

好嘛，FMT  就是枚举子集...

即：序列经历过一次 FMT 按位或变换之后得到的新的序列就是原序列的子集和形式！

因此我们可以直接利用一次 FMT 在 $O(m\log m),m=2^{n}$ 的复杂度下计算出所有的 $P(w)=\displaystyle\sum\limits_{w\subset W}P(w)$，然后利用  Min - Max  容斥在 $O(2^n)$ 的复杂度下计算出答案即可。




**Code**


```cpp 
// Problem: P3175 [HAOI2015]按位或
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3175
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org) 

#include <bits/stdc++.h>

using namespace std;  
const int N = 3e6 + 7;

int n, m, s, t, k, a[N];
double ans;
double p[N];
int cnt[N];

void FMT_OR(double *f, int n, double x = 1.0)
{
	for (int o = 2; o <= n; o <<= 1) {
		for (int i = 0, k = o >> 1; i <= n; i += o) {
			for (int j = 0; j < k; ++ j) {
				f[i + j + k] = f[i + j] * x + f[i + j + k];
			}
		}
	}
} 

int main()
{
	scanf("%d", &n);
	int S = (1 << n) - 1; 
	int limit = 1;
	while(limit <= S) limit <<= 1;
	for (int i = 0; i <= S; ++ i) 
		scanf("%lf", &p[i]);
	FMT_OR(p, limit); 

	for (int i = 1; i <= S; ++ i) 
		cnt[i] = cnt[i >> 1] + (i & 1);
	
	ans = 0;
	for (int i = 1; i <= S; ++ i) {
		int SminusT = S ^ i;
		if(1 - p[SminusT] < 1e-8) 
			return puts("INF"), 0;
		ans += 1.0 / (1.0 - p[SminusT]) * (cnt[i] & 1 ? 1 : -1);
	}
	printf("%.10f\n", ans);
	return 0;
}
```


---

## 作者：Jμdge (赞：0)

可能算是通过这道题学会了 Min-Max 容斥...

并且发现 FWT 并不全是个没用的东西...


这里有两个前置芝士：


# 一、Min-Max 容斥

上个结论： 

$$Min\{S\}=\sum_{T\subseteq S,T\not=\varnothing}(-1)^{|T|-1}Max\{T\} $$

$$Max\{S\}=\sum_{T\subseteq S,T\not=\varnothing}(-1)^{|T|-1}Min\{T\} $$

具体的证明其实很简单...我们考虑证明其中一个（以第一个为例），另一个可以用类似证法得到结论。咱直接考虑集合内元素不重的情况，因为相同大小我们强制规定他们之间存在大小关系就好了，并不影响结果

那么我们再把元素从小到大排个序，从前往后考虑每个值对答案的贡献...

>首先第一个元素有贡献当且仅当集合里只有它一个元素，那么这样的集合只有一个，所以它的贡献有且仅有一次；

>对于第二个元素，它除了自己一定要选以外，比他小的元素（这时只有第一个元素）全部可选可不选，总共有 $2^{1}=2$ 种方案，并且集合大小为奇数和为偶数的情况各有一次，两者贡献抵消

>对于后面的元素，可以用第二个元素类似的思路去想，最后我们发现除第一个元素以外的所有贡献都相互抵消了

当然咱也可以用二项式定理草率地证明一下，然后也能发现贡献相抵了，究其原因就是杨辉三角奇数列和偶数列之差为 0 ，而第一行为 1 是个特例 （因为只有一个元素）

于是乎得证...

但更重要的一点，我们发现这道题的期望步数满足可 Min-Max 容斥的性质：


$$E(Max\{S\})=\sum_{T\subseteq S,T\not=\varnothing}(-1)^{|T|-1} E(Min\{T\}) $$


这里的 $E(Max\{S\})$ 表示集合 S 中出现最晚的元素出现的期望步数，而 $E(Min\{S\})$ 则是集合 S 中出现最早的元素出现的期望步数

那么我们可以发现其实 $E(Max\{2^n-1\})$ 就是要求的答案...



# 二、FWT 的第一步

之所以说第一步...是因为这道题真的就只要用到 FWT 的第一步（子集和计算）

FWT 本身是求两个多项式的位运算卷积（简直毒瘤），其中或运算的 FWT 第一步就要用到子集和计算，对此咱可以用一段和 法法塔 极其相似的代码求解...

具体关于 FWT 的运算可以康康 [yyb聚聚](https://www.cnblogs.com/cjyyb/p/9065615.html) 和 [wjyyy聚聚](https://www.cnblogs.com/wjyyy/p/FWT.html) 写的博客...

为什么要用 FWT 相关知识？因为枚举子集 $3^n$ 复杂度爆炸了

或者康康 [这里](https://www.cnblogs.com/Judge/p/10920451.html) 的第三条...

如果令 $n$ 为多项式长度，其实 FWT 的复杂度是 $n ~log~ n$ ，而这道题长度为$2^n$ 所以复杂度为 $n·2^n $

但为什么要用到计算子集和呢？ 【冷静分析...

因为咱要求 $E(Min\{S\})$ 哇...

这玩意儿就表示 S 集合最早出现的元素期望的步数，那么这个值就等于所有和 S 交集不为空的值最早出现的期望步数，公式化表示一下就是：

$$E(Min\{S\})={1\over \sum_{T\cap S\not=\varnothing} P(T)}$$

这里 $P(T)$ 表示的是 T 这个值出现的概率，那么期望等于 1 除去概率这一点...您感性理解一下好了...这里由于所有满足条件的 T 只要出现一个即可，那么他们出现的概率之和 分之一 就是 S 中有元素出现的期望步数
...

那么咱发现这玩意儿贼难求...和 S 有交集？ wdnmd 这怎么求啊...但是咱发现所有的值 $[0,2^n-1]$ 出现的概率之和是 $1$ ，那么咱可以用 1 容去不满足条件的 T 出现概率之和，然后咱得到的其实就是要求的东西啊...

随后咱发现不满足条件的 T 就是总集中 S 的补集的所有子集...emmmm 有点绕，但并不影响解题...咱令 S 的补集为 S' ，那么咱原来要求的东西就变成了：

$$E(Min\{S\}) ={1\over 1-\sum_{T\subseteq S'} P(T)}$$


这样咱只要求出所有的 $S'$ 的子集概率和即可 $O(1)$ 得到 $E(Min\{S\})$ ，然后咱就可以 $O(2^n)$ 用 Min-Max 容斥得到答案辣~




# code

证明也证明完了，那么咱处理个子集和然后就可以计算答案了...


发现代码特别短...【话说咱一发上了 $top~4$ 是个什么鬼 ...

```
//by Judge
#include<bits/stdc++.h>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
int n,cnt[1<<20],N; double p[1<<20],ans;
int main(){ cin>>n,N=1<<n; fp(i,0,N-1) cin>>p[i],cnt[i]=cnt[i>>1]+(i&1);
	for(Rg int i=1;i<N;i<<=1) for(int I=i<<1,j=0;j<N;j+=I) fp(k,0,i-1) p[i+j+k]+=p[j+k];
	fp(i,1,N-1) if(1-p[(N-1)^i]>1e-8) ans+=((cnt[i]&1)?1:-1)/(1-p[(N-1)^i]);
	if(ans<1e-10) return !printf("INF\n"); else printf("%.10lf\n",ans);
}
```



---

## 作者：Yajnun (赞：0)

$MIN$−$MAX$ 容斥 + $FMT$经典好题，考虑分治

定义当前分治到的状态为$i$，$E_{i}$为$i$状态所有位变为$1$的期望，$P_{i}$为$i$状态所有位变为$1$的概率。

考虑第$x$位对答案的贡献，可能的情况有两种：

$1.$ 在前$x-1$位全变为$1$前，第$x$位就已经为$1$

$2.$ 前$x-1$位全变为$1$后若干轮后，第$x$位变为$1$

我们可以对该状态$X$，计算所有$x$位为$0$的数组成的状态记为状态$L$，将所有$x$位为$1$的数的概率加到对应的$x$位为$0$的数的概率上，再计算这些数组成的状态记为状态$A$。$sum_{0/1}= \sum_{i}[x$位为$0/1]p_{i}$

对于第一种情况很好考虑，$P_{1}=P_{A}-P_{L}$，$E_{1}=E_{A}-E_{L}$

对于第二种情况，考虑$P_{2}$，每一次有$sum_{1}$的概率成功到达结束状态，有$sum_{0}$的概率再随机一次，则$P_{2}=$$\frac{sum_{1}}{1-sum_{0}}$。

考虑$E_{2}$，枚举$k$轮后选到了$x$位为$1$的数，则它的期望为$E_{L}+(1+k)P_{L}$

$E_{2} =sum_{1} \sum_{k=0}^{∞} (E_{L}+(1+k)P_{L})sum_{0}^k = sum_{1}(  \frac{E_{L}}{1-sum0} + \frac{ P_{L} }{(1-sum0)^2} )$ 

复杂度$O(nlog_{}{n})$


---

## 作者：League丶翎 (赞：0)

[秋葉-树叶的一生，只是为了归根么](https://chlience.com)

### Problem

初始为 $0$ ，每一秒在 $[0,2^n-1]$ 中非等概率的选一个出来和当前数字异或，$i$ 被选中的概率为 $p[i]$，问期望多久当前数字变为 $2^n-1$

### Though

看到这东西肯定是 $MIN-MAX$ 容斥了
将整体的期望最大值转化为子集的期望最小值
$$MAX(S)=\sum_{T\in S}(-1)^{|T|+1}MIN(T)$$
先看下 $MIN(T)$ 怎么求

设对任意一个子集 $T$，被选中的概率为 $f(T)$
显然有

$$f(T)=\sum_{X\cap T\neq\emptyset}p[X]$$

不太优美，考虑变形
$$f(T)=1-\sum_{X\cap T=\emptyset}p[X]$$
$$f(T)=1-\sum_{X\subseteq \complement_ST}p[X]$$
$$1-f(\complement_ST)=\sum_{X\subseteq T}p[X]$$
忽然发现右半边和 $FMT$ 形式相同，只需要求出来然后取个反就能计算出 $f(T)$ 的值

再观察 $MIN-MAX$ 容斥的式子，那个 $(-1)^{|T|+1}$ 看起来很难受，如果是 $(-1)^{|S-T|}$ 就好了，直接 $FMI$ 就完事了

由于这是 $-1$ 的次幂，所以只需要考虑奇偶性，也就是说，如果 $|S|$ 为偶数，则 $|S-T|$ 和 $|T|+1$ 奇偶性相反，反之 $|S-T|$ 和 $|T|+1$ 奇偶性相同，所以直接上 $FMI$ 然后分情况将答案乘上 $1$ 或者 $-1$ 即可

不要问我为啥不枚举子集，因为我懒

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define double long double
const double eps = 1e-6;
int n , N;
double p[1 << 20];
double f[1 << 20];
void FMT(double *p , int N) {
	for(int l = 1 ; l < N ; l <<= 1)
		for(int i = 0 ; i < N ; i += (l << 1))
			for(int j = i ; j < i + l ; ++ j)
				p[j + l] += p[j];
}
void FMI(double *p , int N) {
	for(int l = 1 ; l < N ; l <<= 1)
		for(int i = 0 ; i < N ; i += (l << 1))
			for(int j = i ; j < i + l ; ++ j)
				p[j + l] -= p[j];
}
int main() {
	scanf("%d" , &n); N = 1 << n;
	for(int i = 0 ; i < N ; ++ i)
		scanf("%llf" , &p[i]);
	FMT(p , N);
	for(int i = 1 ; i < N ; ++ i) {
		if(fabs(1.0 - p[N - i - 1]) < eps) {
			puts("INF");
			return 0;
		}
		f[i] = (n % 2 ? 1.0 : - 1.0) / (1.0 - p[N - i - 1]);
	}
	FMI(f , N);
	printf("%llf\n" , f[N - 1]);
	return 0;
}
```



---


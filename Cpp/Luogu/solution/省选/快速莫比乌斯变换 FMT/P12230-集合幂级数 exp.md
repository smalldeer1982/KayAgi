# 集合幂级数 exp

## 题目描述

给定一个集合幂级数 $F(x)$，保证 $[x^{\varnothing}]F(x)=0$。定义 $x$ 的乘法为子集卷积，你需要对所有 $S\subseteq\{1,2,\cdots,n\}$ 求出 $[x^S]e^{F(x)}$ 对 $998244353$ 取模后的值。

如果你仍不清楚题意，可以阅读题面最后的提示部分。

## 说明/提示

#### 【数据范围】

对于所有数据，保证 $1\le n\le 20$，$[x^S]F(x)\in[0,998244353)\cap\mathbb Z$，$[x^{\varnothing}]F(x)=0$。

本题有 $20$ 个测试点，第 $i$ 个测试点满足 $n=i$。

#### 【提示】

假设 $F(x)=\sum_S f_Sx^S$，那么 $[x^S]F(x)=f_S$。

在本题中，$x$ 的乘法被定义为子集卷积，即：
$$x^S\cdot x^T=\begin{cases}0&S\cap T\neq\varnothing\\x^{S\cup T}&\text{otherwise}\end{cases}$$

根据泰勒展开，有：
$$e^{F(x)}=\sum_{n\ge 0}\frac{F^n(x)}{n!}$$

## 样例 #1

### 输入

```
2
0 1 2 3```

### 输出

```
1 1 2 5```

## 样例 #2

### 输入

```
4
0 11 83 73 34 53 72 57 81 92 10 31 44 33 93 10```

### 输出

```
1 11 83 986 34 427 2894 38772 81 983 6733 87643 2798 38232 238499 3459260```

# 题解

## 作者：Purslane (赞：7)

# Solution

集合幂级数的 $\exp$ 解决的是这样一个问题：给定全集 $U$ 和它的一个子集 $S$，计算：

$$
\sum_{S_1 \cup S_2 \cup \cdots \cup S_k = S , |S_1| + \cdots + |S_k| = |S|} \prod a_{S_i}
$$

注意这里的 $S_i$ 是无序的，我们只考虑他们构成的子集族。

定义两个集合幂级数的乘法为子集卷积，那么给定集合幂级数 $F$（要求 $[x^{\varnothing}]F = 0$）求出 $T = \sum_{i \ge 0 } \dfrac{F^i}{i!}$。

经典的，我们定义 $F_i = \sum_{S} [x^S] F \times [\text{popcount}(S) = i]$。

那么对于每个 $S$ 和正整数 $t$，我们只用求出 $g_t = \sum_k \frac{1}{k!} \sum_{i_1 + i_2 + \cdots i_k = t}  \prod_j F_{i_j,S}$。发现对于固定的 $S$，$g_*$ 就是 $F_{*,S}$ 在形式幂级数意义下的 $\rm exp$。

但是这里我们不用真的去算 $\rm exp$，因为维数太小了！事实上，[我们有 $O(n^2)$ 求 $\exp$ 的方法](https://www.cnblogs.com/tzcwk/p/dxs-sqr.html)，直接递推即可。

复杂度 $O(n^2 2^n)$。

```cpp
#include<bits/stdc++.h>
#define int long long 
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=(1<<20)+10,MOD=998244353;
int n,a[MAXN],f[21][MAXN],g[21][MAXN];
void fwt(int *f,int l,int r) {
	if(l==r) return ;
	int mid=(l+r)>>1;
	fwt(f,l,mid),fwt(f,mid+1,r);
	ffor(i,l,mid) {
		int j=i-l+mid+1;
		int x=f[i],y=f[j];
		f[i]=(x+y)%MOD,f[j]=(x-y)%MOD;
	}
	return ;
}
int inv[MAXN];
int qpow(int base,int p) {
	int ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;
	}
	return ans;
}
void exp(int *f,int *g) {
	g[0]=1;
	ffor(i,1,n) {
		ffor(j,1,i) g[i]=(g[i]+g[i-j]*f[j]%MOD*j)%MOD;
		g[i]=g[i]*inv[i]%MOD;	
	}
	return ;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n;
	ffor(i,0,(1<<n)-1) cin>>a[i],f[__builtin_popcount(i)][i]=a[i];
	ffor(i,1,n) inv[i]=qpow(i,MOD-2);
	ffor(i,0,n) fwt(f[i],0,(1<<n)-1);
	ffor(i,0,(1<<n)-1) {
		int F[21],G[21];
		memset(F,0,sizeof(F)),memset(G,0,sizeof(G));
		ffor(j,0,n) F[j]=f[j][i];
		exp(F,G);
		ffor(j,0,n) g[j][i]=G[j]; 
	}
	ffor(i,0,n) fwt(g[i],0,(1<<n)-1);
	int div=qpow(1<<n,MOD-2);
	ffor(i,0,(1<<n)-1) cout<<(g[__builtin_popcount(i)][i]*div%MOD+MOD)%MOD<<' ';
	return 0;
}
```

把 $\exp$ 换成 $\ln$ 或者乘法逆就可以把另外两个模板题给过了。

---

## 作者：山田リョウ (赞：3)

本文旨在解决不保证 $m\in\mathbb{P}$ 时如何进行 $F_m[x_0,x_1,\cdots,x_{n-1}]/[x_0^2,x_1^2,\cdots,x_{n-1}^2]$ 上的 $\exp$。

$\exp$ 的组合意义是将大集合划分为多个无序小集合的方案数，不保证 $m\in\mathbb{P}$ 带来的影响在于没有逆元而无法在把集合的集合当做集合序列后再除以 $k!$，因此我们考虑不需要除以 $k!$ 的做法。

一个简单的想法就是为集合钦定一个统计顺序，我们不妨考虑按照集合最小元从小到大排序，然后我们依次枚举。

因此 $\exp(f(x))=\prod\limits_{i=0}^{n-1}(1+\sum\limits_{\min\left(S\right)=i}x^S[x^S]f(x))$，直接子集卷积即可，使用一些简单地打标记即可做到 $O(2^nn^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace AfterTheRainStops{//雨停酱可爱捏~ 最喜欢雨停姐姐了！！！
const int mod=998244353;
int sum(int x,int y){return mod-x>y?x+y:y-(mod-x);}
int dif(int x,int y){return x<y?mod-(y-x):x-y;}
int pro(int x,int y){return 1ll*x*y%mod;}
void fmt(int f[1<<20][21],int n,int op){
    for(int i=0;i<n;++i)
        for(int s=0;s<(1<<n);++s)
            if((s>>i)&1)
                if(op){
                    for(int j=0;j<=n;++j)
                        f[s][j]=dif(f[s][j],f[s^(1<<i)][j]);
                }else{
                    for(int j=0;j<=n;++j)
                        f[s][j]=sum(f[s][j],f[s^(1<<i)][j]);
                }
}
int f[1<<20][21],g[1<<20][21],tmp1[21],tmp2[21];
void main(){
    int n;
    scanf("%d",&n);
    for(int i=0;i<(1<<n);++i)scanf("%d",&f[i][__builtin_popcount(i)]);
    fmt(f,n,0);
    for(int i=0;i<(1<<n);++i)g[i][0]=1;
    for(int i=0;i<n;++i){
        for(int s=1;s<(1<<n);++s)
            if((s&-s)==(1<<i)){
                memcpy(tmp1,g[s],sizeof(tmp1)),memset(g[s],0,sizeof(g[s]));
                for(int j=0;j<=n;++j)tmp2[j]=dif(f[s][j],f[s^(1<<i)][j]);
                tmp2[0]=sum(tmp2[0],1);
                for(int x=0;x<=n;++x)
                    for(int y=0;x+y<=n;++y)
                        g[s][x+y]=sum(g[s][x+y],pro(tmp1[x],tmp2[y]));
            }
    }
    for(int s=1;s<(1<<n);++s)
        for(int i=0;!((s>>i)&1);++i){
            memcpy(tmp1,g[s|(1<<i)],sizeof(tmp1)),memset(g[s|(1<<i)],0,sizeof(g[s|(1<<i)]));
            for(int x=0;x<=n;++x)
                for(int y=0;x+y<=n;++y)
                    g[s|(1<<i)][x+y]=sum(g[s|(1<<i)][x+y],pro(tmp1[x],g[s][y]));
        }
    fmt(g,n,1);
    for(int i=0;i<(1<<n);++i)printf("%d ",g[i][__builtin_popcount(i)]);
}
}
int main(){
    AfterTheRainStops::main();
    return 0;
}
```

[submission.](https://www.luogu.com.cn/record/219390576)

---


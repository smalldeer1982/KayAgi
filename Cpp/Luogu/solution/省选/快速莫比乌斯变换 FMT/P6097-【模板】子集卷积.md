# 【模板】子集卷积

## 题目背景

这是一道模板题。

## 题目描述

给定两个长度为 $2^n$ 的序列 $a_0,a_1,\cdots,a_{2^n-1}$ 和 $b_0,b_1,\cdots,b_{2^n-1}$，你需要求出一个序列 $c_0,c_1,\cdots,c_{2^n-1}$，其中 $c_k$ 满足：

$$c_k=\sum_{\substack{{i \& j=0}\\{i~\mid~ j=k}}} a_i b_j$$

其中$~\mid~$表示按位或，$\&$表示按位与。

答案对 $10^9+9$ 取模。

## 说明/提示

对于所有数据，$1\le n\le 20$，$0\le a_i,b_i< 10^9+9$。

## 样例 #1

### 输入

```
2
1 0 2 1
2 0 2 1```

### 输出

```
2 0 6 3```

# 题解

## 作者：EternalAlexander (赞：48)

记 $|S|$ 表示集合 $S$ 的元素个数，$*$ 表示子集并卷积运算，即 $h_i = \sum_{j\cup k = i} f_j \times g_k$。

第一个限制 $i \cup j=k$ 容易处理，直接 FWT 计算子集并卷积即可。

考虑第二个限制 $ i \cap j=\varnothing$，等价于 $|i|+|j|=|i\cup j|$。我们再开一维记录集合中的元素个数即可。

具体地，令 $f_{i,j} = \begin{cases}a_j\,(|j|=i)\\0\end{cases}$，$g_{i,j} = \begin{cases}b_j\,(|j|=i)\\0\end{cases}$，有 $h_i=\sum_{k=0}^i f_k * g_{i-k}$。最后我们所求的答案 $c_i = h_{|i|,i}$。

复杂度 $\mathcal O(n^2 2^n)$。供题人开 3s 不知道是什么心态，不明白模板题卡常有什么意义。

```cpp
#include <bits/stdc++.h>
#define ll long long
const int mod=1e9+9;
int a[22][1<<21],b[22][1<<21],h[22][1<<21],n,t;
int ctz(int x){return __builtin_popcount(x);}

void fwt(int *a,int n,int flag){
	for(int i=1;i<n;i<<=1)
	for(int len=i<<1,j=0;j<n;j+=len)
	for(int k=0;k<i;++k){
		if (flag==1)a[j+k+i]=(a[j+k]+a[j+k+i])%mod;
		else a[j+k+i]=(a[j+k+i]-a[j+k]+mod)%mod;
	}
}


int main(){
	scanf("%d",&n);
	int lim=n;n=1<<n;
	for(int i=0;i<n;++i)
		scanf("%d",&a[ctz(i)][i]);
	for(int i=0;i<n;++i)
		scanf("%d",&b[ctz(i)][i]);
	for(int i=0;i<=lim;++i){
		fwt(a[i],n,1);fwt(b[i],n,1);
	}for(int i=0;i<=lim;++i)
		for(int j=0;j<=i;++j)
			for(int k=0;k<n;++k)h[i][k]=(h[i][k]+(ll)a[j][k]*b[i-j][k]%mod)%mod;
	for(int i=0;i<=lim;++i)fwt(h[i],n,-1);
	for(int i=0;i<n;++i)printf("%d ",h[ctz(i)][i]);
	return 0;
}
	
	
	
	
```


---

## 作者：yijan (赞：27)

# 子集卷积

当然您也可以到[这里](https://www.cnblogs.com/yijan/p/12387352.html)阅读

## FMT

给定数列 $ a_{0\dots 2^{k}-1} $ 求 $ b $ 满足 $ b_{s} = \sum_{i\in s} a_i $

实现方法很简单，

```
for( i in 0 to n-1 ) 
	for( j in 0 to 2^n-1)
		if( j & ( 1 << i ) ) 
			a[j] += a[j ^ ( 1 << i )]
```

然后称为 $ B = \text{FMT}(A) $ ，快速莫比乌斯变换

想要还原也很简单，把代码反着写：

```
for( i in n-1 downTo 0 ) 
	for( j in 2^n - 1 downTo 0)
		if( j & ( 1 << i ) ) 
			a[j] -= a[j ^ ( 1 << i )]
```

当然， $ i $ 的顺序可以是原来的顺序，因为按照哪个顺序枚举位根本不重要

同时，$ j $ 的顺序也不重要，考虑对于一个数字，它只有在当前枚举的位数为 1 的时候才被执行，所以就算已经枚举到这位是 0 的状态，它也不会被更新。

所以甚至只需要改个符号就是逆变换了

```
for( i in 0 to n-1 ) 
	for( j in 0 to 2^n-1)
		if( j & ( 1 << i ) ) 
			a[j] -= a[j ^ ( 1 << i )]
```

这样 $ A = \text{IFMT}( B ) $

FMT 可以写成 FFT 那样的形式，可以移步 FWT 题解区有很多，就不赘述了。

## 或卷积

或卷积就需要用到这个东西。

或卷积是指：
$$
C_s = \sum_{i|j=s} A_i B_j
$$
有一个结论， $ \text{FMT}(C) = \text{FMT}(A) \cdot \text{FMT}(B) $ ，其中 $\cdot$ 指点积，也就是把每个位置的函数值乘起来。

原因是 $(i \cup j) \subseteq s$ 等价于 $(i \subseteq  s)\land(j \subseteq s)$ 。于是
$$
\begin{aligned} 
\ [x]FMT(C) 
&=\sum_{s \subseteq x}C_s\\
&= \sum_{s \subseteq x}\sum_{i|j = s}A_iB_j\\
&= \sum_{i|j \subseteq x} A_iB_j\\
&= ( \sum_{i\subseteq x} A_i )(\sum_{j\subseteq x} B_j)\\
&= [x]FMT(A) \cdot [x]FMT(B) 
\end{aligned}
$$
所以有 $ \text{FMT}(C) = \text{FMT}(A) \cdot \text{FMT}(B) $ 

于是可以 $ O(n2^n) $ 做这个。

## 子集卷积

子集卷积长这样：
$$
C_s = A\times_{subset} B = \sum_{i|j=s,i\&j = 0} A_i B_j
$$


如果设 $ p(x) $ 为 $ x $ 的 popcount（ 1 的个数），那么：

$$
(i|j = s) , (i\&j = 0) \Leftrightarrow i|j = s , p(i)+p(j) = p(s)
$$
$$
C_s = \sum_{i|j = s , p(i)+p(j) = p(s)} A_iB_j
$$
我们把 $ C $ 扩展到二维，设 $ C'_{x,k} $，定义如下： 
$$
C'_{x,s} = \sum_{i|j = s,p(i)+p(j) = x} A_iB_j[p(s) = x]
$$
把 $ C $ 扩展到二维了，$ A $ 也扩展到二维，定义 $ A'_{p,s} $ 
$$
A'_{x,s} = \left\{\begin{aligned}&0 & {p(s) \neq x}\\&A_{s} & {p(s) = x} \end{aligned}\right.
$$
同理定义 $ B'_{x,s} $

我们知道
$$
C'_{x,s} = \sum_{i|j = s,p(i)+p(j) = x} A'_{p(i),i} B'_{p(j),j}
$$
观察到 $ C'_x = \sum_{i=0}^x A'_{i}\times_{or} B'_{x-i} $ ，而且需要最后去掉左边的 $ p(s) \neq x $ 的情况。

这样复杂度 $ O(n^3 2^n) $，一共要卷 $ n^2 $ 次。 

注意 $ \text{FMT} , \text{IFMT} $ 都有可加性，所以我们把那个或卷积写成 $ \text{FMT} $ 的形式
$$
\begin{aligned}C'_{x} &= \sum_i IFMT(FMT(A'_i) · FMT(B'_{x-i}))\\&= IFMT( \sum_i FMT(A_i') · FMT(B_{x-i}') )\end{aligned}
$$
我们现在只需要处理出所有 $ A'_i $ 和 $ B'_{i} $ 的 FMT ，最后再跑 $ n $ 次逆 FMT ，所以这样做就优化到了 $ O( 2^n n^2 ) $

不知道为啥 开O2 TLE 了。。。注意模数是 $ 10^9+9 $ 不是 $ 10^9+7 $。。。~~目害了成功wa了两发~~

```cpp
#include "iostream"
#include "algorithm"
#include "cstring"
#include "cstdio"
using namespace std;
#define P 1000000009
int rd( ) {
    char ch = ' '; int ret = 0;
    while( ch > '9' || ch < '0' ) ch = getchar();
    while( ch >= '0' && ch <= '9' ) ret = ret * 10 + ch - '0' , ch = getchar();
    return ret;
}

int A[1<<21] , B[1<<21] , n , len;
int a[21][1<<21] , b[21][1<<21] , c[21][1<<21];

void FMT( int A[] , int l ) {
    for( int i = 0 ; i < l ; ++ i )
        for( int j = 0 ; j < ( 1 << l ) ; ++ j )
            if( j & ( 1 << i ) ) A[j] = ( A[j] + A[j ^ ( 1 << i )] ) % P;
}
void IFMT( int A[] , int l ) {
    for( int i = 0 ; i < l ; ++ i )
        for( int j = 0 ; j < ( 1 << l ) ; ++ j )
            if( j & ( 1 << i ) ) A[j] = ( A[j] + P - A[j ^ ( 1 << i )] ) % P;
}

int main() {
    cin >> n; len = ( 1 << n );
    for( int i = 0 ; i < len ; ++ i ) A[i] = rd() , a[__builtin_popcount(i)][i] = A[i];
    for( int i = 0 ; i < len ; ++ i ) B[i] = rd() , b[__builtin_popcount(i)][i] = B[i];
    for( int i = 0 ; i <= n ; ++ i ) FMT( a[i] , n ) ,  FMT( b[i] , n );
    for( int x = 0 ; x <= n ; ++ x ) {
        for( int i = 0 ; i <= x ; ++ i )
            for( int j = 0 ; j < ( 1 << n ) ; ++ j )
                ( c[x][j] += 1ll * a[i][j] * b[x - i][j] % P ) %= P;
        IFMT( c[x] , n );
    }
    for( int i = 0 ; i < len ; ++ i ) printf("%d ",c[__builtin_popcount(i)][i]);
}
```



---

## 作者：ix35 (赞：20)

子集卷积，解决的就是这样的问题：

$$h_S=\sum\limits_{L\cup R=S,\ L\cap R=\varnothing}f_Lg_R$$

首先有个 $O(3^n)$ 的暴力枚举子集的算法，但这显然不是我们想要的。

设 $f(i,S)=\sum\limits_{T\in S,\ |T
|=i} f(T)$。

那么初始条件是 $f(|S|,S)=f(S)$，然后对于每一个确定的 $i$，做一次 FWT 即可得到所有的 $f(i,S)$，这里的时间复杂度是 $O(n^22^n)$，因为 FWT 的复杂度是 $O(n2^n)$。

一个很好的性质：

$$h(i,S)=\sum\limits_{j=0}^i f(j,S)g(i-j,S)$$

这是因为：根据 FWT 的理论，$h$ 中的 $S$ 项应该有 $f,g$ 的 $S$ 项相乘得到，而如果 $L\cup R=S,\ L\cap R=\varnothing$，就意味着 $|L|+|R|=|S|$。

最后对于所有 $i$，把 $h(i,S)$ 做一次 IFWT，就得到的要求的 $h$ 数组。

放个一开始写的不卡常的代码，这个是 **不能** AC 的。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=21,MAXM=1100010,P=1e9+9;
int n,f[MAXN][MAXM],g[MAXN][MAXM],h[MAXN][MAXM];
int bitcnt (int x) {
	int res=0;
	while (x) {res++,x-=(x&(-x));}
	return res;
}
void fwtor (int a[],int lim,int type) {
	for (int i=1;i<lim;i<<=1) {
		for (int j=0;j<lim;j+=(i<<1)) {
			for (int k=0;k<i;k++) {
				a[j+k+i]=((a[j+k+i]+a[j+k]*type)%P+P)%P;
			}
		}
	}
	return;
}
int main () {
	scanf("%d",&n);
	for (int i=0;i<(1<<n);i++) {scanf("%d",&f[bitcnt(i)][i]);}
	for (int i=0;i<(1<<n);i++) {scanf("%d",&g[bitcnt(i)][i]);}
	for (int i=0;i<=n;i++) {fwtor(f[i],1<<n,1),fwtor(g[i],1<<n,1);}
	for (int i=0;i<=n;i++) {
		for (int j=0;j+i<=n;j++) {
			for (int s=0;s<(1<<n);s++) {
				h[i+j][s]=(h[i+j][s]+(1ll*f[i][s]*g[j][s])%P)%P;
			}
		}
	} 
	for (int i=0;i<=n;i++) {fwtor(h[i],1<<n,-1);}
	for (int i=0;i<(1<<n)-1;i++) {printf("%d ",h[bitcnt(i)][i]);}
	printf("%d\n",h[n][(1<<n)-1]);
	return 0;
}
```


---

## 作者：皎月半洒花 (赞：11)

萌新由于太弱被卡了常。~~那一定是FMT自身常数太大了~~

_____

如果不会 FMT 可以移步谷谷的板子题或者[我的博客](https://www.orchidany.cn/2019/08/26/fmt/)

快速子集变换(FST)是在 FMT 基础上的扩展，解决的也是子集交卷积，但是限制了状态不重复，即

$$c_i=\sum_{\begin{aligned}~k &\cup j=i\\ k &\cap j= \emptyset \end{aligned}}a_kb_j$$

换个写法：

$$
c_s=\sum_{t\subseteq s}a_sb_{s-t}
$$

这东西其实也不是非要用 FMT 来做，FWT 也可以。

然后就是考虑在卷积的时候多增加一维，即 $f_{i,S}$ 表示集合 $S$ 中有 $i$ 个元素，于是发现只有当元素个数相加符合时才是对的。

于是一开始将 $f_{bct(s),s}$ 赋值为 $f_s$，其中 $bct(s)=\rm bitcount(s)$。然后对每一个 $f_i$ 分别做 FMT，之后按位乘的时候需要

$$P_{i, S}=\sum_{i=0}^{i} f_{j, S} \times g_{i-j, S}$$

输出的时候只输出 $P_{bct(s),s}$ 即可。

复杂度似乎是两个 $\log$ 的？然而并不满。推荐取模优化。


```cpp
#define MAXN 21
#define MAXM 2000010
#define Mod 1000000009

#define I inline
#define LL long long

using namespace std;
int bc[MAXM];
int N, M;
int A[MAXN][MAXM], B[MAXN][MAXM], C[MAXN][MAXM];

I int read() {
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
I void reduce(int &x) { x += x >> 31 & Mod; }
I void Ifmt(int *f) {
    register int i, j;
    for (i = 0; i < N; ++i)
        for (j = 0; j <= M; ++j)
            if (j >> i & 1)
                reduce(f[j] -= f[j ^ 1 << i]);
}
I void fmt(int *f) {
    register int i, j;
    for (i = 0; i < N; ++i)
        for (j = 0; j <= M; ++j)
            if (j >> i & 1)
                reduce(f[j] += f[j ^ 1 << i] - Mod);
}
int main() {
    cin >> N;
    M = (1 << N) - 1;
    register int i, j, s;
    for (i = 1; i <= M; ++i) bc[i] = bc[i - (i & -i)] + 1;
    for (i = 0; i <= M; ++i) A[bc[i]][i] = read();
    for (i = 0; i <= M; ++i) B[bc[i]][i] = read();
    for (i = 0; i <= N; ++i) fmt(A[i]), fmt(B[i]);
    for (i = 0; i <= N; ++i)
        for (j = 0; j <= i; ++j)
            for (s = 0; s <= M; ++s) (C[i][s] += 1ll * A[j][s] * B[i - j][s] % Mod) %= Mod;
    for (i = 0; i <= N; ++i) Ifmt(C[i]);
    for (i = 0; i <= M; ++i) printf("%d ", C[bc[i]][i]);
}

```


---

## 作者：SAMSHAWCRAFT (赞：6)

Update: 代码挂了，修复一下。

Update: 修改了 FWT 和 FMT 的名称问题。

集合幂级数，是一种关于集合的形式幂级数。约定 $S=\{1,2,\cdots,n\}$ 为全集，设 $\mathbb{F}$ 为一个域，则称 $f:2^S\mapsto\mathbb{F}$ 为 $\mathbb{F}$ 上的一个集合幂级数，$f$ 可以记作 $f=\sum_{T\in 2^S}f_Tx^T$，这里的 $f_T$ 即这个集合幂级数的第 $T$ 项系数。用不太严谨的话说，集合幂级数就是一个形式幂级数，一般的形式幂级数都是以一个整数为下标，而集合幂级数以一个集合为下标，这个集合其实可以对应到二进制中，因此集合幂级数也可以写成一般的形式幂级数的形式，对集合幂级数下标（集合）进行的运算可以看成对形式幂级数下标（整数）的位运算。

而本题求的子集卷积其实就是对给定的两个集合幂级数 $f$ 和 $g$ 求不相交集合并卷积的过程，即求 $h_S=\sum_{T_1\cup T_2=S\land T_1\cap T_2=\varnothing}f_{T_1}g_{T_2}$，将集合下标转换为整数下标，其实就是题面上的 $h_k=\sum_{i|j=k \land i\&j=0}f_{i}g_{j}$ ，定义 $\mathtt{popcount(x)}$ 为 $\mathtt x$ 二进制下 1 的个数，我们不难知道，满足 $T_1\cup T_2=S\land T_1\cap T_2=\varnothing$ 的集合 $T_1$ 和 $T_2$ 对应的下标 $i$ 和 $j$ 满足 $i|j=k\land\mathtt{popcount(}i\mathtt)+\mathtt{popcount(}j\mathtt)=\mathtt{popcount(}k\mathtt)$ 。

对于前一个条件我们用 FWT OR 卷积或 FMT OR 卷积解决，后一个条件我们用占位多项式解决。

**FWT OR 卷积**

这个问题的模板题是 [【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)](https://www.luogu.com.cn/problem/P4717) 。其实 FWT 类似 FFT，也有转移矩阵，对于 FWT OR 的转移矩阵，其实就是做了一个前缀和：

$$A=\begin{bmatrix}
1 & 0 & 0 & \cdots & 0 \\
1 & 1 & 0 & \cdots & 0 \\
1 & 1 & 1 & \cdots & 0 \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
1 & 1 & 1 & \cdots & 1
\end{bmatrix}$$

而 FWT OR 的逆变换是差分。由这个转移矩阵我们可以写出 FWT OR 卷积的代码：

```cpp
void FWTOR(int limit,int *arr,int sign){
  for(int l=2;l<=limit;l<<=1)
    for(int cx=0;cx<limit;cx+=l)
      for(int cy=0;cy<(l>>1);++cy)
        arr[cx+cy+(l>>1)]=(arr[cx+cy+(l>>1)]+arr[cx+cy]*sign+mod)%mod;
}
```

上面代码中 `FWTOR` 的 `sign` 为 1 时做的是 FWT OR 的变换，为 -1 时做的是 FWT OR 的逆变换，即为 1 时做前缀和，为 -1 时做差分。

**占位多项式**

占位多项式就是为了适应子集卷积的 $\mathtt{popcount(}i\mathtt)+\mathtt{popcount(}j\mathtt)=\mathtt{popcount(}k\mathtt)$ 的条件而产生的。集合幂级数 $f$ 的占位多项式定义如下：

$$f_{i,j}=\begin{cases}1,&\mathtt{popcount(}j\mathtt)=i\\0,&\mathtt{popcount(}j\mathtt)\ne i,\end{cases}$$

只要我们让满足 $\mathtt{popcount(}i\mathtt)+\mathtt{popcount(}j\mathtt)=\mathtt{popcount(}k\mathtt)$ 的多项式进行 OR 卷积就好啦。代码如下：

```cpp
for(int cx=0;cx<=n;++cx)
    FWTOR(lim,f[cx],1),FWTOR(lim,g[cx],1);
for(int cx=0;cx<=n;++cx)
  for(int cy=0;cx+cy<=n;++cy)
    for(int p=0,bt=cx+cy;p<lim;++p)
      c[bt][p]=(c[bt][p]+1LL*f[cx][p]*g[cy][p]%mod)%mod;
for(int cx=0;cx<=n;++cx)
  FWTOR(lim,c[cx],-1);
```

然后据说这题卡常，我的程序跑得最慢的点差不多有 2.0 s，勉强能过，大家注意一下代码实现有什么优化的地方，尽量卡卡常，保证正确的情况下能少取模就少取模。下面是我的全部代码：

```cpp
#include <stdio.h>
#include <algorithm>
#define qaq inline
#define alqaq __attribute__((always_inline)) inline
using ll=long long;
const ll mod=1e9+9;
const int sz=(1<<21|1);
int lim,n,f[21][sz],g[21][sz],c[21][sz];
alqaq int popcount(int x){
  return __builtin_popcount(x);
}
qaq void FWTOR(int limit,int *arr,int sign){
  for(int l=2;l<=limit;l<<=1)
    for(int cx=0;cx<limit;cx+=l)
      for(int cy=0;cy<(l>>1);++cy)
        arr[cx+cy+(l>>1)]=(arr[cx+cy+(l>>1)]+arr[cx+cy]*sign+mod)%mod;
}
int main(){
  scanf("%d",&n);
  lim=(1<<n);
  for(int cx=0;cx<lim;++cx)
    scanf("%d",&f[popcount(cx)][cx]);
  for(int cx=0;cx<lim;++cx)
    scanf("%d",&g[popcount(cx)][cx]);
  for(int cx=0;cx<=n;++cx)
    FWTOR(lim,f[cx],1),FWTOR(lim,g[cx],1);
  for(int cx=0;cx<=n;++cx)
    for(int cy=0;cx+cy<=n;++cy)
      for(int p=0,bt=cx+cy;p<lim;++p)
        c[bt][p]=(c[bt][p]+1LL*f[cx][p]*g[cy][p]%mod)%mod;
  for(int cx=0;cx<=n;++cx)
    FWTOR(lim,c[cx],-1);
  for(int cx=0;cx<lim;++cx)
    printf("%d ",c[popcount(cx)][cx]);
  return 0;
}
```

---

## 作者：Doqe (赞：5)

[前置文章](https://www.luogu.com.cn/article/88ytk5jf)。其包含了这里的一些概念。

### 原始算法

在这题里我们希望：

$$c^0=W(a^0,b^0),c^1=W(a^0,b^1)+W(a^1,b^0)$$

好消息是总项数只有 $3$，直接做也是 $O(3^n)$ 的，坏消息是难以用前置文章中的通用思路构造出小于 $3$ 的项数。

这个形式形如一个真正的卷积，我们搓出一个形式元 $x$，有：

$$W(a^0+a^1x,b^0+b^1x)=W(a^0,b^0)+(W(a^0,b^1)+W(a^1,b^0))x+W(a^1,b^1)x^2$$

也就是 $c^0+c^1x+W(a^1,b^1)x^2$。

$c^0$ 可以直接表示，分离出来，剩下 $c^1x+W(a^1,b^1)x^2$。我们可以发现这部分答案是 $x$ 的系数，也是**最低有效位**的系数。那就有 $[x^n]\sum_{i=1}^n(c_ix+d_ix^2)=\prod c_i$，即可以完美保存最低有效位的乘积，其余位置和没有一样。

那就好办了。

$$d^0=W(a^0,a^1),d^1=W(a^0+a^1x,b^0+b^1x)$$

$$c^0=d^0,c'^1=d^1-d^0$$

这里的 $c'^1$ 是多项式，真正答案在于最低有效位，可以推出 $i$ 的最低有效位的指数是 $\operatorname{popcount}(i)$。

分析复杂度，在 “FMT” 和 “IFMT” 过程之中，所有操作是加法和乘 $x$，均为线性；其余操作是执行 $2^n$ 次的卷积。总复杂度 $O(2^nn^2)$。

（PS：如果你让 $x=\epsilon$，足够小的话，最后的结果形如 $Ax^k+\sum_{i\ge k+1}Bx^{i}$，剩余部分完全能够被区分出来。只不过这要求 $x=O(nV)$，也就是需要上高精度，导致和一般的子集卷积复杂度相同。）

（PS：这部分和一般不使用 $x$ 的算法，在张量分析下可以使用普通张量秩和边界秩分别解释，即 $\sum a_i\circ b_i\circ c_i=X$ 还是 $\sum a_i\circ b_i\circ c_i=Xx^k+Yo(x^k)$（如果不知道这表示什么东西的话可以忽略），其天然对应占位多项式。）

此时的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const unsigned P=1e9+9,N=1<<20|3;
unsigned a[N][21],b[N][21];
int n;
inline void ADD(unsigned&A,unsigned B){A=(A+B>=P?A+B-P:A+B);}
void _FMT(unsigned a[][21])
{
	for(int i=0;i<n;++i)
		for(int j=0;j<(1<<n);++j)if(!(j>>i&1))
		{
			unsigned *A=a[j|(1<<i)],*B=a[j]; 
			memmove(A+1,A,80);A[0]=B[0];
			for(int i=1;i<=n;++i)ADD(A[i],B[i]);
		}
}
void _IFMT(unsigned a[][21])
{
	for(int i=0;i<n;++i)
		for(int j=0;j<(1<<n);++j)if(!(j>>i&1))
		{
			unsigned *A=a[j|(1<<i)],*B=a[j];
			for(int i=0;i<=n;++i)ADD(A[i],P-B[i]);
		}
}
unsigned long long tmp[21];
int main()
{
	cin.tie(0)->sync_with_stdio(0);
	cin>>n;
	for(int i=0;i<(1<<n);++i)cin>>a[i][0];
	for(int i=0;i<(1<<n);++i)cin>>b[i][0]; 
	_FMT(a),_FMT(b);
	for(int i=0;i<(1<<n);++i)
	{
		memset(tmp,0,sizeof tmp);
		for(int j=0;j<=n;++j)
			for(int k=0;j+k<=n;++k)
				(tmp[j+k]+=1ull*a[i][j]*b[i][k]))%=P;
		for(int j=0;j<=n;++j)
			a[i][j]=tmp[j]%P;
	}
	_IFMT(a);
	for(int i=0;i<(1<<n);++i)cout<<a[i][__builtin_popcount(i)]<<" ";cout<<endl;
}
```

### 改进算法：位置对齐

如果初始输入直接放入 $x^{\operatorname{popcount}(i)}$ 的系数，“FMT”中的 `memmove` 就可以省去。更改部分的代码：

```cpp
void _FMT(unsigned a[][21])
{
	for(int i=0;i<n;++i)
		for(int j=0;j<(1<<n);++j)if(!(j>>i&1))
		{
			unsigned *A=a[j|(1<<i)],*B=a[j]; 
			for(int i=0;i<=n;++i)ADD(A[i],B[i]);
		}
}
//do other thing

int main()
{
	cin.tie(0)->sync_with_stdio(0);
	cin>>n;
	for(int i=0;i<(1<<n);++i)cin>>a[i][__builtin_popcount(i)];
	for(int i=0;i<(1<<n);++i)cin>>b[i][__builtin_popcount(i)];
//do other thing
}
```

### 进一步：线性空间

如果我们强制线性空间，那么多项式 $f(x)$ 是无法存储的。

但是我们可以存储 $f(B)$，其中 $B$ 是一个初始固定的值。接下来可以尝试使用拉格朗日插值求系数。

但是不需要求系数这么麻烦。我们知道对于 $S$，记 $c=\operatorname{popcount}(S)$，则 $f_S(x)=ans_Sx^c+\sum_{j>c}z_{S,j}x^j$。

我们可以对 $g_S(x)=\frac{f_S(x)}{x^c}$ 求 $g_S(0)$，即使 $\frac{f_S(0)}{0^c}$ 看起来似乎有问题，但如果中间看成多项式操作就完全能够解释。（这里是因为足够好的连续函数除法会导致一些点上的间断，但是结果仍然可以通过极限弥补成“连续”的，即 $g_S(0)=\lim_{B\to 0}g_S(B)$）

于是我们可以直接预处理拉格朗日插值的系数 $c_j$，然后对于所有 $S$ 有 $g_S(0)=\sum_j c_jg_S(j)$，选取 $j\ge O(\log n)$，这样 $j$ 超过了多项式最大度数（似乎是 $\log n+O(1)$？），最后枚举 $1\le B\le j$，对于所有 $S$ 求 $g_S(B)$ 并做出对应贡献。

时间复杂度不变，空间从 $O(2^nn)$ 转到 $O(2^n)$。

```cpp
void _FMT(unsigned long long a[])
{
	for(int i=0;i<n;++i)
		for(int j=0;j<(1<<n);++j)if(!(j>>i&1))
			ADD(a[j|(1<<i)],a[j]);
}
void _IFMT(unsigned long long a[])
{
	for(int i=0;i<n;++i)
		for(int j=0;j<(1<<n);++j)if(!(j>>i&1))
			ADD(a[j|(1<<i)],P-a[j]);
}
const int M=50;
long long K[M+3];
long long pw[M+3],ipw[M+3];
long long inv[M+3];
int main()
{
	cin.tie(0)->sync_with_stdio(0);
	inv[1]=1;
	for(int i=2;i<=M;++i)inv[i]=(P-1ll*P/i)*inv[P%i]%P;
	cin>>n;
	for(int i=0;i<(1<<n);++i)cin>>a[i];
	for(int i=0;i<(1<<n);++i)cin>>b[i]; 
	for(int i=1;i<=M;++i)
	{
		long long A=1,B=1;
		for(int j=1;j<=M;++j)if(i!=j)
			A=A*(P-j)%P;
		for(int j=1;j<=M;++j)if(i!=j)
			if(i<j) B=B*(P-inv[j-i])%P;
			else B=B*(inv[i-j])%P;
		K[i]=A*B%P;
	}
	for(int _=1;_<=M;++_)
	{
		pw[0]=ipw[0]=1;
		for(int j=1;j<=M;++j)pw[j]=pw[j-1]*_%P,ipw[j]=ipw[j-1]*inv[_]%P;
		for(int i=0;i<(1<<n);++i)
			A[i]=a[i]*pw[__builtin_popcount(i)]%P,
			B[i]=b[i]*pw[__builtin_popcount(i)]%P;
		_FMT(A),_FMT(B);
		for(int i=0;i<(1<<n);++i)A[i]=1ll*A[i]*B[i]%P;
		_IFMT(A);
		for(int i=0;i<(1<<n);++i)(ans[i]+=K[_]*(A[i]*ipw[__builtin_popcount(i)]%P))%=P;
	}
	for(int i=0;i<(1<<n);++i)cout<<ans[i]<<" ";cout<<endl;
}
```

---

## 作者：EnofTaiPeople (赞：5)

规定（都是正常的规定，可以跳过）：

用二进制数 $k$ 来表示一个集合，某一位为一表示有，零表示没有，$|k|$ 表示集合 $k$ 的大小，即二进制表示下 $1$ 的个数，$x|y$ 表示集合 $x$ 和 $y$ 的并集，即按位或，$x\&y$ 表示集合 $x$ 和 $y$ 的交集，即按位与，$x\otimes y$ 为集合 $x$ 和 $y$ 的对称差，即按位异或。

子集卷积是一个小清新的科技，可以解决一类状态压缩动态规划的问题，可以抽象成 $h_k=\sum\limits_{i\&k=k}f_kg_{i\otimes k}$。

容易发现暴力计算时间复杂度为 $O(3^n)$，可以通过 $n\le18$ 的数据，本题恰好不能通过，所以需要进行优化。

考虑将子集大小相同的放在一起，于是有 $h_k=\sum\limits_{|i|+|j|=|k|,i|j=k}f_ig_j$。

只需要将 $f$ 和 $g$ 按照 集合大小划分为 $n$ 个数组，或运算卷积套上暴力加法卷积即可，或运算卷积需要使用快速沃尔什变换优化，时间复杂度 $O(n^22^n)$，空间复杂度 $O(n2^n)$，注意**不开** `long long`，在运算时强转来优化空间常数。

实际上不开 O2 最慢点也只有 1.82s，一点也不卡常：
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int N=(1<<20)+20,M=1e9+9;
inline void File(){
#ifndef ONLINE_JUDGE
	freopen("a.in","r",stdin);
	freopen("a.out","w",stdout);
#endif
}
namespace fast_rd{
	const int R=1e5+5;
	char buf[R+5],c;
	int it,ed,f;
#define gc (it==ed&&(ed=(it=0)+fread(buf,1,R,stdin),it==ed)?EOF:buf[it++])
	template<typename _Tp>
	inline void read(_Tp &x){
		for(f=0,c=gc;c<48;c=gc)if(c=='-')f=!f;
		for(x=0;c>47;x=x*10+(48^c),c=gc);if(f)x=-x;
	}
	template<typename _Tp,typename..._tps>
	inline void read(_Tp &x,_tps&...y){
		read(x),read(y...);
	}
};
using fast_rd::read;
inline ll qp(ll a,ll x=M-2){
	ll res=1;for(;x;x>>=1,a=a*a%M)
		if(x&1)res=res*a%M;return res;
}
int k,n,f[22][N],g[22][N],pct[N],h[22][N];
signed main(){
	File();
	read(k),n=1<<k;int i,j,ln,md,r,p;
	for(i=1;i<n;++i)pct[i]=pct[i>>1]+(i&1);
	for(i=0;i<n;++i)read(f[pct[i]][i]);
	for(i=0;i<n;++i)read(g[pct[i]][i]);
	for(md=1,r=2;md<n;md<<=1,r<<=1)
		for(ln=0;ln<n;ln+=r)
			for(i=0;i<md;++i)
				for(p=0;p<=k;++p){
					if((f[p][ln|md|i]+=f[p][ln|i])>=M)f[p][ln|md|i]-=M;
					if((g[p][ln|md|i]+=g[p][ln|i])>=M)g[p][ln|md|i]-=M;
				}
	for(i=0;i<=k;++i)
		for(j=k-i;~j;--j)
			for(p=0;p<n;++p)
				h[i+j][p]=(ll(f[i][p])*g[j][p]+h[i+j][p])%M;
	for(md=1,r=2;md<n;md<<=1,r<<=1)
		for(ln=0;ln<n;ln+=r)
			for(i=0;i<md;++i)
				for(p=0;p<=k;++p)
					if((h[p][ln|md|i]-=h[p][ln|i])<0)h[p][ln|md|i]+=M;
	for(i=0;i<n;++i)
		printf("%d ",h[pct[i]][i]);
	return 0;
}
```

---

## 作者：baiABC (赞：3)

前置知识：FMTor 和 IFMTor。
令：
$$A(i,S)=[|S|=i]a_S$$
$$B(i,S)=[|S|=i]b_S$$
$$C(i,S)=\sum_{L\cup R=S}[|L|+|R|=i]a_Lb_R$$

有：
$$A(|S|,S)=a_S$$
$$B(|S|,S)=b_S$$
$$C(|S|,S)=\sum_{L\cup R=S}[|L|+|R|=|S|]a_Lb_R=c_S$$

令：
$$A'(i,S)=\sum_{I\subset S}A(i,S)$$
$$B'(i,S)=\sum_{I\subset S}B(i,S)$$
$$C'(i,S)=\sum_{I\subset S}C(i,S)$$
求 $A'$，$B'$ 可以直接 FMT，然后我们只要求出 $C'$，再做 IFMT 就可以得到 $C$，然后得到答案，FMT 和 IFMT 做 $n+1$ 次都是 $O(n^22^n)$ 的。

事实上有：
$$\begin{aligned}C'(i,S) & = \sum_{I\subset S}\sum_{L\cup R=I}[|L|+|R|=i]a_Lb_R \\ & = \sum_{|L|+|R|=i}[L\subset S][R\subset S]a_Lb_R \\ & = \sum_{k=0}^{i}\left(\sum_{L\subset S}[|L|=k]a_L\right)\left(\sum_{R\subset S}[|R|=i-k]b_R\right)\\ & = \sum_{k=0}^{i}A'(k,S)B'(i-k,S)\end{aligned}$$
这部分也可以 $O(n^22^n)$ 求。

于是我们就解决了这道题。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 1000000009;
int n, A[21][1<<20], B[21][1<<20], C[21][1<<20];
void FMT(int a[])
{
   for(int i = 0; i < n; ++i)
      for(int j = 0; j < (1<<n); ++j)
         if((j>>i)&1)
            a[j] = (a[j]+a[j^(1<<i)])%mod;
}
void IFMT(int a[])
{
   for(int i = 0; i < n; ++i)
      for(int j = 0; j < (1<<n); ++j)
         if((j>>i)&1)
            a[j] = (a[j]-a[j^(1<<i)])%mod;
}
int main()
{
   ios::sync_with_stdio(0);
   cin >> n;
   for(int i = 0; i < (1<<n); ++i)
      cin >> A[__builtin_popcount(i)][i];
   for(int i = 0; i < (1<<n); ++i)
      cin >> B[__builtin_popcount(i)][i];
   for(int i = 0; i <= n; ++i)
   {
      FMT(A[i]); FMT(B[i]);
   }
   for(int i = 0; i <= n; ++i)
      for(int k = 0; k <= i; ++k)
         for(int S = 0; S < (1<<n); ++S)
            C[i][S] = (C[i][S]+1ll*A[k][S]*B[i-k][S]%mod)%mod;
   for(int i = 0; i <= n; ++i)
      IFMT(C[i]);
   for(int i = 0; i < (1<<n); ++i)
      cout << (C[__builtin_popcount(i)][i]+mod)%mod << ' ';
   cout << '\n';
   return 0;
}
```

---

## 作者：Durancer (赞：3)

### 前置知识

- FWT/FMT

- 位运算

### 思路

题目中所求的是：

$$C_{i}=\sum_{j\&k=0\land j\mid k=i}a_jb_k$$

首先看第一个条件：

$$j|k=i$$

很显然的可以用 $\text{FMT}$ 求解出来，也就是:

$$C_i=\sum_{j|k=i}a_jb_k$$

当然这是一个大的范围，我们接下来要满足第二个条件：

$$j\&k=0$$

可以把条件转换一下：

$$|j|+|k|=|j\mid k|$$

我们可以考虑再开一位数组，来储存每一个数的 $1$ 的数量：

$$f_{i,j}=\begin{cases} a_j \ \ (i=|j|)\\  \\ 0\end{cases}$$

然后 $\text{FWT}$ 一遍初始的 $a_{i,j},b_{i,j}$ 数组，用下列形式卷起来，就是答案

$$C_{i,k}=\sum_{i=0}^{len}\sum_{j=0}^i\ a_{j,k}b_{i-j,k}$$

最后的 $C_{|i|,i}$ 即为第 $i$ 位的答案。

### 代码实现（大常数）：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<stack>
#include<algorithm>
using namespace std;
const int N=1<<21|1;
const int mod=1e9+9;
int a[22][N],b[22][N];
int n;
int c[22][N];
int read()
{
	int f=1,x=0;
	char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=(x<<1)+(x<<3)+(s^'0');s=getchar();}
	return f*x;
} 
int lowbit(int x)
{
	return x&(-x);
}
int get(int x)
{
	int cnt=0;
	while(x)
	{
		x-=lowbit(x);
		cnt++;
	}
	return cnt;
}
void FWT(int *f,int term,int x)
{
	for(int mid=1;(mid<<1)<=term;mid<<=1)
	{
		int R=mid<<1;
		for(int j=0;j<term;j+=R)
			for(int k=0;k<mid;k++)
				f[j+k+mid]=(f[j+k+mid]+1ll*f[j+k]*x%mod+mod)%mod;
	}
}
int len;
void Juan()
{
	for(int i=0;i<=len;i++)
		for(int j=0;j<=i;j++)
			for(int k=0;k<n;k++)
				c[i][k]=1ll*(1ll*c[i][k]+1ll*a[j][k]*b[i-j][k]%mod)%mod; 
}
int main()
{
	n=read();
	len=n;
	n=1ll<<n;
	for(int i=0;i<n;i++)
		a[get(i)][i]=read();
	for(int i=0;i<n;i++)
		b[get(i)][i]=read();
	for(int i=0;i<=len;i++)
	{
		FWT(a[i],n,1);
		FWT(b[i],n,1);
	}
	Juan();
	for(int i=0;i<=len;i++)
		FWT(c[i],n,-1); 
	for(int i=0;i<n;i++)
		printf("%d ",c[get(i)][i]);
	return 0;
}
```






---

## 作者：WeLikeStudying (赞：2)

- [前置知识](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/gao-wei-qian-zhui-hu)。
- [还是前置知识](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/mei-hao-di-xi-ri)。

**题意**
- [题目链接](https://www.luogu.com.cn/problem/P6097)。
- 定义差集：
$$P-Q=\{a|a\in P,a\notin Q\}$$
- 有两个集合 $U$ 的子集到实数的单射 $a,b$，定义单射 $c$ 为：
$$c(S)=\sum_{P\subseteq S}a(P)b(S-P)$$
- 求单射 $c$。
- 暴力的实现仍然是 $O(3^{|U|})$ 的。
- ~~我将带头煞笔，尔等紧随其后~~作者下面将给出一个错误的示范：
- [链接](https://www.luogu.com.cn/paste/klxpy16k)，不作正文内容防止误导他人，但希望大家知道为什么需要正解这样的转换。
- 不过还好咱们可以把交集运算给去掉，根据容斥原理，如果两个集合 $P,Q$ 满足 $P\cup Q=S$ 且 $|P|+|Q|=|S|$ 那么就可以断定两个集合没有交。
- 定义 $h(S,k)$：
$$c'(S)=\sum_{P\subseteq S,|P|=k}a(P)b(S-P)$$
- 容易得到：
$$c(S)=\sum_{i=0}^{|S|}h(S,i)$$
- 继续推导：
$$c'(S,k)=\sum_{P,Q}[|P|=k][|Q|=|S|-k]\sum_{R\subseteq S}(-1)^{|S|-|R|}[P\subseteq R]a(P)b(Q)$$
$$c'(S,k)=\sum_{R\subseteq S}(-1)^{|S|-|R|}\sum_{P\subseteq R}[|P|=k]a(P)\sum_{Q\subseteq R}[|Q|=|S|-k]b(Q)$$
- 那么我们只需要定义：
$$a'(S,k)=\sum_{P\subseteq S}[|P|=k]a(P)$$
$$b'(S,k)=\sum_{P\subseteq S}[|P|=k]b(P)$$
- 就可以完成全部的计算了。
- 利用高维前缀和的实现复杂度是 $O(|U|^22^{|U|})$ 的。
- [代码实现](https://www.luogu.com.cn/paste/fy3d2e8v)。
- 实现地很顺利，似乎并不卡常。

---

## 作者：xujindong_ (赞：1)

子集卷积可以做到线性空间。

子集卷积中间有一步对于占位多项式的每个 $S$，对 $F_S,G_S$ 的元 $y$ 做加法卷积。我们把这一步改为 DFT，点乘后 IDFT。因为每列的 FFT 相同，所以可以先 DFT 再 FMT，同理先 FMI 再 IDFT。此时我们可以逐行 FMT，因为 DFT 和 IDFT 的系数是可以直接算出的。

FFT 还要用到单位根，实际上因为这里 FFT 不需要很快速，直接选 $1\sim 2n$ 处的点值即可。系数可以拉插算。

虽然没什么用，但是很炫酷。

```cpp
int t1[n],t2[n],c1[d+5][2*d+5],c2[2*d+5][d+5],vac[2*d+5];
void FMTor(int n,int f[],int c){
  for(int k=1;k<n;k<<=1)for(int i=0;i<n;i+=k<<1)for(int j=0;j<k;j++)f[i|j|k]=(f[i|j|k]+1ll*c*f[i|j])%mod;
}
void subset_conv(int n,int f[],int g[],int h[]){
  int d=__lg(n);
  vac[0]=vac[1]=1;
  for(int i=2;i<=2*d;i++)vac[i]=1ll*vac[mod%i]*(mod-mod/i)%mod;
  for(int i=1;i<=2*d;i++)vac[i]=1ll*vac[i]*vac[i-1]%mod;
  for(int j=0;j<=2*d;j++)for(int i=0,now=1;i<=d;i++,now=1ll*now*j%mod)c1[i][j]=now;
  for(int i=0;i<=2*d;i++){
    c2[i][0]=1;
    for(int j=0;j<=2*d;j++)if(j!=i)for(int k=min(j+(j<i),d);k>=0;k--)c2[i][k]=(1ll*c2[i][k]*(mod-j)+(k?c2[i][k-1]:0))%mod;
    for(int j=0;j<=d;j++)c2[i][j]=1ll*c2[i][j]*vac[i]%mod*vac[2*d-i]%mod*(i&1?mod-1:1)%mod;
  }
  for(int i=0;i<=2*d;i++){
    for(int j=0;j<n;j++)t1[j]=1ll*f[j]*c1[__builtin_popcount(j)][i]%mod,t2[j]=1ll*g[j]*c1[__builtin_popcount(j)][i]%mod;
    FMTor(n,t1,1),FMTor(n,t2,1);
    for(int j=0;j<n;j++)t1[j]=1ll*t1[j]*t2[j]%mod;
    FMTor(n,t1,mod-1);
    for(int j=0;j<n;j++)h[j]=(h[j]+1ll*t1[j]*c2[i][__builtin_popcount(j)])%mod;
  }
}
```

---

## 作者：Arghariza (赞：0)

upd 2023/3/16：更改了时间复杂度的错误。

---

~~其实是暴力。~~

因为这是模板题，所以模板的前置知识也要讲。

- 前置知识：FWT 计算或卷积。

这里只需要掌握快速计算或卷积的方法，所以内容较少。如果向了解更多（比如异或卷积）的话可以去 [P4717](https://www.luogu.com.cn/problem/P4717) 看看。

> 例题：给定长度为 $2^n$ 的序列 $a,b$，求 $c_k=\sum\limits_{i|j=k}a_ib_j$ 序列中每一项的值。我们需要一个 $O(n2^n)$ 的解法。

考虑根据 $a,b$ 构造两个序列 $A,B$，若 $a\to A,b\to B$ 均为 $O(n2^n)$ 并且这个过程可逆，令 $C_i=A_i\times B_i$，若 $C$ 能还原回 $c$，那么我们就可以 $O(n2^n)$ 计算 $c$。

在这里，我们令 $A_i=\sum\limits_{j|i=i}a_j$（也就是 $j$ 为 $i$ 的子集）。那么有 $C_i=\sum\limits_{(j|k)|i=i}a_jb_k$。

那么有：

$$\begin{aligned}A_i\times B_i&=\left(\sum\limits_{j|i=i}a_j\right)\left(\sum\limits_{j|i=i}b_j\right)\\&=\sum\limits_{j|i=i,k|i=i}a_jb_k\\&=\sum\limits_{(j|k)|i=i}a_jb_k\\&=C_i\end{aligned}$$

也就是说我们证明了这个 $A,B$ 是的确能映射到一个正确的 $C$ 的。现在考虑如何快速求 $A_i=\sum\limits_{j|i}a_j$。

显然可以从低到高枚举每个二进制位，然后当前位为 $0$ 的是右边对应位置为 $1$ 的子集，从左依次贡献到右即可。

$C\to c$ 相当于求一个逆过程，右边依次减去左边的贡献即可。

参考了[这里](https://www.luogu.com.cn/blog/xht37/solution-p4717)的代码。

```cpp
void fwt(int *s, int op) {
	op = (op + mod) % mod;
	for (int o = 2, k = 1; o <= S + 1; o <<= 1, k <<= 1) 
		for (int i = 0; i <= S; i += o)
			for (int j = 0; j < k; j++)
				(s[i + j + k] += 1ll * s[i + j] * op % mod) %= mod;
}
```

- 回到原题

你发现这东西就多加了一个限制 $i\&j=0$，也就是说 $i,j$ 无交。

考虑一个充要条件，$i\&j=0$ 并且 $i|j=k$ 其实就相当于 $|i|+|j|=|k|$ 并且 $i|j=k$，$|i|$ 表示 $i$ 集合的大小，即 $i$ 中 $1$ 的个数。

所以可以预处理 $f_{i,j}$ 表示满足 $|j|=i$ 的 $a_j$ 的值，$g_{i,j}$ 对 $b$ 同理。

那么 $c_{k}=\sum\limits_{i=0}^n\sum\limits_{j=0}^{2^n-1}\sum\limits_{j|l=k}f_{i,j}g_{k-i,l}$。

令 $h_{i}=\sum\limits_{k=0}^nf_{k}*g_{i-k}$，$*$ 表示进行或卷积，那么 $c_i=h_{|i|,i}$。

FWT 预处理每个 $f_k$ 和 $g_k$ 的子集和，枚举这个 $i,k$ 求出 $h$ 的子集和，然后做逆的 FWT 就做完了。复杂度 $O(n^22^n)$。

```cpp
const int maxs = (1 << 20) + 100;
const int mod = 1e9 + 9;
int n, S, a[maxs], b[maxs], c[21][maxs], f[21][maxs], g[21][maxs];
int p[maxs];

void fwt(int *s, int op) {
	op = (op + mod) % mod;
	for (int o = 2, k = 1; o <= S + 1; o <<= 1, k <<= 1) 
		for (int i = 0; i <= S; i += o)
			for (int j = 0; j < k; j++)
				(s[i + j + k] += 1ll * s[i + j] * op % mod) %= mod;
}

int main() {
	n = read(), S = (1 << n) - 1;
	for (int i = 1; i <= S; i++) p[i] = p[i >> 1] + (i & 1);
    for (int i = 0; i <= S; i++) f[p[i]][i] = read();
    for (int i = 0; i <= S; i++) g[p[i]][i] = read();
	for (int i = 0; i <= n; i++) fwt(f[i], 1), fwt(g[i], 1);
	for (int i = 0; i <= n; i++)
		for (int j = 0; j <= i; j++)
			for (int k = 0; k <= S; k++)
				(c[i][k] += 1ll * f[j][k] * g[i - j][k] % mod) %= mod;
	for (int i = 0; i <= n; i++) fwt(c[i], -1);
	for (int i = 0; i <= S; i++) write(c[p[i]][i]), pc(' ');
	return 0;
}
```

---


# BZOJ2759 一个动态树好题

## 题目描述

有 $n$ 个未知数 $x_1,x_2,\dots,x_n$ 和 $n$ 个等式组成的同余方程组：$x_i\equiv k_i\times x_{p_i} + b_i \pmod {10007}$。

你需要进行 $q$ 次操作，每次操作为下列两种情况之一：
- `A a`，询问当前 $x_a$ 的解，无解输出 `-1`，多解输出 `-2` 否则输出 $x_a$。
- `C a x y z`，修改一个等式 $k_a \gets x,p_a \gets y,b_a \gets z$。

## 说明/提示

对于所有数据，$k_i,b_i,x_i \in [0,10007) \cap \Z$。$1\leq n\leq 3\times 10^4$，$0\leq q\leq 10^5$，其中询问操作占总操作数的约 $80\%$。

## 样例 #1

### 输入

```
5
2 2 1
2 3 2
2 4 3
2 5 4
2 3 5
5
A 1
A 2
C 5 3 1 1
A 4
A 5```

### 输出

```
4276
7141
4256
2126```

# 题解

## 作者：luanyanjia (赞：7)

~~从题目名字看出此题需要用动态树解决。~~

对于任意 $i$，都有唯一的 $p_i$ 与之对应，由 $p_i$ 向 $i$ 连边，$n$ 种关系显然构成一基环树森林。对于环上的节点，一个点可以自己表示自己，所以可以直接解出该点的权值，其他点从环上的点直接推出即可。

考虑如何动态维护这个过程，一个点上对应的线性变换显然可以用矩阵刻画（其实只是不想动脑子），对于一棵基环树，我们把它多出来那一条边，和根节点的答案都存在根节点上（这样的话换根就要慎重一些了），询问时直接链乘积求出系数即可。

对于任意 $\text{Link}(x,y)$ 操作，若 $x,y$ 不连通则直接连边（注意此处 $\text{MakeRoot}(x)$ 也没有影响，因为能连出边的点一定不属于一棵基环树）。否则算出 $x$ 的答案，并把答案和这条边存在 $x$ 上。

修改的时候，设此处原来的边为 $(y,x)$，现换为 $(z,x)$。那么我们先 $\text{Cut}(x,y)$（此处根节点需要特判，因为它连向父亲的边没有真实连上），然后 $\text{Link}(x,z)$，最后如果 $x$ 不是根节点的话，要把 $x$ 所属的基环树的那条虚边再 $\text{Link}$ 一遍（因为修改后环可能被拆了，此时应该将它真实连上以保证正确性）。

最后关于无解和多解。可以证明，如果根无解，那么整棵树所有节点都无解，多解也有一样的性质。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline void rd(){}
template<typename T,typename ...U>
inline void rd(T &x,U &...args){
	char ch=getchar();
	T f=1;x=0;
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	x*=f;rd(args...);
}
const int N=3e4+5,mod=10007;
struct Matrix{
	int m[2][2];
	Matrix(){memset(m,0,sizeof m);}
	Matrix(int _x){memset(m,0,sizeof m);m[0][0]=m[1][1]=_x;}
	Matrix friend operator+(Matrix a,Matrix b){
		Matrix c;
		for(int i=0;i<=1;i++)
			for(int j=0;j<=1;j++)c.m[i][j]=(a.m[i][j]+b.m[i][j])%mod;
		return c;
	}
	Matrix friend operator*(Matrix a,Matrix b){
		Matrix c;
		for(int i=0;i<=1;i++)
			for(int j=0;j<=1;j++)
				for(int k=0;k<=1;k++)(c.m[i][j]+=a.m[i][k]*b.m[k][j])%=mod;
		return c;
	}
};
inline int KSM(int x,int n){
	int ans=1;
	while(n){
		if(n&1)ans=ans*x%mod;
		x=x*x%mod;
		n>>=1;
	}
	return ans;
}
int n,q;
namespace LCT{
	int f[N],ch[N][2],tag[N];
	Matrix m[N],prd[N];
	struct{int x,y,ans;}nd[N];
	#define ls ch[p][0]
	#define rs ch[p][1]
	inline void PushUp(int p){prd[p]=prd[ls]*m[p]*prd[rs];}
	inline void Rev(int p){
		tag[p]^=1;swap(ls,rs);
		PushUp(p);
	}
	inline void PushDown(int p){
		if(!tag[p])return ;
		Rev(ls),Rev(rs);tag[p]=0;
	}
	inline int Get(int p){return ch[f[p]][1]==p;}
	inline int IsRoot(int p){return ch[f[p]][1]!=p&&ch[f[p]][0]!=p;}
	void Update(int p){
		if(!IsRoot(p))Update(f[p]);
		PushDown(p);
	}
	inline void Rotate(int x){
		int y=f[x],z=f[y],k=Get(x);
		if(!IsRoot(y))ch[z][Get(y)]=x;
		ch[y][k]=ch[x][!k],ch[x][!k]=y;
		f[y]=x,f[x]=z,f[ch[y][k]]=y;
		PushUp(y),PushUp(x);
	}
	inline void Splay(int x){
		Update(x);
		for(int fa=f[x];!IsRoot(x);Rotate(x),fa=f[x])
			if(!IsRoot(fa))Rotate(Get(fa)==Get(x)?fa:x);
	}
	inline int Access(int x){
		int p;
		for(p=0;x;p=x,x=f[x])
			Splay(x),ch[x][1]=p,PushUp(x);
		return p;
	}
	inline void MakeRoot(int x){
		x=Access(x);Rev(x);
	}
	inline int FindRoot(int p){
		p=Access(p);
		while(ls)p=ls,PushDown(p);
		return Splay(p),p;
	}
	inline void Link(int x,int y){
		if(FindRoot(x)==FindRoot(y)){
			MakeRoot(x);Access(y);
			Splay(x);Matrix mm=prd[ch[x][1]]*m[x];
			nd[x].x=x,nd[x].y=y;
			int k=(mm.m[0][0]+mod-1)%mod,b=mod-mm.m[1][0];
			if(k==0&&b==0)nd[x].ans=-2;
			else if(k==0)nd[x].ans=-1;
			else nd[x].ans=1ll*b*KSM(k,mod-2)%mod;
		}else{
			MakeRoot(x);
			Splay(x);f[x]=y;
		}
	}
	inline void Modify(int x,int k,int y,int b){
		int rt=FindRoot(x);
		Splay(x);
		m[x].m[0][0]=k,m[x].m[1][0]=b;
		PushUp(x);
		if(rt!=x){
			Access(x);Splay(x);
			f[ch[x][0]]=0,ch[x][0]=0;
			Link(x,y);
			Link(nd[rt].x,nd[rt].y);
		}
		else Link(x,y);
	}
	inline int Query(int p){
		int rt=FindRoot(p);Access(p);
		Splay(rt);
		int k=prd[ch[rt][1]].m[0][0],b=prd[ch[rt][1]].m[1][0];
		if(nd[rt].ans==-1)return -1;
		if(nd[rt].ans==-2)return -2;
		return (1ll*k*nd[rt].ans%mod+b)%mod;
	}
	#undef ls
	#undef rs 
}
int p[N];
using namespace LCT;
signed main(){
	rd(n);
	prd[0]=m[0]=Matrix(1);
	for(int i=1;i<=n;i++){
		int k,b;rd(k,p[i],b);
		m[i].m[0][0]=k;
		m[i].m[1][0]=b;
		m[i].m[1][1]=1;
	}
	for(int i=1;i<=n;i++)Link(i,p[i]);
	rd(q);
	while(q--){
		char s[3];int a,x,y,z;
		scanf("%s",s);
		if(s[0]=='A'){
			rd(a);
			printf("%d\n",Query(a));
		}else if(s[0]=='C'){
			rd(a,x,y,z);
			Modify(a,x,y,z);
		}
	}
	return 0;
}
```

---

## 作者：chenwenmo (赞：1)

好题，做完这题对 LCT 的理解又加深了不少。

首先我们考虑建图，连接有向边 $i\to p_i$，由于每个点的的出度为 $1$，那么这个图构成一个内向基环树森林。

### 简单情况

我们从简单的开始考虑，如果只有一次求值操作：

- 对于环上的点，它们都是可以确定出解的（包括无解和多解），

  例如环 $a_1\to a_2\to a_1$，对于第一条边，有 $a_1=k_1a_2+b_1$；对于第二条边，有 $a_2=k_2a_1+b_2$。

  那么合并一下，我们就可以用 $a_1$ 来表示它自己，进而得到 $a_1$ 的解的情况。

- 那么对于基环树的树枝上的点，它们就能由环上已经确定的点来得到解的情况。

那么现在已经可以写出一个 $O(nq)$ 暴力了。

### 代入 LCT

我们考虑怎么动态维护这个东西。

修改操作本质上是单点修改，删边和加边，于是可以想到用 LCT 来维护这一过程。

那我们显然要把求值操作刻画的更好一些，以便 LCT 维护的链上信息能帮助我们求出答案。

我的做法是，每个点 $i$ 维护一个二元组 $(k_i,b_i)$，表示 $x_i=k_ix_{p_i}+b_i$，$p_i$ 是 $i$ 的树上父亲，

```cpp
struct Info {
    int k, b;
    Info operator + (const Info &_) const { return {_.k * k % MOD, (_.k * b + _.b) % MOD}; }
};
```

然后对于 $(k_1,b_1)+(k_2,b_2)$，我们令它等于 $(k_1k_2,k_1b_2+b_1)$，实际意义就是，把 $x_1=k_1x_{p_1}+b_1$ 带入到 $x_2=k_2x_1+b_2$ 中。

那么对于一条链 $a_1\to a_2\to\cdots\to a_n$，设 $(k,b)=(k_{n-1},b_{n-1})+\cdots +(k_2,b_2)+(k_1,b_1)$，其恰好代表 $a_1=ka_n+b$，即用 $a_n$ 表示 $a_1$。

于是我们就可以对 LCT 的每个 Splay，维护这条实链从浅到深的二元组的和：

```cpp
struct Node {
    Info val, sum;
    int son[2], fa;
} t[N];

void push_up(int x) { sum(x) = sum(ls(x)) + val(x) + sum(rs(x)); }
```

### 非树边处理

由于 LCT 维护的是森林，因此我们需要对基环树的环做些处理。

对于基环树的环上，我们随便标记一条边为非树边，举个例子：对于 $a_1\to a_2\to a_3\to a_2$，我们把 $a_3\to a_2$ 标记，我在实现上就是令 $p_{a_3}=-a_2$，然后和虚边用同样的方法维护。

这样不仅方便维护，还能判断这条 $i\to p_i$ 是树边还是环边。

值得注意的是，在一棵辅助树上，只有最顶上的 Splay 的根才有这种边。

接下来是一些具体的代码实现：

```link()``` 的时候，判一下两个点是否已经连通：
```cpp
void link(int x, int y) {
    int fx = find_root(x), fy = find_root(y);
    access(x);
    splay(x);
    fa(x) = (fx == fy ? -y : y);
}
```
```is_root()``` 和 ```access()``` 需要改一下：
```cpp
bool is_root(int x) { return (fa(x) < 0 || (ls(fa(x)) != x && rs(fa(x)) != x)); }

void access(int x) {
    for (int y = 0; /* Notice! */ x > 0; y = x, x = fa(x)) {
        splay(x);
        rs(x) = y;
        push_up(x);
    }
}
```

```cut()``` 的时候也比较容易理解：
```cpp
void cut(int x) {
    access(x);
    splay(x);
    if (!ls(x)) fa(x) = 0;
    else {
        int y = ls(x), z = -fa(x);
        fa(y) = ls(x) = 0;
        link(y, z);
        push_up(x);
    }
}
```

### 求答案

然后我们考虑怎么求答案，先看代码：

```cpp
Info get_sum(int x) {
    access(x);
    splay(x);
    return sum(ls(x)) + val(x);
}

int query(int x) {
    auto [k1, b1] = get_sum(x);
    auto [k2, b2] = get_sum(-fa(x));
    if (k2 == 1) return (-1 - (!b2));
    else {
        int a2 = b2 * fpow((1 - k2 + MOD) % MOD, MOD - 2) % MOD;
        return (a2 * k1 + b1) % MOD;
    }
}
```
```get_sum()``` 作用是求出 $x$ 到原树根的路径从浅到深的二元组和。

根据上面讲到的性质，这里 $k1,b1$ 就表示当前询问的 $x$，用 "基环树上 $x$ 这条链接入到环的点" 表示，

例如，$a_1\to a_2\to a_3\underline{\to} a_2$，最后一条是非树边，那么 $a_1+a_2+a_3$ 就代表 $a_1$ 用 $a_2$ 表示出来。

然后 $k2,b2$ 就代表 $x$ 用 它自己 表示出来，在上面的例子中就是 $a_2$ 自己表示自己。

这里需要注意，由于在第一个 ```get_sum()``` 的时候，$x$ 已经 ```splay()``` 到当前辅助树的根了，那么 $-fa_{x}$ 就是这棵辅助树代表的原树的非树边指向的点。

而环上某个点求出来了，就可以推出 $x$ 的解了。

### 总代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
using UI = unsigned int;
using ULL = unsigned long long;
using DB = double;
using LDB = long double;
using PII = pair<int, int>;
using PLL = pair<LL, LL>;
#define CP(x) complex<x>
#define fst first
#define snd second
#define popcnt(i) __builtin_popcount(i)

const int N = 3e4 + 5, MOD = 10007;

int n, q, k[N], p[N], b[N];

int fpow(int a, int b) {
    int ans = 1;
    for (; b; b >>= 1) {
        if (b & 1) ans = ans * a % MOD;
        a = a * a % MOD;
    }
    return ans;
}

struct LCT {
    #define fa(x) t[x].fa
    #define ls(x) t[x].son[0]
    #define rs(x) t[x].son[1]
    #define son(x, y) t[x].son[y]
    #define val(x) t[x].val
    #define sum(x) t[x].sum

    struct Info {
        int k, b;
        Info operator + (const Info &_) const { return {_.k * k % MOD, (_.k * b + _.b) % MOD}; }
    };

    struct Node {
        Info val, sum;
        int son[2], fa;
    } t[N];

    bool dir(int x) { return (rs(fa(x)) == x); }

    void push_up(int x) { sum(x) = sum(ls(x)) + val(x) + sum(rs(x)); }

    bool is_root(int x) { return (fa(x) < 0 || (ls(fa(x)) != x && rs(fa(x)) != x)); }

    void rotate(int x) {
        int y = fa(x), z = fa(y); bool d = dir(x);
        if ((fa(x) = z) && !is_root(y)) son(z, dir(y)) = x;
        if (son(y, d) = son(x, !d)) fa(son(y, d)) = y;
        if (son(x, !d) = y) fa(y) = x;
        push_up(y);
        push_up(x);
    }

    void splay(int x) {
        for (; !is_root(x); rotate(x)) {
            if (!is_root(fa(x))) rotate(dir(x) == dir(fa(x)) ? fa(x) : x);
        }
    }

    void access(int x) {
        for (int y = 0; /* Notice! */ x > 0; y = x, x = fa(x)) {
            splay(x);
            rs(x) = y;
            push_up(x);
        }
    }

    int find_root(int x) {
        access(x);
        splay(x);
        while (ls(x)) x = ls(x);
        splay(x);
        return x;
    }

    void link(int x, int y) {
        int fx = find_root(x), fy = find_root(y);
        access(x);
        splay(x);
        fa(x) = (fx == fy ? -y : y);
    }

    void cut(int x) {
        access(x);
        splay(x);
        if (!ls(x)) fa(x) = 0;
        else {
            int y = ls(x), z = -fa(x);
            fa(y) = ls(x) = 0;
            link(y, z);
            push_up(x);
        }
    }

    Info get_sum(int x) {
        access(x);
        splay(x);
        return sum(ls(x)) + val(x);
    }

    int query(int x) {
        auto [k1, b1] = get_sum(x);
        auto [k2, b2] = get_sum(-fa(x));
        if (k2 == 1) return (-1 - (!b2));
        else {
            int a2 = b2 * fpow((1 - k2 + MOD) % MOD, MOD - 2) % MOD;
            return (a2 * k1 + b1) % MOD;
        }
    }
} T;

void solve() {
    cin >> n;
    T.val(0) = T.sum(0) = {1, 0}; // 单位元
    for (int i = 1; i <= n; i++) {
        cin >> k[i] >> p[i] >> b[i];
        T.val(i) = {k[i], b[i]};
    }
    for (int i = 1; i <= n; i++) {
        T.link(i, p[i]);
    }
    cin >> q;
    char op; int a, x, y, z;
    while (q--) {
        cin >> op >> a;
        if (op == 'A') {
            cout << T.query(a) << '\n';
        } else {
            cin >> x >> y >> z;
            T.val(a) = {x, z};
            T.cut(a);
            T.link(a, y);
        }
    }
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    solve();
    return 0;
}

// g++ main.cpp -o main -O2 -std=c++14 -Wextra -Wall -Wconversion -Wshadow
```

---


# [FJCPC 2025] 帕累托前沿

## 题目描述

给出 $n$ 个二元组 $(x_i,y_i)$，你需要回答 $q$ 个询问，每个询问给出闭区间 $[l,r]$，请回答满足以下条件的整数 $j$ 数量：

- $l\leq j\leq r$；

- 不存在 $l\leq k\leq r, k\neq j$，使得 $x_k\geq x_j$ 且 $y_k\geq y_j$。

## 说明/提示

对于询问 $1$，满足条件的整数为 $2$。

对于询问 $2$，满足条件的整数为 $4$、$6$。

对于询问 $3$，满足条件的整数为 $2$。

对于询问 $4$，满足条件的整数为 $4$。

对于询问 $5$，满足条件的整数为 $6$。

对于询问 $6$，满足条件的整数为 $4$、$6$。

对于询问 $7$，满足条件的整数为 $6$。

## 样例 #1

### 输入

```
8 7
1 9 7 8 0 7 2 3
19 20 5 6 1 14 9 5
1 8
3 7
2 6
4 4
5 7
3 8
6 7```

### 输出

```
1
2
1
1
1
2
1```

# 题解

## 作者：CQ_Bab (赞：3)

# 前言
没脑子题。
# 思路
首先我们发现如果对于一个区间去求有多少个点不太好求，所以考虑计算每一个点能对那些询问区间产生贡献，我们考虑定义 $l_i,r_i$ 表示 $i$ 左边和右边第一个使得 $x_{l_i}\geq x_i,y_{l_i}\geq y_i$ 的点，那么我们考虑如何求出这个东西，首先我们发现这个式子就是一个三维偏序，即 $i<j,x_i\leq x_j,y_i\leq y_j$ 那么我们只需要跑两遍三维偏序就可以求出 $l_i,r_i$，然后考虑求 $i$ 的贡献我们发现但询问区间满足 $l_i<l\leq i,i\leq r<r_i$ 时 $i$ 对此询问有贡献，所以考虑离线之后转成差分即可。
# 代码
因为是 $O(n{\log^2{n}})$ 的所以略需卡常。
```cpp
#include <bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include <ext/rope>
using namespace __gnu_pbds;
using namespace std;
#define pb push_back
#define rep(i,x,y) for(register int i=x;i<=y;i++)
#define rep1(i,x,y) for(register int i=x;i>=y;--i)
#define fire signed
#define il inline
template<class T> il void print(T x) {
	if(x<0) printf("-"),x=-x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
template<class T> il void in(T &x) {
    x = 0; char ch = getchar();
    while (ch < '0' || ch > '9') {ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar(); }
}
int T=1;
const int N=1e6+10;
struct node{
	int x,y;
	int id;
}s[N];
bool cmp(node a,node b) {
	return a.x>b.x;
}
int tr[N];
int lowbit(int x) {
	return x&-x;
}
void add(int x,int k) {
	x=1000001-x;
	for(;x<=1000001;x+=lowbit(x)) tr[x]=max(tr[x],k);
}
int Ans(int x) {
	x=1000001-x;
	int res=0;
	for(;x;x-=lowbit(x)) res=max(res,tr[x]);
	return res;
}
void clr(int x) {
	x=1000001-x;
	for(;x<=1000001;x+=lowbit(x)) tr[x]=false;
}
void add1(int x,int k) {
	x=1000001-x;
	for(;x<=1000001;x+=lowbit(x)) tr[x]=min(tr[x],k);
}
int Ans1(int x) {
	x=1000001-x;
	int res=1e18;
	for(;x;x-=lowbit(x)) res=min(res,tr[x]);
	return res;
}
void clr1(int x) {
	x=1000001-x;
	for(;x<=1000001;x+=lowbit(x)) tr[x]=1e18;
}
int vl[N],vr[N];
il void cdq(int l,int r) {
	if(l==r) return;
	int mid=l+r>>1;
	cdq(l,mid);
	cdq(mid+1,r);
	stable_sort(s+l,s+mid+1,cmp);
	stable_sort(s+mid+1,s+r+1,cmp);
	int j=l;
	rep(i,mid+1,r) {
		while(s[j].x>=s[i].x&&j<=mid) {
			add(s[j].y,s[j].id);
			j++;
		}
		vl[s[i].id]=max(vl[s[i].id],Ans(s[i].y));
	}
	rep(x,l,j-1) clr(s[x].y);
}
il void cdq1(int l,int r) {
	if(l==r) return;
	int mid=l+r>>1;
	cdq1(l,mid);
	cdq1(mid+1,r);
	stable_sort(s+l,s+mid+1,cmp);
	stable_sort(s+mid+1,s+r+1,cmp);
	int j=l;
	rep(i,mid+1,r) {
		while(s[j].x>=s[i].x&&j<=mid) {
			add1(s[j].y,s[j].id);
			j++;
		}
		vr[s[i].id]=min(vr[s[i].id],Ans1(s[i].y));
	}
	rep(x,l,j-1) clr1(s[x].y);
}
bool cmp1(node a,node b) {
	return a.id>b.id;
}
struct nodes{
	int l,r,r1,v;
	int id;
	friend bool operator<(const nodes&a,const nodes&b) {
		if(a.l!=b.l) return a.l<b.l; 
		return a.id<b.id;
	}
}qr[N*4];
int idx;
int ans[N];
int tt[N],n,q;
void pl(int x,int k) {
	for(;x<=1000001;x+=lowbit(x)) tt[x]+=k;
}
int aa(int x) {
	int res=0;
	for(;x;x-=lowbit(x)) res+=tt[x];
	return res;
}
void solve() {
	in(n),in(q);
	rep(i,1,n) in(s[i].x),s[i].id=i;
	rep(i,1,n) in(s[i].y);
	cdq(1,n);
	memset(tr,0x3f,sizeof tr);
	rep(i,1,n) vr[i]=n+1;
	sort(s+1,s+1+n,cmp1);
	cdq1(1,n);
	rep(i,1,n) vl[i]++,vr[i]--;
	rep(i,1,q) in(qr[i].l),in(qr[i].r),qr[i].id=i;
	idx=q;
	rep(i,1,n) {
		qr[++idx]={vl[i],i,vr[i],1,0};
		qr[++idx]={i+1,i,vr[i],-1,0};
	}
	sort(qr+1,qr+1+idx);
	rep(i,1,idx) {
		if(qr[i].id) {
			ans[qr[i].id]+=aa(qr[i].r); 
		}else {
			pl(qr[i].r,qr[i].v);
			pl(qr[i].r1+1,-qr[i].v);
		}
	}
	rep(i,1,q) printf("%d\n",ans[i]);
}
fire main() {
	while(T--) {
		solve();
	}
	return false;
}
```

---

## 作者：Fzrcy (赞：2)

直接统计 $[l,r]$ 内满足条件的 $j$ 的个数的复杂度爆炸，所以我们需要转换思路，考虑每个元素可以对哪些区间产生贡献。

设 $[L_i,R_i]$ 为 $i$ 可以对其产生贡献的最大区间，即 $i$ 对且仅对所有满足 $l\in[L_i,i],r\in [i,R_i]$ 的区间 $[l,r]$ 有贡献。

由于 $R_i$ 的求法与 $L_i$ 相似，所以我们只需考虑 $L_i$ 如何求。

我们按照 $x_i$ 从大到小的顺序依次考虑每个 $i$，问题变为求在 $i$ 左侧的离 $i$ 最近的 $j$，使得 $y_j\ge y_i$。$L_i$ 即为 $j+1$。二分加线段树的复杂度是单次 $O(\log^2n)$ 的，我们可以直接在线段树上二分，单次复杂度为 $O(\log n)$，

注意：题目没有要求 $x_i$ 两两不同，所以对于所有 $x_i$ 相同的 $i$，我们要放在一起考虑，不能分先后。

求出 $L_i,R_i$ 后将询问离线，直接扫描线即可。

总复杂度为 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+9;
struct node{int x,y,id;}a[N];
int n,q,L[N],R[N];
struct tree{
    int t[N<<2];
    inline void cls(int k=1,int l=1,int r=n){
        t[k]=-1;if(l==r)return;int mid=l+r>>1;
        cls(k<<1,l,mid),cls(k<<1|1,mid+1,r);
    }
    inline void ins(int x,int y,int k=1,int l=1,int r=n){
        if(l==r){t[k]=y;return;}int mid=l+r>>1;
        if(x<=mid)ins(x,y,k<<1,l,mid);
        else ins(x,y,k<<1|1,mid+1,r);
        t[k]=max(t[k<<1],t[k<<1|1]);
    }
    inline int fl(int x,int v,int k=1,int l=1,int r=n){
        if(t[k]<v)return l;
        if(l==r)return (v>t[k]||x==l)?l:l+1; int mid=l+r>>1;
        if(x<=mid)return fl(x,v,k<<1,l,mid);
        int ans=(t[k<<1|1]<v)?(mid+1):fl(x,v,k<<1|1,mid+1,r);
        if(ans>mid+1)return ans;
        if(t[k<<1]<v)return l;
        return fl(x,v,k<<1,l,mid);
    }
    inline int fr(int x,int v,int k=1,int l=1,int r=n){
        if(t[k]<v)return r;
        if(l==r)return (v>t[k]||x==l)?l:l-1; int mid=l+r>>1;
        if(x>mid)return fr(x,v,k<<1|1,mid+1,r);
        int ans=(t[k<<1]<v)?mid:fr(x,v,k<<1,l,mid);
        if(ans<mid)return ans;
        if(t[k<<1|1]<v)return r;
        return fr(x,v,k<<1|1,mid+1,r);
    }
}tr;
struct BIT{
    int c[N];
    inline void ins(int x,int v){
        for(;x<=n;x+=x&-x)c[x]+=v;
    }
    inline int Q(int x){
        int r=0;
        for(;x;x-=x&-x)r+=c[x];
        return r;
    }
}T1,T2;
int Ans[N],ql[N],qr[N];
vector<int>idx[N],Era[N];
int main(){
    cin>>n>>q,tr.cls();
    for(int i=1;i<=n;i++)cin>>a[i].x,a[i].id=i;
    for(int i=1;i<=n;i++)cin>>a[i].y;
    sort(a+1,a+n+1,[=](node x,node y){return x.x>y.x;});
    for(int i=1,j;i<=n;i=j){
        for(j=i;a[j].x==a[i].x&&j<=n;j++)tr.ins(a[j].id,a[j].y);
        for(int k=i;k<j;k++)
            L[a[k].id]=tr.fl(a[k].id,a[k].y),
            R[a[k].id]=tr.fr(a[k].id,a[k].y),
            Era[R[a[k].id]].push_back(a[k].id);
    }
    for(int i=1;i<=q;i++)
        cin>>ql[i]>>qr[i],idx[qr[i]].push_back(i);
    for(int i=1;i<=n;i++){
        T1.ins(L[i],1),T2.ins(i,1);
        for(auto j:idx[i]){
            int l=ql[j],r=qr[j];
            Ans[j]=T1.Q(l)-T2.Q(l-1);
        }
        for(auto j:Era[i])T1.ins(L[j],-1),T2.ins(j,-1);
    }
    for(int i=1;i<=q;i++)cout<<Ans[i]<<endl;
    return 0;
}
```

---

## 作者：postpone (赞：0)

设 $L_i$ 为最大的 $j<i$，使 $x_j>x_i$ 且 $y_j>y_i$；设 $R_i$ 为最小的 $j>i$，使 $x_j>x_i$ 且 $y_j>y_i$。

先假装我们已经得出了所有的 $L_i$ 和 $R_i$。

对于一个询问 $[l, r]$ 和一个 $i$, $i$ 产生贡献仅当 $L_i<l\leq i \leq r < R_i$，也就是 $l\in[L_i + 1, i + 1)$ 且 $r\in[i, R_i)$。这两个要同时满足，该怎么实现呢？

我们再假装把 $l$ 这个维度去掉，只考虑 $r$，也就是说一堆线段 $[i, R_i)$，看 $r$ 这个点被几条线段覆盖。这是一个很简单的差分。

那我们现在想要什么呢？想要覆盖 $r$ 的这些线段，恰好都满足另一维度的条件：$l\in[L_i + 1, i + 1)$。仅需把 $l$ 这个维度当成时间维度就行了，将询问以 $l$ 开桶存储，然后让线段 $i$ 在 $L_i+1$ 出现，在 $i+1$ 消失。此时当我们走到 $l$ 这个时间，出现的所有线段都能满足 $l\in[L_i + 1, i + 1)$，再如上面一维的情况统计 $r$ 即可。

将一个维度变成时间，然后在线维护另一个维度，这也是二维偏序的一个经典统计方法。

最后来看看 $L_i$ 和 $R_i$ 怎么求，这是比较好懂的。以 $L_i$ 为例，先将所有点以 $(x_i, y_i, -i)$ 为关键字**降序**。我们维护一棵线段树，线段树下标为原序列下标，值为区间已插入下标 $y$ 的最大值。对于每个 $i$，由于前面已插入线段树的下标的 $x_j$ 都大于等于自己的 $x_i$，所以仅需要找到左边最大的 $j$，使 $y_j>y_i$。线段树二分即可。

求 $R_i$ 需要以 $(x_i, y_i, i)$ 降序，后面的步骤一模一样，就不再赘述了。

总的复杂度是 $O(n\log n)$。核心代码如下，线段树和树状数组都是哥哥的板子，就省略了，可以在[这个仓库里](https://github.com/hh2048/XCPC/tree/main/03%20-%20jiangly%E6%A8%A1%E6%9D%BF%E6%94%B6%E9%9B%86)看。

```cpp
#include <bits/stdc++.h>
using namespace std;

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned;
using u128 = unsigned __int128;

template <class Info>
struct SegmentTree {
    // ...
};

constexpr int inf = 1e9;

struct Info {
    int max = -inf;
};

Info operator+(const Info &a, const Info &b) {
    return {std::max(a.max, b.max)};
}

template <typename T>
struct Fenwick {
    // ...
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, q;
    cin >> n >> q;
    
    vector<int> x(n), y(n);
    for (int i = 0; i < n; i++) {
        cin >> x[i];
    }
    for (int i = 0; i < n; i++) {
        cin >> y[i];
    }

    vector<int> ord(n);
    iota(ord.begin(), ord.end(), 0);

    vector<int> L(n);
    {
        SegmentTree<Info> seg(n);
        ranges::sort(ord, [&](int i, int j) {
            return make_tuple(x[i], y[i], -i) > make_tuple(x[j], y[j], -j);
        });
        for (auto i : ord) {
            int p = seg.findLast(0, i, [&](auto v) {
                return v.max >= y[i];
            });
            L[i] = p;

            seg.modify(i, {y[i]});   
        }
    }
    vector<int> R(n);
    {
        SegmentTree<Info> seg(n);
        ranges::sort(ord, [&](int i, int j) {
            return make_tuple(x[i], y[i], i) > make_tuple(x[j], y[j], j);
        });
        for (auto i : ord) {
            int q = seg.findFirst(i + 1, n, [&](auto v) {
                return v.max >= y[i];
            });
            R[i] = (q == -1 ? n + 1 : q);
        
            seg.modify(i, {y[i]});   
        }
    }
    // { [i, R[i]), add / del }
    vector<vector<tuple<int, int, int>>> e(n + 1);
    for (int i = 0; i < n; i++) {
        // [L[i] + 1, i)
        e[L[i] + 1].emplace_back(i, R[i], 1);
        e[i + 1].emplace_back(i, R[i], -1);
    }
    // {r, i}
    vector<vector<pair<int, int>>> que(n);
    for (int i = 0; i < q; i++) {
        int l, r;
        cin >> l >> r;
        l--;
        que[l].emplace_back(r, i);
    }
    
    vector<int> ans(q);
    Fenwick<int> fen(n + 2);
    for (int l = 0; l < n; l++) {
        for (auto [x, y, i] : e[l]) {
            fen.add(x, i);
            fen.add(y, -i);
        }
        for (auto [r, i] : que[l]) {
            ans[i] = fen.sum(r);
        }
    }

    for (int i = 0; i < q; i++) {
        cout << ans[i] << "\n";
    }

    return 0;
}
```

---


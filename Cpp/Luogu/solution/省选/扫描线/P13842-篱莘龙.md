# 篱莘龙

## 题目描述

Yuki 家里养着 $n$ 只奶龙，第 $i$ 只奶龙的攻击力为 $a_i$，防御力为 $b_i$。

对于第 $i$ 只奶龙和第 $j$ 只奶龙（$i\ne j$），如果 $a_i>b_j$，则第 $i$ 只奶龙会攻击第 $j$ 只奶龙。

你需要对于每个不大于 $n$ 的正整数 $k$ 求出，在第 $1$ 只奶龙到第 $k$ 只奶龙中，最多可以选择多少只奶龙，使得这些奶龙中不存在某只奶龙会攻击另一只奶龙。

## 说明/提示

### 样例 1 解释

- $k=1$ 时显然只能选择第一只奶龙。
- $k=2$ 时可以选择前两只奶龙。
- $k=3$ 时，如果选择全部奶龙，则第三只奶龙会攻击第二只奶龙。所以答案最多为 $2$。

### 数据范围

对于所有测试数据，保证：

- $1 \le n \le 10^6$；
- $1 \le a_i,b_i \le 2n$，所有 $a_i,b_i$ 互不相同。

| 测试点编号  |     $n\le$     | 特殊性质 |
| :---------: | :------------: | :------: |
|     $1$     |      $20$      |    无    |
|  $2\sim 3$  |     $400$      |    无    |
|     $4$     |     $2000$     |    B     |
|  $5\sim 6$  |     $2000$     |    无    |
|     $7$     |     $10^5$     |    B     |
|     $8$     |     $10^5$     |    C     |
| $9\sim 11$  |     $10^5$     |    无    |
|    $12$     |     $10^6$     |    A     |
|    $13$     |     $10^6$     |    B     |
|    $14$     |     $10^6$     |    C     |
| $15\sim 17$ | $5\times 10^5$ |    无    |
| $18\sim 20$ |     $10^6$     |    无    |

- 特殊性质 A：保证 $a_i> b_i$。
- 特殊性质 B：保证 $a_i< b_i$。
- 特殊性质 C：保证只有不超过 $100$ 只奶龙满足 $a_i>b_i$。

## 样例 #1

### 输入

```
0
3
1 6
3 2
5 4```

### 输出

```
1
2
2```

# 题解

## 作者：Erine (赞：2)

考虑好子集的形态。实际上是选中一个分界点 $t$，将 $a_i\le t\le b_i$ 的点全部选择，再最多选一个点 $p$ 有 $\max a_i<b_p<a_p<\min b_i$ 加入。不考虑加上的这个点 $p$ 可以动态维护每个 $t$ 对应的答案，转化为区间加全局 max。我们称此时答案为初始答案。

我们将 $a_i<b_i$ 的称作一类点，其余称作二类点。一个元素对应的区间是 $[\min(a_i,b_i),\max(a_i,b_i)]$。那么容易发现存在一个 $p$ 能让答案加一的充要条件就是，存在一个二类点对应区间被初始答案个一类点对应区间包含。于是可以做到平方。

考虑动态维护所有二类点对应区间被包含几次。我们要注意到如果两个二类区间存在包含关系，只有小的有用。使用 set 维护。那么这样左端点递增右端点也递增，后面的一类区间对其贡献可以直接线段树维护。前面的需要计算——这等价于动态 2side 数点。很不幸，看起来你需要 2log，而 2log 显然过不去，也获得不了可观的分数，所以你决定摆烂。

事实上，我们仍然需要一个性质：注意到将一类区间一起加入 set 中，不会影响其正确性。证明考虑如果一个二类区间包含了一个一类区间，那么这个二类区间必然不会成为使答案加一的关键区间（若是，则里面的一类区间必然会让答案加一，而这个二类区间就不符合条件）。然后此时的 $l-r$ 二维图就明朗了很多：我们要计算一个点左上角点数，然而右下角是没有点的。这意味着可以把 2-side 转化为两个 1-side。于是可以直接 1log 维护。

---

## 作者：沉石鱼惊旋 (赞：1)

我们称 $[a_i,b_i]$ 是正区间，$[b_i,a_i]$ 是反区间。

如果没有反区间，正区间有交即可。答案就是一个点被覆盖次数的 $\max$。

如果有反区间，手玩发现至多一个，并且要完全被正区间包含。

对于一个反区间，如果他和任何一个正区间有交且不被正区间包含，显然我们把那个交点拿出来，当做被覆盖的那个点的话，答案肯定不劣于保留这个反区间。

因此，只要反区间内存在一个正区间的端点，那么就可以直接扔掉反区间。

对于正区间，我们维护每个位置被覆盖了几次。如果那个位置是一个反区间的话，答案可以额外 $+1$。由于我们已经提前把有交的删了，那么被反区间包含的充要条件就是 $b$ 被包含。可以把反区间看成一个点去做。

维护每个位置是否是反区间以及被覆盖了几次即可。删除反区间需要一个报警器，随便打一下 tag 就行了。

复杂度 $\mathcal O(n\log n)$，这个做法常数有点大，稍微卡卡常，写一个二倍空间线段树就能过。

---


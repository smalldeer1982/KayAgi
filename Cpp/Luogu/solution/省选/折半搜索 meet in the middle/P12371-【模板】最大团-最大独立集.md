# 【模板】最大团/最大独立集

## 题目描述

给定一个无向图 $G$，你需要对其分别求出：

- $G$ 的一组最大团。
- $G$ 的最大团个数。
- $G$ 的一组最大独立集。
- $G$ 的最大独立集个数。

$G$ 的最大团为 $G$ 的最大完全子图，完全图为各点间两两均有连边的图。

$G$ 的最大独立集为 $G$ 的最大零子图，零图为各点间两两均没有边的图。

## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/tjj1sy0t.png)

图 $G$ 的最大团分别为 $\{3,4,5\}$。

图 $G$ 的最大独立集分别为 $\{1,3,6\},\{1,5,6\}$。

### 数据范围

对于全部数据：$1\leq n\leq 50$，$0\leq m\leq 1225$，$1\leq u,v\leq n$。

## 样例 #1

### 输入

```
6 7
1 2
2 3
3 4
4 1
3 5
5 4
2 6```

### 输出

```
3 1
3 4 5
3 2
1 3 6```

# 题解

## 作者：masterhuang (赞：10)

**std** 好菜啊！好菜啊！好菜啊！

本文经过伟大的 EI 的教导。

---

理论上 **std** 应该是这个东西[《浅谈信息学竞赛中的独立集问题》 - 学习笔记
](https://www.cnblogs.com/p-b-p-b/p/14200616.html)。

当然也可以看 [CF1767E 题解](https://www.luogu.com.cn/article/bk7olmxk)。

时空复杂度 $O(2^{n/2})$。

最大独立集个数不超过 $2^{n/2}$，故个数是完全可以用 `int` 存的。

---

最大独立集：常见的求最大独立集的乱搞是尝试删度数最大的点。对于这个题，若 $\deg \le 2$，每个联通块都只是环和链，单独算一下。否则暴力递归，复杂度 $T(n)=T(n-1)+T(n-4)\Rightarrow T(n)\sim 1.3803^n$，吊打 $O(2^{n/2})$ 的 **std**。而且空间也是 $O(n)$ 而非 **std** 的 $O(2^{n/2})$。

虽然复杂度可能要 $\times n$，但是根本跑不满，还可以过程中通过位运算优化只算有效位，跑得飞快。

具体细节详见代码。

```cpp
//洛谷 P12371
//https://www.luogu.com.cn/problem/P12371
#include<bits/stdc++.h>
#define u64 unsigned long long
#define ctz __builtin_ctzll
#define pc __builtin_popcountll
#define P pair<u64,int>
#define fr(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);
using namespace std;
const int N=55;
int n,m,f[N],g[N];u64 U,e[N];
inline void wr(u64 S){for(;S;S&=(S-1)) cout<<ctz(S)+1<<" ";cout<<"\n";}
P dfs(u64 S)
{
	if(!S) return {0,1};int w=0,d=-1;
	for(u64 i=S;i;i&=(i-1))
	{
		int x=ctz(i),t=pc(e[x]&S);
		if(t>d) d=t,w=x;
	}//找度数最大的点
	if(d<=2)
	{
		u64 v=S,x=0,s1,s2;int y=1;bool O;
		auto dfs=[&](auto &&sf,int x,bool o)->void{
			v^=(1ull<<x);(o?s2:s1)|=1ull<<x;O&=(pc(e[x]&S)==2);
			while(v&e[x]) sf(sf,ctz(v&e[x]),o^1);
		};//搜每个联通块的形态以及点数
		while(v)
		{
			s1=s2=0,O=1;dfs(dfs,ctz(v),0);int a=pc(s1),b=pc(s2),num=a+b;
			(O&&(num&1))?x|=(a<b?s1:s2):x|=(a>b?s1:s2);
			y*=(O?g:f)[num];//f 是链的方案数，g 是环的方案数
		}
		return {x,y};
	}//处理环和链
	u64 W=1ull<<w;P nw=dfs(S^W);
	auto [x,y]=dfs(S&(~(e[w]|W)));x|=W;
	if(pc(x)>pc(nw.first)) nw={x,y};
	else if(pc(x)==pc(nw.first)) nw.second+=y;//递归下去
	return nw;
}
inline void sol(){
	auto [S,c]=dfs(U);
	cout<<pc(S)<<" "<<c<<"\n";wr(S);
}
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);cin>>n>>m;U=(1ull<<n)-1;
	for(int i=1;i<=n;i++) f[i]=(i&1?1:i/2+1),g[i]=(i&1?i:2);
	for(int i=1,u,v;i<=m;i++) cin>>u>>v,e[--u]|=1ull<<(--v),e[v]|=1ull<<u;
	for(int i=0;i<n;i++) e[i]=((~e[i])&U)^(1ull<<i);sol();//最大团，转补图求最大独立集
	for(int i=0;i<n;i++) e[i]=((~e[i])&U)^(1ull<<i);sol();//求最大独立集
	return 0;
}
```

---

## 作者：Purslane (赞：4)

# Solution

显然最大独立集可以转为补图的最大团，所以只需要搞定最大团怎么找。

## 复杂度 $O(n 2^{\frac{n}{2}})$ 的最大团算法

考虑枚举团中编号最小的点 $i$，考虑剩下的 $n-i$ 个点。

将其分为两部分 $A$ 和 $B$。在 $A$ 和 $B$ 上分别做 $O(2^{|S|})$ 的指数级算法，得到内部所有可能的团。

$A$ 的一个团 $C_A$ 和 $B$ 的一个团 $C_B$ 能合并，当且仅当他们任意两点都有连边。发现对于 $C_A$ 而言，计算其在 $B$ 中的邻域的交 $S_A$，有 $C_b \subseteq S_A$。

这是一个高维前缀和问题，所以可以做到 $O((n-i) 2^{\frac{n-i}{2}})$。求和后还是 $O(n2^{\frac{n}{2}})$。

## 复杂度 $O(2^{\frac{n}{2}})$ 的最大团算法

其实复杂度瓶颈就在算高维前缀和上。

考虑高维前缀和的具体含义：对于集合 $S$，算出所有包含在 $S$ 中的团的信息，记为 $f_S$。

令 $u$ 为 $S$ 中任何一个元素，$T_u$ 为 $u$ 在 $S$ 中的邻域。

如果 $u$ 不在团中，由 $f_{S / \{u\}}$ 转移；如果 $u$ 在团中，由 $f_{T_u} + 1$ 转移。所以可以做到 $O(2^{\frac{n-i}{2}})$ 单次。求和后为 $O(2^{\frac{n}{2}})$。

## 复杂度 $O(\sqrt m 2^{\frac{\sqrt{2m}}{2}})$ 的最大团算法

其实没啥本质不同。类似三元环计数的手法，将所有点按照度数排序。这样可以控制每个点比他大且有连边的点个数在 $\sqrt {2m}$ 之内。跑和上面一样的方法即可。

根据琴生不等式（其实也不是琴生不等式，就是最基础的凸函数求最值），最大值为 $O(\sqrt m 2^{\frac{\sqrt{2m}}{2}})$。这种方法在稀疏图上非常优秀。

## 最大独立集的一个搜索做法

哎我去年学过这个东西，怎么给忘了呢。

如果所有点的度数都 $\le 2$，那么只有环和链，最大独立集是容易处理的。

考虑枚举度数最大的点是否在独立集里面，如果在就把其邻域内所有点都删掉。因此复杂度满足递推式 $T(n) = T(n-1) + T(n-4)$，得到 [$T(n) = O(1.3803^n)$](https://www.wolframalpha.com/input?i2d=true&i=Power%5Bx%2C4%5D%3DPower%5Bx%2C3%5D%2B1&lang=zh)。

哎我的 $O(2^{\frac{n}{2}})$ 怎么在代码难度和时间复杂度上都被偏序了。难过。

放一个 $O(2^{\frac{n}{2}})$ 的代码，略微卡常：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=50+5;
struct INFO {int mx,cnt;ll ex;}F[(1<<25)+10];
INFO operator +(INFO A,INFO B) {if(A.mx>B.mx) return A;if(B.mx>A.mx) return B;return {A.mx,A.cnt+B.cnt,A.ex};}
INFO operator +(INFO A,ll S) {return A.mx+=__builtin_popcountll(S),A.ex|=S,A;}
int n,m;
ll T[MAXN],FF[MAXN];
int NXT2[MAXN],NXT1[MAXN],n1,n2,f1[(1<<25)+10];
ll idx[(1<<25)+10];
bool ok[(1<<25)+10];
INFO calc(int u) {
	vector<int> nxt;
	ffor(v,u+1,n) if(T[u]&(1ll<<v-1)) nxt.push_back(v);
	n1=n2=0;
	for(auto id:nxt) {
		if(n2<=n1) NXT2[++n2]=id;
		else NXT1[++n1]=id;	
	}
	INFO ans={-1,0,0};
	ffor(i,1,n) {FF[i]=0;ffor(j,1,n1) if(T[i]&(1ll<<NXT1[j]-1)) FF[i]|=(1<<j-1);}
	F[0]={0,1,0};
	ffor(i,1,(1<<n1)-1) {
		int lb=(i&-i),id=NXT1[1+(int)log2(lb)];
		F[i]=F[i-lb]+(F[FF[id]&i]+(1ll<<id-1));
	}
	ok[0]=1,f1[0]=(1<<n1)-1;
	ffor(i,0,(1<<n2)-1) {
		if(i) {
			ok[i]=0;
			int lb=(i&-i),id=NXT2[1+(int)log2(lb)];
			if(ok[i-lb]&&((idx[i-lb])&T[id])==idx[i-lb]) ok[i]=1,f1[i]=f1[i-lb]&FF[id],idx[i]=idx[i-lb]|(1ll<<id-1);
		}
		if(ok[i]) ans=ans+(F[f1[i]]+idx[i]);
	}
	return ans+(1ll<<u-1);
}
INFO solve(void) {
	INFO ans={-1,0,0};
	ffor(i,1,n)  ans=ans+calc(i);
	return ans;	
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	ffor(i,1,m) {
		int u,v;
		cin>>u>>v;
		T[u]|=(1ll<<v-1),T[v]|=(1ll<<u-1);
	}
	auto ans=solve();
	cout<<ans.mx<<' '<<ans.cnt<<'\n';
	ffor(i,1,n) if(ans.ex&(1ll<<i-1)) cout<<i<<' ';
	cout<<'\n';
	ffor(i,1,n) T[i]=(1ll<<n)-1-(1ll<<i-1)-T[i];
	ans=solve();
	cout<<ans.mx<<' '<<ans.cnt<<'\n';
	ffor(i,1,n) if(ans.ex&(1ll<<i-1)) cout<<i<<' ';
	return 0;
}
```

---

## 作者：liangbowen (赞：4)

写了写发现 TLE 了，然后发现自己居然不会 $O(2^{n/2})$ 求团诶。不过其实也没啥特别的地方。

这里就只写最大团了，反正两者本质相同。

首先有一个 $O(n2^{n/2})$ 的算法：类似折半搜索的思路，将总集合分成两半 $\mathbb S,\mathbb T$。对 $\mathbb S,\mathbb T$ 的每个子集分别求出它们是否是团。对 $\mathbb S$ 的子集施高维前缀和求出 $f(S\subseteq\mathbb S)$ 表示集合 $S$ 包含的所有团的信息和（本题中为最大值 + 数量的二元组）。然后枚举 $\mathbb T$ 中的所有团 $T\in\mathbb T$，找出左边能够与 $T$ 拼起来组成团的点集合 $S=\bigcap\limits_{u\in T}E_u$（其中 $E_u$ 为 $u$ 的邻居），将 $f(S)$ 与 $T$ 的信息合并即可。容易发现这样是不重不漏的。

写出代码发现唯一瓶颈是求 $f(S)$ 的部分，如果用高维前缀和的话怎样都是 $O(n2^{n/2})$ 的。尝试直接考虑 $f(S)$ 的定义是集合 $S$ 包含的所有团的信息和，那么取出 $S$ 中的任意一点 $u\in S$，分类 $u$ 是否包含在一个团中，我们有

$$f(S)=f(S-u)+\Big(f\big((S-u)\cap E_u\big)\cup \{u\}\Big)$$

这样直接递推 $f$ 就好啦，其他部分不用变，复杂度 $O(2^{n/2})$。

顺带一提，有一个经典题目 [qoj7514 Clique Challenge](https://qoj.ac/problem/7514)，可以使复杂度与 $m$ 挂钩，这个其他题解有写，我就懒得写做法了。

---

upd：一个可爱的女孩子让我放个代码，那就放吧：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#define mems(x, v) memset(x, v, sizeof x)
#define mcpy(x, y) memcpy(x, y, sizeof x)
using namespace std;
typedef pair <int, int> pii;
typedef long long ll;
typedef unsigned long long ull;
typedef long double wisdom;

int n, m, popc[1 << 25], to[1 << 25], lg[1 << 25]; pair <int, ll> f[1 << 25]; ll E[55]; bool e[55][55], g[1 << 25];
void solve() {
	int mid = n / 2;
	for (int i = 1; i <= n; i++) e[i][i] = true, E[i] = 0;
	for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) if (e[i][j]) E[i] |= (1ll << (j - 1));

	for (int S = 0; S < (1 << mid); S++) f[S] = {0, 0}, g[S] = false;
	f[0] = {0, 1};
	for (int S = 1; S < (1 << mid); S++) {
		pair <int, ll> A = f[S ^ (S & -S)], B = f[(S ^ (S & -S)) & E[lg[S & -S]]];
		B.first |= (S & -S);
		if (popc[B.first] > popc[A.first]) A = B; else if (popc[B.first] == popc[A.first]) A.second += B.second;
		f[S] = A;
	}
	g[0] = true;
	for (int S = 1; S < (1 << (n - mid)); S++) {
		g[S] = g[S ^ (S & -S)] && !(S & ~(E[lg[S & -S] + mid] >> mid));
	}

	ll ans = 0, state = 0, tot = 0;
	for (int T = 0; T < (1 << (n - mid)); T++) if (g[T]) {
		// for (int i = 1; i <= n - mid; i++) if (T >> (i - 1) & 1) S &= E[i + mid];
		int S; to[T] = S = (!T ? (1 << mid) - 1 : to[T ^ (T & -T)] & E[lg[T & -T] + mid]);

		ll pc = popc[f[S].first] + popc[T], me = f[S].first | ((ll)T << mid);
		if (pc > ans) ans = pc, state = me, tot = f[S].second;
		else if (pc == ans) tot += f[S].second;
	}
	cout << ans << ' ' << tot << '\n';
	for (int i = 1; i <= n; i++) if (state >> (i - 1) & 1) cout << i << ' ';
	cout << '\n';
}
int main() {
	cin >> n >> m;
	for (int i = 1; i < (1 << ((n + 1) / 2)); i++) popc[i] = popc[i ^ (i & -i)] + 1;
	for (int i = 0; i < 25; i++) lg[1 << i] = i + 1;

	while (m--) {int u, v; cin >> u >> v; e[u][v] = e[v][u] = true;}
	solve(); for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) e[i][j] ^= 1; solve();
	return 0;
}
```

---

## 作者：hgckythgcfhk (赞：4)

这个题我求助了 deepseek，学到了一种题解区目前没有的做法，而且这个做法的时间复杂度是还可以的。

由于团和独立集只要求个反图重新做一遍就可以了，这里只讨论团，独立集是同理的。

## 定义

**极大团**：可以类比函数的极值，如果一个团不能通过增加一个点来得到一个更大的团，则称这个团为极大团。

可以发现，最大团一定是极大团，而极大团不一定是最大团。

## 由暴力得到的启发

首先，最大团是 NP 问题，同时这题没让取模，根据经验告诉我们最大团的个数很可能是不多的，可以猜测 $O(\text{最大团个数})$ 的时间复杂度是能过的。

感性理解一下，如果两个团的异或的点集是一个团，则这两个团的并也是团，也就是说，所有最大团的异或不能是一个团，这保证了邻接矩阵中的 $1$ 的数量不能太多，而为了尽可能构造比较多的最大团又不能太少，在两个比较矛盾的限制下最大团看起来不会太多。

这个结论先不证，放到后面证，先假设它是对的。

考虑最暴力的暴力，直接枚举二进制硬判，而一般情况下枚举二进制其实是对 dfs 的优化，而这个题枚举二进制实则更容易想到，但不可否认的是这个题可以 dfs。

大体说一下这种对集合 dfs 的一般形式，直接维护一个集合每次加入一个元素，加到不合法为止开始回溯。

这样虽然仍然可以卡到 $O(2^n)$ 但实际上这样少枚举了很多东西，这启发我们这种枚举集合的形式方便减枝。

虽然上面说的这些对于大部分能来看这个题的人拿来说比较简单，但事实上我认为这属于思路的一步，而且 OIwiki 上就是从这个暴力开始讲起的。

## Bron–Kerbosch 算法

为了方便描述，下面简称为 BK 算法，事实上 BK 算法就是对上面的暴力的优化，现在记 $3$ 个集合：

1. $R$（当前团）：已选的点集（保证是团的候选）。

1. $P$（候选点）：可能被加入 $R$ 的点（与 $R$ 中所有点相连）。

1. $X$（已排除的点）：无法扩展 $R$ 的点（已被剪枝的点）。

先说算法流程：

1. 初始化 $R,X$ 为空集，$P$ 为全集，也就是说，一开始团内没有任何东西，且所有点都被候选。
2. 如果 $P$ 和 $X$ 都是空集，则此时 $R$ 是一个极大团。
3. 从 $P$ 中枚举点 $v$，$R$ 加上 $v$，和 $P,X$ 分别与 $v$ 的邻域的交，其中邻域表示与 $v$ 相邻的点组成的点集。
4. 将当前枚举的 $v$ 从 $P$ 移动到 $X$。

对于第三步，具体的，记 $v$ 的邻域为 $V$，第三步相当于从 $(R,P,X)$ 递归到 $(R\cup v,P\cap V,X\cap V)$。

BK 算法快的原因是每一步向某个极大团扩展的过程中，以状态为点以转移为边建图后，图是一棵树。也就是说，BK 算法的时间复杂度是和极大团个数同级的

下面证明这个算法正确性和时间复杂度。

首先我认为正确性和时间复杂度其实可以合并到一起证，具体分为一下两个方面：

1. 完备性，即所有极大团都会被搜到。

我在学习了 deepseek 给出的很多证法没看懂，又在别的很多地方看到“显然”之后，突然想到一个好理解的解释来让这里“显然”，换一种暴力的思路，类似于枚举二进制，直接对每个点选不选进行 dfs，而这个只是相当于换了一个 dfs 的顺序，按在集合 $P$ 中的位置排序，递归下去的那一步相当于选，而回溯后会把 $v$ 移至 $X$，这正好就是不选。

那这优化了什么？在递归的过程中有取交集的一步，这样避免掉了候选一些明显不合法的点（考虑 $P$ 的定义是候选点集），而实际做的其实是换了顺序后最暴力的暴力。

但是还有个不好理解的地方就是 $X$ 的意义，这一点确实很多现成的资料里面有一定的误导性，如果你只需要枚举所有的极大团确实可以不用 $X$，实际上根本用不到这个集合，在 OIwiki 的伪代码中，不判的运行结果是一样的，而判这个地方只是为了要输出所有极大团时防止多输出一些非极大团，对于本题是没有影响的。

2. 唯一性，即每个极大团只会被搜一遍。

这个其实根据上面说的那么多已经比较可以显然了，这其实相当于证状态之间的树形关系，从把 BK 算法理解成换顺序暴力的角度来看就很容易发现这个是对的，同时这保证了时间复杂度是和极大团个数同级，事实上可以构造极大团个数等于最大团个数且时间达到上界，所以之前假设的结论是对的。

然后就是极大团的个数了，根据 Moon-Moser 定理，极大团最多有 $O(3^{\lfloor \frac{n}{3}\rfloor})$ 个，同时这个是可以卡满的。

下面证明 Moon-Moser 定理，首先 $n\le 3$ 的情况显然成立，这个自己构造一下就行，然后假设 $k<n$ 的 $k$ 成立，现在随便找一个邻域并上自己不是所有点的点，即邻域大小小于 $n$ 的点 $v$ 分讨。

1. 包含 $v$ 的极大团必须是 $v$ 的邻域和 $v$ 的并的子集而前面保证了邻域大小小于 $n$，所以这样的极大团最多有 $O(3^{\lfloor \frac{n-1}{3}\rfloor})$ 个。
2. 不包含 $v$ 的极大团只能从剩下的 $n-1$ 个点里面找，这样的极大团最多也是 $O(3^{\lfloor \frac{n-1}{3}\rfloor})$ 个。
3. 找不到这样的 $v$ 时时完全图，极大团只有一个。

对于前两种，注意到下取整，直接加起来只会差 $2$ 倍的常数，这样就归纳地证完了。

这个上界可以在完全三分图上卡满，完全三分图顾名思义就是分成三个集合后每个集合内部没边但每个点和其他两个集合的所有点之间有边。

## 基于 BK 算法的优化

这是根据上面的过程，写出来的程序：
```cpp
unsigned n,m;
struct A{ull a[64],ans,cnt,sta;
	void ins(cit u,cit v){a[u]|=1ll<<v;}
	void chk(cit ll R){cit x=__builtin_popcountll(R);if(x<ans)return;if(x==ans){++cnt;return;}cnt=1,ans=x,sta=R;}
	void dfs(int ll P,int ll R){/*cerr<<bitset<8>(P)<<' '<<bitset<8>(R)<<'\n';*/if(!P)return chk(R);
		for(int ll v=__builtin_ctzll(P);P;P^=1ll<<v,v=__builtin_ctzll(P))dfs(P&a[v],R|1ll<<v);
	}void print(){cout<<ans<<' '<<cnt<<'\n';for(int i=1;i<=n;++i)if(sta&(1ll<<i))cout<<i<<' ';cout<<'\n';}
}G1,G2;Bool(a[64],64);ull all=0;
void init(){rd(n),rd(m);
	for(int u,v;m--;a[u][v]=a[v][u]=1)rd(u),rd(v);
	for(int i=1;i<=n;++i)for(int j=1;j<=n;++j)if((i^j)&& a[i][j])G1.ins(i,j);
	for(int i=1;i<=n;++i)for(int j=1;j<=n;++j)if((i^j)&&!a[i][j])G2.ins(i,j);
	for(int i=1;i<=n;++i)/*G1.ins(i,i),G2.ins(i,i),*/all|=1ll<<i;
}void solve(){init();
	G1.dfs(all,0);G1.print(),G2.dfs(all,0),G2.print();
}signed main(){open;int t=1;//cin>>t;
	while(t--)solve();}
```

我认为我说的足够详细到能直接把程序写出来了，所以为了减少不必要的篇幅和过审，这里省略了缺省源。

这样是过不了的，能拿 $42$ 分。

首先，先给出几个优化。

1. 考虑到对于一组当前的 $R$ 和 $P$，最优情况下也只能 $P$ 全都加进 $R$ 里，而我们要找的只是最大而不是所有极大团，所以这里可以根据当前答案减枝，只需要在判断 $P$ 空后面加一行：
```cpp
if(__builtin_popcountll(R|P)<ans)return;
```
就好了。这个减枝可以优化到 $76$ 分。

2. 递归时按邻域与 $P$ 的交从大到小排序，注意只有这个优化是没用的，这个优化是辅助上一个减枝更快找到比较大的团以达到减掉更多没用的分支用的，因为看起来这样排序后较前的分支的候选点集减少的比较少，后面操作起来更自由所以更优，但这貌似有点负优化，实测 $67$ 分，当然还有一种说法是按度数从大到小排序，虽然看起来不如上一个优但这个能 $76$ 分。

我不知道是不是数据具有特殊性的问题，这个优化等于没有优化。

3. 支配点减枝，就是如果有某个点 $u$ 的邻域是另一个点 $v$ 的邻域的子集，那 $u$ 一定在 $v$ 后搜，这个如果真有的话其实理论上能优化不少，但事实上想不增加太多额外开销写这个不好写，而且很容易卡的没有这样的支配点对，所以我没试。

4. 颜色减枝，这是 deepseek 提供的思路，据说在稠密图上效果很好，但这个减枝貌似对后面没什么帮助，而且有额外开销，我看着不太好写所以就没试。

## Tomita 改进

Tomita 的改进通过选择枢轴顶点（pivot）减少递归分支，显著提升效率。

**枢轴的作用**：

选择一个顶点 $u$ 作为枢轴（通常选当前的 $P|X$ 中度数最大的点）。

关键性质：所有极大团必须包含 $u$ 或至少一个与 $u$ 不相邻的点。

下面证明这个性质，假设存在极大团 $C$ 不包含这样的点，那么 $C\cap(P\setminus N(u))= \emptyset$，则有 $C\subset P\cap N(u)\cup X $，由于 $C$ 不包含 $u$，则 $C\subset P\cup X\setminus u$，由于 $C$ 一定不可能属于 $X$，那两个并上 $X$ 可以消掉，所以发现 $C\subset N(u)$，即 $u$ 到 $C$ 所有点有边，则 $C$ 不是极大团，矛盾。

于是这样就能过了，为防止因火车头导致无法过审，这里只放核心程序。
```cpp
unsigned n,m;
struct A{ull a[64],ans,cnt,sta;
	void ins(cit u,cit v){a[u]|=1ll<<v;}
	void chk(cit ll R){cit x=__builtin_popcountll(R);if(x<ans)return;if(x==ans){++cnt;return;}cnt=1,ans=x,sta=R;}
	il unsigned find();
	void dfs(int ll P,int ll R,int ll X){/*cerr<<bitset<8>(P)<<' '<<bitset<8>(R)<<'\n';*/if(!P)return chk(R);
		if(__builtin_popcountll(R|P)<ans)return;
		int ll U=P|X,Q;int u=0;
		for(int ll v=__builtin_ctzll(U);U;U^=1ll<<v,v=__builtin_ctzll(U))if(__builtin_popcountll(a[v]&P)>__builtin_popcountll(a[u]&P))u=v;
		Q=P&~a[u];
		for(int ll v=__builtin_ctzll(Q);Q;Q^=1ll<<v,P^=1ll<<v,X|=1ll<<v,v=__builtin_ctzll(Q))dfs(P&a[v],R|1ll<<v,X&a[v]);
	}void print(){cout<<ans<<' '<<cnt<<'\n';for(int i=1;i<=n;++i)if(sta&(1ll<<i))cout<<i<<' ';cout<<'\n';}
}G1,G2;Bool(a[64],64);ull all=0;
void init(){rd(n),rd(m);
	for(int u,v;m--;a[u][v]=a[v][u]=1)rd(u),rd(v);
	for(int i=1;i<=n;++i)for(int j=1;j<=n;++j)if((i^j)&& a[i][j])G1.ins(i,j);
	for(int i=1;i<=n;++i)for(int j=1;j<=n;++j)if((i^j)&&!a[i][j])G2.ins(i,j);
	for(int i=1;i<=n;++i)/*G1.ins(i,i),G2.ins(i,i),*/all|=1ll<<i;
}void solve(){init();
	G1.dfs(all,0,0);G1.print(),G2.dfs(all,0,0),G2.print();
}signed main(){open;int t=1;//cin>>t;
	while(t--)solve();}
```
部分内容借鉴自 deepseek，但我并没有整段整句的复制粘贴，也没有原封不动的抄袭，事实上仅仅只是因为我没有学过这个算法使用 deepseek 进行学习正常的整理笔记。

---

## 作者：Missa (赞：2)

一个比较好写的时空 $O(2^{\frac{n}{2}})$ 做法。

考虑每次去掉一个点搜索。我们希望记录一部分结果以减小复杂度，因此考虑每次去掉编号最大的那个点，并记忆化所有只使用编号最小的 $n/2$ 个点的情况。

这里要记下的结果包含：大小，个数，和一个例子。只要能比较与合并一个点进去，就可以这样做。

下面考虑的是独立集（这样好写些）。

记当前集合为 $S$，要去掉的也是编号最大的点为 $u$，$u$ 的领域为 $E(u)$。则，选 $u$ 入独立集，转化在 $S \backslash	 (E(U) \cup \{u\})$ 上考虑原问题，并将 $u$ 加入结果；否则，转化为在 $S\backslash	\{u\}$ 上考虑原问题。

考虑复杂度证明。前 $n/2$ 步只会拓展出 $2^{\frac{n}{2}}$ 个状态，而后 $n/2$ 步涉及的总状态数不超过 $2^{\frac{n}{2}}$，由于记忆化每种只会被访问一次，因此这个做法的时空复杂度均为 $2^{\frac{n}{2}}$。

这个复杂度证明方式跟 [CF1336E1](https://www.luogu.com.cn/problem/CF1336E1) 很像。

因为是独立集，要先对反图求解，再对原图求解。可以把开始的 $E$ 就看成补集，但那样代码可读性会下降，我就没写。

```cpp
#include <bits/stdc++.h>

using LL = long long;

struct node {
  int mx, cnt; LL ex;
  node(int mx = 0, int cnt = 1, LL ex = 0) : mx(mx), cnt(cnt), ex(ex) {}
  node operator + (const node &t) const {
    if (mx != t.mx) return mx > t.mx ? *this : t;
    return {mx, cnt + t.cnt, ex};
  }
  node operator + (int x) const {
    return {mx + 1, cnt, ex | (1ll << x)};
  }
};

int main() {
  int n, m; scanf("%d %d", &n, &m);
  std::vector<LL> e(n);
  for (int i = 0, u, v; i < m; i++) {
    scanf("%d %d", &u, &v), --u, --v;
    e[u] |= 1ll << v, e[v] |= 1ll << u;
  }
  LL lim = 1ll << (n / 2), all = (1ll << n) - 1;
  std::vector<node> f(lim);
  std::function<node(LL)> dfs = [&](LL st) {
    if (st < lim && f[st].mx > 0) return f[st];
    if (!st) return node();
    int x = std::__lg(st);
    LL r = st & (all ^ e[x] ^ (1ll << x));
    node ans = dfs(st ^ (1ll << x)) + (dfs(r) + x); 
    if (st < lim) f[st] = ans;
    return ans;
  };
  for (int i = 0; i < n; i++)
    e[i] = all ^ (1ll << i) ^ e[i];
  node ans = dfs(all);
  printf("%d %d\n", ans.mx, ans.cnt);
  for (int i = 0; i < n; i++) if (ans.ex & (1ll << i))
    printf("%d ", i + 1);
  printf("\n");
  for (int i = 0; i < n; i++)
    e[i] = all ^ (1ll << i) ^ e[i];
  f.assign(lim, node());
  ans = dfs(all);
  printf("%d %d\n", ans.mx, ans.cnt);
  for (int i = 0; i < n; i++) if (ans.ex & (1ll << i))
    printf("%d ", i + 1);
  printf("\n");
} 
```

---


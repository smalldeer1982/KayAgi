# [SDOI2011] 黑白棋

## 题目描述

小 A 和小 B 又想到了一个新的游戏。

这个游戏是在一个 $1 \times n$ 的棋盘上进行的，棋盘上有 $k$ 个棋子，一半是黑色，一半是白色。

最左边是白色棋子，最右边是黑色棋子，相邻的棋子颜色不同。

![](https://cdn.luogu.com.cn/upload/image_hosting/dmv5zoyy.png)

小 A 可以移动白色棋子，小 B 可以移动黑色的棋子，其中白色不能往左，黑色不能往右。他们每次操作可以移动 $1$ 到 $d$ 个棋子。

每当移动某一个棋子时，这个棋子不能跨越两边的棋子，当然也不可以出界。当谁不可以操作时，谁就失败了。

小 A 和小 B 轮流操作，现在小 A 先移动，有多少种初始棋子的布局会使他胜利呢？


## 说明/提示

- 对于 $30\%$ 的数据，有 $k=2$。
- 对于 $100\%$ 的数据，有 $1 \leq d \leq k \leq n \leq 10^4$，$k$ 为偶数，$k \leq 100$。


## 样例 #1

### 输入

```
10 4 2```

### 输出

```
182```

# 题解

## 作者：VinstaG173 (赞：37)

感觉大家的题解的dp部分挺不错的了，但是k-nim部分还是不太好。这篇题解会主要讲解k-nim。

k-nim游戏是这样的：

有$N$堆石子，每次可以从不超过$k$堆中各取一些石子，不能操作者败。

这题的转化就是将相邻的白左黑右的棋子看作一堆石子，石子个数为两颗棋子之间的空格数。这样两个人移动一颗棋子都相当于从对应的堆中取出一些石子。

k-nim的解法是这样的：

首先将各堆石子数用二进制表示。

令$r_i$表示每堆石子二进制表示的第$i$位上数字之和$\bmod (k+1)$的值。

如果有任意一个$r_i \ne 0$，先手必胜；否则先手必败。

k-nim的解法证明：

**敲黑板划重点啦！**

如果所有的$r_i$都为$0$，则一次操作肯定会使得某些数位上的值改变。又因为一堆石子每位上都是$0$或$1$，所以变动的绝对值不会超过$k$。因此操作结束后该位置上的$r_i$必不能为$0$。

如果有一些$r_i$不为$0$。则肯定有$r_i$堆石子的数量二进制表示该位上为$1$。此时我们只要从高到低扫每一个二进制位，选择$r_i$堆该位上为$1$的石子，再使每堆石子的个数$\mathrm{xor}$ $2^i$，此时这些堆的石子个数会变少，而$r_i$会变为$0$。

但是有一个问题：如果这样选出来的石子堆数超过了$k$怎么办？

此时我们知道：如果一个数的高位从$1$变成$0$，则其低位无论怎么变化，这个数还是变小。

于是我们每次只要尽量优先选择有高位变为$0$的数，再选择该位上为$1$的数，这样由于每个位置要选的数不到$k+1$（$r_i < k+1$）个，所以总共要选的堆数不会超过$k$堆。

又因为无法操作的状态各个$r_i$均为$0$。所以我们得到了解法。

接着的dp可以参见神仙们的题解，在此不予赘述。

Code:
```cpp
#include<cstdio>
const int o=1e9+7;
int n,k,d,ans;
int frc[10007],inv[10007];
int dp[17][17007];
inline int qpw(int x,int v)
{
	int r=1;
	while(v)
	{
		(v&1)&&(r=1ll*r*x%o),x=1ll*x*x%o,v>>=1;
	}
	return r;
}
inline int C(int N,int M)
{
	return 1ll*frc[N]*inv[M]%o*inv[N-M]%o;
}
int main()
{
	scanf(" %d %d %d",&n,&k,&d);
	frc[0]=1;
	for(int i=1;i<=n;++i)
	{
		frc[i]=1ll*frc[i-1]*i%o;
	}
	inv[n]=qpw(frc[n],o-2);
	for(int i=n;i;--i)
	{
		inv[i-1]=1ll*inv[i]*i%o;
	}
	dp[0][0]=1;
	for(int i=0;i<=13;++i)
	{
		for(int j=0;j<=n-k;++j)
		{
			for(int x=0;k+(x<<i)<=n&&x<<1<=k;x+=d+1)
			{
				dp[i+1][j+(x<<i)]=(dp[i+1][j+(x<<i)]+1ll*dp[i][j]*C(k>>1,x))%o;
			}
		}
	}
	for(int i=0;i<=n-k;++i)
	{
		ans=(ans+1ll*dp[14][i]*C(n-i-(k>>1),k>>1))%o;
	}
	printf("%d\n",(C(n,k)-ans+o)%o);
	return 0;
}
```

---

## 作者：ysner (赞：35)

题面显然有误，如果允许白往左、黑往右，这游戏玩不完。

~~毕竟我是在博弈论的题单里发现这道题的~~

很快就反应过来：**把各对相邻黑白棋子之间的距离视作一堆石子即可**。
于是问题转化为一个 一次限制取$d$个 的$Nim$游戏。

这种类型问题有个结论：$SG[x]=x\%(d+1)$。
即题目本质是要 各堆石子个数异或和$\%(d+1)=0$。

怎么统计方案？（注意下状态）

显然异或和模$d+1$为$0$这种情况很方便设计$DP$状态。于是先统计后者胜利的情况，再用方案总数$C_n^k$减去它得到答案。

设$f[i][j]$表示确定异或和二进制第$1-i$位均为$0$、现有$j$个石子的方案数。

枚举该位需要$x$倍$d+1$个石子。

此时，该位对石子数的贡献取决于各堆石子该位是否为$1$。

**于是要从$k/2$个堆选出$x*(d+1)$个,把这些堆石子数 该位置为$1$，贡献$C_{k/2}^{x*(d+1)}$种方案**。

**同时，我们要选出各堆的位置，相当于在$n-j-k/2$（$k/2$个位置被终点占）个位置中选出$k/2$个起点，贡献$C_{n-j-k/2}^{k/2}$种方案。**

综上得方程式：
$$f[i+1][j+(1<<i)*x*(d+1)]+=f[i][j]*c[k/2][x*(d+1)]$$
$$f[i][j]=f[i][j]*C[n-j-k/2][k/2]$$
```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#define ll long long
#define re register
#define il inline
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
using namespace std;
const int mod=1e9+7;
int n,k,d,C[10005][205],dp[18][100005];
ll ans;
il ll gi()
{
  re ll x=0,t=1;
  re char ch=getchar();
  while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
  if(ch=='-') t=-1,ch=getchar();
  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
  return x*t;
}
int main()
{
  n=gi();k=gi();d=gi();
  C[0][0]=1;
  fp(i,1,n)
    {
      C[i][0]=1;
      fp(j,1,200) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
    }
  dp[0][0]=1;
  fp(i,0,16)
    fp(j,0,n-k)
    for(re int x=0;(1ll<<i)*x*(d+1)<=n-k&&x*(d+1)<=k/2;++x)
      (dp[i+1][j+(1ll<<i)*x*(d+1)]+=1ll*dp[i][j]*C[k/2][x*(d+1)]%mod)%=mod;
  fp(i,0,n-k) ans=(ans+1ll*dp[17][i]*C[n-i-k/2][k/2]%mod+mod)%mod;
  printf("%lld\n",(C[n][k]-ans+mod)%mod);
  return 0;
}
```

---

## 作者：cyffff (赞：19)

[$\text{Link}$](https://www.luogu.com.cn/problem/P2490)

$\text{upd2021.8.12:}$ 修复一个笔误。
## 题意
在一个 $1\times n$ 的棋盘上有 $k$ 个棋子，其中有 $\frac k 2$ 个黑棋和 $\frac k 2$ 个白旗。黑棋只能向左，白棋只能向右。每次可以动自己的 $1$ 至 $d$ 颗棋子，每颗棋子可以移动任意格，但是不能跨过任意一方的棋子。

问有多少种布局方案使得白方必胜，要求棋局满足：

- 最左边的棋子是白色；
- 最右边的棋子是黑色；
- 相邻棋子颜色相异。 


其中 $1\le k\le 100,1\le d\le k\le n\le 10^4,2|k$

## 思路
搞了好久终于搞懂了...

### 前置知识：$k-\text{Nim}$ 游戏
#### 描述
有 $n$ 堆棋子，其中第 $i$ 堆有 $a_i$ 颗，每次可以取走 $1$ 至 $k$ 堆棋子中任意颗棋子，不能操作者输。
#### 解法
记数 $x$ 二进制下的第 $i$ 位表示为 $(x)_i$。

先写出结论：若 $\displaystyle\forall s,\left(\sum_{i=1}^n(a_i)_s\right)\bmod(k+1)=0$，则先手必败，否则先手必胜。

#### 证明

有向无环图博弈满足一下几点：

- 终止状态为 $\text{P}$ 态

所有堆都为 $0$ 颗棋子，显然满足 $\text{P}$ 态。

- 所有的 $\text{N}$ 态只能转移至 $\text{P}$ 态

对于一次操作，必定会取走一些棋子，使得某一位上的数值发生改变，改变的范围只有 $1$ 至 $k$，不存在一种方案使得操作前后 $\displaystyle\forall s,\left(\sum_{i=1}^n(a_i)_s\right)\bmod(k+1)$ 都是 $0$。

- 所有的 $\text{P}$ 态都有至少一种方案转移至 $\text{N}$ 态

记 $b_s=\displaystyle\left(\sum_{i=1}^n(a_i)_s\right)\bmod(k+1)$，对于所有的 $b_s\ne0$，我们找到 $b_s$ 堆棋子，从中取走 $2^s$ 颗棋子即可转换至 $\text{N}$ 态。

证毕。
****
回到本题，我们发现棋子不能跨越另外一颗棋子，则最后 $\frac k 2$ 对相邻的黑白棋子必定会被放置在相邻两个格子中，我们可以将相邻的 $2$ 颗棋子之间的距离看做一堆棋子的颗数，问题转化为了 $d-\text{Nim}$ 游戏先手必胜局面数。

考虑一个 $\text{dp}$，正着不好想，于是反着做，设 $dp_{i,j}$ 表示 $0$ 至 $i-1$ 位中 $b_i$ 都为 $0$ 的方案数，用 $\displaystyle\binom{n}{k}$ 减去即得答案。

考虑在新的一位中选出 $x(d+1)$ 堆为 $1$ 的，方案数即为 $\displaystyle\binom{\frac k 2}{x(d+1)}$，可有转移

$$dp_{i+1,j+2^ix(d+1)}\gets dp_{i+1,j+2^ix(d+1)}+\binom{\frac k 2}{x(d+1)}dp_{i,j}$$

方案即
$$\sum_{i=1}^{n-k}dp_{mx+1,i}\binom{n-i-\frac k 2}{\frac k 2}$$

其中 $mx$ 为最高的二进制位

注意要记得转换回原方案。

时间复杂度 $O(nk\log n)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int mod=1e9+7,N=1e4+10;
int n,k,d,dp[14][N];
int C[N][205];
inline void init(){
	C[0][0]=1;
	for(int i=1;i<=n;i++){
		C[i][0]=1;
		for(int j=1;j<=min(i,k);j++)
			C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
	}
}
int main(){
	n=read(),k=read(),d=read();
	init();
	dp[0][0]=1;
	for(int i=0,p=1;i<=12;i++,p<<=1)
		for(int j=0;j<=n-k;j++)
			for(int x=0;j+p*x*(d+1)<=n-k&&x*(d+1)<=k/2;x++)
				dp[i+1][j+p*x*(d+1)]=(dp[i+1][j+p*x*(d+1)]+1ll*dp[i][j]*C[k/2][x*(d+1)])%mod;
	int ans=0;
	for(int i=0;i<=n-k;i++)
		ans=(ans+1ll*dp[13][i]*C[n-i-k/2][k/2])%mod;
	printf("%d",(C[n][k]+mod-ans)%mod);
	flush();
	return 0;
}
```
再见 qwq~

---

## 作者：ez_lcw (赞：10)

显然，如果白棋往左，黑棋往右，最后肯定会两两碰在一起，就像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/g5z5a6pv.png)

红框框起来的是会碰在一起的棋子。（我们把会碰到一起的棋子称为一对棋子）

如下图就是碰在一起的一种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/fbxv46p5.png)

那么现在假设是 $A$ 遇到了这种情况，那么无论他操作的是白棋或黑棋，他肯定会输。因为另一个人可以操控棋子跟着 $A$ 的棋子走，一直保持棋子两两紧逼的状态，直到所有棋子都堆在一边，这时 $A$ 就无路可走了，失败。

不妨设开始前每对棋子之间的距离为 $a_1,a_2,\dots,a_{\frac{k}{2}}$，那么原题就可以转化成一个 k-nim 游戏：现在有 $\frac{k}{2}$ 堆石子，第 $i$ 堆石子的石子个数是 $a_i$，现在两人轮流进行如下操作：在这之中任意选取 $1\sim d$ 堆石子，对于选取的这几堆石子中的每堆石子，能拿走任意正整数个石子。最后不能进行操作为失败。

这种问题有一个结论：将当前状态的 $a_i$ 用二进制表示，设 $s_i$ 表示 $a_1\sim a_{\frac{k}{2}}$ 中二进制下第 $i$ 位 $1$ 的个数，$s_i\equiv s_i'\pmod {k+1}$。若所有的 $s_i'$ 都为 $0$，则这个状态为必败状态，否则为必胜状态。

证明：

1. $a_i$ 全部为 $0$ 的状态是必败状态，且此时所有的 $s_i'$ 都为 $0$。

2. 设状态 $P$ 是 $s_i'$ 全部为 $0$ 的状态，状态 $N$ 是存在 $s_i'$ 不为 $0$ 的状态。

	假设当前状态为 $P$ 状态。
    
   显然，由于我至少要在一个堆里面取石子，所以某些 $a_i$ 的一定会改变。所以首先，某些 $s_i$ 一定会改变。然后又由于一次最多只能改变 $d$ 个堆，所以对于每一个 $s_i$，最多只会加上或减去 $d$。又由于一开始 $s_i\equiv0\pmod{d+1}$，所以变化后的 $s_i$ 一定不可能满足 $s_i\equiv0\pmod{d+1}$。
   
   也就是说，对于任意的 $P$ 状态，一定只能转移成 $N$ 状态。
   
3. 假设当前状态为 $N$ 状态，那么我们要证明的目标是：对于任意的 $N$ 状态，一定存在一种转移方式转移成 $P$ 状态。

	我们从高位到低位地考虑所有的二进制位。显然，最高位的石子我们要全部取走。假设当前位为第 $i$ 位，且已经满足了 $s_j'=0$（$j>i$），并且改变了 $m$ 个堆的石子数量（$m\leq d$）。
    
   那么我们现在就是要证明：是否有一种操作，能使得 $s_i'=0$，且新改变的堆加上以前改变过的堆的总堆数 $m'\leq d$。（类似数学归纳法）
    
   有一个比较显然的性质：对于那些已经改变的 $m$ 堆，我改变这些堆的低位不会影响到高位的 $s_j'$。
   
   设在这 $m$ 堆中，每一堆所含石子个数的第 $i$ 位上共有 $a$ 个 $1$，$b$ 个 $0$。
   
   分情况讨论：
   
   1. $a\geq s_i'$。那我们就可以在这 $m$ 堆中找到 $s_i'$ 个第 $i$ 位为 $1$ 的堆并**取走**这一位所代表的石子（也就是 $2^i$ 个石子），显然根据我们刚刚提到的性质，取走这些石子不会影响高位的 $s_j'$。（也就是让 $s_i'\gets 0$）
   
   2. $b\geq (d+1)-s_i'$。那我们就可以在这 $m$ 堆中找到 $(d+1)-s_i'$ 个第 $i$ 位为 $0$ 的堆并**加上**这一位所代表的石子（也就是 $2^i$ 个石子）（就算加上了这些石子，对于这一堆来说，石子总数还是减的，因为我们一开始减去了最高位所代表的石子），显然根据我们刚刚提到的性质，取走这些石子不会影响高位的 $s_j'$。（也就是让 $s_i'\gets d+1$）
   
   3. 上述两种情况都不满足，也就是说 $a< s_i'$，那么我们先取走这 $a$ 堆中第 $i$ 位的石子，然后再从这 $m$ 堆之外的堆里面找 $s_i'-a$ 个第 $i$ 位为 $1$ 的堆并取出它第 $i$ 位的石子，总堆数变成了 $m+s_i'-a=b+s_i'\leq d+1-s_i'+s_i'=d+1$，所以这种取法是合法的。
   
   综上所述，我们可以保证对于任意的 $N$ 状态，一定存在一种转移方式转移成 $P$ 状态。

综上所述，我们就可以证明 $P$ 状态是必败状态，$N$ 状态是必胜状态，结论成立。

接下来就是如何计算方案。

设 $dp(i,j)$ 表示前 $i-1$ 位每一位的异或和均为 $0$，已经有 $j$ 个石子的方案数。（也就是必败方案数）

枚举 $a_1\sim a_\frac{k}{2}$ 的第 $i$ 位共有多少个 $1$，且满足个数是 $(d+1)$ 的倍数（也就是枚举 $(d+1)$ 的 $x$ 倍）。

然后在 $\frac{k}{2}$ 个堆里面取 $x(d+1)$ 个，把他们的第 $i$ 位设为 $1$，总方案数是 $\dbinom{\frac{k}{2}}{x(d+1)}$。

最后我们还要枚举堆在哪里，也就是 $\dbinom{n-j-\frac{k}{2}}{\frac{k}{2}}$。

然后 dp 一下就好了。

代码如下：

```cpp
#include<bits/stdc++.h>

#define LN 20
#define K 210
#define N 10010
#define ll long long
#define int long long
#define mod 1000000007

using namespace std;

int n,k,d;
int C[N][K],dp[LN][N];

signed main()
{
	scanf("%lld%lld%lld",&n,&k,&d);
	C[0][0]=1;
	for(int i=1;i<=n;i++)
	{
		C[i][0]=1;
		for(int j=1;j<=200;j++)
			C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
	}
	dp[0][0]=1;
	for(int i=0;i<=16;i++)
	{
		ll t=(1ll<<i);
		for(int j=0;j<=n-k;j++)
			for(int x=0;t*x*(d+1)<=n-k&&x*(d+1)<=k/2;x++)
				dp[i+1][j+t*x*(d+1)]=(dp[i+1][j+t*x*(d+1)]+(1ll*dp[i][j]*C[k/2][x*(d+1)])%mod)%mod;
	}
	ll ans=0;
	for(int i=0;i<=n-k;i++)
		ans=(ans+1ll*dp[17][i]*C[n-i-k/2][k/2]%mod)%mod;
	printf("%lld\n",((C[n][k]-ans)%mod+mod)%mod);
	return 0;
}
```

---

## 作者：Fan_Tuan (赞：9)

本题解部分内容借鉴大佬博客（~~好像是全借鉴的~~。

## 题意：
	
给定你一个 $1 \times n$ 的棋盘，棋盘上总共有 $k$ 枚棋子，

有 $\frac{k}{2}$ 枚白棋，有 $\frac{k}{2}$ 枚黑棋。

其中棋盘上的棋子满足最左边一定是白色棋子，最右边的一枚一定是黑色棋子。

同时为了保证游戏可以停止，所以黑棋只能往左走，白棋只能往右走。

游戏结束的条件是当有一个人无法移动自己的棋子的时候，这个人就输了。

同时题目规定不能隔着棋走，也就是只能走棋盘上的空格。

## 思路：

这道题是一道博弈论的题，仔细读题会发现这题可以看成 `K-Nim` 游戏。

那什么是 `K-Nim` 游戏呢？

这是一个公平组合游戏，输赢与当前的状态有关，与游戏者无关。

有 $n$ 堆石子，每次可以从不超过 $k$ 堆中各取一些石子，如过轮到哪个人拿石

子时却石子被拿空，那么这个人就输了。

我们可以将相邻的白黑棋子看成是一堆石子，中间棋盘的空格就是石子的个数。

当两个人移动棋子的时候就相当于是从这堆石子中取出了石子。

`K-Nim` 游戏的解法是：

将每堆石子转换成二进制，然后用一个 $sum_i$ 来表示每堆石子二进制下第 $i$ 

位的数字去 $\bmod (k + 1)$，当有一个 $sum_i \ne 0$ 时，

此时先手必胜，后手必输。

### `Nim` 游戏详细讲解：

这游戏看上去比较复杂，先从简单的情况开始分析。

当只有一堆石子的时候，先手必胜，只需要一次性把所有石子都拿走就行了。

当有两堆石子并且两堆石子数量不一样多的时候，那么你只需要先手从石子多的那

堆中去拿一部分石子让两堆石子数量相等，然后每次拿和对面一样多的石子，也是必胜局面。

那当两堆石子一样多的时候，还会存在必胜局面吗，只能后手必胜，所以你的对手也

可以拿和你一样多的石子让你输掉。

定义两种状态，一种是 `P-position`，另一种是 `N-position`。

`P-position` 是指后手必胜的局面， `N-position` 是指先手必胜的局面。

根据这个定义，我们可以来以 `Nim` 游戏为例来进行一下计算。

我们这里认为 $(x,y)$ 和 $(y,x)$ 是一种本质相同的局面，因为这两种情况只是

交换了两堆的石子数量，并没有本质区别。

下面我们依靠定义证明一下 $(3,3)$ 是一个 `P-position`。

首先 $(3,3)$ 的子局面有 $(0,3)$、$(1,3)$、$(2,3)$，只需要计算出这三种局面的性质就可以了。

$(0,3)$ 的子局面有 $(0,0)$、$(0,1)$、$(0,2)$，其中 $(0,0)$ 显然是 `P-position`，

所以 $(0,3)$ 是 `N-position`（只要找到一个是 `P-position` 的子局面就能

说明现在是 `N-position`）。

 $(1,3)$ 的后继中 $(1,1)$ 是 `P-position`（因为 $(1,1)$ 的唯一子局面 
 
 $(0,1)$ 是 `N-position`），所以 $(1,3)$ 也是 `N-position`。
 
同样可以证明 $(2,3)$ 是 `N-position`。

所以 $(3,3)$ 的所有子局面都是 `N-position`，它就是 `P-position`。

通过一点简单的数学归纳，可以严格的证明“有两堆石子时的局面是 `P-position` 。

当且仅当这两堆石子的数目相等”。 

根据这个过程，我们可以通过递归来计算每种局面的自局面，如果某个局面是 `P-
position`，

那么这个局面的上一步就是一个必胜的局面。

### `K-Nim` 游戏解法证明：

我们这里设堆数为 $d$。

我们考虑只有一堆石子的时候，显然异或和为 $0$ 时先手能变为不为 $0$，
 
而后手在能将其变为为 $0$，假设先手动的最高位为 $i$，

则后手动第 $i$ 位上为 $1$ 的另一个石子，下面的变成与之对应的即可。

那么考虑堆数大于 $1$ 的情况， 当所有数出现次数均为 $(d+1)$ 的倍数时，先

手不可能依然变为出现次数均为 $(d+1)$ 的倍数；

从高到低考虑位 $j$，设现在已经改变的堆数为 $t$， $t$ 个数中有 $a$ 个在位 

$j$ 上为 $1$，$b$ 个为 $0$， 并假设后手改动前这一位上 $1$ 的个数 $(d+1)$ 总共是 $x$。

若 $ a \le x$， 则改变这 $a$ 个中的 $x$ 个即可。若$ b \le (d - x + 1)$。 

 则可以把 $b$ 个中的 $(d + 1 - x)$ 个从 $0$ 变成 $1$。

否则另外选择 $t$ 堆之外的 $(x - a)$ 堆变成1， 

则选的总数为 $(x-a)+a+b$ $ = $ $x + b \le  (d +1- b +b)$ $=$ $d + 1$，

故移动依然合法。

然后统计方案数即可，我们用 $dp[i][j]$ 来表示到第 $i$ 位和为 $j$ 的方案数。

转移一下即可，其他题解都已经写的比较明白了。


---

## 作者：Star_Cried (赞：6)

## P2490 [SDOI2011]黑白棋

### 题意

一个 $1*n$ 的棋盘上，A 可以移动白色棋子，B 可以移动黑色的棋子，其中白色不能往左，黑色不能往右。他们每次操作可以移动 1 到 $d$ 个棋子。

每当移动某一个棋子时，这个棋子不能跨越两边的棋子，当然也不可以出界。当谁不可以操作时，谁就失败了。

### 思路

显然可以将题意转化为一种 K-Nim 游戏，即在 $\frac k2$ 堆石子中，每次可将 $d$ 堆石子取任意个，令对手无路可走时获胜。

用总方案数减去先手必败的方案数即为答案，因为先手必败方案更加好算。

****

## K-Nim 游戏

### 结论

设 $r_i$ 为二进制第 $i$ 位所有数该位为 1 的个数 $\pmod {d+1}$  的值，那么只用一步即可在 “$r$ 全为 0” 和 “$r$ 不全为 0” 两种状态间转移。

### 感性证明

考虑一个大小不超过 $d$ 的集合，为我们一次操作需要拿走的石子堆的集合，选 0 或 1 都是合法的。

假设我们现在已经有这样一个大小为 $d$ 的集合，其中有 $x$ 个 1，$y$ 个 0，即 $x+y=d$。我们要让 $r$ 等于零，分以下情况：

* $x\ge r$ 则选择 $r$ 个 1 变为 0 即可。
* $x<r$ 则 $y+r\ge d+1$ ，则选择 $d-r+1$ 个 0 变为 1 即可。

所以一定有一种方法使这一位的 $r$ 变成 0.

现在我们并没有一个可以随便转换的集合，但是当一个数的高位从 1 变为 0 之后低位就可以随便选 0 和 1.所以我们从高位向低位考虑，如果一直符合第二个情况就向下考虑，否则就是第一个情况，并且在这种情况下把 1 变成 0 是合法的，那么我们扩大集合即可。

得证。

****

在上述博弈中，所有 $r$ 为 0 的状态是必败态。我们只需要算所有这种情况的方案就可以了。

考虑 Dp。设 $f_{ij}$ 为前 $i$ 位的 $r$ 均为 0，总共 $j$ 个石子的方案数。

新选一位，枚举在 $d+1$ 堆石子中放入若干次石子。即
$$
f_{i+1,j+2^ix(d+1)}+=f_{i,j}\binom{\frac k2}{x*(d+1)}
$$
最后统计答案需要枚举每一堆的起点位置，即在原题中的白棋的位置，答案为所有位的
$$
f_{i,j}\binom{n-j-\frac k2}{\frac k2}
$$
的和。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cstring>
#include<cmath>
using namespace std;
inline int read(){
	int w=0,x=0;char c=getchar();
	while(!isdigit(c))w|=c=='-',c=getchar();
	while(isdigit(c))x=x*10+(c^48),c=getchar();
	return w?-x:x;
}
namespace star
{
	const int maxn=10005,mod=1e9+7;
	int n,k,d,C[maxn][205],f[18][100005];
	inline void work(){
		n=read(),k=read(),d=read();
		C[0][0]=1;
		for(int i=1;i<=n;i++){
			C[i][0]=1;
			for(int j=1;j<=200;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
		}
		f[0][0]=1;
		for(int i=0;i<=16;i++) for(int j=0;j<=n-k;j++) for(int x=0;(1ll<<i)*x*(d+1)<=n-k and x*(d+1)<=k/2;x++)
			f[i+1][j+(1ll<<i)*x*(d+1)]=(f[i+1][j+(1ll<<i)*x*(d+1)]+1ll*f[i][j]*C[k/2][x*(d+1)])%mod;
		int ans=0;
		for(int i=0;i<=n-k;i++) ans=(ans+1ll*f[17][i]*C[n-i-k/2][k/2])%mod;
		printf("%d\n",(C[n][k]-ans+mod)%mod);
	}
}
signed main(){
	star::work();
	return 0;
}
```



---

## 作者：Genius_Star (赞：5)

### 思路：

因为白棋只能往右走，黑棋只能往左走；故我们可以令黑白棋之间的距离看作一堆石子。

游戏转化为：

- 每次选择任意 $1 \sim d$ 堆石子取走任意枚棋子。

是一个经典的 k-nim 游戏。

先说结论：

- 先将 $a$ 序列每个数换成**二进制**，对于二进制下第 $i$ 位，令 $s_i$ 表示 $a$ 序列中该位为 $1$ 的个数对 $k+1$ **取模**。 

- 若存在一个 $i$ 使得 $s_i \ne 0$，则**先手必胜**；否则**后手必胜**。 

证明：

- 若游戏无法进行，即 $a = \{0,0,0,0,\cdots\}$，此时定然满足 $\forall i,s_i = 0$，**故先手必败**。

- 若当前状态为**必胜态**，即 $s$ 中有些位置的值不为 $0$，需要经过一次操作使得下一个状态为**必败态**。
    
  - 考虑从**高位到低位**使得 $s_i=0$。

  - 考虑**数学归纳法**，设已经使得 $s_j = 0 (j>i)$，且已经改变了 $m$ 堆的石子数，设这 $m$ 堆石子中第 $i$ 位中 $1$ 的个数为 $a$，$0$ 的个数为 $b$（注意，这里不取模）。

  - 进行分类讨论：
      
    - 若 $a \ge s_i$：故我们需要在 $m$ 堆中找到 $s_i$ 堆第 $i$ 位为 $1$ 的堆，然后拿走第 $i$ 位的石子，即 $2^i$ 枚石子；这样会使得 $s_i \gets 0$。

    - 若 $b \ge (k+1) - s_i$：故我们需要在 $m$ 堆中找到 $(k+1)-s_i$ 堆第 $i$ 位为 $0$ 的堆，然后“添加”上第 $i$ 位的棋子；因为这些堆高位上操作过，且 $2^n \ge \sum_{i=0}^{n-1} 2^i$，故相对于总量还是减少的；也可以使得 $s_i \gets 0$。

    - 若上述两种情况都不满足，即 $a < s_i,b < (k+1) - s_i$；此时先在 $m$ 堆取出 $a$ 堆第 $i$ 位为 $1$ 的堆，然后再在这 $m$ 堆之外的堆中找 $s_i - a$ 堆第 $i$ 位为 $0$ 的堆，此时 $s_i \gets 0$；且总操作的堆数为 $m + s_i - a = b + s_i < (k+1) - s_i + s_i = k+1$，故最多操作 $k$ 堆。
   
    - 即总能经过操作使得下一个状态为**必败态**。

- 若当前状态为**必败态**，即  $s = \{0,0,0,0,\cdots\}$，则进行一次操作后肯定 $\exists i,s_i \ne 0$；因为最多进行 $k$ 次操作，故每一位上的变动的**绝对值**绝对**不超过** $k$，故下一个状态为**必胜态**。

综上，得证。

故问题可以转化为：

- 将 $n-k$ 颗棋子放在 $\frac{k}{2}$ 堆里，满足存在一个 $i$，使得二进制第 $i$ 位为 $1$ 的数量对 $(d+1)$ 取模后的值不为 $0$。

进行容斥，用总方案数减去都为 $0$ 的方案数。

考虑动态规划算法，定义 $dp_{i,j}$ 表示满足 $s_k(k>i) \bmod (d+1) = 0$，即对于二进制后 $i$ 位都为 $0$；且当前用了 $j$ 颗石子的方案数。

枚举一个 $(d+1)$ 的倍数 $l$ 进行转移，则状态转移方程为：

$$dp_{i,j - l \times (d+1) \times 2^i} \gets dp_{i,j - l \times (d+1) \times 2^i} + dp_{i+1,j} \times C_{\frac{k}{2}}^{l \times (d+1)}$$

注意要乘上在 $\frac{k}{2}$ 堆石子中选择 $l \times (d+1)$ 堆使得二进制第 $i$ 位为 $1$ 的方案数，即放入 $2^i$ 颗石子进去。

最后答案为：

$$\sum_{i=0}^{n-k} dp_{0,i} \times C_{i + \frac{k}{2}}^{\frac{k}{2}}$$

即将剩下的 $i$ 枚棋子放置到 $\frac{2}{k}+1$ 个空位中，插板法，方案数为 $C_{i+\frac{k}{2}}^{\frac{k}{2}}$。

时间复杂度为 $O(nk \log n)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef double db;
typedef long long ll;
const int N=1e4+10,mod=1e9+7;
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(int x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
int n,k,d,t,ans;
int f[N],inv[N];
int dp[17][N];
inline int qpow(int a,int b){
	int ans=1;
	while(b){
		if(b&1ll)
		  ans=(1ll*ans*a)%mod;
		a=(1ll*a*a)%mod;
		b>>=1ll;
	}
	return ans;
}
inline void init(){
	f[0]=f[1]=inv[0]=inv[1]=1;
	for(int i=2;i<N;i++)
	  f[i]=(1ll*f[i-1]*i)%mod;
	inv[N-1]=qpow(f[N-1],mod-2);
	for(int i=N-2;i>1;i--)
	  inv[i]=1ll*(i+1)*inv[i+1]%mod;
}
inline int C(int n,int m){
	if(n<m)
	  return 0; 
	return 1ll*f[n]*inv[m]%mod*inv[n-m]%mod;
}
int main(){
	init();
	n=read(),k=read(),d=read();
	t=(ceil)(log(n)/log(2));
	dp[t][n-k]=1;
	for(int i=t-1;i>=0;i--){
		for(int j=0;j<=n-k;j++){
			if(!dp[i+1][j])
			  continue;
			for(int l=0;l*(d+1)<=(k>>1)&&l*(d+1)*(1ll<<i)<=j;l++)
			  dp[i][j-l*(d+1)*(1ll<<i)]=Add(dp[i][j-l*(d+1)*(1ll<<i)],1ll*dp[i+1][j]*C(k>>1,l*(d+1))%mod);
		}
	}
	for(int i=0;i<=n-k;i++)
	  ans=Add(ans,1ll*dp[0][i]*C(i+(k>>1),k>>1)%mod);
	write((C(n,k)-ans+mod)%mod);
	return 0;
}
```

---

## 作者：quantum11 (赞：4)

题目中应增加限制：先手不能左移，后手不能右移

在此前提下，把题目转换为一个$nim$游戏

第$i$个白子与第$i$个黑子中间的格子为一堆石子，每次可以取$d$堆

结论：把$n$堆石子的石子数用二进制表示，统计每位上的$1$的个数，若每位上$1$的个数$\mod(d+1)$全为0，则必败,否则必胜

$f[i][j]$表示前$i$位$\frac K 2$堆石子堆中$j$颗石子的必败局面数量

枚举前位加起来是$d+1$的多少倍$k$

$f[i+1][j+k\times(d+1)\times B[i]]+=f[i][j]\times C^{\frac K 2}_{k\times(d+1)})$

最后用总方案减去必败方案数

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int mo=1e9+7;
int n,K,d,p;
ll tt,s,B[25],c[10005][205],f[25][10005];
void pre() {
	for(int i=0; i<=n; ++i) c[i][0]=1;
	for(int i=1; i<=n; ++i) for(int j=1,L=min(2*K,i); j<=L; ++j)
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%mo;
}
int C(int n,int m) {
	if(m>n-m) m=n-m;
	return c[n][m];
}
void add(ll &x,ll y) {
	x=(x+y)%mo;
}
int main() {
	B[0]=1;
	for(int i=1; i<=15; ++i) B[i]=B[i-1]<<1;
	scanf("%d%d%d",&n,&K,&d);
	K/=2;
	pre();
	f[0][0]=1;
	for(int i=0; i<15; ++i) for(int j=0; j<=n-2*K; ++j)
			for(int k=0; k*(d+1)<=K&&j+k*(d+1)*B[i]<=n-2*K; ++k)
				add(f[i+1][j+k*(d+1)*B[i]],f[i][j]*C(K,k*(d+1)));
	for(int i=0; i<=n-2*K; ++i) add(s,f[15][i]*C(n-i-K,K));
	tt=C(n,K*2);
	return !printf("%d",(tt-s+mo)%mo);
}
```

---

## 作者：Prean (赞：3)

贡献一个知道博弈的结论之后用 GF 脚做的方法（

根据他这个题意说的，白子向右的第一个一定是对应的黑子啊。

所以棋子的绝对位置是不重要的，我们只需要考虑白子和黑子的相对位置，然后考虑用 GF 来拼凑状态就好了。

下面的 $k$ 是题面中的 $\frac{k}{2}$。

这是一个 k-nim。$k$ 堆石头每次最多选 $d$ 堆。

先丢结论：设 $x_i$ 为 $x$ 在二进制下的第 $i$ 位，那么先手必败的条件一定满足对于任意 $i$ 有 $\sum_{j=1}^k(x_j)_i \bmod(d+1)=0$。

证明不会，只会感性理解（

很明显全 $0$ 随便撤一步都不可能撤回全 $0$ 的状态，只需要证明非全 $0$ 是必胜即可。

而非全 $0$ 明显是有办法撤到全 $0$ 的。~~所以我们就成功感性理解了~~

注意到必败的方法比必胜的要好算，所以我们计算必败的方案。

根据这个我们就可以考虑 GF 了！！！！！！

我们设单块（一对黑白子）的 GF 为 $F(x,y)$，那么有：
$$F(x,y)=x^2\prod_{i=0}\sum_{j=0}^1x^{2^{ij}}y_i^j$$
我们知道有 $n-2k$ 个位置是空的，空格被黑白子分成了 $k+1$ 段，那么我们再设一个：
$$G(x)=\sum_{i=0}x^i=\frac{1}{1-x}$$
我们有：
$$H(x,y)=G^{k+1}(x)F^k(x,y)$$
答案是
$$[x^n]\sum_{d+1|t_i}[\prod y_i^{t_i}]H(x,y)$$
~~虽然看上去很奇怪，但是我们成功写成了 GF 的形式~~

我们先考虑 $F^k$ 是个什么鬼东西：
$$x^{2k}\prod_{i=0}(x^{2^i}y_i+1)^k$$
前面 $x^{2k}$ 可以直接丢掉了。
$$\prod_{i=0}(\sum_{j=0}^k\binom{k}{i}x^{j2^{i}}y_i^j)$$
$$H(x,y)=\frac{\prod_{i=0}(\sum_{j=0}^k\binom{k}{j}x^{j2^{i}}y_i^j)}{(1-x)^{k+1}}$$
$$ans=[x^{n-2k}]\sum_{d+1|t_i}[\prod y_i^{t_i}]H(x,y)$$
我们考虑一个很神秘的东西：对 GF 的指数进行 DP（？）

我们设一个 $F_n(x,y)=\prod_{i=0}^n(\sum_{j=0}^k\binom{k}{j}x^{j2^{i}}y_i^j)$。

再设一个 $dp[t][n]=[x^n(\sum_{d+1|t_i,i\leq k}\prod y_i^{t_i})]F_{t-1}(x,y)$。（这里 $t-1$ 是为了避免 $dp[0]$ 初始化有点麻烦）

我们似乎只需要求出 $dp[\lfloor\log n\rfloor][0\sim n-2k]$ 即可？

然后好像把这个序列卷上一个组合数序列就行了。

转移很明显，根据定义直接卷上去就完了。

复杂度是 $O(nk\log n)$，足以通过此题。
```cpp
#include<cstdio>
typedef unsigned ui;
const ui M=10005,mod=1e9+7;
ui n,d,k,C[55],g[M],dp[17][M];
inline ui pow(ui a,ui b){
	ui ans(1);for(;b;b>>=1,a=1ull*a*a%mod)if(b&1)ans=1ull*ans*a%mod;return ans;
}
inline ui binom(const ui&n,const ui&m){
	ui x(1),y(1),z(1);
	for(ui i=1;i<=n;++i)x=1ull*x*i%mod;
	for(ui i=1;i<=m;++i)y=1ull*y*i%mod;
	for(ui i=1;i<=n-m;++i)z=1ull*z*i%mod;
	return 1ull*x*pow(1ull*y*z%mod,mod-2)%mod;
}
signed main(){
	ui lgn(1),ans(0);
	g[0]=g[1]=1;C[0]=C[1]=1;dp[0][0]=1;
	scanf("%u%u%u",&n,&k,&d);++d;n-=k;k>>=1;
	while((1<<lgn)<=n)++lgn;--lgn;
	for(ui i=2;i<=n;++i)g[i]=1ull*(mod-mod/i)*g[mod%i]%mod;
	for(ui i=1;i<=n;++i)g[i]=1ull*g[i]*g[i-1]%mod*(k+i)%mod;
	for(ui i=2;i<=k;++i)C[i]=1ull*(mod-mod/i)*C[mod%i]%mod;
	for(ui i=1;i<=k;++i)C[i]=1ull*C[i]*C[i-1]%mod*(k-i+1)%mod;
	for(ui i=1;i<=lgn;++i){
		for(ui j=0;j<=n;++j){
			for(ui x=0;(x<<i-1)<=j&&x<=k;x+=d)dp[i][j]=(dp[i][j]+1ull*C[x]*dp[i-1][j-(x<<i-1)])%mod;
		}
	}
	for(ui i=0;i<=n;++i)ans=(ans+1ull*dp[lgn][i]*g[n-i])%mod;
	printf("%u",(mod+binom(n+(k<<1),k<<1)-ans)%mod);
}
```

---

## 作者：Felix72 (赞：1)

考虑如下 k-nim 模型：

> 有 $n$ 堆石子，每次可以从**至多 $k$ 堆**石子中任意取出石子，无法操作者失败。

有 nim 游戏的扩展定理：

先手必败当且仅当把所有石子数量写为二进制数，每一位都恰好有 $x(k + 1)$ 个数满足该位是 $1$（$x \in \mathbb{Z}$）。

**为方便讨论 $k + 1$ 的倍数，以下讨论的数域均 $\bmod (k + 1)$**。证明如下：

当处于先手必败状态时，一个人做操作至少改变 $1$ 位，而对于每一位满足该位是 $1$ 的数量绝对值至多改变 $k$ ，不可能仍为 $0$，因此必然进入先手必胜状态。

反之，我们重复找数量不等于 $0$ 的最高位，设这个数量是 $x$。如果有 $r$ 个数在当前位可以随便改，且这 $r$ 个数足够把 $x \to 0$（减去 $x$ 或者加上 $k - x$），就直接操作；否则再找其他当前位是 $1$ 的数。这一定能找到，因为至少有 $x$ 个这样的数，其中一些在 $r$ 个数里，剩下的就在外面。这样 $r$ 的值也会增加，且不超过 $k$。转到下一位继续做即可。

因此我们定义状态 $f_{cnt，0/1}$ 表示 $cnt$ 个石子满足先手必败/必胜的状态数，逐位背包就行了，复杂度是 $O(nk\log n)$。

```cpp
 /* NE_Cat 4.1 */
#include <bits/stdc++.h>
#define lowbit(x) ((x) & (-(x)))
using namespace std;

const int N = 20010, K = 110, mod = 1e9 + 7;
inline void Plus(long long &now, long long add) {now += add; while(now >= mod) now -= mod;}
int n, k, d; long long f[N][2], g[N][2], res;

long long fac[N], inv[N];
inline long long C(int n, int m)
{return fac[n] * inv[m] % mod * inv[n - m] % mod;}
inline long long qpow(long long a, long long b)
{
	long long res = 1;
	while(b) {if(b & 1) res = res * a % mod; b >>= 1, a = a * a % mod;}
	return res;
}
inline void init_math()
{
	fac[0] = inv[0] = 1;
	for(int i = 1; i <= 20000; ++i) fac[i] = fac[i - 1] * i % mod;
	inv[20000] = qpow(fac[20000], mod - 2);
	for(int i = 19999; i >= 1; --i) inv[i] = inv[i + 1] * (i + 1) % mod;
}

int main()
{
//	freopen("text.in", "r", stdin);
//	freopen("prog.out", "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	init_math();
	cin >> n >> k >> d; k /= 2;
	f[0][0] = 1;
	for(int i = 0; (1 << i) <= n; ++i)
	{
		memcpy(g, f, sizeof(g));
		memset(f, 0, sizeof(f));
		for(int j = n; j >= 0; --j)
		{
			for(int cnt = 0; cnt <= k && cnt * (1 << i) <= j; ++cnt)
			{
				if(cnt % (d + 1) == 0)
				{
					Plus(f[j][0], g[j - cnt * (1 << i)][0] * C(k, cnt) % mod);
					Plus(f[j][1], g[j - cnt * (1 << i)][1] * C(k, cnt) % mod);
				}
				else
				{
					Plus(f[j][1], (g[j - cnt * (1 << i)][0] + g[j - cnt * (1 << i)][1]) * C(k, cnt) % mod);
				}
			}
		}
	}
	for(int i = 0; i + 2 * k <= n; ++i)
		Plus(res, C(n - (i + 2 * k) + k, k) * f[i][1] % mod);
	cout << res << '\n';
	return 0;
}
/*

*/
```

---

## 作者：SalN (赞：1)

P2490

不妨 $k\gets \frac{k}{2}$，设白黑棋子间可以缩小的间隔分别为 $a_1,\dots a_k$，那么操作就是每次选择 $x\in[1,d]$ 个 $a$ 使其严格变小，不能操作的人失败。我没有力气和手段自己发明创造出来这个 $d-nim$ 问题的解法所以我选择介绍一下结论和证明。

用 $(x)_y$ 表示 $x$ 二进制下第 $y$ 位的值，我们声称 $\forall x,\sum_{i=1}^k(a_i)_x\mod{d+1}=0$ 的局面必败，反之，$\exists x,\sum_{i=1}^k(a_i)_x\mod{d+1}\neq 0$ 的局面必胜。注意到这是一个 DAG 上的游戏，那么能到达必败态的是必胜态，不能到达必败态的是必败态，我们可以证明这个。

+ 必胜态能到达必败态：注意到一个 $a$ 如果在一个二进制位 $1\to 0$，那么后面的位随便变化 $a$ 都是变小的。动态维护变化了的数的集合，按照二进制位从高到低考虑，在集合里面暂时随便额外加入当前位为 $1$ 的数直到没有这种数或者集合大小为 $d$，如果最后集合大小没有达到 $d$，当前位为 $1$ 的肯定都加进去了，那么随便选一些 $1\to 0$ 一定是够的，下面考虑集合大小是 $d$ 的情况，当前集合当前位为 $1$ 的使用 $1\to 0$ 肯定没有问题，当前集合当前位为 $0$ 的一定是以前在某一位下降过的所以使用 $0\to 1$ 肯定没有问题，设有 $d-x/x$ 个当前位为 $1/0$ 的，可以造成的影响区间显然是 $[-x,d-x]$，这个显然可以帮助这一位的和在 $\mod{d+1}$ 意义下碰到为 $0$ 的，最后再删除集合中从来没有下降过的数即可

+ 必败态不能到达必败态：$a_i$ 一位上的扰动一定在 $(-d,d)$ 之间，不能够到两边的 $0$，更不能全都是中间的 $0$

显然必败态数量更好考虑，不妨用总方案数 $\binom{n}{2k}$ 减去必败的方案数。然后就是要考虑怎么 dp 了，不妨按照二进制位来考虑，设 $f_{i,j}$ 表示考虑了二进制下 $(\infty,i]$ 位 $\sum a=j$ 的方案数，初始化显然是 $f_{\infty,0}=1$。转移的话考虑当前位使用了 $p$ 个 $1$，要求 $d+1|p,0\leq p\leq k$，转移有 $f_{i+1,j-2^i\times p}\times\binom{k}{p}\to f_{i,j}$，最后的答案显然是 $\sum_{i=1}^n f_{0,i}\times \binom{n-i-k}{k}$，组合数是插板来的。 

```cpp
#include<bits/stdc++.h>
#define int long long
#define up(i,l,r) for(int i=l; i<=r; ++i)
#define dn(i,r,l) for(int i=r; i>=l; --i)

using namespace std;

const int N=10005, M=15, P=1e9+7;

int n, k, d, f[M][N], Ans, mul[N], inv[N]; 

int C(int n,int m) {
	if(m<0||n<m) return 0;
	return mul[n]*inv[m]%P*inv[n-m]%P;
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	mul[0]=inv[0]=inv[1]=1;
	up(i,1,1e4) mul[i]=mul[i-1]*i%P;
	up(i,2,1e4) inv[i]=inv[P%i]*(P-P/i)%P;
	up(i,2,1e4) inv[i]=inv[i-1]*inv[i]%P;
	cin >> n >> k >> d, f[14][0]=1, Ans=C(n,k), k>>=1;
	dn(i,13,0) up(j,0,n) for(int p=0; p<=k; p+=d+1) {
		if(j-(1<<i)*p<0) continue;
		(f[i][j]+=f[i+1][j-(1<<i)*p]*C(k,p)%P)%=P;
	}
	up(i,0,n) (Ans-=f[0][i]*C(n-i-k,k)%P)%=P;
	cout << (Ans%P+P)%P << '\n';
	return 0; 
}
```

---

## 作者：lsj2009 (赞：1)

我们将第 $i$ 个黑色棋子和第 $i$ 个白色棋子间的空格数记作 $x_i$，则其实移动一次棋子相当于减小 $x_i$ 的值若干大小。

则原题的操作变为：

> 每次可以选择不大于 $d$ 个 $x_i$，将每个 $x_i$ 减小若干值。

第一反应是：这玩意和 Nim 游戏很像！则类似的，我们去考虑 A 的必胜/必败局面。

先给出结论：
- 当且仅当 $\forall k\in \mathtt{N}$ 满足 $\sum\limits_{i=1}^n [x_i 的第 k 位为 1]\equiv0\pmod{(d+1)}$ 时，先手必输（注：结论及其推导部分的 $n$ 表示黑白棋子的间隔数目，即题目中的 $\frac{k}{2}$）。

然后是证明：


1. 方便起见，设 $f(k)=\sum\limits_{i=1}^n [x_i 的第 k 位为 1]$。

2. 先考虑没有后继状态的情况：当 $x_1=x_2=\cdots=x_n=0$ 时，满足条件，先手必输。

3. 当 $\forall k\in \mathtt{N}$ 满足 $f(k) \equiv 0\pmod{(d+1)}$ 时，则我们要证明**对于任意**的后继状态均有 $\exist k\in \mathtt{N}$ 满足 $f(k) \not\equiv 0\pmod{(d+1)}$。因为我们必须要进行操作，所以必然 $\exist k'$ 使得 $f(k')$ 发生变化；而我们至多操作 $d$ 个 $x_i$，即 $f(k')$ 的变化程度不超过 $d$，所以 $f(k')$ 必然不再被 $d+1$ 整除。

4. 当 $\exist k\in \mathtt{N}$ 满足 $f(k) \not\equiv 0\pmod{(d+1)}$ 时，则我们要证明**存在某种**后继状态使得 $\forall k\in \mathtt{N}$ 满足 $f(k) \equiv 0\pmod{(d+1)}$。那么这样，我们将所有使得 $f(k) \not\equiv 0\pmod{(d+1)}$ 的 $f(k)$ 对应的多余的几个 $x_i$ 去减掉几个 $2^k$；这样，我们就构造出了一种方案。

QED.

然后我们就可以开始愉快得 dp 了。

由结论，我们去逐个按位考虑。设 $f_{i,j}$ 表示当前在枚举第 $i$ 位得值，而且 $\sum x_i=j$ 时的先手必败的方案总数。

因为我们要保证 $$f(k) \equiv 0\pmod{(d+1)}$$，所以不妨去枚举 $f(i)$ 的值，然后再随机分配到 $\frac{k}{2}$ 个 $x_i$ 上，所以得到转移方程：

$$f_{i+1,j+2^i\cdot p(d+1)}\gets f_{i+1,j+2^i\cdot p(d+1)}+f_{i,j}\cdot C_{\frac{k}{2}}^{p(d+1)}$$

。此处使用填表法，思路更加清晰。

然后我们去计算出所有先手必输的方案总数：又由于各个 $x_i$ 的位置不同也会产生不同的方案，所以我们还需要乘上各堆位置的方案总数，即我们要在除已经确定的 $n-i-\frac{k}{2}$ 外的位置上再额外选出 $\frac{k}{2}$ 个空（形象的，可以把前者中的 $\frac{k}{2}$ 看作黑子，把后者的 $\frac{k}{2}$ 看作白子）。即为

$$\sum\limits_{i=0}^{n-k} f_{s,i}\cdot C_{n-i-\frac{k}{2}}^{\frac{k}{2}}$$

。其中 $s$ 约为 $\lg n$ 级别（即所枚举的位的范围）。

然后最终拿总方案数 $C_n^k$ 去减掉上式即可。

---

## 作者：zifanwang (赞：0)

k-nim 博弈板子题。

注意到白子只能向右移，黑子只能向左，那么可以将每对相邻的 白-黑 子看作一堆石子，石子个数为中间的空格数。每次可以从 $1\sim d$ 个堆中取出若干石子。

考虑先手必胜的条件。将所有石子个数用二进制表示，那么一定存在一个 $i$ 满足所有石子个数二进制表示下的第 $i$ 位之和 $\bmod(d+1)\neq 0$。

于是可以按位 dp，记录当前总石子数，每次枚举这一位为 $1$ 的石子堆数，直接转移即可。

时间复杂度 $\mathcal O(nk\log n)$。

参考代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxn 10003
#define md 1000000007
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define rept(i,a,b) for(int i=(a);i<(b);++i)
#define drep(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
int n,m,k,f[15][mxn][2];
ll ans,C[mxn+53][53];
signed main(){
	cin>>n>>m>>k,n-=m,m>>=1,k=min(k,m);
	C[0][0]=1;
	rep(i,1,n+m){
		C[i][0]=1;
		rep(j,1,min(i,m))C[i][j]=(C[i-1][j-1]+C[i-1][j])%md;
	}
	f[14][0][0]=1;
	drep(i,13,0){
		rep(j,0,n)rept(x,0,2)if(f[i+1][j][x]){
			rep(c,0,m)if(j+(1<<i)*c<=n){
				f[i][j+(1<<i)*c][x||c%(k+1)]=(f[i][j+(1<<i)*c][x||c%(k+1)]+f[i+1][j][x]*C[m][c])%md;
			}
		}
	}
	rep(i,0,n)ans=(ans+f[0][i][1]*C[n-i+m][m])%md;
	cout<<ans;
	return 0;
}
```

---


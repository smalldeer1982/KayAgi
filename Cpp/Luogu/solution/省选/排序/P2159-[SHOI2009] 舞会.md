# [SHOI2009] 舞会

## 题目描述

OItown要举办了一年一度的超级舞会了，作为主办方的Constantine为了使今年的舞会规模空前，他邀请了许多他的好友和同学去。舞会那天，恰好来了n个男生n个女生。Constantine发现，一般情况下，舞伴之间，总是男伴总是比女伴长得高，不过，偶尔也是有特殊情况的。所以，Constantine现在想知道，如果把这2n个人恰好配成n对舞伴，有多少种搭配方法，而且他要求最多只有k对舞伴之间女伴比男伴高。现在，Constantine需要参加SHTSC的你帮助他算出这个答案，当然啦，他会先告诉你这2n个同学的身高。


## 说明/提示

评分
如果你的输出文件与标准答案完全相符，你将获得该测试点的全部分数，否则得零分。


N< = 200

K< = N

## 样例 #1

### 输入

```
3 0
178
188
176
168
178
170
```

### 输出

```
4```

# 题解

## 作者：Pine (赞：8)

# DP + 高精

首先本题需要写高精，~~恶心到爆~~。

现将男生、女生按照身高排序

考虑DP，用$f[i][j]$表示前i个女生中至少选j个配对比男生高，其余$i-j$个不限。

$f[i][j] = (f[i-1][j] + f[i-1][j-1] * (p - (j - 1))) * (n-i)!$

$p$表示一共有$p$个男生比前$i$个女生低

考虑用容斥得到前$i$个女生中有且仅有$j$个配对比男生高

然后累加$ans$即可

# 代码
```
#include <bits/stdc++.h>
#define R register
#define eps 1e-12
#define INF (1<<30)
#define LL long long
#define LINF (1ll<<60)
#define MM(x, y) memset(x, y, sizeof x)
#define Fo(i, x, y) for(R int i=x; i<=y; ++i)
#define Ro(i, x, y) for(R int i=x; i>=y; --i)
using namespace std;
template<typename T> inline T Max(R T x, R T y) {return x > y ? x : y;}
template<typename T> inline T Min(R T x, R T y) {return x < y ? x : y;}
template<typename T> inline void in(R T &x)
{
    static int ch; static bool flag;
    for(flag=false, ch=getchar(); ch<'0'||ch>'9'; ch=getchar()) flag |= ch=='-';
    for(x=0; ch>='0'&&ch<='9'; ch=getchar()) x = (x<<1) + (x<<3) + ch - '0';
    x = flag ? -x : x;
}
/*************************************Samle*************************************/
#define MD 100000000
int n, K, A[205], B[205];
struct Big{
    LL a[105];
    Big() {}
    Big(R int x)
    {
        MM(a, 0);
        while(x) a[++a[0]] = x%MD, x/=MD;
    }
    inline void print()
    {
        if(!a[0] || (a[0] == 1 && a[1] == 0)) 
        {
            puts("0");
        }
        else
        {
            printf("%lld", a[a[0]]);
            Ro(i, a[0]-1, 1) printf("%08lld", a[i]);
            puts("");
        }
    }
};
Big operator + (R Big x, R Big y)
{
    Big re; MM(re.a, 0); re.a[0] = Max(x.a[0], y.a[0]);
    Fo(i, 1, re.a[0]) re.a[i] = x.a[i] + y.a[i];
    Fo(i, 1, re.a[0]-1) if(re.a[i] >= MD) re.a[i+1] += re.a[i] / MD, re.a[i] %= MD;
    while(re.a[re.a[0]] >= MD) re.a[re.a[0]+1] = re.a[re.a[0]] / MD, re.a[re.a[0]] %= MD, ++re.a[0];
    return re;
}
Big operator -(R Big x, R Big y)
{
    R Big re; MM(re.a, 0); re.a[0] = x.a[0];
    Fo(i, 1, re.a[0])
    {
        re.a[i] = x.a[i] - y.a[i];
        if(re.a[i] < 0) re.a[i] += MD, x.a[i+1] -= 1;
    }
    while(!re.a[re.a[0]] && re.a[0]) --re.a[0];
    return re;
}
Big operator *(R Big x, R Big y)
{
    R Big re; MM(re.a, 0);
    Fo(i, 1, x.a[0]) Fo(j, 1, y.a[0]) re.a[i+j-1] += x.a[i] * y.a[j], re.a[i+j] += re.a[i+j-1] / MD, re.a[i+j-1] %= MD;
    re.a[0] = x.a[0] + y.a[0] - 1; re.a[0] = Max(re.a[0], 0ll);
    while(re.a[re.a[0]+1]) ++re.a[0], re.a[re.a[0]+1] = re.a[re.a[0]] / MD, re.a[re.a[0]] %= MD;
    return re;
}
Big operator *(R Big x, R int y)
{
    R Big re; MM(re.a, 0);
    Fo(i, 1, x.a[0]) re.a[i] += x.a[i] * y, re.a[i+1] += re.a[i] / MD, re.a[i] %= MD;
    re.a[0] = x.a[0];
    while(re.a[re.a[0]+1]) ++re.a[0], re.a[re.a[0]+1] = re.a[re.a[0]] / MD, re.a[re.a[0]] %= MD;
    return re;
}
Big f[201][201], C[201][201], bin[201];
int main()
{
	Big one; one.a[0] = one.a[1] = 1; 
	Big zero; zero.a[0]=1, zero.a[1] = 0;
    in(n); in(K); Fo(i, 1, n) in(A[i]); Fo(i, 1, n) in(B[i]);
    sort(A+1, A+n+1); sort(B+1, B+n+1);
    f[0][0] = one;
    for(R int i=1, j=0; i<=n; ++i)
    {
        while(B[i] > A[j+1] && j+1<=n) ++j;
        Fo(k, 0, i)
        {
            f[i][k] = f[i-1][k];
            if(j - (k-1) > 0) f[i][k] = f[i][k] + f[i-1][k-1] * (j - (k-1));
        }
    }
    bin[0] = one;
    Fo(i, 1, n) bin[i] = bin[i-1] * i;
    C[0][0] = one;
    Fo(i, 1, n) 
    {
        C[i][0] = one;
        Fo(j, 1, i)
        {
            C[i][j] = C[i-1][j] + C[i-1][j-1];
        }
    }
    Fo(i, 0, n) f[n][i] = f[n][i] * bin[n-i];
    Ro(i, n, 0) Fo(j, i+1, n) f[n][i] = f[n][i] - C[j][i] * f[n][j];
    Big ans; ans = zero;
    Fo(i, 0, K) ans = ans + f[n][i];
    ans.print();
    return 0;
}
```

---

## 作者：Tyher (赞：6)

### 好难……。

垃圾根本想不到容斥 ~~就只能蠢蠢的直接Dp了……。~~

不妨设$xi$表示男生，$yi$表示女生

一个匹配，我们理解为强制$x$不变，$y$随意交换得到排列

设$ Dp[i][j]$ 表示当前正在决策第$i$组男女，产生了$j$对  $y>x$的方案数量。




那么答案即为
$\sum_{1}^{k}Dp[n][j]$

### 考虑~~毒瘤~~的$Dp$转移

先分两种情况。

### 当前$xi>=yi$ 

 假设对于$i$之前的$j$，存在$xj>=yi$的部分有$S$个

那么着一些是可以随意交换的不会对$j$产生贡献 有

$Dp[i][j]+=S*Dp[i-1][j]$


假设对于之前已经决策过的$yk>=xk$ 有

$Dp[i][j]+=j*Dp[i-1][j]$

因为这一部分的数量时$j$个。

假设对于剩下的，满足$yk<xk<yi$的部分，他们的个数应当是所有减去前面两个的和，即为$i-j-S$，那么方程有

$ Dp[i][j]+=(i-s-c)*Dp[i-1][j-1]$

因为这一段的交换，有$yi>=xk$且$yk<=xi$，所以如果交换这个时候的$i$和$k$，一定会对$j$产生$1$的贡献

### 当前$xi<yi$

和上面差不多，也是分三种情况大力讨论……。

假设对于$i$之前的$j$，存在$yj>=xi$的部分有$T$个

那么着一些是可以随意交换的
#### 并且一定会对$j$产生贡献 有

$Dp[i][j]+=T*Dp[i-1][j-1]$


假设对于之前不符合决策要求的$xk>yk$ 有

$Dp[i][j]+=(i-j)*Dp[i-1][j-1]$

对于剩下那一段，满足$xi>=yk>=xk$的点，有

$Dp[i][j]+=(j-T)*Dp[i-1][j]$

#### 细节

首先，$S[i] ,T[i]$可以预处理，复杂度$O(n^2)$

然后，要打高精度

其实高精度的部分比较简单写两个重载运算符就好了，我打的高精度压了9位

$Dp$复杂度$O(n^2)$，总复杂度$O(n^3).$

```
#include<bits/stdc++.h>
#define rg register
#define il inline
#define N 211
#define __ 5001
#define inf 1000000000
#define int long long
using namespace std;
int n,K,x[N],y[N],S[N],T[N];
struct huge{
	int s[N<<1],len;
	void print(){
		printf("%lld",s[len]);
		for(rg int i=len-1;i>=1;--i)
			printf("%09lld",s[i]);
	}
}dp[N][N],ans,zero;
huge operator + (huge a,huge b){
	rg int len=max(a.len,b.len);
	huge NOW=zero;
	for(rg int i=1;i<=len;++i)
		NOW.s[i]=a.s[i]+b.s[i];
	for(rg int i=1;i<=len;++i)
		NOW.s[i+1]+=NOW.s[i]/inf,NOW.s[i]%=inf;
	while(NOW.s[len+1])len++,NOW.s[len+1]+=NOW.s[len]/inf,NOW.s[len]%=inf;
	NOW.len=len;
	return NOW;
}
huge operator * (int a,huge b){
	rg int len=b.len;
	huge NOW=zero;
	for(rg int i=1;i<=len;++i)
		NOW.s[i]=a*b.s[i];
	for(rg int i=1;i<=len;++i)
		NOW.s[i+1]+=NOW.s[i]/inf,NOW.s[i]%=inf;
	while(NOW.s[len+1])len++,NOW.s[len+1]+=NOW.s[len]/inf,NOW.s[len]%=inf;
	NOW.len=len;
	return NOW;
}
il void re(rg int &x);
main(){
	freopen("party.in","r",stdin);
	freopen("party.out","w",stdout);
	re(n),re(K);
	for(rg int i=1;i<=n;++i)re(x[i]);
	for(rg int i=1;i<=n;++i)re(y[i]);
	sort(x+1,x+n+1),sort(y+1,y+n+1);
	for(rg int i=1;i<=n;++i){
		for(rg int j=1;j<=i;++j)
			if(x[j]>=y[i])S[i]++;
		for(rg int j=1;j<=i;++j)
			if(y[j]>x[i])T[i]++;
	}
	dp[0][0].s[1]=1,dp[0][0].len=1;
	for(rg int i=1;i<=n;++i){
		if(x[i]>=y[i]){
			for(rg int c=0;c<=i;++c)
				dp[i][c]=dp[i][c]+(S[i]*dp[i-1][c]);
			
			for(rg int c=0;c<=i;++c)
				dp[i][c]=dp[i][c]+(c*dp[i-1][c]);
			for(rg int c=1;c<=i-S[i];++c){
				dp[i][c]=dp[i][c]+((i-S[i]-c+1)*dp[i-1][c-1]);
			}
		}
		else {
			for(rg int c=1;c<=i;++c){
				dp[i][c]=dp[i][c]+(T[i]*dp[i-1][c-1]);
				dp[i][c]=dp[i][c]+((i-c)*dp[i-1][c-1]);
			}
			for(rg int c=T[i];c<=i;++c){
				dp[i][c]=dp[i][c]+((c-T[i]+1)*dp[i-1][c]);// debug two hours.....
			}
		}
	}
	for(rg int c=0;c<=K;++c)ans=(ans+dp[n][c]);
	while(!ans.s[ans.len]&&ans.len)ans.len--;
	if(!ans.len)printf("0");
	else 	ans.print();
    return 0;
}
il void re(rg int &x){
    x=0;rg int w=1;char c=getchar();
    while((c<'0'||c>'9')&&c!='-')c=getchar();
    if(c=='-')w=-1,c=getchar();
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
    x*=w;
}
/*
  匹配关系是一个排列.
  dp[i][j]表示前i个人有j对的方案数量
  
*/

```





---

## 作者：Rui_R (赞：5)

不错的DP题。但是需要高精就很恶心……

[原题](https://www.luogu.com.cn/problem/P2159)

本文更像是对```Thyer```大佬题解的解释。因为我们的做法高度相似，但是```Thyer```大佬的题解不太详细，于是就有了此文。

观察数据范围，$n \le 200$，初步判断为 $n^3$ 的DP。但是注意到，没有模数。数数题没有模数……好家伙，需要高精，而高精巨大的常数就意味着不可能是 $n^3$ 的。

首先想到将男女按身高排序，得到一些优秀的性质。具体见后文。

然后，考虑固定男人的位置不变，接着把女人一个一个与男人配对。

那么，令 $dp[i][j]$ 表示考虑前 $i$ 个位置（也就是男人）与前 $i$ 个女人匹配，其中有 $j$ 组满足女伴高于男伴的方案数。

答案为 $\sum_{i=0}^k dp[n][i]$

尝试转移：

如果当前女人不高于男人：

1：当前女人不会使 $j$ 增加：

此时，当前女人可以放到任意满足男人身高大于等于当前女人身高的位置上，同时将该位置上的女人放到当前位置上，形成新的方案。

记满足这样要求的位置有 $Alpha$ 个。$O(n)$ 扫一遍就可以得到 $Alpha$。

或者，可以将当前女人放到任意原来就是女伴更高的位置。由于女人身高已经过排序，交换后“原来就是女伴更高的位置”仍然是女伴更高，而当前位置也仍然是男人不矮于女人。

满足这样要求的位置显然有 $j$ 个。

同时， $j$ 与 $Alpha$ 不可能有重叠部分。因为 $Alpha$ 的部分满足男人不矮于女人。

综上，对于 $dp[i][j]$ ，能使 $j$ 增加的位置有 $j+Alpha$ 个。

2：当前女人会使 $j$ 增加：

这个简单，用总位置数 $i$ 减掉上面的就好。

得到“当前女人不高于男人”的状态转移方程：

$$dp[i][j]=dp[i-1][j]\cdot (j+Alpha)+dp[i-1][j-1]\cdot(i-Alpha-(j-1))$$

那么如果当前女人高于男人：

1：当前女人不会使 $j$ 增加：

此时她无论放到哪里都会形成一组“女伴更高”的组合。（因为男人已经按身高排序）那么不会使 $j$ 增加就等于将一个原来女伴更高的组合中的女伴放到当前男人的位置，同时她不高于当前男人。

也就是“原来女伴更高的部分”减去高于当前男人的部分。

那么记之前的女伴中，高于当前男人的女人有 $Alpha$ 个，（显然她们都形成了“女伴更高”的组合），满足当前要求的位置就有 $j-Alpha$ 个。

2：当前女人会使 $j$ 增加：

用总位置数 $i$ 减掉上面的就好。

得到“当前女人高于男人”的状态转移方程：

$$dp[i][j]=dp[i-1][j]\cdot(j-Alpha)+dp[i-1][j-1]\cdot (i-((j-1)-Alpha))$$

由于 $dp[i][]$ 只会跟 $dp[i-1][]$ 有关，可以再用滚动数组优化空间。

如果对细节感到好奇，或者想白嫖高精的，见代码。

```
#include <bits/stdc++.h>
using namespace std;

const int maxn=205;

int n,k;int M[maxn],W[maxn];

struct Int{
	#define max_size (501)
	int val[max_size];int len;const int base=10;//压位的部分就先不管了
	Int(int _val=0){len=1;for(int i=0;i<max_size;i++) val[i]=0;*this=_val;}
	Int(const char s[max_size]){init(s);}
	Int(char s[max_size]){init(s);}
	int& operator[](const int id){return val[id];}
	void operator=(int _val){
		for(int i=0;i<=len;i++) val[i]=0;
		len=0;while(_val) val[++len]=_val%10,_val/=10;
	}
	void operator=(Int pos){
		*this=0;len=pos.len;
		for(int i=1;i<=len;i++) val[i]=pos.val[i];
	}
	void carry_bit(){
		for(int i=1;i<=len;i++){
			if(val[i]>9){
				val[i+1]+=val[i]/10;
				val[i]%=10;
				if(i==len) len++;
			}
		}
	}
	void eat_zero(){
		for(;!val[len]&&len>1;len--);
		if(!len) len=0,val[len]=0;
	}
	Int operator+(int _val){
		Int now=*this;now[1]+=_val;
		now.carry_bit();return now;
	}
	Int operator+(Int _val){
		Int now=*this;now.len=max(now.len,_val.len);
		for(int i=1;i<=_val.len;i++) now[i]+=_val[i];
		now.carry_bit();return now;
	}
	Int operator*(int _val){
		Int now=*this;
		for(int i=1;i<=len;i++) now[i]*=_val;
		now.carry_bit();return now;
	}
	Int operator*(Int _val){
		Int now;now.len=len+_val.len-1;
		for(int i=1;i<=now.len;i++){
			for(int j=1;j<=_val.len;j++){
				now[i+j-1]+=val[i]*_val[j];
			}
		}
		now.eat_zero();
		now.carry_bit();return now;
	}
	Int operator/(int _val){
		Int now=*this;
		for(int i=len;i>=1;i--){
			if(i) now[i-1]+=base*(now[i]%_val);
			now[i]/=_val;
		}
		now.eat_zero();return now;
	}
	bool operator<(Int _val)const{
		if(len!=_val.len) return len<_val.len;
		for(int i=len;i>=1;i--){
			if(val[i]!=_val[i]) return val[i]<_val[i];
		}
		return 0;
	}
	bool operator==(Int _val)const{
		if(len!=_val.len) return 0;
		for(int i=len;i>=1;i--){
			if(val[i]!=_val[i]) return 0;
		}
		return 1;
	}
	bool operator>(Int _val)const{
		if(len!=_val.len) return len>_val.len;
		for(int i=len;i>=1;i--){
			if(val[i]!=_val[i]) return val[i]>_val[i];
		}
		return 0;
	}
	bool operator<=(Int _val)const{return !(*this>_val);}
	bool operator>=(Int _val)const{return !(*this<_val);}
	void init(const char s[max_size]){
		len=0;int begin=0;
		for(int i=1;s[i]>='0'&&s[i]<='9';i++){
			if(!begin&&s[i]==48) continue;
			if(!begin){begin=i;}len++;
		}
		if(!begin){len=0,val[1]=0;return;}
		for(int i=1;i<=len;i++){
			val[i]=s[len-i+begin]-48;
		}
	}
	void operator=(const char s[max_size]){this->init(s);}
	void print(){
		eat_zero();if(!len) putchar(48);
		else for(int i=len;i>=1;i--) putchar(val[i]+48);
		putchar('\n');
	}
};

//这个高精板子并不太靠谱……并且不支持负数
//如果你还是想用的话，那我只能说：
//El Psy Congroo.

Int dp[2][maxn];

int main(){
	// freopen("P2159_1.in","r",stdin);
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%d",&M[i]);
	for(int i=1;i<=n;i++) scanf("%d",&W[i]);
	std::sort(M+1,M+n+1),std::sort(W+1,W+n+1);
	dp[0][0]=1;
	for(int i=1;i<=n;i++){
		int Alpha=0,Sg=i&1;
		for(int j=0;j<=i;j++) dp[Sg][j]=0;
		if(M[i]>=W[i]){
			for(int j=1;j<=i;j++) if(M[j]>=W[i]) Alpha++;
			for(int j=0;j<=i;j++)
			dp[Sg][j]=dp[!Sg][j]*(j+Alpha);
			for(int j=1;j<=i-Alpha;j++)
			dp[Sg][j]=(dp[Sg][j]+dp[!Sg][j-1]*(i-Alpha-(j-1)));
		}
		else{
			for(int j=1;j< i;j++) if(W[j]>M[i])  Alpha++;//注意不要取等号，因为这里Alpha统计的是在i之前的
			for(int j=1;j<=i;j++)
			dp[Sg][j]=dp[Sg][j]+dp[!Sg][j-1]*(i-((j-1)-Alpha));
			for(int j=Alpha;j<=i;j++)
			dp[Sg][j]=dp[Sg][j]+dp[!Sg][j]*(j-Alpha);
		}
	}
	Int answer=0;
	for(int i=0;i<=k;i++) answer=answer+dp[n&1][i];
	answer.print();
	return 0;
}

```

---

## 作者：wyd_forever (赞：3)

### $first$  
  
看到数据范围应该都会多多少少有点思路了，要搞一个大概是$n^3$的$dp$，可是貌似最多的方案数是$200!$级别的，计算器一算发现是$6e600+$，于是要套高精。所以之前的$n^3$排除，将注意力放在$n^2-n^2logn$，可$logn$这种奇怪的复杂度怎么会无缘无故出现在一个$n<=200$的题目？于是果断考虑$n^2dp$  
  
$n^2$都知道什么意思吧，就是设置两个状态的$dp$方程  
  
### $second$  
  
首先应当想到先排序，因为当身高有序后才能方便找出比某一女生矮的男生有多少，以方便进行$dp$计算  
  
### $third$  
  
考虑设置$dp$方程$f_{i,j}$表示当前遍历到第$i$矮的女生，我们已经匹配了$j$对，并且$j$对全是女大于男的方案数，这样的话$dp$方程可以比较快地得到  
  
考虑将第$i$个女生与比第$i$个女生矮而**不矮于**第$i-1$个女生的一众男生（设人数为$p$）一起加入$f_{i,j}$的更新  
  
那么$f_{i,j}$首先肯定无条件继承$f_{i-1,j}$的值，而当$p>j-1$时表明我们可以再已经有$j-1$对的基础上再扩展一对女大于男的舞伴，并且扩展的这一对有$p-(j-1)$种方案，那么$f_{i,j}$就需要加上$f_{i-1,j-1} * (p-j+1)$  
  
### $forth$  
  
但是$f_{n,j}$还是不能帮我们解决问题，嗯  
  
但已经接近尾声了，考虑设置$g_j$表示选完所有对，而其中至少有$j$对的方案数，那么~~显然~~$g_j=f_{n,j} * (n-j)!$（因为剩下$n-j$对没有要求，那么就是全排列嘛）  
  
得到了$g_j$数组后就很容易想到容斥得到答案了（容斥系数自己可以瞎搞搞出来）：  
  
$$ans=\sum_{i=0}^{k}\sum_{j=i}^{n}(-1)^{j-i}* C_j^i * g_j$$  
  
### $fifth$  
  
最后一点小注，本篇题解是对该题第一篇题解的一点补充，代码实现思路几乎相同。但由于彼题解有些许瑕疵（也可能是我太蒟蒻）导致没有怎么看懂，后来仔细推敲代码并手搞式子才有了以上这些想法，担心会有和我一样的小菜鸡（应该不会吧）对于首篇的做法有迷惑，于是作此题解来造(bao)福(fu)人(she)类(hui)  
  
### $sixth$  
  
代码（代码中的$f_{i,j}$是用的滚动数组，没算$g_j$而是直接代入$ans$公式，若还有不懂欢迎私信）：  
  
```cpp  
#include<bits/stdc++.h>
using namespace std;

#define ll long long

inline int read()
{
	int x=0,f=1;char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar()) f=ch=='-'?-1:1;
	for(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);
	return x*f;
}

const int xx=2e2+10,xd=100;
const int digit=1e9;

int m[xx],wm[xx],n,k;

struct Big
{
	ll a[xd];
	inline void print()
	{
		for(register int i=a[0];i;--i)
		{
			if(i!=a[0])
				for(register int j=1e8;j>=10;j/=10)
					a[i]<j?putchar('0'):j=1;
			printf("%d",a[i]);
		}
		puts(""); 
	}
}zero,one,fac[xx],f[2][xx],C[xx][xx];
Big ans;
Big operator * (Big x,Big y)
{
	Big tmp=zero;tmp.a[0]=x.a[0]+y.a[0];
	for(register int i=1;i<=x.a[0];++i)
		for(register int j=1;j<=y.a[0];++j)
		{
			tmp.a[i+j-1]+=x.a[i]*y.a[j];
			if(tmp.a[i+j-1]>=digit)
			{
				tmp.a[i+j]+=tmp.a[i+j-1]/digit;
				tmp.a[i+j-1]%=digit;
			}
		}
	while(!tmp.a[tmp.a[0]]&&tmp.a[0]>1)
		--tmp.a[0];
	return tmp;
}
Big operator * (int x,Big y)
{
	Big tmp=zero;tmp.a[0]=y.a[0]+1;
	for(register int i=1;i<=y.a[0];++i)
	{
		tmp.a[i]+=x*y.a[i];
		if(tmp.a[i]>=digit)
		{
			tmp.a[i+1]+=tmp.a[i]/digit;
			tmp.a[i]%=digit;
		}
	}
	while(!tmp.a[tmp.a[0]]&&tmp.a[0]>1)
		--tmp.a[0];
	return tmp;
}
Big operator + (Big x,Big y)
{
	Big tmp=zero;tmp.a[0]=max(x.a[0],y.a[0])+1;
	for(register int i=1;i<=tmp.a[0]-1;++i)
	{
		tmp.a[i]+=(x.a[i]+y.a[i]);
		if(tmp.a[i]>=digit)
		{
			tmp.a[i+1]+=tmp.a[i]/digit;
			tmp.a[i]%=digit;
		}
	}
	while(!tmp.a[tmp.a[0]]&&tmp.a[0]>1)
		--tmp.a[0];
	return tmp;
}
Big operator - (Big x,Big y)
{
	Big tmp=zero;tmp.a[0]=x.a[0];
	for(register int i=1;i<=x.a[0];++i)
	{
		tmp.a[i]=x.a[i]-y.a[i];
		if(tmp.a[i]<0)
		{
			tmp.a[i]+=digit;
			--x.a[i+1];
		}
	}
	while(!tmp.a[tmp.a[0]]&&tmp.a[0]>1)
		--tmp.a[0];
	return tmp;
}

inline void pre()
{
	memset(zero.a,0,sizeof(zero.a));
	zero.a[0]=one.a[0]=one.a[1]=1;
	for(register int i=0;i<=n;++i)
		C[i][0]=one;
	for(register int i=1;i<=n;++i)
		for(register int j=1;j<=n;++j)
			C[i][j]=C[i-1][j]+C[i-1][j-1];
	for(register int i=0;i<=1;++i)
		for(register int j=1;j<=n;++j)
			f[i][j]=zero;
	fac[0]=one;
	for(register int i=1;i<=n;++i)
		fac[i]=i*fac[i-1];
	f[0][0]=f[1][0]=one;
}

int main()
{
	n=read(),k=read(),pre();
	for(register int i=1;i<=n;++i) m[i]=read();
	for(register int i=1;i<=n;++i) wm[i]=read();
	sort(m+1,m+n+1),sort(wm+1,wm+n+1);
	for(register int i=1,K=0;i<=n;++i)
	{
		while(K<n&&m[K+1]<wm[i])
			++K;
		for(register int j=1;j<=i;++j)
		{
			if(K>j-1)
				f[i&1][j]=(K-j+1)*f[(i-1)&1][j-1];
			f[i&1][j]=f[i&1][j]+f[(i-1)&1][j];
		}
	}
	ans=zero;
	for(register int i=0;i<=k;++i)
		for(register int j=i;j<=n;j+=2)
			ans=ans+(f[n&1][j]*fac[n-j]*C[j][i]);
	for(register int i=0;i<=k;++i)
		for(register int j=i+1;j<=n;j+=2)
			ans=ans-(f[n&1][j]*fac[n-j]*C[j][i]);
	ans.print();
	return 0;
}
```

---

## 作者：2021hych (赞：1)

# 题意化简
两个长度为 $n$ 的序列 $B$，$G$。对于一种最大二分图匹配，记它的代价为：满足 $B_i<G_j$ 的匹配边 $(i,j)$ 的数量。求代价不超过 $k$ 的匹配方案。

题意化繁？
# 题解
一眼组合计数，考虑到 $k$ 很小，我们完全可以枚举代价是多少，问题转化为：求出代价恰好为 $k$ 的方案数。

首先，匹配满足集合的无序性，所以我们将两个数组从小到大排序再求解是没有本质区别的。这样做可以把贡献代价的匹配边形成一段连续的区间。

由于是二分图匹配，乍一看不好 DP。我们尝试利用二项式反演，将恰好转钦定。

按照序列 DP 的状态设计方式，记 $dp_{i,j}$ 表示右部点集为 $G$ 的前 $i$ 个元素，钦定 $j$ 个点所在的匹配边对代价有贡献，注意，我们只统计钦定的点的匹配方案。

那么 $dp_{i,j}$ 来源于：不钦定 $G_i$，方案数为 $dp_{i-1,j}$。钦定 $G_i$，方案数为 $dp_{i-1,j-1} \times (cnt-(j-1))$。其中 $cnt$ 表示对于 $G_i$ 可贡献的左部点的数量，由于使二分图匹配，要减去已经钦定的。

加上特判的情况，整理一下得到：

$$dp_{i,0}=dp_{i-1,0}$$

$$dp_{i,i}=dp_{i-1,i-1} \times \max(0,cnt-i+1)$$ 

$$dp_{i,j}=dp_{i-1,j}+dp_{i-1,j-1} \times \max(0,cnt-j+1)(0<j<i)$$

$$dp_{1,0}=1$$

$$dp_{1,1}=cnt$$

当然了，由于排过序了，转移的时候只要向右移动指针就能求出当前的 $cnt$ 了。

现在记 $g_i$ 表示对于右部点集为所有 $G$ 的元素，钦定 $i$ 个点所在的匹配边对代价有贡献的最大匹配方案数。这里我们要用乘法原理计入未钦定点的匹配方案，显然的：

$$g_i=dp_{n,i} \times (n-i)!$$

记 $f_i$ 表示代价为 $i$ 的最大匹配数量。这是就是二项式反演的形式了：

$$g_i=\sum\limits_{j=i}^n \dbinom{j}{i}f_j$$

$$f_i=\sum\limits_{j=i}^n (-1)^{j-i}\dbinom{j}{i}g_j$$

答案为：

$$\sum\limits_{i=0}^k f_i$$

但是没有取模，所以我们需要高精度。我写了一个常数巨大的，所以要 O2。

实现上：为了防止出现高精度负数的情况，我们先把反演后式子里符号为正的先统计，再去减。

时间复杂度主要花在 $dp$ 数组的计算上：$O(n^2)$。
# AC code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=210;
int n,k,B[N],G[N],cnt; 
struct BigInteger {
	static const int BASE=1e8;
	static const int WIDTH=8;
	vector<int>s;
	BigInteger(int num=0) {*this=num;}
	BigInteger operator = (int num) {
		s.clear();
		do {
			s.push_back(num%BASE),num/=BASE;
		}while(num>0);
		return *this;
	}
	BigInteger operator + (const BigInteger& b) const {
		BigInteger c;
		c.s.clear();
		for(int i=0,g=0;;i++) {
			if(g==0&&i>=s.size()&&i>=b.s.size()) break;
			int x=g;
			if(i<s.size()) x+=s[i];
			if(i<b.s.size()) x+=b.s[i];
			c.s.push_back(x%BASE);
			g=x/BASE;
		}
		while(c.s.size()!=1&&c.s[c.s.size()-1]==0) c.s.pop_back();
		return c;
	}
	BigInteger operator - (const BigInteger& b) const {
		BigInteger c;
		c.s.clear();
		for(int i=0,g=0;;i++) {
			if(g==0&&i>=s.size()&&i>=b.s.size()) break;
			int x=-g;
			if(i<s.size()) x+=s[i];
			if(i<b.s.size()) x-=b.s[i];
			g=0;
			while(x<0) g++,x+=BASE;
			c.s.push_back(x);
		}
		while(c.s.size()!=1&&c.s[c.s.size()-1]==0) c.s.pop_back();
		return c;
	}
	BigInteger operator * (const BigInteger& b) const{
		BigInteger c;
		c.s.clear();
		for(int i=0;i<b.s.size();i++) {
			BigInteger d;
			d.s.clear();
			for(int j=0;j<i;j++) d.s.push_back(0);
			for(int j=0,g=0;;j++) {
				if(g==0&&j>=s.size()) break;
				int x=g;
				if(j<s.size()) x+=s[j]*b.s[i];
				d.s.push_back(x%BASE);
				g=x/BASE;
			}
			c=c+d;
		}
		while(c.s.size()!=1&&c.s[c.s.size()-1]==0) c.s.pop_back();
		return c;
	}
	BigInteger operator * (int num) {
		BigInteger c;
		c.s.clear();
		for(int i=0,g=0;;i++) {
			if(g==0&&i>=s.size()) break;
			int x=g;
			if(i<s.size()) x+=s[i]*num;
			c.s.push_back(x%BASE);
			g=x/BASE;
		}
		while(c.s.size()!=1&&c.s[c.s.size()-1]==0) c.s.pop_back();
		return c;
	}
	friend ostream& operator << (ostream& out,const BigInteger& x) {
		out<<x.s.back();
		for(int i=x.s.size()-2;i>=0;i--) {
			char buf[20];
			sprintf(buf,"%08d",x.s[i]);
			for(int j=0;j<strlen(buf);j++) out<<buf[j];
		}
		return out;
	}
}dp[N][N],C[N][N],fact[N],g[N],zans,fans,ans,GG,HH;
void init() {
	for(int i=0;i<=n;i++) C[i][0]=1,C[i][i]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<i;j++) C[i][j]=C[i-1][j-1]+C[i-1][j];	
	fact[0]=1;
	for(int i=1;i<=n;i++) fact[i]=fact[i-1]*i;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k;
	init();
	for(int i=1;i<=n;i++) cin>>B[i];
	for(int i=1;i<=n;i++) cin>>G[i];
	sort(B+1,B+n+1);
	sort(G+1,G+n+1);
	dp[1][0]=1;
	while(G[1]>B[cnt+1]&&cnt+1<=n) cnt++;
	dp[1][1]=cnt;
	cnt=(G[1]>B[1]);
	for(int i=2;i<=n;i++) {
		while(G[i]>B[cnt+1]&&cnt+1<=n) cnt++;
		dp[i][0]=dp[i-1][0];
		dp[i][i]=dp[i-1][i-1]*max(0ll,cnt-i+1);
		for(int j=1;j<i;j++) dp[i][j]=dp[i-1][j]+dp[i-1][j-1]*max(0ll,cnt-j+1);
	}
	for(int i=0;i<=n;i++) g[i]=dp[n][i]*fact[n-i];
	fans=0;
	zans=0;
	for(int i=0;i<=k;i++)
		for(int j=i;j<=n;j++) {
			if((j-i)&1) fans=fans+C[j][i]*g[j];
			else zans=zans+C[j][i]*g[j];
		}
	ans=zans-fans;
	cout<<ans;
	return 0;
}

```


---


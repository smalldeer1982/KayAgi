# [ZJOI2012] 灾难

## 题目背景

阿米巴是小强的好朋友。

阿米巴和小强在草原上捉蚂蚱。小强突然想，如果蚂蚱被他们捉灭绝了，那么吃蚂蚱的小鸟就会饿死，而捕食小鸟的猛禽也会跟着灭绝，从而引发一系列的生态灾难。

学过生物的阿米巴告诉小强，草原是一个极其稳定的生态系统。如果蚂蚱灭绝了，小鸟照样可以吃别的虫子，所以一个物种的灭绝并不一定会引发重大的灾难。

## 题目描述

我们现在从专业一点的角度来看这个问题。我们用一种叫做食物网的有向图来描述生物之间的关系：

- 一个食物网有 $n$ 个点，代表 $n$ 种生物，生物从 $1$ 到 $n$ 编号。
- 如果生物 $x$ 可以吃生物 $y$，那么从 $y$ 向 $x$ 连一个有向边。
- 这个图没有环。
- 图中有一些点没有连出边，这些点代表的生物都是生产者，可以通过光合作用来生存。
- 而有连出边的点代表的都是消费者，它们必须通过吃其他生物来生存。
- 如果某个消费者的所有食物都灭绝了，它会跟着灭绝。

我们定义一个生物在食物网中的“灾难值”为，如果它突然灭绝，那么会跟着一起灭绝的生物的种数。

举个例子：在一个草场上，生物之间的关系如下

![](https://cdn.luogu.com.cn/upload/image_hosting/oiw4lh97.png)

如果小强和阿米巴把草原上所有的羊都给吓死了，那么狼会因为没有食物而灭绝，而小强和阿米巴可以通过吃牛、牛可以通过吃草来生存下去。所以，羊的灾难值是 $1$。但是，如果草突然灭绝，那么整个草原上的 $5$ 种生物都无法幸免，所以，草的灾难值是 $4$。

给定一个食物网，你要求出每个生物的灾难值。

## 说明/提示

### 样例 1 解释

样例输入描述了题目描述中举的例子。

### 数据规模与约定

- 对于 $50\%$ 的数据，保证 $n \leq 10^4$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 65534$，$1 \leq a_{i, j} \leq n$，输入的文件大小不超过 1 MB，且图上不存在环。

## 样例 #1

### 输入

```
5
0
1 0
1 0
2 3 0
2 0
```

### 输出

```
4
1
0
0
0```

# 题解

## 作者：llzzxx712 (赞：115)

#  P2597[灾难]
[更好的阅读体验](https://www.luogu.com.cn/blog/llzzxx712/solution-p2597)

**2020.9.18 Update:修改了代码里的入队一个小 bug**

## 题目简述
- 输入一个有向森林
- 灾难值：在一个节点被删去后以它为根从上到下逐步删去入度为0的点，最终被删去的点的数量即其灾难值
- 你需要输出每个点的灾难值

比如看样例（一个食物网应该是由食物指向捕食者，在存边时要反向存）![](https://cdn.luogu.com.cn/upload/image_hosting/gysi7omu.png)

1节点被删去后2、3节点入度变为0被删去，接着4、5节点入度变为0被删去，一共4个点被删去，所以它的灾难值是4.

2被删去会使5节点入度为0被删去，所以它的灾难值为1。剩下几个点被删去都不会产生入度为0的点，他们灾难值为0

## 题目分析
### **下面内容来自《中学生计算机程序设计提高篇》**（有删减）

对于生产者，不妨给它添加一个假想的食物——太阳。那么这个森林就变成了一颗“灭绝树”。

首先，按照食物网从猎物到捕食者的顺序拓扑排序，有且仅有太阳没有任何入度，所以先将太阳加入灭绝树，之后，依次考虑每个生物 $i$ ,依次考虑构建好排序在 $i$ 之前的生物组成的灭绝树，假设$i$ 的食物有 $p_1,p_2,p_3,\cdots,p_k$(这些节点在拓扑序中比 $i$靠前，$i$ 会灭绝，当且仅当$p_1,p_2,p_3,\cdots,p_k$全部灭绝，当且仅当LCA（$p_1,p_2,p_3,\cdots,p_k$）灭绝。

于是可以在树上加上LCA到$i$ 的边，把$i$ 的边加到树中。处理完后就得到了灭绝树，每个生物的灾难值就是以它为根的子树大小减一


------------
### 下面是自己的详细理解和对上面的补充
感觉书中说的并不是非常清楚，至少我在设计思路和完成代码时遇到了很多问题（WA了10次的痛）

本题中的LCA和普通LCA有一些差别，1是它是多节点的LCA，再者它是要一边建树一边LCA。而且本题中涉及原树（食物网）和新树（灭绝树），书中没有说在哪里求LCA，如何倍增。

我想到的一种求LCA的方法是：**更新迭代LCA**

其思路是：给每个数多维护一个值$dad$,用来表示如果此时它要被连入灭绝树中，它应该是哪个点的儿子。一开始**将$dad$清为-1**，将开始**入度为0的点 $p_i$ 的$dad$设为0**（太阳）。在拓扑排序取出一个点$i$的时候连接边 $dad[i]->i$ (此时$i$的父亲（根节点的父亲前面已经确定）都已经被处理过了，所以$dad[i]$已经确定（怎么确定的马上会说））。然后更新点$i$相对应的**深度和倍增数组**（因为$i$的祖先们已经在$i$之前被确定，所以此时的深度和其倍增数组可以唯一确定），接着遍历$i$的儿子们，如果它的儿子$p$的父亲$dad[p]$为0，说明它的父亲还没有被更新过，此时把$dad[p]$更新为$i$。否则就将$dad[p]$更新为LCA（$dad[p],i$）。这样，在遍历到$p$的时候它的父节点就被确定下来了。

**为什么能这样做呢？**

我们需要在求出在原树上$i$的所有父亲的LCA，就相当于把两个父亲当成一组，一组一组地求LCA，并把这个过程转移到一个点遍历其儿子的时候。

## 思路总结
1. 初始化$dad$数组为-1。
1. 读入原树，反向建立森林并统计每个点的入度。
1. 扫描所有点，将入度为0的点加入队列中，并将其$dad$更新为0。
1. 拓扑排序，取出队首$x$，连接$dad[x],x$,并更新倍增数组和该点深度。遍历$x$的儿子，更新儿子的$dad$并将儿子的入度减一，若入度为0则入队。
1. 重复操作4，直到队列为空。
1. $dfs$一次新树，并递归求子树大小。
1. 输出每个点子树减一

## 易错点
- 原树是一个有向无环森林，亲测存边数组大小20w能过
- 倍增数组在根节点再往上是0（如果把太阳设为-1节点就会WA第五个点）
- 存原树时要反向存
- 倍增深度16
- 原树和新树的查询小心弄混
- 输出时子树大小要减一

## 代码实现

```cpp
#include<bits/stdc++.h>
#define N 65536
using namespace std;
int n,tot,ans,tot1;
int to[N*4],ne[N*4],head[N];//原树邻接表 
int edge[N],anc[N][21],dad[N],size[N],de[N];// 入度、倍增、父亲、子树大小、深度 
int to1[N*4],ne1[N*4],head1[N];//新树邻接表 
void add(int x,int y) { to[++tot]=y,ne[tot]=head[x],head[x]=tot,edge[y]++; }//存原树 
void add1(int x,int y) { to1[++tot1]=y,ne1[tot1]=head1[x],head1[x]=tot1;}//存新树 
queue < int > q;//STL队列 
void dfs(int x){//深搜求子树大小 
    size[x]=1;
    for(int i=head1[x];i;i=ne1[i]){
        int y=to1[i];
        dfs(y);
        size[x]+=size[y];
    } 
}
int lca(int x,int y){//求LCA 
    if(x==y) return x;
    if(de[x]<de[y]) swap(x,y);
    for(int i=18;i>=0;i--) if(de[anc[x][i]]>=de[y]) x=anc[x][i];
    if(x==y) return x;
    for(int i=18;i>=0;i--) if(anc[x][i]!=anc[y][i]) x=anc[x][i],y=anc[y][i];
    return anc[x][0];
}
void read(int &x) {//快读 
    int f = 1; x = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9')   {if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    x *= f;
}
int main()
{
    read(n);
    for(int i=1;i<N;i++) dad[i]=-1;//初始化 
    for(int i=1;i<=n;i++){
        int x;
        read(x);
        while(x){
            add(x,i);//反向存树 
            read(x);
        }
    }
    for(int i=1;i<=n;i++) 
        if(!edge[i]){
            q.push(i);
            dad[i]=0;//找到入度为0的边 
        }
    while(!q.empty()){
        int x;
        x=q.front();q.pop();//取出队首  
        add1(dad[x],x);
        anc[x][0]=dad[x],de[x]=de[dad[x]]+1;        
        for(int i=1;i<=18;i++) anc[x][i]=anc[anc[x][i-1]][i-1];//更新倍增数组 
        for(int i=head[x];i;i=ne[i]){
            int y=to[i];
            if(dad[y]==-1) dad[y]=x;//父亲之前没有被更新 
            else dad[y]=lca(dad[y],x);//父亲之前已经被更新过 
            if(--edge[y]==0) q.push(y);//入度为0则入队 
        }
    }
    dfs(0);//求子树大小 
    for(int i=1;i<=n;i++)
        printf("%d\n",size[i]-1);//输出 
    return 0;
}
	
```

**写题解不易，给个赞呗**



---

## 作者：Lance1ot (赞：72)

$QAQ$，人生第一道紫题

我觉得还是只讲讲思路吧。毕竟我的代码太丑了。

先来看样例
![1](http://images.cnblogs.com/cnblogs_com/Lance1ot/1199055/o_1.jpg)

这里为什么要反向存图呢？因为高级捕食者要捕食低级捕食者（生产者）。如果所有指向他的点（低级捕食者）都没了。他也肯定会死。

然后接着下看。

如果我们只用赤果果的topsort+递推。节点4（下同）就会卡掉你。

我们怎么改进呢？

我们可以将节点4复制一份~~影分身！~~ 再利用边的有向性。建一颗树。

如图

![2](http://images.cnblogs.com/cnblogs_com/Lance1ot/1199055/o_3.jpg)

这样的话我们就将问题转换为求以 节点x 为根的子树的节点的个数，再去一个重。

可是这样的话，最难的问题就变成了去重。

我们先等一等。再想一想4和4* 的性质只有节点1死了。4才会死尽。

而节点1是什么呢？是4和4* 的最近公共祖先。

![3](http://images.cnblogs.com/cnblogs_com/Lance1ot/1199055/o_4.jpg)

我们可以利用一个类似并查集的思想，舍弃一些信息。使维护起来更加方便。

而这些信息。对于我们就不需要了。我们只关心i没了以后j是否会没。

就像这个样子

[![4](http://images.cnblogs.com/cnblogs_com/Lance1ot/1199055/o_5.jpg)](http://www.cnblogs.com/Lance1ot/)

我们再回看样例

![1](http://images.cnblogs.com/cnblogs_com/Lance1ot/1199055/o_1.jpg)

我们在topsort建树中，扫描到了4。
根据我们之前找的道理。我们需要找**他们**的最近公共祖先并且链上去。

一个很简单的性质。对于样例，我们只需要找出2,3（就是在我们第2个图没有缩点之前中4和4* 的父亲，图2是我们为了理解的一个过程的树），就是所有指向他的节点在我们以及建好了的树中（无影分身版）的lca。

最终，最后一个在coding中的问题也解决了。

代码还是看楼下大佬吧

---

## 作者：Refun (赞：30)

感谢zhhe0101学长orz的耐心讲解

我太菜了听了好久才懂

不过这个题的做法的确是十分精妙的

大体分三步：1、拓扑排序2、建树3、求树的前缀和 

1、我们知道，一个生物死亡的条件是他的所有食物全部死亡

   而且既然这个题说了没有环，那么就可以保证食物链等级鲜明 
   
   那么求这种图，我们很容易就可以想到拓扑排序了
   
2、我们建一棵树，让father[x]为x的父亲，意味着若father[x]死了，那么x则灭绝

   问题来了，x应该挂在哪个点上？
   
   当然是他所有食物的LCA上啊！
   
   若LCA死了，x的食物也会都死亡，那么x也必然死亡
   
	 建树这里可以将出度为0的点连在一个虚拟点n+1上方便处理 
     
3、最后DFS求一下树的前缀和

	 因为若x死了，那么他的子树会全部死亡，那么他的重要度就是子树大小-1（去除本身） 
     
     
最后附样例转树的图（学长给我画的）

5 →2 →1 

	↗  ↗ 
    
4 →3 


------------


		6 
 		↓ 
		1 
	  ↙↓↘ 
	 2  3  4 
 ↙
 
5 

[代码](http://www.cnblogs.com/refun/p/8678431.html)的题解可能排版更好一点

---

## 作者：jyz666 (赞：21)

# [P2597 [ZJOI2012]灾难]

[传送门](https://www.luogu.com.cn/problem/P2597)

###  前言

感谢 [lzx](https://www.luogu.com.cn/blog/llzzxx712/solution-p2597#) 巨佬。

这道题在我AC之前，这位巨佬和我已经讨论了一个礼拜。

~~多亏他的无数次WA与TLE~~ 我们最终想出了正解。

## 题目分析

首先先要建一个有向森林。

我们再想，如果这条食物链是一棵树。

但样例的图片一看就知道题目并没有那么简单~~毕竟是一道紫题~~。

如果你想由一个点灭绝来推导，那么恭喜，你走入了一条死路。

反过来想，一个点灭绝原因。

发现，一个点灭绝的前提是，所有前驱都灭绝。

一次只能灭绝一个。

如果前驱多个的话，显然灭绝一个该点不会灭绝。

所以，继续找前驱的前驱。

直到前驱变成一个点$P$。那么，就相当于，这个点灭绝了，开始说的点$X$才会灭绝。

如果我们构造出来一个树，那么这个$P$就是$X$的所有前驱的$LCA$

找到所有前驱的$LCA$，直接把$X$作为$LCA$的儿子连上去。就构造出来了这个树。

其实，就是最近的可以灭绝后灭绝$X$的点。

那它每个节点的灾难值就是它的子树大小$-1$。

**但是** 也会出现一个生物吃两个生产者的情况，这时$LCA$便会出现$BUG$，就需要建一个超级原点$ROOT$，把所有入度为0的点（根）都接上去，就可以用$LCA$了。

root不参与答案统计。如果连向root的点，无论如何不会因为某个物种灭绝而灭绝。（因为多于一个前驱必须自己死）

上代码：
```cpp
#include<bits/stdc++.h>
#define res register int
#define maxn 500010
using namespace std;
void read(int &x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9')   {if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    x *= f;
}
struct node{int to,nxt;};
node edge[maxn<<1],edge2[maxn<<1];int indegree[maxn],dad[maxn];
int head[maxn],head2[maxn],m,n,root,dep[maxn],fa[maxn][30],num,sum,siz[maxn],topo[maxn];
void add1(int a,int b){edge[++num].to=b;edge[num].nxt=head[a];head[a]=num;indegree[b]++;}
void add2(int a,int b){edge2[++num].to=b;edge2[num].nxt=head2[a];head2[a]=num;}
int lca(int u,int v){
	if(dep[u]<dep[v]) swap(u,v);
	for(res i=20;i>=0;--i)if(dep[fa[u][i]]>=dep[v]) u=fa[u][i];
	if(u==v) return u;
	for(res i=20;i>=0;--i)if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];
	return fa[u][0];
}
void get_siz(int x){//求子树大小 
	for(res i=head2[x];i!=-1;i=edge2[i].nxt){
		int y=edge2[i].to;get_siz(y);siz[x]+=siz[y];
	}
}
void topsort()
{
	memset(dad,-1,sizeof(dad));
	queue< int > q;
    for(int i=1;i<=n;i++) if(!indegree[i])q.push(i),dad[i]=0;
    while(!q.empty())
    {
        int temp=q.front();q.pop();
        add2(dad[temp],temp);dep[temp]=dep[dad[temp]]+1;
        fa[temp][0]=dad[temp];
        for(int i=1;i<=16;i++)fa[temp][i]=fa[fa[temp][i-1]][i-1];
        for(int p=head[temp];p!=-1;p=edge[p].nxt)
        {
            int v=edge[p].to;
            if(dad[v]==-1) dad[v]=temp;
            else dad[v]=lca(dad[v],temp);
            indegree[v]--;
			if(!indegree[v])q.push(v);
			
        }
    }
}
int main(){
	read(n);
	memset(head,-1,sizeof(head));
	memset(indegree,0,sizeof(indegree));
    for(int i=1,x;i<=n;i++){//节点数 
		while(1){
        	read(x);
        	if(!x) break;
        	add1(x,i);
		}
    }
    siz[0]=dep[0]=0;memset(head2,-1,sizeof(head2));
    topsort();get_siz(0);
    for(int i=1;i<=n;i++)printf("%d\n",siz[i]-1);
	return 0;
}
```
## 总结

突破口就是想到转化成树比较好处理。然后考虑一个物种是怎么灭绝的。

发现，一个物种灭绝，只要找到最近的可以让它灭绝的物种Y即可。所有能让Y灭绝的物种也能让X灭绝。

而一个物种灭绝后，可能影响到多个物种也灭绝。

一个点，一个前驱，多个后继。

这就是树形结构！！

根据其他巨佬的题解，原来这还是DAG的支配树

所以其实是模板题。（惊了！）

~~求点赞~~


---

## 作者：wwyx2001 (赞：10)

其实第一遍已经A了。。。。但是！但是！手滑的错误不要犯了好嘛。。。。

依次考虑每个生物i：假设我们已经构建好了排序在i之前的生物组成的“灭绝树”了。

假设i的食物有x[0]~x[k]（x[0]~x[k]在拓扑排序中比i靠前），

很显然，只有x[0]~x[k]在树上的公共祖先的灭绝会导致i灭绝，否则i一定可以找到能让它活下来的食物。

于是，我们可以把i挂在x[0]~x[k]的最近公共祖先下面。

处理完所有的生物，我们得到的树就是整个图的灭绝树了。之后dfs计算一下每个节点对应的子树大小，子树大小-1即危险程度

一个可爱的地方<http://blog.csdn.net/blue\_cuso4/article/details/77968467>

```cpp
#include <cstdio>  
#include <queue>  
#include <cstring>  
#include <iostream>  
#define sz 31  
#define N 65540  
using namespace std;  
int tot,nxt[N*4],point[N*4],v[N*4],tot1,nxt1[N*4],point1[N*4],v1[N*4],tot2,nxt2[N*4],point2[N*4],v2[N*4],n,in[N],ran[N],h[N];  
int f[N][sz],ans[N];  
void addline(int x,int y){++tot; nxt[tot]=point[x]; point[x]=tot; v[tot]=y;}  
void addline1(int x,int y){++tot1; nxt1[tot1]=point1[x]; point1[x]=tot1; v1[tot1]=y;}  
void addline2(int x,int y){++tot2; nxt2[tot2]=point2[x]; point2[x]=tot2; v2[tot2]=y;}  
void topsort()  
{  
    queue<int>q;  
    for (int i=1;i<=n;i++)  
      if (!in[i]) q.push(i);  
    int num=0;  
    while (!q.empty())  
    {  
        int now=q.front(); q.pop();  
        ran[++num]=now;  
        for (int i=point[now];i;i=nxt[i])  
        {  
            in[v[i]]--;  
            if (!in[v[i]]) q.push(v[i]);  
        }  
    }   
}  
int lca(int x,int y)  
{  
    if (h[x]<h[y]) swap(x,y);  
    int k=h[x]-h[y];  
    for (int i=0;i<sz;i++)  
      if ((k>>i)&1) x=f[x][i];  
    if (x==y) return x;  
    for (int i=sz-1;i>=0;i--)  
      if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];  
    return f[x][0];  
}  
void dfs(int now)  
{  
    for (int i=point2[now];i;i=nxt2[i])  
      {  
          dfs(v2[i]);  
          ans[now]+=ans[v2[i]];  
      }  
    ans[now]++;  
}  
int main()  
{  
    int i,j;  
    scanf("%d",&n);  
    for (i=1;i<=n;i++)  
    {  
        int x;  
        scanf("%d",&x);  
        while (x) {in[i]++;addline1(i,x);addline(x,i);scanf("%d",&x);}  
    }  
    topsort();  
    for (i=1;i<=n;i++)  
    {  
        int x=v1[point1[ran[i]]];  
        for (j=point1[ran[i]];j;j=nxt1[j])  
          x=lca(x,v1[j]);  
        addline2(x,ran[i]);  
        h[ran[i]]=h[x]+1;  
        f[ran[i]][0]=x;  
        for (j=1;j<sz;j++) f[ran[i]][j]=f[f[ran[i]][j-1]][j-1];  
    }  
    dfs(0);  
    for (i=1;i<=n;i++) printf("%d\n",ans[i]-1);  
}
```

---

## 作者：VenusM1nT (赞：8)

灭绝树。这道题应该可以算是灭绝树的模板题，我们在求出灭绝树后从 $0$ 做一遍 $\text{DFS}$ 求出到每个结点的前缀和，输出时 $-1$ （即去除它本身）即可。

那么怎样构造一棵灭绝树呢？首先可以明确，这道题构成的图是一个 $\text{DAG}$，所以可以使用 拓扑排序+$\text{LCA}$ 的方法构造，流程如下：

 1. 先对图拓扑排序，求出拓扑序
 2. 按拓扑序处理，求出当前节点在 $\text{DAG}$ 上**所有出点**在当前灭绝树上的 $\text{LCA}$，作为当前点在灭绝树上的**父亲**。这一点可以通过建**反图**来求出。
 
至于为什么要从 $0$ 开始 $\text{DFS}$，因为构造灭绝树到第一个点的时候，灭绝树上没有结点，它所有出点的 $\text{LCA}$ 必然是 $0$，所以它的父亲就是 $0$，从 $0$ 开始 $\text{DFS}$。

具体原因我就不分析了，一时半会儿说不清楚，讲稿还是挺多的。

```cpp
#include<bits/stdc++.h>
#define MAXN 100005
using namespace std;
queue <int> q;
int cnt[3],fst[3][MAXN<<1],nxt[3][MAXN<<1],to[3][MAXN<<1];
int n,top[MAXN],ind[MAXN],f[MAXN][25],dep[MAXN],ans[MAXN];
void AddEdge(int u,int v,int id)
{
	to[id][++cnt[id]]=v;
	nxt[id][cnt[id]]=fst[id][u];
	fst[id][u]=cnt[id];
}
void TopoSort()//拓扑排序
{
	for(int i=1;i<=n;i++) if(!ind[i]) q.push(i);
	int tot=0;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		top[++tot]=u;
		for(int i=fst[0][u];i;i=nxt[0][i])
		{
			int v=to[0][i];
			ind[v]--;
			if(!ind[v]) q.push(v);
		}
	}
}
int LCA(int x,int y)//求LCA
{
	if(dep[x]>dep[y]) swap(x,y);
	for(int i=20;i>=0;i--) if(dep[f[y][i]]>=dep[x]) y=f[y][i];
	if(x==y) return x;
	for(int i=20;i>=0;i--)
	{
		if(f[x][i]!=f[y][i])
		{
			x=f[x][i];
			y=f[y][i];
		}
	}
	return f[x][0];
}
void Dfs(int u)//求前缀和
{
	for(int i=fst[2][u];i;i=nxt[2][i])
	{
		int v=to[2][i];
		Dfs(v);
		ans[u]+=ans[v];
	}
	ans[u]++;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int x;
		while(1)
		{
			scanf("%d",&x);
			if(!x) break;
			ind[i]++;
			AddEdge(x,i,0);//正图
			AddEdge(i,x,1);//反图
		}
	}
	TopoSort();
	for(int i=1;i<=n;i++)//建灭绝树
	{
		int lca=to[1][fst[1][top[i]]];
		for(int j=fst[1][top[i]];j;j=nxt[1][j])
		{
			int v=to[1][j];
			lca=LCA(lca,v);
		}
		AddEdge(lca,top[i],2);
		dep[top[i]]=dep[lca]+1;
		f[top[i]][0]=lca;
		for(int j=1;j<=20;j++) f[top[i]][j]=f[f[top[i]][j-1]][j-1];
	}
	Dfs(0);
	for(int i=1;i<=n;i++) printf("%d\n",ans[i]-1);
	return 0;
}
```

---

## 作者：UnyieldingTrilobite (赞：5)

算法就是最典的那个，每个点在支配树上的父亲是前驱在支配树上的 LCA。直接把正常图的算法搬过来是能用的，或者 LCT 也不是不能做，但我们希望能用最简单的算法解决它。鉴于这是一篇题解，我们会首先介绍一下这个东西。

---

首先我们考虑把给定的捕食关系按照食物向捕食者的方向连边，同时从虚拟源点（太阳，$0$）向所有没有食物的点连边。这样整个图依然是一个 DAG，且生物 $x$ 灭绝导致生物 $y$ 当且仅当从 $0$ 到 $y$ 的每条路径都经过 $x$。这是显然的。对于这样的关系，我们称生物 $y$ 支配生物 $x$。不难发现，只有当 $y$ 能走到 $x$ 时，$y$ 有可能支配 $x$，且 $0$ 能支配任何其他点。

不难发现，对于点 $x,y,z$，若 $x$ 支配 $z$，$y$ 能走到 $z$，且这三个点的拓扑序递增，则一定有 $x$ 支配 $y$。证明就是一定不能存在一条太阳到 $y$ 然后 $y$ 到 $z$ 的路不经过 $x$，而根据 DAG 上路径拓扑序的单调性第二段一定不会出现 $x$。

如此一来，对于一个节点 $x$，找到拓扑序最大的支配其的点 $y$。根据上面的性质，$y$ 的拓扑序一定小于 $x$，且对于任意其他支配 $x$ 的点 $z$，一定有 $z$ 支配 $y$。不难发现，如果从 $y$ 向 $x$ 连边，这实际上构成了一棵以 $0$ 为根的树，称之为“支配树”，而我们要求的即为每个点在支配树上的子树大小。

由于支配树的父子有拓扑偏序关系，我们考虑将节点按拓扑序从小到大排序。假设我们现在要处理点 $x$ 并找到其在支配树上的父亲 $y$，考虑 $x$ 的任一前驱 $z$，则若 $y$ 的拓扑序小于 $z$，其一定支配 $z$；等于 $z$，其一定就是 $z$；大于 $z$，由于存在 $0$ 到 $z$ 到 $x$ 的路径，其不符合支配的定义。换而言之，这样的 $y$ 一定是每个 $z$ 在支配树上的祖先。在此前提下，由于 $y$ 支配（或等于）了 $x$ 的每个前驱，不难发现其一定也支配 $x$，于是这个条件是充要的。由于我们要找拓扑序最大的 $y$，只需要对所有这些前驱求 LCA 即可。复杂度 $O(n\log n)$。

---

不难发现我们需要支持的是给一棵树动态加叶子和查 LCA，这是倍增的经典问题，使用 <https://return20071007.blog.uoj.ac/blog/8981/> 中提到的神秘东西改写即可。

代码在这篇东西发出来之前是最优解。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int S = 1 << 21, N = 65535;
char buf[S], *p1, *p2, obuf[S], *O = obuf;
inline char gc() {
  if (p1 == p2) {
    p2 = (p1 = buf) + cin.read(buf, S).gcount();
    if (p1 == p2) return EOF;
  }
  return *p1++;
}
inline int rd() {
  char ch;
  while (!isdigit(ch = gc()))
    ;
  int x = ch & 0xf;
  while (isdigit(ch = gc())) x = x * 10 + (ch & 0xf);
  return x;
}
inline void prtln(int x) {
  char s[7];
  int t = 0;
  if (!x)
    *O++ = '0';
  else {
    while (x) s[t++] = x % 10 | '0', x /= 10;
    while (t) *O++ = s[--t];
  }
  *O++ = '\n';
}
basic_string<int> es[N];
int n, fa[N], d[N], lb[N], dg[N], sz[N];
inline void lca(int& u, int v) {
  if (!~u) return u = v, void();
  if (d[u] < d[v]) swap(u, v);
  while (d[u] > d[v]) d[lb[u]] < d[v] ? (u = fa[u]) : (u = lb[u]);
  while (u != v)
    lb[u] == lb[v] ? (u = fa[u], v = fa[v]) : (u = lb[u], v = lb[v]);
}
inline void addf(int x) {
  int p = fa[x], q = lb[p], r = lb[q];
  d[x] = d[p] + 1, lb[x] = d[p] - d[q] != d[q] - d[r] ? p : r;
}
inline void build() {
  memset(fa + 1, -1, n * sizeof(int));
  int q[N], l = 0, r = 0, u;
  for (int i = 1; i <= n; ++i)
    if (!dg[i]) fa[q[r++] = i] = 0, d[i] = 1;
  while (l < r)
    for (addf(u = q[l++]); int v : es[u])
      if (lca(fa[v], u), !--dg[v]) q[r++] = v;
  while (r--)
    if (int f = fa[u = q[r]]) sz[f] += sz[u] + 1;
}
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  n = rd();
  for (int i = 1; i <= n; ++i)
    while (int j = rd()) es[j].push_back(i), ++dg[i];
  build(), for_each_n(sz + 1, n, prtln);
  return cout.write(obuf, O - obuf).flush(), 0;
}
```

---

## 作者：Mrnobody (赞：5)

1：n <= 3k 可以逆拓扑序，对每个点求一遍

2：n <= 2 \*short ， 显然这样不行，但是这题和拓扑排序的关系很紧密，考虑利用拓扑序来优化这个过程

3：（这里要构造一下），一种生物的灭绝的原因是它的所有食物的灭绝，这样递归下去所有生物会聚到一个点上，很像LCA

4：那么怎么找到这个LCA呢，得自己建一颗树

5：我们将一个点直接性灭绝后会引发灭绝的生物作为它的子树，那么lca可以直接倍增求出，动态维护下稀疏表即可









```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n , root , rd[N];
int dep[N] , fa[N][20] , siz[N];
vector<int> top[N] , food[N] , newe[N];
int lca(int a , int b)
{
    if(dep[a] < dep[b]) swap(a , b);
    for(int i = 18; i >= 0; i--)
        if(dep[a] - (1 << i) >= dep[b])
            a = fa[a][i];
    if(a == b) return a;
    for(int i = 18; i >= 0; i--)
        if(fa[a][i] != fa[b][i])
            a = fa[a][i] , b = fa[b][i];
    return fa[a][0];
}
void solve(int x)    /*对x点建边*/
{
    int t = food[x][0];
    for(int i = 1; i < (int) food[x].size(); i++) {
        t = lca(t , food[x][i]);
    }
    newe[t].push_back(x);
    dep[x] = dep[t] + 1;
    fa[x][0] = t;
    for(int j = 1; j <= 18; j++)
        if(fa[x][j - 1]) fa[x][j] = fa[fa[x][j-1]][j-1];
}
void top_sort()
{
    for(int i = 1; i <= n; i++) 
        if(!rd[i]) 
        {
            top[0].push_back(i); 
            food[i].push_back(0);     
        }
    queue<int> q;
    q.push(0); 
    while(!q.empty())
    {
        int x = q.front();
        q.pop();
        for(int i = 0; i < (int) top[x].size(); i++) {
            int y = top[x][i];
            if(--rd[y] <= 0) {
                q.push(y);
                solve(y); 
            }
        }
    }
}
void dfs(int x)
{
    siz[x] = 1;
    for(int i = 0; i < (int) newe[x].size(); i++) {
        dfs(newe[x][i]);
        siz[x] += siz[newe[x][i]];
    }
}
int main()
{
    scanf("%d", &n);
    for(int i = 1, x; i <= n; i++) {
        while(scanf("%d", &x) && x) {
            top[x].push_back(i);
            rd[i]++; 
            food[i].push_back(x);
        }
    }
    top_sort();
    dfs(root);
    for(int i = 1; i <= n; i++) printf("%d\n", siz[i] - 1);
    return 0;
}

```

---

## 作者：黑客 (赞：4)

# P2597 [ZJOI2012]灾难

### 开头语

这次修改了几个小 $BUG$ 和没有解释清楚的地方。

好不容易写道紫题，具体解法是听了 $dalao$ 的思路，琢磨了半天，也 $WA$ 了很多次之后才摸索出来的。

------------

### 思路

首先，我们要知道，一个生物灭绝的条件是什么？是这个生物所有的食物都灭绝。

假设一个生物 $A$，$A$ 灭绝的是因为其食物全部灭绝。那么，如果这是一种生物 $B$ 的灭绝造成的（因为题目是说某一种生物灭绝造成的影响），那么 $B$ 必然是 $A$ 的所有食物的共同食物，否则 $B$ 的灭绝不可能导致 $A$ 的灭绝（因为 $A$ 还可以以其他没有灭绝的食物为食）。

也就是把所有的生产者用“太阳”连在一起（把森林连成一棵树），从“太阳”走到某点 $A$ 的路径中必须经过的点（简称为必经点）中离 $A$ 最近的点 $B$（最近必经点），如果 $B$ 灭绝了，$A$ 也一定会灭绝。必经点必然是 $A$ 的父亲节点（其食物）的公共祖先，而最近必经点就是其父亲节点的最近公共祖先。

然后我们找到每个点的最近必经点，连上一条边，组成一颗新树（根为“太阳”），每个节点的子树大小就是这个生物的灾难值。

最后一个小小的但很重要的点，就是要一边求 $LCA$ 一边修改这棵老树。

嗯，换句话来说，就是因为这是一张食物网，所以可能会出现这种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/hmr56v1e.png)

也就是 $C$ 吃 $B$ 和 $A$,但是 $B$ 又吃 $A$ ，这样做 $LCA$ 时会出现 $BUG$ ，所以我们可以求得 $C$ 的最近必经点，将 $C$ 的所有食物整合为一个点，也就是最近必经点，所以我们要求得最近必经点后再更新。 

------------

### 实现

知道思路之后，考虑怎么实现。首先，我们要做一遍 $TopSort$，得到这些生物的拓扑顺序，以便在找最近必经点时最近必经点已经连在新树上了。然后我们再用 $LCA$ 求得最近必经点，然后建树。最后用 $DFS$ 求得子树大小。

------------

### 代码

```
#include<bits/stdc++.h>
using namespace std;
#define N 65544
int n,cnt1=0,cnt2=0,cnt3=0,h1[N],h2[N],h3[N],sum[N],total[N],size[N],fa[N][30],d[N];
queue<int>q;
struct edge{
	int v,nxt;
}e1[500010],e2[500010],e3[500010];
void add1(int u,int v){
	e1[++cnt1]=(edge){v,h1[u]};
	h1[u]=cnt1;
}
void add2(int u,int v){
	e2[++cnt2]=(edge){v,h2[u]};
	h2[u]=cnt2;
}
void add3(int u,int v){
	e3[++cnt3]=(edge){v,h3[u]};
	h3[u]=cnt3;
}
void get_date(int x){
	while(1){
		int y;
		scanf("%d",&y);
		if(y==0)break;
		add1(y,x);
		add2(x,y);
		sum[x]++;
	}
	if(sum[x]==0){
		q.push(x);
		add2(x,0);
	}
}
void top_sort(){
	for(int i=1;i<=n;i++){
		int k=q.front();
		q.pop();
		total[i]=k;
		for(int j=h1[k];j;j=e1[j].nxt){
			sum[e1[j].v]--;
			if(sum[e1[j].v]==0)q.push(e1[j].v);
		}
	}
}
int LCA(int u,int v){
	if(d[u]<d[v])swap(u,v);
	for(int i=20;i>=0;i--){
		if(d[fa[u][i]]>=d[v])u=fa[u][i];
	}
	if(u==v)return u;
	for(int i=20;i>=0;i--){
		if(fa[u][i]!=fa[v][i])u=fa[u][i],v=fa[v][i];
	}
	return fa[u][0];
}
void update(int x,int fx){
	fa[x][0]=fx;
	d[x]=d[fx]+1;
	for(int i=1;(1<<i)<=d[x];i++){
		fa[x][i]=fa[fa[x][i-1]][i-1];
	}
}
void get_size(int x){
	size[x]=1;
	for(int i=h3[x];i;i=e3[i].nxt){
		get_size(e3[i].v);
		size[x]+=size[e3[i].v];
	}
	return;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		get_date(i);
	}
	top_sort();
	d[0]=1;
	for(int i=1;i<=n;i++){
		int k=total[i];
		int fp=e2[h2[k]].v;
		for(int j=e2[h2[k]].nxt;j;j=e2[j].nxt){
			fp=LCA(fp,e2[j].v);
		}
		update(k,fp);
		add3(fp,k);
	}
	get_size(0);
	for(int i=1;i<=n;i++){
		printf("%d\n",size[i]-1);
	}
} 
```
------------

### 结束语

### 祝大家切紫题快乐！

------------

# 黑客出品

---

## 作者：破壁人 (赞：4)

这道题作为一道省选题，初看无从下手，但是要是能找到一棵树，使得一旦某个节点被毁灭则它的子树全都被毁灭问题就简单了许多。

因为这样的话就可以对每个节点求一个树上前缀和就行了。

那么问题来了如何建树呢。一个结点被毁灭当且仅当它的所有食物都毁灭了，而所有食物都被毁灭当且仅当他们的LCA被毁灭，因此我们把每个节点都连接在它的所有食物的LCA上，即每个节点的父节点是它的所有食物的LCA。

当然了这样逐步建树的前提条件是把某个节点加入树中时它的所有食物已经都在树中了，那么如何满足这个条件呢？

其实很明显，按吃与被吃的关系建立一张有向图（食物向消费者连一条有向边）按照拓扑排序顺序加点就行了。

至此问题已经完美解决。








```cpp
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<iostream>
using namespace std;
vector<int> a[100001],shi[100001],son[100001];
queue<int> ling;
int ru[100001],fa[100001][20],deep[100001],ans[100001];
int LCA(int aa,int bb)//用倍增法求LCA
{
    if(deep[aa]>deep[bb]) swap(aa,bb);
    int ff=deep[bb]-deep[aa];
    for(int i=0;(1<<i)<=ff;i++)
        if((1<<i)&ff)
            bb=fa[bb][i];
    if(aa!=bb)
    {
        for(int i=18;i>=0;i--)
            if(fa[aa][i]!=fa[bb][i])
            {
                aa=fa[aa][i];
                bb=fa[bb][i];
            }
        aa=fa[aa][0];
    }
    return aa;
}
void dfs(int o)//树上前缀和
{
    if(son[o].empty()) {ans[o]=1;return;}
    for(int i=0;i<son[o].size();i++)
    {
        if(ans[son[o][i]]==0) dfs(son[o][i]);
        ans[o]+=ans[son[o][i]];
    }
    ans[o]++;
}
int main()
{
    int n;
    cin>>n;
    memset(ru,0,sizeof(ru));
    for(int i=1;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        while(x!=0)
        {
            a[x].push_back(i);
            ru[i]++;
            shi[i].push_back(x);
            scanf("%d",&x);
        }
    }
    memset(fa,0,sizeof(fa));
    memset(deep,0,sizeof(deep));
    deep[70000]=1;
    for(int i=1;i<=n;i++)
        if(ru[i]==0) 
        {
            ling.push(i);
            shi[i].push_back(70000);
        }
    while(!ling.empty())//拓扑排序（同时加点）
    {
        int yu=ling.front();
        ling.pop();
        int lca=shi[yu][0];
        if(shi[yu].size()!=1)
            for(int i=1;i<shi[yu].size();i++)
                lca=LCA(lca,shi[yu][i]);//把每个节点都连接在它的所有食物的LCA上
        deep[yu]=deep[lca]+1;//新加入节点的深度
        fa[yu][0]=lca;
        son[lca].push_back(yu);
        for(int i=1;i<=18;i++)//更新新加入节点的倍增数组
            if(fa[yu][i-1])
                fa[yu][i]=fa[fa[yu][i-1]][i-1];
        for(int i=0;i<a[yu].size();i++)
        {
            ru[a[yu][i]]--;
            if(ru[a[yu][i]]==0) ling.push(a[yu][i]);
        }
    }
    memset(ans,0,sizeof(ans));
    dfs(70000);//求树上前缀和
    for(int i=1;i<=n;i++) cout<<(ans[i]-1)<<endl;
    return 0;
}
```

---

## 作者：Jμdge (赞：4)

这么多年了，第一次没抄题解（但还是看了自己的板子）然后 1 A 了

留下了幸福的泪水...

-----

江一下大致思路：

1. 首先看出这道题是支配树

怎么看出来的?~~（显然啊）~~ 【雾

>我们看到删除某个点后，对于任意一个**原先有入度**的点说，如果因此没有入度，那么它就**死**了，并且**删除与它相连的边**，然后**重复迭代**以上步骤直到没有点**死**去

>然后我们江边反向然后观察可以发现：如果说删除了一个点后某个点无法连向原图中无入度的点（注意是原图中的入度，反图中就是出度），那么它就**死**了

其实对于**死**的定义就是支配树中的 **被支配** 了

那么我们要算的就是**一个点能够支配的点数**，然后此题中自己不算支配自己，答案要-1

关于支配树的学习点[这里](https://www.luogu.org/problemnew/show/P5180)
，题解里面江得很详细

于是这道题非常 **明了** 了

2. 剩下的问题就是如何处理：原图中有**多个点没入度**的情况

>因为某个点会死的前提是它无法到达**原图中任意一个无入度的点**，所以我们考虑建一个点，向 **原图中所有无入度的点** 连一条边,这样一来问题就能解决了

这不是网络流的思路么（小声说）

3. 默默敲代码

```
//by Judge
#include<cstdio>
#include<iostream>
using namespace std;
const int M=7e4+7;
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(int x,char chr='\n'){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=chr;
} int n,pat,tim,head[M],pre[M],las[M],cdy[M];
int dfn[M],id[M],du[M],fa[M],bel[M];
int val[M],sdom[M],idom[M],siz[M];
struct Edge{ int to,nxt; }e[M<<3];
inline void add(int* h,int x,int y){
	e[++pat]=(Edge){y,h[x]},h[x]=pat;
}
#define v e[i].to
void dfs(int u){ dfn[u]=++tim,id[tim]=u;
	for(int i=head[u];i;i=e[i].nxt)
		if(!dfn[v]) fa[v]=u,dfs(v);
}
inline int Min(int a,int b){
	return dfn[sdom[a]]<dfn[sdom[b]]?a:b;
}
inline int find(int x){
	if(x==bel[x]) return x; int rt=find(bel[x]);
	return val[x]=Min(val[bel[x]],val[x]),bel[x]=rt;
}
inline void tarjan(){
	for(int j=tim,u;j>1;--j){ u=id[j];
		for(int i=pre[u];i;i=e[i].nxt)
			find(v),sdom[u]=sdom[Min(u,val[v])];
		add(las,sdom[u],u),bel[u]=fa[u],u=fa[u];
		for(int i=las[u];i;i=e[i].nxt)
			find(v),idom[v]=sdom[val[v]]^u?val[v]:u;
	}
	for(int i=2,u;i<=tim;++i) u=id[i],
		idom[u]=idom[idom[u]^sdom[u]?idom[u]:u];
}
inline void calc(int u){ siz[u]=1;
	for(int i=cdy[u];i;i=e[i].nxt)
		calc(v),siz[u]+=siz[v];
}
int main(){
#ifdef Judge
	freopen("1.in","r",stdin);
#endif
	n=read();
	for(int i=1,k;i<=n;++i)
		for(k=read();k;k=read(),++du[i])
			add(head,k,i),add(pre,i,k);
	for(int i=1;i<=n+1;++i)
		val[i]=bel[i]=sdom[i]=i;
	for(int i=1;i<=n;++i) if(!du[i])
		add(head,n+1,i),add(pre,i,n+1);
	dfs(n+1),tarjan(),pat=0;
	for(int i=1;i<=n;++i) if(idom[i])
		add(cdy,idom[i],i); calc(n+1);
	for(int i=1;i<=n;++i) print(siz[i]-1);
	return Ot(),0;
}
```



---

## 作者：MikukuOvO (赞：2)

考虑到食物网的结构没法直接统计答案，我们试着转化一下。

考虑一个点如果要死的彻底，那么他就不能有任何的食物，也就是他的所有父亲节点必须全部死掉。

那么我们发现如果要让一个点集全部死掉，只要满足死掉的点在这个点集的$lca$到根的路径上即可，我们就可以将该点直接连到$lca$上。

这样我们按照拓扑序建图，然后每个点的权值就是子树大小。

[$code$](https://pastebin.com/B8LS5Xcc)

---

## 作者：GUO大侠 (赞：2)

ps:该题解有借鉴 @Mrnobody 的题解.

---- 
- 若把生产者看做topo起点,遍历整张图,会发现计算一个点能影响到的点比较麻烦,不如计算被影响到的点对它上级的贡献;      
由题意,灭绝是有骨牌效应的,考虑按拓扑序建树,计算对上级的贡献的方法可以dfs上级再求子树的后缀和(说白了就是求子树大小).   
   
- 又由题意得:一个生物灭绝是因为他的食物全部灭绝,那么这个点的父亲一定是它所有食物的食物(或者本身),就像树上的lca.所以建树就是连一条$(Upreys.lca)->(u)$的边  

- 注意,必须等到u的入度为0方可查询lca,这样才能保证所有lca的祖先已经被处理.

----

代码:

```
#include<bits/stdc++.h>
#define _ 565535
using namespace std;
int n,rd[_],A[_],dep[_],st[_][21];
vector<int>prey[_],Top[_],tr[_];
int get_lca(int a,int b){
	if(dep[a]<dep[b])swap(a,b);
	for(int i=20;~i;--i)if(dep[st[a][i]]>=dep[b])a=st[a][i];
	if(a==b)return a;
	for(int i=20;~i;--i)if(st[a][i]!=st[b][i])a=st[a][i],b=st[b][i];
	return st[a][0];
}
void solve(int x){
	int lca=prey[x][0];
	for(int i=1,l=prey[x].size();i<l;i++)
		lca=get_lca(lca,prey[x][i]);
	tr[lca].push_back(x);
	dep[x]=dep[lca]+1;
	st[x][0]=lca;	
	for(int i=1;st[st[x][i-1]][i-1];i++)
		st[x][i]=st[st[x][i-1]][i-1];
}
void topo(){
	queue<int>q;
	for(int i=1;i<=n;i++)
		if(!rd[i])
			Top[0].push_back(i),prey[i].push_back(0),rd[i]++;
	q.push(0);
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0,l=Top[u].size();i<l;i++){
			int v=Top[u][i];
			rd[v]--;
			if(rd[v]==0)q.push(v),solve(v);
		}
	}
}
void calc(int u){
	A[u]=1;
	for(int i=0,l=tr[u].size();i<l;i++){
		int v=tr[u][i];
		calc(v);
		A[u]+=A[v];
	}
}
int main(){
	cin>>n;
	for(int i=1,x;i<=n;i++)
		while(1){
			scanf("%d",&x);
			if(x)Top[x].push_back(i),rd[i]++,prey[i].push_back(x);
			else break;
		}
	topo();
	calc(0);
	for(int i=1;i<=n;i++)printf("%d\n",A[i]-1);
	return 0;
}

```

---

## 作者：ModestCoder_ (赞：2)

如果以生产者开始为根建树的话

一个点可以向该点所有食物的$lca$以及这个$lca$的所有祖先贡献1灾难值

根据上面两句话，就可以把这道题给做掉了

不过还是讲一讲具体写法

先拓扑排序调整顺序（从高级消费者到低级生产者），然后从生产者开始建树，一边建一边初始化倍增数组

最终从最高级的消费者开始向下面的东西贡献灾难值

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 1000010
using namespace std;
struct Edge{
	int to, next;
}edge[maxn << 1];
int num, head[maxn], in[maxn], d[maxn], que[maxn], cnt, fa[maxn][25], size[maxn], n;
queue <int> q;

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
} 

void addedge(int x, int y){ edge[++num] = (Edge){y, head[x]}, head[x] = num; }

void topsort(){
	for (int i = 1; i <= n; ++i)
		if (!in[i]) q.push(i);
	while (!q.empty()){
		int u = q.front(); q.pop();
		que[++cnt] = u;
		for (int i = head[u]; i; i = edge[i].next){
			int v = edge[i].to;
			if (!(--in[v])) q.push(v);
		}
	}
}

int get(int u, int v){
	if (d[u] > d[v]) swap(u, v);
	for (int i = 20; i >= 0; --i) if (d[u] <= d[fa[v][i]]) v = fa[v][i];
	if (u == v) return u;
	for (int i = 20; i >= 0; --i) if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
	return fa[u][0];
}

int main(){
	n = read();
	for (int i = 1; i <= n; ++i){
		int x = read();
		while (x) ++in[x], addedge(i, x), x = read();
	}
	topsort();
	for (int i = n; i; --i){
		int u = que[i], x = edge[head[u]].to;
		for (int j = edge[head[u]].next; j; j = edge[j].next) x = get(x, edge[j].to);
		fa[u][0] = x, d[u] = d[x] + 1;
		for (int j = 0; fa[u][j]; ++j) fa[u][j + 1] = fa[fa[u][j]][j];
	}
	for (int i = 1; i <= n; ++i) ++size[que[i]], size[fa[que[i]][0]] += size[que[i]];
	for (int i = 1; i <= n; ++i) printf("%d\n", size[i] - 1);
	return 0;
}
```


---

## 作者：封禁用户 (赞：1)

废话不多说，直接开门见山。

**定理：** 生物之间的灭绝结构形成了一个森林，森林上的节点的灭绝会且仅会导致以它为根的子树的灭绝。~~好惨~~

**分析：** 对于生产者，不妨给它添加一个假象的食物——太阳。那么定理中的森林就变成了一棵树，可以称它为“灭绝树。”

下面说明如何通过增量法把灭绝树建出来，同时也是对灭绝树的存在的证明。

首先，把食物网按照从猎物到捕食者的顺序拓扑排序，有且仅有太阳没有任何的入边，所以拓扑排序的第一个就是太阳。把太阳加入灭绝树，此时，灭绝树只有太阳一个点。

之后，一次考虑每个生物$i$。已经构建好排序在$i$之前的生物组成的灭绝树，假设$i$生物的食物有$p_1,p_2,\cdots,p_k$,（这些节点在拓扑序中比$i$靠前），$i$会灭绝，当且仅当$p_1,p_2,\cdots,p_k$全部灭绝，当且仅当$LCA(p_1,p_2,\cdots,p_k)$灭绝。

于是，可以在树上加上$LCA$到$i$的边，把$i$加到树中。

处理完所有的生物，我们就可以得到整个图的灭绝树。

一旦得到灭绝树，每个生物的灾难值就可以通过以它为根的子树的大小$-1$来计算。

这便可以通过一次$DFS$来解决。

**复杂度分析（$LCA$使用倍增算法）:** 拓扑排序$O(n+m)$,求$LCA$共$m$次，每次$O(log_2n)$，加点共$n$次，每次$O(log_2n)$,$DFS$为$O(n)$，总时间复杂度为：$O(nlog_2n+mlog_2m)$

---

## 作者：闲鱼 (赞：1)

这里给出一个~~较为详细的~~解释


------------

### 解题思路

#### 1.
首先读完题后我们很容易发现这是一个有向无环图。

又看到生产者的存在……肯定会想到拓扑排序啊qwq

但是感觉拓扑了之后没什么用欸，换思路！

#### 2.

我们再逆推一下，题目要求你求每种生物灭绝后会带动灭绝其他生物多少个。

然后你就会发现这是一个灭绝的关系，我们尝试用树来表示这个灭绝关系：如果生物i灭绝，那么i在灭绝树上的儿子就会灭绝，最终结果就是i节点往下求树上前缀和即可。（就是子树的节点数量）

#### 3.

那我们应该如何去建立这棵灭绝树呢？

把问题聚焦到某一个点i上，如果i要灭绝，前提条件是i的食物都灭绝了，而食物都灭绝的前提则是它们灭绝树上的的最近公共祖先灭绝了。换言之，我们只需要求出每个节点的食物的最近公共祖先就能建立灭绝树上的一个灭绝关系。

#### 4.

可能会有人不理解为什么在灭绝树建树的时候我们就可以在灭绝树上求LCA。

因为我们知道i的食物一定是比i等级低的（姑且认为这是一个等级关系），那么i的食物的LCA等级一定比i低（因为LCA导致了i的食物的灭绝），所以我们可以用食物链中等级由低到高的顺序建立灭绝树

回头一看之前的拓扑排序，恰好可以在这里构造一个等级由低到高的关系


------------

### 细节实现

#### 1.

搞清楚数据结构的关系：一棵灭绝树、一个有向无环图即可
。fa数组存的是灭绝树的关系！

#### 2.

处理多个生产者我们可以用一个0号节点，将所有生产者挂在0号节点下面（在灭绝树下）

```cpp
#include <queue>
#include <stdio.h>
#include <iostream>
using namespace std;

#define N 70000
#define M 500010

#define Abs(x) ((x) > 0 ? (x) : -(x)) 
#define Min(x, y) ((x) < (y) ? (x) : (y))
#define Max(x, y) ((x) > (y) ? (x) : (y))
#define Swap(x, y) do{x ^= y; y ^= x; x ^= y;}while(0)

struct Edge{
    int t, next;
}edge[M], tree[M]; //分别存有向无环图和灭绝树 
int head[N], head2[N], cnt = 1;
int n, indegree[N], depth[N], fa[N][20], ans[N];

inline int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-') f = -1; ch = getchar();}
    while('0' <= ch && ch <= '9'){x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
    return x * f;
}

inline void add(int u, int v)
{
    edge[cnt].t = v;
    edge[cnt].next = head[u];
    head[u] = cnt++;
}

inline void add2(int u, int v)
{
    tree[cnt].t = v;
    tree[cnt].next = head2[u];
    head2[u] = cnt++;
}

inline int LCA(int x, int y) //倍增LCA 
{
    int K = 0;
    if(depth[x] < depth[y]) Swap(x, y);
    while((1 << (K + 1)) <= depth[x]) K++;
    for(register int i = K;i >= 0;i--)
    {
        if(depth[fa[x][i]] < depth[y]) continue;
        x = fa[x][i];
    }
    if(x == y) return x;
    for(register int i = K;i >= 0;i--)
    {
        if(fa[x][i] != fa[y][i])
        {
            x = fa[x][i];
            y = fa[y][i];
        }
    }
    return fa[x][0];
}

inline void TopSort()
{
    queue<int> q;
    for(register int i = 1;i <= n;i++) fa[i][0] = -1;//初始化标记为-1，表示还未确定父亲 
    for(register int i = 1;i <= n;i++)
    {
        if(!indegree[i])
        {
            fa[i][0] = 0; //如果入度为零说明它是生产者，挂到0号节点下面 
            q.push(i);
        }
    }
    while(!q.empty())
    {
        int u = q.front(); q.pop();
        add2(fa[u][0], u);
        depth[u] = depth[fa[u][0]] + 1;
        for(register int i = 1;(1 << i) <= depth[u];i++) fa[u][i] = fa[fa[u][i-1]][i-1];
        for(register int i = head[u];i != 0;i = edge[i].next)
        {
            int v = edge[i].t;
            if(fa[v][0] == -1) fa[v][0] = u; 
            else fa[v][0] = LCA(fa[v][0], u); //多个节点的LCA 
            indegree[v]--;
            if(!indegree[v]) //入度为0入队 
            {
                q.push(v);
            }
        }
    }
}

inline void DFS(int u)
{
    ans[u] = 1; //自己 
    for(register int i = head2[u];i != 0;i = tree[i].next)
    {
        DFS(tree[i].t);
        ans[u] += ans[tree[i].t];
    }
}

int main()
{
    n = read();
    for(register int i = 1;i <= n;i++)
    {
        while(1)
        {
            int q = read();
            if(q == 0) break;
            add(q, i); indegree[i]++; //初始化节点入读 
        }
    }
    cnt = 1, depth[0] = 0; //cnt废物利用 
    TopSort();
    DFS(0);
    for(register int i = 1;i <= n;i++)
    {
        printf("%d\n", ans[i] - 1); //需要求该物种灭绝会影响多少其他物种灭绝，所以要去掉一个 
    }
    return 0;
}
```
总结：解决有一定思维难度的题目时可以从正向和反向推，抓住关键信息则是解题的重中之重

---

## 作者：Doingdong (赞：1)

[题目链接](https://www.luogu.org/problemnew/show/P2597)

发现生物之间的灭绝关系（x向y连边表示x死了y也活不成）会形成一片森林

我们可以用一个根节点将所有树合并成一棵树,也可以想象为新增一种生物,所有生产者会因为它的灭绝而灭绝. 

首先对所有生物进行拓扑排序,然后考虑按拓扑序一个一个节点加入

在加入第i个节点时,有且仅有它的所有食物的lca到根的这条链上的任意一个点的灭绝都会使它灭绝,因此我们可以将它的父节点定为这个lca. 

这样处理完每个点的子树大小(不算它自己)就是它的灾难度.

用倍增就能动态维护lca

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,j,k) for(int i=j;i<=k;++i)
typedef long long ll;
char cch;
inline int rd(){
	int x=0,fl=1;
	cch=getchar();
	while(cch>'9'||cch<'0'){
		if(cch=='-') fl=-1;
		cch=getchar();
	}
	while(cch>='0'&&cch<='9') x=(x<<3)+(x<<1)+cch-'0',cch=getchar();
	return x*fl;
}
const int N=7e4;
int dep[N],head[N],head2[N],cnt,to[N*350],a[N],nxt[N*350],sz[N],fa[N][19],ru[N];//边必须乘350，因为这不是一棵树！是一个DAG， 
queue<int> q;
void top(){
	int u,tot=0;
	while(q.size()){
		a[++tot]=u=q.front(),q.pop();
		for(int i=head[u];i;i=nxt[i]){
			--ru[to[i]];
			if(ru[to[i]]==0) q.push(to[i]);
		}
	}
}
inline void adde(int u,int v){
	to[++cnt]=v,nxt[cnt]=head[u],head[u]=cnt;
}
inline int lca(int u,int v){
	if(dep[u]<dep[v]) swap(u,v);
	for(int i=18;i>=0;--i) if(dep[fa[u][i]]>=dep[v]) u=fa[u][i];
	for(int i=18;i>=0;--i) if(fa[u][i]^fa[v][i]) u=fa[u][i],v=fa[v][i];
	if(u==v) return u;
	return fa[u][0];
}
inline void add(int son,int f){
	fa[son][0]=f,dep[son]=dep[f]+1;
	rep(i,1,18) fa[son][i]=fa[fa[son][i-1]][i-1];
}
int main(){
	int n=rd(),lc,t;
	rep(i,1,n){
		t=rd();
		while(t){
			adde(t,i);
			++ru[i];
			to[++cnt]=t,nxt[cnt]=head2[i],head2[i]=cnt;
			t=rd();
		}
		if(ru[i]==0) q.push(i);sz[i]=1;
	}
	top();
	rep(u,1,n){
		lc=to[head2[a[u]]];
		for(int i=head2[a[u]];i;i=nxt[i]) lc=lca(lc,to[i]);
		add(a[u],lc);
	}
	for(int i=n;i;--i){
		sz[fa[a[i]][0]]+=sz[a[i]];
	}
	rep(i,1,n) printf("%d\n",sz[i]-1);
}
```

虽然边乘4就可以过所有数据了

---

## 作者：jpwang (赞：1)

楼下的题解都好平易近人啊，我来一个支配树的做法

考虑加入非生物因素（雾）作为根连接生产者
那么我们只需要建出原图的支配树即可求出x挂了后多少个节点会受到影响
答案即为支配树上的子树size-1
# Code

---
```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <vector>
#define rep(i,st,ed) for (int i=st;i<=ed;++i)
#define drp(i,st,ed) for (int i=st;i>=ed;--i)

const int N=500005;

namespace Tree {
	struct edge {int y,next;} e[N];

	int size[N];
	int ls[N],edCnt;

	void add_edge(int x,int y) {
		e[++edCnt]=(edge) {y,ls[x]}; ls[x]=edCnt;
	}

	void dfs(int now) {
		size[now]=1;
		for (int i=ls[now];i;i=e[i].next) {
			dfs(e[i].y); size[now]+=size[e[i].y];
		}
	}
} ;

struct edge {int y,next;} e[N];

std:: vector <int> pre[N],dom[N];

int dfn[N],id[N],fa[N],acs[N],mn[N];
int idom[N],sdom[N];
int ls[N],edCnt;

int read() {
	int x=0,v=1; char ch=getchar();
	for (;ch<'0'||ch>'9';v=(ch=='-')?(-1):(v),ch=getchar());
	for (;ch<='9'&&ch>='0';x=x*10+ch-'0',ch=getchar());
	return x*v;
}

void add_edge(int x,int y) {
	e[++edCnt]=(edge) {y,ls[x]}; ls[x]=edCnt;
}

void dfs(int now) {
	dfn[now]=++dfn[0];
	id[dfn[0]]=now;
	for (int i=ls[now];i;i=e[i].next) {
		pre[e[i].y].push_back(now);
		if (!dfn[e[i].y]) {
			fa[e[i].y]=now;
			dfs(e[i].y);
		}
	}
}

int find(int x) {
	if (acs[x]==x) return x;
	int tmp=find(acs[x]);
	if (dfn[sdom[mn[acs[x]]]]<dfn[sdom[mn[x]]]) mn[x]=mn[acs[x]];
	return acs[x]=tmp;
}

int smin(int x,int y) {
	return (dfn[x]<dfn[y])?x:y;
}

void build(int n) {
	drp(i,dfn[0],1) {
		int x=id[i];
		if (!pre[x].empty()) {
			for (int j=0;j<pre[x].size();j++) {
				int y=pre[x][j];
				if (dfn[y]<dfn[x]) sdom[x]=smin(sdom[x],y);
				else {
					find(y);
					sdom[x]=smin(sdom[x],sdom[mn[y]]);
				}
			}
			pre[x].clear();
		}
		acs[x]=fa[x];
		dom[sdom[x]].push_back(x);
		if (!dom[fa[x]].empty()) {
			for (int j=0;j<dom[fa[x]].size();j++) {
				int y=dom[fa[x]][j];
				find(y); int d=mn[y];
				if (dfn[sdom[d]]>=dfn[sdom[y]]) idom[y]=sdom[y];
				else idom[y]=d;
			}
			dom[fa[x]].clear();
		}
	}
	rep(i,1,dfn[0]) {
		int x=id[i];
		if (idom[x]!=sdom[x]) idom[x]=idom[idom[x]];
		Tree:: add_edge(idom[x],x);
	}
	Tree:: dfs(n);
	rep(i,1,n-1) printf("%d\n", Tree:: size[i]-1);
}

int main(void) {
	int n=read();
	rep(i,1,n) {
		int x=read();
		if (!x) add_edge(n+1,i);
		else for (;x;x=read()) add_edge(x,i);
	}
	rep(i,1,n+1) sdom[i]=acs[i]=mn[i]=i;
	dfs(n+1);
	build(n+1);
	return 0;
}
```

---

## 作者：shuri001 (赞：1)

构建食物链

比这个点拓扑序列小的点们的lca必然可以gank掉这个点

然后求一求 把这个点归到这父亲底下

恩 看注释



```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
const int mx=65535;
int q[mx],top,tail,n,v[mx],head[mx],head1[mx],cnt1,cnt,p[mx][22],d[mx],die[mx];
struct nd{
    int to,ne;
}e[mx*2],e1[mx*2];
std::vector<int> qq[mx*5];
struct nod{
    int num,rk;
}rr[mx];
void link(int x,int y){
    e[++cnt].to=y,e[cnt].ne=head[x],head[x]=cnt;
```
}//连图
void link1(int x,int y){

    e1[++cnt1].to=y,e1[cnt1].ne=head1[x],head1[x]=cnt1;

}//连树


```cpp
bool cmp(nod a,nod b){
    return a.rk<b.rk;//拓扑序列小的在前 
}
void dfs1(int u){
    for(int v=head1[u];v;v=e1[v].ne){
        int to=e1[v].to;    //搜一遍 看看他是多少个点的父亲（说白了就是求深度？？？ 
        dfs1(to);
        die[u]+=die[to]+1;
    }
}
int lca(int a,int b){
    if(a==b) return a;
    if(d[a]<d[b]){int t=a; a=b,b=t;    }
    int f=d[a]-d[b];
    for(int i=0;(1<<i)<=f;i++)
        if(f&(1<<i)) a=p[a][i];
    if(a!=b){
        for(int i=20;i>=0;i--)
            if(p[a][i]!=p[b][i])
                a=p[a][i],b=p[b][i]; 
        a=p[a][0];
    }
    return a;//倍增lca板子 
}
int main(){
    scanf("%d",&n); d[0]=1; int xx;
    for(int i=1;i<=n;i++){
        scanf("%d",&xx);//读入节点 
        while(xx){
            v[i]++;//读该节点的儿子 并记录入度 
            link(xx,i);    
            qq[i].push_back(xx);
            scanf("%d",&xx);
        }
    }
    for(int i=1;i<=n;i++)   if(!v[i]) v[i]++,link(0,i),qq[i].push_back(0); //如果是一个父节点 那就和我们的虚根“0”连起来 构成一个生命树 
    q[++tail]=0;
    while(top<tail){
        int x=q[++top];
        for(int i=head[x];i;i=e[i].ne){ //遍历一下 求拓扑序列 
            int to=e[i].to;
            v[to]--;
            if(!v[to]) q[++tail]=to,rr[to].num=to,rr[to].rk=tail;
        }
    }
    std::sort(rr+1,rr+1+n,cmp);//进行排序 
    for(int i=1;i<=n;i++){
        int xx=rr[i].num,t=0; 
        for(int j=0;j<qq[xx].size();j++){
            int tt=qq[xx][j];
            if(!j) t=tt;    //找一下拓扑序列比这个点大的点的lca    （可以灭亡这个父亲的点 
            else t=lca(t,tt);
        } 
        link1(t,xx);//找到了这个点 让这个父亲从属于于这个点的生存树下 
         p[xx][0]=t; d[xx]=d[t]+1;
        for(int j=1;j<=20;j++) p[xx][j]=p[p[xx][j-1]][j-1];//更新树 
    }
    dfs1(0);   //搜一下危险值（层数 
    for(int i=1;i<=n;i++) printf("%d\n",die[i]);
    return 0;
}
```

---

## 作者：FrankLi0324 (赞：1)

略加封装，可读性++

分析得：一个物种灭绝当且仅当：

这个物种的所有食物的lca灭绝

'''cpp
```cpp
#include<iostream>
#include<vector>
#include<queue>
#include<cstring>
#define memset(x,y) memset(x,y,sizeof x)
using namespace std;
int n;
#define maxn 70000
class Graph {
    vector<int>map[maxn];
    int inDegree[maxn];
```
public:
```cpp
    vector<int>topoOrder;
    Graph() {
        memset(inDegree, 0);
    }
    vector<int> &operator [](int pos) {
        return map[pos];
    }
    void connect(int from, int to) {
        map[from].push_back(to);
        inDegree[to]++;
    }
    void topoSort() {
        queue<int>joblist;
        for (int i = 1; i <= n; i++)
            if (!inDegree[i])joblist.push(i);
        while (!joblist.empty()) {
            int current = joblist.front(); joblist.pop();
            topoOrder.push_back(current);
            for (int i = 0; i < map[current].size(); i++) {
                inDegree[map[current][i]]--;
                if (!inDegree[map[current][i]])
                    joblist.push(map[current][i]);
            }
        }
    }
}G;
class DistinctTree {
    int depth[maxn], father[maxn][17];
    vector<int>map[maxn];
    int lca(int x, int y) {
        if (x == -1)return y;
        if (depth[x] < depth[y])swap(x, y);
        int delta = depth[x] - depth[y];
        for (int i = 0; i < 17 && delta; i++) {
            if (delta&(1 << i)) {
                x = father[x][i];
                delta ^= 1 << i;
            }
        }
        for (int i = 16; i >= 0; i--) {
            if (father[x][i] != father[y][i])
                x = father[x][i], y = father[y][i];
        }
        return (x == y ? x : father[x][0]);
    }
```
public:
```cpp
    DistinctTree() {
        memset(depth, 0); memset(father, 0);
    }
    vector<int> &operator[](int pos) {
        return map[pos];
    }
    void build(vector<int>&topo) {
        depth[0] = 1;//super node
        for (int i = topo.size() - 1; i >= 0; i--) {
            int current = topo[i];
            int current_father = -1;
            for (int i = 0; i < G[current].size(); i++)
                current_father = lca(current_father, G[current][i]);
            if (current_father == -1)current_father = 0;
            map[current_father].push_back(current);
            depth[current] = depth[current_father] + 1;
            father[current][0] = current_father;
            for (int i = 0; i < 16 && father[current][i]; i++)
                father[current][i + 1] = father[father[current][i]][i];
        }
```
#undef current
```cpp
    }
}DT;
int FINAL[maxn];
int FINAL_DFS(int current) {
    int cnt = 1;
    for (int i = 0; i < DT[current].size(); i++)
        cnt += FINAL_DFS(DT[current][i]);
    return FINAL[current] = cnt;
}
int main() {
    cin >> n; int other;
    for (int i = 1; i <= n; i++) {
        cin >> other;
        while (other) {
            G.connect(i, other);
            cin >> other;
        }
    }
    G.topoSort();
    DT.build(G.topoOrder);
    FINAL_DFS(0);
    for (int i = 1; i <= n; i++)
        cout << FINAL[i] - 1 << endl;
}
```
'''

---

## 作者：eternal (赞：1)

生物之间的灭绝的结构形成了一个树，树上的一个节点的灭绝会且仅会导致以它为根的子树的灭绝。我们管这个树叫“灭绝树”。

对于生产者，我们给它添加一个假想的食物：太阳。

这样，“灭绝树”就形成了一个以太阳为根的树。


下面说明如何通过增量法把灭绝树建出来，同时也是对灭绝树的存在性的证明。


首先，把食物网按从猎物到捕食者的顺序拓扑排序。

之后，依次考虑每个生物i.我们已经构建好了排序在i之前的生物组成的“灭绝树”了。

假设i的食物有x[0]~x[k]（x[0]~x[k]在拓扑排序中比i靠前）。

很显然，只有x[0]~x[k]在树上的公共祖先的灭绝会导致i灭绝，否则i一定可以找到能让它活下来的食物。

　　　　　　　　　　　　　　　　　
．．．

／
／
ＬＣＡ

／｜＼

＿／｜｜

／｜＼

Ｏ｜＼

／＼＼\

ｘｘｘｘ

　　　　　　　　　　　　　　　　　
ｉ
　　　　　　　　　　　　　　　　　
　　　　　　　　　　　　　　　　　
于是，我们可以把i挂在x[0]~x[k]的最近公共祖先下面。


处理完所有的生物，我们得到的树就是整个图的灭绝树了。

一旦得到灭绝树，每个生物的灾难值就可以通过以它为根的子树的大小减1来计算.


【复杂度分析】


拓扑排序的时间复杂度是O（|E|）的。
一共有|E|次LCA的查询，和|V|次添加边的操作。
我们使用某种支持快速查询LCA、添加点的数据结构（例如动态树）。

这样，总的时间复杂度是O(|E|log|V|)。

 
 
 
 
 
 
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#define pb push_back
using namespace std;
const int maxn=100000;
vector<int> linkto[maxn],dd[maxn];
int dep[maxn],fa[maxn][20],ans[maxn],ini[maxn],s[maxn];
int l,r,n,q,cur,csize,lca;
int getlca(int x,int y){
    int p,step=0;
    if (dep[x]<dep[y])  swap(x,y);
    p=dep[x]-dep[y];
    while   (p){
        if  (p&1)    x=fa[x][step];
        p/=2;step++;
    }
    step=0;
    while   (x!=y){
        if (fa[x][step]!=fa[y][step] || (fa[x][step]==fa[y][step] && !step)){
            x=fa[x][step];
            y=fa[y][step];
            step++;
        }
        else step--;
    }
    return x;
}
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;i++){
        scanf("%d",&cur);
        while   (cur){
            linkto[i].pb(cur);
            dd[cur].pb(i);
            ini[i]++;
            scanf("%d",&cur);
        }
    }
    l=1;r=0;
    for (int i=1;i<=n;i++)
        if (!ini[i])    s[++r]=i;
    while   (l<=r){
        for (int j=0;j<dd[s[l]].size();j++){
            ini[dd[s[l]][j]]--;
            if (!ini[dd[s[l]][j]])
                s[++r]=dd[s[l]][j];
        }
        l++;
    }
    memset(ini,0,sizeof ini);
    dep[0]=1;
    for (int i=1;i<=n;i++){
        if  (!linkto[s[i]].size()){
            fa[s[i]][0]=0;
            dep[s[i]]=2;
            continue;
        }
        lca=linkto[s[i]][0];
        for (int j=1;j<linkto[s[i]].size();j++)
            lca=getlca(lca,linkto[s[i]][j]);
        dep[s[i]]=dep[lca]+1;
        cur=0;fa[s[i]][cur]=lca;
        ini[lca]++;
        while (fa[s[i]][cur]){
            fa[s[i]][cur+1]=fa[fa[s[i]][cur]][cur];
            cur++;
        }
    }
    l=1;r=0;
    for (int i=1;i<=n;i++){
        ans[i]=1;
        if  (ini[i]==0) s[++r]=i;
    }
    while (l<=r){
        ini[fa[s[l]][0]]--;
        ans[fa[s[l]][0]]+=ans[s[l]];
        if (ini[fa[s[l]][0]]==0)
            s[++r]=fa[s[l]][0];
        l++;
    }
    for (int i=1;i<=n;i++)
        printf("%d\n",ans[i]-1);
    return 0;
}
```

---

## 作者：永不复行 (赞：1)

说明一句 不用反向建边
这是一种较短的求最近公共祖先的方法
```c
void RMQ(int x)
{
	f[x][0]=fa[x];
	for (int i=1;i<=16;++i)
		f[x][i]=f[f[x][i-1]][i-1];
}
int LCA(int x,int y)
{
	if (d[x]<d[y])swap(x,y);
	for (int i=16;i>=0;--i)
		if (f[x][i]!=0&&d[f[x][i]]>=d[y])
			x=f[x][i];
	if (x==y)	return y;
	else return LCA(fa[x],y);
}
```
如果你反向建边
```c
ll find(ll x)
{
    if(!u[x])
    {
        g[++cng]=x;
        f[x]=x;
        return x;
    }
    if(f[x])return f[x];
    if(u[x]==1)
    {
        ll tmp=x;
        if(u[fd[h[tmp]].s]==1)
        {
            acs[tmp]=fd[h[tmp]].s;
            f[tmp]=f[fd[h[tmp]].s];
        }
        else while(!(u[tmp]-1))
        {
            done[tmp]=true;
            acs[tmp]=fd[h[tmp]].s;
            tmp=fd[h[tmp]].s;
        }
        f[x]=tmp;
        return tmp;
    }
    if(u[x]>1)
    {
        f[x]=fd[h[x]].s;
        done[x]=true;
        for(ll i=h[x];i;i=fd[i].n)
        {
            f[x]=getf(f[x],fd[i].s);
            done[fd[i].s]=true;
        }
        acs[x]=f[x];
        return f[x];
    }
}
ll getf(ll x,ll y)
{
    if(x==y)return x;
    else
    {
        if(find(x)==y)return y;
        if(find(y)==x)return x;
        if(f[x]==f[y])return f[x];
        return getf(f[x],f[y]);
    }
}
```
要多加几个数组
优化方法是处理时除father数组外再加一个
**k数组** 维护在原图中整一条入度为1的链
（上方代码中的f数组是k数组，acs才是father数组），但这样的话就不能倍增了，搞不好的话好像会wa几个点，尤其是边多的图，o（nm）（点数乘边数）
[代码](https://www.luogu.org/blog/ylz4944749/p2597-chun-dai-ma)

---

## 作者：Rainybunny (赞：0)

# $\mathcal{Description}$
&emsp;&emsp;[link](https://www.luogu.com.cn/problem/P2597).  
&emsp;&emsp;给定一个捕食网络，对于每个物种，求其灭绝后有多少消费者失去所有食物来源。（一些名词与生物学的定义相同 w。）  
&emsp;&emsp;原图结点数 $n\le65534$，边数 $m\le10^6$，图保证无有向环。
# $\mathcal{Solution}$
&emsp;&emsp;支配树板题。将原图反向建边，令一个“超级生产者”结点，指向所有生产者，然后求出该图的支配树。每个物种的答案就是其子树大小 $-1$。  
&emsp;&emsp;以下会讲解对于有向无环图（DAG），如何建出支配树。
## 在 DAG 上建支配树
&emsp;&emsp;声明对“支配”的定义：对于 $u$ 的支配点 $v$，满足删去 $v$ 后，从源点不可到达 $u$。  
&emsp;&emsp;最近支配点：所有支配 $u$ 的 $v$ 中距离 $u$ 最近的一个点。可以证明某个点的最近支配点唯一。  
&emsp;&emsp;按照拓扑序，从源点开始处理。可以直观地发现，点 $u$ 的最近支配点就是其所有前驱结点在支配树上的 LCA。所以只需要每次向支配树加入当前结点，并处理处当前结点的倍增信息即可。
## $\mathcal{Code}$
```cpp
#include <queue>
#include <cstdio>
#include <vector>

#define adj( g, u, v ) \
	for ( int _eid = g.head[u], v; v = g.to[_eid], _eid; _eid = g.nxt[_eid] )

const int MAXN = 65534, MAXM = 1e6, MAXLG = 15;
int n, dep[MAXN + 5], ans[MAXN + 5], rnk[MAXN + 5], fa[MAXN + 5][MAXLG + 5];
std::queue<int> que;
std::vector<int> pre[MAXN + 5];

inline int rint () {
	int x = 0; char s = getchar ();
	for ( ; s < '0' || '9' < s; s = getchar () );
	for ( ; '0' <= s && s <= '9'; s = getchar () ) x = x * 10 + ( s ^ '0' );
	return x;
}

struct Graph {
	int ecnt, head[MAXN + 5], to[MAXM + 5], nxt[MAXM + 5], ind[MAXN + 5];
	inline void link ( const int s, const int t ) {
		++ ind[to[++ ecnt] = t], nxt[ecnt] = head[s], head[s] = ecnt;
		pre[t].push_back ( s );
	}
} sour, domt;

inline int LCA ( int u, int v ) {
	if ( dep[u] < dep[v] ) u ^= v ^= u ^= v;
	for ( int i = 15; ~ i; -- i ) if ( dep[fa[u][i]] >= dep[v] ) u = fa[u][i];
	if ( u == v ) return u;
	for ( int i = 15; ~ i; -- i ) if ( fa[u][i] ^ fa[v][i] ) u = fa[u][i], v = fa[v][i];
	return fa[u][0];
}

inline void calc ( const int u ) {
	ans[u] = 1;
	adj ( domt, u, v ) calc ( v ), ans[u] += ans[v];
}

int main () {
	n = rint ();
	for ( int i = 1, t; i <= n; ++ i ) while ( t = rint () ) sour.link ( t, i );
	for ( int i = 1; i <= n; ++ i ) if ( ! sour.ind[i] ) sour.link ( n + 1, i );
	int cnt = 0;
	que.push ( n + 1 );
	for ( int u; ! que.empty (); que.pop () ) {
		rnk[++ cnt] = u = que.front ();
		adj ( sour, u, v ) if ( ! -- sour.ind[v] ) que.push ( v );
	}
	for ( int i = 1; i <= cnt; ++ i ) {
		int u = rnk[i], f = 0;
		if ( ! pre[u].empty () ) f = pre[u][0];
		for ( int j = 1; j < ( int ) pre[u].size (); ++ j ) f = LCA ( f, pre[u][j] );
		dep[u] = dep[fa[u][0] = f] + 1, domt.link ( f, u );
		for ( int j = 1; j <= 15; ++ j ) fa[u][j] = fa[fa[u][j - 1]][j - 1];
	}
	calc ( n + 1 );
	for ( int i = 1; i <= n; ++ i ) printf ( "%d\n", ans[i] - 1 );
	return 0;
}
```

---

## 作者：Uniecho1 (赞：0)

有生之年第一次写支配树......发个题解纪念一下

一个物种要灭绝的条件是：他所有的食物都凉掉了。

所以，你想到了建反图+top序？

嗯你对了一半了。

我们还要满足所有食物都死绝......

得出结论：当他所有食物在刚刚构造出的树上的LCA死绝时，他才会死绝

...就没了欸

最后搞一波树上统计就好了

上代码上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100005;
int N,in[maxn],top[maxn],fa[maxn][20],lg2[maxn]={-1},dep[maxn],size[maxn];
vector<int>G1[maxn],G2[maxn],G3[maxn];
void topsort(){
	int cnt=0;
	queue<int>q;
	for(int i=1;i<=N;i++)
		if(!in[i])
			q.push(i);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		top[++cnt]=u;
		for(int i=0;i<G2[u].size();i++){
			int v=G2[u][i];
			in[v]--;
			if(!in[v])
				q.push(v);
		}
	}
}
int LCA(int u,int v){
	if(dep[u]<dep[v])swap(u,v);
	while(dep[u]>dep[v])
		u=fa[u][lg2[dep[u]-dep[v]]];
	if(u==v)return u;
	for(int k=lg2[dep[u]];k>=0;k--)
		if(fa[u][k]!=fa[v][k])
			u=fa[u][k],v=fa[v][k];
	return fa[u][0];
}
void dfs(int u){
	size[u]=1;
	for(int i=0;i<G3[u].size();i++){
		int v=G3[u][i];
		dfs(v);
		size[u]+=size[v];
	}
}
int main(){
	//freopen("in.txt","r",stdin);
	ios::sync_with_stdio(false);
	cin>>N;
	for(int i=1;i<=N;i++)
		lg2[i]=lg2[i>>1]+1;
	for(int i=1,x;i<=N;i++)
		while(cin>>x&&x){
			G1[i].push_back(x);
			G2[x].push_back(i);
			in[i]++;
		}
	topsort();
	for(int i=1;i<=N;i++){
		if(!G1[top[i]].size())
			G1[top[i]].push_back(N+1);
		int x=G1[top[i]][0];
		for(int j=1;j<G1[top[i]].size();j++)
			x=LCA(x,G1[top[i]][j]);
		G3[x].push_back(top[i]);
		fa[top[i]][0]=x;
		dep[top[i]]=dep[x]+1;
		for(int k=1;k<=lg2[dep[top[i]]];k++)
			fa[top[i]][k]=fa[fa[top[i]][k-1]][k-1];
	}
	dfs(N+1);
	for(int i=1;i<=N;i++)
		cout<<size[i]-1<<endl;
	return 0;
} 
```


---

## 作者：xryjr233 (赞：0)

首先,我们需要把图上的边像样例的图片一样反着建。

然后我们跑一遍拓扑排序(注意这时候可能有多个入度为0的点),记录每个点的层数(即它的所有父亲的层数最大值+1)。

然后我们将所有点按层数升序排序,依次处理。

对于每个点,能够使它灭绝的,深度最大的点是它所有父亲的$LCA$,记为$f_{i,0}$。

当然必然会有某一些点的所有父亲没有$LCA$,或者它干脆没有父亲(①)。

这里就是要按层数处理节点的原因,可以确保处理一个点时,它所有的父亲都被处理过了。

显然$f_{f_{i,0},0},f_{f_{f_{i,0},0},0},...$也能使$i$灭绝。

由于$f_{i,0}$是唯一的,所以如果我们建一个新的图,其中所有$f_{i,0}$向$i$连边,就得到了一个森林。

森林中所有树的根都满足①,而且所有满足①的点必然是树根。

而一个点的灾难值就是它的子树中点的数量。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,in[65551],sq[65551],sz,f[65551][20],ans[65551],dep[65551],tg;
vector<int>e[65551];
vector<int>fs[65551];
vector<int>ze[65551];
queue<int>q;
void Tpst(){
	for(int i=1;i<=n;i++)if(!in[i])q.push(i);
	while(!q.empty()){
		sq[++sz]=t=q.front();
		q.pop();
		for(int i=0;i<e[t].size();i++)if(!(--in[e[t][i]]))q.push(e[t][i]);
	}
}
int LCA(int x,int y){
	if(dep[x]<dep[y])swap(x,y);
	for(int i=16;i>=0;i--)if(dep[x]-(1<<i)>=dep[y])x=f[x][i];
	for(int i=16;i>=0;i--)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];
	if(x==y)return x;
	return f[x][0];
}
void dfs(int x){
	ans[x]=1;
	for(int i=0;i<ze[x].size();i++)dfs(ze[x][i]),ans[x]+=ans[ze[x][i]];
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		while(scanf("%d",&t)){
			if(!t)break;
			e[t].push_back(i);
			fs[i].push_back(t);
			in[i]++;
		}
	Tpst();
	for(int i=1;i<=sz;i++){
		t=-1;
		for(int j=0;j<fs[sq[i]].size();j++){
			t=(t==-1?fs[sq[i]][j]:LCA(t,fs[sq[i]][j]));
		}
		if(t!=-1&&t!=0)f[sq[i]][0]=t;
		if(t!=-1)dep[sq[i]]=dep[t]+1;
		for(int j=1;j<=16&&f[sq[i]][j-1];j++)f[sq[i]][j]=f[f[sq[i]][j-1]][j-1];
		if(f[sq[i]][0])ze[f[sq[i]][0]].push_back(sq[i]);
		else q.push(sq[i]);
	}
	while(!q.empty())tg=(q.front()==1),dfs(q.front()),q.pop();
	for(int i=1;i<=n;i++)printf("%d\n",ans[i]-1);
	return 0;
}
```

---


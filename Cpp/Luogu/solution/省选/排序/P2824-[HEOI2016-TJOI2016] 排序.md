# [HEOI2016/TJOI2016] 排序

## 题目描述

在 $2016$ 年，佳媛姐姐喜欢上了数字序列。因而她经常研究关于序列的一些奇奇怪怪的问题，现在她在研究一个难题，需要你来帮助她。  

这个难题是这样子的：给出一个 $1$ 到 $n$ 的排列，现在对这个排列序列进行 $m$ 次局部排序，排序分为两种：  

- `0 l r` 表示将区间 $[l,r]$ 的数字升序排序  
- `1 l r` 表示将区间 $[l,r]$ 的数字降序排序  

注意，这里是对**下标**在区间 $[l,r]$ 内的数排序。  
最后询问第 $q$ 位置上的数字。


## 说明/提示

河北省选2016第一天第二题。

对于 $30\%$ 的数据，$n,m\leq 1000$

对于 $100\%$ 的数据，$n,m\leq 10^5$，$1\leq q\leq n$

## 样例 #1

### 输入

```
6 3
1 6 2 5 3 4
0 1 4
1 3 6
0 2 4
3```

### 输出

```
5```

# 题解

## 作者：fy0123 (赞：252)

**大意：**

给一个n的排列（n<=10^5），有m（m<=10^5）个操作：

- 1 l r  表示把[l, r]区间内的数降序排序；

- 0 l r 表示把[l, r]区间内的数升序排序。

最后询问这个序列的第p个位子上的数是多少。

-----------------

**做法：**

由于将一个普通序列排序很慢，需要nlogn的时间，所以我们试着把它转化为对01序列排序。先来考虑一个简单的问题：


-------------------------

- 如何将一个01序列排序？（logn的复杂度）

- 对于这个问题，我们使用线段树来维护。查询一段区间内的1的个数记为cnt1，如果是升序，就将这段区间的[r-cnt1+1, r]都更改为1，将[l, r-cnt1]更改为0。降序则将[l, l+cnt1-1]更改为1，将[l+cnt, r]更改为0。这样我们就成功地把排序转化为了区间查询和区间修改。

-----------


接下来我们来说本题的做法：

这是一个离线的做法。首先二分答案mid。我们把原排列中大于等于mid的数都标记为1，小于mid的都标记为0。然后对于每个操作我们就将01序列排个序。最后如果第p个位子仍是1的话就是可行的。

这个二分成立因为是满足单调性的：可以简单地假设一下，如果你二分的答案是1，那么原序列所有的值都转化为了1，所以最后肯定是true。如果二分一个值成立当且仅当这个位子的值大于等于mid，故如果check返回true，则l = mid+1，否则r = mid-1。

（这题的思想可以借鉴，比较巧妙）


```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
#define lc o<<1
#define rc o<<1|1
#define mid (l+r)/2
using namespace std;

const int N = 100010;
int n, m, p;
int T[4*N], lazy[4*N];//segment tree
int a[N], ch[N], L[N], R[N];//the information by reading

inline int read()
{
    char ch = getchar(); int x = 0;
    while (!isdigit(ch)) ch = getchar();
    while (isdigit(ch)){ x = x*10+ch-'0'; ch = getchar(); }
    return x;
}

inline void build(int o, int l, int r, int x)
{
    if (l == r){
        T[o] = a[l] >= x;
        lazy[o] = 0;
        return;
    }
    build(lc, l, mid, x); build(rc, mid+1, r, x);
    T[o] = T[lc]+T[rc]; lazy[o] = 0;
}

inline void pushdown(int o, int l, int r)
{
    if (!lazy[o]) return;
    lazy[lc] = lazy[rc] = lazy[o];
    if (lazy[o] == 1){
        T[lc] = mid-l+1; T[rc] = r-mid;
    } else T[lc] = T[rc] = 0;
    lazy[o] = 0;
}

inline int query(int o, int l, int r, int x, int y)
{
    if (x <= l && y >= r) return T[o];
    if (x > r || y < l) return 0;
    pushdown(o, l, r);
    return query(lc, l, mid, x, y) + query(rc, mid+1, r, x, y);
}

inline int queryPoint(int o, int l, int r, int x)
{
    if (l == x && r == x) return T[o];
    pushdown(o, l, r);
    if (x <= mid) return queryPoint(lc, l, mid, x);
    else return queryPoint(rc, mid+1, r, x);
}

inline void update(int o, int l, int r, int x, int y, int val)
{
    if (x <= l && y >= r){
        T[o] = val*(r-l+1); lazy[o] = val ? 1 : -1;
        return;
    }
    if (x > r || y < l) return;
    pushdown(o, l, r);
    update(lc, l, mid, x, y, val);
    update(rc, mid+1, r, x, y, val);
    T[o] = T[lc]+T[rc];
}

inline bool check(int x)
{
    build(1, 1, n, x);
    for (int i = 1; i <= m; i ++){
        int cnt1 = query(1, 1, n, L[i], R[i]);
        if (ch[i] == 0){
            update(1, 1, n, R[i]-cnt1+1, R[i], 1);
            update(1, 1, n, L[i], R[i]-cnt1, 0);
        }
        else{
            update(1, 1, n, L[i], L[i]+cnt1-1, 1);
            update(1, 1, n, L[i]+cnt1, R[i], 0);
        }
    }
    return queryPoint(1, 1, n, p);
}

int main()
{
    n = read(); m = read();
    for (int i = 1; i <= n; i ++) a[i] = read();
    for (int i = 1; i <= m; i ++){
        ch[i] = read(); L[i] = read(); R[i] = read();
    }
    p = read();
    int ll = 1, rr = n, midd, ans;
    while (ll <= rr){
        midd = (ll+rr) >> 1;
        if (check(midd)) ans = midd, ll = midd+1; else rr = midd-1;
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：ComeIntoPower (赞：70)

本题有**O(nlogn)**的写法

用可分裂合并的线段树,即建n个值域线段树(动态开点),然后在线做,

拿一个set维护每次要合并的区间,然后如果l,r“切断”了一个区间,就把它分裂

跟非旋转式treap一样...然而...

PS:此题排列中有0,所以是0到n

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<set>
#define Sum(a) ((a)?(a)->sum:0)
using namespace std;
struct tree{
    tree* l,* r;
    int sum;
    tree(){l=r=0;sum=0;}
    void update(){
        sum=Sum(l)+Sum(r);
    }
};

struct data{
    int l,r,type;
    tree* ptr;
    data(int l,int r,int type,tree*ptr):
        l(l),r(r),type(type),ptr(ptr){}
    int operator<(const data& d)const{
        return r<d.r;
    }
};
typedef set<data>::iterator sit;
tree* merge(tree*& a,tree* b,int l,int r){
//    printf("[%d,%d]",a,b);
    if(!a)return b;
    if(!b)return a;
    if(l==r){
        a->sum+=b->sum;
        return a;
    }
    int mid=l+r>>1;
    a->l=merge(a->l,b->l,l,mid);
    a->r=merge(a->r,b->r,mid+1,r);
    a->update();
    return a;
}
tree* split(tree*& a,int l,int r,int k){
    
    if(!k||!a)return 0;
//    printf(" S{%d,%d,%d}",a,l,r);
    if(l==r){
        tree* ret=new tree;
        ret->sum=a->sum;
        a=0;
        return ret;
    }
    tree* ret=new tree;
    int mid=l+r>>1;
    if(Sum(a->l)<k){
        tree* f=split(a->r,mid+1,r,k-Sum(a->l));
        ret->r=f,ret->l=a->l,a->l=0;
//        printf("[%d,%d,%d]",a->l,f,k);
        ret->update();
        a->update();
    } else {
        tree* f=split(a->l,l,mid,k);
        ret->l=f,ret->r=0;
        ret->update();
        a->update();
    }
//    printf("{%d}\n",k);
    return ret;
}
void insert(tree*& a,int l,int r,int k){
    if(!a)a=new tree;
    a->sum++;
    if(l==r)return ;
    int mid=l+r>>1;
    if(k<=mid)insert(a->l,l,mid,k);
    else insert(a->r,mid+1,r,k);
}
int ask(tree* a,int l,int r,int k){
//    printf("[%d,%d]",a->sum,k);
    if(l==r)return l;
    int mid=l+r>>1;
    if(Sum(a->l)<k)return ask(a->r,mid+1,r,k-Sum(a->l));
    else return ask(a->l,l,mid,k);
}
tree* newnode(int k,int n){
    tree* ret=0;
    insert(ret,0,n,k);
    return ret;
}
void print(tree* a,int l,int r,bool type){
    if(!a)return ;
    if(l==r){
        printf("%d ",l);
        return ;
    }
    int mid=l+r>>1;
    if(type){
        print(a->r,mid+1,r,type);
        print(a->l,l,mid,type);
    } else {
        print(a->l,l,mid,type);
        print(a->r,mid+1,r,type);    
    }
}
int n,m;
set<data>st;
int main(){
//    freopen("in.txt","r",stdin);
    scanf("%d%d",&n,&m);
    for(int i=1,a;i<=n;++i)
        scanf("%d",&a),st.insert(data(i,i,0,newnode(a,n)));

    for(int i=1,k,op,l,r;i<=m;++i){
        scanf("%d%d%d",&op,&l,&r);
        tree* res=0;
        sit it=st.lower_bound(data(0,l,0,0));
        while(it!=st.end()&&it->l<=r){
            data d=*it;
            sit xt=it;xt++;
            st.erase(it);it=xt;
            tree* g=d.ptr;
            if(d.l<=l&&r<=d.r){
                if(op==d.type){
                    st.insert(data(d.l,d.r,d.type,g));
                    goto end;
                } else if(d.type){
                    tree* ptr=split(g,0,n,d.r-r);
                    res=split(g,0,n,r-l+1);
                    if(Sum(g)!=0)st.insert(data(d.l,l-1,d.type,g));
                    if(Sum(ptr)!=0)st.insert(data(r+1,d.r,d.type,ptr));
                } else {
                    tree* ptr=split(g,0,n,l-d.l);
                    res=split(g,0,n,r-l+1);
                    if(Sum(ptr)!=0)st.insert(data(d.l,l-1,d.type,ptr));
                    if(Sum(g)!=0)st.insert(data(r+1,d.r,d.type,g));    
                }
                st.insert(data(l,r,op,res));
                goto end;
                
            } else if(l<=d.l&&d.r<=r){
                res=merge(res,g,0,n);
            } else if(d.l<l){
                if(d.type){
                    k=d.r-l+1;
                    tree* ptr=split(g,0,n,k);
                    res=merge(res,ptr,0,n);
                    if(Sum(g)!=0)st.insert(data(d.l,l-1,d.type,g));
                } else {
                    k=l-d.l;
                    tree* ptr=split(g,0,n,k);
                    res=merge(res,g,0,n);
                    if(Sum(ptr)!=0)st.insert(data(d.l,l-1,d.type,ptr));
                }
            } else if(d.r>r){
                if(d.type){
                    k=d.r-r;
                    tree* ptr=split(g,0,n,k);
                    res=merge(res,g,0,n);
                    if(Sum(ptr)!=0)st.insert(data(r+1,d.r,d.type,ptr));
                } else {
                    k=r-d.l+1;
                    tree* ptr=split(g,0,n,k);
                    res=merge(res,ptr,0,n);
                    if(Sum(g)!=0)st.insert(data(r+1,d.r,d.type,g));
                }
            }
        }
        st.insert(data(l,r,op,res));
        end:;
    }
    int q;scanf("%d",&q);
    sit it=st.lower_bound(data(q,q,0,0));
    if(!it->type)printf("%d",ask(it->ptr,0,n,q-it->l+1));
    else printf("%d",ask(it->ptr,0,n,it->r-q+1));
}
```

---

## 作者：Limit (赞：41)

一道十分神奇的线段树题,做法十分的有趣.

- ## 前置芝士

1.[线段树](https://baike.baidu.com/item/%E7%BA%BF%E6%AE%B5%E6%A0%91/10983506?fr=aladdin):一个十分基础的数据结构,在这道题中起了至关重要的作用.

2.一种基于01串的神奇的二分思想:在模拟赛中出现了[这道题](https://www.luogu.com.cn/problem/AT2165),可以先去做一下,这样可能有助于理解.

- ## 具体做法

可以发现sort是非常慢的,每次多要$O(N\log_2N)$,最后的时间复杂度为$O(MN\log_2N)$,肯定是会T的,而且sort这个东西也不是很好去维护.可以发现,最后需要查询的数只有一个,于是就可以想到离线的做法.$N$虽然不小,但其实并不算大,$O(N\log^2_2N)$是可以过的,那么有没有这样的方法呢,那自然是有的,所以就要用到01串的一种神奇的用法了.
对于每一次sort的时间复杂度为$O(N\log_2N)$,那么如果这时一个01串呢,可以发现这样的时间复杂度就可以变为$O(N)$,而且这时区间覆盖,再用线段树维护就只要$O(\log_2N)$.

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200115194722648.jpg)

(如这样一个01序列,灰色为1,白色为0,只要查询出区间的和,将最后的这几个覆盖为1,前面覆盖为0,这样为升序,降序同理)
这样就出现了一种单调性,可以发现如果将这个序列中大于等于最终答案的数改为1,小于改为0,那么最后在答案位置的数就一定是1了,反之则一定是0,所以就可以二分答案了,最终的时间复杂度为$O(M\log^2_2N)$.(二分为$O(\log_2N)$,每一次check需要$O(M\log_2N)$)

- ## 代码

```cpp
#include<bits/stdc++.h>
#define rap(i,first,last) for(int i=first;i<=last;++i)
//线段树标准define
#define Lson (now<<1)
#define Rson (now<<1|1)
#define Middle ((left+right)>>1)
#define Left Lson,left,Middle
#define Right Rson,Middle+1,right
#define Now nowleft,nowright
using namespace std;
const int maxN=1e5+7;
int N,M,Q;
int L[maxN],R[maxN];
int arr[maxN];
bool UD[maxN];
struct Lazy//lazy标记
{
	int cover;
	bool covercheck;//用一个bool型标记这个位置需不需要cover
};
struct Tree//这是一颗资瓷区间覆盖和区间查询和的线段树
{
	int sum;
	Lazy lazy;
}tree[maxN*4];
void PushUp(int now)
{
	tree[now].sum=tree[Lson].sum+tree[Rson].sum;//合并左右子树
}
void Build(int k,int now=1,int left=1,int right=N)//建树
{
	tree[now].lazy.covercheck=0;
	if(left==right)
	{
		tree[now].sum=(arr[left]>=k);//在大于等于k时的值为1,小于为0
		return;
	}
	Build(k,Left);
	Build(k,Right);
	PushUp(now);
}
void Down(int now,int left,int right,int cover)//修改这棵树
{
	tree[now].sum=(right-left+1)*cover;
	tree[now].lazy.covercheck=1;
	tree[now].lazy.cover=cover;
}
void PushDown(int now,int left,int right)//下传标记
{
	if(tree[now].lazy.covercheck)//有标记才下传
	{
		Down(Left,tree[now].lazy.cover);
		Down(Right,tree[now].lazy.cover);
		tree[now].lazy.covercheck=0;
	}
}
void UpData(int nowleft,int nowright,int cover,int now=1,int left=1,int right=N)//区间覆盖部分
{
	if(nowright<left||right<nowleft)return;
	if(nowleft<=left&&right<=nowright)
	{
		Down(now,left,right,cover);//直接修改
		return;
	}
	PushDown(now,left,right);//下传标记
	UpData(Now,cover,Left);//修改左子树
	UpData(Now,cover,Right);//修改右子树
	PushUp(now);//合并
}
int Query(int nowleft,int nowright,int now=1,int left=1,int right=N)//查询区间和
{
	if(nowright<left||right<nowleft)return 0;
	if(nowleft<=left&&right<=nowright)//直接返回
	{
		return tree[now].sum;
	}
	PushDown(now,left,right);//下传标记
	//值为左右子树的值之和
	int result=Query(Now,Left)+Query(Now,Right);
	PushUp(now);//需要合并
	return result;
}
bool check(int middle)//check的部分
{
	Build(middle);//将大于等于middle我改为1,小于为0
	int num;
	rap(i,1,M)
	{
		num=Query(L[i],R[i]);//其中1的个数
		if(UD[i])
		{
			//降序修改
			UpData(L[i],L[i]+num-1,1);//前num个为1
			UpData(L[i]+num,R[i],0);//后面的为0
		}
		else
		{
			//升序同理
			num=R[i]-L[i]+1-num;
			UpData(L[i],L[i]+num-1,0);
			UpData(L[i]+num,R[i],1);
		}
	}
	return Query(Q,Q);//返回最终位置的值
}
int getanswer()//二分答案
{
	int left=1,right=N;//因为这是一个排列,所以这个数是在1~N的范围内
	int answer=-1;
	while(left<=right)
	{
		if(check(Middle))
		{
			//如果可以就记录答案,并且修改left
			answer=Middle;
			left=Middle+1;
		}
		else
		{
			//不可以就修改right
			right=Middle-1;
		}
	}
	return answer;//返回最终答案
}
int main()
{
	//离线做法
	scanf("%d%d",&N,&M);
	rap(i,1,N)scanf("%d",&arr[i]);
	rap(i,1,M)scanf("%d%d%d",&UD[i],&L[i],&R[i]);
	scanf("%d",&Q);
	printf("%d",getanswer());//输出答案
	return 0;
}
```
一种神奇的思路.

Updata 2020.3.23

分享一种本题不用STL的在线做法.

# 分析

本题有一种通过二分做到的 $\mathcal{O}(mlog_2^2n)$ 的做法,但是理解起来比较麻烦,而且时间复杂度也比较高,而且只可以查询一个数,甚至不可以在线做,显然这个方法并不优秀,那么是否存在一种容易理解且有着优秀时间复杂度的做法呢,这显然是有的.

先要了解一下线段树分裂这个东西,可以看看[这道题](https://www.luogu.com.cn/problem/P5494),可以算是线段树分裂的模板题,实现起来也比较简单,但是这道题中的分裂和那道题又有所不同,具体下面会讲到.

先考虑如何排序,排序中有一种排序是桶排,那么考虑如何维护桶排呢,自然就会想到权值线段树,对于每一段有序的区间都开一颗权值线段树去维护就好了,如果需要将一段区间排序,那么这段区间的起点和终点可能是在一段有序数列的中间,这时就需要将这颗线段树分裂开来分裂开来的区间自然也是有序的,分裂之后排序的区间就被分成了若干个连续且不重合的区间,每个区间都是一颗权值线段树,那么只要线段树合并一下就好了.

### 关于查询某段区间内涉及到的权值线段树的根节点编号

这个东西可以用set维护,但是为了照顾其他语言的选手(~~其实就是我不会~~),有一种很简单的线段树的维护方法.线段树中每个节点维护两个东西,一个是当前区间内的数是否相同,还有一个是如果相同,则数是什么.然后查询的时候只要这段查询区间内的节点上遍历就好了,如果当前位置已经全部相同就没有必要向下遍历,不同就继续向下遍历.

这里的分裂是分裂范围不固定的,只要求分裂出的树中恰好有 $k$ 个数(从大到小或从小到大的前 $k$ 个数).

## 关于时间复杂度证明

关于上面这个方法的时间复杂度证明:

(我太菜了,证明未必对)

可以发现每次修改之后修改涉及到的区间最多只会变成三个区间,每次查询的时候一个连续相同的区间最多只会被查询到 $log_2n$ 次,所以均摊时间复杂度就是 $\mathcal{O}(log_2n)$.

关于线段树合并的时间复杂度证明:

线段树合并的时间复杂度是总共线段树上节点的个数,因为每次合并两个点就会减少一个节点,每次分裂只会多出 $log_2n$ 个节点,开始有 $nlog_2n$ 个节点,所以均摊每次操作的时间复杂度是 $\mathcal{O}(log_2n)$.

# 代码

```cpp
#include<bits/stdc++.h>
#define REP(i,first,last) for(int i=first;i<=last;++i)
#define DOW(i,first,last) for(int i=first;i>=last;--i)
using namespace std;
const int MAXN=1e5+7;
int n,m;
int arr[MAXN];
int first_root[MAXN];
int change_root[MAXN];//修改的线段树的根节点
int change_cnt;//修改的线段树的个数
namespace root//两颗线段树,防止重变量名
{
	struct LazyTag//区间覆盖的懒标记
	{
		int check_cover;
		int cover;
		void CleanLazyTag()
		{
			check_cover=0;
			cover=0;
		}
	}for_make;
	LazyTag MakeLazyTag(int cover)
	{
		for_make.check_cover=1;
		for_make.cover=cover;
		return for_make;
	}
	struct SegmentTree
	{
		bool check;//判断区间内的数是否相同
		int num;//相同则记录这个数
		LazyTag tag;
	}sgt[MAXN*4];
	#define LSON (now<<1)
	#define RSON (now<<1|1)
	#define MIDDLE ((left+right)>>1)
	#define LEFT LSON,left,MIDDLE
	#define RIGHT RSON,MIDDLE+1,right
	#define NOW now_left,now_right
	void PushUp(int now)
	{
		sgt[now].check=(sgt[LSON].check&sgt[RSON].check)&(sgt[LSON].num==sgt[RSON].num);
        //如果子树都是全部相同且子树的数相同
		if(sgt[now].check)//如果全部相同则记录一下数
		{
			sgt[now].num=sgt[LSON].num;
		}
	}
	void Build(int now=1,int left=1,int right=n)//建树部分
	{
		sgt[now].tag.CleanLazyTag();
		if(left==right)
		{
			sgt[now].num=first_root[left];
			sgt[now].check=1;
			return;
		}
		Build(LEFT);
		Build(RIGHT);
		PushUp(now);
	}
	void Down(LazyTag tag,int now)//标记下传的修改
	{
		sgt[now].num=tag.cover;
		sgt[now].check=1;
		sgt[now].tag.cover=tag.cover;
		sgt[now].tag.check_cover=1;
	}
	void PushDown(int now)//下传标记
	{
		if(sgt[now].tag.check_cover)//如果有覆盖才下传
		{
			Down(sgt[now].tag,LSON);
			Down(sgt[now].tag,RSON);
			sgt[now].tag.CleanLazyTag();
		}
	}
	void Updata(int now_left,int now_right,int cover,int now=1,int left=1,int right=n)//区间覆盖
	{
		if(now_right<left||right<now_left)
		{
			return;
		}
		if(now_left<=left&&right<=now_right)
		{
			Down(MakeLazyTag(cover),now);
			return;
		}
		PushDown(now);
		Updata(NOW,cover,LEFT);
		Updata(NOW,cover,RIGHT);
		PushUp(now);
	}
	int last_visit;
	void Query(int now_left,int now_right,int now=1,int left=1,int right=n)//查询部分
	{
		if(now_right<left||right<now_left)
		{
			return;
		}
		if(now_left<=left&&right<=now_right)
		{
			if(sgt[now].check)//如果查询到区间内的数全部相同则不用继续向下
			{
				if(sgt[now].num^last_visit)//如果和上一次查询的结果不同则放入数组
				{
					change_root[++change_cnt]=sgt[now].num;
					last_visit=sgt[now].num;
				}
				return;
			}
		}
		PushDown(now);//下传标记
		Query(NOW,LEFT);
		Query(NOW,RIGHT);
	}
	void QueryRoot(int now_left,int now_right)
	{
		last_visit=0;//初始化
		change_cnt=0;
		Query(NOW);//查询
	}
	#undef LSON
	#undef RSON
	#undef MIDDLE
	#undef LEFT
	#undef RIGHT
	#undef NOW
}
namespace sort
{
	struct Range//记录每个区间的信息
	{
		int left,right;//尅是和结束位置
		bool order;//升序还是降序
	}range[MAXN*32];
	struct SegmentTree//动态开点权值线段树,需要维护区间和
	{
		int lson,rson,sum;
	}sgt[MAXN*32];
	#define LSON sgt[now].lson
	#define RSON sgt[now].rson
	#define MIDDLE ((left+right)>>1)
	#define LEFT LSON,left,MIDDLE
	#define RIGHT RSON,MIDDLE+1,right
	int cnt=0,tot=0;
	int rubbish[MAXN*32];
	int NewNode()//建一个新节点
	{
		if(tot)
		{
			return rubbish[tot--];
		}
		return ++cnt;
	}
	void DeleteNode(int &now)//空间回收
	{
		sgt[now].lson=sgt[now].rson=sgt[now].sum=0;
		rubbish[++tot]=now;
		now=0;
	}
	void PushUp(int now)//合并
	{
		sgt[now].sum=sgt[LSON].sum+sgt[RSON].sum;
	}
	void SplitFormerKth(int &tree1,int &tree2,int k,int left=1,int right=n)//分裂从小到大前k个数
	{
		if(k<=0)
		{
			return;
		}
		if(sgt[tree1].sum<=k)//如果当前查找的k大于当前区间大小就可以将原树中的这部分放入新树了
		{
			tree2=tree1;
			tree1=0;
			return;
		}
		tree2=NewNode();
		int sum=sgt[sgt[tree1].lson].sum;
		SplitFormerKth(sgt[tree1].lson,sgt[tree2].lson,k,left,MIDDLE);//想查询kth一样查询
		SplitFormerKth(sgt[tree1].rson,sgt[tree2].rson,k-sum,MIDDLE+1,right);
		PushUp(tree1);
		PushUp(tree2);
	}
	void SplitLastKth(int &tree1,int &tree2,int k,int left=1,int right=n)//分裂从大到小前k个数
	{
		if(k<=0)//做法同理
		{
			return;
		}
		if(sgt[tree1].sum<=k)
		{
			tree2=tree1;
			tree1=0;
			return;
		}
		tree2=NewNode();
		int sum=sgt[sgt[tree1].rson].sum;
		SplitLastKth(sgt[tree1].rson,sgt[tree2].rson,k,MIDDLE+1,right);
		SplitLastKth(sgt[tree1].lson,sgt[tree2].lson,k-sum,left,MIDDLE);
		PushUp(tree1);
		PushUp(tree2);
	}
	void Merge(int &tree1,int &tree2,int left=1,int right=n)//线段树合并
	{
		if(!tree1||!tree2)//如果两棵树中有一棵树没有当前节点就直接用有的那棵
		{
			tree1+=tree2;
			return;
		}
		Merge(sgt[tree1].lson,sgt[tree2].lson,left,MIDDLE);//向下递归合并
		Merge(sgt[tree1].rson,sgt[tree2].rson,MIDDLE+1,right);
		DeleteNode(tree2);//tree2以后不会再用到了,就可以删了,节省空间
		PushUp(tree1);
	}
	void Updata(int num,int val,int &now,int left=1,int right=n)//单点修改,建树时用,所以其实没什么用
	{
		if(num<left||right<num)
		{
			return;
		}
		if(!now)
		{
			now=NewNode();
		}
		if(left==right)
		{
			sgt[now].sum+=val;
			return;
		}
		Updata(num,val,LEFT);
		Updata(num,val,RIGHT);
		PushUp(now);
	}
	void Build()//建树
	{
		REP(i,1,n)//一个点就是一个有序的区间,暴力建树
		{
			first_root[i]=0;
			Updata(arr[i],1,first_root[i]);
			range[first_root[i]].left=range[first_root[i]].right=i;
			range[first_root[i]].order=0;
		}
		root::Build();//还要把区间部分树也建一下
	}
	int new_tree;
	void SplitFKth(int &tree1,int &tree2,int k)//分裂区间前k个
	{
		if(range[tree1].order==0)//需要判断降序还是升序
		{
			SplitFormerKth(tree1,tree2,k);
		}
		else
		{
			SplitLastKth(tree1,tree2,k);
		}
	}
	void SplitLKth(int &tree1,int &tree2,int k)//同理取出后k个
	{
		if(range[tree1].order==1)
		{
			SplitFormerKth(tree1,tree2,k);
		}
		else
		{
			SplitLastKth(tree1,tree2,k);
		}
	}
	int first_root,last_root;
	void Sort(int now_left,int now_right,int order)
	{
		root::QueryRoot(now_left,now_right);//先查询出设计到的区间的线段树的根节点
		first_root=0;//前面多出的部分
		last_root=0;//后面多出的部分
		if(now_left-range[change_root[1]].left)//如果前面有多出部分就分裂出来
		{
			SplitFKth(change_root[1],first_root,now_left-range[change_root[1]].left);//分裂多出部分
			range[first_root].left=range[change_root[1]].left;//新的区间左边和开始区间相同
			range[first_root].right=now_left-1;//右边为修改区间边上
			range[first_root].order=range[change_root[1]].order;//排序方式和原来相同
			root::Updata(range[first_root].left,range[first_root].right,first_root);//重新覆盖上新的节点编号
		}
		if(range[change_root[change_cnt]].right-now_right)//后面同理
		{
			SplitLKth(change_root[change_cnt],last_root,range[change_root[change_cnt]].right-now_right);
			range[last_root].left=now_right+1;
			range[last_root].right=range[change_root[change_cnt]].right;
			range[last_root].order=range[change_root[change_cnt]].order;
			root::Updata(range[last_root].left,range[last_root].right,last_root);
		}
		REP(i,2,change_cnt)//全部合并起来
		{
			Merge(change_root[1],change_root[i]);
		}
		range[change_root[1]].left=now_left;//新区间范围就是修改的范围
		range[change_root[1]].right=now_right;
		range[change_root[1]].order=order;//排序方式也是修改方式
		root::Updata(now_left,now_right,change_root[1]);
	}
	int QueryKth(int k,int now,int left=1,int right=n)//查询k大,没什么可以说的
	{
		if(left==right)
		{
			return left;
		}
		if(sgt[sgt[now].lson].sum>=k)
		{
			return QueryKth(k,LEFT);
		}
		else
		{
			return QueryKth(k-sgt[sgt[now].lson].sum,RIGHT);
		}
	}
	int Query(int k)//查询第k个位置
	{
		root::QueryRoot(k,k);//这道区间
		if(range[change_root[1]].order==0)//分类查询kth
		{
			return QueryKth(k-range[change_root[1]].left+1,change_root[1]);
		}
		else
		{
			return QueryKth(range[change_root[1]].right-k+1,change_root[1]);
		}
	}
	#undef LSON
	#undef RSON
	#undef MIDDLE
	#undef LEFT
	#undef RIGHT
}
int main()
{
	scanf("%d%d",&n,&m);
	REP(i,1,n)
	{
		scanf("%d",&arr[i]);
	}
	sort::Build();
	int left,right,order,k;
	REP(i,1,m)
	{
		scanf("%d%d%d",&order,&left,&right);
		sort::Sort(left,right,order);
	}
	scanf("%d",&k);
	printf("%d",sort::Query(k));
	return 0;
}
```

---

## 作者：FlashHu (赞：36)

### 线段树分裂

以某个键值为中点将线段树分裂成左右两部分，应该类似Treap的分裂吧（我菜不会Treap）。一般应用于区间排序。

方法很简单，就是把分裂之后的两棵树的重复的$\log$个节点新建出来，单次时间复杂度严格$O(\log n)$。

至于又有合并又有分裂的复杂度，蒟蒻一直不会比较有说服力的证明，直到看见[SovietPower巨佬的题解](https://www.cnblogs.com/SovietPower/p/9300819.html)

对于只有合并：合并两棵线段树的过程，是找到它们$x$个重合的节点的位置，并将它们合并，而对于不重合的节点会跳过。

注意到合并与分裂类似互逆过程，也就是说可以看做是删掉了这$x$个节点。

所以可以得出，时间复杂度上界，等于被删去的节点数的上界，不大于若干线段树最开始的节点数。

那么，对于一些既有合并又有分裂的题目，复杂度也是可以分析滴！

$n$棵线段树初始有$O(n\log n)$的节点，每一次分裂只会新增$O(\log n)$的节点

于是总点数就是$O((n+m)\log n)$级别的，线段树合并的总代价就不会超过$O((n+m)\log n)$了。

接下来回到这题

如果一个区间有序，那么顺序是唯一的，我们就可以把它们插到一个权值线段树里，记录一下是升序还是降序。区间排序就变成了线段树合并。

但是我们的排序端点可能会落在一个有序区间内，这时候就要拆开。额外用一个set标记已经有序的区间（像珂朵莉树一样），需要拆开时线段树分裂。

~~突然暂时变成了洛谷rk1~~
```cpp
#include<bits/stdc++.h>
#define R register int
#define G if(++ip==ie)if(fread(ip=buf,1,SZ,stdin))
using namespace std;
typedef set<int>::iterator IT;
const int SZ=1<<19,N=1e5+9,M=6e6;
char buf[SZ],*ie=buf+SZ,*ip=ie-1;
inline int in(){
	G;while(*ip<'-')G;
	R x=*ip&15;G;
	while(*ip>'-'){x*=10;x+=*ip&15;G;}
	return x;
}
int p,rt[N],lc[M],rc[M],s[M],o[N];
set<int>t;
void ins(R&x,R l,R r,R k){
	s[x=++p]=1;
	if(l==r)return;
	R m=(l+r)>>1;
	k<=m?ins(lc[x],l,m,k):ins(rc[x],m+1,r,k);
}
int qry(R x,R l,R r){
	if(l==r)return l;
	R m=(l+r)>>1;
	return lc[x]?qry(lc[x],l,m):qry(rc[x],m+1,r);
}
void mer(R&x,R y){//合并
	if(!(x&&y)){x|=y;return;}
	s[x]+=s[y];
	mer(lc[x],lc[y]);
	mer(rc[x],rc[y]);
}
void spl(R&x,R y,R k,R o){//分裂
	if(s[y]==k)return;
	s[x=++p]=s[y]-k;s[y]=k;
	if(o){
		if(k<=s[rc[y]])spl(rc[x],rc[y],k,o),lc[x]=lc[y],lc[y]=0;
		else  spl(lc[x],lc[y],k-s[rc[y]],o);
	}
	else{
		if(k<=s[lc[y]])spl(lc[x],lc[y],k,o),rc[x]=rc[y],rc[y]=0;
		else  spl(rc[x],rc[y],k-s[lc[y]],o);
	}
}
IT Split(R p){//拆区间
	IT i=t.lower_bound(p);
	if(*i==p)return i;
	--i;spl(rt[p],rt[*i],p-*i,o[p]=o[*i]);
	return t.insert(p).first;
}
int main(){
	R n=in(),m=in();
	t.insert(n+1);
	for(R i=1;i<=n;++i)
		ins(rt[i],0,n,in()),t.insert(i);
	while(m--){
		R op=in(),l=in(),r=in();
		IT il=Split(l),ir=Split(r+1);
		for(IT i=++il;i!=ir;++i)mer(rt[l],rt[*i]);
		o[l]=op;t.erase(il,ir);
	}
	R q=in();
	Split(q);Split(q+1);
	printf("%d\n",qry(rt[q],0,n));
	return 0;
}
```

---

## 作者：一扶苏一 (赞：18)

[其实点这里也不会获得更好的阅读体验](https://www.cnblogs.com/yifusuyi/p/10438005.html)

## Description

给定一个长度为 $n$ 的排列，有 $m$ 次操作，每次选取一段局部进行升序或降序排序，问你一波操作后某个位置上的数字是几

## Hint

$1~\leq~n,~m~\leq~10^5$

## Solution

有两种做法，一种在线一种离线，这里把在线部分讲得更清楚点吧……

考虑离线算法，我们二分该位置上的答案，将大于该数的元素置为 $1$，小于该数的元素置为 $0$，然后模拟所有的排序并检验。由于使用线段树对 $0/1$ 序列多次局部排序可以做到 $O(m~\log n~+~n)$ 的复杂度，所以总复杂度为 $O(m~\log^2 n)$。

具体排序的做法为使用线段树维护当前区间有多少个 $1$，不妨设为 $x$ 个。如果对该区间升序排序，则将后面 $x$ 个数置为 $1$，剩下的置为 $0$，否则将前面 $x$ 个数置为 $1$，其余置为 $0$。于是一次操作的复杂度为 $O(\log n)$，于是进行 $m$ 次操作的复杂度为 $O(m~\log n)$。

考虑在线做。发现对于任意的时刻我们都有一些区间是排好序的。那么现在我们的问题是每次排序操作后合并被排序操作覆盖的区间。考虑到对于两个序列的按序合并可以使用权值线段树轻松做到，我们对每个排好序的区间分别维护一棵权值线段树。然后用一个 ``set`` 维护这些区间。对于被该排序操作完全覆盖的区间，我们可以直接进行线段树合并，而对于区间两侧的被覆盖了一部分的两个区间，可以先分裂成被完全覆盖的区间和完全不被覆盖的区间再进行合并。例如被排序的区间是 $[l,~r]$，左侧被覆盖了一部分的区间为 $[l_0,~y_0]$，其中 $l_0~<~l~<~r_0$，那么将区间 $[l_0,~r_0]$ 拆分成 $[l_0,~l - 1]~\bigcap~[l,~r_0]$ 两个区间，然后对 $[l,~r_0]$ 与其他被完全覆盖的区间进行合并即可。

考虑复杂度分析：

如果不考虑线段树分裂操作，我们对区间的操作实质上是将很多的小区间合并成至少一个大区间。考虑到对 $n$ 个长度为 $1$ 的小区间全部合并成一个大区间的复杂度为 $O(n~\log n)$，于是 ``merge`` 部分的的总复杂度为 $O(n~\log n)$。考虑分裂，一次排序操作后会分裂出 $O(1)$ 个新区间，于是 $m$ 次操作后会分裂出 $O(m)$ 个新区间，合并这 $O(m)$ 个区间的复杂度仍为 $O(m~\log n)$，考虑到每次分裂是严格 $O(\log n)$ 的，且会进行 $O(m)$ 次排序，所以分裂操作对复杂度的总贡献仍是 $O(m~\log n)$。于是总复杂度为 $O((n+m)~\log n)$。比上面的离线算法更优秀。同时这个算法可以解决查询任意多个位置上的数字，而不是仅仅一个。

## Code

在分裂区间的时候有很多小细节需要注意……另外下面的代码存在一定的内存泄漏问题，不过总共被泄露的内存是 $O((n+m)~\log n)$ 级别的，对空间复杂度不产生影响，是可以接受的。

~~其实是我不知道为什么回收空间会莫名其妙 RE~~

```cpp
#include <cstdio>
#include <set>
#include <algorithm>
#ifdef ONLINE_JUDGE
#define freopen(a, b, c)
#endif

typedef long long int ll;

namespace IPT {
	const int L = 1000000;
	char buf[L], *front=buf, *end=buf;
	char GetChar() {
		if (front == end) {
			end = buf + fread(front = buf, 1, L, stdin);
			if (front == end) return -1;
		}
		return *(front++);
	}
}

template <typename T>
inline void qr(T &x) {
	char ch = IPT::GetChar(), lst = ' ';
	while ((ch > '9') || (ch < '0')) lst = ch, ch=IPT::GetChar();
	while ((ch >= '0') && (ch <= '9')) x = (x << 1) + (x << 3) + (ch ^ 48), ch = IPT::GetChar();
	if (lst == '-') x = -x;
}

namespace OPT {
	char buf[120];
}

template <typename T>
inline void qw(T x, const char aft, const bool pt) {
	if (x < 0) {x = -x, putchar('-');}
	int top=0;
	do {OPT::buf[++top] = static_cast<char>(x % 10 + '0');} while (x /= 10);
	while (top) putchar(OPT::buf[top--]);
	if (pt) putchar(aft);
}

const int maxn = 100010;

struct Tree {
	Tree *ls, *rs;
	int l, r, v;

	Tree() {
		ls = rs = NULL;
		l = r = v = 0;
	}
	
	inline void pushup() {if (this->l != this->r) this->v = (this->ls ? this->ls->v : 0) + (this->rs ? this->rs->v : 0); else this->v = 1;}
};

struct OP {
	int l, r;
	bool up;
	Tree *rot;
	
	inline bool operator<(const OP &_others) const {
		return this->r < _others.r;
	}

	OP(int _l = 0, int _r = 0, bool _up = 0, Tree *_rot = 0) {
		l = _l; r = _r; up = _up; rot = _rot;
	}
};
OP temp;
std::set<OP>s;

int n, m;
int MU[maxn];

void split(int, bool);
void insert(Tree*, int, int, int);
void split(Tree*, Tree*, Tree*, int);
Tree* merge(Tree*, Tree*);
int query(Tree*, int);

int main() {
	freopen("data.in", "r", stdin);
	freopen("my.out", "w", stdout);
	qr(n); qr(m);
	for (int i = 1; i <= n; ++i) {
		auto _rot = new Tree; qr(MU[i]);
		insert(_rot, 1, n, MU[i]); s.insert(OP(i, i, true, _rot));
	}
	for (int j = 1, a, b, c; j <= m; ++j) {
		a = b = c = 0; qr(a); qr(b); qr(c);
		split(b, true); split(c + 1, false);
		auto l = s.lower_bound({0, b, true, NULL}), r = s.lower_bound({0, c + 1, true, NULL});
		auto _tmp = *l;
		for (auto i = s.erase(l); i != r; i = s.erase(i)) {
			_tmp.rot = merge(_tmp.rot, (*i).rot);
		}
		_tmp.l = b; _tmp.r = c; _tmp.up = !a;
		s.insert(_tmp);
	}
	int q = 0; qr(q);
	auto _ans = s.lower_bound({0, q, true, NULL}); auto ans = *_ans;
	int k = ans.up ? q - ans.l + 1 : ans.r - q + 1;
	qw(query(ans.rot, k), '\n', true);
	return 0;
}

int query(Tree *u, int k) {
	if (u->l == u->r) return u->l;
	if (!u->ls) return query(u->rs, k);
	if (u->ls->v >= k) return query(u->ls, k);
	return query(u->rs, k - u->ls->v);
}

Tree* merge(Tree *u, Tree *v) {
	if (!u) return v; else if (!v) return u;
	u->v += v->v;
	u->ls = merge(u->ls, v->ls);
	u->rs = merge(u->rs, v->rs);
	return u;
}

void insert(Tree *u, int l, int r, int v) {
	++u->v;
	if ((u->l = l) == (u->r = r)) return;
	int mid = (l + r) >> 1;
	if (v <= mid) insert(u->ls = new Tree, l, mid, v);
	else insert(u->rs = new Tree, mid + 1, r, v);
}

void split(int x, bool isfront) {
	auto k = s.lower_bound({0, x, true, NULL}); if (k == s.end()) return; auto t = *k;
	if (t.l == x) return;
	s.erase(k);
	int _k = (isfront ? t.r - x + 1: x - t.l), len = t.r - t.l + 1;
	if (t.up == isfront) {
		Tree *_rot = new Tree;
		_k = len - _k; 
		if (!_k) {
			s.insert(t); return;
		}
		split(t.rot, t.rot, _rot, _k);
		if (!t.up) {
			_k = len - _k; std::swap(_rot, t.rot);
		}
		s.insert({t.l, t.l + _k - 1, t.up, t.rot});
		s.insert({t.l + _k, t.r, t.up, _rot});
	} else {
		Tree *_rot = new Tree; 
		if (!_k) {
			s.insert(t); return;
		}
		split(t.rot, t.rot, _rot, _k);
		if (!t.up) {
			std::swap(t.rot, _rot); _k = len -_k;
		}
		s.insert({t.l, t.l + _k - 1, t.up, t.rot});
		s.insert({t.l + _k, t.r, t.up, _rot});
	}
}

void split(Tree *u, Tree *l, Tree *r, int k) {
	l->l = r->l = u->l; r->r = l->r = u->r;
	if (!u->ls) split(u->rs, l->rs ? l->rs : l->rs = new Tree, r->rs ? r->rs : r->rs = new Tree, k);
	else if (k == u->ls->v) {
		l->ls = u->ls; r->rs = u->rs; l->rs = NULL; r->ls = NULL;
	} else if (k < u->ls->v) {
		split(u->ls, l->ls ? l->ls : l->ls = new Tree, r->ls ? r->ls : r->ls = new Tree, k);
		r->rs = u->rs; l->rs = NULL;
	} else {
		split(u->rs, l->rs ? l->rs : l->rs = new Tree, r->rs ? r->rs : r->rs = new Tree, k - u->ls->v);
	l->ls = u->ls; r->ls = NULL;
	}
	l->pushup(); r->pushup();
}
```

## Summary

1、将 $n$ 个长度为 $1$ 的小区间合并为一个大区间的复杂度为 $O(n~\log n)$，理由是这样的开销显然不大于将这些区间顺次插入一棵线段树。

2、合并两个有序序列可以使用合并权值线段树来做到均摊复杂度 $O(\log n)$。

---

## 作者：beretty (赞：17)

  
  首先，这道题只有一组查询，所以可以二分这个数的排名 
  
  每次二分一个要查询的数在序列中的大小排名
  
  (排名指在升序的情况下的排名) 
  
  然后当val[i] >= mid 此位置就为1
  反之则为0
  这样一来，这道题就变成了一个01序列排序，所以就可以用线段树实现logn排序
  
  线段树维护区间和，需要实现区间覆盖
  
  每次排序前先查询排序一共有多少1
  
  升序排序则将r-区间1的数量+1~r改为1
  l~ r-区间1的数量改为0
  
  最后再查询要询问的位置
  
  若要查询的位置为1，那么就增加ta的排名（r=mid-1） 
  
  反之，就降低这个数排名 
  
  由于这个数列是1~n的全排列，所以二分出的结果就是答案
  
  ~~不过好像这题暴力给分挺多的，好像暴力能到80~~
  
```

#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<iostream>
# define ls now<<1
# define rs now<<1|1
const int M = 30005 ;
using namespace std;
inline int read(){
	char c=getchar(); int x=0,w=1;
	while(c>'9'||c<'0'){
		if(c=='-') w=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return x*w;
}
struct Q{
	int opt,l,r;
}q[M];
int n,m,st[M],val[M],tag[M<<2],tree[M<<2],K;
inline void pushup(int now){
	tree[now]=tree[ls]+tree[rs];
}
void build(int l,int r,int now){
	tag[now]=-1;
	if(l==r){
		tree[now]=st[l];
		return ;
	}
	int mid=(l+r)>>1;
	build(l,mid,ls); build(mid+1,r,rs);
	pushup(now);
}
inline void pushdown(int now,int l,int r){
	if(tag[now]<0) return ;
	tag[ls]=tag[rs]=tag[now];
	tree[ls]=tag[now]*l; tree[rs]=tag[now]*r;
	tag[now]=-1;
}
void change(int L ,int R ,int val,int l,int r,int now){
	if(l>R||r<L) return ;
	if(l>=L&&r<=R){
		tree[now]=val*(r-l+1);
		tag[now]=val; return ;
	}
	int mid=(l+r)>>1;
	pushdown(now,mid-l+1,r-mid);
	change(L,R,val,l,mid,ls);
	change(L,R,val,mid+1,r,rs);
	pushup(now);
}
int query(int L, int R,int l,int r,int now){
	if(l>R||r<L) return 0;
	if(l>=L&&r<=R) return tree[now];
	int mid=(l+r)>>1;
	pushdown(now,mid-l+1,r-mid);
	int Ans=0;
	Ans+=query(L, R, l,mid,ls);
    Ans+=query(L, R, mid+1,r,rs);
	return Ans;
}
inline int judge(int mid){
	for(register int i=1;i<=n;++i)
	  if(val[i]>=mid) st[i]=1;
	  else st[i]=0;
	build(1,n,1);
	for(register int i=1;i<=m;++i){
		int l =q[i].l, r= q[i].r ;
		if(q[i].opt==0){
		// 升序排列 
			int num1=query(l,r,1,n,1);
			change(r-num1+1,r,1,1,n,1);
			change(l,r-num1,0,1,n,1);
		}
		else{
		//  降序排列
			int num1=query(l,r,1,n,1);
			change(l,l+num1-1,1,1,n,1);
			change(l+num1,r,0,1,n,1);
		}
	}
	int tmp=query(K,K,1,n,1);
	return tmp;
}
int main(){
	n=read(); m=read();
	for(register int i=1;i<=n;++i) val[i]=read();
	for(register int i=1;i<=m;++i){
		q[i].opt=read(); q[i].l=read(); q[i].r=read();
	}
	K = read() ;
	int L=1 , R=n , Ans=0;
	while(L<=R){
		int mid=(L+R)>>1;
		if(judge(mid))  L=mid+1,Ans=mid ;
		else  R=mid-1;
	}
	printf("%d\n",Ans);
	return 0;
}
```

---

## 作者：yijan (赞：12)

解题思路其他题解很清楚了，。

但是由于是区间推平和寻找个数可以Chtholly树维护

所以，就是个板子。。

但是这里要注意一下，因为数据非随机，显然ODT是会被卡T的
![](https://i.loli.net/2018/10/30/5bd8578fde2f9.png)

然后开了个O2 ， 
![](https://i.loli.net/2018/10/30/5bd857902fc25.png)

ac

```cpp
/*Heroes Never Die!*/
#include "iostream"
#include "cstring"
#include "cstdio"
#include "set"
#include "algorithm"
using namespace std;
#define MAXN 100006
int A[MAXN] , k , n , m;

struct query { int l , r , k ; } q[MAXN];

struct node{
    int l , r , v;
    node( int l , int r = -1 , int v = 0 ) :l(l) , r(r) ,v(v) {}
    node( ) {}
    bool operator < ( const node& t ) const {
        return l < t.l;
    }
};

set<node> S;

set<node>::iterator spli( int pos ) {
    auto it = S.lower_bound( node( pos ) );
    if( it != S.end( ) && it->l == pos ) return it; --it;
    int l = it->l , r = it->r , v = it->v;
    S.erase( it ) , S.insert( node( l , pos - 1 , v ) );
    return S.insert( node( pos , r , v ) ).first;
}
int countone( int l ,int r ) {
    auto itr = spli( r + 1 ) , itl = spli( l ); int res = 0;
    for( ; itl != itr ; ++ itl )
        if( itl->v == 1 ) res += itl->r - itl->l + 1;
    return res;
}

void change( int l , int  r , int v ) {
    auto itr = spli( r + 1 ) , itl = spli( l );
    S.erase( itl , itr ) , S.insert( node( l , r , v ) );
}

bool check( int x ) {
    S.clear();
    for( int i = 1 ; i <= n ; ++ i )
        S.insert( node( i , i , A[i] >= x ) );
    S.insert( node( n + 1 , n + 1 , -1 ) );
    for( int i = 1 ; i <= m ; ++ i ) {
        int l = q[i].l , r = q[i].r , k = q[i].k , numone = countone( l , r );
        if( !k ) change( r - numone + 1 , r , 1 ) , change( l , r - numone , 0 );
        else change( l , l + numone - 1 , 1 ) , change( l + numone , r , 0 );
    }
    return spli( k )->v == 1 ;
}

int main() {
    cin >> n >> m;
    for( int i = 1 ; i <= n ; ++ i ) scanf( "%d" , & A[i] );
    for( int i = 1 ; i <= m ; ++ i ) scanf( "%d%d%d" , &q[i].k , &q[i].l , &q[i].r);
    cin >> k;
    int l = 1 , r = n , m , ans;
    while( l <= r ) {
        m = l + r >> 1;
        if( check(m) ) ans = m , l = m + 1 ;//最后这个位置上是1 ， 那么选的数字大了
        else r = m - 1;
    }
    cout << ans;
}
```

---

## 作者：day_dream (赞：11)

&emsp;其实这题是有nlogn做法的，而且支持在线操作和询问！

&emsp;这题要让我们区间排序，我们发现如果我们将区间放进一个值域线段树中，那它就已经排好序了(要倒序排序的话，打个tag就好啦)。那我们要怎么要排序的区间放到一个值域线段树中呢？

&emsp;这时候,我们就要用到线段树的合并与分裂啦。

&emsp;我们一开始对每个位置开一颗值域线段树(这肯定是要动态开点的)，然后每次只要把我们要排序的区间中的线段树合并起来就相当于完成了一次排序。

&emsp;当然，要排序的区间的开头一段和末尾一段一开始可能不是单独的一棵线段树，这就需要我们将线段树进行分裂。

&emsp;最后，我们合并完线段树当然要知道你这棵线段树是维护那一段区间的，这个可以用链表维护(然而本蒟蒻每次打链表都打挂，我就又开了一棵线段树维护，反正不在复杂度瓶颈，嘿嘿)。

>然后献上本蒟蒻的代码:

```
#include<algorithm>
#include<cstdio>
#define mxn 100010
using namespace std;
int n,m,sl,fh,rt_num,a[mxn];
int b[mxn],rt[mxn];// b是表示升序(0)/降序(1)
struct val_seg
{
    int l,r,sz;
}tre[mxn*400];
struct seg
{
    int mn,id,lt;
}tr[mxn<<2];
int rd()
{
    sl=0;fh=1;
    char ch=getchar();
    while(ch<'0'||'9'<ch) {if(ch=='-') fh=-1; ch=getchar();}
    while('0'<=ch&&ch<='9') sl=sl*10+ch-'0',ch=getchar();
    return sl*fh;
}
void split(int no,int &x,int &y,int k) //分裂
{
    if(!no) return ;
    if(tre[no].sz<=k) {x=no,y=0; return ;}
    else if(k<=0) {x=0,y=no; return ;}
    x=++rt_num;y=++rt_num;
    tre[x].sz=k,tre[y].sz=tre[no].sz-k;
    split(tre[no].l,tre[x].l,tre[y].l,k);
    split(tre[no].r,tre[x].r,tre[y].r,k-tre[tre[no].l].sz);
}
void merge(int &no,int l,int r,int x,int y) //合并
{
    if(!x||!y) {no=x+y; return ;}
    no=++rt_num;tre[no].sz=tre[x].sz+tre[y].sz;
    if(l==r) return ;
    int mid=(l+r)>>1;
    merge(tre[no].l,l,mid,tre[x].l,tre[y].l);
    merge(tre[no].r,mid+1,r,tre[x].r,tre[y].r);
}
void ins(int &no,int l,int r,int x) //一开始对每个位置建的线段树
{
    if(!no) no=++rt_num;
    tre[no].sz++;
    if(l==r) return ;
    int mid=(l+r)>>1;
    if(x<=mid) ins(tre[no].l,l,mid,x);
    else ins(tre[no].r,mid+1,r,x);
}
int find(int no,int l,int r,int k) //查找第k个
{
    if(l==r) return l;
    int mid=(l+r)>>1,t=tre[tre[no].l].sz;
    if(k<=t) return find(tre[no].l,l,mid,k);
    else return find(tre[no].r,mid+1,r,k-t);
}
// 下面这个是用来充当链表的，dalao可以自行跳过
void build(int no,int l,int r)
{
    if(l==r) {tr[no].id=tr[no].mn=l; return ;}
    int mid=(l+r)>>1;
    build(no<<1,l,mid);
    build(no<<1|1,mid+1,r);
    tr[no].mn=min(tr[no<<1].mn,tr[no<<1|1].mn);
}
void pushdown(int no)
{
    if(tr[no].lt)
    {
        tr[no<<1].mn=tr[no<<1].id=tr[no<<1].lt=tr[no].lt;
        tr[no<<1|1].mn=tr[no<<1|1].id=tr[no<<1|1].lt=tr[no].lt;
        tr[no].lt=0;
    }
}
void update(int no,int l,int r,int L,int R,int x)
{
    if(r<L||R<l) return ;
    if(L<=l&&r<=R) {tr[no].mn=tr[no].id=tr[no].lt=x; return ;}
    int mid=(l+r)>>1;
    pushdown(no);
    if(L<=mid) update(no<<1,l,mid,L,R,x);
    if(R>mid) update(no<<1|1,mid+1,r,L,R,x);
    tr[no].mn=min(tr[no<<1].mn,tr[no<<1|1].mn);
}
int query(int no,int l,int r,int x)
{
    if(l==r) return tr[no].id;
    int mid=(l+r)>>1;
    pushdown(no);
    if(x<=mid) return query(no<<1,l,mid,x);
    else return query(no<<1|1,mid+1,r,x);
}
int ask(int no,int l,int r,int x)
{
    if(l==r)
    {
        if(tr[no].id<=x) return l;
        else return 0;
    }
    int mid=(l+r)>>1;
    pushdown(no);
    if(tr[no<<1|1].mn>x) return ask(no<<1,l,mid,x);
    else return ask(no<<1|1,mid+1,r,x);
}
int getrt(int no,int l,int r,int x)
{
    if(!x) return 0;
    if(l==r) return tr[no].id;
    int mid=(l+r)>>1;
    pushdown(no);
    if(tr[no<<1|1].mn>x) return getrt(no<<1,l,mid,x);
    else return getrt(no<<1|1,mid+1,r,x);
}
void solve(int l,int r,int flg)
{
    int L,R,z,k,x,y;
    x=query(1,1,n,l);k=ask(1,1,n,x-1);z=l-1; //k表示前面那棵线段树维护区间的末尾位置
    if(!b[x]) split(rt[x],L,R,l-k-1); //升序的话，直接将前面的分裂出去
    else split(rt[x],R,L,tre[rt[x]].sz-l+k+1); //降序的话，在前面我们要的区间是前面的那些数
    //L是不需要的那些数，R是我们需要的
    if(L&&R) //若其中一个为空，说明它已经独自成一个区间了
    {
        rt[z]=L,rt[z+1]=R,b[z]=b[z+1]=b[x];
        update(1,1,n,k+1,z,z);k=ask(1,1,n,x);update(1,1,n,z+1,k,z+1);
    }
    //下面是对区间最后一段的操作，和上面同理，L、R的意义与上面相反
    y=query(1,1,n,r);k=ask(1,1,n,y-1);z=r+1;
    if(!b[y]) split(rt[y],L,R,r-k);
    else split(rt[y],R,L,tre[rt[y]].sz-r+k);
    if(L&&R)
    {
        rt[z]=R,rt[z-1]=L,b[z]=b[z-1]=b[y];
        update(1,1,n,k+1,z-1,z-1);k=ask(1,1,n,y);update(1,1,n,z,k,z);
    }
    l=query(1,1,n,l);r=query(1,1,n,r);x=l;
    for(int i=r;i!=l;i=getrt(1,1,n,i-1)) merge(rt[l],1,n,rt[l],rt[i]); //合并线段树
    l=ask(1,1,n,l-1)+1;r=ask(1,1,n,r);
    update(1,1,n,l,r,x);b[x]=flg;
}
int main()
{
    n=rd();m=rd();int l,r,typ;
    for(int i=1;i<=n;++i) ins(rt[i],1,n,rd());
    build(1,1,n);
    for(int i=1;i<=m;++i) typ=rd(),l=rd(),r=rd(),solve(l,r,typ);
    int x=rd();l=query(1,1,n,x);
    x-=ask(1,1,n,l-1);
    if(!b[l]) printf("%d\n",find(rt[l],1,n,x));
    else printf("%d\n",find(rt[l],1,n,tre[rt[l]].sz-x+1));
    return 0;
}
```


---

## 作者：米奇奇米 (赞：9)

## 题解-P2824[HEOI2016/TJOI2016]排序

* **题目意思**

就是给你一个排列$A$，接下来有$m$次操作每次将$[l,r]$区间里的数降序或者升序排列，最后询问$Ax$。

* $Solution$

这道题目主要是思想的转化，其他并无难点。对于这种思想的转化可以看[戳这里](https://www.luogu.org/problem/P1627)。

考虑离线。

我们可以二分答案，对于每次二分的答案如果大于$Ai$那么将$Ai$变为$0$否则变为$1$。

然后对于修改为递增序列我们可以先统计出$[l,r]$区间中$1$的个数$gs1$，然后将$[l,r-gs]$区间里的数变为$0$
并且将$[r-gs+1,r]$里的数变为$1$,如果是递减序列也是相近类似的操作。这些都是可以用线段树进行维护的。

对于最后我们只要判断$Ax$是不是为$1$即可。

* $Code$

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn=1e5+5;
const int maxm=4e5+5;

int n,m,op[maxn],val[maxn],ans;
int tr[maxm],tag[maxm],Q;

struct number {
	int opt,l,r;
};
number q[maxn];

inline int read() {
	int sum=0; char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)) 
		sum=sum*10+(ch^48),ch=getchar();
	return sum;
}

inline void build(int rt,int l,int r) {
	tag[rt]=-1;
	if(l==r) {
		tr[rt]=op[l];
		return;
	}
	int mid=(l+r)/2;
	build(rt<<1,l,mid);
	build(rt<<1|1,mid+1,r);
	tr[rt]=tr[rt<<1]+tr[rt<<1|1];
}

inline void push_down(int rt,int l,int r) {
	if(tag[rt]==-1) return;
	int mid=(l+r)/2;
	tr[rt<<1]=(mid-l+1)*tag[rt];
	tr[rt<<1|1]=(r-mid)*tag[rt];
	tag[rt<<1]=tag[rt];
	tag[rt<<1|1]=tag[rt];
	tag[rt]=-1;
}

inline void modify(int rt,int l,int r,int ll,int rr,int val) {
	if(l>rr||r<ll) return;
	if(ll<=l&&r<=rr) {
		tr[rt]=val*(r-l+1);
		tag[rt]=val;
		return;
	}
	push_down(rt,l,r);
	int mid=(l+r)/2;
	if(ll<=mid) modify(rt<<1,l,mid,ll,rr,val);
	if(rr>mid) modify(rt<<1|1,mid+1,r,ll,rr,val);
	tr[rt]=tr[rt<<1]+tr[rt<<1|1];
}

inline int query(int rt,int l,int r,int ll,int rr) {
	if(l>rr||r<ll) return 0;
	if(ll<=l&&r<=rr) return tr[rt];
	push_down(rt,l,r);
	int mid=(l+r)/2;
	int tmp=0;
	if(ll<=mid) tmp+=query(rt<<1,l,mid,ll,rr);
	if(rr>mid) tmp+=query(rt<<1|1,mid+1,r,ll,rr);
	return tmp;
}

inline bool check(int mid,int pos) {
	for ( int i=1;i<=n;i++ ) {
		if(mid>val[i]) op[i]=0;
			else op[i]=1;
	}
	build(1,1,n);
	for ( int i=1;i<=m;i++ ) {
		int opt=q[i].opt;
		int l=q[i].l;
		int r=q[i].r;
		if(!opt) {
			int gs=query(1,1,n,l,r);
			modify(1,1,n,l,r-gs,0);
			modify(1,1,n,r-gs+1,r,1);
		}
		if(opt) {
			int gs=query(1,1,n,l,r);
			modify(1,1,n,l,l+gs-1,1);
			modify(1,1,n,l+gs,r,0); 
		}
	}
	if(query(1,1,n,pos,pos)) return true;
	return false;
}

int main() {
	n=read();
	m=read();
	for ( int i=1;i<=n;i++ ) val[i]=read();
	for ( int i=1;i<=m;i++ ) {
		q[i].opt=read();
		q[i].l=read();
		q[i].r=read();
	}
	Q=read();
	int l=1,r=n;
	while(l<=r) {
		int mid=(l+r)/2;
		if(check(mid,Q)) {
			ans=mid;
			l=mid+1;
		}
		else r=mid-1;
	}
	printf("%d\n",ans);
	return 0;
}

```



---

## 作者：Sai0511 (赞：9)

一道神题ORZ,思路真的很妙啊。    
### 正文部分：          
题意：

给一个序列，可以对某一个区间升序和降序排序，问你最后数列中第$Q$个数是什么？             
乍一看貌似毫无思路，于是我们考虑一个更简单的问题：
如果对$1$个$01$序列执行上面的操作，是不是就可以变得简单一点？        
设某段区间$[l,r]$里总共有$cnt$个1   
那么降序排就是把$l\sim l+cnt - 1$修改为$1$,把$l+cnt \sim r$修改为$0$              
升序排则是把$r-cnt+1\sim r$修改为$1$,$l\sim r-cnt$修改为$0$      
其实一个$01$序列有多少个$1$就是这个序列的和。    
于是这样就变成了一道线段树问题：  
区间修改，区间求和

于是我们回归原题，看是否能用一种“$01$序列”的方法维护原数列。      
**答案是可以的。**      
对于某一个数，我们把大于它的数设为$1$,小于它的数设为$0$，于是我们就得到了一个$01$序列。    
把所有操作全部离线，跑一遍，于是我们就可以二分了。    
为什么可以二分？   
我们设想一下，如果这个$01$序列最后第$Q$位是$1$,说明最后的答案一定比这个数大，否则则一定比这个数小。

而题目又保证了一定为全排列，所以答案肯定只有一个。    
于是这道题就变成了一个二分+线段树问题，可以通过了。

```cpp
#include <bits/stdc++.h>
#define gc getchar
#define il inline
#define lson(x) (x << 1)
#define rson(x) (x << 1 | 1)
const int MAXN = 1e5 + 10;
const int MAXQ = MAXN;
using namespace std;
int n,m,i,j,k,ans,Q;
int a[MAXN];bool b[MAXN];
int tr[MAXN << 2],tag[MAXN << 2];
struct Questions {
	int l,r;bool opt;
	Questions() {l = r = opt = 0;}
	Questions(int L,int R,int Opt) {
		l = L;r = R;opt = Opt;
	}
}query[MAXQ];
il int read() {
	int res = 0;char c;bool sign = 0;
	for(c = gc();!isdigit(c);c = gc()) sign |= c == '-';
	for(;isdigit(c);c = gc()) res = (res << 1) + (res << 3) + (c ^ 48);
	return sign ? -res : res;
}
il void pushup(int num) {
	tr[num] = tr[lson(num)] + tr[rson(num)];
	return;
}
il void init(int num,int l,int r,int val) {
	tr[num] = (r - l + 1) * val;
	tag[num] = val; 
	return;
}
il void pushdown(int num,int l,int r) {
	if(~tag[num]) {
		int mid = l + r >> 1;
		init(lson(num),l,mid,tag[num]);
		init(rson(num),mid + 1,r,tag[num]);
		tag[num] = -1;
	}
	return;
}
void build(int l,int r,int num) {
	if(l == r) {tr[num] = b[l];return;}
	int mid = l + r >> 1;
	build(l,mid,lson(num));
	build(mid + 1,r,rson(num));
	pushup(num);
	return;
}
void modify(int ml,int mr,int l,int r,int num,int val) {
   if(ml <= l && r <= mr) {
        tr[num] = (r - l + 1) * val;
        tag[num] = val;
        return;
    }
    int mid = l + r >> 1;
    pushdown(num,l,r);
    if(ml <= mid) modify(ml,mr,l,mid,lson(num),val);
    if(mid < mr)  modify(ml,mr,mid + 1,r,rson(num),val);
    pushup(num);return; 
}
int Query(int ql,int qr,int l,int r,int num) {
	if(ql <= l && r <= qr) return tr[num];
	pushdown(num,l,r);
	int mid = l + r >> 1,res = 0;
	if(ql <= mid) res += Query(ql,qr,l,mid,lson(num));
	if(mid < qr)  res += Query(ql,qr,mid + 1,r,rson(num));
	return res;
}
il bool judge(int cknum) {
	for(int i = 1;i <= n;i++) {
		b[i] = a[i] >= cknum;
	} 
	memset(tr,0,sizeof(tr));
	memset(tag,-1,sizeof(tag));
	build(1,n,1);
	for(int i = 1;i <= m;i++) {
		int opt = query[i].opt;
		int l = query[i].l;
		int r = query[i].r;
		int cnt = Query(l,r,1,n,1);
		if(!opt) {
			modify(r - cnt + 1,r,1,n,1,1);
			modify(l,r - cnt,1,n,1,0);
		} else {
			modify(l,l + cnt - 1,1,n,1,1);
			modify(l + cnt,r,1,n,1,0);
		}
	}
	return Query(Q,Q,1,n,1);
}
int main() {
	n = read();m = read();
	for(int i = 1;i <= n;i++) a[i] = read();
	for(int i = 1;i <= m;i++) {
		query[i].opt = read();
		query[i].l = read();
		query[i].r = read();
	}		
	Q = read();
	int l = 1,r = n;
	while(l <= r) {
		int mid = l + r >> 1;
		if(judge(mid)) l = mid + 1,ans = mid;
		else r = mid - 1;
	}	
	printf("%d",ans);
	return 0;
}
```




---

## 作者：Leianha (赞：6)

## ODT&二分

看到没有人写关于ODT的题解，所以我决定来一发ODT题解。

首先这道题的的整体思路就是二分，关于二分的正确性可以感性的理解一下：我们每一次二分一个答案，然后将$<mid$的值变为1，$\geq mid$的变为0，每一次只用对0/1序列进行操作，倘若最后我们询问的位置上为0，说明这个位置上的值$< mid$,否则就$\geq mid$，所以它就具有可二分性。

让我们看看对0/1序列的操作，每次排序就相当于整体的0/1序列排序，也就是区间推平操作，所以我们就珂以用幸福的ODT来做这道题啦.我们每一次只用询问一下这个区间里一共有多少个1，然后将$l$到$l+len-1$推平就好辣。当然这需要开O2(否则就死掉了)，实测开了O2后跑的快的飞起。

最后献上我~~丑陋~~的代码

```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<set>
#define IT set<node>::iterator
using namespace std;
int n,m,opt,k,ll,rr,ans;
int a[100010];
int l[100010],r[100010];
int pan[100010];

int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}



struct node
{
	int l,r;
	mutable int val;
	node(int L,int R=-1,int V=0):l(L),r(R),val(V){}
	friend bool operator <(const node &a,const node &b)
	{
		return a.l<b.l;
	}
};

set<node>s;



IT split(int pos)
{
	IT it=s.lower_bound(node(pos));
	if(it!=s.end()&&it->l==pos)return it;
	--it;
	int L=it->l,R=it->r;
	int V=it->val;
	s.erase(it);
	s.insert(node{L,pos-1,V});
	return s.insert(node{pos,R,V}).first;
}

int sum(int l,int r)
{
	IT it2=split(r+1),it1=split(l);
	int res=0;
	for(;it1!=it2;++it1)
	if(it1->val)res+=(it1->r-it1->l+1);
	return res;
}


void tuiping(int l,int r,int v)
{
	IT it2=split(r+1),it1=split(l);
	s.erase(it1,it2);
	s.insert(node{l,r,v});
}

int check(int x)
{
	s.clear();
	int val=(a[1]>=x),len=1;
	for(int i=2;i<=n;++i)
	{
		if((a[i]>=x)!=val)
		{
			s.insert(node{i-len,i-1,val});
			val=(a[i]>=x);len=1;
		}
		else len++;
	}
	s.insert(node{n-len+1,n,val});
	s.insert(node{n+1,n+1,1});
	for(int i=1;i<=m;++i)
	{
		if(pan[i]==0)//升序 
		{
			int lin=r[i]-l[i]+1-sum(l[i],r[i]);//cout<<"lin="<<lin<<endl;
			tuiping(l[i],l[i]+lin-1,0);
			tuiping(l[i]+lin,r[i],1);
		}
		else
		{
			int lin=sum(l[i],r[i]);
			tuiping(l[i],l[i]+lin-1,1);
			tuiping(l[i]+lin,r[i],0);
		}
	}
    return sum(k,k);
}

void slove2()
{
	for(int i=1;i<=m;++i)pan[i]=(bool)read(),l[i]=read(),r[i]=read();
	cin>>k;
	int ans=0;
	ll=1;rr=n;//cout<<check(5)<<endl;;
	while(ll<=rr)
	{
		int mid=(ll+rr)>>1;
		if(check(mid))
		{
			ll=mid+1;
			ans=mid;
		}
		else rr=mid-1;
	}
	cout<<ans;
}



int main()
{
	//freopen("seq.in","r",stdin);
	//freopen("seq.out","w",stdout);
	cin>>n>>m;
	for(int i=1;i<=n;++i)a[i]=read();
	slove2();
	fclose(stdin);fclose(stdout);
	return 0;
}
```


---

## 作者：sdxjzsq (赞：4)

看到题解一堆线段树，写不熟练线段树、老年高三NOIP选手的我默默的开始敲分块...  
主体思想就是二分答案，大概就是不断检查二分出的答案是大了还是小了，这个珂以通过将原数组中大于二分出来的答案的数变成1，小于等于二分出来的答案的数变成0，来把原数组变成一个01序列，之后再对01序列进行题目中的操作，这个只需知道这段区间中有多少个1，然后把前面（降序，升序的话是后面）区间修改成1，其他的修改成0，就珂以快速地实现排序，最后判断要求的位置上是0/1就好了，若为0，则说明要找的数小于等于当前的答案，若为1，则说明要找的数大于当前答案。  
如果看不懂以上的思路的话，也珂以参考其他优秀的题解来对照着看~  
其中区间修改的过程无法用树状数组实现，这让一直用树状数组偷懒的我极其尴尬...  
好在跟ddd大佬在洛谷网校学会了分块，于是乎在调了一晚上bug以后...终于AC了这道题。  
分块的思路大概就是开一个数组sum[i]记录分到的第i块的和是多少，然后再开一个数组tag[i]记录第i块是否被覆盖了，如果被覆盖成了1，那么tag[i]=1,如果被覆盖成了0，那么tag[i]=0.  
代码如下:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+7,maxb=400;//虽然洛谷上的说明是30000，但是实际上数据上界确实是1e5
int n,m,num[maxn],v[maxn],sum[maxb],q,lst=0,block,tag[maxb];
struct oper
{
	int o,l,r;
}a[maxn];//记录操作
inline int getb(int x)
{
	//获得所在的块
	return (x-1)/block+1;
}
inline int getsta(int x)
{
	//获得所在块的起始位置
	return (getb(x)-1)*block+1;
}
inline int getend(int x)
{
	//获得所在块的结束位置
	int tmp=getb(x);
	if(lst==tmp)return n;
	return tmp*block;
}
inline void add(int o)
{
	//o位置上的+1，主要用于块的维护
	v[o]=1;sum[getb(o)]++;
	return;
}
inline void pushdown(int x)
{
	//用于下放tag
	if(tag[x]==2)
	{
		tag[x]=0;
		for(register int i=(x-1)*block+1;i<=x*block;i++)v[i]=0;
	}
	else if(tag[x]==1) 
	{
		tag[x]=0;
		for(register int i=(x-1)*block+1;i<=x*block;i++)v[i]=1;
	}
}
inline void modify(int l,int r,int o)
{
	//将l..r区间内的数都修改成o
	if(l>r)return;
	int bl=getb(l),br=getb(r);
	if(bl==br)
	{
		if(tag[bl])pushdown(bl);
		if(o==1){for(register int i=l;i<=r;i++)if(v[i]==0)sum[bl]++,v[i]=1;}
		else for(register int i=l;i<=r;i++)if(v[i]==1)sum[bl]--,v[i]=0;
		return;
	}
	if(o==1)
	{
		if(l!=getsta(l))//l和r所在的块不完整就暴力更新，否则就直接打tag，下面的查询同理
		{
			if(tag[bl]==2)pushdown(bl);
			if(tag[bl]!=1)
				for(register int i=getend(l);i>=l;i--)
					if(v[i]==0)sum[bl]++,v[i]=1;
		}
		else tag[bl]=1,sum[bl]=block;
		for(register int i=br-1;i>bl;i--)
			tag[i]=1,sum[i]=block;
		if(r!=getend(r)||(lst&&r==n))
		{
			if(tag[br]==2)pushdown(br);
			if(tag[br]!=1)
				for(register int i=getsta(r);i<=r;i++)
				{
					if(v[i]==0)sum[br]++,v[i]=1;
				}
		}
		else tag[br]=1,sum[br]=block;
	}
	else 
	{
		if(l!=getsta(l))
		{
			if(tag[bl]==1)pushdown(bl);
			if(tag[bl]!=2)
				for(register int i=getend(l);i>=l;i--)
					if(v[i]==1)sum[bl]--,v[i]=0;
		}
		else tag[bl]=2,sum[bl]=0;
		for(register int i=br-1;i>bl;i--)
			tag[i]=2,sum[i]=0;
		if(r!=getend(r))
		{
			if(tag[br]==1)pushdown(br);
			if(tag[br]!=2)
				for(register int i=getsta(r);i<=r;i++)
					if(v[i]==1)sum[br]--,v[i]=0;
		}
		else tag[br]=2,sum[br]=0;
	}
}
inline int query(int l,int r)
{
	int ans=0;
	int bl=getb(l),br=getb(r);
	if(bl==br)
	{
		if(tag[bl])
		{
			if(tag[bl]==1)return  r-l+1;
			else return 0;
		}
		if(br-bl+1==block)return sum[bl];
		for(register int i=l;i<=r;i++)ans+=v[i];
		return ans;
	}
	if(l!=getsta(l))
	{
		if(tag[bl]){if(tag[bl]==1)ans+=getend(l)-l+1;}
		else for(register int i=getend(l);i>=l;i--)ans+=v[i];
		bl++; 
	}
	if(r!=getend(r))
	{
		if(tag[br]){if(tag[br]==1)ans+=r-getsta(r)+1;}
		else for(register int i=getsta(r);i<=r;i++)ans+=v[i];
		br--;
	}
	for(register int i=bl;i<=br;i++)ans+=sum[i];
	return ans;
}
inline int check(int x)
{
	int tot;
	memset(sum,0,sizeof(sum));
	memset(tag,0,sizeof(tag));
	memset(v,0,sizeof(v));
	for(register int i=1;i<=n;i++)
		if(num[i]>x)add(i);
	for(register int i=1;i<=m;i++)
	{
		int l=a[i].l,r=a[i].r,o=a[i].o;
		tot=query(l,r);
		if(a[i].o)
		{
			modify(l,l+tot-1,1);
			modify(l+tot,r,0);
		}
		else
		{
			modify(r-tot+1,r,1);
			modify(l,r-tot,0);
		}
	}
	if(tag[getb(q)]==1||(v[q]==1&&tag[getb(q)]==0))return 1;
	else return 0;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=n;i++)
		scanf("%d",&num[i]);
	for(register int i=1;i<=m;i++)
		scanf("%d%d%d",&a[i].o,&a[i].l,&a[i].r);
	block=sqrt(n);
	if(getend(n)>n)lst=getb(n);
	scanf("%d",&q);
	int l=1,r=n;
	while(l<r)
	{
		int mid=l+r>>1;
		if(check(mid))l=mid+1;
		else r=mid;
	}
	printf("%d",r);
	return 0;
}
```
另外附送数据生成器一枚：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5,maxm=1e5;//珂手玩的样例：maxn=8,maxm=5 
inline int getint(int x)
{
	return rand()%x+1;
}
inline int getf()
{
	if(rand()&1)return 1;
	else return -1;
}
int vis[(int)1e5+7],a[(int)1e5+7];
int main()
{
	srand(time(NULL));
	int n,m,l,r;
	n=getint(maxn),m=getint(maxm);
	while(n<4)n=getint(maxn);
	while(m<3)m=getint(maxm);
	memset(vis,0,sizeof(vis));
	for(register int i=1;i<=n;i++)
	{
		a[i]=getint(n);
		while(vis[a[i]])a[i]=getint(n);
		vis[a[i]]=1;
	}
	printf("%d %d\n",n,m);
	for(register int i=1;i<=n;i++)printf("%d ",a[i]);
	putchar('\n');
	for(register int i=1;i<=m;i++)
	{
		l=getint(n),r=getint(n);
		while(l==r)l=getint(n);
		if(l>r)swap(l,r);
		printf("%d %d %d\n",rand()%2,l,r);
	}
	printf("%d",getint(n));
	return 0;
} 
```
这样妈妈就再也不用担心我下载不了数据了！

---

## 作者：kimi0503 (赞：4)

注意到值域那么小，可以直接桶排，而且因为是排列，没有重复元素，所以可以用bool类型存，然后8个bit压成一个unsigned char，岂不美哉。 然而直接这样会T两个点，所以还要加个特判：如果当前的unsigned char为空，就直接跳过。

```cpp
#pr\
agma GCC optimize("O2")
#include<cstdio> 
#include<cstring>
#include<cctype>
inline char read() {
    static const int IN_LEN = 1000000;
    static char buf[IN_LEN], *s, *t;
    if (s == t) {
        t = (s = buf) + fread(buf, 1, IN_LEN, stdin);
        if (s == t) return -1;
    }
    return *s++;
}
template<class T>
inline void read(T &x) {
    static bool iosig;
    static char c;
    for (iosig = false, c = read(); !isdigit(c); c = read()) {
        if (c == '-') iosig = true;
        if (c == -1) return;
    }
    for (x = 0; isdigit(c); c = read())
        x = (x + (x << 2) << 1) + (c ^ '0');
    if (iosig) x = -x;
}
int n,m,a[30005],i,j,o,l,r,z,x,y,j1,j2,j3,j4;
unsigned char b[4000];
int main(){
    read(n);
    read(m);
    z=n>>3;
    for(i=1;i<=n;++i)read(a[i]);
    while(m--){
        read(o);
        read(l);
        read(r);
        memset(b,0,sizeof b);
        for(j1=l,j2=j1+1,j3=j2+1,j4=j3+1;j4<=r;j1+=4,j2+=4,j3+=4,j4+=4){
            b[a[j1]>>3]|=1<<(a[j1]&7);
            b[a[j2]>>3]|=1<<(a[j2]&7);
            b[a[j3]>>3]|=1<<(a[j3]&7);
            b[a[j4]>>3]|=1<<(a[j4]&7);
        } 
        for(j=j1;j<=r;++j)b[a[j]>>3]|=1<<(a[j]&7);
        x=l;
        if(o&1){
            y=(z<<3)+7;
            for(j=z;j>=0;--j){
                while(!b[j] && j) --j,y-=8;
                b[j]&128?a[x++]=y--:y--;
                b[j]&64?a[x++]=y--:y--;
                b[j]&32?a[x++]=y--:y--;
                b[j]&16?a[x++]=y--:y--;
                b[j]&8?a[x++]=y--:y--;
                b[j]&4?a[x++]=y--:y--;
                b[j]&2?a[x++]=y--:y--;
                b[j]&1?a[x++]=y--:y--;
            }
        }else{    
            y=0;
            for(j=0;j<=z;++j){
                while(!b[j] && j<z)++j,y+=8;
                b[j]&1?a[x++]=y++:y++;
                b[j]&2?a[x++]=y++:y++;
                b[j]&4?a[x++]=y++:y++;
                b[j]&8?a[x++]=y++:y++;
                b[j]&16?a[x++]=y++:y++;
                b[j]&32?a[x++]=y++:y++;
                b[j]&64?a[x++]=y++:y++;
                b[j]&128?a[x++]=y++:y++;
            }
        }
    }
    read(m);
    printf("%d\n",a[m]);
    return 0;
}
```

---

## 作者：crashed (赞：2)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P2824)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如我们用一个值$k$来卡这个序列，也就是说，构建一个新序列$b_i$，$b_i=\begin{cases}1&a_i\ge k\\0&a_i<k\end{cases}$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个新的序列$b_i$，如果最后排序完了，$b_q$为$1$。那么我们就知道，答案$\ge k$，否则答案就是$<k$。容易发现，我们**找到的最大的满足$b_q$为$1$的$k$就是答案**。显然，确定这个最大的$k$可以用二分快速搞掉。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在考虑对于$b_i$，怎么对它快速排序。升序降序的区别不大，所以我们只考虑升序的情况。对于一个$01$序列，升序排序的时候$0$会排前面，$1$会排后面，我们可以通过线段树查询区间的$1$的个数，然后区间覆盖。这样做到了单次“排序”$O(\log_2n)$，一次检查就是$O(m\log_2n)$。总时间就是$O(m\log_2n\log_2\{\max\{a_i\}\})$。  
# 代码
```cpp
#include <cstdio>

#define isLeaf( a ) ( segTree[a].l == segTree[a].r )
#define siz( a ) ( segTree[a].r - segTree[a].l + 1 )

const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s < '0' || '9' < s ){ if( s == '-' ) f = -1; s = getchar(); }
	while( '0' <= s && s <= '9' ){ x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar(); }
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ x = -x, putchar( '-' ); }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

struct oper
{
	int l, r, type;
}P[MAXN];

struct segmentTreeNode
{
	int l, r;
	int cnt;
	int tag;
}segTree[MAXN << 2];

int a[MAXN];
int splt;
int N, M, Q;

void upt( const int now )
{
	segTree[now].cnt = segTree[now << 1].cnt + segTree[now << 1 | 1].cnt;
}

void build( const int now, const int left, const int right )
{
	#ifdef _DEBUG
	segmentTreeNode &node3 = segTree[now];
	#endif
	segTree[now].l = left, segTree[now].r = right, segTree[now].tag = 0;
	if( isLeaf( now ) ) { segTree[now].cnt = a[left] >= splt; return ; }
	build( now << 1, left, left + right >> 1 ), build( now << 1 | 1, ( left + right >> 1 ) + 1, right );
	upt( now );
}

void nCover( const int now, const int type )
{
	if( type > 0 ) segTree[now].cnt = siz( now );
	else if( type < 0 ) segTree[now].cnt = 0;
	segTree[now].tag = type;
}

void normalize( const int now )
{
	if( ! segTree[now].tag ) return ;
	nCover( now << 1, segTree[now].tag ), nCover( now << 1 | 1, segTree[now].tag );
	segTree[now].tag = 0;
}

void cover( const int now, const int segL, const int segR, const int type ) 
{
	#ifdef _DEBUG
	segmentTreeNode &node1 = segTree[now];
	#endif
	if( segR < segTree[now].l || segTree[now].r < segL ) return ;
	if( segL <= segTree[now].l && segTree[now].r <= segR ){ nCover( now, type ); return ; }
	if( isLeaf( now ) ) return ; normalize( now );
	cover( now << 1, segL, segR, type ), cover( now << 1 | 1, segL, segR, type );
	upt( now );
}

int count( const int now, const int segL, const int segR )
{
	#ifdef _DEBUG
	segmentTreeNode &node2 = segTree[now];
	#endif
	if( segR < segTree[now].l || segTree[now].r < segL ) return 0;
	if( segL <= segTree[now].l && segTree[now].r <= segR ) return segTree[now].cnt;
	if( isLeaf( now ) ) return 0; normalize( now );
	return count( now << 1, segL, segR ) + 
		   count( now << 1 | 1, segL, segR );
}

bool chk( const int val )
{
	splt = val;
	build( 1, 1, N );
	int cnt;
	for( int i = 1 ; i <= M ; i ++ )
	{
		cnt = count( 1, P[i].l, P[i].r );
		if( P[i].type == 0 ) cover( 1, P[i].l, P[i].r - cnt, -1 ), cover( 1, P[i].r - cnt + 1, P[i].r, 1 );
		else cover( 1, P[i].l, P[i].l + cnt - 1, 1 ), cover( 1, P[i].l + cnt, P[i].r, -1 );
	}
	return count( 1, Q, Q );
}

int main()
{
	int l = INF, r = -INF;
	read( N ), read( M );
	for( int i = 1 ; i <= N ; i ++ ) read( a[i] ), l = MIN( l, a[i] ), r = MAX( r, a[i] );
	for( int i = 1 ; i <= M ; i ++ ) read( P[i].type ), read( P[i].l ), read( P[i].r );
	read( Q );
	int mid;
	while( r - l > 1 )
	{
		mid = l + r >> 1;
		if( chk( mid ) ) l = mid;
		else r = mid - 1;
	}
	if( chk( r ) ) write( r );
	else write( l );
	putchar( '\n' ); 
	return 0;
}
```

---

## 作者：GUO大侠 (赞：2)

#### 步骤: 
-  二分答案:Q上这个数是x
- check:   
  -  把所有小于x的数改成0,大于等于x的改成1;    
  -  使用线段树以mlogn的复杂度修改数列    
     (先求出1的个数,再根据op把这些1全部放到区间左边或者右边)
  - 最后看Q上这个数是不是1

#### 二分的单调在哪里:   
假如你已经知道结果了,就可以轻轻松松说出对于一个x,a[Q]是0还是1.   
如果Q上这个数是1,那么这个结果可能是x,x+1,x+2,,,,,,题目说这是一个排列,所以有唯一解,那么查询区间右移.

//简单吧!有道理吧!

#### 细节:
 
  - 每一次新建树tag都要重新设为-1
  - 题目要看清楚,op=0,把1全部放右边

#### 代码:

```
#include<bits/stdc++.h>
#define N 100005
#define mid (l+r>>1)
using namespace std;
int n,m,a[N],Mid,Q;
int o[N],lo[N],ro[N],tag[N<<2],tr[N<<2],Std;
void uptag(int u){tr[u]=tr[u<<1]+tr[u<<1|1];}
void pushtag(int u,int len){
	if(tag[u]<0)return;
	tag[u<<1]=tag[u];
	tag[u<<1|1]=tag[u];
	tr[u<<1]=tag[u]*(len-(len/2));
	tr[u<<1|1]=tag[u]*(len/2);
	tag[u]=-1;
}
void build(int u,int l,int r){
	tag[u]=-1;//**************************
	if(l==r){
		tr[u]=(a[l]>=Std);return;
	}
	build(u<<1,l,mid);
	build(u<<1|1,mid+1,r);
	uptag(u);
}
int query(int u,int l,int r,int L,int R){
	if(l>=L&&r<=R)return tr[u];
	int re=0;
	pushtag(u,r-l+1);
	if(L<=mid)re+=query(u<<1,l,mid,L,R);
	if(R>mid)re+=query(u<<1|1,mid+1,r,L,R);
	return re;
}
void upd(int u,int l,int r,int L,int R,int v){
	if(l>=L&&r<=R){
		tag[u]=v;tr[u]=(r-l+1)*v;return;
	}
	pushtag(u,r-l+1);
	if(L<=mid)upd(u<<1,l,mid,L,R,v);
	if(R>mid)upd(u<<1|1,mid+1,r,L,R,v);
	uptag(u);
}
bool check(int x){
	Std=x;
	build(1,1,n);
	for(int i=1;i<=m;i++){
		if(!o[i]){
			int q=query(1,1,n,lo[i],ro[i]);
			upd(1,1,n,ro[i]-q+1,ro[i],1);
			upd(1,1,n,lo[i],ro[i]-q,0);
		}
		else{
			int q=query(1,1,n,lo[i],ro[i]);
			upd(1,1,n,lo[i],lo[i]+q-1,1);
			upd(1,1,n,lo[i]+q,ro[i],0);
		}
	}
	return query(1,1,n,Q,Q);
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=m;i++)scanf("%d%d%d",&o[i],&lo[i],&ro[i]);
	cin>>Q;int l=1,r=n,ans=0;
	while(l<=r){Mid=l+r>>1;if(check(Mid))ans=Mid,l=Mid+1;else r=Mid-1;}
	cout<<ans<<'\n';return 0;
}

```

thanks

---

## 作者：C20203030 (赞：2)


## 一、题目

[点此看题](https://www.luogu.org/problem/P2824)

## 二、解法

其实本题的突破口在只有一个询问上，因为没有排序算法能达到$O(\log n)$。

考虑$\log$的复杂度排序，发现它只能对$01$串进行排序，我们尝试把问题转化为$01$串的排序。

如果我们有一个分界值$x$，那么小于$x$的是$0$，否则是$1$，排序可以用线段树实现，维护$0$的个数，支持区间赋值。这样我们可以得到一个关于大小的描述，我们看最后$q$位是否为$1$，如果为$1$，就可以确定$a[q]\leq x$，所以我们二分$x$，找到一个能使$q$位为$1$的最大的$x$，即为答案。

时间复杂度$O(n\log^2 n)$。


```cpp
#include <cstdio>
#define Len(i) (tr[i].r-tr[i].l+1)
const int MAXN = 100005;
int read()
{
    int x=0,flag=1;char c;
    while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
    while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^'0'),c=getchar();
    return x*flag;
}
int n,m,q,ans,a[MAXN];
struct node
{
    int op,l,r;
}s[MAXN];
struct tree
{
    int l,r,sum,lazy;//1->0 2->1
}tr[MAXN*4];
void build(int i,int l,int r)
{
    tr[i]=tree{l,r,0,0};
    if(l==r) return ;
    int mid=(l+r)>>1;
    build(i<<1,l,mid);
    build(i<<1|1,mid+1,r);
}
void down(int i)
{
    if(tr[i].lazy==1)
    {
        tr[i<<1].sum=Len(i<<1),tr[i<<1].lazy=1;
        tr[i<<1|1].sum=Len(i<<1|1),tr[i<<1|1].lazy=1;
    }
    else
    {
        tr[i<<1].sum=0,tr[i<<1].lazy=2;
        tr[i<<1|1].sum=0,tr[i<<1|1].lazy=2;
    }
    tr[i].lazy=0;
}
void updata(int i,int l,int r,int t)
{
    if(l>r || tr[i].l>r || tr[i].r<l)
        return ;
    if(l<=tr[i].l && tr[i].r<=r)
    {
        if(t==0) tr[i].sum=Len(i),tr[i].lazy=1;
        else tr[i].sum=0,tr[i].lazy=2;
        return ;
    }
    if(tr[i].lazy) down(i);
    updata(i<<1,l,r,t);
    updata(i<<1|1,l,r,t);
    tr[i].sum=tr[i<<1].sum+tr[i<<1|1].sum;
}
int query(int i,int l,int r)
{
    if(tr[i].l>r || tr[i].r<l)
        return 0;
    if(l<=tr[i].l && tr[i].r<=r)
        return tr[i].sum;
    if(tr[i].lazy) down(i);
    return query(i<<1,l,r)+query(i<<1|1,l,r);
}
bool check(int x)
{
    build(1,1,n);
    for(int i=1;i<=n;i++)
        updata(1,i,i,a[i]>=x);
    for(int i=1;i<=m;i++)
    {
        int op=s[i].op,l=s[i].l,r=s[i].r;
        int t=query(1,l,r);
        if(op==0)
        {
            updata(1,l,l+t-1,0);
            updata(1,l+t,r,1);
        }
        else
        {
            updata(1,l,r-t,1);
            updata(1,r-t+1,r,0);
        }
    }
    return query(1,q,q)==0;
}
void dich(int l,int r)
{
    if(l>r) return ;
    int mid=(l+r)>>1;
    if(check(mid))
    {
        ans=mid;
        dich(mid+1,r);
    }
    else
        dich(l,mid-1);
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=n;i++)
        a[i]=read();
    for(int i=1;i<=m;i++)
        s[i]=node{read(),read(),read()};
    q=read();
    dich(1,n);
    printf("%d\n",ans);
}

```

其实这道题暴力桶排然后开$O2$也能过qwq。



---

## 作者：doctorZ_ (赞：1)

## 题目大意：
给一个$n(n<=10^5)$的排列，有$m(m<=10^5)$个操作：       
$1\ l\ r$表示把$[l, r]$区间内的数降序排序；   
$0\ l\ r$表示把$[l, r]$区间内的数升序排序。       
最后询问这个序列位置$p$上的数。
## 解法
如果我们要对一个区间排序，那么时间复杂度显然是$O(nlogn)$的，对$m$个区间排序，那么时间复杂度就是$O(nmlogn)$的，这个时间复杂度对于这道题来说显然是过不了的    

我们可以二分一个值$mid$，将原序列中大于等于$mid$的数当作$1$，小于$mid$的数当作0，再进行进行$m$个区间的排序，如果位置$q$上的数等于$1$，则说明mid大于等于u原序列的排序结果的位置$q$上的数字，否则小于

$01$序列的区间排序显然可以使用线段树当中的区间更新操作用$logn$的时间完成，那么完成$m$个区间的排序时间复杂度显然为$O(mlogn)$，再加上原来的二分，总时间复杂度则为$O(mlog^2n)$
## $code:$
```cpp
#include<cstdio>
#define N 110000
using namespace std;
int n,m,q;
int a[N+1];
struct ask
{
	int type,l,r;
}Q[N+1];
struct tree
{
	int sum,tag;//sum为该节点的区间和，tag为懒标记，-1表示不变，0表示该区间变成0，1表示该区间变成1 
}t[N<<2|1];
void pushup(int p){t[p].sum=t[p<<1].sum+t[p<<1|1].sum;}
void pushdown(int p,int l,int r)
{
	if(t[p].tag!=-1)
	{
		t[p<<1].tag=t[p<<1|1].tag=t[p].tag;
		int mid=(l+r)>>1;
		t[p<<1].sum=(mid-l+1)*t[p].tag,t[p<<1|1].sum=(r-mid)*t[p].tag;
		t[p].tag=-1;
	} 
}
void build(int p,int l,int r,int x)//每次二分重新建树 
{
	t[p].tag=-1;
	if(l==r)
	{
		t[p].sum=(a[l]>=x);
		return;
	}
	int mid=(l+r)>>1;
	build(p<<1,l,mid,x),build(p<<1|1,mid+1,r,x);
	pushup(p);
}
int query(int p,int l,int r,int L,int R)//区间查询 
{
	if(L<=l&&r<=R)
		return t[p].sum;
	pushdown(p,l,r);
	int mid=(l+r)>>1,res=0;
	if(L<=mid)
		res+=query(p<<1,l,mid,L,R);
	if(R>mid)
		res+=query(p<<1|1,mid+1,r,L,R);
	return res;
}
void update(int p,int l,int r,int L,int R,int x)//区间修改 
{
	if(L>R)
		return;
	if(L<=l&&r<=R)
	{
		t[p].tag=x;
		t[p].sum=(r-l+1)*x;
		return;
	} 
	pushdown(p,l,r);
	int mid=(l+r)>>1;
	if(L<=mid)
		update(p<<1,l,mid,L,R,x);
	if(R>mid)
		update(p<<1|1,mid+1,r,L,R,x);
	pushup(p);
}
int check(int x)//返回mid=x时，新序列中位置q上的数 
{
	build(1,1,n,x);
	for(int i=1;i<=m;i++)
	{
		int sum=query(1,1,n,Q[i].l,Q[i].r);
		if(!Q[i].type)
		{
			update(1,1,n,Q[i].l,Q[i].r-sum,0);
			update(1,1,n,Q[i].r-sum+1,Q[i].r,1);
		}
		else
		{
			update(1,1,n,Q[i].l,Q[i].l+sum-1,1);
			update(1,1,n,Q[i].l+sum,Q[i].r,0);
		}
	}
	return query(1,1,n,q,q);
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=m;i++)
		scanf("%d %d %d",&Q[i].type,&Q[i].l,&Q[i].r);
	scanf("%d",&q); 
	int l=0,r=1000000000,mid,res=0;
	while(l<=r)
	{
		mid=(l+r)>>1;
		if(check(mid))
			l=mid+1,res=mid;
		else
			r=mid-1;
	}
	printf("%d\n",res);
	return 0;
}
```


---

## 作者：撤云 (赞：1)

[点击食用更佳](https://www.cnblogs.com/hbxblog/p/11708862.html)

### $Solution$

这道题在线的做法不会，所以这里就只讲离线的做法。

因为直接排序的话复杂度显然不对.但是如果数列为$01$串的话就可以让复杂度变成对的了

那么$01$串怎么做呢?

我们考虑用线段树维护这个东西.

假设我们要将$[l,r]$排序

我们可以处理出$[l,r]$中$1$的个数,我们令他为$w$

如果升序就将$[r-x+1,r]$设为1,其余为$0$

如果降序就将$[l,l+x-1]$设为1,其余为$0$

那么这个问题怎么变成上述情况呢?

我们二分最后的答案，令这个数为$mid$。

对于序列中的数，如果小于$mid$就为$0$，大于$mid$就为$1$

然后操作根上述过程一样.

最后判断下$q$位置是否为$1$

是，$l=mid+1$

否，$r=mid-1$

现在来证明一下这个单调性。

如果$q$这个位置的数为$1$，那么答案肯定为$x+1,x+2,x+3...$所以区间右移，反之亦然。

### $Code$

``` cpp
#include<bits/stdc++.h>
#define rg register
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return f*x;
}
struct node {
	int lazy,v;
}a[1000001];
int c[1000001];
void pushup(int k){
	a[k].v=a[k<<1].v+a[k<<1|1].v;
}
void build(int k,int l,int r){
	a[k].lazy=-1,a[k].v=0;
	if(l==r)
		return;
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
}
void pushdown(int k,int l,int r){
	if(a[k].lazy==-1) return;
	int mid=(l+r)>>1;
	a[k<<1].v=(mid-l+1)*a[k].lazy;
	a[k<<1|1].v=(r-mid)*a[k].lazy;
	a[k<<1].lazy=a[k<<1|1].lazy=a[k].lazy;
	a[k].lazy=-1;
}
void update(int k,int l,int r,int begin,int end,int v){
	if(r<begin||l>end) return ;
	if(r<=end&&l>=begin){
		a[k].v=(r-l+1)*v;
		a[k].lazy=v;
		return ;
	}
	pushdown(k,l,r);
	int mid=(l+r)>>1;
	update(k<<1,l,mid,begin,end,v);
	update(k<<1|1,mid+1,r,begin,end,v);
	pushup(k);
}
int find(int k,int l,int r,int begin,int end){
	if(r<begin&&l>end) return 0;
	if(r<=end&&l>=begin) return a[k].v;
	pushdown(k,l,r);
	int mid=(l+r)>>1;
	if(end<=mid)
		return find(k<<1,l,mid,begin,end);
	else if(begin>mid)
		return find(k<<1|1,mid+1,r,begin,end);
	else return find(k<<1,l,mid,begin,mid)+find(k<<1|1,mid+1,r,mid+1,end);
}
struct ans{
	int opt,x,y;
}b[1000001];
int n,m,ans,l,r,q;
bool check(int x){
	build(1,1,n);
	for(int i=1;i<=n;i++)
		update(1,1,n,i,i,c[i]>=x);
	for(int i=1;i<=m;i++){
		int opt=b[i].opt,x=b[i].x,y=b[i].y;
		int w1=find(1,1,n,x,y),w0=y-x+1-w1;
		if(opt==0)
			update(1,1,n,x,y,1),update(1,1,n,x,x+w0-1,0);
		else update(1,1,n,x,y,0),update(1,1,n,x,x+w1-1,1);
	}
	return find(1,1,n,q,q)==1;
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++) c[i]=read();
	for(int i=1;i<=m;i++) b[i].opt=read(),b[i].x=read(),b[i].y=read();
	l=1,r=n,q=read();
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid)) l=mid+1,ans=mid;
		else r=mid-1;
	}
	printf("%d",ans);
    return 0;
}
```

---

## 作者：Setsugesuka (赞：1)

不难想到去二分我们最终的答案，每次检查的时候把所有比我们二分出来的答案小的数设为 $0$ ，其他的数设为 $1$ 。

每次升序排序就是把这段区间里 $0$ 放到前面， $1$ 放到后面。

降序同理。

注意到放 $0,1$ 的操作就是我们喜闻乐见的区间推平，考虑用 $ODT$ 来解决这个问题。

值得注意的是，我们整个数列的值域很小，所以我们在每次操作以后尝试把新出现的两个区间和旁边的两个区间合并。

不知道为什么开了 $O2$ 以后还要跑 $1s$ 多，或许是人丑常数大吧。

```cpp
#include <bits/stdc++.h>
using namespace std;

template <class T>
inline void write(T x)
{
    if(x>9)
    {
        write(x/10);
    }
    putchar(x%10+'0');
}

inline char nc()
{
    static char buf[1000000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;
}

inline void read(int &sum)
{
    char ch=nc();
    int tf=0;
    sum=0;
    while((ch<'0'||ch>'9')&&(ch!='-')) ch=nc();
    tf=((ch=='-')&&(ch=nc()));
    while(ch>='0'&&ch<='9') sum=sum*10+(ch-48),ch=nc();
    (tf)&&(sum=-sum);
}

const int MAXN=1e5+10;

struct node
{
    int l,r,v;
    node(){}
    node(int L,int R=-1,int V=0):l(L),r(R),v(V){}
    bool operator <(const node &o) const
    {
        return l<o.l;
    }
};

set<node> s;

inline void merge(int l)
{
    set<node>::iterator it1,it2,it3;
    it2=s.lower_bound(l);
    if(it2==s.begin())
        return;
    it1=it2,it3=it2;
    --it1,++it3;
    bool pd3=(it3!=s.end());
    if(pd3&&it1->v==it2->v&&it2->v==it3->v&&it1->v==it3->v)
    {
        int l=it1->l,r=it3->r,v=it2->v;
        s.erase(it1,++it3);
        s.insert(node(l,r,v));
    }
    else if(it1->v==it2->v)
    {
        int l=it1->l,r=it2->r,v=it2->v;
        s.erase(it1,++it2);
        s.insert(node(l,r,v));
    }
    else if(pd3&&it2->v==it3->v)
    {
        int l=it2->l,r=it3->r,v=it2->v;
        s.erase(it2,++it3);
        s.insert(node(l,r,v));
    }
}

inline set<node>::iterator split(int pos)
{
    set<node>::iterator it=s.lower_bound(node(pos));
    if(it!=s.end()&&it->l==pos) return it;
    --it;
    int L=it->l,R=it->r,V=it->v;
    s.erase(it);
    s.insert(node(L,pos-1,V));
    return s.insert(node(pos,R,V)).first;
}

inline void assignval(int l,int r,int v)
{
    set<node>::iterator itr=split(r+1),itl=split(l);
    s.erase(itl,itr);
    s.insert(node(l,r,v));
}

inline int query(int l,int r)
{
    set<node>::iterator itr=split(r+1),itl=split(l);
    int ret=0;
    for(;itl!=itr;++itl)
        if(itl->v==1) ret+=(itl->r-itl->l+1);
    return ret;
}

struct qnode
{
    int l,r,lx;
};

qnode q[MAXN];
int a[MAXN];
int n,m,k;

inline bool check(int x)
{
    s.clear();
    for(int i=1;i<=n;++i)
        s.insert(node(i,i,a[i]>=x));
    s.insert(node(n+1,n+1,-1));
    s.insert(node(0,0,-1));
    for(int i=1;i<=m;++i)
    {
        int cnt1=query(q[i].l,q[i].r);
        if(!q[i].lx)
        {
            assignval(q[i].r-cnt1+1,q[i].r,1);
            assignval(q[i].l,q[i].r-cnt1,0);
        }
        else
        {
            assignval(q[i].l,q[i].l+cnt1-1,1);
            assignval(q[i].l+cnt1,q[i].r,0);
        }
        merge(q[i].l);
        merge(q[i].r+1);
    }
    set<node>::iterator itl=split(k);
    return itl->v==1;
}

int main()
{
    read(n),read(m);
    for(int i=1;i<=n;++i)
        read(a[i]);
    for(int i=1;i<=m;++i)
        read(q[i].lx),read(q[i].l),read(q[i].r);
    read(k);
    int l=1,r=n,ans;
    while(l<=r)
    {
        int mid=(l+r)>>1;
        if(check(mid)) ans=mid,l=mid+1;
        else r=mid-1;
    }
    write(ans);
    return 0;
}
```


---

## 作者：GoldenPotato137 (赞：1)

**蒟蒻博客：**[QwQ](https://www.cnblogs.com/GoldenPotato/p/9814376.html)


------------

## Solution

这题极其巧妙。

 .

首先，如果直接做m次排序，显然会T得起飞。

注意一点：我们只需要找到一个数。

所以说，我们可以考虑一个绝妙的想法：**我们可以用二分答案的方法缩小要找的数的区间。**

考虑二分一个值，判定p位置的数排序之后，p位置上的数是否>=mid

如果>=mid,则向右找，否则向左找。

.

怎么判定p位置的数排序之后是否>=mid呢？

考虑这样做：**扫描一遍原数组，>=mid的数赋值为1，<mid的数赋值为0**。

这样子，**题目就变成了一个01序列排序**。

这就很可做了，我们直接线段树维护之即可，我们只需要实现区间查询与区间赋值。

**对于一个01区间排序，我们只需要知道这个区间有多少个0，多少个1，然后区间修改即可。**

. 

时间复杂度$O(m*logn^2)$

.

就酱，这题就可以切掉啦(ﾉ´▽｀)ﾉ♪



------------
## Code

```cpp
//Luogu  P2824 [HEOI2016/TJOI2016]排序
//Oct,19th,2018
//二分答案缩小范围+线段树妙题
#include<iostream>
#include<cstdio>
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=30000+100;
int a[N],w[N];
struct SegmentTree
{
    #define lson (now<<1)
    #define rson (now<<1|1)
    #define mid ((now_l+now_r)>>1)
    static const int M=N<<2;
    int sum[M][2],lazy[M];
    inline void update(int now)
    {
        sum[now][0]=sum[lson][0]+sum[rson][0];
        sum[now][1]=sum[lson][1]+sum[rson][1];
    }
    inline void pushdown(int now,int now_l,int now_r)
    {
        if(now_l==now_r)
        {
            lazy[now]=2;
            return;
        }
        lazy[lson]=lazy[rson]=lazy[now];
        sum[lson][lazy[now]]=mid-now_l+1,sum[lson][!lazy[now]]=0;
        sum[rson][lazy[now]]=now_r-mid,sum[rson][!lazy[now]]=0;
        lazy[now]=2;
    }
    void Build(int now,int now_l,int now_r)
    {
        sum[now][0]=sum[now][1]=0;
        lazy[now]=2;
        if(now_l==now_r)
        {
            sum[now][w[now_l]]++;
            return;
        }
        Build(lson,now_l,mid);
        Build(rson,mid+1,now_r);
        update(now);
    }
    void Change(int L,int R,int x,int now,int now_l,int now_r)
    {
        if(L>R) return;
        if(lazy[now]!=2) pushdown(now,now_l,now_r);
        if(now_l>=L and now_r<=R)
        {
            sum[now][x]=now_r-now_l+1,sum[now][!x]=0;
            lazy[now]=x;
            return;
        }
        if(L<=mid) Change(L,R,x,lson,now_l,mid);
        if(R>mid) Change(L,R,x,rson,mid+1,now_r);
        update(now);
    }
    int Query(int L,int R,int x,int now,int now_l,int now_r)
    {
        if(lazy[now]!=2) pushdown(now,now_l,now_r);
        if(now_l>=L and now_r<=R)
            return sum[now][x];
        int ans=0;
        if(L<=mid) ans+=Query(L,R,x,lson,now_l,mid);
        if(R>mid) ans+=Query(L,R,x,rson,mid+1,now_r);
        return ans;
    }
    #undef lson
    #undef rson
    #undef mid
}sgt;
struct OP
{
    int type,L,R;
}op[N];
int n,m,p;
bool Check(int x)
{
    for(int i=1;i<=n;i++)
        if(a[i]>=x) w[i]=1;
        else w[i]=0;
    sgt.Build(1,1,n);
    for(int i=1;i<=m;i++)
    {
        int cnt0=sgt.Query(op[i].L,op[i].R,0,1,1,n),cnt1=op[i].R-op[i].L+1-cnt0;
        if(op[i].type==0)
            sgt.Change(op[i].L,op[i].L+cnt0-1,0,1,1,n),
            sgt.Change(op[i].L+cnt0,op[i].R,1,1,1,n);
        else
            sgt.Change(op[i].L,op[i].L+cnt1-1,1,1,1,n),
            sgt.Change(op[i].L+cnt1,op[i].R,0,1,1,n);
    }
    if(sgt.Query(p,p,1,1,1,n)==1) return true;
    return false;
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;i++)
        a[i]=read();
    for(int i=1;i<=m;i++)
        op[i].type=read(),op[i].L=read(),op[i].R=read();
    p=read();
    
    int L=0,R=n+100,ans=0;
    while(L<=R)
    {
        int mid=(L+R)/2;
        if(Check(mid)==true)
            ans=max(ans,mid),L=mid+1;
        else
            R=mid-1;
    }
    
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Ning_Mew (赞：1)

首先先声明一下，方法与Drench大佬的差不多，此篇题解填了一些解释，让代码更容易理解。（P.S.：我的代码不知道为啥在主站会T第10个点，在大牛分站交过了，能有大佬想到一些优化的方法当然是更好，这题解主要是介绍思路和代码含义）

###SOLUTION：

First：主体思路：二分答案+线段树操作

Second：代码完成思路

1.读入，存储数值

2.二分第Q个值的答案

3.线段树的操作

1)建树   2)进行m次操作  3)找到第q个点

4.二分left 和 right的更改

Third：线段树操作方法及能实现的原因

1.二分出q，建树时大于等于q叶子节点为1，反之为0，然后利用线段树处理的sum（和）。

2.对于第i步修改操作中，区间l-r中的和及大于等于q的个数(1)，r-l+1为区间数的个数，求差就是小于q的个数(0)。

3.求出l-r区间num0与num1个数后，若从小到大，则将l-(l+num0-1)赋值为0，(l+num0-r)赋值为1

反之，则将l-(l+num1-1)赋值为1，(l+num1-r)赋值为0

4.上述步骤重复m次后，就可以去查询第Q个数，如果为1说明二分出来的q大于等于答案，如果为0说明二分出来的q小于q

下面就是我的代码了，代码中有一些注释：

```cpp
//It is coded by Ning_Mew on 10.17
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;
int read(){//读入优化
    int x=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x=(x*10)+ch-'0',ch=getchar();
    return x;
}
int n,m,q,top=0,tail,mid;
struct Operation{
    int type,l,r;
}ope[100000+10];//储存更改操作
struct Node{
    int l,r,sum,lazy;
}node[400000+10];//线段树储存
int a[100000+10];//储存每个值
void build(int num,int nl,int nr){//建树
    if(nl==nr){
        node[num].l=nl; node[num].r=nr;
        if(a[nl]>=mid)node[num].sum=1;
        else node[num].sum=0;//对应Third中的第一点
        return;
    }
    int nmid=(nl+nr)/2;
    build(num*2,nl,nmid);
    build(num*2+1,nmid+1,nr);
    node[num].l=nl; node[num].r=nr;
    node[num].sum=(node[num*2].sum+node[num*2+1].sum);
    return;
}
void pushdown(int num,int nl,int nr){//下放lazy操作
    if(node[num].lazy!=-1){
        node[num*2].lazy=node[num].lazy;
        node[num*2+1].lazy=node[num].lazy;//因为lazy是将这个节点中的数全部更改为0或1，所以lazy是直接被覆盖而不是+=
        node[num*2].sum=node[num].lazy*(node[num*2].r-node[num*2].l+1);
        node[num*2+1].sum=node[num].lazy*(node[num*2+1].r-node[num*2+1].l+1);//同样因为是全被更改，所以直接覆盖
        node[num].lazy=-1;
    }
    return;
}
int count(int num,int nl,int nr,int ql,int qr){//求区间和
    if(qr<nl||nr<ql)return 0;
    if(ql<=nl&&nr<=qr){
        return node[num].sum;
    }
    pushdown(num,nl,nr);
    int nmid=(nl+nr)/2;
    return count(num*2,nl,nmid,ql,qr)+count(num*2+1,nmid+1,nr,ql,qr);
}
void change(int num,int nl,int nr,int ql,int qr,int add){//区间更改
    if(qr<nl||nr<ql||ql>qr)return;
    if(ql<=nl&&nr<=qr){
        node[num].sum=add*(node[num].r-node[num].l+1);//被防止了lazy的点本身应已被更改，下次就只用下放lazy了
        node[num].lazy=add;
        return;
    }
    pushdown(num,nl,nr);
    int nmid=(nl+nr)/2;
    change(num*2,nl,nmid,ql,qr,add);
    change(num*2+1,nmid+1,nr,ql,qr,add);
    node[num].sum=node[num*2].sum+node[num*2+1].sum;//两个儿子节点已更改所以更新此节点sum值
    return;
}
bool judge(){//检查q值
    build(1,1,n);
    for(int i=1;i<=4*n+1;i++)node[i].lazy=-1;
    for(int i=1;i<=m;i++){
        int ll=ope[i].l,rr=ope[i].r;
        int num1=count(1,1,n,ll,rr),num0;
            num0=rr-ll+1-num1;
        if(ope[i].type==0){//对应Third 3点
            change(1,1,n,ll,ll+num0-1,0);
            change(1,1,n,ll+num0,rr,1);
        }
        else{
            change(1,1,n,ll,ll+num1-1,1);
            change(1,1,n,ll+num1,rr,0);
        }
    }
    if(count(1,1,n,q,q))return true;//1-->true
    return false;//0-->false
}
int main(){
    n=read();m=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
    }
    for(int i=1;i<=m;i++){
        ope[i].type=read();
        ope[i].l=read();
        ope[i].r=read();
    }
    q=read();
    top=0;tail=n+1;
    do{
        mid=(top+tail)/2;
        if(judge()){top=mid;}
        else {tail=mid;}
    }while(top<tail-1);
    cout<<top;    
    return 0;
}
```

题解就写到这啦，好好理解还是不难的～


---

## 作者：优少 (赞：0)

**二分+线段树**趴

首先让我们想想暴力的做法

emmmmmm

强行暴力，O（n^2*logn）（直接强行排序）

让我们想想如何优化这个排序，对一个序列排序的时间复杂度是O（n*logn），但是当我们对一个01序列排序的时候就是O（logn）了

那具体怎么做呢？做法如下：

正确做法:

首先二分所求位置数字，将原序列大于mid值的数设为1，小于的设为0

当降序时前半段改为1，后半段改为0

当升序时前半段改为0，后半段改为1

具体改多少个就要通过线段树区间求1个数判断了，若个数为cnt

**当降序时[l, r-cnt1]改为1，[l+cnt, r]改为0**

**当升序时[l, r-cnt1]改为0，[r-cnt1+1, r]改为1**

二分验证则判断所求位置是否为1

时间复杂度O（n*logn^2）

详见代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100010; 
int a[maxn],opt[maxn],ll[maxn],rr[maxn];
int n,m;
int hh;
struct SYM{
    int sum;
    int lazy; 
}tree[8*maxn] ;
void build(int i,int l,int r,int x){               //建树
    if(l==r){
        tree[i].sum=(a[l]>=x);
        tree[i].lazy=0;
        return ;
    }
    int mid=(l+r)/2;
    build(2*i,l,mid,x);
    build(2*i+1,mid+1,r,x);
    tree[i].sum=tree[2*i].sum+tree[2*i+1].sum;
    tree[i].lazy=0;
}
void pushdown(int i,int l,int r){                  //下传lazy标记
    int mid=(l+r)/2;
    if(!tree[i].lazy) return ;
    tree[2*i].lazy=tree[2*i+1].lazy=tree[i].lazy;
    if(tree[i].lazy==1){
        tree[2*i].sum=(mid-l+1);
        tree[2*i+1].sum=(r-mid); 
    }
    else tree[2*i].sum=tree[2*i+1].sum=0;
    tree[i].lazy=0;
}
void pushup(int i){
    tree[i].sum=tree[2*i].sum+tree[2*i+1].sum;
}
int query(int i,int l,int r,int L,int R){                      //查询1个数
    if(l>=L&&r<=R)
        return tree[i].sum;
    if(r<L||l>R) return 0;
    pushdown(i,l,r);
    int mid=(l+r)/2;
    return query(2*i,l,mid,L,R)+query(2*i+1,mid+1,r,L,R);
}
void update(int i,int l,int r,int L,int R,int x){            //更新
    if(l>=L&&r<=R){
        if(x==1){
            tree[i].sum=(r-l+1);
            tree[i].lazy=1;
        }
        else tree[i].sum=0,tree[i].lazy=-1;
        return ;
    }
    if(r<L||l>R) return ;
    pushdown(i,l,r);
    int mid=(l+r)/2;
    update(2*i,l,mid,L,R,x);
    update(2*i+1,mid+1,r,L,R,x);
    pushup(i);
}
int query1(int i,int l,int r,int x){
    if(l==x&&r==x) return tree[i].sum;
    int mid=(l+r)/2;
    pushdown(i,l,r);
    if(x<=mid) query1(2*i,l,mid,x);
    else query1(2*i+1,mid+1,r,x);
}
int check(int x){
    build(1,1,n,x);
    for(int i=1;i<=m;i++){
        int cnt=query(1,1,n,ll[i],rr[i]);
        if(opt[i]==1){
            update(1,1,n,ll[i],ll[i]+cnt-1,1);                  //当降序时[l, r-cnt1]改为1，[l+cnt, r]改为0
            update(1,1,n,ll[i]+cnt,rr[i],0);
        }
        if(opt[i]==0){
            update(1,1,n,rr[i]-cnt+1,rr[i],1);                 //当升序时[l, r-cnt1]改为0，[r-cnt1+1, r]改为1
            update(1,1,n,ll[i],rr[i]-cnt,0);
        }
    }
    return query1(1,1,n,hh);
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<=m;i++)
        scanf("%d%d%d",&opt[i],&ll[i],&rr[i]);
    scanf("%d",&hh);
    int lll=1,rrr=n,ans;
    while(lll<=rrr){
        int mid=(lll+rrr)/2;
        if(check(mid)) ans=mid,lll=mid+1;
        else rrr=mid-1;
    }
    printf("%d",ans);
    return 0;
}
```


---

## 作者：Mihari (赞：0)

# T 「TJOI / HEOI2016」排序
## 题目
[点这里](https://loj.ac/problem/2055)
## 考场思路（假正解）
直接看的 $50\%$ 的数据范围，发现可以使用区间桶排序，时间复杂度 $O(nm)$。

```cpp
#include<cstdio>
// #define FILEOI
#define rep(i,__l,__r) for(int i=__l,i##_end_=__r;i<=i##_end_;++i)
#define dep(i,__l,__r) for(int i=__l,i##_end_=__r;i>=i##_end_;--i)
#define cg (c=getchar())
template<class T>inline void qread(T& x){
	x=0;char c;bool f=0;
	while(cg<'0'||'9'<c)if(c=='-')f=1;
	for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
	if(f)x=-x;
}
template<class T,class... Args>inline void qread(T& x,Args&... args){qread(x),qread(args...);}
inline int qread(){
	int x=0;char c;bool f=1;
	while(cg<'0'||'9'<c)if(c=='-')f=0;
	for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
	return f?x:-x;
}
#undef cg
template<class T>inline T Max(const T x,const T y){return x>y?x:y;}
template<class T>inline T Min(const T x,const T y){return x<y?x:y;}
template<class T>inline T fab(const T x){return x>0?x:-x;}
template<class T>void fwrit(T x){
	if(x<0)return (void)(putchar('-'),fwrit(-x));
	if(x>10)fwrit(x/10);
	return (void)(putchar(x%10^48));
}

const int MAXN=1e5;

int n,m,q,a[MAXN+5],t[MAXN+5];

inline void init(){
	qread(n,m);
	rep(i,1,n)qread(a[i]);
}

inline void getOperation(){
	int op,l,r,li,ri;
	while(m--){
		li=n,ri=0;
		qread(op,l,r);
		rep(i,l,r)++t[a[i]],li=Min(li,a[i]),ri=Max(ri,a[i]);
		if(op==0){
			rep(i,l,r){
				while(t[li]==0)++li;
				a[i]=li,t[li]=0;
			}
		}
		else if(op==1){
			rep(i,l,r){
				while(t[ri]==0)--ri;
				a[i]=ri,t[ri]=0;
			}
		}
	}
	printf("%d\n",a[qread()]);
}

signed main(){
#ifdef FILEOI
	freopen("sort.in","r",stdin);
	freopen("sort.out","w",stdout);
#endif
	init();
	getOperation();
	return 0;
}
```
期望得分只有 $50pts$，但是数据测出来，居然可以 $A$ 掉...所以叫伪正解...
## 正解
我们发现，对于一个 $x$，将小于 $x$ 的数换成 $0$，大于等于 $x$ 的数换成 $1$ 之后，所得到的排序结果其实是一样的。

但是这样做有唯一的缺陷，就是我们只知道最后 $q$ 位置的数是 $0$ 还是 $1$。

其实很好解决，**二分**这个 $x$ 即可。

这里先把标称附上

`std version`

```cpp
#include <cstdio>
#include <cstring>
#include <cctype>
#define lc o << 1
#define rc o << 1 | 1
#define mid (l + r) / 2
using namespace std;

const int N = 100010;
int n, m, p;
int T[4 * N], lazy[4 * N];    // segment tree
int a[N], ch[N], L[N], R[N];  // the information by reading

inline int read() {
    char ch = getchar();
    int x = 0;
    while (!isdigit(ch)) ch = getchar();
    while (isdigit(ch)) {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x;
}

inline void build(int o, int l, int r, int x) {
    if (l == r) {
        T[o] = a[l] >= x;
        lazy[o] = 0;
        return;
    }
    build(lc, l, mid, x);
    build(rc, mid + 1, r, x);
    T[o] = T[lc] + T[rc];
    lazy[o] = 0;
}

inline void pushdown(int o, int l, int r) {
    if (!lazy[o])
        return;
    lazy[lc] = lazy[rc] = lazy[o];
    if (lazy[o] == 1) {
        T[lc] = mid - l + 1;
        T[rc] = r - mid;
    } else
        T[lc] = T[rc] = 0;
    lazy[o] = 0;
}

inline int query(int o, int l, int r, int x, int y) {
    if (x <= l && y >= r)
        return T[o];
    if (x > r || y < l)
        return 0;
    pushdown(o, l, r);
    return query(lc, l, mid, x, y) + query(rc, mid + 1, r, x, y);
}

inline int queryPoint(int o, int l, int r, int x) {
    if (l == x && r == x)
        return T[o];
    pushdown(o, l, r);
    if (x <= mid)
        return queryPoint(lc, l, mid, x);
    else
        return queryPoint(rc, mid + 1, r, x);
}

inline void update(int o, int l, int r, int x, int y, int val) {
    if (x <= l && y >= r) {
        T[o] = val * (r - l + 1);
        lazy[o] = val ? 1 : -1;
        return;
    }
    if (x > r || y < l)
        return;
    pushdown(o, l, r);
    update(lc, l, mid, x, y, val);
    update(rc, mid + 1, r, x, y, val);
    T[o] = T[lc] + T[rc];
}

inline bool check(int x) {
    build(1, 1, n, x);
    for (int i = 1; i <= m; i++) {
        int cnt1 = query(1, 1, n, L[i], R[i]);
        if (ch[i] == 0) {
            update(1, 1, n, R[i] - cnt1 + 1, R[i], 1);
            update(1, 1, n, L[i], R[i] - cnt1, 0);
        } else {
            update(1, 1, n, L[i], L[i] + cnt1 - 1, 1);
            update(1, 1, n, L[i] + cnt1, R[i], 0);
        }
    }
    return queryPoint(1, 1, n, p);
}

int main() {
    freopen("sort.in","r",stdin);
    freopen("sort.out","w",stdout);
    n = read();
    m = read();
    for (int i = 1; i <= n; i++) a[i] = read();
    for (int i = 1; i <= m; i++) {
        ch[i] = read();
        L[i] = read();
        R[i] = read();
    }
    p = read();
    int ll = 1, rr = n, midd, ans;
    while (ll <= rr) {
        midd = (ll + rr) >> 1;
        if (check(midd))
            ans = midd, ll = midd + 1;
        else
            rr = midd - 1;
    }
    printf("%d\n", rr);
    return 0;
}
```

`My version`

```cpp
#include<cstdio>
// #define FILEOI
#define lc (i<<1)
#define rc (i<<1|1)
#define rep(i,__l,__r) for(int i=__l,i##_end_=__r;i<=i##_end_;++i)
#define dep(i,__l,__r) for(int i=__l,i##_end_=__r;i>=i##_end_;--i)
#define cg (c=getchar())
template<class T>inline void qread(T& x){
	x=0;char c;bool f=0;
	while(cg<'0'||'9'<c)if(c=='-')f=1;
	for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
	if(f)x=-x;
}
template<class T,class... Args>inline void qread(T& x,Args&... args){qread(x),qread(args...);}
inline int qread(){
	int x=0;char c;bool f=1;
	while(cg<'0'||'9'<c)if(c=='-')f=0;
	for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
	return f?x:-x;
}
#undef cg
template<class T>inline T Max(const T x,const T y){return x>y?x:y;}
template<class T>inline T Min(const T x,const T y){return x<y?x:y;}
template<class T>inline T fab(const T x){return x>0?x:-x;}
template<class T>void fwrit(T x){
	if(x<0)return (void)(putchar('-'),fwrit(-x));
	if(x>10)fwrit(x/10);
	return (void)(putchar(x%10^48));
}

const int MAXN=1e5;
const int MAXM=1e5;

struct change{int op,l,r;}p[MAXM+5];
struct node{
	int l,r,mid,t1,lazy;
	node(){lazy=-1;}
	node(const int L,const int R,const int M):l(L),r(R),mid(M){lazy=-1;}
}tre[(MAXN<<2)+5];
int n,m,a[MAXN+5],t[MAXN+5],q;

inline void init(){
	qread(n,m);
	rep(i,1,n)qread(a[i]);
	for(int i=1;i<=m;++i)p[i]=change{qread(),qread(),qread()};
	qread(q);
}

inline void pushup(const int i){tre[i].t1=tre[lc].t1+tre[rc].t1;}

inline void pushdown(const int i){
	if(tre[i].l^tre[i].r){
		if(tre[i].lazy==1){
			tre[lc].lazy=tre[rc].lazy=1;
			tre[lc].t1=(tre[lc].r-tre[lc].l+1);
			tre[rc].t1=(tre[rc].r-tre[rc].l+1);
		}
		else if(tre[i].lazy==0){
			tre[lc].lazy=tre[rc].lazy=0;
			tre[lc].t1=tre[rc].t1=0;
		}
	}
	tre[i].lazy=-1;
}

inline void buildtre(const int i,const int l,const int r,const int x){
	// printf("buildtre : %d %d %d %d\n",i,l,r,x);
	int mid=(l+r)>>1;
	tre[i]=node(l,r,mid);
	if(l==r)return (void)(tre[i].t1=(a[l]>=x));
	buildtre(lc,l,mid,x);
	buildtre(rc,mid+1,r,x);
	pushup(i);
}

inline int query(const int i,const int l,const int r){
	// printf("query : %d %d %d\n",i,l,r);
	if(l<=tre[i].l&&tre[i].r<=r)return tre[i].t1;
	if(tre[i].lazy!=-1)pushdown(i);
	int ret=0;
	if(l<=tre[i].mid)ret+=query(lc,l,r);
	if(tre[i].mid<r)ret+=query(rc,l,r);
	pushup(i);
	return ret;
}

inline void update(const int i,const int l,const int r,const int var){
	// if(l>r)return;
	// printf("update : %d to %d, %d\n",l,r,var);
	if(l<=tre[i].l&&tre[i].r<=r){
		tre[i].lazy=var;
		tre[i].t1=(tre[i].r-tre[i].l+1)*var;
		return;
	}
	if(tre[i].lazy!=-1)pushdown(i);
	if(l<=tre[i].mid)update(lc,l,r,var);
	if(tre[i].mid<r)update(rc,l,r,var);
	pushup(i);
}

inline int query(const int i,const int p){
	// printf("update : %d %d\n",i,p);
	if(tre[i].l==tre[i].r)return tre[i].t1;
	if(tre[i].lazy!=-1)pushdown(i);
	int ret;
	if(p<=tre[i].mid)ret=query(lc,p);
	else ret=query(rc,p);
	pushup(i);
	return ret;
}

inline bool check(const int x){
	// printf("Now check : x == %d\n",x);
	buildtre(1,1,n,x);
	// for(int i=1;i<=13;++i)printf("tre[%d] : %d %d %d %d %d\n",i,tre[i].l,tre[i].r,tre[i].mid,tre[i].t1,tre[i].lazy);
	rep(i,1,m){
		int cnt1=query(1,p[i].l,p[i].r);
		int cnt0=p[i].r-p[i].l+1-cnt1;
		// printf("query : %d %d, cnt1 == %d, cnt0 == %d\n",p[i].l,p[i].r,cnt1,cnt0);
		if(p[i].op==0){
			if(cnt0)update(1,p[i].l,p[i].l+cnt0-1,0);
			if(cnt1)update(1,p[i].l+cnt0,p[i].r,1);
			// printf("update : %d to %d, %d\n",p[i].l,p[i].l+cnt0-1,0);
			// printf("update : %d to %d, %d\n",p[i].l+cnt0,p[i].r,1);
		}
		else{
			if(cnt1)update(1,p[i].l,p[i].l+cnt1-1,1);
			if(cnt0)update(1,p[i].l+cnt1,p[i].r,0);
			// printf("update : %d to %d, %d\n",p[i].l,p[i].l+cnt1-1,0);
			// printf("update : %d to %d, %d\n",p[i].l+cnt1,p[i].r,1);
		}
		// printf("Now The info of the tre :\n");
		// for(int j=1;j<=13;++j)printf("tre[%d] : %d %d %d %d %d\n",j,tre[j].l,tre[j].r,tre[j].mid,tre[j].t1,tre[j].lazy);
	}
	// printf("When x == %d,ans == %d\n",x,query(1,q));
	return query(1,q);
}

inline void biSearch(){
	int l=0,r=n,x=0,ans;
	while(l<=r){
		x=(l+r)>>1;
		if(check(x))ans=x,l=x+1;
		else r=x-1;
	}
	fwrit(ans),putchar('\n');
}

signed main(){
#ifdef FILEOI
	freopen("sort.in","r",stdin);
	freopen("sort.out","w",stdout);
#endif
	init();
	biSearch();
	return 0;
}
```


---

## 作者：zhaoyuweijsnt (赞：0)

答案的区间是$[1,n]$，考虑二分答案。

在check的时候我们把当前假设的答案记为$u$，比$u$大的位置记为$1$，否则记为$0$，得到一个新的01序列，用这个序列建线段树，维护区间和。当我们遇到对一个区间顺序排序的询问，就是把区间里的1放到区间的最后，否则把0放在区间最后。每次check需要做$m$个操作，操作结束之后如果目标位置的值为$1$，就说明答案大于$u$，否则小于等于$u$。

渐进时间复杂度$O((n + m) \log ^2 n )$。

类似题目：[Gym – 101234A](https://codeforces.com/gym/101234/problem/A)

我的博客：[SweetCigarettes
](http://www.cfzhao.com)

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;

const int MAX_N = 100000 + 5;
int n, m, a[MAX_N], b[MAX_N], tree[MAX_N << 2], tag[MAX_N << 2];
int op[MAX_N], opL[MAX_N], opR[MAX_N];
int pos;

void makeTag(int u) {
    for (int i = 1; i <= n; ++i) b[i] = (a[i] > u ? 1 : 0); 
    // printf("u = %d\n", u);
    // for (int i = 1; i <= n; ++i) printf("%d%c", b[i], i == n ? '\n' : ' ');
}

inline int ls(int o) {
    return o << 1;
}

inline int rs(int o) {
    return o << 1 | 1;
}

inline void pushUp(int o) {
    tree[o] = tree[ls(o)] + tree[rs(o)];
}

inline void pushDown(int o, int l, int r) {
    if (tag[o] == -1) return;
    tag[ls(o)] = tag[rs(o)] = tag[o];
    int mid = (l + r) >> 1;
    tree[ls(o)] = tag[o] * (mid - l + 1); 
    tree[rs(o)] = tag[o] * (r - mid); 
    tag[o] = -1;
}

void build(int o, int l, int r) {
    tag[o] = -1;
    if (l == r) {
        tree[o] = b[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(ls(o), l, mid);
    build(rs(o), mid + 1, r);
    pushUp(o);
}

void update(int o, int l, int r, int L, int R, int v) {
    if (L <= l && r <= R) {
        tag[o] = v;
        tree[o] = v * (r - l + 1);
        return;
    }
    int mid = (l + r) >> 1;
    pushDown(o, l, r);
    if (L <= mid) update(ls(o), l, mid, L, R, v);
    if (R > mid) update(rs(o), mid + 1, r, L, R, v);
    pushUp(o);
}

int query(int o, int l, int r, int L, int R) {
    if (L <= l && r <= R) return tree[o];
    int mid = (l + r) >> 1, ret = 0;
    pushDown(o, l, r);
    if (L <= mid) ret += query(ls(o), l, mid, L, R);
    if (R > mid) ret += query(rs(o), mid + 1, r, L, R);
    return ret;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%d", a + i);
    for (int i = 1; i <= m; ++i) scanf("%d%d%d", op + i, opL + i, opR + i);
    scanf("%d", &pos);
    int l = 1, r = n;
    while (l < r) {
        // printf("l = %d, r = %d\n", l, r);
        int mid = (l + r) >> 1;
        makeTag(mid);
        build(1, 1, n);
        for (int i = 1; i <= m; ++i) {
            int sum = query(1, 1, n, opL[i], opR[i]);
            // printf("sum = %d\n", sum);
            switch (op[i]) {
                case 0: {
                    int k = opR[i] - sum + 1;
                    if (opL[i] <= k - 1) update(1, 1, n, opL[i], k - 1, 0);
                    if (opR[i] >= k) update(1, 1, n, k, opR[i], 1);
                    break;
                }
                case 1: {
                    int k = opL[i] + sum - 1;
                    if (opL[i] <= k) update(1, 1, n, opL[i], k, 1);
                    if (opR[i] >= k + 1) update(1, 1, n, k + 1, opR[i], 0);
                    break;
                }
            }
        }
        if (query(1, 1, n, pos, pos)) l = mid + 1;
        else r = mid;
    }
    printf("%d\n", l);
    return 0;
}
```

---


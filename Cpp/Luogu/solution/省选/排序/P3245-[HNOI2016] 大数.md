# [HNOI2016] 大数

## 题目描述

小 B 有一个很大的数 $S$，长度达到了 $n$ 位；这个数可以看成是一个数字串，它可能有前导 $0$，例如 `00009312345`。小 B 还有一个素数 $p$。现在，小 B 提出了 $m$ 个询问，每个询问求 $S$ 的一个子串中有多少子串是 $p$ 的倍数（$0$ 也是 $p$ 的倍数）。例如 $S$ 为 `0077` 时，其子串 `007` 有 $6$ 个子串：`0,0,7,00,07,007`；显然 `0077` 的子串 `007` 有 $6$ 个子串都是素数 $7$ 的倍数。

## 说明/提示

#### 样例 1 解释

第一个询问问的是整个串，满足条件的子串分别有：`121121,2112,11,121,121`。

#### 数据范围

对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^5$，$2\le p\le 10^9$，$S$ 中只有数字字符，$p$ 为素数。

## 样例 #1

### 输入

```
11
121121
3
1 6
1 5
1 4```

### 输出

```
5
3
2
//第一个询问问的是整个串，满足条件的子串分别有：121121,2112,11,121,121。```

# 题解

## 作者：nosta (赞：23)

若区间[l,r]构成的数字是p的倍数，定义t[i]是i~n位构成的数字，有(t[l]-t[r+1])/10^(r-l+1)=0(mod p)。

当gcd(10,p)=1时，即10!=0(mod p)，再即10^(r-l+1)!=0(mod p)，那么有t[l]-t[r+1]=0(mod p)；我们令t[i]=t[i]%p，则此时有t[l]=t[r+1]，问题转化为在给定区间内数值相的点对数量；

当gcd(10,p)!=1时因为p为素数，有p=2或p=5。由于分母为0，放弃上做法，考虑个位律：对于p=2，在询问区间内查询第二点为末尾为02468的点对数，同理对于p=5，查询第二点为末尾为05的点对数。

具体地，第一类问题我们使用莫队求无序点对数；而第二类中，可以转化到统计区间内合法的第二点的位置之和与个数。

![panda](https://cdn.luogu.com.cn/upload/pic/55295.png)

```cpp
#include <bits/stdc++.h>
#define ll long long 
using namespace std;
const int N=1e5+10;

int p,n,m;
char str[N];

namespace Solve1 { //O(n^1.5)
	int bel[N],cnt[N],t[N],d[N],siz;
	ll ans[N],now;
	struct Query{
		int l,r,id;
		bool operator<(const Query&d) const{
			return bel[l]!=bel[d.l]?l<d.l:r<d.r;
		}
	} q[N];
	void add(int x) {
		now-=1ll*cnt[x]*(cnt[x]-1)/2; cnt[x]++;
		now+=1ll*cnt[x]*(cnt[x]-1)/2; 
	}
	void del(int x) {
		now-=1ll*cnt[x]*(cnt[x]-1)/2; cnt[x]--;
		now+=1ll*cnt[x]*(cnt[x]-1)/2; 
	}
	void main() {
		siz=sqrt(n);
		bel[n+1]=n/siz+1;
		int c=1;
		for(int i=n; i; --i,c=1LL*c*10%p) {
			t[i]=(1LL*c*(str[i]-'0')%p+t[i+1])%p;
			d[i]=t[i];
			bel[i]=(i-1)/siz+1;
		}
		sort(d+1,d+n+2);
		c=unique(d+1,d+n+2)-d-1;
		for(int i=1; i<=n+1; ++i) {
			t[i]=lower_bound(d+1,d+c+1,t[i])-d;
		}
		scanf("%d",&m);
		for(int i=1; i<=m; ++i) {
			scanf("%d%d",&q[i].l,&q[i].r);
			q[i].id=i; q[i].r++;
		}
		sort(q+1,q+m+1);
		for(int i=1,l=1,r=0; i<=m; ++i) {
			while(l<q[i].l) del(t[l++]);
			while(q[i].l<l) add(t[--l]);
			while(r<q[i].r) add(t[++r]);
			while(q[i].r<r) del(t[r--]);
			ans[q[i].id]=now;
		}
		for(int i=1; i<=m; ++i) {
			printf("%lld\n",ans[i]);
		}
	}
}
namespace Solve2 { //O(n)
	bool lgl[10];
	ll snum[N],spos[N];
	void main() {
		if(p==2) lgl[0]=lgl[2]=lgl[4]=lgl[6]=lgl[8]=1;
		if(p==5) lgl[0]=lgl[5]=1;
		for(int i=1; i<=n; ++i) {
			snum[i]=snum[i-1]+lgl[str[i]-'0'];
			spos[i]=spos[i-1]+lgl[str[i]-'0']*i;
		}
		scanf("%d",&m);
		for(int l,r; m--; ) {
			scanf("%d%d",&l,&r);
			printf("%lld\n",spos[r]-spos[l-1]-(snum[r]-snum[l-1])*(l-1));
		}
	}
}

int main() {
	scanf("%d%s",&p,str+1);
	n=strlen(str+1);
	if(p==2||p==5) Solve2::main();
	else Solve1::main();
	return 0;
}
```

---

## 作者：Cxs3 (赞：19)

题目链接:https://www.luogu.com.cn/problem/P3245

---

## $\text{Solution}$
为方便起见，我们用$[L,R]$表示$S[L...R]$这段数字，用$sum[i]$表示$S[i...n]$的值。  
则易得：  
$$[L,R]\times10^{n-R}=sum[L]-sum[R+1]$$  
$$\Rightarrow [L,R]=\frac{sum[L]-sum[R+1]}{10^{n-R}} $$  

---

- 当$10^{n-R}$与$P$互质时（即$P\neq2$且$P\neq5$）：  
若$[L,R]\ mod\ P=0$，则：  
$$\frac{sum[L]-sum[R+1]}{10^{n-R}}\ mod\ P=0$$  
$$\Rightarrow(sum[L]-sum[R+1])\ mod\ P=0$$  
$$\Rightarrow sum[L]\ mod\ P =sum[R+1]\ mod\ P$$  
这时我们让$sum[i]$的意义改变：表示$S[i...n]$的值$mod\ P$后的**余数**。  
也就是说，若$sum[L]=sum[R+1]$，则$[L,R]\ mod\ P=0$.  
这样问题就转化为求$sum[L...R+1]$中**相等的数字有多少对**。  
由此，这道题就变成了[小Z的袜子](https://www.luogu.com.cn/problem/P1494)，可以用[莫队](https://www.cnblogs.com/WAMonster/p/10118934.html)来求解。  

我们用$cnt[sum[x]]$表示在当前区间$[L,R]$中值为$sum[x]$的点有多少个。每当加进来一个点$x$时，这个点可以分别与$[L,R]$中$cnt[sum[x]]$个点配对成一对（因为值相同，都是$sum[x]$），则当前答案$nowans+=cnt[sum[x]]$.删去点$x$时也同理。  
需要注意的是，由于$sum[x]$太大，需要进行离散化才能作为数组下标。  
还有就是，若$sum[x]=0$，则这个点不用与其他点配对，自己本身就可以作为一种答案，所以在代码中新加一个值为$0$的点（`sum[n+1]=0`），与之配对来计入这一部分答案。

---

- 当$10^{n-R}$与$P$不互质时（即$P=2$或$P=5$）：  
这时问题就更简单了，因为是$10$进制，若最后一位能被$P$整除，则这个数字就可以被$P$整除。即若$a[i]\ mod\ P=0$，答案就增加$i$个 。  
对于每一个询问，计算每一位的贡献做前缀和即可。

---

## $\text{Code}$
```cpp
#include<bits/stdc++.h>
#define ll long long
const int N=2e5+10;
using namespace std;

struct node
{
    ll l,r,id;
}h[N];
struct date
{
    ll d,id;
}s[N];
ll n,m,size,p;
ll a[N],num[N],bl[N],cnt[N],now,ans[N];
char c[N];

ll read()
{
    ll a,f=1;
    char c;
    c=getchar();
    while(!isdigit(c)){f=c=='-'?-1:f; c=getchar();}
    a=c-'0'; c=getchar();
    while(isdigit(c)){a=a*10+c-'0'; c=getchar();}
    return a*f;
}

void solve()
{
    ll i,l,r,tot,mus;
    for(i=1;i<=n;i++)
    {
      s[i]=s[i-1];
      if(a[i]%p==0){s[i].d+=i; s[i].id++;}
    }
    m=read();
    while(m--)
    {
      l=read(); r=read();
      tot=s[r].d-s[l-1].d;//全部的贡献 
      mus=(l-1)*(s[r].id-s[l-1].id);//区间[1,l-1]里产生的贡献 
      printf("%lld\n",tot-mus);//相减得到[l,r]里的贡献 
    }
}

bool cmp1(date x,date y){return x.d<y.d;}

void prework()
{
    ll i,len=0,pow=1;
    size=sqrt(n);//莫队分块的时候，不能在n++之后分，不然会出问题emmm 
	bl[n+1]=n/size+1;
    for(i=n;i>0;i--)//算出[i,n]这段数字%p的余数 
    {
      s[i].d=(s[i+1].d+a[i]*pow)%p;
      s[i].id=i; pow=pow*10%p;//s[i].id用来记录原来的编号 
      bl[i]=(i-1)/size+1;//顺便分块 
    }
    s[++n].d=0; s[n].id=n;//新加一个点 
    sort(s+1,s+n+1,cmp1);
    for(i=1;i<=n;i++)//（非常朴素的）离散化 
    {
      if(i==1||s[i].d!=s[i-1].d) len++;
      num[s[i].id]=len;
    }
}

bool cmp2(node x,node y)
{
    if(bl[x.l]^bl[y.l]) return bl[x.l]<bl[y.l];
    return (bl[x.l]&1)?(x.r<y.r):(x.r>y.r);
	//莫队排序小技巧： 奇数块升序，偶数块降序 
}

void add(ll x){now+=cnt[num[x]]; cnt[num[x]]++;}
//注意now与cnt数组改变的先后顺序 
void del(ll x){cnt[num[x]]--; now-=cnt[num[x]];}

int main()
{
    ll i,j,l,r;
    p=read(); scanf("%s",c);
    n=strlen(c);
	for(i=1;i<=n;i++) a[i]=c[i-1]-'0';
    if(p==2||p==5){solve(); return 0;}//特判 
    prework();
    m=read();
    for(i=1;i<=m;i++)
    {
      h[i].l=read();
      h[i].r=read()+1;//在这里就+1 
      h[i].id=i;
    }
    sort(h+1,h+m+1,cmp2);
    l=1; r=0;
    for(i=1;i<=m;i++)//莫队 
    {
      while(l<h[i].l) del(l++);
      while(l>h[i].l) add(--l);
      while(r<h[i].r) add(++r);
      while(r>h[i].r) del(r--);
      ans[h[i].id]=now;
    }
    for(i=1;i<=m;i++) printf("%lld\n",ans[i]);
    return 0;
}
```

---

## 作者：pomelo_nene (赞：7)

定义 $q_i$ 为区间 $[i,n]$ 构成的数，满足区间 $[l,r]$ 能被 $p$ 整除，一定有 $\dfrac{r_l-r_{r+1}}{10^{r-l+1}} \equiv 0 (\bmod \ p)$。

因此考虑化化式子。首先如果 $p | 10$，即 $\gcd(p,10) \not = 1$ 时，我们直接处理。否则因为 $10 \not \equiv 0 (\bmod \ p)$ ，所以上式成立的条件即为 $r_l \bmod p=r_{{r+1}} \bmod p$。离散化一下，问题就转化成区间求相等点对的问题了。可以直接莫队求解。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
//char buf[1<<21],*p1=buf,*p2=buf;
//#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
LL read()
{
	LL x=0,f=1;
	char c=getchar();
	while(c<'0' || c>'9')
	{
		if(c=='-')	f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x*f;
}
void write(LL x)
{
	if(x<0)	putchar('-'),x=-x;
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
LL pos[200005],ans[200005],m,p,n,sz,cnt[200005],t[200005],q[200005],gr,jm1[200005],jm2[200005];
char s[200005];
struct queries{
	LL l,r,id;
	queries(){l=r=id=0;}
	queries(LL L,LL R,LL I){l=L,r=R,id=I;}
	bool operator < (queries o) const {
		if(pos[l]==pos[o.l])	return r<o.r;
		return l<o.l;
	}
}que[200005];
LL QuickPow(LL a,LL x)
{
	LL base=a,ans=1;
	while(x)
	{
		if(x&1)	ans*=base;
		x>>=1;
		base*=base;
	}
	return ans;
}
void add(LL n)
{
	gr-=cnt[q[n]]*(cnt[q[n]]-1)/2;
	++cnt[q[n]];
	gr+=cnt[q[n]]*(cnt[q[n]]-1)/2;
}
void sub(LL n)
{
	gr-=cnt[q[n]]*(cnt[q[n]]-1)/2;
	--cnt[q[n]];
	gr+=cnt[q[n]]*(cnt[q[n]]-1)/2;
}
int main(){
//	scanf("%lld",&p);
	p=read();
	scanf("%s",s+1);
	n=LL(strlen(s+1));
	sz=sqrt(n);
	m=read();
	if(p==2 || p==5)
	{
		for(LL i=1;i<=n;++i)
		{
			jm1[i]=jm1[i-1];
			jm2[i]=jm2[i-1];
			if((s[i]^'0')%p==0)	++jm1[i],jm2[i]+=i;
		}
		for(LL i=1;i<=m;++i)
		{
			LL l=read(),r=read();
			write(jm2[r]-jm2[l-1]-(l-1)*(jm1[r]-jm1[l-1]));
			puts("");
		}
		return 0;
	}
	for(LL i=n,tn=1;i;--i,tn*=10,tn%=p)	t[i]=q[i]=((s[i]^'0')*tn%p+q[i+1])%p;
	sort(t+1,t+1+n+1);
	LL len=unique(t+1,t+1+n+1)-t-1;
	for(LL i=1;i<=n+1;++i)	q[i]=lower_bound(t+1,t+1+len,q[i])-t,pos[i]=(i-1)/sz+1;
	for(LL i=1;i<=m;++i)
	{
		LL l=read(),r=read();
		que[i]=queries(l,r+1,i);
	}
	sort(que+1,que+1+m);
	for(LL l=1,r=0,i=1;i<=m;++i)
	{
		while(l>que[i].l)	add(--l);
		while(r<que[i].r)	add(++r);
		while(l<que[i].l)	sub(l++);
		while(r>que[i].r)	sub(r--);
		ans[que[i].id]=gr;
//		for(LL i=1;i<=n+1;++i)	printf("%lld ",cnt[i]);
//		puts("");
	}
	for(LL i=1;i<=m;++i)	write(ans[i]),puts("");
	return 0;
}
/*
11
121121
3
1 6
1 5
1 4
*/
```

$\ \ $

---

## 作者：Sangber (赞：5)

### 题目描述
给定一个质数$p$和一个数字序列，每次询问一段区间$[l,r]$,  
求出该序列区间$[l,r]$内的所有子串，满足该子串所形成的数是$p$的倍数(样例的解释也挺直观的)

----
### 基本思路
这题的话，满足莫队的离线查询套路，所以用莫队蛮好写。  

我们考虑这样一个思路：  
众所周知，判断两个数的倍数关系是通过取模来实现的，所以我们考虑对于每一个位置$\ i\ $，定义一个$s_i$  
表示$\overline{a_ia_{i+1}...a_n}$这个后缀模$\ p\ $的值，再把它离散化，这样我们就可以实现单次移动在$O(1)$时间内完成(见下)  
```cpp
inline void upt(int x, int v) {
    //x为传入的s的值，v是当前操作带来的变化值(1则为加上贡献，-1则为减去贡献)
    //tong是计数器，存储当前s的数量
    ans -= tong[x] * (tong[x] - 1) / 2;
    tong[x] += v;
    ans += tong[x] * (tong[x] - 1) / 2;
}
```
搞定这一步，接下来考虑$s$如何转移：  
由于是求后缀，我们考虑从后往前枚举$a_i$，我们推一下式子  
$$s_i\equiv\overline{a_ia_{i+1}...a_n}\equiv a_i\times10^{n-i+1}+\overline{a_{i+1}a_{i+2}...a_n}\equiv a_i\times10^{n-i+1}\bmod p+s_{i+1}(\bmod\ p)$$
所以我们只需要在枚举的时候不断更新$10^{n-i+1}$即可  
然后我们就可以发现，如果一个区间$[l,r]$所表示的数$\overline{a_la_{l+1}...a_r}$，它如果是$p$的倍数的话，显然有$s_l=s_{r+1}$  
小小的证明：  
$$\because\  \overline{a_la_{l+1}...a_r} \equiv 0(\bmod\ p)$$
$$\therefore\  \overline{a_la_{l+1}...a_r}\times10^{n-r}\equiv0(\bmod\ p)$$
$$\therefore \overline{a_la_{l+1}...a_n}-\overline{a_{r+1}a_{r+2}...a_n}\equiv0(\bmod\ p)$$
$$\therefore s_l=s_{r+1}$$
**但是！！！**  
在上述的证明中第一次推导是不严谨的，因为可能存在$p\mid10$使得原式成立，这就引来了重点的分类讨论  
对于$p\nmid10$也就是$p\ne2$且$p\ne5$时，我们可以用上述方法，结合莫队来离线求解。  
而对于$p=2$或$p=5$的情况，我们直接写特判：  
我们发现，判断一个数是不是$2$或$5$的倍数，只需要看个位数字是否被该数字整除即可。  
所以我们考虑对于每一个位置$i$，记录下区间$[1,i]$中的$p$的个数及总贡献：  
```cpp
    if (p == 2) bo[0] = bo[2] = bo[4] = bo[6] = bo[8] = 1;
    if (p == 5) bo[0] = bo[5] = 1;
    for (rg int i = 1; i <= n; ++i) {
        f[i] = f[i - 1] + bo[num[i] ^ 48];//f为区间[1,i]中的p的个数
        g[i] = g[i - 1] + bo[num[i] ^ 48] * i;
        //g为区间[1,i]的总贡献，乘上一个i是因为乘法原理，这个可以自己简单想一想
    }
```
查询贡献时我们就可以直接在线搞：
```cpp
    m = read();
    for (rg int l, r, i = 1; i <= m; ++i) {
        l = read(), r = read();
        /*-----想一想为什么-----*/
        printf("%lld\n", g[r] - g[l - 1] - (f[r] - f[l - 1]) * (l - 1));
    }
```
那么至此这道题就解决了。

----
### 细节注意事项
1. 这题应该要开$long\ long$
1. 莫队别写挂了。。。

----
### 参考代码
```cpp
/*--------------------------------
  Code name: HNOI2016 BigNumber
  Author: The Ace Bee
  This code is made by The Ace Bee
--------------------------------*/
#include <cmath>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define rg register
#define int long long 
const int MAXN = 200010;
inline int read() {
    int s = 0; bool f = false; char c = getchar();
    while (c < '0' || c > '9') f |= (c == '-'), c = getchar();
    while (c >= '0' && c <= '9') s = (s << 3) + (s << 1) + (c ^ 48), c = getchar();
    return f ? -s : s;
}
char num[MAXN]; int bo[10], f[MAXN], g[MAXN];
int p, m, s[MAXN], s1[MAXN], gap, pos[MAXN];
struct Ask{ int l, r, id; }q[MAXN];
inline bool cmp(const Ask& x, const Ask& y)
{ return pos[x.l] == pos[y.l] ? x.r < y.r : x.l < y.l; }
int ans, res[MAXN], cnt[MAXN];
inline void upt(int x, int v) {
    ans -= cnt[x] * (cnt[x] - 1) / 2;
    cnt[x] += v;
    ans += cnt[x] * (cnt[x] - 1) / 2;
}
signed main() {
    p = read();
    scanf("%s", num + 1);
    int n = strlen(num + 1);
    if (p != 2 && p != 5) {
        m = read();
        for (rg int i = 1; i <= m; ++i) q[i].l = read(), q[i].r = read() + 1, q[i].id = i;
        gap = sqrt(n * 1.0);
        pos[n + 1] = n / gap + 1;
        for (rg int c = 1, i = n; i >= 1; --i, c = c * 10 % p) {
            s1[i] = s[i] = ((num[i] ^ 48) * c % p + s[i + 1]) % p；
            pos[i] = (i - 1) / gap + 1;
        }
        std :: sort(s1 + 1, s1 + 2 + n);
        int t = std :: unique(s1 + 1, s1 + 2 + n) - s1 - 1;
        for (rg int i = 1; i <= n + 1; ++i)
            s[i] = std :: lower_bound(s1 + 1, s1 + 1 + t, s[i]) - s1;
        std :: sort(q + 1, q + 1 + m, cmp);
        for (rg int l = 1, r = 0, i = 1; i <= m; ++i) {
            while (l < q[i].l) upt(s[l++], -1);
            while (l > q[i].l) upt(s[--l], 1);
            while (r < q[i].r) upt(s[++r], 1);
            while (r > q[i].r) upt(s[r--], -1);
            res[q[i].id] = ans;
        }
        for (rg int i = 1; i <= m; ++i) printf("%lld\n", res[i]);
    } else {
        if (p == 2) bo[0] = bo[2] = bo[4] = bo[6] = bo[8] = 1;
        if (p == 5) bo[0] = bo[5] = 1;
        for (rg int i = 1; i <= n; ++i) {
            f[i] = f[i - 1] + bo[num[i] ^ 48];
            g[i] = g[i - 1] + bo[num[i] ^ 48] * i;
        }
        m = read();
        for (rg int l, r, i = 1; i <= m; ++i) {
            l = read(), r = read();
            printf("%lld\n", g[r] - g[l - 1] - (f[r] - f[l - 1]) * (l - 1));
        }
    }
    return 0;
}

```
**完结撒花$qwq$**

---

## 作者：Celtic (赞：3)

题意：询问给定区间有多少个子区间是质数 $p$ 的倍数。

记 $s_i$ 表示从第 $i$ 位到第 $n$ 位构成的数除以 $p$ 的余数。

转移很简单，$s_i=a_i\times 10^{n-i}+s_i+1$ 。

边界情况 $s_{n+1}=0$ 。

有了 $s$ 数组，我们看区间 $l,r$ 是 $p$ 的倍数的情况

$$\overline{a_l,a_{l+1},\dots,a_r}\equiv 0\pmod p$$

$$\overline{a_l,a_{l+1},\dots,a_r}\times10^{n-r}\equiv 0\pmod p$$

$$\overline{a_l,a_{l+1},\dots,a_n}-\overline{a_{r+1},a_{r+2},\dots,a_n}\equiv 0\pmod p$$

$$s_l-s_{r+1}\equiv 0\pmod p$$

$$s_l=s_{r+1}$$

所以我们直接莫队，然后把区间右端点 $+1$ ，移动的时候直接减去它对答案的贡献就行了。

但是注意，尽管我们推的没有问题，但是它**不能反推回去**。

也就是在第二步，当 $p\mid10$ 时，由 $s_l=s_{r+1}$ 是无法推回去的。

由于 $p$ 为质数，所以此时 $p$ 只能是 $2$ 或者 $5$。

发现当 $p$ 是这两个数的时候一个数整除它只需要看最后一位就行了。

于是直接处理下前缀和，在线询问即可。

具体见代码。

```cpp
#include<bits/stdc++.h>
#define MAX 2001
#define N 2001001
#define re register
#define inf 1e18
using namespace std;
typedef long long ll;
typedef double db;
const ll mod=998244353;
inline void read(re ll &ret)
{
	ret=0;re char c=getchar();re bool pd=false;
	while(!isdigit(c)){pd|=c=='-';c=getchar();}
	while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}
	ret=pd?-ret:ret;
	return;
}
ll p,n,m,q[N],pre[N],xx[N],len,val[N],b[N],num[N],ans;
char s[N];
struct query
{
	ll l,r,ans,t;
	inline friend bool operator <(re query x,re query y)
	{
		if(q[x.l]==q[y.l])
			return x.r<y.r;
		return q[x.l]<q[y.l];
	}
}que[N];
ll f[N];
inline void add(re ll pos)
{
	ans+=num[val[pos]];
	num[val[pos]]++;
	return;
}
inline void del(re ll pos)
{
	num[val[pos]]--;
	ans-=num[val[pos]];
	return;
}
inline bool cmp(re query x,re query y)
{
	return x.t<y.t;
}
signed main()
{
	read(p);
	scanf("%s",s+1);
	n=strlen(s+1);
	read(m);
	if(p==2||p==5)
	{
		for(re int i=0;i<10;i+=p)
			f[i]=1;
		for(re int i=1;i<=n;i++)
		{
			pre[i]=pre[i-1]+f[s[i]&15];
			xx[i]=xx[i-1]+f[s[i]&15]*i;
		}
		for(re int i=1;i<=m;i++)
		{
			read(que[i].l);
			read(que[i].r);
			printf("%lld\n",xx[que[i].r]-xx[que[i].l-1]-(que[i].l-1)*(pre[que[i].r]-pre[que[i].l-1]));
		}
	}
	else
	{
		len=n/sqrt(m)+1;
		for(re int i=1;i<=n;i++)
			q[i]=(i-1)/len+1;
		re ll now=1;
		b[n+1]=val[n+1];
		for(re int i=n;i;i--)
		{
			val[i]=(val[i+1]+now*(s[i]&15))%p,b[i]=val[i];
			now=((now<<1)+(now<<3))%p;
		}
		sort(b+1,b+n+2);
		re ll all=unique(b+1,b+n+2)-b-1;
		for(re int i=1;i<=n+1;i++)
			val[i]=lower_bound(b+1,b+all+1,val[i])-b;
		for(re int i=1;i<=m;i++)
		{
			read(que[i].l);
			read(que[i].r);
			que[i].r++;
			que[i].t=i,que[i].ans=0;
		}
		sort(que+1,que+m+1);
		re ll l=2,r=1;
		for(re int i=1;i<=m;i++)
		{
			while(l>que[i].l)
			{
				l--;
				add(l);
			}
			while(r<que[i].r)
			{
				r++;
				add(r);
			}
			while(l<que[i].l)
			{
				del(l);
				l++;
			}
			while(r>que[i].r)
			{
				del(r);
				r--;
			}
			que[i].ans=ans;
		}
		sort(que+1,que+m+1,cmp);
		for(re int i=1;i<=m;i++)
			printf("%lld\n",que[i].ans);
	}
	exit(0);
}
```


---

## 作者：xryjr233 (赞：3)

首先,考虑如和判断一个区间内的数是否为某个质数的倍数。

设$num_i$表示区间$[i,n]$组成的数。

如果区间$[l,r]$内的数是质数$p$的倍数,则:

$\frac{num_l-num_{r+1}}{10^{r-l+1}}\equiv0(mod\ p)$

当$p\ne2,5$时,$gcd(10,p)=1$则当且仅当

$num_l-num_{r+1}\equiv0(mod\ p)$

即

$num_l\ mod\ p=num_{r+1}\ mod\ p$

时,区间$[l,r]$内的数是$p$的倍数。

当$p=2$或$p=5$,倍数性质只和最后一位有关,非常好判断。

回到题目

有了上述结论,直接莫队即可。

当$p\ne2,5$时,设$h$为离散化后的$num$(对$p$取余),记录$cnt_i$为当前区间$[l,r]$内$h_j=i(j\in[l,r])$的数量,加入第$i$个数的时候答案加上$cnt_{h_i}$,$cnt_{h_i}$加上一即可。

当$p=2,5$时,记$cnt$为当前区间内$p$的倍数的个数。当从加入一个数,如果是$p$的倍数$cnt++$。当从左边加入,答案加上$cnt$;当从右边加入,如果是$p$的倍数,答案加上区间长度。

删除同理。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
struct query{
    int l,r,blk,id;
}q[100010];
struct Ls{
    long long v;
    int id;
}ls[100010];
int p,n,m,bs,l,r,cnt,tot,num[100010];
long long h[100010],POW[100010];
long long ans,prt[100010];
char s[100010];
bool cmp(query x,query y){
    if(x.blk==y.blk){
        if(x.blk&1)return x.r>y.r;
        else return x.r<y.r;
    }else return x.blk<y.blk;
}
bool Cmp(Ls x,Ls y){
    return x.v<y.v;
}
void Ins(int x){
    ans+=num[h[x]];
    num[h[x]]++;
}
void Del(int x){
    num[h[x]]--;
    ans-=num[h[x]];
}
void insl(int x){
    cnt+=(s[x]-'0')%p==0;
    ans+=cnt;
}
void insr(int x){
    if((s[x]-'0')%p==0)cnt++,ans+=r-l+1;
}
void dell(int x){
    ans-=cnt;
    cnt-=(s[x]-'0')%p==0;
}
void delr(int x){
    if((s[x]-'0')%p==0)ans-=r-l+1,cnt--;
}
int main(){
    scanf("%d%s%d",&p,s+1,&m);
    n=strlen(s+1);
    POW[0]=1;
    for(int i=1;i<=n;i++){
        POW[i]=POW[i-1]*10%p;
    }
    for(int i=n;i>=1;i--){
        ls[i].v=(ls[i+1].v+(s[i]-'0')*POW[n-i])%p;
        ls[i].id=i;
    }
    sort(ls+1,ls+n+1,Cmp);
    tot=0;
    for(int i=1;i<=n;i++){//离散化(或者hash_map+卡常)
        if(ls[i].v!=ls[i-1].v)tot++;
        h[ls[i].id]=tot;
    }
    bs=sqrt(n);
    for(int i=1;i<=m;i++){
        scanf("%d%d",&q[i].l,&q[i].r);
        q[i].blk=q[i].l/bs;
        q[i].id=i;
    }
    sort(q+1,q+m+1,cmp);
    l=1;
    r=0;
    if(p!=2&&p!=5){//一般情况
        for(int i=1;i<=m;i++){
            q[i].r++;
            while(l>q[i].l)l--,Ins(l);
            while(r<q[i].r)r++,Ins(r);
            while(l<q[i].l)Del(l),l++;
            while(r>q[i].r)Del(r),r--;
            prt[q[i].id]=ans;
        }
    }else{//特殊情况
        for(int i=1;i<=m;i++){
            while(l>q[i].l)l--,insl(l);
            while(r<q[i].r)r++,insr(r);
            while(l<q[i].l)dell(l),l++;
            while(r>q[i].r)delr(r),r--;
            prt[q[i].id]=ans;
        }
    }
    for(int i=1;i<=m;i++)printf("%lld\n",prt[i]);
    return 0;
}
```



---

## 作者：elijahqi (赞：3)

据说新加的数据一组就是 p=2||p=5的数据
分类处理

1、p=2||p=5 用pre[]表示 前缀有多少个可以被p整除的子串  a[]表示有多少个可以被P整除的数  求区间多少个子串的时候用pre[r]-pre[l-1]-【l-1中整除p对区间l~r的贡献】
2、把n个后缀组成的数字全部对p取模。

若s[l] ~ s[n]的余数和s[r] ~ s[n]的余数相同，那么s[l] ~ s[r – 1]区间内的数字就是p的倍数(l < r)

然后这个题就变成经典莫队题了：给定一个序列，每次询问[l, r]内有多少对相同的数

每一个余数s[i]给一个计数器aa[i]（需离散化），记录[l, r]中这个数出现了几次，区间长度±1时答案改变值为aa[i]。【推倒一下排列组合公式】同bzoj2038 jpy的方法  <http://www.elijahqi.win/2017/07/05/%e3%80%90bzoj2308%e3%80%91-2009%e5%9b%bd%e5%ae%b6%e9%9b%86%e8%ae%ad%e9%98%9f%e5%b0%8fz%e7%9a%84%e8%a2%9c%e5%ad%90hose/>

注意加和减aa[s[x]]-1  和aa[s[x]]

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<map>
#include<algorithm>
#define N 110000
using namespace std;
struct node{
    int l,r,id;
}data[N];
char str1[N];
map <long long,long long>mm;
int n,n1,m,a[N],aa[N];
long long pre[N],p,ans[N],map1[N],s[N],tmp;
inline int read(){
    int x=0;char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}
    return x;
}
bool cmp(node a,node b){
    if ((a.l-1)/n1==(b.l-1)/n1) return a.r<b.r;
    return (a.l-1)/n1<(b.l-1)/n1;
}
void work1(){
    for (int i=1;i<=n;++i){
        pre[i]=pre[i-1];a[i]=a[i-1];
        if ((str1[i]-'0')%p==0) pre[i]+=i,a[i]++;
    }
    for (int i=1;i<=m;++i){
        int l=read(),r=read();
        printf("%lld\n",pre[r]-pre[l-1]-(a[r]-a[l-1])*(l-1));
    }
}
inline void solve(int x){
    tmp+=aa[s[x]];aa[s[x]]+=1;
}
inline void solve1(int x){
    tmp-=aa[s[x]]-1;aa[s[x]]-=1;
}
int main(){
    freopen("3245.in","r",stdin);
    freopen("3245.out","w",stdout);
    scanf("%lld",&p);
    scanf("%s",str1);
    m=read();n=strlen(str1);
    for (int i=n;i>=1;--i) str1[i]=str1[i-1];
    if (p==5||p==2) {work1();return 0;}
    for (int i=1;i<=m;++i) data[i].l=read(),data[i].r=read(),data[i].id=i;
    n1=sqrt(n);
    sort(data+1,data+m+1,cmp);
    tmp=1;
    for (int i=n;i>=1;--i){
        s[i]=((str1[i]-'0')*tmp%p+s[i+1])%p;
        map1[i]=s[i];
        tmp=tmp*10%p;
    }
    //for (int i=1;i<=n+1;++i) printf("%d ",s[i]);printf("\n");
    sort(map1+1,map1+n+2);
    for (int i=1;i<=n+1;++i) mm[map1[i]]=i;
    for (int i=1;i<=n+1;++i) s[i]=mm[s[i]];
    //for (int i=1;i<=n+1;++i) printf("%d ",s[i]);printf("\n");
    int cl=1,cr=0;
    tmp=0;
    for (int i=1;i<=m;++i){
        int l=data[i].l,r=data[i].r+1,id=data[i].id;
        while (cl>l) solve(--cl);
        while (cl<l) solve1(cl++);
        while (cr<r) solve(++cr);
        while (cr>r) solve1(cr--);
        ans[id]=tmp;
    }
    for (int i=1;i<=m;++i) printf("%lld\n",ans[i]);
    return 0;
}
```

---

## 作者：Rainybunny (赞：2)

# 题目

&emsp;&emsp;[luogu](https://www.luogu.com.cn/problem/P3245).

# 题解

&emsp;&emsp;~~一眼莫队然后卡了半天qwq。~~

&emsp;&emsp;莫队。  

&emsp;&emsp;对于 $p=2$ 或 $p=5$，发现只需要求末位数字是 $2$ 或 $5$ 的倍数的子串，比较简单，不赘述。  

&emsp;&emsp;首先一个 naive 的算法：莫队，维护一个 $\bmod p$ 的桶。记两个位置 $l<r$ 的后缀 $\bmod p$ 的余数分别为 $v_l,v_r$，则 $S[l...(r-1)]$ （如题目中的记号）满足条件，当且仅当 $\frac{v_l-v_r}{10^{r-l}}\equiv 0\pmod p$。又因为当 $p\not=2\text{ or }5$，$10^{r-l}\not\equiv0\pmod p$，所以有 $v_l\equiv v_r\pmod p$。莫队套上去就可以。

&emsp;&emsp;然后，因为后缀只有 $n$ 个，所以 $v\bmod p$ 至多有 $n$ 个值，离散化一下，就过题啦~

## 代码

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <algorithm>

typedef long long LL;

inline int rint () {
	int x = 0; char s = getchar ();
	for ( ; s < '0' || '9' < s; s = getchar () );
	for ( ; '0' <= s && s <= '9'; s = getchar () ) x = x * 10 + ( s ^ '0' );
	return x;
}

template<typename Tp>
inline void wint ( Tp x ) {
	if ( x < 0 ) putchar ( '-' ), x = ~ x + 1;
	if ( 9 < x ) wint ( x / 10 );
	putchar ( x % 10 ^ '0' );
}

const int MAXN = 2e5;
int p, n, m, blk, l = 1, r, sufval[MAXN + 5], tmp[MAXN + 5];
int bel[MAXN + 5], cnt[MAXN + 5];
char s[MAXN + 5];
LL cur, ans[MAXN + 5];

struct Query {
	int l, r, id;
	inline bool operator < ( const Query t ) const { return bel[l] ^ bel[t.l] ? l < t.l : r < t.r; }
} qry[MAXN + 5];

inline void add ( const int indx ) { cur += cnt[sufval[indx]] ++; }

inline void rem ( const int indx ) { cur -= -- cnt[sufval[indx]]; }

namespace Pis2or5 {

LL sum[MAXN + 5];
int cnt[MAXN + 5];
	
inline void main () {
	sum[0] = cnt[0] = 0;
	for ( int i = 1; i <= n; ++ i ) {
		sum[i] = sum[i - 1] + ! ( ( s[i] ^ '0' ) % p ) * i;
		cnt[i] = cnt[i - 1] + ! ( ( s[i] ^ '0' ) % p );
	}
	for ( int i = 1; i <= m; ++ i ) {
		-- qry[i].r;
		wint ( sum[qry[i].r] - sum[qry[i].l - 1] - ( qry[i].l - 1ll ) * ( cnt[qry[i].r] - cnt[qry[i].l - 1] ) );
		putchar ( '\n' );
	}
}

}

int main () {
	p = rint ();
	scanf ( "%s", s + 1 ), n = strlen ( s + 1 );
	m = rint ();
	blk = sqrt ( n ), bel[n + 1] = n / blk + 1;
	for ( int i = n, t = 1; i; -- i, t = t * 10ll % p ) {
		bel[i] = ( i - 1 ) / blk + 1;
		sufval[i] = ( 1ll * ( s[i] - '0' ) * t + sufval[i + 1] ) % p;
		tmp[i] = sufval[i];
	}
	tmp[n + 1] = sufval[n + 1] = 0;
	std :: sort ( tmp + 1, tmp + n + 2 );
	int t = std :: unique ( tmp + 1, tmp + n + 2 ) - tmp - 1;
	for ( int i = 1; i <= n + 1; ++ i ) {
		sufval[i] = std :: lower_bound ( tmp + 1, tmp + t + 1, sufval[i] ) - tmp;
	}
	for ( int i = 1; i <= m; ++ i ) {
		qry[i].l = rint (), qry[i].r = rint () + 1, qry[i].id = i;
	}
	if ( p == 2 || p == 5 ) return Pis2or5 :: main (), 0;
	std :: sort ( qry + 1, qry + m + 1 );
	for ( int i = 1; i <= m; ++ i ) {
		for ( ; r < qry[i].r; add ( ++ r ) );
		for ( ; l > qry[i].l; add ( -- l ) );
		for ( ; r > qry[i].r; rem ( r -- ) );
		for ( ; l < qry[i].l; rem ( l ++ ) );
		ans[qry[i].id] = cur;
	}
	for ( int i = 1; i <= m; ++ i ) wint ( ans[i] ), putchar ( '\n' );
	return 0;
}
```



---

## 作者：XenonKnight (赞：1)

> ## 洛谷 P3245

> 题意：给出数字串 $s$ 和一个质数 $p$。有 $m$ 次询问，每次给出区间 $[l,r]$ 问有多少个子区间，组成的数是 $p$ 的倍数，可含前导零。

> $1 \leq n \leq 10^5$

我们记 $suf_i$ 为 $i$ 的后缀组成的数模 $p$ 的值。

那么区间 $[l,r]$ 表示的数就是 $\frac{suf_l-suf_{r+1}}{10^{n-r}}$。

- 如果 $p$ 与 $10$ 互质，那么组成的数是 $p$ 的倍数就意味着 $suf_l=suf_{r+1}$，要求的就是有多少个 $l \leq i \lt j \leq r+1$ 满足 $suf_i=suf_j$，这个用莫队可以维护。注意离散化。

- 如果 $p$ 与 $10$ 互质，那么组成的数是 $p$ 的倍数当且仅当最后一位是 $p$ 的倍数。对于第 $i$ 位，如果是 $p$ 的倍数，那么对答案的贡献就是 $i-l+1$，我们记 $sum_i$ 为第 $1$ 位到第 $i$ 位 $a_i$ 是 $p$ 的倍数的**下标**的和，$cnt_i$ 为第 $1$ 位到第 $i$ 位 $a_i$ 是 $p$ 的倍数，那么答案就是 $sum_r-sum_{l-1}-(cnt_r-cnt_{l-1}) \times (l-1)$。

```cpp
//Coded by tzc_wk
/*
数据不清空，爆零两行泪。
多测不读完，爆零两行泪。
边界不特判，爆零两行泪。
贪心不证明，爆零两行泪。
D P 顺序错，爆零两行泪。
大小少等号，爆零两行泪。
变量不统一，爆零两行泪。
越界不判断，爆零两行泪。
调试不注释，爆零两行泪。
溢出不 l l，爆零两行泪。
*/
#include <bits/stdc++.h>
using namespace std;
#define fi			first
#define se			second
#define fz(i,a,b)	for(int i=a;i<=b;i++)
#define fd(i,a,b)	for(int i=a;i>=b;i--)
#define foreach(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define all(a)		a.begin(),a.end()
#define giveup(...) return printf(__VA_ARGS__),0;
#define fill0(a)	memset(a,0,sizeof(a))
#define fill1(a)	memset(a,-1,sizeof(a))
#define fillbig(a)	memset(a,0x3f,sizeof(a))
#define fillsmall(a) memset(a,0xcf,sizeof(a))
#define mask(a)		(1ll<<(a))
#define maskx(a,x)	((a)<<(x))
#define _bit(a,x)	(((a)>>(x))&1)
#define _sz(a)		((int)(a).size())
#define filei(a)	freopen(a,"r",stdin);
#define fileo(a)	freopen(a,"w",stdout);
#define fileio(a) 	freopen(a".in","r",stdin);freopen(a".out","w",stdout)
#define eprintf(...) fprintf(stderr,__VA_ARGS__)
#define put(x)		putchar(x)
#define eoln        put('\n')
#define space		put(' ')
#define y1			y_chenxiaoyan_1
#define y0			y_chenxiaoyan_0
typedef pair<int,int> pii;
inline int read(){
	int x=0,neg=1;char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	neg=-1;
		c=getchar();
	}
	while(isdigit(c))	x=x*10+c-'0',c=getchar();
	return x*neg;
}
inline void print(int x){
	if(x<0){
		putchar('-');
		print(abs(x));
		return;
	}
	if(x<=9)	putchar(x+'0');
	else{
		print(x/10);
		putchar(x%10+'0');
	}
}
inline int qpow(int x,int e,int _MOD){
	int ans=1;
	while(e){
		if(e&1)	ans=ans*x%_MOD;
		x=x*x%_MOD;
		e>>=1;
	}
	return ans;
}
int n=read(),m=read(),a[100005];
const int BLOCK_SZ=320;
int blk,L[100005],R[100005],bel[100005];
int cnt[100005],cnt_cnt[100005],cnt_cnt_blk[100005],ans[100005],key[100005],hs[100005],cntt=0;
struct query{
	int l,r,k,id;
	friend bool operator <(query a,query b){
		if(bel[a.l]!=bel[b.l])	return bel[a.l]<bel[b.l];
		else if(bel[a.l]^1)		return a.r<b.r;
		else					return a.r>b.r;
	}
} q[100005];
inline void push(int x){
	if(cnt[a[x]]){
		cnt_cnt[cnt[a[x]]]--;
		cnt_cnt_blk[bel[cnt[a[x]]]]--;
	}
	cnt[a[x]]++;
	cnt_cnt[cnt[a[x]]]++;
	cnt_cnt_blk[bel[cnt[a[x]]]]++;
}
inline void pop(int x){
	cnt_cnt[cnt[a[x]]]--;
	cnt_cnt_blk[bel[cnt[a[x]]]]--;
	cnt[a[x]]--;
	if(cnt[a[x]]){
		cnt_cnt[cnt[a[x]]]++;
		cnt_cnt_blk[bel[cnt[a[x]]]]++;
	}
}
inline int deal(int k){
	int i=1;
	for(;i<=blk;i++){
		if(k<=cnt_cnt_blk[i])	break;
		k-=cnt_cnt_blk[i];
	}
//	cout<<"k="<<k<<endl;
	for(int j=L[i];j<=R[i];j++){
		if(k<=cnt_cnt[j])	return j;
		k-=cnt_cnt[j];
	}
	return -1;
}
signed main(){
	blk=(n-1)/BLOCK_SZ+1;
	fz(i,1,n)	a[i]=read(),key[i]=a[i];
	sort(key+1,key+n+1);
	fz(i,1,n)	if(key[i]!=key[i-1])	hs[++cntt]=key[i];
	fz(i,1,n)	a[i]=lower_bound(hs+1,hs+cntt+1,a[i])-hs;
	fz(i,1,blk){
		L[i]=(i-1)*BLOCK_SZ+1;
		R[i]=min(i*BLOCK_SZ,n);
		fz(j,L[i],R[i])	bel[j]=i;
	}
	fz(i,1,m)	q[i].l=read(),q[i].r=read(),q[i].k=read(),q[i].id=i;
	sort(q+1,q+m+1);
	int l=1,r=0;
	fz(i,1,m){
//		cout<<q[i].l<<" "<<q[i].r<<" "<<q[i].k<<" "<<q[i].id<<endl;
		while(r<q[i].r)	push(++r);
		while(l>q[i].l)	push(--l);
		while(l<q[i].l)	pop(l++);
		while(r>q[i].r)	pop(r--);
//		fz(j,1,n)	cout<<cnt_cnt[j]<<" ";puts("");
//		cout<<cnt_cnt_blk[1]<<endl;
		ans[q[i].id]=deal(q[i].k);
	}
	fz(i,1,m)	cout<<ans[i]<<endl;
	return 0;
}
```

---

## 作者：crashed (赞：0)

# 题目
&emsp;&emsp;[点这里](https://www.luogu.com.cn/problem/P3245)看题目。  
# 分析
&emsp;&emsp;分类讨论。  
### $gcd(10,p)=1$  
&emsp;&emsp;此时，设$s(i)$为$[i,n]$这个子串对应的数字，那么就可以得到，任何一个子串$[i,j]$即为：  
$$(s(i)-s(j+1))\times 10^{-(i-j)}$$  
&emsp;&emsp;对于一个$\bmod p$为 0 的子串，由于数据范围内的$10^{-(i-j)}\not\equiv\pmod p$，因此一定有$s(i)=s(j+1)$。这就转化成了区间相等对数量的问题，可以离散化之后莫队。  
### $gcd(10,p)\not=1$  
&emsp;&emsp;由于$p$是素数，所以$p=2$或$p=5$。  
&emsp;&emsp;那么直接查询区间中以$2$结尾/以$5$结尾的子串数即可。  
# 代码
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <utility>
#include <algorithm>
using namespace std;

typedef long long LL;
typedef pair<int, int> ele;

const int MAXN = 2e5 + 5, MAXS = 505;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

ele val[MAXN];

int pure[MAXN], H[MAXN], tot[MAXN], ans[MAXN];
int a[MAXN], cnt[MAXN], ps[MAXN];
int N, Q, res, blk, mod;
char C[MAXN];

struct query
{
	int l, r, id, qid;
	query() { l = r = id = 0; }
	bool operator < ( const query &b ) const { return id == b.id ? ( id & 1 ? r > b.r : r < b.r ) : id < b.id; }
}q[MAXN];

int qkpow( int base, int indx )
{
	int ret = 1;
	while( indx )
	{
		if( indx & 1 ) ret = 1ll * ret * base % mod;
		base = 1ll * base * base % mod, indx >>= 1;
	}
	return ret;
}

void add( const int i ) { res += tot[H[i]] ++; }
void sub( const int i ) { res -= -- tot[H[i]]; }

int main()
{
	read( mod );
	scanf( "%s", C + 1 ), N = strlen( C + 1 );
	for( int i = 1 ; i <= N ; i ++ ) a[i] = C[i] - '0';
	read( Q );
	if( mod == 2 || mod == 5 )
	{
		for( int i = 1 ; i <= N ; i ++ )
			ps[i] = ps[i - 1] + bool( a[i] % mod == 0 ) * i,
			cnt[i] = cnt[i - 1] + bool( a[i] % mod == 0 );
		while( Q -- )
		{
			int l, r;
			read( l ), read( r );
			write( ps[r] - ps[l - 1] - 1ll * ( cnt[r] - cnt[l - 1] ) * ( l - 1 ) ), putchar( '\n' );
		}
		return 0; 
	}
	val[N + 1] = ele( 0, N + 1 );
	for( int i = N ; i ; i -- ) 
		val[i] = ele( ( 1ll * a[i] * qkpow( 10, N - i ) % mod + val[i + 1].first ) % mod, i ),
		pure[i] = val[i].first;
	std :: sort( val + 1, val + 2 + N ), val[0].first = -1;
	for( int i = 1, tot = 0 ; i <= N + 1 ; i ++ ) H[val[i].second] = ( tot += val[i].first != val[i - 1].first );
	blk = sqrt( N );
	for( int i = 1 ; i <= Q ; i ++ )
		read( q[i].l ), read( q[i].r ), q[i].r ++, q[i].id = q[i].l / blk, q[i].qid = i;
	sort( q + 1, q + 1 + Q );
	int l = 1, r = 0, id, qL, qR;
	for( int i = 1 ; i <= Q ; i ++ )
	{
		id = q[i].qid, qL = q[i].l, qR = q[i].r;
		while( r < qR ) add( ++ r );
		while( qR < r ) sub( r -- );
		while( l < qL ) sub( l ++ );
		while( qL < l ) add( -- l );
		ans[id] = res;
	}
	for( int i = 1 ; i <= Q ; i ++ ) write( ans[i] ), putchar( '\n' );
	return 0;
}
```

---

## 作者：zzw4257 (赞：0)

## 题意

> 给定一个含前导$0$数字串(本质是字符串但子串有数字意义),多次询问一个子串$S_{l,r}$的的所有子串中表示数字是给定质数$p$的倍数个数

## Solution

首先一个区间的所有子区间这种明显没有可加性(可合并性),只能增量

因此提前确定考虑莫队或在线

然后回顾要求子串表达数字是$p$的倍数,对$S_{x,y}\equiv 0\pmod p$即$\displaystyle \frac{(S_{x,|S|}-S_{y+1,|S|})}{10^{|S|-y}}\equiv 0\pmod p$

- 当$(10^{|S|-y},p)=1$时等价于$S_{x,|S|}\equiv S_{y+1,|S|}\pmod p$

  因此问题变为$\frac{[l,r]区间内有多少对数相同-(r-l+1)}{2}$莫队可做

- 否则$p=2,5$

考虑以第$i$位为结尾可以贡献为$i-(l-1)$拆成$\displaystyle f_i=\sum_{i=1}^n[$i可做结尾$]i,g_i=\sum_{i=1}^n[$i可做结尾$]\therefore ans_{l,r}=f_r-f_{l-1}-(l-1)(g_{r}-g_{l-1})$

注意一下$n+1$这个断点

---

## 作者：Taduro (赞：0)

可以看出是莫队，但怎么做呢？

首先要能把$[l,r]​$这个串形成的数在$\% p​$下表示出来，存一下后缀，$rs[i]​$表示i到n形成的数$\%p​$的值。

那么$[l,r]​$的数$num(l,r)≡\frac{rs[l]-rs[r+1]}{10^{r-l+1}}(mod\ p)​$

当$10^{r-l+1}\%p\ne0$时：$num(l,r)*10^{r-l+1}≡rs[l]-rs[r+1](mod\ p)$ 

所以如果$rs[l]=rs[r+1]$，$num(l,r)$就是p的倍数，条件是$gcd(10,p)=1$，p不能是2或5。

p=2或5的情况很好判断，可以写一个前缀和，但我又写了一个莫队。

```c++
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
struct node{
	int l,r,h;
}q[200001];
struct number{
	int z,h;
}b[200021];
int bl[200001],ro[200021],n,m,p,l,r,blo,w[200021];
int rs[200021],a[200021],sum,ans[200001],cnt;
inline bool cmp1(node c,node d){
	if (bl[c.l]!=bl[d.l]) return c.l<d.l;
	if (bl[c.l]%2) return c.r<d.r;
	return c.r>d.r;
}
inline bool cmp2(number c,number d){
	return c.z<d.z;
}
inline void addl(int x){cnt+=(a[x]%p==0);sum+=cnt;}
inline void addr(int x){sum+=(r-l+1)*(a[x]%p==0);cnt+=(a[x]%p==0);}
inline void dell(int x){sum-=cnt;cnt-=(a[x]%p==0);}
inline void delr(int x){sum-=(r-l+1)*(a[x]%p==0);cnt-=(a[x]%p==0);}
inline void add(int x){sum+=ro[rs[x]]; ro[rs[x]]++;}
inline void del(int x){ro[rs[x]]--; sum-=ro[rs[x]];}
int main(){
	char ch[100021];
	scanf("%d",&p); scanf("%s",ch+1);
	n=strlen(ch+1); blo=sqrt(n);
	for (int i=1; i<=n; i++){
		a[i]=ch[i]-'0';
		bl[i]=(i-1)/blo+1;
	}
	w[1]=1;
	for (int i=2; i<=n; i++) w[i]=w[i-1]*10%p;
	if (p!=2&&p!=5){
		for (int i=n; i>=1; i--){
			b[i].z=(b[i+1].z+a[i]*w[n-i+1])%p;
			b[i].h=i;
		}
		b[n+1].h=n+1; b[n+1].z=0;
		sort(b+1,b+n+2,cmp2);
		for (int i=1; i<=n+1; i++)
			rs[b[i].h]=rs[b[i-1].h]+(b[i].z!=b[i-1].z);
	}
	scanf("%d",&m);
	for (int i=1; i<=m; i++){
		scanf("%d%d",&q[i].l,&q[i].r);
		q[i].h=i;
	}
	sort(q+1,q+m+1,cmp1); 
	l=1;
	if (p!=2&&p!=5){
		for (int i=1; i<=m; i++){
			while (l<q[i].l) del(l),l++;
			while (l>q[i].l) l--,add(l);
			while (r>q[i].r+1) del(r),r--;
			while (r<q[i].r+1) r++,add(r);
			ans[q[i].h]=sum;			
		}
	}
	else{
		for (int i=1; i<=m; i++){
			while (l<q[i].l) dell(l),l++;
			while (l>q[i].l) l--,addl(l);
			while (r>q[i].r) delr(r),r--;
			while (r<q[i].r) r++,addr(r);
			ans[q[i].h]=sum;
		}		
	}
	for (int i=1; i<=m; i++) printf("%lld\n",ans[i]);
	return 0;
}
```



---


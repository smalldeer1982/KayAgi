# [SHOI2013] 扇形面积并

## 题目描述

 ![](https://cdn.luogu.com.cn/upload/pic/11825.png) 

给定 n 个同心的扇形，求有多少面积，被至少 $k$ 个扇形所覆盖。


## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 10^5$, $1\leq m\leq 10^6$, $1\leq k\leq 5000$, $1\leq r_i\leq 10^5$,$-m\leq a_1,a_2\leq m$。


## 样例 #1

### 输入

```
3 8 2
1 -8 8
3 -7 3
5 -5 5```

### 输出

```
76```

## 样例 #2

### 输入

```
2 4 1
4 -4 2
1 -4 4```

### 输出

```
98```

# 题解

## 作者：LPA20020220 (赞：16)

显然一份区域的贡献为覆盖其上的扇形半径的第k大的平方。所以我们可以按扇形的半径从大到小排序， 每次等于一个区间赋值的操作，  如果一个段被覆盖k次就产生贡献。（貌似比扫描线常数更小， 而且还好写...~~貌似突然rk1了？？~~）

维护一个区间最大最小值判断是否应该递归计算。 另外， 将贡献过的区间的size赋值为0， 避免重复计算。

代码如下：

```cpp
    #include <cstdio>
    #include <cstring>
    #include <cmath>
    #include <cctype>
    #include <algorithm>
    #include <cstdlib>
    #define R register
    #define IN inline
    #define W while
    #define gc getchar()
    #define MX 2000500
    #define ll long long
    bool neg;
    template <class T>
    IN void in(T &x)
    {
    	x = 0; R char c = gc;
    	for (; !isdigit(c); c = gc)
    	if(c == '-') neg = true;
    	for (;  isdigit(c); c = gc)
    	x = (x << 1) + (x << 3) + c - 48;
    	if(neg) neg = false, x = -x;
    }
    int q, seg, kth, tar; struct Node {int siz, mn, mx, tag;} tree[MX << 2];
    struct opt {int h, lef, rig;} req[100005];
    IN bool operator < (const opt &x, const opt &y) {return x.h > y.h;}
    namespace SGT
    {
    	#define ls (now << 1)
    	#define rs (now << 1 | 1)
    	IN void pushup(R int now)
    	{
    		tree[now].mn = std::min(tree[ls].mn, tree[rs].mn);
    		tree[now].mx = std::max(tree[ls].mx, tree[rs].mx);
    		tree[now].siz = tree[ls].siz + tree[rs].siz;
    	}
    	IN void pushdown(R int now)
    	{
    		if(tree[now].tag)
    		{
    			if(ls) tree[ls].mn += tree[now].tag, tree[ls].mx += tree[now].tag, tree[ls].tag += tree[now].tag;
    			if(rs) tree[rs].mn += tree[now].tag, tree[rs].mx += tree[now].tag, tree[rs].tag += tree[now].tag;
    			tree[now].tag = 0;
    		}
    	}
    	void build(R int now, R int lef, R int rig)
    	{
    		if(lef == rig) return tree[now].siz = 1, void();
    		int mid = lef + rig >> 1;
    		build(ls, lef, mid), build(rs, mid + 1, rig);
    		pushup(now);
    	}
    	int query(R int now, R int lef, R int rig, R int lb, R int rb)
    	{
    		if(lef > rig) return 0;
    		if(tree[now].mn >= kth) return 0;
    		if(lef >= lb && rig <= rb)
    		{
    			if(tree[now].mx < tar) {tree[now].tag += 1, tree[now].mx++, tree[now].mn++; return 0;}
    			if(tree[now].mn == tar) {int ret = tree[now].siz; tree[now].siz = 0; tree[now].mx = tree[now].mn = kth; return ret;}
    			int ret = 0, mid = lef + rig >> 1;
    			pushdown(now);
    			if(ls) ret += query(ls, lef, mid, lb, rb); if(rs) ret += query(rs, mid + 1, rig, lb, rb);
    			pushup(now); return ret;
    		}
    		int mid = lef + rig >> 1, ret = 0; pushdown(now);
    		if(lb <= mid) ret += query(ls, lef, mid, lb, rb);
    		if(rb > mid) ret += query(rs, mid + 1, rig, lb, rb);
    		pushup(now); return ret;
    	}
    	#undef ls
    	#undef rs
    }
    ll ans, sum;
    int main(void)
    {
    
    	in(q), in(seg), in(kth); tar = kth - 1;
    	SGT::build(1, 1, seg << 1);
    	for (R int i = 1; i <= q; ++i) in(req[i].h), in(req[i].lef), in(req[i].rig), req[i].lef += 1 + seg, req[i].rig += seg;
    	std::sort(req + 1, req + 1 + q);
    	for (R int i = 1; i <= q; ++i)
    	{
    		sum = 0;
    		if(req[i].rig < req[i].lef)
    		{
    			sum += SGT::query(1, 1, seg << 1, req[i].lef, seg << 1);
    			sum += SGT::query(1, 1, seg << 1, 1, req[i].rig);
    			ans += 1ll * req[i].h * req[i].h * sum;
    		}
    		else
    		{
    			sum += SGT::query(1, 1, seg << 1, req[i].lef, req[i].rig);
    			ans += 1ll * req[i].h * req[i].h * sum;
    		}
    	}
    	printf("%lld", ans);
    }
    
```



---

## 作者：fysbb (赞：11)

这题很多题解都是用扫描线+权值线段树/Splay，在这里提供一个只需普通线段树的解法。


------------
### 1.将扇形转化为线段

题目中将整个圆**分成 $ 2m $ 个小区间**，我们将其从 $ 1 $ 到 $ 2m $ 编号。以便用线段树进行维护。

![](https://i.loli.net/2019/02/12/5c62a2acc70ac.png)

### 2.确定第 $ k $ 大半径

首先将扇形按半径由大到小排序，之后依次覆盖到图上。每次覆盖其实就是一次区间修改，如果一个区间已经被修改了 $ k $ 次，便代表其已被 $ k $ 个扇形覆盖。当前扇形的半径便是第 $ k $ 大半径。

### 3.确定覆盖区间

1. $ a_1 < a_2 $ :

 此情况较为简单， $ a_1+m+1 $ 为区间左端点， $ a_2+m $ 为区间右端点

2. $ a_1 > a_2 $ :

 此时需要修改两个区间，分别是 $ a_1+m+1 $ 到 $ 2m $ ，以及 $ 1 $ 到 $ a_2+m $
 
```cpp
for i:=1 to n do begin
  if a[i].x<=a[i].y then change(1,2*m,1,a[i].x+m+1,a[i].y+m,a[i].r)
    else begin
      change(1,2*m,1,a[i].x+m+1,2*m,a[i].r);
      change(1,2*m,1,1,a[i].y+m,a[i].r);
    end;       
 end;
```

### 4.进行区间修改

修改过程不能像普通的区间加一样，因为其懒标记若没在准确的时间下放，会造成答案偏小。

如图，当 $ k=2 $ ，此时已有 $ DE $ 区间被覆盖 $ 2 $ 次，但由于线段树懒标记未下放，就无法统计答案。

![](https://i.loli.net/2019/02/12/5c62a5c633ea1.png)

所以，我们需要找到方法来判断懒标记下放时间。

```cpp
   tree,tree_max,p,q:array[0..8000005]of int64;
   tf:array[0..8000005]of boolean;
```

$ tree[i] $ 统计覆盖次数的线段树

$ treemax[i] $ 记录当前区间内，最多处有多少个扇形覆盖

$ p[i] $ 懒标记

$ q[i] $ 当前区间内，已有多少个小区间统计过答案

$ tf[i] $ 当前区间是否全部小区间都统计过答案

在处理过程中，每当区间 $ t $ 被完全覆盖，若区间 $ t $ 未处理，就将 $ tree[t] \ ,\  treemax[t] \ ,\  p[t] $ 加 $ 1 $ ，如果 $ tree[t]>=k $ ,就统计答案，并将 $ tf[t] $ 标记为已处理。若区间 $ t $ 已处理，则直接返回。当区间$ t $ 未被完全覆盖，而 $ treemax[t]+p[t]>=k $ ,就将懒标记下放。

```cpp
procedure change(l,r,t,x,y,o:longint);     //o为半径
var mid:longint;
begin
  if tf[t]=true then exit;
  if q[t]=r-l+1 then begin     //此区间所有小区间皆处理过，相当于此区间处理过
    tf[t]:=true;
    exit;
  end;
  if (x<=l) and (y>=r) then begin
    inc(tree[t]);
    inc(tree_max[t]);
    inc(p[t]);
    if tree[t]>=k then begin
      tf[t]:=true;
      inc(ans,o*o*(r-l+1-q[t]));   //计算答案
      q[t]:=r-l+1;
      tree_max[t]:=0;
      exit;
    end;
    if tree_max[t]+p[t]>=k then down(l,r,t,o);
    exit;
  end;
  mid:=(l+r) shr 1;
  down(l,r,t,o);
  if x<=mid then change(l,mid,t shl 1,x,y,o);
  if y>=mid+1 then change(mid+1,r,t shl 1 + 1,x,y,o);
  q[t]:=q[t shl 1]+q[t shl 1 + 1];
  tree_max[t]:=max(tree_max[t],max(tree_max[t shl 1],tree_max[t shl 1 + 1]));
end;
```

但不同于一般线段树，懒标记不是下放一层，而是直接下放到叶节点，并且在期间也要统计答案。（详见程序）

```cpp
procedure down(l,r,t,o:longint);
var mid:longint;
begin
  if tf[t]=true then exit;
  if q[t]=r-l+1 then begin
    tf[t]:=true;
    exit;
  end;
  if tree[t]>=k then begin
    tf[t]:=true;
    inc(ans,o*o*(r-l+1-q[t]));
    q[t]:=r-l+1;
    tree_max[t]:=0;
    exit;
  end;
  if l=r then exit;
  if p[t]<>0 then begin
    mid:=(l+r) shr 1;
    inc(tree[t shl 1],p[t]);
    inc(tree[t shl 1 + 1],p[t]);
    inc(tree_max[t shl 1],p[t]);
    inc(tree_max[t shl 1 + 1],p[t]);
    inc(p[t shl 1],p[t]);
    inc(p[t shl 1 + 1],p[t]);
    p[t]:=0;
    if tree_max[t shl 1]+p[t]>=k then down(l,mid,t shl 1,o);
    if tree_max[t shl 1 + 1]+p[t]>=k then down(mid+1,r,t shl 1 + 1,o);
    q[t]:=q[t shl 1]+q[t shl 1 + 1];
  end;
end;
```

### 5.完整程序

```cpp
program project1;
type tp=record
  x,y,r:int64;
end;

var
   tree,tree_max,p,q:array[0..8000005]of int64;
   tf:array[0..8000005]of boolean;
   a:array[0..100005]of tp;
   n,m,k,ans:int64;

function max(a,b:int64):int64;
begin
  if a>b then exit(a) else exit(b);
end;

procedure re;
var i:longint;
begin
  for i:=1 to n do read(a[i].r,a[i].x,a[i].y);
end;

procedure qsort(l,r:longint);
var i,j:longint;
    mid:int64;
    t:tp;
begin
  i:=l;
  j:=r;
  mid:=a[(i+j) shr 1].r;
  repeat
    while a[i].r>mid do inc(i);
    while a[j].r<mid do dec(j);
    if i<=j then begin
      t:=a[i];
      a[i]:=a[j];
      a[j]:=t;
      inc(i);
      dec(j);
    end;
  until i>j;
  if i<r then qsort(i,r);
  if l<j then qsort(l,j);
end;

procedure down(l,r,t,o:longint);
var mid:longint;
begin
  if tf[t]=true then exit;
  if q[t]=r-l+1 then begin
    tf[t]:=true;
    exit;
  end;
  if tree[t]>=k then begin
    tf[t]:=true;
    inc(ans,o*o*(r-l+1-q[t]));
    q[t]:=r-l+1;
    tree_max[t]:=0;
    exit;
  end;
  if l=r then exit;
  if p[t]<>0 then begin
    mid:=(l+r) shr 1;
    inc(tree[t shl 1],p[t]);
    inc(tree[t shl 1 + 1],p[t]);
    inc(tree_max[t shl 1],p[t]);
    inc(tree_max[t shl 1 + 1],p[t]);
    inc(p[t shl 1],p[t]);
    inc(p[t shl 1 + 1],p[t]);
    p[t]:=0;
    if tree_max[t shl 1]+p[t]>=k then down(l,mid,t shl 1,o);
    if tree_max[t shl 1 + 1]+p[t]>=k then down(mid+1,r,t shl 1 + 1,o);
    q[t]:=q[t shl 1]+q[t shl 1 + 1];
  end;
end;

procedure change(l,r,t,x,y,o:longint);
var mid:longint;
begin
  if tf[t]=true then exit;
  if q[t]=r-l+1 then begin
    tf[t]:=true;
    exit;
  end;
  if (x<=l) and (y>=r) then begin
    inc(tree[t]);
    inc(tree_max[t]);
    inc(p[t]);
    if tree[t]>=k then begin
      tf[t]:=true;
      inc(ans,o*o*(r-l+1-q[t]));
      q[t]:=r-l+1;
      tree_max[t]:=0;
      exit;
    end;
    if tree_max[t]+p[t]>=k then down(l,r,t,o);
    exit;
  end;
  mid:=(l+r) shr 1;
  down(l,r,t,o);
  if x<=mid then change(l,mid,t shl 1,x,y,o);
  if y>=mid+1 then change(mid+1,r,t shl 1 + 1,x,y,o);
  q[t]:=q[t shl 1]+q[t shl 1 + 1];
  tree_max[t]:=max(tree_max[t],max(tree_max[t shl 1],tree_max[t shl 1 + 1]));
end;

procedure main;
var i:longint;
begin
  for i:=1 to n do begin
    if a[i].x<=a[i].y then change(1,2*m,1,a[i].x+m+1,a[i].y+m,a[i].r)
      else begin
        change(1,2*m,1,a[i].x+m+1,2*m,a[i].r);
        change(1,2*m,1,1,a[i].y+m,a[i].r);
      end;      
  end;
  writeln(ans);
end;

begin
  read(n,m,k);
  re;
  qsort(1,n);
  main;
end.

```

---

## 作者：Imakf (赞：8)

别看题目说的玄乎，其实是个序列问题

要求维护 $2m$ 个集合(multiset)，执行两个操作：

- 对区间 $[l,r]$ 每个集合中插入某个数

- 设集合有 $n$ 个数，求集合 $n-k+1$ 大

----

那么显然这个东西就是可以用splay做啦！

维护一个大的splay

把每个区间$[l,r]$插入数字拆成两个操作：

1.在 $l$ 插入

2.在 $r+ 1$ 删除

注意特判 $l>r$ 的情况QAQ，要拆成 $4$ 个操作

然后对所有操作排序

序列从左往右扫一遍，同时在对应位置执行插入和删除操作

每次都要统计答案（查 $n-k+1$ 大），注意特判数的数量比 $n-k+1$ 还少的情况，此时贡献为 0

splay写了垃圾回收有点丑

速度还行，但是比不过权值线段树


```cpp
#include<cstdio>
#include<cstring>
#include<ctime>
#include<cstdlib>
#include<set>
#include<queue>
#include<algorithm>
#include<cassert>

#define rg register
#define il inline
#define MX (200000 + 50)
#define ll long long
#define mod (210000)
#define INF (21474836)
//#define debug

int read(){
	rg char k = getchar();
	int x = 0 ,flag = 1;
	while(k < '0' || k > '9'){
		if(k == '-')	flag = -1;
		k = getchar();
	}
	while(k >= '0' && k <= '9'){
		x = x * 10 + k - '0';
		k = getchar();
	}
	return x * flag;
}

int n ,m ,k;
namespace SPLAY{
	#define lch(x) ch[x][0]
	#define rch(x) ch[x][1]
	int root;
	int trash[MX * 2] ,top = 0 ,in[mod + 5];
	int ch[mod][2] ,fa[mod] ,size[mod] ,key[mod];
	int cnt[mod];
	int get(int x){return x == ch[fa[x]][1];}
	int Nroot(int x){return get(x) || x == ch[fa[x]][0];}
	il void pushup(int x){
		size[x] = cnt[x];
		if(lch(x))	size[x] += size[lch(x)];
		if(rch(x))	size[x] += size[rch(x)];
	}
	il void rotate(int x){
		int f = fa[x] ,gf = fa[f] ,which = get(x) ,W = ch[x][!which];
		if(gf)	ch[gf][ch[gf][1] == f] = x;
		ch[x][!which] = f;
		ch[f][which] = W;
		if(W)	fa[W] = f;
		fa[f] = x ,fa[x] = gf;
		pushup(f);
		pushup(x);
	}
	void splay(int x ,int goal = 0){
		int f;
		while((f = fa[x]) != goal){
			if(fa[f] != goal)	rotate(get(x) == get(f) ? f : x);
			rotate(x);
		}if(!goal)	root = x;
		pushup(x);
	}
	void insert(int val){
		#ifdef debug
			printf("insert %d\n" ,val);
		#endif
		int now = root ,f = 0;
		while(now && key[now] != val){
			f = now;
			now = ch[now][val > key[now]];
		}
		if(now){
			++cnt[now];
			pushup(now);
			pushup(f);
			return splay(now);
		}
		now = trash[top--];
		size[now] = cnt[now] = 1;
		ch[now][0] = ch[now][1] = 0;
		key[now] = val ,fa[now] = f;
		if(f)	ch[f][val > key[f]] = now ,pushup(f);
		splay(now);
	}
	int Kth(int rank){
		int now = root;
		if(rank <= 1)	return 0;
		while(now){
			if(lch(now) && size[lch(now)] >= rank)	now = lch(now);
			else{
				int tmp = cnt[now] + (lch(now) ? size[lch(now)] : 0);
				rank -= tmp;
				if(rank <= 0)	return now;
				now = rch(now);
			}
		}
	}
	int find(int val){
		int now = root;
		while(key[now] != val){
			if(key[now] > val)	now = lch(now);
			else	now = rch(now);
		}
		return now;
	}
	int pre(int x){
		x = lch(x);
		while(rch(x))	x = rch(x);
		return x;
	}
	int nxt(int x){
		x = rch(x);
		while(lch(x))	x = lch(x);
		return x;
	}
	void del(int val){
		#ifdef debug
			printf("delete %d\n" ,val);
		#endif
		int aim = find(val);
		splay(aim);
		int PRE = pre(aim) ,NXT = nxt(aim);
		splay(PRE ,0);
		splay(NXT ,PRE);
		if(cnt[aim] > 1){
			--cnt[aim];
			pushup(aim);
			pushup(NXT);
			pushup(PRE);
			splay(aim);
		}
		else{
			trash[++top] = aim;	// 垃圾回收，交易自由
			ch[NXT][0] = fa[aim] = 0;
			size[aim] = cnt[aim] = 0;
			pushup(NXT);
			pushup(PRE);
		}
	}
}using namespace SPLAY;

struct opt{
	int type ,pos ,val;
	bool operator <(const opt &B)const{
		return pos < B.pos;
	}
}op[MX * 2];

ll Ans ,ccnntt = 1;
int main(){
	n = read(); m = read(); k = read();
	for(int i = 1 ,r ,s ,t ; i <= n ; ++i){
		r = read(); s = read() + m + 1 ; t = read() + m + 1;
		#ifdef debug
		//	printf("%d %d %d\n" ,r ,s ,t);
		#endif
		//  assert(r != 34448);
		if((s == 2 * m + 1 && t == 1))	continue;
		if(s < t){
			op[ccnntt * 2 - 1] = (opt){1 ,s ,r};
			op[ccnntt * 2] = (opt){0 ,t ,r};
			++ccnntt;
		}
		else{
			if(t != 1){
				op[ccnntt * 2 - 1] = (opt){1 ,1 ,r};
				op[ccnntt * 2] = (opt){0 ,t ,r};
				++ccnntt;
			}
			op[ccnntt * 2 - 1] = (opt){1 ,s ,r};
			op[ccnntt * 2] = (opt){0 ,m * 2 + 1 ,r};
			++ccnntt;
		}
	}
	--ccnntt;
	for(rg int i = 1 ; i <= 209000 ; ++i){
		trash[++top] = 209000 - i + 1;
	}
	insert(-INF);
	insert(INF);
	op[ccnntt * 2 + 1] = (opt){1111 ,m + m + 1 ,0};
	int l = 1;
	std::sort(op + 1 ,op + ccnntt * 2 + 1);
	ll tmp = 0 ,change;
	for(rg int i = 1 ; i <= m * 2 ; ++i){
		change = false;	// 常熟优化
		while(op[l].pos <= i){
			change = true;
			if(op[l].type == 1)	insert(op[l++].val);
			else	del(op[l++].val);
		}
		if(change)	tmp = key[Kth(size[root] - k)];
		Ans += tmp * tmp;
	}
	printf("%lld\n" ,Ans);
	return 0;
}
```

---

## 作者：Owen_codeisking (赞：4)

当时教练说给我们 $noip$ 信心赛，结果找到了这题，当时考场上手敲 $splay$，$splay$ 没敲挂，但是没想到 $l>r$ 的情况，$GG$。

赛后我写了好几种方法，但是现在才找到原题。

我们可以通过某些方式可得每次就是求目前覆盖的第 $k$ 大。

把原来的覆盖差分一下，若 $l\leq r$ 就在 $l$ 位置 $+1$，$r+1$ 位置 $-1$。否则在 $1$ 位置 $+1$，$l+1$ 位置 $-1$，$r$ 的位置 $+1$。

操作就是插入，删除，找第 $k$ 大，我这里介绍三种方法

1、$O(n\log^2 n)$ 树状数组+二分，常数巨小

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=1000000+10;
int n,m,k,R[maxn],c[maxn];ll ans;
vector<int> in[maxn<<1],out[maxn<<1];

inline int read(){
    register int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return (f==1)?x:-x;
}

int lowbit(int x){return x & -x;}
void add(int x,int y){
    for(;x<maxn;x+=lowbit(x)) 
        c[x]+=y;
}
int sum(int x){
    int ans=0;
    for(;x;x-=lowbit(x)) 
        ans+=c[x];
    return ans;
}
int findkth(int k){
    int l=1,r=1000000,mid;
    while(l<r){
        mid=l+r>>1;
        if(sum(mid)<k) l=mid+1;
        else r=mid;
    }
    return l;
}

signed main()
{
    m=read(),n=read(),k=read();
    int l,r;
    for(int i=1;i<=m;i++){
    	R[i]=read(),l=read(),r=read();
    	if(l<r){
    		l+=n+1;r+=n;
        	in[l].push_back(i);
            out[r+1].push_back(i);	
        }
    	else {
    		swap(l,r);
    		l+=n;r+=n+1;
    		in[1].push_back(i);
    		out[l+1].push_back(i);
    		in[r].push_back(i);
        }
    }
    int now=0,x;
    for(int i=1;i<=2*n;i++){
        for(int j=0;j<in[i].size();j++)
            add(R[in[i][j]],1);
        for(int j=0;j<out[i].size();j++)
            add(R[out[i][j]],-1);
        now+=in[i].size()-out[i].size();
        if(now>=k){
            x=findkth(now-k+1);
            ans+=(ll)x*x;
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```

2、$O(n\log n)$ $fhq\ treap$ 常数适中

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=1000000+10;
int ch[maxn][2],key[maxn],siz[maxn],val[maxn];
int m,n,k,R[maxn],rt,sz,seed=233;ll ans;
vector<int> in[maxn<<1],out[maxn<<1];

inline int read(){
    register int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return (f==1)?x:-x;
}

int Rand(){
    return seed=(int)(1561112ll*seed%2147483647);
}
int newnode(int v){
    key[++sz]=Rand();
    val[sz]=v;
    siz[sz]=1;
    ch[sz][0]=ch[sz][1]=0;
    return sz;
}

void update(int x){
    siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+1;
}

void split(int x,int &a,int &b,int v){
    if(x==0){
        a=b=0;
        return ;
    }
    if(val[x]<=v) a=x,split(ch[x][1],ch[a][1],b,v);
    else b=x,split(ch[x][0],a,ch[b][0],v);
    update(x);
}

void merge(int &x,int a,int b){
    if(a==0||b==0){
        x=a+b;
        return ;
    }
    if(key[a]<key[b]) x=a,merge(ch[x][1],ch[a][1],b);
    else x=b,merge(ch[x][0],a,ch[b][0]);
    update(x);
}

void insert(int v){
    int x=0,y=0,z=newnode(v);
    split(rt,x,y,v);
    merge(x,x,z);
    merge(rt,x,y);
}

void del(int v){
    int x=0,y=0,z=0;
    split(rt,x,y,v);
    split(x,x,z,v-1);
    merge(z,ch[z][0],ch[z][1]);
    merge(x,x,z);
    merge(rt,x,y);
}

int getkth(int x,int k){
    while(siz[ch[x][0]]+1!=k){
        if(siz[ch[x][0]]>=k) x=ch[x][0];
        else k-=siz[ch[x][0]]+1,x=ch[x][1];
    }
    return val[x];
}

int main()
{
    m=read(),n=read(),k=read();
    int l,r;
    for(int i=1;i<=m;i++){
        R[i]=read(),l=read(),r=read();
        if(l<r){
            l+=n+1;r+=n;
            in[l].push_back(i);
            out[r+1].push_back(i);
        }
        else {
            swap(l,r);
            l+=n;r+=n+1;
            in[1].push_back(i);
            out[l+1].push_back(i);
            in[r].push_back(i);
        }
    }
    int now=0,x;
    for(int i=1;i<=2*n;i++){
        for(int j=0;j<in[i].size();j++)
            insert(R[in[i][j]]);
        for(int j=0;j<out[i].size();j++)
            del(R[out[i][j]]);
        now+=in[i].size()-out[i].size();
        if(now>=k){
            x=getkth(rt,now-k+1);
            ans+=(ll)x*x;
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```

3、$O(n\log n)$ $splay$ 常数巨大（考场敲的）

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=1000000+10;
int n,m,k,R[maxn];ll ans;
int ch[maxn][2],fa[maxn],siz[maxn],cnt[maxn],key[maxn];
int sz,rt;
vector<int> in[maxn<<1],out[maxn<<1];

inline int read(){
    register int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return (f==1)?x:-x;
}
inline void clear(int x){
    ch[x][0]=ch[x][1]=fa[x]=siz[x]=cnt[x]=key[x]=0;
}
inline bool get(int x){
    return ch[fa[x]][1]==x;
}
inline void update(int x){
    if(x){
        siz[x]=cnt[x];
        if(ch[x][0]) siz[x]+=siz[ch[x][0]];
        if(ch[x][1]) siz[x]+=siz[ch[x][1]];
    }
}
inline void rotate(int x){
    int y=fa[x],z=fa[y],k=get(x);
    ch[y][k]=ch[x][k^1];fa[ch[y][k]]=y;
    ch[x][k^1]=y;fa[y]=x;fa[x]=z;
    if(z) ch[z][ch[z][1]==y]=x;
    update(y);update(x);
}
inline void splay(int x){
    for(int y;y=fa[x];rotate(x))
        if(fa[y])
            rotate((get(x)==get(y))?y:x);
    rt=x;
}
inline void insert(int val){
    if(rt==0){sz++;ch[sz][0]=ch[sz][1]=fa[sz]=0;rt=sz;siz[sz]=cnt[sz]=1;key[sz]=val;return;}
    int x=rt,y=0;
    while(1){
        if(val==key[x]){cnt[x]++;update(x);update(y);splay(x);return;}
        y=x;x=ch[x][key[x]<val];
        if(x==0){
            sz++;fa[sz]=y;
            ch[y][key[y]<val]=sz;
            ch[sz][0]=ch[sz][1]=0;
            siz[sz]=cnt[sz]=1;
            key[sz]=val;
            update(y);
            splay(sz);
            return;
        }
    }
}
inline int find(int val){
    int x=rt,ans=0;
    while(1){
        if(val<key[x]) x=ch[x][0];
        else {
            ans+=(ch[x][0]?siz[ch[x][0]]:0);
            if(val==key[x]){
                splay(x);return ans+1;
            }
            ans+=cnt[x];
            x=ch[x][1];
        }
    }
}
inline int findkth(int val){
    int x=rt,k;
    while(1){
        if(ch[x][0]&&val<=siz[ch[x][0]]) 
            x=ch[x][0];
        else {
            k=(ch[x][0]?siz[ch[x][0]]:0)+cnt[x];
            if(val<=k) return key[x];
            val-=k;x=ch[x][1];
        }
    }
}
inline int pre(){
    int x=ch[rt][0];
    while(ch[x][1]) x=ch[x][1];
    return x;
}
inline void del(int val){
    find(val);int x=rt;
    if(cnt[rt]>1){cnt[rt]--;update(rt);return;}
    if(!ch[rt][0]&&!ch[rt][1]){clear(rt);rt=0;return;}
    if(!ch[rt][0]){rt=ch[x][1];fa[rt]=0;clear(x);return;}
    else if(!ch[rt][1]){rt=ch[x][0];fa[rt]=0;clear(x);return;}
    splay(pre());
    ch[rt][1]=ch[x][1];
    fa[ch[x][1]]=rt;
    clear(x);update(rt);
}

int main()
{
    m=read(),n=read(),k=read();
    int l,r;
    for(int i=1;i<=m;i++){
    	R[i]=read(),l=read(),r=read();
    	if(l<r){
    		l+=n+1;r+=n;
        	in[l].push_back(i);
            out[r+1].push_back(i);	
        }
    	else {
    		swap(l,r);
    		l+=n;r+=n+1;
    		in[1].push_back(i);
    		out[l+1].push_back(i);
    		in[r].push_back(i);
        }
    }
    int now=0,x;
    for(int i=1;i<=2*n;i++){
        for(int j=0;j<in[i].size();j++)
            insert(R[in[i][j]]);
        for(int j=0;j<out[i].size();j++)
            del(R[out[i][j]]);
        now+=in[i].size()-out[i].size();
        if(now>=k){
            x=findkth(now-k+1);
            ans+=(ll)x*x;
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Ybll_ (赞：3)

![](https://cdn.luogu.com.cn/upload/image_hosting/njhgecao.png)

**卡常过了！！！**

# 思路：

有点类似差分哈。

首先我们先把这一个被平均分成 $2m$ 份扇形的圆转换成 $2m$ 棵线段树，但是，**空间**肯定**会超**，

所以我们可以每一份**单独处理**。

先准备一个长度为 $2m$，类型为 `pair<int,int>` 的**二维**动态数组 $v$，先让扇形的起始位置 $a$ 和结束位置 $b$ 加 $m$ 使它们非负，然后再像下面这样：

```cpp
		v[a+m].push_back({r,1});
		v[b+m].push_back({r,-1});
```

第一行表示从 $a+m$ 的位置开始放入一个半径为 $r$ 的扇形，同时他可以造成价值为 $1$ 的厚度贡献；

第二行表示在 $b+m$ 的位置撤销 $a+m$ 处放入的半径为 $r$ 的扇形的厚度贡献；

但是由于输入的特殊性，可能会出现 $a>b$ 的情况，此时只需在 $0$ 的位置放入一个半径为 $r$ 的扇形即可。

然后我们遍历这 $2m$ 份扇形，对于第 $i$ 个扇形 $v_i$ 中的第 $j$ 个元素的半径 `v[i][j].first` 和贡献 `v[i][j].second`，

我们使用**线段树**进行区间加的操作，加的范围就是 `[1,v[i][j].first]`，加的贡献就是 `v[i][j].second`。

然后对于这份扇形，我们去二分找出最后一个大于等于 $k$ 的位置，设这个位置为 $R$，

那这份扇形的面积的贡献就为：
$\frac{πR^2}{2m}$。

由于最后要乘上 $\frac{2m}{π}$，化简后即为 $R^2$。

接着，就有以下代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define up(id) tree[id].sum=tree[id*2].sum+tree[id*2+1].sum
using namespace std;
struct node
{
	int l,r,sum,lazy;
}tree[8000005];
int n,m,k,ans;
vector<pair<int,int>>v[2000005];
void build(int id,int l,int r)
{
	tree[id].l=l;
	tree[id].r=r;
	if(l==r)return;
	int mid=l+r>>1;
	build(id*2,l,mid);
	build(id*2+1,mid+1,r);
}
void down(int id)
{
	tree[id*2].sum+=(tree[id*2].r-tree[id*2].l+1)*tree[id].lazy;
	tree[id*2+1].sum+=(tree[id*2+1].r-tree[id*2+1].l+1)*tree[id].lazy;
	tree[id*2].lazy+=tree[id].lazy;
	tree[id*2+1].lazy+=tree[id].lazy;
	tree[id].lazy=0;
}
void update(int id,int l,int r,int sum)
{
	if(tree[id].l>r||tree[id].r<l)return;
	if(tree[id].l>=l&&tree[id].r<=r)
	{
		tree[id].lazy+=sum;
		tree[id].sum+=(tree[id].r-tree[id].l+1)*sum;
		return;
	}
	down(id);
	update(id*2,l,r,sum);
	update(id*2+1,l,r,sum);
	up(id);
}
int query(int id,int l,int r)
{
	if(tree[id].l>r||tree[id].r<l)return 0;
	if(tree[id].l>=l&&tree[id].r<=r)return tree[id].sum;
	down(id);
	return query(id*2,l,r)+query(id*2+1,l,r);
}
signed main()
{
	cin>>n>>m>>k;
	build(1,1,2*m);
	for(int i=0,r,a,b;i<n;i++)
	{
		cin>>r>>a>>b;
		v[a+m].push_back({r,1});
		v[b+m].push_back({r,-1});
		if(b<a)v[0].push_back({r,1});
	}
	for(int i=0;i<2*m;i++)
	{
		for(auto j:v[i])
		{
			update(1,1,j.first,j.second);
		}
		int l=1,r=100000,mid,res=0;
		while(l<=r)
		{
			mid=l+r>>1;
			if(query(1,mid,mid)>=k)
			{
				l=mid+1;
				res=mid;
			}
			else r=mid-1;
		}
		ans+=res*res;
	}
	cout<<ans;
	return 0;
}
```

但是，你这样写会 TLE 一个点。

为了减少常数，先把一部分 `long long` 类型的数据改为 `int` 类型，再加上**快读快写**，

是的没错，仍然会 TLE，因为**普通线段树常数太大**了。

所以，这边给到一个 **zkw 线段树**，zkw 线段树的**常数、空间**要比普通线段树**少**。

至于 zkw 线段树，请参考[这篇](https://www.luogu.com.cn/article/zyplvygx)文章。

时间复杂度为 $O(m\log_2^2n)$。

# AC 代码：

```cpp
#include<bits/stdc++.h>
#define il inline
#define re register
using namespace std;
il int read()
{
	re int x=0,f=1;
	char c;
	while(!isdigit(c=getchar()))
	{
		if(c=='-')f=-1;
	}
	while(isdigit(c))
	{
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
struct node
{
	int sum,lazy;
}tree[8000005];
int n=read(),m=read(),k=read(),P=1;
long long ans;
vector<pair<int,int>>v[2000005];
il void update(int l,int r,int v)
{
	long long ln=0,rn=0,nn=1;
	for(l=P+l-1,r=P+r+1;l^r^1;l/=2,r/=2,nn*=2)
	{
	    tree[l].sum+=v*ln;
	    tree[r].sum+=v*rn;
	    if(~l&1)
		{
			tree[l^1].lazy+=v;
			tree[l^1].sum+=v*nn;
			ln+=nn;
		}
	    if(r&1)
		{
			tree[r^1].lazy+=v;
			tree[r^1].sum+=v*nn;
			rn+=nn;
		}
	}
	for(;l;l/=2,r/=2)
	{
	    tree[l].sum+=v*ln;
	    tree[r].sum+=v*rn;
	}
}
il long long query(int l,int r)
{
	long long ln=0,rn=0,nn=1,sum=0;
	for(l=P+l-1,r=P+r+1;l^r^1;l/=2,r/=2,nn*=2)
	{
	    if(tree[l].lazy)sum+=tree[l].lazy*ln;
	    if(tree[r].lazy)sum+=tree[r].lazy*rn;
	    if(~l&1)
		{
			sum+=tree[l^1].sum;
			ln+=nn;
		}
	    if(r&1)
		{
			sum+=tree[r^1].sum;
			rn+=nn;
		}
	}
	for(;l;l/=2,r/=2)
	{
	    sum+=tree[l].lazy*ln;
	    sum+=tree[r].lazy*rn;
	}
	return sum;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	for(;P<=100001;P*=2);
	for(int i=0,r,a,b;i<n;i++)
	{
		r=read();
		a=read();
		b=read();
		v[a+m].push_back({r,1});
		v[b+m].push_back({r,-1});
		if(b<a)v[0].push_back({r,1});
	}
	for(int i=0;i<2*m;i++)
	{
		int l=1,r=100000,mid;
		long long res=0;
		for(auto j:v[i])
		{
			update(1,j.first,j.second);
		}
		while(l<=r)
		{
			mid=l+r>>1;
			if(query(mid,mid)>=k)
			{
				l=mid+1;
				res=mid;
			}
			else r=mid-1;
		}
		ans+=res*res;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Gmt丶FFF (赞：2)

UP 23 10 10：感谢 @Java_Herobrine 指出的错误。

理解题意后可以把题目看成一个覆盖线段的问题。

对于点在 $-m$ 上，看成在 $m$ 上。 

对于 $l<r$，不用处理。

对于 $l>r$，将问题看成 $(l,m)$ 和 $(-m+1.r)$ 两个区间。

对于正常处理点的问题，Splay 可以在 $l$ 时加入这个点，$r+1$ 时删除这个点。

但本题为线段覆盖，所以我们可以把线段的下标看为点的下标，但是一个 $(l,r)$ 的区间只能覆盖 $(r-l)$ 的线段数，所以在 $r$ 时就删除这个点即可。

剩下的都是 Splay 板子了，离线排序，插入，删除，在一个点时判断是否树中有超过 $k$ 的节点，如果有，那么搜索第 $k$ 大的数，否则赋为 $0$。

时间复杂度：$O(n\times \log(n))$。

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
const int N=1e5+5;
const int M=1e6+5;
int n,m,k,cnt,root,nl,nr;
struct node2
{
	int name,data;
	bool flag;
}ask[4*N];
int cmp2(node2 fi,node2 se)
{
	if(fi.name==se.name)return fi.flag<se.flag;
	return fi.name<se.name;
}
void clac(int &x,int &y)
{
	nl=0;
	if(x>=y)//注意要加等于，因为如果为区间为 [-m,m] x 会转化为 m，导致样例无法通过。
	{
		nl=x;
		x=-m+1;
	}
}
struct node
{
	int fa,ch[2],siz,cnt,val;
}t[4*N];
inline void newnode(int &x,int fa,int val)
{
	x=++cnt;
	t[x].fa=fa;
	t[x].val=val;
	t[x].cnt=t[x].siz=1;
}
inline void connect(int x,int fa,int son)
{
	t[x].fa=fa;
	t[fa].ch[son]=x;
}
inline bool ident(int x,int fa)
{
	return t[fa].ch[1]==x;
}
inline void pushup(int x)
{
	t[x].siz=t[x].cnt+t[t[x].ch[0]].siz+t[t[x].ch[1]].siz;
}
inline void rotate(int x)
{
	int fa=t[x].fa,ff=t[fa].fa,k=ident(x,fa);
	connect(t[x].ch[k^1],fa,k);
	connect(fa,x,k^1);
	connect(x,ff,ident(fa,ff));
	pushup(fa),pushup(x);
}
void splay(int x,int topp=0)
{
	if(topp==0)root=x;
	while(t[x].fa!=topp)
	{
		int fa=t[x].fa,ff=t[fa].fa;
		if(ff!=topp)ident(x,fa)^ident(fa,ff)?rotate(x):rotate(fa);
		rotate(x);
	}
}
void ins(int val,int &x=root,int fa=0)
{
	if(!x)newnode(x,fa,val),splay(x);
	else if(t[x].val>val)ins(val,t[x].ch[0],x);
	else if(t[x].val<val)ins(val,t[x].ch[1],x);
	else t[x].cnt++,splay(x);
}
void erase(int val,int x=root)
{
	if(t[x].val==val)
	{
		splay(x);
		if(t[x].cnt>=2)t[x].cnt--;
		else if(t[x].ch[1])
		{
			int p=t[x].ch[1];
			while(t[p].ch[0])p=t[p].ch[0];
			splay(p,x);	
			root=p,connect(t[x].ch[0],p,0),t[p].fa=0;
			pushup(p);
		}
		else root=t[x].ch[0],t[t[x].ch[0]].fa=0;
	}
	else if(t[x].val>val)erase(val,t[x].ch[0]);
	else erase(val,t[x].ch[1]);
}
int getrank(int k,int x=root)
{
	if(k<=0)
	{
		splay(x);
		return t[x].val;
	}
	if(k<=t[t[x].ch[0]].siz)return getrank(k,t[x].ch[0]);
	int tmp=k-t[t[x].ch[0]].siz-t[x].cnt;
	if(tmp<=0)
	{
		splay(x);
		return t[x].val;
	}
	return getrank(tmp,t[x].ch[1]);
}
signed main()
{
	//freopen("a.out","r",stdin);
	//freopen("area.out","w",stdout);
	scanf("%lld%lld%lld",&n,&m,&k);
	int cnp=0;
	for(int i=1;i<=n;i++)
	{
		int dat,lc,rc;
		scanf("%lld%lld%lld",&dat,&lc,&rc);
		if(lc==-m)lc=m;
		if(rc==-m)rc=m;
		clac(lc,rc);
		ask[++cnp]=(node2){lc,dat,0};
		ask[++cnp]=(node2){rc,dat,1};
		if(nl)ask[++cnp]=(node2){nl,dat,0};
	}
	sort(ask+1,ask+1+cnp,cmp2);
	int bef=1,num=0,ans=0;
	for(int i=-m+1;i<=m;i++)
	{
		for(;bef<=cnp;bef++)
		{
			if(ask[bef].name!=i)break;
			if(ask[bef].flag==1)num--,erase(ask[bef].data*ask[bef].data);
			else num++,ins(ask[bef].data*ask[bef].data);
		}
		if(num>=k)ans+=getrank(num-k+1);
	}
	printf("%lld",ans);
	return 0;
}
/*
10 100 2
24660 98 32
906 -15 -49
26067 -52 -23
15409 -76 -25
22490 41 65
2600 -10 -7
4310 15 75
20389 -100 -3
4421 8 -40
8664 -70 -95
*/
```


---

## 作者：zhengrunzhe (赞：2)

### 平衡树+扫描线

#### 用平衡树维护kth
一个角度上覆盖k次所能取到的最大半径便是该角度上覆盖的所有半径中的第k大

比如角度2上覆盖着半径为1926,817,666的扇形，则当k=2时，角度2最大能取到817

维护第k大，想到平衡树

#### 扇形转线段

把每个扇形看作2/4条线段，每条线段的长度是它的半径

用三元组(len,pos,tag)表示一条线段，len就是线段的长度也就是它所对应的扇形的半径，pos表示该线段所处的角度,tag=0表示该线段要被插入，tag=1表示要从平衡树中删除一条长度为len的线段

把len当作平衡树的排序原则，把pos作为线段排序的原则，把所有的线段存下来后，按照极坐标角度从小到大排序

#### 负角度转正
那么有负角度，转成正角度更好做，如图所示是当m=8时的极坐标系

![](https://cdn.luogu.com.cn/upload/pic/46377.png)

0同时又可以是2m，一个角度p(p<0)，转成正后便是2m+p，比如p=-3，对应m=8时2*8-3=13

#### 考虑怎么把扇形分解成线段

对于一个以len为半径，从角度l覆盖到r的扇形，题目并没有保证l<r，所以要进行一波分类讨论

**1.l==r** (好像数据没有这种情况)

这种情况便是一个圆，转为(len,0,0)和(len,2m,1)即可，表示一个圆

**2.l<r，且l≠0,r≠0**

##### 1)l>0,r>0

![](https://cdn.luogu.com.cn/upload/pic/46380.png)
直接转为(len,l,0),(len,r,1)即可

##### 2)l>0,r<0

不满足l<r的前提，舍去

##### 3)l<0,r>0

![](https://cdn.luogu.com.cn/upload/pic/46384.png)

此时该扇形会覆盖到角度0，也就是l对应的正数是是一个>m的数，r则<m，直接塞(len,l,0),(len,r,1)则会出现问题，因为扫描线是按极坐标角度从小到大扫的，而这样塞l会被排在r后面

所以考虑以0角度为基准，把该扇形分割为[0,l],[0,r]两部分

对于0到l的这一块，分解为(len,2m+l,0),(len,2m,1)

对于0到r的这一块，分解为(len,0,0),(len,r,1)

##### 4)l<0,r<0

![](https://cdn.luogu.com.cn/upload/pic/46385.png)

l,r同为负，转成2m+l,2m+r即可

转为(len,2m+l,0),(len,2m+r,1)

**3.l>r**

##### 1)l>0,r>0

![](https://cdn.luogu.com.cn/upload/pic/46386.png)

同样分割成两部分，转为(len,l,0),(len,2m,1),(len,0,0),(len,r,1)

##### 2)l>0,r<0

![](https://cdn.luogu.com.cn/upload/pic/46387.png)

r转正变成2m+r，转为(len,l,0),(len,2m+r,1)

##### 3)l<0,r>0

不满足l>r的前提，舍去

##### 4)l<0,r<0

![](https://cdn.luogu.com.cn/upload/pic/46388.png)

同理分解为(len,2m+l,0),(len,2m,1),(len,0,0),(len,2m+r,1)

**4.l==0,r≠0** (由于可能有0的存在导致在2.3.的时候懒得去想什么地方写>=0什么地方写>0，所以干脆把有0的列出来好了)

##### 1)r<0   (len,0,0),(len,2m+r,1)

##### 2)r>0   (len,0,0),(len,r,1)

**5.l≠0,r==0**

##### 1)l<0   (len,2m+l,0),(len,2m,1)

##### 2)l>0   (len,l,0),(len,2m,1)

#### 如何扫描线

扇形分解成线段了之后，按照pos为关键字sort一下，从小到大遍历一遍

一个半径为r，圆心角为α的扇形的扇形对答案的贡献为**α*r²**

循环中一开始先累计答案：**ans+=(当前平衡树中第k大长度)²*(s[i].pos-s[i-1].pos)**，表示前一个位置到当前位置的区域的面积

然后看当前线段的标记tag

tag为0时往平衡树中插入线段长len

tag为1时在平衡树中删去一个len

#### 代码：指针Splay(记得处理好long long)

```cpp
#include<cstdio>
#include<algorithm>
using std::sort;
template<class type>inline void read(type &in)
{
    in=0;char ch=getchar();short fh=1;
    while (ch<48||ch>57)fh=ch=='-'?-1:fh,ch=getchar();
    while (ch>47&&ch<58)in=(in<<3)+(in<<1)+ch-48,ch=getchar();
    in*=fh;
}
typedef long long ll;
const int N=1e5+10;
class Splay
{
	private:
		struct tree
		{
			int size,value,cnt;
			tree *son[2],*fa;
			inline const void pushup()
			{
				size=son[0]->size+cnt+son[1]->size;
			}
			inline const bool identity()
			{
				return fa->son[1]==this;
			}
		}*null,*root,memory_pool[N<<2],*tail,*rec[N<<2];
		int top;
		inline const void init()
		{
			tail=memory_pool;
			null=tail++;
			null->size=null->cnt=null->value=0;
			null->son[0]=null->son[1]=null->fa=null;
			root=null;
		}
		inline tree *spawn(int key)
		{
			tree *p=top?rec[--top]:tail++;
			p->value=key;
			p->size=p->cnt=1;
			p->fa=p->son[0]=p->son[1]=null;
			return p;
		}
		inline const void erase(tree *&p)
		{
			rec[top++]=p;p=null;
		}
		inline const void connect(tree *p,tree *fa,bool which)
		{
			if (p!=null)p->fa=fa;
			if (fa!=null)fa->son[which]=p,fa->pushup();
		}
	protected:
		inline const void rotate(tree *p)
		{
			tree *fa=p->fa;
			bool id=p->identity();
			connect(p,fa->fa,fa->identity());
			connect(p->son[id^1],fa,id);
			connect(fa,p,id^1);
		}
		inline const void splay(tree *p)
		{
			for (tree *fa;(fa=p->fa)!=null;rotate(p))
				if (fa->fa!=null)
					rotate(p->identity()^fa->identity()?p:fa);
			root=p;
		}
		inline const void find(int key)
		{
			tree *now=root;
			while (now->son[key<now->value]!=null&&now->value!=key)
				now=now->son[key<now->value];
			splay(now);
		}
		inline tree *precursor(tree *p)
		{
			splay(p);
			tree *now=p->son[0];
			while (now->son[1]!=null)now=now->son[1];
			return now;
		}
	public:
		inline Splay(){init();}
		inline const void insert(int key)
		{
			if (root==null)return (void)(root=spawn(key));
			tree *now=root;
			while (1)
			{
				if (now->value==key)
					return now->cnt++,now->pushup(),splay(now);
				tree *fa=now;
				bool which=key<fa->value;
				now=fa->son[which];
				if (now==null)
					return now=spawn(key),connect(now,fa,which),splay(now);
			}
		}
		inline const void Delete(int key)
		{
			find(key);tree *p=root;
			if (p->cnt>1)return p->cnt--,p->pushup();
			if (p->son[0]==null&&p->son[1]==null)return root=null,erase(p);
			if (p->son[0]==null)return (root=p->son[1])->fa=null,erase(p);
			if (p->son[1]==null)return (root=p->son[0])->fa=null,erase(p);
			tree *pre=precursor(p);splay(pre);connect(p->son[1],pre,1);erase(p);
		}
		inline const int findrank(int k)
		{
			tree *now=root;
			while (1)
				if (k<=now->son[0]->size)now=now->son[0];
				else 
					if ((k-=now->son[0]->size+now->cnt)<=0)
						return now->value;
					else now=now->son[1];
		}
		inline const int size()
		{
			return root->size;
		}
}S;
int n,m,k,cnt;
ll ans;
struct segment
{
	int len,pos;bool tag;
	inline const bool operator<(const segment &p)const
	{
		return pos<p.pos;
	}
}s[N<<2];
inline const void addseg(int len,int pos,bool tag)
{
	s[++cnt].len=len;s[cnt].pos=pos;s[cnt].tag=tag;
}
inline const ll square(int x)
{
	return (ll)((ll)(x)*(ll)(x));
}
int main()
{
	read(n);read(m);read(k);
	for (int len,l,r,i=1;i<=n;i++)
		if (read(len),read(l),read(r),l==r)
			addseg(len,0,0),addseg(len,2*m,1);
		else
			if (!l||!r)
				if (!l)addseg(len,0,0),addseg(len,r<0?r+2*m:r,1);
				else addseg(len,l>0?l:2*m+l,0),addseg(len,2*m,1);
			else
				if (l<r)
				{
					if (l<0&&r>0)addseg(len,0,0),addseg(len,r,1),addseg(len,2*m+l,0),addseg(len,2*m,1);
					if (l>0&&r>0)addseg(len,l,0),addseg(len,r,1);	
					if (l<0&&r<0)addseg(len,2*m+l,0),addseg(len,2*m+r,1);
				}			
				else
				{
					if (l<0&&r<0)addseg(len,2*m+l,0),addseg(len,2*m,1),addseg(len,0,0),addseg(len,2*m+r,1);
					if (l>0&&r<0)addseg(len,l,0),addseg(len,2*m+r,1);
					if (l>0&&r>0)addseg(len,l,0),addseg(len,2*m,1),addseg(len,0,0),addseg(len,r,1);
				}
	sort(s+1,s+cnt+1);
	for (int i=1;i<=cnt;i++)
	{
		if (S.size()>=k)ans+=square(S.findrank(k))*(s[i].pos-s[i-1].pos);
		if (!s[i].tag)S.insert(s[i].len);
		else S.Delete(s[i].len);
	}
	if (S.size()>=k)ans+=square(S.findrank(k))*(s[cnt].pos-s[cnt-1].pos);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：lzyqwq (赞：2)

秒了。

[P3997 [SHOI2013] 扇形面积并](https://www.luogu.com.cn/problem/P3997)

> - 给出 $n$ 个形如由始边 $\dfrac{a_1\pi}{m}$ **逆时针旋转至** 终边 $\dfrac{a_2\pi}{m}$ 且半径为 $r$ 的扇形，求至少被 $k$ 个扇形覆盖的面积。
> - $n\le 10^5$，$m\le 10^6$。

想象将平面以 $0,\dots,\dfrac{2m-1}{2m}\pi$ 的弧度的直线半径为 $1,\dots,|V|$ 的圆划分称 $2m|V|$ 块，则扇形覆盖的面积可以拆分成若干块。

而且这些块的弧度构成了一个区间，半径构成了一段前缀。

把弧度看成一维，半径看成另一维，相当于平面加。

扫描线，维护每个弧度与其下一逆时针相邻弧度之间构成的 $|V|$ 块面积的覆盖次数。容易发现对于两个相邻弧度之间所夹的块，随着半径增大，覆盖次数是不增的。

考虑线段树维护，支持区间加和求全局最右边 $\ge k$ 的位置。线段树二分即可。

找到这个位置 $p$ 后，这两个弧度所夹的 $[1,p]$ 这些块构成了半径为 $p$ 圆心角为 $\dfrac{\pi}{m}$ 的扇形，容易计算。

注意到有 $\mathcal{O}(m)$ 个弧度，但是只有 $\mathcal{O}(n)$ 次修改，因此可以当这一弧度上的面积块信息发生变化是再花费一次查询，否则继承上一次查询的结果。

时间复杂度为 $\mathcal{O}(n\log m)$，空间复杂度为 $\mathcal{O}(m)$。

[AC Link](https://www.luogu.com.cn/record/193413631) & [Code](https://www.luogu.com.cn/paste/fgg0y7id)

---

## 作者：Pine (赞：2)

## 线段树

我们可以将添加一个扇形变为添加一个半径与删除一个半径。

对于$l > r$的扇形，则将它拆为两个扇形$[l, m], [-m, r]$

之后我们建立一个权值线段树，方便我们查询第k大的半径是多少

用now表示目前已经插入now个半径，那么目前覆盖至少k层的半径为第now-k+1大的半径，而覆盖的角度则是上一次添加半径的位置至这一次添加半径的位置


### 代码
```
#include <bits/stdc++.h>
#define R register
#define eps 1e-12
#define INF (1<<30)
#define LL long long
#define MM(x, y) memset(x, y, sizeof x)
#define Fo(i, x, y) for(R int i=x; i<=y; ++i)
#define Ro(i, x, y) for(R int i=x; i>=y; --i)
using namespace std;
template<typename T> inline T Max(R T x, R T y) {return x > y ? x : y;}
template<typename T> inline T Min(R T x, R T y) {return x < y ? x : y;}
template<typename T> inline void in(R T &x)
{
    static int ch; static bool flag;
    for(flag=false, ch=getchar(); ch<'0'||ch>'9'; ch=getchar()) flag |= ch=='-';
    for(x=0; ch>='0'&&ch<='9'; ch=getchar()) x = (x<<1) + (x<<3) + ch - '0';
    x = flag ? -x : x;
}

#define N 1000005
#define lc (o<<1)
#define rc (lc|1)
#define mid ((l+r)>>1)
int n, m, K, sum[N*5];

inline void update(R int o, R int l, R int r, R int x, R int p)
{
    sum[o] += p;
    if(l == r) return;
    if(x <= mid) update(lc, l, mid, x, p);
    else update(rc, mid+1, r, x, p);
}

inline int query(R int o, R int l, R int r, R int k)
{
    if(l == r) return l;
    if(k <= sum[lc]) return query(lc, l, mid, k);
    else return query(rc, mid+1, r, k-sum[lc]);
}

struct Que{
    int a, b, c;
    Que() {}
    Que(int a, int b, int c) : a(a), b(b), c(c) {}
    bool operator < (const Que &t) const {return b < t.b;}
}q[N];

int main()
{
    in(n); in(m); in(K);
    R int cnt = 0;
    Fo(i, 1, n)
    {
        R int a, b, c; in(a); in(b); in(c);
        if(b > c) q[++cnt] = Que(a, -m, 1), q[++cnt] = Que(a, c, -1), q[++cnt] = Que(a, b, 1), q[++cnt] = Que(a, m, -1);
        else q[++cnt] = Que(a, b, 1), q[++cnt] = Que(a, c, -1);
    }
    sort(q+1, q+cnt+1);
    R int now = 0, last = 0;
    R LL ans = 0;
    Fo(i, 1, cnt)
    {
        R int r = query(1, 0, 100001, now-K+1); ans += 1ll * r * r * (q[i].b-last);
        now += q[i].c; update(1, 0, 100001, q[i].a, q[i].c); last = q[i].b;
    }
    printf("%lld\n", ans);
    return 0;
}

```


---

## 作者：KobeBeanBryantCox (赞：1)

# P3997 [SHOI2013] 扇形面积并 题解

-------------

[题目传送门](https://www.luogu.com.cn/problem/P3997)。

如果接下来有看不懂的去找 AI 翻译吧。

此题甚牛而逼之！

-------------

## 题意

若有众扇形，求其面积至少为 $k$ 重覆盖者。

-------------

## 思路

不难察之，题欲吾辈求 $\sum r^2$，此依扇形面积之公式，易可得也。

初遇此题，即思以扫描线法秒之。

遂取扫描线术解之。

其法以半径为 $r$ 之扇形，于始边处增 $r$ 于数据结构，终边处减 $r$ 于结构。

每操作毕，乃行判断：若数据结构之大小 $n$ 大于等于 $k$，则取位次为 $(n−k+1)$ 者纳于答案。

诸操作皆可用平衡树维之。

故扇形者，于 $a_1$ 处增之，于 $a_2$ 处减之。

另有细则二：

其一，$-m$ 即作 $m$ 观；


其二，若 $a_1>a_2$，则析为两段：$[a_1,m+1]$ 与 $[- m+1,a_2]$ 之区间（即增 $a_1$、$-m+1$，减 $m+1$、$a_2$）。

事毕，O 而 K 之，吾用 fhq-treap 术成之。

--------------

## AC 代码

十载 OI 终成空，勿用 long long 愧对宗！

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
#define int long long
int in()
{
	int k=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
	return k*f;
}
void out(int x)
{
	if(x<0)putchar('-'),x=-x;
	if(x<10)putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
const int N=2e5+10;
struct fhq_treap
{
	struct node{int lc,rc,siz,val,rnk;}tr[N];
	#define lc(x) tr[x].lc
	#define rc(x) tr[x].rc
	void pushup(int x){tr[x].siz=tr[lc(x)].siz+tr[rc(x)].siz+1;}
	int root=0,cnt=0;
	int newnode(int v){tr[++cnt]={0,0,1,v,rand()};return cnt;}
	void split(int k,int &x,int &y,int v)
	{
		if(!k)return x=y=0,void();
		if(tr[k].val<=v)x=k,split(rc(x),rc(x),y,v);
		else y=k,split(lc(y),x,lc(y),v);
		pushup(k);
	}
	int merge(int x,int y)
	{
		if(!x||!y)return x|y;
		if(tr[x].rnk<tr[y].rnk){rc(x)=merge(rc(x),y),pushup(x);return x;}
		else {lc(y)=merge(x,lc(y)),pushup(y);return y;}
	}
	void insert(int &k,int v)
	{
		int x,y;split(k,x,y,v);
		k=merge(merge(x,newnode(v)),y);
	}
	void erase(int &k,int v)
	{
		int x,y,z;split(k,x,y,v),split(x,x,z,v-1);
		z=merge(lc(z),rc(z)),k=merge(merge(x,z),y);
	}
	int kth(int k,int a)
	{
		if(tr[lc(k)].siz+1==a)return tr[k].val*tr[k].val;
		if(tr[lc(k)].siz>=a)return kth(lc(k),a);
		else return kth(rc(k),a-tr[lc(k)].siz-1);
	}
}T;
struct qwq
{
	int t,r;bool tag;
	bool operator<(const qwq &a)const{return t<a.t;}
};vector<qwq>ovo;
vector<int>$;
signed main()
{
	int n=in(),m=in(),k=in();
	for(int i=1;i<=n;i++)
	{
		int r=in(),a1=in(),a2=in(),tmp=0;
		int aa1=a1,aa2=a2;
		if(a1==-m)a1=m;if(a2==-m)a2=m;
		if(a1>a2)tmp=a1,a1=-m+1;
		else if(a1==a2&&a1==m&&aa1<aa2)tmp=a1,a1=-m+1;
		ovo.push_back({a1,r,1}),ovo.push_back({a2,r,0});
		$.push_back(a1),$.push_back(a2);
		if(!tmp)continue;
		ovo.push_back({tmp,r,1}),ovo.push_back({m+1,r,0});
		$.push_back(tmp),$.push_back(m+1);
	}
	sort(ovo.begin(),ovo.end());
	sort($.begin(),$.end()),$.erase(unique($.begin(),$.end()),$.end());
	int i=0,ans=0,las=$[0]-1;
	for(int v:$)
	{
		if(T.tr[T.root].siz>=k)ans+=T.kth(T.root,T.tr[T.root].siz-k+1)*(v-las);
		for(;i<ovo.size()&&ovo[i].t==v;i++)
			if(ovo[i].tag)T.insert(T.root,ovo[i].r);
			else T.erase(T.root,ovo[i].r);
		las=v;
	}
	out(ans);
	return 0;
}
```

--------------

## 后记

吾有数据如下：

```text
1 8 1
1 8 8
```

未知当输 $0$ 抑或 $16$，题未明言，总归，吾之代码得 $0$。

然迄于 2025-03-14，现存首篇题解得 $15$，此必误也，宜改之或撤之！

所述有误或不明者，欢迎评之或私之。

~~另，此文言语实乃戏谑之作，不喜者轻咎。~~

宜降蓝。

---

## 作者：PUTONGDEYITIREN (赞：1)

# 思路

它这里给我们了一些扇形，叫我们求大于 $k$ 层的面积（实际上是 $\frac{\pi(a_1-a_2+1)r^2}{2m}\times\frac{2m}{\pi}$），我们把它给的这坨东西化简一下就是 $(a_1-a_2+1)\times r^2$，现在式子化简好了，我们来考虑一下比较难处理的圆圈这个问题，大家都知道，一般一个问题在圆圈上一般都是很难处理的，但是这里我们可以算出每一个格子的值再加起来，所以可以把他当作一个直线来处理，具体怎么处理我们在来看 (不知道怎么用数组存储看下图)。

![](https://cdn.luogu.com.cn/upload/image_hosting/mya64656.png)

## 方法

我们可以考虑一下扫描线，我们把每个扇形的 $a_1$ 当作入边存储，把 $a_2$ 当作出边存储，当我们遍历到入边时就在你所用的数据结构中加一，表示这个扇形在这时存在；当我们遍历到出边时就在你所用的数据结构中减一，表示这个扇形现在不在了。在每一个格子时，我们要找到所拥有扇形中的第 $k$ 大，找这个数有很多种方法，我最倾向于用树状数组加倍增，关于树状数组加倍增，先看代码吧。

# code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll  long long
#define low (x&(-x))
ll const N=2e6+5;
ll n,m,k,tree[N],a,b,r,t,ans,pp;
vector<ll> p[N];
void update(ll x,ll d){
	while(x<=2e6+4)
		tree[x]+=d,
		x+=low;
	return;
}
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){//输入并把圆圈化为直线数组
		cin>>r>>a>>b;
		if(a>b) p[0].push_back(r);
		p[a+m].push_back(r);
		p[b+m].push_back(-r);
	}
	for(int i=0;i<2*m;i++){
		for(int j=0;j<p[i].size();j++) update(abs(p[i][j]),p[i][j]/abs(p[i][j])),pp+=p[i][j]/abs(p[i][j]);
		ll u=0,s=0;
		if(pp>=k){//树状数组加倍增主要代码
			for(int l=21;l>=0;l--)
				if(u+(1<<l)<N&&s+tree[u+(1<<l)]<pp-k+1) s+=tree[u+=(1<<l)];				
			ans+=(u+1)*(u+1);			
		}	
	}
	cout<<ans<<endl;
	return 0;
}

```

# 细节

但相信大家对一些细节还有疑问，比如说如果 $a_1$ 大于 $a_2$ 怎么办，在这个时候，我们不能单纯交换他们，我们要在第一个位置再放一条边，这样子就把这个扇形分成了两个部分，在后面就不用另外考虑了。还有为什么我们要把把倍增 $s$ 的边界设为 $pp-k+1$，这很简单，就是因为我们要求的并不是第 $k$ 小的而是第 $k$ 大的。

---

## 作者：Leianha (赞：1)

## 线段树

[博客阅读](https://www.cnblogs.com/wljss/p/12658754.html)

考虑每个小区间的的贡献，显然是只用到了覆盖了这个小区间的值里面第 $k$ 大。

倘若我们已经知道了覆盖当前区间的值都有多少个，我们就可以在线段树上二分找第 $k$大。

现在我们并不知道，我们可以用差分+线段树上修改的方法来完成对当前 值的出现次数 的维护。

```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#define lson (k<<1)
#define rson ((k<<1)|1)
using namespace std;
int n, m, k, tot, r, a, b, c;
long long ans;
const int N = 100010;
int s[N << 2];
struct node
{
	int x, y, k;
} p[N << 2];
int my(node a, node b) {return a.x < b.x;}
void pushup(int k) {s[k] = s[lson] + s[rson];}
void change(int k, int l, int r, int pos, int val)
{
	if (l == r)
	{
		s[k] += val;
		return;
	}
	int mid = (l + r) >> 1;
	if (pos <= mid)change(lson, l, mid, pos, val);
	else change(rson, mid + 1, r, pos, val);
	pushup(k);
}
int ask(int k, int l, int r, int v)
{
	if (l == r)return l;
	int mid = (l + r) >> 1;
	return v <= s[rson] ? ask(rson, mid + 1, r, v) : ask(lson, l, mid, v - s[rson]);
}
signed main()
{
	cin >> n >> m >> k;
	for (int i = 1; i <= n; ++i)
	{
		scanf("%d%d%d", &c, &a, &b); a += m; b += m; r = max(r, c);
		if (a <= b)p[++tot] = (node) {a, c, 1}, p[++tot] = (node) {b, c, -1};
		else p[++tot] = (node) {a, c, 1}, p[++tot] = (node) {2 * m, c, -1}, p[++tot] = (node) {0, c, 1}, p[++tot] = (node) {b, c, -1};
	}
	sort(p + 1, p + 1 + tot, my);
	for (int i = 1; i <= tot; ++i)
	{
		a = ask(1, 0, r, k); ans += (long long)a * a * (p[i].x - p[i - 1].x);
		change(1, 0, r, p[i].y, p[i].k);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：zhimao (赞：1)

### 前言

堆是一个好东西，能干很多事。

### 正轨
此题方法很多，我用的是扫描线+堆。首先题目把平面分成等大的2m个角度。我们要求的答案就是每个角度中第k大的被覆盖的扇形半径的平方加起来的和。求第k大，@zhengrunzhe想到的是平衡树，其实没必要，两个堆也可以解决（毕竟堆比平衡树好打太多了）。

第一个堆（下称A堆）用来储存前k大半径，并且是小根堆，这样堆顶就是我们要求的；第二个堆（下称B堆）用来储存其他的，是大根堆。

**每次加入新元素**：
- 如果A堆元素个数小于k，加入A堆。
- 否则如果新元素大于A堆堆顶元素，A堆堆顶元素换到B堆，新元素加入A堆。
- 否则加入B堆

**删除元素**：
- 如果为B堆元素直接删。
- 如果为A堆元素删除之后，若B堆非空，则B堆堆顶元素换到A堆。

还有一个问题，描述扇形时l可能大于等于r，这个问题@zhengrunzhe讲的很清楚，可以戳[这里](https://www.luogu.com.cn/blog/van/solution-p3997)看。

## 注意
让我们算算答案有多大： $r^2*m$有16位，不开**long long**见祖宗！

代码就不发了，你们写的都比我好~~刚转c++的蒟蒻一枚啊~~。

---

## 作者：daklqw (赞：1)

离线一波，把询问拆成对多重集合的操作：遇到左边界插入元素，遇到右边界删除元素，元素的值均为扇形的半径

为了方便，把下下标向右偏移$m$，定义数组下标为$i$的地方对应区间$[i - m, i - m + 1]$的面积

当$l > r$,考虑把扇形拆成两个区间$[l..m)$ 和 $[-m, r)$ 

对于每个位置，先处理完插入的，再处理删除的，接着查询面积

考虑每个位置的面积，其实就是查询当前集合的第K大的值

~~于是偷懒写一波vector"平衡树"，于是跑得巨慢（可以权值线段树或平衡树代替）~~

开氧气RE不开却过了？

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>

const int MAXN = 100010;
const int MAXM = 2000010;
int n, m, k, t1, t2, t3;
std::vector<int> add[MAXM], dec[MAXM], tree;
int li[MAXN << 2], bak;
#define lb(X) lower_bound(tree.begin(), tree.end(), X)
void makeadd(int at) {
    const std::vector<int> & ad = add[at];
    const int SZ = ad.size();
    for (int i = 0; i != SZ; ++i)
        tree.insert(lb(ad[i]), ad[i]);
}
void makedec(int at) {
    const std::vector<int> & de = dec[at];
    const int SZ = de.size();
    for (int i = 0; i != SZ; ++i)
        tree.erase(lb(de[i]));
}
typedef long long LL;
LL ans = 0;
inline LL sqr(int x) { return static_cast<LL> (x) * x; }
LL calc() {
    if (tree.size() < k) return 0;
    return sqr(tree[tree.size() - k]);
}
int main() {
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 1; i <= n; ++i) {
        scanf("%d%d%d", &t1, &t2, &t3);
        if (t2 <= t3) {
            add[t2 + m].push_back(t1);
            dec[t3 + m].push_back(t1);
            li[++bak] = t2 + m;
            li[++bak] = t3 + m;
        } else {
            add[0].push_back(t1);
            dec[t3 + m].push_back(t1);
            add[t2 + m].push_back(t1);
            dec[m << 1].push_back(t1);
            li[++bak] = 0; li[++bak] = t2 + m;
            li[++bak] = t3 + m; li[++bak] = m << 1;
        }
    }
    std::sort(li + 1, li + 1 + bak);
    bak = std::unique(li + 1, li + 1 + bak) - li - 1;
    int lpos = 0;
    for (int T = 1; T <= bak; ++T) {
        const int i = li[T];
        // printf("calc %d : %lld\n", i, calc());
        ans += calc() * (i - lpos);
        lpos = i;
        makeadd(i); makedec(i);
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：Igallta (赞：1)

## 思路
因为它要给整个结果 $\times \frac{\pi}{2m}$，所以答案其实就是每一部分的 $r^2$ 加起来。

在圆上面操作显然不好操作，所以我们给它搞成一个平面。

至于怎么表示这个扇形，考虑差分。

大体思路的话我们先来看一下样例来引入：

![](https://pic1.imgdb.cn/item/67c810cfd0e0a243d40ca01f.png)

如图，所有被标记大于等于 2 的地方的 $r$ 的平方就是最终答案。但我们不从外往里数，我们从里往外数。你想：从外往里数 $k-1$ 层往后就是答案，那么从里往外就是数 $x-k$ 层就是答案。（$x$ 为总层数）

那我们就直接从里往外查询排名 $x-k$ 的是谁，然后把答案累加上去不就行了？

注意，这里是建立在差分的基础上的，如果这个扇形已经结束了你需要在数据结构删除它。

因为涉及到排名，这里考虑红黑树。

## 代码（by zhangshirui(1040353)）

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#define ll long long
using namespace std;
using namespace __gnu_pbds;
ll ans,n,m,k,s,t,r,xx=0;
vector<pair<ll,ll> > does[2000005];
tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update> tr;
ll fang(ll x){return x*x;}
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>m>>k;
	while(n--){
		cin>>r>>s>>t;
		does[s+m].emplace_back(r,1);
		does[t+m].emplace_back(r,-1);
		if(s>t){
			does[0].emplace_back(r,1);
		}

	}
	for(int i=0;i<m*2;i++){
		for(auto p:does[i]){
			if(p.second==1)tr.insert((p.first<<22)+(xx++));
			else tr.erase(tr.lower_bound(p.first<<22));
		}
		if(tr.size()>=k)ans+=fang(*tr.find_by_order(tr.size()-k)>>22);
	}
	cout<<ans;
	return 0;
}
```

这就是这道题，思路十分简单但也算不上好想，代码难度也有的，蓝紫。

---

## 作者：Emplace (赞：0)

## 题意
将一个圆形分成 $2m$ 个小扇形，在给出 $n$ 个大扇形，第 $i$ 个扇形半径为 $r_i$。给上方的的扇形逆时针编号为正，下方顺时针编号为负，则大扇形就是覆盖了第 $s_i$ 个小扇形转到到第 $t_i$ 个扇形。求至少被 $k$ 个大扇形覆盖的面积，设答案为 $T$。则输出 $T \times \frac{\pi}{2m}$。这里先给一张图。
![](https://cdn.luogu.com.cn/upload/image_hosting/n9zttuv3.png)
## 解题
### 题意转换
首先，这里先看一下怎么算一个小扇形的覆盖面积。设半径为 $r$。则面积为 $\pi \times r^2 \times \frac{1}{2m} \times \frac{2m}{\pi} = r^2$。

我们可以将题目转换为每一个小扇形中，覆盖了这个小扇形的所有大扇形有 $cnt$ 个。则这块小扇形的贡献就是其中半径第 $cnt-k+1$ 大的大扇形在这块小扇形中的面积。也就是说因为需要求至少被 $k$ 个大扇形覆盖的地方的面积，所以每块小扇形有了 $k$ 个大扇形的覆盖之后就从半径最小的大扇形开始算。
### 思路
显然，每个大扇形都是连续的。那我们用一个树状数组，可以在某个地方把它加上，再在某个地方减去即可。因为要求第 $cnt-k+1$ 大，所以对于每个大扇形，将它在它的半径的位置加或减 $1$，然后使用[树状数组倍增](https://blog.csdn.net/ym18411030/article/details/146047306?spm=1001.2014.3001.5501)就行。

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,m,ans,luozhi;
int c[3000000]; 
vector<int> tree[3000000];
int lowbit(int x){
	return x&(-x);
}
void change(int k,int x){
	for(int i=x;i<=100000;i+=lowbit(i))c[i]+=k;
}
int sum(int id){
	int x=0,k=0,y=0,cnt=0;
	for(int i=21;~i;i--){
		x=k+(1<<i);if(x>100000) continue;
		y=cnt+c[x];
		if(y<id)k=x,cnt=y;
	}
	return k+1;
}
signed main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		int r,s,t;
		cin>>r>>s>>t,s+=m,t+=m;
		if(s<t){
			tree[s].push_back(-r);
			tree[t].push_back(r);
		}
		else{
			tree[m*2].push_back(r);
			tree[s].push_back(-r);
			tree[t].push_back(r);
		}
	}
	for(int i=2*m;i>=1;i--){
		for(int j=0;j<tree[i].size();j++){
			int e=tree[i][j];
			if(e>0)change(1,e),luozhi++;
			else change(-1,-e),luozhi--;
		}
		if(luozhi>=k)ans+=sum(luozhi-k+1)*sum(luozhi-k+1);
	}
	cout<<ans;
}
```

---

## 作者：Yuzu_Soft (赞：0)

目前最优解

转化一下并将扇形从大到小排序，那么相当于是有一些区间覆盖操作，求每个点第 $k$ 次覆盖的大小。

我们考虑直接线段树维护每个点还需要被覆盖几次。加入一个区间相当于区间 -1，如果线段树拆分的小区间产生了新的 0 的节点，那么就将其覆盖为我们需要的值。

单独覆盖有点麻烦，我们人类智慧地直接将区间全部覆盖为那个值，同时线段树碰到已经有 0 的节点还需要继续拆分。

时间复杂度不会算，但是跑的很快 qwq。

hack 了不要喷 qaq。
```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
using namespace std;
char *p1,*p2,buf[1000000];
#define nc()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++)
inline int read()
{
    int x=0,f=1;
    char ch=nc();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')f=-1;
        ch=nc();
    }
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=nc();
    return x*f;
}
pii to[100005];
int nxt[100005],head[100005];
int edgenum;
void addedge(int x,int y,int z)
{
    to[++edgenum]={y,z};
    nxt[edgenum]=head[x];
    head[x]=edgenum;
}
int n,m,k;
struct segtree
{
    struct node
    {
        int tag,ma,mi,tag2;
        long long val;
    }tree[8000005];
    void pushup(int x)
    {
        tree[x].ma=max(tree[x*2].ma,tree[x*2+1].ma);
        tree[x].mi=min(tree[x*2].mi,tree[x*2+1].mi);
        tree[x].val=tree[x*2].val+tree[x*2+1].val;
    }
    void pushtag(int x,int k)
    {
        tree[x].ma+=k;
        tree[x].mi+=k;
        tree[x].tag+=k;
    }
    void pushtag2(int x,int l,int r,int k)
    {
        tree[x].val=1ll*k*k*(r-l+1);
        tree[x].tag2=k;
    }
    void pushdown(int x,int l,int r)
    {
        if(tree[x].tag!=0)
        {
            pushtag(x*2,tree[x].tag);
            pushtag(x*2+1,tree[x].tag);
            tree[x].tag=0;
        }
        if(tree[x].tag2!=-1)
        {
            int mid=l+r>>1;
            pushtag2(x*2,l,mid,tree[x].tag2);
            pushtag2(x*2+1,mid+1,r,tree[x].tag2);
            tree[x].tag2=-1;
        }
    }
    void build(int p,int l,int r)
    {
        tree[p].tag2=-1;
        tree[p].ma=tree[p].mi=k;
        if(l==r)return;
        int mid=l+r>>1;
        build(p*2,l,mid);
        build(p*2+1,mid+1,r);
    }
    void add(int p,int l,int r,int x,int y,int z)
    {
        if(!tree[p].ma)return;
        if(x<=l&&r<=y&&tree[p].mi)
        {
            pushtag(p,-1);
            if(!tree[p].mi)pushtag2(p,l,r,z);
            return;
        }
        pushdown(p,l,r);
        int mid=l+r>>1;
        if(x<=mid)add(p*2,l,mid,x,y,z);
        if(y>mid)add(p*2+1,mid+1,r,x,y,z);
        pushup(p);
    }
}yuruyuri;
int main()
{
    n=read();
    m=read();
    k=read();
    int maz=0;
    for(int x,y,z,i=1;i<=n;i++)
    {
        z=read(),x=read()+m+1,y=read()+m;
        addedge(z,x,y);
        maz=max(maz,z);
    }
    m=m<<1;
    yuruyuri.build(1,1,m);
    for(int i=maz;i>=1;i--)
        for(int k=head[i];k;k=nxt[k])
        {
            pii j=to[k];
            if(j.first<j.second)yuruyuri.add(1,1,m,j.first,j.second,i);
            else
            {
                if(j.first<=m)yuruyuri.add(1,1,m,j.first,m,i);
                if(j.second>=1)yuruyuri.add(1,1,m,1,j.second,i);
            }
        }
    while(yuruyuri.tree[1].ma!=0)yuruyuri.add(1,1,m,1,m,0);
    printf("%lld\n",yuruyuri.tree[1].val);
    return 0;
}

```

---


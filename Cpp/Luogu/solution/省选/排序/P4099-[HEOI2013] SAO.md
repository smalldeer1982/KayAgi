# [HEOI2013] SAO

## 题目描述

Welcome to SAO ( Strange and Abnormal Online)。这是一个 VR MMORPG， 含有 n 个关卡。但是，挑战不同关卡的顺序是一个很大的问题。

某款游戏有 $n-1$ 个对于挑战关卡的限制，诸如第 $i$ 个关卡必须在第 $j$ 个关卡前挑战，或者完成了第 $k$ 个关卡才能挑战第 $l$ 个关卡。并且，如果不考虑限制的方向性，那么在这 $n-1$ 个限制的情况下，任何两个关卡都存在某种程度的关联性。即，我们不能把所有关卡分成两个非空且不相交的子集，使得这两个子集之间没有任何限制。


## 说明/提示

对于 $20\%$ 的数据有 $n \le 10$。

对于 $40\%$ 的数据有 $n \le 100$。

对于另外 $20\%$ 的数据有，保证数据中 sign 只会是 <，并且 $i<j$。

对于 $100\%$ 的数据有 $T \le 5$，$1 \le n \le 1000$。

## 样例 #1

### 输入

```
2 
5 
0 < 2 
1 < 2 
2 < 3 
2 < 4 
4 
0 < 1 
0 < 2 
0 < 3```

### 输出

```
4 
6```

# 题解

## 作者：λᴉʍ (赞：65)

# P4099 [HEOI2013]SAO


---

贼~~板子~~有意思的一个题～～～~~我（）竟然没看题解~~

没卡就暂时这题rk1了来写一发题解

有一张连成树的有向图，球拓扑序数量。

树形dp，设$f[i][j]$表示$i$在子树中$i$拓扑序上排名为$j$的方案数。

难就难在转移，现在有两个树$x$和$y$，其中$x$是父亲，$x$的拓扑序小于$y$的，从$f[x][p1],f[y][p2]$转移到$newf[x][p3]$：$x$在原序列中排名$p1$，新序列中$p3$；$y$在原序列中排名$p2$，新序列中$p4$，那么限制是$p3<p4$

那么$x$子树中，$p1$左边的点也一定在$p3$左边（因为是和同一个点$x$比较）

又有限制$p3<p4$，所以$y$的原序列中排名为$[p2,siz_y]$都在$p3$右边，$[1,p2-1]$可以有一些在$p3$右边，有一些在左边

所以$p3$的左边数的数量限制是：$p1-1\leq p3-1\leq p1-1+p2-1$，也就是$p1\leq p3\leq p1+p2-1$

$p3$的范围就确定了，转移当然还要乘组合数，先考虑左边的情况，左边有$p3-1$个点，一定有$p1-1$个来自$x$的原序列，所以左边的方案数为$C_{p3-1}^{p1-1}$；右边同理，有$siz_x+siz_y-p3$个点，一定有$siz_x-p1$个点来自$x$的原序列，所以右边方案数是$C_{siz_x+siz_y-p3}^{siz_x-p1}$。

综上，从$f[x][p1],f[y][p2]$转移到$newf[x][p3]$，而且新序列中$x$在$y$左边，要满足$p1\leq p3\leq p1+p2-1$，转移方程是

$newf[x][p3]+=C_{p3-1}^{p1-1}C_{siz_x+siz_y-p3}^{siz_x-p1}f[x][p1]f[y][p2]$

还有一种情况就是新序列中$x$在$y$右边的，也是同理推，转移方程一样，唯一的区别是$p3$的取值范围是$p1+p2\leq p3\leq p1+siz_x$。

然后就解决了，然而是$O(n^3)$的，考虑优化

当然把式子写出来啊（还是以新序列中$x$在$y$左边为例）

```python
for p1 in [1,siz_x]
    for p2 in [1,siz_y]
        for p3 in [p1,p1+p2-1]
            转移
```

观察一下转移方程，好像$p2$只出现了一次，还是连续的，于是调换循环顺序（省去对循环范围的推倒）：

```python
for p1 in [1,siz_x]
    for p3 in [p1,p1+siz_y-1]
        for p2 in [p3-p1+1,siz_y]
            转移
```

那么把循环转移成了p2最后一个循环，就可以用前缀和优化转移了，然后这题切了。。。

就是新序列中$x$在$y$右边的情况直接看代码。

```cpp
#include<bits/stdc++.h>
#define il inline
#define vd void
#define mod 1000000007
typedef long long ll;
il ll gi(){
	ll x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
	return x*f;
}
int fir[1010],dis[2010],nxt[2010],w[2010],id;
il vd link(int a,int b,int c){nxt[++id]=fir[a],fir[a]=id,dis[id]=b,w[id]=c;}
int f[1010][1010],g[1010],siz[1010];
int C[1010][1010];
il vd dfs(int x){
	siz[x]=1;f[x][1]=1;
	for(int i=fir[x];i;i=nxt[i]){
		if(siz[dis[i]])continue;
		dfs(dis[i]);
		memcpy(g,f[x],sizeof g);
		memset(f[x],0,sizeof f[x]);
		if(w[i]==1){
			for(int p1=1;p1<=siz[x];++p1)
				for(int p3=p1;p3<p1+siz[dis[i]];++p3)
					f[x][p3]=(f[x][p3]+1ll*C[siz[x]+siz[dis[i]]-p3][siz[x]-p1]*C[p3-1][p1-1]%mod*g[p1]%mod*(f[dis[i]][siz[dis[i]]]-f[dis[i]][p3-p1]+mod))%mod;
		}else{
			for(int p1=1;p1<=siz[x];++p1)
				for(int p3=p1+1;p3<=p1+siz[dis[i]];++p3)
					f[x][p3]=(f[x][p3]+1ll*C[siz[x]+siz[dis[i]]-p3][siz[x]-p1]*C[p3-1][p1-1]%mod*g[p1]%mod*f[dis[i]][p3-p1])%mod;
		}
		siz[x]+=siz[dis[i]];
	}
	for(int i=1;i<=siz[x];++i)f[x][i]=(f[x][i]+f[x][i-1])%mod;
}
int main(){
#ifdef XZZSB
	freopen("in.in","r",stdin);
	freopen("out.out","w",stdout);
#endif
	C[0][0]=1;
	for(int i=1;i<=1000;++i){
		C[i][0]=1;
		for(int j=1;j<=i;++j)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
	}
	int T=gi();
	while(T--){
		id=0;memset(fir,0,sizeof fir);memset(siz,0,sizeof siz);
		int n=gi(),a,b;char ch;
		for(int i=1;i<n;++i){
			scanf("%d %c %d",&a,&ch,&b);++a,++b;
			link(a,b,ch=='<');link(b,a,ch=='>');
		}
		dfs(1);
		printf("%d\n",f[1][n]);
	}
	return 0;
}
```

---

## 作者：zhiyangfan (赞：24)

~~这题好sao啊~~

### 题意简述
给一个 $n$ 个节点 $n-1$ 条边的有向图，且保证任何两点之间都有一定的关联性，求拓扑序个数，对 $p$ 取模。（ $n \le 1000,p=10^9+7$ ）
### 思路分析
有向图的拓扑序个数看起来就是一脸不可求的样子，这提醒我们注意题目中的特殊性质——如果我们把有向边看成无向边，原图就构成了一棵树。而树型DP肯定是要比拓扑序个数好做的。

考虑设 $f_{i,j}$ 表示以 $i$ 为根的子树中，$i$ 的拓扑序排名第 $j$ 的方案数。这个状态还是比较套路的，难点在于转移。

根据树型DP的通常套路，我们考虑怎么把子结点的信息往父结点合并。比如我们要把 $f_{v,k}$ 往 $f_{u,i}$ 上合并（其中 $u$ 是 $v$ 的父结点 ），那会出现两种情况：一种是在以 $u$ 为根的子树中，$v$ 的拓扑序在 $u$ 前，即 $\cdot\cdot\cdot v\cdot\cdot\cdot u\cdot\cdot\cdot$ ，另一种就是 $u$ 在 $v$ 前，即 $\cdot\cdot\cdot u\cdot\cdot\cdot v\cdot\cdot\cdot$ 。

我们分别考虑每种情况怎么转移。当 $u$ 在 $v$ 前时，$u$ 排在第 $i$ 位，说明它前面有 $i-1$ 个结点，同理，$v$ 的前面有 $k-1$ 个结点，合并时，我们就假设有 $j$ 个结点合并到了 $u$ 前面，这下转移方程就呼之欲出了。新的状态应该是 $f_{u,i+j}$ ，原来方案数应该是 $f_{u,i}\times f_{v,k}$ ，而选 $j$ 个放到 $u$ 前的方案数是 $\binom{i+j-1}{j}\binom{size_u+size_v-i-j}{size_v-j}$ ，组合意义大概是从在拓扑序中位于 $u$ 之前的元素（ $i+j-1$ 个 ）选 $j$ 个是从 $v$ 子树来的，从拓扑序中位于 $v$ 之后的元素（ $size_u+size_v-i-j$ 个 ）选 $size_v-j$ 个是从 $v$ 子树来的。所以最终的转移方程为 $f_{u,i+j}=\binom{i+j-1}{j}\binom{size_u+size_v-i-j}{size_v-j}f_{u,i}\times f_{v,k}$ 。考虑一下每个变量的范围。显然 $1\le i\le size_u,1\le k\le size_v$ 而由于  $v$ 还在 $u$ 后，所以最多有 $k-1$ 个在 $u$ 前，即 $0\le j<k$ 

另一种情况是类似的，依然是选从在 $u$ 前面的 $i+j-1$ 个选 $j$ 个来自 $v$ ，从在 $u$ 后面的 $size_u+size_v-i-j$ 个选 $size_v-j$ 个来自 $v$ 。所以转移方程不变，但因为 $v$ 在 $u$ 前，所以至少有 $k$ 个在 $u$前，即 $k\le j\le size_v$ ，其余范围不变。

接下来考虑复杂度。$i,j,k$ 全需要枚举，所以复杂度为 $\mathcal{O}(n^3)$ ，不足以通过本题。我们来把枚举换成求和式再来推导一下（以 $u$ 在 $v$ 前为例）:

$$\sum_{i=1}^{size_u}\sum_{k=1}^{size_v}\sum_{j=0}^{k-1}\cdot\cdot\cdot=\sum_{i=1}^{size_u}\sum_{j=0}^{size_v-1}\sum_{k=1}^{size_v}\cdot\cdot\cdot[j<k]=\sum_{i=1}^{size_u}\sum_{j=0}^{size_v-1}\sum_{k=j+1}^{size_v}\cdot\cdot\cdot$$

这里展示过程主要是为了帮助一些像我一样的不会很快地换求和顺序的同学。这里的方法是先交换求和顺序，把从里面换到外面的顶满范围，再用艾佛森约定加以限制，最后通过限制外面换到里面的变量的取值范围来满足艾佛森约定（虽然笨但好用啊）（ $v$ 在 $u$ 前类似，留给读者自行推导）。

注意到这样的话后面可以把 $f_{v,k}$ 提出来变成前缀和的形式，这样就优化掉了一个变量的枚举，复杂度降低为 $\mathcal{O}(n^2)$ ，足以通过本题。

### 代码环节
有一些细节放在注释啦。
```cpp
#include <cstdio>
#include <cstring>
const int N = 2e3 + 10, mod = 1e9 + 7;
typedef long long ll; ll C[N][N];
struct edge{ int v, next, w; }E[N << 1]; int p[N], cnt;
inline void init() { memset(p, -1, sizeof p); cnt = 0; }
inline void insert(int u, int v, int w)
{ E[cnt].w = w; E[cnt].v = v; E[cnt].next = p[u]; p[u] = cnt++; }
int size[N]; ll f[N][N], g[N];
void dfs(int u, int fa)
{
	size[u] = 1; f[u][1] = 1;
	for (int t = p[u], v; t + 1; t = E[t].next)
	{
		v = E[t].v; if (v == fa) continue;
		dfs(v, u);
     	//注意到并入时用到的f值都应该是并入前的f值，所以要提前记录一下
		//否则在转移时会受到影响 
		for (int i = 1; i <= size[u]; i++) g[i] = f[u][i], f[u][i] = 0;
		if (E[t].w)
		{
			//这里0是因为前面有可能一个都没有
			//<是因为v在u后面，v子树不可能全部都在u前面 
			for (int i = 1; i <= size[u]; i++)
				for (int j = 0; j < size[v]; j++)
					f[u][i + j] = (f[u][i + j] + 
					C[size[u] + size[v] - i - j][size[v] - j] * C[i + j - 1][j] % mod
					* g[i] % mod * (f[v][size[v]] - f[v][j] + mod) % mod) % mod;
		}
		else
		{
			//这里1是因为前面至少有个v
			//<=是因为v就在u前面，v子树有可能全在u前面 
			for (int i = 1; i <= size[u]; i++)
				for (int j = 1; j <= size[v]; j++)
					f[u][i + j] = (f[u][i + j] + 
					C[size[u] + size[v] - i - j][size[v] - j] * C[i + j - 1][j] % mod
					* g[i] % mod * f[v][j] % mod) % mod;
		}
		size[u] += size[v]; //注意最后再合并size,可以降低复杂度
	}
	for (int i = 1; i <= size[u]; i++) f[u][i] = (f[u][i] + f[u][i - 1]) % mod;
}
int main()
{
	int T, n; scanf("%d", &T); char opt[5]; C[0][0] = 1;
	for (int i = 1; i < N; i++) //这里之前因为写了<=导致开O2RE了好几发/wul
	{
		C[i][0] = 1;
		for (int j = 1; j <= i; j++)
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
	}	
	while (T--)
	{
		init(); scanf("%d", &n);
		for (int i = 1, x, y; i < n; i++)
		{
			scanf("%d", &x); ++x; scanf("%s", opt); scanf("%d", &y); ++y;
			insert(x, y, opt[0] == '<'); insert(y, x, opt[0] == '>');
			//<表示x的拓扑序一定在y之前，转移时会用到 
		}
		dfs(1, 0);
		printf("%lld\n", f[1][n]);
		for (int i = 1; i <= n; i++)
		{
			for (int j = 1; j <= n; j++) f[i][j] = 0;
			size[i] = 0;
		}	 //多测不清空，爆零见祖宗
	}
	return 0;
}
```

---

## 作者：_louhc (赞：17)

# 洛谷P4099 [HEOI2013]SAO 解题报告

> Link Start!

## 思路

我们对所有关卡建图,一对关系就是一条有向边.

题目中"任何两个关卡都存在某种程度的关联性"实际上就是保证所有节点都是连通的.(从现在暂时认为所有边都是无向的)再加上边数为 $N-1$ ,很容易发现题目给出的图是一棵树.

考虑树形DP.状态 $f[u][i]$ 表示节点 $u$ 子树中, $u$ 的拓扑序在第$i$位的答案.

对于 $u$ ,我们可以依次合并每一棵子树来转移.假设遇到 $u$ 的一个儿子 $v$, $sz[u]$ 表示合并过的子树大小之和 $+1$ (即 $u$ ).我们先把合并之前的状态 $f[u][i]$ 转移到 $g[u]$ 中,并清空原来的 $f[u][i]$ .

设合并后$u$的拓扑序为第 $i$ 个,合并前为第 $j$ 个,$v$ 在子树内拓扑序为 $k$ .

$f[u][i]+=g[j] \times f[v][k] \times K$

感性理解这个转移方程就是将两个序列合并,第一个序列中 $u$ 在第 $j$ 位,第二个序列中 $u$ 在第 $k$ 位,合并后 $u$ 在第 $i$ 位,那么合并方案有多少种,由于两个序列之间的顺序有多种排列方案,所以需要乘一个常数 $K$ . $u$ 之前还需要插入 $i-j$ 个第二个序列中的元素,方案数为 $\binom{i-1}{j-1}$ (或者是 $\binom{i-1}{i-j}$ ), $u$ 之后同理, 方案数为 $\binom{sz[u]+sz[v]-i}{sz[u]-j}$.因此,$K=\binom{i-1}{j-1}\times \binom{sz[u]+sz[v]-i}{sz[u]-j}$.

注意到到此为止我们都没有关注过边的方向.这会增加合并后序列的限制: $u$ 必须在 $v$ 之前/后.

这里讨论 $u$ 必须在 $v$ 之后的情况,另一种情况同理.

$i-j \ge k-1,\therefore k \le i-j+1$.

因此只要限制 $k$ 的取值就能解决这一问题.

我我们还发现$K$的值与$k$无关,也就是说,在枚举 $k$ 时, 转移方程 $f[u][i]+=g[j] \times f[v][k] \times K$ 中变化的只有 $k$,并且枚举到的 $k$ 还是连续的一段, 于是我们可以用前缀和处理. $f[u][i]+=g[j]\times K\times \sum_{k}f[v][k]$.

于是复杂度就变成了$O(N^2)$.(转移过程可以看成 枚举 $u$ 子树中任意两个点,加起来就是枚举树上任意两点,复杂度是 $O(N^2)$ 的)

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define i64 long long
#define f80 long double
#define rgt register
#define fp( i, b, e ) for ( int i(b), I(e); i <= I; ++i )
#define fd( i, b, e ) for ( int i(b), I(e); i >= I; --i )
#define go( i, b ) for ( int i(b), v(to[i]); i; v = to[i = nxt[i]] )
template<typename T> inline bool cmax( T &x, T y ){ return x < y ? x = y, 1 : 0; }
template<typename T> inline bool cmin( T &x, T y ){ return y < x ? x = y, 1 : 0; }
#define getchar() ( p1 == p2 && ( p1 = bf, p2 = bf + fread( bf, 1, 1 << 21, stdin ), p1 == p2 ) ? EOF : *p1++ )
char bf[1 << 21], *p1(bf), *p2(bf);
template<typename T>
inline void read( T &x ){ char t(getchar()), flg(0); x = 0;
	for ( ; !isdigit(t); t = getchar() ) flg = t == '-';
	for ( ; isdigit(t); t = getchar() ) x = x * 10 + ( t & 15 );
	flg ? x = -x : x;
}

const int mod = 1e9 + 7, MAXN = 1005;
int T, N, n, h1[MAXN], h2[MAXN], nxt[MAXN<<1], to[MAXN<<1], tot;
int sz[MAXN], f[MAXN][MAXN], g[MAXN], C[MAXN][MAXN];
inline void addedge( int *hd, int x, int y ){ nxt[++tot] = hd[x], hd[x] = tot, to[tot] = y; }
inline int dec( int x ){ return x >= mod ? x - mod : x; }
inline int rec( int x ){ return x < 0 ? x + mod : x; }

void DFS( int u, int fa ){
	memset( f[u] + 1, 0, N<<2 ), sz[u] = 1, f[u][1] = 1;
	go( e, h1[u] ) if ( v != fa ){ // in dfn, u is before v
		DFS(v, u), memcpy( g + 1, f[u] + 1, sz[u] << 2 ), memset( f[u] + 1, 0, sz[u] << 2 );
		fp( j, 1, sz[u] ) fp( i, j, sz[v] + j - 1 )
			f[u][i] = ( f[u][i] + 1ll * g[j] * C[i - 1][j - 1] % mod * C[sz[u] + sz[v] - i][sz[u] - j] % mod * rec(f[v][sz[v]] - f[v][i - j]) ) % mod;
		sz[u] += sz[v];
	}
	go( e, h2[u] ) if ( v != fa ){ // in dfn, u is after v
		DFS(v, u), memcpy( g + 1, f[u] + 1, sz[u] << 2 ), memset( f[u] + 1, 0, sz[u] << 2 );
		fp( j, 1, sz[u] ) fp( i, j + 1, sz[v] + j )
			f[u][i] = ( f[u][i] + 1ll * g[j] * C[i - 1][j - 1] % mod * C[sz[u] + sz[v] - i][sz[u] - j] % mod * f[v][i - j] ) % mod;
		sz[u] += sz[v];
	} fp( i, 1, sz[u] ) f[u][i] = dec( f[u][i - 1] + f[u][i] );
}

signed main(){
	read(T), C[0][0] = 1;
	fp( i, 1, 1000 ){ C[i][0] = 1; fp( j, 1, i ) C[i][j] = dec(C[i - 1][j - 1] + C[i - 1][j]); }
	while( T-- ){
		read(N), memset( h1+1, 0, N<<2 ), memset( h2+1, 0, N<<2 ), tot = 0;
		char t; int x, y;
		fp( i, 2, N ){
			read(x), t = getchar(), read(y), ++x, ++y;
			if ( t == '<' ) addedge( h1, x, y ), addedge( h2, y, x );
			else addedge( h1, y, x ), addedge( h2, x, y );
		} DFS(1, 0), printf( "%d\n", f[1][N] );
	}
	return 0;
}
```



---

## 作者：do_while_true (赞：17)

回忆一个外向树的拓扑序计数是如何解决的。对于所有的 $n!$ 种方案，必须要满足根在所有子孙的拓扑序之前，那么方案书就是 $\frac{n!}{\frac{n!}{(n-1)!}}=\frac{n!}{n}$，然后就可以剥去根不考虑根的印象。之后每次再考虑剩余若干子树的一个根 $x$，要满足 $x$ 出现在它所有子孙之前，那么方案数就会除掉 $siz_x$，之后 $x$ 就对总方案数没有了影响，可以剥除。所以外向树的拓扑序个数是 $\frac{n!}{\prod siz_x}$．

现在有了内向边，同时有内向边和外向边不是很好做，我们现在只会做只有外向边。

考虑容斥，选出 $i$ 条内向边，钦定它们是一定不满足的，剩余的内向边满足与否都无所谓。那么这种情况的方案数就是把选出的内向边看成外向边，其余的当作不存在（也就是这条边的限制满足与否都无所谓），然后对连通块分别求出拓扑序，再利用组合数乘起来（此时连通块之间不存在影响了），容斥系数就是 $(-1)^i$．

基于这个容斥，列出 dp，令 $g_{i,j}$ 表示考虑 $i$ 以内的子树，一共钦定了 $j$ 条内向边是不满足的。但是发现由于需要对拓扑序计数，还要记一个当前 $i$ 所在连通块的总和为 $k$，这样状态数就达到了 $\mathcal{O}(n^3)$，不能接受。

考虑我们最终只是想要求 $\sum g_{i,j,k}(-1)^j$，那么就可以令 $f_{i,k}=\sum g_{i,j,k}(-1)^j$，换而言之，令 $f_{i,k}$ 为考虑 $i$ 子树内，所有钦定方案的，带容斥系数的拓扑序数之和。转移即为一个树形背包，在钦定一条内向边一定不满足的时候，乘上一个 $-1$ 的容斥系数来转移即可。

时间复杂度 $\mathcal{O}(Tn^2)$．

```cpp
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<ctime>
#include<random>
#include<assert.h>
#define pb emplace_back
#define mp make_pair
#define fi first
#define se second
#define dbg(x) cerr<<"In Line "<< __LINE__<<" the "<<#x<<" = "<<x<<'\n';
#define dpi(x,y) cerr<<"In Line "<<__LINE__<<" the "<<#x<<" = "<<x<<" ; "<<"the "<<#y<<" = "<<y<<'\n';
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int>pii;
typedef pair<ll,int>pli;
typedef pair<ll,ll>pll;
typedef pair<int,ll>pil;
typedef vector<int>vi;
typedef vector<ll>vll;
typedef vector<pii>vpii;
typedef vector<pil>vpil;
template<typename T>T cmax(T &x, T y){return x=x>y?x:y;}
template<typename T>T cmin(T &x, T y){return x=x<y?x:y;}
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
template<typename T>
T &read(T &r){
	r=0;bool w=0;char ch=getchar();
	while(ch<'0'||ch>'9')w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9')r=r*10+(ch^48),ch=getchar();
	return r=w?-r:r;
}
template<typename T1,typename... T2>
void read(T1 &x,T2& ...y){read(x);read(y...);}
const int mod=1000000007;
inline void cadd(int &x,int y){x=(x+y>=mod)?(x+y-mod):(x+y);}
inline void cdel(int &x,int y){x=(x-y<0)?(x-y+mod):(x-y);}
inline int add(int x,int y){return (x+y>=mod)?(x+y-mod):(x+y);}
inline int del(int x,int y){return (x-y<0)?(x-y+mod):(x-y);}
int qpow(int x,int y){
	int s=1;
	while(y){
		if(y&1)s=1ll*s*x%mod;
		x=1ll*x*x%mod;
		y>>=1;
	}
	return s;
}
const int N=1010;
int n,f[N][N],g[N];
int fac[N],inv[N],rev[N];
int C[N][N];
int siz[N];
vpii eg[N];
void dfs(int x,int fa){
	siz[x]=1;f[x][1]=1;
	for(auto i:eg[x])if(i.fi!=fa){
		int v=i.fi,w=i.se;
		dfs(v,x);
		if(w){
			for(int j=1;j<=siz[x];j++)
				for(int k=1;k<=siz[v];k++)
					cadd(g[j+k],1ll*f[x][j]*f[v][k]%mod*C[siz[x]+siz[v]][siz[x]]%mod);
			siz[x]+=siz[v];
			for(int j=0;j<=siz[x];j++)f[x][j]=g[j],g[j]=0;
		}
		else{
			for(int j=1;j<=siz[x];j++)
				for(int k=1;k<=siz[v];k++){
					int t=1ll*f[x][j]*f[v][k]%mod*C[siz[x]+siz[v]][siz[x]]%mod;
					cdel(g[j+k],t);
					cadd(g[j],t);
				}
			siz[x]+=siz[v];
			for(int j=0;j<=siz[x];j++)f[x][j]=g[j],g[j]=0;
		}
	}
	for(int i=1;i<=siz[x];i++)f[x][i]=1ll*f[x][i]*rev[i]%mod;
}
void solve(){
	for(int i=0;i<=n;i++)vpii().swap(eg[i]),siz[i]=0;
	for(int i=0;i<=n;i++)
		for(int j=0;j<=n;j++)
			f[i][j]=0;
	read(n);
	for(int i=1;i<n;i++){
		int u,v;read(u);char ch=getchar();read(v);
		if(ch=='>')swap(u,v);
		eg[u].pb(mp(v,0));
		eg[v].pb(mp(u,1));
	}
	dfs(0,-1);
	int ans=0;
	for(int i=0;i<=n;i++)cadd(ans,f[0][i]);
//	cout << "ans = ";
	cout << ans << '\n';
}
signed main(){
	#ifdef do_while_true
//		assert(freopen("data.in","r",stdin));
//		assert(freopen("data.out","w",stdout));
	#endif
	fac[0]=1;for(int i=1;i<=1000;i++)fac[i]=1ll*fac[i-1]*i%mod;
	inv[1000]=qpow(fac[1000],mod-2);
	for(int i=999;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod;
	for(int i=1;i<=1000;i++)rev[i]=1ll*inv[i]*fac[i-1]%mod;
	C[0][0]=1;
	for(int i=1;i<=1000;i++){
		C[i][0]=1;
		for(int j=1;j<=i;j++)C[i][j]=add(C[i-1][j-1],C[i-1][j]);
	}
	int T;read(T);while(T--)solve();
    #ifdef do_while_true
		cerr<<'\n'<<"Time:"<<1.0*clock()/CLOCKS_PER_SEC*1000<<" ms"<<'\n';
	#endif
	return 0;
}
```

---

## 作者：EricQian (赞：9)

[P4099 [HEOI2013]SAO](https://www.luogu.com.cn/problem/P4099)

类型：树形 $\text{DP}$

这里主要补充一下 $O(n^3)$ 的 $\text{DP}$ 优化的过程，基础转移方程推导可以参考其他巨佬的博客（题解）。

令 $f[x][p]$ 表示在以 $x$ 为根的子树中，$x$ 在拓扑序排在第 $p$ 个时的方案数。

转移中设 $x$ 在已经合并的拓扑序中排名为 $p_1$ ，将要合并的子树（以 $ver$ 为根）中 $ver$ 排名为 $p_2$ ，合并后 $x$ 排名为 $p_3$ 。

### 1. 列出转移方程：（为了表示方便略去了取模操作）

+ 若 $x < ver$ 即 $x$ 应在 $ver$ 之前，$p_1<p_2$ 。

```cpp
for(p1 = [1,siz[x]])
	for(p2 = [1,siz[ver]])
		for(p3 = [p1,p1+p2-1])
	 		f[x][p3]+=f[x][p1]*f[ver][p2]*c[p3-1][p1-1]*c[siz[x]+siz[ver]-p3][siz[x]-p1];
```

+ 若 $x > ver$ 即 $x$ 应在 $ver$ 之后，$p_1>p_2$ 。

```cpp
for(p1 = [1,siz[x]])
	for(p2 = [1,siz[ver]])
	 	for(p3 = [p1+p2,siz[x]+siz[ver]])
	 	 	f[x][p3]+=f[x][p1]*f[ver][p2]*c[p3-1][p1-1]*c[siz[x]+siz[ver]-p3][siz[x]-p1];
```

（更直观的转移方程：）

$$f[x][p3]+=f[x][p1]\times f[ver][p2]\times C_{p3-1}^{p1-1}\times C_{siz[x]+siz[ver]-p3}^{siz[x]-p1}$$

到此为止，你可以得到 $40pts$ 的好成绩。

### 2. 交换内外循环

可以观察到 $p_2$ 在转移方程中只出现了一次，因此我们将 $p_2$ 和 $p_3$ 的循环交换，列出转移方程：

+ 若 $x < ver$ 即 $x$ 应在 $ver$ 之前，$p_1<p_2$ 。

```cpp
for(p1 = [1,siz[x]])
	for(p3 = [p1,p1+siz[ver]-1])
	 	for(p2 = [p3-p1+1,siz[ver]])
		 	f[x][p3]+=f[x][p1]*f[ver][p2]*c[p3-1][p1-1]*c[siz[x]+siz[ver]-p3][siz[x]-p1];
```

+ 若 $x > ver$ 即 $x$ 应在 $ver$ 之后，$p_1>p_2$ 。

```cpp
for(p1 = [1,siz[x]])
	for(p3 = [p1+1,p1+siz[ver]])
	 	for(p2 = [1,p3-p1])
		 	f[x][p3]+=f[x][p1]*f[ver][p2]*c[p3-1][p1-1]*c[siz[x]+siz[ver]-p3][siz[x]-p1];
```

### 3. 前缀和优化去掉一层循环

通过上一步的交换，发现 $f[x][p3]$ 累加中的 $p2$ 是一段连续的，并且满足乘法结合律，联想到前缀和优化。

令 $g[x][p]$ 表示在以 $x$ 为根的子树中，$x$ 在拓扑序排在**前** $p$ 个时的方案数之和。

那么转移方程变为：

+ 若 $x < ver$ 即 $x$ 应在 $ver$ 之前，$p_1<p_2$ 。

```cpp
for(p1 = [1,siz[x]])
	for(p3 = [p1,p1+siz[ver]-1])
		g[x][p3]+=g[x][p1]*(g[ver][siz[ver]]-g[ver][p3-p1])*c[p3-1][p1-1]*c[siz[x]+siz[ver]-p3][siz[x]-p1];
```

+ 若 $x > ver$ 即 $x$ 应在 $ver$ 之后，$p_1>p_2$ 。

```cpp
for(p1 = [1,siz[x]])
	for(p3 = [p1+1,p1+siz[ver]])
		g[x][p3]+=g[x][p1]*g[ver][p3-p1]*c[p3-1][p1-1]*c[siz[x]+siz[ver]-p3][siz[x]-p1];
```

记得在最后加上：

```cpp
for(int i=1;i<=siz[x];i++) g[x][i]+=g[x][i-1];
```

所以这道题 $AC$ 了。

**注：转移中为了维持方程的无后效性，应将 $f$ 数组备份一遍。**

$100pts$ 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define inf 0x3f3f3f3f
#define Maxn 1005
#define mod 1000000007
inline int rd()
{
	 int x=0;
     char ch,t=0;
     while(!isdigit(ch = getchar())) t|=ch=='-';
     while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
     return x=t?-x:x;
}
int t,n,tot;
int dp[Maxn][Maxn],tmp[Maxn],c[Maxn][Maxn],siz[Maxn];
int hea[Maxn],nex[Maxn<<1],ver[Maxn<<1],edg[Maxn<<1];
void add(int x,int y,int d)
{
	 ver[++tot]=y,nex[tot]=hea[x],hea[x]=tot,edg[tot]=d;
}
void dfs(int x,int fa)
{
	 siz[x]=1,dp[x][1]=1;
	 for(int i=hea[x];i;i=nex[i])
	 {
	 	 if(ver[i]==fa) continue;
	 	 dfs(ver[i],x);
	 	 memcpy(tmp,dp[x],sizeof(dp[x]));
	 	 memset(dp[x],0,sizeof(dp[x]));
	 	 if(edg[i])
		 	 for(int p1=1;p1<=siz[x];p1++)
	 	 	 	 for(int p3=p1;p3<=siz[ver[i]]+p1-1;p3++)
					 dp[x][p3]=(dp[x][p3]+1ll*tmp[p1]*(dp[ver[i]][siz[ver[i]]]-dp[ver[i]][p3-p1]+mod)%mod*c[p3-1][p1-1]%mod*c[siz[x]+siz[ver[i]]-p3][siz[x]-p1]%mod)%mod;
		 else
		 	 for(int p1=1;p1<=siz[x];p1++)
	 	 	 	 for(int p3=p1+1;p3<=siz[ver[i]]+p1;p3++)
					 dp[x][p3]=(dp[x][p3]+1ll*tmp[p1]*dp[ver[i]][p3-p1]%mod*c[p3-1][p1-1]%mod*c[siz[x]+siz[ver[i]]-p3][siz[x]-p1]%mod)%mod;
	 	 siz[x]+=siz[ver[i]];
	 }
	 for(int i=1;i<=siz[x];i++) dp[x][i]=(dp[x][i]+dp[x][i-1])%mod;
}
int main()
{
     //freopen(".in","r",stdin);
     //freopen(".out","w",stdout);
     c[1][0]=c[0][0]=1;
     for(int i=1;i<=1000;i++,c[i][0]=1)
     	 for(int j=1;j<=i;j++)
     	 	 c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
	 t=rd();
	 char c;
	 while(t--)
	 {
	 	 n=rd();
	 	 memset(hea,0,sizeof(hea)),tot=0;
	 	 memset(siz,0,sizeof(siz));
	 	 for(int i=1,x,y;i<n;i++)
	 	 {
	 	 	 x=rd()+1,cin>>c,y=rd()+1;
	 	 	 add(x,y,c=='<'),add(y,x,c=='>');
		 }
		 dfs(1,0);
		 printf("%d\n",dp[1][n]);
	 }
     //fclose(stdin);
     //fclose(stdout);
     return 0;
}
```

---

## 作者：WrongAnswer_90 (赞：8)

[P4099 [HEOI2013] SAO](https://www.luogu.com.cn/problem/P4099)

很有意思的一道题。

考虑树形 DP。首先考虑的是 $f_i$ 表示 $i$ 为根的子树内合法的拓扑序数量，但是这样合并子树的时候是无法计算的，如下图：

![](https://s2.loli.net/2023/10/12/ZG2S9OmMrEg8o6D.png)

假设 $1$ 当前合并了 $3$ 这棵子树，接下来要合并红色和蓝色的部分，此时 $2$ 必须在 $1$ 之后挑战，但是方案数并不是简单地两个 $f$ 值相乘，观察可以发现 **$5,4,7$ 号点的合并顺序是任意的**，并且 **$1,2$ 都挑战了之后 $3,6,8$ 的挑战顺序也不是一种**，所以我们合并的时候会乘**两个**神秘系数。

观察性质，合并 $i,to$ 两棵树时，问题可以抽象为两个序列，合并之后 $i$ 需要在 $to$ 前面并且保持原先相对顺序不变，而上面所说的的神秘系数其实完全由在 $i,to$ 之前与之后的数的个数决定。

注意到我们并不关心前面的数的顺序，因为这个东西显然满足乘法原理，只需要把顺序数存在 $f$ 里直接乘起来就是对的。

很自然的，想到再加一维状态 $f_{i,j}$ 表示 $i$ 在它当前子树内排名为 $j$ 的方案数（本质上还是记录的在它之前的数的个数 $j-1$，而在它之后的数就是 $siz_i-j$），接下来是愉快的推式子时间：

设 $i,to$ 为当前合并的两棵树，其中 $i$ 在它所在的子树内排在第 $j$ 位，$to$ 在它所在的子树内排在第 $k$ 位。

若 $i$ 指向 $to$，即 $i$ 在 $to$ 之前挑战，则合并大概是这样的：

![](https://s2.loli.net/2023/10/12/cNI2U9wRqgtDnGX.png)

橙圈表示合并后的序列在 $i$ 之前的数字数，枚举 $t$ 表示合并后 $i$ 的位置在第 $t$ 位，则红圈一定是第 $t$ 个，橙圈中应当有 $t-1$ 个数，其中 $j-1$ 个为序列 $i$ 中的元素，合并顺序随意，所以第一个系数就是 $C_{t-1}^{j-1}$。

新序列中第 $t$ 个为数字是 $i$，接下来 $siz_i+siz_to-t$ 个数中有 $siz_i-j$ 个是序列 $i$ 中的元素，所以第二个系数就是 $C_{siz_i+siz_to-t}^{siz_i-j}$。

对于 $t$ 的取值，最少取 $j$，最多取 $j+k-1$，因为 $to$ 一定在 $i$ 之后，如果 $t>j+k-1$ 则一定是合法。

整理一下，在外层枚举 $t$，求出 $k$ 的取值范围 $[1,t-j+1]$ 就得出转移方程：

$$f_{i,t}=f_{i,j}f_{to,k}C_{t-1}^{j-1}C_{siz_i+siz_to-t}^{siz_i-j}$$

观察一下，其中只有 $f_{to,k}$ 一项中包含 $k$，并且是连续的一段，显然可以用前缀和优化。

对于 $to$ 指向 $i$ 的情况也是同理，转移方程甚至也是一样的，只不过取值变了一些。

最后讨论一下时间复杂度，对于每一条边连接 $fa_x$ 和 $x$，它会被计算 $(siz_{fa_x}-siz_x)siz_x$，相当于是把它两边的点互相枚举了一遍，这样每个点对只会合并一次，所以时间复杂度是优秀的 $\mathcal O(n^2)$。

本题无论是状态的设计，方程的推导，范围的计算，转移的优化都需要细致的思考，是一道不可多得的好题。

```cpp
int T,n,cnt,fr[1001],inv[1001],head[1001],to[2001],nex[2001],v[2001],tmp[1001],f[1001][1001],siz[1001];
inline void add(int x,int y,int z){to[++cnt]=y,v[cnt]=z,nex[cnt]=head[x],head[x]=cnt;}
inline int C(int n,int m){return fr[n]*inv[m]%MOD*inv[n-m]%MOD;}
inline int power(int x,int y)
{
	int s=1;
	for(;y;y>>=1,x=x*x%MOD)if(y&1)s=s*x%MOD;
	return s;
}
void dfs(int x,int fa)
{
	siz[x]=1,f[x][1]=1;
	for(int i=head[x];i;i=nex[i])
	{
		if(to[i]==fa)continue;
		dfs(to[i],x),memcpy(tmp,f[x],sizeof(tmp)),memset(f[x],0,sizeof(f[x]));
		if(v[i]==1)
		{
			for(int j=1;j<=siz[x];++j)
			{
				for(int t=j;t<=j+siz[to[i]]-1;++t)
				f[x][t]=(f[x][t]+tmp[j]*((f[to[i]][siz[to[i]]]-f[to[i]][t-j])%MOD+MOD)%MOD*C(t-1,j-1)%MOD*C(siz[x]+siz[to[i]]-t,siz[x]-j))%MOD;
			}
		}
		else
		{
			for(int j=1;j<=siz[x];++j)
			{
				for(int t=j+1;t<=siz[to[i]]+j;++t)
				f[x][t]=(f[x][t]+tmp[j]*f[to[i]][t-j]%MOD*C(t-1,j-1)%MOD*C(siz[x]+siz[to[i]]-t,siz[x]-j))%MOD;
			}
		}
		siz[x]+=siz[to[i]];
	}
	for(int i=2;i<=siz[x];++i)f[x][i]=(f[x][i]+f[x][i-1])%MOD;
}
inline void mian()
{
	fr[0]=inv[0]=1,read(T);int x,y;char ch;
	for(int i=1;i<=1000;++i)fr[i]=fr[i-1]*i%MOD;
	inv[1000]=power(fr[1000],MOD-2);
	for(int i=999;i>=1;--i)inv[i]=inv[i+1]*(i+1)%MOD;
	while(T--)
	{
		read(n),memset(head,0,sizeof(head)),memset(f,0,sizeof(f)),cnt=0;
		for(int i=1;i<n;++i)read(x),ch=getchar(),read(y),++x,++y,add(x,y,ch=='<'),add(y,x,ch=='>');
		dfs(1,0),write(f[1][n],'\n');
	}
}
```

---

## 作者：苹果蓝17 (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/P4099)

[更好的阅读体验](https://www.cnblogs.com/Appleblue17/p/14801332.html)

#### 题意简述

一棵 $n$ 个点的树，边有方向，求其拓扑序数量，答案对 $10^9+7$ 取模。

$n \leq 10^3$。

#### 题目分析

将拓扑序理解成给每一个点赋一个值 $t_u$，求满足 $\forall (u,v),t_u<t_v$ 的排列 $\{t_i\}$ 。

如果边的方向都是统一的（即第三个部分分），图退化成一棵有根树，可以使用 $O(n)$ 的树形 dp 解决。

本题中的树边方向不统一，似乎只能将它当作 `DAG` 来考虑，但这样不仅丢失了许多性质，也难以设计状态。

不妨直接进行树形 dp，对于两种方向分别进行转移。

考虑设计状态，观察到方案数**只与值的大小关系**有关，设 $f_{i,j}$ 表示 **$i$ 在其子树中的排名为 $j$ 的方案数**。

转移使用类似树形背包的方式，不断加入子树。

现在考虑将树 $v$ 加入树 $u$ 得到新的树 $u'$，计算 $f_{u',k}$ 的值。

+ $v$ 连向 $u$：

  设加入前 $u$ 在树 $u$ 内的排名为 $p$，$v$ 在树 $v$ 内的排名为 $q$。

  + 考虑限制：加入后 $u$ 的排名变为了 $k$，说明树 $v$ 内有 $k-p$ 个点比 $u$ 小，而 $q$ 在树 $v$ 内的排名为 $q$，因此有限制 $q \leq k-p$，即 $p+q \leq k$。

  + 考虑计算：$u$ 的排名由 $p$ 变为 $k$，比 $u$ 小的点原来有 $p-1$ 个，新加的有 $k-p$ 个，而这些点实际上是确定的（就是 $u$ 树里最小的 $p-1$ 个点和 $v$ 树的 $k-p$ 个点），因此只需考虑它们间的顺序：可重排列 $\dbinom{k-1}{p-1}$；同理，比 $u$ 大的点原来有 $siz_u-p$ 个，新加的有 $siz_v-k+p$ 个，可重排列 $\dbinom{siz_u+siz_v-k}{siz_u-p}$。

  综上，可以得到转移式：

  $$f_{u',k}=\sum\limits_{p=1}^{siz_u} \sum\limits_{q=1}^{siz_v} [p+q \leq k] f_{u,p} f_{v,q} \dbinom{k-1}{p-1} \dbinom{siz_u+siz_v-k}{siz_u-p}$$

+ $u$ 连向 $v$：

  + 考虑限制：同理，有限制 $q > k-p$，即 $p+q > k$。

  + 考虑计算：与第一种情况相同。

  同理，可以得到转移式：

  $$f_{u',k}=\sum\limits_{p=1}^{siz_u} \sum\limits_{q=1}^{siz_v} [p+q > k] f_{u,p} f_{v,q} \dbinom{k-1}{p-1} \dbinom{siz_u+siz_v-k}{siz_u-p}$$

总复杂度 $O(n^4)$。

考虑优化，将只与 $p$ 有关的东西提出来：

$$f_{u',k}=\sum\limits_{p=1}^{siz_u} f_{u,p} \dbinom{k-1}{p-1}\dbinom{siz_u+siz_v-k}{siz_u-p} \sum\limits_{q=1}^{k-p}  f_{v,q} $$

$$f_{u',k}=\sum\limits_{p=1}^{siz_u} f_{u,p} \dbinom{k-1}{p-1}\dbinom{siz_u+siz_v-k}{siz_u-p} \sum\limits_{q=k+1-p}^{siz_v}  f_{v,q}$$

就只剩下一个 $f_{v,q}$ 的前缀和，即可做到 $O(n^2)$，可以通过本题。

~~$O(n^2 \log n)$ 的任意模数 NTT 也可以过去……~~

#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5,mod=1e9+7;
int mul[N],inv[N],pw[N];
int ksm(int a,int x){
	int tot=1;
	while(x){
		if(x & 1ll) tot=1ll*tot*a%mod;
		a=1ll*a*a%mod;
		x>>=1ll;
	}
	return tot;
}
void PRE(){
	int lim=N-5;
	mul[0]=inv[0]=1;
	for(int i=1;i<=lim;i++) mul[i]=1ll*mul[i-1]*i%mod;
	inv[lim]=ksm(mul[lim],mod-2);
	for(int i=lim-1;i>=1;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;
}
int C(int m,int n){
	if(m<n || m<0 || n<0) return 0;
	return 1ll*mul[m]*inv[n]%mod*inv[m-n]%mod;
}

struct nod{
	int to,nxt,w;
}e[N*2];
int head[N],cnt;
void add(int u,int v,int w){
	e[++cnt].to=v;
	e[cnt].w=w;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}

int T,n,ans;
int siz[N],f[N][N],pre[N][N],suf[N][N],tmp[N];

void dfs(int u,int fa){
	siz[u]=1;
	f[u][1]=1;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa) continue;
		dfs(v,u);
		if(e[i].w==1){
			for(int p=siz[u];p>=1;p--)
				for(int q=siz[v];q>=1;q--)
					tmp[p+q]=(tmp[p+q]+1ll*f[u][p]*C(p+q-1,p-1)%mod*C(siz[u]+siz[v]-p-q,siz[u]-p)%mod*pre[v][q]%mod)%mod;
		}
		else{
			for(int p=siz[u];p>=1;p--)
				for(int q=siz[v];q>=0;q--)
					tmp[p+q]=(tmp[p+q]+1ll*f[u][p]*C(p+q-1,p-1)%mod*C(siz[u]+siz[v]-p-q,siz[u]-p)%mod*suf[v][q+1]%mod)%mod;
		}
		siz[u]+=siz[v];
		for(int t=1;t<=siz[u];t++) f[u][t]=tmp[t],tmp[t]=0;
	}
	pre[u][0]=f[u][0];
	for(int t=1;t<=siz[u];t++) pre[u][t]=(pre[u][t-1]+f[u][t])%mod;
	suf[u][siz[u]+1]=0;
	for(int t=siz[u];t>=1;t--) suf[u][t]=(suf[u][t+1]+f[u][t])%mod;
}

int main(){
	PRE();
	cin>>T;
	while(T-->0){
		cin>>n;
		cnt=0;
		memset(head,0,sizeof(head));
		memset(f,0,sizeof(f));
		ans=0;
		for(int i=1;i<n;i++){
			int u,v;
			char w;
			scanf("%d %c%d",&u,&w,&v);
			u++,v++;
			if(w=='>') add(u,v,1),add(v,u,0);
			else add(u,v,0),add(v,u,1);
		}
		dfs(1,0);
		for(int i=1;i<=n;i++) ans=(ans+f[1][i])%mod;
		cout<<ans<<endl;	
	}
}
```

---

## 作者：walk_alone (赞：5)

（这个题好多题解真心看不懂，问了学长之后才明白，于是写一个更加详细的题解出来）

这题首先是对于图的一个判定问题。题目说是拓扑图，又满足树的性质。那么肯定按照树来分析啊！

如果是树，然后又是这种计数类问题，搞得不好就是DP。然后就来刻画状态。

记$f_{u,i}$为$u$在它的形式子树内拓扑序为第$i$位时的方案总数。首先这个东西就挺难理解的。

由于这个图是一个拓扑图，又有树的性质，不妨以1为根节点。忽略有向边的方向直接跑树的遍历，这样我们就得到了一个形式上的树。但是这题是有向边，那么就存在一个情况就是：对于某一个节点$u$，它的子节点$v$到它的边可能是$u\to v$或者$v \to u$。从拓扑序中看后一种情况应该是$v$在$u$前，但是这里为了方便统计就强行让$v$作为$u$的子节点。

然后就要考虑状态转移了。考虑$u\to v$的情况。现在需要让$v$这个子树合并到$u$上，此时$f_{u,i}$表示的是**已经合并进去**的序列中$u$排在拓扑序$i$的方案总数。

[![65ultJ.png](https://z3.ax1x.com/2021/03/21/65ultJ.png)](https://imgtu.com/i/65ultJ)

例如，当我们准备将$v$合并进入$u$时，$u$已经合并了$u_2,u_4$子节点，那么$f_{u,i}$代表的只是$u_2$与$u_4$这两个子树大小的序列，**而不是全部！**。也就是说，初始的时候$f_{u,i}$只代表它自己，序列长度为$1$。

将这个图抽象出来成为下面的这个形式：

$$
\underline{A} \quad i \quad \underline{B}
$$
$$
\downarrow
$$
$$
\underline{C} \quad j \quad \underline{D}
$$

其中$A,B$都是$u$已经合并进去的子树，$i$为其排位；$j$同理。$A$代表排在$u$前的子树，如果用上面这个图表示（假定$u$的子树除了$v$没有被合并）就是$u_1,u_2$两个子树——它们指向$u$。而$B$代表的是$u_3,u_4$——它们被$u$指向。显然在拓扑序中一定要满足这个关系，无论是合并前还是合并后。

现在考虑将$v$合并。合并后总序列长度应该是$size_u+size_v$——此处的$size_u$不计入$size_v$，待合并完成后再更新。考虑$u$在新序列中的位置，枚举这个位置$k$。由于在$u$前的子树序列$A$合并后也一定在$u$前，所以$k-1 \geq i-1$，并且多出来的一定是$v$形式子树内的$C$**开头部分**贡献的——$v$的子树序列会全部进入$u$，$v$内顺序不变。如果不是开头部分那么开头的元素没办法放了。同理，$D$的最后部分子树必须插在$B$中。

先来考虑将开头部分的$C$插入$A$的方案总数。根据约定，$A$全部保留，一部分的$C$加入使得这一部分（$u$节点前）总长变成$k-1$。而且$A,C$序列内部顺序不可交换（否则不满足拓扑性质），那么显然，这部分方案总数为：$C_{k-1}^{i-1}$——新序列中$u$前面$k-1$个空位放了$i-1$个$A$，剩下的直接由$C$全部照搬。

后面$D$进入$B$的问题本质相同，答案为$\displaystyle C_{size_u+size_v-k}^{size_u-1}$。

从更高的角度去审视这个问题，其实是**枚举$v$子树的分割位置**，这个位置与$k$相关——$k-i$个$C$序列进去$u$前，其余的到$u$后。前后插入个数、原$u,v$序列方案总数这四个问题相互独立，因而满足乘法原理，相乘即可。

所以我们整理出了这样的DP方程：

$$f'_{u,k}=\sum_{i=1}^{size_u}\sum_{j=1}^{size_v}C_{k-1}^{i-1}C_{size_u+size_v-k}^{size_u-1}f_{u,i}f_{v,j}$$

这里没有直接刷进去是因为前后的$f$明显指代的序列长度都不一样，因而不可混和。

如果是$v \to u$情况完全相同，只是$v$一定要在$u$前：

$$f'_{u,k}=\sum_{i=1}^{size_u}\sum_{j=1}^{size_v}C_{k-1}^{i-1}C_{size_u+size_v-k}^{size_v-1}f_{u,i}f_{v,j}$$

显然，$i \leq k \leq i+j-1$

注意到上式中$j$只出现了一次，而且我们复杂度还是$O(n^3)$，因而考虑优化这一维。

考虑$\displaystyle sum_{u,i}=\sum_{j=1}^{i}f_{u,j} $，则可消去一维的枚举：

$$f'_{u,k}=\sum_{i=1}^{size_u}C_{k-1}^{i-1}C_{size_u+size_v-k}^{size_v-1}f_{u,i}sum_{v,size_v}$$

这样就能到$O(n^2)$的复杂度了。

（代码太丑就不放了）

---

## 作者：Albedo (赞：3)


## $ \texttt{Introduction} $

一道思维比较巧妙的 DP 题。

## $ \texttt{Description} $ 

问你有多少个排列组合满足题目中的条件，其中条件的格式为 $ i $ 必须在 $ j $ 的前面或后面。

## $ \texttt{Solution} $ 

###  DP 状态的设置

一个比较显然的思路应该是我们以一个数的排名来做 DP，即DP状态为 $ f[i][j] $ 表示 $ i $ 这个数排名为 $ j $ 时的方案数。

### DP 方程的建立

发现题目中的条件忽略方向后是一棵树。

对于一个数 $ i $ ，我们找到与其直接相关的数 $ j $ (当然 $ j $ 有很多个)，那么他们只会有两种情况

$ i $ 在 $ j $ 的前面---我们假设 $ i $ 的排名是 $ pi $，$ j $ 的排名是 $ pj $,显然 $ pi<pj $， 这时我们可以考虑枚举比 $ j $ 排名小的数中有多少个比 $ i $ 小的，设这个数为 $ pk $ ，那么这时 $ i $ 的排名变成了 $ pi+pk $ ,而这 $ pk $ 个数排名只要在 $ i $ 前面就行了，所以对于这 $ pk $ 个数，总共的排名方案为 $ C_{pi+pk-1}^{pk} $，我们发现 $ j $ 的排名序列中可能还有比 $ i $ 大的数，但我们怎么知道有多少个数比 $ i $ 大呢，其实很简单，我们发现图是一棵树，所以我们只要以 $ 1 $ 为根将他建成一棵有向树，然后比 $ j $ 先做的总共有 $ siz_j $ 个数，而已经有 $ pk $ 个数在 $ j $ 的前面了，那么还有 $ siz_j-pk $ 个数在 $ i $ 的后面，方案数的推导和上文一样。

所以可以得出转移方程式:
$$
f[x][pi+pk]=\sum_{pj=1}^{siz[a[i]]} \sum_{pk=0}^{pj-1} f[x][pi]\times f[a[i]][pj]\times C_{pi+pk-1}^{pk}\times C_{siz[x]-pi+siz[a[i]]-pk}^{siz[a[i]]-pk}
$$
$ i $ 在 $ j $ 的后面----推理过程同上，不再赘述。

### DP 的优化

我们发现上面的方程是 $ O(n^3) $ 的，因为还要枚举 $ pi $ ，所以一定会T，那怎么办呢，我们考虑用前缀和优化。

我们发现这个 $ pj $ 其实就只与 $ f[a[i]][pj] $ 有关，而且 $ pj $ 的取值是连续的，那我们为什么还要枚举 $ pj $ 呢，但是还有一个问题就是 $ pk $ 的取值是与 $ pj $ 有关的，那怎么办呢。

调换顺序不就好了，$ pk $ 要比 $ pj $ 小，那不就是 $ pj $ 要比 $ pk $ 大吗，然后这题就做好了。

## $ \texttt{code} $ 

```c++
#include<bits/stdc++.h>
using namespace std;
inline long long read()
{
  long long x=0,f=1;char ch=getchar();
  while(!isdigit(ch)&&ch!='-')ch=getchar();
  if(ch=='-')f=-1,ch=getchar();
  while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
  return x*f;
}
long long pow(long long x,long long y,long long p)
{
	long long ans=1;
	for (;y;y>>=1,x=x*x % p)
		if (y&1) ans=ans*x % p;
	return ans;
}
long long gcd(long long x,long long y)
{
	if (y==0) return x;
	long long ans=gcd(y,x % y);return ans;
}
//1:x在y的前面
//2:x在y的后面 
unsigned long long j,cnt,MOD,g[1010][1010],T,f[1010][1010],C[2010][2010],e[1010][1010],siz[101000],a[101000],b[101000],c[101000],d[101000],ans,n,i,x,y;
string dir;
void add(int x,int y,int z)
{
	cnt++;a[cnt]=y;b[cnt]=d[x];c[cnt]=z;d[x]=cnt;
}
void sc(int x,int fa)
{
	int i,p1,p2,p3;
	siz[x]=1;f[x][1]=1;
	for (i=d[x];i;i=b[i])
	     if (a[i]!=fa)
	         {
	         	sc(a[i],x);
	         	if (c[i]==1)
	         	    {
     	            	for (p1=1;p1<=siz[x]+siz[a[i]];p1++) e[x][p1]=0;
     	            	g[a[i]][siz[a[i]]]=f[a[i]][siz[a[i]]];g[a[i]][siz[a[i]]+1]=0;
     	            		for (p1=siz[a[i]]-1;p1>=1;p1--) g[a[i]][p1]=(g[a[i]][p1+1]+f[a[i]][p1]) % MOD;
	         	    	for (p1=siz[x];p1>=1;p1--)
	         	    	  for (p3=0;p3<=siz[a[i]]-1;p3++)
	         	    	       e[x][p1+p3]=(e[x][p1+p3]+f[x][p1]*g[a[i]][p3+1] % MOD*C[p1+p3-1][p3] % MOD*C[siz[x]-p1+siz[a[i]]-p3][siz[a[i]]-p3] % MOD) % MOD; 
					  }
     	        else 
     	            {
     	            	for (p1=1;p1<=siz[x]+siz[a[i]];p1++) e[x][p1]=0;
     	            	for (p1=1;p1<=siz[a[i]];p1++) g[a[i]][p1]=(g[a[i]][p1-1]+f[a[i]][p1]) % MOD;
     	            	for (p1=siz[x];p1>=1;p1--)
     	            	   for (p3=1;p3<=siz[a[i]];p3++)
     	            	        e[x][p1+p3]=(e[x][p1+p3]+f[x][p1]*g[a[i]][p3] % MOD*C[p1+p3-1][p3] % MOD*C[siz[x]-p1+siz[a[i]]-p3][siz[a[i]]-p3] % MOD) % MOD;
     	        for (p1=1;p1<=siz[x]+siz[a[i]];p1++) f[x][p1]=e[x][p1];
				siz[x]+=siz[a[i]];
			 }
}
int main()
{
	ios::sync_with_stdio(0);cin.tie();cout.tie();
	cin>>T;MOD=1e9+7;
	C[0][0]=1;
	for  (i=1;i<=2000;i++)
	     {
	     	C[i][0]=1;C[i][i]=1;
	     	for (j=1;j<i;j++)
	     	    C[i][j]=(C[i-1][j]+C[i-1][j-1]) % MOD;
		 }
	for (;T;T--)
	    {
	    	cin>>n;cnt=0;
	    	for (i=1;i<=n;i++) d[i]=0,siz[i]=0;
	    	for (i=1;i<n;i++)
	    	   {
	    	   	   cin>>x>>dir>>y;
	    	   	   x++;y++;
	    	   	   if (dir=="<") add(x,y,1),add(y,x,2);
	    	   	   else add(x,y,2),add(y,x,1);
			   }
			for (i=1;i<=n;i++)
			    for (j=1;j<=n;j++)
				      f[i][j]=0;  
			sc(1,0);
			ans=0;
			for (i=1;i<=n;i++) ans=(ans+f[1][i]) % MOD;
			printf("%llu\n",ans);
		}
   return 0;
}
```



---

## 作者：devout (赞：3)

> Welcome to SAO ( Strange and Abnormal Online)

**description**

给你一棵有向树，问这棵树的拓扑序的情况数。

**solution**

考虑树形dp，我们用 $f[u][i]$ 表示以 $u$ 为根的子树中，$u$ 的拓扑序排名为 $i$ 的方案数

考虑 $u$ 的新的一个子节点时，对于边的方向分类讨论，假设 $u$ 要在 $v$ 之后。

那么可以推出转移：

$$f[u][i+k]=\sum_{j\leq k} f[u][i]\times f[v][j]\times\binom{i+k-1}{i-1}\times\binom{siz_u+siz_v-i-k}{siz_u-i}$$

解释一下，$f[u][i+k]$ 要从 $f[u][i]$ 和 $f[v][j]$ 转移过来的话，那么以 $v$ 为根的子树中应该有 $k$ 个点拓扑序在 $u$ 之前，合并之后在 $u$ 前面有 $i-k-1$ 个位置，任意从中选出 $i-1$ 个放 $f[u][i]$ 中在 $i$ 之前的，剩下的放在 $v$ 子树中的，就是 $\binom{i+k-1}{i-1}$，相应的，放在 $u$ 之后的方案数就是 $\binom{siz_u+siz_v-i-k}{siz_u-i}$

这样朴素的转移是 $O(n^3)$ 的，观察发现我们每次的 $j$ 要满足 $j\leq k$，所以对于 $f[v][j]$ 求前缀和就可以把复杂度做到 $O(n^2)$ 了。

对于 $u$ 在 $v$ 之前的情况，类似的方法。

但是注意我们需要另外开一个数组来做转移，否则会被反复更新。

**code**

```
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=1005;
const int mod=1e9+7;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int t,n;
int head[N],cnt;
int siz[N];
int f[N][N],g[N],h[N];
int fac[N],inv[N];

struct Edge{
	int to,next,w;	
}e[N<<1];

void add(int x,int y,int c){
	e[++cnt]=(Edge){y,head[x],c},head[x]=cnt;	
}

int Qpow(int base,int ind){
	int res=1;
	while(ind){
		if(ind&1)res=1ll*res*base%mod;
		base=1ll*base*base%mod;
		ind>>=1;
	}
	return res;
}

int C(int n,int m){
	return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;	
}

void dfs(int u,int fa){
	siz[u]=1;
	f[u][1]=1;
	RepG(en,u){
		int v=e[en].to;
		if(v==fa)continue;
		dfs(v,u);
		Rep(i,1,siz[u]+siz[v])h[i]=0;
		if(e[en].w<0){
			g[0]=0;
			Rep(j,1,siz[v])(g[j]=g[j-1]+f[v][j])%=mod;
			Rep(i,1,siz[u])
				Rep(k,1,siz[v])
					(h[i+k]+=1ll*f[u][i]*g[k]%mod*C(i+k-1,i-1)%mod*C(siz[u]+siz[v]-i-k,siz[u]-i)%mod)%=mod;
		}
		else{
			g[siz[v]+1]=0;
			_Rep(j,siz[v],1)(g[j]=g[j+1]+f[v][j])%=mod;
			Rep(i,1,siz[u])
				Rep(k,0,siz[v])
					(h[i+k]+=1ll*f[u][i]*g[k+1]%mod*C(i+k-1,i-1)%mod*C(siz[u]+siz[v]-i-k,siz[u]-i)%mod)%=mod;
		}
		siz[u]+=siz[v];
		Rep(i,1,siz[u])f[u][i]=h[i];
	}
}

int main()
{
	read(t);
	fac[0]=inv[0]=1;
	Rep(i,1,1000)fac[i]=1ll*fac[i-1]*i%mod;
	Rep(i,1,1000)inv[i]=Qpow(fac[i],mod-2);	
	while(t--){
		memset(head,-1,sizeof(head)),cnt=0;
		memset(f,0,sizeof(f));
		read(n);
		Rep(i,1,n-1){
			int x,y;
			char opt[10];
			scanf("%d%s%d",&x,opt,&y);
			x++,y++;
			if(opt[0]=='<')add(x,y,1),add(y,x,-1);
			else add(x,y,-1),add(y,x,1);
		}
		dfs(1,0);
		int ans=0;
		Rep(i,1,n)(ans+=f[1][i])%=mod;
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：MCAdam (赞：3)

[P4099 [HEOI2013]SAO](https://www.luogu.com.cn/problem/P4099)

挺妙的一道题，需要灵活利用拓扑图的性质

题意：给定一个树形的有向图，问拓扑序的数量

$n\leq 1000$

如果只是普通的有向图，求拓扑序的数量是无法在多项式时间内解决的，所以这就提示我们要利用好“树”的这个特殊性质

然后想当然地设$f[p]$表示以$p$为根的子树拓扑序数量

但是这是一个“树形图”，但不是一棵树，观察样例就知道，每个节点有不止一个父亲

所以我们的定义既要融合树的性质，也要能满足拓扑图的限制

并且通常的树形DP是设一个随便指定一个根来跑，但这道题会有多个拓扑图的起点，在多个起点上开始DP然后合并答案貌似不太可行（要考虑重合部分）

不妨这样定义：设$f[p][i]$表示以$p$为根的子树中，$p$的排名为$i$的方案数

子树指的是所有的边都当做无向边形成的树，排名指的是$p$在$p$为根的子树的有向图中的拓扑序

那么显然要分开讨论$p$连出去和连向$p$的节点

如何转移呢？

## $q$连向$p$

先分析一下这些点的拓扑序：

1、如果$k$连向$q$，那么$k$一定在$p$前面

2、如果$q$连向其子树内的$k$，那么$k$和$p$的顺序可以任意，因为它们互相独立

那么不确定的状态就是$p$前面/后面到底有多少个$q$子树内的节点，因为这个一旦确定了，$q$的排名也就确定了，那就能够转移了

考虑直接枚举$q$子树中有多少个排在$p$的前面，注意这并不代表$q$在其子树内排名就是多少

为了避免互相转移，先转移到$g$后，再拷贝回$f$；并且$size[p]$表示在和并$q$之前的子树大小

那现在就相当于合并两个序列，设$p$在原来的序列中排名为$i_1$，$q$在原来的序列中排名为$j_1$，合并成新的序列后，排名分别为$i_2,j_2$，那么要满足：

- $j_2<i_2$

- 在$q$原来的序列中，排名为$[1,j_1]$都还要排在$p$的前面

- 在$q$原来的序列中，排名为$[j_1+1,size[q]]$可以排在$p$前面，或者在$p$的后面

那么在$p$在新序列中，前面的数量$x$满足：$i_1-1+j_1\leq x\leq i_1-1+size[q]$

也就是$i_1+j_1\leq i_2\leq i_1+size[q]$

那么转移：$\displaystyle g[p][i_2]=f[p][i_1]\times f[q][j_1]\times \binom{i_2-1}{i_1-1}\times \binom{size[p]+size[q]-i_2}{size[p]-i_1}$

后面那两个组合数是什么意思呢？首先$p$前面有$i_2-1$个数，其中有$i_1-1$个是来自$p$原来的序列（即原来$p$前面的，当然也可以写成$\displaystyle \binom{i_2-1}{j_2}$）。$f[p][i_1]\times f[q][j_1]$只考虑的是其合并前的排列的方案，乘上组合数给这$i_1-1$个数在新序列中安排位置

后面的就同理了，$p$后面有$size[p]+size[q]-i_2$个数，有$size[p]-i_1$个是来在原来$p$序列的

## $p$连向$q$

和上面几乎一样，只是两个组合数的意义交换过来了，但形式上还是一样的

不过此时$i_2$的范围就有了变化：$i_1\leq i_2\leq i_1+j_1-1$

## 优化

然后这样转移是$O(n^3)$的，注意到DP的式子，如果组合数全部统一用$i_1$，发现$j_1$和其他部分根本没有关系，用一个前缀和优化一下就好了

可以先写出暴力的DP转移式子，然后交换$j_1$和$i_2$的枚举顺序就没了，对$i_2$的区间限制就转移到了$j_1$上了

然后使用树形背包子树合并的技巧，时间复杂度就是$O(n^2)$的了

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#define ll long long
using namespace std;
const int N=1010;
const ll mod=1e9+7;
int tot;
int fir[N],size[N];
ll f[N][N],g[N],C[N][N];
struct edge
{
	int to;
	int dis;
	int nxt;
}e[2*N];
inline void add(int x,int y)
{
	e[++tot].to=y; e[tot].dis=1; e[tot].nxt=fir[x]; fir[x]=tot;
	e[++tot].to=x; e[tot].dis=0; e[tot].nxt=fir[y]; fir[y]=tot;
}
inline void dfs(int p,int fa)
{
	size[p]=f[p][1]=1;
	for(int i=fir[p];i;i=e[i].nxt)
	{
		int q=e[i].to;
		if(q==fa) continue;
		dfs(q,p);
		if(e[i].dis)
		{
			for(int i1=1;i1<=size[p];i1++)
				for(int i2=i1;i2<=i1+size[q]-1;i2++)//j [i2-i1+1,size[q]]
					(g[i2]+=f[p][i1]*(f[q][size[q]]-f[q][i2-i1]+mod)%mod*C[i2-1][i1-1]%mod*C[size[p]+size[q]-i2][size[p]-i1]%mod)%=mod;
			for(int j=1;j<=size[p]+size[q];j++) f[p][j]=g[j],g[j]=0;
		}
		else
		{
			for(int i1=1;i1<=size[p];i1++)
				for(int i2=i1+1;i2<=i1+size[q];i2++)// j[1,i2-i1]
					(g[i2]+=f[p][i1]*f[q][i2-i1]%mod*C[i2-1][i1-1]%mod*C[size[p]+size[q]-i2][size[p]-i1]%mod)%=mod;
			for(int j=1;j<=size[p]+size[q];j++) f[p][j]=g[j],g[j]=0;
		}
		size[p]+=size[q];
	}
	for(int i=1;i<=size[p];i++) (f[p][i]+=f[p][i-1])%=mod;
}
int main()
{
	for(int i=0;i<=1000;i++)
	{
		for(int j=1;j<i;j++)
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
		C[i][0]=C[i][i]=1;
	}
	int T;
	scanf("%d",&T);
	while(T--)
	{
		tot=0; memset(fir,0,sizeof(fir));
		int n,a,b; char ch[2]; 
		scanf("%d",&n);
		for(int i=1;i<n;i++)
		{
			scanf("%d%s%d",&a,ch,&b);
			a++,b++;
			if(ch[0]=='<') add(a,b);
			else add(b,a);
		}
		dfs(1,0);
		printf("%lld\n",f[1][n]);
	}
	return 0;
}
```


---

## 作者：Code_星云 (赞：1)

题目简意：有一颗树状 DAG，求其拓扑序数量。

先无视限制方向做，此时图为一棵树。又由于拓扑序是一个序列，因此我们设置状态 $f_{u,i}$ 表示在 $u$ 的子树中，$u$ 在该子树的拓扑序上的位置为 $i$。

然后考虑用其子树做刷表法。设起一个子节点的状态为 $f_{v,k}$，那么该子节点的贡献为 $f_{u,i}\  \times f_{v,k} \ \times V$，目标状态为 $f_{u,i+j}$，$V$ 表示转移时的组合贡献。（$j$ 后文提及）

此时添加对限制方向的考虑。若 $u$ 在 $v$ 的前面，且令 $j$ 表示在 $v$ 子树中选了 $j$ 个点在新拓扑序上放在 $u$ 的前面。那么此时的组合贡献 $V = C_{i + j -1} ^ {j}\times C_{size_u+size_v-i-j}^{size_v-j}$，意义即为在新拓扑序 $u$ 的前面（有 $i + j - 1$ 个数）选 $j$ 个放 $v$ 中的那些点，在 $u$ 的后面意义同理。
此时 $i,j$ 都需要枚举，且 $j$ 的范围是 $(0,k - 1)$，而由于

$\sum_{i = 1}^{size_u}\sum_{k = 1}^{size_v}\sum_{j = 0}^{k-1}$ 

$= \sum_{i = 1}^{size_u}\sum_{k = 1}^{size_v}\sum_{j = 0}^{size_v-1}[j<k]$ 

$= \sum_{i = 1}^{size_u}\sum_{j = 0}^{size_v-1}\sum_{k = 1}^{size_v}[k>j]$

$= \sum_{i = 1}^{size_u}\sum_{j = 0}^{size_v-1}pre_{size_v}-pre_{j}$

因此 $k$ 可以通过前缀和处理，总复杂度 $O(n^2)$。然后 $v$ 在 $u$ 后面的情况同理，只是 $j$ 的范围变到了 $(k,size_v)$，也可以这样处理。

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
#define int long long

int t;
const int N = 2005;
const int mod = 1e9 + 7;
struct edges{
	int to, next, w;
};
edges edge[2 * N];
int n, size[N], f[N][N], cnt = 0, head[N], g[N];

namespace math{
	int C[N][N];
	void init(){
		C[0][0] = 1;
		for(int i = 1; i <= N - 5; i ++){
		    C[i][0] = 1;
		    for(int j = 1; j <= i; j ++)
		        C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
		}
	}
};
using namespace math;

void dfs(int u, int fa){
	size[u] = 1; f[u][1] = 1;
	for(int i = head[u]; ~ i; i = edge[i].next){
		int v = edge[i].to, w = edge[i].w;
		if(v == fa) continue;
		dfs(v, u);
		for(int i = 1; i <= size[u]; i ++){
			g[i] = f[u][i];
			f[u][i] = 0;
		}
		if(w){
			for(int i = 1; i <= size[u]; i ++)
			  for(int j = 0; j < size[v]; j ++)
			    f[u][i + j] = (f[u][i + j] + C[i + j - 1][j] * C[size[u] + size[v] - i - j][size[v] - j] % mod * g[i] % mod * (f[v][size[v]] - f[v][j] + mod) % mod) % mod;
		}else{
			for(int i = 1; i <= size[u]; i ++)
			  for(int j = 1; j <= size[v]; j ++)
			    f[u][i + j] = (f[u][i + j] + C[i + j - 1][j] * C[size[u] + size[v] - i - j][size[v] - j] % mod * g[i] % mod * f[v][j] % mod) % mod;
		}
		size[u] += size[v];
	}
	for(int i = 1; i <= size[u]; i ++) f[u][i] = (f[u][i - 1] + f[u][i]) % mod;
}
void add_edge(int u, int v, int w){
	edge[++ cnt].to = v;
	edge[cnt].next = head[u];
	edge[cnt].w = w;
	head[u] = cnt;
}
void work(){
	memset(head, -1, sizeof head);
	scanf("%lld", &n);
	for(int i = 1; i < n; i ++){
		int u, v; char c; 
		cin >> u >> c >> v; 
		u ++; v ++;
		add_edge(u, v, c == '<');
		add_edge(v, u, c == '>');
	}
	dfs(1, 0);
	printf("%lld\n", f[1][n]);
	memset(f, 0, sizeof f);
	memset(size, 0, sizeof size);
	cnt = 0;
}
signed main(){
	init();
	scanf("%lld", &t);
	while(t --) work();
	return 0;
}
```


---

## 作者：St_john (赞：0)

# [P4099 [HEOI2013]SAO](https://www.luogu.com.cn/problem/P4099)

设 $f_{i,j}$ 表示 $i$ 在以 $i$ 为根的子树中，拓扑序排名为 $j$ 的方案数。  

两个节点 $x,y$ 之间如何合并呢？  
不妨设 $p_1$ 为加 $y$ 之前 $x$ 的排名，$p_2$ 为加 $y$ 之后 $x$ 的排名，$p_3$ 为加 $y$ 之前 $y$ 的排名，$p_4$ 为加 $y$ 之后 $y$ 的排名。  

这里的 $siz_x,siz_y$ 表示 $x,y$ 的子树大小。  
$siz_x$ 为加 $y$ 之前的。  

分类讨论：
1. $x$ 的排名在 $y$ 前。  

显然 $p_1\in[1,siz_x]$，由于 $x$ 的排名在 $y$ 前，$p_2$ 不会比 $p_1$ 小，所以 $p_2\in[p_1,p_1+siz_y)$。  
所以 $(p_1,p_2)$ 之间多出来的点都是要用 $y$ 子树中的点去补的。  


接下来讨论转移。  
由于 $p_1$ 是基于加了 $y$ 之前的，所以在 $p_2$ 左边要有 $p_1-1$ 个数同样来自加了 $y$ 之前的 $x$ 的子树，所以要乘组合数 $\binom{p_2-1}{p_1-1}$。  
既然 $p_1-1$ 都在左边，$p_1$ 变成 $p_2$ 了，那么 $siz_x-p1$ 要在 $p_2$ 右边了，右边的也要乘组合数 $\binom{siz_x+siz_y-p_2}{siz_x-p_1}$。  

接下来讨论一下 $p_3$ 的情况。  
由于上面的分析，$y$ 一定不会 $x$ 之前，$p_2$ 左边要有 $p_2-p_1$ 个数来自 $y$ 的子树，所以 $y$ 的排名范围为 $[p_2-p_1+1,siz_y]$。  
这里考虑前缀和优化。  

2. $x$ 的排名在 $y$ 后。

显然 $p_1\in[1,siz_x]$，由于 $y$ 的排名在 $x$ 的前，$p_2>p_1$，所以 $p_2\in(p_1,p_1+siz_y]$。  

转移的组合数就和上面一样。  

接下来分析 $p_3$ 的情况。  
由于上面的分析，$y$ 一定在 $x$ 前，$p_2$ 左边有 $p_2-p_1$ 个数来自 $y$ 的子树，所以 $y$ 的排名范围为 $[1,p_2-p_1]$。  

预处理一下组合数和前缀和，这道题就结束了。  


```cpp
#include<cstdio>
#include<cstring>
using namespace std;
typedef long long ll;
#define  il inline
#define pc putchar
#define Re register int
#define _for(i,a,b) for(register int i=(a);i<=(b);++i)
#define __for(i,a,b) for(register int i=(a);i>=(b);--i)
il int re(){
	int x=0;
	char ch=getchar();
	bool f=0;
	while(ch<'0'||ch>'9')
		f|=(ch=='-'),ch=getchar();
	while(ch>='0'&&ch<='9')
		x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return f?-x:x;
}
void pr(int x){
	if(x<0) x=-x,pc('-');
	if(x>9) pr(x/10);
	pc(x%10|48);
}
const int A=1e3+10,B=A<<1,mod=1e9+7;
int head[A],cnt;
struct Edge{
	int t,n,w;
}edge[B];
il void add_edge(int u,int v,int w){
	edge[++cnt]=(Edge){v,head[u],w};head[u]=cnt;
}
int n;
int f[A][A],g[A];
int fac[A],ifac[A],siz[A];
il int calc1(int a,int b){
	return a+b>=mod?a+b-mod:a+b;
}
il int calc2(int a,int b){
	return a-b<0?a-b+mod:a-b;
}
il int binom(int n,int m){
	if(n<m) return 0;
	return (ll)fac[n]*ifac[m]%mod*ifac[n-m]%mod;
}
il int pow(int a,int b){
	int c=1;
	while(b){
		if(b&1) c=(ll)c*a%mod;
		a=(ll)a*a%mod;
		b>>=1;
	}
	return c;
}
void dfs(int x,int fa){
	f[x][1]=1;
	siz[x]=1;
	for(Re i=head[x],y;i;i=edge[i].n){
		y=edge[i].t;
		if(y!=fa){
			dfs(y,x);
			memcpy(g,f[x],sizeof(g));
			memset(f[x],0,sizeof(f[x]));
			if(edge[i].w){//x->y
				_for(p1,1,siz[x])
					for(Re p2=p1;p2<p1+siz[y];++p2)
						f[x][p2]=calc1(f[x][p2],(ll)binom(p2-1,p1-1)*binom(siz[x]+siz[y]-p2,siz[x]-p1)%mod*
						g[p1]%mod*calc2(f[y][siz[y]],f[y][p2-p1])%mod);
				
			}
			else{//x<-y
				_for(p1,1,siz[x])
					_for(p2,p1+1,p1+siz[y])
						f[x][p2]=calc1(f[x][p2],(ll)binom(p2-1,p1-1)*binom(siz[x]+siz[y]-p2,siz[x]-p1)%mod*
						g[p1]%mod*f[y][p2-p1]%mod);
			}
			siz[x]+=siz[y];
		}
	}
	_for(i,1,siz[x])
		f[x][i]=calc1(f[x][i],f[x][i-1]);
}
signed main(){
	fac[0]=ifac[0]=1;
	_for(i,1,1000)
		fac[i]=(ll)fac[i-1]*i%mod;
	ifac[1000]=pow(fac[1000],mod-2);
	__for(i,1000-1,1)
		ifac[i]=(ll)ifac[i+1]*(i+1)%mod;
	
	__for(_,re(),1){
		memset(f,0,sizeof(f));
		cnt=0;
		memset(head,0,sizeof(head));
		memset(siz,0,sizeof(siz));
		
		n=re();
		_for(i,2,n){
			int x=re();
			char op[10];
			scanf("%s",op);
			int y=re();
			add_edge(x,y,op[0]=='<');
			add_edge(y,x,op[0]=='>');
		}
		dfs(0,-1);
		pr(f[0][n]),pc('\n');
	}
	return 0;
}
```


---

## 作者：Diwanul (赞：0)

# 题意

给定一棵树，边有方向。要给点重标号，使得边都由小编号指向大编号，求重标号方案数。

$n\le10^3$

# 思路

有关树的计数。套路性考虑树形 DP。

设计状态 $f_{u}$ 表示 $u$ 的子树的合法重标号方案数。如何转移？发现不好转移。

考虑什么情况下可以转移呢？发现转移是合并当前 $u$ 子树中已经考虑了部分的状态和其某还未考虑的儿子 $v$ 的子树的状态，而转移合法只要保证 $u$ 和 $v$ 在重标号中相对大小关系符合边上的限制。那么我们考虑改状态为 $f_{u,i}$ 表示 $u$ 的子树重标号且 $u$ 的新编号为 $i$ 的方案数。如何转移？

大于和小于的情况是对称的，所以我们只讨论 $u$ 的新编号要小于 $v$ 的情况，另一种情况的转移类似。我们考虑状态 $f_{u,i}$ 能转移到什么状态。考虑在新的重标号方案中，在 $v$ 的子树中拿 $j$ 个点标上小于 $i+j$ 的编号，$u$ 标上编号 $i+j$，那么考虑转移方程中需要哪些系数呢？首先，考虑 $f_{u,i}$ 能与哪些 $f_{v,k}$ 合并得到新的状态，发现 $v$ 子树中前新编号前 $j$ 小的点都拥有小于 $i$ 的新编号，而 $v$ 的新编号不能小于 $u$，所以要保证 $k>j$，也就说这次转移中合法的 $v$ 的子树重编号方案数是 $\sum\limits_{k=j+1}^{siz_v}f_{v,k}$。其他系数？要在 $i+j-1$ 个新编号小于 $i+j$ 的点中选 $j$ 个点来自 $v$ 的子树，这里需要乘上 $\binom{i+j-1}{j}$。新编号大于 $i+j$ 的同理，乘上 $\binom{siz_u+siz_v-i-j}{siz_v-j}$。总的式子就是 $f_{u,i+j}+=\binom{i+j-1}{j}\binom{siz_u+siz_v-i-j}{siz_v-j}f_{u,i}\sum\limits_{k=j+1}^{siz_v}f_{v,k}$。发现前缀和可以优化掉那个 $\sum$。统计答案就是 $\sum\limits_{i=1}^nf_{1,i}$。

计算一下复杂度，看似是 $O(n^3)$？每次合并复杂度为 $siz_u\times siz_v$，这与树形背包是一样的复杂度，所以总复杂度应该是 $O(n^2)$。可以理解为 $u$ 子树中已考虑的每个点和 $v$ 子树中每个点都 $O(1)$ 计算一次，发现每对点都只会在其 LCA 处计算一次，所以总复杂度是点对数即 $O(n^2)$。

# 实现

```cpp
void DP(int u,int fa){
	sz[u]=1;
	for(int i=1;i<=n;++i)
		f[u][i]=0;
	f[u][1]=1;
	for(int ie=head[u],v=e[ie].t;ie;ie=e[ie].n,v=e[ie].t)
		if(v!=fa){
			DP(v,u);
			for(int i=1;i<=sz[u]+sz[v];++i)
				tmp[i]=0;
			if(e[ie].op)
				for(int i=1;i<=sz[u];++i)
					for(int j=1;j<=sz[v];++j)
						MAdd(tmp[i+j-1],Mul(Mul(Add(g[v][sz[v]],MOD-g[v][j-1]),f[u][i]),Mul(C(i+j-2,j-1),C(sz[u]-i+sz[v]-j+1,sz[v]-j+1))));
			else
				for(int i=1;i<=sz[u];++i)
					for(int j=1;j<=sz[v];++j)
						MAdd(tmp[i+j],Mul(Mul(g[v][j],f[u][i]),Mul(C(i+j-1,j),C(sz[u]-i+sz[v]-j,sz[v]-j))));
			sz[u]+=sz[v];
			for(int i=1;i<=sz[u];++i)
				f[u][i]=tmp[i];
		}
	for(int i=1;i<=sz[u];++i)
		g[u][i]=Add(g[u][i-1],f[u][i]);
}
```



---

## 作者：MoonPie (赞：0)

# [HEOI2013]SAO

[$\mathfrak{LINK}$ ](https://www.luogu.com.cn/problem/P4099)

## 题意

给你一棵有向树，求这棵树的拓扑序数量（$n\le 1000$）

## 题解

设 $dp(u,i)$ 表示 $u$ 子树中，有 $i$ 个点在点 $u$ 之前的拓扑序数量。对于 $v \in son(u)$ 的转移分两种情况讨论：

如果是 $u$ 指向 $v$，那么对于 $v$ 子树中的所有结点，在 $v$ 前的一定比在 $u$ 前的要少（因为 $u$ 一定排在 $v$ 前，而在 $v$ 之前的点可以在 $u$ 之前）。我们先枚举 $v$ 子树中有 $k$ 个排在 $u$ 之前，然后再枚举有 $p$ 个排在 $v$ 之前就得到转移方程如下：

$$
dp(u,j+k) += \sum_{j=0}^{siz(u)-1}\sum_{k=0}^{siz(v)-1}\sum_{p=k}^{sz(v)-1} dp(u,j)\times dp(v,p)\times \binom{j+k}{k}\binom{siz(u)+siz(v)-j-k-1}{siz(v)-k}
$$

后面两个组合数是因为点标号各不相同，需要在 $u$ 前面选出 $k$ 个空位来放 $u$ 子树中的结点，其余的放 $v$ 子树的；$u$ 后面也是同理。

这个式子用前缀和优化就可以做到 $O(n^2)$，另一种情况同理可得。

这里需要$\text{\color{red}注意}$的是：

不需要重新计算从 $u$ 子树中选出 $j$ 个、$v$ 子树中选出 $k$ 个放在前面的方案数！因为我们记录的数字是**排列**的个数，合并后还是排列的个数，是本身有序的，只需去最前面的几个就可以了。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1005, mod = 1e9+7;
struct edge { int to,w; };
vector<edge> g[N];
int T,n,sz[N];
ll dp[N][N],t[N],suf[N],pre[N],pi[N],iv[N];
 
int qpow(int x,int y)
{
  int res = 1;
  for (int i = 0; (1<<i) <= y; ++i, x = 1ll * x * x % mod)
    if (y>>i&1) res = 1ll * res * x % mod;
  return res;
}
 
int C(int n,int m)
{
  if (m < 0 || m > n) return 0;
  return pi[n] * iv[m] % mod * iv[n-m] % mod;
}
 
void init(int n)
{
  pi[0] = 1;
  for (int i = 1; i <= n; ++i) pi[i] = pi[i-1] * i % mod;
  iv[n] = qpow(pi[n],mod-2);
  for (int i = n-1; i >= 0; --i) iv[i] = iv[i+1] * (i+1) % mod;
}
 
 
void dfs(int u,int fa)
{
  sz[u] = dp[u][0] = 1;
 
  for (int i = 0 ; i < (int)g[u].size(); ++i)
  {
    int v = g[u][i].to, w = g[u][i].w;
    if (v == fa) continue;
    dfs(v,u);
     
    memcpy(t,dp[u],sizeof(t));
    memset(dp[u],0,sizeof(dp[u]));
    memcpy(suf,dp[v],sizeof(dp[v]));
    memcpy(pre,dp[v],sizeof(dp[v]));
    for (int j = sz[v]; j >= 0; --j) suf[j] = (suf[j] + suf[j+1]) % mod;
    for (int j = 1; j <= sz[v]; ++j) pre[j] = (pre[j] + pre[j-1]) % mod;
 
    if (w == 1)
    {
      for (int j = 0; j < sz[u]; ++j)
        for (int k = 0; k < sz[v]; ++k)
        dp[u][j+k] += t[j]*C(j+k,k)%mod*C(sz[u]+sz[v]-j-k-1,sz[v]-k)%mod*suf[k]%mod,
        dp[u][j+k] %= mod;
    }
 
    else
    {
      for (int j = 0; j < sz[u]; ++j)
        for (int k = 1; k <= sz[v]; ++k)
        {
          dp[u][j+k] += t[j]*C(j+k,j)%mod*C(sz[u]+sz[v]-j-k-1,sz[u]-j-1)%mod*pre[k-1]%mod;
          dp[u][j+k] %= mod;
        }
    }
     
    sz[u] += sz[v];
  }
}
 
void rmain()
{
  init(1000);
  cin >> n;
  for (int i = 1; i <= n; ++i) g[i].clear();
  int u,v; string s;
  for (int i = 1; i < n; ++i) {
    cin >> u >> s >> v; u++; v++;
    if (s[0] == '<') g[u].push_back(edge{v,1}), g[v].push_back(edge{u,0});
    if (s[0] == '>') g[u].push_back(edge{v,0}), g[v].push_back(edge{u,1});
  }
 
  memset(dp,0,sizeof(dp));
  dfs(1,0);
 
  ll ans = 0;
  for (int i = 0; i < n; ++i) ans = (ans + dp[1][i]) % mod;
  cout << ans << endl;
}
int main()
{
  cin >> T;
  while(T--) {
    rmain();
  }
   
  return 0;
}
```

---

## 作者：哈撒各一 (赞：0)

~~这道题~~我是真的~~难~~蒻。

首先我们看到题目中的 $n-1$ 条边，应该很显然的想到树形DP。

由于我们树上的两个点之间是有相对关系的所以我们必须记录这种相对关系。

```cpp
struct Edge{
	int ne,to,kind;
}
inline void add(int from,int to,int kind){
	ne(++idx)=head[from];
	to(idx)=to;
	kind(idx)=kind;
	head[from]=++idx;
}
```

那么我们对于树形DP有一个模板状态表示：

**$f_i$ ：表示在 $i$ 点的子树中**

那么我们顺着这个模板考虑，然而我们发现题目要求我们求得是方案数，就是说选择数相同，顺序不同也是不同的方案，然而这个状态表示并不能表示出我们选择 $i$ 这个点的位置。

因为我们要用$C^n_m$来求方案数（因为我们只需要知道有 $m$ 个点在 $i$ 前，要挑战 $i$ 有 $n$ 个前置关卡，其内部排序在计算 $i$ 的情况时无关），必须要知道这个 $i$ 点的位置。

因此我们决定在开一维表示在 $i$ 点的子树中我们第 $j$ 个位置选 $i$ 。

而且我们通过观察发现，一个子树外的点对于子树内的排列顺序是不关心的，因为对于这个子树外的点来说，子树内的点只有两个状态：1.在我之前。2.在我之后。

那么我们的这个状态转移方程就已经可以表示完所有的状态。

因此，这个DP的状态表示就是$f_{i,j}$第i个点处于他的子树的拓扑序的第j个位置。

---

接下来就要思考状态转移方程：

因为我们已经确定了这道题是树形DP，那么我们就按照树形DP的常规方法，DFS序，通过一个树的子树的状态合并出一颗大树的状态。

那么我们接下来就会发现对于我们定义的状态表示，每一个叶子节点都只有一个值：$f_{u,1}=1$ 。

那么这样就更加坚定了我们对于这个算法正确性的信心。

那么我们就可以对于一个子树的根节点 $u$ ，取出一个子节点 $y$ 进行讨论。

因为 $u$ 是 $y$ 的父节点，那么不论子树 $u$ 的拓扑序怎么变化， $u$ 都会在 $y$ 的前面。我们就可以将这个过程看做把y子树序列合并入u子树序列的过程，那么我们令 $u$ 合并前后的位置为 $u_1$ ，$u_2$ ，$y$ 合并前后的位置为 $y_1$ ，$y_2$ 。

那么我们就可以发现在$u_2$之前有$u_2-1$个元素，有$u_1-1$个元素是原来就在u前面的，那么u前面的情况数就是$C_{u_2-1}^{u_1-1}$。

同理，u后面就有$size_u+size_y-u_2$个元素，其中有$size_u-u_1$个是原来就在u后面的，所以u后面的情况数就是$C_{size_u+size_y-u_2}^{size_u-u_1}$。

那么我们对于 $u$ ，$y$ 的相对位置情况就考虑完毕了，但是 $u$ ，$y$ 内部的排列顺序对于情况数也是有影响的，但是他们的内部排列数已经求好了，直接调用即可。

所以状态转移就是：

$f_{u,u_2}+=C_{u_2-1}^{u_1-1} \times C_{size_u+size_y-u_2}^{size_u-u_1} \times f_{u,u_1} \times f_{y,y_1}$。

但是我们发现这个式子可以提取公因式，应为我们在枚举$y_1$的时候前面的式子的值都是不会变化的，所以我们可以吧范围内的所有$f_{y,y_1}$的和计算出来在一起乘上前面的式子，但是我们在统计和的时候就会产生大量的重复计算，我们就理所应当的想到前缀和优化。

那么我们枚举$y_1$的范围是很容易求出来的，因为我们必须在 $u$ ，$y$ 前后的数量都已经确定了，我们只需要用剩下的可以活动的部分取极限就可以了。

$u_2-u_1<y_1<=size_y$

**CODE**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1010
#define mod 1000000007
struct Edge{
	int ne,to,ki;
	#define ne(x) edge[x].ne
	#define to(x) edge[x].to
	#define ki(x) edge[x].ki
}edge[N<<1];
int head[N],idx=1,T,n,a,b;
int f[N][N],C[N][N],cf[N],size[N];
char op;
inline void init(){
	memset(head,0,sizeof(head));
	memset(size,0,sizeof(size));
	idx=1;
}
inline void add(int from,int to,int ki){
	ne(++idx)=head[from];
	to(idx)=to;
	ki(idx)=ki;
	head[from]=idx;
}
void dfs(int u){
	size[u]=1;f[u][1]=1;
	for(int i=head[u];i;i=ne(i)){
		int y=to(i);
		if(size[y])continue;
		dfs(y);
		memcpy(cf,f[u],sizeof(cf));
		memset(f[u],0,sizeof(f[u]));
		if(ki(i)==1){
			for(int p1=1;p1<=size[u];++p1){
				for(int p2=p1;p2<p1+size[y];++p2){
					f[u][p2]=(f[u][p2]+1ll*C[p2-1][p1-1]*C[size[u]+size[y]-p2][size[u]-p1]%mod*cf[p1]%mod*(f[y][size[y]]-f[y][p2-p1]+mod))%mod;
				}
			}
		}else{
			for(int p1=1;p1<=size[u];++p1){
				for(int p2=p1+1;p2<=p1+size[y];++p2){
					f[u][p2]=(f[u][p2]+1ll*C[p2-1][p1-1]*C[size[u]+size[y]-p2][size[u]-p1]%mod*cf[p1]%mod*f[y][p2-p1])%mod;
				}
			}	
		}
		size[u]+=size[y];
	}
	for(int i=1;i<=size[u];++i){
		f[u][i]=(f[u][i]+f[u][i-1])%mod;
	}
}
int main(){
	cin>>T;
	C[0][0]=1;
	for(int i=1;i<=1000;++i){
		C[i][0]=1;
		for(int j=1;j<=i;++j){
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
		}
	}
	while(T--){
		init();
		cin>>n;
		for(int i=1;i<n;++i){
			scanf("%d %c %d",&a,&op,&b);
			a++;b++;
			if(op=='<'){
				add(a,b,1);
				add(b,a,0);
			}else{
				add(b,a,1);
				add(a,b,0);
			}
		}
		dfs(1);
		printf("%d\n",f[1][n]);
	}
	return 0;
}
```


---


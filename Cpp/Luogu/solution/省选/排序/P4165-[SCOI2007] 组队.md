# [SCOI2007] 组队

## 题目描述

NBA每年都有球员选秀环节。通常用速度和身高两项数据来衡量一个篮球运动员的基本素质。假如一支球队里速度最慢的球员速度为minV，身高最矮的球员高度为minH，那么这支球队的所有队员都应该满足: A × ( height – minH ) + B × ( speed – minV ) <= C 其中A和B，C为给定的经验值。这个式子很容易理解，如果一个球队的球员速度和身高差距太大，会造成配合的不协调。

请问作为球队管理层的你，在N名选秀球员中，最多能有多少名符合条件的候选球员。


## 说明/提示

数据范围： N <= 5000 ,height和speed不大于10000。A、B、C在长整型以内。



## 样例 #1

### 输入

```
4 1 2 10
5 1
3 2
2 3
2 1```

### 输出

```
4```

# 题解

## 作者：DDOSvoid (赞：12)

令 $H$ 代表 $minh$，$V$ 代表 $minv$

考虑满足条件的队员应满足 3 个条件：

1. $A*h+B*v\le C+A*H+B*V$
2. $h\ge H$
3. $v\ge V$

考虑如果满足 1 和 3，则能得出 4. $h \le \frac{C}{A}+H$

但是根据 1 和 4 或 3 和 4，却不能推出 3 或 1，所以这段好像没啥用？

令 $s$ 表示 $A*h+B*v$

考虑外层枚举 $H$，内层枚举 $V$，将数组按照 $s$ 排序，那么满足第一个条件的位置会随着内层的枚举递增。

当然只有第一个条件是不够的，考虑如何增加其他的条件，因为外层枚举是固定的，所以显然可以在统计的答案的时候遵守限制 2。考虑满足第三个限制。如果只是简单的满足的话（如下

```cpp
for(int i = 1; i <= n; ++i){ // H
        int r = 0, cnt = 0;
		for(int j = 1; j <= n; ++j){ // V
        	while(r < n && a3[r + 1].s <= A * a1[i].h + B * a2[j].v)
        		++r, cnt += (a3[r].h >= a1[i].h && a3[r].v >= a2[j].v);
        	// del 
		}
    }
```

那么随着 j 的增加，我们的删除是 $O(n)$

考虑如何做到 $O(1)$ 的删除，考虑刚才推出的性质 4，如果满足 1 和 4 的话，的确没法推出 $v\ge V$，但是如果性质 4（$h \le \frac{C}{A}+H$ 存在的话，假设此时 $v<V$ 那么，我们能得到 $A*h+B*v\le A*H+B*V+C$

这有什么用呢？考虑在统计的时候并不一定满足性质 1、2、3 的答案，而是只满足 1 和 2 还有 4 的答案，然后再将多余的减掉，我们发现减的过程是单调的（如下

```cpp
for(int i = 1; i <= n; ++i){ // h
        int l1 = 0, l2 = 0, cnt = 0;
        int Min = a1[i].h, Max = a1[i].h + C / A;	
        for(int j = 1; j <= n; ++j){ // v
            while(l2 < n && a3[l2 + 1].s <= C + A * a1[i].h + B * a2[j].v)
                ++l2, cnt += (a3[l2].h >= Min && a3[l2].h <= Max);
            while(l1 < n && a2[l1 + 1].v < a2[j].v)
                ++l1, cnt -= (a2[l1].h >= Min && a2[l1].h <= Max);	
            ans = max(ans, cnt);
        }
    }
```

~~可以发现这样是对的~~。另外，再删除过程中是不会删除没加入的点的。

证明如下：

首先，它被删除了，说明他满足不等式 $a2[l1].h >= Min$ 和 $a2[l1].h <= Max$，即 $A*h\le A*H+C$ 且 $h\ge H$。我们知道他没有被添加，说明 $A*h+B*v>A*H+B*V+C$，解得 $v>V$，但 $a2[l1 + 1].v < a2[j].v$

并且也不会漏删加入的点（这个非常显然

并且在固定 i 和 j 之后，应该要被删除的点一定会在这次被删除，

分两种情况讨论：

1 应该删除的点在之后才被删除

证明：首先，它在这次被加入了，说明 $A*h+B*v\le C+A*H+B*V$，并且 $h \le \frac{C}{A}+H$。它应该被删除，说明 $v<V$，那么肯定会在现在被删除

2 应该删除的点在之前被删除了

证明：它被删除了，说明 $h \le \frac{C}{A}+H$，且 $v<V$，这个 $V$ 是当时枚举的，那么在当时就有 $A*h+B*v\le C+A*H+B*V$，所以在当时就会被加入

所以删除满足单调性，所以，应该就没了。贴一下 AC 代码。

如有不严谨的地方，请指出

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define maxn 5010
using namespace std;

int A, B, C, n, m;

struct node{
    int h, v, s;	
}a1[maxn], a2[maxn], a3[maxn];

inline bool cmp1(node x, node y){return x.h < y.h;}
inline bool cmp2(node x, node y){return x.v < y.v;}
inline bool cmp3(node x, node y){return x.s < y.s;}

int ans;
int main(){
    scanf("%d%d%d%d", &n, &A, &B, &C);
    for(int i = 1; i <= n; ++i){
        scanf("%d%d", &a1[i].h, &a1[i].v);
        a1[i].s = A * a1[i].h + B * a1[i].v;
        a3[i] = a2[i] = a1[i];
    }
    //sort(a1 + 1, a1 + n + 1, cmp1); 
    sort(a2 + 1, a2 + n + 1, cmp2);
    sort(a3 + 1, a3 + n + 1, cmp3);
    for(int i = 1; i <= n; ++i){ // h
        int l1 = 0, l2 = 0, cnt = 0;
        int Min = a1[i].h, Max = a1[i].h + C / A;	
        for(int j = 1; j <= n; ++j){ // v
            while(l2 < n && a3[l2 + 1].s <= C + A * a1[i].h + B * a2[j].v)
                ++l2, cnt += (a3[l2].h >= Min && a3[l2].h <= Max);
            while(l1 < n && a2[l1 + 1].v < a2[j].v)
                ++l1, cnt -= (a2[l1].h >= Min && a2[l1].h <= Max);	
            ans = max(ans, cnt);
        }
    }
    cout << ans;
    return 0; 
}
```

---

## 作者：pigstd (赞：10)

我们很容易得到一个时间复杂度为 $O(n^{3})$ 的方法：枚举$\min v$和$\min h$,然后把所有球员枚举一边，统计可不可以。

那么，如果我们先枚举 $\min h$ ,然后我们可以可以通过这个不等式： 

$A$ $\times$ ( $h$ $-$ $\min h$ )+ $B$ $\times$ ( $v$ $-$ $\min v$ ) $\le$ $C$

得到：   

$\min v$ $\ge$ ( $C$ $-$ $A$ $\times$ ( $h$ - $\min h$ ))/ $B$ ) 

然后算出每一个球员在 $\min h$ 确定的情况下，$\min v$ 在哪一个范围的时候，这个球员可以被选中。

然后我们只要通过差分，然后枚举每一个 $v$ 找到最大值就可以了。

其余的注释在代码里：（还有，我在代码中把速度用 $s$ 来表示速度）
```
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int M=5005;
int n,A,B,C,h[M],hh[M],s[M],hs=1,ans=1;
int cnt[M*2],smax;

signed main()
{
	cin>>n>>A>>B>>C;
	for (int i=1;i<=n;i++)
		cin>>h[i]>>s[i],smax=max(smax,s[i]),hh[i]=h[i];
	sort(hh+1,hh+1+n);
	for (int i=2;i<=n;i++)
		if (hh[i]!=hh[i-1])
			hh[++hs]=hh[i];//这一步是把h排序并去重
	for (int i=1;i<=hs;i++)
	{
		memset(cnt,0,sizeof(cnt));
		for (int j=1;j<=n;j++)
		{
			if (h[j]>=hh[i]&&(A*(h[j]-hh[i]))<=C)
			{
				int tl;
				if (B==0)
					tl=1;
				else
					tl=max(1ll,s[j]-(C-A*(h[j]-hh[i]))/B);
				//这说明第j个数当Smin在tl~s[j]中时这个球员都可以被入选 
				cnt[tl]++,cnt[s[j]+1]--;//差分，做了前缀和之后就相当于把tl~s[j]的数值+1 
			}
		}
		for (int j=2;j<=smax;j++)
			cnt[j]+=cnt[j-1];//做前缀和
		for (int j=1;j<=n;j++)
			ans=max(ans,cnt[s[j]]);//统计答案
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：zsq147258369 (赞：6)

~~考试时 DS 写挂了，导致保龄。。~~

看到有 $\min$ 以及只有 $5000$ 的 $N$，可以自然的想到枚举最小值来求答案。

假设我们枚举的 $minH$ 是 $i$，$minV$ 是 $j$ （注意   $height_i\le height_j,speed_j\le speed_i$），那么如果有一个 $k$ 可以被选入，则它满足一下条件：

* $speed_j\le speed_k$
* $height_i\le height_k$
* $A(height_k-height_i)+B(speed_k-speed_j)\le C$

我们尝试把第三个化简一下：

$$A*height_k+B*speed_k-A*speed_i-B*speed
_j\le C$$

$$A*height_k+B*speed_k\le C+A*speed_i+B*speed
_j$$

可以看到，后面值已经确定，前面的值只与 $k$ 有关。

把三个限定条件摆到一起：这不就是 [三维偏序](https://www.luogu.com.cn/problem/P3810) 吗？剩下的都是板子。写什么都行，可就我写的是线段树套线段树，跑得贼慢。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e3+350,M=1e4,I=1e6+500;

struct node
{
	int h,s;
	
	friend bool operator<(node a,node b)
	{
		return a.h==b.h?a.s>b.s:a.h<b.h;
	}
}a[N];

int n,ans,jk,tot,ls[I],rs[I],val[I];
int A,B,C,re[N],o[N];
map<int,int>mp;

class tree_and_tree
{
	public:
		int ro;
		
		#define mid ((l+r)>>1)
		
		void pre(int&x){x=++tot;}
		
		void insert(int x,int l,int r,int t)
		{
			val[x]++;
			if(l==r)return;
			if(!ls[x])pre(ls[x]);
			if(!rs[x])pre(rs[x]);
			if(t<=mid)insert(ls[x],l,mid,t);
			else insert(rs[x],mid+1,r,t);
			return;
		}
		
		int query(int x,int l,int r,int L,int R)
		{
			if(L>R)return 0;
			if(!x)return 0;
			if(L<=l&&R>=r)return val[x];
			int ans=0;
			if(L<=mid)ans+=query(ls[x],l,mid,L,R);
			if(R>mid)ans+=query(rs[x],mid+1,r,L,R);
			return ans;
		}
}t[M<<3];

int find(int x,int l,int r,int L,int R,int y)
{
	if(L<=l&&R>=r)return t[x].query(t[x].ro,1,jk,1,y);
	int tmid=(l+r)>>1,ans=0;
	if(L<=tmid)ans+=find(x<<1,l,tmid,L,R,y);
	if(R>tmid)ans+=find(x<<1|1,tmid+1,r,L,R,y);
	return ans;
}

int get(int mins,int mxre)
{
	int l=upper_bound(o+1,o+1+jk,mxre)-o-1;
	return find(1,1,M,mins,M,l);
}

void insert(int x,int l,int r,int a,int b)
{
	t[x].insert(t[x].ro,1,jk,b);
	if(l==r)return;
	int tmid=(l+r)>>1;
	if(a<=tmid)insert(x<<1,l,tmid,a,b);
	else insert(x<<1|1,tmid+1,r,a,b);
}

main()
{
	for(int i=1;i<=(M<<2);i++)t[i].ro=++tot;
	cin>>n>>A>>B>>C;
	for(int i=1;i<=n;i++)cin>>a[i].h>>a[i].s;sort(a+1,a+1+n);
	for(int i=1;i<=n;i++)re[i]=(A*a[i].h+B*a[i].s)-C,o[i]=re[i];
	sort(o+1,o+1+n);jk=unique(o+1,o+1+n)-o-1;
	for(int i=1;i<=jk;i++)mp[o[i]]=i;
	for(int i=n;i>=1;i--)//minH
	{
		insert(1,1,M,a[i].s,mp[re[i]]);
		for(int j=i;j<=n;j++)//minS
		if(a[j].s<=a[i].s)
		{
			int p=A*a[i].h+B*a[j].s;
			if((re[i]>p)||(re[j]>p))continue;
			int x=get(a[j].s,p);
			ans=max(ans,x);
		}
	}
	cout<<ans;
}
```

---

## 作者：Sakura_梦瑶 (赞：6)

将式子拆开得到:ai∗h+bi∗s<=c+ai∗minh+bi∗mins；

于是现在左边可以通过枚举直接算出,右边也可以枚举约束,然后n^3就成型了.基于这个其实可以优化为正解;

------------
预处理出两个结构体,一个按照a,一个按照ai∗h+bi∗s,从小到大排序.
然后外层枚举minb,内层枚举mina.最内层先按照式子扫描将符合条件的加入,在扫描过程中判断若ai=0的情况下,也就是理想情况下是否暂时符合条件.

------------
再次进行扫描,这时扫描按照a大小排序的那个数组,除掉刚才那个暂时符合情况但是由于<当前minh 的答案.

过程中取max为答案
```
#include<bits/stdc++.h>
#define fer(x,y,z) for(short x=y;x<=z;x++)
#define N 1<<13
#define int long long
using namespace std;
struct q{int a,b,c;}a[N],c[N];int n,A,B,C,ans;
inline bool cma(q x,q y){return x.a<y.a;}
inline bool cmc(q x,q y){return x.c<y.c;}
main(){
	cin>>n>>A>>B>>C;fer(i,1,n)scanf("%lld%lld",&a[i].a,&a[i].b),
	 a[i].c=A*a[i].a+B*a[i].b,c[i]=a[i];
	sort(a+1,a+n+1,cma),sort(c+1,c+n+1,cmc);
	fer(i,1,n)for(int k=1,l=0,r=0,cnt=0,res=C/B+a[i].b;k<=n;k++){
		while(r<n&&c[r+1].c<=C+A*a[k].a+B*a[i].b)
		 if(a[i].b<=c[++r].b&&c[r].b<=res)cnt++;
		while(l<n&&a[l+1].a<a[k].a)
		 if(a[i].b<=a[++l].b&&a[l].b<=res)cnt--;
		ans=max(cnt,ans); 
	}cout<<ans;
}
```




---

## 作者：zplqwq (赞：0)

假设我们现在已经知道了 $\min_h$ 和 $\min_v$，那么由题得：当且仅当一个球员的条件满足 $a\times h+b \times v \le a\times \min_h+b  \times \min_v+c$ 时才可以加入。然后发现 $a\times h+b \times v$ 是固定的于是那个数组存下然后排个序，在把原数组按照 $h$ 排个序，然后枚举 $\min_v$ 。


然后发现，要满足 $h \ge \min_h$ ，所以把这个带进去解一下 $v$，发现 $\min_v\le v \le min_v+\frac{c}{b}$ 。

然后你再 **从小到大** 枚举 $\min_h$，这样 $a\times \min_h+b  \times \min_v+c$ 是递增的，就有很好的单调性可以利用。就利用类似于单调队列的思想，每次 $\min_h$ 增大，就将新的满足的点加进去。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=5005;
int n,ans;
ll a,b,c;
ll mn,mx;
int p1,p2,cnt;
struct node
{
    int h,v;
    ll sum;
}hh[N],vv[N];
bool cmp1(node a,node b)
{
    return a.h<b.h;
}
bool cmp2(node a,node b)
{
    return a.sum<b.sum;
} 
int main()
{
	cin>>n>>a>>b>>c;
	for(int i=1;i<=n;i++)
	{
		cin>>hh[i].h>>hh[i].v;
		vv[i]=hh[i];
		vv[i].sum=a*vv[i].h+b*vv[i].v;
	}
	sort(hh+1,hh+1+n,cmp1);
	sort(vv+1,vv+1+n,cmp2);
    for(int i=1;i<=n;i++)
	{
        mn=hh[i].v,mx=hh[i].v+c/b;
        p1=p2=cnt=0;
        for(int j=1;j<=n;j++)
		{
            while(p1<n and vv[p1+1].sum<=a*hh[j].h+b*hh[i].v+c)
			{
                p1++;
                if(vv[p1].v>=mn and vv[p1].v<=mx) cnt++;
            }
            while(p2<n and hh[p2+1].h<hh[j].h)
			{
                p2++;
                if(hh[p2].v>=mn and hh[p2].v<=mx) cnt--;
            }
            ans=max(ans,cnt);
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P4165)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下$H$表示$\min\{h\}$，$S$表示$\min\{s\}$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;梳理一下题目给出的限制条件：  
$$1.A(h_i-H)+B(s_i-S)\le C\Rightarrow Ah_i+Bs_i\le C+AH+BS$$  
$$2.h_i\ge H$$
$$3.s_i\ge S$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是不难想到一个$O(n^3)$的方法，枚举$H$和$S$，然后再扫一遍数组统计可以加入到答案的队员。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑优化这个暴力。我们还是用$O(n)$的时间枚举一波$S$，而此时的$AH+(C+BS)$已经变成了一个一次函数。考虑$H$的变化给答案带来的影响。$H$变小一点，那么对于$h_i$的限制就变小了，但同时$AH+(C+BS)$的限制也更强了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以理解成，每个满足$s_i\ge S$的球员都变成了坐标系上的点$(h_i,Ah_i+Bs_i)$，坐标系上有直线$x=H$和$y=C+AH+BS$，那么直线围出来的第四象限中的点的数量也就是满足要求的人的数量。显然，两条直线都是只会左移/下移的，**也就是一个点如果不在这个范围内了，这辈子它都不会再回到这个范围了。**~~逃课一次直接退役~~  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从$H=\max\{h\}$开始，放宽$H$的范围，根据上面的性质，我们可以在缩小$H$的过程中同时删除那些没有用的点，然后就不用管它了。每次每个点只会被删除一次，$H$也只需要扫$n$个球员里面的$h$，所以单次时间是$O(n)$。总时间$O(n^2)$。
# 代码
```cpp
#include <cstdio>
#include <algorithm>

typedef long long LL;

const int MAXN = 5005, MAXSIZ = 10005;

template<typename _T>
void read( _T &x )
{
	x = 0; char s = getchar();int f = 1;
	while( s < '0' || '9' < s ) { f = 1; if( s == '-' ) f = -1; s = getchar(); }
	while( '0' <= s && s <= '9' ) { x = ( x << 3 ) + ( x << 1 ) + s - '0', s = getchar(); }
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ) { putchar( '-' ), x = -x; }
	if( 9 < x ) { write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

struct player
{
	int h, s;
}p1[MAXN], p2[MAXN], p3[MAXN];

int buck[MAXSIZ];
LL A, B, C;
int N;

LL val( const player & x ) { return A * x.h + B * x.s; }
bool cmp1( const player & x, const player & y ) { return x.h < y.h; }
bool cmp2( const player & x, const player & y ) { return x.s < y.s; }
bool cmp3( const player & x, const player & y ) { return A * x.h + B * x.s <= A * y.h + B * y.s; }

int main()
{
	freopen( "team.in", "r", stdin );
	freopen( "team.out", "w", stdout );
	read( N ), read( A ), read( B ), read( C );
	for( int i = 1 ; i <= N ; i ++ ) read( p1[i].h ), read( p1[i].s ), p2[i] = p3[i] = p1[i];
	std :: sort( p1 + 1, p1 + 1 + N, cmp1 );
	std :: sort( p2 + 1, p2 + 1 + N, cmp2 );
	std :: sort( p3 + 1, p3 + 1 + N, cmp3 );
    //先进行三种排序，存下每种的结果
	LL upper;
	int res = 0, cnt, r;
	for( int j = 1 ; j <= N ; j ++ )
	{
		for( int i = 1 ; i <= N ; i ++ ) buck[p1[i].h] = 0;
        //清空桶
		for( int i = 1 ; i <= N ; i ++ ) 
			if( p3[i].s >= p2[j].s )
				buck[p3[i].h] ++;
        //用桶记录每次哪些点会因为H的放宽被加入答案
		r = N, cnt = 0;
		for( int i = N ; i ; i -- )
		{
			if( p1[i].h == p1[i + 1].h ) continue;
            upper = C + p2[j].s * B + A * p1[i].h;
			while( r && val( p3[r] ) > upper )
			{
				if( p3[r].s >= p2[j].s )
				{
					buck[p3[r].h] --;
                    //从桶里面删除
					if( N - i && p3[r].h >= p1[i + 1].h ) cnt --;
                    //如果在之前就被计入了答案也要弹出
				}
				r --;
			}
			cnt += buck[p1[i].h];
            //加上H的放松带来的新的成员
			res = MAX( res, cnt );
		}
	}
	write( res ), putchar( '\n' );
	return 0;
}
```

---


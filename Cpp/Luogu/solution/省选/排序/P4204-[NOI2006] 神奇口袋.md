# [NOI2006] 神奇口袋

## 题目描述

Pòlya 获得了一个奇妙的口袋，上面写着人类难以理解的符号。Pòlya 看得入了迷，冥思苦想，发现了一个神奇的模型（被后人称为 Pòlya 模型)。为了生动地讲授这个神奇的模型，他带着学生们做了一个虚拟游戏：游戏开始时，袋中装入 $a_1$ 个颜色为 $1$ 的球，$a_2$ 个颜色为 $2$ 的球，……，$a_t$ 个颜色为 $t$ 的球，其中 $a_i \in \mathbb Z^+$（$1 \le i \le t$）。

游戏开始后，每次严格进行如下的操作：

从袋中随机的抽出一个小球（袋中所有小球被抽中的概率相等），Pòlya 独自观察这个小球的颜色后将其放回，然后再把 $d$ 个与其颜色相同的小球放到口袋中。

设 $c_i$ 表示第 $i$ 次抽出的小球的颜色（$1 \le C_i \le t$），一个游戏过程将会产生一个颜色序列（$c_1, c_2, \ldots, c_n, \ldots$）。Pòlya 把游戏开始时 $t$ 种颜色的小球每一种的个数 $a_1, a_2, \ldots, a_t$ 告诉了所有学生。然后他问学生：一次游戏过程产生的颜色序列满足下列条件的概率有多大？ 

$$c_{x_1}=y_1, c_{x_2}=y_2, \ldots, c_{x_n}=y_n$$

其中 $0 < x_1 < x_2 < \cdots < x_n$，$1 \le y_i \le t$。换句话说，已知 $(t, n, d, a_1, a_2, \ldots, a_t, x_1, y_1, x_2, y_2, \ldots, x_n, y_n)$，你要回答有多大的可能性会发生下面的事件：“对所有 $k$（$1 \le k \le n$），第 $x_k$ 次抽出的球的颜色为 $y_k$”。

## 说明/提示

**【样例解释 #1】**

初始时，两种颜色球数分别为 $(1, 1)$，取出色号为 $1$ 的球的概率为 $1/2$；第二次取球之前，两种颜色球数分别为 $(2, 1)$，取出色号为 $2$ 的球的概率为 $1/3$；第三次取球之前，两种颜色球数分别为 $(2, 2)$，取出色号为 $1$ 的球的概率为 $1/2$，所以三次取球的总概率为 $1/12$。

**【数据规模和约定】**

对于 $100 \%$ 的数据，$1 \le t, n \le 1000$，$1 \le a_k, d \le 10$，$1 \le x_1 < x_2 < \cdots < x_n \le 10000$，$1 \le y_k \le t$。

## 样例 #1

### 输入

```
2 3 1
1 1
1 1
2 2
3 1
```

### 输出

```
1/12
```

## 样例 #2

### 输入

```
3 1 2
1 1 1
5 1
```

### 输出

```
1/3
```

# 题解

## 作者：yybyyb (赞：22)

考虑以下性质

*$x[1],x[2]..x[n]$等价于$1,2,...n$*

证明：

假设取第$k$步以前，所有的球的个数分别是$a[1],a[2]..a[n]$，

球的总数是$sum$

那么，第$k$步取到颜色$y$的概率是$\frac{a[y]}{sum}$

考虑第$k+1$步取到颜色$y$的概率

①第$k$步取了颜色$y$

那么，$k+1$步取到$y$的概率是$\frac{a[y]}{sum}*\frac{a[y]+D}{sum+D}$

②第$k$步没有取到颜色$y$

那么，$k+1$步取到$y$的概率是$\frac{sum-a[y]}{sum}*\frac{a[y]}{sum+D}$

将概率相加，得到第$k+1$步的概率

$$\frac{a[y](a[y]+D)+(sum-a[y])a[y]}{sum(sum+D)}$$
$$=\frac{a[y](sum+D)}{sum(sum+D)}=\frac{a[y]}{sum}$$

因此，在没有其他限制下，无论何时取$y$的概率都是相等的
也就是题目中按照$x$排序之后，可以直接将$x$离散。

但是题目中显然存在其他限制，也就是前面的某一次必定会取到某个颜色，所以我们来考虑另外一个性质。

*颜色出现的顺序对答案没有影响*

对于按照$x$排序之后，相邻的两个$y[i],y[i+1]$

①$y[i]=y[i+1]$，显然没有影响

②$y[i]\neq y[i+1]$考虑概率
$$P1=\frac{a[y[i]]}{sum}*\frac{a[y[i+1]]}{sum+D}$$

交换之后考虑概率

$$P2=\frac{a[y[i+1]]}{sum}*\frac{a[y[i]]}{sum+D}$$
$P1$显然等于$P2$

因此，$y$的出现顺序与结果无关。

根据上面的两个性质，我们可以得出：

1.$x$可以直接离散

2.$y$的顺序对结果并没有影响

因此，我们可以就按照读入顺序处理，并且$x$读进来并没有什么用

记录一下每一个颜色的球个数，以及球的总数

每次要抽到一个颜色的球就给他的数量以及总数都加上$D$
然后算一下概率就行了

因此范围比较大，概率要用高精度算

为了防止要写高精度除法

可以先分解质因数，然后约掉之后再做乘法就行了。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define ll long long
#define RG register
#define MAX 1111
inline int read()
{
    RG int x=0,t=1;RG char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
struct BigInt
{
	int s[20000],ws;
	void init(){s[1]=1;ws=1;}
	void Multi(int x)
	{
		for(int i=1;i<=ws;++i)s[i]=s[i]*x;
		for(int i=1;i<=ws;++i)s[i+1]+=s[i]/10,s[i]%=10;
		while(s[ws+1])++ws,s[ws+1]=s[ws]/10,s[ws]%=10;
	}
	void output(){for(int i=ws;i;--i)printf("%d",s[i]);}
}Ans1,Ans2;
int pri[20001],tot;
bool zs[20001];
void getpri()
{
	zs[1]=true;
	for(int i=2;i<=20000;++i)
	{
		if(!zs[i])pri[++tot]=i;
		for(int j=1;j<=tot&&i*pri[j]<=20000;++j)
		{
			zs[i*pri[j]]=true;
			if(i%pri[j]==0)break;
		}
	}
}
int Mul[20001],Div[20001];
int sum,a[MAX];
int n,m,D;
void Calc(int x,int *f)
{
	for(int i=1;i<=tot;++i)
		while(x%pri[i]==0)
		{
			f[pri[i]]++;
			x/=pri[i];
		}
}
int main()
{
	n=read();m=read();D=read();
	for(int i=1;i<=n;++i)a[i]=read(),sum+=a[i];
	getpri();
	for(int i=1;i<=m;++i)
	{
		int x=read(),y=read();
		if(!a[y]){puts("0/1");return 0;}
		Calc(a[y],Mul);Calc(sum,Div);
		a[y]+=D;sum+=D;
	}
	for(int i=1;i<=20000;++i)
		if(Div[i]>=Mul[i])Div[i]-=Mul[i],Mul[i]=0;
		else Mul[i]-=Div[i],Div[i]=0;
	Ans1.init();Ans2.init();
	for(int i=1;i<=20000;++i)
		for(int j=1;j<=Mul[i];++j)Ans1.Multi(i);
	for(int i=1;i<=20000;++i)
		for(int j=1;j<=Div[i];++j)Ans2.Multi(i);
	Ans1.output();putchar('/');Ans2.output();puts("");
	return 0;
}

```


---

## 作者：w33z8kqrqk8zzzx33 (赞：3)

首先考虑第一步，也就是对满足第一个条件的概率。

这个很类似于 polya urn model 但是球不仅仅有两种了，所有我们还是考虑一个类似结论：在任意时刻选出来一个颜色 $t$ 的球是 $\frac{a_t}{\sum a}$。

我们用对步骤数量的数学归纳来证明这个结论：

 - 当步骤数量是 $0$，显然成立。
 - 假设步骤数量为 $i-1$ 的结论成立。定义 $P(a_1,a_2,\dots)$ 为 $i-1$ 步骤后选出想要的颜色的概率。那么，$i$ 步骤后的概率是：
$$\sum \frac{a_i}{\sum a}P(\dots,a_i+d,\dots)$$
 - 根据归纳假设，$P(a)=\frac{a_t}{\sum a}$。
 - 对上面的和分类讨论：$i=t$ 或者 $i\neq t$。
$$\frac{\sum a-a_t}{\sum a}\frac{a_t}{\sum a+d}+\frac{a_t}{\sum a}\frac{a_t+d}{\sum a+d}$$
$$\frac{\sum a-a_t}{\sum a+d}\frac{a_t}{\sum a}+\frac{a_t}{\sum a}\frac{a_t+d}{\sum a+d}$$
$$\frac{a_t}{\sum a}(\frac{a_t+d}{\sum a+d}+\frac{\sum a-a_t}{\sum a+d})$$
$$\frac{a_t}{\sum a}(\frac{\sum a+d}{\sum a+d})$$
$$\frac{a_t}{\sum a}$$
 - 于是归纳假设成立。

然后发现这些条件完全可以弄的互不影响，直接对对应数组 $a_t$ 位置强行加上 $d$ 然后重新计算概率即可。为什么呢？可以把一个条件先更新到原数组上，然后在乘上这个条件满足的概率，这个条件就消失了。

很短的代码：

```py
from fractions import *
t, n, d = map(int, input().split())
ar = list(map(int, input().split()))
s = sum(ar)
ans = Fraction(1)
for i in range(n):
	x, y = map(int, input().split())
	y -= 1
	ans *= Fraction(ar[y], s)
	ar[y] += d
	s += d
print(ans)
```


---

## 作者：Purslane (赞：1)

# Solution

非常有趣的模型，其弱化版本在数学上被称为 $\rm Polya's \ urn \ scheme$。

$\rm Lemma$：本题中 $x_1,x_2,\dots,x_n$ 可以等价于 $1,2,\dots,n$。

为了证明 $\rm Lemma$，先证明一个小小的结论：

假设现在有一个状态 $\mathcal T$，则第一次操作选到某种颜色的概率和第二次操作选到这种颜色的概率是一样的。

设这种颜色在 $\mathcal T$ 中出现了 $x$ 次，$\mathcal T$ 中一共有 $S$ 个球。

那么第一次操作选到这种颜色的概率为 $\dfrac{x}{S}$。

第二次操作选到这种颜色的概率为：

- 第一次操作选到这种颜色，答案是 $\dfrac{x}{S} \cdot \dfrac{x+d}{S+d}$。
- 第一次操作没选到这种颜色，答案是 $\dfrac{S-x}{S} \cdot \dfrac{x}{S+d}$。

求和，得到还是 $\dfrac{x}{S}$。

不断调整，即可证明 $\rm Lemma$。

这道题就相当容易了，因为每一步都是确定的。

什么，还要高精度？似乎真的好久没写了。。。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2e4+10;
int n,t,tot,flg[MAXN],a[MAXN],d,x,y[MAXN],lst[MAXN];
vector<int> pr;
void init(int mx) {
	ffor(i,2,mx) {
		if(!flg[i]) pr.push_back(i),lst[i]=i;
		for(auto v:pr) {
			if(i*v>mx) break ;
			flg[i*v]=1,lst[i*v]=v;
			if(i%v==0) break ;	
		}
	}
	return ;
}
multiset<int> fz,fm;
void insert(int val,int op) {
	if(op==1) {
		if(fm.find(val)!=fm.end()) return fm.erase(fm.find(val)),void();
		fz.insert(val);
	}
	else {
		if(fz.find(val)!=fz.end()) return fz.erase(fz.find(val)),void();
		fm.insert(val);
	}
	return ;
}
struct BigNum {vector<int> vc;};
BigNum operator *(BigNum A,int v) {
	int len=A.vc.size();
	ffor(i,0,len-1) A.vc[i]*=v;
	ffor(i,0,len-2) A.vc[i+1]+=A.vc[i]/10,A.vc[i]%=10;
	while(A.vc[A.vc.size()-1]>=10) A.vc.push_back(A.vc[A.vc.size()-1]/10),A.vc[A.vc.size()-2]%=10;
	return A;
}
void output(BigNum b) {
	reverse(b.vc.begin(),b.vc.end());
	for(auto v:b.vc) cout<<v;
	return ;	
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	init(20000);
	cin>>t>>n>>d;
	ffor(i,1,t) cin>>a[i],tot+=a[i];
	ffor(i,1,n) {
		cin>>x>>y[i];
		int u=tot;
		while(u!=1) insert(lst[u],2),u/=lst[u];
		u=a[y[i]];
		while(u!=1) insert(lst[u],1),u/=lst[u];
		a[y[i]]+=d,tot+=d;
	}
	BigNum a,b;
	a.vc.push_back(1),b.vc.push_back(1);
	for(auto v:fz) a=a*v;
	for(auto v:fm) b=b*v;
	output(a),cout<<"/",output(b);
	return 0;
}
```

---

## 作者：hjmmm (赞：1)

[题目链接](https://www.luogu.org/problemnew/show/P4204)

更好的阅读体验？
[本题解同时发布于csdn](https://blog.csdn.net/CH_Vaniteux/article/details/85055971)

题意：
有t种颜色的球，最开始袋中每种颜色的小球各有a~1~, a~2~, a~3~……a~t~个。Polya抽小球**多次**，每次抽球的结果为c~1~, c~2~, c~3~……（注意，至少有n个）。每次抽出一个颜色为ci的小球后，会再放入d个颜色为c~i~的小球。
现给出n个约束条件，每个条件形如x~i~，y~i~ 
表示c[x~i~] = y~i~ 
求满足所有条件的机率

这道题乱搞是很容易搞出来的
关键就是在证明 
【小声：蒟蒻最不擅长概率题了qvq
 
 首先 如果我们只有一个约束条件c[x] = y
 考虑第x - 1步时 每个颜色有a~1~, a~2~……a~t~个小球
 
 x-1步选的颜色 | x步时的小球总数 | x步时的y球总数
 ---|---|---
 y | sum + d | a~y~ + d
 不是y | sum + d | a~y~
 
此时满足条件c[x] = y的概率显然为

$$ \frac{a[y]}{sum} * \frac{a[y] + d}{sum + d} + \frac{sun - a[y]}{sum} * \frac{a[y]}{sum + d} $$

动笔算一下 这个式子等价于$$ \frac{a[y]}{sum}$$

其实到这里 这道题就okk了
但可以更进一步
既然我们可以证明一个约束不受顺序影响
自然可以想到去证多个约束也不被影响
~~式子懒得打了 借一下yyb大神仙的orz~~
y[i] == y[i + 1]那肯定不用说
如果y[i] != y[i + 1]
$$ P1 = \frac{a[y[i]]}{sum} * \frac{a[y[i+1]]}{sum+d} $$ ​
交换之后考虑概率 
$$ P2 = \frac{a[y[i+1]]}{sum} * \frac{a[y[i]]}{sum+d} $$ ​
这样直接按照输入顺序处理就可以了

至于分数的处理
要么高精度
要么处理出它的质因数分解
对于每一个质因数 p^r1^ / p^r2^ = p^r1-r2^

 






 











---


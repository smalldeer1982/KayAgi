# [USTCPC 2025] 送温暖

## 题目描述

克露丝卡尔酱听说大家都是经验丰富的信息竞赛老手，轻松暴力踩标算。为了让大家都体验一下暴力踩标算的乐趣，所以克露丝卡尔酱准备了一道简单的送温暖题：

给定一个 $n$ 个点的树，点 $i$ 的点权为 $a_i$，你需要从中选出一个连通块，使得它们的点权和模 $M$ 的余数最大。克露丝卡尔酱想知道这个点权和模 $M$ 的余数最大是多少。

## 说明/提示

这棵树是一条链 `1 - 2 - 3 - 4 - 5 - 6`。最优解为选择一条长度为 4 的链（例如 `1 - 2 - 3 - 4` 或者 `2 - 3 - 4 - 5` 等等），此时答案为 $4 \times 7 \equiv 8\pmod {10}$。

## 样例 #1

### 输入

```
6 10
1 2 3 4 5
7 7 7 7 7 7```

### 输出

```
8```

# 题解

## 作者：vegetable_king (赞：4)

[可能更好的阅读体验](https://yjh965.github.io/post/p12038-ustcpc-2025-song-wen-nuan-ti-jie/)

这个数据范围显然考虑 meet in the middle。但是直接做可能不好做，我们考虑找到树的一个重心 $rt$，那么连通块根据是否包含 $u$ 被分为两类。对于第二类，直接枚举即可，根据重心的定义，这部分时间复杂度为 $O(2^{\frac n2})$。

考虑第一类连通块。我们考虑以 $rt$ 为根，那么我们需要将 $rt$ 的儿子的子树分为两部分，使得两部分的大小之和更大的那个尽量小，设这个大小为 $B$，由于两部分独立，这样我们就能直接以 $O((n - B)2^B)$ 的时间 meet in the middle 了。

考虑证明 $B < \frac 23n$。显然 $rt$ 的度数 $\le 3$ 的时候，结论成立。当 $rt$ 的度数 $> 3$ 的时候，$rt$ 的儿子的子树中，最小与次小的子树大小之和显然 $\le \frac n2$，我们将这两个子树合并为一个子树，就能归纳到度数减一的情况。

那么这个题就做完了。[代码](https://www.luogu.com.cn/paste/lr4rypui)在这里。

---

## 作者：mysterys (赞：3)

考虑如果没有这棵树：在一个序列上，选一些点让他们的点权和模 $M$ 的余数最大。

这是折半搜索的典题。

现在把问题放在树上，考虑折半搜索的本质：找到两个大小大约是 $2^{n/2}$ 的集合，用他们快速找出原来的大小为 $2^{n}$ 集合的答案。

我们现在相当于要找出两个子树，用最暴力的方法分别找出答案。然后快速合并。

我们发现：当根为树的重心时，刚好有最大子树的大小 $\le n/2$ 这个性质。我们可以把所有子树分成大小相近的两组。

对于没有经过根的答案，直接暴力做就行了。

对于有经过根的答案，先分别把答案存到一个 vector 里。然后二分地找即可。

实现的时候枚举联通块可能比较麻烦，可以转成 dfs 序后直接枚举，注意卡常即可。

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define FILE(x) freopen(x".in","r",stdin); freopen(x".out","w",stdout);
#define int long long
#define eb emplace_back
const int N=35;
int n,mod,dad[N];
vector<int>g[N];
vector<int>s;
int a[N];
int sz[N],rt,ans;
int b[N],len,fa[N]; 
bool vis[N];
vector<int>S[2];
int dfn[N],id[N];
int t;
int R[N];
inline void upd(int &x ,int y){
	x+=y; while(x>=mod)x-=mod;
}
inline void ins(int x){
	s.insert(upper_bound(s.begin(),s.end(),x),x);
}
inline void dfs(int u,int pa,int op){
	sz[u]=1;dad[u]=pa;
	if(op) {dfn[u]=++t;id[t]=u;}
	int val=0;
	for(int v:g[u]){
		if(v==dad[u]) continue;
		dfs(v,u,op); sz[u]+=sz[v];	val=max(val,sz[v]);	
	}
	val=max(val,n-sz[u]);
	if(val<=n/2) rt=u;
	if(op) R[u]=t;
}
inline int find(int x){ return fa[x]==x ? fa[x] : fa[x]=find(fa[x]); }
inline void merge(int x,int y){
	x=find(x);y=find(y);
	if(x==y) return;
	fa[x]=y;
}
inline int get(){
	if(!len) return 0; 
	int res=0,cnt=0;
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1;i<=len;i++) vis[b[i]]=1;
	for(int i=1;i<=len;i++) if(vis[dad[b[i]]]) merge(dad[b[i]],b[i]);
	for(int i=1;i<=len;i++) {
		cnt+=((find(b[i])==b[i]) ? 1 : 0);
		upd(res,a[b[i]]);
	} 
	for(int i=1;i<=len;i++) vis[b[i]]=0;
	return cnt==1 ? res : 0;
}
inline int get_val(int x){
	int id=lower_bound(s.begin(),s.end(),x)-s.begin();
	if(s.empty()) return 0;
	if(s.back()<x) return s.back();
	if(s[0]>=x) return 0;
	while(s[id]>=x) --id;
	return s[id];
}
inline void solve1(int u,int up){
	if(u==up+1) return ans=max(ans,get()),void();
	b[++len]=id[u];
	solve1(u+1,up);
	b[len--]=0;
	solve1(u+1,up);
}
inline void solve2(int u,int up,int op){
	if(u==up+1){
		if(op==1) {
			int val=(get()-a[rt]+mod)%mod;
			if(!get()) return;
			while(val>=mod) val-=mod;
			ans=max(ans,(val+get_val(mod-val))%mod);
		}else {
			ins(get()); ans=max(ans,get());
		}
		return;
	}
	b[++len]=id[u];
	solve2(u+1,up,op);
	b[len--]=0;
	solve2(u+1,up,op);
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n>>mod;
	for(int i=2;i<=n;i++) { cin>>dad[i]; g[dad[i]].eb(i); g[i].eb(dad[i]); }
	for(int i=1;i<=n;i++) cin>>a[i];
	if(n==1) return cout<<(a[1]%mod),0;
	dfs(1,0,0); dfs(rt,0,0);
	stable_sort(g[rt].begin(),g[rt].end(),[&](int x,int y){return sz[x]<sz[y];});
	S[0].eb(*(g[rt].rbegin()));
	int sum=0,val=sz[*g[rt].rbegin()];
	for(int i=0;i<(int)g[rt].size()-1;i++) sum+=sz[g[rt][i]];
	for(int i=0;i<(int)g[rt].size()-1;i++){
		if(val+sz[g[rt][i]]<=sum-sz[g[rt][i]]){
			sum-=sz[g[rt][i]];val+=sz[g[rt][i]];
			S[0].eb(g[rt][i]);
		}else S[1].eb(g[rt][i]);
	}
	g[rt].clear();
	for(int v:S[0]) g[rt].eb(v);
	for(int v:S[1]) g[rt].eb(v);
	dfs(rt,0,1);
	solve1(dfn[rt]+1,R[*S[0].rbegin()]);
	if(!S[1].empty())solve1(dfn[*S[1].begin()],R[*S[1].rbegin()]);
	b[len=1]=rt; 
	solve2(dfn[*S[0].begin()],R[*S[0].rbegin()],0); 
	if(!S[1].empty())solve2(dfn[*S[1].begin()],R[*S[1].rbegin()],1); 
	b[len--]=0; 
	cout<<ans;
	return 0;
}
```

---

## 作者：Aegleseeker_ (赞：3)

取模最优化，没有什么好的入手点，考虑减小需要搜索的范围。

我们令重心为根，考虑连通块是否经过重心。若连通块不经过重心，则说明连通块必在其某一子树内。根据重心的性质，每棵子树的大小都 $\le \frac{n}{2}$。我们直接枚举重心的每棵子树，暴力枚举连通块。复杂度 $O(2^{\frac{n}{2}}\times n)$。

若连通块经过重心，考虑将重心的若干棵子树划分成两个集合，然后 meet-in-the-middle。我们希望这两个集合的子树大小之和的最大值最小。

通过细致的观察可以得出结论：可以划分成两个集合使得子树大小之和都 $\le\frac{2}{3}n$。证明是若重心度数 $\le 3$，则必有一子树大小 $\ge \frac{1}{3}n$，则另外两子树大小 $\frac{2}{3}n$，将 $\frac{1}{3}n$ 的子树作为一个集合，另外两子树划分成一个集合即可。若度数 $>3$，则子树大小最小和次小的两棵子树大小加起来一定 $\le \frac{n}{2}$，我们把这两棵子树缩起来，这样就归纳成了 $\operatorname{deg}-1$ 的情况。

按照上述构造可以构造出两个集合，我们分别暴力枚举两个集合中的连通块，然后贪心 $O(n)$ 匹配即可。复杂度 $O(2^{\frac{2}{3}n}n)$。

实现的时候有一些细节，比如如何简洁地枚举连通块。这里提供一种写法，dfs 的时候上传一个 `set`，代表「考虑 $u$ 子树内，强制选 $u$ 的连通块可以凑出哪些元素」。初始 `set` 里放入 $a_u$，每次儿子的 $v$ 上传后，我们将 $u$ 的 `set` 与 `v` 的进行暴力合并即可。同时注意上传之前对答案取 $\max$。具体可以参考我的实现。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=35;
int n,m,ans;
int a[N];
vector<int> g[N];
int root,sz[N],mx[N];
void dfsroot(int u,int fa){
	sz[u]=1,mx[u]=0;
	for(auto v:g[u]){
		if(v==fa){
			continue;
		}
		dfsroot(v,u);
		sz[u]+=sz[v];
		mx[u]=max(mx[u],sz[v]);
	}
	mx[u]=max(mx[u],n-sz[u]);
	if(mx[u]<mx[root]){
		root=u;
	}
}
vector<int> get(set<int> s){
	vector<int> res;
	for(auto x:s){
		res.push_back(x);
	}
	return res;
}
set<int> dfs(int u,int fa){
	set<int> s;
	s.insert(a[u]%m);
	for(auto v:g[u]){
		if(v==fa){
			continue;
		}
		set<int> t=dfs(v,u);
		vector<int> ss=get(s),tt=get(t);
		for(auto x:ss){
			for(auto y:tt){
				s.insert((x+y)%m);
			}
		}
	}
	ans=max(ans,*(--s.end()));
	return s;
}
void dfssz(int u,int fa){
	sz[u]=1;
	for(auto v:g[u]){
		if(v==fa){
			continue;
		}
		dfssz(v,u);
		sz[u]+=sz[v];
	}
}
struct node{
	int id,sz;
	bool operator <(const node &b)const{
		return sz<b.sz;
	}
};
int f[N],type[N];
int find(int x){
	if(f[x]!=x){
		f[x]=find(f[x]);
	}
	return f[x];
}
void split(){
	multiset<node> s;
	for(auto v:g[root]){
		s.insert(node{v,sz[v]});
	}
	for(int i=1;i<=n;i++){
		f[i]=i;
	}
	while(s.size()>3){
		auto x=s.begin(),y=(x++);
		int fx=find(x->id),fy=find(y->id);
		if(fx!=fy){
			f[fy]=fx;
		}
		s.erase(x),s.erase(y);
		s.insert(node{fx,x->sz+y->sz});
	}
	bool flag=0;
	for(auto x:s){
		if(!flag&&x.sz*3>=n){
			flag=1,type[x.id]=1;
		}else{
			type[x.id]=2;
		}
	}
	for(int i=1;i<=n;i++){
		type[i]=type[find(i)];
	}
}
set<int> type1,type2;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin>>n>>m;
	for(int i=2;i<=n;i++){
		int x;
		cin>>x;
		g[x].push_back(i),g[i].push_back(x);
	}
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	mx[0]=0x3f3f3f3f,dfsroot(1,0);
	for(auto v:g[root]){
		dfs(v,root);
	}
	dfssz(root,0);
	split();
	type1.insert(0),type2.insert(0);
	for(auto v:g[root]){
		if(type[v]==1){
			set<int> t=dfs(v,root);
			vector<int> ss=get(type1),tt=get(t);
			for(auto x:ss){
				for(auto y:tt){
					type1.insert((x+y)%m);
				}
			}			
		}else{
			set<int> t=dfs(v,root);
			vector<int> ss=get(type2),tt=get(t);
			for(auto x:ss){
				for(auto y:tt){
					type2.insert((x+y)%m);
				}
			}				
		}
	}
	for(auto x:type2){
		int u=(x+a[root])%m;
		auto it=type1.lower_bound(m-u);
		if(it!=type1.begin()){
			ans=max(ans,(*(--it)+u)%m);
		}
		ans=max(ans,(*(--type1.end())+u)%m);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：2huk (赞：2)

首先如果是链，经典做法是 meet-in-the-middle。

于是考虑令树的重心为根。那么每个根的儿子的子树大小 $\le n/2$。于是一个想法是暴力枚举每个根儿子的子树内点选还是不选，然后将若干个集合合并。

但是将若干个集合合并是不好做的。好做的是合并两个集合。于是考虑将所有儿子子树分成两个集合，且它们的大小差尽量小。显然差越小复杂度越好。

注意到这个差最坏时上界是 $n/3$，即根有三个大小为 $n/3$ 的儿子。

考虑让其不超过上界。我们找到最大的子树，如果它的大小在 $[n/3,n/2]$ 内，那么将它划为一个集合，其他的子树划为另一个集合，那么他们的差最大为 $n/3$。

否则，考虑让其他的子树依次尝试合并到最大子树所在的集合。因为每个子树都 $< n/3$，所以这个集合大小第一次 $\ge n/3$ 时一定不超过 $\frac 23n$。然后跟上面一样了。

所以复杂度是 $\mathcal O(2^{\frac 23n})$ 的，实际远远跑不满。

---

## 作者：Colinxu2020 (赞：2)

不妨考虑重心 $u$ 的情况，如果 $u$ 不在我们选择的连通块中，那么不妨将 $u$ 删掉，基于重心的性质，我们所新得到的每个连通块的大小都不超过 $\frac n2$，暴力枚举所得到的每个连通块的子集，复杂度为 $O(k \cdot 2^{\frac nk}) \leq O(2^{\frac n2})$，足以通过。如果 $u$ 在我们选择的连通块中，考虑换根到 $u$。

结论：总是能将 $u$ 的子树分割为两个集合 $S,T$ 使得 $\max(\lvert S \rvert, \lvert T \rvert) \leq \frac 23 n$。

证明 & 构造方法：当 $u$ 的度数 $\leq 3$ 时，显然至少有一个子树的大小 $\geq \frac 13 n$，将这个子树单独放入 $S$，其余子树放入 $T$，则因为重心的性质，$S$ 的大小和 $\leq \frac 12 n$ 且 $T$ 的大小和 $\leq \frac 23 n$。当 $u$ 的度数 $> 3$ 时，最小的和次下的子树的大小和显然 $\leq \frac 12 n$，不妨将这两个子树合并为一个子树，$u$ 仍然是重心，归纳到了度数减一的情况。

不妨分别在 $S,T$ 中枚举所有的连通块，将可能得到的权值和放入集合中，之后变成了经典的有两个集合，分别取出一个元素让和 $\bmod M$ 的值最小的问题，直接枚举第一个集合中的元素，讨论答案是否 $-M$，如果答案不 $-M$，则找 $< M-x$ 中最大的，否则找全局最大的即可。复杂度为 $O(2^{\frac 23 n} \times n)$，足以通过。

参考代码：

```cpp

#include<iostream>
#include<vector>
#include<set>
#include<cassert>
using namespace std;

const int maxn=33+1;
int n,m,sz[maxn],wei[maxn],centroid,ai[maxn],ans;
vector<int> grp[maxn];

void dfs(int cur, int pa){
    sz[cur]=1;
    for(int x:grp[cur])if(x!=pa)dfs(x,cur),sz[cur]+=sz[x],wei[cur]=max(wei[cur],sz[x]);
    wei[cur]=max(wei[cur],n-sz[cur]);
}
set<int> split(int cur){
    set<pair<int,set<int>>> subtrees;
    for(auto x:grp[cur])subtrees.insert({sz[x],{x}});
    while(subtrees.size()>3){
        auto x=*subtrees.begin(); subtrees.erase(subtrees.begin());
        auto y=*subtrees.begin(); subtrees.erase(subtrees.begin());
        x.second.insert(y.second.begin(),y.second.end());
        subtrees.insert({x.first+y.first,x.second});
    }
    //assert(n/3-1<=subtrees.begin()->first);
    //assert(subtrees.begin()->first<=(2*n)/3+1);
    return subtrees.rbegin()->second;
}
pair<set<int>,set<int>> collect(int cur, int pa){
    set<int> res[2]; res[0].insert(ai[cur]);
    set<int> noupload;
    for(auto x:grp[cur])if(x!=pa){
        auto tmp=collect(x,cur);
        for(auto a:res[0])for(auto b:tmp.first)res[1].insert((a+b)%m);
        for(auto a:res[0])res[1].insert(a);
        for(auto a:tmp.second)noupload.insert(a);
        for(auto a:tmp.first)noupload.insert(a);
        swap(res[0],res[1]); res[1].clear();
    }
    return {res[0],noupload};
}
set<int> collect_sp(int cur, set<int> filter, int mask){
    set<int> res[2]; res[0].insert(ai[cur]*mask);
    for(auto x:grp[cur])if(filter.count(x)==mask){
        auto tmp=collect(x,cur).first;
        for(auto a:res[0])for(auto b:tmp)res[1].insert((a+b)%m);
        for(auto a:res[0])res[1].insert(a);
        swap(res[0],res[1]); res[1].clear();
    }
    return res[0];
}
int main(){
    cin>>n>>m;
    for(int i=2;i<=n;i++){
        int pa; cin>>pa;
        grp[pa].push_back(i);
        grp[i].push_back(pa);
    }
    for(int i=1;i<=n;i++)cin>>ai[i];
    if(n==1){
        cout<<ai[1]<<endl;
        return 0;
    }
    dfs(1,0);
    for(int i=1;i<=n;i++)if(wei[i]<=n/2)centroid=i;
    dfs(centroid,0);
    for(auto x:grp[centroid]){
        auto tmp=collect(x,centroid);
        ans=max(ans,*(--tmp.first.end()));
        if(tmp.second.size())ans=max(ans,*(--tmp.second.end()));
    }
    //cout<<split(centroid).size()<<endl;
    auto filter=split(centroid),a=collect_sp(centroid,filter,0),b=collect_sp(centroid,filter,1);
    //cout<<a.size()<<' '<<b.size()<<endl;
    for(auto x:a){
        auto y=b.lower_bound(m-x);
        if(y==b.begin())continue;
        ans=max(ans,(x+*(--y))%m);
    }
    ans=max(ans,(*(--a.end())+*(--b.end()))%m);
    cout<<ans<<endl;
}
```

---

## 作者：Purslane (赞：2)

# Solution

数据太唐了。

首先，显然有一个 $O(n2^n)$ 的做法，过不了。

取出重心。如果不选重心，那么暴力枚举剩下每个连通块的子集，复杂度 $O(n 2^{\frac{n}{2}})$。

如果包含重心，可以证明——能将子树分为两个子集，使得每个子集的大小 $\le \dfrac{2}{3} n$。

再暴力枚举子集并且 Meet In The Middle，就可以做到 $O(2^{\frac{2}{3}n} \text{poly}(n))$。

听说有 $O(2^{\frac{n}{2}} \text{poly}(n))$ 做法，但是不太会。。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=100;
int n,M,ans,fa[MAXN],sze[MAXN],a[MAXN],occ[MAXN],fafa[MAXN],flg[MAXN];
vector<int> G[MAXN];
void dfs(int u,int f) {sze[u]=1,occ[u]|=(1ll<<u-1);for(auto v:G[u]) dfs(v,u),occ[u]|=occ[v],sze[u]+=sze[v];return ;}
vector<int> vc[MAXN];
int find(int k) {return (fa[k]==k)?k:(fa[k]=find(fa[k]));}
int check(int s) {
	ffor(i,1,n) fa[i]=i;
	vector<int> p;
	ffor(i,1,n) if(s&(1ll<<i-1)) p.push_back(i);
	for(auto u:p) {
		for(auto v:G[u]) if(s&(1ll<<v-1)) fa[find(u)]=find(v);
		if(u!=1) {int v=fafa[u];if(s&(1ll<<v-1)) fa[find(u)]=find(v);}
	}
	int cnt=0;
	ffor(i,1,n) if(s&(1ll<<i-1)) cnt+=(find(i)==i);
	return cnt==1;
}
set<int> st;
void calc(int s) {
	for(int S=s;S;S=(S-1)&s) if(check(S)) {
		int sum=0;
		ffor(i,1,n) if(S&(1ll<<i-1)) sum+=a[i];
		ans=max(ans,sum%M);
	}
	return ;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>M;
	ffor(i,2,n) {int u;cin>>u,fafa[i]=u,G[u].push_back(i);}
	ffor(i,1,n) cin>>a[i];
	dfs(1,0);
	pair<int,pair<int,vector<int>>> mn={n+1,{-1,{}}};
	ffor(u,1,n) {
		vector<pair<int,int>> s;
		for(auto v:G[u]) s.push_back({sze[v],v});
		if(u!=1) s.push_back({n-sze[u],-1});
		ffor(j,0,n) vc[j].clear(),flg[j]=0;
		flg[0]=1;
		for(auto pr:s) {
			int v=pr.first,id=pr.second;
			roff(j,n,v) if(flg[j-v]) flg[j]=1,vc[j]=vc[j-v],vc[j].push_back(id);	
		}
		ffor(j,0,n) if(flg[j]) mn=min(mn,{max(j,n-j),{u,vc[j]}});
	}
	int u=mn.second.first;
	auto div=mn.second.second;
	for(auto v:G[u]) calc(occ[v]);
	calc((1ll<<n)-1-occ[u]);
	set<int> v;
	int s1=(1ll<<u-1),s2=(1ll<<u-1);
	for(auto v:div) {
		if(v==-1) s1|=((1ll<<n)-1)-occ[u];
		else s1|=occ[v];
	}
	s2|=(1ll<<n)-1-s1;
	for(int S=s2;S;S=(S-1)&s2) if(S&(1ll<<u-1)) {
		if(check(S)) {
			int sum=0;
			ffor(i,1,n) if(S&(1ll<<i-1)) sum+=a[i];
			v.insert(sum%M);
			ans=max(ans,sum%M);
		}
	}
	for(int S=s1;S;S=(S-1)&s1) if(S&(1ll<<u-1)) {
		if(check(S)) {
			int sum=-a[u];
			ffor(i,1,n) if(S&(1ll<<i-1)) sum+=a[i];
			ans=max(ans,(sum+*(--v.end()))%M);
			auto it=v.lower_bound(M-(sum%M));
			if(it!=v.begin()) ans=max(ans,(sum+*prev(it))%M);
			ans=max(ans,(sum+a[u])%M);
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：hgckythgcfhk (赞：2)

广告：[USTCPC2025 题解汇总（部分）](https://www.luogu.com.cn/article/xl8dsc9j)。

注意到重心的最大的子树的 $size$ 小于 $\frac{n}{2}$，这个性质使得把重心拆出来形成的多个子树划分成两个集合，每个集合的 $size$ 的和不超过 $\frac{2}{3}n$。事实上这个东西可以卡满，考虑让重心当根然后分 $3$ 个一样大的子树。

合并两个集合可以枚举一个集合里的所有带着根的答案去在另一个集合里二分。

大体做法就是这样，不需要详细解释，我重点说一些细节，事实上这个做法在理论上是题面说的暴力，而且貌似还有时间复杂度更优的做法，这个东西直接写是过不了的，现在说几个卡常的方法。

首先一定要保证 ```chk``` 的复杂度不要假掉，这里一定要只带一个 $n$，判断连通可以保留集合内所有边然后在当前判的集合里数多少边是在当前判的集合有多少条边，然后用 ```popcount``` 算点数，点数减边数就是连通块个数，连通块个数是 $1$ 的时候合法，这样可以避开并查集的大常数。

然后经过我的测试，对 ```set``` 进行 ```lower_bound``` 的时间复杂度疑似是错的，就算是对的也是大常数，所以应该先放到 ```vector``` 里面进二分。

划分集合的过程未必要真正的去完美的划分，事实上我记得有这么一个题好像正解是随机化，大概就是说把 $n$ 个数划分成两个集合使得两个集合和的差绝对值最小，大概就是直接贪心的把当前的数放到小的集合，然后随机打乱多做几次，可以认为这么做是对的。

具体的直接看程序吧，这次没有 $42$ 队的赛时代码，是我自己写的，$42$ 队做出了帮我卡常的贡献。

为防止因火车头导致无法过审，这里省略了缺省源，只放核心程序。

```cpp
#define debug if(1.0*(clock()-t0)/CLOCKS_PER_SEC>=0.6)cout<<"-1",exit(0)
vint a[40];unsigned b[40],m,seed=time(0);unsigned t0=clock();
#define R() (seed^=(seed^=(seed<<11)>>13)<<17)
struct tree{set<unsigned>s,id;vint c;unsigned rt,n,f[40],res;unsigned mp[40],e[40][40],$[40][2],d;
	void ins(vint _){for(cit&i:_)id.emplace(i),++n;}
	void init(){int i=0;for(cit&j:id)mp[j]=++i;res=0;
		for(cit&u:id)for(cit&v:a[u]){cit x=mp[u],y=mp[v];debug;
		if(!y)continue;e[x][y]=e[y][x]=1;}d=0;
		for(i=1;i<=n;++i)for(int j=1;j<i;++j)if(e[i][j])++d,$[d][0]=i,$[d][1]=j;
		c+=(unsigned)0;for(cit&j:id)c+=b[j];}
	il unsigned fd(cit x){return f[x]==x?x:f[x]=fd(f[x]);}
	il unsigned calc(cit _){int sum=0;for(int i=1;i<=n;++i)if(_&(1<<i))sum+=c[i],sum>=m?sum-=m:0;return sum;}
	void chk(cit _){int cnt=0;
		for(int i=1;i<=d;++i)if((_&(1<<$[i][0]))&&(_&(1<<$[i][1])))++cnt;
		cnt=__builtin_popcount(_)-cnt;if(cnt>1)return;
		cit t=calc(_);res=max(res,t);if(_&(1<<rt))s.emplace(t);
	}void ans(){rt=mp[rt];for(int i=0;i<(1<<n);++i)chk(i<<1);}
}t1,t2;unsigned rt,dp[40],s[40],f[40];unsigned n;
void dfs(cit u){s[u]=1;for(cit&v:a[u])if(v^f[u])dfs(v),s[u]+=s[v],dp[u]=max(s[v],dp[u]);dp[u]=max(n-s[u],dp[u]);}
void gf(cit u){s[u]=1;for(cit&v:a[u])if(v^f[u])f[v]=u,gf(v),s[u]+=s[v];}
il vint val(cit u){vint _;_+=u;for(cit&v:a[u])_+=val(v);return _;}
void init(){rd(n),rd(m);int mn=40,s1=0,s2=0,b1=0,b2=0;
	for(int i=2;i<=n;++i)a[f[i]=rd()]+=i,a[i]+=f[i];dfs(1);
	for(int i=1;i<=n;++i)mn>dp[i]?mn=dp[i],rt=i:0,rd(b[i]);
	cle(f);gf(rt);for(int i=1;i<=n;++i)a[i]=vint();vint _,a1,a2;
	for(int i=1;i<=n;++i)a[f[i]]+=i;for(cit&v:a[rt])if(v)a[n+1]+=v;
	for(cit&v:a[rt])s1<s2?(s1+=s[v],a1+=v):(s2+=s[v],a2+=v);
	vint ans1=a1,ans2=a2;for(int i=1;i<=16;++i){
		a1=vint(),a2=vint(),b1=b2=0;
		for(int j=a[rt].SZ-1;j;--j)swap(a[rt][j],a[rt][R()%j]);
		for(cit&v:a[rt])b1<b2?(b1+=s[v],a1+=v):(b2+=s[v],a2+=v);
		if(max(s1,s2)>max(b1,b2))b1=s1,b2=s2,ans1=a1,ans2=a2;}
	for(cit&v:ans1)t1.ins(val(v));for(cit&v:ans2)t2.ins(val(v));
	_+=rt,t1.ins(_),t1.init(),_=vint(),_+=n+1,t2.ins(_),t2.init();
}void solve(){init();t1.rt=rt,t2.rt=n+1;t1.ans(),t2.ans();int ans=0;
	if(t1.s.SZ>t2.s.SZ)swap(t1.s,t2.s);vint tt;for(cit&x:t2.s)tt+=x;
	for(cit&x:t1.s){auto it=lower_bound(tt.begin(),tt.end(),m-x);if(it==tt.begin())continue;--it;ans=max(x+*it,ans);}
	cout<<max(ans,max(t1.res,t2.res));
}signed main(){open;int t=1;//cin>>t;
	while(t--)solve();}
```

---

## 作者：wukaichen888 (赞：1)

$O(2^{\frac{n}{2}}n)$ 做法。

考虑对于 $x$ 子树，求出包含 $x$ 的最优解。

先对 $x$ 子树剖 $x$ 所在的重链，对挂在重链上的轻子树全部暴力求解。钦定选取的 $x$ 重链前缀，将轻子树划分到两个集合，使得两个集合内总点数 $\le\frac{siz_x}{2}$，然后折半合并出最优解，这是经典问题。

考虑证明总能分两个合法集合。设重链长度为 $len$，构造一个序列 $a$ 表示所有挂在 $x$ 重链上的轻子树大小，然后往 $a$ 中加入 $len$ 个 $1$。将 $a$ 从大到小排序，试证明 $a_x\le\sum_{x\lt y}a_y$（可能有点不严谨）：在重链上找到最低的 $u$ 使得 $siz_u\lt x$，$siz_{par_u}\ge x$，$par_u$ 的轻子树 $siz\le siz_u\lt x$，选取 $par_u$ 子树内所有 $a$ 即可。然后从大到小依次考虑 $a$，由于 $a_x\le\sum_{x\lt y}a_y$ 且 $\sum a=siz_x$，所以你总是能将 $a_x$ 扔进较小的集合。

算完包含 $x$ 的最优解直接递归算所有子树即可。

复杂度 $\sum{2^{\frac{siz_x}{2}}siz_x^2}$ 即 $O(2^\frac{n}{2}n^2)$（因为有排序），能优化到 $O(2^\frac{n}{2}n)$，人傻常数大，跑得比 $O(2^{\frac{3n}{2}}n)$ 慢。

---

## 作者：流水行船CCD (赞：0)

按重心把树切开再合并去 meet-in-miidle 太不自然了，有没有更直接的办法？有的。

一个朴素的思路是找到一条边吧树切成两半，但是对于菊花，这种方法无法保证切出来的子树是平衡的。

而我们在边分治中遇到了同样的问题，因此考虑把原树三度化（三度化后不妨把原来的点称作关键点，新建的点称作非关键点），注意到此时一定能找到一条边把原树分成两个部分，每个部分中关键点最多为 $\frac{2}{3}n$。

考虑证明上述结论，反证法：如果最小的剖分（不妨设是按 $(u,v)$ 剖开的）都会有一个部分关键点数大于 $\frac{2}{3}n$，不妨设这个部分的根是 $u$，由于三度化之后是二叉树，分讨 $u$ 的儿子个数：如果只有一个儿子，很明显剖分 $u$ 的儿子到 $u$ 这条边更优；如果有两个儿子，很明显其中关键点个数较大的子树必定大于 $\frac{1}{3}n$，很明显剖分这个较大子树的根到 $u$ 这条边更优。这与 $(u,v)$ 是最小剖分矛盾。

后面枚举连通块的部分其他题解讲的很细，这里就只提供一种新的 meet-in-middle 的方法了。

复杂度是 $O(\frac{2}{3}n \cdot 2^{\frac{2}{3}n})$ 的。

---


# 拼字游戏

## 题目描述

有一个未知的 $4 \times 4$ 的拼盘 $M$，它的每个元素都是正整数。给出 $4$ 行元素的总和，$4$ 列元素的总和以及两条对角线元素总和。另外还给出了拼盘中任意 $4$ 个位置的元素值，它们的位置在输入文件中给定。

编写一个程序求出拼盘中另外 $12$ 个位置的正整数的值，要求这些元素的行之和，列之和以及对角线之和与输入文件中给定的值相一致。


## 说明/提示

- 对于 $10\%$ 的数据，任何行，列或对角线之和不会超过 $20$；
- 对于 $30\%$ 的数据，任何行，列或对角线之和不会超过 $80$；
- 对于 $60\%$ 的数据，任何行，列或对角线之和不会超过 $200$；
- 对于 $100\%$ 的数据，任何行，列或对角线之和不会超过 $300$。

感谢 @Jomoo 的贡献。

## 样例 #1

### 输入

```
130 120 172 140 157 93 144 168 66 195 0 1 15 1 3 49 2 2 16 3 0 33```

### 输出

```
22 15 28 65
49 1 21 49
53 76 16 27
33 1 79 27
```

# 题解

## 作者：henryhu2006 (赞：23)

## 拼字游戏题解
### 题目大意
要求得出一个 4 x 4 的矩形，使得它满足几个限制条件。

- 每一行之和等于对应的给定数
- 每一列之和等于对应的给定数
- 正对角线 $x=y$ 之和等于给定数
- 反对角线 $x+y=3$ 之和等于给定数
- $3$ 个格子的值已经限定。

值域 $\leq 300$

### 算法1

首先矩形那么小，多半是搜索，所以考虑最暴力的方式：依次搜索每个格子的值，如果不符合题意就继续。但是这可能只有个位数的成绩。

最朴素的想法就是可行性剪枝，一边搜索一边判断已经结束的行或者列或者对角线的合法性，同时保证每个时刻，任何格子确定值了以后不会出现明显的导致**行**之和超过给定值的情况。

这样，通过最基础的算法，可以得到 $24$ 分。

```
lin: 每一行当前的和
col: 每一列当前的和
cr1: 正对角线当前的和
cr2: 反对角线当前的和
val: 就是填出的矩阵

update: 搜索更新各个和
```

代码：
```cpp
int val[5][5],lin[5],col[5],cr1,cr2;
void update(int x,int y,int v){
	lin[x]+=v,col[y]+=v;
	if(x==y) cr1+=v;
	if(x+y==5) cr2+=v;
}
```
```cpp
void dfs(int x,int y){
	if(x==4&&y==5){
		if(cr1) return;
     if(col[4]) return; // 最后两个判断非常重要
		for(int i=1;i<=4;++i){
			for(int j=1;j<=4;++j)
				cout<<val[i][j]<<" ";
			cout<<endl;
		}
		exit(0);
	}
	if(y==5){
		if(lin[x]) return;
		dfs(x+1,1);
		return;
	}
	if(x==4&&y>1&&cr2) return;
	if(x==4&&col[y-1]!=0) return;
	if(val[x][y]){
		dfs(x,y+1);
		return;
	}
	int mx=min(lin[x],col[y]);
	if(x==y) mx=min(mx,cr1);
	if(x+y==5) mx=min(mx,cr2); // 计算最大可行值
	if(y==4){
		if(lin[x]==0) return;
		val[x][y]=lin[x],update(x,y,-val[x][y]);
		dfs(x,y+1);
		update(x,y,val[x][y]),val[x][y]=0;
		return;
	}
	for(int i=1;i<=mx;++i)
		update(x,y,-1),val[x][y]=i,dfs(x,y+1);
	val[x][y]=0,update(x,y,mx);
}
```
```cpp
int main(){
	for(int i=1;i<=4;++i) cin>>lin[i];
	for(int i=1;i<=4;++i) cin>>col[i];
	cin>>cr1>>cr2;
	for(int i=1,x,y,v;i<=4;++i)
		cin>>x>>y>>v,++x,++y,val[x][y]=v,update(x,y,-v);
	dfs(1,1);
	return 0;
}
```

### 算法2

算法1浪费在无法在合适的时候解决掉一些不合法的状态。从上面的代码可以看到，列的和以及对角线和直到最后一行才被判断。同时，最大可行值也需要考虑给别的空格至少留下 $1$。

优化方案：记录每一时刻每行每列每对角线没有填的格子的数量。同时一些小小的常数优化，分数就变成了 $78$ 分。

```
numl: 每行剩余空格数
numc: 每列剩余空格数
num1: 正对角线空格数
num2: 反对角线空格数

calc: 更新空格数
check: 判断一个格子填某个值是否合法
limit: 求一个格子当前最大可以填几
```

代码：
```cpp
void calc(int x,int y,int v){
	numl[x]+=v,numc[y]+=v;
	if(x==y) num1+=v;
	if(x+y==5) num2+=v;
}
```
```cpp
bool check(int x,int y,int v){
	if(v<=0) return 0;
	if(lin[x]<v+numl[x]-1) return 0;
	if(col[y]<v+numc[y]-1) return 0;
	if(x==y&&cr1<v+num1-1) return 0;
	if(x+y==5&&cr2<v+num2-1) return 0;
	return 1;
}
```
```cpp
inline int limit(int x,int y){
	return min(min(lin[x]-numl[x],col[y]-numc[y]),min((x==y?cr1-num1:inf),(x+y==5?cr2-num2:inf)))+1;
}
```
特判只有一个剩余格子，其他以此类推。
```cpp
if(numl[x]==1){
	if(!check(x,y,lin[x])) return;
	val[x][y]=lin[x],update(x,y,-val[x][y]),calc(x,y,-1);
	dfs(x,y+1);
	update(x,y,val[x][y]),calc(x,y,1),val[x][y]=0;
	return;
}
```
搜索该格的值。
```cpp
int lmm=limit(x,y);
calc(x,y,-1);
for(int i=1;i<=lmm;++i)
	++val[x][y],update(x,y,-1),dfs(x,y+1);
calc(x,y,1),val[x][y]=0,update(x,y,lmm);
// main 函数不要忘了一样要 calc
```

### 算法3

> 山重水复疑无路，柳暗花明又一村。

看似优化到底了，但是注意到这道题的目标是尽快找到一个合法的答案，而不是搜索所有的解。因此需要尽量使程序快速找到答案。

优化一：考虑到限制越大的格子先搜。先将所有格子按照最大可填值排序，依次按顺序搜索。

优化二：经过观察可以发现，如果一个格子填的值太大或者太小，那么找到解的概率会大致的随之下降。所以枚举一个格子的值可以从中间往后枚举，然后在枚举小的值。

通过这两个优化可以通过。

```
Tip: #48 数据占据总时间的 70%，不要被这数据点卡了！
```
```
sr: 排在第几的是哪个格子
dfs 的参数变为当前搜索的是第几个格子。
```
完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=1e9;
int val[5][5],lin[5],col[5],cr1,cr2;
int numl[5],numc[5],num1,num2;
struct node{int x,y;} sr[35];
void update(int x,int y,int v){
	lin[x]+=v,col[y]+=v;
	if(x==y) cr1+=v;
	if(x+y==5) cr2+=v;
}
void calc(int x,int y,int v){
	numl[x]+=v,numc[y]+=v;
	if(x==y) num1+=v;
	if(x+y==5) num2+=v;
}
bool check(int x,int y,int v){
	if(v<=0) return 0;
	if(lin[x]<v+numl[x]-1) return 0;
	if(col[y]<v+numc[y]-1) return 0;
	if(x==y&&cr1<v+num1-1) return 0;
	if(x+y==5&&cr2<v+num2-1) return 0;
	return 1;
}
inline int limit(int x,int y){
	return min(min(lin[x]-numl[x],col[y]-numc[y]),min((x==y?cr1-num1:inf),(x+y==5?cr2-num2:inf)))+1;
}
inline bool cmp(const node&aa,const node&bb){
	return limit(aa.x,aa.y)<limit(bb.x,bb.y);
}
void dfs(int pos){
	int x=sr[pos].x,y=sr[pos].y;
	if(x==4&&y==5){
		for(int i=1;i<=4;++i)
			if(lin[i]) return;
		for(int i=1;i<=4;++i)
			if(col[i]) return;
		if(cr1||cr2) return;
		for(int i=1;i<=4;++i){
			for(int j=1;j<=4;++j)
				cout<<val[i][j]<<" ";
			cout<<endl;
		}
		exit(0);
	}
	if(numl[x]==1){
		if(!check(x,y,lin[x])) return;
		val[x][y]=lin[x],update(x,y,-val[x][y]),calc(x,y,-1);
		dfs(pos+1);
		update(x,y,val[x][y]),calc(x,y,1),val[x][y]=0;
		return;
	}
	if(numc[y]==1){
		if(!check(x,y,col[y])) return;
		val[x][y]=col[y],update(x,y,-val[x][y]),calc(x,y,-1);
		dfs(pos+1);
		update(x,y,val[x][y]),calc(x,y,1),val[x][y]=0;
		return;
	}
	if(num1==1&&x==y){
		if(!check(x,y,cr1)) return;
		val[x][y]=cr1,update(x,y,-val[x][y]),calc(x,y,-1);
		dfs(pos+1);
		update(x,y,val[x][y]),calc(x,y,1),val[x][y]=0;
		return;
	}
	if(num2==1&&x+y==5){
		if(!check(x,y,cr2)) return;
		val[x][y]=cr2,update(x,y,-val[x][y]),calc(x,y,-1);
		dfs(pos+1);
		update(x,y,val[x][y]),calc(x,y,1),val[x][y]=0;
		return;
	}
	int lmm=limit(x,y),l=lmm/3;
	l=max(l,1);
	calc(x,y,-1);
	update(x,y,-l+1);
	for(int i=l;i<=lmm;++i)
		val[x][y]=i,update(x,y,-1),dfs(pos+1);
	update(x,y,lmm);
	for(int i=1;i<l;++i)
		val[x][y]=i,update(x,y,-1),dfs(pos+1);
	calc(x,y,1),val[x][y]=0,update(x,y,l-1);
}
int main(){
	for(int i=1;i<=4;++i) cin>>lin[i],numl[i]=4;
	for(int i=1;i<=4;++i) cin>>col[i],numc[i]=4;
	cin>>cr1>>cr2,num1=num2=4;
	for(int i=1,x,y,v;i<=4;++i){
		cin>>x>>y>>v,++x,++y;
		val[x][y]=v,update(x,y,-v),calc(x,y,-1);
	}
	int tt=0;
	for(int i=1;i<=4;++i)
		for(int j=1;j<=4;++j)
			if(!val[i][j]) sr[++tt]=(node){i,j};
	sort(sr+1,sr+tt+1,cmp);
	sr[++tt]=(node){4,5};
	dfs(1);
	return 0;
}
```
### 总结
- 长的代码最好加上最后的保险

- 搜索可行解可以通过合理的搜索顺序进行优化。

- 枚举一个位置的值时要考虑哪个值比较容易有可行解。

- 尽量不要让搜索的可行性判断放到最后

---

## 作者：王大神——A001 (赞：7)

### 题目描述
[传送门](https://www.luogu.com.cn/problem/P1277)

有一个未知的 $4\times4$ 的拼盘 $M$，它的每个元素都是正整数。给出 4 行元素的总和 4 列元素的总和以及两条对角线元素总和。另外还给出了拼盘中任意 4 个位置的元素值，它们的位置在输入文件中给定

编写一个程序求出拼盘中另外 12 个位置的正整数的值，要求这些元素的行之和，列之和以及对角线之和与输入文件中给定的值相一致

### 理思路
首先题目给了我们**每列每排**和**对角线**的数的和，以及 4 个**数的数值**，而且任何行对角线或列**之和不会超过 300**，另外给定的输入文件**总是存在解决方案**

假设题目给的数为 $sum_i$（从下标 0 开始计数），下图一种颜色代表一个 $sum_i$ 的所管辖的数，也是约束情况合理的条件
![手绘要求](https://cdn.luogu.com.cn/upload/image_hosting/sddyaql1.png)
（样例）

**目标：我们要找到更多的约束条件**（因为约束越多，尝试的情况越少）

设 $S = sum_0+sum_1+sum_2+sum_3$（即所有数值和）

$\because$

$$\left\{
\begin{aligned}
(0,0)+(0,1)+(0,2)+(0,3) = sum_0 \\
(0,0)+(0,1)+(0,2)+(0,3) = sum_3 \\
(0,1)+(1,1)+(2,1)+(3,1) = sum_5 \\
(0,2)+(1,2)+(2,2)+(3,2) = sum_6 \\
(0,0)+(1,1)+(2,2)+(3,3) = sum_8 \\
(0,3)+(1,2)+(2,1)+(3,0) = sum_9 \\
\end{aligned}
\right.$$

$\therefore$ $\frac{(sum_0+sum_3+sum_5+sum_6+sum_8+sum_9)}{2}=S-(1,0)-(2,0)-(1,3)-(2,3)$

$S_1=(1,0)+(2,0)+(1,3)+(2,3)$（下图中紫色所经过的点的和）

$S_2=(0,1)+(0,2)+(3,1)+(3,2)=S-(sum_8+sum_9)-S_1$（下图中橙色所经过的点的和）


$S_3=(0,0)+(0,3)+(3,0)+(3,3)=(sum_0+sum_3)-S_2$（即四个角的和）

$S_4=S-S_1-S_2-S_3=(1,1)+(1,2)+(2,1)+(2,2)$（即内部四数之和）

![点权](https://cdn.luogu.com.cn/upload/image_hosting/cqp14h6m.png)


------------
我们可以开始尝试一下了

我们先用样例的数据，为了方便我们用 * 表示已知数，? 表示未知，1 至 $n$ 表示我们自己填的数

**初始：**

$?,*,?,?$

$?,?,?,*$

$?,?,*,?$

$*,?,?,?$

------------

**填入第一个数**

$1,*,?,?$

$?,?,?,*$

$?,?,*,?$

$*,?,?,?$

------------

**填入第二个数**

$1,*,2,*$

$?,?,?,*$

$?,?,*,?$

$*,?,?,?$

----
$1,*,2,*$

$?,?,?,*$

$?,?,*,?$

$*,?,?,*$（我们有 $S_3$）

----
$1,*,2,*$

$?,*,?,*$

$?,?,*,*$

$*,?,?,*$

------------

**填入第三个数**

$1,*,2,*$

$3,*,*,*$

$*,*,*,*$

$*,*,*,*$

------------

正是因为我们的约束条件找得多，所以我们需要填的数次数少，便利的次数就会减少（填的数只需要 3 或 4 个就可以得出答案！）

**而剩下的就可以移交给随机数来处理了**

通过 $sum_i$ 的范围限制，不断尝试即可。

---

## 作者：wangziwenhk (赞：2)

[传送门](https://www.luogu.com.cn/problem/P1277)

## 题面

有一个未知的 $4 \times 4$ 的拼盘 $M$，它的每个元素都是正整数。给出 $4$ 行元素的总和，$4$ 列元素的总和以及两条对角线元素总和。另外还给出了拼盘中任意 $4$ 个位置的元素值，它们的位置在输入文件中给定。

编写一个程序求出拼盘中另外 $12$ 个位置的正整数的值，要求这些元素的行之和，列之和以及对角线之和与输入文件中给定的值相一致。

## 思路

这一道题目类似于八皇后，不过暴力肯定会超时间。

我们可以对每一个格子预处理出它的最大可填值，

例如样例：

| $\colorbox{yellow}{\textcolor{black}{66}}$ | $\colorbox{red}{\textcolor{white}{157}}$ | $\colorbox{red}{\textcolor{white}{93}}$ | $\colorbox{red}{\textcolor{white}{144}}$ | $\colorbox{red}{\textcolor{white}{168}}$ |
| :----------------------------------------: | :--------------------------------------: | :-------------------------------------: | :--------------------------------------: | :--------------------------------------: |
|  $\colorbox{red}{\textcolor{white}{130}}$  |                                          |                   15                    |                                          |                                          |
|  $\colorbox{red}{\textcolor{white}{120}}$  |                                          |                                         |                                          |                    49                    |
|  $\colorbox{red}{\textcolor{white}{172}}$  |                                          |                                         |                    16                    |                                          |
|  $\colorbox{red}{\textcolor{white}{140}}$  |                    33                    |                                         |                                          |                                          |
| $\colorbox{blue}{\textcolor{yellow}{195}}$ |                                          |                                         |                                          |                                          |

的最大可填值则为：

| $\textcolor{black}{50}$  |            X            | $\textcolor{black}{115}$ | $\textcolor{black}{115}$ |
| :----------------------: | :---------------------: | :----------------------: | :----------------------: |
| $\textcolor{black}{71}$  | $\textcolor{black}{50}$ | $\textcolor{black}{71}$  |            X             |
| $\textcolor{black}{124}$ | $\textcolor{black}{78}$ |            X             | $\textcolor{black}{119}$ |
|            X             | $\textcolor{black}{78}$ | $\textcolor{black}{107}$ | $\textcolor{black}{50}$  |

我们将所有的最大可填值先预处理出来：
```c++
//棋盘
int puzzle[4][4];
//行列总和
int row[4],column[4];
//对角线总和
int diagonal[2];
//行内最小
for(int i=0;i<4;i++) {
    int sum = row[i];
    for(int j=0;j<4;j++) {
        sum-=puzzle[i][j];
    }
    for(int j=0;j<4;j++) {
        minx[i][j]=sum;
    }
    row[i] = sum;
}
//列内最小
for(int j=0;j<4;j++) {
    int sum = column[j];
    for(int i=0;i<4;i++) {
        sum-=puzzle[i][j];
    }
    for(int i=0;i<4;i++) {
        minx[i][j]=min(sum,minx[i][j]);
    }
    column[j] = sum;
}
//对角线最小
{
    diagonal[0] = diagonal[0]-(puzzle[0][0]+puzzle[1][1]+puzzle[2][2]+puzzle[3][3]);
    diagonal[1] = diagonal[1]-(puzzle[0][3]+puzzle[1][2]+puzzle[2][1]+puzzle[3][0]);
    //主对角线
    for(int i=0;i<4;i++) {
        minx[i][i]=min(diagonal[0],minx[i][i]);
        if(puzzle[i][i]) {
            numd[0]--;
        }
    }
    //副对角线
    for(int i=0;i<4;i++) {
        minx[i][3-i]=min(diagonal[1],minx[i][3-i]);
        if(puzzle[i][3-i]) {
            numd[1]--;
        }
    }
}
//生成序列
for(int i=0;i<4;i++) {
    for(int j=0;j<4;j++) {
        if(!puzzle[i][j]) {
            vec.push_back(Node{i,j,minx[i][j]});
        }
        else {
            numr[i]--;
            numc[j]--;
        }
    }
}
```
排个序：

````c++
struct Node{
    int x,y;
    int maxValue;
}
bool cmp(Node x,Node y){
    return x.maxValue<y.maxValue;
}
sort(vec.begin(),vec.end(),cmp);
````

接下来写 DFS 部分。我们将 DFS 的 $(x,y)$​ 改成 vec 中的下标，这样总是可以在最小的范围内找到答案。

我们可以再设置一个 maxValue 来存储当前格子可能的最大值（别问，问就是格子是动态的）。

```c++
int maxValue = min(min(vec[k].maxValue,row[x]),column[y]);
maxValue = min(maxValue,diagonal[flag]);
```

为了防止在最后检验答案时出幺蛾子，我们可以采取局部检验方法——在一行，一列或一个对角线满了时候，检查一下值是否等于。

```c++
//每一行的剩余格子数
int numr[4];
//每一列的剩余格子数
int numc[4];
//主副对角线的剩余格子数
int numd[4];
//说明当前是哪个对角线上的格子
int flag;

if(numr[x]==0 && row[x]!=0) {
    //这一块内容是回溯用的
    puzzle[x][y] = 0;
    row[x]+=i;
    column[y]+=i;
    diagonal[flag]+=i;
   	//尝试下一个值
    continue;
}
if(numc[y]==0 && column[y]!=0){
    puzzle[x][y] = 0;
    row[x]+=i;
    column[y]+=i;
    diagonal[flag]+=i;
    continue;
}
if(numd[flag] == 0 && diagonal[flag]!=0) {
    puzzle[x][y] = 0;
    row[x]+=i;
    column[y]+=i;
    diagonal[flag]+=i;
    continue;
}
```

最后检查并输出就好了：

```c++
bool check(){
    for(int i=0;i<4;i++)if(row[i])return false;
    for(int i=0;i<4;i++)if(column[i])return false;
    for(int i=0;i<2;i++)if(diagonal[i])return false;
    return true;
}

if(k==vec.size()) {
	if(!check())return;
	for(int i=0;i<4;i++) {
		for(int j=0;j<4;j++) {
			cout<<puzzle[i][j]<<' ';
		}
	cout<<endl;
	}
	exit(0);
}
```

## 完整代码

```c++
#include <bits/stdc++.h>

using namespace std;

//行,列,主副对角线
int row[4], column[4],diagonal[2];
int puzzle[4][4];
int minx[4][4];
//每一空行的格子数
int numr[4] = {4,4,4,4};
//每一列的格子数
int numc[4] = {4,4,4,4};
//主副对角线的格子数
int numd[2] = {4,4};
struct Node {
    int x, y;
    int maxValue;
};
vector<Node>vec;
bool cmp(const Node x, const Node y) {
    return x.maxValue < y.maxValue;
}
bool check(){
    for(int i=0;i<4;i++)if(row[i])return false;
    for(int i=0;i<4;i++)if(column[i])return false;
    for(int i=0;i<2;i++)if(diagonal[i])return false;
    return true;
}
int checkPos(int x,int y) {
    if(x==y)return 0;
    if(x==3-y)return 1;
    return -1;
}
//表示当前遍历哪个格子
void dfs(int k) {
    if(k==vec.size()) {
        if(!check())return;
        for(int i=0;i<4;i++) {
            for(int j=0;j<4;j++) {
                cout<<puzzle[i][j]<<' ';
            }
            cout<<endl;
        }
        exit(0);
    }
    const int x = vec[k].x;
    const int y = vec[k].y;
    const int flag = checkPos(x,y);

    int maxValue = min(min(vec[k].maxValue,row[x]),column[y]);

    if(flag==-1) {
        numr[x]--;
        numc[y]--;
        for(int i=maxValue;i>=1;i--) {
            puzzle[x][y] = i;
            row[x]-=i;
            column[y]-=i;
            if(numr[x]==0 && row[x]!=0){
                puzzle[x][y] = 0;
                row[x]+=i;
                column[y]+=i;
                continue;
            }
            if(numc[y]==0 && column[y]!=0){
                puzzle[x][y] = 0;
                row[x]+=i;
                column[y]+=i;
                continue;
            }
            dfs(k+1);
            puzzle[x][y] = 0;
            row[x]+=i;
            column[y]+=i;
        }
        numr[x]++;
        numc[y]++;
    }
    else {
        numr[x]--;
        numc[y]--;
        numd[flag]--;
        maxValue = min(maxValue,diagonal[flag]);
        for(int i=maxValue;i>=1;i--) {
            puzzle[x][y] = i;
            row[x]-=i;
            column[y]-=i;
            diagonal[flag]-=i;
            if(numr[x]==0 && row[x]!=0) {
                puzzle[x][y] = 0;
                row[x]+=i;
                column[y]+=i;
                diagonal[flag]+=i;
                continue;
            }
            if(numc[y]==0 && column[y]!=0){
                puzzle[x][y] = 0;
                row[x]+=i;
                column[y]+=i;
                diagonal[flag]+=i;
                continue;
            }
            if(numd[flag] == 0 && diagonal[flag]!=0) {
                puzzle[x][y] = 0;
                row[x]+=i;
                column[y]+=i;
                diagonal[flag]+=i;
                continue;
            }
            dfs(k+1);
            puzzle[x][y] = 0;
            row[x]+=i;
            column[y]+=i;
            diagonal[flag]+=i;
        }
        numr[x]++;
        numc[y]++;
        numd[flag]++;
    }

}
int main() {
    for(int i=0;i<4;i++)cin>>row[i];
    for(int i=0;i<4;i++)cin>>column[i];
    for(int i=0;i<2;i++)cin>>diagonal[i];
    for(int i=0;i<4;i++) {
        int x,y,value;
        cin>>x>>y>>value;
        puzzle[x][y]=value;
    }
    //行内最小
    for(int i=0;i<4;i++) {
        int sum = row[i];
        for(int j=0;j<4;j++) {
            sum-=puzzle[i][j];
        }
        for(int j=0;j<4;j++) {
            minx[i][j]=sum;
        }
        row[i] = sum;
    }
    //列内最小
    for(int j=0;j<4;j++) {
        int sum = column[j];
        for(int i=0;i<4;i++) {
            sum-=puzzle[i][j];
        }
        for(int i=0;i<4;i++) {
            minx[i][j]=min(sum,minx[i][j]);
        }
        column[j] = sum;
    }
    //对角线最小
    {
        diagonal[0] = diagonal[0]-(puzzle[0][0]+puzzle[1][1]+puzzle[2][2]+puzzle[3][3]);
        diagonal[1] = diagonal[1]-(puzzle[0][3]+puzzle[1][2]+puzzle[2][1]+puzzle[3][0]);
        for(int i=0;i<4;i++) {
            minx[i][i]=min(diagonal[0],minx[i][i]);
            if(puzzle[i][i]) {
                numd[0]--;
            }
        }
        for(int i=0;i<4;i++) {
            minx[i][3-i]=min(diagonal[1],minx[i][3-i]);
            if(puzzle[i][3-i]) {
                numd[1]--;
            }
        }
    }
    //生成序列
    for(int i=0;i<4;i++) {
        for(int j=0;j<4;j++) {
            if(!puzzle[i][j]) {
                vec.push_back(Node{i,j,minx[i][j]});
            }
            else {
                numr[i]--;
                numc[j]--;
            }
        }
    }
    sort(vec.begin(),vec.end(),cmp);
    dfs(0);
    return 0;
}
```

---

## 作者：Jason331 (赞：1)

解法：搜索 + 随机化（思维较简单）

## 题意简述

构造一个 $4 \times 4$ 的正整数矩阵。

使矩阵的每行、每列以及两条对角线之和符合给定的数。

矩阵中有 $4$ 个已经被确定的数。

保证给定的数据有解。

# 解法

首先，看到这么小的数据范围，第一想法肯定是搜索。

对于普通的搜索方式我就不做过多介绍了，相信其他题解已经讲得很详细了。

## 搜索的优化

此题比较像幻方或数独，这使得我在剪枝的时候有了一个奇妙的想法。

人类是如何填幻方或数独的，**能不能让我们的算法模拟人类的填法？**

对于玩过数独的人来说，众所周知，填数独的基本技巧：

>
> 当一行、一列或一条对角线中只剩一个没有填的方格时，可以立即根据该行、该列、该对角线的总和算出此方格应填的值。
>

### 如何用计算机来实现呢？

预处理出每行、每列、两条对角线还没填的数的总和，以及还没填的数的个数，并在搜索时相应维护这些值。

当发现当前位置是该行、该列或对角线中唯一没有确定的数时，立即根据没填的数的总和确定这个位置的值。

*注：当该位置是很多行、列、对角线中唯一未确定的值时，记得判断这几个值有无冲突。*

### 意外的剪枝

因为矩阵中都是正整数，所以对当前位置所处行、列、对角线的剩余数之和去最小值作为取值上限。

但是你会发现还是过不去，怎么办？

当你迷茫的时候，当你疯狂的时候，当你无聊的时候，当你不想写的时候，请想起我们的终极救星——

## 随机化

在当前位置的取值范围内随机搜索 $5$ 次。

如果整个搜索完后发现无解，那就再搜一遍，直到有解为止！

然后就过了。

## 完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int last_hang[4],last_lie[4],last_dj,last_fdj,un_hang[4],un_lie[4],un_dj,un_fdj;

struct node
{
	bool fixed;
	int value;
}maps[4][4];

void print()
{
	int i,j;
	for(i = 0;i < 4;i++)
	{
		for(j = 0;j < 4;j++)
		    printf("%d ",maps[i][j].value);
        printf("\n");
	}
}

void add(int x,int y,int reverse)
{
	const int add_value = maps[x][y].value * reverse;
	last_hang[x] -= add_value;
	last_lie[y] -= add_value;
	un_hang[x] -= reverse;
	un_lie[y] -= reverse;
	if(x == y)
	{
		last_dj -= add_value;
		un_dj -= reverse;
	}
    if(x + y == 3)
	{
	    last_fdj -= add_value;
	    un_fdj -= reverse;
	}
}

int get_min(int x,int y)
{
	int result = min(last_hang[x],last_lie[y]);
	if(x == y) result = min(result,last_dj);
    if(x + y == 3) result = min(result,last_fdj);
    return result;
}

vector <int> get_value(int x,int y)
{
	vector <int> result;
	if(un_hang[x] == 1)           result.push_back(last_hang[x]);
    if(un_lie[y] == 1)            result.push_back(last_lie[y]);
    if(x == y && un_dj == 1)      result.push_back(last_dj);
    if(x + y == 3 && un_fdj == 1) result.push_back(last_fdj);
    return result;
}

void dfs(int x,int y)
{
    if(x == 4)
	{
		print();
		exit(0);
	 } 
    if(y == 4)
    {
    	dfs(x + 1,0);
    	return;
	}
    if(maps[x][y].fixed)
    {
    	dfs(x,y + 1);
    	return;
	}
	vector <int> ready_value = get_value(x,y);
	if(ready_value.size())
	{
		const int now_value = *ready_value.begin();
		int i;
		for(i = 1;i < ready_value.size();i++)
		    if(ready_value[i] != now_value)
		        return;
        if(now_value > get_min(x,y) || now_value <= 0)
            return;
        maps[x][y].value = now_value;
        add(x,y,1);
        dfs(x,y + 1);
        add(x,y,-1);
        maps[x][y].value = 0;
        return;
	}
	const int lowest = 1,highest = get_min(x,y);
	if(highest < lowest)
	    return;
	int try_times = 5;
	while(try_times--)
	{
		maps[x][y].value = lowest + rand() % (highest - lowest + 1);
		add(x,y,1);
		dfs(x,y + 1);
		add(x,y,-1);
		maps[x][y].value = 0;
	}
}

int main()
{
	srand(time(NULL));
	int i,x,y;
	for(i = 0;i < 4;i++)
	{
	    scanf("%d",last_hang + i);
	    un_hang[i] = 4;
	}
    for(i = 0;i < 4;i++)
    {
        scanf("%d",last_lie + i);
        un_lie[i] = 4;
    }
    scanf("%d %d",&last_dj,&last_fdj);
    un_dj = un_fdj = 4;
    for(i = 0;i < 4;i++)
    {
    	scanf("%d %d",&x,&y);
    	scanf("%d",&maps[x][y].value);
    	maps[x][y].fixed = true;
    	add(x,y,1);
    }
    while(true)
        dfs(0,0);
	return 0;
}
```

---


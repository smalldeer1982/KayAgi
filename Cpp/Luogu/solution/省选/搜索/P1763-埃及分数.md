# 埃及分数

## 题目描述

**来源：BIO 1997 Round 1 [Question 3](http://www.olympiad.org.uk/papers/1997/bio/bio97r1q3.html)**

在古埃及，人们使用单位分数的和（形如 $\dfrac{1}{a}$ 的，$a$ 是自然数）表示一切有理数。如：$\dfrac{2}{3} = \dfrac{1}{2} + \dfrac{1}{6}$，但不允许 $\dfrac{2}{3} = \dfrac{1}{3} + \dfrac{1}{3}$，因为加数中有相同的。对于一个分数 $\dfrac{a}{b}$，表示方法有很多种，但是哪种最好呢？首先，加数少的比加数多的好，其次，加数个数相同的，最小的分数越大越好。如：
$$
\begin{aligned}
\frac{19}{45} &= \frac{1}{3} + \frac{1}{12} + \frac{1}{180}\\
\frac{19}{45} &= \frac{1}{3} + \frac{1}{15} + \frac{1}{45}\\
\frac{19}{45} &= \frac{1}{3} + \frac{1}{18} + \frac{1}{30}\\
\frac{19}{45} &= \frac{1}{4} + \frac{1}{6} + \frac{1}{180}\\
\frac{19}{45} &= \frac{1}{5} + \frac{1}{6} + \frac{1}{18}\\
\end{aligned}
$$
最好的是最后一种，因为 $\dfrac{1}{18}$ 比 $\dfrac{1}{180}, \dfrac{1}{45}, \dfrac{1}{30}$ 都大。  
注意，可能有多个最优解。如：
$$
\begin{aligned}
\frac{59}{211} &= \frac{1}{4} + \frac{1}{36} + \frac{1}{633} + \frac{1}{3798}\\
\frac{59}{211} &= \frac{1}{6} + \frac{1}{9} + \frac{1}{633} + \frac{1}{3798}\\
\end{aligned}
$$
由于方法一与方法二中，最小的分数相同，因此二者均是最优解。

给出 $a,b$，编程计算最好的表达方式。保证最优解满足：最小的分数 $\ge \cfrac{1}{10^7}$。 


## 说明/提示

$1 \lt a \lt b \lt 1000$

## 样例 #1

### 输入

```
19 45```

### 输出

```
5 6 18```

# 题解

## 作者：王熙文 (赞：104)

## 前言

偶然做到这题，看到讨论区有一个 [hack](https://www.luogu.com.cn/discuss/574016) 将所有的题解都叉掉了，因此就想用我的代码通过这个 hack。经过了两天的优化，代码终于过了，因此来发一篇题解。

upd 2023.7.17: 修改了一些细节，重新交了一下题解。

## 思路

首先发现题目要求单位分数的个数最少，且直接 dfs 可能会进入一个错解出不来，bfs 会空间超限，所以使用迭代加深搜索，从小到大枚举选的分数个数 $cnt$，并 dfs。

注意到题目也要求最大的分母最小，且如果限制了分母的最大值有利于剪枝，所以也将最大的分母迭代加深，设限制为 $ax$，$ax$ 从 $10^3$ 到 $10^7$ 每次乘 $10$。

可以参考下面这个代码理解一下。代码中 `ch` 表示当前选的数，`ans` 表示答案选的数。

```cpp
void dfs(int now,int a,int b)
{
	if(now==cnt+1)
	{
		if(a!=0) return;
		if(ans[1]==0 || ch[cnt]<ans[cnt])
		{
			for(int i=1; i<=cnt; ++i) ans[i]=ch[i];
		}
		return;
	}
	for(int i=ch[now-1]+1; i<=ax; ++i)
	{
		int gta=a*i-b,gtb=b*i,g=gcd(gta,gtb);
		gta/=g,gtb/=g;
		ch[now]=i,dfs(now+1,gta,gtb);
	}
}
```

这样并不能通过，考虑优化代码。以下是我加的几个优化：

* 设接下来选的分数为 $\dfrac{1}{i}$，则 $\dfrac{a}{b}\ge\dfrac{1}{i}$，所以 $i \ge \dfrac{b}{a}$。

* 因为后面选的分数一定小于当前，所以必须满足 $(cnt-now+1)\cdot \dfrac{1}{i} \ge \dfrac{a}{b}$ 才有可能满足。因此 $i \le \dfrac{(cnt-now+1)\cdot b}{a}$。

* 当 $now \le cnt-1$ 时，需要满足下一次 $i$ 存在（下一次 $i$ 的限制区间左端点小于等于右端点）。因为 $i$ 的限制有关 $a,b$ 的都是两个数的比例（$\dfrac{a}{b}$ 或 $\dfrac{b}{a}$），所以在考虑下一次的时候 $a,b$ 不需要约分。设下一次的 $a,b$ 为 $nxta,nxtb$。提出来 $\dfrac{nxtb}{nxta} \le i$ 和 $i \le ax$ 这两个条件，得 $\dfrac{nxtb}{nxta} \le ax$，即 $\dfrac{bi}{ai-b} \le ax$。所以 $i \ge \dfrac{axb}{axa-b}$。

* 用类似的方法推 $now \le cnt-2$（$\dfrac{axbi}{ax(ai-b)-bi} \le ax$）可以得到 $i \ge \dfrac{axb}{axa-2b}$。因此猜测对于任意的 $now$ 都有 $i \ge \dfrac{axb}{axa-(cnt-now)b}$。使用类似的方法可以证明。

* 假设 $cnt=3$，那么 $\dfrac{a}{b}=\dfrac{1}{x}+\dfrac{1}{y}+\dfrac{1}{z}=\dfrac{xy+xz+yz}{xyz}$。又因为 $x,y,z \le ax$，所以若 $a>cnt\cdot ax^2$ 或 $b > ax^3$，则无解。类似的，若在过程中 $ a > (cnt-now+1)\cdot ax^{cnt-now}$ 或 $b > ax^{cnt-now+1}$ 则无解。

* 当 $now=cnt$ 时，最后一个分数一定为 $\dfrac{a}{b}$，所以直接检查是否合法即可，不需要递归到下一层。

* 当 $now=cnt-1$ 时，还剩下两个分数。设 $\dfrac{a}{b}=\dfrac{1}{x}+\dfrac{1}{y}=\dfrac{x+y}{xy}$。所以 $a,b$ 同时乘上某个数（设其为 $z$）后分别等于 $x+y,xy$。因为 $x+y \le 2ax$，所以 $z \le \dfrac{2ax}{a}$，并不会太大。因此当 $z$ 小于等于某个阈值时，可以直接枚举 $z$，并解方程组 $\begin{cases}az=x+y\\bz=xy\end{cases}$ 即可得到最后两个分数，检查是否合法即可。

* 在上面优化的过程中，方程有不相等的两解当且仅当 $\Delta=(az)^2-4bz > 0$ 即 $z >\dfrac{4b}{a^2}$，因此枚举的时候下界为 $\lfloor \dfrac{4b}{a^2}\rfloor+1$。

使用这些优化后，便可以快速通过讨论区的 hack。

## 代码

代码中使用了 `__int128`，因为不确定是否会爆 `long long`。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int __int128
int ceil(int a,int b) { return (a+b-1)/b; }
int gcd(int a,int b) { return b==0?a:gcd(b,a%b); }
int a,b;
int cnt,ax;
int ch[1000010],ans[1000010];
int ppow[1000010];
int sum=0;
void dfs(int now,int a,int b)
{
    if(now==cnt-1 && min(ax*2/a,ax*ax/b)<=1000)
    {
        int tmp=min(ax*2/a,ax*ax/b);
        for(int i=(4*b/a/a)+1; i<=tmp; ++i)
        {
            int delta=a*i*a*i-4*b*i;
            int sqr=sqrtl((long double)delta)+2;
            while(sqr*sqr>delta) --sqr;
            if(sqr*sqr!=delta || (a*i+sqr)%2!=0) continue;
            ch[cnt-1]=(a*i-sqr)/2,ch[cnt]=(a*i+sqr)/2;
            if(ch[cnt-1]>ch[cnt-2] && ch[cnt]>ch[cnt-1] && ch[cnt]<ax)
            {
                ax=ch[cnt];
                for(int i=1; i<=cnt; ++i) ans[i]=ch[i];
                for(int i=1; i<=cnt; ++i) ppow[i]=min(ppow[i-1]*ax,(int)1e29);
            }
        }
        return;
    }
    if(now==cnt)
    {
        if(b%a!=0 || b/a<=ch[cnt-1]) return;
        ch[cnt]=b/a;
        if(ch[cnt]<ax)
        {
            ax=ch[cnt];
            for(int i=1; i<=cnt; ++i) ans[i]=ch[i];
            for(int i=1; i<=cnt; ++i) ppow[i]=min(ppow[i-1]*ax,(int)1e29);
        }
        return;
    }
    if(a>(cnt-now+1)*ppow[cnt-now] || b>ppow[cnt-now+1]) return;
    int l=max(ch[now-1]+1,max(ceil(b,a),ceil(b*ax,a*ax-(cnt-now)*b))),r=min(ax,(cnt-now+1)*b/a);
    if(now==cnt-1)
    {
        for(int i=l; i<=r; ++i) ch[now]=i,dfs(now+1,a*i-b,b*i);
    }
    else
    {
        for(int i=l; i<=r; ++i)
        {
            ch[now]=i;
            int g=gcd(a*i-b,b*i);
            dfs(now+1,(a*i-b)/g,b*i/g);
        }
    }
}
signed main()
{
    ppow[0]=1;
    long long re; cin>>re; a=re; cin>>re; b=re;
    int g=gcd(a,b); a/=g,b/=g;
    if(a==1) return cout<<(long long)b,0;
    cnt=2;
    while(1)
    {
        ans[cnt]=1e9;
        ax=1e3;
        while(ax<=1e7)
        {
            for(int i=1; i<=cnt; ++i) ppow[i]=min(ppow[i-1]*ax,(int)1e29);
            dfs(1,a,b);
            if(ans[1]!=0 && ans[1]!=1e9)
            {
                for(int i=1; i<=cnt; ++i) cout<<(long long)ans[i]<<' ';
                return 0;
            }
            ax*=10;
        }
        ++cnt;
    }
    return 0;
}
```

---

## 作者：Mights (赞：26)

# P1763 埃及分数
### 分析
看完这道题，首选 $\text{IDDFS}$

可以枚举 $S$，从 $1000 \sim 10^7$，每次 $S \leftarrow S \times 10$

控制搜索深度 $\text{maxDep}$，表示当前迭代加深搜索的最大深度（即 `Code Show` 中的 $\text{IDDFS}$）

上述代码如下：
```
while (!f)
{
	S = 100, maxDep++;
	while (S < 1e7 && !f)
		S = (S << 3) + (S << 1), f = IDDFS(n, m, 1);
}
```

我们考虑 $\text{IDDFS}$

现申请两个大小为 $25$ 的一维数组（足够了），一个叫 `res`，另一个叫 `ans`，`res` 帮忙取答案，`ans` 则准备输出最后最优的结果，设当前层数为 $i$

$\text{\color{SpringGreen}Optimization \ 1}$

如果已经枚举到最后一层（$\text{dep = maxDep}$），那么 $\frac{p}{q}$ 就只能分成原分式，但是还要判断 $a=1$ 和 $b>res_{dep-1}$

由于还要保证最后一个分数最大，即分母最小，还要判断 `ans` 数组已经有了答案，所以接下里就很简单了

如果上述条件都满足，则只需要用 `res` 记录一下答案，再用 $\text{memcpy}$ 复制一遍就可以了

$\text{\color{Blue}Optimization \ 2}$

由于分母递增，若前一分母为 $p'$ 需要满足 $p>p'$，又由于当前分数不能超过剩余部分，故有
$$\frac{1}{p} \leq \frac{a}{b} \Longrightarrow p \geq \frac{b}{a}$$
为了能在 $\text{maxDep}$ 层上分解完，须满足
$$(\text{maxDep}-\text{dep}+1)\ \times \frac{1}{p} \geq \frac{a}{b}$$
即
$$p \leq \frac{b(\text{maxDep}-\text{dep}+1)}{a}$$
考虑进一步紧缩下界

如果 $\text{dep}+1=\text{maxDep}$，为了保证下一层分母 $\frac{1}{\frac{a}{b}-\frac{1}{p}}$ 依然存在，需满足
$$\frac{1}{\frac{a}{b}-\frac{1}{p}} \leq S \Rightarrow \frac{bp}{ap-b} \le S \Rightarrow p \geq \frac{Sb}{Sa-b}$$
类似的在第 $i$ 层需满足
$$p \geq \frac{Sb}{Sa-(\text{maxDep}-i)b}$$
综上，
$$p \in \Big[\max\Big(p',\lceil \frac{b}{a} \rceil,\frac{Sb}{Sa-(\text{maxDep}-i)b}\Big),\min\Big(S,\frac{b(\text{maxDep}-i+1)}{a}\Big)\Big]$$
$\text{\color{SpringGreen}Optimization \ 3}$

当仅需枚举两个分母时，设剩余两个分母为 $x,y$，有
$$\frac{a}{b}=\frac{1}{x}+\frac{1}{y}$$
可以得出
$$\begin{cases}az=x+y\\bz=xy\end{cases} \Rightarrow x^2-azx-bz=0$$
考虑枚举 $z$

当 $\Delta=a^2z^2-4bz>0$ 时存在 $x \neq y$ 的解（当 $\Delta=0$ 时 $x=y$ 与规则相悖）

可以得到
$$x=\frac{az-\sqrt\Delta}{2},y=\frac{az+\sqrt\Delta}{2}$$
在求解时须验证 $\Delta$ 是否为完全平方数，如果是，令 $s=\sqrt\Delta$，还需验证 $2\ |\ az-s$

考虑 $z$ 的枚举上下界

由于 $x,y \leq s$，那么
$$az=x+y \le 2S \Rightarrow z \le \frac{2S}{a} \ \ \ \ \ bz=xy\leq S^2 \Rightarrow z \leq \frac{S^2}{b}$$
同时在求解时 $\Delta>0$，那么
$$\Delta=a^2z^2-4bz>0 \Rightarrow z>\frac{4b}{a^2}$$
综上
$$z \in \Big[\Big\lfloor\frac{4b}{a^2}+1\Big\rfloor,\min\Big(\frac{2S}{a} \frac{S^2}{b}\Big)\Big]$$
### Code show
```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll ans[25], res[25], S;
int n, m, maxDep;
bool f;
bool IDDFS(ll p, ll q, int dep)
{
	if (dep == maxDep)
	{
		if (p == 1 && q > res[dep - 1] && (q < ans[dep] || !ans[dep]))
		{
			res[dep] = q;
			memcpy(ans, res, sizeof(res));
			return true;
		}
		return false;
	}
	if (dep == maxDep - 1)
	{
		for (ll z = (q << 2) / p / p + 1; z < min((S << 1) / p, S * S / q); z++)
		{
			ll delta = p * p * z * z - (q << 2) * z, s = sqrt(delta);
			if (s * s != delta || p * z + s & 1)
				continue;
			res[dep] = p * z - s >> 1, res[dep + 1] = p * z + s >> 1;
			if (res[dep + 1] < ans[dep + 1] || !ans[dep + 1])
			{
				memcpy(ans, res, sizeof(res));
				return true;
			}
		}
		return false;
	}
	ll l = max(res[dep - 1], (q - 1) / p) + 1LL, r = (maxDep - dep + 1) * q / p;
	bool flag = false;
	for (int i = l; i < r; i++)
	{
		ll tx = p * i - q, ty = q * i, g = __gcd(tx, ty);
		res[dep] = i;
		if (IDDFS(tx / g, ty / g, dep + 1))
			flag = true;
	}
	return flag;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("data.in", "r", stdin);
	// freopen("data.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	while (!f)
	{
		S = 100, maxDep++;
		while (S < 1e7 && !f)
			S = (S << 3) + (S << 1), f = IDDFS(n, m, 1);
	}
	for (int i = 1; i <= maxDep; i++)
		printf("%lld ", ans[i]);
	return 0;
}
```

### 注意

本题解由 [**stonesx**](https://www.luogu.com.cn/user/762254) **原著**，若有意见请发短信给我，作者将及时处理！

---

## 作者：0Io_oI0 (赞：23)

先放上代码，然后再讲解：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll deep,s[11],ans[11],flag,a,b;
ll gcd(ll x,ll y){
	if(y==0)return x;
	else return gcd(y,x%y);
}
void dfs(ll a,ll b,int x){
	if(x>deep)return;
	if(a==1&&b>s[x-1]){
		s[x]=b;
		if(!flag||s[x]<ans[x])memcpy(ans,s,sizeof(ll)*(deep+1));
		flag=1;
		return;
	}
	ll l=max(b/a+1,s[x-1]+1);
	ll r=(deep-x+1)*b/a;
	if(flag&&r>=ans[deep])r=ans[deep]-1;
	for(ll i=l;i<r;i++){
		s[x]=i;
		ll gcdd=gcd(a*i-b,b*i);
		dfs((a*i-b)/gcdd,b*i/gcdd,x+1);
	}
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>a>>b;
    ll g=gcd(a,b);
    a/=g,b/=g;
	for(deep=1;deep<=10;deep++){
		dfs(a,b,1);
		if(flag){
			for(int i=1;i<=deep;i++)cout<<ans[i]<<' ';
			return 0;
		}
	}
}
```
代码中有一个全局变量 $deep$，用来规定搜索深度的上限。将其设为全局变量是为了方便跨函数调用（设成函数参数也可以）。

接下来就是 dfs 函数来深搜，其中有一个变量 $x1$ 表示搜索深度。函数中如果当前面的搜索深度大于规定搜索深度 $deep$，则直接返回，表示在当前规定搜索深度下，此状态一定不能到达搜索目标状态。

在主函数中，从小到大枚举深度界限 $deep$，每次让深度界限增加 $1$，并调用 dfs 函数，在新的深度界限下再次搜索。当 dfs 搜索到目标时后不再继续增加深度界限，此时 $deep$ 的值就能搜到的答案的最小深度。

**但是，众所周知单单就这样写代码 hack 会 TLE（即上面刚刚的代码不能 AC！**

所以我们还需要优化：

首先很容易发现暴力枚举每个位置的分母还是太慢了。我们可以发现，当搜到最后两个分母时，我们没有必要枚举，而是可以直接把最后两项分母列方程解出来，这样会比枚举快很多。那现在我们设最后两项分母为 $x$ 和 $y$，其中 $x<y$ ，它们的总和是 $\frac{a}{b}$， 即：$\frac{a}{b}=\frac{1}{x}+\frac{1}{y}=\frac{x+y}{xy}$。

因为 $a$ 和 $b$ 是互质的，等式要是有整数解，则存在一个整数 $k$ 满足：$\frac{x+y}{xy}=\frac{ak}{bk}$，则有：

$$\left\{\begin{matrix}x+y=ak
 \\
xy=bk
\end{matrix}\right.$$

把 $y$ 消掉以后，有：$x^2-akx+bk=0$。

这个方程要是有解，则判别式为：$\Delta =a^2k^2-4bk≥0$ 满足这个条件的话，则：$k≥\left \lceil \frac{4b}{a^2} \right \rceil $。

因此我们可以枚举 $k$，找到某个 $k$ 使得 $\sqrt{\Delta}$ 为整数，此时两个解分别为：

$$\left\{\begin{matrix}x=\frac{ak-\sqrt{\Delta}}{2}
 \\
y=\frac{ak+\sqrt{\Delta}}{2}
\end{matrix}\right.$$

要求这两个数也必须是整数，且 $y$ 要小于等于求出过的最后一项的分母，或者小于 $10^7$。如果 $y$ 大于 $10^7$ 可直接 ```break```。

好了，这就是优化思路，最后我放上**求最后两项分母的代码：**

```cpp
if(x1==deep-1){
    ll minK=ceil(sqrt(4*b/(a*a)));
		for(ll k=minK;;k++){
			ll delta=a*a*k*k-4*b*k;
			ll t=sqrt(delta),gd=-1;
			if(t*t==delta)gd=t;
			else if((t-1)*(t-1)==delta)gd=t-1;
			else if((t+1)*(t+1)==delta)gd=t+1;
			ll x=(a*k-gd)/2;
			ll y=(a*k+gd)/2;
			if(y>1e7||(flag&&y>=ans[deep]))break;
			if(gd<=0||(a*k-gd)%2!=0)continue;
			s[deep-1]=x;
			s[deep]=y;
			memcpy(ans,s,sizeof(ll)*(deep+1));
			flag=1;
			break;
		}
		return;
	}
```

---

## 作者：CNS_5t0_0r2 (赞：18)

**update on 2024-8-16：**

修正代码的错误。

## 【-1】前言

这题的剪枝真的太妙了，很难想象[巨佬](https://www.luogu.com.cn/user/353688)是怎么独立想出来这所有的剪枝的。

本题解没有包含所有的剪枝，只选了我认为最好理解的几条剪枝。

想学习所有的剪枝的右转[巨佬的题解](https://www.luogu.com.cn/article/qcyb4h7h)。

## 【1】本题大框架：迭代加深搜索（IDDFS）

看到 $1 < a < b < 1000$，可以猜测分数的个数不会很多，考虑搜索。

那么怎么搜？因为我们不能确定最少分数的个数（这是我们首要要求的），可以考虑枚举分数的个数再进行搜索。

这相当于每次限制了搜索树的深度，当确定一个深度发现了解，深度就不会再加深。

这种每次限制了深度的搜索就叫**迭代加深搜索（IDDFS）**（又称 IDS）。

我们明显感觉到，每次限制深度为 $dep$，那么搜索深度为 $dep + 1$ 时，搜索深度 $dep$ 对应的搜索树又会被重新搜一遍。浪费了一些时间。

所以这种搜索有什么优势呢？

如果我们不限定深度，那么我们可能花大力气搜出了一个答案但远没达到最优解（分数的个数超过正解），此时再及时回溯已经很难了（搜索树深度增加一层增加的节点数是指数级的），浪费的时间会更多。

```cpp
const int N = 11,INF = 1e7;//N为层数上限，INF为分母最大值
void dfs(int a,int b,int x){//(a/b)表示剩余分数大小，x表示当前搜索深度
	if(x > dep)//超过了限定深度，退出
		return;
	if(a == 1){//找到了解（此时x一定等于限定的深度dep，否则在dep更小的时候就会找到解）
		if(b > tmp[x - 1]){//如果当前的分母比上
			st[x] = b;
			if(!flag || tmp[x] < ans[x])//找到了更优解
				for(int i = 1;i <= dep;i++)
					ans[i] = tmp[i];
		}
		flag = 1;//标记为已经找到了答案
		return;
	}
	int l = max((b + a - 1) / a,tmp[x - 1] + 1),r = min((dep - x + 1) * b / a,INF);//下一个分数分母的上下界
	if(flag && r >= ans[dep])
		r = ans[dep] - 1;
	for(int i = l;i <= r;i++){
		tmp[x] = i;
        //请自行模拟分数加减法
		int A = a * i - b,B = b * i;
		int gcd = GCD(A,B);
		dfs(A / gcd,B / gcd,x + 1);
	}
}
signed main(){
	a = read();b = read();
	c = GCD(a,b);
	a /= c;b /= c;
	tmp[0] = 1;
	for(dep = 1;dep <= N - 1;dep++){//枚举深度
		dfs(a,b,1);
		if(flag){找到了答案
			for(int i = 1;i <= dep;i++)
				printf("%lld ",ans[i]);
			return 0;
		}
	}
	return 0;
}
```


## 【2】初步剪枝

~~其实在上方的代码中已经给出了。~~

就是这一段：

```cpp
int l = max((b + a - 1) / a/*(b + a - 1) / a = ceil(b / a)*/,tmp[x - 1] + 1);
int r = min((dep - x + 1) * b / a,INF);//下一个分数分母的上下界
if(flag && r >= ans[dep])
	r = ans[dep] - 1;
```

考虑上下界剪枝。

先考虑下界 $l$。这段代码中，$tmp_{x - 1}$ 为上一个分数的分母，按照题目要求，下一个分数的分母要更大，所以下界 $l$ **至少**为 $tmp_{x - 1} + 1$。又因为当前填的分数不能超过当前剩余的分数 $\frac{a}{b}$，所以有 $\frac{1}{tmp_{x}} \leq \frac{a}{b}$，移项得 $tmp_{x} \geq \frac{b}{a}$。又因为 $tmp_{x}$ 为正整数，所以 $tmp_{x}  \geq \lceil \frac{b}{a} \rceil$。综上，下界 $l =\max(tmp_{x - 1} + 1,\lceil \frac{b}{a} \rceil)$。

上界 $r$ 呢？由题意，$tmp_{x + 1},tmp_{x + 2},\dots,tmp_{dep} \geq tmp_{x}$，所以这些数的倒数小于 $\frac{1}{tmp_{x}}$，那么这些数倒数的和（包括 $\frac{1}{tmp_{x}}$）小于这些数的个数乘 $\frac{1}{tmp_{x}}$，即小于 $\frac{dep - x + 1}{tmp_{x}}$。但这些数的和刚好等于当前的 $\frac{a}{b}$，所以 $\frac{dep - x + 1}{tmp_{x}} > \frac{a}{b}$，移项得 $tmp_x < \frac{b(dep - x + 1)}{a}$，又因为 $tmp_x$ 为正整数，所以 $tmp_x \leq \lfloor \frac{b(dep - x + 1)}{a} \rfloor$。题目中还说了最小的分数 $\geq \frac{1}{10^7}$，所以上界 $r$ 不会超过 $10^7$，综合有 $r = \min(\lfloor \frac{b(dep - x + 1)}{a} \rfloor,10^7)$。

这里还有个小优化：当发现已经找到了解，那么如果当前的分数小于当前找到的最优解中最小的分数，那么接下来搜索到的解不会更优。

## 【3】神奇的剪枝

加了上下界剪枝依然无法通过本题，因为本题有一个很强的数据：

```
570 877
```

所以还要继续剪枝。

#### 【3.1】神奇的剪枝 1：

我们发现，限制深度可以大大优化搜索，那么是否可以每次限制一些其它参数，进一步优化搜索呢？

题目还要求最小的分数越大越好，即最小的分数分母越小越好，考虑每次限制分母的最大值 $A$。

我的枚举是这样的：

限制深度为 $dep$ 时，先设 $A = 10^5$（这个可以自己调），因为规定了最小的分数分母小于 $10 ^ 7$，所以 $A \leq 10^7$。

如果每次将 $A$ 加 $1$，那么这个剪枝就没有任何意义了。因为这要求 $A$ 的初值很接近 $10 ^ 7$ 才能避免超时，而两个相差 $1$ 的 $A$ 对应的搜索树基本一致，相当于重复搜了很多次。

所以，我们每次将 $A$ 乘 $10$，有了这个限制，就可以对搜索进行优化。

因为题目首要满足的是分数个数尽可能小，所以枚举深度的循环在外层。

```cpp
for(dep = 1;dep <= N - 1;dep++){//枚举深度
	ans[dep] = tmp[dep] = INF + 1;
	for(max_a = 100000;max_a <= INF;max_a *= 10){//即原文的A
		dfs(a,b,1);
		if(flag){//找到了答案
			for(int i = 1;i <= dep;i++)
				cout << ans[i] << ' ';
			return 0;
		}
	}
}
```

#### 【3.2】神奇的剪枝 2：

这是本题最难想到但也是最妙的地方。

每次层数最深的地方搜索树的节点个数巨大，考虑对最深的两层优化。

根据题意，在 $x = dep - 1$（倒数第二层）时，当前的 $\frac{a}{b} = \frac{1}{p} + \frac{1}{q} = \frac{p + q}{pq}(p < q,\gcd(a,b) = 1)$，因为 $a,b$ 互质，所以有：

$$ \begin{cases}
  p + q = ak \\
  pq = bk
\end{cases}$$

消元，得 $q = ak - p$，代入二式得 $p(ak - p) = bk$，整理得 $p^2 - akp + bk = 0$。

这是一个关于 $p$ 的一元二次方程，要求满足有正整数解，考虑枚举参数 $k$。

因为是一元二次方程，所以有 $\Delta = a^2k^2 - 4bk \geq 0$，解这个关于 $k$ 的一元二次不等式得 $k \geq \frac{4b}{a^2}$ 或 $k \leq 0$。又因为 $k$ 为正整数，所以 $k \geq \lceil \frac{4b}{a^2} \rceil$。

继续解方程，得 $p_1 = \frac{ak + \sqrt{\Delta}}{2},p_2 = \frac{ak - \sqrt{\Delta}}{2}$，要求为正整数，则 $\Delta$ 为完全平方数且 $2 | ak + \sqrt{\Delta}$，所以当不满时直接跳过。否则，令 $tmp_{dep - 1} = p_1,tmp_{dep} = p_2$ 即求得一组解。

$k$ 的下界 $l$ 确定了，接下来就确定上界 $r$。由上方方程的解，得 $ak = p_1 + p_2$。因为我们限定了分母最大值 $A$，所以 $p_1 < p_2 \leq A$，所以 $p_1 + p_2 < 2A$，即 $ak < 2A$，所以 $k < \frac{2A}{a}$。又因为 $k$ 为正整数，所以 $k \leq \lfloor \frac{2A}{a} \rfloor$。

这还没完，将 $ak = p_1 + p_2$ 代入原方程 $p^2 - akp + bk = 0$ 得 $bk = p_1p_2$，还是由 $p_1 < p_2 \leq A$，得 $p_1p_2 \leq A(A - 1)$，所以 $bk \leq A(A - 1)$ 得 $k \leq \lfloor \frac{A(A - 1)}{b} \rfloor$。

综上，$k$ 的上界 $r = \min(\lfloor \frac{2A}{a} \rfloor,\lfloor \frac{A(A - 1)}{b} \rfloor)$。

```cpp
if(x == dep - 1){
	const int l = ((b << 2) / (a * a)) + 1,r = min(((max_a << 1)) / a,max_a * (max_a - 1) / b);
	for(int i = l;i <= r;i++){
		int delta = a * a * i * i - ((b * i) << 2);
		int Sqrt = sqrt(delta);
		if(Sqrt * Sqrt != delta/*delta不为完全平方数*/ || ((a * i - Sqrt) & 1))
			continue;
		tmp[x] = (a * i - Sqrt) >> 1;tmp[x + 1] = (a * i + Sqrt) >> 1;
		if(!flag || tmp[dep] < ans[dep]){
			for(int i = 1;i <= dep;i++)
				ans[i] = tmp[i];
			flag = 1;
		}
	}
	return;
}
```

**update on 2024-8-16：**

感谢用户 @[wangjingtang](https://www.luogu.com.cn/user/1216833) 提供的一个 hack：

```
349 720
```

上面的代码会输出 ``5 9 9 16``，不符合题意，解决方法就是特判，当搜出不合法答案的时候直接跳过。

```cpp
if(x == dep - 1){
	int l = ((b << 2) / (a * a)) + 1,r = min(((max_a << 1)) / a,max_a * max_a / b);
	for(int i = l;i <= r;i++){
		int delta = a * a * i * i - ((b * i) << 2);
		int Sqrt = sqrt(delta);
		if(Sqrt * Sqrt != delta || ((a * i - Sqrt) & 1))
			continue;
		tmp[x] = (a * i - Sqrt) >> 1;tmp[x + 1] = (a * i + Sqrt) >> 1;
		if(tmp[x] <= tmp[x - 1] || tmp[x + 1] <= tmp[x])//这里需要特判，否则可能会搜出不合法的答案
			continue;
		if(!flag || tmp[dep] < ans[dep]){
			for(int j = 1;j <= dep;j++)
				ans[j] = tmp[j];
			flag = true;
		}
	}
	return;
}
```

# AC code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 11,INF = 1e7;
int dep;int max_a;
int tmp[N],ans[N];
int a,b,c;
bool flag;
int GCD(const int x,const int y){
	return y ? GCD(y, x % y) : x;
}
void dfs(const int a,const int b,const int x){
	if(x > dep)
		return;
	if(a == 1){
		tmp[x] = b;
		if(!flag || tmp[dep] < ans[dep])
			for(int i = 1;i <= dep;i++)
				ans[i] = tmp[i];
		flag = 1;
		return;
	}
	if(x == dep - 1){
		int l = ((b << 2) / (a * a)) + 1,r = min(((max_a << 1)) / a,max_a * max_a / b);
		for(int i = l;i <= r;i++){
			int delta = a * a * i * i - ((b * i) << 2);
			int Sqrt = sqrt(delta);
			if(Sqrt * Sqrt != delta || ((a * i - Sqrt) & 1))
				continue;
			tmp[x] = (a * i - Sqrt) >> 1;tmp[x + 1] = (a * i + Sqrt) >> 1;
			if(tmp[x] <= tmp[x - 1] || tmp[x + 1] <= tmp[x])
				continue;
			if(!flag || tmp[dep] < ans[dep]){
				for(int j = 1;j <= dep;j++)
					ans[j] = tmp[j];
				flag = true;
			}
		}
		return;
	}
	int l = max((b + a - 1) / a,tmp[x - 1] + 1);
	int r = min((((dep - x + 1) * b + a - 1) / a),max_a);
	if(flag && r >= ans[dep])
		r = ans[dep] - 1;
	for(int i = l;i <= r;i++){
		tmp[x] = i;
		const int A = a * i - b,B = b * i;
		const int gcd = GCD(A,B);
		dfs(A / gcd,B / gcd,x + 1);
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin >> a >> b;
	c = GCD(a,b);
	a /= c;b /= c;
	tmp[0] = 1;
	for(dep = 1;dep <= N - 1;dep++){
		ans[dep] = tmp[dep] = INF + 1;
		for(max_a = 100000;max_a <= INF;max_a *= 10){
			dfs(a,b,1);
			if(flag){
				for(int i = 1;i <= dep;i++)
					cout << ans[i] << ' ';
				return 0;
			}
		}
	}
	return 0;
}
```

---

## 作者：WangTianJiao (赞：7)

[题面](https://www.luogu.com.cn/problem/P1763)

# 分析题干

对于分数 $\dfrac{a}{b}$，要求把它拆分成 $n$ 个分子为 $1$ 的分数 $\dfrac{1}{i_1} + \dfrac{1}{i_2} + \cdots + \dfrac{1}{i_n}$，满足：

1. $i_1$ 到 $i_n$ **严格**递增
2. $n$ 尽可能小
3. 满足第一条时，$i_n$ 尽量小，即 $\dfrac{1}{i_n}$ 尽量大

# 思路

显然不能采用贪心策略而在一开始尽量使用大分数，否则可能使剩下的分数极小而又不能简单分解，不得不分解成很多分数，使最后解不是最优解。考虑搜索算法来找出解。

考虑解答树的结构。

显然每层的数目极大，单纯的广搜空间和时间都不能接受（**尤其空间**）。如果使用深搜，那么可能会陷入深度极大但对答案完全没有贡献的枝杈，从而**时间**完全不能接受。因此，我们需要更优秀的搜索方法。

## 迭代加深搜索（IDDFS）

简要介绍一下**迭代加深搜索**（**迭代深化深度优先搜索**）：

在这个搜索策略中，一个具有**深度限制**的深度优先搜索算法会不断重复地运行，并且同时**放宽**对于搜索深度的**限制**，直到找到目标状态。——百度百科

也就是说，我们进行正常的深度优先搜索，但是限制搜索的深度，如果搜索时**深度超过限制**，无论如何**立即回溯**，继续搜索其它状态，从而遍历解答树上深度不超过限制的所有状态。如果找不到解，那就扩大限制，再次搜索；一旦找到结果，立即**停止搜索**、停止继续扩大限制。

$Q$：这么做会导致深度低的节点反复被搜索，是否会导致浪费时间，以至于超时？

$A$：不会，因为解答树的每层状态数是成指数级增长的，前几层的状态数目相对于最后的一两层来说九牛一毛，即使反复搜索也成本不高。也就是说，即使假设我们提前知道解的深度，直接进行一次该深度的搜索，也比迭代加深搜索快不了多少。

显然，这种思路可以避免广搜的空间紧张，也可以避免深搜陷入无底洞。当然，搜索出的解一定层数最少。


迭代加深分数个数（即层数），每层不断枚举 $i$，从 $\dfrac{a}{b}$ 中减去 $\dfrac {1}{i}$，并向下传递：

- 剩下需要搜索的分数
- 上一个分母
- 当前层数
- 最大层数

以此进行搜索。

此时很容易发现一个优化：搜索到最后一层时不必再枚举，而是直接判定当前剩下的分数是否符合条件：分子为 $1$，分母大于上个分母。

```cpp
typedef long long ll;
ll vans[1000005], vnow[1000005];//vans是存储的当前层数最优解，vnow是不断更新的搜索解 
ll nowp, ansp;
bool lessthan(ll xa, ll xb, ll ya, ll yb)//xa/xb 是否小于 ya/yb 
{
	return xa * yb < ya * xb;
}


void dfs(ll step, ll a, ll b, ll lastb, ll maxstep)
{
	if (step > maxstep || a == 0)//IDDFS, 超过最大深度直接跳过
		return;
	ll g = gcd(a, b);
	a /= g;
	b /= g;//未保证互质，约分
	if (step == maxstep - 1)
	{
		if ((a != 1) || (b <= lastb))//最后一层直接判定，剩下的分数必须是合法解
			return;
		vnow[step] = b;
		if (ansp == 0 || b < vans[step])
		{
			for (ll i = 1; i <= step; ++i)
			{
				vans[i] = vnow[i];
			}
			ansp = step;
		}//拷贝结果
		return;
	}
	
	for (ll i = lastb + 1;i <= 1e7; i++)
	{
		if (lessthan(a, b, 1, i))//a/b小于1/i可直接跳过
			continue;
		
		ll newa = a * i - b;
		ll newb = i * b;//新的分子分母
		ll ng = gcd(newa, newb);
		newa /= ng;
		newb /= ng;//计算、约分
		vnow[step] = i;//装入答案
		dfs(step + 1, newa, newb, i, maxstep);
		vnow[step] = 0;
	}
}
int main()
{
	ll a, b;
	cin >> a >> b;
	ll maxdepth = 1;
	for (; maxdepth <= 1e5; ++maxdepth)//迭代加深最大深度
	{
		memset(vans, 0, sizeof(vans));
		memset(vnow, 0, sizeof(vnow));
		nowp = ansp = 0;
		dfs(1, a, b, 0, maxdepth);
		if (ansp)//找到答案立刻输出、退出
		{
			for (ll i = 1; i <= ansp; ++i)
			{
				printf("%lld ", vans[i]);
			}
			printf("\n");
			return 0;
		}
			
	}
	return 0;
}
```

发现严重超时，连 $\dfrac{2}{3}$ 这种小数字都超时，需要剪枝。

## 剪枝 #1

思考可行性剪枝：搜索中各个分数值严格递减，而每一层最多剩下几个分数是固定的。显然，如果剩下的分数全部顶满最大值，仍小于剩下的分数，可以直接剪枝。

```cpp
bool notok(ll a, ll b, ll i, ll cnt)//若剩下层数全部填满与当前分数相同仍不足剩余分数，返回真
{
	return (cnt) * (1 / double(i)) < double(a) / double(b);
}
```

在搜索时写一句剪枝：

```cpp
if (notok(a, b, i, maxstep - step))//判断剩下的层数能否容纳剩下的分数
	break;
```

好些了。

按这样思路写好提交，分数介于 $40$ 到 $100$ 之间（实际分数我自己两次写好提交都不一样），但是仍有一个 subtask 超时。（搜索的时间复杂度是 $O(玄学)$，两次可能差着一点常数）

## 剪枝 #2

事实上，最大分母的量级很大，使得每一层搜索工作量极大。在每次搜索时，由一次固定最大分母搜索，改为多次层数相同、但最大分母差异较大的搜索。如果最大分母每次 $+1$ 显然功效不大，可以由 $10^3$ 每次 $\times 10$ 到 $10^7$。

```cpp
	ll maxdepth = 1;
	for (; maxdepth <= 1e5; ++maxdepth)//迭代加深最大深度
	{
		ll maxb = 1000;
		while (maxb <= 10000000)//迭代加深最大分母，最多5次，不会浪费大量时间
		{
			memset(vans, 0, sizeof(vans));
			memset(vnow, 0, sizeof(vnow));
			nowp = ansp = 0;
			dfs(1, a, b, 0, maxdepth, maxb);
			if (ansp)//找到答案立刻输出、退出
			{
				for (ll i = 1; i <= ansp; ++i)
				{
					printf("%lld ", vans[i]);
				}
				return 0;
			}
			maxb *= 10;
		}
	}
```

但是即使这样仍然不能通过 subtask。它层数极多，前面的剪枝不能通过，因此还需要剪枝。

## 剪枝 #3（最妙的剪枝）

考察最后两层搜索，它们占了主要的时间。

我们想求 $\dfrac {a}{b} = \dfrac{1}{x} + \dfrac{1}{y}$ 的整数解，通分得 $\dfrac {a}{b} = \dfrac{x+y}{xy} $，由于 $\gcd(a,b)=1$，所以存在正整数 $k$，使得：
$$
\begin {cases}
ka=x+y\\
kb=xy
\end {cases}
$$
根据韦达定理，$x,y$ 是下面这个方程的两个解：
$$
q^2-kaq+kb=0
$$
此时 $\Delta = k^2a^2-4kb$，为了有两个不等的实根，须有 $\Delta > 0$，化简得 $k>\dfrac{4b}{a^2}$。

简单枚举 $k$，计算这个方程的两个根 $x,y$，即可在一次循环中求得剩余两层的解而无需再搜索。

在枚举 $k$ 时应有范围限制：已经求得 $k>\dfrac{4b}{a^2}$，还需求得上界。

设最大分母为 $maxb$，有：
$$
x<y\\
ka=x+y<2y<2\times maxb\\
k < \dfrac{2maxb}{a}\\
kb=xy<maxb(maxb-1)\\
k<\dfrac{maxb(maxb-1)}{b}\\
$$

即
$$
k \in \left( \dfrac{4b}{a^2},\min \left( \dfrac{2maxb}{a}, \dfrac{maxb(maxb-1)}{b}\right) \right)
$$
还需验证 $\Delta$ 是完全平方数。

计算：
$$
x=\dfrac{ka-\sqrt{\Delta}}{2}\\
y=\dfrac{ka+\sqrt{\Delta}}{2}\\
$$
此处 $ka$ 和 $k^2a^2$ 同奇偶，$-4kb$ 不影响奇偶性，若 $\Delta$ 是完全平方数时 $ka$ 也和 $\sqrt{\Delta}$ 同奇同偶，从而分子是偶数，保证了解是整数。

此时 $x,y$ 即是解，直接装入。

```cpp
for (ll k = 4 * b / (a * a); k <= min(2 * maxb / a, maxb * (maxb - 1) / b); ++k)
{
	ll delta = (k * k * a * a) - (4 * k * b), x, y;//计算判别式
	ll s = sqrt(delta);
	if (abs(sqrt(delta) - s) > eps || delta <= 0)//判别式必须是完全平方数，保证x,y均为整数
		continue;
	y = ((k * a) + s) >> 1;
	x = ((k * a) - s) >> 1;//计算x,y
	if (x < 0 || y < 0)
		continue;
	if ((ansp == 0 || y < vans[step + 1]))//当前解更优
	{
		for (ll i = 1; i <= step; ++i)
		{
			vans[i] = vnow[i];
		}
		vans[step] = x;
		vans[step + 1] = y;
		ansp = step + 1;
		break;
	}
}
return;
```

此时这段代码能搜能剪，性能十分优越，因而此时可以用 $0.4s$ ~ $0.6s$ 的时间通过 hack 数据。

[完整代码](https://www.luogu.com.cn/paste/h3rbpa1c)

---

## 作者：gavinliu266 (赞：5)

# Subtask 0
## 思路
可以使用 IDDFS。

在枚举分母时，设还有 $h$ 层，还要加 $\frac{a}{b}$，则接下来的数最小是 $\frac{a}{hb}$，否则所有数加起来一定小于所求分数。

注意判断一下序列是否合法（是否存在负数），不然会错 Subtask 0 一个点。

这样就可以通过 Subtask 0，但是无法通过 hack 数据。

## 代码实现
```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;
typedef long long ll;
#define __gf(ax, bx) (int)ceil(double(bx) / double(ax))
int a, b, mh = 1;
int d[1000005], ans[1000005];
bool dfs(int h, int m, ll ax, ll bx) {
    if(h == mh) {
        if(bx % ax) return false;
        d[h] = bx / ax;
        if((ans[h] == -1 || d[h] < ans[h]) && d[h] > 0 /* 这里不加会 WA 一个点 */) memcpy(ans, d, (h + 1) << 2);
        return true;
    }
    bool f = false;
    int ff = max(m, __gf(ax, bx));  // 分母 ff 必须大于上一个的分母，并且 1/ff <= ax/bx
    for(int i = ff; bx * (mh + 1 - h) > i * ax; ++i) { // 若接下来所有分母都是 1/bx，还无法达到需要的水平，则停止
        d[h] = i;
        ll by = bx * i;         // 通分
        ll ay = ax * i - bx;
        ll gcd = __gcd(ay, by);
        if(dfs(h + 1, i + 1, ay / gcd, by / gcd)) f = true;
    }
    return f;
}
int main() {
    scanf("%d%d", &a, &b);
    memset(ans, -1, sizeof(ans));
    while(++mh) {   // 迭代加深搜索
        if(dfs(0, __gf(a, b), a, b)) {    // 如果成功，则打印答案，这样可以最小化长度，使得答案最优
            for(int i = 0; ans[i] != -1; ++i)
                printf("%d ", ans[i]);
            return 0;
        }
    }
}
```
# 正解
## 思路
很明显，每一层的搜索量都是指数级增长的。

所以，考虑优化最后两层。

设剩下来 $\frac{a}{b}$，接下来两个分数为 $\frac{1}{x}$，$\frac{1}{y}$，则 $\frac{1}{x} + \frac{1}{y} = \frac{a}{b}$，即 $\frac{x + y}{xy} = \frac{a}{b}$。

设 $\begin{cases} x + y = ak \\ xy = bk\end{cases}$，则 $-y^2 + aky - bk= 0$。

判别式为 $\Delta = a^2k^2 - 4bk \ge 0$。

解该方程组，得 $\begin{cases} x = \frac{ak \mp \sqrt{\Delta}}{2} \\ y = \frac{ak \pm \sqrt{\Delta}}{2} \end{cases}$。

由题意，$\frac{1}{x} > \frac{1}{y}$，所以 $\begin{cases} x = \frac{ak - \sqrt{\Delta}}{2} \\ y = \frac{ak + \sqrt{\Delta}}{2} \end{cases}$。

接下来考虑 $k$ 的范围。

该方程有解，所以 $\Delta > 0$，但当 $\Delta = 0$ 时 $\frac{1}{x} = \frac{1}{y}$，加数相等。

所以只能 $\Delta = a^2k^2 - 4bk > 0$。又因为 $k > 0$（不然两个分数的分子或分母会出现负数或 $0$），所以 $k > \frac{4b}{a^2}$。

因为 $x, y < 10^7$，所以设 $M = 2 \times 10^7$，则 $x+y=ak<2M$，$x y = bk < M(M - 1)$。

所以 $\frac{4b}{a^2} < k < \operatorname{min}(\frac{M}{a}, \frac{M(M - 1)}{2})$。

再加一些关于整数的判断即可。

## 代码实现
```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;
typedef long long ll;
#define __gf(ax, bx) (int)ceil(double(bx) / double(ax))
const ll M = 1e7;
int a, b, mh = 1;
int d[105], ans[105];
bool dfs(int h, int m, ll ax, ll bx) {
    if(h == mh) {
        if(bx % ax) return false;
        d[h] = bx / ax;
        if((ans[h] == -1 || d[h] < ans[h]) && d[h] > 0) memcpy(ans, d, (h + 1) << 2);
        return true;
    }
    if(h == mh - 1) {
        for(ll k = 4 * bx / ax / ax + 1; k <= min(M / ax, M * (M - 1) / bx); ++k) {
            ll dt = ax * ax * k * k - 4 * bx * k;
            ll sd = sqrt(dt);
            if(sd * sd != dt) continue;  // sqrt(dt) 为小数
            if((ax * k - sd) & 1) continue; // 分母为小数
            ll ta = (ax * k - sd) >> 1;
            ll tb = (ax * k + sd) >> 1;
            if(ta > M || tb > M) return false;
            d[h] = ta;
            d[h + 1] = tb;
            if((ans[h + 1] == -1 || d[h + 1] < ans[h + 1]) && d[h + 1] > 0)
             	memcpy(ans, d, (h + 2) << 2);
            return true;
        }
        return false;
    }
    int ff = max(m, __gf(ax, bx));
    bool f = false;
    for(int i = ff; i * ax < bx * (mh + 1 - h)  && i <= (int)1e7; ++i) {
        d[h] = i;
        ll by = bx * i;
        ll ay = ax * i - bx;
        ll gcd = __gcd(ay, by);
        if(dfs(h + 1, i + 1, ay / gcd, by / gcd)) f = true;
    }
    return f;
}
int main() {
    scanf("%d%d", &a, &b);
    memset(ans, -1, sizeof(ans));
    while(++mh) {
        if(dfs(0, __gf(a, b), a, b)) {
            for(int i = 0; ans[i] != -1; ++i)
                printf("%d ", ans[i]);
            return 0;
        }
    }
}
```

---

## 作者：smydahaoren (赞：4)

思路
--------------

这道题目可以使用迭代加深搜索，不过直接搜索肯定是会超时的，所以要做一定的剪枝。

先分析一下搜索的思路。枚举分数从大向小，这样可以保证输出方式是题目要求的顺序（分母从小到大），在枚举完一种情况后，用这种情况储存的数组和最优情况的数组最后一个分母大小进行比较，判断哪一种情况更好。

根据这种想法维护两个数组 ```ansnow``` 和 ```ans```。```ansnow``` 用来储存当次枚举的答案，```ans``` 用于纪录目前最优解。$now$ 变量用于储存当次枚举到第几个分数，$deep$ 用于储存总共需要的分数个数。

以下是一些剪枝。

- 可以限制枚举分母的范围，假设要枚举的分母是 $x$。显然的，当 $a\not= 1$ 时（当 $a=1$ 时已经进行特判了），$\frac{1}{x}<\frac{a}{b}$。因此可以推出 $x>\frac{b}{a}$。所以 $x\ge \lfloor \frac{b}{a} \rfloor+1$。

- 又因为根据分母从小到大的顺序。所以 $x\ge ansnow_{now-1}+1$。

- 因为可以求出接下来剩下的分数个数为 $deep-now+1$，并且剩下来的单位分数不应该相等，所以 $\frac{a}{b}\times \frac{1}{(deep-now+1)}<\frac{1}{x}$。因此 $x< \frac{(deep-now+1)\times b}{a}$。

剪枝剪完了之后，代码应该是以下这个样子。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e7+9;
int n,m,ans[N],ans1[N];
void turn(int deap){
	for(int i=1;i<=deap;i++)
		ans[i]=ans1[i];
}
int gcd(int aa, int bb) { return bb == 0 ? aa : gcd(bb, aa % bb); }
bool dfs(int now,int a,int b,int deap){
	if(now>deap)
		if(a==0){
			if(ans1[deap]<ans[deap]){
				turn(deap);
			}
			return true;
	}
	else
		return false;
	bool flag=false;
	int q=b/a;
	for(int x=max(q,ans1[now-1]+1);x<=(deap-now+1)*q;x++){
		ans1[now]=x;
		int da=a*x-b;
		int db=b*x;
		int g=gcd(a,b);
		da/=g,db/=g;
		if(dfs(now+1,da,db,deap)) flag=1;
	}
	
	return flag;

}
signed main(){
	cin>>n>>m;
	int g=gcd(n,m);
	n/=g,m/=g;
	for(int deap=1;;deap++){
		ans[deap]=N;
		if(dfs(1,n,m,deap)==true){
		for(int i=1;i<=deap;i++)
		cout<<ans[i]<<" ";
			break;	
		}
	} 
	return 0;
}


```

提交后会发现 ```Hack``` 数据过不了，原因是因为时间复杂度还是太大了，那么需要更有效的剪枝。

当只剩下最后两个分数枚举时，也就是 $now=deep-1$ 时，因为按照之前的方法枚举量太大，所以导致了超时。

观察 $\frac{a}{b}=\frac{1}{x}+\frac{1}{y}$ 这个式子。经过通分移项后可以得到 $\frac{a}{b}=\frac{x+y}{x\times y}$。

因此可以得到以下方程：

$$\begin{cases}x+y=ac\\ x\times y=bc\end{cases}$$

接下来就相当于接一个一元二次方程 $n^2-acn+bc$。其中 $x$ 和 $y$ 分别是方程两根。

不妨设 $x<y$，所以 $\begin{cases}x=\frac{ac-\sqrt{(ac)^2-4bc}}{2}\\ y=\frac{ac+\sqrt{(ac)^2-4bc}}{2}\end{cases}$。

由此可以得知 $(ac)^2-4bc>0$。又因为 $c$ 是正整数，所以 $c\ge \lfloor \frac{4b}{a^2}\rfloor+1$。得知了 $c$ 的下限之后要找到其上限。但是其上限没办法明确得知，因此只能用题目中给出的 $10^7$。但是这样做还是会超时，如果缩小范围，会导致其他点过不去，因此只能枚举分母的范围 $M$。

最后只要判断 $x$,$y$ 是否是正整数即可。

AC 代码
--------------
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e7;
int n,m,ans[11],ansnow[11],M;
bool flag;
void turn(int deep){
	for(int i=1;i<=deep;i++)
		ans[i]=ansnow[i];
}
int gcd(int o, int p) { return p == 0 ? o : gcd(p, o % p); }
void dfs(int now,int a,int b,int deep){
	if(now>deep) return;
	if(a==1){//当到达最简分数时直接返回数值。
		ansnow[now]=b;	
			turn(deep);
		flag=1;
		return;
	}
	if(now == deep - 1){
		int Min=(b*4/a/a)+1,Max=min(2*M/a,M*M/b);
		for(int z=Min;z<=Max;z++){
			int delta=a*a*z*z-4*b*z;
			int Delta=sqrt(delta);
			int tmp=(a*z-Delta)/2;
			if(Delta*Delta!=delta||tmp<=0)
				continue;
			ansnow[now]=(a*z-Delta)/2;ansnow[now+1]=(a*z+Delta)/2;
			if(ansnow[deep]<ans[deep]){
				turn(deep);
				flag=1;
				break;
			}
		}
		return;
	}

	for(int x=max(b/a+1,ansnow[now-1]+1);x<=(deep-now+1)*b/a;x++){	
		ansnow[now]=x;
		int da=a*x-b;
		int db=b*x;
		int g=gcd(da,db);
		da/=g,db/=g;
		dfs(now+1,da,db,deep);
	}
}
signed main(){
	cin>>n>>m;
	int g=gcd(n,m);
	n/=g,m/=g;
	for(int deep=1;;deep++){
		ans[deep]= N + 1;
		for(M=1e5;M<=N;M*=10){
			dfs(1,n,m,deep);
			if(flag){
				for(int i = 1;i <= deep;i++)
					cout << ans[i] << " ";
				return 0;
			}
		}
	}
	return 0;
}
```


------------
若本题解出现问题，请私信 [smydahaoren](www.luogu.com.cn/user/800468/)。

---

## 作者：wsm52 (赞：3)

# 前言
这道题的剪枝真的太酷啦（~~基本上想不到~~）！
# 思路
这道题得用**迭代加深搜索（IDDFS）**。

**有以下几种剪枝。**

1.假设 $\frac{a}{b}=\frac{998}{999}$，我们使 $\frac{1}{2} + \frac{1}{4} + \frac{1}{8}+\dots=\frac{a}{b}$（最差情况），则最多需要 $\log_{2}1000 \approx 10$ 个分数。

2.求分母的左边界。我们知道 $\large\frac{1}{p_{idx}} \le \frac{a}{b}$，化简得 $\large p_{idx} \ge \frac{b}{a}$，又因为 $p_{idx}\in N_{+}$，所以最小的分母为 $\max(p_{idx-1}+1,\lceil \frac{b}{a} \rceil)$。

3.求分母的右边界。我们知道 $\large \frac{1}{p_{idx+1}},\frac{1}{p_{idx+2}} \dots \frac{1}{p_{dep}} < \frac{1}{p_{idx}}$、$\large\frac{1}{p_{idx}}+\frac{1}{p_{idx+1}}+\frac{1}{p_{idx+2}}+ \dots +\frac{1}{p_{dep}}=\frac{a}{b}$，可以得出 $\large\frac{dep-idx+1}{p_{idx}} > \frac{a}{b}$，化简得 $\large p_{idx} \le \frac{(dep-idx+1)	\times b}{a}$，又因为 $p_{idx} \le 10^7$ 且 $p_{idx}\in N_{+}$，所以最大的分母为 $\min(10^7,\lfloor\frac{(dep-idx+1) \times b}{a}\rfloor)$。

4.如果已经有结果了，那么最大分母为 $\min(\min(10^7,\lfloor\frac{(dep-idx+1) \times b}{a}\rfloor),p_{dep}-1)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL N=1e7;
LL a,b,q[11],p[11];
int dep;
bool flag=false;
LL gcd(LL x,LL y){//最大公约数 
	return y==0?x:gcd(y,x%y);
}
void dfs(LL a,LL b,int idx){
	if(idx>dep) return;//超出所规定的深度，返回 
	if(a==1){ 
		if(b>p[idx-1]){//判断分母是否大于上一个分母 
			p[idx]=b;
			if(!flag||p[idx]<q[idx]){//如果没有答案 或者 现在最后一个分母比上一个答案的最后一个分母小 
				for(int i=1;i<=idx;i++) q[i]=p[i];//赋值 
				flag=true;//已经有答案 
			}
		}
		return;
	}
	LL lf=max(p[idx-1]+1,(a+b-1)/a),rt=min(N,(dep-idx+1)*b/a);//剪枝2、3 
	if(flag&&rt>=p[dep]) rt=p[dep]-1;//剪枝4 
	for(LL i=lf;i<=rt;i++){//枚举分母 
		p[idx]=i;
		LL son=a*i-b,mth=b*i;
		LL k=gcd(mth,son);
		dfs(son/k,mth/k,idx+1);
	}
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	scanf("%lld%lld",&a,&b);
	LL c=gcd(a,b);
	a/=c,b/=c;//先给分数化简 
	p[0]=1;
	for(dep=1;dep<11;dep++){//枚举深度，剪枝1 
		dfs(a,b,1);
		if(flag){//如果有结果，直接输出 
			for(int i=1;i<=dep;i++) printf("%lld ",q[i]);
			return 0;
		}
	}
	return 0;
}
```

到这里就可以拿 $100$ 分了，但是邪恶的 hack 数据会**超时**。所以还要剪枝。

5.我们还可以枚举最大分母的大小，建议 $N$ 从 $10^5$ 开始，每次乘 $10$（不知道是作者代码原因还是其他，如果 $N$ 从 $10^3$ 或者 $10^4$ 开始会 **WA**）。
```cpp
for(dep=1;dep<11;dep++){//枚举深度 
		for(N=1e5;N<=1e7;N*=10){//枚举分母范围，剪枝5
			dfs(a,b,1);
			if(flag){//如果有结果，直接输出 
				for(int i=1;i<=dep;i++) printf("%lld ",q[i]);
				return 0;
			}
		}
	}
```
6.最后一个剪枝就厉害了。当我们搜索到倒数第二个分数时，可以进行特殊处理。此时 $\large \frac{a}{b}=\frac{1}{p}+\frac{1}{q}=\frac{p+q}{p \times q}$。

设$\large\begin{cases}
    p+q=a \times k  \\
    p \times q=b \times k
\end{cases}$
，$k \in N_{+}$

通过第一条式子可以得出 $q=a \times k-p$，将其带入第二条式子，得 $p \times (a \times k-p)=b \times k$，化简得 $p^2-a \times k \times p+b \times k=0$，则 $\varDelta=a^2 \times k^2-4 \times b \times k \ge 0$，解一元二次不等式的过程如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/0d703clv.png)

因为 $k\in N_{+}$，所以 $k\ge\lceil\frac{4 \times b}{a^2}\rceil$。

根据公式可得 $p=\frac{a \times k \pm \sqrt{\varDelta}}{2}$，要求 $p\in N_{+}$，$\varDelta$ 为完全平方数且 $2\mid a \times k \pm \sqrt{\varDelta}$（判断一种情况就行了）。得出的解 $p_1$、$p_2$即为最后两个分母。

最后一步就是要求 $k$ 的取值范围了，我们已经求出 $k\ge\lceil\frac{4 \times b}{a^2}\rceil$，还需要求 $k$ 的右边界。已知 $p_1+p_2=a \times k$，因为 $p_1<p_2\le N$（$N$为最大能取的分母），所以 $a \times k<2 \times N$，化简得 $k<\frac{2 \times N}{a}$，又因为 $k \in N_{+}$，所以 $k \le \lfloor\frac{2 \times N}{a}\rfloor$；已知 $p_1 \times p_2=b \times k$，$p_1<p_2\le N$，所以 $a \times k \le N \times (N-1)$，化简得 $k \le \frac{N \times (N-1)}{a}$，又因为 $k \in N_{+}$，所以 $k \le \lfloor\frac{N \times (N-1)}{a}\rfloor$。所以综上所述，$k=\min(\lfloor\frac{2 \times N}{a}\rfloor,\lfloor\frac{N \times (N-1)}{a}\rfloor)$。

# AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
LL a,b,q[11],p[11],N;
int dep;
bool flag=false;
LL gcd(LL x,LL y){//最大公约数 
	return y==0?x:gcd(y,x%y);
}
void dfs(LL a,LL b,int idx){
	if(idx>dep) return;//超出所规定的深度，返回 
	if(a==1){
		if(b>p[idx-1]){//判断分母是否大于上一个分母 
			p[idx]=b;
			if(!flag||p[idx]<q[idx]){//如果没有答案 或者 现在最后一个分母比上一个答案的最后一个分母小 
				for(int i=1;i<=idx;i++) q[i]=p[i];//赋值 
				flag=true;//已经有答案 
			}
		}
		return;
	}
	if(idx==dep-1){//剪枝6 
		LL lf=(b*4/(a*a))+1,rt=min(2*N/a,N*(N-1)/b);
		for(LL i=lf;i<=rt;i++){
			LL d=a*a*i*i-4*b*i;
			LL k=sqrt(d);
			if(k*k!=d||((a*i-k)&1)) continue;
			p[idx]=(a*i-k)>>1;
			p[dep]=(a*i+k)>>1;
			if(p[idx]<=p[idx-1]||p[dep]<=p[idx]) continue;
			if(!flag||p[dep]<q[dep]){
				for(int j=1;j<=dep;j++) q[j]=p[j];
				flag=true;
			}
		}
		return;
	}
	LL lf=max(p[idx-1]+1,(a+b-1)/a),rt=min(N,(dep-idx+1)*b/a);//剪枝2、3 
	if(flag&&rt>=p[dep]) rt=p[dep]-1;//剪枝4 
	for(LL i=lf;i<=rt;i++){//枚举分母 
		p[idx]=i;
		LL son=a*i-b,mth=b*i;
		LL k=gcd(mth,son);
		dfs(son/k,mth/k,idx+1);
	}
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	scanf("%lld%lld",&a,&b);
	LL c=gcd(a,b);
	a/=c,b/=c;//先给分数化简 
	p[0]=1;
	for(dep=1;dep<11;dep++){//枚举深度，剪枝1 
		for(N=1e5;N<=1e7;N*=10){//枚举分母范围，剪枝5 
			dfs(a,b,1);
			if(flag){//如果有结果，直接输出 
				for(int i=1;i<=dep;i++) printf("%lld ",q[i]);
				return 0;
			}
		}
	}
	return 0;
}
```
# 结尾
我从来没有做过剪枝这么巧妙的题。这道题花费了我一天的时间，虽然还有其他剪枝没写，但是收获也很大。希望大家多刷刷有挑战的题，长长见识，增长才干，在赛场上取得优异成绩！

---

## 作者：LZYAC (赞：2)

## 思路

首先由于搜索树巨大，无法使用单独的 DFS，因为可能进入错误的子节点从而浪费大量的时间；也无法使用 BFS，因为空间需求太大。所以使用 IDDFS。[不会的点这里](https://oi-wiki.org/search/iterative/)。

接下来发现 TLE 了，考虑剪枝。

+ 对 IDDFS 本身的优化

发现不止可以限制层数，还可以限制分数的最小值（通过控制分母的最大值来实现）这里选取每次 $\times 10$ 的方法来减小搜索树的规模。

+ 卡扩展子树时的上下界

在扩展子树时，我们发现有相当一部分的分数是不可能的。

对于下界：比上一个分数 $lst$ 大，所以至少有 $lst+1$，并且不能超过当前剩余的分数大小，即 $\frac{1}{x} < \frac{a}{b}$ 移项之后变成 $x>\frac{b}{a}$ 因为是整数所以 $x \ge \lceil \frac{b}{a} \rceil$ 两者取更小的就可以了。

对于上界：不小于限制的分数最小值且假设从这个开始，后面的全部设为 $\frac{1}{i}$ ，那么必须使得 $\frac{maxd+1-d}{i} > \frac{a}{b}$ 如果不行的话自然全都不行，因为这是最优的情况。移项之后变成 $\frac{b(maxd+1-d)}{a}>i$ 跟上面一样将左边向上取整将 $>$ 变成 $\ge$。两者取更大的。

详见代码。

+ 对于最后两层的优化 

这样可以 AC 除了最后一个点以外的其他点。

```570 877``` 这组数据将搜索树变得极大导致无法很快的求出来。发现最后两个数在恶劣的情况下都会变得很大，我们运用初中数学知识设出来：

$$\frac{1}{x}+\frac{1}{y}=\frac{a}{b}$$

然后通分后变成 $\frac{x+y}{xy}=\frac{a}{b}$。

因为都是整数，所以有：

$\begin{cases}
x+y=ka\\
xy=kb
\end{cases}$

那么根据韦达定理，我们只用解 $-y^2+kay-kb=0$ 这个东西的两个解就行了。

算出 $\Delta = k^2a^2-4kb$ 然后求根公式得到:

$\begin{cases}
x=\frac{ka-\sqrt{\Delta}}{2}\\
y=\frac{ka+\sqrt{\Delta}}{2}
\end{cases}$

在计算时枚举 $k$ 注意 $\Delta >0$，因为等于 $0$ 时两根相等不符合定义，可以卡 $k$ 的下界。并且注意到 $x$ 和 $y$ 都小于规定的最大分母，同样用来卡上界，设最大分母是 $C$ 那么 $x+y=ka<2C$ 并且 $xy=kb<C(C-1)$。则 $k<\frac{2C}{a}$ 且 $k<\frac{C(C-1)}{b}$。
就可以通过了。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int a,b,maxd,maxs,flag,al,del,ax,bx,tmp,path[15],ans[15];
double sum;
void dfs(int d,int lst,int aa,int bb){
	if(d==maxd){
		if(bb%aa!=0||bb/aa>maxs||bb/aa<=lst) return ;
		flag=true;
		path[maxd]=bb/aa;
		if(path[maxd]<ans[maxd]){
			for(int i=1;i<=maxd;i++){
				ans[i]=path[i];
			}
		}
		return ;
	}
	if(d==maxd-1){
		for(int k=4*bb/aa/aa+1;k<min(2*maxs/aa,maxs*(maxs-1)/bb);k++){
			del=aa*aa*k*k-4*bb*k;tmp=sqrt(del);
			if(tmp*tmp!=del||(aa*k-tmp)%2==1) continue;
			ax=(aa*k-tmp)/2;bx=(aa*k+tmp)/2;
			if(ax>maxs||bx>maxs) return ;
			flag=true;
			path[d]=ax;path[d+1]=bx;
			if(path[d+1]<ans[d+1]){
				for(int i=1;i<=maxd;i++){
					ans[i]=path[i];
				}
			}
			return ;
		}
		return ;
	}
	int l=ceil(bb*1.0/aa),r=ceil((maxd+1-d)*bb*1.0/aa);
	r=min(r,maxs);
	l=max(l,lst+1);
	for(int i=l;i<=r;i++){
		int na=i*aa-bb,nb=i*bb;
		int tmp=__gcd(na,nb);
		na/=tmp,nb/=tmp;
		path[d]=i;
		dfs(d+1,i,na,nb);
	}
}
signed main(){
	cin.tie(0);
	cout.tie(0);
	ios::sync_with_stdio(false);
	cin>>a>>b;
	sum=a*1.0/b;
	memset(ans,0x7f,sizeof ans);
	for(maxd=1;maxd;maxd++){
		for(maxs=10;maxs<=10000000;maxs*=10){
			dfs(1,0,a,b);
			if(flag==true){
				for(int i=1;i<=maxd;i++) cout<<ans[i]<<" ";		
				return 0;
			}
		}
	} 
	return 0;
}
```

---

## 作者：Chenaknoip (赞：2)

一道 IDA* 的经典题目。
### 0 pts
考虑进行 DFS。设 $\frac{a}{b}=\sum _{i=1}^p a_i (2 \le i)$，由于 $a_i$ 单调递增，所以可以每次调用 DFS 函数时将 $\frac{a}{b}$ 减去 $\frac{1}{i}$，直到 $\frac{a}{b} = 0$，即 $a=0$。

但这样操作的时间复杂度过高，对于 $\frac{2}{3}$ 这样的小数据都会超时，因此考虑引入 IDDFS。

在 DFS 中引入一个递归深度变量 $\text{limit}$，并在主函数中进行多次 DFS，每次将 $\text{limit}$ 的值加一，直到搜索到合法的答案为止（在本题中指搜索到至少一组 $a_i$）。下面是形式化代码：
```cpp
void dfs(int lim, /* 你想传入的参数 */) {
    if (lim == 0) {
        // 记录答案
        return;
    }
    for (int i = preans + 1; i <= maxans; i++) {
        if (ok(i)) dfs(lim - 1, /* 更新后的答案 */);
    }
}
```
但这样仍然会超时，因此我们需要一些针对这道题的优化。
### hacked 100 pts
1. 输出递归的中间结果就会发现，代码在递归树的最后一层进行了大量无意义的递归，这使得复杂度远超允许范围。因此考虑当 $\text{lim}=1$ 时直接判断答案是否合法。因为当 $\text{lim}=0$ 时 $x=0$，所以当 $\text{lim}=1$ 时应有 $x=1,y\in [2, 10^7]$。
2. 每次递归时，由于 $i$ 过大会导致答案不可能算出，因此每次循环 $i$ 不必一定循环到 $10^7$。因为接下来有 $\text{lim}$ 个分数等待被当前状态的 $\frac{a}{b}$ 减去，因此当 $\text{lim} \times \frac{1}{i} \ge \frac{a}{b}$ 时可退出循环。
3. $\frac{1}{a_i} > \frac{x}{y}$，其中 $x$ 和 $y$ 表示 $\frac{x}{y}=\frac{a}{b}-\sum a_{visited}$。
```cpp
void dfs(int lim, int x, int y, int lb) {
	if (lim == 1) {
		if (x == 1 && lb < y && y < flag) {
			for (int i = 1; i < v.size(); i++) {
				ans[i] = v[i];
			}
			ans[ans.size() - 1] = y;
			flag = y;
		}
		return;
	}
	for (int i = max(y / x, lb) + 1; i <= 1e7 && lim * y >= i * x; i++) {
		v.push_back(i);
		int tmpx = i * x - y, tmpy = i * y, tmp = __gcd(tmpx, tmpy);
		dfs(lim - 1, tmpx / tmp, tmpy / tmp, i);
		v.pop_back();
	}
}
```
### 100 Accepted
这时需要一些数学技巧。

对于 $\text{lim}=2$ 时，可以对其列不定方程 $x\times k=p+q$，$y\times k=pq$，其中 $p$ 和 $q$ 表示剩下的两个分数为 $\frac{1}{p}$，$\frac{1}{q}$。于是得到剩下的两个分数。注意方程由两不同实根当且仅当 $\Delta > 0$。类似的，有 $k \le \frac{2 \times b_{\text{max}}}{x}$。

参考 IDDFS，也可以在主函数中对 $b_{\text{max}}$ 进行类似的操作。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a, b, v[100010], ans[100010], ptr = 1;
int flag = 0x7f7f7f7f, maxb;
void dfs(int lim, int x, int y, int lb) {
	if (lim == 1) {
		if (x == 1 && lb < y && y < flag) {
			for (int i = 1; i < ptr; i++) {
				ans[i] = v[i];
			}
			ans[ptr] = y;
			flag = y;
		}
		return;
	}
	if (lim == 2) {
		for (int k = 4 * y / x / x + 1; k <= min(2 * maxb / x, maxb * (maxb - 1) / b); k++) {
			int tmp = sqrt(x * x * k * k - 4 * y * k);
			if (tmp * tmp == x * x * k * k - 4 * y * k) {
				if ((x * k + tmp) & 1) continue;
				int tmpx = (x * k - tmp) / 2, tmpy = (x * k + tmp) / 2;
				v[ptr++] = tmpx;
				dfs(1, 1, tmpy, tmpx);
				v[--ptr] = 0;
			}
		}
		return;
	}
	if (lim * y < x * (lb + 1)) return;
	for (int i = max(y / x, lb) + 1; i <= maxb && lim * y > i * x; i++) {
		v[ptr++] = i;
		int tmpx = i * x - y, tmpy = i * y, tmp = __gcd(tmpx, tmpy);
		dfs(lim - 1, tmpx / tmp, tmpy / tmp, i);
		v[--ptr] = 0;
	}
}
signed main() {
	scanf("%lld%lld", &a, &b);
	int gcd = __gcd(a, b);
	a /= gcd; b /= gcd;
	for (int i = 1; i < 100000; i++) {
		maxb = 1000;
		while (maxb <= 10000000) {
			dfs(i, a, b, 1);
			if (flag != 0x7f7f7f7f) {
				for (int j = 1; j <= i; j++) {
					printf("%lld ", ans[j]);
				}
				return 0;
			}
			maxb *= 10;
		}
	}
	return 0;
}
```

---

## 作者：DengDuck (赞：2)

一道很经典的迭代加深搜索题。

我们考虑对于俩东西迭代加深，一个是数字的数量 $Cnt$，一个是最大值的规模 $Mx$。

前者的原因很显然，因为我们希望数字的数量尽可能小，同时如果不这么做的话我们的搜索是没有尽头的（悲）。

后者的原因是啥呢？后者可以方便我们在等一下剪枝的时候确定一个上界出来。

### 优化 1

考虑优化枚举 $\dfrac 1 i$ 的那个 $i$ 的范围：

- 下界考虑 $\dfrac 1 i \leq \dfrac a b \iff i\geq \dfrac b a$。
- 上界考虑 $\dfrac 1 i$ 会比后面分数都大所以 $\dfrac {Cnt-D+1} i \geq \dfrac a b\iff\dfrac {(Cnt-D+1)b} a \geq i$，这里的 $D$ 表示 $\dfrac 1 i$ 是第几个数字。

于是乎你就可以获得 100 分的好成绩，但是会被 Hack。

### 优化 2

优化来自 @王熙文，太强了。

当 $D=Cnt-1$ 时我们可以直接设剩下俩数字是 $\dfrac 1 x$ 和 $\dfrac 1 y$，然后大力解方程：

$$
\begin{aligned}
&\frac 1 x+\frac 1 y=\frac a b\\
\Rightarrow &\frac {x+y}{xy}=\frac a b\\
\Rightarrow &\frac {x+y}{xy}=\frac {za} {zb} (z\in \Z)\\
\Rightarrow &
\begin{cases}
x+y=za\\
xy=zb
\end{cases}\\
\end{aligned}
$$

利用一些初中一元二次方程知识，我们知道可以利用 $\Delta$ 算下界，得到 $z> \dfrac{4B}{A^2}$。

我们还能利用当前答案（没有答案时用枚举的规模）算出 $z$ 的上界 $z\leq 2Ax$，如果这个上界小于一个阈值我们就枚举 $z$ 然后大力解方程就行。

实测这个阈值在 $20000$ 左右可以跑到 200ms 左右于是乎稳稳地过了。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=35;
LL A,B,Ans[N];
LL Ch[N],Cnt,Mx;
void Dfs(LL A,LL B,int D)
{
	LL GCD=__gcd(A,B);
	A/=GCD,B/=GCD;	
	LL R=Mx*2/A;
	if(D==Cnt-1&&R<=50000)
	{
		for(LL z=4*B/A/A+1;z<=R;z++)
		{
			LL De=A*A*z*z-4*B*z;
			LL Sq=sqrt(De);
			if(Sq*Sq!=De)continue;
			if((A*z+Sq)&1)continue;
			Ch[Cnt-1]=(A*z-Sq)/2,Ch[Cnt]=(A*z+Sq)/2;
			if(Ch[Cnt-1]>Ch[Cnt-2]&&Ch[Cnt]>Ch[Cnt-2]&&Ch[Cnt]<Mx)
			{
				Mx=Ch[Cnt];
				for(int i=1;i<=Cnt;i++)Ans[i]=Ch[i];
			}
		}
		return;
	}
	if(D==Cnt)
	{
		if(A==1)
		{
			if(B==Ch[D-1])return;
			Ch[D]=B;
			if(Ch[D]<Mx)
			{
				for(int i=1;i<=D;i++)Ans[i]=Ch[i];
				Mx=Ch[D];
			}
		}
		return;
	}
	LL L=(B+A-1)/A,r=B*(Cnt-D+1)/A;
	if(L<Ch[D-1]+1)L=Ch[D-1]+1;
	for(LL i=L;i<=r&&i<=Mx;i++)
	{
		LL A2=A*i-B,B2=B*i;
		Ch[D]=i;
		Dfs(A2,B2,D+1);
	}
}
int main()
{
	cin>>A>>B;
	for(Cnt=1;;Cnt++)
	{
		for(Mx=1000;Mx<=10000000;Mx*=10)
		{
			Dfs(A,B,1);
			if(Ans[1])
			{
				for(int i=1;i<=Cnt;i++)cout<<Ans[i]<<' ';
				return 0;
			}			
		}

	}
}
```

---


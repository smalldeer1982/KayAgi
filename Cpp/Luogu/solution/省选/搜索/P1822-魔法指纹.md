# 魔法指纹

## 题目描述

对于任意一个至少两位的正整数 $n$，按如下方式定义 $\mathrm{magic}(n)$：将 $n$ 按十进制顺序写下来，依次对相邻两个数写下差的绝对值。这样，得到了一个新数，去掉前导 $0$，则定义为 $\mathrm{magic}(n)$。特别地，若 $n$ 为一位数，则 $mag_ic(n)=n$。

例如：$\mathrm{magic}(5913)=482$，$\mathrm{magic}(1198)=081=81$，$\mathrm{magic}(666)=00=0$。

对任意一个数 $n$，反复迭代计算 $\mathrm{magic}$ 值直到 $n$ 变成一个一位数，可以得到一个序列 $[n,\mathrm{magic}(n),\mathrm{magic}(\mathrm{magic}(n)),\cdots]$。最后的这个值称为数 $n$ 的 $\mathrm{magic}$ 指纹。

例如，对于 $n=5913$，我们得到序列：$[5913,482,46,2]$。所以 $5913$ 的 $\mathrm{magic}$ 指纹为 $2$。

若一个数的 $\mathrm{magic}$ 指纹为 $7$，则认为这个数是个幸运数。

现在，给定 $A,B$，计算出 $[A,B]$ 中有多少个数是幸运数。

## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 数据，$B \le 10^4$。
- 对于 $100\%$ 数据，$0<A \le B \le 10^9$。


## 样例 #1

### 输入

```
1
9```

### 输出

```
1
```

# 题解

## 作者：_rqy (赞：79)

不明白为什么这题会被扔到“分块”里。

说一下我的做法（顺带一提，目前AC代码中除了打表的之外只有两个，另一个既看不明白有编译不过）。

首先写个暴力，可以发现$A=1,B=10^7$的时候答案也只有三万多。

我们考虑如果有一个图，每个顶点有一个数，然后从$magic[x]$到$x$连边，那么显然某个数的魔法指纹是$7$当且仅当从$7$可以到达它。那么我们从$7$开始广搜（图并不用实际建出来）。

广搜每次拓展时我们需要从$a$出发拓展出所有$magic[b]=a$的$b$。考虑枚举$b$的个位，那么因为$b$的十位与个位差的绝对值是$a$的个位，所以$b$的十位至多有两种可能；同理，确定$b$的十位后，其百位数至多有两种可能...如此做下去，最后最多拓展出$2^l$个数，其中$l$是$a$的位数。但实际上几乎不可能有那么多数，因为许多选择会使某一位上的数不在$[0,9]$范围内（实际上，如果$b$的前两位不等，容易证明$magic[b]\leq10^l\Rightarrow b\leq 10^{l+1}$，于是平均每个数能扩展出$10$个数）。这个过程可以$dfs$实现。

不过要注意一点：由于求$magic[b]$的定义是相邻两项取绝对值再去掉前导零，所以由$magic[b]$求$b$的时候可能要把$b$的最高位重复几遍，这样求出的$magic$不变（因为只是多了前导零）。

代码：

```cpp
#include <algorithm>
#include <cstdio>
typedef long long LL;
bool mm[10000050];
int p[10], A, B;
int queue[40000], num, head, tail;
void dfs(int x, LL y, int p10) {
  if (y > B) return;
  if (x == 0) {
    int last = y / (p10 / 10);
    if (!last) return;
    dfs(x, y + (LL)last * p10, p10 * 10);
    if (y >= A && y <= B) ++num;
    if (p10 < B) queue[tail++] = y;
    return;
  }
  int last = y / (p10 / 10), nxt = x % 10;
  x /= 10;
  if (last - nxt >= 0) dfs(x, y + p10 * (last - nxt), p10 * 10);
  if (nxt && last + nxt < 10) dfs(x, y + p10 * (last + nxt), p10 * 10);
}
int main() {
  scanf("%d%d", &A, &B);
  head = tail = num = 0;
  queue[tail++] = 7;
  if (A <= 7 && B >= 7) ++num;
  do
    for (int i = 0; i < 10; ++i)
      dfs(queue[head], i, 10);
  while (++head < tail);
  printf("%d\n", num);
  return 0;
}

```

---

## 作者：NaCly_Fish (赞：30)

题目链接：[P1822 魔法指纹](https://www.luogu.org/problemnew/show/P1822)  
  
这里来介绍一些间隔打表的方法和技巧。 
### 1，答案可递推，才适合间隔打表  
什么叫可递推呢？  
假设$\text{F}_n$为区间$[1,n]$的答案，那么$\text{F}_{n+1}$应该可以由很短的时间从$\text{F}_n$推出来。满足这个条件，就可以愉快地间隔打表辣！   
像这一题就是可递推的，递推式可以写成这样：  
```cpp
f[n] = f[n-1] + IsLucky(n);
```
### 2，间隔打表用法  
个人对于区间统计问题的用法是这样的：  
在这题中，记录$[1,10^6],[1,2*10^6]....[1,1000*10^6]$区间的答案，容易看出这是一个前缀和的形式。  
当我们要计算区间$[l,r]$的答案时，只需要计算$[1,r]-[1,l-1]$即可  
对于$[1,a]$的答案，可以拆成两部分计算，一部分是已经搞好的前缀和，一部分暴力计算。  
### 3，打表的间隔  
根据上面一段，可以发现打表的间隔越小，运行速度就越快。  
但是代码过长的话，是没办法提交的。这题单次递推的时间复杂度是$\Theta(\log n)$的，所以打表间隔用$10^6$就行了。  

这题表的生成器也非常好写，按照题意模拟就完了。  
大概就是这么多，我们把代码放上来吧qwq：    
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#define N 100003
#define p 998244353
#define reg register
using namespace std;

int a[15];
int table[1003] = {0,2045,3089,3839,4196,4512,4828,5186,5935,6979,8453,9319,10363,10666,10886,11040,11155,11239,11364,11710,12637,13015,13573,14323,14544,14748,14902,15020,15154,15300,15682,15792,16062,16365,16722,16898,17102,17270,17398,17487,17562,17647,17773,18071,18292,18608,18784,19004,19172,19260,19329,19398,19486,19654,19874,20050,20366,20587,20885,21011,21096,21171,21260,21388,21556,21760,21936,22293,22596,22866,22977,23359,23504,23638,23756,23910,24114,24336,25085,25643,26021,26948,27295,27419,27503,27618,27772,27992,28295,29339,30205,32227,32981,33205,33276,33362,33477,33645,33943,34501,35975,36601,37159,37277,37358,37409,37442,37461,37491,37807,39268,40134,41178,41481,41701,41855,41970,42054,42179,42525,43452,43562,44120,44214,44435,44531,44608,44656,44688,44714,44774,44848,45118,45234,45300,45395,45599,45717,45800,45855,45884,45934,46060,46178,46255,46305,46381,46494,46662,46719,46762,46806,46894,47002,47081,47121,47162,47206,47297,47395,47480,47521,47610,47679,47760,47794,47817,47847,47868,47948,48015,48151,48296,48370,48434,48485,48506,48528,48552,48587,48640,49129,49476,49551,49612,49663,49687,49700,49728,49900,49979,51122,51876,51923,51968,52019,52055,52070,52090,52319,53243,53483,53723,54021,54139,54208,54259,54287,54330,54393,54978,55844,56172,56475,56588,56665,56716,56751,56776,56838,57213,57591,58149,58899,59120,59324,59478,59596,59730,59876,60258,60325,60519,60822,60906,61082,61178,61259,61308,61340,61365,61412,61510,61808,61934,62003,62098,62318,62426,62478,62516,62559,62616,62784,62897,62973,63023,63100,63218,63344,63394,63442,63511,63639,63757,63817,63857,63891,63920,64016,64090,64246,64343,64477,64553,64630,64664,64691,64714,64740,64795,64957,65150,65274,65328,65397,65448,65471,65494,65529,65566,65877,66192,66416,66451,66509,66560,66582,66610,66682,66959,66984,67062,67180,67348,67413,67471,67506,67533,67547,67561,67943,68035,68151,68371,68472,68541,68594,68627,68666,68698,68808,69366,69460,69681,69777,69854,69902,69934,69960,70020,70130,70400,70703,71060,71236,71440,71608,71736,71825,71900,71934,72017,72135,72356,72420,72596,72709,72818,72860,72887,72925,72977,73085,73305,73400,73469,73595,73893,73991,74038,74073,74127,74196,74364,74460,74536,74595,74660,74854,74964,75015,75081,75155,75273,75374,75434,75478,75508,75555,75693,75725,75785,75860,75944,76009,76086,76138,76159,76184,76217,76241,76282,76329,76400,76452,76521,76577,76611,76646,76662,76685,76732,76823,76941,77056,77108,77153,77188,77204,77219,77389,77453,77518,77631,77785,77850,77911,77943,77975,77995,78373,78613,78692,78818,79022,79123,79187,79233,79260,79314,79381,79575,79878,79962,80138,80234,80315,80364,80396,80421,80506,80632,80930,81151,81467,81643,81863,82031,82119,82188,82215,82257,82366,82479,82655,82719,82940,83058,83141,83175,83204,83259,83342,83460,83664,83759,83825,83941,84211,84285,84326,84375,84453,84529,84683,84779,84856,84889,84967,85077,85100,85146,85195,85249,85364,85465,85544,85573,85596,85648,85663,85685,85738,85773,85859,85924,86005,86057,86083,86095,86107,86133,86185,86266,86331,86417,86452,86505,86527,86542,86594,86617,86646,86725,86826,86941,86995,87044,87090,87113,87223,87301,87334,87411,87507,87661,87737,87815,87864,87905,87979,88249,88365,88431,88526,88730,88848,88931,88986,89015,89049,89132,89250,89471,89535,89711,89824,89933,89975,90002,90071,90159,90327,90547,90723,91039,91260,91558,91684,91769,91794,91826,91875,91956,92052,92228,92312,92615,92809,92876,92930,92957,93003,93067,93168,93372,93498,93577,93817,94195,94215,94247,94279,94340,94405,94559,94672,94737,94801,94971,94986,95002,95037,95082,95134,95249,95367,95458,95505,95528,95544,95579,95613,95669,95738,95790,95861,95908,95949,95973,96006,96031,96052,96104,96181,96246,96330,96405,96465,96497,96635,96682,96712,96756,96816,96917,97035,97109,97175,97226,97336,97530,97595,97654,97730,97826,97994,98063,98117,98152,98199,98297,98595,98721,98790,98885,99105,99213,99265,99303,99330,99372,99481,99594,99770,99834,100055,100173,100256,100290,100365,100454,100582,100750,100954,101130,101487,101790,102060,102170,102230,102256,102288,102336,102413,102509,102730,102824,103382,103492,103524,103563,103596,103649,103718,103819,104039,104155,104247,104629,104643,104657,104684,104719,104777,104842,105010,105128,105206,105232,105508,105580,105608,105630,105681,105739,105775,105999,106314,106624,106661,106696,106719,106742,106793,106862,106916,107041,107234,107395,107450,107476,107499,107526,107560,107637,107713,107847,107945,108100,108174,108270,108299,108333,108373,108433,108551,108679,108748,108796,108846,108972,109090,109167,109217,109293,109406,109574,109631,109674,109712,109764,109872,110092,110187,110256,110382,110680,110778,110825,110850,110882,110931,111012,111108,111284,111368,111671,111865,111933,112315,112460,112594,112712,112866,113070,113292,114041,114599,114978,115352,115414,115439,115474,115525,115602,115715,116019,116346,117213,117797,117860,117903,117931,117982,118051,118169,118467,118708,118947,119871,120100,120120,120135,120171,120222,120267,120314,121068,122211,122290,122462,122490,122503,122527,122578,122639,122715,123061,123550,123603,123638,123662,123684,123705,123756,123820,123894,124039,124175,124242,124322,124343,124373,124396,124430,124511,124580,124669,124710,124795,124893,124984,125028,125069,125109,125188,125296,125384,125428,125471,125528,125696,125809,125885,125935,126012,126130,126256,126306,126335,126390,126473,126591,126795,126890,126956,127072,127342,127416,127476,127502,127534,127582,127659,127755,127976,128070,128628,128738,129665,130012,130136,130220,130335,130489,130709,131012,132056,132922,134383,134699,134729,134748,134781,134832,134913,135031,135589,136215,139782,142039,142127,142133,142153,142186,142221,142275,142589,144611,144982,145988,146122,146131,146140,146176,146229,146279,146471,147398,147455,147527,147611,147625,147636,147660,147708,147786,147884,148266,148312,148353,148376,148394,148403,148424,148480,148563,148632,148707,148757,148840,148892,148919,148940,148963,149015,149124,149181,149250,149294,149382,149490,149569,149609,149650,149694,149785,149883,149968,150003,150057,150126,150294,150390,150466,150525,150590,150784,150894,150948,150975,151021,151085,151186,151390,151516,151595,151835,152214,152588,152650,152675,152710,152761,152838,152951,153255,153582,154448,156470,157224,157448,157519,157605,157720,157888,158186,158744,160218};

inline int abs(int x);
inline int magic(int n);
inline bool check(int n);
void print(int x);
int calc(int n);

int main(){
    int a,b,l,r;
    scanf("%d%d",&l,&r);
    print(calc(r)-calc(l-1));
    return 0;
}

int calc(int n){
    int m = n%1000000;
    n /= 1000000;
    int res = table[n];
    n *= 1000000;
    m += n;
    for(int i=n+1;i<=m;++i)
        if(check(i)) ++res;
    return res;	
}

inline int abs(int x){
    return x<0?-x:x;
}

inline bool check(int n){
    while(n>9) n = magic(n);
    return n==7;
}

inline int magic(int n){
    int x = 0,i = 1;
    for(;n>0;++i){
        a[i] = n%10;
        n /= 10;
    }
    for(reg int j=i-1;j>1;--j)
        x = (x<<3)+(x<<1)+abs(a[j]-a[j-1]);
    return x;
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}
```  
### 4、例题1：  

给你两个正整数$l,r$，你需要求出区间$[l,r]$中有多少整数，它的二进制表示中有奇数个$1$。  
$1\le l\le r \le10^9$  
此题虽然用搜索+各种玄学剪枝优化也能过，但是这很明显可以间隔打表。  
暴力统计前缀和，然后按我们上面的做法就好。  
由于这题并不难，所以就不放代码了。  

### 5、例题2：  
[P1662 数7](https://www.luogu.org/problemnew/show/P1662)  这题就不是区间的问题了，但是我们依然可以用间隔打表来搞。  
这题的打表难度稍微高了一些，因为我们不仅要记录数到谁了，还要记下来下一次数的方向。  
这题的做法和前面也是大同小异。仍然是把询问拆成两块，一部分是算好的，一部分暴力即可。  
$\text{Code:}$
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;

bool cnt(int a){
	if(a%7 == 0) return true;
	while(a>0){
		if(a%10 == 7) return true;
		a /= 10;
    }
	return false;
}

int main(){
    int n,c,i,turn;
    int a[52] = {0,522,887,364,841,548,880,228,750,52,866,123,1167,162,370,892,1257,734,1328,396,64,716,194,1166,560,1303,259,1264,579,462,97,620,26,319,593,1278,1278,1278,1278,1278,1278,946,261,1076,437,960,366,659,327,119,934};
    int turns[52] = {0,1,0,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,1,0,1,0};
    scanf("%d",&n);
    c = n/20000000 + 1;
    i = a[c-1];
    turn = turns[c-1];
    c = (n/20000000)*20000000 + 1;
    while(c<=n){
        if(turn == 0) i++;
        else i--;
        i %= 1337;
        if(i == 0) i = 1337;
        if(cnt(c)) turn = 1-turn;
        c++;
    }
    printf("%d",i);
}
```
### 6，总结  
间隔打表是个常用的技巧，尤其是在数位dp等问题中，也可以骗不少分。如果常数比较优秀，甚至可以AC。  
所以：  
~~打表大法好，入教保平安~~

---

## 作者：miemieQWQ (赞：27)

- ***我不是来讲正解的***

**我很抱歉**我的这份题解可能辜负了这紫色的难度标签

话说这道题目拿到的第一反应除了暴力就是毫无思路对吧

应该可以大概猜到这题就是考你数学, 回忆一下NOIPD1T1

- ***数据那么少, 我们要打表!***

关键是这个表怎么打, 首先我们需要一个暴力程序算出一个数的魔法指纹, 系统自带的pow我用快速幂换掉了, 其他常数优化我懒得加, 反正线下处理有的是时间! 在这个数据下, 复杂度接近**O(1)**.

```cpp
inline int qpow(int x, int y)
{
    if (y == 0) return 1;
    int temp = qpow(x, y >> 1);
    if (y & 1) return temp * temp * x;
    else return temp * temp;
}
int magic(int x)
{
    int y = 0, num[10], i = -1;
    while (x) num[++i] = x % 10, x /= 10;
    for (int j = 0; j < i; j++)
        y += abs(num[j] - num[j+1]) * qpow(10, j);
    if (y < 10) return y;
    else return magic(y);
}
```
- ***分块大法好!***

整区间的无非就那么几种东西, 线段树树状数组有点杀鸡的感觉, 前缀和貌似不错(遗憾空间感觉会炸), 但分块就更赞了, 单个区间仅需**O(Sqrt(N))**.

我们先将所有的区间信息通过打表的方式处理好, 没有处理的地方就用暴力处理掉! 打表时间复杂度**O(NlogN)**

```cpp
int main()
{
    freopen("table.out", "w", stdout);
    int Len = 31623, res = 1, L, R;
    for (int i = 1; i <= Len; i++)
    {
        L = (i - 1) * Len + 1;
        R = min(1000000000, Len * i);
        for (int j = L; j <= R; j++)
            if (magic(j) == 7) res++;
        printf("%d,", res); res = 0;
    }
    return 0;
} 
```
通过上面的程序我们实现了对每个区间内的魔法指纹为7的个数统计, 为了保证我们的打表机正常工作, 先将数据调小试一试看看能不能用, 证明无误后就可以**挂机**了!!!!!!

- ***挂机1140ms过后***

要交的程序在下面, 复杂度**O(Sqrt(B))**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 35000, Len = 31623;
const int Cnt[] = {/*此处过于磅礴被我切掉了*/};
inline int qpow(int x, int y);
int magic(int x);
inline int ID(const int &x) { return (x + Len - 1) / Len; }
inline int L(const int &x) { return (ID(x) - 1) * Len + 1; }
inline int R(const int &x) { return ID(x) * Len; }
int main()
{
    int A, B, res = 0;
    scanf("%d%d", &A, &B);
    if (A <= 7 && 7 <= B) res++;
    
    if (ID(A) == ID(B))
    {
        for (int i = A; i <= B; i++)
            res += bool(magic(i) == 7);
        printf("%d\n", res); return 0;
    }
    for (int i = A; i <= R(A); i++)
        res += bool(magic(i) == 7);
    for (int i = L(B); i <= B; i++)
        res += bool(magic(i) == 7);
    for (int i = ID(A) + 1; i < ID(B); i++)
        res += Cnt[i];
    printf("%d\n", res);
    return 0;
} 
```
真是可怕, AC代码就我最长, 算了.


---

## 作者：asuldb (赞：9)

我们神奇的教练loli在考试里放了这道题，竟然能神奇的差点A掉

感觉这道题很搜索，而且有一种数位dp的感觉

反正我也不会写数位dp，那就写一个数位搜索吧

我们的起始状态就是$magic(7)=7$，那么我们就通过增加数位的搜索来扩展这个状态，同时在搜索的过程中减掉一些不合法的状态，这样就能不打表的优雅A掉了

具体看注释吧

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define re register
#define LL long long
using namespace std;
LL A,B;
LL ans=0;
LL w1,w2;
int num_10(LL T)
{
    int k=0;
    while(T)
    {
        k++;
        T/=10;
    }
    return k;
}//统计数位个数
inline LL read()
{
    char c=getchar();
    LL x=0;
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9')
      x=(x<<3)+(x<<1)+c-48,c=getchar();
    return x;
}
void se(LL f,int t,int p,int num[]);
void dfs(LL x,int step)//x表示当前的数,step表示当前的位数，每一层搜索往外扩展一位
{
    if(step<=w2&&x<=B&&x>=A) ans++;
    //如果当前的数在范围之内我们就增加答案
    if(step>=w2) return;//如果位数大于等于B的位数，我们就减掉
    int k=0,num[11];
    memset(num,0,sizeof(num));
    while(x)
    {
        num[++k]=x%10;
        x/=10;
    }//将x个各个数位拆开
    num[++k]=0;
    for(re int i=1;i<=9;i++)//枚举下一个状态的第一位数
        se(i,step,step+1,num);
    for(re int j=1;j+step+1<=w2;j++)//由于可能会出现一长串前导0，所以我们要枚举前导0的个数
    for(re int i=1;i<=9;i++)//还是枚举一个状态的首位
        se(i,step+j,step+j+1,num);
}
int main()
{
    A=read(),B=read();
    w1=num_10(A),w2=num_10(B);
    dfs(7,1);
    cout<<ans<<endl;
    return 0;
}
void se(LL f,int t,int p,int num[])//f是当前的数，t是num的位数，p是目标位数
{
    if(!t) //num的位数已经用完
    {
        dfs(f,p);//搜索一个新状态
        return;
    }
    if(f%10+num[t]<=9) se(f*10+f%10+num[t],t-1,p,num);//如果这一位加上对应的差没有超过9，那么可以是加
    if(f%10+num[t]==f%10-num[t]) return;//如果加和减得到的是一个数，那么就没有减得必要了
    if(f%10-num[t]>=0) se(f*10+f%10-num[t],t-1,p,num);//如果这一位减上对应的差没有小于，那么可以是减
}
```

---

## 作者：Cuiyi_SAI (赞：7)

#### 免责声明：我不是来讲正解的，这是写给OI入门学者们的分块题解

内容较水，有错误欢迎直接D

---
## 分块基础
- #### 分块思想

分块是一种优美的暴力。他的核心思想在于**将一个要维护的区间（长度为 $n$）分成有穷个 $\sqrt n$ 个子区间来进行分别维护**。每个子区间的长度都为 $\sqrt n$。


**我们所要查询的区间所覆盖的每个块的信息进行整合，就是我们要查询的区间的信息**。

这样将区间分块来处理有什么好处呢？可以感性理解，如果我们已经有了这个块的全部信息，那么下一次要查询包含这个块的区间信息时，就直接调用这个块就可以了。显然优化了不少。

---

- ### 分块区间的构造

分块区间构造起来思维难度不高，我们直接在代码中的注释进行讲解和理解。

```
int S,C=0,belong[500010],st[10010],en[10010],sum[10010]={0};

S代表每个块的长度，即为根号n取整。
C代表所分成的块的个数，一般也是根号n取整
belong[i]代表原区间中的第 i 个元素所属块的编号
st[i] 表示第 i 个块的左端点，同理 en[i] 代表右端点
sum[i] 代表第i个块元素信息的整合，对于这里的代码展现我使用的是和的形式

inline void build()
{
   S=int(sqrt(double(n)));  //求出S的大小
   for(register int i=1;i<=n;i+=S)  //为每个块设立左端点和右端点
   {
      st[++C]=i;
      en[C]=min(n,i+S-1);
   }
   for(register int i=1;i<=C;++i)  //枚举所有的块
   {
     for(register int j=st[i];j<=en[i];++j)  //遍历每个块中的元素，将他们所属的块的编号记录
     {
       belong[j]=i;  //表示第j个元素是第i块的
       sum[i]+=a[j];  //统计第i块元素的和
     }
   }
   return ;
}
```


---

- ### 分块区间单点修改

显而易见，只有此元素所在的块才会因为单点修改而产生改变，因此直接修改就好了。

```
inline void single(int x,int k)  在第x个位置加上k
{
  a[x]+=k;
  sum[belong[x]]+=k;   //在x所属块的信息集合sum数组中进行修改
  return ;
}
```

---

- ### 分块区间的区间修改

我们使用一个数组 $delta$ ，$delta_i$ 记录第 $i$ 个块 **整个块被修改的变化情况，当且仅当这个块被整块一起修改的时候，才会改变这个块的 $delta$**。

设要修改的区间的左端点是 $l$，右端点是 $r$，若 $[l,r]$ 的位置和我们已分好的一个块重合：

$$
\boxed{~~~~~~~~~~~~~}\quad\boxed{~~~~~~~~~~~~~}\quad\boxed{~~~~~~~~~~~~~}\quad\boxed{~~~~~~~~~~~~~}\quad\boxed{~~~~~~~~~~~~~}
$$
$$
\colorbox{Black}{~~~~~~~~~~~~~}
$$

ps:白色块为所分的块，黑色块为$[l,r]$


也就是说存在第 $i$ 个块使得 $st_i=x$且$en_i=y$，那么我们可以对这个块进行整块操作，即直接改变 $delta_i$ 的值。

```
  int l=belong[x],r=belong[y];
  if(l==r&&st[l]==x&&en[l]==y)
  {
    delta[l]+=k;  //记录第 l 个块的变化情况。
    return ;
  }
```

可是，要是 $x,y$ 并不是理想的刚好在一个块中，而是同时涉猎了三个块呢？

$$
\boxed{~~~~~~~~~~~~~}\,\boxed{~~~~~~~~~~~~~}\,\boxed{~~~~~~~~~~~~~}\,\boxed{~~~~~~~~~~~~~}\,\boxed{~~~~~~~~~~~~~}
$$
$$
\colorbox{Black}{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
$$

很简单，对于 $[l,r]$ 区间内，那些完整的块我们通过改变 $delta$ 来改变，而那些不完整的块，我们通过单点修改 $single$ 来一一改变他们的原值。

```
  for(register int i=x;i<=en[l];++i)  //改变左边的不完整区间
    single(i,k);
  for(register int i=st[r];i<=y;++i)  //改变右边的不完整区间
    single(i,k);
  for(register int i=l+1;i<r;++i)  //完整区间统一修改
    delta[i]+=k;
```

因此一个完整的区间修改函数 $range$ 就出来了

```
int delta[10010]={0};
inline void range(int x,int y,int k)
{
  int l=belong[x],r=belong[y];
  if(l==r&&st[l]==x&&en[l]==y)
  {
    delta[l]+=k;
    return ;
  }
  for(register int i=x;i<=en[l];++i)
    single(i,k);
  for(register int i=st[r];i<=y;++i)
    single(i,k);
  for(register int i=l+1;i<r;++i)
    delta[i]+=k;
  return ;
}
```

---

- ### 分块的区间查询

仍然考虑查询一个 $[l,r]$ 的区间，如果 $l,r$ 在同一个块内，那么也许会是这么一种情况：

$$
\boxed{~~~~~~~~~~~~~}\quad\boxed{~~~~~~~~~~~~~}\quad\boxed{~~~~~~~~~~~~~}\quad\boxed{~~~~~~~~~~~~~}\quad\boxed{~~~~~~~~~~~~~}
$$
$$
\colorbox{Black}{~~~}
$$
此时，$[l,r]$ 的确在一个块内，但是又并不是占据这整一个块，这种情况我们就需要特判处理

```
  int l=belong[x],r=belong[y],ans=0;
  if(l==r)
  {
    for(register int i=x;i<=y;++i)
      ans+=a[i]+delta[belong[i]];  //最朴素的对该区间进行求和，此时delta数组就派上用场了。
    return ans;
  }
```

对于区间查询，我们依旧可以尝试像区间修改那样思考，将区间所占据的块分为三部分：

1. 左边的不完整块
2. 中间的完整块
3. 右边的不完整块。

这样我们就可对区间进行有逻辑的查询。

对于左右不分，直接暴力处理即可，对于中间完整块，信息整合数组$sum$和变化记录数组$delta$的功能就体现出来了，他们极大程度的优化了完整块的处理。

```
  for(register int i=x;i<=en[l];++i)  //左半不完整部分
    ans+=a[i]+delta[belong[i]];
  for(register int i=st[r];i<=y;++i)  //右半不完整部分
    ans+=a[i]+delta[belong[i]];
  for(register int i=l+1;i<r;++i)  //完整的块直接利用sum和delta卡速累加即可
    ans+=sum[i]+delta[i]*(en[i]-st[i]+1);
```

这样就是一个完整的分块区间查询函数：

```
inline int query(int x,int y)
{
  int l=belong[x],r=belong[y],ans=0;
  if(l==r)
  {
    for(register int i=x;i<=y;++i)
      ans+=a[i]+delta[belong[i]];
    return ans;
  }
  for(register int i=x;i<=en[l];++i)
    ans+=a[i]+delta[belong[i]];
  for(register int i=st[r];i<=y;++i)
    ans+=a[i]+delta[belong[i]];
  for(register int i=l+1;i<r;++i)
    ans+=sum[i]+delta[i]*(en[i]-st[i]+1);
  return ans;
}
```
---
## 分块打表

相信此时的你已经对分块有了基础的认识，那么我们回到这道题目，如何利用分块来暴力解决呢？

如果你不会省选级别思维难度的搜索，那么在考场自然而然的思路就是**打表**。

但是很显然，这题的数据规模直接打表的话会爆程序长度，那么怎么办？限制打表的不是程序，而是人心。
我们可以选择**分块打表**

分块打表的思路和分块简直如出一辙：**我们直接线下求出每一个块的信息整合，也就是对于每个块进行打表，然后利用分块来合并信息。**

思路非常清晰，对于这题，我们可以将每个块的长度设为$1000000$，然后打表求得每个块的幸运数个数，然后利用分块算法流程来对所查询区间进行信息整合。

先奉上打表程序：
```
int n,tot=0,sum[1000010]={0};
int magic(int x)
{
	if(x<10) return x;
	int a[20],t=0;
	while(x)
	{
		a[++t]=x%10;
		x/=10;
	}
	int m=0;
	for(int i=t;i>=2;i--)
	{
		m=m*10+abs(a[i]-a[i-1]);
	}
	return magic(m);
}
int main()
{
	cin>>n;
	tot=1;
	for(int i=1;i<=n;i++)
	{
		if(i%1000000==0) sum[tot]+=sum[tot-1],tot++;
		sum[tot]+=(magic(i)==7);
	}
	for(int i=1;i<=tot;i++)
	  {
	  	if(sum[i]==0) break;
	  	cout<<sum[i]<<',';
	  }
	return 0;
} 
```
对于这段程序输出的是每一个长度为 $1000000$ 的块所含幸运数的前缀和。

有了打表的帮助，我们就等于有了每个块的信息（利用前缀和相减求区间和总会吧），然后直接如上文所讲利用这些块进行分块中的区间信息整合即可。

## CODE:	

```
#include <bits/stdc++.h>
using namespace std;
int sum[1010]={//已删减};
int st[1010],en[1010],S,tot;
int l,r;
int belong(int x)  //求当前元素所属块的编号
{
	if(x%1000000==0) return x/1000001+1;
	else return x/1000000+1;
}
void start()
{
  S=1000000;
  for(int i=1;i<=r;i+=S)
  {
    st[++tot]=i;
    en[tot]=i+S-1;
  }
  return ;
  //预处理块的左右端点
}
int magic(int x)  //求得magic值（本人蒟蒻，写得特别丑）
{
	if(x<10) return x;
	int a[20],t=0;
	while(x)
	{
		a[++t]=x%10;
		x/=10;
	}
	int m=0;
	for(int i=t;i>=2;i--)
	{
		m=m*10+abs(a[i]-a[i-1]);
	}
	return magic(m);
}
int range(int l,int r)  //分块思路的区间查询
{
  int ans=0;
  if(belong(l)==belong(r))
  {
    for(int i=l;i<=r;i++)
      ans+=(magic(i)==7);
    return ans;
  }
  ans=sum[belong(r)]-sum[belong(l)-1];
  for(int i=st[belong(l)];i<l;i++)
    ans-=(magic(i)==7);
  for(int i=r+1;i<=en[belong(r)];i++)
    ans-=(magic(i)==7);
  return ans;
}
signed main()
{
  ios::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);
  cin>>l>>r;
  start();
  cout<<range(l,r);
  return 0;
}
```

---

## 总结

这是蒟蒻的第一篇博客，望能通过本人的一点点微微的帮助，使得更多人在偶然中体会算法之美。

---

## 作者：wcwac (赞：5)

大家都知道这道题可以打表，但是怎样打表？


楼上的方法太过暴力


况且

### 跑得很慢


至少在学校这"烂"机器上没跑出来


非常怀疑其复杂度


所以

我们要优雅的打表


------------


考虑一下


$magic(5913)=482$


$magic(482)=46$


$magic(46)=2$


在计算magic(5913)时我们又重新计算了magic(482)


这个结果我们之前已经计算过


因此我们可以保存一下，直接用，就可以快速出结果


## 时间换空间！


我们发现，这其实就类似于并查集的路径压缩操作  ~~长得都一样~~


因为值可能为零 我们让初值为-1 访问过就变成0-9中的一个值


------------


``` cpp
char a[0..9]={0..9}
a[10..1E9]=-1;

inline int magic(register int x) {
    register int t=1,s=0;
    while (x>=10) {
        s+=abs((x%10)-(x/=10)%10)*t;
        t*=10;
    }
    return s;
}

inline int work(register int x) {
    return (a[x]==-1)?a[x]=work(magic(x)):a[x];
}
```

然后就可以较为优雅的做一个间隔为sqrt的表了


------------


这就结束了吗，事情并没有这么简单


本地这样打表是可以了，可是如果我们要往oj上交，要处理块外的数字，数组开不下怎么办？


1. 换朴素的暴力方案 就不用开数组了 楼上有讲


2. 一种巧妙的方案


为防止越界，我们在work()中加上

```cpp
while (x>N) x=magic(x);
```

赋初值memset太慢怎么办？


我们把它取个反省掉就好了，反正让值域不为零就行


最终成品


```cpp
char a[0..9]={~0..~9}
a[10..1E9]=0
inline int work(register int x) {
    while (x>N) x=magic(x);
    return !a[x]?a[x]=work(magic(x)):a[x];
}
```

不用初始化就会跑起来很快


最后的程序


```cpp
#include <bits/stdc++.h>
const int N=1e8+2e7,S=31623;
using namespace std;
int an[]={/* 打的表 */}
char a[N+20];
int ans;
inline int magic(register int x) {
    register int t=1,s=0;
    while (x>=10) 
        s+=abs((x%10)-(x/=10)%10)*t,t*=10;
    return s;
}

inline int work(register int x) {
    while (x>N) x=magic(x);
    return !a[x]?(a[x]=work(magic(x))):a[x];
}

int main() {
    int l,r,ll,rr;
    scanf("%d%d",&l,&r);
    for (int i=0;i<10;++i) a[i]=~i;
    ll=l/S;
    rr=r/S;
    if (ll==rr){
        for (int i=l;i<=r;++i) if (work(i)==~7) ans++;
        return printf("%d\n",ans),0;
    }
    for (int i=l;i<(ll+1)*S;++i) if (work(i)==~7) ans++;
    for (int i=ll+1;i<rr;++i) ans+=an[i];
    for (int i=rr*S;i<=r;++i) if (work(i)==~7) ans++;
    printf("%d\n",ans);
    return 0;
}
```

------------


~~学长说 内存就是拿来用的 不用就算浪费 hhh~~


~~楼上的打表方法肯定不是O(n)的~~


---

## 作者：foglake (赞：3)

这道题偷看标签的同学们一定知道是**搜索**。那么怎么搜呢？

看一下数据范围，十亿的范围枚举每个数搜会超时。但如果仔细审题就知道最后的结果 7 是确定的。所以我们可以倒着搜，也就是从 7 向能变成它的数逐层拓展。而且逆向操作的结果一定比原数大，所以原数超出范围就不用搜了。

### 一个要注意的地方

我们来看这样一组数据
```
1108
```
它的操作结果为 018 ，但 18 不会拓展到 1108 。所以我们拓展时要**补足前导零**。
# 代码：
```
#include <bits/stdc++.h>
using namespace std;
queue <int> q;
int ans;
int l, r;
void make_num(int n, int sum, int las, int len) {//造出符合要求的数。
    //n 代表操作数，sum 代表操作后的数，las 代表上一位数（用于推下一位），len 取当前n的首位。
    if (!len) {
        q.push(sum);//造出数后加入队列。
        return;
    }
    if (las - n / len >= 0 && n / len != 0)//因为差是绝对值所以分类讨论。
        make_num(n % len, sum * 10 + las - n / len, las - n / len, len / 10);
    if (las + n / len <= 9)
        make_num(n % len, sum * 10 + las + n / len, las + n / len, len / 10);
}
void bfs() {
    if (q.empty()) return;
    int x = q.front();
    q.pop();
    if (l <= x && x <= r) ans++;//在区间内答案加一。
    if (x >= r) { //超出区间就返回。
        if (!q.empty()) bfs();
        return;
    }
    int len = 1;
    while (len * 10 <= x) len *= 10;
    for (int i = 1; i <= 9; i++) //枚举可能的首位。
        make_num(x, i, i, len);
    while (len <= r / 10) {
       len *= 10;
        for (int i = 1; i <= 9; i++)
            make_num(x, i, i, len);//补零后继续拓展，但补零的数不计入结果
    }
    if (!q.empty()) bfs();
}
int main() {
    scanf("%d%d", &l, &r);
    q.push(7);// 7 一定为初始态
    bfs();
    printf("%d", ans);
}
```

---

## 作者：zhangzongyue (赞：3)

个人觉得这是一道很好的 DFS 题。

对于每次搜索，都要扩展出一个数位，所以每次枚举的就是新扩展的这个数位放的数字。剩下数位上的的数则由与其相邻数位上的数推理而来。而由于是绝对值，所以有两种情况。

还有一个很重要的点就是**前导零**，如：

$magic(770)=7$ 而 770 就是搜索 07 的结果。

代码如下：

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll a,b,ans;
int len; //b的数位
void dfs(ll,int);
void f(int,int,ll,int*);
int main(){
	scanf("%lld%lld",&a,&b);
	ll b1=b;
	while(b1){
		len++;
		b1/=10;
	}
	dfs(7,1);//所有魔法数由7搜索而来
	printf("%lld",ans);
	return 0;
}
void f(int w,int ww,ll s,int num[15]){
//w,ww表示数位个数，s是新产生的数，num数组是x的各个数位
	if(w==0){//所有数位都搜索完了
		dfs(s,ww+1);//搜索下一个数
		return;
	}
	int s1,s2;
	s1=s%10+num[w],s2=s%10-num[w];//绝对值产生的两种情况
	if(s1<10) f(w-1,ww,s*10+s1,num);
	if(s2>=0&&s1!=s2) f(w-1,ww,s*10+s2,num);
}
void dfs(ll x,int w){ //x表示当前搜的数,w表示x的数位
	if(x>=a&&x<=b){
		ans++;
	}
	if(x>=b) return;//边界条件
	int num[15],nl=0;
	memset(num,0,sizeof(num));
	while(x){
		num[++nl]=x%10;
		x/=10;
	}//拆分x的各个数位
	for(int j=0;j+w<len;++j){//j表示加上的前导零的个数
		for(int i=1;i<=9;++i){//枚举最高数位上的数
			f(j+w,j+w,i,num);
		}
	} 
}
```


---

## 作者：hytree (赞：2)

  
# 思路分析

瞄一下数据范围,居然达到了$10$亿级别,显然暴力统计就行不通了,题目中又显然与数位有关.所以我们考虑**类似数位的搜索办法**解决本题.  

首先我们需明白若**一个数字可能为幸运数,那必是由一个会是幸运数的数拓展过来的**,题目也告诉我们$7$是幸运数字,则**所有幸运数字就必是由$7$拓展来的**.所以我们由$7$开始疯狂拓展,拓展出来的数在$l-r$之内即使符合条件的解,这些解又还能拓展出其他解,所以我们可以写广搜来拓展情况.

那么一开始就把$7$入队,如何拓展呢,首先我们的原始数如果可以通过$magic$变为幸运数的话,可以通过两种方式拓展出来.  

### 拓展方式

我们若令当前用于拓展的幸运数字为 **$magicx$** ,原始数为 **$old$**   

那么$magicx$的当前位 **$nowx$** 必是由原始数$old$的上一位减当前位得到的.  
所以我们要拓展的下一个原始数为 $old+10^{wei+1}$ $\times$ $(原始数当前位-nowx)$ 或  $old+10^{wei+1}$ $\times$ $(nowx+原始数当前位)$ .
### 初始原始数以及复杂度小小的分析

原始数个位必为 $0-9$ 之间的某个,由这个个位我们拓展下一个原始数就只有2种情况,所以队列中一个状态就最多只有$2^{10}$(~~应该没算错趴~~)   

### 后话
所以就可以愉快的搜索求解啦$QAQ$.

另外还有些细节见代码趴(记得开$long\ long$,我没开就只有$70$了$QWQ$).  
###  _以下是代码部分(里面还有注释的嗷)_
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int l,r,ans;
queue<int>q;
void DFS(int magicx,int old,int wei)
{
	if(old>r) return;
	if(magicx==0)//当我们magicx的位数被枚举完了后.仍然有些状态可以拓展.
	//如7,显然7会直接拓展到70,到70时magicx就变成了7/10=0了。
	//但仍有如770,7770的可以拓展.就直接把old最大位拿过来,复制一遍接到最大位上. 
	{
		int nxt=old/pow(10,wei);//取最高位.
		if(!nxt)return;
		DFS(magicx,old+nxt*pow(10,wei+1),wei+1);//把类似70变为770; 
		if(old>=l&&old<=r) ans++;
		if(pow(10,wei+1)<r) q.push(old);//还有拓展可能的就入队. 
		return; 
	}
	//把magicx/10保证每次magicx的个位数是我们可拓展的数. 
	int nxt=old/pow(10,wei),nowx=magicx%10; magicx/=10;
	//由于原数的上一位减当前为old的绝对值为magicx的当前位数,而magicx的当前位数我们知道.
	//所以可拓展的上一位就是nxt-nowx或nxt+nowx;
	if(nxt-nowx>=0) DFS(magicx,old+pow(10,wei+1)*(nxt-nowx),wei+1);
	if(nowx&&nowx+nxt<10) DFS(magicx,old+pow(10,wei+1)*(nowx+nxt),wei+1);
}
signed main() 
{
  	scanf("%lld%lld",&l,&r);
	q.push(7);
  	if(l<=7&&r>=7) ans++;
  	while(!q.empty())
  	{
  		for(int i=0;i<=9;i++)
		DFS(q.front(),i,0);
		q.pop();
  	}
  	printf("%lld",ans);
  	return 0;
}
```


---


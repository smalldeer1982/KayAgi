# [SCOI2008] 城堡

## 题目背景

2008NOI四川省选


## 题目描述

在一个国家里，有 $n$ 个城市（编号为 $0$ 到 $n-1$）。这些城市之间有 $n$ 条双向道路相连（编号为 $0$ 到 $n-1$），其中编号为 $i$ 的道路连接了城市 $i$ 和城市 $r_i$（一条道路可以连接一个城市和它自身），长度为 $d_i$。$n$ 个城市中有 $m$ 个拥有自己城堡，可以抵御敌人侵略。如果没有城堡的城市遭受攻击，则离它最近的城堡将派兵前往救援。

你的任务是在不超过 $k$ 个没有城堡的城市中建立城堡，使得所有城市中“离最近城堡的距离”的最大值尽量小。换句话说，若令 $dist(c)$ 表示城市 $c$ 的最近城堡离它的距离，则你的任务是让 $\max\{dist(c)\}$ 尽量小。

输入数据保证存在方案使得对于每个城市，至少有一个城堡能够到达。

## 说明/提示

$100\%$ 的数据满足: $2\leq n\leq 50$，$1\leq d_i\leq 10^6$，$0\leq m\leq n-k$。

## 样例 #1

### 输入

```
5 0 1
1 2 3 4 0
1 1 1 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
3 1 1
1 2 0
1 2 3
2```

### 输出

```
1```

## 样例 #3

### 输入

```
2 1 1  
0 1  
1 1  
1 ```

### 输出

```
0```

## 样例 #4

### 输入

```
10 3 3
0 2 0 0 2 2 8 3 8 7
10 9 1 8 1 3 7 2 8 1
3 4 6```

### 输出

```
3```

## 样例 #5

### 输入

```
2 0 1
1 0
5 10```

### 输出

```
5```

# 题解

## 作者：vectorwyx (赞：16)

题意：给定一棵基环树森林，起初有 $m$ 个点已被选进 $S$ 里，你需要再选 $k$ 个点加入到 $S$ 中，最小化其余点到 $S$ 距离的最大值。

二分，树的部分同 P3523 做 dp。但是根结点（也就是在环上的点）的处理要保留，如果当前子树中最深的还未被覆盖的点距离根结点的距离为 $d$，它要求环上的某段区间 $[l,r]$ 里至少有一个点被选进 $S$ 里，然后最小化环上被选进 $S$ 的点数。这个问题和 P4155 的形式是一致的，断环成链后变为经典贪心，每次从还未被满足的区间中选一个右端点最靠左的区间，把它的右端点选进 $S$ 里。复杂度 $O(n^2\log n)$，通过倍增应该能优化到 $O(n\log^2 n)$，但是懒得写了。

代码如下：
```cpp
#include<bits/stdc++.h>
namespace vectorwyx{
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define mk make_pair
#define sml(x,y) (x=min(x,y))
#define big(x,y) (x=max(x,y))
#define ll long long
#define uint unsigned
#define ull unsigned long long
#define umap unordered_map
#define db double
#define fo(i,x,y) for(int i=(x);i<=(y);++i)
#define go(i,x,y) for(int i=(x);i>=(y);--i)
#define ptc putchar
#define emp emplace
#define re return
#define co continue
#define brk break
#define HH (ptc('\n'))
#define bctz __builtin_ctz
#define bclz __builtin_clz
#define bppc __builtin_popcount
using namespace std;
ll seed=chrono::system_clock::now().time_since_epoch().count();
mt19937 rnd(seed);
inline int rm(int x,int y){return (int)(rnd()%(y-x+1ll)+x);}
inline int read(){signed ch=getchar();int x=0,f=1;while(!isdigit(ch)){if(ch==(int)('-'))f=-1;ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
inline void out(int *a,int l,int r){fo(i,l,r) cout<<*(a+i)<<' ';puts("");}

//8:36~9:44~
const int N=105,inf=1e9;
int a[N],num,n,m,k,vis[N],ti,f[N],g[N],stk[N],top,ins[N],rk[N];
int mp[N][N];
vector<pii> e[N];

void dfs1(int x){
	if(vis[x]==ti) re;
	vis[x]=ti;
	for(auto i:e[x]) dfs1(i.fi);
}

struct Ctree{
int cir[N],ct,rvl[N],k,ins[N],ans,l[N],r[N],m,fl,nxt[N],sum[N],R[N];

void insert(int x){
	cir[++ct]=x;
	rk[x]=ct;ins[x]=1;
}
void play_it(){
	fo(i,1,ct-1) rvl[i]=rvl[i+ct]=mp[cir[i]][cir[i+1]];
	rvl[ct]=mp[cir[ct]][cir[1]];
	fo(i,1,ct) if(a[cir[i]]){fl=i;brk;}
	fo(i,1,2*ct-1) sum[i+1]=sum[i]+rvl[i];
//	cout<<"rvl:";out(rvl,1,2*ct);cout<<"sum:";out(sum,1,2*ct);
}

void dfs(int x,int fa){
	f[x]=0,g[x]=inf;
	for(auto i:e[x]) if(!ins[i.fi]&&i.fi!=fa){
		dfs(i.fi,x);
		big(f[x],f[i.fi]+i.se);
		sml(g[x],g[i.fi]+i.se);
	}
	if(a[x]) g[x]=0;
	if(f[x]+g[x]<=k) f[x]=-inf;
	if(f[x]+mp[x][fa]>k) f[x]=-inf,g[x]=0,ans++;//,printf("%d!\n",x); 
}

int solve(){
//	printf("solve(%d)\n",k);
	ans=m=0;
	fo(i,1,ct)
		dfs(cir[i],0);
//	printf("now ans=%d!\n",ans);
//	fo(i,1,ct) printf("%d:(%d,%d)\n",i,f[cir[i]],g[cir[i]]);
	int Fl=0;
	fo(i,1,2*ct) R[i]=inf;
	fo(i,1,ct){
		bool flg=0;
		fo(j,1,ct){
			int dis=abs(sum[i]-sum[j]);sml(dis,sum[ct+1]-dis);
			if(f[cir[i]]+g[cir[j]]+dis<=k){flg=1;brk;}
		}
		if(flg) co;
		int len=k-f[cir[i]];
//		printf("%d:len=%d\n",i,len);
		if(2*len>=sum[ct+1]){
//			puts("qwq");
			if(!fl) Fl=1;
			co;
		}
		++m;
		if(sum[i]+rvl[ct]>len){
			l[m]=1;r[m]=2*ct;
			go(j,i,1) if(sum[i]-sum[j]>len){l[m]=j+1;brk;}
			fo(j,i,2*ct) if(sum[j]-sum[i]>len){r[m]=j-1;brk;}
			if(r[m]>ct) co;
			l[m+1]=l[m]+ct;r[m+1]=r[m]+ct;
			++m;
		}else{
			l[m]=1;r[m]=2*ct;
			go(j,i+ct,1) if(sum[i+ct]-sum[j]>len){l[m]=j+1;brk;}
			fo(j,i+ct,2*ct) if(sum[j]-sum[i+ct]>len){r[m]=j-1;brk;}			
		}
	}
	if(!m) re ans+Fl;
//	fo(i,1,m) printf("[%d,%d]\n",l[i],r[i]);
	fo(i,1,m) sml(R[l[i]],r[i]);
	int c=0,mn=inf;
	go(i,2*ct,1){
		nxt[i]=mn;
		sml(mn,R[i]);
	}
	if(fl){
		int x=fl;
		while(nxt[x]<fl+ct){
			c++;
			x=nxt[x];
		}
	}else{
		c=inf;
		fo(i,1,ct){
			int x=i,rp=1;
			while(nxt[x]<i+ct){
				rp++;
				x=nxt[x];
			}
			sml(c,rp);
		}
	}
	big(c,Fl);
	re ans+c;
}
}tr[N];

bool dfs2(int x,int fa){
	stk[++top]=x;vis[x]=ti;
	bool fl=0;
	for(auto i:e[x]){
		if(vis[i.fi]==ti){//基环树找环一定要特判父亲！！
			if(i.fi==fa){
				if(!fl){
					fl=1;
					co;
				}	
			}
			do{
				tr[num].insert(stk[top]);
			}while(stk[top--]!=i.fi);
			re 1;
		}
		if(dfs2(i.fi,x)) re 1;
	}
	top--;
	re 0;
}

signed main(){
	cin>>n;int w=read();cin>>m;
	{
	int x[N];fo(i,1,n) x[i]=read()+1;
	fo(i,1,n) fo(j,1,n) mp[i][j]=inf;
	fo(i,1,n){
		int v=read();
		e[i].eb(x[i],v);
		e[x[i]].eb(i,v);
//		printf("%d <-> %d %d\n",i,x[i],v);
		sml(mp[i][x[i]],v);
		sml(mp[x[i]][i],v);
	}		
	}

	fo(i,1,w) a[read()+1]=1;
	fo(i,1,n) if(!vis[i]){
		++ti;++num;
		dfs1(i);
		++ti;
		dfs2(i,0);
		tr[num].play_it();
//		tr[i].rvl[tr[i].ct]=mp[tr[i]]
	}
//	tr[1].k=5;cout<<tr[1].solve()<<'\n';
//	tr[2].k=3;cout<<tr[2].solve()<<'\n';
//	re 0;
	int l=0,r=inf,mid,ans=inf;
	while(l<=r){
		mid=(l+r)>>1;
		int x=0;
		fo(i,1,num) tr[i].k=mid,x+=tr[i].solve();
		if(x>m) l=mid+1;
		else r=mid-1,ans=mid;
	}
	cout<<ans;
	return 0;
}
}
/*
-------------------------------------------------
*/










signed main(){re vectorwyx::main();}

```

---

## 作者：JK_LOVER (赞：7)

首先，这是我第一次做黑题
~~（激动）~~


然后看看题解的退火不是太清晰，便有了这篇题解


1. 先看题目的是让max(dist[c])最小，这首先让我想起了二分。再一看范围$n\le50$，所以就枚举可以放城堡的点，跑最短路，复杂度不允许。$O((n-m)!)$是过不了的

2. 先预处理每个点的最短距离，再二分答案，将不能到达的点值加+1，最后在值最大k个中建城堡,这应该是正解了，但蒟蒻的我写不来，所以只有写退火了

3. 关于退火可见[#60[M_sea]浅谈玄学算法——模拟退火](https://www.luogu.com.cn/blog/m-sea/qian-tan-SA)。这里引用一下


模拟退火算法新解的产生和接受可分为如下四个步骤：


- 第一步是由一个产生函数从当前解产生一个位于解空间的新解；为便于后续的计算和接受，减少算法耗时，通常选择由当前新解经过简单地变换即可产生新解的方法，如对构成新解的全部或部分元素进行置换、互换等，注意到产生新解的变换方法决定了当前新解的邻域结构，因而对冷却进度表的选取有一定的影响。

- 第二步是计算与新解所对应的目标函数差。因为目标函数差仅由变换部分产生，所以目标函数差的计算最好按增量计算。事实表明，对大多数应用而言，这是计算目标函数差的最快方法。

- 第三步是判断新解是否被接受，判断的依据是一个接受准则，最常用的接受准则是Metropolis准则: 若Δt′<0则接受S′作为新的当前解S，否则以概率exp(-Δt′/T)接受S′作为新的当前解S。

- 第四步是当新解被确定接受时，用新解代替当前解，这只需将当前解中对应于产生新解时的变换部分予以实现，同时修正目标函数值即可。此时，当前解实现了一次迭代。可在此基础上开始下一轮试验。而当新解被判定为舍弃时，则在原当前解的基础上继续下一轮试验

- 模拟退火算法与初始值无关，算法求得的解与初始解状态S(是算法迭代的起点)无关；模拟退火算法具有渐近收敛性，已在理论上被证明是一种以概率收敛于全局最优解的全局优化算法；模拟退火算法具有并行性。


----百度百科



用一张图来描述就是![](https://upload.wikimedia.org/wikipedia/commons/d/d5/Hill_Climbing_with_Simulated_Annealing.gif)


总结：模拟退火会慢慢逼近一个函数的较大（小）值
~~(骗分神器)~~


时间复杂度： $O$(证不来) ，影响速度的主要是，降温系数，初始温度,末温度,处理函数，退火次数。



优点：将一个问题，由求解转变为证明问题，使问题简单化。也避免了 $TLE$ ，也是解决NPC问题的好方法



缺点：退火并不能保证算法的正确性，对于多峰函数其解的最优可能性跟低


关于模板：



```cpp
void EA()
{
	double T = 2000;初始温度
	while(T > 1e-10)退出温度
	{
      		随机生成一个新解
		T *= 0.987;降温
		double delta = 原解 - 新解;
		if(更优)
		{
			res = new_res;接受
		}
		else if(exp(-(double)delta*RAND_MAX/T) < rand())
		{
			一定概率接受
		}
	}
	ans = min(ans,res);更新答案
}
```




对于这道题：就是随机跳哪些点建城市，代码就非常简单了




```cpp
#include<bits/stdc++.h>
#define P pair<int,int>
const double putdown = 0.997;
const int inf = 0x3f3f3f3f;
using namespace std;
const int N = 55;
int city[N],head[N],ans = inf,n,m,k,ri[N],dist[N],no_city[N],cnt = -1,need_city = 0;
bool vis[N];
struct EDGE{
	int to;
	int next;
	int w;
}e[N<<1];
void add(int x,int y,int d)
{
	e[++cnt].to = y;e[cnt].next = head[x];e[cnt].w = d;head[x] = cnt;
	e[++cnt].to = x;e[cnt].next = head[y];e[cnt].w = d;head[y] = cnt;
}
struct node{
    int pos;
    int dist;
    bool operator <(const node& S)const{
    return dist>S.dist;
    }
};

void solve()
{
	priority_queue<node> q;
    memset(dist,0x3f,sizeof(dist));
    memset(vis,false,sizeof(vis));
    for(int i = 1;i <= m;i++)
    {
    	dist[city[i]] = 0;
    	q.push((node){city[i],dist[city[i]]});
	}
    for(int i = 1;i <= k;i++)
    {
    	dist[no_city[i]] = 0;
    	q.push((node){no_city[i],dist[no_city[i]]});
	}
    
    while(!q.empty())
    {
        int x = q.top().pos;
        q.pop();
        //cout<<x<<endl;
        if(vis[x]) continue;
        vis[x] = true;
        for(int i = head[x];~i;i = e[i].next)
        {
            int y = e[i].to;
            if(e[i].w<dist[y]-dist[x])
            {
                dist[y] = dist[x] + e[i].w;
                q.push((node){y,dist[y]});
            }
        }
    }
//    for(int i = 1;i <= n;i++)
//    {
//    	cout<<dist[i]<<endl;
//    	system("pause");
//	}
}
void EA()
{
	int res = inf;
	double T = 2000;
	while(T > 1e-10)
	{
		int x = (rand()%k)+1;
		int y = (rand()%(need_city - k))+k+1;
		swap(no_city[x],no_city[y]);
		//cout<<"debug1"<<endl;
		solve();
		//cout<<"debug2"<<endl;
		int new_res = -1;
		for(int i = 1;i <= need_city;i++)
		{
			//cout<<"debug3"<<endl;
			int yy = dist[no_city[i]];
			//if(yy == inf) cout<<no_city[i]<<endl;
			new_res = max(new_res,yy);
		}
		//cout<<"debug4 "<<new_res<<endl;
		T *= putdown;
		int delta = res - new_res;
		if(delta > 0)
		{
			res = new_res;
			continue;
		}
		else if(exp(-(double)delta*RAND_MAX/T) < rand())
		{
			//cout<<"debug5"<<endl;
			continue;
		}
		swap(no_city[x],no_city[y]);
	}
	ans = min(ans,res);
}

int main()
{
	srand((int)time(0));
	memset(vis,true,sizeof(vis));
	memset(head,-1,sizeof(head));
	cin>>n>>m>>k;
	for(int i = 1;i <= n;i++)
	cin>>ri[i];
	for(int i = 1;i <= n;i++)
	{
		int d;
		cin>>d;
		add(i,ri[i]+1,d);
	}
	for(int i = 1;i <= m;i++)
	{
		int a;
		cin>>a;
		city[i] = a+1;
		//cin>>city[i];
		vis[city[i]] = false;
	}
	for(int i = 1;i <= n;i++)
	{
		if(vis[i])
		{
			no_city[++need_city] = i;
		}
	}
	solve();
	if(need_city == k)
	{
		ans = 0;
		for(int i = 1;i <= need_city;i++)
		{
			int y = no_city[i];
			ans = max(ans,dist[y]);
		}
		cout<<ans<<endl;
		return 0;
	}
	EA();
	EA();
	EA();
	cout<<ans<<endl;
	return 0;
}
```
安利[博客](https://www.luogu.com.cn/blog/xzc/)


---

## 作者：ywy_c_asm (赞：5)

看见这题之后，我第一想法是random_shuffle骗分，就是把所有非关键点提出来random_shuffle多次，每次取前k个判定，然而这样做实际效果并不是很理想……

然后把random_shuffle改成模拟退火之后正确率就变得极高了……但是要注意退火的时候每次只能随机交换2个并不是每次都随机打乱~~要不就跟直接random_shuffle没区别了~~，大概是每次从上一个解出发所以正确率才更高吧。

上代码~

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <cmath>
#include <ctime>
#define ll long long
#define p 998244353
using namespace std;
namespace ywy {
	typedef struct _b {
	    int dest;
	    int nxt;
	    int len;
	} bian;
	bian memchi[100001];
	int gn = 1, heads[100], dis[55], que[100001];
	unsigned char bv[55];
	int n, minn = 0;
	inline void spfa(int s) {
	    dis[s] = 0;
	    int head = 0, tail = 1;
	    que[0] = s;
	    do {
	        int me = que[head];
	        head++;
	        bv[me] = 0;
	        for (register int i = heads[me]; i; i = memchi[i].nxt) {
	            if (dis[me] + memchi[i].len < dis[memchi[i].dest]) {
	                dis[memchi[i].dest] = dis[me] + memchi[i].len;
	                if (!bv[memchi[i].dest]) {
	                    que[tail] = memchi[i].dest;
	                    tail++;
	                    bv[memchi[i].dest] = 1;
	                }
	            }
	        }
	    } while (head < tail);
	}
	inline void add(int s, int t, int l) {
	    memchi[gn].dest = t;
	    memchi[gn].len = l;
	    memchi[gn].nxt = heads[s];
	    heads[s] = gn;
	    gn++;
	}
	int dst[100], d[100], ints[100], qd[100];
	unsigned char orz[100];
	int ptr, m, k;
	inline int calc() {
	    memset(dis, 0x7f, sizeof(dis));
	    for (register int i = 1; i <= k; i++) spfa(ints[i]);
	    for (register int i = 1; i <= m; i++) spfa(qd[i]);
	    int maxn = 0;
	    for (register int i = 1; i <= n; i++) maxn = max(maxn, dis[i]);
	    return (maxn);
	}
	inline void SA(double t, double delta) {
	    int me = minn;
	    while (t >= 1e-10) {
	        t *= delta;
	        int a = rand() % k + 1, b = rand() % (ptr - k) + 1;
	        swap(ints[a], ints[k + b]);
	        int cjr = calc();
	        if (cjr < me || cjr < minn) {
	            minn = min(minn, cjr);
	            me = cjr;
	            continue;
	        }
	        if (exp((me - cjr) / t) * RAND_MAX > rand()) {
	            minn = min(minn, cjr);
	            me = cjr;
	            continue;
	        }
	        swap(ints[a], ints[k + b]);
	    }
	}
	void ywymain() {
	    srand(19260817);
	    cin >> n >> m >> k;
	    for (register int i = 1; i <= n; i++) cin >> dst[i], dst[i]++;
	    for (register int i = 1; i <= n; i++) {
	        cin >> d[i];
	        add(i, dst[i], d[i]);
	        add(dst[i], i, d[i]);
	    }
	    for (register int i = 1; i <= m; i++) {
	        cin >> qd[i];
	        qd[i]++;
	        orz[qd[i]] = 1;
	    }
	    int st = clock();
	    minn = 0;
	    memset(dis, 0x7f, sizeof(dis));
	    for (register int i = 1; i <= m; i++) spfa(qd[i]);
	    for (register int i = 1; i <= n; i++) {
	        minn = max(minn, dis[i]);
	    }
	    ptr = 1;
	    for (register int i = 1; i <= n; i++) {
	        if (!orz[i])
	            ints[ptr] = i, ptr++;
	    }
	    ptr--;
	    if (m + k == n) {
	        cout << calc() << endl;
	        return;
	    }
	    int t = 30;
	    while (clock() - st < 780000) {
	        SA(1000, 0.993);
	    }
	    cout << minn << endl;
	}
}
int main() {
    ywy::ywymain();
    return (0);
}
```

---

## 作者：HansLimon (赞：3)

# 模拟退火

## \>1.1

先不提模拟退火，我们来理解爬山算法，已经知晓的可以调至1.2

如果我们有一个函数$ f(x) $，已知其在定义域上有且仅有一个单调递增和单调递减区间，为了求$ f(x) $的近似极值，我们可以采用爬山算法。感性理解，你有如下的函数：

![Figure 1](https://s2.ax1x.com/2020/01/19/1Cdqwn.png)

肉眼可见，$ f(x) $的极值在区间6~8中。为了求得大致的极值，显而易见，我们可以二分。不过我们在此处讲的是爬山，因此先将二分撂一边去

爬山算法在(比如说)4这个位置出发，向x轴负半轴方向和x轴正半轴方向试探，发现正半轴要小一些，又因为单调区间仅有1个，因此，我们选择向右半轴方向走。(具体走多少需要求导以确定大致，这里大概感觉一下)越陡，一次就走的越多。

###### ~~小声bb~~:其实对机器学习有所了解的话，可以发现这就是梯度下降。当然，是更简单的梯度下降。

这样就算大致的理解了爬山算法，实现并不困难，不做额外阐释。

## \>1.2
模拟退火可以说做特殊的爬山，针对于$ f(x) $的单调区间很多的时候。但有时候也得不到正确答案，~~毕竟过于玄学~~。

举个例子：

![Figure 2](https://s2.ax1x.com/2020/01/19/1CdzSU.png)

很明显，一般的爬山算法很容易卡在**局部最优解**上。举个例子，它在0附近找到了一个“最值”，向左、右走都发现要更大一点，最后就停在了这里。但很明显，我们肉眼可见，0附近不是最值的所在位置。

因此我们会需要一个算法，它在移动时不仅仅因为这种“倾斜关系”(想不出更好的词了，请模糊理解一下)来决定怎么移动，还根据一些其他关系。

什么是“其他关系”呢？也就是加入随机的因素。

实际上，在正常使用时随机化的表现效果并不是很好。为了解决这一点，我们引入“温度”这种说法，也是“退火”的来源。

>引用自百度百科：(实际上感觉说的不是很好，不想看这个引用的话就pass好了)

>模拟退火的原理也和金属退火的原理近似：将热力学的理论套用到统计学上，将搜寻空间内每一点想像成空气内的分子；分子的能量，就是它本身的动能；而搜寻空间内的每一点，也像空气分子一样带有“能量”，以表示该点对命题的合适程度。演算法先以搜寻空间内一个任意点作起始：每一步先选择一个“邻居”，然后再计算从现有位置到达“邻居”的概率。


为了帮助你更好理解，现在想象你正在打铁，铁的温度正逐步下降。这块铁中的某一分子正从活跃变为稳定，我们把该分子的稳定过程映射为一条在x轴上移动的点，随着温度逐渐降低，点的移动由剧烈趋向平缓，最终停下来。在该点移动的过程中，做出一条垂直于x轴且经过该点的直线，该直线与 $y = f(x)$ 交于一点，对应着我们的y值。

现在，模拟退火结合上爬山以及退火两个操作，成功(有时也不成功)地达到我们的目标：极值。

## \>1.3

在你理解了这两个操作后，看到右侧的图，这是刚才Figure 2在-1~1上的图像。现在感受一下模拟退火的过程，从-0.5出发，向任意两侧走…到(甚至还没到)局部最优解上，然后突然一跳，跳到了另一侧…最后近似的求得了极值。

![Figure 3](https://s2.ax1x.com/2020/01/19/1CwmlD.png)

现在，给出模拟退火的代码。

```cpp
void SA(){//即模拟退火
	register int ans, ……;//ans是当前解
	while (T *= delta_T, T >= …){//T是温度，delta_T是降温速率
		if (……)…rand()…//通常我们会rand一次做一个“假设操作”
		……//这里是一些附加内容，通常简单的模拟退火不需要
		if (ans = work(), ans < otp)otp = ans;
/*SA一般搭配一个work函数使用，可以感性认为是求出当前的y值；otp是当前最优解，也就是运行完毕后被输出的解*/
		else if (exp((long double)ans - otp)/T > (long double)rand()/0x7fff)……
		/*先说这一步的作用，充当随机化操作。其中，
exp是 ⅇ^x(e^x)；0x7fff是rand的上界。
按照我的习惯，该步一般表示以一定概率不接受本次操作，即上面的 if (……)…rand()… */
	}
}
```

## \>1.4
大致就是这样，现在对本题做简短的思路讲解。

考虑最初随机生成一串序列表示将要建城堡的城市，用$Dijkstra$跑个最短路来作为$work$函数的主要部分，以最大距离表示y值。$if (……)…rand()…$步骤随机交换两个城市(一个建了的和没建的，因此 附加内容 部分要判定是否为一个有一个无以及已经有城堡不能不建造的。实际上实现时前两个都无需注意，对答案影响不大，只须注意最后一个即可)，一个建造城堡，另一个取消建造城堡。

```cpp
void SA(){
	register int ans, x, y;//选出城堡x、y
//	DEBUG//调试步骤
	while (T *= delta_T, T >= 1e-9){
		if (x = rand()%n, y = rand()%n, castle[x] == castle[y] || SP_sign[x] || SP_sign[y])x = rand()%n, y = rand()%n;//特判第一次，x不能和y相同，且不能是已有城堡的城市
		if (castle[x] == castle[y] || SP_sign[x] || SP_sign[y])continue;
//如果上述特判后的新x、y仍不满足，则直接降温
		swap(castle[x], castle[y]);
		if (ans = work(), ans < otp)otp = ans;//ans优于otp，更新otp
		else if (__builtin_exp((long double)ans - otp)/T > (long double)rand()/0x7fff)swap(castle[x], castle[y]);
		//不接受此次调换
//		var_DEBUG(ans, otp);//调试步骤
	}
}
```

讲解完毕。

---


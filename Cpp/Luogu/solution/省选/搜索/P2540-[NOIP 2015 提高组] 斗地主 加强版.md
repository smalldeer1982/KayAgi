# [NOIP 2015 提高组] 斗地主 加强版

## 题目描述

牛牛最近迷上了一种叫斗地主的扑克游戏。斗地主是一种使用黑桃、红心、梅花、方片的 $A$ 到 $K$ 加上大小王的共 $54$ 张牌来进行的扑克牌游戏。在斗地主中，牌的大小关系根据牌的数码表示如下：$3<4<5<6<7<8<9<10<J<Q<K<A<2<\text{小王}<\text{大王}$，而花色并不对牌的大小产生影响。每一局游戏中，一副手牌由 $n$ 张牌组成。游戏者每次可以根据规定的牌型进行出牌，首先打光自己的手牌一方取得游戏的胜利。

现在，牛牛只想知道，对于自己的若干组手牌，分别最少需要多少次出牌可以将它们打光。请你帮他解决这个问题。

需要注意的是，本题中游戏者每次可以出手的牌型与一般的斗地主相似而略有不同。具体规则如下：

 ![](https://cdn.luogu.com.cn/upload/pic/1827.png) 

**在此题中认为两个王不能组成对子牌**。


## 说明/提示

#### 样例 1 说明

共有 $1$ 组手牌，包含 $8$ 张牌：方片 $7$，方片 $8$，黑桃 $9$，方片 $10$，黑桃 $J$，黑桃 $5$，方片 $A$ 以及黑桃 $A$。可以通过打单顺子（方片 $7$，方片 $8$，黑桃 $9$，方片 $10$，黑桃 $J$），单张牌（黑桃 $5$）以及对子牌（黑桃 $A$ 以及方片 $A$）在 $3$ 次内打光。

#### 数据范围与提示

对于前 $20$ 个测试点， 我们约定手牌组数 $T$ 与张数 $n$ 的规模如下：

 ![](https://cdn.luogu.com.cn/upload/pic/1828.png) 

数据不保证所有的手牌都是随机生成的。


## 样例 #1

### 输入

```
1 8
7 4
8 4
9 1
10 4
11 1
5 1
1 4
1 1```

### 输出

```
3```

## 样例 #2

### 输入

```
1 17
12 3
4 3
2 3
5 4
10 2
3 3
12 2
0 1
1 3
10 1
6 2
12 1
11 3
5 2
12 4
2 2
7 2```

### 输出

```
6```

# 题解

## 作者：Starrykiller (赞：12)

[（可能）更好的阅读体验？](https://starrykiller.blog.luogu.org/solution-p2540-p2668)

和 [@luchuhan](https://www.luogu.com.cn/user/764603) 共同想出来的做法~

关于如何搜索和怎么强剪枝其他题解已经说得很清楚了（如果不清楚请参阅其他题解）。那么这里提供另外一个优化的方法（似乎题解里面没有人这么写）

在写 dfs 的时候，我们会加上这样一条剪枝：

```cpp
void dfs(int step, int cnt) { // 打了 step 手牌，用了 cnt 张
    if (step>=ans) return;
    // do something
}
```

这样剪枝的正确性是显然的。但是这样剪枝针对的情况只有一种：$step\geq ans$。

我们不妨记 $card_i$ 表示第 $i$ 种牌有 $card_i$ 张。

显然一个状态就是这样的一个集合：$S=\{card_1,card_2,\cdots,card_n\}$，我们考虑对于不同的 $S$，维护一个 $ans_s$ 表示到状态 $s$ 需要的最少步数。于是若访问到状态 $S$，当前的 $step_S\geq ans_S$，则可以立即回溯。

如果简单地用一个 $15$ 维数组记录，不仅写起来麻烦，空间上恐怕也不太承受得住。于是我们可以设计一个哈希函数

$$h(S)=\sum_{i=1}^n card_i\cdot p^i$$

其中 $p$ 是一个素数，我的程序中使用的是 $13331$。我们可以利用 `unsigned long long` 的自然溢出（$\bmod 2^{64}$）+ `map<unsigned long long, int>` 或者 对素数取模+数组 来进行记录。

其实用结构体之类的东西记录下状态也可以。

于是就能得到极大的优化。

```cpp
// 这里把牌映射到了[13,17]
unsigned long long hsh() {
    unsigned long long res=0;
    for (int i=3; i<=17; ++i) {
        res=res*p+card[i];
    }
    return res;
}

map<unsigned long long, int> m;

void dfs(int step, int cnt) { // 打了 step 手牌，用了 cnt 张
    if (cnt>=n || step>=ans) {
        ans=min(ans, step);
        return;
    }
    auto h=hsh();
    if (m.find(h)!=m.end() && step>=m[h])
        return;
    m[h]=step;
    
    // do something
}
```

完整代码见[此处](https://www.luogu.com.cn/paste/elgpjqv7)。

AC 记录见[此处](https://www.luogu.com.cn/record/127023045)。

---

## 作者：housq (赞：10)

蒟蒻不会贪心，看起来这道题好像就是个搜索题嘛，不如就简单搜搜看。

先分析一波，求最优步数，也就是每打一次牌代价都是1，求到目标状态（手牌没有了）的最小代价。考虑下能不能从目标反推？知道手上的牌，上一手打掉的是什么...嗯情况太多了，不好反推，所以这题不适合双向BFS。既然不适合双向BFS，那么

## 无脑上A*

当然这种求最小步数的题目用来练手写IDA* 是再好不过了。

思路和迭代加深的DFS是差不多的，都是逐次迭代，深度限制每次+1，每次迭代的时候搜索到大于深度限制的时候就返回，直到某一个迭代找到了一个解。所以迭代加深DFS和BFS一样在求最小步数的时候都能求出来最优解。

迭代加深的 A\* 和迭代加深DFS不一样的地方就在于，迭代加深DFS判断的是深度（也就是起点到当前走过的步数）是否大于深度限制，IDA* 判断的是 （深度+启发式函数值）是否大于深度限制。

这个启发式函数值是什么呢？简单来说，从起点s到当前状态x走过的路径长叫深度g(x)，从x走到终点t的**最短**路径长叫h\*(x)，对这个最短路径长h\*(x)的一个估计就叫做启发式函数h(x)。那么我们可以推出来，沿着当前s搜到x然后再继续走到终点t，长度一定至少是g(x)+h\*(x)。如果对于所有的x都有h(x)<=h\*(x)，也就是启发式函数从来不高估到终点的最短距离，那这个启发式函数就是可接受(admissible)的，用可接受的启发式函数的A\*，第一个搜到的解是最优解。对于IDA\*也是一样，如果g(x)+h(x) > depth_limit，那么从x再往后就不会有depth_limit内的解了，这里就可以返回。

那是不是设计一个启发式函数，每一次枚举手上有多少种能一次打出的组合，迭代加深搜索就可以了呢？

这问题没有这么简单！我们漏掉了这类问题最重要的性质！

# 利用问题的对称性压缩状态空间

如果你用搜索写过P2386，你会发现，这道题说(5,1,1)和(1,1,5)是同一个解，只和数字**组合**有关，和**顺序**无关。搜索的时候，我们一般可以这么做，从第二个盘子开始，每一个盘子放的数目都不能超过前一个盘子，这样我们就只会搜出来非升序的解，比如说(5,1,1)，不可能搜出来(1,1,5)，这样只要数字**组合**确定了，**顺序**就是唯一的。

那斗地主呢？比如我手上是一对2和一张3。先打对2，再打3，两步。先打3，再打对2，两步。

### 和**顺序**无关

那我们搜索的时候，就可以要求，每一次出牌都**不大于**上一次的出牌。

打过斗地主的同学可能要有意见了，单顺子和双顺子比，单顺子也压不了双顺子，双顺子也压不了单顺子，哪里能比较大小呢？

这种有的时候，两个东西可以比较大小，有的时候分不出大小的关系，叫做**偏序关系**。我们这里需要更强一点的，任意拿出来两个都能比较大小的，并且a<b, b<c 能推出a<c的，这种叫做**全序关系**。既然这道题只是求最小步数，我们可以撇开斗地主的偏序关系（题目也没描述，只有打过斗地主的知道），设计一个全序关系。这里直接上代码了。这段代码定义了cardset类型的小于号。

```cpp
struct cardset{
	int count[15];
	int tot;
};
bool operator< (const cardset &s1, const cardset &s2){
	if (s1.tot<s2.tot)
		return true;
	if (s1.tot>s2.tot)
		return false;
	for (int i=1;i<=14;i++)
		if (s1.count[i]!=s2.count[i])
			return s1.count[i]<s2.count[i];
	return false;
}
```

解释一下，一次打出的牌，牌数较小的我们认为较小。如果牌数相等，则比较count数组的字典序。

这样的定义对打牌的方式带来的最直观的改变是，我必须先出牌数较多的组合，再出牌数较少的组合。后面的分析能看出，这种打法方便我们设计启发式函数h。

## 启发式函数设计

我手上有牌(牌数>0)，最理想的情况至少几次出完？ 1次

我手上有12张牌，出了一个4张的炸，剩下八张至少几次出完？ 因为我们已经出了4张的组合了，之后不能出超过4张的牌，so至少 2次。

我手上有13张牌，出了一个3张，剩下10张至少几次出完？4次。

所以，启发式函数这么定义，初始状态，h=1。其他状态，h=上取整（剩余张数/上一次打的张数）。这个启发式函数满足可接受的条件，可以得出最优解。

## 判重？
既然都写迭代加深了不就是不想判重嘛。而且A\*的判重本来就没有太大用处，如果不是为了判断无解的话。

分析完毕，直接上代码。（代码里还有个提前剪枝的lowerbound，这个没有的话会有一个点TLE）。

```cpp
/*
 * doudizhuenhanced.cpp
 *
 *  Created on: 2018 0926
 *      Author: Hou
 */

#include <iostream>
#include <vector>
#include <string>
using namespace std;

struct cardset{
	int count[15];
	int tot;
	cardset(){
		for (int i=0;i<=14;i++)
			count[i]=0;
		tot=0;
	}

	void add(int number, int c){
		count[number] += c;
		tot+=c;
	}

};
bool operator< (const cardset &s1, const cardset &s2){
	if (s1.tot<s2.tot)
		return true;
	if (s1.tot>s2.tot)
		return false;
	for (int i=1;i<=14;i++)
		if (s1.count[i]!=s2.count[i])
			return s1.count[i]<s2.count[i];
	return false;
}

//for debug output
ostream& operator<< (ostream& stream, const cardset& set) {
	for (int i=1;i<=14;i++)
		for (int k=0;k<set.count[i];k++)
			stream<<i<<",";
	return stream;
}

struct state{
	int count[15]; //1:Joker 2~10:Number 11:Jack 12:Queen 13:King 14:Ace
	int tot;
	int upperbound;
	int step;
	cardset lastplay;
	state(int n){
		for (int i=0;i<15;i++)
			count[i] = 0;
		tot=upperbound =n;
		step = 0;
		lastplay.tot = 0;
	}
	state(const state& s){
		*this = s;
	}

	void play(const cardset &s){
		tot -= s.tot;
		step++;
		for (int i=1;i<=14;i++)
			count[i] -= s.count[i];
		upperbound = s.tot;
		lastplay = s;
	}
};

int n;

void find(const state &s, vector<cardset> &plays, int lowerbound, int upperbound){
	if (upperbound<lowerbound) return;
	//3 shunzi
	for (int i=3;i<=13;i++) if (s.count[i]>=3){
		cardset play;
		play.add(i, 3);
		int seq = 1;
		for (int j=i+1;j<=14;j++){
			if (s.count[j]<3)
				break;
			else{
				seq++;
				play.add(j,3);
				if (seq>=2){  //at least a 3-sequence
					if (play.tot>=lowerbound && play.tot<=upperbound)
						plays.push_back(play);
				}
			}
		}
	}
	//2 shunzi
	for (int i=3;i<=12;i++) if (s.count[i]>=2){
		cardset play;
		play.add(i,2);
		int seq = 1;
		for (int j=i+1;j<=14;j++){
			if (s.count[j]<2)
				break;
			else{
				seq++;
				play.add(j,2);
				if (seq>=3){  //at least a 3-sequence
					if (play.tot>=lowerbound && play.tot<=upperbound)
						plays.push_back(play);
				}
			}
		}
	}
	//1 shunzi
	for (int i=3;i<=10;i++) if (s.count[i]>=1){
		cardset play;
		play.add(i,1);
		int seq = 1;
		for (int j=i+1;j<=14;j++){
			if (s.count[j]<1)
				break;
			else{
				seq++;
				play.add(j,1);
				if (seq>=5){  //at least a 5-sequence
					if (play.tot>=lowerbound && play.tot<=upperbound)
						plays.push_back(play);
				}
			}
		}
	}

	//rocket
	if (s.count[1]==2 && lowerbound<=2 && upperbound>=2){
		cardset rocket;
		rocket.add(1, 2);
		plays.push_back(rocket);
	}

	//boom
	if (lowerbound<=4 && upperbound>=4)
		for (int i=1;i<=14;i++){
			cardset boom;
			if (s.count[i]==4){
				boom.add(i,4);
			}
		}

	//3+2
	if (lowerbound<=5 && upperbound>=5)
		for (int i=2;i<=14;i++) if(s.count[i]>=3) { //exclude joke
			cardset three;
			three.add(i, 3);
			for (int j=2;j<=14;j++) if (j!=i && s.count[j]>=2){
				cardset three2 = three;
				three2.add(j,2);
				plays.push_back(three2);
			}
		}

	//3+1
	if (lowerbound<=4 && upperbound>=4)
		for (int i=2;i<=14;i++) if(s.count[i]>=3) { //exclude joke
			cardset three;
			three.add(i, 3);
			for (int j=1;j<=14;j++) if (j!=i && s.count[j]>=1){
				cardset three1 = three;
				three1.add(j,1);
				plays.push_back(three1);
			}
		}

	//three
	if (lowerbound<=3 && upperbound>=3)
		for (int i=2;i<=14;i++) if(s.count[i]>=3) { //exclude joke
			cardset three;
			three.add(i, 3);
			plays.push_back(three);
		}

	//couple
	if (lowerbound<=2 && upperbound>=2)
		for (int i=2;i<=14;i++) if(s.count[i]>=2) { //exclude joke
			cardset couple;
			couple.add(i, 2);
			plays.push_back(couple);
		}

	//single
	if (lowerbound<=1 && upperbound>=1)
		for (int i=1;i<=14;i++) if(s.count[i]>=1) { //include joke
			cardset single;
			single.add(i, 1);
			plays.push_back(single);
		}

	//4+2 : 4+4, 4+1couple, 4+2couple, 4+2single
	if (lowerbound<=8 && upperbound>=4){
		for (int i=2;i<=14;i++) if(s.count[i]>=4) {
			cardset four;
			four.add(i,4);
			//4+4
			if (lowerbound<=8 && upperbound>=8)
				for (int j=2;j<=14;j++) if (j!=i && s.count[j]>=4){
					cardset fourfour = four;
					fourfour.add(j,4);
					plays.push_back(fourfour);
				}

			// 4+1couple
			for (int j=2;j<=14;j++) if (j!=i && s.count[j]>=2){ //Joker excluded
				cardset four1couple = four;
				four1couple.add(j, 2);
				if (lowerbound<=6 && upperbound>=6)
					plays.push_back(four1couple);
				// 4+2couple
				if (lowerbound<=8 && upperbound>=8)
					for (int k=j+1;k<=14;k++) if (k!=i && s.count[k]>=2){
						cardset four2couple = four1couple;
						four2couple.add(k, 2);
						plays.push_back(four2couple);
					}
			}

			// 4+Jokers
			if (s.count[1]==2 && lowerbound<=6 && upperbound>=6){
				cardset four2joker = four;
				four2joker.add(1,2);
				plays.push_back(four2joker);
			}

			// 4+2single
			if (lowerbound<=6 && upperbound>=6)
				for (int j=1;j<=14;j++) if (j!=i && s.count[j]>=1){
					for (int k=j+1;k<=14;k++) if (k!=i && s.count[k]>=1){
						cardset four2single = four;
						four2single.add(j,1);
						four2single.add(k,1);
						plays.push_back(four2single);
					}
				}
		}
	}



}

int idastar(const state &s, int limit){
	//goal test
	if (s.tot==0){
		return s.step;
	}
	//heuristic pruning
	int heuristic = (s.tot-1)/s.upperbound +1; // h = ceil(total/limit)
	if (s.step+heuristic>limit)
		return 0;


	int lowerbound = (s.tot-1)/(limit-s.step) +1;

	// play some cards, lowerbound <=numberofcards <=upperbound

	vector<cardset> plays;

	find(s, plays, lowerbound, s.upperbound);

	//for debug
	/*
	cout << plays.size() <<" possible plays" <<endl;
	for (int i=0;i<plays.size();i++){
		cout <<"can play" << plays[i] <<endl;
	}
	*/

	for (int i=0;i<plays.size();i++){
		state next(s);
		if (s.lastplay.tot ==0 || !(s.lastplay<plays[i]) ){
			next.play(plays[i]);
			int finish = idastar(next, limit);
			if (finish){
				return finish;
			}
		}
	}

	return 0;
}

void solve(){
	state init(n);

	//input
	for (int i=0;i<n;i++){
		int number, type;
		cin >>number >>type;
		if (number==0) //Joker
			init.count[1]++;
		if (number==1) //Ace
			init.count[14]++;
		else
			init.count[number]++;
	}

	//iterative deepening A*
	int res;
	for (int limit=1; limit<=n; limit++){
		res = idastar(init, limit);
		if (res>0)
			break;
	}

	cout <<res <<endl;
}

int main(){
	int T;
	cin >>T >>n;

	for (int i=0;i<T;i++)
		solve();

	return 0;
}

```

---

## 作者：lihongru (赞：6)

### 题目分析

这道题按照我们老师的话来说就是很神奇，写完才知道这道题有多么神奇。看到这道题依然只能想到搜索每一步出牌。

我们看题可以知道，牌的花色是不影响出牌的，所以输入时，我们不存每张牌长啥样，**只存某种点数牌的数量**，记作 $s$。

当然，输入**需要特别把 $1(A)$ 记在 $15$ 的位置**，这样才能更好的枚举顺子。以下分析均**不带火箭**，因为统计答案时直接使用更方便。

发现，有一部分出牌方法中，**牌的点数和能否出是有关的**，而另一部分中，**牌的点数是无关的**。我们依此大致可以把出牌分为两类。

- 顺子类：单顺子/双顺子/三顺子
- 其它类：炸弹/单张牌/对子牌/三张牌/三带一/三带二/四带二（需要拆解成四带二张和四带二对处理）

当然，不分类这道题依然可做，暴力卡时也能过。不过我更倾向于分类后使用这个“神奇”的剪枝来做。

牌的点数有关，我们没有什么好办法处理。但牌的点数无关就可以使用预处理的动态规划（四维：`dp[单张数量][对子数量][三张数量][炸弹数量]`）来减去搜索的时间复杂度。我们先来处理顺子类。

### 顺子类 - 搜索处理

我们使用暴力做法，暴力枚举顺子中每个点数的个数 $a$，起点位置 $i$ 与可能的终点位置 $j$。对于每一个起点位置，我们开一个计数器 $cnt$ 记成功选中的牌的点数个数。

对于每一个可能的终点位置 $j$，如果能够选择 $a$ 张牌，则选择 $a$ 张牌，并 `cnt++;`，如果不能，则直接跳出。

这里用数学直觉找出一个临界值用于判定，当顺子 `cnt` 足够时，$a$ 和 $cnt$ 满足 $cnt \times a \ge 5$，对于本题 $a$ 的取值都是满足的。

由此可写出顺子部分的代码。注意删除和回溯。这份片段中，$x$ 代表走到这一步需要的步数。

```cpp
for (int a = 1; a <= 3; a++){
	for (int i = 3; i <= 14; i++){
		int cnt = 0;
		for (int j = i; j <= 14; j++){
			if (s[j] >= a) cnt++;
			else break;
			if (a * cnt >= 5){
				for (int k = i; k <= j; k++){
					s[k] -= a;
				}
				dfs(x+1);
				for (int k = i; k <= j; k++){
					s[k] += a;
				}
			}
		}
		
	}
}
```

### 其它类 - 动态规划

我们记 $a$ 为单张数，$b$ 为对子数，$c$ 为三张数，$d$ 为炸弹数。记 `dp[a][b][c][d]` 表示这些牌需要用几次出完。具体如何转移见下表。

|出牌种类|$a$|$b$|$c$|$d$|附加值|
|:-:|:-:|:-:|:-:|:-:|:-:|
|单张牌|$a-1$|$b$|$c$|$d$|$1$|
|对子牌|$a$|$b-1$|$c$|$d$|$1$|
|三张牌|$a$|$b$|$c-1$|$d$|$1$|
|炸弹|$a$|$b$|$c$|$d-1$|$1$|
|三带一|$a-1$|$b$|$c-1$|$d$|$1$|
|三带二|$a$|$b-1$|$c-1$|$d$|$1$|
|四带两张|$a-2$|$b$|$c$|$d$|$1$|
|四带两对|$a$|$b-2$|$c$|$d$|$1$|
|拆一对*|$a+2$|$b-1$|$c$|$d$|$0$|
|拆三张*|$a+1$|$b+1$|$c-1$|$d$|$0$|
|拆炸弹成两对*|$a$|$b+2$|$c$|$d-1$|$0$|
|拆炸弹成单+三张*|$a+1$|$b$|$c+1$|$d-1$|$0$|

注释：四带两张和四带两对都是四带二。所有带星号的都是拆牌操作，它们**可能使得答案更优**，且**不需要消耗步数**。

引入拆牌操作后，我们就需要仔细思考动态规划的顺序了。显然，$d \to c \to b \to a$ 的顺序是更合理的，保证了每个值被推算前，它需要用到的值都已经推算完成。

预处理时进行动态规划即可。为了减少代码量，可以使用临时变量。注意**边界问题**，初始值的设置与 $0$ 值不能够被覆盖。

```cpp
for (int d = 0; d <= 5; d++){
	for (int c = 0; c <= 8; c++){
		for (int b = 0; b <= 12; b++){
			for (int a = 0; a <= 23; a++){
				if (!a && !b && !c && !d) continue;
				int s = 0x3f3f3f3f;
				
				if (a) s = min(s, dp[a-1][b][c][d] + 1);
				if (b) s = min(s, dp[a][b-1][c][d] + 1);
				if (c) s = min(s, dp[a][b][c-1][d] + 1);
				if (d) s = min(s, dp[a][b][c][d-1] + 1);
				
				if (a && c) s = min(s, dp[a-1][b][c-1][d] + 1);
				if (b && c) s = min(s, dp[a][b-1][c-1][d] + 1);
				if (a >= 2 && d) s = min(s, dp[a-2][b][c][d-1] + 1);
				if (b >= 2 && d) s = min(s, dp[a][b-2][c][d-1] + 1);
				
				if (b) s = min(s, dp[a+2][b-1][c][d]);
				if (c) s = min(s, dp[a+1][b+1][c-1][d]);
				if (d) s = min(s, dp[a][b+2][c][d-1]);
				if (d) s = min(s, dp[a+1][b][c+1][d-1]);
					
				dp[a][b][c][d] = s;
			}
		}
	}
}
```

### 剪枝的具体实现

由于牌一共就 $14$ 种（不加大小王），我们直接暴力统计即可。调用时注意，双王**可作单张，也可作火箭（即多加一步）**。

```cpp
memset(c, 0, sizeof c);
for (int i = 2; i <= 14; i++) c[s[i]]++;
ans = min(ans, x + dp[c[1]+s[0]][c[2]][c[3]][c[4]]);
if (s[0] == 2) ans = min(ans, x + dp[c[1]][c[2]][c[3]][c[4]] + 1);
```

当然，不要忘记我们的最简单的剪枝“最优性剪枝”。

```cpp
if (x >= ans) return ;
```

最终将上面的代码块串在一起，加上输入输出就是本题的代码。

### 题目总结与参考代码

本题的“神奇之处”就在于使用动态规划进行剪枝。最后提醒一句，**本题多测，不要忘记清空和重置答案**。

```cpp
#include <bits/stdc++.h>
using namespace std;

int T, n, s[25], c[5], dp[26][15][10][6], ans;

void dfs(int x){
	if (x >= ans) return ;
	
	memset(c, 0, sizeof c);
	for (int i = 2; i <= 14; i++) c[s[i]]++;
	ans = min(ans, x + dp[c[1]+s[0]][c[2]][c[3]][c[4]]);
	if (s[0] == 2) ans = min(ans, x + dp[c[1]][c[2]][c[3]][c[4]] + 1);
	
	for (int a = 1; a <= 3; a++){
		for (int i = 3; i <= 14; i++){
			int cnt = 0;
			for (int j = i; j <= 14; j++){
				if (s[j] >= a) cnt++;
				else break;
				if (a * cnt >= 5){
					for (int k = i; k <= j; k++){
						s[k] -= a;
					}
					dfs(x+1);
					for (int k = i; k <= j; k++){
						s[k] += a;
					}
				}
			}
			
		}
	}
	return ;
}

int main(){
	for (int d = 0; d <= 5; d++){
		for (int c = 0; c <= 8; c++){
			for (int b = 0; b <= 12; b++){
				for (int a = 0; a <= 23; a++){
					if (!a && !b && !c && !d) continue;
					int s = 0x3f3f3f3f;
					
					if (a) s = min(s, dp[a-1][b][c][d] + 1);
					if (b) s = min(s, dp[a][b-1][c][d] + 1);
					if (c) s = min(s, dp[a][b][c-1][d] + 1);
					if (d) s = min(s, dp[a][b][c][d-1] + 1);
					
					if (a && c) s = min(s, dp[a-1][b][c-1][d] + 1);
					if (b && c) s = min(s, dp[a][b-1][c-1][d] + 1);
					if (a >= 2 && d) s = min(s, dp[a-2][b][c][d-1] + 1);
					if (b >= 2 && d) s = min(s, dp[a][b-2][c][d-1] + 1);
					
					if (b) s = min(s, dp[a+2][b-1][c][d]);
					if (c) s = min(s, dp[a+1][b+1][c-1][d]);
					if (d) s = min(s, dp[a][b+2][c][d-1]);
					if (d) s = min(s, dp[a+1][b][c+1][d-1]);
					
					dp[a][b][c][d] = s;
				}
			}
		}
	}
	cin >> T >> n;
	while (T--){
		memset(s, 0, sizeof s);
		for (int i = 1; i <= n; i++){
			int x, y; cin >> x >> y;
			if (x == 1) x = 14;
			s[x]++;
		}
		ans = 0x7f7f7f7f;
		dfs(0);
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：Ciyang (赞：6)

暴力出奇迹，~~我是搜索小名士~~。

博客中观看体验更佳：[My Blog](https://xciyang.github.io/)


### 分析

其实我一开始没有想着去写100分的代码，因为爆搜的复杂度太大，然后这题好像我只会爆搜。

#### 第一步

首先，很容易想到一种最纯粹的爆搜。每层都将当前剩余牌可行的情况全部枚举判断，然后打出一种可行的牌进入下一层继续搜索。

```
搜索是盲目的，我们考虑剪枝。    ——某金牌教练
```

一个剪枝是搜索必备，如果当前答案大于或等于已知的最小答案，我们接下来的搜索一定不会更新答案，所以回到上一层。

然后再继续想，可以加一个启发式剪枝，计算打出所有剩余牌的最大出牌次数。

用肉眼就能推出，一副牌的最大出牌次数就是牌的数码种类数，两个王在此可以算一种。然后我们计算出当前最大出牌次数加上当前已出牌次数去更新答案，这样就会剪去接下来的一些较差的出牌方法。

#### 第二步

上面的方法必不能通过本题，不需要尝试也能猜测。所以还要继续剪枝。

再稍微思考一下，我们每层搜索将全部出牌方法都枚举一遍过于暴力。我们发现，有些出牌方法自始至终永远不可行，并且可行的出牌方法一定越来越少。然后就想到了预处理，我们预处理出最开始的手牌的可行出牌方法。

这里我的代码极其鬼畜，可能对代码能力有些要求。我用了一些自认为省空间，用起来舒服的方法。将可行方法的信息写成结构体，就不演示，代码中在讲讲。

最关键的是，我们要计算每种方法的出牌数量，可用来后续我们继续优化。

这些代码全部可在输入后搜索前执行，我是将这些可行方法放到了vector中。在搜索时，枚举vector的所有元素。再进行一次针对性判断，也就是判断需要打的那几张牌就够了。

#### 第三步

我们说记录了每种方法的出牌数量。那我们从大到小排序，这样大概能优化时间，我也不知道。

在这我们提个醒，如果你将王炸、对子、三张牌放入可行方法中，那你一定会TLE，因为我一开始就是这样。（实践出真知，但其实非加强版不需要，到这里已经通过了）

我们每层搜索，只枚举上一层搜索枚举没有枚举到的就行了，这是个小剪枝。如果当前方法的出牌数大于当前剩余数量，就直接枚举下一个出牌方法，这也可算上个小剪枝。然后还要再次判断当前剩余的牌下这种方法是否可行。

还有几个小的要点，我们不管是预处理，还是每层搜索都要用到一个小动态规划，用来求某个牌当左端点，可以连成（单、双、三）顺子的最大长度。鉴于这个题的难度，我相信大家都会这个小动归。

然后还有几个提示，四带二可以带两个相同数码的对子（俗称炸弹），同理，可以带两个相同数码的一张牌（俗称对子）。然后1当14，大小王当15、16比较好写代码。

经过多次提交更改调试，终于通过了本题。

### 代码

不开O2两秒多通过。

```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <vector>
#include <algorithm>
using namespace std;
int T, n;
struct PAI {
	int num, col;
} ps[30];
// 记录牌的数码，颜色（没啥用）
#define SHUNZI 3
#define SANDAI 4
#define SIDAI 5
//顺子、三带、四带
struct CP {
    // 记录出牌方法的信息
	int typ, l, r, k1, k2, siz;
    // typ 为宏定义的值
    // siz 为出牌数量
    // l r 多种使用。l：顺子左端点，其他为最多的那张牌。r：顺子右端点，其他为少的那张牌需要的个数
    // k1 k2 三带、四带使用，表示附带哪一（两）张牌。
	CP(int typ, int siz, int l= 0, int r= 0, int k1= 0, int k2= 0) {
		this->typ= typ, this->siz= siz, this->l= l, this->r= r, this->k1= k1, this->k2= k2;
	}
	inline int operator<(const CP &c2) const {
		return siz > c2.siz;
	}
};
int pai[20], bestans, us3[20], us2[20], us1[20];
vector< CP > v;
void dfs(int nown, int nowa, int ls) {
	if(nowa >= bestans) return;
    // 小剪枝
	bestans= min(bestans, nowa + nown);
    // 更新答案，全部单打（没什么用）
	if(!nown) return;
	int res= 0, us[4][20];
	memset(us, 0, sizeof(us));
	for(int i= 2; i <= 16; i++) res+= (pai[i] != 0);
	if(pai[15] && pai[16]) --res;
    // 15、16为大小王，主程序中有，大小王可以王炸
	bestans= min(bestans, nowa + res);
    // 再次更新答案（剪枝）
	for(int i= 14, cnt= 0; i >= 2; i--) {
		if(pai[i] < 1) continue;
		us[1][i]= us[1][i + 1] + 1;
		if(pai[i] < 2) continue;
		us[2][i]= us[2][i + 1] + 1;
		if(pai[i] < 3) continue;
		us[3][i]= us[3][i + 1] + 1;
	}
    // DP出可行的顺子长度
	for(int i= ls; i < v.size(); i++) {
		if(v[i].siz > nown) continue;
		switch(v[i].typ) {
			case SHUNZI: {
				if(v[i].r - v[i].l + 1 > us[v[i].k1][v[i].l]) break;
				for(int j= v[i].l; j <= v[i].r; j++) pai[j]-= v[i].k1;
				dfs(nown - v[i].siz, nowa + 1, i + 1);
				for(int j= v[i].l; j <= v[i].r; j++) pai[j]+= v[i].k1;
                // 判断顺子
				break;
			}
			case SANDAI: {
				if(pai[v[i].l] < 3 || pai[v[i].k1] < v[i].r) break;
				pai[v[i].l]-= 3, pai[v[i].k1]-= v[i].r;
				dfs(nown - v[i].siz, nowa + 1, i + 1);
				pai[v[i].l]+= 3, pai[v[i].k1]+= v[i].r;
                // 判断三带
				break;
			}
			case SIDAI: {
				if(pai[v[i].l] < 4) break;
				if(pai[v[i].k1] < 1 || pai[v[i].k2] < 1) break;
				if(v[i].r == 2 && (pai[v[i].k1] < 2 || pai[v[i].k2] < 2)) break;
                // 都需要两张
				if(v[i].r == 2 && v[i].k1 == v[i].k2 && pai[v[i].k1] < 4) break;
                // 两对相同数码
				if(v[i].r == 1 && v[i].k1 == v[i].k2 && pai[v[i].k1] < 2) break;
                // 两张相同数码
				pai[v[i].l]-= 4;
				pai[v[i].k1]-= v[i].r;
				pai[v[i].k2]-= v[i].r;
				dfs(nown - v[i].siz, nowa + 1, i + 1);
				pai[v[i].l]+= 4;
				pai[v[i].k1]+= v[i].r;
				pai[v[i].k2]+= v[i].r;
                // 判断四带
			}
			default: break;
		}
	}
	return;
}
int main() {
	scanf("%d%d", &T, &n);
	while(T--) {
		memset(pai, 0, sizeof(pai)), bestans= 0x3f3f3f3f;
		for(int i= 1; i <= n; i++) {
			scanf("%d%d", &ps[i].num, &ps[i].col);
			if(ps[i].num == 1) ps[i].num= 14;
            // 1 当 14
			if(ps[i].num == 0) ps[i].num= ps[i].col + 14;
            // 大小王当15、16
			++pai[ps[i].num];
		}
		memset(us3, 0, sizeof(us3)), memset(us2, 0, sizeof(us2)), memset(us1, 0, sizeof(us1));
		v.clear();
		for(int i= 14; i >= 3; i--) {
			if(pai[i] < 1) continue;
			us1[i]= us1[i + 1] + 1;
			if(pai[i] < 2) continue;
			us2[i]= us2[i + 1] + 1;
			if(pai[i] < 3) continue;
			us3[i]= us3[i + 1] + 1;
		}
        // DP出顺子长度
		for(int i= 2; i <= 16; i++) {
			for(int j= 5; j <= us1[i]; j++) v.push_back(CP(SHUNZI, j, i, i + j - 1, 1));
			for(int j= 3; j <= us2[i]; j++) v.push_back(CP(SHUNZI, j * 2, i, i + j - 1, 2));
			for(int j= 2; j <= us3[i]; j++) v.push_back(CP(SHUNZI, j * 3, i, i + j - 1, 3));
            // i 当左端点的顺子
			if(pai[i] < 3) continue;
			for(int j= 2; j <= 16; j++) {
				if(i == j || !pai[j]) continue;
				v.push_back(CP(SANDAI, 4, i, 1, j));
				if(pai[j] < 2) continue;
				v.push_back(CP(SANDAI, 5, i, 2, j));
			}
            // 三带
			if(pai[i] < 4) continue;
			for(int j= 2; j <= 16; j++) {
				if(i == j || !pai[j]) continue;
				for(int k= j + 1; k <= 16; k++) {
					if(i == k || !pai[k]) continue;
					v.push_back(CP(SIDAI, 6, i, 1, j, k));
					if(pai[j] < 2 || pai[k] < 2) continue;
					v.push_back(CP(SIDAI, 8, i, 2, j, k));
				}
				if(pai[j] == 4) v.push_back(CP(SIDAI, 8, i, 2, j, j));
				if(pai[j] > 2) v.push_back(CP(SIDAI, 6, i, 1, j, j));
			}
            // 四带
		}
		sort(v.begin(), v.end());
        // 排序
		dfs(n, 0, 0);
		cout << bestans << endl;
	}
	return 0;
}
···

---

## 作者：chenhanzheapple (赞：2)

前言：调了3h

# [传送门](https://www.luogu.com.cn/problem/P2540)

## 思路

首先发现，**只有打顺子时与大小有关，其他与牌的大小无关**。

所以可以搜索如何打顺子，dp 打其他牌。

---

### 搜索

搜索很简单，贴个代码：

```cpp
void dfs(int x){
    if(x>=ans){//剪枝
        return;
    }
    memset(c,0,sizeof(c));
    for(int i=2;i<=14;i++){//统计每种牌的出现次数，c[1]表示单牌，c[2]表示对牌，c[3]表示三张牌，c[4]表示炸弹
        c[s[i]]++;
    }
    /*
    下面的dp一会讲
    */
    ans = min(ans,x+f[c[1]+s[0]][c[2]][c[3]][c[4]]);//顺便处理王牌：当做单牌出
    if(s[0]>=2){
        ans = min(ans,x+f[c[1]][c[2]][c[3]][c[4]]+1);//当做火箭（对牌）单出
    }
    for(int a=1;a<=3;a++){//枚举顺子：单顺，双顺，三顺
        for(int i=3;i<=14;i++){//枚举开头，特殊说明：14表示Ase，2不能在顺子里。
            int cnt = 0;//统计顺子里有多少牌
            for(int j=i;j<=14;j++){//枚举结尾
                if(s[j]>=a){//这种牌可以在顺子内
                    cnt+=a;//增加牌数
                }
                else{//否则就不连着了，直接break掉
                    break;
                }
                if(cnt>=5){//如果可以打顺子
                    for(int k=i;k<=j;k++){//打顺子
                        s[k]-=a;
                    }
                    dfs(x+1);//搜索
                    for(int k=i;k<=j;k++){//回溯
                        s[k]+=a;
                    }
                }
            }
        }
    }
}
```

---

### dp

做一个 $4$ 维 dp，$f_{a_{b_{c_d}}}$ 表示在还剩 $a$ 张单牌，$b$ 个对子，$c$ 个三张，$d$ 个炸弹时最少需要多少步才能打完。

给一个转移表格。

|方法|状态|
|:-:|:-:|
|打单牌|$f[a-1][b][c][d]+1$|
|打对子|$f[a][b-1][c][d]+1$|
|打三张牌|$f[a][b][c-1][d]+1$|
|打炸弹|$f[a][b][c][d-1]+1$|
|打三带一|$f[a-1][b][c-1][d]+1$|
|打三带二|$f[a][b-1][c-1][d]+1$|
|打四带二单|$f[a-2][b][c][d-1]+1$|
|打四带二对|$f[a][b-2][c][d-1]+1$|

当然，这样是错的。

给个反例：$JJJ$ $QQQ$ $KKK$。

如果按刚才那样打的话，需要三步才能打完(打三次三张牌)，但实际上我们可以 **拆牌（打一次三带一，打一次三带二）**。

再给一个拆牌的转移表格。

|方法|状态|
|:-:|:-:|
|把对牌拆成两张单牌|$f[a+2][b-1][c][d]$|
|把三张牌拆成一单一对|$f[a+1][b+1][c-1][d]$|
|把炸弹拆成两个对牌|$f[a][b+2][c][d-1]$|
|把炸弹拆成一单一三|$f[a+1][b][c+1][d-1]$|

其中将三张牌拆成三张单牌可以先将三张牌拆成一单一对，再将对牌拆成两张单牌，因此不用单独写一个转移。

把炸弹拆成四张单牌同理。

**特别注意：拆牌不耗步数；小心数组越界**

上代码！

```cpp
    //初始化
	memset(f,0x3f,sizeof(f));
	f[0][0][0][0] = 0;
    //开始dp
	for(int d=0;d<=5;d++){//枚举炸弹个数
        for(int c=0;c<=7;c++){//枚举三张牌个数
            for(int b=0;b<=11;b++){//枚举对牌个数
                for(int a=0;a<=23;a++){//枚举单牌个数
                    //就是上面的循环边界浪费了我2h
                    if(a+b*2+c*3+d*4>n){//牌可以打出（减少），但不能凭空变出来（增多）
                        continue;
                    }
                    //打牌，注意不要越界
                    if(a>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a-1][b][c][d]+1);
                    }
                    if(b>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a][b-1][c][d]+1);
                    }
                    if(c>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a][b][c-1][d]+1);
                    }
                    if(d>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a][b][c][d-1]+1);
                    }
                    if(a>0 && c>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a-1][b][c-1][d]+1);
                    }
                    if(b>0 && c>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a][b-1][c-1][d]+1);
                    }
                    if(a>1 && d>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a-2][b][c][d-1]+1);
                    }
                    if(b>1 && d>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a][b-2][c][d-1]+1);
                    }
                    //拆牌，同样不能越界
                    if(b>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a+2][b-1][c][d]);
                    }
                    if(c>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a+1][b+1][c-1][d]);
                    }
                    if(d>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a][b+2][c][d-1]);
                    }
                    if(d>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a+1][b][c+1][d-1]);
                    }
                }
            }
        }
	}
```

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,ans;
bool flag;
int s[25],c[25],f[30][30][30][30];
void dfs(int x){
    if(x>=ans){//剪枝
        return;
    }
    memset(c,0,sizeof(c));
    for(int i=2;i<=14;i++){//统计每种牌的出现次数，c[1]表示单牌，c[2]表示对牌，c[3]表示三张牌，c[4]表示炸弹
        c[s[i]]++;
    }
    ans = min(ans,x+f[c[1]+s[0]][c[2]][c[3]][c[4]]);//顺便处理王牌：当做单牌出
    if(s[0]>=2){
        ans = min(ans,x+f[c[1]][c[2]][c[3]][c[4]]+1);//当做火箭（对牌）单出
    }
    for(int a=1;a<=3;a++){//枚举顺子：单顺，双顺，三顺
        for(int i=3;i<=14;i++){//枚举开头，特殊说明：14表示Ase，2不能在顺子里。
            int cnt = 0;//统计顺子里有多少牌
            for(int j=i;j<=14;j++){//枚举结尾
                if(s[j]>=a){//这种牌可以在顺子内
                    cnt+=a;//增加牌数
                }
                else{//否则就不连着了，直接break掉
                    break;
                }
                if(cnt>=5){//如果可以打顺子
                    for(int k=i;k<=j;k++){//打顺子
                        s[k]-=a;
                    }
                    dfs(x+1);//搜索
                    for(int k=i;k<=j;k++){//回溯
                        s[k]+=a;
                    }
                }
            }
        }
    }
}
signed main(){
	cin >> t >> n;
    //初始化
	memset(f,0x3f,sizeof(f));
	f[0][0][0][0] = 0;
    //开始dp
	for(int d=0;d<=5;d++){//枚举炸弹个数
        for(int c=0;c<=7;c++){//枚举三张牌个数
            for(int b=0;b<=11;b++){//枚举对牌个数
                for(int a=0;a<=23;a++){//枚举单牌个数
                    //就是上面的循环边界浪费了我2h
                    if(a+b*2+c*3+d*4>n){//牌可以打出（减少），但不能凭空变出来（增多）
                        continue;
                    }
                    //打牌，注意不要越界
                    if(a>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a-1][b][c][d]+1);
                    }
                    if(b>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a][b-1][c][d]+1);
                    }
                    if(c>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a][b][c-1][d]+1);
                    }
                    if(d>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a][b][c][d-1]+1);
                    }
                    if(a>0 && c>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a-1][b][c-1][d]+1);
                    }
                    if(b>0 && c>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a][b-1][c-1][d]+1);
                    }
                    if(a>1 && d>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a-2][b][c][d-1]+1);
                    }
                    if(b>1 && d>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a][b-2][c][d-1]+1);
                    }
                    //拆牌，同样不能越界
                    if(b>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a+2][b-1][c][d]);
                    }
                    if(c>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a+1][b+1][c-1][d]);
                    }
                    if(d>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a][b+2][c][d-1]);
                    }
                    if(d>0){
                        f[a][b][c][d] = min(f[a][b][c][d],f[a+1][b][c+1][d-1]);
                    }
                }
            }
        }
	}
	while(t--){
		memset(s,0,sizeof(s));
		ans = n;
		for(int i=1;i<=n;i++){
			int x,y;
			cin >> x >> y;
			if(x==1){//统计每种牌的数量，14号牌表示Ase
				s[14]++;
			}
			else{
				s[x]++;
			}
		}
		dfs(0);
		cout << ans << endl;
	}
	return 0;
}

```

---

## 作者：ZHR100102 (赞：2)

一步一步推性质就能做出来的剪枝题。

这题思路和小木棒的剪枝思路极其相似，剪枝的角度都差不多。

其实大部分搜索剪枝题都是先观察性质，列出性质后选择几个比较关键且代码好写的性质进行剪枝，特别要注意避免重复搜索相同状态的剪枝。同时注意想好了之后再写代码。

并且大部分搜索题会把正向的搜索树 hack 得很大，当被卡的时候不妨试试倒着搜索，可能有奇效。

# 思路

观察题目，我们可以发现如下几点性质：
- 出牌的顺序不影响最终的结果，先出某一组牌和后出某一组牌本质是一样的。
- 最后只剩下单牌、对子、三张牌、炸弹和王炸的时候，我们可以贪心地扫一遍统计至少存在一张牌的码数的个数，特判掉大小王得出答案。
- 在顺子和带牌中，顺子打出的方案数一般比带牌的方案数更少。

因此，我们可以设计出如下剪枝方案：
- 将搜索阶段拆解为 $6$ 步，依次完成。分别是三顺子、双顺子、单顺子、四带二、三带一和二、最后剩下的统一出掉，大王小王绑一起出。
- 记录下当前的搜索阶段 $p$，以及上一次在同阶段最后搜索到的牌 $lst$。每次接着 $lst$ 后面来搜索，避免搜到重复状态。
- 把三顺子、双顺子、单顺子、四带二、三带一和二全部出完之后，我们可以线性扫一遍算出最终的答案，避免了搜索多余状态。

实现的时候对每个搜索阶段分步实现，代码在写顺子和带牌内部时可以稍作修改之后重复利用。

时间复杂度玄学，但是除非对着卡很难 hack 掉。

# 代码

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
using namespace std;
using pi=pair<int,int>;
/*
三顺子 1
双顺子 2
单顺子 3
四带二 4
三带一、二 5
最后剩下的统一出掉，大王小王绑一起出。 
1~11 3~K
12 A
13 2
14 little
15 big
*/
int tot[20],ans=0x3f3f3f3f,now=0,n;
void dfs(int p,int lst)
{
	if(p>=6)
	{
		int cur=0;
		for(int i=1;i<=15;i++)if(tot[i])cur++;
		if(tot[14]&&tot[15])cur--;
		ans=min(ans,now+cur);
		return;
	}
	if(p==1)
	{
		int pre=0;
		for(int i=1;i<=12;i++)
		{
			if(tot[i]>=3)pre++;
			else pre=0;
			if(pre>=2&&i>=lst)
			{
				int tmp[20];
				memcpy(tmp,tot,sizeof(tmp));
				tot[i]-=3;
				for(int j=2;j<=pre;j++)
				{
					tot[i-j+1]-=3;
					now++;
					dfs(p,i);
					now--;
				}
				memcpy(tot,tmp,sizeof(tmp));
			}
		}
		dfs(p+1,1);
		return;
	}
	if(p==2)
	{
		int pre=0;
		for(int i=1;i<=12;i++)
		{
			if(tot[i]>=2)pre++;
			else pre=0;
			if(pre>=3&&i>=lst)
			{
				int tmp[20];
				memcpy(tmp,tot,sizeof(tmp));
				tot[i]-=2;
				tot[i-1]-=2;
				for(int j=3;j<=pre;j++)
				{
					tot[i-j+1]-=2;
					now++;
					dfs(p,i);
					now--;
				}
				memcpy(tot,tmp,sizeof(tmp));
			}
		}
		dfs(p+1,1);
		return;		
	}
	if(p==3)
	{
		int pre=0;
		for(int i=1;i<=12;i++)
		{
			if(tot[i]>=1)pre++;
			else pre=0;
			if(pre>=5&&i>=lst)
			{
				int tmp[20];
				memcpy(tmp,tot,sizeof(tmp));
				tot[i]-=1;
				tot[i-1]-=1;
				tot[i-2]-=1;
				tot[i-3]-=1;
				for(int j=5;j<=pre&&i-j+1>=1;j++)
				{
					tot[i-j+1]-=1;
					now++;
					dfs(p,i);
					now--;
				}
				memcpy(tot,tmp,sizeof(tmp));
			}
		}
		dfs(p+1,1);
		return;		
	}
	if(p==4)
	{
		for(int i=1;i<=13;i++)
		{
			if(tot[i]>=4)
			{
				tot[i]-=4;
				for(int j=1;j<=15;j++)
				{
					if(tot[j]<=0)continue;
					for(int k=1;k<=15;k++)
					{
						if(tot[k]<=0)continue;
						if(tot[j]&&tot[k]&&(j!=k||tot[j]>=2))
						{
							tot[j]--;
							tot[k]--;
							now++;
							dfs(p,i);
							tot[j]++;
							tot[k]++;
							now--;
						}
						if(tot[j]>=2&&tot[k]>=2&&(j!=k||tot[j]>=4))
						{
							tot[j]-=2;
							tot[k]-=2;
							now++;
							dfs(p,i);
							tot[j]+=2;
							tot[k]+=2;
							now--;
						}			
					}
				}
				tot[i]+=4;
			}
		}
		dfs(p+1,1);
		return;
	}
	if(p==5)
	{
		for(int i=1;i<=13;i++)
		{
			if(tot[i]>=3)
			{
				tot[i]-=3;
				for(int j=1;j<=15;j++)
				{
					if(tot[j]>=1)
					{
						tot[j]--;
						now++;
						dfs(p,i);
						tot[j]++;
						now--;
					}
					if(tot[j]>=2)
					{
						tot[j]-=2;
						now++;
						dfs(p,i);
						tot[j]+=2;
						now--;
					}
				}
				tot[i]+=3;
			}
		}
		dfs(p+1,1);
		return;
	}
}
void solve()
{
	memset(tot,0,sizeof(tot));
	ans=0x3f3f3f3f;
	now=0;
	for(int i=1;i<=n;i++)
	{
		int a,b;
		cin>>a>>b;
		if(3<=a&&a<=13)tot[a-2]++;
		else if(a<3&&a>0)tot[a+11]++;
		else tot[b+13]++;
	}
	dfs(1,1);
	cout<<ans<<'\n';
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t;
	cin>>t>>n;
	while(t--)solve();
	return 0;
}
```

---

## 作者：DeepSeekR1 (赞：1)

加强版跟普通版的区别就是要加一个很甜菜的优化。

~~虽然我因为刚做完愤怒的小鸟导致在普通版就用上了这个优化~~

因为最后总是要把牌出完的，所以只有顺序不同的情况可以被认为是同一种方法，这会减少很多情况。

于是我们规定每次出牌必须带上现在剩下的所有牌中的最小的那张，枚举其他的牌，这样就优化完了。

不过因为一定要出最小那张的原因，需要更多的分类讨论。假设最小的是 `3`, 那么 `3334` 和 `3444` 这两种情况是要分开讨论的。

那么模拟部分就分这几类：

单牌，也就是出的所有牌都是最小的：单，对，三，炸。

2\. 顺子：单顺子，双顺子，三顺子。

到带这里就要分类了

3.1. 最小的出一张的：`(1+4+1)`，`(1+3)`

3.2. 最小的出两张的：`(2+4+2)`，`(2+3)`，`(2+4)`

3.3. 最小的出三张的：`(3+1)`，`(3+2)`

3.4. 最小的出四张的：`(4+2+2)`，`(4+1+1)`

4\. 最小的是小王时特判一下王炸即可。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int ans;
int a[20000];
void prt () {
	for (int i = 2;i <= 16;i++) {
		cout << a[i] << ' ';
	}
	cout << endl;
	return;
}
void dfs(int d) {
//	cout << d << ' ';
//	prt();
	if (d >= ans) {
		return;
	}
	int x = 0;
	for (int i = 2;i <= 16;i++) {
		if (a[i] > 0) {
			x = i;
			break;
		}
	}
	if (x == 0) {
		ans = min(ans,d);
		return;
	}
	if (3 <= x && x <= 13) {//三顺子
		int l = 0;
		for (int i = 1;x + i - 1 <= 14;i++) {
			if (a[x + i - 1] < 3) {
				break;
			}
			l = i;
		}
		if (l < 2) {
			goto s3;
		}
		for (int j = x;j <= x + l - 1;j++) {
			a[j] -= 3;
		}
		for (int j = x + l - 1;j >= x;j--) {
			if (j - x + 1 < 2) {
				a[j] += 3;
				continue;
			}
			dfs(d + 1);
			a[j] += 3;
		}
	}
	s3:
	if (3 <= x && x <= 12) {//双顺子
		int l = 0;
		for (int i = 1;x + i - 1 <= 14;i++) {
			if (a[x + i - 1] < 2) {
				break;
			}
			l = i;
		}
		if (l < 3) {
			goto s2;
		}
		for (int j = x;j <= x + l - 1;j++) {
			a[j] -= 2;
		}
		for (int j = x + l - 1;j >= x;j--) {
			if (j - x + 1 < 3) {
				a[j] += 2;
				continue;
			}
			dfs(d + 1);
			a[j] += 2;
		}
	}
	s2:
	if (3 <= x && x <= 10) {//单顺子
		int l = 0;
		for (int i = 1;x + i - 1 <= 14;i++) {
			if (a[x + i - 1] < 1) {
				break;
			}
			l = i;
		}
		if (l < 5) {
			goto s1;
		}
		for (int j = x;j <= x + l - 1;j++) {
			a[j] -= 1;
		}
		for (int j = x + l - 1;j >= x;j--) {
			if (j - x + 1 < 5) {
				a[j] += 1;
				continue;
			}
			dfs(d + 1);
			a[j] += 1;
		}
	}
	s1:
	if (a[x] >= 1) {//1带 
		if (true) {//x=1,1+4+1
			a[x]--;
			for (int i = 2;i <= 16;i++) {
				if (a[i] < 4) {
					continue;
				}
				a[i] -= 4;
				for (int j = 2;j <= 16;j++) {
					if (i == x || j == x) {
						continue;
					}
					if (a[j] >= 1) {
						a[j]--;
						dfs(d + 1);
						a[j]++;
					}
				}
				a[i] += 4;
			}
			a[x]++;
		}
		if (true) {//x=1,1+3
			a[x]--;
			for (int i = 2;i <= 16;i++) {
				if (x == i) {
					continue;
				} 
				if (a[i] >= 3) {
					a[i] -= 3;
					dfs(d + 1);
					a[i] += 3;
				}
			}
			a[x]++;
		} 
	}
	if (a[x] >= 2) {//2带 
		if (true) {//x=2,2+4+2
			a[x] -= 2;
			for (int i = 2;i <= 16;i++) {
				if (a[i] < 4) {
					continue;
				}
				a[i] -= 4;
				for (int j = 2;j <= 16;j++) {
					if (i == x || j == x) {
						continue;
					}
					if (a[j] >= 2) {
						a[j] -= 2;
						dfs(d + 1);
						a[j] += 2;
					}
				}
				a[i] += 4;
			}
			a[x] += 2;
		}
		if (true) {//x=2,2+4
			a[x] -= 2;
			for (int i = 2;i <= 16;i++) {
				if (i == x) {
					continue;
				}
				if (a[i] >= 4) {
					a[i] -= 4;
					dfs(d + 1);
					a[i] += 4;
				}
			}
			a[x] += 2;
		}
		if (true) {//x=2,2+3
			a[x] -= 2;
			for (int i = 2;i <= 16;i++) {
				if (i == x) {
					continue;
				}
				if (a[i] >= 3) {
					a[i] -= 3;
					dfs(d + 1);
					a[i] += 3;
				}
			}
			a[x] += 2;
		}
	}
	if (a[x] >= 3) {//3带 
		if (true) {//x=3,3+2
			a[x] -= 3;
			for (int i = 2;i <= 16;i++) {
				if (i == x) {
					continue;
				}
				if (a[i] >= 2) {
					a[i] -= 2;
					dfs(d + 1);
					a[i] += 2;
				}
			}
			a[x] += 3;
		}
		if (true) {//x=3,3+1
			a[x] -= 3;
			for (int i = 2;i <= 16;i++) {
				if (i == x) {
					continue;
				}
				if (a[i] >= 1) {
					a[i] -= 1;
					dfs(d + 1);
					a[i] += 1;
				}
			}
			a[x] += 3;
		}
	}
	if (a[x] >= 4) {//4带
		if (true) {//x=4,4+2+2
			a[x] -= 4;
			for (int i = 2;i <= 16;i++) {
				if (a[i] < 2) {
					continue;
				}
				a[i] -= 2;
				for (int j = i;j <= 16;j++) {
					if (i == x || j == x) {
						continue;
					}
					if (a[j] >= 2) {
						a[j] -= 2;
						dfs(d + 1);
						a[j] += 2;
					}
				}
				a[i] += 2;
			}
			a[x] += 4;
		}
		if (true) {//x=4,4+1+1
			a[x] -= 4;
			for (int i = 2;i <= 16;i++) {
				if (a[i] < 1) {
					continue;
				}
				a[i]--;
				for (int j = i;j <= 16;j++) {
					if (i == x || j == x) {
						continue;
					}
					if (a[j] >= 1) {
						a[j]--;
						dfs(d + 1);
						a[j]++;
					}
				}
				a[i]++;
			}
			a[x] += 4;
		}
	}
	if (a[x] >= 4) {//4
		a[x] -= 4;
		dfs(d + 1);
		a[x] += 4;
	}
	if (a[x] >= 3) {//3
		a[x] -= 3;
		dfs(d + 1);
		a[x] += 3;
	}
	if (a[x] >= 2) {//2
		a[x] -= 2;
		dfs(d + 1);
		a[x] += 2;
	}
	if (a[x] >= 1) {//1
		a[x]--;
		dfs(d + 1);
		a[x]++;
	}
	if (x == 15) {//王炸 
		if (a[15] > 0 && a[16] > 0) {
			a[15]--,a[16]--;
			dfs(d + 1);
			a[15]++,a[16]++;
		}
	}
	return;
}
int t,n,x,y;
inline void mian () {
	for (int i = 1;i <= n;i++) {
		cin >> x >> y;
		if (x) {
			if (x == 1) {
				a[14]++;
			} else {
				a[x]++;
			}
		} else {
			a[14 + y]++;
		}
	}
	dfs(0);
	cout << ans << endl;
	return;
}
inline void init () {
	ans = 2147483647;
	memset(a,0,sizeof(a));
}
signed main () {
	cin >> t >> n;
	while (t--) {
		init();
		mian();
	}
	fclose(stdout);
	return 0;
}
```

---

## 作者：gongruixin (赞：1)

# 题目大意
有以下几种出牌形式：

 ![](https://cdn.luogu.com.cn/upload/pic/1827.png)     
 问你最少几次可以出完手牌。

注意：
- 双王不可以当对子带，但可以当单牌带。   
- 四带两对可以带四张相同的牌，四带二可以带对子。


# 思路
暴力出奇迹，考虑直接 DFS 暴力，枚举所有的方案，直接暴力出最少的次数。   
暴力顺序：单顺子$\to$双顺子$\to$三顺子$\to$三带一$\to$三带二$\to$四带二$\to$四带两对$\to$散牌。  
（这只是我的顺序，别的应该也行）。   
你们可能会说，这会 TLE。  
考虑剪枝优化。  
只要加上

```cpp
if(x>=ans) //x是当前次数，ans是最后的答案
    return;
```
就能减掉大部分的时间。因为当前次数已经超过了最优次数，就没必要往下搜了。  
你们又要说了，还是会 TLE，没有用。   
怎么办呢，我们就能使用信仰一剪。  
考虑通过计数器来统计 DFS 的次数，达到一定值后退出来卡时间（我选的值是 $1 \times 10^6$）。
```cpp
int dfn;
void dfs(int x)
{
    if(++dfn>1000000) 
        return;
...........
```
这样就能愉快的 AC 了。  
就下来就是...
# AC 代码
~~配合注释食用更佳。~~

```cpp
#include<bits/stdc++.h>
using namespace std;
#define Tie ios::sync_with_stdio(false),cin.tie(0),cout.tie(0) //快读
int T,n,ans,sum[25]; //T组数，n牌数，ans答案，sum记录牌数
int dfn; //记录dfs次数
void dfs(int x) //x记录次数
{
    if(++dfn>1000000) //剪枝优化1
        return;
	if(x>=ans) //剪枝优化2
        return;
	int k=0;
    //单顺子
	for(int i=3;i<=14;i++)
	{
		if(sum[i]==0) 
            k=0; //顺子断了,k清零
		else
		{
			k++; //顺子长度加一
			if(k>=5) //如果顺子长度大于等于5
			{
				for(int j=i-k+1;j<=i;j++) 
                    sum[j]--; //顺子中的牌数减一
				dfs(x+1); //搜下一层
				for(int j=i-k+1;j<=i;j++)  
                    sum[j]++;   //回溯
			}
		}
	}
	k=0; //清零
    //双顺子
	for(int i=3;i<=14;i++)
	{
		if(sum[i]<2) 
            k=0; //双顺子断了,k清零
		else 
		{
			k++; //双顺子长度加一
			if(k>=3) //如果双顺子长度大于等于3
            {
                for(int j=i-k+1;j<=i;j++) 
                    sum[j]-=2; //双顺子中的牌数减二
                dfs(x+1); //搜下一层
                for(int j=i-k+1;j<=i;j++) 
                    sum[j]+=2; //回溯
            }
		}
	}
	k=0;
    //三顺子
	for(int i=3;i<=14;i++)
	{
		if(sum[i]<=2) 
            k=0; //三顺子断了,k清零
		else 
		{
			k++;    //三顺子长度加一
			if(k>=2) //如果三顺子长度大于等于2
			{
				for(int j=i-k+1;j<=i;j++)
                    sum[j]-=3; //三顺子中的牌数减三
				dfs(x+1);
				for(int j=i-k+1;j<=i;j++)
                    sum[j]+=3;  //回溯
			}
		}
	}
    //以下原理同上
	for(int i=2;i<=14;i++)
	{
		if(sum[i]==3) //三带
        {
			sum[i]-=3;
			for(int j=2;j<=15;j++) //三带一
			{
				if(sum[j]<1||j==i) 
                    continue;
				sum[j]--;
				dfs(x+1);
				sum[j]++;
			}
			for(int j=2;j<=14;j++) //三带二
            {
                if(sum[j]<2||j==i) 
                    continue;
                sum[j]-=2;
                dfs(x+1);
                sum[j]+=2;
            }
			sum[i]+=3;
		} 
		if(sum[i]==4)//四带
		{
			sum[i]-=4;
			for(int j=2;j<=15;j++) //四带二
            {
				if(sum[j]<1||j==i) 
                    continue;
				sum[j]--;
				for (int k=2;k<=15;k++)
				{
					if(sum[k]<1) 
                        continue;
					sum[k]--;
					dfs(x+1);
					sum[k]++;
				}
				sum[j]++;
			}
			for(int j=2;j<=14;j++) //四带两对
			{
				if(sum[j]<2||j==i) 
                    continue;
				sum[j]-=2;
				for(int k=2;k<=14;k++) 
				{
					if(sum[k]<2) 
                        continue;
					sum[k]-=2;
					dfs(x+1);
					sum[k]+=2;
				}
				sum[j]+=2;
			}
			sum[i]+=4;
		}
	}
	for(int i=2;i<=15;i++) 
        if(sum[i]) 
            x++; //没出完的，无论是单张，对子，三张，四张都可以一次出完
	ans=min(ans,x); //更新答案
}
int main() 
{
    Tie;
	cin>>T>>n; 
	while(T--) 
	{
        dfn=0; //初始化1
		ans=INT_MAX;  //初始化2
		memset(sum,0,sizeof sum); //初始化3
		for(int i=1;i<=n;i++)
		{
            int x,y;
            cin>>x>>y;
			if(x==0) x=15; //0是大小王，算到15里
			if(x==1) x=14; //1是A，算到14里，因为A最大
		    sum[x]++; //记录牌数
		}
		dfs(0); //dfs
        cout<<ans<<'\n'; //输出答案
	}
}
```
[双倍经验: P2668 [NOIP2015 提高组] 斗地主](https://www.luogu.com.cn/problem/P2668)

---

## 作者：RainWetPeopleStart (赞：1)

原来的 DP 出散牌的题解被撤了，这里补一篇。

首先，考虑朴素的 dfs，暴力搜每次出什么牌。

考虑优化，只搜顺子，三带和四带，其他的用牌的种类数算即可，这个做法加点剪枝即可拿到 80 分以上。

瓶颈在搜上面，顺子很难快速处理，考虑快速处理三带和四带。

考虑 dp，记 $f_{a,b,c,d,e}$ 表示出完 $a$ 张单牌，$b$ 个对子，$c$ 个三带，$d$ 个炸弹，$e$ 张王的最小次数（这里王不算单牌）。

初始 $f_{0,0,0,0,0}=0$，其余 $f$ 取正无穷。 

下面是转移。(因 case 太多，不保证没有错误，若有请指出)

如果下标不合法就不做该情况的转移。

下文用 $a\leftarrow b$ 表示将 $a$ 变成 $\min(a,b)$。

- case1 出单牌

$f_{a,b,c,d,e}\leftarrow f_{a-1,b,c,d,e}+1$。

- case2 出对子

$f_{a,b,c,d,e}\leftarrow f_{a,b-1,c,d,e}+1$。

- case3 出三张

$f_{a,b,c,d,e}\leftarrow f_{a,b,c-1,d,e}+1$。

- case4 出炸弹

$f_{a,b,c,d,e}\leftarrow f_{a,b,c,d-1,e}+1$。

- case5 出一张王

$f_{a,b,c,d,e}\leftarrow f_{a,b,c,d,e-1}+1$。

- case6 出火箭

$f_{a,b,c,d,e}\leftarrow f_{a,b,c,d,e-2}+1$。

- case7 出三带一（带单牌）

$f_{a,b,c,d,e}\leftarrow f_{a-1,b,c-1,d,e}+1$。

- case8 出三带一（带王）

$f_{a,b,c,d,e}\leftarrow f_{a,b,c-1,d,e-1}+1$。

- case9 出三带二

$f_{a,b,c,d,e}\leftarrow f_{a,b-1,c-1,d,e}+1$。

- case10 出四带二（带两个不一样的单牌）

$f_{a,b,c,d,e}\leftarrow f_{a-2,b,c,d-1,e}+1$。

- case11 出四带二（带两个一样的单牌）

$f_{a,b,c,d,e}\leftarrow f_{a,b-1,c,d-1,e}+1$。

- case12 出四带二（带一单一王）

$f_{a,b,c,d,e}\leftarrow f_{a-1,b,c,d-1,e-1}+1$。

- case13 出四带二（带两王）

$f_{a,b,c,d,e}\leftarrow f_{a,b,c,d-1,e-2}+1$。

- case14 出四带二（带两个不一样的对子）

$f_{a,b,c,d,e}\leftarrow f_{a,b-2,c,d-1,e}+1$。

- case15 出四带二（带两个一样的对子）

$f_{a,b,c,d,e}\leftarrow f_{a,b,c,d-2,e}+1$。

- case16 拆三带

$f_{a,b,c,d,e}\leftarrow f_{a+1,b+1,c-1,d,e}$。

- case17 拆四带

$f_{a,b,c,d,e}\leftarrow f_{a+1,b,c+1,d-1,e}$。

说明：

本题中，拆对子一定不优，把三带/炸弹全部拆成单张也不优，把炸弹拆成两个对子的情况可以调整到能被转移到的情况，故上文转移是对的。

附代码（可读性不是特别高）：


```cpp
#include<bits/stdc++.h>
#define Rf(i,a,b) for(int i=(a);i<=(b);i++)
#define Rb(i,a,b) for(int i=(a);i>=(b);i--)
#define ll long long
#define jp8 push_back
using namespace std;
const int N=20;
int cnt[N];
//3 4 5 6 7 8 9 10J Q K A 2 Joker
//1 2 3 4 5 6 7 8 9 1011121314
int to[]={14,12,13,1,2,3,4,5,6,7,8,9,10,11};int n;
int ans=0;
int f[28][20][15][12][5];
inline void dfs(int now){
	if(now>=ans) return;//cout<<now<<endl;
	int len=0;int pf[]={0,5,3,2};
	Rf(p,1,3){
		len=0;
		Rf(i,1,12){
			if(cnt[i]<p) len=0;
			else len++;
			if(len>=pf[p]){
				Rf(q,pf[p],len){
					Rf(j,0,q-1) cnt[i-j]-=p;
					dfs(now+1);
					Rf(j,0,q-1) cnt[i-j]+=p;
				}
			}
		}
	}
	int oc=0,dc=0,tc=0,bm=0;
	Rf(i,1,13){
		if(cnt[i]==1) oc++;
		if(cnt[i]==2) dc++;
		if(cnt[i]==3) tc++;
		if(cnt[i]==4) bm++;
	}now+=f[oc][dc][tc][bm][cnt[14]];
	ans=min(ans,now);
}
void slv(){
	memset(cnt,0,sizeof(cnt));
	Rf(i,1,n){
		int a,b;cin>>a>>b;
		cnt[to[a]]++;
	}ans=100;
	dfs(0);cout<<ans<<endl;
}int zhengpai(int a,int b,int c,int d,int e){
	return min(
	(a>0)?f[a-1][b][c][d][e]:100,
	min(min((b>0)?f[a][b-1][c][d][e]:100,
	(c>0)?f[a][b][c-1][d][e]:100),
	min((d>0)?f[a][b][c][d-1][e]:100,
	(e>0)?f[a][b][c][d][e-1]:100)))+1;
}int sandai(int a,int b,int c,int d,int e){
	return min(
	(c>0&&a>0)?f[a-1][b][c-1][d][e]:100,
	min((c>0&&e>0)?f[a][b][c-1][d][e-1]:100,
	(c>0&&b>0)?f[a][b-1][c-1][d][e]:100))+1;
}int others(int a,int b,int c,int d,int e){
	return min(
	(e>1)?f[a][b][c][d][e-2]+1:100,
	min((c>0)?f[a+1][b+1][c-1][d][e]:100,
	(d>0)?f[a+1][b][c+1][d-1][e]:100));
}int sidai(int a,int b,int c,int d,int e){
	return min(
	min((d>0&&a>1)?f[a-2][b][c][d-1][e]:100, 
	(d>0&&a>0&&e>0)?f[a-1][b][c][d-1][e-1]:100
	),min(min((d>0&&b>0)?f[a][b-1][c][d-1][e]:100,
	(d>0&&e>1)?f[a][b][c][d-1][e-2]:100
	),min((d>1)?f[a][b][c][d-2][e]:100,
	(d>0&&b>1)?f[a][b-2][c][d-1][e]:100)))+1; 
}int modify(int a,int b,int c,int d,int e){
	return min(min(zhengpai(a,b,c,d,e),sandai(a,b,c,d,e)),min(sidai(a,b,c,d,e),others(a,b,c,d,e)));
}void init(){
	f[0][0][0][0][0]=0;
	Rf(d,0,8){
		Rf(c,0,12){
			Rf(a,0,25){
				Rf(b,0,15){
					Rf(e,0,2){
						if(a==0&&b==0&&c==0&&d==0&&e==0) continue;
						f[a][b][c][d][e]=modify(a,b,c,d,e);
						//if(a+b+c+d+e<=10)cout<<a<<' '<<b<<' '<<c<<' '<<d<<' '<<e<<' '<<f[a][b][c][d][e]<<endl;
					}
				}
			}
		}
	}//cout<<sidai(0,3,0,1,0);
	//cout<<f[0][2][0][0][0];
}
int main(){init();
	int t;cin>>t>>n;while(t--) slv();
    return 0;
}
```

---

## 作者：Walrus (赞：1)

首先这个题对于花色没关系，所以这里直接忽略花色影响。

**以下用「被三带」表示此牌是三张相同的牌带的单牌或一对，「被四带」同理。**

考虑这个题怎么做，结合迄今为止所有「斗地主」题目，含 PKUSC/PKUWC 的题目，考虑搜索并剪枝。

分别考虑每种**基础**牌型，即单、双、三、四（炸）。

## 单

单牌会引出「被三带」和「顺子」以及「被四带」三种牌型。

单牌、「被三带」和「被四带」的处理是简单的，「被四带」只是在「被三带」的基础上加上了再找一张单牌的过程。「顺子」稍复杂，因为我们在 dfs 的过程中是把点数小于当前搜索的牌的所有牌全部耗光才会进入当前牌的搜索，所以我们考虑直接向后枚举，考虑最短的五顺子，逐渐增大长度并判断是否可行。

实现其实也是简单的，但是注意枚举完之后请注意要做所谓的「还原现场」。

## 双

一对会引出「被三带」、「被四带」和「顺子」三种牌型。

同上，注意判王炸的情况。

## 三

会引出「三带」和「顺子」两种牌型。

注意这里的三带是主动的，故可以带单或者带对，同时注意不能带对王。

## 四

会引出「四带」一种牌型，注意带的牌可以是任意两张单牌或者任意两对（同样不能带对王）。

## 剪枝

显然是有最优性剪枝的，如果当前步数大于最优解就停止。

还可以记录剩余牌数，如果打光了就停止（好像是废话）。

大概思路就是这样，只需要从四个主干牌型去引伸出其它分支牌型，就避免了无头绪的搜索过程。

---

## 作者：chdy (赞：0)

~~由于本人特别会打斗地主~~，所以此题我在普通版本的代码稍加修改(也就是大小王不能当对这处)，然后通过了加强版。

我没有考虑怎么贪心甚至一开始我都不知道从哪下手开始搜索，那先考虑暴力搜，也就是每张牌的出牌形式。

剪枝：

- 必须有序我们发现最小出牌方式和出牌的顺序无关我们强制一定的顺序。这里的提现是由小到大出牌。把小的出完再出大的。

- 最优化剪枝。也就是如果最优解比当前层数要浅就停止。

- 当前有牌且深度+1==最优解 直接停止。

其实我们发现第一种是核心剪枝必须有序才行。

第二，三种是必要的剪枝。

还有一点需要注意的是发现前面的单牌可以和后面的一些牌进行操作我们必须考虑到，这并不浪费时间。

这样我们顺利通过了这道题不用贪心啦，拆牌的考虑辣么多。

```cpp
//#include<bits/stdc++.h>
#include<iostream>
#include<queue>
#include<iomanip>
#include<cctype>
#include<cstdio>
#include<deque>
#include<utility>
#include<cmath>
#include<ctime>
#include<cstring>
#include<string>
#include<cstdlib>
#include<vector>
#include<algorithm>
#include<stack>
#include<map>
#include<set>
#include<bitset>
#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)>(y)?(y):(x))
#define INF 10000000000000ll
#define ll long long
#define l(x) t[x].l
#define r(x) t[x].r
#define v(x) t[x].v
using namespace std;
char buf[1<<15],*fs,*ft;
inline char getc()
{
	return (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),fs==ft))?0:*fs++;
}
inline ll read()
{
    ll x=0,f=1;char ch=getc();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getc();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getc();}
    return x*f;
}
inline void put(ll x)
{
    x<0?putchar('-'),x=-x:0;
    ll num=0;char ch[50];
    while(x)ch[++num]=x%10+'0',x/=10;
    num==0?putchar('0'):0;
    while(num)putchar(ch[num--]);
    putchar('\n');return;
}
//1 最优化剪枝 2 按顺序剪枝
const int MAXN=30;
int T,n;
int maxx=25,m;
int a[MAXN];
inline void dfs(int x,int depth,int p)
{
	if(depth>=maxx)return;
	if(p&&depth+1==maxx)return;
	if(!p){maxx=min(maxx,depth);return;}
	if(!a[x]){dfs(x+1,depth,p);return;}
	--a[x];
	for(int i=x+1;i<=14;++i)//被动三带一
		if(a[i]>2)
		{
			a[i]-=3;
			dfs(x,depth+1,p-4);
			a[i]+=3;
		}
	int flag=0;
	for(int i=x+1;i<=14;++i)if(a[i]>3)flag=i;
	if(flag)
	{
		a[flag]-=4;
		for(int i=x;i<=15;++i)//被动4带二
			if(a[i])
			{
				--a[i];
				dfs(x,depth+1,p-6);
				++a[i];
			}
		a[flag]+=4;
	}
	dfs(x,depth+1,p-1);//出单张牌
	++a[x];
	if(x!=2)if(a[x+1]&&a[x+2]&&a[x+3]&&a[x+4]&&x+4<=14)
	{
		--a[x];--a[x+1];--a[x+2];--a[x+3];--a[x+4];
		dfs(x,depth+1,p-5);
		int w=x+5;
		while(a[w]&&w<=14)//单顺子
		{
			--a[w];
			dfs(x,depth+1,p-(w-x+1));
			++w;
		}
		for(int i=w-1;i>=x;--i)++a[i];
	}
	if(a[x]>1)//出对子 或者火箭
	{
		a[x]-=2;
		dfs(x,depth+1,p-2);
		int flag=0;
		for(int i=x+1;i<=14;++i)if(a[i]>3)flag=i;
		if(flag)
		{
			a[flag]-=4;
			for(int i=x+1;i<=14;++i)
				if(a[i]>1)
				{
					a[i]-=2;
					dfs(x,depth+1,p-8);
					a[i]+=2;
				}
			a[flag]+=4;//被动四代二
		}
		for(int i=x+1;i<=14;++i)//被动三带二
			if(a[i]>2)
			{
				a[i]-=3;
				dfs(x,depth+1,p-5);
				a[i]+=3;
			}
		a[x]+=2;
		if(x!=2&&a[x+1]>1&&a[x+2]>1&&x+2<=14)
		{
			a[x]-=2;a[x+1]-=2;a[x+2]-=2;
			int w=x+3;//注意不要加错
			dfs(x,depth+1,p-6);
			while(a[w]>1&&w<=14)//双顺子 
			{
				a[w]-=2;
				dfs(x,depth+1,p-(w-x+1)*2);
				++w;
			}
			for(int i=w-1;i>=x;--i)a[i]+=2;
		}
	}
	if(a[x]>2)
	{
		a[x]-=3;
		dfs(x,depth+1,p-3);//出三张牌
		for(int i=x+1;i<=15;++i)
		{	
			if(a[i])
			{
				--a[i];
				dfs(x,depth+1,p-4);//三带一
				++a[i];
			}
			if(a[i]>1&&i<=14)
			{
				a[i]-=2;
				dfs(x,depth+1,p-5);//三带二
				a[i]+=2;
			}
		}
		a[x]+=3;
		if(a[x+1]>2&&x!=2)//三顺子
			{
				int w=x+2;//注意两个即可
				a[x]-=3;a[x+1]-=3;
				dfs(x,depth+1,p-6);
				while(a[w]>2)
				{
					a[w]-=3;
					dfs(x,depth+1,p-(w-x+1)*3);
					++w;
				}
				for(int j=w-1;j>=x;--j)a[j]+=3;
			}
	}
	if(a[x]>3)
	{
		a[x]-=4;
		dfs(x+1,depth+1,p-4);//炸弹
		for(int i=x+1;i<=15;++i)//终极四带二
			for(int j=i;j<=15;++j)
			{
				if(i==j)//注意相等
				{
					if(a[i]>1)
					{
						a[i]-=2;
						dfs(x+1,depth+1,p-6);
						a[i]+=2;
					}
					if(a[i]>3)
					{
						a[i]-=4;
						dfs(x+1,depth+1,p-8);
						a[i]+=4;
					}
					continue;
				}
				if(a[i]&&a[j])
				{
					--a[i];--a[j];
					dfs(x+1,depth+1,p-6);
					++a[i];++a[j];
				}
				if(a[i]>1&&a[j]>1&&i!=15&&j!=15)
				{
					a[i]-=2;a[j]-=2;
					dfs(x+1,depth+1,p-8);
					a[i]+=2;a[j]+=2;
				}
			}
		a[x]+=4;
	}
	return;
}
int main()
{
	//freopen("1.in","r",stdin);
	//freopen("1.out","w",stdout);
	T=read();n=read();
	while(T--)
	{
		memset(a,0,sizeof(a));maxx=25;
		for(int i=1;i<=n;++i)
		{
			int x,y;
			x=read();y=read();
			if(x==0&&y==1){++a[15];continue;}
			if(x==0&&y==2){++a[15];continue;}
			if(x==1){++a[14];continue;}
			++a[x];
		}
		//for(int i=2;i<=15;++i)cout<<a[i]<<endl;
		dfs(2,0,n);
		put(maxx);
	}
	return 0;
}

```


---


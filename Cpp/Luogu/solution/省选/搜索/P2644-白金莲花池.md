# 白金莲花池

## 题目背景

为了让奶牛们娱乐和锻炼，农夫约翰建造了一个美丽的池塘。这个长方形的池子被分成了 $M$ 行 $N$ 列个方格（$1≤M,N≤30$）。一些格子是坚固得令人惊讶的莲花，还有一些格子是岩石，其余的只是美丽、纯净、湛蓝还可能掩藏着宝藏的水。

贝西正在练习芭蕾舞，她站在一朵莲花上，想跳到另一朵莲花上去，她只能从一朵莲花跳到另一朵莲花上，既不能跳到水里，也不能跳到岩石上。

贝西的舞步很像象棋中的马步：每次总是先横向移动一格，再纵向移动两格，或先纵向移动两格，再横向移动一格。最多时，贝西会有八个移动方向可供选择。

约翰一直在观看贝西的芭蕾练习，发现她有时候不能跳到终点，因为中间缺了一些荷叶。于是他想要添加几朵莲花来帮助贝西完成任务，当然莲花不能种在岩石上。


## 题目描述

但是！约翰在种植莲花的时候发现了一件很有趣的事，有些格子是不能直接种植莲花的，原因是……实不相瞒，无法直接种植莲花的格子的泥土中大部分都是货真价实的铂金，正是它们妨碍了莲花的正常生长！而恰好约翰刚刚学到了铂金的开采方法，也有相关的开采工具，而且他还发现开采铂金后的格子就可以正常地种植莲花，不必担心泥土缺失的问题。（由于贝西迫切地想练习，所以约翰不会开采不打算种莲花的铂金格子）

开采铂金很累，就像是种植莲花一样累，它们都会消耗掉约翰 $1$ 点体力（也就是说想把铂金格子变成莲花格子需要 $2$ 点体力），约翰最初有 $P$ 点体力来种植莲花或开采铂金。

请帮助约翰计算至少需要消耗多少体力才能帮助贝西完成任务，这个数字记作 $S$，以及有多少种消耗这些体力的方法能帮助贝西完成任务，这个数字记作 $W_S$；铂金当然是越多越好，请计算在消耗 $S$ 点体力帮助贝西完成任务的同时最多能开采多少铂金，这个数字记作 $G$，以及消耗 $S$ 点体力开采 $G$ 块铂金帮助贝西完成任务的方法数，这个数字记作 $W_G$。

若在 $P$ 点体力内无法帮助到贝西，那么只输出 `-1`。

若在 $S$ 点体力内无法开采铂金，那么第二行只输出 `-1`。

## 说明/提示

约翰可以用开采到的铂金小赚一笔，但如果用多余的体力开采铂金而不往上种莲花的话贝西会很生气！


## 样例 #1

### 输入

```
4 5 6
0 0 0 1 0 0
2 0 0 2 0 0
0 0 5 0 0 0
3 0 0 0 4 0
0 0 2 0 0 0```

### 输出

```
2 2
1 1```

## 样例 #2

### 输入

```
3 3 2
3 5
4 2
0 1```

### 输出

```
-1```

# 题解

## 作者：251Sec (赞：6)

有点无趣的题目。

这题是 [P1606](https://www.luogu.com.cn/problem/P1606) 的加强版。大部分思路与那题一致。

对于每个点，将它向它能直接或通过荷叶间接到达的点连一条有向边。如果连向水的话边权为 1，连向铂金的话边权为 2。

跑最短路，顺便维护一下[方案数](https://www.luogu.com.cn/problem/P1144)，铂金最大值和铂金方案数。总体思路和 P1606 几乎没有差别。（所以我昨天为什么闲的没事在那里敲 A\*）

Code:

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pid(x, y) ((x - 1) * n + (y - 1))
int m, n, p;
struct Edge {
	int to, next, w;
} e[200005];
int head[905], len;
void Insert(int u, int v, int w) {
	e[++len].to = v;
	e[len].next = head[u];
	e[len].w = w;
	head[u] = len;
}
int mp[905];
int sx, sy, tx, ty;
int d[905], pt[905];
ll f[905], g[905];
bool vis[905], mkd[905];
struct ND {
	int num, dis;
	bool operator<(const ND &o) const {
		return dis > o.dis;
	}
};
void dfs(int x, int y, int rx, int ry) {
	vis[pid(x, y)] = true;
	int dx[] = {2, 2, -2, -2, 1, 1, -1, -1};
	int dy[] = {1, -1, 1, -1, 2, -2, 2, -2};
	for (int i = 0; i < 8; i++) {
		if (x + dx[i] < 1 || x + dx[i] > m || y + dy[i] < 1 || y + dy[i] > n) continue;
		if (mp[pid(x + dx[i], y + dy[i])] == 0) {
			if (!mkd[pid(x + dx[i], y + dy[i])]) Insert(pid(rx, ry), pid(x + dx[i], y + dy[i]), 1);
			mkd[pid(x + dx[i], y + dy[i])] = true;
		}
		else if (mp[pid(x + dx[i], y + dy[i])] == 4) {
			if (!mkd[pid(x + dx[i], y + dy[i])]) Insert(pid(rx, ry), pid(x + dx[i], y + dy[i]), 0);
			mkd[pid(x + dx[i], y + dy[i])] = true;
		}
		else if (mp[pid(x + dx[i], y + dy[i])] == 5) {
			if (!mkd[pid(x + dx[i], y + dy[i])]) Insert(pid(rx, ry), pid(x + dx[i], y + dy[i]), 2);
			mkd[pid(x + dx[i], y + dy[i])] = true;
		}
		else if (mp[pid(x + dx[i], y + dy[i])] == 1) {
			if (!vis[pid(x + dx[i], y + dy[i])]) dfs(x + dx[i], y + dy[i], rx, ry);
		}
	}
}
void Dijkstra() {
	priority_queue<ND> q;
	q.push({pid(sx, sy), 0});
	memset(d, 0x3f, sizeof(d));
	d[pid(sx, sy)] = 0;
	f[pid(sx, sy)] = 1;
	g[pid(sx, sy)] = 1;
	while (!q.empty()) {
		int u = q.top().num; q.pop();
		for (int i = head[u]; i; i = e[i].next) {
			int v = e[i].to;
			if (d[v] == d[u] + e[i].w) {
				f[v] += f[u];
				if (pt[v] == pt[u] + (e[i].w == 2)) {
					g[v] += g[u];
				}
				else if (pt[v] < pt[u] + (e[i].w == 2)) {
					pt[v] = pt[u] + (e[i].w == 2);
					g[v] = g[u];
				}
			}
			else if (d[v] > d[u] + e[i].w) {
				d[v] = d[u] + e[i].w;
				f[v] = f[u];
				g[v] = g[u];
				pt[v] = pt[u] + (e[i].w == 2);
				q.push({v, d[v]});
			}
		}
	}
}
int main() {
	scanf("%d%d%d", &p, &m, &n);
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= n; j++) {
			scanf("%d", &mp[pid(i, j)]);
			if (mp[pid(i, j)] == 3) {
				sx = i; sy = j;
				mp[pid(i, j)] = 0;
			}
			else if (mp[pid(i, j)] == 4) {
				tx = i; ty = j;
			}
		}
	}
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= n; j++) {
			memset(vis, 0, sizeof(vis));
			memset(mkd, 0, sizeof(mkd));
			if (mp[pid(i, j)] == 0 || mp[pid(i, j)] == 5) dfs(i, j, i, j);
		}
	}
	Dijkstra();
	if (d[pid(tx, ty)] > p) {
		puts("-1");
		return 0;
	}
	printf("%d %lld\n", d[pid(tx, ty)], f[pid(tx, ty)]);
	if (!pt[pid(tx, ty)]) {
		puts("-1");
		return 0;
	}
	printf("%d %lld\n", pt[pid(tx, ty)], g[pid(tx, ty)]);
	return 0;
}
```

---


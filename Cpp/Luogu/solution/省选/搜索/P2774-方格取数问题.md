# 方格取数问题

## 题目描述

有一个 $m$ 行 $n$ 列的方格图，每个方格中都有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大，请求出最大的和。


## 说明/提示

**数据规模与约定**

对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 100$，$1 \leq a_{i, j} \leq 10^5$。

**提示**

请注意输入的第一行先读入 $m$ 再读入 $n$。

## 样例 #1

### 输入

```
3 3
1 2 3
3 2 3
2 3 1 ```

### 输出

```
11```

# 题解

## 作者：学委 (赞：204)

限制条件是——如果要取某一个方格，那么禁止取相邻的**四个**方格，不限制**其它所有**方格。

所以猜测，从禁止的角度考虑才会更高效。也就是说，先选中所有方格，再想办法删去**权值和**尽量小的一批方格。

___

相邻的概念是，横坐标或纵坐标中的一个相差 $1$，所以两点的横纵坐标之和**奇偶性不同**。

于是，横纵坐标和的奇偶性相同的两个点肯定不互斥（奇偶性不同的**可能**互斥）。把互斥的点连边的话，会形成一个二分图。

但先不管这个。

要想办法构造一个模型，它：

* **能删掉一个元素，表示不取这个方格；**

* **删掉的代价为方格的权值；**

* **要么删掉的总是保证策略最优的，要么能反悔；**

* **最终状态为：没有互斥的方格了。**

好像能发现对应的模型了，大概是**图**一类的东西：

* 删掉连向方格的边

* 边权为方格的权值

* 网络流搞一搞

* **割**

___

怎么构造一个合适的图呢？最好能利用上面的二分图。并不容易想到：

源点连向二分图的一个点集（横纵坐标之和为奇数的那些方格），边权为点权。**删一条边表示不取这个方格。**

二分图的另一个点集连向超级汇，边权还是点权。删边也表示不取此点。

二分图内部的边，连接着互斥的点。边权全部赋为 $inf$，以保证在最小割中不被删。啥意思？

想象一下通过某种方式，求出了该图最小割。

* 因为是最小割，所以中间的 $inf$ 边没删，删掉的都是源点连出的边，或连入汇点的边。

	**因此这个割能够确切表示：不取某些方格。**（删掉中间边本来就没有意义，不能表示对方格的操作；只有两侧的边具有意义）

* 因为是割，所以图不连通。**不连通**，就已经保证没有取到任何互斥的方格（假设图中还有互斥方格，也就是两者在图中各自所属的边还没删，再因为它们中间的 $inf$ 边也没删，所以图还是连通的）

　　　　![](https://cdn.luogu.com.cn/upload/pic/47260.png
)

最后只需知道**最大流 = 最小割**就好了。

```cpp
//Dinic 理解代价低 
#include <cstdio>
#include <cctype>
#include <cstring>
#include <queue>
#define N 10010
#define E 100010
#define S 0
#define T (m * n + 1)
#define code(i, j) ((i - 1) * m + j)//点的线性标号 
#define between(x, flo, top) (flo <= x and x <= top)//您是不是不喜欢这个qwq 
int getint() {
	int res = 0, ch = getchar();
	while (!isdigit(ch) and ch != EOF)
		ch = getchar();
	while (isdigit(ch))
		res = res * 10 + (ch - '0'), ch = getchar();
	return res;
}
inline int min(int x, int y) { return (x < y) ? x : y; }
using std::queue;
const int d[4][2] = {//待会枚举四个方向用的 
	{0, 1},
	{0, -1},
	{1, 0},
	{-1, 0}
};

int m, n;
int sum = 0;

int first[N];
int nxt[E], to[E], val[E], cnt = 1;
void addE(int u, int v, int w) {
	++cnt;
	to[cnt] = v;
	val[cnt] = w;
	nxt[cnt] = first[u];
	first[u] = cnt;
}

int dep[N];
queue<int> q;
bool bfs() {
	memset(dep, 0, sizeof(dep));
	
	dep[S] = 1;
	q.push(S);
	while (not q.empty()) {
		int u = q.front();
		q.pop();
		for (int p = first[u]; p; p = nxt[p]) {
			int v = to[p];
			if (dep[v])
				continue;
			if (val[p]) {//放心，开始都是正权的情况下，不会出现负数的 
				dep[v] = dep[u] + 1;
				q.push(v);
			}
		}
	}
	return dep[T];
}

int dfs(int u, int in) {
	if (u == T)
		return in;
	int out = 0;
	for (int p = first[u]; p and in; p = nxt[p]) {
		
		if (val[p] == 0)
			continue;
		int v = to[p];
		if (dep[v] != dep[u] + 1)
			continue;
		
		int res = dfs(v, min(val[p], in));
		val[p] -= res;
		val[p ^ 1] += res;
		in -= res;
		out += res;
	}
	
	return out;
}

int main() {
	n = getint(), m = getint();
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j) {
			int w = 0;
			sum += w = getint();//假定全部都取，随后会删 
			if ((i + j) % 2 == 0) {//阵营A，源点连向自己，自己连向阵营B 
				addE(S, code(i, j), w);
				addE(code(i, j), S, 0);
				
				for (int k = 0; k <= 3; ++k) {
					int x = i + d[k][0], y = j + d[k][1];
					if (between(x, 1, n) and between(y, 1, m)) {
						addE(code(i, j), code(x, y), 2e9);
						addE(code(x, y), code(i, j), 0);
					}
				}				
			}
			else {//阵营B，连向汇点 
				addE(code(i, j), T, w);
				addE(T, code(i, j), 0);
			}
		}
	
	int cut = 0;//最小割 
	while (bfs())
		cut += dfs(S, 2e9);//最小割 = 最大流 
	printf("%d\n", sum - cut);
	return 0;
}

```

---

## 作者：「QQ红包」 (赞：70)

my blog： http://redbag.pw/

我们对棋盘进行黑白染色（（横坐标+纵坐标）%2==1的点设为黑点），可以发现，若取一个黑格的点，受到影响的就是周围的白点。

于是我们可以建一个二分图。

然后可以发现这是一个最小割的套路题，假设所有的点都取，然后去掉最小割，就是答案了。

建模：S->黑点，容量为点权

白点->T，容量为点权

每一个黑点->取该黑点会受到影响的白点，容量为inf

然后就可以了

```cpp
#include<bits/stdc++.h>
using namespace std;
int qmax(int &x,int y) {if (x<y) x=y;}
int qmin(int &x,int y) {if (x>y) x=y;}
int read()
{
    char s;int k=0,base=1;
    while((s=getchar())!='-'&&s!=EOF&&!(isdigit(s)));
    if(s==EOF)exit(0);if(s=='-')base=-1,s=getchar();
    while(isdigit(s)){k=k*10+(s^'0');s=getchar();}
    return k*base;
}
const int maxn=10003; 
const int maxm=80010;
int S,T,n,m,id,X,Y;
int to[maxm],ne[maxm],w[maxm],po[maxn];
int h[maxn];
int Q[maxn/2],l,r;
int d1;
int ID(int x,int y)
{
    return (x-1)*m+y;
}
void add(int x,int y,int z) {id++;to[id]=y;w[id]=z;ne[id]=po[x];po[x]=id;}
bool bfs()
{
    memset(h,-1,sizeof(h));
    h[S]=1;l=0;r=1;Q[r]=S;
    while (l!=r)
    {
        l++;if (l==maxn) l=1;
        int u=Q[l],v=0;
        for (int i=po[u];i;i=ne[i])
        {
            v=to[i];
            if (h[v]==-1&&w[i]>0)
            {
                h[v]=h[u]+1;r++;if (r==maxn) r=1;Q[r]=v;
            }
        }
    }
    return h[T]!=-1;
}
int dfs(int u,int low)
{
    if (u==T||low==0) return low;int used=0,v,W;
    for (int i=po[u];i;i=ne[i])
    {
        if (h[to[i]]==h[u]+1)
        {
            v=to[i];
            W=dfs(v,min(w[i],low-used));
            used+=W;
            w[i]-=W;w[i^1]+=W;
            if (used==low) return low;
        }
    }
    if (used==0) h[u]=-1;
    return used;
}
int a;
int fx[4][2]={{-1,0},{0,-1},{1,0},{0,1}};
long long sum=0;
int main()
{
    id=1;
    n=read();m=read();S=n*m+1;T=n*m+2;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
        {//所有点和起点或终点连边
            a=read();sum+=a;
            if ((i+j)%2==1) add(S,(i-1)*m+j,a),add((i-1)*m+j,S,0); else add((i-1)*m+j,T,a),add(T,(i-1)*m+j,0);
        }
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
        {
            if ((i+j)%2==1) //连边
            {
                for (int k=0;k<4;k++) 
                {
                    X=i+fx[k][0];Y=j+fx[k][1];
                    if (X<=0||Y<=0||X>n||Y>m) continue;//判越界
                    add((i-1)*m+j,(X-1)*m+Y,1e8),add((X-1)*m+Y,(i-1)*m+j,0); 
                }
            }
        }
    while (bfs()) sum-=dfs(S,1e9);//跑一遍dinic
    printf("%lld\n",sum);
}

```

---

## 作者：Mark_ZZY (赞：28)

### 关于构图：

首先，这是一道最小割的题目。

我们可以想到一个性质，最大和=全局和-舍弃和，而舍弃和=最小割=最大流。
![](https://cdn.luogu.com.cn/upload/pic/15206.png)

我们可以看到上面的那一幅图，就会有所启发。

当一个点(i,j)满足(i+j)mod 2=1时，为白色的点，否则为黑色的点。

对于任意一个点，我们不能取它上下左右的点，于是就可以得到上面的那一幅图，白色的点为一个集合，黑色的点为一个集合，两个集合中的点都满足这一规定。

你或许会问，这可以用贪心（ans=max(sigma白,sigma黑)）解决啊。

但是，一个白色的点可以与一个不与它相临的黑色的点连边，这时，就得用到最小割。一个白色的点与与它相临的黑色的点建边，但这些便是需要“割”掉的。有了这些边，就可以从一个白色的点流向一个不与它相临的黑色的点了。

构图：

1.首先，需要一个超级源点和汇点。

2.源点连向每一个黑色的点，流量为这个点的值；同理，每一个白色的点都连向汇点，流量为这个点的值。

3.每一个黑色的点都连向与它相临的白色的点，流量为INF，这些边需要“割”掉一些。

最后就可以根据最小割=最大流这个定理&最大和=全局和-舍弃和求解了。

### 关于代码：
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#define INF 2147483647
using namespace std; 
queue<int> f;
	const int fx[4]={0,0,1,-1};
	const int fy[4]={1,-1,0,0};
	struct node{int x,y,z,next;} a[200000];
	int last[1000];
	int n,m,len=-1,ans=0,st,ed;
void ins(int x,int y,int z)
{
	a[++len].x=x;a[len].y=y;a[len].z=z;a[len].next=last[x];last[x]=len;
}
int h[1000];
bool bfs()
{
	memset(h,0,sizeof(h));
	h[st]=1;
	f.push(st);
	while(!f.empty())
	{
		int x=f.front();
		for(int i=last[x];i>=0;i=a[i].next)
		{
			int y=a[i].y;
			if(a[i].z>0&&h[y]==0)
			{
				h[y]=h[x]+1;
				f.push(y);
			}
		}
		f.pop();
	}
	if(h[ed]) return true; else return false;
}
int dfs(int x,int f)
{
	int s=0,t;
	if(x==ed) return f;
	for(int i=last[x];i>=0;i=a[i].next)
	{
		int y=a[i].y;
		if(a[i].z>0&&h[y]==h[x]+1&&f>s)
		{
			s+=(t=(dfs(y,min(f-s,a[i].z))));
			a[i].z-=t;
			a[i^1].z+=t;
		}
	}
	if(!s) h[x]=0;
	return s;
}
int dinic()
{
	int sum=0;
	while(bfs())
		sum+=dfs(st,INF);
	return sum;
}
int main()
{
	int x,id;
	scanf("%d %d",&n,&m);
	st=0,ed=n*m+1;
	memset(last,-1,sizeof(last));
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&x);
			ans+=x;
			id=(i-1)*m+j;
			if((i+j)&1) ins(st,id,x),ins(id,st,0); else ins(id,ed,x),ins(ed,id,0);
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if((i+j)&1)
			{
				for(int k=0;k<=3;k++)
				{
					int t1=i+fx[k],t2=j+fy[k];
					if(t1<=0||t1>n||t2<=0||t2>m) continue;
					id=(i-1)*m+j;
					ins(id,(t1-1)*m+t2,INF),ins((t1-1)*m+t2,id,0);
				}
			}
	printf("%d",ans-dinic());
}
```

---

## 作者：zhaoyifan (赞：14)

相邻的数字只能选一个，联想到二分图，相邻的点分别放在x、y端，他们之间连一条边

为什么他们之间连一条边呢，因为相邻数字的关系有且仅有相邻为影响，我们需要把影响转化到模型上，

不相邻的点建边虽然思考起来更直观，但是边数太多了，反而更难理清思路

要使边有意义且合法，我们需要构造起始点和终点，因为x的每个点地位相同，那么都和s点相连，同理y和t相连

显然对于构造出来的这个图，我们要尝试把题意转化进去，即答案需要的是一种什么图。

x和y相连的两个点只能要一个，这是题意，那么结果图中不能有s-u-v-t完整的4条弧构成的“链”，

断链的方法显然为最小割，最小割最大流是很重要的定理。

模拟一下最大流的过程，举几个小例子就能明白我们割掉的是小的，留下来的是大的和小的的差

那么结果就显而易见了。

```cpp
    #include<iostream>
    #include<cstdio>
    #include<cmath>
    #include<cstring>
    #include<iomanip>
    #include<algorithm>
    #include<queue>
    #define in(x) scanf("%d",&x)
    using namespace std;
    const int maxn=1e5+7,pn=2e4+7;
    int n,m,all=0,ans=0,cnt=1,head[maxn],s=0,t,
    to[maxn],nxt[maxn],w[maxn],d[pn];
    int x2[4]={1,-1,0,0};
    int y2[4]={0,0,1,-1};
    queue<int>q;
    void add(int x,int y,int we)
    {
        nxt[++cnt]=head[x];head[x]=cnt;to[cnt]=y;w[cnt]=we;
        nxt[++cnt]=head[y];head[y]=cnt;to[cnt]=x;w[cnt]=0;
    }
    int bfs()
    {
        memset(d,0,sizeof(d));d[s]=1;q.push(s);
        while(q.size())
        {
            int x=q.front();q.pop();
            for(int i=head[x];i;i=nxt[i])
            {
                int u=to[i];
                if(d[u]||w[i]<=0) continue;
                d[u]=d[x]+1;q.push(u);
            }
        }
        return d[t];
    }
    int dfs(int x,int flow)
    {
        if(x==t) return flow;int p;
        for(int i=head[x];i;i=nxt[i])
        {
            int u=to[i];
            if(d[u]!=d[x]+1||w[i]<=0) continue;
            if(p=dfs(u,min(flow,w[i])))
            {
                w[i]-=p;w[i^1]+=p;return p;
            }
        }
        return 0;
    }
    void dinic()
    {
        int p=0;
        while(bfs())
        {
            while(1)
            {
                p=dfs(s,1e9);
                if(!p)break;
                ans+=p;
            }
        }
    }
    int main()
    {
        in(n);in(m);t=m*n+m+3;
        for(int i=1;i<=n;++i)
         for(int j=1;j<=m;++j)
         {
             int x;in(x);all+=x;int u=i*m+j;
             if((i+j)%2==0) 
             {
                 add(s,u,x);
                 for(int k=0;k<=3;++k)
                 {
                     int xx=i+x2[k],yy=j+y2[k];
                     if(xx<1||xx>n||yy<1||yy>m) continue;
                     int v=xx*m+yy;
                     add(u,v,1e9);
                 }
             }
             else add(u,t,x);
         }
         dinic();
         cout<<all-ans;
         return 0;
}
```

---

## 作者：jun头吉吉 (赞：8)

# P2774 方格取数问题
[更好的阅读体验](https://chen-jia-liang.gitee.io/blog/2020/07/13/%E9%A2%98%E8%A7%A3-P2774-%E3%80%90%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E9%97%AE%E9%A2%98%E3%80%91/)
## 题意
在一个$m\times n$的方阵中取若干个数，任意两个数不能相邻，求和的最大值

## 题解

>**小技巧**：在网络流建模的时候，如果关系比较类似，我们可以先考虑局部建模，再将其放到全局去考虑。

在此题中，我们使用上面的方法，先拎出两个相邻的数$A$和$B$，用$X$和$Y$表示他们对应的点。

根据体面，我们了解到，对于$A$与$B$，其必定是**二选一**的。二选一~~自然~~能够想到的就是**最小割**了，把其选中若干个数使和最大，看作是选若干个**矛盾的**数使和最小，剩下的必然是不矛盾的 ~~最小割的套路~~。然后我们就~~很容易的想到了如下操作~~

1. 将源点$S$与$X$连接一条删去费用为$A$的边
1. 将$X$与$Y$连接一条删去费用为$+\infty$的边
1. 将$Y$与汇点$T$连接一条删去费用为$B$的边

所以我们现在的问题是把局部的两个点**搬**到整个方阵上去。~~根据某个套路~~，我们可以把所有的方格按照$(x+y) \bmod2$的值分类，那么对于在同一类中的数，是必定不会互相影响的。因此将$x+y$为奇数的当成上面的$X$点，$x+y$为偶数的当成$B$点，跑一遍最大流就 $\color{green}{\texttt{AC}}$了
## 代码
```cpp
 #pragma GCC optimize(3,"Ofast","inline")
#include<bits/stdc++.h>
namespace in{
	char buf[1<<21],*p1=buf,*p2=buf;
	inline int getc(){
	    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;
	}
	template <typename T>inline void read(T& t){
	    t=0;int f=0;char ch=getc();
	    while (!isdigit(ch)){
	        if(ch=='-')f = 1;
	        ch=getc();
	    }
	    while(isdigit(ch)){
   	    	t=t*10+ch-48;
   	    	ch = getc();
   		}
		if(f)t=-t;
	}
	template <typename T,typename... Args> inline void read(T& t, Args&... args){
	    read(t);read(args...);
	}
}
namespace out{
	char buffer[1<<21];
	int p1=-1;
	const int p2 = (1<<21)-1;
	inline void flush() {
		fwrite(buffer,1,p1+1,stdout),
		p1=-1;
	}
	inline void putc(const char &x) {
		if(p1==p2)flush();
		buffer[++p1]=x;
	}
	template <typename T>void write(T x) {
		static char buf[15];
		static int len=-1;
		if(x>=0){
			do{
    			buf[++len]=x%10+48,x/=10;
    		}while (x);
		}else{
    		putc('-');
			do {
    			buf[++len]=-(x%10)+48,x/=10;
			}while(x);
		}
		while (len>=0)
			putc(buf[len]),--len;
	}
}
const int maxn=10000+10,maxe=1000000;
struct Graph{
	struct node{
		int v,w,nxt;
		node(int _v=0,int _w=0,int _nxt=0):v(_v),w(_w),nxt(_nxt){}
	}e[maxe];
	int head[maxn],cur[maxn],cnt;
	int s,t,dis[maxn];
	inline void init(int _s,int _t){s=_s,t=_t;cnt=1;}
	void add(int u,int v,int w){
		e[++cnt]=node(v,w,head[u]);head[u]=cnt;
		e[++cnt]=node(u,0,head[v]);head[v]=cnt;
	}
	#define v e[i].v
	inline bool bfs(){
		memset(dis,0,sizeof dis);
		memcpy(cur,head,sizeof cur);
		std::queue<int>q;
		q.push(s);dis[s]=1;
		while(!q.empty()){
			int u=q.front();q.pop();
			for(int i=head[u];i;i=e[i].nxt)if(e[i].w&&!dis[v]){
				dis[v]=dis[u]+1;q.push(v);
				if(v==t)return true;
			}
		}
		return false;
	}
	int dfs(int u,int flow){
		if(u==t)return flow;
		int rest=flow;
		for(int &i=cur[u];i;i=e[i].nxt){
			if(dis[v]==dis[u]+1&&e[i].w){
				int tmp=dfs(v,std::min(rest,e[i].w));
				e[i].w-=tmp,e[i^1].w+=tmp,rest-=tmp;
			}
		}
		if(!rest)dis[u]=-1;
		return flow-rest;
	}
	#undef v
	int dinic(){
		int ans=0;
		while(bfs())
			while(int sth=dfs(s,2e9))
				ans+=sth;
		return ans;
	}
}G;
int m,n,x,sum;//m为行数 n为列数
#define P(i,j) ((i)-1)*n+(j) 
inline bool check(int x,int y){
	return x<=m&&x>=1&&y<=n&&y>=1;
}
signed main(){
	in::read(m,n);
	G.init(0,n*m+1);
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++){
			in::read(x);sum+=x;
			if((i+j)&1){
				G.add(G.s,P(i,j),x);
				if(check(i-1,j))G.add(P(i,j),P(i-1,j),1e9);
				if(check(i+1,j))G.add(P(i,j),P(i+1,j),1e9);
				if(check(i,j-1))G.add(P(i,j),P(i,j-1),1e9);
				if(check(i,j+1))G.add(P(i,j),P(i,j+1),1e9);
				
			}
			else{
				G.add(P(i,j),G.t,x);
			}
		}
	out::write(sum-G.dinic());
	out::flush();
	return 0;
}
```

---

## 作者：Ireliaღ (赞：7)

**最大流=最小割**

最大流经典题目，ISAP算法跑的飞快

### 解题思路

由于取数时不可以取相邻数字，所以我们可以把方格表进行象棋棋盘的黑白染色，让黑白节点形成二分图，然后就是带点权的二分图匹配了，使用最大流的思路是最简单的

### 建图

* 设$0$为原点，$n \times m + 1$为汇点，把棋盘里的点全部映射到$[1, n \times m]$的节点

* 对于$\forall i \in black$，从$0$向$i$建边，容量为该点数字

* 对于$\forall j \in white$，从$j$向$n \times m + 1$建边，容量为该点数字

* 对于$\forall i \in black$，从$i$向上下左右的白点建边，容量为$\infty$

然后跑最大流，用数字总和减去它即可。

### 代码

指针版ISAP，有当前弧优化

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include <iostream>
#include <queue>
#include <cstring>

using namespace std;

const int MAXN = 105;
const int INF = 0x3f3f3f3f;

int m, n;

struct Edge{
    int to, val;
    Edge *next, *ops;
    Edge(int to, int val, Edge *next): to(to), val(val), next(next){}
};

Edge *head[MAXN * MAXN], *cur[MAXN * MAXN];

int ID(int x, int y) {
    return (x - 1) * n + y;
}

void AddEdge(int u, int v, int w) {
    head[u] = new Edge(v, w, head[u]);
    head[v] = new Edge(u, 0, head[v]);
    head[u]->ops = head[v]; head[v]->ops = head[u];
}

int dep[MAXN * MAXN], gap[MAXN * MAXN];
int s, t, res;

void Bfs() {
    memset(dep, -1, sizeof(dep));
    memset(gap, 0, sizeof(gap));
    dep[t] = 0; gap[0]++;
    queue<int> q; q.push(t);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (Edge *e = head[u]; e; e = e->next) {
            int v = e->to;
            if (dep[v] != -1) continue;
            q.push(v);
            dep[v] = dep[u] + 1;
            gap[dep[v]]++;
        }
    }
}

int Dfs(int u, int flow) {
    if (u == t) {
        res += flow;
        return flow;
    }
    int used = 0;
    for (Edge *&e = cur[u]; e; e = e->next) {
        int v = e->to;
        if (e->val && dep[v] == dep[u] - 1) {
            int mi = Dfs(v, min(e->val, flow - used));
            if (mi) {
                e->val -= mi;
                e->ops->val += mi;
                used += mi;
            }
            if (used == flow) return used;
        }
    }
    cur[u] = head[u];
    gap[dep[u]]--;
    if (gap[dep[u]] == 0) dep[s] = n * m + 3;
    dep[u]++;
    gap[dep[u]]++;
    return used;
}

void Work() {
    memcpy(cur, head, sizeof(head));
    res = 0;
    Bfs();
    while (dep[s] <= n * m + 2) Dfs(s, INF);
}

int num[MAXN][MAXN];

int main() {
    ios :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> m >> n;
    s = 0; t = n * m + 1;
    int sum = 0;
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++)
            cin >> num[i][j], sum += num[i][j];
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if ((i + j) % 2 == 1) {
                AddEdge(0, ID(i, j), num[i][j]);
                if (i > 1) AddEdge(ID(i, j), ID(i - 1, j), INF);
                if (i < m) AddEdge(ID(i, j), ID(i + 1, j), INF);
                if (j > 1) AddEdge(ID(i, j), ID(i, j - 1), INF);
                if (j < n) AddEdge(ID(i, j), ID(i, j + 1), INF);
            } else {
                AddEdge(ID(i, j), n * m + 1, num[i][j]);
            }
        }
    }
    Work();
    cout << sum - res << endl;
    return 0;
}
```


---

## 作者：qwqqqq (赞：7)

这个题刚拿到一脸问号，这种题竟然是网络流？于是写了个把所有的方格中互相没有公共边的方格全取上来然后两种情况比大小的代码交了上去，然后只有36分……
其实这个题是可以用最大流做的，我们需要把它转移成二分图来做。

首先借鉴一下非正解的一个思路，把格子黑白染色，染成国际象棋棋盘就行（或者方格旗的样子?）然后把所有的黑点向超级源点连边，容量为点权；所有的白点向超级汇点连边，容量为点权；然后再从每个黑点向周围有公共边的白点连边，容量为inf。
最后做完的图差不多长这样。
![](https://cdn.luogu.com.cn/upload/pic/24131.png )
跑一边dinic/km/blabla，答案是总点权-最小割。
为什么呢？看看图上的最小割是不是被点权小的那一组点连的边所影响了。
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
using namespace std;
struct edge
{
	int u,v,x,f,s;
}ed[1000010];
int map[1010][1010];
int vas[1010][1010];
int num[1010][1010];
int head[1000010];
int dis[1000010];
int vis[1000010];
int que[1000010];
int fro[1000010];
int s,e,n,m,tot,p,h,t=1,cnt,ans,flow;
void debug()
{
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
			cout<<map[i][j]<<" ";
		cout<<"\n";
	}
	cout<<"\n";
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
			cout<<vas[i][j]<<" ";
		cout<<"\n";
	}
	cout<<"\n";
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
			cout<<num[i][j]<<" ";
		cout<<"\n";
	}
	cout<<"\n";
}
void add(int x,int y,int z)
{
	ed[cnt].u=head[x];
	ed[cnt].v=y;
	ed[cnt].x=x;
	ed[cnt].f=z;
	head[x]=cnt++;
}
bool spfa()
{
	for(int i=s;i<=e;i++)
		dis[i]=2147483647;
	memset(vis,0,sizeof(vis));
	dis[s]=0,vis[s]=1,que[t]=s;
	h=0,t=1;
	while(h!=t)
	{
		int temp=que[++h];
		for(int i=head[temp];i!=-1;i=ed[i].u)
		{
			if(dis[ed[i].v]>dis[ed[i].x]+ed[i].s&&ed[i].f!=0)
			{
				dis[ed[i].v]=dis[ed[i].x]+ed[i].s;
				fro[ed[i].v]=i;
				if(vis[ed[i].v]==0)
				{
					vis[ed[i].v]=1;
 					que[++t]=ed[i].v;
				}
			}
		}
		vis[temp]=0;
	}
	if(dis[e]!=2147483647)
		return 1;
	else
		return 0;
}
void f()
{
	int minn=2147483647;
	for(int i=e;i!=s;i=ed[fro[i]].x)
		minn=min(minn,ed[fro[i]].f);
	for(int i=e;i!=s;i=ed[fro[i]].x)
	{
		ed[fro[i]].f-=minn;
		ed[fro[i]^1].f+=minn;
		ans+=minn*ed[fro[i]].s;
	}
	flow+=minn;
}
int main()
{
	memset(head,-1,sizeof(head));
	cin>>m>>n;
	s=0,e=n*m+1;
	for(int i=1; i<=m; i++)
		for(int j=1; j<=n; j++)
			cin>>map[i][j],tot+=map[i][j];
	for(int i=1;i<=m;i++)
	{
		if(i%2!=0)
		{
			for(int j=1;j<=n;j++)
				if(j%2!=0)
					vas[i][j]=1;
		}
		else
		{
			for(int j=1;j<=n;j++)
				if(j%2==0)
					vas[i][j]=1;
		}
	}
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
		{
			p++;
			if(vas[i][j]==1)
			{
				add(s,p,map[i][j]);
				add(p,s,0);
			}
			if(vas[i][j]==0)
			{
				add(p,e,map[i][j]);
				add(e,p,0);
			}
			num[i][j]=p;
		}
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
		{
			if(vas[i][j]==1)
			{
				if(i+1<=m)
				{
					add(num[i][j],num[i+1][j],2147483647);
					add(num[i+1][j],num[i][j],0);
				}
				if(j+1<=n)
				{
					add(num[i][j],num[i][j+1],2147483647);
					add(num[i][j+1],num[i][j],0);
				}
				if(i-1>=1)
				{
					add(num[i][j],num[i-1][j],2147483647);
					add(num[i-1][j],num[i][j],0);
				}
				if(j-1>=1)
				{
					add(num[i][j],num[i][j-1],2147483647);
					add(num[i][j-1],num[i][j],0);
				}
			}
		}
//	debug();
	while(spfa())
		f();
	cout<<tot-flow;
	return 0;
}
```

---

## 作者：Little09 (赞：4)

个人认为此题算网络流24题里较水的。其实网络流题目的难度都在于建图上，掌握了以后这样的题问题就不大了。  

题目给定一个矩阵，需要选出一些两两无公共边（就是不相邻）的格子，使其的数值和最大。  

看到“相邻”一类的词语，大家应该已经往二分图的方向去想。对矩阵进行黑白染色，那么比如选了一个黑块，那么与它相邻的白块不能选。这里就要想到，我们可以计算不选的方块，其余的都选。这样就很容易地想到最小割啦。

那么建图就很容易了。对于每个点$(i,j)$，数值为$a_{i,j}$，如果是白色的点，那么从源点向它连一条容量$a_{i,j}$的边；否则就从这个点向汇点连一条容量$a_{i,j}$的边。这样我们**就把不选的点转化成了割掉的边**。为了保证相邻点直接的边不会被割掉，我们从每个白点向与其相邻的黑点连容量为$inf$的边。这样这题的建图就建完了，最后跑一边$dinic$即可。下面放个代码。

```
#include<bits/stdc++.h>
using namespace std;
const int INF=2000000000;
int s,T,cnt=1,n,m,S;
int nxt[1000005],h[1000005],t[1000005],w[1000005];
int deth[1000005],det[4][2]={{0,1},{1,0},{-1,0},{0,-1}};
queue <int> q;
inline int read()
{
    int f=1,ans=0;
	char c;
    while (c<'0'||c>'9')
	{
		if (c=='-') f=-1;
		c=getchar();
	}
    while (c>='0'&&c<='9')
	{
		ans=ans*10+c-'0';
		c=getchar();
	}
    return f*ans;
}
void add(int x,int y,int z)
{
    cnt++;
    t[cnt]=y;
    nxt[cnt]=h[x];
    w[cnt]=z;
    h[x]=cnt;
    cnt++;
    swap(x,y),z=0;
    t[cnt]=y;
    nxt[cnt]=h[x];
    w[cnt]=z;
    h[x]=cnt;
}
int bfs()
{
    memset(deth,0,sizeof(deth));
    while (!q.empty()) q.pop();
    deth[s]=1;
    q.push(s);
    while (!q.empty())
    {
        int u=q.front();
        q.pop();
        for (int i=h[u];i!=-1;i=nxt[i])
        {
            if (w[i]>0&&deth[t[i]]==0)
            {
                deth[t[i]]=deth[u]+1;
                q.push(t[i]);
            }
        }
    }
    if (deth[T]!=0) return 1;
	return 0;
}
int dfs(int u,int dist)
{
    if (u==T) return dist;
    for (int i=h[u];i!=-1;i=nxt[i])
    {
        if ((deth[t[i]]==deth[u]+1)&&(w[i]!=0))
        {
            int di=dfs(t[i],min(dist,w[i])); 
            if (di>0) 
            {
                w[i]-=di;
                w[i^1]+=di;
                return di;
            }
        }
    }
    return 0;
}
int dinic()//dinic求最大流=最小割 
{
    int ans=0;
    while (bfs())
    {
    	while (int res=dfs(s,INF)) ans+=res;
    }
    return ans;
}
int main()
{
    n=read(),m=read();
	s=0,T=n*m+1;
    memset(h,-1,sizeof(h));
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=m;j++)
		{
			int p=read();
			S+=p;//S是总数 
			if ((i+j)%2==1) 
			{
				add(s,i*m-m+j,p);//从源点向白点连边 
				for (int k=0;k<4;k++)//枚举相邻的点 
				{
					int x=i+det[k][0],y=j+det[k][1];
					if (x<1||x>n||y<1||y>m) continue;
					add(i*m-m+j,x*m-m+y,INF);//从白点向黑点连边
				}
			}
			else add(i*m-m+j,T,p);//从黑点向汇点连边
		}
	}
    cout << S-dinic();
    return 0;
}
```

祝大家很快可以A了这题，也希望大家掌握好网络流的建图技巧。谢谢。

---

## 作者：千年知乎_天才 (赞：4)

题目名称：方格取数问题

来源：网络流24题
# 链接
## 博客链接
- [博客园](https://www.cnblogs.com/Alvin-Tree/p/11596142.html)
- [CSDN](https://blog.csdn.net/weixin_43890363/article/details/101456278)
- [洛谷博客](https://www.luogu.org/blog/131abc155-7341-6424/solution-p2774)
- [洛谷题解](https://www.luogu.org/problemnew/solution/P2774)

## 题目链接
- LibreOJ(6007) [题目](https://loj.ac/problem/6007) [提交](https://loj.ac/problem/6007#submit_code) [状态](https://loj.ac/submissions?problem_id=6007) [讨论](https://loj.ac/discussion/problem/6007)
- 洛谷(P2774) [题目](https://www.luogu.org/problem/P2774) [提交](https://www.luogu.org/problem/P2774#submit) [状态](https://www.luogu.org/record/list?pid=P2774) [讨论](https://www.luogu.org/discuss/lists?forumname=P2774)
- BZOJCH(1475) [题目](https://bzoj.zcmimi.tk/p/1475.html) [提交](http://www.lydsy.com/JudgeOnline/submitpage.php?id=1475) [讨论](http://www.lydsy.com/JudgeOnline/wttl/wttl.php?pid=1475)

# 提示
注意试题来源！
# 题解
这道题要我们求的是从方格中取得的数最大的和。

不难发现，直接求不太好求。

因为我们取这个格子里的数的条件，不是**取了某个格子里的数**，而是**未取某些格子里的数**。如果我们直接用最大流来写的话，不太好连边。

著名的数学家（神犇）Isaac Newton（虽然说是数学家，但是无意间把OIer往死里坑）曾经说过“正难则反”。

那么我换一下思路，我可以将*取得的最大和*变为*总和*-*最小代价*，这里的代价是指，如果不取某些格子上的数，可以使取的方案合法，这样的格子上的数的总和。

我们将格子进行黑白染色，保证相邻颜色不同，并按顺序给每个格子标上编号，拿样例说话。

![黑（蓝）白（红）染色后的图](http://img5.imgtn.bdimg.com/it/u=3941792551,3972599066&fm=15&gp=0.jpg)

如图，蓝色即是黑色，红色即是白色，方格内是权值。

开始考虑建图：（注意：这里连边都是在格子的编号之间连边）

1. 将源点向所有染黑色格子连边。容量为其权值。
2. 将所有染黑色格子向汇点连边。容量为其权值。
3. 将所有互相冲突的格子（上下左右四个格子）连边，方向为从黑格子向白格子，容量为$\infty$。

又拿样例说话

![根据样例所建的网络图](http://img2.imgtn.bdimg.com/it/u=3143775641,3273518911&fm=15&gp=0.jpg)

不难发现，互相冲突的两个格子必须有一个不被选，在图上就表现为至少有一个到源点或汇点的边要割掉。（因为不可能割中间容量为$\infty$的边）

所以答案就是所有格子上数的总和减去最小割。

跑一遍Dinic就可以了。
```cpp
//C++
#include<bits/locale_facets.h>
#include<bitset>
#include<limits.h>
#include<memory.h>
#include<stdio.h>
#include<queue>
#define downt(i,n) for(int i=n;i;i=back[i])
#define forto(name,i,d,u) for(name i=d;i<=u;i++)
#define foruntil(name,i,d,u) for(name i=d;i<u;i++)
const short nm=101;
inline void output(long long o); 
inline long long input();
short number[nm][nm];
std::bitset<nm>BW[nm];
template<int nn,int mm,typename name>struct network{
#define nnn (nn+3)
#define mmmm (mm<<2)+2
	int s,t,tot,nnnn,last[nnn],level[nnn],to[mmmm],arc[mmmm],back[mmmm];
	name c[mmmm];
	std::queue<int>q;
	network(){nnnn=nnn<<2,INIT();}
#undef nnn
#undef mmmm
	void INIT(){tot=1,memset(last,0,nnnn);}
	void add(int f,int t,name cap){to[++tot]=t,c[tot]=cap,back[tot]=last[f],last[f]=tot;}
	void insert(int f,int t,name cap){
		if(cap){
			if(cap<0)std::swap(f,t),cap=-cap;
			add(f,t,cap),add(t,f,0);
		}
	}bool climb(){
		memset(level,0,nnnn),q.push(s),level[s]=0;
		for(int p,too;!q.empty();q.pop()){
			p=q.front(),level[p]++;
			downt(i,last[p])
			if(c[i]&&!level[too=to[i]])level[too]=level[p],q.push(too);
		}return level[t];
	}name augment(int p,name m){
		if(p==t)return m;
		name sum=0,flow;
		int d=level[p]+1;
        for(;arc[p];arc[p]=back[arc[p]])
		if(level[to[arc[p]]]==d&&c[arc[p]]){
			sum+=(flow=augment(to[arc[p]],std::min(c[arc[p]],(name)(m-sum)))),c[arc[p]]-=flow,c[arc[p]^1]+=flow;
			if(sum==m)return m;
		}return sum;
	}name Dinic(name inf){
		name maximum=0;
		while(climb()){
			foruntil(int,i,s,t)arc[i]=last[i];
			maximum+=augment(s,inf);
		}return maximum;
	}
};network<10000,50000,int>check;
int main(){
	short m=input(),n=input(),e;
	int sum=0,inf=0x3f3f3f;
	check.s=0,check.t=m*n+1,BW[1][1]=true,number[1][1]=1;
	forto(short,i,2,m)BW[i][1]=!BW[i-1][1],number[i][1]=(i-1)*n+1;
	forto(short,i,1,m)
	forto(short,j,2,n)BW[i][j]=!BW[i][j-1],number[i][j]=(i-1)*n+j;
	forto(short,i,1,m)
	forto(short,j,1,n){
		sum+=(e=input());
		if(BW[i][j]){
			check.insert(0,number[i][j],e);
			if(i>1)check.insert(number[i][j],number[i-1][j],inf);
			if(j>1)check.insert(number[i][j],number[i][j-1],inf);
			if(i<m)check.insert(number[i][j],number[i+1][j],inf);
			if(j<n)check.insert(number[i][j],number[i][j+1],inf);
		}else check.insert(number[i][j],check.t,e);
	}output(sum-check.Dinic(INT_MAX));
	return 0;
}inline void output(long long o){
	if(o<0)putchar('-'),o=-o;
	if(o>=10)output(o/10);
	putchar(o%10^'0');
}inline long long input(){
	bool minus=false;
	char now=getchar();
	long long i=0;
	for(;!isdigit(now);now=getchar())
	if(now=='-')minus=!minus;
	for(;isdigit(now);now=getchar())i=(i<<3)+(i<<1)+(now^'0');
	return minus?-i:i;
}
```
# 题集
- [网络流24题](https://blog.csdn.net/weixin_43890363/article/details/101509320)

---

## 作者：tth37 (赞：4)


> [题目链接](https://www.luogu.org/problemnew/show/P2774)

不难发现，每个方格会与其上下左右四个方格产生矛盾。编程的任务即找到一种不产生矛盾的选择方案，并且使得取出的数总和最大。

首先对图进行黑白染色，目的是使产生矛盾的两个位置分别位于不同的色块中，方便建图。

![](https://cdn.luogu.com.cn/upload/pic/54936.png)

源点与所有白色位置相连，权值为该位置上的数字；所有黑色位置与汇点相连，权值也为该位置上的数字；所有白色位置与其上下左右（注意边界情况）的黑色位置相连，权值为无穷大。

![](https://cdn.luogu.com.cn/upload/pic/54937.png)

如此建图后，可以发现存在源点到汇点的增广路，这也意味着原图中存在产生矛盾的两个位置。假设一开始选取M*N网格中的所有方块，我们的任务是割掉网络中的一些边（即删去一些方块），使得割去的边权最小。割去网络中的边就相当于删掉两个矛盾位置中的其中一个，因此当网络中不再有源点到汇点的增广路，就意味着矛盾全部消除。

问题便转化为求解最小割（最大流）的问题。输出答案为全局和减去最小割。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

const int INF=0x3f3f3f3f;
const int MAXN=100005;

int N,M,S,T;
ll sum;

int nx[]={0,1,0,-1};
int ny[]={1,0,-1,0};

struct Edge{
    int v,w,nxt;
}mem[MAXN];
int head[MAXN],cnt=1;

inline void AddEdge(int u,int v,int w){
    mem[++cnt].w=w;
    mem[cnt].v=v;
    mem[cnt].nxt=head[u];
    head[u]=cnt;
}

int d[MAXN];
bool vis[MAXN];

inline bool bfs(){
    memset(vis,0,sizeof(vis));
    vis[S]=1;d[S]=0;
    queue<int> q;
    q.push(S);
    while(q.size()){
        int u=q.front();q.pop();
        for(register int i=head[u];i;i=mem[i].nxt){
            int v=mem[i].v,w=mem[i].w;
            if(vis[v]||(w==0)) continue;
            vis[v]=1;d[v]=d[u]+1;
            q.push(v);
        }
    }
    return vis[T];
}

inline int dfs(int u,int flow){
    if(u==T) return flow;
    int rflow;
    for(register int i=head[u];i;i=mem[i].nxt){
        int v=mem[i].v,w=mem[i].w;
        if(w==0||d[u]+1!=d[v]) continue;
        if(rflow=dfs(v,min(flow,w))){
            mem[i].w-=rflow;
            mem[i^1].w+=rflow;
            return rflow;
        }
    }
    return 0;
}

inline int Dinic(){
    int maxflow=0,lowflow;
    while(bfs()){
        while(lowflow=dfs(S,INF)) maxflow+=lowflow;
    }
    return maxflow;
}

int main(){
    scanf("%d%d",&M,&N);
    S=0,T=M*N+1;
    for(register int i=1;i<=M;++i){
        for(register int j=1;j<=N;++j){
            int w;
            scanf("%d",&w);
            sum+=w;
            if((i+j)&1){
                AddEdge(S,(i-1)*N+j,w);
                AddEdge((i-1)*N+j,S,INF);
                for(register int k=0;k<=3;++k){
                    int tx=i+nx[k],ty=j+ny[k];
                    if(tx<1||tx>M||ty<1||ty>N) continue;
                    AddEdge((i-1)*N+j,(tx-1)*N+ty,INF);
                    AddEdge((tx-1)*N+ty,(i-1)*N+j,0);
                }
            }
            else{
                AddEdge((i-1)*N+j,T,w);
                AddEdge(T,(i-1)*N+j,INF);
            }
        }
    }
    printf("%lld",sum-Dinic());
    return 0;
}
```


---

## 作者：arfa (赞：3)

本题的先决是 [$P3410$ 拍照](https://www.luogu.org/problemnew/show/P3410) , [题解](https://www.luogu.org/blog/acking/solution-p3410)。

我只能照着 $P3410$ 的来说喽。

$P3410$ 中我们要求给一些人拍照,一些人给你钱。最后付下属的钱。求最大的纯利润。

这一题我们也转化一下:

- 首先黑白染色 ($(i+j) \mod 2=1$ 为白色),显然一个黑色点周围都是白色,一个白色点周围都是黑色。

- 白色点会给你钱,但是白色点要去除一些黑色点。而一个黑色点被去除 (只要一次或一次以上) 要你钱,它可以被去除多次 (因为它上下左右都是白点)。

这样子就变成了 $P3410$ 的问题了。

所以每一个白色点向源点连边,黑色点向汇点连边,流量为点权。白色点向黑色点连边,流量为 $inf$。

```pascal
// luogu-judger-enable-o2
Uses math;

var
    value,reach,next:array[-1..21000] of longint;
    gap,dis,cnt:array[-1..21000] of longint;
    n,m,l,r,i,j,sum,tot,sink,source,number,maxflow:longint;

procedure add(l,r,sum:longint);
begin
    inc(tot); reach[tot]:=r; value[tot]:=sum; next[tot]:=cnt[l]; cnt[l]:=tot;
    inc(tot); reach[tot]:=l; value[tot]:=8-8; next[tot]:=cnt[r]; cnt[r]:=tot;
end;

function Dfs(now,flow:longint):longint;
var i,k,mindis,ret:longint;
begin
    mindis:=n-1; ret:=flow;
    if now=sink then exit(flow);
    i:=cnt[now];
    while i<>-1 do
    begin
        if value[i]>0 then
        begin
            if dis[now]=dis[reach[i]]+1 then
            begin
                k:=Dfs(reach[i],min(ret,value[i]));
                dec(value[i],k);inc(value[i xor 1],k);
                dec(ret,k);
                if dis[source]>=n then exit(flow-ret);
                if ret=0 then break;
            end;
            mindis:=min(mindis,dis[reach[i]]);
        end;
        i:=next[i];
    end;
    if ret=flow then
    begin
        dec(gap[dis[now]]);
        if gap[dis[now]]=0 then dis[source]:=n;
        dis[now]:=mindis+1;
        inc(gap[dis[now]]);
    end;
    exit(flow-ret);
end;

begin
    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1);

    read(n,m);
    source:=1; sink:=n*m+2; number:=1; tot:=1;
    for i:=1 to n do
        for j:=1 to m do
        begin
            read(l); inc(sum,l); inc(number);
            if ((i+j) mod 2=1) then
            begin
                add(source,number,l);
                if (j<m) then add(number,number+1,maxlongint);
                if (j>1) then add(number,number-1,maxlongint);
                if (i<n) then add(number,number+m,maxlongint);
                if (i>1) then add(number,number-m,maxlongint);
            end else add(number,sink,l);
        end;

    n:=sink; gap[source]:=n;
    while dis[source]<n do inc(maxflow,Dfs(source,maxlongint));
    writeln(sum-maxflow);
end.
```

至于我一开始为什么 $9$ 分是因为 $n,m$ 搞反了。

---

## 作者：Kelin (赞：3)

题意楼下已经说得比较清楚了

我只是来上一份ISAP的代码

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#define re register int
#define Inline __inline__ __attribute((always_inline))
const int N=2505,M=N<<2,inf=~0u>>1;
const int dx[]={0,0,1,-1},dy[]={1,-1,0,0};
struct edges{int nx,to,w,ivs;}edge[M<<1];
int n,m,W,cnt,dis[N],num[N],pre[N],pos[51][51],tot,fi[N],cur[N];
std::queue<int>q;
void bfs(re st,re en){
    memset(dis,-1,sizeof(dis));memset(num,0,sizeof(num));
    num[dis[en]=0]=1;q.push(en);re u,v;
    while(!q.empty()){
        v=q.front();q.pop();
        for(re i=fi[v];i;i=edge[i].nx)
            if(dis[u=edge[i].to]==-1)
                {++num[dis[u]=dis[v]+1];q.push(u);}
    }
}
int augment(re st,re en,re&pos){
    re flow=inf,v;
    v=en;while(v!=st){flow=flow<edge[pre[v]].w?flow:edge[pos=pre[v]].w;v=edge[edge[pre[v]].ivs].to;}//找到最靠近源点的断流(满流)了的点,所以相等时也要往前推移 
    v=en;while(v!=st){edge[pre[v]].w-=flow;edge[edge[pre[v]].ivs].w+=flow;v=edge[edge[pre[v]].ivs].to;}
    pos=edge[edge[pos].ivs].to;return flow;
}
Inline int ISAP(re st,re en){
    bfs(st,en);re ans=0,u=st,i,md;
    memcpy(cur,fi,sizeof(fi));
    while(dis[st]<=en){
        ok:if(u==en)ans+=augment(st,en,u);
        for(i=cur[u];i;i=edge[i].nx)
            if(edge[i].w&&dis[u]==dis[edge[i].to]+1)
                {pre[u=edge[i].to]=i;goto ok;}
        if(--num[dis[u]]==0)break;
        for(md=en,i=fi[u];i;i=edge[i].nx)
            if(edge[i].w&&dis[edge[i].to]!=-1)
                md=md>dis[edge[i].to]?dis[edge[cur[u]=i].to]:md;
        ++num[dis[u]=md+1];
        if(u!=st)u=edge[edge[pre[u]].ivs].to;
    }
    return ans;
}
Inline void add_edge(re u,re v,re w){
    edge[++tot]=(edges){fi[u],v,w,tot+1};fi[u]=tot;
    edge[++tot]=(edges){fi[v],u,0,tot-1};fi[v]=tot;
}
int main(){
    scanf("%d%d",&n,&m);
    for(re i=1;i<=n;++i)
        for(re w,j=1;j<=m;++j){
            scanf("%d",&w),pos[i][j]=++cnt;W+=w;
            if((i+j)&1)add_edge(0,cnt,w);//自己琢磨一下是哪些点
            else add_edge(cnt,n*m+1,w);
        }
    for(re i=1;i<=n;++i)
        for(re j=1;j<=m;++j)
            if((i+j)&1)//注意是连向起点的点向四周(连向终点的点)连一条无限大的边
                for(re k=0;k<4;++k){
                    re x=i+dx[k],y=j+dy[k];
                    if(1<=x&&x<=n&&1<=y&&y<=m)
                        add_edge(pos[i][j],pos[x][y],inf);
                }
    printf("%d",W-ISAP(0,n*m+1));
return 0;
}
```

---

## 作者：Ajsoabk (赞：2)

博大精深的网络流。。。

## [P2774 方格取数问题](https://www.luogu.org/problemnew/show/P2774)


又一个tot不初始化为1的惨痛教训

先假设**所有点都取**

考虑用最小的代价“割去”各点之间的联系（**总体缩减**思想在网络流里经常用到，比如最小路径覆盖）

可以理解为减去相邻的点所取各值中较小的一个（即最大通过的流）

我们可以很简单的建出一个表示邻接关系的图（二分图）

为了让两点的值在整条路上有所体现（**限制流量**）

我们在源汇与各部集之间的容量设为**所连点的值**

则流在从源向汇时必会受到首尾两个容量的限制

而表示邻接关系的容量不必限制，设为inf

所以最大流的题主要难在**抽象出流与流的限制条件**

即 什么在流？什么在限制？（限制了多少）

```cpp

#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
typedef long long LL;
const int N=10000+5;
const int inf=0x7fffffff;
const int dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
template<class T>inline void read(T &num){
    char ch;
    while(!isdigit(ch=getchar()));
    num=ch-'0';
    while(isdigit(ch=getchar()))num=num*10+ch-'0';
}

int hea[N],to[N<<2],nex[N<<2],val[N<<2],dep[N],n,m,tot=1,s,t;
LL sum;
inline int id(int i,int j){
    return (i-1)*n+j;
}
inline void add_edge(const int x,const int y,const int w){
//printf("%d --> %d ( %d )\n",x,y,w);
    to[++tot]=y,nex[tot]=hea[x],hea[x]=tot,val[tot]=w;
}

queue<int> que;
int bfs(){
    memset(dep,0,sizeof(dep));
    dep[s]=1;
    while(que.size())que.pop();
    que.push(s);
    int x;
    while(que.size()){
        x=que.front();que.pop();
        for(int i=hea[x];i;i=nex[i]){
            int y=to[i];
            if(val[i]&&!dep[y]){
                dep[y]=dep[x]+1;
                if(y==t)return 1;
                que.push(y);
            }
        }
    }
    return 0;
}

int dfs(int x,int flow){
//printf("dfs(%d,%d)\n",x,flow); 
    if(x==t)return flow;
    int rest=flow,k;
    for(int i=hea[x];i&&rest;i=nex[i]){
        int y=to[i];
        
        if(val[i]&&dep[y]==dep[x]+1){
//printf("rest=%d,val[%d]=%d\n",rest,i,val[i]);
//printf("%d->%d\n",x,y);
            k=dfs(y,min(rest,val[i]));
//printf("k=%d\n",k); 
            if(k==0)dep[y]=0;
            val[i]-=k;
            val[i^1]+=k;
            rest-=k;
        }
    }
//printf("return %d-%d\n",flow,rest);
    return flow-rest;
}

int main(){
    read(m),read(n);
    s=m*n+1,t=m*n+2;
//printf("s=%d,t=%d\n",s,t);
    for(int i=1,w;i<=m;++i){
        for(int j=1;j<=n;++j){
            read(w);
            sum+=w;
            if((i+j)&1){
                add_edge(s,id(i,j),w);
                add_edge(id(i,j),s,0);
            }
            else{
                add_edge(id(i,j),t,w);
                add_edge(t,id(i,j),0);
            }
        }
    }
    for(int i=1;i<=m;++i){
        for(int j=1;j<=n;++j){
            if((i+j)&1)
                for(int k=0;k<4;++k){
                    int x=i+dir[k][0],y=j+dir[k][1];
                    if(1<=x&&x<=m&&1<=y&&y<=n){
                        add_edge(id(i,j),id(x,y),inf);
                        add_edge(id(x,y),id(i,j),0);
                    }
                }
        }
    }
    int flow;
    while(bfs())while(flow=dfs(s,inf))sum-=flow;
    printf("%lld\n",sum);
    return 0;
}
```

---

## 作者：Hongse_Fox (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P2774)
# 零.前记
已经有半年没有写过网络流了

拿道网络流$24$题的题恢复一下手感

~~不过还是写错了一个字符~~

这道题就是最小割等于最大流的经典应用

# 一.思路
如果直接求没有相邻格子的最大和比较困难

因为情况实在是太多了

那我们不妨换个角度思考

把不取的删掉 那剩下的不就是相当于取吗

题目就相当于求怎么删格子使得删除格子的和最小且剩下的格子没有相邻的

而对于方格问题首先想到的不是$dp$就是二分图了

于是我们就按照格子行数$+$列数的奇偶性分个二分图

但是这还不够

既然都说到二分图了那么自然就要连上源点和汇点了

得到的图就是这样$:$

![](https://s3.ax1x.com/2020/11/16/DkHMut.png)

其中连源点和汇点的边流量为格子权值

中间的边流量为正无穷

那我们最后想得到的结果是怎样呢

假设有两个点$a,b$相邻 那么他们不能同时选

也就是说要不然割掉$a$和源点相连的边$($图中的$S3)$

要不然就割掉$b$与汇点相连的边$($图中的$2T)$

那我们剩下的图就是$S$走不到$T$的图

这不就是求最小割吗

而最小割等于最大流

于是我们就可以打一个网络流解决问题

# 二.实现方法
按前面所说的连图再跑一遍网络流即可

求出最大流$maxflow$之后

要用所有格子的权值和减去$maxflow$

# 三.代码
```cpp
#include<cstdio>
#include<cctype>
const int INF=0x7fffffff;
inline int fan(int a){return a%2==0? a-1:a+1;}
inline int min(int a,int b){return a<b? a:b;}
inline int R(){
	int r=0;char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) r=(r<<1)+(r<<3)+(c^48),c=getchar();
	return r;
}
struct node{
	int to,next,flow;
}edge[410005];
int n,m,a[35][35],num[35][35],head[1005],tot,opt=1,ans,h;
int s,t,dis[1005],gap[1005],cur[1005];//网络流 
inline void add(int from,int to,int flow){
	edge[++tot].next=head[from];
	edge[tot].flow=flow;
	edge[tot].to=to;
	head[from]=tot;
	return ;
}
inline void addd(int from,int to,int flow){
	add(from,to,flow);
	add(to,from,0);
}
inline int isap(int now,int nowflow){//isap模板 
	if(now==t) return nowflow;
	int sum=0;
	for(register int i=cur[now];i;i=edge[i].next){
		if(edge[i].flow && dis[edge[i].to]==dis[now]-1){
			int akak=isap(edge[i].to,min(nowflow-sum,edge[i].flow));
			sum+=akak;cur[now]=i;
			edge[i].flow-=akak;edge[fan(i)].flow+=akak;
			if(dis[s]==n || sum==nowflow) return sum;
		}
	}
	if(!--gap[dis[now]]) dis[s]=n;
	gap[++dis[now]]++;
	cur[now]=head[now];
	return sum;
}
int main(){
	n=R();m=R();
	s=1;t=n*m+2;
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			a[i][j]=R();
			h+=a[i][j];
		}
	}
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			num[i][j]=++opt;
			if((i+j)%2==1){//按照点的奇偶分左右 
				addd(s,opt,a[i][j]);
				dis[opt]=2;gap[2]++;//gap优化和dis优化 
				if(i!=1) addd(opt,num[i-1][j],INF);
				if(j!=1) addd(opt,num[i][j-1],INF);
			}
			else{
				addd(opt,t,a[i][j]);
				dis[opt]=1;gap[1]++;
				if(i!=1) addd(num[i-1][j],opt,INF);
				if(j!=1) addd(num[i][j-1],opt,INF);
			}
		}
	}
	dis[t]=0;gap[0]++;dis[s]=3;gap[3]++;
	n=opt+1;
	for(register int i=1;i<=n;i++) cur[i]=head[i];//cur优化 
	while(dis[s]<n)
	ans+=isap(s,INF);//网络流 用的是isap 
	printf("%d\n",h-ans);
	return 0;
}
```
# 四.后记
这道题可以给我们三个启示

$1.$当直接取东西不好算的时候可以考虑删东西

$2.$考虑题目要求的最后是什么样的状态 有什么特点

$3.$时刻谨记最大流和最小割是相等的

Finally，谢谢大家

[更好的阅读体验](https://www.luogu.com.cn/blog/HongseFox/solution-p2774)

---

## 作者：KobeWu (赞：1)

### 解题之前
刚刚学习网络流时，看了一遍[网络流24题](https://www.luogu.org/problem/list?tag=332&page=1)，发现用网络流一题也不会做（应该是我太蒻了）。于是，我先找了一些基础的题目做，渐渐对这类题的建模和套路有了一些了解，尤其是在$\mathbb{AC}$了[P4304 TJOI2013 攻击装置](https://www.luogu.org/problem/P4304)和[P3355 骑士共存问题](https://www.luogu.org/problem/P3355)后，看到本题[P2774 方格取数问题](https://www.luogu.org/problem/P2774)，思路更加清晰明了了。

其实，我还没点开这道题时，我还以为这是[P1004 方格取数](https://www.luogu.org/problem/P1004)的加强版，然而并不是，于是开始仔细审题。
### 题目分析
事实上，这道题的题目描述已经将题目的意思表达得很清楚了，我们需要在一个$N \times M$ 的棋盘中取数，并且当选取了一个方格时，与其相邻（有公共边）的方格不能被选取。根据题意，我们可以对这个棋盘进行黑白染色，显然，由此我们得到了一个二分图。

由于选择一个方格和选择与这个方格相邻的方格是对立的，我们可以联想到求二分图的最大独立集，于是我们可以建立起一个初步的模型：

- 从超级源$S$向所有黑色方格连有向边
- 从所有黑色方格向与其相邻的白色方格连有向边
- 从所有白色方格向超级汇$T$连有向边

但是，每个方格都有相应的权值，怎么办？而这些权值与刚刚连的有向边的边权又有什么关系呢？

其实，由选择一个方格和选择与这个方格相邻的方格是对立的，我们可以换一种方式理解，即：选择了一个方格，我们就无法的得到与其相邻的方格的权值了。或者说，原本所有的方格都是可能被选择的，但是一旦你选择了一个方格，得到了它的权值，就会有相应的损失。这样，你想到了什么？

我觉得这有点像求最大权闭合子图，于是，我们可以尝试着给边赋权了;

- 从超级源$S$出发或连向超级汇$T$的边都赋上对应的方格的权值
- 黑色方格与白色方格之间的边赋上$INF$

但是，我们的选择而造成的损失是有重复的，因为一个方格如果已经不能被选择，那么由它不能被选择而带来的损失不会有第二次，而且我们可能会同时选择不相邻的黑色格子和白色格子，所以用求最大权闭合子图的方法似乎行不通。这是真的吗？

回忆一下：最大权闭合子图的权值和$=$所有正点的权值之和$-$从$S$到$T$的最小割

其实，要让选取的权值和最大，就是要让$S$-$T$的割最小。这时，我的脑中闪过老师的一句话：很多题目正着做很难做，但是考虑所求答案的反面，就很简单。

~~啊！~~ 原来之前建立的模型似乎很接近正解呢！

事实上，我们可以假设每个点都选，然后减去最小的损失，就是最终的答案。具体来讲，就是先统计所有方格的权值和，再求之前建立的网络图的最大流（等于最小割），将两者一做差，就得到答案了。

以下是我的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 110
#define MXN 10010
#define MXM 20010
#define INF 2147483600
#define Min(a,b) ((a)<(b)?(a):(b))
int N,M,g[MAXN][MAXN],S,T,sum;
struct Point {int x,y;};
int det[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
int hd[MXN],ed[MXM<<1],val[MXM<<1],nxt[MXM<<1],tot;
int dep[MXN],curArc[MXN]; bool inq[MXN]; queue <int> Q;
inline int rd()
{
	int ret=0,f_f=1; char c=getchar();
	while(c<'0' || c>'9') {if(c=='-') f_f=-1; c=getchar();}
	while(c>='0' && c<='9') ret=(ret<<1)+(ret<<3)+c-'0',c=getchar();
	return ret*f_f;
}
inline int Transf(Point x) {return (x.x-1)*M+x.y;}
inline void AddEdge(int u,int v,int w) {ed[++tot]=v,val[tot]=w,nxt[tot]=hd[u],hd[u]=tot;}
inline bool Bfs()
{
	for (int i=0;i<=N*M+1;i++)
		curArc[i]=hd[i],dep[i]=INF,inq[i]=false;
	dep[S]=0,inq[S]=true;
	while (!Q.empty()) Q.pop(); Q.push(S);
	while (!Q.empty())
	{
		int u=Q.front(); Q.pop(),inq[u]=false;
		for (int p=hd[u];p!=-1;p=nxt[p])
		{
			int v=ed[p];
			if (val[p] > 0 && dep[v] > dep[u] + 1)
			{
				dep[v]=dep[u]+1;
				if (!inq[v]) inq[v]=true,Q.push(v);
			}
		}
	}
	return dep[T] != INF;
}
inline int Dfs(int u,int Flow)
{
	if (u == T) return Flow;
	int curFlow,tot=0;
	for (int p=curArc[u];p!=-1;p=nxt[p])
	{
		curArc[u]=p;
		int v=ed[p];
		if (val[p] > 0 && dep[v] == dep[u] + 1)
		{
			curFlow=Dfs(v,Min(val[p],Flow));
			if (curFlow != 0)
			{
				val[p]-=curFlow;
				val[p^1]+=curFlow;
				Flow-=curFlow,tot+=curFlow;
				if (Flow <= 0) break;
			}
		}
	}
	return tot;
}
inline int Dinic()
{
	int maxFlow=0;
	while (Bfs())
	{
		int Flow=Dfs(S,INF);
		while (Flow != 0)
		{
			maxFlow+=Flow;
			Flow=Dfs(S,INF);
		}
	}
	return maxFlow;
}
int main()
{
	N=rd(),M=rd(),S=0,T=N*M+1,sum=0;
	for (int i=1;i<=N;i++)
		for (int j=1;j<=M;j++)
			g[i][j]=rd(),sum+=g[i][j];
	memset(hd,-1,sizeof(hd)),tot=1;
	for (int i=1;i<=N;i++)
		for (int j=1;j<=M;j++)
		{
			Point u=(Point){i,j};
			if ((i + j) & 1)
			{
				for (int k=0;k<4;k++)
				{
					Point v=u; v.x+=det[k][0],v.y+=det[k][1];
					if (v.x >= 0 && v.x <= N && v.y >= 1 && v.y <= M)
						AddEdge(Transf(u),Transf(v),INF),AddEdge(Transf(v),Transf(u),0);
				}
				AddEdge(S,Transf(u),g[i][j]),AddEdge(Transf(u),S,0);
			}
			else AddEdge(Transf(u),T,g[i][j]),AddEdge(T,Transf(u),0);
		}
	printf("%d",sum-Dinic());
	return 0;
}
```

---

## 作者：FREEH (赞：1)


### 【题目大意】

- 在一个有m*n个方格的棋盘中，每个方格中有一个正整数。现要从方格中取数，使任意2个数所在方格没有公共边，输出取出的数的最大总和。

### 【解题思路】

- 题目要求的是取出的数和最大，其实就是删除和最小的数，使方案合法，然后用总和减去最小的和。

- 染色。因为只有相邻的方格会发生冲突，那么把相邻的方格染成不同的颜色就行了。

- 构图。源点连接着每一个红色方格，边的容量是每一个红色方格的数；每一个红色方格连接着发生冲突的黄色方格，边的容量是1；每一个黄色方格连接着汇点，边的容量是每一个黄色方格的数。

- 求出了这个图的最小割，就是删除的最小和，用总和减去它就行了。而最小割就是最大流。

### 【解题反思】
-     做这类题目最重要的是如何把不可构图的题目转化为可构图的题目。

### 【参考程序】
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#define min(a,b)(a<b?a:b)
using namespace std;
struct EDGE{int f,t,c,next;};
EDGE edge[100005];
int head[100005],cur=-1,s,t,n,m,p[50][50],c[50][50],sz[50][50];
bool visit[100005],viu[100005],viv[100005];
const int dx[4]={0,0,-1,1};
const int dy[4]={-1,1,0,0};
void add(int u,int v,int c)
{
    cur++;
    edge[cur].f=u;
    edge[cur].t=v;
    edge[cur].c=c;
    edge[cur].next=head[u];
    head[u]=cur;
}
int dfs(int now,int mi)
{
    if (visit[now]) return 0;
    if (now==t) return mi;
    visit[now]=true;
    int h=head[now];
    while (h!=-1)
    {
        int to=edge[h].t;
    
        if (edge[h].c!=0)
        {
            int res=dfs(to,min(mi,edge[h].c));
            if (res)
            {
                edge[h].c-=res;
                edge[h^1].c+=res; 
                return res;
            }
        }
        h=edge[h].next;
    }
    return 0;
}
int main()
{
    cur=-1;
    memset(edge,0,sizeof(edge));
    memset(head,-1,sizeof(head));
    
    scanf("%d%d",&n,&m);
    s=n*m+1,t=n*m+2;
    for (int i=1;i<=n;i++)
      for (int j=1;j<=m;j++)
        {	
            p[i][j]=(i-1)*m+j;
            c[i][j]=(i%2==j%2);
        }
    int sum=0;
    for (int i=1;i<=n;i++)
      for (int j=1;j<=m;j++)
        {	
           scanf("%d",&sz[i][j]);
           sum+=sz[i][j];   
        }
    for (int i=1;i<=n;i++)
      for (int j=1;j<=m;j++)
        for (int k=0;k<4;k++)
          {
              int x=i+dx[k],y=j+dy[k];
              if (x<1||x>n||y<1||y>m) continue;
              if (c[i][j]) add(p[i][j],p[x][y],100000000),add(p[x][y],p[i][j],0);
          }
    for (int i=1;i<=n;i++)
      for (int j=1;j<=m;j++)
        {
            if (c[i][j]) add(s,p[i][j],sz[i][j]),add(p[i][j],s,0);
              else add(p[i][j],t,sz[i][j]),add(t,p[i][j],0);
        }
    int ans=0;
    while (1)
      {
          memset(visit,0,sizeof(visit));
          int res=dfs(s,100000000);
          if (res) ans+=res;else break;	
      }
    cout<<sum-ans;
    return 0;
}

```

---

## 作者：11D_Beyonder (赞：0)

> 传送门 [$\looparrowright$](https://www.luogu.com.cn/problem/P2774)  

## 题目描述  
&emsp;&emsp;有一个 $m$ 行 $n$ 列的方格图，每个方格中都有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大，请求出最大的和。  
## 输入格式  
&emsp;&emsp;第一行是两个用空格隔开的整数，分别代表方格图的行数 $m$ 和列数 $n$。  
&emsp;&emsp;第 $2$ 到第 $(m + 1)$ 行，每行 $n$ 个整数，第 $(i + 1)$ 行的第 $j$ 个整数代表方格图第 $i$ 行第 $j$ 列的的方格中的数字 $a_{i, j}$。  
## 输出格式  
&emsp;&emsp;输出一行一个整数，代表和最大是多少。  
## 输入输出样例  
### 输入 #1  
> 3 3  
> 1 2 3  
> 3 2 3  
> 2 3 1   

### 输出 #1  
> 11  

## 说明/提示  
### 数据规模与约定   
&emsp;&emsp;对于 $100\%$ 的数据，保证 $1 \leqslant n, m \leqslant 100$，$1 \leqslant a_{i, j} \leqslant 10^5$。  
### 提示  
&emsp;&emsp;请注意输入的第一行先读入 $m$ 再读入 $n$。   
## 分析  
&emsp;&emsp;首先明确题意：在一个 $m\times n$ 的方格图中取若干个数，设取出的数组成可重集 $\mathbb S$，$\mathbb S$ 中任意两个数所在放个不能在相邻（共享同一条边），求 $\mathbb S$ 中所有元素和的最大值。  
&emsp;&emsp;可以考虑一开始取所有方格，再删除权值和尽量小的方格，使得剩下的方格合法。假设取了方格 $x$，与其相邻的四个方格就都不可取了，可以注意到，与其相邻的四个方格的横纵坐标（行为横坐标，列为纵坐标）之和同 $x$ 的横纵坐标之和相差 $1$，相差 $1$ 意味着奇偶性不相同。可见，横纵坐标之和的奇偶性相同的两个点**一定**可以同时选取，而横纵坐标之和不同的两点**可能**会产生**冲突**。根据这一特性，可以建立二分图，将横纵坐标之和为偶数的点放入左部，横纵坐标之和为奇数的点放入右部。    
&emsp;&emsp;二分图问题往往可以用网络流求解。建立超级源点 $s$ 和超级汇点 $t$，$s$ 向各个左部点连边，边权为对应方格的数字；各个右部点向 $t$ 连边，边权为对应方格的数字；$s$ 的出边和 $t$ 的入边都存在，代表一开始选取所有方格中的数；若割去 $s$ 的一条入边，那么该边指向的节点所代表的方格就不会被选取。接着在左右两部节点之间建边，左部各个点向其互相冲突的至多四个（上下左右）右部点连边；这时，一定存在从 $s$ 到 $t$ 的路径，这条路径一定会包含一对互相冲突的节点，设为 $a,b$，意味着存在 $s$ 到 $a$ 的边和 $b$ 到 $t$ 的边，即两个冲突的方格同时被选取；我们的任务是割去一些 $s$ 的出边和 $t$ 的入边，使得 $s$ 和 $t$ 互不相通，且割去的边的边权要尽量小，这就联想到了最小割。将左右两部之间的边的边权设为 $+\infty$，该网络最小割即为要舍弃的方格中的数的总和，所有方格中数字的和减去舍弃方格中的数的总和即为答案。   
&emsp;&emsp;最后，最大流等于最小割，建完图跑一遍 $\text{Dinic}$ 算法即可。  

## 代码  
```cpp
/******************************************************************
Copyright: 11D_Beyonder All Rights Reserved
Author: 11D_Beyonder
Problem ID: 洛谷 P2774
Date: 7/27/2020
Description: Minimum Cut
*******************************************************************/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int MAX_POINT=10023;
const int MAX_EDGE=100024;
const int inf=0x3f3f3f3f;
const int dx[]={-1,1,0,0};
const int dy[]={0,0,-1,1};
struct E
{
	int to;
	int cap;
	int Next=-1;
}edge[MAX_EDGE];
int head[MAX_POINT],tot;
int s,t;
int depth[MAX_POINT];
int m,n;
void init();
inline void add_edge(int,int,int);
inline int ID(int,int);
bool bfs();
int dfs(int,int);
int Dinic();
int main()
{
	int i,j,k;
	int sum=0;
	cin>>m>>n;
	init();
	for(i=1;i<=m;i++)
	{
		for(j=1;j<=n;j++)
		{
			int val;
			scanf("%d",&val);
			sum+=val;
			if((i+j)&1) add_edge(ID(i,j),t,val);//右部
			else//左部
			{
				add_edge(s,ID(i,j),val);
				for(k=0;k<4;k++)
				{
					int x=i+dx[k];//行
					int y=j+dy[k];//列
					if(x<1||x>m||y<1||y>n) continue;
					add_edge(ID(i,j),ID(x,y),inf);
				}
			}
		}
	}
	cout<<sum-Dinic()<<endl;
	return 0;
}
void init()
{
	tot=1;
	memset(head,-1,sizeof(head));
	s=0;
	t=n*m+1;
}
inline int ID(int x,int y) {return (x-1)*n+y;}
inline void add_edge(int u,int v,int cap)
{
	tot++;
	edge[tot].to=v;
	edge[tot].cap=cap;
	edge[tot].Next=head[u];
	head[u]=tot;
	//建立反边
	tot++;
	edge[tot].to=u;
	edge[tot].cap=0;
	edge[tot].Next=head[v];
	head[v]=tot;
}
bool bfs()
{
	memset(depth,0,sizeof(depth));
	queue<int>q;
	q.push(s);
	depth[s]=1;
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(register int i=head[x];~i;i=edge[i].Next)
		{
			int y=edge[i].to;
			//残量网络上构建分层图
			if(edge[i].cap&&!depth[y])
			{
				q.push(y);
				depth[y]=depth[x]+1;
				if(y==t) return 1;//汇点可达
			}
		}
	}
	return 0;
}
int dfs(int x,int flow)//当前节点 当前流量
{
	//dfs 返回残量网络上可增广的流量
	if(x==t) return flow;
	int rest=flow;//rest 剩余流量
	int temp;
	for(register int i=head[x];~i&&rest;i=edge[i].Next)
	{
		int y=edge[i].to;
		if(edge[i].cap&&depth[y]==depth[x]+1)
		{
			temp=dfs(y,min(rest,edge[i].cap));
			if(!temp) depth[y]=0;//剪枝 去掉增广完毕的点
			edge[i].cap-=temp;
			edge[i^1].cap+=temp;
			rest-=temp;
		}
	}
	return flow-rest;
}
int Dinic()
{
	int maxflow=0;
	while(bfs()) maxflow+=dfs(s,inf);
	return maxflow;
}
```
## 后记  
&emsp;&emsp;位于第 $x$ 行，第 $y$ 列的点的编号为 $(x-1)n+y$；一开始没搞对，导致有一个测试点一直过不去。  

---

## 作者：cunzai_zsy0531 (赞：0)

# 本人的题解

[题目链接](https://www.luogu.com.cn/problem/P2774)

0. 这道题目解法很妙，主要用到了最大和=总和-最小舍弃和。

   最小舍弃和即最小割（我们构造出一个二分图满足割掉=舍去），我们又知最小割=最大流，所以是一道最大流问题。

1. 考虑建图：

   我们发现，只要两个点相邻（不兼容），那么这两个点的横纵坐标和的奇偶性一定不同，即

   $(x_i+y_i)\bmod 2 \neq (x_j+y_j)\bmod 2$

   所以我们可以把整个图分成$(x_i+y_i)\bmod 2=0$的点集和$(x_i+y_i)\bmod 2=1$的点集。这样就构成了二分图。

1. 考虑构图：

   将这两个点集分别全部连向$S$和$T$（边权即为此方格中的数），中间相邻点连边（边权为$INF$）。这样我们可以保证形成最小割时，图的中间所有边都没被删，也就达成了割掉=舍去这一目的。
   
   最终，跑最大流即可。
   
上代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<vector>
using namespace std;
const int N=20000+21,INF=0x3f3f3f3f;
struct Edge{int u,v,w,nxt;}e[N*100];
struct Node{int u,val;bool operator <(const Node &a)const{return val<a.val;};};
priority_queue<Node>q;//HLPP用优先队列优化
int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};
int h[N],gap[N],flow[N],d[N];
bool vis[N];
int n,m,s,t,sum,tot=1;
inline int getnum(int x,int y){return (x-1)*m+y;}
inline bool check(int x,int y){return x>=1&&x<=n&&y>=1&&y<=m;}
inline void add(int u,int v,int w){//别忘了反向边
	e[++tot]=(Edge){u,v,w,h[u]};h[u]=tot;
	e[++tot]=(Edge){v,u,0,h[v]};h[v]=tot;
}
bool bfs(){
	memset(d,-1,sizeof(d));
	queue<int>Q;
	Q.push(t);//HLPP反向建边
	d[t]=0;
	while(!Q.empty()){
		int u=Q.front();
		Q.pop();
		for(int i=h[u];i;i=e[i].nxt){
			int v=e[i].v,w=e[i^1].w;//注意反向边
			if(d[v]==-1&&w){
				d[v]=d[u]+1;
				Q.push(v);
			}
		}
	}
	return d[s]!=-1;
}
void Init(){//队列初始化
	for(int i=h[s];i;i=e[i].nxt){
		int v=e[i].v,w=e[i].w;
		if(w){
			e[i].w=0,e[i^1].w=w;
			flow[s]-=w,flow[v]+=w;
			if(v!=s&&v!=t&&!vis[v]){
				vis[v]=1;
				q.push((Node){v,d[v]});
			}
		}
	}
}
void Push(int u){//扫描到u点，把u点的流往下推进
	for(int i=h[u];i;i=e[i].nxt){
		int v=e[i].v,w=e[i].w;
		if(d[u]==d[v]+1&&w){
			int f=min(flow[u],w);
			e[i].w-=f,e[i^1].w+=f;
			flow[u]-=f,flow[v]+=f;
			if(v!=s&&v!=t&&!vis[v]){
				vis[v]=1;
				q.push((Node){v,d[v]});
			}
		}
	}
}
void Gap(int u){//断层优化，把所有点的层数都改为源点+1，使其尽快流回源点
	for(int i=1;i<=n*m;++i){
		if(i!=s&&i!=t&&d[i]>d[u]&&d[i]<=n) d[i]=n+1;
	}
}
void Relabel(int u){//把u点的层设为它连向的点中最小的层数+1，保证能流
	d[u]=INF;
	for(int i=h[u];i;i=e[i].nxt){
		int v=e[i].v,w=e[i].w;
		if(w) d[u]=min(d[u],d[v]);
	}
	d[u]++;
}
int HLPP(){
	if(!bfs()) return 0;
	memset(gap,0,sizeof(gap));
	memset(flow,0,sizeof(flow));
	memset(vis,0,sizeof(vis));
	d[s]=n;
	for(int i=1;i<=n*m;++i){
		if(d[i]!=-1) gap[d[i]]++;
	}
	Init();
	while(!q.empty()){
		int u=q.top().u;
		q.pop();
		vis[u]=0;
		Push(u);
		if(flow[u]){
			gap[d[u]]--;
			if(!gap[d[u]]) Gap(u);
			Relabel(u);
			gap[d[u]]++;
			vis[u]=1;
			q.push((Node){u,d[u]});
		}
	}
	return flow[t];//最终推到汇点的就是最大流
}
int main(){
	scanf("%d%d",&n,&m);s=n*m+1,t=n*m+2;
	for(int i=1;i<=n;++i){
		for(int j=1,w;j<=m;++j){
			bool ok=0;
			scanf("%d",&w);
			sum+=w;//总和
			int k=getnum(i,j);
            //构造二分图
			if((i+j)%2) add(s,k,w),ok=1;//一个集连向源点
			else add(k,t,w);//另一个集连向汇点
			if(ok){
				for(int q=0;q<4;++q){
					int ex=i+dx[q],ey=j+dy[q];
					if(check(ex,ey)){
						int p=getnum(ex,ey);
						if((ex+ey)%2) swap(k,p);
						add(k,p,INF);//相邻点连边，注意顺序啊！
					}
				}	
			}
		}
	}
	int ans=sum-HLPP();//我使用的是HLPP预留推进来做这个题的，没学过的请右转板子题P4722
	printf("%d\n",ans);
	return 0;
}
```
## 初学HLPP，板子不好看，请各位巨佬神犇见谅。

# 谢谢大家！

---

## 作者：一扶苏一 (赞：0)

## Description

给定一个 $n~\times~m$ 的矩阵，每个位置有一个正整数，选择一些互不相邻的数，最大化权值和

## Limitation

$1~\leq~n,~m~\leq~100$

## Solution

由于数必须互不相邻，考虑二分图。

将矩阵染成二分图，相邻的格子连边，这样一条边的两个端点不能被同时选择，问题就被转化为了二分图上的最大带权独立集问题。

有关二分图的几个定理：

**二分图最小无权点覆盖 = 二分图最大匹配**

**二分图最小无权边覆盖 = 总点数 - 二分图最大匹配**

**二分图最大无权独立集 = 总点数 - 二分图最大匹配**

如果点带点 **正** 权，则源点向左部连边，容量为点权，右部向汇点连边，容量为点权，原边保留，容量无穷。

**二分图最小权点覆盖 = 最小割**

**二分图最大权独立集 = 点权和 - 最小割**

最小点权覆盖的证明与最大权闭合子图的证明类似，证明在[这里](https://www.cnblogs.com/yifusuyi/p/10544280.html)，最大权独立集的证明需要 最大独立集 = 全集 - 最小点覆盖 的引理。

于是这题跑一个最小割就可以解决了。

## Code

```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
#ifdef ONLINE_JUDGE
#define freopen(a, b, c)
#endif

typedef long long int ll;

namespace IPT {
  const int L = 1000000;
  char buf[L], *front=buf, *end=buf;
  char GetChar() {
    if (front == end) {
      end = buf + fread(front = buf, 1, L, stdin);
      if (front == end) return -1;
    }
    return *(front++);
  }
}

template <typename T>
inline void qr(T &x) {
  char ch = IPT::GetChar(), lst = ' ';
  while ((ch > '9') || (ch < '0')) lst = ch, ch=IPT::GetChar();
  while ((ch >= '0') && (ch <= '9')) x = (x << 1) + (x << 3) + (ch ^ 48), ch = IPT::GetChar();
  if (lst == '-') x = -x;
}

namespace OPT {
  char buf[120];
}

template <typename T>
inline void qw(T x, const char aft, const bool pt) {
  if (x < 0) {x = -x, putchar('-');}
  int top=0;
  do {OPT::buf[++top] = static_cast<char>(x % 10 + '0');} while (x /= 10);
  while (top) putchar(OPT::buf[top--]);
  if (pt) putchar(aft);
}

const int maxn = 10010;
const int maxm = 105;
const int INF = 100000000;

struct Edge {
  int u, v, flow;
  Edge *nxt, *bk;

  Edge(const int _u, const int _v, const int _flow, Edge* &h) {
    this->u = _u; this->v = _v; this->flow = _flow; this->nxt = h; h = this;
  }
};
Edge *hd[maxn], *fir[maxn];
inline void cont(const int _u, const int _v, const int _flow) {
  auto u = new Edge(_u, _v, _flow, hd[_u]), v = new Edge(_v, _u, 0, hd[_v]);
  (u->bk = v)->bk = u;
}

int n, m, s, t, ans;
int MU[maxn], id[maxm][maxm], col[maxm][maxm], dist[maxn];
std::queue<int>Q;

bool bfs();
int dfs(const int u, int canag);
void link(const int x, const int y);

int main() {
  freopen("1.in", "r", stdin);
  qr(n); qr(m);
  for (int i = 1; i <= n; ++i) 
    for (int j = 1; j <= m; ++j) {
      qr(MU[id[i][j] = ++t]);
      ans += MU[t];
    }
  s = ++t; ++t;
  for (int i = 1; i <= n; ++i) {
    if ((col[i][1] = col[i - 1][1] ^ 1))
      link(i, 1);
    else 
      cont(id[i][1], t, MU[id[i][1]]);
    for (int j = 2; j <= m; ++j) 
      if ((col[i][j] = col[i][j - 1] ^ 1))
        link(i, j);
      else
        cont(id[i][j], t, MU[id[i][j]]);
  }

  while (bfs()) {
    for (int i = 1; i <= t; ++i) fir[i] = hd[i];
    ans -= dfs(s, INF);
  }

  qw(ans, '\n', true);
  return 0;
}

bool bfs() {
  memset(dist, 0, sizeof dist);
  Q.push(s); dist[s] = 1;
  while (!Q.empty()) {
    int u = Q.front(); Q.pop();
    for (auto e = hd[u]; e; e = e->nxt) if (e->flow > 0) {
      int v = e->v;
      if (dist[v]) continue;
      dist[v] = dist[u] + 1;
      Q.push(v);
    }
  }
  return dist[t];
}

int dfs(const int u, int canag) {
  if ((u == t) || (!canag)) return canag;
  int _f = 0;
  for (auto &e = fir[u]; e; e = e->nxt) if (e->flow > 0) {
    int v = e->v;
    if (dist[v] != (dist[u] + 1)) continue;
    int f = dfs(v, std::min(canag, e->flow));
    e->flow -= f; e->bk->flow += f; _f += f;
    if (!(canag -= f)) break;
  }
  return _f;
}

void link(const int x, const int y) {
  int u = id[x][y];
  cont(s, u, MU[u]);
  if (x > 1) cont(u, id[x - 1][y], INF);
  if (y < m) cont(u, id[x][y + 1], INF);
  if (y > 1) cont(u, id[x][y - 1], INF);
  if (x < n) cont(u, id[x + 1][y], INF);
}
```

---

## 作者：Taduro (赞：0)

这题的二分图模型十分套路，是一道二分图带权最大独立集问题，有一个结论：二分图最大独立集=所有的点权-最小点覆盖数（用最少的点覆盖所有边）。

解释一下：因为所有的边已经被最小点覆盖点集中的点覆盖了，那么删掉这些点就是删掉所有边，剩下的点都是不联通且最大的。

而根据König定理，最小点覆盖=最大匹配。所以我们只要求最大匹配就好了。

（吐槽一下：这个定理网上证明并不多，而且许多证明都是用“显然”混过去了关键点，其他题解也没有说为什么是总点权-最小割，这里推荐[Matrix67的证明](http://www.matrix67.com/blog/archives/116#comment-4409)）

这样我们就把横纵坐标奇偶性相同的点放在二分图的一侧，对相邻的点连一条容量为无限的边，二分图两侧的点分别向源点和汇点连一条容量为点权的边，之后跑一边最小割即可。

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
struct node{
	int x,y,next,z;
}w[2000001];
int tail,m,deep[110][110],head[110][110],a[110][110];
int heap,n,team[10010][2],cnt,tim,sum,ans,o[110][110];
int dx[5]={0,-1,0,1,0},dy[5]={0,0,-1,0,1};
inline void add(int x1,int y1,int x2,int y2,int z){
	w[cnt].next=head[x1][y1];
	w[cnt].x=x2; w[cnt].y=y2;
	w[cnt].z=z; head[x1][y1]=cnt; cnt++;
}
inline bool bfs(){
	heap=tail=1; tim++; o[0][0]=tim;
	team[heap][0]=team[heap][1]=0;
	deep[0][0]=1;
	while (heap<=tail){
		int x=team[heap][0],y=team[heap][1];
		for (int i=head[x][y]; i!=-1; i=w[i].next){
			if (w[i].z&&o[w[i].x][w[i].y]!=tim){
				tail++; o[w[i].x][w[i].y]=tim;
				deep[w[i].x][w[i].y]=deep[x][y]+1;
				team[tail][0]=w[i].x; team[tail][1]=w[i].y;
			}
		}
		heap++;
	}
	return (o[n+1][m+1]==tim);
}
int dfs(int x,int y,int l){
	if ((!l)||(x==n+1&&y==m+1)) return l;
	int used=0,minn,z;
	for (int i=head[x][y]; i!=-1; i=w[i].next){
		if (deep[w[i].x][w[i].y]==deep[x][y]+1&&w[i].z){
			minn=min(l-used,w[i].z);
			z=dfs(w[i].x,w[i].y,minn);
			if (z){
				w[i].z-=z; w[i^1].z+=z;
				used+=z; if (used==l) break;
			}
		}
	}
	if (!used) deep[x][y]=0;
	return used;
}
int main(){
	scanf("%d%d",&n,&m);
	for (int i=1; i<=n; i++)
		for (int j=1; j<=m; j++){
			scanf("%d",&a[i][j]); sum+=a[i][j];
		}
	memset(head,-1,sizeof(head));
	for (int i=1; i<=n; i++)
		for (int j=1; j<=m; j++){
			if (i%2==j%2){
				add(0,0,i,j,a[i][j]);
				add(i,j,0,0,0);
				for (int k=1; k<=4; k++){
					if (i+dx[k]<=0||i+dx[k]>n) continue;
					if (j+dy[k]<=0||j+dy[k]>m) continue;
					add(i,j,i+dx[k],j+dy[k],1e9);
					add(i+dx[k],j+dy[k],i,j,0);
				}
			}
			else{
				add(i,j,n+1,m+1,a[i][j]);
				add(n+1,m+1,i,j,0);
			}
		}
	while (bfs()) ans+=dfs(0,0,1e9);
	printf("%d\n",sum-ans);
	return 0;
}
```

---

## 作者：Isonan (赞：0)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P2774)

这道题和[骑士共存问题](https://www.luogu.org/problemnew/show/P3355)基本没差，这是[P3355的题解](https://www.luogu.org/blog/PopulusEuphratica/luogup3355-qi-shi-gong-cun-wen-ti)

在这道题里，我们只要把边权从1改到num[i][j]就可以水过了。

代码如下：

```cpp
#include <cstdio>
#include <cstring>
#define min(X,Y) ((X)<(Y)?(X):(Y))

int num[101][101],head[20001],nxt[200001],b[200001],v[200001],k=1,n,m;
int p[20001],dis[20001],q[20001],h,t,S,T;
void push(int s,int t,int val){
	nxt[++k]=head[s];
	head[s]=k;
	b[k]=t;
	v[k]=val;
}
void link(int s,int t,int val){
	push(s,t,val);
	push(t,s,0);
}
bool bfs(){
	memset(dis,0,sizeof dis);
	dis[S]=1;
	h=t=0;
	q[++t]=S;
	while(h<t){
		++h;
		for(int i=head[q[h]];i;i=nxt[i])
			if(v[i]&&!dis[b[i]]){
				dis[b[i]]=dis[q[h]]+1;
				q[++t]=b[i];
				if(b[i]==T)return 1;
			}
	}
	return 0;
}
int dfs(int x,int flow){
	if(x==T||!flow)return flow;
	int used=0;
	for(int i=p[x];i;i=nxt[i])
		if(v[i]&&dis[b[i]]==dis[x]+1){
			int w=dfs(b[i],min(flow-used,v[i]));
			v[i]-=w;
			v[i^1]+=w;
			used+=w;
			if(w)p[x]=i;
			if(used==flow)return flow;
		}
	if(!used)dis[x]=0;
	return used;
}
void check(int a,int b,int c,int d){
	if(!c||!d)return;
	if(c>n||d>m)return;
	link((a-1)*m+b,(c-1)*m+d,0x7f7f7f7f);
}
int main(){
	scanf("%d%d",&n,&m);
	int ans=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&num[i][j]),ans+=num[i][j];
	S=0,T=n*m+1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(((i+j)&1)==1){
				link(S,(i-1)*m+j,num[i][j]);
				check(i,j,i-1,j);
				check(i,j,i+1,j);
				check(i,j,i,j-1);
				check(i,j,i,j+1);
			}
			else link((i-1)*m+j,T,num[i][j]);
	while(bfs()){
		memcpy(p,head,sizeof p);
		ans-=dfs(S,0x7f7f7f7f);
	}
	printf("%d\n",ans);
}
```

---


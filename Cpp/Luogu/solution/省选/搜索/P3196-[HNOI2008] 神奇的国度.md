# [HNOI2008] 神奇的国度

## 题目描述

K国是一个热衷三角形的国度,连人的交往也只喜欢三角原则.他们认为三角关系:即AB相互认识,BC相互认识,CA相互认识,是简洁高效的.为了巩固三角关系,K国禁止四边关系,五边关系等等的存在.

所谓N边关系,是指N个人 A1A2...An之间仅存在N对认识关系:(A1A2)(A2A3)...(AnA1),而没有其它认识关系.比如四边关系指ABCD四个人 AB,BC,CD,DA相互认识,而AC,BD不认识.全民比赛时,为了防止做弊，规定任意一对相互认识的人不得在一队，国王相知道，最少可以分多少支队。


## 说明/提示

一种方案(1,3)(2)(4)


## 样例 #1

### 输入

```
4 5
1 2
1 4
2 4
2 3
3 4```

### 输出

```
3```

# 题解

## 作者：kczno1 (赞：7)

求弦图点色数。

考虑按完美消除序列从后往前，每个点贪心选择最小可染颜色，

那么他会产生的颜色种类<=所在团大小，

而一个团由于两两连边，每个点颜色都不同，所以产生的颜色种类>=团的大小，

所以弦图点色数就是弦图最大团的大小。

得到完美消除序列用最大势算法，每次选择与最多已选择点相连的点，

由于每次势最多+1,可以对每个值开个双向链表存势为该值的点，可以做到O(1)删除插入，

这样时间就是线性。

之后判断弦图就从后往前扫，检验x与相连的后面的点N(x)是否构成一个团，

就是先找到N(x)里最小的，之后检验他与N(x)其他点是否相连( 用hash表，bitset(压空间)存都是O(1)的 )，

如果不相连显然就不是团，如果相连，由于在他检验的时候已经保证N(x)是个团，那么加入一个和所有点都有连边的点显然还是一个团。

这样每条边只被枚举一次，也是线性的。

(当然这题不需要判断)

```cpp
#include<cstdio> 

#define N 10010
#define M 1000100
int n,m,i,x,y,k;
int t[N];
struct edge
{
    int to,next;
}l[M<<1];int e;
void add_e(int x,int y)
{
    l[++e]=(edge){y,t[x]};t[x]=e;
}

int next[N<<1],pre[N<<1];
int w[N],q[N],dy[N];

void push(int x)
{
    pre[next[x]=next[N+w[x]]]=x;
    next[pre[x]=N+w[x]]=x;
}
void del(int x)
{
    pre[next[x]]=pre[x];next[pre[x]]=next[x];
}

int main()
{
    freopen("1.in","r",stdin);
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;++i)
    {
        scanf("%d%d",&x,&y);
        add_e(x,y);add_e(y,x); 
    }
    for(i=1;i<=n;++i) push(i);
    int now=0,ans=0;
    for(k=n;k;--k,++now)
    {
        while(!next[N+now])--now;
        x=next[N+now];
        del(x);
        q[k]=x;dy[x]=k;
        int sum=1;
        for(i=t[x];y=l[i].to;i=l[i].next)
        if(!dy[y]) 
        {
            del(y);
            ++w[y];
            push(y);
        }
        else ++sum;
        if(sum>ans)ans=sum;
    }
    printf("%d\n",ans);
}
```

---

## 作者：pengrui (赞：2)

**标签：** 弦图

有关弦图的定义与mcs算法请自学（模板）

题意为求弦图的色数$\chi(G)$

**做法：**

最优染色构造：将完美消除序列从后往前依次给每个点染色，给每个点染上可染的最小颜色

证明：

设以上方法用$col$个颜色，原图团数为$\omega(G)$

引理：$\omega(G) \leq \chi(G)$

引理证明：对最大团的导出子图染色，至少需要$\omega(G)$种颜色（因为团中每个点都相邻，每个点都需用不同的颜色）

设$col \geq \chi(G)$

团上每个点都不同$\rightarrow col = \omega(G)$

由引理：$col = \omega(G) \leq \chi(G)$，$col \geq \chi(G)$

$\therefore t = \omega(G) =\chi(G) $

$ans = max\{|\{x\} + N(x)|\} = max\{lab_i\} + 1$

**代码：** 要开O2优化

```cpp
#include <iostream>
#include <cstdio>

using namespace std;

const int N = 1e4 + 1;

int n, m, u, v, lab[N], p[N];
bool c[N][N], vis[N];

inline void mcs()
{
	for (int i = n; i >= 1; --i)	
	{
		u = 0;
		for (int j = 1; j <= n; ++j)
			if (!vis[j] && (!u || lab[j] > lab[u]))
				u = j;
		vis[u] = 1;
		p[i] = u;
		for (int j = 1; j <= n; ++j)
			if (!vis[j] && c[u][j])
				++lab[j];
	}		
}

int main()
{
	ios::sync_with_stdio(false);
	cin >> n >> m;
	for (int i = 1; i <= m; ++i)	
	{
		cin >> u >> v;
		c[u][v] = c[v][u] = 1;
	}
	mcs();
	int ans = 0;
	for (int i = 1; i <= n; ++i)
		ans = max(ans, lab[i] + 1);
	cout << ans << endl;
	return 0;
}
```



---

## 作者：zhangjiacheng (赞：2)

## 主要思路：
col[i]表示点i不能用的顏色数。
找所有没有便利过的点当中最大的col值的点。
从一个店触发，相邻并且没有便利过的点的col加一
重复n次，max(col[i]+1)就是答案。这里的答案可以在循环中直接维护掉。
找最大col值的点这部分不知道有没能用最大堆代替的方法，那样复杂度会降很多，但似乎又不好维护。
主要思路就是这样。


---

## 作者：Tgotp (赞：1)

思路：弦图

算法：mcs，邻接表

具体实现：逆序寻找完美消除序列，然后染成能染的最小颜色，证明参见cdq的弦图与区间课件。

c++代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
inline void read(int&x)
{
    x = 0;char c; int sign = 1;
    do{ c = getchar(); if(c == '-') sign = -1;}while(c < '0' ||c > '9');
    do{ x = x * 10 + c - '0'; c = getchar(); }while(c <= '9' && c >= '0');
    x *= sign;
}
const int maxn = 1e4 + 1,maxm = 1e6 + 1; 
int ans,n,m,tot,head[maxn],he[maxn],h[maxn];
bool k[maxn],mark[maxn][1000];
struct node{ int to,next; }edge[maxm*4];
inline void add(int head[],int u,int v)
{
    edge[tot].next = head[u];
    edge[tot].to = v;
    head[u] = tot++;
}
inline void mcs()
{
    for(int i = 1;i <= n;i++) add(he,0,i);
    int best = 0;
    for(int i = 1;i <= n;i++) while(1)
    {
        int i,color;
        for(i = he[best]; ~i ;i = edge[i].next){ node &e = edge[i]; if(!k[e.to]) break; }
        if(~i)
        {
            int x = edge[i].to;k[x] = true;
            for(i = 1;i;i++) if(!mark[x][i]) { color = i,mark[x][i] = true; ans = max(i,ans);break; }
            for(i = head[x];~i; i = edge[i].next){
                node &e = edge[i];
                if(k[e.to]) continue;
                mark[e.to][color] = true ;h[e.to]++; add(he,h[e.to],e.to);
                best = max(best,h[e.to]);
            }
            break;
        }
        else best--;
    }
}
int main()
{
    memset(head,-1,sizeof(head));
    memset(he,-1,sizeof(he));
    read(n);read(m);
    for(int i = 1;i <= m;i++){
        int u ,v; read(u),read(v);
        add(head,u,v);add(head,v,u);
    }
    mcs();
    cout<<ans;
    return 0;
}
推广一下blog ： <http://tgotp.science>
```

---

## 作者：花样百出 (赞：1)

题解:

详细说明请见cdq的论文--弦图和区间图

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<queue>
#include<vector>
#include<stack>
#define MAXN 1000010
#define RG register
#define LL long long int
using namespace std;
const int INF=1e9;
const int mod=31011;
struct node{
  int next;
  int to;
}t[MAXN*2];
int head[MAXN*2],num;
int n,m;
int ans;
int du[MAXN],vis[MAXN],q[MAXN];
int col[MAXN],used[MAXN];
void add(int from,int to)
{
  t[++num].next=head[from];
  t[num].to=to;
  head[from]=num;
}
int main()
{
  freopen("1.in","r",stdin);
  scanf("%d%d",&n,&m);int x,y;
  for(int i=1;i<=m;i++){
    scanf("%d%d",&x,&y);add(x,y);add(y,x);
  }
  for(int i=n;i>=1;i--){
    int p=0;
    for(int j=1;j<=n;j++) if(!vis[j] && du[j]>=du[p]) p=j;
    q[i]=p;vis[p]=1;
    for(int j=head[p];j;j=t[j].next) du[t[j].to]++;
  }
  for(int i=n;i>=1;i--){
    int p=q[i];
    for(int j=head[p];j;j=t[j].next) used[col[t[j].to]]=p;
    int j;
    for(j=1;;j++) if(used[j]!=p) break;
    col[p]=j;if(j>ans) ans=j;
  }
  printf("%d\n",ans);
  return 0;
}

```

---

## 作者：Nuisdete (赞：0)

题目要求的是弦图的色数。

首先设 $N(x)$ 表示在完美消除序列中在 $x$ 后面且和 $x$ 关联的点的集合，那么最大团大小就是 $\max_{u \in V}{|N(u)|} + 1$。这个证明可以参考其它资料。

下界显然是最大团大小，考虑构造一组方案取到下界。

按照完美消除序列从后往前贪心染色就可以取到下界，具体证明大概就是染 $u$ 这个点的时候，影响它颜色的只是染过色且与它关联的点，不难发现这些点就是 $N(u)$，那么色数显然也就是上面的那个最大团的式子了。

求 $|N(u)|$ 用 `mcs` 算法就行了。

```cpp
# include <cstdio>
# include <vector>
# include <algorithm>

using std::max;

const int MAXN = 1e4 + 5;

int n, m;

int deg[MAXN << 1];
bool vis[MAXN << 1];

std::vector<int> G[MAXN << 1], vec[MAXN << 1];

void mcs() {
  int p = 0;
  for (int i = 1; i <= n; ++i) 
    vec[0].push_back(i);
  
  for (int i = 1; i <= n; ++i) {
    int cur = 0;
    while (!cur) {
      while (!vec[p].empty() && vis[ vec[p].back() ])
        vec[p].pop_back();
      
      if (vec[p].empty()) --p;
      else cur = vec[p].back();
    }
    vis[cur] = true;
    for (int k : G[cur]) if (!vis[k]) {
      ++deg[k];
      if (deg[k] > p) ++p;
      vec[ deg[k] ].push_back(k);
    }
  }
}

int main() {

  scanf("%d %d", &n, &m);
  for (int i = 1; i <= m; ++i) {
    int x, y;
    scanf("%d %d", &x, &y);
    G[x].push_back(y), G[y].push_back(x);
  }
  mcs();
  int ans = 0;
  for (int i = 1; i <= n; ++i)
    ans = max(ans, deg[i] + 1);
  
  printf("%d\n", ans);

  return 0;
}
```


---

## 作者：JiaY19 (赞：0)

裸题。

### 思路

设图 $G$ 的最小染色数 $f(G)$，最大团 $g(G)$，则 $f(G)=g(G)$。

证明：

由于对于一个完全图所有的颜色都应该不同，所以 $f(G)\ge g(G)$。

而对于一个弦图来说，我们按照完美消除序列倒序染色，设染色数为 $w$。

则有 $w\ge f(G)$。

而显然对于一个点而言，与它有限制的仅有已经染色并且与它有连边的点。

所以 $w=g(G)$。

所以 $w=g(G)=f(G)$。

至此，便可以线性求出最小染色数与最大团。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

// #define int long long
#define fro(i, x, y) for (int i = (x); i <= (y);i++)
#define pre(i, x, y) for (int i = (x); i >= (y);i--)

const int N = 1000010;

int n, m, cnt, rk[N], id[N], lb[N], head[N];
vector<int> to[N];

struct edge
{
    int to, nxt;
} e[N * 2];

inline void add(int x, int y)
{
    e[++cnt] = {y, head[x]}, head[x] = cnt;
    e[++cnt] = {x, head[y]}, head[y] = cnt;
}

inline void cl(vector<int> &x)
{
    vector<int> y;
    x.swap(y);
}

inline void mcs()
{
    fro(i, 0, n) cl(to[i]);
    fro(i, 1, n) to[0].push_back(i);
    int sum = 0;
    pre(pos, n, 1)
    {
        int x = 0, y;
        while (!x)
        {
            while (to[sum].empty() == 0 && !x)
            {
                y = to[sum].back();
                if (!rk[y] && lb[y] == sum) x = y;
                to[sum].pop_back();
            }
            if(!x) sum--;
        }
        rk[x] = pos, id[pos] = x;
        for (int i = head[x]; i; i = e[i].nxt)
            lb[e[i].to]++, to[lb[e[i].to]].push_back(e[i].to), sum = max(sum, lb[e[i].to]);
    }
}

int main()
{
    ios::sync_with_stdio(false), cin.tie(0);
    int x, y, ans = 0; cin >> n >> m;
    fro(i, 1, m) cin >> x >> y, add(x, y);
    mcs();
    fro(i, 1, n)
    {
        x = id[i], y = 0;
        for (int j = head[x]; j; j = e[j].nxt)
            if (rk[e[j].to] > i) y++;
        ans = max(ans, y + 1);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Prev1ous (赞：0)

今天说开始补题解就想到好久之前写过的这个了。

——————————————直接就复制当时的写法了哦———————————————

先给大家普及一下弦图（连接环上俩个不相邻节点的边称为弦）和mcs算法（最小染色数=最大完全子图）的概念（会的可以直接跳代码）。

没错这题就是弦图最小涂色，直接一遍mcs就搞定了（仿佛没说一样。

将弦图分成多组的问题可以看做给弦图上的点染色且两个有直接边相连的点不能同色，这样就转化成了弦图的最小染色问题。

优先队列可以实现O(nlogn+m)的复杂度，其实还是很慢，我做这个题好几次T（真悲伤。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cctype>
#include<queue>
#define rg register
using namespace std;
inline int read(){
    rg int s=0,f=0;
    rg char ch=getchar();
    while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
    while(isdigit(ch)) s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
    return f?-s:s;
}
int n,m,cnt=-1;
const int MAX=2000015;
int head[MAX];
bool vis[MAX],used[MAX];
int seq[MAX],label[MAX],color[MAX];
struct edge{
    int nxt;
    int to;
}e[MAX];
void add(int u,int v){
    e[++cnt].nxt=head[u];
    e[cnt].to=v;
    head[u]=cnt;
}
typedef pair<int,int>p;
priority_queue<p>q;
void mcs(){
    for(rg int i=1;i<=n;++i) q.push(p(0,i));
    for(rg int i=n;i>=1;--i){
        while(vis[q.top().second]) q.pop();
        int u=q.top().second;
        q.pop();
        seq[i]=u;
        vis[u]=1;
        for(rg int i=head[u];~i;i=e[i].nxt){
            if(!vis[e[i].to]) q.push(p(++label[e[i].to],e[i].to));
        }
    }
}
int solve(){
    int res=0;
    for(rg int i=n;i>=1;--i){
        memset(used,0,sizeof(used));
        for(rg int j=head[seq[i]];~j;j=e[j].nxt){
            used[color[e[j].to]]=1;
        }
        for(color[seq[i]]=1;used[color[seq[i]]];++color[seq[i]]);
        res=max(res,color[seq[i]]);
    }
    return res;
}
int main(){
    memset(head,-1,sizeof(head));
    n=read(),m=read();
    for(rg int i=1;i<=m;++i){
        int u=read(),v=read();
        add(u,v);
        add(v,u);
    }
    mcs();
    printf("%d\n",solve());
    return 0;
}
```


---

## 作者：WAMonster (赞：0)

做法：观察题意，发现题目所给的关系可看做一个弦图（具体见[cdq论文](https://wenku.baidu.com/view/07f4be196c175f0e7cd13784.html)），分成若干组的问题可以看做给弦图上的点染成不同的颜色，而且两个有直接边相连的点不能同色，这样就转化成了弦图的最小染色问题，用最大势算法解决，最终答案为所有点最大“势”+1。

看一眼题解发现都是链表$O(n+m)$、暴力$O(n^2+m)$的最大势做法，我就苟一个用优先队列实现的$O(n \log n+m)$的劣质算法吧（不过好像可以卡到$O(n^2+m)$，跑的贼慢要开O2）

code：

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <utility>
#include <queue>
using namespace std;
#define maxn 10005
#define maxm 2000007
#define P make_pair
#define pii pair<int, int>
struct edge {
	int to, next;
} e[maxm];
int n, m, vis[maxn], val[maxn], head[maxn], ans, ecnt;
void adde(int u, int v) {
	e[++ecnt] = (edge) {v, head[u]};
	head[u] = ecnt;
}
priority_queue<pii> p;
#define isdigit(x) ((x) >= '0' && (x) <= '9')
inline int read() {
	int res = 0;
	char c = getchar();
	while (!isdigit(c)) c = getchar();
	while (isdigit(c)) res = (res << 1) + (res << 3) + (c ^ 48), c = getchar();
	return res;
}
int main() {
	n = read(), m = read();
	for (int i = 1; i <= m; ++i) {
		int u = read(), v = read();
		adde(u, v);
		adde(v, u);
	}
	for (int i = 1; i <= n; ++i) p.push(P(0, i));
	for (int i = 1; i <= n; ++i) {
		while (vis[p.top().second]) p.pop();
		pii a = p.top();
		p.pop();
		vis[a.second] = 1;
		for (int j = head[a.second]; j; j = e[j].next) {
			int to = e[j].to;
			if (!vis[to]) ++val[to], p.push(P(val[to], to)); 
		}
	}
	for (int i = 1; i <= n; ++i) ans = max(ans, val[i]);
	printf("%d\n", ans + 1); 
}
```

---


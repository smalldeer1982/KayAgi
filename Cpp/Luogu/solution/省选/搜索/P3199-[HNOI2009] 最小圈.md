# [HNOI2009] 最小圈

## 题目描述

考虑带权有向图 $G=(V,E)$ 以及 $w:E\rightarrow \R$，每条边 $e=(i,j)$（$i\neq j$，$i, j\in V$）的权值定义为 $w_{i,j}$。设 $n=|V|$。

$c=(c_1,c_2,\cdots,c_k)$（$c_i\in V$）是 $G$ 中的一个圈当且仅当 $(c_i,c_{i+1})$（$1\le i<k$）和 $(c_k,c_1)$ 都在 $E$ 中。称 $k$ 为圈 $c$ 的长度，同时记 $c_{k+1}=c_1$，并定义圈 $c=(c_1,c_2,\cdots,c_k)$ 的平均值为
$$
\mu(c)= \frac 1 k \sum\limits_{i=1}^{k} w_{c_i,c_{i+1}}
$$
即 $c$ 上所有边的权值的平均值。设 $\mu'(G)=\min_c\mu(c)$ 为 $G$ 中所有圈 $c$ 的平均值的最小值。

给定图 $G=(V,E)$ 以及 $w:E\rightarrow \R$，求出 $G$ 中所有圈 $c$ 的平均值的最小值 $\mu'(G)$。


## 说明/提示

对于 $100\%$ 的数据，$2\leq n\le 3000$，$1\leq m\le 10000$，$|w_{i,j}| \le 10^7$，$1\leq i, j\leq n$ 且 $i\neq j$。

------------
提示：本题存在 $O(nm)$ 的做法，但是 $O(nm\log n)$ 的做法也可以通过。

## 样例 #1

### 输入

```
4 5
1 2 5
2 3 5
3 1 5
2 4 3
4 1 3```

### 输出

```
3.66666667```

## 样例 #2

### 输入

```
2 2
1 2 -2.9
2 1 -3.1```

### 输出

```
-3.00000000```

# 题解

## 作者：_rqy (赞：95)

对于这个东西，有一个结论（Karp1977年的论文）：

我们新建一个节点，从它到每个点连一条权值任意的边（比如都是0），再令$F_j(i)$表示从新建的点到$i$点恰好经过$j$条边的最短路，那么有

$$ans=\min_{1\leq i\leq n, F_{n+1}(i)\neq\infty}\max_{j=1}^{n}\left[\frac{F_{n+1}(v)-F_k(v)}{n+1-k}\right]$$

具体证明请看[我的博客](http://www.cnblogs.com/y-clever/p/7043553.html)

虽然代码不是跑的最快的但是理论复杂度低（没办法，数据不卡SPFA），是$O(nm)$的（而且代码也是最短的，只有0.71KB，不比Dijkstra难写）

```cpp
#include <algorithm>
#include <cstdio>
const int N = 3050;
const int M = 10050;
const double INF = 1e12;
double F[N][N], w[M];
int u[M], v[M];
int main() {
  int n, m, i, j;
  scanf("%d%d", &n, &m);
  for (i = 0; i < m; ++i)
    scanf("%d%d%lf", &u[i], &v[i], &w[i]);
  for (i = 0; i <= n; ++i)
    for (j = 1; j <= n; ++j)
      F[i][j] = i ? INF : 0;
  for (i = 0; i < n; ++i)
    for (j = 0; j < m; ++j)
      F[i + 1][v[j]] = std::min(F[i + 1][v[j]], F[i][u[j]] + w[j]);
  double ans = 1e7, ans1;
  for (i = 1; i <= n; ++i) if (F[n][i] < 1e11) {
    ans1 = -INF;
    for (j = 0; j < n; ++j)
      ans1 = std::max(ans1, (F[n][i] - F[j][i]) / (n - j));
    ans = std::min(ans, ans1);
  }
  printf("%.8lf\n", ans);
  return 0;
}

```
下面还有一个空间复杂度极低（70MB->1.9MB），稍长一点（0.71KB->0.98KB），稍慢一点（3936ms->4468ms）的实现，算了两遍，滚动数组（实际上，上面的代码在BZOJ上MLE，因为BZOJ这题空间64M）

```cpp
#include <algorithm>
#include <cstdio>
const int N = 3050;
const int M = 10050;
const double INF = 1e12;
double _F[2][N], Fn[N], w[M], maxv[N];
int u[M], v[M];
int main() {
  int n, m, i, j;
  scanf("%d%d", &n, &m);
  for (i = 0; i < m; ++i)
    scanf("%d%d%lf", &u[i], &v[i], &w[i]);
  double *F = _F[0], *G = _F[1];
  for (i = 1; i <= n; ++i)
    G[i] = 0;
  for (i = 0; i < n; ++i, std::swap(F, G)) {
    for (j = 1; j <= n; ++j) F[j] = INF;
    for (j = 0; j < m; ++j)
      F[v[j]] = std::min(F[v[j]], G[u[j]] + w[j]);
  }
  for (i = 1; i <= n; ++i) Fn[i] = G[i];
  double ans = 1e7;
  for (i = 1; i <= n; ++i)
    maxv[i] = Fn[i] / n, G[i] = 0;
  for (i = 0; i < n; ++i, std::swap(F, G)) {
    for (j = 1; j <= n; ++j) F[j] = INF;
    for (j = 0; j < m; ++j)
      F[v[j]] = std::min(F[v[j]], G[u[j]] + w[j]);
    for (j = 1; j <= n; ++j) maxv[j] = std::max(maxv[j], (Fn[j] - F[j]) / (n - i - 1));
  }
  for (i = 1; i <= n; ++i) if (Fn[i] < 1e11) ans = std::min(ans, maxv[i]);
  printf("%.8lf\n", ans);
  return 0;
}
```

---

## 作者：niiick (赞：36)

题目说的通俗点就是，
在图中找一个环，使得环上边权之和除以节点个数最小，求这个最小平均值

也算比较裸的0/1分数规划了，和POJ - 3621 Sightseeing Cows有点像

为方便描述，记环$S=(\{v_i\},\{e_i\})$，
其中$\{v_i\}$为环上结点的集合，$\{e_i\}$为环上的边的集合
记每条边边权为$a[e_i]$,每个节点点权$b[v_i]$
并令**所有点权为1**

这样我们就得到了一个0/1分数规划模型
###[0/1分数规划 详解](https://blog.csdn.net/niiick/article/details/80925267)

二分一个mid然后判定图上**是否存在一个环S**

使得$\frac{\sum_{i=1}^ta[e_i]}{\sum_{i=1}^tb[v_i]}<mid$

即该环是否满足$\sum_{i=1}^t(a[e_i]-mid*b[v_i])<0$

因为$b[v_i]=1$,所以再化简得$\sum_{i=1}^t(a[e_i]-mid)<0$

这样我们就把问题转化成了判定图中**是否存在负环**

我们把每条边得边权看作$a[e_i]-mid$，
然后在图上判负环，若有负环则$R=mid$，否则$L=mid$，
直到达到精度要求
***************

```
#include<iostream>
#include<map>
#include<algorithm>
#include<queue>
#include<cstring>
#include<cstdio>
using namespace std;
typedef double dd;
 
int read()
{
    int f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}
 
const int maxn=3010;
int n,m;
int a[maxn];
struct node{int v,nxt; dd dis;}E[20010];
int head[maxn],tot;
int vis[maxn],judge;
dd d[maxn]; 
 
void add(int u,int v,dd dis)
{
    E[++tot].nxt=head[u];
    E[tot].v=v; E[tot].dis=dis;
    head[u]=tot;
}
 
void check(int u,dd x)
{
    vis[u]=1;
    for(int i=head[u];i;i=E[i].nxt)
    {
        int v=E[i].v; dd dis=E[i].dis;
        if(d[v]>d[u]+dis-x)//边权a[e_i]-mid
        {
            if(vis[v]||judge){judge=1;break;}
            d[v]=d[u]+dis-x;
            check(v,x);
        }
    }
    vis[u]=0;
}
 
int main()
{
    n=read();m=read();
    for(int i=1;i<=m;++i)
    {
        int u=read(),v=read();
        dd dis; scanf("%lf",&dis);
        add(u,v,dis);
    }
    dd L=-1e6,R=1e6,mid;
    while(R-L>1e-10)
    {
        mid=(L+R)/2;
        memset(d,0,sizeof(d)); judge=0;
        memset(vis,0,sizeof(vis));
        for(int i=1;i<=n;++i)
        {
            check(i,mid);
            if(judge) break;
        }
        if(judge)R=mid;
        else L=mid;
    }
    printf("%.8lf",L);
    return 0;
}
```

---

## 作者：VenusM1nT (赞：13)

负环 + 分数规划。这道题的做法和 [`P3288 [SCOI2014]方伯伯运椰子`](https://www.luogu.org/problemnew/show/P3199) 比较相似，所以做着比较快。我们依然要求最小的 $C=\frac{\sum_{i=1}^{k}a'[i]}{\sum_{i=1}^{k}b'[i]}, b[i]=1$，也就是最优比率环，可以得到一个分数规划模型，化一下可以得到 $\sum_{i=1}^{k}a'[i]-C\sum_{i=1}^{k}b'[i]=0$，因为 $b'[i]=1$，得到 $\sum_{i=1}^{k}a'[i]-C=0$，所以我们将所有边权 $-C$，最后判一下是否有负环即可。

本文同步发表于笔者的博客：[题解 P3199 [HNOI2009]最小圈](https://venusnero.github.io/2019/01/25/solution_p3199/)

```cpp
#include<bits/stdc++.h>
#define MAXN 3005
#define MAXM 10005
#define eps 1e-12
using namespace std;
int cnt,fst[MAXN],nxt[MAXM],to[MAXM];
int n,m;
double dis[MAXN],w[MAXM];
bool vis[MAXN];
void AddEdge(int u,int v,double c)
{
	to[++cnt]=v;
	nxt[cnt]=fst[u];
	fst[u]=cnt;
	w[cnt]=c;
}
bool Spfa(int u,double mid)
{
	vis[u]=1;
	for(int i=fst[u];i;i=nxt[i])
	{
		int v=to[i];
		if(dis[v]>dis[u]+w[i]-mid)
		{
			dis[v]=dis[u]+w[i]-mid;
			if(vis[v] || Spfa(v,mid)) return 1;
		}
	}
	vis[u]=0;
	return 0;
}
bool Check(double mid)
{
	for(int i=1;i<=n;i++) dis[i]=0;
	memset(vis,0,sizeof(vis));
	for(int i=1;i<=n;i++) if(Spfa(i,mid)) return 1;
	return 0;
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x,y;
		double z;
		scanf("%d %d %lf",&x,&y,&z);
		AddEdge(x,y,z);
	}
	double l=-1e7,r=1e7;
	while(r-l>eps)
	{
		double mid=(l+r)/2.0;
		if(Check(mid)) r=mid;
		else l=mid;
	}
	printf("%.8lf\n",r);
	return 0;
}
```

---

## 作者：米奇奇米 (赞：6)

## 一道坑啦我很久很久的好题！
### 主要用到的算法与思想：$01$分数规划$+spfa$判环$+$玄学减枝
### 对于$01$分数规划不清楚的右拐先去学习一下：[P1570 KC喝咖啡](https://www.luogu.org/problemnew/show/P1570)
### 懂得啦什么是分数规划后这道题目就变得很简单啦，你会判负环吗？什么方法都可以的，如果你真的不会判负环右拐[P3385 【模板】负环](https://www.luogu.org/problemnew/show/P3385)
### 当你掌握啦以上两种前置知识后这道题目就是一题裸奔在分钟的省选题啦
### 我们先来看一下判负环的代码（在判断负环的过程中一个玄学的剪条，就是当你做到了一定的次数后可以$return$了，我是当$(num[u]>25$ 或者 $num[v]>25)$时结束$spfa$
```cpp
inline bool spfa(double x)
{
	queue<int>q;
	for ( register int i=1;i<=n;i++ ) dis[i]=123456789;
	memset(vis,0,sizeof(vis));
	memset(num,0,sizeof(num));
	q.push(1);
	vis[1]=1;
	dis[1]=0;//初始化
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=0;
		if(num[u]>25) return true;//做到一定的次数结束循环
		for ( register int i=head[u];i;i=e[i].nex )
		{
			int v=e[i].to;
			if(dis[v]>dis[u]+e[i].w-x)
			{
				dis[v]=dis[u]+e[i].w-x;//01分数规划+spfa
				if(!vis[v])
				{
				    q.push(v);
					vis[v]=1;
					num[v]++;
					if(num[v]>=25) return true;//做到一定的次数结束循环（判环）
				}
			}
		}
	}
	return false;
}
```
### 完整的代码就不放啦，只要加个二分就撒花啦！二分时只有当$r-l<=eps(1e-8)$时$break$掉（总之就是要注意精度问题）！！、

### 总结：其实这道题目只要掌握$01$分数规划$+spfa$判环就可以水过这道题目，与这道题目相类似的还有不少，都是运用这种思想，比如：
#### [P1768 天路](https://www.luogu.org/problemnew/show/P1768)
#### [P2868 观光奶牛Sightseeing Cows](https://www.luogu.org/recordnew/show/19467871)
### 最后[戳这里](https://www.luogu.org/team/show?teamid=15177)到此一游


---

## 作者：crashed (赞：5)

&emsp;&emsp;感谢 18Michael 的指正，二分的精度边界有点问题，已更正。
# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P3199)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经典的最小平均值问题，不难想到二分答案。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二分出来答案$v$之后，对于每一条边$(u,v)$，它的新边权就是$w_{u,v}-v$。一个环的$\mu$就是$\frac {\sum_{i=1}^k (w_{c_i,c_{i+1}}-v)} k=\frac{\sum_{i=1}^k (w_{c_i,c_{i+1}})} k -v$。考虑原图中如果现在还存在一个负环，就说明这个图中存在一个$\mu<0$的环。我们就知道了下一步二分的范围。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何判负环？你当然可以用$SPFA$。这里建议使用$DFS$版本而不是$BFS$版本。理论时间是$O(nm\log_{2}V)$（$V$是值域），但是由于$DFS+SPFA$的高效，实际运行完全不会超时。  
# 代码
```cpp
#include <queue>
#include <cstdio>
using namespace std;

typedef long long LL;

const double INF = 1e7, eps = 1e-10;
const double inf = 0x3f3f3f3f3f3f3f3f;
const int MAXN = 3005, MAXM = 10005;

template<typename _T>
void read( _T &x )
{
    x = 0;char s = getchar();int f = 1;
    while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
    while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
    x *= f;
}

template<typename _T>
void write( _T x )
{
    if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
    if( 9 < x ){ write( x / 10 ); }
    putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
    return a < b ? a : b;
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
    return a > b ? a : b;
}

struct edge
{
    int to, nxt; double w;
}Graph[MAXM];

queue<int> q;

double dist[MAXN];
int head[MAXN];
int N, M, cnt, S;
bool inSta[MAXN];

void addEdge( const int from, const int to, const double w = 0 )
{
    cnt ++;
    Graph[cnt].w = w, Graph[cnt].to = to, Graph[cnt].nxt = head[from];
    head[from] = cnt;
}

bool SPFA( const int u, const double negt )
{
    double w;
    inSta[u] = true;
    for( int i = head[u], v ; i ; i = Graph[i].nxt )
    {
        v = Graph[i].to, w = Graph[i].w;
        if( dist[v] > dist[u] + w - negt )
        {
            dist[v] = dist[u] + w - negt;
            if( inSta[v] || SPFA( v, negt ) ) return true;
        }
    }
    inSta[u] = false;
    return false;
}

bool chk( const double val )
{
    for( int i = 1 ; i <= N ; i ++ ) dist[i] = 0, inSta[i] = 0;
    for( int i = 1 ; i <= N ; i ++ )
        if( SPFA( i, val ) ) return true;
    return false;
}

int main()
{
    double l = 0, r = 0, mid, w;
    read( N ), read( M );
    for( int i = 1, u, v ; i <= M ; i ++ ) 
        scanf( "%d %d %lf", &u, &v, &w ), 
        l = MIN( l, l + w ), r = MAX( r, r + w ), addEdge( v, u, w );
    while( r - l > eps )
    {
        mid = ( l + r ) / 2;
        if( chk( mid ) ) r = mid;
        else l = mid;
    }
    printf( "%.8f\n", l );
    return 0;
}
```

---

## 作者：s_r_f (赞：4)

Karp 算法。  
至于图不联通的问题，  
可以参照[rqy神犇的blog](http://www.cnblogs.com/y-clever/p/7043553.html),   
添加一个新点和n条边再DP。  
O(nm)，要卡卡常，不然过不去。

代码很短，很好写。
```cpp
#include <bits/stdc++.h>
#define db double
using namespace std;
inline int read(){
    int x = 0,f = 1; char c = getchar();
    while (c != EOF && !isdigit(c)) {if (c == '-') f = -1;c = getchar();}
    while (c != EOF && isdigit(c)) {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}
const int N = 3050,M = 10050 + N;
const db INF = 1e11;
int n,m,u[M],v[M]; db w[M];
db F[N],G[N],Fn[N],Mx[N],ans;
int main(){
	register int i,j;
	n = read(),m = read();
	for (i = 1; i <= m; ++i) scanf("%d%d%lf",&u[i],&v[i],&w[i]);
	++n;
	for (i = 1; i < n; ++i) ++m,u[m] = n,v[m] = i,w[m] = 0;
	
	for (i = 1; i < n; ++i) F[i] = INF; F[n] = 0;
	for (i = 1; i <= n; ++i){
		for (j = 1; j <= n; ++j) G[j] = INF;
		for (j = 1; j <= m; ++j) G[v[j]] = min(G[v[j]],F[u[j]] + w[j]);
		for (j = 1; j <= n; ++j) F[j] = G[j];
	}
	for (i = 1; i <= n; ++i) Fn[i] = F[i];
	
	for (i = 1; i <= n; ++i) Mx[i] = -INF;
	for (i = 1; i < n; ++i) F[i] = INF; F[n] = 0;
	for (i = 1; i < n; ++i){
		for (j = 1; j <= n; ++j) G[j] = INF;
		for (j = 1; j <= m; ++j) G[v[j]] = min(G[v[j]],F[u[j]] + w[j]);
		for (j = 1; j <= n; ++j) F[j] = G[j],Mx[j] = max(Mx[j],(Fn[j] - F[j]) / (n - i));
	}
	ans = INF;
	for (i = 1; i <= n; ++i) if (Fn[i] < 1e10) ans = min(ans,Mx[i]);
	printf("%.8lf\n",ans); 
    return 0;
}
```

---

## 作者：xyz32768 (赞：4)

看到“平均值”，可以想到先二分圈的平均值的最小值，记当前答案为$mid$。

这时候，把所有的边权都减掉$mid$，这样判断原图中是否包含有平均值小于等于$mid$的圈，就转化成了判断新图中是否包含有负环。用SPFA或DFS判断负环即可。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 3005, M = 1e4 + 5; const double eps = 1e-9;
int n, m, ecnt, nxt[M], adj[N], go[M], w[M]; double val[M], dis[N];
bool Flag, vis[N];
void add_edge(int u, int v, int x) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v; w[ecnt] = x;
}
void dfs(int u) {
    vis[u] = 1;
    for (int e = adj[u], v; e; e = nxt[e])
        if (dis[u] + val[e] < dis[v = go[e]]) {
            if (vis[v]) return (void) (Flag = 1);
            else {
                dis[v] = dis[u] + val[e];
                dfs(v);
            }
        }
    vis[u] = 0;
}
bool check(double x) {
    int i; memset(vis, 0, sizeof(vis));
    for (i = 1; i <= ecnt; i++) val[i] = 1.0 * w[i] - x;
    memset(dis, 0, sizeof(dis));
    for (i = 1; i <= n; i++) {
        Flag = 0;
        if (dfs(i), Flag) return 1;
    }
    return 0;
}
double solve() {
    double l = -1e5, r = 1e5;
    while (fabs(r - l) > eps) {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
int main() {
    int i, x, y, z; n = read(); m = read();
    for (i = 1; i <= m; i++) x = read(), y = read(),
        z = read(), add_edge(x, y, z);
    printf("%.8lf\n", solve());
    return 0;
}
```

---

## 作者：tommymio (赞：3)

板子题，最小均值环，非常 $\text{Naive}$ 的 $0/1$ 分数规划题。

根据 $0/1$ 分数规划的套路，本题令 $\frac{\sum a_i\times w_i}{\sum b_i\times w_i}$ 最小，并二分求解，判定是否存在一组 $w_i\in\{0,1\}$ 满足 $\sum a_iw_i-mid\times \sum w_i<0$ 即可。在本题的判定中，将每条边的边权变为 $a_i-mid$ 后我们直接求负环即可。

求负环使用最简单的 $\text{dfs-SPFA}$，非常好写。

当然也有非常优秀的 $O(nm)$ 做法，这里就不介绍了（

**Show the Code**

```cpp
#include<cstdio>
#include<queue>
const double inf=1e18;
int cnt=0;
int vis[3005],f[3005];
double dis[3005],w[20005];
int h[3005],to[20005],ver[20005];
inline void add(int x,int y,double z) {
	to[++cnt]=y;
	ver[cnt]=h[x];
	w[cnt]=z;
	h[x]=cnt;
}
inline bool spfa(int x,double val) {
	vis[x]=1;
	for(register int i=h[x];i;i=ver[i]) {
		int y=to[i];
		if(dis[y]>dis[x]+w[i]-val) {
			dis[y]=dis[x]+w[i]-val;
			if(vis[y]||spfa(y,val)) return 1;
		}
	}
	vis[x]=0;
	return 0;
}
inline bool check(int n,double val) {
	for(register int i=1;i<=n;++i) vis[i]=dis[i]=0;
	for(register int i=1;i<=n;++i) if(spfa(i,val)) return 1;
	return 0;
}
int main() {
	int n,m; scanf("%d%d",&n,&m);
	for(register int i=1;i<=m;++i) {int x,y; double z; scanf("%d%d%lf",&x,&y,&z); add(x,y,z);}
	double L=-1e7+5,R=1e7+5;
	while(R-L>=1e-9) {
		double mid=(L+R)/2.00;
		if(check(n,mid)) R=mid;
		else L=mid;
	}
	printf("%.8lf",L);
	return 0;
}
```


---

## 作者：std__unsigned (赞：2)

这道题不容易求出最小值，但我们可以将其化为判断可行性问题，就是二分最小值，用spfa判断负环

注意每次spfa要将vis和dis初始化为0

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
const double eps=(1e-9);
int head[10000],n,m,cnt;
bool vis[10000],flag;
double dis[10000];
struct node
{
    int to,w,next;
 } edge[10000];
void add(int u,int v,int w)//加边
{
    cnt++;
    edge[cnt].w=w;
    edge[cnt].to=v;
    edge[cnt].next=head[u];
    head[u]=cnt;
}
void spfa(int u,double mid)//dfs版的spfa
{
    vis[u]=1;
    for(int i=head[u];i;i=edge[i].next)
    {
        int v=edge[i].to;
        if(dis[v]>dis[u]+edge[i].w - mid)
        {
            if(vis[v]==1)
            {
                flag=false;    
                return;
            }
            dis[v]=dis[u]+edge[i].w - mid;
            spfa(v,mid);
            if(flag == false) {
                return;
            }
        }
    }
    vis[u]=0;
}
bool judge(double now)//判断
{
    memset(dis,0,sizeof(dis));
    memset(vis,0,sizeof(vis));
    for(int i=1;i<=n;i++)
    {
        if(vis[i]) continue;
        flag=true;
        spfa(i,now);
        if(flag==false)
        return false;
    }
    return true;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        add(u,v,w);
    }
    double l=0.000000,r=100000.0,mid;
    double result=-1;
    while(l-r<=eps)
    {
        mid=(l+r)/2;
        if(judge(mid)==true) 
        {
            l=mid+eps;    
            result=max(result,mid);
        }
        else r=mid-eps;
    }
    printf("%.8f",mid);
    return 0;
}

```

---

## 作者：水库中的水库 (赞：2)

这道题题目很复杂，其实一句话题意：求该图的最小的环的边权平均值（不包括自环）

首先我们可以发现它的解具有单调性，即

$aver_i>ans$且$aver_j>aver_i$则$aver_j>ans$

所以我们可以用二分答案$aver_i$，因为有负环所以边界是正负无穷大

则对于一个可以的环一定满足$(w_i-aver)+...+(w_j-aver)\ge0$

判定环用spfa即可，另外dfs的spfa会比bfs更优

```cpp
// luogu-judger-enable-o2
/***************************************************************
    File name: C.cpp
    Author: ljfcnyali
    Create time: 2019年05月17日 星期五 09时38分08秒
***************************************************************/
#include<bits/stdc++.h>

using namespace std;

#define REP(i, a, b) for ( int i = (a), _end_ = (b); i <= _end_; ++ i ) 
#define mem(a) memset ( (a), 0, sizeof ( a ) ) 
#define str(a) strlen ( a ) 

const int maxm = 2000010;
const int maxn = 10010;
const double eps = 0.000000001;

int Begin[maxm], Next[maxm], To[maxm], e;
int n, m, vis[maxn];
double aver, ans = 0x3f3f3f3f3f3f, dis[maxn], W[maxn], Max = -0x3f3f3f3f3f3f, Min = 0x3f3f3f3f3f3f;
bool flag;

inline void add(int u, int v, double w)
{
    To[++ e] = v;
    Next[e] = Begin[u];
    Begin[u] = e;
    W[e] = w;
}

inline void spfa(int u, int x)
{
    if ( flag == true ) return ;
    vis[u] = x;
    for ( int i = Begin[u]; i; i = Next[i] ) 
    {
        int v = To[i];
        if ( (double) dis[v] > (double) dis[u] + W[i] - aver ) 
        {
            dis[v] = (double) dis[u] + W[i] - aver;
            if ( !vis[v] ) spfa(v, x);
//			if ( dis[v] > Max * n ) { flag = true; return ; } 
            if ( vis[v] == x ) { flag = true; return ; }
        }
    }
    vis[u] = 0;
}

inline bool solve() 
{
    mem(vis); mem(dis);
    flag = false;
    REP(i, 1, n) 
    {
        spfa(i, i);
        if ( flag == true ) return true;
    }
    return false;
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif
    scanf("%d%d", &n, &m);
    REP(i, 1, m)
    {
        int u, v; double w;
        scanf("%d%d%lf", &u, &v, &w);
        add(u, v, w);
        Max = max(Max, w);
        Min = min(Min, w);
    }
    double L = Min, R = Max;
    while ( L <= R ) 
    {
        aver = (L + R) / 2;
        if ( solve() ) { ans = min(ans, aver); R = aver - eps; }
        else L = aver + eps;
    }
    printf("%.8lf\n", ans);
    return 0;
}
```

---

## 作者：Poetic_Rain (赞：1)

~~疑似三倍经验~~

因为和机房一些大佬一起做的这道题，所以emmm他们貌似也写了题解，在做这道题的时候也参照了其他大佬写的一些题解，所以如果程序有雷同请见谅（手动鞠躬）



------------

题目也是莫名其妙地给了一大串数学式，简洁地重新说一下题目

给你一张图，图中有环，定义**一个环的平均值为环的边权和÷环中点的个数**，那么就应该有了一中非常暴力的思路

- 想办法找出来图中所有的环并求出其平均值，再比较出最小值

这个方法确实怎么想都很暴力，但是一点也不好实现，可能是我太弱，我实在想不太出来有什么算法可以找出来所有的环，所以这种思路先给我PASS掉

而正解呢？应该是二分答案。为什么？

- 既然我们找不出来环，我们逆向思维，直接枚举平均值，看是否会有一个环符合条件，那么这道题就变成了：**二分枚举平均值，找到是否有环符合条件**

若我们此时枚举的平均值为$ans$，有$k$个字符串，那么就有

$ans * k = len1 + len2 + len3  + ... + lenk$

那道这个式子之后，我们对它进行移项

$0=len1-ans+len2-ans+len3-ans+...+lenk-ans$

那么对于满足以下式子，就可以判断是环了，所以在跑$SPFA$更新距离的时候，就应该像下面这样

$0 \leq len1-ans+len2-ans+len3-ans+...+lenk-ans$

所以这里就直接给程序了（三道题的）

[SP2885 WORDRING - Word Rings](https://www.cnblogs.com/Poetic-Rain/p/13368559.html)

P3199 [HNOI2009]最小圈

```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=30000000+51;
const double INF=(1e5)*1.0;
const double eqs=1e-9;
int n,m;
struct node {
	int net,to;
	double z;
} e[MAXN];
int head[MAXN],tot;
void add(int x,int y,double z) {
	e[++tot].net=head[x];
	e[tot].to=y;
	e[tot].z=z;
	head[x]=tot;
}

double d[MAXN];
bool v[MAXN],flag;
bool spfa(int x,double k) {
	v[x]=true;
	for(register int i=head[x]; i; i=e[i].net) {
		int y=e[i].to;
		double z=e[i].z;
		if(d[y]>d[x]+z-k) {
			d[y]=d[x]+z-k;
			if(v[y]==true||spfa(y,k)==true) return true;
		}
	}
	v[x]=false;
	return false;
}
bool check(double x) {
	for(register int i=1; i<=n; i++) {
		d[i]=20040915;
		v[i]=false;
	}
	for(register int i=1; i<=n; i++) {
		if(spfa(i,x)==true) return true;
	}
	return false;
}
int main() {
	scanf("%d%d",&n,&m);
	for(register int i=1; i<=m; i++) {
		int x,y;
		double z;
		scanf("%d%d%lf",&x,&y,&z);
		add(x,y,z);
	}
	double l=-INF,r=INF;
	while(r-l>eqs) {
		double mid=(l+r)/2;
		if(check(mid)==true) r=mid;
		else l=mid;
	}
	printf("%.8lf",l);
	return 0;
}
```

[UVA11090 Going in Cycle!!](https://www.luogu.com.cn/problem/UVA11090)


```
#include <bits/stdc++.h>
using namespace std;
int T,n,m,u,v,w,tot;
double dis[520010];
int vis[520010],head[520010];

struct node {
	int to,net;
	double val;
} e[520010];

inline void add(int u,int v,double w) {
	e[++tot].to=v;
	e[tot].val=w;
	e[tot].net=head[u];
	head[u]=tot;
}

inline bool dfs(int now,double x) {
	vis[now]=1;
	for(register int i=head[now];i;i=e[i].net) {
		int v=e[i].to;
		if(dis[v]>dis[now]+e[i].val-x) {
			dis[v]=dis[now]+e[i].val-x;
			if(vis[v]==1||dfs(v,x)==true) return true;
		}
	}
	vis[now]=0;
	return false;
}

inline bool check(double x) {
	for(register int i=1;i<=n;i++) {
		vis[i]=0;
		dis[i]=20050206;
	}
	for(register int i=1;i<=n;i++) {
		if(dfs(i,x)==true) return true;
	}
	return false;
}

int main() {
	scanf("%d",&T);
	for(register int k=1;k<=T;k++) {
		tot=0;
		for(register int i=1;i<=n;i++) head[i]=0;
		scanf("%d%d",&n,&m);
		for(register int i=1;i<=m;i++) {
			scanf("%d%d%d",&u,&v,&w);
			add(u,v,w);
		}
		double l=-10000000,r=10000000;
		while(r-l>1e-10) {
			double mid=(l+r)/2;
			if(check(mid)==true) r=mid;
			else l=mid;
		}
		printf("Case #%d: ",k);
		if(l==10000000) puts("No cycle found.");
		else printf("%.2lf\n",l);
	}
	return 0;
}

```


---

## 作者：Eleven谦 (赞：0)

# 最小圈

### Preface 前言

双（三）倍经验！

- [P3199 [HNOI2009]最小圈](https://www.luogu.com.cn/problem/P3199)

- [UVA11090 Going in Cycle!!](https://www.luogu.com.cn/problem/UVA11090)

- [SP2885 WORDRING - Word Rings](https://www.luogu.com.cn/problem/SP2885)

所以，你们可能会在 [UVA11090 Going in Cycle!!](https://www.luogu.com.cn/problem/UVA11090) 这篇题解中又看到我qwq


------------
### Problem model 问题模型

这三道题都是给定一张有向图，首先判断是否有环

如果有环就求出最大环或最小环的平均值

解决这种题，我们通常都是使用 **二分答案 & SPFA** 判环求最短（长）路

### Train of thought 思路点拨

- 为什么会想到**二分答案**呢？

因为在找最大（小）环的时候我们一般会想到：

遍历整个图，找到每一个环，然后算出它们的平均值，最后比较出最大（小）值

但是题目可能是多组数据，还不说图的大小，所以这种思路大概率会 $T$ 飞的

- 那怎么做？

——不能找环，那我们就直接找答案啊！（这里要转换一下思想）

因为找答案 $=$ 枚举答案，而枚举答案一般使用较高效的**二分答案**！

- 再来转换一下关键式子

我们能将求答案$ans$的式子表示如下：

$ans=(len_1+len_2+len_3+···+len_k)/K$

数学转换一下：

$ans*K=len_1+len_2+len_3+···+len_k$

移项一下：

$(len_1+len_2+len_3+···+len_k)-ans*K=0$

最后我们可得：

$(len_1-ans)+(len_2-ans)+(len_3-ans)+···+(len_k-ans)≥0$

（因为最开始的式子是整除，会有精度问题，所以是 $≥$ ）

- 经过上述转换之后，$SPFA$ 中**更新路径长度**的写法就应该如下：

```dis[v]>dis[now]+e[i].val-mid``` 或 ```dis[v]<dis[now]+e[i].val-mid```

则 ```dis[v]=dis[now]+e[i].val-mid```

其中 $mid$ 是我们当前枚举的答案（第一句是最小环，第二句是最大环）

- $check$ 函数的写法也变得显而易见：

**每次枚举了 $ans$，就跑 $SPFA$ ，如果存在环则说明当前枚举的 $ans$ 是合法的，反之不合法**

------------
#### Code 代码

注：这三道题我都写的 $dfs$ 版的 $SPFA$

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,u,v,tot;
double w,dis[520010];
int vis[520010],head[520010];

struct node {
    int to,net;
    double val;
} e[520010];

inline void add(int u,int v,double w) {
    e[++tot].to=v;
    e[tot].val=w;
    e[tot].net=head[u];
    head[u]=tot;
}

inline bool dfs(int now,double x) {
    vis[now]=1;
    for(register int i=head[now];i;i=e[i].net) {
        int v=e[i].to;
        if(dis[v]>dis[now]+e[i].val-x) {
            dis[v]=dis[now]+e[i].val-x;
            if(vis[v]==1||dfs(v,x)==true) return true;
        }
    }
    vis[now]=0;
    return false;
}

inline bool check(double x) {
    for(register int i=1;i<=n;i++) {
        vis[i]=0;
        dis[i]=20050206;
    }
    for(register int i=1;i<=n;i++) {
        if(dfs(i,x)==true) return true;
    }
    return false;
}

int main() {
    scanf("%d%d",&n,&m);
    for(register int i=1;i<=m;i++) {
        scanf("%d%d%lf",&u,&v,&w);
        add(u,v,w);
    }
    double l=-10000000,r=10000000;
    while(r-l>1e-10) {
        double mid=(l+r)/2;
        if(check(mid)==true) r=mid;
        else l=mid;
    }
    printf("%.8lf",l);
    return 0;
}
```

------------
### Epilogue 尾声

最后，如果这篇题解有任何问题或不懂的地方，欢迎留言区评论

我一定会及时回复、改正，谢谢各位dalao呀！orz

------------







---

## 作者：Position (赞：0)

二分答案+dfs spfa判负环


二分出一个答案mid，对于每条边的权值减去mid，利用spfa找负环，如果找到的话，说明mid可作为最小圈的平均值

对于判负环，dfs的spfa比bfs的快很多


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 3005
#define maxe 10005
using namespace std;
struct Edge
{
    int v;
    double w;
    int next;
}e[maxe];
int head[maxn],cnts=0,n,m;
double eps=1e-9,dis[maxn];
bool vis[maxn],flag;
inline void addedge(int u,int v,double w)
{
    cnts++;
    e[cnts].v=v;
    e[cnts].w=w;
    e[cnts].next=head[u];
    head[u]=cnts;
}
void spfa(int x,double mid)
{
    vis[x]=1;
    for(int i=head[x];i!=0;i=e[i].next)
    {
        int v=e[i].v;
        if(dis[v]>dis[x]+e[i].w-mid)
        {
            if(vis[v])
            {
                flag=1;
                return;
            }
            dis[v]=dis[x]+e[i].w-mid;
            spfa(v,mid);
        }
    }
    vis[x]=0;
}
inline bool check(double mid)
{
    memset(vis,0,sizeof(vis));
    memset(dis,0,sizeof(dis));
    for(int i=1;i<=n;i++)
    {
        flag=0;
        spfa(i,mid);
        if(flag) return 1;
    }
    return 0;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1,u,v;i<=m;i++)
    {
        double w;
        scanf("%d%d%lf",&u,&v,&w);
        addedge(u,v,w);
    }
    double l=-1e5,r=1e5,mid;
    while(r-l>eps)
    {
        mid=(l+r)/2;
        if(check(mid)) r=mid;
        else l=mid;
    }
    printf("%.8lf",mid);
}
```

---

## 作者：stevewen (赞：0)

看到这道题，首先想到2分，当然这道题还可以给成多种形式，比如说小数点位数，所以一定要确定值的范围

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define maxn 3005
#define fr(i,a,b); for(i=a;i<=b;i++)
using namespace std;
typedef long long ll;
const double ding=1e5;
const double eps=1e-9;
struct poi
{
    int x;
    double y,z;
    poi *nex;
} *a[maxn];
int i,n,m,x,y;
double z,mn,mx,l,r,mid,tot,dis[maxn];
bool cai,kan[maxn];
void link(int x,int y,long double z)
{
    poi *p=new poi;
    p->x=y;
    p->y=z;
    p->nex=a[x];
    a[x]=p;
    return;
}
void dfs(int x)
{
    kan[x]=1;
    poi *p=new poi;
    for(p=a[x];p;p=p->nex)
        if (dis[p->x]>dis[x]+p->y-mid)
        {
            dis[p->x]=dis[x]+p->y-mid;
            if (!kan[p->x]) dfs(p->x);
            else cai=1;
            if (cai) return;
        }
    kan[x]=0;
    return;
}
bool check( double x)
{
    cai=0;
    fr(i,1,n)
    {
        memset(kan,0,sizeof(kan));
        memset(dis,0,sizeof(dis));
        dfs(i);
        if (cai) return 1;
    }
    return 0;
}
int main()
{
    scanf("%d%d",&n,&m);
    mn=ding,mx=-ding
fr(i,1,m)
    {
        scanf("%d%d%lf",&x,&y,&z);
        link(x,y,z);
        mn=min(mn,z),mx=max(mx,z);
    }
    l=mn,r=mx;
    while (r-l>eps)
    {
        mid=(l+r)/2;
        if (check(mid)) r=mid;
        else l=mid;
    }
    printf("%.8f\n",l);
    return 0;
}


```



---


# [HNOI2013] 数列

## 题目描述

小 $T$ 最近在学着买股票，他得到内部消息：$F$ 公司的股票将会疯涨。股票每天的价格已知是正整数，并且由于客观上的原因，最多只能为 $N$。在疯涨的 $K$ 天中小 $T$ 观察到：除第一天外每天的股价都比前一天高，且高出的价格（即当天的股价与前一天的股价之差）不会超过 $M$，$M$ 为正整数。并且这些参数满足 $M(K-1)<N$。小 $T$ 忘记了这 $K$ 天每天的具体股价了，他现在想知道这 $K$ 天的股价有多少种可能。

## 说明/提示

**样例解释**  

输出样例的 $16$ 表示输入样例的股价有 $16$ 种可能：

{1，2，3}，{1，2，4}，{1，3，4}，{1，3，5}， {2，3，4}，{2，3，5}，{2，4，5}，{2，4，6}， {3，4，5}，{3，4，6}，{3，5，6}，{3，5，7}，{4，5，6}，{4，5，7}，{4，6，7}，{5，6，7}

## 样例 #1

### 输入

```
7 3 2 997
```

### 输出

```
16
```

# 题解

## 作者：League丶翎 (赞：16)

无耻的安利一波博客[Chlience](http://blog.csdn.net/Force_CHL)

~~这个题目我们可以画图AC~~

将某一个确定的上涨序列$a[1],a[2],a[3],...,a[k]$写出来

这个序列对于总数的贡献为1,当然,是当$a[k]\leq n$的时候

显然的,维持每天上涨的价格不变,由于$a[1]$能够有多种取值,那么它就会有很多贡献,当然,变化后的$a[1]$仍然要保证$a[k]\leq n$

那么能不能考虑维护一个股票价格的差分数列?就不用考虑$a[1]$的取值

并且,这个差分数列$s[1],s[2],s[3],...,s[k-1]$所做出的贡献就为$n-\sum_{i=1}^{k-1}s[i]$

一共有$m^{k-1}$个不同的差分数列,每个数列做出的贡献值为$n-\sum_{i=1}^{k-1}s[i]$

那么总贡献就为

$\sum_{d=1}^{m^{k-1}}(n-\sum_{i=1}^{k-1}s[d][i])$

将$n$提出可得

$n*m^{k-1}-\sum_{d=1}^{m^{k-1}}\sum_{i=1}^{k-1}s[d][i]$

现在要做的就是处理后面那一堆东西

注意,$s$显然是将所有可能的排列情况都算了进去,并且$s[d][i]\in[1,m]$

那么后面一共就会有$m^{k-1}*(k-1)$个数,并且在$[1,m]$中完全平均分布

所以$[1,m]$中的每个数都会出现$\frac{m^{k-1}*(k-1)}{m}=m^{k-2}*(k-1)$次

运用小学数学知识,将其总和化为$m^{k-2}*(k-1)*\frac{(m+1)*m}{2}$

这样就很好求解了

最终答案为$n*m^{k-1}-m^{k-2}*(k-1)*\frac{(m+1)*m}{2}$
快速幂就好啦╮(╯_╰)╭


努力追赶dalao中
给予我力量吧(丢脸ing

**代码如下**
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
ll n,k,m,p,ans;
ll read() {
	ll ans=0,flag=1;
	char ch=getchar();
	while((ch>'9' || ch<'0') && ch!='-') ch=getchar();
	if(ch=='-') flag=-1,ch=getchar();
	while(ch>='0' && ch<='9') ans=ans*10+ch-'0',ch=getchar();
	return ans*flag;
}
ll qpow(ll a,ll b,ll mod) {
	ll ans=1;
	while(b>0) {
		if(b&1) {ans*=a;ans%=mod;}
		b>>=1;a*=a;a%=mod;
	}
	return ans;
}
ll exgcd(ll a,ll b,ll &x,ll &y) {
	if(b==0) {x=1;y=0;return a;}
	ll gcd=exgcd(b,a%b,x,y);
	ll t=x;
	x=y; y=t-(a/b)*y;
}
int main() {
	n=read(),k=read(),m=read(),p=read();
	ll x,y,gcd;
	gcd=exgcd(2,p,x,y);
	x=(x%p+p)%p;
	ans+=(qpow(m,k-1,p)*(n%p))%p;
	ans-=((((qpow(m,k-1,p)*(k-1))%p*(m+1))%p)%p*x%p);
	ans=(ans%p+p)%p;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：zhylj (赞：9)

> 组合意义天地灭，代数推导保平安。

介绍一个非常暴力的推法。

考虑差分数组 $x_1,x_2,\cdots, x_k$，相当于要满足性质：

$$\forall i\in [2,k],\ 1\le x\le m$$

$$\sum x_i \le n$$

不妨设 $x_{k+1} = n - \sum_{i=1}^k x_i+1$（注意要 $+1$，这样所有的 $x$ 都是正整数），则限制变成 $\sum_{i=1}^{k+1} x_i = n+1$。

于是，我们考虑容斥，枚举 $i$ 表示有 $i$ 个大于 $m$，故答案为：

$$\sum_{i=0}^{k-1} (-1)^i{k-1\choose i}{n - i\cdot m \choose k}$$

考虑这个式子长得很像函数的 $k-1$ 阶差分：

$$\Delta^{k-1} f(x) = \sum_{i=0}^{k-1}(-1)^{k - 1 - i} {k-1\choose i}f(x + i)$$

于是我们考虑令 $f(x) = {n-x\cdot m \choose k}$，则：

$$(-1)^{k-1}\Delta^{k-1}f(0) = \sum_{i=0}^{k-1} (-1)^i{k-1\choose i}{n - i\cdot m \choose k}$$

于是，问题就变成了求 $(-1)^n\Delta^nf(0)$，考虑把它转成牛顿级数 $f(x)=\sum_{i} c_i{x\choose i}$ 的形式，这样 $k-1$ 阶差分就是 $\Delta^{k-1} f(x)\sum_ic_{i+k-1}{x\choose i}$ 了，于是 $\Delta^{k-1}f(0) = c_{k-1}$。

先把 $f(x)$ 转化为多项式（第一类斯特林数和二项式定理）：

$$\begin{aligned}f(x) & = {n-x\cdot m\choose k}\\& = \frac{(n-x\cdot m)^{\underline k}}{k!}\\& = \frac{1}{k!}\sum_{j=0}^k (-1)^{k-j}\left[\begin{matrix}k\\j\end{matrix}\right](n-x\cdot m)^j\\& = \frac{1}{k!}\sum_{j=0}^k (-1)^{k-j}\left[\begin{matrix}k\\j\end{matrix}\right]\sum_{p=0}^jn^{j-p}m^p(-1)^p{j\choose p}x^p\\& = \frac{1}{k!}\sum_{p=0}^k\sum_{j=p}^k (-1)^{k-j+p}\left[\begin{matrix}k\\j\end{matrix}\right]n^{j-p}m^p{j\choose p}x^p\end{aligned}$$

然后再转成牛顿级数：

$$\begin{aligned}f(x) & = \frac{1}{k!}\sum_{p=0}^k\sum_{j=p}^k (-1)^{k-j+p}\left[\begin{matrix}k\\j\end{matrix}\right]n^{j-p}m^p{j\choose p}x^p\\& = \frac{1}{k!}\sum_{p=0}^k\sum_{j=p}^k (-1)^{k-j+p}\left[\begin{matrix}k\\j\end{matrix}\right]n^{j-p}m^p{j\choose p}\sum_{q=0}^p\left\{\begin{matrix}p\\q\end{matrix}\right\}{x\choose q}q!\\& = \frac{1}{k!}\sum_{q=0}^k\sum_{p=q}^k\sum_{j=p}^k (-1)^{k-j+p}\left[\begin{matrix}k\\j\end{matrix}\right]n^{j-p}m^p{j\choose p}\left\{\begin{matrix}p\\q\end{matrix}\right\}q!{x\choose q}
\end{aligned}$$

于是 $\Delta^{k-1}f(0)$ 为它的第 $k-1$ 次项系数：

$$\begin{aligned}(-1)^{k-1}\Delta^{k-1}f(0) &= \frac{1}{k}\sum_{p=k-1}^k\sum_{j=p}^k (-1)^{p-j+1}\left[\begin{matrix}k\\j\end{matrix}\right]n^{j-p}m^p{j\choose p}\left\{\begin{matrix}p\\k-1\end{matrix}\right\}\\
\end{aligned}$$

注意到这些斯特林数和组合数上下至多差一，有：

$$\left[\begin{matrix}k\\k-1\end{matrix}\right]=\left\{\begin{matrix}k\\k-1\end{matrix}\right\}={k\choose 2}$$

所以其实已经可以算了，但是这样式子还是太丑，于是我们考虑继续化简：

当 $p=k-1$ 时，后半部分（第一个 $\sum$ 之后）的值为：

$$-m^{k-1}{k\choose 2}+m^{k-1}nk$$

当 $p=k$ 时，后半部分的值为：

$$-m^k{k\choose 2}$$

所以答案为：

$$\frac{1}k\left(-m^{k-1}{k\choose 2}+m^{k-1}nk
 - m^k{k\choose 2}\right)$$

整理得：

$$m^{k-1}\cdot n - \frac{m^{k-1}(m+1)(k-1)}2$$

就是组合推出来的式子了。

代码很简单，不贴了。顺带一提，这个式子还可以求不限制的 $x_i$ 稍微多一点的情况。（时间复杂度是不限制的变量数的平方）


---

## 作者：撤云 (赞：6)

[$blog$](https://www.cnblogs.com/hbxblog/p/10395890.html)

### $Solution$

这道题貌似并不难的样子$QAQ$ 

我们发现这个因为有首项的关系所以有点不太好弄.所以我们要将这个首项对答案的影响给去掉.

我们可以构建一个差分数组,我们令他等于$a[1],a[2]...a[k-1]$

则一个查分数组对答案的贡献为:

$$\sum_{i=1}^{k-1}n-a[i]$$

然后我们一共有$m^(k-1)$个这样的查分数组,所以总贡献为:

$$\sum_{j=1}^{m^{k-1}}\sum_{i=1}^{k-1}n-a[j][i]$$

我们将$n$提出来,式子变为:

$$n*m^{k-1}-\sum_{j=1}^{m^{k-1}}\sum_{i=1}^{k-1}a[j][i]$$

所以现在只需要化简后面的式子了.

枚举一些数发现(实际上是我不会证明)  
发现在区间$[1,m]的数每个数出现的个数相同$  
至于怎么发现的,打表找规律啊.  

这样的话,每个数出现的次数就可以确定了:  
$m^{k-1}$个数组,每个数组$(k-1)$个数,  
则每个数的个数为:  
$$m^{k-1}*(k-1)/m$$
$$=m^{k-2}*(k-1)$$
然后后面式子的值就只需要用这个数乘上$1+2+3+...+m的值了$

所以后面式子实际上就是:
$$m^{k-2}*(k-1)*((1+m)*m)/2$$

所以最终答案为:
$$n*m^{k-1}-m^{k-2}*(k-1)*((1+m)*m)/2$$

注意取模的问题啊,好坑!!!

### $Code$

``` cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    return x*f;
}
int ksm(int a,int b,int mod){
    int ans=1;
    while(b){
    if(b&1)
        ans=a*ans%mod;
    a=a*a%mod;
    b>>=1;
    }
    return ans%mod;
}
main(){
    int n=read(),k=read(),m=read(),p=read();
    printf("%lld",(n%p*ksm(m,k-1,p)%p-ksm(m,k-2,p)*(k-1)%p*((1+m)*m/2%p)%p+p)%p);
}
```

---

## 作者：老K (赞：5)

[详情在博客（因为我的公式渲染出了点锅在这上面不好调）](https://cnyali-lk.com/HNOI2013-%E6%95%B0%E5%88%97/)

就是快速幂了。

```C++

ll fpm(ll a,ll b,ll p){
	ll c=1;
	while(b){
		if(b&1)c=c*a%p;	
		a=a*a%p;
		b>>=1;
	}
	return c;
}
int main(){
#ifdef cnyali_lk
	freopen("3228.in","r",stdin);
	freopen("3228.out","w",stdout);
#endif
	ll n,m,k,p;
	n=read();//read是读入
	k=read()-1;
	m=read();
	p=read();
	n%=p;
	printf("%lld\n",(n*fpm(m,k,p)%p-fpm(m,k-1,p)*k%p*(m*(m+1)/2%p)%p+p)%p);
	return 0;
}


```



---

## 作者：IceKylin (赞：4)

### P3228 [HNOI2013] 数列 题解

组合意义天地灭，代数推导保平安。

由于除第一天外每天的股价都比前一天高，所以不妨设 $d_i$ 表示第 $(i+1)$ 天股价与第 $i$ 天股价的差值，所以得到差分序列 $\{d_{k-1}\}$，显然有 $1\le d_i\le m$。

由题意知 $\displaystyle\sum_{i=1}^{k-1}d_i\le m(k-1)<n$，所以对于每一种差分序列，第一天的股价都存在 $\displaystyle \left(n-\sum_{i=1}^{k-1}d_i\right)$ 种取值。

所以得到答案：

$$\displaystyle\text{ans}=\sum_{d_1=1}^m\sum_{d_2=1}^m\sum_{d_3=1}^m\cdots\sum_{d_{k-1}=1}^m\left(n-\sum_{i=1}^{k-1}d_i\right)$$

化简一下式子：

$$\displaystyle\text{ans}=m^{k-1}n-\sum_{d_1=1}^m\sum_{d_2=1}^m\sum_{d_3=1}^m\cdots\sum_{d_{k-1}=1}^m\sum_{i=1}^{k-1}d_i$$

很多题解到了这里就开始"感性理解"，但其实可以用代数方法继续推：

$$\displaystyle\text{ans}=m^{k-1}n-\sum_{d_1=1}^m\sum_{d_2=1}^m\sum_{d_3=1}^m\cdots\sum_{d_{k-1}=1}^m(d_1+d_2+d_3+\cdots+d_{k-1})$$

由于 $d_i$ 之间互不相关，所以可以把后面那一坨拆开：

$$\displaystyle\text{ans}=m^{k-1}n-m^{k-2}\sum_{d_1=1}^md_1-m^{k-2}\sum_{d_2=1}^md_2-m^{k-2}\sum_{d_3=1}^md_3-\cdots-m^{k-2}\sum_{d_{k-1}=1}^md_{k-1}$$

从而得到：

$$\displaystyle\text{ans}=m^{k-1}n-m^{k-2}(k-1)\cdot\frac{m(m+1)}{2}=m^{k-1}n-\frac{m^{k-1}(m+1)(k-1)}{2}$$

然后就无脑算了。

细节：

1. 特判 $k=1$ 的情况。

2. 由于 $n$ 可能大于 $p$，所以要注意取模。

---

## 作者：cyn2006 (赞：4)

题目降到每一天都要比前一天高，但相差不能超过 $m$，容易联想到差分序列。

我们考虑每一个序列对最终答案的贡献，因为可以第一天的数值可以任意，所以我们需要考虑后 $k-1$ 天的贡献。

对于一个差分序列 $\{a\}$，贡献记为 $g(a)$，则需要满足 $k-1$ 个数的和都小于等于 $n$，那么第一天的数值的方案数，即对答案做出的贡献有：
$$
g(a)=n-\sum_{i=1}^{k-1} a_i
$$
一共有 $m^{k-1}$ 个序列，记第 $i$ 个序列为 $a_i$，则：
$$
Ans=\sum_{i=1}^{m^{k-1}} g(a)
$$

$$
=n\times m^{k-1} +\sum_{i=1}^{m^{k-1}} \sum_{j=1}^{k-1} a_{j}
$$
考虑到每一个数分布的概率均匀，所以每一个数的出现次数为：
$$
m^{k-1}\times (k-1)\times \frac{1}{m}
$$

$$
=m^{k-2}\times (k-1)
$$
所以后者的总和为：
$$
m^{k-2}\times (k-1)\times \dfrac{m\times (m+1)}{2}
$$
所以答案即为：
$$
Ans=n\times m^{k-1}-m^{k-2}\times (k-1)\times \dfrac{m\times (m+1)}{2}
$$

```cpp
#include<bits/stdc++.h>
#define ll long long
ll n,k,m,p;
inline ll qpow(ll x,ll y,ll ret=1){
	for(;y;y>>=1,x=x*x%p) if(y&1)
		ret=ret*x%p; return ret;
}
inline ll upd(ll x){return x+=x>>31&p;}
inline ll calc(ll x){return x&1?(x+1)/2*x%p:x/2*(x+1)%p;}
int main(){
	std::cin>>n>>k>>m>>p;
	std::cout<<upd(n%p*qpow(m,k-1)%p-qpow(m,k-2)*calc(m)%p*(k-1)%p)<<'\n';
	return 0;
}
```



---

## 作者：蒟蒻丁 (赞：4)

呃，这题代码极短，6行即可（逃
```
#include<iostream>
#define ll long long
using namespace std;
ll n,m,k,p;
ll ksm(ll x,ll k){ll tmp=1;while(k){if(k&1)tmp=tmp*x%p;x=x*x%p,k/=2;}return tmp;}
int main(){cin>>n>>k>>m>>p,n%=p,m%=p,cout<<(ksm(m,k-1)*n%p-(((m+1)*m/2)%p*ksm(m,k-2)%p*(k-1)%p)%p+p)%p;}
```
但是如果思路被带偏了，就会像小编一样想了两个小时才理解

首先考虑“构造”出一个合法的 $a$ 数组，用以记录每天股票的价格

那么根据题意 $a[i]-a[i-1]<=m$ ，题目中又写到 $m * (k-1)< n$ ，那么就算每一个 $a[i]$ 都取到 $a[i]==a[i-1]+m$ 也没问题

现在再构造一个差分数组 $b$ 也就是定义 $b[i]=a[i]-a[i-1]$ ，那么 $b[i]<=m$ ，那么不考虑“最高价格不超过n” $ans=m^{k-1} * (a[1]的可能取值)$

$m^{k-1}$ 的意思就是，每个 $b[i]$ 都可以从 1 到 $m$ 随便取一个值，这就是个乘法原理，不解释下去了（不然反而看不懂）

那么我们来想想 $a[1]$ 的取值

hin显然， $a[1]=n-$$\sum_{x=1}^{n}{b_x}$ (建议自行理解，要是由小编来解释诸位可能反而会晕)

那么 $ans=m^{k-1} * (n-∑b_x)=n * m^{k-1}-∑∑b_x$ 为什么拆括号的时候会有这个奇怪问题呢，因为前面 $m^{k-1}$ 是会影响 $b_x$ 的

毕竟 $m^{k-1}$ 是一个方案数，并没有考虑方案不同而导致的不同结果

而 $∑∑b_x$ 可以转化为一个数在差分序列中出现的次数，用 $(k-1) * m^{k-2} * (m+1) * m/2$ 计算 

因为 $b_x$ 的数值是在 1 到 $m$ 中随便选取的，那么显然一个数可以在 $(k-1)$ (每)个位置都出现一次，然后其他 $(k-2)$ 个数值可以随便选取

然后等差数列求和就完了（我 * * 这里想了贼久，其实就是每个数字是有实际贡献的，hhhc）

为什么要乘上等差序列求和呢:请注意-∑∑bx前面((k-1)*m^k-2)算出来的是每个数出现的次数,但是我们要算的是-∑∑bx所以根据“总价=数量*单价”,需要乘上∑i

---

## 作者：hgckythgcfhk (赞：2)

考虑这 $k$ 天的差分数组 $a$，定义第 $0$ 天的价格必须为 $0$，问题转化为：求和不超过 $n$ 的数组 $a$，使得 $\forall i \in [2,k]$，$a_i \le m$ 的方案数。

注意到 $m \times (k-1)<n$，也就是说，即使后面 $k-1$ 个数都取到上界，也一定有解。

一个显然的想法是若后面都能取到上界，$a_1 \le n-m \times (k-1)$，由于正整数，设 $t=n-m \times (k-1)$ 显然这部分的答案是 $t\times m^{k-1}$，很快，我们会发现 $a_1>t$ 但后面很小也是合法解，这样会算漏，考虑计算其他的解，发现很容易算重，也许能算，但我太菜了，不会算。

基于这个想法，我们手动数一下 $a_1>t$ 的情况，显然合法的解后面 $k-1$ 个数的和不超过 $n-a_1$，从 $t+1$ 到 $n-k+1$ 枚举 $a_1$ 设 $i=a_1-t$，$cnt(i)$ 表示 后面和为 $i$ 的每个元素都不超过 $m$ 数组个数，发现每个 $i$ 的贡献为 $\sum_{j=0}^{j \le i} cnt(n-j)$ 计算每个 $cnt(i)$ 的贡献，发现并不是很好算，考虑把 $a_1 \le t$ 的情况并入，即直接计算所有情况的方案数，从 $1$ 到 $n$ 枚举 $a_1$，答案为 $\sum_{i=n-k+1}^{i \le n-1} cnt(i) \times (n-i)$。

这里 $n-i$ 表示 $a_1$，正确性显然，可以用组合意义证，因为对于每个和为 $i$ 的数组，$n-i$ 合法，比 $n-i$ 小肯定更合法，即，$a_1$ 可一为 $[1,n-i]$ 的任意数。

最后化简这个式子。

$\text{原式}=(n \times \sum cnt(i))-(\sum cnt(i) \times i)$

由于 $\sum cnt(i)$ 等价于 每个元素都不超过 $m$ 的数组个数，$\sum cnt(i) = m^{k-1}$。

$\text{原式}=n \times m^{k-1}-\sum {cnt(i)\times i}$

由于 $\sum {cnt(i)\times i}$ 的意义为和为 $i$ 的合法数组个数乘 $i$，显然等价于所有合法数组和的和。

我们可以把一个每个位置上界相同且确定，下界为 $0$ 的数组视为一个固定进制的整数。把所有数组进行一个变换使得数组中所有元素减 $1$，发现每个数的个数等于变换后的对应数的个数，则所有合法的数组的集合可以表示为 $0$ 到 $m^{k-2}-1$ 的 $m$ 进制整数的集合。

以 $2$ 进制为例，发现集合中 $0$ 和 $1$ 的个数相等，这个很好证明，因为每个元素按位取反后的结果一定在集合中，把每个元素和按位取反的结果划为一组，每一组里的 $0$ 和 $1$ 个数相等，每个元素可以不重不漏划分到一组，所以在 $2$ 进制下成立。

假设 $x$ 进制（$x \ge 2$）成立，则在 $x$ 进制下，设位数为 $y$，每个数的出现次数为 $x^{y-1} \times y \div x=x^{y-2}\times y$，$y$ 位的 $x+1$ 进制数的集合，每一位有是 $x$ 和不是两种情况，对于一个有 $z$ 个 $x$ 的数，对 $x$ 的贡献为 $z\times C_{y-1}^{z}\times x^{y-z-1}$ 所以 $x$ 的个数为 $\sum_{i=1}^{i\le y}{i\times C_{y-1}^{i}\times x^{y-i-1}}$，根据二项式定理，这个东西等于 $y\times (x+1)^{y-1}$，对于其他的数，考虑每一位上不为 $x$ 的取值，我们已经假设 $x$ 进制成立，所以其他数在无论 $z$ 取何值出现次数一定相等，易得出现次数也是 $y\times (x+1)^{y-1}$。

到这里，我们已经归纳的证出一个结论，所有合法数组每个数出现 $m^{k-2}\times (k-1)$ 次，故 $\sum {cnt(i)\times i}=(m^{k-2}\times (k-1))\times (\frac{m\times(m+1)}{2})$。

所以 $\text{原式}=n \times m^{k-1}-(m^{k-2}\times (k-1))\times (\frac{m\times(m+1)}{2})$。

这个式子也可以用其他的组合意义去理解，比如容斥和斯特林数，但我感觉直接这样理解更简单，因为这个方法没有用到高级的知识点，只需要硬推和熟悉位运算就能理解。

```
#include<bits/stdc++.h>
#define cit const register unsigned
#define open ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)//,freopen("1.in","r",stdin),freopen("1.out","w",stdout)
#define int register unsigned
#define void inline void
using namespace std;constexpr unsigned N=1e5+1;
#define ll long long
unsigned ll p;
inline unsigned ll pw(int ll a,int ll b){int ll s=1;for(;b;b>>=1,a=a*a%p)b&1?s=s*a%p:0;return s;}
signed main(){open;int ll n,k,m;cin>>n>>k>>m>>p;cout<<(n%p*pw(m,k-1)%p+p-(pw(m,k-2)*1ll*(k-1)%p*((m*(m+1)>>1)%p)%p)%p)%p;}
```


---

## 作者：Nine_Suns (赞：1)

显然考虑原数列的差分数组，限制变为序列的和不超过 $n$，并且除第一天外其它天数的值处于 $[1,m]$。朴素的做法是容斥，但显然无法通过。

观察题目发现 $m(k-1)<n$。设第一天的值为 $v$，则当 $v+m(k-1)\le n$ 时后面的 $k-1$ 天可以任意摆放。

设 $t=n-m(k-1)$，则我们先计算出当第一天的值取在 $[1,t)$ 时的答案。接下来我们设将 $n$ 个数分在 $k-1$ 天中，且每一天的数都在 $[1,m]$ 中的方案数为 $S(n)$。为了方便，我们定义，对于 $n>m(k-1)$ 或 $n<0$ 有 $S(n)=0$。

枚举除第一天外所有天的值之和，答案即为 $\sum\limits_{i=0}^n S(i)(n-i)$（注意：$n>m(k-1)$，所以上界取到 $n$ 是合法的）。计算似乎仍然困难，但我们有两个等式成立：

1. $\sum\limits_{i=0}^n S(i)=m^{k-1}$。

2. $S(i)=S((m+1)(k-1)-i)$。

对于等式 $1$，$m^{k-1}$ 和 $\sum\limits_{i=0}^{m(k-1)}S(i)$ 都涵盖了每一种划分方案，自然相等。对于等式 $2$，设一天分配的数为 $x$，令其变为 $m-x+1$，不难发现仍然满足限制，且新的和为 $(m+1)(k-1)-i$。

于是可以计算上式：

$$\begin{aligned}\sum_{i=0}^nS(i)(n-i)&= \frac {1}{2} \left(\sum_{i=0}^{n}S(i)(n-i)+\sum_{i=0}^nS((m+1)(k-1)-i)(n-i)\right)\\ &= \frac 12\left(\sum_{i=0}^n S(i)(n-i)+\sum_{i=0}^nS(i)(n+i-(m+1)(k-1)) \right )\\&= \frac 12 \sum_{i=0}^nS(i)(2n-(m+1)(k-1)) \\&= \frac {(2n-(m+1)(k-1))m^{k-1}}2\end{aligned}$$

再加上一开始的答案即可。

```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long long ll; 
ll n, k, m; int mod; 

ll qpow (ll x, ll y) {
	ll res = 1;
	while (y) {
		if (y&1) res = res*x%mod;
		x = x*x%mod; y >>= 1; 
	}
	return res; 
}

int main () {
	cin >> n >> k >> m >> mod; 
	ll t = m*(k-1), ans; 
	if (m&1) ans = (n-t+(t-k+1)/2)%mod*qpow(m, k-1)%mod;
	else ans = (n-t)%mod*qpow(m, k-1)%mod+(t-k+1)%mod*(qpow(m, k-2)*(m/2)%mod)%mod; 
	ans %= mod; if (ans < 0) ans += mod; 
	cout << ans;  
	return 0; 
}
```


---

## 作者：tsqtsqtsq0309 (赞：1)

# P3228 [HNOI2013] 数列

## 题目大意

给定四个参数 $N$，$K$，$M$，$P$，你需要构造一个长度为 $K$ 的上升序列，令这个构造序列为 $A$，这个上升序列需要满足以下条件：

1. $\forall A_i,i \in \left\{1 \le i \le k \mid i \in \Z\right\},A_i \le N$。
2. $\forall A_i, i \in \left\{1 < i \le k \mid i \in \Z\right\}, A_{i-1} \le A_i$。
3. $\forall A_i,i \in \left\{1 \le i \le k \mid i \in \Z\right\},A_i - A_{i-1} \le M$。

试求解出构造合法的上升序列 $A$ 的的方案数对 $P$ 取模的结果，其中对于给定的四个参数满足以下条件：

1. $M(K - 1) < N$。
2. $M, K, P \le 10^9, N \le 10^{18}$。

## 思路

显然对于每一个合法的上升序列 $A$，这个上升序列对于总方案数的贡献为 $1$，可以考虑维护一个表示序列具体数据的差分序列，这样的话就可以不用考虑 $A_1$ 的取值。

令这个差分序列为 $B$，则 $B$ 的贡献为：
$$
n - \sum_{i = 1}^{k - 1}{B_i}
$$
一共会有 $m_{k - 1}$ 个不同的差分序列，总的贡献为：
$$
\sum_{i = 1}^{m^{k - 1}}(n - \sum_{j = 1}^{k - 1}{B_{i,j}})
$$
经过简单变换可得：
$$
n \times m^{k - 1} - \sum_{i = 1}^{m^{k - 1}}\sum_{j = 1}^{k - 1}{B_{i,j}}
$$
注意到差分序列 $B_{i,j} \in [1, m]$，显然一共会有 $m^{k - 2} \times (k - 1)$ 个数在 $[1, m]$ 中完全平均分布，则 $[1, m]$ 中的每一个数都会出现 $\frac{m^{k - 1} \times (k - 1)}{m}$ 次。 

可以求出总和为：
$$
\frac{m^{k - 1} \times (k - 1)}{m} \times \frac{(m + 1)m}{2}
$$
代入原式得：
$$
n * m^{k - 1} - \frac{m^{k - 1} \times (k - 1)}{m} \times \frac{(m + 1)m}{2}
$$
经过简单变换可得最终总方案数为：
$$
n \times m^{k - 1} - m^{k - 2} \times (k - 1) \times \frac{(m + 1)m}{2}
$$

至于代码实现的话，直接用快速幂和逆元求解这个式子的值就可以了。

具体细节请看代码……

## 代码

```cpp
#include <iostream>
using namespace std;
#define int long long
int n, k, m, p, x, y, gcd, ans;
int qpow(int a, int b){
	int ans = 1;
	while(b > 0){
		if(b & 1){ans *= a;ans %= p;}
		b >>= 1;a *= a;a %= p;
	}
	return ans;
}
int exgcd(int a, int b, int &x, int &y) // 扩欧求逆元
{
    if(b == 0){x = 1;y = 0;return a;}
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}
signed main(){
	cin >> n >> k >> m >> p;
	gcd = exgcd(2, p, x, y); // 求逆元
	x = (x % p + p) % p;
	ans += (qpow(m, k - 1) * (n % p)) % p;
	ans -= ((((qpow(m, k - 1) * (k - 1)) % p * (m + 1)) % p) % p * x % p);
	ans = (ans % p + p) % p; // 依据表达式求解答案
	cout << ans << endl;
	return 0;
} // 完结撒花～～
```



---

## 作者：到底几只鱼呢 (赞：1)

## 组合数学推柿子

用**涨幅相同**来定义同一个差分序列 $d_i$，那么不同的序列只取决于不同的首项，从而可得：

$$ans=\sum_{d1=1}^{m} \sum_{d2=1}^{m} \dots \sum_{d_{k-1}=1}^{m}\times  \left ( n-\sum_{i=1}^{k-1}d_i  \right ) $$

分析这个式子，我们可以知道将 

$$
\sum_{d1=1}^{m} \sum_{d2=1}^{m} \dots \sum_{d_{k-1}=1}^{m}
$$

看作 $A$，那么 
$$ans=A\times \left ( n-\sum_{i=1}^{k-1}d_i  \right) $$
即：

$$ans=A\times n-A\times  \sum_{i=1}^{k-1}d_i$$

$$ans=n\times m^{k-1}-\sum_{d1=1}^{m} \sum_{d2=1}^{m} \dots \sum_{d_{k-1}=1}^{m}\times \sum_{i=1}^{k-1}d_i$$

 减号后面共 $ m^{k-1}* (k-1)$ 个数，并且在 $[1,m]$ 中完全平均分布
所以 $[1,m]$ 中的每个数都会出现 
 $ \frac{m^{k-1}\times \left ( k-1 \right ) }{m} $
 次，将其总和化为
$$ m^{k-2}\times (k-1) \times \frac{(m+1)\times m}{2} $$

那么最终的答案即为：

$$ans=n\times m^{k-1}-m^{k-2}\times (k-1) \times \frac{(m+1)\times m}{2}$$

别忘了 $+p$ 再 $\bmod\ p$ !

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <cstdlib>
#include <queue>
#define inf 0x3f3f3f3f
using namespace std;

long long n,k,m,p;

long long ksm(long long base,long long power) {
	long long ans=1;
	while(power!=0) {
		if(power%2==1) {
			ans=(ans*base)%p;
		}
		base=(base*base)%p;
		power/=2;
	}
	return ans;
}

int main() {
	cin>>n>>k>>m>>p;
	k--;
	n%=p;
	long long a1=n*ksm(m,k)%p;
	long long a2=k*ksm(m,k-1)%p;
	long long a3=((m+1)*m/2)%p;
	cout<<((a1-(a2)*(a3)%p+p)%p+p)%p;
	return 0;
}
```


---

## 作者：cloud2764scallop_eve (赞：0)

## 题意
给定 $n$、$m$、$k$ 和 $p$，要求在 $n$ 中取 $k$ 个数，并且相邻的两个数字差小于等于 $m$，最后对 $p$ 取模。  
## 思路
如果直接考虑求出这个数列的话，过程相对麻烦，实现起来比较困难，所以不妨换一种思路。  

注意题目中有一个非常特殊的数据： $m$，数列中相邻的两个数差一定小于等于 $m$，这为解题提供了另一种思路——从差的角度考虑。  

那么如果将数列中每两个相邻的数的差表示为一个数组 $a$，用 $a_i$ 表示第 $i$ 天到第 $i + 1$ 天数列差的变化。为了满足题意，很明显，$a_i \in [1 , m]$。  

那么对于一种情况，答案就可以表示为 $n - \sum_{i = 1}^{k-1} a_i$。由于题目中有叙述 $m(k - 1) < n$，易得总共应有 $m^{k - 1}$ 个不同的数列，所以答案可以表示为 $m^{k - 1} \times (n - \sum_{i = 1}^{k - 1} a_i)$。  

接下来的步骤就是对 $m^{k - 1} \times (n - \sum_{i = 1}^{k - 1} a_i)$ 进行处理。可以把原式拆开，即 $m^{k - 1} \times n - m^{k - 1} \times \sum_{i = 1}^{k - 1} a_i$。对于全排列中的每一个数，出现的次数都是相同的，即 $[1,m]$ 中的每一个数平均出现了 $m^{k - 1} \times \frac{k - 1}{m} = m^{k - 2} \times (k - 1)$ 次。所以可以把原式变为 $m^{k - 1} \times n - m^{k - 2} \times (k - 1) \times \sum_{i = 1}^m i$，再用求和公式化简，即可得到 $ans = m^{k - 1} \times n - m^{k - 2} \times (k - 1) \times \frac{m(m-1)}{2}$。  

代码实现使用快速幂即可。
## 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n, m, k, mod, ans;
ll qpow(ll a, ll b) {
	ll res = 1;
	while (b) {
		if (b & 1) res = res * a % mod;
		a = a * a % mod;
		b /= 2;
	}
	return res;
}
int main() {
	scanf ("%lld%lld%lld%lld", &n, &k, &m, &mod);
	n %= mod;
	ans = (qpow(m, k - 1) * n % mod - qpow(m, k - 2) * ((m * (m + 1) / 2ll) % mod) % mod * (k - 1) % mod + mod) % mod;
	printf ("%lld", ans);
	return 0;
}
```
> 注意，由于 $n$ 的值较大，在运算中可能会爆 `long long`，要在输入完之后及时取模。

---

## 作者：Tzs_yousa (赞：0)

首先，尝试用暴力来解决这个问题的话，通过枚举我们会发现每个序列的贡献为1（废话），如果挨个枚举 $a_1$ 貌似并没有什么好的办法。

那就可以设一个数组存每次上涨的价格，也就是股票价格的差分序列，这个序列的总和加上 $a_1$ 小于等于 $n$ 即可，那么 $a_1$ 可得的合法价格就是 $n - sum$。

这个差分序列有 $k - 1$ 项，每一项有 $m$ 种选择。那么最后所得的价值就是这 $m^{k - 1}$ 种序列的贡献相加。

但是如果直接这样算会 $TLE$，我们考虑化简这个式子。通过观察发现一共出现了 $(k - 1) \times m^{k - 1}$ 个数，且1到 $m$ 全都是等概率分布的，那每个数出现次数都是 $(k - 1) \times m^{k - 2}$ 次。

最后的结果就是 $m^{k - 2} \times (k - 1) \times \frac{(m + 1) \times m} {2}$。

## 代码
```cpp
#include <bits/stdc++.h>
#define int long long
const int MAXN = 1e5 + 10;
using namespace std;
int n, k, m, p;
inline int read()
{
	int x = 0, f = 1; char c = getchar();
	while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
	while(c >= '0' && c <= '9') {x = (x << 3) + (x << 1) + c - '0'; c = getchar();}
	return x * f;
}
int quick_pow(int a, int b)
{
	int res = 1;
	while(b)
	{
		if(b & 1) (res *= a) %= p;
		(a *= a) %= p;
		b >>= 1;
	}
	return res % p;
}
signed main()
{
	n = read(), k = read(), m = read(), p = read();
	printf("%lld\n", (n % p * quick_pow(m, k - 1) % p - quick_pow(m, k - 2) * (k - 1) % p * ((m + 1) % p * m / 2 % p) % p + p) % p);
	return 0;
}
```


---

## 作者：FZzzz (赞：0)

> 组合意义天地灭，代数推导保平安。

下面某位一看就是嘉心糖的老哥这样写道。可问题是……那个代数推导怎么也不像“保平安”的样子啊喂！

这里是一个既无思维含量也无计算难度的生成函数推法。

------------
题意：求满足下列条件的正整数序列个数：有 $k$ 个数，严格递增，每项不超过 $n$，相邻两项的差不超过 $m$。

考虑如果我们确定了第一项，以及最后一项与第一项的差 $d$，那么我们就只需要求出选 $k-1$ 个 $[1,m]$ 内的数使得和为 $d$ 的方案数，即可唯一对应一个合法序列。这个形式可以直接写出生成函数：
$$F(x)=\sum_{i=1}^mx^i$$
$$G(x)=F^{k-1}(x)$$
若首项与末项差为 $d$，则合法首项的个数即为 $n-d$，那么答案即为：
$$\sum_{i=1}^{n-1}(n-i)[x^i]G(x)=n\sum_{i=1}^{n-1}[x^i]G(x)-\sum_{i=1}^{n-1}i[x^i]G(x)$$
发现，$F$ 是一个 $m$ 次多项式，那么 $G$ 是一个 $m(k-1)$ 次多项式，而题目保证了 $n>m(k-1)$，则多项式的每一项都在上式中被考虑到。我们考虑用多项式的求值来改写上式，不难发现即为：
$$nG(1)-G'(1)=nF(1)^{k-1}-(k-1)F(1)^{k-2}F'(1)$$
我们显然有 $F(1)=m$，$F'(1)=\dfrac12m(m+1)$，那么最终答案即为：
$$nm^{k-1}-\frac12m^{k-1}(m+1)(k-1)$$

---

## 作者：zqy1018 (赞：0)

这是一道数学题。

解这道题可以利用画图和DP的方法。

由于图比较多，具体题解见这里：

[题解](http://leanote.com/blog/post/593f7c62ab644110b3000eeb)

代码如下（实际上只有一个快速幂的过程）：

```cpp
ll N,M,K,P;
ll Pow(ll a,ll b,ll c){
    ll res=1;
    a%=c;
    while(b){
        if(b&1)res=(res*a)%c;
        a=(a*a)%c,b>>=1;
    }
    return res;
}
void init(){
    scanf("%lld%lld%lld%lld",&N,&K,&M,&P);
}
void solve(){
    ll ans1=Pow(M,K-1,P);
    ll inv2,ans;
    N%=P,ans=(N*ans1)%P;
    if(M&1)inv2=(M+1)/2,inv2=inv2*M%P;
    else inv2=M/2,inv2=inv2*(M+1)%P;
    inv2=inv2*(K-1)%P;
    inv2=inv2*Pow(M,K-2,P)%P;
    ans+=P,ans=(ans-inv2)%P;
    printf("%lld\n",ans);
}
```

---


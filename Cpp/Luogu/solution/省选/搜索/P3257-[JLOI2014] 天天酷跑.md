# [JLOI2014] 天天酷跑

## 题目描述

在游戏天天酷跑中，最爽的应该是超级奖励模式了吧，没有一切障碍，可以尽情的吃金币，现在请你控制游戏角色来获得尽可能多的分数。游戏界面离散为一个长度为 $1 \sim n$，高度为 $1 \sim m$（初始点为 $(0,1)$）的矩阵图。每个格子上都有收益 $(-1 \sim 1000)$，$-1$ 表示该点不能通过。游戏角色从起点一路奔跑向终点，中途可以跳跃来获得更高的分数，在空中还能进行连跳。

游戏开始前你可以设定跳跃的高度，以及能连跳的次数，初始跳跃高度为 $1$，连跳数为 $1$（最多为 $5$），升级跳跃高度和连跳都需要一定的花费。跳跃高度设定完后游戏角色每次跳跃高度都将固定，连跳必须在下落过程中可以使用。所有操作都将在整点上完成，需要保证设定完的跳跃高度及连跳数，无法跳出游戏高度上限。

![](https://cdn.luogu.com.cn/upload/pic/17609.png) 

从 $(1,1)$ 点用一次跳跃，一次经过 $(2,2),(3,3),(4,2),(5,1)$。

以下是连跳数为 $2$ 连跳，跳跃高度为 $2$ 的跳跃方案：

![](https://cdn.luogu.com.cn/upload/pic/17610.png)

从 $(1,1)$ 起跳，依次经过 $(2,2),(3,3),(4,2)$ 再使用连跳，经过 $(5,3),(6,4),(7,3),(8,2),(9,1)$。

![](https://cdn.luogu.com.cn/upload/pic/17611.png)

## 说明/提示

对于 $20 \%$ 的数据，满足 $m=2$，$1 \le n \le 10 ^ 5$。

对于另外 $80 \%$ 的数据，$1 \le n \le 10000$，$2 < m \le 20$，其中有 $20\%$ 的数据保证 $2 < n \le 10$，$1 \le m \le 10$。

## 样例 #1

### 输入

```
7 4 6 10
9 4 7 7 4 3 2
18 8 9 4 15 12 4
19 2 4 7 10 18 12
8 1 13 14 16 0 14```

### 输出

```
67 1 2```

# 题解

## 作者：thmyl (赞：8)

[http://www.cnblogs.com/thmyl/p/7485186.html](http://www.cnblogs.com/thmyl/p/7485186.html)

记忆化搜索

定义状态f[i][j][o]表示处于x，y这个位置，还剩余o次连跳数的最大收益

如果是跑——f[i][j][o]=max(f[i][j+1][o]+w[i][j]) w[i][j]为这点的权值；

如果是跳的话——f[i][j][o]=max(f[i+跳跃高度（high）][j+high][o--]+hhh+w[i][j]) hhh跳跃上升过程中得到的金币数。


```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
using namespace std;
#define inf 1<<30
#define maxn 100010
bool vis[25][maxn][6];
int f[25][maxn][6],map[25][maxn];
int n,m,c1,c2,ans=-inf,ans1,ans2,h,num;
int dfs(int x,int y,int now){
    if(x>n)return 0;
    if(map[y][x]==-1)return -inf;
    if(vis[y][x][now])return f[y][x][now];
    int tot=-inf,sum=0;bool flag=1;
    if(y==1)now=0;
    if(now<num){
        for(int i=1;i<h;i++){
            if(map[y+i][x+i]==-1){flag=0;break;}
            sum+=map[y+i][x+i];
        }
        if(flag)tot=max(tot,sum+dfs(x+h,y+h,now+1));
    }
    if(y==1)tot=max(tot,dfs(x+1,y,0));
    if(y>1)tot=max(tot,dfs(x+1,y-1,now));
    vis[y][x][now]=1;
    f[y][x][now]=tot+map[y][x];
    return f[y][x][now];
}
int main(){
    scanf("%d%d%d%d",&n,&m,&c1,&c2);
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
            scanf("%d",&map[i][j]);
    for(num=1;num<=5;num++){
        for(h=1;h*num<m;h++){
            memset(f,-1,sizeof(f));
            memset(vis,0,sizeof(vis));
            int tot=dfs(0,1,m)-c2*(num-1)-c1*(h-1);
            if(ans<tot)ans=tot,ans1=num,ans2=h;
        }
    }
    if(ans>0)printf("%d %d %d",ans,ans1,ans2);
    else printf("mission failed");
    return 0;
}
```

---

## 作者：年华天地 (赞：4)

交这篇题解，主要是因为在我于机友讨论的时候发现了一点点的小疑惑，为什么在枚举跳跃高度的时候是跳跃次数$\times$跳跃高度<m，我们研究了一下，发现不对劲，跳跃次数$\times$跳跃高度可以大于m呀，我们可以先跳一次，在下滑过程中再跳，这样不会超过边界但也是一种情况，比如这份数据：

20 5 1 1

10 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 10 10 

-1 10 -1 -1 -1 10 -1 -1 -1 -1 -1 10 -1 -1 -1 -1 -1 10 -1 -1 

-1 -1 10 -1 10 -1 10 -1 -1 -1 10 -1 10 -1 -1 -1 10 -1 -1 -1 

-1 -1 -1 10 -1 -1 -1 10 -1 10 -1 -1 -1 10 -1 10 -1 -1 -1 -1 

-1 -1 -1 -1 -1 -1 -1 -1 10 -1 -1 -1 -1 -1 10 -1 -1 -1 -1 -1 

你会发现沿着10跳是最优的，但是两个题解输出的全是mission failed。

我发这篇题解并不是为了专门去hack谁，或显摆自己的知识（其实我也没有多少知识，蒟蒻一枚），只是为了与大家讨论正确的解法罢了。



---

## 作者：Flying2018 (赞：3)

众所周知，记忆化搜索是可以转dp的。（~~但为什么dp跑这么慢~~）

首先，跳跃高度和连跳次数无法由上一种直接推得（~~或者是因为我太菜~~）。直接枚举跳跃高度和连跳次数。

但是考虑到跳跃上升时无法连跳，考虑用$f[i][j][k]$表示第$i$行$j$格高时，已经连跳k次（当前不处于上升状态）后的最优结果。

很显然可以推得
$f[i+1][j-1][k]=max(f[i+1][j-1][k],f[i][j][k]+cost[i+1][j-1])$
$f[i+h][j+h][k+1]=max(f[i][j][k]+\sum_{l=1}^{h}{cost[i+l][j+l][k]},f[i+h][j+h][k+1])$
其中$cost[i][j]$表示该格的收益$h$表示跳跃高度

显然可以发现其中累加的一段可以用前缀和解决。

最后是一些特判。

对于第一行（即地面上那一行），是可以清空连跳次数的。所以从第一行跳出的$k=1$。同时第一行也可以直接走过去。

这道题中最后到第n列时可以不落地，所以假如跳跃时跳出了地图(即$i+h>=n$)那么需要将跳出地图时的情况记录下来。

附上丑陋的代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#define N 100050
#define M 30
#define inf 100000000
using namespace std;
int f[N][M][8];
int c1,c2;
int cost[N][M],sum[N][M];
int cmax,tmin,hmin;
int n,m;
int get(int x,int y,int h){return sum[x+h][y+h]-sum[x][y];}
int main()
{
	scanf("%d%d%d%d",&n,&m,&c1,&c2);
	for(int j=1;j<=m;j++)
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&cost[i][j]);
			if(cost[i][j]==-1) cost[i][j]=-inf;
			sum[i][j]=cost[i][j]+sum[i-1][j-1];
		}
	cmax=-inf;
	tmin=hmin=inf;
	for(int h=1;h<m;h++)
	{
		for(int t=1;h*t<m && t<=5;t++)
		{
			for(int i=0;i<=n;i++)
				for(int j=1;j<=m;j++)
					for(int k=0;k<=t;k++)
					f[i][j][k]=-inf;
			f[0][1][0]=0;
			int res=-inf;
			for(int i=0;i<n;i++)
				for(int j=1;j<=m;j++)
				{
					if(j==1)
					{
						for(int k=1;k<=t;k++)
						f[i][j][0]=max(f[i][j][0],f[i][j][k]);
						f[i+1][j][0]=max(f[i+1][j][0],f[i][j][0]+cost[i+1][j]);
						if(i+h<=n) f[i+h][j+h][1]=max(f[i][j][0]+get(i,j,h),f[i+h][j+h][1]);
						else f[n][n-i+1][1]=max(f[i][j][0]+get(i,j,n-i),f[n][n-i+1][1]);
					}
					else
					{
						for(int k=1;k<=t;k++)
						{
							f[i+1][j-1][k]=max(f[i+1][j-1][k],f[i][j][k]+cost[i+1][j-1]);
							if(k<t)
							{
								if(i+h<=n) f[i+h][j+h][k+1]=max(f[i][j][k]+get(i,j,h),f[i+h][j+h][k+1]);
								else f[n][j+n-i+1][k+1]=max(f[i][j][k]+get(i,j,n-i),f[n][j+n-i+1][k+1]);
							}
						}
					}
				}
			for(int i=1;i<=m;i++)
				for(int k=0;k<=t;k++)
				res=max(res,f[n][i][k]);
			res-=(h-1)*c1+(t-1)*c2;
			if(res>cmax || (res==cmax && t<tmin) || (res==cmax && t==tmin && h<hmin))
			{
				cmax=res;
				tmin=t;
				hmin=h;
			}
		}
	}
	if(cmax<0) puts("mission failed");
	else printf("%d %d %d",cmax,tmin,hmin);
	return 0;
}

```

---

## 作者：DengDuck (赞：1)

建议给这题改名，叫做【模板】语文阅读理解。

首先自然的想法是发现高度和连跳的次数都很小，可以枚举，然后可以直接 $F_{X,Y,C}$ 表示当前在 $(X,Y)$，还可以连跳 $C$ 次的最大价值。

考虑下一步是跳还是不跳就能转移了。

注意到这样常数很大，所以我们考虑简单优化一下，合法的状态应该不会太多，所以写记搜就可以了。

**注意到：**

> 初始点为 $(0,1)$ 而不是 $(1,1)$。

你可能会问：这不是很基础吗？哎呀真没意思，散了散了。

别急，大的要来了：

**注意到：**

> **需要保证设定完的跳跃高度及连跳数，无法跳出游戏高度上限。**

这句话的意思**并不是需要保证我们的方案不会跳出**，而是要保证**在这个连跳数和跳跃高度下不存在跳出的方案**。

所以我们需要满足 $1+HC\leq m$，$H$ 是跳跃高度，$C$ 是连跳数。

这一点似乎是很难发现的，我们机房很多人都在这里被硬控了。

也许对本题的数据的疑问和 Hack 也就可以盖棺定论了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
const int M=20;
const int Inf=1e9;
int n,m,C1,C2,C,H;
int A[N][M],F[N][M+5][6];
int Dfs(int X,int Y,int K)
{
	if(X>n)return 0;
	if(A[X][Y]==-1)return -Inf;
	int &Ans=F[X][Y][K];
	if(Ans!=-1)return Ans;
	Ans=-Inf;
	if(Y==1)K=C;
	if(K>0&&Y+H<=m)
	{
		int Flg=1,S=0;
		for(int i=1;i<H;i++)Flg&=A[X+i][Y+i]!=-1,S+=A[X+i][Y+i];
		if(Flg)Ans=S+Dfs(X+H,Y+H,K-1);
	}
	Ans=max(Ans,Dfs(X+1,Y-(Y!=1),K))+A[X][Y];
	return Ans;
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&C1,&C2);
	for(int j=1;j<=m;j++)
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&A[i][j]);
	}
	int Ans=-Inf,AC,AH;
	for(C=1;C<=5;C++)
	for(H=1;H*C<m;H++)
	{
		memset(F,-1,sizeof(F));
		int K=Dfs(0,1,C)-(H-1)*C1-(C-1)*C2;
		if(K>Ans)Ans=K,AC=C,AH=H;
	}
	if(Ans>=0)printf("%d %d %d",Ans,AC,AH);
	else puts("mission failed");
}
```

---

## 作者：LJXlalala (赞：1)

## 思路

考虑记忆化搜索。定义 $f[i][j][k]$ 为到达坐标 $(i,j)$ 时还剩下 $k$ 次连跳次数的能拿收益最大。

所以当到达一个点的时候接下来有两种选择，跳与不跳。

如果选择不跳的话，就判断现在是否在空中，如果在空中，就往右下搜，否则在地面上的话，就往右搜。

跳起来上升的那一段可以直接用一个循环语句，来提前处理出可获得的收益以及是否合法，然后搜索跳跃的最高点即可。

## 警钟

最高点是算作下落过程的，题意描述较为模糊。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10,INF=0x3f3f3f3f;
int n,m,ch,ct,a[N][21],f[N][21][6],ans=-INF,ant,anh,mat,h;
int dfs(int x,int y,int t){
	if(x>n) return 0;
	if(a[x][y]==-1) return -INF;
	if(f[x][y][t]!=-1) return f[x][y][t];
	int num=-INF;
	if(y==1) t=mat;
	if(t>0&&y+h<=m){//尝试跳跃 
		int i,sum=0;
		bool flag=1;
		for(i=1;i<h;i++){
            if(a[x+i][y+i]==-1){
				flag=0;
				break;
			}
            sum+=a[x+i][y+i];
        }
        if(flag) num=sum+dfs(x+h,y+h,t-1);
	}
	//常规往后走 
	num=max(num,dfs(x+1,y-(y!=1),t));
    f[x][y][t]=num+a[x][y];
	return f[x][y][t];
}
int main(){
	int i,j,sum;
	cin>>n>>m>>ch>>ct;
	for(i=1;i<=m;i++){
		for(j=1;j<=n;j++){
			cin>>a[j][i];
		}
	} 
	for(mat=1;mat<=5;mat++){
		for(h=1;h*mat<m;h++){
			memset(f,-1,sizeof(f));
			sum=dfs(0,1,mat)-((mat-1)*ct+(h-1)*ch);
			if(sum>ans){
				ans=sum;
				ant=mat;
				anh=h;
			}
		}
	}
	if(ans>=0) cout<<ans<<" "<<ant<<" "<<anh;
	else cout<<"mission failed";
	return 0;
}
```

---


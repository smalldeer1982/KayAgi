# [JLOI2015] 战争调度

## 题目描述

脸哥最近来到了一个神奇的王国，王国里的公民每个公民有两个下属或者没有下属，这种关系刚好组成一个 $n$ 层的完全二叉树。公民 $i$ 的下属是 $2i$ 和 $2i +1$。最下层的公民即叶子节点的公民是平民，平民没有下属，最上层的是国王，中间是各级贵族。

现在这个王国爆发了战争，国王需要决定每一个平民是去种地以供应粮食还是参加战争，每一个贵族（包括国王自己）是去管理后勤还是领兵打仗。一个平民会对他的所有直系上司有贡献度，若一个平民 $i$ 参加战争，他的某个直系上司 $j$ 领兵打仗，那么这个平民对上司的作战贡献度为 $w_{ij}$。若一个平民 $i$ 种地，他的某个直系上司 $j$ 管理后勤，那么这个平民对上司的后勤贡献度为 $f_{ij}$，若 $i$ 和 $j$ 所参加的事务不同，则没有贡献度。为了战争需要保障后勤，国王还要求不多于 $m$ 个平民参加战争。

国王想要使整个王国所有贵族得到的贡献度最大，并把这件事交给了脸哥。但不幸的是，脸哥还有很多 deadline 没有完成，他只能把这件事又转交给你。你能帮他安排吗？

## 说明/提示

对于 $100 \%$ 的数据，$2 \leq n \leq 10, \ m \leq 2^{n-1}, \ 0 \leq w_{ij}, f_{ij} \leq 2000$。

## 样例 #1

### 输入

```
3 4
503 1082
1271 369
303 1135
749 1289
100 54
837 826
947 699
216 389```

### 输出

```
6701```

# 题解

## 作者：Shikita (赞：23)

# 的确是一道树形DP的好题目

题意简述：对于一颗完全二叉树，可以将叶子节点设置为两种状态（简称为0和1），如果该叶子节点与其某个祖先的状态相同，那么就有一个贡献值，两者都为0或1时对应两种不同的贡献值，求设置某种状态小于m时的最大贡献

由于这是一颗完全二叉树，那么其实就是分别求左右两个树形背包然后合并的结果

设 f[i][j] 表示以i为根的子树中，j个叶子节点选择战争的最大总贡献值。

```
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int x=0;
    char c=getchar();
    bool flag=0;
    while(c<'0'||c>'9') {if(c=='-')flag=1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x+(x<<2)<<1)+ c-'0';c=getchar();}
    return flag?-x:x;
}
int n,m;
int gh[1030][15],pt[1030][15],f[1030][1030],vis[15];
void dfs(int x,int y) //x表示节点，y表示层数
{
	for(int i=0;i<=1<<y;i++) f[x][i]=0;//全部初始化
	if(!y) //如果已经完成搜索（dp）
    {
    for(int i=1;i<=n;i++) 
      if(vis[i]) f[x][1]+=gh[x][i]; 
      else f[x][0]+=pt[x][i];return;
      //把贡献分别上交，退出
    }
	vis[y]=0,dfs(x<<1,y-1),dfs(x<<1|1,y-1);//分别去子节点
	for(int i=0;i<=1<<(y-1);i++) 
      for(int j=0;j<=1<<(y-1);j++) 
        f[x][i+j]=max(f[x][i+j],f[x<<1][i]+f[x<<1|1][j]);
	vis[y]=1,dfs(x<<1,y-1),dfs(x<<1|1,y-1);
	for(int i=0;i<=1<<(y-1);i++) 
      for(int j=0;j<=1<<(y-1);j++)
        f[x][i+j]=max(f[x][i+j],f[x<<1][i]+f[x<<1|1][j]);
    //在分别完成子树的搜索之后进行子树的合并
}
int main()
{
	int ans=0;
	n=read(),m=read(),n--;//不能超过n所以这里直接进行--处理
	for(int i=0;i<(1<<n);++i) 
      for(int j=1;j<=n;++j) 
        gh[i+(1<<n)][j]=read();//这个是存打仗的贡献，（givehead）
	for(int i=0;i<(1<<n);++i) 
      for(int j=1;j<=n;++j) 
        pt[i+(1<<n)][j]=read();//这个是存种地的贡献，（刨土）
	dfs(1,n);
	for(int i=0;i<=m;++i) ans=max(ans,f[1][i]); cout<<ans<<endl;
    //根据dp方程的推导，以1为根选取1~m个节点的最大值
}
```

望大佬们多多海涵，感谢斧正

---

## 作者：PPL_ (赞：8)

# 前言(可跳过)

~~这题真是好啊(KCUF)~~

这题拿到的时候，我知道又可以锻炼我的暴力技巧了

# 思路

当你没什么思路的时候，你可以从暴力开始

比如你可以先把每个叶子节点的状态用$2^{2^{n-1}}$枚举出来，然后统计答案，于是20pts就到手了

但是T飞了！！！

很明显我们不能枚举叶子节点，那我们可以枚举什么来确定这棵树的状态呢？

我们很容易想到，如果一个叶子节点的所有祖先的状态都已经确定了，那么这个叶子节点的状态也可以确定下来

而一个叶子节点的祖先只有$n-1$个，我们可以枚举他们来得到答案，时间只有$O(2^n)$

# 正题

当我们想到枚举祖先的状态，这道题离AC已经不远了

我们就可以用 $dp[x]$ 表示第 $x$ 个节点的最大贡献度，但是还有一个最多 $m$ 个人去打仗的条件，我们就可以加一维：

用 $dp[x][i]$ 表示第 $x$ 个节点有 $i$ 个人去打仗的最大贡献度

那么对于**每一个叶子节点所有祖先的状态已经确定的情况下**(多读几遍就懂了)

每个叶子节点的贡献度可以直接算出来，然后向上更新

到了这一步，我们可以得到状态转移方程 $dp[x][i+j] = max(dp[x][i+j],dp[x<<1][i] + dp[x<<1|1][j])$ ，也就是确定了左右儿子的贡献度后，向上更新

最后在根节点求0~m个人去打仗的最大贡献率输出就行了

下面是丑陋的代码：

**能不看还是别看了 非要看就只看dfs吧**

```cpp
//12252024832524
#include <cstdio>
#include <algorithm>
#define Min(x,y) (x<y?x:y)
#define Max(x,y) (x>y?x:y)
using namespace std; 

typedef long long LL;
const int MAXN = 15;
const int MAXNN = 2055;
int n,nn,m,ans;
int dp[MAXNN][MAXNN],war[MAXNN][MAXN],farmer[MAXNN][MAXN];

int Read()
{
    int x = 0,f = 1;char c = getchar();
    while(c > '9' || c < '0'){if(c == '-')f = -1;c = getchar();}
    while(c >= '0' && c <= '9'){x = (x*10) + (c^48);c = getchar();}
    return x * f;
}
void Put(int x)
{
    if(x > 9)
        Put(x/10);
    putchar(x%10^48);
}
void dfs(int x,int s,int d)//s为祖先状态 1打仗 0后勤，d为子树大小
{
    for(int i = 0;i <= d;++ i)
        dp[x][i] = 0;
    if(d == 1)
    {
        for(int i = 0;i < n-1;++ i)
            if(s >> i & 1)
                dp[x][1] += war[x][i+1];
            else
                dp[x][0] += farmer[x][i+1];
        return ;
    }
    for(int cas = 0;cas < 2;++ cas)
    {
        dfs(x<<1,s<<1|cas,d>>1);
        dfs(x<<1|1,s<<1|cas,d>>1);
        for(int i = 0;i <= Min(d,m);++ i)
            for(int j = 0;j <= Min(d,m);++ j)
                dp[x][i+j] = Max(dp[x][i+j],dp[x<<1][i]+dp[x<<1|1][j]);
    }
}

int main()
{
//  freopen(".in","r",stdin);
//  freopen(".out","w",stdout);
    n = Read();
    nn = 1 << (n-1);
    m = Read();
    for(int i = nn;i < nn+nn;++ i)
        for(int j = 1;j < n;++ j)
            war[i][j] = Read();
    for(int i = nn;i < nn+nn;++ i)
        for(int j = 1;j < n;++ j)
            farmer[i][j] = Read();
    dfs(1,0,(1<<n)-1);
    for(int i = 0;i <= m;++ i)
        ans = Max(dp[1][i],ans);
    Put(ans);
    return 0;
}
```

其实在dfs中的状态转移时还可以优化一下(for循环的边界问题)

但为了方便理解 ~~作者比较懒~~ ，就不改了



---

## 作者：Grisses (赞：5)

[题面](https://www.luogu.com.cn/problem/P3262)

显然，本题是一道树形 DP 题。

我们设 $w_{i,j}$ 表示第 $i$ 个公民参加战争时且他的第 $j$ 个直系上司管理战争时带来的贡献，$f_{i,j}$ 表示第 $i$ 个公民参加种植时且他的第 $j$ 个直系上司管理后时是带来的贡献。容易发现，$w,f$ 的第一维的范围是 $2^{n-1}+1\sim2^n$（因为这一区间内的公民都是平民，只有他们会带来贡献）。$dp_{i,j}$ 表示第 $i$ 个公民管理的平民中有 $j$ 个参加战争时得到的最大贡献值。

然后我们开始树形 DP，由于这是一棵满二叉树，所以我们可以用 $\times 2$ 或 $/2$ 的方式存储树。先向下搜索，在搜索的过程中不断枚举目前搜到的节点的贡献是什么类别,并将其记录下来。在搜到叶子节点也就是平民时，我们通过这搜下来的一条链上的标记来更新这个平民为后勤和战争做贡献的贡献。

然后在回溯中，我们通过枚举每一个公民的左右子树中参与战争的平民数量来转移 DP 式：

$$dp_{i,j}=\max\limits_{k=0}^{j}dp_{2i,k}+dp_{2i+1,j-k}$$

最后，因为最多只能有 $m$ 个平民参与战争，所以答案就是 $\max\limits_{i=0}^mdp_{1,i}$。

代码：
```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int n,m,ans,w[1050][15],f[1050][15],dp[1050][1050],vis[15];
  void dfs(int x,int y){
      for(int i=0;i<=1<<(n-y+1);i++)dp[x][i]=0;
      if(y==n){//搜到了平民
          dp[x][1]=dp[x][0]=0;//初始化
          for(int i=1;i<=n;i++){
              if(vis[i])dp[x][1]+=w[x][i];//贡献的是战争
              else dp[x][0]+=f[x][i];//贡献的是后勤
          }
          return;
      }
      vis[n-y]=0;//标记这个人是为后勤做贡献
      dfs(x<<1,y+1);
      dfs(x<<1|1,y+1);//递归
      for(int i=0;i<=(1<<(n-y));i++){
          for(int j=0;j<=(1<<(n-y));j++){枚举左右子树中平民对他的贡献
              dp[x][i+j]=max(dp[x][i+j],dp[x<<1][i]+dp[x<<1|1][j]);//更新
          }
      }
      vis[n-y]=1;//标记这个人是为战争做贡献
      dfs(x<<1,y+1);
      dfs(x<<1|1,y+1);
      for(int i=0;i<=(1<<(n-y));i++){
          for(int j=0;j<=(1<<(n-y));j++){
              dp[x][i+j]=max(dp[x][i+j],dp[x<<1][i]+dp[x<<1|1][j]);
          }
      }//同上
  }
  signed main()
  {
      scanf("%d%d",&n,&m);
      n--;
      for(int i=0;i<(1<<n);i++){
          for(int j=1;j<=n;j++){
              scanf("%d",&w[(1<<n)+i][j]);
          }
      }
      for(int i=0;i<(1<<n);i++){
          for(int j=1;j<=n;j++){
              scanf("%d",&f[(1<<n)+i][j]);
          }
      }
      dfs(1,0);
      for(int i=0;i<=m;i++)ans=max(ans,dp[1][i]);//最多只能有m个平民参与战争
      printf("%d",ans);
  }
```

---

## 作者：lihaoda0120 (赞：3)

# [战争调度](https://www.luogu.com.cn/problem/P3262)

# 思路

比较不同的树上 dp，可以说是搜索+dp。

首先，一个平民必须知道他的所有祖先的状态才能计算出他的贡献，所以我们可以先爆搜出所有当前点 $u$ 到根的点的状态，然后计算**在 $fa_u$ 到根的点的状态确定的情况下，以 $u$ 为根的子树的 dp 答案**，令 $dp_{u,i}$ 表示点 $u$ 的子树里选了 $i$ 个平民参战的最大贡献，我们枚举点 $u$ 是参战还是后勤，然后先递归到儿子，再用儿子的 $dp$ 数组来更新自己的 $dp$ 数组。

或者也可以认为 $dp_{u,i,S}$ 表示以点 $u$ 为根的子树里选了 $i$ 个平民参战，且根到 $fa_u$ 的点的状态为 $S$ 的最大贡献。

时间复杂度：$\sum_{i=0}^{n-1} 2^{n-1-i}\times 2^{2i-2}\times 2^{n-1-i}=\sum_{i=0}^{n-1} 2^{2n-4}=n\times 2^{2n-4}$，大约 $10^6$。

这题其实看起来很像暴力，那他和暴力的不同之处在哪呢？我们在点 $u$ 将两个子树递归完后，暴力是将两个子树的所有情况一一组合，时间是左右两边方案数之积，而正解使用 dp 将两边的结果合并，自然快很多。

# 代码

```cpp
#include<bits/stdc++.h>
#define fre(name) freopen(name".in","r",stdin),freopen(name".out","w",stdout)
#define psb push_back
#define ppb pop_back
#define fi first
#define se second
#define endl '\n'
using namespace std;
const int N=10;
int n,m,w[1<<N][N],f[1<<N][N],vis[N],dp[1<<N][1<<N];
#define lc (u<<1)
#define rc (u<<1|1)
void dfs(int u,int y){
	for(int i=0;i<=1<<y;i++)dp[u][i]=0;
	if(y==0){
		for(int i=1;i<n;i++){
			if(vis[i])dp[u][1]+=w[u][i];
			else dp[u][0]+=f[u][i];
		}
		return;
	}
	for(int k=0;k<=1;k++){
		vis[y]=k;
		dfs(lc,y-1),dfs(rc,y-1);
		for(int i=0;i<=1<<(y-1);i++)
			for(int j=0;j<=1<<(y-1);j++)
				dp[u][i+j]=max(dp[u][i+j],dp[lc][i]+dp[rc][j]);
	}
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1<<(n-1);i<1<<n;i++)for(int j=1;j<n;j++)cin>>w[i][j];
	for(int i=1<<(n-1);i<1<<n;i++)for(int j=1;j<n;j++)cin>>f[i][j];
	dfs(1,n-1);
	int ans=0;
	for(int i=0;i<=m;i++)ans=max(ans,dp[1][i]);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Lyrella (赞：2)

# 简要题意

有一棵不超过十层的满二叉树，需要对每个节点进行染色。每个叶子节点会对其颜色相同的祖先节点产生贡献且黑白贡献不同。求最大贡献。

# 题解

首先我会暴力！我如果直接暴力枚举每个节点的颜色，复杂度就是 $O(2^{2^n})$。然后还要算贡献，所以还有一个 $O(2^{n-1}(n-1))$。然后肯定爆了。

不用说都知道是因为我们在枚举的时候重复枚举了很多相同的状态，这时我们应该单独考虑贡献。对于一个点，它的贡献应该只与其祖先节点有关，而我们暴力是去枚举了其他无关的节点。所以我们就可以设计一个 $f_{u,S}$ 表示当前考虑到 $u$ 节点，$u$ 的祖先状态为 $S$ 时子树最大贡献。然后题目中还有对黑点的个数限制，所以我们还需要加一维表示子树内黑点个数。所以最终状态是 $f_{u,S,cnt}$ 表示 $u$ 的子树内，其祖先染色状态为 $S$ 且子树内有 $cnt$ 个黑点时最大贡献。然后对于任意节点，假设它在第 $x$ 层，则它的祖先结点状态数为 $2^{x-1}$，子树大小为 $2^{n-x+1}-1$，所以时间复杂度为 $O(n\times2^n)$。但是空间是 $O(n\times2^{2n})$，所以我们就在搜索状态的过程中记录一个状态 $S$，数组就只用开二维。

转移其实就是合并两个子树的信息，所以直接预处理出叶子节点的答案，然后跑一遍 $dfs$ 然后类似合并背包一样做即可。

# 代码

```cpp
inline void upd(int &x, int y){x = x > y ? x : y;}

void dfs(int u, int sta, int dep){
	if(dep == n)return(void)(f[u][0] = c[u - lim][sta][0], f[u][1] = c[u - lim][sta][1]);
	for(int i = 0; i <= qp[dep]; ++i)f[ls][i] = f[rs][i] = 0;
	dfs(ls, sta, dep + 1); dfs(rs, sta, dep + 1);
	for(int i = 0; i <= qp[dep]; ++i)for(int j = 0; j <= qp[dep]; ++j)upd(f[u][i + j], f[ls][i] + f[rs][j]);
	for(int i = 0; i <= qp[dep]; ++i)f[ls][i] = f[rs][i] = 0;
	dfs(ls, sta + qp[dep], dep + 1), dfs(rs, sta + qp[dep], dep + 1);
	for(int i = 0; i <= qp[dep]; ++i)for(int j = 0; j <= qp[dep]; ++j)upd(f[u][i + j], f[ls][i] + f[rs][j]);
}
signed main(){
	n = rd(), m = rd(); lim = 1 << n - 1;
	for(int i = 0; i < lim; ++i)for(int j = 0; j < n - 1; ++j)v[i][j][1] = rd();
	for(int i = 0; i < lim; ++i)for(int j = 0; j < n - 1; ++j)v[i][j][0] = rd();
	qp[n - 1] = 1; for(int i = n - 2; ~ i; --i)qp[i] = qp[i + 1] << 1;
	for(int i = 0; i < lim; ++i)for(int j = 0; j < lim; ++j)
		for(int k = 0, bit = i; k < n - 1; ++k, bit >>= 1)c[j][i][bit & 1] += v[j][k][bit & 1];
	dfs(1, 0, 1); int ans = 0;
	for(int i = 0; i <= m; ++i)upd(ans, f[1][i]);
	wt(ans);
}
```

---

## 作者：myyyIisq2R (赞：2)

状压枚举每个节点的状态复杂度是 $O(2^{2^{n}-1})$，可以过掉 $20$ 分。既然我们可以枚举祖先状态，通过祖先状态来算出当前贡献，我们就可以 $\text{dp}$ 了。注意到限制条件在叶子节点的打仗人数，不妨将叶子节点的打仗人数纳入状态。设 $f_{u,i}$ 表示节点编号为 $u$ ，子树中叶子节点中有 $i$ 个人打仗的最大贡献，便有 $f_{u,i+j} \Leftarrow \max(f_{u,i+j},f_{u<<1,i} + f_{u<<1|1,j})$，即从左右子树汇总答案。

然后只需要 $\text{dfs}$ 往下推的时候推两次不同的当前状态，推到叶子节点计算总答案，复杂度可类比线段树，为 $O(2^{n-1}\log 2^{n-1})$。再往上传，每次按照上式 $O(m^2)$ 算一下值，不断上推到根节点，在根上取最大值就完了。

```cpp
#define lson(x) x<<1
#define rson(x) x<<1|1
void dfs(int x,int s,int siz)
{
    for(int i{};i<=siz;i++) f[x][i] = 0;
    if(siz == 1)
    {
        for(int i{1};i<=n-1;i++)
            if((s >> (i-1)) & 1) f[x][1] += val1[x][i];
            else f[x][0] += val0[x][i];
        return;
    }
    for(int now{};now<=1;now++)
    {
        dfs(lson(x),s<<1|now,siz>>1),dfs(rson(x),s<<1|now,siz>>1);
        for(int i{};i <= min(siz,m);i++)
        for(int j{};j <= min(siz,m);j++)
            f[x][i+j] = max(f[x][i+j],f[lson(x)][i]+f[rson(x)][j]);
    }
}

signed main()
{
	#ifdef LOCAL
	freopen("in.in","r",stdin);
	#endif
 	n = read(),m = read();
    for(int i{qp(2,n-1)};i < qp(2,n);i++)
        for(int j{1};j < n;j++) val1[i][j] = read();
    for(int i{qp(2,n-1)};i < qp(2,n);i++)
        for(int j{1};j < n;j++) val0[i][j] = read();
    dfs(1,0,qp(2,n)-1);
    for(int i{};i<=m;i++)
        ans = max(f[1][i],ans);
    writeln(ans);
    return 0;
}
```

---

## 作者：Coros_Trusds (赞：2)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/16127952.html)

~~这道题是道好题，因为它非常好。如果你没有思路，那么你不妨去想想思路。废话文学万岁！！！~~

简单树形 $dp$。

# 题目大意

对于一颗 **满二叉树**，可以将叶子节点设置为两种状态（简称为 $0$ 和 $1$），如果该叶子节点与其某个祖先的状态相同，那么就有一个贡献值，两者都为 $0$ 或 $1$ 时对应两种不同的贡献值，求设置 $1$ 状态小于 $m$ 时的最大贡献。

# 题目分析

想出来一个沙雕 $dp$，令 $dp[i,j,0/1]$ 表示以 $i$ 为根的子树中有 $j$ 个节点在打仗且 $i$ 节点是否在打仗的最大总贡献值。

但是推状态推了半个小时无果，然后发现不需要第三维。。。。

令 $dp[i,j]$ 表示以 $i$ 为根的子树中有 $j$ 个节点在打仗的最大总贡献值。

所以状态转移为 $dp[now,i+j]=\max\{dp[now][i]+dp[now][j]\}$。即左子树的最优解加上右子树的最优解，$\verb!dfs!$ 的时候~~像 $\verb!dfs!$ 那样推就行了~~依次向下递归是否选择当前节点。

答案为 $\max\{dp[1][i]\}(i\in[1,m])$。

因为数据范围很小所以可以通过。

还是套路题，练少了啊。。。

# 代码

```cpp
//2022/4/9
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#define enter putchar(10)
#define debug(c,que) cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) cout << arr[i] << w;
#define speed_up() ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define Abs(x) ((x) > 0 ? (x) : -(x))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;
using namespace std;

const int N = 1025,M = 15;
int fight[N][M],food[N][M],dp[N][N];//dp[i][j]:以 i 为根的子树中有 j 个节点在打仗的最大总贡献值
bool vis[M];
int n,m;
inline void dfs(int now,int dep) {
	mst(dp[now],0);
	if (dep == 0) {//叶子节点
		for (register int i = 1;i <= n; ++ i) {
			if (vis[i]) {
				dp[now][1] += fight[now][i];
			} else {
				dp[now][0] += food[now][i];
			}
		}
		return;
	}
	vis[dep] = false;
	dfs(now << 1,dep - 1),dfs(now << 1 | 1,dep - 1);
	for (register int i = 0;i <= (1 << (dep - 1)); ++ i) {
		for (register int j = 0;j <= (1 << (dep - 1)); ++ j) {
			dp[now][i + j] = max(dp[now][i + j],dp[now << 1][i] + dp[now << 1 | 1][j]);
		}
	}
	vis[dep] = true;
	dfs(now << 1,dep - 1),dfs(now << 1 | 1,dep - 1);
	for (register int i = 0;i <= (1 << (dep - 1)); ++ i) {
		for (register int j = 0;j <= (1 << (dep - 1)); ++ j) {
			dp[now][i + j] = max(dp[now][i + j],dp[now << 1][i] + dp[now << 1 | 1][j]);
		}
	}
}
int main(void) {
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	n = read() - 1,m = read();
	for (register int i = 0;i < (1 << n); ++ i) {
		for (register int j = 1;j <= n; ++ j) {
			fight[i + (1 << n)][j] = read();
		}
	}
	for (register int i = 0;i < (1 << n); ++ i) {
		for (register int j = 1;j <= n; ++ j) {
			food[i + (1 << n)][j] = read();
		}
	}
	dfs(1,n);
	int ans = 0;
	for (register int i = 0;i <= m; ++ i) ans = max(ans,dp[1][i]);
	printf("%d\n",ans);

	return 0;
}
```

---

## 作者：C20203030 (赞：2)

## 战争调度

### 一、题目

[点此看题](https://www.luogu.org/problem/P3262)

### 二、解法

其实本题一看就是树形$dp$的题，可是状态的不确定性实在太大了，普通的树$dp$根本做不了。

考虑每个叶节点对答案的影响，发现每个叶节点只对该点到根节点的路径上的决策有直接影响，而因为我们的树是一个完全二叉数，且深度为$n$，所以我们在树$dp$中暴枚每个非叶节点的所有可能只会消耗$O(2^{n-1})$，这样我们就把树上非叶节点的状态确定了。

然后我们考虑确定叶节点的状态，把它放进$dp$式中，定义$f[i][j]$为第$i$个点的子树内的叶节点有$j$个点参军，然后跑背包即可，注意我们树$dp$时用了暴力枚举可能性，$f$数组要清零。

每一层算复杂度，可得$O(n2^{2n-4})$(如果你不会算，私信我吧qwq)


```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int MAXN = 1025;
int read()
{
	int x=0,flag=1;
	char c;
	while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
	while(c>='0' && c<='9') x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x*flag;
}
int n,m,Max,vis[10],a[MAXN][10],b[MAXN][10],f[MAXN][MAXN];
void dfs(int u,int y)
{
	for(int i=0;i<=1<<y;i++) f[u][i]=0;
	if(!y)
	{
		for(int i=1;i<=n;i++)
			if(!vis[i]) f[u][0]+=b[u][i];
			else f[u][1]+=a[u][i];
		return ; 
	}
	for(int k=0;k<=1;k++)
	{
		vis[y]=k;
		dfs(u<<1,y-1);dfs(u<<1|1,y-1);
		for(int i=0;i<=(1<<y-1);i++)
			for(int j=0;j<=(1<<y-1);j++)
				f[u][i+j]=max(f[u][i+j],f[u<<1][i]+f[u<<1|1][j]);
	}
}
int main()
{
	n=read();m=read();n--;
	for(int i=1<<n;i<1<<n+1;i++)
	{
		for(int j=1;j<=n;j++)
			a[i][j]=read();
	}
	for(int i=1<<n;i<1<<n+1;i++)
	{
		for(int j=1;j<=n;j++)
			b[i][j]=read();
	}
	dfs(1,n);
	for(int i=0;i<=m;i++) Max=max(Max,f[1][i]);
	printf("%d\n",Max);
}
```


---

## 作者：MikukuOvO (赞：2)

不难发现，如果一个叶子节点的所有祖先节点的颜色已经确定，那么这个叶子节点的最大贡献就可以确定，这样我们不难发现我们对于一个叶子节点只要枚举$2^{n-1}$个祖先节点即可。

我们考虑$f[x][i]$表示$x$节点的子树选择$i$个叶子节点去打架的最大贡献值，$f[x][i+j]=max(f[x][i+j],f[x<<1][i]+f[x<<1|1][j])$。

答案就是$max_{i=0}^{m}f[1][i]$。

---

## 作者：liuchang09 (赞：1)

## 思路
很显然是树上的动态规划。设 $f_{i,j}$ 表示以 $i$ 为根节点，他有 $j$ 个下属选择参加战争时的最大贡献。

对于树上动态规划，我们可以使用深度优先搜索。从第一个节点开始，先将储存最大贡献的数组初始化，再枚举他是否参加战争并用 $war_x$ 表示，最后枚举他的两个子节点并转移状态，边界就是当前节点到达最大深度时返回。又因为题中所说：

> 一个平民会对他的所有直系上司有贡献度

如果一个一个枚举并将叶子结点对他的父节点的贡献值累加到 $f_{i,j}$ 上显然不理智，因此我们可以将其累加到最底部的叶子结点上。

然后是动态转移方程，这个还是比较好想的：

$f_{i,j+k}=\max\{f_{i \times 2,j}+f_{i \times 2 + 1,k}\}(j,k \in [2^{n - 1},2^n - 1],i \in [1,2^n - 1])$。

最后是答案的统计，因为不多于 $m$ 个平民参加战争，因此答案为 $\max\{f_{1,i}\}(i \in [0,m])$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=1028;
int f[maxn][maxn];
int a[maxn][12],b[maxn][12];
bool war[12];
int n,m;
int k;//一共有k个平民 
int ans=-1;
int lz(int x){return 2*x;}
int rz(int x){return 2*x+1;}
inline int read(){
    int x=0;
    char c=getchar();
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9'){x=x*10+(c-'0');c=getchar();}
    return x;
}
void dfs(int x,int y){//当前节点和当前层数
	for(int j=0;j<=(1<<(n-y));j++)
		f[x][j]=0;
	if(y==n){
		for(int i=1;i<=n;i++){
			if(war[i]) f[x][1]+=a[x][i];
			else f[x][0]+=b[x][i];
		}
		return ;
	}
	for(int w=0;w<=1;w++){
		war[y]=w;
		dfs(lz(x),y+1);
		dfs(rz(x),y+1);
		for(int i=0;i<=(1<<(n-y-1));i++)
			for(int j=0;j<=(1<<(n-y-1));j++)
				f[x][i+j]=max(f[x][i+j],f[lz(x)][i]+f[rz(x)][j]);
	}
}
signed main(){
	//freopen("test.in","r",stdin);
	n=read();m=read();
	k=(1<<(n-1));
	for(int i=1;i<=k;i++)
		for(int j=1;j<=n-1;j++)
			a[k-1+i][n-j]=read();
	for(int i=1;i<=k;i++)
		for(int j=1;j<=n-1;j++)
			b[k-1+i][n-j]=read();
	dfs(1,1);
	for(int i=0;i<=m;i++)
		ans=max(ans,f[1][i]);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Sorato_ (赞：1)

# P3262 [JLOI2015] 战争调度 题解

## 题目大意

给定一棵 $n$ 层的完全二叉树，第 $i$ 号节点的儿子编号为 $2i$ 和 $2i+1$。给每个点钦定状态为 0/1，记为 $t(i)$。钦定完每个点的状态后，整棵树的价值定义为：
$$
\sum\limits_{i\geq 2^{n-1}}\sum\limits_{j\in anc(i)}[t(i)=t(j)]\cdot w(i,j,t(i))
$$
其中，$w(i,j,0/1)$ 是给定的。求任意钦定，整棵树的最大价值，要求叶子节点的 1 的个数不超过 $m$。$n\leq 10,m\leq 2^{n-1}$。

## Solve

考虑一个暴力的状压 DP：记 $f(u,s,i)$ 表示仅 $u$ 的子树，$u$ 的祖先链状态是 $s$ ，叶子节点选了 $i$ 个 1 的最大价值。转移比较简单，只是在朴素树背包的基础上加了一个枚举状态。时空复杂度似乎是 $O(2^{2n}m)$，约 $5\times 10^8$，不能通过。时间上可以卡一卡，但空间上是完全开不下的。

但是考虑， 对于一个节点 $u$，它的 $s$ 的范围不一定是严格的 $O(2^n)$，所以这个复杂度不是很真。由此我们考虑不把 $s$ 记录在 $f$ 中，而是在 dfs 时作为参数记录，对于每一种祖先链状态都去跑一遍树背包。空间复杂度 $O(2^nm)$，我们分析一下时间复杂度。

考虑对于一个在第 $i$ 层的点，它会被遍历到 $2^{i-1}$ 次，即把上面 $i-1$ 层祖先链的状态都枚举一遍。而第 $i$ 层的点有 $2^{i-1}$ 个。如果把每个点每一次被遍历到时，都认为它被复制了一遍，那么最后仍然是一棵树，且点数为：
$$
\sum\limits_{i=0}^{n-1}2^i\cdot2^i
$$
等比数列求和，化简后为 $2^{2n}-1\over 3$，记为 $V$。

再套一个树背包，所以总复杂度为 $O(mV)$，约 $1.8\times 10^8$，且极松，可以通过。

## Code

```c++
void dfs(int u,int s,int siz/*当前子树内叶节点个数*/)
{
	for(int i=0;i<=siz;i=-~i)	f[u][i]=0;
	if(u>=(n>>1))//叶节点
	{
		f[u][1]=f[u][0]=0;
		for(int i=0;i<dep-1;i=-~i)
			f[u][s>>i&1]+=a[s>>i&1][u][i];
		return;
	}
	for(int t=0;t<2;t=-~t)
	{
		dfs(u<<1,s<<1|t,siz>>1);dfs(u<<1|1,s<<1|t,siz>>1);
		for(int i=0;i<=m&&i<=(siz>>1);i=-~i)//树背包
			for(int j=0;i+j<=m&&j<=(siz>>1);j=-~j)
				f[u][i+j]=max(f[u][i+j],f[u<<1][i]+f[u<<1|1][j]);
	}
}
signed main()
{
	dep=read();m=read();n=1<<dep;
	for(int t=1;-~t;t=~-t)
		for(int i=n>>1;i<n;i=-~i)
			for(int j=0;j<dep-1;j=-~j)
				a[t][i][j]=read();
	dfs(1,0,n>>1);
	for(int i=0;i<=m;i=-~i)	ans=max(ans,f[1][i]);
	return printf("%d",ans),0;
}
```

---

## 作者：ybe2007 (赞：1)

好题，这是一种不同与平常树形 dp 的思路。

这种题目最显著的特征就是子节点的贡献与父亲有关，那么这时很显然一般的树形 dp，节点信息直接从儿子节点信息转移过来的方法，就不适用了。那么这类题应当如何分析呢？

既然叶子节点的贡献与其所有的祖先节点均有关，那么我们不妨**枚举祖先节点的状态**，到叶子结点时，算出贡献，向上传递更新最优解。

具体地，设 $f_x$ 表示 $x$ 这棵子树的最大贡献。注意到题目对当兵的个数存在限制，因此加一维，设 $f_{x,i}$ 表示 $x$ 这棵子树，选了 $i$ 个农民去当兵的最大贡献。

转移方程：$f_{x,i+j}=\max({f_{lson_x,i}+f_{rson_x,j}})$。

答案更新部分代码如下（之后会小改）：

```cpp
	dfs(x<<1,dep+1,s|(1<<n-dep-1)),dfs(x<<1|1,dep+1,s|(1<<n-dep-1));
	for(int i=0;i<=m;i++) for(int j=0;j<=m-i;j++) g[x][i+j]=max(g[x][i+j],g[x<<1][i]+g[x<<1|1][j]);
	dfs(x<<1,dep+1,s),dfs(x<<1|1,dep+1,s);
	for(int i=0;i<=m;i++) for(int j=0;j<=m-i;j++) g[x][i+j]=max(g[x][i+j],g[x<<1][i]+g[x<<1|1][j]);
```

至此我们已经得到了大体思路，现在可以尝试分析一下时间复杂度了。

上述代码内层循环 $O(m^2)$。

由以上的分析，我们知道每个节点有两种决策，向下传递后，复杂度显然呈指数级增长。现在我们来看一下每个节点被遍历的次数。

![](https://cdn.luogu.com.cn/upload/image_hosting/e3n6p0rf.png)

容易发现，对于第 $dep$ 层的节点，其被遍历次数为 $2^{dep-1}$。由于内层一致，分配率提出来，外层运用等比数列求和，算出总遍历次数为 $\dfrac{4^n-1}{3}$，乘上 $m^2$，发现时间复杂度爆炸了（吸氧 80pts）。

那么如何优化呢？事实上只用对内层的循环进行优化即可。设当前深度为 $dep$（深度从 $1$ 开始），由于当士兵的人数不会超过子树内叶子结点的个数 $2^{n-dep}$ 次，因此内层循环完全没必要 $m^2$，而是只到 $2^{n-dep}$ 即可。

这时再来看一下计算量，每一层被遍历 $2^{dep-1}$，每层 $2^{dep-1}$ 个节点，内层循环为 $2^{n-dep}$，因此总计算量三者相乘，逐层求和，为 $\sum\limits_{dep=1}^{n}2^{n+dep-1}$，再用等比数列求和，最后的答案即为 $4^n-2^n$。

经过大致的计算分析，得到最终时间复杂度约为 $O(4^n)$。

附上最后代码：

```cpp
#include<bits/stdc++.h>
#define N 1105
#define I inline
using namespace std;
int n,m;
int w[N][15],f[N][15];
int g[N][N];
void dfs(int x,int dep,int s,int siz)
{
	for(int i=0;i<=siz;i++) g[x][i]=0;
	if(dep==n)
	{
		for(int i=1;i<n;i++)
		{
			if(s&(1<<i-1)) g[x][1]+=w[x][i];
			else g[x][0]+=f[x][i];
		}
		return ;
	}
	dfs(x<<1,dep+1,s|(1<<n-dep-1),siz>>1),dfs(x<<1|1,dep+1,s|(1<<n-dep-1),siz>>1);
	for(int i=0;i<=min(m,siz>>1);i++) for(int j=0;j+i<=m&&j<=siz>>1;j++) g[x][i+j]=max(g[x][i+j],g[x<<1][i]+g[x<<1|1][j]);
	dfs(x<<1,dep+1,s,siz>>1),dfs(x<<1|1,dep+1,s,siz>>1);
	for(int i=0;i<=min(m,siz>>1);i++) for(int j=0;j+i<=m&&j<=siz>>1;j++) g[x][i+j]=max(g[x][i+j],g[x<<1][i]+g[x<<1|1][j]);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=(1<<n-1);i++)
	{
		int idf=(1<<n-1)+i-1;
		for(int j=1;j<n;j++) scanf("%d",&w[idf][j]);
	}
	for(int i=1;i<=(1<<n-1);i++)
	{
		int idf=(1<<n-1)+i-1;
		for(int j=1;j<n;j++) scanf("%d",&f[idf][j]);
	}
	dfs(1,1,0,1<<n-1);
	int ans=0;
	for(int i=0;i<=m;i++) ans=max(ans,g[1][i]);
	printf("%d\n",ans);
}
```

---

## 作者：Starlight_Glimmer (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P3262)

#### 题目解析

乍一想有$2^{2^n}$种状态，直接暴力不太可取。

考虑树$dp$的话，设$dp[i]$表示子树$i$的答案，由于有个$m$的限制，我们设$dp[i][j]$表示子树$i$内有$j$个人选择作战的最大贡献。

但是这样很难转移，因为我们不知道儿子们选了啥。

但如果从儿子们的角度来考虑，若一个叶结点的所有祖先结点的状态确定，那么这个叶结点的贡献可以直接算出来。而每个叶结点有$2^{n-1}$个祖先，如果枚举它们的祖先的状态，复杂度消耗只有$2^{n-1}$，再乘上叶结点个数，时间复杂度是$2^{n-1}\times 2^{n-1}=2^n$。

所以相当于可以枚举一条链上的每个点的状态，用类似于状压的方式存状态，然后到了叶子结点可以转移上去。

（我在想这样枚举复杂度不是狂野的$2^{2^n}$应该是因为，它是按照父子关系枚举下来的，按照每一条链的顺序枚举下来，左右儿子通过$dp$的方式合并答案，而不是像直接暴力那样，链与链之间通过枚举状态计算答案，（有点像背包那个意思），把链与链之间的复杂度从加法变成了乘法）

每个点还有转移$dp[u][i+j]=max(dp[u<<1][i]+dp[u<<1|1][j])$，这里还有个$n$的复杂度，所以总时间复杂度应该是$O(n2^n)$



------

#### ►Code View

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
#include<queue>
using namespace std;
#define LL long long
#define N 15
#define K 5000
#define INF 0x3f3f3f3f
int rd()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1; c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48); c=getchar();}
	return f*x;
}
int n,m,k,ans;
int w[K][N],f[K][N];//war farm 
int dp[K][K];//以i为根的子树内有j个平民作战的最大贡献 
void dfs(int u,int s,int d)//u为子树根节点 s为祖先的状态(状压 1作战 0后勤) d为子树大小 
{
	for(int i=0;i<=d;i++)
		dp[u][i]=0;
	//记得清空 下面的dp值在根选另一个选项时算过 
	if(d==1)
	{//叶子结点 
		for(int i=0;i<n-1;i++)
		{//枚举n-1个祖先 高位是比较老的祖先 爸爸是最低位 
			if((s>>i)&1)//第i个祖先作战 
				dp[u][1]+=w[u-(k-1)][i+1]; 
			else dp[u][0]+=f[u-(k-1)][i+1];
		}
		return ;
	}
	for(int sit=0;sit<=1;sit++)
	{//枚举当前为作战/后勤 
		dfs(u<<1,(s<<1)|sit,d>>1);
		dfs(u<<1|1,(s<<1)|sit,d>>1);
		for(int i=0;i<=min(d,m);i++)
			for(int j=0;j<=min(d,m);j++)
				dp[u][i+j]=max(dp[u][i+j],dp[u<<1][i]+dp[u<<1|1][j]); 
	}
} 
int main()
{
	n=rd(),m=rd();
	k=1<<(n-1);//叶子结点个数 
	for(int i=1;i<=k;i++)
		for(int j=1;j<=n-1;j++)
			w[i][j]=rd();
	for(int i=1;i<=k;i++)
		for(int j=1;j<=n-1;j++)
			f[i][j]=rd();
	dfs(1,0,(1<<n)-1);
	for(int i=0;i<=m;i++)
		ans=max(ans,dp[1][i]);
	printf("%d\n",ans); 
	return 0;
}
```


---

## 作者：PosVII (赞：1)

**前言**

------------

树形 dp 练习题。题面里的完全二叉树其实是满二叉树。

**思路**

------------

不难发现，一颗树只会影响这颗树下的节点，而一棵树的状态可以由它的两颗子树再枚举根节点状态得到，也就是说无后效性，那么可以使用树形 dp。

因为一棵树的根只会影响其树下所有叶子节点而不影响其他非叶子节点，所以直接枚举其状态到叶子节点并计算叶子节点的贡献即可，递归时需要记录路径上节点的状态。

**code**

------------

```
#include<bits/stdc++.h>
using namespace std;
template<typename G>inline void read(G&x){x=0;G f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+(ch^48),ch=getchar();x*=f;}
const int MAXN=3000,N=600;
int head[MAXN],to[MAXN],nxt[MAXN],cnt;
void add(int u,int v) {
	nxt[++cnt]=head[u];
	head[u]=cnt;
	to[cnt]=v;
}
void addt(int u,int v) {
	add(u,v);
	add(v,u);
}
int n,m,V,dp[MAXN][N],w[N][20],f[N][20];
int u,v,ans;
void dfs(int p,int s,int mem) {
	for(int i=min(m,mem);i>=0;--i) dp[p][i]=0;
	if(mem==1) {
		for(int i=1;i<n;++i) {
			if(s&(1<<(i-1))) {
				dp[p][1]+=w[p-V+1][i];
			}
            else {
            	dp[p][0]+=f[p-V+1][i];
			}
		}
        return;
	}
	for(int i=0;i<=1;++i) {
		dfs(p<<1,s<<1|i,mem>>1);
		dfs(p<<1|1,s<<1|i,mem>>1);
		for(int i=min(mem,m);i>=0;--i) {
			for(int j=0;j<=i;++j) {
				dp[p][i]=max(dp[p][i],dp[p<<1][j]+dp[p<<1|1][i-j]);
			}
		}
	}
}
int main() {
	read(n),read(m);
	V=1<<(n-1);
	for(int i=1;i<=V;++i) {
		for(int j=1;j<n;++j) {
			read(w[i][j]);
		}
	} 
	for(int i=1;i<=V;++i) {
		for(int j=1;j<n;++j) {
			read(f[i][j]);
		}
	} 
	dfs(1,0,(1<<n)-1);
	for(int i=0;i<=m;++i) ans=max(ans,dp[1][i]);
	printf("%d",ans);
	return 0;
}
/*
7
1 1
1 1
2 1
3 1
2 3
5 1
*/
```

---

## 作者：lihongqian__int128 (赞：0)

如果你想到枚举平民去打架还是种地，那么你就想偏了。

考虑枚举贵族管打架还是种地。

你可能会说：这样时间不是 $\Theta(2^{2^{n-1}})$ 的吗？这样能过吗？

我们发现，每一个平民只会影响他上边的 $n-1$ 个贵族，我们不需要枚举完所有的贵族再计算，每次只用枚举一条国王到平民的路径。这样，时间复杂度是比较优秀的。

然后，怎么计算贡献呢？

考虑背包。

定义 $dp_{i,j}$ 表示 $i$ 的子树内有 $j$ 个平民去打架的最大贡献。

如果 $i$ 是平民，贡献直接算。

如果 $i$ 是贵族，那么有转移：$dp_{i,j}\gets\max\limits_{k=0}^j(dp_{2i,k}+dp_{2i+1,j-k})$。

然后，加一个小优化：我们发现，$i$ 的子树内的平民数不会很多，所以转移的时候可以和 $i$ 子树内的平民数取 min。

吐槽一句：这题的样例是真的【数据删除】，错了一大堆地方还能过……

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,w[1055][15],f[1055][15],dp[1055][1055];
bool l[15];
void dfs(int x,int dep){
	if(dep==n){
		int s0=0,s1=0;
		for(int i=1;i<n;i++){
			if(l[dep-i]==0)s0+=w[x][i];
			else s1+=f[x][i];
		}
		dp[x][1]=s0,dp[x][0]=s1;
		return;
	}
	for(int i=0;i<=min((1<<(n-dep)),m);i++)dp[x][i]=0;
	l[dep]=1;
	dfs(x*2,dep+1);
	dfs(x*2+1,dep+1);
	for(int le=0;le<=min((1<<(n-dep-1)),m);le++)
		for(int ri=0;ri<=min((1<<(n-dep-1)),m);ri++)
			dp[x][le+ri]=max(dp[x][le+ri],dp[x*2][le]+dp[x*2+1][ri]);
	l[dep]=0;
	dfs(x*2,dep+1);
	dfs(x*2+1,dep+1);
	for(int le=0;le<=min((1<<(n-dep-1)),m);le++)
		for(int ri=0;ri<=min((1<<(n-dep-1)),m);ri++)
			dp[x][le+ri]=max(dp[x][le+ri],dp[x*2][le]+dp[x*2+1][ri]);
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=(1<<(n-1));i++)
		for(int j=1;j<n;j++)
			cin>>w[(1<<(n-1))-1+i][j];
	for(int i=1;i<=(1<<(n-1));i++)
		for(int j=1;j<n;j++)
			cin>>f[(1<<(n-1))-1+i][j];
	dfs(1,1);
	int ans=0;
	for(int i=0;i<=m;i++)ans=max(ans,dp[1][i]);
	cout<<ans;
	return 0;
}
```

---

## 作者：Kelvin2009 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P3262)

这是一道特殊的树形动态规划。

普通的树形动态规划普遍表示此节点选不选的状态，并对其它节点产生影响，此题显然不可行。

由于只对参战的平民数有 $m$ 的限制，考虑 $dp_{i,j}$ 表示对于根节点为 $i$ 的子树，共有 $j$ 个平民参战，整棵子树的最大总贡献度。

显然，可根据当前点参军还是善后遍历其下子树，回溯后算最大总贡献度可通过枚举左右子树各有多少平民参军。

最后统计答案，只取不多于 $m$ 个平民参战的状态作为可能答案。

**有一点注意：$dp_{i,j}$ 需重复使用，每次使用前初始化！**

------------
代码：

------------
```cpp
#include<bits/stdc++.h>
#define p_num 1<<n
#define lson pos<<1
#define ran 1<<(n-1)
#define rson pos<<1|1
#define t_ran 1<<base
using namespace std;
const int number=15;
const int range=2005;
bool flag[range];
int n,m,ans,pos_num,dp[range][range],val[range][number][2];
void dfs(int pos,int base)
{
	for(int i=0;i<=t_ran;i++) dp[pos][i]=0;
	if(!base)
    {
        for(int i=1;i<n;i++) (flag[i])?(dp[pos][1]+=val[pos][i][0]):(dp[pos][0]+=val[pos][i][1]);
        return ;
    }
	flag[base]=0,dfs(lson,base-1),dfs(rson,base-1);
	for(int i=0;i<=(t_ran>>1);i++) for(int j=0;j<=(t_ran>>1);j++) dp[pos][i+j]=max(dp[pos][i+j],dp[lson][i]+dp[rson][j]);
	flag[base]=1,dfs(lson,base-1),dfs(rson,base-1);
	for(int i=0;i<=(t_ran>>1);i++) for(int j=0;j<=(t_ran>>1);j++) dp[pos][i+j]=max(dp[pos][i+j],dp[lson][i]+dp[rson][j]);
	return ;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=ran;i<p_num;i++) for(int j=1;j<n;j++) scanf("%d",&val[i][j][0]);
	for(int i=ran;i<p_num;i++) for(int j=1;j<n;j++) scanf("%d",&val[i][j][1]);
	dfs(1,n-1);
	for(int i=0;i<=m;i++) ans=max(ans,dp[1][i]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：_Imaginary_ (赞：0)

我们令

$$
dp[i][j][S]
$$

表示以 $i$ 节点为根的子树，有 $j$ 个选战争，且 $i$ 到根的节点状态确定（存在 $S$ 里面）的最大贡献。 

那么，我们可以这样设计转移：

$$
dp[i][j][S]=\sum\limits_{k=0}^{j} dp[lc][k][ls]+dp[rc][j-k][rs]
$$

其中 $ls$, $rs$表示加入子节点后到状态。

另外，在叶子节点处理一下整条链的就行。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=12,M=1145;
const bool W=0,F=1;
int n,m,tn;
ll dp[M][M];//以i为根的子树中有j个选战争的（对祖先）最大贡献
ll w[M][N],f[M][N];
bool flag[M];//0=w,1=f
void dfs(int u,int dep)
{
	memset(dp[u],0,sizeof(dp[u]));
	if(dep==n)
	{
		for(int i=1;i<n;i++)
			if(flag[u>>i]==W) dp[u][1]+=w[u][i];
			else dp[u][0]+=f[u][i];
		return;
	}
	flag[u]=W; dfs(u*2,dep+1); dfs(u*2+1,dep+1);
	for(int i=0;i<=(1<<(n-dep));i++)
		for(int j=0;j<=(1<<(n-dep));j++)
			dp[u][i+j]=max(dp[u][i+j],dp[u*2][i]+dp[u*2+1][j]);
	flag[u]=F; dfs(u*2,dep+1); dfs(u*2+1,dep+1);
	for(int i=0;i<=(1<<(n-dep));i++)
		for(int j=0;j<=(1<<(n-dep));j++)
			dp[u][i+j]=max(dp[u][i+j],dp[u*2][i]+dp[u*2+1][j]);
}
int main()
{
	scanf("%d%d",&n,&m);
	tn=1<<(n-1);
	for(int i=tn;i<tn*2;i++)
		for(int j=1;j<=n-1;j++)
			scanf("%lld",&w[i][j]);
	for(int i=tn;i<tn*2;i++)
		for(int j=1;j<=n-1;j++)
			scanf("%lld",&f[i][j]);
	memset(dp,0,sizeof(dp));
	dfs(1,1);
	ll ans=0;
	for(int i=0;i<=m;i++) ans=max(ans,dp[1][i]);
	printf("%lld",ans);
	return 0;
}
```

---


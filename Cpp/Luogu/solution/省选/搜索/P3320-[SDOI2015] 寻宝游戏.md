# [SDOI2015] 寻宝游戏

## 题目描述

小 B 最近正在玩一个寻宝游戏，这个游戏的地图中有 $N$ 个村庄和 $N-1$ 条道路，并且任何两个村庄之间有且仅有一条路径可达。游戏开始时，玩家可以任意选择一个村庄，瞬间转移到这个村庄，然后可以任意在地图的道路上行走，若走到某个村庄中有宝物，则视为找到该村庄内的宝物，直到找到所有宝物并返回到最初转移到的村庄为止。

小 B 希望评测一下这个游戏的难度，因此他需要知道玩家找到所有宝物需要行走的最短路程。但是这个游戏中宝物经常变化，有时某个村庄中会突然出现宝物，有时某个村庄内的宝物会突然消失，因此小 B 需要不断地更新数据，但是小 B 太懒了，不愿意自己计算，因此他向你求助。为了简化问题，我们认为最开始时所有村庄内均没有宝物。

## 说明/提示

- 对于 $10\%$ 的数据，$1 \leq N \leq 100, 1 \leq M \leq 100$；
- 对于 $20\%$ 的数据，$1 \leq N \leq 1000, 1 \leq M \leq 1000$；
- 对于另外 $15\%$ 的数据，每个村庄最多成为两条道路的端点；
- 对于 $100\%$ 的数据，$1 \leq N \leq 100000,\ 1 \leq M \leq 100000,\ 1 \leq z \leq 10^9$。

## 样例 #1

### 输入

```
4 5
1 2 30
2 3 50
2 4 60
2
3
4
2
1```

### 输出

```
0
100
220
220
280```

# 题解

## 作者：小粉兔 (赞：93)

在博客园食用更佳：[https://www.cnblogs.com/PinkRabbit/p/10356940.html](https://www.cnblogs.com/PinkRabbit/p/10356940.html)

### 题意简述：

一棵 $n$ 个节点的树，边有边权。

每个点可能是关键点，每次操作改变一个点是否是关键点。

求所有关键点形成的极小连通子树的边权和的两倍。

### 题解：

有一个结论：DFS 序求出后，假设关键点按照 DFS 序排序后是 $\{a_1,a_2,\ldots ,a_k\}$。

那么所有关键点形成的极小连通子树的边权和的两倍等于 $\mathrm{dist}(a_1,a_2)+\mathrm{dist}(a_2,a_3)+\cdots+\mathrm{dist}(a_{k-1},a_k)+\mathrm{dist}(a_k,a_1)$。

画个图感性理解一下，应该是很好懂的。

那么求一下 DFS 序，每次操作相当于往集合里加入/删除一个元素。

假设插入 $x$，它DFS序左右两边分别是 $y$ 和 $z$。那么答案加上 $\mathrm{dist}(x,y)+\mathrm{dist}(x,z)-\mathrm{dist}(y,z)$ 即可。

删除同理。还有，求 LCA 就用个倍增或者树剖吧，Tarjan 离线比较麻烦。

用 STL 自带的 set 容器维护起来很方便。你也可以手写树状数组/线段树/平衡树。

```cpp
#include <cstdio>
#include <set>

typedef long long LL;
const int MN = 100005;

int N, M;
int h[MN], nxt[MN * 2], to[MN * 2], w[MN * 2], tot;
inline void ins(int x, int y, int z) {
	nxt[++tot] = h[x], to[tot] = y, w[tot] = z, h[x] = tot;
}

int dfn[MN], idf[MN], dfc;
int dep[MN], faz[MN][17];
LL dis[MN];

void DFS(int u, int fz) {
	dfn[u] = ++dfc; idf[dfc] = u; dep[u] = dep[faz[u][0] = fz] + 1;
	for (int j = 1; 1 << j < dep[u]; ++j) faz[u][j] = faz[faz[u][j - 1]][j - 1];
	for (int i = h[u]; i; i = nxt[i]) if (to[i] != fz) dis[to[i]] = dis[u] + w[i], DFS(to[i], u);
}

inline int lca(int x, int y) {
	if (dep[x] < dep[y]) std::swap(x, y);
	for (int d = dep[x] - dep[y], j = 0; d; d >>= 1, ++j)
		if (d & 1) x = faz[x][j];
	if (x == y) return x;
	for (int j = 16; ~j; --j) if (faz[x][j] != faz[y][j])
		x = faz[x][j], y = faz[y][j];
	return faz[x][0];
}

inline LL dist(int x, int y) { return dis[x] + dis[y] - 2 * dis[lca(x, y)]; }

bool vis[MN];
std::set<int> st;
std::set<int>::iterator it;
LL Ans;

int main() {
	scanf("%d%d", &N, &M);
	for (int i = 1, x, y, z; i < N; ++i) {
		scanf("%d%d%d", &x, &y, &z);
		ins(x, y, z), ins(y, x, z);
	}
	DFS(1, 0);
	for (int m = 1, x, y, z; m <= M; ++m) {
		scanf("%d", &x);
		x = dfn[x];
		if (!vis[idf[x]]) st.insert(x);
		y = idf[(it = st.lower_bound(x)) == st.begin() ? *--st.end() : *--it];
		z = idf[(it = st.upper_bound(x)) == st.end() ? *st.begin() : *it];
		if (vis[idf[x]]) st.erase(x);
		x = idf[x];
		LL d = dist(x, y) + dist(x, z) - dist(y, z);
		if (!vis[x]) vis[x] = 1, Ans += d;
		else vis[x] = 0, Ans -= d;
		printf("%lld\n", Ans);
	}
	return 0;
}
```

---

## 作者：Hzao (赞：30)

自己搞出来一种树状数组+倍增的做法，A掉之后发现网上的题解都是平衡树。心里还是有点美滋滋。

于是决定分享出来。~~（其实只是想找个借口颓废一下）~~

不过其实非常简单，耐心读一读就懂了。

在阅读实现部分之前，请不要考虑“这个操作怎么实现呢？”“时间复杂度会不会过高？”这类的问题。否则很可能你会很快放弃阅读。先理解这种做法的流程即可。（可以先剧透一下：时间复杂度大约是$O(m\,log^2n)$）

### 题意分析

分析一下题意，其实就是给定一棵树，在这棵树上选择某几个节点（设这几个节点的集合为$S$），求从其中的某个节点出发，经过所有被选择的节点后再回到出发点的最短路径长度。

从起点到终点，和从终点到起点的路径长度$L$是一样的，仅仅是沿原路返回而已。

也就是说，我们要求的即是将所有$S$中的节点连接起来的路径长度的二倍，即$2L$。

下两图分别是$S=\{3,4,6\}$时的路径和$S=\{1,2,3\}$时的路径，请自行理解，我就不再赘述。

(在机房只能用Windows 7的画图工具，只能说还算能看吧)

![](https://img.hzao.top/data/图1(a).png)

![](https://img.hzao.top/data/图1(b).png)

那么，我们可以求出把选择的所有节点连接起来的最短路径，然后输出它的二倍。

于是题目就变成了，动态维护使树上某些节点连通的最短路径长度，并且在每一次修改操作完成后输出这个长度的二倍。

### 解决方案

题目中有两种操作，增加选择的节点和删除选择的节点。

假设要处理的节点为$u$，我们先考虑将向$S$中增加$u$的情况。删除$u$的情况是可以建立在增加$u$的情况之上的：令$S'=S-\{u\}$,在$S$中删除$u$的花费就是在$S'$中增加$u$的花费——他们是前后两种路径长度的差。

现在考虑增加$u$时的情况。

情况1.$|S|=0$，即$S$中还没有任何节点。向其中加入$u$也不会产生任何长度。因此可以不修改答案。

情况2.在原图中，$u$至少有两个子节点(设其中一个为$v$) ，满足以$v$为根节点的子树中有节点属于$S$。

于是$u$是属于$S$的2个（或更多）点的$LCA$，使他们连通则必须经过$u$。那么，在加入$u$之前，使节点连通的路径就已经经过了$u$，因此可以不修改答案。

如下图所示，$4$的两个子节点$5,8$的子树中都至少有一个节点在$S$中，在加入$4$之前，连通$S$中节点的路径就已经经过了$4$。即加入$4$也不会对答案造成影响。

![](https://img.hzao.top/data/图2_a.png)

情况3.在原图中，以$u$为根的子树中有节点属于$S$，并且以$u$为根的子树外也有节点属于$S$。

那么同上，在加入$u$之前，使节点连通的路径已经经过了$u$。换句话说，$u$的加入不会对路径长度造成影响，因此不需要修改答案。

如图所示，假如要加入$5$，在加入$5$之前已有$4,7 \in S$，连接$4,7$的路已经覆盖了$5$，因此加入$5$不会使答案改变。

![](https://img.hzao.top/data/图2_b.png)

情况4.不满足上述三种情况中的任何一个。

那么我们需要找到一个在原路径上的点$v$,满足$dist(u,v)$最小。并且使答案加上$dist(u,v)$。

寻找$v$的方法是，从$u$开始向上倍增，找到离$u$最近的，且子树中有节点属于$S$的点。设这个点为$y$。

那么：

$a.$假如$y$在原有路径上，即加入$u$之前，$y$就被使节点连通的路径覆盖。也就是说，$y$满足情况2或情况3。

此时$v=y$。

那么只需要让答案加上$dist(u,y).$

即，如下图所示：

$u=9,S=\{3,4,7\}$，$4$是$u$ 能到达的 最近的 子树中有节点在$S$中的 点。

那么只需要将$9$与$4$连接起来即可。

![](https://img.hzao.top/data/图2_c.png)

$b.$假如$y$不在原有路径上，那么以$y$的子树外一定没有节点在$S$中。（否则满足情况3，原有路径一定经过$y$）

也就是说，$S$中的点全部都在以$y$为根的子树中。

我们只需要在这当中选择一个离$u$最近的点，将它与$u$连起来即可。

如下图所示：

![](https://img.hzao.top/data/图2_d.png)





那如何寻找离$u$最近的$v$呢？（请先往上翻，确认自己已知悉$u,y,v$的含义后再继续阅读）

由$dist(v,u)=dist(v,y)+dist(y,u)$可知，无论选择哪个点，都有一段$dist(y,u)$，而这段距离是已固定的。（当前只有$v$不确定）

所以我们要找的其实是$dist(v,y)$最小的点。

由于$y$是$v$的父节点，所以有：

$dist(root,v)=dist(root,y)+dist(v,y)$

而$dist(root,y)$是恒定的。

所以我们要找的就是$dist(root,v)$最小的点。

于是可以先处理出每个点到根节点(任选一个即可)的距离。





以上的讨论就包含所有的情况了。



### 代码实现

上述流程有几个需要高效算法维护的内容：

1.节点$x$的子树中有多少节点属于$S$；

2.离节点$x$最近的 子树中有节点属于$S$的 点；

3.树上任意两点间的距离；

4.已经被路径覆盖的点中，距离根最近的点。



由于要维护子树中的信息，很自然地想到用$DFS$序。设$In(x)$表示深度优先搜索时，$x$是第几个被遍历到的。$Out(x)$表示从$x$往上回溯时，已经遍历了多少的点。

则$x$的子树中的点就是$DFS$序在$[In(x),Out(x)]$中间的点。

当我们要将$y$加入到$s$中时，令$FT[In(y)]=1$。那么$\sum_{i=In(x)}^{Out(x)}FT[i]$就是以$x$为根的子树中在$S$中的个数。

用树状数组维护即可。

**于是1就解决了。单次操作$O(log\,n)$。**



树上$x,y$之间的距离等于$dist(root,x)+dist(root,y)-2*dist(root,LCA(x,y))$,于是用$LCA$维护即可。巧了，我们本来就要维护每个节点的$dist(root,x)$啊，一举两得。

**于是问题3解决。单次操作$O(log\, n) $。**



由于只要$x$的子树中有节点属于$S$，那么$x$的父节点（或者父节点的父节点，等等）中也一定有节点属于$S$。换句话说，”子树中是否有节点属于$S$“ 这一属性具有单调性。

于是可以用倍增的方法。每次向上倍增某个节点的$2^k$个祖先，找到最近的即可。

（又巧了，倍增$LCA$不正好维护了每个节点的$2^k$倍祖先么？）

**于是问题2可在$log^2n$内解决。**



**最巧的是问题4。** 由于树的形态确定后，每个点$x$的$dist(root,x)$都是不变的，所以可以考虑小根堆维护。

但是，是不是我们要把路径上所有的点（包括没在$S$中的点）都加入小根堆？如果是，那么每次需要$O(n\,logn)$的时间来找出路径上的点并将其加入小根堆中。这显然是不可接受的。

重新考虑之前讨论的4种加入点的情况。除了在$S$中的点，我们只需要将距离根最近的点加入小根堆即可。

例如，在情况1（$|S|=0$ )中，我们将这唯一添加进去的点加入小根堆即可。



在情况2（有至少两个子树中有点属于$S$）中，我们将正在处理的$u$(即图中的$4$)加入小根堆即可。它就是最近的，最有可能被选中的点。

![](https://img.hzao.top/data/图2_a.png)

假如$4$在后面被删掉了怎么办？会不会遗漏$5,8$这种候选项？

不会。

假如$4$被删掉，我们先不在小根堆中删除$4$，而是在取用它的时候判断它是否在路径上。只要它在路径上（满足情况2或3或者本身就是$S$中的点），就直接取用，否则将它弹出，考虑下一个候选项。

如果$4$被弹出，那么除非有其它操作使得$5$或$8$在路径上，否则候选项肯定不可能是$5$或$8$。

而当其它操作使得$5$或$8$在路径上并且可能成为备选点时，我们会将$5$或$8$加入小根堆，所以不会遗漏。



类似地，在情况3下，将要处理的点（图中的9）加入小根堆即可。

![](https://img.hzao.top/data/图2_c.png)



在情况4下，将倍增找到的点和正处理的点加入小根堆即可。



其实我们发现，除了要向上倍增的情况，所有情况都要将要处理的点加入小根堆中。


```cpp
#include<cmath>
#include<queue>
#include<cstdio>
#include<cstring>

//#define LOC
#define nowy (L[i].to)
using std::queue;
using std::priority_queue;
template <typename T>
inline void read(T &x){
	x=0;char c; T f=1;
	do{c=getchar();if(c=='-')f=-1;}while(c>'9'||c<'0');
	do{x=x*10+c-'0';c=getchar();}while(c>='0'&&c<='9');x*=f;
}

const int N=1e5 + 10;

int n,m,t;
int h[N],tot=1;
int f[N][18];
int d[N];
long long len[N];
int bg[N],ed[N];
int Inq[N];
int DFN;
int TotIn;
int Diff[N];//Diff是FT的一个拷贝 便于直接确认一个点是否在S中
int x,y,z;
int Num_SonIn,Cls_F;
long long ans=0;

struct line{
	int to,nxt,w;
}L[2*N];

struct OneNode{
	int num;
	bool operator <(const OneNode b)const {
		if(len[num]==len[b.num])return d[num]>d[b.num];
		return len[num]>len[b.num];
	}
	OneNode(int x):num(x){}
};//通过便于维护小根堆
struct FenwickTree{
	int v[N];
	inline void clear(){
		memset(v,0,sizeof(v));
	}
	inline void add(int x,int y){
		for(;x<=n;x+=x&-x){
			v[x]+=y;
		}
	}
	inline int ask(int x){
		int res=0;
		while(x>0){
			res+=v[x];
			x-=x&-x;
		}
		return res;
	}
	FenwickTree(){clear();}
}FT;
priority_queue<OneNode> OQ;

inline void add(int x,int y,int z){
	L[++tot].to=y;L[tot].nxt=h[x];h[x]=tot;L[tot].w=z;
	L[++tot].to=x;L[tot].nxt=h[y];h[y]=tot;L[tot].w=z;
}

void GetLCA_DFS(int x){
//DFS 同时求出祖先数组、距离根节点的距离、DFS序
	bg[x]=++DFN;
	for(int i=h[x];i;i=L[i].nxt){
		if(d[nowy])continue;
		d[nowy]=d[x]+1;
		f[nowy][0]=x;
		len[nowy]=len[x]+L[i].w;
		for(int j=1;j<=t;++j){
			f[nowy][j]=f[f[nowy][j-1]][j-1];
		}
		GetLCA_DFS(nowy);
	}
	ed[x]=DFN;
}
inline int LCA(int x,int y){
	if(d[x]>d[y]){
		x^=y;y^=x;x^=y;
	}
	//d[x]<=d[y]
	for(register int i=t;i>=0;--i){
		if(d[f[y][i]]>=d[x]){
			y=f[y][i];
		}
	}
	if(x==y)return x;
	for(register int i=t;i>=0;--i){
		if(f[y][i]!=f[x][i]){
			y=f[y][i];
			x=f[x][i];
		}
	}
	return f[x][0];
}
inline long long LEN(int x,int y){
	return 1ll*len[x]+len[y]-2*len[LCA(x,y)];
}
inline int GetSonIn(int x){//including x
//判断x的子树中有多少节点属于S
	if(!x)return TotIn;
	int Num=FT.ask(ed[x])-FT.ask(bg[x]-1);
	return Num;
}
inline bool TwoSon(int x,int v){
//是否满足情况2
	int SonV;
	for(register int i=h[x];i;i=L[i].nxt){
		if(d[nowy]<=d[x])continue;
		SonV=GetSonIn(nowy);

		if(SonV){
			if(SonV==v)return false;
			return true;
		}
	}
	return false;
}
inline bool check(int x){
//是否满足情况2或3 这两种情况可以一同处理
	if(!x)return true;
	int Num_SonIn;
	return (Num_SonIn=GetSonIn(x))&&(Num_SonIn<TotIn||TwoSon(x,Num_SonIn));
}
inline int GetCls_F(int x){
//倍增求离自己最近的 子树里有节点属于S 的节点
	if(GetSonIn(x))return x;
	int Num;
	for(register int i=t;i>=0;--i){
		if(!(Num=GetSonIn(f[x][i]))){
			x=f[x][i];
		}
	}
	return f[x][0];
}
inline void Change(long long t){
//通过t变量实现增加删除在同一个函数处理 减少码量
	if(TotIn!=0){
		if(!check(x)){
			Cls_F=GetCls_F(x);
			if(check(Cls_F)){
				if(t&&!Inq[Cls_F]){OQ.push(OneNode(Cls_F));Inq[Cls_F]=1;}
					ans+=LEN(x,Cls_F)*(-1+2*t);
			}
			else {
				while(!OQ.empty()){
					z=OQ.top().num;
					if(check(z)||Diff[z])break;
					OQ.pop();
					Inq[z]=0;
				}
				if(t&&!Inq[Cls_F]){OQ.push(OneNode(Cls_F));Inq[Cls_F]=1;}
				ans+=LEN(x,z)*(-1+2*t);
			}
		}
	}
}
int main(){
	read(n);read(m);
	t=log(n)/log(2)+1;
	for(register int i=1;i<n;++i){
		read(x);
		read(y);
		read(z);
		add(x,y,z);
	}
	d[1]=1;
	GetLCA_DFS(1);
	for(register int i=1;i<=m;++i){
		read(x);
		if(!Diff[x]){
			Change(1);
			FT.add(bg[x],1);
			Diff[x]+=1;
			if(!Inq[x]){Inq[x]=1;OQ.push(OneNode(x));}
			++TotIn;
		}
		else{
			--TotIn;
			FT.add(bg[x],-1);
			Diff[x]-=1;

			Change(0);
		}
		printf("%lld\n",ans*2);
	}
	return 0;
}
```



然后就可以愉快地AC了。

[](https://blog.hzao.top/2019/09/04/sdoi2015寻宝游戏-题解/)Uae牛逼！





---

## 作者：zhouyuheng2003 (赞：21)

这一题的的标签有“虚树”，但是虚树？难道对于每一次操作都O（n）的树形dp吗，那复杂度就是O（nm）的了，显然会TLE。

不难证明，这一题从任意一个有宝藏的起点出发的答案都是等价的（因为要回到起点，所以路径相当于是一个环），那么答案是什么呢，其实就是dis(a[1],a[2])+dis(a[2],a[3])+···+dis(a[k-1],a[k])+dis(a[k],a[1])，k为当前有宝藏的村庄数，a数组存放着按dfs序排序过后的有宝藏的村庄，那么每一次加一个点只要在原基础上删掉它按dfs序的前一个点和后一个点的距离、加上自己与那两个点的距离就好了（注意边界情况，即dfs序是最小的或者是最大的），删除同理。

有宝藏的村庄用一个set维护就好了，一次操作复杂度O（logn），树上点之间的距离可以用树链剖分或者是倍增实现（这里用的是倍增）

下面的是AC代码：

```cpp
#include<cstdio>
#include<cctype>
namespace fast_IO
{
    const int IN_LEN=10000000,OUT_LEN=10000000;
    char ibuf[IN_LEN],obuf[OUT_LEN],*ih=ibuf+IN_LEN,*oh=obuf;
    char *lastin=ibuf+IN_LEN;
    const char *lastout=ibuf+OUT_LEN-1;
    inline char getchar_()
    {
        if(ih==lastin)lastin=ibuf+fread(ibuf,1,IN_LEN,stdin),ih=ibuf;
        return (*ih++);
    }
    inline void putchar_(const char x)
    {
        if(ih==lastout)fwrite(obuf,1,oh-obuf,stdout),oh=obuf;
        *oh++=x;
    }
    inline void flush(){fwrite(obuf, 1, oh - obuf, stdout);}
}
using namespace fast_IO;
#define getchar() getchar_()
#define putchar(x) putchar_((x))
typedef long long LL;
#define rg register
template <typename T> inline T max(const T a,const T b){return a>b?a:b;}
template <typename T> inline T min(const T a,const T b){return a<b?a:b;}
template <typename T> inline T abs(const T a){return a>0?a:-a;}
template <typename T> inline void swap(T&a,T&b){T c=a;a=b;b=c;}
template <typename T> inline T gcd(const T a,const T b){if(a%b==0)return b;return gcd(b,a%b);}
template <typename T> inline T square(const T x){return x*x;};
template <typename T> inline void read(T&x)
{
    char cu=getchar();x=0;bool fla=0;
    while(!isdigit(cu)){if(cu=='-')fla=1;cu=getchar();}
    while(isdigit(cu))x=x*10+cu-'0',cu=getchar();
    if(fla)x=-x; 
}
template <typename T> void printe(const T x)
{
    if(x>=10)printe(x/10);
    putchar(x%10+'0');
}
template <typename T> inline void print(const T x)
{
    if(x<0)putchar('-'),printe(-x);
    else printe(x);
}
inline void judge()
{
    freopen("1.in","r",stdin);
    freopen("1.out","w",stdout);
}
#include<algorithm>
#include<set>
const int maxn=250001,maxm=500001;
int bit[19];
int n,m,s;
int head[maxn],nxt[maxm],tow[maxm],vau[maxm],tmp=1;
int who[maxn][19],dep[maxn];
LL dis[maxn][19];
inline void addb(const int u,const int v,const int w)
{
    tmp++;
    nxt[tmp]=head[u];
    head[u]=tmp;
    tow[tmp]=v;
    vau[tmp]=w;
}
int tid[maxn],tim;
inline void dfs(const int u)
{
    tid[u]=++tim;
    for(rg int i=head[u];i;i=nxt[i])
    {
        const int v=tow[i];
        if(who[u][0]!=v)
        {
            who[v][0]=u;
            dis[v][0]=vau[i];
            dep[v]=dep[u]+1;
            dfs(v);
        }
    }
}
inline LL dist(int a,int b)
{
    rg LL ans=0;
    if(dep[a]<dep[b])swap(a,b);
    const int lenth=dep[a]-dep[b];
    for(rg int i=0;bit[i]<=lenth;i++)
        if(lenth&bit[i])
            ans+=dis[a][i],a=who[a][i];
    if(a==b)return ans;
    for(rg int i=18;i>=0;i--)
        if(who[a][i]!=who[b][i])
            ans+=dis[a][i]+dis[b][i],a=who[a][i],b=who[b][i];
    return ans+dis[a][0]+dis[b][0];
}
LL ans;
struct Node
{
    int id;
    bool operator <(const Node b)const
    {
        return tid[id]<tid[b.id];
    }    
};
std::set<Node>Q;
inline std::set<Node>::iterator last(std::set<Node>::iterator Pos)
{
    if(Pos==Q.begin())Pos=Q.end();
    Pos--;
    return Pos;
}
inline std::set<Node>::iterator next(std::set<Node>::iterator Pos)
{
    Pos++;
    if(Pos==Q.end())Pos=Q.begin();
    return Pos;
}
std::set<Node>::iterator Posl,Posr;
int main()
{
//    judge();
    bit[0]=1;
    for(rg int i=1;i<=18;i++)bit[i]=bit[i-1]<<1;
    read(n),read(m),s=1;
    for(rg int i=1;i<n;i++)
    {
        int u,v,w;read(u),read(v),read(w);
        addb(u,v,w),addb(v,u,w);
    }
    who[s][0]=s,dep[s]=1;
    dfs(s);
    for(rg int j=1;j<=18;j++)
        for(rg int i=1;i<=n;i++)
            who[i][j]=who[who[i][j-1]][j-1],dis[i][j]=dis[i][j-1]+dis[who[i][j-1]][j-1];
    for(rg int i=1;i<=m;i++)
    {
        int u;read(u);
        if(Q.find((Node){u})!=Q.end())
        {
            if(Q.size()!=1)
            {
                Posl=Posr=Q.find((Node){u});
                Posl=last(Posl),Posr=next(Posr);
                ans-=dist(u,(*Posl).id)+dist(u,(*Posr).id);
                ans+=dist((*Posl).id,(*Posr).id);
            }
            Q.erase((Node){u});
        }
        else
        {
            Q.insert((Node){u});
            if(Q.size()!=1)
            {
                Posl=Posr=Q.find((Node){u});
                Posl=last(Posl),Posr=next(Posr);
                ans+=dist(u,(*Posl).id)+dist(u,(*Posr).id);
                ans-=dist((*Posl).id,(*Posr).id);
            }
        }
        print(ans),putchar('\n');
    }
    return flush(),0;
}
```

---

## 作者：「　」 (赞：20)

这里要讲的是一个两只 $\log_2$ 的~~低劣~~做法，仅供各位参考，希望能给您带来启发。

---

问题转化为动态求一个点集的**最小生成树的边权和**，发现这个东西不太好弄。

我们考虑到边权不是很好维护，所以就将边权下放点权，那么最终求答案的时候就需要两个东西：**最小生成树的点权和** 和 **生成树最上方的点的点权**（因为最上面的这个东西不在答案范围中）。

我们先来考虑后者，发现最上方的点实际上就是**所有节点的 $lca$** （注：此处是指所有点的最近公共祖先），也就是要动态维护一个点集的 $lca$ 。

可以发现如果将 $lca(u,v)$ 看成一种运算，发现他是完美满足结合律的，然后我们就可以用线段树来维护，这里不多赘述了。

然后考虑前者，发现这个东西除非用一些动态的高妙数据结构好像根本不能维护，但是我们可以发现，如果我们用类似于扫描线的做法，每一次加入或删除一个点的时候，将这个点到根的路径的 $tag$ 全部 $+1$ ，那么最后查询的**整棵树中 $tag$ 大于 $0$ 的节点的权值和**，实际上就是我们最后需要的**最小生成树的点权和**加上**所有点的 $lca$ 到根节点的路径的权值和**，由于我们前面已经可以维护所有点的 $lca$ 了，所有最后只需要减去后者（**所有点的 $lca$ 到根节点的路径的权值和**）即可。

有什么不明白的可以私信或者留言，我尽量尽快回复。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define Lint long long
const int N=1e5+5;
int n,m;
struct Node{int dep,fa,top,son,size;Lint data,dis;}tr[N];
struct Edge{int nxt,to;Lint val;}e[N<<1];int fir[N];
void add(int u,int v,Lint w,int i){e[i]=(Edge){fir[u],v,w},fir[u]=i;}
void dfs1(int u)
{
	tr[u].size=1,tr[u].top=u;
	tr[u].dep=tr[tr[u].fa].dep+1;
	tr[u].dis=tr[tr[u].fa].dis+tr[u].data;
	for(int i=fir[u];i;i=e[i].nxt)
	{
		if(e[i].to==tr[u].fa) continue;
		tr[e[i].to].fa=u;
		tr[e[i].to].data=e[i].val;
		dfs1(e[i].to);
		tr[u].size+=tr[e[i].to].size;
		if(tr[e[i].to].size>tr[tr[u].son].size)
		tr[u].son=e[i].to;
	}
}
int dfn[N],mp[N],cnt=0;
void dfs2(int u)
{
	dfn[++cnt]=u,mp[u]=cnt;
	if(tr[u].son)
	{
		tr[tr[u].son].top=tr[u].top;
		dfs2(tr[u].son);
	}
	for(int i=fir[u];i;i=e[i].nxt)
	{
		if(e[i].to==tr[u].fa||e[i].to==tr[u].son) continue;
		dfs2(e[i].to);
	}
}
int lca(int u,int v)
{
	while(tr[u].top!=tr[v].top)
	{
		if(tr[tr[u].top].dep<tr[tr[v].top].dep) swap(u,v);
		u=tr[tr[u].top].fa;
	}
	if(tr[u].dep>tr[v].dep) swap(u,v);
	return u;
}
bool alive[N];
Lint val[N];
struct Seg_Tree_data
{
	struct Node{Lint data,sum;int tag;}tr[N<<3];
	void up(int u)
	{
		if(tr[u].tag) tr[u].data=tr[u].sum;
		else tr[u].data=tr[u<<1].data+tr[u<<1|1].data;
	}
	void build(int u,int l,int r,Lint a[])
	{
		tr[u].tag=tr[u].data=0;
		if(l==r){tr[u].sum=a[l];return ;}
		int mid=(l+r)>>1;
		build(u<<1,l,mid,a);
		build(u<<1|1,mid+1,r,a);
		tr[u].sum=tr[u<<1].sum+tr[u<<1|1].sum;
	}
	void add(int u,int l,int r,int x,int y,int z)
	{
		if(x<=l&&r<=y){tr[u].tag+=z,up(u);return ;}
		int mid=(l+r)>>1;
		if(x<=mid) add(u<<1,l,mid,x,y,z);
		if(y>mid) add(u<<1|1,mid+1,r,x,y,z);
		up(u);
	}
}t1;
struct Seg_Tree_lca
{
	struct Node{int data;}tr[N<<2];
	void up(int u)
	{
		if(!tr[u<<1].data){tr[u].data=tr[u<<1|1].data;return ;}
		if(!tr[u<<1|1].data){tr[u].data=tr[u<<1].data;return ;}
		tr[u].data=lca(tr[u<<1].data,tr[u<<1|1].data);
	}
	void chg(int u,int l,int r,int x)
	{
		if(l==r)
		{
			if(tr[u].data) tr[u].data=0;
			else tr[u].data=l;
			return ;
		}
		int mid=(l+r)>>1;
		if(x<=mid) chg(u<<1,l,mid,x);
		else chg(u<<1|1,mid+1,r,x);
		up(u);
	}
}t2;
void work(int u,int v,int w)
{
	while(tr[u].top!=tr[v].top)
	{
		if(tr[tr[u].top].dep<tr[tr[v].top].dep) swap(u,v);
		t1.add(1,1,n,mp[tr[u].top],mp[u],w);
		u=tr[tr[u].top].fa;
	}
	if(tr[u].dep>tr[v].dep) swap(u,v);
	t1.add(1,1,n,mp[u],mp[v],w);
}
int main()
{
	cin>>n>>m;
	for(int i=1,u,v,w;i<n;++i)
	{
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,w,i<<1),add(v,u,w,i<<1|1);
	}
	dfs1(1),dfs2(1);
	for(int i=1;i<=n;++i) val[i]=tr[dfn[i]].data;
	t1.build(1,1,n,val);
	while(m--)
	{
		int u;cin>>u;
		if(!alive[u])
		{
			alive[u]=true;
			work(1,u,1);
			t2.chg(1,1,n,u);
		}
		else
		{
			alive[u]=false;
			work(1,u,-1);
			t2.chg(1,1,n,u);
		}
//		printf("%lld %d\n",t1.tr[1].data,t2.tr[1].data);
		printf("%lld\n",2*(t1.tr[1].data-tr[t2.tr[1].data].dis));
	}
	return 0;
}
```


---

## 作者：Karry5307 (赞：7)

### 题意

给定一棵$n$个点的树，第$i$条边有边权$w_i$，初始状态下每一个点都不是关键点。

有$m$次操作，每次可以把某个点是否是关键点的状态取反。

在每次操作之后，求所有关键点形成的极小联通子树的边权和的两倍。

$\texttt{Data Range:}1\leq n,m\leq 10^5,w_i\leq 10^9$

### 题解

一道好题。

看到题解区+网络上清一色的$\texttt{set}$做法我留下了伤心的泪水qwq（~~其实是我不太会用这东西~~），于是我写了平衡树。

有一个小结论：求出$\texttt{DFS}$序后，所有关键点$\{a_1,a_2\cdots a_n\}$的极小联通子树的边权和的两倍为

$$\sum\limits_{i=1}^{n-1}\operatorname{dist}(a_i,a_{i+1})+\operatorname{dist}(a_n,a_1)$$

画个图感性理解就好了，不难懂吧。

所以我们要动态维护一下关键点的按$\texttt{dfs}$序排序得到的序列，考虑到所有点的$\texttt{dfs}$序的相对次序是固定的，考虑预处理出每个点在$\texttt{dfs}$序上的位置和$\texttt{dfs}$序上第$i$个是哪个点。

然后发现每一次操作只会把一个关键点变成非关键点，或是把一个非关键点变成一个关键点，对应的就是有序序列的插入和删除，这个我们可以考虑用平衡树来维护。

当然，插入一个点$x$对答案的贡献为

$$\operatorname{dist}(x,prv)+\operatorname{dist}(x,nxt)-\operatorname{dist}(prv,nxt)$$

其中$prv,nxt$为$x$在$\texttt{dfs}$序上的前驱与后继。

删除可以类比着写，然后就可以完结撒花了qwq

有个小细节要注意一下，就是插入的时候先插入再求前驱后继，删除相反。

这里我用的是$\texttt{Splay}$，别的平衡树同理。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long int ll;
const ll MAXN=2e5+51,inf=0x7fffffffffffffff;
struct Edge{
	ll to,prev,dist;
};
Edge ed[MAXN<<1];
ll nc,qcnt,tot,from,to,dis,ddfn,x,res,prv,nxt,sz;
ll last[MAXN],depth[MAXN],dfn[MAXN],rdfn[MAXN],anc[MAXN][19],dist[MAXN][19];
ll vis[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline void addEdge(ll from,ll to,ll dist)
{
	ed[++tot].prev=last[from];
	ed[tot].to=to;
	ed[tot].dist=dist;
	last[from]=tot;
}
inline void dfs(ll node,ll fa,ll dis)
{
	depth[node]=depth[anc[node][0]=fa]+1,dist[node][0]=dis;
	dfn[node]=++ddfn,rdfn[ddfn]=node;
	for(register int i=last[node];i;i=ed[i].prev)
	{
		if(ed[i].to!=fa)
		{
			dfs(ed[i].to,node,ed[i].dist);
		}
	}
}
inline void LCASetup()
{
	for(register int j=1;j<=18;j++)
	{
		for(register int i=1;i<=nc;i++)
		{
			anc[i][j]=anc[anc[i][j-1]][j-1];
			dist[i][j]=dist[i][j-1]+dist[anc[i][j-1]][j-1];
		}
	}
}
inline ll LCA(ll x,ll y)
{
	ll res=0;
	if(depth[x]<depth[y])
	{
		swap(x,y);
	}
	for(register int i=18;i>=0;i--)
	{
		if(depth[anc[x][i]]>=depth[y])
		{
			res+=dist[x][i],x=anc[x][i];
		}
	}
	if(x==y)
	{
		return res;
	}
	for(register int i=18;i>=0;i--)
	{
		if(anc[x][i]!=anc[y][i])
		{
			res+=dist[x][i]+dist[y][i],x=anc[x][i],y=anc[y][i];
		}
	}
	return res+dist[x][0]+dist[y][0];
}
namespace Splay{
    struct Node{
        ll fa,val,size,tmp;
        ll ch[2];
        inline void reset(ll val=0,ll fa=0)
        {
            this->fa=fa,this->val=val,this->tmp=this->size=1;
            this->ch[0]=this->ch[1]=0;
        }
    };
    struct Splay{
        ll tot,root;
        Node nd[MAXN];
        inline bool id(ll x)
        {
            return nd[nd[x].fa].ch[1]==x;
        }
        inline void update(ll x)
        {
            nd[x].size=nd[nd[x].ch[0]].size+nd[nd[x].ch[1]].size+nd[x].tmp;
        }
        inline void connect(ll x,ll fa,ll dir)
        {
            nd[x].fa=fa,nd[fa].ch[dir]=x;
        }
        inline void rotate(ll x)
        {
            ll fa=nd[x].fa,gfa=nd[fa].fa,dir=id(x);
            connect(x,gfa,id(fa));
            connect(nd[x].ch[dir^1],fa,dir);
            connect(fa,x,dir^1);
            update(fa),update(x);
        }
        inline void splay(ll cur,ll target)
        {
            while(nd[cur].fa!=target)
            {
                ll fa=nd[cur].fa,gfa=nd[fa].fa;
                if(gfa!=target)
                {
                    rotate(id(cur)^id(fa)?cur:fa);
                }
                rotate(cur);
            }
            if(!target)
            {
                root=cur;
            }
        }
        inline void insert(ll val)
        {
            ll cur=root,fa=0;
            while(cur&&nd[cur].val!=val)
            {
                fa=cur,cur=nd[cur].ch[val>nd[cur].val];
            }
            if(cur)
            {
            	nd[cur].tmp++;
            }
            else
            {
            	cur=++tot;
                if(fa)
                {
                   nd[fa].ch[val>nd[fa].val]=cur;
                }
                nd[cur].reset(val,fa);
            }
            splay(cur,0);
        }
        inline void find(ll val)
        {
            ll cur=root;
            if(!cur)
            {
            	return;
            }
            while(nd[cur].ch[val>nd[cur].val]&&val!=nd[cur].val)
            {
                cur=nd[cur].ch[val>nd[cur].val];
            }
            splay(cur,0);
        } 
        inline ll getPrev(ll val)
        {
            find(val);
            ll cur=root;
            if(nd[cur].val<val)
            {
                return cur;
            }
            cur=nd[cur].ch[0];
            while(nd[cur].ch[1])
            {
                cur=nd[cur].ch[1];
            }
            return cur;
        }
        inline ll getNext(ll val)
        {
            find(val);
            ll cur=root;
            if(nd[cur].val>val)
            {
                return cur;
            }
            cur=nd[cur].ch[1];
            while(nd[cur].ch[0])
            {
                cur=nd[cur].ch[0];
            }
            return cur;
        }
        inline ll prev(ll val)
        {
        	return nd[getPrev(val)].val;
        }
        inline ll next(ll val)
        {
            return nd[getNext(val)].val;
        }
        inline void del(ll val)
        {
        	ll prv=getPrev(val),nxt=getNext(val),ls;
        	splay(prv,0),splay(nxt,prv),ls=nd[nxt].ch[0];
        	if(nd[ls].tmp>1)
        	{
        		nd[ls].tmp--,splay(ls,0);   
            }
            else
            {
                nd[nxt].ch[0]=0;
            }
        }
        inline ll findVal(ll rk)
        {
            ll cur=root,ls;
            if(nd[root].size<rk)
            {
                return 0;
            }
            while(1)
            {
                ls=nd[cur].ch[0];
                if(rk>nd[ls].size+nd[cur].tmp)
                {
                    rk-=nd[ls].size+nd[cur].tmp,cur=nd[cur].ch[1];
                }
                else
                {
                    if(rk<=nd[ls].size)
                    {
                        cur=ls;
                    }
                    else
                    {
                        return nd[cur].val;
                    }
                }
            }
        }
        inline ll findRank(ll val)
        {
            find(val);
            return nd[nd[root].ch[0]].size;
        }
    };
}
Splay::Splay splay;
int main()
{
	nc=read(),qcnt=read();
	for(register int i=0;i<nc-1;i++)
	{
		from=read(),to=read(),dis=read();
		addEdge(from,to,dis),addEdge(to,from,dis);
	}
	dfs(1,0,0),LCASetup(),splay.insert(inf),splay.insert(-inf),sz=2;
	for(register int i=0;i<qcnt;i++)
	{
		x=dfn[read()];
		if(!vis[rdfn[x]])
		{
			splay.insert(x),sz++;
		}
		prv=splay.prev(x),nxt=splay.next(x);
		prv=prv==-inf?splay.findVal(sz-1):prv;
		nxt=nxt==inf?splay.findVal(2):nxt;
		if(vis[rdfn[x]])
		{
			splay.del(x),sz--;
		}
		prv=rdfn[prv],nxt=rdfn[nxt],x=rdfn[x];
		dis=LCA(x,prv)+LCA(x,nxt)-LCA(prv,nxt);
		!vis[x]?(vis[x]=1,res+=dis):(vis[x]=0,res-=dis);
		printf("%lld\n",res);
	}
}
```

---

## 作者：raincity (赞：6)

## 题面
[P3320 [SDOI2015]寻宝游戏](https://www.luogu.com.cn/problem/P3320)

## 分析

好家伙！调试了六个小时。。。

不过貌似我的常数最小，抢到了rk1？（如果有人抢走了请告诉我）。

兔队讲得不很清楚，但是有借鉴意义。

>> 一个结论：DFS 序求出后，假设关键点按照 DFS 序排序后是 ${a_1,a_2,…,a_k}$。

>>  那么所有关键点形成的极小连通子树的边权和的两倍等于 $dist(a_1,a_2)+dist(a_2,a_3)+...+dist(a_{k-1},a_k)+dist(a_k,a_1)$

所以，我们可以用STL `std::set <int> Set`(当然，手写也行)，Set里面存每一个节点的dfs序，并记录每一个dfs序对应哪一个节点，即建立节点编号与dfs序的对应关系。（粉兔的题解看了我半天，idf是啥呀。。。而且也不严谨，如果原来没有节点的话$cur$就没有前驱）。

每插入一个节点：

若Set为空，ans=0

若Set中原来有一个元素，ans = $2 \times dist$(原有元素，当前元素)

若Set中原来至少有两个元素，设dfs序比当前节点大的且dfs序最小（即当前节点的后继）和前驱。设为 $x$, $y$。

那么，$dist(x,y)$可以删去，要加上$dist(x,cur)+dist(cur,y)$。

删除同理。

## 解决

最优解~~170行巨长~~代码：

```cpp
#include <iostream>
#include <cstdio>
#include <set>
#include <algorithm>

namespace Read {
char bufin[1 << 21], *p1 = bufin, *p2 = bufin;
inline char gc() {
  if (p1 == p2) {
    p1 = bufin, p2 = p1 + fread(bufin, 1, 1 << 21, stdin);
      if (p1 == p2)
        return EOF;
  }
  return *p1++;
}
inline void read(int &ret) {
  ret = 0;
  char c = gc();
  while (!isdigit(c)) c = gc();
  while (isdigit(c)) ret = ret * 10 + c - '0', c = gc();
}
} //namespace IO 
using Read::read;
using Read::gc;

namespace Write {
char bufout[1 << 21];
int tot, top;
char buf[20];
inline void flush() {
    fwrite(bufout, 1, tot, stdout);
    tot = 0;
}
inline void write(long long ret) {
  if (tot + 20 >= (1 << 21))
    flush();
  top = 0;
  if (ret < 0)
    ret = -ret, bufout[tot++] = '-';
  if (ret == 0)
    bufout[tot++] = '0';
  while (ret) buf[top++] = ret % 10 + '0', ret /= 10;
  for (int i = top - 1; i >= 0; i--) bufout[tot++] = buf[i];
  bufout[tot++] = '\n';
}
} // namespace Write
using Write::write;
using Write::flush;

typedef long long lxl;

const int N = 100005, M = N << 1;

int n, m;
int head[N], ver[M], nxt[M], edge[M], tot;
int dfn[N], dep[N], son[N], siz[N], fa[N], top[N], Idx, DFN[N];
bool exist[N];
lxl dis[N], ans;

std::set <int> Set;
std::set <int>::iterator it;

void addedge(int x, int y, int z) {
  tot++, ver[tot] = y, edge[tot] = z;
  nxt[tot] = head[x], head[x] = tot;
}

void build() {
  read(n), read(m);
  for (int i = 1; i < n; i++) {
    int u, v, w;
    read(u), read(v), read(w);
    addedge(u, v, w), addedge(v, u, w);
  }
}

inline void dfs1(int cur, int f, int e) {
  dep[cur] = dep[f] + 1, dis[cur] = dis[f] + e;
  fa[cur] = f, siz[cur] = 1, dfn[cur] = ++Idx, DFN[Idx] = cur;
  int maxi = -1;
  for (int i = head[cur]; i; i = nxt[i]) {
    if (ver[i] == f)
      continue;
    dfs1(ver[i], cur, edge[i]);
    siz[cur] += siz[ver[i]];
    if (siz[ver[i]] > maxi)
      maxi = siz[ver[i]], son[cur] = ver[i];
  }
}

inline void dfs2(int cur, int tp) {
  top[cur] = tp;
  if (!son[cur])
    return;
  dfs2(son[cur], tp);
  for (int i = head[cur]; i; i = nxt[i])
    if (ver[i] != fa[cur] && ver[i] != son[cur])
      dfs2(ver[i], ver[i]);
}

inline void swap(int &x, int &y) { x ^= y ^= x ^= y; }

inline int LCA(int x, int y) {
  while (top[x] != top[y]) {
    if (dep[top[x]] < dep[top[y]])
      swap(x, y);
    x = fa[top[x]];
  }
  if (dep[x] > dep[y])
    swap(x, y);
  return x;
}

inline lxl D(int x, int y) { return dis[x] + dis[y] - 2 * dis[LCA(x, y)]; }

inline void Erase(int t) {
  exist[DFN[t]] = false;
  if (Set.size() <= 2) {
    ans = 0; 
    Set.erase(t); 
    return;
  }
  if (Set.size() == 3) {
    Set.erase(t);
    ans = 2 * D(DFN[*Set.begin()], DFN[*(--Set.end())]);
    return;
  }
  it = Set.lower_bound(t);
  int x = DFN[(it == Set.begin()) ? *(--Set.end()) : *(--it)];
  it = Set.lower_bound(t);
  int y = DFN[(it == --Set.end()) ? *(Set.begin()) : *(++it)];
  ans -= D(x, DFN[t]) + D(DFN[t], y) - D(x, y);
  Set.erase(t);
}

inline void Insert(int t) {
  exist[DFN[t]] = true;
  if (Set.size() == 0) {
    ans = 0;
    Set.insert(t);
    return;
  }
  if (Set.size() == 1) {
    ans = 2 * D(DFN[*Set.begin()], DFN[t]);
    Set.insert(t);
    return;
  }
  Set.insert(t);
  it = Set.lower_bound(t);
  int x = DFN[(it == Set.begin()) ? *(--Set.end()) : *(--it)];
  it = Set.lower_bound(t);
  int y = DFN[(it == --Set.end()) ? *(Set.begin()) : *(++it)];
  ans += D(x, DFN[t]) + D(DFN[t], y) - D(x, y);
}

int main() {
  build();
  dfs1(1, 0, 0);
  dfs2(1, 1);
  while (m--) {
    int t, x, y;
    read(t);
    t = dfn[t];
    if (!exist[DFN[t]]) 
        Insert(t);
    else
        Erase(t);
    write(ans);
  }
  flush();
  return 0;
}


```

因为是用emacs写的，缩进只有两格。有人会帮忙调成四格吗？~~其实两格也挺好看~~。

~~好像写的越长跑得越快~~

忠告：
1. 别用register！
2. 开~~lxl~~ long long!
3. 树链剖分求LCA的if条件别写错！（当然您也可以写倍增）。

### THE END

---

## 作者：大菜鸡fks (赞：6)

可以发现其实求的答案就是树上关键点的边权和*2

这个有点难求。 由于每次只修改一个关键点，那么加入这个关键点会对答案造成什么影响？

首先发现整棵树的权值和与从哪个点开始计算无关，所以可以换种计算方式，就是每次加入往他dfs序的后继走，就可以了（虚树上的最短路径一定是按照dfs序走的简单路径）。

考虑加入一个点就是加上他到前驱后继的距离，减去前驱后继之间原有的“边权” 就可以了

```cpp
#include<cstdio>
#include<set>
#include<algorithm>
#define int long long
using namespace std;
inline int read(){int x=0,f=1,ch=getchar(); while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();} while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}
inline void write(int x){if (x<0) putchar('-'),x=-x; if (x>=10) write(x/10); putchar(x%10+'0');}
inline void writeln(int x){write(x); puts("");}
const int N=100005;
struct edge{
	int link,next,val;
}e[N<<1];
int cnt,id[N],pos[N],dep[N],n,m,tot,head[N],fa[N][20],va[N];
set<int > st;
set<int > :: iterator it,qi,ho;
inline void add_edge(int u,int v,int w){
	e[++tot]=(edge){v,head[u],w}; head[u]=tot;
}
inline void insert(int u,int v,int w){
	add_edge(u,v,w); add_edge(v,u,w); 
}
inline void init(){
	n=read(); m=read();
	for (int i=1;i<n;i++){
		int u=read(),v=read(),w=read();
		insert(u,v,w);
	}
}
void dfs(int u,int Fa){
	fa[u][0]=Fa; dep[u]=dep[Fa]+1; id[u]=++cnt; pos[cnt]=u;
	for (int i=1;i<20;i++){
		fa[u][i]=fa[fa[u][i-1]][i-1];
	}
	for (int i=head[u];i;i=e[i].next){
		int v=e[i].link;
		if (v!=Fa){
			va[v]=va[u]+e[i].val; dfs(v,u);
		}
	}
}
inline int LCA(int u,int v){
	if (dep[u]<dep[v]) swap(u,v);
	int delta=dep[u]-dep[v];
	for (int i=0;i<20;i++){
		if (delta&(1<<i)){
			u=fa[u][i];
		}
	}
	for (int i=19;i>=0;i--){
		if (fa[u][i]!=fa[v][i]){
			u=fa[u][i]; v=fa[v][i];
		}
	}
	if (u!=v) return fa[u][0];
		else return u;
}
bool vis[N];
inline void qry(int x){
	it=st.find(id[x]);
	if (it==st.begin()) {qi=st.end(); qi--;}
		else{ qi=it; qi--;}
	ho=it; ho++;
	if (ho==st.end()) ho=st.begin();
}
inline int work1(){
	return va[pos[*ho]]+va[pos[*it]]*2+va[pos[*qi]]-va[LCA(pos[*ho],pos[*it])]*2-va[LCA(pos[*qi],pos[*it])]*2;
}
inline int work2(){
	return va[pos[*ho]]+va[pos[*qi]]-2*va[LCA(pos[*ho],pos[*qi])];
}
int ans;
inline void solve(){
	dfs(1,0);
	for (int i=1;i<=m;i++){
		int x=read();
		if (vis[x]){
			qry(x);
			ans-=work1(); ans+=work2();
			st.erase(id[x]); vis[x]=0;
		}else{
			vis[x]=1; st.insert(id[x]);
			qry(x);
			ans+=work1(); ans-=work2();
		}
		writeln(ans);
	}
}
signed main(){
	init();
	solve();
	return 0;
} 
```



---

## 作者：Warriors_Cat (赞：4)

是一道比较经典的题了吧，不过 NOIp 前做做老题也不错。

---

### $Solution:$

这题本质上就是求使动态点集连通的最小代价。

不放设这个点集为 $\{S_i\}$，$|\{S_i\}|=n$。

如果我们把 $S_i$ 按照其 $\mathrm{DFS}$ 序排序的话，那么这个最小代价便是：

$$2\sum_{i=1}^ndis(S_i, S_{i+1})$$

这里钦定 $S_{n+1}=S_1$。

证明其实很简单，考虑连通后的子树，每条边在 $\mathrm{DFS}$ 的时候会入一次，又出一次，所以每条边就贡献了两次。而按照 $\mathrm{DFS}$ 序相邻取距离就相当于一个 $\mathrm{DFS}$ 的过程。

于是，我们每次插入后删除的时候都能维护这个值就行了。很显然每次我们都要找它的前驱和后继。

动态插入/删除+找前驱后继？平衡树！

~~平衡树好长啊，不想打（~~

STL 中恰好有现成的平衡树 `set`，于是我们可以巧妙地运用 `set` 来解决此题。

两点间的距离可以直接用 $\mathrm{LCA}$ $O(\log n)$ 求。

于是整道题就做完了，时间复杂度为 $O((n+m)\log n)$。

写代码的时候，注意前驱后继的边界问题。

### $Code:$

由于笔者的特判有亿点多，所以此代码又臭又长，建议不做参考，但想看的同学还是可以看一下。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <set>
using namespace std;
#define int long long
#define SI set <int> :: iterator
inline int read(){
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
	return x * f;
}
const int N = 100010;
struct edge{
	int v, w, nxt; 
}e[N << 1];
int head[N << 1], cnt, n, m, k, x, y, z, dep[N], dis[N], f[N][20], dfn[N], pos[N], ans;
char ch[10];
set <int> st;
SI it, it2, it3;
inline void add(int u, int v, int w){
	e[++cnt].v = v;
	e[cnt].w = w;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}
inline void dfs(int u){
	dfn[u] = ++k;
	pos[k] = u;
	for(register int i = head[u]; i; i = e[i].nxt){
		int v = e[i].v, w = e[i].w;
		if(dep[v]) continue;
		dep[v] = dep[u] + 1;
		dis[v] = dis[u] + w;
		f[v][0] = u;
		for(int j = 1; j <= 17; ++j) f[v][j] = f[f[v][j - 1]][j - 1];
		dfs(v);
	}
}
inline int lca(int a, int b){
	if(dep[a] < dep[b]) a ^= b ^= a ^= b;
	for(register int i = 17; i >= 0; --i) if(dep[f[a][i]] >= dep[b]) a = f[a][i];
	if(a == b) return a;
	for(register int i = 17; i >= 0; --i) if(f[a][i] != f[b][i]) a = f[a][i], b = f[b][i];
	return f[a][0];
}
inline int pat(int a, int b){
	return dis[a] + dis[b] - 2 * dis[lca(a, b)];
}
signed main(){
	n = read(); m = read();
	for(register int i = 1; i < n; ++i){
		x = read(); y = read(); z = read();
		add(x, y, z); add(y, x, z);
	}
	dfs(dep[1] = 1);
	for(register int i = 1; i <= m; ++i){
		x = read(); it = st.find(dfn[x]);
		if(it == st.end()){
			if(st.empty()){
				st.insert(dfn[x]);
				printf("%lld\n", ans);
				continue;
			}
			it = st.lower_bound(dfn[x]);
			if(it == st.end() || it == st.begin()){
				it2 = st.end(); --it2;
				ans -= pat(pos[*st.begin()], pos[*it2]);
				ans += pat(pos[*st.begin()], x);
				ans += pat(pos[*it2], x);
				st.insert(dfn[x]);
			}
			else{
				it2 = it; --it2;
				ans -= pat(pos[*it2], pos[*it]);
				ans += pat(pos[*it], x);
				ans += pat(pos[*it2], x);
				st.insert(dfn[x]);
			}
		}
		else{
			if(st.size() == 1){
				ans = 0;
				st.erase(st.begin());
				printf("%lld\n", ans);
				continue;
			}
			it = st.lower_bound(dfn[x]);
			it3 = it; ++it3;
			if(it3 == st.end()){
				it2 = it; --it2;
				ans += pat(pos[*st.begin()], pos[*it2]);
				ans -= pat(pos[*st.begin()], x);
				ans -= pat(pos[*it2], x);
				st.erase(dfn[x]);
			}
			else if(it == st.begin()){
				it2 = it; ++it2; it3 = st.end(); --it3;
				ans += pat(pos[*it2], pos[*it3]);
				ans -= pat(pos[*it2], x);
				ans -= pat(pos[*it3], x);
				st.erase(dfn[x]);
			}
			else{
				it2 = it; --it2;
				ans += pat(pos[*it2], pos[*it3]);
				ans -= pat(pos[*it2], x);
				ans -= pat(pos[*it3], x);
				st.erase(dfn[x]);
			}
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```


---

## 作者：ycyaw (赞：4)

看到建虚树的做法？？？~~不会~~

这题要求每一次加减操作都计算答案，那么我们考虑加入一个点的贡献。

慢慢分析：首先一个点或者没有点，肯定没有贡献，为0。

然后是两个点，随便从一个点开始，走到另一个点再返回，贡献为2 $\times$ $dis(x,y)$。

回忆一下树上两点距离：$x$到$y$的距离$=$ $x$到根的距离$+$ $y$到根的距离$-$ $lca(x,y)$到根的距离$\times$ 2。($lca$想怎么求怎么求)
 
再增加一个点呢？树上有3个点，怎么走能使距离最短？应该是按遍历时的时间戳走咯。假设时间戳为1，2，3，那么贡献就是1->2 $+$ 2->3 $+$ 3->1。(箭头表示两点之间距离)

那么不管几个点，我们发现按时间戳走肯定最快。所以考虑维护加入点的时间戳。蒟蒻我不会$splay$，只能甩出一手$STL$大法$set$。(~~STL大法好~~)

每插入一个元素，考虑增加的贡献，是先删去它时间戳($set$里面)左边和右边的贡献，再加上它和左边以及它和右边的贡献。删去一个元素同理。这题做完，对$set$的使用以后就会很熟练了。

注意特判一个点的情况以及开$long\ long$。

上代码：
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define oo (1e18)
#define int long long
#define LL unsigned long long
#define ite set<int>::iterator
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
#define hh puts("")
using namespace std;
int n,m,cnt,head[100005],dfn[100005],bz[100005][20],dis[100005],vis[100005],dep[100005],ans;
set<int> s;
struct Edge{
	int v,nx,s;
}e[200005];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-1;ch=getchar();}
    while(isdigit(ch)){ret=(ret<<3)+(ret<<1)+(ch^48);ch=getchar();}
    return ret*ff;
}
inline void add(int x,int y,int z){
	e[++cnt].v=y;
	e[cnt].nx=head[x];
	e[cnt].s=z;
	head[x]=cnt;
}
void dfs(int now,int fa){
	dfn[now]=++cnt;//时间戳 
	vis[cnt]=now;//dfs序 
	dep[now]=dep[fa]+1;
	for(int i=head[now];i;i=e[i].nx){
		int v=e[i].v;
		if(v==fa) continue;
		dis[v]=dis[now]+e[i].s;
		bz[v][0]=now;
		dfs(v,now);
	}
}
inline ite lef(ite it){
	if(it==s.begin()) return --s.end();
	return --it;
}
inline ite rig(ite it){
	if(it==--s.end()) return s.begin();
	return ++it;
}
inline int LCA(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=17;i>=0;i--){
		if(dep[bz[x][i]]>=dep[y])
			x=bz[x][i];
	}
	if(x==y) return x;
	for(int i=17;i>=0;i--)
		if(bz[x][i]!=bz[y][i])
			x=bz[x][i],y=bz[y][i];
	return bz[x][0];
}
signed main(){
	n=read(),m=read();
	for(int i=1;i<n;i++){
		int x=read(),y=read(),z=read();
		add(x,y,z);
		add(y,x,z);
	}
	cnt=0;
	dis[1]=0;
	dfs(1,0);
	for(int k=1;k<=17;k++)
		for(int i=1;i<=n;i++)
			bz[i][k]=bz[bz[i][k-1]][k-1];
	
	for(int i=1;i<=m;i++){
		int x=read();
		if(!s.count(dfn[x])){
			if(s.size()){
				ite it=s.lower_bound(dfn[x]);
				if(it==s.end()) it=s.begin();
				ite L=lef(it);
				int lca1=LCA(vis[*it],vis[*L]);
				int lca2=LCA(vis[*it],x);
				int lca3=LCA(vis[*L],x);
				ans-=dis[vis[*it]]+dis[vis[*L]]-2*dis[lca1];
				ans+=dis[vis[*it]]+dis[x]-2*dis[lca2];
				ans+=dis[vis[*L]]+dis[x]-2*dis[lca3];
			}
			s.insert(dfn[x]);
			printf("%lld\n",ans);
			continue;
		}
		else{
			ite it=s.find(dfn[x]);
			ite L=lef(it),R=rig(it);
			int lca1=LCA(x,vis[*L]);
			int lca2=LCA(x,vis[*R]);
			int lca3=LCA(vis[*L],vis[*R]);
			ans-=dis[x]+dis[vis[*L]]-2*dis[lca1];
			ans-=dis[x]+dis[vis[*R]]-2*dis[lca2];
			ans+=dis[vis[*L]]+dis[vis[*R]]-2*dis[lca3];
			s.erase(dfn[x]);
			printf("%lld\n",ans);
			continue;
		}
	}
    return 0;
}
```


---

## 作者：ezoiHY (赞：3)


# 更好[阅读体验](https://www.cnblogs.com/ezoihy/p/9110381.html)，欢迎访问本弱弱的[博客](http://www.cnblogs.com/ezoihy/)
### solution
其实这题是一个比较坑爹的题，可以用虚树做，也可以用set+lca做
#### 这里讲下set+lca的做法
首先我们可以将各个点的dfn值在set中删除，用dfn是因为set中的元素都是有序的，这样方便查找，当然也可以手写rank_tree（splay，treap等），这样效率或许更高。


插入操作：我们可以将一点x插入到set中，将上一次的答案加上x点到其前驱以及后继点的路径长，再减去该两点之间的路径长。

$$insert_{ans}(x)=ans_{last}-dis(before,after)+dis(x,before)+dis(x,after)$$

删除操作：我们可以将上一次答案加上待删除的点x的前驱和后继之间的路径长，再减去分别到前驱后后继的路径。

$$erase_{ans}(x)=ans_{last}+dis(before,after)-dis(x,before)-dis(x,after)$$

其中dis为

$$dis(x,y)=dis\bigr(LCA(x,y),x\bigl)+dis\bigr(LCA(x,y),y\bigl)$$

期间我们可以用树剖求lca，并在树剖的第一个dfs里初始化好各个点到根的距离。
#### 虚树做法
易知，答案就是各个关键点之间形成的树的边权和的两倍，这就是虚树！对于一颗虚树，答案就是各个的dfs序排序，相邻两点的距离和，再加上最后一个到第一个的距离,直接用set维护dfs序就好了，注意最后要减掉所有关键点的LCA的深度

这是LCA+set做法的代码

    #include<cstdio>
	#include<cstring>
	#include<algorithm>
	#include<set>
	using namespace std;
	 
	const int N=1000001;
	int n,q,tot,root,maxn,dftim,tim[N],fa[N],to[N<<1],nx[N<<1],head[N<<1],dep[N],siz[N],son[N],top[N],dfn[N],dfnnode[N+5];
	long long cost[N<<1],ans,toroot[N];
	bool flag[N];
	set<int> s;
	 
	void addedge(int x,int y,long long z){
	    nxt[++tot]=head[x]; 
	    head[x]=tot;
	    to[tot]=y;
	    cost[tot]=z;
	}
	  
	void dfs1(int u,int f) {//树剖求lca
    	dfn[u]=++dftim;
    	dfnnode[dfn[u]]=u;
    	dep[u]=dep[fa[u]=f]+(siz[u]=1);
    	for(int i=head[u];i;i=nxt[i]) {
        	int v=to[i];
        	if(v==f)continue;
        	toroot[to[i]]=toroot[u]+cost[i];
        	dfs1(v,u);
        	siz[u]+=siz[v];
        	if(siz[v]>siz[son[u]])son[u]=v;
    	}
	}
  
	void dfs2(int u,int topf){
	    top[u]=topf;
	    if(!son[u])return;
	    dfs2(son[u],topf);
	    for(int i=head[u];i;i=nxt[i]){
	        int v=to[i];
	        if(v==fa[u] or v==son[u])continue;
	        dfs2(v,v);
	    }
	}
	 
	int lca(int x,int y) {
	    register int u=x,v=y;
	    while(top[u]!=top[v]) {
	        if(dep[top[u]]<dep[top[v]])swap(u,v);
	        u=fa[top[u]];
	    }
	    return dep[u]<=dep[v]?u:v;
	}
	 
	long long get(int x,int y){
	    int z=lca(x,y);
	    return toroot[x]+toroot[y]-2*toroot[z];
	}
	 
	int main() {
	    scanf("%d%d",&n,&q);
	    for(int i=1; i<n; ++i) {
	        int u,v;
	        long long w;
	        scanf("%d%d%lld",&u,&v,&w);
	        addedge(u,v,w),addedge(v,u,w);
	        tim[u]++,tim[v]++;
	        if(tim[u]>maxn)root=u,maxn=tim[u];
	        if(tim[v]>maxn)root=v,maxn=tim[v];
	    }
	    dfs1(root,0);
	    dfs2(root,root);    
		s.insert(0),s.insert(n+1);
    	while(q--){
        	int x;scanf("%d",&x);
        	if(flag[x]){
        	    int las=*--s.find(dfn[x]),nxt=*++s.find(dfn[x]);
            	if(las>=1)ans-=get(dfnnode[las],x);
            	if(nxt<=n)ans-=get(dfnnode[nxt],x);
            	if(las>=1 and nxt<=n)ans+=get(dfnnode[las],dfnnode[nxt]);
            	s.erase(dfn[x]);
        	}else{
            	s.insert(dfn[x]);
            	int las=*--s.find(dfn[x]),nxt=*++s.find(dfn[x]);//计算前驱与后继
            	if(las>=1)ans+=get(dfnnode[las],x);
            	if(nxt<=n)ans+=get(dfnnode[nxt],x);
            	if(las>=1 and nxt<=n)ans-=get(dfnnode[las],dfnnode[nxt]);
	        }
    	    int first=*++s.find(0),last=*--s.find(n+1);long long hehe=0;
        	if (first<1 or last>n) hehe=0;
        	else hehe=get(dfnnode[first],dfnnode[last]);
        	printf("%lld\n",ans+hehe);
        	flag[x]=!flag[x];
    	}
    	return 0;
	}

---

## 作者：Lynkcat (赞：3)

其实我的思路和大部分题解是差不多的。(具体思路见题解，下面我说的话和思路没任何关系，完全在讲pascal如何实现）

但是作为一个不会平衡树的小菜鸡我实在想不到如何来维护这个可怕的宝藏村庄序列。

于是我找到了机房大佬，请求他助我一臂之力！

于是……我就使用了Pascal版的STL库来做了！(实际上我原先还以为只有c++有这东西)

然而这东西比赛是不能用的(~~ccf太*了~~)

于是我们就可以用sets来维护序列了！！！

~~这是我目前做过最装逼的题目了……~~

```pascal
uses Gset,Gutil,math;
type
  cmp=specialize Tless<longint>;
  sets=specialize Tset<int64,cmp>;
  rec=record
  x,next,dis:longint;
  end;
var f,d:array[0..100000,0..20] of int64;
    dian,dep,h,xu:array[0..100000] of longint;
    b:array[0..100000] of boolean;
    q:array[0..200000] of rec;
    k1,n,m,i,x,y,z,u,cnt1,cnt,k:longint;
    ans:int64;
    s:sets;
procedure ad(x,y,z:longint);//链式前向星存图
begin
  inc(cnt);
  q[cnt].x:=x;q[cnt].dis:=z;q[cnt].next:=h[y];
  h[y]:=cnt;
end;
procedure dfs(k,l,dist:longint);//日常dfs预处理
var t,i:longint;
begin
  inc(k1);
  dian[k1]:=k;xu[k]:=k1;//其实我觉得这样写更方便一点(在空间不炸的情况下)
  dep[k]:=dep[l]+1;
  f[k,0]:=l;d[k,0]:=dist;
  for i:=1 to trunc(log2(dep[k])) do
  begin
    f[k,i]:=f[f[k,i-1],i-1];
    d[k,i]:=d[k,i-1]+d[f[k,i-1],i-1];
  end;
  t:=h[k];
  while t>0 do
  begin
    if q[t].x<>l then dfs(q[t].x,k,q[t].dis);
    t:=q[t].next;
  end;
end;
function lca(x,y:longint):int64;//lca(x,y)表示x与y的距离
var i,t:longint;
begin
  lca:=0;if (x=0)or(y=0) then exit(0);
  if dep[x]<dep[y] then
  begin
    t:=x;x:=y;y:=t;
  end;
  for i:=20 downto 0 do
  begin
    if dep[f[x,i]]>=dep[y] then
    begin
      lca:=lca+d[x,i];
      x:=f[x,i];
    end;
    if x=y then exit;
  end;
  for i:=20 downto 0 do
    if f[x,i]<>f[y,i] then
    begin
      lca:=lca+d[x,i]+d[y,i];
      x:=f[x,i];
      y:=f[y,i];
    end;
  lca:=lca+d[x,0]+d[y,0];
end;
begin
  readln(n,m);ans:=0;
  s:=sets.create;
  s.insert(-maxlongint);
  s.insert(maxlongint);
  for i:=1 to n-1 do
  begin
    readln(x,y,z);
    ad(x,y,z);
    ad(y,x,z);
  end;
  dfs(1,0,0);
  for i:=1 to m do
  begin
    readln(u);
    if b[u] then
    begin
      x:=s.findgreater(xu[u]).data;if x=maxlongint then x:=s.findgreater(-maxlongint).data;
      y:=s.findless(xu[u]).data;if y=-maxlongint then y:=s.findless(maxlongint).data;//找前驱和后继
      if x=maxlongint then x:=0 else x:=dian[x];
      if y=-maxlongint then y:=0 else y:=dian[y];
      ans:=ans-lca(x,u)-lca(y,u)+lca(x,y);//更新答案
      s.delete(xu[u]);b[u]:=false;dec(cnt1);
    end else
    begin
      x:=s.findgreaterEqual(xu[u]).data;if x=maxlongint then x:=s.findgreater(-maxlongint).data;
      y:=s.findlessEqual(xu[u]).data;if y=-maxlongint then y:=s.findless(maxlongint).data;//同上
      if x=maxlongint then x:=0 else x:=dian[x];
      if y=-maxlongint then y:=0 else y:=dian[y];
      ans:=ans+lca(x,u)+lca(y,u)-lca(x,y);//同上
      s.insert(xu[u]);b[u]:=true;inc(cnt1);
    end;
    writeln(ans);
  end;
end.


```


---

## 作者：KellyFrog (赞：2)

~~通过标签可以得知跟虚树有关~~

考虑建出了虚树之后怎么做

显然虚数上所有叶子节点都是关键点，那么从任意点出发，遍历所有叶子再回来的长度就是所有边权长度值和的两倍，且遍历途中会遍历所有节点。因为虚树是根据 dfs 序建立的，且虚树的 dfs 序和原树一样，所以将虚树上的节点按原树 dfs 序排序，答案就是 $dis(u_1,u_2)+dis(u_2,u_3)+...+dis(u_m,u_1)$

于是我们惊喜地发现，根本不需要建虚树，插入一个节点 $x$ 相当于将 $dis(u_i,u_{i+1})$ 改为 $dis(u_i+x)+dis(u_{i+1},x)$，其中 $u_i,u_{i+1}$ 分别是 $x$ 在 dfs 序上的前驱和后继

于是将所有节点扔到按 dfs 序排序的 set 里就可以了，总复杂度 $O((n+q)\log n)$，需要注意一些细节

```cpp
// Problem: #2182. 「SDOI2015」寻宝游戏
// Contest: LibreOJ
// URL: https://loj.ac/p/2182
// Memory Limit: 256 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef long double ldb;
typedef vector<int> vi;
typedef pair<int, int> pii;
#define fi first
#define se second
#define rg register
#define mp make_pair
#define pb push_back
#define pf push_front

#define rep(i, s, t) for (rg int i = s; i <= t; i++)
#define per(i, s, t) for (rg int i = t; i >= s; i--)
#define OK cerr << "OK!\n"

/*
 * fastio::qread(...) read int/LL
 * fastio::qwrite(x, (char)y) write int/LL and char
 */

namespace fastio {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;

inline char getchar() {
  return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin),
          (iS == iT ? EOF : *iS++) : *iS++);
}
inline void qread() {}
template <typename T1, typename... T2>
inline void qread(T1 &x, T2 &...ls) {
  x = 0;
  rg char ch = ' ';
  rg int ps = 1;
  while (!isdigit(ch) && ch != '-') ch = getchar();
  if (ch == '-') ps = -1, ch = getchar();
  while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();
  x *= ps;
  qread(ls...);
}

inline void flush() {
  fwrite(obuf, 1, oS - obuf, stdout);
  oS = obuf;
  return;
}
inline void putchar(char _x) {
  *oS++ = _x;
  if (oS == oT) flush();
}
template <typename T>
inline void qwrite(T x) {
  if (x < 0) putchar('-'), x = -x;
  if (x < 10) return putchar('0' + x), void();
  qwrite(x / 10), putchar('0' + (x % 10));
}

template <typename T>
inline void qwrite(T x, char ch) {
  qwrite(x), putchar(ch);
}
};  // namespace fastio

#ifndef ONLINE_JUDGE

void debug(const char *s) { cerr << s; }
template <typename T1, typename... T2>
void debug(const char *s, const T1 x, T2... ls) {
  int p = 0;
  while (*(s + p) != '\0') {
    if (*(s + p) == '{' && *(s + p + 1) == '}') {
      cerr << x;
      debug(s + p + 2, ls...);
      return;
    }
    cerr << *(s + p++);
  }
}

#else
#define debug(...) void(0)
#endif

const ll mod = 1e9 + 7;
// const ll mod = 1e9 + 9;
// const ll mod = 19260817;
// const ll mod = 998244353;

template<typename T> inline void chkadd(T& x, T y) { x = x + y >= mod ? x + y - mod : x + y; }
template<typename T> inline void chkadd(T& x, T y, T z) { x = y + z >= mod ? y + z - mod : y + z; }
template<typename T> inline void chkmns(T& x, T y) { x = x - y < 0 ? x - y + mod : x - y; }
template<typename T> inline void chkmns(T& x, T y, T z) { x = y - z < 0 ? y - z + mod : y - z; }
template<typename T> inline void chkmax(T& x, T y) { x = x < y ? y : x; }
template<typename T> inline void chkmax(T& x, T y, T z) { x = y > z ? y : z; }
template<typename T> inline void chkmin(T& x, T y) { x = x < y ? x : y; }
template<typename T> inline void chkmin(T& x, T y, T z) { x = y < z ? y : z; }

const int N = 1e5 + 5;

vector<pair<int, int> > adj[N];
ll dis[N];
int n, q;
int dep[N], anc[N][21], dfn[N], dfncnt;
set<pair<int, int> > node;
ll ans = 0;

inline void dfs(int u, int fa, int lw) {
	dep[u] = dep[fa] + 1;
	anc[u][0] = fa;
	dis[u] = dis[fa] + lw;
	rep(i, 1, 20) anc[u][i] = anc[anc[u][i-1]][i-1];
	dfn[u] = ++dfncnt;
	for(auto e : adj[u]) {
		if(e.fi != fa) dfs(e.fi, u, e.se);
	}
}

inline int LCA(int x, int y) {
	if(dep[x] < dep[y]) swap(x, y);
	per(i, 0, 20) if(dep[anc[x][i]] >= dep[y]) x = anc[x][i];
	if(x == y) return x;
	per(i, 0, 20) if(anc[x][i] != anc[y][i]) x = anc[x][i], y = anc[y][i];
	return anc[x][0];
}

inline ll getdis(int x, int y) {
	return dis[x] + dis[y] - 2 * dis[LCA(x, y)];
}


int main() {
	fastio::qread(n, q);
	rep(i, 1, n-1) {
		int u, v, w;
		fastio::qread(u, v, w);
		adj[u].pb(mp(v, w));
		adj[v].pb(mp(u, w));
	}
	dfs(1, 0, 0);
	while(q--) {
		int x; fastio::qread(x);
		if(node.count(mp(dfn[x], x))) {
			if(node.size() == 1) {
				
			} else if(node.size() == 2) {
				ans = 0;
			} else {
				auto it = node.find(mp(dfn[x], x));
				auto nd1 = it, nd2 = it;
				if(it == node.begin()) {
					nd1 = --node.end();
					nd2 = ++it;
				} else if(it == --node.end()) {
					nd1 = --it;
					nd2 = node.begin();
				} else {
					nd1 = --it; ++it;
					nd2 = ++it;
				}
				int u1 = nd1 -> se;
				int u2 = nd2 -> se;
				ans -= getdis(u1, x);
				ans -= getdis(u2, x);
				ans += getdis(u1, u2);
			}
			node.erase(mp(dfn[x], x));
		} else {
			if(node.size() == 0) {
				node.insert(mp(dfn[x], x));
			} else if(node.size() == 1) {
				ans += 2 * getdis(node.begin() -> se, x);
				node.insert(mp(dfn[x], x));
			} else {
				
				node.insert(mp(dfn[x], x));
				
				auto it = node.find(mp(dfn[x], x));
				auto nd1 = it, nd2 = it;
				if(it == node.begin()) {
					nd1 = --node.end();
					nd2 = ++it;
				} else if(it == --node.end()) {
					nd1 = --it;
					nd2 = node.begin();
				} else {
					nd1 = --it; ++it;
					nd2 = ++it;
				}
				int u1 = nd1 -> se;
				int u2 = nd2 -> se;
				
				ans += getdis(u1, x);
				ans += getdis(u2, x);
				ans -= getdis(u1, u2);
			}
		}
		
		fastio::qwrite(ans, '\n');
	}
	fastio::flush();
	return 0;
}

```

---

## 作者：Uniecho1 (赞：2)

先看算法标签：虚树是啥我不知道,不过后两个我还是会一点的......试试看吧？？

1min后：动态的，这么骚的吗？
于是脑子里有了第一个想法：维护一个存在标记，对于每次询问进行一次树形迪屁（自己脑补去）

但是很显然，时间复杂度炸了，不想了

手动操作一下，发现了一点东西：加一个点等于把环上在它左右两点之间的距离减去，然后分别加上它与这两点的距离！根据对称性，删去一个点也能这么玩！

好了，又蒙蔽了：我怎么知道哪两个点在左右啊！！！！

点开题解一看，哟西，dfs序？

去卫生间熏陶一下，嗯好像有点道理？

于是就很好做了......预处理出dfs序和倍增找爹表，两点间的距离就可以用 dep[u]+dep[v]-2*dep[u]*dep[v] 来表示了（当然我）偷懒直接原地解决了

然后就用一个set维护一下在dfs序上的前驱和后继然后就完事了......

```cpp
#include<bits/stdc++.h>
using namespace std;
std::set<long long>s;
std::set<long long>::iterator it;
long long N,M,size,head[200005],seg[100005],cnt,pos[100005];
long long dep[100005],fa[100005][18],dis[100005][18];
long long lg2[100005]={-1},vis[100005];

struct node{
	long long nxt,to,dis;
}edge[200005];

void adde(long long from,long long to,long long dis){
	size++;
	edge[size].dis=dis;
	edge[size].to=to;
	edge[size].nxt=head[from];
	head[from]=size;
}

void prepare(long long cur,long long pa,long long dist){
	seg[cur]=++cnt;pos[cnt]=cur;
	dep[cur]=dep[pa]+1;fa[cur][0]=pa;dis[cur][0]=dist;
	for(long long i=1;i<=lg2[dep[cur]];i++){
		fa[cur][i]=fa[fa[cur][i-1]][i-1];
		dis[cur][i]=dis[cur][i-1]+dis[fa[cur][i-1]][i-1];
	}
	for(long long i=head[cur];i;i=edge[i].nxt){
		long long v=edge[i].to;if(v==pa)continue;
		prepare(v,cur,edge[i].dis);
	}
}

long long getl(long long x){
	it=s.lower_bound(x);
	if(it==s.begin())it=s.end();
	return *--it;
}

long long getr(long long x){
	it=s.lower_bound(x);
	if(++it==s.end())it=s.begin();
	return *it;
}

long long LCA(long long x,long long y){
	long long ans=0;
	if(dep[x]<dep[y])swap(x,y);
	while(dep[x]!=dep[y]){
		ans+=dis[x][lg2[dep[x]-dep[y]]];
		x=fa[x][lg2[dep[x]-dep[y]]];
	}
	if(x==y)return ans;
	for(long long i=lg2[dep[x]];i>=0;i--){
		if(fa[x][i]==fa[y][i])continue;
		ans+=dis[x][i]+dis[y][i];
		x=fa[x][i],y=fa[y][i];
	}
	return ans+dis[x][0]+dis[y][0];
}

int main(){
	scanf("%lld",&N);scanf("%lld\n",&M);
	for(long long i=1;i<=N;i++)lg2[i]=lg2[i/2]+1;
	for(long long i=1,x,y,z;i<N;i++){
		scanf("%lld%lld%lld",&x,&y,&z);
		adde(x,y,z);adde(y,x,z);
	}
	prepare(1,0,0);
	long long ans=0;
	for(long long i=1,x;i<=M;i++){
		scanf("%lld",&x);
		if(!vis[x]){
			vis[x]^=1;
			s.insert(seg[x]);
			ans+=LCA(pos[getl(seg[x])],x)+LCA(pos[getr(seg[x])],x)-LCA(pos[getl(seg[x])],pos[getr(seg[x])]);
		}
		else{
			vis[x]^=1;
			ans-=LCA(pos[getl(seg[x])],x)+LCA(pos[getr(seg[x])],x)-LCA(pos[getl(seg[x])],pos[getr(seg[x])]);
			s.erase(seg[x]);
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：muller (赞：2)

 显然答案是虚树中边长的两倍.
 我们用set来维护虚树中的点的dfs序。
 可以发现set中相邻点的距离的和再加上第一个点和最后一个点的距离就是答案。
 所以对于每次修改。 我们把修改的点的dfs序加入set,或从set中删除。
 然后找到这个点的位置.加上或减去它和它旁边的点的距离。再减去或加上它旁边两个点的距离即可
上代码
```cpp
#include <bits/stdc++.h>
#define lb lower_bound
#define ub upper_bound
using namespace std;
typedef long long ll;
const int N = 100005, M = (N << 1), K = 21;
int n, q, ecnt = 0, idx, to[M], nxt[M], fir[N], depth[N], fa[N][K], dfn[N], pos[N];
ll dis[N], len[M], ans; bool vis[N]; set <int> S;
template <class T> void rd(T &x) {
	char c = getchar(); int f = 1; x = 0;
	for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
	for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
	x *= f;
}
void ae(int u, int v, ll w) {to[++ecnt] = v; len[ecnt] = w; nxt[ecnt] = fir[u]; fir[u] = ecnt;}
int lca(int u, int v) {
	int i; if (depth[u] < depth[v]) swap(u, v);
	for (i = 20; ~i; --i) if (depth[fa[u][i]] >= depth[v]) u = fa[u][i];
	if (u == v) return u;
	for (i = 20; ~i; --i) if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
	return fa[u][0];
}
ll calc(int u, int v) {return dis[u] + dis[v] - dis[lca(u, v)] * 2;}
void dfs(int u, int dep, int f) {
	int i; dfn[u] = ++idx; pos[idx] = u; depth[u] = dep; fa[u][0] = f;
	for (i = fir[u]; i; i = nxt[i]) {
		int v = to[i], w = len[i];
		if (v != f) dis[v] = dis[u] + w, dfs(v, dep + 1, u);
	}
}
int main() {
	int i, j; rd(n); rd(q);
	for (i = 1; i < n; ++i) {
		int u, v; ll w; rd(u); rd(v); rd(w);
		ae(u, v, w); ae(v, u, w);
	}
	dfs(1, 1, 0); S.insert(-1); S.insert(999999);
	for (i = 1; i <= 20; ++i)
		for (j = 1; j <= n; ++j) fa[j][i] = fa[fa[j][i - 1]][i - 1];
	for (i = 1; i <= q; ++i) {
		int x, p, l, r; ll tmp = 0; rd(x);
		if (!vis[x]) S.insert(dfn[x]), p = 1; else S.erase(dfn[x]), p = -1;
		vis[x] ^= 1; l = *--S.lb(dfn[x]); r = *S.ub(dfn[x]);
		if (l != -1) ans += calc(pos[l], x) * p; if (r != 999999) ans += calc(pos[r], x) * p;
		if (l != -1 && r != 999999) ans -= calc(pos[l], pos[r]) * p;
		if (S.size() != 2) tmp = calc(pos[*++S.begin()], pos[*--S.lb(999999)]);
		printf("%lld\n", ans + tmp);
	}
	return 0;
}

```

---

## 作者：Saber_Master (赞：1)

[P3320 [SDOI2015]寻宝游戏](https://www.luogu.com.cn/problem/P3320)

虚树.

询问有动态将点插入到查询集的操作，所以我们考虑构造虚树.这里提供一种简单的构造方式.

我们将查询集中的节点按照时间戳从小到大排序，排好序后依次扫描相邻的点对，最终答案即为相邻点对距离之和.有一个小点注意一下，最后一个点相邻的点是第一个点.

至于动态单点修改查询集，又要保持序列时间戳有序，我们可以使用平衡树，这里用了$STL-set$.剩下的注意注意细节就好了.

$O(nlog^2n)$

核心代码

```

set<ll> s;
ll res;

#define It set<ll>::iterator
//calc函数表示两时间戳对应点对的距离，倍增求即可
inline void Insert(ll x){
	if (s.empty()) return (void)(s.insert(x));
	if (s.size()==1){
		res=(calc(*s.begin(), x)<<1);
		s.insert(x);
		return;
	}
	It itr=s.lower_bound(x), itl;
	if (itr==s.end()) --itr, itl=s.begin();
	else if (itr==s.begin()) itl=--s.end();
	else itl=itr, --itl;
	res-=calc(*itl, *itr);
	res+=calc(*itl, x)+calc(*itr, x);
	s.insert(x);
	return;
}

inline void Erase(ll x){
	It it=s.find(x);
	if (s.size()<=2){
		s.erase(it); res=0;
		return;
	}
	It itr=it, itl=it;
	++itr;
	if (itr==s.end()) itr=s.begin(), --itl;
	else if (itl==s.begin()) itl=--s.end();
	else --itl;
	res-=calc(*itl, *it)+calc(*it, *itr);
	res+=calc(*itl, *itr);
	s.erase(it);
	return;
}

bool book[N];

inline void solve(ll x){
	if (book[x]) Erase(dfn[x]);
	else Insert(dfn[x]);
	book[x]^=1;
}
```


---

## 作者：crh1272336175 (赞：1)

方法：LCA+时间戳+set

使用时间戳，并且按照时间戳从小到大的顺序，把有宝物的村庄节点排成一圈（首尾相连），并且累加相邻两个节点之间的路径长度，最后得到的恰好就是答案。

可以用set进行维护，每次有一个新的t点来的时候，在set中寻找t的le和ri点，如果是insert操作，那么
$ans+=path(le,t)+(t,ri)-path(le,ri)$

反之则$ans+=-path(le,t)-(t,ri)+path(le,ri)$

其中path的计算使用LCA即可

时间复杂度$O((N+M)log(N)$

AC代码：

```cpp
#include<bits/stdc++.h>
#pragma GCC opitimize(2)
using namespace std;
typedef long long ll;
typedef pair<ll,ll> PLL; 
const int N=1e5+5;
ll n,tot,m,cnt,t=18,ans;
ll head[N],Next[N<<1],des[N<<1],len[N<<1];
ll dfn[N],dep[N],d[N],f[N][20];
set<PLL> s;
set<PLL>::iterator it,it2,le,ri;
inline ll read()
{
    ll s=0,f=1; char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)) s=s*10+(ch^48),ch=getchar();
    return s*f;
}
inline void write(ll x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
inline void add(ll a,ll b,ll c)
{
	Next[++tot]=head[a]; des[tot]=b; len[tot]=c;
	head[a]=tot;
}
ll dfs(ll x)
{
	dfn[x]=++cnt;
	for(ll i=head[x]; i; i=Next[i])
	{
		ll y=des[i],z=len[i];
		if(dep[y]) continue;
		dep[y]=dep[x]+1;
		d[y]=d[x]+z;
		f[y][0]=x;
		for(ll j=1; j<=t; j++)
		    f[y][j]=f[f[y][j-1]][j-1];
		dfs(y);
	}
}
inline ll lca(ll x,ll y)
{
	if(dep[x]>dep[y]) swap(x,y);//保证x的深度小于等于y
	for(ll i=t; i>=0; i--)
	    if(dep[f[y][i]]>=dep[x]) y=f[y][i];
	if(y==x) return x;
	for(ll i=t; i>=0; i--)
		if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
inline ll path(ll x,ll y)
{
	return d[x]+d[y]-2*d[lca(x,y)];
}
inline void Insert(ll x)
{
	s.insert({dfn[x],x});
	it2=it=s.find({dfn[x],x});
	if(it==s.begin()) le=--s.end();
	else le=--it;
	it=it2;
	if(it==--s.end()) ri=s.begin();
	else ri=++it;
	it=it2;
	ll a=(*le).second,b=(*it).second,c=(*ri).second;
	ans+=path(a,b)+path(b,c);
	ans-=path(a,c);
}
inline void del(ll x)
{
	it2=it=s.find({dfn[x],x});
	if(it==s.begin()) le=--s.end();
	else le=--it;
	it=it2;
	if(it==--s.end()) ri=s.begin();
	else ri=++it;
	it=it2;
	ll a=(*le).second,b=(*it).second,c=(*ri).second;
	ans-=path(a,b)+path(b,c);
	ans+=path(a,c);
	s.erase({dfn[x],x});
}
int main()
{
	n=read(); m=read();
	for(ll i=1; i<n; i++)
	{
		ll a=read(),b=read(),c=read();
		add(a,b,c); add(b,a,c);
	}
	dep[1]=1; 
	dfs(1);
	for(ll i=1; i<=m; i++)
	{
		int t=read();
		if(s.find({dfn[t],t})!=s.end()) del(t);
		else Insert(t);
		if(s.size()<=1) puts("0");
		else write(ans),printf("\n");
	}
	return 0;
}
```


---

## 作者：幻离ian (赞：0)

## 题意：

- 给一颗n个节点边带权的树，m次操作每次使一个点由非关键点和关键点相互转换。

- 每次操作后输出使所有关键点连通权值和最小路径权值和的2倍

## 思路：

1. **先看n个点的最短连通。**

	
	我们可以先对这棵树进行深度优先遍历，记录下每个点的时间戳，用两个数组将每个点的时间戳与在原数组中的位置映射一下（在dfs建树时即可实现）。每次询问将所有关键点按时间戳大小排成一圈，并累加相邻两个节点之间的路径长度，即得到结果。
    
1. **求相邻两点间的路径长度。**

	  $fv[i]$表示i点到根节点的路径长度（亦可在dfs与处理中得到）。
      
	所以：
    
      $distance(x,y)=fv[x]+fv[y]-2\times fv[lca(x,y)]$。
      
      我不会剖分求lca，所以用的是倍增。
      
1. **时间戳的维护。**

	最开始想的是每次dfs存下关键点再处理每次操作$O(n)$,显然会TLE。
    
    于是想着用平衡树，但码量太大，只好用STL set。每次操作，若增加一个关键点x，则把它插入到set中合适的地方,设前后节点	分别为l和r，就令ans减去 $distance(l,r)$，加上$distance(l,x)$和$distance(x,r)$。删去一个关键点的操作同理。


时间复杂度为：$O((n+m)\log n)$

代码：
```cpp
#include <iostream>
#include <cstdio>
#include <set>
using namespace std;
int n,m,x,y,z,fs[100001],nex[200000],tot,va[200000],go[200000],f[100005][20],dep[100001];
int seg[100001],rev[100001];
long long fv[100001],ans,tem;
int t,a[100001];
set<int>::const_iterator itor;
set<int>s;
set<int>::iterator it;
inline void Add(int u,int v,int z){
    nex[++tot]=fs[u];fs[u]=tot;va[tot]=z;go[tot]=v;
    nex[++tot]=fs[v];fs[v]=tot;va[tot]=z;go[tot]=u;
}
void deal(int u,int fa){
	seg[u]=++seg[0];
	rev[seg[u]]=u;//位置的映射
    dep[u]=dep[fa]+1;
    for(int i = 0;i<19;i++)
        f[u][i+1]=f[f[u][i]][i];

    for(int e=fs[u];e;e=nex[e]){
        int v=go[e];
        if(v==fa)continue;
        f[v][0]=u;
        fv[v]=fv[u]+va[e];//预处理v到根的费用
        deal(v,u);
    }
}
inline int LCA(int x,int y){
    if(dep[x]<dep[y])swap(x,y);
    for(int i  =18;i>=0;i--){
        if(dep[f[x][i]]>=dep[y])x=f[x][i];
        if(x==y)return x;
    }
    for(int i = 18;i>=0;i--)
        if(f[x][i]!=f[y][i]){
                x=f[x][i];y=f[y][i];
        }

    return f[x][0];
}
inline long long dis(int x,int y){
	return fv[rev[x]]+fv[rev[y]]-2*fv[LCA(rev[x],rev[y])];
}
inline void Out(int t) {//删除一个关键点
  if (s.size() <= 2) {
    ans = 0; 
    s.erase(t); 
    return;
  }
  if (s.size() == 3) {
    s.erase(t);
    ans = dis(*s.begin(),*(--s.end()))*2;
    return;
  }
  it = s.lower_bound(t);
  x = (it == s.begin()) ? *(--s.end()) : *(--it);
  it = s.lower_bound(t);
  y = (it == --s.end()) ? *(s.begin()) : *(++it);
  ans -= dis(x, t) + dis(t, y) - dis(x, y);
  s.erase(t);
}

inline void In(int t) {//插入一个关键点
  if (s.size() == 0) {
    ans = 0;
    s.insert(t);
    return;
  }
  if (s.size() == 1) {
    ans = 2 * dis(t,*s.begin());
    s.insert(t);
    return;
  }
  s.insert(t);
  it = s.lower_bound(t);
  x = (it == s.begin()) ? *(--s.end()) : *(--it);
  it = s.lower_bound(t);
  y = (it == --s.end()) ? *(s.begin()) : *(++it);
  ans += dis(x, t) + dis(t, y) - dis(x, y);
}
int main(){
    cin>>n>>m;
    for(int i = 1;i<n;i++){
        scanf("%d%d%d",&x,&y,&z);
        Add(x,y,z);
    }
    deal(1,0);
    for(int i = 1;i<=m;i++){
        scanf("%d",&t);
        a[t]^=1;//1变0，0变1
        
        if(a[t]==1)
        	In(seg[t]);
		else
			Out(seg[t]);
        printf("%lld\n",ans);
    }
    return 0;
}
```


---

## 作者：丛雨 (赞：0)

> ## 思路：

> 先用线段树分治以时间分割操作，用树链剖分维护宝藏到根的覆盖区间（去重）的长度并染色，再减去所有宝藏$lca$到根的距离后$*2$，时间复杂度$O(nlog^2n)$

> $ps$:维护时直接寻找当前节点最近的染色祖先

> $\mathfrak{Talk\ is\ cheap,show\ you\ the\ code.}$

```cpp
#include<cstdio>
#include<stack>
#include<vector>
#include<algorithm>
using namespace std;
# define read read1<int>()
# define Type template<typename T>
Type inline const T read1(){
    T m=0;
    char k=getchar();
    while(('0'>k||k>'9')&&(k!='-'))k=getchar();
    const bool f=(k=='-'?1:0);
    if(f)k=getchar();
    while('0'<=k&&k<='9')m=(m<<3)+(m<<1)+(k^48),k=getchar();
    return f?-m:m;
}
# define ll long long
# define N 100000
int s,m,now[N|1],fa[N|1],top[N|1],siz[N|1],tm[N|1];
ll h[N|1];
vector<int>G[N|1],V[N|1],tr[N<<2|1];
void add(int l,int r,int dl,int dr,int v,int d){
    if(l==dl&&r==dr){
        tr[d].push_back(v);
        return;
    }
    int mid=l+r>>1;
    if(dr<=mid)add(l,mid,dl,dr,v,d<<1);
    else if(mid<dl)add(mid+1,r,dl,dr,v,d<<1|1);
    else add(l,mid,dl,mid,v,d<<1),add(mid+1,r,mid+1,dr,v,d<<1|1);
}
void dfs1(int n,int f){
    fa[n]=f;
    siz[n]=1;
    for(int i=0;i<G[n].size();++i)
        if(G[n][i]^f)
            h[G[n][i]]=h[n]+V[n][i],dfs1(G[n][i],n),siz[n]+=siz[G[n][i]];
}
void dfs2(int n,int to){
    top[n]=to;
    int son=-1;
    for(int i=0;i<G[n].size();++i)
        if(G[n][i]^fa[n]&&(!~son||siz[G[n][i]]>siz[G[n][son]]))
            son=i;
    for(int i=0;i<G[n].size();++i)
        if(G[n][i]^fa[n])
            if(i^son)dfs2(G[n][i],G[n][i]);
            else dfs2(G[n][i],to);
}
ll ans[N|1],t;
int tot;
stack<pair<int,int> >sta[30];
void solve(int n){
    if(h[tm[top[n]]]>=h[n])return;
    int i=n;
    while(i&&!tm[top[i]])tm[top[i]]=i,i=fa[top[i]];
    sta[tot].push(make_pair(n,tm[top[i]]));
    t+=h[n]-min(h[tm[top[i]]],h[i]);
    if(i&&h[tm[top[i]]]<=h[i])tm[top[i]]=i;
    // printf("-<%d %d\n",n,tm[top[i]]);
}
int lca(int l,int r){
    while(top[l]!=top[r]){
        if(h[top[l]]>h[top[r]])swap(l,r);
        r=fa[top[r]];
    }
    return h[l]>h[r]?r:l;
}
void back(int n,int l){
    int i=n;
    while(top[i]!=top[l])tm[top[i]]=0,i=fa[top[i]];
    t-=h[n]-min(h[l],h[i]);
    tm[top[i]]=l;
    // printf("->%d %d\n",n,l);
}
void dfs(int d,int l,int r,int lc){
    for(int i=0;i<tr[d].size();++i){
        lc=lc?lca(lc,tr[d][i]):tr[d][i];
        solve(tr[d][i]);
    }
    ++tot;
    if(l==r)ans[l]=t-h[lc]<<1;
    else{
        int mid=l+r>>1;
        dfs(d<<1,l,mid,lc);
        dfs(d<<1|1,mid+1,r,lc);
    }
    --tot;
    while(!sta[tot].empty())back(sta[tot].top().first,sta[tot].top().second),sta[tot].pop();
    // printf("%d %d:%lld %d\n",l,r,t,lc);
    // for(int i=1;i<=s;++i)
    //     printf("%d ",tm[i]);
    // putchar('\n');
}
int main(){
    s=read,m=read;
    for(int i=1;i<s;++i){
        int u=read,v=read,t=read;
        G[u].push_back(v);
        V[u].push_back(t);
        G[v].push_back(u);
        V[v].push_back(t);
    }
    for(int i=1;i<=m;++i){
        int k=read;
        if(now[k]){
            add(1,m,now[k],i-1,k,1);
            now[k]=0;
        }
        else now[k]=i;
    }
    for(int i=1;i<=s;++i)
        if(now[i])
            add(1,m,now[i],m,i,1);
    dfs1(1,0);
    // cout<<fa[1]<<endl;
    dfs2(1,1);
    dfs(1,1,m,0);
    for(int i=1;i<=m;++i)
        printf("%lld\n",ans[i]);
	return 0;
}
```


---

## 作者：JZYshuraK (赞：0)

# 寻宝游戏

题解：
我们发现如果给定了一些点有宝物的话那么答案就是树链的并。

树链的并的求法就是把所有点按照$dfs$序排序然后相加再减去相邻之间的$lca$。

故此我们按照$dfs$序维护一个平衡树。

每次往里插入节点即可。

实时用$lca$更新答案，复杂度$O(nlogn)$。

Code:
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <set>
#define N 100010 
using namespace std; typedef long long ll;
set<int>s;
int head[N],nxt[N<<1],to[N<<1],tot; ll val[N<<1];
ll dis[N],ans; int dic[N],f[22][N],size[N],re[N],dep[N],cnt;
bool vis[N];
inline char nc() {static char *p1,*p2,buf[100000]; return (p1==p2)&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;}
ll rd() {ll x=0; char c=nc(); while(!isdigit(c)) c=nc(); while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=nc(); return x;}
inline void add(int x,int y,ll z) {to[++tot]=y; val[tot]=z; nxt[tot]=head[x]; head[x]=tot;}
void dfs(int pos,int fa)
{
	f[0][pos]=fa; for(int i=1;i<=20;i++) f[i][pos]=f[i-1][f[i-1][pos]];
	dep[pos]=dep[fa]+1; dic[pos]=++cnt,re[cnt]=pos; size[pos]=1; for(int i=head[pos];i;i=nxt[i]) if(to[i]!=fa)
	{
		dis[to[i]]=dis[pos]+val[i]; dfs(to[i],pos); size[pos]+=size[to[i]];
	}
}
int lca(int x,int y)
{
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=20;~i;i--) if(dep[f[i][x]]>=dep[y]) x=f[i][x];
	if(x==y) return x;
	for(int i=20;~i;i--) if(f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
	return f[0][x];
}
inline void output()
{
	set<int>::iterator it=s.begin();
	for(;it!=s.end();it++) printf("%d ",*it); puts("");
}
int main()
{
	int n=rd(),m=rd(); for(int i=1;i<n;i++) {int x=rd(),y=rd(); ll z=rd(); add(x,y,z); add(y,x,z);}
	dfs(1,1);
	// for(int i=1;i<=n;i++) printf("%d %d %d %d %d %d\n",re[dic[i]],dis[i],dic[i],dep[i],size[i],f[0][i]);
	for(int i=1;i<=m;i++)
	{
		int x=rd();
		if(s.empty()) {s.insert(dic[x]),ans=dis[x]; vis[x]=true;}
		else if(!vis[x])
		{
			vis[x]=true;
			set<int>::iterator it1=s.lower_bound(dic[x]);
			set<int>::iterator it2=s.upper_bound(dic[x]);
			if(it2==s.end())
			{
				it1--;
				ans+=dis[x]-dis[lca(x,re[*it1])];
			}
			else
			{
				if(it1==s.begin()) ans+=dis[x]-dis[lca(x,re[*it1])];
				else
				{
					it1--;
					int y=re[*it1],z=re[*it2];
					ans+=dis[x]+dis[lca(y,z)]-dis[lca(x,y)]-dis[lca(x,z)];
				}
			}
			s.insert(dic[x]);
		}
		else
		{
			vis[x]=false;
			set<int>::iterator it1=s.lower_bound(dic[x]);
			set<int>::iterator it2=s.upper_bound(dic[x]);
			if(it2==s.end())
			{
				if(it1==s.begin()) ans=0;
				else
				{
					it1--;
					int y=re[*it1];
					ans+=dis[lca(x,y)]-dis[x];
				}
			}
			else
			{
				if(it1==s.begin())
				{
					int z=re[*it2];
					ans+=dis[lca(x,z)]-dis[x];
				}
				else
				{
					it1--;
					int y=re[*it1],z=re[*it2];
					ans+=dis[lca(y,x)]+dis[lca(x,z)]-dis[x]-dis[lca(y,z)];
				}
			}
			s.erase(dic[x]);
		}
		// output();
		// cout << ans << endl ;
		set<int>::iterator it1=s.begin();
		set<int>::iterator it2=s.end();
		if(it1==it2) puts("0");
		else
		{
			it2--;
			if(it1==it2) puts("0");
			else printf("%lld\n",(ans-dis[lca(re[*it1],re[*it2])])*2);
		}
	}
	return 0;
}
```

推销个人blog [JZYshuraK](https://www.cnblogs.com/ShuraK/p/10163820.html)

---


# [ZJOI2014] 璀灿光华

## 题目描述

金先生有一个女朋友没名字。她勤劳勇敢、智慧善良。金先生很喜欢她。为此，金先生用 $a^3$ 块 $1\times 1 \times 1$ 的独特的水晶制作了一个边长为 $a$ 的水晶立方体，他要将这个水晶立方体送给他见过最单纯善良的她。

由于水晶立方体太太，不好运送，金先生还是将它拆开来送出。他相信拼好这个水晶立方难不倒聪明的她。

没名字收到了礼物后果然不一会儿就根据说明将水晶立方体拼好了。没名字发现，有 $n$ 块水晶在漆黑安静的夜晚会随机以等概率向上下左右前后六个方向的一个发出穿透光。被光照到的水晶显得格外好看。没名字给每一块不会发光的水晶定义了一个好看程度。水晶立方体在夜晚中的好看程度就是每块被光照到的水晶的好看程度之和。没名字想知道，水晶立方体在夜晚中的好看程度的最小值和最大值。

## 说明/提示

对于所有数据，$1<a\leq 70$，$g_i<10^6$，$n\leq 8$。


## 样例 #1

### 输入

```
2
0 7 2 3
0 8 1 4
4 5 4 1
8 6 3 2
16 3 6 7
32 4 5 8
1 1 8 5
2 2 7 6```

### 输出

```
0 12```

# 题解

## 作者：kczno1 (赞：7)

6^8\*70爆搜是容易的，

难度在于如何利用每个点相邻的点的编号得到每个点的坐标。

用(x,y,z)表示在平面上坐标(x,y)，高度z的点。

首先，我们找一个度数为3的点，把他当成(1,1,1)。

假如得到高度为1的那一层平面，我们就可以一层层推上去。

考虑如何从当前1-a,1-a这样的一个正方形扩展成a+1的。

高度为1的点的特点是度数=4(如果在边缘上)或5，而上面的点的度数是5或6。

所以我们可以先用原来度数=4的两个点找出现在度数=4的两个点，

之后从他们开始bfs,只有当一个点有两个已访问的相邻点时才访问它。

还有一点，就是读入时你不知道要读几个，必须读到换行为止，

于是我直接用了读入优化。

```cpp
#include<bits/stdc++.h>
using std::swap;

const int A=75,N=A*A*A+5;
int a,n,x,y;
int mn=1e9,mx=0;
int g[N],du[N],link[N][7];
struct point
{
    int x,y,z;
}p[N];
int have[N];//有多少个已访问的相邻点 

namespace kcz
{
    const int ch_top=10000000;
    char ch[ch_top],*p=ch;
    void read(int &x)
    {
        while(*p<'0') ++p;
        for(x=*p-'0';*++p>='0';) x=(x<<1)+(x<<3)+*p-'0';
    }
    void init()
    {
        ch[fread(ch,1,ch_top,stdin)]='\n';
    }
    void init(int x)
    {
        read(g[x]);
        int &i=du[x];
        for(;;++i)
        {
            for(;*p<'0';++p)  
            if(*p=='\n') return ;
            read(link[x][i]);
        }
    }
};

int q[N],head,tail;

void Add(int x)
{
    for(int i=0,y;i<du[x];++i) 
    if(++have[y=link[x][i]]==2&&!p[y].x) q[++tail]=y;
}
void get(int x)
{
    int p1=0,p2,i;
    for(i=0,y;i<du[x];++i) 
    if(p[y=link[x][i]].x) 
     if(!p1)p1=y;
     else {p2=y;break;}
    if(p[p1].x>p[p2].x) swap(p1,p2);
    p[x]=(point){p[p2].x,p[p1].y,1};
}

const int fx[6]={0,0,0,0,1,-1},fy[6]={0,0,1,-1,0,0},fz[6]={1,-1,0,0,0,0};
int dy[A][A][A],mark[N],to;
bool ok(int x)
{
    return x>0&&x<=a;
}
void dfs(int num,int ans)
{
    if(num>tail) 
    {
      if(ans<mn)mn=ans;
      if(ans>mx)mx=ans;    
      return;
    }
    int k=q[num];
    for(int i=0;i<6;++i)
    {
        int x=p[k].x,y=p[k].y,z=p[k].z,sum=0;
        while(to=dy[x][y][z])
        {
            if(++mark[to]==1) sum+=g[to]; 
            x+=fx[i];y+=fy[i];z+=fz[i];
        }
        dfs(num+1,ans+sum);
        x=p[k].x;y=p[k].y;z=p[k].z;
        while(to=dy[x][y][z])
        {
           --mark[to];
            x+=fx[i];y+=fy[i];z+=fz[i];
        }
    }
}

int main()
{
    freopen("1.in","r",stdin);
    kcz::init();
    kcz::read(a);n=a*a*a;
    int i;
    for(i=1;i<=n;++i) 
     kcz::init(i);
    
    for(i=1;du[i]!=3;++i);
    p[i]=(point){1,1,1};Add(q[tail=1]=i);
    p[q[++tail]=link[i][0]]=(point){1,2,1};
    p[q[++tail]=link[i][1]]=(point){2,1,1};
    Add(q[2]);Add(q[3]);
    p[q[4]]=(point){2,2,1};
    Add(q[4]);

    int len=2,need,t0;
    for(head=2;len<a;++len)
    {
        if(len==a-1) need=3;
        else need=4;
          x=q[head];
          for(int i=0,y;i<du[x];++i) 
          if(du[y=link[x][i]]==need&&!p[y].x) 
          {
               p[y]=(point){1,len+1,1};
               q[++tail]=y;
               break;
          }
          x=q[head+1];
          for(int i=0,y;i<du[x];++i) 
          if(du[y=link[x][i]]==need&&!p[y].x) 
          {
               p[y]=(point){len+1,1,1};
               q[++tail]=y;
               break;
          }
        head=tail-1;
        for(int k=head;;++k)
        {
            x=q[k];
            Add(x);
            if(k==tail) break;
            get(q[tail]);
        }
    }
    
    for(head=1;head<=tail;)
    {
        t0=tail;
        for(;head<=t0;++head) 
        {
            x=q[head];
            for(i=0;y=link[x][i];++i)
            if(!p[y].x) 
            {
                q[++tail]=y;
                p[y]=(point){p[x].x,p[x].y,p[x].z+1};
                break;
            }
        }
    }
    
    tail=0;
    for(i=1;i<=n;++i)
    {
      dy[p[i].x][p[i].y][p[i].z]=i;
      if(!g[i]) q[++tail]=i;
    }
    dfs(1,0);
    printf("%d %d\n",mn,mx);
}
```

---

## 作者：pufanyi (赞：4)

首先，介绍一下c++ stl里的神物——`stringstream`。

这东西能像`cin`那样读入，但是是从字符串中读入，所以我们就不用打快读了（虽然慢了一点，但开氧气之后海星）。

头文件`<sstream>`

大概就是这样读：

```cpp
for(int i = 1; i <= n; ++i)
{
	getline(cin, tmp);
	stringstream ss(tmp);
	ss >> dep[i];
	int aa;
	while(ss >> aa)
		add_edge(i, aa);
}
```

题目中的照射不仅只照到了与该水晶相邻的水晶，它把整条射线上的水晶全照到了。

所以我们只能考虑建出这个立方体后重新建图。

我的思路是这样的：

先找到一个度为3的点作为一个角的点，用bfs求出其道个点的最短路。记以该点为原点的第$i$个点坐标为$(x_{1, i}, y_{1, i}, z_{1, i})$，最短路为$dist[0][i]$，显然有$dist[0][i] = x_{1, i} - 1+ y_{1, i} - 1 + z_{1, i} - 1$。

我们任选一个平面，要求包含刚才那个点。我们找到在该平面上该点对角线上的点，其实就是随便找一个度为3（在角上）且与原点距离$2(n-1)$（在该平面上最远）的点。以该点为原点跑一遍最短路，记$dist[1][i]$。

由于我们设计最短路时，可以先走到该点正下方，再往上爬，同样，我们可以设计成先走$y$，再走$x$，最后走$z$。

![](https://github.com/pfypfypfy/images-in-blogs/blob/master/20180708001.png?raw=true)

我们发现$dist[0][i] +dist[1][i]=2(n-1)$，我们把它减去，就只剩下$2z$了，于是$z$就求出来了：

```cpp
/**
 ddn是度数
 di是原点
 poi记录点的x, y, z
 这里的n已经是点的个数了
 tn才是边长
 由于从1开始，所以有些地方微调了一下
 */
for(di[0] = 1; ddn[di[0]] > 3; ++di[0]);
bfs(0);
for(int i = 1; i <= n; ++i)
{
	if(ddn[i] == 3 && dist[0][i] == ((tn-1)<<1))
	{
		di[1] = i;
		break;
	}
}
bfs(1);
for(int i = 1; i <= n; ++i)
	poi[i].z = (dist[0][i] + dist[1][i] - ((tn-2)<<1)) >> 1;
```

我们可以用同样的方法把$x$解出来，最后的$y$只要减一下就可以了。因为我的坐标是从1开始的，所以我对坐标做了一些微调，从0开始就没有这个问题。

由于之前bfs的数据我们还能用，所以我们只需再一遍bfs即可

```cpp
for(int i = 1; i <= n; ++i)
	if(poi[i].z == tn && dist[0][i] == dist[1][i] && ddn[i] == 3)
		di[2] = i;
bfs(2);
for(int i = 1; i <= n; ++i)
{
	poi[i].x = (dist[0][i] + dist[2][i] - ((tn-1)<<1)) >> 1;
	poi[i].y = (dist[0][i] - poi[i].x - poi[i].z) + 1;
	poi[i].x++;
	poi[i].y++;
	mmap[poi[i].x][poi[i].y][poi[i].z] = i;
}
```

于是我们就建好图了。

后面的大力dfs也没什么好说的。

下面把ac代码贴一下，由于`stringstream`在没有氧气的情况下极慢，所以必须开氧气。

```cpp
// luogu-judger-enable-o2
#include <cstring>
#include <iostream>
#include <fstream>
#include <sstream>//stringstream 
#include <queue>

using namespace std;

const int maxm = 2058000;//这里的最大边数我是把点数加起来乘了6 
const int maxn = 75*75*75;
const int inf = 0x3f3f3f3f;

int n;//总个数 
int tn;//边长 

struct Edge
{
    int to, nxt;
} e[maxm<<1];

int first[maxn];

int cnt;
inline void add_edge(int f, int t)
{
    e[++cnt].nxt = first[f];
    first[f] = cnt;
    e[cnt].to = t;
}

int dirx[] = {1, -1, 0, 0, 0, 0};
int diry[] = {0, 0, 1, -1, 0, 0};
int dirz[] = {0, 0, 0, 0, 1, -1};

int dep[maxn];//"好看程度" 
int vis[maxn];
int minn = inf;
int maxx = -inf;
int ll[10];//会发光的水晶的编号 
int ddn[maxn];//度数 
int zl;//这是个ddn的cnt 
int mmap[73][73][73]; 

struct zb
{
    int x, y, z;
} poi[maxn];

#define pan (x > 0 && x <= tn && y > 0 && y <= tn && z > 0 && z <= tn)
#define nxxt x += dirx[i], y += diry[i], z += dirz[i]

inline int getans(int i, zb a)//能加多少"好看程度"
{
    int ans = 0;
    int x = a.x, y = a.y, z = a.z;
    for(; pan; nxxt)
        if(!vis[mmap[x][y][z]]++)//由于待会儿回溯时要删除，所以懒到家的我就直接用++,--代替记录了 
            ans += dep[mmap[x][y][z]];
    return ans;
}

inline void delvis(int i, zb a)//回溯时把dfs前加的vis删除 
{
    int x = a.x, y = a.y, z = a.z;
    for(; pan; nxxt)
        vis[mmap[x][y][z]]--;
}

inline void dfs(int now, int ans)//大力枚举所有情况 
{
    if(now > zl)
    {
        minn = min(minn, ans);
        maxx = max(maxx, ans);
        return;
    }
    for(int i = 0; i < 6; ++i)
    {
        dfs(now+1, ans + getans(i, poi[ll[now]]));
        delvis(i, poi[ll[now]]);
    }
}

int dist[4][maxn];
int di[4];
bool viss[maxn];

inline void bfs(int id)//求最短路 
{
    memset(viss, 0, sizeof(viss));
    queue<int> q;
    int from = di[id];
    viss[from] = true;
    q.push(from);
    while(!q.empty())
    {
        int now = q.front();
        q.pop();
        for(int i = first[now]; i; i = e[i].nxt)
        {
            int to = e[i].to;
            if(!viss[to])
            {
                viss[to] = true;
                dist[id][to] = dist[id][now] + 1;
                q.push(to);
            }
        }
    }
}

int main() 
{
    ios:: sync_with_stdio(false);
    cin >> n;
    tn = n;
    string tmp;
    getline(cin, tmp);
    n *= n * n;
    for(int i = 1; i <= n; ++i)
    {
        getline(cin, tmp);
        stringstream ss(tmp);
        ss >> dep[i];
        int aa;
        if(!dep[i])
        {
            vis[i] = true;
            ll[++zl] = i;
        }
        while(ss >> aa)
        {
            add_edge(i, aa);
            ddn[i]++;
        }
    }
    for(di[0] = 1; ddn[di[0]] > 3; ++di[0]);
    bfs(0);
    for(int i = 1; i <= n; ++i)
    {
        if(ddn[i] == 3 && dist[0][i] == ((tn-1)<<1))
        {
            di[1] = i;
            break;
        }
    }
    bfs(1);
    for(int i = 1; i <= n; ++i)//得到z 
    {
        poi[i].z = (dist[0][i] + dist[1][i] - ((tn-2)<<1)) >> 1;
        if(poi[i].z == tn && dist[0][i] == dist[1][i] && ddn[i] == 3)
            di[2] = i;
    }
    bfs(2);
    for(int i = 1; i <= n; ++i)//得到x, y 
    {
        poi[i].x = (dist[0][i] + dist[2][i] - ((tn-1)<<1)) >> 1;
        poi[i].y = (dist[0][i] - poi[i].x - poi[i].z) + 1;
        poi[i].x++;
        poi[i].y++;
        mmap[poi[i].x][poi[i].y][poi[i].z] = i;
    }
    dfs(1, 0);
    cout << minn << ' ' << maxx << endl;
    fclose(stdin);
    fclose(stdout);
    return 0;
}
```



---

## 作者：MarchKid_J0e (赞：3)

# [P3342](https://www.luogu.com.cn/problem/P3342)

## 前言

3.11 的模拟考试居然放了这个令人无语的题：刚看到输入就无语了，理解错题意后也无语了，还原立方体时也无语了，考后发现被卡常了也无语了，总体来说~~依托答辩~~。本题 [loj](https://loj.ac/p/2203) 上的数据对常数大的人很不友好，如果被卡常了，可以看后言-优化。

## 题意

给定 ${n}\times{n}\times{n}$ 的立方体，每个 $1\times1\times1$ 的立方体有一个权值，其中 $m(m\leqslant8)$ 个点会向六个方向其中之一发射**穿透**光，问最后被光照到的所有 $1\times1\times1$ 的立方体权值和最大为多少？

## Solution

还原出立方体后暴力，时间复杂度 $O(k+n\times{m^6})$，$k$ 是还原立方体的常数。

难点就在还原立方体~~和输入~~，这里不介绍如何暴力求解~~和输入~~。

对 $1\times1\times1$ 的立方体简称为**小立方体**，对仅连接 $3$ 个小立方体的的小立方体简称为**角**。

根据高中**三维平面直角坐标系**的知识，首先可以随便找一个**角**确定为原点 $O(1,1,1)$。

设一个点 $P(x,y,z)$ 与 $O$ 的距离为 $d$，得到一个方程：

$$
(x-1)+(y-1)+(z-1)=d
$$

然后找到与 $O$ 的距离为 $n-1$ 的另外三个的**角**，每个**角**可以得到一个方程，得到方程组：

$$
\begin{aligned}
    (n-x)+(y-1)+(z-1)=d\\
    (x-1)+(n-y)+(z-1)=d\\
    (x-1)+(y-1)+(n-z)=d\\
\end{aligned}
$$

三元一次方程求解需要至少 $3$ 个方程，也就是说搜索完 $O$ 后再随便寻找两个与 $O$ 的距离为 $n-1$ 的**角**即可。

笔者选择了下面 $3$ 个方程：

$$
\begin{aligned}
&\begin{cases}
    (x-1)+(y-1)+(z-1)=d_1\\
    (x-1)+(y-1)+(n-z)=d_2\\
    (n-x)+(y-1)+(z-1)=d_3\\
\end{cases}
\\&\Downarrow\\
&\begin{cases}
    +x+y+z=d_1+3&(1)\\
    +x+y-z=d_2+2-n&(2)\\
    -x+y+z=d_3+2-n&(3)\\
\end{cases}
\\&\Downarrow\\
&\begin{cases}
    x=\frac{(1)-(3)}{2}\\
    y=\frac{(2)+(3)}{2}\\
    z=\frac{(1)-(2)}{2}\\
\end{cases}
\end{aligned}
$$

还原立方体后暴力求解即可。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace IO
{
    int cnt, sum;
    const int K = 70 + 1;
    const int M = 10;
    const int N = K * K * K;
    int read(){char c;int x=0;do cnt+=((c=getchar())=='\n');while(c<'0'||c>'9');while(c>='0'&&c<='9')x=x*10+c-48,c=getchar();return --sum,cnt+=(c=='\n'),x;}
    void print(int x){static int t[20];int top=0;if(x<0)putchar('-'),x=-x;do{t[++top]=x%10,x/=10;}while(x);while(top)putchar(t[top--]+48);}
}
using namespace IO;
int minn = +2e9, maxn = -2e9;
int n, m, res;
int val[N], vis[N];
int d[3][N]; /*3 个角到其它小立方体的距离*/
int f[K][K][K]; /*立方体*/
vector<int> e[N]; /*连接的小立方体*/
vector<int> col[M][6]; /*预处理放光的小立方体每个方向可以照到的所有小立方体的编号*/
array<int,3> a[M]; /*存储放光的小立方体的坐标*/
void dfs(int step)
{
    if (step == cnt + 1)
        return maxn = max(maxn, res), minn = min(minn, res), void();
    for (int i = 0; i < 6; i++) /*便递归边算答案*/
    {
        for (const int &j : col[step][i])
            if (!(vis[j]++))
                res += val[j];
        dfs(step + 1);
        for (const int &j : col[step][i])
            if (!(--vis[j]))
                res -= val[j];
    }
}
void shine(int p, int i, int x, vector<int> &v)
{
    for (auto g = a[p]; g[i] >= 1 && g[i] <= n; g[i] += x)
        v.emplace_back(f[g[0]][g[1]][g[2]]);
}
void bfs(int s, int p)
{
    queue<int> q; q.push(s), d[p][s] = 0;
    while (!q.empty())
    {
        int u = q.front(); q.pop();
        for (const int &v : e[u])
            if (d[p][v] > d[p][u] + 1)
                d[p][v] = d[p][u] + 1, q.push(v);
    }
}
signed main()
{
    memset(d, 0x3f, sizeof(d)); /*输入问题自行解决*/
    n = read(), sum = 8 * 3 + (n - 2) * 12 * 4 + (n - 2) * (n - 2) * 6 * 5 + (n - 2) * (n - 2) * (n - 2) * 6 + n * n * n;
    memset(val, -1, sizeof(val));
    for (int i = 1, x; x = read(), i; i = cnt)
    {
        if (val[i] == -1)
            val[i] = x;
        else
            e[i].emplace_back(x);
        if (sum == 0) break;
    }
    vector<int> v; /*找 3 个角并遍历*/
    for (int i = 1; i <= n * n * n; i++)
        if (e[i].size() == 3)
            v.emplace_back(i);
    bfs(d[0][0] = *v.begin(), 0);
    for (int i = 1, j = 1; j <= 2; i++)
        if (d[0][v[i]] == n - 1)
            d[j++][0] = v[i];
    bfs(d[1][0], 1);
    bfs(d[2][0], 2);
    cnt = 0;
    for (int i = 1, x, y, z; i <= n * n * n; i++) /*解方程*/
    {
        d[0][i] += 3, d[1][i] += 2 - n, d[2][i] += 2 - n;
        x = (d[0][i] - d[2][i]) >> 1;
        y = (d[1][i] + d[2][i]) >> 1;
        z = (d[0][i] - d[1][i]) >> 1;
        f[x][y][z] = i;
        if (!val[i]) a[++cnt] = {x, y, z};
    }
    for (int i = 1; i <= cnt; i++) /*预处理每个方向可以照到的所有小立方体*/
    {
        shine(i, 0, +1, col[i][0]);
        shine(i, 0, -1, col[i][1]);
        shine(i, 1, +1, col[i][2]);
        shine(i, 1, -1, col[i][3]);
        shine(i, 2, +1, col[i][4]);
        shine(i, 2, -1, col[i][5]);
    }
    dfs(1); /*暴力求解*/
    print(minn), putchar(' '), print(maxn);
    return 0;
}
```

## 后言-优化

- **三维数组内存访问很不连续**，最好用 vector 预处理出来每个放光的小立方体每个方向可以照到的所有小立方体的编号，这个优化最大。~~（截至 3.11 最优解）~~

- 对于**多次调用**的函数，里面的局部变量最好改为全局变量，尤其是开数组的。

- dfs 时边递归边算答案，最好不要递归结束后再计算答案。

- 尽量避免指针数组代替原数组进入递归函数进行操作。

---

## 作者：夏色祭 (赞：2)

难点在如何建图。

先随便找个棱角，再随便建两条棱，然后一层一层铺下去。当铺到一个新的点时，肯定已经铺好了至少一个与它相邻的点，然后再暴力算出已知与当前点相邻的点给出的每个相邻的点的出现次数，然后没被填过且出现次数最多的那个点的编号，就是当前点的编号。

建完图跑个dfs就行了。

```
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
#include<iostream>
using namespace std;
#define ll long long
#define For(i,x,y) for (register int i=(x);i<=(y);i++)
#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)
#define cross(i,k) for (register int i=first[k];i;i=last[i])
char c;
inline ll read(){
    ll x=0;int ch=getchar(),f=1;
    while (!isdigit(ch)&&(ch!='-')&&(ch!=EOF)) ch=getchar();
    if (ch=='-'){f=-1;ch=getchar();}
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    c=ch;return x*f;
}
const int N = 70*70*70+10;
const int dx[6]={1,-1,0,0,0,0};
const int dy[6]={0,0,1,-1,0,0};
const int dz[6]={0,0,0,0,1,-1};
struct node{
	int x,y,z;
}l[11];
int n,rt,tot,g[N],next[N][7],a[75][75][75],vis[N],cnt[N];
ll Max,Min;
inline bool check(int x,int y,int z){return x>0&&x<=n&&y>0&&y<=n&&z>0&&z<=n;}
inline void dfs(int now,int x,int y,int z,int k){
	a[x][y][z]=now,vis[now]=1;
	if (z==n&&k==4||y==n&&k==2) return;
	if (z==n-1&&k==4||y==n-1&&k==2){
		For(i,1,next[now][0]){
			int v=next[now][i];
			if (!vis[v]&&next[v][0]==3){dfs(v,x+dx[k],y+dy[k],z+dz[k],k);break;}
		}
		return;
	}
	For(i,1,next[now][0]){
		int v=next[now][i];
		if (!vis[v]&&next[v][0]==4){dfs(v,x+dx[k],y+dy[k],z+dz[k],k);break;}
	}
}
int x,y,z,Vis[75][75][75];
ll ans;
inline ll min(ll a,ll b){return a<b?a:b;}
inline ll max(ll a,ll b){return a>b?a:b;}
inline void dfs(int k){
	if (k>tot){Max=max(Max,ans),Min=min(Min,ans);return;}
	For(i,0,5){
		x=l[k].x,y=l[k].y,z=l[k].z;
		while (check(x+dx[i],y+dy[i],z+dz[i])){
			x+=dx[i],y+=dy[i],z+=dz[i];
			if (!Vis[x][y][z]) ans+=1ll*g[a[x][y][z]];Vis[x][y][z]++;
		}
		dfs(k+1);
		x=l[k].x,y=l[k].y,z=l[k].z;
		while (check(x+dx[i],y+dy[i],z+dz[i])){
			x+=dx[i],y+=dy[i],z+=dz[i],Vis[x][y][z]--;
			if (!Vis[x][y][z]) ans-=1ll*g[a[x][y][z]];
		}
	}
}
inline void Print(){
	For(i,1,n){
		For(j,1,n){
			For(k,1,n) printf("%d ",a[i][j][k]);puts("");
		}puts("");
	}
}
int main(){
	//freopen("P3342.in","r",stdin);
	//freopen("P3342.out","w",stdout);
	n=read();
	For(i,1,n*n*n){
		g[i]=read();
		while (c==' ') next[i][++next[i][0]]=read();
	}
	For(i,1,n*n*n) if (next[i][0]==3){rt=i;break;}
	dfs(rt,1,1,1,4),dfs(rt,1,1,1,2);
	For(i,1,n) For(j,1,n) For(k,1,n){
		if (a[i][j][k]) continue;
		int Max=0,Max_id=0;
		for (int d=0;d<6;d+=2){
			int v=a[i-dx[d]][j-dy[d]][k-dz[d]];
			For(nxt,1,next[v][0]){
				cnt[next[v][nxt]]++;
				if (cnt[next[v][nxt]]>Max&&!vis[next[v][nxt]]) Max=cnt[next[v][nxt]],Max_id=next[v][nxt];
			}
		}
		a[i][j][k]=Max_id,vis[Max_id]=1;
		for (int d=0;d<6;d+=2){
			int v=a[i-dx[d]][j-dy[d]][k-dz[d]];
			For(nxt,1,next[v][0]) cnt[next[v][nxt]]--;
		}
	}
	For(i,1,n) For(j,1,n) For(k,1,n) if (!g[a[i][j][k]]) l[++tot]=(node){i,j,k};
	Max=(ll)-1e18,Min=-Max;
	dfs(1);
	printf("%lld %lld",Min,Max);
}
```

---

## 作者：我梦见一片焦土 (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/P3342)

# 思路：
不用建水晶立方体，因为发光水晶的方向都要枚举一遍，只需知道发光水晶每个方向有哪些水晶就可以了。

对于一个发光水晶，将它连接的水晶标号，从该水晶 bfs，若某水晶在相同步数下被访问过两次，那么它必然不是某一方向的直线上的。每个点的标号为最先访问到它的点的标号。这样可以整出发光水晶每个方向的水晶。时间复杂度 $O(n\times a^3)$。

之后把每个发光水晶朝向枚举一遍，复杂度 $O(6^n\times a)$。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
const int INF=0x3f3f3f3f;
int n,r,mk[N],val[N],que[N],mark[N],tot_val,Max,Min=INF;
vector<int>son[N],rt,ft[8][6];
bool is_used[N];
char c;
void dfs(int x){
	if(x==(int)rt.size()){
		Max=max(Max,tot_val);
		Min=min(Min,tot_val);
		return;
	}
	vector<int> sta;
	for(int q=0;q<=5;q++){
		sta.clear();
		for(int w=0;w<=(int)ft[x][q].size()-1;w++){
			int y=ft[x][q][w];
			if(!is_used[y]){
				sta.push_back(y);
				is_used[y]=1;
				tot_val+=val[y];
			}
		}
		dfs(x+1);
		for(int w=0;w<=(int)sta.size()-1;w++){
            is_used[sta[w]]=0;
            tot_val-=val[sta[w]];
        }
		if(ft[x][q].size()==0){
            return;
        }
	}
}
signed main(){
	cin>>n;
	for(int q=1;q<=n*n*n;q++){
		cin>>val[q];
		if(!val[q]){
            rt.push_back(q);
        }
		while(1){
			r=0;
			while(c=getchar(),c<48);
			do{
                r=(r<<1)+(r<<3)+(c^48);
            }while(c=getchar(),c>47);
			son[q].push_back(r);
			if(c=='\n'||c=='\r'){
                break;
            }
		}
	}
	for(int q=0;q<=(int)rt.size()-1;q++){
		int l=0,r=0,now=rt[q];
		mk[now]=-1;
		for(int w=0;w<=(int)son[now].size()-1;w++){
            mk[son[now][w]]=w+1;
            mark[son[now][w]]=1;
            que[++r]=son[now][w];
        }
		while(l<r){
			int nw=que[++l];
			for(int w=0;w<=(int)son[nw].size()-1;w++){
				int to=son[nw][w];
				if(mk[to]==0){
                    mk[to]=mk[nw];
                    mark[to]=mark[nw]+1;
                    que[++r]=to;
                }else if(mark[to]==mark[nw]+1){
                    is_used[to]=1;
                }
			}
		}
		for(int w=1;w<=r;w++){
			if(!is_used[que[w]]){
                ft[q][mk[que[w]]-1].push_back(que[w]);
            }
			is_used[que[w]]=0;
			mk[que[w]]=0;
            mark[que[w]]=0;
		}
		mk[now]=0;
        mark[now]=0;
	}
	dfs(0);
	cout<<Min<<" "<<Max<<endl;
	return 0;
}
```
完结撒花~

---

## 作者：Furina_Saikou (赞：1)

我有一个和所以题解都不同的建立方体思路，但是绝对简单易懂

# 拆分问题

我们将问题拆成三部分：

- 如何输入？
- 如何建立立方体
- 如何求答案

# 输入问题

我们不知道每个块有多少相邻的块，但是我们可以直接读入一行，通过 `stringstream` 函数从字符串中读入数据。

# 建立方体

首先，我们找一个角块（只有三个相邻块），把它设为 $a_{1,1,1}$，将他三个相邻的块直接放入立方体与它相邻的位置（因为这三个块的顺序不会影响接下来的操作，顺序不同相当于这个立方体被旋转或者镜像，答案还是不变）并将这三个块入队。

接下来开始跑 bfs，我们每次枚举队头的块的相邻块，根据广搜逐层扩散的原理，设当前块为 $a_{x,y,z}$，他的未被放置的相邻块只会出现 $a_{x+1,y,z},a_{x,y+1,z},a_{x,y,z+1}$ 三个位置，我们枚举这些未被放置的相邻块能被放在哪个位置，如何判断呢？我们看这个位置周围已经摆放好的块，如果周围的块都有当前块作为相邻的边且块数 $>2$，那这个位置就能放，这也是为什么要把 $a_{1,1,1}$ 的相邻块单独处理的原因。

但是我们可以发现，有些位置周围只有一个块，无法判断怎么办？没关系，想想，三个位置中肯定有两个位置能确定，剩下这个位置也就能确定了。

# 计算答案

因为射线的方向只有 $6$ 个，发射器也最多只有 $8$ 个，我们完全可以爆搜枚举每个发射器的方向，在发射时我们把被找到的打上标记防止计算重复，在用打标记同样的方法删掉标记就好了。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=4e5+1,M=80,INF=0x7fffffffff;
int n,m,val[N],giver[M],f[N][7],vis[N],cnt[N],a[M][M][M],b[M][M][M],d[M],dx[]={-1,0,0},dy[]={0,-1,0},dz[]={0,0,-1},maxn=-INF,minn=INF;//giver是发射器的编号，val是美丽度，f[i][j]存i相邻的块，cnt[i]存i的相邻块数，a是立方体，b是标记
struct node{
	int x,y,z;
}block[N];
void print()
{
	cout<<"\n";
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			for(int k=1;k<=n;k++)
			{
				cout<<a[i][j][k]<<" ";
			}
			cout<<"\n";
		}
		cout<<"\n";
	}
}
bool check(int u,int x,int y,int z)
{
	if(x>n||y>n||z>n||a[x][y][z])return 0;
	int tot=0;
	for(int i=0;i<3;i++)
	{
		int xx=x+dx[i],yy=y+dy[i],zz=z+dz[i],v;
		v=a[xx][yy][zz];
		bool flag=0;
		if(!v)continue;
		for(int j=1;j<=cnt[v];j++)
		{
			if(f[v][j]==u)
			{
				flag=1;
				tot++;
				break;
			}
		}
		if(!flag)return 0;
	}
	return tot>1;
}
void build()
{
	queue<int>q;
	block[a[1][1][1]].x=block[a[1][1][1]].y=block[a[1][1][1]].z=vis[a[1][1][1]]=1;
	for(int i=1;i<=3;i++)
	{
		int xx=1-dx[i-1],yy=1-dy[i-1],zz=1-dz[i-1],v=f[a[1][1][1]][i];
		a[xx][yy][zz]=v;
		block[v].x=xx,block[v].y=yy,block[v].z=zz;
		q.push(v);
		vis[v]=1;
	}
	while(!q.empty())
	{
		int u=q.front(),x,y,z;
		x=block[u].x;
		y=block[u].y;
		z=block[u].z;
		// cout<<u<<" "<<x<<" "<<y<<" "<<z<<"\n";
		q.pop();
		for(int i=1;i<=cnt[u];i++)
		{
			int v=f[u][i];
			if(vis[v])
			{
				continue;
			}
			if(check(v,x+1,y,z))//判断位置能不能放
			{
				a[x+1][y][z]=v;
				block[v].x=x+1,block[v].y=y,block[v].z=z;
				vis[v]=1;
			}else if(check(v,x,y+1,z))
			{
				a[x][y+1][z]=v;
				block[v].x=x,block[v].y=y+1,block[v].z=z;
				vis[v]=1;
			}else if(check(v,x,y,z+1))
			{
				a[x][y][z+1]=v;
				block[v].x=x,block[v].y=y,block[v].z=z+1;
				vis[v]=1;
			}
			// cout<<u<<" "<<v<<" "<<block[v].x<<" "<<block[v].y<<" "<<block[v].z<<"\n";
			q.push(v);
		}
		for(int i=1;i<=cnt[u];i++)
		{
			int v=f[u][i];
			if(!vis[v])//找出剩下那个无法判断的位置
			{
				if(!a[x+1][y][z])
				{
					a[x+1][y][z]=v;
					block[v].x=x+1,block[v].y=y,block[v].z=z;
				}else if(!a[x][y+1][z])
				{
					a[x][y+1][z]=v;
					block[v].x=x,block[v].y=y+1,block[v].z=z;
				}else
				{
					a[x][y][z+1]=v;
					block[v].x=x,block[v].y=y,block[v].z=z+1;
				}
				vis[v]=1;
				break;
			}
		}
	}
}
void calc()
{
	int sum=0;
	for(int i=1;i<=m;i++)
	{
		int x=block[giver[i]].x,y=block[giver[i]].y,z=block[giver[i]].z;
		if(d[i]==1)
		{
			while(y<n)
			{
				sum+=(b[x][++y][z]^1)*val[a[x][y][z]];
				b[x][y][z]=1;
			}
		}else if(d[i]==2)
		{
			while(y>1)
			{
				sum+=(b[x][--y][z]^1)*val[a[x][y][z]];
				b[x][y][z]=1;
			}
		}else if(d[i]==3)
		{
			while(x<n)
			{
				sum+=(b[++x][y][z]^1)*val[a[x][y][z]];
				b[x][y][z]=1;
			}
		}else if(d[i]==4)
		{
			while(x>1)
			{
				sum+=(b[--x][y][z]^1)*val[a[x][y][z]];
				b[x][y][z]=1;
			}
		}else if(d[i]==5)
		{
			while(z<n)
			{
				sum+=(b[x][y][++z]^1)*val[a[x][y][z]];
				b[x][y][z]=1;
			}
		}else 
		{
			while(z>1)
			{
				sum+=(b[x][y][--z]^1)*val[a[x][y][z]];
				b[x][y][z]=1;
			}
		}
	}
	maxn=max(maxn,sum),minn=min(minn,sum);
	for(int i=1;i<=m;i++)
	{
		int x=block[giver[i]].x,y=block[giver[i]].y,z=block[giver[i]].z;
		if(d[i]==1)
		{
			while(y<n)
			{
				b[x][++y][z]=0;
			}
		}else if(d[i]==2)
		{
			while(y>1)
			{
				b[x][--y][z]=0;
			}
		}else if(d[i]==3)
		{
			while(x<n)
			{
				b[++x][y][z]=0;
			}
		}else if(d[i]==4)
		{
			while(x>1)
			{
				b[--x][y][z]=0;
			}
		}else if(d[i]==5)
		{
			while(z<n)
			{
				b[x][y][++z]=0;
			}
		}else 
		{
			while(z>1)
			{
				b[x][y][--z]=0;
			}
		}
	}
	return;
}
void dfs(int k)
{
	if(k>m)
	{
		calc();
		return;
	}
	for(int i=1;i<=6;i++)
	{
		d[k]=i;
		dfs(k+1);
	}
}
signed main()
{
	cin>>n;
	string s;
	getchar();
	for(int i=1,x;i<=n*n*n;i++)
	{
		getline(cin,s);
		stringstream sin(s);
		sin>>val[i];
		char c;
		while(sin>>x)
		{
			f[i][++cnt[i]]=x;
		}
		if(cnt[i]==3)
		{
			a[1][1][1]=i;
		}
		if(!val[i])giver[++m]=i;
	}
	build();
	// print();
	dfs(1);
	if(minn==INF)cout<<"0 0";
	else cout<<minn<<" "<<maxn;
	return 0;
}

```

---

## 作者：feecle6418 (赞：1)

其他题解建出正方体都使用了比较麻烦的方法，这里提供一种牺牲一点常数换取不用动脑子的做法。

首先任找一个度数为 $3$ 的点执行 BFS，把它的坐标钦定为 $(1,1,1)$。

再找一个到 $(1,1,1)$ 的距离恰为 $2n-2$ 的度数为 $3$ 的点，把它的坐标钦定为 $(n,n,1)$。

再从 $(n,n,1)$ BFS，找到一个点，他离 $(1,1,1),(n,n,1)$ 距离都恰好为 $n-1$。把这个点钦定为 $(1,n,1)$。

再从 $(1,n,1)$ BFS 一遍。以上三次 BFS 算出来到某个点 $X$ 的距离，分别称为 $dis(0/1/2,X)$。考虑数对 $(dis(1,X)-dis(0,X),dis(2,X)-dis(0,X))$。

- 结论 $1$：这个数对与 $X$ 的 $z$ 维坐标无关。
- 结论 $2$：这个数对与 $X$ 的 $x,y$ 坐标有一一对应关系。

因此，找出这个一一对应关系就能算出 $X$ 的坐标是 $(x,y,?)$，再结合 $dis(0,X)=x+y+?-3$ 就能算出 $?$ 的值。

这个对应关系可以 $n^2$ 预处理，也不需要手算。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Triple{
	int x,y,z;
}t[285][285];
int n,m,a[500005],v[75][75][75],p1,p2,p3,dis[3][500005],mi=1e9,mx=0,u[75][75][75],f[8];
vector<Triple> A;
vector<int> g[500005];
int D(int x,int y,int z,int w){
	return abs(x-z)+abs(y-w);
}
void BFS(int s,int dis[]){
	queue<int> q;
	dis[s]=0,q.push(s);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int y:g[x])if(dis[y]>dis[x]+1)dis[y]=dis[x]+1,q.push(y);
	}
}
void Calc(){
	int o=0,sum=0;
	for(Triple i:A){
		int x=i.x,y=i.y,z=i.z;
		if(f[o]==0)for(int i=1;i<x;i++)if(!u[i][y][z])u[i][y][z]=1,sum+=v[i][y][z];
		if(f[o]==1)for(int i=x+1;i<=n;i++)if(!u[i][y][z])u[i][y][z]=1,sum+=v[i][y][z];
		if(f[o]==2)for(int i=1;i<y;i++)if(!u[x][i][z])u[x][i][z]=1,sum+=v[x][i][z];
		if(f[o]==3)for(int i=y+1;i<=n;i++)if(!u[x][i][z])u[x][i][z]=1,sum+=v[x][i][z];
		if(f[o]==4)for(int i=1;i<z;i++)if(!u[x][y][i])u[x][y][i]=1,sum+=v[x][y][i];
		if(f[o]==5)for(int i=z+1;i<=n;i++)if(!u[x][y][i])u[x][y][i]=1,sum+=v[x][y][i];
		o++;
	}
	mi=min(mi,sum),mx=max(mx,sum),o=0;
	for(Triple i:A){
		int x=i.x,y=i.y,z=i.z;
		if(f[o]==0)for(int i=1;i<x;i++)u[i][y][z]=0;
		if(f[o]==1)for(int i=x+1;i<=n;i++)u[i][y][z]=0;
		if(f[o]==2)for(int i=1;i<y;i++)u[x][i][z]=0;
		if(f[o]==3)for(int i=y+1;i<=n;i++)u[x][i][z]=0;
		if(f[o]==4)for(int i=1;i<z;i++)u[x][y][i]=0;
		if(f[o]==5)for(int i=z+1;i<=n;i++)u[x][y][i]=0;
		o++;
	}
}
void dfs(int x){
	if(x==A.size())return Calc();
	for(int i=0;i<6;i++)f[x]=i,dfs(x+1);
}
int main(){
	scanf("%d",&n),m=n*n*n,memset(dis,0x3f,sizeof(dis));
	for(int i=1,x;i<=m;i++){
		scanf("%d",&a[i]);
		stringstream ss;
		string s;
		getline(cin,s),ss<<s;
		while(ss>>x)g[i].push_back(x);
	}
	for(int i=1;i<=m;i++)if(g[i].size()==3)p1=i;
	v[1][1][1]=a[p1],BFS(p1,dis[0]);
	for(int i=1;i<=m;i++)if(g[i].size()==3&&dis[0][i]==2*(n-1))p2=i;
	v[n][n][1]=a[p2],BFS(p2,dis[1]);
	for(int i=1;i<=m;i++)if(g[i].size()==3&&dis[0][i]==(n-1)&&dis[1][i]==(n-1))p3=i;
	v[n][1][1]=a[p3],BFS(p3,dis[2]);
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)t[142+D(i,j,n,n)-D(i,j,1,1)][142+D(i,j,n,1)-D(i,j,1,1)]={i,j,1};
	for(int i=1;i<=m;i++){
		Triple w=t[142+dis[1][i]-dis[0][i]][142+dis[2][i]-dis[0][i]];
		w.z=dis[0][i]-D(w.x,w.y,1,1)+1,v[w.x][w.y][w.z]=a[i];
		if(!a[i])A.push_back(w);
	}
	dfs(0),cout<<mi<<' '<<mx;
}
```

---

## 作者：kingho11 (赞：0)

# P3342 [ZJOI2014] 璀灿光华 题解

## 题意：

给你 $a^3$ 个小立方体，并且告诉你每个小立方体的邻接的立方体的编号，和它自己的美丽值，需要你把他拼回原来的那样子，拼完后，其中有 $n$ 个立方体（即该小立方体的美丽值为 $0$）会向上下左右前后六个方向中随机选择一个方向发射穿透光（其实往哪个方向发射是可以由你来决定的），被光照到的小立方体就会散发出自己的美丽值，需要你最小化和最大化这个美丽值。

## 思路：

bfs+dfs。

这道题最大的难点就在于怎么复原原来的大立方体。

具体怎么做呢，各位可以先思考一下。

接下来，我给出做法：

bfs 用于复原立方体，dfs 用于统计分数。

第一步、我们需要确定整个大立方体的角块（只需要确定一个就可以了），并把它放到队列里准备广搜（因为只有角块是可以确定的），为什么呢？因为我们可以依着角块的邻接块慢慢的把立方体复原。

第二步、我们把队列里的块的邻接块也放入队列，同时进行构建立方体，有几个要点如下：

第一、如果该块是角块，不用管邻接块的具体位置，因为改变两个邻接块的位置，只是将整个立方体翻转了一下，不会造成什么影响，我们可以拿出立方体的一个面来解释。

![](https://cdn.luogu.com.cn/upload/image_hosting/sz8y300m.png)

可以看到，只是沿着红线把整个立方体翻转了，但这只是一个面，其实运用一下空间想象力，一个立方体也是一样的，所以如果这一块是角块，不管它的邻接块怎么放置也并不会造成什么影响，但是这只适用于这块角块是我们一开始放到队列里的角块，其他被遍历到的角块并不适用。

其次，对于其他的块，我们需要检测这块可不可以放在我们目前尝试放置的位置，假设我们现在放置到的块的编号为 $o$，目前尝试放置的位置是 $(x,y,z)$。需要满足 $o$ 的邻接块中在 $(x,y,z)$ 的邻接块中也有，具体可以看代码。

接下来，我们只需要反复执行第二步，直到整个立方体都被填充完毕。

之后就是比较简单的 dfs 了，暴力 dfs 每一个可能发光的小立方体，枚举是往哪个方向发射的穿透光，之后统计答案，记录最小值最大值即可。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long N=75;
long long a[N][N][N],n,xx[6]={1,-1,0,0,0,0},yy[6]={0,0,-1,1,0,0},zz[6]={0,0,0,0,-1,1},lt,maxn=-1,minn=1e18;
bool b1[N*N*N];
long long b2[N][N][N];
struct position{
	long long x,y,z;
};
map <long long,position> mp;
struct uuu{
	long long g,a[7],o;
}dot[N*N*N];
struct uu{
	long long x,y,z;
};
long long light[N*N*N],tpl; 
void input(long long pos)//阴间输入
{
	dot[pos].o=-1;
	string s;
	getline(cin,s);
	stringstream ss(s);
	string str;
	while(ss>>str)
	{
		long long num=0;
		for(long long i=0;i<str.length();i++)
		{
			num*=10;
			num+=str[i]-'0';
		}
		if(dot[pos].o==-1)
		{
			dot[pos].o=0;
			dot[pos].g=num;
		}else
		{
			dot[pos].o++;
			dot[pos].a[dot[pos].o]=num;
		}
	}
}
bool check1(long long x,long long y,long long z)//判断这个块合不合法（在不在范围内）
{
	if(x>=1 && x<=n && y>=1 && y<=n && z>=1 && z<=n)
	{
		return true;
	}else
	{
		return false;
	}
}
long long check2(long long pos,long long x,long long y,long long z,long long last)//求把第pos个点放在{x,y,z}这个地方合不合法 
{
	long long cnt=0;
	for(long long i=0;i<6;i++)//枚举该点的邻接点 
	{
		long long nx=x+xx[i],ny=y+yy[i],nz=z+zz[i];
		if(!check1(nx,ny,nz))
		{
			continue;
		}
		bool fl=false,fl2=false;
		for(long long j=1;j<=dot[pos].o;j++)
		{
			if(a[nx][ny][nz]==dot[pos].a[j])//找到了
			{
				fl=true;
				cnt++;
				break;
			}else if(a[nx][ny][nz]!=0 && a[nz][ny][nz]!=last)
			{
				fl2=true;
			}
		}
		if(!fl && fl2)
		{
			return -1;
		}
	}
	return cnt;
}
void build()//复原大立方体
{
	long long p=0;
	for(long long i=1;i<=n*n*n;i++)
	{
		if(dot[i].o==3)//确定角块 
		{
			p=i;
			break;
		}
	}
	a[1][1][1]=p;
	queue <uu> q;
	q.push((uu){1,1,1});//把第一个角块放到队列里
	b1[p]=true;//标记这个块已经被使用过
	while(!q.empty())//bfs复原大立方体
	{
		long long size=q.size();
		for(long long i=0;i<size;i++)
		{
			long long x=q.front().x,y=q.front().y,z=q.front().z;
			q.pop();
			mp[a[x][y][z]]=(position){x,y,z};
			for(long long j=0;j<6;j++)//枚举现在可以放置方块的位置
			{
				long long nx=x+xx[j],ny=y+yy[j],nz=z+zz[j];
				if(!check1(nx,ny,nz) || a[nx][ny][nz])
				{
					continue;
				}
				for(long long k=1;k<=dot[a[x][y][z]].o;k++)//枚举如果把第dot[a[x][y][z].a[k]个块放在{nx,ny,nz}合不合法，如果可以放在这里的先不放，留着备用 
				{
					if(b1[dot[a[x][y][z]].a[k]])//如果这个块被使用过，直接结束
					{
						continue;
					}
					long long ck=check2(dot[a[x][y][z]].a[k],nx,ny,nz,a[x][y][z]);
					if(ck>=2)//只有旁边邻接的块超过两个才可以说明这个块一定是放在这里的，不是>=1的原因是因为我这个块肯定是由一个块转移过来的，那么这个块和我现在的这个块一定是相邻的，要排除掉这个块才行。
					{
						a[nx][ny][nz]=dot[a[x][y][z]].a[k];
						q.push((uu){nx,ny,nz});
						b1[dot[a[x][y][z]].a[k]]=true;
						break;
					}
				}
			}
			for(long long j=1;j<=dot[a[x][y][z]].o;j++)//放置不知道放在那里的块
			{
				long long v2=dot[a[x][y][z]].a[j],nx,ny,nz;
				if(b1[v2])
				{
					continue;
				}
				for(long long k=0;k<6;k++)//枚举这些块可以放置的位置，其中一定是有位置是满足的
				{
					nx=x+xx[k],ny=y+yy[k],nz=z+zz[k];//判断能不能放
					if(!check1(nx,ny,nz) || a[nx][ny][nz])
					{
						continue;
					}
					a[nx][ny][nz]=v2;
					break;
				}
				q.push((uu){nx,ny,nz});//压入队列
				b1[v2]=true;//标记使用过
			}
		}
	}
}
void dfs(long long pos,long long sum)//dfs找最大最小值
{
	if(pos>lt)
	{
		if(sum<minn)
		{
			minn=sum;
		}
		if(sum>maxn)
		{
			maxn=sum;
		}
		return ;
	}
	long long tp;
	position zb=mp[light[pos]];
	for(long long i=0;i<6;i++)//枚举往哪个方向发射穿透光
	{
		long long nx=zb.x,ny=zb.y,nz=zb.z,o=0;
		tp=0;
		while(check1(nx,ny,nz))//统计答案
		{
			b2[nx][ny][nz]++;
			if(b2[nx][ny][nz]==1)
			{
				o+=dot[a[nx][ny][nz]].g;
			}
			nx+=xx[i],ny+=yy[i],nz+=zz[i];
		}
		dfs(pos+1,sum+o);
		nx=zb.x,ny=zb.y,nz=zb.z;
		while(check1(nx,ny,nz))//回溯
		{
			b2[nx][ny][nz]--;
			nx+=xx[i],ny+=yy[i],nz+=zz[i];
		}
	}
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	string pp;
	getline(cin,pp);
	for(long long i=1;i<=n*n*n;i++)
	{
		input(i);
	}
	build();
	for(long long i=1;i<=n*n*n;i++)
	{
		if(!dot[i].g)
		{
			lt++;
			light[++tpl]=i;
		}
	}
	dfs(1,0);
	cout<<minn<<" "<<maxn;
	return 0;
}
```

---

## 作者：sgl654321 (赞：0)

很好的一道题，可以锻炼空间想象能力，转换能力，和代码编写与调试能力。

## 题目大意
- 给定一个棱长为 $a$ 的立方体，它由 $a^3$ 个 $1\times 1\times 1$ 的小立方体拼成。给出每一个小立方体相邻的立方体的编号。
- 每个小立方体要么能发光，要么有一个美丽值 $g_i$。能发光的立方体会向上下左右前后六个方向随机发光。
- 定义总美丽值为所有被照到光的小立方体的美丽值之和。请问最大和最小的总美丽值是多少。

## 解题思路
本题可以分三步进行：
1. 读入。
2. 还原立方体（即求出每一个小立方体的 $x,y,z$ 坐标）。
3. 枚举每个发光小立方体的发光方向，求出总美丽值。

### 读入
本题的读入与其他题目有一点不同。由于读入时没有告诉你相邻的小立方体有几个，所以你要持续读入，直至换行。可以用下面的 ```read``` 函数来完成：
```cpp
int read(){
	int x=0,sgn=1;char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')sgn=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	c=ch;
	return sgn*x;
}
```
读完后，$c$ 如果是一个空格，那就继续读入。如果是换行符就停止。

### 还原立方体
这也是本道题最重要的模拟部分。

首先，每个立方体一定有 $8$ 个角块，即只有三个相邻的小立方体的小立方体。我们可以找到一个角块，然后进行 bfs，求出每个小立方体到这个角块的距离 $dis_1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/2yjm6dns.png)
左下角的角块是我们一开始找到的。记为 $jiao_1$。

下一步：我们要找到另外两个打红叉的角块。记为 $jiao_2,jiao_3$。

显然，它们到 $jiao_1$ 的距离都是 $2(a-1)$。于是我们就找到了它们。找到了之后，我们再以它们为起点，求出每个小立方体到它们的距离，分别记录为 $dis_2,dis_3$。

下一步：我们要还原出所有小立方体的 $x,y,z$ 坐标。

![](https://cdn.luogu.com.cn/upload/image_hosting/ygaxu5wm.png)


比如我们要用 $jiao_1,jiao_2$ 还原绿色立方体的 $u$ 的 $x,y,z$ 坐标。

我们发现，$jiao_1$ 到 $u$ 的距离，加上 $jiao_2$ 到 $u$ 的距离，就是它们在底面跑的距离之和，加上两倍的 $z-1$。

即 $dis_1+dis_2=2(a-1)+2(z-1)$，解得 $z=\dfrac{dis_1+dis_2-2(a-1)}{2}+1$。

同理，我们通过 $jiao_2$ 和 $jiao_3$，$jiao_3$ 和 $jiao_1$ 可以求出 $x,y$ 坐标。

这里，就有同学要问了：哪个是 $x$，哪个是 $y$ 呢？

其实，这是不重要的。因为立方体是可以旋转的。我们之后会枚举 $6$ 个方向，全都枚举过去了。所以并没有必要分清楚 $x,y,z$ 坐标。

### 枚举方向求出总美丽值

这个就比较简单了。因为题目中已经给定 $n\le 8$，我们显然可以对于每一个可发光的立方体，枚举 $6$ 个方向。然后统计出总美丽值。

注意，我们记录下操作序列后，千万不要 $n^3$ 的计算总美丽值，这样会导致 TLE。

## 参考代码
注意，这一题答案要开 ```long long```，但是也不能全开。否则会导致 MLE。

建议自己先实现一遍。代码在[这里](https://www.luogu.com.cn/paste/beghoa5k)。写的比较丑。


---


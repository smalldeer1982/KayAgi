# [六省联考 2017] 寿司餐厅

## 题目描述

Kiana 最近喜欢到一家非常美味的寿司餐厅用餐。

每天晚上，这家餐厅都会按顺序提供 $n$ 种寿司，第 $i$ 种寿司有一个代号 $a_i$ 和美味度 $d_{i, i}$，不同种类的寿司有可能使用相同的代号。每种寿司的份数都是无限的，Kiana 也可以无限次取寿司来吃，但每种寿司每次只能取一份，且每次取走的寿司必须是按餐厅提供寿司的顺序连续的一段，即 Kiana 可以一次取走第 $1, 2$ 种寿司各一份，也可以一次取走第 $2, 3$ 种寿司各一份，但不可以一次取走第 $1, 3$ 种寿司。

由于餐厅提供的寿司种类繁多，而不同种类的寿司之间相互会有影响：三文鱼寿司和鱿鱼寿司一起吃或许会很棒，但和水果寿司一起吃就可能会肚子痛。因此，Kiana 定义了一个综合美味度 $d_{i, j} \ (i < j)$，表示在一次取的寿司中，如果包含了餐厅提供的从第 $i$ 份到第 $j$ 份的所有寿司，吃掉这次取的所有寿司后将获得的额外美味度。由于取寿司需要花费一些时间，所以我们认为分两次取来的寿司之间相互不会影响。注意在吃一次取的寿司时，不止一个综合美味度会被累加，比如若 Kiana 一次取走了第 $1, 2, 3$ 种寿司各一份，除了 $d_{1, 3}$ 以外，$d_{1, 2}, d_{2, 3}$ 也会被累加进总美味度中。

神奇的是，Kiana 的美食评判标准是有记忆性的，无论是单种寿司的美味度，还是多种寿司组合起来的综合美味度，在计入 Kiana 的总美味度时都只会被累加一次。比如，若 Kiana 某一次取走了第 $1, 2$ 种寿司各一份，另一次取走了第 $2, 3$ 种寿司各一份，那么这两次取寿司的总美味度为 $d_{1, 1} + d_{2, 2} + d_{3, 3} + d_{1, 2} + d_{2, 3}$，其中 $d_{2, 2}$ 只会计算一次。

奇怪的是，这家寿司餐厅的收费标准很不同寻常。具体来说，如果 Kiana 一共吃过了 $c \ (c > 0)$ **种**代号为 $x$ 的寿司，则她需要为这些寿司付出 $mx^2 + cx$ 元钱，其中 $m$ 是餐厅给出的一个常数。

现在 Kiana 想知道，在这家餐厅吃寿司，自己能获得的总美味度（包括所有吃掉的单种寿司的美味度和所有被累加的综合美味度）减去花费的总钱数的最大值是多少。由于她不会算，所以希望由你告诉她。

## 说明/提示

### 样例解释 1

在这组样例中，餐厅一共提供了 $3$ 份寿司，它们的代号依次为 $a_1 = 2, a_2 = 3, a_3 = 2$，计算价格时的常数 $m = 1$。

在保证每次取寿司都能获得新的美味度的前提下，Kiana 一共有 $14$ 种不同的吃寿司方案。以下列出其中几种：
1. Kiana 一个寿司也不吃，这样她获得的总美味度和花费的总钱数都是 $0$，两者相减也是 $0$；
2. Kiana 只取 $1$ 次寿司，且只取第 $1$ 个寿司，即她取寿司的情况为 $\{[1, 1]\}$，这样获得的总美味度为 $5$，花费的总钱数为 $1 \times 2^2 + 1 \times 2 = 6$，两者相减为 $-1$；
3. Kiana 取 $2$ 次寿司，第一次取第 $1, 2$ 个寿司，第二次取第 $2, 3$ 个寿司，即她取寿司的情况为 $\{[1, 2], [2, 3]\}$，这样获得的总美味度为 $5 + (-10) + 15 + (-10) + 15 = 15$，花费的总钱数为 $(1 \times 2^2 + 2 \times 2) + (1 \times 3^2 + 1 \times 3) = 20$，两者相减为 $-5$；
4. Kiana 取 $2$ 次寿司，第一次取第 $1$ 个寿司，第二次取第 $3$ 个寿司，即她取寿司的情况为 $\{[1, 1], [3, 3]\}$，这样获得的总美味度为 $5 + 15 = 20$，花费的总钱数为 $1 \times 2^2 + 2 \times 2 = 8$，两者相减为 $12$。

在 $14$ 种方案中，惟一的最优方案是列出的最后一种方案，这时她获得的总美味度减去花费的总钱数的值最大为 $12$。

### 数据范围

对于所有数据，保证 $-500 \leq d_{i, j} \leq 500$。

数据的一些特殊约定如下表：

| Case # | $n$ | $a_i$ | $m$ | 附加限制 |
|:-:|:-:|:-:|:-:|:-:|
| 1 | $\leq 2$ | $\leq 30$ | $= 0$ | - |
| 2 | $\leq 2$ | $\leq 30$ | $= 1$ | - |
| 3 | $\leq 3$ | $\leq 30$ | $= 0$ | - |
| 4 | $\leq 3$ | $\leq 30$ | $= 1$ | - |
| 5 | $\leq 5$ | $\leq 30$ | $= 0$ | - |
| 6 | $\leq 5$ | $\leq 30$ | $= 1$ | - |
| 7 | $\leq 10$ | $\leq 30$ | $= 0$ | 所有的 $a_i$ 相同 |
| 8 | $\leq 10$ | $\leq 30$ | $= 1$ | - |
| 9 | $\leq 15$ | $\leq 30$ | $= 0$ | 所有的 $a_i$ 相同 |
| 10 | $\leq 15$ | $\leq 30$ | $= 1$ | - |
| 11 | $\leq 30$ | $\leq 1000$ | $= 0$ | 所有的 $a_i$ 相同 |
| 12 | $\leq 30$ | $\leq 30$ | $= 0$ | 所有的 $a_i$ 相同 |
| 13 | $\leq 30$ | $\leq 1000$ | $= 0$ | - |
| 14 | $\leq 30$ | $\leq 1000$ | $= 1$ | - |
| 15 | $\leq 50$ | $\leq 1000$ | $= 0$ | 所有的 $a_i$ 相同 |
| 16 | $\leq 50$ | $\leq 30$ | $= 0$ | 所有的 $a_i$ 相同 |
| 17 | $\leq 50$ | $\leq 1000$ | $= 0$ | - |
| 18 | $\leq 50$ | $\leq 1000$ | $= 1$ | - |
| 19 | $\leq 100$ | $\leq 1000$ | $= 0$ | - |
| 20 | $\leq 100$ | $\leq 1000$ | $= 1$ | - |

## 样例 #1

### 输入

```
3 1
2 3 2
5 -10 15
-10 15
15```

### 输出

```
12```

## 样例 #2

### 输入

```
5 0
1 4 1 3 4
50 99 8 -39 30
68 27 -75 -32
70 24 72
-10 81
-95```

### 输出

```
381```

## 样例 #3

### 输入

```
10 1
5 5 4 4 1 2 5 1 5 3
83 91 72 29 22 -5 57 -14 -36 -3
-11 34 45 96 32 73 -1 0 29
-48 68 44 -5 96 66 17 74
88 47 69 -9 2 25 -49
86 -9 -77 62 -10 -30
2 40 95 -74 46
49 -52 2 -51
-55 50 -44
72 22
-68```

### 输出

```
1223```

# 题解

## 作者：小粉兔 (赞：56)

在博客园食用更佳：[https://www.cnblogs.com/PinkRabbit/p/10422815.html](https://www.cnblogs.com/PinkRabbit/p/10422815.html)。

### 题意简述：

有 $n$ 种寿司，第 $i$ 种寿司的类型为 $a_i$。

如果你吃了第 $i$ 种到第 $j$ 种寿司，你会得到 $d_{i,j}$（$i\le j$）的收益。

如果你吃了 $c$（$c>0$）种类型为 $x$ 的寿司，你会付出 $mx^2+cx$ 的代价（$m\in\{0,1\}$）。

最大化收益与代价的差。

### 题解：

#### 一种经典的模型：最大权闭合子图。

模型：有若干个物品，每种物品有一个可正可负的价值 $v_i$，选取了物品就意味着获得了价值。

物品之间有限制关系：$x\to y$ 表示若要选择物品 $x$ 则必须选择物品 $y$。

目标是最大化价值和。

显然，有时需要为了一个拥有较大价值的物品而被迫选择负价值的物品。

#### 考虑使用最小割解决此类问题：

将每个物品与源 $S$ 汇 $T$ 相连。若割掉与 $S$ 相连的边表示不选这个物品，割掉与 $T$ 相连的边表示选择这个物品。

对于一个物品的价值 $v$，如果 $v>0$ 则令它与 $S$ 相连的边的权值为 $v$，与 $T$ 相连的边的权值为 $0$，将 $v$ 加入答案。表示不选择这个物品会付出 $v$ 的代价；  
如果 $v<0$ 则令它与 $S$ 相连的边的权值为 $0$，与 $T$ 相连的边的权值为 $-v$（显然 $-v>0$）。表示选择这个物品会付出 $-v$ 的代价。

对于 $x\to y$ 的关系，转化为 $x$ 向 $y$ 连一条权值为 $\infty$ 的边，显然这条边永远不会被割，如果选择了 $x$，即割掉 $x$ 与 $T$ 相连的边，那么如果不选 $y$，即割掉 $y$ 与 $S$ 相连的边，就会出现路径 $S\to x\to y\to T$，所以必须选择 $y$。而如果不选 $x$ 则对 $y$ 的选择没有影响。

因为权值全部为非负数，符合使用 Dinic 算法解决网络流的条件，结合最大流最小割定理，可以使用 Dinic 算法解决此类问题。

回到题目上来，我们将每种 $d_{i,j}$ 的收益都看做一个物品。显然如果选择 $d_{i,j}$（$i<j$），则必须选择 $d_{i,j-1}$ 以及 $d_{i+1,j}$。

而如果吃了 $c$（$c>0$）种类型为 $x$ 的寿司，需要付出 $mx^2+cx$ 的代价。  
这可以转化为：吃了每种类型为 $x$ 的寿司需要付出 $x$ 的代价，而吃过类型为 $x$ 的寿司需要付出 $mx^2$ 的代价。

选择了 $d_{i,i}$ 就代表吃掉了第 $i$ 种寿司，这时需要付出 $a_i$ 的代价（$a_i$ 是这种寿司的类型）。

选择了 $d_{i,i}$ 还意味着：必须付出 $m\cdot a_i^2$ 的代价，我们将每个寿司类型也看作一个物品，选择收益 $d_{i,i}$ 则必须选择类型 $a_i$。

至此，所有限制都转化为了“选择 $x$ 则必须选择 $y$”的形式，可以使用**最大权闭合子图**的模型解决了。

在代码中，$S$、$T$ 分别是 $1$ 和 $2$ 号点，$d_{i,j}$ 是 $\mathrm{Id}[i][j]$ 号点，接下来的点则是每种寿司类型。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

typedef long long LL;
const LL Inf = 0x7fffffffffffffff;

namespace DinicFlow {
	const int MN = 6060, MM = 16055;
	
	int N, S, T;
	int h[MN], iter[MN], nxt[MM * 2], to[MM * 2], tot = 1; LL w[MM * 2];
	inline void ins(int u, int v, LL x) { nxt[++tot] = h[u], to[tot] = v, w[tot] = x, h[u] = tot; }
	inline void insw(int u, int v, LL x) { ins(u, v, x); ins(v, u, 0); }
	
	int lv[MN], que[MN], l, r;
	
	inline bool Lvl() {
		memset(lv, 0, sizeof(lv));
		lv[S] = 1;
		que[l = r = 1] = S;
		while (l <= r) {
			int u = que[l++];
			for (int i = h[u]; i; i = nxt[i]) if (w[i] && !lv[to[i]]) {
				lv[to[i]] = lv[u] + 1;
				que[++r] = to[i];
			}
		}
		return lv[T] != 0;
	}
	
	LL Flow(int u, LL f) {
		if (u == T) return f;
		LL d = 0, s = 0;
		for (int &i = iter[u]; i; i = nxt[i]) if (w[i] && lv[to[i]] == lv[u] + 1) {
			d = Flow(to[i], std::min(f, w[i]));
			f -= d, s += d;
			w[i] -= d, w[i ^ 1] += d;
			if (!f) break;
		}
		return s;
	}
	
	inline LL Dinic() {
		LL Ans = 0;
		while (Lvl()) {
			memcpy(iter + 1, h + 1, N * sizeof(h[0]));
			Ans += Flow(S, Inf);
		}
		return Ans;
	}
}

const int MN = 105;

int N, M, A[MN], MxA;
int F[MN][MN], Id[MN][MN], cnt;
LL Ans = 0;

int main() {
	scanf("%d%d", &N, &M);
	for (int i = 1; i <= N; ++i) scanf("%d", &A[i]), MxA = std::max(MxA, A[i]);
	DinicFlow::S = 1, DinicFlow::T = 2;
	cnt = 2;
	for (int i = 1; i <= N; ++i) for (int j = i; j <= N; ++j) {
		scanf("%d", &F[i][j]), Id[i][j] = ++cnt;
	}
	for (int i = 1; i <= N; ++i) for (int j = i; j <= N; ++j) {
		int cost = F[i][j];
		if (i == j) {
			if (M) DinicFlow::insw(Id[i][j], cnt + A[i], Inf);
			cost -= A[i];
		}
		else {
			DinicFlow::insw(Id[i][j], Id[i + 1][j], Inf);
			DinicFlow::insw(Id[i][j], Id[i][j - 1], Inf);
		}
		if (cost > 0) DinicFlow::insw(1, Id[i][j], cost), Ans += cost;
		if (cost < 0) DinicFlow::insw(Id[i][j], 2, -cost);
	}
	if (M) for (int i = 1; i <= MxA; ++i) DinicFlow::insw(++cnt, 2, i * i);
	DinicFlow::N = cnt;
	printf("%lld\n", Ans - DinicFlow::Dinic());
	return 0;
}
```

---

## 作者：绚濑绘里 (赞：14)

把博客里写的复制过来骗一波经验好了(雾)

网络流 最小割 最大权闭合子图

有经验的选手可以根据权值不重复计算的特性看出这是一个最大权闭合子图问题；

经验不足的选手看了题解就知道这是一个最大权闭合子图问题（逃）


###花式建边：


1.对于所有的$(i,j)$区间收益，将它们各自看做一个点，若权值$mp$为正，从源点连过来，容量为$mp$，若权值为负，连到汇点去，容量为$-mp$


2.对于所有的$(i,j)$区间收益，向区间内包括的i到j号寿司连边，容量为$INF$，表示必须选对应的寿司才能选这个区间


3.对于所有的寿司类型$w[i]$，为它们各自开一个点，向汇点T连边，容量为$m*w[i]*w[i]$


4.对于1~n每一个寿司，向它们所属的类型$w[i]$连边，容量为$INF$；向T连边，容量为$C[i]$


5.对于所有的$(i,j)$区间，向$(i+1,j)$和$(i,j-1)$连边，容量为INF，表示选了大区间肯定得选被大区间包含的小区间

之后用总收益减去最小割即可


```cpp
/*by SilverN & Elichika*/
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<queue>
#define LL long long
using namespace std;
const int INF=0x3f3f3f3f;
const int mxn=30505;
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0' && ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
struct edge{
    int u,v,nxt,f;
}e[mxn<<6];
int hd[mxn],mct=1;
inline void add_edge(int u,int v,int f){
    e[++mct].v=v;e[mct].u=u;e[mct].nxt=hd[u];e[mct].f=f;hd[u]=mct;return;
}
void insert(int u,int v,int f){
    add_edge(u,v,f); add_edge(v,u,0);
    return;
}
int S,T;
int d[10085];
bool BFS(){
    memset(d,0,sizeof d);
    queue<int>q;
    d[S]=1;
    q.push(S);
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=hd[u];i;i=e[i].nxt){
            int v=e[i].v;
            if(!d[v] && e[i].f){
                d[v]=d[u]+1;
                q.push(v);
            }
        }
    }
    return d[T];
}
int DFS(int u,int lim){
    if(u==T)return lim;
    int f=0,tmp;
    for(int i=hd[u];i;i=e[i].nxt){
        int v=e[i].v;
        if(d[v]==d[u]+1 && e[i].f && (tmp=DFS(v,min(lim,e[i].f)))){
            e[i].f-=tmp;
            e[i^1].f+=tmp;
            lim-=tmp;
            f+=tmp;
            if(!lim)return f;
        }
    }
    d[u]=0;
    return f;
}
int Dinic(){
    int res=0;
    while(BFS())res+=DFS(S,INF);
    return res;
}
int n,m;
int a[105];
int mp[105][105];
int id[105][105],ict=0;
int idw[1005];
bool vis[1005];
LL smm=0;
void Build(){
    S=0;
    for(int i=1;i<=n;i++){
        for(int j=i;j<=n;j++){
            id[i][j]=++ict;
        }
    }
    for(int i=1;i<=n;i++){
        if(!vis[a[i]]){
            vis[a[i]]=1;
            idw[a[i]]=++ict;
        }
    }
    T=ict+n+1;
    memset(vis,0,sizeof vis);
    for(int i=1;i<=n;i++){
        if(!vis[a[i]]){
            vis[a[i]]=1;
            insert(idw[a[i]],T,m*a[i]*a[i]);
        }
    }
    for(int i=1;i<=n;i++){//zhonglei
        insert(ict+i,idw[a[i]],INF);
        insert(ict+i,T,a[i]);
    }
    for(int i=1;i<=n;i++){
        for(int j=i;j<=n;j++){
            if(mp[i][j]>0){
                smm+=mp[i][j];
                insert(S,id[i][j],mp[i][j]);
                insert(id[i][j],ict+i,INF);
                insert(id[i][j],ict+j,INF);
            }
            else if(mp[i][j]<0){
                insert(id[i][j],T,-mp[i][j]);
                insert(id[i][j],ict+i,INF);
                insert(id[i][j],ict+j,INF);
            }
            if(i!=j){
                insert(id[i][j],id[i+1][j],INF);
                insert(id[i][j],id[i][j-1],INF);
            }
        }
    }
    return ;
}
int main(){
    int i,j;
    n=read();m=read();
    for(int i=1;i<=n;i++)a[i]=read();
    for(i=1;i<=n;i++)
        for(j=i;j<=n;j++)
            mp[i][j]=read();
    Build();
    int res=Dinic();
    smm-=res;
    printf("%lld\n",smm);
    return 0;
}

```


---

## 作者：tzc_wk (赞：12)

神仙题

##### 顺便打个广告：[我的网络流好题的blog](https://www.luogu.com.cn/blog/et2006/wang-lao-liu-hao-ti-ti-xie-hui-zong) 以及 [我的网络流24题题解](https://www.luogu.com.cn/blog/et2006/post-wang-lao-liu-24-ti-ti-xie-hui-zong)

### 铺垫：最大权闭合子图

#### 推荐以下我的模板题：[【模板】最大权闭合子图](https://www.luogu.com.cn/problem/U103816)

现在假设有一张 $\mathrm{DAG}$。$n$ 个节点 $m$ 条边，点上有点权 $w_i$，可正可负。现在你要从中选出一个点集 $S$，使得对于所有的有向边 $x \rightarrow y$，如果 $x \in S$，那么 $y \in S$，最大化选出的点的权值之和。

首先我们知道最理想的状态为取走所有权值为正的点，不去所有权值为负的点，但是这个状态不一定合法。我们可以尝试使用最小割的思想，拿最理想的状态的答案，减去将理想状态调整为合法状态的最小代价。

我们可以建一张图，对于所有的点 $i$，如果 $w_i \gt 0$，从源点 $S$ 向 $i$ 连一条边，流量为 $w_i$，删掉这条边，表示不选这条边，需要付出 $w_i$ 的代价。如果 $w_i \lt 0$，那么连一条从 $i$ 到汇点 $T$ 的边，流量为 $-w_i$（原本权值为负，取个相反数就变成正的了），删掉这条边，表示选这个点，要加上 $-w_i$ 的代价。中间连我们已有的边，流量为 $\infty$，然后跑最小割即最大流，就是我们将理想状态调整为合法状态的最小代价。然后再拿理想状态，即 $\sum_{i=1}^nw_i\ (w_i>0)$，减掉这个最小代价，就是最终答案了。

为什么这么做是正确的呢？我们发现对于 $w_i>0$ 的点，尽管我们没有在它与汇点 $T$ 之间连边，我们也可以定义割掉这条边为选择这个点，只不过容量为 $0$，即原本在理想状态中已经选择了这个点，再重新选择它不需要任何代价。同理，对于 $w_i<0$ 的点，尽管没有它与 $S$ 之间的边，我们也可以定义割掉这条边为不选择这个点，只不过容量为 $0$，表明不选择这个点不需要付出任何代价。

这样就可以证明了，对于每一条边 $x \rightarrow y$，假设我们选了 $x$ 没有选 $y$，那么就是割掉 $x$ 到 $T$ 的边，割掉 $S$ 到 $y$ 的边，但是还是存在路径 $S \rightarrow x \rightarrow y \rightarrow T$，仍然存在 $S$ 到 $T$ 的路径。这也就意味着“网络图中不存在 $S$ 到 $T$ 的路径” 与 “不存在有向边 $x \rightarrow y$，$x$ 被选中，$y$ 没有被选中” 是等价的。这也就证明了我们算法的正确性。

回到这个题来。我们会发现，那个“美食评判标准”的“记忆性”其实是假的。因为我们选了 $[1,2]$ 和 $[2,3]$，获得的收益为 $d_{1,1}+d_{1,2}+d_{2,2}+d_{2,3}+d_{3,3}$等价于取 $[1,3]$ 的收益，但是相比于取 $[1,3]$，它还多了一个 $a_2$ 的代价。也就是说与其取 $[1,2]$ 和 $[2,3]$，还不如取它们的并集 $[1,3]$。

其次，我们发现，如果 $d_{i,j}\ (i<j)$ 被累加到了答案里，那么 $d_{i+1,j}$ 和 $d_{i,j-1}$ 也会被累加到答案里。这就给我们一个启发：把每个 $d_{i,j}$ 看成一个点，选了 $d_{i,j}$ 就必须选 $d_{i+1,j}$ 和 $d_{i,j-1}$。

再考虑代价 $mx^2+cx$，可以将其转化为“每吃一个类型为 $x$ 的寿司就需要付出 $x$ 的代价，而吃过至少一种类型为 $x$ 的寿司又要付出 $mx^2$ 的代价”。“每吃一个类型为 $x$ 的寿司就需要付出 $x$ 的代价”，可以看成是选择 $d_{i,i}$ 的代价额外增加 $a_i$。而“吃过至少一种类型为 $x$ 的寿司又要付出 $mx^2$ 的代价”可以启发我们将每种寿司类型也看成一个点，类型 $x$ 的代价为 $mx^2$，而如果选择点 $d_{i,i}$，就必须选择点 $a_i$。这样就转化为了一个最大权闭合子图的问题了。

最后是代码：

```cpp
/*
数据不清空，爆零两行泪。
多测不读完，爆零两行泪。
边界不特判，爆零两行泪。
贪心不证明，爆零两行泪。
D P 顺序错，爆零两行泪。
大小少等号，爆零两行泪。
变量不统一，爆零两行泪。
越界不判断，爆零两行泪。
调试不注释，爆零两行泪。
溢出不 l l，爆零两行泪。
*/
#include <bits/stdc++.h>
using namespace std;
#define fi			first
#define se			second
#define fz(i,a,b)	for(int i=a;i<=b;i++)
#define fd(i,a,b)	for(int i=a;i>=b;i--)
#define put(x)		putchar(x)
#define eoln        put('\n')
#define space		put(' ')
#define int long long
inline int read(){
	int x=0,neg=1;char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	neg=-1;
		c=getchar();
	}
	while(isdigit(c))	x=x*10+c-'0',c=getchar();
	return x*neg;
}
inline void print(int x){
	if(x<0){
		putchar('-');
		print(abs(x));
		return;
	}
	if(x<=9)	putchar(x+'0');
	else{
		print(x/10);
		putchar(x%10+'0');
	}
}
int head[20005];
struct edge{
	int to,nxt,cap;
} e[300005];
int ecnt=1;
inline void addedge(int u,int v,int f){
	e[++ecnt].to=v;e[ecnt].cap=f;e[ecnt].nxt=head[u];head[u]=ecnt;
}
int dep[20005];
inline bool bfs(int s,int t){
	queue<int> q;
	memset(dep,-1,sizeof(dep));
	q.push(s);dep[s]=0;
	while(!q.empty()){
		int cur=q.front();q.pop();
		for(int i=head[cur];i;i=e[i].nxt){
			int to=e[i].to;
			if(dep[to]==-1&&e[i].cap){
				dep[to]=dep[cur]+1;
				q.push(to);
			}
		}
	}
	if(dep[t]!=-1)	return 1;
	return 0;
}
inline int dfs(int x,int t,int f){
	if(x==t)	return f;
	int ret=0;
	for(int i=head[x];i;i=e[i].nxt){
		int y=e[i].to;
		if(dep[y]==dep[x]+1&&e[i].cap){
			int w=dfs(y,t,min(f-ret,e[i].cap));
			e[i].cap-=w;
			e[i^1].cap+=w;
			ret+=w;
			if(ret==f)	return f;
		}
	}
	if(ret==0)	dep[x]=-1;
	return ret;
}
inline int Dinic(int s,int t){
	int tot=0;
	while(bfs(s,t))	tot+=dfs(s,t,0x3f3f3f3f);
	return tot;
}
int n,m,d[105][105],id[105][105],mx=0,a[105],aid[1005],cnt=0,sum=0;
signed main(){
	n=read(),m=read();
	fz(i,1,n)	a[i]=read(),mx=max(mx,a[i]);
	fz(i,1,n)	fz(j,i,n)	d[i][j]=read(),id[i][j]=++cnt;
	fz(i,1,mx)	aid[i]=++cnt;
	fz(i,1,n){
		fz(j,i,n){
			if(i==j){
				d[i][j]-=a[i];
			}
			if(d[i][j]>0)	addedge(0,id[i][j],d[i][j]),addedge(id[i][j],0,0),sum+=d[i][j];
			else			addedge(id[i][j],cnt+1,-d[i][j]),addedge(cnt+1,id[i][j],0);
		}
	}
	fz(i,1,mx){
		if(m>0){
			addedge(aid[i],cnt+1,m*i*i);
			addedge(cnt+1,aid[i],0);
		}
	}
	fz(i,1,n){
		addedge(id[i][i],aid[a[i]],0x3f3f3f3f);
		addedge(aid[a[i]],id[i][i],0);
	}
	fz(i,1,n){
		fz(j,i+1,n){
			addedge(id[i][j],id[i+1][j],0x3f3f3f3f);
			addedge(id[i+1][j],id[i][j],0);
			addedge(id[i][j],id[i][j-1],0x3f3f3f3f);
			addedge(id[i][j-1],id[i][j],0);
		}
	}
	cout<<sum-Dinic(0,cnt+1)<<endl;
	return 0;
}
```

---

## 作者：SofanHe (赞：4)

## 题目分析

权值有正有负,而且重复选只算一次.

选了某些东西就得选其他东西.

↓

最大权连通子图.

###### ~~于是我想不出来怎么建图了~~

## 建图分析

最大权连通子图的建图方法是?

###### 补充说明:gnum(x,y)为得到[x,y]区间的编号,auto_add(from,to,flow)为网络流加边

#### 1.有约束的相互连边

选了大区间一定要选小区间.

##### Code

```cpp
for(int i=1;i<=n;++i){
	for(int j=i+1;j<=n;++j){
    	auto_add(gnum(i,j),gnum(i+1,j),inf);
        auto_add(gnum(i,j),gnum(i,j-1),inf);
    }
}
```

#### 2.最终算式加的连S,减的连T.

区间的得分情况啊,如果是正的就从S连过来,最大流为他的得分.

负的的话就连T,最大流为他的得分的绝对值啊.

##### Code

```cpp
for(int i=1;i<=n;++i){
	for(int j=i;j<=n;++j){
    	if(gains[i][j]>0)
        	auto_add(S,gnum(i,j),gains[i][j]);
        else
        	auto_add(gnum(i,j),T,-gains[i][j]);
    }
}
//gains[i][j]为[i,j]区间的得分
```

但是我们发现还有一个代价没有搞上,就是买这些寿司的钱.

$mx^{2}+cx$

我们拆开看    $mx^{2}$   和   $cx$

#### 先单独看前一项

前一项是与c,也就是购买的个数无关的,所以我们可以考虑单独建一个点,也就是说对每一种编号单独建一个点,由于选了它会产生负的收益,且为$mx^{2}$,所以我们就从这个x向T连一个$mx^{2}$的边.

这样的话,我们能得到新的依赖关系:

#### 选了一个寿司就需要选代表它的编号的那个点.

我们就向它的编号那个点连边.

#### 再看看后一项

后一项可以拆成这样  $c×(1×x)$

那么每选一个编号为x的寿司就会多x的消费,我们就从寿司那个点连向T,最大流量为它的编号的一条边就好了.

## 建模分析

最大权连通子图.

要求某些东西加起来最大,其中有依赖关系,就可以了.

本题的难点在于如何把买寿司的消费调整到图中.

博主这样的巨弱也是看了题解 $d^{a}_{lao}$ 才明白的.

## My Code For Reference

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Mmax = 1e7;
const int Nmax = 20000;
//%%%
const int inf=20010509;
int n,m,s,t,p1,p2,p3,to[Mmax<<1],net[Mmax<<1],tails=1,fr[Nmax];
long long mf[Mmax<<1];
void add(int froms,int tos,int mfs){
	//手动加边 
	to[++tails]=tos;
	net[tails]=fr[froms];
	mf[tails]=mfs;
	fr[froms]=tails;
}
void auto_add(int froms,int tos,int mfs){
	//自动化加边,高级不?(滑稽 
	add(froms,tos,mfs);
	add(tos,froms,0);
}
int cur[Nmax],dep[Nmax],ndo;
bool vis[Nmax];
bool BFS(){
	//Dinic啊,这个不用说 
	queue<int>ready;
	memset(vis,0,sizeof(vis));
	while(!ready.empty())ready.pop();
	dep[s]=0;vis[s]=1;
	ready.push(s);
	while(!ready.empty()){
		ndo=ready.front();
		ready.pop();
		for(int lzh=fr[ndo];lzh;lzh=net[lzh]){
			if(!vis[to[lzh]] && mf[lzh]){
				dep[to[lzh]]=dep[ndo]+1;
				vis[to[lzh]]=1;
				ready.push(to[lzh]);
				if(to[lzh]==t)return 1;
			}
		}
	}
	return vis[t];
}
long long DFS(int start,long long nf){
	//Dinic啊,这个也不用说 
	if(start==t || nf==0)	return nf;
	long long allflow=0,f;
	for(int &lzh=cur[start];lzh;lzh=net[lzh]){
		if(dep[to[lzh]]==dep[start]+1 && ( f = DFS(to[lzh],min(mf[lzh],nf)) )>0){
			mf[lzh]-=f;
			mf[lzh^1]+=f;
			allflow+=f;
			if( (nf-=f) ==0 )break;
		}
	}
	return allflow;
}
long long Dinic(){
	//Dinic啊,这个不用说 
	long long ans=0;
	while(BFS()){
		for(int i=0;i<=t;++i)cur[i]=fr[i];
		ans+=DFS(s,20010509);
	}
	return ans;
}
int id[1001],gains,total;
bool ads[1001];
int gnum(int fromd,int tod){
	//1000种菜品编号放前面,剩下的放后面. 
	return (fromd-1)*n+tod+1000;
}
int main(){
	scanf("%d%d",&n,&m);
	//t 是最大的编号 
	s=0;t=n*n+1001;
	for(int i=1;i<=n;++i){
		scanf("%d",&id[i]);
		if(m && !ads[id[i]]){
			//防止重边 
			ads[id[i]]=1;
			//只要有选这个编号的就会产生id[i]*id[i]的代价. 
			auto_add(id[i],t,id[i]*id[i]);
			// id[i]*id[i]*m, m为1,无所谓了
		}
		//选一个它就会触发它对应的编号的消费. 
		auto_add(gnum(i,i),id[i],inf);
		//选一个它就要付出id[i]的代价. 
		auto_add(gnum(i,i),t,id[i]);
	}
	for(int i=1;i<=n;++i){
		for(int j=i;j<=n;++j){
			scanf("%d",&gains);	
			//正权加上	
			total+=(gains>0?gains:0);
			//最大权闭合子图模型 
			if(gains>0)	auto_add(s,gnum(i,j),gains);
			else		auto_add(gnum(i,j),t,-gains);
			//选了大区间一定选小区间,首先[i,j]得是一个长度大于1的区间
			if(i!=j)	auto_add(gnum(i,j),gnum(i+1,j),inf);
			if(i!=j)	auto_add(gnum(i,j),gnum(i,j-1),inf);
		}
	}
	printf("%lld",total-Dinic());
	return 0;
}
```

---

## 作者：StudyingFather (赞：3)

归纳下题意：

1. 有若干个贡献值 $d_{i,j}$，每个贡献值最多只能取一次；
2. 如果取了 $d_{i,j}$，则一定会取 $d_{i+1,j}$ 和 $d_{i,j-1}$（如果存在）；
3. 取一个寿司（即取了 $d_{i,i}$）会产生 $a_i$ 的开销（可以认为实际收益为 $d_{i,i}-a_i$）；
4. 如果**存在**一个种类为 $i$ 的寿司被取，则产生 $m\times i^2$ 的开销。

由「取一个点必取其后继」和「贡献只算一次」的特点可知，本题实际上是一个 [最大权闭合子图](https://studyingfather.com/archives/2771) 的模型。

如何建模？

将所有的点分为两部分（点权非负和点权为负），对于所有点权非负的点，从源点向该点连边，流量为该点点权；而对于所有点权为负的点，从该点向汇点连边，流量为该点点权相反数。

对于原图上存在的依赖关系边（包括两种，第一种是 $d_{i,j}$ 连向 $d_{i+1,j}$ 和 $d_{i,j-1}$ 的边，第二种是 $d_{i,i}$ 连向点权为 $-m \times a_i^2$ 的点的边），我们继续保留，这些边的流量为 $+\infty$。

则答案为所有正权点的点权和减去原图的最小割。

详细正确性证明上面的链接已经给出，这里不再赘述。

```cpp
// Problem : P3749 [六省联考2017]寿司餐厅
// Contest : Luogu
// URL : https://www.luogu.com.cn/problem/P3749
// Memory Limit : 512 MB
// Time Limit : 1000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <cstring>
#include <iostream>
#include <queue>
#define INF 0x3f3f3f3f
using namespace std;
struct edge
{
 int v,w,next;
}e[1000005];
int head[10005],cur[10005],dep[10005],vis[10005],cnt=1,s,t;
int a[105],d[105][105],id[105][105],cntp;
void addedge(int u,int v,int w)
{
 e[++cnt].v=v;
 e[cnt].w=w;
 e[cnt].next=head[u];
 head[u]=cnt;
}
bool bfs()
{
 queue<int> q;
 memset(dep,INF,sizeof(dep));
 memset(vis,0,sizeof(vis));
 memcpy(cur,head,sizeof(head));
 dep[s]=0;
 vis[s]=1;
 q.push(s);
 while(!q.empty())
 {
  int p=q.front();
  q.pop();
  vis[p]=0;
  for(int i=head[p];i;i=e[i].next)
   if(dep[e[i].v]>dep[p]+1&&e[i].w)
   {
    dep[e[i].v]=dep[p]+1;
    if(!vis[e[i].v])
    {
     vis[e[i].v]=1;
     q.push(e[i].v);
    }
   }
 }
 if(dep[t]==INF)return 0;
 return 1;
}
int dfs(int p,int w)
{
 if(p==t)return w;
 int used=0;
 for(int i=cur[p];i;i=e[i].next)
 {
  cur[p]=i;
  if(dep[e[i].v]==dep[p]+1&&e[i].w)
  {
   int flow=dfs(e[i].v,min(w-used,e[i].w));
   if(flow)
   {
    used+=flow;
    e[i].w-=flow;
    e[i^1].w+=flow;
    if(used==w)break;
   }
  }
 }
 return used;
}
int main()
{
 ios::sync_with_stdio(false);
 int n,m,ans=0;
 cin>>n>>m;
 for(int i=1;i<=n;i++)
  cin>>a[i];
 for(int i=1;i<=n;i++)
  for(int j=i;j<=n;j++)
   cin>>d[i][j],id[i][j]=++cntp;
 s=cntp+1000+1,t=s+1;
 for(int i=1;i<=n;i++)
  for(int j=i;j<=n;j++)
  {
   int u=id[i][j];
   if(i==j)
   {
    d[i][j]-=a[i];
    addedge(u,cntp+a[i],INF),addedge(cntp+a[i],u,0);
   }
   int v1=id[i+1][j],v2=id[i][j-1];
   if(d[i][j]>0)
    addedge(s,u,d[i][j]),addedge(u,s,0),ans+=d[i][j];
   else
    addedge(u,t,-d[i][j]),addedge(t,u,0);
   if(i==j)continue;
   addedge(u,v1,INF),addedge(v1,u,0);
   addedge(u,v2,INF),addedge(v2,u,0);
  }
 for(int i=1;i<=1000;i++)
  addedge(cntp+i,t,m*i*i),addedge(t,cntp+i,0);
 while(bfs())
  ans-=dfs(s,INF);
 cout<<ans<<endl;
 return 0;
}
```

---

## 作者：installb (赞：2)

[题](https://www.luogu.com.cn/problem/P3749)  
先不考虑 $mx^2+c$。

这题读题有些困难，但是可以发现其实就是在一些 $d$ 中让你选取一些，并且有一些"选了 a 则必选 b"的限制，每个 $d$ 都只有**被选或不被选**两种状态，而不是可以被多次选择，后面的花费也是如此，这基本可以排除 dp 的可能性，这题就是个网络流题。

对于每个 $d_{i,j}$ 建一个点，然后向它的所有子区间连边，很明显，这就是个最大权闭合子图模型。  
但这样边数太多，考虑优化，$[i,j]$ 只连到 $[i+1,j]$ 和 $[i,j-1]$ 就可以达成目的了。

再考虑加入 $mx^2+c$。

对于每个代号单独建一个点，注意到 $mx^2$ 和**这个代号选了几种**是无关的，只和**这个代号选或没选**有关。如果选择了这个代号的寿司则必选这个代号对应的点，这是一个限制。  
然后就相当于让这个点是最大权闭合子图模型中一个收益为 $-mx^2$ 的点即可。

还有 $cx$，这个其实没啥用，每个寿司单独分开算就可以了，直接减到它的收益里面就行了，但我为方便起见建了两条边。

剩下就是最大权闭合子图了。  
**下图中省略了代表区间的点和单点所连的边**  
（也就是 `1-3,1-2,2-3,1,2,3` 的 $d$ 产生的边）  

![P3749.PNG](https://i.loli.net/2020/08/08/ekPpQ9ORMj2nVgl.png)  
图中认为 1 和 2 是代号 1，3 是代号 2。

贴一下代码：  
```cpp
#include <queue>
using namespace std;
typedef long long LL;
const LL INF = 0x3f3f3f3f3f3f3f3f;
const LL N = 12515,M = 70005;

// 以下是网络最大流 dinic 算法的模板
LL ec = 1,to[M << 1],nxt[M << 1],hed[N],cur[N],cap[M << 1];
void add_edge(LL f,LL t,LL c){
	++ ec; to[ec] = t; nxt[ec] = hed[f]; hed[f] = ec; cap[ec] = c;
	++ ec; to[ec] = f; nxt[ec] = hed[t]; hed[t] = ec; cap[ec] = 0;
}

queue <LL> q; LL lev[N];
void bfs(LL s){
	while(!q.empty()) q.pop();
	memset(lev,0,sizeof(lev)); lev[s] = 1; q.push(s);
	while(!q.empty()){
		LL u = q.front(); q.pop();
		for(LL i = hed[u];i;i = nxt[i]){
			LL v = to[i];
			if(cap[i] && !lev[v]){
				lev[v] = lev[u] + 1;
				q.push(v);
			}
		}
	}
}

LL dfs(LL u,LL t,LL f){
	if(u == t) return f;
	for(LL i = cur[u];i;i = nxt[i]){
		LL v = to[i]; cur[u] = i;
		if(cap[i] && lev[v] == lev[u] + 1){
			LL tmp = dfs(v,t,min(f,cap[i]));
			if(tmp){
				cap[i] -= tmp;
				cap[i ^ 1] += tmp;
				return tmp;
			}
		}
	}
	return 0;
}

LL mxf;
void dinic(LL s,LL t){
	LL f;
	while(1){
		bfs(s); if(!lev[t]) return;
		for(LL i = 1;i <= t;i ++) cur[i] = hed[i];
		while(1){
			f = dfs(s,t,INF);
			if(!f) break;
			mxf += f;
		}
	}
}
// 以上是 模板

LL n;
LL id(LL x,LL y){
	return (x - 1) * n + y;
}// 区间 [x,y] 对应的点

int main(){
	LL m,tp,sum = 0,S,T;
	cin >> n >> m;
	S = id(n,n) + 1001; T = S + 1;
	for(LL i = 1;i <= n;i ++){
		cin >> tp;
		add_edge(id(i,i),id(n,n) + tp,INF);
		add_edge(id(i,i),T,tp);
	}
	for(LL i = 1;i <= 1000;i ++) add_edge(id(n,n) + i,T,m * i * i);
    // 这里是为了方便，id(n,n) + x 是代号 x 对应的点
	for(LL i = 1;i <= n;i ++){
		for(LL j = i;j <= n;j ++){
			cin >> tp;
			if(tp > 0) sum += tp,add_edge(S,id(i,j),tp);
			else add_edge(id(i,j),T,-tp);
			if(j != i){
				add_edge(id(i,j),id(i + 1,j),INF);
				add_edge(id(i,j),id(i,j - 1),INF);
			}
		}
	}
	dinic(S,T);
	cout << sum - mxf << '\n';
	return 0;
}
```

---

## 作者：shadowice1984 (赞：2)

可能只有我这个蒟蒻dinic不加优化了吧……

~~(AC率俯冲90度)(大雾)~~

下面是关于这道题的题解，首先我们一看这道题是个应用题，而且这道题是个语文神题，最重要的是，n只有100！

根据~~“大了三分，小网络流，不大不小，斜率优化”~~可知，这道题是个网络流题

那么我们首先先把题目读一遍，~~然后发现我们并没有读懂~~，经过细致的观察，我们发现，题目中的限制虽然杂七杂八，但是呢，都是关于代价计算的方面，可以暂且不读，主要研究决策，最后发现只有一种决策——选中一个区间，然后就没了，那么我们知道了这个以后再去读代价计算公式

我们发现根据题目的代价计算方案，总收益=

sigma(cost(所有选中的区间))-sigma(每个代号的“开荒”代价)-sigma(每个代号的使用代价)

那么我们发现了，如果我们把题目输入的数组列成矩阵，大概长这样

X X X X X X

0 X X X X X

0 0 X X X X

0 0 0 X X X

0 0 0 0 X X

0 0 0 0 0 X

然后，我们发现每次取区间，都是取的一个方阵里的数，并且，这个方阵必须关于主对角线对称，另外，我们还发现，如果令(x,y)为这个方阵右上方的点，那么它对应的方阵唯一确定。

也就是说，选了点(x,y)也就是一定要选(x,y)下面的方阵，也就是说，一定要选它对应的方阵里的其他点。

选一些点必须要选其他点……每个点最多选一次……有点权……求最大点权和……？

只要你知道有个东西叫最大权闭合子图(我相信但凡讲网络流建图就得讲这个)
那么上面的就是最大权闭合子图的标准定义。~~（麻麻我会做了！）~~

且慢，还有两个问题要解决：

1.目前的限制条件还是 n^4的，无法忍受，但是，我们发现，选(x,y)其实就是必选(x+1,y),和(x,y-1)而且这个性质对于任意一个非对角线点恒成立，于是呢，我们可以这样有点递归意味的连边，总的限制条件就被压缩到了n^2级别

2.我们发现开荒费根本没管，每个寿司的价钱，一种只计算一次，所以可以直接让cost\[i]\[i]减去对应的代号即可，但是开荒费呢？
还好我萌已经推出了最大权闭合子图的模型，所以我们可以考虑把这个开荒费嵌进去，每种代号的开荒费仅计算一次，所以，新建一堆开荒费的负权节点，每个对角线点连一个依附关系即可，就是“选这个点必须选开荒费节点”的限制关系

### 最大权闭合子图

应该没人拿这道题练手最大权闭合子图吧~~(比如我？ε=ε=ε=┏(゜ロ゜;)┛逃)~~
还是讲一下好了呢

最大权闭合子图模型

1.选一些点必须要选其他点
2.每个点最多选一次
3.有点权
4.求最大点权和

嗯就是这样，我们考虑建立最小割模型处理这类问题

我们设割完的图里，A和S无连边，表示不选择A,A和T无连边，表示选择A

那么我们先贪心的拿所有正权点，之后再偿还代价

那么显然的，正权点向S连边，负权点向T连边，边权为点权的绝对值

这样的话，割掉S边，表示失去了一个正权边，割掉T边表示加进来了一个负权边

那么对于选A必选B的限制关系，我们从A->B连一条权值为+∞的边这样的话，如果
B没被割掉，A就必须被割掉，但是反向就没有约束,所以满足单向的限制关系

然后根据最大流最小割定理(最大流==最小割，感性理解一下就是第一遍输水，第二遍输502，输了多少水就得输等量的502才能堵住水管)，答案为所有正权和-最小割==所有正权和-最大流

上代码~

```C

#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
typedef long long ll;
struct data{int v;int nxt;ll cot;}edge[400010];
int alist[20010];int cnt=1;queue <int> q;
inline void add(int u,int v,ll cot)
{
    edge[++cnt].v=v;edge[cnt].nxt=alist[u];alist[u]=cnt;edge[cnt].cot=cot;
    edge[++cnt].v=u;edge[cnt].nxt=alist[v];alist[v]=cnt;edge[cnt].cot=0;
}
int n;int m;int s;int t;int dep[20010];int ctt;bool book[20010];
inline ll dfs(int x,ll lim)
{
    if(x==t){return lim;}
    int nxt=alist[x];ll nowflow=0;
    while(nxt)
    {
        if(lim==0)return nowflow;//两个优化都得加上，不然等着T飞吧~ 
        int v=edge[nxt].v;ll cot=edge[nxt].cot;
        if(cot!=0&&dep[v]==dep[x]+1)
        {
            ll del=dfs(v,min(cot,lim));
            if(del!=0)
            {
                edge[nxt].cot-=del;edge[nxt^1].cot+=del;
                lim-=del;nowflow+=del;
            }
        }
        nxt=edge[nxt].nxt;
    }
    if(nowflow==0){dep[x]=0x3f3f3f3f;}//第二优化 
	return nowflow;
}
inline bool bfs()//没啥好说的板子BFS 
{
    for(int i=1;i<=ctt;i++){book[i]=false;dep[i]=0x3f3f3f3f;}
    dep[s]=0;book[s]=true;q.push(s);
    while(!q.empty())
    {
        int now=q.front();q.pop();
        int nxt=alist[now];
        while(nxt)
        {
            int v=edge[nxt].v;ll cot=edge[nxt].cot;
            if(book[v]==false&&cot!=0)
            {book[v]=true;dep[v]=dep[now]+1;q.push(v);}
            nxt=edge[nxt].nxt;
        }
    }return book[t];
}
ll d[110][110];int tr[110][110];ll tp[110];ll flow;
int numtp[110]; 
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){scanf("%lld",&tp[i]);}
    for(int i=1;i<=n;i++){for(int j=i;j<=n;j++){scanf("%lld",&d[i][j]);}}
    for(int i=1;i<=n;i++){for(int j=i;j<=n;j++){tr[i][j]=++ctt;}}//暴力染色 
    s=++ctt;t=++ctt;
    for(int i=1;i<=n;i++){d[i][i]-=tp[i];}//减去花费 
    for(int i=1;i<=n;i++)
    {
        for(int j=i;j<=n;j++)
        {
            if(d[i][j]>0){flow+=d[i][j];add(s,tr[i][j],d[i][j]);}//正权点 
            if(d[i][j]<0){add(tr[i][j],t,-d[i][j]);}//负权点 
        }
    }
    for(int i=1;i<=n-1;i++)
    {
        for(int j=i+1;j<=n;j++)
        {
            add(tr[i][j],tr[i][j-1],0x7f7f7f7f);//压缩后的限制条件 
            add(tr[i][j],tr[i+1][j],0x7f7f7f7f);
        }
    }
    if(m==1)//如果有开荒费 
    {
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=i-1;j++)
            {if(tp[i]==tp[j]){numtp[i]=numtp[j];goto ed;}}
            numtp[i]=++ctt;add(ctt,t,tp[i]*tp[i]);ed:;//暴力找重复的 
        }
        for(int i=1;i<=n;i++){add(tr[i][i],numtp[i],0x7f7f7f7f);}//然后连上开荒费 
    }
    while(bfs()){while(1){ll p=dfs(s,0x7f7f7f7f);if(p==0)break;else flow-=p;}}//DINIC 
    flow=max(flow,0LL);printf("%lld",flow);return 0;//拜拜程序~ 
}

```

---

## 作者：览遍千秋 (赞：1)

### 问题描述

Kiana 最近喜欢到一家非常美味的寿司餐厅用餐。

每天晚上，这家餐厅都会按顺序提供 $n$ 种寿司，第 $i$ 种寿司有一个代号 $a_i$ 和美味度 $d_{i, i}$，不同种类的寿司有可能使用相同的代号。每种寿司的份数都是无限的，Kiana 也可以无限次取寿司来吃，但每种寿司每次只能取一份，且每次取走的寿司必须是按餐厅提供寿司的顺序连续的一段，即 Kiana 可以一次取走第 $1, 2$ 种寿司各一份，也可以一次取走第 $2, 3$ 种寿司各一份，但不可以一次取走第 $1, 3$ 种寿司。

由于餐厅提供的寿司种类繁多，而不同种类的寿司之间相互会有影响：三文鱼寿司和鱿鱼寿司一起吃或许会很棒，但和水果寿司一起吃就可能会肚子痛。因此，Kiana 定义了一个综合美味度 $d_{i, j} \ (i < j)$，表示在一次取的寿司中，如果包含了餐厅提供的从第 $i$ 份到第 $j$ 份的所有寿司，吃掉这次取的所有寿司后将获得的额外美味度。由于取寿司需要花费一些时间，所以我们认为分两次取来的寿司之间相互不会影响。注意在吃一次取的寿司时，不止一个综合美味度会被累加，比如若 Kiana 一次取走了第 $1, 2, 3$ 种寿司各一份，除了 $d_{1, 3}$ 以外，$d_{1, 2}, d_{2, 3}$ 也会被累加进总美味度中。

神奇的是，Kiana 的美食评判标准是有记忆性的，无论是单种寿司的美味度，还是多种寿司组合起来的综合美味度，在计入 Kiana 的总美味度时都只会被累加一次。比如，若 Kiana 某一次取走了第 $1, 2$ 种寿司各一份，另一次取走了第 $2, 3$ 种寿司各一份，那么这两次取寿司的总美味度为 $d_{1, 1} + d_{2, 2} + d_{3, 3} + d_{1, 2} + d_{2, 3}$，其中 $d_{2, 2}$ 只会计算一次。

奇怪的是，这家寿司餐厅的收费标准很不同寻常。具体来说，如果 Kiana 一共吃过了 $c \ (c > 0)$ **种**代号为 $x$ 的寿司，则她需要为这些寿司付出 $mx^2 + cx$ 元钱，其中 $m$ 是餐厅给出的一个常数。

现在 Kiana 想知道，在这家餐厅吃寿司，自己能获得的总美味度（包括所有吃掉的单种寿司的美味度和所有被累加的综合美味度）减去花费的总钱数的最大值是多少。由于她不会算，所以希望由你告诉她。

---

### 题解

模型，最大权闭合子图。

有 $n$ 个物品，第 $i$ 个物品的价值为 $w_i$（可以为负），存在若干形如选 $i$ 必须选 $j$ 的限制。

最小割。

令超源 $S$ 所在的集合为选择的物品集合，超汇 $T$ 所在的集合为不选择的物品的集合，显然对于一个物品 $i$ ，要么属于 $S$ ，要么属于 $T$。

令 $sum = \sum\limits_{w_i>0}{w_i}$

对于价值为正的物品 $i$，从 $S$ 向 $i$ 连边，边权为 $w_i$，表示不选择 $i$ 会损失 $w_i$ 的收益。

对于价值为负或零的物品 $i$，从 $i$ 向 $T$ 连边，边权为 $-w_i$ （显然 $-w_i > 0$ ），表示选择了 $i$ 要付出 $-w_i$ 的代价，即损失 $-w_i$ 的收益。

对于选择 $i$ 必选 $j$ 的限制，由 $i$ 向 $j$ 连边，表示 $j$ 必须属于 $i$ 所在的集合。

设最小割为 $ans$，则最后所选择物品的收益最大值为 $sum - ans$ 。

$\texttt{---------------------------------------------------------------------------------}$

对于本题，将每个 $d_{i,j}$ 视作一个物品。

特别地，新建 $\max{a_i}$ 个点，表示代号。

对于代号点，向 $T$ 连 $m \times a_i^2$ 的边，表示选择过这代号的寿司的代价。

对于寿司点，即 $d_{i,i}$ 点，向 $T$ 连 $a_i$ 的边，表示选择其所付出的价格；向对应代号点连边，表示选取这个寿司后一定会启用这个代号。

若选择 $d_{i,j}$ ，必选 $d_{i + 1,j},d_{i,j-1}$。

再按照最大权闭合子图建图就好了。

---

### $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn = 100 + 7;
const int maxnode = 7000 + 7;
const int maxm = 5000000 + 7;
const int INF = 0x3f3f3f3f;

int n, m, tot = 1, S = 7000, T = 7001;

int a[maxn];
int Head[maxnode], to[maxm], Next[maxm], w[maxm];

void addedge(int x, int y, int z) {
	to[++tot] = y, Next[tot] = Head[x], Head[x] = tot, w[tot] = z;
}
void add(int x, int y, int z) {
	addedge(x, y, z);
	addedge(y, x, 0);
}

int id(int x, int y) {
	return (n * 2 - x + 2) * (x - 1) / 2 + y - x + 1; 
}

int aimax;
int d[maxn][maxn];

void Init(void) {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
		aimax = max(aimax, a[i]);
	}
	for(int i = 1; i <= n; i++) {
		for(int j = i; j <= n; j++) {
			scanf("%d", &d[i][j]);
		}
	}
}

int ans;

/*
------------------- id defination -------------------
Range [1, (n + 1) * n / 2] FOR all d_{i,j}
Point (2 * n + 2 - i) * (i - 1) / 2 + j FOR d_{i,j}
Range [(n + 1) * n / 2 + 1, (n + 1) * n / 2 + max{a_i} ] FOR all a_i
Point (n + 1) * n / 2 + i FOR a_i
Point 7000 FOR S
Point 7001 FOR T
*/

void Graph_Build(void) {
	for(int i = 1; i <= aimax; i++) {
		add((n + 1) * n / 2 + i, T, m * i * i);
	}
	for(int i = 1; i <= n; i++) {
		for(int j = i; j <= n; j++) {
			if(d[i][j] > 0) {
				ans += d[i][j];
				add(S, id(i, j), d[i][j]);
			}
			else {
				add(id(i, j), T, -d[i][j]);
			}	
		}
		add(id(i, i), T, a[i]);
		add(id(i, i), (n + 1) * n / 2 + a[i], INF);
	}
	for(int i = 1; i <= n; i++) {
		for(int j = i + 1; j <= n; j++) {
			int x = i, y = j - 1;
			if(x <= y) add(id(i, j), id(x, y), INF);
			x = i + 1, y = j;
			if(x <= y) add(id(i, j), id(x, y), INF);
		}
	}
}

int D[maxnode];

bool bfs(void) {
	memset(D, 0, sizeof(D));
	queue < int > q;
	q.push(S); D[S] = 1;
	while(q.size()) {
		int x = q.front(); q.pop();
		for(int i = Head[x]; i; i = Next[i]) {
			int y = to[i];
			if(D[y] || !w[i]) continue;
			D[y] = D[x] + 1; q.push(y);
			if(y == T) return true;
		}
	}
	return false;
}

int dfs(int x, int flow) {
	if(x == T) return flow;
	int rest = flow;
	for(int i = Head[x]; i && rest; i = Next[i]) {
		int y = to[i];
		if(D[y] != D[x] + 1 || !w[i]) continue;
		int k = dfs(y, min(rest, w[i]));
		if(!k) D[y] = 0;
		else w[i] -= k, w[i ^ 1] += k, rest -= k;
	}
	return flow - rest;
}

int sum;

void Dinic(void) {
	int t;
	while(bfs()) {
		while(t = dfs(S, INF)) sum += t;
	}
}

void debug() {
	for(int i = 2; i <= tot; i += 2) {
		printf("%d %d %d\n", to[i ^ 1], to[i], w[i]);
	}
}

void Work(void) {
	Graph_Build();
//	debug();
	Dinic();
	printf("%d\n", ans - sum);
}


int main(void) {
	Init();
	Work();
	return 0;
}
```


---

## 作者：ysy20021208 (赞：1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**分析与题解：**如果我们选择了$[l，r]$的寿司，则我们就相当于选择了$[l+1，r]、[l，r-1]$的寿司，所以我们就可已经问题转化成如果要选择$[l，r]$的寿司，我们就必须选择$[l+1，r]、[l，r-1]$的寿司，这样我们就可以连边了。我们对每一个区间开一个点。对于$[l，r]$区间所对应点连出一条边，指向$[l+1，r]、[l，r-1]$所对应的点，边权为$inf$。对于每一个区间的点我们都用一条边权为当前区间美味值的边和$S$连接起来。对于花销，每一个寿司都和$T$相连，边权为他的编号。每一种寿司都开一个节点，每个寿司和自己种类所对应的点相连，边权为$inf$，这个种类还要和$T$相连，边权为$m\times x ^2$。我们在建出来的图上跑最大权闭合子图就可以了。

```c++
// luogu-judger-enable-o2
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define N 200
#define inf 1000000000
int n,m,cnt,idx=1,ans,ord[N][N],dis[N*N],mx,num[N],s,t;bool is[N<<3];
int cur[N*N],head[N*N],to[N*N<<5],nxt[N*N<<5],val[N*N<<5];
void add(int a,int b,int c)
    {nxt[++idx]=head[a],to[idx]=b,val[idx]=c,head[a]=idx;}
bool bfs()
{
    memset(dis,-1,sizeof dis);
    queue <int> q;q.push(s),dis[s]=0;
    while(!q.empty())
    {
        int p=q.front();q.pop();
        if(p==t) return true;
        for(int i=head[p];i;i=nxt[i])
            if(val[i]>0&&dis[to[i]]==-1)
                dis[to[i]]=dis[p]+1,q.push(to[i]);
    } return false;
}
int dfs(int p,int flow)
{
    int now,temp=flow;
    if(p==t) return flow;
    for(int i=cur[p];i;i=nxt[i])
        if(val[i]>0&&dis[to[i]]==dis[p]+1)
        {
            now=dfs(to[i],min(val[i],temp));
            if(!now) dis[to[i]]=-1;
            temp-=now,val[i]-=now,val[i^1]+=now;
            if(val[i]) cur[p]=i;
            if(!temp) break;
        } return flow-temp;
}
void dinic() {while(bfs()) memcpy(cur,head,sizeof head),ans-=dfs(s,inf);}
int main()
{
    scanf("%d%d",&n,&m),s=n*(n+1)/2+1,t=n*(n+1)/2+2;
    for(int i=1;i<=n;i++) scanf("%d",&num[i]),mx=max(mx,num[i]); s+=mx,t+=mx;
    for(int i=1;i<=n;i++) if(!is[num[i]])
        is[num[i]]=true,add(n*(n+1)/2+num[i],t,m*num[i]*num[i]),add(t,n*(n+1)/2,0);
    for(int i=1;i<=n;i++) for(int j=i;j<=n;j++) ord[i][j]=++cnt;
    for(int i=1;i<=n;i++)
        for(int j=i,a;j<=n;j++)
        {
            scanf("%d",&a);
            if(i==j) (a-num[i]<0)?(add(ord[i][j],t,num[i]-a),add(t,ord[i][j],0)):
                (ans+=a-num[i],add(s,ord[i][j],a-num[i]),add(ord[i][j],s,0));
            else (a<0)?(add(ord[i][j],t,-a),add(t,ord[i][j],0)):
                (ans+=a,add(s,ord[i][j],a),add(ord[i][j],s,0));
            if(i==j) add(ord[i][j],n*(n+1)/2+num[i],inf),add(n*(n+1)/2+num[i],ord[i][j],0);
            else add(ord[i][j],ord[i+1][j],inf),add(ord[i+1][j],ord[i][j],0),
                add(ord[i][j],ord[i][j-1],inf),add(ord[i][j-1],ord[i][j],0);
        } dinic();printf("%d\n",ans);
}
```

---

## 作者：撤云 (赞：1)

### 题目链接
[戳我](https://www.luogu.org/problemnew/show/P3749)
### $Describe$
>简要题目：
    一个序列，可以若干次取其中一段区间，区间及其子集的价值都会被统计进去且每个区间的价值只能被统计一次。
    如果你拿$c$种$x$数，你需要花费$m*x^2+c*x$的代价。
    求最大价值。
    
### $Solution$

这道题看起来并没有思路，看了看题解后发现这是最大权闭合子图。$What?$这是神马？不会，于是去学了一下。

然后发现这道题就是最大权闭合子图；

首先处理区间：
将区间看成点,看看这个区间的权值是否为正，为正用$S$和这个区间相连,流量为权值。反之用这个区间和$t$相连流量为权值的前缀和。因为对于一个区间他还必须要包括子区间，所以我们在把这个区间$[i,j]$和$[i,j-1],[i+1,j]$相连。流量为$inf$

再来看看寿司

对于$m*x^2+c*x$我们将他拆分。变成$m*x^2$和$c*x$

对于$m*x^2$我们会发现他和数量没冠希，于是我们可以将他和$T$相连流量为$m*x^2$
在将$[i,i]$这个点和这个寿司相连，流量为$inf$再将这个点和$T$相连流量为$x$

网络流的代码有点长，见博客吧，就不在这占篇幅了
[戳我](https://www.cnblogs.com/hbxblog/p/10265715.html)

---

## 作者：_HCl_ (赞：0)

小蒟蒻刚学最大权闭合子图，写一篇题解加深一下理解。

# P3749 题解

**题意简述**

有 $n$ 个物品，每个物品的类型是 $a_i$。现在要选择一些物品。

如果 $[i,j]$ 内的物品都被选择，可以获得 $d_{i,j}$ 的收益。

如果类型 $t$ 的物品被选择了 $x$ 种，就会获得 $-(mt^2+xt)$ 的收益。

其中 $m$ 是题目给定的常数，$m\in \{0,1\}$。

**思路引导**

最大权闭合子图模型，可以解决形如下的问题：

有若干的物品，每个物品拥有价值 $v_i$（$v_i$ 可以为负），选取若干个物品，使得总价值最大。

一些物品的选择存在先决条件，也就是先选择其他物品才能选择该物品。


对于这类问题使用最小割进行处理。具体建立的流网络模型是：

对于每一个物品建立一个节点，开始时与源汇点相连，表示不确定是否选取。割掉与源点相连的边表示不选，割掉与汇点相连的边表示选。

初始时，对于一个物品节点：
- $v_i>0$ 时，与源点相连的边边权为 $v_i$，与汇点相连的边边权为 $0$。
- $v_i<0$ 时，与汇点相连的边边权为 $0$，与汇点相连的边边权为 $-v_i$。

对于制约条件，如果选 $A$ 是选 $B$ 的先决条件，那么连一条从 $B$ 到 $A$ 的边权为 $\infty$ 的边。

最后的最大总价值就是 $\sum_{v_i>0}v_i$ 减去图的最小割。

---

接下来考虑将本题转换为最大权闭合子图的模型。

考虑选取 $[i,j]$ 内的全部寿司视为一个物品，而选取其子区间 $[i+1,j]$ 和 $[i,j-1]$ 就是先决条件。

对于选取某一类型的代价（负收益），我们拆成类型所带来的负收益 $-mx^2$ 和单个寿司所带来的负收益 $-x$。

对于 $[i,i]$ 这个区间所对应的物品，其 $v_i$ 还需要减去 $a_i$。

对于一个类型，我们将一个类型视为一个物品，则该类型下的寿司就是其先决条件。其 $v_i=-mx^2$。

**代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=20001;
int n,m,d[2001][2001],id[2001][2002],id2[N],a[N];
int to[N<<2],e[N<<2],nxt[N<<2],hd[N<<2],t=1;
int now[N],dis[N],vis[N];
int S=0,T=1,cnt=1;
int ans;
queue<int> q;
void add(int x,int y,int z){
	to[++t]=y,e[t]=z,nxt[t]=hd[x],hd[x]=t;
	to[++t]=x,e[t]=0,nxt[t]=hd[y],hd[y]=t;
}
bool bfs(){
	memset(dis,0,sizeof(dis));
	while(!q.empty())q.pop();
	q.push(S);
	dis[S]=1,now[S]=hd[S];
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=hd[x];i;i=nxt[i]){
			if(e[i]&&!dis[to[i]]){
				q.push(to[i]);
				now[to[i]]=hd[to[i]];
				dis[to[i]]=dis[x]+1;
				if(to[i]==T)return 1;	
			}
		}
	}
	return 0;
}
int dinic(int x,int flow){
	if(x==T)return flow;
	int cur=flow,k;
	for(int i=now[x];i&&cur;i=nxt[i]){
		now[x]=i;
		if(e[i]&&dis[to[i]]==dis[x]+1){
			k=dinic(to[i],min(cur,e[i]));
			if(!k)dis[to[i]]=0;
			e[i]-=k,e[i^1]+=k,cur-=k;
		}
	}
	return flow-cur;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i)scanf("%d",a+i),id2[a[i]]=++cnt;//id2存储类型对应的节点编号 
	for(int i=1;i<=n;++i)
		for(int j=i;j<=n;++j){
			scanf("%d",&d[i][j]);
			id[i][j]=++cnt;//id存储区间对应的节点编号 
		} 
	for(int i=1;i<=n;++i){
		for(int j=i;j<=n;++j){
			int tmp=d[i][j];
			if(i==j){
				if(m)add(id[i][j],id2[a[i]],1e9); //建边 
				tmp-=a[i];//价值修正 
			}
			else{
				add(id[i][j],id[i+1][j],1e9);
				add(id[i][j],id[i][j-1],1e9);
			}
			if(tmp>0)add(S,id[i][j],tmp),ans+=tmp;
			else if(tmp<0)add(id[i][j],T,-tmp);
		}
	}
	for(int i=1;i<=n;++i)
		if(!vis[a[i]])
			vis[a[i]]=1,add(id2[a[i]],T,a[i]*a[i]);
	int maxflow=0,flow;
	while(bfs())
		while(flow=dinic(S,1e9))maxflow+=flow;//最小割=最大流 
	cout<<ans-maxflow;
}
```

---

## 作者：Cindy_Li (赞：0)

## [P3749 [六省联考 2017] 寿司餐厅](https://www.luogu.com.cn/problem/P3749) 题解

发现很少有人讲为什么这题是**最大权闭合子图**，但作为一个刚学网络流的蒟蒻，我认为考虑是必要的。

最大权闭合子图的特点：
- 存在**单向依赖**关系，选 $x$ 必须选 $y$。
- 每个点只会被选一次。
- 代价有正有负。

本问题特点：
- 选一个区间，必选所有子区间（单向依赖）。
- 贡献 & 代价都只算一次。
- 有正有负。

完美符合要求！

只需要打个补丁，选 $[i,i]$ 必选 $a_i$。

------------------------------

会最大权闭合子图的可以跳过下面一部分。

### 最大权闭合子图模型

考虑最优为选所有正的，不选负的。

建图：
- $s$ 为源点，$t$ 为汇点。
- 对于依赖关系 $x\to y$，连边 $(x,y,INF)$。
- 对于节点，若代价为正，连边 $(s,i,v_i)$；反之，连边 $(i,t,-v_i)$。

若割掉与 $s$ 相连的边，代表不选这个正的，损失 $v_i$ 贡献；若割掉与 $t$ 相连的边，代表选这个负的，付出 $v_i$ 代价。

发现 $s$ 和 $t$ 只会通过形如 $s\to x\to y\to t$ 的边相连。
- 如果保留 $(y,t)$，即选 $y$，则**必然**割掉 $(s,x)$，即不选 $x$。
- 如果割掉 $(y,t)$，即不选 $y$，$(s,x)$ 可割可不割，不受影响。

故此图的割满足**选 $y$ 是选 $x$ 的必要条件**。

最大权为 所有正权值之和 $-$ 最小割。

---------------------------------

讲到这里本题建图就很简单了，不懂的请自行看代码理解。

```c++
#include<bits/stdc++.h>
using namespace std;
#define rep(i,x,y) for(int i=x;i<=y;i++)
#define REPG(i,g,x) for(int i=g.head[x];~i;i=g.edge[i].nxt)

//此处省略快读板子

const int N=1e5+5,M=2e6+5;
struct graph{
    int head[N],cnt;
    struct node{
        int to,nxt,w,c;
    }edge[M];
    inline void add(int x,int y,int w,int c){
        edge[++cnt]=(node){y,head[x],w,c};head[x]=cnt;
    }
    inline void clear(){
        memset(head,-1,sizeof(head));cnt=1;
    }
}g;
int n,m,s,t;
const int NF=105;
const int INF=1e9+5;
int a[NF],d[NF][NF],id[NF][NF];
int Maxa;

namespace Dinic{
    int dep[N],cur[N];
    queue<int> q;
    bool bfs(){
        memset(dep,-1,sizeof(dep));
        memcpy(cur,g.head,sizeof(g.head));
        while(!q.empty()) q.pop();
        
        dep[s]=1;q.push(s);
        while(!q.empty()){
            int u=q.front();q.pop();
            if(u==t) break;
            REPG(i,g,u){
                int v=g.edge[i].to,w=g.edge[i].w,c=g.edge[i].c;
                if(dep[v]==-1 && w>c){
                    dep[v]=dep[u]+1;
                    q.push(v);
                }
            }
        }
        return dep[t]!=-1;
    }
    int dfs(int u,int f){
        if(u==t || !f) return f;
        int res=0;
        for(int i=cur[u];(~i) && f!=res;i=g.edge[i].nxt){
            int v=g.edge[i].to,w=g.edge[i].w,c=g.edge[i].c;
            cur[u]=i;
            if(dep[v]==dep[u]+1 && w>c){
                int nf=dfs(v,min(f-res,w-c));
                res+=nf;
                g.edge[i].c+=nf;
                g.edge[i^1].c-=nf;
            }
        }
        return res;
    }
    int solve(){
        int ans=0;
        while(bfs()) ans+=dfs(s,INF);
        return ans;
    }
}

int main(){
    g.clear();
    read(n),read(m);
    rep(i,1,n) read(a[i]),Maxa=max(Maxa,a[i]);
    s=1,t=2;
    int tot=2;
    rep(i,1,n) rep(j,i,n){
        read(d[i][j]);
        id[i][j]=++tot;
    }
    int mx=0;
    rep(i,1,n) rep(j,i,n){
        if(i==j){
            //选 d[i][i] 必选 a[i]
            g.add(id[i][j],tot+a[i],INF,0);
            g.add(tot+a[i],id[i][j],0,0);
            //选 d[i][i] 需要付出 a[i] 的代价
            d[i][j]-=a[i];
        }
        else{
            //选 d[i][j] 必选 d[i+1][j],d[i][j-1]
            g.add(id[i][j],id[i+1][j],INF,0);
            g.add(id[i+1][j],id[i][j],0,0);
            g.add(id[i][j],id[i][j-1],INF,0);
            g.add(id[i][j-1],id[i][j],0,0);
        }
        if(d[i][j]>0) g.add(s,id[i][j],d[i][j],0),g.add(id[i][j],s,0,0),mx+=d[i][j];
        else g.add(id[i][j],t,-d[i][j],0),g.add(t,id[i][j],0,0);
    }
    //选 i 需要付出 m*i*i 的代价
    rep(i,1,Maxa) g.add(tot+i,t,m*i*i,0),g.add(t,tot+i,0,0);
    printf("%d\n",mx-Dinic::solve());
    return 0;
}
```

---

## 作者：lfxxx (赞：0)

既然是求最大值而且有收益有代价，所以考虑建立一个最大权封闭子图模型。

## 收益

正的美味值是收益，所以假若 $d_{i,j} \geq 0$ 则建边 $(s,pos_{i,j},d_{i,j})$。

## 代价

负的美味值是代价，所以假若 $d_{i,j} < 0$ 则建边 $(pos_{i,j},t,-d_{i,j})$。

吃某种代号的寿司会收钱，吃没吃和吃多少分开计算，种类 $x$ 建边 $(x,t,m \times x^2)$。寿司 $i$ 建边 $(pos_{i,i},t,a_i)$。

## 依赖关系

吃了区间 $[l,r]$ 内的寿司也一定吃了被这个区间所包含的区间内的寿司，所以建边 $(pos_{i,j},pos_{i+1,j})$ 与 $(pos_{i,j},pos_{i,j-1})$。

吃没吃某一种寿司也是一种依赖关系，所有 $a_i = x$ 的 $i$ 建边$(pos_{i,i},x,inf)$。

那么建完边之后跑一遍最大流即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e6+114;
const int inf = INT_MAX;
int maxflow,tot=1;
int s,t,hd[maxn],road[maxn],dis[maxn];
struct edge{
int next,to,w;
}e[maxn*2];
void add(int u,int v,int w){
e[++tot].to=v;
e[tot].w=w;
e[tot].next=hd[u];
hd[u]=tot;
e[++tot].to=u;
e[tot].w=0;
e[tot].next=hd[v];
hd[v]=tot;
}
bool bfs(bool flag){
	memset(dis,0,sizeof(dis));
	dis[s]=1;
	queue<int>Q;
	Q.push(s);
	while(!Q.empty())
	{
		int u=Q.front();
		Q.pop();
		road[u]=hd[u];
		for(int i=hd[u];i;i=e[i].next)
		{
			int v=e[i].to;
			if(!dis[v]&&e[i].w) 
			{
			dis[v]=dis[u]+1;
			Q.push(v);	
			}
			
		}
	}
	return dis[t]!=0; 
}
int dinic(int now,int res){
	if(now==t)
	return res;
	int tp=res;
	for(int i=road[now];i;i=e[i].next)
	{
		int v=e[i].to;road[now]=i;
		if(dis[v]==dis[now]+1&&e[i].w)
		{
			int k=min(e[i].w,tp);
			int del=dinic(v,k);
			e[i].w-=del;
			e[i^1].w+=del;
			tp-=del;
			if(!tp)
			break;
		}
	}
	return res-tp;
}
int a[maxn],n,m,d[1001][1001],pos[1001][1001],cnt,sum;
map<int,int> vis;
map<int,int> type;
int main(){
ios::sync_with_stdio(0);
cin.tie(0);
cout.tie(0);
cin>>n>>m;
s=++cnt;
t=++cnt;
for(int i=1;i<=n;i++){
	cin>>a[i];
	if(vis[a[i]]==false){
		vis[a[i]]=true;
		type[a[i]]=++cnt;
		add(type[a[i]],t,m*a[i]*a[i]);
	}
}
for(int i=1;i<=n;i++){
	for(int j=i;j<=n;j++){
		cin>>d[i][j];
		pos[i][j]=++cnt;
	}
}
for(int i=1;i<=n;i++){
	for(int j=i;j<=n;j++){
		if(d[i][j]>=0) sum+=d[i][j],add(s,pos[i][j],d[i][j]);
		else add(pos[i][j],t,-d[i][j]);
		if(i!=j){
			add(pos[i][j],pos[i+1][j],inf);
			add(pos[i][j],pos[i][j-1],inf);
		}
	}
}
for(int i=1;i<=n;i++){
	add(pos[i][i],type[a[i]],inf);
	add(pos[i][i],t,a[i]);
}
while(bfs(true)==true) maxflow+=dinic(s,inf);
cout<<sum-maxflow;
return 0;
}
```




---

## 作者：_ZSR_ (赞：0)

### [[六省联考 2017] 寿司餐厅](https://www.luogu.com.cn/problem/P3749)

题目要求求出最大值，然而给出的信息很多，对答案有贡献的因素也很多。那么这个时候我们似乎无法想到有什么好的办法直接计算，即使枚举也是很麻烦的。

考虑到最大值的问题可以用网络流来求解，那不妨往这方面想想看。网络流难就难在建图，建图想清楚了就可以做出来了。首先想以什么为点？第一反应是以寿司为点，但是这样的话好像不太好连边，因为两个寿司之间似乎没有什么很强的关系。想到强关联性，我们发现，题目中给出的 $d$ 数组似乎有比较强的关联性。具体来说，如果选择了 $d_{i,j}$，那么一定要选择 $d_{i+1,j}$ 和 $d_{i,j-1}$。想到这里，我们不妨令 $d$ 数组为点，那么我们就要选择一些点。因为上述关系，我们选择了一个点之后，必须选择另外几个点。这和最大权闭合子图十分相似。而且答案也是求最大值，那是不是就是最大权闭合子图呢？

具体做法：对于每一个 $d_{i,j}$，都由它向 $d_{i+1,j}$ 和 $d_{i,j-1}$ 连边，最后跑一遍最大权闭合子图就可以求出美味度的最大值。但是题目中要求我们减去费用后最大，那费用怎么在图中体现呢？

对于式子中的 $cx$，我们可以拆开来看。具体来说，我们每选一个编号为 $x$ 的寿司，我们就减去一个 $x$ 的费用。为了方便，我们直接将 $a_i$ 在 $d_{i,i}$ 中减去。然后对于 $m x^2$，我们将每个编号也建成一个点，从每个编号对应的点向汇点连 $x^2$ 的边。至此建图就完成了。

code
```
#include <bits/stdc++.h>
using namespace std;
const int N=6060,M=32300,INF=1e9;
int n,m,maxa,cnt,tot,S,T;
int a[N];
int delicious[110][110],id[110][110];
int h[N],to[M],f[M],nxt[M],idx=1;
int d[N],cur[N];
inline void add(int a,int b,int c)
{
    to[++idx]=b,f[idx]=c,nxt[idx]=h[a],h[a]=idx;
    to[++idx]=a,f[idx]=0,nxt[idx]=h[b],h[b]=idx;
}
inline bool bfs()
{
    memset(d,-1,sizeof d);
    queue<int> q;
    q.push(S);
    d[S]=1,cur[S]=h[S];
    while (q.size())
    {
        int x=q.front();
        q.pop();
        for (int i=h[x];i;i=nxt[i])
        {
            int y=to[i];
            if (d[y]==-1&&f[i])
            {
                d[y]=d[x]+1;
                cur[y]=h[y];
                if (y==T) return true;
                q.push(y);
            }
        }
    }
    return false;
}
int find(int u,int limit)
{
    if (u==T) return limit;
    int flow=0;
    for (int i=cur[u];i&&flow<limit;i=nxt[i])
    {
        int j=to[i];
        cur[u]=i;
        if (d[j]==d[u]+1&&f[i])
        {
            int t=find(j,min(f[i],limit-flow));
            if (!t) d[j]=-1;
            f[i]-=t,f[i^1]+=t,flow+=t;
        }
    }
    return flow;
}
inline int dinic()
{
    int res=0,flow;
    while (bfs()) while (flow=find(S,INF)) res+=flow;
    return res;
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("sushi.in","r",stdin);
    freopen("sushi.out","w",stdout);
#endif
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;++i) scanf("%d",&a[i]),maxa=max(maxa,a[i]);//记录编号的最大值
    S=0,T=1;
    cnt=1;
    for (int i=1;i<=n;++i)
    {
        for (int j=i;j<=n;++j)
        {
            scanf("%d",&delicious[i][j]);
            id[i][j]=++cnt;//编号
        }
    }
    for (int i=1;i<=n;++i)
    {
        for (int j=i;j<=n;++j)
        {
            int cost=delicious[i][j];
            if (i==j)
            {
                if (m) add(id[i][j],cnt+a[i],INF);
                cost-=a[i];
            }
            else
            {
                add(id[i][j],id[i+1][j],INF);
                add(id[i][j],id[i][j-1],INF);
            }
            if (cost>0) add(S,id[i][j],cost),tot+=cost;
            else if (cost<0) add(id[i][j],T,-cost);
        }
    }
    if (m) for (int i=1;i<=maxa;++i) add(++cnt,T,i*i);
    printf("%d\n",tot-dinic());
    return 0;
}
```


---

## 作者：Skyjoy (赞：0)

**又是一道最大权闭合图**

# 初期想法

本题的权值 $d_{i,j}$ 只能取一次，还要带上 $d_{i+1,j}$ 和 $d_{i,j-1}$ ，这其实很明显就是一个最大权闭合图上的最大流问题。

那如何建模呢？

# 建模思路

- 这道题的精髓在于联系了钱和编号

- 相互约束的点要连边，也就是 $d_{i,j}$ 与 $d_{i+1,j}$ 与 $d_{i,j-1}$ 连边，边权为 $inf$ ，而 $d_{i,i}$ 则需要连上 $n^2+a_i$ ，边权也是 $inf$ 。

- 最后补上从 $n^2+i$ 连到汇点 $T$ 的边，边权为$mi^2$

- 然后把点权为正的点连向源点 $S$ ，边权为自身点权，点权非正的连向汇点 $T$ ，边权为自身相反数。用正点权的和减去最大流就是答案了

# 代码讲解

我们用一个映射来表示 $d_{i,j}$ 的编号，然后建图即可，代码：

```cpp
#include<bits/stdc++.h>
#define N 40010
#define inf 0x3f3f3f3f
using namespace std;
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-'){
			f=-1;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return x*f;
}
int s=23323,t=23333,n,m,a[N],dis[N],head[N],ans,d,cnt=1;
struct edge{
	int to,next,val;
}e[N<<1]; 
int calc(int i,int j){//映射
	return (i-1)*n+j;
}
void add(int u,int v,int w){
	e[++cnt].to=v,e[cnt].next=head[u],e[cnt].val=w,head[u]=cnt;
	e[++cnt].to=u,e[cnt].next=head[v],e[cnt].val=0,head[v]=cnt;
}
int bfs(){
	memset(dis,0,sizeof(dis));
	queue<int>q;
	q.push(s);
	dis[s]=1;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=e[i].next){
			int v=e[i].to;
			if(!dis[v]&&e[i].val){
				dis[v]=dis[u]+1;
				q.push(v);
			}
		}
	}
	return dis[t];
}
int dfs(int u,int cur){
	if(u==t||!cur){
		return cur;
	}
	int sum=0,tmp;
	for(int i=head[u];i;i=e[i].next){
		int v=e[i].to;
		if(dis[v]==dis[u]+1&&e[i].val){
			sum+=(tmp=dfs(v,min(cur-sum,e[i].val)));
			e[i].val-=tmp,e[i^1].val+=tmp;
		}
	}
	if(!sum){
		dis[u]=-1;
	}
	return sum;
}
int Dinic(){
	int maxflow=0;
	while(bfs()){
		maxflow+=dfs(s,inf);
	}
	return maxflow;
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			d=read();
			if(i==j){
				d-=a[i];
				add(calc(i,j),n*n+a[i],inf);
			}
			else{
				add(calc(i,j),calc(i+1,j),inf),add(calc(i,j),calc(i,j-1),inf);
			}
			if(d>0){//正权
				add(s,calc(i,j),d);
				ans+=d;
			}
			else{//负权
				add(calc(i,j),t,-d);
			}
		}
	}
	for(int i=1;i<=1000;i++){
		add(n*n+i,t,m*i*i);//补上
	}
	printf("%d",ans-Dinic());
	return 0;
}
```

# 总结

网络流关键在于建模，对此，我们要多加练习找感觉，希望大家都会有进步的！

# 联赛快来了，祝大家取得自己理想的成绩！

---

## 作者：zzw4257 (赞：0)

### 题意

>给定每个寿司类型$a_i$,选$[l,r]$号的收益(每个子区间$[x,y]|x\geqslant l\vee r\leqslant r$会因为父区间被选取而会且仅会得到一次收益),设吃了$c_x$个种类的$x$类型寿司，则会付出$\displaystyle \sum_{x}mx^2+c_xx(m\in\{0,1\})$代价

### Solution

首先会想到转最大收益为最小割，

但是不要因为区间类收益/次数唯一就当成关键点集收益而使用集合划分模型，因为那样边会炸(而且那样第二问转不了)

一次收益就只对区间建一个虚点与$T$连，取完子区间可以当成一种迭代关系选$[l,r]$就必须选$[l+1,r]$和$[l,r-1]$

因此使用最大权闭合子图

最后代价可以对每一个类型建虚点与$T$连费用为$mx^2$(只要没割就至少存在一个),$cx$直接分配到每个数自己选取上,就用$[i,i]$向独立的表示$i$的虚点连$a_i$即可.因此我们发现实际上就算费用形如$ax^2+bx$也不一定要用流量分配模型转一次函数的线性和

---

## 作者：⚡114514_zzm⚡ (赞：0)

考虑每个区间建一个收益点向区间内的寿司连边，然后对每个代号新建一个点权为 -mx^2的点，每种寿司寿司连向代号点，这样就是求最大权闭合子图了。但是这样边数是n^3 ，可能过不了。          

考虑优化，区间 [i,j]只需要连向 [i,j−1] 和 [i+1,j] 就可以了，所有区间 [i,i] 的点权为 d[i,i]-a[i] ，这样边数只有 n^2 ，复杂度O(n^4) 。                    

```
#include <bits/stdc++.h>
const int MAXN=1e2+10;
const int MAXV=1e4+10;
const int MAXE=1e6+10;
const int INF=0x7FFFFFFF;
struct Edge{
	int from;
	int to;
	int flow;
	Edge* rev;
	Edge* next;
};
Edge E[MAXE];
Edge* head[MAXV];
Edge* cur[MAXV];
Edge* top=E;
int n;
int m;
int a[MAXN];
bool vis[1010];
int depth[MAXV];
int id[MAXN][MAXN];
int val[MAXN][MAXN];
bool BFS(int,int);
int Dinic(int,int);
int DFS(int,int,int);
void Insert(int,int,int);
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",a+i);
	int s=0,t=1;
	int cnt=1,sum=0;
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			scanf("%d",val[i]+j);
			id[i][j]=++cnt;
			if(i==j)
				val[i][j]-=a[i];
			if(val[i][j]>=0){
				sum+=val[i][j];
				Insert(s,id[i][j],val[i][j]);
			}
			else
				Insert(id[i][j],t,-val[i][j]);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			Insert(id[i][j],id[i+1][j],INF);
			Insert(id[i][j],id[i][j-1],INF);
		}
	}
	for(int i=1;i<=n;i++)
		Insert(id[i][i],cnt+a[i],INF);
	for(int i=1;i<=n;i++){
		if(!vis[a[i]]){
			vis[a[i]]=true;
			Insert(cnt+a[i],t,m*a[i]*a[i]);
		}
	}
	printf("%d\n",sum-Dinic(s,t));
	return 0;
}
int Dinic(int s,int t){
	int ans=0;
	while(BFS(s,t))
	ans+=DFS(s,INF,t);
	return ans;
}
bool BFS(int s,int t){
	memset(depth,0,sizeof(depth));
	std::queue<int> q;
	q.push(s);
	depth[s]=1;
    cur[s]=head[s];
    while(!q.empty()){
        s=q.front();
        q.pop();
        for(Edge* i=head[s];i!=NULL;i=i->next){
            if(i->flow>0&&depth[i->to]==0){
                depth[i->to]=depth[s]+1;
                cur[i->to]=head[i->to];
                if(i->to==t)
                    return true;
                q.push(i->to);
           }
       }
   }
    return false;
}
int DFS(int s,int flow,int t){
    if(s==t||flow<=0)
        return flow;
    int rest=flow;
    for(Edge*& i=cur[s];i!=NULL;i=i->next){
        if(i->flow>0&&depth[i->to]==depth[s]+1){
            int tmp=DFS(i->to,std::min(rest,i->flow),t);
            if(tmp<=0)
                depth[i->to]=0;
            rest-=tmp;
            i->flow-=tmp;
            i->rev->flow+=tmp;
            if(rest<=0)
                break;
       }
   }
    return flow-rest;
}
inline void Insert(int from,int to,int flow){
    top->from=from;
    top->to=to;
    top->flow=flow;
    top->rev=top+1;
    top->next=head[from];
    head[from]=top++;
    top->from=to;
    top->to=from;
    top->flow=0;
    top->rev=top-1;
    top->next=head[to];
    head[to]=top++;
}
```


---


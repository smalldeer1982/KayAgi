# [湖南集训] 更为厉害

## 题目描述

设 $\text T$ 为一棵有根树，我们做如下的定义：

- 设 $a$ 和 $b$ 为 $\text T$ 中的两个不同节点。如果 $a$ 是 $b$ 的祖先，那么称“$a$ 比 $b$ 更为厉害”。
- 设 $a$ 和 $b$ 为 $\text T$ 中的两个不同节点。如果 $a$ 与 $b$ 在树上的距离不超过某个给定常数 $x$，那么称“ $a$ 与 $b$ 彼此彼此”。

给定一棵 $n$ 个节点的有根树 $\text T$，节点的编号为 $1$ 到 $n$，根节点为 $1$ 号节点。
你需要回答 $q$ 个询问，询问给定两个整数 $p$ 和 $k$，问有多少个有序三元组 $(a,b,c)$ 满足：

1. $a,b,c$ 为 $\text T$ 中三个不同的点，且 $a$ 为 $p$ 号节点；
2. $a$ 和 $b$ 都比 $c$ 更为厉害；
3. $a$ 和 $b$ 彼此彼此。这里彼此彼此中的常数为给定的 $k$。


## 说明/提示

样例中的树如下图所示：

 ![](https://cdn.luogu.com.cn/upload/pic/6858.png) 

对于第一个和第三个询问，合法的三元组有 $(2,1,4)$、 $(2,1,5)$ 和 $(2,4,5)$。

对于第二个询问，合法的三元组只有 $(4,2,5)$。


所有测试点的数据规模如下（注意，洛谷并不按照以下方式评测）：

 ![](https://cdn.luogu.com.cn/upload/pic/6859.png) 

对于全部测试数据的所有询问，$1\le p,k \le n$。

- 2023.9.15 添加一组 hack 数据。

## 样例 #1

### 输入

```
5 3
1 2
1 3
2 4
4 5
2 2
4 1
2 3```

### 输出

```
3
1
3```

# 题解

## 作者：GoldenPotato137 (赞：50)

**蒟蒻博客**：[QwQ](https://www.cnblogs.com/GoldenPotato/p/9801317.html)


------------

## Solution

你们搞的这道题啊，exciting！

 .

这题真的很有意思。

首先，我们可以先理解一下题面：固定一个a，找到一个b，c就是a与b的公共子树中的某个点。

那么，我们显然可以把这个b分成两类，第一种是在a上面的，第二种在a下面的。


对于b在a上面的情况，显然，c一定是a的子树中的某个点，答案即$min(K,depth[a])*size[a]$

.

对于b在a下面的情况，问题就会变得比较exciting了。

我们可以考虑使用主席树来搞这个问题。

考虑建一颗这样的主席树，**以节点深度为主席树下标**。

对于一个节点，如果B在这个节点上，那么，它对答案的贡献显然是它的size-1。

那么，我们把它的贡献插入到它对应的主席树中（以深度为下标）。

每一个子节点开一颗主席树，记录到它为止所有的深度的答案和，有点类似前缀和，**以dfs序为时间轴**。

这样，我们可以用一种类似树上差分的办法来“抠”出一颗子树对应的线段数（以深度为下标），**这颗线段数中的[depth[x]+1,depth[x]+K]区间的sum就是这个x点的答案啦**。

 
.

就酱，这题就被我们切掉啦٩(๑>◡<๑)۶


------------
## Code
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const long long N=300000+100;
const long long M=N*30;
struct SegmentTree
{
    #define mid ((now_l+now_r)>>1)
    long long son[M][2],cnt;
    long long sum[M];
    inline void update(long long now)
    {
        sum[now]=sum[son[now][0]]+sum[son[now][1]];
    }
    void Build(long long now,long long now_l,long long now_r)
    {
        if(now_l==now_r) 
            return;    
        Build(son[now][0]=++cnt,now_l,mid);
        Build(son[now][1]=++cnt,mid+1,now_r);
    }
    void Add(long long x,long long num,long long now,long long pre,long long now_l,long long now_r)
    {
        if(now_l==now_r)
        {
            sum[now]=sum[pre];
            sum[now]+=num;
            return ;
        }
        if(x<=mid) son[now][1]=son[pre][1],Add(x,num,son[now][0]=++cnt,son[pre][0],now_l,mid);
        else son[now][0]=son[pre][0],Add(x,num,son[now][1]=++cnt,son[pre][1],mid+1,now_r);
        update(now);
    }
    long long Query(long long L,long long R,long long now,long long pre,long long now_l,long long now_r)
    {
        if(now_l>=L and now_r<=R)
            return sum[now]-sum[pre];
        long long ans=0;
        if(L<=mid) ans+=Query(L,R,son[now][0],son[pre][0],now_l,mid);
        if(R>mid) ans+=Query(L,R,son[now][1],son[pre][1],mid+1,now_r);
        return ans;
    }
    void Print(long long now,long long now_l,long long now_r)
    {
        cerr<<"no."<<now<<" now_l&r:"<<now_l<<" "<<now_r<<" sonl&r"<<son[now][0]<<" "<<son[now][1]<<" sum:"<<sum[now]<<endl;
        if(now_l!=now_r)
        {
            Print(son[now][0],now_l,mid);
            Print(son[now][1],mid+1,now_r);    
        }
    }    
    #undef mid
}sgt;
vector <long long> e[N];
long long n,m,depth[N],size[N],dfn[N],dfn_to,r[N];
void dfs2(long long now)
{
    dfn[now]=++dfn_to;
    size[now]=1;
    for(long long i=0;i<(long long)(e[now].size());i++)
        if(depth[e[now][i]]==0)    
        {
            depth[e[now][i]]=depth[now]+1;
            dfs2(e[now][i]);
            size[now]+=size[e[now][i]];    
        }
}
void dfs(long long now)
{
    r[dfn[now]]=++sgt.cnt;
    sgt.Add(depth[now],size[now]-1,r[dfn[now]],r[dfn[now]-1],1,n);
    //sgt.Print(r[dfn[now]],1,n);
    //cerr<<endl;
    for(long long i=0;i<(long long)(e[now].size());i++)
        if(depth[e[now][i]]>depth[now])
            dfs(e[now][i]);
}
int main()
{
    n=read(),m=read();
    for(long long i=1;i<=n;i++)
        e[i].reserve(4);
    for(long long i=1;i<n;i++)
    {
        long long s=read(),t=read();
        e[s].push_back(t);
        e[t].push_back(s);    
    }
    
    sgt.Build(0,1,n);
    //sgt.Print(0,1,n);
    //cerr<<endl;
    depth[1]=1;
    dfs2(1);
    dfs(1);
    
    for(long long i=1;i<=m;i++)
    {
        long long p=read(),K=read();
        long long ans=sgt.Query(depth[p]+1,depth[p]+K,r[dfn[p]+size[p]-1],r[dfn[p]-1],1,n);
        ans+=min(K,depth[p]-1)*(size[p]-1);
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：xtx1092515503 (赞：41)

这道题看到大家都用主席树或者权值线段树等等，其实完全没有必要呀orz

只要稍微想想就能发现，它其实可以转变为一个简单的**二维数点问题**。

设$dep_i$为$i$节点的深度（根节点深度为$0$），$sz_i$为$i$节点子树大小

对于询问$(p,k)$,我们将$(a,b,c)$这一三元组分为两种情况：

1)**$b$是$a$的父亲**。显然，这时$c$可以是$a$子树内任何一个节点。

此时答案为$(sz_p-1)\times min(dep_p,k)$，因为有$min(dep_p,k)$个合法的$b$是$a$的父亲

2)**$b$是$a$的儿子**。显然，只有$dep_b\in [dep_a+1,dep_a+k]$时，这才是一个合法的$b$。

而对每个$b$，它能贡献$sz_b-1$个答案。

而如何判断每个$b$是否在$a$的子树内呢？

**dfs序**

设$rev_i$表示$i$节点在dfs序中，在第$rev_i$次时被访问到

则$[rev_i,rev_i+sz_i-1]$为节点$i$的子树编号。

那么，对于节点$a$，所有满足$dep_b\in [dep_a+1,dep_a+k]$且$rev_b\in[rev_a+1,rev_a+sz_a-1]$的$b$均为合法的$b$。

想到了什么？

如果我们以$rev$作为$x$轴，$dep$作为$y$轴，建立平面直角坐标系，则每个节点i可以被抽象成一个点$(rev_i,dep_i)$，并且有$sz_i-1$的权值。

而每次询问，就可以被抽象成一个矩形，查询的是矩形内部所有点的权值和。

并且，这道题**可以离线**。

然后，就可以愉快地用**树状数组**进行**二维数点**了。

复杂度$O(nlog_2n)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,head[300100],cnt,dep[300100],rev[300100],tot,sz[300100],res[300100],BIT[300100];
struct Edge{
	int to,next;
}edge[600100];
int ae(int u,int v){
	edge[cnt].to=v,edge[cnt].next=head[u],head[u]=cnt++;
}
void dfs(int x,int fa){
	rev[x]=++tot,sz[x]=1;
	for(int i=head[x];i!=-1;i=edge[i].next)if(edge[i].to!=fa)dep[edge[i].to]=dep[x]+1,dfs(edge[i].to,x),sz[x]+=sz[edge[i].to];
}
struct Point{
	int u,v,w;
	Point(int a=0,int b=0,int c=0){
		u=a,v=b,w=c;
	}
	friend bool operator <(const Point &x,const Point &y){
		return x.v<y.v;
	}
}p[300100];
struct Query{
	int x1,x2,y,id;
	Query(int a=0,int b=0,int c=0,int d=0){
		x1=a,x2=b,y=c,id=d;
	}
	friend bool operator <(const Query &x,const Query &y){
		return x.y<y.y;
	}
}q[600100];
int lowbit(int x){
	return x&-x;
}
void add(int x,int val){
	while(x<=n)BIT[x]+=val,x+=lowbit(x);
}
int ask(int x){
	int sum=0;
	while(x)sum+=BIT[x],x-=lowbit(x);
	return sum;
}
signed main(){
	scanf("%lld%lld",&n,&m),memset(head,-1,sizeof(head));
	for(int i=1,x,y;i<n;i++)scanf("%lld%lld",&x,&y),ae(x,y),ae(y,x);
	dfs(1,0);
	for(int i=1;i<=n;i++)p[i]=Point(rev[i],dep[i],sz[i]-1);
	for(int i=1,x,y;i<=m;i++){
		scanf("%lld%lld",&x,&y);
		res[i]+=(sz[x]-1)*min(dep[x],y);
		q[(i<<1)-1]=Query(rev[x],rev[x]+sz[x]-1,dep[x],-i);
		q[(i<<1)]=Query(rev[x],rev[x]+sz[x]-1,dep[x]+y,i);
	}
	sort(p+1,p+n+1);
	sort(q+1,q+(m*2)+1);
	for(int i=1,j=1;i<=(m*2);i++){
		while(j<=n&&p[j].v<=q[i].y)add(p[j].u,p[j].w),j++;
		if(q[i].id>0)res[q[i].id]+=ask(q[i].x2)-ask(q[i].x1);
		else res[q[i].id]-=ask(q[i].x2)-ask(q[i].x1);
	}
	for(int i=1;i<=m;i++)printf("%lld\n",res[i]);
	return 0;
} 
```


---

## 作者：Mr_Wu (赞：36)

好像没人写长链剖分的，那作为初学者就来写一下。。

### 题解

首先当 $b$ 比 $a$ 不知道高到哪里去时，这件事就很 simple。

但当 $a$ 比 $b$ 不知道高到哪里去时，这件事就很 exciting 了。

设 $f_{u,k}=\sum\limits_{v\in T(u)-\{u\}} [\text{dis}(u,v)\le k](siz_v-1)$ 表示对于所有 $v$ 满足 $u$ 比 $v$ 不知道高到哪里去，且 $v$ 与 $u$ 谈笑风生时的答案。

容易发现

$$ f_{u,k}=\sum_{v\in \text{son}(u)} f_{v,k-1}+siz_v-1 $$

然后考虑长链剖分，也就是说，当节点 $u$ 要从 $\text{wson}_u$ 转移时直接将数组拷贝过去，其它情况暴力。这个复杂度的证明是因为

$$ \sum_u \left( \sum_{v\in \text{son}(u)} \text{maxdep}_v - \text{maxdep}_{\text{wson}_u} \right)=\sum_u \left( \sum_{v\in \text{son}(u)} \text{maxdep}_v - (\text{maxdep}_u-1) \right)=n $$

但现在我们不能直接把数组拷贝过去，因为我们加上了一个常量。打懒惰标记即可，并将 $f_{u,0}$ 减去懒惰标记以撤销。

时间复杂度 $\Theta(n)$。

### 代码

```cpp
#include <cstdio>

typedef long long ll;
inline ll max(ll a, ll b) { return a > b ? a : b; }
inline ll min(ll a, ll b) { return a < b ? a : b; }

const int MAXN = 300005;

int N, T; ll ans[MAXN];
struct node { int v, next; } E[MAXN << 1]; int head[MAXN], Elen;
struct query { int u, k; } q[MAXN];
struct vec { int v, next, id; } Q[MAXN]; int headQ[MAXN], Qlen;
void add(int u, int v) { ++Elen, E[Elen].v = v, E[Elen].next = head[u], head[u] = Elen; }
void addQ(int u, int v, int id) { ++Qlen, Q[Qlen].v = v, Q[Qlen].next = headQ[u], Q[Qlen].id = id, headQ[u] = Qlen; }

int fa[MAXN], dep[MAXN], siz[MAXN], maxdep[MAXN], wson[MAXN], top[MAXN];
void dfs1(int u, int ff) {
    fa[u] = ff, dep[u] = dep[ff] + 1, siz[u] = 1;
    for (int i = head[u]; i; i = E[i].next) if (E[i].v != ff) {
        dfs1(E[i].v, u), siz[u] += siz[E[i].v];
        if (maxdep[E[i].v] > maxdep[wson[u]]) wson[u] = E[i].v;
    } maxdep[u] = maxdep[wson[u]] + 1;
}
void dfs2(int u, int ff, int tp) {
    top[u] = tp; if (wson[u]) dfs2(wson[u], u, tp);
    for (int i = head[u]; i; i = E[i].next) if (E[i].v != ff && E[i].v != wson[u]) dfs2(E[i].v, u, E[i].v);
}
ll *dp[MAXN], tag[MAXN], buc[MAXN << 2], *id = buc;
void dfs(int u, int ff) {
    if (wson[u]) {
        dp[wson[u]] = dp[u] + 1, dfs(wson[u], u);
        dp[u][0] = 0, tag[u] = tag[wson[u]] + siz[wson[u]] - 1;
    }
    for (int i = head[u]; i; i = E[i].next) if (E[i].v != ff && E[i].v != wson[u]) {
        dp[E[i].v] = id, id += maxdep[E[i].v], dfs(E[i].v, u), tag[u] += tag[E[i].v] + siz[E[i].v] - 1;
        for (int j = 1; j <= maxdep[E[i].v]; ++j) dp[u][j] += dp[E[i].v][j - 1];
    } dp[u][0] = -tag[u];
    for (int i = headQ[u]; i; i = Q[i].next) ans[Q[i].id] = dp[u][min(q[Q[i].id].k, maxdep[u] - 1)] + tag[u];
}

int main() {
    scanf("%d%d", &N, &T); int i, u, v;
    for (i = 1; i < N; ++i) scanf("%d%d", &u, &v), add(u, v), add(v, u);
    for (i = 1; i <= T; ++i) scanf("%d%d", &q[i].u, &q[i].k), addQ(q[i].u, q[i].k, i);
    dfs1(1, 0), dfs2(1, 0, 1);
    dp[1] = id, id += maxdep[1], dfs(1, 0);
    for (i = 1; i <= T; ++i) printf("%lld\n", ans[i] + (ll)min(dep[q[i].u] - 1, q[i].k) * (siz[q[i].u] - 1));
    return 0;
}
```

---

## 作者：Cgod (赞：20)

## 一些闲话
这题方法好多啊QAQ，离线有BIT、长链剖分，在线有线段树合并，主席树等。
要我出题绝对不可能放离线过。。。

# [无耻地挂上自己blog的链接](https://www.cnblogs.com/cx233666/p/9721869.html)
## 题意简述
简单的看一下题意，就是给定$a$，求任何一个距$a$距离不超过给定的$k$的$b$，然后求一个$c$使得是$a,b$的后代。
## sol
我相信你已经看出来了，$abc$在一条直上直下的链上，不过这并没有什么用。我们考虑当$b$是$a$的祖先时，$a$子树内所有除它自己以外的点都可以做$c$这个可以直接统计。当$a$是$b$的祖先时，$b$子树内所有除它以外的点都可以做$c$。那么每个节点搞一个权值线段树维护一下就可以辣。然后显然这个空间复杂度会爆炸，于是就可以愉快的线段树合并辣。
```
#include<vector>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define gt getchar()
#define ll long long
#define File(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
inline int in()
{
    int k=0;char ch=gt;
    while(ch<'-')ch=gt;
    while(ch>'-')k=k*10+ch-'0',ch=gt;
    return k;
}
const int N=600005;
std::vector<int>Q[N],id[N];
using std::min;
using std::max;
struct node
{
    ll siz;int lc,rc;
}t[N*30];
int tot,opt;
ll query(int L,int R,int l,int r,int x)
{
    if(!x)return 0;
    if(L<=l&&r<=R)return t[x].siz;
    int mid=l+r>>1;ll res=0;
    if(mid>=L)res+=query(L,R,l, mid ,t[x].lc);
    if(mid< R)res+=query(L,R,mid+1,r,t[x].rc);
    return res;
}
void upd(int l,int r,int pos,int &x,int v)
{
    if(!x)x=++tot;t[x].siz+=v;
    if(l==r)return;
    int mid=l+r>>1;
    if(mid>=pos)upd(l,mid,pos,t[x].lc,v);
    else upd(mid+1,r,pos,t[x].rc,v);
}
int merge(int u,int v,int l,int r)
{
    if(!u||!v)return u|v;
    int mid=l+r>>1,x=++tot;
    t[x].siz=t[u].siz+t[v].siz;
    t[x].lc=merge(t[u].lc,t[v].lc,l, mid );
    t[x].rc=merge(t[u].rc,t[v].rc,mid+1,r);
    return x;
}
int siz[N],rt[N],a[N],b[N],fa[N],head[N],to[N],nxt[N],cnt,sz,dep[N];
ll ans[N];
inline void add(int u,int v)
{
    to[++cnt]=v,nxt[cnt]=head[u],head[u]=cnt;
    to[++cnt]=u,nxt[cnt]=head[v],head[v]=cnt;
}
void dfs(int u,int pa=0)
{
    dep[u]=dep[pa]+1;siz[u]=1;//printf("u=%d pa=%d\n",u,pa);
    for(int i=head[u];i;i=nxt[i])
        if(to[i]!=pa)
            dfs(to[i],u),siz[u]+=siz[to[i]];
    upd(1,sz,dep[u],rt[u],siz[u]-1);
    if(pa)rt[pa]=merge(rt[pa],rt[u],1,sz);
}
int main()
{
    int n=in(),q=in();sz=n;
    for(int i=1;i<n;++i)add(in(),in());
    dfs(1);
    for(int i=1;i<=q;++i)
    {
        int x=in(),y=in();
        printf("%lld\n",query(dep[x]+1,dep[x]+y,1,n,rt[x])+1ll*(siz[x]-1)*min(dep[x]-1,y));
    }
    return 0;
}
```

---

## 作者：从蒟蒻到小犇 (赞：18)

# 线段树合并只打12分可太难了TvT
看来好多红名巨佬都跟我一样是从12分改过来的，其实是因为合并u点的线段树的时候把儿子的线段树信息给改了，那本蒟蒻就主要说说动态开点线段树的深度理解。
## sol
首先看如果b和a没有祖先后代关系，a和b肯定不能同时是c的祖先，不成立；

如果b是a的祖先，方案数就是$\min(K,depth[a]-1)*(size[a]-1)$;

如果b是a的后代，方案数就是深度在depth[a]+1到depth[a]+K之间每个b的(size[b]-1)之和，那么可以用线段树合并来做，线段树下标表示深度，记区间的(size-1)之和，求线段树在(depth[a]+1,depth[a]+K)的区间和。

但是merge函数如果这么写的话（没新开节点，直接更新x的信息）就会获得12分的好成绩TvT：
```cpp
int merge(int x,int y,int tl,int tr) {
	if(x==0||y==0) return x|y;//有空节点。
	if(tl==tr) {
		tree[x].num=tree[x].num+tree[y].num;
		return x;
	}![](lf[wpepwkf)
	int mid=(tl+tr)/2;
	tree[x].ls=merge(tree[x].ls,tree[y].ls,tl,mid);
	tree[x].rs=merge(tree[x].rs,tree[y].rs,mid+1,tr);
	up(x);//上传维护值。
	return x;
}
```

只有新开了线段树节点才能A：
```cpp
int merge(int x,int y,int tl,int tr) {
	if(x==0||y==0) return x|y;//有空节点。
	
	if(tl==tr) {
		int now=++tot;
		tree[now].num=tree[x].num+tree[y].num;
		return now;
	}
	int mid=(tl+tr)/2,now=++tot;//为了不改变儿子线段树的值，必须新建节点。
	tree[now].ls=merge(tree[x].ls,tree[y].ls,tl,mid);
	tree[now].rs=merge(tree[x].rs,tree[y].rs,mid+1,tr);
	up(now);
	return now;
}
```
所以本篇题解详细讲一下产生这种情况的原因。

## 线段树合并
![iakioi](http://m.qpic.cn/psb?/V11W0lxB1YaNik/i*OeVAlltmRdTdns2Bpgav1a0UN2BNxK*xomME69ATk!/b/dDYBAAAAAAAA&bo=wAMcAgAAAAADB*8!&rf=viewer_4&t=5)
要合并x和y两颗线段树，如果直接合并的话，x上的1号点右儿子直接赋成y上的2号点了，这样的话，x再和另一颗线段树合并，有可能改变2号点以及2号点子树的信息，y的信息就被乱改了。ovo

如果每次要合并的时候都给x新开一个节点，y的信息就不会被乱改了，每个点合并之后儿子的信息还是准确的。$*v*$

但是x线段树递归到某个空子树的时候，还是要把y上对应的子树拿过来，这可以相当于是打标记，暂时用了y的子树。正经合并的时候肯定是不能改变y的信息了。

这样就能A掉这道题了……
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mv=3e5,ml=19;

int n,q;
struct node{
	int ls,rs;
	long long num;//每个点的siz-1之和。
}tree[2*mv*ml+3];int tot=0;
inline void up(int x) {
	tree[x].num=tree[tree[x].ls].num+tree[tree[x].rs].num;
}
void add(int x,int tl,int tr,int w,int ad) {
	if(tl==tr) {
		tree[x].num+=ad;
		return;
	}
	
	int mid=(tl+tr)/2;
	if(w<=mid) {
		if(!tree[x].ls) tree[x].ls=++tot;
		add(tree[x].ls,tl,mid,w,ad);
	}
	if(w>mid) {
		if(!tree[x].rs) tree[x].rs=++tot;
		add(tree[x].rs,mid+1,tr,w,ad);
	}
	up(x);
}
long long askS(int x,int tl,int tr,int l,int r) {
	if(!x) return 0;
	if(tl==l&&r==tr) return tree[x].num;
	
	int mid=(tl+tr)/2;long long ans=0;
	//没建出来的地方值肯定为0，不用递归。
	if(l<=mid&&tree[x].ls) 
		ans+=askS(tree[x].ls,tl,mid,l,min(mid,r));
	if(r>mid&&tree[x].rs) 
		ans+=askS(tree[x].rs,mid+1,tr,max(l,mid+1),r);
	return ans;
}
int merge(int x,int y,int tl,int tr) {
	if(x==0||y==0) return x|y;//有空的则返回非空的。
	
	if(tl==tr) {
		int now=++tot;
		tree[now].num=tree[x].num+tree[y].num;
		return now;
	}
	int mid=(tl+tr)/2,now=++tot;//为了不改变儿子线段树的值，必须新建节点。
	tree[now].ls=merge(tree[x].ls,tree[y].ls,tl,mid);
	tree[now].rs=merge(tree[x].rs,tree[y].rs,mid+1,tr);
	up(now);
	return now;
}

vector<int>po[mv+3];
int fa[mv+3],h[mv+3],siz[mv+3],rtw[mv+3];
//父亲、深度、子树大小、该点对应线段树树根的编号。
void dfs(int u) {
	siz[u]=1;
	for(int j=0;j<(int)po[u].size();j++) {
		int v=po[u][j];
		if(fa[u]==v) continue;
		
		fa[v]=u;
		h[v]=h[u]+1;
		dfs(v);
		siz[u]+=siz[v];
	}
	
	rtw[u]=++tot;
	add(rtw[u],1,n,h[u],siz[u]-1);//在线段树深度为h处加答案。
	for(int j=0;j<(int)po[u].size();j++) {
		int v=po[u][j];
		if(fa[u]==v) continue;
		
		rtw[u]=merge(rtw[u],rtw[v],1,n);//合并。
	}
}

int main() {
	cin>>n>>q;
	int u,v;
	for(int e=1;e<n;e++) {
		scanf("%d%d",&u,&v);
		po[u].push_back(v);
		po[v].push_back(u);
	}
	h[1]=1;//深度从1开始记。
	dfs(1);
	
	int K;
	for(int z=1;z<=q;z++) {
		scanf("%d%d",&u,&K);
		long long ans=1ll*min(h[u]-1,K)*(siz[u]-1);//上方谈笑风生。
		ans+=askS(rtw[u],1,n,h[u]+1,h[u]+K);//下方谈笑风生。
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：b2019dy (赞：13)

为这道题提供一个神奇的做法，复杂度O(nlognlogn)  
我们考虑b点的情况  
首先考虑b是a的祖先则有$min(deep[a],k)*size[a-1]$种情况  
考虑b是a的儿子，则情况总数是离a的距离小于等于k的子节点size-1的和，直接求比较麻烦，考虑用总的size和减去距离大于k的  
基于树bfs序的性质，同一深度的点都是连续区间，且一个点所有深度相同的子节点编号也都是连续区间我们考虑来维护这一段的和  
我们考虑二分寻找这个树这一深度的点在整个区间内的起始与终点，check时将中间点找到，然后跳到与当前询问点深度相同的祖先，如果重合，就记录并根据情况调整l与r，否则如果跳到的点bfs序小于询问点bfs序，就收缩至右区间，大于则收缩至右区间  
```cpp
#include<iostream>
#include<iomanip>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<queue>
#include<algorithm>
using namespace std;
int n,q,f[300005][21],h[300005],deep[300005],cnt,seg[300005],rev[300005],qs[300005],head,tail,size[300005],ls[300005],rs[300005],sign,maxdeep;
long long tree[300005],ans,sums[300005],sums2[300005];
bool vis[300005];
struct Edge
{
	int to,next;
}w[600005];
void dfs(int x,int fa)
{
	f[x][0]=fa;
	deep[x]=deep[fa]+1;
	maxdeep=max(maxdeep,deep[x]);
	size[x]=1;
	for(int i=h[x];i;i=w[i].next)
	{
		int to=w[i].to;
		if(to==fa) continue;
		dfs(to,x);
		size[x]+=size[to];
		sums[x]+=sums[to];
	}
	sums[x]+=size[x]-1;
}
void bfs(int x)
{
	qs[++tail]=x;
	head=1;
	vis[x]=1;
	ls[1]=1,rs[1]=1;
	seg[x]=++sign;
	rev[sign]=x;
	while(head<=tail)
	{
		int u=qs[head++];
		for(int i=h[u];i;i=w[i].next)
		{
			int to=w[i].to;
			if(vis[to]) continue;
			vis[to]=1;
			qs[++tail]=to;
			seg[to]=++sign;
			rev[sign]=to;
			ls[deep[to]]=min(ls[deep[to]],sign);
			rs[deep[to]]=max(rs[deep[to]],sign);
		}
	}
}
void pre()
{
	for(int j=1;(1<<j)<=n;j++)
	for(int i=1;i<=n;i++)
	if(f[i][j-1]!=-1) f[i][j]=f[f[i][j-1]][j-1];
}
int main()
{
	memset(f,-1,sizeof(f));
	memset(ls,0x3f,sizeof(ls));
	scanf("%d%d",&n,&q);
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		w[++cnt]=(Edge){y,h[x]},h[x]=cnt;
		w[++cnt]=(Edge){x,h[y]},h[y]=cnt;
	}
	dfs(1,0);
	bfs(1);
	pre();
	for(int i=1;i<=n;i++) sums2[i]=sums2[i-1]+sums[rev[i]];
	for(int i=1;i<=q;i++)
	{
		ans=0;
		int x,k;
		scanf("%d%d",&x,&k);
		ans+=(long long)min(deep[x]-1,k)*(size[x]-1);
		ans+=sums[x]-(size[x]-1);
		if(deep[x]+k+1<=maxdeep)
		{
			int l=ls[deep[x]+k+1],r=rs[deep[x]+k+1];
			int ans1=n+1,ans2=0;
			while(l<=r)
			{
				int mid=(l+r)>>1;
				int now=rev[mid];
				for(int j=log(deep[now])/log(2);j>=0;j--)
				{
					if(deep[now]-(1<<j)>=deep[x]) now=f[now][j];
				}
				if(now==x) ans1=mid,r=mid-1;
				else
				{
					if(seg[now]<seg[x]) l=mid+1;
					else r=mid-1;
				}
			}
			l=ls[deep[x]+k+1],r=rs[deep[x]+k+1];
			while(l<=r)
			{
				int mid=(l+r)>>1;
				int now=rev[mid];
				for(int j=log(deep[now])/log(2);j>=0;j--)
				{
					if(deep[now]-(1<<j)>=deep[x]) now=f[now][j];
				}
				if(now==x) ans2=mid,l=mid+1;
				else
				{
					if(seg[now]<seg[x]) l=mid+1;
					else r=mid-1;
				}
			}
			if(ans1<=ans2) ans-=sums2[ans2]-sums2[ans1-1];
		}
		printf("%lld\n",ans);
	}
} 
```

---

## 作者：Anoxiacxy (赞：13)

### 主席树+dfs序

把深度看成下标，按dfs序对每个节点建立主席树，我们希望查询一个子树中，深度在deep[p]+1--deep[p]+k的点的权值和，由于在dfn序中，一个子树的编号连续，那么直接查询子树开始和结束的权值差即可，对于在p点以上的答案统计比较简单，直接乘法原理即可，在此不作赘述

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#include <stack>
#include <vector>
#include <cmath>
#define LL long long
#define inf 1e9
#define mod 989381
using namespace std; 
/*struct io{
    char op[1 << 26], *s;
    io{fread(s=op,1,s<<26,stdin);} 
    inline int read(){
        int u = 0;
        while(*s < 48) s++;
        while(*s > 32) u = (u << 1) + (u << 3) + *s++ -48;
        return u;
    }
}ip;
#define read ip.read*/
#ifndef read
inline int read(){
    int u=0;char c=getchar();
    while(!isdigit(c))c=getchar();
    while( isdigit(c))u=u*10+c-'0',c=getchar();
    return u;
}
#endif
int n,m,maxdep=1;
vector<int>G[300300];
int dep[300300],sz[300300],fa[300300];
void dfs1(int k){
    sz[k]=1;
    for(int i=0;i<G[k].size();i++){
        int kk=G[k][i];
        if(dep[kk])continue;
        dep[kk]=dep[k]+1;
        maxdep=max(maxdep,dep[kk]);
        fa[kk]=k;
        dfs1(kk);
        sz[k]+=sz[kk];
    }
}
int sos;
int dfn[300300];
int root[300300];
struct node{
    int ls,rs;
    LL ans;
}T[300300*20];
int coc;
void insert(int &p,int l,int r,LL v,int dp){
    T[++coc]=T[p];p=coc;
    T[p].ans+=v;
    if(l==r)return;
    int mid=l+r>>1;
    if(dp<=mid)insert(T[p].ls,l,mid,v,dp);
    else insert(T[p].rs,mid+1,r,v,dp);
}
LL query(int p1,int p2,int l,int r,int dpl,int dpr){
    if(l==dpl&&r==dpr)return T[p2].ans-T[p1].ans;
    int mid=l+r>>1;
    if(dpr<=mid)return query(T[p1].ls,T[p2].ls,l,mid,dpl,dpr);
    else if(dpl>mid)return query(T[p1].rs,T[p2].rs,mid+1,r,dpl,dpr);
    else return     query(T[p1].ls,T[p2].ls,l,mid,dpl,mid)
                +query(T[p1].rs,T[p2].rs,mid+1,r,mid+1,dpr);
}
void dfs2(int k){
    dfn[k]=++sos;
    root[sos]=root[sos-1];
    insert(root[sos],1,maxdep,(LL)sz[k]-1,dep[k]);
    for(int i=0;i<G[k].size();i++){
        int kk=G[k][i];
        if(fa[k]==kk)continue;
        dfs2(kk);
    }
}
int main(){
    n=read(),m=read();
    for(int i=1;i<n;i++){
        int x=read(),y=read();
        G[x].push_back(y);
        G[y].push_back(x);
    }
    dep[1]=1;dfs1(1);
    dfs2(1);
    for(int i=1;i<=m;i++){
        int p=read(),k=read();
        LL ans=((LL)sz[p]-1)*(min(k,dep[p]-1));
        int l=dfn[p]-1,r=dfn[p]+sz[p]-1;
        if(dep[p]==maxdep){printf("0\n");continue;}
        ans+=query(root[l],root[r],1,maxdep,dep[p]+1,min(maxdep,dep[p]+k));
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：2016jzy (赞：11)

时光不待，他真的老了/叹气

为了感谢这位和蔼老人，

我决定发一波题解/严肃脸

首先我们来分析一下题意，易知我们要求的是对于每个询问，求满足条件的有序三元组（a,b,c)的个数。

由条件1可知，对于每个询问，a为定点，即为p号节点；由条件2可知，a和b都是c的祖先；由条件3可知，a与b的距离小于等于k。

然而对于a和b的血缘关系我们并不知道，所以我们需要分类讨论（划重点

//$P.S:$以下$dep[]$为节点深度，$dfn[]$为时间戳,$siz[]$为以该节点为根的子树大小

当b是a的祖先时需满足：

$$dfn[a]<dfn[c]<dfn[a]+siz[a]$$

$$dep[a]-k≤dep[b]<dep[a]<dep[c]$$

因为a为定点，所以c可以为以a为根的子树中的任意一点，b可以为距离a小于等于k的链上的任意一点（注意树根在链上的情况），所以可得对答案的贡献为$min(dep[p],k)*(siz[p]-1)$

当a是b的祖先时需满足：
$$dfn[a]<dfn[b]<dfn[a]+siz[a]$$
$$dep[a]<dep[b]<dep[a]+k$$
$$dfn[b]<dfn[c]<dfn[b]+siz[b]$$

容易看出这是一个二维偏序问题，故可以用主席树解决。
以$dep[]$为下标，以$dfn[]$为版本，对答案的贡献是每个满足条件的b，其子树大小的总和，最后xjb乱搞一下就做完了$^_^$

```cpp
#include<iostream>
#include<cstdio>
#define ll long long      //注意要开long long
using namespace std;
int n,q,doby;
int root[300001];
struct edge {
	int to,next;
}e[600001];
int head[300001],num;
void add(int a,int b)
{
	e[++num].next=head[a];
	e[num].to=b;
	head[a]=num;
}
ll siz[300001],dep[300001];
int fa[300001],dfn[300001],dot[300001],tot;
void dfs(int u)
{
	siz[u]=1;
	dot[dfn[u]=++tot]=u;
	for(int i=head[u];i;i=e[i].next) {
		int v=e[i].to;
		if(fa[u]==v)continue;
		fa[v]=u;
		dep[v]=dep[u]+1;
		dfs(v);
		siz[u]+=siz[v];
	}
}   //预处理一下各种数组
struct data {
	int l,r;
	ll val;
}t[6000001];
void update(int l,int r,int x,int s,int pre,int &cnt)
{
	cnt=++doby;t[cnt]=t[pre];
	t[cnt].val+=s;
	if(l==r)return;
	int mid=(l+r)>>1;
	if(x<=mid)update(l,mid,x,s,t[pre].l,t[cnt].l);
	else update(mid+1,r,x,s,t[pre].r,t[cnt].r);
}
ll query(int l,int r,int L,int R,int pre,int cnt)
{
	if(r<L||l>R)return 0;
	if(L<=l&&r<=R)return t[cnt].val-t[pre].val;
	int mid=(l+r)>>1;
	ll sum=0;
	if(L<=mid)sum+=query(l,mid,L,R,t[pre].l,t[cnt].l);
	if(mid+1<=R)sum+=query(mid+1,r,L,R,t[pre].r,t[cnt].r);
	return sum;
}   //注意别写成区间单点查询/滑稽
int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1;i<n;i++) {
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);add(v,u);
	}
	dfs(1);
	for(int i=1;i<=n;i++) {
		update(1,n,dep[dot[i]],siz[dot[i]]-1,root[i-1],root[i]);
	}     //我觉得并没有什么需要注释的qwq
	for(int i=1;i<=q;i++) {
		int p;
		ll k;
		scanf("%d%lld",&p,&k);
		printf("%lld\n",min(dep[p],k)*(siz[p]-1)+query(1,n,dep[p]+1,dep[p]+k,root[dfn[p]],root[dfn[p]+siz[p]-1]));
	}   //我依然觉得并没有什么需要注释的qwq
	return 0;
}
```


---

## 作者：Priori_Incantatem (赞：10)

### 题目大意

有一棵 $n$ 个节点的有根树，有 $m$ 组询问  
每次询问给出 $a,k$，求有多少个三元组 $(a,b,c)$，满足 $a,b$ 都是 $c$ 的祖先，并且 $a,b$ 之间的距离不超过 $k$

刚开始没有思路，看了题解的分类讨论后发现可以很轻松地转化为线段树合并

### 解题思路
首先，定义 $d[x]$ 为点 $x$ 的深度（根节点的深度为 $1$）  
$s[x]$ 为点 $x$ 的子树大小（包括 $x$）
考虑两种情况  
1. $b$ 是 $a$ 的祖先：$b$ 就必须在 $a$ 到根的路径上的可能方案数就为 $\min (d[a]-1,k)$
2.  $b$ 在 $a$ 的子树中：方案数就是 $\sum\limits_{d[x] \in [d[a]+1,d[a]+k]} s[x]-1$，注意这里的 $x$ 必须在 $a$ 的子树中。

我们发现可以用线段树合并维护子树信息来实现操作2，最终的答案就是两方案数之和

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const long long Maxn=300000+10,inf=0x3f3f3f3f;
const long long Maxm=6000000+10;
long long d[Maxn],s[Maxn];
long long nxt[Maxn<<1],to[Maxn<<1];
long long sum[Maxm],ls[Maxm],rs[Maxm];
long long root[Maxn],head[Maxn];
long long n,m,idcnt,edgecnt=1;
inline void add(long long x,long long y)
{
	++edgecnt;
	nxt[edgecnt]=head[x];
	to[edgecnt]=y;
	head[x]=edgecnt;
}
inline long long read()
{
	long long s=0,w=1;
	char ch=getchar();
	while(ch<'0' || ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
inline void push_up(long long x)
{
	sum[x]=sum[ls[x]]+sum[rs[x]];
}
void modify(long long &x,long long l,long long r,long long pos,long long v)
{
	if(!x)x=++idcnt;
	if(l==r)
	{
		sum[x]+=v;
		return;
	}
	long long mid=(l+r)>>1;
	if(pos<=mid)modify(ls[x],l,mid,pos,v);
	else modify(rs[x],mid+1,r,pos,v);
	push_up(x);
}
long long merge(long long x,long long y)
{
	if(!x || !y)return x|y;
	long long cur=++idcnt;
	sum[cur]=sum[x]+sum[y];
	ls[cur]=merge(ls[x],ls[y]);
	rs[cur]=merge(rs[x],rs[y]);
	return cur;
}
long long query(long long k,long long l,long long r,long long x,long long y)
{
	if(x<=l && r<=y)return sum[k];
	long long mid=(l+r)>>1,ret=0;
	if(x<=mid)ret=query(ls[k],l,mid,x,y);
	if(mid<y)ret+=query(rs[k],mid+1,r,x,y);
	return ret;
}
void dfs(long long x,long long fa)
{
	d[x]=d[fa]+1,s[x]=1;
	for(long long i=head[x];i;i=nxt[i])
	{
		long long y=to[i];
		if(y==fa)continue;
		dfs(y,x),s[x]+=s[y];
		root[x]=merge(root[x],root[y]);
	}
	modify(root[x],1,n,d[x],s[x]-1);
}
int main()
{
//	freopen("in.txt","r",stdin);
	n=read(),m=read();
	for(long long i=1;i<n;++i)
	{
		long long x=read(),y=read();
		add(x,y),add(y,x);
	}
	dfs(1,0);
	while(m--)
	{
		long long x=read(),k=read();
		long long ans=min(k,d[x]-1)*(s[x]-1);
		ans+=query(root[x],1,n,d[x]+1,min(n,d[x]+k));
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：iodwad (赞：9)

[欢迎访问我的 Blog](https://zcdhj.org)

线段树合并。

因为要求三元组 $(a,b,c)$ 中 $a,b$ 都是 $c$ 的祖先，所以只有两种情况

- $b$ 是 $a$ 的祖先

  这种情况直接统计就好了，答案为 $\min\{depth(a)-1,k\}*(size(a)-1)$ 其中 $depth(a)$ 为 $a$ 的深度，$size(a)$ 为子树大小

- $a$ 是 $b$ 的祖先

  随便选一个满足要求的 $b$，然后 $b$ 子树中任选一个 $c$ 都能满足答案。答案为 $\sum\limits_{depth(a)+k≥depth(b)} size(b)-1$。要要计算这个东西，对于每一个结点维护一棵以深度为编号，以 $size(x)-1$ 为权值的线段树，每次将子树的线段树合并上来。

注意要开 `long long`。

睡觉前写的 wa 成8分？？回来重构一遍就过了？？

```cpp
#include <iostream>
#include <cstdio>

typedef long long LL;
#define int LL

const int MAXN = 3e5;

int n, m, edge;
int size[MAXN | 1], depth[MAXN | 1], firstE[MAXN << 1];

struct Edge { int to, nxt; Edge() {} Edge(int x, int y) : to(x), nxt(y) {} } e[MAXN << 1];

struct Segtree {
	int sumv;
	Segtree *ch[2];
	Segtree() : sumv(0) { ch[0] = ch[1] = NULL; }
	Segtree(Segtree *ch0, Segtree *ch1, int _val) : sumv(_val) { ch[0] = ch0; ch[1] = ch1; }
} *root[MAXN << 1];

inline int read() {
	register int x = 0;
	register char ch = getchar();
	while(!isdigit(ch)) ch = getchar();
	while(isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }
	return x;
}

inline void addEdge(int x, int y) { e[++edge] = Edge(y, firstE[x]); firstE[x] = edge; }

inline void pushup(Segtree *o) { o -> sumv = (o -> ch[0] == NULL ? 0 : o -> ch[0] -> sumv) + (o -> ch[1] == NULL ? 0 : o -> ch[1] -> sumv); }

void insert(Segtree *&o, int pos, int val, int l = 1, int r = n) {
    if(o == NULL) o = new Segtree;
    if(l == r) { o -> sumv += val; return; }
    int mid = (l + r) >> 1;
    pos <= mid ? insert(o -> ch[0], pos, val, l, mid) : insert(o -> ch[1], pos, val, mid + 1, r);
    pushup(o);
}

int query(Segtree *o, int ql, int qr, int l = 1, int r = n) {
    if(o == NULL) return 0;
    if(ql <= l && r <= qr) return o -> sumv;
    int res = 0, mid = (l + r) >> 1;
    if(ql <= mid) res = query(o -> ch[0], ql, qr, l, mid);
    if(mid < qr) res += query(o -> ch[1], ql, qr, mid + 1, r);
    return res;
}

Segtree *merge(Segtree *x, Segtree *y, int l = 1, int r = n) {
    if(x == NULL) return y;
    if(y == NULL) return x;
    if(l == r) return new Segtree(NULL, NULL, x -> sumv + y -> sumv);
    int mid = (l + r) >> 1;
    return new Segtree(merge(x -> ch[0], y -> ch[0], l, mid), merge(x -> ch[1], y -> ch[1], mid + 1, r), x -> sumv + y -> sumv);
}

void dfs(int x, int fa) {
	size[x] = 1; depth[x] = depth[fa] + 1;
	for(int k = firstE[x], to; k; k = e[k].nxt) {
		to = e[k].to;
		if(to == fa) continue;
		dfs(to, x);
		size[x] += size[to]; root[x] = merge(root[x], root[to]);
	}
	insert(root[x], depth[x], size[x] - 1);
}

signed main() {
	n = read();
	m = read();
	for(int i = 1, u, v; i < n; ++i) { u = read(); v = read(); addEdge(u, v); addEdge(v, u); }
	dfs(1, 0);
	while(m--) { int p = read(), k = read(); printf("%lld\n", std::min(depth[p] - 1, k) * (size[p] - 1) + query(root[p], depth[p] + 1, depth[p] + k)); }
	return 0;
}
```



---

## 作者：ppp204 (赞：5)

> 做法: 树上dfs做差+树状数组维护前缀

看到这题不难想到它分为两种情况:b在a上面与b在a下面

b在a上面比较好想,只需要计算出$(sz[a]-1)\times min(dep[a]-1,k)$即可($min$就是防止跳到比$1$还上面的点,其实$1$上面没有点)

主要问题在于$b$在$a$下面

仔细想想,可以想到我们要存入答案的值肯定是**在$a$的子树中,深度$\leq dep[x]+k$的$sz-1$

那么看这个深度区间内的点sz总和呢？树状数组+dfs做差即可

我们在每一个节点上存入相关他的询问，以及第几个回答的ID值与给定的k值,如果我们要加sz总和，那么我们只需压在当前dep上加上相应的sz值就好了。钥匙求一段dep区间内的sz总和的话，就可以用树状数组做差发求出区间总值了

#### Code:

```
#include<bits/stdc++.h>
#define re register
#define rep(i,a,b) for(re int i=a,i##end=(int)b; i<=i##end; i++)
#define drep(i,a,b) for(re int i=a,i##end=(int)b; i>=i##end; i--)
#define repp(i,a,b) for(re int i=a,i##end=(int)b; i<i##end; i++)
#define drepp(i,a,b) for(re int i=a,i##end=(int)b; i>i##end; i--)
#define Erep(i,x) for(re int i=head[x]; ~i; i=Edge[i].nxt)
#define ll long long
#define debug(x) cout<<#x<<" = "<<x<<endl
#define lowbit(x) (x&-x)
using namespace std;
template <class T> bool Max(T &x, T y){
	return x<y?x=y,1:0;
}
template <class T> bool Min(T &x, T y){
	return x>y?x=y,1:0;
}
template <class T> T rd() {
	static char ch;static bool neg;
	static T x=0;
	for(ch=neg=0;ch<'0' || '9'<ch;neg|=ch=='-',ch=getchar());
	for(x=0;'0'<=ch && ch<='9';(x*=10)+=ch-'0',ch=getchar());
	return x=neg?-x:x;
}
const int mod=1e9+7,M=300000+5;
//bool S1;
struct edge{
	int to,nxt;
}Edge[M<<1];
int head[M],tcnt;
void AddEdge(int u, int v){
	Edge[++tcnt]=(edge)<%v,head[u]%>;
	head[u]=tcnt;
}

struct Ask{
	int x,k;
};
vector<Ask>ask[M];
int sz[M],dep[M];
ll ans[M];
//bool S2;
ll sum[M];
int n,m;

void Modify(int x, int val){
	while(x<=n){
		sum[x]+=1ll*val;
		x+=lowbit(x);
	}
	return;
}

ll Sum(int x){
	ll res=0;
	while(x){
		res+=sum[x];
		x-=lowbit(x);
	}
	return res;
}

void dfs(int x, int fa){
	dep[x]=dep[fa]+1; sz[x]=1;
	repp(i,0,ask[x].size()){
		Ask now=ask[x][i];
		ans[now.x]-=1ll*(Sum(min(dep[x]+now.k,n))-Sum(dep[x]));
	}
	Erep(i,x){
		int y=Edge[i].to;
		if(y==fa) continue;
		dfs(y,x);
		sz[x]+=sz[y];
	}
	repp(i,0,ask[x].size()){
		Ask now=ask[x][i];
		ans[now.x]+=1ll*min(dep[x]-1,now.k)*(sz[x]-1);
		ans[now.x]+=1ll*(Sum(min(dep[x]+now.k,n))-Sum(dep[x]));
	}
	Modify(dep[x],sz[x]-1);
}

int main(){
//	freopen("tree.in","r",stdin);
//	freopen("tree.out","w",stdout);
//	printf("%.2lf",(&S2-&S1)/1024.0/1024);
	memset(head,-1,sizeof head);
	n=rd<int>(),m=rd<int>();
	repp(i,1,n){
		int u=rd<int>(),v=rd<int>();
		AddEdge(u,v), AddEdge(v,u);
	}
	rep(i,1,m){
		int x=rd<int>(),k=rd<int>();
		ask[x].push_back((Ask)<%i,k%>);
	}
	dfs(1,0);
	rep(i,1,m) printf("%lld\n",ans[i]);
	return 0;
}


```

---

## 作者：p_b_p_b (赞：4)

## 树上启发式合并

广告：我的[树上启发式合并总结](https://blog.csdn.net/pb122401/article/details/84648993)。


### 思路

观察题目，发现一个性质：合法的三元组(a,b,c)一定在一条1~c的路径上。

于是统计答案的方式大概是这样的：

对于给出的a：

一、统计b在a上方时的方案数：`ans+=min(dep[a]-1,k)*(size[a]-1)`。这很容易理解。b在a上方时c可以在a的子树内任意位置。

二、统计b在a下方时的方案数。当b固定时，c可以在b的子树内的任意位置。我们只需要求出对于所有满足条件的b，它们的size-1的和即可。

问题来了：如何统计这个和呢？

很简单，树上启发式合并+数据结构维护每一个dep贡献的答案就好了，树状数组或线段树均可。

我日常sb，又用了常数巨大的线段树。

### 做法

将询问读入进来并分别塞入每一个a中。

dfs一遍求出每个点的重儿子。

再dfs一遍求出答案，求法在思路中有，不会启发式合并的可以参考我的博客。

### 代码

```cpp
#include<bits/stdc++.h>
#define sz 300020
using namespace std;
typedef long long ll;
int n,m;
struct hh{int t,nxt;}edge[sz<<1];
int head[sz],ecnt;
void make_edge(int f,int t)
{
	edge[++ecnt]=(hh){t,head[f]};
	head[f]=ecnt;
	edge[++ecnt]=(hh){f,head[t]};
	head[t]=ecnt;
}
#define go(x) for (int i=head[x];i;i=edge[i].nxt)
#define v edge[i].t
int son[sz];
ll dep[sz],size[sz];
void dfs1(int x,int fa)
{
	size[x]=1;dep[x]=dep[fa]+1;
	go(x) if (v!=fa)
	{
		dfs1(v,x);
		size[x]+=size[v];
		if (size[v]>size[son[x]]) son[x]=v;
	}
}
ll tr[sz<<2];//线段树
#define ls k<<1
#define rs k<<1|1
#define lson ls,l,mid
#define rson rs,mid+1,r
void add(int k,int l,int r,int x,int y)
{
	tr[k]+=y;
	if (l==r) return;
	int mid=(l+r)>>1;
	if (x<=mid) add(lson,x,y);
	else add(rson,x,y);
}
ll query(int k,int l,int r,int x,int y)
{
	if (x>y) return 0;
	if (x<=l&&r<=y) return tr[k];
	int mid=(l+r)>>1;
	ll ret=0;
	if (x<=mid) ret+=query(lson,x,y);
	if (y>mid) ret+=query(rson,x,y);
	return ret;
}
int S;
#define pii pair<int,int>
#define fir first
#define sec second
#define MP make_pair
vector<pii>q[sz];
ll ans[sz];
void add(int d,ll x){add(1,1,n,d,x);}
void add(int x,int fa,int t)
{
	add(dep[x],(size[x]-1)*t);
	go(x) if (v!=fa&&v!=S) add(v,x,t); 
}
void dfs2(int x,int fa,bool keep)
{
	go(x) if (v!=fa&&v!=son[x]) dfs2(v,x,0);
	if (son[x]) dfs2(son[x],x,1);
	S=son[x];
	add(x,fa,1);
	for (int i=0;i<(int)q[x].size();i++)
	{
		ll tmp1=query(1,1,n,dep[x]+1,min((ll)n,dep[x]+q[x][i].sec));//b在下方
		ll tmp2=1ll*min(dep[x]-1,(ll)q[x][i].sec)*(size[x]-1);//b在上方
		ans[q[x][i].fir]=tmp1+tmp2;
	}
	S=0;
	if (!keep) add(x,fa,-1);
}
int main()
{
	ios::sync_with_stdio(0);
	int i,x,y;
	cin>>n>>m;
	for (i=1;i<n;i++) cin>>x>>y,make_edge(x,y);
	for (i=1;i<=m;i++) cin>>x>>y,q[x].push_back(MP(i,y));//离线处理
	dfs1(1,0);
	dfs2(1,0,1);//树上启发式合并
	for (i=1;i<=m;i++) printf("%lld\n",ans[i]);
}
```

---

## 作者：foreverlasting (赞：4)

[题面](https://www.luogu.org/problemnew/show/P3899)

长链剖分。

好像主席树更好写，但长链剖分极其好想。因为这里的DP是显然的，与[这道题](https://www.luogu.org/problemnew/show/CF1009F)的DP基本一致，只不过现在这道题需要维护一个后缀和就好了。所以思路就很简单了，离线一下，维护后缀和的DP值，讨论一下$b$在$a$的下面还是在$a$的上面，下面乘一下，上面加一下就好了。

code:
```
//2018.9.12 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
inline int read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void _swap(res &x,res &y){
    x^=y^=x^=y;
}
inline int _abs(const res &x){
    return x>0?x:-x;
}
inline int _max(const res &x,const res &y){
    return x>y?x:y;
}
inline int _min(const res &x,const res &y){
    return x<y?x:y;
}
const int N=3e5+10;
namespace MAIN{
    int n,Q;
    struct E{
        int next,to;
        E() {}
        E(res next,res to):next(next),to(to) {}
    }edge[N<<1];
    int head[N],cnt;
    inline void addedge(res u,res v){
        edge[++cnt]=E(head[u],v),head[u]=cnt;
        edge[++cnt]=E(head[v],u),head[v]=cnt;
    }
    int fa[N],dep[N],maxdep[N],son[N],siz[N];
    void dfs(res x,res fax,res depx){
        fa[x]=fax,maxdep[x]=dep[x]=depx,siz[x]=1;
        for(res i=head[x];~i;i=edge[i].next){
            res tox=edge[i].to;
            if(tox==fax)continue;
            dfs(tox,x,depx+1);
            siz[x]+=siz[tox];
            maxdep[x]=_max(maxdep[x],maxdep[tox]);
            if(maxdep[tox]>maxdep[son[x]])son[x]=tox;
        }
    }
    typedef pair<int,int> Pair;
    vector<Pair> vec[N];
    LL *dp[N],tmp[N<<2],*now=tmp+1,ans[N];
    inline void Dp(res x){
        dp[x]=now,now+=maxdep[x]-dep[x]+1;
    }
    void DP(res x){
        if(son[x])dp[son[x]]=dp[x]+1,DP(son[x]),dp[x][0]+=dp[son[x]][0];
        dp[x][0]+=siz[x]-1;
        for(res i=head[x];~i;i=edge[i].next){
            res tox=edge[i].to;
            if(tox==fa[x]||tox==son[x])continue;
            Dp(tox);
            DP(tox);
            for(res j=0;j<=maxdep[tox]-dep[tox];j++)dp[x][j+1]+=dp[tox][j];
            dp[x][0]+=dp[tox][0];
        }
        for(res i=vec[x].size()-1;~i;i--){
            res id=vec[x][i].first,k=vec[x][i].second;
            ans[id]+=(LL)(siz[x]-1)*_min(dep[x]-1,k);
            if(k>=maxdep[x]-dep[x])ans[id]+=dp[x][0]-siz[x]+1;
            else ans[id]+=dp[x][0]-siz[x]+1-dp[x][k+1];
        }
    }
    inline void MAIN(){
        memset(head,-1,sizeof(head));
        n=read(),Q=read();
        for(res i=1;i<n;i++){
            res u=read(),v=read();
            addedge(u,v);
        }
        dfs(1,0,1);
#define mp make_pair
        for(res i=1;i<=Q;i++){
           res p=read(),k=read();
           vec[p].push_back(mp(i,k));
        }
        Dp(1);
        DP(1);
        for(res i=1;i<=Q;i++)printf("%lld\n",ans[i]);
    }
}
int main(){
    MAIN::MAIN();
    return 0;
}
```

---

## 作者：skydogli (赞：3)

【模板】二维偏序（逃）

当然这题还是有很多不错的性质的。

首先我们发现因为A和B都是C的祖先，所以A和B在C到根的链上，因此只需分类讨论A和B的位置关系。

- B在A上方

因为这是一颗树，所以每往上一层只有一个节点，而A的子树除A外的任意节点都满足条件，所以贡献是${\min (k,dep_A-1)\times  (siz_A-1)}$($-1$是因为$C$不能等于$A$)，这个可以直接$O(1)$计算

- B在A下方

实际上贡献就是
$$\sum_{x \in subtree_A,dep_x\in [dep_A+1,dep_A+k]}siz_x-1$$

（$-1$是因为$C$不能等于$B$）

属于A的子树我们可以通过dfs序转化为偏序问题，这样实际上就是个二位偏序问题了。我们可以进行差分，离线后按dfs序依次插入树状数组中并查询当前的答案即可。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int a=0;char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while('0'<=c&&c<='9'){
		a=a*10+c-48;
		c=getchar();
	}
	return a;
}
#define MN 300005
#define LL long long
int n,q,cnt,siz[MN],dep[MN],fa[MN];
int dfn[MN],id[MN],DP;
LL sum[MN],ans[MN];
vector<int>edge[MN];
struct data{
	int id,l,r,op;
	data(int I=0,int L=0,int R=0,int O=0){id=I;l=L;r=R;op=O;}
};
vector<data>Q[MN];
void dfs(int x){
	siz[x]=1;dfn[x]=++cnt;id[cnt]=x;
	DP=max(DP,dep[x]);//求出DFS序并找到最大的深度
	for(int i=0;i<edge[x].size();++i)
		if(fa[x]!=edge[x][i]){
			fa[edge[x][i]]=x;
			dep[edge[x][i]]=dep[x]+1;
			dfs(edge[x][i]);
			siz[x]+=siz[edge[x][i]];
		}
}
void add(int x,int v){
	while(x<=DP)sum[x]+=v,x+=x&(-x);
}
LL ask(int x){
	LL res=0;
	while(x)res+=sum[x],x-=x&(-x);
	return res;
}
int main(){
	n=read();q=read();
	for(int i=1;i<n;++i){
		int u=read(),v=read();
		edge[u].push_back(v);
		edge[v].push_back(u);
	}
	dep[1]=1;dfs(1);
	for(int i=1;i<=q;++i){
		int p=read(),k=read();
		Q[dfn[p]-1].push_back(data(i,dep[p]+1,min(DP,dep[p]+k),-1));
		Q[dfn[p]+siz[p]-1].push_back(data(i,dep[p]+1,min(DP,dep[p]+k),1));//将询问差分
		ans[i]=(LL)(siz[p]-1)*min(k,dep[p]-1);
	}
	for(int i=1;i<=n;++i){
		add(dep[id[i]],siz[id[i]]-1);//按DFS序依次插入
		for(int j=0;j<Q[i].size();++j){
			data w=Q[i][j];
			ans[w.id]+=(LL)w.op*(ask(w.r)-ask(w.l-1));
		}
	}
	for(int i=1;i<=q;++i)printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：Sai0511 (赞：3)

来一篇比较详细的题解，~~你们怎么对点$\text{b}$在点$\text{a}$上面的情况一字不提啊，要真正**清晰**的理解还是需要一定思考的。~~   
情况$\text{1}$。$\text{b}$在点$\text{a}$上面。首先点$\text{b}$一定和点$\text{a}$在同一条链上，为什么一定在同一条链上？因为不在同一条链上时他们的子树没有交集所以对答案没有贡献。$\text{c}$点可以选的范围就在$\text{a}$的子树里，也就是$\text{size}_a-1$($\text{a}$点不能选)。   
然后点$\text{a}$上面的点就有$\text{depth}_a-1$个，因为最多只能取$\text{k}$个，每个点所造成的贡献是$\text{size}_a-1$，所以这种情况的贡献可以$O(1)$得到，就是$\min(\text{k},\text{depth}_a-1)*(\text{size}_a-1)$。  
情况$\text{2}$，点$\text{b}$在点$\text{a}$下面（即点$\text{b}$在点$\text{a}$的子树里）。那么点$\text{c}$可以取的范围就是$\text{size}_b-1$(点$\text{b}$不能选)，也就是说情况$\text{2}$的贡献就是：
$$\sum_{b\text{在a的子树里且dis(a,b)}\leq\text{k}}\text{size}_b-1$$
$\text{b}$的合法范围就是$\text{depth}_a+1 \sim \text{depth}_a +\text{k}$  
~~其实我感觉这种情况比前一种情况要更容易理解。~~  
找个数据结构维护这个东西，这里我用了主席树。  
按照$\text{dfn}$序依次将每个点加入主席树，以**深度为下标**，每次将在主席树上包含这个深度的点加上$\text{size}-1$。  
那么对于一个点$\text{u}$它在主席树上对应的区间就是$\text{root}_{\text{dfn}_u}\sim\text{root}_{\text{dfn}_u+\text{size}_u-1}$。   
那么查询的时候就在主席树里查$\text{depth}_a+1 \sim \text{depth}_a+\text{k}$就好了。  
代码挺好写，这里就不放了。 



---

## 作者：crashed (赞：2)

# 题目
&emsp;&emsp;[点这里](https://www.luogu.com.cn/problem/P3899)看题目。  
# 分析  
&emsp;&emsp;首先发现，对于$(a,b,c)$的合法三元组，$c$一定在$a$的子树内，并且$b$也是$c$的祖先。那么我们只需要考虑$b$的位置。如果$b$是$a$的子孙，那么$c$一定就是$b$的子孙，此时的贡献是$siz(b)-1$（我们以下都用$siz(u)$表示$u$的子树大小）。如果$b$是$a$的祖先，那么贡献就是$siz(a)-1$。  
&emsp;&emsp;发现，当$b$是$a$的祖先的时候，贡献只与$k$、$siz(a)$和$a$的深度有关，因此可以直接计算。  
&emsp;&emsp;因此我们只需要考虑，对每个询问求出：  
$$\sum_{dis(p,v)\le k} (siz(v)-1)$$  
&emsp;&emsp;这是一个长链剖分可做的问题。~~但是由于我很蒻，因此我不会。~~  
&emsp;&emsp;考虑到 " $a$和$b$距离不超过$k$ " 的限制，我们可以发现，$b$到$a$的深度差不会超过$k$。因此，知道了$a$的深度和$k$，我们就可以知道合法的$b$的最大的深度，我们称这个最大深度为一个询问的 " 可用深度 " 。  
&emsp;&emsp;因此，我们将所有点按照深度从小到大，插入贡献。对于一个询问，当深度小于等于它的 " 可用深度 " 的点都被插入后，我们就可以计算它此时的答案——也就是它子树内的贡献和。  
&emsp;&emsp;可以发现，此时查询既满足贡献不遗漏，也满足不会有多余的贡献。  
&emsp;&emsp;子树内的贡献和，可以通过将树展开为 DFS 序的方法，转化为区间求和，用 BIT 可以维护。点和询问都可以在排序后使用指针扫过去。  
&emsp;&emsp;时间复杂度$O((n+q)\log_2n)$。  
# 代码
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

typedef long long LL;

const int MAXN = 3e5 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

struct edge
{
	int to, nxt;
}Graph[MAXN << 1];

struct Query
{
	int dd, id, A, K;
	bool operator < ( const Query &b ) const { return dd < b.dd; }
};

Query q[MAXN];

LL BIT[MAXN], ans[MAXN];
int pts[MAXN];
int head[MAXN], dep[MAXN], pos[MAXN], siz[MAXN];
int N, Q, cnt, ID;

int lowbit( const int x ) { return x & ( -x ); }
void update( int x, int v ) { for( ; x <= N ; x += lowbit( x ) ) BIT[x] += v; }
LL getSum( int x ) { LL ret = 0; while( x ) ret += BIT[x], x -= lowbit( x ); return ret; }
LL query( int l, int r ) { return getSum( r ) - getSum( l - 1 ); }
bool cmp( const int &x, const int &y ) { return dep[x] < dep[y]; }

void addEdge( const int from, const int to )
{
	Graph[++ cnt].to = to, Graph[cnt].nxt = head[from];
	head[from] = cnt;
}

void DFS( const int u, const int fa )
{
	dep[u] = dep[fa] + 1, siz[u] = 1, pos[u] = ++ ID;
	for( int i = head[u], v ; i ; i = Graph[i].nxt )
		if( ( v = Graph[i].to ) ^ fa )
			DFS( v, u ), siz[u] += siz[v];
}

signed main()
{
	int height = 0;
	read( N ), read( Q );
	for( int i = 1, a, b ; i < N ; i ++ ) read( a ), read( b ), addEdge( a, b ), addEdge( b, a );
	DFS( 1, 0 );
	for( int i = 1 ; i <= N ; i ++ ) height = MAX( height, dep[i] ), pts[i] = i;
	for( int i = 1 ; i <= Q ; i ++ ) 
		read( q[i].A ), read( q[i].K ), q[i].dd = MIN( dep[q[i].A] + q[i].K, height ), q[i].id = i;
	std :: sort( q + 1, q + 1 + Q );
	std :: sort( pts + 1, pts + 1 + N, cmp );
	int rig = 1, ptr = 1;
	for( int i = 1 ; i <= N ; )
	{
		for( ; rig <= N && dep[pts[rig]] == dep[pts[i]] ; rig ++ );
		for( ; i < rig ; i ++ ) update( pos[pts[i]], siz[pts[i]] - 1 );
		if( q[ptr].dd == dep[pts[i - 1]] )
		{
			for( ; ptr <= Q && q[ptr].dd == dep[pts[i - 1]] ; ptr ++ )
			{
				ans[q[ptr].id] = query( pos[q[ptr].A] + 1, pos[q[ptr].A] + siz[q[ptr].A] - 1 );
				ans[q[ptr].id] += 1ll * MIN( q[ptr].K, dep[q[ptr].A] - 1 ) * ( siz[q[ptr].A] - 1 );
			}
		}
	}
	for( int i = 1 ; i <= Q ; i ++ ) write( ans[i] ), putchar( '\n' );
	return 0;
}
```  

---

## 作者：Santiego (赞：2)

题目大意：

> 给一棵树$n$个节点，$q$次询问，每次给定$p,k$，问有多少三元组$(p,b,c)$满足$p,b$均为$c$的父亲，$p,b$在树上的距离不超过$k$
> $n,q\le 10^5$

很有意思的一道题。

两种情况讨论：

- $b$在$a$的上面，我们发现$b$有$min(dep[a]-1, k)$个可选位置，而$a$的子树内所有节点（除了节点$a$本身）均可作为$c$，所以共有$min(dep[a]-1, k)\times(sz[a]-1) ​$个三元组满足。
- 对于$b$在$a$的下面，我们可以每个节点都维护一颗**下标为深度**的权值线段树，因为节点$u$作为$b$的同时，其子树除$u$外均可作为$c$，所以对于深度$dep[u]$的贡献为$sz[u]-1$，然后在$dfs$回溯时同时合并子树线段树，每次答案即为深度区间$[dep[a]+1, dep[a]+k]$的区间和。

最后答案即为两种情况之和

注意空间限制，需要动态开点。

```cpp
#include <cstdio>
#include <algorithm>
#define MAXN 300003
#define MAXM 300003*30
#define ll long long
using namespace std;
int head[MAXN],nxt[MAXN*2],vv[MAXN*2],tot;
inline void add_edge(int u, int v){
    vv[++tot]=v;
    nxt[tot]=head[u];
    head[u]=tot;
}
int cnt;
ll tre[MAXM*2];
int sl[MAXM*2],sr[MAXM*2];
void change(int &x, int l, int r, int pos, int val){
    if(x==0) x=++cnt;
    tre[x]+=val;
    if(l==r) return;
    int mid=(l+r)>>1;
    if(pos<=mid) change(sl[x], l, mid, pos, val);
    else change(sr[x], mid+1, r, pos, val);
}
ll query(int x, int l, int r, int ql, int qr){
    if(x==0) return 0;
    if(ql<=l&&r<=qr) return tre[x];
    int mid=(l+r)>>1;
    ll res=0;
    if(ql<=mid) res+=query(sl[x], l, mid, ql, qr);
    if(mid<qr) res+=query(sr[x], mid+1, r, ql, qr);
    return res;
}
int merge(int a, int b, int l, int r){
    if(a==0||b==0) return a+b;
    int mid=(l+r)>>1;
    int x=++cnt;
    tre[x]=tre[a]+tre[b];
    sl[x]=merge(sl[a], sl[b], l, mid);
    sr[x]=merge(sr[a], sr[b], mid+1, r);
    return x;
}
int n,q;
int sz[MAXN],rot[MAXN],dep[MAXN];
void dfs(int u, int fa){
    sz[u]=1;
    dep[u]=dep[fa]+1;
    for(int i=head[u];i;i=nxt[i]){
        int v=vv[i];
        if(v==fa) continue;
        dfs(v, u);
        sz[u]+=sz[v];
    }
    change(rot[u], 1, n, dep[u], sz[u]-1);
    rot[fa]=merge(rot[fa], rot[u], 1, n);
}
int main(){
    scanf("%d %d", &n, &q);
    for(int i=1;i<n;++i){
        int a,b;scanf("%d %d", &a, &b);
        add_edge(a, b);add_edge(b, a);
    }
    dfs(1, 0);
    while(q--){
        int p,k;scanf("%d %d", &p, &k);
        printf("%lld\n", query(rot[p], 1, n, dep[p]+1, dep[p]+k)+(ll)(sz[p]-1)*min(k, dep[p]-1));
    }
    return 0;
}
```



---

## 作者：antimo (赞：1)

[博客](https://blog.csdn.net/Antimonysbguy/article/details/107326531)内食用效果更佳哦

[传送门](https://www.luogu.com.cn/problem/P3899)

# 一、做法

$C$一定是$A, B$公共子树里的点

1. B在A上方\
则C一定在A子树中\
$ans=\min\{k,dep[A]-1\}\times (siz[A]-1)$
2. B在A下方\
$ans=\sum[0<dis(A,B)\leq k](siz[B]-1)$\
使$dis(A,B)$相等的B对$ans$都有贡献，具有可加性\
但是不能把$dep[B]=dep[A]+dis(A,B)$的B加起来，不是A的子树上的B不能统计\
考虑前缀和，考虑可持久化：\
按照**DFS序**，以**深度**为下标，每个子节点建主席树，记录目前搜到**深度大于等于**它的所有节点贡献和（可持久化+支持前缀和）\
具体$sum[B]=(siz[B]-1)+\sum_u[dep[u]\geq dep[B]\&dfn[u]<dfn[B]]sum[u]$
然后查询就直接$ans=sum[dep[A]+1,dep[A]+k]$，前缀和\
注意是$rt[dep[A]+siz[A]-1]-rt[dep[A]-1]$，-1是为了避免统计到下一个该深度的节点（-1停留在同深度上一个节点子树的最后一个叶子节点，此时统计完了前面所有内容）

# 二、复杂度和数据范围
骚\
很骚\
真的骚

- 数据范围：\
如果是条链，$p$是中点，$k$是半长\
考虑B在上面的情况\
$ans=1.5e5\times 1.5e5>1e9$\
要开long long
- 复杂度\
时间复杂度没啥好说的，第一个DFS$\Theta(n)$，第二个$\Theta(n^2\log n)$，查询$\Theta(qn\log n)$，主席树不会爆\
空间复杂度就很日龙\
`vector`1个多一点，`SGT`（没存左右端点）3个，再加上`dep,siz,dfn,rt`总共8个$\Theta(8n)$多一点，如果`SGT`存左右端点就$\Theta(10n)$多一点，炸掉:sob:

# ACcode

```cpp
#include<bits/stdc++.h>
using namespace std;
#define in Read()
#define int long long
int in{
	int i=0,f=1;char ch=0;
	while(!isdigit(ch)&&ch!='-') ch=getchar();
	if(ch=='-') ch=getchar(),f=-1;
	while(isdigit(ch)) i=(i<<1)+(i<<3)+ch-48,ch=getchar();
	return i*f;
}

const int NNN=3e5+5;
int n,q;
vector<int>G[NNN];
struct SGT{
	int sum,lc,rc;
}tre[NNN*30];
int dep[NNN],siz[NNN],dfn[NNN],tot,sz,rt[NNN];

#define lch(x) tre[(x)].lc
#define rch(x) tre[(x)].rc

void Print(int p){
	if(!lch(p)&&!rch(p)) return;
	printf("%d(%d) %d(%d) %d(%d)\n",p,tre[p].sum,lch(p),tre[lch(p)].sum,rch(p),tre[rch(p)].sum);
	Print(lch(p));
	Print(rch(p));
	return;
}

void push_up(int p){
	tre[p].sum=tre[lch(p)].sum+tre[rch(p)].sum;
	return;
}

void build(int &p,int l,int r){
	p=++sz;
	if(l==r) return;
	int mid=l+r>>1;
	build(lch(p),l,mid);
	build(rch(p),mid+1,r);
	return;
}

void update(int &p,int pre,int loc,int con,int l,int r){
	p=++sz;
	tre[p]=tre[pre];
	if(l==r){
		tre[p].sum+=con;
		return;
	}
	int mid=l+r>>1;
	if(loc<=mid) update(lch(p),lch(pre),loc,con,l,mid);
	else update(rch(p),rch(pre),loc,con,mid+1,r);
	push_up(p);
	return;
}

int query(int p,int pre,int l,int r,int L,int R){
	if(L<=l&&r<=R) return tre[p].sum-tre[pre].sum;
	int mid=l+r>>1,res=0;
	if(L<=mid) res+=query(lch(p),lch(pre),l,mid,L,R);
	if(R>mid) res+=query(rch(p),rch(pre),mid+1,r,L,R);
	return res;
}

void DFS1(int u,int fa){
	dfn[u]=++tot;
	dep[u]=dep[fa]+1;
	siz[u]=1;
	for(int e=0;e<G[u].size();++e){
		int v=G[u][e];
		if(v==fa) continue;
		DFS1(v,u);
		siz[u]+=siz[v];
	}
	return;
}

void DFS2(int u,int fa){
	update(rt[dfn[u]],rt[dfn[u]-1],dep[u],siz[u]-1,1,n);
//	for(int i=0;rt[i];++i) printf("---\n"),Print(rt[i]),printf("---\n");
	for(int e=0;e<G[u].size();++e){
		int v=G[u][e];
		if(v==fa) continue;
		DFS2(v,u);
	}
	return;
}

signed main(){
	n=in,q=in;
	for(int i=1;i<n;++i){
		int u=in,v=in;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	
	DFS1(1,0);
	build(rt[0],1,n);
	DFS2(1,0);
	
	for(int i=1;i<=q;++i){
		int p=in,k=in;
		int ans=0;
		ans+=min(k,dep[p]-1)*(siz[p]-1);
//		printf("up:%d\n",ans);
		ans+=query(rt[dfn[p]+siz[p]-1],rt[dfn[p]-1],1,n,dep[p]+1,dep[p]+k);
//		printf("down:%d\n",ans-min(k,dep[p]-1)*(siz[p]-1));
		printf("%lld\n",ans);
	}
	
	return 0;
}
```


---

## 作者：Martian148 (赞：1)

## link
[P3899 [湖南集训]谈笑风生](https://www.luogu.com.cn/problem/P3899)
## solve
通过观察我们发现，a是固定不动的，而b距离a不超过k

则b有两种情况。

**$(i)$b在a的上方**

则$b$离$a$的距离最大为$ min(deep[a],k)$

$c$就是$a$子树的任意一点。

则对答案的贡献就是$ min(deep[a],k)* (size[a]-1) $

**$(ii)$b是a的下方**

那我们b是a子树上距离$a$不超过k也就是深度差不超过k的一个点

$c$就是$b$子树上的一个点

对答案的贡献就是把所有可能的$size[b]$加起来

我们以$deep[x]$为下标,$size[x]$为权值建主席树，就可以统计出$sum$总和了。

注意一点，数据比较大，要开long long

## code

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
using namespace std;
const int maxn=600005;
typedef long long LL;
int N,Q,son[maxn],nxt[maxn],lnk[maxn],cnt,deep[maxn],size[maxn],r[maxn],tot,q[maxn],l[maxn],sz,root[maxn];
struct data{
	int l,r;
	LL sum;
}tr[maxn*32];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch<='9'&&ch>='0')ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
int add_e(int x,int y){son[++cnt]=y;nxt[cnt]=lnk[x];lnk[x]=cnt;}
void dfs(int u,int fa){
	l[u]=++tot;deep[u]=deep[fa]+1;q[tot]=u;size[u]=1;
	for(int j=lnk[u];j;j=nxt[j]){
		if(son[j]==fa)continue;
		dfs(son[j],u);size[u]+=size[son[j]];
	}
	r[u]=tot;
}
void insert(int &x,int l,int r,int pos,int val){
	tr[++sz]=tr[x];x=sz;
	tr[x].sum+=(LL)val;
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(pos<=mid)insert(tr[x].l,l,mid,pos,val);
	else insert(tr[x].r,mid+1,r,pos,val);
}
void update(int x){
	int l=tr[x].l,r=tr[x].r;
	tr[x].sum=tr[l].sum+tr[r].sum;
}
LL query(int i,int j,int l,int r,int ll,int rr){
	if(ll<=l&&r<=rr)return tr[j].sum-tr[i].sum;
	int mid=(l+r)>>1;
	LL ans=0;
	if (ll<=mid)ans+=query(tr[i].l,tr[j].l,l,mid,ll,rr);
	if (rr>mid)ans+=query(tr[i].r,tr[j].r,mid+1,r,ll,rr);
	return ans;
} 
int main(){
	freopen("3653.in","r",stdin);
	freopen("3653.out","w",stdout);
	N=read();Q=read();
	for(int i=1;i<N;i++){
		int x=read(),y=read();
		add_e(x,y);add_e(y,x);
	}
	dfs(1,0);
	for(int i=1;i<=N;i++)root[i]=root[i-1],insert(root[i],1,N,deep[q[i]],size[q[i]]-1);
	for(int i=1;i<=Q;i++){
		int x=read(),k=read();
		LL t=query(root[l[x]],root[r[x]],1,N,deep[x]+1,deep[x]+k);
		int len=min(k,deep[x]-1);
		printf("%lld\n",t+(LL)len*(LL)(size[x]-1));
	}
	return 0;
}
```



---

## 作者：totorato (赞：1)

### 求什么
树上在一条深度单调的链上的满足一些特性的节点三元组的个数。
### 怎么求
我们可以模仿《天天爱跑酷》中的套路一样计算这个东西。

由于我们知道答案可以分为两部分计算。第一部分用子树大小和节点深度的积可以求得，第二部分需要利用这个套路：

我们需要求一个节点子树中以到他距离小于等于k的节点为根的子树大小的和。由于整棵树的DFS序确定，那么以这个节点为根的子树一定是DFS序列中一段连续的区间。

在DFS的过程中，我们按DFS序将答案累加起来。询问两个不同时间的差值就意味着得到了一段连续区间的和(即一棵子树的答案)

所以我们可以认为我们在做一个序列差分--只不过这个序列的下标是时间。

这样，我们就可以用树状数组维护某一时刻所有深度的节点的子树大小的和，比如sum\[x\]表示深度为x的节点为根的子树大小的和。两个时刻询问得到的答案相减对应一棵子树的答案。

所以可以知道为了这么做我们需要先把询问离线才行。

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>

#define MX 300003

using namespace std;

typedef long long ll;

int fst[MX],nxt[MX*2],v[MX*2],siz[MX],dep[MX],lnum;
ll sum[MX];
vector<int>qk[MX],qid[MX];
ll ans[MX];
int n,m;

void add(int p,ll x){for(;p<MX;p+=(p&(-p)))sum[p]+=x;}
ll qsm(int p){ll x=0;for(;p;p-=(p&(-p)))x+=sum[p];return x;}
void addeg(int nu,int nv)
{
	nxt[++lnum]=fst[nu];
	fst[nu]=lnum;
	v[lnum]=nv;
}
void dfs(int x,int fa,int d)
{
	siz[x]=1,dep[x]=d;
	for(int i=fst[x];i!=-1;i=nxt[i])
		if(v[i]!=fa)
			dfs(v[i],x,d+1),
			siz[x]+=siz[v[i]];
}
void calc(int x,int fa)
{
	for(int i=0;i<qk[x].size();i++)ans[qid[x][i]]-=(qsm(min(dep[x]+qk[x][i],MX-1))-qsm(dep[x]));
	for(int i=fst[x];i!=-1;i=nxt[i])
		if(v[i]!=fa)
			calc(v[i],x);
	for(int i=0;i<qk[x].size();i++)ans[qid[x][i]]+=(qsm(min(dep[x]+qk[x][i],MX-1))-qsm(dep[x])+(ll)min(dep[x]-1,qk[x][i])*(ll)(siz[x]-1));
	add(dep[x],siz[x]-1);
}
void input()
{
	int a,b;
	memset(fst,0xff,sizeof(fst)),lnum=-1;
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++)
	{
		scanf("%d%d",&a,&b);
		addeg(a,b);
		addeg(b,a);
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&a,&b);
		qk[a].push_back(b);
		qid[a].push_back(i);
	}
}
int main()
{
	input();
	dfs(1,0,1);
	calc(1,0);
	for(int i=1;i<=m;i++)printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：muller (赞：0)

这道题首先要分情况考虑

A

a是b的祖先

那么对于b我们以深度为关键字，维护一下主席树

然后算和即可

B

b是a的祖先

我们直接min(depth[a]-1,k)种选择

我们可以直接算出答案，统计一下即可

对于主席树环节，我们主要需要在权值线段树上二分

注意要用long long

其他注意些细节即可

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 300005;
int Rt[N], ls[N << 5], rs[N << 5], to[N << 1], nxt[N << 1], fir[N];
int n, ecnt, idx, tot, siz[N], size[N], depth[N], dfn[N], rev[N];
ll ans, sum[N << 5];
void build(int rt, int l, int r) {
    if (l == r) return;
    int mid = l + r >> 1;
    build(ls[rt] = ++tot, l, mid); build(rs[rt] = ++tot, mid + 1, r);
}
void insert(int pre, int rt, int l, int r, int x, int y) {
    sum[rt] = sum[pre] + y;
    if (l == r) return;
    int mid = l + r >> 1;
    ls[rt] = ls[pre]; rs[rt] = rs[pre];
    if (x <= mid) insert(ls[pre], ls[rt] = ++tot, l, mid, x, y);
    else insert(rs[pre], rs[rt] = ++tot, mid + 1, r, x, y);
} 
ll query(int pre, int rt, int l, int r, int x) {
    if (l == r) return sum[rt] - sum[pre];
    int mid = l + r >> 1;
    if (x > mid) return sum[ls[rt]] - sum[ls[pre]] + query(rs[pre], rs[rt], mid + 1, r, x);
    return query(ls[pre], ls[rt], l, mid, x);
}
void ae(int u, int v) {to[++ecnt] = v; nxt[ecnt] = fir[u]; fir[u] = ecnt;}
void dfs(int u, int f) {
    int v, i;
    rev[dfn[u] = ++idx] = u; depth[u] = depth[f] + 1; size[u] = 1;
    for (i = fir[u]; i; i = nxt[i]) {
        v = to[i];
        if (v != f) {dfs(v, u); size[u] += size[v];}
    }
}
int main() {
    int l, r, u, v, p, q, k, i;
    scanf("%d%d", &n, &q);
    for (i = 1; i < n; ++i) {
        scanf("%d%d", &u, &v);
        ae(u, v); ae(v, u);
    }
    depth[1] = 1; build(Rt[0] = tot = 1, 1, n); dfs(1, 0);
    for (i = 1; i <= n; ++i) insert(Rt[i - 1], Rt[i] = ++tot, 1, n, depth[rev[i]], size[rev[i]] - 1);
    while (q--) {
        scanf("%d%d", &p, &k); ans = 1ll * min(depth[p] - 1, k) * (size[p] - 1);
        l = dfn[p]; r = dfn[p] + size[p] - 1;
        ans += query(Rt[l], Rt[r], 1, n, min(depth[p] + k, n));
        printf("%lld\n", ans);
    }
    return 0;
}

```


---

## 作者：Styx (赞：0)

首先分析一下题意，会发现有这么一句话  

>2.a 和 b 都比 c 不知道高明到哪里去了；

思考一下：如果$a$比$c$高，说明$a$是$c$的祖先，同样$b$是$c$的祖先  
那么显然**$a$和$b$肯定都在$c$到根的路径上**，所以要么$a$是$b$的祖先，要么$b$是$a$的祖先  

先来思考$b$是$a$的祖先的情况：

首先$c$肯定是在$a$的子树里，有$size[a]-1$个  
然后$b$的个数有$min(deep[a]-1,k)$个  
所以这一部分的贡献是$(size[a]-1)*min(deep[a]-1,k)$

接着是$a$是$b$的祖先的情况

$b$是$a$子树中距离$a$点深度$k$以内的点，每个$c$点从$b$点的子树中取。    
这一部分的贡献是共有$\sum size[b]-1(deep[b]-deep[a]<=k)$

显然第一部分dfs的时候$O(1)$随便搞搞就可以了，重点在第二部分

我们在每个点弄一颗线段树，以深度为下标，记录这个点子树中每个深度对应的$c$点的个数

到时候只需要查询$deep[a]+1 \rightarrow deep[a]+k$之间的权值和就行了

为了不MLE，可以考虑在dfs的时候将子节点线段树合并到父节点线段树上，然后就写完了

注意要开下longlong.......

```cpp

#include<bits/stdc++.h>
#define lson tr[now].l
#define rson tr[now].r
using namespace std;

struct tree
{
    long long sum;
    int l,r;
}tr[20000010];

struct op
{
    int k,id;
};

int n,m;
int rt[300010],cnt,deep[300010];
long long ans[300010],size[300010];
vector<int> g[300010];
vector<op> gg[300010];

int dfs(int now,int fa,int dep)
{
    deep[now]=dep;
    size[now]=1;
    rt[now]=++cnt;
    for(int i=0;i<g[now].size();i++)
    {
        if(g[now][i]==fa) continue;
        dfs(g[now][i],now,dep+1);
        size[now]+=size[g[now][i]];
    }
}

int push_up(int now)
{
    tr[now].sum=tr[lson].sum+tr[rson].sum;
}

int insert(int &now,int l,int r,int pos,int val)
{
    if(!now) now=++cnt;
    if(l==r)
    {
        tr[now].sum+=val;
        return 0;
    }
    int mid=(l+r)>>1;
    if(pos<=mid)
    {
        insert(lson,l,mid,pos,val);
    }
    else
    {
        insert(rson,mid+1,r,pos,val);
    }
    push_up(now);
}

long long query(int now,int l,int r,int ll,int rr)
{
    if(ll>rr) return 0;
    if(ll<=l&&r<=rr) return tr[now].sum;
    int mid=(l+r)>>1;
    if(rr<=mid)
    {
        return query(lson,l,mid,ll,rr);
    }
    else
    {
        if(mid<ll)
        {
            return query(rson,mid+1,r,ll,rr);
        }
        else
        {
            return query(lson,l,mid,ll,mid)+query(rson,mid+1,r,mid+1,rr);
        }
    }
}

int merge(int a,int b,int l,int r)
{
    if(!a) return b;
    if(!b) return a;
    if(l==r)
    {
        tr[a].sum+=tr[b].sum;
        return a;
    }
    int mid=(l+r)>>1;
    tr[a].l=merge(tr[a].l,tr[b].l,l,mid);
    tr[a].r=merge(tr[a].r,tr[b].r,mid+1,r);
    push_up(a);
    return a;
}

int dfs2(int now,int fa)
{
    insert(rt[now],1,300000,deep[now],size[now]-1);
    for(int i=0;i<g[now].size();i++)
    {
        if(g[now][i]==fa) continue;
        dfs2(g[now][i],now);
        merge(rt[now],rt[g[now][i]],1,300000);
    }
    for(int i=0;i<gg[now].size();i++)
    {
        int id=gg[now][i].id;
        int k=gg[now][i].k;
        long long sum1=(size[now]-1)*min(deep[now]-1,k);
        long long sum2=query(rt[now],1,300000,deep[now]+1,min(deep[now]+k,300000));
        ans[id]=sum1+sum2;
    }
}

int main()
{
    scanf("%d%d",&n,&m);
    int from,to;
    for(int i=1;i<n;i++)
    {
        scanf("%d%d",&from,&to);
        g[from].push_back(to);
        g[to].push_back(from);
    }
    int pos,k;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&pos,&k);
        gg[pos].push_back({k,i});
    }
    dfs(1,0,1);
    dfs2(1,0);
    for(int i=1;i<=m;i++)
    {
        printf("%lld\n",ans[i]);
    }
}
```




---

## 作者：Iscream2001 (赞：0)

看到楼下大佬用主席树。。。忍不住发一波题解。。。

好吧其实思路是一样的。。。

先预处理出每个节点子树的大小（不包括该节点）。

答案显然分成两部分，若b是a的祖先，这部分答案就是a的距离为k的祖先个数乘a的子树大小。

若a是b的祖先。。其实用线段树就可以了。。

dfs需处理出来之后，记下每个节点的开头和结尾，在开头处加上该节点的子树大小，每次询问就是普通的线段树求区间和基本操作了。。。

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
#include<vector>
#include<map>
#define N 300050
#define LL long long
#define inf 2000000000
using namespace std;
inline int Read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,Q,cnt=0,dfn=0;
int hed[N],siz[N],DFN[N][2],s[N<<1],dep[N],D[N<<1];
struct edge{int r,nxt;}e[N<<1];
struct node{int l,r,mn,mx;LL sum;}d[N<<3];
void insert(int u,int v){
    e[++cnt].r=v;e[cnt].nxt=hed[u];hed[u]=cnt;
}
void dfs(int x,int F){
    DFN[x][0]=++dfn;siz[x]=1;
    for(int i=hed[x];i;i=e[i].nxt)
        if(e[i].r!=F){
            dep[e[i].r]=dep[x]+1;
            dfs(e[i].r,x);
            siz[x]+=siz[e[i].r];
        }
    DFN[x][1]=++dfn;
    D[DFN[x][0]]=D[DFN[x][1]]=dep[x];
    s[DFN[x][0]]=siz[x]-1;s[DFN[x][1]]=0;
    return;
}
void build(int l,int r,int k){
    d[k].l=l;d[k].r=r;
    if(l==r){
        d[k].mx=d[k].mn=D[l];d[k].sum=s[l];return;
    }
    int mid=(l+r)>>1;
    build(l,mid,k<<1);build(mid+1,r,k<<1|1);
    d[k].mx=max(d[k<<1].mx,d[k<<1|1].mx);
    d[k].mn=min(d[k<<1].mn,d[k<<1|1].mn);
    d[k].sum=d[k<<1].sum+d[k<<1|1].sum;
    return;
}
LL solve(int l,int r,int k,int w){
    if(d[k].mn>w) return 0;
    if(d[k].l==l && d[k].r==r && d[k].mx<=w)return d[k].sum;
    if(r<=d[k<<1].r) return solve(l,r,k<<1,w);
    else if(l>d[k<<1].r) return solve(l,r,k<<1|1,w);
    else return solve(l,d[k<<1].r,k<<1,w)+solve(d[k<<1|1].l,r,k<<1|1,w);
}
int main(){
    int u,v;
    LL ans;
    n=Read();Q=Read();
    for(int i=1;i<n;i++){
        u=Read();v=Read();
        insert(u,v);insert(v,u);
    }
    dep[1]=1;dfs(1,0);
    build(1,dfn,1);
    while(Q--){
        u=Read();v=Read();
        ans=(LL)(siz[u]-1)*(LL)(min(v,dep[u]-1));
        ans+=solve(DFN[u][0]+1,DFN[u][1],1,v+dep[u]);
        printf("%lld\n",ans);
    }
    return 0;
}
```

---


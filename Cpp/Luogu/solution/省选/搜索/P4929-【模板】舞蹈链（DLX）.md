# 【模板】舞蹈链（DLX）

## 题目背景

本题是舞蹈链模板——精确覆盖问题

## 题目描述

给定一个 $N$ 行 $M$ 列的矩阵，矩阵中每个元素要么是 $1$，要么是 $0$。

你需要在矩阵中挑选出若干行，使得对于矩阵的每一列 $j$，在你挑选的这些行中，有且仅有一行的第 $j$ 个元素为 $1$。


## 说明/提示

对于 $100\%$ 的数据，$N,M\leq 500$，保证矩阵中 $1$ 的数量不超过 $5000$ 个。

## 样例 #1

### 输入

```
3 3
0 0 1
1 0 0
0 1 0
```

### 输出

```
2 1 3
```

## 样例 #2

### 输入

```
3 3
1 0 1
1 1 0
0 1 1
```

### 输出

```
No Solution!
```

# 题解

## 作者：钱逸凡 (赞：350)

DLX又称dancing links X 是一种
### 解决重复覆盖和精确覆盖的高效算法

# 精确覆盖的定义：
 
 一个全集S有若干个子集S1，S2，……Sn，选取其中若干个子集，使得这些集合中出现了S中每个元素各一次。
 
 这么说可能有点抽象（我知道我语文不好），举个例子：
 
 全集S=｛1，2，3，4，5，6，7｝，
 用子集S1=｛1，2，3｝，S2=｛3，4，5，7｝，S3=｛4，5，6，7｝，S4=｛1，5，6，7｝，S5={4,5}精确覆盖，结果显然是选取S1和S3。
 
# 主要思想：

把全集中的每个元素对应成一个矩阵中的列，把每个子集对应成一个行
对于矩阵中一点（i，j）若集合Si包含元素j则改点为1，否则为0。

我表达能力确实不行，将就看吧，实在不行就看图吧。~~（蒟蒻不会绘图软件，只好手敲了）~~

还是刚才的例子，矩阵表示为：

     S | 1  |2  |3  |4  |5  |6  |7
    S1 | 1  |1  |1  |0  |0  |0  |0
    S2 | 0  |0  |1  |1  |1  |0  |1
    S3 | 0  |0  |0  |1  |1  |1  |1
    S4 | 1  |0  |0  |0  |1  |1  |1
    S5 | 0  |0  |0  |1  |1  |0  |0

接下来是核心操作：
先选取一个集合（一行），把该行和该行上有点的列和包含这些列的行删除（还是看图吧……），比如说我们选了第1行：

     S | 4  |5  |6  |7
    S3 | 1  |1  |1  |1
    S5 | 1  |1  |0  |0

为什么是这样呢？首先我们要知道当我们把矩阵删完后就完成了精确覆盖，我们选了第一行所以第一行中的元素对应的列就删完了，而包含了这些元素的行肯定是不能选的，所以我们把它们也删了。

接下来如果我们选择了S3，显然矩阵为空，我们找到了一组解，但若我们选择了S5则矩阵变为：

     S | 6  |7
     
矩阵未覆盖完但已经无集合可用，覆盖失败，于是要回溯，于是矩阵又为：
      
     S | 4  |5  |6  |7
    S3 | 1  |1  |1  |1
    S5 | 1  |1  |0  |0

大致是这样一个过程，具体怎么操作就看代码：

# 代码实现：

首先要知道我们需要的数组和对应的含义：
```
int n,m,cnt;//矩阵的长，宽，点的数量
	int l[mx],r[mx],u[mx],d[mx],row[mx],col[mx];//每个点的左，右，上下，行，列信息
	int h[mx];//每行的头结点
	int s[mx];//每列的结点数
	int ans,ansk[mx];//需要ans个子集，分别为ansk[]
```

dancing links 的原理是十字链表的删除和恢复很方便，利用十字链表来储存我们需要的信息。

1. 第一步 ：建立空的矩阵：
```
void init(int _n,int _m) {
		n=_n,m=_m;
		int i;
		for(i=0; i<=m; i++) {
			r[i]=i+1;
			l[i]=i-1;
			u[i]=d[i]=i;
		}
		r[m]=0;//m右边是0
		l[0]=m;//0左边是m
		memset(h,-1,sizeof(h));
		memset(s,0,sizeof(s));
		cnt=m+1;//开始时有m个结点（0结点和各列头结点）
	}//初始化，生成每列的头
```

1. 第二步：在r行c列插入点

```
inline void link(int R,int C) {
		s[C]++;
		row[cnt]=R;
		col[cnt]=C;
		u[cnt]=C;
		d[cnt]=d[C];
		u[d[C]]=cnt;
		d[C]=cnt;//十字链表原理
		if(h[R]<0)h[R]=r[cnt]=l[cnt]=cnt;//该行没有别的点,把第一个加入的点作为该行的行头结点
		else {
			r[cnt]=h[R];
			l[cnt]=l[h[R]];
			r[l[h[R]]]=cnt;
			l[h[R]]=cnt;
		}
		cnt++;
	}
```
1. 第三步：删除与恢复：
```
inline void remove(int c) {
		r[l[c]]=r[c],l[r[c]]=l[c];
		for(int i=d[c]; i!=c; i=d[i]) {
			for(int j=r[i]; j!=i; j=r[j]) {
				u[d[j]]=u[j];
				d[u[j]]=d[j];
				s[col[j]]--;
			}
		}
	}//删除c列和c列上有点的行
	inline void resume(int c) {
		for(int i=u[c]; i!=c; i=u[i]) {
			for(int j=l[i]; j!=i; j=l[j]) {
				u[d[j]]=j;
				d[u[j]]=j;//十字链表的恢复原理，可以自己画图验证。
				s[col[j]]++;
			}
		}
		r[l[c]]=c;
		l[r[c]]=c;
	}//恢复c列和c列上有点的行，恢复与删除很像
```
1. 第四步：核心dance：
```
bool dance(int deep) {
		if(r[0]==0) { //矩阵已经删除完
		ans=deep;
        //如果要求输出具体的解，可在此处操作（把ansk转换换回对应的集合信息）
        return 1;//多解问题去掉这行
		}
		int c=r[0];
		for(int i=r[0];i!=0;i=r[i])if(s[i]<s[c])c=i;//找到点最少的列
		remove(c);
		for(int i=d[c];i!=c;i=d[i]){
			ansk[deep]=row[i];
			for(int j=r[i];j!=i;j=r[j]) remove(col[j]);
			if(dance(deep+1)==1)return 1;
			for(int j=l[i];j!=i;j=l[j]) resume(col[j]);
		}
		resume(c); 
		return 0;
	}
```

推荐几道精确覆盖的题：
[八皇后](https://www.luogu.org/problemnew/show/P1219)
[靶形数独](https://www.luogu.org/problemnew/show/P1074)

注意没有精确覆盖的模版题，要自己转换，把一些条件转换成对应的集合。

没有思路的看看题解[八皇后题解](https://www.luogu.org/blog/ONE-PIECE/solution-p1219)（~~中文不好看完别吐）~~
。靶形数独已经有大佬写的题解了，我就不再献丑了，有需要可以看一下我的代码[靶形数独代码](https://www.luogu.org/blog/ONE-PIECE/ba-xing-shuo-du-dai-ma)

差点忘了，还有重复覆盖。

# 重复覆盖定义：
顾名思意，与精确覆盖差不多，只是可以有元素重复

主要思想：同上（精确覆盖）

## 代码实现：

删除和恢复略有不同
```
inline void del(int c){
    for(int i=d[c];i!=c;i=d[i]){
    l[r[i]]=l[i],r[l[i]]=r[i];	
    }
    }//删除c列 
    inline void res(int c){
        for(int i=u[c];i!=c;i=u[i]){
            l[r[i]]=i,r[l[i]]=i;
        }
    }//恢复c列 
```
dance 部分多了一个剪枝,因为重复覆盖比精确覆盖慢。
```
inline int leave(){
        int ans=0;
        bool vis[m];
        register int i,j,k;
        memset(vis,0,sizeof(vis));
        for(i=r[0];i!=0;i=r[i]){
            if(vis[i]==0){
                vis[i]=1;
                ans++;
                for(j=d[i];j!=i;j=d[j]){
                    for(k=r[j];k!=j;k=r[k])
                    vis[col[k]]=1;
                }
            }
        }
        return ans;
    }//最优情况还要多少个集合
    void dance(int deep){
    //注意：这个剪枝只有在多解情况求最优解时下才用
        if(deep+leave()>=out)return;//剪枝 
        if(r[0]==0){
            out=deep;
            return;
        }
        int c=r[0];
        register int i,j;
        for(i=r[0];i!=0;i=r[i])if(s[i]<s[c])c=i;//找到点最少的列
        for(i=d[c];i!=c;i=d[i]){
            del(i);
            for(j=r[i];j!=i;j=r[j])del(j);
            dance(deep+1);
            for(j=l[i];j!=i;j=l[j])res(j);
            res(i);
        }
        return;
    }//可以看出重复覆盖的效率并不算太高，与深搜差不多，甚至如果深搜剪枝剪得好比dancing links快，谨慎使用
```



洛谷上没找到重复覆盖的题，推荐一道：神龙的难题。

想做的自己去百度

# 万分感谢你们忍着看完了~~这么烂的语文水平写的文章~~

~~祝各位NOIP满分~~

### ~~行行好给个赞吧~~

再附上次模板题的代码：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int mx=250501;//n*m+m<=250500
inline int Read(){
	int x=0;
	char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	return x;
}
int n,m;
int cnt;
int l[mx],r[mx],u[mx],d[mx],col[mx],row[mx];//每个点的左右上下指针，所在行列 
int h[mx];//每行的头结点 
int s[mx];//每列的节点数 
int ansk[mx];//选了那些集合 
void init(int m){//m个元素 
	for(register int i=0;i<=m;i++){
		r[i]=i+1;
		l[i]=i-1;
		u[i]=d[i]=i;
	}
	r[m]=0;
	l[0]=m;
	memset(h,-1,sizeof(h));
	memset(s,0,sizeof(s));
	cnt=m+1;
}//初始化 
inline void link(int R,int C){//R行C列插入点 
	s[C]++;
	row[cnt]=R;
	col[cnt]=C;
	u[cnt]=C;
	d[cnt]=d[C];
	u[d[C]]=cnt;
	d[C]=cnt;
	if(h[R]==-1)h[R]=r[cnt]=l[cnt]=cnt;//该行没有点，直接加入 
	else{
		r[cnt]=h[R];
		l[cnt]=l[h[R]];
		r[l[h[R]]]=cnt;
		l[h[R]]=cnt;
	}
	cnt++;
	return;
}
inline void remove(int C){//删除涉及C列的集合 
	r[l[C]]=r[C],l[r[C]]=l[C];
	for(int i=d[C];i!=C;i=d[i]){
		for(int j=r[i];j!=i;j=r[j]){
			u[d[j]]=u[j];
			d[u[j]]=d[j];
			s[col[j]]--;
		}
	}
}
inline void resume(int C){//恢复涉及C列的集合 
	for(int i=u[C];i!=C;i=u[i]){
		for(int j=l[i];j!=i;j=l[j]){
			u[d[j]]=j;
			d[u[j]]=j;
			s[col[j]]++;
		}
	}
	r[l[C]]=C;
	l[r[C]]=C;
}
bool dance(int deep){
	if(r[0]==0){
		register int i=0;
		for(i=0;i<deep;i++)printf("%d ",ansk[i]);
		return 1;
	}
	int c=r[0];
	int i,j;
	for(i=r[0];i!=0;i=r[i])if(s[i]<s[c])c=i;
	remove(c);
	for(i=d[c];i!=c;i=d[i]){
		ansk[deep]=row[i];
		for(j=r[i];j!=i;j=r[j])remove(col[j]);
		if(dance(deep+1))return 1;
		for(j=l[i];j!=i;j=l[j])resume(col[j]);
	}
	resume(c);
	return 0;
}
int main(){
//	freopen("cin.txt","r",stdin);
	n=Read(),m=Read();
	register int i,j;
	int f;
	init(m);
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			f=Read();
			if(f)link(i,j);
		}
	}
	if(!dance(0))printf("No Solution!");
	return 0;
}
```

---

## 作者：lsr1409111459 (赞：178)

本文所有内容（包括图片）均由 [浩熙](http://lsr2002.com) 制作，未经允许不得转发。

[更好的阅读体验](https://lsr2002.blog.luogu.org/wu-dao-lian)

### 1.舞蹈链

不懂不知道，一懂吓一跳（虽然没有完全懂）。

这个算法/数据结构也太太太太巧妙了吧。

舞蹈链名副其实，确实好看又精巧。

舞蹈链主要解决的是 **精确覆盖问题** 。

#### 1.1 精确覆盖问题

##### 1.1.1 问题定义

给定一个由 $0-1$ 组成的矩阵，问是否可以挑出若干行，使得对于这个行的集合，每一列有且仅有一个 $1$ 出现。[洛谷传送门](https://www.luogu.com.cn/problem/P4929)
$$
\left(
\begin{array}{l}
0 & 0 & 1 & 1 & 0 & 1 & 0 \\
1 & 0 & 0 & 0 & 1 & 0 & 1 \\
0 & 1 & 1 & 0 & 0 & 1 & 0 \\
1 & 0 & 0 & 0 & 1 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 & 1 \\
0 & 1 & 0 & 1 & 1 & 0 & 1 \\
\end{array}
\right)
$$
我们可以观察出行 $1,4,5$ 为一个解。可以利用递归回溯得出这个解。

##### 1.1.2 回溯求解

我们先选择第一行（用蓝色标记），然后将其中 $1$ 所在的列用红色标记，最后将有红色的 $\color{red}1$ 的行用绿色标记。结果如下：
$$
\left(
\begin{array}{l}
\color{blue} 0 & \color{blue} 0 & \color{blue} 1 & \color{blue} 1 & \color{blue} 0 & \color{blue} 1 & \color{blue} 0 \\
1 & 0 & \color{red} 0 & \color{red} 0 & 1 & \color{red} 0 & 1 \\
\color{green} 0 & \color{green} 1 & \color{red} 1 & \color{red} 0 & \color{green} 0 & \color{red} 1 & \color{green} 0 \\
1 & 0 & \color{red} 0 & \color{red} 0 & 1 & \color{red} 0 & 0 \\
0 & 1 & \color{red} 0 & \color{red} 0 & 0 & \color{red} 0 & 1 \\
\color{green} 0 & \color{green} 1 & \color{red} 0 & \color{red} 1 & \color{green} 1 & \color{red} 0 & \color{green} 1 \\
\end{array}
\right)
$$
根据要求，选择蓝色行后，所有绿色行均与其冲突，不能再选择。所以我们删掉上图中所有带颜色的部分，得到如下矩阵：
$$
\left(
\begin{array}{l}
1 & 0 & 1 & 1 \\
1 & 0 & 1 & 0 \\
0 & 1 & 0 & 1 \\
\end{array}
\right)
$$
于是我们得到了规模更小的新的精确覆盖问题。选择次矩阵的第一行（原矩阵的第二行），再按照上述方法进行标记，结果如下：
$$
\left(
\begin{array}{l}
\color{blue} 1 & \color{blue} 0 & \color{blue} 1 & \color{blue} 1 \\
\color{red} 1 & \color{green} 0 & \color{red} 1 & \color{red} 0 \\
\color{red} 0 & \color{green} 1 & \color{red} 0 & \color{red} 1 \\
\end{array}
\right)
$$
再次将所有带颜色的部分删去，得到空矩阵。而此时蓝色行有 $\color{blue}0$ ，说明没有得到解。于是回溯，选择第二行（原矩阵的第四行）：
$$
\left(
\begin{array}{l}
\color{red} 1 & \color{green} 0 & \color{red} 1 & \color{green} 1 \\
\color{blue} 1 & \color{blue} 0 & \color{blue} 1 & \color{blue} 0 \\
\color{red} 0 & 1 & \color{red} 0 & 1 \\
\end{array}
\right)
$$
删掉上图中所有带颜色的部分，得到如下矩阵：
$$
\left(
\begin{array}{l}
1 & 1\\
\end{array}
\right)
$$
选择第一行（原矩阵的第五行），再进行标记，删除，得到空矩阵。而此时蓝色行没有 $\color{blue}0$ ，说明得到一个解。

得到的解为原矩阵的第一行、第四行和第五行。

因此我们可以将该回溯算法总结成如下步骤：

1. 选择当前矩阵的一行。
2. 标记该行，该行元素为 $1$ 的列，被标记的列中含 $1$ 的行。
3. 删除所有标记元素，得到新矩阵。如果新矩阵为空矩阵，跳转到 $4.$ ；否则继续求解，跳转到 $1.$ 。
4. 新矩阵为空矩阵。如果删除的行全为 $1$ ，说明得到一个解，求解结束，跳转到 $5.$ ；否则说明求解失败，跳转到 $6.$ 。
5. 求解结束，得到一个解。输出这个解。
6. 求解失败，回溯到上一个矩阵，选择下一行，跳转到 $1.$ 。如果没有矩阵可以回溯，说明本题无解，跳转到 $7.$ 。
7. 求解结束，本题无解。输出无解信息。

从上述过程来看，我们需要很大的空间来存储缓存和回溯的矩阵。而如何缓存保证数据可以回溯，如何得到对应原矩阵的行的答案等，实现起来较为困难。

#### 1.2 舞蹈链

为了解决精确覆盖问题，高德纳( **Donald Ervin Knuth** )——经典巨著《计算机程序设计的艺术》的年轻作者，提出了 **DLX(Dancing Links X)** 算法。实际上，他提出的算法为 **X算法** ，而舞蹈链则是实现这个算法的高效的数据结构。在介绍舞蹈链的过程中，我们可以发现其巧妙的结构带来的高效的效率，各元素就像在链上舞蹈一般灵巧。

##### 1.2.1 双向链表

在学习数据结构时，我们曾经接触过链表，其巧妙的插入删除操作让我们对其记忆犹新。

为了解决不同的问题，链表又分为单向链表，双向链表，循环链表等等。

其中双向链表，即每个元素含有两个指针，分别指向前面和后面的元素。

比如我们有三个连续的元素 $ABC$ ，则我们可以用： ``A.Right=B B.Right=C B.Left=A C.left=B`` 将其相连。

当我们要删除元素 $B$ 时，我们只需将 $B$ 的左元素的右指针附成 $B$ 的右元素，将 $B$ 的右元素的左指针附成 $B$ 的左元素。即 ``A.Right=C C.Left=A`` 。

值得注意的是，此时 $B$ 这个元素的实体还在，只是其不在链中而已。也就是说，此时仍有 ``B.Right=C B.Left=A`` 。

当我们还想将 $B$ 插回原来的位置时，只需要 ``A.Right=B C.Left=B`` 即可。

再观察上述删除和插入操作，类比上文中的缓存和回溯操作，我们发现其恰好对应，可以灵活运用。而更巧妙的是，它不再需要额外的空间去存储缓存的数据，而是可以直接进行删除和操作，这使得空间复杂度大大降低了。而时间上，插入一个结点和回溯一个矩阵相比也更快了。

另外，我们将双向链表的首尾相连，则得到了 **双向循环链表** ，这在实际应用中是很广泛的。

##### 1.2.2 十字交叉双向循环链表

~~看看这高大上的名字吧。~~

我们分析一下这个名字， 双向循环链表我们已经介绍过了，那这个十字交叉是什么东西？

我们是将若干条双向循环链表十字交叉得到一个类似于矩阵的数据结构。

我们先来分析两条双向循环链表十字交叉是个什么概念。

![](https://cdn.luogu.com.cn/upload/image_hosting/c6qxj3o4.png)

这就是一个十字交叉双向循环链表，其中元素 $B$ 不仅在横向的链中，也在纵向的链中。两条双向循环链十字交叉，交点为元素 $B$ 。

对于交点元素，它的指针便有四个。我们记成 ``B.Left=A B.Right=C B.up=D B.down=E`` 。

##### 1.2.3 舞蹈链

把舞蹈链单独写个小标题只是因为它是重点，并不代表它跟 **十字交叉双向循环链表** 不同。恰恰相反，舞蹈链本质就是一个 **十字交叉双向循环链表** 。

对于上面的样例（怕大家记不住我们把它拿下来）：
$$
\left(
\begin{array}{l}
0 & 0 & 1 & 1 & 0 & 1 & 0 \\
1 & 0 & 0 & 0 & 1 & 0 & 1 \\
0 & 1 & 1 & 0 & 0 & 1 & 0 \\
1 & 0 & 0 & 0 & 1 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 & 1 \\
0 & 1 & 0 & 1 & 1 & 0 & 1 \\
\end{array}
\right)
$$
我们可以构造出如下图的舞蹈链：

![](https://cdn.luogu.com.cn/upload/image_hosting/ptq7rhj5.png)

不用惊慌，我们一步一步分析这个数据结构。

对于上图（下文称作 **DLX** ）中的每个结点，都含有六个元素。可以视为每个结点是 **DLX** 中的一个元素，而每个结点本身又是一个包含六个更细小元素的结构体。这六个元素分别为 $left,right,up,down,row,col$ 。前四个我们上文说过，元素 $row$ 指向该结构体所在的行标，元素 $col$ 指向该结构体所在的列对应的列元素（见下文）。

而对于 **DLX** ，我们将其中的元素分为三种。

第一种为 **DLX** 中的数字，如上图的 $1-17$ ，它们表示原矩阵中的 $1$ 。这也是 **DLX** 中最为重要的结点。因为精确覆盖问题一般给出的都是稀疏图，所以这些结点的个数不会很多。

第二种为 **DLX** 中的列元素，如上图的 $C1-C7$ ，它们是辅助元素，作用是方便 **DLX** 运作。它们的 $row$ 为 $0$ ， $col$ 为本身， $left,right$ 为列元素或 $head$ 元素。

 第三种，或者说第三个为 **DLX** 中的 $head$ 元素，它也是辅助元素，且只有一个，作用也是方便 **DLX** 运作。它没有 $up,down,row,col$ 元素。换句话说，它只有 $left,right$ 元素有用。 

下面我们来具体谈一谈这样一个 **DLX** 究竟是如何工作的。

我们首先给出 **DLX** 的步骤：

1. 判断 ``head.right==head`` 。如果等于，说明求出解，输出答案并返回 ``true``；否则，继续。
2. 取列元素 ``c=head.right`` 。
3. 遍历列元素所在列链，选择一行。
4. 删除与该行链元素冲突的行列，得到一个新的 **DLX** 。
5. 如果新的 **DLX** 中仍有列元素且列链为空，则返回 ``false`` ；否则跳转步骤 $1.$ 。
6. 如果选择该行后未求得解，则回溯到当前状态，选择下一行，跳转步骤 $5.$ 。如果所有行都遍历过仍未求得解，说明之前有行选择错误或无解，返回 ``false`` 。
7. 如果最终函数返回值为 ``false`` ，则输出 ``No Solution!`` 。

下面根据上述步骤进行对样例的模拟：

1.  ``head.right!=head`` ，取 ``c=head.right=1`` ，遍历列元素所在列链（得到元素 $4,10$ ）。

![](https://cdn.luogu.com.cn/upload/image_hosting/0mww0wny.png)

2. 选择元素 $4$ 所在行 $L2$ ，并处理与该行链元素冲突的行列。

![](https://cdn.luogu.com.cn/upload/image_hosting/um1x6ffp.png)

3. 得到新的 **DLX** 。 ``head.right!=head`` 。

![](https://cdn.luogu.com.cn/upload/image_hosting/safn8j3z.png)

4.取 ``c=head.right=2`` ，遍历列元素所在列链（得到元素 $7$ ）。

![](https://cdn.luogu.com.cn/upload/image_hosting/x1l04t3t.png)

5. 选择元素 $7$ 所在行 $L3$ ，并处理与该行链元素冲突的行列。

![](https://cdn.luogu.com.cn/upload/image_hosting/wdcctuld.png)

6. 得到新的 **DLX** ，仍有列元素且列链为空，返回 ``false`` 。（说明没有满足要求的行能覆盖该列）

![](https://cdn.luogu.com.cn/upload/image_hosting/wdcctuld.png)

7. 上图返回模拟步骤 $4.$ ，此时所有行都遍历过仍未求得解，说明之前有行选择错误或无解，返回 ``false`` 。

![](https://cdn.luogu.com.cn/upload/image_hosting/x1l04t3t.png)

8. 上图返回模拟步骤 $1.$ ,列元素所在列链含有元素 $4,10$ ， $4$ 选择过，无解。

![](https://cdn.luogu.com.cn/upload/image_hosting/0mww0wny.png)

9. 选择元素 $10$ 所在行 $L4$ ，并处理与该行链元素冲突的行列。

![](https://cdn.luogu.com.cn/upload/image_hosting/kn9v9rua.png)

10. 得到新的 **DLX** 。 ``head.right!=head`` 。

![](https://cdn.luogu.com.cn/upload/image_hosting/2jvra4fx.png)

11. 取 ``c=head.right=2`` ，遍历列元素所在列链（得到元素 $7,12$ ）。

![](https://cdn.luogu.com.cn/upload/image_hosting/drcmfquh.png)

12. 选择元素 $7$ 所在行 $L3$ ，并处理与该行链元素冲突的行列。

![](https://cdn.luogu.com.cn/upload/image_hosting/8gth9gec.png)

13. 得到新的 **DLX** ，仍有列元素且列链为空，返回 ``false`` 。（说明没有满足要求的行能覆盖该列）

![](https://cdn.luogu.com.cn/upload/image_hosting/l16mngxj.png)

14. 上图返回模拟步骤 $11.$  ,列元素所在列链含有元素 $7,12$ ， $7$ 选择过，无解。

![](https://cdn.luogu.com.cn/upload/image_hosting/drcmfquh.png)

15. 选择元素 $12$ 所在行 $L5$ ，并处理与该行链元素冲突的行列。

![](https://cdn.luogu.com.cn/upload/image_hosting/dj3ic9op.png)

16. 得到新的 **DLX** 。 ``head.right!=head`` 。

![](https://cdn.luogu.com.cn/upload/image_hosting/36s7sx2j.png)

17. 取 ``c=head.right=3`` ，遍历列元素所在列链（得到元素 $1$ ）。

![](https://cdn.luogu.com.cn/upload/image_hosting/4d3yamv4.png)

18. 选择元素 $1$ 所在行 $L1$ ，并处理与该行链元素冲突的行列。

![](https://cdn.luogu.com.cn/upload/image_hosting/ujvgsetd.png)

19.  ``head.right==head`` ，得出解。

![](https://cdn.luogu.com.cn/upload/image_hosting/94bzumrx.png)

20. 输出解： $L4,L5,L1$ 。

#### 1.3 代码讲解

##### 1.3.0 定义

```cpp
struct DLXnode
{
    int Row,Col;
    int Left,Right,Up,Down;
};
int cnt=0;
DLXnode node[6000];//DLX中的所有元素，包括head元素和列元素
int row[510];//每行第一个元素
int ans[510];//记录答案
int lcnt[510];//每列元素个数
```

结构体部分与上文对应。

其中 ``row`` 是为了建 **DLX** 时更方便，一个辅助数组。

 ``lcnt`` 是用来提速的（），具体用法在 ``dance()`` 中会体现。只需记住它记录的是每列的元素个数即可。

##### 1.3.1 初始化

```cpp
void init()
{
    for(int i=0;i<=m;i++)
    {
        node[i].Left=i-1;
        node[i].Right=i+1;
        node[i].Up=i;
        node[i].Down=i;
        lcnt[i]=0;
    }
    node[0].Left=m;
    node[m].Right=0;
    cnt=m;
}
```

初始化的是 $head$ 元素和列元素。将它们的上下左右指针指好，列指针和行指针可以不用。

##### 1.3.2 添加 '1' 结点

```cpp
void addnode(int r,int c)
{
    //修改该结点所在列链
    node[++cnt].Row=r;
    node[cnt].Col=c;
    node[cnt].Up=node[c].Up;
    node[cnt].Down=c;
    node[node[cnt].Up].Down=cnt;
    node[c].Up=cnt;
    //修改该结点所在行链
    if(!row[r])//该结点是其所在行的第一个元素
    {
        node[cnt].Left=cnt;
        node[cnt].Right=cnt;
        row[r]=cnt;
    }
    else//该结点不是其所在行的第一个元素
    {
        node[cnt].Left=node[row[r]].Left;
        node[cnt].Right=row[r];
        node[node[cnt].Left].Right=cnt;
        node[node[cnt].Right].Left=cnt;
    }
    lcnt[c]++;//对应列元素个数++
}
```

##### 1.3.3 删除列元素所在列链及其中元素所对应行

```cpp
void remove(int c) 
{
    for(int i=node[c].Down;i!=c;i=node[i].Down)//枚举列链中元素
        for(int j=node[i].Right;j!=i;j=node[j].Right)//枚举列链中元素所对应行链中元素并删除
        {
            node[node[j].Down].Up=node[j].Up;
            node[node[j].Up].Down=node[j].Down;
            lcnt[node[j].Col]--;
        }
   	//删除列链（仅需删除列元素即可删除整个列链）
    node[node[c].Left].Right=node[c].Right;
    node[node[c].Right].Left=node[c].Left;
}
```

##### 1.3.4 恢复列元素所在列链及其中元素所对应行

```cpp
void resume(int c) 
{
    //恢复列链（仅需恢复列元素即可恢复整个列链）
    node[node[c].Left].Right=c;
    node[node[c].Right].Left=c;
    for(int i=node[c].Down;i!=c;i=node[i].Down)//枚举列链中元素
        for(int j=node[i].Right;j!=i;j=node[j].Right)//枚举列链中元素所对应行链中元素并恢复
        {
            node[node[j].Down].Up=j;
            node[node[j].Up].Down=j;
            lcnt[node[j].Col]++;
        }
}
```

##### 1.3.5 Let's Dance !  !  !

```cpp
bool dance(int dep)//dep表示答案的个数（搜索的层数）
{
    if(node[0].Right==0)//如果head.right==head，说明有解，输出答案
    {
        for(int i=1;i<dep-1;i++)
            printf("%d ",ans[i]);
        printf("%d\n",ans[dep-1]);
        return true;
    }
    int C=node[0].Right;//取列元素 c=head.right 。
    for(int i=node[0].Right;i;i=node[i].Right)//提速（见文字）
    {
        if(lcnt[i]<lcnt[C])
            C=i;
    }
    remove(C);//删除列链
    for(int i=node[C].Down;i!=C;i=node[i].Down)//枚举选择行
    {
        ans[dep]=node[i].Row;
        for(int j=node[i].Right;j!=i;j=node[j].Right)//删除选择行链元素所在列链
            remove(node[j].Col);
        if(dance(dep+1))return true;
        for(int j=node[i].Right;j!=i;j=node[j].Right)//恢复选择行链元素所在列链
            resume(node[j].Col);
    }
    resume(C);//恢复列链
    return false;
}
```

上述提速的枚举，在正常的舞蹈链中可以不加。它的作用仅仅是提速。

但是在洛谷的舞蹈链中，如果不加这个枚举，会 $TLE$ 四个点，就算吸了氧也会 $TLE$ 两个点。

因此我们加了这个提速的枚举。原理是减少搜索树的分叉数。

首先我们知道，取所有列中任意一列进行操作对于结果没有影响，因此我们选择列中元素最少的列，这可以使得搜索树的分叉数大大减少（尤其是当搜索层数较高时）。

另外，代码中 ``remove(C)`` 和 ``resume(C)`` 也可以写在循环中，也就是 ``remove(node[i].Col)`` 和 ``resume(node[i].Col)`` 。但其实删除的都是同一行，所以写在外面可以减少一点点复杂度。不理解的话就背板子（当然也可以问），但最好还是理解理解。

##### 1.3.6 主函数

```cpp
int main()
{
    scanf("%d%d",&n,&m);
    init();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&x);
            if(x==1)addnode(i,j);
        }
    if(!dance(1))printf("No Solution!\n");
    return 0;
}
```

没什么好讲的，如果上面所有内容都理解了，这个主函数肯定能看懂。

### 2. 参考博客
[跳跃的舞者，舞蹈链（Dancing Links）算法——求解精确覆盖问题](https://www.cnblogs.com/grenet/p/3145800.html)

---

## 作者：无意识躺枪人 (赞：47)

发现其它题解都没给图，专门过来发一下这个很经典的图解
[$\text{（参考博客）}$](https://www.cnblogs.com/grenet/p/3145800.html)

------------

# $$\Huge\color{black}\text{常规解法}$$



对于一个矩阵

![](https://cdn.luogu.com.cn/upload/pic/49052.png)

选定它的第一行，将其标为红色，这行的“1”对应的列标为蓝色，蓝色部分的“1”对应的行标为紫色

![](https://cdn.luogu.com.cn/upload/pic/49053.png)

然后删去标了颜色的数字，变成了这样

![](https://cdn.luogu.com.cn/upload/pic/49054.png)

同理，重复上述操作

![](https://cdn.luogu.com.cn/upload/pic/49055.png)

发现得到了一个空矩阵，说明矩阵不合法，回溯，选择第二行

![](https://cdn.luogu.com.cn/upload/pic/49056.png)

删去有颜色的数字，得到新矩阵

![](https://cdn.luogu.com.cn/upload/pic/49057.png)

由于剩下的矩阵只有1行，且都是1，选择这一行即可

也就是应该选择原矩阵1中的第1、4、5行

```
1、从矩阵中选择一行

2、根据定义，标示矩阵中其他行的元素

3、删除相关行和列的元素，得到新矩阵

4、如果新矩阵是空矩阵，并且之前的一行都是1，那么求解结束，跳转到6；新矩阵不是空矩阵，继续求解，跳转到1；新矩阵是空矩阵，之前的一行中有0，跳转到5

5、说明之前的选择有误，回溯到之前的一个矩阵，跳转到1；如果没有矩阵可以回溯，说明该问题无解，跳转到7

6、求解结束，把结果输出

7、求解结束，输出无解消息
```


------------

# $$\Huge\color{black}\text{DLX算法}$$

Dancing Links的核心是基于双向链的方便操作（移除、恢复加入）

Dancing Links用的数据结构是**交叉十字循环双向链**

而Dancing Links中的每个元素不仅是横向循环双向链中的一份子，又是纵向循环双向链的一份子。

因为精确覆盖问题的矩阵往往是稀疏矩阵（矩阵中，0的个数多于1），**Dancing Links仅仅记录矩阵中值是1的元素**

![](https://cdn.luogu.com.cn/upload/pic/49058.png)

每个绿色方块是一个元素，其中Head和C1、C2、……、C7是辅助元素。橙色框中的元素是原矩阵中1的元素，给他们标上号（从1到16）

左侧的红色，标示的是行号，辅助元素所在的行是0行，其余元素所在的行从1到6

每两个元素之间有一个双向箭头连线，表示双向链中相邻两个元素的关系（水平的是左右关系、垂直的是上下关系）

单向的箭头并不是表示单向关系，而因为是循环双向链，左侧的单向箭头和右侧的单向箭头（上边的和下边的）组成了一个双向箭头，例如元素14左侧的单向箭头和元素16右侧的单项箭头组成一个双向箭头，表示14.Left=16、16.Right=14；同理，元素14下边的单项箭头和元素C4上边的单向箭头组成一个双向箭头，表示14.Down=C4、C4.Up=14

接下来，利用图来解释Dancing Links是如何求解精确覆盖问题

1、首先判断Head.Right=Head？若是，求解结束，输出解；若不是，求解还没结束，到步骤2（也可以判断Head.Left=Head？）

2、获取Head.Right元素，即元素C1，并标示元素C1（标示元素C1，指的是标示C1、和C1所在列的所有元素、以及该元素所在行的元素，并从双向链中移除这些元素）。如下图中的紫色部分。

![](https://cdn.luogu.com.cn/upload/pic/49059.png)

如上图可知，行2和行4中的一个必是答案的一部分（其他行中没有元素能覆盖列C1），先假设选择的是行2

 

3、选择行2（在答案栈中压入2），标示该行中的其他元素（元素5和元素6）所在的列首元素，即标示元素C4和标示元素C7，下图中的橙色部分。

注意的是，即使元素5在步骤2中就从双向链中移除，但是元素5的Col分量还是指向元素C4的，这里体现了双向链的强大作用。

![](https://cdn.luogu.com.cn/upload/pic/49060.png)

把上图中的紫色部分和橙色部分移除的话，剩下的绿色部分就如下图所示

![](https://cdn.luogu.com.cn/upload/pic/49061.png)

一下排除了很多元素，这样就转换为一个少了很多元素的精确覆盖问题，利用递归，很快就能写出求解的过程

DLX的流程：

```
1、Dancing函数的入口

2、判断Head.Right=Head？，若是，输出答案，返回True，退出函数。

3、获得Head.Right的元素C

4、标示元素C

5、获得元素C所在列的一个元素

6、标示该元素同行的其余元素所在的列首元素

7、获得一个简化的问题，递归调用Daning函数，若返回的True，则返回True，退出函数。

8、若返回的是False，则回标该元素同行的其余元素所在的列首元素，回标的顺序和之前标示的顺序相反

9、获得元素C所在列的下一个元素，若有，跳转到步骤6

10、若没有，回标元素C，返回False，退出函数。
```



代码实现：（DLX代码模板）

```c
struct DLX
{
    int n,sz;
    int s[maxn];
    int row[maxnode],col[maxnode];
    int L[maxnode],R[maxnode],U[maxnode],D[maxnode];
    int ansd,ans[maxnode];
    void init(int n)//初始化，0为超级节点，1~n为每列的虚拟节点
    {
        this->n=n;
        sz=n+1;
        memset(s,0,sizeof(s));
        for(int i=0;i<=n;i++)
            { U[i]=i; D[i]=i; L[i]=i-1; R[i]=i+1; }
        R[n]=0;L[0]=n;
    }
    void addNodes(int r,const vector<int> &columns)
    {//在第r行（最后一行）添加这些节点
        int first=sz,c_sz=columns.size();
        for(int i=0;i<c_sz;i++)
        {
            int c=columns[i];
            L[sz]=sz-1; R[sz]=sz+1; D[sz]=c; U[sz]=U[c];
            D[U[c]]=sz; U[c]=sz;
            row[sz]=r; col[sz]=c;
            s[c]++;sz++;
        }
        R[sz-1]=first; L[first]=sz-1;
    }
    #define For(i,A,s) for(int i=A[s];i!=s;i=A[i])
    void remove(int c)//覆盖第c个目标
    {
        L[R[c]]=L[c];
        R[L[c]]=R[c];
        For(i,D,c)
            For(j,R,i)//撕开所有相关节点
            { U[D[j]]=U[j]; D[U[j]]=D[j]; --s[col[j]]; }
    }
    void restore(int c)
    {//复原
        For(i,U,c)
            For(j,L,i)
            { ++s[col[j]]; U[D[j]]=j; D[U[j]]=j; }
        L[R[c]]=c;
        R[L[c]]=c;
    }
    bool dfs(int d)
    {
        if(R[0]==0)
        {
            ansd=d;
            return true;
        }
        int c=R[0];
        For(i,R,0) if(s[i]<s[c]) c=i;
        remove(c);
        For(i,D,c)
        {
            ans[d]=row[i];
            For(j,R,i) remove(col[j]);//为了确保只覆盖一次
            if(dfs(d+1)) return true;
            For(j,L,i) restore(col[j]);//回溯
        }
        restore(c);//回溯
        return false;
    }
    bool solve(vector<int> &v)//对外接口
    {
        v.clear();
        if(!dfs(0)) return false;
        for(int i=0;i<ansd;i++) v.push_back(ans[i]);
        return true;
    }
};
```



DLX的一次操作如下：（不含回溯）


![](https://cdn.luogu.com.cn/upload/pic/49062.png)

![](https://cdn.luogu.com.cn/upload/pic/49063.png)

![](https://cdn.luogu.com.cn/upload/pic/49064.png)

主函数和操作上面的dalao都写得很详细了，便不再重复qwq


---

## 作者：Rainy7 (赞：34)

- **前言**

  >挖坑，开始填。--2021/04/26
  >
  >填完了（？竟然没鸽。） --2021/04/27
  >
  >**upd 2022/01/24:** 因为某句话描述的有问题，造成了一些误解。感谢 @[_Felix](https://www.luogu.com.cn/user/106738) 
  
  《关于我不想搞 whk 于是就来写博客这件事。》
  
  不是什么鬼啊喂。
  
  **如果有不足的地方欢迎随时指出**，然后求赞（？）。

------------

- **DLX 是什么**

  **D**ancing **L**inks **X** 即舞蹈链是一种高效的数据结构，用来优化一些搜索。

  处理的问题主要包括 $2$ 种类型，一类是**精确覆盖问题**，另一类是**重复覆盖问题**。
  
  那么接下来先给出**精确覆盖问题**的模板题，即[洛谷 P4929 【模板】舞蹈链（DLX）](https://www.luogu.com.cn/problem/P4929)。
  
  >给定一个 $n$ 行 $m$ 列的矩阵，矩阵中每个元素要么是 $1$ ，要么是 $0$ 。
  >
  >你需要在矩阵中挑选出若干行，使得对于矩阵的每一列 $j$ ，在你挑选的这些行中，**有且仅有**一行的第 $j$ 个元素为 $1$ 。
  
  首先易得，大暴搜的复杂度是 $\mathcal{O}(m\cdot2^n)$
  
  实际上，**这属于 NP 完全问题**，也就是没有多项式算法。
  
  但是 DLX 却可以在大大提高搜索的效率，在本题中，可以解决的范围为 $n,m \le 500$ ，其中保证矩阵中 $1$ 的数量不超过 $5000$ 个。
  
  **重复覆盖问题**类似，只有两点不同。下边已加粗。
  
  由于洛谷并没有重复覆盖模板题，所以以下给出模板问题：

  >给定一个 $N$ 行 $M$ 列的矩阵，矩阵中每个元素要么是 $1$ ，要么是 $0$ 。
  >
  >你需要在矩阵中选择若干行，使每一列都**至少**包含一个 $1$ ，并且要求**选择的行数最少**。

------------

- **十字链表**

  专门用来 DLX 的东西，属于前置知识。
  
  ~~顾名思义，~~ 十字样子的链表。**下面用 $row_i$ 表示行 $col_j$ 表示列。**
  
  以下是十字链表初始状态 ~~，什么中间太空了放点东西好耶~~ 。
  
  ![](https://i.loli.net/2021/04/26/ePdQVaDjYG7NwJ4.png)
  
  接下来，因为我不喜欢这个样例，所以我手造一个来讲吧。
  
  ```
  1 0 0
  0 1 0
  1 0 1
  ```
  
  首先加上第一个点 $(1,1)$ 。
  
  ![](https://i.loli.net/2021/04/26/psQuXTvYJocfnWL.png)
  
  同理，加上点 $(2,2)$ 和 $(3,3)$ 。
  
  ![](https://i.loli.net/2021/04/26/Qnb8qxPcRmYtEX1.png)
  
  然后加上 $(3,1)$ 。
  
  ![](https://i.loli.net/2021/04/26/yS57XrATOf8CkZb.png)
  
  删除的时候，类似把上面的图倒着看（？）。
  
  这些就是十字链表的要用的知识了。下面进入正题。

------------

- **精确覆盖问题**

  首先，先来考虑大暴搜如何优化。
  
  给定一个矩阵。
  
  ```
  1 1 1 0 0 0 0
  0 0 1 1 1 0 1
  0 0 0 1 1 1 1
  1 0 0 0 1 1 1
  0 0 0 1 1 0 0
  ```
  
  比如我们首先选了第 $1$ 行，然后发现第一行的前 $3$ 列都是 $1$ 。
  
  那么我们肯定**不能再选含有前 $3$ 列为 $1$ 的行**，也就是第 $2,4$ 行。
  
  ![](https://i.loli.net/2021/04/26/plKMGcNJgm7wv65.png)
  
  那么我们**将他们一起删除。**
  
  ![](https://i.loli.net/2021/04/26/C2SIibMc1eTQjKY.png)
  
  那么接下来也就同理了。
  
  当**所有列都被删后**，就可以判定有解并且返回了。
  
  所以接下来的问题就是如何高效判断要删除的行。
  
  很自然的想到了十字链表 ~~（因为他是前置知识）~~ ，每次删除时，**在对应一列下去的把每个点对应一横溜过去的每个点都删掉。**
  
  所以可以发现，DLX 的效率和 $1$ 数量有关。
  
  此外，每次找行是，**我们优先选择 $1$ 最多的行**
  
  另外，因为是在 dfs 中，所以**回溯的时候要把删的点在加回去。**

  现在放出代码。
  
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
const int Maxn=5000+500+10;
int n,m,l[Maxn],r[Maxn],u[Maxn],d[Maxn];// 十字链表左右上下
int idx,ansn,ans[Maxn],s[Maxn],row[Maxn],col[Maxn];
void init() // 预处理 
{	
	for(int i=0;i<=m;i++)
	{	
		l[i]=i-1;r[i]=i+1;
		u[i]=d[i]=i; 
	}
	l[0]=m;r[m]=0; // 注意十字链表是收尾相接 
	idx=m+1;
}
void add(int &hd,int &tl,int x,int y) // 十字链表加点 
{	
	row[idx]=x;col[idx]=y;s[y]++;
	u[idx]=y;d[idx]=d[y];u[d[y]]=idx;d[y]=idx;
	r[hd]=l[tl]=idx;r[idx]=tl;l[idx]=hd;
	tl=idx++;
}
void remove(int p) // 删除 
{	
	r[l[p]]=r[p];l[r[p]]=l[p];
	for(int i=d[p];i!=p;i=d[i])
		for(int j=r[i];j!=i;j=r[j])
		{	
			s[col[j]]--;
			u[d[j]]=u[j];d[u[j]]=d[j];
		}
}
void resum(int p) // 复原 
{	
	for(int i=u[p];i!=p;i=u[i])
		for(int j=l[i];j!=i;j=l[j])
		{	
			u[d[j]]=j;d[u[j]]=j;
			s[col[j]]++;
		}
	r[l[p]]=p;l[r[p]]=p;
}
bool dfs()
{	
	if(!r[0])return 1;
	int p=r[0];
	for(int i=r[0];i;i=r[i])
		if(s[i]<s[p])p=i; // 优先选择 1 最多的行
	remove(p);
	for(int i=d[p];i!=p;i=d[i])
	{	
		ans[++ansn]=row[i];
		for(int j=r[i];j!=i;j=r[j])remove(col[j]);
		if(dfs())return 1;
		for(int j=l[i];j!=i;j=l[j])resum(col[j]);
		ansn--;
	}
	resum(p);
	return 0;
}
int main()
{	
	scanf("%d%d",&n,&m);
	init();
	for(int i=1;i<=n;i++)
	{	
		int hd=idx,tl=idx;
		for(int j=1;j<=m;j++)
		{	
			int x;
			scanf("%d",&x);
			if(x)add(hd,tl,i,j);
		}
	}
	if(dfs())
		for(int i=1;i<=ansn;i++)
			printf("%d ",ans[i]);
	else printf("No Solution!");
	printf("\n");
	return 0;
}
```

------------

- **重复覆盖问题**

  解决方法和精确覆盖类似，**但有前置知识 IDA\* 算法。** 建议没有学过的先去补一下。
  
  因为是至少一个 $1$ ，所以同一列存在多个 $1$ 是合法的。
  
  换句话说，**就相当于我们之前的同时删除多个行的做法，不 行 了 。**
  
  那么就相当于之前找列也没意义了，因为每一列都有可能。
  
  所以我们简单改一下代码。
  
  首先是修改和恢复部分，**不再需要删除一列过去的点。**
  
  每次优先找到 $1$ 最多的列时，也不再需要删除这一列了。
  
  但是这样效率明显差很多了。
  
  于是我们考虑类似 IDA* 来搞。
  
  先用一个数组 $tot$ 来从小到大枚举要的行数，在 dfs 中用一个估价函数，**估一下目前还要多少行**，如果当前行数加上估价函数大于 $tot$ 返回无解即可。
  
  而估价函数呢，用贪心技数下就可以了。
  
  具体详见代码。
  
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
const int Maxn=10000+5;
int n,m,l[Maxn],r[Maxn],u[Maxn],d[Maxn],s[Maxn];
int idx,tot,ans[Maxn],col[Maxn],row[Maxn];
bool st[Maxn];
void init()
{	
	for(int i=0;i<=m;i++)
	{	
		l[i]=i-1;r[i]=i+1;
		u[i]=d[i]=col[i]=i;
		s[i]=0;
	}
	l[0]=m;r[m]=0;
	idx=m+1;
}
int h() //估价函数 
{	
	int cnt=0;
	memset(st,0,sizeof(st));
	for(int i=r[0];i;i=r[i])
	{	
		if(st[col[i]])continue;
		cnt++;
		st[col[i]]=1;
		for(int j=d[i];j!=i;j=d[j])
			for(int k=r[j];k!=j;k=r[k])
				st[col[k]]=1;
	}
	return cnt;
} 
void add(int &hd,int &tl,int x,int y)
{	
	row[idx]=x;col[idx]=y;s[y]++;
	u[idx]=y;d[idx]=d[y];u[d[y]]=idx;d[y]=idx;
	r[hd]=l[tl]=idx;r[idx]=tl;l[idx]=hd;
	tl=idx++;
}
void remove(int p) // 注意列并不会删除 
{	
	for(int i=d[p];i!=p;i=d[i])
		r[l[i]]=r[i],l[r[i]]=l[i];
}
void resum(int p) // 同上 
{	
	for(int i=u[p];i!=p;i=u[i])
		r[l[i]]=i,l[r[i]]=i;
}
bool dfs(int k)
{	
	if(k+h()-1>tot)return 0;
	if(!r[0])return 1;
	int p=r[0];
	for(int i=r[0];i;i=r[i])
		if(s[p]>s[i])p=i;
	// 注意选完列，p 所在的列并不会删除。 
	for(int i=d[p];i!=p;i=d[i])
	{	
		ans[k]=row[i];
		remove(i);
		for(int j=r[i];j!=i;j=r[j])remove(j);
		if(dfs(k+1))return 1;
		for(int j=l[i];j!=i;j=l[j])resum(j);
		resum(i);
	}
	return 0;
}
int main()
{	
	scanf("%d%d",&n,&m);
	init();
	for(int i=1;i<=n;i++)
	{	
		int hd=idx,tl=idx;
		for(int j=1;j<=m;j++)
		{	
			int x;
			scanf("%d",&x);
			if(x)add(hd,tl,i,j);
		}
	}
	tot=0;
	while(!dfs(1))tot++;
	printf("%d\n",tot);
	for(int i=1;i<=tot;i++)
		printf("%d ",ans[i]);
	return 0;
}
```

------------

- **DLX 的练习题**

  这是我之前整理的一份题单：[「舞蹈链DLX」の 学习题单](https://www.luogu.com.cn/training/57092) 。
  
  但是因为我题刷的少，见识也少，题单里的题数不多，还有 $2,3$ 题几乎是多倍经验。
  
  但题单是处于持续更新状态，**如果往后做题还碰到，会不定期的补充，也欢迎大家来补充。**
  
  下面举例两个例题。

------------

- **SP1110 SUDOKU - Sudoku**

  题目链接：[Link.](https://www.luogu.com.cn/problem/SP1110)
  
  >一个数独的网格是由 $16 \times 16$ 个小格组成的, 这些小格又被分为 $4 \times 4=16$ 个小组, 一些小格填入了从 $A$ 至 $P$ (字母表前 $16$ 个)的字母，不过一般填成数字。

  >游戏目的是将所有小格填满，而使每行，每列和每个$4 \times 4$ 小组中不重复的包含这 $16$ 个字母。

  >给出的初始状态满足以上要求且满足唯一解。
  
  ~~说真的，做舞蹈链的题，你首先不能把他当矩阵看（~~
  
  数独是真的算很经典的题了。
  
  首先我们简化一下题目，对于一个 $16 \times 16$ 的矩阵，每一行必须有 $1-16$ ，每一列必须有 $1-16$ ，每一 $16$ 宫格必须有 $1-16$ 。
  
  再换个说法，比如我们**定义一个 $(i,j,k) \in \{ 0,1 \}$ ，表示位于 $(i,j)$ 填的数字是否 $k$ 。**
  
  也就是，对于一个 $16 \times 16$ 的矩阵，每一行都**必须满足对于每个 $k$ ，存在一个为 $1$ ，** 每一列都必须满足对于每个 $k$ ，存在一个为 $1$ ，每一宫格都必须满足对于每个 $k$ ，存在一个为 $1$ 。
  
  发现这就是个 DLX 精确覆盖问题。
  
  那么问题解决了。具体代码细节如下：
  
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
const int Maxn=20000;
struct node{
	int x,y;
	char c;
}op[Maxn];
int m=16*16*4,l[Maxn],r[Maxn],u[Maxn],d[Maxn];// 十字链表左右上下
int idx,ansn,ans[Maxn],s[Maxn],row[Maxn],col[Maxn];
char c[20][20];
void init() // 预处理 
{	
	for(int i=0;i<=m;i++)
	{	
		l[i]=i-1;r[i]=i+1;s[i]=0;
		u[i]=d[i]=i;
	}
	l[0]=m;r[m]=0;
	idx=m+1;
}
void add(int &hd,int &tl,int x,int y)
{	
	row[idx]=x;col[idx]=y;s[y]++;
	u[idx]=y;d[idx]=d[y];u[d[y]]=idx;d[y]=idx;
	r[hd]=l[tl]=idx;r[idx]=tl;l[idx]=hd;
	tl=idx++;
}
void remove(int p)
{	
	r[l[p]]=r[p];l[r[p]]=l[p];
	for(int i=d[p];i!=p;i=d[i])
		for(int j=r[i];j!=i;j=r[j])
		{	
			s[col[j]]--;
			u[d[j]]=u[j];d[u[j]]=d[j];
		}
}
void resum(int p)
{	
	for(int i=u[p];i!=p;i=u[i])
		for(int j=l[i];j!=i;j=l[j])
		{	
			u[d[j]]=j;d[u[j]]=j;
			s[col[j]]++;
		}
	r[l[p]]=p;l[r[p]]=p;
}
bool dfs()
{	
	if(!r[0])return 1;
	int p=r[0];
	for(int i=r[0];i;i=r[i])
		if(s[i]<s[p])p=i;
	remove(p);
	for(int i=d[p];i!=p;i=d[i])
	{	
		ans[++ansn]=row[i];
		for(int j=r[i];j!=i;j=r[j])remove(col[j]);
		if(dfs())return 1;
		for(int j=l[i];j!=i;j=l[j])resum(col[j]);
		ansn--;
	}
	resum(p);
	return 0;
}
void w()
{	
	memset(r,0,sizeof(r));memset(u,0,sizeof(u));
	memset(l,0,sizeof(l));memset(u,0,sizeof(u));
	memset(s,0,sizeof(s));
	memset(col,0,sizeof(col));
	memset(row,0,sizeof(row));
}
int main()
{	int T,cases=0;
	scanf("%d",&T);
	while(T--)
	{	
		for(int i=0;i<16;i++)
			scanf("%s",c[i]);
		if(cases)printf("\n");
		cases++;
		w();
		init();
		for(int i=0,n=1;i<16;i++)
			for(int j=0;j<16;j++)
			{	
				int a=0,b=15;
				if(c[i][j]!='-')a=b=c[i][j]-'A';
				for(int k=a;k<=b;k++,n++)
				{	
					int hd=idx,tl=idx;
					op[n].x=i;op[n].y=j;op[n].c=k+'A';
					add(hd,tl,n,i*16+j+1);
					add(hd,tl,n,256+i*16+k+1);
					add(hd,tl,n,256*2+j*16+k+1);
					add(hd,tl,n,256*3+(i/4*4+j/4)*16+k+1);
				}
			}
		dfs();
		for(int i=1;i<=ansn;i++)
			c[op[ans[i]].x][op[ans[i]].y]=op[ans[i]].c;
		for(int i=0;i<16;i++)
			printf("%s\n",c[i]);
	}
	return 0;
}
```

------------

- **UVA1603 破坏正方形 Square Destroyer**

  ~~这篇我甚至写过题解那就直接复制过来嗯就这样。~~
  
  题目链接：[Link.](https://www.luogu.com.cn/problem/UVA1603)
  
  >一个 $n \times n$ 的网格，共 $2 \times n \times (n + 1)$ 条边，现在已经删除了一些边，问至少还需删去多少边，以使得剩下的边不能构成正方形。
  
    一个正方形有 $4$ 条边（每条边若干火柴），选择一根火柴就可以破坏掉正方形。但是也可以选择多根。
  
  要保证**每个正方形**内部**至少有一根火柴被选择**，且要求**选择火柴数量最少**。
  
  再想想重复覆盖问题。
  
  很明显，这是一道**重复覆盖问题。**
  
  接下来就是如何构建了。
  
  首先，把这些火柴抽象成 $2n(n+1)$ 个点。
  
  然后每根火柴和**所在边长为 $len (1 \le len \le n)$ 的矩形的边上所有火柴**连起来。

  如下图：(举例点 $1$
  
  ![](https://s3.ax1x.com/2021/02/27/6pbhNV.png)
  
  具体细节见代码，以下为代码：
  
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<vector> 
#include<algorithm>
using namespace std;
const int Maxn=3600+5;
int T,n,m,l[Maxn],r[Maxn],u[Maxn],d[Maxn],s[Maxn];
int idx,tot,ans[Maxn],col[Maxn],row[Maxn];
bool st[Maxn]; // 1.作为估价函数 2.作为建图 
vector<int> sq[60];
void init()
{	
	for(int i=0;i<=m;i++)
	{	
    	l[i]=i-1;r[i]=i+1;
		u[i]=d[i]=col[i]=i;
		s[i]=0;
	}
	l[0]=m;r[m]=0;
	idx=m+1;
}
int h() //估价函数 
{	
	int cnt=0;
	memset(st,0,sizeof(st));
	for(int i=r[0];i;i=r[i])
	{	
    	if(st[col[i]])continue;
		cnt++;
		st[col[i]]=1;
		for(int j=d[i];j!=i;j=d[j])
			for(int k=r[j];k!=j;k=r[k])
				st[col[k]]=1;
	}
	return cnt;
} 
void add(int &hd,int &tl,int x,int y)
{	
	row[idx]=x;col[idx]=y;s[y]++;
	u[idx]=y;d[idx]=d[y];u[d[y]]=idx;d[y]=idx;
	r[hd]=l[tl]=idx;r[idx]=tl;l[idx]=hd;
	tl=idx++;
}
void remove(int p)
{	
	for(int i=d[p];i!=p;i=d[i])
		r[l[i]]=r[i],l[r[i]]=l[i];
}
void resum(int p)
{	
	for(int i=u[p];i!=p;i=u[i])
		r[l[i]]=i,l[r[i]]=i;
}
bool dfs(int k)
{	
	if(k+h()-1>tot)return 0;
	if(!r[0])return 1;
	int p=r[0];
	for(int i=r[0];i;i=r[i])
		if(s[p]>s[i])p=i;
	for(int i=d[p];i!=p;i=d[i])
	{	
		ans[k]=row[i];
		remove(i);
		for(int j=r[i];j!=i;j=r[j])remove(j);
		if(dfs(k+1))return 1;
		for(int j=l[i];j!=i;j=l[j])resum(j);
		resum(i);
	}
	return 0;
}
int main()
{	
	scanf("%d",&T);
	while(T--)
	{	
		int k;
		scanf("%d%d",&n,&k);
		m=idx=0;
		memset(st,0,sizeof(st));
		memset(col,0,sizeof(col));
		for(int i=1;i<=k;i++)
		{	
			int x;
			scanf("%d",&x);
			st[x]=1;
		}
		for(int len=1;len<=n;len++)
			for(int x=1;x+len-1<=n;x++)
				for(int y=1;y+len-1<=n;y++)
				{
					m++;
					sq[m].clear();
					int dd=n*2+1;//一行过去(横n加上竖n+1)个数
					for(int i=0;i<len;i++) //向一个矩形的 4 边(上下左右)连去 
					{	
						sq[m].push_back((x-1)*dd+y+i); //上 
						sq[m].push_back((x-1)*dd+y+i+dd*len); //下 
						sq[m].push_back((x-1)*dd+y+n+i*dd); //左 
						sq[m].push_back((x-1)*dd+y+n+i*dd+len); //右 
					}
					for(int i=0;i<sq[m].size();i++) //相连的边有一个断了,直接删除所有即可 
						if(st[sq[m][i]]){m--;break;}
				}
		init();
		for(int i=1;i<=n*(n+1)*2;i++) //全部边
			if(!st[i])
			{	
				int hh=idx,tl=idx;
				for(int j=1;j<=m;j++)
					if(find(sq[j].begin(),sq[j].end(),i)!=sq[j].end()) //连边存在 
						add(hh,tl,i,j);
			} 
		tot=0;
		while(!dfs(1))tot++;
		printf("%d\n",tot);
	}
	return 0;
}
```

------------

$$\text{by Rainy7}$$
  

---

## 作者：Setsugesuka (赞：34)

看到没有人写题解，蒟蒻我就想要来刷一发QWQ(很想过审核的说QAQ)



------------
- ## 关于精确覆盖问题

首先，我们来考虑如下的一个问题：

　　给定一个 $m$ 行，$n$ 列的矩阵，矩阵中只有 $0$ 或 $1$ 两种数字。找到最少的行数，使得对于矩阵的每一列 $j$，在你挑选的这些行中，有且仅有一行的第 $j$ 个元素为 $1$ 。

　　$(n,m)$ $\leq$ $15$
  
不难发现，对于$\leq$ $15$的数据，我们可以直接采用穷举法。对于每一行，都有取或不取两种操作，所以最大的操作数也只有 $ 2 $^$ 15 $次，即使代码再丑，吸一口氧气也总归是能够过的。

　　那么当$(n,m)$ $\leq$ $50$的时候呢？
  
这时候我们发现，$ 2 $^$ 50 $次肯定是会爆炸的，难道我们要用状态压缩DP来处理这道题吗？可以是可以，但是对于我这种菜的一批的蒟蒻来说，肯定是不行的(不会写状压QAQAQAQAQAQ.jpg)。那么，这个时候，我们考虑一些更加高级的搜索。


------------
- ## 搜索与回溯

在初学OI的时候，相信大家都学过深度优先搜索，在深度优先搜索中，有一个很重要的思想就是回溯。那么，对于精确覆盖问题，我们能不能也采用这个策略呢？答案是可以的。让我们来看一看回溯的过程。

　　首先我们假设拥有以下一个矩阵：
  
　　　$1$　$0$　$0$　$1$
  
　　　$0$　$1$　$0$　$0$
      
　　　$1$　$0$　$1$　$1$
   
　　　$0$　$0$　$1$　$0$

显然，我们首先会选择第一行，然后选择第二行，再选择第三行，发现并不行，于是我们返回到选择第二行的时候，重新选择第四行，成功发现了答案。事实上，在小规模的数据上，与暴力并没有太大的差异。但是当数据很大的时候，回溯显然能更快地求出答案(但是时间复杂度完全是玄学)。由此，我们得到了一个实现 $X$ 算法的思路。但是，我们思考刚刚描述的过程，我们选择前三行发现不行是因为我们发现了在一列上有了多个 $1$ 。那么，我们能不能在找寻下一行的时候，就删除掉一些显然不会被选取行呢？答案是可行的。


------------

- ## X算法

我们用Markdown的表格来先生成一个矩阵。(QAQ蒟蒻我不会插图片,手写的又丑)

| $0$ | $1$ | $0$ | $0$ | $0$ | $1$ | $0$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $0$ | $0$ | $1$ | $1$ | $1$ | $0$ |
| $0$ | $1$ | $1$ | $0$ | $0$ | $0$ | $1$ |
| $1$ | $0$ | $0$ | $1$ | $0$ | $0$ | $1$ |
| $1$ | $0$ | $0$ | $1$ | $0$ | $0$ | $0$ |
| $0$ | $0$ | $1$ | $0$ | $1$ | $0$ | $1$ |

考虑如上的算法，首先，我们选取了第一行，在第一行中，第二列与第六列是 $1$ 我们标记上第二列与第六列，然后对于这两列，从头往下算，找到这两列同样是 $1$ 的行并删除它。在上图中，我们会删除掉第二第三行，得到一个 $3$ x $5$的矩阵：

| $1$ | $0$ | $1$ | $0$ | $1$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $0$ | $1$ | $0$ | $0$ |
| $0$ | $1$ | $0$ | $1$ | $1$ |

之后，我们选择第一行，按照如上规则，删去行后，发现矩阵空了，但是我们只得到了 $5$ 个 $1$ 。这显然是不对的，于是我们回溯一步，选择第二行，按照如上规则删除，最后会剩下 $3$ 个 $1$ ，符合我们的题意。

以上的过程，就是 $X$ 算法。

------------
- ## 考虑存图方法

我们思考如何来储存这张图，如果直接用二维矩阵的话。删除操作和回溯操作都会用掉很大的空间和时间，这显然是十分不妥的。我们考虑上文写到的算法描述，快速删除一个元素，链表就能实现，那么如何实现回溯呢？其实很简单，我们在删除的时候，不删除这个点的空间，只是把这个点给“忽略”了。回溯的时候，只需要把与这个点相连的指针恢复回来就可以了。因此，我们在这里引入十字交叉双向循环链表。这种链表结构的每个结点有两类数据，分别为指针域和数据域。指针域为left、right、up、down，分别指向左、右、上、下四个其它结点，数据域则是这个结点对应于原始矩阵的行编号rowIdx，列编号colIdx。对于复杂的问题，数据域可能还会有更多的内容。

```cpp
struct DLXnode{
    int r,c;
    DLXnode *U,*D,*L,*R;
};
```

那么，如何将一个矩阵变为一个十字交叉双向循环链表呢？在DLX中，我们引入额外节点来维护这个结构，它们分别是：

1. 总表头head，将列与行串起来，实现更快的删除，插入等操作，同时为判断矩阵为空提供了便利。
2. 列首数组col，维护每一列的元素。
3. 行首节点row，维护每一行的元素。
4. 元素节点node，也就是在这个矩阵中的普通节点。

>在这里引用一下大佬的一篇博客，如果我的上述形容没有很好地让你听懂，你可以去看《[跳跃的舞者，舞蹈链（Dancing Links）算法——求解精确覆盖问题](https://www.cnblogs.com/grenet/p/3145800.html)》这一篇文章，写的非常好，图解非常详细(特别是相对于我这个渣题解)。看了他的介绍可以让你更好地理解以下代码(我这个题解的唯一优势可能就在于我这个是C++了QAQ)。

那么，很显然，当我们得到行数和列数时，就可以直接初始化了
```cpp
void init(int r,int c){
    cnt=0;
    head.r=r;
    head.c=c;
    head.L=head.R=head.U=head.D=&head;
    for(int i=0;i<c;i++){
        col[i].r=r;
        col[i].c=i;
        col[i].L=&head;
        col[i].R=head.R;
        col[i].L->R=col[i].R->L=&col[i];
        col[i].U=col[i].D=&col[i];
        sz[i]=0;
    }
    for(int i=r-1;i>-1;i--){
        row[i].r=i;
        row[i].c=c;
        row[i].U=&head;
        row[i].D=head.D;
        row[i].U->D=row[i].D->U=&row[i];
        row[i].L=row[i].R=&row[i];
    }
}
```


初始化之后，我们就要输入矩阵了。但在这之前，我们先观察一下问题，问题只要求我们使得 $1$ 完全覆盖，和 $0$ 没有任何关系。于是我们不难想到，在读入图时，我们只保存 $1$ 的位置，然后更新node的值。

以下分别为插入和main函数读入代码：

```cpp
 scanf("%d %d",&m,&n);
    init(m,n);
    int sr;
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            scanf("%d",&sr);
            if(sr==1){
                addnode(i,j);
            }
        }
    }
```


```cpp
inline void addnode(int r,int c){
    DLXnode *ptr=&node[cnt++];
    ptr->r=r;
    ptr->c=c;
    ptr->R=&row[r];
    ptr->L=row[r].L;
    ptr->L->R=ptr->R->L=ptr;
    ptr->U=&col[c];
    ptr->D=col[c].D;
    ptr->U->D=ptr->D->U=ptr;
    ++sz[c];
}
```

在完成了图的构建后，我们就可以让指针舞动起来了。

------------
- ## Let's dance！

首先，我们考虑如何对一个节点进行删除和回溯。如上文，我们并不用删除掉这个行的每个元素，我们只需要对行首，列首元素进行操作，让我们在搜索过程中忽略掉它们，就实现了删除操作了，同样的，这样做的好处在于回溯的时候不需要开辟新的内存空间，也就不会MLE(money溢出)。

```cpp
inline void delLR(DLXnode *ptr){
    ptr->L->R=ptr->R;
    ptr->R->L=ptr->L;
}

inline void delUD(DLXnode *ptr){
    ptr->U->D=ptr->D;
    ptr->D->U=ptr->U;
}

inline void reLR(DLXnode *ptr){
    ptr->L->R=ptr->R->L=ptr;
}

inline void reUD(DLXnode *ptr){
    ptr->U->D=ptr->D->U=ptr;
}
```

同理，对于行列的删除与回溯操作，也很容易地就能写出来了。

```cpp
inline void cover(int c){
    if(c==n){
        return;
    }
    delLR(&col[c]);
    DLXnode *R,*C;
    for(C=col[c].D;C!=(&col[c]);C=C->D){
        if(C->c==n){
            continue;
        }
        for(R=C->L;R!=C;R=R->L){
            if(R->c==n){
                continue;
            }
            --sz[R->c];
            delUD(R);
        }
        delLR(C);
    }
}

inline void re(int c){
    if(c==n){
        return;
    }
    DLXnode *R,*C;
    for(C=col[c].U;C!=(&col[c]);C=C->U){
        if(C->c==n){
            continue;
        }
        reLR(C);
        for(R=C->R;R!=C;R=R->R){
            if(R->c==n){
                continue;
            }
            ++sz[R->c];
            reUD(R);
        }
    }
    reLR(&col[c]);
}
```

在写出函数主体部分前，我们先重新思考一遍 $X$ 算法

1. 如果矩阵A没有列（即空矩阵），则当前记录的解为一个可行解；算法终止，成功返回；
2. 否则选择矩阵A中“1”的个数最少的列c；（确定性选择）
3. a:如果存在A[r][c]=1的行r，将行r放入可行解列表，进入步骤4)；（非确定性选择）

   b.如果不存在A[r][c]=1的行r，则剩下的矩阵不可能完成精确覆盖，说明之前的选择有错（或者根本就无解），需要回溯，并且恢复此次删除的行和列，然后跳到步骤3)a；
4. 对于所有的满足A[r][j]=1的列j，对于所有满足A[i][j]=1的行i，将行i从矩阵A中删除；将列j从矩阵A中删除；
5. 在不断减少的矩阵A上递归重复调用上述算法；

(以上 $X$ 算法的中文概述引自与博客[夜深人静写算法（九）- Dancing Links X（跳舞链）](https://blog.csdn.net/whereisherofrom/article/details/79220897)该博客内容也十分优秀，如果读到这里也还没理解DLX的话强烈推荐去阅读这篇博客，但博主码风更偏向于工程风。)

那么，显然地，dance部分也就能写出来了。

```cpp
bool dance(int k){
    if(head.L==(&head)){
        for(int i=0;i<k;i++){
            printf("%d ",ans[i]);
        }
        return true;
    }
    int INF=(1<<30),c=-1;
    for(DLXnode *ptr=head.L;ptr!=(&head);ptr=ptr->L){
        if(sz[ptr->c]<INF){
            INF=sz[ptr->c];
            c=ptr->c;
        }
    }
    cover(c);
    DLXnode *ptr;
    for(ptr=col[c].D;ptr!=(&col[c]);ptr=ptr->D){
        DLXnode *rc;
        ptr->R->L=ptr;
        for(rc=ptr->L;rc!=ptr;rc=rc->L){
            cover(rc->c);
        }
        ptr->R->L=ptr->L;
        ans[k]=ptr->r+1;
        if(dance(k+1)){
            return true;
        }
        ptr->L->R=ptr;
        for(rc=ptr->R;rc!=ptr;rc=rc->R){
            re(rc->c);
        }
        ptr->L->R=ptr->R;
    }
    re(c);
    return false;
}
```

------------

- ## 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1010;
int ans[MAXN];
struct DLXnode{
    int r,c;
    DLXnode *U,*D,*L,*R;
};
DLXnode node[MAXN*MAXN];
DLXnode row[MAXN];
DLXnode col[MAXN];
DLXnode head;
int cnt;
int sz[MAXN];
int n,m;

void init(int r,int c){
    cnt=0;
    head.r=r;
    head.c=c;
    head.L=head.R=head.U=head.D=&head;
    for(int i=0;i<c;i++){
        col[i].r=r;
        col[i].c=i;
        col[i].L=&head;
        col[i].R=head.R;
        col[i].L->R=col[i].R->L=&col[i];
        col[i].U=col[i].D=&col[i];
        sz[i]=0;
    }
    for(int i=r-1;i>-1;i--){
        row[i].r=i;
        row[i].c=c;
        row[i].U=&head;
        row[i].D=head.D;
        row[i].U->D=row[i].D->U=&row[i];
        row[i].L=row[i].R=&row[i];
    }
}

inline void addnode(int r,int c){
    DLXnode *ptr=&node[cnt++];
    ptr->r=r;
    ptr->c=c;
    ptr->R=&row[r];
    ptr->L=row[r].L;
    ptr->L->R=ptr->R->L=ptr;
    ptr->U=&col[c];
    ptr->D=col[c].D;
    ptr->U->D=ptr->D->U=ptr;
    ++sz[c];
}

inline void delLR(DLXnode *ptr){
    ptr->L->R=ptr->R;
    ptr->R->L=ptr->L;
}

inline void delUD(DLXnode *ptr){
    ptr->U->D=ptr->D;
    ptr->D->U=ptr->U;
}

inline void reLR(DLXnode *ptr){
    ptr->L->R=ptr->R->L=ptr;
}

inline void reUD(DLXnode *ptr){
    ptr->U->D=ptr->D->U=ptr;
}

inline void cover(int c){
    if(c==n){
        return;
    }
    delLR(&col[c]);
    DLXnode *R,*C;
    for(C=col[c].D;C!=(&col[c]);C=C->D){
        if(C->c==n){
            continue;
        }
        for(R=C->L;R!=C;R=R->L){
            if(R->c==n){
                continue;
            }
            --sz[R->c];
            delUD(R);
        }
        delLR(C);
    }
}

inline void re(int c){
    if(c==n){
        return;
    }
    DLXnode *R,*C;
    for(C=col[c].U;C!=(&col[c]);C=C->U){
        if(C->c==n){
            continue;
        }
        reLR(C);
        for(R=C->R;R!=C;R=R->R){
            if(R->c==n){
                continue;
            }
            ++sz[R->c];
            reUD(R);
        }
    }
    reLR(&col[c]);
}

bool dance(int k){
    if(head.L==(&head)){
        for(int i=0;i<k;i++){
            printf("%d ",ans[i]);
        }
        return true;
    }
    int INF=(1<<30),c=-1;
    for(DLXnode *ptr=head.L;ptr!=(&head);ptr=ptr->L){
        if(sz[ptr->c]<INF){
            INF=sz[ptr->c];
            c=ptr->c;
        }
    }
    cover(c);
    DLXnode *ptr;
    for(ptr=col[c].D;ptr!=(&col[c]);ptr=ptr->D){
        DLXnode *rc;
        ptr->R->L=ptr;
        for(rc=ptr->L;rc!=ptr;rc=rc->L){
            cover(rc->c);
        }
        ptr->R->L=ptr->L;
        ans[k]=ptr->r+1;
        if(dance(k+1)){
            return true;
        }
        ptr->L->R=ptr;
        for(rc=ptr->R;rc!=ptr;rc=rc->R){
            re(rc->c);
        }
        ptr->L->R=ptr->R;
    }
    re(c);
    return false;
}

int main(){
    scanf("%d %d",&m,&n);
    init(m,n);
    int sr;
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            scanf("%d",&sr);
            if(sr==1){
                addnode(i,j);
            }
        }
    }
    if(!dance(0)){
        cout<<"No Solution!"<<endl;
    }
}
```

---

## 作者：Meteorshower_Y (赞：17)

这是一道 **DLX** 的 **模板题** 

DLX，全名Dancing Links X，是一种被用来解决 **精确覆盖问题**如（n皇后问题、数独问题）和**重复覆盖问题**等等的高效算法。

这道题归根结底是一道**精确覆盖**问题。

精确覆盖简要介绍：[点这里](https://www.luogu.com.cn/blog/YJi/jing-que-fu-gai-wen-ti#)  
（本蒟蒻的介绍不是很好，如果看不明白可以去看看其他dalao的介绍）

### 精确覆盖
其标准定义呢，就是：  在一个全集X中若干子集的集合为S，精确覆盖是指，S的子集S ，满足X中的每一个元素在S 中恰好出现一次。

简单来说：  
由0和1组成的矩阵A来表示精确覆盖问题，目标是选出矩阵的若干行，使得其中的1在所有列中出现且仅出现一次。  
即：  
给定一个由0-1组成的矩阵，是否能找到一个行的集合，使得集合中每一列都恰好包含一个1

### 本题思路（DLX）
1. 对于下图一个矩阵（灰色表示1，无色表示0），因为要实现精确覆盖，所以每一列都要有一个为灰色，所以要么是无解，要么解之中的一个行就在每一列有元素的行上。那么我们是不是要从头到尾把每行、每种情况扫一遍呢？  
肯定是要有优化的。  
以图中第一列为例，要么这个图精确覆盖无解，要么解中就包含第 2 列 **或** 第 4 列。  
凭借这个原理，我们就可以每一次都选当前列上元素最
少的一列，依次选取元素所在行，从而达到减小搜索决策树的大小，节省时间的目的。
![](https://cdn.luogu.com.cn/upload/image_hosting/elpy8cp9.png)
1. 列上元素最少的为第一、三、五、六列，有两个元素，对应着两行
![](https://cdn.luogu.com.cn/upload/image_hosting/hqn7z68h.png)
1. 首先选中第一行，把其元素所在列 有元素的行（如图2/4/5/6行）全部删去得到新矩阵
![](https://cdn.luogu.com.cn/upload/image_hosting/vnrmkyf9.png)
1. 新矩阵如图所示，第2、5列元素最少，均为一个：
![](https://cdn.luogu.com.cn/upload/image_hosting/ls79wbd4.png)
1. 下面接着选中选中第二列中，删除第三行相关行列，得矩阵：
![](https://cdn.luogu.com.cn/upload/image_hosting/kwycdycw.png)
这时候发现没有元素，可是还没全部覆改（剩下第5列）说明这种方法不可行

1. 接着回溯，选中（第五列）第一行，删除相关行列，得如图矩阵：
![](https://cdn.luogu.com.cn/upload/image_hosting/7e6avvna.png)
1. 还是不可行，接着回溯，回溯到了最原始的矩阵，选中剩下的 **第四行** ，删除相关行列:
![](https://cdn.luogu.com.cn/upload/image_hosting/gzzxmhn4.png)

1. 列元素最少的为5、7列，选中**第一行**（第五列），删除相关行列，得新矩阵，接着选中剩下的一行（ **第五行** ），删除相关行列，得最后的空矩阵（只剩标头）。  
![](https://cdn.luogu.com.cn/upload/image_hosting/l3u7no1m.png)
这时递归路径：4-1-5，即为答案。
![](https://cdn.luogu.com.cn/upload/image_hosting/nzpu2r6t.png)
### 代码实现
算法实现重要基础： **双向十字循环链表**
#### 定义变量：
```cpp
const int MAXN=5500;
int cnt,lin[MAXN],sz[MAXN];			//链中的第cnt个元素；第i行的第一个数为lin[i]；第[j]列的元素个数为sz[j] 
int l[MAXN],r[MAXN],u[MAXN],d[MAXN];//第i元素左、右、上、下的元素的下标 
int col[MAXN],row[MAXN];     		//第i个元素在第col[i]行，row[i]列 
```


#### 第一步：建立矩阵
```cpp
inline void build(int n,int m)		//建造空矩阵 
{
	for(register int i=0;i<=m;i++)	//用双向链表储存列表头 
		l[i]=i-1, r[i]=i+1, u[i]=i, d[i]=i;
	l[0]=m, r[m]=0, cnt=m;			//构成双向循环链表，矩阵中已存cnt个元素 
}
```
#### 第二步：插入元素
```cpp
inline void insert(int ro,int co)	//向矩阵中加入新的元素 
{
	cnt+=1;
	row[cnt]=ro;					//第cnt个元素所在行 
	col[cnt]=co;					//第cnt个元素所在列 
	sz[co]+=1;						//第co列的元素个数 +1 
/*	处理纵向的链表：				*/
	u[cnt]=co;						// 将第cnt个元素 加入 纵向的 链表中 
	d[cnt]=d[co];					// 		同上 
	u[d[co]]=cnt;					// 		同上
	d[co]=cnt;						//		同上
/*	处理横向的链表：				*/
	if(lin[ro]==0)					//如果这一行链表中没有元素 所执行的操作 
	{
		lin[ro]=cnt;				//将第cnt个元素 加入 横向的 链表中 
		l[cnt]=cnt;					// 		同上
		r[cnt]=cnt;					// 		同上
	} 
	else							//反之，执行的操作 
	{
		l[cnt]=lin[ro];				//将第cnt个元素 加入 横向的 链表中 
		r[cnt]=r[lin[ro]];			// 		同上
		l[r[lin[ro]]]=cnt;			// 		同上
		r[lin[ro]]=cnt;				// 		同上
	}
}
```
#### 第三步：删列与恢复
```cpp
inline void cut(int c)				//将第c列移除 
{
	l[r[c]]=l[c]; 							//将第c列从表头中删除（将该表头元素的 左右表头元素 相连） 
	r[l[c]]=r[c];
	for(register int i=d[c];i!=c;i=d[i])	//从 纵向链表 中移除  第c列中的每个元素所在一行 
		for(register int j=r[i];j!=i;j=r[j])//从 纵向链表 中移除  该行元素 
		{
			u[d[j]]=u[j];					//将 该行的每一个元素从 纵向链表 中移除（将此元素的上下两元素相连） 
			d[u[j]]=d[j];
			sz[col[j]]-=1;					//第 该元素 所在列的 列元素个数 -1 
		}
}
inline void back(int c)				//将第c列恢复 
{
	for(register int i=u[c];i!=c;i=u[i])	//恢复 纵向链表 中 第c列中的被移除行 
		for(register int j=l[i];j!=i;j=l[j])//恢复 纵向链表 中 被移出行中被移除的元素 
		{
			u[d[j]]=d[u[j]]=j;				//将 该行的每一个元素从 纵向链表 中恢复（将此元素接入 上下两元素中间） 
			sz[col[j]]+=1;					//第 该元素 所在列的 列元素个数 +1 
		}
	l[r[c]]=c;								//将第c列从表头中恢复 
	r[l[c]]=c;
}
```
#### 第四步：开始跳舞



```cpp
int ans[MAXN];						//储存答案 


inline void print(int ln)			//输出答案 
{
	for(register int i=1;i<ln;i+=1)
		printf("%d ",ans[i]);
}
                                 
                                 
                                 
inline bool dance(int deep) /*deep 表示递归深度（即删除列的个数）*/	 //Start Dancing!
{
	if(r[0]==0)								//空矩阵则说明完成了 精确覆盖 ，输出答案 
	{
		print(deep);
		return 1;
	}
	
	int c=r[0];
	for(register int i=r[0];i!=0;i=r[i])	//此循环用来找矩阵中元素最少的一列，以减少决策树，节省时间 
		if(sz[i]<sz[c]) c=i;
		
	cut(c);									//移除第c列
	for(register int i=d[c];i!=c;i=d[i])	//依次列举第c列中有元素的每一行 
	{
		ans[deep]=row[i];					//记录路径，为下午 输出答案 做铺垫，埋伏笔 
		for(register int j=r[i];j!=i;j=r[j])//将选中第 col[j]行，删除相关元素 
			cut(col[j]);
			
		if(dance(deep+1)) return 1;			//如果为真则说明 上文中 已完成精确覆盖任务，回溯 
											//如果为假则说明 该列并不在答案中，下次循环选取下一列 
		for(register int j=l[i];j!=i;j=l[j])//将选中第 col[j]行，恢复相关元素 
			back(col[j]);
	}
	back(c);								//恢复第c列 
	return 0;								//表明 上文为达到题目要求，返回值为 假，回溯 
}                                 
```
### 完整Code
```cpp
#include<iostream>
#include<cstdio>
using namespace std;

const int MAXN=5500;
int ans[MAXN];						//储存答案 
int n,m,x;
int cnt,lin[MAXN],sz[MAXN];			//链中的第cnt个元素；第i行的第一个数为lin[i]；第[j]列的元素个数为sz[j] 
int l[MAXN],r[MAXN],u[MAXN],d[MAXN];//第i元素左、右、上、下的元素的下标 
int col[MAXN],row[MAXN];     		//第i个元素在第col[i]行，row[i]列 

inline void build(int n,int m)		//建造空矩阵 
{
	for(register int i=0;i<=m;i++)	//用双向链表储存列表头 
		l[i]=i-1, r[i]=i+1, u[i]=i, d[i]=i;
	l[0]=m, r[m]=0, cnt=m;			//构成双向循环链表，矩阵中已存cnt个元素 
}
inline void insert(int ro,int co)	//向矩阵中加入新的元素 
{
	cnt+=1;
	row[cnt]=ro;					//第cnt个元素所在行 
	col[cnt]=co;					//第cnt个元素所在列 
	sz[co]+=1;						//第co列的元素个数 +1 
/*	处理纵向的链表：				*/
	u[cnt]=co;						// 将第cnt个元素 加入 纵向的 链表中 
	d[cnt]=d[co];					// 		同上 
	u[d[co]]=cnt;					// 		同上
	d[co]=cnt;						//		同上
/*	处理横向的链表：				*/
	if(lin[ro]==0)					//如果这一行链表中没有元素 所执行的操作 
	{
		lin[ro]=cnt;				//将第cnt个元素 加入 横向的 链表中 
		l[cnt]=cnt;					// 		同上
		r[cnt]=cnt;					// 		同上
	} 
	else							//反之，执行的操作 
	{
		l[cnt]=lin[ro];				//将第cnt个元素 加入 横向的 链表中 
		r[cnt]=r[lin[ro]];			// 		同上
		l[r[lin[ro]]]=cnt;			// 		同上
		r[lin[ro]]=cnt;				// 		同上
	}
}
inline void cut(int c)				//将第c列移除 
{
	l[r[c]]=l[c]; 							//将第c列从表头中删除（将该表头元素的 左右表头元素 相连） 
	r[l[c]]=r[c];
	for(register int i=d[c];i!=c;i=d[i])	//从 纵向链表 中移除  第c列中的每个元素所在一行 
		for(register int j=r[i];j!=i;j=r[j])//从 纵向链表 中移除  该行元素 
		{
			u[d[j]]=u[j];					//将 该行的每一个元素从 纵向链表 中移除（将此元素的上下两元素相连） 
			d[u[j]]=d[j];
			sz[col[j]]-=1;					//第 该元素 所在列的 列元素个数 -1 
		}
}
inline void back(int c)				//将第c列恢复 
{
	for(register int i=u[c];i!=c;i=u[i])	//恢复 纵向链表 中 第c列中的被移除行 
		for(register int j=l[i];j!=i;j=l[j])//恢复 纵向链表 中 被移出行中被移除的元素 
		{
			u[d[j]]=d[u[j]]=j;				//将 该行的每一个元素从 纵向链表 中恢复（将此元素接入 上下两元素中间） 
			sz[col[j]]+=1;					//第 该元素 所在列的 列元素个数 +1 
		}
	l[r[c]]=c;								//将第c列从表头中恢复 
	r[l[c]]=c;
}
inline void print(int ln)			//输出答案 
{
	for(register int i=1;i<ln;i+=1)
		printf("%d ",ans[i]);
}
inline bool dance(int deep) /*deep 表示递归深度（即删除列的个数）*/	 //Start Dancing!
{
	if(r[0]==0)								//空矩阵则说明完成了 精确覆盖 ，输出答案 
	{
		print(deep);
		return 1;
	}
	
	int c=r[0];
	for(register int i=r[0];i!=0;i=r[i])	//此循环用来找矩阵中元素最少的一列，以减少决策树，节省时间 
		if(sz[i]<sz[c]) c=i;
		
	cut(c);									//移除第c列
	for(register int i=d[c];i!=c;i=d[i])	//依次列举第c列中有元素的每一行 
	{
		ans[deep]=row[i];					//记录路径，为下午 输出答案 做铺垫，埋伏笔 
		for(register int j=r[i];j!=i;j=r[j])//将选中第 col[j]行，删除相关元素 
			cut(col[j]);
			
		if(dance(deep+1)) return 1;			//如果为真则说明 上文中 已完成精确覆盖任务，回溯 
											//如果为假则说明 该列并不在答案中，下次循环选取下一列 
		for(register int j=l[i];j!=i;j=l[j])//将选中第 col[j]行，恢复相关元素 
			back(col[j]);
	}
	back(c);								//恢复第c列 
	return 0;								//表明 上文为达到题目要求，返回值为 假，回溯 
}
int main()
{
	scanf("%d%d",&n,&m);
	build(n,m);
	for(register int i=1;i<=n;i+=1)
	{
		for(register int j=1;j<=m;j+=1)
		{
			scanf("%d",&x);
			if(x) insert(i,j);				//将这个在i行 j列的元素 加入矩阵、链表中 
		}
	}
	if(!dance(1))
		printf("No Solution!\n");
	return 0;
}
```

**END**
如果各位感觉注释太乱的话，这里有[无注释版](https://www.luogu.com.cn/paste/enyvu847)的。

感谢观看~

---

## 作者：ฅ南瓜ฅ (赞：8)

### 适合用DLX来解决的题型：
	完美覆盖（棋盘问题，数独问题，n皇后问题..）
	重复覆盖

### 节点的储存：
某列的大小，行头元素，每个节点上下左右的节点，所在的行数列数

```cpp
int U[maxn],D[maxn],L[maxn],R[maxn];
int sz[maxn],h[maxn],col[maxn],row[maxn];
```

### 预处理：
```cpp
void prepare()
{
	num=m;head=0;
	for(int i=0;i<=m;++i)
	{
		U[i]=D[i]=i;sz[i]=0;
    	L[i]=i-1;R[i]=i+1;
	}
	L[head]=m;R[m]=head;
	memset(h,-1,sizeof(h));
}
```

### 节点的插入：
	将值为1的节点插入双向链表中，更新当前节点和周围节点的关系

```cpp
void link(int r,int c)//将r行c列元素插入双向十字循环链表 
{
	num++;sz[c]++;
	col[num]=c;row[num]=r;
	U[num]=U[c],D[num]=c;
	U[D[num]]=D[U[num]]=num;
	if(h[r]<0) h[r]=L[num]=R[num]=num;
    else L[num]=h[r],R[num]=R[h[r]],L[R[h[r]]]=num,R[h[r]]=num;
}  
```

### 节点的删除：
	假设双向链的三个连续的元素，A1、A2、A3，每个元素有两个分量Left和Right，分别指向左边和右边的元素。由定义可知
	
    A1.Right=A2，A2.Right=A3
	A2.Left=A1，A3.Left=A2
	
    在这个双向链中，可以由任一个元素得到其他两个元素，A1.Right.Right=A3，A3.Left.Left=A1等等
 
	现在把A2这个元素从双向链中移除（不是删除）出去，那么执行下面的操作就可以了
	
    A1.Right=A3，A3.Left=A1

```cpp
void remove(int c)//删除某一列中出现1的所有行 
{
	L[R[c]]=L[c],R[L[c]]=R[c];
	for(int i=D[c];i!=c;i=D[i])
		for(int j=R[i];j!=i;j=R[j])
			U[D[j]]=U[j],D[U[j]]=D[j],sz[col[j]]--;
}
```

### 节点的复原：
	如果此时发现，需要把A2这个元素重新加入到双向链中的原来的位置，也就是A1和A3的中间。由于A2的两个分量没有发生变化，仍然指向A1和A3。那么只要修改A1的Right分量和A3的Left就行了。也就是下面的操作
	
    A1.Right=A2，A3.Left=A2

```cpp
void resume(int c)//重置某一列中出现1的所有行
{
	for(int i=D[c];i!=c;i=D[i])
	    for(int j=R[i];j!=i;j=R[j])
		    U[D[j]]=D[U[j]]=j,sz[col[j]]++;
    L[R[c]]=R[L[c]]=c; 
}
```
### 核心函数（本质dfs）
	枚举没有覆盖的列，选择本列含有1的行数进行删除，然后回溯

```cpp
int dance(int dep)
{
	if(R[head]==head)return true;
	int c=R[head];
	for(int i=R[head];i!=head;i=R[i])if(sz[i]<sz[c]) c=i;//选取出现1元素次数最少的一列进行删除
	remove(c);
	for(int i=D[c];i!=c;i=D[i])
	{
		for(int j=R[i];j!=i;j=R[j]) remove(col[j]);
		if(dance(dep+1)){printf("%d ",row[i]);return true;} 
		for(int j=L[i];j!=i;j=L[j]) resume(col[j]);
	}
	resume(c);
	return false;
}
```


	完整代码qwq：
    
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cstdlib>
#define maxn 10000+5
using namespace std;

int n,m,d,num,head;
int U[maxn],D[maxn],L[maxn],R[maxn];
int sz[maxn],h[maxn],col[maxn],row[maxn];//sz:一列有多少个 h：行头元素 col&&row：当前点所在的行数和列数 

void prepare()
{
	num=m;head=0;
	for(int i=0;i<=m;++i)
	{
		U[i]=D[i]=i;sz[i]=0;
    	L[i]=i-1;R[i]=i+1;
	}
	L[head]=m;R[m]=head;
	memset(h,-1,sizeof(h));
}

void link(int r,int c)//将r行c列元素插入双向十字循环链表 
{
	num++;sz[c]++;
	col[num]=c;row[num]=r;
	U[num]=U[c],D[num]=c;
	U[D[num]]=D[U[num]]=num;
	if(h[r]<0) h[r]=L[num]=R[num]=num;
    else L[num]=h[r],R[num]=R[h[r]],L[R[h[r]]]=num,R[h[r]]=num;
}  

void remove(int c)//删除某一列中出现1的所有行 
{
	L[R[c]]=L[c],R[L[c]]=R[c];
	for(int i=D[c];i!=c;i=D[i])
		for(int j=R[i];j!=i;j=R[j])
			U[D[j]]=U[j],D[U[j]]=D[j],sz[col[j]]--;
}

void resume(int c)//重置某一列中出现1的所有行
{
	for(int i=D[c];i!=c;i=D[i])
	    for(int j=R[i];j!=i;j=R[j])
		    U[D[j]]=D[U[j]]=j,sz[col[j]]++;
    L[R[c]]=R[L[c]]=c; 
}

int dance(int dep)
{
	if(R[head]==head)return true;
	int c=R[head];
	for(int i=R[head];i!=head;i=R[i])if(sz[i]<sz[c]) c=i;//选取出现1元素次数最少的一列进行删除
	remove(c);
	for(int i=D[c];i!=c;i=D[i])
	{
		for(int j=R[i];j!=i;j=R[j]) remove(col[j]);
		if(dance(dep+1)){printf("%d ",row[i]);return true;} 
		for(int j=L[i];j!=i;j=L[j]) resume(col[j]);
	}
	resume(c);
	return false;
}

int main()
{
    scanf("%d%d",&n,&m);
	prepare();
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)
    {
    	scanf("%d",&d);
    	if(d) link(i,j);
	}
	if(!dance(1)) puts("No Solution!");
	return 0;
}
```



---

## 作者：vvauted (赞：7)

## 问题提出
给定 $N$ 个待选集合 $S_1,S_2,\cdots,S_{N-1},S_N$ 与一个目标集合 $X$，求出一个集合 $P$ 使得：

$$\bigcup_{i\in P}S_i=X$$


记为性质 $1$，且：

$$S_i \cap S_j=\varnothing(i,j\in P,i\ne j)$$

记为性质 $2$，这就是精确覆盖问题。
## 问题转化
同 [Luogu P4929 【模板】舞蹈链（DLX）](https://www.luogu.com.cn/problem/P4929) 的叙述，若把集合中的元素化为一个 $N$ 行 $M$ 列的 01 矩阵，那问题即可转换为：

选出矩阵中的若干行，使每一列上有且仅有一行中位上的元素为 $1$。

## 算法引入

对于这样一个矩阵，集合 $P$ 为已选的行集：


$$\begin{pmatrix}
        0&0&1&0&1&1&0\\
        1&1&0&0&0&0&0\\
        1&0&1&0&0&1&0\\
        1&1&1&0&1&0&1\\
        0 &0&0&1&0&0&1
        \end{pmatrix}$$

$$ P =\varnothing$$

要是先选择第一行，我们把第一行涂上红色:

$$\begin{pmatrix}
        \color{red}0&\color{red}0&\color{red}1&\color{red}0&\color{red}1&\color{red}1&\color{red}0\\
        1&1&0&0&0&0&0\\
        1&0&1&0&0&1&0\\
        1&1&1&0&1&0&1\\
        0 &0&0&1&0&0&1
        \end{pmatrix}$$

$$P=\{1\} $$

由性质 $2$ 得：使每一列上有且仅有一行中位上的元素为 $1$。

那么我们把第一行位上为 $1$ 的列都标记为红色：

$$\begin{pmatrix}
        \color{red}0&\color{red}0&\color{red}1&\color{red}0&\color{red}1&\color{red}1&\color{red}0\\
        1&1&\color{red}0&0&\color{red}0&\color{red}0&0\\
        1&0&\color{red}1&0&\color{red}0&\color{red}1&0\\
        1&1&\color{red}1&0&\color{red}1&\color{red}0&1\\
        0 &0&\color{red}0&1&\color{red}0&\color{red}0&1
        \end{pmatrix}$$

$$P=\{1\} $$

那么这些列上含有 $1$ 的行我们是绝对不能选的，这些行也标记为红色：

$$\begin{pmatrix}
        \color{red}0&\color{red}0&\color{red}1&\color{red}0&\color{red}1&\color{red}1&\color{red}0\\
        1&1&\color{red}0&0&\color{red}0&\color{red}0&0\\
        \color{red}1&\color{red}0&\color{red}1&\color{red}0&\color{red}0&\color{red}1&\color{red}0\\
        \color{red}1&\color{red}1&\color{red}1&\color{red}0&\color{red}1&\color{red}0&\color{red}1\\
        0 &0&\color{red}0&1&\color{red}0&\color{red}0&1
        \end{pmatrix}$$
        
$$P=\{1\} $$

把它们都删掉，得到：

$$
        \begin{pmatrix}
        1&1&0&0\\
       0 &0&1&1
        \end{pmatrix}
        
$$

$$P=\{1\}$$

肉眼很直观的可以看到：把这两行都选上不就好了，但是我们遵守下程序。

先选第 $1$ 行（其实为原矩阵的第 $2$ 行），并标红：

$$
        \begin{pmatrix}
        \color{red}1&\color{red}1&\color{red}0&\color{red}0\\
       0 &0&1&1
        \end{pmatrix}
        
$$

$$P=\{1,2\}$$

把行中位上为 $1$ 的列标红：

$$
        \begin{pmatrix}
        \color{red}1&\color{red}1&\color{red}0&\color{red}0\\
       \color{red}0 &\color{red}0&1&1
        \end{pmatrix}
        
$$

$$P=\{1,2\}$$

列中全为 $0$ 所以没有第 $3$ 步了，删去后得到：

$$
        \begin{pmatrix}
        1&1
        \end{pmatrix}
        
$$

$$P=\{1,2\}$$

再进行一轮后，矩阵为空：

$$P=\{1,2,5\}$$

那么 $P$ 则为精确覆盖问题的一个解。

但实际上，这是因为我们的数据很弱，导致我们一次就求出来了，但是在一般情况下，一次性是无法得到正解的，若矩阵在搜索的过程中，只剩 $0$ 元素，无法再选择，则恢复一次选择，在写代码时使用回溯的手段解决。
## 数据结构引入
著名的图灵奖得主:尼古拉斯·沃斯 提出著名的等式:

			程序 = 算法 + 数据结构。

我们已经研究出了解决这个精确覆盖的算法，那我们怎么通过选用数据结构来解决？

 Donald E. Knuth 使用了 **十字双向循环链表** 来解决这个问题
 
 他把我们刚才用的矩阵拿双向十字链表维护，不同的是，他只维护了其中的 $1$ 元素。
 
 既然是双向十字链表，那么每个节点都具有 $4$ 个指针域，在此定义：
 
 `U[i]` 指向 $i$ 上方的元素，
 `D[i]` 指向 $i$ 下方的元素，
 `L[i]` 指向 $i$ 左方的元素，
 `R[i]` 指向 $i$ 右方的元素。
 
 特殊得，每一列上都有一个节点（独立的，不代表这里是 $1$），称为列头，在后辅助我们对算法的应用。
 
 每一行中任取一个节点作为行首（在代码实现中为第一个插入到本行的元素，并不是独立的，代表位上为 $1$）。
 
 还有一个独立的 $0$ 节点，不参与算法实现过程，只是在后用于辅助判断矩阵是否为空。
 
 所以这个链表实际上长这样：
 
![](https://cdn.luogu.com.cn/upload/image_hosting/z44dhqre.png)
 
 ## 程序实现
 
 接下来就到写代码阶段啦！
 #### 变量初始化
 ```cpp
int L[Maxs],R[Maxs],U[Maxs],D[Maxs],Ans[Maxs],Col[Maxs],Row[Maxs],Siz[Maxs],Head[Maxs],n,m,tot;
```
`Ans` 数组存我们搜索过程中选择的行；

`Col` 与 `Row` 分别为存节点的列与行；

`Siz` 存列上元素的个数；

`Head` 存行首的下标；

`n,m` 分别为矩阵的行数与列数；

`tot` 存当前节点的个数。

 #### 1 建初始表
 我们只需要把 $0$ 节点与各列列头建好即可，给出代码：
 ```cpp
inline void build(int r,int c)//建立 r 行 c 列表
{
  	n=r,m=c;//赋值
  	for(rei i=0;i<=c;i++)  L[i]=i-1,R[i]=i+1,U[i]=D[i]=i;
   //左边为 i-1 ，右边为 i+1.上边与下边都为 i
	L[0]=c,R[c]=0,tot=c;
   // 0的左边是 c，c的右边是 0，构成循环链表
   //目前有 c 个节点（0节点不占）
}
```
 #### 2 插入节点
 对于列上，我们已经有独立的列头节点，把新节点放在插入到列头下方。
 
 对于行上，若行首为空，那么把行首赋为当前节点，左指针右指针初始化指向当前节点；
 
 若行首不为空，则插在行首右侧
 
 注：我们在实现算法的过程中操作都是对整行整列的，所以其在链表中的顺序不重要，只要保证在正确的行列上即可。
 
 给出代码：
 ```cpp
inline void insert(int r,int c)
{
	Col[++tot]=c,Row[tot]=r,Siz[c]++;
	D[tot]=D[c],U[D[c]]=tot,U[tot]=c,D[c]=tot;
	if(!Head[r]) Head[r]=L[tot]=R[tot]=tot;
	else 
	{
		R[tot]=R[Head[r]],L[R[Head[r]]]=tot;
		L[tot]=Head[r],R[Head[r]]=tot;
	}
}
```
 #### 3 删除一整列，并把其位上为 1 的行删去
 先对列头进行处理，再对列上元素进行遍历，再把遍历列节点所在行删去即可。
 
 注：此处遍历为对循环链表的遍历，不会的可以自己推一下
 
 给出代码与删除行上元素示意图：
 
 
 ```cpp
#define rei register int
inline void remove(int c)
{
	L[R[c]]=L[c],R[L[c]]=R[c];
	for(rei i=D[c];i!=c;i=D[i]) 
		for(rei j=R[i];j!=i;j=R[j])
			U[D[j]]=U[j],D[U[j]]=D[j],Siz[Col[j]]--;
}
```
![](https://cdn.luogu.com.cn/upload/image_hosting/32nxvp6k.png)
 
 #### 4 上一个操作的回溯
 即为逆操作，注意每一个地方都是逆的，不要漏了。
 
注：在这个操作中你就会感到循环链表有多妙了，删除这一列/行后，节点的信息并没有改变，所以很容易恢复。
 ```cpp
#define rei register int
inline void recover(int c)
{
	for(rei i=U[c];i!=c;i=U[i]) 
		for(rei j=L[i];j!=i;j=L[j])
			U[D[j]]=D[U[j]]=j,Siz[Col[j]]++;
	L[R[c]]=R[L[c]]=c;
}
```
#### 5 搜索
每一次贪心的选择 Siz 较小的列，然后删除这一列后枚举选择一行并删除这一行位上为 $1$ 的列，这样使得 Siz 较大的列很有可能在过程中被删除，降低回溯的次数。 
```cpp
#define rei register int 
inline bool dance(int dep)//已选行数为 dep-1 
{
	if(!R[0])//矩阵为空，输出，跳出
	{
		for(int i=1;i<dep;i++) printf("%d ",Ans[i]);
  		return 1;
	}
	rei c=R[0];
	for(rei i=R[0];i;i=R[i]) if(Siz[i]<Siz[c]) c=i;
	remove(c);//找到 Siz 最小列并删除
	for(rei i=D[c];i!=c;i=D[i])
	{
		Ans[dep]=Row[i];
		for(rei j=R[i];j!=i;j=R[j]) remove(Col[j]);//删除位上为 1 的列
		if(dance(dep+1)) return 1;//如果已经找到答案，跳出
		for(rei j=L[i];j!=i;j=L[j]) recover(Col[j]);//回溯后继续找
	}
	recover(c);
	return 0;//回溯，这种情况无解
}
```

给出 Dancing Links 部分代码：

```cpp
#define rei register int 
struct DLX {
  	int L[Maxs],R[Maxs],U[Maxs],D[Maxs],Ans[Maxs],Col[Maxs],Row[Maxs],Siz[Maxs],Head[Maxs],n,m,tot;
  	inline void build(int r,int c)
  	{
  		n=r,m=c;
  		for(rei i=0;i<=c;i++) L[i]=i-1,R[i]=i+1,U[i]=D[i]=i;
		L[0]=c,R[c]=0,tot=c;
	}
	inline void insert(int r,int c)
	{
		Col[++tot]=c,Row[tot]=r,Siz[c]++;
		D[tot]=D[c],U[D[c]]=tot,U[tot]=c,D[c]=tot;
		if(!Head[r]) Head[r]=L[tot]=R[tot]=tot;
		else 
		{
			R[tot]=R[Head[r]],L[R[Head[r]]]=tot;
			L[tot]=Head[r],R[Head[r]]=tot;
		}
	}
	inline void remove(int c)
	{
		L[R[c]]=L[c],R[L[c]]=R[c];
		for(rei i=D[c];i!=c;i=D[i]) for(rei j=R[i];j!=i;j=R[j]) U[D[j]]=U[j],D[U[j]]=D[j],Siz[Col[j]]--;
	}
	inline void recover(int c)
	{
		for(rei i=U[c];i!=c;i=U[i]) for(rei j=L[i];j!=i;j=L[j]) U[D[j]]=D[U[j]]=j,Siz[Col[j]]++;
		L[R[c]]=R[L[c]]=c;
	}
	inline bool dance(int dep)
	{
		if(!R[0])
		{
			for(int i=1;i<dep;i++) printf("%d ",Ans[i]);
	  		return 1;
		}
		rei c=R[0];
		for(rei i=R[0];i;i=R[i]) if(Siz[i]<Siz[c]) c=i;
		remove(c);
		for(rei i=D[c];i!=c;i=D[i])
		{
			Ans[dep]=Row[i];
			for(rei j=R[i];j!=i;j=R[j]) remove(Col[j]);
			if(dance(dep+1)) return 1;
			for(rei j=L[i];j!=i;j=L[j]) recover(Col[j]);
		}
		recover(c);
		return 0;
	}
}dlx;
```



---

## 作者：CmsMartin (赞：7)

update2022.8.3：修改问题定义的第一条的错误。

[更好的阅读体验](http://cmsblog.top/archives/dlx)

## 精确覆盖问题

### 问题定义

精确覆盖问题（英文：Exact Cover Problem) 是指给定许多集合 $S_i(1\leq i \leq n)$  以及一个集合 $X$ ，求满足以下条件的无序多元组 $(T_1,T_2,\cdots,T_m)$：

+ $\forall i , j \in [1,m] , T_i \cap T_j = \varnothing(i \neq j)$

+ $X = \bigcup\limits_{i=1}^mT_i$

+ $\forall i \in [1,m] , T_i \in \{S_1 , S_2,\cdots,,S_n\}$

例如，若给出：

$$
S_1 = \{5,9,17\}
$$
$$
S_2 = \{1,8,119\}
$$
$$
S_3= \{3,5,17\}
$$
$$
S_4 = \{1,8\}
$$
$$
S_5 = \{3,119\}
$$
$$
S_6 = \{8,9,119\}
$$
$$
X = \{1,3,5,8,9,17,119\}
$$

则 $(S_1,S_4 , S_5)$ 为一组合法解。

### 问题转化

将 $\bigcup\limits_{i=1}^n S_i$ 中的所有数离散化，可以得到这么一个模型：

> 给定一个 $01$ 矩阵，你可以选择一些行，使得最终每列都恰好有一个 $1$。 举个例子，我们对上文中的例子进行建模，可以得到这么一个矩阵：

![](https://cdn.luogu.com.cn/upload/image_hosting/mjlhzi4y.png)

> 其中第 $i$ 行表示着 $S_i$ ，而这一行的每个数依次表示:
> $[1 \in S_i],[3 \in S_i],[5 \in S_i],\cdots,[119 \in S_i]$。

### 暴力求解

方法 $1$：直接暴力枚举，时间复杂度 $O(nm \cdot 2^n)$

```cpp
int ok = 0;
for (int state = 0; state < 1 << n; ++state) {  // 枚举每行是否被选
  for (int i = 1; i <= n; ++i)
    if ((1 << i - 1) & state)
      for (int j = 1; j <= m; ++j) a[i][j] = 1;
  int flag = 1;
  for (int j = 1; j <= m; ++j)
    for (int i = 1, bo = 0; i <= n; ++i)
      if (a[i][j]) {
        if (bo)
          flag = 0;
        else
          bo = 1;
      }
  if (!flag)
    continue;
  else {
    ok = 1;
    for (int i = 1; i <= n; ++i)
      if ((1 << i - 1) & state) printf("%d ", i);
    puts("");
  }
  memset(a, 0, sizeof(a));
}
if (!ok) puts("No solution.");
```

方法 $2$：二进制优化枚举，时间复杂度 $O(n \cdot 2 ^ n)$

```cpp
int ok = 0;
for (int i = 1; i <= n; ++i)
  for (int j = m; j >= 1; --j) num[i] = num[i] << 1 | a[i][j];
for (int state = 0; state < 1 << n; ++state) {
  int tmp = 0;
  for (int i = 1; i <= n; ++i)
    if ((1 << i - 1) & state) {
      if (tmp & num[i]) break;
      tmp |= num[i];
    }
  if (tmp == (1 << m) - 1) {
    ok = 1;
    for (int i = 1; i <= n; ++i)
      if ((1 << i - 1) & state) printf("%d ", i);
    puts("");
  }
}
if (!ok) puts("No solution.");
```


## Algorithm X

### 算法过程

1. 对于现在的矩阵 $M$ ，选择并标记一列 $r$，将 $r$ 添加至 $S$ 中；
2. 如果尝试了所有的 $r$ 却无解，则算法结束，输出无解；
3. 标记与 $r$ 相关的行 $r_i$ 和 $c_i$；
4. 删除所有标记的行和列，得到新矩阵 $M'$；
5. 如果 $M'$ 为空，且 $r$ 为全 $1$ ，则算法结束，输出被删除的行组成的集合；

	如果 $M'$ 为空，且 $r$ 不全为 $1$ ，则恢复与 $r$ 相关的行 $r_i$ 以及列 $c_i$，跳转至步骤 $1$；

	如果 $M'$  不为空，则跳转至步骤 $1$。	

不难看出，X 算法需要大量的“删除行”、“删除列”和“恢复行”、“恢复列”的操作。

Donald E. Knuth 想到了用双向十字链表来维护这些操作。

而在双向十字链表上不断跳跃的过程被形象地比喻成“跳跃”，因此被用来优化 X 算法的双向十字链表也被称为 “Dancing Links” 。

所以舞蹈链算法名为 Dancing Links X（Dancing Links 优化 X 算法）

## Dancing Links X

双向十字链表中存在四个指针域，分别指向上、下、左、右的元素；且每个元素  在整个双向十字链表系中都对应着一个格子，因此还要表示  所在的列和所在的行，如图所示：

![](https://oi-wiki.org/search/images/dlx-1.png)
图片来自于Oi-Wiki

大型的双向链表则更为复杂：

![](https://oi-wiki.org/search/images/dlx-2.png)
图片来自于 Oi-Wiki

### 所需变量

对于每个节点，需要左指针，右指针，上指针，下指针，以及该节点的行列信息；


```cpp
int N , M , Cnt; //矩阵的长，宽，点的数量

int Left[MAXN] , Right[MAXN] , Up[MAXN] , Down[MAXN]; //每个节点的左指针，右指针，上指针，下指针

int Row[MAXN] , Cal[MAXN]; //行，列信息指针

int Head[MAXN] , S[MAXN]; //每行的头结点 , 每列的结点数

```

### InIt

初始化结果(图片来源于 Oi-Wiki )：
![](https://oi-wiki.org/search/images/dlx-5.png)

显然用类似于双向链表的方式初始化，~~非常简单~~

```cpp
void InIt(int M) {
	for(int i = 0; i <= M; i++) {
		Right[i] = i + 1;
		Left[i] = i - 1;
		Up[i] = Down[i] = i;
	}
	Right[M] = 0; //M的右侧是0
	Left[0] = M;  //0的左侧是M
	memset(Head , -1 , sizeof Head);
	memset(S , 0 , sizeof S);
	Cnt = M + 1; //开始时有M个结点（0结点和各列头结点）
}
```

### Links

插入操作分为两种基本情况

+ 如果第 $R$ 行没有元素，那么直接插入一个元素，并使 `Head[R]` 指向这个元素。
这可以通过 `Head[R] = Right[Cnt] = Left[Cnt] = Cnt;` 来实现。

+ 如果第 $R$ 行有元素， 用类似于双向链表的方式将该点插入到 `Head[R]` 的正右方

```cpp
Right[Cnt] = Head[R];
Left[Cnt] = Left[Head[R]];
Right[Left[Head[R]]] = Cnt;
Left[Head[R]] = Cnt;
```


最后用类似于双向链表的方式将该点插入到 $C$ 的正下方
```cpp
Up[Cnt] = C; 
Down[Cnt] = Down[C];
Up[Down[C]] = Cnt;
Down[C] = Cnt;
```

图解(来源于 Oi-Wiki )：

![](https://oi-wiki.org/search/images/dlx-6.png)

```cpp
void Link(int R , int C) { //在R行C列插入点
	S[C]++; //C 列节点多了1个
	Row[Cnt] = R; //更新该节点的行号
	Col[Cnt] = C; //更新该节点的列标
	Up[Cnt] = C; 
	Down[Cnt] = Down[C];
	Up[Down[C]] = Cnt;
	Down[C] = Cnt;
	if(Head[R] == -1) { //该行没有别的点,把第一个加入的点作为该行的行头结点
		Head[R] = Right[Cnt] = Left[Cnt] = Cnt;
	}
	else { 
		Right[Cnt] = Head[R];
		Left[Cnt] = Left[Head[R]];
		Right[Left[Head[R]]] = Cnt;
		Left[Head[R]] = Cnt;
	}
	++Cnt;
	return;
}
```

### ReMove

`ReMove(C)` 表示在 Dancing Links 中删除第 $C$ 列以及与其相关的行和列。

先将 $C$ 删除，此时：

+ $C$ 左侧的结点的右结点应为 $C$ 的右结点。
+ $C$ 右侧的结点的左结点应为 $C$ 的左结点。

即为 `Right[Left[C]] = Right[C],Left[Right[C]] = Left[C];`

然后顺着这一列往下走，把走过的每一行都删掉。

如何删掉每一行呢？枚举当前行的指针 $j$ ，此时：

 + $j$ 上方的结点的下结点应为 $j$ 的下结点。
 + $j$ 下方的结点的上结点应为 $j $ 的上结点。
**注意要修改每一列的元素个数。**

即 `Up[Down[j]] = Up[j],Down[Up[j]] = Down[j],S[Col[j]]--;`。

```cpp
void ReMove(int C) {
	Right[Left[C]] = Right[C];
	Left[Right[C]] = Left[C];
	//顺着这一列从上往下遍历
	for(int i = Down[C]; i != C; i = Down[i]) {
		//顺着这一列从左往右遍历
		for(int j = Right[i]; j != i; j = Right[j]) {
			Up[Down[j]] = Up[j];
			Down[Up[j]] = Down[j];
			S[Col[j]]--;
		}
	}
}
```

### ReSume

`ReSume` 就是逆着跑一此 `ReMove` ,不做解释

**注意操作顺序与 `ReMove` 正好相反**

```cpp
void ReSume(int C) {
	for(int i = Up[C]; i != C; i = Up[i]) {
		for(int j = Left[i]; j != i; j = Left[j]) {
			Up[Down[j]] = j;
			Down[Up[j]] = j;
			S[Col[j]]++;
		}
	}
	Right[Left[C]] = C;
	Left[Right[C]] = C;
}
```

### Dance

`dance()` 即为递归地删除以及还原各个行列的过程。

+ 如果 $0$ 号结点没有右结点，那么矩阵为空，记录答案并返回；
+ 选择列元素个数最少的一列，并删掉这一列；
+ 遍历这一列所有有 $1$ 的行，枚举它是否被选择；
+ 递归调用 `dance()`，如果可行，则返回；如果不可行，则恢复被选择的行；如果无解，则返回。

```cpp
bool Dance(int Dep) {
	if(Right[0] == 0) {
		for(int i = 0; i < Dep; i++)
			cout << Ans[i] << " ";
		return 1;
	}
	int C = Right[0];
	int i , j;
	for(i = Right[0]; i != 0; i = Right[i]) if(S[i] < S[C]) C = i;
	ReMove(C);
	for(i = Down[C]; i != C; i = Down[i]) {
		Ans[Dep] = Row[i];
		for(j = Right[i]; j != i; j = Right[j]) ReMove(Col[j]);
		if(Dance(Dep + 1)) return 1;
		for(int j = Left[i]; j != i; j = Left[j]) ReSume(Col[j]);
	}
	ReSume(C);
	return 0;
}
```

注意我们每次优先选择列元素个数最少的一列进行删除，这样能保证程序具有一定的启发性，使搜索树分支最少。

**时间复杂度**

DLX 递归及回溯的次数与矩阵中 $1$ 的个数有关，与矩阵的 $r , c$ 等参数无关。因此，它的时间复杂度是 **指数级** 的，理论复杂度大概在 $O(c^n)$ 左右，其中 $c$ 为某个非常接近于 $1$ 的常数，$n$ 为矩阵中 $1$ 的个数。

的个数。

但实际情况下 DLX 表现良好，一般能解决大部分的问题

## 例题讲解

### 【模板】舞蹈链（DLX）

[题目传送门](https://www.luogu.com.cn/problem/P4929)

#### 思路

直接使用 DLX 算法，无技术含量

#### 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 250100;

int N , M;
int Cnt;
int Left[MAXN] , Right[MAXN] , Up[MAXN] , Down[MAXN] , Col[MAXN] , Row[MAXN];

int Head[MAXN];

int S[MAXN];

int Ans[MAXN];

void InIt(int M) {
	for(int i = 0; i <= M; i++) {
		Right[i] = i + 1;
		Left[i] = i - 1;
		Up[i] = Down[i] = i;
	}
	Right[M] = 0;
	Left[0] = M;
	memset(Head , -1 , sizeof Head);
	memset(S , 0 , sizeof S);
	Cnt = M + 1;
}

void Link(int R , int C) {
	S[C]++;
	Row[Cnt] = R;
	Col[Cnt] = C;
	Up[Cnt] = C;
	Down[Cnt] = Down[C];
	Up[Down[C]] = Cnt;
	Down[C] = Cnt;
	if(Head[R] == -1) {
		Head[R] = Right[Cnt] = Left[Cnt] = Cnt;
	}
	else {
		Right[Cnt] = Head[R];
		Left[Cnt] = Left[Head[R]];
		Right[Left[Head[R]]] = Cnt;
		Left[Head[R]] = Cnt;
	}
	++Cnt;
	return;
}

void ReMove(int C) {
	Right[Left[C]] = Right[C];
	Left[Right[C]] = Left[C];
	for(int i = Down[C]; i != C; i = Down[i]) {
		for(int j = Right[i]; j != i; j = Right[j]) {
			Up[Down[j]] = Up[j];
			Down[Up[j]] = Down[j];
			S[Col[j]]--;
		}
	}
}

void ReSume(int C) {
	for(int i = Up[C]; i != C; i = Up[i]) {
		for(int j = Left[i]; j != i; j = Left[j]) {
			Up[Down[j]] = j;
			Down[Up[j]] = j;
			S[Col[j]]++;
		}
	}
	Right[Left[C]] = C;
	Left[Right[C]] = C;
}

bool Dance(int Dep) {
	if(Right[0] == 0) {
		for(int i = 0; i < Dep; i++)
			cout << Ans[i] << " ";
		return 1;
	}
	int C = Right[0];
	int i , j;
	for(i = Right[0]; i != 0; i = Right[i]) if(S[i] < S[C]) C = i;
	ReMove(C);
	for(i = Down[C]; i != C; i = Down[i]) {
		Ans[Dep] = Row[i];
		for(j = Right[i]; j != i; j = Right[j]) ReMove(Col[j]);
		if(Dance(Dep + 1)) return 1;
		for(int j = Left[i]; j != i; j = Left[j]) ReSume(Col[j]);
	}
	ReSume(C);
	return 0;
}

int main() {
	ios::sync_with_stdio(false);
	cin >> N >> M;
	int f;
	InIt(M);
	
	for(int i = 1; i <= N; i++) {
		for(int j = 1; j <= M; j++) {
			cin >> f;
			if(f) Link(i , j);
		}
	}
	if(!Dance(0)) cout << "No Solution!" << endl;
	
	return 0;
}
```
----
### [USACO1.5]八皇后 Checker Challenge

[题目传送门](https://www.luogu.com.cn/problem/P1219)

#### 思路

对于八皇后问题我们可以把它转化为精确覆盖的问题：

+ 每行只能放一个皇后
+ 每列只能放一个皇后
+ 每一个“/”斜行只能放一个皇后
+ 每一个“\”斜行只能放一个皇后
+ 我们把每个状态当成列，每个点当成一行 然后精确覆盖这个矩阵

**注意：与模版不同的是我们只需保证每行每列完全覆盖而每一斜行是肯定不能完全覆盖的（因为一共 $2n-1$ 个斜行）**

#### 参考代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100100;

long long ToT;

int N;
int Cnt;
int Left[MAXN] , Right[MAXN] , Up[MAXN] , Down[MAXN] , Col[MAXN] , Row[MAXN];

int Head[MAXN];

int S[MAXN];

int Ans[MAXN];

struct Node {
    int ans[14];
}SS[100000];


void InIt(int M) {
	for(int i = 0; i <= M; i++) {
		Right[i] = i + 1;
		Left[i] = i - 1;
		Up[i] = Down[i] = i;
	}
	Right[M] = 0;
	Left[0] = M;
	memset(Head , -1 , sizeof Head);
	memset(S , 0 , sizeof S);
	Cnt = M + 1;
}

void Link(int R , int C) { // Add (R , C)
	S[C]++;
	Row[Cnt] = R;
	Col[Cnt] = C;
	Up[Cnt] = C;
	Down[Cnt] = Down[C];
	Up[Down[C]] = Cnt;
	Down[C] = Cnt;
	if(Head[R] < 0) {
		Head[R] = Right[Cnt] = Left[Cnt] = Cnt;
	}
	else {
		Right[Cnt] = Head[R];
		Left[Cnt] = Left[Head[R]];
		Right[Left[Head[R]]] = Cnt;
		Left[Head[R]] = Cnt;
	}
	++Cnt;
	return;
}

void ReMove(int C) {
	Right[Left[C]] = Right[C];
	Left[Right[C]] = Left[C];
	for(int i = Down[C]; i != C; i = Down[i]) {
		for(int j = Right[i]; j != i; j = Right[j]) {
			Up[Down[j]] = Up[j];
			Down[Up[j]] = Down[j];
			S[Col[j]]--;
		}
	}
}

void ReSume(int C) {
	for(int i = Up[C]; i != C; i = Up[i]) {
		for(int j = Left[i]; j != i; j = Left[j]) {
			Up[Down[j]] = j;
			Down[Up[j]] = j;
			S[Col[j]]++;
		}
	}
	Right[Left[C]] = C;
	Left[Right[C]] = C;
}

void Dance(int Dep) {
	if(Right[0] > N) {
        ++ToT;
		for(int i = 0 , x , y; i < Dep; i++) {
            x = Ans[i] % N;
            y = (Ans[i] - 1) / N + 1;
            if(x == 0) x = N;
            SS[ToT].ans[x] = y;
        }
		return;
	}
	int C = Right[0];
	int i , j;
	for(i = Right[0]; i <= N ; i = Right[i]) 
        if(S[i] < S[C]) C = i;
	ReMove(C);
	for(i = Down[C]; i != C; i = Down[i]) {
		Ans[Dep] = Row[i];
		for(j = Right[i]; j != i; j = Right[j]) ReMove(Col[j]);
		Dance(Dep + 1);
		for(j = Left[i]; j != i; j = Left[j]) ReSume(Col[j]);
	}
	ReSume(C);
	return;
}

bool Cmp(Node a , Node b) {
    int i = 1;
    while(a.ans[i] == b.ans[i] && i <= N)
        ++i;
    return a.ans[i] < b.ans[i];
}

int main() {
	ios::sync_with_stdio(false);
	cin >> N ;
	int f = 0;
	InIt(6 * N - 2);
	//一共n*n格对应n*n行
	//对于第m列
	//若[1,n]对应在第m行放皇后 
	//若[n+1,2*n]对应在第m-n列放皇后 
	//若[2*n+1,4*n-1]对应在第m-2*n“\”斜行放皇后 （共2*n-1个“\”斜行） 
	//若[4*n,6*n-2]对应在第m-4*n+1“/”斜行放皇后（共2*n-1个“/”斜行） 
	for(int i = 1; i <= N; i++) {
		for(int j = 1; j <= N; j++) {
			++f;
            Link(f , i);
            Link(f , j + N);
            Link(f , i - j + 3 * N);
            Link(f , i + j + 4 * N - 2);
		}
	}
	
    Dance(0);

    sort(SS + 1 , SS + 1 + ToT , Cmp); 

    for(int i = 1; i <= 3; i++){
		for(int j = 1; j <= N; j++)
            cout << SS[i].ans[j] << " ";
        cout << endl;
	}

    cout << ToT << endl;
	
	return 0;
}
```
----

### 数独

[题目传送门](https://www.luogu.com.cn/problem/solution/P1784)

#### 思路

对于求解数独可以把它转化为精确覆盖的问题：

+ 每个点只能填一个数
+ 每个行只能填每种数各一个
+ 每个列只能填每种数各一个
+ 每个宫只能填每种数各一个

**于是我们把点对应成一个集合，包含 $4$ 个元素，分别表示对应的数，行，列，宫。然后精确覆盖即可。**

#### 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 250100;

inline int read() {
	int ret = 0;
	char c = getchar();
	while(c > '9' || c < '0') c = getchar();
	while(c >= '0' && c <= '9') {
		ret = (ret << 3) + (ret << 1) + c - 48;
		c = getchar();
	}
	return ret;
}

int N , M;
int Cnt;
int Left[MAXN] , Right[MAXN] , Up[MAXN] , Down[MAXN] , Col[MAXN] , Row[MAXN];

int Head[MAXN];

int S[MAXN];

int Ans[MAXN];

int Num[10][10];

void InIt(int M) {
	for(int i = 0; i <= M; i++) {
		Right[i] = i + 1;
		Left[i] = i - 1;
		Up[i] = Down[i] = i;
	}
	Right[M] = 0;
	Left[0] = M;
	memset(Head , -1 , sizeof Head);
	memset(S , 0 , sizeof S);
	Cnt = M + 1;
}

void Link(int R , int C) { // Add (R , C)
	S[C]++;
	Row[Cnt] = R;
	Col[Cnt] = C;
	Up[Cnt] = C;
	Down[Cnt] = Down[C];
	Up[Down[C]] = Cnt;
	Down[C] = Cnt;
	if(Head[R] == -1) {
		Head[R] = Right[Cnt] = Left[Cnt] = Cnt;
	}
	else {
		Right[Cnt] = Head[R];
		Left[Cnt] = Left[Head[R]];
		Right[Left[Head[R]]] = Cnt;
		Left[Head[R]] = Cnt;
	}
	++Cnt;
	return;
}

void ReMove(int C) {
	Right[Left[C]] = Right[C];
	Left[Right[C]] = Left[C];
	for(int i = Down[C]; i != C; i = Down[i]) {
		for(int j = Right[i]; j != i; j = Right[j]) {
			Up[Down[j]] = Up[j];
			Down[Up[j]] = Down[j];
			S[Col[j]]--;
		}
	}
}

void ReSume(int C) {
	for(int i = Up[C]; i != C; i = Up[i]) {
		for(int j = Left[i]; j != i; j = Left[j]) {
			Up[Down[j]] = j;
			Down[Up[j]] = j;
			S[Col[j]]++;
		}
	}
	Right[Left[C]] = C;
	Left[Right[C]] = C;
}

bool Dance(int Dep) {
	if(Right[0] == 0) {
		for(int i = 0 , x , y , v; i < Dep; i++) {
            x = (Ans[i] - 1) / 9 / 9;
            y = (Ans[i] - 1) / 9 % 9;
            v = (Ans[i]) % 9;
            if(v == 0) v = 9;
            Num[x][y] = v;
        }
        return 1;
	}
	int C = Right[0];
	int i , j;
	for(i = Right[0]; i != 0; i = Right[i]) if(S[i] < S[C]) C = i;
	ReMove(C);
	for(i = Down[C]; i != C; i = Down[i]) {
		Ans[Dep] = Row[i];
		for(j = Right[i]; j != i; j = Right[j]) ReMove(Col[j]);
		if(Dance(Dep + 1)) return 1;
		for(int j = Left[i]; j != i; j = Left[j]) ReSume(Col[j]);
	}
	ReSume(C);
	return 0;
}

int main() {
	ios::sync_with_stdio(false);
	N = 729;
    	M = 324;
	InIt(M);
	
    	for (int i = 0 , x , o; i < 9; i++) {
        	for(int j = 0; j < 9; j++) {
            		cin >> Num[i][j];
            		x = Num[i][j];
            		for(int k = 1; k <= 9; k++) {
                		if(x != k && x != 0) continue;
                		Link(i * 9 * 9 + j * 9 + k , i * 9 + j + 1);
                		Link(i * 9 * 9 + j * 9 + k , i * 9 + 81 + k);
                		Link(i * 9 * 9 + j * 9 + k , j * 9 + 81 * 2 + k);
                		Link(i * 9 * 9 + j * 9 + k , 81 * 3 + (i / 3 * 3 + j / 3) * 9 + k);
            		}
        	}
    	}
    
   	 Dance(0);

    	for(int i = 0; i < 9; i++) {
        	for(int j = 0; j < 9; j++)
            	cout << Num[i][j] << " ";
        	cout << endl;
    	}
	return 0;
}
```

### [NOIP2009 提高组] 靶形数独

[题目传送门](https://www.luogu.com.cn/problem/P1074)

#### 思路
首先，要将数独问题转化为一个精确覆盖问题。

于是我们重新建立一个 $(N \times N \times N)$ 矩阵。

+ 由于每个格子只能填一个数，用 $1 \sim 81$ 列表示每一个是否填数

+ 由于每个数在每一列只能出现一次，用 $82 \sim 162$ 列表示是否满足这个条件

+ 行和宫的方法是一样的

接着，枚举每个格子的方案，将这些方案在新的矩阵中所能覆盖的格子用二维链表连起来。

#### 参考代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 250100;

inline int read() {
	int ret = 0;
	char c = getchar();
	while(c > '9' || c < '0') c = getchar();
	while(c >= '0' && c <= '9') {
		ret = (ret << 3) + (ret << 1) + c - 48;
		c = getchar();
	}
	return ret;
}

int N , M;
int Cnt;
int Left[MAXN] , Right[MAXN] , Up[MAXN] , Down[MAXN] , Col[MAXN] , Row[MAXN];

int Head[MAXN];

int S[MAXN];

int Ans[MAXN];

long long Sum;

int Value[9][9]={
    {6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6} , 
    {6 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 6} , 
    {6 , 7 , 8 , 8 , 8 , 8 , 8 , 7 , 6} , 
    {6 , 7 , 8 , 9 , 9 , 9 , 8 , 7 , 6} , 
    {6 , 7 , 8 , 9 , 10 , 9 , 8 , 7 , 6} , 
    {6 , 7 , 8 , 9 , 9 , 9 , 8 , 7 , 6} , 
    {6 , 7 , 8 , 8 , 8 , 8 , 8 , 7 , 6} , 
    {6 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 6} , 
    {6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6}
};

void InIt(int M) {
	for(int i = 0; i <= M; i++) {
		Right[i] = i + 1;
		Left[i] = i - 1;
		Up[i] = Down[i] = i;
	}
	Right[M] = 0;
	Left[0] = M;
	memset(Head , -1 , sizeof Head);
	memset(S , 0 , sizeof S);
	Cnt = M + 1;
}

void Link(int R , int C) { // Add (R , C)
	S[C]++;
	Row[Cnt] = R;
	Col[Cnt] = C;
	Up[Cnt] = C;
	Down[Cnt] = Down[C];
	Up[Down[C]] = Cnt;
	Down[C] = Cnt;
	if(Head[R] == -1) {
		Head[R] = Right[Cnt] = Left[Cnt] = Cnt;
	}
	else {
		Right[Cnt] = Head[R];
		Left[Cnt] = Left[Head[R]];
		Right[Left[Head[R]]] = Cnt;
		Left[Head[R]] = Cnt;
	}
	++Cnt;
	return;
}

void ReMove(int C) {
	Right[Left[C]] = Right[C];
	Left[Right[C]] = Left[C];
	for(int i = Down[C]; i != C; i = Down[i]) {
		for(int j = Right[i]; j != i; j = Right[j]) {
			Up[Down[j]] = Up[j];
			Down[Up[j]] = Down[j];
			S[Col[j]]--;
		}
	}
}

void ReSume(int C) {
	for(int i = Up[C]; i != C; i = Up[i]) {
		for(int j = Left[i]; j != i; j = Left[j]) {
			Up[Down[j]] = j;
			Down[Up[j]] = j;
			S[Col[j]]++;
		}
	}
	Right[Left[C]] = C;
	Left[Right[C]] = C;
}

void Dance(int Dep) {
	if(Right[0] == 0) {
        long long sum = 0;
		for(int i = 0 , x , y , v; i < Dep; i++) {
            x = (Ans[i] - 1) / 9 / 9;
            y = (Ans[i] - 1) / 9 % 9;
            v = (Ans[i] - 1) % 9;
            sum += Value[x][y] * (v + 1);
        }
        Sum = max(Sum , sum);
        return;
	}
	int C = Right[0];
	int i , j;
	for(i = Right[0]; i != 0; i = Right[i]) if(S[i] < S[C]) C = i;
	ReMove(C);
	for(i = Down[C]; i != C; i = Down[i]) {
		Ans[Dep] = Row[i];
		for(j = Right[i]; j != i; j = Right[j]) ReMove(Col[j]);
		Dance(Dep + 1);
		for(int j = Left[i]; j != i; j = Left[j]) ReSume(Col[j]);
	}
	ReSume(C);
	return;
}

int main() {
	ios::sync_with_stdio(false);
	N = 729;
    	M = 324;
	InIt(M);
	
    	for (int i = 0 , x; i < 9; i++) {
        	for(int j = 0; j < 9; j++) {
            		cin >> x;
            		for(int k = 1; k <= 9; k++) {
                		if(x != k && x != 0) continue;
                		Link(i * 9 * 9 + j * 9 + k , i * 9 + j + 1);
                		Link(i * 9 * 9 + j * 9 + k , i * 9 + 81 + k);
                		Link(i * 9 * 9 + j * 9 + k , j * 9 + 81 * 2 + k);
                		Link(i * 9 * 9 + j * 9 + k , 81 * 3 + (i / 3 * 3 + j / 3) * 9 + k);
            		}
        	}
    	}
    
    	Dance(0);

    	if(Sum != 0) cout << Sum << endl;
    	else cout << -1 << endl;
	
	return 0;
}
```

---

## 作者：pyqpyq (赞：6)

我来~~水一波题解~~分享一下我的解法。
# 算法分析
首先看到这道题可以想到什么？

暴力！

对的没错这题正解就是暴力（滑稽

那我们怎么暴力呢？

~~依次枚举每行是否取走然后判断是否合法~~（T到飞起）

我们可以依次枚举每列出现的行，然后给这行上出现的 1 所在列打上标记，删掉含打上标记的行，然后换一列枚举。

没看懂？上图：
![](https://cdn.luogu.com.cn/upload/image_hosting/aoq5vxhw.png)
图中的数字是输入时给的矩阵，红线画出的是当前枚举的列，绿线画出的是当前枚举的行，黄线画出的是被打上标记的列，蓝线画出的是当前删掉的行。

我们从第一列开始枚举，先枚举第一列上的第一次出现的行第一行。

第一行经过的列有第一、二和五列，我们给它们打上标记。

接下来进行删除。可以看到第二行由于第二列被打上标记而被删除了，第四行也因第一列被打上标记而壮烈牺牲了。

如上步骤重复多次，如果所有列都打上了标记就输出解，如果当前枚举的行无解则回溯。
***
那问题来了：怎么删行？

~~这不好说，把那一行用 0 赋一遍就行了。~~

这样的话每次删行都要遍历一遍。会 T 到飞起啊。

但注意到 1 的数量不超过 5000 个。

那么我们每次只需要把 1 赋成 0 就行了，没必要把 0 赋成  0。

（上面这么说只是方便理解，实际操作中并无赋 0 操作。）

那接下来我们进入重点。
# 舞蹈链分析
舞蹈连是什么？

~~二维双向循环十字链表。~~

翻译成人话就长下面这样：
![](https://cdn.luogu.com.cn/upload/image_hosting/q32kwi79.png)
~~差点没画死我。~~

蓝色的是列虚拟节点，黄色的是行虚拟节点，红色的是普通节点。

每个节点都储存着它上下相邻的 1 所在行和左右相邻的 1 所在的列。

（这里只是方便描述，实际操作时按照真实的上下左右储存比较麻烦，故只需使链表可以遍历行和列的元素即可。可对比一维数组链表理解。）

为了快速找到行和列，我们可以在每行左边加入行虚拟节点，每列上面加入列虚拟节点。

特殊的，所有的列虚拟节点也算一行，故要在所有的列虚拟节点前加入一个行虚拟节点。当有列打上标记时便将那个列的列虚拟节点删除。

所以我们发现打了标记的列都被删了那么标记也就没有用了。

（在实际操作中不需要新开数组，一般以每行或列的第 0 个作为虚拟节点。自然，列虚拟节点的那一行行号为 0）

我们发现要满足三个操作：建~~设银~~行，删除行（剪枝）和加入行（回溯和建表）。

为什么要建行呢？建舞蹈链呢？~~工商银行它不香吗。~~

可以发现每行的节点之间的相邻情况在枚举过程中不会发生变化，所以在读入时就可以把同行节点之间的相邻关系即左右建好，建完后把该行用加入行加入到链表中就行了。

怎么建同行中的左右关系呢？

还记得怎么建一维的双向循环链表的吗？

~~都研究舞蹈链了没有人没学过吧。~~

就是对每列的节点建一个双向循环链表了。

只不过行虚拟节点要建在该行最前面。

那行与行之间的上下关系呢？

插入时遍历该行所有节点，把该节点像一维的双向循环链表一样插入该列末尾即可（注意不一定要插到原位置）。

删除时遍历该行所有节点，把该节点像一维的双向循环链表一样删除即可。~~人性的本质。~~

还要做两个优化，一个是每次先枚举剩余节点最少的列（优化搜索顺序），另一个是枚举时插入的顺序要和删除的顺序相反（我也不知道为什么要这么干）。

用事实证明优化二有多重要：

+ [优化一和优化二都没做的](https://www.luogu.com.cn/record/30576498)

+ [做了优化一没做优化二的](https://www.luogu.com.cn/record/30580413)

+ [优化一和优化二都做了的](https://www.luogu.com.cn/record/30692419)
# 代码分析
我知道我变量名是乱取的。那我就用~~紫名~~几乎每行一句的注释将功补过吧。

还是补充说明一下：n,m,a 是原题给出的行数列数和矩阵，o 用来记录每列现存多少 1 以便进行优化一，ans,con 记录答案（类似栈），t 记录是否有解以便找到解及时退出。
```cpp
//珍爱账号，远离JC
int n,m,a[511][511],o[511],ans[511],con,t;//同上
struct dlx//写在结构体里方便以后直接使用
{
	int u[511][511],d[511][511],l[511][511],r[511][511];//上下左右指针
	void buiro(int x)//建行
	{
		for(register int y=1; y<=m; ++y)//枚举该行每个数
		{
			if(!a[x][y])//如果这个数是1
			{
				r[x][y]=0;//为了循环将该数右指针指向该行虚拟节点
				l[x][y]=l[x][0];//将该数左指针指向该行虚拟节点左指针节点即末尾
				r[x][l[x][y]]=y;//是双向链表所以指回来
				l[x][r[x][y]]=y;//同上
			}
		}
	}
	void addro(int x)//加入行，与建行差不多
	{
		for(register int y=r[x][0]; y; y=r[x][y])//枚举该行所有节点
		{
			d[x][y]=0;
			u[x][y]=u[0][y];
			d[u[x][y]][y]=x;
			u[d[x][y]][y]=x;
			o[y]++;//所在列 1 的数量加 1
		}
	}
	void delro(int x)//删除行
	{
		for(register int y=l[x][0]; y; y=l[x][y])//倒序枚举该行所有节点
		{
			d[u[x][y]][y]=d[x][y];//该节点的上相邻节点的上指针直接跳过该节点指向该节点下指针节点
			u[d[x][y]][y]=u[x][y];//同上
			o[y]--;//所在列 1 的数量减 1
		}
	}
} c;//对象（OP术语即结构体变量）
void dfs()//枚举
{
	if(!c.r[0][0])//如果列虚拟节点的那一行的行虚拟节点右节点指向自己即列都被删完了
	{
		for(register int i=0; i<con; ++i)//遍历 ans 数组
			printf("%d ",ans[i]);//输出解
		t=1;//t 赋 1 以快速退出
		return;//退出当前函数
	}
	register int g=INT_MAX,p=0;//g 是现存节点中最小的 o[i]，p 是拥有最小的 o[i] 的列的编号
	for(register int i=c.r[0][0]; i; i=c.r[0][i])//遍历所有现存的列
	{
		if(g>o[i])//如果小于当前最小 o[i]
			g=o[p=i];//把 g 赋成 o[i]，p 赋成 i
	}
	int v[511],k=0;//倒序插入会打乱该列顺序，需要我们记录所有需要枚举的行
	for(register int i=c.d[0][p]; i; i=c.d[i][p])//遍历第 p 列
	{
		v[k++]=i;//把列上的所有行加入 v 数组
	}
	for(int i=0;i<k;++i)//枚举所有需要枚举的行
	{
		int s[511],w=0;//记录被删掉的列以便回溯
		for(register int j=c.l[v[i]][0]; j; j=c.l[v[i]][j])//枚举当前行中出现的列
		{
			c.r[0][c.l[0][j]]=c.r[0][j];//删除此列虚拟节点
			c.l[0][c.r[0][j]]=c.l[0][j];
			while(c.d[0][j])//枚举出现在此列的行
				c.delro(s[w++]=c.d[0][j]);//并删掉它
		}
		ans[con++]=v[i];//将枚举行的加入 ans 数组
		dfs();//继续枚举
		if(t)//如果找到答案
			return;//就快速退出
		con--;//否则将当前枚举的行弹出
		for(register int j=c.r[v[i]][0]; j&&f[j]; j=c.r[v[i]][j])//遍历因当前行而删掉的列
		{
			c.r[0][j]=0;//将它的列虚拟节点恢复
			c.l[0][j]=c.l[0][0];
			c.r[0][c.l[0][j]]=j;
			c.l[0][c.r[0][j]]=j;
		}
		for(register int j=w-1; j>=0; --j)//倒序遍历因当前行而删掉的行
			c.addro(s[j]);//并恢复它
	}
}
int main()//主函数
{
	register char h;//快读使用
	scanf("%d%d",&n,&m);//读入n、m
	c.buiro(0);//建列虚拟节点的那一行
	for(register int i=1; i<=n; ++i)//当前行
	{
		for(register int j=1; j<=m; ++j)//当前列
		{
			do
			{
				h=getchar();
			}
			while(h!='0'&&h!='1');//快读
			a[i][j]='1'-h;//存进 a 矩阵
		}
		c.buiro(i);//先建行
		c.addro(i);//再加入当前行
	}
	dfs();//枚举
	if(!t)//如果无解
		printf("No Solution!");//则输出
}
```
当然，舞蹈链的写法有很多，别的题解大部分是将上下左右指针存在一维数组里，而我将它们存在二维数组里，虽然占空间但更方便好写。

当然，舞蹈链不仅能解决精准覆盖问题，还是解决数独问题、八皇后问题的利器。

~~麻麻再也不用担心我被靶形数独卡了~~

完结撒花\\(^o^)/

---

## 作者：_Yoimiya_ (赞：5)

# Dancing Links X 算法

### 一，算法概述

$Dancing$ $Links$ $X$是一个由算法大师 Kunth 研究出的算法,基本思想是一个删除和恢复元素有些特殊的四向循环链表,可以将 Exact Covering Problem (简称 ECP ,为 NPC 问题)在极短的时间内解决。
  
### 二， X 算法

   所谓 X 算法...这就是一个深搜（~~太屑了~~）。
    
    步骤
    1.如果发现所有列都被标记则输出答案。
    2.对当前矩阵删除当前行，并删去与当前行有公共元素（即同列有 1） 的所有行，递归下一层。
    3.如果所有行返回无解即返回无解给上一层，并恢复行，回到第2步。
    4.所有搜索无解则返回无解。
    
   关于X算法，网上有许多生动的图解，这里已经说了步骤，不理解的可自行看代码或搜索其他题解，这里不再赘述（~~我太弱了不会讲~~）。
    
   本题的 DFS 部分代码：
   ```cpp
    inline bool dance(int deep){
        if(!r[0]){
            for(register int i(0);i<deep;++i)printf("%d ",ansk[i]);
            return 1;//本题不要求多解，可以直接返回
        }
        int mini=r[0];//找到1最少的列（减少迭代次数）
        for(register int i(r[0]);i!=0;i=r[i])if(s[i]<s[mini])mini=i;
        removed(mini);
        for(int i(d[mini]);i!=mini;i=d[i]){
            ansk[deep]=row[i];
            for(int j=r[i];j!=i;j=r[j]) removed(col[j]);
            if(dance(deep+1))return 1;//递归下一层
            for(int j=l[i];j!=i;j=l[j]) resumed(col[j]);
        }
        resumed(mini);
        return 0;//返回无解
    }
   ```

### 三，十字链表（四向循环链表）
   - <1> 循环链表  
   
   	 循环链表是一种链式存储结构，链表中最后一个结点的指针域指向头结点，整个链表形成一个环。
       
   - <2> 四向循环链表 ( Dancing Links )
   
     又称十字链表，相当于四个方向（上下左右）都有指针，构成四个循环链表。这种特殊的结构可以使其快速地进行移除和回复操作(正好对应X算法需要的操作)，四个方向的指针之间的变换犹如舞蹈一般美丽又不失巧妙，因此被称为“舞蹈链”。
      
      十字链表初始化
      ```cpp
      void init(int m)//一般不用传n，构建矩阵只用m个头元素
      {
        cnt=m+1;//开始时有m个结点（0结点和各列头结点）
        memset(h,-1,sizeof h);//将头结点赋为-1，表示没有
        for(int i=0;i<=m;i++){
          u[i]=d[i]=i;
          l[i]=i-1;r[i]=i+1;//十字链表基本原理
        }
      
      ```
      对于插入新节点（注意，这里比较难懂，建议不理解的画一下图，模拟一下指针的变化）
      ```cpp
      inline void link(int R,int C){//在R行C列插入一个1
        s[C]++;//s数组表示每列的结点数
        col[cnt]=C;row[cnt]=R;//记录这个点的行列信息
        u[cnt]=C;d[cnt]=d[C];u[d[C]]=cnt;d[C]=cnt;//链表插入
        if(h[R]==-1) l[cnt]=cnt,h[R]=cnt,r[cnt]=cnt;//如果没有头，那它就是头
        else{
            r[cnt]=h[R];l[cnt]=l[h[R]];r[l[h[R]]]=cnt;l[h[R]]=cnt;
        }
        ++cnt;return ;//下一个点的编号
      }
      ```
      移除与恢复C列上有点的行，我觉得这里最能体现“指针的舞蹈”的巧妙。
      
      对于移除行操作（不用释放内存，因为这只是暂时的）
      ```cpp
      inline void removed(int C){
          r[l[C]]=r[C];l[r[C]]=l[C];//它左边的右边指向它的右边，它右边的左边指向它的左边（我觉得很巧妙）
          for(register int i(d[C]);i!=C;i=d[i]){
              for(register int j(r[i]);j!=i;j=r[j]){
                  u[d[j]]=u[j];//同理
                  d[u[j]]=d[j];
                  --s[col[j]];
              }
          }return ;
      }
      ```
      对于恢复操作（注意恢复要和移除方向相反）
      ```cpp
      inline void resumed(int C){
          r[l[C]]=C;l[r[C]]=C;
          for(register int i(u[C]);i!=C;i=u[i]){//相反方向
              for(register int j(l[i]);j!=i;j=l[j]){
                  u[d[j]]=j;d[u[j]]=j;++s[col[j]];
              }
          }return ;
      }
      ```

### 四，整体代码
   本题代码
   ```cpp
  #include<iostream>
  #include<cstdio>
  #include<cstring>
  #include<algorithm>
  using namespace std;
  const int mx=250510;
  inline int Read(){
      int x=0;char c=getchar();
      while(c>'9'||c<'0')c=getchar();
      while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
      return x;
  }
  int n,m,cnt;
  int l[mx],r[mx],u[mx],d[mx],col[mx],row[mx],h[mx],s[mx],ansk[mx]; 
  void init(int m){
      cnt=m+1;
      memset(h,-1,sizeof h);
      for(register int i(0);i<=m;++i){
          u[i]=d[i]=i;
          l[i]=i-1;r[i]=i+1;
      }
      l[0]=m;r[m]=0;
  }
  inline void link(int R,int C){
      s[C]++;col[cnt]=C;row[cnt]=R;
      u[cnt]=C;d[cnt]=d[C];u[d[C]]=cnt;d[C]=cnt;
      if(h[R]==-1) l[cnt]=cnt,h[R]=cnt,r[cnt]=cnt;
      else{
          r[cnt]=h[R];l[cnt]=l[h[R]];r[l[h[R]]]=cnt;l[h[R]]=cnt;
      }
      ++cnt;return ;
  }
  inline void removed(int C){
      r[l[C]]=r[C];l[r[C]]=l[C];
      for(register int i(d[C]);i!=C;i=d[i]){
          for(register int j(r[i]);j!=i;j=r[j]){
              u[d[j]]=u[j];
              d[u[j]]=d[j];
              --s[col[j]];
          }
      }return ;
  }
  inline void resumed(int C){
      r[l[C]]=C;l[r[C]]=C;
      for(register int i(u[C]);i!=C;i=u[i]){
          for(register int j(l[i]);j!=i;j=l[j]){
              u[d[j]]=j;d[u[j]]=j;++s[col[j]];
          }
      }return ;
  }
  inline bool dance(int deep){
      if(!r[0]){
          for(register int i(0);i<deep;++i)printf("%d ",ansk[i]);
          return 1;
      }
      int mini=r[0];
      for(register int i(r[0]);i!=0;i=r[i])if(s[i]<s[mini])mini=i;
      removed(mini);
      for(int i(d[mini]);i!=mini;i=d[i]){
          ansk[deep]=row[i];
          for(int j=r[i];j!=i;j=r[j]) removed(col[j]);
          if(dance(deep+1))return 1;
          for(int j=l[i];j!=i;j=l[j]) resumed(col[j]);
      }
      resumed(mini);
      return 0;
  }
  signed main(){
      n=Read(),m=Read();
      init(m);
      for(register int i(1);i<=n;++i)
          for(register int j(1);j<=m;++j)
              if(Read())link(i,j);
      if(!dance(0))printf("No Solution!");
      return 0;
  }
  ```
  好题推荐：
    
    
  | Dominoes | http://acm.hdu.edu.cn/showproblem.php?pid=2518 |
| :----------: | :----------: |
| N 皇后 | https://www.spoj.com/problems/NQUEEN/ |
| Lamp | http://acm.hdu.edu.cn/showproblem.php?pid=2828 |
|靶形数独|https://www.luogu.com.cn/problem/P1074|

感谢阅读！

---

## 作者：SegTre (赞：2)

## 什么是精确覆盖问题
在一个全集 $X$ 中若干子集的集合为 $S$ ，精确覆盖是指：$S$ 的子集 $S*$，满足X中的每一个元素在 $S*$ 中恰好出现一次。

举个例子：给定全集 $[1,7]$ ，再给出其若干子集

$$\{3,5,6\}\{1,4,7\}\{2,3,6\}\{1,4\}\{2,7\}\{4,5,7\}$$

要求选出其中几个子集，满足:

1. 这些子集内没有相同元素（精确）；

1. 这些子集的元素能组成全集（覆盖）；

其中集合 $\{3,5,6\},\{1,4\},\{2,7\}$ 满足精确覆盖。

## 矩阵表示法
我们可以用矩阵描述精确覆盖：每列代表一个元素，每行代表一个集合，然后我们要解决的就是[题目](https://www.luogu.com.cn/problem/P4929)所描述的问题了。

![](https://b1.sbimg.org/file/chevereto-jia/2020/11/26/Q21pw.png)

## 十字双向循环链表（数组模拟）

```cpp
struct point
{
	int left,right,up,down;
}node[MAXN];//每个点的上下左右指针

int cnt,head[MAXN],s[MAXN];//有cnt个点，head存每行头结点，s存每列有多少个1

```
## 核心操作
DFS搜索每次选哪个集合（哪一行）。

每选定一行，删除该行，以及相关行列。（找出选定行有 $1$ 的列，把这列上有 $1$ 的行都删除。相当于选到一个元素，把有这个元素的集合都删掉）。而十字双向循环链表能够高效的完成这个操作。



------------
## Code

```cpp

#include<cstdio>
using namespace std;
inline int read()
{
	int res;
	char c;
	while((c=getchar())<'0'||c>'9');
	res=c^48;
	while((c=getchar())>='0'&&c<='9')
	res=(res<<3)+(res<<1)+(c^48);
	return res;
}
int cnt,l[6000],r[6000],u[6000],d[6000],row[6000],col[6000];
int head[505],s[505],ans[505]; 

inline void init(int m)
{
	for(int i=0;i<=m;++i)
	{
		l[i]=i-1;
		r[i]=i+1;
		u[i]=d[i]=i;
	}
	l[0]=m;
	r[m]=0;
	cnt=m;
}//
inline void insert(int R,int C)
{
	cnt++;//元素序号 
	row[cnt]=R;
	col[cnt]=C;
	s[C]++;
	u[cnt]=u[C];
	d[cnt]=C;
	d[u[C]]=cnt;
	u[C]=cnt;
	if(head[R])
	{
		l[cnt]=l[head[R]];
		r[cnt]=head[R];
		r[l[head[R]]]=cnt;
		l[head[R]]=cnt;
	}
	else head[R]=l[cnt]=r[cnt]=cnt;
}//插入结点 

inline void remove(int C)
{
	l[r[C]]=l[C];
	r[l[C]]=r[C];
	for(int i=d[C];i!=C;i=d[i])
	{
		for(int j=r[i];j!=i;j=r[j])
		{
			d[u[j]]=d[j];
			u[d[j]]=u[j];
			s[col[j]]--;
		}
	}
}//删除操作
inline void resume(int C)
{
	l[r[C]]=C;
	r[l[C]]=C;
	for(int i=d[C];i!=C;i=d[i])
	{
		for(int j=r[i];j!=i;j=r[j])
		{
			d[u[j]]=j;
			u[d[j]]=j;
			s[col[j]]++;
		}
	}
}//还原操作
bool dance(int deep)
{
	if(!r[0])
	{
		for(int i=1;i<deep;++i)
		printf("%d ",ans[i]);
		return 1;
	}
	int C=r[0];
	for(int i=r[0];i;i=r[i]) if(s[i]<s[C]) C=i;
	remove(C);
	for(int i=d[C];i!=C;i=d[i])
	{
		ans[deep]=row[i];
		for(int j=r[i];j!=i;j=r[j]) remove(col[j]);
		if(dance(deep+1)) return 1;
		for(int j=r[i];j!=i;j=r[j]) resume(col[j]);
	}
	resume(C);
	return 0;
}//其实是DFS
int main()
{
	int n=read(),m=read();
	bool x;
	init(m);
	for(int i=1;i<=n;++i)
	for(int j=1;j<=m;++j)
	{
		x=read();
		if(x) insert(i,j);
	}
	if(!dance(1)) printf("No Solution!");
	return 0;
}

```



---

## 作者：阴阳八卦 (赞：2)

个人感觉精确覆盖的算法理解难度不大，关键在于十字链表板子的理解，所以本篇题解重在解释十字链表 ~~（没错，我就是菜 )~~  
先来说说本体的数据结构：十字链表  
对于每一个点都有up,down,left,right四种方向的指针的数据结构，模拟矩阵。用于精确覆盖和完美覆盖。  
首先在每行首创建初始点
```
void init(int m)
{
	for(int i=0;i<=m;i++)
	{
		r[i]=i+1;
		l[i]=i-1;
		u[i]=d[i]=i;//构成环式结构
	}
	r[m]=0;
	l[0]=m;//l、r构成环式结构
	memset(h,-1,sizeof(h));
	memset(s,0,sizeof(s));
	cnt=m+1;//新的cnt加入
}
```
![ ](https://cdn.luogu.com.cn/upload/image_hosting/fz1n7ekc.png)  
其次，进行初始化的加入
```
void link(int rw,int c)//加入第cnt个点
{
	row[cnt]=rw,col[cnt]=c;//记录cnt的行列状况
   s[c]++;//c列多一个
	u[cnt]=c;
	d[cnt]=d[c];
	u[d[c]]=cnt;
	d[c]=cnt;//以上参考图一
	if(h[rw]==-1)h[rw]=r[cnt]=l[cnt]=cnt;
	else {
		l[cnt]=h[rw];
		r[cnt]=r[h[rw]];      
		l[r[h[rw]]]=cnt;
		r[h[rw]]=cnt;//以上参考图二
	}
	cnt++;
	return ;
}
```
图一：  
![图一](https://cdn.luogu.com.cn/upload/image_hosting/ohct4ndq.png)  
图二：![图二](https://cdn.luogu.com.cn/upload/image_hosting/1uha3ma0.png)
通过以上的画图证明，我们非常容易（没错）发现以下代码：
```
遍历第c列：for(int i=d[c];i!=c;i=d[i])
i=d[c]:初始化为c列最高行点编号
i!=c:跑回来
i=d[i]:一层层往下爬直到爬回c点
遍历i所在的行：for(int j=r[i];j!=i;j=r[j])
j=r[i]:从右边开始跑
j!=i：跑回来
j=r[j]:继续向右跑

```
所以，我们可以得到十字链表的del与add操作代码
```
void del(int c)删除c列
{
	r[l[c]]=r[c];
	l[r[c]]=l[c];//把c点从0-m点内扒出来，但是保留c列u、d关系
	for(int i=d[c];i!=c;i=d[i])
	for(int j=r[i];j!=i;j=r[j])
	{
		u[d[j]]=u[j];
		d[u[j]]=d[j];//此处把i所在行扒了下来，保留行内l、r、u、d关系不变仅处理原图
		s[col[j]]--;
	}
}
void add(int c)加上d列
{
	for(int i=u[c];i!=c;i=u[i])//用c列原有的u、d关系遍历c列（u、d均可）
	for(int j=l[i];j!=i;j=l[j])//用i所在行的l、r关系把i行装回去，重新建立于其他行的u、d关系（l、r均可）
	{
		u[d[j]]=j;
		d[u[j]]=j;
		s[col[j]]++;
	}
	r[l[c]]=c;
	l[r[c]]=c;
}
```
接着回到本题  
对于本题精确覆盖问题可以参考众多大佬的绘图理解与解释。蒟蒻理解见代码：
```
bool dance(int deep)
{
	if(r[0]==0)//判断1-m列是否均被del，如果均被del,0点的左右指针均指向0
	{
		for(int i=0;i<deep;i++)printf("%d ",ansk[i]);//简单dfs类型的记录输出
		return 1;
	}
	int c=r[0];
	for(int i=r[0];i!=0;i=r[i])if(s[i]<s[c])c=i;//找到有最少点的列，优化时间
	del(c);//删除最少点列（有限在该列中确定一点，该列自然从图中被扒下来）
	for(int i=d[c];i!=c;i=d[i])
	{
		ansk[deep]=row[i];//枚举选择的第几行，进行搜索回溯
		for(int j=r[i];j!=i;j=r[j])del(col[j]);//删除i点所在行
		if(dance(deep+1))return 1;
		for(int j=l[i];j!=i;j=l[j])add(col[j]);//加上i点所在行
	}
	add(c);//补回原图，dfs日常操作
	return 0;
}
```


---

## 作者：Kobe_BeanBryant (赞：2)

### 题目方法：
典型的精确覆盖问题。

### 算法实现：
1. 如果矩阵为空，问题解决，输出。
2. 否则，选择 $ 1 $ 最少的一列。
3. 如果存在为 $ 1 $ 的行，进入下一步；否则回溯到上一层。
4. 把这一行包含进部分解。
5. 对于所有满足为 $ 1 $ 的列，对于所有满足为 $ 1 $ 的行，从矩阵中删除这一行，然后从矩阵中删除这一列。
6. 在不断减少的矩阵上递归地重复上面的方法。

### 图形结合:
我们先拿一组数据来举例，如：

| $A$ | $B$ | $C$ | $D$ | $E$ | $F$ | $G$ |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| $0$ | $0$ | $1$ | $0$ | $1$ | $1$ | $0$ |
| $1$ | $0$ | $0$ | $1$ | $0$ | $0$ | $1$ |
| $0$ | $1$ | $1$ | $0$ | $0$ | $1$ | $0$ |
| $1$ | $0$ | $0$ | $1$ | $0$ | $0$ | $0$ |
| $0$ | $1$ | $0$ | $0$ | $0$ | $0$ | $1$ |
| $0$ | $0$ | $0$ | $1$ | $1$ | $0$ | $1$ |

![](https://cdn.luogu.com.cn/upload/image_hosting/org6wknv.png)

我们再将 $ 0 $ 删掉，只剩下 $ 1 $，在用链表链接起来，如图：
![](https://cdn.luogu.com.cn/upload/image_hosting/u3ennw1i.png?x-oss-process=image/resize,m_lfit,h_3000,w_3000)

### 核心代码：
初始化建表：
```cpp
void sth(){
	ans[0]=head=flag=0;
	for(int i=0;i<=m;i++){
		S[i]=0;
		D[i]=U[i]=i;
		L[i]=i-1;R[i]=i+1;
	}
	L[0]=m,R[m]=0;
	cnt=m+1;
	for(int i=1;i<=n;i++){
		int a,begin,end;
		begin=end=cnt;
		for(int j=1;j<=m;j++){
			cin>>a;
			if(a==0) continue;
			S[j]++;
			D[U[j]]=cnt;U[cnt]=U[j];
			D[cnt]=j;U[j]=cnt;
			L[cnt]=end;R[cnt]=begin;
			R[end]=cnt;L[begin]=cnt;
			X[cnt]=i;Y[cnt]=j;
			end=cnt;
			cnt++;
		}
	}
}
```
搜索代码：
```cpp
void dfs(){
	if(R[head]==head) {flag=1;return;}
	int Mi=INT_MAX,id=-1;
	for(int i=R[head];i!=head;i=R[i]){
		if(!S[i]) return;
		if(S[i]<Mi) Mi=S[i],id=i;
	}
	SC(id);
	for(int i=D[id];i!=id;i=D[i]){
		ans[++ans[0]]=X[i];
		for(int j=R[i];j!=i;j=R[j]) SC(Y[j]);
		dfs();
		if(flag) return;
		ans[0]--;
		for(int j=L[i];j!=i;j=L[j]) FF(Y[j]);
	}
	FF(id);
}
```
全部代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAX=250005;
int n,m;
int head,finded,cnt,cnt1,id;
int s[MAX],l[MAX],r[MAX],u[MAX],d[MAX],x[MAX],y[MAX],ans[MAX];

void del(int x){
	r[l[x]] = r[x];  l[r[x]] = l[x];
	for(int i = d[x]; i!=x; i = d[i]){
		for(int j = r[i]; j!=i; j = r[j]){
			d[u[j]] = d[j];  u[d[j]] = u[j];
			s[y[j]]--;
		}
	}
}

void remove(int x){
	r[l[x]] = l[r[x]] = x;
	for(int i = d[x]; i!=x; i = d[i]){
		for(int j = r[i]; j!=i; j = r[j]){
			d[u[j]] = u[d[j]] = j;
			s[y[j]]++;
		}
	}
}

void dfs(){
	if(r[0] == 0){finded = 1;return;}
	int minn = 1e9,c = -1;
	for(int i = r[0]; i!=0; i = r[i]){
		if(s[i] == 0) return;
		if(s[i] < minn) minn = s[i],c = i;
	}
	del(c);
	for(int i = d[c]; i!=c; i = d[i]){
		ans[++cnt1] = x[i];
		for(int j = r[i]; j!=i; j = r[j]) del(y[j]);
		dfs();
		if(finded) return;
		cnt1--;
		for(int j = r[i]; j!=i; j = r[j]) remove(y[j]);
	}
	remove(c);
	return;
}

void build(){
	cin>>n>>m;
	head = finded = 0;
	for(int i = 0; i<=m; i++){
		u[i] = d[i] = i;
		l[i] = i-1,r[i] = i+1;
	}
	l[0] = m,r[m] = 0;
	cnt = m+1;
	for(int i = 1; i<=n; i++){
		int x_,bin,end;
		bin = end = cnt;
		for(int j = 1; j<=m; j++){
			cin>>x_;
			if(x_ != 0){
				s[j]++;
				x[cnt] = i;  y[cnt] = j;
				d[u[j]] = cnt;  u[cnt] = u[j];
				d[cnt] = j;  u[j] = cnt;
				l[cnt] = end;  r[cnt] = bin;
				r[end] = cnt;  l[bin] = cnt;
				end = cnt;
				cnt++;
			}
		}
	}
}
void print(){
    if(finded) for(int i = 1; i<=cnt1; i++)cout<<ans[i]<<" ";
	else cout<<"No Solution!";
}
int main(){
	build();
	dfs();
	print();
	return 0;
}

```
禁止抄袭。

---

## 作者：_Imaginary_ (赞：1)

首先，让我们令

$$
A=
\begin{bmatrix}
0&1&1&1&0&1\\
1&1&0&0&0&1\\
1&0&0&0&1&0\\
0&1&0&0&0&1
\end{bmatrix}
$$

显然，第 $5$ 列中，我们必须选第三行，否则这一列中就不符合条件。

于是，我们选了第三行，同时第五列也满足了条件，标记一下：

$$
B=
\begin{bmatrix}
0&1&1&1&(0)&1\\
1&1&0&0&(0)&1\\
(1)&(0)&(0)&(0)&(1)&(0)\\
0&1&0&0&(0)&1
\end{bmatrix}
$$

我们发现，第一列已经选了一个，满足了条件，于是第一列是 $1$ 的都不能选。所以，我们再标记一下：

$$
C=
\begin{bmatrix}
(0)&1&1&1&(0)&1\\
(1)&(1)&(0)&(0)&(0)&(1)\\
(1)&(0)&(0)&(0)&(1)&(0)\\
(0)&1&0&0&(0)&1
\end{bmatrix}
$$

这些打括号的点我们可以不用考虑，所以删掉。

$$
D=
\begin{bmatrix}
1&1&1&1\\
1&0&0&1
\end{bmatrix}
$$

我们考虑第二列。此时我们必须选第一行。选完后所有的点都被删除了。所以，

$$
E=\varnothing
$$

这样我们就选出了一种方案。

这可以用一个叫舞蹈链的东西来维护。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=100005,inf=0x3f3f3f3f;
int n,m,cnt;
int L[N],R[N],U[N],D[N];
int row[N],col[N];
int sz[N];
bool ok=0;
int ans[N];
void build()
{
	ans[0]=ok=0;
	scanf("%d%d",&n,&m);
	for(int i=0;i<=m;i++)
	{
		sz[i]=0;
		L[i]=i-1; R[i]=i+1;
		U[i]=D[i]=i;
	}
	L[0]=m;R[m]=0;
	cnt=m+1;
	for(int i=1;i<=n;i++)
	{
		int x,begin,end;
		begin=end=cnt;
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&x);
			if(!x) continue;
			sz[j]++;
			row[cnt]=i;
			col[cnt]=j;
			D[U[j]]=cnt;U[cnt]=U[j];
			D[cnt]=j;U[j]=cnt;
			L[cnt]=end;R[cnt]=begin;
			R[end]=cnt;L[begin]=cnt;
			end=cnt;
			++cnt;
		}
	}
}
void Del(int c)
{
	L[R[c]]=L[c],R[L[c]]=R[c];
	for(int i=D[c];i!=c;i=D[i])
		for(int j=R[i];j!=i;j=R[j])
			U[D[j]]=U[j],D[U[j]]=D[j],--sz[col[j]];
}
void Resume(int c)
{
	L[R[c]]=R[L[c]]=c;
	for(int i=U[c];i!=c;i=U[i])
		for(int j=L[i];j!=i;j=L[j])
			U[D[j]]=j,D[U[j]]=j,++sz[col[j]];
	
}
void dfs()
{
	if(R[0]==0)
	{
		ok=1;
		return;
	}
	int mn=inf,c=-1;
	for(int i=R[0];i;i=R[i])
	{
		if(!sz[i]) return;
		if(sz[i]<mn) mn=sz[i],c=i;
	}
	Del(c);
	for(int i=D[c];i!=c;i=D[i])
	{
		ans[++ans[0]]=row[i];
		for(int j=R[i];j!=i;j=R[j]) Del(col[j]);
		dfs();
		if(ok) return;
		--ans[0];
		for(int j=L[i];j!=i;j=L[j]) Resume(col[j]);
	}
	Resume(c);
}
int main()
{
	build();
	dfs();
	if(ok&&ans[0]) for(int i=1;i<=ans[0];i++) printf("%d ",ans[i]);
	else printf("No Solution!");
	return 0;
}

```

---


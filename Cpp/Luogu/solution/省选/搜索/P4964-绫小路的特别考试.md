# 绫小路的特别考试

## 题目背景

>  这世界上「胜利」便是一切。无关乎过程。
要付出多少牺牲都无所谓。只要最后我「胜出」那就行了。

![](https://i.loli.net/2018/10/06/5bb879f4ac370.jpg)

## 题目描述

一场新的特别考试来临了，这次的考试内容是（wan e de）文化课，但有所不同的是，考试中允许学生使用对讲机。然而，对讲机的接收范围是有限的（每个对讲机都能发送无限远，但是只能接收到接收范围内的信号），所以不是所有学生都能接收到其他同学的广播。

考试时，共有 $n$ 名学生坐成一排（从左至右依次编号为 $1$ ~ $n$），绫小路自己坐在第 $c$ 号位置。每名学生都有一个能力值 $w_i$。绫小路已经给每名学生安排了一个接收范围为 $d_i$ 的对讲机。

每名学生可以直接做出难度**不超过**自身能力值的**所有**题目，一旦一名学生凭能力做出某道题，他就会把这道题的做法进行广播。一名坐在位置 $i$，有接收范围为 $d_i$ 的对讲机的学生，可以接收到 $[i-d_i,\ i+d_i]$ 范围内所有学生的广播，若这个范围内有人公布了做法，则他将会做这道题，并也会把这道题的做法进行广播。

绫小路会问你一些问题：当一道题目难度为 $x$ 时，有多少学生会做这道题？由于绫小路想隐藏实力，他可能会修改自己的能力值。这两种操作分别用以下两种方式表示：

- $1\ x$，表示询问当一道题目难度为 $x$ 时，有多少学生会做这道题。

- $2\ x$，将绫小路的能力值修改为 $x$，即将 $w_c$ 修改为 $x$。

---

形式化描述（与上文同义）：

> 给你两个长为 $n$ 的数列 $w_{1..n}$ 和 $d_{1..n}$，以及一个 $w_c$ 可修改的位置 $c$。现在有两种操作（共 $m$ 次）：
- $1\ x$ 表示一次询问：设 $f_i=\begin{cases}1\quad(w_i\ge x)\\1\quad(\exists\ j \in [i - d_i,\ i + d_i],\ f_j=1)\\ 0\quad(otherwise)\end{cases}$，这里的 $f_i$ 定义中引用了 $f_j$，$\ \ \ \ $所以 $f_{1..n}$ 是会不断更新的，直到无法继续更新时，计算这次询问的答案为 $\sum\limits_{i=1}^nf_i$。
- $2\ x$ 表示一次修改：把 $w_c$ 修改为 $x$。

## 说明/提示

### 你需要用到的变量：

$1\le c\le n\le 2\times 10^6$，$1\le m\le 2\times 10^6$，$0\le w_i,\ d_i,\ x<n$。

### 其它用于生成数据的变量：

$1\le \mathrm{seed},\ \mathrm{mfq}\le 10^9$，$0\le \mathrm{mind}\le \mathrm{maxd}<n$，$0\le k\le 2\times 10^5$，$1\le p\le n$，$0\le t<n$。

## 样例解释

### 样例一：

生成得到三名同学的能力值 $w_{1..3} = \{0,\ 1,\ 2\}$，对讲机接收范围 $d_{1..3} = \{1,\ 0,\ 1\}$。

第一个操作是 `1 1`，询问有多少同学会做难度为 $1$ 的题。

绫小路（第 $2$ 名同学）和第 $3$ 名同学能够独立做出这道题（$w_2 \ge 1$ ，$w_3 \ge 1$），第 $1$ 名同学虽然能力不足，但通过对讲机能接收到绫小路广播的做法（$2 \in [1 - d_1,\ 1 + d_1]$），所以他也会做。故 $ans_1 = 3$。

第二个操作是 `2 0`，修改绫小路（第 $2$ 名同学）的能力值为 $0$。此时 $w_{1..3} = \{0,\ 0,\ 2\}$。

第三个操作是 `1 1`，再次询问有多少同学会做难度为 $1$ 的题。

只有第 $3$ 名同学能够独立做出（$w_3 \ge 1$），然而第 $1$ 名同学和绫小路（第 $2$ 名同学）都无法接收到他广播的做法（$3 \notin [1 - d_1,\ 1 + d_1]$，$3 \notin [2 - d_2,\ 2 + d_2]$），做不出来。故 $ans_2 = 1$。

综上所述，$T_1 = ans_1 = 3$，$T_2 = 3 \times T_1+ ans_2 = 3 \times 233 + 1 = 700$，仅输出 $700$ 即可。

### 样例二：

生成得到 $w_{1..10} = \{1,\ 6,\ 6,\ 5,\ 3,\ 5,\ 2,\ 7,\ 9,\ 5\}$，$d_{1..10} =\{1,\ 1,\ 1,\ 1,\ 2,\ 0,\ 1,\ 0,\ 1,\ 1\}$。

十次操作及对应结果如下所示：

`1 6`，查询操作，$ans_1 = 9$，$T_1 = 9$。

`2 2`，修改操作，$w_{1..10}$ 变为 $\{1,\ 6,\ 6,\ 5,\ 3,\ 5,\ 2,\ 2,\ 9,\ 5\}$。

`1 7`，查询操作，$ans_2 = 2$，$T_2 = 2099$。

`1 3`，查询操作，$ans_3 = 9$，$T_3 = 489076$。

`2 4`，修改操作，$w_{1..10}$ 变为 $\{1,\ 6,\ 6,\ 5,\ 3,\ 5,\ 2,\ 4,\ 9,\ 5\}$。

`1 3`，查询操作，$ans_4 = 10$，$T_4 = 113954718$。
  
`2 2`，修改操作，$w_{1..10}$ 变为 $\{1,\ 6,\ 6,\ 5,\ 3,\ 5,\ 2,\ 2,\ 9,\ 5\}$。
  
`1 9`，查询操作，$ans_5 = 2$，$T_5 = 597096118$。  

`1 0`，查询操作，$ans_6 = 10$，$T_6 = 367430437$。    

`1 3`，查询操作，$ans_7 = 9$，$T_7 = 760521825$。

仅输出 $760521825$ 即可。

### 样例三：

~~出题人有足够的良心写出这个样例的解释，可惜版面太小，写不下。~~

## 样例 #1

### 输入

```
3 3 2
19720918 0 1 2 0```

### 输出

```
700```

## 样例 #2

### 输入

```
10 10 8
2102036 0 1 4 1
5 2```

### 输出

```
760521825```

## 样例 #3

### 输入

```
1000 1000 126
114321251 1 2 2 0```

### 输出

```
91977056```

# 题解

## 作者：ouuan (赞：8)

### 〇、暴力

首先这题有一个比较好想的暴力：对于每对可以传递答案的同学连单向边，然后从每个可以独立作出的同学开始dfs。

这个暴力主要有两个问题：

1. 边数太多，最多可以达到 $O(n^2)$ 的级别。

2. 每次询问都要dfs一次。

下面将分别进行讲解：

### 一、连边

其实对于每个同学，只需要向左右两边最近的能够接收到的同学各连一条边即可。

不妨令当前同学为第 $u$ 位同学，他左边最近的能够接收到他的广播的同学为 $l_u(l_u=\max\{v|v<u,v+d_v\ge u\})$.

若存在比 $l_u$ 更远的一位同学 $p(p<l_u,p+d_p\ge u)$ 能够接收到 $u$ 的广播，那么 $p$ 一定能够接收到 $l_u$ 的广播，而 $l_u$ 又能接收到 $u$ 的广播。

所以，$u$ 向左只用连 $(u,l_u)$ 这条边即可。向右是类似的。一共只要连不到 $2n$ 条边。

~~说得好，怎么实现呢？~~

用一个栈，从左往右扫一遍，如果栈顶无法接收到当前同学的广播就弹出，若栈非空就向栈顶连边，然后将当前同学入栈。然后再从右往左扫一遍就好了。

### 二、单次dfs

> 注：这里的单次dfs不是指只dfs一次，而是指所有的dfs过程总复杂度为 $O(n)$

每次询问的时候dfs的起点都是 $w_i$ 中最大的一些，所以先对 $w_i$ 排序。

~~然后按顺序依次进行dfs就可以啦！~~

停！怎么dfs？怎么回答询问？

从大到小枚举 $x$，每次把 $w_i=x$ 的点作为起点dfs，然后记录每个询问 $x$ 的答案，就可以回答询问啦！

~~你当这题没有修改吗？？？~~

事实上，修改造成的影响只有 $w_c<x$，$w_c\ge x$ 两种，所以分两种情况，$ans[0][x]$ 表示 $w_c<x$ 时询问 $x$ 的答案，$ans[1][x]$ 表示 $w_c\ge x$ 时询问 $x$ 的答案。计算 $ans[0][x]$ 时跳过 $c$，计算 $ans[1][x]$ 时先以 $c$ 为起点dfs再dfs其它点。

总复杂度：$O(n+q)$

~~等等？排序呢？？？~~

$0\le w_i<n$，所以可以用各种 $O(n)$ 排序算法，比如计数排序。

值得注意的是，vector/前向星常数可能较大。由于每个点最多只连两条边，可以用两个数组分别存向左/向右的边。同时最好不要用vector/前向星来作为桶排序的容器。

当然，~~ctr非常良心~~，实测前向星存图+前向星桶排~~只需~~$2.7s$，是可过的。两个数组存图+`std::sort`也只需 $1.8s$。

### 参考代码：

```cpp
#include <cstdio>
#include <cstring>

const int N=2000010;

void dfs(int u);

unsigned long long seed;
int n, m, c, mfq, mind, maxd, k, w[2000001], d[2000001];
int sta[N],top,tot,ans[2][N],l[N],r[N],ord[N],cnt[N];
bool vis[N];

inline int randInt() { seed = 99999989 * seed + 1000000007; return seed >> 33; } 

void generate()
{
    for (int i = 1; i <= n; i++) { w[i] = randInt() % n; }
    for (int i = 1; i <= n; i++) { d[i] = randInt() % (maxd - mind + 1) + mind; }
}

void getOperation(int lastans, int &opt, int &x)
{
    if ((0ll + randInt() + lastans) % mfq) { opt = 1; } else { opt = 2; }
    x = (0ll + randInt() + lastans) % n;
}

int main()
{
    int i,j,lxl;
    
    scanf("%d %d %d", &n, &m, &c);
    scanf("%llu %d %d %d %d", &seed, &mind, &maxd, &mfq, &k);
    generate();
    for (int i = 1; i <= k; i++)
    {
        int p, t;
        scanf("%d %d", &p, &t);
        d[p] = t;
    }
    
    lxl=w[c]; //lxl表示当前绫小路的能力值
    
    for (i=1;i<=n;++i) //连边
    {
        while (top&&sta[top]+d[sta[top]]<i)
        {
            --top;
        }
        if (top)
        {
            l[i]=sta[top];
        }
        sta[++top]=i;
    }
    
    top=0;
    
    for (i=n;i>=1;--i)
    {
        while (top&&sta[top]-d[sta[top]]>i)
        {
            --top;
        }
        if (top)
        {
            r[i]=sta[top];
        }
        sta[++top]=i;
    }
    
    for (i=1;i<=n;++i) //计数排序
    {
    	++cnt[w[i]];
	}
	for (i=n-1;i>=0;--i)
	{
		cnt[i]+=cnt[i+1];
	}
	for (i=1;i<=n;++i)
	{
		ord[--cnt[w[i]]]=i;
	}
    
    for (i=n-1,j=0;i>=0;--i) //计算ans[0][i]
    {
    	while (j<n&&w[ord[j]]==i)
    	{
    		if (ord[j]!=c)
    		{
    			dfs(ord[j]);
			}
			++j;
		}
        ans[0][i]=tot;
    }
    
    tot=0;
    memset(vis,false,sizeof(vis));
    dfs(c);
    
    for (i=n-1,j=0;i>=0;--i) //计算ans[1][i]
    {
    	while (j<n&&w[ord[j]]==i)
    	{
    		if (ord[j]!=c)
    		{
    			dfs(ord[j]);
			}
			++j;
		}
        ans[1][i]=tot;
    }
    
    int lastans = 0, finalans = 0;
    for (i = 1; i <= m; i++)
    {
        int opt, x;
        getOperation(lastans, opt, x);
        if (opt == 1)
        {
            finalans = (finalans * 233ll + ans[lxl>=x][x]) % 998244353;
            lastans = ans[lxl>=x][x];
        }
        else
        {
            lxl=x;
        }
    }
    printf("%d\n", finalans);
    return 0;
}

void dfs(int u)
{
    if (vis[u]||u==0)
    {
        return;
    }
    vis[u]=true;
    ++tot;
    dfs(l[u]);
    dfs(r[u]);
}
```

---

## 作者：SpeMars (赞：5)

Hidden is a kind of outstanding talent

深藏不露是一种卓越的才能。

首先排除较为复杂 (du liu) 的输入输出格式，

那么这一题该从何着手呢？

从询问的角度切入，

对于每一个人都有一个能力值 $w_i$ ,接收范围 $d_i$，

对于每次询问，都要求出有多少同学能做出难度为 $x$ 的题目，

首先每一个 $w_i$ $\ge$ $x$ 的同学一定做的出来 ~~这题我做过~~

那么其他同学呢，其他同学可以通过接收广播 (zuo bi) 来完成题目，

又因为每一个人的广播可以传播无限远，

那么是不是只要有一人会做，全部人都会做了 ~~一人首A,万人AC~~

显然不是的，虽然每个人的广播可无限传播，

但是接受范围是有限的，在 [ $i-d_i$ , $i+d_i$ ] 这个闭合区间内，

那么我们很容易就能想到 DFS（大法术），

枚举每个点记为 $i$ ,那么能接收到 $i$ 广播的点记为 $j$ ,

对于每一个 $j$ ,都建一条从 $i$ -> $j$ 的单向边，

那么每次从 $w_i$ $\ge$ $x$ 的点跑 DFS ,再用一个 $cnt$ 计数输出即可。

但是 $n$ 的上限达到了 $2*10^6$ 显然 $n^2$ 时间和空间复杂度都太高了。

有了基本的思路，优化就有了大致的方向,

我们先考虑空间优化，

对于每一个点 $i$ ，极端情况每个点都会连接其余的 $n-1$ 个点，

也就是 $n^2$ 的空间，明显会MLE。

其实对于每个点 $i$ ，最多要连两条边，

即往左，右各连接离 $i$ 最近且能够接收到 $i$ 广播的最近的点。

怎么理解呢？

假定存在一个在 $i$ 左边 离 $i$ 较远但是仍然能接收到 $i$ 广播的点 $p$ ,

设左边离 $i$ 最近且能够接收到 $i$ 广播的最近的点为 $l$ ,

那么 $p$ 一定可以接收到 $l$ 的广播，因为 $l$ 相对于 $i$ 更接近 $p$ 。

$p$ 能接收 $i$ 的广播，所以 $p$ 就一定会接收到 $l$ 的广播。

右边也是同理，所以总连边数从 $n^2$ 降为 $2n$ 复杂度大大减低。

我们将 $w_i$ 按降序排序后跑总时间复杂度为 O( $n$ ) 的 DFS 即可，

预处理每一个 $x$ ,最后 O( 1 ) 输出即可。

但是别忘记了还有修改操作，

修改操作只对于路哥有效果，可以随意更改自身实力。

~~社会我路哥，人狠话不多~~

那么每次修改 $w_c$ 的值对于答案的的影响无非就只有两种影响。

1.我路哥会做这题，并广播出去。

2.我路哥要隐藏实力，故意不做也不告诉你们解法。

无非就是否 DFS $c$ 这个点的区别。

所以预处理时我们用一个二维数组 $f[2][n]$ 存储答案。

$f[0][x]$ 表示难度为 $x$ 路哥不做题时有多少人会做。

$f[1][x]$ 表示难度为 $x$ 路哥做题时有多少人会做。

so:

对于 $f[0][x]$ 我们只需要不从 $c$ 跑 DFS ,只跑其他可行点 DFS 即可。

反之,对于 $f[1][x]$ 我们先从 $c$ 跑 DFS ，再跑其他可行点 DFS 即可。

最后对于每次修改，只需要修改路哥的能力值( $w_c$ )即可。

## Code:

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
unsigned long long seed;
const int N=2e6+10;
struct node{
	int w,pos;//pos为当前点排序前在序列中的哪个位置
}p[N];
int n,m,c,mfq,mind,maxd,k,kiy,ans,cnt,top;
int w[N],d[N],s[N],l[N],r[N],f[2][N];
bool vis[N];
inline int randInt(){
	seed=99999989*seed+1000000007;
	return seed>>33;
} 
void generate(){
    for(int i=1;i<=n;++i)w[i]=randInt()%n;
    for(int i=1;i<=n;++i)d[i]=randInt()%(maxd-mind+1)+mind;
}
void getOperation(int lastans,int &opt,int &x){
    if((0ll+randInt()+lastans)%mfq)opt=1;
	else opt=2;
    x=(0ll+randInt()+lastans)%n;
    return;
}
bool cmp(node x,node y){
	return x.w>y.w;//从大到小排序
}
void dfs(int u){
	if(vis[u]||u==0)return;
	vis[u]=true;
	++cnt;//计数
	dfs(l[u]);
	dfs(r[u]);
	return;
}
int main(){
    scanf("%d%d%d",&n,&m,&c);
    scanf("%llu%d%d%d%d",&seed,&mind,&maxd,&mfq,&k);
    generate();
    for(int i=1;i<=k;++i){
        int p,t;
        scanf("%d%d",&p,&t);
        d[p]=t;
    }
    kiy=w[c];//绫小路清隆的当前能力值
    top=0;//用单调栈维护连边
    for(int i=1;i<=n;++i){
    	p[i].w=w[i];
    	p[i].pos=i;
	}
    //左右各连一次边用数组存图
    for(int i=1;i<=n;++i){
    	for(;top&&s[top]+d[s[top]]<i;--top);
    	if(top)l[i]=s[top];
    	s[++top]=i;
	}
	top=0;
	for(int i=n;i>=1;--i){
		for(;top&&s[top]-d[s[top]]>i;--top);
    	if(top)r[i]=s[top];
    	s[++top]=i;
	}
	sort(p+1,p+n+1,cmp);//按w降序排序
   	//预处理f[0][W]
	for(int W=n-1,i=1;W>=0;--W){//W最大为n-1
    	//从大到小枚举W，因为f[0][n-1]~f[0][0]单调递增
		for(;i<=n&&p[i].w==W;++i){
			if(p[i].pos!=c)dfs(p[i].pos);
		}
		f[0][W]=cnt;
	}
    	//预处理f[1][W]
	memset(vis,false,sizeof(vis));
	cnt=0,dfs(c);//初始化后先跑c
    	//依样画葫芦
	for(int W=n-1,i=1;W>=0;--W){
		for(;i<=n&&p[i].w==W;++i){
			dfs(p[i].pos);
		}
		f[1][W]=cnt;
	}
    int lastans=0,finalans=0;
    for(int i=1;i<=m;++i){
        int opt,x;
        getOperation(lastans,opt,x);
        if(opt==1){
        	if(kiy<x)ans=f[0][x];
        	else ans=f[1][x];
            	//处理答案
            finalans=(finalans*233ll+ans)%998244353;
            lastans=ans;
        }
        else kiy=x;
    }
    printf("%d\n",finalans);
    return 0;
}
/*
样例:

3 3 2
19720918 0 1 2 0

10 10 8
2102036 0 1 4 1
5 2

1000 1000 126
114321251 1 2 2 0
*/
```

---

## 作者：nullqtr_pwp (赞：2)

先讲 $n\leq 3000$ 的做法。

这道题显然可以抽象一张有向图上乱搞的问题。建边就是考虑谁会被一个人连带起来。具体就是所有满足 $\min(n,v+d_v)\ge u$ 或者 $\max(1,v-d_v)\leq u$ 的 $v$ 向 $u$ 连边。

在查询次数很多的时候，我们一般要求 $O(1)$ 或者以较低的时间复杂度求答案。在这题由于修改只针对定点，我们可以 **直接预处理出所有答案。** 

记 $ans_{i}$ 表示查询为 $i$ 时的答案，发现定点的值需要分讨，故优化成 $ans_{i,0/1}$ 表示查询为 $i$，且当前 $a_p=x$ 分别为 $x\ge i$ 与 $x<i$ 的答案。这样可以不重不漏的覆盖所有情况。对于 $ans_{i,0}$ 和 $ans_{i,1}$，分别扫描线一下就好了。 

再讲 $n\leq 10^6$ 的做法。

显然建边是搞笑的。你直接去找最大的前驱和后继连边即可。边数直接从 $O(n^2)$ 降到 $O(n)$，这样做的正确性是因为，不会影响任意两点间的连通性。这个你直接开个栈维护就行了。

---

## 作者：Angraecum (赞：1)

>善于隐藏自己的精明，才称得上是最大的精明。
>——拉罗什福科《道德箴言录》

首先注意 $d_i$ 的意义是 $i$ 能**接收** $[i-d_i,i+d_i]$ 的人发的消息，而不是 $i$ 能给其他人**发**消息的范围。

$O(n^2)$ 做法是直接暴力让 $i$ 和 $[i-d_i,i+d_i]$ 内的所有点连指向 $i$ 的边，查询就直接对每个点 dfs 一遍，如果遍历过了就不额外 dfs 了，单次查询均摊下来是 $O(n^2)$ 的。

最大的问题在于边数过多，其实画画图就能发现对于每个 $i$ 只需要向左右两边最近的**能收到他的消息**的点连边就行了，因为这样相当于只保留了必要的边，不改变连通性，就把边数降到了 $O(n)$ 级。这个过程可以用单调栈搞。

但查询如果还是每次重做一遍 dfs 就是 $O(nm)$ 的，而这题又强制在线。但是注意到学生能力 $w_i$ 和每次查询的难度 $x$ 都是 $<n$ 的，这启示我们从值域入手。到这里想法都是很自然的。

因为修改操作只会修改路哥一个人（他对每道题只有做出来或没做出来的情况），并且值域小，所以可以想到预处理每个难度 $x$ 的答案。

做题人数显然和题目难度成正比，所以我们可以提前对学生按能力**降序**排序，然后降序枚举难度 $x$ 双指针处理答案。我们做两遍这样的操作记录路哥是否做出这道题时的答案就行了。

复杂度 $O(n\log n)$，瓶颈在于对学生排序，可以桶排优化，但很奇怪我桶排是错的。

代码不难实现：


```cpp
ll AK; //路哥的能力值
struct xx{
	ll v,id;
	bool operator <(const xx &b)const{
		return v>b.v;
	}
}a[N];
ll st[N],l[N],r[N],res;
ll ans[N][2];
bool vis[N];
void dfs(ll u){
	if(vis[u]||!u) return;
	vis[u]=1,++res;
	if(l[u]) dfs(l[u]);
	if(r[u]) dfs(r[u]);
}
int main(){
    scanf("%d %d %d", &n, &m, &c);
    scanf("%llu %d %d %d %d", &seed, &mind, &maxd, &mfq, &k);
    generate();
    for (int i = 1; i <= k; i++){
        int p, t;
        scanf("%d %d", &p, &t);
        d[p] = t;
    }
    AK=w[c];
    for(int i=1;i<=n;++i) a[i]={w[i],i};
    sort(a+1,a+n+1);
    for(int i=1,j=0;i<=n;++i){
    	while(j&&st[j]+d[st[j]]<i) --j;
    	if(j) l[i]=st[j];
		st[++j]=i;
	}
	for(int i=n,j=0;i>=1;--i){
		while(j&&st[j]-d[st[j]]>i) --j;
		if(j) r[i]=st[j];
		st[++j]=i;
	}
	for(int x=n-1,i=1;x>=0;--x){
		while(i<=n&&a[i].v==x){
			if(a[i].id!=c) dfs(a[i].id);
			++i;
		}
		ans[x][0]=res;
	}
	res=0;
	memset(vis,0,sizeof(vis));
	dfs(c); //注意路哥的能力值是不定的，所以必须单独处理（符合路哥独狼形象）
	for(int x=n-1,i=1;x>=0;--x){
		while(i<=n&&a[i].v==x){
			if(a[i].id!=c) dfs(a[i].id);
			++i;
		}
		ans[x][1]=res;
	}
    lxl lastans = 0, finalans = 0;
    for (int i = 1; i <= m; i++){
        int opt, x;
        getOperation(lastans, opt, x);
        if (opt == 1){
            // 在这里执行询问操作，并用答案的表达式替代下面的 ___.
            lxl ___;
			if(x>AK) ___=ans[x][0];
			else ___=ans[x][1]; 
            finalans = (finalans * 233ll + ___) % 998244353;
            lastans = ___;
        }
        else{
            // 在这里执行修改操作.
            AK=x;
        }
    }
    printf("%lld\n", finalans);
    return 0;
}
```

---


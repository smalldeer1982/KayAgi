# [Cnoi2019] 雪松果树

## 题目背景

幻想乡，冬。

一年一度，生长在高山上的雪松果树又结果了。

Cirno 不知从哪弄到了 $1,2,3\cdots9$ 颗雪松果,然后很开心的吃掉了其中 $6$ 颗，最后还剩最后 $1$ 颗。

Cirn o因为以后吃不到雪松果而感到忧愁,于是决定种在美丽的雾之湖畔。

第一天,发芽。

第二天,雪松果树长成了一颗参天大树, 上面长满了雪松果。

Cirno 在雪松果成熟之前早有一些问题想知道，但现在她忙于收集雪松果，就把问题丢给了你。

## 题目描述

雪松果树是一个以 $1$ 为根有着 $N$ 个节点的树。

除此之外, Cirno还有 $Q$ 个询问，每个询问是一个二元组 $(u,k)$ ,表示询问 $u$ 节点的 $k$-cousin 有多少个。

我们定义:

> 节点 $u$ 的 $1$-father 为 路径 $(1, u)$ （不含 u）上距 u 最近的节点
>
> 节点 $u$ 的 $k$-father 为 节点 「$u$ 的 $(k-1)$-father」 的 1-father
>
> 节点 $u$ 的 $k$-son 为所有 $k$-father 为 $u$ 的节点
>
> 节点 $u$ 的 $k$-cousin 为 节点「 $u$ 的 $k$-father」的 $k$-son (不包含 $u$ 本身)

## 说明/提示

数据范围：

对于0%-10%的数据 $N,Q \le 100$

对于10%-20%的数据 $N \le 100,Q \le 10^6$

对于 20%-30% 的数据 $N \le 10^5,Q \le100$

对于 30%-35% 的数据 $N \le 10^4,Q \le 5000$

对于 35%-50% 的数据 $N \le 10^5,Q \le 10^5$

对于 50%-70% 的数据 保证树随机

对于 70%-100% 的数据 $N,Q \le 10^6$

另外存在一组记 $20$ 分的 hack 数据。

## 样例 #1

### 输入

```
5 2
1 2 1 4
2 1
3 2```

### 输出

```
1 1```

# 题解

## 作者：皎月半洒花 (赞：52)

$\rm upd:$ 神仙`一扶苏一:uid65363`不仅帮我半夜交代码，还顺便帮我优化了一波，于是最终过掉了这个题，此处致以敬意。

友情提示，本篇`blog`不同于其他的题解，其渐进复杂度是最优的。
___

**温馨提示**：以下算法思路大致相同，但是实现有不同，从$0x01$到$0x04$,共有$4$种**常数越来优秀、空间越来越优秀的写法**。
____



## 算法$\#\bold {0x01}$ 长链剖分 + vector离线询问 + 对dfn做前缀和

前置知识：读题

$n,q=1e6$，我会长剖！大概就是发现我们首先把询问转化到$u$的$\text {k-father}$上，然后其实就是询问以某些点为根的子树里面$dep=x$的点有多少，这东西就变成了一个经典的$dsu~on~tree$的裸题，复杂度$n\log n-n\log n$。

但实际上对于每组询问，用长剖可以实现$O(1)$求$k$级祖先，故其瓶颈在于$dsu~on~tree$太浪费时间。考虑一种在$dfn$上的算法。对于一棵$u$而言，$dfn_u$到$dfn_u+size_u-1$可以刻画整棵包含$u$在内的子树。所以考虑离线询问，直接进行前缀和，拿一个桶扫一下就做完了。时间复杂度$O(n \log n)-O(m)$，空间复杂度$O(n\log n)+O(?(n))$。其中$?(n)$可以看做一个关于$n$的超线性（与亚线性相对）函数，即给$vector$预留的空间。

码码码…码完了！submit~~发现只有$50pts$？以下是部分代码：

```cpp
struct qsy{
    int x, id ; bool sg ;
    qsy(int v, int y, int z){ x = v, id = y, sg = z ; }
} ;
void dfs(int u){
    sz[u] = 1, 
    dfn[++ tot] = u, Id[u] = tot ;
    dep[u] = L[u] = dep[fa[u][0]] + 1 ;
    for (int k = head[u] ; k ; k = next(k)){
        dfs(to(k)) ; sz[u] += sz[to(k)] ;
        if (L[to(k)] > L[son[u]]) son[u] = to(k), L[u] = L[to(k)] ;
    }
}
void build(){
    for (short int i = 1 ; i < 15 ; ++ i)
        for (int j = 1 ; j <= N ; ++ j)
            fa[j][i] = fa[fa[j][i - 1]][i - 1] ;
}
void dfs(int u, int tp){
    top[u] = tp, L[u] = L[u] - dep[tp] + 1 ;
    if (son[u]) dfs(son[u], tp) ;
    for (int k = head[u] ; k ; k = next(k))
        if (to(k) != son[u]) dfs(to(k), to(k)) ;
}
int query(int u, int k){
    if (!k) return u ; if (k > dep[u]) return 0 ;
    u = fa[u][hb[k]] ; k ^= 1 << hb[k] ; if (!k) return u ;
    if (dep[u] - dep[top[u]] == k) return top[u] ;
    int dif = dep[u] - dep[top[u]] ;
    if (dep[u] - dep[top[u]] > k) return _down[top[u]][dif - k - 1] ;
    return _up[top[u]][k - dif - 1] ;
}
function :main{
    for (i = 2 ; i <= N ; ++ i) u = qr(), add(i, u) ;
	dfs(1, 0), dfs(1, 0, 1), build() ;
    for (i = 1 ; i <= N ; ++ i) if (i >> hm & 1) hb[i] = hm ++ ; else hb[i] = hm - 1 ;
    for (i = 1 ; i <= N ; ++ i){
        if (top[i] != i) continue ;
        l = 0, u = i ; while (l < L[i] && u) u = fa[u][0], ++ l, _up[i].pb(u) ;
        l = 0, u = i ; while (l < L[i] && u) u = son[u], ++ l, _down[i].pb(u) ;
    }
	for (i = 1 ; i <= M ; ++ i){
        u = qr(), k = qr(), v = query(u, k) ; if (!v) continue ;
        q[Id[v]].pb(qsy(dep[v] + k, i, -1)), q[Id[v] + sz[v] - 1].pb(qsy(dep[v] + k, i, 1)) ;
    }
    for (i = 1 ; i <= N ; ++ i){
        buc[dep[dfn[i]]] ++ ;
        for (j = 0 ; j < q[i].size() ; ++ j)
            ans[q[i][j].id] += buc[q[i][j].x] * q[i][j].sg ;
    }
}
```



是的，本题空间$\rm 128Mb$，$O(n\log n)+O(?(n))$的空间**不可承受**，因为实践中会发现$O(n\log n)\leq O(?(n))$，也就是说大头在vector……

但其实vector并不是很好优化，因为询问是要离线的。于是考虑换个空间开销小的与预处理方式——

## 算法$\#\bold {0x02}$ 栈 + vector离线询问 + 对dfn做前缀和

然后发现，其实如果不强制在线，直接用栈做$k$级祖先是一个经典问题~~nmd哪来那么多经典问题~~。就是类似用栈模仿递归的做法：

```cpp
int stk[MAXN], top ;
void do_do(const int &u){
	stk[++ top] = u ;
	for (register int i = 0 ; i < pq[u].size() ; ++ i){
		register int op = pq[u][i].id ;
		v[op] = (top > kk[op]) ? stk[top - kk[op]] : 0 ; 
	}
	for (register int k = head[u] ; k ; k = next(k)) do_do(to(k)) ; -- top ; 
}
function :main{
    for (i = 1 ; i <= M ; ++ i) uu[i] = qr(), kk[i] = qr(), pq[uu[i]].pb(qsx(kk[i], i)) ;
}
```

然后就有了一个时间复杂度$O(n)-O(n)$，空间复杂度$O(?(n))$的做法，需要多用到一个vector。之后就会发现……它喜提了$\mathsf {MLE}$，不过分数变成了$70pts$。考虑问题所在，还是vector太慢了，于是插播一个细节，就是中途我花了一些时间学习了一下怎么清空vector的内存，大概是这样：

```cpp
template < class T >
il void _clean( vector< T >& vt ) {
    vector <T> vtTemp ; vtTemp.swap(vt) ;
}
function :main{
     do_do(1) ; for (i = 1 ; i <= N ; ++ i) if (pq[i].size()) _clean(pq[i]) ;
}
```

喜闻乐见的是终于不卡空间了，但是却毫无征兆地$\mathscr{TLE}$了。不过想想也自然，这其实就相当于声明$1,000,000$个$vector$，算导上写过，这种动态表一般都是`低于1/4重构`或者`倍增式重构`，常数可想而知。

并且$vector$具有两种属性，$\rm vec.capacity()$和$\rm vec.size()$，前者是向内存申请的空间，后者是实际使用的空间，一般情况下$\rm capacity$会严格大于$\rm size$。同时有三种成员函数用来清零，`resize(n)`同时释放两者，`reserve(n)`只会释放$\rm capacity$，$\rm clear()$只会清空$\rm size$。

但最后，Luogu评测机的特性导致实际应用中这几个没有什么bird区别，于是还是选了最快的$\rm clear$。喜提$70pts$.

然后最让人心累的来了：

## 算法$\#\bold {0x03}$ 算法2 + 各种奇怪的技巧 + 对询问直接分配内存

分为两个$part$，$part·1$我$11.3$写了一下午+半晚上，$part·2$我$11.4$又写了一下午。

### $\rm Part · 1$ 奇怪的技巧

首先就是考虑如何回收那些不需要用的数组，能少$1e6$是$1e6$啊，大概思想就是vector回收+数组重复使用，并且尽量使用不需要`memset`就可以清空的数组，效果：依然$70pts$，但是空间下降至$110 ± 7$左右。

于是发现空间可控之后，就可以上一个毒瘤东西——$fread$.

不过这东西是真的有效（但仅限于本OJ某些时段，比如下午3点以后到晚上11点之前），很轻松的让我获得了$95pts$的高分……但是问题就在于，$fread$的$\rm ch\_top$这边量的大小，一般都是$1e7$级别，大了就$\mathsf{MLE}$，小了会导致$\mathsf{WA}$，只能在一定区间内波动——而波动的不只是自己敲下的数字，还有评测机。。。于是就会出现交$50$余份只调整了一些参数的代码，会出现在$70pts$~$95pts$激烈波动的情况……

不说了，fread葬送青春。于是这一个$part$最终的代码长这样：

```cpp
#include <bits/stdc++.h>
#pragma GCC target("avx")
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
const int ch_top = 22000001 ;
char ch[ch_top],*now_r=ch-1,*now_w=ch-1;

il int read(){
    while (*++now_r < 48) ;
    register int x = *now_r - 48 ;
    while (*++now_r >= 48) x = (x << 1) + (x << 3) + *now_r - 48 ;
    return x ;
}
il void write(int x){
    static char st[7] ; static int top ;
    while (st[++ top] = 48 + x % 10, x /= 10) ;
    while (*++ now_w = st[top], -- top) ; *++ now_w = ' ' ;
}
il void add(const int &u, const int &v){
    E[++ cnt].to = u, E[cnt].next = head[v], head[v] = cnt ;
}
function :main(){
	fread(ch, 1, ch_top, stdin) ;
	fwrite(ch,1,now_w-ch,stdout) ;  return 0 ;
}
```

ps：没有展现出来数组混用，大概就是边表里面的$head$数组被我用来当做ans数组了这种感觉的一系列操作。

### $\rm Part · 2$ 手动分配内存

起因大概是这样：

> uoj群
>
> 我：有没有什么减少vector占内存的方法？
>
> 神仙1：强行resize？或者先算好每个vector要多大，然后resize之后当数组用？
>
> 神仙2： 如果我知道多大我为什么不开一个大数组然后分配指针（ 

一语点醒梦中人.wtcl

然后我就~~开始学习内存分配~~换了个写法，大体就是把$vector$都成了指针，每次手动`new`出需要多少空间，我想这样怎么说也不会被卡了吧……结果MLE，于是还是只能手动`delete`.这一部分代码大概长这样：

```cpp
struct qsy{ int x, id ; bool sg ; } ; int *p[MAXN] ; qsy *q[MAXN] ; 
int main(){
    N = qr(), M = qr() ; 
	rg int u, op ; dep[1] = 1 ;
    for (rg int i = 2, j ; i <= N ; ++ i)
		j = qr(), to(++ cnt) = i, next(cnt) = head[j], head[j] = cnt ;
	cnt = 0, dfs(1) ; 
    for (rg int i = 1 ; i <= M ; ++ i) 
		v[i] = qr(), kk[i] = qr(), buc[v[i]] ++ ;
    for (rg int i = 1 ; i <= N ; ++ i) 
		p[i] = new int[buc[i] + 1], p[i][0] = buc[i] = 0 ;
    for (rg int i = 1 ; i <= M ; ++ i) 
		p[v[i]][++ p[v[i]][0]] = i, v[i] = 0 ;
    cnt = 0, do_do(1) ;  
    for (rg int i = 1 ; i <= N ; ++ i) delete p[i] ;
    for (rg int i = 1 ; i <= M ; ++ i) 
		buc[Id[v[i]]] ++, buc[Id[v[i]] + sz[v[i]] - 1] ++ ;
    for (rg int i = 0 ; i <= N ; ++ i) 
		q[i] = new qsy[buc[i] + 1], q[i][0].x = buc[i] = 0 ; 
    for (rg int i = 1, j ; i <= M ; ++ i) {
        if (!v[i]) continue ;
		u = Id[v[i]], j = dep[v[i]] + kk[i], op = u + sz[v[i]] - 1 ;
        q[u][++ q[u][0].x] = (qsy){j, i, 0}, q[op][++ q[op][0].x] = (qsy){j, i, 1} ;
    }
    for (rg int i = 1 ; i <= N ; ++ i){
        buc[dep[dfn[i]]] ++ ;
        for (rg int j = 1 ; j <= q[i][0].x ; ++ j)
            head[q[i][j].id] += q[i][j].sg ? buc[q[i][j].x] : -buc[q[i][j].x] ;
	}
    for (rg int i = 1 ; i <= M ; ++ i) 
		printf("%d ", head[i] > 0 ? head[i] - 1 : head[i]) ;
	return 0 ; 
}
```

这样最终终于是可以做到较为稳定的$80pts$~$95pts$……但是还是没有救。

## 算法$\#\bold {0x04}$ 算法2 + 链表

出于此，我便去找`—扶苏—`神仙：

![](https://cdn.luogu.com.cn/upload/image_hosting/iecbb9h4.png)

然后第二天早上发现昨晚他经历艰难的奋斗…感动的个我/dk

![](https://cdn.luogu.com.cn/upload/image_hosting/zrsqs1h7.png)

但是..!

![](https://cdn.luogu.com.cn/upload/image_hosting/ogxd0vfd.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/dqv4ohb0.png)

很有道理的亚子！于是就是最后代码:

```cpp
#include <bits/stdc++.h>

#define il inline
#define to(k) E[k].to
#define next(k) E[k].next

#define rg register 
#define MAXN 1000017

using namespace std ;
struct Edge{
    int to, next ;
}E[MAXN] ; int N, M, cnt ;
int head[MAXN], Id[MAXN], kk[MAXN] ;
int dep[MAXN], dfn[MAXN], sz[MAXN], buc[MAXN], v[MAXN] ;
struct qsy{ int x, id, next ; bool sg ; }; //; int *p[MAXN] ; qsy *q[MAXN] ;
qsy pq[MAXN << 1]; int pd[MAXN] ; int pcnt ;

il int qr(){
	rg char c = getchar() ; 
	rg int res = 0 ; while (!isdigit(c)) c = getchar() ; 
	while (isdigit(c)) res = (res << 1) + (res << 3) + c - 48, c = getchar() ;
	return res ;
}
void dfs(const int & u){
    sz[u] = 1, dfn[++ cnt] = u, Id[u] = cnt ;
    for (rg int k = head[u] ; k ; k = next(k)) 
		dep[to(k)] = dep[u] + 1, dfs(to(k)), sz[u] += sz[to(k)] ;
}
void do_do(const int &u){
	buc[++ cnt] = u ; 
	for (rg int i = pd[u]; i; i = pq[i].id) {
		int x = pq[i].x;
		v[x] = (cnt > kk[x]) ? buc[cnt - kk[x]] : 0;
	}
//	for (rg int i = 1 ; i <= p[u][0]; ++ i)
//		v[p[u][i]] = (cnt > kk[p[u][i]]) ? buc[cnt - kk[p[u][i]]] : 0 ; 
	for (rg int k = head[u] ; k ; k = next(k)) do_do(to(k)) ; buc[cnt --] = head[u] = 0 ; 
}
int main(){
    N = qr(), M = qr() ; 
	rg int u, op ; dep[1] = 1 ;
    for (rg int i = 2, j ; i <= N ; ++ i)
		j = qr(), to(++ cnt) = i, next(cnt) = head[j], head[j] = cnt ;
	cnt = 0, dfs(1) ; 
    for (rg int i = 1 ; i <= M ; ++ i) 
		v[i] = qr(), kk[i] = qr(), buc[v[i]] ++ ;
//    for (rg int i = 1 ; i <= N ; ++ i) 
//		p[i] = new int[buc[i] + 1], p[i][0] = buc[i] = 0 ;
	memset(buc, 0, sizeof buc);
    for (rg int i = 1 ; i <= M ; ++ i)
    	pq[++ pcnt].x = i, pq[pcnt].id = pd[v[i]], pd[v[i]] = pcnt, v[i] = 0 ;
//		p[v[i]][++ p[v[i]][0]] = i, v[i] = 0 ;
    cnt = 0, do_do(1) ;  
//    for (rg int i = 1 ; i <= N ; ++ i) delete p[i] ;
    for (rg int i = 1 ; i <= M ; ++ i) 
		buc[Id[v[i]]] ++, buc[Id[v[i]] + sz[v[i]] - 1] ++ ;
	pcnt = 0, memset(pd, 0, sizeof pd), memset(buc, 0, sizeof buc) ;
//    for (rg int i = 0 ; i <= N ; ++ i) 
//		q[i] = new qsy[buc[i] + 1], q[i][0].x = buc[i] = 0 ; 
    for (rg int i = 1, j ; i <= M ; ++ i) {
        if (!v[i]) continue ;
		u = Id[v[i]], j = dep[v[i]] + kk[i], op = u + sz[v[i]] - 1 ;
		pq[++ pcnt] = (qsy){j, i, pd[u], 0}, pd[u] = pcnt ;
		pq[++ pcnt] = (qsy){j, i, pd[op], 1}, pd[op] = pcnt ;
//        q[u][++ q[u][0].x] = (qsy){j, i, 0}, q[op][++ q[op][0].x] = (qsy){j, i, 1} ;
    }
    for (rg int i = 1 ; i <= N ; ++ i){
        buc[dep[dfn[i]]] ++ ;
        for (rg int j = pd[i]; j; j = pq[j].next)
            head[pq[j].id] += pq[j].sg ? buc[pq[j].x] : -buc[pq[j].x];
//        for (rg int j = 1 ; j <= q[i][0].x ; ++ j)
//            head[q[i][j].id] += q[i][j].sg ? buc[q[i][j].x] : -buc[q[i][j].x] ;
	}
    for (rg int i = 1 ; i <= M ; ++ i) 
		printf("%d ", head[i] > 0 ? head[i] - 1 : head[i]) ;
	return 0 ; 
}
```

可以通过本题。

## 后记

* ⑧说别的了，zay天下第一！
* fread是真的浪费青春……好烦啊。
* 如果出题人当时就把空间或者时间开大一倍的话，Luogu说不定可以少浪费一堆评测资源，%￥&@#￥%&。
* 祝自己csp rp++，祝zay csp rp++！

之后的事情：
![](https://cdn.luogu.com.cn/upload/image_hosting/d1e9vt19.png)

---

## 作者：Autre (赞：29)

楼下小花声称给出了一个渐进复杂度最优的做法，那我们就来个更优的做法。

第一步是用栈维护 dfs 过程中每个点的祖先，于是可以把所有询问 $(u,k)$ 登记到 $u$ 的 $k$ 级祖先处。

第二步是解决 $u$ 的 $k$ 级儿子计数问题。对于某个点 $u$，其每一级儿子数量可以看作是可以 $O(d)$（$d$ 表示树的最大深度）或 $O(s)$（$s$ 表示子树大小）合并的信息，取决于合并方式是相同位置直接相加，还是考虑其中一个子树内的点的贡献。后者的常见优化为 $O(n\log n)$ 的树上启发式合并。

考虑到信息是可减的，我们于是效仿[[NOIP2016 提高组] 天天爱打卡](https://www.luogu.com.cn/problem/P1600)和[[省选联考 2020 A 卷] 树](https://www.luogu.com.cn/problem/P6623)的做法，维护一个全局桶 $c_d$ 表示当前遍历到的所有点中深度为 $d$ 的点的数量，在每个节点处记录桶内它所关心的位置在遍历其儿子前后的值，做差即可得到子树内的答案。

时间复杂度 $O(n+q)$。代码：

```C++
#include<iostream>
#include<vector>

char bf[30000000], *ptr = bf;
void inline rd(int&x) {
    for (x=0; !isdigit(*ptr); ptr++);
    for (; isdigit(*ptr); ptr++)
        x = x * 10 + *ptr - 48;
}
const int N = 1e6;
int n, m, st[N], ct[N], ans[N], tp;
std::vector<int>g[N];
std::vector<std::pair<int, int>>q[N], h[N];
void ganc(int u) {
    for (auto[i, k] : q[u]) if (tp >= k)
        h[st[tp-k]].emplace_back(i, tp);
    else ans[i] = 1;
    for (st[tp++]=u; int v : g[u]) ganc(v);
    tp--;
}
void gans(int u) {
    for (auto[i, k] : h[u]) ans[i] = -ct[k];
    for (ct[tp++]++; int v : g[u]) gans(v); tp--;
    for (auto[i, k] : h[u]) ans[i] += ct[k];
}
int main() {
    fread(bf, 1, sizeof bf, stdin), rd(n), rd(m);
    for (int i=1, f; i<n; i++) rd(f), g[f-1].push_back(i);
    for (int i=0, u, k; i<m; i++)
        rd(u), rd(k), q[u-1].emplace_back(i, k);
    ganc(0), gans(0);
    for (int i=0; i<m; i++) printf("%d ", ans[i]-1);
}
```

---

## 作者：feecle6418 (赞：17)

## Update on 2020.5.6

增加优化，保证了能过目前的所有 Hack 数据。

## 线段树合并是能过这个题的！（并且跑到了最优解第一页）

没错。

诶线段树合并 $O(n\log n)$ 空间 $O(n\log n)$ 时间怎么可能过？

下面我们一一优化。

## Step 1：优化空间

首先求 $k$ 级祖先可以离线然后 dfs，用一个栈记录当前节点的所有祖先，然后 $O(n)$ 得到。但是线段树合并呢？

~~其实，假如合并完一颗子树后**马上删除这棵子树的线段树**，空间复杂度是 $O(n)$！但是，条件是：按照 `size` 从大到小访问所有儿子。~~

~~为什么？因为在任意时刻，真正存在的至多只有两棵线段树：~~

- ~~正在被合并的节点 $y$ 的子树的线段树。~~
- ~~正在将 $y$ 并入的 $x$ 的 $y$ 之前的儿子合并成的线段树。~~

注意我们按照 `size` 排序了儿子，因此不会出现许多小点增加无意义的空间的情况。**现在作者不能证明空间复杂度，若有能证明的 / Hack 的请私信我。**

~~每棵线段树空间都是 $O(n)$，因此总空间就是 $O(n)$。~~

## Step 2：换掉 vector

由于 `vector` 过于占空间，我们需要用类似于链表的方法将询问串起来。具体可以看代码，实现很简单。

## Step 3：常数优化

首先快读快输。$10^6$ 的数据，输入输出优化会有很大作用。

然后线段树的值域最大不用到 $n$，而是最大的深度。这里也可以稍稍优化一下。**同时这个优化也使得空间大大减小，因此暂时无法找到 Hack 数据。**

## Step 4：代码

AC 代码如下。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<vector>
#include<algorithm>
using namespace std;
inline char get_char() {
	static char buf[5000001],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,5000000,stdin),p1==p2)?EOF:*p1++;
}
//#define get_char getchar
inline int read() {
	char ch;
	int x=0,ff=1;
	do {
		ch=get_char();
	} while((ch<'0'||'9'<ch)&&ch!='-');
	if(ch=='-')ff=-1,ch=get_char();
	while('0'<=ch&&ch<='9') {
		x=10*x+ch-'0';
		ch=get_char();
	}
	return x*ff;
}
char buffer[7000005];
int p1=-1;
const int p2=7000000;
inline void flush() {
	fwrite(buffer,1,p1+1,stdout),p1=-1;
}
inline void putc(const char &x){
	if(p1==p2)flush();
	buffer[++p1]=x;
}
void wrtn(int x) {
	if(!x){
		putc('0');
		putc(' ');
		return ;
	} 
	static char buf[15];
	static int len=-1;
	do {
		buf[++len]=x%10+48,x/=10;
	} while(x);
	while(len>=0){
		putc(buf[len]),--len;
	}
	putc(' ');
}
int n,cnt,cntt,yyy,hh[1000005],hhh[1000005],yyyy,h[1000005],root[1000005],ans[1000005],d[1000005],q,st[4000005],top,sta[1000005],top2,size[1000005];
struct TreeNode{
	int ls,rs,sum;
}t[4000005];
struct Edge{
	int to,next;
}e[1000005];
struct Que{
	int k,id,next;
}qq[1000005],qqq[1000005];
int NewNode(){
	if(top)return st[top--];
	return ++cntt;
}
void Add_Edge(int x,int y){
	e[++cnt].to=y;
	e[cnt].next=h[x];
	h[x]=cnt;
}
void AddQ(int x,int k,int id){
	qq[++yyy]={k,id,hh[x]};
	hh[x]=yyy;
}
void Addqq(int x,int k,int id){
	qqq[++yyyy]={k,id,hhh[x]};
	hhh[x]=yyyy;
}
void Update(int &p,int l,int r,int x){
	if(!p)p=NewNode();
	if(l==r){
		t[p].sum++;
		return ;
	}
	int mid=(l+r)/2;
	if(x<=mid)Update(t[p].ls,l,mid,x);
	else Update(t[p].rs,mid+1,r,x);
}
void Merge(int &p,int q,int l,int r){
	if(!p||!q){
		p=p+q;
		return ;
	}
	if(l==r){
		t[p].sum+=t[q].sum;
		t[q].ls=t[q].rs=t[q].sum=0;
		st[++top]=q;
		return ;
	}
	int mid=(l+r)/2;
	Merge(t[p].ls,t[q].ls,l,mid);
	Merge(t[p].rs,t[q].rs,mid+1,r);
	t[q].ls=t[q].rs=t[q].sum=0;
	st[++top]=q;
}
int Query(int p,int l,int r,int x){
	if(l==r)return t[p].sum;
	int mid=(l+r)/2;
	if(x<=mid)return Query(t[p].ls,l,mid,x);
	else return Query(t[p].rs,mid+1,r,x);
}
int maxd=0;
int aa[1000005]={0};
void Solve(int now,int fa){
	sta[++top2]=now;
	for(int i=hh[now];i;i=qq[i].next){
		Que y=qq[i];
		if(top2>y.k)Addqq(sta[top2-y.k],d[now],y.id);
	}
	root[now]=++cntt;
	int from=aa[0];
	for(int i=h[now];i;i=e[i].next)aa[++aa[0]]=e[i].to;
	int to=aa[0];
	sort(aa+from+1,aa+to+1,[](int x,int y){return size[x]>size[y];});
	for(int i=from+1;i<=to;i++){
		int y=aa[i];
		//cout<<now<<' '<<y<<endl;
		Solve(y,now);
		Merge(root[now],root[y],1,maxd);
	}
	Update(root[now],1,maxd,d[now]);
	for(int i=hhh[now];i;i=qqq[i].next){
		Que y=qqq[i];
		ans[y.id]=Query(root[now],1,maxd,y.k);
	}
	top2--;
}
void DFS(int now,int dep){
	maxd=max(maxd,dep);
	d[now]=dep,size[now]=1;
	for(int i=h[now];i;i=e[i].next){
		int y=e[i].to;
		DFS(y,dep+1);
		size[now]+=size[y];
	}
}
int main(){
	n=read(),q=read();
	for(int i=2,x;i<=n;i++){
		x=read();
		Add_Edge(x,i);
	}
	DFS(1,1);
	for(int i=1,x,k;i<=q;i++){
		x=read(),k=read();
		AddQ(x,k,i);
	}
	Solve(1,0);
	for(int i=1;i<=q;i++)wrtn(max(ans[i]-1,0));
	flush();
	return 0;
}
```



---

## 作者：夜猫子驱蚊器 (赞：10)

[传送门](https://www.luogu.org/problem/P5384)

虽然这题是一道二合一，也不算难，但还是学到了很多东西啊，$k$ 级儿子个数的五种求法！！我还是觉得四种比较好（

$k$ 级儿子个数有五种求法，你知道么？ ——鲁迅

首先 $k$ 级祖先很好求，离线的话dfs的时候开个栈就好了。长链剖分也可以但我不会，倍增什么的就不用说了。

### 树上启发式合并

就是求一个子树里为某一个深度的点的个数嘛，这个明显可以dsu on tree啊，开个桶记录下各种深度的有几个就好了。

复杂度：$O(nlogn)$，应该不能过0_0

### 树状数组

转化为dfs序，就是一个区间里等于某一个数的个数，二维数点弱化版，离线+树状数组。

复杂度：$O(nlogn)$

### 二分

给每个深度开一个vector，按照dfs序把点塞进去，询问时只要在对应深度的vector里二分出区间左右端点就好了。

这个做法虽然也是 $O(nlogn)$ ，但它是在线的，很妙啊！！

### 长链剖分

这个是模板了吧，用一个简单的DP统计一下就好了

复杂度 $O(n)$

因为我之前其实不会长链剖分所以就写了下代码……

随便卡一卡空间就能过了……

```cpp
#include<bits/stdc++.h>
#define ll long long
#define fr(i,x,y) for(int i=(x);i<=(y);i++)
#define rf(i,x,y) for(int i=(x);i>=(y);i--)
#define frl(i,x,y) for(int i=(x);i<(y);i++)
using namespace std;
const int N=1000003;
const int M=N<<1;
int n,q;
int cnt,head[N],Next[M],v[M];
vector<int> id[N];
int qk[N];

void read(int &x){
	char ch=getchar();x=0;
	for(;ch<'0'||ch>'9';ch=getchar());
	for(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
}

void add(int x,int y){
	Next[++cnt]=head[x];
	head[x]=cnt;
	v[cnt]=y;
}

int st[N],L;
int d[N],bc[N],ls[N],*f[N],*now=ls;
//vector<int> qry[N];
void predfs(int x,int fa,int dep){
	st[dep]=x;
	//int bc=0;
	for(auto tmp:id[x])
	 if (dep>qk[tmp])
	  id[st[dep-qk[tmp]]].push_back(tmp);
	id[x].resize(0);
	for(int i=head[x];i;i=Next[i]){
	 	predfs(v[i],x,dep+1);
	 	if (d[v[i]]>d[bc[x]]) bc[x]=v[i];
	}
	d[x]=d[bc[x]]+1;
}

int ans[N];
void dfs(int x,int fa){
	f[x][0]=1;
	if (bc[x]) f[bc[x]]=f[x]+1,dfs(bc[x],x);
	for(int i=head[x];i;i=Next[i]){
		int tmp=v[i];
		if (tmp==bc[x]) continue;
		f[tmp]=now;now+=d[tmp];
		dfs(tmp,x);
		fr(j,1,d[tmp]) f[x][j]+=f[tmp][j-1];
	}
	for(auto tmp:id[x])
	 ans[tmp]=f[x][qk[tmp]]-1;
}

int main(){
	read(n);read(q);
	int x;
	fr(i,2,n){
		read(x);
		add(x,i);
	}
	fr(i,1,q){
		read(x);read(qk[i]);
		id[x].push_back(i);
	}
	predfs(1,0,1);
	f[1]=now;now+=d[1];
	fr(i,1,n) for(auto j:id[i]) printf("%d ",j);puts("---");
	dfs(1,0);
	fr(i,1,q) printf("%d ",qk[i]==0?0:ans[i]);
	return 0;
}
```

### dfs+差分

这是标算，，想不到……

前面那个树状数组未免太大材小用了，因为我们只是求区间里等于一个数的个数，并不真的需要树状数组所维护的前缀和。

我们dfs的时候记录一个 $cnt_i$ 表示dfs过点的里面深度为 $i$ 的有多少个，然后求一个子树里深度为 $d$ 的个数只要把dfs这个子树前后的 $cnt_d$ 减一减就好了。

最后，例行宣传[博客](https://www.cnblogs.com/ymzqwq/p/11809162.html)

---

## 作者：mrsrz (赞：5)

用倍增跳上去，然后相当于问一个区间内等于某个数的节点有多少个。

离线树状数组即可。

~~听说你卡倍增~~

**Update(2020.10.13):**

听说加了组 hack 数据，那再去掉两个数组好了。

## Code：
```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
const int N=1e6+1;
inline int readint(){
	int c=getchar(),d=0;
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())d=d*10+(c^'0');
	return d;
}
int head[N],cnt,nxt[N],n,m,dep[N],F[20][N],siz[N],dfn[N],idx;
int B[N];
inline void add(int i){for(;i<=n;i+=i&-i)++B[i];}
inline void del(int i){for(;i<=n;i+=i&-i)--B[i];}
inline int ask(int i){int x=0;for(;i;i&=i-1)x+=B[i];return x;}
void dfs(int now){
	dfn[now]=++idx;
	siz[now]=1;
	for(int i=head[now];i;i=nxt[i])dep[i]=dep[now]+1,dfs(i),siz[now]+=siz[i];
}
inline int jump(int u,int k){
	for(int i=0;i<20;++i)if(k>>i&1)u=F[i][u];
	return u;
}
struct que{
	int l,r,id,nxt;
}K[N];
int hd[N],tt;
int main(){
	n=readint(),m=readint();
	for(int i=2;i<=n;++i)
	nxt[i]=head[F[0][i]=readint()],head[F[0][i]]=i;
	dfs(dep[1]=1);
	for(int i=1;i<20;++i)
	for(int j=1;j<=n;++j)
	F[i][j]=F[i-1][F[i-1][j]];
	for(int i=1;i<=n;++i)head[i]=0;cnt=0;
	for(int i=1;i<=n;++i)
	nxt[i]=head[dep[i]],head[dep[i]]=i;
	for(int i=1;i<=m;++i){
		int u=readint(),k=readint();
		if(dep[u]>k){
			u=jump(u,k),k=dep[u]+k;
			int l=dfn[u],r=dfn[u]+siz[u]-1;
			K[++tt]=(que){l,r,i,hd[k]},hd[k]=tt;
		}
	}
	memset(dep,0,sizeof dep);
	for(int i=1;i<=n;++i){
		for(int j=head[i];j;j=nxt[j])add(dfn[j]);
		for(int j=hd[i];j;j=K[j].nxt)
		dep[K[j].id]=ask(K[j].r)-ask(K[j].l-1)-1;
		for(int j=head[i];j;j=nxt[j])del(dfn[j]);
	}
	for(int i=1;i<=m;++i)
	printf("%d ",dep[i]);
	return 0;
}

```

---

## 作者：ccviolett (赞：3)

听机房大佬 @CYJian 说这道题目卡 倍增+dsu on tree，想来试试。

果然被卡了，但是去掉倍增之后，dsu on tree 不需要卡常，就压线过了。感谢良心数据人。

208E: Blood Cousins 的卡常版。

将每个询问挂到其 k 级祖先上，dsu on tree 求出每个点子树内深度信息统计答案即可。不能直接倍增挂询问，需要用到离线快速计算 k-fater 的技巧。

```cpp
/* Header {{{ */
#include <bits/stdc++.h>
using namespace std;

typedef long long readtype;
typedef long long var;
typedef long double let;

readtype read() {
  readtype a = 0, c = getchar(), s = 0;
  while (!isdigit(c)) s |= c == '-', c = getchar();
  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();
  return s ? -a : a;
}
/* }}} */

const int N = 1e6 + 1;

struct Query {
  int id, val;
};

int n, q;
int top, fi[N], ne[N], to[N];
int fa[N], size[N], deep[N], maxson[N];
vector<Query> tquery[N], query[N];
int cnt, sta[N];
int have[N], res[N];

void Add(int u, int v);
void GetInfo(int t);
void GetRes(int t);
void GetTree(int rt, int t, int v);

int main() {
#ifndef ONLINE_JUDGE
  freopen("P5384.in", "r", stdin);
  freopen("P5384.out", "w", stdout);
#endif
  n = read(), q = read();
  for (int i = 2; i <= n; ++i) Add(read(), i);
  for (int i = 1; i <= q; ++i) {
    int u = read(), k = read();
    tquery[u].push_back((Query) {i, k});
  }
  GetInfo(1), GetRes(1);
  for (int i = 1; i <= q; ++i) printf("%d ", res[i]);
  puts("");
  return 0;
}

void Add(int u, int v) {
  ne[++top] = fi[u], fi[u] = top, to[top] = v;
}

void GetInfo(int t) {
  sta[++cnt] = t;
  size[t] = 1, deep[t] = deep[fa[t]] + 1;
  for (int i = fi[t]; i; i = ne[i]) {
    fa[to[i]] = t;
    GetInfo(to[i]);
    size[t] += size[to[i]];
    if (size[to[i]] > size[maxson[t]])
      maxson[t] = to[i];
  }
  
  for (size_t i = 0; i < tquery[t].size(); ++i) {
    Query tq = tquery[t].at(i);
    if (tq.val >= deep[t]) continue;
    query[sta[cnt - tq.val]].push_back((Query) {tq.id, deep[t]} );
  }

  cnt--;
}

void GetRes(int t) {
  for (int i = fi[t]; i; i = ne[i]) {
    if (to[i] == maxson[t]) continue;
    GetRes(to[i]);
    GetTree(t, to[i], -1);
  }

  if (maxson[t]) GetRes(maxson[t]);

  GetTree(t, t, 1);
  
  for (size_t i = 0; i < query[t].size(); ++i) {
    Query tq = query[t].at(i);
    res[tq.id] = have[tq.val] - 1;
  }
}

void GetTree(int rt, int t, int v) {
  have[deep[t]] += v;
  for (int i = fi[t]; i; i = ne[i]) {
    if (to[i] == maxson[rt]) continue;
    GetTree(rt, to[i], v);
  }
}
```

!! 一、长链剖分

待续

---

## 作者：fr200110217102 (赞：3)

## 吐槽

~~关于倍增，它终于死了。~~

这好像是我做的第一道放过树剖卡掉倍增的题……

## 50pts做法

原题等价于询问$x$的$k$级祖先的子树中$dep=dep[x]$的节点个数。

一看到$k$级祖先显然会想到用倍增求。

再用线段树合并维护每个节点的子树中$dep=i$的节点个数。

时间复杂度$O(nlogn)$，空间复杂度也是$O(nlogn)$还多好几倍常数。显然会$TLE+MLE$。。。

## 70pts做法？

先求出$DFS$序，则询问相当于询问$DFS$序从$dfn[x]$到$dfn[x]+sz[x]-1$中的$dep=x$的节点个数。

离线所有询问，把每个询问拆成两个事件：减去小于$dfn[x]$的答案和加上$dfn[x]+sz[x]-1$的答案。

按$dfn$序枚举，维护当前$dep=i$的节点个数$sum$。枚举到$i$的时候把$dfn$序为$i$的节点统计到$sum$中。同时处理所有$i$处的事件。

由于需要倍增，时间和空间复杂度都是$O(nlogn)$。本来算起来这个复杂度是足够的。但是由于我们还需要很多$10^6$的数组，所以空间还是炸了（手算大约需要$140$到$150MB$）。而且$10^6$的树用倍增……时间也不太行。

随机树的点或许能过？

## 100pts做法

现在复杂度的瓶颈就在于倍增了。考虑把倍增的这个空间上的$log$给优化掉。

$k$级祖先，不用倍增，我只能想到树剖了。。。

沿着$x$到根的重链不断向上跳。

当重链长度$>k$时，说明所求的$k$级祖先就在这条重链上，直接返回$dfn$序为$dfn[x]-k$的点即可。

否则跳过这条重链，注意同时要更新$k$。

时间复杂度$O(nlogn)$，空间复杂度$O(n)$。必须开$O2$才能过。。。

## 细节

$x$的$k$级祖先可能不存在，此时输出$0$。

## 代码

由于别的都是板子，就不粘了。

只粘主程序，~~抄代码的自己看着办~~

```cpp
int main(){
	n=read(),m=read();
	for(int i=2;i<=n;++i)fa[i]=read(),adde(fa[i],i);
	dep[1]=1,dfs1(1),dfs2(1,1);
	for(int i=1;i<=m;++i){
		x=read(),k=read(),f=up(x,k);
		if(f){
			q[++tot].pos=dfn[f]      -1,q[tot].val=dep[x],q[tot].id=i,q[tot].op=-1;
			q[++tot].pos=dfn[f]+sz[f]-1,q[tot].val=dep[x],q[tot].id=i,q[tot].op=1;
		}else ans[i]=1;
	}
	sort(q+1,q+tot+1);
	for(int i=0,j=1;i<=n&&j<=tot;++i){
		++sum[dep[num[i]]];
		while(j<=tot&&q[j].pos==i)ans[q[j].id]+=q[j].op*sum[q[j].val],++j;
	}
	for(int i=1;i<=m;++i)space(ans[i]-1);
}

```

$UPD$：

倍增把$fa$数组开成$N*15$可过？？？

数据不够强啊。。。如果造一个链的或者$\frac n2$的链挂一些点的数据倍增应该就彻底凉凉了？

---

## 作者：1saunoya (赞：2)

~~很成功的用 dsu on tree 被卡空间被卡时间的卡过去了…然而为什么我不是最劣解啊~~

~~我成功尝试了把两个vector都换成链表，原因是懒得写长链剖分~~

听说你卡倍增+dsu on tree


```cpp
// powered by c++11
// by Isaunoya
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize( \
	"inline,-fgcse,-fgcse-lm,-fipa-sra,-ftree-pre,-ftree-vrp,-fpeephole2,-ffast-math,-fsched-spec,unroll-loops,-falign-jumps,-falign-loops,-falign-labels,-fdevirtualize,-fcaller-saves,-fcrossjumping,-fthread-jumps,-funroll-loops,-freorder-blocks,-fschedule-insns,inline-functions,-ftree-tail-merge,-fschedule-insns2,-fstrict-aliasing,-fstrict-overflow,-falign-functions,-fcse-follow-jumps,-fsched-interblock,-fpartial-inlining,no-stack-protector,-freorder-functions,-findirect-inlining,-fhoist-adjacent-loads,-frerun-cse-after-loop,inline-small-functions,-finline-small-functions,-ftree-switch-conversion,-foptimize-sibling-calls,-fexpensive-optimizations,inline-functions-called-once,-fdelete-null-pointer-checks")

#include <bits/stdc++.h>
#define rep(i, x, y) for (register int i = (x); i <= (y); ++i)
#define Rep(i, x, y) for (register int i = (x); i >= (y); --i)
using namespace std;
using db = double;
using ll = long long;
using uint = unsigned int;
#define Tp template
using pii = pair<int, int>;
#define fir first
#define sec second
Tp<class T> void cmax(T& x, const T& y) {if (x < y) x = y;} Tp<class T> void cmin(T& x, const T& y) {if (x > y) x = y;}
#define all(v) v.begin(), v.end()
#define sz(v) ((int)v.size())
#define pb emplace_back
Tp<class T> void sort(vector<T>& v) { sort(all(v)); } Tp<class T> void reverse(vector<T>& v) { reverse(all(v)); }
Tp<class T> void unique(vector<T>& v) { sort(all(v)), v.erase(unique(all(v)), v.end()); }
const int SZ = 1 << 20 | 233;
struct FILEIN { char qwq[SZ], *S = qwq, *T = qwq, ch;
#ifdef __WIN64
#define GETC getchar
#else
  char GETC() { return (S == T) && (T = (S = qwq) + fread(qwq, 1, SZ, stdin), S == T) ? EOF : *S++; }
#endif
  FILEIN& operator>>(char& c) {while (isspace(c = GETC()));return *this;}
  FILEIN& operator>>(string& s) {while (isspace(ch = GETC())); s = ch;while (!isspace(ch = GETC())) s += ch;return *this;}
  Tp<class T> void read(T& x) { bool sign = 0;while ((ch = GETC()) < 48) sign ^= (ch == 45); x = (ch ^ 48);
    while ((ch = GETC()) > 47) x = (x << 1) + (x << 3) + (ch ^ 48); x = sign ? -x : x;
  }FILEIN& operator>>(int& x) { return read(x), *this; } FILEIN& operator>>(ll& x) { return read(x), *this; }
} in;
struct FILEOUT {const static int LIMIT = 1 << 19 ;char quq[SZ], ST[233];int sz, O;
  ~FILEOUT() { flush() ; }void flush() {fwrite(quq, 1, O, stdout); fflush(stdout);O = 0;}
  FILEOUT& operator<<(char c) {return quq[O++] = c, *this;}
  FILEOUT& operator<<(string str) {if (O > LIMIT) flush();for (char c : str) quq[O++] = c;return *this;}
  Tp<class T> void write(T x) {if (O > LIMIT) flush();if (x < 0) {quq[O++] = 45;x = -x;}
		do {ST[++sz] = x % 10 ^ 48;x /= 10;} while (x);while (sz) quq[O++] = ST[sz--];
  }FILEOUT& operator<<(int x) { return write(x), *this; } FILEOUT& operator<<(ll x) { return write(x), *this; }
} out;
int n , _ ;
const int maxn = 1e6 + 1 ;
int dep[maxn] ;
int f[maxn][20] ;
struct edge {
	int v , nxt ;
};

edge e[maxn] ;
int cnt = 0 , head[maxn] ;
void add(int u , int v) {
	e[++ cnt] = { v , head[u] } , head[u] = cnt ;
}
int sz[maxn] , son[maxn] ;
void dfs(int u) {
	sz[u] = 1 ;
	for(int i = 1 ; f[u][i - 1] ; i ++)
		f[u][i] = f[f[u][i - 1]][i - 1] ;
	for(int i = head[u] , v ; i ; i = e[i].nxt) {
		dep[(v = e[i].v)] = dep[u] + 1 ;
		dfs(v) ;
		sz[u] += sz[v] ;
		if(sz[v] > sz[son[u]])
			son[u] = v ;
	}
}

bool vis[maxn] ;
int Cnt[maxn] ;

void calc(int u , int c) {
	Cnt[dep[u]] += c ;
	for(int i = head[u] , v ; i ; i = e[i].nxt)
		if(! vis[v = e[i].v])
			calc(v , c) ;
}

int ans[maxn] ;

struct List {
	int v , id , nxt ;
} qr[maxn] ;

int qc = 0, hd[maxn];
void makelist(int u , int v , int id) {
	qr[++ qc] = { v , id , hd[u] }, hd[u] = qc;
}

void dfs(int u , int kep) {
	for(int i = head[u] , v ; i ; i = e[i].nxt)
		if((v = e[i].v) ^ son[u]) dfs(v , 0) ;
	if(son[u]) dfs(son[u] , 1) , vis[son[u]] = 1 ;
	calc(u , 1) , vis[son[u]] = 0 ;
	for(int i = hd[u] ; i ; i = qr[i].nxt)
		ans[qr[i].id] = Cnt[qr[i].v] - 1 ;
	if(! kep) calc(u , -1) ;
}

int kth(int x , int k) {
	for(int i = 0 ; k ; i ++)
		if(k & (1 << i)) {
			x = f[x][i] ;
			k ^= (1 << i) ;
		}
	return x ;
}

signed main() {
  // code begin.
	in >> n >> _ ;
	rep(i , 2 , n) in >> f[i][0] , add(f[i][0] , i);
	dfs(1) ; rep(i , 1 , _) {
		int u , k ;
		in >> u >> k ;
		if(dep[u] < k) continue ;
		int v = kth(u , k) ;
		makelist(v , dep[u] , i) ;
	}
	dfs(1 , 0);
	rep(i , 1 , _)
		out << ans[i] << ' ' ;
	return 0;
  // code end.
}
```

---

## 作者：zhengrunzhe (赞：2)

提供一个在线算法~~虽然是个O(m log n)卡常~~

先倍增跳到k-father，然后统计其子树内有多少个点的dep=dep[u]

当然如果不存在k-father直接输出0

树上dfs序，把子树问题转化为区间问题

这是一个经典问题：[l,r]中有多少个数=x

显然我们可以对所有深度开个vector，递增地pushback其dfn

然后询问的时候二分查找[dfn[kfa],end[kfa]]

空间复杂度O(n log n) (倍增数组)

时间复杂度O(max(n,m)log n)

当然，一百万的log是20，~~但是开*20会mle~~

~~由于树不可能这么高，开15就过了~~

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using std::sort;
using std::vector;
using std::lower_bound;
template<class type>inline const void read(type &in)
{
	in=0;char ch=getchar();bool fh=0;
	while (ch<48||ch>57)fh=ch=='-'?1:fh,ch=getchar();
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
	if (fh)in=-in;
}
const int N=1e6+5,LOG=15;
int n,q;
int to[N],next[N],cnt,head[N];
inline const void addedge(int u,int v)
{
	next[++cnt]=head[u];to[head[u]=cnt]=v;
}
vector<int>v[N];
inline const int query(int p,int l,int r)
{
	vector<int>::iterator head=lower_bound(v[p].begin(),v[p].end(),l),tail=lower_bound(v[p].begin(),v[p].end(),r+1);
	return tail-head;
}
int fa[N][LOG],dep[N],dfn[N],dot[N],end[N],dfc;
inline const void dfs(int p)
{
	dot[dfn[p]=++dfc]=p;
	for (int i=head[p];i;i=next[i])dep[to[i]]=dep[p]+1,dfs(to[i]);
	end[p]=dfc;
}
inline const void getfa()
{
	for (int j=1;j<LOG;j++)
		for (int i=1;i<=n;i++)
			fa[i][j]=fa[fa[i][j-1]][j-1];
}
inline const int jump(int x,int y)
{
	for (int i=0;i<LOG;i++)
		if (y>>i&1)
			x=fa[x][i];
	return x;
}
inline const int query(int x,int y)
{
	if (dep[x]-1<y)return 0;
	int fa=jump(x,y);
	return query(dep[x],dfn[fa],end[fa])-1;
}
int main()
{
	read(n);read(q);
	for (int i=2;i<=n;i++)read(fa[i][0]),addedge(fa[i][0],i);
	dfs(dep[1]=1);getfa();
	for (int i=1;i<=n;i++)v[dep[dot[i]]].push_back(i);
	for (int x,y;q--;)read(x),read(y),printf("%d ",query(x,y));
	return 0;
}
```

---

## 作者：Owen_codeisking (赞：2)

这题正解就不是 $O(n\log n)$ 的啊。。。

不过确实 $BIT$ 常数小，卡不掉。

首先，这是一个二合一的题目，我们要解决两个树上经典问题：

1. 求出某个结点的 $k$ 级祖先

2. 求出某个结点的 $k$ 级子孙

**不强制在线。**

### 第一个问题：

在 $dfs$ 的过程中开个栈记录一下祖先结点，询问就离线在栈中查就可以了。

### 第二个问题：

长链剖分入门问题。

具体就学看一看长剖的博客吧，我还不会证它的时间复杂度。

时间复杂度 $O(n)$

~~其实没快多少~~

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1000000+10;
int n,m,fa[maxn],len[maxn],son[maxn],u[maxn],k[maxn],anc[maxn],ans[maxn],tmp[maxn<<1],*f[maxn],*id=tmp,sta[maxn],top;
int head[maxn],tot,fir[maxn],cnt;

struct node
{
	int to,next,id;
}e[maxn],q[maxn];

inline int read()
{
	register int x=0,f=1;char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
	return (f==1)?x:-x;
}
void print(int x)
{
	if(x<0) putchar('-'),x=-x;
	if(x>9) print(x/10);
	putchar(x%10+'0');
}
inline void addedge(int x,int y)
{
	e[++tot].to=y;
	e[tot].next=head[x];
	head[x]=tot;
}
inline void addque(int x,int y,int z)
{
	q[++cnt].to=y;
	q[cnt].id=z;
	q[cnt].next=fir[x];
	fir[x]=cnt;
}
void dfs1(int x)
{
	sta[++top]=x;
	vector<pair<int,int> >::iterator it;
	for(int i=fir[x];i;i=q[i].next)
		if(top>q[i].to) anc[q[i].id]=sta[top-q[i].to];
	for(int i=head[x];i;i=e[i].next) dfs1(e[i].to);
	top--;
}
void dfs2(int x)
{
	for(int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;dfs2(y);
		if(len[y]>len[son[x]]) son[x]=y;
	}
	len[x]=len[son[x]]+1;
}
void dfs3(int x)
{
	for(int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if(y==son[x]) continue;
		f[y]=id;id+=len[y];dfs3(y);
	}
	if(son[x]) f[son[x]]=f[x]+1,dfs3(son[x]);
	f[x][0]=1;
	for(int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if(y==son[x]) continue;
		for(int j=1;j<=len[y];j++) f[x][j]+=f[y][j-1];
	}
	for(int i=fir[x];i;i=q[i].next) ans[q[i].id]=f[x][q[i].to]-1;
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=2;i<=n;i++) fa[i]=read(),addedge(fa[i],i);
	for(int i=1;i<=m;i++) u[i]=read(),k[i]=read(),addque(u[i],k[i],i);
	dfs1(1);
	memset(fir,0,sizeof(fir));cnt=0;
	for(int i=1;i<=m;i++)
		if(anc[i]) addque(anc[i],k[i],i);
	dfs2(1);f[1]=id;id+=len[1]+1;dfs3(1);
	for(int i=1;i<=m;i++) print(ans[i]),putchar(' '); putchar('\n');
	return 0;
}
```

---

## 作者：Aleph1022 (赞：1)

目前空间最优（逃  
其实我这个应该改一改就能改成 $O(n)$ 的了……只是我太懒……

首先有一个简单的思路是按照深度开 vector，每个 vector 内按 DFS 序存，然后每次二分找答案。  
但是众所周知 vector 的内存会爆炸。  
于是先算出每个深度的点的个数，最后存在一个大数组里就行了。

然后就没了。

代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1e6;
const int Q = 1e6;
int n,q;
int to[N + 5],pre[N + 5],first[N + 5];
inline void add(int u,int v)
{
    static int tot = 0;
    to[++tot] = v,pre[tot] = first[u],first[u] = tot;
}
struct s_query
{
    int k,nxt,ans;
} qry[Q + 5];
int st[N + 5];
inline void push(int u,int k)
{
    static int tot = 0;
    qry[++tot] = (s_query){k,st[u],0},st[u] = tot;
}
int dep[N + 5],cnt[N + 5],a[N + 5],id[N + 5],rk[N + 5],sz[N + 5];
void dfs1(int p)
{
    static int tot = 0;
    rk[id[p] = ++tot] = p,sz[p] = 1;
    for(register int i = first[p];i;i = pre[i])
        dep[to[i]] = dep[p] + 1,dfs1(to[i]),sz[p] += sz[to[i]];
}
void dfs2(int p)
{
    static int s[N + 5],top = 0;
    s[++top] = p;
    for(register int i = st[p],x;i;i = qry[i].nxt)
        if(qry[i].k >= top)
            qry[i].k = 0;
        else
            x = s[top - qry[i].k],qry[i].k = upper_bound(a + cnt[dep[p] - 1] + 1,a + cnt[dep[p]] + 1,id[x] + sz[x] - 1) - lower_bound(a + cnt[dep[p] - 1] + 1,a + cnt[dep[p]] + 1,id[x]) - 1;
    for(register int i = first[p];i;i = pre[i])
        dfs2(to[i]);
    --top;
}
int main()
{
    scanf("%d%d",&n,&q);
    int u;
    for(register int i = 2;i <= n;++i)
        scanf("%d",&u),add(u,i);
    dfs1(1);
    for(register int i = 1;i <= n;++i)
        ++cnt[dep[i]];
    for(register int i = 1;i <= n;++i)
        cnt[i] += cnt[i - 1];
    for(register int i = 1;i <= n;++i)
        a[++cnt[dep[rk[i]] - 1]] = i;
    for(register int i = 1;i <= n;++i)
        --cnt[dep[i] - 1];
    int k;
    for(register int i = 1;i <= q;++i)
        scanf("%d%d",&u,&k),push(u,k);
    dfs2(1);
    for(register int i = 1;i <= q;++i)
        printf("%d%c",qry[i].k," \n"[i == q]);
}
```

---

## 作者：cyhzz (赞：0)

对于一个询问，我们首先要找出他的K-father，这个可以倍增实现。这样我们就把一个询问转化成询问一个点的K-son个数-1，将询问离线排序后可以在DFS序上查询。

时空复杂度O(nlogn) 但是1e6，卡得很紧（其实树高并不高，我倍增只开了14n的数组就过了
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int MAXN=1000001;
int n,q,b[MAXN],ans[MAXN],ux[MAXN],kx[MAXN];
int tot,front[MAXN],to[MAXN],nxt[MAXN];
inline void init(int u,int v)
{
	to[++tot]=v;
	nxt[tot]=front[u];
	front[u]=tot;
}
int dep[MAXN],fa[MAXN][15],siz[MAXN],dfn[MAXN],dfn_clock,dq[MAXN];
void dfs(int u)
{
	for(int i=1;i<=14;i++)
		fa[u][i]=fa[fa[u][i-1]][i-1];
	dep[u]=dep[fa[u][0]]+1;
	siz[u]=1;
	dfn[u]=++dfn_clock;
	dq[dfn_clock]=dep[u];
	for(int i=front[u];i;i=nxt[i])
	{
		int v=to[i];
		dfs(v);
		siz[u]+=siz[v];
	}
}
int cnt;
struct question{
	int x,id;
}que[MAXN*2];
inline int getkfa(int x,int k)
{
	for(int i=14;i>=0;i--)
		if((k>>i)&1)
			x=fa[x][i];
	return x;
}
bool cmp(question x,question y)
{
	return x.x<y.x;
}
int main()
{
	freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);
	scanf("%d%d",&n,&q);
	for(int i=2;i<=n;i++)
	{
		scanf("%d",&fa[i][0]);
		init(fa[i][0],i);
	}
	dfs(1);
	for(int i=1;i<=q;i++)
	{
		scanf("%d%d",&ux[i],&kx[i]);
		ux[i]=getkfa(ux[i],kx[i]);
		que[++cnt]=(question){dfn[ux[i]]-1,-i};
		que[++cnt]=(question){dfn[ux[i]]+siz[ux[i]]-1,i};
	}
	sort(que+1,que+1+cnt,cmp);
	for(int i=1,j=0;i<=cnt;i++)
	{
		while(j<que[i].x&&j<n)b[dq[++j]]++;
		int id=abs(que[i].id),x=dep[ux[id]]+kx[id];
		if(que[i].id<0)
			ans[id]-=b[x];
		else
			ans[id]+=b[x];
	}
	for(int i=1;i<=q;i++)
		printf("%d ",max(ans[i]-1,0));
	return 0;
}
```


---


# [SCOI2014] 方伯伯的商场之旅

## 题目描述

方伯伯有一天去参加一个商场举办的游戏。商场派了一些工作人员排成一行。每个人面前有几堆石子。

说来也巧，位置在 $i$ 的人面前的第 $j$ 堆的石子的数量，刚好是 $i$ 写成 $K$ 进制后的第 $j$ 位。现在方伯伯要玩一个游戏，商场会给方伯伯两个整数 $L,R$。

方伯伯要把位置在 $[L, R]$ 中的每个人的石子都合并成一堆石子。每次操作，他可以选择一个人面前的两堆石子，将其中的一堆中的某些石子移动到另一堆，代价是移动的石子数量 $\times$ 移动的距离。

商场承诺，方伯伯只要完成任务，就给他一些椰子，代价越小，给他的椰子越多。所以方伯伯很着急，想请你告诉他最少的代价是多少。例如：$10$ 进制下的位置在 $12312$ 的人，合并石子的最少代价为：$1 \times 2 + 2 \times 1 + 3 \times 0 + 1 \times1 + 2 \times 2 = 9$即把所有的石子都合并在第三堆。


## 说明/提示

对于 $100\%$ 的数据，$1 \le L \le R \le 10^{15}, 2 \le K \le 20$。

## 样例 #1

### 输入

```
3 8 3```

### 输出

```
5```

# 题解

## 作者：Midoria7 (赞：26)

## 思路
广告：[希丰展](https://www.cnblogs.com/Midoria7/p/13536230.html)

如果你做过[这道题](https://www.luogu.com.cn/problem/P2512)的话可以想到选择石子位置的中位数一定是最优的。

~~但是本题对于并无卵用~~，因为无法同时处理很多数字，只能单个处理。（~~建议写暴力~~）

对于本题的时空限制来说显然枚举每个数是不现实的。但显然数位数不会很多，可以考虑枚举贪心，整体处理（前缀和的形式）。首先把第一个位置当作集合点，算出一个贡献。然后向右枚举，更新贡献。

~~可以看出~~这是一个单峰函数，当集合点右移的时候，如果新的答案更小，就更新答案，否则就不变。

举个栗子：把二号点转移到三号点，变动的就是：小于等于二号点的石子个数 $-$ 大于等于三号点的石子个数。如果这个值是负的，我们就更新。

为什么贪心是正确的？因为前面的石子数量和一直在增加，而其后的一直在减小，因此答案的减小值一定是不断减小的。

先用一遍数位 $DP$ 求出集合点在一号点的答案，然后向右枚举转移即可。当枚举到 $n$ 的时候就结束了。
## 代码
~~不会真的有人数位 DP 写递推吧，不会吧不会吧不会吧。~~
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int L,R,K;
int a[100],f[100][10000];

int dfs(int now,int sum,int p,int lim){
    if(!now)return max(sum,0LL)
    if(!lim&&~f[now][sum])return f[now][sum];
    int ans=0;
    int num=lim?a[now]:K-1;
    for(int i=0;i<=num;i++)
        ans+=dfs(now-1,sum+(p==1?i*(now-1):(now<p?-i:i)),p,lim&&(i==num));
    if(!lim)f[now][sum]=ans;
    return ans;
}

inline int Solve(int x){
    int n=0;
    while(x){
        a[++n]=x%K;
        x/=K;
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        memset(f,-1,sizeof(f));
        ans+=((i==1)?1:-1)*dfs(n,0,i,1);
    }
    return ans;
}

signed main(){
    freopen("B.in","r",stdin);
    freopen("B.out","w",stdout);
    scanf("%lld%lld%lld",&L,&R,&K);
    printf("%lld",Solve(R)-Solve(L-1));
    return 0;
}
```

---

## 作者：shadowice1984 (赞：19)

## 本题题解

先来考虑一个特殊的情况，如果只有一个数字，那么我们该如何挪动石子才能使得总代价最小

换句话说我们的目标是最小化每个石子到集合点的距离之和

小学数奥告诉我们集合到石子们位置的中位数的位置是最优的

但是，似乎并没什么卵用……，因为我们现在要同时处理很多数字

那么我们考虑另一种寻求最优解的方法，

其实寻找最优解的过程是可以贪心的

我们先假设一号点就是集合点，求出一个代价

接下来我们尝试将集合点从1号点挪动到2号点，那么代价的变动量就是（1号点的石子数目-编号大于等于2的点的石子数目）如果代价的变动量是负的，我们就将集合点挪到2号点

现在我们的集合点是2号点，我们接着考虑将集合点放到3号点会不会更加优秀，依然求出代价的变化量，这时代价的变化量是(编号小于等于2的点的石子数目-编号大于等于3的点的石子数目)，如果代价的变化量是负的我们就将集合点挪到3号点

重复这个贪心流程，直到代价的变化量是正的，我们就停止

为什么这个贪心是对的呢？

因为石子数目肯定是非负的，所以整个数组的前缀和单调不减，整个数组的后缀和单调不增,我们发现刚才贪心过程中代价的变化量其实就是前缀和-后缀和的形式,那么显然这个值一旦变成正的就再也不可能变回负数了，所以我们可以证明这个贪心就是对的

好了那么这个贪心算法有什么用呢？

答案是我们可以对于[l,r]区间里所有的数字同时跑这个贪心算法

一开始先求出所有数字都集合到1号点时的代价之和
 
_这个东西可以使用数位dp来求解，枚举每一位放什么数字，然后计算代价_

接下来我们尝试着将集合点挪动到2号点，那么此时有一些数字不会挪动的，有一些数字是会挪动的，我们此时的目标是求出所有挪动了的数字的代价的变化量之和

显然对于一个数字来讲他的答案的变化量就是(前缀和-后缀和)，问题来了现在有一堆数字，他们的变化量各不相同，怎么办呢?

观察到前缀和的范围很小，只有250左右，所以我们暴力枚举这些数字的前缀和和后缀和，对每一个变化量求出变化量就是这个值的数字有多少个，然后答案加上变化量×数字个数就行了

那么我们现在要回答的问题就是，第p位之前数位和为pre且第p位之后数位和为suf且这个数字小于x的数字有多少个

这似乎是个经典的数位dp问题

设$dp_{i,j,k,t} t \in \{ 0,1\}$表示决策到了第i位，第p位前的数位和为j,数字的数位和为k，t为0表示这个数字前i位比x的前i小，t为1表示这个数字的前i位和x的前i位一样

那么转移的话十分的simple，只需要枚举下一位填什么数字就行了

求出这个dp数组之后我们就可以回答之前的问题了

然后我们就可以求出将集合点挪动到2之后答案的变化量了

接着重复这个过程，尝试将集合点挪动至第三个点

继续刚才的数位dp，把他再做一遍，只不过这回你的问题中的p由2变成了3，然后求出挪动到3的变化量之和即可

最后当你将集合点挪动到n的时候你就做完了这道题了

当然你可能会觉得刚才的数位dp可能有点不对劲，我是不是还要加上一个这个点之前一直在挪动的限制条件？

事实上这个限制条件是没有必要的，因为我们最后统计的是所有前缀和小于后缀和的数字，既然这个位置它的变化量还是负的，就证明它之前一直在挪动，无需加上这个限制条件
____________________________________

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=60;const int M=250;typedef long long ll;
ll dp[N][M][M][2];int a[N];ll l;ll r;int n;int jz;ll f[N][2];ll sum[N][2];
inline ll solve(ll x)
{
	ll ret=0;n=0;while(x)a[++n]=x%jz,x/=jz;reverse(a+1,a+n+1);f[0][1]=1;
	for(int i=0;i<n;i++)
	{
		f[i+1][1]+=f[i][1];sum[i+1][1]+=sum[i][1]+f[i][1]*a[i+1]*i;
		for(int t=0;t<a[i+1];t++)f[i+1][0]+=f[i][1],sum[i+1][0]+=sum[i][1]+f[i][1]*t*i;
		for(int t=0;t<jz;t++)f[i+1][0]+=f[i][0],sum[i+1][0]+=sum[i][0]+f[i][0]*t*i;
	}ret=sum[n][0]+sum[n][1];
	for(int i=0;i<=n;i++)sum[i][0]=sum[i][1]=0;for(int i=1;i<=n;i++)f[i][0]=f[i][1]=0;
	for(int nl=1;nl<n;nl++)
	{
		dp[0][0][0][1]=1;
		for(int i=0;i<n;i++)
			if(i+1<=nl)
			{
				for(int j=0;j<=i*jz;j++)
				{
					if(dp[i][j][j]==0)continue;
					dp[i+1][j+a[i+1]][j+a[i+1]][1]+=dp[i][j][j][1];
					for(int t=0;t<a[i+1];t++)dp[i+1][j+t][j+t][0]+=dp[i][j][j][1];
					for(int t=0;t<jz;t++)dp[i+1][j+t][j+t][0]+=dp[i][j][j][0];
				}	
			}
			else 
			{
				for(int j=0;j<=i*jz;j++)
					for(int k=0;k<=nl*jz;k++)
					{
						if(dp[i][j][k]==0)continue;
						dp[i+1][j+a[i+1]][k][1]+=dp[i][j][k][1];
						for(int t=0;t<a[i+1];t++)dp[i+1][j+t][k][0]+=dp[i][j][k][1];
						for(int t=0;t<jz;t++)dp[i+1][j+t][k][0]+=dp[i][j][k][0];
					}	
			}
		for(int pre=0;pre<=nl*jz;pre++)
			for(int suf=pre+1;suf+pre<=n*jz;suf++)
				ret-=(suf-pre)*(dp[n][suf+pre][pre][0]+dp[n][suf+pre][pre][1]);
		for(int i=0;i<=n;i++)
			for(int j=0;j<=i*jz;j++)
				for(int k=0;k<=nl*jz;k++)dp[i][j][k][0]=dp[i][j][k][1]=0;
	}return ret;
}
int main(){scanf("%lld%lld%d",&l,&r,&jz);printf("%lld",solve(r)-solve(l-1));return 0;}
```






---

## 作者：枫林晚 (赞：13)

**博客园cnblog链接：[[SCOI2014]方伯伯的商场之旅](https://www.cnblogs.com/Miracevin/p/9526948.html)**

网上的做法基本都是贪心到1号位置，再容斥。

这里我就写一个不一样的做法。直接就可以得到答案。

（其实是我们学长gzz的想法，我实现了一下）

发现，对于一个数字P，假设钦定最终合并位置是p，

调整的时候，p向左移动一位，代价变化是p及右边所有的数位和-p左边所有数位和。

p向右移动一位，代价变化是p及左边所有数位和-p右边所有数位和。

设最优的位置的数字是x，位置是p，p左边数位和是a，右边是b

那么，一定有不等式：x+a-b>=0 ; x+b-a>=0 就是说，x不论往左往右移动，代价的变化总是增大的。

**即：-x<=a-b<=x**

所以，如果知道最终填的a-b，和x，p，就可以判断这个p位置填x是不是左边a，右边b的最优解了。



枚举p，x；

伪代码：(cnt是最高位,进制用m，填数用k)

```cpp
for(p=1~cnt)

  for(x=0~m-1)

    for(i=cnt~1)

　  for(a-b=-200~+200)

　　设f[i][a-b][0/1]表示，填完第i位，a-b的值，有没有限制情况下，所有符合情况的数移动到p位置所花费的代价。

          g[i][a-b][0/1]表示，f的方案数，即满足情况的数的个数，方便转移。

       if(i==p){

　　　　

　　　　continue;

　　}

       for(k=0;k<m;k++){

　　　　if(i<p)

　　　　else

　　}

　在i循环完之后，

　for(a-b=-200~+200)

      if(-x<=a-b<x) ret+=f[1][a-b][0/1]

　注意这里是<=和<，因为可能一个数字有两个位置都是最优的合并位置，只能算一遍。
```

## Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=70;
const int M=22;
const int fix=201;
const int up=402;
ll f[N][405][2];
ll g[N][405][2];
ll L,R;
int m;
ll ansl,ansr;
int a[N],cnt;
ll wrk(){
	ll ret=0;
	for(int p=1;p<=cnt;p++){
	   for(int x=0;x<m;x++){
	    memset(f,0,sizeof f);
		memset(g,0,sizeof g);
	    g[cnt+1][fix][1]=1;
		for(int i=cnt;i>=1;i--){
			for(int j=0;j<=up;j++){
					if(i==p){
						if(x<a[i]){
							if(g[i+1][j][0]) g[i][j][0]+=g[i+1][j][0],f[i][j][0]+=f[i+1][j][0];
							if(g[i+1][j][1]) g[i][j][0]+=g[i+1][j][1],f[i][j][0]+=f[i+1][j][1];
						}						
						else if(x==a[i]){
							g[i][j][1]+=g[i+1][j][1],f[i][j][1]+=f[i+1][j][1];
							g[i][j][0]+=g[i+1][j][0],f[i][j][0]+=f[i+1][j][0];
						}
						else{
							g[i][j][0]+=g[i+1][j][0],f[i][j][0]+=f[i+1][j][0];
						}
						continue;
					}
					
				for(int k=0;k<m;k++){
					if(i>p){//before
						if(j+k>up) continue;
						
						if(k<a[i]){
							g[i][j+k][0]+=g[i+1][j][0],f[i][j+k][0]+=f[i+1][j][0]+(i-p)*k*g[i+1][j][0];
							g[i][j+k][0]+=g[i+1][j][1],f[i][j+k][0]+=f[i+1][j][1]+(i-p)*k*g[i+1][j][1];
						}
						else if(k==a[i]){
							g[i][j+k][0]+=g[i+1][j][0],f[i][j+k][0]+=f[i+1][j][0]+(i-p)*k*g[i+1][j][0];
							g[i][j+k][1]+=g[i+1][j][1],f[i][j+k][1]+=f[i+1][j][1]+(i-p)*k*g[i+1][j][1];
						}
						else{
							g[i][j+k][0]+=g[i+1][j][0],f[i][j+k][0]+=f[i+1][j][0]+(i-p)*k*g[i+1][j][0];
						}
					}
					else{//after 
						if(j-k<0) continue;
					
					
						if(k<a[i]){
							f[i][j-k][0]+=f[i+1][j][0]+g[i+1][j][0]*(p-i)*k,g[i][j-k][0]+=g[i+1][j][0];
							f[i][j-k][0]+=f[i+1][j][1]+g[i+1][j][1]*(p-i)*k,g[i][j-k][0]+=g[i+1][j][1];
						}
						else if(k==a[i]){
							f[i][j-k][0]+=f[i+1][j][0]+g[i+1][j][0]*(p-i)*k,g[i][j-k][0]+=g[i+1][j][0];
							f[i][j-k][1]+=f[i+1][j][1]+g[i+1][j][1]*(p-i)*k,g[i][j-k][1]+=g[i+1][j][1];
						}
						else{
							f[i][j-k][0]+=f[i+1][j][0]+g[i+1][j][0]*(p-i)*k,g[i][j-k][0]+=g[i+1][j][0];
						}
					}
				}
			}
		}
			for(int j=0;j<=up;j++){
				if((fix-x<=j)&&(j<x+fix)){
					ret+=f[1][j][0]+f[1][j][1];			
				}
			}
		}
	}	
	return ret;
}
int main(){
	scanf("%lld%lld",&L,&R);
	scanf("%d",&m);
	L--;
	cnt=0;
	while(L){
		a[++cnt]=L%m;
		L/=m;
	}
	if(cnt==0){
		ansl=0;
	}
	else{
		ansl=wrk();
	}
	
	cnt=0;
	while(R){
		a[++cnt]=R%m;
		R/=m;
	}
	ansr=wrk();
	printf("%lld",ansr-ansl);
}
```


---

## 作者：Utilokasteinn (赞：12)

## [Link](https://www.luogu.com.cn/problem/P3286)

非常妙的一道题。

假设我们现在要算 $[1,x]$ 中每个人合并完石子的最小代价。

先把 $x$ 转换为 $k$ 进制，设最低位为第 $1$ 位，最高位为第 $cnt$ 位。

我们先把所有人的石子都合并到第 $1$ 位。这容易用数位 $\tt dp$ 求出。

设 $f_{pos,sum}$ 表示最高位到第 $pos+1$ 位的石子移到第 $1$ 位需要的代价为 $sum$ 时，后 $pos$ 位可以是任意个石子，其所需要的代价。

代码如下：

```cpp
ll dfs1(int pos,int sum,bool lim)
{
    if(!pos)return sum;
    if(!lim&&f[pos][sum]!=-1)return f[pos][sum];
    ll up=lim?num[pos]:base-1,ans=0;
    for(int i=0;i<=up;i++)
    	ans+=dfs1(pos-1,sum+i*(pos-1),lim&&i==up);
    if(!lim)f[pos][sum]=ans;
    return ans;
}
```

设 $ans_{i}$ 表示将所有人的石子都合并到第 $1$ 位到第 $i$ 位中**任意一位**的最小代价。

现在已经求出 $ans_1$，所有石子都被合并到了第 $1$ 位。

然后我们进行递推，最后的 $ans_{cnt}$ 就是答案。

假设我们已经求出了 $ans_1$ 到 $ans_{i-1}$，现在要求 $ans_i$。

一个性质：若一个人的石子最优合并是合并到 $j(j>i)$，那么在 $[1,i-1]$ 中，它会合并到 $i-1$。

然后就可以大力 $\tt dp$ 了。

设 $f_{pos,sum}$ 表示最高位到第 $pos+1$ 位的石子有 $sum$ 个时，将其移至 $to$ 时，相比之前减少的代价。

代码如下：

```cpp
ll dfs2(int pos,int sum,int to,bool lim)
{
    if(!pos)return max(sum,0); 
    if(!lim&&f[pos][sum]!=-1)return f[pos][sum];
    ll up=lim?num[pos]:base-1,ans=0;
    for(int i=0;i<=up;i++)
    	ans+=dfs2(pos-1,sum+(pos>=to?i:-i),to,lim&&i==up);
    if(!lim)f[pos][sum]=ans;
    return ans;
}
```

当然，你可以把两个 ```dfs``` 合并成一个。

完整的代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll l,r,f[70][1400];
int base,num[70];
ll dfs(int pos,int sum,int to,bool lim)
{
    if(!pos)return max(sum,0);
    if(!lim&&f[pos][sum]!=-1)return f[pos][sum];
    ll up=lim?num[pos]:base-1,ans=0;
    for(int i=0;i<=up;i++)
    	if(to==1)ans+=dfs(pos-1,sum+i*(pos-1),to,lim&&i==up);
    	else ans+=dfs(pos-1,sum+(pos>=to?i:-i),to,lim&&i==up);
    if(!lim)f[pos][sum]=ans;
    return ans;
}
inline ll solve(ll x)
{
    int cnt=0;
    while(x)num[++cnt]=x%base,x/=base;
    memset(f,-1,sizeof(f));
    ll ans=dfs(cnt,0,1,1);
    for(int i=2;i<=cnt;i++)
	{
        memset(f,-1,sizeof(f));
        ans-=dfs(cnt,0,i,1);
    }
    return ans;
}
int main()
{
    scanf("%lld%lld%d",&l,&r,&base);
    printf("%lld\n",solve(r)-solve(l-1));
    return 0;
}
```


---

## 作者：ql12345 (赞：8)

数位dp（记忆化搜索）

思路和代码来源于：https://blog.csdn.net/cdsszjj/article/details/79264663

思路：先令1为集合点，算出代价，再利用贪心性质将答案减小到最小
    
	1.算出代价：基础的数位dp，dfs1函数（模板）（返回值为代价之和）
	2.贪心：性质：从前到后移动集合点，代价减小值：新集合点以及后面的点代价减小的值  -  前面的点代价增大值，因为前面点的数值和不断增加，后面点不断减小，所以代价减小值不断减小。
		实现：dfs2函数：也是模板，以代价减小值来代替代价（所以dfs2就是dfs1变形起到不同作用）。（dfs2返回值是代价的减小值之和）
	代码框架就是solve函数里用1.2.两步算出最小代价（是个”前缀和“），主函数里相减得到答案，除了多个函数，都是模板

code: 

	#include<bits/stdc++.h>
	using namespace std;
	long long a,b,k,f[60][4000];
	int num[60]; 
	inline long long dfs1(int p,int sum,int op){
	//有的人把p写成pos
	//有的人把op写成limit，表示这位以前各位是否都与solve中的x相同
		if(!p)return sum;//sum表示累计代价
		if(!op&&~f[p][sum])return f[p][sum];
		//有的人把~f[p][sum]写成f[p][sum]!=-1	
    	long long ans=0,maxx=op?num[p]:k-1;
   		//k进制下最大数为k-1；有的人把maxx写成up
		for(int i=0;i<=maxx;++i)
			ans+=dfs1(p-1,sum+i*(p-1),op&(i==maxx));
    		//i*(p-1)表示“当前值”与“当前位置与集合点1之间的距离”之积	
    	if(!op)f[p][sum]=ans;	
    	return ans;	
    }	
    inline long long dfs2(int p,int sum,int m,int op){
	//除了m，与dfs1无差别，m为新集合点	
    	if(!p)return max(sum,0);
    	//如果求出的sum<0，为了不让solve中的ans变劣，不会减去负数，减去0会不变	
    	if(!op&&~f[p][sum])return f[p][sum];
    	//与dfs1一样；solve中memset过，f[]数组的值与dfs1无关	
    	long long ans=0,maxx=op?num[p]:k-1;	
    	for(int i=0;i<=maxx;++i)
			ans+=dfs2(p-1,sum+(p<m?-i:i),m,op&(i==maxx));
        		//m是从1变大的，如果比m小，代价增加，代价减小-i，反之同理	
  	    	if(!op)f[p][sum]=ans;
	    	return ans;
	}
	inline long long solve(long long x){//与模板有出入的地方有注释
		int len=0;
		while(x){
			num[++len]=x%k;
			x/=k;
		}
		long long ans=0;
		memset(f,-1,sizeof(f));
		ans=dfs1(len,0,1);//1.（从高位往低位填数的写法）
		for(int i=2;i<=len;++i){//2.（集合点依次从1移动到2~len）
			memset(f,-1,sizeof(f));
			ans-=dfs2(len,0,i,1);//减去在移动前基础上减小的代价
			//（当减小代价小于0，即移动不优时，ans不会再更新（见dfs2）。即ans不会变差）
		}
		return ans;
	}
	int main(){
		scanf("%lld%lld%lld",&a,&b,&k);
		printf("%lld",solve(b)-solve(a-1));
		return 0; 
	}

---

## 作者：zzy_zzy (赞：4)

### 前言
为什么大家都这么强，人均代码长度1k，我却写了11k，还跑得很慢。
### 思路
学过初一数学的小朋友们都知道，有句口诀叫奇中偶范。也就是说，合并后的位置是以 $k$ 进制拆开后所有数的**带权中位数**的位置。

学过数位DP的小朋友们都知道，这种给一段区间，让你计数的题有很多都是**数位DP**。

因此，我们考虑数位DP。按照惯例，先想长度小于上限的答案怎么统计。

考虑先枚举长度、所有数的总和、最终会合并到的位置 $pos$、$1\sim pos$ 位置数的和、第 $pos$ 个位置是什么数以及第 $pos+1$ 个位置是什么数，接下来，我们发现问题转化为了求长度为 $i$，总和为 $j$ 的方案数（记录方案数的原因是要将两段区间的代价合并）以及代价和。考虑数位DP，设 $dp_{i,j}$ 为考虑到第 $i$ 个位置、且当前和为 $j$ 的代价和，$g_{i,j}$ 为方案数，有转移：

$$dp_{i,j}=\sum (dp_{i-1,j-k}+k(n+1-i)\times g_{i-1,j-k})$$

$$g_{i,j}=\sum g_{i-1,j-k}$$

这样你就做完了长度小于上限的情况。考虑长度等于上限怎么做。其实这就是把状态多加了“有无顶到上界”这一维，转移时特殊判断一下即可。注意合并区间时也要判断两边有无顶到上界。

细节还是很多的，代码也很丑。
### AC code:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int wei[55],dp[55][55][230][2],g[55][230],ge1[55][55][230][2],ge2[55][230];
int ggg[55][55][230][2],ge3[55][55][230][2];//ge代表题解中的g
int get(int x,int k){
    memset(dp,0,sizeof(dp));
    memset(g,0,sizeof(g));
    memset(ge1,0,sizeof(ge1));
    memset(ge2,0,sizeof(ge2));
    int tot=0;
    int now=x;
    while(now){
        wei[++tot]=now%k;
        now/=k;
    }
    reverse(wei+1,wei+tot+1);
    ge1[0][0][0][0]=1;
    for(int i=1;i<tot;i++){
        for(int j=1;j<k;j++)dp[i][1][j][0]=i*j,ge1[i][1][j][0]=1;
        for(int j=2;j<=i;j++){
            for(int a=0;a<=228;a++){
                for(int b=0;b<=a;b++){
                    int now=a-b;
                    if(now>=k)continue;
                    if(!ge1[i][j-1][b][0])continue;
                    dp[i][j][a][0]+=dp[i][j-1][b][0]+now*(i+1-j)*ge1[i][j-1][b][0];
                    ge1[i][j][a][0]+=ge1[i][j-1][b][0];
                }
            }
        }
    }
    ge2[0][0]=1;
    for(int i=0;i<k;i++)g[1][i]=i*2,ge2[1][i]=1;
    for(int i=2;i<=tot;i++){
        for(int j=0;j<=228;j++){
            for(int a=0;a<=j;a++){
                int now=j-a;
                if(now>=k)continue;
                if(!ge2[i-1][a])continue;
                g[i][j]+=g[i-1][a]+now*(i+1)*ge2[i-1][a];
                ge2[i][j]+=ge2[i-1][a];
            }
        }
    }
    int sum=0;
    for(int i=1;i<tot;i++){
        for(int j=0;j<=i*k;j++){
            int lim=j/2;
            if(j%2)lim++;
            for(int a=1;a<=i;a++){
                for(int b=lim;b<=j;b++){
                    for(int c=0;c<=min(k-1,b);c++){
                        if(b-c>=lim)continue;
                        for(int d=0;d<k;d++){
                            if(a==i&&d)continue;
                            if(b+d>j)continue;
                            int JJ=i-a-1;
                            if(JJ==-1)JJ=0;
                            int num=dp[a-1][a-1][b-c][0]*ge2[JJ][j-b-d]+ge1[a-1][a-1][b-c][0]*g[JJ][j-b-d]+ge1[a-1][a-1][b-c][0]*ge2[JJ][j-b-d]*d;
                            sum+=num;
                        }
                    }
                }
            }
        }
    }
    //上面这个部分是考虑长度小于上限的情况
    memset(dp,0,sizeof(dp));
    memset(ge1,0,sizeof(ge1));
    memset(ggg,0,sizeof(ggg));
    ge1[tot][0][0][0]=1;
    for(int i=1;i<wei[1];i++){
        dp[tot][1][i][0]=i*tot;
        ge1[tot][1][i][0]=1;
    }
    dp[tot][1][wei[1]][1]=wei[1]*tot;
    ge1[tot][1][wei[1]][1]=1;
    for(int i=2;i<=tot;i++){
        for(int j=0;j<=228;j++){
            for(int a=0;a<=j;a++){
                if(j-a>=k)continue;
                int now=j-a;
                if(now>wei[i]){
                    if(ge1[tot][i-1][a][0]){
                        dp[tot][i][j][0]+=dp[tot][i-1][a][0]+ge1[tot][i-1][a][0]*(tot+1-i)*now;
                        ge1[tot][i][j][0]+=ge1[tot][i-1][a][0];
                    }
                }
                else if(now==wei[i]){
                    if(ge1[tot][i-1][a][0]){
                        dp[tot][i][j][0]+=dp[tot][i-1][a][0]+ge1[tot][i-1][a][0]*(tot+1-i)*now;
                        ge1[tot][i][j][0]+=ge1[tot][i-1][a][0];
                    }
                    if(ge1[tot][i-1][a][1]){
                        dp[tot][i][j][1]+=dp[tot][i-1][a][1]+ge1[tot][i-1][a][1]*(tot+1-i)*now;
                        ge1[tot][i][j][1]+=ge1[tot][i-1][a][1];
                    }
                }
                else{
                    if(ge1[tot][i-1][a][0]){
                        dp[tot][i][j][0]+=dp[tot][i-1][a][0]+ge1[tot][i-1][a][0]*(tot+1-i)*now;
                        ge1[tot][i][j][0]+=ge1[tot][i-1][a][0];
                    }
                    if(ge1[tot][i-1][a][1]){
                        dp[tot][i][j][0]+=dp[tot][i-1][a][1]+ge1[tot][i-1][a][1]*(tot+1-i)*now;
                        ge1[tot][i][j][0]+=ge1[tot][i-1][a][1];
                    }
                }
            }
        }
    }
    for(int i=0;i<=tot*k;i++){
        int lim=i/2;
        if(i%2)lim++;
        for(int j=1;j<=tot;j++){
            for(int a=lim;a<=i;a++){
                for(int b=0;b<=min(k-1,a);b++){
                    if(a-b>=lim)continue;
                    for(int c=0;c<k;c++){
                        if(j==1&&(b>wei[1]||(b==wei[1]&&c>=wei[2])))continue;
                        if(j==tot&&c)continue;
                        if(a+c>i)continue;
                        if(b>wei[j]||(b==wei[j]&&c>=wei[j+1])){
                            int JJ=tot-j-1;
                            if(JJ==-1)JJ=0;
                            int NN=ge1[tot][j-1][a-b][0]*(tot+1-j)*(a-b);
                            if(j==1)NN=0;
                            int num=(dp[tot][j-1][a-b][0]-NN)*ge2[JJ][i-a-c]+ge1[tot][j-1][a-b][0]*g[JJ][i-a-c]+ge1[tot][j-1][a-b][0]*ge2[JJ][i-a-c]*c;
                            sum+=num;
                        }
                        else{
                            int JJ=tot-j-1;
                            if(JJ==-1)JJ=0;
                            int NN=(ge1[tot][j-1][a-b][0]+ge1[tot][j-1][a-b][1])*(tot+1-j)*(a-b);
                            if(j==1)NN=0;
                            int num=(dp[tot][j-1][a-b][0]+dp[tot][j-1][a-b][1]-NN)*ge2[JJ][i-a-c]+(ge1[tot][j-1][a-b][0]+ge1[tot][j-1][a-b][1])*g[JJ][i-a-c]+(ge1[tot][j-1][a-b][0]+ge1[tot][j-1][a-b][1])*ge2[JJ][i-a-c]*c;
                            sum+=num;
                        }
                    }
                }
            }
        }
    }
    memset(ge3,0,sizeof(ge3));
    ge3[tot+1][0][0][0]=1;
    for(int i=1;i<=tot;i++){
        for(int j=0;j<wei[i];j++){
            ggg[i][1][j][0]=2*j;
            ge3[i][1][j][0]=1;
        }
        ggg[i][1][wei[i]][1]=2*wei[i];
        ge3[i][1][wei[i]][1]=1;
        for(int j=2;j<=tot-i+1;j++){
            for(int a=0;a<=228;a++){
                for(int b=0;b<=a;b++){
                    int now=a-b;
                    if(now>=k)continue;
                    if(now>wei[i+j-1]){
                        if(ge3[i][j-1][b][0]){
                            ggg[i][j][a][0]+=ggg[i][j-1][b][0]+now*(j+1)*ge3[i][j-1][b][0];
                            ge3[i][j][a][0]+=ge3[i][j-1][b][0];
                        }
                    }
                    else if(now==wei[i+j-1]){
                        if(ge3[i][j-1][b][0]){
                            ggg[i][j][a][0]+=ggg[i][j-1][b][0]+now*(j+1)*ge3[i][j-1][b][0];
                            ge3[i][j][a][0]+=ge3[i][j-1][b][0];
                        }
                        if(ge3[i][j-1][b][1]){
                            ggg[i][j][a][1]+=ggg[i][j-1][b][1]+now*(j+1)*ge3[i][j-1][b][1];
                            ge3[i][j][a][1]+=ge3[i][j-1][b][1];
                        }
                    }
                    else{
                        if(ge3[i][j-1][b][0]){
                            ggg[i][j][a][0]+=ggg[i][j-1][b][0]+now*(j+1)*ge3[i][j-1][b][0];
                            ge3[i][j][a][0]+=ge3[i][j-1][b][0];
                        }
                        if(ge3[i][j-1][b][1]){
                            ggg[i][j][a][0]+=ggg[i][j-1][b][1]+now*(j+1)*ge3[i][j-1][b][1];
                            ge3[i][j][a][0]+=ge3[i][j-1][b][1];
                        }
                    }
                }
            }
        }
    }
    for(int i=0;i<=tot*k;i++){
        int lim=i/2;
        if(i%2)lim++;
        for(int j=1;j<=tot;j++){
            for(int a=lim;a<=i;a++){
                for(int b=0;b<=min(k-1,a);b++){
                    if(a-b>=lim)continue;
                    for(int c=0;c<k;c++){
                        if(j==1&&(b>wei[1]||(b==wei[1]&&c>wei[2])))continue;
                        if(j==tot&&c)continue;
                        if(a+c>i)continue;
                        if(b==wei[j]&&c==wei[j+1]){
                            int JJ=tot-j-1;
                            if(JJ==-1)JJ=0;
                            int SS=ge1[tot][j-1][a-b][1];
                            if(j==1&&a==b)SS=1;
                            int NN=SS*(tot+1-j)*(a-b);
                            if(j==1)NN=0;
                            int NNN=ge3[j+2][tot-j-1][i-a-c][0]+ge3[j+2][tot-j-1][i-a-c][1];
                            if(j==tot&&i==a+c)NNN=1;
                            int num=(dp[tot][j-1][a-b][1]-NN)*(NNN)+SS*(ggg[j+2][tot-j-1][i-a-c][0]+ggg[j+2][tot-j-1][i-a-c][1])+SS*(NNN)*c;
                            sum+=num;
                        }
                    }
                }
            }
        }
    }
    //上面这个部分是考虑长度等于上限的情况
    return sum;
}

signed main(){
    int l,r,k;
    cin>>l>>r>>k;
    cout<<get(r,k)-get(l-1,k);
    return 0;
}
```

---

## 作者：Vocalise (赞：3)

## 题目大意

给出一个区间 $[l,r],(l,r\le 10^{15})$，并给出一个 $k\le20$，对于其中每一个​数，把它写成 $k$​ 进制后各位数字构成的序列，将一个位置的数字加到左或右一格并清空该位的代价是它的数字大小，需要将这个序列变成只有一位非 $0$。

求区间中所有数的最小代价之和。

## 题解

考虑数位 DP。首先，对每个数字分别考虑代价是不现实的。所以我们尝试一起 DP。

对于一个数，显然是选定一个中心点，将其它位置的数移动到该位置。

不难发现， 这个位置就是带权平均数。因此有计算最优点的公式：

设 $\{a_i\}_{i=1}^n$ 为该数的各位数码，则
$$
\frac 2{n(n+1)}\sum_{i=1}^na_i\times i
$$
为最优点。

但是对于求解移动距离（代价）和，这个公式用处不大。

我们考虑另一件事情：代价和关于中心点位置是单峰的。一个中心点越偏离最优点，答案一定越不更优。

所以就有了一个调整性的算法：

我们先令所有数的中心点为 $1$，计算代价。

然后，对于所有 $1\le i< n$尝试把一些数的中心点从 $i$ 转移到 $i+1$，计算出这部分减少的代价。

显然，只有一些数从 $1$ 转移到 $2$ 是更优的，这其中又只有一些数 $2$ 转移到 $3$ 更优。为什么我们不用考虑包含的情况，只需分别转移？

因为如果一个数在 $2$ 转 $3$ 时能更优（不劣），那么根据单峰性，它从 $1$ 转 $2$ 也必定不劣。所以它转移了两次，代价也变化了两次。

接下来考虑实现：如果前 $i$​ 位的数字和不大于 $i$​ 位后的数字和，那么 $i$ 转 $i+1$ 就​更优。可以画图理解。

我们枚举每个前缀后缀和，通过数位 DP 计算出这样的数字个数，就可以相乘计算代价变化了。

具体地，令 $f_{i,j,x,y,0/1}$ 为考虑 $i$ 转 $i+1$ 时（这一维略去），考虑到 $j$ 位，前缀后缀分别是 $x,y$，是或否（$1/0$）与上界（$l,r$）相同，的数字个数。转移略。

一开始计算 $1$ 处的代价和，就可以简单地考虑 $f'_{i,0/1},g'_{0,1}$ 表示第 $i$​ 位，是否与上界相同的方案数和代价和了。转移略。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <vector>

typedef long long ll;
const int K = 21;
const int N = 52;
const int V = 250;

char buf[1 << 25] ,*p1 = buf ,*p2 = buf;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf ,1 ,1 << 21 ,stdin) ,p1 == p2) ? EOF : *p1++)
inline ll read() {
    ll x = 0, f = 1; char ch = getchar();
    while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();
    return x * f;
}

int k,b[N],t; ll f[N][2],g[N][2],dp[N][V][V][2];

void Div(ll n) {
    if(!n) return;
    b[++t] = n % k, Div(n / k);
    return;
}

ll F(ll n) {
    t = 0, Div(n);
    memset(f,0,sizeof(f)), memset(g,0,sizeof(g));
    f[t][1] = 1, g[t][1] = 0;
    f[t][0] = b[t], g[t][0] = 0;
    for(int i = t;i > 1;i--) {
        for(int p = 0;p < 2;p++) for(int v = 0;v < k;v++) {
            if(p && v > b[i - 1]) continue;
            int q = (p && v == b[i - 1]) ? 1 : 0;
            f[i - 1][q] += f[i][p];
            g[i - 1][q] += g[i][p] + 1ll * v * (t - i + 1) * f[i][p];
        }
    }
    ll ans = g[1][0] + g[1][1];
    //std::printf("ans = %lld\n",ans);
    for(int P = t;P > 1;P--) {
        memset(dp,0,sizeof(dp));
        dp[t + 1][0][0][1] = 1;
        for(int i = t + 1;i > 1;i--) {
            for(int x = 0;x <= (k - 1) * (t - i + 1);x++) 
                for(int y = 0;x + y <= (k - 1) * (t - i + 1);y++)
                    for(int p = 0;p < 2;p++) for(int v = 0;v < k;v++) {
                        if(p && v > b[i - 1]) continue;
                        int q = (p && v == b[i - 1]) ? 1 : 0;
                        int _x = x, _y = y;
                        (i - 1 >= P ? _x : _y) += v;
                        if(_x <= V && _y <= V)
                            dp[i - 1][_x][_y][q] += dp[i][x][y][p];
                    }
        }
        for(int x = 0;x <= (k - 1) * t;x++) 
            for(int y = x;x + y <= (k - 1) * t;y++)
                ans += 1ll * (x - y) * (dp[1][x][y][0] + dp[1][x][y][1]);
    }
    //std::printf("lstans = %lld\n",ans);
    return ans;
}

int main() {
    ll l = read(), r = read();
    k = read(); 
    std::printf("%lld\n",F(r) - F(l - 1));
    return 0;
}

```



---

## 作者：Flash_Man (赞：3)

先用数位 DP 统计所有数都挪到第一位的答案，$f(i,0/1)$ 表示前 $i$ 位，合并到第 $1$ 位，第 $i$ 位是否受限的代价和。

考虑如果合并点从左往右移动，代价会是一个单峰函数，所以可以一位一位的向右挪，则可以定义 $g(i,j,0/1)$ 表示前 $i$ 位，合并点从 $j-1$ 挪到 $j$ 的代价变化量，然后把 $g(n,j,?)$ 为正的从答案中减去。注意对每个 $j$ 都要跑一次数位 DP。

转移（不考虑受限位）：
$$
f(i)+x\times(i-1)\mathop\longrightarrow\limits^{x\in[0..k)} f(i+1)
$$
$$
g(i,j)+(-1)^{[i\ge j]}x\mathop\longrightarrow\limits^{x\in[0..k)} g(i+1,j)
$$
两个数位 DP 可以只写一个记忆化深搜。时间复杂度：$\Theta(K^2\log w)$，其中 $w$ 是 $L,R$ 的值域。

```cpp
#include <cstdio>
#include <cstring>
#define int long long
const int maxn = 50 + 3;
const int maxs = 1e4 + 3;
int l, r, k, a[maxn], f[maxn][maxs];
int dfs(int i, int j, int s, bool op) {
	if (s < 0) return 0;
	if (!i) return s;
	if (!op && ~f[i][s]) return f[i][s];
	int res = 0, num = op ? a[i] : k - 1;
	for (int x = 0; x <= num; x++)
		res += dfs(i - 1, j, s + (j == 1 ? x * (i - 1) : (i < j ? -x : x)), op && x == num);
	if (!op) return f[i][s] = res;
	return res;
}
int solve(int x) {
	int len = 0;
	while (x) {
		a[++len] = x % k;
		x /= k;
	} 
	memset(f, -1, sizeof(f));
	int ans = dfs(len, 1, 0, true);
	for (int i = 2; i <= len; i++) {
		memset(f, -1, sizeof(f));
		ans -= dfs(len, i, 0, true);
	}
	return ans;
}
signed main() {
	scanf("%lld%lld%lld", &l, &r, &k);
	printf("%lld\n", solve(r) - solve(l - 1));
	return 0;
}
```

---

## 作者：7KByte (赞：3)

prework不清空，爆零两行泪。。。

神仙数位DP题。

根据题面和数据范围，显然这是一道数位DP题。

但是又不能按照数位DP的常规思路来做。

最开始想到用$f[i][j][k]$表示填到第$i$位，第$i$位为$j$，是否卡上界的答案。

很快发现这个想法太$\texttt{naive}$了，因为面对大量的数时，根本不知道到底要合并到哪一堆。

但观察之后我们可以发现一些有用的性质，比如向右填一个数字后，合并点（指最终剩的一堆的位置）只可能向右移动。因为加入的数一定在原来的合并点的右边，向左移动只能使代价更大，但向右移动可能使代价更小。

借助这个性质，我们可以先把所有点合并到最左边，再逐一考虑向右移动。

$\texttt{Task1:}$求$1-N$的所有数，全部合并到最低位的答案。

$f[i][j]$表示填到第$i$位，第$i$位为$j$时的答案。DP方程如下。

$$f[i][j]=j\times(i-1)\times k^{i-1}+\sum\limits_{u=0}^{k-1}{f[i-1][u]}$$

最后按照数位DP的套路试填即可。


$\texttt{Task2:}$求$1-N$的所有数，全部合并到第$s$位，其中低于$s$位的数字之和要小于高于$s$位（这里包括第$s$位）的数字之和的数的个数。

直接求也不好求，我们直接枚举$s$，再分别枚举高于和低于$s$位的数位之和。

$f[i][l][r][op]$表示填到第$i$位，$l$表示高于或等于$s$位的数字之和，$r$表示低于$s$位的数字之和。$op$表示是否卡上界（数位DP套路）。

然后枚举当前位上的数字直接转移即可。

代码如下，写了两个``namespace``分别对应上面两个``task``，可读性应该是比较高的/cy。

```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 66
#define M 255
using namespace std;
int k,a[N],n,s[N],b[N],c[N];
namespace task1{
	int f[N][N];
	int solve(){
		memset(f,0,sizeof(f));
		b[0]=1;rep(i,1,n)b[i]=b[i-1]*k;
		rep(i,1,n)rep(j,0,k-1){
			rep(o,0,k-1)f[i][j]+=f[i-1][o];
			f[i][j]+=j*(i-1)*b[i-1]; 	
		}
		int ans=0;
		rep(i,0,a[n]-1)ans+=f[n][i];
		rep(i,1,n)ans+=a[i]*(i-1);
		pre(i,n-1,1){
			rep(j,0,a[i]-1)ans+=f[i][j];
			pre(j,n,i+1)ans+=a[j]*(j-1)*a[i]*b[i-1];
		}
		return ans;
	}
}
namespace task2{
	int f[N][M][M][2];
	void prework(int pos){
		memset(f,0,sizeof(f));
		f[n+1][0][0][1]=1;
		pre(i,n,1){
			if(i>=pos){
				rep(l,0,c[n-i]){
					rep(j,0,a[i]-1)f[i][l+j][0][0]+=f[i+1][l][0][1];
					rep(j,0,k-1)f[i][l+j][0][0]+=f[i+1][l][0][0];
					f[i][l+a[i]][0][1]+=f[i+1][l][0][1];
				}
			}
			else{
				rep(l,0,c[n-pos+1])rep(r,0,c[pos-i-1]){
					rep(j,0,a[i]-1)f[i][l][r+j][0]+=f[i+1][l][r][1];
					rep(j,0,k-1)f[i][l][r+j][0]+=f[i+1][l][r][0];
					f[i][l][r+a[i]][1]+=f[i+1][l][r][1];
				}
			}
		}
	}
	int solve(){
		int ans=0;
		rep(i,2,n){
			prework(i);
			rep(l,1,c[n-i+1])rep(r,0,l-1){
				ans+=(f[1][l][r][1]+f[1][l][r][0])*(r-l);
			}
		}
		return ans;
	} 
}
int solve(int x){
	n=0;while(x)a[++n]=x%k,x/=k;
	rep(i,1,k)s[i]=s[i-1]+i;
	rep(i,1,n)c[i]=c[i-1]+k-1;
	return task1::solve()+task2::solve();
}
signed main(){
	int l,r;scanf("%lld%lld%lld",&l,&r,&k);
	printf("%lld\n",solve(r)-solve(l-1));
	return 0;
} 
/*
114514 1919810 10
*/
```

---

## 作者：Plozia (赞：2)

宣传博客->[link](https://blog.csdn.net/BWzhuzehao/article/details/114545554)

这道题是道套路不太一般的数位 DP。

首先根据小学奥数知识我们可以得知：所有石子合并到最中间一定是最优的，然而这并没有什么用，也不知道什么在中间。

那么我们先思考一个问题：假设当前合并点为 $tag$，当我们将合并点更新为 $tag+1$ 时，记 $tag+1$ 时的答案为 $ans_{tag+1}$，第一位答案为 $ans_1$，那么：$ans_{tag+1}-ans_1$ 是否具有单调性？

答案是：是。

为什么？我们将合并点不断右移的时候，显然更多的点会到左边，此时左边的石头会越来越多，导致每移动一格影响就会越来越大，因此有单调性。

那么我们就有了一种思路：首先先计算出合并到 1 号点的答案，然后贪心右移，答案能变小就变小。

~~于是这道题就做完了~~

到目前为止还没有做完，因为代码写不出来。

这道题的特别之处在于我们要写两个 `dfs`。

1. `LL dfs1(int pos, int sum, int limit)`
    $sum$ 表示已经算完位的贡献。
2. `LL dfs2(int pos, int sum, int tag, int limit)`
    $tag$ 是新的合并点。
    而在 `dfs2` 中，我们需要计算的是新的左边贡献减去右边贡献的差值，相当于一种前缀和的思想，如果算出来是正数，那么更新答案。

到这里就做完了。

代码注意：

1. 随时清空 $f$ 数组。
2. 注意数位上界是 $k-1$！

代码：

```cpp
#include <bits/stdc++.h>
#define Max(a, b) ((a > b) ? a : b)
using namespace std;

typedef long long LL;
const int MAXN = 1e5 + 10;
LL l, r, f[70][MAXN];
int k, cnt, a[70];

LL read()
{
	LL sum = 0, fh = 1; char ch = getchar();
	for (; ch < '0' || ch > '9'; ch = getchar()) fh -= (ch == '-') << 1;
	for (; ch >= '0' && ch <= '9'; ch = getchar()) sum = (sum << 3) + (sum << 1) + (ch ^ 48);
	return (fh == 1) ? sum : -sum;
}

LL dfs1(int pos, int sum, int limit)
{
	if (pos == 0) return sum;
	if (!limit && f[pos][sum] != -1) return f[pos][sum];
	int t = limit ? a[pos] : k - 1; LL ans = 0;
	for (int i = 0; i <= t; ++i) ans += dfs1(pos - 1, sum + i * (pos - 1), limit && i == a[pos]);
	if (!limit) f[pos][sum] = ans;
	return ans;
}

LL dfs2(int pos, int sum, int tag, int limit)
{
	if (sum < 0) return 0;
	if (pos == 0) return sum;
	if (!limit && f[pos][sum] != -1) return f[pos][sum];
	int t = limit ? a[pos] : k - 1; LL ans = 0;
	for (int i = 0; i <= t; ++i) ans += dfs2(pos - 1, sum + ((pos < tag) ? -i : i), tag, limit && i == a[pos]);
	if (!limit) f[pos][sum] = ans;
	return ans;
}

LL Get(LL p)
{
	memset(f, -1, sizeof(f)); cnt = 0;
	for (; p; p /= k) a[++cnt] = p % k;
	LL sum = dfs1(cnt, 0, 1);
	for (int i = 2; i <= cnt; ++i)
	{
		memset(f, -1, sizeof(f));
		sum -= dfs2(cnt, 0, i, 1);
	}
	return sum;
}

int main()
{
	l = read(), r = read(), k = read();
	printf ("%lld\n", Get(r) - Get(l - 1));
	return 0;
}
```

---

## 作者：hzoi_liuchang (赞：2)

## 分析
对于一堆石子来说，显然合并到石子位置的中位数是最优的

但是题中给出的石子达到了 $10^{15}$ ，暴力枚举显然是不现实的

但是把所有的石子都合并到同一个位置的贡献是可以计算的

所以我们考虑先把所有的石子合并到编号为 $1$ 的一堆

然后再把石子从左往右移，每次算出减小的贡献减去

如果当前的位置在修改的位置左边，那么减小的贡献减去当前的数字

否则减小的贡献加上当前的数字

因为递归时从编号较大的石子递归到编号较小的石子

所以减小的贡献一定是先增大后减小的

因此为了防止数组越界，当当前值小于 $0$ 时，直接 $return 0$
## 代码
``` cpp
#include<cstdio>
#include<cstring>
#define ll long long
#define rg register
const int maxk=65,maxm=1e4+5;
ll f[maxk][maxm],l,r;
int num[maxk],cnt,k;
ll dfs(ll ws,ll tot,bool lim){
	if(!ws) return tot;
	if(!lim && f[ws][tot]!=-1) return f[ws][tot];
	int up=lim?num[ws]:(k-1);
	long long ans=0;
	for(int i=0;i<=up;i++){
		ans+=dfs(ws-1,tot+i*(ws-1),lim && i==up);
	}
	if(!lim) f[ws][tot]=ans;
	return ans;
}
ll dfs2(ll ws,ll tot,int xg,bool lim){
	if(tot<0) return 0;
	if(!ws) return tot;
	if(!lim && f[ws][tot]!=-1) return f[ws][tot];
	int up=lim?num[ws]:(k-1);
	long long ans=0;
	for(int i=0;i<=up;i++){
		ans+=dfs2(ws-1,tot+(ws<xg?-i:i),xg,lim && i==up);
	}
	if(!lim) f[ws][tot]=ans;
	return ans;
}
ll solve(ll now){
	cnt=0;
	while(now){
		num[++cnt]=now%k;
		now/=k;
	}
	memset(f,-1,sizeof(f));
	long long nans=dfs(cnt,0,1);
	for(int i=2;i<=cnt;i++){
		memset(f,-1,sizeof(f));
		nans-=dfs2(cnt,0,i,1);
	}
	return nans;
}
int main(){
	scanf("%lld%lld%d",&l,&r,&k);
	printf("%lld\n",solve(r)-solve(l-1));
	return 0;
}
```

---

## 作者：神眷之樱花 (赞：1)

# 题面
[方伯伯的商场之旅](https://www.luogu.com.cn/problem/P3286)
# 题解
如果是单个的情况，将它面前的石子往中位数的位置移肯定是最优的。

但是由于数的范围很大，这样做只能单独处理，所以显然不能这么做。

考虑上述思路的局限性，每个数面前的石子的中位数都要单独处理，也就是每个集合内的石子会移到不同且需要我们去求的位置，所以我们在规定的时间内无法做。

考虑我们能求出什么，如果我们知道了每个集合内的石子往哪里移，并且移到相同的位置，我们就可以用数位 DP 求出总花费。

但是这和我们要求的有什么联系呢。

接下来就是神仙转化。

我们先将每个集合内的石子移到位置 $1$， 然后再从左往右扫，求出答案的减小量，如果减小量为正，就更新答案，为了把范围内的总花费求出来，我们统计答案要以前缀和的形式统计。

# 数位 DP 的代码帮助理解：

用 $sum$ 表示减小量。

每次把移的位置往右移一位到 $p$，如果对于位置小于 $p$的，那么把要移的位置右移一位到 $p$ 时，总花费变大，那么对于减小量的贡献就是负的当前位置的值乘上多的距离 $1$，对于在 $p$ 右边及在 $p$ 上的，同理总花费变小，对减小量的贡献为正。

因为我们数位 DP 的时候从高位往低位扫，所以每次对减小量的贡献是从正的变成负的，所以一旦 $sum < 0$，那么它就不可能再变成正的了，而负的减小量是不能更新总花费的，所以直接返回 $0$。
```cpp
LL dfs(int now, int sum, int p, int lim) {
	if(sum < 0) return 0;
	if(!now) return max(sum, 0);
	if(!lim && ~f[now][sum]) return f[now][sum];
	int num = lim ? a[now] : k - 1; LL res = 0;
	for(int i = 0; i <= num; i++)
		res += dfs(now - 1, sum + ((p == 1) ? i * (now - 1) : (now < p ? -i : i)), p, lim & (i == num));
	if(!lim) return f[now][sum] = res;
	return res;
}
```

---

## 作者：Unnamed114514 (赞：0)

把每一位提取出来放到序列 $a$ 里面求前缀和得到 $s$。

先算出 $1$ 的答案，然后考虑位移之后答案的变化量，容易得到递推式：

$$f_i=f_{i-1}+2s_{i-1}-s_n$$

因为 $s$ 递增，所以 $f$ 是单谷的。

注意到 dp 是从高到低进行的，前缀和容易求出。

因此考虑钦定 $s_n$ 然后 dp 状态里维护前缀和进行转移。

---

## 作者：complete_binary_tree (赞：0)

如果只有一个数，那么最优解肯定是取中位数。

这样暴力 $\text{check}$ 是 $O((R - L) \log_K R)$ 的，肯定过不了。~~实测只能过一个点~~

那么这个结论有什么用呢？

观察可以发现，对于一个数，越远离这个最优点数值肯定越大，解越不优。因为它是一个绝对值 $\sum_{i = 1}^{len} |i - j| \cdot a_i$（$j$ 为定值）的形式。

那么对于每一个数肯定有一个点，使得这个函数的值最小。

于是我们可以先求出所有石子都合并到第 $1$ 堆的代价，然后进行转移，每一次将转移后更优的石子转移一位并减去转移一位所节省的代价。

我们发现这种方法直接计算 $[l,r]$ 较为困难，所以我们可以拆分为 $[1,r]$ 的答案减去 $[1,l - 1]$ 的答案。

详细地，我们分两个 dp（其实是记搜）过程。

- dp1：都移到第 $1$ 堆的代价。

设计状态 `dfs(pos,sum,lim)`。

`pos`：dp 的位置。（从低到高第 `pos` 位）

`sum`：前 `pos - 1` 位的总和。

`lim`：是否顶到上界。

发现 `sum` 很小，所以可以开二维数组 `f[pos][sum]` 进行记搜。（开 `f[55][2005]` 就够了）

那么当它要转移到下一位时，我们需要枚举这位填的数 $i$，由于是把这一位的石子转移到第 $1$ 位，所以这一位的代价是 $i \times ( pos - 1 )$。

当转移到末位的时候，代价就是 `sum`，此时直接 `return sum` 即可。

- dp2：移一位后减少的代价。

跟 dp1 类似，不过多一个状态。

状态：`dfs(pos,to_pos,sum,lim)`。

`to_pos`：表示要从 `to_pos - 1` 转移到 `to_pos`。

此时转移时，如果 `pos < to_pos` 那么代价是 $-i$，否则是 $i$。

形象生动地，我们可以这么理解：

```
    high                  low
pos 9  8  7  6  5  4  3  2  1
to_pos(5)       ^<-^
```

那么 $[1,5)(<pos)$ 的所有代价都增加，$[5,9](\ge pos)$ 的所有代价减小。

由于我们算的是 **代价减小的数值**，所以我们要反过来。

所以是 $<pos$ 的答案减小，$\ge pos$ 的答案增大，就是上面的 $-i$ 和 $i$。

这时如果 $sum$ 是正值，那么说明可以减小；但是如果 $sum$ 是负值，反而增大了，就不用继续了，因为再继续往下搜 $sum$ 只会越来越小，而我们对于这种情况可以直接不选，贡献是 $0$。

然后每一次 $ans$ 减去搜出来的代价就能得到最终代价。

时间复杂度 $O(K\log_K^2 R)$。代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 55, K = 25, SUM = 2005;
typedef long long ll;

int a[N], cnt, k;
ll f[N][SUM], l, r;

ll dfs1( int pos, ll sum, bool lim ) {
    if( !pos ) return sum; //搜到底，回溯
    if( !lim && f[pos][sum] != -1 ) return f[pos][sum]; //记忆化
    ll ans = 0;
    int now = ( lim ? a[pos] : k - 1 ); //顶到上界特殊处理
    //转移的时候由于是到第 1 位所以要加上 i*(pos-1)
    for( int i = 0; i <= now; ++i )
        ans += dfs1( pos - 1, sum + i * ( pos - 1 ), lim && i == now );
    if( !lim ) f[pos][sum] = ans; //记忆化
    return ans;
}

ll dfs2( int pos, int to_pos, ll sum, bool lim ) {
    if( sum < 0 ) return 0; //小于0没必要再搜了（还可能会数组越界）
    if( !pos ) return sum;
    if( !lim && f[pos][sum] != -1 ) return f[pos][sum];
    ll ans = 0;
    int now = ( lim ? a[pos] : k - 1 );
    //转移的时候，小于 to_pos 答案变劣，大于等于答案变优，所以是 - 和 +
    for( int i = 0; i <= now; ++i )
        ans += dfs2( pos - 1, to_pos, sum + ( pos < to_pos ? -i : i ), lim && i == now );
    if( !lim ) f[pos][sum] = ans;
    return ans;
}

ll query( ll x ){
    if( x <= 0 ) return 0;
    memset( a, 0, sizeof a ); cnt = 0; //记得清空！
    while( x ) a[++cnt] = x % k, x /= k;
    memset( f, -1, sizeof f ); //记得清空！
    ll ans = dfs1( cnt, 0, 1 ); //先求并到 1 的答案
    for( int pos = 2; pos <= cnt; ++pos ) {
        memset( f, -1, sizeof f ); //记得清空！重要的事情说三遍！
        ans -= dfs2( cnt, pos, 0, 1 ); //再转移，把更优的转移过来
    }
    return ans;
}

int main() {
    cin >> l >> r >> k;
    cout << query( r ) - query( l - 1 ) << endl; //差分
    return 0;
}
```

---

## 作者：__ycx2010__ (赞：0)

## 思路
对于一个数 $x$ 来说，它在 $K$ 进制下有 $n$ 位，分别为 $a_1,a_2,\dots,a_n$，$a_1$ 为低位，$a_n$ 为最高位。

设 $s_i = \sum_{i=1}^i a_i$。

首先我们可以先计算出将所有石子移动到第 $1$ 位的步数。

设 $f(i)$ 表示最终把所有石子移动到第 $i$ 位的步数，显然 $f$ 是单峰函数。

之前我们已经得到了 $f(1)$，则 $f(2) = f(1) + s_1 - (s_n - s_1)$。

得到递推式 $f(i) = f(i-1)+s_{i-1} - (s_n - s_{i-1})$。

由于 $f$ 是单峰函数，所以当 $s_{i-1}-(s_n-s_{i-1}) < 0$ 时，可以由 $i-1$ 移向 $i$，否则 $i-1$ 就是最优点。

于是得到最优解的公式为

$$f(1)+\sum_{i=2}^n min\{0, s_{i-1}-(s_n-s_{i-1})\}$$

把以上操作放在拓展为区间同时进行，用 dfs 加记忆化即可，具体看代码。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
int k;
int a[100];
ll f[100][10000];

ll dfs(int nw, int s, int p, bool lim) {
	if (s < 0) return 0;
	if (!nw) return max(0, s);
	if (!lim &&~f[nw][s]) return f[nw][s];
	ll ans = 0;
	int up = lim ? a[nw] : k - 1;
	for (int i = 0; i <= up; i ++ )
		ans += dfs(nw - 1, s + ((p == 1) ? i * (nw - 1) : (nw >= p ? i : -i)), p, lim && (i == up));
	if (!lim) f[nw][s] = ans;
	return ans;
}

ll solve(ll x) {
	int n = 0;
	while (x) {
		a[++ n] = x % k;
		x /= k;
	}
	ll ans = 0;
	for (int i = 1; i <= n; i ++ ) {
		memset(f, -1, sizeof f);
		ans += (i == 1 ? 1 : -1) * dfs(n, 0, i, 1);
	}
	return ans;
}

int main() {
	long long l, r;
	scanf("%lld%lld%d", &l, &r, &k);
	printf("%lld\n", solve(r) - solve(l - 1));
	return 0;
}
```

---

## 作者：OIer_ACMer (赞：0)

~~这个商场我下次也去一趟！~~

------------
## 警钟敲烂：
这道题千万不要放弃写 dfs，因为，加上个记忆化再加一个数位 DP 的模板你就 AC 了！

------------
## 大致思路：
本题偏模板数位 DP，比较适合我这种新手做，下面我就来讲一讲我这道题的思路。

首先，先固定集合点在最低位（也就是**合并的第一位**），很容易用数位 DP 求出来所有数的贡献，然后考虑集合点往高位移动移位的贡献改变，显然变化量是集合点左边的数位之和 $\operatorname{solve(l)}$ 减去右边的数位之和 $\operatorname{solve(r)}$。也就是前缀和减去后缀和，又因为，**前缀和是不断递增的，后缀和是不断递减的**（从左往右看），所以答案的函数是满足单调性的，即当变化量为负就移动，否则此时一定是最优情况。

接着，我们就来分析一下转移方程。我们先判断 $limit$ 有没有到头（也就是是否为 $0$），是的，则直接将此时的 $ans$ 值赋值给 $dp[x][s]$，否则就啥都不用做。同时，我们还不能忘记**设计状态**：**我们设** $dp[x][s]$ **为最高位到第** $x + 1$ **位的石子移到第** $1$ **位需要的代价为** $s$ **时**，**后** $x$ **位可以是任意个石子，其所需要的代价**。则在在当 $p$ 为 $1$时（$p$ 就是对应 $k$ 进制的第几个数，此时前面没有数）转移的时候我们除了要让 $x$ 减去 $1$，从而减小距离，还要将 $s$ 加上 $i$（石子个数）与 $x - 1$（同上）。还有一种可能，当 $p$ 的值不为 $1$ 时，我们就要考虑另外一种情况，我们判断此时 $x$ 最大值是否比 $p$ 小，是的话则可以减小代价，用 $-i$，否则代价增加，用 $i$（没有这个判断你一分也别想得到）。

注意开 long long，不然泪两行，还有空间要开足够。

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 105, M = 5005, inf = 0x3f3f3f3f, mod = 1e9 + 7;
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
int dp[N][M];
int a[N], k;
int l, r;
int dfs(int x, int s, int p, bool limit)
{
    if (!x)
    {
        return max(s, 0LL);
    }
    if (!limit && dp[x][s] != -1)
    {
        return dp[x][s];
    }
    int mx = limit ? a[x] : k - 1;
    int ans = 0;
    for (int i = 0; i <= mx; i++)
    {
        ans += dfs(x - 1, s + (p == 1 ? i * (x - 1) : (x < p ? -i : i)), p, limit & (i == mx));
    }
    if (!limit)
    {
        dp[x][s] = ans;
    }
    return ans;
}
int solve(int n)
{
    int w = 0;
    int ans = 0;
    while (n)
    {
        a[++w] = n % k, n /= k;
    }// 拆成 k 进制形式
    for (int i = 1; i <= w; i++)
    {
        memset(dp, -1, sizeof(dp)); 
        ans += (i == 1 ? 1 : -1) * dfs(w, 0, i, 1);
    }
    return ans;
}
signed main()
{
    l = read();
    r = read();
    k = read();
    cout << solve(r) - solve(l - 1);
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/122120390)

---


# [SDOI2013] 淘金

## 题目描述

小 Z 在玩一个叫做《淘金者》的游戏。游戏的世界是一个二维坐标。$X$ 轴、$Y$ 轴坐标范围均为$1\ldots N$。初始的时候，所有的整数坐标点上均有一块金子，共 $N^2$ 块。

一阵风吹过，金子的位置发生了一些变化。细心的小 Z 发现，初始在 $(i,j)$ 坐标处的金子会变到 $(f(i),f(j))$ 坐标处。其中 $f(x)$ 表示 $x$ 各位数字的乘积，例如 $f(99)=81,~f(12)=2,~f(10)=0$。

如果金子变化后的坐标不在 $1\ldots N$ 的范围内，我们认为这块金子已经被移出游戏。同时可以发现，对于变化之后的游戏局面，某些坐标上的金子数量可能不止一块，而另外一些坐标上可能已经没有金子。这次变化之后，游戏将不会再对金子的位置和数量进行改变，玩家可以开始进行采集工作。

小 Z 很懒，打算只进行 $K$ 次采集。每次采集可以得到某一个坐标上的所有金子，采集之后，该坐标上的金子数变为 $0$。

现在小 Z 希望知道，对于变化之后的游戏局面，在采集次数为 $K$ 的前提下，最多可以采集到多少块金子？ 答案可能很大，小 Z 希望得到对 $10^9+7$ 取模之后的答案。

## 说明/提示

对于 $100\%$ 的数据，$N \leq 10^{12}, K \leq \min(N^2, 10^5)$。


## 样例 #1

### 输入

```
12 5```

### 输出

```
18```

# 题解

## 作者：xyz32768 (赞：28)

反过来想：对于一个$i$，求有多少个$j$满足$f(j)=i$（下面记作$c(i)$）。

可以发现在$f(j)=i$中，数$i$必然可以分解成$2^a\times3^b\times5^c\times7^d$的形式。

所以虽然$N\leq 10^{12}$，但是满足$c(i)>0$的$i$是不多的（实测最多$14672$个）。

因此设状态：$dp[i,j,0/1]$表示从低到高位到了第$i$位，各位数的积为$j$（需要离散化），第三维表示小于等于/大于$N$的从低到高前$i$位。

转移即枚举第$i$位数$k$，如果$k|j$，

那么$dp[i,j,0/1]$可以从$dp[i-1,\frac j k,0/1]$转移过来。

这样就能算出所有$>0$的$c(i)$。

回到题目，可以得出，位置$(x,y)$的金子数目为$c(x)\times c(y)$。

所以要求的就是$c(x)\times c(y)$的前$K$大值之和。

由于$K$较小，因此可以将$c$从小到大排序，用大根堆维护$t$（有效的$c(x)$的个数）个指针（如果第$i$个指针在$j$位置，则关键字为$c(i)\times c(j)$，这里的$c$是排序后的，因此$c(i)$在这里是指排序后第$i$小的$c$值），每次贪心选择关键字最大的指针向左移，统计答案。

代码：

```cpp
#include <map>
#include <cmath>
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define For(i, a, b) for (i = a; i <= b; i++)
using namespace std;
typedef long long ll;
const int N = 15, M = 15000, MX = 1e9 + 7;
ll n, otz[M], f[N][M][2], sum[M];
int K, QAQ, a[N], ans;
map<ll, int> orz;
struct cyx
{
	int id, pos;
	cyx() {}
	cyx(int _x, int _y) :
		id(_x), pos(_y) {}
	friend inline bool operator < (cyx a, cyx b)
	{
		return sum[a.id] * sum[a.pos] < sum[b.id] * sum[b.pos];
	}
};
priority_queue<cyx> pq;
void DP(ll num)
{
	int i, j, k, n = 0;
	while (num) a[++n] = num % 10, num /= 10;
	For (k, 1, 9)
		f[1][orz[k]][k > a[1]]++;
	For (i, 2, n) For (j, 1, QAQ) For (k, 1, 9)
	{
		ll q = otz[j]; if (q % k != 0) continue;
		int h = orz[q / k];
		if (k < a[i]) f[i][j][0] += f[i - 1][h][0] + f[i - 1][h][1];
		else if (k > a[i])
			f[i][j][1] += f[i - 1][h][0] + f[i - 1][h][1];
		else f[i][j][0] += f[i - 1][h][0],
			f[i][j][1] += f[i - 1][h][1];
	}
	For (j, 1, QAQ)	For (i, 1, n)
		sum[j] += f[i][j][0] + (i == n ? 0 : f[i][j][1]);
	sort(sum + 1, sum + QAQ + 1);
	K = min(1ll * K, 1ll * QAQ * QAQ);
}
int main()
{
	int i, j, k, h;
	ll x = 1;
	cin >> n >> K;
	For (i, 0, 39)
	{
		ll t = x;
		For (j, 0, 25)
		{
			ll r = x;
			For (k, 0, 17)
			{
				ll w = x;
				For (h, 0, 14)
				{
					otz[orz[x] = ++QAQ] = x;
					x *= 7;
					if (x > n) break;
				}
				x = w * 5;
				if (x > n) break;
			}
			x = r * 3;
			if (x > n) break;
		}
		x = t * 2;
		if (x > n) break;
	}
	DP(n);
	For (i, 1, QAQ) pq.push(cyx(i, QAQ));
	For (i, 1, K)
	{
		cyx u = pq.top(); pq.pop();
		ans = (ans + sum[u.id] * sum[u.pos] % MX) % MX;
		if (u.pos == 1) continue;
		pq.push(cyx(u.id, u.pos - 1));
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：George1123 (赞：17)


到蒟蒻无人问津的小博客园看看![/kel](https://cdn.luogu.com.cn/upload/pic/62226.png)$\to$ [$\large\textit{George1123}$](https://www.cnblogs.com/George1123/p/13473544.html)

---
## 题面

> [SDOI2013 淘金](https://www.luogu.com.cn/problem/P3303)

> 有一个 $X$、$Y$ 轴坐标范围为 $1\sim n$ 的范围的方阵，每个点上有块黄金。一阵风来 $(x,y)$ 上的黄金到了 $(f(x),f(y))$，$f(x)$ 为 $x$ 各位上数字的乘积，如果黄金飘出方阵就没了。求在 $k$ 个格子上采集黄金最多可以采集的黄金数。

> 数据范围：$1\le n\le 10^{12}$，$k\le \min(n^2,10^5)$。

---
## 蒟蒻语

蒟蒻跟着 $\it srf$ 大师的日报来做这题，然后发现自己的裸代码跑得比题解都快，方法也比较神奇，于是来跟巨佬们讲讲。

---
## 蒟蒻解

首先众所周知，对于 $1\le i\le 10^{12}$，$f(i)$ 只有 $8282$ 种，所以可以先找出这 $8282$ 种 $f(i)$，蒟蒻有三种方法：set、枚举质因数和数位 dp。

为了优化可以用数位 dp（这是第一次数位 dp），正好求出 $1\sim n$ 的所有 $f(i)\not=0$：

```cpp
int dn,d[13],cnt=0;
ll t[N]; unordered_map<ll,int> nt;
bool vis[13][N];
void init(int w,ll now,bool ava){ //w：位 now：乘积 ava=true：可以自由选择数字
	if(!~w){if(!nt.count(now)) nt[t[cnt]=now]=cnt,cnt++;return;}
	if(vis[w][nt[now]]) return;
	vis[w][nt[now]]=true;
	int up=ava?9:d[w];
	for(int i=1;i<=up;i++) init(w-1,now*i,true||i<up); 
}
void INIT(){
	while(n) d[dn++]=n%10,n/=10;
	for(int i=0;i<=dn;i++) init(i-1,1,i<dn);
}
```

然后是最重要的部分：求每种 $f(i)$ 有多少个 $i$。

蒟蒻原来的做法是对每种 $f(i)$ 来一次数位 dp，瞬间被 TLE 打脸，于是蒟蒻想出了一个不同于别的巨佬的做法：

记 $f_{w,now}$ 表示到第 $w$ 位，剩下 $w$ 位乘积为 $now$ 的方案数。

用记忆化搜索转移，dp 中会用到除法。

```cpp
ll f[13][N];
ll dp(int w,int now,bool ava){ //w：位 now：剩下期望乘积 ava=true：可以自由选择数字
	if(!~w) return t[now]==1;
	if(ava&&~f[w][now]) return f[w][now];
	int up=ava?9:d[w]; ll res=0;
	for(int i=1;i<=up;i++)if(t[now]%i==0)
		res+=dp(w-1,nt[t[now]/i],ava||i<up);
	if(ava) f[w][now]=res;
	return res;
}
void DP(){
	memset(f,-1,sizeof f);
	for(int i=0;i<cnt;i++)
		for(int j=1;j<=dn;j++) a[i]+=dp(j-1,i,j<dn); // ai 是每种 fi 出现次数
}
```

然后给 $a_i$ 排个序，用堆维护找最大 $k$ 乘积即可，考虑到相乘可能会爆 long long，蒟蒻用了除法。

**时间复杂度 $\Theta(8282*12*10)$。**

---
## 代码

很明显蒟蒻的题解都是废话，只好放代码了![/kk](https://cdn.luogu.com.cn/upload/pic/62227.png)。

```cpp
#include <bits/stdc++.h>
using namespace std;

//Start
typedef long long ll;
typedef double db;
#define mp(a,b) make_pair(a,b)
#define x first
#define y second
#define be(a) a.begin()
#define en(a) a.end()
#define sz(a) int((a).size())
#define pb(a) push_back(a)
const int inf=0x3f3f3f3f;
const ll INF=0x3f3f3f3f3f3f3f3f;

//Data
const int N=8282;
const int mod=1e9+7;
ll n,a[N];
int k,nex[N],ans;
struct cmp{
	bool operator()(pair<int,int> p,pair<int,int> q){
		return 1.*a[p.x]/a[q.y]<1.*a[q.x]/a[p.y];
	}
};
priority_queue<pair<int,int>,vector<pair<int,int>>,cmp> q;

//Digitdp
int dn,d[13],cnt=0;
ll t[N]; unordered_map<ll,int> nt;
bool vis[13][N];
void init(int w,ll now,bool ava){
	if(!~w){if(!nt.count(now)) nt[t[cnt]=now]=cnt,cnt++;return;}
	if(vis[w][nt[now]]) return;
	vis[w][nt[now]]=true;
	int up=ava?9:d[w];
	for(int i=1;i<=up;i++) init(w-1,now*i,true||i<up); 
}
void INIT(){
	while(n) d[dn++]=n%10,n/=10;
	for(int i=0;i<=dn;i++) init(i-1,1,i<dn);
}
ll f[13][N];
ll dp(int w,int now,bool ava){
	if(!~w) return t[now]==1;
	if(ava&&~f[w][now]) return f[w][now];
	int up=ava?9:d[w]; ll res=0;
	for(int i=1;i<=up;i++)if(t[now]%i==0)
		res+=dp(w-1,nt[t[now]/i],ava||i<up);
	if(ava) f[w][now]=res;
	return res;
}
void DP(){
	memset(f,-1,sizeof f);
	for(int i=0;i<cnt;i++)
		for(int j=1;j<=dn;j++) a[i]+=dp(j-1,i,j<dn);
}

//Main
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>k,INIT(),DP();
	sort(a+0,a+cnt,[&](ll p,ll q){return p>q;});
	for(int i=0;i<cnt;i++) nex[i]=0,q.push(mp(i,nex[i]++));
	while(k--&&sz(q)){
		pair<int,int> u=q.top(); q.pop();
		(ans+=(a[u.x]%mod)*(a[u.y]%mod)%mod)%=mod;
		if(nex[u.x]<cnt) u.y=nex[u.x]++,q.push(u);
	}
	cout<<ans<<'\n';
	return 0;
}
```

---
**祝大家学习愉快！**

---

## 作者：ViXbob (赞：7)

[博客推广](https://www.vixbob-lwc.pw)

正解很妙啊, 但是我这个 ~~傻逼~~ 并没有想出来正解的那种做法

考虑到 $ f(i) $ 的值的个数, 只跟这个数中每个不同的数码的个数相关, 跟他们的位置无关

所以区间 $[1, 10 ^ k)$ 中不同的 $f(i)$ 的值的个数为 : 

$$\binom{k + 9 - 1}{k}$$

(有 0 就肯定不合法, 所以不用考虑 0 这个数码)

在极限数据下这个东西也只有 $125970$ 种

我们考虑直接**暴搜**出来每个数码有多少个就好了, 因为不能有前导零, 所以我们枚举一个长度, 然后有两种情况

* 如果长度小于 $N$ 的长度, 我们可以用多重全排列算出来方案数
* 如果长度等于 $N$ 的长度, 我们就数位 $dp$ 一下

然后好像就做完了???

至于要你选 $k$ 个最大的, 你就拿个优先队列贪心的维护一下就好了

关于多重全排列, 公式为 : 

$$P(n; a_1, a_2,...., a_9) = \frac{n!}{\prod _ i a_i!}$$

复杂度 $O(C_{20}^{12} \cdot log^2n + klog(C_{20} ^ {12}))$

$PS$ : 实际上因为要满足小于等于 $N$, 所以合法状态会变得更少

代码 :

```
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;
typedef __int128 int128;

const int maxn = 3e5 + 5;
const int P = 1e9 + 7;

int k, cnt[maxn], con[maxn], a[20], len, tot, OP, LEN, CONIT, ans;
LL N, num[maxn], fac[20], mi[20][20], prez, z;

struct Node {
	int id; int128 w;

	Node (int a, int128 b) {
		id = a; w = b;
	}

	bool operator < (const Node &t) const {
		return w < t.w;
	}
} ;

priority_queue<Node> q;
map<LL, int> mp;

inline LL read() {
	char ch = getchar(); LL u = 0, f = 1;
	while(!isdigit(ch)) {if(ch == '-') f = -1; ch = getchar();}
	while(isdigit(ch))  {u = u * 10 + ch - 48; ch = getchar();} return u * f;
}

inline int pls(int x, int y) {x += y; return x >= P ? x - P : (x < 0 ? x + P : x);}
inline int mul(int x, int y) {LL rnt = 1ll * x * y; return rnt >= P ? rnt % P : rnt;}

inline void prep(LL x) {
	len = 0;
	while(x) {
		a[++len] = x % 10;
		x /= 10;
	}
	reverse(a + 1, a + 1 + len);
	for(register int i = 0; i < 10; i++) {
		mi[i][0] = 1;
		for(register int j = 1; j < 15; j++) mi[i][j] = mi[i][j - 1] * i;
	}

	fac[0] = 1;
	for(register int i = 1; i <= 15; i++) fac[i] = fac[i - 1] * i;
}

inline LL calc(int *a) {
	int L = 0;
	for(register int i = 0; i < 10; i++) L += a[i];
	LL rnt = fac[L];
	for(register int i = 0; i < 10; i++) rnt /= fac[a[i]];
	return rnt;
}

inline LL dfs(int pos, bool lim, bool lead) {
	if(pos > 1 && lead) return 0;
	if(pos > len) return 1;
	if(!lim && !lead) return calc(cnt);
	LL rnt = 0, Lim = lim ? a[pos] : 9, tmp = calc(cnt), Len = 0;
	for(register int i = 0; i < 10; i++) Len += cnt[i];
	for(register int i = 0; i < Lim; i++) {
		if(!cnt[i]) continue;
		if(!lead || i) 
			rnt += (int128)tmp * fac[cnt[i]] * fac[Len - 1] / fac[Len] / fac[cnt[i] - 1];
	}
	if(cnt[Lim]) {
		cnt[Lim]--;
		rnt += dfs(pos + 1, lim, 0);
		cnt[Lim]++;
	} return rnt;
}

inline void solve(int pos, int sum, LL now) {
	if(pos > 9 && sum > 0) return;
	if(sum == 0) {
		LL tmp = 0, rnt = 0, Len = 0;
		if(LEN == len) tmp = dfs(1, 1, 1);
		else {
			rnt = calc(cnt);
			for(register int i = 0; i < 10; i++) Len += cnt[i];
			for(register int i = 1; i < 10; i++)
				if(cnt[i]) tmp += (int128)rnt * fac[cnt[i]] * fac[Len - 1] / fac[Len] / fac[cnt[i] - 1];
		}
		if(tmp < 1) return;
		if(mp[now]) OP = mp[now];
		else OP = mp[now] = ++tot;
		num[OP] += tmp;
		z += tmp;
		return;
	}
	for(register int i = sum - (!pos); i >= 0; i--) {
		cnt[pos] += i;
		solve(pos + 1, sum - i, now * mi[pos][i]);
		cnt[pos] -= i;
	}
}

int main() {
	N = read(); k = read();
	prep(N);
	
	for(register int i = 1; i <= len; i++) {
		memset(cnt, 0, sizeof(cnt));
		LEN = i; solve(1, i, 1);
	}

	sort(num + 1, num + 1 + tot);
	
	for(register int i = 1; i <= tot; i++) {
		con[i] = tot;
		q.push(Node(i, (int128)num[i] * num[tot]));
	}
    
	while(k && !q.empty()) {
		Node tmp = q.top(); q.pop();
		int del = tmp.w % P;
		ans = pls(ans, del);
		if(con[tmp.id] > 1) {
			tmp.w = (int128)num[tmp.id] * num[--con[tmp.id]];
			q.push(tmp); 
		} k--;
	}

	cout << ans;
	return 0;
}
/*
10
01
990 12250

*/

```

---

## 作者：Meaninglessness (赞：5)

考虑记忆化搜索的数位dp。

由于 $f(x)$ 是 $x$ 的各位数字相乘，则我们可以统计每个数的$0\sim9$的个数，并且也能记忆化。

状态 $dp[pos][num1][num2][num3][num4][num5][num6][num7][num8][num9]$ 表示当前位为 $pos$,$1\sim9$ 各用了 $num_1 \sim num_9$ 次的数的个数。

由于 $f(x)=0$ 不在坐标轴范围内，则在搜索时判断即可。

然后愉快的发现: $N \le 10^{12}$。明显爆炸。

有没有方法优化呢?



后来想到：
> - 一个数位$9$等价于两个数位$3$
> - 一个数位$8$等价于三个数位$2$
> - 一个数位$6$等价于一个数位$2$和一个数位$3$
> - 一个数位$4$等价于两个数位$2$
> - 数位$1$不会对 $f(x)$ 做出贡献

那么我们就可以将 $num4$,$num6$,$num8$,$num9$ 转化为 $num2$ 与 $num3$，并将 $num1$ 删除。


状态转化为 $dp[pos][num2][num3][num5][num7]$。

$13^{10} \rightarrow 13\times 39\times 26\times 13\times 13$

现在我们就有了最终所有的 $f(x)$，但答案是二维的，并且让你取前 $k$ 大的和。

二维可以直接用 $\sum\limits_{i=1}^n \sum\limits_{j=1}^n num_{f_i}\times num_{f_j}$ 得到,那么如何统计答案?

可以二分答案一个 $mid$，看有多少个值 $\ge mid$，最终找到恰好有 $k$ 个的情况即可。

注意:本题居然爆long long了，使用了一下__int128。

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#define mem(name,value) memset(name,value,sizeof(name))
using namespace std;
typedef long long ll;
inline ll min(ll a,ll b) {return a<b ? a : b;}
inline ll max(ll a,ll b) {return a>b ? a : b;}
inline ll abs(ll x) {return x>0 ? x : -x;}
const int Mod = 1e9+7;
const int maxn = 15;
const int maxlen = 40*27*14*14+5;
int a[maxn],top,len;
ll n,k,dp[maxn][3*maxn][2*maxn][maxn][maxn],maxnum;
__int128 num[maxlen],sum[maxlen];

ll dfs(int pos,int num2,int num3,int num5,int num7,bool lead,bool limit)
{
    if(pos==0) return (num2+num3+num5+num7+lead==0);
    if(!limit && !lead && dp[pos][num2][num3][num5][num7]!=-1) return dp[pos][num2][num3][num5][num7];
    int up;
    if(!limit) up=9;
    else up=a[pos];
    ll ans=0;
    for(int i=0;i<=up;i++)
    {
        if(i==0 && lead==true) ans+=dfs(pos-1,num2,num3,num5,num7,true,(limit==true && i==a[pos])); 
        if(i==1) ans+=dfs(pos-1,num2,num3,num5,num7,false,(limit==true && i==a[pos]));
        if(i==2 && num2>=1) ans+=dfs(pos-1,num2-1,num3,num5,num7,false,(limit==true && i==a[pos]));
        if(i==3 && num3>=1) ans+=dfs(pos-1,num2,num3-1,num5,num7,false,(limit==true && i==a[pos]));
        if(i==4 && num2>=2) ans+=dfs(pos-1,num2-2,num3,num5,num7,false,(limit==true && i==a[pos]));
        if(i==5 && num5>=1) ans+=dfs(pos-1,num2,num3,num5-1,num7,false,(limit==true && i==a[pos]));
        if(i==6 && num2>=1 && num3>=1) ans+=dfs(pos-1,num2-1,num3-1,num5,num7,false,(limit==true && i==a[pos]));
        if(i==7 && num7>=1) ans+=dfs(pos-1,num2,num3,num5,num7-1,false,(limit==true && i==a[pos]));
        if(i==8 && num2>=3) ans+=dfs(pos-1,num2-3,num3,num5,num7,false,(limit==true && i==a[pos]));
        if(i==9 && num3>=2) ans+=dfs(pos-1,num2,num3-2,num5,num7,false,(limit==true && i==a[pos]));
    }
    if(!limit && !lead) 
        dp[pos][num2][num3][num5][num7]=ans;
    return ans;
}

void solve(int num2,int num3,int num5,int num7)
{
    ll ans=dfs(top,num2,num3,num5,num7,true,true);
    num[++len]=ans;
    maxnum=max(maxnum,ans);
}

void spilt(ll x)
{
    while(x!=0)
    {
        a[++top]=x%10;
        x/=10;
    }
}

void write(__int128 x)
{
    if(!x) return;
	if(x<0) putchar('-'),x=-x;
    write(x/10);
    putchar(x%10+'0');
}


bool check(__int128 x)
{
    int tot=0;
    for(int i=len,tag=1;i>=1 && tag<=len;i--)
    {
        while(tag<=len && num[i]*num[tag]<x) tag++;
        tot+=len-tag+1;
    }
    return tot<k;
}

int main()
{
    scanf("%lld%lld",&n,&k);
    spilt(n);
    mem(dp,-1);
    for(int num2=0;num2<=39;num2++)
        for(int num3=0;num3<=26;num3++)
            for(int num5=0;num5<=13;num5++)
                for(int num7=0;num7<=13;num7++)	
                    solve(num2,num3,num5,num7);
    sort(num+1,num+len+1);
    __int128 l=0,r=__int128(maxnum)*maxnum,mid,val;
    while(l<r)
    {
        mid=(l+r)>>1;
        if(check(mid)==true) r=mid;
        else l=mid+1;
    }
    val=l-1;
    for(int i=len;i>=1;i--) sum[i]=(sum[i+1]+num[i])%Mod;
    ll ans=0,cnt=0;
    for(int i=1;i<=len;i++)
    {
        int id=lower_bound(num+1,num+len+1,ceil(1.0*val/num[i]))-num;
        ans=(ans+num[i]%Mod*sum[id])%Mod;
        cnt+=(len-id+1);
    }
    if(cnt>k) ans=((ans-val%Mod*(cnt-k)%Mod)+Mod)%Mod;
    printf("%lld\n",ans);
    return 0;
}


```

---

## 作者：s_r_f (赞：4)

[我的数位$DP$总结$blog$](https://www.luogu.com.cn/blog/s-r-f/oi-bi-ji-shuo-wei-dp-ge-ji-dui-shuo-wei-dp-di-yi-dian-li-xie)

首先写个爆搜$,$发现对于$1\leq i \leq10^{12}$的$i$ $,$ $f(i)$ 只有$8282$ 种 $.$ 所以考虑对于这 $8282$ 种数求出有多少数字满足$f(i) = $这个数字$.$

数位$dp,$ 记 $dp(x,n,1/0)$ 表示目前还有$n$位数字没有决定$,$**除去前导零之后**剩下的数字乘积为$x$ $($ 所有的$x$应当事先搜出来放到数组里 $),$ 目前有$/$无非零数的方案数$.$

求出来之后$,$令$a_i$为第$i$个数字被用到的次数$,$

把$a_i$从大到小排序$,$用堆贪心就可以了$.$

复杂度$O(8282 * 12 * 9 * hash()),$我自己代码里面用了$map,$所以比较慢$,$但是能过就没必要 $unordered$ $map$ 或者 手写$Hash$ 了 $.$

代码$:$

```cpp
#include <bits/stdc++.h>
#define LL long long
#define db double
using namespace std;
template <typename T> void read(T &x){
	x = 0; int f = 1; char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}
	while (isdigit(ch)) {x = x * 10 + ch - '0'; ch = getchar();}
	x *= f;
}
inline void write(int x){if (x > 9) write(x/10); putchar(x%10+'0'); }
const int S = 8282+5,P = 1e9 + 7;
LL v[S],pw[13]; int cnt; map<LL,int>Id;
namespace INIT{
	map<LL,int>S; int limit;
	inline void dfs(int dep,LL s){
		if (dep>limit){
			if (!S.count(s)){ S[s] = dep; v[++cnt] = s; Id[s] = cnt; }
			else S[s] = min(S[s],dep); 
			return;
		}
		if (S.count(s) && S[s] <= dep) return;
		if (!S.count(s)){ v[++cnt] = s; Id[s] = cnt; }
		S[s] = dep;
		for (int i = 0; i <= 9; ++i) dfs(dep+1,s*i);
	}
	inline void init(){
		int i,j;
		limit = 12,dfs(1,1);
		for (pw[0] = i = 1; i <= 12; ++i) pw[i] = pw[i-1] * 10;
	//	for (i = 1; i <= cnt; ++i) for (j = 0; j <= 9; ++j)
	//		if (Id.count(v[i]*j)) nxt[i][j] = Id[v[i]*j]; else nxt[i][j] = 0;
	}
}
LL dp[S][13][2]; bool vis[S][13][2];
inline LL DP(int s,int n,int tp){
	if (!s || !v[s]) return 0; if (!n) return (tp && v[s] == 1) ? 1 : 0;
	if (vis[s][n][tp]) return dp[s][n][tp]; vis[s][n][tp] = 1;
	LL tot = 0;
	if (tp){
		for (int i = 1; i <= 9; ++i) if (v[s] % i == 0) tot += DP((int)Id[v[s]/i],n-1,1);
	}
	else{
		for (int i = 1; i <= 9; ++i) if (v[s] % i == 0) tot += DP((int)Id[v[s]/i],n-1,1);
		tot += DP(s,n-1,0);
	}
	return dp[s][n][tp] = tot;
}
LL a[S];
inline void work(){
	LL n; register int i,j,k; int x; LL now = 1; bool flag = 0;
	cin >> n; ++n;
	for (i = 12; i >= 0; --i) if ((x=n/pw[i]%10)||flag){
		for (k = 1; k <= cnt; ++k) if (v[k] <= n)
		for (j = 0; j < x; ++j) if (v[k] && v[k] % (now*(j?j:1)) == 0){
			if (flag && !j) continue;
			a[k] += DP(Id[v[k]/now/(j?j:1)],i,(flag||j)?1:0);
		}
		flag = 1,now *= x; if (!now) break;
	}
}
int now[S],n,ans;
struct data{
	int x,y;
	bool operator < (data w) const{ return (db)a[x]*a[y] < (db)a[w.x]*a[w.y]; }
}t;
priority_queue<data>H;
int main(){
	int i,k;
	INIT::init(); work(); n = cnt; cin >> k;
	sort(a+1,a+n+1),reverse(a+1,a+n+1);
	for (i = 1; i <= n; ++i) now[i] = 1,t.x = i,t.y = 1,H.push(t);
	while (k--){
		t = H.top();
		ans = (ans + a[t.x] % P * (a[t.y] % P)) % P;
		H.pop();
		++now[t.x];
		if (now[t.x] <= n) ++t.y,H.push(t);
	}
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：gyh20 (赞：3)

数位 DP + 贪心。

求最大的 $f(i,j)$ 不好算，因为这是二维的，我们把它转为一个一维的问题。

首先，因为每一位上的数都不大于 $9$ （显然），所以乘积肯定是 $2^{a1}\times 3^{a2}\times 5^{a3}\times 7^{a4}$，而这样的数一定不多。

可以预处理出有哪些数是符合上述条件的，然后计算出有多少个将每一位分解后由 $a1$ 个 $2$，$a2$ 个 $3$，$a3$ 个 $5$，$a4$ 个 $7$ 组成的且不大于 $n$ 的数（预处理出 $0\sim 9$ 的质因数分解情况）。这是一个很简单的数位 DP。

将一维得到的结果排序，用优先队列维护当前最大值。

```cpp
#include<cstdio>
#include<queue>
#include<algorithm>
#include<cstring>
#include<map>
#define int long long
#define re register
#define M 1000000007
using namespace std;
inline int read(){
	re int t=0;
	re char v=getchar();
	while(v<'0')v=getchar();
	while(v>='0'){
		t=(t<<3)+(t<<1)+v-48;
		v=getchar();
	}
	return t;
}
int h[200002],tot,n,f[14][45][28][20][16][2],cnt[10][4]={{0,0,0,0},{0,0,0,0},{1,0,0,0},{0,1,0,0},{2,0,0,0},{0,0,1,0},{1,1,0,0},{0,0,0,1},{3,0,0,0},{0,2,0,0}},p[17],ans[200002],k,m,num;
map<int,int>mp;
inline void dfs(re int x){
	if(mp[x])return;
	mp[x]=1;
	if(x>n)return;
	h[++tot]=x;
	dfs(x<<1),dfs((x<<1)+x),dfs((x<<2)+x),dfs((x<<2)+(x<<1)+x);
}
inline int dp(re int x,re int a,re int b,re int c,re int d,re int z,re bool flag){

	if(a<0||b<0||c<0||d<0)return 0;
	if(x==0)return !a&&!b&&!c&&!d&&!z;//	printf("%lld %lld %lld %lld %lld %lld %d\n",x,a,b,c,d,z,flag);
	if(~f[x][a][b][c][d][z]&&!flag)return f[x][a][b][c][d][z];
	re int ret=0;
	for(re int i=!z;i<=(flag?p[x]:9);++i){
		
	ret+=dp(x-1,a-cnt[i][0],b-cnt[i][1],c-cnt[i][2],d-cnt[i][3],z&&(!i),flag&&(i==p[x]));//printf("%lld\n",f[x][a][b][c][d][z][flag]);
	}
	if(!flag)f[x][a][b][c][d][z]=ret;
	return ret;
}
struct node{
	int x,y;
	const bool operator <(const node xx)const{
	return ans[xx.x]*ans[xx.y]>ans[x]*ans[y];
}
};
inline int calc(re int x){
	re int a=0,b=0,c=0,d=0,y=x;
	while(!(x&1))x>>=1,++a;
	x=y;
	while(!(x%3))x/=3,++b;
	x=y;
	while(!(x%5))x/=5,++c;
	x=y;
	while(!(x%7))x/=7,++d;
	return dp(p[0],a,b,c,d,1,1);
}
priority_queue<node>q;
signed main(){
	re int xx=n=read();k=read();
	p[0]=0;
	while(xx){
		p[++p[0]]=xx%10;
		xx/=10;
	}
	dfs(1);
	memset(f,-1,sizeof(f));
	for(re int i=1;i<=tot;++i){
	ans[i]=calc(h[i]);
	//printf("%lld %lld\n",h[i],ans[i]);
	}
	sort(ans+1,ans+tot+1);
	for(re int i=1;i<=tot;++i)q.push(node{i,tot});
	for(re int i=1;i<=k;++i){
		re int x=q.top().x,y=q.top().y;
		q.pop();
	//	printf("%lld %lld\n",x,y);
		m+=ans[x]%M*ans[y]%M;
		m%=M;
		if(y>1)q.push(node{x,y-1}); 
	}
	printf("%lld",m);
}
```



---

## 作者：Aleph1022 (赞：3)

设 $c(x)$ 为满足 $f(i) = x$ 即各位数字之积 $=x$ 的 $i$ 的个数。

那么变化之后格子 $(x,y)$ 上有的金块个数就是 $c(x) \cdot c(y)$。

容易发现 $c(x)$ 中的 $x$ 分解后若除了 $2,3,5,7$ 还有其他质因子，$c(x) = 0$。

问题就在于 $c(x)$ 的求法，我们可以用数位 DP（个人喜欢记搜），状态需要记录搜到第 $x$ 位，组成的数 $= 2^a \cdot 3^b \cdot 5^c \cdot 7^d$ 中的指数 $a,b,c,d$。  
然后用一个常量数组记录一下 $1 - 9$ 分解之后的四个指数，搜索的时候注意除了前导 $0$ 的时候都不能选 $0$，以及所有位都是 $0$ 时最后一位会算作前导 $0$ 需要特判。

于是我们 DFS 一遍 $n$ 以内的质因子只有 $2,3,5,7$ 的数（或者直接枚举四个指数就行），求出其对应的 $c$ 函数值，然后把所有的 $c$ 函数值从大到小排个序。  
然后我们设 $c$ 函数值有 $cnt$ 个，往大根堆里面丢 $cnt$ 个形如 $(x,1)$ 的二元组，大根堆的优先级是二元组两个数的 $c$ 值之积。  
从大根堆取出一个二元组，计算对答案的贡献，再把第二个数加一丢回去。这样执行 $k$ 次就行了。

注意实现细节。  
以及，不要问为什么我用 pbds 的优先队列。

代码：
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <functional>
#include <ext/pb_ds/priority_queue.hpp>
using namespace std;
const int LEN = 12;
const int divi[10][4] = {
    {0,0,0,0},
    {0,0,0,0},
    {1,0,0,0},
    {0,1,0,0},
    {2,0,0,0},
    {0,0,1,0},
    {1,1,0,0},
    {0,0,0,1},
    {3,0,0,0},
    {0,2,0,0}
};
const long long N = 1e12;
const int CNT = 2e4;
const long long mod = 1e9 + 7;
long long n;
int k;
int tot,d[LEN + 5];
long long f[LEN + 5][LEN * 3 + 5][LEN * 2 + 5][LEN + 5][LEN + 5][2];
long long h[CNT + 5],c[CNT + 5];
int cnt;
void dfs(int x,long long prod)
{
    static const long long d[4] = {2,3,5,7};
    if(prod > n)
        return ;
    h[++cnt] = prod;
    for(register int i = x;i < 4;++i)
        dfs(i,prod * d[i]);
}
long long dfs(int x,int _2,int _3,int _5,int _7,int lead,int top)
{
    if(_2 < 0 || _3 < 0 || _5 < 0 || _7 < 0)
        return 0;
    if(!x)
        return !_2 && !_3 && !_5 && !_7;
    if(!top && ~f[x][_2][_3][_5][_7][lead])
        return f[x][_2][_3][_5][_7][lead];
    long long ret = 0;
    int bound = top ? d[x] : 9;
    for(register int i = x > 1 ? 0 : 1;i <= bound;++i)
    {
        if(!lead && !i)
            continue;
        ret += dfs(x - 1,_2 - divi[i][0],_3 - divi[i][1],_5 - divi[i][2],_7 - divi[i][3],lead && !i,top && i == bound);
    }
    if(!top)
        f[x][_2][_3][_5][_7][lead] = ret;
    return ret;
}
long long solve(long long x)
{
    int _2 = 0;
    while(!(x % 2))
        x /= 2,++_2;
    int _3 = 0;
    while(!(x % 3))
        x /= 3,++_3;
    int _5 = 0;
    while(!(x % 5))
        x /= 5,++_5;
    int _7 = 0;
    while(!(x % 7))
        x /= 7,++_7;
    return dfs(tot,_2,_3,_5,_7,1,1);
}
struct note
{
    int x,y;
    inline bool operator<(const note &a) const
    {
        return c[x] * c[y] < c[a.x] * c[a.y];
    }
};
__gnu_pbds::priority_queue<note> pq;
long long ans;
int main()
{
    memset(f,-1,sizeof f);
    scanf("%lld%d",&n,&k);
    dfs(0,1);
    long long temp = n;
    while(temp)
    {
        d[++tot] = temp % 10;
        temp /= 10;
    }
    for(register int i = 1;i <= cnt;++i)
        c[i] = solve(h[i]);
    sort(c + 1,c + cnt + 1,greater<long long>());
    k = min(k,cnt * cnt);
    for(register int i = 1;i <= cnt;++i)
        pq.push((note){i,1});
    for(register int i = 1;i <= k;++i)
    {
        note cur = pq.top();
        pq.pop();
        ans = (ans + c[cur.x] * c[cur.y]) % mod;
        if(cur.y == cnt)
            continue;
        pq.push((note){cur.x,cur.y + 1});
    }
    printf("%lld\n",ans);
}
```

---

## 作者：Infiltrator (赞：2)

[$\Large\color{#FFBBFF}\textit{Tian-Xing's blog}$](https://Tian-Xing.github.io)

------------

# Description

[传送门](https://www.luogu.com.cn/problem/P3303)

------------

# Solution

首先每一位上有$0$就不合法，然后很多不同的排列乘起来是相同的，所以盲猜最后的$f$函数有用的值不多。

经过搜索发现最多只有不到$10000$个。

~~为啥别的题解都是8282我搜出来是9200？~~

那就把这些合法的$f$函数值都放进哈希表存起来，然后设$dp_{i, x, 0/1}$表示当前$dp$到了第$i$位，乘积为哈希表里的第$x$个状态，有没有卡到最高位。

这个朴素的数位$dp$就枚举一下上一位的乘积，这一位选什么数即可。

注意要考虑前导零的情况。

然后我们就搜出来每种合法状态有多少个数会变成它，那么对于一个合法的位置$(i, j)$，它上面就有$tot_i \times tot_j$个金矿。

那么对$tot$排序，将一个二元组$(i, j)$放进堆里表示这是$tot$数组的第$i$个和第$j$个数相乘。

$(i, j)$可以转移到$(i + 1, j)$和$(i, j + 1)$，但是这样直接转移会有一个小问题，$(i - 1, j)$和$(i, j - 1)$都能转移到$(i, j)$，所以再记录一下上一次是不是将$j$加一，如果上次将$j$加一，那么这次不能再将$i$加一。

这样堆中的状态变为了一个三元组$(i, j, p)$，代表$tot$数组的第$i$个和第$j$个数相乘，上次是不是将$j$加一。

------------

# Code

```cpp
/*
    _______                       ________                        _______
   / _____ \                     / ______ \                      / _____ \
  / /     \_\  _     __     _   / /      \ \   _     __     _   / /     \_\
 | |          | |   |  |   | | | |        | | | |   |  |   | | | |
 | |          | |   |  |   | | | |     __ | | | |   |  |   | | | |
 | |       __ \  \  |  |  /  / | |     \ \| | \  \  |  |  /  / | |       __
  \ \_____/ /  \  \/ /\ \/  /   \ \_____\  /   \  \/ /\ \/  /   \ \_____/ /
   \_______/    \___/  \___/     \______/\__\   \___/  \___/     \_______/
*/
#include <iostream>
#include <queue>
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;

#define ll long long
#define RE register

const int HashMOD = 100077;
const int MOD = 1e9 + 7;

int k, head[HashMOD + 5], num, fa[20], shu[20], len, tot[10005], ans;

ll dp[14][10005][2];

ll n;

struct Node {
	int next;
	ll to;
} edge[HashMOD + 5];

struct HeapNode {
	int pos1, pos2;
	ll qz;
	bool flag;
	bool operator < (const HeapNode &rhs) const {
		return qz < rhs.qz;
	}
};

inline void Add(ll x) {
	int pos = x % HashMOD;
	for (RE int i = head[pos]; i; i = edge[i].next) {
		ll v = edge[i].to;
		if (v == x) return;
	}
	edge[++num] = (Node){head[pos], x};
	head[pos] = num;
	return;
}

inline int Find(ll x) {
	int pos = x % HashMOD;
	for (RE int i = head[pos]; i; i = edge[i].next) {
		ll v = edge[i].to;
		if (v == x) return i;
	} 
	return 0;
}

inline ll Ksm(ll a, int b) {
	ll tmp = 1;
	while (b) {
		if (b & 1) tmp = tmp * a;
		a = a * a;
		b >>= 1;
	}
	return tmp;
}

void Work() {
	ll tmp = 1;
	for (RE ll i = 1; i <= 9; i++)
		tmp *= Ksm(i, fa[i]);
	Add(tmp);
	return;
}

void Dfs(int x, int sum) {
	if (x == 10 || sum == 12) {
		Work();
		return;
	}
	for (RE int i = 0; i <= 12 - sum; i++)
		fa[x] = i, Dfs(x + 1, sum + i);
	return;
}

void Solve(ll n) {
	ll tmp = n;
	while (n) {
		shu[++len] = n % 10;
		n /= 10;
	}	
	for (RE int i = 1; i <= shu[len]; i++) dp[len][Find(i)][i == shu[len]] = 1;
	for (RE int i = len - 1; i >= 1; i--) {
		for (RE int now = 1; now <= 9; now++)
			dp[i][Find(now)][0]++;
		for (RE int lst = 1; lst <= num; lst++) 
			for (RE int p = 0; p <= 1; p++)
				if (dp[i + 1][lst][p]) {
					for (RE int now = 1; now <= (p ? shu[i] : 9); now++) {
						ll ne = edge[lst].to * now;
						dp[i][Find(ne)][p && (now == shu[i])] += dp[i + 1][lst][p];
					}
				}
	}
	for (RE int i = 1; i <= num; i++)
		if (edge[i].to <= tmp)
			tot[i] += dp[1][i][0] + dp[1][i][1];
	return;
}

bool Cmp(int a, int b) {
	return a > b;
}

void Qm(int &x) {
	x -= MOD;
	x += x >> 31 & MOD;
	return;
}

void Calc(int k) {
	sort(tot + 1, tot + num + 1, Cmp);
	priority_queue<HeapNode> q;
	q.push((HeapNode){1, 1, 1LL * tot[1] * tot[1] % MOD, false});
	while (!q.empty() && k) {
		HeapNode tmp = q.top(); q.pop();
		int pos1 = tmp.pos1, pos2 = tmp.pos2;
		if (!tmp.qz) break;
		k--;
		Qm(ans += tmp.qz % MOD);
		if (pos1 <= num && tmp.flag == false) q.push((HeapNode){pos1 + 1, pos2, 1LL * tot[pos1 + 1] * tot[pos2], false});
		if (pos2 <= num) q.push((HeapNode){pos1, pos2 + 1, 1LL * tot[pos1] * tot[pos2 + 1], true});
	}
	return;
}

int main() {
	Dfs(1, 0);
	scanf("%lld%d", &n, &k);
	Solve(n);
	Calc(k);
	printf("%d", ans);
	return 0;
}
```

---

## 作者：Piwry (赞：2)

感觉用这题可以用来测测自己的数位 dp 掌握程度qwq

## 解析

发现 $n$ 的范围很大，显然我们没法一个个验证每个数的 $f$ 取值

于是倒过来想，设 $g(x)$ 表示 $|\{y: f(y)=x, 1\leq y\leq n\}|$（$f$ 取值为 x 的且在 $n$ 范围内的数字的个数）。由于数位上的数字范围只有 $[1, 9]$，我们发现 $x$ 一定可以表示为 $2^a3^b5^c7^d$ 的形式；这样的数在题目范围内应该是不多的（yy 一下也就 $(\log_5 n)^4$ 左右的样子X），实际上只有 $14762$ 个

（有些题解说是 $8282$ 个...这应该是因为他们还另外要求了 $f(y)=x$ 中的 $y$ **也在题目范围**内，而这里只是简单地要求 $x$ 在范围内；要做到 $8282$ 个只需在 dfs 里再加几个条件即可（我比较懒就没敲了X））

于是题目的前半部分就转化为，对于每种 $x=2^a3^b5^c7^d$，求出 $g(x)=|\{y: f(y)=x, 1\leq y\leq n\}|$ 的值（取 $k$ 大部分待会再说）

可以简单地想到：设 $dp(i, k, a, b, c, d)$ 表示放到第 $i$ 位，该位为 $k$，已放数位的乘积 $x=2^a3^b5^c7^d$ 的方案数。手模一下发现 $a\cdot b\cdot c\cdot d$ 的值最大也就 $1200$ 左右；但我们如果算上 $i, k$ 以及 $x$ 的取值个数，还有每次枚举数位的数字，就会发现运算次数超过了 $10^{10}$——这妥妥地过不了（

只要再稍微想一下就可以发现，这个 dp 有很多重复计算的部分：我们在算 $dp(i, k, a, b, c, d)$ 时，实际上也算了 $dp(i, k, a', b', c', d'), a'\leq a, b'\leq b, c'\leq c, d'\leq d$，于是就可能存在 $x'=2^{a'}3^{b'}5^{c'}7^{d'}$，被重复计算了

于是我们可以用类似记搜的策略，标记计算过的状态；这样运算次数应该就在 $10^6$ 左右了（可能还有一些常数），可过

&nbsp;

现在我们已经计算出所有可能的 $x$ 的 $g(x)$ 的值。考虑坐标 $(x_1, x_2)$ 的贡献，其显然是 $g(x_1)\cdot g(x_2)$。于是剩余部分的问题就为：从一些数 $\{a_1, a_2, a_3, \cdots\}$ 中选出最大的 $k$ 对 $a_i\cdot a_j$（且要求选出的 $k$ 对两两间 $i, j$ 不能都相同）

由于每个数都可和其它每个数都配对一次，即每个数可以使用多次，因此双指针贪心（我一开始想的X）是行不通的

我们先固定一个数 $a_i$，并只考虑它的配对；显然是贪心地第一次和最大的数配对，接着再和次大的配对...；我们发现每个数只会和 $a_i$ 配对**一次**。

于是可以对每个数 $a_i$ 维护一个指针 $j$，表示它当前正配对的数 $a_j$；再把 $a_i\cdot a_j$ 作为键值放到堆里排序，每次取出堆顶的元素统计答案，将该元素对应的指针向后移一位（还要求先把数列排序），再重新计算键值，并把该元素放回堆里（如果指针尚未遍历完数列），这样重复 $k$ 次即可

## CODE

如果觉得开四维状态太多的话，其实也可以将 $x$ 离散化一下做成一维状态（就像我代码中做的），转移时用当前标号对应的 $x$ 的值除放置的数字，得到的值在维护的关系表里再查找一次就行了；不过这样会使复杂度再带一个 $\log$（用 `stl` 的哈希好像也不会太快...）。注意不要频繁的查找（例如我代码中注释掉的部分），否则会被卡常卡时限

还有 dp 时 $k$ 这个状态其实也可简化为 $0/1$，表示当前数位的数小于/大于等于 $n$ **的该数位**——因为实际统计时我们也就只分这两种状态讨论（不过这样就不能统计等于 $n$ 的数字了，还需要 `++n`）。这个 trick 在别的数位 dp 也能用

&nbsp;

另外在维护堆时，两个 `ll` 范围的方案数相乘可能会炸 `ll`，这时可以考虑将键值类型换成 `double`；或者先将这两个 `ll` 打包成类存下来，比较时再用比例计算，就像这样：

```cpp
bool cmp(pair<ll, ll> A, pair<ll, ll> B){
	return 1.0*A.first/B.second < 1.0*B.first/A.second;
}
```

第二种方法比起第一种方法要更可靠，但在极端情况下两种方法都可能出错（毕竟精度摆在那）。于是我就~~偷懒~~选择直接用 `__int128` 存键值

```cpp
#include <cstdio>
#include <cmath>
#include <unordered_map>
#include <queue>
#include <algorithm>
#pragma GCC optimize("O3")
#pragma GCC optimize("Ofast", "-funroll-loops", "-fdelete-null-pointer-checks")
#pragma GCC target("ssse3", "sse3", "sse2", "sse", "avx2", "avx")
#define ll long long
using std::unordered_map;
using std::priority_queue;
using std::vector;
using std::greater;
using std::pair;
using std::sort;
typedef pair<ll, int> pad;
typedef pair<__int128, int> pad2;

const int M =1e9+7, IDMAX =14762;
const int prim[4] ={2, 3, 5, 7};

/*------------------------------f------------------------------*/

ll n, K;
int ID;
unordered_map<ll, int> Map;/*对于每个 f 值的 id ( 离散化 )*/
ll val[IDMAX];/*每个 id 对应的的 f 的值*/

/*搜索可能的 f 取值*/
void dfs(int p, ll valf){
	if(p == 4){
		Map.insert(pad(valf, ID));
		val[ID] =valf;
		++ID;
		return;
	}
	for(int i =0; i <= (int)(log2(n)/log2(prim[p])); ++i){
		dfs(p+1, valf);
		valf *=prim[p];
		if(valf > n)
			return;
	}
}

/*------------------------------dp------------------------------*/

/*前面部分必须用 ll ( 不能取模 )*/
int dig[15], len;
ll dp[15][2][IDMAX];/*i 位，该位数字比 n 的该位小/大于等于，数位乘积为 x ( 已离散化 )，的数字有多少个*/
ll g[IDMAX];/*g(x): 有多少数字 y，满足 f(y) 为 x*/

void Dp(){
	/*初始化*/
	for(int k =1; k <= 9; ++k){
		if(k < dig[1])
			dp[1][0][Map.find(k)->second] =1;
		else
			dp[1][1][Map.find(k)->second] =1;
	}
	/*dp，这里的转移我是反着写的，于是不需要对每个乘积 x 做一次 dp ( 还要考虑 dp 顺序问题 )，更不用记录状态是否被计算过*/
	for(int i =1; i < len; ++i)
		for(int id =0; id < ID; ++id)
			for(int knet =1; knet <= 9; ++knet){
			//	if(!Map.count(val[id]*knet))/*这个 map 操作不是必要的，还会带来两倍常数 (*/
				if(val[id]*knet > n)
					continue;
				int idnet =Map.find(val[id]*knet)->second;
				if(knet < dig[i+1])
					dp[i+1][0][idnet] +=dp[i][0][id]+dp[i][1][id];
				else
					dp[i+1][1][idnet] +=dp[i][0][id]+dp[i][1][id];
			}
	/*统计答案*/
	for(int id =0; id < ID; ++id){
		ll ans =0;
		for(int i =1; i < len; ++i)
			ans +=dp[i][0][id]+dp[i][1][id];
		int idnw =id;
		for(int i =len; i >= 1; --i){
			ans +=dp[i][0][idnw];
			if(dig[i] == 0)/*之后数位乘积也一定为 0 了，不合法*/
				break;
			if(val[idnw]%dig[i] != 0)/*乘积不再合法*/
				break;
			idnw =Map.find(val[idnw]/dig[i])->second;
		}
		g[id] =ans;
	}
}

/*------------------------------k------------------------------*/

priority_queue<pad2, vector<pad2> > Heap;/*也可用 double，再弄个比例更不容易错，但我比较懒 X*/
int gPair[IDMAX];/*目前的 a_1 配对的 a_2，数组名有 g 是因为毕竟 {a} 数组里面的值就是 g(x) qwq*/

/*------------------------------Main------------------------------*/

int main(){
	scanf("%lld%lld", &n, &K);
	dfs(0, 1);
	ll n2 =n+1;
	while(n2){
		dig[++len] =n2%10;
		n2 /=10;
	}
	Dp();
	sort(g, g+ID, greater<ll>());
	for(int i =0; i < ID; ++i)
		Heap.push(pad2((__int128)g[i]*g[0], i)), gPair[i] =0;
	int ans =0;
	for(int i =0; i < K && !Heap.empty(); ++i){
		pad2 nw =Heap.top();
		Heap.pop();
		(ans +=nw.first%M) %=M;
		++gPair[nw.second];
		if(gPair[nw.second] < ID)
			Heap.push(pad2((__int128)g[nw.second]*g[gPair[nw.second]], nw.second));
	}
	printf("%d", ans);
}
```

---


# [COCI 2018/2019 #4] Akvizna

## 题目描述

你面临 $n$ 名参赛者的挑战，最终要将他们全部战胜。  
每一轮中，都会淘汰一些选手；你会得到这一轮奖金池中 被淘汰者 除以 这一轮对手总数 比例的奖金。  

例如某一轮有 $10$ 个对手，淘汰了 $3$ 个，那么你将获得奖金池中 $3/10$ 的奖金。  

假设每一轮的奖金池均为一元，`Mirko` 希望通过恰好 $k$ 轮赢得比赛，那么他最多可能获得多少奖金呢？   

你只需要输出答案保留 $9$ 位小数即可。

## 说明/提示

### 样例1解释：   

最优的情况为：  
第一轮淘汰 $3$ 人，剩下两轮各淘汰 $1$ 人。  
获得奖金为 $\frac{3}{5}+\frac{1}{2}+\frac{1}{1}=2.1$ 元。

### 数据范围：   

对于$20\%$的数据，$1\le n\le 100$。

对于$40\%$的数据，$1\le n \le 3000$。

对于$100\%$的数据，$1\le k \le n \le 10^5$。

本题较卡精度，请留意。

## 样例 #1

### 输入

```
5 3```

### 输出

```
2.100000000```

## 样例 #2

### 输入

```
10 10```

### 输出

```
2.928968254```

# 题解

## 作者：Aleph1022 (赞：14)

本文同步发表于我的博客：https://www.alpha1022.me/articles/loj-3132.htm

发现踢人的顺序并不影响答案，所以我们不妨把每次踢的人都看成一段，并且**倒序 DP**。  
这样的话，每一轮的总人数就比较好计算。

首先不考虑 $k$，设 $f_i$ 表示从后往前数某一轮还剩 $i$ 个人的最大奖金。  
显然转移就枚举这一轮的下一轮还剩多少人，中间少的就是淘汰的。  
有 $f_i = \max\limits_{0 \le j < i}(f_j + \dfrac{i - j}i)$。

假设对于决策 $0 \le k < j < i$，有 $j$ 优于 $k$，即
$$\begin{aligned}f_j + \dfrac{i - j}i & > f_k + \dfrac{i - k}i \\f_j - f_k & > \dfrac{j - k}i \\\dfrac{f_j - f_k}{j - k} & > \dfrac 1 i\end{aligned}$$

然后既然有了 $k$ 的限制，显然 WQS 二分直接上。

代码：
```cpp
#include <cstdio>
using namespace std;
const int N = 1e5;
const long double eps = 1e-12;
int n,k,g[N + 5];
int q[N + 5],head,tail;
long double f[N + 5];
long double l,r,mid;
inline long double slope(int x,int y)
{
    return (f[x] - f[y]) / (x - y);
}
int check()
{
    q[head = tail = 1] = 0;
    for(register int i = 1;i <= n;++i)
    {
        for(;head < tail && slope(q[head],q[head + 1]) - 1.0 / i > eps;++head);
        f[i] = f[q[head]] + (long double)(i - q[head]) / i - mid,g[i] = g[q[head]] + 1;
        for(;head < tail && slope(q[tail - 1],q[tail]) - slope(q[tail],i) < -eps;--tail);
        q[++tail] = i;
    }
    return g[n] >= k;
}
int main()
{
    scanf("%d%d",&n,&k);
    l = 0,r = 1e6;
    for(register int i = 1;i <= 200;++i)
    {
        mid = (l + r) / 2;
        if(check())
            l = mid;
        else
            r = mid;
    }
    mid = l,check();
    printf("%.9Lf\n",f[n] + k * mid);
}
```

---

## 作者：D_F_S (赞：11)

	看了看题解里好像没有一篇 DP 正推的，那不妨我来写一篇吧~
    
    
  

## Solution：
设 $f[i][j]$ 表示前 i 名参赛者中挑战 j 轮所获得的奖最大值，

易得状态转移方程 :

>>$ f[i][k]=\max\limits_{0 \leq j < i}(f[j][k-1]+ \frac{i-j}{n-j})$

考虑斜率优化，既得：

>>$ f[j][k-1]-\frac{j}{n-j}=(-i)\times \frac{1}{n-j}+f[i][k]$

令 $f[j][k-1]$ 为 $y$，$\frac{1}{n-j}$ 为 $x$，$(-i)$ 为 $k$，$f[i][k]$ 为 $b$。

其中 $x$、$k$ 均满足单调性，则可用单调队列维护上凸包进行斜率优化 DP。


------------
然后看看数据范围，$O(nk)$ 的时间复杂度直接 GG，考虑优化，简单证明 ~~(口胡 ，反正也没学过别的优化方式)~~ 便知是 WQS 二分，然后注意各种细节就行了。 (￣▽￣)~*



## Code:
```cpp
#include<bits/stdc++.h>
#define inl inline
#define re register
typedef long double ld;
using namespace std;
const int maxn=100005,inf=1e9;
const double eps=1e-14;
inl int Read()
{
	re int s=0,f=1;
	re char c;
	while(!isdigit(c=getchar()))
		if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) s=s*10+c-'0';
	return s*f;
}
int n,K,head,tail,q[maxn],g[maxn];
ld f[maxn];
inl ld X(int x)
{
	return 1.0/(n-x);
}
inl ld Y(int x)
{
	return f[x]-1.0*x/(n-x);
}
inl ld Calc(int x,int y)    //为了避免精度误差最好用叉积，只是我懒得~
{
	return (Y(y)-Y(x))/(X(y)-X(x));
}
inl bool Check(double x)
{
	head=tail=1;
	for(re int i=1;i<=n;++i)
	{
		while(head<tail&&Calc(q[head],q[head+1])>=-1.0*i) ++head;
		f[i]=Y(q[head])+i*X(q[head])-x;    //由于是求最大值，应减去额外贡献才能让分段越多代价越大 
		g[i]=g[q[head]]+1;
		while(head<tail&&Calc(q[tail-1],q[tail])<=Calc(q[tail],i)) --tail;
		q[++tail]=i;
	}
	return g[n]>=K;
}
int main()
{
	n=Read();
	K=Read();
	double l=0.0,r=1.0*inf;    //因为 f 可取实数，所以二分的额外贡献也要取到实数 
	while(r-l>=eps)
	{
		re double mid=(l+r)*0.5;
		if(Check(mid)) l=mid;
		else r=mid;
	}
	Check(l);
	printf("%.9Lf\n",f[n]+1.0*l*K);
	return 0;
}
```


---

## 作者：ADay (赞：6)

[更好的阅读体验](http://www.aday.fun/%E9%A2%98%E8%A7%A3%20P5308%20%5BCOCI2019%5D%20Quiz/)  


$\text{WQS}$ 二分+斜率优化

若没有 $k$ 的限制，可以用 $f_i$ 表示剩 $i$ 个人时获得的最大收益，那么当下一轮剩 $j$ 个人时，这一轮就淘汰了 $i-j$ 个人，获得 $\dfrac{i-j}{i}$ 的奖金。

所以转移方程为 $f_i=\max\{f_j+\dfrac{i-j}{i}\}(j<i)$。

这个式子显然可以斜率优化，转化为 $y=kx+b$ 的形式，即 $\underline{f_j}_y=\underline{\dfrac{1}{i}}_k\times\underline{j}_x+\underline{f_i-1}_b$。

现在考虑有 $k$ 的限制，“恰好 $k$ 个”显然是 $\text{WQS}$ 二分的特征，其凸性读者可以自证。~~我只会打表找规律~~

另外，此题稍卡精度，所以我加了个时间限制。

Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
const double eps=1e-20;
int n,K;
double f[N];
int q[N],cnt[N];
inline double Y(int i,int j){return f[i]-f[j];}
inline double X(int i,int j){return i-j;} 
inline double slope(int i,int j){return Y(i,j)/X(i,j);}
bool check(double k){
    int l=1,r=1;q[1]=0;
    memset(cnt,0,sizeof(cnt));
    for(int i=1;i<=n;i++){
        while(l<r&&slope(q[l+1],q[l])>1.0/(double)i+eps)l++;
        int j=q[l];
        f[i]=f[j]+(double)(i-j)/(double)i-k;
        cnt[i]=cnt[j]+1;
        while(l<r&&slope(q[r],q[r-1])+eps<slope(i,q[r]))r--;
        q[++r]=i;
    }return cnt[n]>=K;
}
int main(){
    scanf("%d%d",&n,&K);
    double l=0,r=1e6;
    while(l+eps<r&&(double)clock()/CLOCKS_PER_SEC<=1.9){
        double mid=(l+r)/2.0;
        if(check(mid))l=mid;
        else r=mid;
    }printf("%.9lf\n",f[n]+l*K);
    return 0;
}
```



---

## 作者：tylon2006 (赞：3)

为什么题解全都是反着推啊，明明正着也很好搞吧。。


## DP式

设 $dp[i][k]$ 为当前淘汰了 i 人，已经经 k 轮的答案。

那么显然有 $dp[i][k]=min(dp[j][k-1]+\dfrac{i-j}{n-j})$

$i-j$ 为当前轮淘汰人数，$n-j$ 为当前轮总人数

## 斜率优化

注意是求最大值(

$(dp[j_2][k-1]-\dfrac{j_2}{n-j_2})+\dfrac{i}{n-j_2}\geq (dp[j_1][k-1]-\dfrac{j_1}{n-j_1})+\dfrac{i}{n-j_1}$

$(dp[j_2][k-1]-\dfrac{j_2}{n-j_2})-(dp[j_1][k-1]-\dfrac{j_1}{n-j_1})\geq i*(\dfrac{1}{n-j_1}-\dfrac{1}{n-j_2})$

那么令 $Y(i)=dp[i][k-1]-\dfrac{i}{n-i}$，$X(i)=\dfrac{1}{n-i}$

则有 $Y(j_2)-Y(j_1)\geq i*(X(j_1)-X(j_2))$

即 $\dfrac{Y(j_2)-Y(j_1)}{X(j_1)-X(j_2)}\geq i$

我们一般习惯化为 $\dfrac{Y(j_2)-Y(j_1)}{X(j_2)-X(j_1)}\leq -i$ 方便判断**凸的方向**

那么这就是优化后的式子，呈上凸

## wqs二分

先不考虑 k 轮的限制，显然上面那个直接算。

按照套路用斜率为 $k_0$ 的直线 $l$ 去切由**轮数为1~n的最优解组成的上凸包**

切点为 $(k,g(k))$ 时满足 k 轮的条件，$g(k)$为k轮时的**最优解**。

设 $f(k)$ 为 $l$ 在 y 轴上的截距，那么 $f(k)=g(k)-k_0x$

那么我们取到最大的 $f(k)$ 即可。

注意到进行了 k 段，减去了 $kx$，那么就 $f(k)$ 相当于**每段的贡献减k的答案**。

那么二分 $k_0$，答案就为 $g(k)=f(k_0)+k_0*k$

## 代码

因为有点卡精度所以我把除移到了右边变成乘法。

即 $Y(j_2)-Y(j_1)\geq -i*(X(j_1)-X(j_2))$

队尾处理同理。

```cpp
#include<bits/stdc++.h>
#define eps 1e-18
using namespace std;
long double f[100010];
int q[100010],hd,tl;
int s[100010],n,k;
long double X(int i){
	return 1.0/(long double)(n-i);
}
long double Y(int i){
	return f[i]-(long double)i/(n-i);
}
bool check(long double mid){
	hd=1,tl=0;
	q[++tl]=0;
	for(int i=1;i<=n;i++){
		while(hd<tl&&Y(q[hd+1])-Y(q[hd])>=-i*(X(q[hd+1])-X(q[hd]))) hd++;
		int j=q[hd];
		s[i]=s[j]+1;
		f[i]=f[j]+(long double)(i-j)/(n-j)-mid;
		while(hd<tl&&(Y(q[tl])-Y(q[tl-1]))*(X(i)-X(q[tl-1]))<=(Y(i)-Y(q[tl-1]))*(X(q[tl])-X(q[tl-1]))) tl--;
		q[++tl]=i;
	}
	return s[n]<=k;
}
int main(){
	scanf("%d%d",&n,&k);
	long double l=0,r=1,mid;
	while(l<r-eps){
		mid=(l+r)/2.0;
		if(check(mid)) r=mid;//被减的越多段数就越少
		else l=mid;
	}
	printf("%.9Lf",f[n]+mid*k);
}
```



---

## 作者：i207M (赞：2)

**wqs二分最后计算答案的时候，假如要求是选K个，那么答案是$ans[n]+K\times mid$，不是$ans[n]+cnt[n]\times mid$！！！**~~（否则这道题会被卡精度，第12位出错emmmm~~

~~（问VUQ做出来的题~~

其实这道题的难点是想到算法，等我说出算法，大家估计就会做了。所以，算法是：

# wqs二分+斜率优化

~~好了，赶快自己想想，然后独立切掉这道题~~

首先思考，没有k的限制，我们怎样做？

$$dp[n]=\max_{i<n}(dp[i]+(n-i)/n)$$

斜率优化没啥问题吧。

现在有了k轮的限制，类比林克卡特树的思想，我们可以给每一轮一个附加权值mid，于是方程就变成了：

$$dp[n]=\max_{i<n}(dp[i]+(n-i)/n-mid),cnt[n]=cnt[i]+1$$

同样斜率优化，根据$cnt[n]$改变二分的l,r即可。

```cpp
#define N 100005
#define lb long double
#define eps 1e-12
int n,K;
lb dp[N];
int f[N];
int q[N],hd,tl;
void calc(const lb &mid)
{
	q[hd=tl=1]=0;
	for(ri i=1; i<=n; ++i)
	{
		while(hd<tl&&i*(dp[q[hd+1]]-dp[q[hd]])-(q[hd+1]-q[hd])>-eps) ++hd;
		dp[i]=dp[q[hd]]+(lb)(i-q[hd])/i-mid;
		f[i]=f[q[hd]]+1;
		while(hd<tl&&(q[tl]-q[tl-1])*(dp[i]-dp[q[tl-1]])-(i-q[tl-1])*(dp[q[tl]]-dp[q[tl-1]])>-eps) --tl;
		q[++tl]=i;
	}
}
signed main()
{
#ifdef M207
	freopen("in.in","r",stdin);
	// freopen("ot.out","w",stdout);
#endif
	in(n,K);
	lb l=-1e6,r=1e6;
	for(ri o=0; o<60; ++o)
	{
		lb mid=(l+r)/2;
		calc(mid);
		if(f[n]>=K) l=mid;
		else r=mid;
	}
	calc(l);
	printf("%.9Lf\n",dp[n]+K*l);
	return 0;
}
```


---

## 作者：Tony102 (赞：2)

[Link](https://www.luogu.com.cn/problem/P5308)

[更好的阅读体验](https://tony102.xyz/index.php/2021/03/27/luogu5308-coci2019-quiz/)

### Sol

正着 DP 好像不好表示这一次选的这一段，正难则反就倒着 DP。设 $f_i$ 表示从后往前的一轮还剩 $i$ 个人的最多奖金。暴力转移就是枚举下一轮还有 $j$ 人，即：

$$f_i = max_{j<i} (f_j + \frac{i-j}{i} )$$ 

有决策单调性，具体的，我们可以知道假如我们在将决策 $k$ 转移给了决策 $j$ ，其中 $k < j$ ，有

$$f_k + \frac{i - k}{i} < f_j + \frac{i - j}{i}$$ 

先由此证明决策是单调的，已知 $f_i$ 要尽可能大。同时，$i$ 增加时 $\frac{1}{i}$ 是在不断减小，说明 $f$ 是一个关于 $i$ 的上凸函数。继续化简式子，

$$f_j - f_k > \frac{j - k}{i}$$

$$\frac{f_j-f_k}{j - k} > \frac{1}{i}$$ 

我们可以二分切这个上凸函数的斜率。也就是说，我们可以二分 $\frac{1}{i}$ 切这个上凸壳 $f_j$ 的一条直线的斜率，把 $f_i$ 作为截距。然后做斜率优化即可。



### Code

[Code戳这里](https://tony102.xyz/index.php/2021/03/27/luogu5308-coci2019-quiz/)

---

## 作者：云岁月书 (赞：1)

## Solution:

讲一下思路过程：

看题面，考虑到参赛者位置不影响答案，可以将每一轮删除的人连起来，这样本题就和石子合并有点像，可以快速写出一个 $\mathcal{O}(n^2k)$ 的 $DP$ 方程：

$dp[k][j]$ 表示第 $k$ 轮还剩 $j$ 个人的最大收益。

$$dp[k][j] = \max(dp[k-1][i]+\frac{i-j}{i}),i > j$$

但是显然这个方程 $\mathcal{O}(n^2k)$ 的方程时间复杂度过大，考虑优化。

### 第一步优化

对于 $dp[k-1][i]+\frac{i-j}{i}$ 这样的形似 $dp[i]+W_i$ 的方程我们一般都会考虑单调队列优化或斜率优化，$W_i = \frac{i-j}{i}$ 是有形如 $ij$ 的式子,故使用斜率优化。

考虑两个决策点 $j_1,j_2$ 满足 $j_1$ 优于 $j_2$:

$$dp[k][j_1]+\frac{j_1-i}{j_1} \geqslant dp[k][j_2]+\frac{j_2-i}{j_2}$$

整理得到: $\frac{dp[k][j_1]-dp[k][j_2]}{j_1-j_2}\geqslant\frac{i}{j_1j_2}$ 发现 $j_1j_2$ 不方便处理。

走到这一步之后就需要较灵活的思维。

$j$ 是我们需要枚举的决策点，当使用它作为分母时就会产生上面的问题，考虑将 $j$ 换到分子上去。

不难发现**由于每一轮奖池不变，所以第 $k-1$ 轮对第 $k$ 轮并没有因为先后顺序产生的影响。**

故我们可以逆序处理。

**即一开始没有任何参赛者，每一轮往里面加参赛者。**

由此有新的 $DP$ 状态:

$dp[k][i]$ 表示第 $k$ 轮有 $i$ 名参赛者。

$$dp[k][i] = \max(dp[k-1][j]+\frac{i-j}{i}),i>j$$

斜率优化：

考虑两个决策点 $j_1,j_2$ 满足 $j_1$ 优于 $j_2$:

$$dp[k][j_1]+\frac{i-j_1}{i} \geqslant dp[k][j_2]+\frac{i-j_2}{i}$$

$$\frac{dp[k][j_1]-dp[k][j_2]}{j_1-j_2}\geqslant\frac{1}{i}$$

当然此时我们可以做到 $\mathcal{O}(nk\log{n})$。

$n \leqslant 3000$ 的数据有点勉强。

考虑到斜率优化的瓶颈在于二分凸包上，进一步优化：

~~打表发现转移具有单调性。~~

所以斜率优化可以做到 $\mathcal{O}(nk)$。

但是对于本题来说还是不够。

### 进一步优化，
**对于强制选 $k$ 个，可以使用 $wqs$ 二分优化掉第一维。**

此时仍可以使用斜率优化，原 $DP$ 方程化作：

$$dp[i] = \max(dp[j]+\frac{i-j}{i}),i>j$$

用 $lst[i]$ 记录分了几段。

二分每一段则需要的代价 $mid$。

最终答案是 $dp[n]+mid*K$(注意精度)。

最终复杂度 $\mathcal{O}(nlogk)$。

不过本题精度卡的有点紧,需要~~耗子尾汁~~才能一次过。

## Code:

~~~
# include <queue>
# include <cmath>
# include <cstring>
# include <cstdio>
# include <algorithm>
# define eps 1e-12

inline int Read()
{
    register int x = 0;char ch = getchar();
    
    while(ch < '0' || ch > '9')ch = getchar();
    
    while(ch >= '0' && ch <= '9'){x = x*10+(ch^48);ch = getchar();}
    
    return x;
}

const int N = 1e5;

double dp[N+5];
int lst[N+5],q[N+5],h,t,n,k;

# define Spole(x,y) ((dp[x]-dp[y])/(x-y))

bool Solve(const double mid)
{
    q[t = h = 1] = 0;lst[0] = 0;
    for(int i = 1; i <= n ; ++i)
    {
        //while(h < t && (dp[q[h+1]]-q[h] == 0 || (dp[q[h+1]]-q[h])*i > q[h+1]-q[h])) ++h;
        //while(h < t && (dp[q[h+1]]-dp[q[h]])*i < (q[h+1]-q[h])) ++h;
        while(h < t && Spole(q[h+1],q[h]) - 1.0/i > eps) ++h;
        dp[i] = dp[q[h]]+(i-(double)q[h])/i-mid;
        lst[i] = lst[q[h]]+1;//无限次试图拆开斜率的式子避开精度问题，却都没成功。
        while(h < t && Spole(i,q[t])-Spole(q[t],q[t-1]) > eps) --t;
        //while(h < t && (dp[i]-dp[q[t]])*(q[t]-q[t-1]) < (dp[q[t]-q[t-1]])*(i-q[t])) --t;
        q[++t] = i;
    }
    return lst[n] >= k;
}

int main()
{
    scanf("%d%d",&n,&k);
    double l = 0,r = 1,mid;
    for(int i = 1; i <= 100 ; ++i)
    {
        mid = (l+r)/2;
        if(Solve(mid)) l = mid;
        else r = mid;
    }
    printf("%.9lf",dp[n]+k*mid);
    return 0;
}
~~~

---

## 作者：lahlah (赞：1)


先不考虑$k$

考虑反过来DP

$f_i$表示还剩下$i$个人的最大奖金

显然

$f_i=\max(f_j+\frac{i-j}{i})$

$f_i-\frac{1}{i}(i-j)=f_j$

$f_i-1+\frac{1}{i}(j)=f_j$

$x_j=j$

$y_j=f_j$

$k_i=\frac{1}{i}$

$c_i=f_i-1$

斜率优化即可

加上$k$的限制就是一个wqs二分

关于wqs二分可以看我写的这篇blog

[浅谈wqs二分
](https://blog.csdn.net/qq_38944163/article/details/108627904)

对于这一题,减得越多，段数就会越少，二分的时候要注意一下

code:
```cpp
#include<bits/stdc++.h>
#define N 200005
using namespace std;
double f[N];
int cnt[N], q[N], n, k;
double y(int i) {return f[i]; }
double x(int i) {return i; }
double slope(int i, int j) {
	return (y(i) - y(j)) / (x(i) - x(j));
}
int check(double mid) {//斜率优化
	int l = 1, r = 1; q[l] = 0;
	for(int i = 1; i <= n; i ++) {
		while(l < r && slope(q[l], q[l + 1]) > 1.0 / i) l ++;
		int j = q[l];
		f[i] = f[j] + (i - j) * 1.0 / i - mid;//注意这里是要减
		cnt[i] = cnt[j] + 1;
		while(l < r && slope(q[r - 1], q[r]) < slope(q[r], i)) r --;
		q[++ r] = i; 
	}
	return cnt[n] >= k;
}
int main() {
	scanf("%d%d", &n, &k);
	double l = 0, r = 1e6;
	for(int i = 1; i <= 200; i ++) {
		double mid = (l + r) * 1.0 / 2.0;
		if(check(mid)) l = mid;
		else r = mid;
	}
	check(l);
	printf("%.9f", f[n] + l * k);
	return 0;
} 
```




---

## 作者：「　」 (赞：1)

纪念一下第二道 $\text{wqs}$ 二分题（我好弱啊），感觉题目很不错。

## 题解

按照 $\text{wqs}$ 二分的套路来，我们先不考虑轮数限制，大体思路上是需要倒序思考 $dp$ 过程，即
$$
f_i=\max_{j<i}(f_j+\frac{i-j}{i})
$$
但是你发现这个 $\text{dp}$ 是 $O(n^2)$ 的，本身就需要优化，发现可以斜率优化，即
$$
f_{i}=f_j+\frac{i-j}{i}\\
f_i\cdot i=f_j\cdot i+i-j\\
(f_j+1)\cdot i-f_i\cdot i=j\\
$$
我们维护点 $(f_j+1,j)$ 的下凸包，并在转移的时候用斜率 $i$ 去切它就可以了。

我们在此时需要将 $\text{wqs}$ 二分结合进去，即在每一次转移中都需要减去我们当前二分到的斜率 $k$ ，可以证明，这个斜率 $k\in (0,1]$ ，即
$$
f_i=\max_{j<i}(f_j+\frac{i-j}{i}-k)\\
(f_j+1-k)\cdot i-f_{i}\cdot i=j
$$
然后每一次二分后的 $\text{dp}$ 就维护点 $(f_j+1-k,j)$ 的下凸包，并用斜率 $i$ 去切它就可以了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define double long double
const int N=1e5+5;
int n,k;
struct Point{double x,y;};
struct Vector{double x,y;};
Vector operator - (Point a,Point b){return (Vector){a.x-b.x,a.y-b.y};}
double operator * (Vector a,Vector b){return a.x*b.y-a.y*b.x;}
double res=0,f[N];int g[N];
pair<Point,int> bag[N];
pair<int,double> cal(double k){
	int L=1,R=0;
	memset(f,0,sizeof(f)),memset(g,0,sizeof(g));
	f[1]=g[1]=1,bag[++R]=make_pair((Point){f[1]+1-k,1},g[1]);
	for(int i=2;i<=n;++i){
		while(R-L>0&&(bag[L+1].first-bag[L].first)*(Vector){1,1.0*i}>0) L++;
		f[i]=bag[L].first.x-bag[L].first.y/i,g[i]=bag[L].second+1;
		Point tmp=(Point){f[i]+1-k,1.0*i};
		while(R-L>0&&(bag[R].first-bag[R-1].first)*(tmp-bag[R-1].first)<0) R--;
		bag[++R]=make_pair(tmp,g[i]);
	}
	// for(int i=1;i<=n;++i) printf("%.9lf %d\n",f[i],g[i]);
	return make_pair(g[n],f[n]);
}
int main(){
	cin>>n>>k;
	double L=0,R=1;
	while((R-L)>1e-16){
		double Mid=(L+R)/2;pair<int,double> tmp=cal(Mid);
		// printf("%.9lf %d %.9lf\n",Mid,tmp.first,tmp.second);
		if(tmp.first>=k) res=tmp.second+Mid*(k-1),L=Mid;
		else R=Mid;
	}
	return printf("%.9Lf\n",res),0;
}
```



---

## 作者：huayucaiji (赞：0)

作为 wqs 二分的一道入门题，值得写一篇题解。

## 解题思路

首先我们考虑 $O(n^2k)$ 的普通 DP。

我们令 $f_{i,k}$​ 为考虑淘汰 $i$ 个人，分成 $k$ 轮淘汰的最大收益。我们可以得到转移方程：

$$f_{i,k}=\max\limits_{j=0}^{i-1} f_{j,k-1}+\frac{i-j}{i}$$

这个式子很难优化。二维的式子一般都很难进行优化。我们考虑化为一维状态，显然不太好化。

我们考虑先不管 $k$​ 的限制，那么我们有：

$$f_{i}=\max\limits_{j=0}^{i-1} f_{j}+\frac{i-j}{i}$$

这样我们对这个式子进行 DP。（显然不考虑 $k$ 后 $f_i=\sum\limits_{i=1}^i \frac 1i$，但是我们先不管这个）

对于 $k,j$ 两个转移点，若 $j$ 优于 $k$，我们有：

$$f_{j}+\frac{i-j}{i}>f_{k}+\frac{i-k}{i}$$

$$\frac{f_j-f_k}{j-k}>\frac 1i$$

显然可以进行斜率优化了。时间复杂度为 $O(n)$

我们在记录一个  $g_i$，记录 $f_i$ 这个状态分割了几段。显然，若最优转移点为 $j$，$g_i=g_j+1$。

现在考虑对于每次分割给予一些“奖赏”（“惩罚”也彳亍）。假设奖赏为 $x,x\in R$，则转移方程变成了：

$$f_{i}=\max\limits_{j=0}^{i-1} f_{j}+\frac{i-j}{i}+x $$

显然 $x$ 越小分的段数越少。~~读者自证不难~~

而且这个方程还是可以斜率优化，式子和上面那个一样。但是此时我们可以通过控制 $x$ 来控制分的段数。显然可以二分 $x$。每次检验 $g_n$ 与 $k$ 的关系即可。

二分出合适的 $x$ 后把奖赏退回去即可。

时间复杂度 $O(n\log N)$。

## 代码实现

```cpp
//Don't act like a loser.
//This code is written by huayucaiji
//You can only use the code for studying or finding mistakes
//Or,you'll be punished by Sakyamuni!!!
#include<bits/stdc++.h>
#define lb long double
using namespace std;

int read() {
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}

const int MAXN=1e5+10; 
const lb eps=1e-11;

int n,m,h,t;
int q[MAXN],g[MAXN];
lb f[MAXN];
lb k(int x,int y) {
	return (f[x]-f[y])/(x-y*1.0);
}

int dp(lb x) {
	h=t=1;
	q[1]=0;
	for(int i=1;i<=n;i++) {
		while(h<t&&k(q[h],q[h+1])>eps+1.00/i) {
			h++;
		}
		f[i]=f[q[h]]+(i*1.0-1.0*q[h])/(1.0*i)+x;
		g[i]=g[q[h]]+1;
		while(h<t&&k(q[t],q[t-1])+eps<k(q[t],i)) {
			t--;
		}
		q[++t]=i;
	}
	return g[n]>m;
}

signed main() {
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);

	cin>>n>>m;
	
	lb l=-1e9,r=1e9,mid=0;
	for(int i=1;i<=150;i++) {
		mid=(l+r)/2;
		if(dp(mid)) {
			r=mid;
		}
		else {
			l=mid;
		}
	}
	
	dp((l+r)/2);
	cout<<fixed<<setprecision(9)<<f[n]-mid*m<<endl;

	//fclose(stdin);
	//fclose(stdout);
	return 0;
}


```



---


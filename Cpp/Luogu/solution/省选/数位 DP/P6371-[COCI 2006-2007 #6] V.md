# [COCI 2006/2007 #6] V

## 题目描述

使用给定的数字，组成一些在 $[A,B]$ 之间的数使得这些数每个都能被 $X$ 整除。

## 说明/提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $1\le X\lt 10^{11}$，$1\le A\le B\lt 10^{11}$。
#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #6](https://hsin.hr/coci/archive/2006_2007/contest6_tasks.pdf) *T5 V***。

## 样例 #1

### 输入

```
2 1 20
0123456789```

### 输出

```
10```

## 样例 #2

### 输入

```
6 100 9294
23689```

### 输出

```
111```

## 样例 #3

### 输入

```
5 4395 9999999999
12346789```

### 输出

```
0```

# 题解

## 作者：xiaolilsq (赞：8)

[题目链接](https://www.luogu.com.cn/problem/P6371)

首先题目中的$[A,B]$让我们可以直接联想到用数位dp做，可以设$dp_{i,j,k}$表示位数为$i$，在模$X$的意义下余数为$X-j$，是否含前导零用$k$表示的方案数，那么有转移方程（需要保证转移合法）：

$$dp_{i,j,k}=\sum dp_{i-1,j^{'},k^{'}}$$

初始状态：

$$dp_{0,j,k}=[j==0]\&\&[k==0]$$

但是貌似数据范围中$X\le10^{11}$不可做？如果$X\le 10^{5}$可以直接用数位dp，当$X> 10^{5}$时，$A/X\le 10^6,B/X\le 10^6$，可以直接枚举所有$X$的倍数，判断是否满足每一位都满足要求，如果满足答案直接累加就可以了。

AC代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
template<typename T>void read(T &x){
	x=0;int f(1);char c(getchar());
	for(;!isdigit(c);c=getchar())if(c=='-')f=-f;
	for(; isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c-'0');
	x*=f;
}
template<typename T>void write(T x){
	if(x<0)putchar('-'),x=-x;
	if(x/10)write(x/10),x%=10;
	putchar(x+'0');
}
const int maxn=15,maxx=100005;
int tmp[maxn],vis[10];
long long dp[maxn][maxx][2],X;
long long dfs(int pos,int le,int _0,int up){
	if(pos==-1)return _0==0&&le==0;
	if(!up&&(~dp[pos][le][_0]))
		return dp[pos][le][_0];
	long long ans=0;
	int mx=up?tmp[pos]:9;
	for(int i=1;i<=mx;++i){
		if(vis[i])
			ans+=dfs(pos-1,(le*10+i)%X,_0&&i==0,up&&i==tmp[pos]);
	}
	if(_0)ans+=dfs(pos-1,0,1,up&&tmp[pos]==0);
	else if(vis[0])ans+=dfs(pos-1,le*10%X,false,up&&tmp[pos]==0);
	if(!up)dp[pos][le][_0]=ans;
	return ans;
}
long long solve(long long test){
	int cnt=0;
	while(test){
		tmp[cnt++]=test%10;test/=10;
	}
	return dfs(cnt-1,0,1,1);
}
int judge(long long test){
	while(test){
		if(!vis[test%10])return false;
		test/=10;
	}
	return true;
}
int main(){
	long long A,B;
	read(X),read(A),read(B);
	char c=getchar();
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())vis[c-'0']=true;
	if(X<=maxx){
		memset(dp,-1,sizeof dp);
		write(solve(B)-solve(A-1));
		putchar('\n');
	}
	else{
		int l=(int)((A-1)/X+1),r=(int)(B/X),ans=0;
		for(int x=l;x<=r;++x)
			if(judge(1ll*X*x))++ans;
		write(ans),putchar('\n');
	}
	return 0;
}

```

另：这可能并不是最优的写法，但是可以过这道题，欢迎大家想出更好的方法。

$\color{white}\text{看在我是第二个过这题的人份上，求过审qwq}$

---

## 作者：大眼仔Happy (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P6371)

# 分析

第一眼看，巧了，这不是很板的数位 dp 模板题吗？然而一看数据范围有点懵。

- $X\le 10^{11}$。

**于是根号分治就登场了。**（具体我自己也不太清楚什么是根号分治啊，我的理解就是根据数据的大小分类，然后再根据每一类的特点处理，搞错了请指出。）

首先假设一个分界点 $Lim$ 吧，我们等一下再讨论取多少好。

先讲 $X\le Lim$ 的情况，显然就是一个很经典的数位 dp。设 $f_{pos,sum,lim,z}$ 表示已经填了第 $pos$ 位（准备填 $pos+1$ 位），当前的数模 $X$ 为 $sum$，填 $pos+1$ 是否有限制，是否含前导零。~~emmm，或许和别人的有点不一样。~~

显然，$f_{pos,sum,lim,z}\xleftarrow{}f_{pos+1,(sum\times 10+i)\bmod X,\ ...\ ,\ ...\ }$。所以最后判断一下 $sum$ 是否等于 $0$ 即可。

下面讲一下 $x>Lim$ 的情况。因为这时 $X$ 已经足够大了，显然上面的方法不行了。但是我们可以发现在这个范围 $X$ 的倍数很少，那么可以直接枚举这些倍数了。

忘记了 $Lim$ 的取值，**如果算的话**，大概是 $10^4\sim 10^6$ 吧。

# 坑点

这题我遇到了不少的坑的，来和大家分享一下吧。

首先一个就是前导零，以为不用写前导零就没写，结果连样例都没过，第二个样例就输出了 $91$。

然后还有就是**实际**的 $Lim$ 的取值，一开始我取的是 $10^5$ 的，结果就 MLE 了。于是改了一个 $10^4$ 之后就过了。其实也挺快的。

[ MLE 记录](https://www.luogu.com.cn/record/102228000)

[ AC 记录](https://www.luogu.com.cn/record/102228014)

# Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll Lim=1e4;
ll X,a,b;
ll s[15],num[10],n,len;
string str;
bool t[15];
ll f[15][Lim][2][2];
bool v[15][Lim][2][2];
ll dfs(int pos,ll sum,bool lim,bool z)
{
	if(pos==len)return (sum==0);
	if(v[pos][sum][lim][z])return f[pos][sum][lim][z];
	v[pos][sum][lim][z]=1;
	if(z)
	{
		f[pos][sum][lim][z]+=dfs(pos+1,0,lim&(s[pos+1]==0),1);
		for(int i=0;i<n;i++)
		{
			ll x=num[i];
			if(lim&&x>s[pos+1]||x==0)continue;
			f[pos][sum][lim][z]+=dfs(pos+1,(sum*10+x)%X,lim&(x==s[pos+1]),0);
		}
	}
	else 
	{
		for(int i=0;i<n;i++)
		{
			ll x=num[i];
			if(lim&&x>s[pos+1])continue;
			f[pos][sum][lim][z]+=dfs(pos+1,(sum*10+x)%X,lim&(x==s[pos+1]),0);
		}
	}
	return f[pos][sum][lim][z];
}
bool pd(ll x)
{
	while(x)
	{
		if(!t[x%10])return false;
		x/=10;
	}
	return true;
}
ll solve(ll x)
{
	if(X>Lim)
	{
		ll ans=0;
		for(ll i=X;i<=x;i+=X)ans+=pd(i);
		return ans;
	}
	memset(s,0,sizeof(s));len=0;
	while(x)s[++len]=x%10,x/=10;
	for(int i=1;i<=len/2;i++)swap(s[i],s[len-i+1]);
	memset(f,0,sizeof(f));memset(v,0,sizeof(v));
	return dfs(0,0,1,1);
}
int main(){
	scanf("%lld%lld%lld",&X,&a,&b);
	cin>>str;n=str.size();
	for(int i=0;i<n;i++)num[i]=str[i]-'0',t[str[i]-'0']=1;
	printf("%lld",solve(b)-solve(a-1));
	return 0;
}
```


---

## 作者：Ginger_he (赞：3)

本文同步更新于[博客园](https://www.cnblogs.com/Gingerhe/p/16056907.html)
# 题目描述
使用给定的数字，组成一些在 $[A,B]$ 之间的数使得这些数每个都能被 $X$ 整除。
# 题解
对于 $X>10^5$，我们可以直接枚举 $X$ 的倍数，然后判断其是否符合条件。  
对于 $X\leqslant10^5$，则使用数位 dp。我们传四个参数 $k,s,t,u$ 进入 dfs，分别表示第 $k$ 位，模 $X$ 的余数为 $s$，这一位填的数有没有限制以及是否为前导 $0$，用 $f$ 数组记忆化即可。
## 注意
要区分前导 $0$ 和题目中给定的 $0$。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=1e5+5;
int len,a[15];
ll p,l,r,f[15][maxn];
bool vis[15];
char s[15];
ll dfs(int k,int s,int t,int u)
{
	if(!k)
		return s?0:1;
	if(!t&&!u&&f[k][s]!=-1)
		return f[k][s];
	int x=t?a[k]:9;
	ll res=0;
	if(u)
		res+=dfs(k-1,0,t&&!x,1);
	for(int i=0;i<=x;i++)
	{
		if(vis[i])
		{
			if(u&&!i)
				continue;
			res+=dfs(k-1,(s*10+i)%p,t&&(i==x),0);
		}
	}
	if(!t&&!u)
		f[k][s]=res;
	return res;
}
ll divide(ll x)
{
	len=0;
	while(x)
	{
		a[++len]=x%10;
		x/=10;
	}
	return dfs(len,0,1,1);
}
bool check(ll x)
{
	while(x)
	{
		if(!vis[x%10])
			return 0;
		x/=10;
	}
	return 1;
}
int main()
{
	memset(f,-1,sizeof(f));
	scanf("%lld%lld%lld\n%s",&p,&l,&r,s+1);
	for(int i=1;s[i];i++)
		vis[s[i]-'0']=1;
	if(p<maxn)
		printf("%lld\n",divide(r)-divide(l-1));
	else
	{
		ll tmp=l%p?l/p+1:l/p,ans=0;
		for(ll i=tmp*p;i<=r;i+=p)
			ans+=check(i);
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：sunkuangzheng (赞：2)

**【题目分析】**

本题要用到一种~~臭名昭著~~美名远扬的算法——数据点分治！

相信拿到这题的你一定是通过 `数位 dp` 标签点进来的吧！所以我们先说这一部分解法。朴素地，设 $f_{pos,sum,lim,pre}$ 表示当前到第 $i$ 位时数字和 $\bmod x = sum$，此时上限状态为 $lim$，前导零状态为 $pre$。按 `数位 dp` 的常规思路，可以得到下面的代码：

```cpp
int dfs(int pos,int sm,bool lim,bool pre){
	if(f[pos][sm][lim] != -1 && !pre) return f[pos][sm][lim];//记忆化搜索
	if(pos == 1) return sm == 0;
	int up = lim ? num[pos-1] : 9,ans = 0;//确定上限
	for(int i = 0;i <= up;i ++){
		if(i == 0 && pre) ans += dfs(pos-1,sm,0,1);
		if(c[i] && (i != 0 || !pre)) ans += dfs(pos-1,(sm*10 + i) % x,lim && i == up,pre && i == 0);
      //特别注意对 0 的处理，小心漏算和重算
	}
	if(!pre) f[pos][sm][lim] = ans;
	return ans;
}
```

我们发现这样的做法只能解决 $X \le 10^5$ 的情况，再大就会内存超限。

那么对于 $10^5 \le X \le 10^{11}$ 怎么办呢？其实更简单，我们采用暴力枚举！这样最多计算 $10^6 \times 11 = 1.1 \times 10^7$ 次，可以 AC 本题。完整代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
bool c[15];
int x,a,b,f[13][100001][2],n,num[15],res;
string s;
int dfs(int pos,int sm,bool lim,bool pre){
	if(f[pos][sm][lim] != -1 && !pre) return f[pos][sm][lim];
	if(pos == 1) return sm == 0;
	int up = lim ? num[pos-1] : 9,ans = 0;
	for(int i = 0;i <= up;i ++){
		if(i == 0 && pre) ans += dfs(pos-1,sm,0,1);
		if(c[i] && (i != 0 || !pre)) ans += dfs(pos-1,(sm*10 + i) % x,lim && i == up,pre && i == 0);
	}
	if(!pre) f[pos][sm][lim] = ans;
	return ans;
}
int work(int k){
	memset(f,-1,sizeof(f));
	n = 0;
	while(k){
		num[++n] = k % 10;
		k /= 10;
	}
	return dfs(n+1,0,1,1);
}
bool check(int x){
	while(x){
		if(!c[x % 10]) return 0;
		x /= 10;
	}
	return 1;
}
signed main(){
	cin >> x >> a >> b >> s;
	for(int i = 0;i < s.size();i ++) c[s[i] - '0'] = 1;
	if(x <= 1e5) cout << work(b) - work(a-1);
	else{
		for(int i = x;i <= b;i += x) if(i >= a && check(i)) res ++;
		cout << res;	
	}
	return 0;
}
```

**【后记】**

注意到进行数位 dp 时，没有采取常规的方法将 $pre$ 作为数组一维，这是因为丧心病狂的出题人空间开的太小，会爆掉！

---

## 作者：chlchl (赞：2)

## 题意简述
用给定的数字组成 $\lbrack l,r\rbrack$ 内的数，问有多少个数能被 $x$ 整除。

## 做法
明显这是一个数位 DP。我们的记忆化搜索应该记录当前到第几位 $len$、当前数的类型 $op$、是否为前导零 $is0$，当前数 $\bmod\ x$ 的值 $mod$。

这样做有个问题：对于 $x$ 比较大的情况，你的数组会开得奇大无比。这时，需要用到类似根号分治的分段思想：对于 $x\leq 10^5$ 的情况，直接 DP 即可。对于 $x>10^5$ 的情况，其倍数最多不超过 $10^6$ 个，可以直接枚举其倍数，依次检验是否可以用数字串组成。

但是这道题的空间限制为 31.25MB，如果直接记录 $f_{len,op,is0,mod}$ 是会 MLE 的，可以省去 $is0$ 那一维，当不是前导零的时候才记录（因为前导零的情况肯定是 $0$ 种）。

最后，有一个非常坑的情况：如果你一直 $93$ 分，并且 WA 在了第 $9$ 个点：[比如这样](https://www.luogu.com.cn/record/86628559)。你需要注意：对于 $0$ 不可用的情况，如果当前仍然是前导零，是可以传 $0$ 进去的（因为前导零最终并不出现在这个数中）。所以 $0$ 是要特判的。

代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 12 + 5;
ll x, l, r, dgt[N], f[N][2][100010];
char s[20];
bool ok[N];

ll dp(int len, int op, int is0, ll mod){
	if(len <= 0)	return (mod ? 0 : 1);
	if(!is0 && f[len][op][mod] != -1)	return f[len][op][mod];
	ll cnt = 0; int k = (op ? dgt[len] : 9);
    if(ok[0])   cnt += dp(len - 1, op & (!k), is0, mod * 10LL % x);
    else if(is0)    cnt += dp(len - 1, 0, 1, 0);//特判 0
	for(int d=1;d<=k;d++){
		if(!ok[d])	continue;//这个数字不可用，跳过
		cnt += dp(len - 1, op & (d == k), is0 & (d == 0), (mod * 10LL + d) % x);
	}
	if(!is0)    f[len][op][mod] = cnt;
	return cnt;
}

ll solve(ll now){
	int len = 0;
	do	dgt[++len] = now % 10;
	while(now /= 10);
	memset(f, -1, sizeof(f));
	return dp(len, 1, 1, 0LL);
}

int main(){
	scanf("%lld%lld%lld", &x, &l, &r);
	scanf("%s", s + 1);
	for(int i=1;s[i];i++)	ok[s[i] - '0'] = 1;
	if(x <= 100000LL)	return printf("%lld\n", solve(r) - solve(l - 1)), 0;
	ll cnt = 0;
	for(ll i=x;i<=r;i+=x){//x>100000，直接枚举所有倍数
        if(i < l)  continue;
		ll j = i, f = 1;
		while(j){
			f = ok[j % 10] ? 1 : 0;
			if(!f)	break;
			j /= 10;
		}//检查这个数能不能蓓表示出来
		if(f)	cnt++;
	}
	printf("%lld\n", cnt);
	return 0;
}
```


---

## 作者：AE酱 (赞：2)

数位dp。
设 $dp[pos][num]$ 表示枚举到第 $pos$ 位，并且前面的位数模 $X$ 为 $num$ 时，使得最终能被 $X$ 整除的数的个数。那么容易进行状态转移。  

但是发现 $X$ 达到 $10^{11}$，$dp$ 数组开不下，我们可以使用 map 来代替 $dp$ 数组。但直接这样写将会 MLE 1个点。容易想到保存的无用的状态太多，很多情况答案都是为0的，我们考虑进行剪枝。  

设当前枚举到第 $pos$ 位，并且前面的位数模 $X$ 为 $num$ ，设 $temp=(X-num\times10^{pos}) \mod X$，设能使用的最大的数字为 $maxnum$，那么若剩下的 $pos$ 位数字全由 $maxnum$ 组成，但仍比 $temp$ 小，说明这样DFS下去必然不可能使得模数为0，直接剪枝即可。

AC代码：
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
#include <cstdio>
#include <vector>
#include <map>
using namespace std;

#define RG register int
#define LL long long

bool cnt[10];
int a[20];
char str[20];
map<LL,LL> dp[12];
LL Div;
int maxnum;

LL DFS(int pos,bool limit,bool lead,LL num){
    if(!pos) return num==0?1:0;
    if(!limit && !lead && dp[pos].count(num)) return dp[pos][num];
    int up=limit?a[pos]:9;
    LL Res=0;
    LL temp=num,temp2;
    for(int i=1;i<=pos;++i)
        temp=temp*10LL%Div;
    temp2=((Div-temp)%Div+Div)%Div;
    temp=0;
    for(int i=1;i<=pos;++i)
        temp=temp*10LL+maxnum;
    if(temp<temp2){
        if(!limit && !lead) dp[pos][num]=Res;
        return Res;
    }
    for(int i=0;i<=up;++i)
        if(cnt[i] || (i==0 && lead))
            Res+=DFS(pos-1,limit && i==up,lead && i==0,(num*10LL+i)%Div);
    if(!limit && !lead) dp[pos][num]=Res;
    return Res;
}

LL Solve(LL x){
    int pos=0;
    while(x){a[++pos]=x%10;x/=10;}
    return DFS(pos,true,true,0);
}

int main(){
    LL L,R;
    scanf("%lld%lld%lld",&Div,&L,&R);
    scanf("%s",str);
    int len=strlen(str);
    for(RG i=0;i<len;++i){
        cnt[str[i]-'0']=true;
        maxnum=max(maxnum,(int)(str[i]-'0'));
    }
    printf("%lld\n",Solve(R)-Solve(L-1));

    return 0;
}
```

---

## 作者：LCat90 (赞：1)

如果 $X$ 很小的话，我们完全可以定义 $dp_{pos,sum}$ 表示到第 $pos$ 位的当前数组模 $X$ 的值为 $sum$ 的数字个数，朴素地数位 dp 即可。但是 $X\le 10^{11}$。

考虑根号分治。发现当 $X$ 很大的时候暴力是极快的。于是我们 $L=10^5$ 左右。如果 $X\ge L$ 直接暴力，否则 $X\le 10^5$，数位 dp 可以做了。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5 + 5;
int a[15], cnt, chu;
bool vis[15];
int dp[15][N]; // pos sum 
int dfs(int pos, int sum, bool limit, bool f1) {
	if(pos == 0) return sum == 0;
	if(!limit and !f1 and ~dp[pos][sum]) return dp[pos][sum];
	int up = (limit ? a[pos] : 9), ans = 0;
	for(int i = 0;i <= up; ++i)
		if(vis[i] or (i == 0 and f1))
		ans += dfs(pos - 1, (sum * 10 + i) % chu, limit and i == up, f1 and i == 0);
	if(!limit and !f1) dp[pos][sum] = ans;
	return ans;
}
int solve(int x) {	
	memset(dp, -1, sizeof dp);
	cnt = 0;
	while(x) a[++cnt] = x % 10, x /= 10;
	return dfs(cnt, 0, 1, 1); 
}
int l, r;
string s; int ans;
signed main() {
	cin >> chu >> l >> r;
	cin >> s;
	for(int i = 0;i < s.size(); ++i) vis[s[i] - '0'] = 1;
	if(chu <= 1e5) return printf("%lld", solve(r) - solve(l - 1)), 0;
	for(int i = chu;i <= r;i += chu) {
		if(i < l) continue ;
		int cnt = i; bool f = 1;
		while(cnt) {
			f &= vis[cnt % 10];
			cnt /= 10;
		}
		ans += f;
	}
	cout << ans;
	return 0;	
}
/* 根号分治
对于 x >= 10^5 直接暴力找然后判断
否则 x 已经非常小了，直接 dp 即可 
*/ 
```

---

## 作者：TernaryTree (赞：1)

根号分治，若 $X\le B$ 是数位 dp 板子，复杂度 $\Theta(|S|B\log V)$；否则暴力枚举 $X$ 倍数判断，复杂度 $\Theta\left(\dfrac VB\right)$。当 $B=\sqrt{\dfrac{V}{|S|\log V}}\approx 3\times 10^4$ 时最优。总复杂度 $\Theta(\sqrt{|S|V\log V})$。代码不放了。

---

## 作者：ilibilib (赞：0)

## 分析：

数位 DP 的板子，不过需要对于不同范围的 $x$  特殊处理一下。

$x\le 10^6$ 时：

让 $DP_{i,j}$ 表示枚举到第 $i$ 位时模数为 $j$ 的答案，然后就是标准的记忆化搜索数位 DP。复杂度为 $O(x\times \lg AB)$。

不过需要注意的是，前导 $0$ 一定是可放的，然而 $0$ 这个数字在中间不一定是可放的，所以要加个变量记录当前是不是还没开始放数。

$x\geq 10^6$ 时：

枚举即可。

## code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10,lim=1e6;
int dp[20][N][2],mx[N];
int x;
bool f[20],vis[20][N][2];
inline int dfs(int len,int sum,bool lim,bool bg)
{
    if(!len) return (sum==0);
    if(!lim)
    {
        if(vis[len][sum][bg]) return dp[len][sum][bg];
        vis[len][sum][bg]=true;
        for(int i=0;i<=9;++i) if(f[i]||(i==0&&!bg)) dp[len][sum][bg]+=dfs(len-1,(sum*10+i)%x,0,max((long long)bg,i));
        return dp[len][sum][bg];
    }
    else
    {
        int ans=0;
        for(int i=0;i<mx[len];++i) if(f[i]||(i==0&&!bg)) ans+=dfs(len-1,(sum*10+i)%x,0,max((long long)bg,i));
        if(f[mx[len]]) ans+=dfs(len-1,(sum*10+mx[len])%x,1,1);
        return ans;
    }
}
int solve(int n)
{
    int len=0,ans=0;
    for(;n;n/=10) mx[++len]=n%10;
    return dfs(len,0,1,0);
}
bool check(int n)
{
    for(;n;n/=10) if(!f[n%10]) return false;
    return true;
}
signed main()
{
    int l,r;string s;
    cin>>x>>l>>r;
    cin>>s;for(int i=0;s[i];++i) f[s[i]-'0']=true;
    if(x<=lim) cout<<solve(r)-solve(l-1);
    else
    {
        int ans=0;
        for(int i=(l/x)*x;i<=r;i+=x) if(i>=l&&i<=r) ans+=check(i);
        cout<<ans;
    }
    return 0;
}
```

---

## 作者：Daniel2020 (赞：0)

~~从[这道题](https://www.luogu.com.cn/problem/AT_arc052_d)来的，发现也没有折半搜索的题解，赶紧写一篇。~~
 
$10^{11}$ 的数据范围提示我们的复杂度在 $O(\sqrt{n})$ 左右。考虑对于一个数 $x$，设 $p = 10^5,x = ap+b$。此时发现 $a < 10^6,b < 10^5$，于是考虑预处理所有合法的小于 $10^6$ 的数。预处理所有的 $b$ 存入桶中，枚举 $a$ 并计算 $ap$。又有 $ap+b \equiv 0\pmod{X}$，所以对于一个 $a$，可以在桶中 $O(1)$ 查找所以合法的 $b$ 的数量。

注意特判两种情况：

1. $a$ 取到了上界，此时 $b$ 不一定能取到上界，但是此时未判断的数至多有 $10^5$ 个，暴力枚举即可。也可以预处理并优先计算这一部分的贡献避免暴力枚举。 
2. $a \neq 0$。此时如果不能选 $0$ 的话，$b$ 不能有前导 $0$。单独开另一个桶计算即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 12,M = 1e6+7;
int k,l,r,n,p = 1e5;
int t[N],f[M],a[M],b[M];
char s[N];
inline void add(int x)
{
	if(!f[x]) return;
	a[x%k]++;
	if(x > 9999) b[x%k]++;
}
inline void ask(int w,int lim,int &ans)
{
	if(w >= p) return;
	if(!lim) return ans += a[w],void(0);
	if(!f[lim]) return;
	ans += t[0]?a[w]:b[w];
}
inline int fun(int n)
{
	int lim = n/p,rem = n%p,ans = 0;
	for(int i = 0;i < p;i++)
		a[i] = b[i] = 0;
	for(int i = 0;i <= rem;i++)
		add(i);
	ask((k-lim*p%k)%k,lim,ans);
	for(int i = rem+1;i < p;i++)
		add(i);
	for(int i = 0;i < lim;i++)
		ask((k-i*p%k)%k,i,ans);
	return ans;
}
signed main()
{
	scanf("%lld%lld%lld%s",&k,&l,&r,s);
	n = strlen(s);
	for(int i = 0;i < n;i++)
		t[s[i]-'0'] = 1;
	for(int i = 0;i < 10;i++)
		f[i] = t[i];
	for(int i = 1;i < 100000;i++)
		for(int j = 0;j < 10;j++)
			f[(i<<3)+(i<<1)+j] = f[i]&t[j];
	printf("%lld",fun(r)-fun(l-1));
 	return 0;
}
```


---

## 作者：happybob (赞：0)

一个比较有趣的数位 DP。

考虑当 $X$ 比较大的时候，可以暴力枚举 $X$ 的所有倍数，判断是否可行，这个的复杂度是 $O(\dfrac{B}{X})$ 的。这个过程类似根号分治，当 $X>L$ 时暴力，我的做法中取 $L=10^4$。

对于 $X \leq L$，考虑数位 DP。平凡的，只需要在 DP 的时候记录当前的数对 $X$ 取模的结果即可。由于 $X \leq 10^4$，所以数组一定开得下。

有一点需要注意，如果 $0$ 不能用，要注意前导 $0$ 仍可以用。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
using namespace std;

const int LIM = 1e4;
const int N = 13;

long long x, a, b;
string s;
bool flag[N];

long long solve1()
{
	for (auto& i : s) flag[i - '0'] = 1;
	long long ans = 0LL;
	for (long long i = x; i <= b; i += x)
	{
		if (i < a) continue;
		string ss = to_string(i);
		for (auto& i : ss)
		{
			if (!flag[i - '0'])
			{
				goto E;
			}
		}
		ans++;
	E:;
	}
	return ans;
}

long long dp[N][LIM + 5][2][2];
string p;

long long dfs(int u, long long r, bool flag, bool zgw)
{
	if (~dp[u][r][flag][zgw]) return dp[u][r][flag][zgw];
	dp[u][r][flag][zgw] = 0;
	if (r == 0 && u == p.size())
	{
		if (!flag)
		{
			dp[u][r][flag][zgw] = 1;
		}
	}
	if (u > p.size() - 1) return dp[u][r][flag][zgw];
	int nowlim = (zgw ? p[u] - '0' : 9);
	for (auto& i : s)
	{
		int gg = i - '0';
		if (gg <= nowlim)
		{
			dp[u][r][flag][zgw] += dfs(u + 1, (r * 10LL + gg) % x, (flag && gg == 0), (zgw && gg == nowlim));
		}
	}
	if (flag && s.find("0") == -1)
	{
		dp[u][r][flag][zgw] += dfs(u + 1, 0LL, 1, 0);
	}
	return dp[u][r][flag][zgw];
}

long long solve2()
{
	p = to_string(b);
	p = " " + p;
	memset(dp, -1, sizeof dp);
	long long ans1 = dfs(1, 0, 1, 1);
	p.clear();
	p = to_string(a - 1);
	p = " " + p;
	memset(dp, -1, sizeof dp);
	long long ans2 = dfs(1, 0, 1, 1);
	return ans1 - ans2;
}

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> x >> a >> b >> s;
	if (x > LIM) cout << solve1() << "\n";
	else cout << solve2() << "\n";
	return 0;
}
```


---

## 作者：15066212pp (赞：0)

# 题目描述

使用给定的数字，组成一些在 $[A,B]$ 之间的数使得这些数每个都能被 $X$ 整除。

------------

# 题解

对于 $X < 8000$ 的情况，我们可以使用数位 dp 算法来求解。

对于 $X \ge 8000$ 的情况，我们可以使用枚举的方法来求解。

## 数位 dp 算法说明

### 参数说明

- $n$ 当前处理的位数。

- $sum$ 当前累积的和。

- $limit$ 是否限制当前位数的取值范围。

- $zero$ 是否存在前导零。


### 细节一

一个优化方法是将记忆数组设为全局变量。

这样，在处理相同的给定数字时，我们无需重新初始化记忆数组，而是直接复用已有的记忆化数组。

这种优化方法适用于一些其他问题，例如杨辉三角。

### 细节二

只有记忆数组 $meo[size - n][sum]$ 可以被复用，而对于记忆数组 $meo[n][sum]$，每次都需要重新初始化。

------------

## java Code

```java
import java.util.*;

class Solution {
    public static final long[][] meo = new long[15][8000]; // 可以重复使用
    public long size;
    public long mod;
    public List<Long> list;
    public List<Long> nums;

    public Solution() {
    }

    public Solution(long p) {
        for (int i = 0; i < meo.length; i++) {
            for (int j = 0; j < meo[0].length; j++) {
                meo[i][j] = -1L;
            }
        }
        mod = p;
    }

    public static boolean check(String A, Set<Character> set) {
        for (char c : A.toCharArray()) {
            if (!set.contains(c)) {
                return false;
            }
        }
        return true;
    }

    public long solve(String digits, long n) {
        if (mod < 8000) {
            return solveLow(digits, n);
        }
        long res = 0;
        Set<Character> set = new HashSet<>();
        for (char c : digits.toCharArray()) {
            set.add(c);
        }
        for (long i = 0; i <= n; i += mod) {
            String val = String.valueOf(i);
            if (check(val, set)) {
                res++;
            }
        }
        return res;
    }

    public long solveLow(String digits, long n) {
        list = new ArrayList<>();
        nums = new ArrayList<>();
        for (char c : digits.toCharArray()) {
            nums.add((long) (c - '0'));
        }
        Stack<Long> st = new Stack<>();
        while (n > 0) {
            st.push(n % 10);
            n /= 10;
        }
        size = st.size();
        while (!st.empty()) {
            list.add(st.pop());
        }
        return dfs(0, 0, true, true);
    }

    public long dfs(long n, long sum, boolean limit, boolean zero) {
        if (n == size) {
            return !zero && (sum % mod == 0) ? 1 : 0;
        }
        if (!limit && !zero && meo[(int) (size - n)][(int) sum] != -1) {
            return meo[(int) (size - n)][(int) sum];
        }
        long res = zero ? dfs(n + 1, sum % mod, false, true) : 0;
        long start = zero ? 1 : 0;
        long up = limit ? list.get((int) n) : 9;
        for (long i : nums) {
            if (i < start) {
                continue;
            }
            if (i > up) {
                break;
            }
            res += dfs(n + 1, (sum * 10 + i) % mod, limit && (i == up), false);
        }
        if (!limit && !zero) {
            meo[(int) (size - n)][(int) sum] = res;
        }
        return res;
    }
}

class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        long mod = scanner.nextLong();
        long A = scanner.nextLong();
        long B = scanner.nextLong();
        String number = scanner.next();
        Solution tool = new Solution(mod);
        long res = tool.solve(number, B) - tool.solve(number, A - 1);
        System.out.println(res);
    }
}
```

------------

## cpp Code

```cpp
#include<bits/stdc++.h>

using namespace std;
typedef long long LL;

vector<vector<LL>> meo(15, vector<LL>(8000, -1));

class Solution {
public:
    LL size{};
    LL mod{};

    vector<LL> list;
    vector<LL> nums;

    Solution() = default;

    explicit Solution(LL p) {
        mod = p;
        for (auto &i: meo) {
            for (auto &j: i) {
                j = -1;
            }
        }
    }

    LL solve(const string &digits, LL n) {
        if (mod < 8000) {
            return solveLow(digits, n);
        }
        LL res = 0;
        unordered_set<char> set;
        for (char c: digits) {
            set.insert(c);
        }
        for (LL i = 0; i <= n; i += mod) {
            string val = to_string(i);
            if (check(val, set)) {
                res++;
            }
        }
        return res;
    }

    static bool check(const string &A, const unordered_set<char> &set) {
        return all_of(A.begin(), A.end(), [&](char c) {
            return set.count(c) != 0;
        });
    }

    LL solveLow(const string &digits, LL n) {
        list.clear();
        nums.clear();
        for (char i: digits) {
            nums.push_back(i - '0');
        }
        stack<LL> st;
        while (n > 0) {
            st.push(n % 10);
            n /= 10;
        }
        size = (LL) st.size();
        while (!st.empty()) {
            list.push_back(st.top());
            st.pop();
        }
        return dfs(0, 0, true, true);
    }

    LL dfs(LL n, LL sum, bool limit, bool zero) { // NOLINT(*-no-recursion)
        if (n == size) {
            return !zero && (sum % mod == 0) ? 1 : 0;
        }
        if (!limit && !zero && meo[size - n][sum] != -1) {
            return meo[size - n][sum];
        }
        LL res = zero ? dfs(n + 1, sum % mod, false, true) : 0;
        LL start = zero ? 1 : 0;
        LL up = limit ? list[n] : 9;
        for (LL i: nums) {
            if (i < start) {
                continue;
            }
            if (i > up) {
                break;
            }
            res += dfs(n + 1, (sum * 10 + i) % mod, limit && (i == up), false);
        }
        if (!limit && !zero) {
            meo[size - n][sum] = res;
        }
        return res;
    };
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    LL mod, A, B;
    string number;
    cin >> mod >> A >> B >> number;
    Solution tool(mod);
    LL res = tool.solve(number, B) - tool.solve(number, A - 1);
    cout << res << endl;
}
```


---

